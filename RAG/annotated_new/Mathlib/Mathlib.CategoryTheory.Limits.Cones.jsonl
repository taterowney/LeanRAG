{"name":"CategoryTheory.Functor.cones_obj","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nX : Opposite C\n‚ä¢ Eq (F.cones.obj X) (Quiver.Hom ((CategoryTheory.Functor.const J).obj (Opposite.unop X)) F)","decl":"/-- If `F : J ‚•§ C` then `F.cones` is the functor assigning to an object `X : C` the\ntype of natural transformations from the constant functor with value `X` to `F`.\nAn object representing this functor is a limit of `F`.\n-/\n@[simps!]\ndef cones : C·µí·µñ ‚•§ Type max u‚ÇÅ v‚ÇÉ :=\n  (const J).op ‚ãô yoneda.obj F\n\n"}
{"name":"CategoryTheory.Functor.cones_map_app","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nX‚úù Y‚úù : Opposite C\nf : Quiver.Hom X‚úù Y‚úù\na‚úù : (CategoryTheory.yoneda.obj F).obj ((CategoryTheory.Functor.const J).op.obj X‚úù)\nX : J\n‚ä¢ Eq ((F.cones.map f a‚úù).app X) (CategoryTheory.CategoryStruct.comp f.unop (a‚úù.app X))","decl":"/-- If `F : J ‚•§ C` then `F.cones` is the functor assigning to an object `X : C` the\ntype of natural transformations from the constant functor with value `X` to `F`.\nAn object representing this functor is a limit of `F`.\n-/\n@[simps!]\ndef cones : C·µí·µñ ‚•§ Type max u‚ÇÅ v‚ÇÉ :=\n  (const J).op ‚ãô yoneda.obj F\n\n"}
{"name":"CategoryTheory.Functor.cocones_map_app","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nX‚úù Y‚úù : C\nf : Quiver.Hom X‚úù Y‚úù\na‚úù : (CategoryTheory.coyoneda.obj { unop := F }).obj ((CategoryTheory.Functor.const J).obj X‚úù)\nX : J\n‚ä¢ Eq ((F.cocones.map f a‚úù).app X) (CategoryTheory.CategoryStruct.comp (a‚úù.app X) f)","decl":"/-- If `F : J ‚•§ C` then `F.cocones` is the functor assigning to an object `(X : C)`\nthe type of natural transformations from `F` to the constant functor with value `X`.\nAn object corepresenting this functor is a colimit of `F`.\n-/\n@[simps!]\ndef cocones : C ‚•§ Type max u‚ÇÅ v‚ÇÉ :=\n  const J ‚ãô coyoneda.obj (op F)\n\n"}
{"name":"CategoryTheory.Functor.cocones_obj","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nX : C\n‚ä¢ Eq (F.cocones.obj X) (Quiver.Hom F ((CategoryTheory.Functor.const J).obj X))","decl":"/-- If `F : J ‚•§ C` then `F.cocones` is the functor assigning to an object `(X : C)`\nthe type of natural transformations from `F` to the constant functor with value `X`.\nAn object corepresenting this functor is a colimit of `F`.\n-/\n@[simps!]\ndef cocones : C ‚•§ Type max u‚ÇÅ v‚ÇÉ :=\n  const J ‚ãô coyoneda.obj (op F)\n\n"}
{"name":"CategoryTheory.cones_map_app_app","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nX‚úù¬π Y‚úù : CategoryTheory.Functor J C\nf : Quiver.Hom X‚úù¬π Y‚úù\nX‚úù : Opposite C\na‚úù : (CategoryTheory.yoneda.obj X‚úù¬π).obj ((CategoryTheory.Functor.const J).op.obj X‚úù)\nX : J\n‚ä¢ Eq ((((CategoryTheory.cones J C).map f).app X‚úù a‚úù).app X) (CategoryTheory.CategoryStruct.comp (a‚úù.app X) (f.app X))","decl":"/-- Functorially associated to each functor `J ‚•§ C`, we have the `C`-presheaf consisting of\ncones with a given cone point.\n-/\n@[simps!]\ndef cones : (J ‚•§ C) ‚•§ C·µí·µñ ‚•§ Type max u‚ÇÅ v‚ÇÉ where\n  obj := Functor.cones\n  map f := whiskerLeft (const J).op (yoneda.map f)\n\n"}
{"name":"CategoryTheory.cones_obj_obj","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nX : Opposite C\n‚ä¢ Eq (((CategoryTheory.cones J C).obj F).obj X) (Quiver.Hom ((CategoryTheory.Functor.const J).obj (Opposite.unop X)) F)","decl":"/-- Functorially associated to each functor `J ‚•§ C`, we have the `C`-presheaf consisting of\ncones with a given cone point.\n-/\n@[simps!]\ndef cones : (J ‚•§ C) ‚•§ C·µí·µñ ‚•§ Type max u‚ÇÅ v‚ÇÉ where\n  obj := Functor.cones\n  map f := whiskerLeft (const J).op (yoneda.map f)\n\n"}
{"name":"CategoryTheory.cones_obj_map_app","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nX‚úù Y‚úù : Opposite C\nf : Quiver.Hom X‚úù Y‚úù\na‚úù : (CategoryTheory.yoneda.obj F).obj ((CategoryTheory.Functor.const J).op.obj X‚úù)\nX : J\n‚ä¢ Eq ((((CategoryTheory.cones J C).obj F).map f a‚úù).app X) (CategoryTheory.CategoryStruct.comp f.unop (a‚úù.app X))","decl":"/-- Functorially associated to each functor `J ‚•§ C`, we have the `C`-presheaf consisting of\ncones with a given cone point.\n-/\n@[simps!]\ndef cones : (J ‚•§ C) ‚•§ C·µí·µñ ‚•§ Type max u‚ÇÅ v‚ÇÉ where\n  obj := Functor.cones\n  map f := whiskerLeft (const J).op (yoneda.map f)\n\n"}
{"name":"CategoryTheory.cocones_obj_obj","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : Opposite (CategoryTheory.Functor J C)\nX : C\n‚ä¢ Eq (((CategoryTheory.cocones J C).obj F).obj X) (Quiver.Hom (Opposite.unop F) ((CategoryTheory.Functor.const J).obj X))","decl":"/-- Contravariantly associated to each functor `J ‚•§ C`, we have the `C`-copresheaf consisting of\ncocones with a given cocone point.\n-/\n@[simps!]\ndef cocones : (J ‚•§ C)·µí·µñ ‚•§ C ‚•§ Type max u‚ÇÅ v‚ÇÉ where\n  obj F := Functor.cocones (unop F)\n  map f := whiskerLeft (const J) (coyoneda.map f)\n\n"}
{"name":"CategoryTheory.cocones_obj_map_app","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : Opposite (CategoryTheory.Functor J C)\nX‚úù Y‚úù : C\nf : Quiver.Hom X‚úù Y‚úù\na‚úù : (CategoryTheory.coyoneda.obj { unop := Opposite.unop F }).obj ((CategoryTheory.Functor.const J).obj X‚úù)\nX : J\n‚ä¢ Eq ((((CategoryTheory.cocones J C).obj F).map f a‚úù).app X) (CategoryTheory.CategoryStruct.comp (a‚úù.app X) f)","decl":"/-- Contravariantly associated to each functor `J ‚•§ C`, we have the `C`-copresheaf consisting of\ncocones with a given cocone point.\n-/\n@[simps!]\ndef cocones : (J ‚•§ C)·µí·µñ ‚•§ C ‚•§ Type max u‚ÇÅ v‚ÇÉ where\n  obj F := Functor.cocones (unop F)\n  map f := whiskerLeft (const J) (coyoneda.map f)\n\n"}
{"name":"CategoryTheory.cocones_map_app_app","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nX‚úù¬π Y‚úù : Opposite (CategoryTheory.Functor J C)\nf : Quiver.Hom X‚úù¬π Y‚úù\nX‚úù : C\na‚úù : (CategoryTheory.coyoneda.obj X‚úù¬π).obj ((CategoryTheory.Functor.const J).obj X‚úù)\nX : J\n‚ä¢ Eq ((((CategoryTheory.cocones J C).map f).app X‚úù a‚úù).app X) (CategoryTheory.CategoryStruct.comp (f.unop.app X) (a‚úù.app X))","decl":"/-- Contravariantly associated to each functor `J ‚•§ C`, we have the `C`-copresheaf consisting of\ncocones with a given cocone point.\n-/\n@[simps!]\ndef cocones : (J ‚•§ C)·µí·µñ ‚•§ C ‚•§ Type max u‚ÇÅ v‚ÇÉ where\n  obj F := Functor.cocones (unop F)\n  map f := whiskerLeft (const J) (coyoneda.map f)\n\n"}
{"name":"CategoryTheory.Limits.Cone.mk.injEq","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\npt‚úù : C\nœÄ‚úù : Quiver.Hom ((CategoryTheory.Functor.const J).obj pt‚úù) F\npt : C\nœÄ : Quiver.Hom ((CategoryTheory.Functor.const J).obj pt) F\n‚ä¢ Eq (Eq { pt := pt‚úù, œÄ := œÄ‚úù } { pt := pt, œÄ := œÄ }) (And (Eq pt‚úù pt) (HEq œÄ‚úù œÄ))","decl":"/-- A `c : Cone F` is:\n* an object `c.pt` and\n* a natural transformation `c.œÄ : c.pt ‚ü∂ F` from the constant `c.pt` functor to `F`.\n\nExample: if `J` is a category coming from a poset then the data required to make\na term of type `Cone F` is morphisms `œÄ‚±º : c.pt ‚ü∂ F j` for all `j : J` and,\nfor all `i ‚â§ j` in `J`, morphisms `œÄ·µ¢‚±º : F i ‚ü∂ F j` such that `œÄ·µ¢ ‚â´ œÄ·µ¢‚±º = œÄ·µ¢`.\n\n`Cone F` is equivalent, via `cone.equiv` below, to `Œ£ X, F.cones.obj X`.\n-/\nstructure Cone (F : J ‚•§ C) where\n  /-- An object of `C` -/\n  pt : C\n  /-- A natural transformation from the constant functor at `X` to `F` -/\n  œÄ : (const J).obj pt ‚ü∂ F\n\n"}
{"name":"CategoryTheory.Limits.Cone.mk.inj","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\npt‚úù : C\nœÄ‚úù : Quiver.Hom ((CategoryTheory.Functor.const J).obj pt‚úù) F\npt : C\nœÄ : Quiver.Hom ((CategoryTheory.Functor.const J).obj pt) F\nx‚úù : Eq { pt := pt‚úù, œÄ := œÄ‚úù } { pt := pt, œÄ := œÄ }\n‚ä¢ And (Eq pt‚úù pt) (HEq œÄ‚úù œÄ)","decl":"/-- A `c : Cone F` is:\n* an object `c.pt` and\n* a natural transformation `c.œÄ : c.pt ‚ü∂ F` from the constant `c.pt` functor to `F`.\n\nExample: if `J` is a category coming from a poset then the data required to make\na term of type `Cone F` is morphisms `œÄ‚±º : c.pt ‚ü∂ F j` for all `j : J` and,\nfor all `i ‚â§ j` in `J`, morphisms `œÄ·µ¢‚±º : F i ‚ü∂ F j` such that `œÄ·µ¢ ‚â´ œÄ·µ¢‚±º = œÄ·µ¢`.\n\n`Cone F` is equivalent, via `cone.equiv` below, to `Œ£ X, F.cones.obj X`.\n-/\nstructure Cone (F : J ‚•§ C) where\n  /-- An object of `C` -/\n  pt : C\n  /-- A natural transformation from the constant functor at `X` to `F` -/\n  œÄ : (const J).obj pt ‚ü∂ F\n\n"}
{"name":"CategoryTheory.Limits.Cone.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\ninst‚úù¬π : SizeOf J\ninst‚úù : SizeOf C\npt : C\nœÄ : Quiver.Hom ((CategoryTheory.Functor.const J).obj pt) F\n‚ä¢ Eq (SizeOf.sizeOf { pt := pt, œÄ := œÄ }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf pt)) (SizeOf.sizeOf œÄ))","decl":"/-- A `c : Cone F` is:\n* an object `c.pt` and\n* a natural transformation `c.œÄ : c.pt ‚ü∂ F` from the constant `c.pt` functor to `F`.\n\nExample: if `J` is a category coming from a poset then the data required to make\na term of type `Cone F` is morphisms `œÄ‚±º : c.pt ‚ü∂ F j` for all `j : J` and,\nfor all `i ‚â§ j` in `J`, morphisms `œÄ·µ¢‚±º : F i ‚ü∂ F j` such that `œÄ·µ¢ ‚â´ œÄ·µ¢‚±º = œÄ·µ¢`.\n\n`Cone F` is equivalent, via `cone.equiv` below, to `Œ£ X, F.cones.obj X`.\n-/\nstructure Cone (F : J ‚•§ C) where\n  /-- An object of `C` -/\n  pt : C\n  /-- A natural transformation from the constant functor at `X` to `F` -/\n  œÄ : (const J).obj pt ‚ü∂ F\n\n"}
{"name":"CategoryTheory.Limits.Cone.w","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cone F\nj j' : J\nf : Quiver.Hom j j'\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (c.œÄ.app j) (F.map f)) (c.œÄ.app j')","decl":"@[reassoc (attr := simp)]\ntheorem Cone.w {F : J ‚•§ C} (c : Cone F) {j j' : J} (f : j ‚ü∂ j') :\n    c.œÄ.app j ‚â´ F.map f = c.œÄ.app j' := by\n  rw [‚Üê c.œÄ.naturality f]\n  apply id_comp\n\n"}
{"name":"CategoryTheory.Limits.Cone.w_assoc","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cone F\nj j' : J\nf : Quiver.Hom j j'\nZ : C\nh : Quiver.Hom (F.obj j') Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (c.œÄ.app j) (CategoryTheory.CategoryStruct.comp (F.map f) h)) (CategoryTheory.CategoryStruct.comp (c.œÄ.app j') h)","decl":"@[reassoc (attr := simp)]\ntheorem Cone.w {F : J ‚•§ C} (c : Cone F) {j j' : J} (f : j ‚ü∂ j') :\n    c.œÄ.app j ‚â´ F.map f = c.œÄ.app j' := by\n  rw [‚Üê c.œÄ.naturality f]\n  apply id_comp\n\n"}
{"name":"CategoryTheory.Limits.Cocone.mk.injEq","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\npt‚úù : C\nŒπ‚úù : Quiver.Hom F ((CategoryTheory.Functor.const J).obj pt‚úù)\npt : C\nŒπ : Quiver.Hom F ((CategoryTheory.Functor.const J).obj pt)\n‚ä¢ Eq (Eq { pt := pt‚úù, Œπ := Œπ‚úù } { pt := pt, Œπ := Œπ }) (And (Eq pt‚úù pt) (HEq Œπ‚úù Œπ))","decl":"/-- A `c : Cocone F` is\n* an object `c.pt` and\n* a natural transformation `c.Œπ : F ‚ü∂ c.pt` from `F` to the constant `c.pt` functor.\n\nFor example, if the source `J` of `F` is a partially ordered set, then to give\n`c : Cocone F` is to give a collection of morphisms `Œπ‚±º : F j ‚ü∂ c.pt` and, for\nall `j ‚â§ k` in `J`, morphisms `Œπ‚±º‚Çñ : F j ‚ü∂ F k` such that `F‚±º‚Çñ ‚â´ F‚Çñ = F‚±º` for all `j ‚â§ k`.\n\n`Cocone F` is equivalent, via `Cone.equiv` below, to `Œ£ X, F.cocones.obj X`.\n-/\nstructure Cocone (F : J ‚•§ C) where\n  /-- An object of `C` -/\n  pt : C\n  /-- A natural transformation from `F` to the constant functor at `pt` -/\n  Œπ : F ‚ü∂ (const J).obj pt\n\n"}
{"name":"CategoryTheory.Limits.Cocone.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\ninst‚úù¬π : SizeOf J\ninst‚úù : SizeOf C\npt : C\nŒπ : Quiver.Hom F ((CategoryTheory.Functor.const J).obj pt)\n‚ä¢ Eq (SizeOf.sizeOf { pt := pt, Œπ := Œπ }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf pt)) (SizeOf.sizeOf Œπ))","decl":"/-- A `c : Cocone F` is\n* an object `c.pt` and\n* a natural transformation `c.Œπ : F ‚ü∂ c.pt` from `F` to the constant `c.pt` functor.\n\nFor example, if the source `J` of `F` is a partially ordered set, then to give\n`c : Cocone F` is to give a collection of morphisms `Œπ‚±º : F j ‚ü∂ c.pt` and, for\nall `j ‚â§ k` in `J`, morphisms `Œπ‚±º‚Çñ : F j ‚ü∂ F k` such that `F‚±º‚Çñ ‚â´ F‚Çñ = F‚±º` for all `j ‚â§ k`.\n\n`Cocone F` is equivalent, via `Cone.equiv` below, to `Œ£ X, F.cocones.obj X`.\n-/\nstructure Cocone (F : J ‚•§ C) where\n  /-- An object of `C` -/\n  pt : C\n  /-- A natural transformation from `F` to the constant functor at `pt` -/\n  Œπ : F ‚ü∂ (const J).obj pt\n\n"}
{"name":"CategoryTheory.Limits.Cocone.mk.inj","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\npt‚úù : C\nŒπ‚úù : Quiver.Hom F ((CategoryTheory.Functor.const J).obj pt‚úù)\npt : C\nŒπ : Quiver.Hom F ((CategoryTheory.Functor.const J).obj pt)\nx‚úù : Eq { pt := pt‚úù, Œπ := Œπ‚úù } { pt := pt, Œπ := Œπ }\n‚ä¢ And (Eq pt‚úù pt) (HEq Œπ‚úù Œπ)","decl":"/-- A `c : Cocone F` is\n* an object `c.pt` and\n* a natural transformation `c.Œπ : F ‚ü∂ c.pt` from `F` to the constant `c.pt` functor.\n\nFor example, if the source `J` of `F` is a partially ordered set, then to give\n`c : Cocone F` is to give a collection of morphisms `Œπ‚±º : F j ‚ü∂ c.pt` and, for\nall `j ‚â§ k` in `J`, morphisms `Œπ‚±º‚Çñ : F j ‚ü∂ F k` such that `F‚±º‚Çñ ‚â´ F‚Çñ = F‚±º` for all `j ‚â§ k`.\n\n`Cocone F` is equivalent, via `Cone.equiv` below, to `Œ£ X, F.cocones.obj X`.\n-/\nstructure Cocone (F : J ‚•§ C) where\n  /-- An object of `C` -/\n  pt : C\n  /-- A natural transformation from `F` to the constant functor at `pt` -/\n  Œπ : F ‚ü∂ (const J).obj pt\n\n"}
{"name":"CategoryTheory.Limits.Cocone.w_assoc","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\nj j' : J\nf : Quiver.Hom j j'\nZ : C\nh : Quiver.Hom (((CategoryTheory.Functor.const J).obj c.pt).obj j') Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map f) (CategoryTheory.CategoryStruct.comp (c.Œπ.app j') h)) (CategoryTheory.CategoryStruct.comp (c.Œπ.app j) h)","decl":"@[reassoc]\ntheorem Cocone.w {F : J ‚•§ C} (c : Cocone F) {j j' : J} (f : j ‚ü∂ j') :\n    F.map f ‚â´ c.Œπ.app j' = c.Œπ.app j := by\n  rw [c.Œπ.naturality f]\n  apply comp_id\n\n"}
{"name":"CategoryTheory.Limits.Cocone.w","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\nj j' : J\nf : Quiver.Hom j j'\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map f) (c.Œπ.app j')) (c.Œπ.app j)","decl":"@[reassoc]\ntheorem Cocone.w {F : J ‚•§ C} (c : Cocone F) {j j' : J} (f : j ‚ü∂ j') :\n    F.map f ‚â´ c.Œπ.app j' = c.Œπ.app j := by\n  rw [c.Œπ.naturality f]\n  apply comp_id\n\n"}
{"name":"CategoryTheory.Limits.Cone.equiv_inv_œÄ","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc : Sigma fun X => F.cones.obj X\n‚ä¢ Eq ((CategoryTheory.Limits.Cone.equiv F).inv c).œÄ c.snd","decl":"/-- The isomorphism between a cone on `F` and an element of the functor `F.cones`. -/\n@[simps!]\ndef equiv (F : J ‚•§ C) : Cone F ‚âÖ Œ£X, F.cones.obj X where\n  hom c := ‚ü®op c.pt, c.œÄ‚ü©\n  inv c :=\n    { pt := c.1.unop\n      œÄ := c.2 }\n  hom_inv_id := by\n    funext X\n    cases X\n    rfl\n  inv_hom_id := by\n    funext X\n    cases X\n    rfl\n\n"}
{"name":"CategoryTheory.Limits.Cone.equiv_inv_pt","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc : Sigma fun X => F.cones.obj X\n‚ä¢ Eq ((CategoryTheory.Limits.Cone.equiv F).inv c).pt (Opposite.unop c.fst)","decl":"/-- The isomorphism between a cone on `F` and an element of the functor `F.cones`. -/\n@[simps!]\ndef equiv (F : J ‚•§ C) : Cone F ‚âÖ Œ£X, F.cones.obj X where\n  hom c := ‚ü®op c.pt, c.œÄ‚ü©\n  inv c :=\n    { pt := c.1.unop\n      œÄ := c.2 }\n  hom_inv_id := by\n    funext X\n    cases X\n    rfl\n  inv_hom_id := by\n    funext X\n    cases X\n    rfl\n\n"}
{"name":"CategoryTheory.Limits.Cone.equiv_hom_snd","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cone F\n‚ä¢ Eq ((CategoryTheory.Limits.Cone.equiv F).hom c).snd c.œÄ","decl":"/-- The isomorphism between a cone on `F` and an element of the functor `F.cones`. -/\n@[simps!]\ndef equiv (F : J ‚•§ C) : Cone F ‚âÖ Œ£X, F.cones.obj X where\n  hom c := ‚ü®op c.pt, c.œÄ‚ü©\n  inv c :=\n    { pt := c.1.unop\n      œÄ := c.2 }\n  hom_inv_id := by\n    funext X\n    cases X\n    rfl\n  inv_hom_id := by\n    funext X\n    cases X\n    rfl\n\n"}
{"name":"CategoryTheory.Limits.Cone.equiv_hom_fst","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cone F\n‚ä¢ Eq ((CategoryTheory.Limits.Cone.equiv F).hom c).fst { unop := c.pt }","decl":"/-- The isomorphism between a cone on `F` and an element of the functor `F.cones`. -/\n@[simps!]\ndef equiv (F : J ‚•§ C) : Cone F ‚âÖ Œ£X, F.cones.obj X where\n  hom c := ‚ü®op c.pt, c.œÄ‚ü©\n  inv c :=\n    { pt := c.1.unop\n      œÄ := c.2 }\n  hom_inv_id := by\n    funext X\n    cases X\n    rfl\n  inv_hom_id := by\n    funext X\n    cases X\n    rfl\n\n"}
{"name":"CategoryTheory.Limits.Cone.extensions_app","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cone F\nx‚úù : Opposite C\nf : ((CategoryTheory.yoneda.obj c.pt).comp CategoryTheory.uliftFunctor.{u‚ÇÅ, v‚ÇÉ}).obj x‚úù\n‚ä¢ Eq (c.extensions.app x‚úù f) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.const J).map f.down) c.œÄ)","decl":"/-- A map to the vertex of a cone naturally induces a cone by composition. -/\n@[simps]\ndef extensions (c : Cone F) : yoneda.obj c.pt ‚ãô uliftFunctor.{u‚ÇÅ} ‚ü∂ F.cones where\n  app _ f := (const J).map f.down ‚â´ c.œÄ\n\n"}
{"name":"CategoryTheory.Limits.Cone.extend_œÄ","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cone F\nX : C\nf : Quiver.Hom X c.pt\n‚ä¢ Eq (c.extend f).œÄ (c.extensions.app { unop := X } { down := f })","decl":"/-- A map to the vertex of a cone induces a cone by composition. -/\n@[simps]\ndef extend (c : Cone F) {X : C} (f : X ‚ü∂ c.pt) : Cone F :=\n  { pt := X\n    œÄ := c.extensions.app (op X) ‚ü®f‚ü© }\n\n"}
{"name":"CategoryTheory.Limits.Cone.extend_pt","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cone F\nX : C\nf : Quiver.Hom X c.pt\n‚ä¢ Eq (c.extend f).pt X","decl":"/-- A map to the vertex of a cone induces a cone by composition. -/\n@[simps]\ndef extend (c : Cone F) {X : C} (f : X ‚ü∂ c.pt) : Cone F :=\n  { pt := X\n    œÄ := c.extensions.app (op X) ‚ü®f‚ü© }\n\n"}
{"name":"CategoryTheory.Limits.Cone.whisker_pt","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nK : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} K\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nE : CategoryTheory.Functor K J\nc : CategoryTheory.Limits.Cone F\n‚ä¢ Eq (CategoryTheory.Limits.Cone.whisker E c).pt c.pt","decl":"/-- Whisker a cone by precomposition of a functor. -/\n@[simps]\ndef whisker (E : K ‚•§ J) (c : Cone F) : Cone (E ‚ãô F) where\n  pt := c.pt\n  œÄ := whiskerLeft E c.œÄ\n\n"}
{"name":"CategoryTheory.Limits.Cone.whisker_œÄ","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nK : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} K\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nE : CategoryTheory.Functor K J\nc : CategoryTheory.Limits.Cone F\n‚ä¢ Eq (CategoryTheory.Limits.Cone.whisker E c).œÄ (CategoryTheory.whiskerLeft E c.œÄ)","decl":"/-- Whisker a cone by precomposition of a functor. -/\n@[simps]\ndef whisker (E : K ‚•§ J) (c : Cone F) : Cone (E ‚ãô F) where\n  pt := c.pt\n  œÄ := whiskerLeft E c.œÄ\n\n"}
{"name":"CategoryTheory.Limits.Cocone.extensions_app","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\nx‚úù : C\nf : ((CategoryTheory.coyoneda.obj { unop := c.pt }).comp CategoryTheory.uliftFunctor.{u‚ÇÅ, v‚ÇÉ}).obj x‚úù\n‚ä¢ Eq (c.extensions.app x‚úù f) (CategoryTheory.CategoryStruct.comp c.Œπ ((CategoryTheory.Functor.const J).map f.down))","decl":"/-- A map from the vertex of a cocone naturally induces a cocone by composition. -/\n@[simps]\ndef extensions (c : Cocone F) : coyoneda.obj (op c.pt) ‚ãô uliftFunctor.{u‚ÇÅ} ‚ü∂ F.cocones where\n  app _ f := c.Œπ ‚â´ (const J).map f.down\n\n"}
{"name":"CategoryTheory.Limits.Cocone.extend_Œπ","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\nY : C\nf : Quiver.Hom c.pt Y\n‚ä¢ Eq (c.extend f).Œπ (c.extensions.app Y { down := f })","decl":"/-- A map from the vertex of a cocone induces a cocone by composition. -/\n@[simps]\ndef extend (c : Cocone F) {Y : C} (f : c.pt ‚ü∂ Y) : Cocone F where\n  pt := Y\n  Œπ := c.extensions.app Y ‚ü®f‚ü©\n\n"}
{"name":"CategoryTheory.Limits.Cocone.extend_pt","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\nY : C\nf : Quiver.Hom c.pt Y\n‚ä¢ Eq (c.extend f).pt Y","decl":"/-- A map from the vertex of a cocone induces a cocone by composition. -/\n@[simps]\ndef extend (c : Cocone F) {Y : C} (f : c.pt ‚ü∂ Y) : Cocone F where\n  pt := Y\n  Œπ := c.extensions.app Y ‚ü®f‚ü©\n\n"}
{"name":"CategoryTheory.Limits.Cocone.whisker_Œπ","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nK : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} K\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nE : CategoryTheory.Functor K J\nc : CategoryTheory.Limits.Cocone F\n‚ä¢ Eq (CategoryTheory.Limits.Cocone.whisker E c).Œπ (CategoryTheory.whiskerLeft E c.Œπ)","decl":"/-- Whisker a cocone by precomposition of a functor. See `whiskering` for a functorial\nversion.\n-/\n@[simps]\ndef whisker (E : K ‚•§ J) (c : Cocone F) : Cocone (E ‚ãô F) where\n  pt := c.pt\n  Œπ := whiskerLeft E c.Œπ\n\n"}
{"name":"CategoryTheory.Limits.Cocone.whisker_pt","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nK : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} K\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nE : CategoryTheory.Functor K J\nc : CategoryTheory.Limits.Cocone F\n‚ä¢ Eq (CategoryTheory.Limits.Cocone.whisker E c).pt c.pt","decl":"/-- Whisker a cocone by precomposition of a functor. See `whiskering` for a functorial\nversion.\n-/\n@[simps]\ndef whisker (E : K ‚•§ J) (c : Cocone F) : Cocone (E ‚ãô F) where\n  pt := c.pt\n  Œπ := whiskerLeft E c.Œπ\n\n"}
{"name":"CategoryTheory.Limits.ConeMorphism.mk.injEq","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nA B : CategoryTheory.Limits.Cone F\nhom‚úù : Quiver.Hom A.pt B.pt\nw‚úù : autoParam (‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp hom‚úù (B.œÄ.app j)) (A.œÄ.app j)) _auto‚úù\nhom : Quiver.Hom A.pt B.pt\nw : autoParam (‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp hom (B.œÄ.app j)) (A.œÄ.app j)) _auto‚úù\n‚ä¢ Eq (Eq { hom := hom‚úù, w := w‚úù } { hom := hom, w := w }) (Eq hom‚úù hom)","decl":"/-- A cone morphism between two cones for the same diagram is a morphism of the cone points which\ncommutes with the cone legs. -/\nstructure ConeMorphism (A B : Cone F) where\n  /-- A morphism between the two vertex objects of the cones -/\n  hom : A.pt ‚ü∂ B.pt\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  w : ‚àÄ j : J, hom ‚â´ B.œÄ.app j = A.œÄ.app j := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.ConeMorphism.w","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nA B : CategoryTheory.Limits.Cone F\nself : CategoryTheory.Limits.ConeMorphism A B\nj : J\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp self.hom (B.œÄ.app j)) (A.œÄ.app j)","decl":"/-- A cone morphism between two cones for the same diagram is a morphism of the cone points which\ncommutes with the cone legs. -/\nstructure ConeMorphism (A B : Cone F) where\n  /-- A morphism between the two vertex objects of the cones -/\n  hom : A.pt ‚ü∂ B.pt\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  w : ‚àÄ j : J, hom ‚â´ B.œÄ.app j = A.œÄ.app j := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.ConeMorphism.mk.inj","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nA B : CategoryTheory.Limits.Cone F\nhom‚úù : Quiver.Hom A.pt B.pt\nw‚úù : autoParam (‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp hom‚úù (B.œÄ.app j)) (A.œÄ.app j)) _auto‚úù\nhom : Quiver.Hom A.pt B.pt\nw : autoParam (‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp hom (B.œÄ.app j)) (A.œÄ.app j)) _auto‚úù\nx‚úù : Eq { hom := hom‚úù, w := w‚úù } { hom := hom, w := w }\n‚ä¢ Eq hom‚úù hom","decl":"/-- A cone morphism between two cones for the same diagram is a morphism of the cone points which\ncommutes with the cone legs. -/\nstructure ConeMorphism (A B : Cone F) where\n  /-- A morphism between the two vertex objects of the cones -/\n  hom : A.pt ‚ü∂ B.pt\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  w : ‚àÄ j : J, hom ‚â´ B.œÄ.app j = A.œÄ.app j := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.ConeMorphism.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nA B : CategoryTheory.Limits.Cone F\ninst‚úù¬π : SizeOf J\ninst‚úù : SizeOf C\nhom : Quiver.Hom A.pt B.pt\nw : autoParam (‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp hom (B.œÄ.app j)) (A.œÄ.app j)) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf { hom := hom, w := w }) (HAdd.hAdd 1 (SizeOf.sizeOf hom))","decl":"/-- A cone morphism between two cones for the same diagram is a morphism of the cone points which\ncommutes with the cone legs. -/\nstructure ConeMorphism (A B : Cone F) where\n  /-- A morphism between the two vertex objects of the cones -/\n  hom : A.pt ‚ü∂ B.pt\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  w : ‚àÄ j : J, hom ‚â´ B.œÄ.app j = A.œÄ.app j := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.ConeMorphism.w_assoc","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nA B : CategoryTheory.Limits.Cone F\nself : CategoryTheory.Limits.ConeMorphism A B\nj : J\nZ : C\nh : Quiver.Hom (F.obj j) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp self.hom (CategoryTheory.CategoryStruct.comp (B.œÄ.app j) h)) (CategoryTheory.CategoryStruct.comp (A.œÄ.app j) h)","decl":"attribute [reassoc (attr := simp)] ConeMorphism.w\n\n"}
{"name":"CategoryTheory.Limits.Cone.category_comp_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nX‚úù Y‚úù Z‚úù : CategoryTheory.Limits.Cone F\nf : Quiver.Hom X‚úù Y‚úù\ng : Quiver.Hom Y‚úù Z‚úù\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f g).hom (CategoryTheory.CategoryStruct.comp f.hom g.hom)","decl":"/-- The category of cones on a given diagram. -/\n@[simps]\ninstance Cone.category : Category (Cone F) where\n  Hom A B := ConeMorphism A B\n  comp f g := { hom := f.hom ‚â´ g.hom }\n  id B := { hom := ùüô B.pt }\n\n-- Porting note: if we do not have `simps` automatically generate the lemma for simplifying\n-- the hom field of a category, we need to write the `ext` lemma in terms of the categorical\n-- morphism, rather than the underlying structure.\n"}
{"name":"CategoryTheory.Limits.Cone.category_id_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nB : CategoryTheory.Limits.Cone F\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id B).hom (CategoryTheory.CategoryStruct.id B.pt)","decl":"/-- The category of cones on a given diagram. -/\n@[simps]\ninstance Cone.category : Category (Cone F) where\n  Hom A B := ConeMorphism A B\n  comp f g := { hom := f.hom ‚â´ g.hom }\n  id B := { hom := ùüô B.pt }\n\n-- Porting note: if we do not have `simps` automatically generate the lemma for simplifying\n-- the hom field of a category, we need to write the `ext` lemma in terms of the categorical\n-- morphism, rather than the underlying structure.\n"}
{"name":"CategoryTheory.Limits.ConeMorphism.ext_iff","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc c' : CategoryTheory.Limits.Cone F\nf g : Quiver.Hom c c'\n‚ä¢ Iff (Eq f g) (Eq f.hom g.hom)","decl":"@[ext]\ntheorem ConeMorphism.ext {c c' : Cone F} (f g : c ‚ü∂ c') (w : f.hom = g.hom) : f = g := by\n  cases f\n  cases g\n  congr\n\n"}
{"name":"CategoryTheory.Limits.ConeMorphism.ext","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc c' : CategoryTheory.Limits.Cone F\nf g : Quiver.Hom c c'\nw : Eq f.hom g.hom\n‚ä¢ Eq f g","decl":"@[ext]\ntheorem ConeMorphism.ext {c c' : Cone F} (f g : c ‚ü∂ c') (w : f.hom = g.hom) : f = g := by\n  cases f\n  cases g\n  congr\n\n"}
{"name":"CategoryTheory.Limits.Cones.ext_hom_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc c' : CategoryTheory.Limits.Cone F\nœÜ : CategoryTheory.Iso c.pt c'.pt\nw : autoParam (‚àÄ (j : J), Eq (c.œÄ.app j) (CategoryTheory.CategoryStruct.comp œÜ.hom (c'.œÄ.app j))) _auto‚úù\n‚ä¢ Eq (CategoryTheory.Limits.Cones.ext œÜ w).hom.hom œÜ.hom","decl":"/-- To give an isomorphism between cones, it suffices to give an\n  isomorphism between their vertices which commutes with the cone\n  maps. -/\n@[aesop apply safe (rule_sets := [CategoryTheory]), simps]\ndef ext {c c' : Cone F} (œÜ : c.pt ‚âÖ c'.pt)\n    (w : ‚àÄ j, c.œÄ.app j = œÜ.hom ‚â´ c'.œÄ.app j := by aesop_cat) : c ‚âÖ c' where\n  hom := { hom := œÜ.hom }\n  inv :=\n    { hom := œÜ.inv\n      w := fun j => œÜ.inv_comp_eq.mpr (w j) }\n\n"}
{"name":"CategoryTheory.Limits.Cones.ext_inv_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc c' : CategoryTheory.Limits.Cone F\nœÜ : CategoryTheory.Iso c.pt c'.pt\nw : autoParam (‚àÄ (j : J), Eq (c.œÄ.app j) (CategoryTheory.CategoryStruct.comp œÜ.hom (c'.œÄ.app j))) _auto‚úù\n‚ä¢ Eq (CategoryTheory.Limits.Cones.ext œÜ w).inv.hom œÜ.inv","decl":"/-- To give an isomorphism between cones, it suffices to give an\n  isomorphism between their vertices which commutes with the cone\n  maps. -/\n@[aesop apply safe (rule_sets := [CategoryTheory]), simps]\ndef ext {c c' : Cone F} (œÜ : c.pt ‚âÖ c'.pt)\n    (w : ‚àÄ j, c.œÄ.app j = œÜ.hom ‚â´ c'.œÄ.app j := by aesop_cat) : c ‚âÖ c' where\n  hom := { hom := œÜ.hom }\n  inv :=\n    { hom := œÜ.inv\n      w := fun j => œÜ.inv_comp_eq.mpr (w j) }\n\n"}
{"name":"CategoryTheory.Limits.Cones.eta_hom_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cone F\n‚ä¢ Eq (CategoryTheory.Limits.Cones.eta c).hom.hom (CategoryTheory.CategoryStruct.id c.pt)","decl":"/-- Eta rule for cones. -/\n@[simps!]\ndef eta (c : Cone F) : c ‚âÖ ‚ü®c.pt, c.œÄ‚ü© :=\n  Cones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.Cones.eta_inv_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cone F\n‚ä¢ Eq (CategoryTheory.Limits.Cones.eta c).inv.hom (CategoryTheory.CategoryStruct.id c.pt)","decl":"/-- Eta rule for cones. -/\n@[simps!]\ndef eta (c : Cone F) : c ‚âÖ ‚ü®c.pt, c.œÄ‚ü© :=\n  Cones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.Cones.cone_iso_of_hom_iso","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nK : CategoryTheory.Functor J C\nc d : CategoryTheory.Limits.Cone K\nf : Quiver.Hom c d\ni : CategoryTheory.IsIso f.hom\n‚ä¢ CategoryTheory.IsIso f","decl":"/-- Given a cone morphism whose object part is an isomorphism, produce an\nisomorphism of cones.\n-/\ntheorem cone_iso_of_hom_iso {K : J ‚•§ C} {c d : Cone K} (f : c ‚ü∂ d) [i : IsIso f.hom] : IsIso f :=\n  ‚ü®‚ü®{   hom := inv f.hom\n        w := fun j => (asIso f.hom).inv_comp_eq.2 (f.w j).symm }, by aesop_cat‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Limits.Cones.extend_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cone F\nX : C\nf : Quiver.Hom X s.pt\n‚ä¢ Eq (CategoryTheory.Limits.Cones.extend s f).hom f","decl":"/-- There is a morphism from an extended cone to the original cone. -/\n@[simps]\ndef extend (s : Cone F) {X : C} (f : X ‚ü∂ s.pt) : s.extend f ‚ü∂ s where\n  hom := f\n\n"}
{"name":"CategoryTheory.Limits.Cones.extendId_inv_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cone F\n‚ä¢ Eq (CategoryTheory.Limits.Cones.extendId s).inv.hom (CategoryTheory.CategoryStruct.id s.pt)","decl":"/-- Extending a cone by the identity does nothing. -/\n@[simps!]\ndef extendId (s : Cone F) : s.extend (ùüô s.pt) ‚âÖ s :=\n  Cones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.Cones.extendId_hom_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cone F\n‚ä¢ Eq (CategoryTheory.Limits.Cones.extendId s).hom.hom (CategoryTheory.CategoryStruct.id s.pt)","decl":"/-- Extending a cone by the identity does nothing. -/\n@[simps!]\ndef extendId (s : Cone F) : s.extend (ùüô s.pt) ‚âÖ s :=\n  Cones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.Cones.extendComp_inv_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cone F\nX Y : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y s.pt\n‚ä¢ Eq (CategoryTheory.Limits.Cones.extendComp s f g).inv.hom (CategoryTheory.CategoryStruct.id X)","decl":"/-- Extending a cone by a composition is the same as extending the cone twice. -/\n@[simps!]\ndef extendComp (s : Cone F) {X Y : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ s.pt) :\n    s.extend (f ‚â´ g) ‚âÖ (s.extend g).extend f :=\n  Cones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.Cones.extendComp_hom_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cone F\nX Y : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y s.pt\n‚ä¢ Eq (CategoryTheory.Limits.Cones.extendComp s f g).hom.hom (CategoryTheory.CategoryStruct.id X)","decl":"/-- Extending a cone by a composition is the same as extending the cone twice. -/\n@[simps!]\ndef extendComp (s : Cone F) {X Y : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ s.pt) :\n    s.extend (f ‚â´ g) ‚âÖ (s.extend g).extend f :=\n  Cones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.Cones.extendIso_inv_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cone F\nX : C\nf : CategoryTheory.Iso X s.pt\n‚ä¢ Eq (CategoryTheory.Limits.Cones.extendIso s f).inv.hom f.inv","decl":"/-- A cone extended by an isomorphism is isomorphic to the original cone. -/\n@[simps]\ndef extendIso (s : Cone F) {X : C} (f : X ‚âÖ s.pt) : s.extend f.hom ‚âÖ s where\n  hom := { hom := f.hom }\n  inv := { hom := f.inv }\n\n"}
{"name":"CategoryTheory.Limits.Cones.extendIso_hom_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cone F\nX : C\nf : CategoryTheory.Iso X s.pt\n‚ä¢ Eq (CategoryTheory.Limits.Cones.extendIso s f).hom.hom f.hom","decl":"/-- A cone extended by an isomorphism is isomorphic to the original cone. -/\n@[simps]\ndef extendIso (s : Cone F) {X : C} (f : X ‚âÖ s.pt) : s.extend f.hom ‚âÖ s where\n  hom := { hom := f.hom }\n  inv := { hom := f.inv }\n\n"}
{"name":"CategoryTheory.Limits.Cones.instIsIsoConeExtend","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cone F\nX : C\nf : Quiver.Hom X s.pt\ninst‚úù : CategoryTheory.IsIso f\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.Limits.Cones.extend s f)","decl":"instance {s : Cone F} {X : C} (f : X ‚ü∂ s.pt) [IsIso f] : IsIso (Cones.extend s f) :=\n  ‚ü®(extendIso s (asIso f)).inv, by aesop_cat‚ü©\n\n"}
{"name":"CategoryTheory.Limits.Cones.postcompose_map_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF G : CategoryTheory.Functor J C\nŒ± : Quiver.Hom F G\nX‚úù Y‚úù : CategoryTheory.Limits.Cone F\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Limits.Cones.postcompose Œ±).map f).hom f.hom","decl":"/--\nFunctorially postcompose a cone for `F` by a natural transformation `F ‚ü∂ G` to give a cone for `G`.\n-/\n@[simps]\ndef postcompose {G : J ‚•§ C} (Œ± : F ‚ü∂ G) : Cone F ‚•§ Cone G where\n  obj c :=\n    { pt := c.pt\n      œÄ := c.œÄ ‚â´ Œ± }\n  map f := { hom := f.hom }\n\n"}
{"name":"CategoryTheory.Limits.Cones.postcompose_obj_pt","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF G : CategoryTheory.Functor J C\nŒ± : Quiver.Hom F G\nc : CategoryTheory.Limits.Cone F\n‚ä¢ Eq ((CategoryTheory.Limits.Cones.postcompose Œ±).obj c).pt c.pt","decl":"/--\nFunctorially postcompose a cone for `F` by a natural transformation `F ‚ü∂ G` to give a cone for `G`.\n-/\n@[simps]\ndef postcompose {G : J ‚•§ C} (Œ± : F ‚ü∂ G) : Cone F ‚•§ Cone G where\n  obj c :=\n    { pt := c.pt\n      œÄ := c.œÄ ‚â´ Œ± }\n  map f := { hom := f.hom }\n\n"}
{"name":"CategoryTheory.Limits.Cones.postcompose_obj_œÄ","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF G : CategoryTheory.Functor J C\nŒ± : Quiver.Hom F G\nc : CategoryTheory.Limits.Cone F\n‚ä¢ Eq ((CategoryTheory.Limits.Cones.postcompose Œ±).obj c).œÄ (CategoryTheory.CategoryStruct.comp c.œÄ Œ±)","decl":"/--\nFunctorially postcompose a cone for `F` by a natural transformation `F ‚ü∂ G` to give a cone for `G`.\n-/\n@[simps]\ndef postcompose {G : J ‚•§ C} (Œ± : F ‚ü∂ G) : Cone F ‚•§ Cone G where\n  obj c :=\n    { pt := c.pt\n      œÄ := c.œÄ ‚â´ Œ± }\n  map f := { hom := f.hom }\n\n"}
{"name":"CategoryTheory.Limits.Cones.postcomposeComp_hom_app_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF G H : CategoryTheory.Functor J C\nŒ± : Quiver.Hom F G\nŒ≤ : Quiver.Hom G H\nX : CategoryTheory.Limits.Cone F\n‚ä¢ Eq ((CategoryTheory.Limits.Cones.postcomposeComp Œ± Œ≤).hom.app X).hom (CategoryTheory.CategoryStruct.id X.pt)","decl":"/-- Postcomposing a cone by the composite natural transformation `Œ± ‚â´ Œ≤` is the same as\npostcomposing by `Œ±` and then by `Œ≤`. -/\n@[simps!]\ndef postcomposeComp {G H : J ‚•§ C} (Œ± : F ‚ü∂ G) (Œ≤ : G ‚ü∂ H) :\n    postcompose (Œ± ‚â´ Œ≤) ‚âÖ postcompose Œ± ‚ãô postcompose Œ≤ :=\n  NatIso.ofComponents fun s => Cones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.Cones.postcomposeComp_inv_app_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF G H : CategoryTheory.Functor J C\nŒ± : Quiver.Hom F G\nŒ≤ : Quiver.Hom G H\nX : CategoryTheory.Limits.Cone F\n‚ä¢ Eq ((CategoryTheory.Limits.Cones.postcomposeComp Œ± Œ≤).inv.app X).hom (CategoryTheory.CategoryStruct.id X.pt)","decl":"/-- Postcomposing a cone by the composite natural transformation `Œ± ‚â´ Œ≤` is the same as\npostcomposing by `Œ±` and then by `Œ≤`. -/\n@[simps!]\ndef postcomposeComp {G H : J ‚•§ C} (Œ± : F ‚ü∂ G) (Œ≤ : G ‚ü∂ H) :\n    postcompose (Œ± ‚â´ Œ≤) ‚âÖ postcompose Œ± ‚ãô postcompose Œ≤ :=\n  NatIso.ofComponents fun s => Cones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.Cones.postcomposeId_hom_app_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nX : CategoryTheory.Limits.Cone F\n‚ä¢ Eq (CategoryTheory.Limits.Cones.postcomposeId.hom.app X).hom (CategoryTheory.CategoryStruct.id X.pt)","decl":"/-- Postcomposing by the identity does not change the cone up to isomorphism. -/\n@[simps!]\ndef postcomposeId : postcompose (ùüô F) ‚âÖ ùü≠ (Cone F) :=\n  NatIso.ofComponents fun s => Cones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.Cones.postcomposeId_inv_app_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nX : CategoryTheory.Limits.Cone F\n‚ä¢ Eq (CategoryTheory.Limits.Cones.postcomposeId.inv.app X).hom (CategoryTheory.CategoryStruct.id X.pt)","decl":"/-- Postcomposing by the identity does not change the cone up to isomorphism. -/\n@[simps!]\ndef postcomposeId : postcompose (ùüô F) ‚âÖ ùü≠ (Cone F) :=\n  NatIso.ofComponents fun s => Cones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.Cones.postcomposeEquivalence_unitIso","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF G : CategoryTheory.Functor J C\nŒ± : CategoryTheory.Iso F G\n‚ä¢ Eq (CategoryTheory.Limits.Cones.postcomposeEquivalence Œ±).unitIso (CategoryTheory.NatIso.ofComponents (fun s => CategoryTheory.Limits.Cones.ext (CategoryTheory.Iso.refl ((CategoryTheory.Functor.id (CategoryTheory.Limits.Cone F)).obj s).pt) ‚ãØ) ‚ãØ)","decl":"/-- If `F` and `G` are naturally isomorphic functors, then they have equivalent categories of\ncones.\n-/\n@[simps]\ndef postcomposeEquivalence {G : J ‚•§ C} (Œ± : F ‚âÖ G) : Cone F ‚âå Cone G where\n  functor := postcompose Œ±.hom\n  inverse := postcompose Œ±.inv\n  unitIso := NatIso.ofComponents fun s => Cones.ext (Iso.refl _)\n  counitIso := NatIso.ofComponents fun s => Cones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.Cones.postcomposeEquivalence_functor","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF G : CategoryTheory.Functor J C\nŒ± : CategoryTheory.Iso F G\n‚ä¢ Eq (CategoryTheory.Limits.Cones.postcomposeEquivalence Œ±).functor (CategoryTheory.Limits.Cones.postcompose Œ±.hom)","decl":"/-- If `F` and `G` are naturally isomorphic functors, then they have equivalent categories of\ncones.\n-/\n@[simps]\ndef postcomposeEquivalence {G : J ‚•§ C} (Œ± : F ‚âÖ G) : Cone F ‚âå Cone G where\n  functor := postcompose Œ±.hom\n  inverse := postcompose Œ±.inv\n  unitIso := NatIso.ofComponents fun s => Cones.ext (Iso.refl _)\n  counitIso := NatIso.ofComponents fun s => Cones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.Cones.postcomposeEquivalence_counitIso","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF G : CategoryTheory.Functor J C\nŒ± : CategoryTheory.Iso F G\n‚ä¢ Eq (CategoryTheory.Limits.Cones.postcomposeEquivalence Œ±).counitIso (CategoryTheory.NatIso.ofComponents (fun s => CategoryTheory.Limits.Cones.ext (CategoryTheory.Iso.refl (((CategoryTheory.Limits.Cones.postcompose Œ±.inv).comp (CategoryTheory.Limits.Cones.postcompose Œ±.hom)).obj s).pt) ‚ãØ) ‚ãØ)","decl":"/-- If `F` and `G` are naturally isomorphic functors, then they have equivalent categories of\ncones.\n-/\n@[simps]\ndef postcomposeEquivalence {G : J ‚•§ C} (Œ± : F ‚âÖ G) : Cone F ‚âå Cone G where\n  functor := postcompose Œ±.hom\n  inverse := postcompose Œ±.inv\n  unitIso := NatIso.ofComponents fun s => Cones.ext (Iso.refl _)\n  counitIso := NatIso.ofComponents fun s => Cones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.Cones.postcomposeEquivalence_inverse","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF G : CategoryTheory.Functor J C\nŒ± : CategoryTheory.Iso F G\n‚ä¢ Eq (CategoryTheory.Limits.Cones.postcomposeEquivalence Œ±).inverse (CategoryTheory.Limits.Cones.postcompose Œ±.inv)","decl":"/-- If `F` and `G` are naturally isomorphic functors, then they have equivalent categories of\ncones.\n-/\n@[simps]\ndef postcomposeEquivalence {G : J ‚•§ C} (Œ± : F ‚âÖ G) : Cone F ‚âå Cone G where\n  functor := postcompose Œ±.hom\n  inverse := postcompose Œ±.inv\n  unitIso := NatIso.ofComponents fun s => Cones.ext (Iso.refl _)\n  counitIso := NatIso.ofComponents fun s => Cones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.Cones.whiskering_map_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nK : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} K\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nE : CategoryTheory.Functor K J\nX‚úù Y‚úù : CategoryTheory.Limits.Cone F\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Limits.Cones.whiskering E).map f).hom f.hom","decl":"/-- Whiskering on the left by `E : K ‚•§ J` gives a functor from `Cone F` to `Cone (E ‚ãô F)`.\n-/\n@[simps]\ndef whiskering (E : K ‚•§ J) : Cone F ‚•§ Cone (E ‚ãô F) where\n  obj c := c.whisker E\n  map f := { hom := f.hom }\n\n"}
{"name":"CategoryTheory.Limits.Cones.whiskering_obj","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nK : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} K\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nE : CategoryTheory.Functor K J\nc : CategoryTheory.Limits.Cone F\n‚ä¢ Eq ((CategoryTheory.Limits.Cones.whiskering E).obj c) (CategoryTheory.Limits.Cone.whisker E c)","decl":"/-- Whiskering on the left by `E : K ‚•§ J` gives a functor from `Cone F` to `Cone (E ‚ãô F)`.\n-/\n@[simps]\ndef whiskering (E : K ‚•§ J) : Cone F ‚•§ Cone (E ‚ãô F) where\n  obj c := c.whisker E\n  map f := { hom := f.hom }\n\n"}
{"name":"CategoryTheory.Limits.Cones.whiskeringEquivalence_inverse","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nK : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} K\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\ne : CategoryTheory.Equivalence K J\n‚ä¢ Eq (CategoryTheory.Limits.Cones.whiskeringEquivalence e).inverse ((CategoryTheory.Limits.Cones.whiskering e.inverse).comp (CategoryTheory.Limits.Cones.postcompose (e.invFunIdAssoc F).hom))","decl":"/-- Whiskering by an equivalence gives an equivalence between categories of cones.\n-/\n@[simps]\ndef whiskeringEquivalence (e : K ‚âå J) : Cone F ‚âå Cone (e.functor ‚ãô F) where\n  functor := whiskering e.functor\n  inverse := whiskering e.inverse ‚ãô postcompose (e.invFunIdAssoc F).hom\n  unitIso := NatIso.ofComponents fun s => Cones.ext (Iso.refl _)\n  counitIso :=\n    NatIso.ofComponents\n      fun s =>\n        Cones.ext (Iso.refl _)\n          (by\n            intro k\n            simpa [e.counit_app_functor] using s.w (e.unitInv.app k))\n\n"}
{"name":"CategoryTheory.Limits.Cones.whiskeringEquivalence_unitIso","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nK : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} K\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\ne : CategoryTheory.Equivalence K J\n‚ä¢ Eq (CategoryTheory.Limits.Cones.whiskeringEquivalence e).unitIso (CategoryTheory.NatIso.ofComponents (fun s => CategoryTheory.Limits.Cones.ext (CategoryTheory.Iso.refl ((CategoryTheory.Functor.id (CategoryTheory.Limits.Cone F)).obj s).pt) ‚ãØ) ‚ãØ)","decl":"/-- Whiskering by an equivalence gives an equivalence between categories of cones.\n-/\n@[simps]\ndef whiskeringEquivalence (e : K ‚âå J) : Cone F ‚âå Cone (e.functor ‚ãô F) where\n  functor := whiskering e.functor\n  inverse := whiskering e.inverse ‚ãô postcompose (e.invFunIdAssoc F).hom\n  unitIso := NatIso.ofComponents fun s => Cones.ext (Iso.refl _)\n  counitIso :=\n    NatIso.ofComponents\n      fun s =>\n        Cones.ext (Iso.refl _)\n          (by\n            intro k\n            simpa [e.counit_app_functor] using s.w (e.unitInv.app k))\n\n"}
{"name":"CategoryTheory.Limits.Cones.whiskeringEquivalence_functor","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nK : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} K\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\ne : CategoryTheory.Equivalence K J\n‚ä¢ Eq (CategoryTheory.Limits.Cones.whiskeringEquivalence e).functor (CategoryTheory.Limits.Cones.whiskering e.functor)","decl":"/-- Whiskering by an equivalence gives an equivalence between categories of cones.\n-/\n@[simps]\ndef whiskeringEquivalence (e : K ‚âå J) : Cone F ‚âå Cone (e.functor ‚ãô F) where\n  functor := whiskering e.functor\n  inverse := whiskering e.inverse ‚ãô postcompose (e.invFunIdAssoc F).hom\n  unitIso := NatIso.ofComponents fun s => Cones.ext (Iso.refl _)\n  counitIso :=\n    NatIso.ofComponents\n      fun s =>\n        Cones.ext (Iso.refl _)\n          (by\n            intro k\n            simpa [e.counit_app_functor] using s.w (e.unitInv.app k))\n\n"}
{"name":"CategoryTheory.Limits.Cones.whiskeringEquivalence_counitIso","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nK : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} K\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\ne : CategoryTheory.Equivalence K J\n‚ä¢ Eq (CategoryTheory.Limits.Cones.whiskeringEquivalence e).counitIso (CategoryTheory.NatIso.ofComponents (fun s => CategoryTheory.Limits.Cones.ext (CategoryTheory.Iso.refl ((((CategoryTheory.Limits.Cones.whiskering e.inverse).comp (CategoryTheory.Limits.Cones.postcompose (e.invFunIdAssoc F).hom)).comp (CategoryTheory.Limits.Cones.whiskering e.functor)).obj s).pt) ‚ãØ) ‚ãØ)","decl":"/-- Whiskering by an equivalence gives an equivalence between categories of cones.\n-/\n@[simps]\ndef whiskeringEquivalence (e : K ‚âå J) : Cone F ‚âå Cone (e.functor ‚ãô F) where\n  functor := whiskering e.functor\n  inverse := whiskering e.inverse ‚ãô postcompose (e.invFunIdAssoc F).hom\n  unitIso := NatIso.ofComponents fun s => Cones.ext (Iso.refl _)\n  counitIso :=\n    NatIso.ofComponents\n      fun s =>\n        Cones.ext (Iso.refl _)\n          (by\n            intro k\n            simpa [e.counit_app_functor] using s.w (e.unitInv.app k))\n\n"}
{"name":"CategoryTheory.Limits.Cones.equivalenceOfReindexing_unitIso","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nK : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} K\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nG : CategoryTheory.Functor K C\ne : CategoryTheory.Equivalence K J\nŒ± : CategoryTheory.Iso (e.functor.comp F) G\n‚ä¢ Eq (CategoryTheory.Limits.Cones.equivalenceOfReindexing e Œ±).unitIso ((CategoryTheory.NatIso.ofComponents (fun s => CategoryTheory.Limits.Cones.ext (CategoryTheory.Iso.refl s.pt) ‚ãØ) ‚ãØ).trans ((CategoryTheory.isoWhiskerRight ((CategoryTheory.Limits.Cones.whiskering e.functor).rightUnitor.symm.trans ((CategoryTheory.isoWhiskerLeft (CategoryTheory.Limits.Cones.whiskering e.functor) (CategoryTheory.NatIso.ofComponents (fun s => CategoryTheory.Limits.Cones.ext (CategoryTheory.Iso.refl s.pt) ‚ãØ) ‚ãØ)).trans ((CategoryTheory.Limits.Cones.whiskering e.functor).associator (CategoryTheory.Limits.Cones.postcompose Œ±.hom) (CategoryTheory.Limits.Cones.postcompose Œ±.inv)).symm)) ((CategoryTheory.Limits.Cones.whiskering e.inverse).comp (CategoryTheory.Limits.Cones.postcompose (e.invFunIdAssoc F).hom))).trans (((CategoryTheory.Limits.Cones.whiskering e.functor).comp (CategoryTheory.Limits.Cones.postcompose Œ±.hom)).associator (CategoryTheory.Limits.Cones.postcompose Œ±.inv) ((CategoryTheory.Limits.Cones.whiskering e.inverse).comp (CategoryTheory.Limits.Cones.postcompose (e.invFunIdAssoc F).hom)))))","decl":"/-- The categories of cones over `F` and `G` are equivalent if `F` and `G` are naturally isomorphic\n(possibly after changing the indexing category by an equivalence).\n-/\n@[simps! functor inverse unitIso counitIso]\ndef equivalenceOfReindexing {G : K ‚•§ C} (e : K ‚âå J) (Œ± : e.functor ‚ãô F ‚âÖ G) : Cone F ‚âå Cone G :=\n  (whiskeringEquivalence e).trans (postcomposeEquivalence Œ±)\n\n"}
{"name":"CategoryTheory.Limits.Cones.equivalenceOfReindexing_functor","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nK : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} K\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nG : CategoryTheory.Functor K C\ne : CategoryTheory.Equivalence K J\nŒ± : CategoryTheory.Iso (e.functor.comp F) G\n‚ä¢ Eq (CategoryTheory.Limits.Cones.equivalenceOfReindexing e Œ±).functor ((CategoryTheory.Limits.Cones.whiskering e.functor).comp (CategoryTheory.Limits.Cones.postcompose Œ±.hom))","decl":"/-- The categories of cones over `F` and `G` are equivalent if `F` and `G` are naturally isomorphic\n(possibly after changing the indexing category by an equivalence).\n-/\n@[simps! functor inverse unitIso counitIso]\ndef equivalenceOfReindexing {G : K ‚•§ C} (e : K ‚âå J) (Œ± : e.functor ‚ãô F ‚âÖ G) : Cone F ‚âå Cone G :=\n  (whiskeringEquivalence e).trans (postcomposeEquivalence Œ±)\n\n"}
{"name":"CategoryTheory.Limits.Cones.equivalenceOfReindexing_counitIso","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nK : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} K\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nG : CategoryTheory.Functor K C\ne : CategoryTheory.Equivalence K J\nŒ± : CategoryTheory.Iso (e.functor.comp F) G\n‚ä¢ Eq (CategoryTheory.Limits.Cones.equivalenceOfReindexing e Œ±).counitIso ((((CategoryTheory.Limits.Cones.postcompose Œ±.inv).comp ((CategoryTheory.Limits.Cones.whiskering e.inverse).comp (CategoryTheory.Limits.Cones.postcompose (e.invFunIdAssoc F).hom))).associator (CategoryTheory.Limits.Cones.whiskering e.functor) (CategoryTheory.Limits.Cones.postcompose Œ±.hom)).symm.trans ((CategoryTheory.isoWhiskerRight (((CategoryTheory.Limits.Cones.postcompose Œ±.inv).associator ((CategoryTheory.Limits.Cones.whiskering e.inverse).comp (CategoryTheory.Limits.Cones.postcompose (e.invFunIdAssoc F).hom)) (CategoryTheory.Limits.Cones.whiskering e.functor)).trans ((CategoryTheory.isoWhiskerLeft (CategoryTheory.Limits.Cones.postcompose Œ±.inv) (CategoryTheory.NatIso.ofComponents (fun s => CategoryTheory.Limits.Cones.ext (CategoryTheory.Iso.refl s.pt) ‚ãØ) ‚ãØ)).trans (CategoryTheory.Limits.Cones.postcompose Œ±.inv).rightUnitor)) (CategoryTheory.Limits.Cones.postcompose Œ±.hom)).trans (CategoryTheory.NatIso.ofComponents (fun s => CategoryTheory.Limits.Cones.ext (CategoryTheory.Iso.refl s.pt) ‚ãØ) ‚ãØ)))","decl":"/-- The categories of cones over `F` and `G` are equivalent if `F` and `G` are naturally isomorphic\n(possibly after changing the indexing category by an equivalence).\n-/\n@[simps! functor inverse unitIso counitIso]\ndef equivalenceOfReindexing {G : K ‚•§ C} (e : K ‚âå J) (Œ± : e.functor ‚ãô F ‚âÖ G) : Cone F ‚âå Cone G :=\n  (whiskeringEquivalence e).trans (postcomposeEquivalence Œ±)\n\n"}
{"name":"CategoryTheory.Limits.Cones.equivalenceOfReindexing_inverse","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nK : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} K\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nG : CategoryTheory.Functor K C\ne : CategoryTheory.Equivalence K J\nŒ± : CategoryTheory.Iso (e.functor.comp F) G\n‚ä¢ Eq (CategoryTheory.Limits.Cones.equivalenceOfReindexing e Œ±).inverse ((CategoryTheory.Limits.Cones.postcompose Œ±.inv).comp ((CategoryTheory.Limits.Cones.whiskering e.inverse).comp (CategoryTheory.Limits.Cones.postcompose (e.invFunIdAssoc F).hom)))","decl":"/-- The categories of cones over `F` and `G` are equivalent if `F` and `G` are naturally isomorphic\n(possibly after changing the indexing category by an equivalence).\n-/\n@[simps! functor inverse unitIso counitIso]\ndef equivalenceOfReindexing {G : K ‚•§ C} (e : K ‚âå J) (Œ± : e.functor ‚ãô F ‚âÖ G) : Cone F ‚âå Cone G :=\n  (whiskeringEquivalence e).trans (postcomposeEquivalence Œ±)\n\n"}
{"name":"CategoryTheory.Limits.Cones.forget_obj","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nt : CategoryTheory.Limits.Cone F\n‚ä¢ Eq ((CategoryTheory.Limits.Cones.forget F).obj t) t.pt","decl":"/-- Forget the cone structure and obtain just the cone point. -/\n@[simps]\ndef forget : Cone F ‚•§ C where\n  obj t := t.pt\n  map f := f.hom\n\n"}
{"name":"CategoryTheory.Limits.Cones.forget_map","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nX‚úù Y‚úù : CategoryTheory.Limits.Cone F\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Limits.Cones.forget F).map f) f.hom","decl":"/-- Forget the cone structure and obtain just the cone point. -/\n@[simps]\ndef forget : Cone F ‚•§ C where\n  obj t := t.pt\n  map f := f.hom\n\n"}
{"name":"CategoryTheory.Limits.Cones.functoriality_obj_pt","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nF : CategoryTheory.Functor J C\nG : CategoryTheory.Functor C D\nA : CategoryTheory.Limits.Cone F\n‚ä¢ Eq ((CategoryTheory.Limits.Cones.functoriality F G).obj A).pt (G.obj A.pt)","decl":"/-- A functor `G : C ‚•§ D` sends cones over `F` to cones over `F ‚ãô G` functorially. -/\n@[simps]\ndef functoriality : Cone F ‚•§ Cone (F ‚ãô G) where\n  obj A :=\n    { pt := G.obj A.pt\n      œÄ :=\n        { app := fun j => G.map (A.œÄ.app j)\n          naturality := by intros; erw [‚Üê G.map_comp]; simp } }\n  map f :=\n    { hom := G.map f.hom\n      w := fun j => by simp [-ConeMorphism.w, ‚Üê f.w j] }\n\n"}
{"name":"CategoryTheory.Limits.Cones.functoriality_obj_œÄ_app","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nF : CategoryTheory.Functor J C\nG : CategoryTheory.Functor C D\nA : CategoryTheory.Limits.Cone F\nj : J\n‚ä¢ Eq (((CategoryTheory.Limits.Cones.functoriality F G).obj A).œÄ.app j) (G.map (A.œÄ.app j))","decl":"/-- A functor `G : C ‚•§ D` sends cones over `F` to cones over `F ‚ãô G` functorially. -/\n@[simps]\ndef functoriality : Cone F ‚•§ Cone (F ‚ãô G) where\n  obj A :=\n    { pt := G.obj A.pt\n      œÄ :=\n        { app := fun j => G.map (A.œÄ.app j)\n          naturality := by intros; erw [‚Üê G.map_comp]; simp } }\n  map f :=\n    { hom := G.map f.hom\n      w := fun j => by simp [-ConeMorphism.w, ‚Üê f.w j] }\n\n"}
{"name":"CategoryTheory.Limits.Cones.functoriality_map_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nF : CategoryTheory.Functor J C\nG : CategoryTheory.Functor C D\nX‚úù Y‚úù : CategoryTheory.Limits.Cone F\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Limits.Cones.functoriality F G).map f).hom (G.map f.hom)","decl":"/-- A functor `G : C ‚•§ D` sends cones over `F` to cones over `F ‚ãô G` functorially. -/\n@[simps]\ndef functoriality : Cone F ‚•§ Cone (F ‚ãô G) where\n  obj A :=\n    { pt := G.obj A.pt\n      œÄ :=\n        { app := fun j => G.map (A.œÄ.app j)\n          naturality := by intros; erw [‚Üê G.map_comp]; simp } }\n  map f :=\n    { hom := G.map f.hom\n      w := fun j => by simp [-ConeMorphism.w, ‚Üê f.w j] }\n\n"}
{"name":"CategoryTheory.Limits.Cones.functoriality_full","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nF : CategoryTheory.Functor J C\nG : CategoryTheory.Functor C D\ninst‚úù¬π : G.Full\ninst‚úù : G.Faithful\n‚ä¢ (CategoryTheory.Limits.Cones.functoriality F G).Full","decl":"instance functoriality_full [G.Full] [G.Faithful] : (functoriality F G).Full where\n  map_surjective t :=\n    ‚ü®{ hom := G.preimage t.hom\n       w := fun j => G.map_injective (by simpa using t.w j) }, by aesop_cat‚ü©\n\n"}
{"name":"CategoryTheory.Limits.Cones.functoriality_faithful","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nF : CategoryTheory.Functor J C\nG : CategoryTheory.Functor C D\ninst‚úù : G.Faithful\n‚ä¢ (CategoryTheory.Limits.Cones.functoriality F G).Faithful","decl":"instance functoriality_faithful [G.Faithful] : (Cones.functoriality F G).Faithful where\n  map_injective {_X} {_Y} f g h :=\n    ConeMorphism.ext f g <| G.map_injective <| congr_arg ConeMorphism.hom h\n\n"}
{"name":"CategoryTheory.Limits.Cones.functorialityEquivalence_functor","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nF : CategoryTheory.Functor J C\ne : CategoryTheory.Equivalence C D\n‚ä¢ Eq (CategoryTheory.Limits.Cones.functorialityEquivalence F e).functor (CategoryTheory.Limits.Cones.functoriality F e.functor)","decl":"/-- If `e : C ‚âå D` is an equivalence of categories, then `functoriality F e.functor` induces an\nequivalence between cones over `F` and cones over `F ‚ãô e.functor`.\n-/\n@[simps]\ndef functorialityEquivalence (e : C ‚âå D) : Cone F ‚âå Cone (F ‚ãô e.functor) :=\n  let f : (F ‚ãô e.functor) ‚ãô e.inverse ‚âÖ F :=\n    Functor.associator _ _ _ ‚â™‚â´ isoWhiskerLeft _ e.unitIso.symm ‚â™‚â´ Functor.rightUnitor _\n  { functor := functoriality F e.functor\n    inverse := functoriality (F ‚ãô e.functor) e.inverse ‚ãô (postcomposeEquivalence f).functor\n    unitIso := NatIso.ofComponents fun c => Cones.ext (e.unitIso.app _)\n    counitIso := NatIso.ofComponents fun c => Cones.ext (e.counitIso.app _) }\n\n"}
{"name":"CategoryTheory.Limits.Cones.functorialityEquivalence_counitIso","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nF : CategoryTheory.Functor J C\ne : CategoryTheory.Equivalence C D\n‚ä¢ Eq (CategoryTheory.Limits.Cones.functorialityEquivalence F e).counitIso (CategoryTheory.NatIso.ofComponents (fun c => CategoryTheory.Limits.Cones.ext (e.counitIso.app c.pt) ‚ãØ) ‚ãØ)","decl":"/-- If `e : C ‚âå D` is an equivalence of categories, then `functoriality F e.functor` induces an\nequivalence between cones over `F` and cones over `F ‚ãô e.functor`.\n-/\n@[simps]\ndef functorialityEquivalence (e : C ‚âå D) : Cone F ‚âå Cone (F ‚ãô e.functor) :=\n  let f : (F ‚ãô e.functor) ‚ãô e.inverse ‚âÖ F :=\n    Functor.associator _ _ _ ‚â™‚â´ isoWhiskerLeft _ e.unitIso.symm ‚â™‚â´ Functor.rightUnitor _\n  { functor := functoriality F e.functor\n    inverse := functoriality (F ‚ãô e.functor) e.inverse ‚ãô (postcomposeEquivalence f).functor\n    unitIso := NatIso.ofComponents fun c => Cones.ext (e.unitIso.app _)\n    counitIso := NatIso.ofComponents fun c => Cones.ext (e.counitIso.app _) }\n\n"}
{"name":"CategoryTheory.Limits.Cones.functorialityEquivalence_unitIso","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nF : CategoryTheory.Functor J C\ne : CategoryTheory.Equivalence C D\n‚ä¢ Eq (CategoryTheory.Limits.Cones.functorialityEquivalence F e).unitIso (CategoryTheory.NatIso.ofComponents (fun c => CategoryTheory.Limits.Cones.ext (e.unitIso.app ((CategoryTheory.Functor.id (CategoryTheory.Limits.Cone F)).obj c).1) ‚ãØ) ‚ãØ)","decl":"/-- If `e : C ‚âå D` is an equivalence of categories, then `functoriality F e.functor` induces an\nequivalence between cones over `F` and cones over `F ‚ãô e.functor`.\n-/\n@[simps]\ndef functorialityEquivalence (e : C ‚âå D) : Cone F ‚âå Cone (F ‚ãô e.functor) :=\n  let f : (F ‚ãô e.functor) ‚ãô e.inverse ‚âÖ F :=\n    Functor.associator _ _ _ ‚â™‚â´ isoWhiskerLeft _ e.unitIso.symm ‚â™‚â´ Functor.rightUnitor _\n  { functor := functoriality F e.functor\n    inverse := functoriality (F ‚ãô e.functor) e.inverse ‚ãô (postcomposeEquivalence f).functor\n    unitIso := NatIso.ofComponents fun c => Cones.ext (e.unitIso.app _)\n    counitIso := NatIso.ofComponents fun c => Cones.ext (e.counitIso.app _) }\n\n"}
{"name":"CategoryTheory.Limits.Cones.functorialityEquivalence_inverse","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nF : CategoryTheory.Functor J C\ne : CategoryTheory.Equivalence C D\n‚ä¢ Eq (CategoryTheory.Limits.Cones.functorialityEquivalence F e).inverse ((CategoryTheory.Limits.Cones.functoriality (F.comp e.functor) e.inverse).comp (CategoryTheory.Limits.Cones.postcomposeEquivalence ((F.associator e.functor e.inverse).trans ((CategoryTheory.isoWhiskerLeft F e.unitIso.symm).trans F.rightUnitor))).functor)","decl":"/-- If `e : C ‚âå D` is an equivalence of categories, then `functoriality F e.functor` induces an\nequivalence between cones over `F` and cones over `F ‚ãô e.functor`.\n-/\n@[simps]\ndef functorialityEquivalence (e : C ‚âå D) : Cone F ‚âå Cone (F ‚ãô e.functor) :=\n  let f : (F ‚ãô e.functor) ‚ãô e.inverse ‚âÖ F :=\n    Functor.associator _ _ _ ‚â™‚â´ isoWhiskerLeft _ e.unitIso.symm ‚â™‚â´ Functor.rightUnitor _\n  { functor := functoriality F e.functor\n    inverse := functoriality (F ‚ãô e.functor) e.inverse ‚ãô (postcomposeEquivalence f).functor\n    unitIso := NatIso.ofComponents fun c => Cones.ext (e.unitIso.app _)\n    counitIso := NatIso.ofComponents fun c => Cones.ext (e.counitIso.app _) }\n\n"}
{"name":"CategoryTheory.Limits.Cones.reflects_cone_isomorphism","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nF : CategoryTheory.Functor C D\ninst‚úù : F.ReflectsIsomorphisms\nK : CategoryTheory.Functor J C\n‚ä¢ (CategoryTheory.Limits.Cones.functoriality K F).ReflectsIsomorphisms","decl":"/-- If `F` reflects isomorphisms, then `Cones.functoriality F` reflects isomorphisms\nas well.\n-/\ninstance reflects_cone_isomorphism (F : C ‚•§ D) [F.ReflectsIsomorphisms] (K : J ‚•§ C) :\n    (Cones.functoriality K F).ReflectsIsomorphisms := by\n  constructor\n  intro A B f _\n  haveI : IsIso (F.map f.hom) :=\n    (Cones.forget (K ‚ãô F)).map_isIso ((Cones.functoriality K F).map f)\n  haveI := ReflectsIsomorphisms.reflects F f.hom\n  apply cone_iso_of_hom_iso\n\n"}
{"name":"CategoryTheory.Limits.CoconeMorphism.mk.inj","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nA B : CategoryTheory.Limits.Cocone F\nhom‚úù : Quiver.Hom A.pt B.pt\nw‚úù : autoParam (‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp (A.Œπ.app j) hom‚úù) (B.Œπ.app j)) _auto‚úù\nhom : Quiver.Hom A.pt B.pt\nw : autoParam (‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp (A.Œπ.app j) hom) (B.Œπ.app j)) _auto‚úù\nx‚úù : Eq { hom := hom‚úù, w := w‚úù } { hom := hom, w := w }\n‚ä¢ Eq hom‚úù hom","decl":"/-- A cocone morphism between two cocones for the same diagram is a morphism of the cocone points\nwhich commutes with the cocone legs. -/\nstructure CoconeMorphism (A B : Cocone F) where\n  /-- A morphism between the (co)vertex objects in `C` -/\n  hom : A.pt ‚ü∂ B.pt\n  /-- The triangle made from the two natural transformations and `hom` commutes -/\n  w : ‚àÄ j : J, A.Œπ.app j ‚â´ hom = B.Œπ.app j := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.CoconeMorphism.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nA B : CategoryTheory.Limits.Cocone F\ninst‚úù¬π : SizeOf J\ninst‚úù : SizeOf C\nhom : Quiver.Hom A.pt B.pt\nw : autoParam (‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp (A.Œπ.app j) hom) (B.Œπ.app j)) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf { hom := hom, w := w }) (HAdd.hAdd 1 (SizeOf.sizeOf hom))","decl":"/-- A cocone morphism between two cocones for the same diagram is a morphism of the cocone points\nwhich commutes with the cocone legs. -/\nstructure CoconeMorphism (A B : Cocone F) where\n  /-- A morphism between the (co)vertex objects in `C` -/\n  hom : A.pt ‚ü∂ B.pt\n  /-- The triangle made from the two natural transformations and `hom` commutes -/\n  w : ‚àÄ j : J, A.Œπ.app j ‚â´ hom = B.Œπ.app j := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.CoconeMorphism.mk.injEq","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nA B : CategoryTheory.Limits.Cocone F\nhom‚úù : Quiver.Hom A.pt B.pt\nw‚úù : autoParam (‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp (A.Œπ.app j) hom‚úù) (B.Œπ.app j)) _auto‚úù\nhom : Quiver.Hom A.pt B.pt\nw : autoParam (‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp (A.Œπ.app j) hom) (B.Œπ.app j)) _auto‚úù\n‚ä¢ Eq (Eq { hom := hom‚úù, w := w‚úù } { hom := hom, w := w }) (Eq hom‚úù hom)","decl":"/-- A cocone morphism between two cocones for the same diagram is a morphism of the cocone points\nwhich commutes with the cocone legs. -/\nstructure CoconeMorphism (A B : Cocone F) where\n  /-- A morphism between the (co)vertex objects in `C` -/\n  hom : A.pt ‚ü∂ B.pt\n  /-- The triangle made from the two natural transformations and `hom` commutes -/\n  w : ‚àÄ j : J, A.Œπ.app j ‚â´ hom = B.Œπ.app j := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.CoconeMorphism.w","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nA B : CategoryTheory.Limits.Cocone F\nself : CategoryTheory.Limits.CoconeMorphism A B\nj : J\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (A.Œπ.app j) self.hom) (B.Œπ.app j)","decl":"/-- A cocone morphism between two cocones for the same diagram is a morphism of the cocone points\nwhich commutes with the cocone legs. -/\nstructure CoconeMorphism (A B : Cocone F) where\n  /-- A morphism between the (co)vertex objects in `C` -/\n  hom : A.pt ‚ü∂ B.pt\n  /-- The triangle made from the two natural transformations and `hom` commutes -/\n  w : ‚àÄ j : J, A.Œπ.app j ‚â´ hom = B.Œπ.app j := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.CoconeMorphism.w_assoc","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nA B : CategoryTheory.Limits.Cocone F\nself : CategoryTheory.Limits.CoconeMorphism A B\nj : J\nZ : C\nh : Quiver.Hom B.pt Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (A.Œπ.app j) (CategoryTheory.CategoryStruct.comp self.hom h)) (CategoryTheory.CategoryStruct.comp (B.Œπ.app j) h)","decl":"attribute [reassoc (attr := simp)] CoconeMorphism.w\n\n"}
{"name":"CategoryTheory.Limits.Cocone.category_id_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nB : CategoryTheory.Limits.Cocone F\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id B).hom (CategoryTheory.CategoryStruct.id B.pt)","decl":"@[simps]\ninstance Cocone.category : Category (Cocone F) where\n  Hom A B := CoconeMorphism A B\n  comp f g := { hom := f.hom ‚â´ g.hom }\n  id B := { hom := ùüô B.pt }\n\n-- Porting note: if we do not have `simps` automatically generate the lemma for simplifying\n-- the hom field of a category, we need to write the `ext` lemma in terms of the categorical\n-- morphism, rather than the underlying structure.\n"}
{"name":"CategoryTheory.Limits.Cocone.category_comp_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nX‚úù Y‚úù Z‚úù : CategoryTheory.Limits.Cocone F\nf : Quiver.Hom X‚úù Y‚úù\ng : Quiver.Hom Y‚úù Z‚úù\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f g).hom (CategoryTheory.CategoryStruct.comp f.hom g.hom)","decl":"@[simps]\ninstance Cocone.category : Category (Cocone F) where\n  Hom A B := CoconeMorphism A B\n  comp f g := { hom := f.hom ‚â´ g.hom }\n  id B := { hom := ùüô B.pt }\n\n-- Porting note: if we do not have `simps` automatically generate the lemma for simplifying\n-- the hom field of a category, we need to write the `ext` lemma in terms of the categorical\n-- morphism, rather than the underlying structure.\n"}
{"name":"CategoryTheory.Limits.CoconeMorphism.ext","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc c' : CategoryTheory.Limits.Cocone F\nf g : Quiver.Hom c c'\nw : Eq f.hom g.hom\n‚ä¢ Eq f g","decl":"@[ext]\ntheorem CoconeMorphism.ext {c c' : Cocone F} (f g : c ‚ü∂ c') (w : f.hom = g.hom) : f = g := by\n  cases f\n  cases g\n  congr\n\n"}
{"name":"CategoryTheory.Limits.CoconeMorphism.ext_iff","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc c' : CategoryTheory.Limits.Cocone F\nf g : Quiver.Hom c c'\n‚ä¢ Iff (Eq f g) (Eq f.hom g.hom)","decl":"@[ext]\ntheorem CoconeMorphism.ext {c c' : Cocone F} (f g : c ‚ü∂ c') (w : f.hom = g.hom) : f = g := by\n  cases f\n  cases g\n  congr\n\n"}
{"name":"CategoryTheory.Limits.Cocones.ext_hom_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc c' : CategoryTheory.Limits.Cocone F\nœÜ : CategoryTheory.Iso c.pt c'.pt\nw : autoParam (‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp (c.Œπ.app j) œÜ.hom) (c'.Œπ.app j)) _auto‚úù\n‚ä¢ Eq (CategoryTheory.Limits.Cocones.ext œÜ w).hom.hom œÜ.hom","decl":"/-- To give an isomorphism between cocones, it suffices to give an\n  isomorphism between their vertices which commutes with the cocone\n  maps. -/\n@[aesop apply safe (rule_sets := [CategoryTheory]), simps]\ndef ext {c c' : Cocone F} (œÜ : c.pt ‚âÖ c'.pt)\n    (w : ‚àÄ j, c.Œπ.app j ‚â´ œÜ.hom = c'.Œπ.app j := by aesop_cat) : c ‚âÖ c' where\n  hom := { hom := œÜ.hom }\n  inv :=\n    { hom := œÜ.inv\n      w := fun j => œÜ.comp_inv_eq.mpr (w j).symm }\n\n"}
{"name":"CategoryTheory.Limits.Cocones.ext_inv_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc c' : CategoryTheory.Limits.Cocone F\nœÜ : CategoryTheory.Iso c.pt c'.pt\nw : autoParam (‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp (c.Œπ.app j) œÜ.hom) (c'.Œπ.app j)) _auto‚úù\n‚ä¢ Eq (CategoryTheory.Limits.Cocones.ext œÜ w).inv.hom œÜ.inv","decl":"/-- To give an isomorphism between cocones, it suffices to give an\n  isomorphism between their vertices which commutes with the cocone\n  maps. -/\n@[aesop apply safe (rule_sets := [CategoryTheory]), simps]\ndef ext {c c' : Cocone F} (œÜ : c.pt ‚âÖ c'.pt)\n    (w : ‚àÄ j, c.Œπ.app j ‚â´ œÜ.hom = c'.Œπ.app j := by aesop_cat) : c ‚âÖ c' where\n  hom := { hom := œÜ.hom }\n  inv :=\n    { hom := œÜ.inv\n      w := fun j => œÜ.comp_inv_eq.mpr (w j).symm }\n\n"}
{"name":"CategoryTheory.Limits.Cocones.eta_inv_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\n‚ä¢ Eq (CategoryTheory.Limits.Cocones.eta c).inv.hom (CategoryTheory.CategoryStruct.id c.pt)","decl":"/-- Eta rule for cocones. -/\n@[simps!]\ndef eta (c : Cocone F) : c ‚âÖ ‚ü®c.pt, c.Œπ‚ü© :=\n  Cocones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.Cocones.eta_hom_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\n‚ä¢ Eq (CategoryTheory.Limits.Cocones.eta c).hom.hom (CategoryTheory.CategoryStruct.id c.pt)","decl":"/-- Eta rule for cocones. -/\n@[simps!]\ndef eta (c : Cocone F) : c ‚âÖ ‚ü®c.pt, c.Œπ‚ü© :=\n  Cocones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.Cocones.cocone_iso_of_hom_iso","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nK : CategoryTheory.Functor J C\nc d : CategoryTheory.Limits.Cocone K\nf : Quiver.Hom c d\ni : CategoryTheory.IsIso f.hom\n‚ä¢ CategoryTheory.IsIso f","decl":"/-- Given a cocone morphism whose object part is an isomorphism, produce an\nisomorphism of cocones.\n-/\ntheorem cocone_iso_of_hom_iso {K : J ‚•§ C} {c d : Cocone K} (f : c ‚ü∂ d) [i : IsIso f.hom] :\n    IsIso f :=\n  ‚ü®‚ü®{ hom := inv f.hom\n      w := fun j => (asIso f.hom).comp_inv_eq.2 (f.w j).symm }, by aesop_cat‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Limits.Cocones.extend_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cocone F\nX : C\nf : Quiver.Hom s.pt X\n‚ä¢ Eq (CategoryTheory.Limits.Cocones.extend s f).hom f","decl":"/-- There is a morphism from a cocone to its extension. -/\n@[simps]\ndef extend (s : Cocone F) {X : C} (f : s.pt ‚ü∂ X) : s ‚ü∂ s.extend f where\n  hom := f\n\n"}
{"name":"CategoryTheory.Limits.Cocones.extendId_hom_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cocone F\n‚ä¢ Eq (CategoryTheory.Limits.Cocones.extendId s).hom.hom (CategoryTheory.CategoryStruct.id s.pt)","decl":"/-- Extending a cocone by the identity does nothing. -/\n@[simps!]\ndef extendId (s : Cocone F) : s ‚âÖ s.extend (ùüô s.pt) :=\n  Cocones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.Cocones.extendId_inv_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cocone F\n‚ä¢ Eq (CategoryTheory.Limits.Cocones.extendId s).inv.hom (CategoryTheory.CategoryStruct.id s.pt)","decl":"/-- Extending a cocone by the identity does nothing. -/\n@[simps!]\ndef extendId (s : Cocone F) : s ‚âÖ s.extend (ùüô s.pt) :=\n  Cocones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.Cocones.extendComp_inv_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cocone F\nX Y : C\nf : Quiver.Hom s.pt X\ng : Quiver.Hom X Y\n‚ä¢ Eq (CategoryTheory.Limits.Cocones.extendComp s f g).inv.hom (CategoryTheory.CategoryStruct.id Y)","decl":"/-- Extending a cocone by a composition is the same as extending the cone twice. -/\n@[simps!]\ndef extendComp (s : Cocone F) {X Y : C} (f : s.pt ‚ü∂ X) (g : X ‚ü∂ Y) :\n    s.extend (f ‚â´ g) ‚âÖ (s.extend f).extend g :=\n  Cocones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.Cocones.extendComp_hom_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cocone F\nX Y : C\nf : Quiver.Hom s.pt X\ng : Quiver.Hom X Y\n‚ä¢ Eq (CategoryTheory.Limits.Cocones.extendComp s f g).hom.hom (CategoryTheory.CategoryStruct.id Y)","decl":"/-- Extending a cocone by a composition is the same as extending the cone twice. -/\n@[simps!]\ndef extendComp (s : Cocone F) {X Y : C} (f : s.pt ‚ü∂ X) (g : X ‚ü∂ Y) :\n    s.extend (f ‚â´ g) ‚âÖ (s.extend f).extend g :=\n  Cocones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.Cocones.extendIso_inv_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cocone F\nX : C\nf : CategoryTheory.Iso s.pt X\n‚ä¢ Eq (CategoryTheory.Limits.Cocones.extendIso s f).inv.hom f.inv","decl":"/-- A cocone extended by an isomorphism is isomorphic to the original cone. -/\n@[simps]\ndef extendIso (s : Cocone F) {X : C} (f : s.pt ‚âÖ X) : s ‚âÖ s.extend f.hom where\n  hom := { hom := f.hom }\n  inv := { hom := f.inv }\n\n"}
{"name":"CategoryTheory.Limits.Cocones.extendIso_hom_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cocone F\nX : C\nf : CategoryTheory.Iso s.pt X\n‚ä¢ Eq (CategoryTheory.Limits.Cocones.extendIso s f).hom.hom f.hom","decl":"/-- A cocone extended by an isomorphism is isomorphic to the original cone. -/\n@[simps]\ndef extendIso (s : Cocone F) {X : C} (f : s.pt ‚âÖ X) : s ‚âÖ s.extend f.hom where\n  hom := { hom := f.hom }\n  inv := { hom := f.inv }\n\n"}
{"name":"CategoryTheory.Limits.Cocones.instIsIsoCoconeExtend","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cocone F\nX : C\nf : Quiver.Hom s.pt X\ninst‚úù : CategoryTheory.IsIso f\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.Limits.Cocones.extend s f)","decl":"instance {s : Cocone F} {X : C} (f : s.pt ‚ü∂ X) [IsIso f] : IsIso (Cocones.extend s f) :=\n  ‚ü®(extendIso s (asIso f)).inv, by aesop_cat‚ü©\n\n"}
{"name":"CategoryTheory.Limits.Cocones.precompose_obj_Œπ","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF G : CategoryTheory.Functor J C\nŒ± : Quiver.Hom G F\nc : CategoryTheory.Limits.Cocone F\n‚ä¢ Eq ((CategoryTheory.Limits.Cocones.precompose Œ±).obj c).Œπ (CategoryTheory.CategoryStruct.comp Œ± c.Œπ)","decl":"/-- Functorially precompose a cocone for `F` by a natural transformation `G ‚ü∂ F` to give a cocone\nfor `G`. -/\n@[simps]\ndef precompose {G : J ‚•§ C} (Œ± : G ‚ü∂ F) : Cocone F ‚•§ Cocone G where\n  obj c :=\n    { pt := c.pt\n      Œπ := Œ± ‚â´ c.Œπ }\n  map f := { hom := f.hom }\n\n"}
{"name":"CategoryTheory.Limits.Cocones.precompose_map_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF G : CategoryTheory.Functor J C\nŒ± : Quiver.Hom G F\nX‚úù Y‚úù : CategoryTheory.Limits.Cocone F\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Limits.Cocones.precompose Œ±).map f).hom f.hom","decl":"/-- Functorially precompose a cocone for `F` by a natural transformation `G ‚ü∂ F` to give a cocone\nfor `G`. -/\n@[simps]\ndef precompose {G : J ‚•§ C} (Œ± : G ‚ü∂ F) : Cocone F ‚•§ Cocone G where\n  obj c :=\n    { pt := c.pt\n      Œπ := Œ± ‚â´ c.Œπ }\n  map f := { hom := f.hom }\n\n"}
{"name":"CategoryTheory.Limits.Cocones.precompose_obj_pt","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF G : CategoryTheory.Functor J C\nŒ± : Quiver.Hom G F\nc : CategoryTheory.Limits.Cocone F\n‚ä¢ Eq ((CategoryTheory.Limits.Cocones.precompose Œ±).obj c).pt c.pt","decl":"/-- Functorially precompose a cocone for `F` by a natural transformation `G ‚ü∂ F` to give a cocone\nfor `G`. -/\n@[simps]\ndef precompose {G : J ‚•§ C} (Œ± : G ‚ü∂ F) : Cocone F ‚•§ Cocone G where\n  obj c :=\n    { pt := c.pt\n      Œπ := Œ± ‚â´ c.Œπ }\n  map f := { hom := f.hom }\n\n"}
{"name":"CategoryTheory.Limits.Cocones.precomposeEquivalence_inverse","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF G : CategoryTheory.Functor J C\nŒ± : CategoryTheory.Iso G F\n‚ä¢ Eq (CategoryTheory.Limits.Cocones.precomposeEquivalence Œ±).inverse (CategoryTheory.Limits.Cocones.precompose Œ±.inv)","decl":"/-- If `F` and `G` are naturally isomorphic functors, then they have equivalent categories of\ncocones.\n-/\n@[simps]\ndef precomposeEquivalence {G : J ‚•§ C} (Œ± : G ‚âÖ F) : Cocone F ‚âå Cocone G where\n  functor := precompose Œ±.hom\n  inverse := precompose Œ±.inv\n  unitIso := NatIso.ofComponents fun s => Cocones.ext (Iso.refl _)\n  counitIso := NatIso.ofComponents fun s => Cocones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.Cocones.precomposeEquivalence_functor","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF G : CategoryTheory.Functor J C\nŒ± : CategoryTheory.Iso G F\n‚ä¢ Eq (CategoryTheory.Limits.Cocones.precomposeEquivalence Œ±).functor (CategoryTheory.Limits.Cocones.precompose Œ±.hom)","decl":"/-- If `F` and `G` are naturally isomorphic functors, then they have equivalent categories of\ncocones.\n-/\n@[simps]\ndef precomposeEquivalence {G : J ‚•§ C} (Œ± : G ‚âÖ F) : Cocone F ‚âå Cocone G where\n  functor := precompose Œ±.hom\n  inverse := precompose Œ±.inv\n  unitIso := NatIso.ofComponents fun s => Cocones.ext (Iso.refl _)\n  counitIso := NatIso.ofComponents fun s => Cocones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.Cocones.precomposeEquivalence_unitIso","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF G : CategoryTheory.Functor J C\nŒ± : CategoryTheory.Iso G F\n‚ä¢ Eq (CategoryTheory.Limits.Cocones.precomposeEquivalence Œ±).unitIso (CategoryTheory.NatIso.ofComponents (fun s => CategoryTheory.Limits.Cocones.ext (CategoryTheory.Iso.refl ((CategoryTheory.Functor.id (CategoryTheory.Limits.Cocone F)).obj s).pt) ‚ãØ) ‚ãØ)","decl":"/-- If `F` and `G` are naturally isomorphic functors, then they have equivalent categories of\ncocones.\n-/\n@[simps]\ndef precomposeEquivalence {G : J ‚•§ C} (Œ± : G ‚âÖ F) : Cocone F ‚âå Cocone G where\n  functor := precompose Œ±.hom\n  inverse := precompose Œ±.inv\n  unitIso := NatIso.ofComponents fun s => Cocones.ext (Iso.refl _)\n  counitIso := NatIso.ofComponents fun s => Cocones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.Cocones.precomposeEquivalence_counitIso","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF G : CategoryTheory.Functor J C\nŒ± : CategoryTheory.Iso G F\n‚ä¢ Eq (CategoryTheory.Limits.Cocones.precomposeEquivalence Œ±).counitIso (CategoryTheory.NatIso.ofComponents (fun s => CategoryTheory.Limits.Cocones.ext (CategoryTheory.Iso.refl (((CategoryTheory.Limits.Cocones.precompose Œ±.inv).comp (CategoryTheory.Limits.Cocones.precompose Œ±.hom)).obj s).pt) ‚ãØ) ‚ãØ)","decl":"/-- If `F` and `G` are naturally isomorphic functors, then they have equivalent categories of\ncocones.\n-/\n@[simps]\ndef precomposeEquivalence {G : J ‚•§ C} (Œ± : G ‚âÖ F) : Cocone F ‚âå Cocone G where\n  functor := precompose Œ±.hom\n  inverse := precompose Œ±.inv\n  unitIso := NatIso.ofComponents fun s => Cocones.ext (Iso.refl _)\n  counitIso := NatIso.ofComponents fun s => Cocones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.Cocones.whiskering_obj","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nK : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} K\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nE : CategoryTheory.Functor K J\nc : CategoryTheory.Limits.Cocone F\n‚ä¢ Eq ((CategoryTheory.Limits.Cocones.whiskering E).obj c) (CategoryTheory.Limits.Cocone.whisker E c)","decl":"/-- Whiskering on the left by `E : K ‚•§ J` gives a functor from `Cocone F` to `Cocone (E ‚ãô F)`.\n-/\n@[simps]\ndef whiskering (E : K ‚•§ J) : Cocone F ‚•§ Cocone (E ‚ãô F) where\n  obj c := c.whisker E\n  map f := { hom := f.hom }\n\n"}
{"name":"CategoryTheory.Limits.Cocones.whiskering_map_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nK : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} K\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nE : CategoryTheory.Functor K J\nX‚úù Y‚úù : CategoryTheory.Limits.Cocone F\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Limits.Cocones.whiskering E).map f).hom f.hom","decl":"/-- Whiskering on the left by `E : K ‚•§ J` gives a functor from `Cocone F` to `Cocone (E ‚ãô F)`.\n-/\n@[simps]\ndef whiskering (E : K ‚•§ J) : Cocone F ‚•§ Cocone (E ‚ãô F) where\n  obj c := c.whisker E\n  map f := { hom := f.hom }\n\n"}
{"name":"CategoryTheory.Limits.Cocones.whiskeringEquivalence_counitIso","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nK : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} K\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\ne : CategoryTheory.Equivalence K J\n‚ä¢ Eq (CategoryTheory.Limits.Cocones.whiskeringEquivalence e).counitIso (CategoryTheory.NatIso.ofComponents (fun s => CategoryTheory.Limits.Cocones.ext (CategoryTheory.Iso.refl ((((CategoryTheory.Limits.Cocones.whiskering e.inverse).comp (CategoryTheory.Limits.Cocones.precompose (CategoryTheory.CategoryStruct.comp F.leftUnitor.inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight e.counitIso.inv F) (e.inverse.associator e.functor F).inv)))).comp (CategoryTheory.Limits.Cocones.whiskering e.functor)).obj s).pt) ‚ãØ) ‚ãØ)","decl":"/-- Whiskering by an equivalence gives an equivalence between categories of cones.\n-/\n@[simps]\ndef whiskeringEquivalence (e : K ‚âå J) : Cocone F ‚âå Cocone (e.functor ‚ãô F) where\n  functor := whiskering e.functor\n  inverse :=\n    whiskering e.inverse ‚ãô\n      precompose\n        ((Functor.leftUnitor F).inv ‚â´\n          whiskerRight e.counitIso.inv F ‚â´ (Functor.associator _ _ _).inv)\n  unitIso := NatIso.ofComponents fun s => Cocones.ext (Iso.refl _)\n  counitIso := NatIso.ofComponents fun s =>\n    Cocones.ext (Iso.refl _) fun k => by simpa [e.counitInv_app_functor k] using s.w (e.unit.app k)\n\n"}
{"name":"CategoryTheory.Limits.Cocones.whiskeringEquivalence_functor","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nK : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} K\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\ne : CategoryTheory.Equivalence K J\n‚ä¢ Eq (CategoryTheory.Limits.Cocones.whiskeringEquivalence e).functor (CategoryTheory.Limits.Cocones.whiskering e.functor)","decl":"/-- Whiskering by an equivalence gives an equivalence between categories of cones.\n-/\n@[simps]\ndef whiskeringEquivalence (e : K ‚âå J) : Cocone F ‚âå Cocone (e.functor ‚ãô F) where\n  functor := whiskering e.functor\n  inverse :=\n    whiskering e.inverse ‚ãô\n      precompose\n        ((Functor.leftUnitor F).inv ‚â´\n          whiskerRight e.counitIso.inv F ‚â´ (Functor.associator _ _ _).inv)\n  unitIso := NatIso.ofComponents fun s => Cocones.ext (Iso.refl _)\n  counitIso := NatIso.ofComponents fun s =>\n    Cocones.ext (Iso.refl _) fun k => by simpa [e.counitInv_app_functor k] using s.w (e.unit.app k)\n\n"}
{"name":"CategoryTheory.Limits.Cocones.whiskeringEquivalence_unitIso","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nK : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} K\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\ne : CategoryTheory.Equivalence K J\n‚ä¢ Eq (CategoryTheory.Limits.Cocones.whiskeringEquivalence e).unitIso (CategoryTheory.NatIso.ofComponents (fun s => CategoryTheory.Limits.Cocones.ext (CategoryTheory.Iso.refl ((CategoryTheory.Functor.id (CategoryTheory.Limits.Cocone F)).obj s).pt) ‚ãØ) ‚ãØ)","decl":"/-- Whiskering by an equivalence gives an equivalence between categories of cones.\n-/\n@[simps]\ndef whiskeringEquivalence (e : K ‚âå J) : Cocone F ‚âå Cocone (e.functor ‚ãô F) where\n  functor := whiskering e.functor\n  inverse :=\n    whiskering e.inverse ‚ãô\n      precompose\n        ((Functor.leftUnitor F).inv ‚â´\n          whiskerRight e.counitIso.inv F ‚â´ (Functor.associator _ _ _).inv)\n  unitIso := NatIso.ofComponents fun s => Cocones.ext (Iso.refl _)\n  counitIso := NatIso.ofComponents fun s =>\n    Cocones.ext (Iso.refl _) fun k => by simpa [e.counitInv_app_functor k] using s.w (e.unit.app k)\n\n"}
{"name":"CategoryTheory.Limits.Cocones.whiskeringEquivalence_inverse","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nK : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} K\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\ne : CategoryTheory.Equivalence K J\n‚ä¢ Eq (CategoryTheory.Limits.Cocones.whiskeringEquivalence e).inverse ((CategoryTheory.Limits.Cocones.whiskering e.inverse).comp (CategoryTheory.Limits.Cocones.precompose (CategoryTheory.CategoryStruct.comp F.leftUnitor.inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight e.counitIso.inv F) (e.inverse.associator e.functor F).inv))))","decl":"/-- Whiskering by an equivalence gives an equivalence between categories of cones.\n-/\n@[simps]\ndef whiskeringEquivalence (e : K ‚âå J) : Cocone F ‚âå Cocone (e.functor ‚ãô F) where\n  functor := whiskering e.functor\n  inverse :=\n    whiskering e.inverse ‚ãô\n      precompose\n        ((Functor.leftUnitor F).inv ‚â´\n          whiskerRight e.counitIso.inv F ‚â´ (Functor.associator _ _ _).inv)\n  unitIso := NatIso.ofComponents fun s => Cocones.ext (Iso.refl _)\n  counitIso := NatIso.ofComponents fun s =>\n    Cocones.ext (Iso.refl _) fun k => by simpa [e.counitInv_app_functor k] using s.w (e.unit.app k)\n\n"}
{"name":"CategoryTheory.Limits.Cocones.equivalenceOfReindexing_functor_obj","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nK : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} K\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nG : CategoryTheory.Functor K C\ne : CategoryTheory.Equivalence K J\nŒ± : CategoryTheory.Iso (e.functor.comp F) G\nX : CategoryTheory.Limits.Cocone F\n‚ä¢ Eq ((CategoryTheory.Limits.Cocones.equivalenceOfReindexing e Œ±).functor.obj X) ((CategoryTheory.Limits.Cocones.precompose Œ±.inv).obj (CategoryTheory.Limits.Cocone.whisker e.functor X))","decl":"/--\nThe categories of cocones over `F` and `G` are equivalent if `F` and `G` are naturally isomorphic\n(possibly after changing the indexing category by an equivalence).\n-/\n@[simps! functor_obj]\ndef equivalenceOfReindexing {G : K ‚•§ C} (e : K ‚âå J) (Œ± : e.functor ‚ãô F ‚âÖ G) : Cocone F ‚âå Cocone G :=\n  (whiskeringEquivalence e).trans (precomposeEquivalence Œ±.symm)\n\n"}
{"name":"CategoryTheory.Limits.Cocones.forget_obj","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nt : CategoryTheory.Limits.Cocone F\n‚ä¢ Eq ((CategoryTheory.Limits.Cocones.forget F).obj t) t.pt","decl":"/-- Forget the cocone structure and obtain just the cocone point. -/\n@[simps]\ndef forget : Cocone F ‚•§ C where\n  obj t := t.pt\n  map f := f.hom\n\n"}
{"name":"CategoryTheory.Limits.Cocones.forget_map","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nX‚úù Y‚úù : CategoryTheory.Limits.Cocone F\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Limits.Cocones.forget F).map f) f.hom","decl":"/-- Forget the cocone structure and obtain just the cocone point. -/\n@[simps]\ndef forget : Cocone F ‚•§ C where\n  obj t := t.pt\n  map f := f.hom\n\n"}
{"name":"CategoryTheory.Limits.Cocones.functoriality_obj_Œπ_app","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nF : CategoryTheory.Functor J C\nG : CategoryTheory.Functor C D\nA : CategoryTheory.Limits.Cocone F\nj : J\n‚ä¢ Eq (((CategoryTheory.Limits.Cocones.functoriality F G).obj A).Œπ.app j) (G.map (A.Œπ.app j))","decl":"/-- A functor `G : C ‚•§ D` sends cocones over `F` to cocones over `F ‚ãô G` functorially. -/\n@[simps]\ndef functoriality : Cocone F ‚•§ Cocone (F ‚ãô G) where\n  obj A :=\n    { pt := G.obj A.pt\n      Œπ :=\n        { app := fun j => G.map (A.Œπ.app j)\n          naturality := by intros; erw [‚Üê G.map_comp]; simp } }\n  map f :=\n    { hom := G.map f.hom\n      w := by intros; rw [‚Üê Functor.map_comp, CoconeMorphism.w] }\n\n"}
{"name":"CategoryTheory.Limits.Cocones.functoriality_obj_pt","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nF : CategoryTheory.Functor J C\nG : CategoryTheory.Functor C D\nA : CategoryTheory.Limits.Cocone F\n‚ä¢ Eq ((CategoryTheory.Limits.Cocones.functoriality F G).obj A).pt (G.obj A.pt)","decl":"/-- A functor `G : C ‚•§ D` sends cocones over `F` to cocones over `F ‚ãô G` functorially. -/\n@[simps]\ndef functoriality : Cocone F ‚•§ Cocone (F ‚ãô G) where\n  obj A :=\n    { pt := G.obj A.pt\n      Œπ :=\n        { app := fun j => G.map (A.Œπ.app j)\n          naturality := by intros; erw [‚Üê G.map_comp]; simp } }\n  map f :=\n    { hom := G.map f.hom\n      w := by intros; rw [‚Üê Functor.map_comp, CoconeMorphism.w] }\n\n"}
{"name":"CategoryTheory.Limits.Cocones.functoriality_map_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nF : CategoryTheory.Functor J C\nG : CategoryTheory.Functor C D\nX‚úù Y‚úù : CategoryTheory.Limits.Cocone F\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Limits.Cocones.functoriality F G).map f).hom (G.map f.hom)","decl":"/-- A functor `G : C ‚•§ D` sends cocones over `F` to cocones over `F ‚ãô G` functorially. -/\n@[simps]\ndef functoriality : Cocone F ‚•§ Cocone (F ‚ãô G) where\n  obj A :=\n    { pt := G.obj A.pt\n      Œπ :=\n        { app := fun j => G.map (A.Œπ.app j)\n          naturality := by intros; erw [‚Üê G.map_comp]; simp } }\n  map f :=\n    { hom := G.map f.hom\n      w := by intros; rw [‚Üê Functor.map_comp, CoconeMorphism.w] }\n\n"}
{"name":"CategoryTheory.Limits.Cocones.functoriality_full","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nF : CategoryTheory.Functor J C\nG : CategoryTheory.Functor C D\ninst‚úù¬π : G.Full\ninst‚úù : G.Faithful\n‚ä¢ (CategoryTheory.Limits.Cocones.functoriality F G).Full","decl":"instance functoriality_full [G.Full] [G.Faithful] : (functoriality F G).Full where\n  map_surjective t :=\n    ‚ü®{ hom := G.preimage t.hom\n       w := fun j => G.map_injective (by simpa using t.w j) }, by aesop_cat‚ü©\n\n"}
{"name":"CategoryTheory.Limits.Cocones.functoriality_faithful","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nF : CategoryTheory.Functor J C\nG : CategoryTheory.Functor C D\ninst‚úù : G.Faithful\n‚ä¢ (CategoryTheory.Limits.Cocones.functoriality F G).Faithful","decl":"instance functoriality_faithful [G.Faithful] : (functoriality F G).Faithful where\n  map_injective {_X} {_Y} f g h :=\n    CoconeMorphism.ext f g <| G.map_injective <| congr_arg CoconeMorphism.hom h\n\n"}
{"name":"CategoryTheory.Limits.Cocones.functorialityEquivalence_functor","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nF : CategoryTheory.Functor J C\ne : CategoryTheory.Equivalence C D\n‚ä¢ Eq (CategoryTheory.Limits.Cocones.functorialityEquivalence F e).functor (CategoryTheory.Limits.Cocones.functoriality F e.functor)","decl":"/-- If `e : C ‚âå D` is an equivalence of categories, then `functoriality F e.functor` induces an\nequivalence between cocones over `F` and cocones over `F ‚ãô e.functor`.\n-/\n@[simps]\ndef functorialityEquivalence (e : C ‚âå D) : Cocone F ‚âå Cocone (F ‚ãô e.functor) :=\n  let f : (F ‚ãô e.functor) ‚ãô e.inverse ‚âÖ F :=\n    Functor.associator _ _ _ ‚â™‚â´ isoWhiskerLeft _ e.unitIso.symm ‚â™‚â´ Functor.rightUnitor _\n  { functor := functoriality F e.functor\n    inverse := functoriality (F ‚ãô e.functor) e.inverse ‚ãô (precomposeEquivalence f.symm).functor\n    unitIso := NatIso.ofComponents fun c => Cocones.ext (e.unitIso.app _)\n    counitIso := NatIso.ofComponents fun c => Cocones.ext (e.counitIso.app _) }\n\n"}
{"name":"CategoryTheory.Limits.Cocones.functorialityEquivalence_inverse","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nF : CategoryTheory.Functor J C\ne : CategoryTheory.Equivalence C D\n‚ä¢ Eq (CategoryTheory.Limits.Cocones.functorialityEquivalence F e).inverse ((CategoryTheory.Limits.Cocones.functoriality (F.comp e.functor) e.inverse).comp (CategoryTheory.Limits.Cocones.precomposeEquivalence ((F.associator e.functor e.inverse).trans ((CategoryTheory.isoWhiskerLeft F e.unitIso.symm).trans F.rightUnitor)).symm).functor)","decl":"/-- If `e : C ‚âå D` is an equivalence of categories, then `functoriality F e.functor` induces an\nequivalence between cocones over `F` and cocones over `F ‚ãô e.functor`.\n-/\n@[simps]\ndef functorialityEquivalence (e : C ‚âå D) : Cocone F ‚âå Cocone (F ‚ãô e.functor) :=\n  let f : (F ‚ãô e.functor) ‚ãô e.inverse ‚âÖ F :=\n    Functor.associator _ _ _ ‚â™‚â´ isoWhiskerLeft _ e.unitIso.symm ‚â™‚â´ Functor.rightUnitor _\n  { functor := functoriality F e.functor\n    inverse := functoriality (F ‚ãô e.functor) e.inverse ‚ãô (precomposeEquivalence f.symm).functor\n    unitIso := NatIso.ofComponents fun c => Cocones.ext (e.unitIso.app _)\n    counitIso := NatIso.ofComponents fun c => Cocones.ext (e.counitIso.app _) }\n\n"}
{"name":"CategoryTheory.Limits.Cocones.functorialityEquivalence_unitIso","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nF : CategoryTheory.Functor J C\ne : CategoryTheory.Equivalence C D\n‚ä¢ Eq (CategoryTheory.Limits.Cocones.functorialityEquivalence F e).unitIso (CategoryTheory.NatIso.ofComponents (fun c => CategoryTheory.Limits.Cocones.ext (e.unitIso.app ((CategoryTheory.Functor.id (CategoryTheory.Limits.Cocone F)).obj c).1) ‚ãØ) ‚ãØ)","decl":"/-- If `e : C ‚âå D` is an equivalence of categories, then `functoriality F e.functor` induces an\nequivalence between cocones over `F` and cocones over `F ‚ãô e.functor`.\n-/\n@[simps]\ndef functorialityEquivalence (e : C ‚âå D) : Cocone F ‚âå Cocone (F ‚ãô e.functor) :=\n  let f : (F ‚ãô e.functor) ‚ãô e.inverse ‚âÖ F :=\n    Functor.associator _ _ _ ‚â™‚â´ isoWhiskerLeft _ e.unitIso.symm ‚â™‚â´ Functor.rightUnitor _\n  { functor := functoriality F e.functor\n    inverse := functoriality (F ‚ãô e.functor) e.inverse ‚ãô (precomposeEquivalence f.symm).functor\n    unitIso := NatIso.ofComponents fun c => Cocones.ext (e.unitIso.app _)\n    counitIso := NatIso.ofComponents fun c => Cocones.ext (e.counitIso.app _) }\n\n"}
{"name":"CategoryTheory.Limits.Cocones.functorialityEquivalence_counitIso","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nF : CategoryTheory.Functor J C\ne : CategoryTheory.Equivalence C D\n‚ä¢ Eq (CategoryTheory.Limits.Cocones.functorialityEquivalence F e).counitIso (CategoryTheory.NatIso.ofComponents (fun c => CategoryTheory.Limits.Cocones.ext (e.counitIso.app c.pt) ‚ãØ) ‚ãØ)","decl":"/-- If `e : C ‚âå D` is an equivalence of categories, then `functoriality F e.functor` induces an\nequivalence between cocones over `F` and cocones over `F ‚ãô e.functor`.\n-/\n@[simps]\ndef functorialityEquivalence (e : C ‚âå D) : Cocone F ‚âå Cocone (F ‚ãô e.functor) :=\n  let f : (F ‚ãô e.functor) ‚ãô e.inverse ‚âÖ F :=\n    Functor.associator _ _ _ ‚â™‚â´ isoWhiskerLeft _ e.unitIso.symm ‚â™‚â´ Functor.rightUnitor _\n  { functor := functoriality F e.functor\n    inverse := functoriality (F ‚ãô e.functor) e.inverse ‚ãô (precomposeEquivalence f.symm).functor\n    unitIso := NatIso.ofComponents fun c => Cocones.ext (e.unitIso.app _)\n    counitIso := NatIso.ofComponents fun c => Cocones.ext (e.counitIso.app _) }\n\n"}
{"name":"CategoryTheory.Limits.Cocones.reflects_cocone_isomorphism","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nF : CategoryTheory.Functor C D\ninst‚úù : F.ReflectsIsomorphisms\nK : CategoryTheory.Functor J C\n‚ä¢ (CategoryTheory.Limits.Cocones.functoriality K F).ReflectsIsomorphisms","decl":"/-- If `F` reflects isomorphisms, then `Cocones.functoriality F` reflects isomorphisms\nas well.\n-/\ninstance reflects_cocone_isomorphism (F : C ‚•§ D) [F.ReflectsIsomorphisms] (K : J ‚•§ C) :\n    (Cocones.functoriality K F).ReflectsIsomorphisms := by\n  constructor\n  intro A B f _\n  haveI : IsIso (F.map f.hom) :=\n    (Cocones.forget (K ‚ãô F)).map_isIso ((Cocones.functoriality K F).map f)\n  haveI := ReflectsIsomorphisms.reflects F f.hom\n  apply cocone_iso_of_hom_iso\n\n"}
{"name":"CategoryTheory.Functor.mapCone_pt","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nH : CategoryTheory.Functor C D\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cone F\n‚ä¢ Eq (H.mapCone c).pt (H.obj c.pt)","decl":"/-- The image of a cone in C under a functor G : C ‚•§ D is a cone in D. -/\n@[simps!]\ndef mapCone (c : Cone F) : Cone (F ‚ãô H) :=\n  (Cones.functoriality F H).obj c\n\n"}
{"name":"CategoryTheory.Functor.mapCone_œÄ_app","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nH : CategoryTheory.Functor C D\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cone F\nj : J\n‚ä¢ Eq ((H.mapCone c).œÄ.app j) (H.map (c.œÄ.app j))","decl":"/-- The image of a cone in C under a functor G : C ‚•§ D is a cone in D. -/\n@[simps!]\ndef mapCone (c : Cone F) : Cone (F ‚ãô H) :=\n  (Cones.functoriality F H).obj c\n\n"}
{"name":"CategoryTheory.Functor.mapConeMapCone_inv_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nE : Type u‚ÇÖ\ninst‚úù : CategoryTheory.Category.{v‚ÇÖ, u‚ÇÖ} E\nF : CategoryTheory.Functor J C\nH : CategoryTheory.Functor C D\nH' : CategoryTheory.Functor D E\nc : CategoryTheory.Limits.Cone F\n‚ä¢ Eq (CategoryTheory.Functor.mapConeMapCone c).inv.hom (CategoryTheory.CategoryStruct.id (H'.obj (H.obj c.pt)))","decl":"/-- The construction `mapCone` respects functor composition. -/\n@[simps!]\nnoncomputable def mapConeMapCone {F : J ‚•§ C} {H : C ‚•§ D} {H' : D ‚•§ E} (c : Cone F) :\n    H'.mapCone (H.mapCone c) ‚âÖ (H ‚ãô H').mapCone c := Cones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Functor.mapConeMapCone_hom_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nE : Type u‚ÇÖ\ninst‚úù : CategoryTheory.Category.{v‚ÇÖ, u‚ÇÖ} E\nF : CategoryTheory.Functor J C\nH : CategoryTheory.Functor C D\nH' : CategoryTheory.Functor D E\nc : CategoryTheory.Limits.Cone F\n‚ä¢ Eq (CategoryTheory.Functor.mapConeMapCone c).hom.hom (CategoryTheory.CategoryStruct.id (H'.obj (H.obj c.pt)))","decl":"/-- The construction `mapCone` respects functor composition. -/\n@[simps!]\nnoncomputable def mapConeMapCone {F : J ‚•§ C} {H : C ‚•§ D} {H' : D ‚•§ E} (c : Cone F) :\n    H'.mapCone (H.mapCone c) ‚âÖ (H ‚ãô H').mapCone c := Cones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Functor.mapCocone_Œπ_app","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nH : CategoryTheory.Functor C D\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\nj : J\n‚ä¢ Eq ((H.mapCocone c).Œπ.app j) (H.map (c.Œπ.app j))","decl":"/-- The image of a cocone in C under a functor G : C ‚•§ D is a cocone in D. -/\n@[simps!]\ndef mapCocone (c : Cocone F) : Cocone (F ‚ãô H) :=\n  (Cocones.functoriality F H).obj c\n\n"}
{"name":"CategoryTheory.Functor.mapCocone_pt","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nH : CategoryTheory.Functor C D\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\n‚ä¢ Eq (H.mapCocone c).pt (H.obj c.pt)","decl":"/-- The image of a cocone in C under a functor G : C ‚•§ D is a cocone in D. -/\n@[simps!]\ndef mapCocone (c : Cocone F) : Cocone (F ‚ãô H) :=\n  (Cocones.functoriality F H).obj c\n\n"}
{"name":"CategoryTheory.Functor.mapCoconeMapCocone_inv_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nE : Type u‚ÇÖ\ninst‚úù : CategoryTheory.Category.{v‚ÇÖ, u‚ÇÖ} E\nF : CategoryTheory.Functor J C\nH : CategoryTheory.Functor C D\nH' : CategoryTheory.Functor D E\nc : CategoryTheory.Limits.Cocone F\n‚ä¢ Eq (CategoryTheory.Functor.mapCoconeMapCocone c).inv.hom (CategoryTheory.CategoryStruct.id (H'.obj (H.obj c.pt)))","decl":"/-- The construction `mapCocone` respects functor composition. -/\n@[simps!]\nnoncomputable def mapCoconeMapCocone {F : J ‚•§ C} {H : C ‚•§ D} {H' : D ‚•§ E} (c : Cocone F) :\n    H'.mapCocone (H.mapCocone c) ‚âÖ (H ‚ãô H').mapCocone c := Cocones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Functor.mapCoconeMapCocone_hom_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nE : Type u‚ÇÖ\ninst‚úù : CategoryTheory.Category.{v‚ÇÖ, u‚ÇÖ} E\nF : CategoryTheory.Functor J C\nH : CategoryTheory.Functor C D\nH' : CategoryTheory.Functor D E\nc : CategoryTheory.Limits.Cocone F\n‚ä¢ Eq (CategoryTheory.Functor.mapCoconeMapCocone c).hom.hom (CategoryTheory.CategoryStruct.id (H'.obj (H.obj c.pt)))","decl":"/-- The construction `mapCocone` respects functor composition. -/\n@[simps!]\nnoncomputable def mapCoconeMapCocone {F : J ‚•§ C} {H : C ‚•§ D} {H' : D ‚•§ E} (c : Cocone F) :\n    H'.mapCocone (H.mapCocone c) ‚âÖ (H ‚ãô H').mapCocone c := Cocones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Functor.functorialityCompPostcompose_hom_app_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nF : CategoryTheory.Functor J C\nH H' : CategoryTheory.Functor C D\nŒ± : CategoryTheory.Iso H H'\nX : CategoryTheory.Limits.Cone F\n‚ä¢ Eq ((CategoryTheory.Functor.functorialityCompPostcompose Œ±).hom.app X).hom (Œ±.hom.app X.pt)","decl":"/-- `functoriality F _ ‚ãô postcompose (whisker_left F _)` simplifies to `functoriality F _`. -/\n@[simps!]\ndef functorialityCompPostcompose {H H' : C ‚•§ D} (Œ± : H ‚âÖ H') :\n    Cones.functoriality F H ‚ãô Cones.postcompose (whiskerLeft F Œ±.hom) ‚âÖ Cones.functoriality F H' :=\n  NatIso.ofComponents fun c => Cones.ext (Œ±.app _)\n\n"}
{"name":"CategoryTheory.Functor.functorialityCompPostcompose_inv_app_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nF : CategoryTheory.Functor J C\nH H' : CategoryTheory.Functor C D\nŒ± : CategoryTheory.Iso H H'\nX : CategoryTheory.Limits.Cone F\n‚ä¢ Eq ((CategoryTheory.Functor.functorialityCompPostcompose Œ±).inv.app X).hom (Œ±.inv.app X.pt)","decl":"/-- `functoriality F _ ‚ãô postcompose (whisker_left F _)` simplifies to `functoriality F _`. -/\n@[simps!]\ndef functorialityCompPostcompose {H H' : C ‚•§ D} (Œ± : H ‚âÖ H') :\n    Cones.functoriality F H ‚ãô Cones.postcompose (whiskerLeft F Œ±.hom) ‚âÖ Cones.functoriality F H' :=\n  NatIso.ofComponents fun c => Cones.ext (Œ±.app _)\n\n"}
{"name":"CategoryTheory.Functor.postcomposeWhiskerLeftMapCone_hom_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nF : CategoryTheory.Functor J C\nH H' : CategoryTheory.Functor C D\nŒ± : CategoryTheory.Iso H H'\nc : CategoryTheory.Limits.Cone F\n‚ä¢ Eq (CategoryTheory.Functor.postcomposeWhiskerLeftMapCone Œ± c).hom.hom (Œ±.hom.app c.pt)","decl":"/-- For `F : J ‚•§ C`, given a cone `c : Cone F`, and a natural isomorphism `Œ± : H ‚âÖ H'` for functors\n`H H' : C ‚•§ D`, the postcomposition of the cone `H.mapCone` using the isomorphism `Œ±` is\nisomorphic to the cone `H'.mapCone`.\n-/\n@[simps!]\ndef postcomposeWhiskerLeftMapCone {H H' : C ‚•§ D} (Œ± : H ‚âÖ H') (c : Cone F) :\n    (Cones.postcompose (whiskerLeft F Œ±.hom :)).obj (mapCone H c) ‚âÖ mapCone H' c :=\n  (functorialityCompPostcompose Œ±).app c\n\n"}
{"name":"CategoryTheory.Functor.postcomposeWhiskerLeftMapCone_inv_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nF : CategoryTheory.Functor J C\nH H' : CategoryTheory.Functor C D\nŒ± : CategoryTheory.Iso H H'\nc : CategoryTheory.Limits.Cone F\n‚ä¢ Eq (CategoryTheory.Functor.postcomposeWhiskerLeftMapCone Œ± c).inv.hom (Œ±.inv.app c.pt)","decl":"/-- For `F : J ‚•§ C`, given a cone `c : Cone F`, and a natural isomorphism `Œ± : H ‚âÖ H'` for functors\n`H H' : C ‚•§ D`, the postcomposition of the cone `H.mapCone` using the isomorphism `Œ±` is\nisomorphic to the cone `H'.mapCone`.\n-/\n@[simps!]\ndef postcomposeWhiskerLeftMapCone {H H' : C ‚•§ D} (Œ± : H ‚âÖ H') (c : Cone F) :\n    (Cones.postcompose (whiskerLeft F Œ±.hom :)).obj (mapCone H c) ‚âÖ mapCone H' c :=\n  (functorialityCompPostcompose Œ±).app c\n\n"}
{"name":"CategoryTheory.Functor.mapConePostcompose_inv_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nH : CategoryTheory.Functor C D\nF G : CategoryTheory.Functor J C\nŒ± : Quiver.Hom F G\nc : CategoryTheory.Limits.Cone F\n‚ä¢ Eq H.mapConePostcompose.inv.hom (CategoryTheory.CategoryStruct.id (H.obj c.pt))","decl":"/--\n`mapCone` commutes with `postcompose`. In particular, for `F : J ‚•§ C`, given a cone `c : Cone F`, a\nnatural transformation `Œ± : F ‚ü∂ G` and a functor `H : C ‚•§ D`, we have two obvious ways of producing\na cone over `G ‚ãô H`, and they are both isomorphic.\n-/\n@[simps!]\ndef mapConePostcompose {Œ± : F ‚ü∂ G} {c} :\n    mapCone H ((Cones.postcompose Œ±).obj c) ‚âÖ\n      (Cones.postcompose (whiskerRight Œ± H :)).obj (mapCone H c) :=\n  Cones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Functor.mapConePostcompose_hom_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nH : CategoryTheory.Functor C D\nF G : CategoryTheory.Functor J C\nŒ± : Quiver.Hom F G\nc : CategoryTheory.Limits.Cone F\n‚ä¢ Eq H.mapConePostcompose.hom.hom (CategoryTheory.CategoryStruct.id (H.obj c.pt))","decl":"/--\n`mapCone` commutes with `postcompose`. In particular, for `F : J ‚•§ C`, given a cone `c : Cone F`, a\nnatural transformation `Œ± : F ‚ü∂ G` and a functor `H : C ‚•§ D`, we have two obvious ways of producing\na cone over `G ‚ãô H`, and they are both isomorphic.\n-/\n@[simps!]\ndef mapConePostcompose {Œ± : F ‚ü∂ G} {c} :\n    mapCone H ((Cones.postcompose Œ±).obj c) ‚âÖ\n      (Cones.postcompose (whiskerRight Œ± H :)).obj (mapCone H c) :=\n  Cones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Functor.mapConePostcomposeEquivalenceFunctor_inv_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nH : CategoryTheory.Functor C D\nF G : CategoryTheory.Functor J C\nŒ± : CategoryTheory.Iso F G\nc : CategoryTheory.Limits.Cone F\n‚ä¢ Eq H.mapConePostcomposeEquivalenceFunctor.inv.hom (CategoryTheory.CategoryStruct.id (H.obj c.pt))","decl":"/-- `mapCone` commutes with `postcomposeEquivalence`\n-/\n@[simps!]\ndef mapConePostcomposeEquivalenceFunctor {Œ± : F ‚âÖ G} {c} :\n    mapCone H ((Cones.postcomposeEquivalence Œ±).functor.obj c) ‚âÖ\n      (Cones.postcomposeEquivalence (isoWhiskerRight Œ± H :)).functor.obj (mapCone H c) :=\n  Cones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Functor.mapConePostcomposeEquivalenceFunctor_hom_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nH : CategoryTheory.Functor C D\nF G : CategoryTheory.Functor J C\nŒ± : CategoryTheory.Iso F G\nc : CategoryTheory.Limits.Cone F\n‚ä¢ Eq H.mapConePostcomposeEquivalenceFunctor.hom.hom (CategoryTheory.CategoryStruct.id (H.obj c.pt))","decl":"/-- `mapCone` commutes with `postcomposeEquivalence`\n-/\n@[simps!]\ndef mapConePostcomposeEquivalenceFunctor {Œ± : F ‚âÖ G} {c} :\n    mapCone H ((Cones.postcomposeEquivalence Œ±).functor.obj c) ‚âÖ\n      (Cones.postcomposeEquivalence (isoWhiskerRight Œ± H :)).functor.obj (mapCone H c) :=\n  Cones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Functor.functorialityCompPrecompose_hom_app_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nF : CategoryTheory.Functor J C\nH H' : CategoryTheory.Functor C D\nŒ± : CategoryTheory.Iso H H'\nX : CategoryTheory.Limits.Cocone F\n‚ä¢ Eq ((CategoryTheory.Functor.functorialityCompPrecompose Œ±).hom.app X).hom (Œ±.hom.app X.pt)","decl":"/-- `functoriality F _ ‚ãô precompose (whiskerLeft F _)` simplifies to `functoriality F _`. -/\n@[simps!]\ndef functorialityCompPrecompose {H H' : C ‚•§ D} (Œ± : H ‚âÖ H') :\n    Cocones.functoriality F H ‚ãô Cocones.precompose (whiskerLeft F Œ±.inv) ‚âÖ\n      Cocones.functoriality F H' :=\n  NatIso.ofComponents fun c => Cocones.ext (Œ±.app _)\n\n"}
{"name":"CategoryTheory.Functor.functorialityCompPrecompose_inv_app_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nF : CategoryTheory.Functor J C\nH H' : CategoryTheory.Functor C D\nŒ± : CategoryTheory.Iso H H'\nX : CategoryTheory.Limits.Cocone F\n‚ä¢ Eq ((CategoryTheory.Functor.functorialityCompPrecompose Œ±).inv.app X).hom (Œ±.inv.app X.pt)","decl":"/-- `functoriality F _ ‚ãô precompose (whiskerLeft F _)` simplifies to `functoriality F _`. -/\n@[simps!]\ndef functorialityCompPrecompose {H H' : C ‚•§ D} (Œ± : H ‚âÖ H') :\n    Cocones.functoriality F H ‚ãô Cocones.precompose (whiskerLeft F Œ±.inv) ‚âÖ\n      Cocones.functoriality F H' :=\n  NatIso.ofComponents fun c => Cocones.ext (Œ±.app _)\n\n"}
{"name":"CategoryTheory.Functor.precomposeWhiskerLeftMapCocone_hom_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nF : CategoryTheory.Functor J C\nH H' : CategoryTheory.Functor C D\nŒ± : CategoryTheory.Iso H H'\nc : CategoryTheory.Limits.Cocone F\n‚ä¢ Eq (CategoryTheory.Functor.precomposeWhiskerLeftMapCocone Œ± c).hom.hom (Œ±.hom.app c.pt)","decl":"/--\nFor `F : J ‚•§ C`, given a cocone `c : Cocone F`, and a natural isomorphism `Œ± : H ‚âÖ H'` for functors\n`H H' : C ‚•§ D`, the precomposition of the cocone `H.mapCocone` using the isomorphism `Œ±` is\nisomorphic to the cocone `H'.mapCocone`.\n-/\n@[simps!]\ndef precomposeWhiskerLeftMapCocone {H H' : C ‚•§ D} (Œ± : H ‚âÖ H') (c : Cocone F) :\n    (Cocones.precompose (whiskerLeft F Œ±.inv :)).obj (mapCocone H c) ‚âÖ mapCocone H' c :=\n  (functorialityCompPrecompose Œ±).app c\n\n"}
{"name":"CategoryTheory.Functor.precomposeWhiskerLeftMapCocone_inv_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nF : CategoryTheory.Functor J C\nH H' : CategoryTheory.Functor C D\nŒ± : CategoryTheory.Iso H H'\nc : CategoryTheory.Limits.Cocone F\n‚ä¢ Eq (CategoryTheory.Functor.precomposeWhiskerLeftMapCocone Œ± c).inv.hom (Œ±.inv.app c.pt)","decl":"/--\nFor `F : J ‚•§ C`, given a cocone `c : Cocone F`, and a natural isomorphism `Œ± : H ‚âÖ H'` for functors\n`H H' : C ‚•§ D`, the precomposition of the cocone `H.mapCocone` using the isomorphism `Œ±` is\nisomorphic to the cocone `H'.mapCocone`.\n-/\n@[simps!]\ndef precomposeWhiskerLeftMapCocone {H H' : C ‚•§ D} (Œ± : H ‚âÖ H') (c : Cocone F) :\n    (Cocones.precompose (whiskerLeft F Œ±.inv :)).obj (mapCocone H c) ‚âÖ mapCocone H' c :=\n  (functorialityCompPrecompose Œ±).app c\n\n"}
{"name":"CategoryTheory.Functor.mapCoconePrecompose_hom_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nH : CategoryTheory.Functor C D\nF G : CategoryTheory.Functor J C\nŒ± : Quiver.Hom F G\nc : CategoryTheory.Limits.Cocone G\n‚ä¢ Eq H.mapCoconePrecompose.hom.hom (CategoryTheory.CategoryStruct.id (H.obj c.pt))","decl":"/-- `map_cocone` commutes with `precompose`. In particular, for `F : J ‚•§ C`, given a cocone\n`c : Cocone F`, a natural transformation `Œ± : F ‚ü∂ G` and a functor `H : C ‚•§ D`, we have two obvious\nways of producing a cocone over `G ‚ãô H`, and they are both isomorphic.\n-/\n@[simps!]\ndef mapCoconePrecompose {Œ± : F ‚ü∂ G} {c} :\n    mapCocone H ((Cocones.precompose Œ±).obj c) ‚âÖ\n      (Cocones.precompose (whiskerRight Œ± H :)).obj (mapCocone H c) :=\n  Cocones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Functor.mapCoconePrecompose_inv_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nH : CategoryTheory.Functor C D\nF G : CategoryTheory.Functor J C\nŒ± : Quiver.Hom F G\nc : CategoryTheory.Limits.Cocone G\n‚ä¢ Eq H.mapCoconePrecompose.inv.hom (CategoryTheory.CategoryStruct.id (H.obj c.pt))","decl":"/-- `map_cocone` commutes with `precompose`. In particular, for `F : J ‚•§ C`, given a cocone\n`c : Cocone F`, a natural transformation `Œ± : F ‚ü∂ G` and a functor `H : C ‚•§ D`, we have two obvious\nways of producing a cocone over `G ‚ãô H`, and they are both isomorphic.\n-/\n@[simps!]\ndef mapCoconePrecompose {Œ± : F ‚ü∂ G} {c} :\n    mapCocone H ((Cocones.precompose Œ±).obj c) ‚âÖ\n      (Cocones.precompose (whiskerRight Œ± H :)).obj (mapCocone H c) :=\n  Cocones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Functor.mapCoconePrecomposeEquivalenceFunctor_inv_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nH : CategoryTheory.Functor C D\nF G : CategoryTheory.Functor J C\nŒ± : CategoryTheory.Iso F G\nc : CategoryTheory.Limits.Cocone G\n‚ä¢ Eq H.mapCoconePrecomposeEquivalenceFunctor.inv.hom (CategoryTheory.CategoryStruct.id (H.obj c.pt))","decl":"/-- `mapCocone` commutes with `precomposeEquivalence`\n-/\n@[simps!]\ndef mapCoconePrecomposeEquivalenceFunctor {Œ± : F ‚âÖ G} {c} :\n    mapCocone H ((Cocones.precomposeEquivalence Œ±).functor.obj c) ‚âÖ\n      (Cocones.precomposeEquivalence (isoWhiskerRight Œ± H :)).functor.obj (mapCocone H c) :=\n  Cocones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Functor.mapCoconePrecomposeEquivalenceFunctor_hom_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nH : CategoryTheory.Functor C D\nF G : CategoryTheory.Functor J C\nŒ± : CategoryTheory.Iso F G\nc : CategoryTheory.Limits.Cocone G\n‚ä¢ Eq H.mapCoconePrecomposeEquivalenceFunctor.hom.hom (CategoryTheory.CategoryStruct.id (H.obj c.pt))","decl":"/-- `mapCocone` commutes with `precomposeEquivalence`\n-/\n@[simps!]\ndef mapCoconePrecomposeEquivalenceFunctor {Œ± : F ‚âÖ G} {c} :\n    mapCocone H ((Cocones.precomposeEquivalence Œ±).functor.obj c) ‚âÖ\n      (Cocones.precomposeEquivalence (isoWhiskerRight Œ± H :)).functor.obj (mapCocone H c) :=\n  Cocones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Functor.mapConeWhisker_hom_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nK : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} K\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nH : CategoryTheory.Functor C D\nF : CategoryTheory.Functor J C\nE : CategoryTheory.Functor K J\nc : CategoryTheory.Limits.Cone F\n‚ä¢ Eq H.mapConeWhisker.hom.hom (CategoryTheory.CategoryStruct.id (H.obj c.pt))","decl":"/-- `mapCone` commutes with `whisker`\n-/\n@[simps!]\ndef mapConeWhisker {E : K ‚•§ J} {c : Cone F} : mapCone H (c.whisker E) ‚âÖ (mapCone H c).whisker E :=\n  Cones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Functor.mapConeWhisker_inv_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nK : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} K\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nH : CategoryTheory.Functor C D\nF : CategoryTheory.Functor J C\nE : CategoryTheory.Functor K J\nc : CategoryTheory.Limits.Cone F\n‚ä¢ Eq H.mapConeWhisker.inv.hom (CategoryTheory.CategoryStruct.id (H.obj c.pt))","decl":"/-- `mapCone` commutes with `whisker`\n-/\n@[simps!]\ndef mapConeWhisker {E : K ‚•§ J} {c : Cone F} : mapCone H (c.whisker E) ‚âÖ (mapCone H c).whisker E :=\n  Cones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Functor.mapCoconeWhisker_hom_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nK : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} K\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nH : CategoryTheory.Functor C D\nF : CategoryTheory.Functor J C\nE : CategoryTheory.Functor K J\nc : CategoryTheory.Limits.Cocone F\n‚ä¢ Eq H.mapCoconeWhisker.hom.hom (CategoryTheory.CategoryStruct.id (H.obj c.pt))","decl":"/-- `mapCocone` commutes with `whisker`\n-/\n@[simps!]\ndef mapCoconeWhisker {E : K ‚•§ J} {c : Cocone F} :\n    mapCocone H (c.whisker E) ‚âÖ (mapCocone H c).whisker E :=\n  Cocones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Functor.mapCoconeWhisker_inv_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nK : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} K\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nH : CategoryTheory.Functor C D\nF : CategoryTheory.Functor J C\nE : CategoryTheory.Functor K J\nc : CategoryTheory.Limits.Cocone F\n‚ä¢ Eq H.mapCoconeWhisker.inv.hom (CategoryTheory.CategoryStruct.id (H.obj c.pt))","decl":"/-- `mapCocone` commutes with `whisker`\n-/\n@[simps!]\ndef mapCoconeWhisker {E : K ‚•§ J} {c : Cocone F} :\n    mapCocone H (c.whisker E) ‚âÖ (mapCocone H c).whisker E :=\n  Cocones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.Cocone.op_pt","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\n‚ä¢ Eq c.op.pt { unop := c.pt }","decl":"/-- Change a `Cocone F` into a `Cone F.op`. -/\n@[simps]\ndef Cocone.op (c : Cocone F) : Cone F.op where\n  pt := Opposite.op c.pt\n  œÄ := NatTrans.op c.Œπ\n\n"}
{"name":"CategoryTheory.Limits.Cocone.op_œÄ","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\n‚ä¢ Eq c.op.œÄ (CategoryTheory.NatTrans.op c.Œπ)","decl":"/-- Change a `Cocone F` into a `Cone F.op`. -/\n@[simps]\ndef Cocone.op (c : Cocone F) : Cone F.op where\n  pt := Opposite.op c.pt\n  œÄ := NatTrans.op c.Œπ\n\n"}
{"name":"CategoryTheory.Limits.Cone.op_Œπ","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cone F\n‚ä¢ Eq c.op.Œπ (CategoryTheory.NatTrans.op c.œÄ)","decl":"/-- Change a `Cone F` into a `Cocone F.op`. -/\n@[simps]\ndef Cone.op (c : Cone F) : Cocone F.op where\n  pt := Opposite.op c.pt\n  Œπ := NatTrans.op c.œÄ\n\n"}
{"name":"CategoryTheory.Limits.Cone.op_pt","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cone F\n‚ä¢ Eq c.op.pt { unop := c.pt }","decl":"/-- Change a `Cone F` into a `Cocone F.op`. -/\n@[simps]\ndef Cone.op (c : Cone F) : Cocone F.op where\n  pt := Opposite.op c.pt\n  Œπ := NatTrans.op c.œÄ\n\n"}
{"name":"CategoryTheory.Limits.Cocone.unop_pt","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F.op\n‚ä¢ Eq c.unop.pt (Opposite.unop c.pt)","decl":"/-- Change a `Cocone F.op` into a `Cone F`. -/\n@[simps]\ndef Cocone.unop (c : Cocone F.op) : Cone F where\n  pt := Opposite.unop c.pt\n  œÄ := NatTrans.removeOp c.Œπ\n\n"}
{"name":"CategoryTheory.Limits.Cocone.unop_œÄ","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F.op\n‚ä¢ Eq c.unop.œÄ (CategoryTheory.NatTrans.removeOp c.Œπ)","decl":"/-- Change a `Cocone F.op` into a `Cone F`. -/\n@[simps]\ndef Cocone.unop (c : Cocone F.op) : Cone F where\n  pt := Opposite.unop c.pt\n  œÄ := NatTrans.removeOp c.Œπ\n\n"}
{"name":"CategoryTheory.Limits.Cone.unop_pt","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cone F.op\n‚ä¢ Eq c.unop.pt (Opposite.unop c.pt)","decl":"/-- Change a `Cone F.op` into a `Cocone F`. -/\n@[simps]\ndef Cone.unop (c : Cone F.op) : Cocone F where\n  pt := Opposite.unop c.pt\n  Œπ := NatTrans.removeOp c.œÄ\n\n"}
{"name":"CategoryTheory.Limits.Cone.unop_Œπ","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cone F.op\n‚ä¢ Eq c.unop.Œπ (CategoryTheory.NatTrans.removeOp c.œÄ)","decl":"/-- Change a `Cone F.op` into a `Cocone F`. -/\n@[simps]\ndef Cone.unop (c : Cone F.op) : Cocone F where\n  pt := Opposite.unop c.pt\n  Œπ := NatTrans.removeOp c.œÄ\n\n"}
{"name":"CategoryTheory.Limits.coconeEquivalenceOpConeOp_functor_obj","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\n‚ä¢ Eq ((CategoryTheory.Limits.coconeEquivalenceOpConeOp F).functor.obj c) { unop := c.op }","decl":"attribute [simps] coconeEquivalenceOpConeOp\n\n"}
{"name":"CategoryTheory.Limits.coconeEquivalenceOpConeOp_inverse_map_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nX Y : Opposite (CategoryTheory.Limits.Cone F.op)\nf : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.Limits.coconeEquivalenceOpConeOp F).inverse.map f).hom f.unop.hom.unop","decl":"attribute [simps] coconeEquivalenceOpConeOp\n\n"}
{"name":"CategoryTheory.Limits.coconeEquivalenceOpConeOp_unitIso","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\n‚ä¢ Eq (CategoryTheory.Limits.coconeEquivalenceOpConeOp F).unitIso (CategoryTheory.NatIso.ofComponents (fun c => CategoryTheory.Limits.Cocones.ext (CategoryTheory.Iso.refl ((CategoryTheory.Functor.id (CategoryTheory.Limits.Cocone F)).obj c).pt) ‚ãØ) ‚ãØ)","decl":"attribute [simps] coconeEquivalenceOpConeOp\n\n"}
{"name":"CategoryTheory.Limits.coconeEquivalenceOpConeOp_counitIso","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\n‚ä¢ Eq (CategoryTheory.Limits.coconeEquivalenceOpConeOp F).counitIso (CategoryTheory.NatIso.ofComponents (fun c => Opposite.rec' (fun X => (CategoryTheory.Limits.Cones.ext (CategoryTheory.Iso.refl X.pt) ‚ãØ).op) c) ‚ãØ)","decl":"attribute [simps] coconeEquivalenceOpConeOp\n\n"}
{"name":"CategoryTheory.Limits.coconeEquivalenceOpConeOp_inverse_obj","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc : Opposite (CategoryTheory.Limits.Cone F.op)\n‚ä¢ Eq ((CategoryTheory.Limits.coconeEquivalenceOpConeOp F).inverse.obj c) (Opposite.unop c).unop","decl":"attribute [simps] coconeEquivalenceOpConeOp\n\n"}
{"name":"CategoryTheory.Limits.coconeEquivalenceOpConeOp_functor_map","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nX Y : CategoryTheory.Limits.Cocone F\nf : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.Limits.coconeEquivalenceOpConeOp F).functor.map f) (Quiver.Hom.op { hom := f.hom.op, w := ‚ãØ })","decl":"attribute [simps] coconeEquivalenceOpConeOp\n\n"}
{"name":"CategoryTheory.Limits.coneOfCoconeLeftOp_pt","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J (Opposite C)\nc : CategoryTheory.Limits.Cocone F.leftOp\n‚ä¢ Eq (CategoryTheory.Limits.coneOfCoconeLeftOp c).pt { unop := c.pt }","decl":"/-- Change a cocone on `F.leftOp : J·µí·µñ ‚•§ C` to a cocone on `F : J ‚•§ C·µí·µñ`. -/\n@[simps!]\ndef coneOfCoconeLeftOp (c : Cocone F.leftOp) : Cone F where\n  pt := op c.pt\n  œÄ := NatTrans.removeLeftOp c.Œπ\n\n"}
{"name":"CategoryTheory.Limits.coneOfCoconeLeftOp_œÄ_app","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J (Opposite C)\nc : CategoryTheory.Limits.Cocone F.leftOp\nX : J\n‚ä¢ Eq ((CategoryTheory.Limits.coneOfCoconeLeftOp c).œÄ.app X) (c.Œπ.app { unop := X }).op","decl":"/-- Change a cocone on `F.leftOp : J·µí·µñ ‚•§ C` to a cocone on `F : J ‚•§ C·µí·µñ`. -/\n@[simps!]\ndef coneOfCoconeLeftOp (c : Cocone F.leftOp) : Cone F where\n  pt := op c.pt\n  œÄ := NatTrans.removeLeftOp c.Œπ\n\n"}
{"name":"CategoryTheory.Limits.coconeLeftOpOfCone_Œπ_app","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J (Opposite C)\nc : CategoryTheory.Limits.Cone F\nX : Opposite J\n‚ä¢ Eq ((CategoryTheory.Limits.coconeLeftOpOfCone c).Œπ.app X) (c.œÄ.app (Opposite.unop X)).unop","decl":"/-- Change a cone on `F : J ‚•§ C·µí·µñ` to a cocone on `F.leftOp : J·µí·µñ ‚•§ C`. -/\n@[simps!]\ndef coconeLeftOpOfCone (c : Cone F) : Cocone F.leftOp where\n  pt := unop c.pt\n  Œπ := NatTrans.leftOp c.œÄ\n\n/- When trying use `@[simps]` to generate the `Œπ_app` field of this definition, `@[simps]` tries to\n  reduce the RHS using `expr.dsimp` and `expr.simp`, but for some reason the expression is not\n  being simplified properly. -/\n"}
{"name":"CategoryTheory.Limits.coconeLeftOpOfCone_pt","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J (Opposite C)\nc : CategoryTheory.Limits.Cone F\n‚ä¢ Eq (CategoryTheory.Limits.coconeLeftOpOfCone c).pt (Opposite.unop c.pt)","decl":"/-- Change a cone on `F : J ‚•§ C·µí·µñ` to a cocone on `F.leftOp : J·µí·µñ ‚•§ C`. -/\n@[simps!]\ndef coconeLeftOpOfCone (c : Cone F) : Cocone F.leftOp where\n  pt := unop c.pt\n  Œπ := NatTrans.leftOp c.œÄ\n\n/- When trying use `@[simps]` to generate the `Œπ_app` field of this definition, `@[simps]` tries to\n  reduce the RHS using `expr.dsimp` and `expr.simp`, but for some reason the expression is not\n  being simplified properly. -/\n"}
{"name":"CategoryTheory.Limits.coconeOfConeLeftOp_pt","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J (Opposite C)\nc : CategoryTheory.Limits.Cone F.leftOp\n‚ä¢ Eq (CategoryTheory.Limits.coconeOfConeLeftOp c).pt { unop := c.pt }","decl":"/-- Change a cone on `F.leftOp : J·µí·µñ ‚•§ C` to a cocone on `F : J ‚•§ C·µí·µñ`. -/\n@[simps pt]\ndef coconeOfConeLeftOp (c : Cone F.leftOp) : Cocone F where\n  pt := op c.pt\n  Œπ := NatTrans.removeLeftOp c.œÄ\n\n"}
{"name":"CategoryTheory.Limits.coconeOfConeLeftOp_Œπ_app","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J (Opposite C)\nc : CategoryTheory.Limits.Cone F.leftOp\nj : J\n‚ä¢ Eq ((CategoryTheory.Limits.coconeOfConeLeftOp c).Œπ.app j) (c.œÄ.app { unop := j }).op","decl":"@[simp]\ntheorem coconeOfConeLeftOp_Œπ_app (c : Cone F.leftOp) (j) :\n    (coconeOfConeLeftOp c).Œπ.app j = (c.œÄ.app (op j)).op := by\n  dsimp only [coconeOfConeLeftOp]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.coneLeftOpOfCocone_œÄ_app","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J (Opposite C)\nc : CategoryTheory.Limits.Cocone F\nX : Opposite J\n‚ä¢ Eq ((CategoryTheory.Limits.coneLeftOpOfCocone c).œÄ.app X) (c.Œπ.app (Opposite.unop X)).unop","decl":"/-- Change a cocone on `F : J ‚•§ C·µí·µñ` to a cone on `F.leftOp : J·µí·µñ ‚•§ C`. -/\n@[simps!]\ndef coneLeftOpOfCocone (c : Cocone F) : Cone F.leftOp where\n  pt := unop c.pt\n  œÄ := NatTrans.leftOp c.Œπ\n\n"}
{"name":"CategoryTheory.Limits.coneLeftOpOfCocone_pt","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J (Opposite C)\nc : CategoryTheory.Limits.Cocone F\n‚ä¢ Eq (CategoryTheory.Limits.coneLeftOpOfCocone c).pt (Opposite.unop c.pt)","decl":"/-- Change a cocone on `F : J ‚•§ C·µí·µñ` to a cone on `F.leftOp : J·µí·µñ ‚•§ C`. -/\n@[simps!]\ndef coneLeftOpOfCocone (c : Cocone F) : Cone F.leftOp where\n  pt := unop c.pt\n  œÄ := NatTrans.leftOp c.Œπ\n\n"}
{"name":"CategoryTheory.Limits.coneOfCoconeRightOp_œÄ","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor (Opposite J) C\nc : CategoryTheory.Limits.Cocone F.rightOp\n‚ä¢ Eq (CategoryTheory.Limits.coneOfCoconeRightOp c).œÄ (CategoryTheory.NatTrans.removeRightOp c.Œπ)","decl":"/-- Change a cocone on `F.rightOp : J ‚•§ C·µí·µñ` to a cone on `F : J·µí·µñ ‚•§ C`. -/\n@[simps]\ndef coneOfCoconeRightOp (c : Cocone F.rightOp) : Cone F where\n  pt := unop c.pt\n  œÄ := NatTrans.removeRightOp c.Œπ\n\n"}
{"name":"CategoryTheory.Limits.coneOfCoconeRightOp_pt","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor (Opposite J) C\nc : CategoryTheory.Limits.Cocone F.rightOp\n‚ä¢ Eq (CategoryTheory.Limits.coneOfCoconeRightOp c).pt (Opposite.unop c.pt)","decl":"/-- Change a cocone on `F.rightOp : J ‚•§ C·µí·µñ` to a cone on `F : J·µí·µñ ‚•§ C`. -/\n@[simps]\ndef coneOfCoconeRightOp (c : Cocone F.rightOp) : Cone F where\n  pt := unop c.pt\n  œÄ := NatTrans.removeRightOp c.Œπ\n\n"}
{"name":"CategoryTheory.Limits.coconeRightOpOfCone_Œπ","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor (Opposite J) C\nc : CategoryTheory.Limits.Cone F\n‚ä¢ Eq (CategoryTheory.Limits.coconeRightOpOfCone c).Œπ (CategoryTheory.NatTrans.rightOp c.œÄ)","decl":"/-- Change a cone on `F : J·µí·µñ ‚•§ C` to a cocone on `F.rightOp : J·µí·µñ ‚•§ C`. -/\n@[simps]\ndef coconeRightOpOfCone (c : Cone F) : Cocone F.rightOp where\n  pt := op c.pt\n  Œπ := NatTrans.rightOp c.œÄ\n\n"}
{"name":"CategoryTheory.Limits.coconeRightOpOfCone_pt","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor (Opposite J) C\nc : CategoryTheory.Limits.Cone F\n‚ä¢ Eq (CategoryTheory.Limits.coconeRightOpOfCone c).pt { unop := c.pt }","decl":"/-- Change a cone on `F : J·µí·µñ ‚•§ C` to a cocone on `F.rightOp : J·µí·µñ ‚•§ C`. -/\n@[simps]\ndef coconeRightOpOfCone (c : Cone F) : Cocone F.rightOp where\n  pt := op c.pt\n  Œπ := NatTrans.rightOp c.œÄ\n\n"}
{"name":"CategoryTheory.Limits.coconeOfConeRightOp_pt","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor (Opposite J) C\nc : CategoryTheory.Limits.Cone F.rightOp\n‚ä¢ Eq (CategoryTheory.Limits.coconeOfConeRightOp c).pt (Opposite.unop c.pt)","decl":"/-- Change a cone on `F.rightOp : J ‚•§ C·µí·µñ` to a cocone on `F : J·µí·µñ ‚•§ C`. -/\n@[simps]\ndef coconeOfConeRightOp (c : Cone F.rightOp) : Cocone F where\n  pt := unop c.pt\n  Œπ := NatTrans.removeRightOp c.œÄ\n\n"}
{"name":"CategoryTheory.Limits.coconeOfConeRightOp_Œπ","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor (Opposite J) C\nc : CategoryTheory.Limits.Cone F.rightOp\n‚ä¢ Eq (CategoryTheory.Limits.coconeOfConeRightOp c).Œπ (CategoryTheory.NatTrans.removeRightOp c.œÄ)","decl":"/-- Change a cone on `F.rightOp : J ‚•§ C·µí·µñ` to a cocone on `F : J·µí·µñ ‚•§ C`. -/\n@[simps]\ndef coconeOfConeRightOp (c : Cone F.rightOp) : Cocone F where\n  pt := unop c.pt\n  Œπ := NatTrans.removeRightOp c.œÄ\n\n"}
{"name":"CategoryTheory.Limits.coneRightOpOfCocone_œÄ","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor (Opposite J) C\nc : CategoryTheory.Limits.Cocone F\n‚ä¢ Eq (CategoryTheory.Limits.coneRightOpOfCocone c).œÄ (CategoryTheory.NatTrans.rightOp c.Œπ)","decl":"/-- Change a cocone on `F : J·µí·µñ ‚•§ C` to a cone on `F.rightOp : J ‚•§ C·µí·µñ`. -/\n@[simps]\ndef coneRightOpOfCocone (c : Cocone F) : Cone F.rightOp where\n  pt := op c.pt\n  œÄ := NatTrans.rightOp c.Œπ\n\n"}
{"name":"CategoryTheory.Limits.coneRightOpOfCocone_pt","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor (Opposite J) C\nc : CategoryTheory.Limits.Cocone F\n‚ä¢ Eq (CategoryTheory.Limits.coneRightOpOfCocone c).pt { unop := c.pt }","decl":"/-- Change a cocone on `F : J·µí·µñ ‚•§ C` to a cone on `F.rightOp : J ‚•§ C·µí·µñ`. -/\n@[simps]\ndef coneRightOpOfCocone (c : Cocone F) : Cone F.rightOp where\n  pt := op c.pt\n  œÄ := NatTrans.rightOp c.Œπ\n\n"}
{"name":"CategoryTheory.Limits.coneOfCoconeUnop_pt","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor (Opposite J) (Opposite C)\nc : CategoryTheory.Limits.Cocone F.unop\n‚ä¢ Eq (CategoryTheory.Limits.coneOfCoconeUnop c).pt { unop := c.pt }","decl":"/-- Change a cocone on `F.unop : J ‚•§ C` into a cone on `F : J·µí·µñ ‚•§ C·µí·µñ`. -/\n@[simps]\ndef coneOfCoconeUnop (c : Cocone F.unop) : Cone F where\n  pt := op c.pt\n  œÄ := NatTrans.removeUnop c.Œπ\n\n"}
{"name":"CategoryTheory.Limits.coneOfCoconeUnop_œÄ","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor (Opposite J) (Opposite C)\nc : CategoryTheory.Limits.Cocone F.unop\n‚ä¢ Eq (CategoryTheory.Limits.coneOfCoconeUnop c).œÄ (CategoryTheory.NatTrans.removeUnop c.Œπ)","decl":"/-- Change a cocone on `F.unop : J ‚•§ C` into a cone on `F : J·µí·µñ ‚•§ C·µí·µñ`. -/\n@[simps]\ndef coneOfCoconeUnop (c : Cocone F.unop) : Cone F where\n  pt := op c.pt\n  œÄ := NatTrans.removeUnop c.Œπ\n\n"}
{"name":"CategoryTheory.Limits.coconeUnopOfCone_Œπ","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor (Opposite J) (Opposite C)\nc : CategoryTheory.Limits.Cone F\n‚ä¢ Eq (CategoryTheory.Limits.coconeUnopOfCone c).Œπ (CategoryTheory.NatTrans.unop c.œÄ)","decl":"/-- Change a cone on `F : J·µí·µñ ‚•§ C·µí·µñ` into a cocone on `F.unop : J ‚•§ C`. -/\n@[simps]\ndef coconeUnopOfCone (c : Cone F) : Cocone F.unop where\n  pt := unop c.pt\n  Œπ := NatTrans.unop c.œÄ\n\n"}
{"name":"CategoryTheory.Limits.coconeUnopOfCone_pt","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor (Opposite J) (Opposite C)\nc : CategoryTheory.Limits.Cone F\n‚ä¢ Eq (CategoryTheory.Limits.coconeUnopOfCone c).pt (Opposite.unop c.pt)","decl":"/-- Change a cone on `F : J·µí·µñ ‚•§ C·µí·µñ` into a cocone on `F.unop : J ‚•§ C`. -/\n@[simps]\ndef coconeUnopOfCone (c : Cone F) : Cocone F.unop where\n  pt := unop c.pt\n  Œπ := NatTrans.unop c.œÄ\n\n"}
{"name":"CategoryTheory.Limits.coconeOfConeUnop_Œπ","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor (Opposite J) (Opposite C)\nc : CategoryTheory.Limits.Cone F.unop\n‚ä¢ Eq (CategoryTheory.Limits.coconeOfConeUnop c).Œπ (CategoryTheory.NatTrans.removeUnop c.œÄ)","decl":"/-- Change a cone on `F.unop : J ‚•§ C` into a cocone on `F : J·µí·µñ ‚•§ C·µí·µñ`. -/\n@[simps]\ndef coconeOfConeUnop (c : Cone F.unop) : Cocone F where\n  pt := op c.pt\n  Œπ := NatTrans.removeUnop c.œÄ\n\n"}
{"name":"CategoryTheory.Limits.coconeOfConeUnop_pt","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor (Opposite J) (Opposite C)\nc : CategoryTheory.Limits.Cone F.unop\n‚ä¢ Eq (CategoryTheory.Limits.coconeOfConeUnop c).pt { unop := c.pt }","decl":"/-- Change a cone on `F.unop : J ‚•§ C` into a cocone on `F : J·µí·µñ ‚•§ C·µí·µñ`. -/\n@[simps]\ndef coconeOfConeUnop (c : Cone F.unop) : Cocone F where\n  pt := op c.pt\n  Œπ := NatTrans.removeUnop c.œÄ\n\n"}
{"name":"CategoryTheory.Limits.coneUnopOfCocone_œÄ","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor (Opposite J) (Opposite C)\nc : CategoryTheory.Limits.Cocone F\n‚ä¢ Eq (CategoryTheory.Limits.coneUnopOfCocone c).œÄ (CategoryTheory.NatTrans.unop c.Œπ)","decl":"/-- Change a cocone on `F : J·µí·µñ ‚•§ C·µí·µñ` into a cone on `F.unop : J ‚•§ C`. -/\n@[simps]\ndef coneUnopOfCocone (c : Cocone F) : Cone F.unop where\n  pt := unop c.pt\n  œÄ := NatTrans.unop c.Œπ\n\n"}
{"name":"CategoryTheory.Limits.coneUnopOfCocone_pt","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor (Opposite J) (Opposite C)\nc : CategoryTheory.Limits.Cocone F\n‚ä¢ Eq (CategoryTheory.Limits.coneUnopOfCocone c).pt (Opposite.unop c.pt)","decl":"/-- Change a cocone on `F : J·µí·µñ ‚•§ C·µí·µñ` into a cone on `F.unop : J ‚•§ C`. -/\n@[simps]\ndef coneUnopOfCocone (c : Cocone F) : Cone F.unop where\n  pt := unop c.pt\n  œÄ := NatTrans.unop c.Œπ\n\n"}
{"name":"CategoryTheory.Functor.mapConeOp_hom_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nF : CategoryTheory.Functor J C\nG : CategoryTheory.Functor C D\nt : CategoryTheory.Limits.Cone F\n‚ä¢ Eq (CategoryTheory.Functor.mapConeOp G t).hom.hom (CategoryTheory.CategoryStruct.id { unop := G.obj t.pt })","decl":"/-- The opposite cocone of the image of a cone is the image of the opposite cocone. -/\n@[simps!]\ndef mapConeOp (t : Cone F) : (mapCone G t).op ‚âÖ mapCocone G.op t.op :=\n  Cocones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Functor.mapConeOp_inv_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nF : CategoryTheory.Functor J C\nG : CategoryTheory.Functor C D\nt : CategoryTheory.Limits.Cone F\n‚ä¢ Eq (CategoryTheory.Functor.mapConeOp G t).inv.hom (CategoryTheory.CategoryStruct.id { unop := G.obj t.pt })","decl":"/-- The opposite cocone of the image of a cone is the image of the opposite cocone. -/\n@[simps!]\ndef mapConeOp (t : Cone F) : (mapCone G t).op ‚âÖ mapCocone G.op t.op :=\n  Cocones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Functor.mapCoconeOp_hom_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nF : CategoryTheory.Functor J C\nG : CategoryTheory.Functor C D\nt : CategoryTheory.Limits.Cocone F\n‚ä¢ Eq (CategoryTheory.Functor.mapCoconeOp G).hom.hom (CategoryTheory.CategoryStruct.id { unop := G.obj t.pt })","decl":"/-- The opposite cone of the image of a cocone is the image of the opposite cone. -/\n@[simps!]\ndef mapCoconeOp {t : Cocone F} : (mapCocone G t).op ‚âÖ mapCone G.op t.op :=\n  Cones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Functor.mapCoconeOp_inv_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nF : CategoryTheory.Functor J C\nG : CategoryTheory.Functor C D\nt : CategoryTheory.Limits.Cocone F\n‚ä¢ Eq (CategoryTheory.Functor.mapCoconeOp G).inv.hom (CategoryTheory.CategoryStruct.id { unop := G.obj t.pt })","decl":"/-- The opposite cone of the image of a cocone is the image of the opposite cone. -/\n@[simps!]\ndef mapCoconeOp {t : Cocone F} : (mapCocone G t).op ‚âÖ mapCone G.op t.op :=\n  Cones.ext (Iso.refl _)\n\n"}
