{"name":"QuadraticMap.toBilin_apply","module":"Mathlib.LinearAlgebra.QuadraticForm.Basis","initialProofState":"ι : Type u_4\nR : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁵ : LinearOrder ι\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nQ : QuadraticMap R M N\nbm : Basis ι R M\ni j : ι\n⊢ Eq (((Q.toBilin bm) (bm i)) (bm j)) (ite (Eq i j) (Q (bm i)) (ite (LT.lt i j) (QuadraticMap.polar (⇑Q) (bm i) (bm j)) 0))","decl":"theorem toBilin_apply (Q : QuadraticMap R M N) (bm : Basis ι R M) (i j : ι) :\n    Q.toBilin bm (bm i) (bm j) =\n      if i = j then Q (bm i) else if i < j then polar Q (bm i) (bm j) else 0 := by\n  simp [toBilin]\n\n"}
{"name":"QuadraticMap.toQuadraticMap_toBilin","module":"Mathlib.LinearAlgebra.QuadraticForm.Basis","initialProofState":"ι : Type u_4\nR : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁵ : LinearOrder ι\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nQ : QuadraticMap R M N\nbm : Basis ι R M\n⊢ Eq (Q.toBilin bm).toQuadraticMap Q","decl":"theorem toQuadraticMap_toBilin (Q : QuadraticMap R M N) (bm : Basis ι R M) :\n    (Q.toBilin bm).toQuadraticMap = Q := by\n  ext x\n  rw [← bm.linearCombination_repr x, LinearMap.BilinMap.toQuadraticMap_apply,\n      Finsupp.linearCombination_apply, Finsupp.sum]\n  simp_rw [LinearMap.map_sum₂, map_sum, LinearMap.map_smul₂, _root_.map_smul, toBilin_apply,\n    smul_ite, smul_zero, ← Finset.sum_product', ← Finset.diag_union_offDiag,\n    Finset.sum_union (Finset.disjoint_diag_offDiag _), Finset.sum_diag, if_true]\n  rw [Finset.sum_ite_of_false, QuadraticMap.map_sum, ← Finset.sum_filter]\n  · simp_rw [← polar_smul_right _ (bm.repr x <| Prod.snd _),\n      ← polar_smul_left _ (bm.repr x <| Prod.fst _)]\n    simp_rw [QuadraticMap.map_smul, mul_smul, Finset.sum_sym2_filter_not_isDiag]\n    rfl\n  · intro x hx\n    rw [Finset.mem_offDiag] at hx\n    simpa using hx.2.2\n\n"}
{"name":"LinearMap.BilinMap.toQuadraticMap_surjective","module":"Mathlib.LinearAlgebra.QuadraticForm.Basis","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁵ : CommRing R\ninst✝⁴ : AddCommGroup M\ninst✝³ : AddCommGroup N\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module.Free R M\n⊢ Function.Surjective LinearMap.BilinMap.toQuadraticMap","decl":"/-- From a free module, every quadratic map can be built from a bilinear form.\n\nSee `BilinMap.not_forall_toQuadraticMap_surjective` for a counterexample when the module is\nnot free. -/\ntheorem _root_.LinearMap.BilinMap.toQuadraticMap_surjective [Module.Free R M] :\n    Function.Surjective (LinearMap.BilinMap.toQuadraticMap : LinearMap.BilinMap R M N → _) := by\n  intro Q\n  obtain ⟨ι, b⟩ := Module.Free.exists_basis (R := R) (M := M)\n  letI : LinearOrder ι := IsWellOrder.linearOrder WellOrderingRel\n  exact ⟨_, toQuadraticMap_toBilin _ b⟩\n\n"}
{"name":"QuadraticMap.add_toBilin","module":"Mathlib.LinearAlgebra.QuadraticForm.Basis","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁵ : LinearOrder ι\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nbm : Basis ι R M\nQ₁ Q₂ : QuadraticMap R M N\n⊢ Eq ((HAdd.hAdd Q₁ Q₂).toBilin bm) (HAdd.hAdd (Q₁.toBilin bm) (Q₂.toBilin bm))","decl":"@[simp]\nlemma add_toBilin (bm : Basis ι R M) (Q₁ Q₂ : QuadraticMap R M N) :\n    (Q₁ + Q₂).toBilin bm = Q₁.toBilin bm + Q₂.toBilin bm := by\n  refine bm.ext fun i => bm.ext fun j => ?_\n  obtain h | rfl | h := lt_trichotomy i j\n  · simp [h.ne, h, toBilin_apply, polar_add]\n  · simp [toBilin_apply]\n  · simp [h.ne', h.not_lt, toBilin_apply, polar_add]\n\n"}
{"name":"QuadraticMap.smul_toBilin","module":"Mathlib.LinearAlgebra.QuadraticForm.Basis","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁹ : LinearOrder ι\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : AddCommGroup N\ninst✝⁵ : Module R M\ninst✝⁴ : Module R N\nS : Type u_5\ninst✝³ : CommSemiring S\ninst✝² : Algebra S R\ninst✝¹ : Module S N\ninst✝ : IsScalarTower S R N\nbm : Basis ι R M\ns : S\nQ : QuadraticMap R M N\n⊢ Eq ((HSMul.hSMul s Q).toBilin bm) (HSMul.hSMul s (Q.toBilin bm))","decl":"@[simp]\nlemma smul_toBilin (bm : Basis ι R M) (s : S) (Q : QuadraticMap R M N) :\n    (s • Q).toBilin bm = s • Q.toBilin bm := by\n  refine bm.ext fun i => bm.ext fun j => ?_\n  obtain h | rfl | h := lt_trichotomy i j\n  · simp [h.ne, h, toBilin_apply, polar_smul]\n  · simp [toBilin_apply]\n  · simp [h.ne', h.not_lt, toBilin_apply]\n\n"}
{"name":"QuadraticMap.toBilinHom_apply","module":"Mathlib.LinearAlgebra.QuadraticForm.Basis","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁹ : LinearOrder ι\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : AddCommGroup N\ninst✝⁵ : Module R M\ninst✝⁴ : Module R N\nS : Type u_5\ninst✝³ : CommSemiring S\ninst✝² : Algebra S R\ninst✝¹ : Module S N\ninst✝ : IsScalarTower S R N\nbm : Basis ι R M\nQ : QuadraticMap R M N\n⊢ Eq ((QuadraticMap.toBilinHom S bm) Q) (Q.toBilin bm)","decl":"/-- `QuadraticMap.toBilin` as an S-linear map -/\n@[simps]\nnoncomputable def toBilinHom (bm : Basis ι R M) : QuadraticMap R M N →ₗ[S] BilinMap R M N where\n  toFun Q := Q.toBilin bm\n  map_add' := add_toBilin bm\n  map_smul' := smul_toBilin S bm\n\n"}
