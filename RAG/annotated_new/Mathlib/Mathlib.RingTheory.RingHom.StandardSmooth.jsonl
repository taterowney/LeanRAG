{"name":"RingHom.IsStandardSmooth.toAlgebra","module":"Mathlib.RingTheory.RingHom.StandardSmooth","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nf : RingHom R S\nhf : f.IsStandardSmooth\n⊢ Algebra.IsStandardSmooth R S","decl":"/-- Helper lemma for the `algebraize` tactic.-/\nlemma IsStandardSmooth.toAlgebra {f : R →+* S} (hf : IsStandardSmooth.{t, w} f) :\n    @Algebra.IsStandardSmooth.{t, w} R S _ _ f.toAlgebra := hf\n\n"}
{"name":"RingHom.IsStandardSmoothOfRelativeDimension.toAlgebra","module":"Mathlib.RingTheory.RingHom.StandardSmooth","initialProofState":"n : Nat\nR : Type u\nS : Type v\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nf : RingHom R S\nhf : RingHom.IsStandardSmoothOfRelativeDimension n f\n⊢ Algebra.IsStandardSmoothOfRelativeDimension n R S","decl":"/-- Helper lemma for the `algebraize` tactic.-/\nlemma IsStandardSmoothOfRelativeDimension.toAlgebra {f : R →+* S}\n    (hf : IsStandardSmoothOfRelativeDimension.{t, w} n f) :\n    @Algebra.IsStandardSmoothOfRelativeDimension.{t, w} n R S _ _ f.toAlgebra := hf\n\n"}
{"name":"RingHom.IsStandardSmoothOfRelativeDimension.isStandardSmooth","module":"Mathlib.RingTheory.RingHom.StandardSmooth","initialProofState":"n : Nat\nR : Type u\nS : Type v\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nf : RingHom R S\nhf : RingHom.IsStandardSmoothOfRelativeDimension n f\n⊢ f.IsStandardSmooth","decl":"lemma IsStandardSmoothOfRelativeDimension.isStandardSmooth (f : R →+* S)\n    (hf : IsStandardSmoothOfRelativeDimension.{t, w} n f) :\n    IsStandardSmooth.{t, w} f := by\n  algebraize [f]\n  exact Algebra.IsStandardSmoothOfRelativeDimension.isStandardSmooth n\n\n"}
{"name":"RingHom.IsStandardSmoothOfRelativeDimension.id","module":"Mathlib.RingTheory.RingHom.StandardSmooth","initialProofState":"R : Type u\ninst✝ : CommRing R\n⊢ RingHom.IsStandardSmoothOfRelativeDimension 0 (RingHom.id R)","decl":"variable (R) in\nlemma IsStandardSmoothOfRelativeDimension.id :\n    IsStandardSmoothOfRelativeDimension.{t, w} 0 (RingHom.id R) :=\n  Algebra.IsStandardSmoothOfRelativeDimension.id R\n\n"}
{"name":"RingHom.IsStandardSmoothOfRelativeDimension.equiv","module":"Mathlib.RingTheory.RingHom.StandardSmooth","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : CommRing R\ninst✝ : CommRing S\ne : RingEquiv R S\n⊢ RingHom.IsStandardSmoothOfRelativeDimension 0 ↑e","decl":"lemma IsStandardSmoothOfRelativeDimension.equiv (e : R ≃+* S) :\n    IsStandardSmoothOfRelativeDimension.{t, w} 0 (e : R →+* S) := by\n  algebraize [e.toRingHom]\n  exact Algebra.IsStandardSmoothOfRelativeDimension.of_algebraMap_bijective e.bijective\n\n"}
{"name":"RingHom.IsStandardSmooth.comp","module":"Mathlib.RingTheory.RingHom.StandardSmooth","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\nT : Type u_1\ninst✝ : CommRing T\ng : RingHom S T\nf : RingHom R S\nhg : g.IsStandardSmooth\nhf : f.IsStandardSmooth\n⊢ (g.comp f).IsStandardSmooth","decl":"lemma IsStandardSmooth.comp {g : S →+* T} {f : R →+* S}\n    (hg : IsStandardSmooth.{t', w'} g) (hf : IsStandardSmooth.{t, w} f) :\n    IsStandardSmooth.{max t t', max w w'} (g.comp f) := by\n  rw [IsStandardSmooth]\n  algebraize [f, g, (g.comp f)]\n  exact Algebra.IsStandardSmooth.trans.{t, t', w, w'} R S T\n\n"}
{"name":"RingHom.IsStandardSmoothOfRelativeDimension.comp","module":"Mathlib.RingTheory.RingHom.StandardSmooth","initialProofState":"n m : Nat\nR : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\nT : Type u_1\ninst✝ : CommRing T\ng : RingHom S T\nf : RingHom R S\nhg : RingHom.IsStandardSmoothOfRelativeDimension n g\nhf : RingHom.IsStandardSmoothOfRelativeDimension m f\n⊢ RingHom.IsStandardSmoothOfRelativeDimension (HAdd.hAdd n m) (g.comp f)","decl":"lemma IsStandardSmoothOfRelativeDimension.comp {g : S →+* T} {f : R →+* S}\n    (hg : IsStandardSmoothOfRelativeDimension.{t', w'} n g)\n    (hf : IsStandardSmoothOfRelativeDimension.{t, w} m f) :\n    IsStandardSmoothOfRelativeDimension.{max t t', max w w'} (n + m) (g.comp f) := by\n  rw [IsStandardSmoothOfRelativeDimension]\n  algebraize [f, g, (g.comp f)]\n  exact Algebra.IsStandardSmoothOfRelativeDimension.trans m n R S T\n\n"}
{"name":"RingHom.isStandardSmooth_stableUnderComposition","module":"Mathlib.RingTheory.RingHom.StandardSmooth","initialProofState":"⊢ RingHom.StableUnderComposition @RingHom.IsStandardSmooth","decl":"lemma isStandardSmooth_stableUnderComposition :\n    StableUnderComposition @IsStandardSmooth.{t, w} :=\n  fun _ _ _ _ _ _ _ _ hf hg ↦ hg.comp hf\n\n"}
{"name":"RingHom.isStandardSmooth_respectsIso","module":"Mathlib.RingTheory.RingHom.StandardSmooth","initialProofState":"⊢ RingHom.RespectsIso @RingHom.IsStandardSmooth","decl":"lemma isStandardSmooth_respectsIso : RespectsIso @IsStandardSmooth.{t, w} := by\n  apply isStandardSmooth_stableUnderComposition.respectsIso\n  introv\n  exact (IsStandardSmoothOfRelativeDimension.equiv e).isStandardSmooth\n\n"}
{"name":"RingHom.isStandardSmoothOfRelativeDimension_respectsIso","module":"Mathlib.RingTheory.RingHom.StandardSmooth","initialProofState":"n : Nat\n⊢ RingHom.RespectsIso (@RingHom.IsStandardSmoothOfRelativeDimension n)","decl":"lemma isStandardSmoothOfRelativeDimension_respectsIso :\n    RespectsIso (@IsStandardSmoothOfRelativeDimension.{t, w} n) where\n  left {R S T _ _ _} f e hf := by\n    rw [← zero_add n]\n    exact (IsStandardSmoothOfRelativeDimension.equiv e).comp hf\n  right {R S T _ _ _} f e hf := by\n    rw [← add_zero n]\n    exact hf.comp (IsStandardSmoothOfRelativeDimension.equiv e)\n\n"}
{"name":"RingHom.isStandardSmooth_isStableUnderBaseChange","module":"Mathlib.RingTheory.RingHom.StandardSmooth","initialProofState":"⊢ RingHom.IsStableUnderBaseChange @RingHom.IsStandardSmooth","decl":"lemma isStandardSmooth_isStableUnderBaseChange :\n    IsStableUnderBaseChange @IsStandardSmooth.{t, w} := by\n  apply IsStableUnderBaseChange.mk\n  · exact isStandardSmooth_respectsIso\n  · introv h\n    replace h : Algebra.IsStandardSmooth R T := by\n      rw [RingHom.IsStandardSmooth] at h; convert h; ext; simp_rw [Algebra.smul_def]; rfl\n    suffices Algebra.IsStandardSmooth S (S ⊗[R] T) by\n      rw [RingHom.IsStandardSmooth]; convert this; ext; simp_rw [Algebra.smul_def]; rfl\n    infer_instance\n\n"}
{"name":"RingHom.isStandardSmoothOfRelativeDimension_isStableUnderBaseChange","module":"Mathlib.RingTheory.RingHom.StandardSmooth","initialProofState":"n : Nat\n⊢ RingHom.IsStableUnderBaseChange (@RingHom.IsStandardSmoothOfRelativeDimension n)","decl":"lemma isStandardSmoothOfRelativeDimension_isStableUnderBaseChange :\n    IsStableUnderBaseChange (@IsStandardSmoothOfRelativeDimension.{t, w} n) := by\n  apply IsStableUnderBaseChange.mk\n  · exact isStandardSmoothOfRelativeDimension_respectsIso\n  · introv h\n    replace h : Algebra.IsStandardSmoothOfRelativeDimension n R T := by\n      rw [RingHom.IsStandardSmoothOfRelativeDimension] at h\n      convert h; ext; simp_rw [Algebra.smul_def]; rfl\n    suffices Algebra.IsStandardSmoothOfRelativeDimension n S (S ⊗[R] T) by\n      rw [RingHom.IsStandardSmoothOfRelativeDimension]\n      convert this; ext; simp_rw [Algebra.smul_def]; rfl\n    infer_instance\n\n"}
{"name":"RingHom.IsStandardSmoothOfRelativeDimension.algebraMap_isLocalizationAway","module":"Mathlib.RingTheory.RingHom.StandardSmooth","initialProofState":"R : Type u\ninst✝³ : CommRing R\nRᵣ : Type u_2\ninst✝² : CommRing Rᵣ\ninst✝¹ : Algebra R Rᵣ\nr : R\ninst✝ : IsLocalization.Away r Rᵣ\n⊢ RingHom.IsStandardSmoothOfRelativeDimension 0 (algebraMap R Rᵣ)","decl":"lemma IsStandardSmoothOfRelativeDimension.algebraMap_isLocalizationAway {Rᵣ : Type*} [CommRing Rᵣ]\n    [Algebra R Rᵣ] (r : R) [IsLocalization.Away r Rᵣ] :\n    IsStandardSmoothOfRelativeDimension.{0, 0} 0 (algebraMap R Rᵣ) := by\n  have : (algebraMap R Rᵣ).toAlgebra = ‹Algebra R Rᵣ› := by\n    ext\n    rw [Algebra.smul_def]\n    rfl\n  rw [IsStandardSmoothOfRelativeDimension, this]\n  exact Algebra.IsStandardSmoothOfRelativeDimension.localization_away r\n\n"}
{"name":"RingHom.isStandardSmooth_localizationPreserves","module":"Mathlib.RingTheory.RingHom.StandardSmooth","initialProofState":"⊢ RingHom.LocalizationPreserves fun {R S} [CommRing R] [CommRing S] => RingHom.IsStandardSmooth","decl":"lemma isStandardSmooth_localizationPreserves : LocalizationPreserves IsStandardSmooth.{t, w} :=\n  isStandardSmooth_isStableUnderBaseChange.localizationPreserves\n\n"}
{"name":"RingHom.isStandardSmoothOfRelativeDimension_localizationPreserves","module":"Mathlib.RingTheory.RingHom.StandardSmooth","initialProofState":"n : Nat\n⊢ RingHom.LocalizationPreserves fun {R S} [CommRing R] [CommRing S] => RingHom.IsStandardSmoothOfRelativeDimension n","decl":"lemma isStandardSmoothOfRelativeDimension_localizationPreserves :\n    LocalizationPreserves (IsStandardSmoothOfRelativeDimension.{t, w} n) :=\n  (isStandardSmoothOfRelativeDimension_isStableUnderBaseChange n).localizationPreserves\n\n"}
{"name":"RingHom.isStandardSmooth_holdsForLocalizationAway","module":"Mathlib.RingTheory.RingHom.StandardSmooth","initialProofState":"⊢ RingHom.HoldsForLocalizationAway fun {R S} [CommRing R] [CommRing S] => RingHom.IsStandardSmooth","decl":"lemma isStandardSmooth_holdsForLocalizationAway :\n    HoldsForLocalizationAway IsStandardSmooth.{0, 0} := by\n  introv R h\n  exact (IsStandardSmoothOfRelativeDimension.algebraMap_isLocalizationAway r).isStandardSmooth\n\n"}
{"name":"RingHom.isStandardSmoothOfRelativeDimension_holdsForLocalizationAway","module":"Mathlib.RingTheory.RingHom.StandardSmooth","initialProofState":"⊢ RingHom.HoldsForLocalizationAway fun {R S} [CommRing R] [CommRing S] => RingHom.IsStandardSmoothOfRelativeDimension 0","decl":"lemma isStandardSmoothOfRelativeDimension_holdsForLocalizationAway :\n    HoldsForLocalizationAway (IsStandardSmoothOfRelativeDimension.{0, 0} 0) := by\n  introv R h\n  exact IsStandardSmoothOfRelativeDimension.algebraMap_isLocalizationAway r\n\n"}
{"name":"RingHom.isStandardSmooth_stableUnderCompositionWithLocalizationAway","module":"Mathlib.RingTheory.RingHom.StandardSmooth","initialProofState":"⊢ RingHom.StableUnderCompositionWithLocalizationAway fun {R S} [CommRing R] [CommRing S] => RingHom.IsStandardSmooth","decl":"lemma isStandardSmooth_stableUnderCompositionWithLocalizationAway :\n    StableUnderCompositionWithLocalizationAway IsStandardSmooth.{0, 0} :=\n  isStandardSmooth_stableUnderComposition.stableUnderCompositionWithLocalizationAway\n    isStandardSmooth_holdsForLocalizationAway\n\n"}
{"name":"RingHom.isStandardSmoothOfRelativeDimension_stableUnderCompositionWithLocalizationAway","module":"Mathlib.RingTheory.RingHom.StandardSmooth","initialProofState":"n : Nat\n⊢ RingHom.StableUnderCompositionWithLocalizationAway fun {R S} [CommRing R] [CommRing S] => RingHom.IsStandardSmoothOfRelativeDimension n","decl":"lemma isStandardSmoothOfRelativeDimension_stableUnderCompositionWithLocalizationAway :\n    StableUnderCompositionWithLocalizationAway (IsStandardSmoothOfRelativeDimension.{0, 0} n) where\n  left R S _ _ _ _ _ r _ _ hf :=\n    have : (algebraMap R S).IsStandardSmoothOfRelativeDimension 0 :=\n      IsStandardSmoothOfRelativeDimension.algebraMap_isLocalizationAway r\n    add_zero n ▸ IsStandardSmoothOfRelativeDimension.comp hf this\n  right _ S T _ _ _ _ s _ _ hf :=\n    have : (algebraMap S T).IsStandardSmoothOfRelativeDimension 0 :=\n      IsStandardSmoothOfRelativeDimension.algebraMap_isLocalizationAway s\n    zero_add n ▸ IsStandardSmoothOfRelativeDimension.comp this hf\n\n"}
