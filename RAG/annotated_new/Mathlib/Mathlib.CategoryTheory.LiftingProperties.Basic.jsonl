{"name":"CategoryTheory.HasLiftingProperty.sq_hasLift","module":"Mathlib.CategoryTheory.LiftingProperties.Basic","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nA B X Y : C\ni : Quiver.Hom A B\np : Quiver.Hom X Y\nself : CategoryTheory.HasLiftingProperty i p\nf : Quiver.Hom A X\ng : Quiver.Hom B Y\nsq : CategoryTheory.CommSq f i p g\n⊢ sq.HasLift","decl":"/-- `HasLiftingProperty i p` means that `i` has the left lifting\nproperty with respect to `p`, or equivalently that `p` has\nthe right lifting property with respect to `i`. -/\nclass HasLiftingProperty : Prop where\n  /-- Unique field expressing that any commutative square built from `f` and `g` has a lift -/\n  sq_hasLift : ∀ {f : A ⟶ X} {g : B ⟶ Y} (sq : CommSq f i p g), sq.HasLift\n\n"}
{"name":"CategoryTheory.sq_hasLift_of_hasLiftingProperty","module":"Mathlib.CategoryTheory.LiftingProperties.Basic","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nA B X Y : C\ni : Quiver.Hom A B\np : Quiver.Hom X Y\nf : Quiver.Hom A X\ng : Quiver.Hom B Y\nsq : CategoryTheory.CommSq f i p g\nhip : CategoryTheory.HasLiftingProperty i p\n⊢ sq.HasLift","decl":"instance (priority := 100) sq_hasLift_of_hasLiftingProperty {f : A ⟶ X} {g : B ⟶ Y}\n    (sq : CommSq f i p g) [hip : HasLiftingProperty i p] : sq.HasLift := hip.sq_hasLift _\n\n"}
{"name":"CategoryTheory.HasLiftingProperty.op","module":"Mathlib.CategoryTheory.LiftingProperties.Basic","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nA B X Y : C\ni : Quiver.Hom A B\np : Quiver.Hom X Y\nh : CategoryTheory.HasLiftingProperty i p\n⊢ CategoryTheory.HasLiftingProperty p.op i.op","decl":"theorem op (h : HasLiftingProperty i p) : HasLiftingProperty p.op i.op :=\n  ⟨fun {f} {g} sq => by\n    simp only [CommSq.HasLift.iff_unop, Quiver.Hom.unop_op]\n    infer_instance⟩\n\n"}
{"name":"CategoryTheory.HasLiftingProperty.unop","module":"Mathlib.CategoryTheory.LiftingProperties.Basic","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nA B X Y : Opposite C\ni : Quiver.Hom A B\np : Quiver.Hom X Y\nh : CategoryTheory.HasLiftingProperty i p\n⊢ CategoryTheory.HasLiftingProperty p.unop i.unop","decl":"theorem unop {A B X Y : Cᵒᵖ} {i : A ⟶ B} {p : X ⟶ Y} (h : HasLiftingProperty i p) :\n    HasLiftingProperty p.unop i.unop :=\n  ⟨fun {f} {g} sq => by\n    rw [CommSq.HasLift.iff_op]\n    simp only [Quiver.Hom.op_unop]\n    infer_instance⟩\n\n"}
{"name":"CategoryTheory.HasLiftingProperty.iff_op","module":"Mathlib.CategoryTheory.LiftingProperties.Basic","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nA B X Y : C\ni : Quiver.Hom A B\np : Quiver.Hom X Y\n⊢ Iff (CategoryTheory.HasLiftingProperty i p) (CategoryTheory.HasLiftingProperty p.op i.op)","decl":"theorem iff_op : HasLiftingProperty i p ↔ HasLiftingProperty p.op i.op :=\n  ⟨op, unop⟩\n\n"}
{"name":"CategoryTheory.HasLiftingProperty.iff_unop","module":"Mathlib.CategoryTheory.LiftingProperties.Basic","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nA B X Y : Opposite C\ni : Quiver.Hom A B\np : Quiver.Hom X Y\n⊢ Iff (CategoryTheory.HasLiftingProperty i p) (CategoryTheory.HasLiftingProperty p.unop i.unop)","decl":"theorem iff_unop {A B X Y : Cᵒᵖ} (i : A ⟶ B) (p : X ⟶ Y) :\n    HasLiftingProperty i p ↔ HasLiftingProperty p.unop i.unop :=\n  ⟨unop, op⟩\n\n"}
{"name":"CategoryTheory.HasLiftingProperty.of_left_iso","module":"Mathlib.CategoryTheory.LiftingProperties.Basic","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\nA B X Y : C\ni : Quiver.Hom A B\np : Quiver.Hom X Y\ninst✝ : CategoryTheory.IsIso i\n⊢ CategoryTheory.HasLiftingProperty i p","decl":"instance (priority := 100) of_left_iso [IsIso i] : HasLiftingProperty i p :=\n  ⟨fun {f} {g} sq =>\n    CommSq.HasLift.mk'\n      { l := inv i ≫ f\n        fac_left := by simp only [IsIso.hom_inv_id_assoc]\n        fac_right := by simp only [sq.w, assoc, IsIso.inv_hom_id_assoc] }⟩\n\n"}
{"name":"CategoryTheory.HasLiftingProperty.of_right_iso","module":"Mathlib.CategoryTheory.LiftingProperties.Basic","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\nA B X Y : C\ni : Quiver.Hom A B\np : Quiver.Hom X Y\ninst✝ : CategoryTheory.IsIso p\n⊢ CategoryTheory.HasLiftingProperty i p","decl":"instance (priority := 100) of_right_iso [IsIso p] : HasLiftingProperty i p :=\n  ⟨fun {f} {g} sq =>\n    CommSq.HasLift.mk'\n      { l := g ≫ inv p\n        fac_left := by simp only [← sq.w_assoc, IsIso.hom_inv_id, comp_id]\n        fac_right := by simp only [assoc, IsIso.inv_hom_id, comp_id] }⟩\n\n"}
{"name":"CategoryTheory.HasLiftingProperty.of_comp_left","module":"Mathlib.CategoryTheory.LiftingProperties.Basic","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\nA B B' X Y : C\ni : Quiver.Hom A B\ni' : Quiver.Hom B B'\np : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.HasLiftingProperty i p\ninst✝ : CategoryTheory.HasLiftingProperty i' p\n⊢ CategoryTheory.HasLiftingProperty (CategoryTheory.CategoryStruct.comp i i') p","decl":"instance of_comp_left [HasLiftingProperty i p] [HasLiftingProperty i' p] :\n    HasLiftingProperty (i ≫ i') p :=\n  ⟨fun {f} {g} sq => by\n    have fac := sq.w\n    rw [assoc] at fac\n    exact\n      CommSq.HasLift.mk'\n        { l := (CommSq.mk (CommSq.mk fac).fac_right).lift\n          fac_left := by simp only [assoc, CommSq.fac_left]\n          fac_right := by simp only [CommSq.fac_right] }⟩\n\n"}
{"name":"CategoryTheory.HasLiftingProperty.of_comp_right","module":"Mathlib.CategoryTheory.LiftingProperties.Basic","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\nA B X Y Y' : C\ni : Quiver.Hom A B\np : Quiver.Hom X Y\np' : Quiver.Hom Y Y'\ninst✝¹ : CategoryTheory.HasLiftingProperty i p\ninst✝ : CategoryTheory.HasLiftingProperty i p'\n⊢ CategoryTheory.HasLiftingProperty i (CategoryTheory.CategoryStruct.comp p p')","decl":"instance of_comp_right [HasLiftingProperty i p] [HasLiftingProperty i p'] :\n    HasLiftingProperty i (p ≫ p') :=\n  ⟨fun {f} {g} sq => by\n    have fac := sq.w\n    rw [← assoc] at fac\n    let _ := (CommSq.mk (CommSq.mk fac).fac_left.symm).lift\n    exact\n      CommSq.HasLift.mk'\n        { l := (CommSq.mk (CommSq.mk fac).fac_left.symm).lift\n          fac_left := by simp only [CommSq.fac_left]\n          fac_right := by simp only [CommSq.fac_right_assoc, CommSq.fac_right] }⟩\n\n"}
{"name":"CategoryTheory.HasLiftingProperty.of_arrow_iso_left","module":"Mathlib.CategoryTheory.LiftingProperties.Basic","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nA B A' B' X Y : C\ni : Quiver.Hom A B\ni' : Quiver.Hom A' B'\ne : CategoryTheory.Iso (CategoryTheory.Arrow.mk i) (CategoryTheory.Arrow.mk i')\np : Quiver.Hom X Y\nhip : CategoryTheory.HasLiftingProperty i p\n⊢ CategoryTheory.HasLiftingProperty i' p","decl":"theorem of_arrow_iso_left {A B A' B' X Y : C} {i : A ⟶ B} {i' : A' ⟶ B'}\n    (e : Arrow.mk i ≅ Arrow.mk i') (p : X ⟶ Y) [hip : HasLiftingProperty i p] :\n    HasLiftingProperty i' p := by\n  rw [Arrow.iso_w' e]\n  infer_instance\n\n"}
{"name":"CategoryTheory.HasLiftingProperty.of_arrow_iso_right","module":"Mathlib.CategoryTheory.LiftingProperties.Basic","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nA B X Y X' Y' : C\ni : Quiver.Hom A B\np : Quiver.Hom X Y\np' : Quiver.Hom X' Y'\ne : CategoryTheory.Iso (CategoryTheory.Arrow.mk p) (CategoryTheory.Arrow.mk p')\nhip : CategoryTheory.HasLiftingProperty i p\n⊢ CategoryTheory.HasLiftingProperty i p'","decl":"theorem of_arrow_iso_right {A B X Y X' Y' : C} (i : A ⟶ B) {p : X ⟶ Y} {p' : X' ⟶ Y'}\n    (e : Arrow.mk p ≅ Arrow.mk p') [hip : HasLiftingProperty i p] : HasLiftingProperty i p' := by\n  rw [Arrow.iso_w' e]\n  infer_instance\n\n"}
{"name":"CategoryTheory.HasLiftingProperty.iff_of_arrow_iso_left","module":"Mathlib.CategoryTheory.LiftingProperties.Basic","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nA B A' B' X Y : C\ni : Quiver.Hom A B\ni' : Quiver.Hom A' B'\ne : CategoryTheory.Iso (CategoryTheory.Arrow.mk i) (CategoryTheory.Arrow.mk i')\np : Quiver.Hom X Y\n⊢ Iff (CategoryTheory.HasLiftingProperty i p) (CategoryTheory.HasLiftingProperty i' p)","decl":"theorem iff_of_arrow_iso_left {A B A' B' X Y : C} {i : A ⟶ B} {i' : A' ⟶ B'}\n    (e : Arrow.mk i ≅ Arrow.mk i') (p : X ⟶ Y) :\n    HasLiftingProperty i p ↔ HasLiftingProperty i' p := by\n  constructor <;> intro\n  exacts [of_arrow_iso_left e p, of_arrow_iso_left e.symm p]\n\n"}
{"name":"CategoryTheory.HasLiftingProperty.iff_of_arrow_iso_right","module":"Mathlib.CategoryTheory.LiftingProperties.Basic","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nA B X Y X' Y' : C\ni : Quiver.Hom A B\np : Quiver.Hom X Y\np' : Quiver.Hom X' Y'\ne : CategoryTheory.Iso (CategoryTheory.Arrow.mk p) (CategoryTheory.Arrow.mk p')\n⊢ Iff (CategoryTheory.HasLiftingProperty i p) (CategoryTheory.HasLiftingProperty i p')","decl":"theorem iff_of_arrow_iso_right {A B X Y X' Y' : C} (i : A ⟶ B) {p : X ⟶ Y} {p' : X' ⟶ Y'}\n    (e : Arrow.mk p ≅ Arrow.mk p') : HasLiftingProperty i p ↔ HasLiftingProperty i p' := by\n  constructor <;> intro\n  exacts [of_arrow_iso_right i e, of_arrow_iso_right i e.symm]\n\n"}
{"name":"CategoryTheory.RetractArrow.leftLiftingProperty","module":"Mathlib.CategoryTheory.LiftingProperties.Basic","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\nX Y Z W Z' W' : C\ng : Quiver.Hom Z W\ng' : Quiver.Hom Z' W'\nh : CategoryTheory.RetractArrow g' g\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.HasLiftingProperty g f\n⊢ CategoryTheory.HasLiftingProperty g' f","decl":"lemma RetractArrow.leftLiftingProperty\n    {X Y Z W Z' W' : C} {g : Z ⟶ W} {g' : Z' ⟶ W'}\n    (h : RetractArrow g' g) (f : X ⟶ Y) [HasLiftingProperty g f] : HasLiftingProperty g' f where\n  sq_hasLift := fun {u v} sq ↦ by\n    have sq' : CommSq (h.r.left ≫ u) g f (h.r.right ≫ v) := by simp only [Arrow.mk_left,\n      Arrow.mk_right, Category.assoc, sq.w, Arrow.w_mk_right_assoc, Arrow.mk_hom, CommSq.mk]\n    exact\n      ⟨⟨{ l := h.i.right ≫ sq'.lift\n          fac_left := by\n            simp only [← h.i_w_assoc, sq'.fac_left, h.retract_left_assoc,\n              Arrow.mk_left, Category.id_comp]}⟩⟩\n\n"}
{"name":"CategoryTheory.RetractArrow.rightLiftingProperty","module":"Mathlib.CategoryTheory.LiftingProperties.Basic","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\nX Y Z W X' Y' : C\nf : Quiver.Hom X Y\nf' : Quiver.Hom X' Y'\nh : CategoryTheory.RetractArrow f' f\ng : Quiver.Hom Z W\ninst✝ : CategoryTheory.HasLiftingProperty g f\n⊢ CategoryTheory.HasLiftingProperty g f'","decl":"lemma RetractArrow.rightLiftingProperty\n    {X Y Z W X' Y' : C} {f : X ⟶ Y} {f' : X' ⟶ Y'}\n    (h : RetractArrow f' f) (g : Z ⟶ W) [HasLiftingProperty g f] : HasLiftingProperty g f' where\n  sq_hasLift := fun {u v} sq ↦\n    have sq' : CommSq (u ≫ h.i.left) g f (v ≫ h.i.right) :=\n      ⟨by rw [← Category.assoc, ← sq.w, Category.assoc, RetractArrow.i_w, Category.assoc]⟩\n    ⟨⟨{ l := sq'.lift ≫ h.r.left}⟩⟩\n\n"}
