{"name":"CommRingCat.pushoutCocone_inl","module":"Mathlib.Algebra.Category.Ring.Constructions","initialProofState":"R A B : Type u\ninst✝⁴ : CommRing R\ninst✝³ : CommRing A\ninst✝² : CommRing B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\n⊢ Eq (CommRingCat.pushoutCocone R A B).inl (CommRingCat.ofHom Algebra.TensorProduct.includeLeftRingHom)","decl":"@[simp]\ntheorem pushoutCocone_inl :\n    (pushoutCocone R A B).inl = ofHom (Algebra.TensorProduct.includeLeftRingHom (A := A)) :=\n  rfl\n\n"}
{"name":"CommRingCat.pushoutCocone_inr","module":"Mathlib.Algebra.Category.Ring.Constructions","initialProofState":"R A B : Type u\ninst✝⁴ : CommRing R\ninst✝³ : CommRing A\ninst✝² : CommRing B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\n⊢ Eq (CommRingCat.pushoutCocone R A B).inr (CommRingCat.ofHom Algebra.TensorProduct.includeRight.toRingHom)","decl":"@[simp]\ntheorem pushoutCocone_inr :\n    (pushoutCocone R A B).inr = ofHom (Algebra.TensorProduct.includeRight.toRingHom (A := B)) :=\n  rfl\n\n"}
{"name":"CommRingCat.pushoutCocone_pt","module":"Mathlib.Algebra.Category.Ring.Constructions","initialProofState":"R A B : Type u\ninst✝⁴ : CommRing R\ninst✝³ : CommRing A\ninst✝² : CommRing B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\n⊢ Eq (CommRingCat.pushoutCocone R A B).pt (CommRingCat.of (TensorProduct R A B))","decl":"@[simp]\ntheorem pushoutCocone_pt :\n    (pushoutCocone R A B).pt = CommRingCat.of (A ⊗[R] B) :=\n  rfl\n\n"}
{"name":"CommRingCat.isPushout_tensorProduct","module":"Mathlib.Algebra.Category.Ring.Constructions","initialProofState":"R A B : Type u\ninst✝⁴ : CommRing R\ninst✝³ : CommRing A\ninst✝² : CommRing B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\n⊢ CategoryTheory.IsPushout (CommRingCat.ofHom (algebraMap R A)) (CommRingCat.ofHom (algebraMap R B)) (CommRingCat.ofHom Algebra.TensorProduct.includeLeftRingHom) (CommRingCat.ofHom Algebra.TensorProduct.includeRight.toRingHom)","decl":"lemma isPushout_tensorProduct (R A B : Type u) [CommRing R] [CommRing A] [CommRing B]\n    [Algebra R A] [Algebra R B] :\n    IsPushout (ofHom <| algebraMap R A) (ofHom <| algebraMap R B)\n      (ofHom (S := A ⊗[R] B) <| Algebra.TensorProduct.includeLeftRingHom)\n      (ofHom (S := A ⊗[R] B) <| Algebra.TensorProduct.includeRight.toRingHom) where\n  w := by\n    ext\n    simp\n  isColimit' := ⟨pushoutCoconeIsColimit R A B⟩\n\n"}
{"name":"CommRingCat.coproductCocone_ι","module":"Mathlib.Algebra.Category.Ring.Constructions","initialProofState":"A B : CommRingCat\n⊢ Eq (A.coproductCocone B).ι { app := fun x => CategoryTheory.Limits.WalkingPair.swap.match_1 (fun j => Quiver.Hom ((CategoryTheory.Limits.pair A B).obj { as := j }) (CommRingCat.of (TensorProduct Int ↑A ↑B))) x.as (fun _ => CommRingCat.ofHom ↑Algebra.TensorProduct.includeLeft) fun _ => CommRingCat.ofHom ↑Algebra.TensorProduct.includeRight, naturality := ⋯ }","decl":"/-- The tensor product `A ⊗[ℤ] B` forms a cocone for `A` and `B`. -/\n@[simps! pt ι]\ndef coproductCocone : BinaryCofan A B :=\n  BinaryCofan.mk\n    (ofHom (Algebra.TensorProduct.includeLeft (S := ℤ)).toRingHom : A ⟶  of (A ⊗[ℤ] B))\n    (ofHom (Algebra.TensorProduct.includeRight (R := ℤ)).toRingHom : B ⟶  of (A ⊗[ℤ] B))\n\n"}
{"name":"CommRingCat.coproductCocone_pt","module":"Mathlib.Algebra.Category.Ring.Constructions","initialProofState":"A B : CommRingCat\n⊢ Eq (A.coproductCocone B).pt (CommRingCat.of (TensorProduct Int ↑A ↑B))","decl":"/-- The tensor product `A ⊗[ℤ] B` forms a cocone for `A` and `B`. -/\n@[simps! pt ι]\ndef coproductCocone : BinaryCofan A B :=\n  BinaryCofan.mk\n    (ofHom (Algebra.TensorProduct.includeLeft (S := ℤ)).toRingHom : A ⟶  of (A ⊗[ℤ] B))\n    (ofHom (Algebra.TensorProduct.includeRight (R := ℤ)).toRingHom : B ⟶  of (A ⊗[ℤ] B))\n\n"}
{"name":"CommRingCat.coproductCocone_inl","module":"Mathlib.Algebra.Category.Ring.Constructions","initialProofState":"A B : CommRingCat\n⊢ Eq (A.coproductCocone B).inl (CommRingCat.ofHom Algebra.TensorProduct.includeLeft.toRingHom)","decl":"@[simp]\ntheorem coproductCocone_inl : (coproductCocone A B).inl =\n  ofHom (Algebra.TensorProduct.includeLeft (S := ℤ)).toRingHom := rfl\n\n"}
{"name":"CommRingCat.coproductCocone_inr","module":"Mathlib.Algebra.Category.Ring.Constructions","initialProofState":"A B : CommRingCat\n⊢ Eq (A.coproductCocone B).inr (CommRingCat.ofHom Algebra.TensorProduct.includeRight.toRingHom)","decl":"@[simp]\ntheorem coproductCocone_inr : (coproductCocone A B).inr =\n  ofHom (Algebra.TensorProduct.includeRight (R := ℤ)).toRingHom := rfl\n\n"}
{"name":"CommRingCat.coproductCoconeIsColimit_desc","module":"Mathlib.Algebra.Category.Ring.Constructions","initialProofState":"A B : CommRingCat\ns : CategoryTheory.Limits.BinaryCofan A B\n⊢ Eq ((A.coproductCoconeIsColimit B).desc s) (CommRingCat.ofHom (Algebra.TensorProduct.lift (CommRingCat.Hom.hom s.inl).toIntAlgHom (CommRingCat.Hom.hom s.inr).toIntAlgHom ⋯).toRingHom)","decl":"/-- The tensor product `A ⊗[ℤ] B` is a coproduct for `A` and `B`. -/\n@[simps]\ndef coproductCoconeIsColimit : IsColimit (coproductCocone A B) where\n  desc (s : BinaryCofan A B) :=\n    ofHom (Algebra.TensorProduct.lift s.inl.hom.toIntAlgHom s.inr.hom.toIntAlgHom\n      (fun _ _ => by apply Commute.all)).toRingHom\n  fac (s : BinaryCofan A B) := fun ⟨j⟩ => by cases j <;> ext a <;> simp\n  uniq (s : BinaryCofan A B) := by\n    rintro ⟨m : A ⊗[ℤ] B →+* s.pt⟩ hm\n    apply CommRingCat.hom_ext\n    apply RingHom.toIntAlgHom_injective\n    apply Algebra.TensorProduct.liftEquiv.symm.injective\n    apply Subtype.ext\n    rw [Algebra.TensorProduct.liftEquiv_symm_apply_coe, Prod.mk.injEq]\n    constructor\n    · ext a\n      simp [map_one, mul_one, ←hm (Discrete.mk WalkingPair.left)]\n    · ext b\n      simp [map_one, mul_one, ←hm (Discrete.mk WalkingPair.right)]\n\n"}
{"name":"CommRingCat.commRingCat_hasStrictTerminalObjects","module":"Mathlib.Algebra.Category.Ring.Constructions","initialProofState":"⊢ CategoryTheory.Limits.HasStrictTerminalObjects CommRingCat","decl":"instance commRingCat_hasStrictTerminalObjects : HasStrictTerminalObjects CommRingCat.{u} := by\n  apply hasStrictTerminalObjects_of_terminal_is_strict (CommRingCat.of PUnit)\n  intro X f\n  refine ⟨ofHom ⟨1, rfl, by simp⟩, ?_, ?_⟩\n  · ext\n  · ext x\n    have e : (0 : X) = 1 := by\n      rw [← f.hom.map_one, ← f.hom.map_zero]\n    replace e : 0 * x = 1 * x := congr_arg (· * x) e\n    rw [one_mul, zero_mul, ← f.hom.map_zero] at e\n    exact e\n\n"}
{"name":"CommRingCat.subsingleton_of_isTerminal","module":"Mathlib.Algebra.Category.Ring.Constructions","initialProofState":"X : CommRingCat\nhX : CategoryTheory.Limits.IsTerminal X\n⊢ Subsingleton ↑X","decl":"theorem subsingleton_of_isTerminal {X : CommRingCat} (hX : IsTerminal X) : Subsingleton X :=\n  (hX.uniqueUpToIso punitIsTerminal).commRingCatIsoToRingEquiv.toEquiv.subsingleton_congr.mpr\n    (show Subsingleton PUnit by infer_instance)\n\n"}
{"name":"CommRingCat.prodFan_pt","module":"Mathlib.Algebra.Category.Ring.Constructions","initialProofState":"A B : CommRingCat\n⊢ Eq (A.prodFan B).pt (CommRingCat.of (Prod ↑A ↑B))","decl":"/-- The product in `CommRingCat` is the cartesian product. This is the binary fan. -/\n@[simps! pt]\ndef prodFan : BinaryFan A B :=\n  BinaryFan.mk (CommRingCat.ofHom <| RingHom.fst A B) (CommRingCat.ofHom <| RingHom.snd A B)\n\n"}
{"name":"CommRingCat.piFan_pt","module":"Mathlib.Algebra.Category.Ring.Constructions","initialProofState":"ι : Type u\nR : ι → CommRingCat\n⊢ Eq (CommRingCat.piFan R).pt (CommRingCat.of ((i : ι) → ↑(R i)))","decl":"/--\nThe categorical product of rings is the cartesian product of rings. This is its `Fan`.\n-/\n@[simps! pt]\ndef piFan : Fan R :=\n  Fan.mk (CommRingCat.of ((i : ι) → R i)) (fun i ↦ ofHom <| Pi.evalRingHom _ i)\n\n"}
{"name":"CommRingCat.instIsLocalHomCarrierObjWalkingParallelPairFunctorConstPtEqualizerForkZeroParallelPairRingHomHomι","module":"Mathlib.Algebra.Category.Ring.Constructions","initialProofState":"A B : CommRingCat\nf g : Quiver.Hom A B\n⊢ IsLocalHom (CommRingCat.Hom.hom (CommRingCat.equalizerFork f g).ι)","decl":"instance : IsLocalHom (equalizerFork f g).ι.hom := by\n  constructor\n  rintro ⟨a, h₁ : _ = _⟩ (⟨⟨x, y, h₃, h₄⟩, rfl : x = _⟩ : IsUnit a)\n  have : y ∈ RingHom.eqLocus f.hom g.hom := by\n    apply (f.hom.isUnit_map ⟨⟨x, y, h₃, h₄⟩, rfl⟩ : IsUnit (f x)).mul_left_inj.mp\n    conv_rhs => rw [h₁]\n    rw [← f.hom.map_mul, ← g.hom.map_mul, h₄, f.hom.map_one, g.hom.map_one]\n  rw [isUnit_iff_exists_inv]\n  exact ⟨⟨y, this⟩, Subtype.eq h₃⟩\n\n"}
{"name":"CommRingCat.equalizer_ι_isLocalHom","module":"Mathlib.Algebra.Category.Ring.Constructions","initialProofState":"F : CategoryTheory.Functor CategoryTheory.Limits.WalkingParallelPair CommRingCat\n⊢ IsLocalHom (CommRingCat.Hom.hom (CategoryTheory.Limits.limit.π F CategoryTheory.Limits.WalkingParallelPair.zero))","decl":"@[instance]\ntheorem equalizer_ι_isLocalHom (F : WalkingParallelPair ⥤ CommRingCat.{u}) :\n    IsLocalHom (limit.π F WalkingParallelPair.zero).hom := by\n  have := limMap_π (diagramIsoParallelPair F).hom WalkingParallelPair.zero\n  rw [← IsIso.comp_inv_eq] at this\n  rw [← this]\n  rw [← limit.isoLimitCone_hom_π\n      ⟨_,\n        equalizerForkIsLimit (F.map WalkingParallelPairHom.left)\n          (F.map WalkingParallelPairHom.right)⟩\n      WalkingParallelPair.zero]\n  change IsLocalHom ((lim.map _ ≫ _ ≫ (equalizerFork _ _).ι) ≫ _).hom\n  infer_instance\n\n"}
{"name":"CommRingCat.equalizer_ι_isLocalRingHom","module":"Mathlib.Algebra.Category.Ring.Constructions","initialProofState":"F : CategoryTheory.Functor CategoryTheory.Limits.WalkingParallelPair CommRingCat\n⊢ IsLocalHom (CommRingCat.Hom.hom (CategoryTheory.Limits.limit.π F CategoryTheory.Limits.WalkingParallelPair.zero))","decl":"@[deprecated (since := \"2024-10-10\")]\nalias equalizer_ι_isLocalRingHom := equalizer_ι_isLocalHom\n\n"}
{"name":"CommRingCat.equalizer_ι_is_local_ring_hom'","module":"Mathlib.Algebra.Category.Ring.Constructions","initialProofState":"F : CategoryTheory.Functor (Opposite CategoryTheory.Limits.WalkingParallelPair) CommRingCat\n⊢ IsLocalHom (CommRingCat.Hom.hom (CategoryTheory.Limits.limit.π F { unop := CategoryTheory.Limits.WalkingParallelPair.one }))","decl":"instance equalizer_ι_is_local_ring_hom' (F : WalkingParallelPairᵒᵖ ⥤ CommRingCat.{u}) :\n    IsLocalHom (limit.π F (Opposite.op WalkingParallelPair.one)).hom := by\n  have : _ = limit.π F (walkingParallelPairOpEquiv.functor.obj _) :=\n    (limit.isoLimitCone_inv_π\n        ⟨_, IsLimit.whiskerEquivalence (limit.isLimit F) walkingParallelPairOpEquiv⟩\n        WalkingParallelPair.zero :)\n  erw [← this]\n  -- note: this was not needed before https://github.com/leanprover-community/mathlib4/pull/19757\n  haveI : IsLocalHom (limit.π (walkingParallelPairOpEquiv.functor ⋙ F) zero).hom := by\n    infer_instance\n  infer_instance\n\n"}
