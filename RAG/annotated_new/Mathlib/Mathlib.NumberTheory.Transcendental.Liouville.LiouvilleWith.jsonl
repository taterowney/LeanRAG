{"name":"liouvilleWith_one","module":"Mathlib.NumberTheory.Transcendental.Liouville.LiouvilleWith","initialProofState":"x : Real\n⊢ LiouvilleWith 1 x","decl":"/-- For `p = 1` (hence, for any `p ≤ 1`), the condition `LiouvilleWith p x` is trivial. -/\ntheorem liouvilleWith_one (x : ℝ) : LiouvilleWith 1 x := by\n  use 2\n  refine ((eventually_gt_atTop 0).mono fun n hn => ?_).frequently\n  have hn' : (0 : ℝ) < n := by simpa\n  have : x < ↑(⌊x * ↑n⌋ + 1) / ↑n := by\n    rw [lt_div_iff₀ hn', Int.cast_add, Int.cast_one]\n    exact Int.lt_floor_add_one _\n  refine ⟨⌊x * n⌋ + 1, this.ne, ?_⟩\n  rw [abs_sub_comm, abs_of_pos (sub_pos.2 this), rpow_one, sub_lt_iff_lt_add',\n    add_div_eq_mul_add_div _ _ hn'.ne']\n  gcongr\n  calc _ ≤ x * n + 1 := by push_cast; gcongr; apply Int.floor_le\n    _ < x * n + 2 := by linarith\n\n"}
{"name":"LiouvilleWith.exists_pos","module":"Mathlib.NumberTheory.Transcendental.Liouville.LiouvilleWith","initialProofState":"p x : Real\nh : LiouvilleWith p x\n⊢ Exists fun C => Exists fun _h₀ => Filter.Frequently (fun n => And (LE.le 1 n) (Exists fun m => And (Ne x (HDiv.hDiv ↑m ↑n)) (LT.lt (abs (HSub.hSub x (HDiv.hDiv ↑m ↑n))) (HDiv.hDiv C (HPow.hPow (↑n) p))))) Filter.atTop","decl":"/-- The constant `C` provided by the definition of `LiouvilleWith` can be made positive.\nWe also add `1 ≤ n` to the list of assumptions about the denominator. While it is equivalent to\nthe original statement, the case `n = 0` breaks many arguments. -/\ntheorem exists_pos (h : LiouvilleWith p x) :\n    ∃ (C : ℝ) (_h₀ : 0 < C),\n      ∃ᶠ n : ℕ in atTop, 1 ≤ n ∧ ∃ m : ℤ, x ≠ m / n ∧ |x - m / n| < C / n ^ p := by\n  rcases h with ⟨C, hC⟩\n  refine ⟨max C 1, zero_lt_one.trans_le <| le_max_right _ _, ?_⟩\n  refine ((eventually_ge_atTop 1).and_frequently hC).mono ?_\n  rintro n ⟨hle, m, hne, hlt⟩\n  refine ⟨hle, m, hne, hlt.trans_le ?_⟩\n  gcongr\n  apply le_max_left\n\n"}
{"name":"LiouvilleWith.mono","module":"Mathlib.NumberTheory.Transcendental.Liouville.LiouvilleWith","initialProofState":"p q x : Real\nh : LiouvilleWith p x\nhle : LE.le q p\n⊢ LiouvilleWith q x","decl":"/-- If a number is Liouville with exponent `p`, then it is Liouville with any smaller exponent. -/\ntheorem mono (h : LiouvilleWith p x) (hle : q ≤ p) : LiouvilleWith q x := by\n  rcases h.exists_pos with ⟨C, hC₀, hC⟩\n  refine ⟨C, hC.mono ?_⟩; rintro n ⟨hn, m, hne, hlt⟩\n  refine ⟨m, hne, hlt.trans_le <| ?_⟩\n  gcongr\n  exact_mod_cast hn\n\n"}
{"name":"LiouvilleWith.frequently_lt_rpow_neg","module":"Mathlib.NumberTheory.Transcendental.Liouville.LiouvilleWith","initialProofState":"p q x : Real\nh : LiouvilleWith p x\nhlt : LT.lt q p\n⊢ Filter.Frequently (fun n => Exists fun m => And (Ne x (HDiv.hDiv ↑m ↑n)) (LT.lt (abs (HSub.hSub x (HDiv.hDiv ↑m ↑n))) (HPow.hPow (↑n) (Neg.neg q)))) Filter.atTop","decl":"/-- If `x` satisfies Liouville condition with exponent `p` and `q < p`, then `x`\nsatisfies Liouville condition with exponent `q` and constant `1`. -/\ntheorem frequently_lt_rpow_neg (h : LiouvilleWith p x) (hlt : q < p) :\n    ∃ᶠ n : ℕ in atTop, ∃ m : ℤ, x ≠ m / n ∧ |x - m / n| < n ^ (-q) := by\n  rcases h.exists_pos with ⟨C, _hC₀, hC⟩\n  have : ∀ᶠ n : ℕ in atTop, C < n ^ (p - q) := by\n    simpa only [(· ∘ ·), neg_sub, one_div] using\n      ((tendsto_rpow_atTop (sub_pos.2 hlt)).comp tendsto_natCast_atTop_atTop).eventually\n        (eventually_gt_atTop C)\n  refine (this.and_frequently hC).mono ?_\n  rintro n ⟨hnC, hn, m, hne, hlt⟩\n  replace hn : (0 : ℝ) < n := Nat.cast_pos.2 hn\n  refine ⟨m, hne, hlt.trans <| (div_lt_iff₀ <| rpow_pos_of_pos hn _).2 ?_⟩\n  rwa [mul_comm, ← rpow_add hn, ← sub_eq_add_neg]\n\n"}
{"name":"LiouvilleWith.mul_rat","module":"Mathlib.NumberTheory.Transcendental.Liouville.LiouvilleWith","initialProofState":"p x : Real\nr : Rat\nh : LiouvilleWith p x\nhr : Ne r 0\n⊢ LiouvilleWith p (HMul.hMul x ↑r)","decl":"/-- The product of a Liouville number and a nonzero rational number is again a Liouville number. -/\ntheorem mul_rat (h : LiouvilleWith p x) (hr : r ≠ 0) : LiouvilleWith p (x * r) := by\n  rcases h.exists_pos with ⟨C, _hC₀, hC⟩\n  refine ⟨r.den ^ p * (|r| * C), (tendsto_id.nsmul_atTop r.pos).frequently (hC.mono ?_)⟩\n  rintro n ⟨_hn, m, hne, hlt⟩\n  have A : (↑(r.num * m) : ℝ) / ↑(r.den • id n) = m / n * r := by\n    simp [← div_mul_div_comm, ← r.cast_def, mul_comm]\n  refine ⟨r.num * m, ?_, ?_⟩\n  · rw [A]; simp [hne, hr]\n  · rw [A, ← sub_mul, abs_mul]\n    simp only [smul_eq_mul, id, Nat.cast_mul]\n    calc _ < C / ↑n ^ p * |↑r| := by gcongr\n      _ = ↑r.den ^ p * (↑|r| * C) / (↑r.den * ↑n) ^ p := ?_\n    rw [mul_rpow, mul_div_mul_left, mul_comm, mul_div_assoc]\n    · simp only [Rat.cast_abs, le_refl]\n    all_goals positivity\n\n"}
{"name":"LiouvilleWith.mul_rat_iff","module":"Mathlib.NumberTheory.Transcendental.Liouville.LiouvilleWith","initialProofState":"p x : Real\nr : Rat\nhr : Ne r 0\n⊢ Iff (LiouvilleWith p (HMul.hMul x ↑r)) (LiouvilleWith p x)","decl":"/-- The product `x * r`, `r : ℚ`, `r ≠ 0`, is a Liouville number with exponent `p` if and only if\n`x` satisfies the same condition. -/\ntheorem mul_rat_iff (hr : r ≠ 0) : LiouvilleWith p (x * r) ↔ LiouvilleWith p x :=\n  ⟨fun h => by\n    simpa only [mul_assoc, ← Rat.cast_mul, mul_inv_cancel₀ hr, Rat.cast_one, mul_one] using\n      h.mul_rat (inv_ne_zero hr),\n    fun h => h.mul_rat hr⟩\n\n"}
{"name":"LiouvilleWith.rat_mul_iff","module":"Mathlib.NumberTheory.Transcendental.Liouville.LiouvilleWith","initialProofState":"p x : Real\nr : Rat\nhr : Ne r 0\n⊢ Iff (LiouvilleWith p (HMul.hMul (↑r) x)) (LiouvilleWith p x)","decl":"/-- The product `r * x`, `r : ℚ`, `r ≠ 0`, is a Liouville number with exponent `p` if and only if\n`x` satisfies the same condition. -/\ntheorem rat_mul_iff (hr : r ≠ 0) : LiouvilleWith p (r * x) ↔ LiouvilleWith p x := by\n  rw [mul_comm, mul_rat_iff hr]\n\n"}
{"name":"LiouvilleWith.rat_mul","module":"Mathlib.NumberTheory.Transcendental.Liouville.LiouvilleWith","initialProofState":"p x : Real\nr : Rat\nh : LiouvilleWith p x\nhr : Ne r 0\n⊢ LiouvilleWith p (HMul.hMul (↑r) x)","decl":"theorem rat_mul (h : LiouvilleWith p x) (hr : r ≠ 0) : LiouvilleWith p (r * x) :=\n  (rat_mul_iff hr).2 h\n\n"}
{"name":"LiouvilleWith.mul_int_iff","module":"Mathlib.NumberTheory.Transcendental.Liouville.LiouvilleWith","initialProofState":"p x : Real\nm : Int\nhm : Ne m 0\n⊢ Iff (LiouvilleWith p (HMul.hMul x ↑m)) (LiouvilleWith p x)","decl":"theorem mul_int_iff (hm : m ≠ 0) : LiouvilleWith p (x * m) ↔ LiouvilleWith p x := by\n  rw [← Rat.cast_intCast, mul_rat_iff (Int.cast_ne_zero.2 hm)]\n\n"}
{"name":"LiouvilleWith.mul_int","module":"Mathlib.NumberTheory.Transcendental.Liouville.LiouvilleWith","initialProofState":"p x : Real\nm : Int\nh : LiouvilleWith p x\nhm : Ne m 0\n⊢ LiouvilleWith p (HMul.hMul x ↑m)","decl":"theorem mul_int (h : LiouvilleWith p x) (hm : m ≠ 0) : LiouvilleWith p (x * m) :=\n  (mul_int_iff hm).2 h\n\n"}
{"name":"LiouvilleWith.int_mul_iff","module":"Mathlib.NumberTheory.Transcendental.Liouville.LiouvilleWith","initialProofState":"p x : Real\nm : Int\nhm : Ne m 0\n⊢ Iff (LiouvilleWith p (HMul.hMul (↑m) x)) (LiouvilleWith p x)","decl":"theorem int_mul_iff (hm : m ≠ 0) : LiouvilleWith p (m * x) ↔ LiouvilleWith p x := by\n  rw [mul_comm, mul_int_iff hm]\n\n"}
{"name":"LiouvilleWith.int_mul","module":"Mathlib.NumberTheory.Transcendental.Liouville.LiouvilleWith","initialProofState":"p x : Real\nm : Int\nh : LiouvilleWith p x\nhm : Ne m 0\n⊢ LiouvilleWith p (HMul.hMul (↑m) x)","decl":"theorem int_mul (h : LiouvilleWith p x) (hm : m ≠ 0) : LiouvilleWith p (m * x) :=\n  (int_mul_iff hm).2 h\n\n"}
{"name":"LiouvilleWith.mul_nat_iff","module":"Mathlib.NumberTheory.Transcendental.Liouville.LiouvilleWith","initialProofState":"p x : Real\nn : Nat\nhn : Ne n 0\n⊢ Iff (LiouvilleWith p (HMul.hMul x ↑n)) (LiouvilleWith p x)","decl":"theorem mul_nat_iff (hn : n ≠ 0) : LiouvilleWith p (x * n) ↔ LiouvilleWith p x := by\n  rw [← Rat.cast_natCast, mul_rat_iff (Nat.cast_ne_zero.2 hn)]\n\n"}
{"name":"LiouvilleWith.mul_nat","module":"Mathlib.NumberTheory.Transcendental.Liouville.LiouvilleWith","initialProofState":"p x : Real\nn : Nat\nh : LiouvilleWith p x\nhn : Ne n 0\n⊢ LiouvilleWith p (HMul.hMul x ↑n)","decl":"theorem mul_nat (h : LiouvilleWith p x) (hn : n ≠ 0) : LiouvilleWith p (x * n) :=\n  (mul_nat_iff hn).2 h\n\n"}
{"name":"LiouvilleWith.nat_mul_iff","module":"Mathlib.NumberTheory.Transcendental.Liouville.LiouvilleWith","initialProofState":"p x : Real\nn : Nat\nhn : Ne n 0\n⊢ Iff (LiouvilleWith p (HMul.hMul (↑n) x)) (LiouvilleWith p x)","decl":"theorem nat_mul_iff (hn : n ≠ 0) : LiouvilleWith p (n * x) ↔ LiouvilleWith p x := by\n  rw [mul_comm, mul_nat_iff hn]\n\n"}
{"name":"LiouvilleWith.nat_mul","module":"Mathlib.NumberTheory.Transcendental.Liouville.LiouvilleWith","initialProofState":"p x : Real\nn : Nat\nh : LiouvilleWith p x\nhn : Ne n 0\n⊢ LiouvilleWith p (HMul.hMul (↑n) x)","decl":"theorem nat_mul (h : LiouvilleWith p x) (hn : n ≠ 0) : LiouvilleWith p (n * x) := by\n  rw [mul_comm]; exact h.mul_nat hn\n\n"}
{"name":"LiouvilleWith.add_rat","module":"Mathlib.NumberTheory.Transcendental.Liouville.LiouvilleWith","initialProofState":"p x : Real\nh : LiouvilleWith p x\nr : Rat\n⊢ LiouvilleWith p (HAdd.hAdd x ↑r)","decl":"theorem add_rat (h : LiouvilleWith p x) (r : ℚ) : LiouvilleWith p (x + r) := by\n  rcases h.exists_pos with ⟨C, _hC₀, hC⟩\n  refine ⟨r.den ^ p * C, (tendsto_id.nsmul_atTop r.pos).frequently (hC.mono ?_)⟩\n  rintro n ⟨hn, m, hne, hlt⟩\n  have : (↑(r.den * m + r.num * n : ℤ) / ↑(r.den • id n) : ℝ) = m / n + r := by\n    rw [Algebra.id.smul_eq_mul, id]\n    nth_rewrite 4 [← Rat.num_div_den r]\n    push_cast\n    rw [add_div, mul_div_mul_left _ _ (by positivity), mul_div_mul_right _ _ (by positivity)]\n  refine ⟨r.den * m + r.num * n, ?_⟩; rw [this, add_sub_add_right_eq_sub]\n  refine ⟨by simpa, hlt.trans_le (le_of_eq ?_)⟩\n  have : (r.den ^ p : ℝ) ≠ 0 := by positivity\n  simp [mul_rpow, Nat.cast_nonneg, mul_div_mul_left, this]\n\n"}
{"name":"LiouvilleWith.add_rat_iff","module":"Mathlib.NumberTheory.Transcendental.Liouville.LiouvilleWith","initialProofState":"p x : Real\nr : Rat\n⊢ Iff (LiouvilleWith p (HAdd.hAdd x ↑r)) (LiouvilleWith p x)","decl":"@[simp]\ntheorem add_rat_iff : LiouvilleWith p (x + r) ↔ LiouvilleWith p x :=\n  ⟨fun h => by simpa using h.add_rat (-r), fun h => h.add_rat r⟩\n\n"}
{"name":"LiouvilleWith.rat_add_iff","module":"Mathlib.NumberTheory.Transcendental.Liouville.LiouvilleWith","initialProofState":"p x : Real\nr : Rat\n⊢ Iff (LiouvilleWith p (HAdd.hAdd (↑r) x)) (LiouvilleWith p x)","decl":"@[simp]\ntheorem rat_add_iff : LiouvilleWith p (r + x) ↔ LiouvilleWith p x := by rw [add_comm, add_rat_iff]\n\n"}
{"name":"LiouvilleWith.rat_add","module":"Mathlib.NumberTheory.Transcendental.Liouville.LiouvilleWith","initialProofState":"p x : Real\nh : LiouvilleWith p x\nr : Rat\n⊢ LiouvilleWith p (HAdd.hAdd (↑r) x)","decl":"theorem rat_add (h : LiouvilleWith p x) (r : ℚ) : LiouvilleWith p (r + x) :=\n  add_comm x r ▸ h.add_rat r\n\n"}
{"name":"LiouvilleWith.add_int_iff","module":"Mathlib.NumberTheory.Transcendental.Liouville.LiouvilleWith","initialProofState":"p x : Real\nm : Int\n⊢ Iff (LiouvilleWith p (HAdd.hAdd x ↑m)) (LiouvilleWith p x)","decl":"@[simp]\ntheorem add_int_iff : LiouvilleWith p (x + m) ↔ LiouvilleWith p x := by\n  rw [← Rat.cast_intCast m, add_rat_iff]\n\n"}
{"name":"LiouvilleWith.int_add_iff","module":"Mathlib.NumberTheory.Transcendental.Liouville.LiouvilleWith","initialProofState":"p x : Real\nm : Int\n⊢ Iff (LiouvilleWith p (HAdd.hAdd (↑m) x)) (LiouvilleWith p x)","decl":"@[simp]\ntheorem int_add_iff : LiouvilleWith p (m + x) ↔ LiouvilleWith p x := by rw [add_comm, add_int_iff]\n\n"}
{"name":"LiouvilleWith.add_nat_iff","module":"Mathlib.NumberTheory.Transcendental.Liouville.LiouvilleWith","initialProofState":"p x : Real\nn : Nat\n⊢ Iff (LiouvilleWith p (HAdd.hAdd x ↑n)) (LiouvilleWith p x)","decl":"@[simp]\ntheorem add_nat_iff : LiouvilleWith p (x + n) ↔ LiouvilleWith p x := by\n  rw [← Rat.cast_natCast n, add_rat_iff]\n\n"}
{"name":"LiouvilleWith.nat_add_iff","module":"Mathlib.NumberTheory.Transcendental.Liouville.LiouvilleWith","initialProofState":"p x : Real\nn : Nat\n⊢ Iff (LiouvilleWith p (HAdd.hAdd (↑n) x)) (LiouvilleWith p x)","decl":"@[simp]\ntheorem nat_add_iff : LiouvilleWith p (n + x) ↔ LiouvilleWith p x := by rw [add_comm, add_nat_iff]\n\n"}
{"name":"LiouvilleWith.add_int","module":"Mathlib.NumberTheory.Transcendental.Liouville.LiouvilleWith","initialProofState":"p x : Real\nh : LiouvilleWith p x\nm : Int\n⊢ LiouvilleWith p (HAdd.hAdd x ↑m)","decl":"theorem add_int (h : LiouvilleWith p x) (m : ℤ) : LiouvilleWith p (x + m) :=\n  add_int_iff.2 h\n\n"}
{"name":"LiouvilleWith.int_add","module":"Mathlib.NumberTheory.Transcendental.Liouville.LiouvilleWith","initialProofState":"p x : Real\nh : LiouvilleWith p x\nm : Int\n⊢ LiouvilleWith p (HAdd.hAdd (↑m) x)","decl":"theorem int_add (h : LiouvilleWith p x) (m : ℤ) : LiouvilleWith p (m + x) :=\n  int_add_iff.2 h\n\n"}
{"name":"LiouvilleWith.add_nat","module":"Mathlib.NumberTheory.Transcendental.Liouville.LiouvilleWith","initialProofState":"p x : Real\nh : LiouvilleWith p x\nn : Nat\n⊢ LiouvilleWith p (HAdd.hAdd x ↑n)","decl":"theorem add_nat (h : LiouvilleWith p x) (n : ℕ) : LiouvilleWith p (x + n) :=\n  h.add_int n\n\n"}
{"name":"LiouvilleWith.nat_add","module":"Mathlib.NumberTheory.Transcendental.Liouville.LiouvilleWith","initialProofState":"p x : Real\nh : LiouvilleWith p x\nn : Nat\n⊢ LiouvilleWith p (HAdd.hAdd (↑n) x)","decl":"theorem nat_add (h : LiouvilleWith p x) (n : ℕ) : LiouvilleWith p (n + x) :=\n  h.int_add n\n\n"}
{"name":"LiouvilleWith.neg","module":"Mathlib.NumberTheory.Transcendental.Liouville.LiouvilleWith","initialProofState":"p x : Real\nh : LiouvilleWith p x\n⊢ LiouvilleWith p (Neg.neg x)","decl":"protected theorem neg (h : LiouvilleWith p x) : LiouvilleWith p (-x) := by\n  rcases h with ⟨C, hC⟩\n  refine ⟨C, hC.mono ?_⟩\n  rintro n ⟨m, hne, hlt⟩\n  refine ⟨-m, by simp [neg_div, hne], ?_⟩\n  convert hlt using 1\n  rw [abs_sub_comm]\n  congr! 1; push_cast; ring\n\n"}
{"name":"LiouvilleWith.neg_iff","module":"Mathlib.NumberTheory.Transcendental.Liouville.LiouvilleWith","initialProofState":"p x : Real\n⊢ Iff (LiouvilleWith p (Neg.neg x)) (LiouvilleWith p x)","decl":"@[simp]\ntheorem neg_iff : LiouvilleWith p (-x) ↔ LiouvilleWith p x :=\n  ⟨fun h => neg_neg x ▸ h.neg, LiouvilleWith.neg⟩\n\n"}
{"name":"LiouvilleWith.sub_rat_iff","module":"Mathlib.NumberTheory.Transcendental.Liouville.LiouvilleWith","initialProofState":"p x : Real\nr : Rat\n⊢ Iff (LiouvilleWith p (HSub.hSub x ↑r)) (LiouvilleWith p x)","decl":"@[simp]\ntheorem sub_rat_iff : LiouvilleWith p (x - r) ↔ LiouvilleWith p x := by\n  rw [sub_eq_add_neg, ← Rat.cast_neg, add_rat_iff]\n\n"}
{"name":"LiouvilleWith.sub_rat","module":"Mathlib.NumberTheory.Transcendental.Liouville.LiouvilleWith","initialProofState":"p x : Real\nh : LiouvilleWith p x\nr : Rat\n⊢ LiouvilleWith p (HSub.hSub x ↑r)","decl":"theorem sub_rat (h : LiouvilleWith p x) (r : ℚ) : LiouvilleWith p (x - r) :=\n  sub_rat_iff.2 h\n\n"}
{"name":"LiouvilleWith.sub_int_iff","module":"Mathlib.NumberTheory.Transcendental.Liouville.LiouvilleWith","initialProofState":"p x : Real\nm : Int\n⊢ Iff (LiouvilleWith p (HSub.hSub x ↑m)) (LiouvilleWith p x)","decl":"@[simp]\ntheorem sub_int_iff : LiouvilleWith p (x - m) ↔ LiouvilleWith p x := by\n  rw [← Rat.cast_intCast, sub_rat_iff]\n\n"}
{"name":"LiouvilleWith.sub_int","module":"Mathlib.NumberTheory.Transcendental.Liouville.LiouvilleWith","initialProofState":"p x : Real\nh : LiouvilleWith p x\nm : Int\n⊢ LiouvilleWith p (HSub.hSub x ↑m)","decl":"theorem sub_int (h : LiouvilleWith p x) (m : ℤ) : LiouvilleWith p (x - m) :=\n  sub_int_iff.2 h\n\n"}
{"name":"LiouvilleWith.sub_nat_iff","module":"Mathlib.NumberTheory.Transcendental.Liouville.LiouvilleWith","initialProofState":"p x : Real\nn : Nat\n⊢ Iff (LiouvilleWith p (HSub.hSub x ↑n)) (LiouvilleWith p x)","decl":"@[simp]\ntheorem sub_nat_iff : LiouvilleWith p (x - n) ↔ LiouvilleWith p x := by\n  rw [← Rat.cast_natCast, sub_rat_iff]\n\n"}
{"name":"LiouvilleWith.sub_nat","module":"Mathlib.NumberTheory.Transcendental.Liouville.LiouvilleWith","initialProofState":"p x : Real\nh : LiouvilleWith p x\nn : Nat\n⊢ LiouvilleWith p (HSub.hSub x ↑n)","decl":"theorem sub_nat (h : LiouvilleWith p x) (n : ℕ) : LiouvilleWith p (x - n) :=\n  sub_nat_iff.2 h\n\n"}
{"name":"LiouvilleWith.rat_sub_iff","module":"Mathlib.NumberTheory.Transcendental.Liouville.LiouvilleWith","initialProofState":"p x : Real\nr : Rat\n⊢ Iff (LiouvilleWith p (HSub.hSub (↑r) x)) (LiouvilleWith p x)","decl":"@[simp]\ntheorem rat_sub_iff : LiouvilleWith p (r - x) ↔ LiouvilleWith p x := by simp [sub_eq_add_neg]\n\n"}
{"name":"LiouvilleWith.rat_sub","module":"Mathlib.NumberTheory.Transcendental.Liouville.LiouvilleWith","initialProofState":"p x : Real\nh : LiouvilleWith p x\nr : Rat\n⊢ LiouvilleWith p (HSub.hSub (↑r) x)","decl":"theorem rat_sub (h : LiouvilleWith p x) (r : ℚ) : LiouvilleWith p (r - x) :=\n  rat_sub_iff.2 h\n\n"}
{"name":"LiouvilleWith.int_sub_iff","module":"Mathlib.NumberTheory.Transcendental.Liouville.LiouvilleWith","initialProofState":"p x : Real\nm : Int\n⊢ Iff (LiouvilleWith p (HSub.hSub (↑m) x)) (LiouvilleWith p x)","decl":"@[simp]\ntheorem int_sub_iff : LiouvilleWith p (m - x) ↔ LiouvilleWith p x := by simp [sub_eq_add_neg]\n\n"}
{"name":"LiouvilleWith.int_sub","module":"Mathlib.NumberTheory.Transcendental.Liouville.LiouvilleWith","initialProofState":"p x : Real\nh : LiouvilleWith p x\nm : Int\n⊢ LiouvilleWith p (HSub.hSub (↑m) x)","decl":"theorem int_sub (h : LiouvilleWith p x) (m : ℤ) : LiouvilleWith p (m - x) :=\n  int_sub_iff.2 h\n\n"}
{"name":"LiouvilleWith.nat_sub_iff","module":"Mathlib.NumberTheory.Transcendental.Liouville.LiouvilleWith","initialProofState":"p x : Real\nn : Nat\n⊢ Iff (LiouvilleWith p (HSub.hSub (↑n) x)) (LiouvilleWith p x)","decl":"@[simp]\ntheorem nat_sub_iff : LiouvilleWith p (n - x) ↔ LiouvilleWith p x := by simp [sub_eq_add_neg]\n\n"}
{"name":"LiouvilleWith.nat_sub","module":"Mathlib.NumberTheory.Transcendental.Liouville.LiouvilleWith","initialProofState":"p x : Real\nh : LiouvilleWith p x\nn : Nat\n⊢ LiouvilleWith p (HSub.hSub (↑n) x)","decl":"theorem nat_sub (h : LiouvilleWith p x) (n : ℕ) : LiouvilleWith p (n - x) :=\n  nat_sub_iff.2 h\n\n"}
{"name":"LiouvilleWith.ne_cast_int","module":"Mathlib.NumberTheory.Transcendental.Liouville.LiouvilleWith","initialProofState":"p x : Real\nh : LiouvilleWith p x\nhp : LT.lt 1 p\nm : Int\n⊢ Ne x ↑m","decl":"theorem ne_cast_int (h : LiouvilleWith p x) (hp : 1 < p) (m : ℤ) : x ≠ m := by\n  rintro rfl; rename' m => M\n  rcases ((eventually_gt_atTop 0).and_frequently (h.frequently_lt_rpow_neg hp)).exists with\n    ⟨n : ℕ, hn : 0 < n, m : ℤ, hne : (M : ℝ) ≠ m / n, hlt : |(M - m / n : ℝ)| < n ^ (-1 : ℝ)⟩\n  refine hlt.not_le ?_\n  have hn' : (0 : ℝ) < n := by simpa\n  rw [rpow_neg_one, ← one_div, sub_div' _ _ _ hn'.ne', abs_div, Nat.abs_cast]\n  gcongr\n  norm_cast\n  rw [← zero_add (1 : ℤ), Int.add_one_le_iff, abs_pos, sub_ne_zero]\n  rw [Ne, eq_div_iff hn'.ne'] at hne\n  exact mod_cast hne\n\n"}
{"name":"LiouvilleWith.irrational","module":"Mathlib.NumberTheory.Transcendental.Liouville.LiouvilleWith","initialProofState":"p x : Real\nh : LiouvilleWith p x\nhp : LT.lt 1 p\n⊢ Irrational x","decl":"/-- A number satisfying the Liouville condition with exponent `p > 1` is an irrational number. -/\nprotected theorem irrational (h : LiouvilleWith p x) (hp : 1 < p) : Irrational x := by\n  rintro ⟨r, rfl⟩\n  rcases eq_or_ne r 0 with (rfl | h0)\n  · refine h.ne_cast_int hp 0 ?_; rw [Rat.cast_zero, Int.cast_zero]\n  · refine (h.mul_rat (inv_ne_zero h0)).ne_cast_int hp 1 ?_\n    rw [Rat.cast_inv, mul_inv_cancel₀]\n    exacts [Int.cast_one.symm, Rat.cast_ne_zero.mpr h0]\n\n"}
{"name":"Liouville.frequently_exists_num","module":"Mathlib.NumberTheory.Transcendental.Liouville.LiouvilleWith","initialProofState":"x : Real\nhx : Liouville x\nn : Nat\n⊢ Filter.Frequently (fun b => Exists fun a => And (Ne x (HDiv.hDiv ↑a ↑b)) (LT.lt (abs (HSub.hSub x (HDiv.hDiv ↑a ↑b))) (HDiv.hDiv 1 (HPow.hPow (↑b) n)))) Filter.atTop","decl":"/-- If `x` is a Liouville number, then for any `n`, for infinitely many denominators `b` there\nexists a numerator `a` such that `x ≠ a / b` and `|x - a / b| < 1 / b ^ n`. -/\ntheorem frequently_exists_num (hx : Liouville x) (n : ℕ) :\n    ∃ᶠ b : ℕ in atTop, ∃ a : ℤ, x ≠ a / b ∧ |x - a / b| < 1 / (b : ℝ) ^ n := by\n  refine Classical.not_not.1 fun H => ?_\n  simp only [Liouville, not_forall, not_exists, not_frequently, not_and, not_lt,\n    eventually_atTop] at H\n  rcases H with ⟨N, hN⟩\n  have : ∀ b > (1 : ℕ), ∀ᶠ m : ℕ in atTop, ∀ a : ℤ, 1 / (b : ℝ) ^ m ≤ |x - a / b| := by\n    intro b hb\n    replace hb : (1 : ℝ) < b := Nat.one_lt_cast.2 hb\n    have H : Tendsto (fun m => 1 / (b : ℝ) ^ m : ℕ → ℝ) atTop (𝓝 0) := by\n      simp only [one_div]\n      exact tendsto_inv_atTop_zero.comp (tendsto_pow_atTop_atTop_of_one_lt hb)\n    refine (H.eventually (hx.irrational.eventually_forall_le_dist_cast_div b)).mono ?_\n    exact fun m hm a => hm a\n  have : ∀ᶠ m : ℕ in atTop, ∀ b < N, 1 < b → ∀ a : ℤ, 1 / (b : ℝ) ^ m ≤ |x - a / b| :=\n    (finite_lt_nat N).eventually_all.2 fun b _hb => eventually_imp_distrib_left.2 (this b)\n  rcases (this.and (eventually_ge_atTop n)).exists with ⟨m, hm, hnm⟩\n  rcases hx m with ⟨a, b, hb, hne, hlt⟩\n  lift b to ℕ using zero_le_one.trans hb.le; norm_cast at hb; push_cast at hne hlt\n  rcases le_or_lt N b with h | h\n  · refine (hN b h a hne).not_lt (hlt.trans_le ?_)\n    gcongr\n    exact_mod_cast hb.le\n  · exact (hm b h hb _).not_lt hlt\n\n"}
{"name":"Liouville.liouvilleWith","module":"Mathlib.NumberTheory.Transcendental.Liouville.LiouvilleWith","initialProofState":"x : Real\nhx : Liouville x\np : Real\n⊢ LiouvilleWith p x","decl":"/-- A Liouville number is a Liouville number with any real exponent. -/\nprotected theorem liouvilleWith (hx : Liouville x) (p : ℝ) : LiouvilleWith p x := by\n  suffices LiouvilleWith ⌈p⌉₊ x from this.mono (Nat.le_ceil p)\n  refine ⟨1, ((eventually_gt_atTop 1).and_frequently (hx.frequently_exists_num ⌈p⌉₊)).mono ?_⟩\n  rintro b ⟨_hb, a, hne, hlt⟩\n  refine ⟨a, hne, ?_⟩\n  rwa [rpow_natCast]\n\n"}
{"name":"forall_liouvilleWith_iff","module":"Mathlib.NumberTheory.Transcendental.Liouville.LiouvilleWith","initialProofState":"x : Real\n⊢ Iff (∀ (p : Real), LiouvilleWith p x) (Liouville x)","decl":"/-- A number satisfies the Liouville condition with any exponent if and only if it is a Liouville\nnumber. -/\ntheorem forall_liouvilleWith_iff {x : ℝ} : (∀ p, LiouvilleWith p x) ↔ Liouville x := by\n  refine ⟨fun H n => ?_, Liouville.liouvilleWith⟩\n  rcases ((eventually_gt_atTop 1).and_frequently\n    ((H (n + 1)).frequently_lt_rpow_neg (lt_add_one (n : ℝ)))).exists\n    with ⟨b, hb, a, hne, hlt⟩\n  exact ⟨a, b, mod_cast hb, hne, by simpa [rpow_neg] using hlt⟩\n"}
