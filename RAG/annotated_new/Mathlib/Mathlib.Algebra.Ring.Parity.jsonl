{"name":"Even.neg_pow","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"α : Type u_2\ninst✝¹ : Monoid α\ninst✝ : HasDistribNeg α\nn : Nat\na✝ : Even n\na : α\n⊢ Eq (HPow.hPow (Neg.neg a) n) (HPow.hPow a n)","decl":"@[simp] lemma Even.neg_pow : Even n → ∀ a : α, (-a) ^ n = a ^ n := by\n  rintro ⟨c, rfl⟩ a\n  simp_rw [← two_mul, pow_mul, neg_sq]\n\n"}
{"name":"Even.neg_one_pow","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"α : Type u_2\ninst✝¹ : Monoid α\ninst✝ : HasDistribNeg α\nn : Nat\nh : Even n\n⊢ Eq (HPow.hPow (-1) n) 1","decl":"lemma Even.neg_one_pow (h : Even n) : (-1 : α) ^ n = 1 := by rw [h.neg_pow, one_pow]\n\n"}
{"name":"Even.neg_zpow","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"α : Type u_2\ninst✝¹ : DivisionMonoid α\ninst✝ : HasDistribNeg α\nn : Int\na✝ : Even n\na : α\n⊢ Eq (HPow.hPow (Neg.neg a) n) (HPow.hPow a n)","decl":"lemma Even.neg_zpow : Even n → ∀ a : α, (-a) ^ n = a ^ n := by\n  rintro ⟨c, rfl⟩ a; simp_rw [← Int.two_mul, zpow_mul, zpow_two, neg_mul_neg]\n\n"}
{"name":"Even.neg_one_zpow","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"α : Type u_2\ninst✝¹ : DivisionMonoid α\ninst✝ : HasDistribNeg α\nn : Int\nh : Even n\n⊢ Eq (HPow.hPow (-1) n) 1","decl":"lemma Even.neg_one_zpow (h : Even n) : (-1 : α) ^ n = 1 := by rw [h.neg_zpow, one_zpow]\n\n"}
{"name":"IsSquare.zero","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"α : Type u_2\ninst✝ : MulZeroClass α\n⊢ IsSquare 0","decl":"@[simp] lemma IsSquare.zero [MulZeroClass α] : IsSquare (0 : α) := ⟨0, (mul_zero _).symm⟩\n\n"}
{"name":"even_iff_exists_two_mul","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"α : Type u_2\ninst✝ : Semiring α\na : α\n⊢ Iff (Even a) (Exists fun b => Eq a (HMul.hMul 2 b))","decl":"lemma even_iff_exists_two_mul : Even a ↔ ∃ b, a = 2 * b := by simp [even_iff_exists_two_nsmul]\n\n"}
{"name":"even_iff_two_dvd","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"α : Type u_2\ninst✝ : Semiring α\na : α\n⊢ Iff (Even a) (Dvd.dvd 2 a)","decl":"lemma even_iff_two_dvd : Even a ↔ 2 ∣ a := by simp [Even, Dvd.dvd, two_mul]\n\n"}
{"name":"Even.two_dvd","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"α : Type u_2\ninst✝ : Semiring α\na : α\na✝ : Even a\n⊢ Dvd.dvd 2 a","decl":"alias ⟨Even.two_dvd, _⟩ := even_iff_two_dvd\n\n"}
{"name":"Even.trans_dvd","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"α : Type u_2\ninst✝ : Semiring α\na b : α\nha : Even a\nhab : Dvd.dvd a b\n⊢ Even b","decl":"lemma Even.trans_dvd (ha : Even a) (hab : a ∣ b) : Even b :=\n  even_iff_two_dvd.2 <| ha.two_dvd.trans hab\n\n"}
{"name":"Dvd.dvd.even","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"α : Type u_2\ninst✝ : Semiring α\na b : α\nhab : Dvd.dvd a b\nha : Even a\n⊢ Even b","decl":"lemma Dvd.dvd.even (hab : a ∣ b) (ha : Even a) : Even b := ha.trans_dvd hab\n\n"}
{"name":"range_two_mul","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"α : Type u_4\ninst✝ : Semiring α\n⊢ Eq (Set.range fun x => HMul.hMul 2 x) (setOf fun a => Even a)","decl":"@[simp] lemma range_two_mul (α) [Semiring α] : Set.range (fun x : α ↦ 2 * x) = {a | Even a} := by\n  ext x\n  simp [eq_comm, two_mul, Even]\n\n"}
{"name":"even_two","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"α : Type u_2\ninst✝ : Semiring α\n⊢ Even 2","decl":"@[simp] lemma even_two : Even (2 : α) := ⟨1, by rw [one_add_one_eq_two]⟩\n\n"}
{"name":"Even.mul_left","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"α : Type u_2\ninst✝ : Semiring α\na : α\nha : Even a\nb : α\n⊢ Even (HMul.hMul b a)","decl":"@[simp] lemma Even.mul_left (ha : Even a) (b) : Even (b * a) := ha.map (AddMonoidHom.mulLeft _)\n\n"}
{"name":"Even.mul_right","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"α : Type u_2\ninst✝ : Semiring α\na : α\nha : Even a\nb : α\n⊢ Even (HMul.hMul a b)","decl":"@[simp] lemma Even.mul_right (ha : Even a) (b) : Even (a * b) := ha.map (AddMonoidHom.mulRight _)\n\n"}
{"name":"even_two_mul","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"α : Type u_2\ninst✝ : Semiring α\na : α\n⊢ Even (HMul.hMul 2 a)","decl":"lemma even_two_mul (a : α) : Even (2 * a) := ⟨a, two_mul _⟩\n\n"}
{"name":"Even.pow_of_ne_zero","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"α : Type u_2\ninst✝ : Semiring α\na : α\nha : Even a\nn : Nat\na✝ : Ne n 0\n⊢ Even (HPow.hPow a n)","decl":"lemma Even.pow_of_ne_zero (ha : Even a) : ∀ {n : ℕ}, n ≠ 0 → Even (a ^ n)\n  | n + 1, _ => by rw [pow_succ]; exact ha.mul_left _\n\n"}
{"name":"odd_iff_exists_bit1","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"α : Type u_2\ninst✝ : Semiring α\na : α\n⊢ Iff (Odd a) (Exists fun b => Eq a (HAdd.hAdd (HMul.hMul 2 b) 1))","decl":"lemma odd_iff_exists_bit1 : Odd a ↔ ∃ b, a = 2 * b + 1 := exists_congr fun b ↦ by rw [two_mul]\n\n"}
{"name":"Odd.exists_bit1","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"α : Type u_2\ninst✝ : Semiring α\na : α\na✝ : Odd a\n⊢ Exists fun b => Eq a (HAdd.hAdd (HMul.hMul 2 b) 1)","decl":"alias ⟨Odd.exists_bit1, _⟩ := odd_iff_exists_bit1\n\n"}
{"name":"range_two_mul_add_one","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"α : Type u_4\ninst✝ : Semiring α\n⊢ Eq (Set.range fun x => HAdd.hAdd (HMul.hMul 2 x) 1) (setOf fun a => Odd a)","decl":"@[simp] lemma range_two_mul_add_one (α : Type*) [Semiring α] :\n    Set.range (fun x : α ↦ 2 * x + 1) = {a | Odd a} := by ext x; simp [Odd, eq_comm]\n\n"}
{"name":"Even.add_odd","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"α : Type u_2\ninst✝ : Semiring α\na b : α\na✝¹ : Even a\na✝ : Odd b\n⊢ Odd (HAdd.hAdd a b)","decl":"lemma Even.add_odd : Even a → Odd b → Odd (a + b) := by\n  rintro ⟨a, rfl⟩ ⟨b, rfl⟩; exact ⟨a + b, by rw [mul_add, ← two_mul, add_assoc]⟩\n\n"}
{"name":"Even.odd_add","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"α : Type u_2\ninst✝ : Semiring α\na b : α\nha : Even a\nhb : Odd b\n⊢ Odd (HAdd.hAdd b a)","decl":"lemma Even.odd_add (ha : Even a) (hb : Odd b) : Odd (b + a) := add_comm a b ▸ ha.add_odd hb\n"}
{"name":"Odd.add_even","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"α : Type u_2\ninst✝ : Semiring α\na b : α\nha : Odd a\nhb : Even b\n⊢ Odd (HAdd.hAdd a b)","decl":"lemma Odd.add_even (ha : Odd a) (hb : Even b) : Odd (a + b) := add_comm a b ▸ hb.add_odd ha\n\n"}
{"name":"Odd.add_odd","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"α : Type u_2\ninst✝ : Semiring α\na b : α\na✝¹ : Odd a\na✝ : Odd b\n⊢ Even (HAdd.hAdd a b)","decl":"lemma Odd.add_odd : Odd a → Odd b → Even (a + b) := by\n  rintro ⟨a, rfl⟩ ⟨b, rfl⟩\n  refine ⟨a + b + 1, ?_⟩\n  rw [two_mul, two_mul]\n  ac_rfl\n\n"}
{"name":"odd_one","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"α : Type u_2\ninst✝ : Semiring α\n⊢ Odd 1","decl":"@[simp] lemma odd_one : Odd (1 : α) :=\n  ⟨0, (zero_add _).symm.trans (congr_arg (· + (1 : α)) (mul_zero _).symm)⟩\n\n"}
{"name":"Even.add_one","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"α : Type u_2\ninst✝ : Semiring α\na : α\nh : Even a\n⊢ Odd (HAdd.hAdd a 1)","decl":"@[simp] lemma Even.add_one (h : Even a) : Odd (a + 1) := h.add_odd odd_one\n"}
{"name":"Even.one_add","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"α : Type u_2\ninst✝ : Semiring α\na : α\nh : Even a\n⊢ Odd (HAdd.hAdd 1 a)","decl":"@[simp] lemma Even.one_add (h : Even a) : Odd (1 + a) := h.odd_add odd_one\n"}
{"name":"Odd.add_one","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"α : Type u_2\ninst✝ : Semiring α\na : α\nh : Odd a\n⊢ Even (HAdd.hAdd a 1)","decl":"@[simp] lemma Odd.add_one (h : Odd a) : Even (a + 1) := h.add_odd odd_one\n"}
{"name":"Odd.one_add","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"α : Type u_2\ninst✝ : Semiring α\na : α\nh : Odd a\n⊢ Even (HAdd.hAdd 1 a)","decl":"@[simp] lemma Odd.one_add (h : Odd a) : Even (1 + a) := odd_one.add_odd h\n\n"}
{"name":"odd_two_mul_add_one","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"α : Type u_2\ninst✝ : Semiring α\na : α\n⊢ Odd (HAdd.hAdd (HMul.hMul 2 a) 1)","decl":"lemma odd_two_mul_add_one (a : α) : Odd (2 * a + 1) := ⟨_, rfl⟩\n\n"}
{"name":"odd_add_self_one'","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"α : Type u_2\ninst✝ : Semiring α\na : α\n⊢ Odd (HAdd.hAdd a (HAdd.hAdd a 1))","decl":"@[simp] lemma odd_add_self_one' : Odd (a + (a + 1)) := by simp [← add_assoc]\n"}
{"name":"odd_add_one_self","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"α : Type u_2\ninst✝ : Semiring α\na : α\n⊢ Odd (HAdd.hAdd (HAdd.hAdd a 1) a)","decl":"@[simp] lemma odd_add_one_self : Odd (a + 1 + a) := by simp [add_comm _ a]\n"}
{"name":"odd_add_one_self'","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"α : Type u_2\ninst✝ : Semiring α\na : α\n⊢ Odd (HAdd.hAdd a (HAdd.hAdd 1 a))","decl":"@[simp] lemma odd_add_one_self' : Odd (a + (1 + a)) := by simp [add_comm 1 a]\n\n"}
{"name":"Odd.map","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : Semiring α\ninst✝² : Semiring β\na : α\ninst✝¹ : FunLike F α β\ninst✝ : RingHomClass F α β\nf : F\na✝ : Odd a\n⊢ Odd (f a)","decl":"lemma Odd.map [FunLike F α β] [RingHomClass F α β] (f : F) : Odd a → Odd (f a) := by\n  rintro ⟨a, rfl⟩; exact ⟨f a, by simp [two_mul]⟩\n\n"}
{"name":"Odd.natCast","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"R : Type u_4\ninst✝ : Semiring R\nn : Nat\nhn : Odd n\n⊢ Odd ↑n","decl":"lemma Odd.natCast {R : Type*} [Semiring R] {n : ℕ} (hn : Odd n) : Odd (n : R) :=\n  hn.map <| Nat.castRingHom R\n\n"}
{"name":"Odd.mul","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"α : Type u_2\ninst✝ : Semiring α\na b : α\na✝¹ : Odd a\na✝ : Odd b\n⊢ Odd (HMul.hMul a b)","decl":"@[simp] lemma Odd.mul : Odd a → Odd b → Odd (a * b) := by\n  rintro ⟨a, rfl⟩ ⟨b, rfl⟩\n  refine ⟨2 * a * b + b + a, ?_⟩\n  rw [mul_add, add_mul, mul_one, ← add_assoc, one_mul, mul_assoc, ← mul_add, ← mul_add, ← mul_assoc,\n    ← Nat.cast_two, ← Nat.cast_comm]\n\n"}
{"name":"Odd.pow","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"α : Type u_2\ninst✝ : Semiring α\na : α\nha : Odd a\nn : Nat\n⊢ Odd (HPow.hPow a n)","decl":"lemma Odd.pow (ha : Odd a) : ∀ {n : ℕ}, Odd (a ^ n)\n  | 0 => by\n    rw [pow_zero]\n    exact odd_one\n  | n + 1 => by rw [pow_succ]; exact ha.pow.mul ha\n\n"}
{"name":"Odd.pow_add_pow_eq_zero","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"α : Type u_2\ninst✝¹ : Semiring α\na b : α\nn : Nat\ninst✝ : IsCancelAdd α\nhn : Odd n\nhab : Eq (HAdd.hAdd a b) 0\n⊢ Eq (HAdd.hAdd (HPow.hPow a n) (HPow.hPow b n)) 0","decl":"lemma Odd.pow_add_pow_eq_zero [IsCancelAdd α] (hn : Odd n) (hab : a + b = 0) :\n    a ^ n + b ^ n = 0 := by\n  obtain ⟨k, rfl⟩ := hn\n  induction' k with k ih\n  · simpa\n  have : a ^ 2 = b ^ 2 := add_right_cancel <|\n    calc\n      a ^ 2 + a * b = 0 := by rw [sq, ← mul_add, hab, mul_zero]\n      _ = b ^ 2 + a * b := by rw [sq, ← add_mul, add_comm, hab, zero_mul]\n  refine add_right_cancel (b := b ^ (2 * k + 1) * a ^ 2) ?_\n  calc\n    _ = (a ^ (2 * k + 1) + b ^ (2 * k + 1)) * a ^ 2 + b ^ (2 * k + 3) := by\n      rw [add_mul, ← pow_add, add_right_comm]; rfl\n    _ = _ := by rw [ih, zero_mul, zero_add, zero_add, this, ← pow_add]\n\n"}
{"name":"Odd.neg_pow","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"α : Type u_2\ninst✝¹ : Monoid α\ninst✝ : HasDistribNeg α\nn : Nat\na✝ : Odd n\na : α\n⊢ Eq (HPow.hPow (Neg.neg a) n) (Neg.neg (HPow.hPow a n))","decl":"lemma Odd.neg_pow : Odd n → ∀ a : α, (-a) ^ n = -a ^ n := by\n  rintro ⟨c, rfl⟩ a; simp_rw [pow_add, pow_mul, neg_sq, pow_one, mul_neg]\n\n"}
{"name":"Odd.neg_one_pow","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"α : Type u_2\ninst✝¹ : Monoid α\ninst✝ : HasDistribNeg α\nn : Nat\nh : Odd n\n⊢ Eq (HPow.hPow (-1) n) (-1)","decl":"@[simp] lemma Odd.neg_one_pow (h : Odd n) : (-1 : α) ^ n = -1 := by rw [h.neg_pow, one_pow]\n\n"}
{"name":"even_neg_two","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"α : Type u_2\ninst✝ : Ring α\n⊢ Even (-2)","decl":"lemma even_neg_two : Even (-2 : α) := by simp only [even_neg, even_two]\n\n"}
{"name":"Odd.neg","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"α : Type u_2\ninst✝ : Ring α\na : α\nhp : Odd a\n⊢ Odd (Neg.neg a)","decl":"lemma Odd.neg (hp : Odd a) : Odd (-a) := by\n  obtain ⟨k, hk⟩ := hp\n  use -(k + 1)\n  rw [mul_neg, mul_add, neg_add, add_assoc, two_mul (1 : α), neg_add, neg_add_cancel_right,\n    ← neg_add, hk]\n\n"}
{"name":"odd_neg","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"α : Type u_2\ninst✝ : Ring α\na : α\n⊢ Iff (Odd (Neg.neg a)) (Odd a)","decl":"@[simp] lemma odd_neg : Odd (-a) ↔ Odd a := ⟨fun h ↦ neg_neg a ▸ h.neg, Odd.neg⟩\n\n"}
{"name":"odd_neg_one","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"α : Type u_2\ninst✝ : Ring α\n⊢ Odd (-1)","decl":"lemma odd_neg_one : Odd (-1 : α) := by simp\n\n"}
{"name":"Odd.sub_even","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"α : Type u_2\ninst✝ : Ring α\na b : α\nha : Odd a\nhb : Even b\n⊢ Odd (HSub.hSub a b)","decl":"lemma Odd.sub_even (ha : Odd a) (hb : Even b) : Odd (a - b) := by\n  rw [sub_eq_add_neg]; exact ha.add_even hb.neg\n\n"}
{"name":"Even.sub_odd","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"α : Type u_2\ninst✝ : Ring α\na b : α\nha : Even a\nhb : Odd b\n⊢ Odd (HSub.hSub a b)","decl":"lemma Even.sub_odd (ha : Even a) (hb : Odd b) : Odd (a - b) := by\n  rw [sub_eq_add_neg]; exact ha.add_odd hb.neg\n\n"}
{"name":"Odd.sub_odd","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"α : Type u_2\ninst✝ : Ring α\na b : α\nha : Odd a\nhb : Odd b\n⊢ Even (HSub.hSub a b)","decl":"lemma Odd.sub_odd (ha : Odd a) (hb : Odd b) : Even (a - b) := by\n  rw [sub_eq_add_neg]; exact ha.add_odd hb.neg\n\n"}
{"name":"Nat.odd_iff","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"n : Nat\n⊢ Iff (Odd n) (Eq (HMod.hMod n 2) 1)","decl":"lemma odd_iff : Odd n ↔ n % 2 = 1 :=\n  ⟨fun ⟨m, hm⟩ ↦ by omega, fun h ↦ ⟨n / 2, (mod_add_div n 2).symm.trans (by rw [h, add_comm])⟩⟩\n\n"}
{"name":"Nat.not_odd_iff","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"n : Nat\n⊢ Iff (Not (Odd n)) (Eq (HMod.hMod n 2) 0)","decl":"lemma not_odd_iff : ¬Odd n ↔ n % 2 = 0 := by rw [odd_iff, mod_two_not_eq_one]\n\n"}
{"name":"Nat.not_odd_iff_even","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"n : Nat\n⊢ Iff (Not (Odd n)) (Even n)","decl":"@[simp] lemma not_odd_iff_even : ¬Odd n ↔ Even n := by rw [not_odd_iff, even_iff]\n"}
{"name":"Nat.not_even_iff_odd","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"n : Nat\n⊢ Iff (Not (Even n)) (Odd n)","decl":"@[simp] lemma not_even_iff_odd : ¬Even n ↔ Odd n := by rw [not_even_iff, odd_iff]\n\n"}
{"name":"Nat.not_odd_zero","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"⊢ Not (Odd 0)","decl":"@[simp] lemma not_odd_zero : ¬Odd 0 := not_odd_iff.mpr rfl\n\n"}
{"name":"Nat.even_iff_not_odd","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"n : Nat\n⊢ Iff (Even n) (Not (Odd n))","decl":"@[deprecated not_odd_iff_even (since := \"2024-08-21\")]\nlemma even_iff_not_odd : Even n ↔ ¬Odd n := by rw [not_odd_iff, even_iff]\n\n"}
{"name":"Nat.odd_iff_not_even","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"n : Nat\n⊢ Iff (Odd n) (Not (Even n))","decl":"@[deprecated not_even_iff_odd (since := \"2024-08-21\")]\nlemma odd_iff_not_even : Odd n ↔ ¬Even n := by rw [not_even_iff, odd_iff]\n\n"}
{"name":"Odd.not_two_dvd_nat","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"n : Nat\nh : Odd n\n⊢ Not (Dvd.dvd 2 n)","decl":"lemma _root_.Odd.not_two_dvd_nat (h : Odd n) : ¬(2 ∣ n) := by\n  rwa [← even_iff_two_dvd, not_even_iff_odd]\n\n"}
{"name":"Nat.even_xor_odd","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"n : Nat\n⊢ Xor' (Even n) (Odd n)","decl":"lemma even_xor_odd (n : ℕ) : Xor' (Even n) (Odd n) := by\n  simp [Xor', ← not_even_iff_odd, Decidable.em (Even n)]\n\n"}
{"name":"Nat.even_or_odd","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"n : Nat\n⊢ Or (Even n) (Odd n)","decl":"lemma even_or_odd (n : ℕ) : Even n ∨ Odd n := (even_xor_odd n).or\n\n"}
{"name":"Nat.even_or_odd'","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"n : Nat\n⊢ Exists fun k => Or (Eq n (HMul.hMul 2 k)) (Eq n (HAdd.hAdd (HMul.hMul 2 k) 1))","decl":"lemma even_or_odd' (n : ℕ) : ∃ k, n = 2 * k ∨ n = 2 * k + 1 := by\n  simpa only [← two_mul, exists_or, Odd, Even] using even_or_odd n\n\n"}
{"name":"Nat.even_xor_odd'","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"n : Nat\n⊢ Exists fun k => Xor' (Eq n (HMul.hMul 2 k)) (Eq n (HAdd.hAdd (HMul.hMul 2 k) 1))","decl":"lemma even_xor_odd' (n : ℕ) : ∃ k, Xor' (n = 2 * k) (n = 2 * k + 1) := by\n  obtain ⟨k, rfl⟩ | ⟨k, rfl⟩ := even_or_odd n <;> use k\n  · simpa only [← two_mul, eq_self_iff_true, xor_true] using (succ_ne_self (2 * k)).symm\n  · simpa only [xor_true, xor_comm] using (succ_ne_self _)\n\n"}
{"name":"Nat.odd_add_one","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"n : Nat\n⊢ Iff (Odd (HAdd.hAdd n 1)) (Not (Odd n))","decl":"lemma odd_add_one {n : ℕ} : Odd (n + 1) ↔ ¬ Odd n := by\n  rw [← not_even_iff_odd, Nat.even_add_one, not_even_iff_odd]\n\n"}
{"name":"Nat.mod_two_add_add_odd_mod_two","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"m n : Nat\nhn : Odd n\n⊢ Eq (HAdd.hAdd (HMod.hMod m 2) (HMod.hMod (HAdd.hAdd m n) 2)) 1","decl":"lemma mod_two_add_add_odd_mod_two (m : ℕ) {n : ℕ} (hn : Odd n) : m % 2 + (m + n) % 2 = 1 :=\n  ((even_or_odd m).elim fun hm ↦ by rw [even_iff.1 hm, odd_iff.1 (hm.add_odd hn)]) fun hm ↦ by\n    rw [odd_iff.1 hm, even_iff.1 (hm.add_odd hn)]\n\n"}
{"name":"Nat.mod_two_add_succ_mod_two","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"m : Nat\n⊢ Eq (HAdd.hAdd (HMod.hMod m 2) (HMod.hMod (HAdd.hAdd m 1) 2)) 1","decl":"@[simp] lemma mod_two_add_succ_mod_two (m : ℕ) : m % 2 + (m + 1) % 2 = 1 :=\n  mod_two_add_add_odd_mod_two m odd_one\n\n"}
{"name":"Nat.succ_mod_two_add_mod_two","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"m : Nat\n⊢ Eq (HAdd.hAdd (HMod.hMod (HAdd.hAdd m 1) 2) (HMod.hMod m 2)) 1","decl":"@[simp] lemma succ_mod_two_add_mod_two (m : ℕ) : (m + 1) % 2 + m % 2 = 1 := by\n  rw [add_comm, mod_two_add_succ_mod_two]\n\n"}
{"name":"Nat.even_add'","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"m n : Nat\n⊢ Iff (Even (HAdd.hAdd m n)) (Iff (Odd m) (Odd n))","decl":"lemma even_add' : Even (m + n) ↔ (Odd m ↔ Odd n) := by\n  rw [even_add, ← not_odd_iff_even, ← not_odd_iff_even, not_iff_not]\n\n"}
{"name":"Nat.not_even_bit1","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"n : Nat\n⊢ Not (Even (HAdd.hAdd (HMul.hMul 2 n) 1))","decl":"@[simp] lemma not_even_bit1 (n : ℕ) : ¬Even (2 * n + 1) := by simp [parity_simps]\n\n"}
{"name":"Nat.not_even_two_mul_add_one","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"n : Nat\n⊢ Not (Even (HAdd.hAdd (HMul.hMul 2 n) 1))","decl":"lemma not_even_two_mul_add_one (n : ℕ) : ¬ Even (2 * n + 1) :=\n  not_even_iff_odd.2 <| odd_two_mul_add_one n\n\n"}
{"name":"Nat.even_sub'","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"m n : Nat\nh : LE.le n m\n⊢ Iff (Even (HSub.hSub m n)) (Iff (Odd m) (Odd n))","decl":"lemma even_sub' (h : n ≤ m) : Even (m - n) ↔ (Odd m ↔ Odd n) := by\n  rw [even_sub h, ← not_odd_iff_even, ← not_odd_iff_even, not_iff_not]\n\n"}
{"name":"Nat.Odd.sub_odd","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"m n : Nat\nhm : Odd m\nhn : Odd n\n⊢ Even (HSub.hSub m n)","decl":"lemma Odd.sub_odd (hm : Odd m) (hn : Odd n) : Even (m - n) :=\n  (le_total n m).elim (fun h ↦ by simp only [even_sub' h, *]) fun h ↦ by\n    simp only [Nat.sub_eq_zero_iff_le.2 h, Even.zero]\n\n"}
{"name":"Odd.tsub_odd","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"m n : Nat\nhm : Odd m\nhn : Odd n\n⊢ Even (HSub.hSub m n)","decl":"alias _root_.Odd.tsub_odd := Nat.Odd.sub_odd\n\n"}
{"name":"Nat.odd_mul","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"m n : Nat\n⊢ Iff (Odd (HMul.hMul m n)) (And (Odd m) (Odd n))","decl":"lemma odd_mul : Odd (m * n) ↔ Odd m ∧ Odd n := by simp [not_or, even_mul, ← not_even_iff_odd]\n\n"}
{"name":"Nat.Odd.of_mul_left","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"m n : Nat\nh : Odd (HMul.hMul m n)\n⊢ Odd m","decl":"lemma Odd.of_mul_left (h : Odd (m * n)) : Odd m :=\n  (odd_mul.mp h).1\n\n"}
{"name":"Nat.Odd.of_mul_right","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"m n : Nat\nh : Odd (HMul.hMul m n)\n⊢ Odd n","decl":"lemma Odd.of_mul_right (h : Odd (m * n)) : Odd n :=\n  (odd_mul.mp h).2\n\n"}
{"name":"Nat.even_div","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"m n : Nat\n⊢ Iff (Even (HDiv.hDiv m n)) (Eq (HDiv.hDiv (HMod.hMod m (HMul.hMul 2 n)) n) 0)","decl":"lemma even_div : Even (m / n) ↔ m % (2 * n) / n = 0 := by\n  rw [even_iff_two_dvd, dvd_iff_mod_eq_zero, ← Nat.mod_mul_right_div_self, mul_comm]\n\n"}
{"name":"Nat.odd_add","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"m n : Nat\n⊢ Iff (Odd (HAdd.hAdd m n)) (Iff (Odd m) (Even n))","decl":"@[parity_simps] lemma odd_add : Odd (m + n) ↔ (Odd m ↔ Even n) := by\n  rw [← not_even_iff_odd, even_add, not_iff, ← not_even_iff_odd]\n\n"}
{"name":"Nat.odd_add'","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"m n : Nat\n⊢ Iff (Odd (HAdd.hAdd m n)) (Iff (Odd n) (Even m))","decl":"lemma odd_add' : Odd (m + n) ↔ (Odd n ↔ Even m) := by rw [add_comm, odd_add]\n\n"}
{"name":"Nat.ne_of_odd_add","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"m n : Nat\nh : Odd (HAdd.hAdd m n)\n⊢ Ne m n","decl":"lemma ne_of_odd_add (h : Odd (m + n)) : m ≠ n := by rintro rfl; simp [← not_even_iff_odd] at h\n\n"}
{"name":"Nat.odd_sub","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"m n : Nat\nh : LE.le n m\n⊢ Iff (Odd (HSub.hSub m n)) (Iff (Odd m) (Even n))","decl":"@[parity_simps] lemma odd_sub (h : n ≤ m) : Odd (m - n) ↔ (Odd m ↔ Even n) := by\n  rw [← not_even_iff_odd, even_sub h, not_iff, ← not_even_iff_odd]\n\n"}
{"name":"Nat.Odd.sub_even","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"m n : Nat\nh : LE.le n m\nhm : Odd m\nhn : Even n\n⊢ Odd (HSub.hSub m n)","decl":"lemma Odd.sub_even (h : n ≤ m) (hm : Odd m) (hn : Even n) : Odd (m - n) :=\n  (odd_sub h).mpr <| iff_of_true hm hn\n\n"}
{"name":"Nat.odd_sub'","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"m n : Nat\nh : LE.le n m\n⊢ Iff (Odd (HSub.hSub m n)) (Iff (Odd n) (Even m))","decl":"lemma odd_sub' (h : n ≤ m) : Odd (m - n) ↔ (Odd n ↔ Even m) := by\n  rw [← not_even_iff_odd, even_sub h, not_iff, not_iff_comm, ← not_even_iff_odd]\n\n"}
{"name":"Nat.Even.sub_odd","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"m n : Nat\nh : LE.le n m\nhm : Even m\nhn : Odd n\n⊢ Odd (HSub.hSub m n)","decl":"lemma Even.sub_odd (h : n ≤ m) (hm : Even m) (hn : Odd n) : Odd (m - n) :=\n  (odd_sub' h).mpr <| iff_of_true hn hm\n\n"}
{"name":"Nat.two_mul_div_two_add_one_of_odd","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"n : Nat\nh : Odd n\n⊢ Eq (HAdd.hAdd (HMul.hMul 2 (HDiv.hDiv n 2)) 1) n","decl":"lemma two_mul_div_two_add_one_of_odd (h : Odd n) : 2 * (n / 2) + 1 = n := by\n  rw [← odd_iff.mp h, div_add_mod]\n\n"}
{"name":"Nat.div_two_mul_two_add_one_of_odd","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"n : Nat\nh : Odd n\n⊢ Eq (HAdd.hAdd (HMul.hMul (HDiv.hDiv n 2) 2) 1) n","decl":"lemma div_two_mul_two_add_one_of_odd (h : Odd n) : n / 2 * 2 + 1 = n := by\n  rw [← odd_iff.mp h, div_add_mod']\n\n"}
{"name":"Nat.one_add_div_two_mul_two_of_odd","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"n : Nat\nh : Odd n\n⊢ Eq (HAdd.hAdd 1 (HMul.hMul (HDiv.hDiv n 2) 2)) n","decl":"lemma one_add_div_two_mul_two_of_odd (h : Odd n) : 1 + n / 2 * 2 = n := by\n  rw [← odd_iff.mp h, mod_add_div']\n\n"}
{"name":"Function.Involutive.iterate_bit0","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"α : Type u_4\nf : α → α\nhf : Function.Involutive f\nn : Nat\n⊢ Eq (Nat.iterate f (HMul.hMul 2 n)) id","decl":"lemma iterate_bit0 (hf : Involutive f) (n : ℕ) : f^[2 * n] = id := by\n  rw [iterate_mul, involutive_iff_iter_2_eq_id.1 hf, iterate_id]\n\n"}
{"name":"Function.Involutive.iterate_bit1","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"α : Type u_4\nf : α → α\nhf : Function.Involutive f\nn : Nat\n⊢ Eq (Nat.iterate f (HAdd.hAdd (HMul.hMul 2 n) 1)) f","decl":"lemma iterate_bit1 (hf : Involutive f) (n : ℕ) : f^[2 * n + 1] = f := by\n  rw [← succ_eq_add_one, iterate_succ, hf.iterate_bit0, id_comp]\n\n"}
{"name":"Function.Involutive.iterate_two_mul","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"α : Type u_4\nf : α → α\nhf : Function.Involutive f\nn : Nat\n⊢ Eq (Nat.iterate f (HMul.hMul 2 n)) id","decl":"lemma iterate_two_mul (hf : Involutive f) (n : ℕ) : f^[2 * n] = id := by\n  rw [iterate_mul, involutive_iff_iter_2_eq_id.1 hf, iterate_id]\n\n"}
{"name":"Function.Involutive.iterate_even","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"α : Type u_4\nf : α → α\nn : Nat\nhf : Function.Involutive f\nhn : Even n\n⊢ Eq (Nat.iterate f n) id","decl":"lemma iterate_even (hf : Involutive f) (hn : Even n) : f^[n] = id := by\n  obtain ⟨m, rfl⟩ := hn\n  rw [← two_mul, hf.iterate_two_mul]\n\n"}
{"name":"Function.Involutive.iterate_odd","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"α : Type u_4\nf : α → α\nn : Nat\nhf : Function.Involutive f\nhn : Odd n\n⊢ Eq (Nat.iterate f n) f","decl":"lemma iterate_odd (hf : Involutive f) (hn : Odd n) : f^[n] = f := by\n  obtain ⟨m, rfl⟩ := hn\n  rw [iterate_add, hf.iterate_two_mul, id_comp, iterate_one]\n\n"}
{"name":"Function.Involutive.iterate_eq_self","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"α : Type u_4\nf : α → α\nn : Nat\nhf : Function.Involutive f\nhne : Ne f id\n⊢ Iff (Eq (Nat.iterate f n) f) (Odd n)","decl":"lemma iterate_eq_self (hf : Involutive f) (hne : f ≠ id) : f^[n] = f ↔ Odd n :=\n  ⟨fun H ↦ not_even_iff_odd.1 fun hn ↦ hne <| by rwa [hf.iterate_even hn, eq_comm] at H,\n    hf.iterate_odd⟩\n\n"}
{"name":"Function.Involutive.iterate_eq_id","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"α : Type u_4\nf : α → α\nn : Nat\nhf : Function.Involutive f\nhne : Ne f id\n⊢ Iff (Eq (Nat.iterate f n) id) (Even n)","decl":"lemma iterate_eq_id (hf : Involutive f) (hne : f ≠ id) : f^[n] = id ↔ Even n :=\n  ⟨fun H ↦ not_odd_iff_even.1 fun hn ↦ hne <| by rwa [hf.iterate_odd hn] at H, hf.iterate_even⟩\n\n"}
{"name":"neg_one_pow_eq_ite","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"R : Type u_4\ninst✝¹ : Monoid R\ninst✝ : HasDistribNeg R\nn : Nat\n⊢ Eq (HPow.hPow (-1) n) (ite (Even n) 1 (-1))","decl":"lemma neg_one_pow_eq_ite {R : Type*} [Monoid R] [HasDistribNeg R] {n : ℕ} :\n    (-1 : R) ^ n = ite (Even n) 1 (-1) := by\n  cases even_or_odd n with\n  | inl h => rw [h.neg_one_pow, if_pos h]\n  | inr h => rw [h.neg_one_pow, if_neg (by simpa using h)]\n\n"}
{"name":"neg_one_pow_eq_one_iff_even","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"R : Type u_4\ninst✝¹ : Monoid R\ninst✝ : HasDistribNeg R\nn : Nat\nh : Ne (-1) 1\n⊢ Iff (Eq (HPow.hPow (-1) n) 1) (Even n)","decl":"lemma neg_one_pow_eq_one_iff_even {R : Type*} [Monoid R] [HasDistribNeg R] {n : ℕ}\n    (h : (-1 : R) ≠ 1) : (-1 : R) ^ n = 1 ↔ Even n := by simp [neg_one_pow_eq_ite, h]\n\n"}
{"name":"natCast_eq_zero_of_even_of_two_eq_zero","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"R : Type u_4\ninst✝ : AddMonoidWithOne R\nn : Nat\nhn : Even n\nh : Eq 2 0\n⊢ Eq (↑n) 0","decl":"theorem natCast_eq_zero_of_even_of_two_eq_zero {n : ℕ} (hn : Even n) (h : (2 : R) = 0) :\n    (n : R) = 0 :=\n  (natCast_eq_zero_or_one_of_two_eq_zero' n h).1 hn\n\n"}
{"name":"natCast_eq_one_of_odd_of_two_eq_zero","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"R : Type u_4\ninst✝ : AddMonoidWithOne R\nn : Nat\nhn : Odd n\nh : Eq 2 0\n⊢ Eq (↑n) 1","decl":"theorem natCast_eq_one_of_odd_of_two_eq_zero {n : ℕ} (hn : Odd n) (h : (2 : R) = 0) :\n    (n : R) = 1 :=\n  (natCast_eq_zero_or_one_of_two_eq_zero' n h).2 hn\n\n"}
{"name":"natCast_eq_zero_or_one_of_two_eq_zero","module":"Mathlib.Algebra.Ring.Parity","initialProofState":"R : Type u_4\ninst✝ : AddMonoidWithOne R\nn : Nat\nh : Eq 2 0\n⊢ Or (Eq (↑n) 0) (Eq (↑n) 1)","decl":"theorem natCast_eq_zero_or_one_of_two_eq_zero (n : ℕ) (h : (2 : R) = 0) :\n    (n : R) = 0 ∨ (n : R) = 1 := by\n  obtain hn | hn := Nat.even_or_odd n\n  · exact Or.inl <| natCast_eq_zero_of_even_of_two_eq_zero hn h\n  · exact Or.inr <| natCast_eq_one_of_odd_of_two_eq_zero hn h\n\n"}
