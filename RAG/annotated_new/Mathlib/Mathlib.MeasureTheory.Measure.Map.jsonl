{"name":"MeasureTheory.Measure.liftLinear_apply₀","module":"Mathlib.MeasureTheory.Measure.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nf : LinearMap (RingHom.id ENNReal) (MeasureTheory.OuterMeasure α) (MeasureTheory.OuterMeasure β)\nhf : ∀ (μ : MeasureTheory.Measure α), LE.le mβ (f μ.toOuterMeasure).caratheodory\ns : Set β\nhs : MeasureTheory.NullMeasurableSet s ((MeasureTheory.Measure.liftLinear f hf) μ)\n⊢ Eq (((MeasureTheory.Measure.liftLinear f hf) μ) s) ((f μ.toOuterMeasure) s)","decl":"lemma liftLinear_apply₀ {f : OuterMeasure α →ₗ[ℝ≥0∞] OuterMeasure β} (hf) {s : Set β}\n    (hs : NullMeasurableSet s (liftLinear f hf μ)) : liftLinear f hf μ s = f μ.toOuterMeasure s :=\n  toMeasure_apply₀ _ (hf μ) hs\n\n"}
{"name":"MeasureTheory.Measure.liftLinear_apply","module":"Mathlib.MeasureTheory.Measure.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nf : LinearMap (RingHom.id ENNReal) (MeasureTheory.OuterMeasure α) (MeasureTheory.OuterMeasure β)\nhf : ∀ (μ : MeasureTheory.Measure α), LE.le mβ (f μ.toOuterMeasure).caratheodory\ns : Set β\nhs : MeasurableSet s\n⊢ Eq (((MeasureTheory.Measure.liftLinear f hf) μ) s) ((f μ.toOuterMeasure) s)","decl":"@[simp]\ntheorem liftLinear_apply {f : OuterMeasure α →ₗ[ℝ≥0∞] OuterMeasure β} (hf) {s : Set β}\n    (hs : MeasurableSet s) : liftLinear f hf μ s = f μ.toOuterMeasure s :=\n  toMeasure_apply _ (hf μ) hs\n\n"}
{"name":"MeasureTheory.Measure.le_liftLinear_apply","module":"Mathlib.MeasureTheory.Measure.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nf : LinearMap (RingHom.id ENNReal) (MeasureTheory.OuterMeasure α) (MeasureTheory.OuterMeasure β)\nhf : ∀ (μ : MeasureTheory.Measure α), LE.le mβ (f μ.toOuterMeasure).caratheodory\ns : Set β\n⊢ LE.le ((f μ.toOuterMeasure) s) (((MeasureTheory.Measure.liftLinear f hf) μ) s)","decl":"theorem le_liftLinear_apply {f : OuterMeasure α →ₗ[ℝ≥0∞] OuterMeasure β} (hf) (s : Set β) :\n    f μ.toOuterMeasure s ≤ liftLinear f hf μ s :=\n  le_toMeasure_apply _ (hf μ) s\n\n"}
{"name":"MeasureTheory.Measure.mapₗ_congr","module":"Mathlib.MeasureTheory.Measure.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nf g : α → β\nhf : Measurable f\nhg : Measurable g\nh : (MeasureTheory.ae μ).EventuallyEq f g\n⊢ Eq ((MeasureTheory.Measure.mapₗ f) μ) ((MeasureTheory.Measure.mapₗ g) μ)","decl":"theorem mapₗ_congr {f g : α → β} (hf : Measurable f) (hg : Measurable g) (h : f =ᵐ[μ] g) :\n    mapₗ f μ = mapₗ g μ := by\n  ext1 s hs\n  simpa only [mapₗ, hf, hg, hs, dif_pos, liftLinear_apply, OuterMeasure.map_apply]\n    using measure_congr (h.preimage s)\n\n"}
{"name":"MeasureTheory.Measure.map_def","module":"Mathlib.MeasureTheory.Measure.Map","initialProofState":"α : Type u_4\nβ : Type u_5\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nf : α → β\nμ : MeasureTheory.Measure α\n⊢ Eq (MeasureTheory.Measure.map f μ) (dite (AEMeasurable f μ) (fun hf => (MeasureTheory.Measure.mapₗ (AEMeasurable.mk f hf)) μ) fun hf => 0)","decl":"open Classical in\n/-- The pushforward of a measure. It is defined to be `0` if `f` is not an almost everywhere\nmeasurable function. -/\nnoncomputable\nirreducible_def map [MeasurableSpace α] [MeasurableSpace β] (f : α → β) (μ : Measure α) :\n    Measure β :=\n  if hf : AEMeasurable f μ then mapₗ (hf.mk f) μ else 0\n\n"}
{"name":"MeasureTheory.Measure.mapₗ_mk_apply_of_aemeasurable","module":"Mathlib.MeasureTheory.Measure.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nf : α → β\nhf : AEMeasurable f μ\n⊢ Eq ((MeasureTheory.Measure.mapₗ (AEMeasurable.mk f hf)) μ) (MeasureTheory.Measure.map f μ)","decl":"theorem mapₗ_mk_apply_of_aemeasurable {f : α → β} (hf : AEMeasurable f μ) :\n    mapₗ (hf.mk f) μ = map f μ := by simp [map, hf]\n\n"}
{"name":"MeasureTheory.Measure.mapₗ_apply_of_measurable","module":"Mathlib.MeasureTheory.Measure.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nf : α → β\nhf : Measurable f\nμ : MeasureTheory.Measure α\n⊢ Eq ((MeasureTheory.Measure.mapₗ f) μ) (MeasureTheory.Measure.map f μ)","decl":"theorem mapₗ_apply_of_measurable {f : α → β} (hf : Measurable f) (μ : Measure α) :\n    mapₗ f μ = map f μ := by\n  simp only [← mapₗ_mk_apply_of_aemeasurable hf.aemeasurable]\n  exact mapₗ_congr hf hf.aemeasurable.measurable_mk hf.aemeasurable.ae_eq_mk\n\n"}
{"name":"MeasureTheory.Measure.map_add","module":"Mathlib.MeasureTheory.Measure.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ ν : MeasureTheory.Measure α\nf : α → β\nhf : Measurable f\n⊢ Eq (MeasureTheory.Measure.map f (HAdd.hAdd μ ν)) (HAdd.hAdd (MeasureTheory.Measure.map f μ) (MeasureTheory.Measure.map f ν))","decl":"@[simp]\ntheorem map_add (μ ν : Measure α) {f : α → β} (hf : Measurable f) :\n    (μ + ν).map f = μ.map f + ν.map f := by simp [← mapₗ_apply_of_measurable hf]\n\n"}
{"name":"MeasureTheory.Measure.map_zero","module":"Mathlib.MeasureTheory.Measure.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nf : α → β\n⊢ Eq (MeasureTheory.Measure.map f 0) 0","decl":"@[simp]\ntheorem map_zero (f : α → β) : (0 : Measure α).map f = 0 := by\n  by_cases hf : AEMeasurable f (0 : Measure α) <;> simp [map, hf]\n\n"}
{"name":"MeasureTheory.Measure.map_of_not_aemeasurable","module":"Mathlib.MeasureTheory.Measure.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nf : α → β\nμ : MeasureTheory.Measure α\nhf : Not (AEMeasurable f μ)\n⊢ Eq (MeasureTheory.Measure.map f μ) 0","decl":"@[simp]\ntheorem map_of_not_aemeasurable {f : α → β} {μ : Measure α} (hf : ¬AEMeasurable f μ) :\n    μ.map f = 0 := by simp [map, hf]\n\n"}
{"name":"AEMeasurable.of_map_ne_zero","module":"Mathlib.MeasureTheory.Measure.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nf : α → β\nμ : MeasureTheory.Measure α\nhf : Ne (MeasureTheory.Measure.map f μ) 0\n⊢ AEMeasurable f μ","decl":"theorem _root_.AEMeasurable.of_map_ne_zero {f : α → β} {μ : Measure α} (hf : μ.map f ≠ 0) :\n    AEMeasurable f μ := not_imp_comm.1 map_of_not_aemeasurable hf\n\n"}
{"name":"MeasureTheory.Measure.map_congr","module":"Mathlib.MeasureTheory.Measure.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nf g : α → β\nh : (MeasureTheory.ae μ).EventuallyEq f g\n⊢ Eq (MeasureTheory.Measure.map f μ) (MeasureTheory.Measure.map g μ)","decl":"theorem map_congr {f g : α → β} (h : f =ᵐ[μ] g) : Measure.map f μ = Measure.map g μ := by\n  by_cases hf : AEMeasurable f μ\n  · have hg : AEMeasurable g μ := hf.congr h\n    simp only [← mapₗ_mk_apply_of_aemeasurable hf, ← mapₗ_mk_apply_of_aemeasurable hg]\n    exact\n      mapₗ_congr hf.measurable_mk hg.measurable_mk (hf.ae_eq_mk.symm.trans (h.trans hg.ae_eq_mk))\n  · have hg : ¬AEMeasurable g μ := by simpa [← aemeasurable_congr h] using hf\n    simp [map_of_not_aemeasurable, hf, hg]\n\n"}
{"name":"MeasureTheory.Measure.map_smul","module":"Mathlib.MeasureTheory.Measure.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nR : Type u_4\ninst✝¹ : SMul R ENNReal\ninst✝ : IsScalarTower R ENNReal ENNReal\nc : R\nμ : MeasureTheory.Measure α\nf : α → β\n⊢ Eq (MeasureTheory.Measure.map f (HSMul.hSMul c μ)) (HSMul.hSMul c (MeasureTheory.Measure.map f μ))","decl":"@[simp]\nprotected theorem map_smul {R : Type*} [SMul R ℝ≥0∞] [IsScalarTower R ℝ≥0∞ ℝ≥0∞]\n    (c : R) (μ : Measure α) (f : α → β) : (c • μ).map f = c • μ.map f := by\n  suffices ∀ c : ℝ≥0∞, (c • μ).map f = c • μ.map f by simpa using this (c • 1)\n  clear c; intro c\n  rcases eq_or_ne c 0 with (rfl | hc); · simp\n  by_cases hf : AEMeasurable f μ\n  · have hfc : AEMeasurable f (c • μ) :=\n      ⟨hf.mk f, hf.measurable_mk, (ae_smul_measure_iff hc).2 hf.ae_eq_mk⟩\n    simp only [← mapₗ_mk_apply_of_aemeasurable hf, ← mapₗ_mk_apply_of_aemeasurable hfc,\n      LinearMap.map_smulₛₗ, RingHom.id_apply]\n    congr 1\n    apply mapₗ_congr hfc.measurable_mk hf.measurable_mk\n    exact EventuallyEq.trans ((ae_smul_measure_iff hc).1 hfc.ae_eq_mk.symm) hf.ae_eq_mk\n  · have hfc : ¬AEMeasurable f (c • μ) := by\n      intro hfc\n      exact hf ⟨hfc.mk f, hfc.measurable_mk, (ae_smul_measure_iff hc).1 hfc.ae_eq_mk⟩\n    simp [map_of_not_aemeasurable hf, map_of_not_aemeasurable hfc]\n\n\n"}
{"name":"MeasureTheory.Measure.map_smul_nnreal","module":"Mathlib.MeasureTheory.Measure.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nc : NNReal\nμ : MeasureTheory.Measure α\nf : α → β\n⊢ Eq (MeasureTheory.Measure.map f (HSMul.hSMul c μ)) (HSMul.hSMul c (MeasureTheory.Measure.map f μ))","decl":"@[deprecated Measure.map_smul (since := \"2024-11-13\")]\nprotected theorem map_smul_nnreal (c : ℝ≥0) (μ : Measure α) (f : α → β) :\n    (c • μ).map f = c • μ.map f :=\n  μ.map_smul c f\n\n"}
{"name":"MeasureTheory.Measure.map_apply₀","module":"Mathlib.MeasureTheory.Measure.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nf : α → β\nhf : AEMeasurable f μ\ns : Set β\nhs : MeasureTheory.NullMeasurableSet s (MeasureTheory.Measure.map f μ)\n⊢ Eq ((MeasureTheory.Measure.map f μ) s) (μ (Set.preimage f s))","decl":"lemma map_apply₀ {f : α → β} (hf : AEMeasurable f μ) {s : Set β}\n    (hs : NullMeasurableSet s (map f μ)) : μ.map f s = μ (f ⁻¹' s) := by\n  rw [map, dif_pos hf, mapₗ, dif_pos hf.measurable_mk] at hs ⊢\n  rw [liftLinear_apply₀ _ hs, measure_congr (hf.ae_eq_mk.preimage s)]\n  rfl\n\n"}
{"name":"MeasureTheory.Measure.map_apply_of_aemeasurable","module":"Mathlib.MeasureTheory.Measure.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nf : α → β\nhf : AEMeasurable f μ\ns : Set β\nhs : MeasurableSet s\n⊢ Eq ((MeasureTheory.Measure.map f μ) s) (μ (Set.preimage f s))","decl":"/-- We can evaluate the pushforward on measurable sets. For non-measurable sets, see\n  `MeasureTheory.Measure.le_map_apply` and `MeasurableEquiv.map_apply`. -/\n@[simp]\ntheorem map_apply_of_aemeasurable (hf : AEMeasurable f μ) {s : Set β} (hs : MeasurableSet s) :\n    μ.map f s = μ (f ⁻¹' s) := map_apply₀ hf hs.nullMeasurableSet\n\n"}
{"name":"MeasureTheory.Measure.map_apply","module":"Mathlib.MeasureTheory.Measure.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nf : α → β\nhf : Measurable f\ns : Set β\nhs : MeasurableSet s\n⊢ Eq ((MeasureTheory.Measure.map f μ) s) (μ (Set.preimage f s))","decl":"@[simp]\ntheorem map_apply (hf : Measurable f) {s : Set β} (hs : MeasurableSet s) :\n    μ.map f s = μ (f ⁻¹' s) :=\n  map_apply_of_aemeasurable hf.aemeasurable hs\n\n"}
{"name":"MeasureTheory.Measure.map_toOuterMeasure","module":"Mathlib.MeasureTheory.Measure.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nf : α → β\nhf : AEMeasurable f μ\n⊢ Eq (MeasureTheory.Measure.map f μ).toOuterMeasure ((MeasureTheory.OuterMeasure.map f) μ.toOuterMeasure).trim","decl":"theorem map_toOuterMeasure (hf : AEMeasurable f μ) :\n    (μ.map f).toOuterMeasure = (OuterMeasure.map f μ.toOuterMeasure).trim := by\n  rw [← trimmed, OuterMeasure.trim_eq_trim_iff]\n  intro s hs\n  simp [hf, hs]\n\n"}
{"name":"MeasureTheory.Measure.map_eq_zero_iff","module":"Mathlib.MeasureTheory.Measure.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nf : α → β\nhf : AEMeasurable f μ\n⊢ Iff (Eq (MeasureTheory.Measure.map f μ) 0) (Eq μ 0)","decl":"@[simp] lemma map_eq_zero_iff (hf : AEMeasurable f μ) : μ.map f = 0 ↔ μ = 0 := by\n  simp_rw [← measure_univ_eq_zero, map_apply_of_aemeasurable hf .univ, preimage_univ]\n\n"}
{"name":"MeasureTheory.Measure.mapₗ_eq_zero_iff","module":"Mathlib.MeasureTheory.Measure.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nf : α → β\nhf : Measurable f\n⊢ Iff (Eq ((MeasureTheory.Measure.mapₗ f) μ) 0) (Eq μ 0)","decl":"@[simp] lemma mapₗ_eq_zero_iff (hf : Measurable f) : Measure.mapₗ f μ = 0 ↔ μ = 0 := by\n  rw [mapₗ_apply_of_measurable hf, map_eq_zero_iff hf.aemeasurable]\n\n"}
{"name":"MeasureTheory.Measure.measure_preimage_of_map_eq_self","module":"Mathlib.MeasureTheory.Measure.Map","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → α\nhf : Eq (MeasureTheory.Measure.map f μ) μ\ns : Set α\nhs : MeasureTheory.NullMeasurableSet s μ\n⊢ Eq (μ (Set.preimage f s)) (μ s)","decl":"/-- If `map f μ = μ`, then the measure of the preimage of any null measurable set `s`\nis equal to the measure of `s`.\nNote that this lemma does not assume (a.e.) measurability of `f`. -/\nlemma measure_preimage_of_map_eq_self {f : α → α} (hf : map f μ = μ)\n    {s : Set α} (hs : NullMeasurableSet s μ) : μ (f ⁻¹' s) = μ s := by\n  if hfm : AEMeasurable f μ then\n    rw [← map_apply₀ hfm, hf]\n    rwa [hf]\n  else\n    rw [map_of_not_aemeasurable hfm] at hf\n    simp [← hf]\n\n"}
{"name":"MeasureTheory.Measure.map_ne_zero_iff","module":"Mathlib.MeasureTheory.Measure.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nf : α → β\nhf : AEMeasurable f μ\n⊢ Iff (Ne (MeasureTheory.Measure.map f μ) 0) (Ne μ 0)","decl":"lemma map_ne_zero_iff (hf : AEMeasurable f μ) : μ.map f ≠ 0 ↔ μ ≠ 0 := (map_eq_zero_iff hf).not\n"}
{"name":"MeasureTheory.Measure.mapₗ_ne_zero_iff","module":"Mathlib.MeasureTheory.Measure.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nf : α → β\nhf : Measurable f\n⊢ Iff (Ne ((MeasureTheory.Measure.mapₗ f) μ) 0) (Ne μ 0)","decl":"lemma mapₗ_ne_zero_iff (hf : Measurable f) : Measure.mapₗ f μ ≠ 0 ↔ μ ≠ 0 :=\n  (mapₗ_eq_zero_iff hf).not\n\n"}
{"name":"MeasureTheory.Measure.map_id","module":"Mathlib.MeasureTheory.Measure.Map","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\n⊢ Eq (MeasureTheory.Measure.map id μ) μ","decl":"@[simp]\ntheorem map_id : map id μ = μ :=\n  ext fun _ => map_apply measurable_id\n\n"}
{"name":"MeasureTheory.Measure.map_id'","module":"Mathlib.MeasureTheory.Measure.Map","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\n⊢ Eq (MeasureTheory.Measure.map (fun x => x) μ) μ","decl":"@[simp]\ntheorem map_id' : map (fun x => x) μ = μ :=\n  map_id\n\n"}
{"name":"MeasureTheory.Measure.map_map","module":"Mathlib.MeasureTheory.Measure.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nmγ : MeasurableSpace γ\nμ : MeasureTheory.Measure α\ng : β → γ\nf : α → β\nhg : Measurable g\nhf : Measurable f\n⊢ Eq (MeasureTheory.Measure.map g (MeasureTheory.Measure.map f μ)) (MeasureTheory.Measure.map (Function.comp g f) μ)","decl":"/-- Mapping a measure twice is the same as mapping the measure with the composition. This version is\nfor measurable functions. See `map_map_of_aemeasurable` when they are just ae measurable. -/\ntheorem map_map {g : β → γ} {f : α → β} (hg : Measurable g) (hf : Measurable f) :\n    (μ.map f).map g = μ.map (g ∘ f) :=\n  ext fun s hs => by simp [hf, hg, hs, hg hs, hg.comp hf, ← preimage_comp]\n\n"}
{"name":"MeasureTheory.Measure.map_mono","module":"Mathlib.MeasureTheory.Measure.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ ν : MeasureTheory.Measure α\nf : α → β\nh : LE.le μ ν\nhf : Measurable f\n⊢ LE.le (MeasureTheory.Measure.map f μ) (MeasureTheory.Measure.map f ν)","decl":"@[mono]\ntheorem map_mono {f : α → β} (h : μ ≤ ν) (hf : Measurable f) : μ.map f ≤ ν.map f :=\n  le_iff.2 fun s hs ↦ by simp [hf.aemeasurable, hs, h _]\n\n"}
{"name":"MeasureTheory.Measure.le_map_apply","module":"Mathlib.MeasureTheory.Measure.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nf : α → β\nhf : AEMeasurable f μ\ns : Set β\n⊢ LE.le (μ (Set.preimage f s)) ((MeasureTheory.Measure.map f μ) s)","decl":"/-- Even if `s` is not measurable, we can bound `map f μ s` from below.\n  See also `MeasurableEquiv.map_apply`. -/\ntheorem le_map_apply {f : α → β} (hf : AEMeasurable f μ) (s : Set β) : μ (f ⁻¹' s) ≤ μ.map f s :=\n  calc\n    μ (f ⁻¹' s) ≤ μ (f ⁻¹' toMeasurable (μ.map f) s) := by gcongr; apply subset_toMeasurable\n    _ = μ.map f (toMeasurable (μ.map f) s) :=\n      (map_apply_of_aemeasurable hf <| measurableSet_toMeasurable _ _).symm\n    _ = μ.map f s := measure_toMeasurable _\n\n"}
{"name":"MeasureTheory.Measure.le_map_apply_image","module":"Mathlib.MeasureTheory.Measure.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nf : α → β\nhf : AEMeasurable f μ\ns : Set α\n⊢ LE.le (μ s) ((MeasureTheory.Measure.map f μ) (Set.image f s))","decl":"theorem le_map_apply_image {f : α → β} (hf : AEMeasurable f μ) (s : Set α) :\n    μ s ≤ μ.map f (f '' s) :=\n  (measure_mono (subset_preimage_image f s)).trans (le_map_apply hf _)\n\n"}
{"name":"MeasureTheory.Measure.preimage_null_of_map_null","module":"Mathlib.MeasureTheory.Measure.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nf : α → β\nhf : AEMeasurable f μ\ns : Set β\nhs : Eq ((MeasureTheory.Measure.map f μ) s) 0\n⊢ Eq (μ (Set.preimage f s)) 0","decl":"/-- Even if `s` is not measurable, `map f μ s = 0` implies that `μ (f ⁻¹' s) = 0`. -/\ntheorem preimage_null_of_map_null {f : α → β} (hf : AEMeasurable f μ) {s : Set β}\n    (hs : μ.map f s = 0) : μ (f ⁻¹' s) = 0 :=\n  nonpos_iff_eq_zero.mp <| (le_map_apply hf s).trans_eq hs\n\n"}
{"name":"MeasureTheory.Measure.tendsto_ae_map","module":"Mathlib.MeasureTheory.Measure.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nf : α → β\nhf : AEMeasurable f μ\n⊢ Filter.Tendsto f (MeasureTheory.ae μ) (MeasureTheory.ae (MeasureTheory.Measure.map f μ))","decl":"theorem tendsto_ae_map {f : α → β} (hf : AEMeasurable f μ) : Tendsto f (ae μ) (ae (μ.map f)) :=\n  fun _ hs => preimage_null_of_map_null hf hs\n\n"}
{"name":"MeasureTheory.mem_ae_map_iff","module":"Mathlib.MeasureTheory.Measure.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nf : α → β\nhf : AEMeasurable f μ\ns : Set β\nhs : MeasurableSet s\n⊢ Iff (Membership.mem (MeasureTheory.ae (MeasureTheory.Measure.map f μ)) s) (Membership.mem (MeasureTheory.ae μ) (Set.preimage f s))","decl":"theorem mem_ae_map_iff {f : α → β} (hf : AEMeasurable f μ) {s : Set β} (hs : MeasurableSet s) :\n    s ∈ ae (μ.map f) ↔ f ⁻¹' s ∈ ae μ := by\n  simp only [mem_ae_iff, map_apply_of_aemeasurable hf hs.compl, preimage_compl]\n\n"}
{"name":"MeasureTheory.mem_ae_of_mem_ae_map","module":"Mathlib.MeasureTheory.Measure.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nf : α → β\nhf : AEMeasurable f μ\ns : Set β\nhs : Membership.mem (MeasureTheory.ae (MeasureTheory.Measure.map f μ)) s\n⊢ Membership.mem (MeasureTheory.ae μ) (Set.preimage f s)","decl":"theorem mem_ae_of_mem_ae_map {f : α → β} (hf : AEMeasurable f μ) {s : Set β}\n    (hs : s ∈ ae (μ.map f)) : f ⁻¹' s ∈ ae μ :=\n  (tendsto_ae_map hf).eventually hs\n\n"}
{"name":"MeasureTheory.ae_map_iff","module":"Mathlib.MeasureTheory.Measure.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nf : α → β\nhf : AEMeasurable f μ\np : β → Prop\nhp : MeasurableSet (setOf fun x => p x)\n⊢ Iff (Filter.Eventually (fun y => p y) (MeasureTheory.ae (MeasureTheory.Measure.map f μ))) (Filter.Eventually (fun x => p (f x)) (MeasureTheory.ae μ))","decl":"theorem ae_map_iff {f : α → β} (hf : AEMeasurable f μ) {p : β → Prop}\n    (hp : MeasurableSet { x | p x }) : (∀ᵐ y ∂μ.map f, p y) ↔ ∀ᵐ x ∂μ, p (f x) :=\n  mem_ae_map_iff hf hp\n\n"}
{"name":"MeasureTheory.ae_of_ae_map","module":"Mathlib.MeasureTheory.Measure.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nf : α → β\nhf : AEMeasurable f μ\np : β → Prop\nh : Filter.Eventually (fun y => p y) (MeasureTheory.ae (MeasureTheory.Measure.map f μ))\n⊢ Filter.Eventually (fun x => p (f x)) (MeasureTheory.ae μ)","decl":"theorem ae_of_ae_map {f : α → β} (hf : AEMeasurable f μ) {p : β → Prop} (h : ∀ᵐ y ∂μ.map f, p y) :\n    ∀ᵐ x ∂μ, p (f x) :=\n  mem_ae_of_mem_ae_map hf h\n\n"}
{"name":"MeasureTheory.ae_map_mem_range","module":"Mathlib.MeasureTheory.Measure.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nmβ : MeasurableSpace β\nm0 : MeasurableSpace α\nf : α → β\nhf : MeasurableSet (Set.range f)\nμ : MeasureTheory.Measure α\n⊢ Filter.Eventually (fun x => Membership.mem (Set.range f) x) (MeasureTheory.ae (MeasureTheory.Measure.map f μ))","decl":"theorem ae_map_mem_range {m0 : MeasurableSpace α} (f : α → β) (hf : MeasurableSet (range f))\n    (μ : Measure α) : ∀ᵐ x ∂μ.map f, x ∈ range f := by\n  by_cases h : AEMeasurable f μ\n  · change range f ∈ ae (μ.map f)\n    rw [mem_ae_map_iff h hf]\n    filter_upwards using mem_range_self\n  · simp [map_of_not_aemeasurable h]\n\n"}
{"name":"MeasurableEmbedding.map_apply","module":"Mathlib.MeasureTheory.Measure.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nm0 : MeasurableSpace α\nm1 : MeasurableSpace β\nf : α → β\nhf : MeasurableEmbedding f\nμ : MeasureTheory.Measure α\ns : Set β\n⊢ Eq ((MeasureTheory.Measure.map f μ) s) (μ (Set.preimage f s))","decl":"nonrec theorem map_apply (hf : MeasurableEmbedding f) (μ : Measure α) (s : Set β) :\n    μ.map f s = μ (f ⁻¹' s) := by\n  refine le_antisymm ?_ (le_map_apply hf.measurable.aemeasurable s)\n  set t := f '' toMeasurable μ (f ⁻¹' s) ∪ (range f)ᶜ\n  have htm : MeasurableSet t :=\n    (hf.measurableSet_image.2 <| measurableSet_toMeasurable _ _).union\n      hf.measurableSet_range.compl\n  have hst : s ⊆ t := by\n    rw [subset_union_compl_iff_inter_subset, ← image_preimage_eq_inter_range]\n    exact image_subset _ (subset_toMeasurable _ _)\n  have hft : f ⁻¹' t = toMeasurable μ (f ⁻¹' s) := by\n    rw [preimage_union, preimage_compl, preimage_range, compl_univ, union_empty,\n      hf.injective.preimage_image]\n  calc\n    μ.map f s ≤ μ.map f t := by gcongr\n    _ = μ (f ⁻¹' s) := by rw [map_apply hf.measurable htm, hft, measure_toMeasurable]\n\n"}
{"name":"MeasurableEquiv.map_apply","module":"Mathlib.MeasureTheory.Measure.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nx✝ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nf : MeasurableEquiv α β\ns : Set β\n⊢ Eq ((MeasureTheory.Measure.map (⇑f) μ) s) (μ (Set.preimage (⇑f) s))","decl":"/-- If we map a measure along a measurable equivalence, we can compute the measure on all sets\n  (not just the measurable ones). -/\nprotected theorem map_apply (f : α ≃ᵐ β) (s : Set β) : μ.map f s = μ (f ⁻¹' s) :=\n  f.measurableEmbedding.map_apply _ _\n\n"}
{"name":"MeasurableEquiv.map_symm_map","module":"Mathlib.MeasureTheory.Measure.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nx✝ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nμ : MeasureTheory.Measure α\ne : MeasurableEquiv α β\n⊢ Eq (MeasureTheory.Measure.map (⇑e.symm) (MeasureTheory.Measure.map (⇑e) μ)) μ","decl":"@[simp]\ntheorem map_symm_map (e : α ≃ᵐ β) : (μ.map e).map e.symm = μ := by\n  simp [map_map e.symm.measurable e.measurable]\n\n"}
{"name":"MeasurableEquiv.map_map_symm","module":"Mathlib.MeasureTheory.Measure.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nx✝ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nν : MeasureTheory.Measure β\ne : MeasurableEquiv α β\n⊢ Eq (MeasureTheory.Measure.map (⇑e) (MeasureTheory.Measure.map (⇑e.symm) ν)) ν","decl":"@[simp]\ntheorem map_map_symm (e : α ≃ᵐ β) : (ν.map e.symm).map e = ν := by\n  simp [map_map e.measurable e.symm.measurable]\n\n"}
{"name":"MeasurableEquiv.map_measurableEquiv_injective","module":"Mathlib.MeasureTheory.Measure.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nx✝ : MeasurableSpace α\ninst✝ : MeasurableSpace β\ne : MeasurableEquiv α β\n⊢ Function.Injective (MeasureTheory.Measure.map ⇑e)","decl":"theorem map_measurableEquiv_injective (e : α ≃ᵐ β) : Injective (Measure.map e) := by\n  intro μ₁ μ₂ hμ\n  apply_fun Measure.map e.symm at hμ\n  simpa [map_symm_map e] using hμ\n\n"}
{"name":"MeasurableEquiv.map_apply_eq_iff_map_symm_apply_eq","module":"Mathlib.MeasureTheory.Measure.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nx✝ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\ne : MeasurableEquiv α β\n⊢ Iff (Eq (MeasureTheory.Measure.map (⇑e) μ) ν) (Eq (MeasureTheory.Measure.map (⇑e.symm) ν) μ)","decl":"theorem map_apply_eq_iff_map_symm_apply_eq (e : α ≃ᵐ β) : μ.map e = ν ↔ ν.map e.symm = μ := by\n  rw [← (map_measurableEquiv_injective e).eq_iff, map_map_symm, eq_comm]\n\n"}
{"name":"MeasurableEquiv.map_ae","module":"Mathlib.MeasureTheory.Measure.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nx✝ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nf : MeasurableEquiv α β\nμ : MeasureTheory.Measure α\n⊢ Eq (Filter.map (⇑f) (MeasureTheory.ae μ)) (MeasureTheory.ae (MeasureTheory.Measure.map (⇑f) μ))","decl":"theorem map_ae (f : α ≃ᵐ β) (μ : Measure α) : Filter.map f (ae μ) = ae (map f μ) := by\n  ext s\n  simp_rw [mem_map, mem_ae_iff, ← preimage_compl, f.map_apply]\n\n"}
