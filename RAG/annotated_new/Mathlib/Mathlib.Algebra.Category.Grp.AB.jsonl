{"name":"instAdditiveFunctorColim","module":"Mathlib.Algebra.Category.Grp.AB","initialProofState":"J : Type u_1\nC : Type u_2\ninst✝³ : CategoryTheory.Category.{u_3, u_1} J\ninst✝² : CategoryTheory.Category.{u_4, u_2} C\ninst✝¹ : CategoryTheory.Limits.HasColimitsOfShape J C\ninst✝ : CategoryTheory.Preadditive C\n⊢ CategoryTheory.Limits.colim.Additive","decl":"instance {J C : Type*} [Category J] [Category C] [HasColimitsOfShape J C] [Preadditive C] :\n    (colim (J := J) (C := C)).Additive where\n\n"}
{"name":"instPreservesHomologyFunctorAddCommGrpColim","module":"Mathlib.Algebra.Category.Grp.AB","initialProofState":"J : Type u\ninst✝ : CategoryTheory.SmallCategory J\n⊢ CategoryTheory.Limits.colim.PreservesHomology","decl":"noncomputable instance :\n    (colim (J := J) (C := AddCommGrp.{u})).PreservesHomology :=\n  Functor.preservesHomology_of_map_exact _ (fun S hS ↦ by\n    replace hS := fun j => hS.map ((evaluation _ _).obj j)\n    simp only [ShortComplex.ab_exact_iff_ker_le_range] at hS ⊢\n    intro x (hx : _ = _)\n    dsimp at hx\n    -- The type ascription around `rfl` works around a `HasForget`/`ConcreteCategory` mismatch,\n    -- and should be removed when `Concrete.colimit_exists_rep` takes `ConcreteCategory`.\n    rcases Concrete.colimit_exists_rep S.X₂ x with ⟨j, y, (rfl : (colimit.ι S.X₂ j) y = _)⟩\n    rw [← ConcreteCategory.comp_apply, colimMap_eq, colimit.ι_map, ConcreteCategory.comp_apply,\n      ← map_zero (colimit.ι S.X₃ j).hom] at hx\n    -- The type ascription around `hk` works around a `HasForget`/`ConcreteCategory` mismatch,\n    -- and should be removed when `Concrete.colimit_exists_rep` takes `ConcreteCategory`.\n    rcases Concrete.colimit_exists_of_rep_eq.{u, u, u} S.X₃ _ _ hx\n      with ⟨k, e₁, e₂, hk : (S.X₃.map e₁) _ = S.X₃.map e₂ 0⟩\n    rw [map_zero, ← ConcreteCategory.comp_apply, ← NatTrans.naturality, ConcreteCategory.comp_apply]\n      at hk\n    rcases hS k hk with ⟨t, ht⟩\n    use colimit.ι S.X₁ k t\n    erw [← ConcreteCategory.comp_apply, colimit.ι_map, ConcreteCategory.comp_apply, ht]\n    exact colimit.w_apply S.X₂ e₁ y)\n\n"}
{"name":"instPreservesFiniteLimitsFunctorAddCommGrpColim","module":"Mathlib.Algebra.Category.Grp.AB","initialProofState":"J : Type u\ninst✝ : CategoryTheory.SmallCategory J\n⊢ CategoryTheory.Limits.PreservesFiniteLimits CategoryTheory.Limits.colim","decl":"noncomputable instance :\n    PreservesFiniteLimits <| colim (J := J) (C := AddCommGrp.{u}) := by\n  apply Functor.preservesFiniteLimits_of_preservesHomology\n\n"}
{"name":"instHasFilteredColimitsAddCommGrp","module":"Mathlib.Algebra.Category.Grp.AB","initialProofState":"⊢ CategoryTheory.Limits.HasFilteredColimits AddCommGrp","decl":"instance : HasFilteredColimits (AddCommGrp.{u}) where\n  HasColimitsOfShape := inferInstance\n\n"}
{"name":"instAB5AddCommGrp","module":"Mathlib.Algebra.Category.Grp.AB","initialProofState":"⊢ CategoryTheory.AB5 AddCommGrp","decl":"noncomputable instance : AB5 (AddCommGrp.{u}) where\n  ofShape _ := { preservesFiniteLimits := inferInstance }\n\n"}
{"name":"instAB4AddCommGrp","module":"Mathlib.Algebra.Category.Grp.AB","initialProofState":"⊢ CategoryTheory.AB4 AddCommGrp","decl":"instance : AB4 AddCommGrp.{u} := AB4.of_AB5 _\n\n"}
{"name":"instHasExactLimitsOfShapeDiscreteAddCommGrp","module":"Mathlib.Algebra.Category.Grp.AB","initialProofState":"J : Type u\n⊢ CategoryTheory.HasExactLimitsOfShape (CategoryTheory.Discrete J) AddCommGrp","decl":"instance : HasExactLimitsOfShape (Discrete J) (AddCommGrp.{u}) := by\n  apply ( config := {allowSynthFailures := true} ) hasExactLimitsOfShape_of_preservesEpi\n  exact {\n    preserves {X Y} f hf := by\n      let iX : limit X ≅ AddCommGrp.of ((i : J) → X.obj ⟨i⟩) := (Pi.isoLimit X).symm ≪≫\n          (limit.isLimit _).conePointUniqueUpToIso (AddCommGrp.HasLimit.productLimitCone _).isLimit\n      let iY : limit Y ≅ AddCommGrp.of ((i : J) → Y.obj ⟨i⟩) := (Pi.isoLimit Y).symm ≪≫\n          (limit.isLimit _).conePointUniqueUpToIso (AddCommGrp.HasLimit.productLimitCone _).isLimit\n      have : Pi.map (fun i ↦ f.app ⟨i⟩) = iX.inv ≫ lim.map f ≫ iY.hom := by\n        simp only [Functor.comp_obj, Discrete.functor_obj_eq_as, Discrete.mk_as, Pi.isoLimit,\n          IsLimit.conePointUniqueUpToIso, limit.cone, AddCommGrp.HasLimit.productLimitCone,\n          Iso.trans_inv, Functor.mapIso_inv, IsLimit.uniqueUpToIso_inv, Cones.forget_map,\n          IsLimit.liftConeMorphism_hom, limit.isLimit_lift, Iso.symm_inv, Functor.mapIso_hom,\n          IsLimit.uniqueUpToIso_hom, lim_obj, lim_map, Iso.trans_hom, Iso.symm_hom,\n          AddCommGrp.HasLimit.lift, Functor.const_obj_obj, Category.assoc, limit.lift_map_assoc,\n          Pi.cone_pt, iX, iY]\n        ext g j\n        change _ = (_ ≫ limit.π (Discrete.functor fun j ↦ Y.obj { as := j }) ⟨j⟩) _\n        simp only [Discrete.functor_obj_eq_as, Functor.comp_obj, Discrete.mk_as, productIsProduct',\n          limit.lift_π, Fan.mk_pt, Fan.mk_π_app, Pi.map_apply]\n        change _ = (_ ≫ _ ≫ limit.π Y ⟨j⟩) _\n        simp\n      suffices Epi (iX.hom ≫ (iX.inv ≫ lim.map f ≫ iY.hom) ≫ iY.inv) by simpa using this\n      suffices Epi (iX.inv ≫ lim.map f ≫ iY.hom) from inferInstance\n      rw [AddCommGrp.epi_iff_surjective, ← this]\n      simp_rw [CategoryTheory.NatTrans.epi_iff_epi_app, AddCommGrp.epi_iff_surjective] at hf\n      refine fun b ↦ ⟨fun i ↦ (hf ⟨i⟩ (b i)).choose, ?_⟩\n      funext i\n      exact (hf ⟨i⟩ (b i)).choose_spec }\n\n"}
{"name":"instAB4StarAddCommGrp","module":"Mathlib.Algebra.Category.Grp.AB","initialProofState":"⊢ CategoryTheory.AB4Star AddCommGrp","decl":"instance : AB4Star AddCommGrp.{u} where\n  ofShape _ := inferInstance\n"}
