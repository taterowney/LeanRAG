{"name":"Polynomial.eval₂_mul'","module":"Mathlib.Algebra.Polynomial.Eval.Algebra","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nx : S\np q : Polynomial R\n⊢ Eq (Polynomial.eval₂ (algebraMap R S) x (HMul.hMul p q)) (HMul.hMul (Polynomial.eval₂ (algebraMap R S) x p) (Polynomial.eval₂ (algebraMap R S) x q))","decl":"@[simp]\ntheorem eval₂_mul' :\n    (p * q).eval₂ (algebraMap R S) x = p.eval₂ (algebraMap R S) x * q.eval₂ (algebraMap R S) x := by\n  exact eval₂_mul_noncomm _ _ fun k => Algebra.commute_algebraMap_left (coeff q k) x\n\n"}
{"name":"Polynomial.eval₂_pow'","module":"Mathlib.Algebra.Polynomial.Eval.Algebra","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nx : S\np : Polynomial R\nn : Nat\n⊢ Eq (Polynomial.eval₂ (algebraMap R S) x (HPow.hPow p n)) (HPow.hPow (Polynomial.eval₂ (algebraMap R S) x p) n)","decl":"@[simp]\ntheorem eval₂_pow' (n : ℕ) :\n    (p ^ n).eval₂ (algebraMap R S) x = (p.eval₂ (algebraMap R S) x) ^ n := by\n  induction n with\n  | zero => simp only [pow_zero, eval₂_one]\n  | succ n ih => rw [pow_succ, pow_succ, eval₂_mul', ih]\n\n"}
{"name":"Polynomial.eval₂_comp'","module":"Mathlib.Algebra.Polynomial.Eval.Algebra","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nx : S\np q : Polynomial R\n⊢ Eq (Polynomial.eval₂ (algebraMap R S) x (p.comp q)) (Polynomial.eval₂ (algebraMap R S) (Polynomial.eval₂ (algebraMap R S) x q) p)","decl":"@[simp]\ntheorem eval₂_comp' : eval₂ (algebraMap R S) x (p.comp q) =\n    eval₂ (algebraMap R S) (eval₂ (algebraMap R S) x q) p := by\n  induction p using Polynomial.induction_on' with\n  | h_add r s hr hs => simp only [add_comp, eval₂_add, hr, hs]\n  | h_monomial n a => simp only [monomial_comp, eval₂_mul', eval₂_C, eval₂_monomial, eval₂_pow']\n\n"}
