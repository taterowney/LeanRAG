{"name":"ULift.zero_down","module":"Mathlib.Algebra.Group.ULift","initialProofState":"α : Type u\ninst✝ : Zero α\n⊢ Eq (ULift.down 0) 0","decl":"@[to_additive (attr := simp)]\ntheorem one_down [One α] : (1 : ULift α).down = 1 :=\n  rfl\n\n"}
{"name":"ULift.one_down","module":"Mathlib.Algebra.Group.ULift","initialProofState":"α : Type u\ninst✝ : One α\n⊢ Eq (ULift.down 1) 1","decl":"@[to_additive (attr := simp)]\ntheorem one_down [One α] : (1 : ULift α).down = 1 :=\n  rfl\n\n"}
{"name":"ULift.add_down","module":"Mathlib.Algebra.Group.ULift","initialProofState":"α : Type u\nx y : ULift.{v, u} α\ninst✝ : Add α\n⊢ Eq (HAdd.hAdd x y).down (HAdd.hAdd x.down y.down)","decl":"@[to_additive (attr := simp)]\ntheorem mul_down [Mul α] : (x * y).down = x.down * y.down :=\n  rfl\n\n"}
{"name":"ULift.mul_down","module":"Mathlib.Algebra.Group.ULift","initialProofState":"α : Type u\nx y : ULift.{v, u} α\ninst✝ : Mul α\n⊢ Eq (HMul.hMul x y).down (HMul.hMul x.down y.down)","decl":"@[to_additive (attr := simp)]\ntheorem mul_down [Mul α] : (x * y).down = x.down * y.down :=\n  rfl\n\n"}
{"name":"ULift.div_down","module":"Mathlib.Algebra.Group.ULift","initialProofState":"α : Type u\nx y : ULift.{v, u} α\ninst✝ : Div α\n⊢ Eq (HDiv.hDiv x y).down (HDiv.hDiv x.down y.down)","decl":"@[to_additive (attr := simp)]\ntheorem div_down [Div α] : (x / y).down = x.down / y.down :=\n  rfl\n\n"}
{"name":"ULift.sub_down","module":"Mathlib.Algebra.Group.ULift","initialProofState":"α : Type u\nx y : ULift.{v, u} α\ninst✝ : Sub α\n⊢ Eq (HSub.hSub x y).down (HSub.hSub x.down y.down)","decl":"@[to_additive (attr := simp)]\ntheorem div_down [Div α] : (x / y).down = x.down / y.down :=\n  rfl\n\n"}
{"name":"ULift.inv_down","module":"Mathlib.Algebra.Group.ULift","initialProofState":"α : Type u\nx : ULift.{v, u} α\ninst✝ : Inv α\n⊢ Eq (Inv.inv x).down (Inv.inv x.down)","decl":"@[to_additive (attr := simp)]\ntheorem inv_down [Inv α] : x⁻¹.down = x.down⁻¹ :=\n  rfl\n\n"}
{"name":"ULift.neg_down","module":"Mathlib.Algebra.Group.ULift","initialProofState":"α : Type u\nx : ULift.{v, u} α\ninst✝ : Neg α\n⊢ Eq (Neg.neg x).down (Neg.neg x.down)","decl":"@[to_additive (attr := simp)]\ntheorem inv_down [Inv α] : x⁻¹.down = x.down⁻¹ :=\n  rfl\n\n"}
{"name":"ULift.smul_down","module":"Mathlib.Algebra.Group.ULift","initialProofState":"α : Type u\nβ : Type u_1\ninst✝ : SMul α β\na : α\nb : ULift.{v, u_1} β\n⊢ Eq (HSMul.hSMul a b).down (HSMul.hSMul a b.down)","decl":"@[to_additive (attr := simp)]\ntheorem smul_down [SMul α β] (a : α) (b : ULift.{v} β) : (a • b).down = a • b.down :=\n  rfl\n\n"}
{"name":"ULift.vadd_down","module":"Mathlib.Algebra.Group.ULift","initialProofState":"α : Type u\nβ : Type u_1\ninst✝ : VAdd α β\na : α\nb : ULift.{v, u_1} β\n⊢ Eq (HVAdd.hVAdd a b).down (HVAdd.hVAdd a b.down)","decl":"@[to_additive (attr := simp)]\ntheorem smul_down [SMul α β] (a : α) (b : ULift.{v} β) : (a • b).down = a • b.down :=\n  rfl\n\n"}
{"name":"ULift.pow_down","module":"Mathlib.Algebra.Group.ULift","initialProofState":"α : Type u\nβ : Type u_1\ninst✝ : Pow α β\na : ULift.{v, u} α\nb : β\n⊢ Eq (HPow.hPow a b).down (HPow.hPow a.down b)","decl":"@[to_additive existing (attr := simp) (reorder := 1 2) smul_down]\ntheorem pow_down [Pow α β] (a : ULift.{v} α) (b : β) : (a ^ b).down = a.down ^ b :=\n  rfl\n\n"}
{"name":"ULift.up_natCast","module":"Mathlib.Algebra.Group.ULift","initialProofState":"α : Type u\ninst✝ : NatCast α\nn : Nat\n⊢ Eq { down := ↑n } ↑n","decl":"@[simp, norm_cast]\ntheorem up_natCast [NatCast α] (n : ℕ) : up (n : α) = n :=\n  rfl\n\n"}
{"name":"ULift.up_ofNat","module":"Mathlib.Algebra.Group.ULift","initialProofState":"α : Type u\ninst✝¹ : NatCast α\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq { down := OfNat.ofNat n } (OfNat.ofNat n)","decl":"@[simp]\ntheorem up_ofNat [NatCast α] (n : ℕ) [n.AtLeastTwo] :\n    up (ofNat(n) : α) = ofNat(n) :=\n  rfl\n\n"}
{"name":"ULift.up_intCast","module":"Mathlib.Algebra.Group.ULift","initialProofState":"α : Type u\ninst✝ : IntCast α\nn : Int\n⊢ Eq { down := ↑n } ↑n","decl":"@[simp, norm_cast]\ntheorem up_intCast [IntCast α] (n : ℤ) : up (n : α) = n :=\n  rfl\n\n"}
{"name":"ULift.down_natCast","module":"Mathlib.Algebra.Group.ULift","initialProofState":"α : Type u\ninst✝ : NatCast α\nn : Nat\n⊢ Eq (↑n).down ↑n","decl":"@[simp, norm_cast]\ntheorem down_natCast [NatCast α] (n : ℕ) : down (n : ULift α) = n :=\n  rfl\n\n"}
{"name":"ULift.down_ofNat","module":"Mathlib.Algebra.Group.ULift","initialProofState":"α : Type u\ninst✝¹ : NatCast α\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (OfNat.ofNat n).down (OfNat.ofNat n)","decl":"@[simp]\ntheorem down_ofNat [NatCast α] (n : ℕ) [n.AtLeastTwo] :\n    down (ofNat(n) : ULift α) = ofNat(n) :=\n  rfl\n\n"}
{"name":"ULift.down_intCast","module":"Mathlib.Algebra.Group.ULift","initialProofState":"α : Type u\ninst✝ : IntCast α\nn : Int\n⊢ Eq (↑n).down ↑n","decl":"@[simp, norm_cast]\ntheorem down_intCast [IntCast α] (n : ℤ) : down (n : ULift α) = n :=\n  rfl\n\n"}
{"name":"ULift.nontrivial","module":"Mathlib.Algebra.Group.ULift","initialProofState":"α : Type u\ninst✝ : Nontrivial α\n⊢ Nontrivial (ULift.{u_2, u} α)","decl":"instance nontrivial [Nontrivial α] : Nontrivial (ULift α) :=\n  Equiv.ulift.symm.injective.nontrivial\n\n-- TODO we don't do `OrderedCancelCommMonoid` or `OrderedCommGroup`\n-- We'd need to add instances for `ULift` in `Order.Basic`.\n"}
