{"name":"small_subtype","module":"Mathlib.Logic.Small.Basic","initialProofState":"α : Type v\ninst✝ : Small.{w, v} α\nP : α → Prop\n⊢ Small.{w, v} (Subtype fun x => P x)","decl":"instance small_subtype (α : Type v) [Small.{w} α] (P : α → Prop) : Small.{w} { x // P x } :=\n  small_map (equivShrink α).subtypeEquivOfSubtype'\n\n"}
{"name":"small_of_injective","module":"Mathlib.Logic.Small.Basic","initialProofState":"α : Type v\nβ : Type w\ninst✝ : Small.{u, w} β\nf : α → β\nhf : Function.Injective f\n⊢ Small.{u, v} α","decl":"theorem small_of_injective {α : Type v} {β : Type w} [Small.{u} β] {f : α → β}\n    (hf : Function.Injective f) : Small.{u} α :=\n  small_map (Equiv.ofInjective f hf)\n\n"}
{"name":"small_of_surjective","module":"Mathlib.Logic.Small.Basic","initialProofState":"α : Type v\nβ : Type w\ninst✝ : Small.{u, v} α\nf : α → β\nhf : Function.Surjective f\n⊢ Small.{u, w} β","decl":"theorem small_of_surjective {α : Type v} {β : Type w} [Small.{u} α] {f : α → β}\n    (hf : Function.Surjective f) : Small.{u} β :=\n  small_of_injective (Function.injective_surjInv hf)\n\n"}
{"name":"small_subsingleton","module":"Mathlib.Logic.Small.Basic","initialProofState":"α : Type v\ninst✝ : Subsingleton α\n⊢ Small.{w, v} α","decl":"instance (priority := 100) small_subsingleton (α : Type v) [Subsingleton α] : Small.{w} α := by\n  rcases isEmpty_or_nonempty α with ⟨⟩\n  · apply small_map (Equiv.equivPEmpty α)\n  · apply small_map Equiv.punitOfNonemptyOfSubsingleton\n\n"}
{"name":"small_of_injective_of_exists","module":"Mathlib.Logic.Small.Basic","initialProofState":"α : Type v\nβ : Type w\nγ : Type v'\ninst✝ : Small.{u, v} α\nf : α → γ\ng : β → γ\nhg : Function.Injective g\nh : ∀ (b : β), Exists fun a => Eq (f a) (g b)\n⊢ Small.{u, w} β","decl":"/-- This can be seen as a version of `small_of_surjective` in which the function `f` doesn't\n    actually land in `β` but in some larger type `γ` related to `β` via an injective function `g`.\n    -/\ntheorem small_of_injective_of_exists {α : Type v} {β : Type w} {γ : Type v'} [Small.{u} α]\n    (f : α → γ) {g : β → γ} (hg : Function.Injective g) (h : ∀ b : β, ∃ a : α, f a = g b) :\n    Small.{u} β := by\n  by_cases hβ : Nonempty β\n  · refine small_of_surjective (f := Function.invFun g ∘ f) (fun b => ?_)\n    obtain ⟨a, ha⟩ := h b\n    exact ⟨a, by rw [Function.comp_apply, ha, Function.leftInverse_invFun hg]⟩\n  · simp only [not_nonempty_iff] at hβ\n    infer_instance\n\n"}
{"name":"small_Pi","module":"Mathlib.Logic.Small.Basic","initialProofState":"α : Type u_2\nβ : α → Type u_1\ninst✝¹ : Small.{w, u_2} α\ninst✝ : ∀ (a : α), Small.{w, u_1} (β a)\n⊢ Small.{w, max u_1 u_2} ((a : α) → β a)","decl":"instance small_Pi {α} (β : α → Type*) [Small.{w} α] [∀ a, Small.{w} (β a)] :\n    Small.{w} (∀ a, β a) :=\n  ⟨⟨∀ a' : Shrink α, Shrink (β ((equivShrink α).symm a')),\n      ⟨Equiv.piCongr (equivShrink α) fun a => by simpa using equivShrink (β a)⟩⟩⟩\n\n"}
{"name":"small_prod","module":"Mathlib.Logic.Small.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Small.{w, u_1} α\ninst✝ : Small.{w, u_2} β\n⊢ Small.{w, max u_2 u_1} (Prod α β)","decl":"instance small_prod {α β} [Small.{w} α] [Small.{w} β] : Small.{w} (α × β) :=\n  ⟨⟨Shrink α × Shrink β, ⟨Equiv.prodCongr (equivShrink α) (equivShrink β)⟩⟩⟩\n\n"}
{"name":"small_sum","module":"Mathlib.Logic.Small.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Small.{w, u_1} α\ninst✝ : Small.{w, u_2} β\n⊢ Small.{w, max u_2 u_1} (Sum α β)","decl":"instance small_sum {α β} [Small.{w} α] [Small.{w} β] : Small.{w} (α ⊕ β) :=\n  ⟨⟨Shrink α ⊕ Shrink β, ⟨Equiv.sumCongr (equivShrink α) (equivShrink β)⟩⟩⟩\n\n"}
{"name":"small_set","module":"Mathlib.Logic.Small.Basic","initialProofState":"α : Type u_1\ninst✝ : Small.{w, u_1} α\n⊢ Small.{w, u_1} (Set α)","decl":"instance small_set {α} [Small.{w} α] : Small.{w} (Set α) :=\n  ⟨⟨Set (Shrink α), ⟨Equiv.Set.congr (equivShrink α)⟩⟩⟩\n"}
