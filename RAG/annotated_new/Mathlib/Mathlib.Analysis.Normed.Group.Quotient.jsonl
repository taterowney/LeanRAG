{"name":"AddSubgroup.quotient_norm_eq","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst‚úù : SeminormedAddCommGroup M\nS : AddSubgroup M\nx : HasQuotient.Quotient M S\n‚ä¢ Eq (Norm.norm x) (InfSet.sInf (Set.image Norm.norm (setOf fun m => Eq (‚Üëm) x)))","decl":"theorem AddSubgroup.quotient_norm_eq {S : AddSubgroup M} (x : M ‚ß∏ S) :\n    ‚Äñx‚Äñ = sInf (norm '' { m : M | (m : M ‚ß∏ S) = x }) :=\n  rfl\n\n"}
{"name":"QuotientAddGroup.norm_eq_infDist","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst‚úù : SeminormedAddCommGroup M\nS : AddSubgroup M\nx : HasQuotient.Quotient M S\n‚ä¢ Eq (Norm.norm x) (Metric.infDist 0 (setOf fun m => Eq (‚Üëm) x))","decl":"theorem QuotientAddGroup.norm_eq_infDist {S : AddSubgroup M} (x : M ‚ß∏ S) :\n    ‚Äñx‚Äñ = infDist 0 { m : M | (m : M ‚ß∏ S) = x } := by\n  simp only [AddSubgroup.quotient_norm_eq, infDist_eq_iInf, sInf_image', dist_zero_left]\n\n"}
{"name":"QuotientAddGroup.norm_mk","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst‚úù : SeminormedAddCommGroup M\nS : AddSubgroup M\nx : M\n‚ä¢ Eq (Norm.norm ‚Üëx) (Metric.infDist x ‚ÜëS)","decl":"/-- An alternative definition of the norm on the quotient group: the norm of `((x : M) : M ‚ß∏ S)` is\nequal to the distance from `x` to `S`. -/\ntheorem QuotientAddGroup.norm_mk {S : AddSubgroup M} (x : M) :\n    ‚Äñ(x : M ‚ß∏ S)‚Äñ = infDist x S := by\n  rw [norm_eq_infDist, ‚Üê infDist_image (IsometryEquiv.subLeft x).isometry,\n    IsometryEquiv.subLeft_apply, sub_zero, ‚Üê IsometryEquiv.preimage_symm]\n  congr 1 with y\n  simp only [mem_preimage, IsometryEquiv.subLeft_symm_apply, mem_setOf_eq, QuotientAddGroup.eq,\n    neg_add, neg_neg, neg_add_cancel_right, SetLike.mem_coe]\n\n"}
{"name":"image_norm_nonempty","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst‚úù : SeminormedAddCommGroup M\nS : AddSubgroup M\nx : HasQuotient.Quotient M S\n‚ä¢ (Set.image Norm.norm (setOf fun m => Eq ((QuotientAddGroup.mk' S) m) x)).Nonempty","decl":"theorem image_norm_nonempty {S : AddSubgroup M} (x : M ‚ß∏ S) :\n    (norm '' { m | mk' S m = x }).Nonempty :=\n  .image _ <| Quot.exists_rep x\n\n"}
{"name":"bddBelow_image_norm","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst‚úù : SeminormedAddCommGroup M\ns : Set M\n‚ä¢ BddBelow (Set.image Norm.norm s)","decl":"theorem bddBelow_image_norm (s : Set M) : BddBelow (norm '' s) :=\n  ‚ü®0, forall_mem_image.2 fun _ _ ‚Ü¶ norm_nonneg _‚ü©\n\n"}
{"name":"isGLB_quotient_norm","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst‚úù : SeminormedAddCommGroup M\nS : AddSubgroup M\nx : HasQuotient.Quotient M S\n‚ä¢ IsGLB (Set.image Norm.norm (setOf fun m => Eq ((QuotientAddGroup.mk' S) m) x)) (Norm.norm x)","decl":"theorem isGLB_quotient_norm {S : AddSubgroup M} (x : M ‚ß∏ S) :\n    IsGLB (norm '' { m | mk' S m = x }) (‚Äñx‚Äñ) :=\n  isGLB_csInf (image_norm_nonempty x) (bddBelow_image_norm _)\n\n"}
{"name":"quotient_norm_neg","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst‚úù : SeminormedAddCommGroup M\nS : AddSubgroup M\nx : HasQuotient.Quotient M S\n‚ä¢ Eq (Norm.norm (Neg.neg x)) (Norm.norm x)","decl":"/-- The norm on the quotient satisfies `‚Äñ-x‚Äñ = ‚Äñx‚Äñ`. -/\ntheorem quotient_norm_neg {S : AddSubgroup M} (x : M ‚ß∏ S) : ‚Äñ-x‚Äñ = ‚Äñx‚Äñ := by\n  simp only [AddSubgroup.quotient_norm_eq]\n  congr 1 with r\n  constructor <;> { rintro ‚ü®m, hm, rfl‚ü©; use -m; simpa [neg_eq_iff_eq_neg] using hm }\n\n"}
{"name":"quotient_norm_sub_rev","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst‚úù : SeminormedAddCommGroup M\nS : AddSubgroup M\nx y : HasQuotient.Quotient M S\n‚ä¢ Eq (Norm.norm (HSub.hSub x y)) (Norm.norm (HSub.hSub y x))","decl":"theorem quotient_norm_sub_rev {S : AddSubgroup M} (x y : M ‚ß∏ S) : ‚Äñx - y‚Äñ = ‚Äñy - x‚Äñ := by\n  rw [‚Üê neg_sub, quotient_norm_neg]\n\n"}
{"name":"quotient_norm_mk_le","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst‚úù : SeminormedAddCommGroup M\nS : AddSubgroup M\nm : M\n‚ä¢ LE.le (Norm.norm ((QuotientAddGroup.mk' S) m)) (Norm.norm m)","decl":"/-- The norm of the projection is smaller or equal to the norm of the original element. -/\ntheorem quotient_norm_mk_le (S : AddSubgroup M) (m : M) : ‚Äñmk' S m‚Äñ ‚â§ ‚Äñm‚Äñ :=\n  csInf_le (bddBelow_image_norm _) <| Set.mem_image_of_mem _ rfl\n\n"}
{"name":"quotient_norm_mk_le'","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst‚úù : SeminormedAddCommGroup M\nS : AddSubgroup M\nm : M\n‚ä¢ LE.le (Norm.norm ‚Üëm) (Norm.norm m)","decl":"/-- The norm of the projection is smaller or equal to the norm of the original element. -/\ntheorem quotient_norm_mk_le' (S : AddSubgroup M) (m : M) : ‚Äñ(m : M ‚ß∏ S)‚Äñ ‚â§ ‚Äñm‚Äñ :=\n  quotient_norm_mk_le S m\n\n"}
{"name":"quotient_norm_mk_eq","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst‚úù : SeminormedAddCommGroup M\nS : AddSubgroup M\nm : M\n‚ä¢ Eq (Norm.norm ((QuotientAddGroup.mk' S) m)) (InfSet.sInf (Set.image (fun x => Norm.norm (HAdd.hAdd m x)) ‚ÜëS))","decl":"/-- The norm of the image under the natural morphism to the quotient. -/\ntheorem quotient_norm_mk_eq (S : AddSubgroup M) (m : M) :\n    ‚Äñmk' S m‚Äñ = sInf ((‚Äñm + ¬∑‚Äñ) '' S) := by\n  rw [mk'_apply, norm_mk, sInf_image', ‚Üê infDist_image isometry_neg, image_neg_eq_neg,\n    neg_coe_set (H := S), infDist_eq_iInf]\n  simp only [dist_eq_norm', sub_neg_eq_add, add_comm]\n\n"}
{"name":"quotient_norm_nonneg","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst‚úù : SeminormedAddCommGroup M\nS : AddSubgroup M\nx : HasQuotient.Quotient M S\n‚ä¢ LE.le 0 (Norm.norm x)","decl":"/-- The quotient norm is nonnegative. -/\ntheorem quotient_norm_nonneg (S : AddSubgroup M) (x : M ‚ß∏ S) : 0 ‚â§ ‚Äñx‚Äñ :=\n  Real.sInf_nonneg <| forall_mem_image.2 fun _ _ ‚Ü¶ norm_nonneg _\n\n"}
{"name":"norm_mk_nonneg","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst‚úù : SeminormedAddCommGroup M\nS : AddSubgroup M\nm : M\n‚ä¢ LE.le 0 (Norm.norm ((QuotientAddGroup.mk' S) m))","decl":"/-- The quotient norm is nonnegative. -/\ntheorem norm_mk_nonneg (S : AddSubgroup M) (m : M) : 0 ‚â§ ‚Äñmk' S m‚Äñ :=\n  quotient_norm_nonneg S _\n\n"}
{"name":"quotient_norm_eq_zero_iff","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst‚úù : SeminormedAddCommGroup M\nS : AddSubgroup M\nm : M\n‚ä¢ Iff (Eq (Norm.norm ((QuotientAddGroup.mk' S) m)) 0) (Membership.mem (closure ‚ÜëS) m)","decl":"/-- The norm of the image of `m : M` in the quotient by `S` is zero if and only if `m` belongs\nto the closure of `S`. -/\ntheorem quotient_norm_eq_zero_iff (S : AddSubgroup M) (m : M) :\n    ‚Äñmk' S m‚Äñ = 0 ‚Üî m ‚àà closure (S : Set M) := by\n  rw [mk'_apply, norm_mk, ‚Üê mem_closure_iff_infDist_zero]\n  exact ‚ü®0, S.zero_mem‚ü©\n\n"}
{"name":"QuotientAddGroup.norm_lt_iff","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst‚úù : SeminormedAddCommGroup M\nS : AddSubgroup M\nx : HasQuotient.Quotient M S\nr : Real\n‚ä¢ Iff (LT.lt (Norm.norm x) r) (Exists fun m => And (Eq (‚Üëm) x) (LT.lt (Norm.norm m) r))","decl":"theorem QuotientAddGroup.norm_lt_iff {S : AddSubgroup M} {x : M ‚ß∏ S} {r : ‚Ñù} :\n    ‚Äñx‚Äñ < r ‚Üî ‚àÉ m : M, ‚Üëm = x ‚àß ‚Äñm‚Äñ < r := by\n  rw [isGLB_lt_iff (isGLB_quotient_norm _), exists_mem_image]\n  rfl\n\n"}
{"name":"norm_mk_lt","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst‚úù : SeminormedAddCommGroup M\nS : AddSubgroup M\nx : HasQuotient.Quotient M S\nŒµ : Real\nhŒµ : LT.lt 0 Œµ\n‚ä¢ Exists fun m => And (Eq ((QuotientAddGroup.mk' S) m) x) (LT.lt (Norm.norm m) (HAdd.hAdd (Norm.norm x) Œµ))","decl":"/-- For any `x : M ‚ß∏ S` and any `0 < Œµ`, there is `m : M` such that `mk' S m = x`\nand `‚Äñm‚Äñ < ‚Äñx‚Äñ + Œµ`. -/\ntheorem norm_mk_lt {S : AddSubgroup M} (x : M ‚ß∏ S) {Œµ : ‚Ñù} (hŒµ : 0 < Œµ) :\n    ‚àÉ m : M, mk' S m = x ‚àß ‚Äñm‚Äñ < ‚Äñx‚Äñ + Œµ :=\n  norm_lt_iff.1 <| lt_add_of_pos_right _ hŒµ\n\n"}
{"name":"norm_mk_lt'","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst‚úù : SeminormedAddCommGroup M\nS : AddSubgroup M\nm : M\nŒµ : Real\nhŒµ : LT.lt 0 Œµ\n‚ä¢ Exists fun s => And (Membership.mem S s) (LT.lt (Norm.norm (HAdd.hAdd m s)) (HAdd.hAdd (Norm.norm ((QuotientAddGroup.mk' S) m)) Œµ))","decl":"/-- For any `m : M` and any `0 < Œµ`, there is `s ‚àà S` such that `‚Äñm + s‚Äñ < ‚Äñmk' S m‚Äñ + Œµ`. -/\ntheorem norm_mk_lt' (S : AddSubgroup M) (m : M) {Œµ : ‚Ñù} (hŒµ : 0 < Œµ) :\n    ‚àÉ s ‚àà S, ‚Äñm + s‚Äñ < ‚Äñmk' S m‚Äñ + Œµ := by\n  obtain ‚ü®n : M, hn : mk' S n = mk' S m, hn' : ‚Äñn‚Äñ < ‚Äñmk' S m‚Äñ + Œµ‚ü© :=\n    norm_mk_lt (QuotientAddGroup.mk' S m) hŒµ\n  erw [eq_comm, QuotientAddGroup.eq] at hn\n  use -m + n, hn\n  rwa [add_neg_cancel_left]\n\n"}
{"name":"quotient_norm_add_le","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst‚úù : SeminormedAddCommGroup M\nS : AddSubgroup M\nx y : HasQuotient.Quotient M S\n‚ä¢ LE.le (Norm.norm (HAdd.hAdd x y)) (HAdd.hAdd (Norm.norm x) (Norm.norm y))","decl":"/-- The quotient norm satisfies the triangle inequality. -/\ntheorem quotient_norm_add_le (S : AddSubgroup M) (x y : M ‚ß∏ S) : ‚Äñx + y‚Äñ ‚â§ ‚Äñx‚Äñ + ‚Äñy‚Äñ := by\n  rcases And.intro (mk_surjective x) (mk_surjective y) with ‚ü®‚ü®x, rfl‚ü©, ‚ü®y, rfl‚ü©‚ü©\n  simp only [‚Üê mk'_apply, ‚Üê map_add, quotient_norm_mk_eq, sInf_image']\n  refine le_ciInf_add_ciInf fun a b ‚Ü¶ ?_\n  refine ciInf_le_of_le ‚ü®0, forall_mem_range.2 fun _ ‚Ü¶ norm_nonneg _‚ü© (a + b) ?_\n  exact (congr_arg norm (add_add_add_comm _ _ _ _)).trans_le (norm_add_le _ _)\n\n"}
{"name":"norm_mk_zero","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst‚úù : SeminormedAddCommGroup M\nS : AddSubgroup M\n‚ä¢ Eq (Norm.norm 0) 0","decl":"/-- The quotient norm of `0` is `0`. -/\ntheorem norm_mk_zero (S : AddSubgroup M) : ‚Äñ(0 : M ‚ß∏ S)‚Äñ = 0 := by\n  erw [quotient_norm_eq_zero_iff]\n  exact subset_closure S.zero_mem\n\n"}
{"name":"norm_mk_eq_zero","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst‚úù : SeminormedAddCommGroup M\nS : AddSubgroup M\nhS : IsClosed ‚ÜëS\nm : M\nh : Eq (Norm.norm ((QuotientAddGroup.mk' S) m)) 0\n‚ä¢ Membership.mem S m","decl":"/-- If `(m : M)` has norm equal to `0` in `M ‚ß∏ S` for a closed subgroup `S` of `M`, then\n`m ‚àà S`. -/\ntheorem norm_mk_eq_zero (S : AddSubgroup M) (hS : IsClosed (S : Set M)) (m : M)\n    (h : ‚Äñmk' S m‚Äñ = 0) : m ‚àà S := by rwa [quotient_norm_eq_zero_iff, hS.closure_eq] at h\n\n"}
{"name":"quotient_nhd_basis","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst‚úù : SeminormedAddCommGroup M\nS : AddSubgroup M\n‚ä¢ (nhds 0).HasBasis (fun Œµ => LT.lt 0 Œµ) fun Œµ => setOf fun x => LT.lt (Norm.norm x) Œµ","decl":"theorem quotient_nhd_basis (S : AddSubgroup M) :\n    (ùìù (0 : M ‚ß∏ S)).HasBasis (fun Œµ ‚Ü¶ 0 < Œµ) fun Œµ ‚Ü¶ { x | ‚Äñx‚Äñ < Œµ } := by\n  have : ‚àÄ Œµ : ‚Ñù, mk '' ball (0 : M) Œµ = { x : M ‚ß∏ S | ‚Äñx‚Äñ < Œµ } := by\n    refine fun Œµ ‚Ü¶ Set.ext <| forall_mk.2 fun x ‚Ü¶ ?_\n    rw [ball_zero_eq, mem_setOf_eq, norm_lt_iff, mem_image]\n    exact exists_congr fun _ ‚Ü¶ and_comm\n  rw [‚Üê QuotientAddGroup.mk_zero, nhds_eq, ‚Üê funext this]\n  exact .map _ Metric.nhds_basis_ball\n\n"}
{"name":"AddSubgroup.normedMk.apply","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst‚úù : SeminormedAddCommGroup M\nS : AddSubgroup M\nm : M\n‚ä¢ Eq (S.normedMk m) ((QuotientAddGroup.mk' S) m)","decl":"/-- `S.normedMk` agrees with `QuotientAddGroup.mk' S`. -/\n@[simp]\ntheorem normedMk.apply (S : AddSubgroup M) (m : M) : normedMk S m = QuotientAddGroup.mk' S m :=\n  rfl\n\n"}
{"name":"AddSubgroup.surjective_normedMk","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst‚úù : SeminormedAddCommGroup M\nS : AddSubgroup M\n‚ä¢ Function.Surjective ‚áëS.normedMk","decl":"/-- `S.normedMk` is surjective. -/\ntheorem surjective_normedMk (S : AddSubgroup M) : Function.Surjective (normedMk S) :=\n  Quot.mk_surjective\n\n"}
{"name":"AddSubgroup.ker_normedMk","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst‚úù : SeminormedAddCommGroup M\nS : AddSubgroup M\n‚ä¢ Eq S.normedMk.ker S","decl":"/-- The kernel of `S.normedMk` is `S`. -/\ntheorem ker_normedMk (S : AddSubgroup M) : S.normedMk.ker = S :=\n  QuotientAddGroup.ker_mk' _\n\n"}
{"name":"AddSubgroup.norm_normedMk_le","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst‚úù : SeminormedAddCommGroup M\nS : AddSubgroup M\n‚ä¢ LE.le (Norm.norm S.normedMk) 1","decl":"/-- The operator norm of the projection is at most `1`. -/\ntheorem norm_normedMk_le (S : AddSubgroup M) : ‚ÄñS.normedMk‚Äñ ‚â§ 1 :=\n  NormedAddGroupHom.opNorm_le_bound _ zero_le_one fun m => by simp [quotient_norm_mk_le']\n\n"}
{"name":"QuotientAddGroup.norm_lift_apply_le","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\nN : Type u_2\ninst‚úù¬π : SeminormedAddCommGroup M\ninst‚úù : SeminormedAddCommGroup N\nS : AddSubgroup M\nf : NormedAddGroupHom M N\nhf : ‚àÄ (x : M), Membership.mem S x ‚Üí Eq (f x) 0\nx : HasQuotient.Quotient M S\n‚ä¢ LE.le (Norm.norm ((QuotientAddGroup.lift S f.toAddMonoidHom hf) x)) (HMul.hMul (Norm.norm f) (Norm.norm x))","decl":"theorem _root_.QuotientAddGroup.norm_lift_apply_le {S : AddSubgroup M} (f : NormedAddGroupHom M N)\n    (hf : ‚àÄ x ‚àà S, f x = 0) (x : M ‚ß∏ S) : ‚Äñlift S f.toAddMonoidHom hf x‚Äñ ‚â§ ‚Äñf‚Äñ * ‚Äñx‚Äñ := by\n  cases (norm_nonneg f).eq_or_gt with\n  | inl h =>\n    rcases mk_surjective x with ‚ü®x, rfl‚ü©\n    simpa [h] using le_opNorm f x\n  | inr h =>\n    rw [‚Üê not_lt, ‚Üê lt_div_iff‚ÇÄ' h, norm_lt_iff]\n    rintro ‚ü®x, rfl, hx‚ü©\n    exact ((lt_div_iff‚ÇÄ' h).1 hx).not_le (le_opNorm f x)\n\n"}
{"name":"AddSubgroup.norm_normedMk","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst‚úù : SeminormedAddCommGroup M\nS : AddSubgroup M\nh : Ne (‚ÜëS.topologicalClosure) Set.univ\n‚ä¢ Eq (Norm.norm S.normedMk) 1","decl":"/-- The operator norm of the projection is `1` if the subspace is not dense. -/\ntheorem norm_normedMk (S : AddSubgroup M) (h : (S.topologicalClosure : Set M) ‚â† univ) :\n    ‚ÄñS.normedMk‚Äñ = 1 := by\n  refine le_antisymm (norm_normedMk_le S) ?_\n  obtain ‚ü®x, hx‚ü© : ‚àÉ x : M, 0 < ‚Äñ(x : M ‚ß∏ S)‚Äñ := by\n    refine (Set.nonempty_compl.2 h).imp fun x hx ‚Ü¶ ?_\n    exact (norm_nonneg _).lt_of_ne' <| mt (quotient_norm_eq_zero_iff S x).1 hx\n  refine (le_mul_iff_one_le_left hx).1 ?_\n  exact norm_lift_apply_le S.normedMk (fun x ‚Ü¶ (eq_zero_iff x).2) x\n\n"}
{"name":"AddSubgroup.norm_trivial_quotient_mk","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst‚úù : SeminormedAddCommGroup M\nS : AddSubgroup M\nh : Eq (‚ÜëS.topologicalClosure) Set.univ\n‚ä¢ Eq (Norm.norm S.normedMk) 0","decl":"/-- The operator norm of the projection is `0` if the subspace is dense. -/\ntheorem norm_trivial_quotient_mk (S : AddSubgroup M)\n    (h : (S.topologicalClosure : Set M) = Set.univ) : ‚ÄñS.normedMk‚Äñ = 0 := by\n  refine le_antisymm (opNorm_le_bound _ le_rfl fun x => ?_) (norm_nonneg _)\n  have hker : x ‚àà S.normedMk.ker.topologicalClosure := by\n    rw [S.ker_normedMk, ‚Üê SetLike.mem_coe, h]\n    trivial\n  rw [ker_normedMk] at hker\n  simp only [(quotient_norm_eq_zero_iff S x).mpr hker, normedMk.apply, zero_mul, le_rfl]\n\n"}
{"name":"NormedAddGroupHom.IsQuotient.norm","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\nN : Type u_2\ninst‚úù¬π : SeminormedAddCommGroup M\ninst‚úù : SeminormedAddCommGroup N\nf : NormedAddGroupHom M N\nself : f.IsQuotient\nx : M\n‚ä¢ Eq (Norm.norm (f x)) (InfSet.sInf (Set.image (fun m => Norm.norm (HAdd.hAdd x m)) ‚Üëf.ker))","decl":"/-- `IsQuotient f`, for `f : M ‚ü∂ N` means that `N` is isomorphic to the quotient of `M`\nby the kernel of `f`. -/\nstructure IsQuotient (f : NormedAddGroupHom M N) : Prop where\n  protected surjective : Function.Surjective f\n  protected norm : ‚àÄ x, ‚Äñf x‚Äñ = sInf ((fun m => ‚Äñx + m‚Äñ) '' f.ker)\n\n"}
{"name":"NormedAddGroupHom.IsQuotient.surjective","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\nN : Type u_2\ninst‚úù¬π : SeminormedAddCommGroup M\ninst‚úù : SeminormedAddCommGroup N\nf : NormedAddGroupHom M N\nself : f.IsQuotient\n‚ä¢ Function.Surjective ‚áëf","decl":"/-- `IsQuotient f`, for `f : M ‚ü∂ N` means that `N` is isomorphic to the quotient of `M`\nby the kernel of `f`. -/\nstructure IsQuotient (f : NormedAddGroupHom M N) : Prop where\n  protected surjective : Function.Surjective f\n  protected norm : ‚àÄ x, ‚Äñf x‚Äñ = sInf ((fun m => ‚Äñx + m‚Äñ) '' f.ker)\n\n"}
{"name":"NormedAddGroupHom.lift_mk","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst‚úù¬π : SeminormedAddCommGroup M\nN : Type u_3\ninst‚úù : SeminormedAddCommGroup N\nS : AddSubgroup M\nf : NormedAddGroupHom M N\nhf : ‚àÄ (s : M), Membership.mem S s ‚Üí Eq (f s) 0\nm : M\n‚ä¢ Eq ((NormedAddGroupHom.lift S f hf) (S.normedMk m)) (f m)","decl":"theorem lift_mk {N : Type*} [SeminormedAddCommGroup N] (S : AddSubgroup M)\n    (f : NormedAddGroupHom M N) (hf : ‚àÄ s ‚àà S, f s = 0) (m : M) :\n    lift S f hf (S.normedMk m) = f m :=\n  rfl\n\n"}
{"name":"NormedAddGroupHom.lift_unique","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst‚úù¬π : SeminormedAddCommGroup M\nN : Type u_3\ninst‚úù : SeminormedAddCommGroup N\nS : AddSubgroup M\nf : NormedAddGroupHom M N\nhf : ‚àÄ (s : M), Membership.mem S s ‚Üí Eq (f s) 0\ng : NormedAddGroupHom (HasQuotient.Quotient M S) N\nh : Eq (g.comp S.normedMk) f\n‚ä¢ Eq g (NormedAddGroupHom.lift S f hf)","decl":"theorem lift_unique {N : Type*} [SeminormedAddCommGroup N] (S : AddSubgroup M)\n    (f : NormedAddGroupHom M N) (hf : ‚àÄ s ‚àà S, f s = 0) (g : NormedAddGroupHom (M ‚ß∏ S) N)\n    (h : g.comp S.normedMk = f) : g = lift S f hf := by\n  ext x\n  rcases AddSubgroup.surjective_normedMk _ x with ‚ü®x, rfl‚ü©\n  change g.comp S.normedMk x = _\n  simp only [h]\n  rfl\n\n"}
{"name":"NormedAddGroupHom.isQuotientQuotient","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst‚úù : SeminormedAddCommGroup M\nS : AddSubgroup M\n‚ä¢ S.normedMk.IsQuotient","decl":"/-- `S.normedMk` satisfies `IsQuotient`. -/\ntheorem isQuotientQuotient (S : AddSubgroup M) : IsQuotient S.normedMk :=\n  ‚ü®S.surjective_normedMk, fun m => by simpa [S.ker_normedMk] using quotient_norm_mk_eq _ m‚ü©\n\n"}
{"name":"NormedAddGroupHom.IsQuotient.norm_lift","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\nN : Type u_2\ninst‚úù¬π : SeminormedAddCommGroup M\ninst‚úù : SeminormedAddCommGroup N\nf : NormedAddGroupHom M N\nhquot : f.IsQuotient\nŒµ : Real\nhŒµ : LT.lt 0 Œµ\nn : N\n‚ä¢ Exists fun m => And (Eq (f m) n) (LT.lt (Norm.norm m) (HAdd.hAdd (Norm.norm n) Œµ))","decl":"theorem IsQuotient.norm_lift {f : NormedAddGroupHom M N} (hquot : IsQuotient f) {Œµ : ‚Ñù} (hŒµ : 0 < Œµ)\n    (n : N) : ‚àÉ m : M, f m = n ‚àß ‚Äñm‚Äñ < ‚Äñn‚Äñ + Œµ := by\n  obtain ‚ü®m, rfl‚ü© := hquot.surjective n\n  have nonemp : ((fun m' => ‚Äñm + m'‚Äñ) '' f.ker).Nonempty := by\n    rw [Set.image_nonempty]\n    exact ‚ü®0, f.ker.zero_mem‚ü©\n  rcases Real.lt_sInf_add_pos nonemp hŒµ\n    with ‚ü®_, ‚ü®‚ü®x, hx, rfl‚ü©, H : ‚Äñm + x‚Äñ < sInf ((fun m' : M => ‚Äñm + m'‚Äñ) '' f.ker) + Œµ‚ü©‚ü©\n  exact ‚ü®m + x, by rw [map_add, (NormedAddGroupHom.mem_ker f x).mp hx, add_zero], by\n    rwa [hquot.norm]‚ü©\n\n"}
{"name":"NormedAddGroupHom.IsQuotient.norm_le","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\nN : Type u_2\ninst‚úù¬π : SeminormedAddCommGroup M\ninst‚úù : SeminormedAddCommGroup N\nf : NormedAddGroupHom M N\nhquot : f.IsQuotient\nm : M\n‚ä¢ LE.le (Norm.norm (f m)) (Norm.norm m)","decl":"theorem IsQuotient.norm_le {f : NormedAddGroupHom M N} (hquot : IsQuotient f) (m : M) :\n    ‚Äñf m‚Äñ ‚â§ ‚Äñm‚Äñ := by\n  rw [hquot.norm]\n  apply csInf_le\n  ¬∑ use 0\n    rintro _ ‚ü®m', -, rfl‚ü©\n    apply norm_nonneg\n  ¬∑ exact ‚ü®0, f.ker.zero_mem, by simp‚ü©\n\n"}
{"name":"NormedAddGroupHom.norm_lift_le","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst‚úù¬π : SeminormedAddCommGroup M\nN : Type u_3\ninst‚úù : SeminormedAddCommGroup N\nS : AddSubgroup M\nf : NormedAddGroupHom M N\nhf : ‚àÄ (s : M), Membership.mem S s ‚Üí Eq (f s) 0\n‚ä¢ LE.le (Norm.norm (NormedAddGroupHom.lift S f hf)) (Norm.norm f)","decl":"theorem norm_lift_le {N : Type*} [SeminormedAddCommGroup N] (S : AddSubgroup M)\n    (f : NormedAddGroupHom M N) (hf : ‚àÄ s ‚àà S, f s = 0) :\n    ‚Äñlift S f hf‚Äñ ‚â§ ‚Äñf‚Äñ :=\n  opNorm_le_bound _ (norm_nonneg f) (norm_lift_apply_le f hf)\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: deprecate?\n"}
{"name":"NormedAddGroupHom.lift_norm_le","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst‚úù¬π : SeminormedAddCommGroup M\nN : Type u_3\ninst‚úù : SeminormedAddCommGroup N\nS : AddSubgroup M\nf : NormedAddGroupHom M N\nhf : ‚àÄ (s : M), Membership.mem S s ‚Üí Eq (f s) 0\nc : NNReal\nfb : LE.le (Norm.norm f) ‚Üëc\n‚ä¢ LE.le (Norm.norm (NormedAddGroupHom.lift S f hf)) ‚Üëc","decl":"theorem lift_norm_le {N : Type*} [SeminormedAddCommGroup N] (S : AddSubgroup M)\n    (f : NormedAddGroupHom M N) (hf : ‚àÄ s ‚àà S, f s = 0) {c : ‚Ñù‚â•0} (fb : ‚Äñf‚Äñ ‚â§ c) :\n    ‚Äñlift S f hf‚Äñ ‚â§ c :=\n  (norm_lift_le S f hf).trans fb\n\n"}
{"name":"NormedAddGroupHom.lift_normNoninc","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst‚úù¬π : SeminormedAddCommGroup M\nN : Type u_3\ninst‚úù : SeminormedAddCommGroup N\nS : AddSubgroup M\nf : NormedAddGroupHom M N\nhf : ‚àÄ (s : M), Membership.mem S s ‚Üí Eq (f s) 0\nfb : f.NormNoninc\n‚ä¢ (NormedAddGroupHom.lift S f hf).NormNoninc","decl":"theorem lift_normNoninc {N : Type*} [SeminormedAddCommGroup N] (S : AddSubgroup M)\n    (f : NormedAddGroupHom M N) (hf : ‚àÄ s ‚àà S, f s = 0) (fb : f.NormNoninc) :\n    (lift S f hf).NormNoninc := fun x => by\n  have fb' : ‚Äñf‚Äñ ‚â§ (1 : ‚Ñù‚â•0) := NormNoninc.normNoninc_iff_norm_le_one.mp fb\n  simpa using le_of_opNorm_le _ (f.lift_norm_le _ _ fb') _\n\n"}
{"name":"Submodule.Quotient.completeSpace","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst‚úù¬≥ : SeminormedAddCommGroup M\nR : Type u_3\ninst‚úù¬≤ : Ring R\ninst‚úù¬π : Module R M\nS : Submodule R M\ninst‚úù : CompleteSpace M\n‚ä¢ CompleteSpace (HasQuotient.Quotient M S)","decl":"instance Submodule.Quotient.completeSpace [CompleteSpace M] : CompleteSpace (M ‚ß∏ S) :=\n  QuotientAddGroup.completeSpace M S.toAddSubgroup\n\n"}
{"name":"Submodule.Quotient.norm_mk_lt","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst‚úù¬≤ : SeminormedAddCommGroup M\nR : Type u_3\ninst‚úù¬π : Ring R\ninst‚úù : Module R M\nS : Submodule R M\nx : HasQuotient.Quotient M S\nŒµ : Real\nhŒµ : LT.lt 0 Œµ\n‚ä¢ Exists fun m => And (Eq (Submodule.Quotient.mk m) x) (LT.lt (Norm.norm m) (HAdd.hAdd (Norm.norm x) Œµ))","decl":"/-- For any `x : M ‚ß∏ S` and any `0 < Œµ`, there is `m : M` such that `Submodule.Quotient.mk m = x`\nand `‚Äñm‚Äñ < ‚Äñx‚Äñ + Œµ`. -/\nnonrec theorem Submodule.Quotient.norm_mk_lt {S : Submodule R M} (x : M ‚ß∏ S) {Œµ : ‚Ñù} (hŒµ : 0 < Œµ) :\n    ‚àÉ m : M, Submodule.Quotient.mk m = x ‚àß ‚Äñm‚Äñ < ‚Äñx‚Äñ + Œµ :=\n  norm_mk_lt x hŒµ\n\n"}
{"name":"Submodule.Quotient.norm_mk_le","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst‚úù¬≤ : SeminormedAddCommGroup M\nR : Type u_3\ninst‚úù¬π : Ring R\ninst‚úù : Module R M\nS : Submodule R M\nm : M\n‚ä¢ LE.le (Norm.norm (Submodule.Quotient.mk m)) (Norm.norm m)","decl":"theorem Submodule.Quotient.norm_mk_le (m : M) : ‚Äñ(Submodule.Quotient.mk m : M ‚ß∏ S)‚Äñ ‚â§ ‚Äñm‚Äñ :=\n  quotient_norm_mk_le S.toAddSubgroup m\n\n"}
{"name":"Submodule.Quotient.instBoundedSMul","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst‚úù‚Å∑ : SeminormedAddCommGroup M\nR : Type u_3\ninst‚úù‚Å∂ : Ring R\ninst‚úù‚Åµ : Module R M\nS : Submodule R M\nùïú : Type u_4\ninst‚úù‚Å¥ : SeminormedCommRing ùïú\ninst‚úù¬≥ : Module ùïú M\ninst‚úù¬≤ : BoundedSMul ùïú M\ninst‚úù¬π : SMul ùïú R\ninst‚úù : IsScalarTower ùïú R M\n‚ä¢ BoundedSMul ùïú (HasQuotient.Quotient M S)","decl":"instance Submodule.Quotient.instBoundedSMul (ùïú : Type*)\n    [SeminormedCommRing ùïú] [Module ùïú M] [BoundedSMul ùïú M] [SMul ùïú R] [IsScalarTower ùïú R M] :\n    BoundedSMul ùïú (M ‚ß∏ S) :=\n  .of_norm_smul_le fun k x =>\n    -- Porting note: this is `QuotientAddGroup.norm_lift_apply_le` for `f : M ‚Üí M ‚ß∏ S` given by\n    -- `x ‚Ü¶ mk (k ‚Ä¢ x)`; todo: add scalar multiplication as `NormedAddGroupHom`, use it here\n    _root_.le_of_forall_pos_le_add fun Œµ hŒµ => by\n      have := (nhds_basis_ball.tendsto_iff nhds_basis_ball).mp\n        ((@Real.uniformContinuous_const_mul ‚Äñk‚Äñ).continuous.tendsto ‚Äñx‚Äñ) Œµ hŒµ\n      simp only [mem_ball, exists_prop, dist, abs_sub_lt_iff] at this\n      rcases this with ‚ü®Œ¥, hŒ¥, h‚ü©\n      obtain ‚ü®a, rfl, ha‚ü© := Submodule.Quotient.norm_mk_lt x hŒ¥\n      specialize h ‚Äña‚Äñ ‚ü®by linarith, by linarith [Submodule.Quotient.norm_mk_le S a]‚ü©\n      calc\n        _ ‚â§ ‚Äñk‚Äñ * ‚Äña‚Äñ := (quotient_norm_mk_le S.toAddSubgroup (k ‚Ä¢ a)).trans (norm_smul_le k a)\n        _ ‚â§ _ := (sub_lt_iff_lt_add'.mp h.1).le\n\n"}
{"name":"Ideal.Quotient.norm_mk_lt","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"R : Type u_3\ninst‚úù : SeminormedCommRing R\nI : Ideal R\nx : HasQuotient.Quotient R I\nŒµ : Real\nhŒµ : LT.lt 0 Œµ\n‚ä¢ Exists fun r => And (Eq ((Ideal.Quotient.mk I) r) x) (LT.lt (Norm.norm r) (HAdd.hAdd (Norm.norm x) Œµ))","decl":"nonrec theorem Ideal.Quotient.norm_mk_lt {I : Ideal R} (x : R ‚ß∏ I) {Œµ : ‚Ñù} (hŒµ : 0 < Œµ) :\n    ‚àÉ r : R, Ideal.Quotient.mk I r = x ‚àß ‚Äñr‚Äñ < ‚Äñx‚Äñ + Œµ :=\n  norm_mk_lt x hŒµ\n\n"}
{"name":"Ideal.Quotient.norm_mk_le","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"R : Type u_3\ninst‚úù : SeminormedCommRing R\nI : Ideal R\nr : R\n‚ä¢ LE.le (Norm.norm ((Ideal.Quotient.mk I) r)) (Norm.norm r)","decl":"theorem Ideal.Quotient.norm_mk_le (r : R) : ‚ÄñIdeal.Quotient.mk I r‚Äñ ‚â§ ‚Äñr‚Äñ :=\n  quotient_norm_mk_le I.toAddSubgroup r\n\n"}
