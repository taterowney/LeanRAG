{"name":"AddSubgroup.quotient_norm_eq","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst✝ : SeminormedAddCommGroup M\nS : AddSubgroup M\nx : HasQuotient.Quotient M S\n⊢ Eq (Norm.norm x) (InfSet.sInf (Set.image Norm.norm (setOf fun m => Eq (↑m) x)))","decl":"theorem AddSubgroup.quotient_norm_eq {S : AddSubgroup M} (x : M ⧸ S) :\n    ‖x‖ = sInf (norm '' { m : M | (m : M ⧸ S) = x }) :=\n  rfl\n\n"}
{"name":"QuotientAddGroup.norm_eq_infDist","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst✝ : SeminormedAddCommGroup M\nS : AddSubgroup M\nx : HasQuotient.Quotient M S\n⊢ Eq (Norm.norm x) (Metric.infDist 0 (setOf fun m => Eq (↑m) x))","decl":"theorem QuotientAddGroup.norm_eq_infDist {S : AddSubgroup M} (x : M ⧸ S) :\n    ‖x‖ = infDist 0 { m : M | (m : M ⧸ S) = x } := by\n  simp only [AddSubgroup.quotient_norm_eq, infDist_eq_iInf, sInf_image', dist_zero_left]\n\n"}
{"name":"QuotientAddGroup.norm_mk","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst✝ : SeminormedAddCommGroup M\nS : AddSubgroup M\nx : M\n⊢ Eq (Norm.norm ↑x) (Metric.infDist x ↑S)","decl":"/-- An alternative definition of the norm on the quotient group: the norm of `((x : M) : M ⧸ S)` is\nequal to the distance from `x` to `S`. -/\ntheorem QuotientAddGroup.norm_mk {S : AddSubgroup M} (x : M) :\n    ‖(x : M ⧸ S)‖ = infDist x S := by\n  rw [norm_eq_infDist, ← infDist_image (IsometryEquiv.subLeft x).isometry,\n    IsometryEquiv.subLeft_apply, sub_zero, ← IsometryEquiv.preimage_symm]\n  congr 1 with y\n  simp only [mem_preimage, IsometryEquiv.subLeft_symm_apply, mem_setOf_eq, QuotientAddGroup.eq,\n    neg_add, neg_neg, neg_add_cancel_right, SetLike.mem_coe]\n\n"}
{"name":"image_norm_nonempty","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst✝ : SeminormedAddCommGroup M\nS : AddSubgroup M\nx : HasQuotient.Quotient M S\n⊢ (Set.image Norm.norm (setOf fun m => Eq ((QuotientAddGroup.mk' S) m) x)).Nonempty","decl":"theorem image_norm_nonempty {S : AddSubgroup M} (x : M ⧸ S) :\n    (norm '' { m | mk' S m = x }).Nonempty :=\n  .image _ <| Quot.exists_rep x\n\n"}
{"name":"bddBelow_image_norm","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst✝ : SeminormedAddCommGroup M\ns : Set M\n⊢ BddBelow (Set.image Norm.norm s)","decl":"theorem bddBelow_image_norm (s : Set M) : BddBelow (norm '' s) :=\n  ⟨0, forall_mem_image.2 fun _ _ ↦ norm_nonneg _⟩\n\n"}
{"name":"isGLB_quotient_norm","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst✝ : SeminormedAddCommGroup M\nS : AddSubgroup M\nx : HasQuotient.Quotient M S\n⊢ IsGLB (Set.image Norm.norm (setOf fun m => Eq ((QuotientAddGroup.mk' S) m) x)) (Norm.norm x)","decl":"theorem isGLB_quotient_norm {S : AddSubgroup M} (x : M ⧸ S) :\n    IsGLB (norm '' { m | mk' S m = x }) (‖x‖) :=\n  isGLB_csInf (image_norm_nonempty x) (bddBelow_image_norm _)\n\n"}
{"name":"quotient_norm_neg","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst✝ : SeminormedAddCommGroup M\nS : AddSubgroup M\nx : HasQuotient.Quotient M S\n⊢ Eq (Norm.norm (Neg.neg x)) (Norm.norm x)","decl":"/-- The norm on the quotient satisfies `‖-x‖ = ‖x‖`. -/\ntheorem quotient_norm_neg {S : AddSubgroup M} (x : M ⧸ S) : ‖-x‖ = ‖x‖ := by\n  simp only [AddSubgroup.quotient_norm_eq]\n  congr 1 with r\n  constructor <;> { rintro ⟨m, hm, rfl⟩; use -m; simpa [neg_eq_iff_eq_neg] using hm }\n\n"}
{"name":"quotient_norm_sub_rev","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst✝ : SeminormedAddCommGroup M\nS : AddSubgroup M\nx y : HasQuotient.Quotient M S\n⊢ Eq (Norm.norm (HSub.hSub x y)) (Norm.norm (HSub.hSub y x))","decl":"theorem quotient_norm_sub_rev {S : AddSubgroup M} (x y : M ⧸ S) : ‖x - y‖ = ‖y - x‖ := by\n  rw [← neg_sub, quotient_norm_neg]\n\n"}
{"name":"quotient_norm_mk_le","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst✝ : SeminormedAddCommGroup M\nS : AddSubgroup M\nm : M\n⊢ LE.le (Norm.norm ((QuotientAddGroup.mk' S) m)) (Norm.norm m)","decl":"/-- The norm of the projection is smaller or equal to the norm of the original element. -/\ntheorem quotient_norm_mk_le (S : AddSubgroup M) (m : M) : ‖mk' S m‖ ≤ ‖m‖ :=\n  csInf_le (bddBelow_image_norm _) <| Set.mem_image_of_mem _ rfl\n\n"}
{"name":"quotient_norm_mk_le'","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst✝ : SeminormedAddCommGroup M\nS : AddSubgroup M\nm : M\n⊢ LE.le (Norm.norm ↑m) (Norm.norm m)","decl":"/-- The norm of the projection is smaller or equal to the norm of the original element. -/\ntheorem quotient_norm_mk_le' (S : AddSubgroup M) (m : M) : ‖(m : M ⧸ S)‖ ≤ ‖m‖ :=\n  quotient_norm_mk_le S m\n\n"}
{"name":"quotient_norm_mk_eq","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst✝ : SeminormedAddCommGroup M\nS : AddSubgroup M\nm : M\n⊢ Eq (Norm.norm ((QuotientAddGroup.mk' S) m)) (InfSet.sInf (Set.image (fun x => Norm.norm (HAdd.hAdd m x)) ↑S))","decl":"/-- The norm of the image under the natural morphism to the quotient. -/\ntheorem quotient_norm_mk_eq (S : AddSubgroup M) (m : M) :\n    ‖mk' S m‖ = sInf ((‖m + ·‖) '' S) := by\n  rw [mk'_apply, norm_mk, sInf_image', ← infDist_image isometry_neg, image_neg_eq_neg,\n    neg_coe_set (H := S), infDist_eq_iInf]\n  simp only [dist_eq_norm', sub_neg_eq_add, add_comm]\n\n"}
{"name":"quotient_norm_nonneg","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst✝ : SeminormedAddCommGroup M\nS : AddSubgroup M\nx : HasQuotient.Quotient M S\n⊢ LE.le 0 (Norm.norm x)","decl":"/-- The quotient norm is nonnegative. -/\ntheorem quotient_norm_nonneg (S : AddSubgroup M) (x : M ⧸ S) : 0 ≤ ‖x‖ :=\n  Real.sInf_nonneg <| forall_mem_image.2 fun _ _ ↦ norm_nonneg _\n\n"}
{"name":"norm_mk_nonneg","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst✝ : SeminormedAddCommGroup M\nS : AddSubgroup M\nm : M\n⊢ LE.le 0 (Norm.norm ((QuotientAddGroup.mk' S) m))","decl":"/-- The quotient norm is nonnegative. -/\ntheorem norm_mk_nonneg (S : AddSubgroup M) (m : M) : 0 ≤ ‖mk' S m‖ :=\n  quotient_norm_nonneg S _\n\n"}
{"name":"quotient_norm_eq_zero_iff","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst✝ : SeminormedAddCommGroup M\nS : AddSubgroup M\nm : M\n⊢ Iff (Eq (Norm.norm ((QuotientAddGroup.mk' S) m)) 0) (Membership.mem (closure ↑S) m)","decl":"/-- The norm of the image of `m : M` in the quotient by `S` is zero if and only if `m` belongs\nto the closure of `S`. -/\ntheorem quotient_norm_eq_zero_iff (S : AddSubgroup M) (m : M) :\n    ‖mk' S m‖ = 0 ↔ m ∈ closure (S : Set M) := by\n  rw [mk'_apply, norm_mk, ← mem_closure_iff_infDist_zero]\n  exact ⟨0, S.zero_mem⟩\n\n"}
{"name":"QuotientAddGroup.norm_lt_iff","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst✝ : SeminormedAddCommGroup M\nS : AddSubgroup M\nx : HasQuotient.Quotient M S\nr : Real\n⊢ Iff (LT.lt (Norm.norm x) r) (Exists fun m => And (Eq (↑m) x) (LT.lt (Norm.norm m) r))","decl":"theorem QuotientAddGroup.norm_lt_iff {S : AddSubgroup M} {x : M ⧸ S} {r : ℝ} :\n    ‖x‖ < r ↔ ∃ m : M, ↑m = x ∧ ‖m‖ < r := by\n  rw [isGLB_lt_iff (isGLB_quotient_norm _), exists_mem_image]\n  rfl\n\n"}
{"name":"norm_mk_lt","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst✝ : SeminormedAddCommGroup M\nS : AddSubgroup M\nx : HasQuotient.Quotient M S\nε : Real\nhε : LT.lt 0 ε\n⊢ Exists fun m => And (Eq ((QuotientAddGroup.mk' S) m) x) (LT.lt (Norm.norm m) (HAdd.hAdd (Norm.norm x) ε))","decl":"/-- For any `x : M ⧸ S` and any `0 < ε`, there is `m : M` such that `mk' S m = x`\nand `‖m‖ < ‖x‖ + ε`. -/\ntheorem norm_mk_lt {S : AddSubgroup M} (x : M ⧸ S) {ε : ℝ} (hε : 0 < ε) :\n    ∃ m : M, mk' S m = x ∧ ‖m‖ < ‖x‖ + ε :=\n  norm_lt_iff.1 <| lt_add_of_pos_right _ hε\n\n"}
{"name":"norm_mk_lt'","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst✝ : SeminormedAddCommGroup M\nS : AddSubgroup M\nm : M\nε : Real\nhε : LT.lt 0 ε\n⊢ Exists fun s => And (Membership.mem S s) (LT.lt (Norm.norm (HAdd.hAdd m s)) (HAdd.hAdd (Norm.norm ((QuotientAddGroup.mk' S) m)) ε))","decl":"/-- For any `m : M` and any `0 < ε`, there is `s ∈ S` such that `‖m + s‖ < ‖mk' S m‖ + ε`. -/\ntheorem norm_mk_lt' (S : AddSubgroup M) (m : M) {ε : ℝ} (hε : 0 < ε) :\n    ∃ s ∈ S, ‖m + s‖ < ‖mk' S m‖ + ε := by\n  obtain ⟨n : M, hn : mk' S n = mk' S m, hn' : ‖n‖ < ‖mk' S m‖ + ε⟩ :=\n    norm_mk_lt (QuotientAddGroup.mk' S m) hε\n  erw [eq_comm, QuotientAddGroup.eq] at hn\n  use -m + n, hn\n  rwa [add_neg_cancel_left]\n\n"}
{"name":"quotient_norm_add_le","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst✝ : SeminormedAddCommGroup M\nS : AddSubgroup M\nx y : HasQuotient.Quotient M S\n⊢ LE.le (Norm.norm (HAdd.hAdd x y)) (HAdd.hAdd (Norm.norm x) (Norm.norm y))","decl":"/-- The quotient norm satisfies the triangle inequality. -/\ntheorem quotient_norm_add_le (S : AddSubgroup M) (x y : M ⧸ S) : ‖x + y‖ ≤ ‖x‖ + ‖y‖ := by\n  rcases And.intro (mk_surjective x) (mk_surjective y) with ⟨⟨x, rfl⟩, ⟨y, rfl⟩⟩\n  simp only [← mk'_apply, ← map_add, quotient_norm_mk_eq, sInf_image']\n  refine le_ciInf_add_ciInf fun a b ↦ ?_\n  refine ciInf_le_of_le ⟨0, forall_mem_range.2 fun _ ↦ norm_nonneg _⟩ (a + b) ?_\n  exact (congr_arg norm (add_add_add_comm _ _ _ _)).trans_le (norm_add_le _ _)\n\n"}
{"name":"norm_mk_zero","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst✝ : SeminormedAddCommGroup M\nS : AddSubgroup M\n⊢ Eq (Norm.norm 0) 0","decl":"/-- The quotient norm of `0` is `0`. -/\ntheorem norm_mk_zero (S : AddSubgroup M) : ‖(0 : M ⧸ S)‖ = 0 := by\n  erw [quotient_norm_eq_zero_iff]\n  exact subset_closure S.zero_mem\n\n"}
{"name":"norm_mk_eq_zero","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst✝ : SeminormedAddCommGroup M\nS : AddSubgroup M\nhS : IsClosed ↑S\nm : M\nh : Eq (Norm.norm ((QuotientAddGroup.mk' S) m)) 0\n⊢ Membership.mem S m","decl":"/-- If `(m : M)` has norm equal to `0` in `M ⧸ S` for a closed subgroup `S` of `M`, then\n`m ∈ S`. -/\ntheorem norm_mk_eq_zero (S : AddSubgroup M) (hS : IsClosed (S : Set M)) (m : M)\n    (h : ‖mk' S m‖ = 0) : m ∈ S := by rwa [quotient_norm_eq_zero_iff, hS.closure_eq] at h\n\n"}
{"name":"quotient_nhd_basis","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst✝ : SeminormedAddCommGroup M\nS : AddSubgroup M\n⊢ (nhds 0).HasBasis (fun ε => LT.lt 0 ε) fun ε => setOf fun x => LT.lt (Norm.norm x) ε","decl":"theorem quotient_nhd_basis (S : AddSubgroup M) :\n    (𝓝 (0 : M ⧸ S)).HasBasis (fun ε ↦ 0 < ε) fun ε ↦ { x | ‖x‖ < ε } := by\n  have : ∀ ε : ℝ, mk '' ball (0 : M) ε = { x : M ⧸ S | ‖x‖ < ε } := by\n    refine fun ε ↦ Set.ext <| forall_mk.2 fun x ↦ ?_\n    rw [ball_zero_eq, mem_setOf_eq, norm_lt_iff, mem_image]\n    exact exists_congr fun _ ↦ and_comm\n  rw [← QuotientAddGroup.mk_zero, nhds_eq, ← funext this]\n  exact .map _ Metric.nhds_basis_ball\n\n"}
{"name":"AddSubgroup.normedMk.apply","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst✝ : SeminormedAddCommGroup M\nS : AddSubgroup M\nm : M\n⊢ Eq (S.normedMk m) ((QuotientAddGroup.mk' S) m)","decl":"/-- `S.normedMk` agrees with `QuotientAddGroup.mk' S`. -/\n@[simp]\ntheorem normedMk.apply (S : AddSubgroup M) (m : M) : normedMk S m = QuotientAddGroup.mk' S m :=\n  rfl\n\n"}
{"name":"AddSubgroup.surjective_normedMk","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst✝ : SeminormedAddCommGroup M\nS : AddSubgroup M\n⊢ Function.Surjective ⇑S.normedMk","decl":"/-- `S.normedMk` is surjective. -/\ntheorem surjective_normedMk (S : AddSubgroup M) : Function.Surjective (normedMk S) :=\n  Quot.mk_surjective\n\n"}
{"name":"AddSubgroup.ker_normedMk","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst✝ : SeminormedAddCommGroup M\nS : AddSubgroup M\n⊢ Eq S.normedMk.ker S","decl":"/-- The kernel of `S.normedMk` is `S`. -/\ntheorem ker_normedMk (S : AddSubgroup M) : S.normedMk.ker = S :=\n  QuotientAddGroup.ker_mk' _\n\n"}
{"name":"AddSubgroup.norm_normedMk_le","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst✝ : SeminormedAddCommGroup M\nS : AddSubgroup M\n⊢ LE.le (Norm.norm S.normedMk) 1","decl":"/-- The operator norm of the projection is at most `1`. -/\ntheorem norm_normedMk_le (S : AddSubgroup M) : ‖S.normedMk‖ ≤ 1 :=\n  NormedAddGroupHom.opNorm_le_bound _ zero_le_one fun m => by simp [quotient_norm_mk_le']\n\n"}
{"name":"QuotientAddGroup.norm_lift_apply_le","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : SeminormedAddCommGroup M\ninst✝ : SeminormedAddCommGroup N\nS : AddSubgroup M\nf : NormedAddGroupHom M N\nhf : ∀ (x : M), Membership.mem S x → Eq (f x) 0\nx : HasQuotient.Quotient M S\n⊢ LE.le (Norm.norm ((QuotientAddGroup.lift S f.toAddMonoidHom hf) x)) (HMul.hMul (Norm.norm f) (Norm.norm x))","decl":"theorem _root_.QuotientAddGroup.norm_lift_apply_le {S : AddSubgroup M} (f : NormedAddGroupHom M N)\n    (hf : ∀ x ∈ S, f x = 0) (x : M ⧸ S) : ‖lift S f.toAddMonoidHom hf x‖ ≤ ‖f‖ * ‖x‖ := by\n  cases (norm_nonneg f).eq_or_gt with\n  | inl h =>\n    rcases mk_surjective x with ⟨x, rfl⟩\n    simpa [h] using le_opNorm f x\n  | inr h =>\n    rw [← not_lt, ← lt_div_iff₀' h, norm_lt_iff]\n    rintro ⟨x, rfl, hx⟩\n    exact ((lt_div_iff₀' h).1 hx).not_le (le_opNorm f x)\n\n"}
{"name":"AddSubgroup.norm_normedMk","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst✝ : SeminormedAddCommGroup M\nS : AddSubgroup M\nh : Ne (↑S.topologicalClosure) Set.univ\n⊢ Eq (Norm.norm S.normedMk) 1","decl":"/-- The operator norm of the projection is `1` if the subspace is not dense. -/\ntheorem norm_normedMk (S : AddSubgroup M) (h : (S.topologicalClosure : Set M) ≠ univ) :\n    ‖S.normedMk‖ = 1 := by\n  refine le_antisymm (norm_normedMk_le S) ?_\n  obtain ⟨x, hx⟩ : ∃ x : M, 0 < ‖(x : M ⧸ S)‖ := by\n    refine (Set.nonempty_compl.2 h).imp fun x hx ↦ ?_\n    exact (norm_nonneg _).lt_of_ne' <| mt (quotient_norm_eq_zero_iff S x).1 hx\n  refine (le_mul_iff_one_le_left hx).1 ?_\n  exact norm_lift_apply_le S.normedMk (fun x ↦ (eq_zero_iff x).2) x\n\n"}
{"name":"AddSubgroup.norm_trivial_quotient_mk","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst✝ : SeminormedAddCommGroup M\nS : AddSubgroup M\nh : Eq (↑S.topologicalClosure) Set.univ\n⊢ Eq (Norm.norm S.normedMk) 0","decl":"/-- The operator norm of the projection is `0` if the subspace is dense. -/\ntheorem norm_trivial_quotient_mk (S : AddSubgroup M)\n    (h : (S.topologicalClosure : Set M) = Set.univ) : ‖S.normedMk‖ = 0 := by\n  refine le_antisymm (opNorm_le_bound _ le_rfl fun x => ?_) (norm_nonneg _)\n  have hker : x ∈ S.normedMk.ker.topologicalClosure := by\n    rw [S.ker_normedMk, ← SetLike.mem_coe, h]\n    trivial\n  rw [ker_normedMk] at hker\n  simp only [(quotient_norm_eq_zero_iff S x).mpr hker, normedMk.apply, zero_mul, le_rfl]\n\n"}
{"name":"NormedAddGroupHom.IsQuotient.norm","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : SeminormedAddCommGroup M\ninst✝ : SeminormedAddCommGroup N\nf : NormedAddGroupHom M N\nself : f.IsQuotient\nx : M\n⊢ Eq (Norm.norm (f x)) (InfSet.sInf (Set.image (fun m => Norm.norm (HAdd.hAdd x m)) ↑f.ker))","decl":"/-- `IsQuotient f`, for `f : M ⟶ N` means that `N` is isomorphic to the quotient of `M`\nby the kernel of `f`. -/\nstructure IsQuotient (f : NormedAddGroupHom M N) : Prop where\n  protected surjective : Function.Surjective f\n  protected norm : ∀ x, ‖f x‖ = sInf ((fun m => ‖x + m‖) '' f.ker)\n\n"}
{"name":"NormedAddGroupHom.IsQuotient.surjective","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : SeminormedAddCommGroup M\ninst✝ : SeminormedAddCommGroup N\nf : NormedAddGroupHom M N\nself : f.IsQuotient\n⊢ Function.Surjective ⇑f","decl":"/-- `IsQuotient f`, for `f : M ⟶ N` means that `N` is isomorphic to the quotient of `M`\nby the kernel of `f`. -/\nstructure IsQuotient (f : NormedAddGroupHom M N) : Prop where\n  protected surjective : Function.Surjective f\n  protected norm : ∀ x, ‖f x‖ = sInf ((fun m => ‖x + m‖) '' f.ker)\n\n"}
{"name":"NormedAddGroupHom.lift_mk","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst✝¹ : SeminormedAddCommGroup M\nN : Type u_3\ninst✝ : SeminormedAddCommGroup N\nS : AddSubgroup M\nf : NormedAddGroupHom M N\nhf : ∀ (s : M), Membership.mem S s → Eq (f s) 0\nm : M\n⊢ Eq ((NormedAddGroupHom.lift S f hf) (S.normedMk m)) (f m)","decl":"theorem lift_mk {N : Type*} [SeminormedAddCommGroup N] (S : AddSubgroup M)\n    (f : NormedAddGroupHom M N) (hf : ∀ s ∈ S, f s = 0) (m : M) :\n    lift S f hf (S.normedMk m) = f m :=\n  rfl\n\n"}
{"name":"NormedAddGroupHom.lift_unique","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst✝¹ : SeminormedAddCommGroup M\nN : Type u_3\ninst✝ : SeminormedAddCommGroup N\nS : AddSubgroup M\nf : NormedAddGroupHom M N\nhf : ∀ (s : M), Membership.mem S s → Eq (f s) 0\ng : NormedAddGroupHom (HasQuotient.Quotient M S) N\nh : Eq (g.comp S.normedMk) f\n⊢ Eq g (NormedAddGroupHom.lift S f hf)","decl":"theorem lift_unique {N : Type*} [SeminormedAddCommGroup N] (S : AddSubgroup M)\n    (f : NormedAddGroupHom M N) (hf : ∀ s ∈ S, f s = 0) (g : NormedAddGroupHom (M ⧸ S) N)\n    (h : g.comp S.normedMk = f) : g = lift S f hf := by\n  ext x\n  rcases AddSubgroup.surjective_normedMk _ x with ⟨x, rfl⟩\n  change g.comp S.normedMk x = _\n  simp only [h]\n  rfl\n\n"}
{"name":"NormedAddGroupHom.isQuotientQuotient","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst✝ : SeminormedAddCommGroup M\nS : AddSubgroup M\n⊢ S.normedMk.IsQuotient","decl":"/-- `S.normedMk` satisfies `IsQuotient`. -/\ntheorem isQuotientQuotient (S : AddSubgroup M) : IsQuotient S.normedMk :=\n  ⟨S.surjective_normedMk, fun m => by simpa [S.ker_normedMk] using quotient_norm_mk_eq _ m⟩\n\n"}
{"name":"NormedAddGroupHom.IsQuotient.norm_lift","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : SeminormedAddCommGroup M\ninst✝ : SeminormedAddCommGroup N\nf : NormedAddGroupHom M N\nhquot : f.IsQuotient\nε : Real\nhε : LT.lt 0 ε\nn : N\n⊢ Exists fun m => And (Eq (f m) n) (LT.lt (Norm.norm m) (HAdd.hAdd (Norm.norm n) ε))","decl":"theorem IsQuotient.norm_lift {f : NormedAddGroupHom M N} (hquot : IsQuotient f) {ε : ℝ} (hε : 0 < ε)\n    (n : N) : ∃ m : M, f m = n ∧ ‖m‖ < ‖n‖ + ε := by\n  obtain ⟨m, rfl⟩ := hquot.surjective n\n  have nonemp : ((fun m' => ‖m + m'‖) '' f.ker).Nonempty := by\n    rw [Set.image_nonempty]\n    exact ⟨0, f.ker.zero_mem⟩\n  rcases Real.lt_sInf_add_pos nonemp hε\n    with ⟨_, ⟨⟨x, hx, rfl⟩, H : ‖m + x‖ < sInf ((fun m' : M => ‖m + m'‖) '' f.ker) + ε⟩⟩\n  exact ⟨m + x, by rw [map_add, (NormedAddGroupHom.mem_ker f x).mp hx, add_zero], by\n    rwa [hquot.norm]⟩\n\n"}
{"name":"NormedAddGroupHom.IsQuotient.norm_le","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : SeminormedAddCommGroup M\ninst✝ : SeminormedAddCommGroup N\nf : NormedAddGroupHom M N\nhquot : f.IsQuotient\nm : M\n⊢ LE.le (Norm.norm (f m)) (Norm.norm m)","decl":"theorem IsQuotient.norm_le {f : NormedAddGroupHom M N} (hquot : IsQuotient f) (m : M) :\n    ‖f m‖ ≤ ‖m‖ := by\n  rw [hquot.norm]\n  apply csInf_le\n  · use 0\n    rintro _ ⟨m', -, rfl⟩\n    apply norm_nonneg\n  · exact ⟨0, f.ker.zero_mem, by simp⟩\n\n"}
{"name":"NormedAddGroupHom.norm_lift_le","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst✝¹ : SeminormedAddCommGroup M\nN : Type u_3\ninst✝ : SeminormedAddCommGroup N\nS : AddSubgroup M\nf : NormedAddGroupHom M N\nhf : ∀ (s : M), Membership.mem S s → Eq (f s) 0\n⊢ LE.le (Norm.norm (NormedAddGroupHom.lift S f hf)) (Norm.norm f)","decl":"theorem norm_lift_le {N : Type*} [SeminormedAddCommGroup N] (S : AddSubgroup M)\n    (f : NormedAddGroupHom M N) (hf : ∀ s ∈ S, f s = 0) :\n    ‖lift S f hf‖ ≤ ‖f‖ :=\n  opNorm_le_bound _ (norm_nonneg f) (norm_lift_apply_le f hf)\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: deprecate?\n"}
{"name":"NormedAddGroupHom.lift_norm_le","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst✝¹ : SeminormedAddCommGroup M\nN : Type u_3\ninst✝ : SeminormedAddCommGroup N\nS : AddSubgroup M\nf : NormedAddGroupHom M N\nhf : ∀ (s : M), Membership.mem S s → Eq (f s) 0\nc : NNReal\nfb : LE.le (Norm.norm f) ↑c\n⊢ LE.le (Norm.norm (NormedAddGroupHom.lift S f hf)) ↑c","decl":"theorem lift_norm_le {N : Type*} [SeminormedAddCommGroup N] (S : AddSubgroup M)\n    (f : NormedAddGroupHom M N) (hf : ∀ s ∈ S, f s = 0) {c : ℝ≥0} (fb : ‖f‖ ≤ c) :\n    ‖lift S f hf‖ ≤ c :=\n  (norm_lift_le S f hf).trans fb\n\n"}
{"name":"NormedAddGroupHom.lift_normNoninc","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst✝¹ : SeminormedAddCommGroup M\nN : Type u_3\ninst✝ : SeminormedAddCommGroup N\nS : AddSubgroup M\nf : NormedAddGroupHom M N\nhf : ∀ (s : M), Membership.mem S s → Eq (f s) 0\nfb : f.NormNoninc\n⊢ (NormedAddGroupHom.lift S f hf).NormNoninc","decl":"theorem lift_normNoninc {N : Type*} [SeminormedAddCommGroup N] (S : AddSubgroup M)\n    (f : NormedAddGroupHom M N) (hf : ∀ s ∈ S, f s = 0) (fb : f.NormNoninc) :\n    (lift S f hf).NormNoninc := fun x => by\n  have fb' : ‖f‖ ≤ (1 : ℝ≥0) := NormNoninc.normNoninc_iff_norm_le_one.mp fb\n  simpa using le_of_opNorm_le _ (f.lift_norm_le _ _ fb') _\n\n"}
{"name":"Submodule.Quotient.completeSpace","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst✝³ : SeminormedAddCommGroup M\nR : Type u_3\ninst✝² : Ring R\ninst✝¹ : Module R M\nS : Submodule R M\ninst✝ : CompleteSpace M\n⊢ CompleteSpace (HasQuotient.Quotient M S)","decl":"instance Submodule.Quotient.completeSpace [CompleteSpace M] : CompleteSpace (M ⧸ S) :=\n  QuotientAddGroup.completeSpace M S.toAddSubgroup\n\n"}
{"name":"Submodule.Quotient.norm_mk_lt","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst✝² : SeminormedAddCommGroup M\nR : Type u_3\ninst✝¹ : Ring R\ninst✝ : Module R M\nS : Submodule R M\nx : HasQuotient.Quotient M S\nε : Real\nhε : LT.lt 0 ε\n⊢ Exists fun m => And (Eq (Submodule.Quotient.mk m) x) (LT.lt (Norm.norm m) (HAdd.hAdd (Norm.norm x) ε))","decl":"/-- For any `x : M ⧸ S` and any `0 < ε`, there is `m : M` such that `Submodule.Quotient.mk m = x`\nand `‖m‖ < ‖x‖ + ε`. -/\nnonrec theorem Submodule.Quotient.norm_mk_lt {S : Submodule R M} (x : M ⧸ S) {ε : ℝ} (hε : 0 < ε) :\n    ∃ m : M, Submodule.Quotient.mk m = x ∧ ‖m‖ < ‖x‖ + ε :=\n  norm_mk_lt x hε\n\n"}
{"name":"Submodule.Quotient.norm_mk_le","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst✝² : SeminormedAddCommGroup M\nR : Type u_3\ninst✝¹ : Ring R\ninst✝ : Module R M\nS : Submodule R M\nm : M\n⊢ LE.le (Norm.norm (Submodule.Quotient.mk m)) (Norm.norm m)","decl":"theorem Submodule.Quotient.norm_mk_le (m : M) : ‖(Submodule.Quotient.mk m : M ⧸ S)‖ ≤ ‖m‖ :=\n  quotient_norm_mk_le S.toAddSubgroup m\n\n"}
{"name":"Submodule.Quotient.instBoundedSMul","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"M : Type u_1\ninst✝⁷ : SeminormedAddCommGroup M\nR : Type u_3\ninst✝⁶ : Ring R\ninst✝⁵ : Module R M\nS : Submodule R M\n𝕜 : Type u_4\ninst✝⁴ : SeminormedCommRing 𝕜\ninst✝³ : Module 𝕜 M\ninst✝² : BoundedSMul 𝕜 M\ninst✝¹ : SMul 𝕜 R\ninst✝ : IsScalarTower 𝕜 R M\n⊢ BoundedSMul 𝕜 (HasQuotient.Quotient M S)","decl":"instance Submodule.Quotient.instBoundedSMul (𝕜 : Type*)\n    [SeminormedCommRing 𝕜] [Module 𝕜 M] [BoundedSMul 𝕜 M] [SMul 𝕜 R] [IsScalarTower 𝕜 R M] :\n    BoundedSMul 𝕜 (M ⧸ S) :=\n  .of_norm_smul_le fun k x =>\n    -- Porting note: this is `QuotientAddGroup.norm_lift_apply_le` for `f : M → M ⧸ S` given by\n    -- `x ↦ mk (k • x)`; todo: add scalar multiplication as `NormedAddGroupHom`, use it here\n    _root_.le_of_forall_pos_le_add fun ε hε => by\n      have := (nhds_basis_ball.tendsto_iff nhds_basis_ball).mp\n        ((@Real.uniformContinuous_const_mul ‖k‖).continuous.tendsto ‖x‖) ε hε\n      simp only [mem_ball, exists_prop, dist, abs_sub_lt_iff] at this\n      rcases this with ⟨δ, hδ, h⟩\n      obtain ⟨a, rfl, ha⟩ := Submodule.Quotient.norm_mk_lt x hδ\n      specialize h ‖a‖ ⟨by linarith, by linarith [Submodule.Quotient.norm_mk_le S a]⟩\n      calc\n        _ ≤ ‖k‖ * ‖a‖ := (quotient_norm_mk_le S.toAddSubgroup (k • a)).trans (norm_smul_le k a)\n        _ ≤ _ := (sub_lt_iff_lt_add'.mp h.1).le\n\n"}
{"name":"Ideal.Quotient.norm_mk_lt","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"R : Type u_3\ninst✝ : SeminormedCommRing R\nI : Ideal R\nx : HasQuotient.Quotient R I\nε : Real\nhε : LT.lt 0 ε\n⊢ Exists fun r => And (Eq ((Ideal.Quotient.mk I) r) x) (LT.lt (Norm.norm r) (HAdd.hAdd (Norm.norm x) ε))","decl":"nonrec theorem Ideal.Quotient.norm_mk_lt {I : Ideal R} (x : R ⧸ I) {ε : ℝ} (hε : 0 < ε) :\n    ∃ r : R, Ideal.Quotient.mk I r = x ∧ ‖r‖ < ‖x‖ + ε :=\n  norm_mk_lt x hε\n\n"}
{"name":"Ideal.Quotient.norm_mk_le","module":"Mathlib.Analysis.Normed.Group.Quotient","initialProofState":"R : Type u_3\ninst✝ : SeminormedCommRing R\nI : Ideal R\nr : R\n⊢ LE.le (Norm.norm ((Ideal.Quotient.mk I) r)) (Norm.norm r)","decl":"theorem Ideal.Quotient.norm_mk_le (r : R) : ‖Ideal.Quotient.mk I r‖ ≤ ‖r‖ :=\n  quotient_norm_mk_le I.toAddSubgroup r\n\n"}
