{"name":"linearIndependent_iff_injective_linearCombination","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nv : ι → M\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Iff (LinearIndependent R v) (Function.Injective ⇑(Finsupp.linearCombination R v))","decl":"theorem linearIndependent_iff_injective_linearCombination :\n    LinearIndependent R v ↔ Injective (Finsupp.linearCombination R v) := Iff.rfl\n\n"}
{"name":"LinearIndependent.injective_linearCombination","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nv : ι → M\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\na✝ : LinearIndependent R v\n⊢ Function.Injective ⇑(Finsupp.linearCombination R v)","decl":"alias ⟨LinearIndependent.injective_linearCombination, _⟩ :=\n  linearIndependent_iff_injective_linearCombination\n\n"}
{"name":"Fintype.linearIndependent_iff_injective","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nv : ι → M\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Fintype ι\n⊢ Iff (LinearIndependent R v) (Function.Injective ⇑((Fintype.linearCombination R Nat) v))","decl":"theorem Fintype.linearIndependent_iff_injective [Fintype ι] :\n    LinearIndependent R v ↔ Injective (Fintype.linearCombination R ℕ v) := by\n  simp [← Finsupp.linearCombination_eq_fintype_linearCombination, LinearIndependent]\n\n"}
{"name":"LinearIndependent.injective","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nv : ι → M\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Nontrivial R\nhv : LinearIndependent R v\n⊢ Function.Injective v","decl":"theorem LinearIndependent.injective [Nontrivial R] (hv : LinearIndependent R v) : Injective v := by\n  simpa [comp_def]\n    using Injective.comp hv (Finsupp.single_left_injective one_ne_zero)\n\n"}
{"name":"LinearIndependent.ne_zero","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nv : ι → M\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Nontrivial R\ni : ι\nhv : LinearIndependent R v\n⊢ Ne (v i) 0","decl":"theorem LinearIndependent.ne_zero [Nontrivial R] (i : ι) (hv : LinearIndependent R v) :\n    v i ≠ 0 := by\n  intro h\n  have := @hv (Finsupp.single i 1 : ι →₀ R) 0 (by simpa using h)\n  simp at this\n\n"}
{"name":"linearIndependent_empty_type","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nv : ι → M\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : IsEmpty ι\n⊢ LinearIndependent R v","decl":"theorem linearIndependent_empty_type [IsEmpty ι] : LinearIndependent R v :=\n  injective_of_subsingleton _\n\n"}
{"name":"linearIndependent_empty","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"R : Type u_2\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ LinearIndependent R fun x => ↑x","decl":"variable (R M) in\ntheorem linearIndependent_empty : LinearIndependent R (fun x => x : (∅ : Set M) → M) :=\n  linearIndependent_empty_type\n\n"}
{"name":"LinearIndependent.comp","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nι' : Type u_1\nR : Type u_2\nM : Type u_4\nv : ι → M\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nh : LinearIndependent R v\nf : ι' → ι\nhf : Function.Injective f\n⊢ LinearIndependent R (Function.comp v f)","decl":"/-- A subfamily of a linearly independent family (i.e., a composition with an injective map) is a\nlinearly independent family. -/\ntheorem LinearIndependent.comp (h : LinearIndependent R v) (f : ι' → ι) (hf : Injective f) :\n    LinearIndependent R (v ∘ f) := by\n  simpa [comp_def] using Injective.comp h (Finsupp.mapDomain_injective hf)\n\n"}
{"name":"LinearIndependent.restrict_scalars","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nK : Type u_3\nM : Type u_4\nv : ι → M\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : Semiring K\ninst✝² : SMulWithZero R K\ninst✝¹ : Module K M\ninst✝ : IsScalarTower R K M\nhinj : Function.Injective fun r => HSMul.hSMul r 1\nli : LinearIndependent K v\n⊢ LinearIndependent R v","decl":"/-- A set of linearly independent vectors in a module `M` over a semiring `K` is also linearly\nindependent over a subring `R` of `K`.\nThe implementation uses minimal assumptions about the relationship between `R`, `K` and `M`.\nThe version where `K` is an `R`-algebra is `LinearIndependent.restrict_scalars_algebras`. -/\ntheorem LinearIndependent.restrict_scalars [Semiring K] [SMulWithZero R K] [Module K M]\n    [IsScalarTower R K M] (hinj : Injective fun r : R ↦ r • (1 : K))\n    (li : LinearIndependent K v) : LinearIndependent R v := by\n  intro x y hxy\n  let f := fun r : R => r • (1 : K)\n  have := @li (x.mapRange f (by simp [f])) (y.mapRange f (by simp [f])) ?_\n  · ext i\n    exact hinj congr($this i)\n  simpa [Finsupp.linearCombination, f, Finsupp.sum_mapRange_index]\n\n"}
{"name":"linearIndependent_iff_injective_total","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nv : ι → M\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Iff (LinearIndependent R v) (Function.Injective ⇑(Finsupp.linearCombination R v))","decl":"@[deprecated (since := \"2024-08-29\")] alias linearIndependent_iff_injective_total :=\n  linearIndependent_iff_injective_linearCombination\n\n"}
{"name":"LinearIndependent.injective_total","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nv : ι → M\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\na✝ : LinearIndependent R v\n⊢ Function.Injective ⇑(Finsupp.linearCombination R v)","decl":"@[deprecated (since := \"2024-08-29\")] alias LinearIndependent.injective_total :=\n  LinearIndependent.injective_linearCombination\n\n-- This version makes `l₁` and `l₂` explicit.\n"}
{"name":"linearIndependent_iffₛ","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nv : ι → M\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Iff (LinearIndependent R v) (∀ (l₁ l₂ : Finsupp ι R), Eq ((Finsupp.linearCombination R v) l₁) ((Finsupp.linearCombination R v) l₂) → Eq l₁ l₂)","decl":"theorem linearIndependent_iffₛ :\n    LinearIndependent R v ↔\n      ∀ l₁ l₂, Finsupp.linearCombination R v l₁ = Finsupp.linearCombination R v l₂ → l₁ = l₂ :=\n  Iff.rfl\n\n"}
{"name":"linearIndependent_iff'ₛ","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nv : ι → M\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Iff (LinearIndependent R v) (∀ (s : Finset ι) (f g : ι → R), Eq (s.sum fun i => HSMul.hSMul (f i) (v i)) (s.sum fun i => HSMul.hSMul (g i) (v i)) → ∀ (i : ι), Membership.mem s i → Eq (f i) (g i))","decl":"open Finset in\ntheorem linearIndependent_iff'ₛ :\n    LinearIndependent R v ↔\n      ∀ s : Finset ι, ∀ f g : ι → R, ∑ i ∈ s, f i • v i = ∑ i ∈ s, g i • v i → ∀ i ∈ s, f i = g i :=\n  linearIndependent_iffₛ.trans\n    ⟨fun hv s f g eq i his ↦ by\n      have h :=\n        hv (∑ i ∈ s, Finsupp.single i (f i)) (∑ i ∈ s, Finsupp.single i (g i)) <| by\n          simpa only [map_sum, Finsupp.linearCombination_single] using eq\n      have (f : ι → R) : f i = (∑ j ∈ s, Finsupp.single j (f j)) i :=\n        calc\n          f i = (Finsupp.lapply i : (ι →₀ R) →ₗ[R] R) (Finsupp.single i (f i)) := by\n            { rw [Finsupp.lapply_apply, Finsupp.single_eq_same] }\n          _ = ∑ j ∈ s, (Finsupp.lapply i : (ι →₀ R) →ₗ[R] R) (Finsupp.single j (f j)) :=\n            Eq.symm <|\n              Finset.sum_eq_single i\n                (fun j _hjs hji => by rw [Finsupp.lapply_apply, Finsupp.single_eq_of_ne hji])\n                fun hnis => hnis.elim his\n          _ = (∑ j ∈ s, Finsupp.single j (f j)) i := (map_sum ..).symm\n      rw [this f, this g, h],\n      fun hv f g hl ↦\n      Finsupp.ext fun _ ↦ by\n        classical\n        refine _root_.by_contradiction fun hni ↦ hni <| hv (f.support ∪ g.support) f g ?_ _ ?_\n        · rwa [← sum_subset subset_union_left, ← sum_subset subset_union_right] <;>\n            rintro i - hi <;> rw [Finsupp.not_mem_support_iff.mp hi, zero_smul]\n        · contrapose! hni\n          simp_rw [not_mem_union, Finsupp.not_mem_support_iff] at hni\n          rw [hni.1, hni.2]⟩\n\n"}
{"name":"linearIndependent_iff''ₛ","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nv : ι → M\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Iff (LinearIndependent R v) (∀ (s : Finset ι) (f g : ι → R), (∀ (i : ι), Not (Membership.mem s i) → Eq (f i) (g i)) → Eq (s.sum fun i => HSMul.hSMul (f i) (v i)) (s.sum fun i => HSMul.hSMul (g i) (v i)) → ∀ (i : ι), Eq (f i) (g i))","decl":"theorem linearIndependent_iff''ₛ :\n    LinearIndependent R v ↔\n      ∀ (s : Finset ι) (f g : ι → R), (∀ i ∉ s, f i = g i) →\n        ∑ i ∈ s, f i • v i = ∑ i ∈ s, g i • v i → ∀ i, f i = g i := by\n  classical\n  exact linearIndependent_iff'ₛ.trans\n    ⟨fun H s f g eq hv i ↦ if his : i ∈ s then H s f g hv i his else eq i his,\n      fun H s f g eq i hi ↦ by\n      convert\n        H s (fun j ↦ if j ∈ s then f j else 0) (fun j ↦ if j ∈ s then g j else 0)\n          (fun j hj ↦ (if_neg hj).trans (if_neg hj).symm)\n          (by simp_rw [ite_smul, zero_smul, Finset.sum_extend_by_zero, eq]) i <;>\n      exact (if_pos hi).symm⟩\n\n"}
{"name":"not_linearIndependent_iffₛ","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nv : ι → M\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Iff (Not (LinearIndependent R v)) (Exists fun s => Exists fun f => Exists fun g => And (Eq (s.sum fun i => HSMul.hSMul (f i) (v i)) (s.sum fun i => HSMul.hSMul (g i) (v i))) (Exists fun i => And (Membership.mem s i) (Ne (f i) (g i))))","decl":"theorem not_linearIndependent_iffₛ :\n    ¬LinearIndependent R v ↔ ∃ s : Finset ι,\n      ∃ f g : ι → R, ∑ i ∈ s, f i • v i = ∑ i ∈ s, g i • v i ∧ ∃ i ∈ s, f i ≠ g i := by\n  rw [linearIndependent_iff'ₛ]\n  simp only [exists_prop, not_forall]\n\n"}
{"name":"Fintype.linearIndependent_iffₛ","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nv : ι → M\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Fintype ι\n⊢ Iff (LinearIndependent R v) (∀ (f g : ι → R), Eq (Finset.univ.sum fun i => HSMul.hSMul (f i) (v i)) (Finset.univ.sum fun i => HSMul.hSMul (g i) (v i)) → ∀ (i : ι), Eq (f i) (g i))","decl":"theorem Fintype.linearIndependent_iffₛ [Fintype ι] :\n    LinearIndependent R v ↔ ∀ f g : ι → R, ∑ i, f i • v i = ∑ i, g i • v i → ∀ i, f i = g i := by\n  simp_rw [Fintype.linearIndependent_iff_injective,\n    Injective, Fintype.linearCombination_apply, funext_iff]\n\n"}
{"name":"Fintype.linearIndependent_iff'ₛ","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nv : ι → M\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\n⊢ Iff (LinearIndependent R v) (Function.Injective ⇑((LinearMap.lsum R (fun x => R) Nat) fun i => LinearMap.id.smulRight (v i)))","decl":"/-- A finite family of vectors `v i` is linear independent iff the linear map that sends\n`c : ι → R` to `∑ i, c i • v i` is injective. -/\ntheorem Fintype.linearIndependent_iff'ₛ [Fintype ι] [DecidableEq ι] :\n    LinearIndependent R v ↔\n      Injective (LinearMap.lsum R (fun _ ↦ R) ℕ fun i ↦ LinearMap.id.smulRight (v i)) := by\n  simp [Fintype.linearIndependent_iffₛ, Injective, funext_iff]\n\n"}
{"name":"Fintype.not_linearIndependent_iffₛ","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nv : ι → M\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Fintype ι\n⊢ Iff (Not (LinearIndependent R v)) (Exists fun f => Exists fun g => And (Eq (Finset.univ.sum fun i => HSMul.hSMul (f i) (v i)) (Finset.univ.sum fun i => HSMul.hSMul (g i) (v i))) (Exists fun i => Ne (f i) (g i)))","decl":"theorem Fintype.not_linearIndependent_iffₛ [Fintype ι] :\n    ¬LinearIndependent R v ↔ ∃ f g : ι → R, ∑ i, f i • v i = ∑ i, g i • v i ∧ ∃ i, f i ≠ g i := by\n  simpa using not_iff_not.2 Fintype.linearIndependent_iffₛ\n\n"}
{"name":"LinearIndependent.pair_iffₛ","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"R : Type u_2\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx y : M\n⊢ Iff (LinearIndependent R (Matrix.vecCons x (Matrix.vecCons y Matrix.vecEmpty))) (∀ (s t s' t' : R), Eq (HAdd.hAdd (HSMul.hSMul s x) (HSMul.hSMul t y)) (HAdd.hAdd (HSMul.hSMul s' x) (HSMul.hSMul t' y)) → And (Eq s s') (Eq t t'))","decl":"lemma LinearIndependent.pair_iffₛ {x y : M} :\n    LinearIndependent R ![x, y] ↔\n      ∀ (s t s' t' : R), s • x + t • y = s' • x + t' • y → s = s' ∧ t = t' := by\n  simp [Fintype.linearIndependent_iffₛ, Fin.forall_fin_two, ← FinVec.forall_iff]; rfl\n\n"}
{"name":"LinearIndependent.eq_of_pair","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"R : Type u_2\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx y : M\nh : LinearIndependent R (Matrix.vecCons x (Matrix.vecCons y Matrix.vecEmpty))\ns t s' t' : R\nh' : Eq (HAdd.hAdd (HSMul.hSMul s x) (HSMul.hSMul t y)) (HAdd.hAdd (HSMul.hSMul s' x) (HSMul.hSMul t' y))\n⊢ And (Eq s s') (Eq t t')","decl":"lemma LinearIndependent.eq_of_pair {x y : M} (h : LinearIndependent R ![x, y])\n    {s t s' t' : R} (h' : s • x + t • y = s' • x + t' • y) : s = s' ∧ t = t' :=\n  pair_iffₛ.mp h _ _ _ _ h'\n\n"}
{"name":"LinearIndependent.eq_zero_of_pair'","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"R : Type u_2\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx y : M\nh : LinearIndependent R (Matrix.vecCons x (Matrix.vecCons y Matrix.vecEmpty))\ns t : R\nh' : Eq (HSMul.hSMul s x) (HSMul.hSMul t y)\n⊢ And (Eq s 0) (Eq t 0)","decl":"lemma LinearIndependent.eq_zero_of_pair' {x y : M} (h : LinearIndependent R ![x, y])\n    {s t : R} (h' : s • x = t • y) : s = 0 ∧ t = 0 := by\n  suffices H : s = 0 ∧ 0 = t from ⟨H.1, H.2.symm⟩\n  exact h.eq_of_pair (by simpa using h')\n\n"}
{"name":"LinearIndependent.eq_zero_of_pair","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"R : Type u_2\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx y : M\nh : LinearIndependent R (Matrix.vecCons x (Matrix.vecCons y Matrix.vecEmpty))\ns t : R\nh' : Eq (HAdd.hAdd (HSMul.hSMul s x) (HSMul.hSMul t y)) 0\n⊢ And (Eq s 0) (Eq t 0)","decl":"lemma LinearIndependent.eq_zero_of_pair {x y : M} (h : LinearIndependent R ![x, y])\n    {s t : R} (h' : s • x + t • y = 0) : s = 0 ∧ t = 0 := by\n  replace h := @h (.single 0 s + .single 1 t) 0 ?_\n  · exact ⟨by simpa using congr($h 0), by simpa using congr($h 1)⟩\n  simpa\n\n"}
{"name":"linearIndependent_iff_finset_linearIndependent","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nv : ι → M\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Iff (LinearIndependent R v) (∀ (s : Finset ι), LinearIndependent R (Function.comp v Subtype.val))","decl":"/-- A family is linearly independent if and only if all of its finite subfamily is\nlinearly independent. -/\ntheorem linearIndependent_iff_finset_linearIndependent :\n    LinearIndependent R v ↔ ∀ (s : Finset ι), LinearIndependent R (v ∘ (Subtype.val : s → ι)) :=\n  ⟨fun H _ ↦ H.comp _ Subtype.val_injective, fun H ↦ linearIndependent_iff'ₛ.2 fun s f g eq i hi ↦\n    Fintype.linearIndependent_iffₛ.1 (H s) (f ∘ Subtype.val) (g ∘ Subtype.val)\n      (by simpa only [← s.sum_coe_sort] using eq) ⟨i, hi⟩⟩\n\n"}
{"name":"LinearIndependent.coe_range","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nv : ι → M\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ni : LinearIndependent R v\n⊢ LinearIndependent R Subtype.val","decl":"theorem LinearIndependent.coe_range (i : LinearIndependent R v) :\n    LinearIndependent R ((↑) : range v → M) := by simpa using i.comp _ (rangeSplitting_injective v)\n\n"}
{"name":"Submodule.range_ker_disjoint","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nM' : Type u_5\nv : ι → M\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M'\ninst✝¹ : Module R M\ninst✝ : Module R M'\nf : LinearMap (RingHom.id R) M M'\nhv : LinearIndependent R (Function.comp (⇑f) v)\n⊢ Disjoint (Submodule.span R (Set.range v)) (LinearMap.ker f)","decl":"/-- If `v` is an injective family of vectors such that `f ∘ v` is linearly independent, then `v`\n    spans a submodule disjoint from the kernel of `f` -/\ntheorem Submodule.range_ker_disjoint {f : M →ₗ[R] M'}\n    (hv : LinearIndependent R (f ∘ v)) :\n    Disjoint (span R (range v)) (LinearMap.ker f) := by\n  rw [LinearIndependent, Finsupp.linearCombination_linear_comp] at hv\n  rw [disjoint_iff_inf_le, ← Set.image_univ, Finsupp.span_image_eq_map_linearCombination,\n    map_inf_eq_map_inf_comap, (LinearMap.ker_comp _ _).symm.trans\n      (LinearMap.ker_eq_bot_of_injective hv), inf_bot_eq, map_bot]\n\n"}
{"name":"LinearIndependent.map_of_injective_injectiveₛ","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nv : ι → M\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nR' : Type u_6\nM' : Type u_7\ninst✝² : Semiring R'\ninst✝¹ : AddCommMonoid M'\ninst✝ : Module R' M'\nhv : LinearIndependent R v\ni : R' → R\nj : AddMonoidHom M M'\nhi : Function.Injective i\nhj : Function.Injective ⇑j\nhc : ∀ (r : R') (m : M), Eq (j (HSMul.hSMul (i r) m)) (HSMul.hSMul r (j m))\n⊢ LinearIndependent R' (Function.comp (⇑j) v)","decl":"/-- If `M / R` and `M' / R'` are modules, `i : R' → R` is a map, `j : M →+ M'` is a monoid map,\nsuch that they are both injective, and compatible with the scalar\nmultiplications on `M` and `M'`, then `j` sends linearly independent families of vectors to\nlinearly independent families of vectors. As a special case, taking `R = R'`\nit is `LinearIndependent.map_injOn`. -/\ntheorem LinearIndependent.map_of_injective_injectiveₛ {R' M' : Type*}\n    [Semiring R'] [AddCommMonoid M'] [Module R' M'] (hv : LinearIndependent R v)\n    (i : R' → R) (j : M →+ M') (hi : Injective i) (hj : Injective j)\n    (hc : ∀ (r : R') (m : M), j (i r • m) = r • j m) : LinearIndependent R' (j ∘ v) := by\n  rw [linearIndependent_iff'ₛ] at hv ⊢\n  intro S r₁ r₂ H s hs\n  simp_rw [comp_apply, ← hc, ← map_sum] at H\n  exact hi <| hv _ _ _ (hj H) s hs\n\n"}
{"name":"LinearIndependent.map_of_surjective_injectiveₛ","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nv : ι → M\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nR' : Type u_6\nM' : Type u_7\ninst✝² : Semiring R'\ninst✝¹ : AddCommMonoid M'\ninst✝ : Module R' M'\nhv : LinearIndependent R v\ni : R → R'\nj : AddMonoidHom M M'\nhi : Function.Surjective i\nhj : Function.Injective ⇑j\nhc : ∀ (r : R) (m : M), Eq (j (HSMul.hSMul r m)) (HSMul.hSMul (i r) (j m))\n⊢ LinearIndependent R' (Function.comp (⇑j) v)","decl":"/-- If `M / R` and `M' / R'` are modules, `i : R → R'` is a surjective map,\nand `j : M →+ M'` is an injective monoid map, such that the scalar multiplications\non `M` and `M'` are compatible, then `j` sends linearly independent families\nof vectors to linearly independent families of vectors. As a special case, taking `R = R'`\nit is `LinearIndependent.map_injOn`. -/\ntheorem LinearIndependent.map_of_surjective_injectiveₛ {R' M' : Type*}\n    [Semiring R'] [AddCommMonoid M'] [Module R' M'] (hv : LinearIndependent R v)\n    (i : R → R') (j : M →+ M') (hi : Surjective i) (hj : Injective j)\n    (hc : ∀ (r : R) (m : M), j (r • m) = i r • j m) : LinearIndependent R' (j ∘ v) := by\n  obtain ⟨i', hi'⟩ := hi.hasRightInverse\n  refine hv.map_of_injective_injectiveₛ i' j (fun _ _ h ↦ ?_) hj fun r m ↦ ?_\n  · apply_fun i at h\n    rwa [hi', hi'] at h\n  rw [hc (i' r) m, hi']\n\n"}
{"name":"LinearIndependent.of_comp","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nM' : Type u_5\nv : ι → M\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M'\ninst✝¹ : Module R M\ninst✝ : Module R M'\nf : LinearMap (RingHom.id R) M M'\nhfv : LinearIndependent R (Function.comp (⇑f) v)\n⊢ LinearIndependent R v","decl":"/-- If the image of a family of vectors under a linear map is linearly independent, then so is\nthe original family. -/\ntheorem LinearIndependent.of_comp (f : M →ₗ[R] M') (hfv : LinearIndependent R (f ∘ v)) :\n    LinearIndependent R v := by\n  rw [LinearIndependent, Finsupp.linearCombination_linear_comp, LinearMap.coe_comp] at hfv\n  exact hfv.of_comp\n\n"}
{"name":"LinearMap.linearIndependent_iff_of_injOn","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nM' : Type u_5\nv : ι → M\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M'\ninst✝¹ : Module R M\ninst✝ : Module R M'\nf : LinearMap (RingHom.id R) M M'\nhf_inj : Set.InjOn ⇑f ↑(Submodule.span R (Set.range v))\n⊢ Iff (LinearIndependent R (Function.comp (⇑f) v)) (LinearIndependent R v)","decl":"/-- If `f` is a linear map injective on the span of the range of `v`, then the family `f ∘ v`\nis linearly independent if and only if the family `v` is linearly independent.\nSee `LinearMap.linearIndependent_iff_of_disjoint` for the version with `Set.InjOn` replaced\nby `Disjoint` when working over a ring. -/\nprotected theorem LinearMap.linearIndependent_iff_of_injOn (f : M →ₗ[R] M')\n    (hf_inj : Set.InjOn f (span R (Set.range v))) :\n    LinearIndependent R (f ∘ v) ↔ LinearIndependent R v := by\n  simp_rw [LinearIndependent, Finsupp.linearCombination_linear_comp, coe_comp]\n  rw [hf_inj.injective_iff]\n  rw [← Finsupp.range_linearCombination, LinearMap.range_coe]\n\n"}
{"name":"LinearIndependent.map_injOn","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nM' : Type u_5\nv : ι → M\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M'\ninst✝¹ : Module R M\ninst✝ : Module R M'\nhv : LinearIndependent R v\nf : LinearMap (RingHom.id R) M M'\nhf_inj : Set.InjOn ⇑f ↑(Submodule.span R (Set.range v))\n⊢ LinearIndependent R (Function.comp (⇑f) v)","decl":"/-- If a linear map is injective on the span of a family of linearly independent vectors, then\nthe family stays linearly independent after composing with the linear map.\nSee `LinearIndependent.map` for the version with `Set.InjOn` replaced by `Disjoint`\nwhen working over a ring. -/\ntheorem LinearIndependent.map_injOn (hv : LinearIndependent R v) (f : M →ₗ[R] M')\n    (hf_inj : Set.InjOn f (span R (Set.range v))) : LinearIndependent R (f ∘ v) :=\n  (f.linearIndependent_iff_of_injOn hf_inj).mpr hv\n\n"}
{"name":"linearIndependent_of_subsingleton","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nv : ι → M\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Subsingleton R\n⊢ LinearIndependent R v","decl":"@[nontriviality]\ntheorem linearIndependent_of_subsingleton [Subsingleton R] : LinearIndependent R v :=\n  linearIndependent_iffₛ.2 fun _l _l' _hl => Subsingleton.elim _ _\n\n"}
{"name":"linearIndependent_equiv","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nι' : Type u_1\nR : Type u_2\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ne : Equiv ι ι'\nf : ι' → M\n⊢ Iff (LinearIndependent R (Function.comp f ⇑e)) (LinearIndependent R f)","decl":"theorem linearIndependent_equiv (e : ι ≃ ι') {f : ι' → M} :\n    LinearIndependent R (f ∘ e) ↔ LinearIndependent R f :=\n  ⟨fun h ↦ comp_id f ▸ e.self_comp_symm ▸ h.comp _ e.symm.injective,\n    fun h ↦ h.comp _ e.injective⟩\n\n"}
{"name":"linearIndependent_equiv'","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nι' : Type u_1\nR : Type u_2\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ne : Equiv ι ι'\nf : ι' → M\ng : ι → M\nh : Eq (Function.comp f ⇑e) g\n⊢ Iff (LinearIndependent R g) (LinearIndependent R f)","decl":"theorem linearIndependent_equiv' (e : ι ≃ ι') {f : ι' → M} {g : ι → M} (h : f ∘ e = g) :\n    LinearIndependent R g ↔ LinearIndependent R f :=\n  h ▸ linearIndependent_equiv e\n\n"}
{"name":"linearIndependent_subtype_range","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"R : Type u_2\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nι : Type u_6\nf : ι → M\nhf : Function.Injective f\n⊢ Iff (LinearIndependent R Subtype.val) (LinearIndependent R f)","decl":"theorem linearIndependent_subtype_range {ι} {f : ι → M} (hf : Injective f) :\n    LinearIndependent R ((↑) : range f → M) ↔ LinearIndependent R f :=\n  Iff.symm <| linearIndependent_equiv' (Equiv.ofInjective f hf) rfl\n\n"}
{"name":"LinearIndependent.of_subtype_range","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"R : Type u_2\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nι : Type u_6\nf : ι → M\nhf : Function.Injective f\na✝ : LinearIndependent R Subtype.val\n⊢ LinearIndependent R f","decl":"alias ⟨LinearIndependent.of_subtype_range, _⟩ := linearIndependent_subtype_range\n\n"}
{"name":"LinearIndependent.to_subtype_range","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"R : Type u_2\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nι : Type u_6\nf : ι → M\nhf : LinearIndependent R f\n⊢ LinearIndependent R Subtype.val","decl":"theorem LinearIndependent.to_subtype_range {ι} {f : ι → M} (hf : LinearIndependent R f) :\n    LinearIndependent R ((↑) : range f → M) := by\n  nontriviality R\n  exact (linearIndependent_subtype_range hf.injective).2 hf\n\n"}
{"name":"LinearIndependent.to_subtype_range'","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"R : Type u_2\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nι : Type u_6\nf : ι → M\nhf : LinearIndependent R f\nt : Set M\nht : Eq (Set.range f) t\n⊢ LinearIndependent R Subtype.val","decl":"theorem LinearIndependent.to_subtype_range' {ι} {f : ι → M} (hf : LinearIndependent R f) {t}\n    (ht : range f = t) : LinearIndependent R ((↑) : t → M) :=\n  ht ▸ hf.to_subtype_range\n\n"}
{"name":"LinearIndependent.image_of_comp","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"R : Type u_2\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nι : Type u_6\nι' : Type u_7\ns : Set ι\nf : ι → ι'\ng : ι' → M\nhs : LinearIndependent R fun x => g (f ↑x)\n⊢ LinearIndependent R fun x => g ↑x","decl":"theorem LinearIndependent.image_of_comp {ι ι'} (s : Set ι) (f : ι → ι') (g : ι' → M)\n    (hs : LinearIndependent R fun x : s => g (f x)) :\n    LinearIndependent R fun x : f '' s => g x := by\n  nontriviality R\n  have : InjOn f s := injOn_iff_injective.2 hs.injective.of_comp\n  exact (linearIndependent_equiv' (Equiv.Set.imageOfInjOn f s this) rfl).1 hs\n\n"}
{"name":"LinearIndependent.image","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"R : Type u_2\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nι : Type u_6\ns : Set ι\nf : ι → M\nhs : LinearIndependent R fun x => f ↑x\n⊢ LinearIndependent R fun x => ↑x","decl":"theorem LinearIndependent.image {ι} {s : Set ι} {f : ι → M}\n    (hs : LinearIndependent R fun x : s => f x) :\n    LinearIndependent R fun x : f '' s => (x : M) := by\n  convert LinearIndependent.image_of_comp s f id hs\n\n"}
{"name":"LinearIndependent.group_smul","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\nG : Type u_6\nhG : Group G\ninst✝³ : DistribMulAction G R\ninst✝² : DistribMulAction G M\ninst✝¹ : IsScalarTower G R M\ninst✝ : SMulCommClass G R M\nv : ι → M\nhv : LinearIndependent R v\nw : ι → G\n⊢ LinearIndependent R (HSMul.hSMul w v)","decl":"theorem LinearIndependent.group_smul {G : Type*} [hG : Group G] [DistribMulAction G R]\n    [DistribMulAction G M] [IsScalarTower G R M] [SMulCommClass G R M] {v : ι → M}\n    (hv : LinearIndependent R v) (w : ι → G) : LinearIndependent R (w • v) := by\n  rw [linearIndependent_iff''ₛ] at hv ⊢\n  intro s g₁ g₂ hgs hsum i\n  refine (Group.isUnit (w i)).smul_left_cancel.mp ?_\n  refine hv s (fun i ↦ w i • g₁ i) (fun i ↦ w i • g₂ i) (fun i hi ↦ ?_) ?_ i\n  · simp_rw [hgs i hi]\n  · simpa only [smul_assoc, smul_comm] using hsum\n\n-- This lemma cannot be proved with `LinearIndependent.group_smul` since the action of\n-- `Rˣ` on `R` is not commutative.\n"}
{"name":"LinearIndependent.units_smul","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nv : ι → M\nhv : LinearIndependent R v\nw : ι → Units R\n⊢ LinearIndependent R (HSMul.hSMul w v)","decl":"theorem LinearIndependent.units_smul {v : ι → M} (hv : LinearIndependent R v) (w : ι → Rˣ) :\n    LinearIndependent R (w • v) := by\n  rw [linearIndependent_iff''ₛ] at hv ⊢\n  intro s g₁ g₂ hgs hsum i\n  rw [← (w i).mul_left_inj]\n  refine hv s (fun i ↦ g₁ i • w i) (fun i ↦ g₂ i • w i) (fun i hi ↦ ?_) ?_ i\n  · simp_rw [hgs i hi]\n  · simpa only [smul_eq_mul, mul_smul, Pi.smul_apply'] using hsum\n\n"}
{"name":"linearIndependent_image","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"R : Type u_2\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nι : Type u_6\ns : Set ι\nf : ι → M\nhf : Set.InjOn f s\n⊢ Iff (LinearIndependent R fun x => f ↑x) (LinearIndependent R fun x => ↑x)","decl":"theorem linearIndependent_image {ι} {s : Set ι} {f : ι → M} (hf : Set.InjOn f s) :\n    (LinearIndependent R fun x : s ↦ f x) ↔ LinearIndependent R fun x : f '' s => (x : M) :=\n  linearIndependent_equiv' (Equiv.Set.imageOfInjOn _ _ hf) rfl\n\n"}
{"name":"linearIndependent_span","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nv : ι → M\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nhs : LinearIndependent R v\n⊢ LinearIndependent R fun i => ⟨v i, ⋯⟩","decl":"theorem linearIndependent_span (hs : LinearIndependent R v) :\n    LinearIndependent R (M := span R (range v))\n      (fun i : ι ↦ ⟨v i, subset_span (mem_range_self i)⟩) :=\n  LinearIndependent.of_comp (span R (range v)).subtype hs\n\n"}
{"name":"linearIndependent_finset_map_embedding_subtype","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"R : Type u_2\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Set M\nli : LinearIndependent R Subtype.val\nt : Finset ↑s\n⊢ LinearIndependent R Subtype.val","decl":"/-- Every finite subset of a linearly independent set is linearly independent. -/\ntheorem linearIndependent_finset_map_embedding_subtype (s : Set M)\n    (li : LinearIndependent R ((↑) : s → M)) (t : Finset s) :\n    LinearIndependent R ((↑) : Finset.map (Embedding.subtype s) t → M) :=\n  li.comp (fun _ ↦ ⟨_, _⟩) <| by intro; aesop\n\n"}
{"name":"linearIndependent_comp_subtypeₛ","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nv : ι → M\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Set ι\n⊢ Iff (LinearIndependent R (Function.comp v Subtype.val)) (∀ (f : Finsupp ι R), Membership.mem (Finsupp.supported R R s) f → ∀ (g : Finsupp ι R), Membership.mem (Finsupp.supported R R s) g → Eq ((Finsupp.linearCombination R v) f) ((Finsupp.linearCombination R v) g) → Eq f g)","decl":"theorem linearIndependent_comp_subtypeₛ {s : Set ι} :\n    LinearIndependent R (v ∘ (↑) : s → M) ↔\n      ∀ f ∈ Finsupp.supported R R s, ∀ g ∈ Finsupp.supported R R s,\n        Finsupp.linearCombination R v f = Finsupp.linearCombination R v g → f = g := by\n  simp only [linearIndependent_iffₛ, (· ∘ ·), Finsupp.mem_supported,\n    Finsupp.linearCombination_apply, Set.subset_def, Finset.mem_coe]\n  refine ⟨fun h l₁ h₁ l₂ h₂ eq ↦ (Finsupp.subtypeDomain_eq_iff h₁ h₂).1 <| h _ _ <|\n    (Finsupp.sum_subtypeDomain_index h₁).trans eq ▸ (Finsupp.sum_subtypeDomain_index h₂).symm,\n    fun h l₁ l₂ eq ↦ ?_⟩\n  refine Finsupp.embDomain_injective (Embedding.subtype s) <| h _ ?_ _ ?_ ?_\n  iterate 2 simpa using fun _ h _ ↦ h\n  simp_rw [Finsupp.embDomain_eq_mapDomain]\n  rwa [Finsupp.sum_mapDomain_index, Finsupp.sum_mapDomain_index] <;>\n    intros <;> simp only [zero_smul, add_smul]\n\n"}
{"name":"linearDependent_comp_subtype'ₛ","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nv : ι → M\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Set ι\n⊢ Iff (Not (LinearIndependent R (Function.comp v Subtype.val))) (Exists fun f => Exists fun g => And (Membership.mem (Finsupp.supported R R s) f) (And (Membership.mem (Finsupp.supported R R s) g) (And (Eq ((Finsupp.linearCombination R v) f) ((Finsupp.linearCombination R v) g)) (Ne f g))))","decl":"theorem linearDependent_comp_subtype'ₛ {s : Set ι} :\n    ¬LinearIndependent R (v ∘ (↑) : s → M) ↔\n      ∃ f g : ι →₀ R, f ∈ Finsupp.supported R R s ∧ g ∈ Finsupp.supported R R s ∧\n        Finsupp.linearCombination R v f = Finsupp.linearCombination R v g ∧ f ≠ g := by\n  simp [linearIndependent_comp_subtypeₛ, and_left_comm]\n\n"}
{"name":"linearDependent_comp_subtypeₛ","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nv : ι → M\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Set ι\n⊢ Iff (Not (LinearIndependent R (Function.comp v Subtype.val))) (Exists fun f => Exists fun g => And (Membership.mem (Finsupp.supported R R s) f) (And (Membership.mem (Finsupp.supported R R s) g) (And (Eq (f.support.sum fun i => HSMul.hSMul (f i) (v i)) (g.support.sum fun i => HSMul.hSMul (g i) (v i))) (Ne f g))))","decl":"/-- A version of `linearDependent_comp_subtype'ₛ` with `Finsupp.linearCombination` unfolded. -/\ntheorem linearDependent_comp_subtypeₛ {s : Set ι} :\n    ¬LinearIndependent R (v ∘ (↑) : s → M) ↔\n      ∃ f g : ι →₀ R, f ∈ Finsupp.supported R R s ∧ g ∈ Finsupp.supported R R s ∧\n        ∑ i ∈ f.support, f i • v i = ∑ i ∈ g.support, g i • v i ∧ f ≠ g :=\n  linearDependent_comp_subtype'ₛ\n\n"}
{"name":"linearIndependent_subtypeₛ","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"R : Type u_2\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Set M\n⊢ Iff (LinearIndependent R fun x => ↑x) (∀ (f : Finsupp M R), Membership.mem (Finsupp.supported R R s) f → ∀ (g : Finsupp M R), Membership.mem (Finsupp.supported R R s) g → Eq ((Finsupp.linearCombination R id) f) ((Finsupp.linearCombination R id) g) → Eq f g)","decl":"theorem linearIndependent_subtypeₛ {s : Set M} :\n    LinearIndependent R (fun x ↦ x : s → M) ↔\n      ∀ f ∈ Finsupp.supported R R s, ∀ g ∈ Finsupp.supported R R s,\n        Finsupp.linearCombination R id f = Finsupp.linearCombination R id g → f = g :=\n  linearIndependent_comp_subtypeₛ (v := id)\n\n"}
{"name":"linearIndependent_restrict_iff","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nv : ι → M\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Set ι\n⊢ Iff (LinearIndependent R (s.restrict v)) (Function.Injective ⇑(Finsupp.linearCombinationOn ι M R v s))","decl":"theorem linearIndependent_restrict_iff {s : Set ι} :\n    LinearIndependent R (s.restrict v) ↔\n      Injective (Finsupp.linearCombinationOn ι M R v s) := by\n  simp [LinearIndependent, Finsupp.linearCombination_restrict]\n\n"}
{"name":"linearIndependent_iff_linearCombinationOnₛ","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"R : Type u_2\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Set M\n⊢ Iff (LinearIndependent R fun x => ↑x) (Function.Injective ⇑(Finsupp.linearCombinationOn M M R id s))","decl":"theorem linearIndependent_iff_linearCombinationOnₛ {s : Set M} :\n    LinearIndependent R (fun x ↦ x : s → M) ↔\n      Injective (Finsupp.linearCombinationOn M M R id s) :=\n  linearIndependent_restrict_iff (v := id)\n\n"}
{"name":"LinearIndependent.restrict_of_comp_subtype","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nv : ι → M\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Set ι\nhs : LinearIndependent R (Function.comp v Subtype.val)\n⊢ LinearIndependent R (s.restrict v)","decl":"theorem LinearIndependent.restrict_of_comp_subtype {s : Set ι}\n    (hs : LinearIndependent R (v ∘ (↑) : s → M)) : LinearIndependent R (s.restrict v) :=\n  hs\n\n"}
{"name":"LinearIndependent.mono","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"R : Type u_2\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nt s : Set M\nh : HasSubset.Subset t s\nhs : LinearIndependent R fun x => ↑x\n⊢ LinearIndependent R fun x => ↑x","decl":"theorem LinearIndependent.mono {t s : Set M} (h : t ⊆ s)\n    (hs : LinearIndependent R (fun x ↦ x : s → M)) : LinearIndependent R (fun x ↦ x : t → M) :=\n  hs.comp _ (Set.inclusion_injective h)\n\n"}
{"name":"linearIndependent_of_finite","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"R : Type u_2\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Set M\nH : ∀ (t : Set M), HasSubset.Subset t s → t.Finite → LinearIndependent R fun x => ↑x\n⊢ LinearIndependent R fun x => ↑x","decl":"theorem linearIndependent_of_finite (s : Set M)\n    (H : ∀ t ⊆ s, Set.Finite t → LinearIndependent R (fun x ↦ x : t → M)) :\n    LinearIndependent R (fun x ↦ x : s → M) :=\n  linearIndependent_subtypeₛ.2 fun f hf g hg eq ↦\n    linearIndependent_subtypeₛ.1 (H _ (union_subset hf hg) <| (Finset.finite_toSet _).union <|\n      Finset.finite_toSet _) f Set.subset_union_left g Set.subset_union_right eq\n\n"}
{"name":"linearIndependent_iUnion_of_directed","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"R : Type u_2\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nη : Type u_6\ns : η → Set M\nhs : Directed (fun x1 x2 => HasSubset.Subset x1 x2) s\nh : ∀ (i : η), LinearIndependent R fun x => ↑x\n⊢ LinearIndependent R fun x => ↑x","decl":"theorem linearIndependent_iUnion_of_directed {η : Type*} {s : η → Set M} (hs : Directed (· ⊆ ·) s)\n    (h : ∀ i, LinearIndependent R (fun x ↦ x : s i → M)) :\n    LinearIndependent R (fun x ↦ x : (⋃ i, s i) → M) := by\n  by_cases hη : Nonempty η\n  · refine linearIndependent_of_finite (⋃ i, s i) fun t ht ft => ?_\n    rcases finite_subset_iUnion ft ht with ⟨I, fi, hI⟩\n    rcases hs.finset_le fi.toFinset with ⟨i, hi⟩\n    exact (h i).mono (Subset.trans hI <| iUnion₂_subset fun j hj => hi j (fi.mem_toFinset.2 hj))\n  · refine (linearIndependent_empty R M).mono (t := iUnion (s ·)) ?_\n    rintro _ ⟨_, ⟨i, _⟩, _⟩\n    exact hη ⟨i⟩\n\n"}
{"name":"linearIndependent_sUnion_of_directed","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"R : Type u_2\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Set (Set M)\nhs : DirectedOn (fun x1 x2 => HasSubset.Subset x1 x2) s\nh : ∀ (a : Set M), Membership.mem s a → LinearIndependent R Subtype.val\n⊢ LinearIndependent R fun x => ↑x","decl":"theorem linearIndependent_sUnion_of_directed {s : Set (Set M)} (hs : DirectedOn (· ⊆ ·) s)\n    (h : ∀ a ∈ s, LinearIndependent R ((↑) : ((a : Set M) : Type _) → M)) :\n    LinearIndependent R (fun x => x : ⋃₀ s → M) := by\n  rw [sUnion_eq_iUnion]\n  exact linearIndependent_iUnion_of_directed hs.directed_val (by simpa using h)\n\n"}
{"name":"linearIndependent_biUnion_of_directed","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"R : Type u_2\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nη : Type u_6\ns : Set η\nt : η → Set M\nhs : DirectedOn (Order.Preimage t fun x1 x2 => HasSubset.Subset x1 x2) s\nh : ∀ (a : η), Membership.mem s a → LinearIndependent R fun x => ↑x\n⊢ LinearIndependent R fun x => ↑x","decl":"theorem linearIndependent_biUnion_of_directed {η} {s : Set η} {t : η → Set M}\n    (hs : DirectedOn (t ⁻¹'o (· ⊆ ·)) s) (h : ∀ a ∈ s, LinearIndependent R (fun x ↦ x : t a → M)) :\n    LinearIndependent R (fun x ↦ x : (⋃ a ∈ s, t a) → M) := by\n  rw [biUnion_eq_iUnion]\n  exact\n    linearIndependent_iUnion_of_directed (directed_comp.2 <| hs.directed_val) (by simpa using h)\n\n"}
{"name":"LinearIndependent.eq_of_smul_apply_eq_smul_apply","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\ninst✝² : Semiring R\nM : Type u_6\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nv : ι → M\nli : LinearIndependent R v\nc d : R\ni j : ι\nhc : Ne c 0\nh : Eq (HSMul.hSMul c (v i)) (HSMul.hSMul d (v j))\n⊢ Eq i j","decl":"/-- Linear independent families are injective, even if you multiply either side. -/\ntheorem LinearIndependent.eq_of_smul_apply_eq_smul_apply {M : Type*} [AddCommMonoid M] [Module R M]\n    {v : ι → M} (li : LinearIndependent R v) (c d : R) (i j : ι) (hc : c ≠ 0)\n    (h : c • v i = d • v j) : i = j := by\n  have h_single_eq : Finsupp.single i c = Finsupp.single j d :=\n    li <| by simpa [Finsupp.linearCombination_apply] using h\n  rcases (Finsupp.single_eq_single_iff ..).mp h_single_eq with (⟨H, _⟩ | ⟨hc, _⟩)\n  · exact H\n  · contradiction\n\n"}
{"name":"LinearIndependent.disjoint_span_image","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nv : ι → M\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nhv : LinearIndependent R v\ns t : Set ι\nhs : Disjoint s t\n⊢ Disjoint (Submodule.span R (Set.image v s)) (Submodule.span R (Set.image v t))","decl":"theorem LinearIndependent.disjoint_span_image (hv : LinearIndependent R v) {s t : Set ι}\n    (hs : Disjoint s t) : Disjoint (Submodule.span R <| v '' s) (Submodule.span R <| v '' t) := by\n  simp only [disjoint_def, Finsupp.mem_span_image_iff_linearCombination]\n  rintro _ ⟨l₁, hl₁, rfl⟩ ⟨l₂, hl₂, H⟩\n  rw [hv.injective_linearCombination.eq_iff] at H; subst l₂\n  have : l₁ = 0 := Submodule.disjoint_def.mp (Finsupp.disjoint_supported_supported hs) _ hl₁ hl₂\n  simp [this]\n\n"}
{"name":"LinearIndependent.not_mem_span_image","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nv : ι → M\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Nontrivial R\nhv : LinearIndependent R v\ns : Set ι\nx : ι\nh : Not (Membership.mem s x)\n⊢ Not (Membership.mem (Submodule.span R (Set.image v s)) (v x))","decl":"theorem LinearIndependent.not_mem_span_image [Nontrivial R] (hv : LinearIndependent R v) {s : Set ι}\n    {x : ι} (h : x ∉ s) : v x ∉ Submodule.span R (v '' s) := by\n  have h' : v x ∈ Submodule.span R (v '' {x}) := by\n    rw [Set.image_singleton]\n    exact mem_span_singleton_self (v x)\n  intro w\n  apply LinearIndependent.ne_zero x hv\n  refine disjoint_def.1 (hv.disjoint_span_image ?_) (v x) h' w\n  simpa using h\n\n"}
{"name":"LinearIndependent.linearCombination_ne_of_not_mem_support","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nv : ι → M\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Nontrivial R\nhv : LinearIndependent R v\nx : ι\nf : Finsupp ι R\nh : Not (Membership.mem f.support x)\n⊢ Ne ((Finsupp.linearCombination R v) f) (v x)","decl":"theorem LinearIndependent.linearCombination_ne_of_not_mem_support [Nontrivial R]\n    (hv : LinearIndependent R v) {x : ι} (f : ι →₀ R) (h : x ∉ f.support) :\n    Finsupp.linearCombination R v f ≠ v x := by\n  replace h : x ∉ (f.support : Set ι) := h\n  have p := hv.not_mem_span_image h\n  intro w\n  rw [← w] at p\n  rw [Finsupp.span_image_eq_map_linearCombination] at p\n  simp only [not_exists, not_and, mem_map] at p -- Porting note: `mem_map` isn't currently triggered\n  exact p f (f.mem_supported_support R) rfl\n\n"}
{"name":"LinearIndependent.total_ne_of_not_mem_support","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nv : ι → M\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Nontrivial R\nhv : LinearIndependent R v\nx : ι\nf : Finsupp ι R\nh : Not (Membership.mem f.support x)\n⊢ Ne ((Finsupp.linearCombination R v) f) (v x)","decl":"@[deprecated (since := \"2024-08-29\")] alias LinearIndependent.total_ne_of_not_mem_support :=\n  LinearIndependent.linearCombination_ne_of_not_mem_support\n\n"}
{"name":"LinearIndependent.linearCombinationEquiv_symm_apply","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nv : ι → M\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nhv : LinearIndependent R v\na✝ : Subtype fun x => Membership.mem (Submodule.span R (Set.range v)) x\n⊢ Eq (hv.linearCombinationEquiv.symm a✝) (((LinearEquiv.ofInjective (LinearMap.codRestrict (Submodule.span R (Set.range v)) (Finsupp.linearCombination R v) ⋯) ⋯).toEquiv.trans (LinearEquiv.ofTop (LinearMap.range (LinearMap.codRestrict (Submodule.span R (Set.range v)) (Finsupp.linearCombination R v) ⋯)) ⋯).toEquiv).invFun a✝)","decl":"/-- Canonical isomorphism between linear combinations and the span of linearly independent vectors.\n-/\n@[simps (config := { rhsMd := default }) symm_apply]\ndef LinearIndependent.linearCombinationEquiv (hv : LinearIndependent R v) :\n    (ι →₀ R) ≃ₗ[R] span R (range v) := by\n  refine LinearEquiv.ofBijective (LinearMap.codRestrict (span R (range v))\n                                 (Finsupp.linearCombination R v) ?_) ⟨hv.codRestrict _, ?_⟩\n  · simp_rw [← Finsupp.range_linearCombination]; exact fun c ↦ ⟨c, rfl⟩\n  rw [← LinearMap.range_eq_top, LinearMap.range_eq_map, LinearMap.map_codRestrict,\n    ← LinearMap.range_le_iff_comap, range_subtype, Submodule.map_top,\n    Finsupp.range_linearCombination]\n\n"}
{"name":"LinearIndependent.linearCombinationEquiv_apply_coe","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nv : ι → M\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nhv : LinearIndependent R v\nl : Finsupp ι R\n⊢ Eq (↑(hv.linearCombinationEquiv l)) ((Finsupp.linearCombination R v) l)","decl":"@[simp]\ntheorem LinearIndependent.linearCombinationEquiv_apply_coe (hv : LinearIndependent R v)\n    (l : ι →₀ R) : hv.linearCombinationEquiv l = Finsupp.linearCombination R v l := rfl\n\n"}
{"name":"LinearIndependent.totalEquiv_apply_coe","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nv : ι → M\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nhv : LinearIndependent R v\nl : Finsupp ι R\n⊢ Eq (↑(hv.linearCombinationEquiv l)) ((Finsupp.linearCombination R v) l)","decl":"@[deprecated (since := \"2024-08-29\")] alias LinearIndependent.totalEquiv_apply_coe :=\n  LinearIndependent.linearCombinationEquiv_apply_coe\n"}
{"name":"LinearIndependent.linearCombination_repr","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nv : ι → M\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nhv : LinearIndependent R v\nx : Subtype fun x => Membership.mem (Submodule.span R (Set.range v)) x\n⊢ Eq ((Finsupp.linearCombination R v) (hv.repr x)) ↑x","decl":"@[simp]\ntheorem LinearIndependent.linearCombination_repr (x) :\n    Finsupp.linearCombination R v (hv.repr x) = x :=\n  Subtype.ext_iff.1 (LinearEquiv.apply_symm_apply hv.linearCombinationEquiv x)\n\n"}
{"name":"LinearIndependent.total_repr","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nv : ι → M\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nhv : LinearIndependent R v\nx : Subtype fun x => Membership.mem (Submodule.span R (Set.range v)) x\n⊢ Eq ((Finsupp.linearCombination R v) (hv.repr x)) ↑x","decl":"@[deprecated (since := \"2024-08-29\")] alias LinearIndependent.total_repr :=\n  LinearIndependent.linearCombination_repr\n\n"}
{"name":"LinearIndependent.linearCombination_comp_repr","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nv : ι → M\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nhv : LinearIndependent R v\n⊢ Eq ((Finsupp.linearCombination R v).comp hv.repr) (Submodule.span R (Set.range v)).subtype","decl":"theorem LinearIndependent.linearCombination_comp_repr :\n    (Finsupp.linearCombination R v).comp hv.repr = Submodule.subtype _ :=\n  LinearMap.ext <| hv.linearCombination_repr\n\n"}
{"name":"LinearIndependent.total_comp_repr","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nv : ι → M\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nhv : LinearIndependent R v\n⊢ Eq ((Finsupp.linearCombination R v).comp hv.repr) (Submodule.span R (Set.range v)).subtype","decl":"@[deprecated (since := \"2024-08-29\")] alias LinearIndependent.total_comp_repr :=\n  LinearIndependent.linearCombination_comp_repr\n\n"}
{"name":"LinearIndependent.repr_ker","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nv : ι → M\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nhv : LinearIndependent R v\n⊢ Eq (LinearMap.ker hv.repr) Bot.bot","decl":"theorem LinearIndependent.repr_ker : LinearMap.ker hv.repr = ⊥ := by\n  rw [LinearIndependent.repr, LinearEquiv.ker]\n\n"}
{"name":"LinearIndependent.repr_range","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nv : ι → M\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nhv : LinearIndependent R v\n⊢ Eq (LinearMap.range hv.repr) Top.top","decl":"theorem LinearIndependent.repr_range : LinearMap.range hv.repr = ⊤ := by\n  rw [LinearIndependent.repr, LinearEquiv.range]\n\n"}
{"name":"LinearIndependent.repr_eq","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nv : ι → M\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nhv : LinearIndependent R v\nl : Finsupp ι R\nx : Subtype fun x => Membership.mem (Submodule.span R (Set.range v)) x\neq : Eq ((Finsupp.linearCombination R v) l) ↑x\n⊢ Eq (hv.repr x) l","decl":"theorem LinearIndependent.repr_eq {l : ι →₀ R} {x : span R (range v)}\n    (eq : Finsupp.linearCombination R v l = ↑x) : hv.repr x = l := by\n  have :\n    ↑((LinearIndependent.linearCombinationEquiv hv : (ι →₀ R) →ₗ[R] span R (range v)) l) =\n      Finsupp.linearCombination R v l :=\n    rfl\n  have : (LinearIndependent.linearCombinationEquiv hv : (ι →₀ R) →ₗ[R] span R (range v)) l = x := by\n    rw [eq] at this\n    exact Subtype.ext_iff.2 this\n  rw [← LinearEquiv.symm_apply_apply hv.linearCombinationEquiv l]\n  rw [← this]\n  rfl\n\n"}
{"name":"LinearIndependent.repr_eq_single","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nv : ι → M\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nhv : LinearIndependent R v\ni : ι\nx : Subtype fun x => Membership.mem (Submodule.span R (Set.range v)) x\nhx : Eq (↑x) (v i)\n⊢ Eq (hv.repr x) (Finsupp.single i 1)","decl":"theorem LinearIndependent.repr_eq_single (i) (x : span R (range v)) (hx : ↑x = v i) :\n    hv.repr x = Finsupp.single i 1 := by\n  apply hv.repr_eq\n  simp [Finsupp.linearCombination_single, hx]\n\n"}
{"name":"LinearIndependent.span_repr_eq","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nv : ι → M\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\nhv : LinearIndependent R v\ninst✝ : Nontrivial R\nx : Subtype fun x => Membership.mem (Submodule.span R (Set.range v)) x\n⊢ Eq (Span.repr R (Set.range v) x) (Finsupp.equivMapDomain (Equiv.ofInjective v ⋯) (hv.repr x))","decl":"theorem LinearIndependent.span_repr_eq [Nontrivial R] (x) :\n    Span.repr R (Set.range v) x =\n      (hv.repr x).equivMapDomain (Equiv.ofInjective _ hv.injective) := by\n  have p :\n    (Span.repr R (Set.range v) x).equivMapDomain (Equiv.ofInjective _ hv.injective).symm =\n      hv.repr x := by\n    apply (LinearIndependent.linearCombinationEquiv hv).injective\n    ext\n    simp only [LinearIndependent.linearCombinationEquiv_apply_coe, Equiv.self_comp_ofInjective_symm,\n      LinearIndependent.linearCombination_repr, Finsupp.linearCombination_equivMapDomain,\n      Span.finsupp_linearCombination_repr]\n  ext ⟨_, ⟨i, rfl⟩⟩\n  simp [← p]\n\n"}
{"name":"LinearIndependent.not_smul_mem_span","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nv : ι → M\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nhv : LinearIndependent R v\ni : ι\na : R\nha : Membership.mem (Submodule.span R (Set.image v (SDiff.sdiff Set.univ (Singleton.singleton i)))) (HSMul.hSMul a (v i))\n⊢ Eq a 0","decl":"theorem LinearIndependent.not_smul_mem_span (hv : LinearIndependent R v) (i : ι) (a : R)\n    (ha : a • v i ∈ span R (v '' (univ \\ {i}))) : a = 0 := by\n  rw [Finsupp.span_image_eq_map_linearCombination, mem_map] at ha\n  rcases ha with ⟨l, hl, e⟩\n  rw [linearIndependent_iffₛ.1 hv l (Finsupp.single i a) (by simp [e])] at hl\n  by_contra hn\n  exact (not_mem_of_mem_diff (hl <| by simp [hn])) (mem_singleton _)\n\n"}
{"name":"LinearIndependent.iSupIndep_span_singleton","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nv : ι → M\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nhv : LinearIndependent R v\n⊢ iSupIndep fun i => Submodule.span R (Singleton.singleton (v i))","decl":"/-- See also `iSupIndep_iff_linearIndependent_of_ne_zero`. -/\ntheorem LinearIndependent.iSupIndep_span_singleton (hv : LinearIndependent R v) :\n    iSupIndep fun i => R ∙ v i := by\n  refine iSupIndep_def.mp fun i => ?_\n  rw [disjoint_iff_inf_le]\n  intro m hm\n  simp only [mem_inf, mem_span_singleton, iSup_subtype'] at hm\n  rw [← span_range_eq_iSup] at hm\n  obtain ⟨⟨r, rfl⟩, hm⟩ := hm\n  suffices r = 0 by simp [this]\n  apply hv.not_smul_mem_span i\n  convert hm\n  ext\n  simp\n\n"}
{"name":"LinearIndependent.independent_span_singleton","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nv : ι → M\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nhv : LinearIndependent R v\n⊢ iSupIndep fun i => Submodule.span R (Singleton.singleton (v i))","decl":"@[deprecated (since := \"2024-11-24\")]\nalias LinearIndependent.independent_span_singleton := LinearIndependent.iSupIndep_span_singleton\n\n"}
{"name":"LinearIndependent.image_subtypeₛ","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"R : Type u_2\nM : Type u_4\nM' : Type u_5\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M'\ninst✝¹ : Module R M\ninst✝ : Module R M'\ns : Set M\nf : LinearMap (RingHom.id R) M M'\nhs : LinearIndependent R fun x => ↑x\nhf_inj : Set.InjOn ⇑f ↑(Submodule.span R s)\n⊢ LinearIndependent R fun x => ↑x","decl":"theorem LinearIndependent.image_subtypeₛ {s : Set M} {f : M →ₗ[R] M'}\n    (hs : LinearIndependent R (fun x ↦ x : s → M))\n    (hf_inj : Set.InjOn f (span R s)) :\n    LinearIndependent R (fun x ↦ x : f '' s → M') := by\n  rw [← Subtype.range_coe (s := s)] at hf_inj\n  refine (hs.map_injOn f hf_inj).to_subtype_range' ?_\n  simp [Set.range_comp f]\n\n"}
{"name":"linearIndependent_inl_union_inr'","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nι' : Type u_1\nR : Type u_2\nM : Type u_4\nM' : Type u_5\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M'\ninst✝¹ : Module R M\ninst✝ : Module R M'\nv : ι → M\nv' : ι' → M'\nhv : LinearIndependent R v\nhv' : LinearIndependent R v'\n⊢ LinearIndependent R (Sum.elim (Function.comp (⇑(LinearMap.inl R M M')) v) (Function.comp (⇑(LinearMap.inr R M M')) v'))","decl":"theorem linearIndependent_inl_union_inr' {v : ι → M} {v' : ι' → M'}\n    (hv : LinearIndependent R v) (hv' : LinearIndependent R v') :\n    LinearIndependent R (Sum.elim (inl R M M' ∘ v) (inr R M M' ∘ v')) := by\n  have : linearCombination R (Sum.elim (inl R M M' ∘ v) (inr R M M' ∘ v')) =\n      .prodMap (linearCombination R v) (linearCombination R v') ∘ₗ\n      (sumFinsuppLEquivProdFinsupp R).toLinearMap := by\n    ext (_ | _) <;> simp [linearCombination_comapDomain]\n  rw [LinearIndependent, this]\n  simpa [LinearMap.coe_prodMap] using ⟨hv, hv'⟩\n\n"}
{"name":"LinearIndependent.inl_union_inr","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"R : Type u_2\nM : Type u_4\nM' : Type u_5\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M'\ninst✝¹ : Module R M\ninst✝ : Module R M'\ns : Set M\nt : Set M'\nhs : LinearIndependent R fun x => ↑x\nht : LinearIndependent R fun x => ↑x\n⊢ LinearIndependent R fun x => ↑x","decl":"theorem LinearIndependent.inl_union_inr {s : Set M} {t : Set M'}\n    (hs : LinearIndependent R (fun x => x : s → M))\n    (ht : LinearIndependent R (fun x => x : t → M')) :\n    LinearIndependent R (fun x => x : ↥(inl R M M' '' s ∪ inr R M M' '' t) → M × M') := by\n  nontriviality R\n  let e : s ⊕ t ≃ ↥(inl R M M' '' s ∪ inr R M M' '' t) :=\n    .ofBijective (Sum.elim (fun i ↦ ⟨_, .inl ⟨_, i.2, rfl⟩⟩) fun i ↦ ⟨_, .inr ⟨_, i.2, rfl⟩⟩)\n      ⟨by rintro (_|_) (_|_) eq <;> simp [hs.ne_zero, ht.ne_zero] at eq <;> aesop,\n        by rintro ⟨_, ⟨_, _, rfl⟩ | ⟨_, _, rfl⟩⟩ <;> aesop⟩\n  refine (linearIndependent_equiv' e ?_).mp (linearIndependent_inl_union_inr' hs ht)\n  ext (_ | _) <;> rfl\n\n"}
{"name":"LinearIndependent.maximal_iff","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type w\nR : Type u\ninst✝³ : Semiring R\ninst✝² : Nontrivial R\nM : Type v\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nv : ι → M\ni : LinearIndependent R v\n⊢ Iff i.Maximal (∀ (κ : Type v) (w : κ → M), LinearIndependent R w → ∀ (j : ι → κ), Eq (Function.comp w j) v → Function.Surjective j)","decl":"/-- An alternative characterization of a maximal linearly independent family,\nquantifying over types (in the same universe as `M`) into which the indexing family injects.\n-/\ntheorem LinearIndependent.maximal_iff {ι : Type w} {R : Type u} [Semiring R] [Nontrivial R]\n    {M : Type v} [AddCommMonoid M] [Module R M] {v : ι → M} (i : LinearIndependent R v) :\n    i.Maximal ↔\n      ∀ (κ : Type v) (w : κ → M) (_i' : LinearIndependent R w) (j : ι → κ) (_h : w ∘ j = v),\n        Surjective j := by\n  constructor\n  · rintro p κ w i' j rfl\n    specialize p (range w) i'.coe_range (range_comp_subset_range _ _)\n    rw [range_comp, ← image_univ (f := w)] at p\n    exact range_eq_univ.mp (image_injective.mpr i'.injective p)\n  · intro p w i' h\n    specialize\n      p w ((↑) : w → M) i' (fun i => ⟨v i, range_subset_iff.mp h i⟩)\n        (by\n          ext\n          simp)\n    have q := congr_arg (fun s => ((↑) : w → M) '' s) p.range_eq\n    dsimp at q\n    rw [← image_univ, image_image] at q\n    simpa using q\n\n"}
{"name":"exists_maximal_independent'","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : ι → M\n⊢ Exists fun I => And (LinearIndependent R fun x => s ↑x) (∀ (J : Set ι), HasSubset.Subset I J → (LinearIndependent R fun x => s ↑x) → Eq I J)","decl":"theorem exists_maximal_independent' (s : ι → M) :\n    ∃ I : Set ι,\n      (LinearIndependent R fun x : I => s x) ∧\n        ∀ J : Set ι, I ⊆ J → (LinearIndependent R fun x : J => s x) → I = J := by\n  let indep : Set ι → Prop := fun I => LinearIndependent R (s ∘ (↑) : I → M)\n  let X := { I : Set ι // indep I }\n  let r : X → X → Prop := fun I J => I.1 ⊆ J.1\n  have key : ∀ c : Set X, IsChain r c → indep (⋃ (I : X) (_ : I ∈ c), I) := by\n    intro c hc\n    dsimp [indep]\n    rw [linearIndependent_comp_subtypeₛ]\n    intro f hfsupp g hgsupp hsum\n    rcases eq_empty_or_nonempty c with (rfl | hn)\n    · rw [show f = 0 by simpa using hfsupp, show g = 0 by simpa using hgsupp]\n    haveI : IsRefl X r := ⟨fun _ => Set.Subset.refl _⟩\n    classical\n    obtain ⟨I, _I_mem, hI⟩ : ∃ I ∈ c, (f.support ∪ g.support : Set ι) ⊆ I :=\n      f.support.coe_union _ ▸ hc.directedOn.exists_mem_subset_of_finset_subset_biUnion hn <| by\n        simpa using And.intro hfsupp hgsupp\n    exact linearIndependent_comp_subtypeₛ.mp I.2 f (subset_union_left.trans hI)\n      g (subset_union_right.trans hI) hsum\n  have trans : Transitive r := fun I J K => Set.Subset.trans\n  obtain ⟨⟨I, hli : indep I⟩, hmax : ∀ a, r ⟨I, hli⟩ a → r a ⟨I, hli⟩⟩ :=\n    exists_maximal_of_chains_bounded\n      (fun c hc => ⟨⟨⋃ I ∈ c, (I : Set ι), key c hc⟩, fun I => Set.subset_biUnion_of_mem⟩) @trans\n  exact ⟨I, hli, fun J hsub hli => Set.Subset.antisymm hsub (hmax ⟨J, hli⟩ hsub)⟩\n\n"}
{"name":"surjective_of_linearIndependent_of_span","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nι' : Type u_1\nR : Type u_2\nM : Type u_4\nv : ι → M\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Nontrivial R\nhv : LinearIndependent R v\nf : Function.Embedding ι' ι\nhss : HasSubset.Subset (Set.range v) ↑(Submodule.span R (Set.range (Function.comp v ⇑f)))\n⊢ Function.Surjective ⇑f","decl":"theorem surjective_of_linearIndependent_of_span [Nontrivial R] (hv : LinearIndependent R v)\n    (f : ι' ↪ ι) (hss : range v ⊆ span R (range (v ∘ f))) : Surjective f := by\n  intro i\n  let repr : (span R (range (v ∘ f)) : Type _) → ι' →₀ R := (hv.comp f f.injective).repr\n  let l := (repr ⟨v i, hss (mem_range_self i)⟩).mapDomain f\n  have h_total_l : Finsupp.linearCombination R v l = v i := by\n    dsimp only [l]\n    rw [Finsupp.linearCombination_mapDomain]\n    rw [(hv.comp f f.injective).linearCombination_repr]\n    -- Porting note: `rfl` isn't necessary.\n  have h_total_eq : Finsupp.linearCombination R v l = Finsupp.linearCombination R v\n       (Finsupp.single i 1) := by\n    rw [h_total_l, Finsupp.linearCombination_single, one_smul]\n  have l_eq : l = _ := hv h_total_eq\n  dsimp only [l] at l_eq\n  rw [← Finsupp.embDomain_eq_mapDomain] at l_eq\n  rcases Finsupp.single_of_embDomain_single (repr ⟨v i, _⟩) f i (1 : R) zero_ne_one.symm l_eq with\n    ⟨i', hi'⟩\n  use i'\n  exact hi'.2\n\n"}
{"name":"eq_of_linearIndependent_of_span_subtype","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"R : Type u_2\nM : Type u_4\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Nontrivial R\ns t : Set M\nhs : LinearIndependent R fun x => ↑x\nh : HasSubset.Subset t s\nhst : HasSubset.Subset s ↑(Submodule.span R t)\n⊢ Eq s t","decl":"theorem eq_of_linearIndependent_of_span_subtype [Nontrivial R] {s t : Set M}\n    (hs : LinearIndependent R (fun x => x : s → M)) (h : t ⊆ s) (hst : s ⊆ span R t) : s = t := by\n  let f : t ↪ s :=\n    ⟨fun x => ⟨x.1, h x.2⟩, fun a b hab => Subtype.coe_injective (Subtype.mk.inj hab)⟩\n  have h_surj : Surjective f := by\n    apply surjective_of_linearIndependent_of_span hs f _\n    convert hst <;> simp [f, comp_def]\n  show s = t\n  apply Subset.antisymm _ h\n  intro x hx\n  rcases h_surj ⟨x, hx⟩ with ⟨y, hy⟩\n  convert y.mem\n  rw [← Subtype.mk.inj hy]\n\n"}
{"name":"le_of_span_le_span","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"R : Type u_2\nM : Type u_4\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Nontrivial R\ns t u : Set M\nhl : LinearIndependent R Subtype.val\nhsu : HasSubset.Subset s u\nhtu : HasSubset.Subset t u\nhst : LE.le (Submodule.span R s) (Submodule.span R t)\n⊢ HasSubset.Subset s t","decl":"theorem le_of_span_le_span [Nontrivial R] {s t u : Set M} (hl : LinearIndependent R ((↑) : u → M))\n    (hsu : s ⊆ u) (htu : t ⊆ u) (hst : span R s ≤ span R t) : s ⊆ t := by\n  have :=\n    eq_of_linearIndependent_of_span_subtype (hl.mono (Set.union_subset hsu htu))\n      Set.subset_union_right (Set.union_subset (Set.Subset.trans subset_span hst) subset_span)\n  rw [← this]; apply Set.subset_union_left\n\n"}
{"name":"span_le_span_iff","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"R : Type u_2\nM : Type u_4\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Nontrivial R\ns t u : Set M\nhl : LinearIndependent R Subtype.val\nhsu : HasSubset.Subset s u\nhtu : HasSubset.Subset t u\n⊢ Iff (LE.le (Submodule.span R s) (Submodule.span R t)) (HasSubset.Subset s t)","decl":"theorem span_le_span_iff [Nontrivial R] {s t u : Set M} (hl : LinearIndependent R ((↑) : u → M))\n    (hsu : s ⊆ u) (htu : t ⊆ u) : span R s ≤ span R t ↔ s ⊆ t :=\n  ⟨le_of_span_le_span hl hsu htu, span_mono⟩\n\n"}
{"name":"linearIndependent_iff_ker","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nv : ι → M\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Iff (LinearIndependent R v) (Eq (LinearMap.ker (Finsupp.linearCombination R v)) Bot.bot)","decl":"theorem linearIndependent_iff_ker :\n    LinearIndependent R v ↔ LinearMap.ker (Finsupp.linearCombination R v) = ⊥ :=\n  LinearMap.ker_eq_bot.symm\n\n"}
{"name":"linearIndependent_iff","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nv : ι → M\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Iff (LinearIndependent R v) (∀ (l : Finsupp ι R), Eq ((Finsupp.linearCombination R v) l) 0 → Eq l 0)","decl":"theorem linearIndependent_iff :\n    LinearIndependent R v ↔ ∀ l, Finsupp.linearCombination R v l = 0 → l = 0 := by\n  simp [linearIndependent_iff_ker, LinearMap.ker_eq_bot']\n\n"}
{"name":"linearIndependent_iff'","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nv : ι → M\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Iff (LinearIndependent R v) (∀ (s : Finset ι) (g : ι → R), Eq (s.sum fun i => HSMul.hSMul (g i) (v i)) 0 → ∀ (i : ι), Membership.mem s i → Eq (g i) 0)","decl":"theorem linearIndependent_iff' :\n    LinearIndependent R v ↔\n      ∀ s : Finset ι, ∀ g : ι → R, ∑ i ∈ s, g i • v i = 0 → ∀ i ∈ s, g i = 0 := by\n  rw [linearIndependent_iff'ₛ]\n  refine ⟨fun h s f ↦ ?_, fun h s f g ↦ ?_⟩\n  · convert h s f 0; simp_rw [Pi.zero_apply, zero_smul, Finset.sum_const_zero]\n  · rw [← sub_eq_zero, ← Finset.sum_sub_distrib]\n    convert h s (f - g) using 3 <;> simp only [Pi.sub_apply, sub_smul, sub_eq_zero]\n\n"}
{"name":"linearIndependent_iff''","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nv : ι → M\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Iff (LinearIndependent R v) (∀ (s : Finset ι) (g : ι → R), (∀ (i : ι), Not (Membership.mem s i) → Eq (g i) 0) → Eq (s.sum fun i => HSMul.hSMul (g i) (v i)) 0 → ∀ (i : ι), Eq (g i) 0)","decl":"theorem linearIndependent_iff'' :\n    LinearIndependent R v ↔\n      ∀ (s : Finset ι) (g : ι → R), (∀ i ∉ s, g i = 0) → ∑ i ∈ s, g i • v i = 0 → ∀ i, g i = 0 := by\n  classical\n  exact linearIndependent_iff'.trans\n    ⟨fun H s g hg hv i => if his : i ∈ s then H s g hv i his else hg i his, fun H s g hg i hi => by\n      convert\n        H s (fun j => if j ∈ s then g j else 0) (fun j hj => if_neg hj)\n          (by simp_rw [ite_smul, zero_smul, Finset.sum_extend_by_zero, hg]) i\n      exact (if_pos hi).symm⟩\n\n"}
{"name":"not_linearIndependent_iff","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nv : ι → M\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Iff (Not (LinearIndependent R v)) (Exists fun s => Exists fun g => And (Eq (s.sum fun i => HSMul.hSMul (g i) (v i)) 0) (Exists fun i => And (Membership.mem s i) (Ne (g i) 0)))","decl":"theorem not_linearIndependent_iff :\n    ¬LinearIndependent R v ↔\n      ∃ s : Finset ι, ∃ g : ι → R, ∑ i ∈ s, g i • v i = 0 ∧ ∃ i ∈ s, g i ≠ 0 := by\n  rw [linearIndependent_iff']\n  simp only [exists_prop, not_forall]\n\n"}
{"name":"Fintype.linearIndependent_iff","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nv : ι → M\ninst✝³ : Ring R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : Fintype ι\n⊢ Iff (LinearIndependent R v) (∀ (g : ι → R), Eq (Finset.univ.sum fun i => HSMul.hSMul (g i) (v i)) 0 → ∀ (i : ι), Eq (g i) 0)","decl":"theorem Fintype.linearIndependent_iff [Fintype ι] :\n    LinearIndependent R v ↔ ∀ g : ι → R, ∑ i, g i • v i = 0 → ∀ i, g i = 0 := by\n  refine\n    ⟨fun H g => by simpa using linearIndependent_iff'.1 H Finset.univ g, fun H =>\n      linearIndependent_iff''.2 fun s g hg hs i => H _ ?_ _⟩\n  rw [← hs]\n  refine (Finset.sum_subset (Finset.subset_univ _) fun i _ hi => ?_).symm\n  rw [hg i hi, zero_smul]\n\n"}
{"name":"Fintype.linearIndependent_iff'","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nv : ι → M\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\n⊢ Iff (LinearIndependent R v) (Eq (LinearMap.ker ((LinearMap.lsum R (fun x => R) Nat) fun i => LinearMap.id.smulRight (v i))) Bot.bot)","decl":"/-- A finite family of vectors `v i` is linear independent iff the linear map that sends\n`c : ι → R` to `∑ i, c i • v i` has the trivial kernel. -/\ntheorem Fintype.linearIndependent_iff' [Fintype ι] [DecidableEq ι] :\n    LinearIndependent R v ↔\n      LinearMap.ker (LinearMap.lsum R (fun _ ↦ R) ℕ fun i ↦ LinearMap.id.smulRight (v i)) = ⊥ := by\n  simp [Fintype.linearIndependent_iff, LinearMap.ker_eq_bot', funext_iff]\n\n"}
{"name":"Fintype.not_linearIndependent_iff","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nv : ι → M\ninst✝³ : Ring R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : Fintype ι\n⊢ Iff (Not (LinearIndependent R v)) (Exists fun g => And (Eq (Finset.univ.sum fun i => HSMul.hSMul (g i) (v i)) 0) (Exists fun i => Ne (g i) 0))","decl":"theorem Fintype.not_linearIndependent_iff [Fintype ι] :\n    ¬LinearIndependent R v ↔ ∃ g : ι → R, ∑ i, g i • v i = 0 ∧ ∃ i, g i ≠ 0 := by\n  simpa using not_iff_not.2 Fintype.linearIndependent_iff\n\n"}
{"name":"LinearIndependent.pair_iff","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"R : Type u_2\nM : Type u_4\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nx y : M\n⊢ Iff (LinearIndependent R (Matrix.vecCons x (Matrix.vecCons y Matrix.vecEmpty))) (∀ (s t : R), Eq (HAdd.hAdd (HSMul.hSMul s x) (HSMul.hSMul t y)) 0 → And (Eq s 0) (Eq t 0))","decl":"/-- Also see `LinearIndependent.pair_iff'` for a simpler version over fields. -/\nlemma LinearIndependent.pair_iff {x y : M} :\n    LinearIndependent R ![x, y] ↔ ∀ (s t : R), s • x + t • y = 0 → s = 0 ∧ t = 0 := by\n  refine ⟨fun h s t hst ↦ h.eq_zero_of_pair hst, fun h ↦ ?_⟩\n  apply Fintype.linearIndependent_iff.2\n  intro g hg\n  simp only [Fin.sum_univ_two, Matrix.cons_val_zero, Matrix.cons_val_one, Matrix.head_cons] at hg\n  intro i\n  fin_cases i\n  exacts [(h _ _ hg).1, (h _ _ hg).2]\n\n"}
{"name":"LinearMap.linearIndependent_iff_of_disjoint","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nM' : Type u_5\nv : ι → M\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup M'\ninst✝¹ : Module R M\ninst✝ : Module R M'\nf : LinearMap (RingHom.id R) M M'\nhf_inj : Disjoint (Submodule.span R (Set.range v)) (LinearMap.ker f)\n⊢ Iff (LinearIndependent R (Function.comp (⇑f) v)) (LinearIndependent R v)","decl":"/-- If the kernel of a linear map is disjoint from the span of a family of vectors,\nthen the family is linearly independent iff it is linearly independent after composing with\nthe linear map. -/\nprotected theorem LinearMap.linearIndependent_iff_of_disjoint (f : M →ₗ[R] M')\n    (hf_inj : Disjoint (span R (Set.range v)) (LinearMap.ker f)) :\n    LinearIndependent R (f ∘ v) ↔ LinearIndependent R v :=\n  f.linearIndependent_iff_of_injOn <| LinearMap.injOn_of_disjoint_ker le_rfl hf_inj\n\n"}
{"name":"LinearIndependent.map","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nM' : Type u_5\nv : ι → M\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup M'\ninst✝¹ : Module R M\ninst✝ : Module R M'\nhv : LinearIndependent R v\nf : LinearMap (RingHom.id R) M M'\nhf_inj : Disjoint (Submodule.span R (Set.range v)) (LinearMap.ker f)\n⊢ LinearIndependent R (Function.comp (⇑f) v)","decl":"/-- If `v` is a linearly independent family of vectors and the kernel of a linear map `f` is\ndisjoint with the submodule spanned by the vectors of `v`, then `f ∘ v` is a linearly independent\nfamily of vectors. See also `LinearIndependent.map'` for a special case assuming `ker f = ⊥`. -/\ntheorem LinearIndependent.map (hv : LinearIndependent R v) {f : M →ₗ[R] M'}\n    (hf_inj : Disjoint (span R (range v)) (LinearMap.ker f)) : LinearIndependent R (f ∘ v) :=\n  (f.linearIndependent_iff_of_disjoint hf_inj).mpr hv\n\n"}
{"name":"LinearIndependent.map'","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nM' : Type u_5\nv : ι → M\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup M'\ninst✝¹ : Module R M\ninst✝ : Module R M'\nhv : LinearIndependent R v\nf : LinearMap (RingHom.id R) M M'\nhf_inj : Eq (LinearMap.ker f) Bot.bot\n⊢ LinearIndependent R (Function.comp (⇑f) v)","decl":"/-- An injective linear map sends linearly independent families of vectors to linearly independent\nfamilies of vectors. See also `LinearIndependent.map` for a more general statement. -/\ntheorem LinearIndependent.map' (hv : LinearIndependent R v) (f : M →ₗ[R] M')\n    (hf_inj : LinearMap.ker f = ⊥) : LinearIndependent R (f ∘ v) :=\n  hv.map <| by simp_rw [hf_inj, disjoint_bot_right]\n\n"}
{"name":"LinearIndependent.map_of_injective_injective","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nv : ι → M\ninst✝⁵ : Ring R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\nR' : Type u_6\nM' : Type u_7\ninst✝² : Ring R'\ninst✝¹ : AddCommGroup M'\ninst✝ : Module R' M'\nhv : LinearIndependent R v\ni : R' → R\nj : AddMonoidHom M M'\nhi : ∀ (r : R'), Eq (i r) 0 → Eq r 0\nhj : ∀ (m : M), Eq (j m) 0 → Eq m 0\nhc : ∀ (r : R') (m : M), Eq (j (HSMul.hSMul (i r) m)) (HSMul.hSMul r (j m))\n⊢ LinearIndependent R' (Function.comp (⇑j) v)","decl":"/-- If `M / R` and `M' / R'` are modules, `i : R' → R` is a map, `j : M →+ M'` is a monoid map,\nsuch that they send non-zero elements to non-zero elements, and compatible with the scalar\nmultiplications on `M` and `M'`, then `j` sends linearly independent families of vectors to\nlinearly independent families of vectors. As a special case, taking `R = R'`\nit is `LinearIndependent.map'`. -/\ntheorem LinearIndependent.map_of_injective_injective {R' M' : Type*}\n    [Ring R'] [AddCommGroup M'] [Module R' M'] (hv : LinearIndependent R v)\n    (i : R' → R) (j : M →+ M') (hi : ∀ r, i r = 0 → r = 0) (hj : ∀ m, j m = 0 → m = 0)\n    (hc : ∀ (r : R') (m : M), j (i r • m) = r • j m) : LinearIndependent R' (j ∘ v) := by\n  rw [linearIndependent_iff'] at hv ⊢\n  intro S r' H s hs\n  simp_rw [comp_apply, ← hc, ← map_sum] at H\n  exact hi _ <| hv _ _ (hj _ H) s hs\n\n"}
{"name":"LinearIndependent.map_of_surjective_injective","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nv : ι → M\ninst✝⁵ : Ring R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\nR' : Type u_6\nM' : Type u_7\ninst✝² : Ring R'\ninst✝¹ : AddCommGroup M'\ninst✝ : Module R' M'\nhv : LinearIndependent R v\ni : R → R'\nj : AddMonoidHom M M'\nhi : Function.Surjective i\nhj : ∀ (m : M), Eq (j m) 0 → Eq m 0\nhc : ∀ (r : R) (m : M), Eq (j (HSMul.hSMul r m)) (HSMul.hSMul (i r) (j m))\n⊢ LinearIndependent R' (Function.comp (⇑j) v)","decl":"/-- If `M / R` and `M' / R'` are modules, `i : R → R'` is a surjective map which maps zero to zero,\n`j : M →+ M'` is a monoid map which sends non-zero elements to non-zero elements, such that the\nscalar multiplications on `M` and `M'` are compatible, then `j` sends linearly independent families\nof vectors to linearly independent families of vectors. As a special case, taking `R = R'`\nit is `LinearIndependent.map'`. -/\ntheorem LinearIndependent.map_of_surjective_injective {R' M' : Type*}\n    [Ring R'] [AddCommGroup M'] [Module R' M'] (hv : LinearIndependent R v)\n    (i : R → R') (j : M →+ M') (hi : Surjective i) (hj : ∀ m, j m = 0 → m = 0)\n    (hc : ∀ (r : R) (m : M), j (r • m) = i r • j m) : LinearIndependent R' (j ∘ v) :=\n  hv.map_of_surjective_injectiveₛ i _ hi ((injective_iff_map_eq_zero _).mpr hj) hc\n\n"}
{"name":"LinearMap.linearIndependent_iff","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nM' : Type u_5\nv : ι → M\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup M'\ninst✝¹ : Module R M\ninst✝ : Module R M'\nf : LinearMap (RingHom.id R) M M'\nhf_inj : Eq (LinearMap.ker f) Bot.bot\n⊢ Iff (LinearIndependent R (Function.comp (⇑f) v)) (LinearIndependent R v)","decl":"/-- If `f` is an injective linear map, then the family `f ∘ v` is linearly independent\nif and only if the family `v` is linearly independent. -/\nprotected theorem LinearMap.linearIndependent_iff (f : M →ₗ[R] M') (hf_inj : LinearMap.ker f = ⊥) :\n    LinearIndependent R (f ∘ v) ↔ LinearIndependent R v :=\n  f.linearIndependent_iff_of_disjoint <| by simp_rw [hf_inj, disjoint_bot_right]\n\n"}
{"name":"LinearIndependent.fin_cons'","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"R : Type u_2\nM : Type u_4\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nm : Nat\nx : M\nv : Fin m → M\nhli : LinearIndependent R v\nx_ortho : ∀ (c : R) (y : Subtype fun x => Membership.mem (Submodule.span R (Set.range v)) x), Eq (HAdd.hAdd (HSMul.hSMul c x) ↑y) 0 → Eq c 0\n⊢ LinearIndependent R (Fin.cons x v)","decl":"/-- See `LinearIndependent.fin_cons` for a family of elements in a vector space. -/\ntheorem LinearIndependent.fin_cons' {m : ℕ} (x : M) (v : Fin m → M) (hli : LinearIndependent R v)\n    (x_ortho : ∀ (c : R) (y : Submodule.span R (Set.range v)), c • x + y = (0 : M) → c = 0) :\n    LinearIndependent R (Fin.cons x v : Fin m.succ → M) := by\n  rw [Fintype.linearIndependent_iff] at hli ⊢\n  rintro g total_eq j\n  simp_rw [Fin.sum_univ_succ, Fin.cons_zero, Fin.cons_succ] at total_eq\n  have : g 0 = 0 := by\n    refine x_ortho (g 0) ⟨∑ i : Fin m, g i.succ • v i, ?_⟩ total_eq\n    exact sum_mem fun i _ => smul_mem _ _ (subset_span ⟨i, rfl⟩)\n  rw [this, zero_smul, zero_add] at total_eq\n  exact Fin.cases this (hli _ total_eq) j\n\n"}
{"name":"linearIndependent_comp_subtype","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nv : ι → M\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\ns : Set ι\n⊢ Iff (LinearIndependent R (Function.comp v Subtype.val)) (∀ (l : Finsupp ι R), Membership.mem (Finsupp.supported R R s) l → Eq ((Finsupp.linearCombination R v) l) 0 → Eq l 0)","decl":"theorem linearIndependent_comp_subtype {s : Set ι} :\n    LinearIndependent R (v ∘ (↑) : s → M) ↔\n      ∀ l ∈ Finsupp.supported R R s, (Finsupp.linearCombination R v) l = 0 → l = 0 :=\n  linearIndependent_comp_subtypeₛ.trans ⟨fun h l hl ↦ h l hl 0 (zero_mem _), fun h f hf g hg eq ↦\n    sub_eq_zero.mp (h (f - g) (sub_mem hf hg) <| by rw [map_sub, eq, sub_self])⟩\n\n"}
{"name":"linearDependent_comp_subtype'","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nv : ι → M\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\ns : Set ι\n⊢ Iff (Not (LinearIndependent R (Function.comp v Subtype.val))) (Exists fun f => And (Membership.mem (Finsupp.supported R R s) f) (And (Eq ((Finsupp.linearCombination R v) f) 0) (Ne f 0)))","decl":"theorem linearDependent_comp_subtype' {s : Set ι} :\n    ¬LinearIndependent R (v ∘ (↑) : s → M) ↔\n      ∃ f : ι →₀ R, f ∈ Finsupp.supported R R s ∧ Finsupp.linearCombination R v f = 0 ∧ f ≠ 0 := by\n  simp [linearIndependent_comp_subtype, and_left_comm]\n\n"}
{"name":"linearDependent_comp_subtype","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nv : ι → M\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\ns : Set ι\n⊢ Iff (Not (LinearIndependent R (Function.comp v Subtype.val))) (Exists fun f => And (Membership.mem (Finsupp.supported R R s) f) (And (Eq (f.support.sum fun i => HSMul.hSMul (f i) (v i)) 0) (Ne f 0)))","decl":"/-- A version of `linearDependent_comp_subtype'` with `Finsupp.linearCombination` unfolded. -/\ntheorem linearDependent_comp_subtype {s : Set ι} :\n    ¬LinearIndependent R (v ∘ (↑) : s → M) ↔\n      ∃ f : ι →₀ R, f ∈ Finsupp.supported R R s ∧ ∑ i ∈ f.support, f i • v i = 0 ∧ f ≠ 0 :=\n  linearDependent_comp_subtype'\n\n"}
{"name":"linearIndependent_subtype","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"R : Type u_2\nM : Type u_4\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\ns : Set M\n⊢ Iff (LinearIndependent R fun x => ↑x) (∀ (l : Finsupp M R), Membership.mem (Finsupp.supported R R s) l → Eq ((Finsupp.linearCombination R id) l) 0 → Eq l 0)","decl":"theorem linearIndependent_subtype {s : Set M} :\n    LinearIndependent R (fun x => x : s → M) ↔\n      ∀ l ∈ Finsupp.supported R R s, (Finsupp.linearCombination R id) l = 0 → l = 0 := by\n  apply linearIndependent_comp_subtype (v := id)\n\n"}
{"name":"linearIndependent_comp_subtype_disjoint","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nv : ι → M\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\ns : Set ι\n⊢ Iff (LinearIndependent R (Function.comp v Subtype.val)) (Disjoint (Finsupp.supported R R s) (LinearMap.ker (Finsupp.linearCombination R v)))","decl":"theorem linearIndependent_comp_subtype_disjoint {s : Set ι} :\n    LinearIndependent R (v ∘ (↑) : s → M) ↔\n      Disjoint (Finsupp.supported R R s) (LinearMap.ker <| Finsupp.linearCombination R v) := by\n  rw [linearIndependent_comp_subtype, LinearMap.disjoint_ker]\n\n"}
{"name":"linearIndependent_subtype_disjoint","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"R : Type u_2\nM : Type u_4\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\ns : Set M\n⊢ Iff (LinearIndependent R fun x => ↑x) (Disjoint (Finsupp.supported R R s) (LinearMap.ker (Finsupp.linearCombination R id)))","decl":"theorem linearIndependent_subtype_disjoint {s : Set M} :\n    LinearIndependent R (fun x ↦ x : s → M) ↔\n      Disjoint (Finsupp.supported R R s) (LinearMap.ker <| Finsupp.linearCombination R id) := by\n  apply linearIndependent_comp_subtype_disjoint (v := id)\n\n"}
{"name":"linearIndependent_iff_linearCombinationOn","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"R : Type u_2\nM : Type u_4\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\ns : Set M\n⊢ Iff (LinearIndependent R fun x => ↑x) (Eq (LinearMap.ker (Finsupp.linearCombinationOn M M R id s)) Bot.bot)","decl":"theorem linearIndependent_iff_linearCombinationOn {s : Set M} :\n    LinearIndependent R (fun x ↦ x : s → M) ↔\n    (LinearMap.ker <| Finsupp.linearCombinationOn M M R id s) = ⊥ :=\n  linearIndependent_iff_linearCombinationOnₛ.trans <|\n    LinearMap.ker_eq_bot (M := Finsupp.supported R R s).symm\n\n"}
{"name":"linearIndependent_iff_totalOn","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"R : Type u_2\nM : Type u_4\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\ns : Set M\n⊢ Iff (LinearIndependent R fun x => ↑x) (Eq (LinearMap.ker (Finsupp.linearCombinationOn M M R id s)) Bot.bot)","decl":"@[deprecated (since := \"2024-08-29\")] alias linearIndependent_iff_totalOn :=\n  linearIndependent_iff_linearCombinationOn\n\n"}
{"name":"LinearIndependent.linear_combination_pair_of_det_ne_zero","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"R : Type u_6\nM : Type u_7\ninst✝³ : CommRing R\ninst✝² : NoZeroDivisors R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nx y : M\nh : LinearIndependent R (Matrix.vecCons x (Matrix.vecCons y Matrix.vecEmpty))\na b c d : R\nh' : Ne (HSub.hSub (HMul.hMul a d) (HMul.hMul b c)) 0\n⊢ LinearIndependent R (Matrix.vecCons (HAdd.hAdd (HSMul.hSMul a x) (HSMul.hSMul b y)) (Matrix.vecCons (HAdd.hAdd (HSMul.hSMul c x) (HSMul.hSMul d y)) Matrix.vecEmpty))","decl":"/-- If two vectors `x` and `y` are linearly independent, so are their linear combinations\n`a x + b y` and `c x + d y` provided the determinant `a * d - b * c` is nonzero. -/\nlemma LinearIndependent.linear_combination_pair_of_det_ne_zero {R M : Type*} [CommRing R]\n    [NoZeroDivisors R] [AddCommGroup M] [Module R M]\n    {x y : M} (h : LinearIndependent R ![x, y])\n    {a b c d : R} (h' : a * d - b * c ≠ 0) :\n    LinearIndependent R ![a • x + b • y, c • x + d • y] := by\n  apply LinearIndependent.pair_iff.2 (fun s t hst ↦ ?_)\n  have H : (s * a + t * c) • x + (s * b + t * d) • y = 0 := by\n    convert hst using 1\n    module\n  have I1 : s * a + t * c = 0 := (h.eq_zero_of_pair H).1\n  have I2 : s * b + t * d = 0 := (h.eq_zero_of_pair H).2\n  have J1 : (a * d - b * c) * s = 0 := by linear_combination d * I1 - c * I2\n  have J2 : (a * d - b * c) * t = 0 := by linear_combination -b * I1 + a * I2\n  exact ⟨by simpa [h'] using mul_eq_zero.1 J1, by simpa [h'] using mul_eq_zero.1 J2⟩\n\n"}
{"name":"linearIndependent_sum","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nι' : Type u_1\nR : Type u_2\nM : Type u_4\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nv : Sum ι ι' → M\n⊢ Iff (LinearIndependent R v) (And (LinearIndependent R (Function.comp v Sum.inl)) (And (LinearIndependent R (Function.comp v Sum.inr)) (Disjoint (Submodule.span R (Set.range (Function.comp v Sum.inl))) (Submodule.span R (Set.range (Function.comp v Sum.inr))))))","decl":"theorem linearIndependent_sum {v : ι ⊕ ι' → M} :\n    LinearIndependent R v ↔\n      LinearIndependent R (v ∘ Sum.inl) ∧\n        LinearIndependent R (v ∘ Sum.inr) ∧\n          Disjoint (Submodule.span R (range (v ∘ Sum.inl)))\n            (Submodule.span R (range (v ∘ Sum.inr))) := by\n  classical\n  rw [range_comp v, range_comp v]\n  refine ⟨?_, ?_⟩\n  · intro h\n    refine ⟨h.comp _ Sum.inl_injective, h.comp _ Sum.inr_injective, ?_⟩\n    refine h.disjoint_span_image ?_\n    -- Porting note: `isCompl_range_inl_range_inr.1` timeouts.\n    exact IsCompl.disjoint isCompl_range_inl_range_inr\n  rintro ⟨hl, hr, hlr⟩\n  rw [linearIndependent_iff'] at *\n  intro s g hg i hi\n  have :\n    ((∑ i ∈ s.preimage Sum.inl Sum.inl_injective.injOn, (fun x => g x • v x) (Sum.inl i)) +\n        ∑ i ∈ s.preimage Sum.inr Sum.inr_injective.injOn, (fun x => g x • v x) (Sum.inr i)) =\n      0 := by\n    -- Porting note: `g` must be specified.\n    rw [Finset.sum_preimage' (g := fun x => g x • v x),\n      Finset.sum_preimage' (g := fun x => g x • v x), ← Finset.sum_union, ← Finset.filter_or]\n    · simpa only [← mem_union, range_inl_union_range_inr, mem_univ, Finset.filter_True]\n    · -- Porting note: Here was one `exact`, but timeouted.\n      refine Finset.disjoint_filter.2 fun x _ hx =>\n        disjoint_left.1 ?_ hx\n      exact IsCompl.disjoint isCompl_range_inl_range_inr\n  rw [← eq_neg_iff_add_eq_zero] at this\n  rw [disjoint_def'] at hlr\n  have A := by\n    refine hlr _ (sum_mem fun i _ => ?_) _ (neg_mem <| sum_mem fun i _ => ?_) this\n    · exact smul_mem _ _ (subset_span ⟨Sum.inl i, mem_range_self _, rfl⟩)\n    · exact smul_mem _ _ (subset_span ⟨Sum.inr i, mem_range_self _, rfl⟩)\n  cases' i with i i\n  · exact hl _ _ A i (Finset.mem_preimage.2 hi)\n  · rw [this, neg_eq_zero] at A\n    exact hr _ _ A i (Finset.mem_preimage.2 hi)\n\n"}
{"name":"LinearIndependent.sum_type","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nι' : Type u_1\nR : Type u_2\nM : Type u_4\nv : ι → M\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nv' : ι' → M\nhv : LinearIndependent R v\nhv' : LinearIndependent R v'\nh : Disjoint (Submodule.span R (Set.range v)) (Submodule.span R (Set.range v'))\n⊢ LinearIndependent R (Sum.elim v v')","decl":"theorem LinearIndependent.sum_type {v' : ι' → M} (hv : LinearIndependent R v)\n    (hv' : LinearIndependent R v')\n    (h : Disjoint (Submodule.span R (range v)) (Submodule.span R (range v'))) :\n    LinearIndependent R (Sum.elim v v') :=\n  linearIndependent_sum.2 ⟨hv, hv', h⟩\n\n"}
{"name":"LinearIndependent.union","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"R : Type u_2\nM : Type u_4\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\ns t : Set M\nhs : LinearIndependent R fun x => ↑x\nht : LinearIndependent R fun x => ↑x\nhst : Disjoint (Submodule.span R s) (Submodule.span R t)\n⊢ LinearIndependent R fun x => ↑x","decl":"theorem LinearIndependent.union {s t : Set M} (hs : LinearIndependent R (fun x => x : s → M))\n    (ht : LinearIndependent R (fun x => x : t → M)) (hst : Disjoint (span R s) (span R t)) :\n    LinearIndependent R (fun x => x : ↥(s ∪ t) → M) :=\n  (hs.sum_type ht <| by simpa).to_subtype_range' <| by simp\n\n"}
{"name":"linearIndependent_iUnion_finite_subtype","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"R : Type u_2\nM : Type u_4\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nι : Type u_6\nf : ι → Set M\nhl : ∀ (i : ι), LinearIndependent R fun x => ↑x\nhd : ∀ (i : ι) (t : Set ι), t.Finite → Not (Membership.mem t i) → Disjoint (Submodule.span R (f i)) (iSup fun i => iSup fun h => Submodule.span R (f i))\n⊢ LinearIndependent R fun x => ↑x","decl":"theorem linearIndependent_iUnion_finite_subtype {ι : Type*} {f : ι → Set M}\n    (hl : ∀ i, LinearIndependent R (fun x => x : f i → M))\n    (hd : ∀ i, ∀ t : Set ι, t.Finite → i ∉ t → Disjoint (span R (f i)) (⨆ i ∈ t, span R (f i))) :\n    LinearIndependent R (fun x => x : (⋃ i, f i) → M) := by\n  classical\n  rw [iUnion_eq_iUnion_finset f]\n  apply linearIndependent_iUnion_of_directed\n  · apply directed_of_isDirected_le\n    exact fun t₁ t₂ ht => iUnion_mono fun i => iUnion_subset_iUnion_const fun h => ht h\n  intro t\n  induction' t using Finset.induction_on with i s his ih\n  · refine (linearIndependent_empty R M).mono ?_\n    simp\n  · rw [Finset.set_biUnion_insert]\n    refine (hl _).union ih ?_\n    rw [span_iUnion₂]\n    exact hd i s s.finite_toSet his\n\n"}
{"name":"linearIndependent_iUnion_finite","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"R : Type u_2\nM : Type u_4\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nη : Type u_6\nιs : η → Type u_7\nf : (j : η) → ιs j → M\nhindep : ∀ (j : η), LinearIndependent R (f j)\nhd : ∀ (i : η) (t : Set η), t.Finite → Not (Membership.mem t i) → Disjoint (Submodule.span R (Set.range (f i))) (iSup fun i => iSup fun h => Submodule.span R (Set.range (f i)))\n⊢ LinearIndependent R fun ji => f ji.fst ji.snd","decl":"theorem linearIndependent_iUnion_finite {η : Type*} {ιs : η → Type*} {f : ∀ j : η, ιs j → M}\n    (hindep : ∀ j, LinearIndependent R (f j))\n    (hd : ∀ i, ∀ t : Set η,\n      t.Finite → i ∉ t → Disjoint (span R (range (f i))) (⨆ i ∈ t, span R (range (f i)))) :\n    LinearIndependent R fun ji : Σ j, ιs j => f ji.1 ji.2 := by\n  nontriviality R\n  apply LinearIndependent.of_subtype_range\n  · rintro ⟨x₁, x₂⟩ ⟨y₁, y₂⟩ hxy\n    by_cases h_cases : x₁ = y₁\n    · subst h_cases\n      refine Sigma.eq rfl ?_\n      rw [LinearIndependent.injective (hindep _) hxy]\n    · have h0 : f x₁ x₂ = 0 := by\n        apply\n          disjoint_def.1 (hd x₁ {y₁} (finite_singleton y₁) fun h => h_cases (eq_of_mem_singleton h))\n            (f x₁ x₂) (subset_span (mem_range_self _))\n        rw [iSup_singleton]\n        simp only at hxy\n        rw [hxy]\n        exact subset_span (mem_range_self y₂)\n      exact False.elim ((hindep x₁).ne_zero _ h0)\n  rw [range_sigma_eq_iUnion_range]\n  apply linearIndependent_iUnion_finite_subtype (fun j => (hindep j).to_subtype_range) hd\n\n"}
{"name":"linearIndependent_iff_not_smul_mem_span","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\nv : ι → M\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Iff (LinearIndependent R v) (∀ (i : ι) (a : R), Membership.mem (Submodule.span R (Set.image v (SDiff.sdiff Set.univ (Singleton.singleton i)))) (HSMul.hSMul a (v i)) → Eq a 0)","decl":"theorem linearIndependent_iff_not_smul_mem_span :\n    LinearIndependent R v ↔ ∀ (i : ι) (a : R), a • v i ∈ span R (v '' (univ \\ {i})) → a = 0 :=\n  ⟨fun hv ↦ hv.not_smul_mem_span, fun H =>\n    linearIndependent_iff.2 fun l hl => by\n      ext i; simp only [Finsupp.zero_apply]\n      by_contra hn\n      refine hn (H i _ ?_)\n      refine (Finsupp.mem_span_image_iff_linearCombination R).2 ⟨Finsupp.single i (l i) - l, ?_, ?_⟩\n      · rw [Finsupp.mem_supported']\n        intro j hj\n        have hij : j = i :=\n          Classical.not_not.1 fun hij : j ≠ i =>\n            hj ((mem_diff _).2 ⟨mem_univ _, fun h => hij (eq_of_mem_singleton h)⟩)\n        simp [hij]\n      · simp [hl]⟩\n\n"}
{"name":"exists_maximal_independent","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\ns : ι → M\n⊢ Exists fun I => And (LinearIndependent R fun x => s ↑x) (∀ (i : ι), Not (Membership.mem I i) → Exists fun a => And (Ne a 0) (Membership.mem (Submodule.span R (Set.image s I)) (HSMul.hSMul a (s i))))","decl":"variable (R) in\ntheorem exists_maximal_independent (s : ι → M) :\n    ∃ I : Set ι,\n      (LinearIndependent R fun x : I => s x) ∧\n        ∀ i ∉ I, ∃ a : R, a ≠ 0 ∧ a • s i ∈ span R (s '' I) := by\n  classical\n    rcases exists_maximal_independent' R s with ⟨I, hIlinind, hImaximal⟩\n    use I, hIlinind\n    intro i hi\n    specialize hImaximal (I ∪ {i}) (by simp)\n    set J := I ∪ {i} with hJ\n    have memJ : ∀ {x}, x ∈ J ↔ x = i ∨ x ∈ I := by simp [hJ]\n    have hiJ : i ∈ J := by simp [J]\n    have h := by\n      refine mt hImaximal ?_\n      · intro h2\n        rw [h2] at hi\n        exact absurd hiJ hi\n    obtain ⟨f, supp_f, sum_f, f_ne⟩ := linearDependent_comp_subtype.mp h\n    have hfi : f i ≠ 0 := by\n      contrapose hIlinind\n      refine linearDependent_comp_subtype.mpr ⟨f, ?_, sum_f, f_ne⟩\n      simp only [Finsupp.mem_supported, hJ] at supp_f ⊢\n      rintro x hx\n      refine (memJ.mp (supp_f hx)).resolve_left ?_\n      rintro rfl\n      exact hIlinind (Finsupp.mem_support_iff.mp hx)\n    use f i, hfi\n    have hfi' : i ∈ f.support := Finsupp.mem_support_iff.mpr hfi\n    rw [← Finset.insert_erase hfi', Finset.sum_insert (Finset.not_mem_erase _ _),\n      add_eq_zero_iff_eq_neg] at sum_f\n    rw [sum_f]\n    refine neg_mem (sum_mem fun c hc => smul_mem _ _ (subset_span ⟨c, ?_, rfl⟩))\n    exact (memJ.mp (supp_f (Finset.erase_subset _ _ hc))).resolve_left (Finset.ne_of_mem_erase hc)\n\n"}
{"name":"LinearIndependent.image_subtype","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"R : Type u_2\nM : Type u_4\nM' : Type u_5\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup M'\ninst✝¹ : Module R M\ninst✝ : Module R M'\ns : Set M\nf : LinearMap (RingHom.id R) M M'\nhs : LinearIndependent R fun x => ↑x\nhf_inj : Disjoint (Submodule.span R s) (LinearMap.ker f)\n⊢ LinearIndependent R fun x => ↑x","decl":"theorem LinearIndependent.image_subtype {s : Set M} {f : M →ₗ[R] M'}\n    (hs : LinearIndependent R (fun x ↦ x : s → M))\n    (hf_inj : Disjoint (span R s) (LinearMap.ker f)) :\n    LinearIndependent R (fun x ↦ x : f '' s → M') :=\n  hs.image_subtypeₛ <| LinearMap.injOn_of_disjoint_ker le_rfl hf_inj\n\n-- See, for example, Keith Conrad's note\n--  <https://kconrad.math.uconn.edu/blurbs/galoistheory/linearchar.pdf>\n"}
{"name":"linearIndependent_monoidHom","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"G : Type u_6\ninst✝² : Monoid G\nL : Type u_7\ninst✝¹ : CommRing L\ninst✝ : NoZeroDivisors L\n⊢ LinearIndependent L fun f => ⇑f","decl":"/-- Dedekind's linear independence of characters -/\n@[stacks 0CKL]\ntheorem linearIndependent_monoidHom (G : Type*) [Monoid G] (L : Type*) [CommRing L]\n    [NoZeroDivisors L] : LinearIndependent L (M := G → L) (fun f => f : (G →* L) → G → L) := by\n  -- Porting note: Some casts are required.\n  letI := Classical.decEq (G →* L)\n  letI : MulAction L L := DistribMulAction.toMulAction\n  -- We prove linear independence by showing that only the trivial linear combination vanishes.\n  exact linearIndependent_iff'.2\n    -- To do this, we use `Finset` induction,\n    -- Porting note: `False.elim` → `fun h => False.elim <| Finset.not_mem_empty _ h`\n    fun s =>\n      Finset.induction_on s\n        (fun g _hg i h => False.elim <| Finset.not_mem_empty _ h) fun a s has ih g hg =>\n        -- Here\n        -- * `a` is a new character we will insert into the `Finset` of characters `s`,\n        -- * `ih` is the fact that only the trivial linear combination of characters in `s` is zero\n        -- * `hg` is the fact that `g` are the coefficients of a linear combination summing to zero\n        -- and it remains to prove that `g` vanishes on `insert a s`.\n        -- We now make the key calculation:\n        -- For any character `i` in the original `Finset`, we have `g i • i = g i • a` as functions\n        -- on the monoid `G`.\n        have h1 : ∀ i ∈ s, (g i • (i : G → L)) = g i • (a : G → L) := fun i his =>\n          funext fun x : G =>\n            -- We prove these expressions are equal by showing\n            -- the differences of their values on each monoid element `x` is zero\n            eq_of_sub_eq_zero <|\n            ih (fun j => g j * j x - g j * a x)\n              (funext fun y : G => calc\n                -- After that, it's just a chase scene.\n                (∑ i ∈ s, ((g i * i x - g i * a x) • (i : G → L))) y =\n                    ∑ i ∈ s, (g i * i x - g i * a x) * i y :=\n                  Finset.sum_apply ..\n                _ = ∑ i ∈ s, (g i * i x * i y - g i * a x * i y) :=\n                  Finset.sum_congr rfl fun _ _ => sub_mul ..\n                _ = (∑ i ∈ s, g i * i x * i y) - ∑ i ∈ s, g i * a x * i y :=\n                  Finset.sum_sub_distrib\n                _ =\n                    (g a * a x * a y + ∑ i ∈ s, g i * i x * i y) -\n                      (g a * a x * a y + ∑ i ∈ s, g i * a x * i y) := by\n                  rw [add_sub_add_left_eq_sub]\n                _ =\n                    (∑ i ∈ insert a s, g i * i x * i y) -\n                      ∑ i ∈ insert a s, g i * a x * i y := by\n                  rw [Finset.sum_insert has, Finset.sum_insert has]\n                _ =\n                    (∑ i ∈ insert a s, g i * i (x * y)) -\n                      ∑ i ∈ insert a s, a x * (g i * i y) := by\n                  congrm ∑ i ∈ insert a s, ?_ - ∑ i ∈ insert a s, ?_\n                  · rw [map_mul, mul_assoc]\n                  · rw [mul_assoc, mul_left_comm]\n                _ =\n                    (∑ i ∈ insert a s, (g i • (i : G → L))) (x * y) -\n                      a x * (∑ i ∈ insert a s, (g i • (i : G → L))) y := by\n                  rw [Finset.sum_apply, Finset.sum_apply, Finset.mul_sum]; rfl\n                _ = 0 - a x * 0 := by rw [hg]; rfl\n                _ = 0 := by rw [mul_zero, sub_zero]\n                )\n              i his\n        -- On the other hand, since `a` is not already in `s`, for any character `i ∈ s`\n        -- there is some element of the monoid on which it differs from `a`.\n        have h2 : ∀ i : G →* L, i ∈ s → ∃ y, i y ≠ a y := fun i his =>\n          Classical.by_contradiction fun h =>\n            have hia : i = a := MonoidHom.ext fun y =>\n              Classical.by_contradiction fun hy => h ⟨y, hy⟩\n            has <| hia ▸ his\n        -- From these two facts we deduce that `g` actually vanishes on `s`,\n        have h3 : ∀ i ∈ s, g i = 0 := fun i his =>\n          let ⟨y, hy⟩ := h2 i his\n          have h : g i • i y = g i • a y := congr_fun (h1 i his) y\n          Or.resolve_right (mul_eq_zero.1 <| by rw [mul_sub, sub_eq_zero]; exact h)\n            (sub_ne_zero_of_ne hy)\n        -- And so, using the fact that the linear combination over `s` and over `insert a s` both\n        -- vanish, we deduce that `g a = 0`.\n        have h4 : g a = 0 :=\n          calc\n            g a = g a * 1 := (mul_one _).symm\n            _ = (g a • (a : G → L)) 1 := by rw [← a.map_one]; rfl\n            _ = (∑ i ∈ insert a s, (g i • (i : G → L))) 1 := by\n              rw [Finset.sum_eq_single a]\n              · intro i his hia\n                rw [Finset.mem_insert] at his\n                rw [h3 i (his.resolve_left hia), zero_smul]\n              · intro haas\n                exfalso\n                apply haas\n                exact Finset.mem_insert_self a s\n            _ = 0 := by rw [hg]; rfl\n        -- Now we're done; the last two facts together imply that `g` vanishes on every element\n        -- of `insert a s`.\n        (Finset.forall_mem_insert ..).2 ⟨h4, h3⟩\n\n"}
{"name":"linearIndependent_algHom_toLinearMap","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"K : Type u_6\nM : Type u_7\nL : Type u_8\ninst✝⁵ : CommSemiring K\ninst✝⁴ : Semiring M\ninst✝³ : Algebra K M\ninst✝² : CommRing L\ninst✝¹ : IsDomain L\ninst✝ : Algebra K L\n⊢ LinearIndependent L AlgHom.toLinearMap","decl":"@[stacks 0CKM]\nlemma linearIndependent_algHom_toLinearMap\n    (K M L) [CommSemiring K] [Semiring M] [Algebra K M] [CommRing L] [IsDomain L] [Algebra K L] :\n    LinearIndependent L (AlgHom.toLinearMap : (M →ₐ[K] L) → M →ₗ[K] L) := by\n  apply LinearIndependent.of_comp (LinearMap.ltoFun K M L)\n  exact (linearIndependent_monoidHom M L).comp\n    (RingHom.toMonoidHom ∘ AlgHom.toRingHom)\n    (fun _ _ e ↦ AlgHom.ext (DFunLike.congr_fun e :))\n\n"}
{"name":"linearIndependent_algHom_toLinearMap'","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"K : Type u_6\nM : Type u_7\nL : Type u_8\ninst✝⁶ : CommRing K\ninst✝⁵ : Semiring M\ninst✝⁴ : Algebra K M\ninst✝³ : CommRing L\ninst✝² : IsDomain L\ninst✝¹ : Algebra K L\ninst✝ : NoZeroSMulDivisors K L\n⊢ LinearIndependent K AlgHom.toLinearMap","decl":"lemma linearIndependent_algHom_toLinearMap' (K M L) [CommRing K]\n    [Semiring M] [Algebra K M] [CommRing L] [IsDomain L] [Algebra K L] [NoZeroSMulDivisors K L] :\n    LinearIndependent K (AlgHom.toLinearMap : (M →ₐ[K] L) → M →ₗ[K] L) := by\n  apply (linearIndependent_algHom_toLinearMap K M L).restrict_scalars\n  simp_rw [Algebra.smul_def, mul_one]\n  exact NoZeroSMulDivisors.algebraMap_injective K L\n\n"}
{"name":"linearIndependent_unique_iff","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\ninst✝⁵ : Ring R\ninst✝⁴ : Nontrivial R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : NoZeroSMulDivisors R M\nv : ι → M\ninst✝ : Unique ι\n⊢ Iff (LinearIndependent R v) (Ne (v Inhabited.default) 0)","decl":"theorem linearIndependent_unique_iff (v : ι → M) [Unique ι] :\n    LinearIndependent R v ↔ v default ≠ 0 := by\n  simp only [linearIndependent_iff, Finsupp.linearCombination_unique, smul_eq_zero]\n  refine ⟨fun h hv => ?_, fun hv l hl => Finsupp.unique_ext <| hl.resolve_right hv⟩\n  have := h (Finsupp.single default 1) (Or.inr hv)\n  exact one_ne_zero (Finsupp.single_eq_zero.1 this)\n\n"}
{"name":"linearIndependent_unique","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nR : Type u_2\nM : Type u_4\ninst✝⁵ : Ring R\ninst✝⁴ : Nontrivial R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : NoZeroSMulDivisors R M\nv : ι → M\ninst✝ : Unique ι\na✝ : Ne (v Inhabited.default) 0\n⊢ LinearIndependent R v","decl":"alias ⟨_, linearIndependent_unique⟩ := linearIndependent_unique_iff\n\n"}
{"name":"linearIndependent_singleton","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"R : Type u_2\nM : Type u_4\ninst✝⁴ : Ring R\ninst✝³ : Nontrivial R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : NoZeroSMulDivisors R M\nx : M\nhx : Ne x 0\n⊢ LinearIndependent R fun x_1 => ↑x_1","decl":"theorem linearIndependent_singleton {x : M} (hx : x ≠ 0) :\n    LinearIndependent R (fun x => x : ({x} : Set M) → M) :=\n  linearIndependent_unique ((↑) : ({x} : Set M) → M) hx\n\n"}
{"name":"mem_span_insert_exchange","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"K : Type u_3\nV : Type u\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\ns : Set V\nx y : V\na✝¹ : Membership.mem (Submodule.span K (Insert.insert y s)) x\na✝ : Not (Membership.mem (Submodule.span K s) x)\n⊢ Membership.mem (Submodule.span K (Insert.insert x s)) y","decl":"theorem mem_span_insert_exchange :\n    x ∈ span K (insert y s) → x ∉ span K s → y ∈ span K (insert x s) := by\n  simp only [mem_span_insert, forall_exists_index, and_imp]\n  rintro a z hz rfl h\n  refine ⟨a⁻¹, -a⁻¹ • z, smul_mem _ _ hz, ?_⟩\n  have a0 : a ≠ 0 := by\n    rintro rfl\n    simp_all\n  match_scalars <;> simp [a0]\n\n"}
{"name":"linearIndependent_iff_not_mem_span","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nK : Type u_3\nV : Type u\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nv : ι → V\n⊢ Iff (LinearIndependent K v) (∀ (i : ι), Not (Membership.mem (Submodule.span K (Set.image v (SDiff.sdiff Set.univ (Singleton.singleton i)))) (v i)))","decl":"theorem linearIndependent_iff_not_mem_span :\n    LinearIndependent K v ↔ ∀ i, v i ∉ span K (v '' (univ \\ {i})) := by\n  apply linearIndependent_iff_not_smul_mem_span.trans\n  constructor\n  · intro h i h_in_span\n    apply one_ne_zero (h i 1 (by simp [h_in_span]))\n  · intro h i a ha\n    by_contra ha'\n    exact False.elim (h _ ((smul_mem_iff _ ha').1 ha))\n\n"}
{"name":"LinearIndependent.insert","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"K : Type u_3\nV : Type u\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\ns : Set V\nx : V\nhs : LinearIndependent K fun b => ↑b\nhx : Not (Membership.mem (Submodule.span K s) x)\n⊢ LinearIndependent K fun b => ↑b","decl":"protected theorem LinearIndependent.insert (hs : LinearIndependent K (fun b => b : s → V))\n    (hx : x ∉ span K s) : LinearIndependent K (fun b => b : ↥(insert x s) → V) := by\n  rw [← union_singleton]\n  have x0 : x ≠ 0 := mt (by rintro rfl; apply zero_mem (span K s)) hx\n  apply hs.union (linearIndependent_singleton x0)\n  rwa [disjoint_span_singleton' x0]\n\n"}
{"name":"linearIndependent_option'","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nK : Type u_3\nV : Type u\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nv : ι → V\nx : V\n⊢ Iff (LinearIndependent K fun o => o.casesOn' x v) (And (LinearIndependent K v) (Not (Membership.mem (Submodule.span K (Set.range v)) x)))","decl":"theorem linearIndependent_option' :\n    LinearIndependent K (fun o => Option.casesOn' o x v : Option ι → V) ↔\n      LinearIndependent K v ∧ x ∉ Submodule.span K (range v) := by\n  -- Porting note: Explicit universe level is required in `Equiv.optionEquivSumPUnit`.\n  rw [← linearIndependent_equiv (Equiv.optionEquivSumPUnit.{u', _} ι).symm, linearIndependent_sum,\n    @range_unique _ PUnit, @linearIndependent_unique_iff PUnit, disjoint_span_singleton]\n  dsimp [(· ∘ ·)]\n  refine ⟨fun h => ⟨h.1, fun hx => h.2.1 <| h.2.2 hx⟩, fun h => ⟨h.1, ?_, fun hx => (h.2 hx).elim⟩⟩\n  rintro rfl\n  exact h.2 (zero_mem _)\n\n"}
{"name":"LinearIndependent.option","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nK : Type u_3\nV : Type u\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nv : ι → V\nx : V\nhv : LinearIndependent K v\nhx : Not (Membership.mem (Submodule.span K (Set.range v)) x)\n⊢ LinearIndependent K fun o => o.casesOn' x v","decl":"theorem LinearIndependent.option (hv : LinearIndependent K v)\n    (hx : x ∉ Submodule.span K (range v)) :\n    LinearIndependent K (fun o => Option.casesOn' o x v : Option ι → V) :=\n  linearIndependent_option'.2 ⟨hv, hx⟩\n\n"}
{"name":"linearIndependent_option","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nK : Type u_3\nV : Type u\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nv : Option ι → V\n⊢ Iff (LinearIndependent K v) (And (LinearIndependent K (Function.comp v Option.some)) (Not (Membership.mem (Submodule.span K (Set.range (Function.comp v Option.some))) (v Option.none))))","decl":"theorem linearIndependent_option {v : Option ι → V} : LinearIndependent K v ↔\n    LinearIndependent K (v ∘ (↑) : ι → V) ∧\n      v none ∉ Submodule.span K (range (v ∘ (↑) : ι → V)) := by\n  simp only [← linearIndependent_option', Option.casesOn'_none_coe]\n\n"}
{"name":"linearIndependent_insert'","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"K : Type u_3\nV : Type u\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nι : Type u_6\ns : Set ι\na : ι\nf : ι → V\nhas : Not (Membership.mem s a)\n⊢ Iff (LinearIndependent K fun x => f ↑x) (And (LinearIndependent K fun x => f ↑x) (Not (Membership.mem (Submodule.span K (Set.image f s)) (f a))))","decl":"theorem linearIndependent_insert' {ι} {s : Set ι} {a : ι} {f : ι → V} (has : a ∉ s) :\n    (LinearIndependent K fun x : ↥(insert a s) => f x) ↔\n      (LinearIndependent K fun x : s => f x) ∧ f a ∉ Submodule.span K (f '' s) := by\n  classical\n  rw [← linearIndependent_equiv ((Equiv.optionEquivSumPUnit _).trans (Equiv.Set.insert has).symm),\n    linearIndependent_option]\n  -- Porting note: `simp [(· ∘ ·), range_comp f]` → `simp [(· ∘ ·)]; erw [range_comp f ..]; simp`\n  -- https://github.com/leanprover-community/mathlib4/issues/5164\n  simp only [comp_def]\n  erw [range_comp f ((↑) : s → ι)]\n  simp\n\n"}
{"name":"linearIndependent_insert","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"K : Type u_3\nV : Type u\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\ns : Set V\nx : V\nhxs : Not (Membership.mem s x)\n⊢ Iff (LinearIndependent K fun b => ↑b) (And (LinearIndependent K fun b => ↑b) (Not (Membership.mem (Submodule.span K s) x)))","decl":"theorem linearIndependent_insert (hxs : x ∉ s) :\n    (LinearIndependent K fun b : ↥(insert x s) => (b : V)) ↔\n      (LinearIndependent K fun b : s => (b : V)) ∧ x ∉ Submodule.span K s :=\n  (linearIndependent_insert' (f := id) hxs).trans <| by simp\n\n"}
{"name":"linearIndependent_pair","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"K : Type u_3\nV : Type u\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nx y : V\nhx : Ne x 0\nhy : ∀ (a : K), Ne (HSMul.hSMul a x) y\n⊢ LinearIndependent K Subtype.val","decl":"theorem linearIndependent_pair {x y : V} (hx : x ≠ 0) (hy : ∀ a : K, a • x ≠ y) :\n    LinearIndependent K ((↑) : ({x, y} : Set V) → V) :=\n  pair_comm y x ▸ (linearIndependent_singleton hx).insert <|\n    mt mem_span_singleton.1 (not_exists.2 hy)\n\n"}
{"name":"LinearIndependent.pair_iff'","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"K : Type u_3\nV : Type u\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nx y : V\nhx : Ne x 0\n⊢ Iff (LinearIndependent K (Matrix.vecCons x (Matrix.vecCons y Matrix.vecEmpty))) (∀ (a : K), Ne (HSMul.hSMul a x) y)","decl":"/-- Also see `LinearIndependent.pair_iff` for the version over arbitrary rings. -/\ntheorem LinearIndependent.pair_iff' {x y : V} (hx : x ≠ 0) :\n    LinearIndependent K ![x, y] ↔ ∀ a : K, a • x ≠ y := by\n  rw [LinearIndependent.pair_iff]\n  constructor\n  · intro H a ha\n    have := (H a (-1) (by simpa [← sub_eq_add_neg, sub_eq_zero])).2\n    simp only [neg_eq_zero, one_ne_zero] at this\n  · intro H s t hst\n    by_cases ht : t = 0\n    · exact ⟨by simpa [ht, hx] using hst, ht⟩\n    apply_fun (t⁻¹ • ·) at hst\n    simp only [smul_add, smul_smul, inv_mul_cancel₀ ht] at hst\n    cases H (-(t⁻¹ * s)) <| by linear_combination (norm := match_scalars <;> noncomm_ring) -hst\n\n"}
{"name":"linearIndependent_fin_cons","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"K : Type u_3\nV : Type u\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nx : V\nn : Nat\nv : Fin n → V\n⊢ Iff (LinearIndependent K (Fin.cons x v)) (And (LinearIndependent K v) (Not (Membership.mem (Submodule.span K (Set.range v)) x)))","decl":"theorem linearIndependent_fin_cons {n} {v : Fin n → V} :\n    LinearIndependent K (Fin.cons x v : Fin (n + 1) → V) ↔\n      LinearIndependent K v ∧ x ∉ Submodule.span K (range v) := by\n  rw [← linearIndependent_equiv (finSuccEquiv n).symm, linearIndependent_option]\n  -- Porting note: `convert Iff.rfl; ...` → `exact Iff.rfl`\n  exact Iff.rfl\n\n"}
{"name":"linearIndependent_fin_snoc","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"K : Type u_3\nV : Type u\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nx : V\nn : Nat\nv : Fin n → V\n⊢ Iff (LinearIndependent K (Fin.snoc v x)) (And (LinearIndependent K v) (Not (Membership.mem (Submodule.span K (Set.range v)) x)))","decl":"theorem linearIndependent_fin_snoc {n} {v : Fin n → V} :\n    LinearIndependent K (Fin.snoc v x : Fin (n + 1) → V) ↔\n      LinearIndependent K v ∧ x ∉ Submodule.span K (range v) := by\n  -- Porting note: `rw` → `erw`\n  -- https://github.com/leanprover-community/mathlib4/issues/5164\n  -- Here Lean can not see that `fun i ↦ Fin.cons x v (↑(finRotate (n + 1)) i)`\n  -- matches with `?f ∘ ↑(finRotate (n + 1))`.\n  erw [Fin.snoc_eq_cons_rotate, linearIndependent_equiv, linearIndependent_fin_cons]\n\n"}
{"name":"LinearIndependent.fin_cons","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"K : Type u_3\nV : Type u\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nx : V\nn : Nat\nv : Fin n → V\nhv : LinearIndependent K v\nhx : Not (Membership.mem (Submodule.span K (Set.range v)) x)\n⊢ LinearIndependent K (Fin.cons x v)","decl":"/-- See `LinearIndependent.fin_cons'` for an uglier version that works if you\nonly have a module over a semiring. -/\ntheorem LinearIndependent.fin_cons {n} {v : Fin n → V} (hv : LinearIndependent K v)\n    (hx : x ∉ Submodule.span K (range v)) : LinearIndependent K (Fin.cons x v : Fin (n + 1) → V) :=\n  linearIndependent_fin_cons.2 ⟨hv, hx⟩\n\n"}
{"name":"linearIndependent_fin_succ","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"K : Type u_3\nV : Type u\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nn : Nat\nv : Fin (HAdd.hAdd n 1) → V\n⊢ Iff (LinearIndependent K v) (And (LinearIndependent K (Fin.tail v)) (Not (Membership.mem (Submodule.span K (Set.range (Fin.tail v))) (v 0))))","decl":"theorem linearIndependent_fin_succ {n} {v : Fin (n + 1) → V} :\n    LinearIndependent K v ↔\n      LinearIndependent K (Fin.tail v) ∧ v 0 ∉ Submodule.span K (range <| Fin.tail v) := by\n  rw [← linearIndependent_fin_cons, Fin.cons_self_tail]\n\n"}
{"name":"linearIndependent_fin_succ'","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"K : Type u_3\nV : Type u\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nn : Nat\nv : Fin (HAdd.hAdd n 1) → V\n⊢ Iff (LinearIndependent K v) (And (LinearIndependent K (Fin.init v)) (Not (Membership.mem (Submodule.span K (Set.range (Fin.init v))) (v (Fin.last n)))))","decl":"theorem linearIndependent_fin_succ' {n} {v : Fin (n + 1) → V} : LinearIndependent K v ↔\n    LinearIndependent K (Fin.init v) ∧ v (Fin.last _) ∉ Submodule.span K (range <| Fin.init v) := by\n  rw [← linearIndependent_fin_snoc, Fin.snoc_init_self]\n\n"}
{"name":"linearIndependent_fin2","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"K : Type u_3\nV : Type u\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nf : Fin 2 → V\n⊢ Iff (LinearIndependent K f) (And (Ne (f 1) 0) (∀ (a : K), Ne (HSMul.hSMul a (f 1)) (f 0)))","decl":"theorem linearIndependent_fin2 {f : Fin 2 → V} :\n    LinearIndependent K f ↔ f 1 ≠ 0 ∧ ∀ a : K, a • f 1 ≠ f 0 := by\n  rw [linearIndependent_fin_succ, linearIndependent_unique_iff, range_unique, mem_span_singleton,\n    not_exists, show Fin.tail f default = f 1 by rw [← Fin.succ_zero_eq_one]; rfl]\n\n"}
{"name":"exists_linearIndependent_extension","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"K : Type u_3\nV : Type u\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\ns t : Set V\nhs : LinearIndependent K Subtype.val\nhst : HasSubset.Subset s t\n⊢ Exists fun b => And (HasSubset.Subset b t) (And (HasSubset.Subset s b) (And (HasSubset.Subset t ↑(Submodule.span K b)) (LinearIndependent K Subtype.val)))","decl":"theorem exists_linearIndependent_extension (hs : LinearIndependent K ((↑) : s → V)) (hst : s ⊆ t) :\n    ∃ b ⊆ t, s ⊆ b ∧ t ⊆ span K b ∧ LinearIndependent K ((↑) : b → V) := by\n  obtain ⟨b, sb, h⟩ := by\n    refine zorn_subset_nonempty { b | b ⊆ t ∧ LinearIndependent K ((↑) : b → V) } ?_ _ ⟨hst, hs⟩\n    · refine fun c hc cc _c0 => ⟨⋃₀ c, ⟨?_, ?_⟩, fun x => ?_⟩\n      · exact sUnion_subset fun x xc => (hc xc).1\n      · exact linearIndependent_sUnion_of_directed cc.directedOn fun x xc => (hc xc).2\n      · exact subset_sUnion_of_mem\n  refine ⟨b, h.prop.1, sb, fun x xt => by_contra fun hn ↦ hn ?_, h.prop.2⟩\n  exact subset_span <| h.mem_of_prop_insert ⟨insert_subset xt h.prop.1, h.prop.2.insert hn⟩\n\n"}
{"name":"exists_linearIndependent","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"K : Type u_3\nV : Type u\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nt : Set V\n⊢ Exists fun b => And (HasSubset.Subset b t) (And (Eq (Submodule.span K b) (Submodule.span K t)) (LinearIndependent K Subtype.val))","decl":"theorem exists_linearIndependent :\n    ∃ b ⊆ t, span K b = span K t ∧ LinearIndependent K ((↑) : b → V) := by\n  obtain ⟨b, hb₁, -, hb₂, hb₃⟩ :=\n    exists_linearIndependent_extension (linearIndependent_empty K V) (Set.empty_subset t)\n  exact ⟨b, hb₁, (span_eq_of_le _ hb₂ (Submodule.span_mono hb₁)).symm, hb₃⟩\n\n"}
{"name":"exists_linearIndependent'","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"ι : Type u'\nK : Type u_3\nV : Type u\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nv : ι → V\n⊢ Exists fun κ => Exists fun a => And (Function.Injective a) (And (Eq (Submodule.span K (Set.range (Function.comp v a))) (Submodule.span K (Set.range v))) (LinearIndependent K (Function.comp v a)))","decl":"/-- Indexed version of `exists_linearIndependent`. -/\nlemma exists_linearIndependent' (v : ι → V) :\n    ∃ (κ : Type u') (a : κ → ι), Injective a ∧\n      Submodule.span K (Set.range (v ∘ a)) = Submodule.span K (Set.range v) ∧\n      LinearIndependent K (v ∘ a) := by\n  obtain ⟨t, ht, hsp, hli⟩ := exists_linearIndependent K (Set.range v)\n  choose f hf using ht\n  let s : Set ι := Set.range (fun a : t ↦ f a.property)\n  have hs {i : ι} (hi : i ∈ s) : v i ∈ t := by obtain ⟨a, rfl⟩ := hi; simp [hf]\n  let f' (a : s) : t := ⟨v a.val, hs a.property⟩\n  refine ⟨s, Subtype.val, Subtype.val_injective, hsp.symm ▸ by congr; aesop, ?_⟩\n  · rw [← show Subtype.val ∘ f' = v ∘ Subtype.val by ext; simp [f']]\n    apply hli.comp\n    rintro ⟨i, x, rfl⟩ ⟨j, y, rfl⟩ hij\n    simp only [Subtype.ext_iff, hf, f'] at hij\n    simp [hij]\n\n"}
{"name":"LinearIndependent.extend_subset","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"K : Type u_3\nV : Type u\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\ns t : Set V\nhs : LinearIndependent K fun x => ↑x\nhst : HasSubset.Subset s t\n⊢ HasSubset.Subset (hs.extend hst) t","decl":"theorem LinearIndependent.extend_subset (hs : LinearIndependent K (fun x => x : s → V))\n    (hst : s ⊆ t) : hs.extend hst ⊆ t :=\n  let ⟨hbt, _hsb, _htb, _hli⟩ := Classical.choose_spec (exists_linearIndependent_extension hs hst)\n  hbt\n\n"}
{"name":"LinearIndependent.subset_extend","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"K : Type u_3\nV : Type u\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\ns t : Set V\nhs : LinearIndependent K fun x => ↑x\nhst : HasSubset.Subset s t\n⊢ HasSubset.Subset s (hs.extend hst)","decl":"theorem LinearIndependent.subset_extend (hs : LinearIndependent K (fun x => x : s → V))\n    (hst : s ⊆ t) : s ⊆ hs.extend hst :=\n  let ⟨_hbt, hsb, _htb, _hli⟩ := Classical.choose_spec (exists_linearIndependent_extension hs hst)\n  hsb\n\n"}
{"name":"LinearIndependent.subset_span_extend","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"K : Type u_3\nV : Type u\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\ns t : Set V\nhs : LinearIndependent K fun x => ↑x\nhst : HasSubset.Subset s t\n⊢ HasSubset.Subset t ↑(Submodule.span K (hs.extend hst))","decl":"theorem LinearIndependent.subset_span_extend (hs : LinearIndependent K (fun x => x : s → V))\n    (hst : s ⊆ t) : t ⊆ span K (hs.extend hst) :=\n  let ⟨_hbt, _hsb, htb, _hli⟩ := Classical.choose_spec (exists_linearIndependent_extension hs hst)\n  htb\n\n"}
{"name":"LinearIndependent.span_extend_eq_span","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"K : Type u_3\nV : Type u\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\ns t : Set V\nhs : LinearIndependent K fun x => ↑x\nhst : HasSubset.Subset s t\n⊢ Eq (Submodule.span K (hs.extend hst)) (Submodule.span K t)","decl":"theorem LinearIndependent.span_extend_eq_span (hs : LinearIndependent K (fun x => x : s → V))\n    (hst : s ⊆ t) : span K (hs.extend hst) = span K t :=\n  le_antisymm (span_mono (hs.extend_subset hst)) (span_le.2 (hs.subset_span_extend hst))\n\n"}
{"name":"LinearIndependent.linearIndependent_extend","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"K : Type u_3\nV : Type u\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\ns t : Set V\nhs : LinearIndependent K fun x => ↑x\nhst : HasSubset.Subset s t\n⊢ LinearIndependent K Subtype.val","decl":"theorem LinearIndependent.linearIndependent_extend (hs : LinearIndependent K (fun x => x : s → V))\n    (hst : s ⊆ t) : LinearIndependent K ((↑) : hs.extend hst → V) :=\n  let ⟨_hbt, _hsb, _htb, hli⟩ := Classical.choose_spec (exists_linearIndependent_extension hs hst)\n  hli\n\n-- TODO(Mario): rewrite?\n"}
{"name":"exists_of_linearIndependent_of_finite_span","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"K : Type u_3\nV : Type u\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\ns : Set V\nt : Finset V\nhs : LinearIndependent K fun x => ↑x\nhst : HasSubset.Subset s ↑(Submodule.span K ↑t)\n⊢ Exists fun t' => And (HasSubset.Subset (↑t') (Union.union s ↑t)) (And (HasSubset.Subset s ↑t') (Eq t'.card t.card))","decl":"theorem exists_of_linearIndependent_of_finite_span {t : Finset V}\n    (hs : LinearIndependent K (fun x => x : s → V)) (hst : s ⊆ (span K ↑t : Submodule K V)) :\n    ∃ t' : Finset V, ↑t' ⊆ s ∪ ↑t ∧ s ⊆ ↑t' ∧ t'.card = t.card := by\n  classical\n  have :\n    ∀ t : Finset V,\n      ∀ s' : Finset V,\n        ↑s' ⊆ s →\n          s ∩ ↑t = ∅ →\n            s ⊆ (span K ↑(s' ∪ t) : Submodule K V) →\n              ∃ t' : Finset V, ↑t' ⊆ s ∪ ↑t ∧ s ⊆ ↑t' ∧ t'.card = (s' ∪ t).card :=\n    fun t =>\n    Finset.induction_on t\n      (fun s' hs' _ hss' =>\n        have : s = ↑s' := eq_of_linearIndependent_of_span_subtype hs hs' <| by simpa using hss'\n        ⟨s', by simp [this]⟩)\n      fun b₁ t hb₁t ih s' hs' hst hss' =>\n      have hb₁s : b₁ ∉ s := fun h => by\n        have : b₁ ∈ s ∩ ↑(insert b₁ t) := ⟨h, Finset.mem_insert_self _ _⟩\n        rwa [hst] at this\n      have hb₁s' : b₁ ∉ s' := fun h => hb₁s <| hs' h\n      have hst : s ∩ ↑t = ∅ :=\n        eq_empty_of_subset_empty <|\n          -- Porting note: `-inter_subset_left, -subset_inter_iff` required.\n          Subset.trans\n            (by simp [inter_subset_inter, Subset.refl, -inter_subset_left, -subset_inter_iff])\n            (le_of_eq hst)\n      Classical.by_cases (p := s ⊆ (span K ↑(s' ∪ t) : Submodule K V))\n        (fun this =>\n          let ⟨u, hust, hsu, Eq⟩ := ih _ hs' hst this\n          have hb₁u : b₁ ∉ u := fun h => (hust h).elim hb₁s hb₁t\n          ⟨insert b₁ u, by simp [insert_subset_insert hust], Subset.trans hsu (by simp), by\n            simp [Eq, hb₁t, hb₁s', hb₁u]⟩)\n        fun this =>\n        let ⟨b₂, hb₂s, hb₂t⟩ := not_subset.mp this\n        have hb₂t' : b₂ ∉ s' ∪ t := fun h => hb₂t <| subset_span h\n        have : s ⊆ (span K ↑(insert b₂ s' ∪ t) : Submodule K V) := fun b₃ hb₃ => by\n          have : ↑(s' ∪ insert b₁ t) ⊆ insert b₁ (insert b₂ ↑(s' ∪ t) : Set V) := by\n            -- Porting note: Too many theorems to be excluded, so\n            --               `simp only` is shorter.\n            simp only [insert_eq, union_subset_union, Subset.refl,\n              subset_union_right, Finset.union_insert, Finset.coe_insert]\n          have hb₃ : b₃ ∈ span K (insert b₁ (insert b₂ ↑(s' ∪ t) : Set V)) :=\n            span_mono this (hss' hb₃)\n          have : s ⊆ (span K (insert b₁ ↑(s' ∪ t)) : Submodule K V) := by\n            simpa [insert_eq, -singleton_union, -union_singleton] using hss'\n          -- Porting note: `by exact` is required to prevent timeout.\n          have hb₁ : b₁ ∈ span K (insert b₂ ↑(s' ∪ t)) := by\n            exact mem_span_insert_exchange (this hb₂s) hb₂t\n          rw [span_insert_eq_span hb₁] at hb₃; simpa using hb₃\n        let ⟨u, hust, hsu, eq⟩ := ih _ (by simp [insert_subset_iff, hb₂s, hs']) hst this\n        -- Porting note: `hb₂t'` → `Finset.card_insert_of_not_mem hb₂t'`\n        ⟨u, Subset.trans hust <| union_subset_union (Subset.refl _) (by simp [subset_insert]), hsu,\n          by simp [eq, Finset.card_insert_of_not_mem hb₂t', hb₁t, hb₁s']⟩\n  have eq : ((t.filter fun x => x ∈ s) ∪ t.filter fun x => x ∉ s) = t := by\n    ext1 x\n    by_cases x ∈ s <;> simp [*]\n  apply\n    Exists.elim\n      (this (t.filter fun x => x ∉ s) (t.filter fun x => x ∈ s) (by simp [Set.subset_def])\n        (by simp +contextual [Set.ext_iff]) (by rwa [eq]))\n  intro u h\n  exact\n    ⟨u, Subset.trans h.1 (by simp +contextual [subset_def, and_imp, or_imp]),\n      h.2.1, by simp only [h.2.2, eq]⟩\n\n"}
{"name":"exists_finite_card_le_of_finite_of_linearIndependent_of_span","module":"Mathlib.LinearAlgebra.LinearIndependent","initialProofState":"K : Type u_3\nV : Type u\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\ns t : Set V\nht : t.Finite\nhs : LinearIndependent K fun x => ↑x\nhst : HasSubset.Subset s ↑(Submodule.span K t)\n⊢ Exists fun h => LE.le h.toFinset.card ht.toFinset.card","decl":"theorem exists_finite_card_le_of_finite_of_linearIndependent_of_span (ht : t.Finite)\n    (hs : LinearIndependent K (fun x => x : s → V)) (hst : s ⊆ span K t) :\n    ∃ h : s.Finite, h.toFinset.card ≤ ht.toFinset.card :=\n  have : s ⊆ (span K ↑ht.toFinset : Submodule K V) := by simpa\n  let ⟨u, _hust, hsu, Eq⟩ := exists_of_linearIndependent_of_finite_span hs this\n  have : s.Finite := u.finite_toSet.subset hsu\n  ⟨this, by rw [← Eq]; exact Finset.card_le_card <| Finset.coe_subset.mp <| by simp [hsu]⟩\n\n"}
