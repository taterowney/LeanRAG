{"name":"TopCat.instHasLimitsPresheaf","module":"Mathlib.Topology.Sheaves.Limits","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasLimits C\nX : TopCat\n⊢ CategoryTheory.Limits.HasLimits (TopCat.Presheaf C X)","decl":"instance [HasLimits C] (X : TopCat.{v}) : HasLimits.{v} (Presheaf C X) :=\n  Limits.functorCategoryHasLimitsOfSize.{v, v}\n\n"}
{"name":"TopCat.instHasColimitsOfSizePresheafOfHasColimits","module":"Mathlib.Topology.Sheaves.Limits","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasColimits C\nX : TopCat\n⊢ CategoryTheory.Limits.HasColimitsOfSize.{v, v, max v w, max (max u v) w} (TopCat.Presheaf C X)","decl":"instance [HasColimits.{v, u} C] (X : TopCat.{w}) : HasColimitsOfSize.{v, v} (Presheaf C X) :=\n  Limits.functorCategoryHasColimitsOfSize\n\n"}
{"name":"TopCat.instHasLimitsOfSizeSheafOfHasLimits","module":"Mathlib.Topology.Sheaves.Limits","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasLimits C\nX : TopCat\n⊢ CategoryTheory.Limits.HasLimitsOfSize.{v, v, v, max v u} (TopCat.Sheaf C X)","decl":"instance [HasLimits C] (X : TopCat.{v}) : HasLimitsOfSize.{v, v} (Sheaf.{v} C X) :=\n  hasLimits_of_hasLimits_createsLimits (Sheaf.forget C X)\n\n"}
{"name":"TopCat.isSheaf_of_isLimit","module":"Mathlib.Topology.Sheaves.Limits","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : Type v\ninst✝¹ : CategoryTheory.SmallCategory J\ninst✝ : CategoryTheory.Limits.HasLimits C\nX : TopCat\nF : CategoryTheory.Functor J (TopCat.Presheaf C X)\nH : ∀ (j : J), (F.obj j).IsSheaf\nc : CategoryTheory.Limits.Cone F\nhc : CategoryTheory.Limits.IsLimit c\n⊢ c.pt.IsSheaf","decl":"theorem isSheaf_of_isLimit [HasLimits C] {X : TopCat} (F : J ⥤ Presheaf.{v} C X)\n    (H : ∀ j, (F.obj j).IsSheaf) {c : Cone F} (hc : IsLimit c) : c.pt.IsSheaf := by\n  let F' : J ⥤ Sheaf C X :=\n    { obj := fun j => ⟨F.obj j, H j⟩\n      map := fun f => ⟨F.map f⟩ }\n  let e : F' ⋙ Sheaf.forget C X ≅ F := NatIso.ofComponents fun _ => Iso.refl _\n  exact Presheaf.isSheaf_of_iso\n    ((isLimitOfPreserves (Sheaf.forget C X) (limit.isLimit F')).conePointsIsoOfNatIso hc e)\n    (limit F').2\n\n"}
{"name":"TopCat.limit_isSheaf","module":"Mathlib.Topology.Sheaves.Limits","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : Type v\ninst✝¹ : CategoryTheory.SmallCategory J\ninst✝ : CategoryTheory.Limits.HasLimits C\nX : TopCat\nF : CategoryTheory.Functor J (TopCat.Presheaf C X)\nH : ∀ (j : J), (F.obj j).IsSheaf\n⊢ (CategoryTheory.Limits.limit F).IsSheaf","decl":"theorem limit_isSheaf [HasLimits C] {X : TopCat} (F : J ⥤ Presheaf.{v} C X)\n    (H : ∀ j, (F.obj j).IsSheaf) : (limit F).IsSheaf :=\n  isSheaf_of_isLimit F H (limit.isLimit F)\n\n"}
