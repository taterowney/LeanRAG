{"name":"exists_smooth_tsupport_subset","module":"Mathlib.Analysis.Calculus.BumpFunction.FiniteDimension","initialProofState":"E : Type u_1\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : NormedSpace Real E\ninst‚úù : FiniteDimensional Real E\ns : Set E\nx : E\nhs : Membership.mem (nhds x) s\n‚ä¢ Exists fun f => And (HasSubset.Subset (tsupport f) s) (And (HasCompactSupport f) (And (ContDiff Real (‚ÜëTop.top) f) (And (HasSubset.Subset (Set.range f) (Set.Icc 0 1)) (Eq (f x) 1))))","decl":"/-- If a set `s` is a neighborhood of `x`, then there exists a smooth function `f` taking\nvalues in `[0, 1]`, supported in `s` and with `f x = 1`. -/\ntheorem exists_smooth_tsupport_subset {s : Set E} {x : E} (hs : s ‚àà ùìù x) :\n    ‚àÉ f : E ‚Üí ‚Ñù,\n      tsupport f ‚äÜ s ‚àß HasCompactSupport f ‚àß ContDiff ‚Ñù ‚àû f ‚àß range f ‚äÜ Icc 0 1 ‚àß f x = 1 := by\n  obtain ‚ü®d : ‚Ñù, d_pos : 0 < d, hd : Euclidean.closedBall x d ‚äÜ s‚ü© :=\n    Euclidean.nhds_basis_closedBall.mem_iff.1 hs\n  let c : ContDiffBump (toEuclidean x) :=\n    { rIn := d / 2\n      rOut := d\n      rIn_pos := half_pos d_pos\n      rIn_lt_rOut := half_lt_self d_pos }\n  let f : E ‚Üí ‚Ñù := c ‚àò toEuclidean\n  have f_supp : f.support ‚äÜ Euclidean.ball x d := by\n    intro y hy\n    have : toEuclidean y ‚àà Function.support c := by\n      simpa only [Function.mem_support, Function.comp_apply, Ne] using hy\n    rwa [c.support_eq] at this\n  have f_tsupp : tsupport f ‚äÜ Euclidean.closedBall x d := by\n    rw [tsupport, ‚Üê Euclidean.closure_ball _ d_pos.ne']\n    exact closure_mono f_supp\n  refine ‚ü®f, f_tsupp.trans hd, ?_, ?_, ?_, ?_‚ü©\n  ¬∑ refine isCompact_of_isClosed_isBounded isClosed_closure ?_\n    have : IsBounded (Euclidean.closedBall x d) := Euclidean.isCompact_closedBall.isBounded\n    refine this.subset (Euclidean.isClosed_closedBall.closure_subset_iff.2 ?_)\n    exact f_supp.trans Euclidean.ball_subset_closedBall\n  ¬∑ apply c.contDiff.comp\n    exact ContinuousLinearEquiv.contDiff _\n  ¬∑ rintro t ‚ü®y, rfl‚ü©\n    exact ‚ü®c.nonneg, c.le_one‚ü©\n  ¬∑ apply c.one_of_mem_closedBall\n    apply mem_closedBall_self\n    exact (half_pos d_pos).le\n\n"}
{"name":"IsOpen.exists_smooth_support_eq","module":"Mathlib.Analysis.Calculus.BumpFunction.FiniteDimension","initialProofState":"E : Type u_1\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : NormedSpace Real E\ninst‚úù : FiniteDimensional Real E\ns : Set E\nhs : IsOpen s\n‚ä¢ Exists fun f => And (Eq (Function.support f) s) (And (ContDiff Real (‚ÜëTop.top) f) (HasSubset.Subset (Set.range f) (Set.Icc 0 1)))","decl":"/-- Given an open set `s` in a finite-dimensional real normed vector space, there exists a smooth\nfunction with values in `[0, 1]` whose support is exactly `s`. -/\ntheorem IsOpen.exists_smooth_support_eq {s : Set E} (hs : IsOpen s) :\n    ‚àÉ f : E ‚Üí ‚Ñù, f.support = s ‚àß ContDiff ‚Ñù ‚àû f ‚àß Set.range f ‚äÜ Set.Icc 0 1 := by\n  /- For any given point `x` in `s`, one can construct a smooth function with support in `s` and\n    nonzero at `x`. By second-countability, it follows that we may cover `s` with the supports of\n    countably many such functions, say `g i`.\n    Then `‚àë i, r i ‚Ä¢ g i` will be the desired function if `r i` is a sequence of positive numbers\n    tending quickly enough to zero. Indeed, this ensures that, for any `k ‚â§ i`, the `k`-th\n    derivative of `r i ‚Ä¢ g i` is bounded by a prescribed (summable) sequence `u i`. From this, the\n    summability of the series and of its successive derivatives follows. -/\n  rcases eq_empty_or_nonempty s with (rfl | h's)\n  ¬∑ exact\n      ‚ü®fun _ => 0, Function.support_zero, contDiff_const, by\n        simp only [range_const, singleton_subset_iff, left_mem_Icc, zero_le_one]‚ü©\n  let Œπ := { f : E ‚Üí ‚Ñù // f.support ‚äÜ s ‚àß HasCompactSupport f ‚àß ContDiff ‚Ñù ‚àû f ‚àß range f ‚äÜ Icc 0 1 }\n  obtain ‚ü®T, T_count, hT‚ü© : ‚àÉ T : Set Œπ, T.Countable ‚àß ‚ãÉ f ‚àà T, support (f : E ‚Üí ‚Ñù) = s := by\n    have : ‚ãÉ f : Œπ, (f : E ‚Üí ‚Ñù).support = s := by\n      refine Subset.antisymm (iUnion_subset fun f => f.2.1) ?_\n      intro x hx\n      rcases exists_smooth_tsupport_subset (hs.mem_nhds hx) with ‚ü®f, hf‚ü©\n      let g : Œπ := ‚ü®f, (subset_tsupport f).trans hf.1, hf.2.1, hf.2.2.1, hf.2.2.2.1‚ü©\n      have : x ‚àà support (g : E ‚Üí ‚Ñù) := by\n        simp only [g, hf.2.2.2.2, Subtype.coe_mk, mem_support, Ne, one_ne_zero,\n          not_false_iff]\n      exact mem_iUnion_of_mem _ this\n    simp_rw [‚Üê this]\n    apply isOpen_iUnion_countable\n    rintro ‚ü®f, hf‚ü©\n    exact hf.2.2.1.continuous.isOpen_support\n  obtain ‚ü®g0, hg‚ü© : ‚àÉ g0 : ‚Ñï ‚Üí Œπ, T = range g0 := by\n    apply Countable.exists_eq_range T_count\n    rcases eq_empty_or_nonempty T with (rfl | hT)\n    ¬∑ simp only [Œπ, iUnion_false, iUnion_empty] at hT\n      simp only [‚Üê hT, mem_empty_iff_false, iUnion_of_empty, iUnion_empty, Set.not_nonempty_empty]\n          at h's\n    ¬∑ exact hT\n  let g : ‚Ñï ‚Üí E ‚Üí ‚Ñù := fun n => (g0 n).1\n  have g_s : ‚àÄ n, support (g n) ‚äÜ s := fun n => (g0 n).2.1\n  have s_g : ‚àÄ x ‚àà s, ‚àÉ n, x ‚àà support (g n) := fun x hx ‚Ü¶ by\n    rw [‚Üê hT] at hx\n    obtain ‚ü®i, iT, hi‚ü© : ‚àÉ i ‚àà T, x ‚àà support (i : E ‚Üí ‚Ñù) := by\n      simpa only [mem_iUnion, exists_prop] using hx\n    rw [hg, mem_range] at iT\n    rcases iT with ‚ü®n, hn‚ü©\n    rw [‚Üê hn] at hi\n    exact ‚ü®n, hi‚ü©\n  have g_smooth : ‚àÄ n, ContDiff ‚Ñù ‚àû (g n) := fun n => (g0 n).2.2.2.1\n  have g_comp_supp : ‚àÄ n, HasCompactSupport (g n) := fun n => (g0 n).2.2.1\n  have g_nonneg : ‚àÄ n x, 0 ‚â§ g n x := fun n x => ((g0 n).2.2.2.2 (mem_range_self x)).1\n  obtain ‚ü®Œ¥, Œ¥pos, c, Œ¥c, c_lt‚ü© :\n      ‚àÉ Œ¥ : ‚Ñï ‚Üí ‚Ñù‚â•0, (‚àÄ i : ‚Ñï, 0 < Œ¥ i) ‚àß ‚àÉ c : NNReal, HasSum Œ¥ c ‚àß c < 1 :=\n    NNReal.exists_pos_sum_of_countable one_ne_zero ‚Ñï\n  have : ‚àÄ n : ‚Ñï, ‚àÉ r : ‚Ñù, 0 < r ‚àß ‚àÄ i ‚â§ n, ‚àÄ x, ‚ÄñiteratedFDeriv ‚Ñù i (r ‚Ä¢ g n) x‚Äñ ‚â§ Œ¥ n := by\n    intro n\n    have : ‚àÄ i, ‚àÉ R, ‚àÄ x, ‚ÄñiteratedFDeriv ‚Ñù i (fun x => g n x) x‚Äñ ‚â§ R := by\n      intro i\n      have : BddAbove (range fun x => ‚ÄñiteratedFDeriv ‚Ñù i (fun x : E => g n x) x‚Äñ) := by\n        apply ((g_smooth n).continuous_iteratedFDeriv\n          (mod_cast le_top)).norm.bddAbove_range_of_hasCompactSupport\n        apply HasCompactSupport.comp_left _ norm_zero\n        apply (g_comp_supp n).iteratedFDeriv\n      rcases this with ‚ü®R, hR‚ü©\n      exact ‚ü®R, fun x => hR (mem_range_self _)‚ü©\n    choose R hR using this\n    let M := max (((Finset.range (n + 1)).image R).max' (by simp)) 1\n    have Œ¥npos : 0 < Œ¥ n := Œ¥pos n\n    have IR : ‚àÄ i ‚â§ n, R i ‚â§ M := by\n      intro i hi\n      refine le_trans ?_ (le_max_left _ _)\n      apply Finset.le_max'\n      apply Finset.mem_image_of_mem\n      -- Porting note: was\n      -- simp only [Finset.mem_range]\n      -- linarith\n      simpa only [Finset.mem_range, Nat.lt_add_one_iff]\n    refine ‚ü®M‚Åª¬π * Œ¥ n, by positivity, fun i hi x => ?_‚ü©\n    calc\n      ‚ÄñiteratedFDeriv ‚Ñù i ((M‚Åª¬π * Œ¥ n) ‚Ä¢ g n) x‚Äñ = ‚Äñ(M‚Åª¬π * Œ¥ n) ‚Ä¢ iteratedFDeriv ‚Ñù i (g n) x‚Äñ := by\n        rw [iteratedFDeriv_const_smul_apply]\n        exact (g_smooth n).contDiffAt.of_le (mod_cast le_top)\n      _ = M‚Åª¬π * Œ¥ n * ‚ÄñiteratedFDeriv ‚Ñù i (g n) x‚Äñ := by\n        rw [norm_smul _ (iteratedFDeriv ‚Ñù i (g n) x), Real.norm_of_nonneg]; positivity\n      _ ‚â§ M‚Åª¬π * Œ¥ n * M := by gcongr; exact (hR i x).trans (IR i hi)\n      _ = Œ¥ n := by field_simp\n  choose r rpos hr using this\n  have S : ‚àÄ x, Summable fun n => (r n ‚Ä¢ g n) x := fun x ‚Ü¶ by\n    refine .of_nnnorm_bounded _ Œ¥c.summable fun n => ?_\n    rw [‚Üê NNReal.coe_le_coe, coe_nnnorm]\n    simpa only [norm_iteratedFDeriv_zero] using hr n 0 (zero_le n) x\n  refine ‚ü®fun x => ‚àë' n, (r n ‚Ä¢ g n) x, ?_, ?_, ?_‚ü©\n  ¬∑ apply Subset.antisymm\n    ¬∑ intro x hx\n      simp only [Pi.smul_apply, Algebra.id.smul_eq_mul, mem_support, Ne] at hx\n      contrapose! hx\n      have : ‚àÄ n, g n x = 0 := by\n        intro n\n        contrapose! hx\n        exact g_s n hx\n      simp only [this, mul_zero, tsum_zero]\n    ¬∑ intro x hx\n      obtain ‚ü®n, hn‚ü© : ‚àÉ n, x ‚àà support (g n) := s_g x hx\n      have I : 0 < r n * g n x := mul_pos (rpos n) (lt_of_le_of_ne (g_nonneg n x) (Ne.symm hn))\n      exact ne_of_gt (tsum_pos (S x) (fun i => mul_nonneg (rpos i).le (g_nonneg i x)) n I)\n  ¬∑ refine\n      contDiff_tsum_of_eventually (fun n => (g_smooth n).const_smul (r n))\n        (fun k _ => (NNReal.hasSum_coe.2 Œ¥c).summable) ?_\n    intro i _\n    simp only [Nat.cofinite_eq_atTop, Pi.smul_apply, Algebra.id.smul_eq_mul,\n      Filter.eventually_atTop]\n    exact ‚ü®i, fun n hn x => hr _ _ hn _‚ü©\n  ¬∑ rintro - ‚ü®y, rfl‚ü©\n    refine ‚ü®tsum_nonneg fun n => mul_nonneg (rpos n).le (g_nonneg n y), le_trans ?_ c_lt.le‚ü©\n    have A : HasSum (fun n => (Œ¥ n : ‚Ñù)) c := NNReal.hasSum_coe.2 Œ¥c\n    simp only [Pi.smul_apply, smul_eq_mul, NNReal.val_eq_coe, ‚Üê A.tsum_eq]\n    apply tsum_le_tsum _ (S y) A.summable\n    intro n\n    apply (le_abs_self _).trans\n    simpa only [norm_iteratedFDeriv_zero] using hr n 0 (zero_le n) y\n\n"}
{"name":"ExistsContDiffBumpBase.u_exists","module":"Mathlib.Analysis.Calculus.BumpFunction.FiniteDimension","initialProofState":"E : Type u_1\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : NormedSpace Real E\ninst‚úù : FiniteDimensional Real E\n‚ä¢ Exists fun u => And (ContDiff Real (‚ÜëTop.top) u) (And (‚àÄ (x : E), Membership.mem (Set.Icc 0 1) (u x)) (And (Eq (Function.support u) (Metric.ball 0 1)) (‚àÄ (x : E), Eq (u (Neg.neg x)) (u x))))","decl":"theorem u_exists :\n    ‚àÉ u : E ‚Üí ‚Ñù,\n      ContDiff ‚Ñù ‚àû u ‚àß (‚àÄ x, u x ‚àà Icc (0 : ‚Ñù) 1) ‚àß support u = ball 0 1 ‚àß ‚àÄ x, u (-x) = u x := by\n  have A : IsOpen (ball (0 : E) 1) := isOpen_ball\n  obtain ‚ü®f, f_support, f_smooth, f_range‚ü© :\n      ‚àÉ f : E ‚Üí ‚Ñù, f.support = ball (0 : E) 1 ‚àß ContDiff ‚Ñù ‚àû f ‚àß Set.range f ‚äÜ Set.Icc 0 1 :=\n    A.exists_smooth_support_eq\n  have B : ‚àÄ x, f x ‚àà Icc (0 : ‚Ñù) 1 := fun x => f_range (mem_range_self x)\n  refine ‚ü®fun x => (f x + f (-x)) / 2, ?_, ?_, ?_, ?_‚ü©\n  ¬∑ exact (f_smooth.add (f_smooth.comp contDiff_neg)).div_const _\n  ¬∑ intro x\n    simp only [mem_Icc]\n    constructor\n    ¬∑ linarith [(B x).1, (B (-x)).1]\n    ¬∑ linarith [(B x).2, (B (-x)).2]\n  ¬∑ refine support_eq_iff.2 ‚ü®fun x hx => ?_, fun x hx => ?_‚ü©\n    ¬∑ apply ne_of_gt\n      have : 0 < f x := by\n        apply lt_of_le_of_ne (B x).1 (Ne.symm _)\n        rwa [‚Üê f_support] at hx\n      linarith [(B (-x)).1]\n    ¬∑ have I1 : x ‚àâ support f := by rwa [f_support]\n      have I2 : -x ‚àâ support f := by\n        rw [f_support]\n        simpa using hx\n      simp only [mem_support, Classical.not_not] at I1 I2\n      simp only [I1, I2, add_zero, zero_div]\n  ¬∑ intro x; simp only [add_comm, neg_neg]\n\n"}
{"name":"ExistsContDiffBumpBase.u_smooth","module":"Mathlib.Analysis.Calculus.BumpFunction.FiniteDimension","initialProofState":"E : Type u_1\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : NormedSpace Real E\ninst‚úù : FiniteDimensional Real E\n‚ä¢ ContDiff Real (‚ÜëTop.top) ExistsContDiffBumpBase.u","decl":"theorem u_smooth : ContDiff ‚Ñù ‚àû (u : E ‚Üí ‚Ñù) :=\n  (Classical.choose_spec (u_exists E)).1\n\n"}
{"name":"ExistsContDiffBumpBase.u_continuous","module":"Mathlib.Analysis.Calculus.BumpFunction.FiniteDimension","initialProofState":"E : Type u_1\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : NormedSpace Real E\ninst‚úù : FiniteDimensional Real E\n‚ä¢ Continuous ExistsContDiffBumpBase.u","decl":"theorem u_continuous : Continuous (u : E ‚Üí ‚Ñù) :=\n  (u_smooth E).continuous\n\n"}
{"name":"ExistsContDiffBumpBase.u_support","module":"Mathlib.Analysis.Calculus.BumpFunction.FiniteDimension","initialProofState":"E : Type u_1\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : NormedSpace Real E\ninst‚úù : FiniteDimensional Real E\n‚ä¢ Eq (Function.support ExistsContDiffBumpBase.u) (Metric.ball 0 1)","decl":"theorem u_support : support (u : E ‚Üí ‚Ñù) = ball 0 1 :=\n  (Classical.choose_spec (u_exists E)).2.2.1\n\n"}
{"name":"ExistsContDiffBumpBase.u_compact_support","module":"Mathlib.Analysis.Calculus.BumpFunction.FiniteDimension","initialProofState":"E : Type u_1\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : NormedSpace Real E\ninst‚úù : FiniteDimensional Real E\n‚ä¢ HasCompactSupport ExistsContDiffBumpBase.u","decl":"theorem u_compact_support : HasCompactSupport (u : E ‚Üí ‚Ñù) := by\n  rw [hasCompactSupport_def, u_support, closure_ball (0 : E) one_ne_zero]\n  exact isCompact_closedBall _ _\n\n"}
{"name":"ExistsContDiffBumpBase.u_nonneg","module":"Mathlib.Analysis.Calculus.BumpFunction.FiniteDimension","initialProofState":"E : Type u_1\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : NormedSpace Real E\ninst‚úù : FiniteDimensional Real E\nx : E\n‚ä¢ LE.le 0 (ExistsContDiffBumpBase.u x)","decl":"theorem u_nonneg (x : E) : 0 ‚â§ u x :=\n  ((Classical.choose_spec (u_exists E)).2.1 x).1\n\n"}
{"name":"ExistsContDiffBumpBase.u_le_one","module":"Mathlib.Analysis.Calculus.BumpFunction.FiniteDimension","initialProofState":"E : Type u_1\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : NormedSpace Real E\ninst‚úù : FiniteDimensional Real E\nx : E\n‚ä¢ LE.le (ExistsContDiffBumpBase.u x) 1","decl":"theorem u_le_one (x : E) : u x ‚â§ 1 :=\n  ((Classical.choose_spec (u_exists E)).2.1 x).2\n\n"}
{"name":"ExistsContDiffBumpBase.u_neg","module":"Mathlib.Analysis.Calculus.BumpFunction.FiniteDimension","initialProofState":"E : Type u_1\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : NormedSpace Real E\ninst‚úù : FiniteDimensional Real E\nx : E\n‚ä¢ Eq (ExistsContDiffBumpBase.u (Neg.neg x)) (ExistsContDiffBumpBase.u x)","decl":"theorem u_neg (x : E) : u (-x) = u x :=\n  (Classical.choose_spec (u_exists E)).2.2.2 x\n\n"}
{"name":"ExistsContDiffBumpBase.u_int_pos","module":"Mathlib.Analysis.Calculus.BumpFunction.FiniteDimension","initialProofState":"E : Type u_1\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : FiniteDimensional Real E\ninst‚úù¬π : MeasurableSpace E\ninst‚úù : BorelSpace E\n‚ä¢ LT.lt 0 (MeasureTheory.integral MeasureTheory.Measure.addHaar fun x => ExistsContDiffBumpBase.u x)","decl":"theorem u_int_pos : 0 < ‚à´ x : E, u x ‚àÇŒº := by\n  refine (integral_pos_iff_support_of_nonneg u_nonneg ?_).mpr ?_\n  ¬∑ exact (u_continuous E).integrable_of_hasCompactSupport (u_compact_support E)\n  ¬∑ rw [u_support]; exact measure_ball_pos _ _ zero_lt_one\n\n"}
{"name":"ExistsContDiffBumpBase.w_def","module":"Mathlib.Analysis.Calculus.BumpFunction.FiniteDimension","initialProofState":"E : Type u_1\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : FiniteDimensional Real E\ninst‚úù¬π : MeasurableSpace E\ninst‚úù : BorelSpace E\nD : Real\n‚ä¢ Eq (ExistsContDiffBumpBase.w D) fun x => HSMul.hSMul (Inv.inv (HMul.hMul (MeasureTheory.integral MeasureTheory.Measure.addHaar fun x => ExistsContDiffBumpBase.u x) (HPow.hPow (abs D) (Module.finrank Real E)))) (ExistsContDiffBumpBase.u (HSMul.hSMul (Inv.inv D) x))","decl":"theorem w_def (D : ‚Ñù) :\n    (w D : E ‚Üí ‚Ñù) = fun x => ((‚à´ x : E, u x ‚àÇŒº) * |D| ^ finrank ‚Ñù E)‚Åª¬π ‚Ä¢ u (D‚Åª¬π ‚Ä¢ x) := by\n  ext1 x; rfl\n\n"}
{"name":"ExistsContDiffBumpBase.w_nonneg","module":"Mathlib.Analysis.Calculus.BumpFunction.FiniteDimension","initialProofState":"E : Type u_1\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : FiniteDimensional Real E\ninst‚úù¬π : MeasurableSpace E\ninst‚úù : BorelSpace E\nD : Real\nx : E\n‚ä¢ LE.le 0 (ExistsContDiffBumpBase.w D x)","decl":"theorem w_nonneg (D : ‚Ñù) (x : E) : 0 ‚â§ w D x := by\n  apply mul_nonneg _ (u_nonneg _)\n  apply inv_nonneg.2\n  apply mul_nonneg (u_int_pos E).le\n  norm_cast\n  apply pow_nonneg (abs_nonneg D)\n\n"}
{"name":"ExistsContDiffBumpBase.w_mul_œÜ_nonneg","module":"Mathlib.Analysis.Calculus.BumpFunction.FiniteDimension","initialProofState":"E : Type u_1\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : FiniteDimensional Real E\ninst‚úù¬π : MeasurableSpace E\ninst‚úù : BorelSpace E\nD : Real\nx y : E\n‚ä¢ LE.le 0 (HMul.hMul (ExistsContDiffBumpBase.w D y) (ExistsContDiffBumpBase.œÜ (HSub.hSub x y)))","decl":"theorem w_mul_œÜ_nonneg (D : ‚Ñù) (x y : E) : 0 ‚â§ w D y * œÜ (x - y) :=\n  mul_nonneg (w_nonneg D y) (indicator_nonneg (by simp only [zero_le_one, imp_true_iff]) _)\n\n"}
{"name":"ExistsContDiffBumpBase.w_integral","module":"Mathlib.Analysis.Calculus.BumpFunction.FiniteDimension","initialProofState":"E : Type u_1\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : FiniteDimensional Real E\ninst‚úù¬π : MeasurableSpace E\ninst‚úù : BorelSpace E\nD : Real\nDpos : LT.lt 0 D\n‚ä¢ Eq (MeasureTheory.integral MeasureTheory.Measure.addHaar fun x => ExistsContDiffBumpBase.w D x) 1","decl":"theorem w_integral {D : ‚Ñù} (Dpos : 0 < D) : ‚à´ x : E, w D x ‚àÇŒº = 1 := by\n  simp_rw [w, integral_smul]\n  rw [integral_comp_inv_smul_of_nonneg Œº (u : E ‚Üí ‚Ñù) Dpos.le, abs_of_nonneg Dpos.le, mul_comm]\n  field_simp [(u_int_pos E).ne']\n\n"}
{"name":"ExistsContDiffBumpBase.w_support","module":"Mathlib.Analysis.Calculus.BumpFunction.FiniteDimension","initialProofState":"E : Type u_1\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : FiniteDimensional Real E\ninst‚úù¬π : MeasurableSpace E\ninst‚úù : BorelSpace E\nD : Real\nDpos : LT.lt 0 D\n‚ä¢ Eq (Function.support (ExistsContDiffBumpBase.w D)) (Metric.ball 0 D)","decl":"theorem w_support {D : ‚Ñù} (Dpos : 0 < D) : support (w D : E ‚Üí ‚Ñù) = ball 0 D := by\n  have B : D ‚Ä¢ ball (0 : E) 1 = ball 0 D := by\n    rw [smul_unitBall Dpos.ne', Real.norm_of_nonneg Dpos.le]\n  have C : D ^ finrank ‚Ñù E ‚â† 0 := by\n    norm_cast\n    exact pow_ne_zero _ Dpos.ne'\n  simp only [w_def, Algebra.id.smul_eq_mul, support_mul, support_inv, univ_inter,\n    support_comp_inv_smul‚ÇÄ Dpos.ne', u_support, B, support_const (u_int_pos E).ne', support_const C,\n    abs_of_nonneg Dpos.le]\n\n"}
{"name":"ExistsContDiffBumpBase.w_compact_support","module":"Mathlib.Analysis.Calculus.BumpFunction.FiniteDimension","initialProofState":"E : Type u_1\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : FiniteDimensional Real E\ninst‚úù¬π : MeasurableSpace E\ninst‚úù : BorelSpace E\nD : Real\nDpos : LT.lt 0 D\n‚ä¢ HasCompactSupport (ExistsContDiffBumpBase.w D)","decl":"theorem w_compact_support {D : ‚Ñù} (Dpos : 0 < D) : HasCompactSupport (w D : E ‚Üí ‚Ñù) := by\n  rw [hasCompactSupport_def, w_support E Dpos, closure_ball (0 : E) Dpos.ne']\n  exact isCompact_closedBall _ _\n\n"}
{"name":"ExistsContDiffBumpBase.y_neg","module":"Mathlib.Analysis.Calculus.BumpFunction.FiniteDimension","initialProofState":"E : Type u_1\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : FiniteDimensional Real E\ninst‚úù¬π : MeasurableSpace E\ninst‚úù : BorelSpace E\nD : Real\nx : E\n‚ä¢ Eq (ExistsContDiffBumpBase.y D (Neg.neg x)) (ExistsContDiffBumpBase.y D x)","decl":"theorem y_neg (D : ‚Ñù) (x : E) : y D (-x) = y D x := by\n  apply convolution_neg_of_neg_eq\n  ¬∑ filter_upwards with x\n    simp only [w_def, Real.rpow_natCast, mul_inv_rev, smul_neg, u_neg, smul_eq_mul, forall_const]\n  ¬∑ filter_upwards with x\n    simp only [œÜ, indicator, mem_closedBall, dist_zero_right, norm_neg, forall_const]\n\n"}
{"name":"ExistsContDiffBumpBase.y_eq_one_of_mem_closedBall","module":"Mathlib.Analysis.Calculus.BumpFunction.FiniteDimension","initialProofState":"E : Type u_1\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : FiniteDimensional Real E\ninst‚úù¬π : MeasurableSpace E\ninst‚úù : BorelSpace E\nD : Real\nx : E\nDpos : LT.lt 0 D\nhx : Membership.mem (Metric.closedBall 0 (HSub.hSub 1 D)) x\n‚ä¢ Eq (ExistsContDiffBumpBase.y D x) 1","decl":"theorem y_eq_one_of_mem_closedBall {D : ‚Ñù} {x : E} (Dpos : 0 < D)\n    (hx : x ‚àà closedBall (0 : E) (1 - D)) : y D x = 1 := by\n  change (w D ‚ãÜ[lsmul ‚Ñù ‚Ñù, Œº] œÜ) x = 1\n  have B : ‚àÄ y : E, y ‚àà ball x D ‚Üí œÜ y = 1 := by\n    have C : ball x D ‚äÜ ball 0 1 := by\n      apply ball_subset_ball'\n      simp only [mem_closedBall] at hx\n      linarith only [hx]\n    intro y hy\n    simp only [œÜ, indicator, mem_closedBall, ite_eq_left_iff, not_le, zero_ne_one]\n    intro h'y\n    linarith only [mem_ball.1 (C hy), h'y]\n  have Bx : œÜ x = 1 := B _ (mem_ball_self Dpos)\n  have B' : ‚àÄ y, y ‚àà ball x D ‚Üí œÜ y = œÜ x := by rw [Bx]; exact B\n  rw [convolution_eq_right' _ (le_of_eq (w_support E Dpos)) B']\n  simp only [lsmul_apply, Algebra.id.smul_eq_mul, integral_mul_right, w_integral E Dpos, Bx,\n    one_mul]\n\n"}
{"name":"ExistsContDiffBumpBase.y_eq_zero_of_not_mem_ball","module":"Mathlib.Analysis.Calculus.BumpFunction.FiniteDimension","initialProofState":"E : Type u_1\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : FiniteDimensional Real E\ninst‚úù¬π : MeasurableSpace E\ninst‚úù : BorelSpace E\nD : Real\nx : E\nDpos : LT.lt 0 D\nhx : Not (Membership.mem (Metric.ball 0 (HAdd.hAdd 1 D)) x)\n‚ä¢ Eq (ExistsContDiffBumpBase.y D x) 0","decl":"theorem y_eq_zero_of_not_mem_ball {D : ‚Ñù} {x : E} (Dpos : 0 < D) (hx : x ‚àâ ball (0 : E) (1 + D)) :\n    y D x = 0 := by\n  change (w D ‚ãÜ[lsmul ‚Ñù ‚Ñù, Œº] œÜ) x = 0\n  have B : ‚àÄ y, y ‚àà ball x D ‚Üí œÜ y = 0 := by\n    intro y hy\n    simp only [œÜ, indicator, mem_closedBall_zero_iff, ite_eq_right_iff, one_ne_zero]\n    intro h'y\n    have C : ball y D ‚äÜ ball 0 (1 + D) := by\n      apply ball_subset_ball'\n      rw [‚Üê dist_zero_right] at h'y\n      linarith only [h'y]\n    exact hx (C (mem_ball_comm.1 hy))\n  have Bx : œÜ x = 0 := B _ (mem_ball_self Dpos)\n  have B' : ‚àÄ y, y ‚àà ball x D ‚Üí œÜ y = œÜ x := by rw [Bx]; exact B\n  rw [convolution_eq_right' _ (le_of_eq (w_support E Dpos)) B']\n  simp only [lsmul_apply, Algebra.id.smul_eq_mul, Bx, mul_zero, integral_const]\n\n"}
{"name":"ExistsContDiffBumpBase.y_nonneg","module":"Mathlib.Analysis.Calculus.BumpFunction.FiniteDimension","initialProofState":"E : Type u_1\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : FiniteDimensional Real E\ninst‚úù¬π : MeasurableSpace E\ninst‚úù : BorelSpace E\nD : Real\nx : E\n‚ä¢ LE.le 0 (ExistsContDiffBumpBase.y D x)","decl":"theorem y_nonneg (D : ‚Ñù) (x : E) : 0 ‚â§ y D x :=\n  integral_nonneg (w_mul_œÜ_nonneg D x)\n\n"}
{"name":"ExistsContDiffBumpBase.y_le_one","module":"Mathlib.Analysis.Calculus.BumpFunction.FiniteDimension","initialProofState":"E : Type u_1\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : FiniteDimensional Real E\ninst‚úù¬π : MeasurableSpace E\ninst‚úù : BorelSpace E\nD : Real\nx : E\nDpos : LT.lt 0 D\n‚ä¢ LE.le (ExistsContDiffBumpBase.y D x) 1","decl":"theorem y_le_one {D : ‚Ñù} (x : E) (Dpos : 0 < D) : y D x ‚â§ 1 := by\n  have A : (w D ‚ãÜ[lsmul ‚Ñù ‚Ñù, Œº] œÜ) x ‚â§ (w D ‚ãÜ[lsmul ‚Ñù ‚Ñù, Œº] 1) x := by\n    apply\n      convolution_mono_right_of_nonneg _ (w_nonneg D) (indicator_le_self' fun x _ => zero_le_one)\n        fun _ => zero_le_one\n    refine\n      (HasCompactSupport.convolutionExistsLeft _ (w_compact_support E Dpos) ?_\n          (locallyIntegrable_const (1 : ‚Ñù)) x).integrable\n    exact continuous_const.mul ((u_continuous E).comp (continuous_id.const_smul _))\n  have B : (w D ‚ãÜ[lsmul ‚Ñù ‚Ñù, Œº] fun _ => (1 : ‚Ñù)) x = 1 := by\n    simp only [convolution, ContinuousLinearMap.map_smul, mul_inv_rev, coe_smul', mul_one,\n      lsmul_apply, Algebra.id.smul_eq_mul, integral_mul_left, w_integral E Dpos, Pi.smul_apply]\n  exact A.trans (le_of_eq B)\n\n"}
{"name":"ExistsContDiffBumpBase.y_pos_of_mem_ball","module":"Mathlib.Analysis.Calculus.BumpFunction.FiniteDimension","initialProofState":"E : Type u_1\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : FiniteDimensional Real E\ninst‚úù¬π : MeasurableSpace E\ninst‚úù : BorelSpace E\nD : Real\nx : E\nDpos : LT.lt 0 D\nD_lt_one : LT.lt D 1\nhx : Membership.mem (Metric.ball 0 (HAdd.hAdd 1 D)) x\n‚ä¢ LT.lt 0 (ExistsContDiffBumpBase.y D x)","decl":"theorem y_pos_of_mem_ball {D : ‚Ñù} {x : E} (Dpos : 0 < D) (D_lt_one : D < 1)\n    (hx : x ‚àà ball (0 : E) (1 + D)) : 0 < y D x := by\n  simp only [mem_ball_zero_iff] at hx\n  refine (integral_pos_iff_support_of_nonneg (w_mul_œÜ_nonneg D x) ?_).2 ?_\n  ¬∑ have F_comp : HasCompactSupport (w D) := w_compact_support E Dpos\n    have B : LocallyIntegrable (œÜ : E ‚Üí ‚Ñù) Œº :=\n      (locallyIntegrable_const _).indicator measurableSet_closedBall\n    have C : Continuous (w D : E ‚Üí ‚Ñù) :=\n      continuous_const.mul ((u_continuous E).comp (continuous_id.const_smul _))\n    exact\n      (HasCompactSupport.convolutionExistsLeft (lsmul ‚Ñù ‚Ñù : ‚Ñù ‚ÜíL[‚Ñù] ‚Ñù ‚ÜíL[‚Ñù] ‚Ñù) F_comp C B\n          x).integrable\n  ¬∑ set z := (D / (1 + D)) ‚Ä¢ x with hz\n    have B : 0 < 1 + D := by linarith\n    have C : ball z (D * (1 + D - ‚Äñx‚Äñ) / (1 + D)) ‚äÜ support fun y : E => w D y * œÜ (x - y) := by\n      intro y hy\n      simp only [support_mul, w_support E Dpos]\n      simp only [œÜ, mem_inter_iff, mem_support, Ne, indicator_apply_eq_zero,\n        mem_closedBall_zero_iff, one_ne_zero, not_forall, not_false_iff, exists_prop, and_true]\n      constructor\n      ¬∑ apply ball_subset_ball' _ hy\n        simp only [hz, norm_smul, abs_of_nonneg Dpos.le, abs_of_nonneg B.le, dist_zero_right,\n          Real.norm_eq_abs, abs_div]\n        simp only [div_le_iff‚ÇÄ B, field_simps]\n        ring_nf\n        rfl\n      ¬∑ have ID : ‚ÄñD / (1 + D) - 1‚Äñ = 1 / (1 + D) := by\n          rw [Real.norm_of_nonpos]\n          ¬∑ simp only [B.ne', Ne, not_false_iff, mul_one, neg_sub, add_tsub_cancel_right,\n              field_simps]\n          ¬∑ simp only [B.ne', Ne, not_false_iff, mul_one, field_simps]\n            apply div_nonpos_of_nonpos_of_nonneg _ B.le\n            linarith only\n        rw [‚Üê mem_closedBall_iff_norm']\n        apply closedBall_subset_closedBall' _ (ball_subset_closedBall hy)\n        rw [‚Üê one_smul ‚Ñù x, dist_eq_norm, hz, ‚Üê sub_smul, one_smul, norm_smul, ID]\n        simp only [B.ne', div_le_iff‚ÇÄ B, field_simps]\n        nlinarith only [hx, D_lt_one]\n    apply lt_of_lt_of_le _ (measure_mono C)\n    apply measure_ball_pos\n    exact div_pos (mul_pos Dpos (by linarith only [hx])) B\n\n"}
{"name":"ExistsContDiffBumpBase.y_smooth","module":"Mathlib.Analysis.Calculus.BumpFunction.FiniteDimension","initialProofState":"E : Type u_1\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : FiniteDimensional Real E\ninst‚úù¬π : MeasurableSpace E\ninst‚úù : BorelSpace E\n‚ä¢ ContDiffOn Real (‚ÜëTop.top) (Function.uncurry ExistsContDiffBumpBase.y) (SProd.sprod (Set.Ioo 0 1) Set.univ)","decl":"theorem y_smooth : ContDiffOn ‚Ñù ‚àû (uncurry y) (Ioo (0 : ‚Ñù) 1 √óÀ¢ (univ : Set E)) := by\n  have hs : IsOpen (Ioo (0 : ‚Ñù) (1 : ‚Ñù)) := isOpen_Ioo\n  have hk : IsCompact (closedBall (0 : E) 1) := ProperSpace.isCompact_closedBall _ _\n  refine contDiffOn_convolution_left_with_param (lsmul ‚Ñù ‚Ñù) hs hk ?_ ?_ ?_\n  ¬∑ rintro p x hp hx\n    simp only [w, mul_inv_rev, Algebra.id.smul_eq_mul, mul_eq_zero, inv_eq_zero]\n    right\n    contrapose! hx\n    have : p‚Åª¬π ‚Ä¢ x ‚àà support u := mem_support.2 hx\n    simp only [u_support, norm_smul, mem_ball_zero_iff, Real.norm_eq_abs, abs_inv,\n      abs_of_nonneg hp.1.le, ‚Üê div_eq_inv_mul, div_lt_one hp.1] at this\n    rw [mem_closedBall_zero_iff]\n    exact this.le.trans hp.2.le\n  ¬∑ exact (locallyIntegrable_const _).indicator measurableSet_closedBall\n  ¬∑ apply ContDiffOn.mul\n    ¬∑ norm_cast\n      refine\n        (contDiffOn_const.mul ?_).inv fun x hx =>\n          ne_of_gt (mul_pos (u_int_pos E) (pow_pos (abs_pos_of_pos hx.1.1) (finrank ‚Ñù E)))\n      apply ContDiffOn.pow\n      simp_rw [‚Üê Real.norm_eq_abs]\n      apply ContDiffOn.norm ‚Ñù\n      ¬∑ exact contDiffOn_fst\n      ¬∑ intro x hx; exact ne_of_gt hx.1.1\n    ¬∑ apply (u_smooth E).comp_contDiffOn\n      exact ContDiffOn.smul (contDiffOn_fst.inv fun x hx => ne_of_gt hx.1.1) contDiffOn_snd\n\n"}
{"name":"ExistsContDiffBumpBase.y_support","module":"Mathlib.Analysis.Calculus.BumpFunction.FiniteDimension","initialProofState":"E : Type u_1\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : FiniteDimensional Real E\ninst‚úù¬π : MeasurableSpace E\ninst‚úù : BorelSpace E\nD : Real\nDpos : LT.lt 0 D\nD_lt_one : LT.lt D 1\n‚ä¢ Eq (Function.support (ExistsContDiffBumpBase.y D)) (Metric.ball 0 (HAdd.hAdd 1 D))","decl":"theorem y_support {D : ‚Ñù} (Dpos : 0 < D) (D_lt_one : D < 1) :\n    support (y D : E ‚Üí ‚Ñù) = ball (0 : E) (1 + D) :=\n  support_eq_iff.2\n    ‚ü®fun _ hx => (y_pos_of_mem_ball Dpos D_lt_one hx).ne', fun _ hx =>\n      y_eq_zero_of_not_mem_ball Dpos hx‚ü©\n\n"}
{"name":"ExistsContDiffBumpBase.instHasContDiffBumpOfFiniteDimensionalReal","module":"Mathlib.Analysis.Calculus.BumpFunction.FiniteDimension","initialProofState":"E : Type u_2\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : NormedSpace Real E\ninst‚úù : FiniteDimensional Real E\n‚ä¢ HasContDiffBump E","decl":"instance (priority := 100) {E : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E]\n    [FiniteDimensional ‚Ñù E] : HasContDiffBump E := by\n  refine ‚ü®‚ü®?_‚ü©‚ü©\n  borelize E\n  have IR : ‚àÄ R : ‚Ñù, 1 < R ‚Üí 0 < (R - 1) / (R + 1) := by intro R hR; apply div_pos <;> linarith\n  exact\n    { toFun := fun R x => if 1 < R then y ((R - 1) / (R + 1)) (((R + 1) / 2)‚Åª¬π ‚Ä¢ x) else 0\n      mem_Icc := fun R x => by\n        simp only [mem_Icc]\n        split_ifs with h\n        ¬∑ refine ‚ü®y_nonneg _ _, y_le_one _ (IR R h)‚ü©\n        ¬∑ simp only [le_refl, zero_le_one, and_self]\n      symmetric := fun R x => by\n        simp only\n        split_ifs\n        ¬∑ simp only [y_neg, smul_neg]\n        ¬∑ rfl\n      smooth := by\n        suffices\n          ContDiffOn ‚Ñù ‚àû\n            (uncurry y ‚àò fun p : ‚Ñù √ó E => ((p.1 - 1) / (p.1 + 1), ((p.1 + 1) / 2)‚Åª¬π ‚Ä¢ p.2))\n            (Ioi 1 √óÀ¢ univ) by\n          apply this.congr\n          rintro ‚ü®R, x‚ü© ‚ü®hR : 1 < R, _‚ü©\n          simp only [hR, uncurry_apply_pair, if_true, Function.comp_apply]\n        apply (y_smooth E).comp\n        ¬∑ apply ContDiffOn.prod\n          ¬∑ refine\n              (contDiffOn_fst.sub contDiffOn_const).div (contDiffOn_fst.add contDiffOn_const) ?_\n            rintro ‚ü®R, x‚ü© ‚ü®hR : 1 < R, _‚ü©\n            apply ne_of_gt\n            dsimp only\n            linarith\n          ¬∑ apply ContDiffOn.smul _ contDiffOn_snd\n            refine ((contDiffOn_fst.add contDiffOn_const).div_const _).inv ?_\n            rintro ‚ü®R, x‚ü© ‚ü®hR : 1 < R, _‚ü©\n            apply ne_of_gt\n            dsimp only\n            linarith\n        ¬∑ rintro ‚ü®R, x‚ü© ‚ü®hR : 1 < R, _‚ü©\n          have A : 0 < (R - 1) / (R + 1) := by apply div_pos <;> linarith\n          have B : (R - 1) / (R + 1) < 1 := by apply (div_lt_one _).2 <;> linarith\n          simp only [mem_preimage, prod_mk_mem_set_prod_eq, mem_Ioo, mem_univ, and_true, A, B]\n      eq_one := fun R hR x hx => by\n        have A : 0 < R + 1 := by linarith\n        simp only [hR, if_true]\n        apply y_eq_one_of_mem_closedBall (IR R hR)\n        simp only [norm_smul, inv_div, mem_closedBall_zero_iff, Real.norm_eq_abs, abs_div, abs_two,\n          abs_of_nonneg A.le]\n        calc\n          2 / (R + 1) * ‚Äñx‚Äñ ‚â§ 2 / (R + 1) := mul_le_of_le_one_right (by positivity) hx\n          _ = 1 - (R - 1) / (R + 1) := by field_simp; ring\n      support := fun R hR => by\n        have A : 0 < (R + 1) / 2 := by linarith\n        have C : (R - 1) / (R + 1) < 1 := by apply (div_lt_one _).2 <;> linarith\n        simp only [hR, if_true, support_comp_inv_smul‚ÇÄ A.ne', y_support _ (IR R hR) C,\n          _root_.smul_ball A.ne', Real.norm_of_nonneg A.le, smul_zero]\n        refine congr (congr_arg ball (Eq.refl 0)) ?_\n        field_simp; ring }\n\n"}
