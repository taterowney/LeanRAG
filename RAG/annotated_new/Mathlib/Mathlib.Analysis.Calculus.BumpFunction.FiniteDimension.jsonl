{"name":"exists_smooth_tsupport_subset","module":"Mathlib.Analysis.Calculus.BumpFunction.FiniteDimension","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : FiniteDimensional Real E\ns : Set E\nx : E\nhs : Membership.mem (nhds x) s\n⊢ Exists fun f => And (HasSubset.Subset (tsupport f) s) (And (HasCompactSupport f) (And (ContDiff Real (↑Top.top) f) (And (HasSubset.Subset (Set.range f) (Set.Icc 0 1)) (Eq (f x) 1))))","decl":"/-- If a set `s` is a neighborhood of `x`, then there exists a smooth function `f` taking\nvalues in `[0, 1]`, supported in `s` and with `f x = 1`. -/\ntheorem exists_smooth_tsupport_subset {s : Set E} {x : E} (hs : s ∈ 𝓝 x) :\n    ∃ f : E → ℝ,\n      tsupport f ⊆ s ∧ HasCompactSupport f ∧ ContDiff ℝ ∞ f ∧ range f ⊆ Icc 0 1 ∧ f x = 1 := by\n  obtain ⟨d : ℝ, d_pos : 0 < d, hd : Euclidean.closedBall x d ⊆ s⟩ :=\n    Euclidean.nhds_basis_closedBall.mem_iff.1 hs\n  let c : ContDiffBump (toEuclidean x) :=\n    { rIn := d / 2\n      rOut := d\n      rIn_pos := half_pos d_pos\n      rIn_lt_rOut := half_lt_self d_pos }\n  let f : E → ℝ := c ∘ toEuclidean\n  have f_supp : f.support ⊆ Euclidean.ball x d := by\n    intro y hy\n    have : toEuclidean y ∈ Function.support c := by\n      simpa only [Function.mem_support, Function.comp_apply, Ne] using hy\n    rwa [c.support_eq] at this\n  have f_tsupp : tsupport f ⊆ Euclidean.closedBall x d := by\n    rw [tsupport, ← Euclidean.closure_ball _ d_pos.ne']\n    exact closure_mono f_supp\n  refine ⟨f, f_tsupp.trans hd, ?_, ?_, ?_, ?_⟩\n  · refine isCompact_of_isClosed_isBounded isClosed_closure ?_\n    have : IsBounded (Euclidean.closedBall x d) := Euclidean.isCompact_closedBall.isBounded\n    refine this.subset (Euclidean.isClosed_closedBall.closure_subset_iff.2 ?_)\n    exact f_supp.trans Euclidean.ball_subset_closedBall\n  · apply c.contDiff.comp\n    exact ContinuousLinearEquiv.contDiff _\n  · rintro t ⟨y, rfl⟩\n    exact ⟨c.nonneg, c.le_one⟩\n  · apply c.one_of_mem_closedBall\n    apply mem_closedBall_self\n    exact (half_pos d_pos).le\n\n"}
{"name":"IsOpen.exists_smooth_support_eq","module":"Mathlib.Analysis.Calculus.BumpFunction.FiniteDimension","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : FiniteDimensional Real E\ns : Set E\nhs : IsOpen s\n⊢ Exists fun f => And (Eq (Function.support f) s) (And (ContDiff Real (↑Top.top) f) (HasSubset.Subset (Set.range f) (Set.Icc 0 1)))","decl":"/-- Given an open set `s` in a finite-dimensional real normed vector space, there exists a smooth\nfunction with values in `[0, 1]` whose support is exactly `s`. -/\ntheorem IsOpen.exists_smooth_support_eq {s : Set E} (hs : IsOpen s) :\n    ∃ f : E → ℝ, f.support = s ∧ ContDiff ℝ ∞ f ∧ Set.range f ⊆ Set.Icc 0 1 := by\n  /- For any given point `x` in `s`, one can construct a smooth function with support in `s` and\n    nonzero at `x`. By second-countability, it follows that we may cover `s` with the supports of\n    countably many such functions, say `g i`.\n    Then `∑ i, r i • g i` will be the desired function if `r i` is a sequence of positive numbers\n    tending quickly enough to zero. Indeed, this ensures that, for any `k ≤ i`, the `k`-th\n    derivative of `r i • g i` is bounded by a prescribed (summable) sequence `u i`. From this, the\n    summability of the series and of its successive derivatives follows. -/\n  rcases eq_empty_or_nonempty s with (rfl | h's)\n  · exact\n      ⟨fun _ => 0, Function.support_zero, contDiff_const, by\n        simp only [range_const, singleton_subset_iff, left_mem_Icc, zero_le_one]⟩\n  let ι := { f : E → ℝ // f.support ⊆ s ∧ HasCompactSupport f ∧ ContDiff ℝ ∞ f ∧ range f ⊆ Icc 0 1 }\n  obtain ⟨T, T_count, hT⟩ : ∃ T : Set ι, T.Countable ∧ ⋃ f ∈ T, support (f : E → ℝ) = s := by\n    have : ⋃ f : ι, (f : E → ℝ).support = s := by\n      refine Subset.antisymm (iUnion_subset fun f => f.2.1) ?_\n      intro x hx\n      rcases exists_smooth_tsupport_subset (hs.mem_nhds hx) with ⟨f, hf⟩\n      let g : ι := ⟨f, (subset_tsupport f).trans hf.1, hf.2.1, hf.2.2.1, hf.2.2.2.1⟩\n      have : x ∈ support (g : E → ℝ) := by\n        simp only [g, hf.2.2.2.2, Subtype.coe_mk, mem_support, Ne, one_ne_zero,\n          not_false_iff]\n      exact mem_iUnion_of_mem _ this\n    simp_rw [← this]\n    apply isOpen_iUnion_countable\n    rintro ⟨f, hf⟩\n    exact hf.2.2.1.continuous.isOpen_support\n  obtain ⟨g0, hg⟩ : ∃ g0 : ℕ → ι, T = range g0 := by\n    apply Countable.exists_eq_range T_count\n    rcases eq_empty_or_nonempty T with (rfl | hT)\n    · simp only [ι, iUnion_false, iUnion_empty] at hT\n      simp only [← hT, mem_empty_iff_false, iUnion_of_empty, iUnion_empty, Set.not_nonempty_empty]\n          at h's\n    · exact hT\n  let g : ℕ → E → ℝ := fun n => (g0 n).1\n  have g_s : ∀ n, support (g n) ⊆ s := fun n => (g0 n).2.1\n  have s_g : ∀ x ∈ s, ∃ n, x ∈ support (g n) := fun x hx ↦ by\n    rw [← hT] at hx\n    obtain ⟨i, iT, hi⟩ : ∃ i ∈ T, x ∈ support (i : E → ℝ) := by\n      simpa only [mem_iUnion, exists_prop] using hx\n    rw [hg, mem_range] at iT\n    rcases iT with ⟨n, hn⟩\n    rw [← hn] at hi\n    exact ⟨n, hi⟩\n  have g_smooth : ∀ n, ContDiff ℝ ∞ (g n) := fun n => (g0 n).2.2.2.1\n  have g_comp_supp : ∀ n, HasCompactSupport (g n) := fun n => (g0 n).2.2.1\n  have g_nonneg : ∀ n x, 0 ≤ g n x := fun n x => ((g0 n).2.2.2.2 (mem_range_self x)).1\n  obtain ⟨δ, δpos, c, δc, c_lt⟩ :\n      ∃ δ : ℕ → ℝ≥0, (∀ i : ℕ, 0 < δ i) ∧ ∃ c : NNReal, HasSum δ c ∧ c < 1 :=\n    NNReal.exists_pos_sum_of_countable one_ne_zero ℕ\n  have : ∀ n : ℕ, ∃ r : ℝ, 0 < r ∧ ∀ i ≤ n, ∀ x, ‖iteratedFDeriv ℝ i (r • g n) x‖ ≤ δ n := by\n    intro n\n    have : ∀ i, ∃ R, ∀ x, ‖iteratedFDeriv ℝ i (fun x => g n x) x‖ ≤ R := by\n      intro i\n      have : BddAbove (range fun x => ‖iteratedFDeriv ℝ i (fun x : E => g n x) x‖) := by\n        apply ((g_smooth n).continuous_iteratedFDeriv\n          (mod_cast le_top)).norm.bddAbove_range_of_hasCompactSupport\n        apply HasCompactSupport.comp_left _ norm_zero\n        apply (g_comp_supp n).iteratedFDeriv\n      rcases this with ⟨R, hR⟩\n      exact ⟨R, fun x => hR (mem_range_self _)⟩\n    choose R hR using this\n    let M := max (((Finset.range (n + 1)).image R).max' (by simp)) 1\n    have δnpos : 0 < δ n := δpos n\n    have IR : ∀ i ≤ n, R i ≤ M := by\n      intro i hi\n      refine le_trans ?_ (le_max_left _ _)\n      apply Finset.le_max'\n      apply Finset.mem_image_of_mem\n      -- Porting note: was\n      -- simp only [Finset.mem_range]\n      -- linarith\n      simpa only [Finset.mem_range, Nat.lt_add_one_iff]\n    refine ⟨M⁻¹ * δ n, by positivity, fun i hi x => ?_⟩\n    calc\n      ‖iteratedFDeriv ℝ i ((M⁻¹ * δ n) • g n) x‖ = ‖(M⁻¹ * δ n) • iteratedFDeriv ℝ i (g n) x‖ := by\n        rw [iteratedFDeriv_const_smul_apply]\n        exact (g_smooth n).contDiffAt.of_le (mod_cast le_top)\n      _ = M⁻¹ * δ n * ‖iteratedFDeriv ℝ i (g n) x‖ := by\n        rw [norm_smul _ (iteratedFDeriv ℝ i (g n) x), Real.norm_of_nonneg]; positivity\n      _ ≤ M⁻¹ * δ n * M := by gcongr; exact (hR i x).trans (IR i hi)\n      _ = δ n := by field_simp\n  choose r rpos hr using this\n  have S : ∀ x, Summable fun n => (r n • g n) x := fun x ↦ by\n    refine .of_nnnorm_bounded _ δc.summable fun n => ?_\n    rw [← NNReal.coe_le_coe, coe_nnnorm]\n    simpa only [norm_iteratedFDeriv_zero] using hr n 0 (zero_le n) x\n  refine ⟨fun x => ∑' n, (r n • g n) x, ?_, ?_, ?_⟩\n  · apply Subset.antisymm\n    · intro x hx\n      simp only [Pi.smul_apply, Algebra.id.smul_eq_mul, mem_support, Ne] at hx\n      contrapose! hx\n      have : ∀ n, g n x = 0 := by\n        intro n\n        contrapose! hx\n        exact g_s n hx\n      simp only [this, mul_zero, tsum_zero]\n    · intro x hx\n      obtain ⟨n, hn⟩ : ∃ n, x ∈ support (g n) := s_g x hx\n      have I : 0 < r n * g n x := mul_pos (rpos n) (lt_of_le_of_ne (g_nonneg n x) (Ne.symm hn))\n      exact ne_of_gt (tsum_pos (S x) (fun i => mul_nonneg (rpos i).le (g_nonneg i x)) n I)\n  · refine\n      contDiff_tsum_of_eventually (fun n => (g_smooth n).const_smul (r n))\n        (fun k _ => (NNReal.hasSum_coe.2 δc).summable) ?_\n    intro i _\n    simp only [Nat.cofinite_eq_atTop, Pi.smul_apply, Algebra.id.smul_eq_mul,\n      Filter.eventually_atTop]\n    exact ⟨i, fun n hn x => hr _ _ hn _⟩\n  · rintro - ⟨y, rfl⟩\n    refine ⟨tsum_nonneg fun n => mul_nonneg (rpos n).le (g_nonneg n y), le_trans ?_ c_lt.le⟩\n    have A : HasSum (fun n => (δ n : ℝ)) c := NNReal.hasSum_coe.2 δc\n    simp only [Pi.smul_apply, smul_eq_mul, NNReal.val_eq_coe, ← A.tsum_eq]\n    apply tsum_le_tsum _ (S y) A.summable\n    intro n\n    apply (le_abs_self _).trans\n    simpa only [norm_iteratedFDeriv_zero] using hr n 0 (zero_le n) y\n\n"}
{"name":"ExistsContDiffBumpBase.u_exists","module":"Mathlib.Analysis.Calculus.BumpFunction.FiniteDimension","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : FiniteDimensional Real E\n⊢ Exists fun u => And (ContDiff Real (↑Top.top) u) (And (∀ (x : E), Membership.mem (Set.Icc 0 1) (u x)) (And (Eq (Function.support u) (Metric.ball 0 1)) (∀ (x : E), Eq (u (Neg.neg x)) (u x))))","decl":"theorem u_exists :\n    ∃ u : E → ℝ,\n      ContDiff ℝ ∞ u ∧ (∀ x, u x ∈ Icc (0 : ℝ) 1) ∧ support u = ball 0 1 ∧ ∀ x, u (-x) = u x := by\n  have A : IsOpen (ball (0 : E) 1) := isOpen_ball\n  obtain ⟨f, f_support, f_smooth, f_range⟩ :\n      ∃ f : E → ℝ, f.support = ball (0 : E) 1 ∧ ContDiff ℝ ∞ f ∧ Set.range f ⊆ Set.Icc 0 1 :=\n    A.exists_smooth_support_eq\n  have B : ∀ x, f x ∈ Icc (0 : ℝ) 1 := fun x => f_range (mem_range_self x)\n  refine ⟨fun x => (f x + f (-x)) / 2, ?_, ?_, ?_, ?_⟩\n  · exact (f_smooth.add (f_smooth.comp contDiff_neg)).div_const _\n  · intro x\n    simp only [mem_Icc]\n    constructor\n    · linarith [(B x).1, (B (-x)).1]\n    · linarith [(B x).2, (B (-x)).2]\n  · refine support_eq_iff.2 ⟨fun x hx => ?_, fun x hx => ?_⟩\n    · apply ne_of_gt\n      have : 0 < f x := by\n        apply lt_of_le_of_ne (B x).1 (Ne.symm _)\n        rwa [← f_support] at hx\n      linarith [(B (-x)).1]\n    · have I1 : x ∉ support f := by rwa [f_support]\n      have I2 : -x ∉ support f := by\n        rw [f_support]\n        simpa using hx\n      simp only [mem_support, Classical.not_not] at I1 I2\n      simp only [I1, I2, add_zero, zero_div]\n  · intro x; simp only [add_comm, neg_neg]\n\n"}
{"name":"ExistsContDiffBumpBase.u_smooth","module":"Mathlib.Analysis.Calculus.BumpFunction.FiniteDimension","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : FiniteDimensional Real E\n⊢ ContDiff Real (↑Top.top) ExistsContDiffBumpBase.u","decl":"theorem u_smooth : ContDiff ℝ ∞ (u : E → ℝ) :=\n  (Classical.choose_spec (u_exists E)).1\n\n"}
{"name":"ExistsContDiffBumpBase.u_continuous","module":"Mathlib.Analysis.Calculus.BumpFunction.FiniteDimension","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : FiniteDimensional Real E\n⊢ Continuous ExistsContDiffBumpBase.u","decl":"theorem u_continuous : Continuous (u : E → ℝ) :=\n  (u_smooth E).continuous\n\n"}
{"name":"ExistsContDiffBumpBase.u_support","module":"Mathlib.Analysis.Calculus.BumpFunction.FiniteDimension","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : FiniteDimensional Real E\n⊢ Eq (Function.support ExistsContDiffBumpBase.u) (Metric.ball 0 1)","decl":"theorem u_support : support (u : E → ℝ) = ball 0 1 :=\n  (Classical.choose_spec (u_exists E)).2.2.1\n\n"}
{"name":"ExistsContDiffBumpBase.u_compact_support","module":"Mathlib.Analysis.Calculus.BumpFunction.FiniteDimension","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : FiniteDimensional Real E\n⊢ HasCompactSupport ExistsContDiffBumpBase.u","decl":"theorem u_compact_support : HasCompactSupport (u : E → ℝ) := by\n  rw [hasCompactSupport_def, u_support, closure_ball (0 : E) one_ne_zero]\n  exact isCompact_closedBall _ _\n\n"}
{"name":"ExistsContDiffBumpBase.u_nonneg","module":"Mathlib.Analysis.Calculus.BumpFunction.FiniteDimension","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : FiniteDimensional Real E\nx : E\n⊢ LE.le 0 (ExistsContDiffBumpBase.u x)","decl":"theorem u_nonneg (x : E) : 0 ≤ u x :=\n  ((Classical.choose_spec (u_exists E)).2.1 x).1\n\n"}
{"name":"ExistsContDiffBumpBase.u_le_one","module":"Mathlib.Analysis.Calculus.BumpFunction.FiniteDimension","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : FiniteDimensional Real E\nx : E\n⊢ LE.le (ExistsContDiffBumpBase.u x) 1","decl":"theorem u_le_one (x : E) : u x ≤ 1 :=\n  ((Classical.choose_spec (u_exists E)).2.1 x).2\n\n"}
{"name":"ExistsContDiffBumpBase.u_neg","module":"Mathlib.Analysis.Calculus.BumpFunction.FiniteDimension","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : FiniteDimensional Real E\nx : E\n⊢ Eq (ExistsContDiffBumpBase.u (Neg.neg x)) (ExistsContDiffBumpBase.u x)","decl":"theorem u_neg (x : E) : u (-x) = u x :=\n  (Classical.choose_spec (u_exists E)).2.2.2 x\n\n"}
{"name":"ExistsContDiffBumpBase.u_int_pos","module":"Mathlib.Analysis.Calculus.BumpFunction.FiniteDimension","initialProofState":"E : Type u_1\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : FiniteDimensional Real E\ninst✝¹ : MeasurableSpace E\ninst✝ : BorelSpace E\n⊢ LT.lt 0 (MeasureTheory.integral MeasureTheory.Measure.addHaar fun x => ExistsContDiffBumpBase.u x)","decl":"theorem u_int_pos : 0 < ∫ x : E, u x ∂μ := by\n  refine (integral_pos_iff_support_of_nonneg u_nonneg ?_).mpr ?_\n  · exact (u_continuous E).integrable_of_hasCompactSupport (u_compact_support E)\n  · rw [u_support]; exact measure_ball_pos _ _ zero_lt_one\n\n"}
{"name":"ExistsContDiffBumpBase.w_def","module":"Mathlib.Analysis.Calculus.BumpFunction.FiniteDimension","initialProofState":"E : Type u_1\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : FiniteDimensional Real E\ninst✝¹ : MeasurableSpace E\ninst✝ : BorelSpace E\nD : Real\n⊢ Eq (ExistsContDiffBumpBase.w D) fun x => HSMul.hSMul (Inv.inv (HMul.hMul (MeasureTheory.integral MeasureTheory.Measure.addHaar fun x => ExistsContDiffBumpBase.u x) (HPow.hPow (abs D) (Module.finrank Real E)))) (ExistsContDiffBumpBase.u (HSMul.hSMul (Inv.inv D) x))","decl":"theorem w_def (D : ℝ) :\n    (w D : E → ℝ) = fun x => ((∫ x : E, u x ∂μ) * |D| ^ finrank ℝ E)⁻¹ • u (D⁻¹ • x) := by\n  ext1 x; rfl\n\n"}
{"name":"ExistsContDiffBumpBase.w_nonneg","module":"Mathlib.Analysis.Calculus.BumpFunction.FiniteDimension","initialProofState":"E : Type u_1\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : FiniteDimensional Real E\ninst✝¹ : MeasurableSpace E\ninst✝ : BorelSpace E\nD : Real\nx : E\n⊢ LE.le 0 (ExistsContDiffBumpBase.w D x)","decl":"theorem w_nonneg (D : ℝ) (x : E) : 0 ≤ w D x := by\n  apply mul_nonneg _ (u_nonneg _)\n  apply inv_nonneg.2\n  apply mul_nonneg (u_int_pos E).le\n  norm_cast\n  apply pow_nonneg (abs_nonneg D)\n\n"}
{"name":"ExistsContDiffBumpBase.w_mul_φ_nonneg","module":"Mathlib.Analysis.Calculus.BumpFunction.FiniteDimension","initialProofState":"E : Type u_1\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : FiniteDimensional Real E\ninst✝¹ : MeasurableSpace E\ninst✝ : BorelSpace E\nD : Real\nx y : E\n⊢ LE.le 0 (HMul.hMul (ExistsContDiffBumpBase.w D y) (ExistsContDiffBumpBase.φ (HSub.hSub x y)))","decl":"theorem w_mul_φ_nonneg (D : ℝ) (x y : E) : 0 ≤ w D y * φ (x - y) :=\n  mul_nonneg (w_nonneg D y) (indicator_nonneg (by simp only [zero_le_one, imp_true_iff]) _)\n\n"}
{"name":"ExistsContDiffBumpBase.w_integral","module":"Mathlib.Analysis.Calculus.BumpFunction.FiniteDimension","initialProofState":"E : Type u_1\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : FiniteDimensional Real E\ninst✝¹ : MeasurableSpace E\ninst✝ : BorelSpace E\nD : Real\nDpos : LT.lt 0 D\n⊢ Eq (MeasureTheory.integral MeasureTheory.Measure.addHaar fun x => ExistsContDiffBumpBase.w D x) 1","decl":"theorem w_integral {D : ℝ} (Dpos : 0 < D) : ∫ x : E, w D x ∂μ = 1 := by\n  simp_rw [w, integral_smul]\n  rw [integral_comp_inv_smul_of_nonneg μ (u : E → ℝ) Dpos.le, abs_of_nonneg Dpos.le, mul_comm]\n  field_simp [(u_int_pos E).ne']\n\n"}
{"name":"ExistsContDiffBumpBase.w_support","module":"Mathlib.Analysis.Calculus.BumpFunction.FiniteDimension","initialProofState":"E : Type u_1\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : FiniteDimensional Real E\ninst✝¹ : MeasurableSpace E\ninst✝ : BorelSpace E\nD : Real\nDpos : LT.lt 0 D\n⊢ Eq (Function.support (ExistsContDiffBumpBase.w D)) (Metric.ball 0 D)","decl":"theorem w_support {D : ℝ} (Dpos : 0 < D) : support (w D : E → ℝ) = ball 0 D := by\n  have B : D • ball (0 : E) 1 = ball 0 D := by\n    rw [smul_unitBall Dpos.ne', Real.norm_of_nonneg Dpos.le]\n  have C : D ^ finrank ℝ E ≠ 0 := by\n    norm_cast\n    exact pow_ne_zero _ Dpos.ne'\n  simp only [w_def, Algebra.id.smul_eq_mul, support_mul, support_inv, univ_inter,\n    support_comp_inv_smul₀ Dpos.ne', u_support, B, support_const (u_int_pos E).ne', support_const C,\n    abs_of_nonneg Dpos.le]\n\n"}
{"name":"ExistsContDiffBumpBase.w_compact_support","module":"Mathlib.Analysis.Calculus.BumpFunction.FiniteDimension","initialProofState":"E : Type u_1\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : FiniteDimensional Real E\ninst✝¹ : MeasurableSpace E\ninst✝ : BorelSpace E\nD : Real\nDpos : LT.lt 0 D\n⊢ HasCompactSupport (ExistsContDiffBumpBase.w D)","decl":"theorem w_compact_support {D : ℝ} (Dpos : 0 < D) : HasCompactSupport (w D : E → ℝ) := by\n  rw [hasCompactSupport_def, w_support E Dpos, closure_ball (0 : E) Dpos.ne']\n  exact isCompact_closedBall _ _\n\n"}
{"name":"ExistsContDiffBumpBase.y_neg","module":"Mathlib.Analysis.Calculus.BumpFunction.FiniteDimension","initialProofState":"E : Type u_1\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : FiniteDimensional Real E\ninst✝¹ : MeasurableSpace E\ninst✝ : BorelSpace E\nD : Real\nx : E\n⊢ Eq (ExistsContDiffBumpBase.y D (Neg.neg x)) (ExistsContDiffBumpBase.y D x)","decl":"theorem y_neg (D : ℝ) (x : E) : y D (-x) = y D x := by\n  apply convolution_neg_of_neg_eq\n  · filter_upwards with x\n    simp only [w_def, Real.rpow_natCast, mul_inv_rev, smul_neg, u_neg, smul_eq_mul, forall_const]\n  · filter_upwards with x\n    simp only [φ, indicator, mem_closedBall, dist_zero_right, norm_neg, forall_const]\n\n"}
{"name":"ExistsContDiffBumpBase.y_eq_one_of_mem_closedBall","module":"Mathlib.Analysis.Calculus.BumpFunction.FiniteDimension","initialProofState":"E : Type u_1\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : FiniteDimensional Real E\ninst✝¹ : MeasurableSpace E\ninst✝ : BorelSpace E\nD : Real\nx : E\nDpos : LT.lt 0 D\nhx : Membership.mem (Metric.closedBall 0 (HSub.hSub 1 D)) x\n⊢ Eq (ExistsContDiffBumpBase.y D x) 1","decl":"theorem y_eq_one_of_mem_closedBall {D : ℝ} {x : E} (Dpos : 0 < D)\n    (hx : x ∈ closedBall (0 : E) (1 - D)) : y D x = 1 := by\n  change (w D ⋆[lsmul ℝ ℝ, μ] φ) x = 1\n  have B : ∀ y : E, y ∈ ball x D → φ y = 1 := by\n    have C : ball x D ⊆ ball 0 1 := by\n      apply ball_subset_ball'\n      simp only [mem_closedBall] at hx\n      linarith only [hx]\n    intro y hy\n    simp only [φ, indicator, mem_closedBall, ite_eq_left_iff, not_le, zero_ne_one]\n    intro h'y\n    linarith only [mem_ball.1 (C hy), h'y]\n  have Bx : φ x = 1 := B _ (mem_ball_self Dpos)\n  have B' : ∀ y, y ∈ ball x D → φ y = φ x := by rw [Bx]; exact B\n  rw [convolution_eq_right' _ (le_of_eq (w_support E Dpos)) B']\n  simp only [lsmul_apply, Algebra.id.smul_eq_mul, integral_mul_right, w_integral E Dpos, Bx,\n    one_mul]\n\n"}
{"name":"ExistsContDiffBumpBase.y_eq_zero_of_not_mem_ball","module":"Mathlib.Analysis.Calculus.BumpFunction.FiniteDimension","initialProofState":"E : Type u_1\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : FiniteDimensional Real E\ninst✝¹ : MeasurableSpace E\ninst✝ : BorelSpace E\nD : Real\nx : E\nDpos : LT.lt 0 D\nhx : Not (Membership.mem (Metric.ball 0 (HAdd.hAdd 1 D)) x)\n⊢ Eq (ExistsContDiffBumpBase.y D x) 0","decl":"theorem y_eq_zero_of_not_mem_ball {D : ℝ} {x : E} (Dpos : 0 < D) (hx : x ∉ ball (0 : E) (1 + D)) :\n    y D x = 0 := by\n  change (w D ⋆[lsmul ℝ ℝ, μ] φ) x = 0\n  have B : ∀ y, y ∈ ball x D → φ y = 0 := by\n    intro y hy\n    simp only [φ, indicator, mem_closedBall_zero_iff, ite_eq_right_iff, one_ne_zero]\n    intro h'y\n    have C : ball y D ⊆ ball 0 (1 + D) := by\n      apply ball_subset_ball'\n      rw [← dist_zero_right] at h'y\n      linarith only [h'y]\n    exact hx (C (mem_ball_comm.1 hy))\n  have Bx : φ x = 0 := B _ (mem_ball_self Dpos)\n  have B' : ∀ y, y ∈ ball x D → φ y = φ x := by rw [Bx]; exact B\n  rw [convolution_eq_right' _ (le_of_eq (w_support E Dpos)) B']\n  simp only [lsmul_apply, Algebra.id.smul_eq_mul, Bx, mul_zero, integral_const]\n\n"}
{"name":"ExistsContDiffBumpBase.y_nonneg","module":"Mathlib.Analysis.Calculus.BumpFunction.FiniteDimension","initialProofState":"E : Type u_1\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : FiniteDimensional Real E\ninst✝¹ : MeasurableSpace E\ninst✝ : BorelSpace E\nD : Real\nx : E\n⊢ LE.le 0 (ExistsContDiffBumpBase.y D x)","decl":"theorem y_nonneg (D : ℝ) (x : E) : 0 ≤ y D x :=\n  integral_nonneg (w_mul_φ_nonneg D x)\n\n"}
{"name":"ExistsContDiffBumpBase.y_le_one","module":"Mathlib.Analysis.Calculus.BumpFunction.FiniteDimension","initialProofState":"E : Type u_1\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : FiniteDimensional Real E\ninst✝¹ : MeasurableSpace E\ninst✝ : BorelSpace E\nD : Real\nx : E\nDpos : LT.lt 0 D\n⊢ LE.le (ExistsContDiffBumpBase.y D x) 1","decl":"theorem y_le_one {D : ℝ} (x : E) (Dpos : 0 < D) : y D x ≤ 1 := by\n  have A : (w D ⋆[lsmul ℝ ℝ, μ] φ) x ≤ (w D ⋆[lsmul ℝ ℝ, μ] 1) x := by\n    apply\n      convolution_mono_right_of_nonneg _ (w_nonneg D) (indicator_le_self' fun x _ => zero_le_one)\n        fun _ => zero_le_one\n    refine\n      (HasCompactSupport.convolutionExistsLeft _ (w_compact_support E Dpos) ?_\n          (locallyIntegrable_const (1 : ℝ)) x).integrable\n    exact continuous_const.mul ((u_continuous E).comp (continuous_id.const_smul _))\n  have B : (w D ⋆[lsmul ℝ ℝ, μ] fun _ => (1 : ℝ)) x = 1 := by\n    simp only [convolution, ContinuousLinearMap.map_smul, mul_inv_rev, coe_smul', mul_one,\n      lsmul_apply, Algebra.id.smul_eq_mul, integral_mul_left, w_integral E Dpos, Pi.smul_apply]\n  exact A.trans (le_of_eq B)\n\n"}
{"name":"ExistsContDiffBumpBase.y_pos_of_mem_ball","module":"Mathlib.Analysis.Calculus.BumpFunction.FiniteDimension","initialProofState":"E : Type u_1\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : FiniteDimensional Real E\ninst✝¹ : MeasurableSpace E\ninst✝ : BorelSpace E\nD : Real\nx : E\nDpos : LT.lt 0 D\nD_lt_one : LT.lt D 1\nhx : Membership.mem (Metric.ball 0 (HAdd.hAdd 1 D)) x\n⊢ LT.lt 0 (ExistsContDiffBumpBase.y D x)","decl":"theorem y_pos_of_mem_ball {D : ℝ} {x : E} (Dpos : 0 < D) (D_lt_one : D < 1)\n    (hx : x ∈ ball (0 : E) (1 + D)) : 0 < y D x := by\n  simp only [mem_ball_zero_iff] at hx\n  refine (integral_pos_iff_support_of_nonneg (w_mul_φ_nonneg D x) ?_).2 ?_\n  · have F_comp : HasCompactSupport (w D) := w_compact_support E Dpos\n    have B : LocallyIntegrable (φ : E → ℝ) μ :=\n      (locallyIntegrable_const _).indicator measurableSet_closedBall\n    have C : Continuous (w D : E → ℝ) :=\n      continuous_const.mul ((u_continuous E).comp (continuous_id.const_smul _))\n    exact\n      (HasCompactSupport.convolutionExistsLeft (lsmul ℝ ℝ : ℝ →L[ℝ] ℝ →L[ℝ] ℝ) F_comp C B\n          x).integrable\n  · set z := (D / (1 + D)) • x with hz\n    have B : 0 < 1 + D := by linarith\n    have C : ball z (D * (1 + D - ‖x‖) / (1 + D)) ⊆ support fun y : E => w D y * φ (x - y) := by\n      intro y hy\n      simp only [support_mul, w_support E Dpos]\n      simp only [φ, mem_inter_iff, mem_support, Ne, indicator_apply_eq_zero,\n        mem_closedBall_zero_iff, one_ne_zero, not_forall, not_false_iff, exists_prop, and_true]\n      constructor\n      · apply ball_subset_ball' _ hy\n        simp only [hz, norm_smul, abs_of_nonneg Dpos.le, abs_of_nonneg B.le, dist_zero_right,\n          Real.norm_eq_abs, abs_div]\n        simp only [div_le_iff₀ B, field_simps]\n        ring_nf\n        rfl\n      · have ID : ‖D / (1 + D) - 1‖ = 1 / (1 + D) := by\n          rw [Real.norm_of_nonpos]\n          · simp only [B.ne', Ne, not_false_iff, mul_one, neg_sub, add_tsub_cancel_right,\n              field_simps]\n          · simp only [B.ne', Ne, not_false_iff, mul_one, field_simps]\n            apply div_nonpos_of_nonpos_of_nonneg _ B.le\n            linarith only\n        rw [← mem_closedBall_iff_norm']\n        apply closedBall_subset_closedBall' _ (ball_subset_closedBall hy)\n        rw [← one_smul ℝ x, dist_eq_norm, hz, ← sub_smul, one_smul, norm_smul, ID]\n        simp only [B.ne', div_le_iff₀ B, field_simps]\n        nlinarith only [hx, D_lt_one]\n    apply lt_of_lt_of_le _ (measure_mono C)\n    apply measure_ball_pos\n    exact div_pos (mul_pos Dpos (by linarith only [hx])) B\n\n"}
{"name":"ExistsContDiffBumpBase.y_smooth","module":"Mathlib.Analysis.Calculus.BumpFunction.FiniteDimension","initialProofState":"E : Type u_1\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : FiniteDimensional Real E\ninst✝¹ : MeasurableSpace E\ninst✝ : BorelSpace E\n⊢ ContDiffOn Real (↑Top.top) (Function.uncurry ExistsContDiffBumpBase.y) (SProd.sprod (Set.Ioo 0 1) Set.univ)","decl":"theorem y_smooth : ContDiffOn ℝ ∞ (uncurry y) (Ioo (0 : ℝ) 1 ×ˢ (univ : Set E)) := by\n  have hs : IsOpen (Ioo (0 : ℝ) (1 : ℝ)) := isOpen_Ioo\n  have hk : IsCompact (closedBall (0 : E) 1) := ProperSpace.isCompact_closedBall _ _\n  refine contDiffOn_convolution_left_with_param (lsmul ℝ ℝ) hs hk ?_ ?_ ?_\n  · rintro p x hp hx\n    simp only [w, mul_inv_rev, Algebra.id.smul_eq_mul, mul_eq_zero, inv_eq_zero]\n    right\n    contrapose! hx\n    have : p⁻¹ • x ∈ support u := mem_support.2 hx\n    simp only [u_support, norm_smul, mem_ball_zero_iff, Real.norm_eq_abs, abs_inv,\n      abs_of_nonneg hp.1.le, ← div_eq_inv_mul, div_lt_one hp.1] at this\n    rw [mem_closedBall_zero_iff]\n    exact this.le.trans hp.2.le\n  · exact (locallyIntegrable_const _).indicator measurableSet_closedBall\n  · apply ContDiffOn.mul\n    · norm_cast\n      refine\n        (contDiffOn_const.mul ?_).inv fun x hx =>\n          ne_of_gt (mul_pos (u_int_pos E) (pow_pos (abs_pos_of_pos hx.1.1) (finrank ℝ E)))\n      apply ContDiffOn.pow\n      simp_rw [← Real.norm_eq_abs]\n      apply ContDiffOn.norm ℝ\n      · exact contDiffOn_fst\n      · intro x hx; exact ne_of_gt hx.1.1\n    · apply (u_smooth E).comp_contDiffOn\n      exact ContDiffOn.smul (contDiffOn_fst.inv fun x hx => ne_of_gt hx.1.1) contDiffOn_snd\n\n"}
{"name":"ExistsContDiffBumpBase.y_support","module":"Mathlib.Analysis.Calculus.BumpFunction.FiniteDimension","initialProofState":"E : Type u_1\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : FiniteDimensional Real E\ninst✝¹ : MeasurableSpace E\ninst✝ : BorelSpace E\nD : Real\nDpos : LT.lt 0 D\nD_lt_one : LT.lt D 1\n⊢ Eq (Function.support (ExistsContDiffBumpBase.y D)) (Metric.ball 0 (HAdd.hAdd 1 D))","decl":"theorem y_support {D : ℝ} (Dpos : 0 < D) (D_lt_one : D < 1) :\n    support (y D : E → ℝ) = ball (0 : E) (1 + D) :=\n  support_eq_iff.2\n    ⟨fun _ hx => (y_pos_of_mem_ball Dpos D_lt_one hx).ne', fun _ hx =>\n      y_eq_zero_of_not_mem_ball Dpos hx⟩\n\n"}
{"name":"ExistsContDiffBumpBase.instHasContDiffBumpOfFiniteDimensionalReal","module":"Mathlib.Analysis.Calculus.BumpFunction.FiniteDimension","initialProofState":"E : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : FiniteDimensional Real E\n⊢ HasContDiffBump E","decl":"instance (priority := 100) {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E]\n    [FiniteDimensional ℝ E] : HasContDiffBump E := by\n  refine ⟨⟨?_⟩⟩\n  borelize E\n  have IR : ∀ R : ℝ, 1 < R → 0 < (R - 1) / (R + 1) := by intro R hR; apply div_pos <;> linarith\n  exact\n    { toFun := fun R x => if 1 < R then y ((R - 1) / (R + 1)) (((R + 1) / 2)⁻¹ • x) else 0\n      mem_Icc := fun R x => by\n        simp only [mem_Icc]\n        split_ifs with h\n        · refine ⟨y_nonneg _ _, y_le_one _ (IR R h)⟩\n        · simp only [le_refl, zero_le_one, and_self]\n      symmetric := fun R x => by\n        simp only\n        split_ifs\n        · simp only [y_neg, smul_neg]\n        · rfl\n      smooth := by\n        suffices\n          ContDiffOn ℝ ∞\n            (uncurry y ∘ fun p : ℝ × E => ((p.1 - 1) / (p.1 + 1), ((p.1 + 1) / 2)⁻¹ • p.2))\n            (Ioi 1 ×ˢ univ) by\n          apply this.congr\n          rintro ⟨R, x⟩ ⟨hR : 1 < R, _⟩\n          simp only [hR, uncurry_apply_pair, if_true, Function.comp_apply]\n        apply (y_smooth E).comp\n        · apply ContDiffOn.prod\n          · refine\n              (contDiffOn_fst.sub contDiffOn_const).div (contDiffOn_fst.add contDiffOn_const) ?_\n            rintro ⟨R, x⟩ ⟨hR : 1 < R, _⟩\n            apply ne_of_gt\n            dsimp only\n            linarith\n          · apply ContDiffOn.smul _ contDiffOn_snd\n            refine ((contDiffOn_fst.add contDiffOn_const).div_const _).inv ?_\n            rintro ⟨R, x⟩ ⟨hR : 1 < R, _⟩\n            apply ne_of_gt\n            dsimp only\n            linarith\n        · rintro ⟨R, x⟩ ⟨hR : 1 < R, _⟩\n          have A : 0 < (R - 1) / (R + 1) := by apply div_pos <;> linarith\n          have B : (R - 1) / (R + 1) < 1 := by apply (div_lt_one _).2 <;> linarith\n          simp only [mem_preimage, prod_mk_mem_set_prod_eq, mem_Ioo, mem_univ, and_true, A, B]\n      eq_one := fun R hR x hx => by\n        have A : 0 < R + 1 := by linarith\n        simp only [hR, if_true]\n        apply y_eq_one_of_mem_closedBall (IR R hR)\n        simp only [norm_smul, inv_div, mem_closedBall_zero_iff, Real.norm_eq_abs, abs_div, abs_two,\n          abs_of_nonneg A.le]\n        calc\n          2 / (R + 1) * ‖x‖ ≤ 2 / (R + 1) := mul_le_of_le_one_right (by positivity) hx\n          _ = 1 - (R - 1) / (R + 1) := by field_simp; ring\n      support := fun R hR => by\n        have A : 0 < (R + 1) / 2 := by linarith\n        have C : (R - 1) / (R + 1) < 1 := by apply (div_lt_one _).2 <;> linarith\n        simp only [hR, if_true, support_comp_inv_smul₀ A.ne', y_support _ (IR R hR) C,\n          _root_.smul_ball A.ne', Real.norm_of_nonneg A.le, smul_zero]\n        refine congr (congr_arg ball (Eq.refl 0)) ?_\n        field_simp; ring }\n\n"}
