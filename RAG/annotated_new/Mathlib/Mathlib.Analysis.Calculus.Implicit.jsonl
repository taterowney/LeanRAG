{"name":"ImplicitFunctionData.left_range","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"ğ•œ : Type u_1\ninstâœâ¹ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace ğ•œ E\ninstâœâ¶ : CompleteSpace E\nF : Type u_3\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\ninstâœÂ³ : CompleteSpace F\nG : Type u_4\ninstâœÂ² : NormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : CompleteSpace G\nself : ImplicitFunctionData ğ•œ E F G\nâŠ¢ Eq (LinearMap.range self.leftDeriv) Top.top","decl":"/-- Data for the general version of the implicit function theorem. It holds two functions\n`f : E â†’ F` and `g : E â†’ G` (named `leftFun` and `rightFun`) and a point `a` (named `pt`) such that\n\n* both functions are strictly differentiable at `a`;\n* the derivatives are surjective;\n* the kernels of the derivatives are complementary subspaces of `E`. -/\nstructure ImplicitFunctionData (ğ•œ : Type*) [NontriviallyNormedField ğ•œ] (E : Type*)\n    [NormedAddCommGroup E] [NormedSpace ğ•œ E] [CompleteSpace E] (F : Type*) [NormedAddCommGroup F]\n    [NormedSpace ğ•œ F] [CompleteSpace F] (G : Type*) [NormedAddCommGroup G] [NormedSpace ğ•œ G]\n    [CompleteSpace G] where\n  leftFun : E â†’ F\n  leftDeriv : E â†’L[ğ•œ] F\n  rightFun : E â†’ G\n  rightDeriv : E â†’L[ğ•œ] G\n  pt : E\n  left_has_deriv : HasStrictFDerivAt leftFun leftDeriv pt\n  right_has_deriv : HasStrictFDerivAt rightFun rightDeriv pt\n  left_range : range leftDeriv = âŠ¤\n  right_range : range rightDeriv = âŠ¤\n  isCompl_ker : IsCompl (ker leftDeriv) (ker rightDeriv)\n\n"}
{"name":"ImplicitFunctionData.left_has_deriv","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"ğ•œ : Type u_1\ninstâœâ¹ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace ğ•œ E\ninstâœâ¶ : CompleteSpace E\nF : Type u_3\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\ninstâœÂ³ : CompleteSpace F\nG : Type u_4\ninstâœÂ² : NormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : CompleteSpace G\nself : ImplicitFunctionData ğ•œ E F G\nâŠ¢ HasStrictFDerivAt self.leftFun self.leftDeriv self.pt","decl":"/-- Data for the general version of the implicit function theorem. It holds two functions\n`f : E â†’ F` and `g : E â†’ G` (named `leftFun` and `rightFun`) and a point `a` (named `pt`) such that\n\n* both functions are strictly differentiable at `a`;\n* the derivatives are surjective;\n* the kernels of the derivatives are complementary subspaces of `E`. -/\nstructure ImplicitFunctionData (ğ•œ : Type*) [NontriviallyNormedField ğ•œ] (E : Type*)\n    [NormedAddCommGroup E] [NormedSpace ğ•œ E] [CompleteSpace E] (F : Type*) [NormedAddCommGroup F]\n    [NormedSpace ğ•œ F] [CompleteSpace F] (G : Type*) [NormedAddCommGroup G] [NormedSpace ğ•œ G]\n    [CompleteSpace G] where\n  leftFun : E â†’ F\n  leftDeriv : E â†’L[ğ•œ] F\n  rightFun : E â†’ G\n  rightDeriv : E â†’L[ğ•œ] G\n  pt : E\n  left_has_deriv : HasStrictFDerivAt leftFun leftDeriv pt\n  right_has_deriv : HasStrictFDerivAt rightFun rightDeriv pt\n  left_range : range leftDeriv = âŠ¤\n  right_range : range rightDeriv = âŠ¤\n  isCompl_ker : IsCompl (ker leftDeriv) (ker rightDeriv)\n\n"}
{"name":"ImplicitFunctionData.right_has_deriv","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"ğ•œ : Type u_1\ninstâœâ¹ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace ğ•œ E\ninstâœâ¶ : CompleteSpace E\nF : Type u_3\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\ninstâœÂ³ : CompleteSpace F\nG : Type u_4\ninstâœÂ² : NormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : CompleteSpace G\nself : ImplicitFunctionData ğ•œ E F G\nâŠ¢ HasStrictFDerivAt self.rightFun self.rightDeriv self.pt","decl":"/-- Data for the general version of the implicit function theorem. It holds two functions\n`f : E â†’ F` and `g : E â†’ G` (named `leftFun` and `rightFun`) and a point `a` (named `pt`) such that\n\n* both functions are strictly differentiable at `a`;\n* the derivatives are surjective;\n* the kernels of the derivatives are complementary subspaces of `E`. -/\nstructure ImplicitFunctionData (ğ•œ : Type*) [NontriviallyNormedField ğ•œ] (E : Type*)\n    [NormedAddCommGroup E] [NormedSpace ğ•œ E] [CompleteSpace E] (F : Type*) [NormedAddCommGroup F]\n    [NormedSpace ğ•œ F] [CompleteSpace F] (G : Type*) [NormedAddCommGroup G] [NormedSpace ğ•œ G]\n    [CompleteSpace G] where\n  leftFun : E â†’ F\n  leftDeriv : E â†’L[ğ•œ] F\n  rightFun : E â†’ G\n  rightDeriv : E â†’L[ğ•œ] G\n  pt : E\n  left_has_deriv : HasStrictFDerivAt leftFun leftDeriv pt\n  right_has_deriv : HasStrictFDerivAt rightFun rightDeriv pt\n  left_range : range leftDeriv = âŠ¤\n  right_range : range rightDeriv = âŠ¤\n  isCompl_ker : IsCompl (ker leftDeriv) (ker rightDeriv)\n\n"}
{"name":"ImplicitFunctionData.isCompl_ker","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"ğ•œ : Type u_1\ninstâœâ¹ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace ğ•œ E\ninstâœâ¶ : CompleteSpace E\nF : Type u_3\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\ninstâœÂ³ : CompleteSpace F\nG : Type u_4\ninstâœÂ² : NormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : CompleteSpace G\nself : ImplicitFunctionData ğ•œ E F G\nâŠ¢ IsCompl (LinearMap.ker self.leftDeriv) (LinearMap.ker self.rightDeriv)","decl":"/-- Data for the general version of the implicit function theorem. It holds two functions\n`f : E â†’ F` and `g : E â†’ G` (named `leftFun` and `rightFun`) and a point `a` (named `pt`) such that\n\n* both functions are strictly differentiable at `a`;\n* the derivatives are surjective;\n* the kernels of the derivatives are complementary subspaces of `E`. -/\nstructure ImplicitFunctionData (ğ•œ : Type*) [NontriviallyNormedField ğ•œ] (E : Type*)\n    [NormedAddCommGroup E] [NormedSpace ğ•œ E] [CompleteSpace E] (F : Type*) [NormedAddCommGroup F]\n    [NormedSpace ğ•œ F] [CompleteSpace F] (G : Type*) [NormedAddCommGroup G] [NormedSpace ğ•œ G]\n    [CompleteSpace G] where\n  leftFun : E â†’ F\n  leftDeriv : E â†’L[ğ•œ] F\n  rightFun : E â†’ G\n  rightDeriv : E â†’L[ğ•œ] G\n  pt : E\n  left_has_deriv : HasStrictFDerivAt leftFun leftDeriv pt\n  right_has_deriv : HasStrictFDerivAt rightFun rightDeriv pt\n  left_range : range leftDeriv = âŠ¤\n  right_range : range rightDeriv = âŠ¤\n  isCompl_ker : IsCompl (ker leftDeriv) (ker rightDeriv)\n\n"}
{"name":"ImplicitFunctionData.mk.sizeOf_spec","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹Â³ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹Â² : NormedAddCommGroup E\ninstâœÂ¹Â¹ : NormedSpace ğ•œ E\ninstâœÂ¹â° : CompleteSpace E\nF : Type u_3\ninstâœâ¹ : NormedAddCommGroup F\ninstâœâ¸ : NormedSpace ğ•œ F\ninstâœâ· : CompleteSpace F\nG : Type u_4\ninstâœâ¶ : NormedAddCommGroup G\ninstâœâµ : NormedSpace ğ•œ G\ninstâœâ´ : CompleteSpace G\ninstâœÂ³ : SizeOf ğ•œ\ninstâœÂ² : SizeOf E\ninstâœÂ¹ : SizeOf F\ninstâœ : SizeOf G\nleftFun : E â†’ F\nleftDeriv : ContinuousLinearMap (RingHom.id ğ•œ) E F\nrightFun : E â†’ G\nrightDeriv : ContinuousLinearMap (RingHom.id ğ•œ) E G\npt : E\nleft_has_deriv : HasStrictFDerivAt leftFun leftDeriv pt\nright_has_deriv : HasStrictFDerivAt rightFun rightDeriv pt\nleft_range : Eq (LinearMap.range leftDeriv) Top.top\nright_range : Eq (LinearMap.range rightDeriv) Top.top\nisCompl_ker : IsCompl (LinearMap.ker leftDeriv) (LinearMap.ker rightDeriv)\nâŠ¢ Eq (SizeOf.sizeOf { leftFun := leftFun, leftDeriv := leftDeriv, rightFun := rightFun, rightDeriv := rightDeriv, pt := pt, left_has_deriv := left_has_deriv, right_has_deriv := right_has_deriv, left_range := left_range, right_range := right_range, isCompl_ker := isCompl_ker }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf leftDeriv)) (SizeOf.sizeOf rightDeriv)) (SizeOf.sizeOf pt)) (SizeOf.sizeOf left_has_deriv)) (SizeOf.sizeOf right_has_deriv)) (SizeOf.sizeOf left_range)) (SizeOf.sizeOf right_range)) (SizeOf.sizeOf isCompl_ker))","decl":"/-- Data for the general version of the implicit function theorem. It holds two functions\n`f : E â†’ F` and `g : E â†’ G` (named `leftFun` and `rightFun`) and a point `a` (named `pt`) such that\n\n* both functions are strictly differentiable at `a`;\n* the derivatives are surjective;\n* the kernels of the derivatives are complementary subspaces of `E`. -/\nstructure ImplicitFunctionData (ğ•œ : Type*) [NontriviallyNormedField ğ•œ] (E : Type*)\n    [NormedAddCommGroup E] [NormedSpace ğ•œ E] [CompleteSpace E] (F : Type*) [NormedAddCommGroup F]\n    [NormedSpace ğ•œ F] [CompleteSpace F] (G : Type*) [NormedAddCommGroup G] [NormedSpace ğ•œ G]\n    [CompleteSpace G] where\n  leftFun : E â†’ F\n  leftDeriv : E â†’L[ğ•œ] F\n  rightFun : E â†’ G\n  rightDeriv : E â†’L[ğ•œ] G\n  pt : E\n  left_has_deriv : HasStrictFDerivAt leftFun leftDeriv pt\n  right_has_deriv : HasStrictFDerivAt rightFun rightDeriv pt\n  left_range : range leftDeriv = âŠ¤\n  right_range : range rightDeriv = âŠ¤\n  isCompl_ker : IsCompl (ker leftDeriv) (ker rightDeriv)\n\n"}
{"name":"ImplicitFunctionData.mk.injEq","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"ğ•œ : Type u_1\ninstâœâ¹ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace ğ•œ E\ninstâœâ¶ : CompleteSpace E\nF : Type u_3\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\ninstâœÂ³ : CompleteSpace F\nG : Type u_4\ninstâœÂ² : NormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : CompleteSpace G\nleftFunâœ : E â†’ F\nleftDerivâœ : ContinuousLinearMap (RingHom.id ğ•œ) E F\nrightFunâœ : E â†’ G\nrightDerivâœ : ContinuousLinearMap (RingHom.id ğ•œ) E G\nptâœ : E\nleft_has_derivâœ : HasStrictFDerivAt leftFunâœ leftDerivâœ ptâœ\nright_has_derivâœ : HasStrictFDerivAt rightFunâœ rightDerivâœ ptâœ\nleft_rangeâœ : Eq (LinearMap.range leftDerivâœ) Top.top\nright_rangeâœ : Eq (LinearMap.range rightDerivâœ) Top.top\nisCompl_kerâœ : IsCompl (LinearMap.ker leftDerivâœ) (LinearMap.ker rightDerivâœ)\nleftFun : E â†’ F\nleftDeriv : ContinuousLinearMap (RingHom.id ğ•œ) E F\nrightFun : E â†’ G\nrightDeriv : ContinuousLinearMap (RingHom.id ğ•œ) E G\npt : E\nleft_has_deriv : HasStrictFDerivAt leftFun leftDeriv pt\nright_has_deriv : HasStrictFDerivAt rightFun rightDeriv pt\nleft_range : Eq (LinearMap.range leftDeriv) Top.top\nright_range : Eq (LinearMap.range rightDeriv) Top.top\nisCompl_ker : IsCompl (LinearMap.ker leftDeriv) (LinearMap.ker rightDeriv)\nâŠ¢ Eq (Eq { leftFun := leftFunâœ, leftDeriv := leftDerivâœ, rightFun := rightFunâœ, rightDeriv := rightDerivâœ, pt := ptâœ, left_has_deriv := left_has_derivâœ, right_has_deriv := right_has_derivâœ, left_range := left_rangeâœ, right_range := right_rangeâœ, isCompl_ker := isCompl_kerâœ } { leftFun := leftFun, leftDeriv := leftDeriv, rightFun := rightFun, rightDeriv := rightDeriv, pt := pt, left_has_deriv := left_has_deriv, right_has_deriv := right_has_deriv, left_range := left_range, right_range := right_range, isCompl_ker := isCompl_ker }) (And (Eq leftFunâœ leftFun) (And (Eq leftDerivâœ leftDeriv) (And (Eq rightFunâœ rightFun) (And (Eq rightDerivâœ rightDeriv) (Eq ptâœ pt)))))","decl":"/-- Data for the general version of the implicit function theorem. It holds two functions\n`f : E â†’ F` and `g : E â†’ G` (named `leftFun` and `rightFun`) and a point `a` (named `pt`) such that\n\n* both functions are strictly differentiable at `a`;\n* the derivatives are surjective;\n* the kernels of the derivatives are complementary subspaces of `E`. -/\nstructure ImplicitFunctionData (ğ•œ : Type*) [NontriviallyNormedField ğ•œ] (E : Type*)\n    [NormedAddCommGroup E] [NormedSpace ğ•œ E] [CompleteSpace E] (F : Type*) [NormedAddCommGroup F]\n    [NormedSpace ğ•œ F] [CompleteSpace F] (G : Type*) [NormedAddCommGroup G] [NormedSpace ğ•œ G]\n    [CompleteSpace G] where\n  leftFun : E â†’ F\n  leftDeriv : E â†’L[ğ•œ] F\n  rightFun : E â†’ G\n  rightDeriv : E â†’L[ğ•œ] G\n  pt : E\n  left_has_deriv : HasStrictFDerivAt leftFun leftDeriv pt\n  right_has_deriv : HasStrictFDerivAt rightFun rightDeriv pt\n  left_range : range leftDeriv = âŠ¤\n  right_range : range rightDeriv = âŠ¤\n  isCompl_ker : IsCompl (ker leftDeriv) (ker rightDeriv)\n\n"}
{"name":"ImplicitFunctionData.right_range","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"ğ•œ : Type u_1\ninstâœâ¹ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace ğ•œ E\ninstâœâ¶ : CompleteSpace E\nF : Type u_3\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\ninstâœÂ³ : CompleteSpace F\nG : Type u_4\ninstâœÂ² : NormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : CompleteSpace G\nself : ImplicitFunctionData ğ•œ E F G\nâŠ¢ Eq (LinearMap.range self.rightDeriv) Top.top","decl":"/-- Data for the general version of the implicit function theorem. It holds two functions\n`f : E â†’ F` and `g : E â†’ G` (named `leftFun` and `rightFun`) and a point `a` (named `pt`) such that\n\n* both functions are strictly differentiable at `a`;\n* the derivatives are surjective;\n* the kernels of the derivatives are complementary subspaces of `E`. -/\nstructure ImplicitFunctionData (ğ•œ : Type*) [NontriviallyNormedField ğ•œ] (E : Type*)\n    [NormedAddCommGroup E] [NormedSpace ğ•œ E] [CompleteSpace E] (F : Type*) [NormedAddCommGroup F]\n    [NormedSpace ğ•œ F] [CompleteSpace F] (G : Type*) [NormedAddCommGroup G] [NormedSpace ğ•œ G]\n    [CompleteSpace G] where\n  leftFun : E â†’ F\n  leftDeriv : E â†’L[ğ•œ] F\n  rightFun : E â†’ G\n  rightDeriv : E â†’L[ğ•œ] G\n  pt : E\n  left_has_deriv : HasStrictFDerivAt leftFun leftDeriv pt\n  right_has_deriv : HasStrictFDerivAt rightFun rightDeriv pt\n  left_range : range leftDeriv = âŠ¤\n  right_range : range rightDeriv = âŠ¤\n  isCompl_ker : IsCompl (ker leftDeriv) (ker rightDeriv)\n\n"}
{"name":"ImplicitFunctionData.mk.inj","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"ğ•œ : Type u_1\ninstâœâ¹ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace ğ•œ E\ninstâœâ¶ : CompleteSpace E\nF : Type u_3\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\ninstâœÂ³ : CompleteSpace F\nG : Type u_4\ninstâœÂ² : NormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : CompleteSpace G\nleftFunâœ : E â†’ F\nleftDerivâœ : ContinuousLinearMap (RingHom.id ğ•œ) E F\nrightFunâœ : E â†’ G\nrightDerivâœ : ContinuousLinearMap (RingHom.id ğ•œ) E G\nptâœ : E\nleft_has_derivâœ : HasStrictFDerivAt leftFunâœ leftDerivâœ ptâœ\nright_has_derivâœ : HasStrictFDerivAt rightFunâœ rightDerivâœ ptâœ\nleft_rangeâœ : Eq (LinearMap.range leftDerivâœ) Top.top\nright_rangeâœ : Eq (LinearMap.range rightDerivâœ) Top.top\nisCompl_kerâœ : IsCompl (LinearMap.ker leftDerivâœ) (LinearMap.ker rightDerivâœ)\nleftFun : E â†’ F\nleftDeriv : ContinuousLinearMap (RingHom.id ğ•œ) E F\nrightFun : E â†’ G\nrightDeriv : ContinuousLinearMap (RingHom.id ğ•œ) E G\npt : E\nleft_has_deriv : HasStrictFDerivAt leftFun leftDeriv pt\nright_has_deriv : HasStrictFDerivAt rightFun rightDeriv pt\nleft_range : Eq (LinearMap.range leftDeriv) Top.top\nright_range : Eq (LinearMap.range rightDeriv) Top.top\nisCompl_ker : IsCompl (LinearMap.ker leftDeriv) (LinearMap.ker rightDeriv)\nxâœ : Eq { leftFun := leftFunâœ, leftDeriv := leftDerivâœ, rightFun := rightFunâœ, rightDeriv := rightDerivâœ, pt := ptâœ, left_has_deriv := left_has_derivâœ, right_has_deriv := right_has_derivâœ, left_range := left_rangeâœ, right_range := right_rangeâœ, isCompl_ker := isCompl_kerâœ } { leftFun := leftFun, leftDeriv := leftDeriv, rightFun := rightFun, rightDeriv := rightDeriv, pt := pt, left_has_deriv := left_has_deriv, right_has_deriv := right_has_deriv, left_range := left_range, right_range := right_range, isCompl_ker := isCompl_ker }\nâŠ¢ And (Eq leftFunâœ leftFun) (And (Eq leftDerivâœ leftDeriv) (And (Eq rightFunâœ rightFun) (And (Eq rightDerivâœ rightDeriv) (Eq ptâœ pt))))","decl":"/-- Data for the general version of the implicit function theorem. It holds two functions\n`f : E â†’ F` and `g : E â†’ G` (named `leftFun` and `rightFun`) and a point `a` (named `pt`) such that\n\n* both functions are strictly differentiable at `a`;\n* the derivatives are surjective;\n* the kernels of the derivatives are complementary subspaces of `E`. -/\nstructure ImplicitFunctionData (ğ•œ : Type*) [NontriviallyNormedField ğ•œ] (E : Type*)\n    [NormedAddCommGroup E] [NormedSpace ğ•œ E] [CompleteSpace E] (F : Type*) [NormedAddCommGroup F]\n    [NormedSpace ğ•œ F] [CompleteSpace F] (G : Type*) [NormedAddCommGroup G] [NormedSpace ğ•œ G]\n    [CompleteSpace G] where\n  leftFun : E â†’ F\n  leftDeriv : E â†’L[ğ•œ] F\n  rightFun : E â†’ G\n  rightDeriv : E â†’L[ğ•œ] G\n  pt : E\n  left_has_deriv : HasStrictFDerivAt leftFun leftDeriv pt\n  right_has_deriv : HasStrictFDerivAt rightFun rightDeriv pt\n  left_range : range leftDeriv = âŠ¤\n  right_range : range rightDeriv = âŠ¤\n  isCompl_ker : IsCompl (ker leftDeriv) (ker rightDeriv)\n\n"}
{"name":"ImplicitFunctionData.prodFun_apply","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"ğ•œ : Type u_1\ninstâœâ¹ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace ğ•œ E\ninstâœâ¶ : CompleteSpace E\nF : Type u_3\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\ninstâœÂ³ : CompleteSpace F\nG : Type u_4\ninstâœÂ² : NormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : CompleteSpace G\nÏ† : ImplicitFunctionData ğ•œ E F G\nx : E\nâŠ¢ Eq (Ï†.prodFun x) { fst := Ï†.leftFun x, snd := Ï†.rightFun x }","decl":"@[simp]\ntheorem prodFun_apply (x : E) : Ï†.prodFun x = (Ï†.leftFun x, Ï†.rightFun x) :=\n  rfl\n\n"}
{"name":"ImplicitFunctionData.hasStrictFDerivAt","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"ğ•œ : Type u_1\ninstâœâ¹ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace ğ•œ E\ninstâœâ¶ : CompleteSpace E\nF : Type u_3\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\ninstâœÂ³ : CompleteSpace F\nG : Type u_4\ninstâœÂ² : NormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : CompleteSpace G\nÏ† : ImplicitFunctionData ğ•œ E F G\nâŠ¢ HasStrictFDerivAt Ï†.prodFun (â†‘(Ï†.leftDeriv.equivProdOfSurjectiveOfIsCompl Ï†.rightDeriv â‹¯ â‹¯ â‹¯)) Ï†.pt","decl":"protected theorem hasStrictFDerivAt :\n    HasStrictFDerivAt Ï†.prodFun\n      (Ï†.leftDeriv.equivProdOfSurjectiveOfIsCompl Ï†.rightDeriv Ï†.left_range Ï†.right_range\n          Ï†.isCompl_ker :\n        E â†’L[ğ•œ] F Ã— G)\n      Ï†.pt :=\n  Ï†.left_has_deriv.prod Ï†.right_has_deriv\n\n"}
{"name":"ImplicitFunctionData.toPartialHomeomorph_coe","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"ğ•œ : Type u_1\ninstâœâ¹ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace ğ•œ E\ninstâœâ¶ : CompleteSpace E\nF : Type u_3\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\ninstâœÂ³ : CompleteSpace F\nG : Type u_4\ninstâœÂ² : NormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : CompleteSpace G\nÏ† : ImplicitFunctionData ğ•œ E F G\nâŠ¢ Eq (â†‘Ï†.toPartialHomeomorph) Ï†.prodFun","decl":"@[simp]\ntheorem toPartialHomeomorph_coe : â‡‘Ï†.toPartialHomeomorph = Ï†.prodFun :=\n  rfl\n\n"}
{"name":"ImplicitFunctionData.toPartialHomeomorph_apply","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"ğ•œ : Type u_1\ninstâœâ¹ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace ğ•œ E\ninstâœâ¶ : CompleteSpace E\nF : Type u_3\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\ninstâœÂ³ : CompleteSpace F\nG : Type u_4\ninstâœÂ² : NormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : CompleteSpace G\nÏ† : ImplicitFunctionData ğ•œ E F G\nx : E\nâŠ¢ Eq (â†‘Ï†.toPartialHomeomorph x) { fst := Ï†.leftFun x, snd := Ï†.rightFun x }","decl":"theorem toPartialHomeomorph_apply (x : E) : Ï†.toPartialHomeomorph x = (Ï†.leftFun x, Ï†.rightFun x) :=\n  rfl\n\n"}
{"name":"ImplicitFunctionData.pt_mem_toPartialHomeomorph_source","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"ğ•œ : Type u_1\ninstâœâ¹ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace ğ•œ E\ninstâœâ¶ : CompleteSpace E\nF : Type u_3\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\ninstâœÂ³ : CompleteSpace F\nG : Type u_4\ninstâœÂ² : NormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : CompleteSpace G\nÏ† : ImplicitFunctionData ğ•œ E F G\nâŠ¢ Membership.mem Ï†.toPartialHomeomorph.source Ï†.pt","decl":"theorem pt_mem_toPartialHomeomorph_source : Ï†.pt âˆˆ Ï†.toPartialHomeomorph.source :=\n  Ï†.hasStrictFDerivAt.mem_toPartialHomeomorph_source\n\n"}
{"name":"ImplicitFunctionData.map_pt_mem_toPartialHomeomorph_target","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"ğ•œ : Type u_1\ninstâœâ¹ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace ğ•œ E\ninstâœâ¶ : CompleteSpace E\nF : Type u_3\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\ninstâœÂ³ : CompleteSpace F\nG : Type u_4\ninstâœÂ² : NormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : CompleteSpace G\nÏ† : ImplicitFunctionData ğ•œ E F G\nâŠ¢ Membership.mem Ï†.toPartialHomeomorph.target { fst := Ï†.leftFun Ï†.pt, snd := Ï†.rightFun Ï†.pt }","decl":"theorem map_pt_mem_toPartialHomeomorph_target :\n    (Ï†.leftFun Ï†.pt, Ï†.rightFun Ï†.pt) âˆˆ Ï†.toPartialHomeomorph.target :=\n  Ï†.toPartialHomeomorph.map_source <| Ï†.pt_mem_toPartialHomeomorph_source\n\n"}
{"name":"ImplicitFunctionData.prod_map_implicitFunction","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"ğ•œ : Type u_1\ninstâœâ¹ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace ğ•œ E\ninstâœâ¶ : CompleteSpace E\nF : Type u_3\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\ninstâœÂ³ : CompleteSpace F\nG : Type u_4\ninstâœÂ² : NormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : CompleteSpace G\nÏ† : ImplicitFunctionData ğ•œ E F G\nâŠ¢ Filter.Eventually (fun p => Eq (Ï†.prodFun (Ï†.implicitFunction p.1 p.2)) p) (nhds (Ï†.prodFun Ï†.pt))","decl":"theorem prod_map_implicitFunction :\n    âˆ€á¶  p : F Ã— G in ğ“ (Ï†.prodFun Ï†.pt), Ï†.prodFun (Ï†.implicitFunction p.1 p.2) = p :=\n  Ï†.hasStrictFDerivAt.eventually_right_inverse.mono fun âŸ¨_, _âŸ© h => h\n\n"}
{"name":"ImplicitFunctionData.left_map_implicitFunction","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"ğ•œ : Type u_1\ninstâœâ¹ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace ğ•œ E\ninstâœâ¶ : CompleteSpace E\nF : Type u_3\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\ninstâœÂ³ : CompleteSpace F\nG : Type u_4\ninstâœÂ² : NormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : CompleteSpace G\nÏ† : ImplicitFunctionData ğ•œ E F G\nâŠ¢ Filter.Eventually (fun p => Eq (Ï†.leftFun (Ï†.implicitFunction p.1 p.2)) p.1) (nhds (Ï†.prodFun Ï†.pt))","decl":"theorem left_map_implicitFunction :\n    âˆ€á¶  p : F Ã— G in ğ“ (Ï†.prodFun Ï†.pt), Ï†.leftFun (Ï†.implicitFunction p.1 p.2) = p.1 :=\n  Ï†.prod_map_implicitFunction.mono fun _ => congr_arg Prod.fst\n\n"}
{"name":"ImplicitFunctionData.right_map_implicitFunction","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"ğ•œ : Type u_1\ninstâœâ¹ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace ğ•œ E\ninstâœâ¶ : CompleteSpace E\nF : Type u_3\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\ninstâœÂ³ : CompleteSpace F\nG : Type u_4\ninstâœÂ² : NormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : CompleteSpace G\nÏ† : ImplicitFunctionData ğ•œ E F G\nâŠ¢ Filter.Eventually (fun p => Eq (Ï†.rightFun (Ï†.implicitFunction p.1 p.2)) p.2) (nhds (Ï†.prodFun Ï†.pt))","decl":"theorem right_map_implicitFunction :\n    âˆ€á¶  p : F Ã— G in ğ“ (Ï†.prodFun Ï†.pt), Ï†.rightFun (Ï†.implicitFunction p.1 p.2) = p.2 :=\n  Ï†.prod_map_implicitFunction.mono fun _ => congr_arg Prod.snd\n\n"}
{"name":"ImplicitFunctionData.implicitFunction_apply_image","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"ğ•œ : Type u_1\ninstâœâ¹ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace ğ•œ E\ninstâœâ¶ : CompleteSpace E\nF : Type u_3\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\ninstâœÂ³ : CompleteSpace F\nG : Type u_4\ninstâœÂ² : NormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : CompleteSpace G\nÏ† : ImplicitFunctionData ğ•œ E F G\nâŠ¢ Filter.Eventually (fun x => Eq (Ï†.implicitFunction (Ï†.leftFun x) (Ï†.rightFun x)) x) (nhds Ï†.pt)","decl":"theorem implicitFunction_apply_image :\n    âˆ€á¶  x in ğ“ Ï†.pt, Ï†.implicitFunction (Ï†.leftFun x) (Ï†.rightFun x) = x :=\n  Ï†.hasStrictFDerivAt.eventually_left_inverse\n\n"}
{"name":"ImplicitFunctionData.map_nhds_eq","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"ğ•œ : Type u_1\ninstâœâ¹ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace ğ•œ E\ninstâœâ¶ : CompleteSpace E\nF : Type u_3\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\ninstâœÂ³ : CompleteSpace F\nG : Type u_4\ninstâœÂ² : NormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : CompleteSpace G\nÏ† : ImplicitFunctionData ğ•œ E F G\nâŠ¢ Eq (Filter.map Ï†.leftFun (nhds Ï†.pt)) (nhds (Ï†.leftFun Ï†.pt))","decl":"theorem map_nhds_eq : map Ï†.leftFun (ğ“ Ï†.pt) = ğ“ (Ï†.leftFun Ï†.pt) :=\n  show map (Prod.fst âˆ˜ Ï†.prodFun) (ğ“ Ï†.pt) = ğ“ (Ï†.prodFun Ï†.pt).1 by\n    rw [â† map_map, Ï†.hasStrictFDerivAt.map_nhds_eq_of_equiv, map_fst_nhds]\n\n"}
{"name":"ImplicitFunctionData.implicitFunction_hasStrictFDerivAt","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"ğ•œ : Type u_1\ninstâœâ¹ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace ğ•œ E\ninstâœâ¶ : CompleteSpace E\nF : Type u_3\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\ninstâœÂ³ : CompleteSpace F\nG : Type u_4\ninstâœÂ² : NormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : CompleteSpace G\nÏ† : ImplicitFunctionData ğ•œ E F G\ng'inv : ContinuousLinearMap (RingHom.id ğ•œ) G E\nhg'inv : Eq (Ï†.rightDeriv.comp g'inv) (ContinuousLinearMap.id ğ•œ G)\nhg'invf : Eq (Ï†.leftDeriv.comp g'inv) 0\nâŠ¢ HasStrictFDerivAt (Ï†.implicitFunction (Ï†.leftFun Ï†.pt)) g'inv (Ï†.rightFun Ï†.pt)","decl":"theorem implicitFunction_hasStrictFDerivAt (g'inv : G â†’L[ğ•œ] E)\n    (hg'inv : Ï†.rightDeriv.comp g'inv = ContinuousLinearMap.id ğ•œ G)\n    (hg'invf : Ï†.leftDeriv.comp g'inv = 0) :\n    HasStrictFDerivAt (Ï†.implicitFunction (Ï†.leftFun Ï†.pt)) g'inv (Ï†.rightFun Ï†.pt) := by\n  have := Ï†.hasStrictFDerivAt.to_localInverse\n  simp only [prodFun] at this\n  convert this.comp (Ï†.rightFun Ï†.pt) ((hasStrictFDerivAt_const _ _).prod (hasStrictFDerivAt_id _))\n  -- Porting note: added parentheses to help `simp`\n  simp only [ContinuousLinearMap.ext_iff, (ContinuousLinearMap.comp_apply)] at hg'inv hg'invf âŠ¢\n  simp [ContinuousLinearEquiv.eq_symm_apply, *]\n\n"}
{"name":"HasStrictFDerivAt.implicitToPartialHomeomorphOfComplemented_fst","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : CompleteSpace E\nF : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\ninstâœ : CompleteSpace F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\na : E\nhf : HasStrictFDerivAt f f' a\nhf' : Eq (LinearMap.range f') Top.top\nhker : (LinearMap.ker f').ClosedComplemented\nx : E\nâŠ¢ Eq (â†‘(HasStrictFDerivAt.implicitToPartialHomeomorphOfComplemented f f' hf hf' hker) x).1 (f x)","decl":"@[simp]\ntheorem implicitToPartialHomeomorphOfComplemented_fst (hf : HasStrictFDerivAt f f' a)\n    (hf' : range f' = âŠ¤) (hker : (ker f').ClosedComplemented) (x : E) :\n    (hf.implicitToPartialHomeomorphOfComplemented f f' hf' hker x).fst = f x :=\n  rfl\n\n"}
{"name":"HasStrictFDerivAt.implicitToPartialHomeomorphOfComplemented_apply","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : CompleteSpace E\nF : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\ninstâœ : CompleteSpace F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\na : E\nhf : HasStrictFDerivAt f f' a\nhf' : Eq (LinearMap.range f') Top.top\nhker : (LinearMap.ker f').ClosedComplemented\ny : E\nâŠ¢ Eq (â†‘(HasStrictFDerivAt.implicitToPartialHomeomorphOfComplemented f f' hf hf' hker) y) { fst := f y, snd := (Classical.choose hker) (HSub.hSub y a) }","decl":"theorem implicitToPartialHomeomorphOfComplemented_apply (hf : HasStrictFDerivAt f f' a)\n    (hf' : range f' = âŠ¤) (hker : (ker f').ClosedComplemented) (y : E) :\n    hf.implicitToPartialHomeomorphOfComplemented f f' hf' hker y =\n      (f y, Classical.choose hker (y - a)) :=\n  rfl\n\n"}
{"name":"HasStrictFDerivAt.implicitToPartialHomeomorphOfComplemented_apply_ker","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : CompleteSpace E\nF : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\ninstâœ : CompleteSpace F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\na : E\nhf : HasStrictFDerivAt f f' a\nhf' : Eq (LinearMap.range f') Top.top\nhker : (LinearMap.ker f').ClosedComplemented\ny : Subtype fun x => Membership.mem (LinearMap.ker f') x\nâŠ¢ Eq (â†‘(HasStrictFDerivAt.implicitToPartialHomeomorphOfComplemented f f' hf hf' hker) (HAdd.hAdd (â†‘y) a)) { fst := f (HAdd.hAdd (â†‘y) a), snd := y }","decl":"@[simp]\ntheorem implicitToPartialHomeomorphOfComplemented_apply_ker (hf : HasStrictFDerivAt f f' a)\n    (hf' : range f' = âŠ¤) (hker : (ker f').ClosedComplemented) (y : ker f') :\n    hf.implicitToPartialHomeomorphOfComplemented f f' hf' hker (y + a) = (f (y + a), y) := by\n  simp only [implicitToPartialHomeomorphOfComplemented_apply, add_sub_cancel_right,\n    Classical.choose_spec hker]\n\n"}
{"name":"HasStrictFDerivAt.implicitToPartialHomeomorphOfComplemented_self","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : CompleteSpace E\nF : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\ninstâœ : CompleteSpace F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\na : E\nhf : HasStrictFDerivAt f f' a\nhf' : Eq (LinearMap.range f') Top.top\nhker : (LinearMap.ker f').ClosedComplemented\nâŠ¢ Eq (â†‘(HasStrictFDerivAt.implicitToPartialHomeomorphOfComplemented f f' hf hf' hker) a) { fst := f a, snd := 0 }","decl":"@[simp]\ntheorem implicitToPartialHomeomorphOfComplemented_self (hf : HasStrictFDerivAt f f' a)\n    (hf' : range f' = âŠ¤) (hker : (ker f').ClosedComplemented) :\n    hf.implicitToPartialHomeomorphOfComplemented f f' hf' hker a = (f a, 0) := by\n  simp [hf.implicitToPartialHomeomorphOfComplemented_apply]\n\n"}
{"name":"HasStrictFDerivAt.mem_implicitToPartialHomeomorphOfComplemented_source","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : CompleteSpace E\nF : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\ninstâœ : CompleteSpace F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\na : E\nhf : HasStrictFDerivAt f f' a\nhf' : Eq (LinearMap.range f') Top.top\nhker : (LinearMap.ker f').ClosedComplemented\nâŠ¢ Membership.mem (HasStrictFDerivAt.implicitToPartialHomeomorphOfComplemented f f' hf hf' hker).source a","decl":"theorem mem_implicitToPartialHomeomorphOfComplemented_source (hf : HasStrictFDerivAt f f' a)\n    (hf' : range f' = âŠ¤) (hker : (ker f').ClosedComplemented) :\n    a âˆˆ (hf.implicitToPartialHomeomorphOfComplemented f f' hf' hker).source :=\n  ImplicitFunctionData.pt_mem_toPartialHomeomorph_source _\n\n"}
{"name":"HasStrictFDerivAt.mem_implicitToPartialHomeomorphOfComplemented_target","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : CompleteSpace E\nF : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\ninstâœ : CompleteSpace F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\na : E\nhf : HasStrictFDerivAt f f' a\nhf' : Eq (LinearMap.range f') Top.top\nhker : (LinearMap.ker f').ClosedComplemented\nâŠ¢ Membership.mem (HasStrictFDerivAt.implicitToPartialHomeomorphOfComplemented f f' hf hf' hker).target { fst := f a, snd := 0 }","decl":"theorem mem_implicitToPartialHomeomorphOfComplemented_target (hf : HasStrictFDerivAt f f' a)\n    (hf' : range f' = âŠ¤) (hker : (ker f').ClosedComplemented) :\n    (f a, (0 : ker f')) âˆˆ (hf.implicitToPartialHomeomorphOfComplemented f f' hf' hker).target := by\n  simpa only [implicitToPartialHomeomorphOfComplemented_self] using\n    (hf.implicitToPartialHomeomorphOfComplemented f f' hf' hker).map_source <|\n      hf.mem_implicitToPartialHomeomorphOfComplemented_source hf' hker\n\n"}
{"name":"HasStrictFDerivAt.map_implicitFunctionOfComplemented_eq","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : CompleteSpace E\nF : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\ninstâœ : CompleteSpace F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\na : E\nhf : HasStrictFDerivAt f f' a\nhf' : Eq (LinearMap.range f') Top.top\nhker : (LinearMap.ker f').ClosedComplemented\nâŠ¢ Filter.Eventually (fun p => Eq (f (HasStrictFDerivAt.implicitFunctionOfComplemented f f' hf hf' hker p.1 p.2)) p.1) (nhds { fst := f a, snd := 0 })","decl":"/-- `HasStrictFDerivAt.implicitFunctionOfComplemented` sends `(z, y)` to a point in `f â»Â¹' z`. -/\ntheorem map_implicitFunctionOfComplemented_eq (hf : HasStrictFDerivAt f f' a) (hf' : range f' = âŠ¤)\n    (hker : (ker f').ClosedComplemented) :\n    âˆ€á¶  p : F Ã— ker f' in ğ“ (f a, 0),\n      f (hf.implicitFunctionOfComplemented f f' hf' hker p.1 p.2) = p.1 :=\n  ((hf.implicitToPartialHomeomorphOfComplemented f f' hf' hker).eventually_right_inverse <|\n        hf.mem_implicitToPartialHomeomorphOfComplemented_target hf' hker).mono\n    fun âŸ¨_, _âŸ© h => congr_arg Prod.fst h\n\n"}
{"name":"HasStrictFDerivAt.eq_implicitFunctionOfComplemented","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : CompleteSpace E\nF : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\ninstâœ : CompleteSpace F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\na : E\nhf : HasStrictFDerivAt f f' a\nhf' : Eq (LinearMap.range f') Top.top\nhker : (LinearMap.ker f').ClosedComplemented\nâŠ¢ Filter.Eventually (fun x => Eq (HasStrictFDerivAt.implicitFunctionOfComplemented f f' hf hf' hker (f x) (â†‘(HasStrictFDerivAt.implicitToPartialHomeomorphOfComplemented f f' hf hf' hker) x).2) x) (nhds a)","decl":"/-- Any point in some neighborhood of `a` can be represented as\n`HasStrictFDerivAt.implicitFunctionOfComplemented` of some point. -/\ntheorem eq_implicitFunctionOfComplemented (hf : HasStrictFDerivAt f f' a) (hf' : range f' = âŠ¤)\n    (hker : (ker f').ClosedComplemented) :\n    âˆ€á¶  x in ğ“ a, hf.implicitFunctionOfComplemented f f' hf' hker (f x)\n      (hf.implicitToPartialHomeomorphOfComplemented f f' hf' hker x).snd = x :=\n  (implicitFunctionDataOfComplemented f f' hf hf' hker).implicitFunction_apply_image\n\n"}
{"name":"HasStrictFDerivAt.implicitFunctionOfComplemented_apply_image","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : CompleteSpace E\nF : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\ninstâœ : CompleteSpace F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\na : E\nhf : HasStrictFDerivAt f f' a\nhf' : Eq (LinearMap.range f') Top.top\nhker : (LinearMap.ker f').ClosedComplemented\nâŠ¢ Eq (HasStrictFDerivAt.implicitFunctionOfComplemented f f' hf hf' hker (f a) 0) a","decl":"@[simp]\ntheorem implicitFunctionOfComplemented_apply_image (hf : HasStrictFDerivAt f f' a)\n    (hf' : range f' = âŠ¤) (hker : (ker f').ClosedComplemented) :\n    hf.implicitFunctionOfComplemented f f' hf' hker (f a) 0 = a := by\n  simpa only [implicitToPartialHomeomorphOfComplemented_self] using\n      (hf.implicitToPartialHomeomorphOfComplemented f f' hf' hker).left_inv\n      (hf.mem_implicitToPartialHomeomorphOfComplemented_source hf' hker)\n\n"}
{"name":"HasStrictFDerivAt.to_implicitFunctionOfComplemented","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : CompleteSpace E\nF : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\ninstâœ : CompleteSpace F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\na : E\nhf : HasStrictFDerivAt f f' a\nhf' : Eq (LinearMap.range f') Top.top\nhker : (LinearMap.ker f').ClosedComplemented\nâŠ¢ HasStrictFDerivAt (HasStrictFDerivAt.implicitFunctionOfComplemented f f' hf hf' hker (f a)) (LinearMap.ker f').subtypeL 0","decl":"theorem to_implicitFunctionOfComplemented (hf : HasStrictFDerivAt f f' a) (hf' : range f' = âŠ¤)\n    (hker : (ker f').ClosedComplemented) :\n    HasStrictFDerivAt (hf.implicitFunctionOfComplemented f f' hf' hker (f a))\n      (ker f').subtypeL 0 := by\n  convert (implicitFunctionDataOfComplemented f f' hf hf' hker).implicitFunction_hasStrictFDerivAt\n    (ker f').subtypeL _ _\n  swap\n  Â· ext\n    -- Porting note: added parentheses to help `simp`\n    simp only [Classical.choose_spec hker, implicitFunctionDataOfComplemented,\n      ContinuousLinearMap.comp_apply, Submodule.coe_subtypeL', Submodule.coe_subtype,\n      ContinuousLinearMap.id_apply]\n  swap\n  Â· ext\n    -- Porting note: added parentheses to help `simp`\n    simp only [(ContinuousLinearMap.comp_apply), Submodule.coe_subtypeL', Submodule.coe_subtype,\n      LinearMap.map_coe_ker, (ContinuousLinearMap.zero_apply)]\n  simp only [implicitFunctionDataOfComplemented, map_sub, sub_self]\n\n"}
{"name":"HasStrictFDerivAt.implicitToPartialHomeomorph_fst","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"ğ•œ : Type u_1\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : CompleteSpace ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : CompleteSpace E\nF : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\ninstâœ : FiniteDimensional ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\na : E\nhf : HasStrictFDerivAt f f' a\nhf' : Eq (LinearMap.range f') Top.top\nx : E\nâŠ¢ Eq (â†‘(HasStrictFDerivAt.implicitToPartialHomeomorph f f' hf hf') x).1 (f x)","decl":"@[simp]\ntheorem implicitToPartialHomeomorph_fst (hf : HasStrictFDerivAt f f' a) (hf' : range f' = âŠ¤)\n    (x : E) : (hf.implicitToPartialHomeomorph f f' hf' x).fst = f x :=\n  rfl\n\n"}
{"name":"HasStrictFDerivAt.implicitToPartialHomeomorph_apply_ker","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"ğ•œ : Type u_1\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : CompleteSpace ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : CompleteSpace E\nF : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\ninstâœ : FiniteDimensional ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\na : E\nhf : HasStrictFDerivAt f f' a\nhf' : Eq (LinearMap.range f') Top.top\ny : Subtype fun x => Membership.mem (LinearMap.ker f') x\nâŠ¢ Eq (â†‘(HasStrictFDerivAt.implicitToPartialHomeomorph f f' hf hf') (HAdd.hAdd (â†‘y) a)) { fst := f (HAdd.hAdd (â†‘y) a), snd := y }","decl":"@[simp]\ntheorem implicitToPartialHomeomorph_apply_ker (hf : HasStrictFDerivAt f f' a) (hf' : range f' = âŠ¤)\n    (y : ker f') : hf.implicitToPartialHomeomorph f f' hf' (y + a) = (f (y + a), y) :=\n  -- Porting note: had to add `haveI` (here and below)\n  haveI := FiniteDimensional.complete ğ•œ F\n  implicitToPartialHomeomorphOfComplemented_apply_ker ..\n\n"}
{"name":"HasStrictFDerivAt.implicitToPartialHomeomorph_self","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"ğ•œ : Type u_1\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : CompleteSpace ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : CompleteSpace E\nF : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\ninstâœ : FiniteDimensional ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\na : E\nhf : HasStrictFDerivAt f f' a\nhf' : Eq (LinearMap.range f') Top.top\nâŠ¢ Eq (â†‘(HasStrictFDerivAt.implicitToPartialHomeomorph f f' hf hf') a) { fst := f a, snd := 0 }","decl":"@[simp]\ntheorem implicitToPartialHomeomorph_self (hf : HasStrictFDerivAt f f' a) (hf' : range f' = âŠ¤) :\n    hf.implicitToPartialHomeomorph f f' hf' a = (f a, 0) :=\n  haveI := FiniteDimensional.complete ğ•œ F\n  implicitToPartialHomeomorphOfComplemented_self ..\n\n"}
{"name":"HasStrictFDerivAt.mem_implicitToPartialHomeomorph_source","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"ğ•œ : Type u_1\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : CompleteSpace ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : CompleteSpace E\nF : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\ninstâœ : FiniteDimensional ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\na : E\nhf : HasStrictFDerivAt f f' a\nhf' : Eq (LinearMap.range f') Top.top\nâŠ¢ Membership.mem (HasStrictFDerivAt.implicitToPartialHomeomorph f f' hf hf').source a","decl":"theorem mem_implicitToPartialHomeomorph_source (hf : HasStrictFDerivAt f f' a)\n    (hf' : range f' = âŠ¤) : a âˆˆ (hf.implicitToPartialHomeomorph f f' hf').source :=\n  haveI := FiniteDimensional.complete ğ•œ F\n  ImplicitFunctionData.pt_mem_toPartialHomeomorph_source _\n\n"}
{"name":"HasStrictFDerivAt.mem_implicitToPartialHomeomorph_target","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"ğ•œ : Type u_1\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : CompleteSpace ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : CompleteSpace E\nF : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\ninstâœ : FiniteDimensional ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\na : E\nhf : HasStrictFDerivAt f f' a\nhf' : Eq (LinearMap.range f') Top.top\nâŠ¢ Membership.mem (HasStrictFDerivAt.implicitToPartialHomeomorph f f' hf hf').target { fst := f a, snd := 0 }","decl":"theorem mem_implicitToPartialHomeomorph_target (hf : HasStrictFDerivAt f f' a)\n    (hf' : range f' = âŠ¤) : (f a, (0 : ker f')) âˆˆ (hf.implicitToPartialHomeomorph f f' hf').target :=\n  haveI := FiniteDimensional.complete ğ•œ F\n  mem_implicitToPartialHomeomorphOfComplemented_target ..\n\n"}
{"name":"HasStrictFDerivAt.tendsto_implicitFunction","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"ğ•œ : Type u_1\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : CompleteSpace ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : CompleteSpace E\nF : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\ninstâœ : FiniteDimensional ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\na : E\nhf : HasStrictFDerivAt f f' a\nhf' : Eq (LinearMap.range f') Top.top\nÎ± : Type u_4\nl : Filter Î±\ngâ‚ : Î± â†’ F\ngâ‚‚ : Î± â†’ Subtype fun x => Membership.mem (LinearMap.ker f') x\nhâ‚ : Filter.Tendsto gâ‚ l (nhds (f a))\nhâ‚‚ : Filter.Tendsto gâ‚‚ l (nhds 0)\nâŠ¢ Filter.Tendsto (fun t => HasStrictFDerivAt.implicitFunction f f' hf hf' (gâ‚ t) (gâ‚‚ t)) l (nhds a)","decl":"theorem tendsto_implicitFunction (hf : HasStrictFDerivAt f f' a) (hf' : range f' = âŠ¤) {Î± : Type*}\n    {l : Filter Î±} {gâ‚ : Î± â†’ F} {gâ‚‚ : Î± â†’ ker f'} (hâ‚ : Tendsto gâ‚ l (ğ“ <| f a))\n    (hâ‚‚ : Tendsto gâ‚‚ l (ğ“ 0)) :\n    Tendsto (fun t => hf.implicitFunction f f' hf' (gâ‚ t) (gâ‚‚ t)) l (ğ“ a) := by\n  refine ((hf.implicitToPartialHomeomorph f f' hf').tendsto_symm\n    (hf.mem_implicitToPartialHomeomorph_source hf')).comp ?_\n  rw [implicitToPartialHomeomorph_self]\n  exact hâ‚.prod_mk_nhds hâ‚‚\n\n"}
{"name":"Filter.Tendsto.implicitFunction","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"ğ•œ : Type u_1\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : CompleteSpace ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : CompleteSpace E\nF : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\ninstâœ : FiniteDimensional ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\na : E\nhf : HasStrictFDerivAt f f' a\nhf' : Eq (LinearMap.range f') Top.top\nÎ± : Type u_4\nl : Filter Î±\ngâ‚ : Î± â†’ F\ngâ‚‚ : Î± â†’ Subtype fun x => Membership.mem (LinearMap.ker f') x\nhâ‚ : Filter.Tendsto gâ‚ l (nhds (f a))\nhâ‚‚ : Filter.Tendsto gâ‚‚ l (nhds 0)\nâŠ¢ Filter.Tendsto (fun t => HasStrictFDerivAt.implicitFunction f f' hf hf' (gâ‚ t) (gâ‚‚ t)) l (nhds a)","decl":"alias _root_.Filter.Tendsto.implicitFunction := tendsto_implicitFunction\n\n"}
{"name":"HasStrictFDerivAt.map_implicitFunction_eq","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"ğ•œ : Type u_1\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : CompleteSpace ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : CompleteSpace E\nF : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\ninstâœ : FiniteDimensional ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\na : E\nhf : HasStrictFDerivAt f f' a\nhf' : Eq (LinearMap.range f') Top.top\nâŠ¢ Filter.Eventually (fun p => Eq (f (HasStrictFDerivAt.implicitFunction f f' hf hf' p.1 p.2)) p.1) (nhds { fst := f a, snd := 0 })","decl":"/-- `HasStrictFDerivAt.implicitFunction` sends `(z, y)` to a point in `f â»Â¹' z`. -/\ntheorem map_implicitFunction_eq (hf : HasStrictFDerivAt f f' a) (hf' : range f' = âŠ¤) :\n    âˆ€á¶  p : F Ã— ker f' in ğ“ (f a, 0), f (hf.implicitFunction f f' hf' p.1 p.2) = p.1 :=\n  haveI := FiniteDimensional.complete ğ•œ F\n  map_implicitFunctionOfComplemented_eq ..\n\n"}
{"name":"HasStrictFDerivAt.implicitFunction_apply_image","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"ğ•œ : Type u_1\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : CompleteSpace ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : CompleteSpace E\nF : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\ninstâœ : FiniteDimensional ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\na : E\nhf : HasStrictFDerivAt f f' a\nhf' : Eq (LinearMap.range f') Top.top\nâŠ¢ Eq (HasStrictFDerivAt.implicitFunction f f' hf hf' (f a) 0) a","decl":"@[simp]\ntheorem implicitFunction_apply_image (hf : HasStrictFDerivAt f f' a) (hf' : range f' = âŠ¤) :\n    hf.implicitFunction f f' hf' (f a) 0 = a := by\n  haveI := FiniteDimensional.complete ğ•œ F\n  apply implicitFunctionOfComplemented_apply_image\n\n"}
{"name":"HasStrictFDerivAt.eq_implicitFunction","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"ğ•œ : Type u_1\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : CompleteSpace ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : CompleteSpace E\nF : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\ninstâœ : FiniteDimensional ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\na : E\nhf : HasStrictFDerivAt f f' a\nhf' : Eq (LinearMap.range f') Top.top\nâŠ¢ Filter.Eventually (fun x => Eq (HasStrictFDerivAt.implicitFunction f f' hf hf' (f x) (â†‘(HasStrictFDerivAt.implicitToPartialHomeomorph f f' hf hf') x).2) x) (nhds a)","decl":"/-- Any point in some neighborhood of `a` can be represented as `HasStrictFDerivAt.implicitFunction`\nof some point. -/\ntheorem eq_implicitFunction (hf : HasStrictFDerivAt f f' a) (hf' : range f' = âŠ¤) :\n    âˆ€á¶  x in ğ“ a,\n      hf.implicitFunction f f' hf' (f x) (hf.implicitToPartialHomeomorph f f' hf' x).snd = x :=\n  haveI := FiniteDimensional.complete ğ•œ F\n  eq_implicitFunctionOfComplemented ..\n\n"}
{"name":"HasStrictFDerivAt.to_implicitFunction","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"ğ•œ : Type u_1\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : CompleteSpace ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : CompleteSpace E\nF : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\ninstâœ : FiniteDimensional ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\na : E\nhf : HasStrictFDerivAt f f' a\nhf' : Eq (LinearMap.range f') Top.top\nâŠ¢ HasStrictFDerivAt (HasStrictFDerivAt.implicitFunction f f' hf hf' (f a)) (LinearMap.ker f').subtypeL 0","decl":"theorem to_implicitFunction (hf : HasStrictFDerivAt f f' a) (hf' : range f' = âŠ¤) :\n    HasStrictFDerivAt (hf.implicitFunction f f' hf' (f a)) (ker f').subtypeL 0 :=\n  haveI := FiniteDimensional.complete ğ•œ F\n  to_implicitFunctionOfComplemented ..\n\n"}
