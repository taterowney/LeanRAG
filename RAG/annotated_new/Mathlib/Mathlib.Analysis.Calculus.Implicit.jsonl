{"name":"ImplicitFunctionData.left_range","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"𝕜 : Type u_1\ninst✝⁹ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : NormedSpace 𝕜 E\ninst✝⁶ : CompleteSpace E\nF : Type u_3\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\ninst✝³ : CompleteSpace F\nG : Type u_4\ninst✝² : NormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : CompleteSpace G\nself : ImplicitFunctionData 𝕜 E F G\n⊢ Eq (LinearMap.range self.leftDeriv) Top.top","decl":"/-- Data for the general version of the implicit function theorem. It holds two functions\n`f : E → F` and `g : E → G` (named `leftFun` and `rightFun`) and a point `a` (named `pt`) such that\n\n* both functions are strictly differentiable at `a`;\n* the derivatives are surjective;\n* the kernels of the derivatives are complementary subspaces of `E`. -/\nstructure ImplicitFunctionData (𝕜 : Type*) [NontriviallyNormedField 𝕜] (E : Type*)\n    [NormedAddCommGroup E] [NormedSpace 𝕜 E] [CompleteSpace E] (F : Type*) [NormedAddCommGroup F]\n    [NormedSpace 𝕜 F] [CompleteSpace F] (G : Type*) [NormedAddCommGroup G] [NormedSpace 𝕜 G]\n    [CompleteSpace G] where\n  leftFun : E → F\n  leftDeriv : E →L[𝕜] F\n  rightFun : E → G\n  rightDeriv : E →L[𝕜] G\n  pt : E\n  left_has_deriv : HasStrictFDerivAt leftFun leftDeriv pt\n  right_has_deriv : HasStrictFDerivAt rightFun rightDeriv pt\n  left_range : range leftDeriv = ⊤\n  right_range : range rightDeriv = ⊤\n  isCompl_ker : IsCompl (ker leftDeriv) (ker rightDeriv)\n\n"}
{"name":"ImplicitFunctionData.left_has_deriv","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"𝕜 : Type u_1\ninst✝⁹ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : NormedSpace 𝕜 E\ninst✝⁶ : CompleteSpace E\nF : Type u_3\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\ninst✝³ : CompleteSpace F\nG : Type u_4\ninst✝² : NormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : CompleteSpace G\nself : ImplicitFunctionData 𝕜 E F G\n⊢ HasStrictFDerivAt self.leftFun self.leftDeriv self.pt","decl":"/-- Data for the general version of the implicit function theorem. It holds two functions\n`f : E → F` and `g : E → G` (named `leftFun` and `rightFun`) and a point `a` (named `pt`) such that\n\n* both functions are strictly differentiable at `a`;\n* the derivatives are surjective;\n* the kernels of the derivatives are complementary subspaces of `E`. -/\nstructure ImplicitFunctionData (𝕜 : Type*) [NontriviallyNormedField 𝕜] (E : Type*)\n    [NormedAddCommGroup E] [NormedSpace 𝕜 E] [CompleteSpace E] (F : Type*) [NormedAddCommGroup F]\n    [NormedSpace 𝕜 F] [CompleteSpace F] (G : Type*) [NormedAddCommGroup G] [NormedSpace 𝕜 G]\n    [CompleteSpace G] where\n  leftFun : E → F\n  leftDeriv : E →L[𝕜] F\n  rightFun : E → G\n  rightDeriv : E →L[𝕜] G\n  pt : E\n  left_has_deriv : HasStrictFDerivAt leftFun leftDeriv pt\n  right_has_deriv : HasStrictFDerivAt rightFun rightDeriv pt\n  left_range : range leftDeriv = ⊤\n  right_range : range rightDeriv = ⊤\n  isCompl_ker : IsCompl (ker leftDeriv) (ker rightDeriv)\n\n"}
{"name":"ImplicitFunctionData.right_has_deriv","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"𝕜 : Type u_1\ninst✝⁹ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : NormedSpace 𝕜 E\ninst✝⁶ : CompleteSpace E\nF : Type u_3\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\ninst✝³ : CompleteSpace F\nG : Type u_4\ninst✝² : NormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : CompleteSpace G\nself : ImplicitFunctionData 𝕜 E F G\n⊢ HasStrictFDerivAt self.rightFun self.rightDeriv self.pt","decl":"/-- Data for the general version of the implicit function theorem. It holds two functions\n`f : E → F` and `g : E → G` (named `leftFun` and `rightFun`) and a point `a` (named `pt`) such that\n\n* both functions are strictly differentiable at `a`;\n* the derivatives are surjective;\n* the kernels of the derivatives are complementary subspaces of `E`. -/\nstructure ImplicitFunctionData (𝕜 : Type*) [NontriviallyNormedField 𝕜] (E : Type*)\n    [NormedAddCommGroup E] [NormedSpace 𝕜 E] [CompleteSpace E] (F : Type*) [NormedAddCommGroup F]\n    [NormedSpace 𝕜 F] [CompleteSpace F] (G : Type*) [NormedAddCommGroup G] [NormedSpace 𝕜 G]\n    [CompleteSpace G] where\n  leftFun : E → F\n  leftDeriv : E →L[𝕜] F\n  rightFun : E → G\n  rightDeriv : E →L[𝕜] G\n  pt : E\n  left_has_deriv : HasStrictFDerivAt leftFun leftDeriv pt\n  right_has_deriv : HasStrictFDerivAt rightFun rightDeriv pt\n  left_range : range leftDeriv = ⊤\n  right_range : range rightDeriv = ⊤\n  isCompl_ker : IsCompl (ker leftDeriv) (ker rightDeriv)\n\n"}
{"name":"ImplicitFunctionData.isCompl_ker","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"𝕜 : Type u_1\ninst✝⁹ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : NormedSpace 𝕜 E\ninst✝⁶ : CompleteSpace E\nF : Type u_3\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\ninst✝³ : CompleteSpace F\nG : Type u_4\ninst✝² : NormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : CompleteSpace G\nself : ImplicitFunctionData 𝕜 E F G\n⊢ IsCompl (LinearMap.ker self.leftDeriv) (LinearMap.ker self.rightDeriv)","decl":"/-- Data for the general version of the implicit function theorem. It holds two functions\n`f : E → F` and `g : E → G` (named `leftFun` and `rightFun`) and a point `a` (named `pt`) such that\n\n* both functions are strictly differentiable at `a`;\n* the derivatives are surjective;\n* the kernels of the derivatives are complementary subspaces of `E`. -/\nstructure ImplicitFunctionData (𝕜 : Type*) [NontriviallyNormedField 𝕜] (E : Type*)\n    [NormedAddCommGroup E] [NormedSpace 𝕜 E] [CompleteSpace E] (F : Type*) [NormedAddCommGroup F]\n    [NormedSpace 𝕜 F] [CompleteSpace F] (G : Type*) [NormedAddCommGroup G] [NormedSpace 𝕜 G]\n    [CompleteSpace G] where\n  leftFun : E → F\n  leftDeriv : E →L[𝕜] F\n  rightFun : E → G\n  rightDeriv : E →L[𝕜] G\n  pt : E\n  left_has_deriv : HasStrictFDerivAt leftFun leftDeriv pt\n  right_has_deriv : HasStrictFDerivAt rightFun rightDeriv pt\n  left_range : range leftDeriv = ⊤\n  right_range : range rightDeriv = ⊤\n  isCompl_ker : IsCompl (ker leftDeriv) (ker rightDeriv)\n\n"}
{"name":"ImplicitFunctionData.mk.sizeOf_spec","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"𝕜 : Type u_1\ninst✝¹³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹² : NormedAddCommGroup E\ninst✝¹¹ : NormedSpace 𝕜 E\ninst✝¹⁰ : CompleteSpace E\nF : Type u_3\ninst✝⁹ : NormedAddCommGroup F\ninst✝⁸ : NormedSpace 𝕜 F\ninst✝⁷ : CompleteSpace F\nG : Type u_4\ninst✝⁶ : NormedAddCommGroup G\ninst✝⁵ : NormedSpace 𝕜 G\ninst✝⁴ : CompleteSpace G\ninst✝³ : SizeOf 𝕜\ninst✝² : SizeOf E\ninst✝¹ : SizeOf F\ninst✝ : SizeOf G\nleftFun : E → F\nleftDeriv : ContinuousLinearMap (RingHom.id 𝕜) E F\nrightFun : E → G\nrightDeriv : ContinuousLinearMap (RingHom.id 𝕜) E G\npt : E\nleft_has_deriv : HasStrictFDerivAt leftFun leftDeriv pt\nright_has_deriv : HasStrictFDerivAt rightFun rightDeriv pt\nleft_range : Eq (LinearMap.range leftDeriv) Top.top\nright_range : Eq (LinearMap.range rightDeriv) Top.top\nisCompl_ker : IsCompl (LinearMap.ker leftDeriv) (LinearMap.ker rightDeriv)\n⊢ Eq (SizeOf.sizeOf { leftFun := leftFun, leftDeriv := leftDeriv, rightFun := rightFun, rightDeriv := rightDeriv, pt := pt, left_has_deriv := left_has_deriv, right_has_deriv := right_has_deriv, left_range := left_range, right_range := right_range, isCompl_ker := isCompl_ker }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf leftDeriv)) (SizeOf.sizeOf rightDeriv)) (SizeOf.sizeOf pt)) (SizeOf.sizeOf left_has_deriv)) (SizeOf.sizeOf right_has_deriv)) (SizeOf.sizeOf left_range)) (SizeOf.sizeOf right_range)) (SizeOf.sizeOf isCompl_ker))","decl":"/-- Data for the general version of the implicit function theorem. It holds two functions\n`f : E → F` and `g : E → G` (named `leftFun` and `rightFun`) and a point `a` (named `pt`) such that\n\n* both functions are strictly differentiable at `a`;\n* the derivatives are surjective;\n* the kernels of the derivatives are complementary subspaces of `E`. -/\nstructure ImplicitFunctionData (𝕜 : Type*) [NontriviallyNormedField 𝕜] (E : Type*)\n    [NormedAddCommGroup E] [NormedSpace 𝕜 E] [CompleteSpace E] (F : Type*) [NormedAddCommGroup F]\n    [NormedSpace 𝕜 F] [CompleteSpace F] (G : Type*) [NormedAddCommGroup G] [NormedSpace 𝕜 G]\n    [CompleteSpace G] where\n  leftFun : E → F\n  leftDeriv : E →L[𝕜] F\n  rightFun : E → G\n  rightDeriv : E →L[𝕜] G\n  pt : E\n  left_has_deriv : HasStrictFDerivAt leftFun leftDeriv pt\n  right_has_deriv : HasStrictFDerivAt rightFun rightDeriv pt\n  left_range : range leftDeriv = ⊤\n  right_range : range rightDeriv = ⊤\n  isCompl_ker : IsCompl (ker leftDeriv) (ker rightDeriv)\n\n"}
{"name":"ImplicitFunctionData.mk.injEq","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"𝕜 : Type u_1\ninst✝⁹ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : NormedSpace 𝕜 E\ninst✝⁶ : CompleteSpace E\nF : Type u_3\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\ninst✝³ : CompleteSpace F\nG : Type u_4\ninst✝² : NormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : CompleteSpace G\nleftFun✝ : E → F\nleftDeriv✝ : ContinuousLinearMap (RingHom.id 𝕜) E F\nrightFun✝ : E → G\nrightDeriv✝ : ContinuousLinearMap (RingHom.id 𝕜) E G\npt✝ : E\nleft_has_deriv✝ : HasStrictFDerivAt leftFun✝ leftDeriv✝ pt✝\nright_has_deriv✝ : HasStrictFDerivAt rightFun✝ rightDeriv✝ pt✝\nleft_range✝ : Eq (LinearMap.range leftDeriv✝) Top.top\nright_range✝ : Eq (LinearMap.range rightDeriv✝) Top.top\nisCompl_ker✝ : IsCompl (LinearMap.ker leftDeriv✝) (LinearMap.ker rightDeriv✝)\nleftFun : E → F\nleftDeriv : ContinuousLinearMap (RingHom.id 𝕜) E F\nrightFun : E → G\nrightDeriv : ContinuousLinearMap (RingHom.id 𝕜) E G\npt : E\nleft_has_deriv : HasStrictFDerivAt leftFun leftDeriv pt\nright_has_deriv : HasStrictFDerivAt rightFun rightDeriv pt\nleft_range : Eq (LinearMap.range leftDeriv) Top.top\nright_range : Eq (LinearMap.range rightDeriv) Top.top\nisCompl_ker : IsCompl (LinearMap.ker leftDeriv) (LinearMap.ker rightDeriv)\n⊢ Eq (Eq { leftFun := leftFun✝, leftDeriv := leftDeriv✝, rightFun := rightFun✝, rightDeriv := rightDeriv✝, pt := pt✝, left_has_deriv := left_has_deriv✝, right_has_deriv := right_has_deriv✝, left_range := left_range✝, right_range := right_range✝, isCompl_ker := isCompl_ker✝ } { leftFun := leftFun, leftDeriv := leftDeriv, rightFun := rightFun, rightDeriv := rightDeriv, pt := pt, left_has_deriv := left_has_deriv, right_has_deriv := right_has_deriv, left_range := left_range, right_range := right_range, isCompl_ker := isCompl_ker }) (And (Eq leftFun✝ leftFun) (And (Eq leftDeriv✝ leftDeriv) (And (Eq rightFun✝ rightFun) (And (Eq rightDeriv✝ rightDeriv) (Eq pt✝ pt)))))","decl":"/-- Data for the general version of the implicit function theorem. It holds two functions\n`f : E → F` and `g : E → G` (named `leftFun` and `rightFun`) and a point `a` (named `pt`) such that\n\n* both functions are strictly differentiable at `a`;\n* the derivatives are surjective;\n* the kernels of the derivatives are complementary subspaces of `E`. -/\nstructure ImplicitFunctionData (𝕜 : Type*) [NontriviallyNormedField 𝕜] (E : Type*)\n    [NormedAddCommGroup E] [NormedSpace 𝕜 E] [CompleteSpace E] (F : Type*) [NormedAddCommGroup F]\n    [NormedSpace 𝕜 F] [CompleteSpace F] (G : Type*) [NormedAddCommGroup G] [NormedSpace 𝕜 G]\n    [CompleteSpace G] where\n  leftFun : E → F\n  leftDeriv : E →L[𝕜] F\n  rightFun : E → G\n  rightDeriv : E →L[𝕜] G\n  pt : E\n  left_has_deriv : HasStrictFDerivAt leftFun leftDeriv pt\n  right_has_deriv : HasStrictFDerivAt rightFun rightDeriv pt\n  left_range : range leftDeriv = ⊤\n  right_range : range rightDeriv = ⊤\n  isCompl_ker : IsCompl (ker leftDeriv) (ker rightDeriv)\n\n"}
{"name":"ImplicitFunctionData.right_range","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"𝕜 : Type u_1\ninst✝⁹ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : NormedSpace 𝕜 E\ninst✝⁶ : CompleteSpace E\nF : Type u_3\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\ninst✝³ : CompleteSpace F\nG : Type u_4\ninst✝² : NormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : CompleteSpace G\nself : ImplicitFunctionData 𝕜 E F G\n⊢ Eq (LinearMap.range self.rightDeriv) Top.top","decl":"/-- Data for the general version of the implicit function theorem. It holds two functions\n`f : E → F` and `g : E → G` (named `leftFun` and `rightFun`) and a point `a` (named `pt`) such that\n\n* both functions are strictly differentiable at `a`;\n* the derivatives are surjective;\n* the kernels of the derivatives are complementary subspaces of `E`. -/\nstructure ImplicitFunctionData (𝕜 : Type*) [NontriviallyNormedField 𝕜] (E : Type*)\n    [NormedAddCommGroup E] [NormedSpace 𝕜 E] [CompleteSpace E] (F : Type*) [NormedAddCommGroup F]\n    [NormedSpace 𝕜 F] [CompleteSpace F] (G : Type*) [NormedAddCommGroup G] [NormedSpace 𝕜 G]\n    [CompleteSpace G] where\n  leftFun : E → F\n  leftDeriv : E →L[𝕜] F\n  rightFun : E → G\n  rightDeriv : E →L[𝕜] G\n  pt : E\n  left_has_deriv : HasStrictFDerivAt leftFun leftDeriv pt\n  right_has_deriv : HasStrictFDerivAt rightFun rightDeriv pt\n  left_range : range leftDeriv = ⊤\n  right_range : range rightDeriv = ⊤\n  isCompl_ker : IsCompl (ker leftDeriv) (ker rightDeriv)\n\n"}
{"name":"ImplicitFunctionData.mk.inj","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"𝕜 : Type u_1\ninst✝⁹ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : NormedSpace 𝕜 E\ninst✝⁶ : CompleteSpace E\nF : Type u_3\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\ninst✝³ : CompleteSpace F\nG : Type u_4\ninst✝² : NormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : CompleteSpace G\nleftFun✝ : E → F\nleftDeriv✝ : ContinuousLinearMap (RingHom.id 𝕜) E F\nrightFun✝ : E → G\nrightDeriv✝ : ContinuousLinearMap (RingHom.id 𝕜) E G\npt✝ : E\nleft_has_deriv✝ : HasStrictFDerivAt leftFun✝ leftDeriv✝ pt✝\nright_has_deriv✝ : HasStrictFDerivAt rightFun✝ rightDeriv✝ pt✝\nleft_range✝ : Eq (LinearMap.range leftDeriv✝) Top.top\nright_range✝ : Eq (LinearMap.range rightDeriv✝) Top.top\nisCompl_ker✝ : IsCompl (LinearMap.ker leftDeriv✝) (LinearMap.ker rightDeriv✝)\nleftFun : E → F\nleftDeriv : ContinuousLinearMap (RingHom.id 𝕜) E F\nrightFun : E → G\nrightDeriv : ContinuousLinearMap (RingHom.id 𝕜) E G\npt : E\nleft_has_deriv : HasStrictFDerivAt leftFun leftDeriv pt\nright_has_deriv : HasStrictFDerivAt rightFun rightDeriv pt\nleft_range : Eq (LinearMap.range leftDeriv) Top.top\nright_range : Eq (LinearMap.range rightDeriv) Top.top\nisCompl_ker : IsCompl (LinearMap.ker leftDeriv) (LinearMap.ker rightDeriv)\nx✝ : Eq { leftFun := leftFun✝, leftDeriv := leftDeriv✝, rightFun := rightFun✝, rightDeriv := rightDeriv✝, pt := pt✝, left_has_deriv := left_has_deriv✝, right_has_deriv := right_has_deriv✝, left_range := left_range✝, right_range := right_range✝, isCompl_ker := isCompl_ker✝ } { leftFun := leftFun, leftDeriv := leftDeriv, rightFun := rightFun, rightDeriv := rightDeriv, pt := pt, left_has_deriv := left_has_deriv, right_has_deriv := right_has_deriv, left_range := left_range, right_range := right_range, isCompl_ker := isCompl_ker }\n⊢ And (Eq leftFun✝ leftFun) (And (Eq leftDeriv✝ leftDeriv) (And (Eq rightFun✝ rightFun) (And (Eq rightDeriv✝ rightDeriv) (Eq pt✝ pt))))","decl":"/-- Data for the general version of the implicit function theorem. It holds two functions\n`f : E → F` and `g : E → G` (named `leftFun` and `rightFun`) and a point `a` (named `pt`) such that\n\n* both functions are strictly differentiable at `a`;\n* the derivatives are surjective;\n* the kernels of the derivatives are complementary subspaces of `E`. -/\nstructure ImplicitFunctionData (𝕜 : Type*) [NontriviallyNormedField 𝕜] (E : Type*)\n    [NormedAddCommGroup E] [NormedSpace 𝕜 E] [CompleteSpace E] (F : Type*) [NormedAddCommGroup F]\n    [NormedSpace 𝕜 F] [CompleteSpace F] (G : Type*) [NormedAddCommGroup G] [NormedSpace 𝕜 G]\n    [CompleteSpace G] where\n  leftFun : E → F\n  leftDeriv : E →L[𝕜] F\n  rightFun : E → G\n  rightDeriv : E →L[𝕜] G\n  pt : E\n  left_has_deriv : HasStrictFDerivAt leftFun leftDeriv pt\n  right_has_deriv : HasStrictFDerivAt rightFun rightDeriv pt\n  left_range : range leftDeriv = ⊤\n  right_range : range rightDeriv = ⊤\n  isCompl_ker : IsCompl (ker leftDeriv) (ker rightDeriv)\n\n"}
{"name":"ImplicitFunctionData.prodFun_apply","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"𝕜 : Type u_1\ninst✝⁹ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : NormedSpace 𝕜 E\ninst✝⁶ : CompleteSpace E\nF : Type u_3\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\ninst✝³ : CompleteSpace F\nG : Type u_4\ninst✝² : NormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : CompleteSpace G\nφ : ImplicitFunctionData 𝕜 E F G\nx : E\n⊢ Eq (φ.prodFun x) { fst := φ.leftFun x, snd := φ.rightFun x }","decl":"@[simp]\ntheorem prodFun_apply (x : E) : φ.prodFun x = (φ.leftFun x, φ.rightFun x) :=\n  rfl\n\n"}
{"name":"ImplicitFunctionData.hasStrictFDerivAt","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"𝕜 : Type u_1\ninst✝⁹ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : NormedSpace 𝕜 E\ninst✝⁶ : CompleteSpace E\nF : Type u_3\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\ninst✝³ : CompleteSpace F\nG : Type u_4\ninst✝² : NormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : CompleteSpace G\nφ : ImplicitFunctionData 𝕜 E F G\n⊢ HasStrictFDerivAt φ.prodFun (↑(φ.leftDeriv.equivProdOfSurjectiveOfIsCompl φ.rightDeriv ⋯ ⋯ ⋯)) φ.pt","decl":"protected theorem hasStrictFDerivAt :\n    HasStrictFDerivAt φ.prodFun\n      (φ.leftDeriv.equivProdOfSurjectiveOfIsCompl φ.rightDeriv φ.left_range φ.right_range\n          φ.isCompl_ker :\n        E →L[𝕜] F × G)\n      φ.pt :=\n  φ.left_has_deriv.prod φ.right_has_deriv\n\n"}
{"name":"ImplicitFunctionData.toPartialHomeomorph_coe","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"𝕜 : Type u_1\ninst✝⁹ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : NormedSpace 𝕜 E\ninst✝⁶ : CompleteSpace E\nF : Type u_3\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\ninst✝³ : CompleteSpace F\nG : Type u_4\ninst✝² : NormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : CompleteSpace G\nφ : ImplicitFunctionData 𝕜 E F G\n⊢ Eq (↑φ.toPartialHomeomorph) φ.prodFun","decl":"@[simp]\ntheorem toPartialHomeomorph_coe : ⇑φ.toPartialHomeomorph = φ.prodFun :=\n  rfl\n\n"}
{"name":"ImplicitFunctionData.toPartialHomeomorph_apply","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"𝕜 : Type u_1\ninst✝⁹ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : NormedSpace 𝕜 E\ninst✝⁶ : CompleteSpace E\nF : Type u_3\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\ninst✝³ : CompleteSpace F\nG : Type u_4\ninst✝² : NormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : CompleteSpace G\nφ : ImplicitFunctionData 𝕜 E F G\nx : E\n⊢ Eq (↑φ.toPartialHomeomorph x) { fst := φ.leftFun x, snd := φ.rightFun x }","decl":"theorem toPartialHomeomorph_apply (x : E) : φ.toPartialHomeomorph x = (φ.leftFun x, φ.rightFun x) :=\n  rfl\n\n"}
{"name":"ImplicitFunctionData.pt_mem_toPartialHomeomorph_source","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"𝕜 : Type u_1\ninst✝⁹ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : NormedSpace 𝕜 E\ninst✝⁶ : CompleteSpace E\nF : Type u_3\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\ninst✝³ : CompleteSpace F\nG : Type u_4\ninst✝² : NormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : CompleteSpace G\nφ : ImplicitFunctionData 𝕜 E F G\n⊢ Membership.mem φ.toPartialHomeomorph.source φ.pt","decl":"theorem pt_mem_toPartialHomeomorph_source : φ.pt ∈ φ.toPartialHomeomorph.source :=\n  φ.hasStrictFDerivAt.mem_toPartialHomeomorph_source\n\n"}
{"name":"ImplicitFunctionData.map_pt_mem_toPartialHomeomorph_target","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"𝕜 : Type u_1\ninst✝⁹ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : NormedSpace 𝕜 E\ninst✝⁶ : CompleteSpace E\nF : Type u_3\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\ninst✝³ : CompleteSpace F\nG : Type u_4\ninst✝² : NormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : CompleteSpace G\nφ : ImplicitFunctionData 𝕜 E F G\n⊢ Membership.mem φ.toPartialHomeomorph.target { fst := φ.leftFun φ.pt, snd := φ.rightFun φ.pt }","decl":"theorem map_pt_mem_toPartialHomeomorph_target :\n    (φ.leftFun φ.pt, φ.rightFun φ.pt) ∈ φ.toPartialHomeomorph.target :=\n  φ.toPartialHomeomorph.map_source <| φ.pt_mem_toPartialHomeomorph_source\n\n"}
{"name":"ImplicitFunctionData.prod_map_implicitFunction","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"𝕜 : Type u_1\ninst✝⁹ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : NormedSpace 𝕜 E\ninst✝⁶ : CompleteSpace E\nF : Type u_3\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\ninst✝³ : CompleteSpace F\nG : Type u_4\ninst✝² : NormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : CompleteSpace G\nφ : ImplicitFunctionData 𝕜 E F G\n⊢ Filter.Eventually (fun p => Eq (φ.prodFun (φ.implicitFunction p.1 p.2)) p) (nhds (φ.prodFun φ.pt))","decl":"theorem prod_map_implicitFunction :\n    ∀ᶠ p : F × G in 𝓝 (φ.prodFun φ.pt), φ.prodFun (φ.implicitFunction p.1 p.2) = p :=\n  φ.hasStrictFDerivAt.eventually_right_inverse.mono fun ⟨_, _⟩ h => h\n\n"}
{"name":"ImplicitFunctionData.left_map_implicitFunction","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"𝕜 : Type u_1\ninst✝⁹ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : NormedSpace 𝕜 E\ninst✝⁶ : CompleteSpace E\nF : Type u_3\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\ninst✝³ : CompleteSpace F\nG : Type u_4\ninst✝² : NormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : CompleteSpace G\nφ : ImplicitFunctionData 𝕜 E F G\n⊢ Filter.Eventually (fun p => Eq (φ.leftFun (φ.implicitFunction p.1 p.2)) p.1) (nhds (φ.prodFun φ.pt))","decl":"theorem left_map_implicitFunction :\n    ∀ᶠ p : F × G in 𝓝 (φ.prodFun φ.pt), φ.leftFun (φ.implicitFunction p.1 p.2) = p.1 :=\n  φ.prod_map_implicitFunction.mono fun _ => congr_arg Prod.fst\n\n"}
{"name":"ImplicitFunctionData.right_map_implicitFunction","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"𝕜 : Type u_1\ninst✝⁹ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : NormedSpace 𝕜 E\ninst✝⁶ : CompleteSpace E\nF : Type u_3\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\ninst✝³ : CompleteSpace F\nG : Type u_4\ninst✝² : NormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : CompleteSpace G\nφ : ImplicitFunctionData 𝕜 E F G\n⊢ Filter.Eventually (fun p => Eq (φ.rightFun (φ.implicitFunction p.1 p.2)) p.2) (nhds (φ.prodFun φ.pt))","decl":"theorem right_map_implicitFunction :\n    ∀ᶠ p : F × G in 𝓝 (φ.prodFun φ.pt), φ.rightFun (φ.implicitFunction p.1 p.2) = p.2 :=\n  φ.prod_map_implicitFunction.mono fun _ => congr_arg Prod.snd\n\n"}
{"name":"ImplicitFunctionData.implicitFunction_apply_image","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"𝕜 : Type u_1\ninst✝⁹ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : NormedSpace 𝕜 E\ninst✝⁶ : CompleteSpace E\nF : Type u_3\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\ninst✝³ : CompleteSpace F\nG : Type u_4\ninst✝² : NormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : CompleteSpace G\nφ : ImplicitFunctionData 𝕜 E F G\n⊢ Filter.Eventually (fun x => Eq (φ.implicitFunction (φ.leftFun x) (φ.rightFun x)) x) (nhds φ.pt)","decl":"theorem implicitFunction_apply_image :\n    ∀ᶠ x in 𝓝 φ.pt, φ.implicitFunction (φ.leftFun x) (φ.rightFun x) = x :=\n  φ.hasStrictFDerivAt.eventually_left_inverse\n\n"}
{"name":"ImplicitFunctionData.map_nhds_eq","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"𝕜 : Type u_1\ninst✝⁹ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : NormedSpace 𝕜 E\ninst✝⁶ : CompleteSpace E\nF : Type u_3\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\ninst✝³ : CompleteSpace F\nG : Type u_4\ninst✝² : NormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : CompleteSpace G\nφ : ImplicitFunctionData 𝕜 E F G\n⊢ Eq (Filter.map φ.leftFun (nhds φ.pt)) (nhds (φ.leftFun φ.pt))","decl":"theorem map_nhds_eq : map φ.leftFun (𝓝 φ.pt) = 𝓝 (φ.leftFun φ.pt) :=\n  show map (Prod.fst ∘ φ.prodFun) (𝓝 φ.pt) = 𝓝 (φ.prodFun φ.pt).1 by\n    rw [← map_map, φ.hasStrictFDerivAt.map_nhds_eq_of_equiv, map_fst_nhds]\n\n"}
{"name":"ImplicitFunctionData.implicitFunction_hasStrictFDerivAt","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"𝕜 : Type u_1\ninst✝⁹ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : NormedSpace 𝕜 E\ninst✝⁶ : CompleteSpace E\nF : Type u_3\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\ninst✝³ : CompleteSpace F\nG : Type u_4\ninst✝² : NormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : CompleteSpace G\nφ : ImplicitFunctionData 𝕜 E F G\ng'inv : ContinuousLinearMap (RingHom.id 𝕜) G E\nhg'inv : Eq (φ.rightDeriv.comp g'inv) (ContinuousLinearMap.id 𝕜 G)\nhg'invf : Eq (φ.leftDeriv.comp g'inv) 0\n⊢ HasStrictFDerivAt (φ.implicitFunction (φ.leftFun φ.pt)) g'inv (φ.rightFun φ.pt)","decl":"theorem implicitFunction_hasStrictFDerivAt (g'inv : G →L[𝕜] E)\n    (hg'inv : φ.rightDeriv.comp g'inv = ContinuousLinearMap.id 𝕜 G)\n    (hg'invf : φ.leftDeriv.comp g'inv = 0) :\n    HasStrictFDerivAt (φ.implicitFunction (φ.leftFun φ.pt)) g'inv (φ.rightFun φ.pt) := by\n  have := φ.hasStrictFDerivAt.to_localInverse\n  simp only [prodFun] at this\n  convert this.comp (φ.rightFun φ.pt) ((hasStrictFDerivAt_const _ _).prod (hasStrictFDerivAt_id _))\n  -- Porting note: added parentheses to help `simp`\n  simp only [ContinuousLinearMap.ext_iff, (ContinuousLinearMap.comp_apply)] at hg'inv hg'invf ⊢\n  simp [ContinuousLinearEquiv.eq_symm_apply, *]\n\n"}
{"name":"HasStrictFDerivAt.implicitToPartialHomeomorphOfComplemented_fst","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : CompleteSpace E\nF : Type u_3\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\ninst✝ : CompleteSpace F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\na : E\nhf : HasStrictFDerivAt f f' a\nhf' : Eq (LinearMap.range f') Top.top\nhker : (LinearMap.ker f').ClosedComplemented\nx : E\n⊢ Eq (↑(HasStrictFDerivAt.implicitToPartialHomeomorphOfComplemented f f' hf hf' hker) x).1 (f x)","decl":"@[simp]\ntheorem implicitToPartialHomeomorphOfComplemented_fst (hf : HasStrictFDerivAt f f' a)\n    (hf' : range f' = ⊤) (hker : (ker f').ClosedComplemented) (x : E) :\n    (hf.implicitToPartialHomeomorphOfComplemented f f' hf' hker x).fst = f x :=\n  rfl\n\n"}
{"name":"HasStrictFDerivAt.implicitToPartialHomeomorphOfComplemented_apply","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : CompleteSpace E\nF : Type u_3\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\ninst✝ : CompleteSpace F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\na : E\nhf : HasStrictFDerivAt f f' a\nhf' : Eq (LinearMap.range f') Top.top\nhker : (LinearMap.ker f').ClosedComplemented\ny : E\n⊢ Eq (↑(HasStrictFDerivAt.implicitToPartialHomeomorphOfComplemented f f' hf hf' hker) y) { fst := f y, snd := (Classical.choose hker) (HSub.hSub y a) }","decl":"theorem implicitToPartialHomeomorphOfComplemented_apply (hf : HasStrictFDerivAt f f' a)\n    (hf' : range f' = ⊤) (hker : (ker f').ClosedComplemented) (y : E) :\n    hf.implicitToPartialHomeomorphOfComplemented f f' hf' hker y =\n      (f y, Classical.choose hker (y - a)) :=\n  rfl\n\n"}
{"name":"HasStrictFDerivAt.implicitToPartialHomeomorphOfComplemented_apply_ker","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : CompleteSpace E\nF : Type u_3\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\ninst✝ : CompleteSpace F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\na : E\nhf : HasStrictFDerivAt f f' a\nhf' : Eq (LinearMap.range f') Top.top\nhker : (LinearMap.ker f').ClosedComplemented\ny : Subtype fun x => Membership.mem (LinearMap.ker f') x\n⊢ Eq (↑(HasStrictFDerivAt.implicitToPartialHomeomorphOfComplemented f f' hf hf' hker) (HAdd.hAdd (↑y) a)) { fst := f (HAdd.hAdd (↑y) a), snd := y }","decl":"@[simp]\ntheorem implicitToPartialHomeomorphOfComplemented_apply_ker (hf : HasStrictFDerivAt f f' a)\n    (hf' : range f' = ⊤) (hker : (ker f').ClosedComplemented) (y : ker f') :\n    hf.implicitToPartialHomeomorphOfComplemented f f' hf' hker (y + a) = (f (y + a), y) := by\n  simp only [implicitToPartialHomeomorphOfComplemented_apply, add_sub_cancel_right,\n    Classical.choose_spec hker]\n\n"}
{"name":"HasStrictFDerivAt.implicitToPartialHomeomorphOfComplemented_self","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : CompleteSpace E\nF : Type u_3\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\ninst✝ : CompleteSpace F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\na : E\nhf : HasStrictFDerivAt f f' a\nhf' : Eq (LinearMap.range f') Top.top\nhker : (LinearMap.ker f').ClosedComplemented\n⊢ Eq (↑(HasStrictFDerivAt.implicitToPartialHomeomorphOfComplemented f f' hf hf' hker) a) { fst := f a, snd := 0 }","decl":"@[simp]\ntheorem implicitToPartialHomeomorphOfComplemented_self (hf : HasStrictFDerivAt f f' a)\n    (hf' : range f' = ⊤) (hker : (ker f').ClosedComplemented) :\n    hf.implicitToPartialHomeomorphOfComplemented f f' hf' hker a = (f a, 0) := by\n  simp [hf.implicitToPartialHomeomorphOfComplemented_apply]\n\n"}
{"name":"HasStrictFDerivAt.mem_implicitToPartialHomeomorphOfComplemented_source","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : CompleteSpace E\nF : Type u_3\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\ninst✝ : CompleteSpace F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\na : E\nhf : HasStrictFDerivAt f f' a\nhf' : Eq (LinearMap.range f') Top.top\nhker : (LinearMap.ker f').ClosedComplemented\n⊢ Membership.mem (HasStrictFDerivAt.implicitToPartialHomeomorphOfComplemented f f' hf hf' hker).source a","decl":"theorem mem_implicitToPartialHomeomorphOfComplemented_source (hf : HasStrictFDerivAt f f' a)\n    (hf' : range f' = ⊤) (hker : (ker f').ClosedComplemented) :\n    a ∈ (hf.implicitToPartialHomeomorphOfComplemented f f' hf' hker).source :=\n  ImplicitFunctionData.pt_mem_toPartialHomeomorph_source _\n\n"}
{"name":"HasStrictFDerivAt.mem_implicitToPartialHomeomorphOfComplemented_target","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : CompleteSpace E\nF : Type u_3\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\ninst✝ : CompleteSpace F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\na : E\nhf : HasStrictFDerivAt f f' a\nhf' : Eq (LinearMap.range f') Top.top\nhker : (LinearMap.ker f').ClosedComplemented\n⊢ Membership.mem (HasStrictFDerivAt.implicitToPartialHomeomorphOfComplemented f f' hf hf' hker).target { fst := f a, snd := 0 }","decl":"theorem mem_implicitToPartialHomeomorphOfComplemented_target (hf : HasStrictFDerivAt f f' a)\n    (hf' : range f' = ⊤) (hker : (ker f').ClosedComplemented) :\n    (f a, (0 : ker f')) ∈ (hf.implicitToPartialHomeomorphOfComplemented f f' hf' hker).target := by\n  simpa only [implicitToPartialHomeomorphOfComplemented_self] using\n    (hf.implicitToPartialHomeomorphOfComplemented f f' hf' hker).map_source <|\n      hf.mem_implicitToPartialHomeomorphOfComplemented_source hf' hker\n\n"}
{"name":"HasStrictFDerivAt.map_implicitFunctionOfComplemented_eq","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : CompleteSpace E\nF : Type u_3\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\ninst✝ : CompleteSpace F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\na : E\nhf : HasStrictFDerivAt f f' a\nhf' : Eq (LinearMap.range f') Top.top\nhker : (LinearMap.ker f').ClosedComplemented\n⊢ Filter.Eventually (fun p => Eq (f (HasStrictFDerivAt.implicitFunctionOfComplemented f f' hf hf' hker p.1 p.2)) p.1) (nhds { fst := f a, snd := 0 })","decl":"/-- `HasStrictFDerivAt.implicitFunctionOfComplemented` sends `(z, y)` to a point in `f ⁻¹' z`. -/\ntheorem map_implicitFunctionOfComplemented_eq (hf : HasStrictFDerivAt f f' a) (hf' : range f' = ⊤)\n    (hker : (ker f').ClosedComplemented) :\n    ∀ᶠ p : F × ker f' in 𝓝 (f a, 0),\n      f (hf.implicitFunctionOfComplemented f f' hf' hker p.1 p.2) = p.1 :=\n  ((hf.implicitToPartialHomeomorphOfComplemented f f' hf' hker).eventually_right_inverse <|\n        hf.mem_implicitToPartialHomeomorphOfComplemented_target hf' hker).mono\n    fun ⟨_, _⟩ h => congr_arg Prod.fst h\n\n"}
{"name":"HasStrictFDerivAt.eq_implicitFunctionOfComplemented","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : CompleteSpace E\nF : Type u_3\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\ninst✝ : CompleteSpace F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\na : E\nhf : HasStrictFDerivAt f f' a\nhf' : Eq (LinearMap.range f') Top.top\nhker : (LinearMap.ker f').ClosedComplemented\n⊢ Filter.Eventually (fun x => Eq (HasStrictFDerivAt.implicitFunctionOfComplemented f f' hf hf' hker (f x) (↑(HasStrictFDerivAt.implicitToPartialHomeomorphOfComplemented f f' hf hf' hker) x).2) x) (nhds a)","decl":"/-- Any point in some neighborhood of `a` can be represented as\n`HasStrictFDerivAt.implicitFunctionOfComplemented` of some point. -/\ntheorem eq_implicitFunctionOfComplemented (hf : HasStrictFDerivAt f f' a) (hf' : range f' = ⊤)\n    (hker : (ker f').ClosedComplemented) :\n    ∀ᶠ x in 𝓝 a, hf.implicitFunctionOfComplemented f f' hf' hker (f x)\n      (hf.implicitToPartialHomeomorphOfComplemented f f' hf' hker x).snd = x :=\n  (implicitFunctionDataOfComplemented f f' hf hf' hker).implicitFunction_apply_image\n\n"}
{"name":"HasStrictFDerivAt.implicitFunctionOfComplemented_apply_image","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : CompleteSpace E\nF : Type u_3\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\ninst✝ : CompleteSpace F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\na : E\nhf : HasStrictFDerivAt f f' a\nhf' : Eq (LinearMap.range f') Top.top\nhker : (LinearMap.ker f').ClosedComplemented\n⊢ Eq (HasStrictFDerivAt.implicitFunctionOfComplemented f f' hf hf' hker (f a) 0) a","decl":"@[simp]\ntheorem implicitFunctionOfComplemented_apply_image (hf : HasStrictFDerivAt f f' a)\n    (hf' : range f' = ⊤) (hker : (ker f').ClosedComplemented) :\n    hf.implicitFunctionOfComplemented f f' hf' hker (f a) 0 = a := by\n  simpa only [implicitToPartialHomeomorphOfComplemented_self] using\n      (hf.implicitToPartialHomeomorphOfComplemented f f' hf' hker).left_inv\n      (hf.mem_implicitToPartialHomeomorphOfComplemented_source hf' hker)\n\n"}
{"name":"HasStrictFDerivAt.to_implicitFunctionOfComplemented","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : CompleteSpace E\nF : Type u_3\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\ninst✝ : CompleteSpace F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\na : E\nhf : HasStrictFDerivAt f f' a\nhf' : Eq (LinearMap.range f') Top.top\nhker : (LinearMap.ker f').ClosedComplemented\n⊢ HasStrictFDerivAt (HasStrictFDerivAt.implicitFunctionOfComplemented f f' hf hf' hker (f a)) (LinearMap.ker f').subtypeL 0","decl":"theorem to_implicitFunctionOfComplemented (hf : HasStrictFDerivAt f f' a) (hf' : range f' = ⊤)\n    (hker : (ker f').ClosedComplemented) :\n    HasStrictFDerivAt (hf.implicitFunctionOfComplemented f f' hf' hker (f a))\n      (ker f').subtypeL 0 := by\n  convert (implicitFunctionDataOfComplemented f f' hf hf' hker).implicitFunction_hasStrictFDerivAt\n    (ker f').subtypeL _ _\n  swap\n  · ext\n    -- Porting note: added parentheses to help `simp`\n    simp only [Classical.choose_spec hker, implicitFunctionDataOfComplemented,\n      ContinuousLinearMap.comp_apply, Submodule.coe_subtypeL', Submodule.coe_subtype,\n      ContinuousLinearMap.id_apply]\n  swap\n  · ext\n    -- Porting note: added parentheses to help `simp`\n    simp only [(ContinuousLinearMap.comp_apply), Submodule.coe_subtypeL', Submodule.coe_subtype,\n      LinearMap.map_coe_ker, (ContinuousLinearMap.zero_apply)]\n  simp only [implicitFunctionDataOfComplemented, map_sub, sub_self]\n\n"}
{"name":"HasStrictFDerivAt.implicitToPartialHomeomorph_fst","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"𝕜 : Type u_1\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : CompleteSpace 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : CompleteSpace E\nF : Type u_3\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\ninst✝ : FiniteDimensional 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\na : E\nhf : HasStrictFDerivAt f f' a\nhf' : Eq (LinearMap.range f') Top.top\nx : E\n⊢ Eq (↑(HasStrictFDerivAt.implicitToPartialHomeomorph f f' hf hf') x).1 (f x)","decl":"@[simp]\ntheorem implicitToPartialHomeomorph_fst (hf : HasStrictFDerivAt f f' a) (hf' : range f' = ⊤)\n    (x : E) : (hf.implicitToPartialHomeomorph f f' hf' x).fst = f x :=\n  rfl\n\n"}
{"name":"HasStrictFDerivAt.implicitToPartialHomeomorph_apply_ker","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"𝕜 : Type u_1\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : CompleteSpace 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : CompleteSpace E\nF : Type u_3\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\ninst✝ : FiniteDimensional 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\na : E\nhf : HasStrictFDerivAt f f' a\nhf' : Eq (LinearMap.range f') Top.top\ny : Subtype fun x => Membership.mem (LinearMap.ker f') x\n⊢ Eq (↑(HasStrictFDerivAt.implicitToPartialHomeomorph f f' hf hf') (HAdd.hAdd (↑y) a)) { fst := f (HAdd.hAdd (↑y) a), snd := y }","decl":"@[simp]\ntheorem implicitToPartialHomeomorph_apply_ker (hf : HasStrictFDerivAt f f' a) (hf' : range f' = ⊤)\n    (y : ker f') : hf.implicitToPartialHomeomorph f f' hf' (y + a) = (f (y + a), y) :=\n  -- Porting note: had to add `haveI` (here and below)\n  haveI := FiniteDimensional.complete 𝕜 F\n  implicitToPartialHomeomorphOfComplemented_apply_ker ..\n\n"}
{"name":"HasStrictFDerivAt.implicitToPartialHomeomorph_self","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"𝕜 : Type u_1\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : CompleteSpace 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : CompleteSpace E\nF : Type u_3\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\ninst✝ : FiniteDimensional 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\na : E\nhf : HasStrictFDerivAt f f' a\nhf' : Eq (LinearMap.range f') Top.top\n⊢ Eq (↑(HasStrictFDerivAt.implicitToPartialHomeomorph f f' hf hf') a) { fst := f a, snd := 0 }","decl":"@[simp]\ntheorem implicitToPartialHomeomorph_self (hf : HasStrictFDerivAt f f' a) (hf' : range f' = ⊤) :\n    hf.implicitToPartialHomeomorph f f' hf' a = (f a, 0) :=\n  haveI := FiniteDimensional.complete 𝕜 F\n  implicitToPartialHomeomorphOfComplemented_self ..\n\n"}
{"name":"HasStrictFDerivAt.mem_implicitToPartialHomeomorph_source","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"𝕜 : Type u_1\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : CompleteSpace 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : CompleteSpace E\nF : Type u_3\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\ninst✝ : FiniteDimensional 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\na : E\nhf : HasStrictFDerivAt f f' a\nhf' : Eq (LinearMap.range f') Top.top\n⊢ Membership.mem (HasStrictFDerivAt.implicitToPartialHomeomorph f f' hf hf').source a","decl":"theorem mem_implicitToPartialHomeomorph_source (hf : HasStrictFDerivAt f f' a)\n    (hf' : range f' = ⊤) : a ∈ (hf.implicitToPartialHomeomorph f f' hf').source :=\n  haveI := FiniteDimensional.complete 𝕜 F\n  ImplicitFunctionData.pt_mem_toPartialHomeomorph_source _\n\n"}
{"name":"HasStrictFDerivAt.mem_implicitToPartialHomeomorph_target","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"𝕜 : Type u_1\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : CompleteSpace 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : CompleteSpace E\nF : Type u_3\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\ninst✝ : FiniteDimensional 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\na : E\nhf : HasStrictFDerivAt f f' a\nhf' : Eq (LinearMap.range f') Top.top\n⊢ Membership.mem (HasStrictFDerivAt.implicitToPartialHomeomorph f f' hf hf').target { fst := f a, snd := 0 }","decl":"theorem mem_implicitToPartialHomeomorph_target (hf : HasStrictFDerivAt f f' a)\n    (hf' : range f' = ⊤) : (f a, (0 : ker f')) ∈ (hf.implicitToPartialHomeomorph f f' hf').target :=\n  haveI := FiniteDimensional.complete 𝕜 F\n  mem_implicitToPartialHomeomorphOfComplemented_target ..\n\n"}
{"name":"HasStrictFDerivAt.tendsto_implicitFunction","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"𝕜 : Type u_1\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : CompleteSpace 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : CompleteSpace E\nF : Type u_3\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\ninst✝ : FiniteDimensional 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\na : E\nhf : HasStrictFDerivAt f f' a\nhf' : Eq (LinearMap.range f') Top.top\nα : Type u_4\nl : Filter α\ng₁ : α → F\ng₂ : α → Subtype fun x => Membership.mem (LinearMap.ker f') x\nh₁ : Filter.Tendsto g₁ l (nhds (f a))\nh₂ : Filter.Tendsto g₂ l (nhds 0)\n⊢ Filter.Tendsto (fun t => HasStrictFDerivAt.implicitFunction f f' hf hf' (g₁ t) (g₂ t)) l (nhds a)","decl":"theorem tendsto_implicitFunction (hf : HasStrictFDerivAt f f' a) (hf' : range f' = ⊤) {α : Type*}\n    {l : Filter α} {g₁ : α → F} {g₂ : α → ker f'} (h₁ : Tendsto g₁ l (𝓝 <| f a))\n    (h₂ : Tendsto g₂ l (𝓝 0)) :\n    Tendsto (fun t => hf.implicitFunction f f' hf' (g₁ t) (g₂ t)) l (𝓝 a) := by\n  refine ((hf.implicitToPartialHomeomorph f f' hf').tendsto_symm\n    (hf.mem_implicitToPartialHomeomorph_source hf')).comp ?_\n  rw [implicitToPartialHomeomorph_self]\n  exact h₁.prod_mk_nhds h₂\n\n"}
{"name":"Filter.Tendsto.implicitFunction","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"𝕜 : Type u_1\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : CompleteSpace 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : CompleteSpace E\nF : Type u_3\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\ninst✝ : FiniteDimensional 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\na : E\nhf : HasStrictFDerivAt f f' a\nhf' : Eq (LinearMap.range f') Top.top\nα : Type u_4\nl : Filter α\ng₁ : α → F\ng₂ : α → Subtype fun x => Membership.mem (LinearMap.ker f') x\nh₁ : Filter.Tendsto g₁ l (nhds (f a))\nh₂ : Filter.Tendsto g₂ l (nhds 0)\n⊢ Filter.Tendsto (fun t => HasStrictFDerivAt.implicitFunction f f' hf hf' (g₁ t) (g₂ t)) l (nhds a)","decl":"alias _root_.Filter.Tendsto.implicitFunction := tendsto_implicitFunction\n\n"}
{"name":"HasStrictFDerivAt.map_implicitFunction_eq","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"𝕜 : Type u_1\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : CompleteSpace 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : CompleteSpace E\nF : Type u_3\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\ninst✝ : FiniteDimensional 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\na : E\nhf : HasStrictFDerivAt f f' a\nhf' : Eq (LinearMap.range f') Top.top\n⊢ Filter.Eventually (fun p => Eq (f (HasStrictFDerivAt.implicitFunction f f' hf hf' p.1 p.2)) p.1) (nhds { fst := f a, snd := 0 })","decl":"/-- `HasStrictFDerivAt.implicitFunction` sends `(z, y)` to a point in `f ⁻¹' z`. -/\ntheorem map_implicitFunction_eq (hf : HasStrictFDerivAt f f' a) (hf' : range f' = ⊤) :\n    ∀ᶠ p : F × ker f' in 𝓝 (f a, 0), f (hf.implicitFunction f f' hf' p.1 p.2) = p.1 :=\n  haveI := FiniteDimensional.complete 𝕜 F\n  map_implicitFunctionOfComplemented_eq ..\n\n"}
{"name":"HasStrictFDerivAt.implicitFunction_apply_image","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"𝕜 : Type u_1\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : CompleteSpace 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : CompleteSpace E\nF : Type u_3\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\ninst✝ : FiniteDimensional 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\na : E\nhf : HasStrictFDerivAt f f' a\nhf' : Eq (LinearMap.range f') Top.top\n⊢ Eq (HasStrictFDerivAt.implicitFunction f f' hf hf' (f a) 0) a","decl":"@[simp]\ntheorem implicitFunction_apply_image (hf : HasStrictFDerivAt f f' a) (hf' : range f' = ⊤) :\n    hf.implicitFunction f f' hf' (f a) 0 = a := by\n  haveI := FiniteDimensional.complete 𝕜 F\n  apply implicitFunctionOfComplemented_apply_image\n\n"}
{"name":"HasStrictFDerivAt.eq_implicitFunction","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"𝕜 : Type u_1\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : CompleteSpace 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : CompleteSpace E\nF : Type u_3\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\ninst✝ : FiniteDimensional 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\na : E\nhf : HasStrictFDerivAt f f' a\nhf' : Eq (LinearMap.range f') Top.top\n⊢ Filter.Eventually (fun x => Eq (HasStrictFDerivAt.implicitFunction f f' hf hf' (f x) (↑(HasStrictFDerivAt.implicitToPartialHomeomorph f f' hf hf') x).2) x) (nhds a)","decl":"/-- Any point in some neighborhood of `a` can be represented as `HasStrictFDerivAt.implicitFunction`\nof some point. -/\ntheorem eq_implicitFunction (hf : HasStrictFDerivAt f f' a) (hf' : range f' = ⊤) :\n    ∀ᶠ x in 𝓝 a,\n      hf.implicitFunction f f' hf' (f x) (hf.implicitToPartialHomeomorph f f' hf' x).snd = x :=\n  haveI := FiniteDimensional.complete 𝕜 F\n  eq_implicitFunctionOfComplemented ..\n\n"}
{"name":"HasStrictFDerivAt.to_implicitFunction","module":"Mathlib.Analysis.Calculus.Implicit","initialProofState":"𝕜 : Type u_1\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : CompleteSpace 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : CompleteSpace E\nF : Type u_3\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\ninst✝ : FiniteDimensional 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\na : E\nhf : HasStrictFDerivAt f f' a\nhf' : Eq (LinearMap.range f') Top.top\n⊢ HasStrictFDerivAt (HasStrictFDerivAt.implicitFunction f f' hf hf' (f a)) (LinearMap.ker f').subtypeL 0","decl":"theorem to_implicitFunction (hf : HasStrictFDerivAt f f' a) (hf' : range f' = ⊤) :\n    HasStrictFDerivAt (hf.implicitFunction f f' hf' (f a)) (ker f').subtypeL 0 :=\n  haveI := FiniteDimensional.complete 𝕜 F\n  to_implicitFunctionOfComplemented ..\n\n"}
