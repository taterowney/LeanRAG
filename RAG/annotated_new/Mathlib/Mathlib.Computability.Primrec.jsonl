{"name":"Nat.Primrec.brecOn","module":"Mathlib.Computability.Primrec","initialProofState":"motive✝ : (a : Nat → Nat) → Nat.Primrec a → Prop\na✝ : Nat → Nat\nx✝ : Nat.Primrec a✝\nih✝ : ∀ (a : Nat → Nat) (x : Nat.Primrec a), x.below → motive✝ a x\n⊢ motive✝ a✝ x✝","decl":"/-- The primitive recursive functions `ℕ → ℕ`. -/\nprotected inductive Primrec : (ℕ → ℕ) → Prop\n  | zero : Nat.Primrec fun _ => 0\n  | protected succ : Nat.Primrec succ\n  | left : Nat.Primrec fun n => n.unpair.1\n  | right : Nat.Primrec fun n => n.unpair.2\n  | pair {f g} : Nat.Primrec f → Nat.Primrec g → Nat.Primrec fun n => pair (f n) (g n)\n  | comp {f g} : Nat.Primrec f → Nat.Primrec g → Nat.Primrec fun n => f (g n)\n  | prec {f g} :\n      Nat.Primrec f →\n        Nat.Primrec g →\n          Nat.Primrec (unpaired fun z n => n.rec (f z) fun y IH => g <| pair z <| pair y IH)\n\n"}
{"name":"Nat.Primrec.of_eq","module":"Mathlib.Computability.Primrec","initialProofState":"f g : Nat → Nat\nhf : Nat.Primrec f\nH : ∀ (n : Nat), Eq (f n) (g n)\n⊢ Nat.Primrec g","decl":"theorem of_eq {f g : ℕ → ℕ} (hf : Nat.Primrec f) (H : ∀ n, f n = g n) : Nat.Primrec g :=\n  (funext H : f = g) ▸ hf\n\n"}
{"name":"Nat.Primrec.const","module":"Mathlib.Computability.Primrec","initialProofState":"n : Nat\n⊢ Nat.Primrec fun x => n","decl":"theorem const : ∀ n : ℕ, Nat.Primrec fun _ => n\n  | 0 => zero\n  | n + 1 => Primrec.succ.comp (const n)\n\n"}
{"name":"Nat.Primrec.id","module":"Mathlib.Computability.Primrec","initialProofState":"⊢ Nat.Primrec id","decl":"protected theorem id : Nat.Primrec id :=\n  (left.pair right).of_eq fun n => by simp\n\n"}
{"name":"Nat.Primrec.prec1","module":"Mathlib.Computability.Primrec","initialProofState":"f : Nat → Nat\nm : Nat\nhf : Nat.Primrec f\n⊢ Nat.Primrec fun n => Nat.rec m (fun y IH => f (Nat.pair y IH)) n","decl":"theorem prec1 {f} (m : ℕ) (hf : Nat.Primrec f) :\n    Nat.Primrec fun n => n.rec m fun y IH => f <| Nat.pair y IH :=\n  ((prec (const m) (hf.comp right)).comp (zero.pair Primrec.id)).of_eq fun n => by simp\n\n"}
{"name":"Nat.Primrec.casesOn1","module":"Mathlib.Computability.Primrec","initialProofState":"f : Nat → Nat\nm : Nat\nhf : Nat.Primrec f\n⊢ Nat.Primrec fun x => Nat.casesOn x m f","decl":"theorem casesOn1 {f} (m : ℕ) (hf : Nat.Primrec f) : Nat.Primrec (Nat.casesOn · m f) :=\n  (prec1 m (hf.comp left)).of_eq <| by simp\n\n-- Porting note: `Nat.Primrec.casesOn` is already declared as a recursor.\n"}
{"name":"Nat.Primrec.casesOn'","module":"Mathlib.Computability.Primrec","initialProofState":"f g : Nat → Nat\nhf : Nat.Primrec f\nhg : Nat.Primrec g\n⊢ Nat.Primrec (Nat.unpaired fun z n => Nat.casesOn n (f z) fun y => g (Nat.pair z y))","decl":"theorem casesOn' {f g} (hf : Nat.Primrec f) (hg : Nat.Primrec g) :\n    Nat.Primrec (unpaired fun z n => n.casesOn (f z) fun y => g <| Nat.pair z y) :=\n  (prec hf (hg.comp (pair left (left.comp right)))).of_eq fun n => by simp\n\n"}
{"name":"Nat.Primrec.swap","module":"Mathlib.Computability.Primrec","initialProofState":"⊢ Nat.Primrec (Nat.unpaired (Function.swap Nat.pair))","decl":"protected theorem swap : Nat.Primrec (unpaired (swap Nat.pair)) :=\n  (pair right left).of_eq fun n => by simp\n\n"}
{"name":"Nat.Primrec.swap'","module":"Mathlib.Computability.Primrec","initialProofState":"f : Nat → Nat → Nat\nhf : Nat.Primrec (Nat.unpaired f)\n⊢ Nat.Primrec (Nat.unpaired (Function.swap f))","decl":"theorem swap' {f} (hf : Nat.Primrec (unpaired f)) : Nat.Primrec (unpaired (swap f)) :=\n  (hf.comp .swap).of_eq fun n => by simp\n\n"}
{"name":"Nat.Primrec.pred","module":"Mathlib.Computability.Primrec","initialProofState":"⊢ Nat.Primrec Nat.pred","decl":"theorem pred : Nat.Primrec pred :=\n  (casesOn1 0 Primrec.id).of_eq fun n => by cases n <;> simp [*]\n\n"}
{"name":"Nat.Primrec.add","module":"Mathlib.Computability.Primrec","initialProofState":"⊢ Nat.Primrec (Nat.unpaired fun x1 x2 => HAdd.hAdd x1 x2)","decl":"theorem add : Nat.Primrec (unpaired (· + ·)) :=\n  (prec .id ((Primrec.succ.comp right).comp right)).of_eq fun p => by\n    simp; induction p.unpair.2 <;> simp [*, Nat.add_assoc]\n\n"}
{"name":"Nat.Primrec.sub","module":"Mathlib.Computability.Primrec","initialProofState":"⊢ Nat.Primrec (Nat.unpaired fun x1 x2 => HSub.hSub x1 x2)","decl":"theorem sub : Nat.Primrec (unpaired (· - ·)) :=\n  (prec .id ((pred.comp right).comp right)).of_eq fun p => by\n    simp; induction p.unpair.2 <;> simp [*, Nat.sub_add_eq]\n\n"}
{"name":"Nat.Primrec.mul","module":"Mathlib.Computability.Primrec","initialProofState":"⊢ Nat.Primrec (Nat.unpaired fun x1 x2 => HMul.hMul x1 x2)","decl":"theorem mul : Nat.Primrec (unpaired (· * ·)) :=\n  (prec zero (add.comp (pair left (right.comp right)))).of_eq fun p => by\n    simp; induction p.unpair.2 <;> simp [*, mul_succ, add_comm _ (unpair p).fst]\n\n"}
{"name":"Nat.Primrec.pow","module":"Mathlib.Computability.Primrec","initialProofState":"⊢ Nat.Primrec (Nat.unpaired fun x1 x2 => HPow.hPow x1 x2)","decl":"theorem pow : Nat.Primrec (unpaired (· ^ ·)) :=\n  (prec (const 1) (mul.comp (pair (right.comp right) left))).of_eq fun p => by\n    simp; induction p.unpair.2 <;> simp [*, Nat.pow_succ]\n\n"}
{"name":"Primcodable.prim","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nself : Primcodable α\n⊢ Nat.Primrec fun n => Encodable.encode (Encodable.decode n)","decl":"/-- A `Primcodable` type is an `Encodable` type for which\n  the encode/decode functions are primitive recursive. -/\nclass Primcodable (α : Type*) extends Encodable α where\n  -- Porting note: was `prim [] `.\n  -- This means that `prim` does not take the type explicitly in Lean 4\n  prim : Nat.Primrec fun n => Encodable.encode (decode n)\n\n"}
{"name":"Primrec.encode","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\n⊢ Primrec Encodable.encode","decl":"protected theorem encode : Primrec (@encode α _) :=\n  (@Primcodable.prim α _).of_eq fun n => by cases @decode α _ n <;> rfl\n\n"}
{"name":"Primrec.decode","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\n⊢ Primrec Encodable.decode","decl":"protected theorem decode : Primrec (@decode α _) :=\n  Nat.Primrec.succ.comp (@Primcodable.prim α _)\n\n"}
{"name":"Primrec.dom_denumerable","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_4\nβ : Type u_5\ninst✝¹ : Denumerable α\ninst✝ : Primcodable β\nf : α → β\n⊢ Iff (Primrec f) (Nat.Primrec fun n => Encodable.encode (f (Denumerable.ofNat α n)))","decl":"theorem dom_denumerable {α β} [Denumerable α] [Primcodable β] {f : α → β} :\n    Primrec f ↔ Nat.Primrec fun n => encode (f (ofNat α n)) :=\n  ⟨fun h => (pred.comp h).of_eq fun n => by simp, fun h =>\n    (Nat.Primrec.succ.comp h).of_eq fun n => by simp⟩\n\n"}
{"name":"Primrec.nat_iff","module":"Mathlib.Computability.Primrec","initialProofState":"f : Nat → Nat\n⊢ Iff (Primrec f) (Nat.Primrec f)","decl":"theorem nat_iff {f : ℕ → ℕ} : Primrec f ↔ Nat.Primrec f :=\n  dom_denumerable\n\n"}
{"name":"Primrec.encdec","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\n⊢ Primrec fun n => Encodable.encode (Encodable.decode n)","decl":"theorem encdec : Primrec fun n => encode (@decode α _ n) :=\n  nat_iff.2 Primcodable.prim\n\n"}
{"name":"Primrec.option_some","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\n⊢ Primrec Option.some","decl":"theorem option_some : Primrec (@some α) :=\n  ((casesOn1 0 (Nat.Primrec.succ.comp .succ)).comp (@Primcodable.prim α _)).of_eq fun n => by\n    cases @decode α _ n <;> simp\n\n"}
{"name":"Primrec.of_eq","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nσ : Type u_3\ninst✝¹ : Primcodable α\ninst✝ : Primcodable σ\nf g : α → σ\nhf : Primrec f\nH : ∀ (n : α), Eq (f n) (g n)\n⊢ Primrec g","decl":"theorem of_eq {f g : α → σ} (hf : Primrec f) (H : ∀ n, f n = g n) : Primrec g :=\n  (funext H : f = g) ▸ hf\n\n"}
{"name":"Primrec.const","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nσ : Type u_3\ninst✝¹ : Primcodable α\ninst✝ : Primcodable σ\nx : σ\n⊢ Primrec fun x_1 => x","decl":"theorem const (x : σ) : Primrec fun _ : α => x :=\n  ((casesOn1 0 (.const (encode x).succ)).comp (@Primcodable.prim α _)).of_eq fun n => by\n    cases @decode α _ n <;> rfl\n\n"}
{"name":"Primrec.id","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\n⊢ Primrec id","decl":"protected theorem id : Primrec (@id α) :=\n  (@Primcodable.prim α).of_eq <| by simp\n\n"}
{"name":"Primrec.comp","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nβ : Type u_2\nσ : Type u_3\ninst✝² : Primcodable α\ninst✝¹ : Primcodable β\ninst✝ : Primcodable σ\nf : β → σ\ng : α → β\nhf : Primrec f\nhg : Primrec g\n⊢ Primrec fun a => f (g a)","decl":"theorem comp {f : β → σ} {g : α → β} (hf : Primrec f) (hg : Primrec g) : Primrec fun a => f (g a) :=\n  ((casesOn1 0 (.comp hf (pred.comp hg))).comp (@Primcodable.prim α _)).of_eq fun n => by\n    cases @decode α _ n <;> simp [encodek]\n\n"}
{"name":"Primrec.succ","module":"Mathlib.Computability.Primrec","initialProofState":"⊢ Primrec Nat.succ","decl":"theorem succ : Primrec Nat.succ :=\n  nat_iff.2 Nat.Primrec.succ\n\n"}
{"name":"Primrec.pred","module":"Mathlib.Computability.Primrec","initialProofState":"⊢ Primrec Nat.pred","decl":"theorem pred : Primrec Nat.pred :=\n  nat_iff.2 Nat.Primrec.pred\n\n"}
{"name":"Primrec.encode_iff","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nσ : Type u_3\ninst✝¹ : Primcodable α\ninst✝ : Primcodable σ\nf : α → σ\n⊢ Iff (Primrec fun a => Encodable.encode (f a)) (Primrec f)","decl":"theorem encode_iff {f : α → σ} : (Primrec fun a => encode (f a)) ↔ Primrec f :=\n  ⟨fun h => Nat.Primrec.of_eq h fun n => by cases @decode α _ n <;> rfl, Primrec.encode.comp⟩\n\n"}
{"name":"Primrec.ofNat_iff","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_4\nβ : Type u_5\ninst✝¹ : Denumerable α\ninst✝ : Primcodable β\nf : α → β\n⊢ Iff (Primrec f) (Primrec fun n => f (Denumerable.ofNat α n))","decl":"theorem ofNat_iff {α β} [Denumerable α] [Primcodable β] {f : α → β} :\n    Primrec f ↔ Primrec fun n => f (ofNat α n) :=\n  dom_denumerable.trans <| nat_iff.symm.trans encode_iff\n\n"}
{"name":"Primrec.ofNat","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_4\ninst✝ : Denumerable α\n⊢ Primrec (Denumerable.ofNat α)","decl":"protected theorem ofNat (α) [Denumerable α] : Primrec (ofNat α) :=\n  ofNat_iff.1 Primrec.id\n\n"}
{"name":"Primrec.option_some_iff","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nσ : Type u_3\ninst✝¹ : Primcodable α\ninst✝ : Primcodable σ\nf : α → σ\n⊢ Iff (Primrec fun a => Option.some (f a)) (Primrec f)","decl":"theorem option_some_iff {f : α → σ} : (Primrec fun a => some (f a)) ↔ Primrec f :=\n  ⟨fun h => encode_iff.1 <| pred.comp <| encode_iff.2 h, option_some.comp⟩\n\n"}
{"name":"Primrec.of_equiv","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\nβ : Type u_4\ne : Equiv β α\n⊢ Primrec ⇑e","decl":"theorem of_equiv {β} {e : β ≃ α} :\n    haveI := Primcodable.ofEquiv α e\n    Primrec e :=\n  letI : Primcodable β := Primcodable.ofEquiv α e\n  encode_iff.1 Primrec.encode\n\n"}
{"name":"Primrec.of_equiv_symm","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\nβ : Type u_4\ne : Equiv β α\n⊢ Primrec ⇑e.symm","decl":"theorem of_equiv_symm {β} {e : β ≃ α} :\n    haveI := Primcodable.ofEquiv α e\n    Primrec e.symm :=\n  letI := Primcodable.ofEquiv α e\n  encode_iff.1 (show Primrec fun a => encode (e (e.symm a)) by simp [Primrec.encode])\n\n"}
{"name":"Primrec.of_equiv_iff","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nσ : Type u_3\ninst✝¹ : Primcodable α\ninst✝ : Primcodable σ\nβ : Type u_4\ne : Equiv β α\nf : σ → β\n⊢ Iff (Primrec fun a => e (f a)) (Primrec f)","decl":"theorem of_equiv_iff {β} (e : β ≃ α) {f : σ → β} :\n    haveI := Primcodable.ofEquiv α e\n    (Primrec fun a => e (f a)) ↔ Primrec f :=\n  letI := Primcodable.ofEquiv α e\n  ⟨fun h => (of_equiv_symm.comp h).of_eq fun a => by simp, of_equiv.comp⟩\n\n"}
{"name":"Primrec.of_equiv_symm_iff","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nσ : Type u_3\ninst✝¹ : Primcodable α\ninst✝ : Primcodable σ\nβ : Type u_4\ne : Equiv β α\nf : σ → α\n⊢ Iff (Primrec fun a => e.symm (f a)) (Primrec f)","decl":"theorem of_equiv_symm_iff {β} (e : β ≃ α) {f : σ → α} :\n    haveI := Primcodable.ofEquiv α e\n    (Primrec fun a => e.symm (f a)) ↔ Primrec f :=\n  letI := Primcodable.ofEquiv α e\n  ⟨fun h => (of_equiv.comp h).of_eq fun a => by simp, of_equiv_symm.comp⟩\n\n"}
{"name":"Primrec.fst","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Primcodable α\ninst✝ : Primcodable β\n⊢ Primrec Prod.fst","decl":"theorem fst {α β} [Primcodable α] [Primcodable β] : Primrec (@Prod.fst α β) :=\n  ((casesOn' zero\n            ((casesOn' zero (Nat.Primrec.succ.comp left)).comp\n              (pair right ((@Primcodable.prim β).comp left)))).comp\n        (pair right ((@Primcodable.prim α).comp left))).of_eq\n    fun n => by\n    simp only [Nat.unpaired, Nat.unpair_pair, decode_prod_val]\n    cases @decode α _ n.unpair.1 <;> simp\n    cases @decode β _ n.unpair.2 <;> simp\n\n"}
{"name":"Primrec.snd","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Primcodable α\ninst✝ : Primcodable β\n⊢ Primrec Prod.snd","decl":"theorem snd {α β} [Primcodable α] [Primcodable β] : Primrec (@Prod.snd α β) :=\n  ((casesOn' zero\n            ((casesOn' zero (Nat.Primrec.succ.comp right)).comp\n              (pair right ((@Primcodable.prim β).comp left)))).comp\n        (pair right ((@Primcodable.prim α).comp left))).of_eq\n    fun n => by\n    simp only [Nat.unpaired, Nat.unpair_pair, decode_prod_val]\n    cases @decode α _ n.unpair.1 <;> simp\n    cases @decode β _ n.unpair.2 <;> simp\n\n"}
{"name":"Primrec.pair","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : Primcodable α\ninst✝¹ : Primcodable β\ninst✝ : Primcodable γ\nf : α → β\ng : α → γ\nhf : Primrec f\nhg : Primrec g\n⊢ Primrec fun a => { fst := f a, snd := g a }","decl":"theorem pair {α β γ} [Primcodable α] [Primcodable β] [Primcodable γ] {f : α → β} {g : α → γ}\n    (hf : Primrec f) (hg : Primrec g) : Primrec fun a => (f a, g a) :=\n  ((casesOn1 0\n            (Nat.Primrec.succ.comp <|\n              .pair (Nat.Primrec.pred.comp hf) (Nat.Primrec.pred.comp hg))).comp\n        (@Primcodable.prim α _)).of_eq\n    fun n => by cases @decode α _ n <;> simp [encodek]\n\n"}
{"name":"Primrec.unpair","module":"Mathlib.Computability.Primrec","initialProofState":"⊢ Primrec Nat.unpair","decl":"theorem unpair : Primrec Nat.unpair :=\n  (pair (nat_iff.2 .left) (nat_iff.2 .right)).of_eq fun n => by simp\n\n"}
{"name":"Primrec.list_get?₁","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\nl : List α\n⊢ Primrec l.get?","decl":"theorem list_get?₁ : ∀ l : List α, Primrec l.get?\n  | [] => dom_denumerable.2 zero\n  | a :: l =>\n    dom_denumerable.2 <|\n      (casesOn1 (encode a).succ <| dom_denumerable.1 <| list_get?₁ l).of_eq fun n => by\n        cases n <;> simp\n\n"}
{"name":"Primrec₂.mk","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nβ : Type u_2\nσ : Type u_3\ninst✝² : Primcodable α\ninst✝¹ : Primcodable β\ninst✝ : Primcodable σ\nf : α → β → σ\nhf : Primrec fun p => f p.1 p.2\n⊢ Primrec₂ f","decl":"theorem mk {f : α → β → σ} (hf : Primrec fun p : α × β => f p.1 p.2) : Primrec₂ f := hf\n\n"}
{"name":"Primrec₂.of_eq","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nβ : Type u_2\nσ : Type u_3\ninst✝² : Primcodable α\ninst✝¹ : Primcodable β\ninst✝ : Primcodable σ\nf g : α → β → σ\nhg : Primrec₂ f\nH : ∀ (a : α) (b : β), Eq (f a b) (g a b)\n⊢ Primrec₂ g","decl":"theorem of_eq {f g : α → β → σ} (hg : Primrec₂ f) (H : ∀ a b, f a b = g a b) : Primrec₂ g :=\n  (by funext a b; apply H : f = g) ▸ hg\n\n"}
{"name":"Primrec₂.const","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nβ : Type u_2\nσ : Type u_3\ninst✝² : Primcodable α\ninst✝¹ : Primcodable β\ninst✝ : Primcodable σ\nx : σ\n⊢ Primrec₂ fun x_1 x_2 => x","decl":"theorem const (x : σ) : Primrec₂ fun (_ : α) (_ : β) => x :=\n  Primrec.const _\n\n"}
{"name":"Primrec₂.pair","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Primcodable α\ninst✝ : Primcodable β\n⊢ Primrec₂ Prod.mk","decl":"protected theorem pair : Primrec₂ (@Prod.mk α β) :=\n  Primrec.pair .fst .snd\n\n"}
{"name":"Primrec₂.left","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Primcodable α\ninst✝ : Primcodable β\n⊢ Primrec₂ fun a x => a","decl":"theorem left : Primrec₂ fun (a : α) (_ : β) => a :=\n  .fst\n\n"}
{"name":"Primrec₂.right","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Primcodable α\ninst✝ : Primcodable β\n⊢ Primrec₂ fun x b => b","decl":"theorem right : Primrec₂ fun (_ : α) (b : β) => b :=\n  .snd\n\n"}
{"name":"Primrec₂.natPair","module":"Mathlib.Computability.Primrec","initialProofState":"⊢ Primrec₂ Nat.pair","decl":"theorem natPair : Primrec₂ Nat.pair := by simp [Primrec₂, Primrec]; constructor\n\n"}
{"name":"Primrec₂.unpaired","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\nf : Nat → Nat → α\n⊢ Iff (Primrec (Nat.unpaired f)) (Primrec₂ f)","decl":"theorem unpaired {f : ℕ → ℕ → α} : Primrec (Nat.unpaired f) ↔ Primrec₂ f :=\n  ⟨fun h => by simpa using h.comp natPair, fun h => h.comp Primrec.unpair⟩\n\n"}
{"name":"Primrec₂.unpaired'","module":"Mathlib.Computability.Primrec","initialProofState":"f : Nat → Nat → Nat\n⊢ Iff (Nat.Primrec (Nat.unpaired f)) (Primrec₂ f)","decl":"theorem unpaired' {f : ℕ → ℕ → ℕ} : Nat.Primrec (Nat.unpaired f) ↔ Primrec₂ f :=\n  Primrec.nat_iff.symm.trans unpaired\n\n"}
{"name":"Primrec₂.encode_iff","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nβ : Type u_2\nσ : Type u_3\ninst✝² : Primcodable α\ninst✝¹ : Primcodable β\ninst✝ : Primcodable σ\nf : α → β → σ\n⊢ Iff (Primrec₂ fun a b => Encodable.encode (f a b)) (Primrec₂ f)","decl":"theorem encode_iff {f : α → β → σ} : (Primrec₂ fun a b => encode (f a b)) ↔ Primrec₂ f :=\n  Primrec.encode_iff\n\n"}
{"name":"Primrec₂.option_some_iff","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nβ : Type u_2\nσ : Type u_3\ninst✝² : Primcodable α\ninst✝¹ : Primcodable β\ninst✝ : Primcodable σ\nf : α → β → σ\n⊢ Iff (Primrec₂ fun a b => Option.some (f a b)) (Primrec₂ f)","decl":"theorem option_some_iff {f : α → β → σ} : (Primrec₂ fun a b => some (f a b)) ↔ Primrec₂ f :=\n  Primrec.option_some_iff\n\n"}
{"name":"Primrec₂.ofNat_iff","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_4\nβ : Type u_5\nσ : Type u_6\ninst✝² : Denumerable α\ninst✝¹ : Denumerable β\ninst✝ : Primcodable σ\nf : α → β → σ\n⊢ Iff (Primrec₂ f) (Primrec₂ fun m n => f (Denumerable.ofNat α m) (Denumerable.ofNat β n))","decl":"theorem ofNat_iff {α β σ} [Denumerable α] [Denumerable β] [Primcodable σ] {f : α → β → σ} :\n    Primrec₂ f ↔ Primrec₂ fun m n : ℕ => f (ofNat α m) (ofNat β n) :=\n  (Primrec.ofNat_iff.trans <| by simp).trans unpaired\n\n"}
{"name":"Primrec₂.uncurry","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nβ : Type u_2\nσ : Type u_3\ninst✝² : Primcodable α\ninst✝¹ : Primcodable β\ninst✝ : Primcodable σ\nf : α → β → σ\n⊢ Iff (Primrec (Function.uncurry f)) (Primrec₂ f)","decl":"theorem uncurry {f : α → β → σ} : Primrec (Function.uncurry f) ↔ Primrec₂ f := by\n  rw [show Function.uncurry f = fun p : α × β => f p.1 p.2 from funext fun ⟨a, b⟩ => rfl]; rfl\n\n"}
{"name":"Primrec₂.curry","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nβ : Type u_2\nσ : Type u_3\ninst✝² : Primcodable α\ninst✝¹ : Primcodable β\ninst✝ : Primcodable σ\nf : Prod α β → σ\n⊢ Iff (Primrec₂ (Function.curry f)) (Primrec f)","decl":"theorem curry {f : α × β → σ} : Primrec₂ (Function.curry f) ↔ Primrec f := by\n  rw [← uncurry, Function.uncurry_curry]\n\n"}
{"name":"Primrec.comp₂","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nσ : Type u_5\ninst✝³ : Primcodable α\ninst✝² : Primcodable β\ninst✝¹ : Primcodable γ\ninst✝ : Primcodable σ\nf : γ → σ\ng : α → β → γ\nhf : Primrec f\nhg : Primrec₂ g\n⊢ Primrec₂ fun a b => f (g a b)","decl":"theorem Primrec.comp₂ {f : γ → σ} {g : α → β → γ} (hf : Primrec f) (hg : Primrec₂ g) :\n    Primrec₂ fun a b => f (g a b) :=\n  hf.comp hg\n\n"}
{"name":"Primrec₂.comp","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nσ : Type u_5\ninst✝³ : Primcodable α\ninst✝² : Primcodable β\ninst✝¹ : Primcodable γ\ninst✝ : Primcodable σ\nf : β → γ → σ\ng : α → β\nh : α → γ\nhf : Primrec₂ f\nhg : Primrec g\nhh : Primrec h\n⊢ Primrec fun a => f (g a) (h a)","decl":"theorem Primrec₂.comp {f : β → γ → σ} {g : α → β} {h : α → γ} (hf : Primrec₂ f) (hg : Primrec g)\n    (hh : Primrec h) : Primrec fun a => f (g a) (h a) :=\n  Primrec.comp hf (hg.pair hh)\n\n"}
{"name":"Primrec₂.comp₂","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\nσ : Type u_5\ninst✝⁴ : Primcodable α\ninst✝³ : Primcodable β\ninst✝² : Primcodable γ\ninst✝¹ : Primcodable δ\ninst✝ : Primcodable σ\nf : γ → δ → σ\ng : α → β → γ\nh : α → β → δ\nhf : Primrec₂ f\nhg : Primrec₂ g\nhh : Primrec₂ h\n⊢ Primrec₂ fun a b => f (g a b) (h a b)","decl":"theorem Primrec₂.comp₂ {f : γ → δ → σ} {g : α → β → γ} {h : α → β → δ} (hf : Primrec₂ f)\n    (hg : Primrec₂ g) (hh : Primrec₂ h) : Primrec₂ fun a b => f (g a b) (h a b) :=\n  hf.comp hg hh\n\n"}
{"name":"PrimrecPred.comp","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : Primcodable α\ninst✝¹ : Primcodable β\np : β → Prop\ninst✝ : DecidablePred p\nf : α → β\na✝¹ : PrimrecPred p\na✝ : Primrec f\n⊢ PrimrecPred fun a => p (f a)","decl":"theorem PrimrecPred.comp {p : β → Prop} [DecidablePred p] {f : α → β} :\n    PrimrecPred p → Primrec f → PrimrecPred fun a => p (f a) :=\n  Primrec.comp\n\n"}
{"name":"PrimrecRel.comp","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝³ : Primcodable α\ninst✝² : Primcodable β\ninst✝¹ : Primcodable γ\nR : β → γ → Prop\ninst✝ : (a : β) → (b : γ) → Decidable (R a b)\nf : α → β\ng : α → γ\na✝² : PrimrecRel R\na✝¹ : Primrec f\na✝ : Primrec g\n⊢ PrimrecPred fun a => R (f a) (g a)","decl":"theorem PrimrecRel.comp {R : β → γ → Prop} [∀ a b, Decidable (R a b)] {f : α → β} {g : α → γ} :\n    PrimrecRel R → Primrec f → Primrec g → PrimrecPred fun a => R (f a) (g a) :=\n  Primrec₂.comp\n\n"}
{"name":"PrimrecRel.comp₂","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\ninst✝⁴ : Primcodable α\ninst✝³ : Primcodable β\ninst✝² : Primcodable γ\ninst✝¹ : Primcodable δ\nR : γ → δ → Prop\ninst✝ : (a : γ) → (b : δ) → Decidable (R a b)\nf : α → β → γ\ng : α → β → δ\na✝² : PrimrecRel R\na✝¹ : Primrec₂ f\na✝ : Primrec₂ g\n⊢ PrimrecRel fun a b => R (f a b) (g a b)","decl":"theorem PrimrecRel.comp₂ {R : γ → δ → Prop} [∀ a b, Decidable (R a b)] {f : α → β → γ}\n    {g : α → β → δ} :\n    PrimrecRel R → Primrec₂ f → Primrec₂ g → PrimrecRel fun a b => R (f a b) (g a b) :=\n  PrimrecRel.comp\n\n"}
{"name":"PrimrecPred.of_eq","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\ninst✝² : Primcodable α\np q : α → Prop\ninst✝¹ : DecidablePred p\ninst✝ : DecidablePred q\nhp : PrimrecPred p\nH : ∀ (a : α), Iff (p a) (q a)\n⊢ PrimrecPred q","decl":"theorem PrimrecPred.of_eq {α} [Primcodable α] {p q : α → Prop} [DecidablePred p] [DecidablePred q]\n    (hp : PrimrecPred p) (H : ∀ a, p a ↔ q a) : PrimrecPred q :=\n  Primrec.of_eq hp fun a => Bool.decide_congr (H a)\n\n"}
{"name":"PrimrecRel.of_eq","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Primcodable α\ninst✝² : Primcodable β\nr s : α → β → Prop\ninst✝¹ : (a : α) → (b : β) → Decidable (r a b)\ninst✝ : (a : α) → (b : β) → Decidable (s a b)\nhr : PrimrecRel r\nH : ∀ (a : α) (b : β), Iff (r a b) (s a b)\n⊢ PrimrecRel s","decl":"theorem PrimrecRel.of_eq {α β} [Primcodable α] [Primcodable β] {r s : α → β → Prop}\n    [∀ a b, Decidable (r a b)] [∀ a b, Decidable (s a b)] (hr : PrimrecRel r)\n    (H : ∀ a b, r a b ↔ s a b) : PrimrecRel s :=\n  Primrec₂.of_eq hr fun a b => Bool.decide_congr (H a b)\n\n"}
{"name":"Primrec₂.swap","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nβ : Type u_2\nσ : Type u_3\ninst✝² : Primcodable α\ninst✝¹ : Primcodable β\ninst✝ : Primcodable σ\nf : α → β → σ\nh : Primrec₂ f\n⊢ Primrec₂ (Function.swap f)","decl":"theorem swap {f : α → β → σ} (h : Primrec₂ f) : Primrec₂ (swap f) :=\n  h.comp₂ Primrec₂.right Primrec₂.left\n\n"}
{"name":"Primrec₂.nat_iff","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nβ : Type u_2\nσ : Type u_3\ninst✝² : Primcodable α\ninst✝¹ : Primcodable β\ninst✝ : Primcodable σ\nf : α → β → σ\n⊢ Iff (Primrec₂ f) (Nat.Primrec (Nat.unpaired fun m n => Encodable.encode ((Encodable.decode m).bind fun a => Option.map (f a) (Encodable.decode n))))","decl":"theorem nat_iff {f : α → β → σ} : Primrec₂ f ↔ Nat.Primrec\n    (.unpaired fun m n => encode <| (@decode α _ m).bind fun a => (@decode β _ n).map (f a)) := by\n  have :\n    ∀ (a : Option α) (b : Option β),\n      Option.map (fun p : α × β => f p.1 p.2)\n          (Option.bind a fun a : α => Option.map (Prod.mk a) b) =\n        Option.bind a fun a => Option.map (f a) b := fun a b => by\n          cases a <;> cases b <;> rfl\n  simp [Primrec₂, Primrec, this]\n\n"}
{"name":"Primrec₂.nat_iff'","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nβ : Type u_2\nσ : Type u_3\ninst✝² : Primcodable α\ninst✝¹ : Primcodable β\ninst✝ : Primcodable σ\nf : α → β → σ\n⊢ Iff (Primrec₂ f) (Primrec₂ fun m n => (Encodable.decode m).bind fun a => Option.map (f a) (Encodable.decode n))","decl":"theorem nat_iff' {f : α → β → σ} :\n    Primrec₂ f ↔\n      Primrec₂ fun m n : ℕ => (@decode α _ m).bind fun a => Option.map (f a) (@decode β _ n) :=\n  nat_iff.trans <| unpaired'.trans encode_iff\n\n"}
{"name":"Primrec.to₂","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nβ : Type u_2\nσ : Type u_3\ninst✝² : Primcodable α\ninst✝¹ : Primcodable β\ninst✝ : Primcodable σ\nf : Prod α β → σ\nhf : Primrec f\n⊢ Primrec₂ fun a b => f { fst := a, snd := b }","decl":"theorem to₂ {f : α × β → σ} (hf : Primrec f) : Primrec₂ fun a b => f (a, b) :=\n  hf.of_eq fun _ => rfl\n\n"}
{"name":"Primrec.nat_rec","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Primcodable α\ninst✝ : Primcodable β\nf : α → β\ng : α → Prod Nat β → β\nhf : Primrec f\nhg : Primrec₂ g\n⊢ Primrec₂ fun a n => Nat.rec (f a) (fun n IH => g a { fst := n, snd := IH }) n","decl":"theorem nat_rec {f : α → β} {g : α → ℕ × β → β} (hf : Primrec f) (hg : Primrec₂ g) :\n    Primrec₂ fun a (n : ℕ) => n.rec (motive := fun _ => β) (f a) fun n IH => g a (n, IH) :=\n  Primrec₂.nat_iff.2 <|\n    ((Nat.Primrec.casesOn' .zero <|\n              (Nat.Primrec.prec hf <|\n                    .comp hg <|\n                      Nat.Primrec.left.pair <|\n                        (Nat.Primrec.left.comp .right).pair <|\n                          Nat.Primrec.pred.comp <| Nat.Primrec.right.comp .right).comp <|\n                Nat.Primrec.right.pair <| Nat.Primrec.right.comp Nat.Primrec.left).comp <|\n          Nat.Primrec.id.pair <| (@Primcodable.prim α).comp Nat.Primrec.left).of_eq\n      fun n => by\n      simp only [Nat.unpaired, id_eq, Nat.unpair_pair, decode_prod_val, decode_nat,\n        Option.some_bind, Option.map_map, Option.map_some']\n      cases' @decode α _ n.unpair.1 with a; · rfl\n      simp only [Nat.pred_eq_sub_one, encode_some, Nat.succ_eq_add_one, encodek, Option.map_some',\n        Option.some_bind, Option.map_map]\n      induction' n.unpair.2 with m <;> simp [encodek]\n      simp [*, encodek]\n\n"}
{"name":"Primrec.nat_rec'","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Primcodable α\ninst✝ : Primcodable β\nf : α → Nat\ng : α → β\nh : α → Prod Nat β → β\nhf : Primrec f\nhg : Primrec g\nhh : Primrec₂ h\n⊢ Primrec fun a => Nat.rec (g a) (fun n IH => h a { fst := n, snd := IH }) (f a)","decl":"theorem nat_rec' {f : α → ℕ} {g : α → β} {h : α → ℕ × β → β}\n    (hf : Primrec f) (hg : Primrec g) (hh : Primrec₂ h) :\n    Primrec fun a => (f a).rec (motive := fun _ => β) (g a) fun n IH => h a (n, IH) :=\n  (nat_rec hg hh).comp .id hf\n\n"}
{"name":"Primrec.nat_rec₁","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\nf : Nat → α → α\na : α\nhf : Primrec₂ f\n⊢ Primrec fun t => Nat.rec a f t","decl":"theorem nat_rec₁ {f : ℕ → α → α} (a : α) (hf : Primrec₂ f) : Primrec (Nat.rec a f) :=\n  nat_rec' .id (const a) <| comp₂ hf Primrec₂.right\n\n"}
{"name":"Primrec.nat_casesOn'","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Primcodable α\ninst✝ : Primcodable β\nf : α → β\ng : α → Nat → β\nhf : Primrec f\nhg : Primrec₂ g\n⊢ Primrec₂ fun a n => Nat.casesOn n (f a) (g a)","decl":"theorem nat_casesOn' {f : α → β} {g : α → ℕ → β} (hf : Primrec f) (hg : Primrec₂ g) :\n    Primrec₂ fun a (n : ℕ) => (n.casesOn (f a) (g a) : β) :=\n  nat_rec hf <| hg.comp₂ Primrec₂.left <| comp₂ fst Primrec₂.right\n\n"}
{"name":"Primrec.nat_casesOn","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Primcodable α\ninst✝ : Primcodable β\nf : α → Nat\ng : α → β\nh : α → Nat → β\nhf : Primrec f\nhg : Primrec g\nhh : Primrec₂ h\n⊢ Primrec fun a => Nat.casesOn (f a) (g a) (h a)","decl":"theorem nat_casesOn {f : α → ℕ} {g : α → β} {h : α → ℕ → β} (hf : Primrec f) (hg : Primrec g)\n    (hh : Primrec₂ h) : Primrec fun a => ((f a).casesOn (g a) (h a) : β) :=\n  (nat_casesOn' hg hh).comp .id hf\n\n"}
{"name":"Primrec.nat_casesOn₁","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\nf : Nat → α\na : α\nhf : Primrec f\n⊢ Primrec fun n => Nat.casesOn n a f","decl":"theorem nat_casesOn₁ {f : ℕ → α} (a : α) (hf : Primrec f) :\n    Primrec (fun (n : ℕ) => (n.casesOn a f : α)) :=\n  nat_casesOn .id (const a) (comp₂ hf .right)\n\n"}
{"name":"Primrec.nat_iterate","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Primcodable α\ninst✝ : Primcodable β\nf : α → Nat\ng : α → β\nh : α → β → β\nhf : Primrec f\nhg : Primrec g\nhh : Primrec₂ h\n⊢ Primrec fun a => Nat.iterate (h a) (f a) (g a)","decl":"theorem nat_iterate {f : α → ℕ} {g : α → β} {h : α → β → β} (hf : Primrec f) (hg : Primrec g)\n    (hh : Primrec₂ h) : Primrec fun a => (h a)^[f a] (g a) :=\n  (nat_rec' hf hg (hh.comp₂ Primrec₂.left <| snd.comp₂ Primrec₂.right)).of_eq fun a => by\n    induction f a <;> simp [*, -Function.iterate_succ, Function.iterate_succ']\n\n"}
{"name":"Primrec.option_casesOn","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nβ : Type u_2\nσ : Type u_3\ninst✝² : Primcodable α\ninst✝¹ : Primcodable β\ninst✝ : Primcodable σ\no : α → Option β\nf : α → σ\ng : α → β → σ\nho : Primrec o\nhf : Primrec f\nhg : Primrec₂ g\n⊢ Primrec fun a => Option.casesOn (o a) (f a) (g a)","decl":"theorem option_casesOn {o : α → Option β} {f : α → σ} {g : α → β → σ} (ho : Primrec o)\n    (hf : Primrec f) (hg : Primrec₂ g) :\n    @Primrec _ σ _ _ fun a => Option.casesOn (o a) (f a) (g a) :=\n  encode_iff.1 <|\n    (nat_casesOn (encode_iff.2 ho) (encode_iff.2 hf) <|\n          pred.comp₂ <|\n            Primrec₂.encode_iff.2 <|\n              (Primrec₂.nat_iff'.1 hg).comp₂ ((@Primrec.encode α _).comp fst).to₂\n                Primrec₂.right).of_eq\n      fun a => by cases' o a with b <;> simp [encodek]\n\n"}
{"name":"Primrec.option_bind","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nβ : Type u_2\nσ : Type u_3\ninst✝² : Primcodable α\ninst✝¹ : Primcodable β\ninst✝ : Primcodable σ\nf : α → Option β\ng : α → β → Option σ\nhf : Primrec f\nhg : Primrec₂ g\n⊢ Primrec fun a => (f a).bind (g a)","decl":"theorem option_bind {f : α → Option β} {g : α → β → Option σ} (hf : Primrec f) (hg : Primrec₂ g) :\n    Primrec fun a => (f a).bind (g a) :=\n  (option_casesOn hf (const none) hg).of_eq fun a => by cases f a <;> rfl\n\n"}
{"name":"Primrec.option_bind₁","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nσ : Type u_3\ninst✝¹ : Primcodable α\ninst✝ : Primcodable σ\nf : α → Option σ\nhf : Primrec f\n⊢ Primrec fun o => o.bind f","decl":"theorem option_bind₁ {f : α → Option σ} (hf : Primrec f) : Primrec fun o => Option.bind o f :=\n  option_bind .id (hf.comp snd).to₂\n\n"}
{"name":"Primrec.option_map","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nβ : Type u_2\nσ : Type u_3\ninst✝² : Primcodable α\ninst✝¹ : Primcodable β\ninst✝ : Primcodable σ\nf : α → Option β\ng : α → β → σ\nhf : Primrec f\nhg : Primrec₂ g\n⊢ Primrec fun a => Option.map (g a) (f a)","decl":"theorem option_map {f : α → Option β} {g : α → β → σ} (hf : Primrec f) (hg : Primrec₂ g) :\n    Primrec fun a => (f a).map (g a) :=\n  (option_bind hf (option_some.comp₂ hg)).of_eq fun x => by cases f x <;> rfl\n\n"}
{"name":"Primrec.option_map₁","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nσ : Type u_3\ninst✝¹ : Primcodable α\ninst✝ : Primcodable σ\nf : α → σ\nhf : Primrec f\n⊢ Primrec (Option.map f)","decl":"theorem option_map₁ {f : α → σ} (hf : Primrec f) : Primrec (Option.map f) :=\n  option_map .id (hf.comp snd).to₂\n\n"}
{"name":"Primrec.option_iget","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\ninst✝¹ : Primcodable α\ninst✝ : Inhabited α\n⊢ Primrec Option.iget","decl":"theorem option_iget [Inhabited α] : Primrec (@Option.iget α _) :=\n  (option_casesOn .id (const <| @default α _) .right).of_eq fun o => by cases o <;> rfl\n\n"}
{"name":"Primrec.option_isSome","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\n⊢ Primrec Option.isSome","decl":"theorem option_isSome : Primrec (@Option.isSome α) :=\n  (option_casesOn .id (const false) (const true).to₂).of_eq fun o => by cases o <;> rfl\n\n"}
{"name":"Primrec.option_getD","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\n⊢ Primrec₂ Option.getD","decl":"theorem option_getD : Primrec₂ (@Option.getD α) :=\n  Primrec.of_eq (option_casesOn Primrec₂.left Primrec₂.right .right) fun ⟨o, a⟩ => by\n    cases o <;> rfl\n\n"}
{"name":"Primrec.bind_decode_iff","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nβ : Type u_2\nσ : Type u_3\ninst✝² : Primcodable α\ninst✝¹ : Primcodable β\ninst✝ : Primcodable σ\nf : α → β → Option σ\n⊢ Iff (Primrec₂ fun a n => (Encodable.decode n).bind (f a)) (Primrec₂ f)","decl":"theorem bind_decode_iff {f : α → β → Option σ} :\n    (Primrec₂ fun a n => (@decode β _ n).bind (f a)) ↔ Primrec₂ f :=\n  ⟨fun h => by simpa [encodek] using h.comp fst ((@Primrec.encode β _).comp snd), fun h =>\n    option_bind (Primrec.decode.comp snd) <| h.comp (fst.comp fst) snd⟩\n\n"}
{"name":"Primrec.map_decode_iff","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nβ : Type u_2\nσ : Type u_3\ninst✝² : Primcodable α\ninst✝¹ : Primcodable β\ninst✝ : Primcodable σ\nf : α → β → σ\n⊢ Iff (Primrec₂ fun a n => Option.map (f a) (Encodable.decode n)) (Primrec₂ f)","decl":"theorem map_decode_iff {f : α → β → σ} :\n    (Primrec₂ fun a n => (@decode β _ n).map (f a)) ↔ Primrec₂ f := by\n  simp only [Option.map_eq_bind]\n  exact bind_decode_iff.trans Primrec₂.option_some_iff\n\n"}
{"name":"Primrec.nat_add","module":"Mathlib.Computability.Primrec","initialProofState":"⊢ Primrec₂ fun x1 x2 => HAdd.hAdd x1 x2","decl":"theorem nat_add : Primrec₂ ((· + ·) : ℕ → ℕ → ℕ) :=\n  Primrec₂.unpaired'.1 Nat.Primrec.add\n\n"}
{"name":"Primrec.nat_sub","module":"Mathlib.Computability.Primrec","initialProofState":"⊢ Primrec₂ fun x1 x2 => HSub.hSub x1 x2","decl":"theorem nat_sub : Primrec₂ ((· - ·) : ℕ → ℕ → ℕ) :=\n  Primrec₂.unpaired'.1 Nat.Primrec.sub\n\n"}
{"name":"Primrec.nat_mul","module":"Mathlib.Computability.Primrec","initialProofState":"⊢ Primrec₂ fun x1 x2 => HMul.hMul x1 x2","decl":"theorem nat_mul : Primrec₂ ((· * ·) : ℕ → ℕ → ℕ) :=\n  Primrec₂.unpaired'.1 Nat.Primrec.mul\n\n"}
{"name":"Primrec.cond","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nσ : Type u_3\ninst✝¹ : Primcodable α\ninst✝ : Primcodable σ\nc : α → Bool\nf g : α → σ\nhc : Primrec c\nhf : Primrec f\nhg : Primrec g\n⊢ Primrec fun a => cond (c a) (f a) (g a)","decl":"theorem cond {c : α → Bool} {f : α → σ} {g : α → σ} (hc : Primrec c) (hf : Primrec f)\n    (hg : Primrec g) : Primrec fun a => bif (c a) then (f a) else (g a) :=\n  (nat_casesOn (encode_iff.2 hc) hg (hf.comp fst).to₂).of_eq fun a => by cases c a <;> rfl\n\n"}
{"name":"Primrec.ite","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nσ : Type u_3\ninst✝² : Primcodable α\ninst✝¹ : Primcodable σ\nc : α → Prop\ninst✝ : DecidablePred c\nf g : α → σ\nhc : PrimrecPred c\nhf : Primrec f\nhg : Primrec g\n⊢ Primrec fun a => ite (c a) (f a) (g a)","decl":"theorem ite {c : α → Prop} [DecidablePred c] {f : α → σ} {g : α → σ} (hc : PrimrecPred c)\n    (hf : Primrec f) (hg : Primrec g) : Primrec fun a => if c a then f a else g a := by\n  simpa [Bool.cond_decide] using cond hc hf hg\n\n"}
{"name":"Primrec.nat_le","module":"Mathlib.Computability.Primrec","initialProofState":"⊢ PrimrecRel fun x1 x2 => LE.le x1 x2","decl":"theorem nat_le : PrimrecRel ((· ≤ ·) : ℕ → ℕ → Prop) :=\n  (nat_casesOn nat_sub (const true) (const false).to₂).of_eq fun p => by\n    dsimp [swap]\n    cases' e : p.1 - p.2 with n\n    · simp [Nat.sub_eq_zero_iff_le.1 e]\n    · simp [not_le.2 (Nat.lt_of_sub_eq_succ e)]\n\n"}
{"name":"Primrec.nat_min","module":"Mathlib.Computability.Primrec","initialProofState":"⊢ Primrec₂ Min.min","decl":"theorem nat_min : Primrec₂ (@min ℕ _) :=\n  ite nat_le fst snd\n\n"}
{"name":"Primrec.nat_max","module":"Mathlib.Computability.Primrec","initialProofState":"⊢ Primrec₂ Max.max","decl":"theorem nat_max : Primrec₂ (@max ℕ _) :=\n  ite (nat_le.comp fst snd) snd fst\n\n"}
{"name":"Primrec.dom_bool","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\nf : Bool → α\n⊢ Primrec f","decl":"theorem dom_bool (f : Bool → α) : Primrec f :=\n  (cond .id (const (f true)) (const (f false))).of_eq fun b => by cases b <;> rfl\n\n"}
{"name":"Primrec.dom_bool₂","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\nf : Bool → Bool → α\n⊢ Primrec₂ f","decl":"theorem dom_bool₂ (f : Bool → Bool → α) : Primrec₂ f :=\n  (cond fst ((dom_bool (f true)).comp snd) ((dom_bool (f false)).comp snd)).of_eq fun ⟨a, b⟩ => by\n    cases a <;> rfl\n\n"}
{"name":"Primrec.not","module":"Mathlib.Computability.Primrec","initialProofState":"⊢ Primrec Bool.not","decl":"protected theorem not : Primrec not :=\n  dom_bool _\n\n"}
{"name":"Primrec.and","module":"Mathlib.Computability.Primrec","initialProofState":"⊢ Primrec₂ Bool.and","decl":"protected theorem and : Primrec₂ and :=\n  dom_bool₂ _\n\n"}
{"name":"Primrec.or","module":"Mathlib.Computability.Primrec","initialProofState":"⊢ Primrec₂ Bool.or","decl":"protected theorem or : Primrec₂ or :=\n  dom_bool₂ _\n\n"}
{"name":"PrimrecPred.not","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\ninst✝¹ : Primcodable α\np : α → Prop\ninst✝ : DecidablePred p\nhp : PrimrecPred p\n⊢ PrimrecPred fun a => Not (p a)","decl":"theorem _root_.PrimrecPred.not {p : α → Prop} [DecidablePred p] (hp : PrimrecPred p) :\n    PrimrecPred fun a => ¬p a :=\n  (Primrec.not.comp hp).of_eq fun n => by simp\n\n"}
{"name":"PrimrecPred.and","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\ninst✝² : Primcodable α\np q : α → Prop\ninst✝¹ : DecidablePred p\ninst✝ : DecidablePred q\nhp : PrimrecPred p\nhq : PrimrecPred q\n⊢ PrimrecPred fun a => And (p a) (q a)","decl":"theorem _root_.PrimrecPred.and {p q : α → Prop} [DecidablePred p] [DecidablePred q]\n    (hp : PrimrecPred p) (hq : PrimrecPred q) : PrimrecPred fun a => p a ∧ q a :=\n  (Primrec.and.comp hp hq).of_eq fun n => by simp\n\n"}
{"name":"PrimrecPred.or","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\ninst✝² : Primcodable α\np q : α → Prop\ninst✝¹ : DecidablePred p\ninst✝ : DecidablePred q\nhp : PrimrecPred p\nhq : PrimrecPred q\n⊢ PrimrecPred fun a => Or (p a) (q a)","decl":"theorem _root_.PrimrecPred.or {p q : α → Prop} [DecidablePred p] [DecidablePred q]\n    (hp : PrimrecPred p) (hq : PrimrecPred q) : PrimrecPred fun a => p a ∨ q a :=\n  (Primrec.or.comp hp hq).of_eq fun n => by simp\n\n"}
{"name":"Primrec.beq","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\ninst✝¹ : Primcodable α\ninst✝ : DecidableEq α\n⊢ Primrec₂ BEq.beq","decl":"protected theorem beq [DecidableEq α] : Primrec₂ (@BEq.beq α _) :=\n  have : PrimrecRel fun a b : ℕ => a = b :=\n    (PrimrecPred.and nat_le nat_le.swap).of_eq fun a => by simp [le_antisymm_iff]\n  (this.comp₂ (Primrec.encode.comp₂ Primrec₂.left) (Primrec.encode.comp₂ Primrec₂.right)).of_eq\n    fun _ _ => encode_injective.eq_iff\n\n"}
{"name":"Primrec.eq","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\ninst✝¹ : Primcodable α\ninst✝ : DecidableEq α\n⊢ PrimrecRel Eq","decl":"protected theorem eq [DecidableEq α] : PrimrecRel (@Eq α) := Primrec.beq\n\n"}
{"name":"Primrec.nat_lt","module":"Mathlib.Computability.Primrec","initialProofState":"⊢ PrimrecRel fun x1 x2 => LT.lt x1 x2","decl":"theorem nat_lt : PrimrecRel ((· < ·) : ℕ → ℕ → Prop) :=\n  (nat_le.comp snd fst).not.of_eq fun p => by simp\n\n"}
{"name":"Primrec.option_guard","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : Primcodable α\ninst✝¹ : Primcodable β\np : α → β → Prop\ninst✝ : (a : α) → (b : β) → Decidable (p a b)\nhp : PrimrecRel p\nf : α → β\nhf : Primrec f\n⊢ Primrec fun a => Option.guard (p a) (f a)","decl":"theorem option_guard {p : α → β → Prop} [∀ a b, Decidable (p a b)] (hp : PrimrecRel p) {f : α → β}\n    (hf : Primrec f) : Primrec fun a => Option.guard (p a) (f a) :=\n  ite (hp.comp Primrec.id hf) (option_some_iff.2 hf) (const none)\n\n"}
{"name":"Primrec.option_orElse","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\n⊢ Primrec₂ fun x1 x2 => HOrElse.hOrElse x1 fun x => x2","decl":"theorem option_orElse : Primrec₂ ((· <|> ·) : Option α → Option α → Option α) :=\n  (option_casesOn fst snd (fst.comp fst).to₂).of_eq fun ⟨o₁, o₂⟩ => by cases o₁ <;> cases o₂ <;> rfl\n\n"}
{"name":"Primrec.decode₂","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\n⊢ Primrec (Encodable.decode₂ α)","decl":"protected theorem decode₂ : Primrec (decode₂ α) :=\n  option_bind .decode <|\n    option_guard (Primrec.beq.comp₂ (by exact encode_iff.mpr snd) (by exact fst.comp fst)) snd\n\n"}
{"name":"Primrec.list_findIdx₁","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Primcodable α\ninst✝ : Primcodable β\np : α → β → Bool\nhp : Primrec₂ p\nl : List β\n⊢ Primrec fun a => List.findIdx (p a) l","decl":"theorem list_findIdx₁ {p : α → β → Bool} (hp : Primrec₂ p) :\n    ∀ l : List β, Primrec fun a => l.findIdx (p a)\n| [] => const 0\n| a :: l => (cond (hp.comp .id (const a)) (const 0) (succ.comp (list_findIdx₁ hp l))).of_eq fun n =>\n  by simp [List.findIdx_cons]\n\n"}
{"name":"Primrec.list_indexOf₁","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\ninst✝¹ : Primcodable α\ninst✝ : DecidableEq α\nl : List α\n⊢ Primrec fun a => List.indexOf a l","decl":"theorem list_indexOf₁ [DecidableEq α] (l : List α) : Primrec fun a => l.indexOf a :=\n  list_findIdx₁ (.swap .beq) l\n\n"}
{"name":"Primrec.dom_fintype","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nσ : Type u_3\ninst✝² : Primcodable α\ninst✝¹ : Primcodable σ\ninst✝ : Finite α\nf : α → σ\n⊢ Primrec f","decl":"theorem dom_fintype [Finite α] (f : α → σ) : Primrec f :=\n  let ⟨l, _, m⟩ := Finite.exists_univ_list α\n  option_some_iff.1 <| by\n    haveI := decidableEqOfEncodable α\n    refine ((list_get?₁ (l.map f)).comp (list_indexOf₁ l)).of_eq fun a => ?_\n    rw [List.get?_eq_getElem?, List.getElem?_map, List.getElem?_indexOf (m a), Option.map_some']\n\n-- Porting note: These are new lemmas\n-- I added it because it actually simplified the proofs\n-- and because I couldn't understand the original proof\n"}
{"name":"Primrec.nat_findGreatest","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\ninst✝¹ : Primcodable α\nf : α → Nat\np : α → Nat → Prop\ninst✝ : (x : α) → (n : Nat) → Decidable (p x n)\nhf : Primrec f\nhp : PrimrecRel p\n⊢ Primrec fun x => Nat.findGreatest (p x) (f x)","decl":"theorem nat_findGreatest {f : α → ℕ} {p : α → ℕ → Prop} [∀ x n, Decidable (p x n)]\n    (hf : Primrec f) (hp : PrimrecRel p) : Primrec fun x => (f x).findGreatest (p x) :=\n  (nat_rec' (h := fun x nih => if p x (nih.1 + 1) then nih.1 + 1 else nih.2)\n    hf (const 0) (ite (hp.comp fst (snd |> fst.comp |> succ.comp))\n      (snd |> fst.comp |> succ.comp) (snd.comp snd))).of_eq fun x => by\n        induction f x <;> simp [Nat.findGreatest, *]\n\n"}
{"name":"Primrec.of_graph","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\nf : α → Nat\nh₁ : Primrec.PrimrecBounded f\nh₂ : PrimrecRel fun a b => Eq (f a) b\n⊢ Primrec f","decl":"/-- To show a function `f : α → ℕ` is primitive recursive, it is enough to show that the function\n  is bounded by a primitive recursive function and that its graph is primitive recursive -/\ntheorem of_graph {f : α → ℕ} (h₁ : PrimrecBounded f)\n    (h₂ : PrimrecRel fun a b => f a = b) : Primrec f := by\n  rcases h₁ with ⟨g, pg, hg : ∀ x, f x ≤ g x⟩\n  refine (nat_findGreatest pg h₂).of_eq fun n => ?_\n  exact (Nat.findGreatest_spec (P := fun b => f n = b) (hg n) rfl).symm\n\n-- We show that division is primitive recursive by showing that the graph is\n"}
{"name":"Primrec.nat_div","module":"Mathlib.Computability.Primrec","initialProofState":"⊢ Primrec₂ fun x1 x2 => HDiv.hDiv x1 x2","decl":"theorem nat_div : Primrec₂ ((· / ·) : ℕ → ℕ → ℕ) := by\n  refine of_graph ⟨_, fst, fun p => Nat.div_le_self _ _⟩ ?_\n  have : PrimrecRel fun (a : ℕ × ℕ) (b : ℕ) => (a.2 = 0 ∧ b = 0) ∨\n      (0 < a.2 ∧ b * a.2 ≤ a.1 ∧ a.1 < (b + 1) * a.2) :=\n    PrimrecPred.or\n      (.and (const 0 |> Primrec.eq.comp (fst |> snd.comp)) (const 0 |> Primrec.eq.comp snd))\n      (.and (nat_lt.comp (const 0) (fst |> snd.comp)) <|\n          .and (nat_le.comp (nat_mul.comp snd (fst |> snd.comp)) (fst |> fst.comp))\n          (nat_lt.comp (fst.comp fst) (nat_mul.comp (Primrec.succ.comp snd) (snd.comp fst))))\n  refine this.of_eq ?_\n  rintro ⟨a, k⟩ q\n  if H : k = 0 then simp [H, eq_comm]\n  else\n    have : q * k ≤ a ∧ a < (q + 1) * k ↔ q = a / k := by\n      rw [le_antisymm_iff, ← (@Nat.lt_succ _ q), Nat.le_div_iff_mul_le (Nat.pos_of_ne_zero H),\n          Nat.div_lt_iff_lt_mul (Nat.pos_of_ne_zero H)]\n    simpa [H, zero_lt_iff, eq_comm (b := q)]\n\n"}
{"name":"Primrec.nat_mod","module":"Mathlib.Computability.Primrec","initialProofState":"⊢ Primrec₂ fun x1 x2 => HMod.hMod x1 x2","decl":"theorem nat_mod : Primrec₂ ((· % ·) : ℕ → ℕ → ℕ) :=\n  (nat_sub.comp fst (nat_mul.comp snd nat_div)).to₂.of_eq fun m n => by\n    apply Nat.sub_eq_of_eq_add\n    simp [add_comm (m % n), Nat.div_add_mod]\n\n"}
{"name":"Primrec.nat_bodd","module":"Mathlib.Computability.Primrec","initialProofState":"⊢ Primrec Nat.bodd","decl":"theorem nat_bodd : Primrec Nat.bodd :=\n  (Primrec.beq.comp (nat_mod.comp .id (const 2)) (const 1)).of_eq fun n => by\n    cases H : n.bodd <;> simp [Nat.mod_two_of_bodd, H]\n\n"}
{"name":"Primrec.nat_div2","module":"Mathlib.Computability.Primrec","initialProofState":"⊢ Primrec Nat.div2","decl":"theorem nat_div2 : Primrec Nat.div2 :=\n  (nat_div.comp .id (const 2)).of_eq fun n => n.div2_val.symm\n\n"}
{"name":"Primrec.nat_double","module":"Mathlib.Computability.Primrec","initialProofState":"⊢ Primrec fun n => HMul.hMul 2 n","decl":"theorem nat_double : Primrec (fun n : ℕ => 2 * n) :=\n  nat_mul.comp (const _) Primrec.id\n\n"}
{"name":"Primrec.nat_double_succ","module":"Mathlib.Computability.Primrec","initialProofState":"⊢ Primrec fun n => HAdd.hAdd (HMul.hMul 2 n) 1","decl":"theorem nat_double_succ : Primrec (fun n : ℕ => 2 * n + 1) :=\n  nat_double |> Primrec.succ.comp\n\n"}
{"name":"Primrec.sum_inl","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Primcodable α\ninst✝ : Primcodable β\n⊢ Primrec Sum.inl","decl":"theorem sum_inl : Primrec (@Sum.inl α β) :=\n  encode_iff.1 <| nat_double.comp Primrec.encode\n\n"}
{"name":"Primrec.sum_inr","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Primcodable α\ninst✝ : Primcodable β\n⊢ Primrec Sum.inr","decl":"theorem sum_inr : Primrec (@Sum.inr α β) :=\n  encode_iff.1 <| nat_double_succ.comp Primrec.encode\n\n"}
{"name":"Primrec.sum_casesOn","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nσ : Type u_4\ninst✝³ : Primcodable α\ninst✝² : Primcodable β\ninst✝¹ : Primcodable γ\ninst✝ : Primcodable σ\nf : α → Sum β γ\ng : α → β → σ\nh : α → γ → σ\nhf : Primrec f\nhg : Primrec₂ g\nhh : Primrec₂ h\n⊢ Primrec fun a => Sum.casesOn (f a) (g a) (h a)","decl":"theorem sum_casesOn {f : α → β ⊕ γ} {g : α → β → σ} {h : α → γ → σ} (hf : Primrec f)\n    (hg : Primrec₂ g) (hh : Primrec₂ h) : @Primrec _ σ _ _ fun a => Sum.casesOn (f a) (g a) (h a) :=\n  option_some_iff.1 <|\n    (cond (nat_bodd.comp <| encode_iff.2 hf)\n          (option_map (Primrec.decode.comp <| nat_div2.comp <| encode_iff.2 hf) hh)\n          (option_map (Primrec.decode.comp <| nat_div2.comp <| encode_iff.2 hf) hg)).of_eq\n      fun a => by cases' f a with b c <;> simp [Nat.div2_val, encodek]\n\n"}
{"name":"Primrec.list_cons","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\n⊢ Primrec₂ List.cons","decl":"theorem list_cons : Primrec₂ (@List.cons α) :=\n  list_cons' Primcodable.prim\n\n"}
{"name":"Primrec.list_casesOn","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nβ : Type u_2\nσ : Type u_4\ninst✝² : Primcodable α\ninst✝¹ : Primcodable β\ninst✝ : Primcodable σ\nf : α → List β\ng : α → σ\nh : α → Prod β (List β) → σ\na✝² : Primrec f\na✝¹ : Primrec g\na✝ : Primrec₂ h\n⊢ Primrec fun a => List.casesOn (f a) (g a) fun b l => h a { fst := b, snd := l }","decl":"theorem list_casesOn {f : α → List β} {g : α → σ} {h : α → β × List β → σ} :\n    Primrec f →\n      Primrec g →\n        Primrec₂ h → @Primrec _ σ _ _ fun a => List.casesOn (f a) (g a) fun b l => h a (b, l) :=\n  list_casesOn' Primcodable.prim\n\n"}
{"name":"Primrec.list_foldl","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nβ : Type u_2\nσ : Type u_4\ninst✝² : Primcodable α\ninst✝¹ : Primcodable β\ninst✝ : Primcodable σ\nf : α → List β\ng : α → σ\nh : α → Prod σ β → σ\na✝² : Primrec f\na✝¹ : Primrec g\na✝ : Primrec₂ h\n⊢ Primrec fun a => List.foldl (fun s b => h a { fst := s, snd := b }) (g a) (f a)","decl":"theorem list_foldl {f : α → List β} {g : α → σ} {h : α → σ × β → σ} :\n    Primrec f →\n      Primrec g → Primrec₂ h → Primrec fun a => (f a).foldl (fun s b => h a (s, b)) (g a) :=\n  list_foldl' Primcodable.prim\n\n"}
{"name":"Primrec.list_reverse","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\n⊢ Primrec List.reverse","decl":"theorem list_reverse : Primrec (@List.reverse α) :=\n  list_reverse' Primcodable.prim\n\n"}
{"name":"Primrec.list_foldr","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nβ : Type u_2\nσ : Type u_4\ninst✝² : Primcodable α\ninst✝¹ : Primcodable β\ninst✝ : Primcodable σ\nf : α → List β\ng : α → σ\nh : α → Prod β σ → σ\nhf : Primrec f\nhg : Primrec g\nhh : Primrec₂ h\n⊢ Primrec fun a => List.foldr (fun b s => h a { fst := b, snd := s }) (g a) (f a)","decl":"theorem list_foldr {f : α → List β} {g : α → σ} {h : α → β × σ → σ} (hf : Primrec f)\n    (hg : Primrec g) (hh : Primrec₂ h) :\n    Primrec fun a => (f a).foldr (fun b s => h a (b, s)) (g a) :=\n  (list_foldl (list_reverse.comp hf) hg <| to₂ <| hh.comp fst <| (pair snd fst).comp snd).of_eq\n    fun a => by simp [List.foldl_reverse]\n\n"}
{"name":"Primrec.list_head?","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\n⊢ Primrec List.head?","decl":"theorem list_head? : Primrec (@List.head? α) :=\n  (list_casesOn .id (const none) (option_some_iff.2 <| fst.comp snd).to₂).of_eq fun l => by\n    cases l <;> rfl\n\n"}
{"name":"Primrec.list_headI","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\ninst✝¹ : Primcodable α\ninst✝ : Inhabited α\n⊢ Primrec List.headI","decl":"theorem list_headI [Inhabited α] : Primrec (@List.headI α _) :=\n  (option_iget.comp list_head?).of_eq fun l => l.head!_eq_head?.symm\n\n"}
{"name":"Primrec.list_tail","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\n⊢ Primrec List.tail","decl":"theorem list_tail : Primrec (@List.tail α) :=\n  (list_casesOn .id (const []) (snd.comp snd).to₂).of_eq fun l => by cases l <;> rfl\n\n"}
{"name":"Primrec.list_rec","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nβ : Type u_2\nσ : Type u_4\ninst✝² : Primcodable α\ninst✝¹ : Primcodable β\ninst✝ : Primcodable σ\nf : α → List β\ng : α → σ\nh : α → Prod β (Prod (List β) σ) → σ\nhf : Primrec f\nhg : Primrec g\nhh : Primrec₂ h\n⊢ Primrec fun a => List.recOn (f a) (g a) fun b l IH => h a { fst := b, snd := { fst := l, snd := IH } }","decl":"theorem list_rec {f : α → List β} {g : α → σ} {h : α → β × List β × σ → σ} (hf : Primrec f)\n    (hg : Primrec g) (hh : Primrec₂ h) :\n    @Primrec _ σ _ _ fun a => List.recOn (f a) (g a) fun b l IH => h a (b, l, IH) :=\n  let F (a : α) := (f a).foldr (fun (b : β) (s : List β × σ) => (b :: s.1, h a (b, s))) ([], g a)\n  have : Primrec F :=\n    list_foldr hf (pair (const []) hg) <|\n      to₂ <| pair ((list_cons.comp fst (fst.comp snd)).comp snd) hh\n  (snd.comp this).of_eq fun a => by\n    suffices F a = (f a, List.recOn (f a) (g a) fun b l IH => h a (b, l, IH)) by rw [this]\n    dsimp [F]\n    induction' f a with b l IH <;> simp [*]\n\n"}
{"name":"Primrec.list_get?","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\n⊢ Primrec₂ List.get?","decl":"theorem list_get? : Primrec₂ (@List.get? α) :=\n  let F (l : List α) (n : ℕ) :=\n    l.foldl\n      (fun (s : ℕ ⊕ α) (a : α) =>\n        Sum.casesOn s (@Nat.casesOn (fun _ => ℕ ⊕ α) · (Sum.inr a) Sum.inl) Sum.inr)\n      (Sum.inl n)\n  have hF : Primrec₂ F :=\n    (list_foldl fst (sum_inl.comp snd)\n      ((sum_casesOn fst (nat_casesOn snd (sum_inr.comp <| snd.comp fst) (sum_inl.comp snd).to₂).to₂\n              (sum_inr.comp snd).to₂).comp\n          snd).to₂).to₂\n  have :\n    @Primrec _ (Option α) _ _ fun p : List α × ℕ => Sum.casesOn (F p.1 p.2) (fun _ => none) some :=\n    sum_casesOn hF (const none).to₂ (option_some.comp snd).to₂\n  this.to₂.of_eq fun l n => by\n    dsimp; symm\n    induction' l with a l IH generalizing n; · rfl\n    cases' n with n\n    · dsimp [F]\n      clear IH\n      induction' l with _ l IH <;> simp [*]\n    · apply IH\n\n"}
{"name":"Primrec.list_getElem?","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\n⊢ Primrec₂ fun l n => GetElem?.getElem? l n","decl":"theorem list_getElem? : Primrec₂ (fun (l : List α) (n : ℕ) => l[n]?) := by\n  convert list_get?\n  ext\n  simp\n\n"}
{"name":"Primrec.list_getD","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\nd : α\n⊢ Primrec₂ fun l n => l.getD n d","decl":"theorem list_getD (d : α) : Primrec₂ fun l n => List.getD l n d := by\n  simp only [List.getD_eq_getElem?_getD]\n  exact option_getD.comp₂ list_getElem? (const _)\n\n"}
{"name":"Primrec.list_getI","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\ninst✝¹ : Primcodable α\ninst✝ : Inhabited α\n⊢ Primrec₂ List.getI","decl":"theorem list_getI [Inhabited α] : Primrec₂ (@List.getI α _) :=\n  list_getD _\n\n"}
{"name":"Primrec.list_append","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\n⊢ Primrec₂ fun x1 x2 => HAppend.hAppend x1 x2","decl":"theorem list_append : Primrec₂ ((· ++ ·) : List α → List α → List α) :=\n  (list_foldr fst snd <| to₂ <| comp (@list_cons α _) snd).to₂.of_eq fun l₁ l₂ => by\n    induction l₁ <;> simp [*]\n\n"}
{"name":"Primrec.list_concat","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\n⊢ Primrec₂ fun l a => HAppend.hAppend l (List.cons a List.nil)","decl":"theorem list_concat : Primrec₂ fun l (a : α) => l ++ [a] :=\n  list_append.comp fst (list_cons.comp snd (const []))\n\n"}
{"name":"Primrec.list_map","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nβ : Type u_2\nσ : Type u_4\ninst✝² : Primcodable α\ninst✝¹ : Primcodable β\ninst✝ : Primcodable σ\nf : α → List β\ng : α → β → σ\nhf : Primrec f\nhg : Primrec₂ g\n⊢ Primrec fun a => List.map (g a) (f a)","decl":"theorem list_map {f : α → List β} {g : α → β → σ} (hf : Primrec f) (hg : Primrec₂ g) :\n    Primrec fun a => (f a).map (g a) :=\n  (list_foldr hf (const []) <|\n        to₂ <| list_cons.comp (hg.comp fst (fst.comp snd)) (snd.comp snd)).of_eq\n    fun a => by induction f a <;> simp [*]\n\n"}
{"name":"Primrec.list_range","module":"Mathlib.Computability.Primrec","initialProofState":"⊢ Primrec List.range","decl":"theorem list_range : Primrec List.range :=\n  (nat_rec' .id (const []) ((list_concat.comp snd fst).comp snd).to₂).of_eq fun n => by\n    simp; induction n <;> simp [*, List.range_succ]\n\n"}
{"name":"Primrec.list_flatten","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\n⊢ Primrec List.flatten","decl":"theorem list_flatten : Primrec (@List.flatten α) :=\n  (list_foldr .id (const []) <| to₂ <| comp (@list_append α _) snd).of_eq fun l => by\n    dsimp; induction l <;> simp [*]\n\n"}
{"name":"Primrec.list_join","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\n⊢ Primrec List.flatten","decl":"@[deprecated (since := \"2024-10-15\")] alias list_join := list_flatten\n\n"}
{"name":"Primrec.list_flatMap","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nβ : Type u_2\nσ : Type u_4\ninst✝² : Primcodable α\ninst✝¹ : Primcodable β\ninst✝ : Primcodable σ\nf : α → List β\ng : α → β → List σ\nhf : Primrec f\nhg : Primrec₂ g\n⊢ Primrec fun a => (f a).flatMap (g a)","decl":"theorem list_flatMap {f : α → List β} {g : α → β → List σ} (hf : Primrec f) (hg : Primrec₂ g) :\n    Primrec (fun a => (f a).flatMap (g a)) := list_flatten.comp (list_map hf hg)\n\n"}
{"name":"Primrec.list_bind","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nβ : Type u_2\nσ : Type u_4\ninst✝² : Primcodable α\ninst✝¹ : Primcodable β\ninst✝ : Primcodable σ\nf : α → List β\ng : α → β → List σ\nhf : Primrec f\nhg : Primrec₂ g\n⊢ Primrec fun a => (f a).flatMap (g a)","decl":"@[deprecated (since := \"2024-10-16\")] alias list_bind := list_flatMap\n\n"}
{"name":"Primrec.optionToList","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\n⊢ Primrec Option.toList","decl":"theorem optionToList : Primrec (Option.toList : Option α → List α) :=\n  (option_casesOn Primrec.id (const [])\n    ((list_cons.comp Primrec.id (const [])).comp₂ Primrec₂.right)).of_eq\n  (fun o => by rcases o <;> simp)\n\n"}
{"name":"Primrec.listFilterMap","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nβ : Type u_2\nσ : Type u_4\ninst✝² : Primcodable α\ninst✝¹ : Primcodable β\ninst✝ : Primcodable σ\nf : α → List β\ng : α → β → Option σ\nhf : Primrec f\nhg : Primrec₂ g\n⊢ Primrec fun a => List.filterMap (g a) (f a)","decl":"theorem listFilterMap {f : α → List β} {g : α → β → Option σ}\n    (hf : Primrec f) (hg : Primrec₂ g) : Primrec fun a => (f a).filterMap (g a) :=\n  (list_flatMap hf (comp₂ optionToList hg)).of_eq\n    fun _ ↦ Eq.symm <| List.filterMap_eq_flatMap_toList _ _\n\n"}
{"name":"Primrec.list_length","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\n⊢ Primrec List.length","decl":"theorem list_length : Primrec (@List.length α) :=\n  (list_foldr (@Primrec.id (List α) _) (const 0) <| to₂ <| (succ.comp <| snd.comp snd).to₂).of_eq\n    fun l => by dsimp; induction l <;> simp [*]\n\n"}
{"name":"Primrec.list_findIdx","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Primcodable α\ninst✝ : Primcodable β\nf : α → List β\np : α → β → Bool\nhf : Primrec f\nhp : Primrec₂ p\n⊢ Primrec fun a => List.findIdx (p a) (f a)","decl":"theorem list_findIdx {f : α → List β} {p : α → β → Bool}\n    (hf : Primrec f) (hp : Primrec₂ p) : Primrec fun a => (f a).findIdx (p a) :=\n  (list_foldr hf (const 0) <|\n        to₂ <| cond (hp.comp fst <| fst.comp snd) (const 0) (succ.comp <| snd.comp snd)).of_eq\n    fun a => by dsimp; induction f a <;> simp [List.findIdx_cons, *]\n\n"}
{"name":"Primrec.list_indexOf","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\ninst✝¹ : Primcodable α\ninst✝ : DecidableEq α\n⊢ Primrec₂ List.indexOf","decl":"theorem list_indexOf [DecidableEq α] : Primrec₂ (@List.indexOf α _) :=\n  to₂ <| list_findIdx snd <| Primrec.beq.comp₂ snd.to₂ (fst.comp fst).to₂\n\n"}
{"name":"Primrec.nat_strong_rec","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nσ : Type u_4\ninst✝¹ : Primcodable α\ninst✝ : Primcodable σ\nf : α → Nat → σ\ng : α → List σ → Option σ\nhg : Primrec₂ g\nH : ∀ (a : α) (n : Nat), Eq (g a (List.map (f a) (List.range n))) (Option.some (f a n))\n⊢ Primrec₂ f","decl":"theorem nat_strong_rec (f : α → ℕ → σ) {g : α → List σ → Option σ} (hg : Primrec₂ g)\n    (H : ∀ a n, g a ((List.range n).map (f a)) = some (f a n)) : Primrec₂ f :=\n  suffices Primrec₂ fun a n => (List.range n).map (f a) from\n    Primrec₂.option_some_iff.1 <|\n      (list_get?.comp (this.comp fst (succ.comp snd)) snd).to₂.of_eq fun a n => by\n        simp [List.getElem?_range (Nat.lt_succ_self n)]\n  Primrec₂.option_some_iff.1 <|\n    (nat_rec (const (some []))\n          (to₂ <|\n            option_bind (snd.comp snd) <|\n              to₂ <|\n                option_map (hg.comp (fst.comp fst) snd)\n                  (to₂ <| list_concat.comp (snd.comp fst) snd))).of_eq\n      fun a n => by\n      induction n with\n      | zero => rfl\n      | succ n IH => simp [IH, H, List.range_succ]\n\n"}
{"name":"Primrec.listLookup","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : Primcodable α\ninst✝¹ : Primcodable β\ninst✝ : DecidableEq α\n⊢ Primrec₂ List.lookup","decl":"theorem listLookup [DecidableEq α] : Primrec₂ (List.lookup : α → List (α × β) → Option β) :=\n  (to₂ <| list_rec snd (const none) <|\n    to₂ <|\n      cond (Primrec.beq.comp (fst.comp fst) (fst.comp <| fst.comp snd))\n        (option_some.comp <| snd.comp <| fst.comp snd)\n        (snd.comp <| snd.comp snd)).of_eq\n  fun a ps => by\n  induction' ps with p ps ih <;> simp [List.lookup, *]\n  cases ha : a == p.1 <;> simp [ha]\n\n"}
{"name":"Primrec.nat_omega_rec'","module":"Mathlib.Computability.Primrec","initialProofState":"β : Type u_2\nσ : Type u_4\ninst✝¹ : Primcodable β\ninst✝ : Primcodable σ\nf : β → σ\nm : β → Nat\nl : β → List β\ng : β → List σ → Option σ\nhm : Primrec m\nhl : Primrec l\nhg : Primrec₂ g\nOrd : ∀ (b b' : β), Membership.mem (l b) b' → LT.lt (m b') (m b)\nH : ∀ (b : β), Eq (g b (List.map f (l b))) (Option.some (f b))\n⊢ Primrec f","decl":"theorem nat_omega_rec' (f : β → σ) {m : β → ℕ} {l : β → List β} {g : β → List σ → Option σ}\n    (hm : Primrec m) (hl : Primrec l) (hg : Primrec₂ g)\n    (Ord : ∀ b, ∀ b' ∈ l b, m b' < m b)\n    (H : ∀ b, g b ((l b).map f) = some (f b)) : Primrec f := by\n  haveI : DecidableEq β := Encodable.decidableEqOfEncodable β\n  let mapGraph (M : List (β × σ)) (bs : List β) : List σ := bs.flatMap (Option.toList <| M.lookup ·)\n  let bindList (b : β) : ℕ → List β := fun n ↦ n.rec [b] fun _ bs ↦ bs.flatMap l\n  let graph (b : β) : ℕ → List (β × σ) := fun i ↦ i.rec [] fun i ih ↦\n    (bindList b (m b - i)).filterMap fun b' ↦ (g b' <| mapGraph ih (l b')).map (b', ·)\n  have mapGraph_primrec : Primrec₂ mapGraph :=\n    to₂ <| list_flatMap snd <| optionToList.comp₂ <| listLookup.comp₂ .right (fst.comp₂ .left)\n  have bindList_primrec : Primrec₂ (bindList) :=\n    nat_rec' snd\n      (list_cons.comp fst (const []))\n      (to₂ <| list_flatMap (snd.comp snd) (hl.comp₂ .right))\n  have graph_primrec : Primrec₂ (graph) :=\n    to₂ <| nat_rec' snd (const []) <|\n      to₂ <| listFilterMap\n        (bindList_primrec.comp\n          (fst.comp fst)\n          (nat_sub.comp (hm.comp <| fst.comp fst) (fst.comp snd))) <|\n            to₂ <| option_map\n              (hg.comp snd (mapGraph_primrec.comp (snd.comp <| snd.comp fst) (hl.comp snd)))\n              (Primrec₂.pair.comp₂ (snd.comp₂ .left) .right)\n  have : Primrec (fun b => ((graph b (m b + 1)).get? 0).map Prod.snd) :=\n    option_map (list_get?.comp (graph_primrec.comp Primrec.id (succ.comp hm)) (const 0))\n      (snd.comp₂ Primrec₂.right)\n  exact option_some_iff.mp <| this.of_eq <| fun b ↦ by\n    have graph_eq_map_bindList (i : ℕ) (hi : i ≤ m b + 1) :\n        graph b i = (bindList b (m b + 1 - i)).map fun x ↦ (x, f x) := by\n      have bindList_eq_nil : bindList b (m b + 1) = [] :=\n        have bindList_m_lt (k : ℕ) : ∀ b' ∈ bindList b k, m b' < m b + 1 - k := by\n          induction' k with k ih <;> simp [bindList]\n          intro a₂ a₁ ha₁ ha₂\n          have : k ≤ m b :=\n            Nat.lt_succ.mp (by simpa using Nat.add_lt_of_lt_sub <| Nat.zero_lt_of_lt (ih a₁ ha₁))\n          have : m a₁ ≤ m b - k :=\n            Nat.lt_succ.mp (by rw [← Nat.succ_sub this]; simpa using ih a₁ ha₁)\n          exact lt_of_lt_of_le (Ord a₁ a₂ ha₂) this\n        List.eq_nil_iff_forall_not_mem.mpr\n          (by intro b' ha'; by_contra; simpa using bindList_m_lt (m b + 1) b' ha')\n      have mapGraph_graph {bs bs' : List β} (has : bs' ⊆ bs) :\n          mapGraph (bs.map <| fun x => (x, f x)) bs' = bs'.map f := by\n        induction' bs' with b bs' ih <;> simp [mapGraph]\n        · have : b ∈ bs ∧ bs' ⊆ bs := by simpa using has\n          rcases this with ⟨ha, has'⟩\n          simpa [List.lookup_graph f ha] using ih has'\n      have graph_succ : ∀ i, graph b (i + 1) =\n        (bindList b (m b - i)).filterMap fun b' =>\n          (g b' <| mapGraph (graph b i) (l b')).map (b', ·) := fun _ => rfl\n      have bindList_succ : ∀ i, bindList b (i + 1) = (bindList b i).flatMap l := fun _ => rfl\n      induction' i with i ih\n      · symm; simpa [graph] using bindList_eq_nil\n      · simp only [graph_succ, ih (Nat.le_of_lt hi), Nat.succ_sub (Nat.lt_succ.mp hi),\n          Nat.succ_eq_add_one, bindList_succ, Nat.reduceSubDiff]\n        apply List.filterMap_eq_map_iff_forall_eq_some.mpr\n        intro b' ha'; simp; rw [mapGraph_graph]\n        · exact H b'\n        · exact (List.infix_flatMap_of_mem ha' l).subset\n    simp [graph_eq_map_bindList (m b + 1) (Nat.le_refl _), bindList]\n\n"}
{"name":"Primrec.nat_omega_rec","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nβ : Type u_2\nσ : Type u_4\ninst✝² : Primcodable α\ninst✝¹ : Primcodable β\ninst✝ : Primcodable σ\nf : α → β → σ\nm : α → β → Nat\nl : α → β → List β\ng : α → Prod β (List σ) → Option σ\nhm : Primrec₂ m\nhl : Primrec₂ l\nhg : Primrec₂ g\nOrd : ∀ (a : α) (b b' : β), Membership.mem (l a b) b' → LT.lt (m a b') (m a b)\nH : ∀ (a : α) (b : β), Eq (g a { fst := b, snd := List.map (f a) (l a b) }) (Option.some (f a b))\n⊢ Primrec₂ f","decl":"theorem nat_omega_rec (f : α → β → σ) {m : α → β → ℕ}\n    {l : α → β → List β} {g : α → β × List σ → Option σ}\n    (hm : Primrec₂ m) (hl : Primrec₂ l) (hg : Primrec₂ g)\n    (Ord : ∀ a b, ∀ b' ∈ l a b, m a b' < m a b)\n    (H : ∀ a b, g a (b, (l a b).map (f a)) = some (f a b)) : Primrec₂ f :=\n  Primrec₂.uncurry.mp <|\n    nat_omega_rec' (Function.uncurry f)\n      (Primrec₂.uncurry.mpr hm)\n      (list_map (hl.comp fst snd) (Primrec₂.pair.comp₂ (fst.comp₂ .left) .right))\n      (hg.comp₂ (fst.comp₂ .left) (Primrec₂.pair.comp₂ (snd.comp₂ .left) .right))\n      (by simpa using Ord) (by simpa [Function.comp] using H)\n\n"}
{"name":"Primcodable.mem_range_encode","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\n⊢ PrimrecPred fun n => Membership.mem (Set.range Encodable.encode) n","decl":"theorem mem_range_encode : PrimrecPred (fun n => n ∈ Set.range (encode : α → ℕ)) :=\n  have : PrimrecPred fun n => Encodable.decode₂ α n ≠ none :=\n    .not\n      (Primrec.eq.comp\n        (.option_bind .decode\n          (.ite (Primrec.eq.comp (Primrec.encode.comp .snd) .fst)\n            (Primrec.option_some.comp .snd) (.const _)))\n        (.const _))\n  this.of_eq fun _ => decode₂_ne_none_iff\n\n"}
{"name":"Primrec.subtype_val","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\ninst✝¹ : Primcodable α\np : α → Prop\ninst✝ : DecidablePred p\nhp : PrimrecPred p\n⊢ Primrec Subtype.val","decl":"theorem subtype_val {p : α → Prop} [DecidablePred p] {hp : PrimrecPred p} :\n    haveI := Primcodable.subtype hp\n    Primrec (@Subtype.val α p) := by\n  letI := Primcodable.subtype hp\n  refine (@Primcodable.prim (Subtype p)).of_eq fun n => ?_\n  rcases @decode (Subtype p) _ n with (_ | ⟨a, h⟩) <;> rfl\n\n"}
{"name":"Primrec.subtype_val_iff","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : Primcodable α\ninst✝¹ : Primcodable β\np : β → Prop\ninst✝ : DecidablePred p\nhp : PrimrecPred p\nf : α → Subtype p\n⊢ Iff (Primrec fun a => ↑(f a)) (Primrec f)","decl":"theorem subtype_val_iff {p : β → Prop} [DecidablePred p] {hp : PrimrecPred p} {f : α → Subtype p} :\n    haveI := Primcodable.subtype hp\n    (Primrec fun a => (f a).1) ↔ Primrec f := by\n  letI := Primcodable.subtype hp\n  refine ⟨fun h => ?_, fun hf => subtype_val.comp hf⟩\n  refine Nat.Primrec.of_eq h fun n => ?_\n  cases' @decode α _ n with a; · rfl\n  simp; rfl\n\n"}
{"name":"Primrec.subtype_mk","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : Primcodable α\ninst✝¹ : Primcodable β\np : β → Prop\ninst✝ : DecidablePred p\nhp : PrimrecPred p\nf : α → β\nh : ∀ (a : α), p (f a)\nhf : Primrec f\n⊢ Primrec fun a => ⟨f a, ⋯⟩","decl":"theorem subtype_mk {p : β → Prop} [DecidablePred p] {hp : PrimrecPred p} {f : α → β}\n    {h : ∀ a, p (f a)} (hf : Primrec f) :\n    haveI := Primcodable.subtype hp\n    Primrec fun a => @Subtype.mk β p (f a) (h a) :=\n  subtype_val_iff.1 hf\n\n"}
{"name":"Primrec.option_get","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Primcodable α\ninst✝ : Primcodable β\nf : α → Option β\nh : ∀ (a : α), Eq (f a).isSome Bool.true\na✝ : Primrec f\n⊢ Primrec fun a => (f a).get ⋯","decl":"theorem option_get {f : α → Option β} {h : ∀ a, (f a).isSome} :\n    Primrec f → Primrec fun a => (f a).get (h a) := by\n  intro hf\n  refine (Nat.Primrec.pred.comp hf).of_eq fun n => ?_\n  generalize hx : @decode α _ n = x\n  cases x <;> simp\n\n"}
{"name":"Primrec.ulower_down","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\n⊢ Primrec ULower.down","decl":"theorem ulower_down : Primrec (ULower.down : α → ULower α) :=\n  letI : ∀ a, Decidable (a ∈ Set.range (encode : α → ℕ)) := decidableRangeEncode _\n  subtype_mk .encode\n\n"}
{"name":"Primrec.ulower_up","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\n⊢ Primrec ULower.up","decl":"theorem ulower_up : Primrec (ULower.up : ULower α → α) :=\n  letI : ∀ a, Decidable (a ∈ Set.range (encode : α → ℕ)) := decidableRangeEncode _\n  option_get (Primrec.decode₂.comp subtype_val)\n\n"}
{"name":"Primrec.fin_val_iff","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\nn : Nat\nf : α → Fin n\n⊢ Iff (Primrec fun a => ↑(f a)) (Primrec f)","decl":"theorem fin_val_iff {n} {f : α → Fin n} : (Primrec fun a => (f a).1) ↔ Primrec f := by\n  letI : Primcodable { a // id a < n } := Primcodable.subtype (nat_lt.comp .id (const _))\n  exact (Iff.trans (by rfl) subtype_val_iff).trans (of_equiv_iff _)\n\n"}
{"name":"Primrec.fin_val","module":"Mathlib.Computability.Primrec","initialProofState":"n : Nat\n⊢ Primrec fun i => ↑i","decl":"theorem fin_val {n} : Primrec (fun (i : Fin n) => (i : ℕ)) :=\n  fin_val_iff.2 .id\n\n"}
{"name":"Primrec.fin_succ","module":"Mathlib.Computability.Primrec","initialProofState":"n : Nat\n⊢ Primrec Fin.succ","decl":"theorem fin_succ {n} : Primrec (@Fin.succ n) :=\n  fin_val_iff.1 <| by simp [succ.comp fin_val]\n\n"}
{"name":"Primrec.vector_toList","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\nn : Nat\n⊢ Primrec List.Vector.toList","decl":"theorem vector_toList {n} : Primrec (@List.Vector.toList α n) :=\n  subtype_val\n\n"}
{"name":"Primrec.vector_toList_iff","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Primcodable α\ninst✝ : Primcodable β\nn : Nat\nf : α → List.Vector β n\n⊢ Iff (Primrec fun a => (f a).toList) (Primrec f)","decl":"theorem vector_toList_iff {n} {f : α → List.Vector β n} :\n    (Primrec fun a => (f a).toList) ↔ Primrec f :=\n  subtype_val_iff\n\n"}
{"name":"Primrec.vector_cons","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\nn : Nat\n⊢ Primrec₂ List.Vector.cons","decl":"theorem vector_cons {n} : Primrec₂ (@List.Vector.cons α n) :=\n  vector_toList_iff.1 <| by simpa using list_cons.comp fst (vector_toList_iff.2 snd)\n\n"}
{"name":"Primrec.vector_length","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\nn : Nat\n⊢ Primrec List.Vector.length","decl":"theorem vector_length {n} : Primrec (@List.Vector.length α n) :=\n  const _\n\n"}
{"name":"Primrec.vector_head","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\nn : Nat\n⊢ Primrec List.Vector.head","decl":"theorem vector_head {n} : Primrec (@List.Vector.head α n) :=\n  option_some_iff.1 <| (list_head?.comp vector_toList).of_eq fun ⟨_ :: _, _⟩ => rfl\n\n"}
{"name":"Primrec.vector_tail","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\nn : Nat\n⊢ Primrec List.Vector.tail","decl":"theorem vector_tail {n} : Primrec (@List.Vector.tail α n) :=\n  vector_toList_iff.1 <| (list_tail.comp vector_toList).of_eq fun ⟨l, h⟩ => by cases l <;> rfl\n\n"}
{"name":"Primrec.vector_get","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\nn : Nat\n⊢ Primrec₂ List.Vector.get","decl":"theorem vector_get {n} : Primrec₂ (@List.Vector.get α n) :=\n  option_some_iff.1 <|\n    (list_get?.comp (vector_toList.comp fst) (fin_val.comp snd)).of_eq fun a => by\n      rw [Vector.get_eq_get_toList, ← List.get?_eq_get]\n      rfl\n\n"}
{"name":"Primrec.list_ofFn","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nσ : Type u_3\ninst✝¹ : Primcodable α\ninst✝ : Primcodable σ\nn : Nat\nf : Fin n → α → σ\na✝ : ∀ (i : Fin n), Primrec (f i)\n⊢ Primrec fun a => List.ofFn fun i => f i a","decl":"theorem list_ofFn :\n    ∀ {n} {f : Fin n → α → σ}, (∀ i, Primrec (f i)) → Primrec fun a => List.ofFn fun i => f i a\n  | 0, _, _ => by simp only [List.ofFn_zero]; exact const []\n  | n + 1, f, hf => by\n    simpa [List.ofFn_succ] using list_cons.comp (hf 0) (list_ofFn fun i => hf i.succ)\n\n"}
{"name":"Primrec.vector_ofFn","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nσ : Type u_3\ninst✝¹ : Primcodable α\ninst✝ : Primcodable σ\nn : Nat\nf : Fin n → α → σ\nhf : ∀ (i : Fin n), Primrec (f i)\n⊢ Primrec fun a => List.Vector.ofFn fun i => f i a","decl":"theorem vector_ofFn {n} {f : Fin n → α → σ} (hf : ∀ i, Primrec (f i)) :\n    Primrec fun a => List.Vector.ofFn fun i => f i a :=\n  vector_toList_iff.1 <| by simp [list_ofFn hf]\n\n"}
{"name":"Primrec.vector_get'","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\nn : Nat\n⊢ Primrec List.Vector.get","decl":"theorem vector_get' {n} : Primrec (@List.Vector.get α n) :=\n  of_equiv_symm\n\n"}
{"name":"Primrec.vector_ofFn'","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\nn : Nat\n⊢ Primrec List.Vector.ofFn","decl":"theorem vector_ofFn' {n} : Primrec (@List.Vector.ofFn α n) :=\n  of_equiv\n\n"}
{"name":"Primrec.fin_app","module":"Mathlib.Computability.Primrec","initialProofState":"σ : Type u_3\ninst✝ : Primcodable σ\nn : Nat\n⊢ Primrec₂ id","decl":"theorem fin_app {n} : Primrec₂ (@id (Fin n → σ)) :=\n  (vector_get.comp (vector_ofFn'.comp fst) snd).of_eq fun ⟨v, i⟩ => by simp\n\n"}
{"name":"Primrec.fin_curry₁","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nσ : Type u_3\ninst✝¹ : Primcodable α\ninst✝ : Primcodable σ\nn : Nat\nf : Fin n → α → σ\n⊢ Iff (Primrec₂ f) (∀ (i : Fin n), Primrec (f i))","decl":"theorem fin_curry₁ {n} {f : Fin n → α → σ} : Primrec₂ f ↔ ∀ i, Primrec (f i) :=\n  ⟨fun h i => h.comp (const i) .id, fun h =>\n    (vector_get.comp ((vector_ofFn h).comp snd) fst).of_eq fun a => by simp⟩\n\n"}
{"name":"Primrec.fin_curry","module":"Mathlib.Computability.Primrec","initialProofState":"α : Type u_1\nσ : Type u_3\ninst✝¹ : Primcodable α\ninst✝ : Primcodable σ\nn : Nat\nf : α → Fin n → σ\n⊢ Iff (Primrec f) (Primrec₂ f)","decl":"theorem fin_curry {n} {f : α → Fin n → σ} : Primrec f ↔ Primrec₂ f :=\n  ⟨fun h => fin_app.comp (h.comp fst) snd, fun h =>\n    (vector_get'.comp\n          (vector_ofFn fun i => show Primrec fun a => f a i from h.comp .id (const i))).of_eq\n      fun a => by funext i; simp⟩\n\n"}
{"name":"Nat.Primrec'.brecOn","module":"Mathlib.Computability.Primrec","initialProofState":"motive✝ : {n : Nat} → (a : List.Vector Nat n → Nat) → Nat.Primrec' a → Prop\nn : Nat\na✝ : List.Vector Nat n → Nat\nx✝ : Nat.Primrec' a✝\nih✝ : ∀ {n : Nat} (a : List.Vector Nat n → Nat) (x : Nat.Primrec' a), x.below → motive✝ a x\n⊢ motive✝ a✝ x✝","decl":"/-- An alternative inductive definition of `Primrec` which\n  does not use the pairing function on ℕ, and so has to\n  work with n-ary functions on ℕ instead of unary functions.\n  We prove that this is equivalent to the regular notion\n  in `to_prim` and `of_prim`. -/\ninductive Primrec' : ∀ {n}, (List.Vector ℕ n → ℕ) → Prop\n  | zero : @Primrec' 0 fun _ => 0\n  | succ : @Primrec' 1 fun v => succ v.head\n  | get {n} (i : Fin n) : Primrec' fun v => v.get i\n  | comp {m n f} (g : Fin n → List.Vector ℕ m → ℕ) :\n      Primrec' f → (∀ i, Primrec' (g i)) → Primrec' fun a => f (List.Vector.ofFn fun i => g i a)\n  | prec {n f g} :\n      @Primrec' n f →\n        @Primrec' (n + 2) g →\n          Primrec' fun v : List.Vector ℕ (n + 1) =>\n            v.head.rec (f v.tail) fun y IH => g (y ::ᵥ IH ::ᵥ v.tail)\n\n"}
{"name":"Nat.Primrec'.to_prim","module":"Mathlib.Computability.Primrec","initialProofState":"n : Nat\nf : List.Vector Nat n → Nat\npf : Nat.Primrec' f\n⊢ Primrec f","decl":"theorem to_prim {n f} (pf : @Nat.Primrec' n f) : Primrec f := by\n  induction pf with\n  | zero => exact .const 0\n  | succ => exact _root_.Primrec.succ.comp .vector_head\n  | get i => exact Primrec.vector_get.comp .id (.const i)\n  | comp _ _ _ hf hg => exact hf.comp (.vector_ofFn fun i => hg i)\n  | @prec n f g _ _ hf hg =>\n    exact\n      .nat_rec' .vector_head (hf.comp Primrec.vector_tail)\n        (hg.comp <|\n          Primrec.vector_cons.comp (Primrec.fst.comp .snd) <|\n          Primrec.vector_cons.comp (Primrec.snd.comp .snd) <|\n            (@Primrec.vector_tail _ _ (n + 1)).comp .fst).to₂\n\n"}
{"name":"Nat.Primrec'.of_eq","module":"Mathlib.Computability.Primrec","initialProofState":"n : Nat\nf g : List.Vector Nat n → Nat\nhf : Nat.Primrec' f\nH : ∀ (i : List.Vector Nat n), Eq (f i) (g i)\n⊢ Nat.Primrec' g","decl":"theorem of_eq {n} {f g : List.Vector ℕ n → ℕ} (hf : Primrec' f) (H : ∀ i, f i = g i) :\n    Primrec' g :=\n  (funext H : f = g) ▸ hf\n\n"}
{"name":"Nat.Primrec'.const","module":"Mathlib.Computability.Primrec","initialProofState":"n m : Nat\n⊢ Nat.Primrec' fun x => m","decl":"theorem const {n} : ∀ m, @Primrec' n fun _ => m\n  | 0 => zero.comp Fin.elim0 fun i => i.elim0\n  | m + 1 => succ.comp _ fun _ => const m\n\n"}
{"name":"Nat.Primrec'.head","module":"Mathlib.Computability.Primrec","initialProofState":"n : Nat\n⊢ Nat.Primrec' List.Vector.head","decl":"theorem head {n : ℕ} : @Primrec' n.succ head :=\n  (get 0).of_eq fun v => by simp [get_zero]\n\n"}
{"name":"Nat.Primrec'.tail","module":"Mathlib.Computability.Primrec","initialProofState":"n : Nat\nf : List.Vector Nat n → Nat\nhf : Nat.Primrec' f\n⊢ Nat.Primrec' fun v => f v.tail","decl":"theorem tail {n f} (hf : @Primrec' n f) : @Primrec' n.succ fun v => f v.tail :=\n  (hf.comp _ fun i => @get _ i.succ).of_eq fun v => by\n    rw [← ofFn_get v.tail]; congr; funext i; simp\n\n"}
{"name":"Nat.Primrec'.nil","module":"Mathlib.Computability.Primrec","initialProofState":"n : Nat\n⊢ Nat.Primrec'.Vec fun x => List.Vector.nil","decl":"protected theorem nil {n} : @Vec n 0 fun _ => nil := fun i => i.elim0\n\n"}
{"name":"Nat.Primrec'.cons","module":"Mathlib.Computability.Primrec","initialProofState":"n m : Nat\nf : List.Vector Nat n → Nat\ng : List.Vector Nat n → List.Vector Nat m\nhf : Nat.Primrec' f\nhg : Nat.Primrec'.Vec g\n⊢ Nat.Primrec'.Vec fun v => List.Vector.cons (f v) (g v)","decl":"protected theorem cons {n m f g} (hf : @Primrec' n f) (hg : @Vec n m g) :\n    Vec fun v => f v ::ᵥ g v := fun i => Fin.cases (by simp [*]) (fun i => by simp [hg i]) i\n\n"}
{"name":"Nat.Primrec'.idv","module":"Mathlib.Computability.Primrec","initialProofState":"n : Nat\n⊢ Nat.Primrec'.Vec id","decl":"theorem idv {n} : @Vec n n id :=\n  get\n\n"}
{"name":"Nat.Primrec'.comp'","module":"Mathlib.Computability.Primrec","initialProofState":"n m : Nat\nf : List.Vector Nat m → Nat\ng : List.Vector Nat n → List.Vector Nat m\nhf : Nat.Primrec' f\nhg : Nat.Primrec'.Vec g\n⊢ Nat.Primrec' fun v => f (g v)","decl":"theorem comp' {n m f g} (hf : @Primrec' m f) (hg : @Vec n m g) : Primrec' fun v => f (g v) :=\n  (hf.comp _ hg).of_eq fun v => by simp\n\n"}
{"name":"Nat.Primrec'.comp₁","module":"Mathlib.Computability.Primrec","initialProofState":"f : Nat → Nat\nhf : Nat.Primrec' fun v => f v.head\nn : Nat\ng : List.Vector Nat n → Nat\nhg : Nat.Primrec' g\n⊢ Nat.Primrec' fun v => f (g v)","decl":"theorem comp₁ (f : ℕ → ℕ) (hf : @Primrec' 1 fun v => f v.head) {n g} (hg : @Primrec' n g) :\n    Primrec' fun v => f (g v) :=\n  hf.comp _ fun _ => hg\n\n"}
{"name":"Nat.Primrec'.comp₂","module":"Mathlib.Computability.Primrec","initialProofState":"f : Nat → Nat → Nat\nhf : Nat.Primrec' fun v => f v.head v.tail.head\nn : Nat\ng h : List.Vector Nat n → Nat\nhg : Nat.Primrec' g\nhh : Nat.Primrec' h\n⊢ Nat.Primrec' fun v => f (g v) (h v)","decl":"theorem comp₂ (f : ℕ → ℕ → ℕ) (hf : @Primrec' 2 fun v => f v.head v.tail.head) {n g h}\n    (hg : @Primrec' n g) (hh : @Primrec' n h) : Primrec' fun v => f (g v) (h v) := by\n  simpa using hf.comp' (hg.cons <| hh.cons Primrec'.nil)\n\n"}
{"name":"Nat.Primrec'.prec'","module":"Mathlib.Computability.Primrec","initialProofState":"n : Nat\nf g : List.Vector Nat n → Nat\nh : List.Vector Nat (HAdd.hAdd n 2) → Nat\nhf : Nat.Primrec' f\nhg : Nat.Primrec' g\nhh : Nat.Primrec' h\n⊢ Nat.Primrec' fun v => Nat.rec (g v) (fun y IH => h (List.Vector.cons y (List.Vector.cons IH v))) (f v)","decl":"theorem prec' {n f g h} (hf : @Primrec' n f) (hg : @Primrec' n g) (hh : @Primrec' (n + 2) h) :\n    @Primrec' n fun v => (f v).rec (g v) fun y IH : ℕ => h (y ::ᵥ IH ::ᵥ v) := by\n  simpa using comp' (prec hg hh) (hf.cons idv)\n\n"}
{"name":"Nat.Primrec'.pred","module":"Mathlib.Computability.Primrec","initialProofState":"⊢ Nat.Primrec' fun v => v.head.pred","decl":"theorem pred : @Primrec' 1 fun v => v.head.pred :=\n  (prec' head (const 0) head).of_eq fun v => by simp; cases v.head <;> rfl\n\n"}
{"name":"Nat.Primrec'.add","module":"Mathlib.Computability.Primrec","initialProofState":"⊢ Nat.Primrec' fun v => HAdd.hAdd v.head v.tail.head","decl":"theorem add : @Primrec' 2 fun v => v.head + v.tail.head :=\n  (prec head (succ.comp₁ _ (tail head))).of_eq fun v => by\n    simp; induction v.head <;> simp [*, Nat.succ_add]\n\n"}
{"name":"Nat.Primrec'.sub","module":"Mathlib.Computability.Primrec","initialProofState":"⊢ Nat.Primrec' fun v => HSub.hSub v.head v.tail.head","decl":"theorem sub : @Primrec' 2 fun v => v.head - v.tail.head := by\n  have : @Primrec' 2 fun v ↦ (fun a b ↦ b - a) v.head v.tail.head := by\n    refine (prec head (pred.comp₁ _ (tail head))).of_eq fun v => ?_\n    simp; induction v.head <;> simp [*, Nat.sub_add_eq]\n  simpa using comp₂ (fun a b => b - a) this (tail head) head\n\n"}
{"name":"Nat.Primrec'.mul","module":"Mathlib.Computability.Primrec","initialProofState":"⊢ Nat.Primrec' fun v => HMul.hMul v.head v.tail.head","decl":"theorem mul : @Primrec' 2 fun v => v.head * v.tail.head :=\n  (prec (const 0) (tail (add.comp₂ _ (tail head) head))).of_eq fun v => by\n    simp; induction v.head <;> simp [*, Nat.succ_mul]; rw [add_comm]\n\n"}
{"name":"Nat.Primrec'.if_lt","module":"Mathlib.Computability.Primrec","initialProofState":"n : Nat\na b f g : List.Vector Nat n → Nat\nha : Nat.Primrec' a\nhb : Nat.Primrec' b\nhf : Nat.Primrec' f\nhg : Nat.Primrec' g\n⊢ Nat.Primrec' fun v => ite (LT.lt (a v) (b v)) (f v) (g v)","decl":"theorem if_lt {n a b f g} (ha : @Primrec' n a) (hb : @Primrec' n b) (hf : @Primrec' n f)\n    (hg : @Primrec' n g) : @Primrec' n fun v => if a v < b v then f v else g v :=\n  (prec' (sub.comp₂ _ hb ha) hg (tail <| tail hf)).of_eq fun v => by\n    cases e : b v - a v\n    · simp [not_lt.2 (Nat.sub_eq_zero_iff_le.mp e)]\n    · simp [Nat.lt_of_sub_eq_succ e]\n\n"}
{"name":"Nat.Primrec'.natPair","module":"Mathlib.Computability.Primrec","initialProofState":"⊢ Nat.Primrec' fun v => Nat.pair v.head v.tail.head","decl":"theorem natPair : @Primrec' 2 fun v => v.head.pair v.tail.head :=\n  if_lt head (tail head) (add.comp₂ _ (tail <| mul.comp₂ _ head head) head)\n    (add.comp₂ _ (add.comp₂ _ (mul.comp₂ _ head head) head) (tail head))\n\n"}
{"name":"Nat.Primrec'.encode","module":"Mathlib.Computability.Primrec","initialProofState":"n : Nat\n⊢ Nat.Primrec' Encodable.encode","decl":"protected theorem encode : ∀ {n}, @Primrec' n encode\n  | 0 => (const 0).of_eq fun v => by rw [v.eq_nil]; rfl\n  | _ + 1 =>\n    (succ.comp₁ _ (natPair.comp₂ _ head (tail Primrec'.encode))).of_eq fun ⟨_ :: _, _⟩ => rfl\n\n"}
{"name":"Nat.Primrec'.sqrt","module":"Mathlib.Computability.Primrec","initialProofState":"⊢ Nat.Primrec' fun v => v.head.sqrt","decl":"theorem sqrt : @Primrec' 1 fun v => v.head.sqrt := by\n  suffices H : ∀ n : ℕ, n.sqrt =\n      n.rec 0 fun x y => if x.succ < y.succ * y.succ then y else y.succ by\n    simp only [H, succ_eq_add_one]\n    have :=\n      @prec' 1 _ _\n        (fun v => by\n          have x := v.head; have y := v.tail.head\n          exact if x.succ < y.succ * y.succ then y else y.succ)\n        head (const 0) ?_\n    · exact this\n    have x1 : @Primrec' 3 fun v => v.head.succ := succ.comp₁ _ head\n    have y1 : @Primrec' 3 fun v => v.tail.head.succ := succ.comp₁ _ (tail head)\n    exact if_lt x1 (mul.comp₂ _ y1 y1) (tail head) y1\n  introv; symm\n  induction' n with n IH; · simp\n  dsimp; rw [IH]; split_ifs with h\n  · exact le_antisymm (Nat.sqrt_le_sqrt (Nat.le_succ _)) (Nat.lt_succ_iff.1 <| Nat.sqrt_lt.2 h)\n  · exact\n      Nat.eq_sqrt.2 ⟨not_lt.1 h, Nat.sqrt_lt.1 <| Nat.lt_succ_iff.2 <| Nat.sqrt_succ_le_succ_sqrt _⟩\n\n"}
{"name":"Nat.Primrec'.unpair₁","module":"Mathlib.Computability.Primrec","initialProofState":"n : Nat\nf : List.Vector Nat n → Nat\nhf : Nat.Primrec' f\n⊢ Nat.Primrec' fun v => (Nat.unpair (f v)).1","decl":"theorem unpair₁ {n f} (hf : @Primrec' n f) : @Primrec' n fun v => (f v).unpair.1 := by\n  have s := sqrt.comp₁ _ hf\n  have fss := sub.comp₂ _ hf (mul.comp₂ _ s s)\n  refine (if_lt fss s fss s).of_eq fun v => ?_\n  simp [Nat.unpair]; split_ifs <;> rfl\n\n"}
{"name":"Nat.Primrec'.unpair₂","module":"Mathlib.Computability.Primrec","initialProofState":"n : Nat\nf : List.Vector Nat n → Nat\nhf : Nat.Primrec' f\n⊢ Nat.Primrec' fun v => (Nat.unpair (f v)).2","decl":"theorem unpair₂ {n f} (hf : @Primrec' n f) : @Primrec' n fun v => (f v).unpair.2 := by\n  have s := sqrt.comp₁ _ hf\n  have fss := sub.comp₂ _ hf (mul.comp₂ _ s s)\n  refine (if_lt fss s s (sub.comp₂ _ fss s)).of_eq fun v => ?_\n  simp [Nat.unpair]; split_ifs <;> rfl\n\n"}
{"name":"Nat.Primrec'.of_prim","module":"Mathlib.Computability.Primrec","initialProofState":"n : Nat\nf : List.Vector Nat n → Nat\na✝ : Primrec f\n⊢ Nat.Primrec' f","decl":"theorem of_prim {n f} : Primrec f → @Primrec' n f :=\n  suffices ∀ f, Nat.Primrec f → @Primrec' 1 fun v => f v.head from fun hf =>\n    (pred.comp₁ _ <|\n          (this _ hf).comp₁ (fun m => Encodable.encode <| (@decode (List.Vector ℕ n) _ m).map f)\n            Primrec'.encode).of_eq\n      fun i => by simp [encodek]\n  fun f hf => by\n  induction hf with\n  | zero => exact const 0\n  | succ => exact succ\n  | left => exact unpair₁ head\n  | right => exact unpair₂ head\n  | pair _ _ hf hg => exact natPair.comp₂ _ hf hg\n  | comp _ _ hf hg => exact hf.comp₁ _ hg\n  | prec _ _ hf hg =>\n    simpa using\n      prec' (unpair₂ head) (hf.comp₁ _ (unpair₁ head))\n        (hg.comp₁ _ <|\n          natPair.comp₂ _ (unpair₁ <| tail <| tail head) (natPair.comp₂ _ head (tail head)))\n\n"}
{"name":"Nat.Primrec'.prim_iff","module":"Mathlib.Computability.Primrec","initialProofState":"n : Nat\nf : List.Vector Nat n → Nat\n⊢ Iff (Nat.Primrec' f) (Primrec f)","decl":"theorem prim_iff {n f} : @Primrec' n f ↔ Primrec f :=\n  ⟨to_prim, of_prim⟩\n\n"}
{"name":"Nat.Primrec'.prim_iff₁","module":"Mathlib.Computability.Primrec","initialProofState":"f : Nat → Nat\n⊢ Iff (Nat.Primrec' fun v => f v.head) (Primrec f)","decl":"theorem prim_iff₁ {f : ℕ → ℕ} : (@Primrec' 1 fun v => f v.head) ↔ Primrec f :=\n  prim_iff.trans\n    ⟨fun h => (h.comp <| .vector_ofFn fun _ => .id).of_eq fun v => by simp, fun h =>\n      h.comp .vector_head⟩\n\n"}
{"name":"Nat.Primrec'.prim_iff₂","module":"Mathlib.Computability.Primrec","initialProofState":"f : Nat → Nat → Nat\n⊢ Iff (Nat.Primrec' fun v => f v.head v.tail.head) (Primrec₂ f)","decl":"theorem prim_iff₂ {f : ℕ → ℕ → ℕ} : (@Primrec' 2 fun v => f v.head v.tail.head) ↔ Primrec₂ f :=\n  prim_iff.trans\n    ⟨fun h => (h.comp <| Primrec.vector_cons.comp .fst <|\n      Primrec.vector_cons.comp .snd (.const nil)).of_eq fun v => by simp,\n    fun h => h.comp .vector_head (Primrec.vector_head.comp .vector_tail)⟩\n\n"}
{"name":"Nat.Primrec'.vec_iff","module":"Mathlib.Computability.Primrec","initialProofState":"m n : Nat\nf : List.Vector Nat m → List.Vector Nat n\n⊢ Iff (Nat.Primrec'.Vec f) (Primrec f)","decl":"theorem vec_iff {m n f} : @Vec m n f ↔ Primrec f :=\n  ⟨fun h => by simpa using Primrec.vector_ofFn fun i => to_prim (h i), fun h i =>\n    of_prim <| Primrec.vector_get.comp h (.const i)⟩\n\n"}
{"name":"Primrec.nat_sqrt","module":"Mathlib.Computability.Primrec","initialProofState":"⊢ Primrec Nat.sqrt","decl":"theorem Primrec.nat_sqrt : Primrec Nat.sqrt :=\n  Nat.Primrec'.prim_iff₁.1 Nat.Primrec'.sqrt\n"}
