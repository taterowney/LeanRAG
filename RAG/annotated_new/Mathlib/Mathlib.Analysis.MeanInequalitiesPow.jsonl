{"name":"Real.pow_arith_mean_le_arith_mean_pow","module":"Mathlib.Analysis.MeanInequalitiesPow","initialProofState":"ι : Type u\ns : Finset ι\nw z : ι → Real\nhw : ∀ (i : ι), Membership.mem s i → LE.le 0 (w i)\nhw' : Eq (s.sum fun i => w i) 1\nhz : ∀ (i : ι), Membership.mem s i → LE.le 0 (z i)\nn : Nat\n⊢ LE.le (HPow.hPow (s.sum fun i => HMul.hMul (w i) (z i)) n) (s.sum fun i => HMul.hMul (w i) (HPow.hPow (z i) n))","decl":"theorem pow_arith_mean_le_arith_mean_pow (w z : ι → ℝ) (hw : ∀ i ∈ s, 0 ≤ w i)\n    (hw' : ∑ i ∈ s, w i = 1) (hz : ∀ i ∈ s, 0 ≤ z i) (n : ℕ) :\n    (∑ i ∈ s, w i * z i) ^ n ≤ ∑ i ∈ s, w i * z i ^ n :=\n  (convexOn_pow n).map_sum_le hw hw' hz\n\n"}
{"name":"Real.pow_arith_mean_le_arith_mean_pow_of_even","module":"Mathlib.Analysis.MeanInequalitiesPow","initialProofState":"ι : Type u\ns : Finset ι\nw z : ι → Real\nhw : ∀ (i : ι), Membership.mem s i → LE.le 0 (w i)\nhw' : Eq (s.sum fun i => w i) 1\nn : Nat\nhn : Even n\n⊢ LE.le (HPow.hPow (s.sum fun i => HMul.hMul (w i) (z i)) n) (s.sum fun i => HMul.hMul (w i) (HPow.hPow (z i) n))","decl":"theorem pow_arith_mean_le_arith_mean_pow_of_even (w z : ι → ℝ) (hw : ∀ i ∈ s, 0 ≤ w i)\n    (hw' : ∑ i ∈ s, w i = 1) {n : ℕ} (hn : Even n) :\n    (∑ i ∈ s, w i * z i) ^ n ≤ ∑ i ∈ s, w i * z i ^ n :=\n  hn.convexOn_pow.map_sum_le hw hw' fun _ _ => Set.mem_univ _\n\n"}
{"name":"Real.zpow_arith_mean_le_arith_mean_zpow","module":"Mathlib.Analysis.MeanInequalitiesPow","initialProofState":"ι : Type u\ns : Finset ι\nw z : ι → Real\nhw : ∀ (i : ι), Membership.mem s i → LE.le 0 (w i)\nhw' : Eq (s.sum fun i => w i) 1\nhz : ∀ (i : ι), Membership.mem s i → LT.lt 0 (z i)\nm : Int\n⊢ LE.le (HPow.hPow (s.sum fun i => HMul.hMul (w i) (z i)) m) (s.sum fun i => HMul.hMul (w i) (HPow.hPow (z i) m))","decl":"theorem zpow_arith_mean_le_arith_mean_zpow (w z : ι → ℝ) (hw : ∀ i ∈ s, 0 ≤ w i)\n    (hw' : ∑ i ∈ s, w i = 1) (hz : ∀ i ∈ s, 0 < z i) (m : ℤ) :\n    (∑ i ∈ s, w i * z i) ^ m ≤ ∑ i ∈ s, w i * z i ^ m :=\n  (convexOn_zpow m).map_sum_le hw hw' hz\n\n"}
{"name":"Real.rpow_arith_mean_le_arith_mean_rpow","module":"Mathlib.Analysis.MeanInequalitiesPow","initialProofState":"ι : Type u\ns : Finset ι\nw z : ι → Real\nhw : ∀ (i : ι), Membership.mem s i → LE.le 0 (w i)\nhw' : Eq (s.sum fun i => w i) 1\nhz : ∀ (i : ι), Membership.mem s i → LE.le 0 (z i)\np : Real\nhp : LE.le 1 p\n⊢ LE.le (HPow.hPow (s.sum fun i => HMul.hMul (w i) (z i)) p) (s.sum fun i => HMul.hMul (w i) (HPow.hPow (z i) p))","decl":"theorem rpow_arith_mean_le_arith_mean_rpow (w z : ι → ℝ) (hw : ∀ i ∈ s, 0 ≤ w i)\n    (hw' : ∑ i ∈ s, w i = 1) (hz : ∀ i ∈ s, 0 ≤ z i) {p : ℝ} (hp : 1 ≤ p) :\n    (∑ i ∈ s, w i * z i) ^ p ≤ ∑ i ∈ s, w i * z i ^ p :=\n  (convexOn_rpow hp).map_sum_le hw hw' hz\n\n"}
{"name":"Real.arith_mean_le_rpow_mean","module":"Mathlib.Analysis.MeanInequalitiesPow","initialProofState":"ι : Type u\ns : Finset ι\nw z : ι → Real\nhw : ∀ (i : ι), Membership.mem s i → LE.le 0 (w i)\nhw' : Eq (s.sum fun i => w i) 1\nhz : ∀ (i : ι), Membership.mem s i → LE.le 0 (z i)\np : Real\nhp : LE.le 1 p\n⊢ LE.le (s.sum fun i => HMul.hMul (w i) (z i)) (HPow.hPow (s.sum fun i => HMul.hMul (w i) (HPow.hPow (z i) p)) (HDiv.hDiv 1 p))","decl":"theorem arith_mean_le_rpow_mean (w z : ι → ℝ) (hw : ∀ i ∈ s, 0 ≤ w i) (hw' : ∑ i ∈ s, w i = 1)\n    (hz : ∀ i ∈ s, 0 ≤ z i) {p : ℝ} (hp : 1 ≤ p) :\n    ∑ i ∈ s, w i * z i ≤ (∑ i ∈ s, w i * z i ^ p) ^ (1 / p) := by\n  have : 0 < p := by positivity\n  rw [← rpow_le_rpow_iff _ _ this, ← rpow_mul, one_div_mul_cancel (ne_of_gt this), rpow_one]\n  · exact rpow_arith_mean_le_arith_mean_rpow s w z hw hw' hz hp\n  all_goals\n    apply_rules [sum_nonneg, rpow_nonneg]\n    intro i hi\n    apply_rules [mul_nonneg, rpow_nonneg, hw i hi, hz i hi]\n\n"}
{"name":"NNReal.pow_arith_mean_le_arith_mean_pow","module":"Mathlib.Analysis.MeanInequalitiesPow","initialProofState":"ι : Type u\ns : Finset ι\nw z : ι → NNReal\nhw' : Eq (s.sum fun i => w i) 1\nn : Nat\n⊢ LE.le (HPow.hPow (s.sum fun i => HMul.hMul (w i) (z i)) n) (s.sum fun i => HMul.hMul (w i) (HPow.hPow (z i) n))","decl":"/-- Weighted generalized mean inequality, version sums over finite sets, with `ℝ≥0`-valued\nfunctions and natural exponent. -/\ntheorem pow_arith_mean_le_arith_mean_pow (w z : ι → ℝ≥0) (hw' : ∑ i ∈ s, w i = 1) (n : ℕ) :\n    (∑ i ∈ s, w i * z i) ^ n ≤ ∑ i ∈ s, w i * z i ^ n :=\n  mod_cast\n    Real.pow_arith_mean_le_arith_mean_pow s _ _ (fun i _ => (w i).coe_nonneg)\n      (mod_cast hw') (fun i _ => (z i).coe_nonneg) n\n\n"}
{"name":"NNReal.rpow_arith_mean_le_arith_mean_rpow","module":"Mathlib.Analysis.MeanInequalitiesPow","initialProofState":"ι : Type u\ns : Finset ι\nw z : ι → NNReal\nhw' : Eq (s.sum fun i => w i) 1\np : Real\nhp : LE.le 1 p\n⊢ LE.le (HPow.hPow (s.sum fun i => HMul.hMul (w i) (z i)) p) (s.sum fun i => HMul.hMul (w i) (HPow.hPow (z i) p))","decl":"/-- Weighted generalized mean inequality, version for sums over finite sets, with `ℝ≥0`-valued\nfunctions and real exponents. -/\ntheorem rpow_arith_mean_le_arith_mean_rpow (w z : ι → ℝ≥0) (hw' : ∑ i ∈ s, w i = 1) {p : ℝ}\n    (hp : 1 ≤ p) : (∑ i ∈ s, w i * z i) ^ p ≤ ∑ i ∈ s, w i * z i ^ p :=\n  mod_cast\n    Real.rpow_arith_mean_le_arith_mean_rpow s _ _ (fun i _ => (w i).coe_nonneg)\n      (mod_cast hw') (fun i _ => (z i).coe_nonneg) hp\n\n"}
{"name":"NNReal.rpow_arith_mean_le_arith_mean2_rpow","module":"Mathlib.Analysis.MeanInequalitiesPow","initialProofState":"w₁ w₂ z₁ z₂ : NNReal\nhw' : Eq (HAdd.hAdd w₁ w₂) 1\np : Real\nhp : LE.le 1 p\n⊢ LE.le (HPow.hPow (HAdd.hAdd (HMul.hMul w₁ z₁) (HMul.hMul w₂ z₂)) p) (HAdd.hAdd (HMul.hMul w₁ (HPow.hPow z₁ p)) (HMul.hMul w₂ (HPow.hPow z₂ p)))","decl":"/-- Weighted generalized mean inequality, version for two elements of `ℝ≥0` and real exponents. -/\ntheorem rpow_arith_mean_le_arith_mean2_rpow (w₁ w₂ z₁ z₂ : ℝ≥0) (hw' : w₁ + w₂ = 1) {p : ℝ}\n    (hp : 1 ≤ p) : (w₁ * z₁ + w₂ * z₂) ^ p ≤ w₁ * z₁ ^ p + w₂ * z₂ ^ p := by\n  have h := rpow_arith_mean_le_arith_mean_rpow univ ![w₁, w₂] ![z₁, z₂] ?_ hp\n  · simpa [Fin.sum_univ_succ] using h\n  · simp [hw', Fin.sum_univ_succ]\n\n"}
{"name":"NNReal.rpow_add_le_mul_rpow_add_rpow","module":"Mathlib.Analysis.MeanInequalitiesPow","initialProofState":"z₁ z₂ : NNReal\np : Real\nhp : LE.le 1 p\n⊢ LE.le (HPow.hPow (HAdd.hAdd z₁ z₂) p) (HMul.hMul (HPow.hPow 2 (HSub.hSub p 1)) (HAdd.hAdd (HPow.hPow z₁ p) (HPow.hPow z₂ p)))","decl":"/-- Unweighted mean inequality, version for two elements of `ℝ≥0` and real exponents. -/\ntheorem rpow_add_le_mul_rpow_add_rpow (z₁ z₂ : ℝ≥0) {p : ℝ} (hp : 1 ≤ p) :\n    (z₁ + z₂) ^ p ≤ (2 : ℝ≥0) ^ (p - 1) * (z₁ ^ p + z₂ ^ p) := by\n  rcases eq_or_lt_of_le hp with (rfl | h'p)\n  · simp only [rpow_one, sub_self, rpow_zero, one_mul]; rfl\n  convert rpow_arith_mean_le_arith_mean2_rpow (1 / 2) (1 / 2) (2 * z₁) (2 * z₂) (add_halves 1) hp\n    using 1\n  · simp only [one_div, inv_mul_cancel_left₀, Ne, mul_eq_zero, two_ne_zero, one_ne_zero,\n      not_false_iff]\n  · have A : p - 1 ≠ 0 := ne_of_gt (sub_pos.2 h'p)\n    simp only [mul_rpow, rpow_sub' A, div_eq_inv_mul, rpow_one, mul_one]\n    ring\n\n"}
{"name":"NNReal.arith_mean_le_rpow_mean","module":"Mathlib.Analysis.MeanInequalitiesPow","initialProofState":"ι : Type u\ns : Finset ι\nw z : ι → NNReal\nhw' : Eq (s.sum fun i => w i) 1\np : Real\nhp : LE.le 1 p\n⊢ LE.le (s.sum fun i => HMul.hMul (w i) (z i)) (HPow.hPow (s.sum fun i => HMul.hMul (w i) (HPow.hPow (z i) p)) (HDiv.hDiv 1 p))","decl":"/-- Weighted generalized mean inequality, version for sums over finite sets, with `ℝ≥0`-valued\nfunctions and real exponents. -/\ntheorem arith_mean_le_rpow_mean (w z : ι → ℝ≥0) (hw' : ∑ i ∈ s, w i = 1) {p : ℝ} (hp : 1 ≤ p) :\n    ∑ i ∈ s, w i * z i ≤ (∑ i ∈ s, w i * z i ^ p) ^ (1 / p) :=\n  mod_cast\n    Real.arith_mean_le_rpow_mean s _ _ (fun i _ => (w i).coe_nonneg) (mod_cast hw')\n      (fun i _ => (z i).coe_nonneg) hp\n\n"}
{"name":"NNReal.add_rpow_le_rpow_add","module":"Mathlib.Analysis.MeanInequalitiesPow","initialProofState":"p : Real\na b : NNReal\nhp1 : LE.le 1 p\n⊢ LE.le (HAdd.hAdd (HPow.hPow a p) (HPow.hPow b p)) (HPow.hPow (HAdd.hAdd a b) p)","decl":"theorem add_rpow_le_rpow_add {p : ℝ} (a b : ℝ≥0) (hp1 : 1 ≤ p) : a ^ p + b ^ p ≤ (a + b) ^ p := by\n  have hp_pos : 0 < p := by positivity\n  by_cases h_zero : a + b = 0\n  · simp [add_eq_zero.mp h_zero, hp_pos.ne']\n  have h_nonzero : ¬(a = 0 ∧ b = 0) := by rwa [add_eq_zero] at h_zero\n  have h_add : a / (a + b) + b / (a + b) = 1 := by rw [div_add_div_same, div_self h_zero]\n  have h := add_rpow_le_one_of_add_le_one (a / (a + b)) (b / (a + b)) h_add.le hp1\n  rw [div_rpow a (a + b), div_rpow b (a + b)] at h\n  have hab_0 : (a + b) ^ p ≠ 0 := by simp [hp_pos, h_nonzero]\n  have hab_0' : 0 < (a + b) ^ p := zero_lt_iff.mpr hab_0\n  have h_mul : (a + b) ^ p * (a ^ p / (a + b) ^ p + b ^ p / (a + b) ^ p) ≤ (a + b) ^ p := by\n    nth_rw 4 [← mul_one ((a + b) ^ p)]\n    exact (mul_le_mul_left hab_0').mpr h\n  rwa [div_eq_mul_inv, div_eq_mul_inv, mul_add, mul_comm (a ^ p), mul_comm (b ^ p), ← mul_assoc, ←\n    mul_assoc, mul_inv_cancel₀ hab_0, one_mul, one_mul] at h_mul\n\n"}
{"name":"NNReal.rpow_add_rpow_le_add","module":"Mathlib.Analysis.MeanInequalitiesPow","initialProofState":"p : Real\na b : NNReal\nhp1 : LE.le 1 p\n⊢ LE.le (HPow.hPow (HAdd.hAdd (HPow.hPow a p) (HPow.hPow b p)) (HDiv.hDiv 1 p)) (HAdd.hAdd a b)","decl":"theorem rpow_add_rpow_le_add {p : ℝ} (a b : ℝ≥0) (hp1 : 1 ≤ p) :\n    (a ^ p + b ^ p) ^ (1 / p) ≤ a + b := by\n  rw [one_div]\n  rw [← @NNReal.le_rpow_inv_iff _ _ p⁻¹ (by simp [lt_of_lt_of_le zero_lt_one hp1])]\n  rw [inv_inv]\n  exact add_rpow_le_rpow_add _ _ hp1\n\n"}
{"name":"NNReal.rpow_add_rpow_le","module":"Mathlib.Analysis.MeanInequalitiesPow","initialProofState":"p q : Real\na b : NNReal\nhp_pos : LT.lt 0 p\nhpq : LE.le p q\n⊢ LE.le (HPow.hPow (HAdd.hAdd (HPow.hPow a q) (HPow.hPow b q)) (HDiv.hDiv 1 q)) (HPow.hPow (HAdd.hAdd (HPow.hPow a p) (HPow.hPow b p)) (HDiv.hDiv 1 p))","decl":"theorem rpow_add_rpow_le {p q : ℝ} (a b : ℝ≥0) (hp_pos : 0 < p) (hpq : p ≤ q) :\n    (a ^ q + b ^ q) ^ (1 / q) ≤ (a ^ p + b ^ p) ^ (1 / p) := by\n  have h_rpow : ∀ a : ℝ≥0, a ^ q = (a ^ p) ^ (q / p) := fun a => by\n    rw [← NNReal.rpow_mul, div_eq_inv_mul, ← mul_assoc, mul_inv_cancel₀ hp_pos.ne.symm,\n      one_mul]\n  have h_rpow_add_rpow_le_add :\n    ((a ^ p) ^ (q / p) + (b ^ p) ^ (q / p)) ^ (1 / (q / p)) ≤ a ^ p + b ^ p := by\n    refine rpow_add_rpow_le_add (a ^ p) (b ^ p) ?_\n    rwa [one_le_div hp_pos]\n  rw [h_rpow a, h_rpow b, one_div p, NNReal.le_rpow_inv_iff hp_pos, ← NNReal.rpow_mul, mul_comm,\n    mul_one_div]\n  rwa [one_div_div] at h_rpow_add_rpow_le_add\n\n"}
{"name":"NNReal.rpow_add_le_add_rpow","module":"Mathlib.Analysis.MeanInequalitiesPow","initialProofState":"p : Real\na b : NNReal\nhp : LE.le 0 p\nhp1 : LE.le p 1\n⊢ LE.le (HPow.hPow (HAdd.hAdd a b) p) (HAdd.hAdd (HPow.hPow a p) (HPow.hPow b p))","decl":"theorem rpow_add_le_add_rpow {p : ℝ} (a b : ℝ≥0) (hp : 0 ≤ p) (hp1 : p ≤ 1) :\n    (a + b) ^ p ≤ a ^ p + b ^ p := by\n  rcases hp.eq_or_lt with (rfl | hp_pos)\n  · simp\n  have h := rpow_add_rpow_le a b hp_pos hp1\n  rw [one_div_one, one_div] at h\n  repeat' rw [NNReal.rpow_one] at h\n  exact (NNReal.le_rpow_inv_iff hp_pos).mp h\n\n"}
{"name":"Real.add_rpow_le_rpow_add","module":"Mathlib.Analysis.MeanInequalitiesPow","initialProofState":"p a b : Real\nha : LE.le 0 a\nhb : LE.le 0 b\nhp1 : LE.le 1 p\n⊢ LE.le (HAdd.hAdd (HPow.hPow a p) (HPow.hPow b p)) (HPow.hPow (HAdd.hAdd a b) p)","decl":"lemma add_rpow_le_rpow_add {p : ℝ} {a b : ℝ} (ha : 0 ≤ a) (hb : 0 ≤ b) (hp1 : 1 ≤ p) :\n     a ^ p + b ^ p ≤ (a + b) ^ p := by\n  lift a to NNReal using ha\n  lift b to NNReal using hb\n  exact_mod_cast NNReal.add_rpow_le_rpow_add a b hp1\n\n"}
{"name":"Real.rpow_add_rpow_le_add","module":"Mathlib.Analysis.MeanInequalitiesPow","initialProofState":"p a b : Real\nha : LE.le 0 a\nhb : LE.le 0 b\nhp1 : LE.le 1 p\n⊢ LE.le (HPow.hPow (HAdd.hAdd (HPow.hPow a p) (HPow.hPow b p)) (HDiv.hDiv 1 p)) (HAdd.hAdd a b)","decl":"lemma rpow_add_rpow_le_add {p : ℝ} {a b : ℝ} (ha : 0 ≤ a) (hb : 0 ≤ b) (hp1 : 1 ≤ p) :\n    (a ^ p + b ^ p) ^ (1 / p) ≤ a + b := by\n  lift a to NNReal using ha\n  lift b to NNReal using hb\n  exact_mod_cast NNReal.rpow_add_rpow_le_add a b hp1\n\n"}
{"name":"Real.rpow_add_rpow_le","module":"Mathlib.Analysis.MeanInequalitiesPow","initialProofState":"p q a b : Real\nha : LE.le 0 a\nhb : LE.le 0 b\nhp_pos : LT.lt 0 p\nhpq : LE.le p q\n⊢ LE.le (HPow.hPow (HAdd.hAdd (HPow.hPow a q) (HPow.hPow b q)) (HDiv.hDiv 1 q)) (HPow.hPow (HAdd.hAdd (HPow.hPow a p) (HPow.hPow b p)) (HDiv.hDiv 1 p))","decl":"lemma rpow_add_rpow_le {p q : ℝ} {a b : ℝ} (ha : 0 ≤ a) (hb : 0 ≤ b) (hp_pos : 0 < p)\n    (hpq : p ≤ q) :\n    (a ^ q + b ^ q) ^ (1 / q) ≤ (a ^ p + b ^ p) ^ (1 / p) := by\n  lift a to NNReal using ha\n  lift b to NNReal using hb\n  exact_mod_cast NNReal.rpow_add_rpow_le a b hp_pos hpq\n\n"}
{"name":"Real.rpow_add_le_add_rpow","module":"Mathlib.Analysis.MeanInequalitiesPow","initialProofState":"p a b : Real\nha : LE.le 0 a\nhb : LE.le 0 b\nhp : LE.le 0 p\nhp1 : LE.le p 1\n⊢ LE.le (HPow.hPow (HAdd.hAdd a b) p) (HAdd.hAdd (HPow.hPow a p) (HPow.hPow b p))","decl":"lemma rpow_add_le_add_rpow {p : ℝ} {a b : ℝ} (ha : 0 ≤ a) (hb : 0 ≤ b) (hp : 0 ≤ p)\n    (hp1 : p ≤ 1) :\n    (a + b) ^ p ≤ a ^ p + b ^ p := by\n  lift a to NNReal using ha\n  lift b to NNReal using hb\n  exact_mod_cast NNReal.rpow_add_le_add_rpow a b hp hp1\n\n"}
{"name":"ENNReal.rpow_arith_mean_le_arith_mean_rpow","module":"Mathlib.Analysis.MeanInequalitiesPow","initialProofState":"ι : Type u\ns : Finset ι\nw z : ι → ENNReal\nhw' : Eq (s.sum fun i => w i) 1\np : Real\nhp : LE.le 1 p\n⊢ LE.le (HPow.hPow (s.sum fun i => HMul.hMul (w i) (z i)) p) (s.sum fun i => HMul.hMul (w i) (HPow.hPow (z i) p))","decl":"/-- Weighted generalized mean inequality, version for sums over finite sets, with `ℝ≥0∞`-valued\nfunctions and real exponents. -/\ntheorem rpow_arith_mean_le_arith_mean_rpow (w z : ι → ℝ≥0∞) (hw' : ∑ i ∈ s, w i = 1) {p : ℝ}\n    (hp : 1 ≤ p) : (∑ i ∈ s, w i * z i) ^ p ≤ ∑ i ∈ s, w i * z i ^ p := by\n  have hp_pos : 0 < p := by positivity\n  have hp_nonneg : 0 ≤ p := by positivity\n  have hp_not_neg : ¬p < 0 := by simp [hp_nonneg]\n  have h_top_iff_rpow_top : ∀ (i : ι), i ∈ s → (w i * z i = ⊤ ↔ w i * z i ^ p = ⊤) := by\n    simp [ENNReal.mul_eq_top, hp_pos, hp_nonneg, hp_not_neg]\n  refine le_of_top_imp_top_of_toNNReal_le ?_ ?_\n  · -- first, prove `(∑ i ∈ s, w i * z i) ^ p = ⊤ → ∑ i ∈ s, (w i * z i ^ p) = ⊤`\n    rw [rpow_eq_top_iff, sum_eq_top, sum_eq_top]\n    intro h\n    simp only [and_false, hp_not_neg, false_or] at h\n    rcases h.left with ⟨a, H, ha⟩\n    use a, H\n    rwa [← h_top_iff_rpow_top a H]\n  · -- second, suppose both `(∑ i ∈ s, w i * z i) ^ p ≠ ⊤` and `∑ i ∈ s, (w i * z i ^ p) ≠ ⊤`,\n    -- and prove `((∑ i ∈ s, w i * z i) ^ p).toNNReal ≤ (∑ i ∈ s, (w i * z i ^ p)).toNNReal`,\n    -- by using `NNReal.rpow_arith_mean_le_arith_mean_rpow`.\n    intro h_top_rpow_sum _\n    -- show hypotheses needed to put the `.toNNReal` inside the sums.\n    have h_top : ∀ a : ι, a ∈ s → w a * z a ≠ ⊤ :=\n      haveI h_top_sum : ∑ i ∈ s, w i * z i ≠ ⊤ := by\n        intro h\n        rw [h, top_rpow_of_pos hp_pos] at h_top_rpow_sum\n        exact h_top_rpow_sum rfl\n      fun a ha => (lt_top_of_sum_ne_top h_top_sum ha).ne\n    have h_top_rpow : ∀ a : ι, a ∈ s → w a * z a ^ p ≠ ⊤ := by\n      intro i hi\n      specialize h_top i hi\n      rwa [Ne, ← h_top_iff_rpow_top i hi]\n    -- put the `.toNNReal` inside the sums.\n    simp_rw [toNNReal_sum h_top_rpow, toNNReal_rpow, toNNReal_sum h_top, toNNReal_mul,\n      toNNReal_rpow]\n    -- use corresponding nnreal result\n    refine\n      NNReal.rpow_arith_mean_le_arith_mean_rpow s (fun i => (w i).toNNReal)\n        (fun i => (z i).toNNReal) ?_ hp\n    -- verify the hypothesis `∑ i ∈ s, (w i).toNNReal = 1`, using `∑ i ∈ s, w i = 1` .\n    have h_sum_nnreal : ∑ i ∈ s, w i = ↑(∑ i ∈ s, (w i).toNNReal) := by\n      rw [coe_finset_sum]\n      refine sum_congr rfl fun i hi => (coe_toNNReal ?_).symm\n      refine (lt_top_of_sum_ne_top ?_ hi).ne\n      exact hw'.symm ▸ ENNReal.one_ne_top\n    rwa [← coe_inj, ← h_sum_nnreal]\n\n"}
{"name":"ENNReal.rpow_arith_mean_le_arith_mean2_rpow","module":"Mathlib.Analysis.MeanInequalitiesPow","initialProofState":"w₁ w₂ z₁ z₂ : ENNReal\nhw' : Eq (HAdd.hAdd w₁ w₂) 1\np : Real\nhp : LE.le 1 p\n⊢ LE.le (HPow.hPow (HAdd.hAdd (HMul.hMul w₁ z₁) (HMul.hMul w₂ z₂)) p) (HAdd.hAdd (HMul.hMul w₁ (HPow.hPow z₁ p)) (HMul.hMul w₂ (HPow.hPow z₂ p)))","decl":"/-- Weighted generalized mean inequality, version for two elements of `ℝ≥0∞` and real\nexponents. -/\ntheorem rpow_arith_mean_le_arith_mean2_rpow (w₁ w₂ z₁ z₂ : ℝ≥0∞) (hw' : w₁ + w₂ = 1) {p : ℝ}\n    (hp : 1 ≤ p) : (w₁ * z₁ + w₂ * z₂) ^ p ≤ w₁ * z₁ ^ p + w₂ * z₂ ^ p := by\n  have h := rpow_arith_mean_le_arith_mean_rpow univ ![w₁, w₂] ![z₁, z₂] ?_ hp\n  · simpa [Fin.sum_univ_succ] using h\n  · simp [hw', Fin.sum_univ_succ]\n\n"}
{"name":"ENNReal.rpow_add_le_mul_rpow_add_rpow","module":"Mathlib.Analysis.MeanInequalitiesPow","initialProofState":"z₁ z₂ : ENNReal\np : Real\nhp : LE.le 1 p\n⊢ LE.le (HPow.hPow (HAdd.hAdd z₁ z₂) p) (HMul.hMul (HPow.hPow 2 (HSub.hSub p 1)) (HAdd.hAdd (HPow.hPow z₁ p) (HPow.hPow z₂ p)))","decl":"/-- Unweighted mean inequality, version for two elements of `ℝ≥0∞` and real exponents. -/\ntheorem rpow_add_le_mul_rpow_add_rpow (z₁ z₂ : ℝ≥0∞) {p : ℝ} (hp : 1 ≤ p) :\n    (z₁ + z₂) ^ p ≤ (2 : ℝ≥0∞) ^ (p - 1) * (z₁ ^ p + z₂ ^ p) := by\n  convert rpow_arith_mean_le_arith_mean2_rpow (1 / 2) (1 / 2) (2 * z₁) (2 * z₂)\n      (ENNReal.add_halves 1) hp using 1\n  · simp [← mul_assoc, ENNReal.inv_mul_cancel two_ne_zero ofNat_ne_top]\n  · simp only [mul_rpow_of_nonneg _ _ (zero_le_one.trans hp), rpow_sub _ _ two_ne_zero ofNat_ne_top,\n      ENNReal.div_eq_inv_mul, rpow_one, mul_one]\n    ring\n\n"}
{"name":"ENNReal.add_rpow_le_rpow_add","module":"Mathlib.Analysis.MeanInequalitiesPow","initialProofState":"p : Real\na b : ENNReal\nhp1 : LE.le 1 p\n⊢ LE.le (HAdd.hAdd (HPow.hPow a p) (HPow.hPow b p)) (HPow.hPow (HAdd.hAdd a b) p)","decl":"theorem add_rpow_le_rpow_add {p : ℝ} (a b : ℝ≥0∞) (hp1 : 1 ≤ p) : a ^ p + b ^ p ≤ (a + b) ^ p := by\n  have hp_pos : 0 < p := by positivity\n  by_cases h_top : a + b = ⊤\n  · rw [← @ENNReal.rpow_eq_top_iff_of_pos (a + b) p hp_pos] at h_top\n    rw [h_top]\n    exact le_top\n  obtain ⟨ha_top, hb_top⟩ := add_ne_top.mp h_top\n  lift a to ℝ≥0 using ha_top\n  lift b to ℝ≥0 using hb_top\n  simpa [ENNReal.coe_rpow_of_nonneg _ hp_pos.le] using\n    ENNReal.coe_le_coe.2 (NNReal.add_rpow_le_rpow_add a b hp1)\n\n"}
{"name":"ENNReal.rpow_add_rpow_le_add","module":"Mathlib.Analysis.MeanInequalitiesPow","initialProofState":"p : Real\na b : ENNReal\nhp1 : LE.le 1 p\n⊢ LE.le (HPow.hPow (HAdd.hAdd (HPow.hPow a p) (HPow.hPow b p)) (HDiv.hDiv 1 p)) (HAdd.hAdd a b)","decl":"theorem rpow_add_rpow_le_add {p : ℝ} (a b : ℝ≥0∞) (hp1 : 1 ≤ p) :\n    (a ^ p + b ^ p) ^ (1 / p) ≤ a + b := by\n  rw [one_div, ← @ENNReal.le_rpow_inv_iff _ _ p⁻¹ (by simp [lt_of_lt_of_le zero_lt_one hp1])]\n  rw [inv_inv]\n  exact add_rpow_le_rpow_add _ _ hp1\n\n"}
{"name":"ENNReal.rpow_add_rpow_le","module":"Mathlib.Analysis.MeanInequalitiesPow","initialProofState":"p q : Real\na b : ENNReal\nhp_pos : LT.lt 0 p\nhpq : LE.le p q\n⊢ LE.le (HPow.hPow (HAdd.hAdd (HPow.hPow a q) (HPow.hPow b q)) (HDiv.hDiv 1 q)) (HPow.hPow (HAdd.hAdd (HPow.hPow a p) (HPow.hPow b p)) (HDiv.hDiv 1 p))","decl":"theorem rpow_add_rpow_le {p q : ℝ} (a b : ℝ≥0∞) (hp_pos : 0 < p) (hpq : p ≤ q) :\n    (a ^ q + b ^ q) ^ (1 / q) ≤ (a ^ p + b ^ p) ^ (1 / p) := by\n  have h_rpow : ∀ a : ℝ≥0∞, a ^ q = (a ^ p) ^ (q / p) := fun a => by\n    rw [← ENNReal.rpow_mul, mul_div_cancel₀ _ hp_pos.ne']\n  have h_rpow_add_rpow_le_add :\n    ((a ^ p) ^ (q / p) + (b ^ p) ^ (q / p)) ^ (1 / (q / p)) ≤ a ^ p + b ^ p := by\n    refine rpow_add_rpow_le_add (a ^ p) (b ^ p) ?_\n    rwa [one_le_div hp_pos]\n  rw [h_rpow a, h_rpow b, one_div p, ENNReal.le_rpow_inv_iff hp_pos, ← ENNReal.rpow_mul, mul_comm,\n    mul_one_div]\n  rwa [one_div_div] at h_rpow_add_rpow_le_add\n\n"}
{"name":"ENNReal.rpow_add_le_add_rpow","module":"Mathlib.Analysis.MeanInequalitiesPow","initialProofState":"p : Real\na b : ENNReal\nhp : LE.le 0 p\nhp1 : LE.le p 1\n⊢ LE.le (HPow.hPow (HAdd.hAdd a b) p) (HAdd.hAdd (HPow.hPow a p) (HPow.hPow b p))","decl":"theorem rpow_add_le_add_rpow {p : ℝ} (a b : ℝ≥0∞) (hp : 0 ≤ p) (hp1 : p ≤ 1) :\n    (a + b) ^ p ≤ a ^ p + b ^ p := by\n  rcases hp.eq_or_lt with (rfl | hp_pos)\n  · simp\n  have h := rpow_add_rpow_le a b hp_pos hp1\n  rw [one_div_one, one_div] at h\n  repeat' rw [ENNReal.rpow_one] at h\n  exact (ENNReal.le_rpow_inv_iff hp_pos).mp h\n\n"}
