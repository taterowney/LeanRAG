{"name":"IsRefl.reflexive","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\ninst✝ : IsRefl α r\n⊢ Reflexive r","decl":"theorem IsRefl.reflexive [IsRefl α r] : Reflexive r := fun x ↦ IsRefl.refl x\n\n"}
{"name":"Reflexive.rel_of_ne_imp","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\nh : Reflexive r\nx y : α\nhr : Ne x y → r x y\n⊢ r x y","decl":"/-- To show a reflexive relation `r : α → α → Prop` holds over `x y : α`,\nit suffices to show it holds when `x ≠ y`. -/\ntheorem Reflexive.rel_of_ne_imp (h : Reflexive r) {x y : α} (hr : x ≠ y → r x y) : r x y := by\n  by_cases hxy : x = y\n  · exact hxy ▸ h x\n  · exact hr hxy\n\n\n"}
{"name":"Reflexive.ne_imp_iff","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\nh : Reflexive r\nx y : α\n⊢ Iff (Ne x y → r x y) (r x y)","decl":"/-- If a reflexive relation `r : α → α → Prop` holds over `x y : α`,\nthen it holds whether or not `x ≠ y`. -/\ntheorem Reflexive.ne_imp_iff (h : Reflexive r) {x y : α} : x ≠ y → r x y ↔ r x y :=\n  ⟨h.rel_of_ne_imp, fun hr _ ↦ hr⟩\n\n"}
{"name":"reflexive_ne_imp_iff","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\ninst✝ : IsRefl α r\nx y : α\n⊢ Iff (Ne x y → r x y) (r x y)","decl":"/-- If a reflexive relation `r : α → α → Prop` holds over `x y : α`,\nthen it holds whether or not `x ≠ y`. Unlike `Reflexive.ne_imp_iff`, this uses `[IsRefl α r]`. -/\ntheorem reflexive_ne_imp_iff [IsRefl α r] {x y : α} : x ≠ y → r x y ↔ r x y :=\n  IsRefl.reflexive.ne_imp_iff\n\n"}
{"name":"Symmetric.iff","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\nH : Symmetric r\nx y : α\n⊢ Iff (r x y) (r y x)","decl":"protected theorem Symmetric.iff (H : Symmetric r) (x y : α) : r x y ↔ r y x :=\n  ⟨fun h ↦ H h, fun h ↦ H h⟩\n\n"}
{"name":"Symmetric.flip_eq","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\nh : Symmetric r\n⊢ Eq (flip r) r","decl":"theorem Symmetric.flip_eq (h : Symmetric r) : flip r = r :=\n  funext₂ fun _ _ ↦ propext <| h.iff _ _\n\n"}
{"name":"Symmetric.swap_eq","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\na✝ : Symmetric r\n⊢ Eq (Function.swap r) r","decl":"theorem Symmetric.swap_eq : Symmetric r → swap r = r :=\n  Symmetric.flip_eq\n\n"}
{"name":"flip_eq_iff","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\n⊢ Iff (Eq (flip r) r) (Symmetric r)","decl":"theorem flip_eq_iff : flip r = r ↔ Symmetric r :=\n  ⟨fun h _ _ ↦ (congr_fun₂ h _ _).mp, Symmetric.flip_eq⟩\n\n"}
{"name":"swap_eq_iff","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\n⊢ Iff (Eq (Function.swap r) r) (Symmetric r)","decl":"theorem swap_eq_iff : swap r = r ↔ Symmetric r :=\n  flip_eq_iff\n\n"}
{"name":"Reflexive.comap","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nβ : Type u_2\nr : β → β → Prop\nh : Reflexive r\nf : α → β\n⊢ Reflexive (Function.onFun r f)","decl":"theorem Reflexive.comap (h : Reflexive r) (f : α → β) : Reflexive (r on f) := fun a ↦ h (f a)\n\n"}
{"name":"Symmetric.comap","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nβ : Type u_2\nr : β → β → Prop\nh : Symmetric r\nf : α → β\n⊢ Symmetric (Function.onFun r f)","decl":"theorem Symmetric.comap (h : Symmetric r) (f : α → β) : Symmetric (r on f) := fun _ _ hab ↦ h hab\n\n"}
{"name":"Transitive.comap","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nβ : Type u_2\nr : β → β → Prop\nh : Transitive r\nf : α → β\n⊢ Transitive (Function.onFun r f)","decl":"theorem Transitive.comap (h : Transitive r) (f : α → β) : Transitive (r on f) :=\n  fun _ _ _ hab hbc ↦ h hab hbc\n\n"}
{"name":"Equivalence.comap","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nβ : Type u_2\nr : β → β → Prop\nh : Equivalence r\nf : α → β\n⊢ Equivalence (Function.onFun r f)","decl":"theorem Equivalence.comap (h : Equivalence r) (f : α → β) : Equivalence (r on f) :=\n  ⟨fun a ↦ h.refl (f a), h.symm, h.trans⟩\n\n"}
{"name":"Relation.comp_eq","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → β → Prop\n⊢ Eq (Relation.Comp r fun x1 x2 => Eq x1 x2) r","decl":"theorem comp_eq : r ∘r (· = ·) = r :=\n  funext fun _ ↦ funext fun b ↦ propext <|\n  Iff.intro (fun ⟨_, h, Eq⟩ ↦ Eq ▸ h) fun h ↦ ⟨b, h, rfl⟩\n\n"}
{"name":"Relation.eq_comp","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → β → Prop\n⊢ Eq (Relation.Comp (fun x1 x2 => Eq x1 x2) r) r","decl":"theorem eq_comp : (· = ·) ∘r r = r :=\n  funext fun a ↦ funext fun _ ↦ propext <|\n  Iff.intro (fun ⟨_, Eq, h⟩ ↦ Eq.symm ▸ h) fun h ↦ ⟨a, rfl, h⟩\n\n"}
{"name":"Relation.iff_comp","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : Prop → α → Prop\n⊢ Eq (Relation.Comp (fun x1 x2 => Iff x1 x2) r) r","decl":"theorem iff_comp {r : Prop → α → Prop} : (· ↔ ·) ∘r r = r := by\n  have : (· ↔ ·) = (· = ·) := by funext a b; exact iff_eq_eq\n  rw [this, eq_comp]\n\n"}
{"name":"Relation.comp_iff","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → Prop → Prop\n⊢ Eq (Relation.Comp r fun x1 x2 => Iff x1 x2) r","decl":"theorem comp_iff {r : α → Prop → Prop} : r ∘r (· ↔ ·) = r := by\n  have : (· ↔ ·) = (· = ·) := by funext a b; exact iff_eq_eq\n  rw [this, comp_eq]\n\n"}
{"name":"Relation.comp_assoc","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\nr : α → β → Prop\np : β → γ → Prop\nq : γ → δ → Prop\n⊢ Eq (Relation.Comp (Relation.Comp r p) q) (Relation.Comp r (Relation.Comp p q))","decl":"theorem comp_assoc : (r ∘r p) ∘r q = r ∘r p ∘r q := by\n  funext a d\n  apply propext\n  constructor\n  · exact fun ⟨c, ⟨b, hab, hbc⟩, hcd⟩ ↦ ⟨b, hab, c, hbc, hcd⟩\n  · exact fun ⟨b, hab, c, hbc, hcd⟩ ↦ ⟨c, ⟨b, hab, hbc⟩, hcd⟩\n\n"}
{"name":"Relation.flip_comp","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nr : α → β → Prop\np : β → γ → Prop\n⊢ Eq (flip (Relation.Comp r p)) (Relation.Comp (flip p) (flip r))","decl":"theorem flip_comp : flip (r ∘r p) = flip p ∘r flip r := by\n  funext c a\n  apply propext\n  constructor\n  · exact fun ⟨b, hab, hbc⟩ ↦ ⟨b, hbc, hab⟩\n  · exact fun ⟨b, hbc, hab⟩ ↦ ⟨b, hab, hbc⟩\n\n"}
{"name":"Acc.of_fibration","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nβ : Type u_2\nrα : α → α → Prop\nrβ : β → β → Prop\nf : α → β\nfib : Relation.Fibration rα rβ f\na : α\nha : Acc rα a\n⊢ Acc rβ (f a)","decl":"/-- If `f : α → β` is a fibration between relations `rα` and `rβ`, and `a : α` is\n  accessible under `rα`, then `f a` is accessible under `rβ`. -/\ntheorem _root_.Acc.of_fibration (fib : Fibration rα rβ f) {a} (ha : Acc rα a) : Acc rβ (f a) := by\n  induction ha with | intro a _ ih => ?_\n  refine Acc.intro (f a) fun b hr ↦ ?_\n  obtain ⟨a', hr', rfl⟩ := fib hr\n  exact ih a' hr'\n\n"}
{"name":"Acc.of_downward_closed","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nβ : Type u_2\nrβ : β → β → Prop\nf : α → β\ndc : ∀ {a : α} {b : β}, rβ b (f a) → Exists fun c => Eq (f c) b\na : α\nha : Acc (InvImage rβ f) a\n⊢ Acc rβ (f a)","decl":"theorem _root_.Acc.of_downward_closed (dc : ∀ {a b}, rβ b (f a) → ∃ c, f c = b) (a : α)\n    (ha : Acc (InvImage rβ f) a) : Acc rβ (f a) :=\n  ha.of_fibration f fun a _ h ↦\n    let ⟨a', he⟩ := dc h\n    -- Porting note: Lean 3 did not need the motive\n    ⟨a', he.substr (p := fun x ↦ rβ x (f a)) h, he⟩\n\n"}
{"name":"Relation.map_apply","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\nr : α → β → Prop\nf : α → γ\ng : β → δ\nc : γ\nd : δ\n⊢ Iff (Relation.Map r f g c d) (Exists fun a => Exists fun b => And (r a b) (And (Eq (f a) c) (Eq (g b) d)))","decl":"lemma map_apply : Relation.Map r f g c d ↔ ∃ a b, r a b ∧ f a = c ∧ g b = d := Iff.rfl\n\n"}
{"name":"Relation.map_map","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\nε : Type u_5\nζ : Type u_6\nr : α → β → Prop\nf₁ : α → γ\ng₁ : β → δ\nf₂ : γ → ε\ng₂ : δ → ζ\n⊢ Eq (Relation.Map (Relation.Map r f₁ g₁) f₂ g₂) (Relation.Map r (Function.comp f₂ f₁) (Function.comp g₂ g₁))","decl":"@[simp] lemma map_map (r : α → β → Prop) (f₁ : α → γ) (g₁ : β → δ) (f₂ : γ → ε) (g₂ : δ → ζ) :\n    Relation.Map (Relation.Map r f₁ g₁) f₂ g₂ = Relation.Map r (f₂ ∘ f₁) (g₂ ∘ g₁) := by\n  ext a b\n  simp_rw [Relation.Map, Function.comp_apply, ← exists_and_right, @exists_comm γ, @exists_comm δ]\n  refine exists₂_congr fun a b ↦ ⟨?_, fun h ↦ ⟨_, _, ⟨⟨h.1, rfl, rfl⟩, h.2⟩⟩⟩\n  rintro ⟨_, _, ⟨hab, rfl, rfl⟩, h⟩\n  exact ⟨hab, h⟩\n\n"}
{"name":"Relation.map_apply_apply","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\nf : α → γ\ng : β → δ\nhf : Function.Injective f\nhg : Function.Injective g\nr : α → β → Prop\na : α\nb : β\n⊢ Iff (Relation.Map r f g (f a) (g b)) (r a b)","decl":"@[simp]\nlemma map_apply_apply (hf : Injective f) (hg : Injective g) (r : α → β → Prop) (a : α) (b : β) :\n    Relation.Map r f g (f a) (g b) ↔ r a b := by simp [Relation.Map, hf.eq_iff, hg.eq_iff]\n\n"}
{"name":"Relation.map_id_id","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → β → Prop\n⊢ Eq (Relation.Map r id id) r","decl":"@[simp] lemma map_id_id (r : α → β → Prop) : Relation.Map r id id = r := by ext; simp [Relation.Map]\n\n"}
{"name":"Relation.ReflTransGen.cases_tail_iff","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\na a✝ : α\n⊢ Iff (Relation.ReflTransGen r a a✝) (Or (Eq a✝ a) (Exists fun b => And (Relation.ReflTransGen r a b) (r b a✝)))","decl":"/-- `ReflTransGen r`: reflexive transitive closure of `r` -/\n@[mk_iff ReflTransGen.cases_tail_iff]\ninductive ReflTransGen (r : α → α → Prop) (a : α) : α → Prop\n  | refl : ReflTransGen r a a\n  | tail {b c} : ReflTransGen r a b → r b c → ReflTransGen r a c\n\n"}
{"name":"Relation.reflGen_iff","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\na a✝ : α\n⊢ Iff (Relation.ReflGen r a a✝) (Or (Eq a✝ a) (r a a✝))","decl":"/-- `ReflGen r`: reflexive closure of `r` -/\n@[mk_iff]\ninductive ReflGen (r : α → α → Prop) (a : α) : α → Prop\n  | refl : ReflGen r a a\n  | single {b} : r a b → ReflGen r a b\n\n"}
{"name":"Relation.eqvGen_iff","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\na✝¹ a✝ : α\n⊢ Iff (Relation.EqvGen r a✝¹ a✝) (Or (r a✝¹ a✝) (Or (Eq a✝ a✝¹) (Or (Relation.EqvGen r a✝ a✝¹) (Exists fun y => And (Relation.EqvGen r a✝¹ y) (Relation.EqvGen r y a✝)))))","decl":"variable (r) in\n/-- `EqvGen r`: equivalence closure of `r`. -/\n@[mk_iff]\ninductive EqvGen : α → α → Prop\n  | rel x y : r x y → EqvGen x y\n  | refl x : EqvGen x x\n  | symm x y : EqvGen x y → EqvGen y x\n  | trans x y z : EqvGen x y → EqvGen y z → EqvGen x z\n\n"}
{"name":"Relation.transGen_iff","module":"Mathlib.Logic.Relation","initialProofState":"α : Sort u\nr : α → α → Prop\na✝¹ a✝ : α\n⊢ Iff (Relation.TransGen r a✝¹ a✝) (Or (r a✝¹ a✝) (Exists fun b => And (Relation.TransGen r a✝¹ b) (r b a✝)))","decl":"attribute [mk_iff] TransGen\n"}
{"name":"Relation.ReflGen.to_reflTransGen","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\na b : α\na✝ : Relation.ReflGen r a b\n⊢ Relation.ReflTransGen r a b","decl":"theorem to_reflTransGen : ∀ {a b}, ReflGen r a b → ReflTransGen r a b\n  | a, _, refl => by rfl\n  | _, _, single h => ReflTransGen.tail ReflTransGen.refl h\n\n"}
{"name":"Relation.ReflGen.mono","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr p : α → α → Prop\nhp : ∀ (a b : α), r a b → p a b\na b : α\na✝ : Relation.ReflGen r a b\n⊢ Relation.ReflGen p a b","decl":"theorem mono {p : α → α → Prop} (hp : ∀ a b, r a b → p a b) : ∀ {a b}, ReflGen r a b → ReflGen p a b\n  | a, _, ReflGen.refl => by rfl\n  | a, b, single h => single (hp a b h)\n\n"}
{"name":"Relation.ReflGen.instIsRefl","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\n⊢ IsRefl α (Relation.ReflGen r)","decl":"instance : IsRefl α (ReflGen r) :=\n  ⟨@refl α r⟩\n\n"}
{"name":"Relation.ReflTransGen.trans","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\na b c : α\nhab : Relation.ReflTransGen r a b\nhbc : Relation.ReflTransGen r b c\n⊢ Relation.ReflTransGen r a c","decl":"@[trans]\ntheorem trans (hab : ReflTransGen r a b) (hbc : ReflTransGen r b c) : ReflTransGen r a c := by\n  induction hbc with\n  | refl => assumption\n  | tail _ hcd hac => exact hac.tail hcd\n\n"}
{"name":"Relation.ReflTransGen.single","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\na b : α\nhab : r a b\n⊢ Relation.ReflTransGen r a b","decl":"theorem single (hab : r a b) : ReflTransGen r a b :=\n  refl.tail hab\n\n"}
{"name":"Relation.ReflTransGen.head","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\na b c : α\nhab : r a b\nhbc : Relation.ReflTransGen r b c\n⊢ Relation.ReflTransGen r a c","decl":"theorem head (hab : r a b) (hbc : ReflTransGen r b c) : ReflTransGen r a c := by\n  induction hbc with\n  | refl => exact refl.tail hab\n  | tail _ hcd hac => exact hac.tail hcd\n\n"}
{"name":"Relation.ReflTransGen.symmetric","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\nh : Symmetric r\n⊢ Symmetric (Relation.ReflTransGen r)","decl":"theorem symmetric (h : Symmetric r) : Symmetric (ReflTransGen r) := by\n  intro x y h\n  induction h with\n  | refl => rfl\n  | tail _ b c => apply Relation.ReflTransGen.head (h b) c\n\n"}
{"name":"Relation.ReflTransGen.cases_tail","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\na b : α\na✝ : Relation.ReflTransGen r a b\n⊢ Or (Eq b a) (Exists fun c => And (Relation.ReflTransGen r a c) (r c b))","decl":"theorem cases_tail : ReflTransGen r a b → b = a ∨ ∃ c, ReflTransGen r a c ∧ r c b :=\n  (cases_tail_iff r a b).1\n\n"}
{"name":"Relation.ReflTransGen.head_induction_on","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\nb : α\nP : (a : α) → Relation.ReflTransGen r a b → Prop\na : α\nh : Relation.ReflTransGen r a b\nrefl : P b ⋯\nhead : ∀ {a c : α} (h' : r a c) (h : Relation.ReflTransGen r c b), P c h → P a ⋯\n⊢ P a h","decl":"@[elab_as_elim]\ntheorem head_induction_on {P : ∀ a : α, ReflTransGen r a b → Prop} {a : α} (h : ReflTransGen r a b)\n    (refl : P b refl)\n    (head : ∀ {a c} (h' : r a c) (h : ReflTransGen r c b), P c h → P a (h.head h')) : P a h := by\n  induction h with\n  | refl => exact refl\n  | @tail b c _ hbc ih =>\n  apply ih\n  · exact head hbc _ refl\n  · exact fun h1 h2 ↦ head h1 (h2.tail hbc)\n\n"}
{"name":"Relation.ReflTransGen.trans_induction_on","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\nP : {a b : α} → Relation.ReflTransGen r a b → Prop\na b : α\nh : Relation.ReflTransGen r a b\nih₁ : ∀ (a : α), P ⋯\nih₂ : ∀ {a b : α} (h : r a b), P ⋯\nih₃ : ∀ {a b c : α} (h₁ : Relation.ReflTransGen r a b) (h₂ : Relation.ReflTransGen r b c), P h₁ → P h₂ → P ⋯\n⊢ P h","decl":"@[elab_as_elim]\ntheorem trans_induction_on {P : ∀ {a b : α}, ReflTransGen r a b → Prop} {a b : α}\n    (h : ReflTransGen r a b) (ih₁ : ∀ a, @P a a refl) (ih₂ : ∀ {a b} (h : r a b), P (single h))\n    (ih₃ : ∀ {a b c} (h₁ : ReflTransGen r a b) (h₂ : ReflTransGen r b c), P h₁ → P h₂ →\n     P (h₁.trans h₂)) : P h := by\n  induction h with\n  | refl => exact ih₁ a\n  | tail hab hbc ih => exact ih₃ hab (single hbc) ih (ih₂ hbc)\n\n"}
{"name":"Relation.ReflTransGen.cases_head","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\na b : α\nh : Relation.ReflTransGen r a b\n⊢ Or (Eq a b) (Exists fun c => And (r a c) (Relation.ReflTransGen r c b))","decl":"theorem cases_head (h : ReflTransGen r a b) : a = b ∨ ∃ c, r a c ∧ ReflTransGen r c b := by\n  induction h using Relation.ReflTransGen.head_induction_on\n  · left\n    rfl\n  · right\n    exact ⟨_, by assumption, by assumption⟩\n\n"}
{"name":"Relation.ReflTransGen.cases_head_iff","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\na b : α\n⊢ Iff (Relation.ReflTransGen r a b) (Or (Eq a b) (Exists fun c => And (r a c) (Relation.ReflTransGen r c b)))","decl":"theorem cases_head_iff : ReflTransGen r a b ↔ a = b ∨ ∃ c, r a c ∧ ReflTransGen r c b := by\n  use cases_head\n  rintro (rfl | ⟨c, hac, hcb⟩)\n  · rfl\n  · exact head hac hcb\n\n"}
{"name":"Relation.ReflTransGen.total_of_right_unique","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\na b c : α\nU : Relator.RightUnique r\nab : Relation.ReflTransGen r a b\nac : Relation.ReflTransGen r a c\n⊢ Or (Relation.ReflTransGen r b c) (Relation.ReflTransGen r c b)","decl":"theorem total_of_right_unique (U : Relator.RightUnique r) (ab : ReflTransGen r a b)\n    (ac : ReflTransGen r a c) : ReflTransGen r b c ∨ ReflTransGen r c b := by\n  induction ab with\n  | refl => exact Or.inl ac\n  | tail _ bd IH =>\n    rcases IH with (IH | IH)\n    · rcases cases_head IH with (rfl | ⟨e, be, ec⟩)\n      · exact Or.inr (single bd)\n      · cases U bd be\n        exact Or.inl ec\n    · exact Or.inr (IH.tail bd)\n\n"}
{"name":"Relation.TransGen.to_reflTransGen","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\na b : α\nh : Relation.TransGen r a b\n⊢ Relation.ReflTransGen r a b","decl":"theorem to_reflTransGen {a b} (h : TransGen r a b) : ReflTransGen r a b := by\n  induction h with\n  | single h => exact ReflTransGen.single h\n  | tail _ bc ab => exact ReflTransGen.tail ab bc\n\n"}
{"name":"Relation.TransGen.trans_left","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\na b c : α\nhab : Relation.TransGen r a b\nhbc : Relation.ReflTransGen r b c\n⊢ Relation.TransGen r a c","decl":"theorem trans_left (hab : TransGen r a b) (hbc : ReflTransGen r b c) : TransGen r a c := by\n  induction hbc with\n  | refl => assumption\n  | tail _ hcd hac => exact hac.tail hcd\n\n"}
{"name":"Relation.TransGen.head'","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\na b c : α\nhab : r a b\nhbc : Relation.ReflTransGen r b c\n⊢ Relation.TransGen r a c","decl":"theorem head' (hab : r a b) (hbc : ReflTransGen r b c) : TransGen r a c :=\n  trans_left (single hab) hbc\n\n"}
{"name":"Relation.TransGen.tail'","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\na b c : α\nhab : Relation.ReflTransGen r a b\nhbc : r b c\n⊢ Relation.TransGen r a c","decl":"theorem tail' (hab : ReflTransGen r a b) (hbc : r b c) : TransGen r a c := by\n  induction hab generalizing c with\n  | refl => exact single hbc\n  | tail _ hdb IH => exact tail (IH hdb) hbc\n\n"}
{"name":"Relation.TransGen.head","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\na b c : α\nhab : r a b\nhbc : Relation.TransGen r b c\n⊢ Relation.TransGen r a c","decl":"theorem head (hab : r a b) (hbc : TransGen r b c) : TransGen r a c :=\n  head' hab hbc.to_reflTransGen\n\n"}
{"name":"Relation.TransGen.head_induction_on","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\nb : α\nP : (a : α) → Relation.TransGen r a b → Prop\na : α\nh : Relation.TransGen r a b\nbase : ∀ {a : α} (h : r a b), P a ⋯\nih : ∀ {a c : α} (h' : r a c) (h : Relation.TransGen r c b), P c h → P a ⋯\n⊢ P a h","decl":"@[elab_as_elim]\ntheorem head_induction_on {P : ∀ a : α, TransGen r a b → Prop} {a : α} (h : TransGen r a b)\n    (base : ∀ {a} (h : r a b), P a (single h))\n    (ih : ∀ {a c} (h' : r a c) (h : TransGen r c b), P c h → P a (h.head h')) : P a h := by\n  induction h with\n  | single h => exact base h\n  | @tail b c _ hbc h_ih =>\n  apply h_ih\n  · exact fun h ↦ ih h (single hbc) (base hbc)\n  · exact fun hab hbc ↦ ih hab _\n\n"}
{"name":"Relation.TransGen.trans_induction_on","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\nP : {a b : α} → Relation.TransGen r a b → Prop\na b : α\nh : Relation.TransGen r a b\nbase : ∀ {a b : α} (h : r a b), P ⋯\nih : ∀ {a b c : α} (h₁ : Relation.TransGen r a b) (h₂ : Relation.TransGen r b c), P h₁ → P h₂ → P ⋯\n⊢ P h","decl":"@[elab_as_elim]\ntheorem trans_induction_on {P : ∀ {a b : α}, TransGen r a b → Prop} {a b : α} (h : TransGen r a b)\n    (base : ∀ {a b} (h : r a b), P (single h))\n    (ih : ∀ {a b c} (h₁ : TransGen r a b) (h₂ : TransGen r b c), P h₁ → P h₂ → P (h₁.trans h₂)) :\n    P h := by\n  induction h with\n  | single h => exact base h\n  | tail hab hbc h_ih => exact ih hab (single hbc) h_ih (base hbc)\n\n"}
{"name":"Relation.TransGen.trans_right","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\na b c : α\nhab : Relation.ReflTransGen r a b\nhbc : Relation.TransGen r b c\n⊢ Relation.TransGen r a c","decl":"theorem trans_right (hab : ReflTransGen r a b) (hbc : TransGen r b c) : TransGen r a c := by\n  induction hbc with\n  | single hbc => exact tail' hab hbc\n  | tail _ hcd hac => exact hac.tail hcd\n\n"}
{"name":"Relation.TransGen.tail'_iff","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\na c : α\n⊢ Iff (Relation.TransGen r a c) (Exists fun b => And (Relation.ReflTransGen r a b) (r b c))","decl":"theorem tail'_iff : TransGen r a c ↔ ∃ b, ReflTransGen r a b ∧ r b c := by\n  refine ⟨fun h ↦ ?_, fun ⟨b, hab, hbc⟩ ↦ tail' hab hbc⟩\n  cases h with\n  | single hac => exact ⟨_, by rfl, hac⟩\n  | tail hab hbc => exact ⟨_, hab.to_reflTransGen, hbc⟩\n\n"}
{"name":"Relation.TransGen.head'_iff","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\na c : α\n⊢ Iff (Relation.TransGen r a c) (Exists fun b => And (r a b) (Relation.ReflTransGen r b c))","decl":"theorem head'_iff : TransGen r a c ↔ ∃ b, r a b ∧ ReflTransGen r b c := by\n  refine ⟨fun h ↦ ?_, fun ⟨b, hab, hbc⟩ ↦ head' hab hbc⟩\n  induction h with\n  | single hac => exact ⟨_, hac, by rfl⟩\n  | tail _ hbc IH =>\n  rcases IH with ⟨d, had, hdb⟩\n  exact ⟨_, had, hdb.tail hbc⟩\n\n"}
{"name":"Relation.reflGen_eq_self","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\nhr : Reflexive r\n⊢ Eq (Relation.ReflGen r) r","decl":"lemma reflGen_eq_self (hr : Reflexive r) : ReflGen r = r := by\n  ext x y\n  simpa only [reflGen_iff, or_iff_right_iff_imp] using fun h ↦ h ▸ hr y\n\n"}
{"name":"Relation.reflexive_reflGen","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\n⊢ Reflexive (Relation.ReflGen r)","decl":"lemma reflexive_reflGen : Reflexive (ReflGen r) := fun _ ↦ .refl\n\n"}
{"name":"Relation.reflGen_minimal","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr r' : α → α → Prop\nhr' : Reflexive r'\nh : ∀ (x y : α), r x y → r' x y\nx y : α\nhxy : Relation.ReflGen r x y\n⊢ r' x y","decl":"lemma reflGen_minimal {r' : α → α → Prop} (hr' : Reflexive r') (h : ∀ x y, r x y → r' x y) {x y : α}\n    (hxy : ReflGen r x y) : r' x y := by\n  simpa [reflGen_eq_self hr'] using ReflGen.mono h hxy\n\n"}
{"name":"Relation.transGen_eq_self","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\ntrans : Transitive r\n⊢ Eq (Relation.TransGen r) r","decl":"theorem transGen_eq_self (trans : Transitive r) : TransGen r = r :=\n  funext fun a ↦ funext fun b ↦ propext <|\n    ⟨fun h ↦ by\n      induction h with\n      | single hc => exact hc\n      | tail _ hcd hac => exact trans hac hcd, TransGen.single⟩\n\n"}
{"name":"Relation.transitive_transGen","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\n⊢ Transitive (Relation.TransGen r)","decl":"theorem transitive_transGen : Transitive (TransGen r) := fun _ _ _ ↦ TransGen.trans\n\n"}
{"name":"Relation.instIsTransTransGen","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\n⊢ IsTrans α (Relation.TransGen r)","decl":"instance : IsTrans α (TransGen r) :=\n  ⟨@TransGen.trans α r⟩\n\n"}
{"name":"Relation.transGen_idem","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\n⊢ Eq (Relation.TransGen (Relation.TransGen r)) (Relation.TransGen r)","decl":"theorem transGen_idem : TransGen (TransGen r) = TransGen r :=\n  transGen_eq_self transitive_transGen\n\n"}
{"name":"Relation.TransGen.lift","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\np : β → β → Prop\na b : α\nf : α → β\nh : ∀ (a b : α), r a b → p (f a) (f b)\nhab : Relation.TransGen r a b\n⊢ Relation.TransGen p (f a) (f b)","decl":"theorem TransGen.lift {p : β → β → Prop} {a b : α} (f : α → β) (h : ∀ a b, r a b → p (f a) (f b))\n    (hab : TransGen r a b) : TransGen p (f a) (f b) := by\n  induction hab with\n  | single hac => exact TransGen.single (h a _ hac)\n  | tail _ hcd hac => exact TransGen.tail hac (h _ _ hcd)\n\n"}
{"name":"Relation.TransGen.lift'","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\np : β → β → Prop\na b : α\nf : α → β\nh : ∀ (a b : α), r a b → Relation.TransGen p (f a) (f b)\nhab : Relation.TransGen r a b\n⊢ Relation.TransGen p (f a) (f b)","decl":"theorem TransGen.lift' {p : β → β → Prop} {a b : α} (f : α → β)\n    (h : ∀ a b, r a b → TransGen p (f a) (f b)) (hab : TransGen r a b) :\n    TransGen p (f a) (f b) := by\nsimpa [transGen_idem] using hab.lift f h\n\n"}
{"name":"Relation.TransGen.closed","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\na b : α\np : α → α → Prop\na✝¹ : ∀ (a b : α), r a b → Relation.TransGen p a b\na✝ : Relation.TransGen r a b\n⊢ Relation.TransGen p a b","decl":"theorem TransGen.closed {p : α → α → Prop} :\n    (∀ a b, r a b → TransGen p a b) → TransGen r a b → TransGen p a b :=\n  TransGen.lift' id\n\n"}
{"name":"Relation.TransGen.closed'","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\nP : α → Prop\ndc : ∀ {a b : α}, r a b → P b → P a\na b : α\nh : Relation.TransGen r a b\na✝ : P b\n⊢ P a","decl":"lemma TransGen.closed' {P : α → Prop} (dc : ∀ {a b}, r a b → P b → P a)\n    {a b : α} (h : TransGen r a b) : P b → P a :=\n  h.head_induction_on dc fun hr _ hi ↦ dc hr ∘ hi\n\n"}
{"name":"Relation.TransGen.mono","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\na b : α\np : α → α → Prop\na✝¹ : ∀ (a b : α), r a b → p a b\na✝ : Relation.TransGen r a b\n⊢ Relation.TransGen p a b","decl":"theorem TransGen.mono {p : α → α → Prop} :\n    (∀ a b, r a b → p a b) → TransGen r a b → TransGen p a b :=\n  TransGen.lift id\n\n"}
{"name":"Relation.transGen_minimal","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr r' : α → α → Prop\nhr' : Transitive r'\nh : ∀ (x y : α), r x y → r' x y\nx y : α\nhxy : Relation.TransGen r x y\n⊢ r' x y","decl":"lemma transGen_minimal {r' : α → α → Prop} (hr' : Transitive r') (h : ∀ x y, r x y → r' x y)\n    {x y : α} (hxy : TransGen r x y) : r' x y := by\n  simpa [transGen_eq_self hr'] using TransGen.mono h hxy\n\n"}
{"name":"Relation.TransGen.swap","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\na b : α\nh : Relation.TransGen r b a\n⊢ Relation.TransGen (Function.swap r) a b","decl":"theorem TransGen.swap (h : TransGen r b a) : TransGen (swap r) a b := by\n  induction h with\n  | single h => exact TransGen.single h\n  | tail _ hbc ih => exact ih.head hbc\n\n"}
{"name":"Relation.transGen_swap","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\na b : α\n⊢ Iff (Relation.TransGen (Function.swap r) a b) (Relation.TransGen r b a)","decl":"theorem transGen_swap : TransGen (swap r) a b ↔ TransGen r b a :=\n  ⟨TransGen.swap, TransGen.swap⟩\n\n"}
{"name":"Relation.reflTransGen_iff_eq","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\na b : α\nh : ∀ (b : α), Not (r a b)\n⊢ Iff (Relation.ReflTransGen r a b) (Eq b a)","decl":"theorem reflTransGen_iff_eq (h : ∀ b, ¬r a b) : ReflTransGen r a b ↔ b = a := by\n  rw [cases_head_iff]; simp [h, eq_comm]\n\n"}
{"name":"Relation.reflTransGen_iff_eq_or_transGen","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\na b : α\n⊢ Iff (Relation.ReflTransGen r a b) (Or (Eq b a) (Relation.TransGen r a b))","decl":"theorem reflTransGen_iff_eq_or_transGen : ReflTransGen r a b ↔ b = a ∨ TransGen r a b := by\n  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩\n  · cases h with\n    | refl => exact Or.inl rfl\n    | tail hac hcb => exact Or.inr (TransGen.tail' hac hcb)\n  · rcases h with (rfl | h)\n    · rfl\n    · exact h.to_reflTransGen\n\n"}
{"name":"Relation.ReflTransGen.lift","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\np : β → β → Prop\na b : α\nf : α → β\nh : ∀ (a b : α), r a b → p (f a) (f b)\nhab : Relation.ReflTransGen r a b\n⊢ Relation.ReflTransGen p (f a) (f b)","decl":"theorem ReflTransGen.lift {p : β → β → Prop} {a b : α} (f : α → β)\n    (h : ∀ a b, r a b → p (f a) (f b)) (hab : ReflTransGen r a b) : ReflTransGen p (f a) (f b) :=\n  ReflTransGen.trans_induction_on hab (fun _ ↦ refl) (ReflTransGen.single ∘ h _ _) fun _ _ ↦ trans\n\n"}
{"name":"Relation.ReflTransGen.mono","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\na b : α\np : α → α → Prop\na✝¹ : ∀ (a b : α), r a b → p a b\na✝ : Relation.ReflTransGen r a b\n⊢ Relation.ReflTransGen p a b","decl":"theorem ReflTransGen.mono {p : α → α → Prop} : (∀ a b, r a b → p a b) →\n    ReflTransGen r a b → ReflTransGen p a b :=\n  ReflTransGen.lift id\n\n"}
{"name":"Relation.reflTransGen_eq_self","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\nrefl : Reflexive r\ntrans : Transitive r\n⊢ Eq (Relation.ReflTransGen r) r","decl":"theorem reflTransGen_eq_self (refl : Reflexive r) (trans : Transitive r) : ReflTransGen r = r :=\n  funext fun a ↦ funext fun b ↦ propext <|\n    ⟨fun h ↦ by\n      induction h with\n      | refl => apply refl\n      | tail _ h₂ IH => exact trans IH h₂, single⟩\n\n"}
{"name":"Relation.reflTransGen_minimal","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr r' : α → α → Prop\nhr₁ : Reflexive r'\nhr₂ : Transitive r'\nh : ∀ (x y : α), r x y → r' x y\nx y : α\nhxy : Relation.ReflTransGen r x y\n⊢ r' x y","decl":"lemma reflTransGen_minimal {r' : α → α → Prop} (hr₁ : Reflexive r') (hr₂ : Transitive r')\n    (h : ∀ x y, r x y → r' x y) {x y : α} (hxy : ReflTransGen r x y) : r' x y := by\n  simpa [reflTransGen_eq_self hr₁ hr₂] using ReflTransGen.mono h hxy\n\n"}
{"name":"Relation.reflexive_reflTransGen","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\n⊢ Reflexive (Relation.ReflTransGen r)","decl":"theorem reflexive_reflTransGen : Reflexive (ReflTransGen r) := fun _ ↦ refl\n\n"}
{"name":"Relation.transitive_reflTransGen","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\n⊢ Transitive (Relation.ReflTransGen r)","decl":"theorem transitive_reflTransGen : Transitive (ReflTransGen r) := fun _ _ _ ↦ trans\n\n"}
{"name":"Relation.instIsReflReflTransGen","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\n⊢ IsRefl α (Relation.ReflTransGen r)","decl":"instance : IsRefl α (ReflTransGen r) :=\n  ⟨@ReflTransGen.refl α r⟩\n\n"}
{"name":"Relation.instIsTransReflTransGen","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\n⊢ IsTrans α (Relation.ReflTransGen r)","decl":"instance : IsTrans α (ReflTransGen r) :=\n  ⟨@ReflTransGen.trans α r⟩\n\n"}
{"name":"Relation.reflTransGen_idem","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\n⊢ Eq (Relation.ReflTransGen (Relation.ReflTransGen r)) (Relation.ReflTransGen r)","decl":"theorem reflTransGen_idem : ReflTransGen (ReflTransGen r) = ReflTransGen r :=\n  reflTransGen_eq_self reflexive_reflTransGen transitive_reflTransGen\n\n"}
{"name":"Relation.ReflTransGen.lift'","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\np : β → β → Prop\na b : α\nf : α → β\nh : ∀ (a b : α), r a b → Relation.ReflTransGen p (f a) (f b)\nhab : Relation.ReflTransGen r a b\n⊢ Relation.ReflTransGen p (f a) (f b)","decl":"theorem ReflTransGen.lift' {p : β → β → Prop} {a b : α} (f : α → β)\n    (h : ∀ a b, r a b → ReflTransGen p (f a) (f b))\n    (hab : ReflTransGen r a b) : ReflTransGen p (f a) (f b) := by\n  simpa [reflTransGen_idem] using hab.lift f h\n\n"}
{"name":"Relation.reflTransGen_closed","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\na b : α\np : α → α → Prop\na✝¹ : ∀ (a b : α), r a b → Relation.ReflTransGen p a b\na✝ : Relation.ReflTransGen r a b\n⊢ Relation.ReflTransGen p a b","decl":"theorem reflTransGen_closed {p : α → α → Prop} :\n    (∀ a b, r a b → ReflTransGen p a b) → ReflTransGen r a b → ReflTransGen p a b :=\n  ReflTransGen.lift' id\n\n"}
{"name":"Relation.ReflTransGen.swap","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\na b : α\nh : Relation.ReflTransGen r b a\n⊢ Relation.ReflTransGen (Function.swap r) a b","decl":"theorem ReflTransGen.swap (h : ReflTransGen r b a) : ReflTransGen (swap r) a b := by\n  induction h with\n  | refl => rfl\n  | tail _ hbc ih => exact ih.head hbc\n\n"}
{"name":"Relation.reflTransGen_swap","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\na b : α\n⊢ Iff (Relation.ReflTransGen (Function.swap r) a b) (Relation.ReflTransGen r b a)","decl":"theorem reflTransGen_swap : ReflTransGen (swap r) a b ↔ ReflTransGen r b a :=\n  ⟨ReflTransGen.swap, ReflTransGen.swap⟩\n\n"}
{"name":"Relation.reflGen_transGen","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\n⊢ Eq (Relation.ReflGen (Relation.TransGen r)) (Relation.ReflTransGen r)","decl":"@[simp] lemma reflGen_transGen : ReflGen (TransGen r) = ReflTransGen r := by\n  ext x y\n  simp_rw [reflTransGen_iff_eq_or_transGen, reflGen_iff]\n\n"}
{"name":"Relation.transGen_reflGen","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\n⊢ Eq (Relation.TransGen (Relation.ReflGen r)) (Relation.ReflTransGen r)","decl":"@[simp] lemma transGen_reflGen : TransGen (ReflGen r) = ReflTransGen r := by\n  ext x y\n  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩\n  · simpa [reflTransGen_idem]\n      using TransGen.to_reflTransGen <| TransGen.mono (fun _ _ ↦ ReflGen.to_reflTransGen) h\n  · obtain (rfl | h) := reflTransGen_iff_eq_or_transGen.mp h\n    · exact .single .refl\n    · exact TransGen.mono (fun _ _ ↦ .single) h\n\n"}
{"name":"Relation.reflTransGen_reflGen","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\n⊢ Eq (Relation.ReflTransGen (Relation.ReflGen r)) (Relation.ReflTransGen r)","decl":"@[simp] lemma reflTransGen_reflGen : ReflTransGen (ReflGen r) = ReflTransGen r := by\n  simp only [← transGen_reflGen, reflGen_eq_self reflexive_reflGen]\n\n"}
{"name":"Relation.reflTransGen_transGen","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\n⊢ Eq (Relation.ReflTransGen (Relation.TransGen r)) (Relation.ReflTransGen r)","decl":"@[simp] lemma reflTransGen_transGen : ReflTransGen (TransGen r) = ReflTransGen r := by\n  simp only [← reflGen_transGen, transGen_idem]\n\n"}
{"name":"Relation.reflTransGen_eq_transGen","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\nhr : Reflexive r\n⊢ Eq (Relation.ReflTransGen r) (Relation.TransGen r)","decl":"lemma reflTransGen_eq_transGen (hr : Reflexive r) :\n    ReflTransGen r = TransGen r := by\n  rw [← transGen_reflGen, reflGen_eq_self hr]\n\n"}
{"name":"Relation.reflTransGen_eq_reflGen","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\nhr : Transitive r\n⊢ Eq (Relation.ReflTransGen r) (Relation.ReflGen r)","decl":"lemma reflTransGen_eq_reflGen (hr : Transitive r) :\n    ReflTransGen r = ReflGen r := by\n  rw [← reflGen_transGen, transGen_eq_self hr]\n\n"}
{"name":"Relation.EqvGen.is_equivalence","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\n⊢ Equivalence (Relation.EqvGen r)","decl":"theorem is_equivalence : Equivalence (@EqvGen α r) :=\n  Equivalence.mk EqvGen.refl (EqvGen.symm _ _) (EqvGen.trans _ _ _)\n\n"}
{"name":"Relation.EqvGen.mono","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\na b : α\nr p : α → α → Prop\nhrp : ∀ (a b : α), r a b → p a b\nh : Relation.EqvGen r a b\n⊢ Relation.EqvGen p a b","decl":"theorem mono {r p : α → α → Prop} (hrp : ∀ a b, r a b → p a b) (h : EqvGen r a b) :\n    EqvGen p a b := by\n  induction h with\n  | rel a b h => exact EqvGen.rel _ _ (hrp _ _ h)\n  | refl => exact EqvGen.refl _\n  | symm a b _ ih => exact EqvGen.symm _ _ ih\n  | trans a b c _ _ hab hbc => exact EqvGen.trans _ _ _ hab hbc\n\n"}
{"name":"EqvGen.is_equivalence","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\n⊢ Equivalence (Relation.EqvGen r)","decl":"@[deprecated (since := \"2024-09-01\")] alias _root_.EqvGen.is_equivalence := is_equivalence\n"}
{"name":"EqvGen.mono","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\na b : α\nr p : α → α → Prop\nhrp : ∀ (a b : α), r a b → p a b\nh : Relation.EqvGen r a b\n⊢ Relation.EqvGen p a b","decl":"@[deprecated (since := \"2024-09-01\")] alias _root_.EqvGen.mono := mono\n\n"}
{"name":"Relation.church_rosser","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\na b c : α\nh : ∀ (a b c : α), r a b → r a c → Exists fun d => And (Relation.ReflGen r b d) (Relation.ReflTransGen r c d)\nhab : Relation.ReflTransGen r a b\nhac : Relation.ReflTransGen r a c\n⊢ Relation.Join (Relation.ReflTransGen r) b c","decl":"/-- A sufficient condition for the Church-Rosser property. -/\ntheorem church_rosser (h : ∀ a b c, r a b → r a c → ∃ d, ReflGen r b d ∧ ReflTransGen r c d)\n    (hab : ReflTransGen r a b) (hac : ReflTransGen r a c) : Join (ReflTransGen r) b c := by\n  induction hab with\n  | refl => exact ⟨c, hac, refl⟩\n  | @tail d e _ hde ih =>\n    rcases ih with ⟨b, hdb, hcb⟩\n    have : ∃ a, ReflTransGen r e a ∧ ReflGen r b a := by\n      clear hcb\n      induction hdb with\n      | refl => exact ⟨e, refl, ReflGen.single hde⟩\n      | @tail f b _ hfb ih =>\n        rcases ih with ⟨a, hea, hfa⟩\n        cases hfa with\n        | refl => exact ⟨b, hea.tail hfb, ReflGen.refl⟩\n        | single hfa =>\n          rcases h _ _ _ hfb hfa with ⟨c, hbc, hac⟩\n          exact ⟨c, hea.trans hac, hbc⟩\n    rcases this with ⟨a, hea, hba⟩\n    cases hba with\n    | refl => exact ⟨b, hea, hcb⟩\n    | single hba => exact ⟨a, hea, hcb.tail hba⟩\n\n\n"}
{"name":"Relation.join_of_single","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\na b : α\nh : Reflexive r\nhab : r a b\n⊢ Relation.Join r a b","decl":"theorem join_of_single (h : Reflexive r) (hab : r a b) : Join r a b :=\n  ⟨b, hab, h b⟩\n\n"}
{"name":"Relation.symmetric_join","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\n⊢ Symmetric (Relation.Join r)","decl":"theorem symmetric_join : Symmetric (Join r) := fun _ _ ⟨c, hac, hcb⟩ ↦ ⟨c, hcb, hac⟩\n\n"}
{"name":"Relation.reflexive_join","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\nh : Reflexive r\n⊢ Reflexive (Relation.Join r)","decl":"theorem reflexive_join (h : Reflexive r) : Reflexive (Join r) := fun a ↦ ⟨a, h a, h a⟩\n\n"}
{"name":"Relation.transitive_join","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\nht : Transitive r\nh : ∀ (a b c : α), r a b → r a c → Relation.Join r b c\n⊢ Transitive (Relation.Join r)","decl":"theorem transitive_join (ht : Transitive r) (h : ∀ a b c, r a b → r a c → Join r b c) :\n    Transitive (Join r) :=\n  fun _ b _ ⟨x, hax, hbx⟩ ⟨y, hby, hcy⟩ ↦\n  let ⟨z, hxz, hyz⟩ := h b x y hbx hby\n  ⟨z, ht hax hxz, ht hcy hyz⟩\n\n"}
{"name":"Relation.equivalence_join","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\nhr : Reflexive r\nht : Transitive r\nh : ∀ (a b c : α), r a b → r a c → Relation.Join r b c\n⊢ Equivalence (Relation.Join r)","decl":"theorem equivalence_join (hr : Reflexive r) (ht : Transitive r)\n    (h : ∀ a b c, r a b → r a c → Join r b c) : Equivalence (Join r) :=\n  ⟨reflexive_join hr, @symmetric_join _ _, @transitive_join _ _ ht h⟩\n\n"}
{"name":"Relation.equivalence_join_reflTransGen","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\nh : ∀ (a b c : α), r a b → r a c → Exists fun d => And (Relation.ReflGen r b d) (Relation.ReflTransGen r c d)\n⊢ Equivalence (Relation.Join (Relation.ReflTransGen r))","decl":"theorem equivalence_join_reflTransGen\n    (h : ∀ a b c, r a b → r a c → ∃ d, ReflGen r b d ∧ ReflTransGen r c d) :\n    Equivalence (Join (ReflTransGen r)) :=\n  equivalence_join reflexive_reflTransGen transitive_reflTransGen fun _ _ _ ↦ church_rosser h\n\n"}
{"name":"Relation.join_of_equivalence","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\na b : α\nr' : α → α → Prop\nhr : Equivalence r\nh : ∀ (a b : α), r' a b → r a b\na✝ : Relation.Join r' a b\n⊢ r a b","decl":"theorem join_of_equivalence {r' : α → α → Prop} (hr : Equivalence r) (h : ∀ a b, r' a b → r a b) :\n    Join r' a b → r a b\n  | ⟨_, hac, hbc⟩ => hr.trans (h _ _ hac) (hr.symm <| h _ _ hbc)\n\n"}
{"name":"Relation.reflTransGen_of_transitive_reflexive","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\na b : α\nr' : α → α → Prop\nhr : Reflexive r\nht : Transitive r\nh : ∀ (a b : α), r' a b → r a b\nh' : Relation.ReflTransGen r' a b\n⊢ r a b","decl":"theorem reflTransGen_of_transitive_reflexive {r' : α → α → Prop} (hr : Reflexive r)\n    (ht : Transitive r) (h : ∀ a b, r' a b → r a b) (h' : ReflTransGen r' a b) : r a b := by\n  induction h' with\n  | refl => exact hr _\n  | tail _ hbc ih => exact ht ih (h _ _ hbc)\n\n"}
{"name":"Relation.reflTransGen_of_equivalence","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\na b : α\nr' : α → α → Prop\nhr : Equivalence r\na✝¹ : ∀ (a b : α), r' a b → r a b\na✝ : Relation.ReflTransGen r' a b\n⊢ r a b","decl":"theorem reflTransGen_of_equivalence {r' : α → α → Prop} (hr : Equivalence r) :\n    (∀ a b, r' a b → r a b) → ReflTransGen r' a b → r a b :=\n  reflTransGen_of_transitive_reflexive hr.1 (fun _ _ _ ↦ hr.trans)\n\n"}
{"name":"Quot.eqvGen_exact","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\na b : α\nH : Eq (Quot.mk r a) (Quot.mk r b)\n⊢ Relation.EqvGen r a b","decl":"theorem Quot.eqvGen_exact (H : Quot.mk r a = Quot.mk r b) : EqvGen r a b :=\n  @Quotient.exact _ (EqvGen.setoid r) a b (congrArg\n    (Quot.lift (Quotient.mk (EqvGen.setoid r)) (fun x y h ↦ Quot.sound (EqvGen.rel x y h))) H)\n\n"}
{"name":"Quot.eqvGen_sound","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\na b : α\nH : Relation.EqvGen r a b\n⊢ Eq (Quot.mk r a) (Quot.mk r b)","decl":"theorem Quot.eqvGen_sound (H : EqvGen r a b) : Quot.mk r a = Quot.mk r b :=\n  EqvGen.rec\n    (fun _ _ h ↦ Quot.sound h)\n    (fun _ ↦ rfl)\n    (fun _ _ _ IH ↦ Eq.symm IH)\n    (fun _ _ _ _ _ IH₁ IH₂ ↦ Eq.trans IH₁ IH₂)\n    H\n\n"}
{"name":"Equivalence.eqvGen_iff","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\na b : α\nh : Equivalence r\n⊢ Iff (Relation.EqvGen r a b) (r a b)","decl":"theorem Equivalence.eqvGen_iff (h : Equivalence r) : EqvGen r a b ↔ r a b :=\n  Iff.intro\n    (by\n      intro h\n      induction h with\n      | rel => assumption\n      | refl => exact h.1 _\n      | symm => apply h.symm; assumption\n      | trans _ _ _ _ _ hab hbc => exact h.trans hab hbc)\n    (EqvGen.rel a b)\n\n"}
{"name":"Equivalence.eqvGen_eq","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\nh : Equivalence r\n⊢ Eq (Relation.EqvGen r) r","decl":"theorem Equivalence.eqvGen_eq (h : Equivalence r) : EqvGen r = r :=\n  funext fun _ ↦ funext fun _ ↦ propext <| h.eqvGen_iff\n\n"}
{"name":"Quot.exact","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\na b : α\nH : Eq (Quot.mk r a) (Quot.mk r b)\n⊢ Relation.EqvGen r a b","decl":"@[deprecated (since := \"2024-08-29\")] alias Quot.exact := Quot.eqvGen_exact\n"}
{"name":"Quot.EqvGen_sound","module":"Mathlib.Logic.Relation","initialProofState":"α : Type u_1\nr : α → α → Prop\na b : α\nH : Relation.EqvGen r a b\n⊢ Eq (Quot.mk r a) (Quot.mk r b)","decl":"@[deprecated (since := \"2024-08-29\")] alias Quot.EqvGen_sound := Quot.eqvGen_sound\n\n"}
