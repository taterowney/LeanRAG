{"name":"Polynomial.natDegree_pos_of_aeval_root","module":"Mathlib.Algebra.Polynomial.RingDivision","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\np : Polynomial R\nhp : Ne p 0\nz : S\nhz : Eq ((Polynomial.aeval z) p) 0\ninj : ∀ (x : R), Eq ((algebraMap R S) x) 0 → Eq x 0\n⊢ LT.lt 0 p.natDegree","decl":"theorem natDegree_pos_of_aeval_root [Algebra R S] {p : R[X]} (hp : p ≠ 0) {z : S}\n    (hz : aeval z p = 0) (inj : ∀ x : R, algebraMap R S x = 0 → x = 0) : 0 < p.natDegree :=\n  natDegree_pos_of_eval₂_root hp (algebraMap R S) hz inj\n\n"}
{"name":"Polynomial.degree_pos_of_aeval_root","module":"Mathlib.Algebra.Polynomial.RingDivision","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\np : Polynomial R\nhp : Ne p 0\nz : S\nhz : Eq ((Polynomial.aeval z) p) 0\ninj : ∀ (x : R), Eq ((algebraMap R S) x) 0 → Eq x 0\n⊢ LT.lt 0 p.degree","decl":"theorem degree_pos_of_aeval_root [Algebra R S] {p : R[X]} (hp : p ≠ 0) {z : S} (hz : aeval z p = 0)\n    (inj : ∀ x : R, algebraMap R S x = 0 → x = 0) : 0 < p.degree :=\n  natDegree_pos_iff_degree_pos.mp (natDegree_pos_of_aeval_root hp hz inj)\n\n"}
{"name":"Polynomial.smul_modByMonic","module":"Mathlib.Algebra.Polynomial.RingDivision","initialProofState":"R : Type u\ninst✝ : CommRing R\nq : Polynomial R\nc : R\np : Polynomial R\n⊢ Eq ((HSMul.hSMul c p).modByMonic q) (HSMul.hSMul c (p.modByMonic q))","decl":"theorem smul_modByMonic (c : R) (p : R[X]) : c • p %ₘ q = c • (p %ₘ q) := by\n  by_cases hq : q.Monic\n  · cases' subsingleton_or_nontrivial R with hR hR\n    · simp only [eq_iff_true_of_subsingleton]\n    · exact\n      (div_modByMonic_unique (c • (p /ₘ q)) (c • (p %ₘ q)) hq\n          ⟨by rw [mul_smul_comm, ← smul_add, modByMonic_add_div p hq],\n            (degree_smul_le _ _).trans_lt (degree_modByMonic_lt _ hq)⟩).2\n  · simp_rw [modByMonic_eq_of_not_monic _ hq]\n\n"}
{"name":"Polynomial.modByMonicHom_apply","module":"Mathlib.Algebra.Polynomial.RingDivision","initialProofState":"R : Type u\ninst✝ : CommRing R\nq p : Polynomial R\n⊢ Eq (q.modByMonicHom p) (p.modByMonic q)","decl":"/-- `_ %ₘ q` as an `R`-linear map. -/\n@[simps]\ndef modByMonicHom (q : R[X]) : R[X] →ₗ[R] R[X] where\n  toFun p := p %ₘ q\n  map_add' := add_modByMonic\n  map_smul' := smul_modByMonic\n\n"}
{"name":"Polynomial.mem_ker_modByMonic","module":"Mathlib.Algebra.Polynomial.RingDivision","initialProofState":"R : Type u\ninst✝ : CommRing R\nq : Polynomial R\nhq : q.Monic\np : Polynomial R\n⊢ Iff (Membership.mem (LinearMap.ker q.modByMonicHom) p) (Dvd.dvd q p)","decl":"theorem mem_ker_modByMonic (hq : q.Monic) {p : R[X]} :\n    p ∈ LinearMap.ker (modByMonicHom q) ↔ q ∣ p :=\n  LinearMap.mem_ker.trans (modByMonic_eq_zero_iff_dvd hq)\n\n"}
{"name":"Polynomial.aeval_modByMonic_eq_self_of_root","module":"Mathlib.Algebra.Polynomial.RingDivision","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring S\ninst✝ : Algebra R S\np q : Polynomial R\nhq : q.Monic\nx : S\nhx : Eq ((Polynomial.aeval x) q) 0\n⊢ Eq ((Polynomial.aeval x) (p.modByMonic q)) ((Polynomial.aeval x) p)","decl":"theorem aeval_modByMonic_eq_self_of_root [Algebra R S] {p q : R[X]} (hq : q.Monic) {x : S}\n    (hx : aeval x q = 0) : aeval x (p %ₘ q) = aeval x p := by\n    --`eval₂_modByMonic_eq_self_of_root` doesn't work here as it needs commutativity\n  rw [modByMonic_eq_sub_mul_div p hq, _root_.map_sub, _root_.map_mul, hx, zero_mul,\n    sub_zero]\n\n"}
{"name":"Polynomial.trailingDegree_mul","module":"Mathlib.Algebra.Polynomial.RingDivision","initialProofState":"R : Type u\ninst✝¹ : Semiring R\ninst✝ : NoZeroDivisors R\np q : Polynomial R\n⊢ Eq (HMul.hMul p q).trailingDegree (HAdd.hAdd p.trailingDegree q.trailingDegree)","decl":"theorem trailingDegree_mul : (p * q).trailingDegree = p.trailingDegree + q.trailingDegree := by\n  by_cases hp : p = 0\n  · rw [hp, zero_mul, trailingDegree_zero, top_add]\n  by_cases hq : q = 0\n  · rw [hq, mul_zero, trailingDegree_zero, add_top]\n  · rw [trailingDegree_eq_natTrailingDegree hp, trailingDegree_eq_natTrailingDegree hq,\n    trailingDegree_eq_natTrailingDegree (mul_ne_zero hp hq), natTrailingDegree_mul hp hq]\n    apply WithTop.coe_add\n\n"}
{"name":"Polynomial.rootMultiplicity_eq_rootMultiplicity","module":"Mathlib.Algebra.Polynomial.RingDivision","initialProofState":"R : Type u\ninst✝ : CommRing R\np : Polynomial R\nt : R\n⊢ Eq (Polynomial.rootMultiplicity t p) (Polynomial.rootMultiplicity 0 (p.comp (HAdd.hAdd Polynomial.X (Polynomial.C t))))","decl":"theorem rootMultiplicity_eq_rootMultiplicity {p : R[X]} {t : R} :\n    p.rootMultiplicity t = (p.comp (X + C t)).rootMultiplicity 0 := by\n  classical\n  simp_rw [rootMultiplicity_eq_multiplicity, comp_X_add_C_eq_zero_iff]\n  congr 1\n  rw [C_0, sub_zero]\n  convert (multiplicity_map_eq <| algEquivAevalXAddC t).symm using 2\n  simp [C_eq_algebraMap]\n\n"}
{"name":"Polynomial.rootMultiplicity_eq_natTrailingDegree","module":"Mathlib.Algebra.Polynomial.RingDivision","initialProofState":"R : Type u\ninst✝ : CommRing R\np : Polynomial R\nt : R\n⊢ Eq (Polynomial.rootMultiplicity t p) (p.comp (HAdd.hAdd Polynomial.X (Polynomial.C t))).natTrailingDegree","decl":"/-- See `Polynomial.rootMultiplicity_eq_natTrailingDegree'` for the special case of `t = 0`. -/\ntheorem rootMultiplicity_eq_natTrailingDegree {p : R[X]} {t : R} :\n    p.rootMultiplicity t = (p.comp (X + C t)).natTrailingDegree :=\n  rootMultiplicity_eq_rootMultiplicity.trans rootMultiplicity_eq_natTrailingDegree'\n\n"}
{"name":"Polynomial.Monic.mem_nonZeroDivisors","module":"Mathlib.Algebra.Polynomial.RingDivision","initialProofState":"R : Type u\ninst✝ : CommRing R\np : Polynomial R\nh : p.Monic\n⊢ Membership.mem (nonZeroDivisors (Polynomial R)) p","decl":"theorem Monic.mem_nonZeroDivisors {p : R[X]} (h : p.Monic) : p ∈ R[X]⁰ :=\n  mem_nonZeroDivisors_iff.2 fun _ hx ↦ (mul_left_eq_zero_iff h).1 hx\n\n"}
{"name":"Polynomial.mem_nonZeroDivisors_of_leadingCoeff","module":"Mathlib.Algebra.Polynomial.RingDivision","initialProofState":"R : Type u\ninst✝ : CommRing R\np : Polynomial R\nh : Membership.mem (nonZeroDivisors R) p.leadingCoeff\n⊢ Membership.mem (nonZeroDivisors (Polynomial R)) p","decl":"theorem mem_nonZeroDivisors_of_leadingCoeff {p : R[X]} (h : p.leadingCoeff ∈ R⁰) : p ∈ R[X]⁰ := by\n  refine mem_nonZeroDivisors_iff.2 fun x hx ↦ leadingCoeff_eq_zero.1 ?_\n  by_contra hx'\n  rw [← mul_right_mem_nonZeroDivisors_eq_zero_iff h] at hx'\n  simp only [← leadingCoeff_mul' hx', hx, leadingCoeff_zero, not_true] at hx'\n\n"}
{"name":"Polynomial.rootMultiplicity_mul_X_sub_C_pow","module":"Mathlib.Algebra.Polynomial.RingDivision","initialProofState":"R : Type u\ninst✝ : CommRing R\np : Polynomial R\na : R\nn : Nat\nh : Ne p 0\n⊢ Eq (Polynomial.rootMultiplicity a (HMul.hMul p (HPow.hPow (HSub.hSub Polynomial.X (Polynomial.C a)) n))) (HAdd.hAdd (Polynomial.rootMultiplicity a p) n)","decl":"theorem rootMultiplicity_mul_X_sub_C_pow {p : R[X]} {a : R} {n : ℕ} (h : p ≠ 0) :\n    (p * (X - C a) ^ n).rootMultiplicity a = p.rootMultiplicity a + n := by\n  have h2 := monic_X_sub_C a |>.pow n |>.mul_left_ne_zero h\n  refine le_antisymm ?_ ?_\n  · rw [rootMultiplicity_le_iff h2, add_assoc, add_comm n, ← add_assoc, pow_add,\n      dvd_cancel_right_mem_nonZeroDivisors (monic_X_sub_C a |>.pow n |>.mem_nonZeroDivisors)]\n    exact pow_rootMultiplicity_not_dvd h a\n  · rw [le_rootMultiplicity_iff h2, pow_add]\n    exact mul_dvd_mul_right (pow_rootMultiplicity_dvd p a) _\n\n"}
{"name":"Polynomial.rootMultiplicity_X_sub_C_pow","module":"Mathlib.Algebra.Polynomial.RingDivision","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : Nontrivial R\na : R\nn : Nat\n⊢ Eq (Polynomial.rootMultiplicity a (HPow.hPow (HSub.hSub Polynomial.X (Polynomial.C a)) n)) n","decl":"/-- The multiplicity of `a` as root of `(X - a) ^ n` is `n`. -/\ntheorem rootMultiplicity_X_sub_C_pow [Nontrivial R] (a : R) (n : ℕ) :\n    rootMultiplicity a ((X - C a) ^ n) = n := by\n  have := rootMultiplicity_mul_X_sub_C_pow (a := a) (n := n) C.map_one_ne_zero\n  rwa [rootMultiplicity_C, map_one, one_mul, zero_add] at this\n\n"}
{"name":"Polynomial.rootMultiplicity_X_sub_C_self","module":"Mathlib.Algebra.Polynomial.RingDivision","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : Nontrivial R\nx : R\n⊢ Eq (Polynomial.rootMultiplicity x (HSub.hSub Polynomial.X (Polynomial.C x))) 1","decl":"theorem rootMultiplicity_X_sub_C_self [Nontrivial R] {x : R} :\n    rootMultiplicity x (X - C x) = 1 :=\n  pow_one (X - C x) ▸ rootMultiplicity_X_sub_C_pow x 1\n\n-- Porting note: swapped instance argument order\n"}
{"name":"Polynomial.rootMultiplicity_X_sub_C","module":"Mathlib.Algebra.Polynomial.RingDivision","initialProofState":"R : Type u\ninst✝² : CommRing R\ninst✝¹ : Nontrivial R\ninst✝ : DecidableEq R\nx y : R\n⊢ Eq (Polynomial.rootMultiplicity x (HSub.hSub Polynomial.X (Polynomial.C y))) (ite (Eq x y) 1 0)","decl":"theorem rootMultiplicity_X_sub_C [Nontrivial R] [DecidableEq R] {x y : R} :\n    rootMultiplicity x (X - C y) = if x = y then 1 else 0 := by\n  split_ifs with hxy\n  · rw [hxy]\n    exact rootMultiplicity_X_sub_C_self\n  exact rootMultiplicity_eq_zero (mt root_X_sub_C.mp (Ne.symm hxy))\n\n"}
{"name":"Polynomial.rootMultiplicity_mul'","module":"Mathlib.Algebra.Polynomial.RingDivision","initialProofState":"R : Type u\ninst✝ : CommRing R\np q : Polynomial R\nx : R\nhpq : Ne (HMul.hMul (Polynomial.eval x (p.divByMonic (HPow.hPow (HSub.hSub Polynomial.X (Polynomial.C x)) (Polynomial.rootMultiplicity x p)))) (Polynomial.eval x (q.divByMonic (HPow.hPow (HSub.hSub Polynomial.X (Polynomial.C x)) (Polynomial.rootMultiplicity x q))))) 0\n⊢ Eq (Polynomial.rootMultiplicity x (HMul.hMul p q)) (HAdd.hAdd (Polynomial.rootMultiplicity x p) (Polynomial.rootMultiplicity x q))","decl":"theorem rootMultiplicity_mul' {p q : R[X]} {x : R}\n    (hpq : (p /ₘ (X - C x) ^ p.rootMultiplicity x).eval x *\n      (q /ₘ (X - C x) ^ q.rootMultiplicity x).eval x ≠ 0) :\n    rootMultiplicity x (p * q) = rootMultiplicity x p + rootMultiplicity x q := by\n  simp_rw [eval_divByMonic_eq_trailingCoeff_comp] at hpq\n  simp_rw [rootMultiplicity_eq_natTrailingDegree, mul_comp, natTrailingDegree_mul' hpq]\n\n"}
{"name":"Polynomial.Monic.neg_one_pow_natDegree_mul_comp_neg_X","module":"Mathlib.Algebra.Polynomial.RingDivision","initialProofState":"R : Type u\ninst✝ : CommRing R\np : Polynomial R\nhp : p.Monic\n⊢ (HMul.hMul (HPow.hPow (-1) p.natDegree) (p.comp (Neg.neg Polynomial.X))).Monic","decl":"theorem Monic.neg_one_pow_natDegree_mul_comp_neg_X {p : R[X]} (hp : p.Monic) :\n    ((-1) ^ p.natDegree * p.comp (-X)).Monic := by\n  simp only [Monic]\n  calc\n    ((-1) ^ p.natDegree * p.comp (-X)).leadingCoeff =\n        (p.comp (-X) * C ((-1) ^ p.natDegree)).leadingCoeff := by\n      simp [mul_comm]\n    _ = 1 := by\n      apply monic_mul_C_of_leadingCoeff_mul_eq_one\n      simp [← pow_add, hp]\n\n"}
{"name":"Polynomial.degree_eq_degree_of_associated","module":"Mathlib.Algebra.Polynomial.RingDivision","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\np q : Polynomial R\nh : Associated p q\n⊢ Eq p.degree q.degree","decl":"theorem degree_eq_degree_of_associated (h : Associated p q) : degree p = degree q := by\n  let ⟨u, hu⟩ := h\n  simp [hu.symm]\n\n"}
{"name":"Polynomial.prime_X_sub_C","module":"Mathlib.Algebra.Polynomial.RingDivision","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nr : R\n⊢ Prime (HSub.hSub Polynomial.X (Polynomial.C r))","decl":"theorem prime_X_sub_C (r : R) : Prime (X - C r) :=\n  ⟨X_sub_C_ne_zero r, not_isUnit_X_sub_C r, fun _ _ => by\n    simp_rw [dvd_iff_isRoot, IsRoot.def, eval_mul, mul_eq_zero]\n    exact id⟩\n\n"}
{"name":"Polynomial.prime_X","module":"Mathlib.Algebra.Polynomial.RingDivision","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\n⊢ Prime Polynomial.X","decl":"theorem prime_X : Prime (X : R[X]) := by\n  convert prime_X_sub_C (0 : R)\n  simp\n\n"}
{"name":"Polynomial.Monic.prime_of_degree_eq_one","module":"Mathlib.Algebra.Polynomial.RingDivision","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\np : Polynomial R\nhp1 : Eq p.degree 1\nhm : p.Monic\n⊢ Prime p","decl":"theorem Monic.prime_of_degree_eq_one (hp1 : degree p = 1) (hm : Monic p) : Prime p :=\n  have : p = X - C (-p.coeff 0) := by simpa [hm.leadingCoeff] using eq_X_add_C_of_degree_eq_one hp1\n  this.symm ▸ prime_X_sub_C _\n\n"}
{"name":"Polynomial.irreducible_X_sub_C","module":"Mathlib.Algebra.Polynomial.RingDivision","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nr : R\n⊢ Irreducible (HSub.hSub Polynomial.X (Polynomial.C r))","decl":"theorem irreducible_X_sub_C (r : R) : Irreducible (X - C r) :=\n  (prime_X_sub_C r).irreducible\n\n"}
{"name":"Polynomial.irreducible_X","module":"Mathlib.Algebra.Polynomial.RingDivision","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\n⊢ Irreducible Polynomial.X","decl":"theorem irreducible_X : Irreducible (X : R[X]) :=\n  Prime.irreducible prime_X\n\n"}
{"name":"Polynomial.Monic.irreducible_of_degree_eq_one","module":"Mathlib.Algebra.Polynomial.RingDivision","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\np : Polynomial R\nhp1 : Eq p.degree 1\nhm : p.Monic\n⊢ Irreducible p","decl":"theorem Monic.irreducible_of_degree_eq_one (hp1 : degree p = 1) (hm : Monic p) : Irreducible p :=\n  (hm.prime_of_degree_eq_one hp1).irreducible\n\n"}
{"name":"Polynomial.aeval_ne_zero_of_isCoprime","module":"Mathlib.Algebra.Polynomial.RingDivision","initialProofState":"S : Type v\nR : Type u_1\ninst✝³ : CommSemiring R\ninst✝² : Nontrivial S\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\np q : Polynomial R\nh : IsCoprime p q\ns : S\n⊢ Or (Ne ((Polynomial.aeval s) p) 0) (Ne ((Polynomial.aeval s) q) 0)","decl":"lemma aeval_ne_zero_of_isCoprime {R} [CommSemiring R] [Nontrivial S] [Semiring S] [Algebra R S]\n    {p q : R[X]} (h : IsCoprime p q) (s : S) : aeval s p ≠ 0 ∨ aeval s q ≠ 0 := by\n  by_contra! hpq\n  rcases h with ⟨_, _, h⟩\n  apply_fun aeval s at h\n  simp only [map_add, map_mul, map_one, hpq.left, hpq.right, mul_zero, add_zero, zero_ne_one] at h\n\n"}
{"name":"Polynomial.isCoprime_X_sub_C_of_isUnit_sub","module":"Mathlib.Algebra.Polynomial.RingDivision","initialProofState":"R : Type u_1\ninst✝ : CommRing R\na b : R\nh : IsUnit (HSub.hSub a b)\n⊢ IsCoprime (HSub.hSub Polynomial.X (Polynomial.C a)) (HSub.hSub Polynomial.X (Polynomial.C b))","decl":"theorem isCoprime_X_sub_C_of_isUnit_sub {R} [CommRing R] {a b : R} (h : IsUnit (a - b)) :\n    IsCoprime (X - C a) (X - C b) :=\n  ⟨-C h.unit⁻¹.val, C h.unit⁻¹.val, by\n    rw [neg_mul_comm, ← left_distrib, neg_add_eq_sub, sub_sub_sub_cancel_left, ← C_sub, ← C_mul]\n    rw [← C_1]\n    congr\n    exact h.val_inv_mul⟩\n\n"}
{"name":"Polynomial.pairwise_coprime_X_sub_C","module":"Mathlib.Algebra.Polynomial.RingDivision","initialProofState":"K : Type u_1\ninst✝ : Field K\nI : Type v\ns : I → K\nH : Function.Injective s\n⊢ Pairwise (Function.onFun IsCoprime fun i => HSub.hSub Polynomial.X (Polynomial.C (s i)))","decl":"open scoped Function in -- required for scoped `on` notation\ntheorem pairwise_coprime_X_sub_C {K} [Field K] {I : Type v} {s : I → K} (H : Function.Injective s) :\n    Pairwise (IsCoprime on fun i : I => X - C (s i)) := fun _ _ hij =>\n  isCoprime_X_sub_C_of_isUnit_sub (sub_ne_zero_of_ne <| H.ne hij).isUnit\n\n"}
{"name":"Polynomial.rootMultiplicity_mul","module":"Mathlib.Algebra.Polynomial.RingDivision","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\np q : Polynomial R\nx : R\nhpq : Ne (HMul.hMul p q) 0\n⊢ Eq (Polynomial.rootMultiplicity x (HMul.hMul p q)) (HAdd.hAdd (Polynomial.rootMultiplicity x p) (Polynomial.rootMultiplicity x q))","decl":"theorem rootMultiplicity_mul {p q : R[X]} {x : R} (hpq : p * q ≠ 0) :\n    rootMultiplicity x (p * q) = rootMultiplicity x p + rootMultiplicity x q := by\n  classical\n  have hp : p ≠ 0 := left_ne_zero_of_mul hpq\n  have hq : q ≠ 0 := right_ne_zero_of_mul hpq\n  rw [rootMultiplicity_eq_multiplicity (p * q), if_neg hpq, rootMultiplicity_eq_multiplicity p,\n    if_neg hp, rootMultiplicity_eq_multiplicity q, if_neg hq,\n    multiplicity_mul (prime_X_sub_C x) (finiteMultiplicity_X_sub_C _ hpq)]\n\n"}
{"name":"Polynomial.exists_multiset_roots","module":"Mathlib.Algebra.Polynomial.RingDivision","initialProofState":"R : Type u\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : DecidableEq R\np : Polynomial R\nx✝ : Ne p 0\n⊢ Exists fun s => And (LE.le (↑s.card) p.degree) (∀ (a : R), Eq (Multiset.count a s) (Polynomial.rootMultiplicity a p))","decl":"open Multiset in\ntheorem exists_multiset_roots [DecidableEq R] :\n    ∀ {p : R[X]} (_ : p ≠ 0), ∃ s : Multiset R,\n      (Multiset.card s : WithBot ℕ) ≤ degree p ∧ ∀ a, s.count a = rootMultiplicity a p\n  | p, hp =>\n    haveI := Classical.propDecidable (∃ x, IsRoot p x)\n    if h : ∃ x, IsRoot p x then\n      let ⟨x, hx⟩ := h\n      have hpd : 0 < degree p := degree_pos_of_root hp hx\n      have hd0 : p /ₘ (X - C x) ≠ 0 := fun h => by\n        rw [← mul_divByMonic_eq_iff_isRoot.2 hx, h, mul_zero] at hp; exact hp rfl\n      have wf : degree (p /ₘ (X - C x)) < degree p :=\n        degree_divByMonic_lt _ (monic_X_sub_C x) hp ((degree_X_sub_C x).symm ▸ by decide)\n      let ⟨t, htd, htr⟩ := @exists_multiset_roots _ (p /ₘ (X - C x)) hd0\n      have hdeg : degree (X - C x) ≤ degree p := by\n        rw [degree_X_sub_C, degree_eq_natDegree hp]\n        rw [degree_eq_natDegree hp] at hpd\n        exact WithBot.coe_le_coe.2 (WithBot.coe_lt_coe.1 hpd)\n      have hdiv0 : p /ₘ (X - C x) ≠ 0 :=\n        mt (divByMonic_eq_zero_iff (monic_X_sub_C x)).1 <| not_lt.2 hdeg\n      ⟨x ::ₘ t,\n        calc\n          (card (x ::ₘ t) : WithBot ℕ) = Multiset.card t + 1 := by\n            congr\n            exact mod_cast Multiset.card_cons _ _\n          _ ≤ degree p := by\n            rw [← degree_add_divByMonic (monic_X_sub_C x) hdeg, degree_X_sub_C, add_comm]\n            exact add_le_add (le_refl (1 : WithBot ℕ)) htd,\n        by\n          intro a\n          conv_rhs => rw [← mul_divByMonic_eq_iff_isRoot.mpr hx]\n          rw [rootMultiplicity_mul (mul_ne_zero (X_sub_C_ne_zero x) hdiv0),\n            rootMultiplicity_X_sub_C, ← htr a]\n          split_ifs with ha\n          · rw [ha, count_cons_self, add_comm]\n          · rw [count_cons_of_ne ha, zero_add]⟩\n    else\n      ⟨0, (degree_eq_natDegree hp).symm ▸ WithBot.coe_le_coe.2 (Nat.zero_le _), by\n        intro a\n        rw [count_zero, rootMultiplicity_eq_zero (not_exists.mp h a)]⟩\ntermination_by p => natDegree p\ndecreasing_by {\n  simp_wf\n  apply (Nat.cast_lt (α := WithBot ℕ)).mp\n  simp only [degree_eq_natDegree hp, degree_eq_natDegree hd0] at wf\n  assumption}\n\n"}
