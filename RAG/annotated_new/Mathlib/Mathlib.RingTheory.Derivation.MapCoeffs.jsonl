{"name":"Derivation.mapCoeffs_apply","module":"Mathlib.RingTheory.Derivation.MapCoeffs","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_3\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing A\ninst✝³ : Algebra R A\ninst✝² : AddCommGroup M\ninst✝¹ : Module A M\ninst✝ : Module R M\nd : Derivation R A M\np : Polynomial A\ni : Nat\n⊢ Eq ((d.mapCoeffs p) i) (d (p.coeff i))","decl":"@[simp]\nlemma mapCoeffs_apply (p : A[X]) (i) :\n    d.mapCoeffs p i = d (coeff p i) := rfl\n\n"}
{"name":"Derivation.mapCoeffs_monomial","module":"Mathlib.RingTheory.Derivation.MapCoeffs","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_3\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing A\ninst✝³ : Algebra R A\ninst✝² : AddCommGroup M\ninst✝¹ : Module A M\ninst✝ : Module R M\nd : Derivation R A M\nn : Nat\nx : A\n⊢ Eq (d.mapCoeffs ((Polynomial.monomial n) x)) ((PolynomialModule.single A n) (d x))","decl":"@[simp]\nlemma mapCoeffs_monomial (n : ℕ) (x : A) :\n    d.mapCoeffs (monomial n x) = .single A n (d x) := Finsupp.ext fun _ ↦ by\n  simp [coeff_monomial, apply_ite d, PolynomialModule.single_apply]\n\n"}
{"name":"Derivation.mapCoeffs_X","module":"Mathlib.RingTheory.Derivation.MapCoeffs","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_3\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing A\ninst✝³ : Algebra R A\ninst✝² : AddCommGroup M\ninst✝¹ : Module A M\ninst✝ : Module R M\nd : Derivation R A M\n⊢ Eq (d.mapCoeffs Polynomial.X) 0","decl":"@[simp]\nlemma mapCoeffs_X :\n    d.mapCoeffs (X : A[X]) = 0 := by simp [← monomial_one_one_eq_X]\n\n"}
{"name":"Derivation.mapCoeffs_C","module":"Mathlib.RingTheory.Derivation.MapCoeffs","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_3\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing A\ninst✝³ : Algebra R A\ninst✝² : AddCommGroup M\ninst✝¹ : Module A M\ninst✝ : Module R M\nd : Derivation R A M\nx : A\n⊢ Eq (d.mapCoeffs (Polynomial.C x)) ((PolynomialModule.single A 0) (d x))","decl":"@[simp]\nlemma mapCoeffs_C (x : A) :\n    d.mapCoeffs (C x) = .single A 0 (d x) := by simp [← monomial_zero_left]\n\n"}
{"name":"Derivation.apply_aeval_eq'","module":"Mathlib.RingTheory.Derivation.MapCoeffs","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_3\ninst✝¹² : CommRing R\ninst✝¹¹ : CommRing A\ninst✝¹⁰ : Algebra R A\ninst✝⁹ : AddCommGroup M\ninst✝⁸ : Module A M\ninst✝⁷ : Module R M\nd : Derivation R A M\nB : Type u_4\nM' : Type u_5\ninst✝⁶ : CommRing B\ninst✝⁵ : Algebra R B\ninst✝⁴ : Algebra A B\ninst✝³ : AddCommGroup M'\ninst✝² : Module B M'\ninst✝¹ : Module R M'\ninst✝ : Module A M'\nd' : Derivation R B M'\nf : LinearMap (RingHom.id A) M M'\nh : ∀ (a : A), Eq (f (d a)) (d' ((algebraMap A B) a))\nx : B\np : Polynomial A\n⊢ Eq (d' ((Polynomial.aeval x) p)) (HAdd.hAdd ((PolynomialModule.eval x) ((PolynomialModule.map B f) (d.mapCoeffs p))) (HSMul.hSMul ((Polynomial.aeval x) (Polynomial.derivative p)) (d' x)))","decl":"theorem apply_aeval_eq' (d' : Derivation R B M') (f : M →ₗ[A] M')\n    (h : ∀ a, f (d a) = d' (algebraMap A B a)) (x : B) (p : A[X]) :\n    d' (aeval x p) = PolynomialModule.eval x (PolynomialModule.map B f (d.mapCoeffs p)) +\n      aeval x (derivative p) • d' x := by\n  induction p using Polynomial.induction_on' with\n  | h_add => simp_all only [eval_add, map_add, add_smul]; abel\n  | h_monomial =>\n    simp only [aeval_monomial, leibniz, leibniz_pow, mapCoeffs_monomial,\n      PolynomialModule.map_single, PolynomialModule.eval_single, derivative_monomial, map_mul,\n      _root_.map_natCast, h]\n    rw [add_comm, ← smul_smul, ← smul_smul, Nat.cast_smul_eq_nsmul]\n\n\n"}
{"name":"Derivation.apply_aeval_eq","module":"Mathlib.RingTheory.Derivation.MapCoeffs","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : CommRing A\ninst✝⁹ : Algebra R A\nB : Type u_4\nM' : Type u_5\ninst✝⁸ : CommRing B\ninst✝⁷ : Algebra R B\ninst✝⁶ : Algebra A B\ninst✝⁵ : AddCommGroup M'\ninst✝⁴ : Module B M'\ninst✝³ : Module R M'\ninst✝² : Module A M'\ninst✝¹ : IsScalarTower R A B\ninst✝ : IsScalarTower A B M'\nd : Derivation R B M'\nx : B\np : Polynomial A\n⊢ Eq (d ((Polynomial.aeval x) p)) (HAdd.hAdd ((PolynomialModule.eval x) ((Derivation.compAlgebraMap A d).mapCoeffs p)) (HSMul.hSMul ((Polynomial.aeval x) (Polynomial.derivative p)) (d x)))","decl":"theorem apply_aeval_eq [IsScalarTower R A B] [IsScalarTower A B M'] (d : Derivation R B M')\n    (x : B) (p : A[X]) :\n    d (aeval x p) = PolynomialModule.eval x ((d.compAlgebraMap A).mapCoeffs p) +\n      aeval x (derivative p) • d x := by\n  convert apply_aeval_eq' (d.compAlgebraMap A) d LinearMap.id _ x p\n  · apply Finsupp.ext\n    intro x\n    rfl\n  · intro a\n    rfl\n\n"}
{"name":"Derivation.apply_eval_eq","module":"Mathlib.RingTheory.Derivation.MapCoeffs","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_3\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing A\ninst✝³ : Algebra R A\ninst✝² : AddCommGroup M\ninst✝¹ : Module A M\ninst✝ : Module R M\nd : Derivation R A M\nx : A\np : Polynomial A\n⊢ Eq (d (Polynomial.eval x p)) (HAdd.hAdd ((PolynomialModule.eval x) (d.mapCoeffs p)) (HSMul.hSMul (Polynomial.eval x (Polynomial.derivative p)) (d x)))","decl":"theorem apply_eval_eq (x : A) (p : A[X]) :\n    d (eval x p) = PolynomialModule.eval x (d.mapCoeffs p) + eval x (derivative p) • d x :=\n  apply_aeval_eq d x p\n\n"}
{"name":"Differential.coeff_mapCoeffs","module":"Mathlib.RingTheory.Derivation.MapCoeffs","initialProofState":"A : Type u_1\ninst✝¹ : CommRing A\ninst✝ : Differential A\np : Polynomial A\ni : Nat\n⊢ Eq ((Differential.mapCoeffs p).coeff i) (p.coeff i)′","decl":"@[simp]\nlemma coeff_mapCoeffs (p : A[X]) (i) :\n    coeff (mapCoeffs p) i = (coeff p i)′ := rfl\n\n"}
{"name":"Differential.mapCoeffs_monomial","module":"Mathlib.RingTheory.Derivation.MapCoeffs","initialProofState":"A : Type u_1\ninst✝¹ : CommRing A\ninst✝ : Differential A\nn : Nat\nx : A\n⊢ Eq (Differential.mapCoeffs ((Polynomial.monomial n) x)) ((Polynomial.monomial n) x′)","decl":"@[simp]\nlemma mapCoeffs_monomial (n : ℕ) (x : A) :\n    mapCoeffs (monomial n x) = monomial n x′ := by\n  simp [mapCoeffs]\n\n"}
{"name":"Differential.mapCoeffs_X","module":"Mathlib.RingTheory.Derivation.MapCoeffs","initialProofState":"A : Type u_1\ninst✝¹ : CommRing A\ninst✝ : Differential A\n⊢ Eq (Differential.mapCoeffs Polynomial.X) 0","decl":"@[simp]\nlemma mapCoeffs_X :\n    mapCoeffs (X : A[X]) = 0 := by simp [← monomial_one_one_eq_X]\n\n"}
{"name":"Differential.mapCoeffs_C","module":"Mathlib.RingTheory.Derivation.MapCoeffs","initialProofState":"A : Type u_1\ninst✝¹ : CommRing A\ninst✝ : Differential A\nx : A\n⊢ Eq (Differential.mapCoeffs (Polynomial.C x)) (Polynomial.C x′)","decl":"@[simp]\nlemma mapCoeffs_C (x : A) :\n    mapCoeffs (C x) = C x′ := by simp [← monomial_zero_left]\n\n"}
{"name":"Differential.deriv_aeval_eq","module":"Mathlib.RingTheory.Derivation.MapCoeffs","initialProofState":"A : Type u_1\ninst✝⁵ : CommRing A\ninst✝⁴ : Differential A\nR : Type u_2\ninst✝³ : CommRing R\ninst✝² : Differential R\ninst✝¹ : Algebra A R\ninst✝ : DifferentialAlgebra A R\nx : R\np : Polynomial A\n⊢ Eq ((Polynomial.aeval x) p)′ (HAdd.hAdd ((Polynomial.aeval x) (Differential.mapCoeffs p)) (HMul.hMul ((Polynomial.aeval x) (Polynomial.derivative p)) x′))","decl":"theorem deriv_aeval_eq (x : R) (p : A[X]) :\n    (aeval x p)′ = aeval x (mapCoeffs p) + aeval x (derivative p) * x′ := by\n  convert Derivation.apply_aeval_eq' Differential.deriv _ (Algebra.linearMap A R) ..\n  · simp [mapCoeffs]\n  · simp [deriv_algebraMap]\n\n"}
{"name":"Differential.implicitDeriv_C","module":"Mathlib.RingTheory.Derivation.MapCoeffs","initialProofState":"A : Type u_1\ninst✝¹ : CommRing A\ninst✝ : Differential A\nv : Polynomial A\nb : A\n⊢ Eq ((Differential.implicitDeriv v) (Polynomial.C b)) (Polynomial.C b′)","decl":"@[simp]\nlemma implicitDeriv_C (v : A[X]) (b : A) :\n    implicitDeriv v (C b) = C b′ := by\n  simp [implicitDeriv]\n\n"}
{"name":"Differential.implicitDeriv_X","module":"Mathlib.RingTheory.Derivation.MapCoeffs","initialProofState":"A : Type u_1\ninst✝¹ : CommRing A\ninst✝ : Differential A\nv : Polynomial A\n⊢ Eq ((Differential.implicitDeriv v) Polynomial.X) v","decl":"@[simp]\nlemma implicitDeriv_X (v : A[X]) :\n    implicitDeriv v X = v := by\n  simp [implicitDeriv]\n\n"}
{"name":"Differential.deriv_aeval_eq_implicitDeriv","module":"Mathlib.RingTheory.Derivation.MapCoeffs","initialProofState":"A : Type u_1\ninst✝⁵ : CommRing A\ninst✝⁴ : Differential A\nR : Type u_2\ninst✝³ : CommRing R\ninst✝² : Differential R\ninst✝¹ : Algebra A R\ninst✝ : DifferentialAlgebra A R\nx : R\nv : Polynomial A\nh : Eq x′ ((Polynomial.aeval x) v)\np : Polynomial A\n⊢ Eq ((Polynomial.aeval x) p)′ ((Polynomial.aeval x) ((Differential.implicitDeriv v) p))","decl":"lemma deriv_aeval_eq_implicitDeriv (x : R) (v : A[X]) (h : x′ = aeval x v) (p : A[X]) :\n    (aeval x p)′ = aeval x (implicitDeriv v p) := by\n  simp [deriv_aeval_eq, implicitDeriv, h, mul_comm]\n\n"}
{"name":"Differential.algHom_deriv","module":"Mathlib.RingTheory.Derivation.MapCoeffs","initialProofState":"A : Type u_1\ninst✝¹¹ : CommRing A\ninst✝¹⁰ : Differential A\nR : Type u_2\ninst✝⁹ : CommRing R\ninst✝⁸ : Differential R\ninst✝⁷ : Algebra A R\ninst✝⁶ : DifferentialAlgebra A R\nR' : Type u_3\ninst✝⁵ : CommRing R'\ninst✝⁴ : Differential R'\ninst✝³ : Algebra A R'\ninst✝² : DifferentialAlgebra A R'\ninst✝¹ : IsDomain R'\ninst✝ : Nontrivial R\nf : AlgHom A R R'\nhf : Function.Injective ⇑f\nx : R\nh : IsSeparable A x\n⊢ Eq (f x′) (f x)′","decl":"lemma algHom_deriv (f : R →ₐ[A] R') (hf : Function.Injective f) (x : R) (h : IsSeparable A x) :\n    f (x′) = (f x)′ := by\n  let p := minpoly A x\n  apply mul_left_cancel₀ (a := aeval (f x) (derivative p))\n  · rw [Polynomial.aeval_algHom]\n    simp only [AlgHom.coe_comp, Function.comp_apply, ne_eq, map_eq_zero_iff f hf]\n    apply Separable.aeval_derivative_ne_zero h (minpoly.aeval A x)\n  conv => lhs; rw [Polynomial.aeval_algHom]\n  simp [← map_mul]\n  apply add_left_cancel (a := aeval (f x) (mapCoeffs p))\n  rw [← deriv_aeval_eq]\n  simp only [aeval_algHom, AlgHom.coe_comp, Function.comp_apply, ← map_add, ← deriv_aeval_eq,\n    minpoly.aeval, map_zero, p]\n\n"}
{"name":"Differential.algEquiv_deriv","module":"Mathlib.RingTheory.Derivation.MapCoeffs","initialProofState":"A : Type u_1\ninst✝¹⁰ : CommRing A\ninst✝⁹ : Differential A\nR : Type u_2\ninst✝⁸ : CommRing R\ninst✝⁷ : Differential R\ninst✝⁶ : Algebra A R\ninst✝⁵ : DifferentialAlgebra A R\nR' : Type u_3\ninst✝⁴ : CommRing R'\ninst✝³ : Differential R'\ninst✝² : Algebra A R'\ninst✝¹ : DifferentialAlgebra A R'\ninst✝ : IsDomain R'\nf : AlgEquiv A R R'\nx : R\nh : IsSeparable A x\n⊢ Eq (f x′) (f x)′","decl":"omit [Nontrivial R] in\nlemma algEquiv_deriv (f : R ≃ₐ[A] R') (x : R) (h : IsSeparable A x) :\n    f (x′) = (f x)′ :=\n  haveI := f.nontrivial\n  algHom_deriv f.toAlgHom f.injective x h\n\n"}
{"name":"Differential.algHom_deriv'","module":"Mathlib.RingTheory.Derivation.MapCoeffs","initialProofState":"A : Type u_1\ninst✝¹² : CommRing A\ninst✝¹¹ : Differential A\nR : Type u_2\ninst✝¹⁰ : CommRing R\ninst✝⁹ : Differential R\ninst✝⁸ : Algebra A R\ninst✝⁷ : DifferentialAlgebra A R\nR' : Type u_3\ninst✝⁶ : CommRing R'\ninst✝⁵ : Differential R'\ninst✝⁴ : Algebra A R'\ninst✝³ : DifferentialAlgebra A R'\ninst✝² : IsDomain R'\ninst✝¹ : Nontrivial R\ninst✝ : Algebra.IsSeparable A R\nf : AlgHom A R R'\nhf : Function.Injective ⇑f\nx : R\n⊢ Eq (f x′) (f x)′","decl":"/--\n`algHom_deriv` in a separable algebra\n-/\nlemma algHom_deriv' (f : R →ₐ[A] R') (hf : Function.Injective f) (x : R) :\n    f (x′) = (f x)′ := algHom_deriv f hf x (Algebra.IsSeparable.isSeparable' x)\n\n"}
{"name":"Differential.algEquiv_deriv'","module":"Mathlib.RingTheory.Derivation.MapCoeffs","initialProofState":"A : Type u_1\ninst✝¹¹ : CommRing A\ninst✝¹⁰ : Differential A\nR : Type u_2\ninst✝⁹ : CommRing R\ninst✝⁸ : Differential R\ninst✝⁷ : Algebra A R\ninst✝⁶ : DifferentialAlgebra A R\nR' : Type u_3\ninst✝⁵ : CommRing R'\ninst✝⁴ : Differential R'\ninst✝³ : Algebra A R'\ninst✝² : DifferentialAlgebra A R'\ninst✝¹ : IsDomain R'\ninst✝ : Algebra.IsSeparable A R\nf : AlgEquiv A R R'\nx : R\n⊢ Eq (f x′) (f x)′","decl":"omit [Nontrivial R] in\n/--\n`algEquiv_deriv` in a separable algebra\n-/\nlemma algEquiv_deriv' (f : R ≃ₐ[A] R') (x : R) :\n    f (x′) = (f x)′ :=\n  haveI := f.nontrivial\n  algHom_deriv' f.toAlgHom f.injective x\n\n"}
