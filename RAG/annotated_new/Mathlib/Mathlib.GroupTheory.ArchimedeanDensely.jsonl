{"name":"Subgroup.mem_closure_singleton_iff_existsUnique_zpow","module":"Mathlib.GroupTheory.ArchimedeanDensely","initialProofState":"G : Type u_1\ninst✝ : LinearOrderedCommGroup G\na b : G\nha : Ne a 1\n⊢ Iff (Membership.mem (Subgroup.closure (Singleton.singleton a)) b) (ExistsUnique fun k => Eq (HPow.hPow a k) b)","decl":"/-- The subgroup generated by an element of a group equals the set of\ninteger powers of the element, such that each power is a unique element.\nThis is the stronger version of `Subgroup.mem_closure_singleton`. -/\n@[to_additive \"The additive subgroup generated by an element of an additive group equals the set of\ninteger multiples of the element, such that each multiple is a unique element.\nThis is the stronger version of `AddSubgroup.mem_closure_singleton`.\"]\nlemma Subgroup.mem_closure_singleton_iff_existsUnique_zpow {G : Type*}\n    [LinearOrderedCommGroup G] {a b : G} (ha : a ≠ 1) :\n    b ∈ closure {a} ↔ ∃! k : ℤ, a ^ k = b := by\n  rw [mem_closure_singleton]\n  constructor\n  · suffices Function.Injective (a ^ · : ℤ → G) by\n      rintro ⟨m, rfl⟩\n      exact ⟨m, rfl, fun k hk ↦ this hk⟩\n    rcases ha.lt_or_lt with ha | ha\n    · exact (zpow_right_strictAnti ha).injective\n    · exact (zpow_right_strictMono ha).injective\n  · exact fun h ↦ h.exists\n\n"}
{"name":"AddSubgroup.mem_closure_singleton_iff_existsUnique_zsmul","module":"Mathlib.GroupTheory.ArchimedeanDensely","initialProofState":"G : Type u_1\ninst✝ : LinearOrderedAddCommGroup G\na b : G\nha : Ne a 0\n⊢ Iff (Membership.mem (AddSubgroup.closure (Singleton.singleton a)) b) (ExistsUnique fun k => Eq (HSMul.hSMul k a) b)","decl":"/-- The subgroup generated by an element of a group equals the set of\ninteger powers of the element, such that each power is a unique element.\nThis is the stronger version of `Subgroup.mem_closure_singleton`. -/\n@[to_additive \"The additive subgroup generated by an element of an additive group equals the set of\ninteger multiples of the element, such that each multiple is a unique element.\nThis is the stronger version of `AddSubgroup.mem_closure_singleton`.\"]\nlemma Subgroup.mem_closure_singleton_iff_existsUnique_zpow {G : Type*}\n    [LinearOrderedCommGroup G] {a b : G} (ha : a ≠ 1) :\n    b ∈ closure {a} ↔ ∃! k : ℤ, a ^ k = b := by\n  rw [mem_closure_singleton]\n  constructor\n  · suffices Function.Injective (a ^ · : ℤ → G) by\n      rintro ⟨m, rfl⟩\n      exact ⟨m, rfl, fun k hk ↦ this hk⟩\n    rcases ha.lt_or_lt with ha | ha\n    · exact (zpow_right_strictAnti ha).injective\n    · exact (zpow_right_strictMono ha).injective\n  · exact fun h ↦ h.exists\n\n"}
{"name":"Subgroup.isLeast_of_closure_iff_eq_mabs","module":"Mathlib.GroupTheory.ArchimedeanDensely","initialProofState":"G : Type u_1\ninst✝¹ : LinearOrderedCommGroup G\ninst✝ : MulArchimedean G\na b : G\n⊢ Iff (IsLeast (setOf fun y => And (Membership.mem (Subgroup.closure (Singleton.singleton a)) y) (LT.lt 1 y)) b) (And (Eq b (mabs a)) (LT.lt 1 b))","decl":"@[to_additive]\nlemma Subgroup.isLeast_of_closure_iff_eq_mabs {a b : G} :\n    IsLeast {y : G | y ∈ closure ({a} : Set G) ∧ 1 < y} b ↔ b = |a|ₘ ∧ 1 < b := by\n  constructor <;> intro h\n  · have := Subgroup.cyclic_of_min h\n    have ha : a ∈ closure ({b} : Set G) := by\n      simp [← this]\n    rw [mem_closure_singleton] at ha\n    obtain ⟨n, rfl⟩ := ha\n    have := h.left\n    simp only [mem_closure_singleton, mem_setOf_eq, ← mul_zsmul] at this\n    obtain ⟨m, hm⟩ := this.left\n    have key : m * n = 1 := by\n      rw [← zpow_right_inj this.right, zpow_mul', hm, zpow_one]\n    rw [Int.mul_eq_one_iff_eq_one_or_neg_one] at key\n    rw [eq_comm]\n    rcases key with ⟨rfl, rfl⟩|⟨rfl, rfl⟩ <;>\n    simp [this.right.le, this.right, mabs]\n  · wlog ha : 1 ≤ a generalizing a\n    · convert @this (a⁻¹) ?_ (by simpa using le_of_not_le ha) using 4\n      · simp\n      · rwa [mabs_inv]\n    rw [mabs, sup_eq_left.mpr ((inv_le_one'.mpr ha).trans ha)] at h\n    rcases h with ⟨rfl, h⟩\n    refine ⟨?_, ?_⟩\n    · simp [h]\n    · intro x\n      simp only [mem_closure_singleton, mem_setOf_eq, and_imp, forall_exists_index]\n      rintro k rfl hk\n      rw [← zpow_one b, ← zpow_mul, one_mul, zpow_le_zpow_iff_right h, ← zero_add 1,\n          ← Int.lt_iff_add_one_le]\n      contrapose! hk\n      rw [← Left.one_le_inv_iff, ← zpow_neg]\n      exact one_le_zpow ha (by simp [hk])\n\n"}
{"name":"AddSubgroup.isLeast_of_closure_iff_eq_abs","module":"Mathlib.GroupTheory.ArchimedeanDensely","initialProofState":"G : Type u_1\ninst✝¹ : LinearOrderedAddCommGroup G\ninst✝ : Archimedean G\na b : G\n⊢ Iff (IsLeast (setOf fun y => And (Membership.mem (AddSubgroup.closure (Singleton.singleton a)) y) (LT.lt 0 y)) b) (And (Eq b (abs a)) (LT.lt 0 b))","decl":"@[to_additive]\nlemma Subgroup.isLeast_of_closure_iff_eq_mabs {a b : G} :\n    IsLeast {y : G | y ∈ closure ({a} : Set G) ∧ 1 < y} b ↔ b = |a|ₘ ∧ 1 < b := by\n  constructor <;> intro h\n  · have := Subgroup.cyclic_of_min h\n    have ha : a ∈ closure ({b} : Set G) := by\n      simp [← this]\n    rw [mem_closure_singleton] at ha\n    obtain ⟨n, rfl⟩ := ha\n    have := h.left\n    simp only [mem_closure_singleton, mem_setOf_eq, ← mul_zsmul] at this\n    obtain ⟨m, hm⟩ := this.left\n    have key : m * n = 1 := by\n      rw [← zpow_right_inj this.right, zpow_mul', hm, zpow_one]\n    rw [Int.mul_eq_one_iff_eq_one_or_neg_one] at key\n    rw [eq_comm]\n    rcases key with ⟨rfl, rfl⟩|⟨rfl, rfl⟩ <;>\n    simp [this.right.le, this.right, mabs]\n  · wlog ha : 1 ≤ a generalizing a\n    · convert @this (a⁻¹) ?_ (by simpa using le_of_not_le ha) using 4\n      · simp\n      · rwa [mabs_inv]\n    rw [mabs, sup_eq_left.mpr ((inv_le_one'.mpr ha).trans ha)] at h\n    rcases h with ⟨rfl, h⟩\n    refine ⟨?_, ?_⟩\n    · simp [h]\n    · intro x\n      simp only [mem_closure_singleton, mem_setOf_eq, and_imp, forall_exists_index]\n      rintro k rfl hk\n      rw [← zpow_one b, ← zpow_mul, one_mul, zpow_le_zpow_iff_right h, ← zero_add 1,\n          ← Int.lt_iff_add_one_le]\n      contrapose! hk\n      rw [← Left.one_le_inv_iff, ← zpow_neg]\n      exact one_le_zpow ha (by simp [hk])\n\n"}
{"name":"LinearOrderedAddCommGroup.discrete_or_denselyOrdered","module":"Mathlib.GroupTheory.ArchimedeanDensely","initialProofState":"G : Type u_2\ninst✝¹ : LinearOrderedAddCommGroup G\ninst✝ : Archimedean G\n⊢ Or (Nonempty (OrderAddMonoidIso G Int)) (DenselyOrdered G)","decl":"/-- Any linearly ordered archimedean additive group is either isomorphic (and order-isomorphic)\nto the integers, or is densely ordered. -/\nlemma LinearOrderedAddCommGroup.discrete_or_denselyOrdered (G : Type*)\n    [LinearOrderedAddCommGroup G] [Archimedean G] :\n    Nonempty (G ≃+o ℤ) ∨ DenselyOrdered G := by\n  by_cases H : ∃ x, IsLeast {y : G | 0 < y} x\n  · obtain ⟨x, hx⟩ := H\n    exact Or.inl ⟨(int_orderAddMonoidIso_of_isLeast_pos hx)⟩\n  · push_neg at H\n    refine Or.inr ⟨?_⟩\n    intro x y hxy\n    specialize H (y - x)\n    obtain ⟨z, hz⟩ : ∃ z : G, 0 < z ∧ z < y - x := by\n      contrapose! H\n      refine ⟨by simp [hxy], fun _ ↦ H _⟩\n    refine ⟨x + z, ?_, ?_⟩\n    · simp [hz.left]\n    · simpa [lt_sub_iff_add_lt'] using hz.right\n\n"}
{"name":"LinearOrderedAddCommGroup.discrete_iff_not_denselyOrdered","module":"Mathlib.GroupTheory.ArchimedeanDensely","initialProofState":"G : Type u_2\ninst✝¹ : LinearOrderedAddCommGroup G\ninst✝ : Archimedean G\n⊢ Iff (Nonempty (OrderAddMonoidIso G Int)) (Not (DenselyOrdered G))","decl":"/-- Any linearly ordered archimedean additive group is either isomorphic (and order-isomorphic)\nto the integers, or is densely ordered, exclusively. -/\nlemma LinearOrderedAddCommGroup.discrete_iff_not_denselyOrdered (G : Type*)\n    [LinearOrderedAddCommGroup G] [Archimedean G] :\n    Nonempty (G ≃+o ℤ) ↔ ¬ DenselyOrdered G := by\n  suffices ∀ (_ : G ≃+o ℤ), ¬ DenselyOrdered G by\n    rcases LinearOrderedAddCommGroup.discrete_or_denselyOrdered G with ⟨⟨h⟩⟩|h\n    · simpa [this h] using ⟨h⟩\n    · simp only [h, not_true_eq_false, iff_false, not_nonempty_iff]\n      exact ⟨fun H ↦ (this H) h⟩\n  intro e H\n  rw [denselyOrdered_iff_of_orderIsoClass e] at H\n  obtain ⟨_, _⟩ := exists_between (one_pos (α := ℤ))\n  omega\n\n"}
{"name":"LinearOrderedCommGroup.discrete_or_denselyOrdered","module":"Mathlib.GroupTheory.ArchimedeanDensely","initialProofState":"G : Type u_1\ninst✝¹ : LinearOrderedCommGroup G\ninst✝ : MulArchimedean G\n⊢ Or (Nonempty (OrderMonoidIso G (Multiplicative Int))) (DenselyOrdered G)","decl":"variable (G) in\n/-- Any linearly ordered mul-archimedean group is either isomorphic (and order-isomorphic)\nto the multiplicative integers, or is densely ordered. -/\n@[to_additive existing]\nlemma LinearOrderedCommGroup.discrete_or_denselyOrdered :\n    Nonempty (G ≃*o Multiplicative ℤ) ∨ DenselyOrdered G := by\n  refine (LinearOrderedAddCommGroup.discrete_or_denselyOrdered (Additive G)).imp ?_ id\n  rintro ⟨f, hf⟩\n  exact ⟨AddEquiv.toMultiplicative' f, hf⟩\n\n"}
{"name":"LinearOrderedCommGroup.discrete_iff_not_denselyOrdered","module":"Mathlib.GroupTheory.ArchimedeanDensely","initialProofState":"G : Type u_1\ninst✝¹ : LinearOrderedCommGroup G\ninst✝ : MulArchimedean G\n⊢ Iff (Nonempty (OrderMonoidIso G (Multiplicative Int))) (Not (DenselyOrdered G))","decl":"variable (G) in\n/-- Any linearly ordered mul-archimedean group is either isomorphic (and order-isomorphic)\nto the multiplicative integers, or is densely ordered, exclusively. -/\n@[to_additive existing]\nlemma LinearOrderedCommGroup.discrete_iff_not_denselyOrdered :\n    Nonempty (G ≃*o Multiplicative ℤ) ↔ ¬ DenselyOrdered G := by\n  let e : G ≃o Additive G := OrderIso.refl G\n  rw [denselyOrdered_iff_of_orderIsoClass e,\n    ← LinearOrderedAddCommGroup.discrete_iff_not_denselyOrdered (Additive G)]\n  refine Nonempty.congr ?_ ?_ <;> intro f\n  · exact ⟨MulEquiv.toAdditive' f, by simp⟩\n  · exact ⟨MulEquiv.toAdditive'.symm f, by simp⟩\n\n"}
{"name":"denselyOrdered_units_iff","module":"Mathlib.GroupTheory.ArchimedeanDensely","initialProofState":"G₀ : Type u_2\ninst✝¹ : LinearOrderedCommGroupWithZero G₀\ninst✝ : Nontrivial (Units G₀)\n⊢ Iff (DenselyOrdered (Units G₀)) (DenselyOrdered G₀)","decl":"lemma denselyOrdered_units_iff {G₀ : Type*} [LinearOrderedCommGroupWithZero G₀] [Nontrivial G₀ˣ] :\n    DenselyOrdered G₀ˣ ↔ DenselyOrdered G₀ := by\n  constructor\n  · intro H\n    refine ⟨fun x y h ↦ ?_⟩\n    rcases (zero_le' (a := x)).eq_or_lt with rfl|hx\n    · lift y to G₀ˣ using h.ne'.isUnit\n      obtain ⟨z, hz⟩ := exists_ne (1 : G₀ˣ)\n      refine ⟨(y * |z|ₘ⁻¹ : G₀ˣ), ?_, ?_⟩\n      · simp [zero_lt_iff]\n      · rw [Units.val_lt_val]\n        simp [hz]\n    · obtain ⟨z, hz, hz'⟩ := H.dense (Units.mk0 x hx.ne') (Units.mk0 y (hx.trans h).ne')\n        (by simp [← Units.val_lt_val, h])\n      refine ⟨z, ?_, ?_⟩ <;>\n      simpa [← Units.val_lt_val]\n  · intro H\n    refine ⟨fun x y h ↦ ?_⟩\n    obtain ⟨z, hz⟩ := exists_between (Units.val_lt_val.mpr h)\n    rcases (zero_le' (a := z)).eq_or_lt with rfl|hz'\n    · simp at hz\n    refine ⟨Units.mk0 z hz'.ne', ?_⟩\n    simp [← Units.val_lt_val, hz]\n\n"}
{"name":"LinearOrderedCommGroupWithZero.discrete_or_denselyOrdered","module":"Mathlib.GroupTheory.ArchimedeanDensely","initialProofState":"G : Type u_2\ninst✝² : LinearOrderedCommGroupWithZero G\ninst✝¹ : Nontrivial (Units G)\ninst✝ : MulArchimedean G\n⊢ Or (Nonempty (OrderMonoidIso G (WithZero (Multiplicative Int)))) (DenselyOrdered G)","decl":"/-- Any nontrivial (has other than 0 and 1) linearly ordered mul-archimedean group with zero is\neither isomorphic (and order-isomorphic) to `ℤₘ₀`, or is densely ordered. -/\nlemma LinearOrderedCommGroupWithZero.discrete_or_denselyOrdered (G : Type*)\n    [LinearOrderedCommGroupWithZero G] [Nontrivial Gˣ] [MulArchimedean G] :\n    Nonempty (G ≃*o ℤₘ₀) ∨ DenselyOrdered G := by\n  classical\n  rw [← denselyOrdered_units_iff]\n  refine (LinearOrderedCommGroup.discrete_or_denselyOrdered Gˣ).imp_left ?_\n  intro ⟨f⟩\n  refine ⟨OrderMonoidIso.trans\n    ⟨WithZero.withZeroUnitsEquiv.symm, ?_⟩ ⟨f.withZero, ?_⟩⟩\n  · intro\n    simp only [WithZero.withZeroUnitsEquiv, MulEquiv.symm_mk,\n      MulEquiv.toEquiv_eq_coe, Equiv.toFun_as_coe, EquivLike.coe_coe, MulEquiv.coe_mk,\n      Equiv.coe_fn_symm_mk ]\n    split_ifs <;>\n    simp_all [← Units.val_le_val]\n  · intro a b\n    induction a <;> induction b <;>\n    simp [MulEquiv.withZero]\n\n"}
{"name":"LinearOrderedCommGroupWithZero.discrete_iff_not_denselyOrdered","module":"Mathlib.GroupTheory.ArchimedeanDensely","initialProofState":"G : Type u_2\ninst✝² : LinearOrderedCommGroupWithZero G\ninst✝¹ : Nontrivial (Units G)\ninst✝ : MulArchimedean G\n⊢ Iff (Nonempty (OrderMonoidIso G (WithZero (Multiplicative Int)))) (Not (DenselyOrdered G))","decl":"open WithZero in\n/-- Any nontrivial (has other than 0 and 1) linearly ordered mul-archimedean group with zero is\neither isomorphic (and order-isomorphic) to `ℤₘ₀`, or is densely ordered, exclusively -/\nlemma LinearOrderedCommGroupWithZero.discrete_iff_not_denselyOrdered (G : Type*)\n    [LinearOrderedCommGroupWithZero G] [Nontrivial Gˣ] [MulArchimedean G] :\n    Nonempty (G ≃*o ℤₘ₀) ↔ ¬ DenselyOrdered G := by\n  rw [← denselyOrdered_units_iff,\n      ← LinearOrderedCommGroup.discrete_iff_not_denselyOrdered]\n  refine Nonempty.congr ?_ ?_ <;> intro f\n  · refine ⟨MulEquiv.unzero (withZeroUnitsEquiv.trans f), ?_⟩\n    intros\n    simp only [MulEquiv.unzero, withZeroUnitsEquiv, MulEquiv.trans_apply,\n      MulEquiv.coe_mk, Equiv.coe_fn_mk, recZeroCoe_coe, OrderMonoidIso.coe_mulEquiv,\n      MulEquiv.symm_trans_apply, MulEquiv.symm_mk, Equiv.coe_fn_symm_mk, map_eq_zero, coe_ne_zero,\n      ↓reduceDIte, unzero_coe, MulEquiv.toEquiv_eq_coe, Equiv.toFun_as_coe, EquivLike.coe_coe]\n    rw [← Units.val_le_val, ← map_le_map_iff f, ← coe_le_coe, coe_unzero, coe_unzero]\n  · refine ⟨withZeroUnitsEquiv.symm.trans (MulEquiv.withZero f), ?_⟩\n    intros\n    simp only [withZeroUnitsEquiv, MulEquiv.symm_mk, MulEquiv.withZero,\n      MulEquiv.toMonoidHom_eq_coe, MulEquiv.toEquiv_eq_coe, Equiv.toFun_as_coe, EquivLike.coe_coe,\n      MulEquiv.trans_apply, MulEquiv.coe_mk, Equiv.coe_fn_symm_mk, Equiv.coe_fn_mk]\n    split_ifs <;>\n    simp_all [← Units.val_le_val]\n\n"}
{"name":"LinearOrderedAddCommGroup.wellFoundedOn_setOf_le_lt_iff_nonempty_discrete","module":"Mathlib.GroupTheory.ArchimedeanDensely","initialProofState":"G : Type u_2\ninst✝¹ : LinearOrderedAddCommGroup G\ninst✝ : Nontrivial G\ng : G\n⊢ Iff ((setOf fun x => LE.le g x).WellFoundedOn fun x1 x2 => LT.lt x1 x2) (Nonempty (OrderAddMonoidIso G Int))","decl":"lemma LinearOrderedAddCommGroup.wellFoundedOn_setOf_le_lt_iff_nonempty_discrete\n    {G : Type*} [LinearOrderedAddCommGroup G] [Nontrivial G] {g : G} :\n    Set.WellFoundedOn {x : G | g ≤ x} (· < ·) ↔ Nonempty (G ≃+o ℤ) := by\n  suffices Set.WellFoundedOn {x : G | 0 ≤ x} (· < ·) ↔ Nonempty (G ≃+o ℤ) by\n    rw [← this]\n    refine ⟨fun h ↦ (h.mapsTo (· + g) ?_).mono' ?_, fun h ↦ (h.mapsTo (· - g) ?_).mono' ?_⟩ <;>\n    · try intro\n      simp [Function.onFun]\n  constructor\n  · intro h\n    replace h : WellFounded (α := {x : G | 0 ≤ x}) (· < ·) := h\n    rw [WellFounded.wellFounded_iff_has_min] at h\n    by_cases H : ∀ (x : G) {y}, 0 < y → ∃ n : ℕ, x ≤ n • y -- Archimedean\n    · replace H : Archimedean G := ⟨H⟩\n      rw [LinearOrderedAddCommGroup.discrete_iff_not_denselyOrdered]\n      intro hd\n      obtain ⟨y, hy⟩ := exists_ne (0 : G)\n      wlog hy' : 0 < y generalizing y\n      · refine this (-y) ?_ ?_\n        · simp [hy]\n        · simp only [not_lt] at hy'\n          simp [lt_of_le_of_ne hy' hy]\n      obtain ⟨⟨z, hz⟩, hz', hz''⟩ := h ({x | ⟨0, le_rfl⟩ < x}) ⟨⟨y, hy'.le⟩, hy'⟩\n      obtain ⟨w, hw, hw'⟩ := exists_between hz'\n      exact hz'' ⟨w, hw.le⟩ hw hw'\n    · push_neg at H\n      exfalso\n      obtain ⟨x, y, hy0, H⟩ := H\n      obtain ⟨_, ⟨n, rfl⟩, hz⟩ :=\n        h (Set.range (fun n : ℕ ↦ ⟨x - n • y, sub_nonneg.mpr (H _).le⟩)) (range_nonempty _)\n      refine hz ⟨x - (n + 1) • y, sub_nonneg.mpr (H _).le⟩ ⟨_, rfl⟩ ?_\n      simp [add_smul, hy0]\n  · rintro ⟨f⟩\n    have : LocallyFiniteOrder G := LocallyFiniteOrder.ofOrderIsoClass f\n    exact BddBelow.wellFoundedOn_lt ⟨0, by simp [mem_lowerBounds]⟩\n\n"}
{"name":"LinearOrderedAddCommGroup.wellFoundedOn_setOf_ge_gt_iff_nonempty_discrete","module":"Mathlib.GroupTheory.ArchimedeanDensely","initialProofState":"G : Type u_2\ninst✝¹ : LinearOrderedAddCommGroup G\ninst✝ : Nontrivial G\ng : G\n⊢ Iff ((setOf fun x => LE.le x g).WellFoundedOn fun x1 x2 => GT.gt x1 x2) (Nonempty (OrderAddMonoidIso G Int))","decl":"lemma LinearOrderedAddCommGroup.wellFoundedOn_setOf_ge_gt_iff_nonempty_discrete\n    {G : Type*} [LinearOrderedAddCommGroup G] [Nontrivial G] (g : G) :\n    Set.WellFoundedOn {x : G | x ≤ g} (· > ·) ↔ Nonempty (G ≃+o ℤ) := by\n  rw [← wellFoundedOn_setOf_le_lt_iff_nonempty_discrete (g := -g)]\n  refine ⟨fun h ↦ (h.mapsTo (- ·) ?_).mono' ?_, fun h ↦ (h.mapsTo (- ·) ?_).mono' ?_⟩ <;>\n  · intro\n    simp [Function.onFun, neg_le]\n\n"}
{"name":"LinearOrderedCommGroup.wellFoundedOn_setOf_le_lt_iff_nonempty_discrete","module":"Mathlib.GroupTheory.ArchimedeanDensely","initialProofState":"G : Type u_2\ninst✝¹ : LinearOrderedCommGroup G\ninst✝ : Nontrivial G\ng : G\n⊢ Iff ((setOf fun x => LE.le g x).WellFoundedOn fun x1 x2 => LT.lt x1 x2) (Nonempty (OrderMonoidIso G (Multiplicative Int)))","decl":"@[to_additive existing]\nlemma LinearOrderedCommGroup.wellFoundedOn_setOf_le_lt_iff_nonempty_discrete\n    {G : Type*} [LinearOrderedCommGroup G] [Nontrivial G] {g : G} :\n    Set.WellFoundedOn {x : G | g ≤ x} (· < ·) ↔ Nonempty (G ≃*o Multiplicative ℤ) := by\n  let e : G ≃o Additive G := OrderIso.refl G\n  suffices Set.WellFoundedOn {x : G | g ≤ x} (· < ·) ↔ Set.WellFoundedOn {x | e g ≤ x} (· < ·) by\n    rw [this, LinearOrderedAddCommGroup.wellFoundedOn_setOf_le_lt_iff_nonempty_discrete]\n    refine Nonempty.congr (fun f ↦ ?_) (fun f ↦ ?_)\n    · exact ⟨AddEquiv.toMultiplicative' f, by simp⟩\n    · exact ⟨MulEquiv.toAdditive' f, by simp⟩\n  refine ⟨fun h ↦ (h.mapsTo e.symm fun _ ↦ e.le_symm_apply.mpr).mono' ?_,\n    fun h ↦ (h.mapsTo e fun _ ↦ ?_).mono' ?_⟩ <;>\n  simp [Function.onFun]\n\n"}
{"name":"LinearOrderedCommGroup.wellFoundedOn_setOf_ge_gt_iff_nonempty_discrete","module":"Mathlib.GroupTheory.ArchimedeanDensely","initialProofState":"G : Type u_2\ninst✝¹ : LinearOrderedCommGroup G\ninst✝ : Nontrivial G\ng : G\n⊢ Iff ((setOf fun x => LE.le x g).WellFoundedOn fun x1 x2 => GT.gt x1 x2) (Nonempty (OrderMonoidIso G (Multiplicative Int)))","decl":"@[to_additive existing]\nlemma LinearOrderedCommGroup.wellFoundedOn_setOf_ge_gt_iff_nonempty_discrete\n    {G : Type*} [LinearOrderedCommGroup G] [Nontrivial G] (g : G) :\n    Set.WellFoundedOn {x : G | x ≤ g} (· > ·) ↔ Nonempty (G ≃*o Multiplicative ℤ) := by\n  rw [← wellFoundedOn_setOf_le_lt_iff_nonempty_discrete (g := g⁻¹)]\n  refine ⟨fun h ↦ (h.mapsTo (·⁻¹) ?_).mono' ?_, fun h ↦ (h.mapsTo (·⁻¹) ?_).mono' ?_⟩ <;>\n  · intro\n    simp [Function.onFun, inv_le']\n\n"}
{"name":"LinearOrderedCommGroupWithZero.wellFoundedOn_setOf_le_lt_iff_nonempty_discrete_of_ne_zero","module":"Mathlib.GroupTheory.ArchimedeanDensely","initialProofState":"G₀ : Type u_2\ninst✝¹ : LinearOrderedCommGroupWithZero G₀\ninst✝ : Nontrivial (Units G₀)\ng : G₀\nhg : Ne g 0\n⊢ Iff ((setOf fun x => LE.le g x).WellFoundedOn fun x1 x2 => LT.lt x1 x2) (Nonempty (OrderMonoidIso G₀ (WithZero (Multiplicative Int))))","decl":"lemma LinearOrderedCommGroupWithZero.wellFoundedOn_setOf_le_lt_iff_nonempty_discrete_of_ne_zero\n    {G₀ : Type*} [LinearOrderedCommGroupWithZero G₀] [Nontrivial G₀ˣ] {g : G₀} (hg : g ≠ 0) :\n    Set.WellFoundedOn {x : G₀ | g ≤ x} (· < ·) ↔ Nonempty (G₀ ≃*o ℤₘ₀) := by\n  suffices Set.WellFoundedOn {x : G₀ | g ≤ x} (· < ·) ↔\n    Set.WellFoundedOn {x : G₀ˣ | Units.mk0 g hg ≤ x} (· < ·) by\n    rw [this, LinearOrderedCommGroup.wellFoundedOn_setOf_le_lt_iff_nonempty_discrete]\n    refine Nonempty.congr (fun f ↦ ⟨?_, ?_⟩) (fun f ↦ ⟨?_, ?_⟩)\n    · exact WithZero.withZeroUnitsEquiv.symm.trans f.withZero\n    · intro a b\n      rcases eq_or_ne a 0 with rfl|ha\n      · simp [WithZero.withZeroUnitsEquiv, MulEquiv.withZero]\n      rcases eq_or_ne b 0 with rfl|hb\n      · simp [WithZero.withZeroUnitsEquiv, MulEquiv.withZero]\n      simp [WithZero.withZeroUnitsEquiv, MulEquiv.withZero, ha, hb, ← Units.val_le_val]\n    · exact MulEquiv.unzero (WithZero.withZeroUnitsEquiv.trans f)\n    · intros\n      rw [← WithZero.coe_le_coe]\n      simp [WithZero.withZeroUnitsEquiv, MulEquiv.unzero]\n  rw [← Set.wellFoundedOn_sdiff_singleton (a := 0)]\n  refine ⟨fun h ↦ (h.mapsTo Units.val ?_).mono' ?_,\n    fun h ↦ (h.mapsTo ?_ ?_).mono' ?_⟩\n  · intro\n    simp [← Units.val_le_val]\n  · simp [Function.onFun]\n  · exact fun x ↦ if h : x = 0 then 1 else Units.mk0 x h\n  · simp +contextual [← Units.val_le_val, MapsTo]\n  · simp only [mem_diff, mem_setOf_eq, mem_singleton_iff, Function.onFun, and_imp]\n    intro _ _ ha0 _ _ hb0 h\n    simp [ha0, hb0, ← Units.val_lt_val, h]\n\n"}
{"name":"LinearOrderedCommGroupWithZero.wellFoundedOn_setOf_ge_gt_iff_nonempty_discrete_of_ne_zero","module":"Mathlib.GroupTheory.ArchimedeanDensely","initialProofState":"G₀ : Type u_2\ninst✝¹ : LinearOrderedCommGroupWithZero G₀\ninst✝ : Nontrivial (Units G₀)\ng : G₀\nhg : Ne g 0\n⊢ Iff ((setOf fun x => LE.le x g).WellFoundedOn fun x1 x2 => GT.gt x1 x2) (Nonempty (OrderMonoidIso G₀ (WithZero (Multiplicative Int))))","decl":"lemma LinearOrderedCommGroupWithZero.wellFoundedOn_setOf_ge_gt_iff_nonempty_discrete_of_ne_zero\n    {G₀ : Type*} [LinearOrderedCommGroupWithZero G₀] [Nontrivial G₀ˣ] {g : G₀} (hg : g ≠ 0) :\n    Set.WellFoundedOn {x : G₀ | x ≤ g} (· > ·) ↔ Nonempty (G₀ ≃*o ℤₘ₀) := by\n  have hg' : g⁻¹ ≠ 0 := by simp [hg]\n  rw [← wellFoundedOn_setOf_le_lt_iff_nonempty_discrete_of_ne_zero hg',\n    ← Set.wellFoundedOn_sdiff_singleton (a := 0)]\n  refine ⟨fun h ↦ (h.mapsTo (·⁻¹) ?_).mono' ?_, fun h ↦ (h.mapsTo (·⁻¹) ?_).mono' ?_⟩\n  · intro x\n    rcases eq_or_ne x 0 with rfl|hx\n    · simp [hg]\n    simp only [mem_setOf_eq, mem_diff, mem_singleton_iff, inv_eq_zero, hx, not_false_eq_true,\n      and_true]\n    refine (inv_le_comm₀ ?_ ?_).mp <;>\n    simp [zero_lt_iff, hg, hx]\n  · simp only [mem_setOf_eq, Function.onFun, gt_iff_lt]\n    intro a ha b _\n    refine inv_strictAnti₀ ?_\n    contrapose! ha\n    simp only [le_zero_iff] at ha\n    simp [zero_lt_iff, ha, hg]\n  · intro x\n    simp only [mem_diff, mem_setOf_eq, mem_singleton_iff, and_imp]\n    intro hxg hx\n    refine inv_anti₀ ?_ hxg\n    simp [zero_lt_iff, hx]\n  · simp only [mem_diff, mem_setOf_eq, mem_singleton_iff, gt_iff_lt, Function.onFun, and_imp]\n    intro a _ _ b _ hb0\n    refine inv_strictAnti₀ ?_\n    simp [zero_lt_iff, hb0]\n\n"}
