{"name":"CategoryTheory.LiftRightAdjoint.instIsCoreflexivePairMapAppUnitOtherMap","module":"Mathlib.CategoryTheory.Adjunction.Lifting.Right","initialProofState":"A : Type u₁\nB : Type u₂\nC : Type u₃\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nU : CategoryTheory.Functor A B\nF : CategoryTheory.Functor B A\nL : CategoryTheory.Functor C B\nU' : CategoryTheory.Functor A C\nadj₁ : CategoryTheory.Adjunction F U\nadj₂ : CategoryTheory.Adjunction (L.comp F) U'\nX : B\n⊢ CategoryTheory.IsCoreflexivePair (U'.map (F.map (adj₁.unit.app X))) (CategoryTheory.LiftRightAdjoint.otherMap L U' adj₁ adj₂ X)","decl":"/-- `(U'Fη_X, otherMap X)` is a coreflexive pair: in particular if `C` has coreflexive equalizers\nthen this pair has an equalizer.\n-/\ninstance (X : B) :\n    IsCoreflexivePair (U'.map (F.map (adj₁.unit.app X))) (otherMap _ _ adj₁ adj₂ X) :=\n  IsCoreflexivePair.mk' (U'.map (adj₁.counit.app (F.obj X)))\n    (by simp [← Functor.map_comp])\n    (by simp only [otherMap, assoc, ← Functor.map_comp]; simp)\n\n"}
{"name":"CategoryTheory.LiftRightAdjoint.constructRightAdjointEquiv_symm_apply","module":"Mathlib.CategoryTheory.Adjunction.Lifting.Right","initialProofState":"A : Type u₁\nB : Type u₂\nC : Type u₃\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} A\ninst✝³ : CategoryTheory.Category.{v₂, u₂} B\ninst✝² : CategoryTheory.Category.{v₃, u₃} C\nU : CategoryTheory.Functor A B\nF : CategoryTheory.Functor B A\nL : CategoryTheory.Functor C B\nU' : CategoryTheory.Functor A C\nadj₁ : CategoryTheory.Adjunction F U\nadj₂ : CategoryTheory.Adjunction (L.comp F) U'\ninst✝¹ : CategoryTheory.Limits.HasCoreflexiveEqualizers C\ninst✝ : (X : B) → CategoryTheory.RegularMono (adj₁.unit.app X)\nY : C\nX : B\na✝ : Quiver.Hom (L.obj Y) X\n⊢ Eq ((CategoryTheory.LiftRightAdjoint.constructRightAdjointEquiv L U' adj₁ adj₂ Y X).symm a✝) ((CategoryTheory.Limits.Fork.IsLimit.homIso (CategoryTheory.Limits.limit.isLimit (CategoryTheory.Limits.parallelPair (U'.map (F.map (adj₁.unit.app X))) (CategoryTheory.LiftRightAdjoint.otherMap L U' adj₁ adj₂ X))) Y).symm ⟨(adj₂.homEquiv Y (F.obj X)) ((adj₁.homEquiv (L.obj Y) (F.obj X)).symm ↑((CategoryTheory.Limits.Fork.IsLimit.homIso (CategoryTheory.LiftRightAdjoint.unitEqualises adj₁ X) (L.obj Y)) a✝)), ⋯⟩)","decl":"/-- The homset equivalence which helps show that `L` is a left adjoint. -/\n@[simps!]\nnoncomputable def constructRightAdjointEquiv [∀ X : B, RegularMono (adj₁.unit.app X)] (Y : C)\n    (X : B) : (Y ⟶ constructRightAdjointObj _ _ adj₁ adj₂ X) ≃ (L.obj Y ⟶ X) :=\n  calc\n    (Y ⟶ constructRightAdjointObj _ _ adj₁ adj₂ X) ≃\n        { f : Y ⟶ U'.obj (F.obj X) //\n          f ≫ U'.map (F.map (adj₁.unit.app X)) = f ≫ (otherMap _ _ adj₁ adj₂ X) } :=\n      Fork.IsLimit.homIso (limit.isLimit _) _\n    _ ≃ { g : F.obj (L.obj Y) ⟶ F.obj X // F.map (adj₁.unit.app _≫ U.map g) =\n        g ≫ F.map (adj₁.unit.app _) } := by\n      apply (adj₂.homEquiv _ _).symm.subtypeEquiv _\n      intro f\n      rw [← (adj₂.homEquiv _ _).injective.eq_iff, eq_comm, otherMap,\n        ← adj₂.homEquiv_naturality_right_symm, adj₂.homEquiv_unit, ← adj₂.unit_naturality_assoc,\n        adj₂.homEquiv_counit]\n      simp\n    _ ≃ { z : L.obj Y ⟶ U.obj (F.obj X) //\n        z ≫ U.map (F.map (adj₁.unit.app X)) = z ≫ adj₁.unit.app (U.obj (F.obj X)) } := by\n      apply (adj₁.homEquiv _ _).subtypeEquiv\n      intro g\n      rw [← (adj₁.homEquiv _ _).injective.eq_iff, adj₁.homEquiv_unit,\n        adj₁.homEquiv_unit, adj₁.homEquiv_unit, eq_comm]\n      simp\n    _ ≃ (L.obj Y ⟶ X) := (Fork.IsLimit.homIso (unitEqualises adj₁ X) _).symm\n\n"}
{"name":"CategoryTheory.LiftRightAdjoint.constructRightAdjointEquiv_apply","module":"Mathlib.CategoryTheory.Adjunction.Lifting.Right","initialProofState":"A : Type u₁\nB : Type u₂\nC : Type u₃\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} A\ninst✝³ : CategoryTheory.Category.{v₂, u₂} B\ninst✝² : CategoryTheory.Category.{v₃, u₃} C\nU : CategoryTheory.Functor A B\nF : CategoryTheory.Functor B A\nL : CategoryTheory.Functor C B\nU' : CategoryTheory.Functor A C\nadj₁ : CategoryTheory.Adjunction F U\nadj₂ : CategoryTheory.Adjunction (L.comp F) U'\ninst✝¹ : CategoryTheory.Limits.HasCoreflexiveEqualizers C\ninst✝ : (X : B) → CategoryTheory.RegularMono (adj₁.unit.app X)\nY : C\nX : B\na✝ : Quiver.Hom Y (CategoryTheory.LiftRightAdjoint.constructRightAdjointObj L U' adj₁ adj₂ X)\n⊢ Eq ((CategoryTheory.LiftRightAdjoint.constructRightAdjointEquiv L U' adj₁ adj₂ Y X) a✝) ((CategoryTheory.Limits.Fork.IsLimit.homIso (CategoryTheory.LiftRightAdjoint.unitEqualises adj₁ X) (L.obj Y)).symm ⟨(adj₁.homEquiv (L.obj Y) (F.obj X)) ((adj₂.homEquiv Y (F.obj X)).symm ↑((CategoryTheory.Limits.Fork.IsLimit.homIso (CategoryTheory.Limits.limit.isLimit (CategoryTheory.Limits.parallelPair (U'.map (F.map (adj₁.unit.app X))) (CategoryTheory.LiftRightAdjoint.otherMap L U' adj₁ adj₂ X))) Y) a✝)), ⋯⟩)","decl":"/-- The homset equivalence which helps show that `L` is a left adjoint. -/\n@[simps!]\nnoncomputable def constructRightAdjointEquiv [∀ X : B, RegularMono (adj₁.unit.app X)] (Y : C)\n    (X : B) : (Y ⟶ constructRightAdjointObj _ _ adj₁ adj₂ X) ≃ (L.obj Y ⟶ X) :=\n  calc\n    (Y ⟶ constructRightAdjointObj _ _ adj₁ adj₂ X) ≃\n        { f : Y ⟶ U'.obj (F.obj X) //\n          f ≫ U'.map (F.map (adj₁.unit.app X)) = f ≫ (otherMap _ _ adj₁ adj₂ X) } :=\n      Fork.IsLimit.homIso (limit.isLimit _) _\n    _ ≃ { g : F.obj (L.obj Y) ⟶ F.obj X // F.map (adj₁.unit.app _≫ U.map g) =\n        g ≫ F.map (adj₁.unit.app _) } := by\n      apply (adj₂.homEquiv _ _).symm.subtypeEquiv _\n      intro f\n      rw [← (adj₂.homEquiv _ _).injective.eq_iff, eq_comm, otherMap,\n        ← adj₂.homEquiv_naturality_right_symm, adj₂.homEquiv_unit, ← adj₂.unit_naturality_assoc,\n        adj₂.homEquiv_counit]\n      simp\n    _ ≃ { z : L.obj Y ⟶ U.obj (F.obj X) //\n        z ≫ U.map (F.map (adj₁.unit.app X)) = z ≫ adj₁.unit.app (U.obj (F.obj X)) } := by\n      apply (adj₁.homEquiv _ _).subtypeEquiv\n      intro g\n      rw [← (adj₁.homEquiv _ _).injective.eq_iff, adj₁.homEquiv_unit,\n        adj₁.homEquiv_unit, adj₁.homEquiv_unit, eq_comm]\n      simp\n    _ ≃ (L.obj Y ⟶ X) := (Fork.IsLimit.homIso (unitEqualises adj₁ X) _).symm\n\n"}
{"name":"CategoryTheory.isLeftAdjoint_triangle_lift","module":"Mathlib.CategoryTheory.Adjunction.Lifting.Right","initialProofState":"A : Type u₁\nB : Type u₂\nC : Type u₃\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} A\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} B\ninst✝³ : CategoryTheory.Category.{v₃, u₃} C\nU : CategoryTheory.Functor A B\nF : CategoryTheory.Functor B A\nL : CategoryTheory.Functor C B\nadj₁ : CategoryTheory.Adjunction F U\ninst✝² : (X : B) → CategoryTheory.RegularMono (adj₁.unit.app X)\ninst✝¹ : CategoryTheory.Limits.HasCoreflexiveEqualizers C\ninst✝ : (L.comp F).IsLeftAdjoint\n⊢ L.IsLeftAdjoint","decl":"/-- The adjoint triangle theorem: Suppose `U : A ⥤ B` has a left adjoint `F` such that each unit\n`η_X : X ⟶ UFX` is a regular monomorphism. Then if a category `C` has equalizers of coreflexive\npairs, then a functor `L : C ⥤ B` has a right adjoint if the composite `L ⋙ F` does.\n\nNote the converse is true (with weaker assumptions), by `Adjunction.comp`.\nSee https://ncatlab.org/nlab/show/adjoint+triangle+theorem\n-/\nlemma isLeftAdjoint_triangle_lift {U : A ⥤ B} {F : B ⥤ A} (L : C ⥤ B) (adj₁ : F ⊣ U)\n    [∀ X, RegularMono (adj₁.unit.app X)] [HasCoreflexiveEqualizers C]\n    [(L ⋙ F).IsLeftAdjoint ] : L.IsLeftAdjoint where\n  exists_rightAdjoint :=\n    ⟨LiftRightAdjoint.constructRightAdjoint L _ adj₁ (Adjunction.ofIsLeftAdjoint _),\n      ⟨Adjunction.adjunctionOfEquivRight _ _⟩⟩\n\n"}
{"name":"CategoryTheory.isLeftAdjoint_triangle_lift_comonadic","module":"Mathlib.CategoryTheory.Adjunction.Lifting.Right","initialProofState":"A : Type u₁\nB : Type u₂\nC : Type u₃\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} A\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} B\ninst✝³ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor B A\ninst✝² : CategoryTheory.ComonadicLeftAdjoint F\nL : CategoryTheory.Functor C B\ninst✝¹ : CategoryTheory.Limits.HasCoreflexiveEqualizers C\ninst✝ : (L.comp F).IsLeftAdjoint\n⊢ L.IsLeftAdjoint","decl":"/-- If `L ⋙ F` has a right adjoint, the domain of `L` has coreflexive equalizers and `F` is a\ncomonadic functor, then `L` has a right adjoint.\nThis is a special case of `isLeftAdjoint_triangle_lift` which is often more useful in practice.\n-/\nlemma isLeftAdjoint_triangle_lift_comonadic (F : B ⥤ A) [ComonadicLeftAdjoint F] {L : C ⥤ B}\n    [HasCoreflexiveEqualizers C] [(L ⋙ F).IsLeftAdjoint] : L.IsLeftAdjoint := by\n  let L' : _ ⥤ _ := L ⋙ Comonad.comparison (comonadicAdjunction F)\n  rsuffices : L'.IsLeftAdjoint\n  · let this : (L' ⋙ (Comonad.comparison (comonadicAdjunction F)).inv).IsLeftAdjoint := by\n      infer_instance\n    refine ((Adjunction.ofIsLeftAdjoint\n      (L' ⋙ (Comonad.comparison (comonadicAdjunction F)).inv)).ofNatIsoLeft ?_).isLeftAdjoint\n    exact isoWhiskerLeft L (Comonad.comparison _).asEquivalence.unitIso.symm ≪≫ L.leftUnitor\n  let this : (L' ⋙ Comonad.forget (comonadicAdjunction F).toComonad).IsLeftAdjoint := by\n    refine ((Adjunction.ofIsLeftAdjoint (L ⋙ F)).ofNatIsoLeft ?_).isLeftAdjoint\n    exact isoWhiskerLeft L (Comonad.comparisonForget (comonadicAdjunction F)).symm\n  let this : ∀ X, RegularMono ((Comonad.adj (comonadicAdjunction F).toComonad).unit.app X) := by\n    intro X\n    simp only [Comonad.adj_unit]\n    exact ⟨_, _, _, _, Comonad.beckCoalgebraEqualizer X⟩\n  exact isLeftAdjoint_triangle_lift L' (Comonad.adj _)\n\n"}
{"name":"CategoryTheory.isLeftAdjoint_square_lift","module":"Mathlib.CategoryTheory.Adjunction.Lifting.Right","initialProofState":"A : Type u₁\nB : Type u₂\nC : Type u₃\ninst✝⁸ : CategoryTheory.Category.{v₁, u₁} A\ninst✝⁷ : CategoryTheory.Category.{v₂, u₂} B\ninst✝⁶ : CategoryTheory.Category.{v₃, u₃} C\nD : Type u₄\ninst✝⁵ : CategoryTheory.Category.{v₄, u₄} D\nQ : CategoryTheory.Functor A B\nV : CategoryTheory.Functor B D\nU : CategoryTheory.Functor A C\nL : CategoryTheory.Functor C D\ncomm : CategoryTheory.Iso (U.comp L) (Q.comp V)\ninst✝⁴ : U.IsLeftAdjoint\ninst✝³ : V.IsLeftAdjoint\ninst✝² : L.IsLeftAdjoint\ninst✝¹ : (X : B) → CategoryTheory.RegularMono ((CategoryTheory.Adjunction.ofIsLeftAdjoint V).unit.app X)\ninst✝ : CategoryTheory.Limits.HasCoreflexiveEqualizers A\n⊢ Q.IsLeftAdjoint","decl":"/-- Suppose we have a commutative square of functors\n\n```\n      Q\n    A → B\n  U ↓   ↓ V\n    C → D\n      R\n```\n\nwhere `U` has a right adjoint, `A` has coreflexive equalizers and `V` has a right adjoint such that\neach component of the counit is a regular mono.\nThen `Q` has a right adjoint if `L` has a right adjoint.\n\nSee https://ncatlab.org/nlab/show/adjoint+lifting+theorem\n-/\nlemma isLeftAdjoint_square_lift (Q : A ⥤ B) (V : B ⥤ D) (U : A ⥤ C) (L : C ⥤ D)\n    (comm : U ⋙ L ≅ Q ⋙ V) [U.IsLeftAdjoint] [V.IsLeftAdjoint] [L.IsLeftAdjoint]\n    [∀ X, RegularMono ((Adjunction.ofIsLeftAdjoint V).unit.app X)] [HasCoreflexiveEqualizers A] :\n    Q.IsLeftAdjoint :=\n  have := ((Adjunction.ofIsLeftAdjoint (U ⋙ L)).ofNatIsoLeft comm).isLeftAdjoint\n  isLeftAdjoint_triangle_lift Q (Adjunction.ofIsLeftAdjoint V)\n\n"}
{"name":"CategoryTheory.isLeftAdjoint_square_lift_comonadic","module":"Mathlib.CategoryTheory.Adjunction.Lifting.Right","initialProofState":"A : Type u₁\nB : Type u₂\nC : Type u₃\ninst✝⁷ : CategoryTheory.Category.{v₁, u₁} A\ninst✝⁶ : CategoryTheory.Category.{v₂, u₂} B\ninst✝⁵ : CategoryTheory.Category.{v₃, u₃} C\nD : Type u₄\ninst✝⁴ : CategoryTheory.Category.{v₄, u₄} D\nQ : CategoryTheory.Functor A B\nV : CategoryTheory.Functor B D\nU : CategoryTheory.Functor A C\nL : CategoryTheory.Functor C D\ncomm : CategoryTheory.Iso (U.comp L) (Q.comp V)\ninst✝³ : U.IsLeftAdjoint\ninst✝² : CategoryTheory.ComonadicLeftAdjoint V\ninst✝¹ : L.IsLeftAdjoint\ninst✝ : CategoryTheory.Limits.HasCoreflexiveEqualizers A\n⊢ Q.IsLeftAdjoint","decl":"/-- Suppose we have a commutative square of functors\n\n```\n      Q\n    A → B\n  U ↓   ↓ V\n    C → D\n      R\n```\n\nwhere `U` has a right adjoint, `A` has reflexive equalizers and `V` is comonadic.\nThen `Q` has a right adjoint if `L` has a right adjoint.\n\nSee https://ncatlab.org/nlab/show/adjoint+lifting+theorem\n-/\nlemma isLeftAdjoint_square_lift_comonadic (Q : A ⥤ B) (V : B ⥤ D) (U : A ⥤ C) (L : C ⥤ D)\n    (comm : U ⋙ L ≅ Q ⋙ V) [U.IsLeftAdjoint] [ComonadicLeftAdjoint V] [L.IsLeftAdjoint]\n    [HasCoreflexiveEqualizers A] : Q.IsLeftAdjoint :=\n  have := ((Adjunction.ofIsLeftAdjoint (U ⋙ L)).ofNatIsoLeft comm).isLeftAdjoint\n  isLeftAdjoint_triangle_lift_comonadic V\n\n"}
