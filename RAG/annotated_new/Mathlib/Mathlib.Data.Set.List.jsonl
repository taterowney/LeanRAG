{"name":"Set.range_list_map","module":"Mathlib.Data.Set.List","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\n⊢ Eq (Set.range (List.map f)) (setOf fun l => ∀ (x : β), Membership.mem l x → Membership.mem (Set.range f) x)","decl":"theorem range_list_map (f : α → β) : range (map f) = { l | ∀ x ∈ l, x ∈ range f } := by\n  refine antisymm (range_subset_iff.2 fun l => forall_mem_map.2 fun y _ => mem_range_self _)\n      fun l hl => ?_\n  induction l with\n  | nil => exact ⟨[], rfl⟩\n  | cons a l ihl =>\n    rcases ihl fun x hx => hl x <| subset_cons_self _ _ hx with ⟨l, rfl⟩\n    rcases hl a (mem_cons_self _ _) with ⟨a, rfl⟩\n    exact ⟨a :: l, map_cons _ _ _⟩\n\n"}
{"name":"Set.range_list_map_coe","module":"Mathlib.Data.Set.List","initialProofState":"α : Type u_1\ns : Set α\n⊢ Eq (Set.range (List.map Subtype.val)) (setOf fun l => ∀ (x : α), Membership.mem l x → Membership.mem s x)","decl":"theorem range_list_map_coe (s : Set α) : range (map ((↑) : s → α)) = { l | ∀ x ∈ l, x ∈ s } := by\n  rw [range_list_map, Subtype.range_coe]\n\n"}
{"name":"Set.range_list_get","module":"Mathlib.Data.Set.List","initialProofState":"α : Type u_1\nl : List α\n⊢ Eq (Set.range l.get) (setOf fun x => Membership.mem l x)","decl":"@[simp]\ntheorem range_list_get : range l.get = { x | x ∈ l } := by\n  ext x\n  rw [mem_setOf_eq, mem_iff_get, mem_range]\n\n"}
{"name":"Set.range_list_get?","module":"Mathlib.Data.Set.List","initialProofState":"α : Type u_1\nl : List α\n⊢ Eq (Set.range l.get?) (Insert.insert Option.none (Set.image Option.some (setOf fun x => Membership.mem l x)))","decl":"theorem range_list_get? : range l.get? = insert none (some '' { x | x ∈ l }) := by\n  rw [← range_list_get, ← range_comp]\n  refine (range_subset_iff.2 fun n => ?_).antisymm (insert_subset_iff.2 ⟨?_, ?_⟩)\n  · exact (le_or_lt l.length n).imp get?_eq_none_iff.mpr\n      (fun hlt => ⟨⟨_, hlt⟩, (get?_eq_get hlt).symm⟩)\n  · exact ⟨_, get?_eq_none_iff.mpr le_rfl⟩\n  · exact range_subset_iff.2 fun k => ⟨_, get?_eq_get _⟩\n\n"}
{"name":"Set.range_list_getD","module":"Mathlib.Data.Set.List","initialProofState":"α : Type u_1\nl : List α\nd : α\n⊢ Eq (Set.range fun n => (GetElem?.getElem? l n).getD d) (Insert.insert d (setOf fun x => Membership.mem l x))","decl":"@[simp]\ntheorem range_list_getD (d : α) : (range fun n : Nat => l[n]?.getD d) = insert d { x | x ∈ l } :=\n  calc\n    (range fun n => l[n]?.getD d) = (fun o : Option α => o.getD d) '' range l.get? := by\n      simp [← range_comp, Function.comp_def]\n    _ = insert d { x | x ∈ l } := by\n      simp only [range_list_get?, image_insert_eq, Option.getD, image_image, image_id']\n\n"}
{"name":"Set.range_list_getI","module":"Mathlib.Data.Set.List","initialProofState":"α : Type u_1\ninst✝ : Inhabited α\nl : List α\n⊢ Eq (Set.range l.getI) (Insert.insert Inhabited.default (setOf fun x => Membership.mem l x))","decl":"@[simp]\ntheorem range_list_getI [Inhabited α] (l : List α) :\n    range l.getI = insert default { x | x ∈ l } := by\n  unfold List.getI\n  simp\n\n"}
{"name":"List.canLift","module":"Mathlib.Data.Set.List","initialProofState":"α : Type u_1\nβ : Type u_2\nc : β → α\np : α → Prop\ninst✝ : CanLift α β c p\n⊢ CanLift (List α) (List β) (List.map c) fun l => ∀ (x : α), Membership.mem l x → p x","decl":"/-- If each element of a list can be lifted to some type, then the whole list can be\nlifted to this type. -/\ninstance List.canLift (c) (p) [CanLift α β c p] :\n    CanLift (List α) (List β) (List.map c) fun l => ∀ x ∈ l, p x where\n  prf l H := by\n    rw [← Set.mem_range, Set.range_list_map]\n    exact fun a ha => CanLift.prf a (H a ha)\n"}
