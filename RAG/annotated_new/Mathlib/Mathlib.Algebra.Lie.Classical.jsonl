{"name":"LieAlgebra.matrix_trace_commutator_zero","module":"Mathlib.Algebra.Lie.Classical","initialProofState":"n : Type u_1\nR : Type u₂\ninst✝² : DecidableEq n\ninst✝¹ : CommRing R\ninst✝ : Fintype n\nX Y : Matrix n n R\n⊢ Eq (Bracket.bracket X Y).trace 0","decl":"@[simp]\ntheorem matrix_trace_commutator_zero [Fintype n] (X Y : Matrix n n R) : Matrix.trace ⁅X, Y⁆ = 0 :=\n  calc\n    _ = Matrix.trace (X * Y) - Matrix.trace (Y * X) := trace_sub _ _\n    _ = Matrix.trace (X * Y) - Matrix.trace (X * Y) :=\n      (congr_arg (fun x => _ - x) (Matrix.trace_mul_comm Y X))\n    _ = 0 := sub_self _\n\n"}
{"name":"LieAlgebra.SpecialLinear.sl_bracket","module":"Mathlib.Algebra.Lie.Classical","initialProofState":"n : Type u_1\nR : Type u₂\ninst✝² : DecidableEq n\ninst✝¹ : CommRing R\ninst✝ : Fintype n\nA B : Subtype fun x => Membership.mem (LieAlgebra.SpecialLinear.sl n R) x\n⊢ Eq (↑(Bracket.bracket A B)) (HSub.hSub (HMul.hMul ↑A ↑B) (HMul.hMul ↑B ↑A))","decl":"theorem sl_bracket [Fintype n] (A B : sl n R) : ⁅A, B⁆.val = A.val * B.val - B.val * A.val :=\n  rfl\n\n"}
{"name":"LieAlgebra.SpecialLinear.eb_val","module":"Mathlib.Algebra.Lie.Classical","initialProofState":"n : Type u_1\nR : Type u₂\ninst✝² : DecidableEq n\ninst✝¹ : CommRing R\ninst✝ : Fintype n\ni j : n\nh : Ne j i\n⊢ Eq (↑(LieAlgebra.SpecialLinear.Eb R i j h)) (Matrix.stdBasisMatrix i j 1)","decl":"@[simp]\ntheorem eb_val (h : j ≠ i) : (Eb R i j h).val = Matrix.stdBasisMatrix i j 1 :=\n  rfl\n\n"}
{"name":"LieAlgebra.SpecialLinear.sl_non_abelian","module":"Mathlib.Algebra.Lie.Classical","initialProofState":"n : Type u_1\nR : Type u₂\ninst✝³ : DecidableEq n\ninst✝² : CommRing R\ninst✝¹ : Fintype n\ninst✝ : Nontrivial R\nh : LT.lt 1 (Fintype.card n)\n⊢ Not (IsLieAbelian (Subtype fun x => Membership.mem (LieAlgebra.SpecialLinear.sl n R) x))","decl":"theorem sl_non_abelian [Fintype n] [Nontrivial R] (h : 1 < Fintype.card n) :\n    ¬IsLieAbelian (sl n R) := by\n  rcases Fintype.exists_pair_of_one_lt_card h with ⟨j, i, hij⟩\n  let A := Eb R i j hij\n  let B := Eb R j i hij.symm\n  intro c\n  have c' : A.val * B.val = B.val * A.val := by\n    rw [← sub_eq_zero, ← sl_bracket, c.trivial, ZeroMemClass.coe_zero]\n  simpa [A, B, stdBasisMatrix, Matrix.mul_apply, hij] using congr_fun (congr_fun c' i) i\n\n"}
{"name":"LieAlgebra.Orthogonal.mem_so","module":"Mathlib.Algebra.Lie.Classical","initialProofState":"n : Type u_1\nR : Type u₂\ninst✝² : DecidableEq n\ninst✝¹ : CommRing R\ninst✝ : Fintype n\nA : Matrix n n R\n⊢ Iff (Membership.mem (LieAlgebra.Orthogonal.so n R) A) (Eq A.transpose (Neg.neg A))","decl":"@[simp]\ntheorem mem_so [Fintype n] (A : Matrix n n R) : A ∈ so n R ↔ Aᵀ = -A := by\n  rw [so, mem_skewAdjointMatricesLieSubalgebra, mem_skewAdjointMatricesSubmodule]\n  simp only [Matrix.IsSkewAdjoint, Matrix.IsAdjointPair, Matrix.mul_one, Matrix.one_mul]\n\n"}
{"name":"LieAlgebra.Orthogonal.pso_inv","module":"Mathlib.Algebra.Lie.Classical","initialProofState":"p : Type u_2\nq : Type u_3\nR : Type u₂\ninst✝⁴ : DecidableEq p\ninst✝³ : DecidableEq q\ninst✝² : CommRing R\ninst✝¹ : Fintype p\ninst✝ : Fintype q\ni : R\nhi : Eq (HMul.hMul i i) (-1)\n⊢ Eq (HMul.hMul (LieAlgebra.Orthogonal.Pso p q R i) (LieAlgebra.Orthogonal.Pso p q R (Neg.neg i))) 1","decl":"theorem pso_inv {i : R} (hi : i * i = -1) : Pso p q R i * Pso p q R (-i) = 1 := by\n  ext (x y); rcases x with ⟨x⟩|⟨x⟩ <;> rcases y with ⟨y⟩|⟨y⟩\n  · -- x y : p\n    by_cases h : x = y <;>\n    simp [Pso, indefiniteDiagonal, h, one_apply]\n  · -- x : p, y : q\n    simp [Pso, indefiniteDiagonal]\n  · -- x : q, y : p\n    simp [Pso, indefiniteDiagonal]\n  · -- x y : q\n    by_cases h : x = y <;>\n    simp [Pso, indefiniteDiagonal, h, hi, one_apply]\n\n"}
{"name":"LieAlgebra.Orthogonal.indefiniteDiagonal_transform","module":"Mathlib.Algebra.Lie.Classical","initialProofState":"p : Type u_2\nq : Type u_3\nR : Type u₂\ninst✝⁴ : DecidableEq p\ninst✝³ : DecidableEq q\ninst✝² : CommRing R\ninst✝¹ : Fintype p\ninst✝ : Fintype q\ni : R\nhi : Eq (HMul.hMul i i) (-1)\n⊢ Eq (HMul.hMul (HMul.hMul (LieAlgebra.Orthogonal.Pso p q R i).transpose (LieAlgebra.Orthogonal.indefiniteDiagonal p q R)) (LieAlgebra.Orthogonal.Pso p q R i)) 1","decl":"theorem indefiniteDiagonal_transform {i : R} (hi : i * i = -1) :\n    (Pso p q R i)ᵀ * indefiniteDiagonal p q R * Pso p q R i = 1 := by\n  ext (x y); rcases x with ⟨x⟩|⟨x⟩ <;> rcases y with ⟨y⟩|⟨y⟩\n  · -- x y : p\n    by_cases h : x = y <;>\n    simp [Pso, indefiniteDiagonal, h, one_apply]\n  · -- x : p, y : q\n    simp [Pso, indefiniteDiagonal]\n  · -- x : q, y : p\n    simp [Pso, indefiniteDiagonal]\n  · -- x y : q\n    by_cases h : x = y <;>\n    simp [Pso, indefiniteDiagonal, h, hi, one_apply]\n\n"}
{"name":"LieAlgebra.Orthogonal.soIndefiniteEquiv_apply","module":"Mathlib.Algebra.Lie.Classical","initialProofState":"p : Type u_2\nq : Type u_3\nR : Type u₂\ninst✝⁴ : DecidableEq p\ninst✝³ : DecidableEq q\ninst✝² : CommRing R\ninst✝¹ : Fintype p\ninst✝ : Fintype q\ni : R\nhi : Eq (HMul.hMul i i) (-1)\nA : Subtype fun x => Membership.mem (LieAlgebra.Orthogonal.so' p q R) x\n⊢ Eq (↑((LieAlgebra.Orthogonal.soIndefiniteEquiv p q R hi) A)) (HMul.hMul (HMul.hMul (Inv.inv (LieAlgebra.Orthogonal.Pso p q R i)) ↑A) (LieAlgebra.Orthogonal.Pso p q R i))","decl":"theorem soIndefiniteEquiv_apply {i : R} (hi : i * i = -1) (A : so' p q R) :\n    (soIndefiniteEquiv p q R hi A : Matrix (p ⊕ q) (p ⊕ q) R) =\n      (Pso p q R i)⁻¹ * (A : Matrix (p ⊕ q) (p ⊕ q) R) * Pso p q R i := by\n  rw [soIndefiniteEquiv, LieEquiv.trans_apply, LieEquiv.ofEq_apply]\n  -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n  erw [skewAdjointMatricesLieSubalgebraEquiv_apply]\n\n"}
{"name":"LieAlgebra.Orthogonal.s_as_blocks","module":"Mathlib.Algebra.Lie.Classical","initialProofState":"l : Type u_4\nR : Type u₂\ninst✝¹ : DecidableEq l\ninst✝ : CommRing R\n⊢ Eq (LieAlgebra.Orthogonal.S l R) (Matrix.fromBlocks 1 0 0 (-1))","decl":"theorem s_as_blocks : S l R = Matrix.fromBlocks 1 0 0 (-1) := by\n  rw [← Matrix.diagonal_one, Matrix.diagonal_neg, Matrix.fromBlocks_diagonal]\n  rfl\n\n"}
{"name":"LieAlgebra.Orthogonal.jd_transform","module":"Mathlib.Algebra.Lie.Classical","initialProofState":"l : Type u_4\nR : Type u₂\ninst✝² : DecidableEq l\ninst✝¹ : CommRing R\ninst✝ : Fintype l\n⊢ Eq (HMul.hMul (HMul.hMul (LieAlgebra.Orthogonal.PD l R).transpose (LieAlgebra.Orthogonal.JD l R)) (LieAlgebra.Orthogonal.PD l R)) (HSMul.hSMul 2 (LieAlgebra.Orthogonal.S l R))","decl":"theorem jd_transform [Fintype l] : (PD l R)ᵀ * JD l R * PD l R = (2 : R) • S l R := by\n  have h : (PD l R)ᵀ * JD l R = Matrix.fromBlocks 1 1 1 (-1) := by\n    simp [PD, JD, Matrix.fromBlocks_transpose, Matrix.fromBlocks_multiply]\n  rw [h, PD, s_as_blocks, Matrix.fromBlocks_multiply, Matrix.fromBlocks_smul]\n  simp [two_smul]\n\n"}
{"name":"LieAlgebra.Orthogonal.pd_inv","module":"Mathlib.Algebra.Lie.Classical","initialProofState":"l : Type u_4\nR : Type u₂\ninst✝³ : DecidableEq l\ninst✝² : CommRing R\ninst✝¹ : Fintype l\ninst✝ : Invertible 2\n⊢ Eq (HMul.hMul (LieAlgebra.Orthogonal.PD l R) (HSMul.hSMul (Invertible.invOf 2) (LieAlgebra.Orthogonal.PD l R).transpose)) 1","decl":"theorem pd_inv [Fintype l] [Invertible (2 : R)] : PD l R * ⅟ (2 : R) • (PD l R)ᵀ = 1 := by\n  rw [PD, Matrix.fromBlocks_transpose, Matrix.fromBlocks_smul,\n    Matrix.fromBlocks_multiply]\n  simp\n\n"}
{"name":"LieAlgebra.Orthogonal.pb_inv","module":"Mathlib.Algebra.Lie.Classical","initialProofState":"l : Type u_4\nR : Type u₂\ninst✝³ : DecidableEq l\ninst✝² : CommRing R\ninst✝¹ : Fintype l\ninst✝ : Invertible 2\n⊢ Eq (HMul.hMul (LieAlgebra.Orthogonal.PB l R) (Matrix.fromBlocks 1 0 0 (Invertible.invOf (LieAlgebra.Orthogonal.PD l R)))) 1","decl":"theorem pb_inv [Invertible (2 : R)] : PB l R * Matrix.fromBlocks 1 0 0 (⅟ (PD l R)) = 1 := by\n  rw [PB, Matrix.fromBlocks_multiply, mul_invOf_self]\n  simp only [Matrix.mul_zero, Matrix.mul_one, Matrix.zero_mul, zero_add, add_zero,\n    Matrix.fromBlocks_one]\n\n"}
{"name":"LieAlgebra.Orthogonal.jb_transform","module":"Mathlib.Algebra.Lie.Classical","initialProofState":"l : Type u_4\nR : Type u₂\ninst✝² : DecidableEq l\ninst✝¹ : CommRing R\ninst✝ : Fintype l\n⊢ Eq (HMul.hMul (HMul.hMul (LieAlgebra.Orthogonal.PB l R).transpose (LieAlgebra.Orthogonal.JB l R)) (LieAlgebra.Orthogonal.PB l R)) (HSMul.hSMul 2 (Matrix.fromBlocks 1 0 0 (LieAlgebra.Orthogonal.S l R)))","decl":"theorem jb_transform : (PB l R)ᵀ * JB l R * PB l R = (2 : R) • Matrix.fromBlocks 1 0 0 (S l R) := by\n  simp [PB, JB, jd_transform, Matrix.fromBlocks_transpose, Matrix.fromBlocks_multiply,\n    Matrix.fromBlocks_smul]\n\n"}
{"name":"LieAlgebra.Orthogonal.indefiniteDiagonal_assoc","module":"Mathlib.Algebra.Lie.Classical","initialProofState":"l : Type u_4\nR : Type u₂\ninst✝² : DecidableEq l\ninst✝¹ : CommRing R\ninst✝ : Fintype l\n⊢ Eq (LieAlgebra.Orthogonal.indefiniteDiagonal (Sum Unit l) l R) ((Matrix.reindexLieEquiv (Equiv.sumAssoc Unit l l).symm) (Matrix.fromBlocks 1 0 0 (LieAlgebra.Orthogonal.indefiniteDiagonal l l R)))","decl":"theorem indefiniteDiagonal_assoc :\n    indefiniteDiagonal (Unit ⊕ l) l R =\n      Matrix.reindexLieEquiv (Equiv.sumAssoc Unit l l).symm\n        (Matrix.fromBlocks 1 0 0 (indefiniteDiagonal l l R)) := by\n  ext ⟨⟨i₁ | i₂⟩ | i₃⟩ ⟨⟨j₁ | j₂⟩ | j₃⟩ <;>\n  -- Porting note: added `Sum.inl_injective.eq_iff`, `Sum.inr_injective.eq_iff`\n    simp only [indefiniteDiagonal, Matrix.diagonal_apply, Equiv.sumAssoc_apply_inl_inl,\n      Matrix.reindexLieEquiv_apply, Matrix.submatrix_apply, Equiv.symm_symm, Matrix.reindex_apply,\n      Sum.elim_inl, if_true, eq_self_iff_true, Matrix.one_apply_eq, Matrix.fromBlocks_apply₁₁,\n      DMatrix.zero_apply, Equiv.sumAssoc_apply_inl_inr, if_false, Matrix.fromBlocks_apply₁₂,\n      Matrix.fromBlocks_apply₂₁, Matrix.fromBlocks_apply₂₂, Equiv.sumAssoc_apply_inr,\n      Sum.elim_inr, Sum.inl_injective.eq_iff, Sum.inr_injective.eq_iff, reduceCtorEq] <;>\n    congr 1\n\n"}
