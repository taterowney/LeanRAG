{"name":"MeasureTheory.lpMeas.ae_eq_zero_of_forall_setIntegral_eq_zero","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Unique","initialProofState":"Î± : Type u_1\nE' : Type u_2\nğ•œ : Type u_4\np : ENNReal\nm m0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœâ´ : RCLike ğ•œ\ninstâœÂ³ : NormedAddCommGroup E'\ninstâœÂ² : InnerProductSpace ğ•œ E'\ninstâœÂ¹ : CompleteSpace E'\ninstâœ : NormedSpace Real E'\nhm : LE.le m m0\nf : Subtype fun x => Membership.mem (MeasureTheory.lpMeas E' ğ•œ m p Î¼) x\nhp_ne_zero : Ne p 0\nhp_ne_top : Ne p Top.top\nhf_int_finite : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ MeasureTheory.IntegrableOn (â†‘â†‘â†‘f) s Î¼\nhf_zero : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ Eq (MeasureTheory.integral (Î¼.restrict s) fun x => â†‘â†‘â†‘f x) 0\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq (â†‘â†‘â†‘f) 0","decl":"theorem lpMeas.ae_eq_zero_of_forall_setIntegral_eq_zero (hm : m â‰¤ m0) (f : lpMeas E' ğ•œ m p Î¼)\n    (hp_ne_zero : p â‰  0) (hp_ne_top : p â‰  âˆ)\n    -- Porting note: needed to add explicit casts in the next two hypotheses\n    (hf_int_finite : âˆ€ s, MeasurableSet[m] s â†’ Î¼ s < âˆ â†’ IntegrableOn (f : Lp E' p Î¼) s Î¼)\n    (hf_zero : âˆ€ s : Set Î±, MeasurableSet[m] s â†’ Î¼ s < âˆ â†’ âˆ« x in s, (f : Lp E' p Î¼) x âˆ‚Î¼ = 0) :\n    f =áµ[Î¼] (0 : Î± â†’ E') := by\n  obtain âŸ¨g, hg_sm, hfgâŸ© := lpMeas.ae_fin_strongly_measurable' hm f hp_ne_zero hp_ne_top\n  refine hfg.trans ?_\n  -- Porting note: added\n  unfold Filter.EventuallyEq at hfg\n  refine ae_eq_zero_of_forall_setIntegral_eq_of_finStronglyMeasurable_trim hm ?_ ?_ hg_sm\n  Â· intro s hs hÎ¼s\n    have hfg_restrict : f =áµ[Î¼.restrict s] g := ae_restrict_of_ae hfg\n    rw [IntegrableOn, integrable_congr hfg_restrict.symm]\n    exact hf_int_finite s hs hÎ¼s\n  Â· intro s hs hÎ¼s\n    have hfg_restrict : f =áµ[Î¼.restrict s] g := ae_restrict_of_ae hfg\n    rw [integral_congr_ae hfg_restrict.symm]\n    exact hf_zero s hs hÎ¼s\n\n"}
{"name":"MeasureTheory.Lp.ae_eq_zero_of_forall_setIntegral_eq_zero'","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Unique","initialProofState":"Î± : Type u_1\nE' : Type u_2\nğ•œ : Type u_4\np : ENNReal\nm m0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœâ´ : RCLike ğ•œ\ninstâœÂ³ : NormedAddCommGroup E'\ninstâœÂ² : InnerProductSpace ğ•œ E'\ninstâœÂ¹ : CompleteSpace E'\ninstâœ : NormedSpace Real E'\nhm : LE.le m m0\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E' p Î¼) x\nhp_ne_zero : Ne p 0\nhp_ne_top : Ne p Top.top\nhf_int_finite : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ MeasureTheory.IntegrableOn (â†‘â†‘f) s Î¼\nhf_zero : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ Eq (MeasureTheory.integral (Î¼.restrict s) fun x => â†‘â†‘f x) 0\nhf_meas : MeasureTheory.AEStronglyMeasurable (â†‘â†‘f) Î¼\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq (â†‘â†‘f) 0","decl":"include ğ•œ in\ntheorem Lp.ae_eq_zero_of_forall_setIntegral_eq_zero' (hm : m â‰¤ m0) (f : Lp E' p Î¼)\n    (hp_ne_zero : p â‰  0) (hp_ne_top : p â‰  âˆ)\n    (hf_int_finite : âˆ€ s, MeasurableSet[m] s â†’ Î¼ s < âˆ â†’ IntegrableOn f s Î¼)\n    (hf_zero : âˆ€ s : Set Î±, MeasurableSet[m] s â†’ Î¼ s < âˆ â†’ âˆ« x in s, f x âˆ‚Î¼ = 0)\n    (hf_meas : AEStronglyMeasurable[m] f Î¼) : f =áµ[Î¼] 0 := by\n  let f_meas : lpMeas E' ğ•œ m p Î¼ := âŸ¨f, hf_measâŸ©\n  -- Porting note: `simp only` does not call `rfl` to try to close the goal. See https://github.com/leanprover-community/mathlib4/issues/5025\n  have hf_f_meas : f =áµ[Î¼] f_meas := by simp only [f_meas, Subtype.coe_mk]; rfl\n  refine hf_f_meas.trans ?_\n  refine lpMeas.ae_eq_zero_of_forall_setIntegral_eq_zero hm f_meas hp_ne_zero hp_ne_top ?_ ?_\n  Â· intro s hs hÎ¼s\n    have hfg_restrict : f =áµ[Î¼.restrict s] f_meas := ae_restrict_of_ae hf_f_meas\n    rw [IntegrableOn, integrable_congr hfg_restrict.symm]\n    exact hf_int_finite s hs hÎ¼s\n  Â· intro s hs hÎ¼s\n    have hfg_restrict : f =áµ[Î¼.restrict s] f_meas := ae_restrict_of_ae hf_f_meas\n    rw [integral_congr_ae hfg_restrict.symm]\n    exact hf_zero s hs hÎ¼s\n\n"}
{"name":"MeasureTheory.Lp.ae_eq_of_forall_setIntegral_eq'","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Unique","initialProofState":"Î± : Type u_1\nE' : Type u_2\nğ•œ : Type u_4\np : ENNReal\nm m0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœâ´ : RCLike ğ•œ\ninstâœÂ³ : NormedAddCommGroup E'\ninstâœÂ² : InnerProductSpace ğ•œ E'\ninstâœÂ¹ : CompleteSpace E'\ninstâœ : NormedSpace Real E'\nhm : LE.le m m0\nf g : Subtype fun x => Membership.mem (MeasureTheory.Lp E' p Î¼) x\nhp_ne_zero : Ne p 0\nhp_ne_top : Ne p Top.top\nhf_int_finite : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ MeasureTheory.IntegrableOn (â†‘â†‘f) s Î¼\nhg_int_finite : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ MeasureTheory.IntegrableOn (â†‘â†‘g) s Î¼\nhfg : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ Eq (MeasureTheory.integral (Î¼.restrict s) fun x => â†‘â†‘f x) (MeasureTheory.integral (Î¼.restrict s) fun x => â†‘â†‘g x)\nhf_meas : MeasureTheory.AEStronglyMeasurable (â†‘â†‘f) Î¼\nhg_meas : MeasureTheory.AEStronglyMeasurable (â†‘â†‘g) Î¼\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq â†‘â†‘f â†‘â†‘g","decl":"include ğ•œ in\n/-- **Uniqueness of the conditional expectation** -/\ntheorem Lp.ae_eq_of_forall_setIntegral_eq' (hm : m â‰¤ m0) (f g : Lp E' p Î¼) (hp_ne_zero : p â‰  0)\n    (hp_ne_top : p â‰  âˆ) (hf_int_finite : âˆ€ s, MeasurableSet[m] s â†’ Î¼ s < âˆ â†’ IntegrableOn f s Î¼)\n    (hg_int_finite : âˆ€ s, MeasurableSet[m] s â†’ Î¼ s < âˆ â†’ IntegrableOn g s Î¼)\n    (hfg : âˆ€ s : Set Î±, MeasurableSet[m] s â†’ Î¼ s < âˆ â†’ âˆ« x in s, f x âˆ‚Î¼ = âˆ« x in s, g x âˆ‚Î¼)\n    (hf_meas : AEStronglyMeasurable[m] f Î¼) (hg_meas : AEStronglyMeasurable[m] g Î¼) :\n    f =áµ[Î¼] g := by\n  suffices h_sub : â‡‘(f - g) =áµ[Î¼] 0 by\n    rw [â† sub_ae_eq_zero]; exact (Lp.coeFn_sub f g).symm.trans h_sub\n  have hfg' : âˆ€ s : Set Î±, MeasurableSet[m] s â†’ Î¼ s < âˆ â†’ (âˆ« x in s, (f - g) x âˆ‚Î¼) = 0 := by\n    intro s hs hÎ¼s\n    rw [integral_congr_ae (ae_restrict_of_ae (Lp.coeFn_sub f g))]\n    rw [integral_sub' (hf_int_finite s hs hÎ¼s) (hg_int_finite s hs hÎ¼s)]\n    exact sub_eq_zero.mpr (hfg s hs hÎ¼s)\n  have hfg_int : âˆ€ s, MeasurableSet[m] s â†’ Î¼ s < âˆ â†’ IntegrableOn (â‡‘(f - g)) s Î¼ := by\n    intro s hs hÎ¼s\n    rw [IntegrableOn, integrable_congr (ae_restrict_of_ae (Lp.coeFn_sub f g))]\n    exact (hf_int_finite s hs hÎ¼s).sub (hg_int_finite s hs hÎ¼s)\n  exact Lp.ae_eq_zero_of_forall_setIntegral_eq_zero' ğ•œ hm (f - g) hp_ne_zero hp_ne_top hfg_int hfg'\n    <| (hf_meas.sub hg_meas).congr (Lp.coeFn_sub f g).symm\n\n"}
{"name":"MeasureTheory.ae_eq_of_forall_setIntegral_eq_of_sigmaFinite'","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Unique","initialProofState":"Î± : Type u_1\nF' : Type u_3\nm m0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ³ : NormedAddCommGroup F'\ninstâœÂ² : NormedSpace Real F'\ninstâœÂ¹ : CompleteSpace F'\nhm : LE.le m m0\ninstâœ : MeasureTheory.SigmaFinite (Î¼.trim hm)\nf g : Î± â†’ F'\nhf_int_finite : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ MeasureTheory.IntegrableOn f s Î¼\nhg_int_finite : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ MeasureTheory.IntegrableOn g s Î¼\nhfg_eq : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ Eq (MeasureTheory.integral (Î¼.restrict s) fun x => f x) (MeasureTheory.integral (Î¼.restrict s) fun x => g x)\nhfm : MeasureTheory.AEStronglyMeasurable f Î¼\nhgm : MeasureTheory.AEStronglyMeasurable g Î¼\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq f g","decl":"theorem ae_eq_of_forall_setIntegral_eq_of_sigmaFinite' (hm : m â‰¤ m0) [SigmaFinite (Î¼.trim hm)]\n    {f g : Î± â†’ F'} (hf_int_finite : âˆ€ s, MeasurableSet[m] s â†’ Î¼ s < âˆ â†’ IntegrableOn f s Î¼)\n    (hg_int_finite : âˆ€ s, MeasurableSet[m] s â†’ Î¼ s < âˆ â†’ IntegrableOn g s Î¼)\n    (hfg_eq : âˆ€ s : Set Î±, MeasurableSet[m] s â†’ Î¼ s < âˆ â†’ âˆ« x in s, f x âˆ‚Î¼ = âˆ« x in s, g x âˆ‚Î¼)\n    (hfm : AEStronglyMeasurable[m] f Î¼) (hgm : AEStronglyMeasurable[m] g Î¼) : f =áµ[Î¼] g := by\n  rw [â† ae_eq_trim_iff_of_aeStronglyMeasurable' hm hfm hgm]\n  have hf_mk_int_finite (s) :\n      MeasurableSet[m] s â†’ Î¼.trim hm s < âˆ â†’ @IntegrableOn _ _ m _ _ (hfm.mk f) s (Î¼.trim hm) := by\n    intro hs hÎ¼s\n    rw [trim_measurableSet_eq hm hs] at hÎ¼s\n    -- Porting note: `rw [IntegrableOn]` fails with\n    -- synthesized type class instance is not definitionally equal to expression inferred by typing\n    -- rules, synthesized m0 inferred m\n    unfold IntegrableOn\n    rw [restrict_trim hm _ hs]\n    refine Integrable.trim hm ?_ hfm.stronglyMeasurable_mk\n    exact Integrable.congr (hf_int_finite s hs hÎ¼s) (ae_restrict_of_ae hfm.ae_eq_mk)\n  have hg_mk_int_finite (s) :\n      MeasurableSet[m] s â†’ Î¼.trim hm s < âˆ â†’ @IntegrableOn _ _ m _ _ (hgm.mk g) s (Î¼.trim hm) := by\n    intro hs hÎ¼s\n    rw [trim_measurableSet_eq hm hs] at hÎ¼s\n    -- Porting note: `rw [IntegrableOn]` fails with\n    -- synthesized type class instance is not definitionally equal to expression inferred by typing\n    -- rules, synthesized m0 inferred m\n    unfold IntegrableOn\n    rw [restrict_trim hm _ hs]\n    refine Integrable.trim hm ?_ hgm.stronglyMeasurable_mk\n    exact Integrable.congr (hg_int_finite s hs hÎ¼s) (ae_restrict_of_ae hgm.ae_eq_mk)\n  have hfg_mk_eq :\n    âˆ€ s : Set Î±,\n      MeasurableSet[m] s â†’\n        Î¼.trim hm s < âˆ â†’ âˆ« x in s, hfm.mk f x âˆ‚Î¼.trim hm = âˆ« x in s, hgm.mk g x âˆ‚Î¼.trim hm := by\n    intro s hs hÎ¼s\n    rw [trim_measurableSet_eq hm hs] at hÎ¼s\n    rw [restrict_trim hm _ hs, â† integral_trim hm hfm.stronglyMeasurable_mk, â†\n      integral_trim hm hgm.stronglyMeasurable_mk,\n      integral_congr_ae (ae_restrict_of_ae hfm.ae_eq_mk.symm),\n      integral_congr_ae (ae_restrict_of_ae hgm.ae_eq_mk.symm)]\n    exact hfg_eq s hs hÎ¼s\n  exact ae_eq_of_forall_setIntegral_eq_of_sigmaFinite hf_mk_int_finite hg_mk_int_finite hfg_mk_eq\n\n"}
{"name":"MeasureTheory.integral_norm_le_of_forall_fin_meas_integral_eq","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Unique","initialProofState":"Î± : Type u_1\nm m0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ns : Set Î±\nhm : LE.le m m0\nf g : Î± â†’ Real\nhf : MeasureTheory.StronglyMeasurable f\nhfi : MeasureTheory.IntegrableOn f s Î¼\nhg : MeasureTheory.StronglyMeasurable g\nhgi : MeasureTheory.IntegrableOn g s Î¼\nhgf : âˆ€ (t : Set Î±), MeasurableSet t â†’ LT.lt (Î¼ t) Top.top â†’ Eq (MeasureTheory.integral (Î¼.restrict t) fun x => g x) (MeasureTheory.integral (Î¼.restrict t) fun x => f x)\nhs : MeasurableSet s\nhÎ¼s : Ne (Î¼ s) Top.top\nâŠ¢ LE.le (MeasureTheory.integral (Î¼.restrict s) fun x => Norm.norm (g x)) (MeasureTheory.integral (Î¼.restrict s) fun x => Norm.norm (f x))","decl":"/-- Let `m` be a sub-Ïƒ-algebra of `m0`, `f` an `m0`-measurable function and `g` an `m`-measurable\nfunction, such that their integrals coincide on `m`-measurable sets with finite measure.\nThen `âˆ« x in s, â€–g xâ€– âˆ‚Î¼ â‰¤ âˆ« x in s, â€–f xâ€– âˆ‚Î¼` on all `m`-measurable sets with finite measure. -/\ntheorem integral_norm_le_of_forall_fin_meas_integral_eq (hm : m â‰¤ m0) {f g : Î± â†’ â„}\n    (hf : StronglyMeasurable f) (hfi : IntegrableOn f s Î¼) (hg : StronglyMeasurable[m] g)\n    (hgi : IntegrableOn g s Î¼)\n    (hgf : âˆ€ t, MeasurableSet[m] t â†’ Î¼ t < âˆ â†’ âˆ« x in t, g x âˆ‚Î¼ = âˆ« x in t, f x âˆ‚Î¼)\n    (hs : MeasurableSet[m] s) (hÎ¼s : Î¼ s â‰  âˆ) : (âˆ« x in s, â€–g xâ€– âˆ‚Î¼) â‰¤ âˆ« x in s, â€–f xâ€– âˆ‚Î¼ := by\n  rw [integral_norm_eq_pos_sub_neg hgi, integral_norm_eq_pos_sub_neg hfi]\n  have h_meas_nonneg_g : MeasurableSet[m] {x | 0 â‰¤ g x} :=\n    (@stronglyMeasurable_const _ _ m _ _).measurableSet_le hg\n  have h_meas_nonneg_f : MeasurableSet {x | 0 â‰¤ f x} :=\n    stronglyMeasurable_const.measurableSet_le hf\n  have h_meas_nonpos_g : MeasurableSet[m] {x | g x â‰¤ 0} :=\n    hg.measurableSet_le (@stronglyMeasurable_const _ _ m _ _)\n  have h_meas_nonpos_f : MeasurableSet {x | f x â‰¤ 0} :=\n    hf.measurableSet_le stronglyMeasurable_const\n  refine sub_le_sub ?_ ?_\n  Â· rw [Measure.restrict_restrict (hm _ h_meas_nonneg_g), Measure.restrict_restrict h_meas_nonneg_f,\n      hgf _ (@MeasurableSet.inter Î± m _ _ h_meas_nonneg_g hs)\n        ((measure_mono Set.inter_subset_right).trans_lt (lt_top_iff_ne_top.mpr hÎ¼s)),\n      â† Measure.restrict_restrict (hm _ h_meas_nonneg_g), â†\n      Measure.restrict_restrict h_meas_nonneg_f]\n    exact setIntegral_le_nonneg (hm _ h_meas_nonneg_g) hf hfi\n  Â· rw [Measure.restrict_restrict (hm _ h_meas_nonpos_g), Measure.restrict_restrict h_meas_nonpos_f,\n      hgf _ (@MeasurableSet.inter Î± m _ _ h_meas_nonpos_g hs)\n        ((measure_mono Set.inter_subset_right).trans_lt (lt_top_iff_ne_top.mpr hÎ¼s)),\n      â† Measure.restrict_restrict (hm _ h_meas_nonpos_g), â†\n      Measure.restrict_restrict h_meas_nonpos_f]\n    exact setIntegral_nonpos_le (hm _ h_meas_nonpos_g) hf hfi\n\n"}
{"name":"MeasureTheory.lintegral_enorm_le_of_forall_fin_meas_integral_eq","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Unique","initialProofState":"Î± : Type u_1\nm m0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ns : Set Î±\nhm : LE.le m m0\nf g : Î± â†’ Real\nhf : MeasureTheory.StronglyMeasurable f\nhfi : MeasureTheory.IntegrableOn f s Î¼\nhg : MeasureTheory.StronglyMeasurable g\nhgi : MeasureTheory.IntegrableOn g s Î¼\nhgf : âˆ€ (t : Set Î±), MeasurableSet t â†’ LT.lt (Î¼ t) Top.top â†’ Eq (MeasureTheory.integral (Î¼.restrict t) fun x => g x) (MeasureTheory.integral (Î¼.restrict t) fun x => f x)\nhs : MeasurableSet s\nhÎ¼s : Ne (Î¼ s) Top.top\nâŠ¢ LE.le (MeasureTheory.lintegral (Î¼.restrict s) fun x => ENorm.enorm (g x)) (MeasureTheory.lintegral (Î¼.restrict s) fun x => ENorm.enorm (f x))","decl":"/-- Let `m` be a sub-Ïƒ-algebra of `m0`, `f` an `m0`-measurable function and `g` an `m`-measurable\nfunction, such that their integrals coincide on `m`-measurable sets with finite measure.\nThen `âˆ«â» x in s, â€–g xâ€–â‚‘ âˆ‚Î¼ â‰¤ âˆ«â» x in s, â€–f xâ€–â‚‘ âˆ‚Î¼` on all `m`-measurable sets with finite\nmeasure. -/\ntheorem lintegral_enorm_le_of_forall_fin_meas_integral_eq (hm : m â‰¤ m0) {f g : Î± â†’ â„}\n    (hf : StronglyMeasurable f) (hfi : IntegrableOn f s Î¼) (hg : StronglyMeasurable[m] g)\n    (hgi : IntegrableOn g s Î¼)\n    (hgf : âˆ€ t, MeasurableSet[m] t â†’ Î¼ t < âˆ â†’ âˆ« x in t, g x âˆ‚Î¼ = âˆ« x in t, f x âˆ‚Î¼)\n    (hs : MeasurableSet[m] s) (hÎ¼s : Î¼ s â‰  âˆ) : (âˆ«â» x in s, â€–g xâ€–â‚‘ âˆ‚Î¼) â‰¤ âˆ«â» x in s, â€–f xâ€–â‚‘ âˆ‚Î¼ := by\n  rw [â† ofReal_integral_norm_eq_lintegral_enorm hfi, â†\n    ofReal_integral_norm_eq_lintegral_enorm hgi, ENNReal.ofReal_le_ofReal_iff]\n  Â· exact integral_norm_le_of_forall_fin_meas_integral_eq hm hf hfi hg hgi hgf hs hÎ¼s\n  Â· positivity\n\n"}
{"name":"MeasureTheory.lintegral_nnnorm_le_of_forall_fin_meas_integral_eq","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Unique","initialProofState":"Î± : Type u_1\nm m0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ns : Set Î±\nhm : LE.le m m0\nf g : Î± â†’ Real\nhf : MeasureTheory.StronglyMeasurable f\nhfi : MeasureTheory.IntegrableOn f s Î¼\nhg : MeasureTheory.StronglyMeasurable g\nhgi : MeasureTheory.IntegrableOn g s Î¼\nhgf : âˆ€ (t : Set Î±), MeasurableSet t â†’ LT.lt (Î¼ t) Top.top â†’ Eq (MeasureTheory.integral (Î¼.restrict t) fun x => g x) (MeasureTheory.integral (Î¼.restrict t) fun x => f x)\nhs : MeasurableSet s\nhÎ¼s : Ne (Î¼ s) Top.top\nâŠ¢ LE.le (MeasureTheory.lintegral (Î¼.restrict s) fun x => ENorm.enorm (g x)) (MeasureTheory.lintegral (Î¼.restrict s) fun x => ENorm.enorm (f x))","decl":"@[deprecated (since := \"2025-01-21\")]\nalias lintegral_nnnorm_le_of_forall_fin_meas_integral_eq :=\n  lintegral_enorm_le_of_forall_fin_meas_integral_eq\n\n"}
