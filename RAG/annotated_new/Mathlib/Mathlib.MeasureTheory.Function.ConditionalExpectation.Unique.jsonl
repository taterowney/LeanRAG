{"name":"MeasureTheory.lpMeas.ae_eq_zero_of_forall_setIntegral_eq_zero","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Unique","initialProofState":"α : Type u_1\nE' : Type u_2\n𝕜 : Type u_4\np : ENNReal\nm m0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝⁴ : RCLike 𝕜\ninst✝³ : NormedAddCommGroup E'\ninst✝² : InnerProductSpace 𝕜 E'\ninst✝¹ : CompleteSpace E'\ninst✝ : NormedSpace Real E'\nhm : LE.le m m0\nf : Subtype fun x => Membership.mem (MeasureTheory.lpMeas E' 𝕜 m p μ) x\nhp_ne_zero : Ne p 0\nhp_ne_top : Ne p Top.top\nhf_int_finite : ∀ (s : Set α), MeasurableSet s → LT.lt (μ s) Top.top → MeasureTheory.IntegrableOn (↑↑↑f) s μ\nhf_zero : ∀ (s : Set α), MeasurableSet s → LT.lt (μ s) Top.top → Eq (MeasureTheory.integral (μ.restrict s) fun x => ↑↑↑f x) 0\n⊢ (MeasureTheory.ae μ).EventuallyEq (↑↑↑f) 0","decl":"theorem lpMeas.ae_eq_zero_of_forall_setIntegral_eq_zero (hm : m ≤ m0) (f : lpMeas E' 𝕜 m p μ)\n    (hp_ne_zero : p ≠ 0) (hp_ne_top : p ≠ ∞)\n    -- Porting note: needed to add explicit casts in the next two hypotheses\n    (hf_int_finite : ∀ s, MeasurableSet[m] s → μ s < ∞ → IntegrableOn (f : Lp E' p μ) s μ)\n    (hf_zero : ∀ s : Set α, MeasurableSet[m] s → μ s < ∞ → ∫ x in s, (f : Lp E' p μ) x ∂μ = 0) :\n    f =ᵐ[μ] (0 : α → E') := by\n  obtain ⟨g, hg_sm, hfg⟩ := lpMeas.ae_fin_strongly_measurable' hm f hp_ne_zero hp_ne_top\n  refine hfg.trans ?_\n  -- Porting note: added\n  unfold Filter.EventuallyEq at hfg\n  refine ae_eq_zero_of_forall_setIntegral_eq_of_finStronglyMeasurable_trim hm ?_ ?_ hg_sm\n  · intro s hs hμs\n    have hfg_restrict : f =ᵐ[μ.restrict s] g := ae_restrict_of_ae hfg\n    rw [IntegrableOn, integrable_congr hfg_restrict.symm]\n    exact hf_int_finite s hs hμs\n  · intro s hs hμs\n    have hfg_restrict : f =ᵐ[μ.restrict s] g := ae_restrict_of_ae hfg\n    rw [integral_congr_ae hfg_restrict.symm]\n    exact hf_zero s hs hμs\n\n"}
{"name":"MeasureTheory.Lp.ae_eq_zero_of_forall_setIntegral_eq_zero'","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Unique","initialProofState":"α : Type u_1\nE' : Type u_2\n𝕜 : Type u_4\np : ENNReal\nm m0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝⁴ : RCLike 𝕜\ninst✝³ : NormedAddCommGroup E'\ninst✝² : InnerProductSpace 𝕜 E'\ninst✝¹ : CompleteSpace E'\ninst✝ : NormedSpace Real E'\nhm : LE.le m m0\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E' p μ) x\nhp_ne_zero : Ne p 0\nhp_ne_top : Ne p Top.top\nhf_int_finite : ∀ (s : Set α), MeasurableSet s → LT.lt (μ s) Top.top → MeasureTheory.IntegrableOn (↑↑f) s μ\nhf_zero : ∀ (s : Set α), MeasurableSet s → LT.lt (μ s) Top.top → Eq (MeasureTheory.integral (μ.restrict s) fun x => ↑↑f x) 0\nhf_meas : MeasureTheory.AEStronglyMeasurable (↑↑f) μ\n⊢ (MeasureTheory.ae μ).EventuallyEq (↑↑f) 0","decl":"include 𝕜 in\ntheorem Lp.ae_eq_zero_of_forall_setIntegral_eq_zero' (hm : m ≤ m0) (f : Lp E' p μ)\n    (hp_ne_zero : p ≠ 0) (hp_ne_top : p ≠ ∞)\n    (hf_int_finite : ∀ s, MeasurableSet[m] s → μ s < ∞ → IntegrableOn f s μ)\n    (hf_zero : ∀ s : Set α, MeasurableSet[m] s → μ s < ∞ → ∫ x in s, f x ∂μ = 0)\n    (hf_meas : AEStronglyMeasurable[m] f μ) : f =ᵐ[μ] 0 := by\n  let f_meas : lpMeas E' 𝕜 m p μ := ⟨f, hf_meas⟩\n  -- Porting note: `simp only` does not call `rfl` to try to close the goal. See https://github.com/leanprover-community/mathlib4/issues/5025\n  have hf_f_meas : f =ᵐ[μ] f_meas := by simp only [f_meas, Subtype.coe_mk]; rfl\n  refine hf_f_meas.trans ?_\n  refine lpMeas.ae_eq_zero_of_forall_setIntegral_eq_zero hm f_meas hp_ne_zero hp_ne_top ?_ ?_\n  · intro s hs hμs\n    have hfg_restrict : f =ᵐ[μ.restrict s] f_meas := ae_restrict_of_ae hf_f_meas\n    rw [IntegrableOn, integrable_congr hfg_restrict.symm]\n    exact hf_int_finite s hs hμs\n  · intro s hs hμs\n    have hfg_restrict : f =ᵐ[μ.restrict s] f_meas := ae_restrict_of_ae hf_f_meas\n    rw [integral_congr_ae hfg_restrict.symm]\n    exact hf_zero s hs hμs\n\n"}
{"name":"MeasureTheory.Lp.ae_eq_of_forall_setIntegral_eq'","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Unique","initialProofState":"α : Type u_1\nE' : Type u_2\n𝕜 : Type u_4\np : ENNReal\nm m0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝⁴ : RCLike 𝕜\ninst✝³ : NormedAddCommGroup E'\ninst✝² : InnerProductSpace 𝕜 E'\ninst✝¹ : CompleteSpace E'\ninst✝ : NormedSpace Real E'\nhm : LE.le m m0\nf g : Subtype fun x => Membership.mem (MeasureTheory.Lp E' p μ) x\nhp_ne_zero : Ne p 0\nhp_ne_top : Ne p Top.top\nhf_int_finite : ∀ (s : Set α), MeasurableSet s → LT.lt (μ s) Top.top → MeasureTheory.IntegrableOn (↑↑f) s μ\nhg_int_finite : ∀ (s : Set α), MeasurableSet s → LT.lt (μ s) Top.top → MeasureTheory.IntegrableOn (↑↑g) s μ\nhfg : ∀ (s : Set α), MeasurableSet s → LT.lt (μ s) Top.top → Eq (MeasureTheory.integral (μ.restrict s) fun x => ↑↑f x) (MeasureTheory.integral (μ.restrict s) fun x => ↑↑g x)\nhf_meas : MeasureTheory.AEStronglyMeasurable (↑↑f) μ\nhg_meas : MeasureTheory.AEStronglyMeasurable (↑↑g) μ\n⊢ (MeasureTheory.ae μ).EventuallyEq ↑↑f ↑↑g","decl":"include 𝕜 in\n/-- **Uniqueness of the conditional expectation** -/\ntheorem Lp.ae_eq_of_forall_setIntegral_eq' (hm : m ≤ m0) (f g : Lp E' p μ) (hp_ne_zero : p ≠ 0)\n    (hp_ne_top : p ≠ ∞) (hf_int_finite : ∀ s, MeasurableSet[m] s → μ s < ∞ → IntegrableOn f s μ)\n    (hg_int_finite : ∀ s, MeasurableSet[m] s → μ s < ∞ → IntegrableOn g s μ)\n    (hfg : ∀ s : Set α, MeasurableSet[m] s → μ s < ∞ → ∫ x in s, f x ∂μ = ∫ x in s, g x ∂μ)\n    (hf_meas : AEStronglyMeasurable[m] f μ) (hg_meas : AEStronglyMeasurable[m] g μ) :\n    f =ᵐ[μ] g := by\n  suffices h_sub : ⇑(f - g) =ᵐ[μ] 0 by\n    rw [← sub_ae_eq_zero]; exact (Lp.coeFn_sub f g).symm.trans h_sub\n  have hfg' : ∀ s : Set α, MeasurableSet[m] s → μ s < ∞ → (∫ x in s, (f - g) x ∂μ) = 0 := by\n    intro s hs hμs\n    rw [integral_congr_ae (ae_restrict_of_ae (Lp.coeFn_sub f g))]\n    rw [integral_sub' (hf_int_finite s hs hμs) (hg_int_finite s hs hμs)]\n    exact sub_eq_zero.mpr (hfg s hs hμs)\n  have hfg_int : ∀ s, MeasurableSet[m] s → μ s < ∞ → IntegrableOn (⇑(f - g)) s μ := by\n    intro s hs hμs\n    rw [IntegrableOn, integrable_congr (ae_restrict_of_ae (Lp.coeFn_sub f g))]\n    exact (hf_int_finite s hs hμs).sub (hg_int_finite s hs hμs)\n  exact Lp.ae_eq_zero_of_forall_setIntegral_eq_zero' 𝕜 hm (f - g) hp_ne_zero hp_ne_top hfg_int hfg'\n    <| (hf_meas.sub hg_meas).congr (Lp.coeFn_sub f g).symm\n\n"}
{"name":"MeasureTheory.ae_eq_of_forall_setIntegral_eq_of_sigmaFinite'","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Unique","initialProofState":"α : Type u_1\nF' : Type u_3\nm m0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝³ : NormedAddCommGroup F'\ninst✝² : NormedSpace Real F'\ninst✝¹ : CompleteSpace F'\nhm : LE.le m m0\ninst✝ : MeasureTheory.SigmaFinite (μ.trim hm)\nf g : α → F'\nhf_int_finite : ∀ (s : Set α), MeasurableSet s → LT.lt (μ s) Top.top → MeasureTheory.IntegrableOn f s μ\nhg_int_finite : ∀ (s : Set α), MeasurableSet s → LT.lt (μ s) Top.top → MeasureTheory.IntegrableOn g s μ\nhfg_eq : ∀ (s : Set α), MeasurableSet s → LT.lt (μ s) Top.top → Eq (MeasureTheory.integral (μ.restrict s) fun x => f x) (MeasureTheory.integral (μ.restrict s) fun x => g x)\nhfm : MeasureTheory.AEStronglyMeasurable f μ\nhgm : MeasureTheory.AEStronglyMeasurable g μ\n⊢ (MeasureTheory.ae μ).EventuallyEq f g","decl":"theorem ae_eq_of_forall_setIntegral_eq_of_sigmaFinite' (hm : m ≤ m0) [SigmaFinite (μ.trim hm)]\n    {f g : α → F'} (hf_int_finite : ∀ s, MeasurableSet[m] s → μ s < ∞ → IntegrableOn f s μ)\n    (hg_int_finite : ∀ s, MeasurableSet[m] s → μ s < ∞ → IntegrableOn g s μ)\n    (hfg_eq : ∀ s : Set α, MeasurableSet[m] s → μ s < ∞ → ∫ x in s, f x ∂μ = ∫ x in s, g x ∂μ)\n    (hfm : AEStronglyMeasurable[m] f μ) (hgm : AEStronglyMeasurable[m] g μ) : f =ᵐ[μ] g := by\n  rw [← ae_eq_trim_iff_of_aeStronglyMeasurable' hm hfm hgm]\n  have hf_mk_int_finite (s) :\n      MeasurableSet[m] s → μ.trim hm s < ∞ → @IntegrableOn _ _ m _ _ (hfm.mk f) s (μ.trim hm) := by\n    intro hs hμs\n    rw [trim_measurableSet_eq hm hs] at hμs\n    -- Porting note: `rw [IntegrableOn]` fails with\n    -- synthesized type class instance is not definitionally equal to expression inferred by typing\n    -- rules, synthesized m0 inferred m\n    unfold IntegrableOn\n    rw [restrict_trim hm _ hs]\n    refine Integrable.trim hm ?_ hfm.stronglyMeasurable_mk\n    exact Integrable.congr (hf_int_finite s hs hμs) (ae_restrict_of_ae hfm.ae_eq_mk)\n  have hg_mk_int_finite (s) :\n      MeasurableSet[m] s → μ.trim hm s < ∞ → @IntegrableOn _ _ m _ _ (hgm.mk g) s (μ.trim hm) := by\n    intro hs hμs\n    rw [trim_measurableSet_eq hm hs] at hμs\n    -- Porting note: `rw [IntegrableOn]` fails with\n    -- synthesized type class instance is not definitionally equal to expression inferred by typing\n    -- rules, synthesized m0 inferred m\n    unfold IntegrableOn\n    rw [restrict_trim hm _ hs]\n    refine Integrable.trim hm ?_ hgm.stronglyMeasurable_mk\n    exact Integrable.congr (hg_int_finite s hs hμs) (ae_restrict_of_ae hgm.ae_eq_mk)\n  have hfg_mk_eq :\n    ∀ s : Set α,\n      MeasurableSet[m] s →\n        μ.trim hm s < ∞ → ∫ x in s, hfm.mk f x ∂μ.trim hm = ∫ x in s, hgm.mk g x ∂μ.trim hm := by\n    intro s hs hμs\n    rw [trim_measurableSet_eq hm hs] at hμs\n    rw [restrict_trim hm _ hs, ← integral_trim hm hfm.stronglyMeasurable_mk, ←\n      integral_trim hm hgm.stronglyMeasurable_mk,\n      integral_congr_ae (ae_restrict_of_ae hfm.ae_eq_mk.symm),\n      integral_congr_ae (ae_restrict_of_ae hgm.ae_eq_mk.symm)]\n    exact hfg_eq s hs hμs\n  exact ae_eq_of_forall_setIntegral_eq_of_sigmaFinite hf_mk_int_finite hg_mk_int_finite hfg_mk_eq\n\n"}
{"name":"MeasureTheory.integral_norm_le_of_forall_fin_meas_integral_eq","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Unique","initialProofState":"α : Type u_1\nm m0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nhm : LE.le m m0\nf g : α → Real\nhf : MeasureTheory.StronglyMeasurable f\nhfi : MeasureTheory.IntegrableOn f s μ\nhg : MeasureTheory.StronglyMeasurable g\nhgi : MeasureTheory.IntegrableOn g s μ\nhgf : ∀ (t : Set α), MeasurableSet t → LT.lt (μ t) Top.top → Eq (MeasureTheory.integral (μ.restrict t) fun x => g x) (MeasureTheory.integral (μ.restrict t) fun x => f x)\nhs : MeasurableSet s\nhμs : Ne (μ s) Top.top\n⊢ LE.le (MeasureTheory.integral (μ.restrict s) fun x => Norm.norm (g x)) (MeasureTheory.integral (μ.restrict s) fun x => Norm.norm (f x))","decl":"/-- Let `m` be a sub-σ-algebra of `m0`, `f` an `m0`-measurable function and `g` an `m`-measurable\nfunction, such that their integrals coincide on `m`-measurable sets with finite measure.\nThen `∫ x in s, ‖g x‖ ∂μ ≤ ∫ x in s, ‖f x‖ ∂μ` on all `m`-measurable sets with finite measure. -/\ntheorem integral_norm_le_of_forall_fin_meas_integral_eq (hm : m ≤ m0) {f g : α → ℝ}\n    (hf : StronglyMeasurable f) (hfi : IntegrableOn f s μ) (hg : StronglyMeasurable[m] g)\n    (hgi : IntegrableOn g s μ)\n    (hgf : ∀ t, MeasurableSet[m] t → μ t < ∞ → ∫ x in t, g x ∂μ = ∫ x in t, f x ∂μ)\n    (hs : MeasurableSet[m] s) (hμs : μ s ≠ ∞) : (∫ x in s, ‖g x‖ ∂μ) ≤ ∫ x in s, ‖f x‖ ∂μ := by\n  rw [integral_norm_eq_pos_sub_neg hgi, integral_norm_eq_pos_sub_neg hfi]\n  have h_meas_nonneg_g : MeasurableSet[m] {x | 0 ≤ g x} :=\n    (@stronglyMeasurable_const _ _ m _ _).measurableSet_le hg\n  have h_meas_nonneg_f : MeasurableSet {x | 0 ≤ f x} :=\n    stronglyMeasurable_const.measurableSet_le hf\n  have h_meas_nonpos_g : MeasurableSet[m] {x | g x ≤ 0} :=\n    hg.measurableSet_le (@stronglyMeasurable_const _ _ m _ _)\n  have h_meas_nonpos_f : MeasurableSet {x | f x ≤ 0} :=\n    hf.measurableSet_le stronglyMeasurable_const\n  refine sub_le_sub ?_ ?_\n  · rw [Measure.restrict_restrict (hm _ h_meas_nonneg_g), Measure.restrict_restrict h_meas_nonneg_f,\n      hgf _ (@MeasurableSet.inter α m _ _ h_meas_nonneg_g hs)\n        ((measure_mono Set.inter_subset_right).trans_lt (lt_top_iff_ne_top.mpr hμs)),\n      ← Measure.restrict_restrict (hm _ h_meas_nonneg_g), ←\n      Measure.restrict_restrict h_meas_nonneg_f]\n    exact setIntegral_le_nonneg (hm _ h_meas_nonneg_g) hf hfi\n  · rw [Measure.restrict_restrict (hm _ h_meas_nonpos_g), Measure.restrict_restrict h_meas_nonpos_f,\n      hgf _ (@MeasurableSet.inter α m _ _ h_meas_nonpos_g hs)\n        ((measure_mono Set.inter_subset_right).trans_lt (lt_top_iff_ne_top.mpr hμs)),\n      ← Measure.restrict_restrict (hm _ h_meas_nonpos_g), ←\n      Measure.restrict_restrict h_meas_nonpos_f]\n    exact setIntegral_nonpos_le (hm _ h_meas_nonpos_g) hf hfi\n\n"}
{"name":"MeasureTheory.lintegral_enorm_le_of_forall_fin_meas_integral_eq","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Unique","initialProofState":"α : Type u_1\nm m0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nhm : LE.le m m0\nf g : α → Real\nhf : MeasureTheory.StronglyMeasurable f\nhfi : MeasureTheory.IntegrableOn f s μ\nhg : MeasureTheory.StronglyMeasurable g\nhgi : MeasureTheory.IntegrableOn g s μ\nhgf : ∀ (t : Set α), MeasurableSet t → LT.lt (μ t) Top.top → Eq (MeasureTheory.integral (μ.restrict t) fun x => g x) (MeasureTheory.integral (μ.restrict t) fun x => f x)\nhs : MeasurableSet s\nhμs : Ne (μ s) Top.top\n⊢ LE.le (MeasureTheory.lintegral (μ.restrict s) fun x => ENorm.enorm (g x)) (MeasureTheory.lintegral (μ.restrict s) fun x => ENorm.enorm (f x))","decl":"/-- Let `m` be a sub-σ-algebra of `m0`, `f` an `m0`-measurable function and `g` an `m`-measurable\nfunction, such that their integrals coincide on `m`-measurable sets with finite measure.\nThen `∫⁻ x in s, ‖g x‖ₑ ∂μ ≤ ∫⁻ x in s, ‖f x‖ₑ ∂μ` on all `m`-measurable sets with finite\nmeasure. -/\ntheorem lintegral_enorm_le_of_forall_fin_meas_integral_eq (hm : m ≤ m0) {f g : α → ℝ}\n    (hf : StronglyMeasurable f) (hfi : IntegrableOn f s μ) (hg : StronglyMeasurable[m] g)\n    (hgi : IntegrableOn g s μ)\n    (hgf : ∀ t, MeasurableSet[m] t → μ t < ∞ → ∫ x in t, g x ∂μ = ∫ x in t, f x ∂μ)\n    (hs : MeasurableSet[m] s) (hμs : μ s ≠ ∞) : (∫⁻ x in s, ‖g x‖ₑ ∂μ) ≤ ∫⁻ x in s, ‖f x‖ₑ ∂μ := by\n  rw [← ofReal_integral_norm_eq_lintegral_enorm hfi, ←\n    ofReal_integral_norm_eq_lintegral_enorm hgi, ENNReal.ofReal_le_ofReal_iff]\n  · exact integral_norm_le_of_forall_fin_meas_integral_eq hm hf hfi hg hgi hgf hs hμs\n  · positivity\n\n"}
{"name":"MeasureTheory.lintegral_nnnorm_le_of_forall_fin_meas_integral_eq","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Unique","initialProofState":"α : Type u_1\nm m0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nhm : LE.le m m0\nf g : α → Real\nhf : MeasureTheory.StronglyMeasurable f\nhfi : MeasureTheory.IntegrableOn f s μ\nhg : MeasureTheory.StronglyMeasurable g\nhgi : MeasureTheory.IntegrableOn g s μ\nhgf : ∀ (t : Set α), MeasurableSet t → LT.lt (μ t) Top.top → Eq (MeasureTheory.integral (μ.restrict t) fun x => g x) (MeasureTheory.integral (μ.restrict t) fun x => f x)\nhs : MeasurableSet s\nhμs : Ne (μ s) Top.top\n⊢ LE.le (MeasureTheory.lintegral (μ.restrict s) fun x => ENorm.enorm (g x)) (MeasureTheory.lintegral (μ.restrict s) fun x => ENorm.enorm (f x))","decl":"@[deprecated (since := \"2025-01-21\")]\nalias lintegral_nnnorm_le_of_forall_fin_meas_integral_eq :=\n  lintegral_enorm_le_of_forall_fin_meas_integral_eq\n\n"}
