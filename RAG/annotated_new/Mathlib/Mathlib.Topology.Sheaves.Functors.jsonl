{"name":"TopCat.Sheaf.pushforward_sheaf_of_sheaf","module":"Mathlib.Topology.Sheaves.Functors","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : TopCat\nf : Quiver.Hom X Y\nF : TopCat.Presheaf C X\nh : F.IsSheaf\n⊢ ((TopCat.Presheaf.pushforward C f).obj F).IsSheaf","decl":"/-- The pushforward of a sheaf (by a continuous map) is a sheaf.\n-/\ntheorem pushforward_sheaf_of_sheaf {F : X.Presheaf C} (h : F.IsSheaf) : (f _* F).IsSheaf :=\n  (Opens.map f).op_comp_isSheaf _ _ ⟨_, h⟩\n\n"}
{"name":"TopCat.Sheaf.pushforward_forget","module":"Mathlib.Topology.Sheaves.Functors","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : TopCat\nf : Quiver.Hom X Y\n⊢ Eq ((TopCat.Sheaf.pushforward C f).comp (TopCat.Sheaf.forget C Y)) ((TopCat.Sheaf.forget C X).comp (TopCat.Presheaf.pushforward C f))","decl":"lemma pushforward_forget (f : X ⟶ Y) :\n    pushforward C f ⋙ forget C Y = forget C X ⋙ Presheaf.pushforward C f := rfl\n\n"}
{"name":"TopCat.Sheaf.pushforward_obj_val","module":"Mathlib.Topology.Sheaves.Functors","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : TopCat\nf : Quiver.Hom X Y\nF : TopCat.Sheaf C X\n⊢ Eq ((TopCat.Sheaf.pushforward C f).obj F).val ((TopCat.Presheaf.pushforward C f).obj F.val)","decl":"@[simp] lemma pushforward_obj_val (f : X ⟶ Y) (F : X.Sheaf C) :\n    ((pushforward C f).obj F).1 = f _* F.1 := rfl\n\n"}
{"name":"TopCat.Sheaf.pushforward_map","module":"Mathlib.Topology.Sheaves.Functors","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : TopCat\nf : Quiver.Hom X Y\nF F' : TopCat.Sheaf C X\nα : Quiver.Hom F F'\n⊢ Eq ((TopCat.Sheaf.pushforward C f).map α).val ((TopCat.Presheaf.pushforward C f).map α.val)","decl":"@[simp] lemma pushforward_map (f : X ⟶ Y) {F F' : X.Sheaf C} (α : F ⟶ F') :\n    ((pushforward C f).map α).1 = (Presheaf.pushforward C f).map α.1 := rfl\n\n"}
{"name":"TopCat.Sheaf.instIsLeftAdjointPullback","module":"Mathlib.Topology.Sheaves.Functors","initialProofState":"X Y : TopCat\nf : Quiver.Hom X Y\nA : Type u_1\ninst✝⁶ : CategoryTheory.Category.{w, u_1} A\ninst✝⁵ : CategoryTheory.HasForget A\ninst✝⁴ : CategoryTheory.Limits.HasColimits A\ninst✝³ : CategoryTheory.Limits.HasLimits A\ninst✝² : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget A)\ninst✝¹ : CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.forget A)\ninst✝ : (CategoryTheory.forget A).ReflectsIsomorphisms\n⊢ (TopCat.Sheaf.pullback A f).IsLeftAdjoint","decl":"instance : (pullback A f).IsLeftAdjoint  := (pullbackPushforwardAdjunction A f).isLeftAdjoint\n"}
{"name":"TopCat.Sheaf.instIsRightAdjointPushforward","module":"Mathlib.Topology.Sheaves.Functors","initialProofState":"X Y : TopCat\nf : Quiver.Hom X Y\nA : Type u_1\ninst✝⁶ : CategoryTheory.Category.{w, u_1} A\ninst✝⁵ : CategoryTheory.HasForget A\ninst✝⁴ : CategoryTheory.Limits.HasColimits A\ninst✝³ : CategoryTheory.Limits.HasLimits A\ninst✝² : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget A)\ninst✝¹ : CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.forget A)\ninst✝ : (CategoryTheory.forget A).ReflectsIsomorphisms\n⊢ (TopCat.Sheaf.pushforward A f).IsRightAdjoint","decl":"instance : (pushforward A f).IsRightAdjoint := (pullbackPushforwardAdjunction A f).isRightAdjoint\n\n"}
