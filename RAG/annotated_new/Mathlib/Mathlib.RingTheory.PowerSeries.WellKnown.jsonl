{"name":"PowerSeries.coeff_invUnitsSub","module":"Mathlib.RingTheory.PowerSeries.WellKnown","initialProofState":"R : Type u_1\ninst✝ : Ring R\nu : Units R\nn : Nat\n⊢ Eq ((PowerSeries.coeff R n) (PowerSeries.invUnitsSub u)) (divp 1 (HPow.hPow u (HAdd.hAdd n 1)))","decl":"@[simp]\ntheorem coeff_invUnitsSub (u : Rˣ) (n : ℕ) : coeff R n (invUnitsSub u) = 1 /ₚ u ^ (n + 1) :=\n  coeff_mk _ _\n\n"}
{"name":"PowerSeries.constantCoeff_invUnitsSub","module":"Mathlib.RingTheory.PowerSeries.WellKnown","initialProofState":"R : Type u_1\ninst✝ : Ring R\nu : Units R\n⊢ Eq ((PowerSeries.constantCoeff R) (PowerSeries.invUnitsSub u)) (divp 1 u)","decl":"@[simp]\ntheorem constantCoeff_invUnitsSub (u : Rˣ) : constantCoeff R (invUnitsSub u) = 1 /ₚ u := by\n  rw [← coeff_zero_eq_constantCoeff_apply, coeff_invUnitsSub, zero_add, pow_one]\n\n"}
{"name":"PowerSeries.invUnitsSub_mul_X","module":"Mathlib.RingTheory.PowerSeries.WellKnown","initialProofState":"R : Type u_1\ninst✝ : Ring R\nu : Units R\n⊢ Eq (HMul.hMul (PowerSeries.invUnitsSub u) PowerSeries.X) (HSub.hSub (HMul.hMul (PowerSeries.invUnitsSub u) ((PowerSeries.C R) ↑u)) 1)","decl":"@[simp]\ntheorem invUnitsSub_mul_X (u : Rˣ) : invUnitsSub u * X = invUnitsSub u * C R u - 1 := by\n  ext (_ | n)\n  · simp\n  · simp [n.succ_ne_zero, pow_succ']\n\n"}
{"name":"PowerSeries.invUnitsSub_mul_sub","module":"Mathlib.RingTheory.PowerSeries.WellKnown","initialProofState":"R : Type u_1\ninst✝ : Ring R\nu : Units R\n⊢ Eq (HMul.hMul (PowerSeries.invUnitsSub u) (HSub.hSub ((PowerSeries.C R) ↑u) PowerSeries.X)) 1","decl":"@[simp]\ntheorem invUnitsSub_mul_sub (u : Rˣ) : invUnitsSub u * (C R u - X) = 1 := by\n  simp [mul_sub, sub_sub_cancel]\n\n"}
{"name":"PowerSeries.map_invUnitsSub","module":"Mathlib.RingTheory.PowerSeries.WellKnown","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹ : Ring R\ninst✝ : Ring S\nf : RingHom R S\nu : Units R\n⊢ Eq ((PowerSeries.map f) (PowerSeries.invUnitsSub u)) (PowerSeries.invUnitsSub ((Units.map ↑f) u))","decl":"theorem map_invUnitsSub (f : R →+* S) (u : Rˣ) :\n    map f (invUnitsSub u) = invUnitsSub (Units.map (f : R →* S) u) := by\n  ext\n  simp only [← map_pow, coeff_map, coeff_invUnitsSub, one_divp]\n  rfl\n\n"}
{"name":"PowerSeries.mk_one_mul_one_sub_eq_one","module":"Mathlib.RingTheory.PowerSeries.WellKnown","initialProofState":"S : Type u_1\ninst✝ : CommRing S\n⊢ Eq (HMul.hMul (PowerSeries.mk 1) (HSub.hSub 1 PowerSeries.X)) 1","decl":"/--\n(1 + X + X^2 + ...) * (1 - X) = 1.\n\nNote that the power series `1 + X + X^2 + ...` is written as `mk 1` where `1` is the constant\nfunction so that `mk 1` is the power series with all coefficients equal to one.\n-/\ntheorem mk_one_mul_one_sub_eq_one : (mk 1 : S⟦X⟧) * (1 - X) = 1 := by\n  rw [mul_comm, PowerSeries.ext_iff]\n  intro n\n  cases n with\n  | zero => simp\n  | succ n => simp [sub_mul]\n\n"}
{"name":"PowerSeries.mk_one_pow_eq_mk_choose_add","module":"Mathlib.RingTheory.PowerSeries.WellKnown","initialProofState":"S : Type u_1\ninst✝ : CommRing S\nd : Nat\n⊢ Eq (HPow.hPow (PowerSeries.mk 1) (HAdd.hAdd d 1)) (PowerSeries.mk fun n => ↑((HAdd.hAdd d n).choose d))","decl":"/--\nNote that `mk 1` is the constant function `1` so the power series `1 + X + X^2 + ...`. This theorem\nstates that for any `d : ℕ`, `(1 + X + X^2 + ... : S⟦X⟧) ^ (d + 1)` is equal to the power series\n`mk fun n => Nat.choose (d + n) d : S⟦X⟧`.\n-/\ntheorem mk_one_pow_eq_mk_choose_add :\n    (mk 1 : S⟦X⟧) ^ (d + 1) = (mk fun n => Nat.choose (d + n) d : S⟦X⟧) := by\n  induction d with\n  | zero => ext; simp\n  | succ d hd =>\n      ext n\n      rw [pow_add, hd, pow_one, mul_comm, coeff_mul]\n      simp_rw [coeff_mk, Pi.one_apply, one_mul]\n      norm_cast\n      rw [Finset.sum_antidiagonal_choose_add, add_right_comm]\n\n"}
{"name":"PowerSeries.invOneSubPow_zero","module":"Mathlib.RingTheory.PowerSeries.WellKnown","initialProofState":"S : Type u_1\ninst✝ : CommRing S\n⊢ Eq (PowerSeries.invOneSubPow S 0) 1","decl":"theorem invOneSubPow_zero : invOneSubPow S 0 = 1 := by\n  delta invOneSubPow\n  simp only [Units.val_one]\n\n"}
{"name":"PowerSeries.invOneSubPow_val_eq_mk_sub_one_add_choose_of_pos","module":"Mathlib.RingTheory.PowerSeries.WellKnown","initialProofState":"S : Type u_1\ninst✝ : CommRing S\nd : Nat\nh : LT.lt 0 d\n⊢ Eq (↑(PowerSeries.invOneSubPow S d)) (PowerSeries.mk fun n => ↑((HAdd.hAdd (HSub.hSub d 1) n).choose (HSub.hSub d 1)))","decl":"theorem invOneSubPow_val_eq_mk_sub_one_add_choose_of_pos (h : 0 < d) :\n    (invOneSubPow S d).val = (mk fun n => Nat.choose (d - 1 + n) (d - 1) : S⟦X⟧) := by\n  rw [← Nat.sub_one_add_one_eq_of_pos h, invOneSubPow, add_tsub_cancel_right]\n\n"}
{"name":"PowerSeries.invOneSubPow_val_succ_eq_mk_add_choose","module":"Mathlib.RingTheory.PowerSeries.WellKnown","initialProofState":"S : Type u_1\ninst✝ : CommRing S\nd : Nat\n⊢ Eq (↑(PowerSeries.invOneSubPow S (HAdd.hAdd d 1))) (PowerSeries.mk fun n => ↑((HAdd.hAdd d n).choose d))","decl":"theorem invOneSubPow_val_succ_eq_mk_add_choose :\n    (invOneSubPow S (d + 1)).val = (mk fun n => Nat.choose (d + n) d : S⟦X⟧) := rfl\n\n"}
{"name":"PowerSeries.invOneSubPow_val_one_eq_invUnitSub_one","module":"Mathlib.RingTheory.PowerSeries.WellKnown","initialProofState":"S : Type u_1\ninst✝ : CommRing S\n⊢ Eq (↑(PowerSeries.invOneSubPow S 1)) (PowerSeries.invUnitsSub 1)","decl":"theorem invOneSubPow_val_one_eq_invUnitSub_one :\n    (invOneSubPow S 1).val = invUnitsSub (1 : Sˣ) := by\n  simp [invOneSubPow, invUnitsSub]\n\n"}
{"name":"PowerSeries.invOneSubPow_eq_inv_one_sub_pow","module":"Mathlib.RingTheory.PowerSeries.WellKnown","initialProofState":"S : Type u_1\ninst✝ : CommRing S\nd : Nat\n⊢ Eq (PowerSeries.invOneSubPow S d) (HPow.hPow (Inv.inv (Units.mkOfMulEqOne (HSub.hSub 1 PowerSeries.X) (PowerSeries.mk 1) ⋯)) d)","decl":"/--\nThe theorem `PowerSeries.mk_one_mul_one_sub_eq_one` implies that `1 - X` is a unit in `S⟦X⟧`\nwhose inverse is the power series `1 + X + X^2 + ...`. This theorem states that for any `d : ℕ`,\n`PowerSeries.invOneSubPow S d` is equal to `(1 - X)⁻¹ ^ d`.\n-/\ntheorem invOneSubPow_eq_inv_one_sub_pow :\n    invOneSubPow S d =\n      (Units.mkOfMulEqOne (1 - X) (mk 1 : S⟦X⟧) <|\n        Eq.trans (mul_comm _ _) (mk_one_mul_one_sub_eq_one S))⁻¹ ^ d := by\n  induction d with\n  | zero => exact Eq.symm <| pow_zero _\n  | succ d _ =>\n      rw [inv_pow]\n      exact (DivisionMonoid.inv_eq_of_mul _ (invOneSubPow S (d + 1)) <| by\n        rw [← Units.val_eq_one, Units.val_mul, Units.val_pow_eq_pow_val]\n        exact (invOneSubPow S (d + 1)).inv_val).symm\n\n"}
{"name":"PowerSeries.invOneSubPow_inv_eq_one_sub_pow","module":"Mathlib.RingTheory.PowerSeries.WellKnown","initialProofState":"S : Type u_1\ninst✝ : CommRing S\nd : Nat\n⊢ Eq (PowerSeries.invOneSubPow S d).inv (HPow.hPow (HSub.hSub 1 PowerSeries.X) d)","decl":"theorem invOneSubPow_inv_eq_one_sub_pow :\n    (invOneSubPow S d).inv = (1 - X : S⟦X⟧) ^ d := by\n  induction d with\n  | zero => exact Eq.symm <| pow_zero _\n  | succ d => rfl\n\n"}
{"name":"PowerSeries.invOneSubPow_inv_zero_eq_one","module":"Mathlib.RingTheory.PowerSeries.WellKnown","initialProofState":"S : Type u_1\ninst✝ : CommRing S\n⊢ Eq (PowerSeries.invOneSubPow S 0).inv 1","decl":"theorem invOneSubPow_inv_zero_eq_one : (invOneSubPow S 0).inv = 1 := by\n  delta invOneSubPow\n  simp only [Units.inv_eq_val_inv, inv_one, Units.val_one]\n\n"}
{"name":"PowerSeries.mk_add_choose_mul_one_sub_pow_eq_one","module":"Mathlib.RingTheory.PowerSeries.WellKnown","initialProofState":"S : Type u_1\ninst✝ : CommRing S\nd : Nat\n⊢ Eq (HMul.hMul (PowerSeries.mk fun n => ↑((HAdd.hAdd d n).choose d)) (HPow.hPow (HSub.hSub 1 PowerSeries.X) (HAdd.hAdd d 1))) 1","decl":"theorem mk_add_choose_mul_one_sub_pow_eq_one :\n    (mk fun n ↦ Nat.choose (d + n) d : S⟦X⟧) * ((1 - X) ^ (d + 1)) = 1 :=\n  (invOneSubPow S (d + 1)).val_inv\n\n"}
{"name":"PowerSeries.invOneSubPow_add","module":"Mathlib.RingTheory.PowerSeries.WellKnown","initialProofState":"S : Type u_1\ninst✝ : CommRing S\nd e : Nat\n⊢ Eq (PowerSeries.invOneSubPow S (HAdd.hAdd d e)) (HMul.hMul (PowerSeries.invOneSubPow S d) (PowerSeries.invOneSubPow S e))","decl":"theorem invOneSubPow_add (e : ℕ) :\n    invOneSubPow S (d + e) = invOneSubPow S d * invOneSubPow S e := by\n  simp_rw [invOneSubPow_eq_inv_one_sub_pow, pow_add]\n\n"}
{"name":"PowerSeries.one_sub_pow_mul_invOneSubPow_val_add_eq_invOneSubPow_val","module":"Mathlib.RingTheory.PowerSeries.WellKnown","initialProofState":"S : Type u_1\ninst✝ : CommRing S\nd e : Nat\n⊢ Eq (HMul.hMul (HPow.hPow (HSub.hSub 1 PowerSeries.X) e) ↑(PowerSeries.invOneSubPow S (HAdd.hAdd d e))) ↑(PowerSeries.invOneSubPow S d)","decl":"theorem one_sub_pow_mul_invOneSubPow_val_add_eq_invOneSubPow_val (e : ℕ) :\n    (1 - X) ^ e * (invOneSubPow S (d + e)).val = (invOneSubPow S d).val := by\n  simp [invOneSubPow_add, Units.val_mul, mul_comm, mul_assoc, ← invOneSubPow_inv_eq_one_sub_pow]\n\n"}
{"name":"PowerSeries.one_sub_pow_add_mul_invOneSubPow_val_eq_one_sub_pow","module":"Mathlib.RingTheory.PowerSeries.WellKnown","initialProofState":"S : Type u_1\ninst✝ : CommRing S\nd e : Nat\n⊢ Eq (HMul.hMul (HPow.hPow (HSub.hSub 1 PowerSeries.X) (HAdd.hAdd d e)) ↑(PowerSeries.invOneSubPow S e)) (HPow.hPow (HSub.hSub 1 PowerSeries.X) d)","decl":"theorem one_sub_pow_add_mul_invOneSubPow_val_eq_one_sub_pow (e : ℕ) :\n    (1 - X) ^ (d + e) * (invOneSubPow S e).val = (1 - X) ^ d := by\n  simp [pow_add, mul_assoc, ← invOneSubPow_inv_eq_one_sub_pow S e]\n\n"}
{"name":"PowerSeries.coeff_exp","module":"Mathlib.RingTheory.PowerSeries.WellKnown","initialProofState":"A : Type u_1\ninst✝¹ : Ring A\ninst✝ : Algebra Rat A\nn : Nat\n⊢ Eq ((PowerSeries.coeff A n) (PowerSeries.exp A)) ((algebraMap Rat A) (HDiv.hDiv 1 ↑n.factorial))","decl":"@[simp]\ntheorem coeff_exp : coeff A n (exp A) = algebraMap ℚ A (1 / n !) :=\n  coeff_mk _ _\n\n"}
{"name":"PowerSeries.constantCoeff_exp","module":"Mathlib.RingTheory.PowerSeries.WellKnown","initialProofState":"A : Type u_1\ninst✝¹ : Ring A\ninst✝ : Algebra Rat A\n⊢ Eq ((PowerSeries.constantCoeff A) (PowerSeries.exp A)) 1","decl":"@[simp]\ntheorem constantCoeff_exp : constantCoeff A (exp A) = 1 := by\n  rw [← coeff_zero_eq_constantCoeff_apply, coeff_exp]\n  simp\n\n"}
{"name":"PowerSeries.map_exp","module":"Mathlib.RingTheory.PowerSeries.WellKnown","initialProofState":"A : Type u_1\nA' : Type u_2\ninst✝³ : Ring A\ninst✝² : Ring A'\ninst✝¹ : Algebra Rat A\ninst✝ : Algebra Rat A'\nf : RingHom A A'\n⊢ Eq ((PowerSeries.map f) (PowerSeries.exp A)) (PowerSeries.exp A')","decl":"@[simp]\ntheorem map_exp : map (f : A →+* A') (exp A) = exp A' := by\n  ext\n  simp\n\n"}
{"name":"PowerSeries.map_sin","module":"Mathlib.RingTheory.PowerSeries.WellKnown","initialProofState":"A : Type u_1\nA' : Type u_2\ninst✝³ : Ring A\ninst✝² : Ring A'\ninst✝¹ : Algebra Rat A\ninst✝ : Algebra Rat A'\nf : RingHom A A'\n⊢ Eq ((PowerSeries.map f) (PowerSeries.sin A)) (PowerSeries.sin A')","decl":"@[simp]\ntheorem map_sin : map f (sin A) = sin A' := by\n  ext\n  simp [sin, apply_ite f]\n\n"}
{"name":"PowerSeries.map_cos","module":"Mathlib.RingTheory.PowerSeries.WellKnown","initialProofState":"A : Type u_1\nA' : Type u_2\ninst✝³ : Ring A\ninst✝² : Ring A'\ninst✝¹ : Algebra Rat A\ninst✝ : Algebra Rat A'\nf : RingHom A A'\n⊢ Eq ((PowerSeries.map f) (PowerSeries.cos A)) (PowerSeries.cos A')","decl":"@[simp]\ntheorem map_cos : map f (cos A) = cos A' := by\n  ext\n  simp [cos, apply_ite f]\n\n"}
{"name":"PowerSeries.exp_mul_exp_eq_exp_add","module":"Mathlib.RingTheory.PowerSeries.WellKnown","initialProofState":"A : Type u_1\ninst✝¹ : CommRing A\ninst✝ : Algebra Rat A\na b : A\n⊢ Eq (HMul.hMul ((PowerSeries.rescale a) (PowerSeries.exp A)) ((PowerSeries.rescale b) (PowerSeries.exp A))) ((PowerSeries.rescale (HAdd.hAdd a b)) (PowerSeries.exp A))","decl":"/-- Shows that $e^{aX} * e^{bX} = e^{(a + b)X}$ -/\ntheorem exp_mul_exp_eq_exp_add [Algebra ℚ A] (a b : A) :\n    rescale a (exp A) * rescale b (exp A) = rescale (a + b) (exp A) := by\n  ext n\n  simp only [coeff_mul, exp, rescale, coeff_mk, MonoidHom.coe_mk, OneHom.coe_mk, coe_mk,\n    factorial, Nat.sum_antidiagonal_eq_sum_range_succ_mk, add_pow, sum_mul]\n  apply sum_congr rfl\n  rintro x hx\n  suffices\n    a ^ x * b ^ (n - x) *\n        (algebraMap ℚ A (1 / ↑x.factorial) * algebraMap ℚ A (1 / ↑(n - x).factorial)) =\n      a ^ x * b ^ (n - x) * (↑(n.choose x) * (algebraMap ℚ A) (1 / ↑n.factorial))\n    by convert this using 1 <;> ring\n  congr 1\n  rw [← map_natCast (algebraMap ℚ A) (n.choose x), ← map_mul, ← map_mul]\n  refine RingHom.congr_arg _ ?_\n  rw [mul_one_div (↑(n.choose x) : ℚ), one_div_mul_one_div]\n  symm\n  rw [div_eq_iff, div_mul_eq_mul_div, one_mul, choose_eq_factorial_div_factorial]\n  · norm_cast\n    rw [cast_div_charZero]\n    apply factorial_mul_factorial_dvd_factorial (mem_range_succ_iff.1 hx)\n  · apply mem_range_succ_iff.1 hx\n  · rintro h\n    apply factorial_ne_zero n\n    rw [cast_eq_zero.1 h]\n\n"}
{"name":"PowerSeries.exp_mul_exp_neg_eq_one","module":"Mathlib.RingTheory.PowerSeries.WellKnown","initialProofState":"A : Type u_1\ninst✝¹ : CommRing A\ninst✝ : Algebra Rat A\n⊢ Eq (HMul.hMul (PowerSeries.exp A) (PowerSeries.evalNegHom (PowerSeries.exp A))) 1","decl":"/-- Shows that $e^{x} * e^{-x} = 1$ -/\ntheorem exp_mul_exp_neg_eq_one [Algebra ℚ A] : exp A * evalNegHom (exp A) = 1 := by\n  convert exp_mul_exp_eq_exp_add (1 : A) (-1) <;> simp\n\n"}
{"name":"PowerSeries.exp_pow_eq_rescale_exp","module":"Mathlib.RingTheory.PowerSeries.WellKnown","initialProofState":"A : Type u_1\ninst✝¹ : CommRing A\ninst✝ : Algebra Rat A\nk : Nat\n⊢ Eq (HPow.hPow (PowerSeries.exp A) k) ((PowerSeries.rescale ↑k) (PowerSeries.exp A))","decl":"/-- Shows that $(e^{X})^k = e^{kX}$. -/\ntheorem exp_pow_eq_rescale_exp [Algebra ℚ A] (k : ℕ) : exp A ^ k = rescale (k : A) (exp A) := by\n  induction' k with k h\n  · simp only [rescale_zero, constantCoeff_exp, Function.comp_apply, map_one, cast_zero, zero_eq,\n      pow_zero (exp A), coe_comp]\n  · simpa only [succ_eq_add_one, cast_add, ← exp_mul_exp_eq_exp_add (k : A), ← h, cast_one,\n    id_apply, rescale_one] using pow_succ (exp A) k\n\n"}
{"name":"PowerSeries.exp_pow_sum","module":"Mathlib.RingTheory.PowerSeries.WellKnown","initialProofState":"A : Type u_1\ninst✝¹ : CommRing A\ninst✝ : Algebra Rat A\nn : Nat\n⊢ Eq ((Finset.range n).sum fun k => HPow.hPow (PowerSeries.exp A) k) (PowerSeries.mk fun p => (Finset.range n).sum fun k => HMul.hMul (HPow.hPow (↑k) p) ((algebraMap Rat A) (Inv.inv ↑p.factorial)))","decl":"/-- Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. -/\ntheorem exp_pow_sum [Algebra ℚ A] (n : ℕ) :\n    ((Finset.range n).sum fun k => exp A ^ k) =\n      PowerSeries.mk fun p => (Finset.range n).sum\n        fun k => (k ^ p : A) * algebraMap ℚ A p.factorial⁻¹ := by\n  simp only [exp_pow_eq_rescale_exp, rescale]\n  ext\n  simp only [one_div, coeff_mk, cast_pow, coe_mk, MonoidHom.coe_mk, OneHom.coe_mk,\n    coeff_exp, factorial, map_sum]\n\n"}
