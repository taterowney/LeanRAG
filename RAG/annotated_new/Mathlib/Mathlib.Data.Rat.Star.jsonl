{"name":"NNRat.addSubmonoid_closure_range_pow","module":"Mathlib.Data.Rat.Star","initialProofState":"n : Nat\nhn₀ : Ne n 0\n⊢ Eq (AddSubmonoid.closure (Set.range fun x => HPow.hPow x n)) Top.top","decl":"@[simp] lemma addSubmonoid_closure_range_pow {n : ℕ} (hn₀ : n ≠ 0) :\n    closure (range fun x : ℚ≥0 ↦ x ^ n) = ⊤ := by\n  refine (eq_top_iff' _).2 fun x ↦ ?_\n  suffices x = (x.num * x.den ^ (n - 1)) • (x.den : ℚ≥0)⁻¹ ^ n by\n    rw [this]\n    exact nsmul_mem (subset_closure <| mem_range_self _) _\n  rw [nsmul_eq_mul]\n  push_cast\n  rw [mul_assoc, pow_sub₀, pow_one, mul_right_comm, ← mul_pow, mul_inv_cancel₀, one_pow, one_mul,\n    ← div_eq_mul_inv, num_div_den]\n  all_goals simp [x.den_pos.ne', Nat.one_le_iff_ne_zero, *]\n\n"}
{"name":"NNRat.addSubmonoid_closure_range_mul_self","module":"Mathlib.Data.Rat.Star","initialProofState":"⊢ Eq (AddSubmonoid.closure (Set.range fun x => HMul.hMul x x)) Top.top","decl":"@[simp] lemma addSubmonoid_closure_range_mul_self : closure (range fun x : ℚ≥0 ↦ x * x) = ⊤ := by\n  simpa only [sq] using addSubmonoid_closure_range_pow two_ne_zero\n\n"}
{"name":"NNRat.instStarOrderedRing","module":"Mathlib.Data.Rat.Star","initialProofState":"⊢ StarOrderedRing NNRat","decl":"instance instStarOrderedRing : StarOrderedRing ℚ≥0 where\n  le_iff a b := by simp [eq_comm, le_iff_exists_nonneg_add (a := a)]\n\n"}
{"name":"Rat.addSubmonoid_closure_range_pow","module":"Mathlib.Data.Rat.Star","initialProofState":"n : Nat\nhn₀ : Ne n 0\nhn : Even n\n⊢ Eq (AddSubmonoid.closure (Set.range fun x => HPow.hPow x n)) (AddSubmonoid.nonneg Rat)","decl":"@[simp] lemma addSubmonoid_closure_range_pow {n : ℕ} (hn₀ : n ≠ 0) (hn : Even n) :\n    closure (range fun x : ℚ ↦ x ^ n) = nonneg _ := by\n  convert (AddMonoidHom.map_mclosure NNRat.coeHom <| range fun x ↦ x ^ n).symm\n  · have (x : ℚ) : ∃ y : ℚ≥0, y ^ n = x ^ n := ⟨x.nnabs, by simp [hn.pow_abs]⟩\n    simp [subset_antisymm_iff, range_subset_iff, this]\n  · ext\n    simp [NNRat.addSubmonoid_closure_range_pow hn₀, NNRat.exists]\n\n"}
{"name":"Rat.addSubmonoid_closure_range_mul_self","module":"Mathlib.Data.Rat.Star","initialProofState":"⊢ Eq (AddSubmonoid.closure (Set.range fun x => HMul.hMul x x)) (AddSubmonoid.nonneg Rat)","decl":"@[simp]\nlemma addSubmonoid_closure_range_mul_self : closure (range fun x : ℚ ↦ x * x) = nonneg _ := by\n  simpa only [sq] using addSubmonoid_closure_range_pow two_ne_zero even_two\n\n"}
{"name":"Rat.instStarOrderedRing","module":"Mathlib.Data.Rat.Star","initialProofState":"⊢ StarOrderedRing Rat","decl":"instance instStarOrderedRing : StarOrderedRing ℚ where\n  le_iff a b := by simp [eq_comm, le_iff_exists_nonneg_add (a := a)]\n\n"}
