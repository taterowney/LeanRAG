{"name":"Equiv.pprodEquivProd_symm_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\nx : Prod α β\n⊢ Eq (Equiv.pprodEquivProd.symm x) { fst := x.1, snd := x.2 }","decl":"/-- `PProd α β` is equivalent to `α × β` -/\n@[simps apply symm_apply]\ndef pprodEquivProd {α β} : PProd α β ≃ α × β where\n  toFun x := (x.1, x.2)\n  invFun x := ⟨x.1, x.2⟩\n  left_inv := fun _ => rfl\n  right_inv := fun _ => rfl\n\n"}
{"name":"Equiv.pprodEquivProd_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\nx : PProd α β\n⊢ Eq (Equiv.pprodEquivProd x) { fst := x.fst, snd := x.snd }","decl":"/-- `PProd α β` is equivalent to `α × β` -/\n@[simps apply symm_apply]\ndef pprodEquivProd {α β} : PProd α β ≃ α × β where\n  toFun x := (x.1, x.2)\n  invFun x := ⟨x.1, x.2⟩\n  left_inv := fun _ => rfl\n  right_inv := fun _ => rfl\n\n"}
{"name":"Equiv.pprodCongr_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_4\nγ : Sort u_7\nδ : Sort u_8\ne₁ : Equiv α β\ne₂ : Equiv γ δ\nx : PProd α γ\n⊢ Eq ((e₁.pprodCongr e₂) x) { fst := e₁ x.fst, snd := e₂ x.snd }","decl":"/-- Product of two equivalences, in terms of `PProd`. If `α ≃ β` and `γ ≃ δ`, then\n`PProd α γ ≃ PProd β δ`. -/\n-- Porting note: in Lean 3 this had `@[congr]`\n@[simps apply]\ndef pprodCongr (e₁ : α ≃ β) (e₂ : γ ≃ δ) : PProd α γ ≃ PProd β δ where\n  toFun x := ⟨e₁ x.1, e₂ x.2⟩\n  invFun x := ⟨e₁.symm x.1, e₂.symm x.2⟩\n  left_inv := fun ⟨x, y⟩ => by simp\n  right_inv := fun ⟨x, y⟩ => by simp\n\n"}
{"name":"Equiv.pprodProd_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α₁ : Sort u_2\nβ₁ : Sort u_5\nα₂ : Type u_9\nβ₂ : Type u_10\nea : Equiv α₁ α₂\neb : Equiv β₁ β₂\na✝ : PProd α₁ β₁\n⊢ Eq ((ea.pprodProd eb) a✝) { fst := ea a✝.fst, snd := eb a✝.snd }","decl":"/-- Combine two equivalences using `PProd` in the domain and `Prod` in the codomain. -/\n@[simps! apply symm_apply]\ndef pprodProd {α₂ β₂} (ea : α₁ ≃ α₂) (eb : β₁ ≃ β₂) :\n    PProd α₁ β₁ ≃ α₂ × β₂ :=\n  (ea.pprodCongr eb).trans pprodEquivProd\n\n"}
{"name":"Equiv.pprodProd_symm_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α₁ : Sort u_2\nβ₁ : Sort u_5\nα₂ : Type u_9\nβ₂ : Type u_10\nea : Equiv α₁ α₂\neb : Equiv β₁ β₂\na✝ : Prod α₂ β₂\n⊢ Eq ((ea.pprodProd eb).symm a✝) ((ea.pprodCongr eb).symm { fst := a✝.1, snd := a✝.2 })","decl":"/-- Combine two equivalences using `PProd` in the domain and `Prod` in the codomain. -/\n@[simps! apply symm_apply]\ndef pprodProd {α₂ β₂} (ea : α₁ ≃ α₂) (eb : β₁ ≃ β₂) :\n    PProd α₁ β₁ ≃ α₂ × β₂ :=\n  (ea.pprodCongr eb).trans pprodEquivProd\n\n"}
{"name":"Equiv.prodPProd_symm_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α₂ : Sort u_3\nβ₂ : Sort u_6\nα₁ : Type u_9\nβ₁ : Type u_10\nea : Equiv α₁ α₂\neb : Equiv β₁ β₂\na✝ : PProd α₂ β₂\n⊢ Eq ((ea.prodPProd eb).symm a✝) { fst := ea.symm a✝.fst, snd := eb.symm a✝.snd }","decl":"/-- Combine two equivalences using `PProd` in the codomain and `Prod` in the domain. -/\n@[simps! apply symm_apply]\ndef prodPProd {α₁ β₁} (ea : α₁ ≃ α₂) (eb : β₁ ≃ β₂) :\n    α₁ × β₁ ≃ PProd α₂ β₂ :=\n  (ea.symm.pprodProd eb.symm).symm\n\n"}
{"name":"Equiv.prodPProd_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α₂ : Sort u_3\nβ₂ : Sort u_6\nα₁ : Type u_9\nβ₁ : Type u_10\nea : Equiv α₁ α₂\neb : Equiv β₁ β₂\na✝ : Prod α₁ β₁\n⊢ Eq ((ea.prodPProd eb) a✝) ((ea.symm.pprodCongr eb.symm).symm { fst := a✝.1, snd := a✝.2 })","decl":"/-- Combine two equivalences using `PProd` in the codomain and `Prod` in the domain. -/\n@[simps! apply symm_apply]\ndef prodPProd {α₁ β₁} (ea : α₁ ≃ α₂) (eb : β₁ ≃ β₂) :\n    α₁ × β₁ ≃ PProd α₂ β₂ :=\n  (ea.symm.pprodProd eb.symm).symm\n\n"}
{"name":"Equiv.pprodEquivProdPLift_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_4\na✝ : PProd α β\n⊢ Eq (Equiv.pprodEquivProdPLift a✝) { fst := Equiv.plift.symm a✝.fst, snd := Equiv.plift.symm a✝.snd }","decl":"/-- `PProd α β` is equivalent to `PLift α × PLift β` -/\n@[simps! apply symm_apply]\ndef pprodEquivProdPLift : PProd α β ≃ PLift α × PLift β :=\n  Equiv.plift.symm.pprodProd Equiv.plift.symm\n\n"}
{"name":"Equiv.pprodEquivProdPLift_symm_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_4\na✝ : Prod (PLift α) (PLift β)\n⊢ Eq (Equiv.pprodEquivProdPLift.symm a✝) ((Equiv.plift.symm.pprodCongr Equiv.plift.symm).symm { fst := a✝.1, snd := a✝.2 })","decl":"/-- `PProd α β` is equivalent to `PLift α × PLift β` -/\n@[simps! apply symm_apply]\ndef pprodEquivProdPLift : PProd α β ≃ PLift α × PLift β :=\n  Equiv.plift.symm.pprodProd Equiv.plift.symm\n\n"}
{"name":"Equiv.prodCongr_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α₁ : Type u_9\nα₂ : Type u_10\nβ₁ : Type u_11\nβ₂ : Type u_12\ne₁ : Equiv α₁ α₂\ne₂ : Equiv β₁ β₂\n⊢ Eq (⇑(e₁.prodCongr e₂)) (Prod.map ⇑e₁ ⇑e₂)","decl":"/-- Product of two equivalences. If `α₁ ≃ α₂` and `β₁ ≃ β₂`, then `α₁ × β₁ ≃ α₂ × β₂`. This is\n`Prod.map` as an equivalence. -/\n-- Porting note: in Lean 3 there was also a @[congr] tag\n@[simps (config := .asFn) apply]\ndef prodCongr {α₁ α₂ β₁ β₂} (e₁ : α₁ ≃ α₂) (e₂ : β₁ ≃ β₂) : α₁ × β₁ ≃ α₂ × β₂ :=\n  ⟨Prod.map e₁ e₂, Prod.map e₁.symm e₂.symm, fun ⟨a, b⟩ => by simp, fun ⟨a, b⟩ => by simp⟩\n\n"}
{"name":"Equiv.prodCongr_symm","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α₁ : Type u_9\nα₂ : Type u_10\nβ₁ : Type u_11\nβ₂ : Type u_12\ne₁ : Equiv α₁ α₂\ne₂ : Equiv β₁ β₂\n⊢ Eq (e₁.prodCongr e₂).symm (e₁.symm.prodCongr e₂.symm)","decl":"@[simp]\ntheorem prodCongr_symm {α₁ α₂ β₁ β₂} (e₁ : α₁ ≃ α₂) (e₂ : β₁ ≃ β₂) :\n    (prodCongr e₁ e₂).symm = prodCongr e₁.symm e₂.symm :=\n  rfl\n\n"}
{"name":"Equiv.coe_prodComm","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\n⊢ Eq (⇑(Equiv.prodComm α β)) Prod.swap","decl":"@[simp]\ntheorem coe_prodComm (α β) : (⇑(prodComm α β) : α × β → β × α) = Prod.swap :=\n  rfl\n\n"}
{"name":"Equiv.prodComm_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\nx : Prod α β\n⊢ Eq ((Equiv.prodComm α β) x) x.swap","decl":"@[simp]\ntheorem prodComm_apply {α β} (x : α × β) : prodComm α β x = x.swap :=\n  rfl\n\n"}
{"name":"Equiv.prodComm_symm","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\n⊢ Eq (Equiv.prodComm α β).symm (Equiv.prodComm β α)","decl":"@[simp]\ntheorem prodComm_symm (α β) : (prodComm α β).symm = prodComm β α :=\n  rfl\n\n"}
{"name":"Equiv.prodAssoc_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\nγ : Type u_11\np : Prod (Prod α β) γ\n⊢ Eq ((Equiv.prodAssoc α β γ) p) { fst := p.1.1, snd := { fst := p.1.2, snd := p.2 } }","decl":"/-- Type product is associative up to an equivalence. -/\n@[simps]\ndef prodAssoc (α β γ) : (α × β) × γ ≃ α × β × γ :=\n  ⟨fun p => (p.1.1, p.1.2, p.2), fun p => ((p.1, p.2.1), p.2.2), fun ⟨⟨_, _⟩, _⟩ => rfl,\n    fun ⟨_, ⟨_, _⟩⟩ => rfl⟩\n\n"}
{"name":"Equiv.prodAssoc_symm_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\nγ : Type u_11\np : Prod α (Prod β γ)\n⊢ Eq ((Equiv.prodAssoc α β γ).symm p) { fst := { fst := p.1, snd := p.2.1 }, snd := p.2.2 }","decl":"/-- Type product is associative up to an equivalence. -/\n@[simps]\ndef prodAssoc (α β γ) : (α × β) × γ ≃ α × β × γ :=\n  ⟨fun p => (p.1.1, p.1.2, p.2), fun p => ((p.1, p.2.1), p.2.2), fun ⟨⟨_, _⟩, _⟩ => rfl,\n    fun ⟨_, ⟨_, _⟩⟩ => rfl⟩\n\n"}
{"name":"Equiv.prodProdProdComm_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\nγ : Type u_11\nδ : Type u_12\nabcd : Prod (Prod α β) (Prod γ δ)\n⊢ Eq ((Equiv.prodProdProdComm α β γ δ) abcd) { fst := { fst := abcd.1.1, snd := abcd.2.1 }, snd := { fst := abcd.1.2, snd := abcd.2.2 } }","decl":"/-- Four-way commutativity of `prod`. The name matches `mul_mul_mul_comm`. -/\n@[simps apply]\ndef prodProdProdComm (α β γ δ) : (α × β) × γ × δ ≃ (α × γ) × β × δ where\n  toFun abcd := ((abcd.1.1, abcd.2.1), (abcd.1.2, abcd.2.2))\n  invFun acbd := ((acbd.1.1, acbd.2.1), (acbd.1.2, acbd.2.2))\n  left_inv := fun ⟨⟨_a, _b⟩, ⟨_c, _d⟩⟩ => rfl\n  right_inv := fun ⟨⟨_a, _c⟩, ⟨_b, _d⟩⟩ => rfl\n\n"}
{"name":"Equiv.prodProdProdComm_symm","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\nγ : Type u_11\nδ : Type u_12\n⊢ Eq (Equiv.prodProdProdComm α β γ δ).symm (Equiv.prodProdProdComm α γ β δ)","decl":"@[simp]\ntheorem prodProdProdComm_symm (α β γ δ) :\n    (prodProdProdComm α β γ δ).symm = prodProdProdComm α γ β δ :=\n  rfl\n\n"}
{"name":"Equiv.curry_symm_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\nγ : Sort u_11\n⊢ Eq (⇑(Equiv.curry α β γ).symm) Function.uncurry","decl":"/-- `γ`-valued functions on `α × β` are equivalent to functions `α → β → γ`. -/\n@[simps (config := .asFn)]\ndef curry (α β γ) : (α × β → γ) ≃ (α → β → γ) where\n  toFun := Function.curry\n  invFun := uncurry\n  left_inv := uncurry_curry\n  right_inv := curry_uncurry\n\n"}
{"name":"Equiv.curry_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\nγ : Sort u_11\n⊢ Eq (⇑(Equiv.curry α β γ)) Function.curry","decl":"/-- `γ`-valued functions on `α × β` are equivalent to functions `α → β → γ`. -/\n@[simps (config := .asFn)]\ndef curry (α β γ) : (α × β → γ) ≃ (α → β → γ) where\n  toFun := Function.curry\n  invFun := uncurry\n  left_inv := uncurry_curry\n  right_inv := curry_uncurry\n\n"}
{"name":"Equiv.prodPUnit_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\np : Prod α PUnit.{u_10 + 1}\n⊢ Eq ((Equiv.prodPUnit α) p) p.1","decl":"/-- `PUnit` is a right identity for type product up to an equivalence. -/\n@[simps]\ndef prodPUnit (α) : α × PUnit ≃ α :=\n  ⟨fun p => p.1, fun a => (a, PUnit.unit), fun ⟨_, PUnit.unit⟩ => rfl, fun _ => rfl⟩\n\n"}
{"name":"Equiv.prodPUnit_symm_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\na : α\n⊢ Eq ((Equiv.prodPUnit α).symm a) { fst := a, snd := PUnit.unit }","decl":"/-- `PUnit` is a right identity for type product up to an equivalence. -/\n@[simps]\ndef prodPUnit (α) : α × PUnit ≃ α :=\n  ⟨fun p => p.1, fun a => (a, PUnit.unit), fun ⟨_, PUnit.unit⟩ => rfl, fun _ => rfl⟩\n\n"}
{"name":"Equiv.punitProd_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\na✝ : Prod PUnit.{u_10 + 1} α\n⊢ Eq ((Equiv.punitProd α) a✝) a✝.2","decl":"/-- `PUnit` is a left identity for type product up to an equivalence. -/\n@[simps!]\ndef punitProd (α) : PUnit × α ≃ α :=\n  calc\n    PUnit × α ≃ α × PUnit := prodComm _ _\n    _ ≃ α := prodPUnit _\n\n"}
{"name":"Equiv.punitProd_symm_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\na✝ : α\n⊢ Eq ((Equiv.punitProd α).symm a✝) { fst := PUnit.unit, snd := a✝ }","decl":"/-- `PUnit` is a left identity for type product up to an equivalence. -/\n@[simps!]\ndef punitProd (α) : PUnit × α ≃ α :=\n  calc\n    PUnit × α ≃ α × PUnit := prodComm _ _\n    _ ≃ α := prodPUnit _\n\n"}
{"name":"Equiv.sigmaPUnit_symm_apply_fst","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\na : α\n⊢ Eq ((Equiv.sigmaPUnit α).symm a).fst a","decl":"/-- `PUnit` is a right identity for dependent type product up to an equivalence. -/\n@[simps]\ndef sigmaPUnit (α) : (_ : α) × PUnit ≃ α :=\n  ⟨fun p => p.1, fun a => ⟨a, PUnit.unit⟩, fun ⟨_, PUnit.unit⟩ => rfl, fun _ => rfl⟩\n\n"}
{"name":"Equiv.sigmaPUnit_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\np : Sigma fun x => PUnit.{u_10 + 1}\n⊢ Eq ((Equiv.sigmaPUnit α) p) p.fst","decl":"/-- `PUnit` is a right identity for dependent type product up to an equivalence. -/\n@[simps]\ndef sigmaPUnit (α) : (_ : α) × PUnit ≃ α :=\n  ⟨fun p => p.1, fun a => ⟨a, PUnit.unit⟩, fun ⟨_, PUnit.unit⟩ => rfl, fun _ => rfl⟩\n\n"}
{"name":"Equiv.sigmaPUnit_symm_apply_snd","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\na : α\n⊢ Eq ((Equiv.sigmaPUnit α).symm a).snd PUnit.unit","decl":"/-- `PUnit` is a right identity for dependent type product up to an equivalence. -/\n@[simps]\ndef sigmaPUnit (α) : (_ : α) × PUnit ≃ α :=\n  ⟨fun p => p.1, fun a => ⟨a, PUnit.unit⟩, fun ⟨_, PUnit.unit⟩ => rfl, fun _ => rfl⟩\n\n"}
{"name":"Equiv.coe_prodUnique","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\ninst✝ : Unique β\n⊢ Eq (⇑(Equiv.prodUnique α β)) Prod.fst","decl":"@[simp]\ntheorem coe_prodUnique {α β} [Unique β] : (⇑(prodUnique α β) : α × β → α) = Prod.fst :=\n  rfl\n\n"}
{"name":"Equiv.prodUnique_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\ninst✝ : Unique β\nx : Prod α β\n⊢ Eq ((Equiv.prodUnique α β) x) x.1","decl":"theorem prodUnique_apply {α β} [Unique β] (x : α × β) : prodUnique α β x = x.1 :=\n  rfl\n\n"}
{"name":"Equiv.prodUnique_symm_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\ninst✝ : Unique β\nx : α\n⊢ Eq ((Equiv.prodUnique α β).symm x) { fst := x, snd := Inhabited.default }","decl":"@[simp]\ntheorem prodUnique_symm_apply {α β} [Unique β] (x : α) : (prodUnique α β).symm x = (x, default) :=\n  rfl\n\n"}
{"name":"Equiv.coe_uniqueProd","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\ninst✝ : Unique β\n⊢ Eq (⇑(Equiv.uniqueProd α β)) Prod.snd","decl":"@[simp]\ntheorem coe_uniqueProd {α β} [Unique β] : (⇑(uniqueProd α β) : β × α → α) = Prod.snd :=\n  rfl\n\n"}
{"name":"Equiv.uniqueProd_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\ninst✝ : Unique β\nx : Prod β α\n⊢ Eq ((Equiv.uniqueProd α β) x) x.2","decl":"theorem uniqueProd_apply {α β} [Unique β] (x : β × α) : uniqueProd α β x = x.2 :=\n  rfl\n\n"}
{"name":"Equiv.uniqueProd_symm_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\ninst✝ : Unique β\nx : α\n⊢ Eq ((Equiv.uniqueProd α β).symm x) { fst := Inhabited.default, snd := x }","decl":"@[simp]\ntheorem uniqueProd_symm_apply {α β} [Unique β] (x : α) :\n    (uniqueProd α β).symm x = (default, x) :=\n  rfl\n\n"}
{"name":"Equiv.coe_sigmaUnique","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_10\nβ : α → Type u_9\ninst✝ : (a : α) → Unique (β a)\n⊢ Eq (⇑(Equiv.sigmaUnique α β)) Sigma.fst","decl":"@[simp]\ntheorem coe_sigmaUnique {α} {β : α → Type*} [∀ a, Unique (β a)] :\n    (⇑(sigmaUnique α β) : (a : α) × (β a) → α) = Sigma.fst :=\n  rfl\n\n"}
{"name":"Equiv.sigmaUnique_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_10\nβ : α → Type u_9\ninst✝ : (a : α) → Unique (β a)\nx : Sigma fun a => β a\n⊢ Eq ((Equiv.sigmaUnique α β) x) x.fst","decl":"theorem sigmaUnique_apply {α} {β : α → Type*} [∀ a, Unique (β a)] (x : (a : α) × β a) :\n    sigmaUnique α β x = x.1 :=\n  rfl\n\n"}
{"name":"Equiv.sigmaUnique_symm_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_10\nβ : α → Type u_9\ninst✝ : (a : α) → Unique (β a)\nx : α\n⊢ Eq ((Equiv.sigmaUnique α β).symm x) ⟨x, Inhabited.default⟩","decl":"@[simp]\ntheorem sigmaUnique_symm_apply {α} {β : α → Type*} [∀ a, Unique (β a)] (x : α) :\n    (sigmaUnique α β).symm x = ⟨x, default⟩ :=\n  rfl\n\n"}
{"name":"Equiv.uniqueSigma_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_10\nβ : α → Type u_9\ninst✝ : Unique α\nx : Sigma fun a => β a\n⊢ Eq ((Equiv.uniqueSigma β) x) (Eq.rec x.snd ⋯)","decl":"theorem uniqueSigma_apply {α} {β : α → Type*} [Unique α] (x : (a : α) × β a) :\n    uniqueSigma β x = (Unique.eq_default _).rec x.2 :=\n  rfl\n\n"}
{"name":"Equiv.uniqueSigma_symm_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_10\nβ : α → Type u_9\ninst✝ : Unique α\ny : β Inhabited.default\n⊢ Eq ((Equiv.uniqueSigma β).symm y) ⟨Inhabited.default, y⟩","decl":"@[simp]\ntheorem uniqueSigma_symm_apply {α} {β : α → Type*} [Unique α] (y : β default) :\n    (uniqueSigma β).symm y = ⟨default, y⟩ :=\n  rfl\n\n"}
{"name":"Equiv.sumCongr_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α₁ : Type u_9\nα₂ : Type u_10\nβ₁ : Type u_11\nβ₂ : Type u_12\nea : Equiv α₁ α₂\neb : Equiv β₁ β₂\na✝ : Sum α₁ β₁\n⊢ Eq ((ea.sumCongr eb) a✝) (Sum.map (⇑ea) (⇑eb) a✝)","decl":"/-- If `α ≃ α'` and `β ≃ β'`, then `α ⊕ β ≃ α' ⊕ β'`. This is `Sum.map` as an equivalence. -/\n@[simps apply]\ndef sumCongr {α₁ α₂ β₁ β₂} (ea : α₁ ≃ α₂) (eb : β₁ ≃ β₂) : α₁ ⊕ β₁ ≃ α₂ ⊕ β₂ :=\n  ⟨Sum.map ea eb, Sum.map ea.symm eb.symm, fun x => by simp, fun x => by simp⟩\n\n"}
{"name":"Equiv.sumCongr_trans","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α₁ : Type u_9\nα₂ : Type u_10\nβ₁ : Type u_11\nβ₂ : Type u_12\nγ₁ : Type u_13\nγ₂ : Type u_14\ne : Equiv α₁ β₁\nf : Equiv α₂ β₂\ng : Equiv β₁ γ₁\nh : Equiv β₂ γ₂\n⊢ Eq ((e.sumCongr f).trans (g.sumCongr h)) ((e.trans g).sumCongr (f.trans h))","decl":"@[simp]\ntheorem sumCongr_trans {α₁ α₂ β₁ β₂ γ₁ γ₂} (e : α₁ ≃ β₁) (f : α₂ ≃ β₂) (g : β₁ ≃ γ₁) (h : β₂ ≃ γ₂) :\n    (Equiv.sumCongr e f).trans (Equiv.sumCongr g h) = Equiv.sumCongr (e.trans g) (f.trans h) := by\n  ext i\n  cases i <;> rfl\n\n"}
{"name":"Equiv.sumCongr_symm","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\nγ : Type u_11\nδ : Type u_12\ne : Equiv α β\nf : Equiv γ δ\n⊢ Eq (e.sumCongr f).symm (e.symm.sumCongr f.symm)","decl":"@[simp]\ntheorem sumCongr_symm {α β γ δ} (e : α ≃ β) (f : γ ≃ δ) :\n    (Equiv.sumCongr e f).symm = Equiv.sumCongr e.symm f.symm :=\n  rfl\n\n"}
{"name":"Equiv.sumCongr_refl","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\n⊢ Eq ((Equiv.refl α).sumCongr (Equiv.refl β)) (Equiv.refl (Sum α β))","decl":"@[simp]\ntheorem sumCongr_refl {α β} :\n    Equiv.sumCongr (Equiv.refl α) (Equiv.refl β) = Equiv.refl (α ⊕ β) := by\n  ext i\n  cases i <;> rfl\n\n"}
{"name":"Equiv.Perm.sumCongr_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\nea : Equiv.Perm α\neb : Equiv.Perm β\nx : Sum α β\n⊢ Eq ((ea.sumCongr eb) x) (Sum.map (⇑ea) (⇑eb) x)","decl":"@[simp]\ntheorem sumCongr_apply {α β} (ea : Equiv.Perm α) (eb : Equiv.Perm β) (x : α ⊕ β) :\n    sumCongr ea eb x = Sum.map (⇑ea) (⇑eb) x :=\n  Equiv.sumCongr_apply ea eb x\n\n-- Porting note: it seems the general theorem about `Equiv` is now applied, so there's no need\n-- to have this version also have `@[simp]`. Similarly for below.\n"}
{"name":"Equiv.Perm.sumCongr_trans","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\ne : Equiv.Perm α\nf : Equiv.Perm β\ng : Equiv.Perm α\nh : Equiv.Perm β\n⊢ Eq (Equiv.trans (e.sumCongr f) (g.sumCongr h)) (Equiv.Perm.sumCongr (Equiv.trans e g) (Equiv.trans f h))","decl":"theorem sumCongr_trans {α β} (e : Equiv.Perm α) (f : Equiv.Perm β) (g : Equiv.Perm α)\n    (h : Equiv.Perm β) : (sumCongr e f).trans (sumCongr g h) = sumCongr (e.trans g) (f.trans h) :=\n  Equiv.sumCongr_trans e f g h\n\n"}
{"name":"Equiv.Perm.sumCongr_symm","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\ne : Equiv.Perm α\nf : Equiv.Perm β\n⊢ Eq (Equiv.symm (e.sumCongr f)) (Equiv.Perm.sumCongr (Equiv.symm e) (Equiv.symm f))","decl":"theorem sumCongr_symm {α β} (e : Equiv.Perm α) (f : Equiv.Perm β) :\n    (sumCongr e f).symm = sumCongr e.symm f.symm :=\n  Equiv.sumCongr_symm e f\n\n"}
{"name":"Equiv.Perm.sumCongr_refl","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\n⊢ Eq (Equiv.Perm.sumCongr (Equiv.refl α) (Equiv.refl β)) (Equiv.refl (Sum α β))","decl":"theorem sumCongr_refl {α β} : sumCongr (Equiv.refl α) (Equiv.refl β) = Equiv.refl (α ⊕ β) :=\n  Equiv.sumCongr_refl\n\n"}
{"name":"Equiv.sumComm_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\n⊢ Eq (⇑(Equiv.sumComm α β)) Sum.swap","decl":"/-- Sum of types is commutative up to an equivalence. This is `Sum.swap` as an equivalence. -/\n@[simps (config := .asFn) apply]\ndef sumComm (α β) : α ⊕ β ≃ β ⊕ α :=\n  ⟨Sum.swap, Sum.swap, Sum.swap_swap, Sum.swap_swap⟩\n\n"}
{"name":"Equiv.sumComm_symm","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\n⊢ Eq (Equiv.sumComm α β).symm (Equiv.sumComm β α)","decl":"@[simp]\ntheorem sumComm_symm (α β) : (sumComm α β).symm = sumComm β α :=\n  rfl\n\n"}
{"name":"Equiv.sumAssoc_apply_inl_inl","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\nγ : Type u_11\na : α\n⊢ Eq ((Equiv.sumAssoc α β γ) (Sum.inl (Sum.inl a))) (Sum.inl a)","decl":"@[simp]\ntheorem sumAssoc_apply_inl_inl {α β γ} (a) : sumAssoc α β γ (inl (inl a)) = inl a :=\n  rfl\n\n"}
{"name":"Equiv.sumAssoc_apply_inl_inr","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\nγ : Type u_11\nb : β\n⊢ Eq ((Equiv.sumAssoc α β γ) (Sum.inl (Sum.inr b))) (Sum.inr (Sum.inl b))","decl":"@[simp]\ntheorem sumAssoc_apply_inl_inr {α β γ} (b) : sumAssoc α β γ (inl (inr b)) = inr (inl b) :=\n  rfl\n\n"}
{"name":"Equiv.sumAssoc_apply_inr","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\nγ : Type u_11\nc : γ\n⊢ Eq ((Equiv.sumAssoc α β γ) (Sum.inr c)) (Sum.inr (Sum.inr c))","decl":"@[simp]\ntheorem sumAssoc_apply_inr {α β γ} (c) : sumAssoc α β γ (inr c) = inr (inr c) :=\n  rfl\n\n"}
{"name":"Equiv.sumAssoc_symm_apply_inl","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\nγ : Type u_11\na : α\n⊢ Eq ((Equiv.sumAssoc α β γ).symm (Sum.inl a)) (Sum.inl (Sum.inl a))","decl":"@[simp]\ntheorem sumAssoc_symm_apply_inl {α β γ} (a) : (sumAssoc α β γ).symm (inl a) = inl (inl a) :=\n  rfl\n\n"}
{"name":"Equiv.sumAssoc_symm_apply_inr_inl","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\nγ : Type u_11\nb : β\n⊢ Eq ((Equiv.sumAssoc α β γ).symm (Sum.inr (Sum.inl b))) (Sum.inl (Sum.inr b))","decl":"@[simp]\ntheorem sumAssoc_symm_apply_inr_inl {α β γ} (b) :\n    (sumAssoc α β γ).symm (inr (inl b)) = inl (inr b) :=\n  rfl\n\n"}
{"name":"Equiv.sumAssoc_symm_apply_inr_inr","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\nγ : Type u_11\nc : γ\n⊢ Eq ((Equiv.sumAssoc α β γ).symm (Sum.inr (Sum.inr c))) (Sum.inr c)","decl":"@[simp]\ntheorem sumAssoc_symm_apply_inr_inr {α β γ} (c) : (sumAssoc α β γ).symm (inr (inr c)) = inr c :=\n  rfl\n\n"}
{"name":"Equiv.sumSumSumComm_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\nγ : Type u_11\nδ : Type u_12\na✝ : Sum (Sum α β) (Sum γ δ)\n⊢ Eq ((Equiv.sumSumSumComm α β γ δ) a✝) (Function.comp (⇑(Equiv.sumAssoc (Sum α γ) β δ)) (Function.comp (Sum.map (⇑(Equiv.sumAssoc α γ β).symm) id) (Function.comp (Sum.map (Sum.map id ⇑(Equiv.sumComm β γ)) id) (Function.comp (Sum.map (⇑(Equiv.sumAssoc α β γ)) id) ⇑(Equiv.sumAssoc (Sum α β) γ δ).symm))) a✝)","decl":"/-- Four-way commutativity of `sum`. The name matches `add_add_add_comm`. -/\n@[simps apply]\ndef sumSumSumComm (α β γ δ) : (α ⊕ β) ⊕ γ ⊕ δ ≃ (α ⊕ γ) ⊕ β ⊕ δ where\n  toFun :=\n    (sumAssoc (α ⊕ γ) β δ) ∘ (Sum.map (sumAssoc α γ β).symm (@id δ))\n      ∘ (Sum.map (Sum.map (@id α) (sumComm β γ)) (@id δ))\n      ∘ (Sum.map (sumAssoc α β γ) (@id δ))\n      ∘ (sumAssoc (α ⊕ β) γ δ).symm\n  invFun :=\n    (sumAssoc (α ⊕ β) γ δ) ∘ (Sum.map (sumAssoc α β γ).symm (@id δ))\n      ∘ (Sum.map (Sum.map (@id α) (sumComm β γ).symm) (@id δ))\n      ∘ (Sum.map (sumAssoc α γ β) (@id δ))\n      ∘ (sumAssoc (α ⊕ γ) β δ).symm\n  left_inv x := by rcases x with ((a | b) | (c | d)) <;> simp\n  right_inv x := by rcases x with ((a | c) | (b | d)) <;> simp\n\n"}
{"name":"Equiv.sumSumSumComm_symm","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\nγ : Type u_11\nδ : Type u_12\n⊢ Eq (Equiv.sumSumSumComm α β γ δ).symm (Equiv.sumSumSumComm α γ β δ)","decl":"@[simp]\ntheorem sumSumSumComm_symm (α β γ δ) : (sumSumSumComm α β γ δ).symm = sumSumSumComm α γ β δ :=\n  rfl\n\n"}
{"name":"Equiv.sumEmpty_symm_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\ninst✝ : IsEmpty β\nval : α\n⊢ Eq ((Equiv.sumEmpty α β).symm val) (Sum.inl val)","decl":"/-- Sum with `IsEmpty` is equivalent to the original type. -/\n@[simps symm_apply]\ndef sumEmpty (α β) [IsEmpty β] : α ⊕ β ≃ α where\n  toFun := Sum.elim id isEmptyElim\n  invFun := inl\n  left_inv s := by\n    rcases s with (_ | x)\n    · rfl\n    · exact isEmptyElim x\n  right_inv _ := rfl\n\n"}
{"name":"Equiv.sumEmpty_apply_inl","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\ninst✝ : IsEmpty β\na : α\n⊢ Eq ((Equiv.sumEmpty α β) (Sum.inl a)) a","decl":"@[simp]\ntheorem sumEmpty_apply_inl {α β} [IsEmpty β] (a : α) : sumEmpty α β (Sum.inl a) = a :=\n  rfl\n\n"}
{"name":"Equiv.emptySum_symm_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\ninst✝ : IsEmpty α\na✝ : β\n⊢ Eq ((Equiv.emptySum α β).symm a✝) (Sum.inr a✝)","decl":"/-- The sum of `IsEmpty` with any type is equivalent to that type. -/\n@[simps! symm_apply]\ndef emptySum (α β) [IsEmpty α] : α ⊕ β ≃ β :=\n  (sumComm _ _).trans <| sumEmpty _ _\n\n"}
{"name":"Equiv.emptySum_apply_inr","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\ninst✝ : IsEmpty α\nb : β\n⊢ Eq ((Equiv.emptySum α β) (Sum.inr b)) b","decl":"@[simp]\ntheorem emptySum_apply_inr {α β} [IsEmpty α] (b : β) : emptySum α β (Sum.inr b) = b :=\n  rfl\n\n"}
{"name":"Equiv.optionEquivSumPUnit_none","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\n⊢ Eq ((Equiv.optionEquivSumPUnit α) Option.none) (Sum.inr PUnit.unit)","decl":"@[simp]\ntheorem optionEquivSumPUnit_none {α} : optionEquivSumPUnit α none = Sum.inr PUnit.unit :=\n  rfl\n\n"}
{"name":"Equiv.optionEquivSumPUnit_some","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\na : α\n⊢ Eq ((Equiv.optionEquivSumPUnit α) (Option.some a)) (Sum.inl a)","decl":"@[simp]\ntheorem optionEquivSumPUnit_some {α} (a) : optionEquivSumPUnit α (some a) = Sum.inl a :=\n  rfl\n\n"}
{"name":"Equiv.optionEquivSumPUnit_coe","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\na : α\n⊢ Eq ((Equiv.optionEquivSumPUnit α) (Option.some a)) (Sum.inl a)","decl":"@[simp]\ntheorem optionEquivSumPUnit_coe {α} (a : α) : optionEquivSumPUnit α a = Sum.inl a :=\n  rfl\n\n"}
{"name":"Equiv.optionEquivSumPUnit_symm_inl","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\na : α\n⊢ Eq ((Equiv.optionEquivSumPUnit α).symm (Sum.inl a)) (Option.some a)","decl":"@[simp]\ntheorem optionEquivSumPUnit_symm_inl {α} (a) : (optionEquivSumPUnit α).symm (Sum.inl a) = a :=\n  rfl\n\n"}
{"name":"Equiv.optionEquivSumPUnit_symm_inr","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\na : PUnit.{u_10 + 1}\n⊢ Eq ((Equiv.optionEquivSumPUnit α).symm (Sum.inr a)) Option.none","decl":"@[simp]\ntheorem optionEquivSumPUnit_symm_inr {α} (a) : (optionEquivSumPUnit α).symm (Sum.inr a) = none :=\n  rfl\n\n"}
{"name":"Equiv.optionIsSomeEquiv_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\no : Subtype fun x => Eq x.isSome Bool.true\n⊢ Eq ((Equiv.optionIsSomeEquiv α) o) ((↑o).get ⋯)","decl":"/-- The set of `x : Option α` such that `isSome x` is equivalent to `α`. -/\n@[simps]\ndef optionIsSomeEquiv (α) : { x : Option α // x.isSome } ≃ α where\n  toFun o := Option.get _ o.2\n  invFun x := ⟨some x, rfl⟩\n  left_inv _ := Subtype.eq <| Option.some_get _\n  right_inv _ := Option.get_some _ _\n\n"}
{"name":"Equiv.optionIsSomeEquiv_symm_apply_coe","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\nx : α\n⊢ Eq (↑((Equiv.optionIsSomeEquiv α).symm x)) (Option.some x)","decl":"/-- The set of `x : Option α` such that `isSome x` is equivalent to `α`. -/\n@[simps]\ndef optionIsSomeEquiv (α) : { x : Option α // x.isSome } ≃ α where\n  toFun o := Option.get _ o.2\n  invFun x := ⟨some x, rfl⟩\n  left_inv _ := Subtype.eq <| Option.some_get _\n  right_inv _ := Option.get_some _ _\n\n"}
{"name":"Equiv.piOptionEquivProd_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_10\nβ : Option α → Type u_9\nf : (a : Option α) → β a\n⊢ Eq (Equiv.piOptionEquivProd f) { fst := f Option.none, snd := fun a => f (Option.some a) }","decl":"/-- The product over `Option α` of `β a` is the binary product of the\nproduct over `α` of `β (some α)` and `β none` -/\n@[simps]\ndef piOptionEquivProd {α} {β : Option α → Type*} :\n    (∀ a : Option α, β a) ≃ β none × ∀ a : α, β (some a) where\n  toFun f := (f none, fun a => f (some a))\n  invFun x a := Option.casesOn a x.fst x.snd\n  left_inv f := funext fun a => by cases a <;> rfl\n  right_inv x := by simp\n\n"}
{"name":"Equiv.piOptionEquivProd_symm_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_10\nβ : Option α → Type u_9\nx : Prod (β Option.none) ((a : α) → β (Option.some a))\na : Option α\n⊢ Eq (Equiv.piOptionEquivProd.symm x a) (Option.casesOn a x.1 x.2)","decl":"/-- The product over `Option α` of `β a` is the binary product of the\nproduct over `α` of `β (some α)` and `β none` -/\n@[simps]\ndef piOptionEquivProd {α} {β : Option α → Type*} :\n    (∀ a : Option α, β a) ≃ β none × ∀ a : α, β (some a) where\n  toFun f := (f none, fun a => f (some a))\n  invFun x a := Option.casesOn a x.fst x.snd\n  left_inv f := funext fun a => by cases a <;> rfl\n  right_inv x := by simp\n\n"}
{"name":"Equiv.sigmaFiberEquiv_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\nf : α → β\nx : Sigma fun y => Subtype fun x => Eq (f x) y\n⊢ Eq ((Equiv.sigmaFiberEquiv f) x) ↑x.snd","decl":"/-- `sigmaFiberEquiv f` for `f : α → β` is the natural equivalence between\nthe type of all fibres of `f` and the total space `α`. -/\n@[simps]\ndef sigmaFiberEquiv {α β : Type*} (f : α → β) : (Σ y : β, { x // f x = y }) ≃ α :=\n  ⟨fun x => ↑x.2, fun x => ⟨f x, x, rfl⟩, fun ⟨_, _, rfl⟩ => rfl, fun _ => rfl⟩\n\n"}
{"name":"Equiv.sigmaFiberEquiv_symm_apply_snd_coe","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\nf : α → β\nx : α\n⊢ Eq (↑((Equiv.sigmaFiberEquiv f).symm x).snd) x","decl":"/-- `sigmaFiberEquiv f` for `f : α → β` is the natural equivalence between\nthe type of all fibres of `f` and the total space `α`. -/\n@[simps]\ndef sigmaFiberEquiv {α β : Type*} (f : α → β) : (Σ y : β, { x // f x = y }) ≃ α :=\n  ⟨fun x => ↑x.2, fun x => ⟨f x, x, rfl⟩, fun ⟨_, _, rfl⟩ => rfl, fun _ => rfl⟩\n\n"}
{"name":"Equiv.sigmaFiberEquiv_symm_apply_fst","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\nf : α → β\nx : α\n⊢ Eq ((Equiv.sigmaFiberEquiv f).symm x).fst (f x)","decl":"/-- `sigmaFiberEquiv f` for `f : α → β` is the natural equivalence between\nthe type of all fibres of `f` and the total space `α`. -/\n@[simps]\ndef sigmaFiberEquiv {α β : Type*} (f : α → β) : (Σ y : β, { x // f x = y }) ≃ α :=\n  ⟨fun x => ↑x.2, fun x => ⟨f x, x, rfl⟩, fun ⟨_, _, rfl⟩ => rfl, fun _ => rfl⟩\n\n"}
{"name":"Equiv.sumCompl_apply_inl","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\np : α → Prop\ninst✝ : DecidablePred p\nx : Subtype fun a => p a\n⊢ Eq ((Equiv.sumCompl p) (Sum.inl x)) ↑x","decl":"@[simp]\ntheorem sumCompl_apply_inl {α} (p : α → Prop) [DecidablePred p] (x : { a // p a }) :\n    sumCompl p (Sum.inl x) = x :=\n  rfl\n\n"}
{"name":"Equiv.sumCompl_apply_inr","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\np : α → Prop\ninst✝ : DecidablePred p\nx : Subtype fun a => Not (p a)\n⊢ Eq ((Equiv.sumCompl p) (Sum.inr x)) ↑x","decl":"@[simp]\ntheorem sumCompl_apply_inr {α} (p : α → Prop) [DecidablePred p] (x : { a // ¬p a }) :\n    sumCompl p (Sum.inr x) = x :=\n  rfl\n\n"}
{"name":"Equiv.sumCompl_apply_symm_of_pos","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\np : α → Prop\ninst✝ : DecidablePred p\na : α\nh : p a\n⊢ Eq ((Equiv.sumCompl p).symm a) (Sum.inl ⟨a, h⟩)","decl":"@[simp]\ntheorem sumCompl_apply_symm_of_pos {α} (p : α → Prop) [DecidablePred p] (a : α) (h : p a) :\n    (sumCompl p).symm a = Sum.inl ⟨a, h⟩ :=\n  dif_pos h\n\n"}
{"name":"Equiv.sumCompl_apply_symm_of_neg","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\np : α → Prop\ninst✝ : DecidablePred p\na : α\nh : Not (p a)\n⊢ Eq ((Equiv.sumCompl p).symm a) (Sum.inr ⟨a, h⟩)","decl":"@[simp]\ntheorem sumCompl_apply_symm_of_neg {α} (p : α → Prop) [DecidablePred p] (a : α) (h : ¬p a) :\n    (sumCompl p).symm a = Sum.inr ⟨a, h⟩ :=\n  dif_neg h\n\n"}
{"name":"Equiv.Perm.subtypeCongr.apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"ε : Type u_9\np : ε → Prop\ninst✝ : DecidablePred p\nep : Equiv.Perm (Subtype fun a => p a)\nen : Equiv.Perm (Subtype fun a => Not (p a))\na : ε\n⊢ Eq ((ep.subtypeCongr en) a) (dite (p a) (fun h => ↑(ep ⟨a, h⟩)) fun h => ↑(en ⟨a, h⟩))","decl":"theorem Perm.subtypeCongr.apply (a : ε) : ep.subtypeCongr en a =\n    if h : p a then (ep ⟨a, h⟩ : ε) else en ⟨a, h⟩ := by\n  by_cases h : p a <;> simp [Perm.subtypeCongr, h]\n\n"}
{"name":"Equiv.Perm.subtypeCongr.left_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"ε : Type u_9\np : ε → Prop\ninst✝ : DecidablePred p\nep : Equiv.Perm (Subtype fun a => p a)\nen : Equiv.Perm (Subtype fun a => Not (p a))\na : ε\nh : p a\n⊢ Eq ((ep.subtypeCongr en) a) ↑(ep ⟨a, h⟩)","decl":"@[simp]\ntheorem Perm.subtypeCongr.left_apply {a : ε} (h : p a) : ep.subtypeCongr en a = ep ⟨a, h⟩ := by\n  simp [Perm.subtypeCongr.apply, h]\n\n"}
{"name":"Equiv.Perm.subtypeCongr.left_apply_subtype","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"ε : Type u_9\np : ε → Prop\ninst✝ : DecidablePred p\nep : Equiv.Perm (Subtype fun a => p a)\nen : Equiv.Perm (Subtype fun a => Not (p a))\na : Subtype fun a => p a\n⊢ Eq ((ep.subtypeCongr en) ↑a) ↑(ep a)","decl":"@[simp]\ntheorem Perm.subtypeCongr.left_apply_subtype (a : { a // p a }) : ep.subtypeCongr en a = ep a :=\n    Perm.subtypeCongr.left_apply ep en a.property\n\n"}
{"name":"Equiv.Perm.subtypeCongr.right_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"ε : Type u_9\np : ε → Prop\ninst✝ : DecidablePred p\nep : Equiv.Perm (Subtype fun a => p a)\nen : Equiv.Perm (Subtype fun a => Not (p a))\na : ε\nh : Not (p a)\n⊢ Eq ((ep.subtypeCongr en) a) ↑(en ⟨a, h⟩)","decl":"@[simp]\ntheorem Perm.subtypeCongr.right_apply {a : ε} (h : ¬p a) : ep.subtypeCongr en a = en ⟨a, h⟩ := by\n  simp [Perm.subtypeCongr.apply, h]\n\n"}
{"name":"Equiv.Perm.subtypeCongr.right_apply_subtype","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"ε : Type u_9\np : ε → Prop\ninst✝ : DecidablePred p\nep : Equiv.Perm (Subtype fun a => p a)\nen : Equiv.Perm (Subtype fun a => Not (p a))\na : Subtype fun a => Not (p a)\n⊢ Eq ((ep.subtypeCongr en) ↑a) ↑(en a)","decl":"@[simp]\ntheorem Perm.subtypeCongr.right_apply_subtype (a : { a // ¬p a }) : ep.subtypeCongr en a = en a :=\n  Perm.subtypeCongr.right_apply ep en a.property\n\n"}
{"name":"Equiv.Perm.subtypeCongr.refl","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"ε : Type u_9\np : ε → Prop\ninst✝ : DecidablePred p\n⊢ Eq (Equiv.Perm.subtypeCongr (Equiv.refl (Subtype fun a => p a)) (Equiv.refl (Subtype fun a => Not (p a)))) (Equiv.refl ε)","decl":"@[simp]\ntheorem Perm.subtypeCongr.refl :\n    Perm.subtypeCongr (Equiv.refl { a // p a }) (Equiv.refl { a // ¬p a }) = Equiv.refl ε := by\n  ext x\n  by_cases h : p x <;> simp [h]\n\n"}
{"name":"Equiv.Perm.subtypeCongr.symm","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"ε : Type u_9\np : ε → Prop\ninst✝ : DecidablePred p\nep : Equiv.Perm (Subtype fun a => p a)\nen : Equiv.Perm (Subtype fun a => Not (p a))\n⊢ Eq (Equiv.symm (ep.subtypeCongr en)) (Equiv.Perm.subtypeCongr (Equiv.symm ep) (Equiv.symm en))","decl":"@[simp]\ntheorem Perm.subtypeCongr.symm : (ep.subtypeCongr en).symm = Perm.subtypeCongr ep.symm en.symm := by\n  ext x\n  by_cases h : p x\n  · have : p (ep.symm ⟨x, h⟩) := Subtype.property _\n    simp [Perm.subtypeCongr.apply, h, symm_apply_eq, this]\n  · have : ¬p (en.symm ⟨x, h⟩) := Subtype.property (en.symm _)\n    simp [Perm.subtypeCongr.apply, h, symm_apply_eq, this]\n\n"}
{"name":"Equiv.Perm.subtypeCongr.trans","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"ε : Type u_9\np : ε → Prop\ninst✝ : DecidablePred p\nep ep' : Equiv.Perm (Subtype fun a => p a)\nen en' : Equiv.Perm (Subtype fun a => Not (p a))\n⊢ Eq (Equiv.trans (ep.subtypeCongr en) (ep'.subtypeCongr en')) (Equiv.Perm.subtypeCongr (Equiv.trans ep ep') (Equiv.trans en en'))","decl":"@[simp]\ntheorem Perm.subtypeCongr.trans :\n    (ep.subtypeCongr en).trans (ep'.subtypeCongr en')\n    = Perm.subtypeCongr (ep.trans ep') (en.trans en') := by\n  ext x\n  by_cases h : p x\n  · have : p (ep ⟨x, h⟩) := Subtype.property _\n    simp [Perm.subtypeCongr.apply, h, this]\n  · have : ¬p (en ⟨x, h⟩) := Subtype.property (en _)\n    simp [Perm.subtypeCongr.apply, h, symm_apply_eq, this]\n\n"}
{"name":"Equiv.subtypePreimage_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_4\np : α → Prop\ninst✝ : DecidablePred p\nx₀ : (Subtype fun a => p a) → β\nx : Subtype fun x => Eq (Function.comp x Subtype.val) x₀\na : Subtype fun a => Not (p a)\n⊢ Eq ((Equiv.subtypePreimage p x₀) x a) (↑x ↑a)","decl":"/-- For a fixed function `x₀ : {a // p a} → β` defined on a subtype of `α`,\nthe subtype of functions `x : α → β` that agree with `x₀` on the subtype `{a // p a}`\nis naturally equivalent to the type of functions `{a // ¬ p a} → β`. -/\n@[simps]\ndef subtypePreimage : { x : α → β // x ∘ Subtype.val = x₀ } ≃ ({ a // ¬p a } → β) where\n  toFun (x : { x : α → β // x ∘ Subtype.val = x₀ }) a := (x : α → β) a\n  invFun x := ⟨fun a => if h : p a then x₀ ⟨a, h⟩ else x ⟨a, h⟩, funext fun ⟨_, h⟩ => dif_pos h⟩\n  left_inv := fun ⟨x, hx⟩ =>\n    Subtype.val_injective <|\n      funext fun a => by\n        dsimp only\n        split_ifs\n        · rw [← hx]; rfl\n        · rfl\n  right_inv x :=\n    funext fun ⟨a, h⟩ =>\n      show dite (p a) _ _ = _ by\n        dsimp only\n        rw [dif_neg h]\n\n"}
{"name":"Equiv.subtypePreimage_symm_apply_coe","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_4\np : α → Prop\ninst✝ : DecidablePred p\nx₀ : (Subtype fun a => p a) → β\nx : (Subtype fun a => Not (p a)) → β\na : α\n⊢ Eq (↑((Equiv.subtypePreimage p x₀).symm x) a) (dite (p a) (fun h => x₀ ⟨a, h⟩) fun h => x ⟨a, h⟩)","decl":"/-- For a fixed function `x₀ : {a // p a} → β` defined on a subtype of `α`,\nthe subtype of functions `x : α → β` that agree with `x₀` on the subtype `{a // p a}`\nis naturally equivalent to the type of functions `{a // ¬ p a} → β`. -/\n@[simps]\ndef subtypePreimage : { x : α → β // x ∘ Subtype.val = x₀ } ≃ ({ a // ¬p a } → β) where\n  toFun (x : { x : α → β // x ∘ Subtype.val = x₀ }) a := (x : α → β) a\n  invFun x := ⟨fun a => if h : p a then x₀ ⟨a, h⟩ else x ⟨a, h⟩, funext fun ⟨_, h⟩ => dif_pos h⟩\n  left_inv := fun ⟨x, hx⟩ =>\n    Subtype.val_injective <|\n      funext fun a => by\n        dsimp only\n        split_ifs\n        · rw [← hx]; rfl\n        · rfl\n  right_inv x :=\n    funext fun ⟨a, h⟩ =>\n      show dite (p a) _ _ = _ by\n        dsimp only\n        rw [dif_neg h]\n\n"}
{"name":"Equiv.subtypePreimage_symm_apply_coe_pos","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_4\np : α → Prop\ninst✝ : DecidablePred p\nx₀ : (Subtype fun a => p a) → β\nx : (Subtype fun a => Not (p a)) → β\na : α\nh : p a\n⊢ Eq (↑((Equiv.subtypePreimage p x₀).symm x) a) (x₀ ⟨a, h⟩)","decl":"theorem subtypePreimage_symm_apply_coe_pos (x : { a // ¬p a } → β) (a : α) (h : p a) :\n    ((subtypePreimage p x₀).symm x : α → β) a = x₀ ⟨a, h⟩ :=\n  dif_pos h\n\n"}
{"name":"Equiv.subtypePreimage_symm_apply_coe_neg","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_4\np : α → Prop\ninst✝ : DecidablePred p\nx₀ : (Subtype fun a => p a) → β\nx : (Subtype fun a => Not (p a)) → β\na : α\nh : Not (p a)\n⊢ Eq (↑((Equiv.subtypePreimage p x₀).symm x) a) (x ⟨a, h⟩)","decl":"theorem subtypePreimage_symm_apply_coe_neg (x : { a // ¬p a } → β) (a : α) (h : ¬p a) :\n    ((subtypePreimage p x₀).symm x : α → β) a = x ⟨a, h⟩ :=\n  dif_neg h\n\n"}
{"name":"Equiv.piCongrRight_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\nβ₁ : α → Sort u_9\nβ₂ : α → Sort u_10\nF : (a : α) → Equiv (β₁ a) (β₂ a)\na✝ : (i : α) → β₁ i\ni : α\n⊢ Eq ((Equiv.piCongrRight F) a✝ i) (Pi.map (fun a => ⇑(F a)) a✝ i)","decl":"/-- A family of equivalences `∀ a, β₁ a ≃ β₂ a` generates an equivalence between `∀ a, β₁ a` and\n`∀ a, β₂ a`. -/\n@[simps]\ndef piCongrRight {β₁ β₂ : α → Sort*} (F : ∀ a, β₁ a ≃ β₂ a) : (∀ a, β₁ a) ≃ (∀ a, β₂ a) :=\n  ⟨Pi.map fun a ↦ F a, Pi.map fun a ↦ (F a).symm, fun H => funext <| by simp,\n    fun H => funext <| by simp⟩\n\n"}
{"name":"Equiv.piCongrRight_symm_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\nβ₁ : α → Sort u_9\nβ₂ : α → Sort u_10\nF : (a : α) → Equiv (β₁ a) (β₂ a)\na✝ : (i : α) → β₂ i\ni : α\n⊢ Eq ((Equiv.piCongrRight F).symm a✝ i) (Pi.map (fun a => ⇑(F a).symm) a✝ i)","decl":"/-- A family of equivalences `∀ a, β₁ a ≃ β₂ a` generates an equivalence between `∀ a, β₁ a` and\n`∀ a, β₂ a`. -/\n@[simps]\ndef piCongrRight {β₁ β₂ : α → Sort*} (F : ∀ a, β₁ a ≃ β₂ a) : (∀ a, β₁ a) ≃ (∀ a, β₂ a) :=\n  ⟨Pi.map fun a ↦ F a, Pi.map fun a ↦ (F a).symm, fun H => funext <| by simp,\n    fun H => funext <| by simp⟩\n\n"}
{"name":"Equiv.piComm_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_4\nφ : α → β → Sort u_9\nf : (x : α) → (y : β) → φ x y\ny : β\nx : α\n⊢ Eq ((Equiv.piComm φ) f y x) (Function.swap f y x)","decl":"/-- Given `φ : α → β → Sort*`, we have an equivalence between `∀ a b, φ a b` and `∀ b a, φ a b`.\nThis is `Function.swap` as an `Equiv`. -/\n@[simps apply]\ndef piComm (φ : α → β → Sort*) : (∀ a b, φ a b) ≃ ∀ b a, φ a b :=\n  ⟨swap, swap, fun _ => rfl, fun _ => rfl⟩\n\n"}
{"name":"Equiv.piComm_symm","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_4\nφ : α → β → Sort u_9\n⊢ Eq (Equiv.piComm φ).symm (Equiv.piComm (Function.swap φ))","decl":"@[simp]\ntheorem piComm_symm {φ : α → β → Sort*} : (piComm φ).symm = (piComm <| swap φ) :=\n  rfl\n\n"}
{"name":"Equiv.piCurry_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_11\nβ : α → Type u_9\nγ : (a : α) → β a → Type u_10\nf : (x : Sigma fun i => β i) → γ x.fst x.snd\n⊢ Eq ((Equiv.piCurry γ) f) (Sigma.curry f)","decl":"@[simp] theorem piCurry_apply {α} {β : α → Type*} (γ : ∀ a, β a → Type*)\n    (f : ∀ x : Σ i, β i, γ x.1 x.2) :\n    piCurry γ f = Sigma.curry f :=\n  rfl\n\n"}
{"name":"Equiv.piCurry_symm_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_11\nβ : α → Type u_9\nγ : (a : α) → β a → Type u_10\nf : (a : α) → (b : β a) → γ a b\n⊢ Eq ((Equiv.piCurry γ).symm f) (Sigma.uncurry f)","decl":"@[simp] theorem piCurry_symm_apply {α} {β : α → Type*} (γ : ∀ a, β a → Type*) (f : ∀ a b, γ a b) :\n    (piCurry γ).symm f = Sigma.uncurry f :=\n  rfl\n\n"}
{"name":"Equiv.prodCongrLeft_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α₁ : Type u_9\nβ₁ : Type u_11\nβ₂ : Type u_12\ne : α₁ → Equiv β₁ β₂\nb : β₁\na : α₁\n⊢ Eq ((Equiv.prodCongrLeft e) { fst := b, snd := a }) { fst := (e a) b, snd := a }","decl":"@[simp]\ntheorem prodCongrLeft_apply (b : β₁) (a : α₁) : prodCongrLeft e (b, a) = (e a b, a) :=\n  rfl\n\n"}
{"name":"Equiv.prodCongr_refl_right","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α₁ : Type u_9\nβ₁ : Type u_11\nβ₂ : Type u_12\ne : Equiv β₁ β₂\n⊢ Eq (e.prodCongr (Equiv.refl α₁)) (Equiv.prodCongrLeft fun x => e)","decl":"theorem prodCongr_refl_right (e : β₁ ≃ β₂) :\n    prodCongr e (Equiv.refl α₁) = prodCongrLeft fun _ => e := by\n  ext ⟨a, b⟩ : 1\n  simp\n\n"}
{"name":"Equiv.prodCongrRight_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α₁ : Type u_9\nβ₁ : Type u_11\nβ₂ : Type u_12\ne : α₁ → Equiv β₁ β₂\na : α₁\nb : β₁\n⊢ Eq ((Equiv.prodCongrRight e) { fst := a, snd := b }) { fst := a, snd := (e a) b }","decl":"@[simp]\ntheorem prodCongrRight_apply (a : α₁) (b : β₁) : prodCongrRight e (a, b) = (a, e a b) :=\n  rfl\n\n"}
{"name":"Equiv.prodCongr_refl_left","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α₁ : Type u_9\nβ₁ : Type u_11\nβ₂ : Type u_12\ne : Equiv β₁ β₂\n⊢ Eq ((Equiv.refl α₁).prodCongr e) (Equiv.prodCongrRight fun x => e)","decl":"theorem prodCongr_refl_left (e : β₁ ≃ β₂) :\n    prodCongr (Equiv.refl α₁) e = prodCongrRight fun _ => e := by\n  ext ⟨a, b⟩ : 1\n  simp\n\n"}
{"name":"Equiv.prodCongrLeft_trans_prodComm","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α₁ : Type u_9\nβ₁ : Type u_11\nβ₂ : Type u_12\ne : α₁ → Equiv β₁ β₂\n⊢ Eq ((Equiv.prodCongrLeft e).trans (Equiv.prodComm β₂ α₁)) ((Equiv.prodComm β₁ α₁).trans (Equiv.prodCongrRight e))","decl":"@[simp]\ntheorem prodCongrLeft_trans_prodComm :\n    (prodCongrLeft e).trans (prodComm _ _) = (prodComm _ _).trans (prodCongrRight e) := by\n  ext ⟨a, b⟩ : 1\n  simp\n\n"}
{"name":"Equiv.prodCongrRight_trans_prodComm","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α₁ : Type u_9\nβ₁ : Type u_11\nβ₂ : Type u_12\ne : α₁ → Equiv β₁ β₂\n⊢ Eq ((Equiv.prodCongrRight e).trans (Equiv.prodComm α₁ β₂)) ((Equiv.prodComm α₁ β₁).trans (Equiv.prodCongrLeft e))","decl":"@[simp]\ntheorem prodCongrRight_trans_prodComm :\n    (prodCongrRight e).trans (prodComm _ _) = (prodComm _ _).trans (prodCongrLeft e) := by\n  ext ⟨a, b⟩ : 1\n  simp\n\n"}
{"name":"Equiv.sigmaCongrRight_sigmaEquivProd","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α₁ : Type u_9\nβ₁ : Type u_11\nβ₂ : Type u_12\ne : α₁ → Equiv β₁ β₂\n⊢ Eq ((Equiv.sigmaCongrRight e).trans (Equiv.sigmaEquivProd α₁ β₂)) ((Equiv.sigmaEquivProd α₁ β₁).trans (Equiv.prodCongrRight e))","decl":"theorem sigmaCongrRight_sigmaEquivProd :\n    (sigmaCongrRight e).trans (sigmaEquivProd α₁ β₂)\n    = (sigmaEquivProd α₁ β₁).trans (prodCongrRight e) := by\n  ext ⟨a, b⟩ : 1\n  simp\n\n"}
{"name":"Equiv.sigmaEquivProd_sigmaCongrRight","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α₁ : Type u_9\nβ₁ : Type u_11\nβ₂ : Type u_12\ne : α₁ → Equiv β₁ β₂\n⊢ Eq ((Equiv.sigmaEquivProd α₁ β₁).symm.trans (Equiv.sigmaCongrRight e)) ((Equiv.prodCongrRight e).trans (Equiv.sigmaEquivProd α₁ β₂).symm)","decl":"theorem sigmaEquivProd_sigmaCongrRight :\n    (sigmaEquivProd α₁ β₁).symm.trans (sigmaCongrRight e)\n    = (prodCongrRight e).trans (sigmaEquivProd α₁ β₂).symm := by\n  ext ⟨a, b⟩ : 1\n  simp only [trans_apply, sigmaCongrRight_apply, prodCongrRight_apply]\n  rfl\n\n-- See also `Equiv.ofPreimageEquiv`.\n"}
{"name":"Equiv.ofFiberEquiv_symm_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_13\nβ : Type u_14\nγ : Type u_15\nf : α → γ\ng : β → γ\ne : (c : γ) → Equiv (Subtype fun a => Eq (f a) c) (Subtype fun b => Eq (g b) c)\na✝ : β\n⊢ Eq ((Equiv.ofFiberEquiv e).symm a✝) ↑((Equiv.sigmaCongrRight e).symm ((Equiv.sigmaFiberEquiv g).symm a✝)).snd","decl":"/-- A family of equivalences between fibers gives an equivalence between domains. -/\n@[simps!]\ndef ofFiberEquiv {α β γ} {f : α → γ} {g : β → γ}\n    (e : ∀ c, { a // f a = c } ≃ { b // g b = c }) : α ≃ β :=\n  (sigmaFiberEquiv f).symm.trans <| (Equiv.sigmaCongrRight e).trans (sigmaFiberEquiv g)\n\n"}
{"name":"Equiv.ofFiberEquiv_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_13\nβ : Type u_14\nγ : Type u_15\nf : α → γ\ng : β → γ\ne : (c : γ) → Equiv (Subtype fun a => Eq (f a) c) (Subtype fun b => Eq (g b) c)\na✝ : α\n⊢ Eq ((Equiv.ofFiberEquiv e) a✝) ↑((e (f a✝)) ((Equiv.sigmaFiberEquiv f).symm a✝).snd)","decl":"/-- A family of equivalences between fibers gives an equivalence between domains. -/\n@[simps!]\ndef ofFiberEquiv {α β γ} {f : α → γ} {g : β → γ}\n    (e : ∀ c, { a // f a = c } ≃ { b // g b = c }) : α ≃ β :=\n  (sigmaFiberEquiv f).symm.trans <| (Equiv.sigmaCongrRight e).trans (sigmaFiberEquiv g)\n\n"}
{"name":"Equiv.ofFiberEquiv_map","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_13\nβ : Type u_14\nγ : Type u_15\nf : α → γ\ng : β → γ\ne : (c : γ) → Equiv (Subtype fun a => Eq (f a) c) (Subtype fun b => Eq (g b) c)\na : α\n⊢ Eq (g ((Equiv.ofFiberEquiv e) a)) (f a)","decl":"theorem ofFiberEquiv_map {α β γ} {f : α → γ} {g : β → γ}\n    (e : ∀ c, { a // f a = c } ≃ { b // g b = c }) (a : α) : g (ofFiberEquiv e a) = f a :=\n  (_ : { b // g b = _ }).property\n\n"}
{"name":"Equiv.prodShear_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α₁ : Type u_9\nα₂ : Type u_10\nβ₁ : Type u_11\nβ₂ : Type u_12\ne₁ : Equiv α₁ α₂\ne₂ : α₁ → Equiv β₁ β₂\n⊢ Eq ⇑(e₁.prodShear e₂) fun x => { fst := e₁ x.1, snd := (e₂ x.1) x.2 }","decl":"/-- A variation on `Equiv.prodCongr` where the equivalence in the second component can depend\n  on the first component. A typical example is a shear mapping, explaining the name of this\n  declaration. -/\n@[simps (config := .asFn)]\ndef prodShear (e₁ : α₁ ≃ α₂) (e₂ : α₁ → β₁ ≃ β₂) : α₁ × β₁ ≃ α₂ × β₂ where\n  toFun := fun x : α₁ × β₁ => (e₁ x.1, e₂ x.1 x.2)\n  invFun := fun y : α₂ × β₂ => (e₁.symm y.1, (e₂ <| e₁.symm y.1).symm y.2)\n  left_inv := by\n    rintro ⟨x₁, y₁⟩\n    simp only [symm_apply_apply]\n  right_inv := by\n    rintro ⟨x₁, y₁⟩\n    simp only [apply_symm_apply]\n\n"}
{"name":"Equiv.prodShear_symm_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α₁ : Type u_9\nα₂ : Type u_10\nβ₁ : Type u_11\nβ₂ : Type u_12\ne₁ : Equiv α₁ α₂\ne₂ : α₁ → Equiv β₁ β₂\n⊢ Eq ⇑(e₁.prodShear e₂).symm fun y => { fst := e₁.symm y.1, snd := (e₂ (e₁.symm y.1)).symm y.2 }","decl":"/-- A variation on `Equiv.prodCongr` where the equivalence in the second component can depend\n  on the first component. A typical example is a shear mapping, explaining the name of this\n  declaration. -/\n@[simps (config := .asFn)]\ndef prodShear (e₁ : α₁ ≃ α₂) (e₂ : α₁ → β₁ ≃ β₂) : α₁ × β₁ ≃ α₂ × β₂ where\n  toFun := fun x : α₁ × β₁ => (e₁ x.1, e₂ x.1 x.2)\n  invFun := fun y : α₂ × β₂ => (e₁.symm y.1, (e₂ <| e₁.symm y.1).symm y.2)\n  left_inv := by\n    rintro ⟨x₁, y₁⟩\n    simp only [symm_apply_apply]\n  right_inv := by\n    rintro ⟨x₁, y₁⟩\n    simp only [apply_symm_apply]\n\n"}
{"name":"Equiv.Perm.prodExtendRight_apply_eq","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α₁ : Type u_9\nβ₁ : Type u_10\ninst✝ : DecidableEq α₁\na : α₁\ne : Equiv.Perm β₁\nb : β₁\n⊢ Eq ((Equiv.Perm.prodExtendRight a e) { fst := a, snd := b }) { fst := a, snd := e b }","decl":"@[simp]\ntheorem prodExtendRight_apply_eq (b : β₁) : prodExtendRight a e (a, b) = (a, e b) :=\n  if_pos rfl\n\n"}
{"name":"Equiv.Perm.prodExtendRight_apply_ne","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α₁ : Type u_9\nβ₁ : Type u_10\ninst✝ : DecidableEq α₁\ne : Equiv.Perm β₁\na a' : α₁\nh : Ne a' a\nb : β₁\n⊢ Eq ((Equiv.Perm.prodExtendRight a e) { fst := a', snd := b }) { fst := a', snd := b }","decl":"theorem prodExtendRight_apply_ne {a a' : α₁} (h : a' ≠ a) (b : β₁) :\n    prodExtendRight a e (a', b) = (a', b) :=\n  if_neg h\n\n"}
{"name":"Equiv.Perm.eq_of_prodExtendRight_ne","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α₁ : Type u_9\nβ₁ : Type u_10\ninst✝ : DecidableEq α₁\ne : Equiv.Perm β₁\na a' : α₁\nb : β₁\nh : Ne ((Equiv.Perm.prodExtendRight a e) { fst := a', snd := b }) { fst := a', snd := b }\n⊢ Eq a' a","decl":"theorem eq_of_prodExtendRight_ne {e : Perm β₁} {a a' : α₁} {b : β₁}\n    (h : prodExtendRight a e (a', b) ≠ (a', b)) : a' = a := by\n  contrapose! h\n  exact prodExtendRight_apply_ne _ h _\n\n"}
{"name":"Equiv.Perm.fst_prodExtendRight","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α₁ : Type u_9\nβ₁ : Type u_10\ninst✝ : DecidableEq α₁\na : α₁\ne : Equiv.Perm β₁\nab : Prod α₁ β₁\n⊢ Eq ((Equiv.Perm.prodExtendRight a e) ab).1 ab.1","decl":"@[simp]\ntheorem fst_prodExtendRight (ab : α₁ × β₁) : (prodExtendRight a e ab).fst = ab.fst := by\n  rw [prodExtendRight]\n  dsimp\n  split_ifs with h\n  · rw [h]\n  · rfl\n\n"}
{"name":"Equiv.sumPiEquivProdPi_symm_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"ι : Type u_10\nι' : Type u_11\nπ : Sum ι ι' → Type u_9\ng : Prod ((i : ι) → π (Sum.inl i)) ((i' : ι') → π (Sum.inr i'))\nt : Sum ι ι'\n⊢ Eq ((Equiv.sumPiEquivProdPi π).symm g t) (Sum.rec g.1 g.2 t)","decl":"/-- The type of dependent functions on a sum type `ι ⊕ ι'` is equivalent to the type of pairs of\nfunctions on `ι` and on `ι'`. This is a dependent version of `Equiv.sumArrowEquivProdArrow`. -/\n@[simps]\ndef sumPiEquivProdPi {ι ι'} (π : ι ⊕ ι' → Type*) :\n    (∀ i, π i) ≃ (∀ i, π (inl i)) × ∀ i', π (inr i') where\n  toFun f := ⟨fun i => f (inl i), fun i' => f (inr i')⟩\n  invFun g := Sum.rec g.1 g.2\n  left_inv f := by ext (i | i) <;> rfl\n  right_inv _ := Prod.ext rfl rfl\n\n"}
{"name":"Equiv.sumPiEquivProdPi_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"ι : Type u_10\nι' : Type u_11\nπ : Sum ι ι' → Type u_9\nf : (i : Sum ι ι') → π i\n⊢ Eq ((Equiv.sumPiEquivProdPi π) f) { fst := fun i => f (Sum.inl i), snd := fun i' => f (Sum.inr i') }","decl":"/-- The type of dependent functions on a sum type `ι ⊕ ι'` is equivalent to the type of pairs of\nfunctions on `ι` and on `ι'`. This is a dependent version of `Equiv.sumArrowEquivProdArrow`. -/\n@[simps]\ndef sumPiEquivProdPi {ι ι'} (π : ι ⊕ ι' → Type*) :\n    (∀ i, π i) ≃ (∀ i, π (inl i)) × ∀ i', π (inr i') where\n  toFun f := ⟨fun i => f (inl i), fun i' => f (inr i')⟩\n  invFun g := Sum.rec g.1 g.2\n  left_inv f := by ext (i | i) <;> rfl\n  right_inv _ := Prod.ext rfl rfl\n\n"}
{"name":"Equiv.prodPiEquivSumPi_symm_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"ι : Type u_9\nι' : Type u_10\nπ : ι → Type u\nπ' : ι' → Type u\na✝ : (i : Sum ι ι') → Sum.elim π π' i\n⊢ Eq ((Equiv.prodPiEquivSumPi π π').symm a✝) ((Equiv.sumPiEquivProdPi (Sum.elim π π')) a✝)","decl":"/-- The equivalence between a product of two dependent functions types and a single dependent\nfunction type. Basically a symmetric version of `Equiv.sumPiEquivProdPi`. -/\n@[simps!]\ndef prodPiEquivSumPi {ι ι'} (π : ι → Type u) (π' : ι' → Type u) :\n    ((∀ i, π i) × ∀ i', π' i') ≃ ∀ i, Sum.elim π π' i :=\n  sumPiEquivProdPi (Sum.elim π π') |>.symm\n\n"}
{"name":"Equiv.prodPiEquivSumPi_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"ι : Type u_9\nι' : Type u_10\nπ : ι → Type u\nπ' : ι' → Type u\na✝ : Prod ((i : ι) → Sum.elim π π' (Sum.inl i)) ((i' : ι') → Sum.elim π π' (Sum.inr i'))\ni : Sum ι ι'\n⊢ Eq ((Equiv.prodPiEquivSumPi π π') a✝ i) ((Equiv.sumPiEquivProdPi (Sum.elim π π')).symm a✝ i)","decl":"/-- The equivalence between a product of two dependent functions types and a single dependent\nfunction type. Basically a symmetric version of `Equiv.sumPiEquivProdPi`. -/\n@[simps!]\ndef prodPiEquivSumPi {ι ι'} (π : ι → Type u) (π' : ι' → Type u) :\n    ((∀ i, π i) × ∀ i', π' i') ≃ ∀ i, Sum.elim π π' i :=\n  sumPiEquivProdPi (Sum.elim π π') |>.symm\n\n"}
{"name":"Equiv.sumArrowEquivProdArrow_apply_fst","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\nγ : Type u_11\nf : Sum α β → γ\na : α\n⊢ Eq (((Equiv.sumArrowEquivProdArrow α β γ) f).1 a) (f (Sum.inl a))","decl":"@[simp]\ntheorem sumArrowEquivProdArrow_apply_fst {α β γ} (f : α ⊕ β → γ) (a : α) :\n    (sumArrowEquivProdArrow α β γ f).1 a = f (inl a) :=\n  rfl\n\n"}
{"name":"Equiv.sumArrowEquivProdArrow_apply_snd","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\nγ : Type u_11\nf : Sum α β → γ\nb : β\n⊢ Eq (((Equiv.sumArrowEquivProdArrow α β γ) f).2 b) (f (Sum.inr b))","decl":"@[simp]\ntheorem sumArrowEquivProdArrow_apply_snd {α β γ} (f : α ⊕ β → γ) (b : β) :\n    (sumArrowEquivProdArrow α β γ f).2 b = f (inr b) :=\n  rfl\n\n"}
{"name":"Equiv.sumArrowEquivProdArrow_symm_apply_inl","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\nγ : Type u_11\nf : α → γ\ng : β → γ\na : α\n⊢ Eq ((Equiv.sumArrowEquivProdArrow α β γ).symm { fst := f, snd := g } (Sum.inl a)) (f a)","decl":"@[simp]\ntheorem sumArrowEquivProdArrow_symm_apply_inl {α β γ} (f : α → γ) (g : β → γ) (a : α) :\n    ((sumArrowEquivProdArrow α β γ).symm (f, g)) (inl a) = f a :=\n  rfl\n\n"}
{"name":"Equiv.sumArrowEquivProdArrow_symm_apply_inr","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\nγ : Type u_11\nf : α → γ\ng : β → γ\nb : β\n⊢ Eq ((Equiv.sumArrowEquivProdArrow α β γ).symm { fst := f, snd := g } (Sum.inr b)) (g b)","decl":"@[simp]\ntheorem sumArrowEquivProdArrow_symm_apply_inr {α β γ} (f : α → γ) (g : β → γ) (b : β) :\n    ((sumArrowEquivProdArrow α β γ).symm (f, g)) (inr b) = g b :=\n  rfl\n\n"}
{"name":"Equiv.sumProdDistrib_apply_left","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\nγ : Type u_11\na : α\nc : γ\n⊢ Eq ((Equiv.sumProdDistrib α β γ) { fst := Sum.inl a, snd := c }) (Sum.inl { fst := a, snd := c })","decl":"@[simp]\ntheorem sumProdDistrib_apply_left {α β γ} (a : α) (c : γ) :\n    sumProdDistrib α β γ (Sum.inl a, c) = Sum.inl (a, c) :=\n  rfl\n\n"}
{"name":"Equiv.sumProdDistrib_apply_right","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\nγ : Type u_11\nb : β\nc : γ\n⊢ Eq ((Equiv.sumProdDistrib α β γ) { fst := Sum.inr b, snd := c }) (Sum.inr { fst := b, snd := c })","decl":"@[simp]\ntheorem sumProdDistrib_apply_right {α β γ} (b : β) (c : γ) :\n    sumProdDistrib α β γ (Sum.inr b, c) = Sum.inr (b, c) :=\n  rfl\n\n"}
{"name":"Equiv.sumProdDistrib_symm_apply_left","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\nγ : Type u_11\na : Prod α γ\n⊢ Eq ((Equiv.sumProdDistrib α β γ).symm (Sum.inl a)) { fst := Sum.inl a.1, snd := a.2 }","decl":"@[simp]\ntheorem sumProdDistrib_symm_apply_left {α β γ} (a : α × γ) :\n    (sumProdDistrib α β γ).symm (inl a) = (inl a.1, a.2) :=\n  rfl\n\n"}
{"name":"Equiv.sumProdDistrib_symm_apply_right","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\nγ : Type u_11\nb : Prod β γ\n⊢ Eq ((Equiv.sumProdDistrib α β γ).symm (Sum.inr b)) { fst := Sum.inr b.1, snd := b.2 }","decl":"@[simp]\ntheorem sumProdDistrib_symm_apply_right {α β γ} (b : β × γ) :\n    (sumProdDistrib α β γ).symm (inr b) = (inr b.1, b.2) :=\n  rfl\n\n"}
{"name":"Equiv.prodSumDistrib_apply_left","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\nγ : Type u_11\na : α\nb : β\n⊢ Eq ((Equiv.prodSumDistrib α β γ) { fst := a, snd := Sum.inl b }) (Sum.inl { fst := a, snd := b })","decl":"@[simp]\ntheorem prodSumDistrib_apply_left {α β γ} (a : α) (b : β) :\n    prodSumDistrib α β γ (a, Sum.inl b) = Sum.inl (a, b) :=\n  rfl\n\n"}
{"name":"Equiv.prodSumDistrib_apply_right","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\nγ : Type u_11\na : α\nc : γ\n⊢ Eq ((Equiv.prodSumDistrib α β γ) { fst := a, snd := Sum.inr c }) (Sum.inr { fst := a, snd := c })","decl":"@[simp]\ntheorem prodSumDistrib_apply_right {α β γ} (a : α) (c : γ) :\n    prodSumDistrib α β γ (a, Sum.inr c) = Sum.inr (a, c) :=\n  rfl\n\n"}
{"name":"Equiv.prodSumDistrib_symm_apply_left","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\nγ : Type u_11\na : Prod α β\n⊢ Eq ((Equiv.prodSumDistrib α β γ).symm (Sum.inl a)) { fst := a.1, snd := Sum.inl a.2 }","decl":"@[simp]\ntheorem prodSumDistrib_symm_apply_left {α β γ} (a : α × β) :\n    (prodSumDistrib α β γ).symm (inl a) = (a.1, inl a.2) :=\n  rfl\n\n"}
{"name":"Equiv.prodSumDistrib_symm_apply_right","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\nγ : Type u_11\na : Prod α γ\n⊢ Eq ((Equiv.prodSumDistrib α β γ).symm (Sum.inr a)) { fst := a.1, snd := Sum.inr a.2 }","decl":"@[simp]\ntheorem prodSumDistrib_symm_apply_right {α β γ} (a : α × γ) :\n    (prodSumDistrib α β γ).symm (inr a) = (a.1, inr a.2) :=\n  rfl\n\n"}
{"name":"Equiv.sigmaSumDistrib_symm_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"ι : Type u_11\nα : ι → Type u_9\nβ : ι → Type u_10\na✝ : Sum (Sigma fun i => α i) (Sigma fun i => β i)\n⊢ Eq ((Equiv.sigmaSumDistrib α β).symm a✝) (Sum.elim (Sigma.map id fun x => Sum.inl) (Sigma.map id fun x => Sum.inr) a✝)","decl":"/-- An indexed sum of disjoint sums of types is equivalent to the sum of the indexed sums. Compare\nwith `Equiv.sumSigmaDistrib` which is indexed by sums. -/\n@[simps]\ndef sigmaSumDistrib {ι} (α β : ι → Type*) :\n    (Σ i, α i ⊕ β i) ≃ (Σ i, α i) ⊕ (Σ i, β i) :=\n  ⟨fun p => p.2.map (Sigma.mk p.1) (Sigma.mk p.1),\n    Sum.elim (Sigma.map id fun _ => Sum.inl) (Sigma.map id fun _ => Sum.inr), fun p => by\n    rcases p with ⟨i, a | b⟩ <;> rfl, fun p => by rcases p with (⟨i, a⟩ | ⟨i, b⟩) <;> rfl⟩\n\n"}
{"name":"Equiv.sigmaSumDistrib_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"ι : Type u_11\nα : ι → Type u_9\nβ : ι → Type u_10\np : Sigma fun i => Sum (α i) (β i)\n⊢ Eq ((Equiv.sigmaSumDistrib α β) p) (Sum.map (Sigma.mk p.fst) (Sigma.mk p.fst) p.snd)","decl":"/-- An indexed sum of disjoint sums of types is equivalent to the sum of the indexed sums. Compare\nwith `Equiv.sumSigmaDistrib` which is indexed by sums. -/\n@[simps]\ndef sigmaSumDistrib {ι} (α β : ι → Type*) :\n    (Σ i, α i ⊕ β i) ≃ (Σ i, α i) ⊕ (Σ i, β i) :=\n  ⟨fun p => p.2.map (Sigma.mk p.1) (Sigma.mk p.1),\n    Sum.elim (Sigma.map id fun _ => Sum.inl) (Sigma.map id fun _ => Sum.inr), fun p => by\n    rcases p with ⟨i, a | b⟩ <;> rfl, fun p => by rcases p with (⟨i, a⟩ | ⟨i, b⟩) <;> rfl⟩\n\n"}
{"name":"Equiv.sumSigmaDistrib_symm_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_10\nβ : Type u_11\nt : Sum α β → Type u_9\na✝ : Sum (Sigma fun i => t (Sum.inl i)) (Sigma fun i => t (Sum.inr i))\n⊢ Eq ((Equiv.sumSigmaDistrib t).symm a✝) (Sum.elim (fun a => ⟨Sum.inl a.fst, a.snd⟩) (fun b => ⟨Sum.inr b.fst, b.snd⟩) a✝)","decl":"/-- A type indexed by  disjoint sums of types is equivalent to the sum of the sums. Compare with\n`Equiv.sigmaSumDistrib` which has the sums as the output type. -/\n@[simps]\ndef sumSigmaDistrib {α β} (t : α ⊕ β → Type*) :\n    (Σ i, t i) ≃ (Σ i, t (.inl i)) ⊕ (Σ i, t (.inr i)) :=\n  ⟨(match · with\n   | .mk (.inl x) y => .inl ⟨x, y⟩\n   | .mk (.inr x) y => .inr ⟨x, y⟩),\n  Sum.elim (fun a ↦ ⟨.inl a.1, a.2⟩) (fun b ↦ ⟨.inr b.1, b.2⟩),\n  by rintro ⟨x|x,y⟩ <;> simp,\n  by rintro (⟨x,y⟩|⟨x,y⟩) <;> simp⟩\n\n"}
{"name":"Equiv.sumSigmaDistrib_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_10\nβ : Type u_11\nt : Sum α β → Type u_9\nx✝ : Sigma fun i => t i\n⊢ Eq ((Equiv.sumSigmaDistrib t) x✝) (Equiv.sumSigmaDistrib.match_1 t (fun x => Sum (Sigma fun i => t (Sum.inl i)) (Sigma fun i => t (Sum.inr i))) x✝ (fun x y => Sum.inl ⟨x, y⟩) fun x y => Sum.inr ⟨x, y⟩)","decl":"/-- A type indexed by  disjoint sums of types is equivalent to the sum of the sums. Compare with\n`Equiv.sigmaSumDistrib` which has the sums as the output type. -/\n@[simps]\ndef sumSigmaDistrib {α β} (t : α ⊕ β → Type*) :\n    (Σ i, t i) ≃ (Σ i, t (.inl i)) ⊕ (Σ i, t (.inr i)) :=\n  ⟨(match · with\n   | .mk (.inl x) y => .inl ⟨x, y⟩\n   | .mk (.inr x) y => .inr ⟨x, y⟩),\n  Sum.elim (fun a ↦ ⟨.inl a.1, a.2⟩) (fun b ↦ ⟨.inr b.1, b.2⟩),\n  by rintro ⟨x|x,y⟩ <;> simp,\n  by rintro (⟨x,y⟩|⟨x,y⟩) <;> simp⟩\n\n"}
{"name":"Equiv.sigmaProdDistrib_symm_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"ι : Type u_10\nα : ι → Type u_9\nβ : Type u_11\np : Sigma fun i => Prod (α i) β\n⊢ Eq ((Equiv.sigmaProdDistrib α β).symm p) { fst := ⟨p.fst, p.snd.1⟩, snd := p.snd.2 }","decl":"/-- The product of an indexed sum of types (formally, a `Sigma`-type `Σ i, α i`) by a type `β` is\nequivalent to the sum of products `Σ i, (α i × β)`. -/\n@[simps apply symm_apply]\ndef sigmaProdDistrib {ι} (α : ι → Type*) (β) : (Σ i, α i) × β ≃ Σ i, α i × β :=\n  ⟨fun p => ⟨p.1.1, (p.1.2, p.2)⟩, fun p => (⟨p.1, p.2.1⟩, p.2.2), fun p => by\n    rcases p with ⟨⟨_, _⟩, _⟩\n    rfl, fun p => by\n    rcases p with ⟨_, ⟨_, _⟩⟩\n    rfl⟩\n\n"}
{"name":"Equiv.sigmaProdDistrib_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"ι : Type u_10\nα : ι → Type u_9\nβ : Type u_11\np : Prod (Sigma fun i => α i) β\n⊢ Eq ((Equiv.sigmaProdDistrib α β) p) ⟨p.1.fst, { fst := p.1.snd, snd := p.2 }⟩","decl":"/-- The product of an indexed sum of types (formally, a `Sigma`-type `Σ i, α i`) by a type `β` is\nequivalent to the sum of products `Σ i, (α i × β)`. -/\n@[simps apply symm_apply]\ndef sigmaProdDistrib {ι} (α : ι → Type*) (β) : (Σ i, α i) × β ≃ Σ i, α i × β :=\n  ⟨fun p => ⟨p.1.1, (p.1.2, p.2)⟩, fun p => (⟨p.1, p.2.1⟩, p.2.2), fun p => by\n    rcases p with ⟨⟨_, _⟩, _⟩\n    rfl, fun p => by\n    rcases p with ⟨_, ⟨_, _⟩⟩\n    rfl⟩\n\n"}
{"name":"Equiv.boolProdEquivSum_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\np : Prod Bool α\n⊢ Eq ((Equiv.boolProdEquivSum α) p) (Bool.casesOn p.1 (Sum.inl p.2) (Sum.inr p.2))","decl":"/-- The product `Bool × α` is equivalent to `α ⊕ α`. -/\n@[simps]\ndef boolProdEquivSum (α) : Bool × α ≃ α ⊕ α where\n  toFun p := p.1.casesOn (inl p.2) (inr p.2)\n  invFun := Sum.elim (Prod.mk false) (Prod.mk true)\n  left_inv := by rintro ⟨_ | _, _⟩ <;> rfl\n  right_inv := by rintro (_ | _) <;> rfl\n\n"}
{"name":"Equiv.boolProdEquivSum_symm_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\na✝ : Sum α α\n⊢ Eq ((Equiv.boolProdEquivSum α).symm a✝) (Sum.elim (Prod.mk Bool.false) (Prod.mk Bool.true) a✝)","decl":"/-- The product `Bool × α` is equivalent to `α ⊕ α`. -/\n@[simps]\ndef boolProdEquivSum (α) : Bool × α ≃ α ⊕ α where\n  toFun p := p.1.casesOn (inl p.2) (inr p.2)\n  invFun := Sum.elim (Prod.mk false) (Prod.mk true)\n  left_inv := by rintro ⟨_ | _, _⟩ <;> rfl\n  right_inv := by rintro (_ | _) <;> rfl\n\n"}
{"name":"Equiv.boolArrowEquivProd_symm_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\np : Prod α α\nb : Bool\n⊢ Eq ((Equiv.boolArrowEquivProd α).symm p b) (Bool.casesOn b p.1 p.2)","decl":"/-- The function type `Bool → α` is equivalent to `α × α`. -/\n@[simps]\ndef boolArrowEquivProd (α) : (Bool → α) ≃ α × α where\n  toFun f := (f false, f true)\n  invFun p b := b.casesOn p.1 p.2\n  left_inv _ := funext <| Bool.forall_bool.2 ⟨rfl, rfl⟩\n  right_inv := fun _ => rfl\n\n"}
{"name":"Equiv.boolArrowEquivProd_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\nf : Bool → α\n⊢ Eq ((Equiv.boolArrowEquivProd α) f) { fst := f Bool.false, snd := f Bool.true }","decl":"/-- The function type `Bool → α` is equivalent to `α × α`. -/\n@[simps]\ndef boolArrowEquivProd (α) : (Bool → α) ≃ α × α where\n  toFun f := (f false, f true)\n  invFun p b := b.casesOn p.1 p.2\n  left_inv _ := funext <| Bool.forall_bool.2 ⟨rfl, rfl⟩\n  right_inv := fun _ => rfl\n\n"}
{"name":"Equiv.isEmpty_congr","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_4\ne : Equiv α β\n⊢ Iff (IsEmpty α) (IsEmpty β)","decl":"/-- If `α` is equivalent to `β`, then `IsEmpty α` is equivalent to `IsEmpty β`. -/\ntheorem isEmpty_congr (e : α ≃ β) : IsEmpty α ↔ IsEmpty β :=\n  ⟨fun h => @Function.isEmpty _ _ h e.symm, fun h => @Function.isEmpty _ _ h e⟩\n\n"}
{"name":"Equiv.isEmpty","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_4\ne : Equiv α β\ninst✝ : IsEmpty β\n⊢ IsEmpty α","decl":"protected theorem isEmpty (e : α ≃ β) [IsEmpty β] : IsEmpty α :=\n  e.isEmpty_congr.mpr ‹_›\n\n"}
{"name":"Equiv.coe_subtypeEquiv_eq_map","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"X : Sort u_9\nY : Sort u_10\np : X → Prop\nq : Y → Prop\ne : Equiv X Y\nh : ∀ (x : X), Iff (p x) (q (e x))\n⊢ Eq (⇑(e.subtypeEquiv h)) (Subtype.map ⇑e ⋯)","decl":"lemma coe_subtypeEquiv_eq_map {X Y} {p : X → Prop} {q : Y → Prop} (e : X ≃ Y)\n    (h : ∀ x, p x ↔ q (e x)) : ⇑(e.subtypeEquiv h) = Subtype.map e (h · |>.mp) :=\n  rfl\n\n"}
{"name":"Equiv.subtypeEquiv_refl","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\np : α → Prop\nh : optParam (∀ (a : α), Iff (p a) (p ((Equiv.refl α) a))) ⋯\n⊢ Eq ((Equiv.refl α).subtypeEquiv h) (Equiv.refl (Subtype fun a => p a))","decl":"@[simp]\ntheorem subtypeEquiv_refl {p : α → Prop} (h : ∀ a, p a ↔ p (Equiv.refl _ a) := fun _ => Iff.rfl) :\n    (Equiv.refl α).subtypeEquiv h = Equiv.refl { a : α // p a } := by\n  ext\n  rfl\n\n"}
{"name":"Equiv.subtypeEquiv_symm","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_4\np : α → Prop\nq : β → Prop\ne : Equiv α β\nh : ∀ (a : α), Iff (p a) (q (e a))\n⊢ Eq (e.subtypeEquiv h).symm (e.symm.subtypeEquiv ⋯)","decl":"@[simp]\ntheorem subtypeEquiv_symm {p : α → Prop} {q : β → Prop} (e : α ≃ β) (h : ∀ a : α, p a ↔ q (e a)) :\n    (e.subtypeEquiv h).symm =\n      e.symm.subtypeEquiv fun a => by\n        convert (h <| e.symm a).symm\n        exact (e.apply_symm_apply a).symm :=\n  rfl\n\n"}
{"name":"Equiv.subtypeEquiv_trans","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_4\nγ : Sort u_7\np : α → Prop\nq : β → Prop\nr : γ → Prop\ne : Equiv α β\nf : Equiv β γ\nh : ∀ (a : α), Iff (p a) (q (e a))\nh' : ∀ (b : β), Iff (q b) (r (f b))\n⊢ Eq ((e.subtypeEquiv h).trans (f.subtypeEquiv h')) ((e.trans f).subtypeEquiv ⋯)","decl":"@[simp]\ntheorem subtypeEquiv_trans {p : α → Prop} {q : β → Prop} {r : γ → Prop} (e : α ≃ β) (f : β ≃ γ)\n    (h : ∀ a : α, p a ↔ q (e a)) (h' : ∀ b : β, q b ↔ r (f b)) :\n    (e.subtypeEquiv h).trans (f.subtypeEquiv h')\n    = (e.trans f).subtypeEquiv fun a => (h a).trans (h' <| e a) :=\n  rfl\n\n"}
{"name":"Equiv.subtypeEquiv_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_4\np : α → Prop\nq : β → Prop\ne : Equiv α β\nh : ∀ (a : α), Iff (p a) (q (e a))\nx : Subtype fun x => p x\n⊢ Eq ((e.subtypeEquiv h) x) ⟨e ↑x, ⋯⟩","decl":"@[simp]\ntheorem subtypeEquiv_apply {p : α → Prop} {q : β → Prop}\n    (e : α ≃ β) (h : ∀ a : α, p a ↔ q (e a)) (x : { x // p x }) :\n    e.subtypeEquiv h x = ⟨e x, (h _).1 x.2⟩ :=\n  rfl\n\n"}
{"name":"Equiv.subtypeEquivRight_apply_coe","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\np q : α → Prop\ne : ∀ (x : α), Iff (p x) (q x)\na : Subtype fun a => p a\n⊢ Eq ↑((Equiv.subtypeEquivRight e) a) ↑a","decl":"/-- If two predicates `p` and `q` are pointwise equivalent, then `{x // p x}` is equivalent to\n`{x // q x}`. -/\n@[simps!]\ndef subtypeEquivRight {p q : α → Prop} (e : ∀ x, p x ↔ q x) : { x // p x } ≃ { x // q x } :=\n  subtypeEquiv (Equiv.refl _) e\n\n"}
{"name":"Equiv.subtypeEquivRight_symm_apply_coe","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\np q : α → Prop\ne : ∀ (x : α), Iff (p x) (q x)\nb : Subtype fun b => q b\n⊢ Eq ↑((Equiv.subtypeEquivRight e).symm b) ↑b","decl":"/-- If two predicates `p` and `q` are pointwise equivalent, then `{x // p x}` is equivalent to\n`{x // q x}`. -/\n@[simps!]\ndef subtypeEquivRight {p q : α → Prop} (e : ∀ x, p x ↔ q x) : { x // p x } ≃ { x // q x } :=\n  subtypeEquiv (Equiv.refl _) e\n\n"}
{"name":"Equiv.subtypeEquivRight_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\np q : α → Prop\ne : ∀ (x : α), Iff (p x) (q x)\nz : Subtype fun x => p x\n⊢ Eq ((Equiv.subtypeEquivRight e) z) ⟨↑z, ⋯⟩","decl":"lemma subtypeEquivRight_apply {p q : α → Prop} (e : ∀ x, p x ↔ q x)\n    (z : { x // p x }) : subtypeEquivRight e z = ⟨z, (e z.1).mp z.2⟩ := rfl\n\n"}
{"name":"Equiv.subtypeEquivRight_symm_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\np q : α → Prop\ne : ∀ (x : α), Iff (p x) (q x)\nz : Subtype fun x => q x\n⊢ Eq ((Equiv.subtypeEquivRight e).symm z) ⟨↑z, ⋯⟩","decl":"lemma subtypeEquivRight_symm_apply {p q : α → Prop} (e : ∀ x, p x ↔ q x)\n    (z : { x // q x }) : (subtypeEquivRight e).symm z = ⟨z, (e z.1).mpr z.2⟩ := rfl\n\n"}
{"name":"Equiv.subtypeSubtypeEquivSubtypeExists_symm_apply_coe_coe","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\np : α → Prop\nq : Subtype p → Prop\na : Subtype fun a => Exists fun h => q ⟨a, h⟩\n⊢ Eq ↑↑((Equiv.subtypeSubtypeEquivSubtypeExists p q).symm a) ↑a","decl":"/-- A subtype of a subtype is equivalent to the subtype of elements satisfying both predicates. This\nversion allows the “inner” predicate to depend on `h : p a`. -/\n@[simps]\ndef subtypeSubtypeEquivSubtypeExists (p : α → Prop) (q : Subtype p → Prop) :\n    Subtype q ≃ { a : α // ∃ h : p a, q ⟨a, h⟩ } :=\n  ⟨fun a =>\n    ⟨a.1, a.1.2, by\n      rcases a with ⟨⟨a, hap⟩, haq⟩\n      exact haq⟩,\n    fun a => ⟨⟨a, a.2.fst⟩, a.2.snd⟩, fun ⟨⟨_, _⟩, _⟩ => rfl, fun ⟨_, _, _⟩ => rfl⟩\n\n"}
{"name":"Equiv.subtypeSubtypeEquivSubtypeExists_apply_coe","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\np : α → Prop\nq : Subtype p → Prop\na : Subtype q\n⊢ Eq ↑((Equiv.subtypeSubtypeEquivSubtypeExists p q) a) ↑↑a","decl":"/-- A subtype of a subtype is equivalent to the subtype of elements satisfying both predicates. This\nversion allows the “inner” predicate to depend on `h : p a`. -/\n@[simps]\ndef subtypeSubtypeEquivSubtypeExists (p : α → Prop) (q : Subtype p → Prop) :\n    Subtype q ≃ { a : α // ∃ h : p a, q ⟨a, h⟩ } :=\n  ⟨fun a =>\n    ⟨a.1, a.1.2, by\n      rcases a with ⟨⟨a, hap⟩, haq⟩\n      exact haq⟩,\n    fun a => ⟨⟨a, a.2.fst⟩, a.2.snd⟩, fun ⟨⟨_, _⟩, _⟩ => rfl, fun ⟨_, _, _⟩ => rfl⟩\n\n"}
{"name":"Equiv.subtypeSubtypeEquivSubtypeInter_symm_apply_coe_coe","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u\np q : α → Prop\na✝ : Subtype fun x => And (p x) (q x)\n⊢ Eq ↑↑((Equiv.subtypeSubtypeEquivSubtypeInter p q).symm a✝) ↑a✝","decl":"/-- A subtype of a subtype is equivalent to the subtype of elements satisfying both predicates. -/\n@[simps!]\ndef subtypeSubtypeEquivSubtypeInter {α : Type u} (p q : α → Prop) :\n    { x : Subtype p // q x.1 } ≃ Subtype fun x => p x ∧ q x :=\n  (subtypeSubtypeEquivSubtypeExists p _).trans <|\n    subtypeEquivRight fun x => @exists_prop (q x) (p x)\n\n"}
{"name":"Equiv.subtypeSubtypeEquivSubtypeInter_apply_coe","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u\np q : α → Prop\na✝ : Subtype fun x => q ↑x\n⊢ Eq ↑((Equiv.subtypeSubtypeEquivSubtypeInter p q) a✝) ↑↑a✝","decl":"/-- A subtype of a subtype is equivalent to the subtype of elements satisfying both predicates. -/\n@[simps!]\ndef subtypeSubtypeEquivSubtypeInter {α : Type u} (p q : α → Prop) :\n    { x : Subtype p // q x.1 } ≃ Subtype fun x => p x ∧ q x :=\n  (subtypeSubtypeEquivSubtypeExists p _).trans <|\n    subtypeEquivRight fun x => @exists_prop (q x) (p x)\n\n"}
{"name":"Equiv.subtypeSubtypeEquivSubtype_symm_apply_coe_coe","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\np q : α → Prop\nh : ∀ {x : α}, q x → p x\na✝ : Subtype q\n⊢ Eq ↑↑((Equiv.subtypeSubtypeEquivSubtype h).symm a✝) ↑a✝","decl":"/-- If the outer subtype has more restrictive predicate than the inner one,\nthen we can drop the latter. -/\n@[simps!]\ndef subtypeSubtypeEquivSubtype {α} {p q : α → Prop} (h : ∀ {x}, q x → p x) :\n    { x : Subtype p // q x.1 } ≃ Subtype q :=\n  (subtypeSubtypeEquivSubtypeInter p _).trans <| subtypeEquivRight fun _ => and_iff_right_of_imp h\n\n"}
{"name":"Equiv.subtypeSubtypeEquivSubtype_apply_coe","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\np q : α → Prop\nh : ∀ {x : α}, q x → p x\na✝ : Subtype fun x => q ↑x\n⊢ Eq ↑((Equiv.subtypeSubtypeEquivSubtype h) a✝) ↑↑a✝","decl":"/-- If the outer subtype has more restrictive predicate than the inner one,\nthen we can drop the latter. -/\n@[simps!]\ndef subtypeSubtypeEquivSubtype {α} {p q : α → Prop} (h : ∀ {x}, q x → p x) :\n    { x : Subtype p // q x.1 } ≃ Subtype q :=\n  (subtypeSubtypeEquivSubtypeInter p _).trans <| subtypeEquivRight fun _ => and_iff_right_of_imp h\n\n"}
{"name":"Equiv.subtypeUnivEquiv_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\np : α → Prop\nh : ∀ (x : α), p x\nx : Subtype p\n⊢ Eq ((Equiv.subtypeUnivEquiv h) x) ↑x","decl":"/-- If a proposition holds for all elements, then the subtype is\nequivalent to the original type. -/\n@[simps apply symm_apply]\ndef subtypeUnivEquiv {α} {p : α → Prop} (h : ∀ x, p x) : Subtype p ≃ α :=\n  ⟨fun x => x, fun x => ⟨x, h x⟩, fun _ => Subtype.eq rfl, fun _ => rfl⟩\n\n"}
{"name":"Equiv.subtypeUnivEquiv_symm_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\np : α → Prop\nh : ∀ (x : α), p x\nx : α\n⊢ Eq ((Equiv.subtypeUnivEquiv h).symm x) ⟨x, ⋯⟩","decl":"/-- If a proposition holds for all elements, then the subtype is\nequivalent to the original type. -/\n@[simps apply symm_apply]\ndef subtypeUnivEquiv {α} {p : α → Prop} (h : ∀ x, p x) : Subtype p ≃ α :=\n  ⟨fun x => x, fun x => ⟨x, h x⟩, fun _ => Subtype.eq rfl, fun _ => rfl⟩\n\n"}
{"name":"Equiv.piEquivPiSubtypeProd_symm_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\np : α → Prop\nβ : α → Type u_10\ninst✝ : DecidablePred p\nf : Prod ((i : Subtype fun x => p x) → β ↑i) ((i : Subtype fun x => Not (p x)) → β ↑i)\nx : α\n⊢ Eq ((Equiv.piEquivPiSubtypeProd p β).symm f x) (dite (p x) (fun h => f.1 ⟨x, h⟩) fun h => f.2 ⟨x, h⟩)","decl":"/-- The type `∀ (i : α), β i` can be split as a product by separating the indices in `α`\ndepending on whether they satisfy a predicate `p` or not. -/\n@[simps]\ndef piEquivPiSubtypeProd {α : Type*} (p : α → Prop) (β : α → Type*) [DecidablePred p] :\n    (∀ i : α, β i) ≃ (∀ i : { x // p x }, β i) × ∀ i : { x // ¬p x }, β i where\n  toFun f := (fun x => f x, fun x => f x)\n  invFun f x := if h : p x then f.1 ⟨x, h⟩ else f.2 ⟨x, h⟩\n  right_inv := by\n    rintro ⟨f, g⟩\n    ext1 <;>\n      · ext y\n        rcases y with ⟨val, property⟩\n        simp only [property, dif_pos, dif_neg, not_false_iff, Subtype.coe_mk]\n  left_inv f := by\n    ext x\n    by_cases h : p x <;>\n      · simp only [h, dif_neg, dif_pos, not_false_iff]\n\n"}
{"name":"Equiv.piEquivPiSubtypeProd_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\np : α → Prop\nβ : α → Type u_10\ninst✝ : DecidablePred p\nf : (i : α) → β i\n⊢ Eq ((Equiv.piEquivPiSubtypeProd p β) f) { fst := fun x => f ↑x, snd := fun x => f ↑x }","decl":"/-- The type `∀ (i : α), β i` can be split as a product by separating the indices in `α`\ndepending on whether they satisfy a predicate `p` or not. -/\n@[simps]\ndef piEquivPiSubtypeProd {α : Type*} (p : α → Prop) (β : α → Type*) [DecidablePred p] :\n    (∀ i : α, β i) ≃ (∀ i : { x // p x }, β i) × ∀ i : { x // ¬p x }, β i where\n  toFun f := (fun x => f x, fun x => f x)\n  invFun f x := if h : p x then f.1 ⟨x, h⟩ else f.2 ⟨x, h⟩\n  right_inv := by\n    rintro ⟨f, g⟩\n    ext1 <;>\n      · ext y\n        rcases y with ⟨val, property⟩\n        simp only [property, dif_pos, dif_neg, not_false_iff, Subtype.coe_mk]\n  left_inv f := by\n    ext x\n    by_cases h : p x <;>\n      · simp only [h, dif_neg, dif_pos, not_false_iff]\n\n"}
{"name":"Equiv.piSplitAt_symm_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\ninst✝ : DecidableEq α\ni : α\nβ : α → Type u_10\nf : Prod (β i) ((j : Subtype fun j => Ne j i) → β ↑j)\nj : α\n⊢ Eq ((Equiv.piSplitAt i β).symm f j) (dite (Eq j i) (fun h => Eq.rec f.1 ⋯) fun h => f.2 ⟨j, h⟩)","decl":"/-- A product of types can be split as the binary product of one of the types and the product\n  of all the remaining types. -/\n@[simps]\ndef piSplitAt {α : Type*} [DecidableEq α] (i : α) (β : α → Type*) :\n    (∀ j, β j) ≃ β i × ∀ j : { j // j ≠ i }, β j where\n  toFun f := ⟨f i, fun j => f j⟩\n  invFun f j := if h : j = i then h.symm.rec f.1 else f.2 ⟨j, h⟩\n  right_inv f := by\n    ext x\n    exacts [dif_pos rfl, (dif_neg x.2).trans (by cases x; rfl)]\n  left_inv f := by\n    ext x\n    dsimp only\n    split_ifs with h\n    · subst h; rfl\n    · rfl\n\n"}
{"name":"Equiv.piSplitAt_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\ninst✝ : DecidableEq α\ni : α\nβ : α → Type u_10\nf : (j : α) → β j\n⊢ Eq ((Equiv.piSplitAt i β) f) { fst := f i, snd := fun j => f ↑j }","decl":"/-- A product of types can be split as the binary product of one of the types and the product\n  of all the remaining types. -/\n@[simps]\ndef piSplitAt {α : Type*} [DecidableEq α] (i : α) (β : α → Type*) :\n    (∀ j, β j) ≃ β i × ∀ j : { j // j ≠ i }, β j where\n  toFun f := ⟨f i, fun j => f j⟩\n  invFun f j := if h : j = i then h.symm.rec f.1 else f.2 ⟨j, h⟩\n  right_inv f := by\n    ext x\n    exacts [dif_pos rfl, (dif_neg x.2).trans (by cases x; rfl)]\n  left_inv f := by\n    ext x\n    dsimp only\n    split_ifs with h\n    · subst h; rfl\n    · rfl\n\n"}
{"name":"Equiv.funSplitAt_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\ninst✝ : DecidableEq α\ni : α\nβ : Type u_10\nf : (j : α) → (fun a => β) j\n⊢ Eq ((Equiv.funSplitAt i β) f) { fst := f i, snd := fun j => f ↑j }","decl":"/-- A product of copies of a type can be split as the binary product of one copy and the product\n  of all the remaining copies. -/\n@[simps!]\ndef funSplitAt {α : Type*} [DecidableEq α] (i : α) (β : Type*) :\n    (α → β) ≃ β × ({ j // j ≠ i } → β) :=\n  piSplitAt i _\n\n"}
{"name":"Equiv.funSplitAt_symm_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\ninst✝ : DecidableEq α\ni : α\nβ : Type u_10\nf : Prod ((fun a => β) i) ((j : Subtype fun j => Ne j i) → (fun a => β) ↑j)\nj : α\n⊢ Eq ((Equiv.funSplitAt i β).symm f j) (dite (Eq j i) (fun h => f.1) fun h => f.2 ⟨j, ⋯⟩)","decl":"/-- A product of copies of a type can be split as the binary product of one copy and the product\n  of all the remaining copies. -/\n@[simps!]\ndef funSplitAt {α : Type*} [DecidableEq α] (i : α) (β : Type*) :\n    (α → β) ≃ β × ({ j // j ≠ i } → β) :=\n  piSplitAt i _\n\n"}
{"name":"Equiv.coe_subtypeEquivCodomain","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"X : Sort u_9\nY : Sort u_10\ninst✝ : DecidableEq X\nx : X\nf : (Subtype fun x' => Ne x' x) → Y\n⊢ Eq ⇑(Equiv.subtypeEquivCodomain f) fun g => ↑g x","decl":"@[simp]\ntheorem coe_subtypeEquivCodomain (f : { x' // x' ≠ x } → Y) :\n    (subtypeEquivCodomain f : _ → Y) =\n      fun g : { g : X → Y // g ∘ (↑) = f } => (g : X → Y) x :=\n  rfl\n\n"}
{"name":"Equiv.subtypeEquivCodomain_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"X : Sort u_9\nY : Sort u_10\ninst✝ : DecidableEq X\nx : X\nf : (Subtype fun x' => Ne x' x) → Y\ng : Subtype fun g => Eq (Function.comp g Subtype.val) f\n⊢ Eq ((Equiv.subtypeEquivCodomain f) g) (↑g x)","decl":"@[simp]\ntheorem subtypeEquivCodomain_apply (f : { x' // x' ≠ x } → Y) (g) :\n    subtypeEquivCodomain f g = (g : X → Y) x :=\n  rfl\n\n"}
{"name":"Equiv.coe_subtypeEquivCodomain_symm","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"X : Sort u_9\nY : Sort u_10\ninst✝ : DecidableEq X\nx : X\nf : (Subtype fun x' => Ne x' x) → Y\n⊢ Eq ⇑(Equiv.subtypeEquivCodomain f).symm fun y => ⟨fun x' => dite (Ne x' x) (fun h => f ⟨x', h⟩) fun h => y, ⋯⟩","decl":"theorem coe_subtypeEquivCodomain_symm (f : { x' // x' ≠ x } → Y) :\n    ((subtypeEquivCodomain f).symm : Y → _) = fun y =>\n      ⟨fun x' => if h : x' ≠ x then f ⟨x', h⟩ else y, by\n        funext x'\n        simp only [ne_eq, dite_not, comp_apply, Subtype.coe_eta, dite_eq_ite, ite_eq_right_iff]\n        intro w\n        exfalso\n        exact x'.property w⟩ :=\n  rfl\n\n"}
{"name":"Equiv.subtypeEquivCodomain_symm_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"X : Sort u_9\nY : Sort u_10\ninst✝ : DecidableEq X\nx : X\nf : (Subtype fun x' => Ne x' x) → Y\ny : Y\nx' : X\n⊢ Eq (↑((Equiv.subtypeEquivCodomain f).symm y) x') (dite (Ne x' x) (fun h => f ⟨x', h⟩) fun h => y)","decl":"@[simp]\ntheorem subtypeEquivCodomain_symm_apply (f : { x' // x' ≠ x } → Y) (y : Y) (x' : X) :\n    ((subtypeEquivCodomain f).symm y : X → Y) x' = if h : x' ≠ x then f ⟨x', h⟩ else y :=\n  rfl\n\n"}
{"name":"Equiv.subtypeEquivCodomain_symm_apply_eq","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"X : Sort u_9\nY : Sort u_10\ninst✝ : DecidableEq X\nx : X\nf : (Subtype fun x' => Ne x' x) → Y\ny : Y\n⊢ Eq (↑((Equiv.subtypeEquivCodomain f).symm y) x) y","decl":"theorem subtypeEquivCodomain_symm_apply_eq (f : { x' // x' ≠ x } → Y) (y : Y) :\n    ((subtypeEquivCodomain f).symm y : X → Y) x = y :=\n  dif_neg (not_not.mpr rfl)\n\n"}
{"name":"Equiv.subtypeEquivCodomain_symm_apply_ne","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"X : Sort u_9\nY : Sort u_10\ninst✝ : DecidableEq X\nx : X\nf : (Subtype fun x' => Ne x' x) → Y\ny : Y\nx' : X\nh : Ne x' x\n⊢ Eq (↑((Equiv.subtypeEquivCodomain f).symm y) x') (f ⟨x', h⟩)","decl":"theorem subtypeEquivCodomain_symm_apply_ne\n    (f : { x' // x' ≠ x } → Y) (y : Y) (x' : X) (h : x' ≠ x) :\n    ((subtypeEquivCodomain f).symm y : X → Y) x' = f ⟨x', h⟩ :=\n  dif_pos h\n\n"}
{"name":"Equiv.instCanLiftForallCoeBijective","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_4\n⊢ CanLift (α → β) (Equiv α β) DFunLike.coe Function.Bijective","decl":"instance : CanLift (α → β) (α ≃ β) (↑) Bijective where prf f hf := ⟨ofBijective f hf, rfl⟩\n\n"}
{"name":"Equiv.Perm.extendDomain_apply_image","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α' : Type u_9\nβ' : Type u_10\ne : Equiv.Perm α'\np : β' → Prop\ninst✝ : DecidablePred p\nf : Equiv α' (Subtype p)\na : α'\n⊢ Eq ((e.extendDomain f) ↑(f a)) ↑(f (e a))","decl":"@[simp]\ntheorem Perm.extendDomain_apply_image (a : α') : e.extendDomain f (f a) = f (e a) := by\n  simp [Perm.extendDomain]\n\n"}
{"name":"Equiv.Perm.extendDomain_apply_subtype","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α' : Type u_9\nβ' : Type u_10\ne : Equiv.Perm α'\np : β' → Prop\ninst✝ : DecidablePred p\nf : Equiv α' (Subtype p)\nb : β'\nh : p b\n⊢ Eq ((e.extendDomain f) b) ↑(f (e (f.symm ⟨b, h⟩)))","decl":"theorem Perm.extendDomain_apply_subtype {b : β'} (h : p b) :\n    e.extendDomain f b = f (e (f.symm ⟨b, h⟩)) := by\n  simp [Perm.extendDomain, h]\n\n"}
{"name":"Equiv.Perm.extendDomain_apply_not_subtype","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α' : Type u_9\nβ' : Type u_10\ne : Equiv.Perm α'\np : β' → Prop\ninst✝ : DecidablePred p\nf : Equiv α' (Subtype p)\nb : β'\nh : Not (p b)\n⊢ Eq ((e.extendDomain f) b) b","decl":"theorem Perm.extendDomain_apply_not_subtype {b : β'} (h : ¬p b) : e.extendDomain f b = b := by\n  simp [Perm.extendDomain, h]\n\n"}
{"name":"Equiv.Perm.extendDomain_refl","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α' : Type u_9\nβ' : Type u_10\np : β' → Prop\ninst✝ : DecidablePred p\nf : Equiv α' (Subtype p)\n⊢ Eq (Equiv.Perm.extendDomain (Equiv.refl α') f) (Equiv.refl β')","decl":"@[simp]\ntheorem Perm.extendDomain_refl : Perm.extendDomain (Equiv.refl _) f = Equiv.refl _ := by\n  simp [Perm.extendDomain]\n\n"}
{"name":"Equiv.Perm.extendDomain_symm","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α' : Type u_9\nβ' : Type u_10\ne : Equiv.Perm α'\np : β' → Prop\ninst✝ : DecidablePred p\nf : Equiv α' (Subtype p)\n⊢ Eq (Equiv.symm (e.extendDomain f)) (Equiv.Perm.extendDomain (Equiv.symm e) f)","decl":"@[simp]\ntheorem Perm.extendDomain_symm : (e.extendDomain f).symm = Perm.extendDomain e.symm f :=\n  rfl\n\n"}
{"name":"Equiv.Perm.extendDomain_trans","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α' : Type u_9\nβ' : Type u_10\np : β' → Prop\ninst✝ : DecidablePred p\nf : Equiv α' (Subtype p)\ne e' : Equiv.Perm α'\n⊢ Eq (Equiv.trans (e.extendDomain f) (e'.extendDomain f)) (Equiv.Perm.extendDomain (Equiv.trans e e') f)","decl":"theorem Perm.extendDomain_trans (e e' : Perm α') :\n    (e.extendDomain f).trans (e'.extendDomain f) = Perm.extendDomain (e.trans e') f := by\n  simp [Perm.extendDomain, permCongr_trans]\n\n"}
{"name":"Equiv.subtypeQuotientEquivQuotientSubtype_mk","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\np₁ : α → Prop\ns₁ : Setoid α\ns₂ : Setoid (Subtype p₁)\np₂ : Quotient s₁ → Prop\nhp₂ : ∀ (a : α), Iff (p₁ a) (p₂ (Quotient.mk s₁ a))\nh : ∀ (x y : Subtype p₁), Iff (s₂ x y) (HasEquiv.Equiv ↑x ↑y)\nx : α\nhx : p₂ (Quotient.mk s₁ x)\n⊢ Eq ((Equiv.subtypeQuotientEquivQuotientSubtype p₁ p₂ hp₂ h) ⟨Quotient.mk s₁ x, hx⟩) (Quotient.mk s₂ ⟨x, ⋯⟩)","decl":"@[simp]\ntheorem subtypeQuotientEquivQuotientSubtype_mk (p₁ : α → Prop)\n    [s₁ : Setoid α] [s₂ : Setoid (Subtype p₁)] (p₂ : Quotient s₁ → Prop) (hp₂ : ∀ a, p₁ a ↔ p₂ ⟦a⟧)\n    (h : ∀ x y : Subtype p₁, s₂ x y ↔ (x : α) ≈ y)\n    (x hx) : subtypeQuotientEquivQuotientSubtype p₁ p₂ hp₂ h ⟨⟦x⟧, hx⟩ = ⟦⟨x, (hp₂ _).2 hx⟩⟧ :=\n  rfl\n\n"}
{"name":"Equiv.subtypeQuotientEquivQuotientSubtype_symm_mk","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\np₁ : α → Prop\ns₁ : Setoid α\ns₂ : Setoid (Subtype p₁)\np₂ : Quotient s₁ → Prop\nhp₂ : ∀ (a : α), Iff (p₁ a) (p₂ (Quotient.mk s₁ a))\nh : ∀ (x y : Subtype p₁), Iff (s₂ x y) (HasEquiv.Equiv ↑x ↑y)\nx : Subtype p₁\n⊢ Eq ((Equiv.subtypeQuotientEquivQuotientSubtype p₁ p₂ hp₂ h).symm (Quotient.mk s₂ x)) ⟨Quotient.mk s₁ ↑x, ⋯⟩","decl":"@[simp]\ntheorem subtypeQuotientEquivQuotientSubtype_symm_mk (p₁ : α → Prop)\n    [s₁ : Setoid α] [s₂ : Setoid (Subtype p₁)] (p₂ : Quotient s₁ → Prop) (hp₂ : ∀ a, p₁ a ↔ p₂ ⟦a⟧)\n    (h : ∀ x y : Subtype p₁, s₂ x y ↔ (x : α) ≈ y) (x) :\n    (subtypeQuotientEquivQuotientSubtype p₁ p₂ hp₂ h).symm ⟦x⟧ = ⟨⟦x⟧, (hp₂ _).1 x.property⟩ :=\n  rfl\n\n"}
{"name":"Equiv.swapCore_self","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\ninst✝ : DecidableEq α\nr a : α\n⊢ Eq (Equiv.swapCore a a r) r","decl":"theorem swapCore_self (r a : α) : swapCore a a r = r := by\n  unfold swapCore\n  split_ifs <;> simp [*]\n\n"}
{"name":"Equiv.swapCore_swapCore","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\ninst✝ : DecidableEq α\nr a b : α\n⊢ Eq (Equiv.swapCore a b (Equiv.swapCore a b r)) r","decl":"theorem swapCore_swapCore (r a b : α) : swapCore a b (swapCore a b r) = r := by\n  unfold swapCore; split_ifs <;> cc\n\n"}
{"name":"Equiv.swapCore_comm","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\ninst✝ : DecidableEq α\nr a b : α\n⊢ Eq (Equiv.swapCore a b r) (Equiv.swapCore b a r)","decl":"theorem swapCore_comm (r a b : α) : swapCore a b r = swapCore b a r := by\n  unfold swapCore\n  -- Porting note: whatever solution works for `swapCore_swapCore` will work here too.\n  split_ifs with h₁ h₂ h₃ <;> try simp\n  · cases h₁; cases h₂; rfl\n\n"}
{"name":"Equiv.swap_self","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\ninst✝ : DecidableEq α\na : α\n⊢ Eq (Equiv.swap a a) (Equiv.refl α)","decl":"@[simp]\ntheorem swap_self (a : α) : swap a a = Equiv.refl _ :=\n  ext fun r => swapCore_self r a\n\n"}
{"name":"Equiv.swap_comm","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\ninst✝ : DecidableEq α\na b : α\n⊢ Eq (Equiv.swap a b) (Equiv.swap b a)","decl":"theorem swap_comm (a b : α) : swap a b = swap b a :=\n  ext fun r => swapCore_comm r _ _\n\n"}
{"name":"Equiv.swap_apply_def","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\ninst✝ : DecidableEq α\na b x : α\n⊢ Eq ((Equiv.swap a b) x) (ite (Eq x a) b (ite (Eq x b) a x))","decl":"theorem swap_apply_def (a b x : α) : swap a b x = if x = a then b else if x = b then a else x :=\n  rfl\n\n"}
{"name":"Equiv.swap_apply_left","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\ninst✝ : DecidableEq α\na b : α\n⊢ Eq ((Equiv.swap a b) a) b","decl":"@[simp]\ntheorem swap_apply_left (a b : α) : swap a b a = b :=\n  if_pos rfl\n\n"}
{"name":"Equiv.swap_apply_right","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\ninst✝ : DecidableEq α\na b : α\n⊢ Eq ((Equiv.swap a b) b) a","decl":"@[simp]\ntheorem swap_apply_right (a b : α) : swap a b b = a := by\n  by_cases h : b = a <;> simp [swap_apply_def, h]\n\n"}
{"name":"Equiv.swap_apply_of_ne_of_ne","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\ninst✝ : DecidableEq α\na b x : α\na✝¹ : Ne x a\na✝ : Ne x b\n⊢ Eq ((Equiv.swap a b) x) x","decl":"theorem swap_apply_of_ne_of_ne {a b x : α} : x ≠ a → x ≠ b → swap a b x = x := by\n  simp +contextual [swap_apply_def]\n\n"}
{"name":"Equiv.eq_or_eq_of_swap_apply_ne_self","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\ninst✝ : DecidableEq α\na b x : α\nh : Ne ((Equiv.swap a b) x) x\n⊢ Or (Eq x a) (Eq x b)","decl":"theorem eq_or_eq_of_swap_apply_ne_self {a b x : α} (h : swap a b x ≠ x) : x = a ∨ x = b := by\n  contrapose! h\n  exact swap_apply_of_ne_of_ne h.1 h.2\n\n"}
{"name":"Equiv.swap_swap","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\ninst✝ : DecidableEq α\na b : α\n⊢ Eq (Equiv.trans (Equiv.swap a b) (Equiv.swap a b)) (Equiv.refl α)","decl":"@[simp]\ntheorem swap_swap (a b : α) : (swap a b).trans (swap a b) = Equiv.refl _ :=\n  ext fun _ => swapCore_swapCore _ _ _\n\n"}
{"name":"Equiv.symm_swap","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\ninst✝ : DecidableEq α\na b : α\n⊢ Eq (Equiv.symm (Equiv.swap a b)) (Equiv.swap a b)","decl":"@[simp]\ntheorem symm_swap (a b : α) : (swap a b).symm = swap a b :=\n  rfl\n\n"}
{"name":"Equiv.swap_eq_refl_iff","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\ninst✝ : DecidableEq α\nx y : α\n⊢ Iff (Eq (Equiv.swap x y) (Equiv.refl α)) (Eq x y)","decl":"@[simp]\ntheorem swap_eq_refl_iff {x y : α} : swap x y = Equiv.refl _ ↔ x = y := by\n  refine ⟨fun h => (Equiv.refl _).injective ?_, fun h => h ▸ swap_self _⟩\n  rw [← h, swap_apply_left, h, refl_apply]\n\n"}
{"name":"Equiv.swap_comp_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\ninst✝ : DecidableEq α\na b x : α\nπ : Equiv.Perm α\n⊢ Eq ((Equiv.trans π (Equiv.swap a b)) x) (ite (Eq (π x) a) b (ite (Eq (π x) b) a (π x)))","decl":"theorem swap_comp_apply {a b x : α} (π : Perm α) :\n    π.trans (swap a b) x = if π x = a then b else if π x = b then a else π x := by\n  cases π\n  rfl\n\n"}
{"name":"Equiv.swap_eq_update","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\ninst✝ : DecidableEq α\ni j : α\n⊢ Eq (⇑(Equiv.swap i j)) (Function.update (Function.update id j i) i j)","decl":"theorem swap_eq_update (i j : α) : (Equiv.swap i j : α → α) = update (update id j i) i j :=\n  funext fun x => by rw [update_apply _ i j, update_apply _ j i, Equiv.swap_apply_def, id]\n\n"}
{"name":"Equiv.comp_swap_eq_update","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_4\ninst✝ : DecidableEq α\ni j : α\nf : α → β\n⊢ Eq (Function.comp f ⇑(Equiv.swap i j)) (Function.update (Function.update f j (f i)) i (f j))","decl":"theorem comp_swap_eq_update (i j : α) (f : α → β) :\n    f ∘ Equiv.swap i j = update (update f j (f i)) i (f j) := by\n  rw [swap_eq_update, comp_update, comp_update, comp_id]\n\n"}
{"name":"Equiv.symm_trans_swap_trans","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_4\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\na b : α\ne : Equiv α β\n⊢ Eq ((e.symm.trans (Equiv.swap a b)).trans e) (Equiv.swap (e a) (e b))","decl":"@[simp]\ntheorem symm_trans_swap_trans [DecidableEq β] (a b : α) (e : α ≃ β) :\n    (e.symm.trans (swap a b)).trans e = swap (e a) (e b) :=\n  Equiv.ext fun x => by\n    have : ∀ a, e.symm x = a ↔ x = e a := fun a => by\n      rw [@eq_comm _ (e.symm x)]\n      constructor <;> intros <;> simp_all\n    simp only [trans_apply, swap_apply_def, this]\n    split_ifs <;> simp\n\n"}
{"name":"Equiv.trans_swap_trans_symm","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_4\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\na b : β\ne : Equiv α β\n⊢ Eq ((e.trans (Equiv.swap a b)).trans e.symm) (Equiv.swap (e.symm a) (e.symm b))","decl":"@[simp]\ntheorem trans_swap_trans_symm [DecidableEq β] (a b : β) (e : α ≃ β) :\n    (e.trans (swap a b)).trans e.symm = swap (e.symm a) (e.symm b) :=\n  symm_trans_swap_trans a b e.symm\n\n"}
{"name":"Equiv.swap_apply_self","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\ninst✝ : DecidableEq α\ni j a : α\n⊢ Eq ((Equiv.swap i j) ((Equiv.swap i j) a)) a","decl":"@[simp]\ntheorem swap_apply_self (i j a : α) : swap i j (swap i j a) = a := by\n  rw [← Equiv.trans_apply, Equiv.swap_swap, Equiv.refl_apply]\n\n"}
{"name":"Equiv.apply_swap_eq_self","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_4\ninst✝ : DecidableEq α\nv : α → β\ni j : α\nhv : Eq (v i) (v j)\nk : α\n⊢ Eq (v ((Equiv.swap i j) k)) (v k)","decl":"/-- A function is invariant to a swap if it is equal at both elements -/\ntheorem apply_swap_eq_self {v : α → β} {i j : α} (hv : v i = v j) (k : α) :\n    v (swap i j k) = v k := by\n  by_cases hi : k = i\n  · rw [hi, swap_apply_left, hv]\n\n  by_cases hj : k = j\n  · rw [hj, swap_apply_right, hv]\n\n  rw [swap_apply_of_ne_of_ne hi hj]\n\n"}
{"name":"Equiv.swap_apply_eq_iff","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\ninst✝ : DecidableEq α\nx y z w : α\n⊢ Iff (Eq ((Equiv.swap x y) z) w) (Eq z ((Equiv.swap x y) w))","decl":"theorem swap_apply_eq_iff {x y z w : α} : swap x y z = w ↔ z = swap x y w := by\n  rw [apply_eq_iff_eq_symm_apply, symm_swap]\n\n"}
{"name":"Equiv.swap_apply_ne_self_iff","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\ninst✝ : DecidableEq α\na b x : α\n⊢ Iff (Ne ((Equiv.swap a b) x) x) (And (Ne a b) (Or (Eq x a) (Eq x b)))","decl":"theorem swap_apply_ne_self_iff {a b x : α} : swap a b x ≠ x ↔ a ≠ b ∧ (x = a ∨ x = b) := by\n  by_cases hab : a = b\n  · simp [hab]\n\n  by_cases hax : x = a\n  · simp [hax, eq_comm]\n\n  by_cases hbx : x = b\n  · simp [hbx]\n\n  simp [hab, hax, hbx, swap_apply_of_ne_of_ne]\n\n"}
{"name":"Equiv.Perm.sumCongr_swap_refl","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\ni j : α\n⊢ Eq ((Equiv.swap i j).sumCongr (Equiv.refl β)) (Equiv.swap (Sum.inl i) (Sum.inl j))","decl":"@[simp]\ntheorem sumCongr_swap_refl {α β : Sort _} [DecidableEq α] [DecidableEq β] (i j : α) :\n    Equiv.Perm.sumCongr (Equiv.swap i j) (Equiv.refl β) = Equiv.swap (Sum.inl i) (Sum.inl j) := by\n  ext x\n  cases x\n  · simp only [Equiv.sumCongr_apply, Sum.map, coe_refl, comp_id, Sum.elim_inl, comp_apply,\n      swap_apply_def, Sum.inl.injEq]\n    split_ifs <;> rfl\n  · simp [Sum.map, swap_apply_of_ne_of_ne]\n\n"}
{"name":"Equiv.Perm.sumCongr_refl_swap","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\ni j : β\n⊢ Eq (Equiv.Perm.sumCongr (Equiv.refl α) (Equiv.swap i j)) (Equiv.swap (Sum.inr i) (Sum.inr j))","decl":"@[simp]\ntheorem sumCongr_refl_swap {α β : Sort _} [DecidableEq α] [DecidableEq β] (i j : β) :\n    Equiv.Perm.sumCongr (Equiv.refl α) (Equiv.swap i j) = Equiv.swap (Sum.inr i) (Sum.inr j) := by\n  ext x\n  cases x\n  · simp [Sum.map, swap_apply_of_ne_of_ne]\n\n  · simp only [Equiv.sumCongr_apply, Sum.map, coe_refl, comp_id, Sum.elim_inr, comp_apply,\n      swap_apply_def, Sum.inr.injEq]\n    split_ifs <;> rfl\n\n"}
{"name":"Equiv.setValue_eq","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_4\ninst✝ : DecidableEq α\nf : Equiv α β\na : α\nb : β\n⊢ Eq ((f.setValue a b) a) b","decl":"@[simp]\ntheorem setValue_eq (f : α ≃ β) (a : α) (b : β) : setValue f a b a = b := by\n  simp [setValue, swap_apply_left]\n\n"}
{"name":"Function.Involutive.coe_toPerm","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\nf : α → α\nh : Function.Involutive f\n⊢ Eq (⇑(Function.Involutive.toPerm f h)) f","decl":"@[simp]\ntheorem coe_toPerm {f : α → α} (h : Involutive f) : (h.toPerm f : α → α) = f :=\n  rfl\n\n"}
{"name":"Function.Involutive.toPerm_symm","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\nf : α → α\nh : Function.Involutive f\n⊢ Eq (Equiv.symm (Function.Involutive.toPerm f h)) (Function.Involutive.toPerm f h)","decl":"@[simp]\ntheorem toPerm_symm {f : α → α} (h : Involutive f) : (h.toPerm f).symm = h.toPerm f :=\n  rfl\n\n"}
{"name":"Function.Involutive.toPerm_involutive","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\nf : α → α\nh : Function.Involutive f\n⊢ Function.Involutive ⇑(Function.Involutive.toPerm f h)","decl":"theorem toPerm_involutive {f : α → α} (h : Involutive f) : Involutive (h.toPerm f) :=\n  h\n\n"}
{"name":"Function.Involutive.symm_eq_self_of_involutive","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\nf : Equiv.Perm α\nh : Function.Involutive ⇑f\n⊢ Eq (Equiv.symm f) f","decl":"theorem symm_eq_self_of_involutive (f : Equiv.Perm α) (h : Involutive f) : f.symm = f :=\n  DFunLike.coe_injective (h.leftInverse_iff.mp f.left_inv)\n\n"}
{"name":"PLift.eq_up_iff_down_eq","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\nx : PLift α\ny : α\n⊢ Iff (Eq x { down := y }) (Eq x.down y)","decl":"theorem PLift.eq_up_iff_down_eq {x : PLift α} {y : α} : x = PLift.up y ↔ x.down = y :=\n  Equiv.plift.eq_symm_apply\n\n"}
{"name":"Function.Injective.map_swap","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_4\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\nf : α → β\nhf : Function.Injective f\nx y z : α\n⊢ Eq (f ((Equiv.swap x y) z)) ((Equiv.swap (f x) (f y)) (f z))","decl":"theorem Function.Injective.map_swap [DecidableEq α] [DecidableEq β] {f : α → β}\n    (hf : Function.Injective f) (x y z : α) :\n    f (Equiv.swap x y z) = Equiv.swap (f x) (f y) (f z) := by\n  conv_rhs => rw [Equiv.swap_apply_def]\n  split_ifs with h₁ h₂\n  · rw [hf h₁, Equiv.swap_apply_left]\n  · rw [hf h₂, Equiv.swap_apply_right]\n  · rw [Equiv.swap_apply_of_ne_of_ne (mt (congr_arg f) h₁) (mt (congr_arg f) h₂)]\n\n"}
{"name":"Equiv.piCongrLeft'_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_4\nP : α → Sort u_9\ne : Equiv α β\nf : (a : α) → P a\nx : β\n⊢ Eq ((Equiv.piCongrLeft' P e) f x) (f (e.symm x))","decl":"/-- Transport dependent functions through an equivalence of the base space.\n-/\n@[simps apply, simps (config := .lemmasOnly) symm_apply]\ndef piCongrLeft' (P : α → Sort*) (e : α ≃ β) : (∀ a, P a) ≃ ∀ b, P (e.symm b) where\n  toFun f x := f (e.symm x)\n  invFun f x := (e.symm_apply_apply x).ndrec (f (e x))\n  left_inv f := funext fun x =>\n    (by rintro _ rfl; rfl : ∀ {y} (h : y = x), h.ndrec (f y) = f x) (e.symm_apply_apply x)\n  right_inv f := funext fun x =>\n    (by rintro _ rfl; rfl : ∀ {y} (h : y = x), (congr_arg e.symm h).ndrec (f y) = f x)\n      (e.apply_symm_apply x)\n\n"}
{"name":"Equiv.piCongrLeft'_symm_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_4\nP : α → Sort u_9\ne : Equiv α β\nf : (b : β) → P (e.symm b)\nx : α\n⊢ Eq ((Equiv.piCongrLeft' P e).symm f x) (Eq.ndrec (f (e x)) ⋯)","decl":"/-- Transport dependent functions through an equivalence of the base space.\n-/\n@[simps apply, simps (config := .lemmasOnly) symm_apply]\ndef piCongrLeft' (P : α → Sort*) (e : α ≃ β) : (∀ a, P a) ≃ ∀ b, P (e.symm b) where\n  toFun f x := f (e.symm x)\n  invFun f x := (e.symm_apply_apply x).ndrec (f (e x))\n  left_inv f := funext fun x =>\n    (by rintro _ rfl; rfl : ∀ {y} (h : y = x), h.ndrec (f y) = f x) (e.symm_apply_apply x)\n  right_inv f := funext fun x =>\n    (by rintro _ rfl; rfl : ∀ {y} (h : y = x), (congr_arg e.symm h).ndrec (f y) = f x)\n      (e.apply_symm_apply x)\n\n"}
{"name":"Equiv.piCongrLeft'_symm","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_4\nP : Sort u_9\ne : Equiv α β\n⊢ Eq (Equiv.piCongrLeft' (fun x => P) e).symm (Equiv.piCongrLeft' (fun a => P) e.symm)","decl":"/-- This lemma is impractical to state in the dependent case. -/\n@[simp]\ntheorem piCongrLeft'_symm (P : Sort*) (e : α ≃ β) :\n    (piCongrLeft' (fun _ => P) e).symm = piCongrLeft' _ e.symm := by ext; simp [piCongrLeft']\n\n"}
{"name":"Equiv.piCongrLeft'_symm_apply_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_4\nP : α → Sort u_9\ne : Equiv α β\ng : (b : β) → P (e.symm b)\nb : β\n⊢ Eq ((Equiv.piCongrLeft' P e).symm g (e.symm b)) (g b)","decl":"/-- Note: the \"obvious\" statement `(piCongrLeft' P e).symm g a = g (e a)` doesn't typecheck: the\nLHS would have type `P a` while the RHS would have type `P (e.symm (e a))`. This lemma is a way\naround it in the case where `a` is of the form `e.symm b`, so we can use `g b` instead of\n`g (e (e.symm b))`. -/\n@[simp]\nlemma piCongrLeft'_symm_apply_apply (P : α → Sort*) (e : α ≃ β) (g : ∀ b, P (e.symm b)) (b : β) :\n    (piCongrLeft' P e).symm g (e.symm b) = g b := by\n  rw [piCongrLeft'_symm_apply, ← heq_iff_eq, rec_heq_iff_heq]\n  exact congr_arg_heq _ (e.apply_symm_apply _)\n\n"}
{"name":"Equiv.piCongrLeft_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_4\nP : β → Sort w\ne : Equiv α β\nf : (a : α) → P (e a)\nb : β\n⊢ Eq ((Equiv.piCongrLeft P e) f b) (Eq.rec (f (e.symm b)) ⋯)","decl":"/-- Note: the \"obvious\" statement `(piCongrLeft P e) f b = f (e.symm b)` doesn't typecheck: the\nLHS would have type `P b` while the RHS would have type `P (e (e.symm b))`. For that reason,\nwe have to explicitly substitute along `e (e.symm b) = b` in the statement of this lemma. -/\n@[simp]\nlemma piCongrLeft_apply (f : ∀ a, P (e a)) (b : β) :\n    (piCongrLeft P e) f b = e.apply_symm_apply b ▸ f (e.symm b) :=\n  rfl\n\n"}
{"name":"Equiv.piCongrLeft_symm_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_4\nP : β → Sort w\ne : Equiv α β\ng : (b : β) → P b\na : α\n⊢ Eq ((Equiv.piCongrLeft P e).symm g a) (g (e a))","decl":"@[simp]\nlemma piCongrLeft_symm_apply (g : ∀ b, P b) (a : α) :\n    (piCongrLeft P e).symm g a = g (e a) :=\n  piCongrLeft'_apply P e.symm g a\n\n"}
{"name":"Equiv.piCongrLeft_apply_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_4\nP : β → Sort w\ne : Equiv α β\nf : (a : α) → P (e a)\na : α\n⊢ Eq ((Equiv.piCongrLeft P e) f (e a)) (f a)","decl":"/-- Note: the \"obvious\" statement `(piCongrLeft P e) f b = f (e.symm b)` doesn't typecheck: the\nLHS would have type `P b` while the RHS would have type `P (e (e.symm b))`. This lemma is a way\naround it in the case where `b` is of the form `e a`, so we can use `f a` instead of\n`f (e.symm (e a))`. -/\nlemma piCongrLeft_apply_apply (f : ∀ a, P (e a)) (a : α) :\n    (piCongrLeft P e) f (e a) = f a :=\n  piCongrLeft'_symm_apply_apply P e.symm f a\n\n"}
{"name":"Equiv.piCongrLeft_apply_eq_cast","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_4\nP : β → Sort v\ne : Equiv α β\nf : (a : α) → P (e a)\nb : β\n⊢ Eq ((Equiv.piCongrLeft P e) f b) (cast ⋯ (f (e.symm b)))","decl":"lemma piCongrLeft_apply_eq_cast {P : β → Sort v} {e : α ≃ β}\n    (f : (a : α) → P (e a)) (b : β) :\n    piCongrLeft P e f b = cast (congr_arg P (e.apply_symm_apply b)) (f (e.symm b)) :=\n  Eq.rec_eq_cast _ _\n\n"}
{"name":"Equiv.piCongrLeft_sum_inl","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"ι : Type u_10\nι' : Type u_11\nι'' : Sort u_12\nπ : ι'' → Type u_9\ne : Equiv (Sum ι ι') ι''\nf : (i : ι) → π (e (Sum.inl i))\ng : (i : ι') → π (e (Sum.inr i))\ni : ι\n⊢ Eq ((Equiv.piCongrLeft π e) ((Equiv.sumPiEquivProdPi fun x => π (e x)).symm { fst := f, snd := g }) (e (Sum.inl i))) (f i)","decl":"theorem piCongrLeft_sum_inl {ι ι' ι''} (π : ι'' → Type*) (e : ι ⊕ ι' ≃ ι'') (f : ∀ i, π (e (inl i)))\n    (g : ∀ i, π (e (inr i))) (i : ι) :\n    piCongrLeft π e (sumPiEquivProdPi (fun x => π (e x)) |>.symm (f, g)) (e (inl i)) = f i := by\n  simp_rw [piCongrLeft_apply_eq_cast, sumPiEquivProdPi_symm_apply,\n    sum_rec_congr _ _ _ (e.symm_apply_apply (inl i)), cast_cast, cast_eq]\n\n"}
{"name":"Equiv.piCongrLeft_sum_inr","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"ι : Type u_10\nι' : Type u_11\nι'' : Sort u_12\nπ : ι'' → Type u_9\ne : Equiv (Sum ι ι') ι''\nf : (i : ι) → π (e (Sum.inl i))\ng : (i : ι') → π (e (Sum.inr i))\nj : ι'\n⊢ Eq ((Equiv.piCongrLeft π e) ((Equiv.sumPiEquivProdPi fun x => π (e x)).symm { fst := f, snd := g }) (e (Sum.inr j))) (g j)","decl":"theorem piCongrLeft_sum_inr {ι ι' ι''} (π : ι'' → Type*) (e : ι ⊕ ι' ≃ ι'') (f : ∀ i, π (e (inl i)))\n    (g : ∀ i, π (e (inr i))) (j : ι') :\n    piCongrLeft π e (sumPiEquivProdPi (fun x => π (e x)) |>.symm (f, g)) (e (inr j)) = g j := by\n  simp_rw [piCongrLeft_apply_eq_cast, sumPiEquivProdPi_symm_apply,\n    sum_rec_congr _ _ _ (e.symm_apply_apply (inr j)), cast_cast, cast_eq]\n\n"}
{"name":"Equiv.coe_piCongr_symm","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_4\nW : α → Sort w\nZ : β → Sort z\nh₁ : Equiv α β\nh₂ : (a : α) → Equiv (W a) (Z (h₁ a))\n⊢ Eq ⇑(h₁.piCongr h₂).symm fun f a => (h₂ a).symm (f (h₁ a))","decl":"@[simp]\ntheorem coe_piCongr_symm : ((h₁.piCongr h₂).symm :\n    (∀ b, Z b) → ∀ a, W a) = fun f a => (h₂ a).symm (f (h₁ a)) :=\n  rfl\n\n"}
{"name":"Equiv.piCongr_symm_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_4\nW : α → Sort w\nZ : β → Sort z\nh₁ : Equiv α β\nh₂ : (a : α) → Equiv (W a) (Z (h₁ a))\nf : (b : β) → Z b\n⊢ Eq ((h₁.piCongr h₂).symm f) fun a => (h₂ a).symm (f (h₁ a))","decl":"theorem piCongr_symm_apply (f : ∀ b, Z b) :\n    (h₁.piCongr h₂).symm f = fun a => (h₂ a).symm (f (h₁ a)) :=\n  rfl\n\n"}
{"name":"Equiv.piCongr_apply_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_4\nW : α → Sort w\nZ : β → Sort z\nh₁ : Equiv α β\nh₂ : (a : α) → Equiv (W a) (Z (h₁ a))\nf : (a : α) → W a\na : α\n⊢ Eq ((h₁.piCongr h₂) f (h₁ a)) ((h₂ a) (f a))","decl":"@[simp]\ntheorem piCongr_apply_apply (f : ∀ a, W a) (a : α) : h₁.piCongr h₂ f (h₁ a) = h₂ a (f a) := by\n  simp only [piCongr, piCongrRight, trans_apply, coe_fn_mk, piCongrLeft_apply_apply, Pi.map_apply]\n\n"}
{"name":"Equiv.coe_piCongr'","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_4\nW : α → Sort w\nZ : β → Sort z\nh₁ : Equiv α β\nh₂ : (b : β) → Equiv (W (h₁.symm b)) (Z b)\n⊢ Eq ⇑(h₁.piCongr' h₂) fun f b => (h₂ b) (f (h₁.symm b))","decl":"@[simp]\ntheorem coe_piCongr' :\n    (h₁.piCongr' h₂ : (∀ a, W a) → ∀ b, Z b) = fun f b => h₂ b <| f <| h₁.symm b :=\n  rfl\n\n"}
{"name":"Equiv.piCongr'_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_4\nW : α → Sort w\nZ : β → Sort z\nh₁ : Equiv α β\nh₂ : (b : β) → Equiv (W (h₁.symm b)) (Z b)\nf : (a : α) → W a\n⊢ Eq ((h₁.piCongr' h₂) f) fun b => (h₂ b) (f (h₁.symm b))","decl":"theorem piCongr'_apply (f : ∀ a, W a) : h₁.piCongr' h₂ f = fun b => h₂ b <| f <| h₁.symm b :=\n  rfl\n\n"}
{"name":"Equiv.piCongr'_symm_apply_symm_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_4\nW : α → Sort w\nZ : β → Sort z\nh₁ : Equiv α β\nh₂ : (b : β) → Equiv (W (h₁.symm b)) (Z b)\nf : (b : β) → Z b\nb : β\n⊢ Eq ((h₁.piCongr' h₂).symm f (h₁.symm b)) ((h₂ b).symm (f b))","decl":"@[simp]\ntheorem piCongr'_symm_apply_symm_apply (f : ∀ b, Z b) (b : β) :\n    (h₁.piCongr' h₂).symm f (h₁.symm b) = (h₂ b).symm (f b) := by\n  simp [piCongr', piCongr_apply_apply]\n\n"}
{"name":"Equiv.piCongrSet_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\nW : α → Sort w\ns t : Set α\nh : Eq s t\nf : (i : Subtype fun i => Membership.mem s i) → W ↑i\ni : Subtype fun i => Membership.mem t i\n⊢ Eq ((Equiv.piCongrSet h) f i) (f ⟨↑i, ⋯⟩)","decl":"/-- Transport dependent functions through an equality of sets. -/\n@[simps!] def piCongrSet {α} {W : α → Sort w} {s t : Set α} (h : s = t) :\n    (∀ i : {i // i ∈ s}, W i) ≃ (∀ i : {i // i ∈ t}, W i) where\n  toFun f i := f ⟨i, h ▸ i.2⟩\n  invFun f i := f ⟨i, h.symm ▸ i.2⟩\n  left_inv f := rfl\n  right_inv f := rfl\n\n"}
{"name":"Equiv.piCongrSet_symm_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type u_9\nW : α → Sort w\ns t : Set α\nh : Eq s t\nf : (i : Subtype fun i => Membership.mem t i) → W ↑i\ni : Subtype fun i => Membership.mem s i\n⊢ Eq ((Equiv.piCongrSet h).symm f i) (f ⟨↑i, ⋯⟩)","decl":"/-- Transport dependent functions through an equality of sets. -/\n@[simps!] def piCongrSet {α} {W : α → Sort w} {s t : Set α} (h : s = t) :\n    (∀ i : {i // i ∈ s}, W i) ≃ (∀ i : {i // i ∈ t}, W i) where\n  toFun f i := f ⟨i, h ▸ i.2⟩\n  invFun f i := f ⟨i, h.symm ▸ i.2⟩\n  left_inv f := rfl\n  right_inv f := rfl\n\n"}
{"name":"Equiv.semiconj_conj","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α₁ : Type u_9\nβ₁ : Type u_10\ne : Equiv α₁ β₁\nf : α₁ → α₁\n⊢ Function.Semiconj (⇑e) f (e.conj f)","decl":"theorem semiconj_conj (f : α₁ → α₁) : Semiconj e f (e.conj f) := fun x => by simp\n\n"}
{"name":"Equiv.semiconj₂_conj","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α₁ : Type u_9\nβ₁ : Type u_10\ne : Equiv α₁ β₁\nf : α₁ → α₁ → α₁\n⊢ Function.Semiconj₂ (⇑e) f ((e.arrowCongr e.conj) f)","decl":"theorem semiconj₂_conj : Semiconj₂ e f (e.arrowCongr e.conj f) := fun x y => by simp [arrowCongr]\n\n"}
{"name":"Equiv.instAssociativeCoeForallForallArrowCongr","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α₁ : Type u_9\nβ₁ : Type u_10\ne : Equiv α₁ β₁\nf : α₁ → α₁ → α₁\ninst✝ : Std.Associative f\n⊢ Std.Associative ((e.arrowCongr (e.arrowCongr e)) f)","decl":"instance [Std.Associative f] : Std.Associative (e.arrowCongr (e.arrowCongr e) f) :=\n  (e.semiconj₂_conj f).isAssociative_right e.surjective\n\n"}
{"name":"Equiv.instIdempotentOpCoeForallForallArrowCongr","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α₁ : Type u_9\nβ₁ : Type u_10\ne : Equiv α₁ β₁\nf : α₁ → α₁ → α₁\ninst✝ : Std.IdempotentOp f\n⊢ Std.IdempotentOp ((e.arrowCongr (e.arrowCongr e)) f)","decl":"instance [Std.IdempotentOp f] : Std.IdempotentOp (e.arrowCongr (e.arrowCongr e) f) :=\n  (e.semiconj₂_conj f).isIdempotent_right e.surjective\n\n"}
{"name":"Equiv.ulift_symm_down","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Type v\nx : α\n⊢ Eq (Equiv.ulift.symm x).down x","decl":"@[simp]\ntheorem ulift_symm_down {α} (x : α) : (Equiv.ulift.{u, v}.symm x).down = x :=\n  rfl\n\n"}
{"name":"Function.Injective.swap_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_4\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\nf : α → β\nhf : Function.Injective f\nx y z : α\n⊢ Eq ((Equiv.swap (f x) (f y)) (f z)) (f ((Equiv.swap x y) z))","decl":"theorem Function.Injective.swap_apply\n    [DecidableEq α] [DecidableEq β] {f : α → β} (hf : Function.Injective f) (x y z : α) :\n    Equiv.swap (f x) (f y) (f z) = f (Equiv.swap x y z) := by\n  by_cases hx : z = x\n  · simp [hx]\n\n  by_cases hy : z = y\n  · simp [hy]\n\n  rw [Equiv.swap_apply_of_ne_of_ne hx hy, Equiv.swap_apply_of_ne_of_ne (hf.ne hx) (hf.ne hy)]\n\n"}
{"name":"Function.Injective.swap_comp","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_4\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\nf : α → β\nhf : Function.Injective f\nx y : α\n⊢ Eq (Function.comp (⇑(Equiv.swap (f x) (f y))) f) (Function.comp f ⇑(Equiv.swap x y))","decl":"theorem Function.Injective.swap_comp\n    [DecidableEq α] [DecidableEq β] {f : α → β} (hf : Function.Injective f) (x y : α) :\n    Equiv.swap (f x) (f y) ∘ f = f ∘ Equiv.swap x y :=\n  funext fun _ => hf.swap_apply _ _ _\n\n"}
{"name":"Function.update_comp_equiv","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_4\nα' : Sort u_9\ninst✝¹ : DecidableEq α'\ninst✝ : DecidableEq α\nf : α → β\ng : Equiv α' α\na : α\nv : β\n⊢ Eq (Function.comp (Function.update f a v) ⇑g) (Function.update (Function.comp f ⇑g) (g.symm a) v)","decl":"theorem update_comp_equiv [DecidableEq α'] [DecidableEq α] (f : α → β)\n    (g : α' ≃ α) (a : α) (v : β) :\n    update f a v ∘ g = update (f ∘ g) (g.symm a) v := by\n  rw [← update_comp_eq_of_injective _ g.injective, g.apply_symm_apply]\n\n"}
{"name":"Function.update_apply_equiv_apply","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_4\nα' : Sort u_9\ninst✝¹ : DecidableEq α'\ninst✝ : DecidableEq α\nf : α → β\ng : Equiv α' α\na : α\nv : β\na' : α'\n⊢ Eq (Function.update f a v (g a')) (Function.update (Function.comp f ⇑g) (g.symm a) v a')","decl":"theorem update_apply_equiv_apply [DecidableEq α'] [DecidableEq α] (f : α → β)\n    (g : α' ≃ α) (a : α) (v : β) (a' : α') : update f a v (g a') = update (f ∘ g) (g.symm a) v a' :=\n  congr_fun (update_comp_equiv f g a v) a'\n\n-- Porting note: EmbeddingLike.apply_eq_iff_eq broken here too\n"}
{"name":"Function.piCongrLeft'_update","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_4\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\nP : α → Sort u_10\ne : Equiv α β\nf : (a : α) → P a\nb : β\nx : P (e.symm b)\n⊢ Eq ((Equiv.piCongrLeft' P e) (Function.update f (e.symm b) x)) (Function.update ((Equiv.piCongrLeft' P e) f) b x)","decl":"theorem piCongrLeft'_update [DecidableEq α] [DecidableEq β] (P : α → Sort*) (e : α ≃ β)\n    (f : ∀ a, P a) (b : β) (x : P (e.symm b)) :\n    e.piCongrLeft' P (update f (e.symm b) x) = update (e.piCongrLeft' P f) b x := by\n  ext b'\n  rcases eq_or_ne b' b with (rfl | h)\n  · simp\n  · simp only [Equiv.piCongrLeft'_apply, ne_eq, h, not_false_iff, update_of_ne]\n    rw [update_of_ne]\n    intro h'\n    /- an example of something that should work, or also putting `EmbeddingLike.apply_eq_iff_eq`\n      in the `simp` should too:\n    have := (EmbeddingLike.apply_eq_iff_eq e).mp h' -/\n    cases e.symm.injective h' |> h\n\n"}
{"name":"Function.piCongrLeft'_symm_update","module":"Mathlib.Logic.Equiv.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_4\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\nP : α → Sort u_10\ne : Equiv α β\nf : (b : β) → P (e.symm b)\nb : β\nx : P (e.symm b)\n⊢ Eq ((Equiv.piCongrLeft' P e).symm (Function.update f b x)) (Function.update ((Equiv.piCongrLeft' P e).symm f) (e.symm b) x)","decl":"theorem piCongrLeft'_symm_update [DecidableEq α] [DecidableEq β] (P : α → Sort*) (e : α ≃ β)\n    (f : ∀ b, P (e.symm b)) (b : β) (x : P (e.symm b)) :\n    (e.piCongrLeft' P).symm (update f b x) = update ((e.piCongrLeft' P).symm f) (e.symm b) x := by\n  simp [(e.piCongrLeft' P).symm_apply_eq, piCongrLeft'_update]\n\n"}
