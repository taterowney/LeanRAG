{"name":"Module.Relations.directSum_G","module":"Mathlib.Algebra.Module.Presentation.DirectSum","initialProofState":"A : Type u\ninst✝ : Ring A\nι : Type w\nrelations : ι → Module.Relations A\n⊢ Eq (Module.Relations.directSum relations).G (Sigma fun i => (relations i).G)","decl":"/-- The direct sum operations on `Relations A`. Given a family\n`relations : ι → Relations A`, the type of generators and relations\nin `directSum relations` are the corresponding `Sigma` types. -/\n@[simps G R relation]\nnoncomputable def directSum : Relations A where\n  G := Σ i, (relations i).G\n  R := Σ i, (relations i).R\n  relation := fun ⟨i, r⟩ ↦ Finsupp.embDomain (Function.Embedding.sigmaMk\n      (β := fun i ↦ (relations i).G) i) ((relations i).relation r)\n\n"}
{"name":"Module.Relations.directSum_relation","module":"Mathlib.Algebra.Module.Presentation.DirectSum","initialProofState":"A : Type u\ninst✝ : Ring A\nι : Type w\nrelations : ι → Module.Relations A\nx✝ : Sigma fun i => (relations i).R\n⊢ Eq ((Module.Relations.directSum relations).relation x✝) (Module.Relations.directSum.match_1 relations (fun x => Finsupp (Sigma fun i => (relations i).G) A) x✝ fun i r => Finsupp.embDomain (Function.Embedding.sigmaMk i) ((relations i).relation r))","decl":"/-- The direct sum operations on `Relations A`. Given a family\n`relations : ι → Relations A`, the type of generators and relations\nin `directSum relations` are the corresponding `Sigma` types. -/\n@[simps G R relation]\nnoncomputable def directSum : Relations A where\n  G := Σ i, (relations i).G\n  R := Σ i, (relations i).R\n  relation := fun ⟨i, r⟩ ↦ Finsupp.embDomain (Function.Embedding.sigmaMk\n      (β := fun i ↦ (relations i).G) i) ((relations i).relation r)\n\n"}
{"name":"Module.Relations.directSum_R","module":"Mathlib.Algebra.Module.Presentation.DirectSum","initialProofState":"A : Type u\ninst✝ : Ring A\nι : Type w\nrelations : ι → Module.Relations A\n⊢ Eq (Module.Relations.directSum relations).R (Sigma fun i => (relations i).R)","decl":"/-- The direct sum operations on `Relations A`. Given a family\n`relations : ι → Relations A`, the type of generators and relations\nin `directSum relations` are the corresponding `Sigma` types. -/\n@[simps G R relation]\nnoncomputable def directSum : Relations A where\n  G := Σ i, (relations i).G\n  R := Σ i, (relations i).R\n  relation := fun ⟨i, r⟩ ↦ Finsupp.embDomain (Function.Embedding.sigmaMk\n      (β := fun i ↦ (relations i).G) i) ((relations i).relation r)\n\n"}
{"name":"Module.Relations.Solution.directSumEquiv_apply_var","module":"Mathlib.Algebra.Module.Presentation.DirectSum","initialProofState":"A : Type u\ninst✝² : Ring A\nι : Type w\nrelations : ι → Module.Relations A\nN : Type v\ninst✝¹ : AddCommGroup N\ninst✝ : Module A N\ns : (Module.Relations.directSum relations).Solution N\ni : ι\ng : (relations i).G\n⊢ Eq ((Module.Relations.Solution.directSumEquiv s i).var g) (s.var ⟨i, g⟩)","decl":"/-- Given an `A`-module `N` and a family `relations : ι → Relations A`,\nthe data of a solution of `Relations.directSum relations` in `N`\nis equivalent to the data of a family of solutions of `relations i` in `N`\nfor all `i`. -/\n@[simps]\ndef directSumEquiv :\n    (Relations.directSum relations).Solution N ≃\n      ∀ i, (relations i).Solution N where\n  toFun s i :=\n    { var := fun g ↦ s.var ⟨i, g⟩\n      linearCombination_var_relation := fun r ↦ by\n        rw [← s.linearCombination_var_relation ⟨i, r⟩]\n        symm\n        apply Finsupp.linearCombination_embDomain }\n  invFun t :=\n    { var := fun ⟨i, g⟩ ↦ (t i).var g\n      linearCombination_var_relation := fun ⟨i, r⟩ ↦ by\n        rw [← (t i).linearCombination_var_relation r]\n        apply Finsupp.linearCombination_embDomain }\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"Module.Relations.Solution.directSumEquiv_symm_apply_var","module":"Mathlib.Algebra.Module.Presentation.DirectSum","initialProofState":"A : Type u\ninst✝² : Ring A\nι : Type w\nrelations : ι → Module.Relations A\nN : Type v\ninst✝¹ : AddCommGroup N\ninst✝ : Module A N\nt : (i : ι) → (relations i).Solution N\nx✝ : (Module.Relations.directSum relations).G\n⊢ Eq ((Module.Relations.Solution.directSumEquiv.symm t).var x✝) (Module.Relations.Solution.directSumEquiv.match_1 (fun x => N) x✝ fun i g => (t i).var g)","decl":"/-- Given an `A`-module `N` and a family `relations : ι → Relations A`,\nthe data of a solution of `Relations.directSum relations` in `N`\nis equivalent to the data of a family of solutions of `relations i` in `N`\nfor all `i`. -/\n@[simps]\ndef directSumEquiv :\n    (Relations.directSum relations).Solution N ≃\n      ∀ i, (relations i).Solution N where\n  toFun s i :=\n    { var := fun g ↦ s.var ⟨i, g⟩\n      linearCombination_var_relation := fun r ↦ by\n        rw [← s.linearCombination_var_relation ⟨i, r⟩]\n        symm\n        apply Finsupp.linearCombination_embDomain }\n  invFun t :=\n    { var := fun ⟨i, g⟩ ↦ (t i).var g\n      linearCombination_var_relation := fun ⟨i, r⟩ ↦ by\n        rw [← (t i).linearCombination_var_relation r]\n        apply Finsupp.linearCombination_embDomain }\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"Module.Relations.Solution.directSum_var","module":"Mathlib.Algebra.Module.Presentation.DirectSum","initialProofState":"A : Type u\ninst✝³ : Ring A\nι : Type w\ninst✝² : DecidableEq ι\nrelations : ι → Module.Relations A\nM : ι → Type v\ninst✝¹ : (i : ι) → AddCommGroup (M i)\ninst✝ : (i : ι) → Module A (M i)\nsolution : (i : ι) → (relations i).Solution (M i)\ni : ι\ng : (relations i).G\n⊢ Eq ((Module.Relations.Solution.directSum solution).var ⟨i, g⟩) ((DirectSum.lof A ι M i) ((solution i).var g))","decl":"@[simp]\nlemma directSum_var (solution : ∀ (i : ι), (relations i).Solution (M i))\n    (i : ι) (g : (relations i).G) :\n    (directSum solution).var ⟨i, g⟩ = lof A ι M i ((solution i).var g) := rfl\n\n"}
{"name":"Module.Relations.Solution.IsPresentation.directSum","module":"Mathlib.Algebra.Module.Presentation.DirectSum","initialProofState":"A : Type u\ninst✝³ : Ring A\nι : Type w\ninst✝² : DecidableEq ι\nrelations : ι → Module.Relations A\nM : ι → Type v\ninst✝¹ : (i : ι) → AddCommGroup (M i)\ninst✝ : (i : ι) → Module A (M i)\nsolution : (i : ι) → (relations i).Solution (M i)\nh : ∀ (i : ι), (solution i).IsPresentation\n⊢ (Module.Relations.Solution.directSum solution).IsPresentation","decl":"include h in\nlemma directSum : (directSum solution).IsPresentation :=\n  (directSum.isRepresentationCore h).isPresentation\n\n"}
{"name":"Module.Presentation.directSum_R","module":"Mathlib.Algebra.Module.Presentation.DirectSum","initialProofState":"A : Type u\ninst✝³ : Ring A\nι : Type w\ninst✝² : DecidableEq ι\nM : ι → Type v\ninst✝¹ : (i : ι) → AddCommGroup (M i)\ninst✝ : (i : ι) → Module A (M i)\npres : (i : ι) → Module.Presentation A (M i)\n⊢ Eq (Module.Presentation.directSum pres).R (Sigma fun i => (pres i).R)","decl":"/-- The obvious presentation of the module `⨁ i, M i` that is obtained from\nthe data of presentations of the module `M i` for each `i`. -/\n@[simps! G R relation]\nnoncomputable def directSum (pres : ∀ (i : ι), Presentation A (M i)) :\n    Presentation A (⨁ i, M i) :=\n  ofIsPresentation\n    (Relations.Solution.IsPresentation.directSum (fun i ↦ (pres i).toIsPresentation))\n\n"}
{"name":"Module.Presentation.directSum_G","module":"Mathlib.Algebra.Module.Presentation.DirectSum","initialProofState":"A : Type u\ninst✝³ : Ring A\nι : Type w\ninst✝² : DecidableEq ι\nM : ι → Type v\ninst✝¹ : (i : ι) → AddCommGroup (M i)\ninst✝ : (i : ι) → Module A (M i)\npres : (i : ι) → Module.Presentation A (M i)\n⊢ Eq (Module.Presentation.directSum pres).G (Sigma fun i => (pres i).G)","decl":"/-- The obvious presentation of the module `⨁ i, M i` that is obtained from\nthe data of presentations of the module `M i` for each `i`. -/\n@[simps! G R relation]\nnoncomputable def directSum (pres : ∀ (i : ι), Presentation A (M i)) :\n    Presentation A (⨁ i, M i) :=\n  ofIsPresentation\n    (Relations.Solution.IsPresentation.directSum (fun i ↦ (pres i).toIsPresentation))\n\n"}
{"name":"Module.Presentation.directSum_relation","module":"Mathlib.Algebra.Module.Presentation.DirectSum","initialProofState":"A : Type u\ninst✝³ : Ring A\nι : Type w\ninst✝² : DecidableEq ι\nM : ι → Type v\ninst✝¹ : (i : ι) → AddCommGroup (M i)\ninst✝ : (i : ι) → Module A (M i)\npres : (i : ι) → Module.Presentation A (M i)\nr : (Module.Relations.directSum fun i => (pres i).toRelations).R\n⊢ Eq ((Module.Presentation.directSum pres).relation r) (Module.Relations.directSum.match_1 (fun i => (pres i).toRelations) (fun x => Finsupp (Sigma fun i => (pres i).G) A) r fun i r => Finsupp.embDomain (Function.Embedding.sigmaMk i) ((pres i).relation r))","decl":"/-- The obvious presentation of the module `⨁ i, M i` that is obtained from\nthe data of presentations of the module `M i` for each `i`. -/\n@[simps! G R relation]\nnoncomputable def directSum (pres : ∀ (i : ι), Presentation A (M i)) :\n    Presentation A (⨁ i, M i) :=\n  ofIsPresentation\n    (Relations.Solution.IsPresentation.directSum (fun i ↦ (pres i).toIsPresentation))\n\n"}
{"name":"Module.Presentation.directSum_var","module":"Mathlib.Algebra.Module.Presentation.DirectSum","initialProofState":"A : Type u\ninst✝³ : Ring A\nι : Type w\ninst✝² : DecidableEq ι\nM : ι → Type v\ninst✝¹ : (i : ι) → AddCommGroup (M i)\ninst✝ : (i : ι) → Module A (M i)\npres : (i : ι) → Module.Presentation A (M i)\ni : ι\ng : (pres i).G\n⊢ Eq ((Module.Presentation.directSum pres).var ⟨i, g⟩) ((DirectSum.lof A ι M i) ((pres i).var g))","decl":"@[simp]\nlemma directSum_var (pres : ∀ (i : ι), Presentation A (M i)) (i : ι) (g : (pres i).G):\n    (directSum pres).var ⟨i, g⟩ = lof A ι M i ((pres i).var g) := rfl\n\n"}
{"name":"Module.Presentation.finsupp_G","module":"Mathlib.Algebra.Module.Presentation.DirectSum","initialProofState":"A : Type u\ninst✝⁴ : Ring A\nN : Type v\ninst✝³ : AddCommGroup N\ninst✝² : Module A N\npres : Module.Presentation A N\nι : Type w\ninst✝¹ : DecidableEq ι\ninst✝ : DecidableEq N\n⊢ Eq (pres.finsupp ι).G (Sigma fun i => pres.G)","decl":"/-- The obvious presentation of the module `ι →₀ N` that is deduced from a presentation\nof the module `N`. -/\n@[simps! G R relation]\nnoncomputable def finsupp : Presentation A (ι →₀ N) :=\n  (directSum (fun (_ : ι) ↦ pres)).ofLinearEquiv (finsuppLequivDFinsupp _).symm\n\n"}
{"name":"Module.Presentation.finsupp_R","module":"Mathlib.Algebra.Module.Presentation.DirectSum","initialProofState":"A : Type u\ninst✝⁴ : Ring A\nN : Type v\ninst✝³ : AddCommGroup N\ninst✝² : Module A N\npres : Module.Presentation A N\nι : Type w\ninst✝¹ : DecidableEq ι\ninst✝ : DecidableEq N\n⊢ Eq (pres.finsupp ι).R (Sigma fun i => pres.R)","decl":"/-- The obvious presentation of the module `ι →₀ N` that is deduced from a presentation\nof the module `N`. -/\n@[simps! G R relation]\nnoncomputable def finsupp : Presentation A (ι →₀ N) :=\n  (directSum (fun (_ : ι) ↦ pres)).ofLinearEquiv (finsuppLequivDFinsupp _).symm\n\n"}
{"name":"Module.Presentation.finsupp_relation","module":"Mathlib.Algebra.Module.Presentation.DirectSum","initialProofState":"A : Type u\ninst✝⁴ : Ring A\nN : Type v\ninst✝³ : AddCommGroup N\ninst✝² : Module A N\npres : Module.Presentation A N\nι : Type w\ninst✝¹ : DecidableEq ι\ninst✝ : DecidableEq N\nr : (Module.Presentation.directSum fun x => pres).R\n⊢ Eq ((pres.finsupp ι).relation r) (Module.Relations.directSum.match_1 (fun i => pres.toRelations) (fun x => Finsupp (Sigma fun i => pres.G) A) r fun i r => Finsupp.embDomain (Function.Embedding.sigmaMk i) (pres.relation r))","decl":"/-- The obvious presentation of the module `ι →₀ N` that is deduced from a presentation\nof the module `N`. -/\n@[simps! G R relation]\nnoncomputable def finsupp : Presentation A (ι →₀ N) :=\n  (directSum (fun (_ : ι) ↦ pres)).ofLinearEquiv (finsuppLequivDFinsupp _).symm\n\n"}
{"name":"Module.Presentation.finsupp_var","module":"Mathlib.Algebra.Module.Presentation.DirectSum","initialProofState":"A : Type u\ninst✝⁴ : Ring A\nN : Type v\ninst✝³ : AddCommGroup N\ninst✝² : Module A N\npres : Module.Presentation A N\nι : Type w\ninst✝¹ : DecidableEq ι\ninst✝ : DecidableEq N\ni : ι\ng : pres.G\n⊢ Eq ((pres.finsupp ι).var ⟨i, g⟩) (Finsupp.single i (pres.var g))","decl":"@[simp]\nlemma finsupp_var (i : ι) (g : pres.G) :\n    (finsupp pres ι).var ⟨i, g⟩ = Finsupp.single i (pres.var g) := by\n  apply (finsuppLequivDFinsupp A).injective\n  erw [(finsuppLequivDFinsupp A).apply_symm_apply]\n  rw [directSum_var, finsuppLequivDFinsupp_apply_apply, Finsupp.toDFinsupp_single]\n  rfl\n\n"}
