{"name":"CategoryTheory.Limits.isLimitConeLeftOpOfCocone_lift","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor J (Opposite C)\nc : CategoryTheory.Limits.Cocone F\nhc : CategoryTheory.Limits.IsColimit c\ns : CategoryTheory.Limits.Cone F.leftOp\n⊢ Eq ((CategoryTheory.Limits.isLimitConeLeftOpOfCocone F hc).lift s) (hc.desc (CategoryTheory.Limits.coconeOfConeLeftOp s)).unop","decl":"/-- Turn a colimit for `F : J ⥤ Cᵒᵖ` into a limit for `F.leftOp : Jᵒᵖ ⥤ C`. -/\n@[simps]\ndef isLimitConeLeftOpOfCocone (F : J ⥤ Cᵒᵖ) {c : Cocone F} (hc : IsColimit c) :\n    IsLimit (coneLeftOpOfCocone c) where\n  lift s := (hc.desc (coconeOfConeLeftOp s)).unop\n  fac s j :=\n    Quiver.Hom.op_inj <| by\n      simp only [coneLeftOpOfCocone_π_app, op_comp, Quiver.Hom.op_unop, IsColimit.fac,\n        coconeOfConeLeftOp_ι_app, op_unop]\n  uniq s m w := by\n    refine Quiver.Hom.op_inj (hc.hom_ext fun j => Quiver.Hom.unop_inj ?_)\n    simpa only [Quiver.Hom.op_unop, IsColimit.fac, coconeOfConeLeftOp_ι_app] using w (op j)\n\n"}
{"name":"CategoryTheory.Limits.isColimitCoconeLeftOpOfCone_desc","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor J (Opposite C)\nc : CategoryTheory.Limits.Cone F\nhc : CategoryTheory.Limits.IsLimit c\ns : CategoryTheory.Limits.Cocone F.leftOp\n⊢ Eq ((CategoryTheory.Limits.isColimitCoconeLeftOpOfCone F hc).desc s) (hc.lift (CategoryTheory.Limits.coneOfCoconeLeftOp s)).unop","decl":"/-- Turn a limit of `F : J ⥤ Cᵒᵖ` into a colimit of `F.leftOp : Jᵒᵖ ⥤ C`. -/\n@[simps]\ndef isColimitCoconeLeftOpOfCone (F : J ⥤ Cᵒᵖ) {c : Cone F} (hc : IsLimit c) :\n    IsColimit (coconeLeftOpOfCone c) where\n  desc s := (hc.lift (coneOfCoconeLeftOp s)).unop\n  fac s j :=\n    Quiver.Hom.op_inj <| by\n      simp only [coconeLeftOpOfCone_ι_app, op_comp, Quiver.Hom.op_unop, IsLimit.fac,\n        coneOfCoconeLeftOp_π_app, op_unop]\n  uniq s m w := by\n    refine Quiver.Hom.op_inj (hc.hom_ext fun j => Quiver.Hom.unop_inj ?_)\n    simpa only [Quiver.Hom.op_unop, IsLimit.fac, coneOfCoconeLeftOp_π_app] using w (op j)\n\n"}
{"name":"CategoryTheory.Limits.isLimitConeRightOpOfCocone_lift","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor (Opposite J) C\nc : CategoryTheory.Limits.Cocone F\nhc : CategoryTheory.Limits.IsColimit c\ns : CategoryTheory.Limits.Cone F.rightOp\n⊢ Eq ((CategoryTheory.Limits.isLimitConeRightOpOfCocone F hc).lift s) (hc.desc (CategoryTheory.Limits.coconeOfConeRightOp s)).op","decl":"/-- Turn a colimit for `F : Jᵒᵖ ⥤ C` into a limit for `F.rightOp : J ⥤ Cᵒᵖ`. -/\n@[simps]\ndef isLimitConeRightOpOfCocone (F : Jᵒᵖ ⥤ C) {c : Cocone F} (hc : IsColimit c) :\n    IsLimit (coneRightOpOfCocone c) where\n  lift s := (hc.desc (coconeOfConeRightOp s)).op\n  fac s j := Quiver.Hom.unop_inj (by simp)\n  uniq s m w := by\n    refine Quiver.Hom.unop_inj (hc.hom_ext fun j => Quiver.Hom.op_inj ?_)\n    simpa only [Quiver.Hom.unop_op, IsColimit.fac] using w (unop j)\n\n"}
{"name":"CategoryTheory.Limits.isColimitCoconeRightOpOfCone_desc","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor (Opposite J) C\nc : CategoryTheory.Limits.Cone F\nhc : CategoryTheory.Limits.IsLimit c\ns : CategoryTheory.Limits.Cocone F.rightOp\n⊢ Eq ((CategoryTheory.Limits.isColimitCoconeRightOpOfCone F hc).desc s) (hc.lift (CategoryTheory.Limits.coneOfCoconeRightOp s)).op","decl":"/-- Turn a limit for `F : Jᵒᵖ ⥤ C` into a colimit for `F.rightOp : J ⥤ Cᵒᵖ`. -/\n@[simps]\ndef isColimitCoconeRightOpOfCone (F : Jᵒᵖ ⥤ C) {c : Cone F} (hc : IsLimit c) :\n    IsColimit (coconeRightOpOfCone c) where\n  desc s := (hc.lift (coneOfCoconeRightOp s)).op\n  fac s j := Quiver.Hom.unop_inj (by simp)\n  uniq s m w := by\n    refine Quiver.Hom.unop_inj (hc.hom_ext fun j => Quiver.Hom.op_inj ?_)\n    simpa only [Quiver.Hom.unop_op, IsLimit.fac] using w (unop j)\n\n"}
{"name":"CategoryTheory.Limits.isLimitConeUnopOfCocone_lift","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor (Opposite J) (Opposite C)\nc : CategoryTheory.Limits.Cocone F\nhc : CategoryTheory.Limits.IsColimit c\ns : CategoryTheory.Limits.Cone F.unop\n⊢ Eq ((CategoryTheory.Limits.isLimitConeUnopOfCocone F hc).lift s) (hc.desc (CategoryTheory.Limits.coconeOfConeUnop s)).unop","decl":"/-- Turn a colimit for `F : Jᵒᵖ ⥤ Cᵒᵖ` into a limit for `F.unop : J ⥤ C`. -/\n@[simps]\ndef isLimitConeUnopOfCocone (F : Jᵒᵖ ⥤ Cᵒᵖ) {c : Cocone F} (hc : IsColimit c) :\n    IsLimit (coneUnopOfCocone c) where\n  lift s := (hc.desc (coconeOfConeUnop s)).unop\n  fac s j := Quiver.Hom.op_inj (by simp)\n  uniq s m w := by\n    refine Quiver.Hom.op_inj (hc.hom_ext fun j => Quiver.Hom.unop_inj ?_)\n    simpa only [Quiver.Hom.op_unop, IsColimit.fac] using w (unop j)\n\n"}
{"name":"CategoryTheory.Limits.isColimitCoconeUnopOfCone_desc","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor (Opposite J) (Opposite C)\nc : CategoryTheory.Limits.Cone F\nhc : CategoryTheory.Limits.IsLimit c\ns : CategoryTheory.Limits.Cocone F.unop\n⊢ Eq ((CategoryTheory.Limits.isColimitCoconeUnopOfCone F hc).desc s) (hc.lift (CategoryTheory.Limits.coneOfCoconeUnop s)).unop","decl":"/-- Turn a limit of `F : Jᵒᵖ ⥤ Cᵒᵖ` into a colimit of `F.unop : J ⥤ C`. -/\n@[simps]\ndef isColimitCoconeUnopOfCone (F : Jᵒᵖ ⥤ Cᵒᵖ) {c : Cone F} (hc : IsLimit c) :\n    IsColimit (coconeUnopOfCone c) where\n  desc s := (hc.lift (coneOfCoconeUnop s)).unop\n  fac s j := Quiver.Hom.op_inj (by simp)\n  uniq s m w := by\n    refine Quiver.Hom.op_inj (hc.hom_ext fun j => Quiver.Hom.unop_inj ?_)\n    simpa only [Quiver.Hom.op_unop, IsLimit.fac] using w (unop j)\n\n"}
{"name":"CategoryTheory.Limits.isLimitConeOfCoconeLeftOp_lift","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor J (Opposite C)\nc : CategoryTheory.Limits.Cocone F.leftOp\nhc : CategoryTheory.Limits.IsColimit c\ns : CategoryTheory.Limits.Cone F\n⊢ Eq ((CategoryTheory.Limits.isLimitConeOfCoconeLeftOp F hc).lift s) (hc.desc (CategoryTheory.Limits.coconeLeftOpOfCone s)).op","decl":"/-- Turn a colimit for `F.leftOp : Jᵒᵖ ⥤ C` into a limit for `F : J ⥤ Cᵒᵖ`. -/\n@[simps]\ndef isLimitConeOfCoconeLeftOp (F : J ⥤ Cᵒᵖ) {c : Cocone F.leftOp} (hc : IsColimit c) :\n    IsLimit (coneOfCoconeLeftOp c) where\n  lift s := (hc.desc (coconeLeftOpOfCone s)).op\n  fac s j :=\n    Quiver.Hom.unop_inj <| by\n      simp only [coneOfCoconeLeftOp_π_app, unop_comp, Quiver.Hom.unop_op, IsColimit.fac,\n        coconeLeftOpOfCone_ι_app, unop_op]\n  uniq s m w := by\n    refine Quiver.Hom.unop_inj (hc.hom_ext fun j => Quiver.Hom.op_inj ?_)\n    simpa only [Quiver.Hom.unop_op, IsColimit.fac, coneOfCoconeLeftOp_π_app] using w (unop j)\n\n"}
{"name":"CategoryTheory.Limits.isColimitCoconeOfConeLeftOp_desc","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor J (Opposite C)\nc : CategoryTheory.Limits.Cone F.leftOp\nhc : CategoryTheory.Limits.IsLimit c\ns : CategoryTheory.Limits.Cocone F\n⊢ Eq ((CategoryTheory.Limits.isColimitCoconeOfConeLeftOp F hc).desc s) (hc.lift (CategoryTheory.Limits.coneLeftOpOfCocone s)).op","decl":"/-- Turn a limit of `F.leftOp : Jᵒᵖ ⥤ C` into a colimit of `F : J ⥤ Cᵒᵖ`. -/\n@[simps]\ndef isColimitCoconeOfConeLeftOp (F : J ⥤ Cᵒᵖ) {c : Cone F.leftOp} (hc : IsLimit c) :\n    IsColimit (coconeOfConeLeftOp c) where\n  desc s := (hc.lift (coneLeftOpOfCocone s)).op\n  fac s j :=\n    Quiver.Hom.unop_inj <| by\n      simp only [coconeOfConeLeftOp_ι_app, unop_comp, Quiver.Hom.unop_op, IsLimit.fac,\n        coneLeftOpOfCocone_π_app, unop_op]\n  uniq s m w := by\n    refine Quiver.Hom.unop_inj (hc.hom_ext fun j => Quiver.Hom.op_inj ?_)\n    simpa only [Quiver.Hom.unop_op, IsLimit.fac, coconeOfConeLeftOp_ι_app] using w (unop j)\n\n"}
{"name":"CategoryTheory.Limits.isLimitConeOfCoconeRightOp_lift","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor (Opposite J) C\nc : CategoryTheory.Limits.Cocone F.rightOp\nhc : CategoryTheory.Limits.IsColimit c\ns : CategoryTheory.Limits.Cone F\n⊢ Eq ((CategoryTheory.Limits.isLimitConeOfCoconeRightOp F hc).lift s) (hc.desc (CategoryTheory.Limits.coconeRightOpOfCone s)).unop","decl":"/-- Turn a colimit for `F.rightOp : J ⥤ Cᵒᵖ` into a limit for `F : Jᵒᵖ ⥤ C`. -/\n@[simps]\ndef isLimitConeOfCoconeRightOp (F : Jᵒᵖ ⥤ C) {c : Cocone F.rightOp} (hc : IsColimit c) :\n    IsLimit (coneOfCoconeRightOp c) where\n  lift s := (hc.desc (coconeRightOpOfCone s)).unop\n  fac s j := Quiver.Hom.op_inj (by simp)\n  uniq s m w := by\n    refine Quiver.Hom.op_inj (hc.hom_ext fun j => Quiver.Hom.unop_inj ?_)\n    simpa only [Quiver.Hom.op_unop, IsColimit.fac] using w (op j)\n\n"}
{"name":"CategoryTheory.Limits.isColimitCoconeOfConeRightOp_desc","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor (Opposite J) C\nc : CategoryTheory.Limits.Cone F.rightOp\nhc : CategoryTheory.Limits.IsLimit c\ns : CategoryTheory.Limits.Cocone F\n⊢ Eq ((CategoryTheory.Limits.isColimitCoconeOfConeRightOp F hc).desc s) (hc.lift (CategoryTheory.Limits.coneRightOpOfCocone s)).unop","decl":"/-- Turn a limit for `F.rightOp : J ⥤ Cᵒᵖ` into a colimit for `F : Jᵒᵖ ⥤ C`. -/\n@[simps]\ndef isColimitCoconeOfConeRightOp (F : Jᵒᵖ ⥤ C) {c : Cone F.rightOp} (hc : IsLimit c) :\n    IsColimit (coconeOfConeRightOp c) where\n  desc s := (hc.lift (coneRightOpOfCocone s)).unop\n  fac s j := Quiver.Hom.op_inj (by simp)\n  uniq s m w := by\n    refine Quiver.Hom.op_inj (hc.hom_ext fun j => Quiver.Hom.unop_inj ?_)\n    simpa only [Quiver.Hom.op_unop, IsLimit.fac] using w (op j)\n\n"}
{"name":"CategoryTheory.Limits.isLimitConeOfCoconeUnop_lift","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor (Opposite J) (Opposite C)\nc : CategoryTheory.Limits.Cocone F.unop\nhc : CategoryTheory.Limits.IsColimit c\ns : CategoryTheory.Limits.Cone F\n⊢ Eq ((CategoryTheory.Limits.isLimitConeOfCoconeUnop F hc).lift s) (hc.desc (CategoryTheory.Limits.coconeUnopOfCone s)).op","decl":"/-- Turn a colimit for `F.unop : J ⥤ C` into a limit for `F : Jᵒᵖ ⥤ Cᵒᵖ`. -/\n@[simps]\ndef isLimitConeOfCoconeUnop (F : Jᵒᵖ ⥤ Cᵒᵖ) {c : Cocone F.unop} (hc : IsColimit c) :\n    IsLimit (coneOfCoconeUnop c) where\n  lift s := (hc.desc (coconeUnopOfCone s)).op\n  fac s j := Quiver.Hom.unop_inj (by simp)\n  uniq s m w := by\n    refine Quiver.Hom.unop_inj (hc.hom_ext fun j => Quiver.Hom.op_inj ?_)\n    simpa only [Quiver.Hom.unop_op, IsColimit.fac] using w (op j)\n\n"}
{"name":"CategoryTheory.Limits.isColimitCoconeOfConeUnop_desc","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor (Opposite J) (Opposite C)\nc : CategoryTheory.Limits.Cone F.unop\nhc : CategoryTheory.Limits.IsLimit c\ns : CategoryTheory.Limits.Cocone F\n⊢ Eq ((CategoryTheory.Limits.isColimitCoconeOfConeUnop F hc).desc s) (hc.lift (CategoryTheory.Limits.coneUnopOfCocone s)).op","decl":"/-- Turn a limit for `F.unop : J ⥤ C` into a colimit for `F : Jᵒᵖ ⥤ Cᵒᵖ`. -/\n@[simps]\ndef isColimitCoconeOfConeUnop (F : Jᵒᵖ ⥤ Cᵒᵖ) {c : Cone F.unop} (hc : IsLimit c) :\n    IsColimit (coconeOfConeUnop c) where\n  desc s := (hc.lift (coneUnopOfCocone s)).op\n  fac s j := Quiver.Hom.unop_inj (by simp)\n  uniq s m w := by\n    refine Quiver.Hom.unop_inj (hc.hom_ext fun j => Quiver.Hom.op_inj ?_)\n    simpa only [Quiver.Hom.unop_op, IsLimit.fac] using w (op j)\n\n"}
{"name":"CategoryTheory.Limits.isColimitOfConeLeftOpOfCocone_desc","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor J (Opposite C)\nc : CategoryTheory.Limits.Cocone F\nhc : CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.coneLeftOpOfCocone c)\ns : CategoryTheory.Limits.Cocone F\n⊢ Eq ((CategoryTheory.Limits.isColimitOfConeLeftOpOfCocone F hc).desc s) (hc.lift (CategoryTheory.Limits.coneLeftOpOfCocone s)).op","decl":"/-- Turn a limit for `F.leftOp : Jᵒᵖ ⥤ C` into a colimit for `F : J ⥤ Cᵒᵖ`. -/\n@[simps!]\ndef isColimitOfConeLeftOpOfCocone (F : J ⥤ Cᵒᵖ) {c : Cocone F}\n    (hc : IsLimit (coneLeftOpOfCocone c)) : IsColimit c :=\n  isColimitCoconeOfConeLeftOp F hc\n\n"}
{"name":"CategoryTheory.Limits.isLimitOfCoconeLeftOpOfCone_lift","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor J (Opposite C)\nc : CategoryTheory.Limits.Cone F\nhc : CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.coconeLeftOpOfCone c)\ns : CategoryTheory.Limits.Cone F\n⊢ Eq ((CategoryTheory.Limits.isLimitOfCoconeLeftOpOfCone F hc).lift s) (hc.desc (CategoryTheory.Limits.coconeLeftOpOfCone s)).op","decl":"/-- Turn a colimit for `F.leftOp : Jᵒᵖ ⥤ C` into a limit for `F : J ⥤ Cᵒᵖ`. -/\n@[simps!]\ndef isLimitOfCoconeLeftOpOfCone (F : J ⥤ Cᵒᵖ) {c : Cone F}\n    (hc : IsColimit (coconeLeftOpOfCone c)) : IsLimit c :=\n  isLimitConeOfCoconeLeftOp F hc\n\n"}
{"name":"CategoryTheory.Limits.isColimitOfConeRightOpOfCocone_desc","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor (Opposite J) C\nc : CategoryTheory.Limits.Cocone F\nhc : CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.coneRightOpOfCocone c)\ns : CategoryTheory.Limits.Cocone F\n⊢ Eq ((CategoryTheory.Limits.isColimitOfConeRightOpOfCocone F hc).desc s) (hc.lift (CategoryTheory.Limits.coneRightOpOfCocone s)).unop","decl":"/-- Turn a limit for `F.rightOp : J ⥤ Cᵒᵖ` into a colimit for `F : Jᵒᵖ ⥤ C`. -/\n@[simps!]\ndef isColimitOfConeRightOpOfCocone (F : Jᵒᵖ ⥤ C) {c : Cocone F}\n    (hc : IsLimit (coneRightOpOfCocone c)) : IsColimit c :=\n  isColimitCoconeOfConeRightOp F hc\n\n"}
{"name":"CategoryTheory.Limits.isLimitOfCoconeRightOpOfCone_lift","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor (Opposite J) C\nc : CategoryTheory.Limits.Cone F\nhc : CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.coconeRightOpOfCone c)\ns : CategoryTheory.Limits.Cone F\n⊢ Eq ((CategoryTheory.Limits.isLimitOfCoconeRightOpOfCone F hc).lift s) (hc.desc (CategoryTheory.Limits.coconeRightOpOfCone s)).unop","decl":"/-- Turn a colimit for `F.rightOp : J ⥤ Cᵒᵖ` into a limit for `F : Jᵒᵖ ⥤ C`. -/\n@[simps!]\ndef isLimitOfCoconeRightOpOfCone (F : Jᵒᵖ ⥤ C) {c : Cone F}\n    (hc : IsColimit (coconeRightOpOfCone c)) : IsLimit c :=\n  isLimitConeOfCoconeRightOp F hc\n\n"}
{"name":"CategoryTheory.Limits.isColimitOfConeUnopOfCocone_desc","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor (Opposite J) (Opposite C)\nc : CategoryTheory.Limits.Cocone F\nhc : CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.coneUnopOfCocone c)\ns : CategoryTheory.Limits.Cocone F\n⊢ Eq ((CategoryTheory.Limits.isColimitOfConeUnopOfCocone F hc).desc s) (hc.lift (CategoryTheory.Limits.coneUnopOfCocone s)).op","decl":"/-- Turn a limit for `F.unop : J ⥤ C` into a colimit for `F : Jᵒᵖ ⥤ Cᵒᵖ`. -/\n@[simps!]\ndef isColimitOfConeUnopOfCocone (F : Jᵒᵖ ⥤ Cᵒᵖ) {c : Cocone F}\n    (hc : IsLimit (coneUnopOfCocone c)) : IsColimit c :=\n  isColimitCoconeOfConeUnop F hc\n\n"}
{"name":"CategoryTheory.Limits.isLimitOfCoconeUnopOfCone_lift","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor (Opposite J) (Opposite C)\nc : CategoryTheory.Limits.Cone F\nhc : CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.coconeUnopOfCone c)\ns : CategoryTheory.Limits.Cone F\n⊢ Eq ((CategoryTheory.Limits.isLimitOfCoconeUnopOfCone F hc).lift s) (hc.desc (CategoryTheory.Limits.coconeUnopOfCone s)).op","decl":"/-- Turn a colimit for `F.unop : J ⥤ C` into a limit for `F : Jᵒᵖ ⥤ Cᵒᵖ`. -/\n@[simps!]\ndef isLimitOfCoconeUnopOfCone (F : Jᵒᵖ ⥤ Cᵒᵖ) {c : Cone F}\n    (hc : IsColimit (coconeUnopOfCone c)) : IsLimit c :=\n  isLimitConeOfCoconeUnop F hc\n\n"}
{"name":"CategoryTheory.Limits.isColimitOfConeOfCoconeLeftOp_desc","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor J (Opposite C)\nc : CategoryTheory.Limits.Cocone F.leftOp\nhc : CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.coneOfCoconeLeftOp c)\ns : CategoryTheory.Limits.Cocone F.leftOp\n⊢ Eq ((CategoryTheory.Limits.isColimitOfConeOfCoconeLeftOp F hc).desc s) (hc.lift (CategoryTheory.Limits.coneOfCoconeLeftOp s)).unop","decl":"/-- Turn a limit for `F : J ⥤ Cᵒᵖ` into a colimit for `F.leftOp : Jᵒᵖ ⥤ C`. -/\n@[simps!]\ndef isColimitOfConeOfCoconeLeftOp (F : J ⥤ Cᵒᵖ) {c : Cocone F.leftOp}\n    (hc : IsLimit (coneOfCoconeLeftOp c)) : IsColimit c :=\n  isColimitCoconeLeftOpOfCone F hc\n\n"}
{"name":"CategoryTheory.Limits.isLimitOfCoconeOfConeLeftOp_lift","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor J (Opposite C)\nc : CategoryTheory.Limits.Cone F.leftOp\nhc : CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.coconeOfConeLeftOp c)\ns : CategoryTheory.Limits.Cone F.leftOp\n⊢ Eq ((CategoryTheory.Limits.isLimitOfCoconeOfConeLeftOp F hc).lift s) (hc.desc (CategoryTheory.Limits.coconeOfConeLeftOp s)).unop","decl":"/-- Turn a colimit for `F : J ⥤ Cᵒᵖ` into a limit for `F.leftOp : Jᵒᵖ ⥤ C`. -/\n@[simps!]\ndef isLimitOfCoconeOfConeLeftOp (F : J ⥤ Cᵒᵖ) {c : Cone F.leftOp}\n    (hc : IsColimit (coconeOfConeLeftOp c)) : IsLimit c :=\n  isLimitConeLeftOpOfCocone F hc\n\n"}
{"name":"CategoryTheory.Limits.isColimitOfConeOfCoconeRightOp_desc","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor (Opposite J) C\nc : CategoryTheory.Limits.Cocone F.rightOp\nhc : CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.coneOfCoconeRightOp c)\ns : CategoryTheory.Limits.Cocone F.rightOp\n⊢ Eq ((CategoryTheory.Limits.isColimitOfConeOfCoconeRightOp F hc).desc s) (hc.lift (CategoryTheory.Limits.coneOfCoconeRightOp s)).op","decl":"/-- Turn a limit for `F : Jᵒᵖ ⥤ C` into a colimit for `F.rightOp : J ⥤ Cᵒᵖ.` -/\n@[simps!]\ndef isColimitOfConeOfCoconeRightOp (F : Jᵒᵖ ⥤ C) {c : Cocone F.rightOp}\n    (hc : IsLimit (coneOfCoconeRightOp c)) : IsColimit c :=\n  isColimitCoconeRightOpOfCone F hc\n\n"}
{"name":"CategoryTheory.Limits.isLimitOfCoconeOfConeRightOp_lift","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor (Opposite J) C\nc : CategoryTheory.Limits.Cone F.rightOp\nhc : CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.coconeOfConeRightOp c)\ns : CategoryTheory.Limits.Cone F.rightOp\n⊢ Eq ((CategoryTheory.Limits.isLimitOfCoconeOfConeRightOp F hc).lift s) (hc.desc (CategoryTheory.Limits.coconeOfConeRightOp s)).op","decl":"/-- Turn a colimit for `F : Jᵒᵖ ⥤ C` into a limit for `F.rightOp : J ⥤ Cᵒᵖ`. -/\n@[simps!]\ndef isLimitOfCoconeOfConeRightOp (F : Jᵒᵖ ⥤ C) {c : Cone F.rightOp}\n    (hc : IsColimit (coconeOfConeRightOp c)) : IsLimit c :=\n  isLimitConeRightOpOfCocone F hc\n\n"}
{"name":"CategoryTheory.Limits.isColimitOfConeOfCoconeUnop_desc","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor (Opposite J) (Opposite C)\nc : CategoryTheory.Limits.Cocone F.unop\nhc : CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.coneOfCoconeUnop c)\ns : CategoryTheory.Limits.Cocone F.unop\n⊢ Eq ((CategoryTheory.Limits.isColimitOfConeOfCoconeUnop F hc).desc s) (hc.lift (CategoryTheory.Limits.coneOfCoconeUnop s)).unop","decl":"/-- Turn a limit for `F : Jᵒᵖ ⥤ Cᵒᵖ` into a colimit for `F.unop : J ⥤ C`. -/\n@[simps!]\ndef isColimitOfConeOfCoconeUnop (F : Jᵒᵖ ⥤ Cᵒᵖ) {c : Cocone F.unop}\n    (hc : IsLimit (coneOfCoconeUnop c)) : IsColimit c :=\n  isColimitCoconeUnopOfCone F hc\n\n"}
{"name":"CategoryTheory.Limits.isLimitOfCoconeOfConeUnop_lift","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor (Opposite J) (Opposite C)\nc : CategoryTheory.Limits.Cone F.unop\nhc : CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.coconeOfConeUnop c)\ns : CategoryTheory.Limits.Cone F.unop\n⊢ Eq ((CategoryTheory.Limits.isLimitOfCoconeOfConeUnop F hc).lift s) (hc.desc (CategoryTheory.Limits.coconeOfConeUnop s)).unop","decl":"/-- Turn a colimit for `F : Jᵒᵖ ⥤ Cᵒᵖ` into a limit for `F.unop : J ⥤ C`. -/\n@[simps!]\ndef isLimitOfCoconeOfConeUnop (F : Jᵒᵖ ⥤ Cᵒᵖ) {c : Cone F.unop}\n    (hc : IsColimit (coconeOfConeUnop c)) : IsLimit c :=\n  isLimitConeUnopOfCocone F hc\n\n"}
{"name":"CategoryTheory.Limits.hasLimit_of_hasColimit_leftOp","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor J (Opposite C)\ninst✝ : CategoryTheory.Limits.HasColimit F.leftOp\n⊢ CategoryTheory.Limits.HasLimit F","decl":"/-- If `F.leftOp : Jᵒᵖ ⥤ C` has a colimit, we can construct a limit for `F : J ⥤ Cᵒᵖ`.\n-/\ntheorem hasLimit_of_hasColimit_leftOp (F : J ⥤ Cᵒᵖ) [HasColimit F.leftOp] : HasLimit F :=\n  HasLimit.mk\n    { cone := coneOfCoconeLeftOp (colimit.cocone F.leftOp)\n      isLimit := isLimitConeOfCoconeLeftOp _ (colimit.isColimit _) }\n\n"}
{"name":"CategoryTheory.Limits.hasLimit_of_hasColimit_op","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasColimit F.op\n⊢ CategoryTheory.Limits.HasLimit F","decl":"theorem hasLimit_of_hasColimit_op (F : J ⥤ C) [HasColimit F.op] : HasLimit F :=\n  HasLimit.mk\n    { cone := (colimit.cocone F.op).unop\n      isLimit := (colimit.isColimit _).unop }\n\n"}
{"name":"CategoryTheory.Limits.hasLimit_of_hasColimit_rightOp","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor (Opposite J) C\ninst✝ : CategoryTheory.Limits.HasColimit F.rightOp\n⊢ CategoryTheory.Limits.HasLimit F","decl":"theorem hasLimit_of_hasColimit_rightOp (F : Jᵒᵖ ⥤ C) [HasColimit F.rightOp] : HasLimit F :=\n  HasLimit.mk\n    { cone := coneOfCoconeRightOp (colimit.cocone F.rightOp)\n      isLimit := isLimitConeOfCoconeRightOp _ (colimit.isColimit _) }\n\n"}
{"name":"CategoryTheory.Limits.hasLimit_of_hasColimit_unop","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor (Opposite J) (Opposite C)\ninst✝ : CategoryTheory.Limits.HasColimit F.unop\n⊢ CategoryTheory.Limits.HasLimit F","decl":"theorem hasLimit_of_hasColimit_unop (F : Jᵒᵖ ⥤ Cᵒᵖ) [HasColimit F.unop] : HasLimit F :=\n  HasLimit.mk\n    { cone := coneOfCoconeUnop (colimit.cocone F.unop)\n      isLimit := isLimitConeOfCoconeUnop _ (colimit.isColimit _) }\n\n"}
{"name":"CategoryTheory.Limits.hasLimit_op_of_hasColimit","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasColimit F\n⊢ CategoryTheory.Limits.HasLimit F.op","decl":"instance hasLimit_op_of_hasColimit (F : J ⥤ C) [HasColimit F] : HasLimit F.op :=\n  HasLimit.mk\n    { cone := (colimit.cocone F).op\n      isLimit := (colimit.isColimit _).op }\n\n"}
{"name":"CategoryTheory.Limits.hasLimit_leftOp_of_hasColimit","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor J (Opposite C)\ninst✝ : CategoryTheory.Limits.HasColimit F\n⊢ CategoryTheory.Limits.HasLimit F.leftOp","decl":"instance hasLimit_leftOp_of_hasColimit (F : J ⥤ Cᵒᵖ) [HasColimit F] : HasLimit F.leftOp :=\n  HasLimit.mk\n    { cone := coneLeftOpOfCocone (colimit.cocone F)\n      isLimit := isLimitConeLeftOpOfCocone _ (colimit.isColimit _) }\n\n"}
{"name":"CategoryTheory.Limits.hasLimit_rightOp_of_hasColimit","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor (Opposite J) C\ninst✝ : CategoryTheory.Limits.HasColimit F\n⊢ CategoryTheory.Limits.HasLimit F.rightOp","decl":"instance hasLimit_rightOp_of_hasColimit (F : Jᵒᵖ ⥤ C) [HasColimit F] : HasLimit F.rightOp :=\n  HasLimit.mk\n    { cone := coneRightOpOfCocone (colimit.cocone F)\n      isLimit := isLimitConeRightOpOfCocone _ (colimit.isColimit _) }\n\n"}
{"name":"CategoryTheory.Limits.hasLimit_unop_of_hasColimit","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor (Opposite J) (Opposite C)\ninst✝ : CategoryTheory.Limits.HasColimit F\n⊢ CategoryTheory.Limits.HasLimit F.unop","decl":"instance hasLimit_unop_of_hasColimit (F : Jᵒᵖ ⥤ Cᵒᵖ) [HasColimit F] : HasLimit F.unop :=\n  HasLimit.mk\n    { cone := coneUnopOfCocone (colimit.cocone F)\n      isLimit := isLimitConeUnopOfCocone _ (colimit.isColimit _) }\n\n"}
{"name":"CategoryTheory.Limits.limitOpIsoOpColimit_inv_comp_π","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasColimit F\nj : Opposite J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limitOpIsoOpColimit F).inv (CategoryTheory.Limits.limit.π F.op j)) (CategoryTheory.Limits.colimit.ι F (Opposite.unop j)).op","decl":"@[reassoc (attr := simp)]\nlemma limitOpIsoOpColimit_inv_comp_π (F : J ⥤ C) [HasColimit F] (j : Jᵒᵖ) :\n    (limitOpIsoOpColimit F).inv ≫ limit.π F.op j = (colimit.ι F j.unop).op := by\n  simp [limitOpIsoOpColimit]\n\n"}
{"name":"CategoryTheory.Limits.limitOpIsoOpColimit_inv_comp_π_assoc","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasColimit F\nj : Opposite J\nZ : Opposite C\nh : Quiver.Hom (F.op.obj j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limitOpIsoOpColimit F).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π F.op j) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι F (Opposite.unop j)).op h)","decl":"@[reassoc (attr := simp)]\nlemma limitOpIsoOpColimit_inv_comp_π (F : J ⥤ C) [HasColimit F] (j : Jᵒᵖ) :\n    (limitOpIsoOpColimit F).inv ≫ limit.π F.op j = (colimit.ι F j.unop).op := by\n  simp [limitOpIsoOpColimit]\n\n"}
{"name":"CategoryTheory.Limits.limitOpIsoOpColimit_hom_comp_ι","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasColimit F\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limitOpIsoOpColimit F).hom (CategoryTheory.Limits.colimit.ι F j).op) (CategoryTheory.Limits.limit.π F.op { unop := j })","decl":"@[reassoc (attr := simp)]\nlemma limitOpIsoOpColimit_hom_comp_ι (F : J ⥤ C) [HasColimit F] (j : J) :\n    (limitOpIsoOpColimit F).hom ≫ (colimit.ι F j).op = limit.π F.op (op j) := by\n  simp [← Iso.eq_inv_comp]\n\n"}
{"name":"CategoryTheory.Limits.limitOpIsoOpColimit_hom_comp_ι_assoc","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasColimit F\nj : J\nZ : Opposite C\nh : Quiver.Hom { unop := F.obj j } Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limitOpIsoOpColimit F).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι F j).op h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π F.op { unop := j }) h)","decl":"@[reassoc (attr := simp)]\nlemma limitOpIsoOpColimit_hom_comp_ι (F : J ⥤ C) [HasColimit F] (j : J) :\n    (limitOpIsoOpColimit F).hom ≫ (colimit.ι F j).op = limit.π F.op (op j) := by\n  simp [← Iso.eq_inv_comp]\n\n"}
{"name":"CategoryTheory.Limits.limitLeftOpIsoUnopColimit_inv_comp_π","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor J (Opposite C)\ninst✝ : CategoryTheory.Limits.HasColimit F\nj : Opposite J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limitLeftOpIsoUnopColimit F).inv (CategoryTheory.Limits.limit.π F.leftOp j)) (CategoryTheory.Limits.colimit.ι F (Opposite.unop j)).unop","decl":"@[reassoc (attr := simp)]\nlemma limitLeftOpIsoUnopColimit_inv_comp_π (F : J ⥤ Cᵒᵖ) [HasColimit F] (j : Jᵒᵖ) :\n    (limitLeftOpIsoUnopColimit F).inv ≫ limit.π F.leftOp j = (colimit.ι F j.unop).unop := by\n  simp [limitLeftOpIsoUnopColimit]\n\n"}
{"name":"CategoryTheory.Limits.limitLeftOpIsoUnopColimit_inv_comp_π_assoc","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor J (Opposite C)\ninst✝ : CategoryTheory.Limits.HasColimit F\nj : Opposite J\nZ : C\nh : Quiver.Hom (F.leftOp.obj j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limitLeftOpIsoUnopColimit F).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π F.leftOp j) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι F (Opposite.unop j)).unop h)","decl":"@[reassoc (attr := simp)]\nlemma limitLeftOpIsoUnopColimit_inv_comp_π (F : J ⥤ Cᵒᵖ) [HasColimit F] (j : Jᵒᵖ) :\n    (limitLeftOpIsoUnopColimit F).inv ≫ limit.π F.leftOp j = (colimit.ι F j.unop).unop := by\n  simp [limitLeftOpIsoUnopColimit]\n\n"}
{"name":"CategoryTheory.Limits.limitLeftOpIsoUnopColimit_hom_comp_ι_assoc","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor J (Opposite C)\ninst✝ : CategoryTheory.Limits.HasColimit F\nj : J\nZ : C\nh : Quiver.Hom (Opposite.unop (F.obj j)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limitLeftOpIsoUnopColimit F).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι F j).unop h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π F.leftOp { unop := j }) h)","decl":"@[reassoc (attr := simp)]\nlemma limitLeftOpIsoUnopColimit_hom_comp_ι (F : J ⥤ Cᵒᵖ) [HasColimit F] (j : J) :\n    (limitLeftOpIsoUnopColimit F).hom ≫ (colimit.ι F j).unop = limit.π F.leftOp (op j) := by\n  simp [← Iso.eq_inv_comp]\n\n"}
{"name":"CategoryTheory.Limits.limitLeftOpIsoUnopColimit_hom_comp_ι","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor J (Opposite C)\ninst✝ : CategoryTheory.Limits.HasColimit F\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limitLeftOpIsoUnopColimit F).hom (CategoryTheory.Limits.colimit.ι F j).unop) (CategoryTheory.Limits.limit.π F.leftOp { unop := j })","decl":"@[reassoc (attr := simp)]\nlemma limitLeftOpIsoUnopColimit_hom_comp_ι (F : J ⥤ Cᵒᵖ) [HasColimit F] (j : J) :\n    (limitLeftOpIsoUnopColimit F).hom ≫ (colimit.ι F j).unop = limit.π F.leftOp (op j) := by\n  simp [← Iso.eq_inv_comp]\n\n"}
{"name":"CategoryTheory.Limits.limitRightOpIsoOpColimit_inv_comp_π","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor (Opposite J) C\ninst✝ : CategoryTheory.Limits.HasColimit F\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limitRightOpIsoOpColimit F).inv (CategoryTheory.Limits.limit.π F.rightOp j)) (CategoryTheory.Limits.colimit.ι F { unop := j }).op","decl":"@[reassoc (attr := simp)]\nlemma limitRightOpIsoOpColimit_inv_comp_π (F : Jᵒᵖ ⥤ C) [HasColimit F] (j : J) :\n    (limitRightOpIsoOpColimit F).inv ≫ limit.π F.rightOp j = (colimit.ι F (op j)).op := by\n  simp [limitRightOpIsoOpColimit]\n\n"}
{"name":"CategoryTheory.Limits.limitRightOpIsoOpColimit_inv_comp_π_assoc","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor (Opposite J) C\ninst✝ : CategoryTheory.Limits.HasColimit F\nj : J\nZ : Opposite C\nh : Quiver.Hom (F.rightOp.obj j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limitRightOpIsoOpColimit F).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π F.rightOp j) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι F { unop := j }).op h)","decl":"@[reassoc (attr := simp)]\nlemma limitRightOpIsoOpColimit_inv_comp_π (F : Jᵒᵖ ⥤ C) [HasColimit F] (j : J) :\n    (limitRightOpIsoOpColimit F).inv ≫ limit.π F.rightOp j = (colimit.ι F (op j)).op := by\n  simp [limitRightOpIsoOpColimit]\n\n"}
{"name":"CategoryTheory.Limits.limitRightOpIsoOpColimit_hom_comp_ι","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor (Opposite J) C\ninst✝ : CategoryTheory.Limits.HasColimit F\nj : Opposite J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limitRightOpIsoOpColimit F).hom (CategoryTheory.Limits.colimit.ι F j).op) (CategoryTheory.Limits.limit.π F.rightOp (Opposite.unop j))","decl":"@[reassoc (attr := simp)]\nlemma limitRightOpIsoOpColimit_hom_comp_ι (F : Jᵒᵖ ⥤ C) [HasColimit F] (j : Jᵒᵖ) :\n    (limitRightOpIsoOpColimit F).hom ≫ (colimit.ι F j).op = limit.π F.rightOp j.unop := by\n  simp [← Iso.eq_inv_comp]\n\n"}
{"name":"CategoryTheory.Limits.limitRightOpIsoOpColimit_hom_comp_ι_assoc","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor (Opposite J) C\ninst✝ : CategoryTheory.Limits.HasColimit F\nj : Opposite J\nZ : Opposite C\nh : Quiver.Hom { unop := F.obj j } Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limitRightOpIsoOpColimit F).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι F j).op h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π F.rightOp (Opposite.unop j)) h)","decl":"@[reassoc (attr := simp)]\nlemma limitRightOpIsoOpColimit_hom_comp_ι (F : Jᵒᵖ ⥤ C) [HasColimit F] (j : Jᵒᵖ) :\n    (limitRightOpIsoOpColimit F).hom ≫ (colimit.ι F j).op = limit.π F.rightOp j.unop := by\n  simp [← Iso.eq_inv_comp]\n\n"}
{"name":"CategoryTheory.Limits.limitUnopIsoUnopColimit_inv_comp_π_assoc","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor (Opposite J) (Opposite C)\ninst✝ : CategoryTheory.Limits.HasColimit F\nj : J\nZ : C\nh : Quiver.Hom (F.unop.obj j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limitUnopIsoUnopColimit F).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π F.unop j) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι F { unop := j }).unop h)","decl":"@[reassoc (attr := simp)]\nlemma limitUnopIsoUnopColimit_inv_comp_π (F : Jᵒᵖ ⥤ Cᵒᵖ) [HasColimit F] (j : J) :\n    (limitUnopIsoUnopColimit F).inv ≫ limit.π F.unop j = (colimit.ι F (op j)).unop := by\n  simp [limitUnopIsoUnopColimit]\n\n"}
{"name":"CategoryTheory.Limits.limitUnopIsoUnopColimit_inv_comp_π","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor (Opposite J) (Opposite C)\ninst✝ : CategoryTheory.Limits.HasColimit F\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limitUnopIsoUnopColimit F).inv (CategoryTheory.Limits.limit.π F.unop j)) (CategoryTheory.Limits.colimit.ι F { unop := j }).unop","decl":"@[reassoc (attr := simp)]\nlemma limitUnopIsoUnopColimit_inv_comp_π (F : Jᵒᵖ ⥤ Cᵒᵖ) [HasColimit F] (j : J) :\n    (limitUnopIsoUnopColimit F).inv ≫ limit.π F.unop j = (colimit.ι F (op j)).unop := by\n  simp [limitUnopIsoUnopColimit]\n\n"}
{"name":"CategoryTheory.Limits.limitUnopIsoUnopColimit_hom_comp_ι_assoc","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor (Opposite J) (Opposite C)\ninst✝ : CategoryTheory.Limits.HasColimit F\nj : Opposite J\nZ : C\nh : Quiver.Hom (Opposite.unop (F.obj j)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limitUnopIsoUnopColimit F).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι F j).unop h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π F.unop (Opposite.unop j)) h)","decl":"@[reassoc (attr := simp)]\nlemma limitUnopIsoUnopColimit_hom_comp_ι (F : Jᵒᵖ ⥤ Cᵒᵖ) [HasColimit F] (j : Jᵒᵖ) :\n    (limitUnopIsoUnopColimit F).hom ≫ (colimit.ι F j).unop = limit.π F.unop j.unop := by\n  simp [← Iso.eq_inv_comp]\n\n"}
{"name":"CategoryTheory.Limits.limitUnopIsoUnopColimit_hom_comp_ι","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor (Opposite J) (Opposite C)\ninst✝ : CategoryTheory.Limits.HasColimit F\nj : Opposite J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limitUnopIsoUnopColimit F).hom (CategoryTheory.Limits.colimit.ι F j).unop) (CategoryTheory.Limits.limit.π F.unop (Opposite.unop j))","decl":"@[reassoc (attr := simp)]\nlemma limitUnopIsoUnopColimit_hom_comp_ι (F : Jᵒᵖ ⥤ Cᵒᵖ) [HasColimit F] (j : Jᵒᵖ) :\n    (limitUnopIsoUnopColimit F).hom ≫ (colimit.ι F j).unop = limit.π F.unop j.unop := by\n  simp [← Iso.eq_inv_comp]\n\n"}
{"name":"CategoryTheory.Limits.hasLimitsOfShape_op_of_hasColimitsOfShape","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} J\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape (Opposite J) C\n⊢ CategoryTheory.Limits.HasLimitsOfShape J (Opposite C)","decl":"/-- If `C` has colimits of shape `Jᵒᵖ`, we can construct limits in `Cᵒᵖ` of shape `J`.\n-/\ntheorem hasLimitsOfShape_op_of_hasColimitsOfShape [HasColimitsOfShape Jᵒᵖ C] :\n    HasLimitsOfShape J Cᵒᵖ :=\n  { has_limit := fun F => hasLimit_of_hasColimit_leftOp F }\n\n"}
{"name":"CategoryTheory.Limits.hasLimitsOfShape_of_hasColimitsOfShape_op","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} J\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape (Opposite J) (Opposite C)\n⊢ CategoryTheory.Limits.HasLimitsOfShape J C","decl":"theorem hasLimitsOfShape_of_hasColimitsOfShape_op [HasColimitsOfShape Jᵒᵖ Cᵒᵖ] :\n    HasLimitsOfShape J C :=\n  { has_limit := fun F => hasLimit_of_hasColimit_op F }\n\n"}
{"name":"CategoryTheory.Limits.hasLimits_op_of_hasColimits","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Limits.HasColimitsOfSize.{v₂, u₂, v₁, u₁} C\n⊢ CategoryTheory.Limits.HasLimitsOfSize.{v₂, u₂, v₁, u₁} (Opposite C)","decl":"/-- If `C` has colimits, we can construct limits for `Cᵒᵖ`.\n-/\ninstance hasLimits_op_of_hasColimits [HasColimitsOfSize.{v₂, u₂} C] :\n    HasLimitsOfSize.{v₂, u₂} Cᵒᵖ :=\n  ⟨fun _ => inferInstance⟩\n\n"}
{"name":"CategoryTheory.Limits.hasLimits_of_hasColimits_op","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Limits.HasColimitsOfSize.{v₂, u₂, v₁, u₁} (Opposite C)\n⊢ CategoryTheory.Limits.HasLimitsOfSize.{v₂, u₂, v₁, u₁} C","decl":"theorem hasLimits_of_hasColimits_op [HasColimitsOfSize.{v₂, u₂} Cᵒᵖ] :\n    HasLimitsOfSize.{v₂, u₂} C :=\n  { has_limits_of_shape := fun _ _ => hasLimitsOfShape_of_hasColimitsOfShape_op }\n\n"}
{"name":"CategoryTheory.Limits.has_cofiltered_limits_op_of_has_filtered_colimits","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Limits.HasFilteredColimitsOfSize.{v₂, u₂, v₁, u₁} C\n⊢ CategoryTheory.Limits.HasCofilteredLimitsOfSize.{v₂, u₂, v₁, u₁} (Opposite C)","decl":"instance has_cofiltered_limits_op_of_has_filtered_colimits [HasFilteredColimitsOfSize.{v₂, u₂} C] :\n    HasCofilteredLimitsOfSize.{v₂, u₂} Cᵒᵖ where\n  HasLimitsOfShape _ _ _ := hasLimitsOfShape_op_of_hasColimitsOfShape\n\n"}
{"name":"CategoryTheory.Limits.has_cofiltered_limits_of_has_filtered_colimits_op","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Limits.HasFilteredColimitsOfSize.{v₂, u₂, v₁, u₁} (Opposite C)\n⊢ CategoryTheory.Limits.HasCofilteredLimitsOfSize.{v₂, u₂, v₁, u₁} C","decl":"theorem has_cofiltered_limits_of_has_filtered_colimits_op [HasFilteredColimitsOfSize.{v₂, u₂} Cᵒᵖ] :\n    HasCofilteredLimitsOfSize.{v₂, u₂} C :=\n  { HasLimitsOfShape := fun _ _ _ => hasLimitsOfShape_of_hasColimitsOfShape_op }\n\n"}
{"name":"CategoryTheory.Limits.hasColimit_of_hasLimit_leftOp","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor J (Opposite C)\ninst✝ : CategoryTheory.Limits.HasLimit F.leftOp\n⊢ CategoryTheory.Limits.HasColimit F","decl":"/-- If `F.leftOp : Jᵒᵖ ⥤ C` has a limit, we can construct a colimit for `F : J ⥤ Cᵒᵖ`. -/\ntheorem hasColimit_of_hasLimit_leftOp (F : J ⥤ Cᵒᵖ) [HasLimit F.leftOp] : HasColimit F :=\n  HasColimit.mk\n    { cocone := coconeOfConeLeftOp (limit.cone F.leftOp)\n      isColimit := isColimitCoconeOfConeLeftOp _ (limit.isLimit _) }\n\n"}
{"name":"CategoryTheory.Limits.hasColimit_of_hasLimit_op","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasLimit F.op\n⊢ CategoryTheory.Limits.HasColimit F","decl":"theorem hasColimit_of_hasLimit_op (F : J ⥤ C) [HasLimit F.op] : HasColimit F :=\n  HasColimit.mk\n    { cocone := (limit.cone F.op).unop\n      isColimit := (limit.isLimit _).unop }\n\n"}
{"name":"CategoryTheory.Limits.hasColimit_of_hasLimit_rightOp","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor (Opposite J) C\ninst✝ : CategoryTheory.Limits.HasLimit F.rightOp\n⊢ CategoryTheory.Limits.HasColimit F","decl":"theorem hasColimit_of_hasLimit_rightOp (F : Jᵒᵖ ⥤ C) [HasLimit F.rightOp] : HasColimit F :=\n  HasColimit.mk\n    { cocone := coconeOfConeRightOp (limit.cone F.rightOp)\n      isColimit := isColimitCoconeOfConeRightOp _ (limit.isLimit _) }\n\n"}
{"name":"CategoryTheory.Limits.hasColimit_of_hasLimit_unop","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor (Opposite J) (Opposite C)\ninst✝ : CategoryTheory.Limits.HasLimit F.unop\n⊢ CategoryTheory.Limits.HasColimit F","decl":"theorem hasColimit_of_hasLimit_unop (F : Jᵒᵖ ⥤ Cᵒᵖ) [HasLimit F.unop] : HasColimit F :=\n  HasColimit.mk\n    { cocone := coconeOfConeUnop (limit.cone F.unop)\n      isColimit := isColimitCoconeOfConeUnop _ (limit.isLimit _) }\n\n"}
{"name":"CategoryTheory.Limits.hasColimit_op_of_hasLimit","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasLimit F\n⊢ CategoryTheory.Limits.HasColimit F.op","decl":"instance hasColimit_op_of_hasLimit (F : J ⥤ C) [HasLimit F] : HasColimit F.op :=\n  HasColimit.mk\n    { cocone := (limit.cone F).op\n      isColimit := (limit.isLimit _).op }\n\n"}
{"name":"CategoryTheory.Limits.hasColimit_leftOp_of_hasLimit","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor J (Opposite C)\ninst✝ : CategoryTheory.Limits.HasLimit F\n⊢ CategoryTheory.Limits.HasColimit F.leftOp","decl":"instance hasColimit_leftOp_of_hasLimit (F : J ⥤ Cᵒᵖ) [HasLimit F] : HasColimit F.leftOp :=\n  HasColimit.mk\n    { cocone := coconeLeftOpOfCone (limit.cone F)\n      isColimit := isColimitCoconeLeftOpOfCone _ (limit.isLimit _) }\n\n"}
{"name":"CategoryTheory.Limits.hasColimit_rightOp_of_hasLimit","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor (Opposite J) C\ninst✝ : CategoryTheory.Limits.HasLimit F\n⊢ CategoryTheory.Limits.HasColimit F.rightOp","decl":"instance hasColimit_rightOp_of_hasLimit (F : Jᵒᵖ ⥤ C) [HasLimit F] : HasColimit F.rightOp :=\n  HasColimit.mk\n    { cocone := coconeRightOpOfCone (limit.cone F)\n      isColimit := isColimitCoconeRightOpOfCone _ (limit.isLimit _) }\n\n"}
{"name":"CategoryTheory.Limits.hasColimit_unop_of_hasLimit","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor (Opposite J) (Opposite C)\ninst✝ : CategoryTheory.Limits.HasLimit F\n⊢ CategoryTheory.Limits.HasColimit F.unop","decl":"instance hasColimit_unop_of_hasLimit (F : Jᵒᵖ ⥤ Cᵒᵖ) [HasLimit F] : HasColimit F.unop :=\n  HasColimit.mk\n    { cocone := coconeUnopOfCone (limit.cone F)\n      isColimit := isColimitCoconeUnopOfCone _ (limit.isLimit _) }\n\n"}
{"name":"CategoryTheory.Limits.ι_comp_colimitOpIsoOpLimit_hom","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasLimit F\nj : Opposite J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι F.op j) (CategoryTheory.Limits.colimitOpIsoOpLimit F).hom) (CategoryTheory.Limits.limit.π F (Opposite.unop j)).op","decl":"@[reassoc (attr := simp)]\nlemma ι_comp_colimitOpIsoOpLimit_hom (F : J ⥤ C) [HasLimit F] (j : Jᵒᵖ) :\n    colimit.ι F.op j ≫ (colimitOpIsoOpLimit F).hom = (limit.π F j.unop).op := by\n  simp [colimitOpIsoOpLimit]\n\n"}
{"name":"CategoryTheory.Limits.ι_comp_colimitOpIsoOpLimit_hom_assoc","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasLimit F\nj : Opposite J\nZ : Opposite C\nh : Quiver.Hom { unop := CategoryTheory.Limits.limit F } Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι F.op j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitOpIsoOpLimit F).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π F (Opposite.unop j)).op h)","decl":"@[reassoc (attr := simp)]\nlemma ι_comp_colimitOpIsoOpLimit_hom (F : J ⥤ C) [HasLimit F] (j : Jᵒᵖ) :\n    colimit.ι F.op j ≫ (colimitOpIsoOpLimit F).hom = (limit.π F j.unop).op := by\n  simp [colimitOpIsoOpLimit]\n\n"}
{"name":"CategoryTheory.Limits.π_comp_colimitOpIsoOpLimit_inv","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasLimit F\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π F j).op (CategoryTheory.Limits.colimitOpIsoOpLimit F).inv) (CategoryTheory.Limits.colimit.ι F.op { unop := j })","decl":"@[reassoc (attr := simp)]\nlemma π_comp_colimitOpIsoOpLimit_inv (F : J ⥤ C) [HasLimit F] (j : J) :\n    (limit.π F j).op ≫ (colimitOpIsoOpLimit F).inv = colimit.ι F.op (op j) := by\n  simp [Iso.comp_inv_eq]\n\n"}
{"name":"CategoryTheory.Limits.π_comp_colimitOpIsoOpLimit_inv_assoc","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasLimit F\nj : J\nZ : Opposite C\nh : Quiver.Hom (CategoryTheory.Limits.colimit F.op) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π F j).op (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitOpIsoOpLimit F).inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι F.op { unop := j }) h)","decl":"@[reassoc (attr := simp)]\nlemma π_comp_colimitOpIsoOpLimit_inv (F : J ⥤ C) [HasLimit F] (j : J) :\n    (limit.π F j).op ≫ (colimitOpIsoOpLimit F).inv = colimit.ι F.op (op j) := by\n  simp [Iso.comp_inv_eq]\n\n"}
{"name":"CategoryTheory.Limits.ι_comp_colimitLeftOpIsoUnopLimit_hom_assoc","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor J (Opposite C)\ninst✝ : CategoryTheory.Limits.HasLimit F\nj : Opposite J\nZ : C\nh : Quiver.Hom (Opposite.unop (CategoryTheory.Limits.limit F)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι F.leftOp j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitLeftOpIsoUnopLimit F).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π F (Opposite.unop j)).unop h)","decl":"@[reassoc (attr := simp)]\nlemma ι_comp_colimitLeftOpIsoUnopLimit_hom (F : J ⥤ Cᵒᵖ) [HasLimit F] (j : Jᵒᵖ) :\n    colimit.ι F.leftOp j ≫ (colimitLeftOpIsoUnopLimit F).hom = (limit.π F j.unop).unop := by\n  simp [colimitLeftOpIsoUnopLimit]\n\n"}
{"name":"CategoryTheory.Limits.ι_comp_colimitLeftOpIsoUnopLimit_hom","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor J (Opposite C)\ninst✝ : CategoryTheory.Limits.HasLimit F\nj : Opposite J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι F.leftOp j) (CategoryTheory.Limits.colimitLeftOpIsoUnopLimit F).hom) (CategoryTheory.Limits.limit.π F (Opposite.unop j)).unop","decl":"@[reassoc (attr := simp)]\nlemma ι_comp_colimitLeftOpIsoUnopLimit_hom (F : J ⥤ Cᵒᵖ) [HasLimit F] (j : Jᵒᵖ) :\n    colimit.ι F.leftOp j ≫ (colimitLeftOpIsoUnopLimit F).hom = (limit.π F j.unop).unop := by\n  simp [colimitLeftOpIsoUnopLimit]\n\n"}
{"name":"CategoryTheory.Limits.π_comp_colimitLeftOpIsoUnopLimit_inv_assoc","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor J (Opposite C)\ninst✝ : CategoryTheory.Limits.HasLimit F\nj : J\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.colimit F.leftOp) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π F j).unop (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitLeftOpIsoUnopLimit F).inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι F.leftOp { unop := j }) h)","decl":"@[reassoc (attr := simp)]\nlemma π_comp_colimitLeftOpIsoUnopLimit_inv (F : J ⥤ Cᵒᵖ) [HasLimit F] (j : J) :\n    (limit.π F j).unop ≫ (colimitLeftOpIsoUnopLimit F).inv = colimit.ι F.leftOp (op j) := by\n  simp [Iso.comp_inv_eq]\n\n"}
{"name":"CategoryTheory.Limits.π_comp_colimitLeftOpIsoUnopLimit_inv","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor J (Opposite C)\ninst✝ : CategoryTheory.Limits.HasLimit F\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π F j).unop (CategoryTheory.Limits.colimitLeftOpIsoUnopLimit F).inv) (CategoryTheory.Limits.colimit.ι F.leftOp { unop := j })","decl":"@[reassoc (attr := simp)]\nlemma π_comp_colimitLeftOpIsoUnopLimit_inv (F : J ⥤ Cᵒᵖ) [HasLimit F] (j : J) :\n    (limit.π F j).unop ≫ (colimitLeftOpIsoUnopLimit F).inv = colimit.ι F.leftOp (op j) := by\n  simp [Iso.comp_inv_eq]\n\n"}
{"name":"CategoryTheory.Limits.ι_comp_colimitRightOpIsoUnopLimit_hom_assoc","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor (Opposite J) C\ninst✝ : CategoryTheory.Limits.HasLimit F\nj : J\nZ : Opposite C\nh : Quiver.Hom { unop := CategoryTheory.Limits.limit F } Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι F.rightOp j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitRightOpIsoUnopLimit F).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π F { unop := j }).op h)","decl":"@[reassoc (attr := simp)]\nlemma ι_comp_colimitRightOpIsoUnopLimit_hom (F : Jᵒᵖ ⥤ C) [HasLimit F] (j : J) :\n    colimit.ι F.rightOp j ≫ (colimitRightOpIsoUnopLimit F).hom = (limit.π F (op j)).op := by\n  simp [colimitRightOpIsoUnopLimit]\n\n"}
{"name":"CategoryTheory.Limits.ι_comp_colimitRightOpIsoUnopLimit_hom","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor (Opposite J) C\ninst✝ : CategoryTheory.Limits.HasLimit F\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι F.rightOp j) (CategoryTheory.Limits.colimitRightOpIsoUnopLimit F).hom) (CategoryTheory.Limits.limit.π F { unop := j }).op","decl":"@[reassoc (attr := simp)]\nlemma ι_comp_colimitRightOpIsoUnopLimit_hom (F : Jᵒᵖ ⥤ C) [HasLimit F] (j : J) :\n    colimit.ι F.rightOp j ≫ (colimitRightOpIsoUnopLimit F).hom = (limit.π F (op j)).op := by\n  simp [colimitRightOpIsoUnopLimit]\n\n"}
{"name":"CategoryTheory.Limits.π_comp_colimitRightOpIsoUnopLimit_inv","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor (Opposite J) C\ninst✝ : CategoryTheory.Limits.HasLimit F\nj : Opposite J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π F j).op (CategoryTheory.Limits.colimitRightOpIsoUnopLimit F).inv) (CategoryTheory.Limits.colimit.ι F.rightOp (Opposite.unop j))","decl":"@[reassoc (attr := simp)]\nlemma π_comp_colimitRightOpIsoUnopLimit_inv (F : Jᵒᵖ ⥤ C) [HasLimit F] (j : Jᵒᵖ) :\n    (limit.π F j).op ≫ (colimitRightOpIsoUnopLimit F).inv = colimit.ι F.rightOp j.unop := by\n  simp [Iso.comp_inv_eq]\n\n"}
{"name":"CategoryTheory.Limits.π_comp_colimitRightOpIsoUnopLimit_inv_assoc","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor (Opposite J) C\ninst✝ : CategoryTheory.Limits.HasLimit F\nj : Opposite J\nZ : Opposite C\nh : Quiver.Hom (CategoryTheory.Limits.colimit F.rightOp) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π F j).op (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitRightOpIsoUnopLimit F).inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι F.rightOp (Opposite.unop j)) h)","decl":"@[reassoc (attr := simp)]\nlemma π_comp_colimitRightOpIsoUnopLimit_inv (F : Jᵒᵖ ⥤ C) [HasLimit F] (j : Jᵒᵖ) :\n    (limit.π F j).op ≫ (colimitRightOpIsoUnopLimit F).inv = colimit.ι F.rightOp j.unop := by\n  simp [Iso.comp_inv_eq]\n\n"}
{"name":"CategoryTheory.Limits.ι_comp_colimitUnopIsoOpLimit_hom","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor (Opposite J) (Opposite C)\ninst✝ : CategoryTheory.Limits.HasLimit F\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι F.unop j) (CategoryTheory.Limits.colimitUnopIsoOpLimit F).hom) (CategoryTheory.Limits.limit.π F { unop := j }).unop","decl":"@[reassoc (attr := simp)]\nlemma ι_comp_colimitUnopIsoOpLimit_hom (F : Jᵒᵖ ⥤ Cᵒᵖ) [HasLimit F] (j : J) :\n    colimit.ι F.unop j ≫ (colimitUnopIsoOpLimit F).hom = (limit.π F (op j)).unop := by\n  simp [colimitUnopIsoOpLimit]\n\n"}
{"name":"CategoryTheory.Limits.ι_comp_colimitUnopIsoOpLimit_hom_assoc","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor (Opposite J) (Opposite C)\ninst✝ : CategoryTheory.Limits.HasLimit F\nj : J\nZ : C\nh : Quiver.Hom (Opposite.unop (CategoryTheory.Limits.limit F)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι F.unop j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitUnopIsoOpLimit F).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π F { unop := j }).unop h)","decl":"@[reassoc (attr := simp)]\nlemma ι_comp_colimitUnopIsoOpLimit_hom (F : Jᵒᵖ ⥤ Cᵒᵖ) [HasLimit F] (j : J) :\n    colimit.ι F.unop j ≫ (colimitUnopIsoOpLimit F).hom = (limit.π F (op j)).unop := by\n  simp [colimitUnopIsoOpLimit]\n\n"}
{"name":"CategoryTheory.Limits.π_comp_colimitUnopIsoOpLimit_inv","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor (Opposite J) (Opposite C)\ninst✝ : CategoryTheory.Limits.HasLimit F\nj : Opposite J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π F j).unop (CategoryTheory.Limits.colimitUnopIsoOpLimit F).inv) (CategoryTheory.Limits.colimit.ι F.unop (Opposite.unop j))","decl":"@[reassoc (attr := simp)]\nlemma π_comp_colimitUnopIsoOpLimit_inv (F : Jᵒᵖ ⥤ Cᵒᵖ) [HasLimit F] (j : Jᵒᵖ) :\n    (limit.π F j).unop ≫ (colimitUnopIsoOpLimit F).inv = colimit.ι F.unop j.unop := by\n  simp [Iso.comp_inv_eq]\n\n"}
{"name":"CategoryTheory.Limits.π_comp_colimitUnopIsoOpLimit_inv_assoc","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor (Opposite J) (Opposite C)\ninst✝ : CategoryTheory.Limits.HasLimit F\nj : Opposite J\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.colimit F.unop) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π F j).unop (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitUnopIsoOpLimit F).inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι F.unop (Opposite.unop j)) h)","decl":"@[reassoc (attr := simp)]\nlemma π_comp_colimitUnopIsoOpLimit_inv (F : Jᵒᵖ ⥤ Cᵒᵖ) [HasLimit F] (j : Jᵒᵖ) :\n    (limit.π F j).unop ≫ (colimitUnopIsoOpLimit F).inv = colimit.ι F.unop j.unop := by\n  simp [Iso.comp_inv_eq]\n\n"}
{"name":"CategoryTheory.Limits.hasColimitsOfShape_op_of_hasLimitsOfShape","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} J\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape (Opposite J) C\n⊢ CategoryTheory.Limits.HasColimitsOfShape J (Opposite C)","decl":"/-- If `C` has colimits of shape `Jᵒᵖ`, we can construct limits in `Cᵒᵖ` of shape `J`.\n-/\ninstance hasColimitsOfShape_op_of_hasLimitsOfShape [HasLimitsOfShape Jᵒᵖ C] :\n    HasColimitsOfShape J Cᵒᵖ where has_colimit F := hasColimit_of_hasLimit_leftOp F\n\n"}
{"name":"CategoryTheory.Limits.hasColimitsOfShape_of_hasLimitsOfShape_op","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} J\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape (Opposite J) (Opposite C)\n⊢ CategoryTheory.Limits.HasColimitsOfShape J C","decl":"theorem hasColimitsOfShape_of_hasLimitsOfShape_op [HasLimitsOfShape Jᵒᵖ Cᵒᵖ] :\n    HasColimitsOfShape J C :=\n  { has_colimit := fun F => hasColimit_of_hasLimit_op F }\n\n"}
{"name":"CategoryTheory.Limits.hasColimits_op_of_hasLimits","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Limits.HasLimitsOfSize.{v₂, u₂, v₁, u₁} C\n⊢ CategoryTheory.Limits.HasColimitsOfSize.{v₂, u₂, v₁, u₁} (Opposite C)","decl":"/-- If `C` has limits, we can construct colimits for `Cᵒᵖ`.\n-/\ninstance hasColimits_op_of_hasLimits [HasLimitsOfSize.{v₂, u₂} C] :\n    HasColimitsOfSize.{v₂, u₂} Cᵒᵖ :=\n  ⟨fun _ => inferInstance⟩\n\n"}
{"name":"CategoryTheory.Limits.hasColimits_of_hasLimits_op","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Limits.HasLimitsOfSize.{v₂, u₂, v₁, u₁} (Opposite C)\n⊢ CategoryTheory.Limits.HasColimitsOfSize.{v₂, u₂, v₁, u₁} C","decl":"theorem hasColimits_of_hasLimits_op [HasLimitsOfSize.{v₂, u₂} Cᵒᵖ] :\n    HasColimitsOfSize.{v₂, u₂} C :=\n  { has_colimits_of_shape := fun _ _ => hasColimitsOfShape_of_hasLimitsOfShape_op }\n\n"}
{"name":"CategoryTheory.Limits.has_filtered_colimits_op_of_has_cofiltered_limits","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Limits.HasCofilteredLimitsOfSize.{v₂, u₂, v₁, u₁} C\n⊢ CategoryTheory.Limits.HasFilteredColimitsOfSize.{v₂, u₂, v₁, u₁} (Opposite C)","decl":"instance has_filtered_colimits_op_of_has_cofiltered_limits [HasCofilteredLimitsOfSize.{v₂, u₂} C] :\n    HasFilteredColimitsOfSize.{v₂, u₂} Cᵒᵖ where HasColimitsOfShape _ _ _ := inferInstance\n\n"}
{"name":"CategoryTheory.Limits.has_filtered_colimits_of_has_cofiltered_limits_op","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Limits.HasCofilteredLimitsOfSize.{v₂, u₂, v₁, u₁} (Opposite C)\n⊢ CategoryTheory.Limits.HasFilteredColimitsOfSize.{v₂, u₂, v₁, u₁} C","decl":"theorem has_filtered_colimits_of_has_cofiltered_limits_op [HasCofilteredLimitsOfSize.{v₂, u₂} Cᵒᵖ] :\n    HasFilteredColimitsOfSize.{v₂, u₂} C :=\n  { HasColimitsOfShape := fun _ _ _ => hasColimitsOfShape_of_hasLimitsOfShape_op }\n\n"}
{"name":"CategoryTheory.Limits.hasCoproductsOfShape_opposite","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nX : Type v₂\ninst✝ : CategoryTheory.Limits.HasProductsOfShape X C\n⊢ CategoryTheory.Limits.HasCoproductsOfShape X (Opposite C)","decl":"/-- If `C` has products indexed by `X`, then `Cᵒᵖ` has coproducts indexed by `X`.\n-/\ninstance hasCoproductsOfShape_opposite [HasProductsOfShape X C] : HasCoproductsOfShape X Cᵒᵖ := by\n  haveI : HasLimitsOfShape (Discrete X)ᵒᵖ C :=\n    hasLimitsOfShape_of_equivalence (Discrete.opposite X).symm\n  infer_instance\n\n"}
{"name":"CategoryTheory.Limits.hasCoproductsOfShape_of_opposite","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nX : Type v₂\ninst✝ : CategoryTheory.Limits.HasProductsOfShape X (Opposite C)\n⊢ CategoryTheory.Limits.HasCoproductsOfShape X C","decl":"theorem hasCoproductsOfShape_of_opposite [HasProductsOfShape X Cᵒᵖ] : HasCoproductsOfShape X C :=\n  haveI : HasLimitsOfShape (Discrete X)ᵒᵖ Cᵒᵖ :=\n    hasLimitsOfShape_of_equivalence (Discrete.opposite X).symm\n  hasColimitsOfShape_of_hasLimitsOfShape_op\n\n"}
{"name":"CategoryTheory.Limits.hasProductsOfShape_opposite","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nX : Type v₂\ninst✝ : CategoryTheory.Limits.HasCoproductsOfShape X C\n⊢ CategoryTheory.Limits.HasProductsOfShape X (Opposite C)","decl":"/-- If `C` has coproducts indexed by `X`, then `Cᵒᵖ` has products indexed by `X`.\n-/\ninstance hasProductsOfShape_opposite [HasCoproductsOfShape X C] : HasProductsOfShape X Cᵒᵖ := by\n  haveI : HasColimitsOfShape (Discrete X)ᵒᵖ C :=\n    hasColimitsOfShape_of_equivalence (Discrete.opposite X).symm\n  infer_instance\n\n"}
{"name":"CategoryTheory.Limits.hasProductsOfShape_of_opposite","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nX : Type v₂\ninst✝ : CategoryTheory.Limits.HasCoproductsOfShape X (Opposite C)\n⊢ CategoryTheory.Limits.HasProductsOfShape X C","decl":"theorem hasProductsOfShape_of_opposite [HasCoproductsOfShape X Cᵒᵖ] : HasProductsOfShape X C :=\n  haveI : HasColimitsOfShape (Discrete X)ᵒᵖ Cᵒᵖ :=\n    hasColimitsOfShape_of_equivalence (Discrete.opposite X).symm\n  hasLimitsOfShape_of_hasColimitsOfShape_op\n\n"}
{"name":"CategoryTheory.Limits.hasProducts_opposite","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Limits.HasCoproducts C\n⊢ CategoryTheory.Limits.HasProducts (Opposite C)","decl":"instance hasProducts_opposite [HasCoproducts.{v₂} C] : HasProducts.{v₂} Cᵒᵖ := fun _ =>\n  inferInstance\n\n"}
{"name":"CategoryTheory.Limits.hasProducts_of_opposite","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Limits.HasCoproducts (Opposite C)\n⊢ CategoryTheory.Limits.HasProducts C","decl":"theorem hasProducts_of_opposite [HasCoproducts.{v₂} Cᵒᵖ] : HasProducts.{v₂} C := fun X =>\n  hasProductsOfShape_of_opposite X\n\n"}
{"name":"CategoryTheory.Limits.hasCoproducts_opposite","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Limits.HasProducts C\n⊢ CategoryTheory.Limits.HasCoproducts (Opposite C)","decl":"instance hasCoproducts_opposite [HasProducts.{v₂} C] : HasCoproducts.{v₂} Cᵒᵖ := fun _ =>\n  inferInstance\n\n"}
{"name":"CategoryTheory.Limits.hasCoproducts_of_opposite","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Limits.HasProducts (Opposite C)\n⊢ CategoryTheory.Limits.HasCoproducts C","decl":"theorem hasCoproducts_of_opposite [HasProducts.{v₂} Cᵒᵖ] : HasCoproducts.{v₂} C := fun X =>\n  hasCoproductsOfShape_of_opposite X\n\n"}
{"name":"CategoryTheory.Limits.hasFiniteCoproducts_opposite","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Limits.HasFiniteProducts C\n⊢ CategoryTheory.Limits.HasFiniteCoproducts (Opposite C)","decl":"instance hasFiniteCoproducts_opposite [HasFiniteProducts C] : HasFiniteCoproducts Cᵒᵖ where\n  out _ := Limits.hasCoproductsOfShape_opposite _\n\n"}
{"name":"CategoryTheory.Limits.hasFiniteCoproducts_of_opposite","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Limits.HasFiniteProducts (Opposite C)\n⊢ CategoryTheory.Limits.HasFiniteCoproducts C","decl":"theorem hasFiniteCoproducts_of_opposite [HasFiniteProducts Cᵒᵖ] : HasFiniteCoproducts C :=\n  { out := fun _ => hasCoproductsOfShape_of_opposite _ }\n\n"}
{"name":"CategoryTheory.Limits.hasFiniteProducts_opposite","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Limits.HasFiniteCoproducts C\n⊢ CategoryTheory.Limits.HasFiniteProducts (Opposite C)","decl":"instance hasFiniteProducts_opposite [HasFiniteCoproducts C] : HasFiniteProducts Cᵒᵖ where\n  out _ := inferInstance\n\n"}
{"name":"CategoryTheory.Limits.hasFiniteProducts_of_opposite","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Limits.HasFiniteCoproducts (Opposite C)\n⊢ CategoryTheory.Limits.HasFiniteProducts C","decl":"theorem hasFiniteProducts_of_opposite [HasFiniteCoproducts Cᵒᵖ] : HasFiniteProducts C :=\n  { out := fun _ => hasProductsOfShape_of_opposite _ }\n\n"}
{"name":"CategoryTheory.Limits.instHasLimitOppositeDiscreteOpFunctor","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nα : Type u_1\nZ : α → C\ninst✝ : CategoryTheory.Limits.HasCoproduct Z\n⊢ CategoryTheory.Limits.HasLimit (CategoryTheory.Discrete.functor Z).op","decl":"instance : HasLimit (Discrete.functor Z).op := hasLimit_op_of_hasColimit (Discrete.functor Z)\n\n"}
{"name":"CategoryTheory.Limits.instHasLimitDiscreteOppositeCompInverseOppositeOpFunctor","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nα : Type u_1\nZ : α → C\ninst✝ : CategoryTheory.Limits.HasCoproduct Z\n⊢ CategoryTheory.Limits.HasLimit ((CategoryTheory.Discrete.opposite α).inverse.comp (CategoryTheory.Discrete.functor Z).op)","decl":"instance : HasLimit ((Discrete.opposite α).inverse ⋙ (Discrete.functor Z).op) :=\n  hasLimitEquivalenceComp (Discrete.opposite α).symm\n\n"}
{"name":"CategoryTheory.Limits.instHasProductOppositeOp","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nα : Type u_1\nZ : α → C\ninst✝ : CategoryTheory.Limits.HasCoproduct Z\n⊢ CategoryTheory.Limits.HasProduct fun x => { unop := Z x }","decl":"instance : HasProduct (op <| Z ·) := hasLimitOfIso\n  ((Discrete.natIsoFunctor ≪≫ Discrete.natIso (fun _ ↦ by rfl)) :\n    (Discrete.opposite α).inverse ⋙ (Discrete.functor Z).op ≅\n    Discrete.functor (op <| Z ·))\n\n"}
{"name":"CategoryTheory.Limits.opCoproductIsoProduct'_inv_comp_inj","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nα : Type u_1\nZ : α → C\nc : CategoryTheory.Limits.Cofan Z\nf : CategoryTheory.Limits.Fan fun x => { unop := Z x }\nhc : CategoryTheory.Limits.IsColimit c\nhf : CategoryTheory.Limits.IsLimit f\nb : α\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.opCoproductIsoProduct' hc hf).inv (c.inj b).op) (f.proj b)","decl":"theorem opCoproductIsoProduct'_inv_comp_inj {c : Cofan Z} {f : Fan (op <| Z ·)}\n    (hc : IsColimit c) (hf : IsLimit f) (b : α) :\n    (opCoproductIsoProduct' hc hf).inv ≫ (c.inj b).op = f.proj b :=\n  IsLimit.conePointUniqueUpToIso_inv_comp (Cofan.IsColimit.op hc) hf ⟨b⟩\n\n"}
{"name":"CategoryTheory.Limits.opCoproductIsoProduct'_comp_self","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nα : Type u_1\nZ : α → C\nc c' : CategoryTheory.Limits.Cofan Z\nf : CategoryTheory.Limits.Fan fun x => { unop := Z x }\nhc : CategoryTheory.Limits.IsColimit c\nhc' : CategoryTheory.Limits.IsColimit c'\nhf : CategoryTheory.Limits.IsLimit f\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.opCoproductIsoProduct' hc hf).hom (CategoryTheory.Limits.opCoproductIsoProduct' hc' hf).inv) (hc.coconePointUniqueUpToIso hc').op.inv","decl":"theorem opCoproductIsoProduct'_comp_self {c c' : Cofan Z} {f : Fan (op <| Z ·)}\n    (hc : IsColimit c) (hc' : IsColimit c') (hf : IsLimit f) :\n    (opCoproductIsoProduct' hc hf).hom ≫ (opCoproductIsoProduct' hc' hf).inv =\n    (hc.coconePointUniqueUpToIso hc').op.inv := by\n  apply Quiver.Hom.unop_inj\n  apply hc'.hom_ext\n  intro ⟨j⟩\n  change c'.inj _ ≫ _ = _\n  simp only [unop_op, unop_comp, Discrete.functor_obj, const_obj_obj, Iso.op_inv,\n    Quiver.Hom.unop_op, IsColimit.comp_coconePointUniqueUpToIso_inv]\n  apply Quiver.Hom.op_inj\n  simp only [op_comp, op_unop, Quiver.Hom.op_unop, Category.assoc,\n    opCoproductIsoProduct'_inv_comp_inj]\n  rw [← opCoproductIsoProduct'_inv_comp_inj hc hf]\n  simp only [Iso.hom_inv_id_assoc]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.opCoproductIsoProduct_inv_comp_ι","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nα : Type u_1\nZ : α → C\ninst✝ : CategoryTheory.Limits.HasCoproduct Z\nb : α\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.opCoproductIsoProduct Z).inv (CategoryTheory.Limits.Sigma.ι Z b).op) (CategoryTheory.Limits.Pi.π (fun x => { unop := Z x }) b)","decl":"variable (Z) in\ntheorem opCoproductIsoProduct_inv_comp_ι [HasCoproduct Z] (b : α) :\n    (opCoproductIsoProduct Z).inv ≫ (Sigma.ι Z b).op = Pi.π (op <| Z ·) b :=\n  opCoproductIsoProduct'_inv_comp_inj _ _ b\n\n"}
{"name":"CategoryTheory.Limits.desc_op_comp_opCoproductIsoProduct'_hom","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nα : Type u_1\nZ : α → C\nc : CategoryTheory.Limits.Cofan Z\nf : CategoryTheory.Limits.Fan fun x => { unop := Z x }\nhc : CategoryTheory.Limits.IsColimit c\nhf : CategoryTheory.Limits.IsLimit f\nc' : CategoryTheory.Limits.Cofan Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (hc.desc c').op (CategoryTheory.Limits.opCoproductIsoProduct' hc hf).hom) (hf.lift c'.op)","decl":"theorem desc_op_comp_opCoproductIsoProduct'_hom {c : Cofan Z} {f : Fan (op <| Z ·)}\n    (hc : IsColimit c) (hf : IsLimit f) (c' : Cofan Z) :\n    (hc.desc c').op ≫ (opCoproductIsoProduct' hc hf).hom = hf.lift c'.op := by\n  refine (Iso.eq_comp_inv _).mp (Quiver.Hom.unop_inj (hc.hom_ext (fun ⟨j⟩ ↦ Quiver.Hom.op_inj ?_)))\n  simp only [unop_op, Discrete.functor_obj, const_obj_obj, Quiver.Hom.unop_op, IsColimit.fac,\n    Cofan.op, unop_comp, op_comp, op_unop, Quiver.Hom.op_unop, Category.assoc]\n  erw [opCoproductIsoProduct'_inv_comp_inj, IsLimit.fac]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.desc_op_comp_opCoproductIsoProduct_hom","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nα : Type u_1\nZ : α → C\ninst✝ : CategoryTheory.Limits.HasCoproduct Z\nX : C\nπ : (a : α) → Quiver.Hom (Z a) X\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.desc π).op (CategoryTheory.Limits.opCoproductIsoProduct Z).hom) (CategoryTheory.Limits.Pi.lift fun a => (π a).op)","decl":"theorem desc_op_comp_opCoproductIsoProduct_hom [HasCoproduct Z] {X : C} (π : (a : α) → Z a ⟶ X) :\n    (Sigma.desc π).op ≫ (opCoproductIsoProduct Z).hom = Pi.lift (fun a ↦ (π a).op) := by\n  convert desc_op_comp_opCoproductIsoProduct'_hom (coproductIsCoproduct Z)\n    (productIsProduct (op <| Z ·)) (Cofan.mk _ π)\n  · ext; simp [Sigma.desc, coproductIsCoproduct]\n  · ext; simp [Pi.lift, productIsProduct]\n\n"}
{"name":"CategoryTheory.Limits.instHasColimitOppositeDiscreteOpFunctor","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nα : Type u_1\nZ : α → C\ninst✝ : CategoryTheory.Limits.HasProduct Z\n⊢ CategoryTheory.Limits.HasColimit (CategoryTheory.Discrete.functor Z).op","decl":"instance : HasColimit (Discrete.functor Z).op := hasColimit_op_of_hasLimit (Discrete.functor Z)\n\n"}
{"name":"CategoryTheory.Limits.instHasColimitDiscreteOppositeCompInverseOppositeOpFunctor","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nα : Type u_1\nZ : α → C\ninst✝ : CategoryTheory.Limits.HasProduct Z\n⊢ CategoryTheory.Limits.HasColimit ((CategoryTheory.Discrete.opposite α).inverse.comp (CategoryTheory.Discrete.functor Z).op)","decl":"instance : HasColimit ((Discrete.opposite α).inverse ⋙ (Discrete.functor Z).op) :=\n  hasColimit_equivalence_comp (Discrete.opposite α).symm\n\n"}
{"name":"CategoryTheory.Limits.instHasCoproductOppositeOp","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nα : Type u_1\nZ : α → C\ninst✝ : CategoryTheory.Limits.HasProduct Z\n⊢ CategoryTheory.Limits.HasCoproduct fun x => { unop := Z x }","decl":"instance : HasCoproduct (op <| Z ·) := hasColimitOfIso\n  ((Discrete.natIsoFunctor ≪≫ Discrete.natIso (fun _ ↦ by rfl)) :\n    (Discrete.opposite α).inverse ⋙ (Discrete.functor Z).op ≅\n    Discrete.functor (op <| Z ·)).symm\n\n"}
{"name":"CategoryTheory.Limits.proj_comp_opProductIsoCoproduct'_hom","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nα : Type u_1\nZ : α → C\nf : CategoryTheory.Limits.Fan Z\nc : CategoryTheory.Limits.Cofan fun x => { unop := Z x }\nhf : CategoryTheory.Limits.IsLimit f\nhc : CategoryTheory.Limits.IsColimit c\nb : α\n⊢ Eq (CategoryTheory.CategoryStruct.comp (f.proj b).op (CategoryTheory.Limits.opProductIsoCoproduct' hf hc).hom) (c.inj b)","decl":"theorem proj_comp_opProductIsoCoproduct'_hom {f : Fan Z} {c : Cofan (op <| Z ·)}\n    (hf : IsLimit f) (hc : IsColimit c) (b : α) :\n    (f.proj b).op ≫ (opProductIsoCoproduct' hf hc).hom = c.inj b :=\n  IsColimit.comp_coconePointUniqueUpToIso_hom (Fan.IsLimit.op hf) hc ⟨b⟩\n\n"}
{"name":"CategoryTheory.Limits.opProductIsoCoproduct'_comp_self","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nα : Type u_1\nZ : α → C\nf f' : CategoryTheory.Limits.Fan Z\nc : CategoryTheory.Limits.Cofan fun x => { unop := Z x }\nhf : CategoryTheory.Limits.IsLimit f\nhf' : CategoryTheory.Limits.IsLimit f'\nhc : CategoryTheory.Limits.IsColimit c\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.opProductIsoCoproduct' hf hc).hom (CategoryTheory.Limits.opProductIsoCoproduct' hf' hc).inv) (hf.conePointUniqueUpToIso hf').op.inv","decl":"theorem opProductIsoCoproduct'_comp_self {f f' : Fan Z} {c : Cofan (op <| Z ·)}\n    (hf : IsLimit f) (hf' : IsLimit f') (hc : IsColimit c) :\n    (opProductIsoCoproduct' hf hc).hom ≫ (opProductIsoCoproduct' hf' hc).inv =\n    (hf.conePointUniqueUpToIso hf').op.inv := by\n  apply Quiver.Hom.unop_inj\n  apply hf.hom_ext\n  intro ⟨j⟩\n  change _ ≫ f.proj _ = _\n  simp only [unop_op, unop_comp, Category.assoc, Discrete.functor_obj, Iso.op_inv,\n    Quiver.Hom.unop_op, IsLimit.conePointUniqueUpToIso_inv_comp]\n  apply Quiver.Hom.op_inj\n  simp only [op_comp, op_unop, Quiver.Hom.op_unop, proj_comp_opProductIsoCoproduct'_hom]\n  rw [← proj_comp_opProductIsoCoproduct'_hom hf' hc]\n  simp only [Category.assoc, Iso.hom_inv_id, Category.comp_id]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.π_comp_opProductIsoCoproduct_hom","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nα : Type u_1\nZ : α → C\ninst✝ : CategoryTheory.Limits.HasProduct Z\nb : α\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.π Z b).op (CategoryTheory.Limits.opProductIsoCoproduct Z).hom) (CategoryTheory.Limits.Sigma.ι (fun x => { unop := Z x }) b)","decl":"variable (Z) in\ntheorem π_comp_opProductIsoCoproduct_hom [HasProduct Z] (b : α) :\n    (Pi.π Z b).op ≫ (opProductIsoCoproduct Z).hom = Sigma.ι (op <| Z ·) b :=\n  proj_comp_opProductIsoCoproduct'_hom _ _ b\n\n"}
{"name":"CategoryTheory.Limits.opProductIsoCoproduct'_inv_comp_lift","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nα : Type u_1\nZ : α → C\nf : CategoryTheory.Limits.Fan Z\nc : CategoryTheory.Limits.Cofan fun x => { unop := Z x }\nhf : CategoryTheory.Limits.IsLimit f\nhc : CategoryTheory.Limits.IsColimit c\nf' : CategoryTheory.Limits.Fan Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.opProductIsoCoproduct' hf hc).inv (hf.lift f').op) (hc.desc f'.op)","decl":"theorem opProductIsoCoproduct'_inv_comp_lift {f : Fan Z} {c : Cofan (op <| Z ·)}\n    (hf : IsLimit f) (hc : IsColimit c) (f' : Fan Z) :\n    (opProductIsoCoproduct' hf hc).inv ≫ (hf.lift f').op = hc.desc f'.op := by\n  refine (Iso.inv_comp_eq _).mpr (Quiver.Hom.unop_inj (hf.hom_ext (fun ⟨j⟩ ↦ Quiver.Hom.op_inj ?_)))\n  simp only [Discrete.functor_obj, unop_op, Quiver.Hom.unop_op, IsLimit.fac, Fan.op, unop_comp,\n    Category.assoc, op_comp, op_unop, Quiver.Hom.op_unop]\n  erw [← Category.assoc, proj_comp_opProductIsoCoproduct'_hom, IsColimit.fac]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.opProductIsoCoproduct_inv_comp_lift","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nα : Type u_1\nZ : α → C\ninst✝ : CategoryTheory.Limits.HasProduct Z\nX : C\nπ : (a : α) → Quiver.Hom X (Z a)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.opProductIsoCoproduct Z).inv (CategoryTheory.Limits.Pi.lift π).op) (CategoryTheory.Limits.Sigma.desc fun a => (π a).op)","decl":"theorem opProductIsoCoproduct_inv_comp_lift [HasProduct Z] {X : C} (π : (a : α) → X ⟶ Z a) :\n    (opProductIsoCoproduct Z).inv ≫ (Pi.lift π).op  = Sigma.desc (fun a ↦ (π a).op) := by\n  convert opProductIsoCoproduct'_inv_comp_lift (productIsProduct Z)\n    (coproductIsCoproduct (op <| Z ·)) (Fan.mk _ π)\n  · ext; simp [Pi.lift, productIsProduct]\n  · ext; simp [Sigma.desc, coproductIsCoproduct]\n\n"}
{"name":"CategoryTheory.Limits.instHasBinaryCoproductOppositeOp","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nA B : C\n⊢ CategoryTheory.Limits.HasBinaryCoproduct { unop := A } { unop := B }","decl":"instance : HasBinaryCoproduct (op A) (op B) := by\n  have : HasProduct fun x ↦ (WalkingPair.casesOn x A B : C) := ‹_›\n  show HasCoproduct _\n  convert inferInstanceAs (HasCoproduct fun x ↦ op (WalkingPair.casesOn x A B : C)) with x\n  cases x <;> rfl\n\n"}
{"name":"CategoryTheory.Limits.fst_opProdIsoCoprod_hom_assoc","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nA B : C\ninst✝ : CategoryTheory.Limits.HasBinaryProduct A B\nZ : Opposite C\nh : Quiver.Hom (CategoryTheory.Limits.coprod { unop := A } { unop := B }) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.fst.op (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.opProdIsoCoprod A B).hom h)) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inl h)","decl":"@[reassoc (attr := simp)]\nlemma fst_opProdIsoCoprod_hom : prod.fst.op ≫ (opProdIsoCoprod A B).hom = coprod.inl := by\n  rw [opProdIsoCoprod, ← op_comp, prod.lift_fst, Quiver.Hom.op_unop]\n\n"}
{"name":"CategoryTheory.Limits.fst_opProdIsoCoprod_hom","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nA B : C\ninst✝ : CategoryTheory.Limits.HasBinaryProduct A B\n⊢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.fst.op (CategoryTheory.Limits.opProdIsoCoprod A B).hom) CategoryTheory.Limits.coprod.inl","decl":"@[reassoc (attr := simp)]\nlemma fst_opProdIsoCoprod_hom : prod.fst.op ≫ (opProdIsoCoprod A B).hom = coprod.inl := by\n  rw [opProdIsoCoprod, ← op_comp, prod.lift_fst, Quiver.Hom.op_unop]\n\n"}
{"name":"CategoryTheory.Limits.snd_opProdIsoCoprod_hom_assoc","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nA B : C\ninst✝ : CategoryTheory.Limits.HasBinaryProduct A B\nZ : Opposite C\nh : Quiver.Hom (CategoryTheory.Limits.coprod { unop := A } { unop := B }) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd.op (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.opProdIsoCoprod A B).hom h)) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inr h)","decl":"@[reassoc (attr := simp)]\nlemma snd_opProdIsoCoprod_hom : prod.snd.op ≫ (opProdIsoCoprod A B).hom = coprod.inr := by\n  rw [opProdIsoCoprod, ← op_comp, prod.lift_snd, Quiver.Hom.op_unop]\n\n"}
{"name":"CategoryTheory.Limits.snd_opProdIsoCoprod_hom","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nA B : C\ninst✝ : CategoryTheory.Limits.HasBinaryProduct A B\n⊢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd.op (CategoryTheory.Limits.opProdIsoCoprod A B).hom) CategoryTheory.Limits.coprod.inr","decl":"@[reassoc (attr := simp)]\nlemma snd_opProdIsoCoprod_hom : prod.snd.op ≫ (opProdIsoCoprod A B).hom = coprod.inr := by\n  rw [opProdIsoCoprod, ← op_comp, prod.lift_snd, Quiver.Hom.op_unop]\n\n"}
{"name":"CategoryTheory.Limits.inl_opProdIsoCoprod_inv","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nA B : C\ninst✝ : CategoryTheory.Limits.HasBinaryProduct A B\n⊢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inl (CategoryTheory.Limits.opProdIsoCoprod A B).inv) CategoryTheory.Limits.prod.fst.op","decl":"@[reassoc (attr := simp)]\nlemma inl_opProdIsoCoprod_inv : coprod.inl ≫ (opProdIsoCoprod A B).inv = prod.fst.op := by\n  rw [Iso.comp_inv_eq, fst_opProdIsoCoprod_hom]\n\n"}
{"name":"CategoryTheory.Limits.inl_opProdIsoCoprod_inv_assoc","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nA B : C\ninst✝ : CategoryTheory.Limits.HasBinaryProduct A B\nZ : Opposite C\nh : Quiver.Hom { unop := CategoryTheory.Limits.prod A B } Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inl (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.opProdIsoCoprod A B).inv h)) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.fst.op h)","decl":"@[reassoc (attr := simp)]\nlemma inl_opProdIsoCoprod_inv : coprod.inl ≫ (opProdIsoCoprod A B).inv = prod.fst.op := by\n  rw [Iso.comp_inv_eq, fst_opProdIsoCoprod_hom]\n\n"}
{"name":"CategoryTheory.Limits.inr_opProdIsoCoprod_inv_assoc","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nA B : C\ninst✝ : CategoryTheory.Limits.HasBinaryProduct A B\nZ : Opposite C\nh : Quiver.Hom { unop := CategoryTheory.Limits.prod A B } Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inr (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.opProdIsoCoprod A B).inv h)) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd.op h)","decl":"@[reassoc (attr := simp)]\nlemma inr_opProdIsoCoprod_inv : coprod.inr ≫ (opProdIsoCoprod A B).inv = prod.snd.op := by\n  rw [Iso.comp_inv_eq, snd_opProdIsoCoprod_hom]\n\n"}
{"name":"CategoryTheory.Limits.inr_opProdIsoCoprod_inv","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nA B : C\ninst✝ : CategoryTheory.Limits.HasBinaryProduct A B\n⊢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inr (CategoryTheory.Limits.opProdIsoCoprod A B).inv) CategoryTheory.Limits.prod.snd.op","decl":"@[reassoc (attr := simp)]\nlemma inr_opProdIsoCoprod_inv : coprod.inr ≫ (opProdIsoCoprod A B).inv = prod.snd.op := by\n  rw [Iso.comp_inv_eq, snd_opProdIsoCoprod_hom]\n\n"}
{"name":"CategoryTheory.Limits.opProdIsoCoprod_hom_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nA B : C\ninst✝ : CategoryTheory.Limits.HasBinaryProduct A B\nZ : C\nh : Quiver.Hom A Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.opProdIsoCoprod A B).hom.unop (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.fst h)) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inl.unop h)","decl":"@[reassoc (attr := simp)]\nlemma opProdIsoCoprod_hom_fst : (opProdIsoCoprod A B).hom.unop ≫ prod.fst = coprod.inl.unop := by\n  simp [opProdIsoCoprod]\n\n"}
{"name":"CategoryTheory.Limits.opProdIsoCoprod_hom_fst","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nA B : C\ninst✝ : CategoryTheory.Limits.HasBinaryProduct A B\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.opProdIsoCoprod A B).hom.unop CategoryTheory.Limits.prod.fst) CategoryTheory.Limits.coprod.inl.unop","decl":"@[reassoc (attr := simp)]\nlemma opProdIsoCoprod_hom_fst : (opProdIsoCoprod A B).hom.unop ≫ prod.fst = coprod.inl.unop := by\n  simp [opProdIsoCoprod]\n\n"}
{"name":"CategoryTheory.Limits.opProdIsoCoprod_hom_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nA B : C\ninst✝ : CategoryTheory.Limits.HasBinaryProduct A B\nZ : C\nh : Quiver.Hom B Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.opProdIsoCoprod A B).hom.unop (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd h)) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inr.unop h)","decl":"@[reassoc (attr := simp)]\nlemma opProdIsoCoprod_hom_snd : (opProdIsoCoprod A B).hom.unop ≫ prod.snd = coprod.inr.unop := by\n  simp [opProdIsoCoprod]\n\n"}
{"name":"CategoryTheory.Limits.opProdIsoCoprod_hom_snd","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nA B : C\ninst✝ : CategoryTheory.Limits.HasBinaryProduct A B\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.opProdIsoCoprod A B).hom.unop CategoryTheory.Limits.prod.snd) CategoryTheory.Limits.coprod.inr.unop","decl":"@[reassoc (attr := simp)]\nlemma opProdIsoCoprod_hom_snd : (opProdIsoCoprod A B).hom.unop ≫ prod.snd = coprod.inr.unop := by\n  simp [opProdIsoCoprod]\n\n"}
{"name":"CategoryTheory.Limits.opProdIsoCoprod_inv_inl","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nA B : C\ninst✝ : CategoryTheory.Limits.HasBinaryProduct A B\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.opProdIsoCoprod A B).inv.unop CategoryTheory.Limits.coprod.inl.unop) CategoryTheory.Limits.prod.fst","decl":"@[reassoc (attr := simp)]\nlemma opProdIsoCoprod_inv_inl : (opProdIsoCoprod A B).inv.unop ≫ coprod.inl.unop = prod.fst := by\n  rw [← unop_comp, inl_opProdIsoCoprod_inv, Quiver.Hom.unop_op]\n\n"}
{"name":"CategoryTheory.Limits.opProdIsoCoprod_inv_inl_assoc","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nA B : C\ninst✝ : CategoryTheory.Limits.HasBinaryProduct A B\nZ : C\nh : Quiver.Hom A Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.opProdIsoCoprod A B).inv.unop (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inl.unop h)) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.fst h)","decl":"@[reassoc (attr := simp)]\nlemma opProdIsoCoprod_inv_inl : (opProdIsoCoprod A B).inv.unop ≫ coprod.inl.unop = prod.fst := by\n  rw [← unop_comp, inl_opProdIsoCoprod_inv, Quiver.Hom.unop_op]\n\n"}
{"name":"CategoryTheory.Limits.opProdIsoCoprod_inv_inr_assoc","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nA B : C\ninst✝ : CategoryTheory.Limits.HasBinaryProduct A B\nZ : C\nh : Quiver.Hom B Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.opProdIsoCoprod A B).inv.unop (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inr.unop h)) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd h)","decl":"@[reassoc (attr := simp)]\nlemma opProdIsoCoprod_inv_inr : (opProdIsoCoprod A B).inv.unop ≫ coprod.inr.unop = prod.snd := by\n  rw [← unop_comp, inr_opProdIsoCoprod_inv, Quiver.Hom.unop_op]\n\n"}
{"name":"CategoryTheory.Limits.opProdIsoCoprod_inv_inr","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nA B : C\ninst✝ : CategoryTheory.Limits.HasBinaryProduct A B\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.opProdIsoCoprod A B).inv.unop CategoryTheory.Limits.coprod.inr.unop) CategoryTheory.Limits.prod.snd","decl":"@[reassoc (attr := simp)]\nlemma opProdIsoCoprod_inv_inr : (opProdIsoCoprod A B).inv.unop ≫ coprod.inr.unop = prod.snd := by\n  rw [← unop_comp, inr_opProdIsoCoprod_inv, Quiver.Hom.unop_op]\n\n"}
{"name":"CategoryTheory.Limits.hasEqualizers_opposite","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Limits.HasCoequalizers C\n⊢ CategoryTheory.Limits.HasEqualizers (Opposite C)","decl":"instance hasEqualizers_opposite [HasCoequalizers C] : HasEqualizers Cᵒᵖ := by\n  haveI : HasColimitsOfShape WalkingParallelPairᵒᵖ C :=\n    hasColimitsOfShape_of_equivalence walkingParallelPairOpEquiv\n  infer_instance\n\n"}
{"name":"CategoryTheory.Limits.hasCoequalizers_opposite","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Limits.HasEqualizers C\n⊢ CategoryTheory.Limits.HasCoequalizers (Opposite C)","decl":"instance hasCoequalizers_opposite [HasEqualizers C] : HasCoequalizers Cᵒᵖ := by\n  haveI : HasLimitsOfShape WalkingParallelPairᵒᵖ C :=\n    hasLimitsOfShape_of_equivalence walkingParallelPairOpEquiv\n  infer_instance\n\n"}
{"name":"CategoryTheory.Limits.hasFiniteColimits_opposite","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Limits.HasFiniteLimits C\n⊢ CategoryTheory.Limits.HasFiniteColimits (Opposite C)","decl":"instance hasFiniteColimits_opposite [HasFiniteLimits C] : HasFiniteColimits Cᵒᵖ :=\n  ⟨fun _ _ _ => inferInstance⟩\n\n"}
{"name":"CategoryTheory.Limits.hasFiniteLimits_opposite","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Limits.HasFiniteColimits C\n⊢ CategoryTheory.Limits.HasFiniteLimits (Opposite C)","decl":"instance hasFiniteLimits_opposite [HasFiniteColimits C] : HasFiniteLimits Cᵒᵖ :=\n  ⟨fun _ _ _ => inferInstance⟩\n\n"}
{"name":"CategoryTheory.Limits.hasPullbacks_opposite","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Limits.HasPushouts C\n⊢ CategoryTheory.Limits.HasPullbacks (Opposite C)","decl":"instance hasPullbacks_opposite [HasPushouts C] : HasPullbacks Cᵒᵖ := by\n  haveI : HasColimitsOfShape WalkingCospanᵒᵖ C :=\n    hasColimitsOfShape_of_equivalence walkingCospanOpEquiv.symm\n  apply hasLimitsOfShape_op_of_hasColimitsOfShape\n\n"}
{"name":"CategoryTheory.Limits.hasPushouts_opposite","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\n⊢ CategoryTheory.Limits.HasPushouts (Opposite C)","decl":"instance hasPushouts_opposite [HasPullbacks C] : HasPushouts Cᵒᵖ := by\n  haveI : HasLimitsOfShape WalkingSpanᵒᵖ C :=\n    hasLimitsOfShape_of_equivalence walkingSpanOpEquiv.symm\n  infer_instance\n\n"}
{"name":"CategoryTheory.Limits.spanOp_hom_app","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX✝ Y Z : C\nf : Quiver.Hom X✝ Z\ng : Quiver.Hom Y Z\nX : CategoryTheory.Limits.WalkingSpan\n⊢ Eq ((CategoryTheory.Limits.spanOp f g).hom.app X) (Option.rec (CategoryTheory.Iso.refl { unop := Z }) (fun val => CategoryTheory.Limits.WalkingPair.rec (CategoryTheory.Iso.refl { unop := X✝ }) (CategoryTheory.Iso.refl { unop := Y }) val) X).hom","decl":"/-- The canonical isomorphism relating `Span f.op g.op` and `(Cospan f g).op` -/\n@[simps!]\ndef spanOp {X Y Z : C} (f : X ⟶ Z) (g : Y ⟶ Z) :\n    span f.op g.op ≅ walkingCospanOpEquiv.inverse ⋙ (cospan f g).op :=\n  NatIso.ofComponents (by rintro (_ | _ | _) <;> rfl)\n    (by rintro (_ | _ | _) (_ | _ | _) f <;> cases f <;> aesop_cat)\n\n"}
{"name":"CategoryTheory.Limits.spanOp_inv_app","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX✝ Y Z : C\nf : Quiver.Hom X✝ Z\ng : Quiver.Hom Y Z\nX : CategoryTheory.Limits.WalkingSpan\n⊢ Eq ((CategoryTheory.Limits.spanOp f g).inv.app X) (Option.rec (CategoryTheory.Iso.refl { unop := Z }) (fun val => CategoryTheory.Limits.WalkingPair.rec (CategoryTheory.Iso.refl { unop := X✝ }) (CategoryTheory.Iso.refl { unop := Y }) val) X).inv","decl":"/-- The canonical isomorphism relating `Span f.op g.op` and `(Cospan f g).op` -/\n@[simps!]\ndef spanOp {X Y Z : C} (f : X ⟶ Z) (g : Y ⟶ Z) :\n    span f.op g.op ≅ walkingCospanOpEquiv.inverse ⋙ (cospan f g).op :=\n  NatIso.ofComponents (by rintro (_ | _ | _) <;> rfl)\n    (by rintro (_ | _ | _) (_ | _ | _) f <;> cases f <;> aesop_cat)\n\n"}
{"name":"CategoryTheory.Limits.opCospan_inv_app","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX✝ Y Z : C\nf : Quiver.Hom X✝ Z\ng : Quiver.Hom Y Z\nX : Opposite CategoryTheory.Limits.WalkingCospan\n⊢ Eq ((CategoryTheory.Limits.opCospan f g).inv.app X) (Option.rec (CategoryTheory.Iso.refl { unop := Z }) (fun val => CategoryTheory.Limits.WalkingPair.rec (CategoryTheory.Iso.refl { unop := X✝ }) (CategoryTheory.Iso.refl { unop := Y }) val) (Opposite.unop X)).hom","decl":"/-- The canonical isomorphism relating `(Cospan f g).op` and `Span f.op g.op` -/\n@[simps!]\ndef opCospan {X Y Z : C} (f : X ⟶ Z) (g : Y ⟶ Z) :\n    (cospan f g).op ≅ walkingCospanOpEquiv.functor ⋙ span f.op g.op :=\n  calc\n    (cospan f g).op ≅ 𝟭 _ ⋙ (cospan f g).op := by rfl\n    _ ≅ (walkingCospanOpEquiv.functor ⋙ walkingCospanOpEquiv.inverse) ⋙ (cospan f g).op :=\n      (isoWhiskerRight walkingCospanOpEquiv.unitIso _)\n    _ ≅ walkingCospanOpEquiv.functor ⋙ walkingCospanOpEquiv.inverse ⋙ (cospan f g).op :=\n      (Functor.associator _ _ _)\n    _ ≅ walkingCospanOpEquiv.functor ⋙ span f.op g.op := isoWhiskerLeft _ (spanOp f g).symm\n\n"}
{"name":"CategoryTheory.Limits.opCospan_hom_app","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX✝ Y Z : C\nf : Quiver.Hom X✝ Z\ng : Quiver.Hom Y Z\nX : Opposite CategoryTheory.Limits.WalkingCospan\n⊢ Eq ((CategoryTheory.Limits.opCospan f g).hom.app X) (Option.rec (CategoryTheory.Iso.refl { unop := Z }) (fun val => CategoryTheory.Limits.WalkingPair.rec (CategoryTheory.Iso.refl { unop := X✝ }) (CategoryTheory.Iso.refl { unop := Y }) val) (Opposite.unop X)).inv","decl":"/-- The canonical isomorphism relating `(Cospan f g).op` and `Span f.op g.op` -/\n@[simps!]\ndef opCospan {X Y Z : C} (f : X ⟶ Z) (g : Y ⟶ Z) :\n    (cospan f g).op ≅ walkingCospanOpEquiv.functor ⋙ span f.op g.op :=\n  calc\n    (cospan f g).op ≅ 𝟭 _ ⋙ (cospan f g).op := by rfl\n    _ ≅ (walkingCospanOpEquiv.functor ⋙ walkingCospanOpEquiv.inverse) ⋙ (cospan f g).op :=\n      (isoWhiskerRight walkingCospanOpEquiv.unitIso _)\n    _ ≅ walkingCospanOpEquiv.functor ⋙ walkingCospanOpEquiv.inverse ⋙ (cospan f g).op :=\n      (Functor.associator _ _ _)\n    _ ≅ walkingCospanOpEquiv.functor ⋙ span f.op g.op := isoWhiskerLeft _ (spanOp f g).symm\n\n"}
{"name":"CategoryTheory.Limits.cospanOp_hom_app","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX✝ Y Z : C\nf : Quiver.Hom X✝ Y\ng : Quiver.Hom X✝ Z\nX : CategoryTheory.Limits.WalkingCospan\n⊢ Eq ((CategoryTheory.Limits.cospanOp f g).hom.app X) (Option.rec (CategoryTheory.Iso.refl { unop := X✝ }) (fun val => CategoryTheory.Limits.WalkingPair.rec (CategoryTheory.Iso.refl { unop := Y }) (CategoryTheory.Iso.refl { unop := Z }) val) X).hom","decl":"/-- The canonical isomorphism relating `Cospan f.op g.op` and `(Span f g).op` -/\n@[simps!]\ndef cospanOp {X Y Z : C} (f : X ⟶ Y) (g : X ⟶ Z) :\n    cospan f.op g.op ≅ walkingSpanOpEquiv.inverse ⋙ (span f g).op :=\n  NatIso.ofComponents (by rintro (_ | _ | _) <;> rfl)\n    (by rintro (_ | _ | _) (_ | _ | _) f <;> cases f <;> aesop_cat)\n\n"}
{"name":"CategoryTheory.Limits.cospanOp_inv_app","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX✝ Y Z : C\nf : Quiver.Hom X✝ Y\ng : Quiver.Hom X✝ Z\nX : CategoryTheory.Limits.WalkingCospan\n⊢ Eq ((CategoryTheory.Limits.cospanOp f g).inv.app X) (Option.rec (CategoryTheory.Iso.refl { unop := X✝ }) (fun val => CategoryTheory.Limits.WalkingPair.rec (CategoryTheory.Iso.refl { unop := Y }) (CategoryTheory.Iso.refl { unop := Z }) val) X).inv","decl":"/-- The canonical isomorphism relating `Cospan f.op g.op` and `(Span f g).op` -/\n@[simps!]\ndef cospanOp {X Y Z : C} (f : X ⟶ Y) (g : X ⟶ Z) :\n    cospan f.op g.op ≅ walkingSpanOpEquiv.inverse ⋙ (span f g).op :=\n  NatIso.ofComponents (by rintro (_ | _ | _) <;> rfl)\n    (by rintro (_ | _ | _) (_ | _ | _) f <;> cases f <;> aesop_cat)\n\n"}
{"name":"CategoryTheory.Limits.opSpan_hom_app","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX✝ Y Z : C\nf : Quiver.Hom X✝ Y\ng : Quiver.Hom X✝ Z\nX : Opposite CategoryTheory.Limits.WalkingSpan\n⊢ Eq ((CategoryTheory.Limits.opSpan f g).hom.app X) (Option.rec (CategoryTheory.Iso.refl { unop := X✝ }) (fun val => CategoryTheory.Limits.WalkingPair.rec (CategoryTheory.Iso.refl { unop := Y }) (CategoryTheory.Iso.refl { unop := Z }) val) (Opposite.unop X)).inv","decl":"/-- The canonical isomorphism relating `(Span f g).op` and `Cospan f.op g.op` -/\n@[simps!]\ndef opSpan {X Y Z : C} (f : X ⟶ Y) (g : X ⟶ Z) :\n    (span f g).op ≅ walkingSpanOpEquiv.functor ⋙ cospan f.op g.op :=\n  calc\n    (span f g).op ≅ 𝟭 _ ⋙ (span f g).op := by rfl\n    _ ≅ (walkingSpanOpEquiv.functor ⋙ walkingSpanOpEquiv.inverse) ⋙ (span f g).op :=\n      (isoWhiskerRight walkingSpanOpEquiv.unitIso _)\n    _ ≅ walkingSpanOpEquiv.functor ⋙ walkingSpanOpEquiv.inverse ⋙ (span f g).op :=\n      (Functor.associator _ _ _)\n    _ ≅ walkingSpanOpEquiv.functor ⋙ cospan f.op g.op := isoWhiskerLeft _ (cospanOp f g).symm\n\n"}
{"name":"CategoryTheory.Limits.opSpan_inv_app","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX✝ Y Z : C\nf : Quiver.Hom X✝ Y\ng : Quiver.Hom X✝ Z\nX : Opposite CategoryTheory.Limits.WalkingSpan\n⊢ Eq ((CategoryTheory.Limits.opSpan f g).inv.app X) (Option.rec (CategoryTheory.Iso.refl { unop := X✝ }) (fun val => CategoryTheory.Limits.WalkingPair.rec (CategoryTheory.Iso.refl { unop := Y }) (CategoryTheory.Iso.refl { unop := Z }) val) (Opposite.unop X)).hom","decl":"/-- The canonical isomorphism relating `(Span f g).op` and `Cospan f.op g.op` -/\n@[simps!]\ndef opSpan {X Y Z : C} (f : X ⟶ Y) (g : X ⟶ Z) :\n    (span f g).op ≅ walkingSpanOpEquiv.functor ⋙ cospan f.op g.op :=\n  calc\n    (span f g).op ≅ 𝟭 _ ⋙ (span f g).op := by rfl\n    _ ≅ (walkingSpanOpEquiv.functor ⋙ walkingSpanOpEquiv.inverse) ⋙ (span f g).op :=\n      (isoWhiskerRight walkingSpanOpEquiv.unitIso _)\n    _ ≅ walkingSpanOpEquiv.functor ⋙ walkingSpanOpEquiv.inverse ⋙ (span f g).op :=\n      (Functor.associator _ _ _)\n    _ ≅ walkingSpanOpEquiv.functor ⋙ cospan f.op g.op := isoWhiskerLeft _ (cospanOp f g).symm\n\n"}
{"name":"CategoryTheory.Limits.PushoutCocone.unop_π_app","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX✝ Y Z : Opposite C\nf : Quiver.Hom X✝ Y\ng : Quiver.Hom X✝ Z\nc : CategoryTheory.Limits.PushoutCocone f g\nX : CategoryTheory.Limits.WalkingCospan\n⊢ Eq (c.unop.π.app X) (CategoryTheory.CategoryStruct.comp (c.ι.app X).unop (Option.rec (CategoryTheory.Iso.refl X✝) (fun val => CategoryTheory.Limits.WalkingPair.rec (CategoryTheory.Iso.refl Y) (CategoryTheory.Iso.refl Z) val) X).inv.unop)","decl":"/-- The obvious map `PushoutCocone f g → PullbackCone f.unop g.unop` -/\n@[simps!]\ndef unop {X Y Z : Cᵒᵖ} {f : X ⟶ Y} {g : X ⟶ Z} (c : PushoutCocone f g) :\n    PullbackCone f.unop g.unop :=\n  Cocone.unop\n    ((Cocones.precompose (opCospan f.unop g.unop).hom).obj\n      (Cocone.whisker walkingCospanOpEquiv.functor c))\n\n"}
{"name":"CategoryTheory.Limits.PushoutCocone.unop_pt","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX Y Z : Opposite C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\nc : CategoryTheory.Limits.PushoutCocone f g\n⊢ Eq c.unop.pt (Opposite.unop c.pt)","decl":"/-- The obvious map `PushoutCocone f g → PullbackCone f.unop g.unop` -/\n@[simps!]\ndef unop {X Y Z : Cᵒᵖ} {f : X ⟶ Y} {g : X ⟶ Z} (c : PushoutCocone f g) :\n    PullbackCone f.unop g.unop :=\n  Cocone.unop\n    ((Cocones.precompose (opCospan f.unop g.unop).hom).obj\n      (Cocone.whisker walkingCospanOpEquiv.functor c))\n\n"}
{"name":"CategoryTheory.Limits.PushoutCocone.unop_fst","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX Y Z : Opposite C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\nc : CategoryTheory.Limits.PushoutCocone f g\n⊢ Eq c.unop.fst c.inl.unop","decl":"theorem unop_fst {X Y Z : Cᵒᵖ} {f : X ⟶ Y} {g : X ⟶ Z} (c : PushoutCocone f g) :\n    c.unop.fst = c.inl.unop := by simp\n\n"}
{"name":"CategoryTheory.Limits.PushoutCocone.unop_snd","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX Y Z : Opposite C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\nc : CategoryTheory.Limits.PushoutCocone f g\n⊢ Eq c.unop.snd c.inr.unop","decl":"theorem unop_snd {X Y Z : Cᵒᵖ} {f : X ⟶ Y} {g : X ⟶ Z} (c : PushoutCocone f g) :\n    c.unop.snd = c.inr.unop := by simp\n\n"}
{"name":"CategoryTheory.Limits.PushoutCocone.op_pt","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\nc : CategoryTheory.Limits.PushoutCocone f g\n⊢ Eq c.op.pt { unop := c.pt }","decl":"/-- The obvious map `PushoutCocone f.op g.op → PullbackCone f g` -/\n@[simps!]\ndef op {X Y Z : C} {f : X ⟶ Y} {g : X ⟶ Z} (c : PushoutCocone f g) : PullbackCone f.op g.op :=\n  (Cones.postcompose (cospanOp f g).symm.hom).obj\n    (Cone.whisker walkingSpanOpEquiv.inverse (Cocone.op c))\n\n"}
{"name":"CategoryTheory.Limits.PushoutCocone.op_π_app","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX✝ Y Z : C\nf : Quiver.Hom X✝ Y\ng : Quiver.Hom X✝ Z\nc : CategoryTheory.Limits.PushoutCocone f g\nX : CategoryTheory.Limits.WalkingCospan\n⊢ Eq (c.op.π.app X) (CategoryTheory.CategoryStruct.comp (c.ι.app X).op (Option.rec (CategoryTheory.Iso.refl { unop := X✝ }) (fun val => CategoryTheory.Limits.WalkingPair.rec (CategoryTheory.Iso.refl { unop := Y }) (CategoryTheory.Iso.refl { unop := Z }) val) X).inv)","decl":"/-- The obvious map `PushoutCocone f.op g.op → PullbackCone f g` -/\n@[simps!]\ndef op {X Y Z : C} {f : X ⟶ Y} {g : X ⟶ Z} (c : PushoutCocone f g) : PullbackCone f.op g.op :=\n  (Cones.postcompose (cospanOp f g).symm.hom).obj\n    (Cone.whisker walkingSpanOpEquiv.inverse (Cocone.op c))\n\n"}
{"name":"CategoryTheory.Limits.PushoutCocone.op_fst","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\nc : CategoryTheory.Limits.PushoutCocone f g\n⊢ Eq c.op.fst c.inl.op","decl":"theorem op_fst {X Y Z : C} {f : X ⟶ Y} {g : X ⟶ Z} (c : PushoutCocone f g) :\n    c.op.fst = c.inl.op := by simp\n\n"}
{"name":"CategoryTheory.Limits.PushoutCocone.op_snd","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\nc : CategoryTheory.Limits.PushoutCocone f g\n⊢ Eq c.op.snd c.inr.op","decl":"theorem op_snd {X Y Z : C} {f : X ⟶ Y} {g : X ⟶ Z} (c : PushoutCocone f g) :\n    c.op.snd = c.inr.op := by simp\n\n"}
{"name":"CategoryTheory.Limits.PullbackCone.unop_ι_app","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX✝ Y Z : Opposite C\nf : Quiver.Hom X✝ Z\ng : Quiver.Hom Y Z\nc : CategoryTheory.Limits.PullbackCone f g\nX : CategoryTheory.Limits.WalkingSpan\n⊢ Eq (c.unop.ι.app X) (CategoryTheory.CategoryStruct.comp (Option.rec (CategoryTheory.Iso.refl Z) (fun val => CategoryTheory.Limits.WalkingPair.rec (CategoryTheory.Iso.refl X✝) (CategoryTheory.Iso.refl Y) val) X).hom.unop (c.π.app X).unop)","decl":"/-- The obvious map `PullbackCone f g → PushoutCocone f.unop g.unop` -/\n@[simps!]\ndef unop {X Y Z : Cᵒᵖ} {f : X ⟶ Z} {g : Y ⟶ Z} (c : PullbackCone f g) :\n    PushoutCocone f.unop g.unop :=\n  Cone.unop\n    ((Cones.postcompose (opSpan f.unop g.unop).symm.hom).obj\n      (Cone.whisker walkingSpanOpEquiv.functor c))\n\n"}
{"name":"CategoryTheory.Limits.PullbackCone.unop_pt","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX Y Z : Opposite C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nc : CategoryTheory.Limits.PullbackCone f g\n⊢ Eq c.unop.pt (Opposite.unop c.pt)","decl":"/-- The obvious map `PullbackCone f g → PushoutCocone f.unop g.unop` -/\n@[simps!]\ndef unop {X Y Z : Cᵒᵖ} {f : X ⟶ Z} {g : Y ⟶ Z} (c : PullbackCone f g) :\n    PushoutCocone f.unop g.unop :=\n  Cone.unop\n    ((Cones.postcompose (opSpan f.unop g.unop).symm.hom).obj\n      (Cone.whisker walkingSpanOpEquiv.functor c))\n\n"}
{"name":"CategoryTheory.Limits.PullbackCone.unop_inl","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX Y Z : Opposite C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nc : CategoryTheory.Limits.PullbackCone f g\n⊢ Eq c.unop.inl c.fst.unop","decl":"theorem unop_inl {X Y Z : Cᵒᵖ} {f : X ⟶ Z} {g : Y ⟶ Z} (c : PullbackCone f g) :\n    c.unop.inl = c.fst.unop := by simp\n\n"}
{"name":"CategoryTheory.Limits.PullbackCone.unop_inr","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX Y Z : Opposite C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nc : CategoryTheory.Limits.PullbackCone f g\n⊢ Eq c.unop.inr c.snd.unop","decl":"theorem unop_inr {X Y Z : Cᵒᵖ} {f : X ⟶ Z} {g : Y ⟶ Z} (c : PullbackCone f g) :\n    c.unop.inr = c.snd.unop := by simp\n\n"}
{"name":"CategoryTheory.Limits.PullbackCone.op_ι_app","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX✝ Y Z : C\nf : Quiver.Hom X✝ Z\ng : Quiver.Hom Y Z\nc : CategoryTheory.Limits.PullbackCone f g\nX : CategoryTheory.Limits.WalkingSpan\n⊢ Eq (c.op.ι.app X) (CategoryTheory.CategoryStruct.comp (Option.rec (CategoryTheory.Iso.refl { unop := Z }) (fun val => CategoryTheory.Limits.WalkingPair.rec (CategoryTheory.Iso.refl { unop := X✝ }) (CategoryTheory.Iso.refl { unop := Y }) val) X).hom (c.π.app X).op)","decl":"/-- The obvious map `PullbackCone f g → PushoutCocone f.op g.op` -/\n@[simps!]\ndef op {X Y Z : C} {f : X ⟶ Z} {g : Y ⟶ Z} (c : PullbackCone f g) : PushoutCocone f.op g.op :=\n  (Cocones.precompose (spanOp f g).hom).obj\n    (Cocone.whisker walkingCospanOpEquiv.inverse (Cone.op c))\n\n"}
{"name":"CategoryTheory.Limits.PullbackCone.op_pt","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nc : CategoryTheory.Limits.PullbackCone f g\n⊢ Eq c.op.pt { unop := c.pt }","decl":"/-- The obvious map `PullbackCone f g → PushoutCocone f.op g.op` -/\n@[simps!]\ndef op {X Y Z : C} {f : X ⟶ Z} {g : Y ⟶ Z} (c : PullbackCone f g) : PushoutCocone f.op g.op :=\n  (Cocones.precompose (spanOp f g).hom).obj\n    (Cocone.whisker walkingCospanOpEquiv.inverse (Cone.op c))\n\n"}
{"name":"CategoryTheory.Limits.PullbackCone.op_inl","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nc : CategoryTheory.Limits.PullbackCone f g\n⊢ Eq c.op.inl c.fst.op","decl":"theorem op_inl {X Y Z : C} {f : X ⟶ Z} {g : Y ⟶ Z} (c : PullbackCone f g) :\n    c.op.inl = c.fst.op := by simp\n\n"}
{"name":"CategoryTheory.Limits.PullbackCone.op_inr","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nc : CategoryTheory.Limits.PullbackCone f g\n⊢ Eq c.op.inr c.snd.op","decl":"theorem op_inr {X Y Z : C} {f : X ⟶ Z} {g : Y ⟶ Z} (c : PullbackCone f g) :\n    c.op.inr = c.snd.op := by simp\n\n"}
{"name":"CategoryTheory.Limits.pullbackIsoUnopPushout_inv_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nX Y Z✝ : C\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\ninst✝¹ : CategoryTheory.Limits.HasPullback f g\ninst✝ : CategoryTheory.Limits.HasPushout f.op g.op\nZ : C\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackIsoUnopPushout f g).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f g) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl f.op g.op).unop h)","decl":"@[reassoc (attr := simp)]\ntheorem pullbackIsoUnopPushout_inv_fst {X Y Z : C} (f : X ⟶ Z) (g : Y ⟶ Z) [HasPullback f g]\n    [HasPushout f.op g.op] :\n    (pullbackIsoUnopPushout f g).inv ≫ pullback.fst f g =\n      (pushout.inl _ _ : _ ⟶ pushout f.op g.op).unop :=\n  (IsLimit.conePointUniqueUpToIso_inv_comp _ _ _).trans (by simp [unop_id (X := { unop := X })])\n\n"}
{"name":"CategoryTheory.Limits.pullbackIsoUnopPushout_inv_fst","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝¹ : CategoryTheory.Limits.HasPullback f g\ninst✝ : CategoryTheory.Limits.HasPushout f.op g.op\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackIsoUnopPushout f g).inv (CategoryTheory.Limits.pullback.fst f g)) (CategoryTheory.Limits.pushout.inl f.op g.op).unop","decl":"@[reassoc (attr := simp)]\ntheorem pullbackIsoUnopPushout_inv_fst {X Y Z : C} (f : X ⟶ Z) (g : Y ⟶ Z) [HasPullback f g]\n    [HasPushout f.op g.op] :\n    (pullbackIsoUnopPushout f g).inv ≫ pullback.fst f g =\n      (pushout.inl _ _ : _ ⟶ pushout f.op g.op).unop :=\n  (IsLimit.conePointUniqueUpToIso_inv_comp _ _ _).trans (by simp [unop_id (X := { unop := X })])\n\n"}
{"name":"CategoryTheory.Limits.pullbackIsoUnopPushout_inv_snd","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝¹ : CategoryTheory.Limits.HasPullback f g\ninst✝ : CategoryTheory.Limits.HasPushout f.op g.op\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackIsoUnopPushout f g).inv (CategoryTheory.Limits.pullback.snd f g)) (CategoryTheory.Limits.pushout.inr f.op g.op).unop","decl":"@[reassoc (attr := simp)]\ntheorem pullbackIsoUnopPushout_inv_snd {X Y Z : C} (f : X ⟶ Z) (g : Y ⟶ Z) [HasPullback f g]\n    [HasPushout f.op g.op] :\n    (pullbackIsoUnopPushout f g).inv ≫ pullback.snd f g =\n      (pushout.inr _ _ : _ ⟶ pushout f.op g.op).unop :=\n  (IsLimit.conePointUniqueUpToIso_inv_comp _ _ _).trans (by simp [unop_id (X := { unop := Y })])\n\n"}
{"name":"CategoryTheory.Limits.pullbackIsoUnopPushout_inv_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nX Y Z✝ : C\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\ninst✝¹ : CategoryTheory.Limits.HasPullback f g\ninst✝ : CategoryTheory.Limits.HasPushout f.op g.op\nZ : C\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackIsoUnopPushout f g).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f g) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr f.op g.op).unop h)","decl":"@[reassoc (attr := simp)]\ntheorem pullbackIsoUnopPushout_inv_snd {X Y Z : C} (f : X ⟶ Z) (g : Y ⟶ Z) [HasPullback f g]\n    [HasPushout f.op g.op] :\n    (pullbackIsoUnopPushout f g).inv ≫ pullback.snd f g =\n      (pushout.inr _ _ : _ ⟶ pushout f.op g.op).unop :=\n  (IsLimit.conePointUniqueUpToIso_inv_comp _ _ _).trans (by simp [unop_id (X := { unop := Y })])\n\n"}
{"name":"CategoryTheory.Limits.pullbackIsoUnopPushout_hom_inl","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝¹ : CategoryTheory.Limits.HasPullback f g\ninst✝ : CategoryTheory.Limits.HasPushout f.op g.op\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl f.op g.op) (CategoryTheory.Limits.pullbackIsoUnopPushout f g).hom.op) (CategoryTheory.Limits.pullback.fst f g).op","decl":"@[reassoc (attr := simp)]\ntheorem pullbackIsoUnopPushout_hom_inl {X Y Z : C} (f : X ⟶ Z) (g : Y ⟶ Z) [HasPullback f g]\n    [HasPushout f.op g.op] :\n    pushout.inl _ _ ≫ (pullbackIsoUnopPushout f g).hom.op = (pullback.fst f g).op := by\n  apply Quiver.Hom.unop_inj\n  dsimp\n  rw [← pullbackIsoUnopPushout_inv_fst, Iso.hom_inv_id_assoc]\n\n"}
{"name":"CategoryTheory.Limits.pullbackIsoUnopPushout_hom_inl_assoc","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nX Y Z✝ : C\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\ninst✝¹ : CategoryTheory.Limits.HasPullback f g\ninst✝ : CategoryTheory.Limits.HasPushout f.op g.op\nZ : Opposite C\nh : Quiver.Hom { unop := CategoryTheory.Limits.pullback f g } Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl f.op g.op) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackIsoUnopPushout f g).hom.op h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f g).op h)","decl":"@[reassoc (attr := simp)]\ntheorem pullbackIsoUnopPushout_hom_inl {X Y Z : C} (f : X ⟶ Z) (g : Y ⟶ Z) [HasPullback f g]\n    [HasPushout f.op g.op] :\n    pushout.inl _ _ ≫ (pullbackIsoUnopPushout f g).hom.op = (pullback.fst f g).op := by\n  apply Quiver.Hom.unop_inj\n  dsimp\n  rw [← pullbackIsoUnopPushout_inv_fst, Iso.hom_inv_id_assoc]\n\n"}
{"name":"CategoryTheory.Limits.pullbackIsoUnopPushout_hom_inr_assoc","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nX Y Z✝ : C\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\ninst✝¹ : CategoryTheory.Limits.HasPullback f g\ninst✝ : CategoryTheory.Limits.HasPushout f.op g.op\nZ : Opposite C\nh : Quiver.Hom { unop := CategoryTheory.Limits.pullback f g } Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr f.op g.op) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackIsoUnopPushout f g).hom.op h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f g).op h)","decl":"@[reassoc (attr := simp)]\ntheorem pullbackIsoUnopPushout_hom_inr {X Y Z : C} (f : X ⟶ Z) (g : Y ⟶ Z) [HasPullback f g]\n    [HasPushout f.op g.op] : pushout.inr _ _ ≫ (pullbackIsoUnopPushout f g).hom.op =\n    (pullback.snd f g).op := by\n  apply Quiver.Hom.unop_inj\n  dsimp\n  rw [← pullbackIsoUnopPushout_inv_snd, Iso.hom_inv_id_assoc]\n\n"}
{"name":"CategoryTheory.Limits.pullbackIsoUnopPushout_hom_inr","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝¹ : CategoryTheory.Limits.HasPullback f g\ninst✝ : CategoryTheory.Limits.HasPushout f.op g.op\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr f.op g.op) (CategoryTheory.Limits.pullbackIsoUnopPushout f g).hom.op) (CategoryTheory.Limits.pullback.snd f g).op","decl":"@[reassoc (attr := simp)]\ntheorem pullbackIsoUnopPushout_hom_inr {X Y Z : C} (f : X ⟶ Z) (g : Y ⟶ Z) [HasPullback f g]\n    [HasPushout f.op g.op] : pushout.inr _ _ ≫ (pullbackIsoUnopPushout f g).hom.op =\n    (pullback.snd f g).op := by\n  apply Quiver.Hom.unop_inj\n  dsimp\n  rw [← pullbackIsoUnopPushout_inv_snd, Iso.hom_inv_id_assoc]\n\n"}
{"name":"CategoryTheory.Limits.pushoutIsoUnopPullback_inl_hom_assoc","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nX Y Z✝ : C\nf : Quiver.Hom X Z✝\ng : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.Limits.HasPushout f g\ninst✝ : CategoryTheory.Limits.HasPullback f.op g.op\nZ : C\nh : Quiver.Hom (Opposite.unop (CategoryTheory.Limits.pullback f.op g.op)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushoutIsoUnopPullback f g).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f.op g.op).unop h)","decl":"@[reassoc (attr := simp)]\ntheorem pushoutIsoUnopPullback_inl_hom {X Y Z : C} (f : X ⟶ Z) (g : X ⟶ Y) [HasPushout f g]\n    [HasPullback f.op g.op] :\n    pushout.inl _ _ ≫ (pushoutIsoUnopPullback f g).hom = (pullback.fst f.op g.op).unop :=\n  (IsColimit.comp_coconePointUniqueUpToIso_hom _ _ _).trans (by simp)\n\n"}
{"name":"CategoryTheory.Limits.pushoutIsoUnopPullback_inl_hom","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.Limits.HasPushout f g\ninst✝ : CategoryTheory.Limits.HasPullback f.op g.op\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl f g) (CategoryTheory.Limits.pushoutIsoUnopPullback f g).hom) (CategoryTheory.Limits.pullback.fst f.op g.op).unop","decl":"@[reassoc (attr := simp)]\ntheorem pushoutIsoUnopPullback_inl_hom {X Y Z : C} (f : X ⟶ Z) (g : X ⟶ Y) [HasPushout f g]\n    [HasPullback f.op g.op] :\n    pushout.inl _ _ ≫ (pushoutIsoUnopPullback f g).hom = (pullback.fst f.op g.op).unop :=\n  (IsColimit.comp_coconePointUniqueUpToIso_hom _ _ _).trans (by simp)\n\n"}
{"name":"CategoryTheory.Limits.pushoutIsoUnopPullback_inr_hom_assoc","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nX Y Z✝ : C\nf : Quiver.Hom X Z✝\ng : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.Limits.HasPushout f g\ninst✝ : CategoryTheory.Limits.HasPullback f.op g.op\nZ : C\nh : Quiver.Hom (Opposite.unop (CategoryTheory.Limits.pullback f.op g.op)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushoutIsoUnopPullback f g).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f.op g.op).unop h)","decl":"@[reassoc (attr := simp)]\ntheorem pushoutIsoUnopPullback_inr_hom {X Y Z : C} (f : X ⟶ Z) (g : X ⟶ Y) [HasPushout f g]\n    [HasPullback f.op g.op] :\n    pushout.inr _ _ ≫ (pushoutIsoUnopPullback f g).hom = (pullback.snd f.op g.op).unop :=\n  (IsColimit.comp_coconePointUniqueUpToIso_hom _ _ _).trans (by simp)\n\n"}
{"name":"CategoryTheory.Limits.pushoutIsoUnopPullback_inr_hom","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.Limits.HasPushout f g\ninst✝ : CategoryTheory.Limits.HasPullback f.op g.op\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr f g) (CategoryTheory.Limits.pushoutIsoUnopPullback f g).hom) (CategoryTheory.Limits.pullback.snd f.op g.op).unop","decl":"@[reassoc (attr := simp)]\ntheorem pushoutIsoUnopPullback_inr_hom {X Y Z : C} (f : X ⟶ Z) (g : X ⟶ Y) [HasPushout f g]\n    [HasPullback f.op g.op] :\n    pushout.inr _ _ ≫ (pushoutIsoUnopPullback f g).hom = (pullback.snd f.op g.op).unop :=\n  (IsColimit.comp_coconePointUniqueUpToIso_hom _ _ _).trans (by simp)\n\n"}
{"name":"CategoryTheory.Limits.pushoutIsoUnopPullback_inv_fst","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.Limits.HasPushout f g\ninst✝ : CategoryTheory.Limits.HasPullback f.op g.op\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushoutIsoUnopPullback f g).inv.op (CategoryTheory.Limits.pullback.fst f.op g.op)) (CategoryTheory.Limits.pushout.inl f g).op","decl":"@[simp]\ntheorem pushoutIsoUnopPullback_inv_fst {X Y Z : C} (f : X ⟶ Z) (g : X ⟶ Y) [HasPushout f g]\n    [HasPullback f.op g.op] :\n    (pushoutIsoUnopPullback f g).inv.op ≫ pullback.fst f.op g.op = (pushout.inl f g).op := by\n  apply Quiver.Hom.unop_inj\n  dsimp\n  rw [← pushoutIsoUnopPullback_inl_hom, Category.assoc, Iso.hom_inv_id, Category.comp_id]\n\n"}
{"name":"CategoryTheory.Limits.pushoutIsoUnopPullback_inv_snd","module":"Mathlib.CategoryTheory.Limits.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.Limits.HasPushout f g\ninst✝ : CategoryTheory.Limits.HasPullback f.op g.op\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushoutIsoUnopPullback f g).inv.op (CategoryTheory.Limits.pullback.snd f.op g.op)) (CategoryTheory.Limits.pushout.inr f g).op","decl":"@[simp]\ntheorem pushoutIsoUnopPullback_inv_snd {X Y Z : C} (f : X ⟶ Z) (g : X ⟶ Y) [HasPushout f g]\n    [HasPullback f.op g.op] :\n    (pushoutIsoUnopPullback f g).inv.op ≫ pullback.snd f.op g.op = (pushout.inr f g).op := by\n  apply Quiver.Hom.unop_inj\n  dsimp\n  rw [← pushoutIsoUnopPullback_inr_hom, Category.assoc, Iso.hom_inv_id, Category.comp_id]\n\n"}
