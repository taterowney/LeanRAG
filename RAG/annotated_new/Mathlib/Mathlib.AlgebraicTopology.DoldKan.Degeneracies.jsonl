{"name":"AlgebraicTopology.DoldKan.HigherFacesVanish.comp_Ïƒ","module":"Mathlib.AlgebraicTopology.DoldKan.Degeneracies","initialProofState":"C : Type u_1\ninstâœÂ¹ : CategoryTheory.Category.{u_2, u_1} C\ninstâœ : CategoryTheory.Preadditive C\nY : C\nX : CategoryTheory.SimplicialObject C\nn b q : Nat\nÏ† : Quiver.Hom Y (X.obj { unop := SimplexCategory.mk (HAdd.hAdd n 1) })\nv : AlgebraicTopology.DoldKan.HigherFacesVanish q Ï†\nhnbq : Eq (HAdd.hAdd n 1) (HAdd.hAdd b q)\nâŠ¢ AlgebraicTopology.DoldKan.HigherFacesVanish q (CategoryTheory.CategoryStruct.comp Ï† (X.Ïƒ âŸ¨b, â‹¯âŸ©))","decl":"theorem HigherFacesVanish.comp_Ïƒ {Y : C} {X : SimplicialObject C} {n b q : â„•} {Ï† : Y âŸ¶ X _[n + 1]}\n    (v : HigherFacesVanish q Ï†) (hnbq : n + 1 = b + q) :\n    HigherFacesVanish q\n      (Ï† â‰«\n        X.Ïƒ âŸ¨b, by\n          simp only [hnbq, Nat.lt_add_one_iff, le_add_iff_nonneg_right, zero_le]âŸ©) :=\n  fun j hj => by\n  rw [assoc, SimplicialObject.Î´_comp_Ïƒ_of_gt', Fin.pred_succ, v.comp_Î´_eq_zero_assoc _ _ hj,\n    zero_comp]\n  Â· dsimp\n    rw [Fin.lt_iff_val_lt_val, Fin.val_succ]\n    linarith\n  Â· intro hj'\n    simp only [hnbq, add_comm b, add_assoc, hj', Fin.val_zero, zero_add, add_le_iff_nonpos_right,\n      nonpos_iff_eq_zero, add_eq_zero, false_and, reduceCtorEq] at hj\n\n"}
{"name":"AlgebraicTopology.DoldKan.Ïƒ_comp_P_eq_zero","module":"Mathlib.AlgebraicTopology.DoldKan.Degeneracies","initialProofState":"C : Type u_1\ninstâœÂ¹ : CategoryTheory.Category.{u_2, u_1} C\ninstâœ : CategoryTheory.Preadditive C\nX : CategoryTheory.SimplicialObject C\nn q : Nat\ni : Fin (HAdd.hAdd n 1)\nhi : LE.le (HAdd.hAdd n 1) (HAdd.hAdd (â†‘i) q)\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (X.Ïƒ i) ((AlgebraicTopology.DoldKan.P q).f (HAdd.hAdd n 1))) 0","decl":"theorem Ïƒ_comp_P_eq_zero (X : SimplicialObject C) {n q : â„•} (i : Fin (n + 1)) (hi : n + 1 â‰¤ i + q) :\n    X.Ïƒ i â‰« (P q).f (n + 1) = 0 := by\n  revert i hi\n  induction' q with q hq\n  Â· intro i (hi : n + 1 â‰¤ i)\n    omega\n  Â· intro i (hi : n + 1 â‰¤ i + q + 1)\n    by_cases h : n + 1 â‰¤ (i : â„•) + q\n    Â· rw [P_succ, HomologicalComplex.comp_f, â† assoc, hq i h, zero_comp]\n    Â· replace hi : n = i + q := by\n        obtain âŸ¨j, hjâŸ© := le_iff_exists_add.mp hi\n        rw [â† Nat.lt_succ_iff, Nat.succ_eq_add_one, hj, not_lt, add_le_iff_nonpos_right,\n          nonpos_iff_eq_zero] at h\n        rw [â† add_left_inj 1, hj, self_eq_add_right, h]\n      rcases n with _|n\n      Â· fin_cases i\n        dsimp at h hi\n        rw [show q = 0 by omega]\n        change X.Ïƒ 0 â‰« (P 1).f 1 = 0\n        simp only [P_succ, HomologicalComplex.add_f_apply, comp_add,\n          HomologicalComplex.id_f, AlternatingFaceMapComplex.obj_d_eq, HÏƒ,\n          HomologicalComplex.comp_f, Homotopy.nullHomotopicMap'_f (c_mk 2 1 rfl) (c_mk 1 0 rfl),\n          comp_id]\n        erw [hÏƒ'_eq' (zero_add 0).symm, hÏƒ'_eq' (add_zero 1).symm, comp_id, Fin.sum_univ_two,\n          Fin.sum_univ_succ, Fin.sum_univ_two]\n        simp only [Fin.val_zero, pow_zero, pow_one, pow_add, one_smul, neg_smul, Fin.mk_one,\n          Fin.val_succ, Fin.val_one, Fin.succ_one_eq_two, P_zero, HomologicalComplex.id_f,\n          Fin.val_two, pow_two, mul_neg, one_mul, neg_mul, neg_neg, id_comp, add_comp,\n          comp_add, Fin.mk_zero, neg_comp, comp_neg, Fin.succ_zero_eq_one]\n        erw [SimplicialObject.Î´_comp_Ïƒ_self, SimplicialObject.Î´_comp_Ïƒ_self_assoc,\n          SimplicialObject.Î´_comp_Ïƒ_succ, comp_id,\n          SimplicialObject.Î´_comp_Ïƒ_of_le X\n            (show (0 : Fin 2) â‰¤ Fin.castSucc 0 by rw [Fin.castSucc_zero]),\n          SimplicialObject.Î´_comp_Ïƒ_self_assoc, SimplicialObject.Î´_comp_Ïƒ_succ_assoc]\n        simp only [add_neg_cancel, add_zero, zero_add]\n      Â· rw [â† id_comp (X.Ïƒ i), â† (P_add_Q_f q n.succ : _ = ğŸ™ (X.obj _)), add_comp, add_comp,\n          P_succ]\n        have v : HigherFacesVanish q ((P q).f n.succ â‰« X.Ïƒ i) :=\n          (HigherFacesVanish.of_P q n).comp_Ïƒ hi\n        erw [â† assoc, v.comp_P_eq_self, HomologicalComplex.add_f_apply, Preadditive.comp_add,\n          comp_id, v.comp_HÏƒ_eq hi, assoc, SimplicialObject.Î´_comp_Ïƒ_succ_assoc, Fin.eta,\n          decomposition_Q n q, sum_comp, sum_comp, Finset.sum_eq_zero, add_zero, add_neg_eq_zero]\n        intro j hj\n        simp only [Finset.mem_univ, Finset.mem_filter] at hj\n        obtain âŸ¨k, hkâŸ© := Nat.le.dest (Nat.lt_succ_iff.mp (Fin.is_lt j))\n        rw [add_comm] at hk\n        have hi' : i = Fin.castSucc âŸ¨i, by omegaâŸ© := by\n          ext\n          simp only [Fin.castSucc_mk, Fin.eta]\n        have eq := hq j.rev.succ (by\n          simp only [â† hk, Fin.rev_eq j hk.symm, Nat.succ_eq_add_one, Fin.succ_mk, Fin.val_mk]\n          omega)\n        rw [HomologicalComplex.comp_f, assoc, assoc, assoc, hi',\n          SimplicialObject.Ïƒ_comp_Ïƒ_assoc, reassoc_of% eq, zero_comp, comp_zero, comp_zero,\n          comp_zero]\n        simp only [Fin.rev_eq j hk.symm, Fin.le_iff_val_le_val, Fin.val_mk]\n        omega\n\n"}
{"name":"AlgebraicTopology.DoldKan.Ïƒ_comp_PInfty_assoc","module":"Mathlib.AlgebraicTopology.DoldKan.Degeneracies","initialProofState":"C : Type u_1\ninstâœÂ¹ : CategoryTheory.Category.{u_2, u_1} C\ninstâœ : CategoryTheory.Preadditive C\nX : CategoryTheory.SimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 1)\nZ : C\nh : Quiver.Hom ((AlgebraicTopology.AlternatingFaceMapComplex.obj X).X (HAdd.hAdd n 1)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (X.Ïƒ i) (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.PInfty.f (HAdd.hAdd n 1)) h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)]\ntheorem Ïƒ_comp_PInfty (X : SimplicialObject C) {n : â„•} (i : Fin (n + 1)) :\n    X.Ïƒ i â‰« PInfty.f (n + 1) = 0 := by\n  rw [PInfty_f, Ïƒ_comp_P_eq_zero X i]\n  simp only [le_add_iff_nonneg_left, zero_le]\n\n"}
{"name":"AlgebraicTopology.DoldKan.Ïƒ_comp_PInfty","module":"Mathlib.AlgebraicTopology.DoldKan.Degeneracies","initialProofState":"C : Type u_1\ninstâœÂ¹ : CategoryTheory.Category.{u_2, u_1} C\ninstâœ : CategoryTheory.Preadditive C\nX : CategoryTheory.SimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 1)\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (X.Ïƒ i) (AlgebraicTopology.DoldKan.PInfty.f (HAdd.hAdd n 1))) 0","decl":"@[reassoc (attr := simp)]\ntheorem Ïƒ_comp_PInfty (X : SimplicialObject C) {n : â„•} (i : Fin (n + 1)) :\n    X.Ïƒ i â‰« PInfty.f (n + 1) = 0 := by\n  rw [PInfty_f, Ïƒ_comp_P_eq_zero X i]\n  simp only [le_add_iff_nonneg_left, zero_le]\n\n"}
{"name":"AlgebraicTopology.DoldKan.degeneracy_comp_PInfty_assoc","module":"Mathlib.AlgebraicTopology.DoldKan.Degeneracies","initialProofState":"C : Type u_1\ninstâœÂ¹ : CategoryTheory.Category.{u_2, u_1} C\ninstâœ : CategoryTheory.Preadditive C\nX : CategoryTheory.SimplicialObject C\nn : Nat\nÎ”' : SimplexCategory\nÎ¸ : Quiver.Hom (SimplexCategory.mk n) Î”'\nhÎ¸ : Not (CategoryTheory.Mono Î¸)\nZ : C\nh : Quiver.Hom ((AlgebraicTopology.AlternatingFaceMapComplex.obj X).X n) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (X.map Î¸.op) (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.PInfty.f n) h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc]\ntheorem degeneracy_comp_PInfty (X : SimplicialObject C) (n : â„•) {Î”' : SimplexCategory}\n    (Î¸ : ([n] : SimplexCategory) âŸ¶ Î”') (hÎ¸ : Â¬Mono Î¸) : X.map Î¸.op â‰« PInfty.f n = 0 := by\n  rw [SimplexCategory.mono_iff_injective] at hÎ¸\n  cases n\n  Â· exfalso\n    apply hÎ¸\n    intro x y h\n    fin_cases x\n    fin_cases y\n    rfl\n  Â· obtain âŸ¨i, Î±, hâŸ© := SimplexCategory.eq_Ïƒ_comp_of_not_injective Î¸ hÎ¸\n    rw [h, op_comp, X.map_comp, assoc, show X.map (SimplexCategory.Ïƒ i).op = X.Ïƒ i by rfl,\n      Ïƒ_comp_PInfty, comp_zero]\n\n"}
{"name":"AlgebraicTopology.DoldKan.degeneracy_comp_PInfty","module":"Mathlib.AlgebraicTopology.DoldKan.Degeneracies","initialProofState":"C : Type u_1\ninstâœÂ¹ : CategoryTheory.Category.{u_2, u_1} C\ninstâœ : CategoryTheory.Preadditive C\nX : CategoryTheory.SimplicialObject C\nn : Nat\nÎ”' : SimplexCategory\nÎ¸ : Quiver.Hom (SimplexCategory.mk n) Î”'\nhÎ¸ : Not (CategoryTheory.Mono Î¸)\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (X.map Î¸.op) (AlgebraicTopology.DoldKan.PInfty.f n)) 0","decl":"@[reassoc]\ntheorem degeneracy_comp_PInfty (X : SimplicialObject C) (n : â„•) {Î”' : SimplexCategory}\n    (Î¸ : ([n] : SimplexCategory) âŸ¶ Î”') (hÎ¸ : Â¬Mono Î¸) : X.map Î¸.op â‰« PInfty.f n = 0 := by\n  rw [SimplexCategory.mono_iff_injective] at hÎ¸\n  cases n\n  Â· exfalso\n    apply hÎ¸\n    intro x y h\n    fin_cases x\n    fin_cases y\n    rfl\n  Â· obtain âŸ¨i, Î±, hâŸ© := SimplexCategory.eq_Ïƒ_comp_of_not_injective Î¸ hÎ¸\n    rw [h, op_comp, X.map_comp, assoc, show X.map (SimplexCategory.Ïƒ i).op = X.Ïƒ i by rfl,\n      Ïƒ_comp_PInfty, comp_zero]\n\n"}
