{"name":"AlgebraicTopology.DoldKan.HigherFacesVanish.comp_σ","module":"Mathlib.AlgebraicTopology.DoldKan.Degeneracies","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nY : C\nX : CategoryTheory.SimplicialObject C\nn b q : Nat\nφ : Quiver.Hom Y (X.obj { unop := SimplexCategory.mk (HAdd.hAdd n 1) })\nv : AlgebraicTopology.DoldKan.HigherFacesVanish q φ\nhnbq : Eq (HAdd.hAdd n 1) (HAdd.hAdd b q)\n⊢ AlgebraicTopology.DoldKan.HigherFacesVanish q (CategoryTheory.CategoryStruct.comp φ (X.σ ⟨b, ⋯⟩))","decl":"theorem HigherFacesVanish.comp_σ {Y : C} {X : SimplicialObject C} {n b q : ℕ} {φ : Y ⟶ X _[n + 1]}\n    (v : HigherFacesVanish q φ) (hnbq : n + 1 = b + q) :\n    HigherFacesVanish q\n      (φ ≫\n        X.σ ⟨b, by\n          simp only [hnbq, Nat.lt_add_one_iff, le_add_iff_nonneg_right, zero_le]⟩) :=\n  fun j hj => by\n  rw [assoc, SimplicialObject.δ_comp_σ_of_gt', Fin.pred_succ, v.comp_δ_eq_zero_assoc _ _ hj,\n    zero_comp]\n  · dsimp\n    rw [Fin.lt_iff_val_lt_val, Fin.val_succ]\n    linarith\n  · intro hj'\n    simp only [hnbq, add_comm b, add_assoc, hj', Fin.val_zero, zero_add, add_le_iff_nonpos_right,\n      nonpos_iff_eq_zero, add_eq_zero, false_and, reduceCtorEq] at hj\n\n"}
{"name":"AlgebraicTopology.DoldKan.σ_comp_P_eq_zero","module":"Mathlib.AlgebraicTopology.DoldKan.Degeneracies","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nX : CategoryTheory.SimplicialObject C\nn q : Nat\ni : Fin (HAdd.hAdd n 1)\nhi : LE.le (HAdd.hAdd n 1) (HAdd.hAdd (↑i) q)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.σ i) ((AlgebraicTopology.DoldKan.P q).f (HAdd.hAdd n 1))) 0","decl":"theorem σ_comp_P_eq_zero (X : SimplicialObject C) {n q : ℕ} (i : Fin (n + 1)) (hi : n + 1 ≤ i + q) :\n    X.σ i ≫ (P q).f (n + 1) = 0 := by\n  revert i hi\n  induction' q with q hq\n  · intro i (hi : n + 1 ≤ i)\n    omega\n  · intro i (hi : n + 1 ≤ i + q + 1)\n    by_cases h : n + 1 ≤ (i : ℕ) + q\n    · rw [P_succ, HomologicalComplex.comp_f, ← assoc, hq i h, zero_comp]\n    · replace hi : n = i + q := by\n        obtain ⟨j, hj⟩ := le_iff_exists_add.mp hi\n        rw [← Nat.lt_succ_iff, Nat.succ_eq_add_one, hj, not_lt, add_le_iff_nonpos_right,\n          nonpos_iff_eq_zero] at h\n        rw [← add_left_inj 1, hj, self_eq_add_right, h]\n      rcases n with _|n\n      · fin_cases i\n        dsimp at h hi\n        rw [show q = 0 by omega]\n        change X.σ 0 ≫ (P 1).f 1 = 0\n        simp only [P_succ, HomologicalComplex.add_f_apply, comp_add,\n          HomologicalComplex.id_f, AlternatingFaceMapComplex.obj_d_eq, Hσ,\n          HomologicalComplex.comp_f, Homotopy.nullHomotopicMap'_f (c_mk 2 1 rfl) (c_mk 1 0 rfl),\n          comp_id]\n        erw [hσ'_eq' (zero_add 0).symm, hσ'_eq' (add_zero 1).symm, comp_id, Fin.sum_univ_two,\n          Fin.sum_univ_succ, Fin.sum_univ_two]\n        simp only [Fin.val_zero, pow_zero, pow_one, pow_add, one_smul, neg_smul, Fin.mk_one,\n          Fin.val_succ, Fin.val_one, Fin.succ_one_eq_two, P_zero, HomologicalComplex.id_f,\n          Fin.val_two, pow_two, mul_neg, one_mul, neg_mul, neg_neg, id_comp, add_comp,\n          comp_add, Fin.mk_zero, neg_comp, comp_neg, Fin.succ_zero_eq_one]\n        erw [SimplicialObject.δ_comp_σ_self, SimplicialObject.δ_comp_σ_self_assoc,\n          SimplicialObject.δ_comp_σ_succ, comp_id,\n          SimplicialObject.δ_comp_σ_of_le X\n            (show (0 : Fin 2) ≤ Fin.castSucc 0 by rw [Fin.castSucc_zero]),\n          SimplicialObject.δ_comp_σ_self_assoc, SimplicialObject.δ_comp_σ_succ_assoc]\n        simp only [add_neg_cancel, add_zero, zero_add]\n      · rw [← id_comp (X.σ i), ← (P_add_Q_f q n.succ : _ = 𝟙 (X.obj _)), add_comp, add_comp,\n          P_succ]\n        have v : HigherFacesVanish q ((P q).f n.succ ≫ X.σ i) :=\n          (HigherFacesVanish.of_P q n).comp_σ hi\n        erw [← assoc, v.comp_P_eq_self, HomologicalComplex.add_f_apply, Preadditive.comp_add,\n          comp_id, v.comp_Hσ_eq hi, assoc, SimplicialObject.δ_comp_σ_succ_assoc, Fin.eta,\n          decomposition_Q n q, sum_comp, sum_comp, Finset.sum_eq_zero, add_zero, add_neg_eq_zero]\n        intro j hj\n        simp only [Finset.mem_univ, Finset.mem_filter] at hj\n        obtain ⟨k, hk⟩ := Nat.le.dest (Nat.lt_succ_iff.mp (Fin.is_lt j))\n        rw [add_comm] at hk\n        have hi' : i = Fin.castSucc ⟨i, by omega⟩ := by\n          ext\n          simp only [Fin.castSucc_mk, Fin.eta]\n        have eq := hq j.rev.succ (by\n          simp only [← hk, Fin.rev_eq j hk.symm, Nat.succ_eq_add_one, Fin.succ_mk, Fin.val_mk]\n          omega)\n        rw [HomologicalComplex.comp_f, assoc, assoc, assoc, hi',\n          SimplicialObject.σ_comp_σ_assoc, reassoc_of% eq, zero_comp, comp_zero, comp_zero,\n          comp_zero]\n        simp only [Fin.rev_eq j hk.symm, Fin.le_iff_val_le_val, Fin.val_mk]\n        omega\n\n"}
{"name":"AlgebraicTopology.DoldKan.σ_comp_PInfty_assoc","module":"Mathlib.AlgebraicTopology.DoldKan.Degeneracies","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nX : CategoryTheory.SimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 1)\nZ : C\nh : Quiver.Hom ((AlgebraicTopology.AlternatingFaceMapComplex.obj X).X (HAdd.hAdd n 1)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.σ i) (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.PInfty.f (HAdd.hAdd n 1)) h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)]\ntheorem σ_comp_PInfty (X : SimplicialObject C) {n : ℕ} (i : Fin (n + 1)) :\n    X.σ i ≫ PInfty.f (n + 1) = 0 := by\n  rw [PInfty_f, σ_comp_P_eq_zero X i]\n  simp only [le_add_iff_nonneg_left, zero_le]\n\n"}
{"name":"AlgebraicTopology.DoldKan.σ_comp_PInfty","module":"Mathlib.AlgebraicTopology.DoldKan.Degeneracies","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nX : CategoryTheory.SimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 1)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.σ i) (AlgebraicTopology.DoldKan.PInfty.f (HAdd.hAdd n 1))) 0","decl":"@[reassoc (attr := simp)]\ntheorem σ_comp_PInfty (X : SimplicialObject C) {n : ℕ} (i : Fin (n + 1)) :\n    X.σ i ≫ PInfty.f (n + 1) = 0 := by\n  rw [PInfty_f, σ_comp_P_eq_zero X i]\n  simp only [le_add_iff_nonneg_left, zero_le]\n\n"}
{"name":"AlgebraicTopology.DoldKan.degeneracy_comp_PInfty_assoc","module":"Mathlib.AlgebraicTopology.DoldKan.Degeneracies","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nX : CategoryTheory.SimplicialObject C\nn : Nat\nΔ' : SimplexCategory\nθ : Quiver.Hom (SimplexCategory.mk n) Δ'\nhθ : Not (CategoryTheory.Mono θ)\nZ : C\nh : Quiver.Hom ((AlgebraicTopology.AlternatingFaceMapComplex.obj X).X n) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.map θ.op) (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.PInfty.f n) h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc]\ntheorem degeneracy_comp_PInfty (X : SimplicialObject C) (n : ℕ) {Δ' : SimplexCategory}\n    (θ : ([n] : SimplexCategory) ⟶ Δ') (hθ : ¬Mono θ) : X.map θ.op ≫ PInfty.f n = 0 := by\n  rw [SimplexCategory.mono_iff_injective] at hθ\n  cases n\n  · exfalso\n    apply hθ\n    intro x y h\n    fin_cases x\n    fin_cases y\n    rfl\n  · obtain ⟨i, α, h⟩ := SimplexCategory.eq_σ_comp_of_not_injective θ hθ\n    rw [h, op_comp, X.map_comp, assoc, show X.map (SimplexCategory.σ i).op = X.σ i by rfl,\n      σ_comp_PInfty, comp_zero]\n\n"}
{"name":"AlgebraicTopology.DoldKan.degeneracy_comp_PInfty","module":"Mathlib.AlgebraicTopology.DoldKan.Degeneracies","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nX : CategoryTheory.SimplicialObject C\nn : Nat\nΔ' : SimplexCategory\nθ : Quiver.Hom (SimplexCategory.mk n) Δ'\nhθ : Not (CategoryTheory.Mono θ)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.map θ.op) (AlgebraicTopology.DoldKan.PInfty.f n)) 0","decl":"@[reassoc]\ntheorem degeneracy_comp_PInfty (X : SimplicialObject C) (n : ℕ) {Δ' : SimplexCategory}\n    (θ : ([n] : SimplexCategory) ⟶ Δ') (hθ : ¬Mono θ) : X.map θ.op ≫ PInfty.f n = 0 := by\n  rw [SimplexCategory.mono_iff_injective] at hθ\n  cases n\n  · exfalso\n    apply hθ\n    intro x y h\n    fin_cases x\n    fin_cases y\n    rfl\n  · obtain ⟨i, α, h⟩ := SimplexCategory.eq_σ_comp_of_not_injective θ hθ\n    rw [h, op_comp, X.map_comp, assoc, show X.map (SimplexCategory.σ i).op = X.σ i by rfl,\n      σ_comp_PInfty, comp_zero]\n\n"}
