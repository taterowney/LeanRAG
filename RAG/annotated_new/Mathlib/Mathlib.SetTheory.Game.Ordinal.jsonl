{"name":"Ordinal.toPGame_def","module":"Mathlib.SetTheory.Game.Ordinal","initialProofState":"o : Ordinal.{u_1}\n⊢ Eq o.toPGame (SetTheory.PGame.mk o.toType PEmpty.{u_1 + 1} (fun x => (↑(o.enumIsoToType.symm x)).toPGame) PEmpty.elim)","decl":"@[deprecated \"No deprecation message was provided.\" (since := \"2024-09-22\")]\ntheorem toPGame_def (o : Ordinal) : o.toPGame =\n    ⟨o.toType, PEmpty, fun x => ((enumIsoToType o).symm x).val.toPGame, PEmpty.elim⟩ := by\n  rw [toPGame]\n\n"}
{"name":"Ordinal.toPGame_leftMoves","module":"Mathlib.SetTheory.Game.Ordinal","initialProofState":"o : Ordinal.{u_1}\n⊢ Eq o.toPGame.LeftMoves o.toType","decl":"@[simp]\ntheorem toPGame_leftMoves (o : Ordinal) : o.toPGame.LeftMoves = o.toType := by\n  rw [toPGame, LeftMoves]\n\n"}
{"name":"Ordinal.toPGame_rightMoves","module":"Mathlib.SetTheory.Game.Ordinal","initialProofState":"o : Ordinal.{u_1}\n⊢ Eq o.toPGame.RightMoves PEmpty.{u_1 + 1}","decl":"@[simp]\ntheorem toPGame_rightMoves (o : Ordinal) : o.toPGame.RightMoves = PEmpty := by\n  rw [toPGame, RightMoves]\n\n"}
{"name":"Ordinal.isEmpty_zero_toPGame_leftMoves","module":"Mathlib.SetTheory.Game.Ordinal","initialProofState":"⊢ IsEmpty (Ordinal.toPGame 0).LeftMoves","decl":"instance isEmpty_zero_toPGame_leftMoves : IsEmpty (toPGame 0).LeftMoves := by\n  rw [toPGame_leftMoves]; infer_instance\n\n"}
{"name":"Ordinal.isEmpty_toPGame_rightMoves","module":"Mathlib.SetTheory.Game.Ordinal","initialProofState":"o : Ordinal.{u_1}\n⊢ IsEmpty o.toPGame.RightMoves","decl":"instance isEmpty_toPGame_rightMoves (o : Ordinal) : IsEmpty o.toPGame.RightMoves := by\n  rw [toPGame_rightMoves]; infer_instance\n\n"}
{"name":"Ordinal.toLeftMovesToPGame_symm_lt","module":"Mathlib.SetTheory.Game.Ordinal","initialProofState":"o : Ordinal.{u_1}\ni : o.toPGame.LeftMoves\n⊢ LT.lt (↑(Ordinal.toLeftMovesToPGame.symm i)) o","decl":"@[simp]\ntheorem toLeftMovesToPGame_symm_lt {o : Ordinal} (i : o.toPGame.LeftMoves) :\n    ↑(toLeftMovesToPGame.symm i) < o :=\n  (toLeftMovesToPGame.symm i).prop\n\n"}
{"name":"Ordinal.toPGame_moveLeft_hEq","module":"Mathlib.SetTheory.Game.Ordinal","initialProofState":"o : Ordinal.{u_1}\n⊢ HEq o.toPGame.moveLeft fun x => (↑(o.enumIsoToType.symm x)).toPGame","decl":"@[nolint unusedHavesSuffices]\ntheorem toPGame_moveLeft_hEq {o : Ordinal} :\n    HEq o.toPGame.moveLeft fun x : o.toType => ((enumIsoToType o).symm x).val.toPGame := by\n  rw [toPGame]\n  rfl\n\n"}
{"name":"Ordinal.toPGame_moveLeft'","module":"Mathlib.SetTheory.Game.Ordinal","initialProofState":"o : Ordinal.{u_1}\ni : o.toPGame.LeftMoves\n⊢ Eq (o.toPGame.moveLeft i) (↑(Ordinal.toLeftMovesToPGame.symm i)).toPGame","decl":"@[simp]\ntheorem toPGame_moveLeft' {o : Ordinal} (i) :\n    o.toPGame.moveLeft i = (toLeftMovesToPGame.symm i).val.toPGame :=\n  (congr_heq toPGame_moveLeft_hEq.symm (cast_heq _ i)).symm\n\n"}
{"name":"Ordinal.toPGame_moveLeft","module":"Mathlib.SetTheory.Game.Ordinal","initialProofState":"o : Ordinal.{u_1}\ni : ↑(Set.Iio o)\n⊢ Eq (o.toPGame.moveLeft (Ordinal.toLeftMovesToPGame i)) (↑i).toPGame","decl":"theorem toPGame_moveLeft {o : Ordinal} (i) :\n    o.toPGame.moveLeft (toLeftMovesToPGame i) = i.val.toPGame := by simp\n\n"}
{"name":"Ordinal.toPGame_zero","module":"Mathlib.SetTheory.Game.Ordinal","initialProofState":"⊢ HasEquiv.Equiv (Ordinal.toPGame 0) 0","decl":"theorem toPGame_zero : toPGame 0 ≈ 0 :=\n  zeroToPGameRelabelling.equiv\n\n"}
{"name":"Ordinal.one_toPGame_leftMoves_default_eq","module":"Mathlib.SetTheory.Game.Ordinal","initialProofState":"⊢ Eq Inhabited.default (Ordinal.toLeftMovesToPGame ⟨0, ⋯⟩)","decl":"@[simp]\ntheorem one_toPGame_leftMoves_default_eq :\n    (default : (toPGame 1).LeftMoves) = @toLeftMovesToPGame 1 ⟨0, Set.mem_Iio.mpr zero_lt_one⟩ :=\n  rfl\n\n"}
{"name":"Ordinal.to_leftMoves_one_toPGame_symm","module":"Mathlib.SetTheory.Game.Ordinal","initialProofState":"i : (Ordinal.toPGame 1).LeftMoves\n⊢ Eq (Ordinal.toLeftMovesToPGame.symm i) ⟨0, ⋯⟩","decl":"@[simp]\ntheorem to_leftMoves_one_toPGame_symm (i) :\n    (@toLeftMovesToPGame 1).symm i = ⟨0, Set.mem_Iio.mpr zero_lt_one⟩ := by\n  simp [eq_iff_true_of_subsingleton]\n\n"}
{"name":"Ordinal.one_toPGame_moveLeft","module":"Mathlib.SetTheory.Game.Ordinal","initialProofState":"x : (Ordinal.toPGame 1).LeftMoves\n⊢ Eq ((Ordinal.toPGame 1).moveLeft x) (Ordinal.toPGame 0)","decl":"theorem one_toPGame_moveLeft (x) : (toPGame 1).moveLeft x = toPGame 0 := by simp\n\n"}
{"name":"Ordinal.toPGame_one","module":"Mathlib.SetTheory.Game.Ordinal","initialProofState":"⊢ HasEquiv.Equiv (Ordinal.toPGame 1) 1","decl":"theorem toPGame_one : toPGame 1 ≈ 1 :=\n  oneToPGameRelabelling.equiv\n\n"}
{"name":"Ordinal.toPGame_lf","module":"Mathlib.SetTheory.Game.Ordinal","initialProofState":"a b : Ordinal.{u_1}\nh : LT.lt a b\n⊢ a.toPGame.LF b.toPGame","decl":"theorem toPGame_lf {a b : Ordinal} (h : a < b) : a.toPGame ⧏ b.toPGame := by\n  convert moveLeft_lf (toLeftMovesToPGame ⟨a, h⟩); rw [toPGame_moveLeft]\n\n"}
{"name":"Ordinal.toPGame_le","module":"Mathlib.SetTheory.Game.Ordinal","initialProofState":"a b : Ordinal.{u_1}\nh : LE.le a b\n⊢ LE.le a.toPGame b.toPGame","decl":"theorem toPGame_le {a b : Ordinal} (h : a ≤ b) : a.toPGame ≤ b.toPGame := by\n  refine le_iff_forall_lf.2 ⟨fun i => ?_, isEmptyElim⟩\n  rw [toPGame_moveLeft']\n  exact toPGame_lf ((toLeftMovesToPGame_symm_lt i).trans_le h)\n\n"}
{"name":"Ordinal.toPGame_lt","module":"Mathlib.SetTheory.Game.Ordinal","initialProofState":"a b : Ordinal.{u_1}\nh : LT.lt a b\n⊢ LT.lt a.toPGame b.toPGame","decl":"theorem toPGame_lt {a b : Ordinal} (h : a < b) : a.toPGame < b.toPGame :=\n  ⟨toPGame_le h.le, toPGame_lf h⟩\n\n"}
{"name":"Ordinal.toPGame_nonneg","module":"Mathlib.SetTheory.Game.Ordinal","initialProofState":"a : Ordinal.{u_1}\n⊢ LE.le 0 a.toPGame","decl":"theorem toPGame_nonneg (a : Ordinal) : 0 ≤ a.toPGame :=\n  zeroToPGameRelabelling.ge.trans <| toPGame_le <| Ordinal.zero_le a\n\n"}
{"name":"Ordinal.toPGame_lf_iff","module":"Mathlib.SetTheory.Game.Ordinal","initialProofState":"a b : Ordinal.{u_1}\n⊢ Iff (a.toPGame.LF b.toPGame) (LT.lt a b)","decl":"@[simp]\ntheorem toPGame_lf_iff {a b : Ordinal} : a.toPGame ⧏ b.toPGame ↔ a < b :=\n  ⟨by contrapose; rw [not_lt, not_lf]; exact toPGame_le, toPGame_lf⟩\n\n"}
{"name":"Ordinal.toPGame_le_iff","module":"Mathlib.SetTheory.Game.Ordinal","initialProofState":"a b : Ordinal.{u_1}\n⊢ Iff (LE.le a.toPGame b.toPGame) (LE.le a b)","decl":"@[simp]\ntheorem toPGame_le_iff {a b : Ordinal} : a.toPGame ≤ b.toPGame ↔ a ≤ b :=\n  ⟨by contrapose; rw [not_le, PGame.not_le]; exact toPGame_lf, toPGame_le⟩\n\n"}
{"name":"Ordinal.toPGame_lt_iff","module":"Mathlib.SetTheory.Game.Ordinal","initialProofState":"a b : Ordinal.{u_1}\n⊢ Iff (LT.lt a.toPGame b.toPGame) (LT.lt a b)","decl":"@[simp]\ntheorem toPGame_lt_iff {a b : Ordinal} : a.toPGame < b.toPGame ↔ a < b :=\n  ⟨by contrapose; rw [not_lt]; exact fun h => not_lt_of_le (toPGame_le h), toPGame_lt⟩\n\n"}
{"name":"Ordinal.toPGame_equiv_iff","module":"Mathlib.SetTheory.Game.Ordinal","initialProofState":"a b : Ordinal.{u_1}\n⊢ Iff (HasEquiv.Equiv a.toPGame b.toPGame) (Eq a b)","decl":"@[simp]\ntheorem toPGame_equiv_iff {a b : Ordinal} : (a.toPGame ≈ b.toPGame) ↔ a = b := by\n  -- Porting note: was `rw [PGame.Equiv]`\n  change _ ≤_ ∧ _ ≤ _ ↔ _\n  rw [le_antisymm_iff, toPGame_le_iff, toPGame_le_iff]\n\n"}
{"name":"Ordinal.toPGame_injective","module":"Mathlib.SetTheory.Game.Ordinal","initialProofState":"⊢ Function.Injective Ordinal.toPGame","decl":"theorem toPGame_injective : Function.Injective Ordinal.toPGame := fun _ _ h =>\n  toPGame_equiv_iff.1 <| equiv_of_eq h\n\n"}
{"name":"Ordinal.toPGame_inj","module":"Mathlib.SetTheory.Game.Ordinal","initialProofState":"a b : Ordinal.{u_1}\n⊢ Iff (Eq a.toPGame b.toPGame) (Eq a b)","decl":"@[simp]\ntheorem toPGame_inj {a b : Ordinal} : a.toPGame = b.toPGame ↔ a = b :=\n  toPGame_injective.eq_iff\n\n"}
{"name":"Ordinal.toPGame_eq_iff","module":"Mathlib.SetTheory.Game.Ordinal","initialProofState":"a b : Ordinal.{u_1}\n⊢ Iff (Eq a.toPGame b.toPGame) (Eq a b)","decl":"@[deprecated (since := \"2024-12-29\")] alias toPGame_eq_iff := toPGame_inj\n\n"}
{"name":"Ordinal.toPGameEmbedding_apply","module":"Mathlib.SetTheory.Game.Ordinal","initialProofState":"o : Ordinal.{u}\n⊢ Eq (Ordinal.toPGameEmbedding o) o.toPGame","decl":"/-- The order embedding version of `toPGame`. -/\n@[simps]\nnoncomputable def toPGameEmbedding : Ordinal.{u} ↪o PGame.{u} where\n  toFun := Ordinal.toPGame\n  inj' := toPGame_injective\n  map_rel_iff' := @toPGame_le_iff\n\n"}
{"name":"Ordinal.mk_toPGame","module":"Mathlib.SetTheory.Game.Ordinal","initialProofState":"o : Ordinal.{u_1}\n⊢ Eq (Quotient.mk SetTheory.PGame.setoid o.toPGame) (Ordinal.toGame o)","decl":"@[simp]\ntheorem mk_toPGame (o : Ordinal) : ⟦o.toPGame⟧ = o.toGame :=\n  rfl\n\n"}
{"name":"Ordinal.toGame_zero","module":"Mathlib.SetTheory.Game.Ordinal","initialProofState":"⊢ Eq (Ordinal.toGame 0) 0","decl":"@[simp]\ntheorem toGame_zero : toGame 0 = 0 :=\n  game_eq toPGame_zero\n\n"}
{"name":"Ordinal.toGame_one","module":"Mathlib.SetTheory.Game.Ordinal","initialProofState":"⊢ Eq (Ordinal.toGame 1) 1","decl":"@[simp]\ntheorem toGame_one : toGame 1 = 1 :=\n  game_eq toPGame_one\n\n"}
{"name":"Ordinal.toGame_injective","module":"Mathlib.SetTheory.Game.Ordinal","initialProofState":"⊢ Function.Injective ⇑Ordinal.toGame","decl":"theorem toGame_injective : Function.Injective toGame :=\n  toGame.injective\n\n"}
{"name":"Ordinal.toGame_lf_iff","module":"Mathlib.SetTheory.Game.Ordinal","initialProofState":"a b : Ordinal.{u_1}\n⊢ Iff ((Ordinal.toGame a).LF (Ordinal.toGame b)) (LT.lt a b)","decl":"@[simp]\ntheorem toGame_lf_iff {a b : Ordinal} : Game.LF a.toGame b.toGame ↔ a < b :=\n  toPGame_lf_iff\n\n"}
{"name":"Ordinal.toGame_le_iff","module":"Mathlib.SetTheory.Game.Ordinal","initialProofState":"a b : Ordinal.{u_1}\n⊢ Iff (LE.le (Ordinal.toGame a) (Ordinal.toGame b)) (LE.le a b)","decl":"theorem toGame_le_iff {a b : Ordinal} : a.toGame ≤ b.toGame ↔ a ≤ b :=\n  toPGame_le_iff\n\n"}
{"name":"Ordinal.toGame_lt_iff","module":"Mathlib.SetTheory.Game.Ordinal","initialProofState":"a b : Ordinal.{u_1}\n⊢ Iff (LT.lt (Ordinal.toGame a) (Ordinal.toGame b)) (LT.lt a b)","decl":"theorem toGame_lt_iff {a b : Ordinal} : a.toGame < b.toGame ↔ a < b :=\n  toPGame_lt_iff\n\n"}
{"name":"Ordinal.toGame_inj","module":"Mathlib.SetTheory.Game.Ordinal","initialProofState":"a b : Ordinal.{u_1}\n⊢ Iff (Eq (Ordinal.toGame a) (Ordinal.toGame b)) (Eq a b)","decl":"theorem toGame_inj {a b : Ordinal} : a.toGame = b.toGame ↔ a = b :=\n  toGame.inj\n\n"}
{"name":"Ordinal.toGame_eq_iff","module":"Mathlib.SetTheory.Game.Ordinal","initialProofState":"a b : Ordinal.{u_1}\n⊢ Iff (Eq (Ordinal.toGame a) (Ordinal.toGame b)) (Eq a b)","decl":"@[deprecated (since := \"2024-12-29\")] alias toGame_eq_iff := toGame_inj\n\n"}
{"name":"Ordinal.toPGame_nadd","module":"Mathlib.SetTheory.Game.Ordinal","initialProofState":"a b : Ordinal.{u_1}\n⊢ HasEquiv.Equiv (a.nadd b).toPGame (HAdd.hAdd a.toPGame b.toPGame)","decl":"/-- The natural addition of ordinals corresponds to their sum as games. -/\ntheorem toPGame_nadd (a b : Ordinal) : (a ♯ b).toPGame ≈ a.toPGame + b.toPGame := by\n  refine ⟨le_of_forall_lf (fun i => ?_) isEmptyElim, le_of_forall_lf (fun i => ?_) isEmptyElim⟩\n  · rw [toPGame_moveLeft']\n    rcases lt_nadd_iff.1 (toLeftMovesToPGame_symm_lt i) with (⟨c, hc, hc'⟩ | ⟨c, hc, hc'⟩) <;>\n    rw [← toPGame_le_iff, le_congr_right (toPGame_nadd _ _)] at hc' <;>\n    apply lf_of_le_of_lf hc'\n    · apply add_lf_add_right\n      rwa [toPGame_lf_iff]\n    · apply add_lf_add_left\n      rwa [toPGame_lf_iff]\n  · apply leftMoves_add_cases i <;>\n    intro i <;>\n    let wf := toLeftMovesToPGame_symm_lt i <;>\n    (try rw [add_moveLeft_inl]) <;>\n    (try rw [add_moveLeft_inr]) <;>\n    rw [toPGame_moveLeft', ← lf_congr_left (toPGame_nadd _ _), toPGame_lf_iff]\n    · exact nadd_lt_nadd_right wf _\n    · exact nadd_lt_nadd_left wf _\ntermination_by (a, b)\n\n"}
{"name":"Ordinal.toGame_nadd","module":"Mathlib.SetTheory.Game.Ordinal","initialProofState":"a b : Ordinal.{u_1}\n⊢ Eq (Ordinal.toGame (a.nadd b)) (HAdd.hAdd (Ordinal.toGame a) (Ordinal.toGame b))","decl":"theorem toGame_nadd (a b : Ordinal) : (a ♯ b).toGame = a.toGame + b.toGame :=\n  game_eq (toPGame_nadd a b)\n\n"}
{"name":"Ordinal.toPGame_nmul","module":"Mathlib.SetTheory.Game.Ordinal","initialProofState":"a b : Ordinal.{u_1}\n⊢ HasEquiv.Equiv (a.nmul b).toPGame (HMul.hMul a.toPGame b.toPGame)","decl":"/-- The natural multiplication of ordinals corresponds to their product as pre-games. -/\ntheorem toPGame_nmul (a b : Ordinal) : (a ⨳ b).toPGame ≈ a.toPGame * b.toPGame := by\n  refine ⟨le_of_forall_lf (fun i => ?_) isEmptyElim, le_of_forall_lf (fun i => ?_) isEmptyElim⟩\n  · rw [toPGame_moveLeft']\n    rcases lt_nmul_iff.1 (toLeftMovesToPGame_symm_lt i) with ⟨c, hc, d, hd, h⟩\n    rw [← toPGame_le_iff, le_iff_game_le, mk_toPGame, mk_toPGame, toGame_nadd _ _, toGame_nadd _ _,\n      ← le_sub_iff_add_le] at h\n    refine lf_of_le_of_lf h <| (lf_congr_left ?_).1 <| moveLeft_lf <| toLeftMovesMul <| Sum.inl\n      ⟨toLeftMovesToPGame ⟨c, hc⟩, toLeftMovesToPGame ⟨d, hd⟩⟩\n    simp only [mul_moveLeft_inl, toPGame_moveLeft', Equiv.symm_apply_apply, equiv_iff_game_eq,\n      quot_sub, quot_add]\n    repeat rw [← game_eq (toPGame_nmul _ _)]\n    rfl\n  · apply leftMoves_mul_cases i _ isEmptyElim\n    intro i j\n    rw [mul_moveLeft_inl, toPGame_moveLeft', toPGame_moveLeft', lf_iff_game_lf,\n      quot_sub, quot_add, ← Game.not_le, le_sub_iff_add_le]\n    repeat rw [← game_eq (toPGame_nmul _ _)]\n    simp_rw [mk_toPGame, ← toGame_nadd]\n    apply toPGame_lf (nmul_nadd_lt _ _) <;>\n    exact toLeftMovesToPGame_symm_lt _\ntermination_by (a, b)\n\n"}
{"name":"Ordinal.toGame_nmul","module":"Mathlib.SetTheory.Game.Ordinal","initialProofState":"a b : Ordinal.{u_1}\n⊢ Eq (Ordinal.toGame (a.nmul b)) (Quotient.mk SetTheory.PGame.setoid (HMul.hMul a.toPGame b.toPGame))","decl":"theorem toGame_nmul (a b : Ordinal) : (a ⨳ b).toGame = ⟦a.toPGame * b.toPGame⟧ :=\n  game_eq (toPGame_nmul a b)\n\n"}
{"name":"Ordinal.toGame_natCast","module":"Mathlib.SetTheory.Game.Ordinal","initialProofState":"n : Nat\n⊢ Eq (Ordinal.toGame ↑n) ↑n","decl":"@[simp] -- used to be a norm_cast lemma\ntheorem toGame_natCast : ∀ n : ℕ, toGame n = n\n  | 0 => Quot.sound (zeroToPGameRelabelling).equiv\n  | n + 1 => by\n    have : toGame 1 = 1 := Quot.sound oneToPGameRelabelling.equiv\n    rw [Nat.cast_add, ← nadd_nat, toGame_nadd, toGame_natCast, Nat.cast_one, this]\n    rfl\n\n"}
{"name":"Ordinal.toPGame_natCast","module":"Mathlib.SetTheory.Game.Ordinal","initialProofState":"n : Nat\n⊢ HasEquiv.Equiv (↑n).toPGame ↑n","decl":"theorem toPGame_natCast (n : ℕ) : toPGame n ≈ n := by\n  rw [PGame.equiv_iff_game_eq, mk_toPGame, toGame_natCast, quot_natCast]\n\n"}
