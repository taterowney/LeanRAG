{"name":"CategoryTheory.Cat.bicategory.strict","module":"Mathlib.CategoryTheory.Category.Cat","initialProofState":"‚ä¢ CategoryTheory.Bicategory.Strict CategoryTheory.Cat","decl":"/-- `Cat` is a strict bicategory. -/\ninstance bicategory.strict : Bicategory.Strict Cat.{v, u} where\n  id_comp {C} {D} F := by cases F; rfl\n  comp_id {C} {D} F := by cases F; rfl\n  assoc := by intros; rfl\n\n"}
{"name":"CategoryTheory.Cat.id_obj","module":"Mathlib.CategoryTheory.Category.Cat","initialProofState":"C : CategoryTheory.Cat\nX : ‚ÜëC\n‚ä¢ Eq ((CategoryTheory.CategoryStruct.id C).obj X) X","decl":"@[simp]\ntheorem id_obj {C : Cat} (X : C) : (ùüô C : C ‚•§ C).obj X = X :=\n  rfl\n\n"}
{"name":"CategoryTheory.Cat.id_map","module":"Mathlib.CategoryTheory.Category.Cat","initialProofState":"C : CategoryTheory.Cat\nX Y : ‚ÜëC\nf : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.CategoryStruct.id C).map f) f","decl":"@[simp]\ntheorem id_map {C : Cat} {X Y : C} (f : X ‚ü∂ Y) : (ùüô C : C ‚•§ C).map f = f :=\n  rfl\n\n"}
{"name":"CategoryTheory.Cat.comp_obj","module":"Mathlib.CategoryTheory.Category.Cat","initialProofState":"C D E : CategoryTheory.Cat\nF : Quiver.Hom C D\nG : Quiver.Hom D E\nX : ‚ÜëC\n‚ä¢ Eq ((CategoryTheory.CategoryStruct.comp F G).obj X) (G.obj (F.obj X))","decl":"@[simp]\ntheorem comp_obj {C D E : Cat} (F : C ‚ü∂ D) (G : D ‚ü∂ E) (X : C) : (F ‚â´ G).obj X = G.obj (F.obj X) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Cat.comp_map","module":"Mathlib.CategoryTheory.Category.Cat","initialProofState":"C D E : CategoryTheory.Cat\nF : Quiver.Hom C D\nG : Quiver.Hom D E\nX Y : ‚ÜëC\nf : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.CategoryStruct.comp F G).map f) (G.map (F.map f))","decl":"@[simp]\ntheorem comp_map {C D E : Cat} (F : C ‚ü∂ D) (G : D ‚ü∂ E) {X Y : C} (f : X ‚ü∂ Y) :\n    (F ‚â´ G).map f = G.map (F.map f) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Cat.id_app","module":"Mathlib.CategoryTheory.Category.Cat","initialProofState":"C D : CategoryTheory.Cat\nF : Quiver.Hom C D\nX : ‚ÜëC\n‚ä¢ Eq ((CategoryTheory.CategoryStruct.id F).app X) (CategoryTheory.CategoryStruct.id (F.obj X))","decl":"@[simp]\ntheorem id_app {C D : Cat} (F : C ‚ü∂ D) (X : C) : (ùüô F : F ‚ü∂ F).app X = ùüô (F.obj X) := rfl\n\n"}
{"name":"CategoryTheory.Cat.comp_app","module":"Mathlib.CategoryTheory.Category.Cat","initialProofState":"C D : CategoryTheory.Cat\nF G H : Quiver.Hom C D\nŒ± : Quiver.Hom F G\nŒ≤ : Quiver.Hom G H\nX : ‚ÜëC\n‚ä¢ Eq ((CategoryTheory.CategoryStruct.comp Œ± Œ≤).app X) (CategoryTheory.CategoryStruct.comp (Œ±.app X) (Œ≤.app X))","decl":"@[simp]\ntheorem comp_app {C D : Cat} {F G H : C ‚ü∂ D} (Œ± : F ‚ü∂ G) (Œ≤ : G ‚ü∂ H) (X : C) :\n    (Œ± ‚â´ Œ≤).app X = Œ±.app X ‚â´ Œ≤.app X := rfl\n\n"}
{"name":"CategoryTheory.Cat.whiskerLeft_app","module":"Mathlib.CategoryTheory.Category.Cat","initialProofState":"C D E : CategoryTheory.Cat\nF : Quiver.Hom C D\nG H : Quiver.Hom D E\nŒ∑ : Quiver.Hom G H\nX : ‚ÜëC\n‚ä¢ Eq ((CategoryTheory.Bicategory.whiskerLeft F Œ∑).app X) (Œ∑.app (F.obj X))","decl":"@[simp]\nlemma whiskerLeft_app {C D E : Cat} (F : C ‚ü∂ D) {G H : D ‚ü∂ E} (Œ∑ : G ‚ü∂ H) (X : C) :\n    (F ‚óÅ Œ∑).app X = Œ∑.app (F.obj X) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Cat.whiskerRight_app","module":"Mathlib.CategoryTheory.Category.Cat","initialProofState":"C D E : CategoryTheory.Cat\nF G : Quiver.Hom C D\nH : Quiver.Hom D E\nŒ∑ : Quiver.Hom F G\nX : ‚ÜëC\n‚ä¢ Eq ((CategoryTheory.Bicategory.whiskerRight Œ∑ H).app X) (H.map (Œ∑.app X))","decl":"@[simp]\nlemma whiskerRight_app {C D E : Cat} {F G : C ‚ü∂ D} (H : D ‚ü∂ E) (Œ∑ : F ‚ü∂ G) (X : C) :\n    (Œ∑ ‚ñ∑ H).app X = H.map (Œ∑.app X) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Cat.eqToHom_app","module":"Mathlib.CategoryTheory.Category.Cat","initialProofState":"C D : CategoryTheory.Cat\nF G : Quiver.Hom C D\nh : Eq F G\nX : ‚ÜëC\n‚ä¢ Eq ((CategoryTheory.eqToHom h).app X) (CategoryTheory.eqToHom ‚ãØ)","decl":"@[simp]\ntheorem eqToHom_app {C D : Cat} (F G : C ‚ü∂ D) (h : F = G) (X : C) :\n    (eqToHom h).app X = eqToHom (Functor.congr_obj h X) :=\n  CategoryTheory.eqToHom_app h X\n\n"}
{"name":"CategoryTheory.Cat.leftUnitor_hom_app","module":"Mathlib.CategoryTheory.Category.Cat","initialProofState":"B C : CategoryTheory.Cat\nF : Quiver.Hom B C\nX : ‚ÜëB\n‚ä¢ Eq ((CategoryTheory.Bicategory.leftUnitor F).hom.app X) (CategoryTheory.eqToHom ‚ãØ)","decl":"lemma leftUnitor_hom_app {B C : Cat} (F : B ‚ü∂ C) (X : B) : (Œª_ F).hom.app X = eqToHom (by simp) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Cat.leftUnitor_inv_app","module":"Mathlib.CategoryTheory.Category.Cat","initialProofState":"B C : CategoryTheory.Cat\nF : Quiver.Hom B C\nX : ‚ÜëB\n‚ä¢ Eq ((CategoryTheory.Bicategory.leftUnitor F).inv.app X) (CategoryTheory.eqToHom ‚ãØ)","decl":"lemma leftUnitor_inv_app {B C : Cat} (F : B ‚ü∂ C) (X : B) : (Œª_ F).inv.app X = eqToHom (by simp) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Cat.rightUnitor_hom_app","module":"Mathlib.CategoryTheory.Category.Cat","initialProofState":"B C : CategoryTheory.Cat\nF : Quiver.Hom B C\nX : ‚ÜëB\n‚ä¢ Eq ((CategoryTheory.Bicategory.rightUnitor F).hom.app X) (CategoryTheory.eqToHom ‚ãØ)","decl":"lemma rightUnitor_hom_app {B C : Cat} (F : B ‚ü∂ C) (X : B) : (œÅ_ F).hom.app X = eqToHom (by simp) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Cat.rightUnitor_inv_app","module":"Mathlib.CategoryTheory.Category.Cat","initialProofState":"B C : CategoryTheory.Cat\nF : Quiver.Hom B C\nX : ‚ÜëB\n‚ä¢ Eq ((CategoryTheory.Bicategory.rightUnitor F).inv.app X) (CategoryTheory.eqToHom ‚ãØ)","decl":"lemma rightUnitor_inv_app {B C : Cat} (F : B ‚ü∂ C) (X : B) : (œÅ_ F).inv.app X = eqToHom (by simp) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Cat.associator_hom_app","module":"Mathlib.CategoryTheory.Category.Cat","initialProofState":"B C D E : CategoryTheory.Cat\nF : Quiver.Hom B C\nG : Quiver.Hom C D\nH : Quiver.Hom D E\nX : ‚ÜëB\n‚ä¢ Eq ((CategoryTheory.Bicategory.associator F G H).hom.app X) (CategoryTheory.eqToHom ‚ãØ)","decl":"lemma associator_hom_app {B C D E : Cat} (F : B ‚ü∂ C) (G : C ‚ü∂ D) (H : D ‚ü∂ E) (X : B) :\n    (Œ±_ F G H).hom.app X = eqToHom (by simp) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Cat.associator_inv_app","module":"Mathlib.CategoryTheory.Category.Cat","initialProofState":"B C D E : CategoryTheory.Cat\nF : Quiver.Hom B C\nG : Quiver.Hom C D\nH : Quiver.Hom D E\nX : ‚ÜëB\n‚ä¢ Eq ((CategoryTheory.Bicategory.associator F G H).inv.app X) (CategoryTheory.eqToHom ‚ãØ)","decl":"lemma associator_inv_app {B C D E : Cat} (F : B ‚ü∂ C) (G : C ‚ü∂ D) (H : D ‚ü∂ E) (X : B) :\n    (Œ±_ F G H).inv.app X = eqToHom (by simp) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Cat.id_eq_id","module":"Mathlib.CategoryTheory.Category.Cat","initialProofState":"X : CategoryTheory.Cat\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id X) (CategoryTheory.Functor.id ‚ÜëX)","decl":"/-- The identity in the category of categories equals the identity functor.-/\ntheorem id_eq_id (X : Cat) : ùüô X = ùü≠ X := rfl\n\n"}
{"name":"CategoryTheory.Cat.comp_eq_comp","module":"Mathlib.CategoryTheory.Category.Cat","initialProofState":"X Y Z : CategoryTheory.Cat\nF : Quiver.Hom X Y\nG : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp F G) (CategoryTheory.Functor.comp F G)","decl":"/-- Composition in the category of categories equals functor composition.-/\ntheorem comp_eq_comp {X Y Z : Cat} (F : X ‚ü∂ Y) (G : Y ‚ü∂ Z) : F ‚â´ G = F ‚ãô G := rfl\n\n"}
{"name":"CategoryTheory.Cat.of_Œ±","module":"Mathlib.CategoryTheory.Category.Cat","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\n‚ä¢ Eq (‚Üë(CategoryTheory.Cat.of C)) C","decl":"@[simp] theorem of_Œ± (C) [Category C] : (of C).Œ± = C := rfl\n\n"}
{"name":"CategoryTheory.typeToCat_map","module":"Mathlib.CategoryTheory.Category.Cat","initialProofState":"X Y : Type u\nf : Quiver.Hom X Y\n‚ä¢ Eq (CategoryTheory.typeToCat.map f) (id (CategoryTheory.Discrete.functor (Function.comp CategoryTheory.Discrete.mk f)))","decl":"/-- Embedding `Type` into `Cat` as discrete categories.\n\nThis ought to be modelled as a 2-functor!\n-/\n@[simps]\ndef typeToCat : Type u ‚•§ Cat where\n  obj X := Cat.of (Discrete X)\n  map := fun {X} {Y} f => by\n    dsimp\n    exact Discrete.functor (Discrete.mk ‚àò f)\n  map_id X := by\n    apply Functor.ext\n    ¬∑ intro X Y f\n      cases f\n      simp only [id_eq, eqToHom_refl, Cat.id_map, Category.comp_id, Category.id_comp]\n      apply ULift.ext\n      aesop_cat\n    ¬∑ simp\n  map_comp f g := by apply Functor.ext; aesop_cat\n\n"}
{"name":"CategoryTheory.typeToCat_obj","module":"Mathlib.CategoryTheory.Category.Cat","initialProofState":"X : Type u\n‚ä¢ Eq (CategoryTheory.typeToCat.obj X) (CategoryTheory.Cat.of (CategoryTheory.Discrete X))","decl":"/-- Embedding `Type` into `Cat` as discrete categories.\n\nThis ought to be modelled as a 2-functor!\n-/\n@[simps]\ndef typeToCat : Type u ‚•§ Cat where\n  obj X := Cat.of (Discrete X)\n  map := fun {X} {Y} f => by\n    dsimp\n    exact Discrete.functor (Discrete.mk ‚àò f)\n  map_id X := by\n    apply Functor.ext\n    ¬∑ intro X Y f\n      cases f\n      simp only [id_eq, eqToHom_refl, Cat.id_map, Category.comp_id, Category.id_comp]\n      apply ULift.ext\n      aesop_cat\n    ¬∑ simp\n  map_comp f g := by apply Functor.ext; aesop_cat\n\n"}
{"name":"CategoryTheory.instFaithfulCatTypeToCat","module":"Mathlib.CategoryTheory.Category.Cat","initialProofState":"‚ä¢ CategoryTheory.typeToCat.Faithful","decl":"instance : Functor.Faithful typeToCat.{u} where\n  map_injective {_X} {_Y} _f _g h :=\n    funext fun x => congr_arg Discrete.as (Functor.congr_obj h ‚ü®x‚ü©)\n\n"}
{"name":"CategoryTheory.instFullCatTypeToCat","module":"Mathlib.CategoryTheory.Category.Cat","initialProofState":"‚ä¢ CategoryTheory.typeToCat.Full","decl":"instance : Functor.Full typeToCat.{u} where\n  map_surjective F := ‚ü®Discrete.as ‚àò F.obj ‚àò Discrete.mk, by\n    apply Functor.ext\n    ¬∑ intro x y f\n      dsimp\n      apply ULift.ext\n      aesop_cat\n    ¬∑ rintro ‚ü®x‚ü©\n      apply Discrete.ext\n      rfl‚ü©\n\n"}
