{"name":"Real.sin_lt","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Bounds","initialProofState":"x : Real\nh : LT.lt 0 x\n⊢ LT.lt (Real.sin x) x","decl":"/-- For 0 < x, we have sin x < x. -/\ntheorem sin_lt (h : 0 < x) : sin x < x := by\n  cases' lt_or_le 1 x with h' h'\n  · exact (sin_le_one x).trans_lt h'\n  have hx : |x| = x := abs_of_nonneg h.le\n  have := le_of_abs_le (sin_bound <| show |x| ≤ 1 by rwa [hx])\n  rw [sub_le_iff_le_add', hx] at this\n  apply this.trans_lt\n  rw [sub_add, sub_lt_self_iff, sub_pos, div_eq_mul_inv (x ^ 3)]\n  refine mul_lt_mul' ?_ (by norm_num) (by norm_num) (pow_pos h 3)\n  apply pow_le_pow_of_le_one h.le h'\n  norm_num\n\n"}
{"name":"Real.sin_le","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Bounds","initialProofState":"x : Real\nhx : LE.le 0 x\n⊢ LE.le (Real.sin x) x","decl":"lemma sin_le (hx : 0 ≤ x) : sin x ≤ x := by\n  obtain rfl | hx := hx.eq_or_lt\n  · simp\n  · exact (sin_lt hx).le\n\n"}
{"name":"Real.lt_sin","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Bounds","initialProofState":"x : Real\nhx : LT.lt x 0\n⊢ LT.lt x (Real.sin x)","decl":"lemma lt_sin (hx : x < 0) : x < sin x := by simpa using sin_lt <| neg_pos.2 hx\n"}
{"name":"Real.le_sin","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Bounds","initialProofState":"x : Real\nhx : LE.le x 0\n⊢ LE.le x (Real.sin x)","decl":"lemma le_sin (hx : x ≤ 0) : x ≤ sin x := by simpa using sin_le <| neg_nonneg.2 hx\n\n"}
{"name":"Real.lt_sin_mul","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Bounds","initialProofState":"x : Real\nhx : LT.lt 0 x\nhx' : LT.lt x 1\n⊢ LT.lt x (Real.sin (HMul.hMul (HDiv.hDiv Real.pi 2) x))","decl":"theorem lt_sin_mul {x : ℝ} (hx : 0 < x) (hx' : x < 1) : x < sin (π / 2 * x) := by\n  simpa [mul_comm x] using\n    strictConcaveOn_sin_Icc.2 ⟨le_rfl, pi_pos.le⟩ ⟨pi_div_two_pos.le, half_le_self pi_pos.le⟩\n      pi_div_two_pos.ne (sub_pos.2 hx') hx\n\n"}
{"name":"Real.le_sin_mul","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Bounds","initialProofState":"x : Real\nhx : LE.le 0 x\nhx' : LE.le x 1\n⊢ LE.le x (Real.sin (HMul.hMul (HDiv.hDiv Real.pi 2) x))","decl":"theorem le_sin_mul {x : ℝ} (hx : 0 ≤ x) (hx' : x ≤ 1) : x ≤ sin (π / 2 * x) := by\n  simpa [mul_comm x] using\n    strictConcaveOn_sin_Icc.concaveOn.2 ⟨le_rfl, pi_pos.le⟩\n      ⟨pi_div_two_pos.le, half_le_self pi_pos.le⟩ (sub_nonneg.2 hx') hx\n\n"}
{"name":"Real.mul_lt_sin","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Bounds","initialProofState":"x : Real\nhx : LT.lt 0 x\nhx' : LT.lt x (HDiv.hDiv Real.pi 2)\n⊢ LT.lt (HMul.hMul (HDiv.hDiv 2 Real.pi) x) (Real.sin x)","decl":"theorem mul_lt_sin {x : ℝ} (hx : 0 < x) (hx' : x < π / 2) : 2 / π * x < sin x := by\n  rw [← inv_div]\n  simpa [-inv_div, mul_inv_cancel_left₀ pi_div_two_pos.ne'] using @lt_sin_mul ((π / 2)⁻¹ * x)\n    (mul_pos (inv_pos.2 pi_div_two_pos) hx) (by rwa [← div_eq_inv_mul, div_lt_one pi_div_two_pos])\n\n"}
{"name":"Real.mul_le_sin","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Bounds","initialProofState":"x : Real\nhx : LE.le 0 x\nhx' : LE.le x (HDiv.hDiv Real.pi 2)\n⊢ LE.le (HMul.hMul (HDiv.hDiv 2 Real.pi) x) (Real.sin x)","decl":"/-- One half of **Jordan's inequality**.\n\nIn the range `[0, π / 2]`, we have a linear lower bound on `sin`. The other half is given by\n`Real.sin_le`.\n-/\ntheorem mul_le_sin {x : ℝ} (hx : 0 ≤ x) (hx' : x ≤ π / 2) : 2 / π * x ≤ sin x := by\n  rw [← inv_div]\n  simpa [-inv_div, mul_inv_cancel_left₀ pi_div_two_pos.ne'] using @le_sin_mul ((π / 2)⁻¹ * x)\n    (mul_nonneg (inv_nonneg.2 pi_div_two_pos.le) hx)\n    (by rwa [← div_eq_inv_mul, div_le_one pi_div_two_pos])\n\n"}
{"name":"Real.sin_le_mul","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Bounds","initialProofState":"x : Real\nhx : LE.le (Neg.neg (HDiv.hDiv Real.pi 2)) x\nhx₀ : LE.le x 0\n⊢ LE.le (Real.sin x) (HMul.hMul (HDiv.hDiv 2 Real.pi) x)","decl":"/-- Half of **Jordan's inequality** for negative values. -/\nlemma sin_le_mul (hx : -(π / 2) ≤ x) (hx₀ : x ≤ 0) : sin x ≤ 2 / π * x := by\n  simpa using mul_le_sin (neg_nonneg.2 hx₀) (neg_le.2 hx)\n\n"}
{"name":"Real.mul_abs_le_abs_sin","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Bounds","initialProofState":"x : Real\nhx : LE.le (abs x) (HDiv.hDiv Real.pi 2)\n⊢ LE.le (HMul.hMul (HDiv.hDiv 2 Real.pi) (abs x)) (abs (Real.sin x))","decl":"/-- Half of **Jordan's inequality** for absolute values. -/\nlemma mul_abs_le_abs_sin (hx : |x| ≤ π / 2) : 2 / π * |x| ≤ |sin x| := by\n  wlog hx₀ : 0 ≤ x\n  case inr => simpa using this (by rwa [abs_neg]) <| neg_nonneg.2 <| le_of_not_le hx₀\n  rw [abs_of_nonneg hx₀] at hx ⊢\n  exact (mul_le_sin hx₀ hx).trans (le_abs_self _)\n\n"}
{"name":"Real.sin_sq_lt_sq","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Bounds","initialProofState":"x : Real\nhx : Ne x 0\n⊢ LT.lt (HPow.hPow (Real.sin x) 2) (HPow.hPow x 2)","decl":"lemma sin_sq_lt_sq (hx : x ≠ 0) : sin x ^ 2 < x ^ 2 := by\n  wlog hx₀ : 0 < x\n  case inr =>\n    simpa using this (neg_ne_zero.2 hx) <| neg_pos_of_neg <| hx.lt_of_le <| le_of_not_lt hx₀\n  rcases le_or_lt x 1 with hxπ | hxπ\n  case inl =>\n    exact pow_lt_pow_left₀ (sin_lt hx₀)\n      (sin_nonneg_of_nonneg_of_le_pi hx₀.le (by linarith [two_le_pi])) (by simp)\n  case inr =>\n    exact (sin_sq_le_one _).trans_lt (by rwa [one_lt_sq_iff₀ hx₀.le])\n\n"}
{"name":"Real.sin_sq_le_sq","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Bounds","initialProofState":"x : Real\n⊢ LE.le (HPow.hPow (Real.sin x) 2) (HPow.hPow x 2)","decl":"lemma sin_sq_le_sq : sin x ^ 2 ≤ x ^ 2 := by\n  rcases eq_or_ne x 0 with rfl | hx\n  case inl => simp\n  case inr => exact (sin_sq_lt_sq hx).le\n\n"}
{"name":"Real.abs_sin_lt_abs","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Bounds","initialProofState":"x : Real\nhx : Ne x 0\n⊢ LT.lt (abs (Real.sin x)) (abs x)","decl":"lemma abs_sin_lt_abs (hx : x ≠ 0) : |sin x| < |x| := sq_lt_sq.1 (sin_sq_lt_sq hx)\n"}
{"name":"Real.abs_sin_le_abs","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Bounds","initialProofState":"x : Real\n⊢ LE.le (abs (Real.sin x)) (abs x)","decl":"lemma abs_sin_le_abs : |sin x| ≤ |x| := sq_le_sq.1 sin_sq_le_sq\n\n"}
{"name":"Real.one_sub_sq_div_two_lt_cos","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Bounds","initialProofState":"x : Real\nhx : Ne x 0\n⊢ LT.lt (HSub.hSub 1 (HDiv.hDiv (HPow.hPow x 2) 2)) (Real.cos x)","decl":"lemma one_sub_sq_div_two_lt_cos (hx : x ≠ 0) : 1 - x ^ 2 / 2 < cos x := by\n  have := (sin_sq_lt_sq (by positivity)).trans_eq' (sin_sq_eq_half_sub (x / 2)).symm\n  ring_nf at this\n  linarith\n\n"}
{"name":"Real.one_sub_sq_div_two_le_cos","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Bounds","initialProofState":"x : Real\n⊢ LE.le (HSub.hSub 1 (HDiv.hDiv (HPow.hPow x 2) 2)) (Real.cos x)","decl":"lemma one_sub_sq_div_two_le_cos : 1 - x ^ 2 / 2 ≤ cos x := by\n  rcases eq_or_ne x 0 with rfl | hx\n  case inl => simp\n  case inr => exact (one_sub_sq_div_two_lt_cos hx).le\n\n"}
{"name":"Real.one_sub_mul_le_cos","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Bounds","initialProofState":"x : Real\nhx₀ : LE.le 0 x\nhx : LE.le x (HDiv.hDiv Real.pi 2)\n⊢ LE.le (HSub.hSub 1 (HMul.hMul (HDiv.hDiv 2 Real.pi) x)) (Real.cos x)","decl":"/-- Half of **Jordan's inequality** for `cos`. -/\nlemma one_sub_mul_le_cos (hx₀ : 0 ≤ x) (hx : x ≤ π / 2) : 1 - 2 / π * x ≤ cos x := by\n  simpa [sin_pi_div_two_sub, mul_sub, div_mul_div_comm, mul_comm π, pi_pos.ne']\n    using mul_le_sin (x := π / 2 - x) (by simpa) (by simpa)\n\n"}
{"name":"Real.one_add_mul_le_cos","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Bounds","initialProofState":"x : Real\nhx₀ : LE.le (Neg.neg (HDiv.hDiv Real.pi 2)) x\nhx : LE.le x 0\n⊢ LE.le (HAdd.hAdd 1 (HMul.hMul (HDiv.hDiv 2 Real.pi) x)) (Real.cos x)","decl":"/-- Half of **Jordan's inequality** for `cos` and negative values. -/\nlemma one_add_mul_le_cos (hx₀ : -(π / 2) ≤ x) (hx : x ≤ 0) : 1 + 2 / π * x ≤ cos x := by\n  simpa using one_sub_mul_le_cos (x := -x) (by linarith) (by linarith)\n\n"}
{"name":"Real.cos_le_one_sub_mul_cos_sq","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Bounds","initialProofState":"x : Real\nhx : LE.le (abs x) Real.pi\n⊢ LE.le (Real.cos x) (HSub.hSub 1 (HMul.hMul (HDiv.hDiv 2 (HPow.hPow Real.pi 2)) (HPow.hPow x 2)))","decl":"lemma cos_le_one_sub_mul_cos_sq (hx : |x| ≤ π) : cos x ≤ 1 - 2 / π ^ 2 * x ^ 2 := by\n  wlog hx₀ : 0 ≤ x\n  case inr => simpa using this (by rwa [abs_neg]) <| neg_nonneg.2 <| le_of_not_le hx₀\n  rw [abs_of_nonneg hx₀] at hx\n  have : x / π ≤ sin (x / 2) := by simpa using mul_le_sin (x := x / 2) (by positivity) (by linarith)\n  have := (pow_le_pow_left₀ (by positivity) this 2).trans_eq (sin_sq_eq_half_sub _)\n  ring_nf at this ⊢\n  linarith\n\n"}
{"name":"Real.two_div_pi_mul_le_sin","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Bounds","initialProofState":"x : Real\nhx : LE.le 0 x\nhx' : LE.le x (HDiv.hDiv Real.pi 2)\n⊢ LE.le (HMul.hMul (HDiv.hDiv 2 Real.pi) x) (Real.sin x)","decl":"@[deprecated (since := \"2024-08-29\")] alias two_div_pi_mul_le_sin := mul_le_sin\n"}
{"name":"Real.sin_le_two_div_pi_mul","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Bounds","initialProofState":"x : Real\nhx : LE.le (Neg.neg (HDiv.hDiv Real.pi 2)) x\nhx₀ : LE.le x 0\n⊢ LE.le (Real.sin x) (HMul.hMul (HDiv.hDiv 2 Real.pi) x)","decl":"@[deprecated (since := \"2024-08-29\")] alias sin_le_two_div_pi_mul := sin_le_mul\n"}
{"name":"Real.one_sub_two_div_pi_mul_le_cos","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Bounds","initialProofState":"x : Real\nhx₀ : LE.le 0 x\nhx : LE.le x (HDiv.hDiv Real.pi 2)\n⊢ LE.le (HSub.hSub 1 (HMul.hMul (HDiv.hDiv 2 Real.pi) x)) (Real.cos x)","decl":"@[deprecated (since := \"2024-08-29\")] alias one_sub_two_div_pi_mul_le_cos := one_sub_mul_le_cos\n"}
{"name":"Real.cos_quadratic_upper_bound","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Bounds","initialProofState":"x : Real\nhx : LE.le (abs x) Real.pi\n⊢ LE.le (Real.cos x) (HSub.hSub 1 (HMul.hMul (HDiv.hDiv 2 (HPow.hPow Real.pi 2)) (HPow.hPow x 2)))","decl":"@[deprecated (since := \"2024-08-29\")] alias cos_quadratic_upper_bound := cos_le_one_sub_mul_cos_sq\n\n"}
{"name":"Real.sin_gt_sub_cube","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Bounds","initialProofState":"x : Real\nh : LT.lt 0 x\nh' : LE.le x 1\n⊢ LT.lt (HSub.hSub x (HDiv.hDiv (HPow.hPow x 3) 4)) (Real.sin x)","decl":"/-- For 0 < x ≤ 1 we have x - x ^ 3 / 4 < sin x.\n\nThis is also true for x > 1, but it's nontrivial for x just above 1. This inequality is not\ntight; the tighter inequality is sin x > x - x ^ 3 / 6 for all x > 0, but this inequality has\na simpler proof. -/\ntheorem sin_gt_sub_cube {x : ℝ} (h : 0 < x) (h' : x ≤ 1) : x - x ^ 3 / 4 < sin x := by\n  have hx : |x| = x := abs_of_nonneg h.le\n  have := neg_le_of_abs_le (sin_bound <| show |x| ≤ 1 by rwa [hx])\n  rw [le_sub_iff_add_le, hx] at this\n  refine lt_of_lt_of_le ?_ this\n  have : x ^ 3 / ↑4 - x ^ 3 / ↑6 = x ^ 3 * 12⁻¹ := by norm_num [div_eq_mul_inv, ← mul_sub]\n  rw [add_comm, sub_add, sub_neg_eq_add, sub_lt_sub_iff_left, ← lt_sub_iff_add_lt', this]\n  refine mul_lt_mul' ?_ (by norm_num) (by norm_num) (pow_pos h 3)\n  apply pow_le_pow_of_le_one h.le h'\n  norm_num\n\n"}
{"name":"Real.deriv_tan_sub_id","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Bounds","initialProofState":"x : Real\nh : Ne (Real.cos x) 0\n⊢ Eq (deriv (fun y => HSub.hSub (Real.tan y) y) x) (HSub.hSub (HDiv.hDiv 1 (HPow.hPow (Real.cos x) 2)) 1)","decl":"/-- The derivative of `tan x - x` is `1/(cos x)^2 - 1` away from the zeroes of cos. -/\ntheorem deriv_tan_sub_id (x : ℝ) (h : cos x ≠ 0) :\n    deriv (fun y : ℝ => tan y - y) x = 1 / cos x ^ 2 - 1 :=\n  HasDerivAt.deriv <| by simpa using (hasDerivAt_tan h).add (hasDerivAt_id x).neg\n\n"}
{"name":"Real.lt_tan","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Bounds","initialProofState":"x : Real\nh1 : LT.lt 0 x\nh2 : LT.lt x (HDiv.hDiv Real.pi 2)\n⊢ LT.lt x (Real.tan x)","decl":"/-- For all `0 < x < π/2` we have `x < tan x`.\n\nThis is proved by checking that the function `tan x - x` vanishes\nat zero and has non-negative derivative. -/\ntheorem lt_tan {x : ℝ} (h1 : 0 < x) (h2 : x < π / 2) : x < tan x := by\n  let U := Ico 0 (π / 2)\n  have intU : interior U = Ioo 0 (π / 2) := interior_Ico\n  have half_pi_pos : 0 < π / 2 := div_pos pi_pos two_pos\n  have cos_pos {y : ℝ} (hy : y ∈ U) : 0 < cos y := by\n    exact cos_pos_of_mem_Ioo (Ico_subset_Ioo_left (neg_lt_zero.mpr half_pi_pos) hy)\n  have sin_pos {y : ℝ} (hy : y ∈ interior U) : 0 < sin y := by\n    rw [intU] at hy\n    exact sin_pos_of_mem_Ioo (Ioo_subset_Ioo_right (div_le_self pi_pos.le one_le_two) hy)\n  have tan_cts_U : ContinuousOn tan U := by\n    apply ContinuousOn.mono continuousOn_tan\n    intro z hz\n    simp only [mem_setOf_eq]\n    exact (cos_pos hz).ne'\n  have tan_minus_id_cts : ContinuousOn (fun y : ℝ => tan y - y) U := tan_cts_U.sub continuousOn_id\n  have deriv_pos (y : ℝ) (hy : y ∈ interior U) : 0 < deriv (fun y' : ℝ => tan y' - y') y := by\n    have := cos_pos (interior_subset hy)\n    simp only [deriv_tan_sub_id y this.ne', one_div, gt_iff_lt, sub_pos]\n    norm_cast\n    have bd2 : cos y ^ 2 < 1 := by\n      apply lt_of_le_of_ne y.cos_sq_le_one\n      rw [cos_sq']\n      simpa only [Ne, sub_eq_self, sq_eq_zero_iff] using (sin_pos hy).ne'\n    rwa [lt_inv_comm₀, inv_one]\n    · exact zero_lt_one\n    simpa only [sq, mul_self_pos] using this.ne'\n  have mono := strictMonoOn_of_deriv_pos (convex_Ico 0 (π / 2)) tan_minus_id_cts deriv_pos\n  have zero_in_U : (0 : ℝ) ∈ U := by rwa [left_mem_Ico]\n  have x_in_U : x ∈ U := ⟨h1.le, h2⟩\n  simpa only [tan_zero, sub_zero, sub_pos] using mono zero_in_U x_in_U h1\n\n"}
{"name":"Real.le_tan","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Bounds","initialProofState":"x : Real\nh1 : LE.le 0 x\nh2 : LT.lt x (HDiv.hDiv Real.pi 2)\n⊢ LE.le x (Real.tan x)","decl":"theorem le_tan {x : ℝ} (h1 : 0 ≤ x) (h2 : x < π / 2) : x ≤ tan x := by\n  rcases eq_or_lt_of_le h1 with (rfl | h1')\n  · rw [tan_zero]\n  · exact le_of_lt (lt_tan h1' h2)\n\n"}
{"name":"Real.cos_lt_one_div_sqrt_sq_add_one","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Bounds","initialProofState":"x : Real\nhx1 : LE.le (Neg.neg (HDiv.hDiv (HMul.hMul 3 Real.pi) 2)) x\nhx2 : LE.le x (HDiv.hDiv (HMul.hMul 3 Real.pi) 2)\nhx3 : Ne x 0\n⊢ LT.lt (Real.cos x) (HDiv.hDiv 1 (HAdd.hAdd (HPow.hPow x 2) 1).sqrt)","decl":"theorem cos_lt_one_div_sqrt_sq_add_one {x : ℝ} (hx1 : -(3 * π / 2) ≤ x) (hx2 : x ≤ 3 * π / 2)\n    (hx3 : x ≠ 0) : cos x < (1 / √(x ^ 2 + 1) : ℝ) := by\n  suffices ∀ {y : ℝ}, 0 < y → y ≤ 3 * π / 2 → cos y < 1 / sqrt (y ^ 2 + 1) by\n    rcases lt_or_lt_iff_ne.mpr hx3.symm with ⟨h⟩\n    · exact this h hx2\n    · convert this (by linarith : 0 < -x) (by linarith) using 1\n      · rw [cos_neg]\n      · rw [neg_sq]\n  intro y hy1 hy2\n  have hy3 : ↑0 < y ^ 2 + 1 := by linarith [sq_nonneg y]\n  rcases lt_or_le y (π / 2) with (hy2' | hy1')\n  · -- Main case : `0 < y < π / 2`\n    have hy4 : 0 < cos y := cos_pos_of_mem_Ioo ⟨by linarith, hy2'⟩\n    rw [← abs_of_nonneg (cos_nonneg_of_mem_Icc ⟨by linarith, hy2'.le⟩), ←\n      abs_of_nonneg (one_div_nonneg.mpr (sqrt_nonneg _)), ← sq_lt_sq, div_pow, one_pow,\n      sq_sqrt hy3.le, lt_one_div (pow_pos hy4 _) hy3, ← inv_one_add_tan_sq hy4.ne', one_div,\n      inv_inv, add_comm, add_lt_add_iff_left, sq_lt_sq, abs_of_pos hy1,\n      abs_of_nonneg (tan_nonneg_of_nonneg_of_le_pi_div_two hy1.le hy2'.le)]\n    exact Real.lt_tan hy1 hy2'\n  · -- Easy case : `π / 2 ≤ y ≤ 3 * π / 2`\n    refine lt_of_le_of_lt ?_ (one_div_pos.mpr <| sqrt_pos_of_pos hy3)\n    exact cos_nonpos_of_pi_div_two_le_of_le hy1' (by linarith [pi_pos])\n\n"}
{"name":"Real.cos_le_one_div_sqrt_sq_add_one","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Bounds","initialProofState":"x : Real\nhx1 : LE.le (Neg.neg (HDiv.hDiv (HMul.hMul 3 Real.pi) 2)) x\nhx2 : LE.le x (HDiv.hDiv (HMul.hMul 3 Real.pi) 2)\n⊢ LE.le (Real.cos x) (HDiv.hDiv 1 (HAdd.hAdd (HPow.hPow x 2) 1).sqrt)","decl":"theorem cos_le_one_div_sqrt_sq_add_one {x : ℝ} (hx1 : -(3 * π / 2) ≤ x) (hx2 : x ≤ 3 * π / 2) :\n    cos x ≤ (1 : ℝ) / √(x ^ 2 + 1) := by\n  rcases eq_or_ne x 0 with (rfl | hx3)\n  · simp\n  · exact (cos_lt_one_div_sqrt_sq_add_one hx1 hx2 hx3).le\n\n"}
