{"name":"Submodule.piQuotientLift_mk","module":"Mathlib.LinearAlgebra.Quotient.Pi","initialProofState":"ι : Type u_1\nR : Type u_2\ninst✝⁶ : CommRing R\nMs : ι → Type u_3\ninst✝⁵ : (i : ι) → AddCommGroup (Ms i)\ninst✝⁴ : (i : ι) → Module R (Ms i)\nN : Type u_4\ninst✝³ : AddCommGroup N\ninst✝² : Module R N\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\np : (i : ι) → Submodule R (Ms i)\nq : Submodule R N\nf : (i : ι) → LinearMap (RingHom.id R) (Ms i) N\nhf : ∀ (i : ι), LE.le (p i) (Submodule.comap (f i) q)\nx : (i : ι) → Ms i\n⊢ Eq ((Submodule.piQuotientLift p q f hf) fun i => Submodule.Quotient.mk (x i)) (Submodule.Quotient.mk (((LinearMap.lsum R Ms R) f) x))","decl":"@[simp]\ntheorem piQuotientLift_mk [Fintype ι] [DecidableEq ι] (p : ∀ i, Submodule R (Ms i))\n    (q : Submodule R N) (f : ∀ i, Ms i →ₗ[R] N) (hf : ∀ i, p i ≤ q.comap (f i)) (x : ∀ i, Ms i) :\n    (piQuotientLift p q f hf fun i => Quotient.mk (x i)) = Quotient.mk (lsum _ _ R f x) := by\n  rw [piQuotientLift, lsum_apply, sum_apply, ← mkQ_apply, lsum_apply, sum_apply, _root_.map_sum]\n  simp only [coe_proj, mapQ_apply, mkQ_apply, comp_apply]\n\n"}
{"name":"Submodule.piQuotientLift_single","module":"Mathlib.LinearAlgebra.Quotient.Pi","initialProofState":"ι : Type u_1\nR : Type u_2\ninst✝⁶ : CommRing R\nMs : ι → Type u_3\ninst✝⁵ : (i : ι) → AddCommGroup (Ms i)\ninst✝⁴ : (i : ι) → Module R (Ms i)\nN : Type u_4\ninst✝³ : AddCommGroup N\ninst✝² : Module R N\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\np : (i : ι) → Submodule R (Ms i)\nq : Submodule R N\nf : (i : ι) → LinearMap (RingHom.id R) (Ms i) N\nhf : ∀ (i : ι), LE.le (p i) (Submodule.comap (f i) q)\ni : ι\nx : HasQuotient.Quotient (Ms i) (p i)\n⊢ Eq ((Submodule.piQuotientLift p q f hf) (Pi.single i x)) (((p i).mapQ q (f i) ⋯) x)","decl":"@[simp]\ntheorem piQuotientLift_single [Fintype ι] [DecidableEq ι] (p : ∀ i, Submodule R (Ms i))\n    (q : Submodule R N) (f : ∀ i, Ms i →ₗ[R] N) (hf : ∀ i, p i ≤ q.comap (f i)) (i)\n    (x : Ms i ⧸ p i) : piQuotientLift p q f hf (Pi.single i x) = mapQ _ _ (f i) (hf i) x := by\n  simp_rw [piQuotientLift, lsum_apply, sum_apply, comp_apply, proj_apply]\n  rw [Finset.sum_eq_single i]\n  · rw [Pi.single_eq_same]\n  · rintro j - hj\n    rw [Pi.single_eq_of_ne hj, _root_.map_zero]\n  · intros\n    have := Finset.mem_univ i\n    contradiction\n\n"}
{"name":"Submodule.quotientPiLift_mk","module":"Mathlib.LinearAlgebra.Quotient.Pi","initialProofState":"ι : Type u_1\nR : Type u_2\ninst✝⁴ : CommRing R\nMs : ι → Type u_3\ninst✝³ : (i : ι) → AddCommGroup (Ms i)\ninst✝² : (i : ι) → Module R (Ms i)\nNs : ι → Type u_5\ninst✝¹ : (i : ι) → AddCommGroup (Ns i)\ninst✝ : (i : ι) → Module R (Ns i)\np : (i : ι) → Submodule R (Ms i)\nf : (i : ι) → LinearMap (RingHom.id R) (Ms i) (Ns i)\nhf : ∀ (i : ι), LE.le (p i) (LinearMap.ker (f i))\nx : (i : ι) → Ms i\n⊢ Eq ((Submodule.quotientPiLift p f hf) (Submodule.Quotient.mk x)) fun i => (f i) (x i)","decl":"@[simp]\ntheorem quotientPiLift_mk (p : ∀ i, Submodule R (Ms i)) (f : ∀ i, Ms i →ₗ[R] Ns i)\n    (hf : ∀ i, p i ≤ ker (f i)) (x : ∀ i, Ms i) :\n    quotientPiLift p f hf (Quotient.mk x) = fun i => f i (x i) :=\n  rfl\n\n"}
{"name":"Submodule.quotientPi_aux.map_add","module":"Mathlib.LinearAlgebra.Quotient.Pi","initialProofState":"ι : Type u_1\nR : Type u_2\ninst✝² : CommRing R\nMs : ι → Type u_3\ninst✝¹ : (i : ι) → AddCommGroup (Ms i)\ninst✝ : (i : ι) → Module R (Ms i)\np : (i : ι) → Submodule R (Ms i)\nx y : HasQuotient.Quotient ((i : ι) → Ms i) (Submodule.pi Set.univ p)\n⊢ Eq (Submodule.quotientPi_aux.toFun p (HAdd.hAdd x y)) (HAdd.hAdd (Submodule.quotientPi_aux.toFun p x) (Submodule.quotientPi_aux.toFun p y))","decl":"theorem map_add (x y : ((i : ι) → Ms i) ⧸ pi Set.univ p) :\n    toFun p (x + y) = toFun p x + toFun p y :=\n  LinearMap.map_add (quotientPiLift p (fun i => (p i).mkQ) fun i => (ker_mkQ (p i)).ge) x y\n\n"}
{"name":"Submodule.quotientPi_aux.map_smul","module":"Mathlib.LinearAlgebra.Quotient.Pi","initialProofState":"ι : Type u_1\nR : Type u_2\ninst✝² : CommRing R\nMs : ι → Type u_3\ninst✝¹ : (i : ι) → AddCommGroup (Ms i)\ninst✝ : (i : ι) → Module R (Ms i)\np : (i : ι) → Submodule R (Ms i)\nr : R\nx : HasQuotient.Quotient ((i : ι) → Ms i) (Submodule.pi Set.univ p)\n⊢ Eq (Submodule.quotientPi_aux.toFun p (HSMul.hSMul r x)) (HSMul.hSMul ((RingHom.id R) r) (Submodule.quotientPi_aux.toFun p x))","decl":"theorem map_smul (r : R) (x : ((i : ι) → Ms i) ⧸ pi Set.univ p) :\n    toFun p (r • x) = (RingHom.id R r) • toFun p x :=\n  LinearMap.map_smul (quotientPiLift p (fun i => (p i).mkQ) fun i => (ker_mkQ (p i)).ge) r x\n\n"}
{"name":"Submodule.quotientPi_aux.left_inv","module":"Mathlib.LinearAlgebra.Quotient.Pi","initialProofState":"ι : Type u_1\nR : Type u_2\ninst✝⁴ : CommRing R\nMs : ι → Type u_3\ninst✝³ : (i : ι) → AddCommGroup (Ms i)\ninst✝² : (i : ι) → Module R (Ms i)\np : (i : ι) → Submodule R (Ms i)\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\n⊢ Function.LeftInverse (Submodule.quotientPi_aux.invFun p) (Submodule.quotientPi_aux.toFun p)","decl":"theorem left_inv : Function.LeftInverse (invFun p) (toFun p) := fun x =>\n  Submodule.Quotient.induction_on _ x fun x' => by\n    dsimp only [toFun, invFun]\n    rw [quotientPiLift_mk p, funext fun i => (mkQ_apply (p i) (x' i)), piQuotientLift_mk p,\n      lsum_single, id_apply]\n\n"}
{"name":"Submodule.quotientPi_aux.right_inv","module":"Mathlib.LinearAlgebra.Quotient.Pi","initialProofState":"ι : Type u_1\nR : Type u_2\ninst✝⁴ : CommRing R\nMs : ι → Type u_3\ninst✝³ : (i : ι) → AddCommGroup (Ms i)\ninst✝² : (i : ι) → Module R (Ms i)\np : (i : ι) → Submodule R (Ms i)\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\n⊢ Function.RightInverse (Submodule.quotientPi_aux.invFun p) (Submodule.quotientPi_aux.toFun p)","decl":"theorem right_inv : Function.RightInverse (invFun p) (toFun p) := by\n  dsimp only [toFun, invFun]\n  rw [Function.rightInverse_iff_comp, ← coe_comp, ← @id_coe R]\n  refine congr_arg _ (pi_ext fun i x => Submodule.Quotient.induction_on _ x fun x' =>\n    funext fun j => ?_)\n  rw [comp_apply, piQuotientLift_single, mapQ_apply,\n    quotientPiLift_mk, id_apply]\n  by_cases hij : i = j <;> simp only [mkQ_apply, coe_single]\n  · subst hij\n    rw [Pi.single_eq_same, Pi.single_eq_same]\n  · rw [Pi.single_eq_of_ne (Ne.symm hij), Pi.single_eq_of_ne (Ne.symm hij), Quotient.mk_zero]\n\n"}
{"name":"Submodule.quotientPi_symm_apply","module":"Mathlib.LinearAlgebra.Quotient.Pi","initialProofState":"ι : Type u_1\nR : Type u_2\ninst✝⁴ : CommRing R\nMs : ι → Type u_3\ninst✝³ : (i : ι) → AddCommGroup (Ms i)\ninst✝² : (i : ι) → Module R (Ms i)\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\np : (i : ι) → Submodule R (Ms i)\na✝ : (i : ι) → HasQuotient.Quotient (Ms i) (p i)\n⊢ Eq ((Submodule.quotientPi p).symm a✝) ((Submodule.piQuotientLift p (Submodule.pi Set.univ p) (LinearMap.single R Ms) ⋯) a✝)","decl":"open quotientPi_aux in\n/-- The quotient of a direct sum is the direct sum of quotients. -/\n@[simps!]\ndef quotientPi [Fintype ι] [DecidableEq ι] (p : ∀ i, Submodule R (Ms i)) :\n    ((∀ i, Ms i) ⧸ pi Set.univ p) ≃ₗ[R] ∀ i, Ms i ⧸ p i where\n  toFun := toFun p\n  invFun := invFun p\n  map_add' := map_add p\n  map_smul' := quotientPi_aux.map_smul p\n  left_inv := left_inv p\n  right_inv := right_inv p\n\n"}
{"name":"Submodule.quotientPi_apply","module":"Mathlib.LinearAlgebra.Quotient.Pi","initialProofState":"ι : Type u_1\nR : Type u_2\ninst✝⁴ : CommRing R\nMs : ι → Type u_3\ninst✝³ : (i : ι) → AddCommGroup (Ms i)\ninst✝² : (i : ι) → Module R (Ms i)\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\np : (i : ι) → Submodule R (Ms i)\na✝ : HasQuotient.Quotient ((i : ι) → Ms i) (Submodule.pi Set.univ p)\ni : ι\n⊢ Eq ((Submodule.quotientPi p) a✝ i) ((Submodule.quotientPiLift p (fun i => (p i).mkQ) ⋯) a✝ i)","decl":"open quotientPi_aux in\n/-- The quotient of a direct sum is the direct sum of quotients. -/\n@[simps!]\ndef quotientPi [Fintype ι] [DecidableEq ι] (p : ∀ i, Submodule R (Ms i)) :\n    ((∀ i, Ms i) ⧸ pi Set.univ p) ≃ₗ[R] ∀ i, Ms i ⧸ p i where\n  toFun := toFun p\n  invFun := invFun p\n  map_add' := map_add p\n  map_smul' := quotientPi_aux.map_smul p\n  left_inv := left_inv p\n  right_inv := right_inv p\n\n"}
