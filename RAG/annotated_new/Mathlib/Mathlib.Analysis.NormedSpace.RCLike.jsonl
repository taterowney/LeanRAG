{"name":"RCLike.norm_coe_norm","module":"Mathlib.Analysis.NormedSpace.RCLike","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹ : RCLike ğ•œ\nE : Type u_2\ninstâœ : NormedAddCommGroup E\nz : E\nâŠ¢ Eq (Norm.norm â†‘(Norm.norm z)) (Norm.norm z)","decl":"theorem RCLike.norm_coe_norm {z : E} : â€–(â€–zâ€– : ğ•œ)â€– = â€–zâ€– := by simp\n\n"}
{"name":"norm_smul_inv_norm","module":"Mathlib.Analysis.NormedSpace.RCLike","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : RCLike ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nx : E\nhx : Ne x 0\nâŠ¢ Eq (Norm.norm (HSMul.hSMul (Inv.inv â†‘(Norm.norm x)) x)) 1","decl":"/-- Lemma to normalize a vector in a normed space `E` over either `â„‚` or `â„` to unit length. -/\n@[simp]\ntheorem norm_smul_inv_norm {x : E} (hx : x â‰  0) : â€–(â€–xâ€–â»Â¹ : ğ•œ) â€¢ xâ€– = 1 := by\n  have : â€–xâ€– â‰  0 := by simp [hx]\n  field_simp [norm_smul]\n\n"}
{"name":"norm_smul_inv_norm'","module":"Mathlib.Analysis.NormedSpace.RCLike","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : RCLike ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nr : Real\nr_nonneg : LE.le 0 r\nx : E\nhx : Ne x 0\nâŠ¢ Eq (Norm.norm (HSMul.hSMul (HMul.hMul (â†‘r) (Inv.inv â†‘(Norm.norm x))) x)) r","decl":"/-- Lemma to normalize a vector in a normed space `E` over either `â„‚` or `â„` to length `r`. -/\ntheorem norm_smul_inv_norm' {r : â„} (r_nonneg : 0 â‰¤ r) {x : E} (hx : x â‰  0) :\n    â€–((r : ğ•œ) * (â€–xâ€– : ğ•œ)â»Â¹) â€¢ xâ€– = r := by\n  have : â€–xâ€– â‰  0 := by simp [hx]\n  field_simp [norm_smul, r_nonneg, rclike_simps]\n\n"}
{"name":"LinearMap.bound_of_sphere_bound","module":"Mathlib.Analysis.NormedSpace.RCLike","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : RCLike ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nr : Real\nr_pos : LT.lt 0 r\nc : Real\nf : LinearMap (RingHom.id ğ•œ) E ğ•œ\nh : âˆ€ (z : E), Membership.mem (Metric.sphere 0 r) z â†’ LE.le (Norm.norm (f z)) c\nz : E\nâŠ¢ LE.le (Norm.norm (f z)) (HMul.hMul (HDiv.hDiv c r) (Norm.norm z))","decl":"theorem LinearMap.bound_of_sphere_bound {r : â„} (r_pos : 0 < r) (c : â„) (f : E â†’â‚—[ğ•œ] ğ•œ)\n    (h : âˆ€ z âˆˆ sphere (0 : E) r, â€–f zâ€– â‰¤ c) (z : E) : â€–f zâ€– â‰¤ c / r * â€–zâ€– := by\n  by_cases z_zero : z = 0\n  Â· rw [z_zero]\n    simp only [LinearMap.map_zero, norm_zero, mul_zero]\n    exact le_rfl\n  set zâ‚ := ((r : ğ•œ) * (â€–zâ€– : ğ•œ)â»Â¹) â€¢ z with hzâ‚\n  have norm_f_zâ‚ : â€–f zâ‚â€– â‰¤ c := by\n    apply h\n    rw [mem_sphere_zero_iff_norm]\n    exact norm_smul_inv_norm' r_pos.le z_zero\n  have r_ne_zero : (r : ğ•œ) â‰  0 := RCLike.ofReal_ne_zero.mpr r_pos.ne'\n  have eq : f z = â€–zâ€– / r * f zâ‚ := by\n    rw [hzâ‚, LinearMap.map_smul, smul_eq_mul]\n    rw [â† mul_assoc, â† mul_assoc, div_mul_cancelâ‚€ _ r_ne_zero, mul_inv_cancelâ‚€, one_mul]\n    simp only [z_zero, RCLike.ofReal_eq_zero, norm_eq_zero, Ne, not_false_iff]\n  rw [eq, norm_mul, norm_div, RCLike.norm_coe_norm, RCLike.norm_of_nonneg r_pos.le,\n    div_mul_eq_mul_div, div_mul_eq_mul_div, mul_comm]\n  apply div_le_divâ‚€ _ _ r_pos rfl.ge\n  Â· exact mul_nonneg ((norm_nonneg _).trans norm_f_zâ‚) (norm_nonneg z)\n  apply mul_le_mul norm_f_zâ‚ rfl.le (norm_nonneg z) ((norm_nonneg _).trans norm_f_zâ‚)\n\n"}
{"name":"LinearMap.bound_of_ball_bound'","module":"Mathlib.Analysis.NormedSpace.RCLike","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : RCLike ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nr : Real\nr_pos : LT.lt 0 r\nc : Real\nf : LinearMap (RingHom.id ğ•œ) E ğ•œ\nh : âˆ€ (z : E), Membership.mem (Metric.closedBall 0 r) z â†’ LE.le (Norm.norm (f z)) c\nz : E\nâŠ¢ LE.le (Norm.norm (f z)) (HMul.hMul (HDiv.hDiv c r) (Norm.norm z))","decl":"/-- `LinearMap.bound_of_ball_bound` is a version of this over arbitrary nontrivially normed fields.\nIt produces a less precise bound so we keep both versions. -/\ntheorem LinearMap.bound_of_ball_bound' {r : â„} (r_pos : 0 < r) (c : â„) (f : E â†’â‚—[ğ•œ] ğ•œ)\n    (h : âˆ€ z âˆˆ closedBall (0 : E) r, â€–f zâ€– â‰¤ c) (z : E) : â€–f zâ€– â‰¤ c / r * â€–zâ€– :=\n  f.bound_of_sphere_bound r_pos c (fun z hz => h z hz.le) z\n\n"}
{"name":"ContinuousLinearMap.opNorm_bound_of_ball_bound","module":"Mathlib.Analysis.NormedSpace.RCLike","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : RCLike ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nr : Real\nr_pos : LT.lt 0 r\nc : Real\nf : ContinuousLinearMap (RingHom.id ğ•œ) E ğ•œ\nh : âˆ€ (z : E), Membership.mem (Metric.closedBall 0 r) z â†’ LE.le (Norm.norm (f z)) c\nâŠ¢ LE.le (Norm.norm f) (HDiv.hDiv c r)","decl":"theorem ContinuousLinearMap.opNorm_bound_of_ball_bound {r : â„} (r_pos : 0 < r) (c : â„)\n    (f : E â†’L[ğ•œ] ğ•œ) (h : âˆ€ z âˆˆ closedBall (0 : E) r, â€–f zâ€– â‰¤ c) : â€–fâ€– â‰¤ c / r := by\n  apply ContinuousLinearMap.opNorm_le_bound\n  Â· apply div_nonneg _ r_pos.le\n    exact\n      (norm_nonneg _).trans\n        (h 0 (by simp only [norm_zero, mem_closedBall, dist_zero_left, r_pos.le]))\n  apply LinearMap.bound_of_ball_bound' r_pos\n  exact fun z hz => h z hz\n\n"}
{"name":"NormedSpace.sphere_nonempty_rclike","module":"Mathlib.Analysis.NormedSpace.RCLike","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : RCLike ğ•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ğ•œ E\ninstâœ : Nontrivial E\nr : Real\nhr : LE.le 0 r\nâŠ¢ Nonempty â†‘(Metric.sphere 0 r)","decl":"include ğ•œ in\ntheorem NormedSpace.sphere_nonempty_rclike [Nontrivial E] {r : â„} (hr : 0 â‰¤ r) :\n    Nonempty (sphere (0 : E) r) :=\n  letI : NormedSpace â„ E := NormedSpace.restrictScalars â„ ğ•œ E\n  (NormedSpace.sphere_nonempty.mpr hr).coe_sort\n"}
