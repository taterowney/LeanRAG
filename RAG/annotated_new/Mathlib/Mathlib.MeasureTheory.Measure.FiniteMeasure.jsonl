{"name":"MeasureTheory.FiniteMeasure.isFiniteMeasure","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœ : MeasurableSpace Î©\nÎ¼ : MeasureTheory.FiniteMeasure Î©\nâŠ¢ MeasureTheory.IsFiniteMeasure â†‘Î¼","decl":"instance isFiniteMeasure (Î¼ : FiniteMeasure Î©) : IsFiniteMeasure (Î¼ : Measure Î©) := Î¼.prop\n\n"}
{"name":"MeasureTheory.FiniteMeasure.val_eq_toMeasure","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœ : MeasurableSpace Î©\nÎ½ : MeasureTheory.FiniteMeasure Î©\nâŠ¢ Eq â†‘Î½ â†‘Î½","decl":"@[simp]\ntheorem val_eq_toMeasure (Î½ : FiniteMeasure Î©) : Î½.val = (Î½ : Measure Î©) := rfl\n\n"}
{"name":"MeasureTheory.FiniteMeasure.toMeasure_injective","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœ : MeasurableSpace Î©\nâŠ¢ Function.Injective MeasureTheory.FiniteMeasure.toMeasure","decl":"theorem toMeasure_injective : Function.Injective ((â†‘) : FiniteMeasure Î© â†’ Measure Î©) :=\n  Subtype.coe_injective\n\n"}
{"name":"MeasureTheory.FiniteMeasure.coeFn_def","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœ : MeasurableSpace Î©\nÎ¼ : MeasureTheory.FiniteMeasure Î©\nâŠ¢ Eq â‡‘Î¼ fun s => (â†‘Î¼ s).toNNReal","decl":"lemma coeFn_def (Î¼ : FiniteMeasure Î©) : Î¼ = fun s â†¦ ((Î¼ : Measure Î©) s).toNNReal := rfl\n\n"}
{"name":"MeasureTheory.FiniteMeasure.coeFn_mk","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœ : MeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\nhÎ¼ : MeasureTheory.IsFiniteMeasure Î¼\nâŠ¢ Eq â‡‘âŸ¨Î¼, hÎ¼âŸ© fun s => (Î¼ s).toNNReal","decl":"lemma coeFn_mk (Î¼ : Measure Î©) (hÎ¼) :\n    DFunLike.coe (F := FiniteMeasure Î©) âŸ¨Î¼, hÎ¼âŸ© = fun s â†¦ (Î¼ s).toNNReal := rfl\n\n"}
{"name":"MeasureTheory.FiniteMeasure.mk_apply","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœ : MeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\nhÎ¼ : MeasureTheory.IsFiniteMeasure Î¼\ns : Set Î©\nâŠ¢ Eq (âŸ¨Î¼, hÎ¼âŸ© s) (Î¼ s).toNNReal","decl":"@[simp, norm_cast]\nlemma mk_apply (Î¼ : Measure Î©) (hÎ¼) (s : Set Î©) :\n    DFunLike.coe (F := FiniteMeasure Î©) âŸ¨Î¼, hÎ¼âŸ© s = (Î¼ s).toNNReal := rfl\n\n"}
{"name":"MeasureTheory.FiniteMeasure.ennreal_coeFn_eq_coeFn_toMeasure","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœ : MeasurableSpace Î©\nÎ½ : MeasureTheory.FiniteMeasure Î©\ns : Set Î©\nâŠ¢ Eq (â†‘(Î½ s)) (â†‘Î½ s)","decl":"@[simp]\ntheorem ennreal_coeFn_eq_coeFn_toMeasure (Î½ : FiniteMeasure Î©) (s : Set Î©) :\n    (Î½ s : â„â‰¥0âˆ) = (Î½ : Measure Î©) s :=\n  ENNReal.coe_toNNReal (measure_lt_top (â†‘Î½) s).ne\n\n"}
{"name":"MeasureTheory.FiniteMeasure.null_iff_toMeasure_null","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœ : MeasurableSpace Î©\nÎ½ : MeasureTheory.FiniteMeasure Î©\ns : Set Î©\nâŠ¢ Iff (Eq (Î½ s) 0) (Eq (â†‘Î½ s) 0)","decl":"@[simp]\ntheorem null_iff_toMeasure_null (Î½ : FiniteMeasure Î©) (s : Set Î©) :\n    Î½ s = 0 â†” (Î½ : Measure Î©) s = 0 :=\n  âŸ¨fun h â†¦ by rw [â† ennreal_coeFn_eq_coeFn_toMeasure, h, ENNReal.coe_zero],\n   fun h â†¦ congrArg ENNReal.toNNReal hâŸ©\n\n"}
{"name":"MeasureTheory.FiniteMeasure.apply_mono","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœ : MeasurableSpace Î©\nÎ¼ : MeasureTheory.FiniteMeasure Î©\nsâ‚ sâ‚‚ : Set Î©\nh : HasSubset.Subset sâ‚ sâ‚‚\nâŠ¢ LE.le (Î¼ sâ‚) (Î¼ sâ‚‚)","decl":"theorem apply_mono (Î¼ : FiniteMeasure Î©) {sâ‚ sâ‚‚ : Set Î©} (h : sâ‚ âŠ† sâ‚‚) : Î¼ sâ‚ â‰¤ Î¼ sâ‚‚ :=\n  ENNReal.toNNReal_mono (measure_ne_top _ sâ‚‚) ((Î¼ : Measure Î©).mono h)\n\n"}
{"name":"MeasureTheory.FiniteMeasure.apply_le_mass","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœ : MeasurableSpace Î©\nÎ¼ : MeasureTheory.FiniteMeasure Î©\ns : Set Î©\nâŠ¢ LE.le (Î¼ s) Î¼.mass","decl":"@[simp] theorem apply_le_mass (Î¼ : FiniteMeasure Î©) (s : Set Î©) : Î¼ s â‰¤ Î¼.mass := by\n  simpa using apply_mono Î¼ (subset_univ s)\n\n"}
{"name":"MeasureTheory.FiniteMeasure.ennreal_mass","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœ : MeasurableSpace Î©\nÎ¼ : MeasureTheory.FiniteMeasure Î©\nâŠ¢ Eq (â†‘Î¼.mass) (â†‘Î¼ Set.univ)","decl":"@[simp]\ntheorem ennreal_mass {Î¼ : FiniteMeasure Î©} : (Î¼.mass : â„â‰¥0âˆ) = (Î¼ : Measure Î©) univ :=\n  ennreal_coeFn_eq_coeFn_toMeasure Î¼ Set.univ\n\n"}
{"name":"MeasureTheory.FiniteMeasure.coeFn_zero","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœ : MeasurableSpace Î©\nâŠ¢ Eq (â‡‘0) 0","decl":"@[simp, norm_cast] lemma coeFn_zero : â‡‘(0 : FiniteMeasure Î©) = 0 := rfl\n\n"}
{"name":"MeasureTheory.FiniteMeasure.zero_mass","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœ : MeasurableSpace Î©\nâŠ¢ Eq (MeasureTheory.FiniteMeasure.mass 0) 0","decl":"@[simp]\ntheorem zero_mass : (0 : FiniteMeasure Î©).mass = 0 := rfl\n\n"}
{"name":"MeasureTheory.FiniteMeasure.mass_zero_iff","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœ : MeasurableSpace Î©\nÎ¼ : MeasureTheory.FiniteMeasure Î©\nâŠ¢ Iff (Eq Î¼.mass 0) (Eq Î¼ 0)","decl":"@[simp]\ntheorem mass_zero_iff (Î¼ : FiniteMeasure Î©) : Î¼.mass = 0 â†” Î¼ = 0 := by\n  refine âŸ¨fun Î¼_mass => ?_, fun hÎ¼ => by simp only [hÎ¼, zero_mass]âŸ©\n  apply toMeasure_injective\n  apply Measure.measure_univ_eq_zero.mp\n  rwa [â† ennreal_mass, ENNReal.coe_eq_zero]\n\n"}
{"name":"MeasureTheory.FiniteMeasure.mass_nonzero_iff","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœ : MeasurableSpace Î©\nÎ¼ : MeasureTheory.FiniteMeasure Î©\nâŠ¢ Iff (Ne Î¼.mass 0) (Ne Î¼ 0)","decl":"theorem mass_nonzero_iff (Î¼ : FiniteMeasure Î©) : Î¼.mass â‰  0 â†” Î¼ â‰  0 :=\n  not_iff_not.mpr <| FiniteMeasure.mass_zero_iff Î¼\n\n"}
{"name":"MeasureTheory.FiniteMeasure.eq_of_forall_toMeasure_apply_eq","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœ : MeasurableSpace Î©\nÎ¼ Î½ : MeasureTheory.FiniteMeasure Î©\nh : âˆ€ (s : Set Î©), MeasurableSet s â†’ Eq (â†‘Î¼ s) (â†‘Î½ s)\nâŠ¢ Eq Î¼ Î½","decl":"@[ext]\ntheorem eq_of_forall_toMeasure_apply_eq (Î¼ Î½ : FiniteMeasure Î©)\n    (h : âˆ€ s : Set Î©, MeasurableSet s â†’ (Î¼ : Measure Î©) s = (Î½ : Measure Î©) s) : Î¼ = Î½ := by\n  apply Subtype.ext\n  ext1 s s_mble\n  exact h s s_mble\n\n"}
{"name":"MeasureTheory.FiniteMeasure.eq_of_forall_toMeasure_apply_eq_iff","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœ : MeasurableSpace Î©\nÎ¼ Î½ : MeasureTheory.FiniteMeasure Î©\nâŠ¢ Iff (Eq Î¼ Î½) (âˆ€ (s : Set Î©), MeasurableSet s â†’ Eq (â†‘Î¼ s) (â†‘Î½ s))","decl":"@[ext]\ntheorem eq_of_forall_toMeasure_apply_eq (Î¼ Î½ : FiniteMeasure Î©)\n    (h : âˆ€ s : Set Î©, MeasurableSet s â†’ (Î¼ : Measure Î©) s = (Î½ : Measure Î©) s) : Î¼ = Î½ := by\n  apply Subtype.ext\n  ext1 s s_mble\n  exact h s s_mble\n\n"}
{"name":"MeasureTheory.FiniteMeasure.eq_of_forall_apply_eq","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœ : MeasurableSpace Î©\nÎ¼ Î½ : MeasureTheory.FiniteMeasure Î©\nh : âˆ€ (s : Set Î©), MeasurableSet s â†’ Eq (Î¼ s) (Î½ s)\nâŠ¢ Eq Î¼ Î½","decl":"theorem eq_of_forall_apply_eq (Î¼ Î½ : FiniteMeasure Î©)\n    (h : âˆ€ s : Set Î©, MeasurableSet s â†’ Î¼ s = Î½ s) : Î¼ = Î½ := by\n  ext1 s s_mble\n  simpa [ennreal_coeFn_eq_coeFn_toMeasure] using congr_arg ((â†‘) : â„â‰¥0 â†’ â„â‰¥0âˆ) (h s s_mble)\n\n"}
{"name":"MeasureTheory.FiniteMeasure.toMeasure_zero","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœ : MeasurableSpace Î©\nâŠ¢ Eq (â†‘0) 0","decl":"@[simp, norm_cast]\ntheorem toMeasure_zero : ((â†‘) : FiniteMeasure Î© â†’ Measure Î©) 0 = 0 := rfl\n\n"}
{"name":"MeasureTheory.FiniteMeasure.toMeasure_add","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœ : MeasurableSpace Î©\nÎ¼ Î½ : MeasureTheory.FiniteMeasure Î©\nâŠ¢ Eq (â†‘(HAdd.hAdd Î¼ Î½)) (HAdd.hAdd â†‘Î¼ â†‘Î½)","decl":"@[norm_cast]\ntheorem toMeasure_add (Î¼ Î½ : FiniteMeasure Î©) : â†‘(Î¼ + Î½) = (â†‘Î¼ + â†‘Î½ : Measure Î©) := rfl\n\n"}
{"name":"MeasureTheory.FiniteMeasure.toMeasure_smul","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœâ´ : MeasurableSpace Î©\nR : Type u_2\ninstâœÂ³ : SMul R NNReal\ninstâœÂ² : SMul R ENNReal\ninstâœÂ¹ : IsScalarTower R NNReal ENNReal\ninstâœ : IsScalarTower R ENNReal ENNReal\nc : R\nÎ¼ : MeasureTheory.FiniteMeasure Î©\nâŠ¢ Eq (â†‘(HSMul.hSMul c Î¼)) (HSMul.hSMul c â†‘Î¼)","decl":"@[simp, norm_cast]\ntheorem toMeasure_smul (c : R) (Î¼ : FiniteMeasure Î©) : â†‘(c â€¢ Î¼) = c â€¢ (Î¼ : Measure Î©) :=\n  rfl\n\n"}
{"name":"MeasureTheory.FiniteMeasure.coeFn_add","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœ : MeasurableSpace Î©\nÎ¼ Î½ : MeasureTheory.FiniteMeasure Î©\nâŠ¢ Eq (â‡‘(HAdd.hAdd Î¼ Î½)) (HAdd.hAdd â‡‘Î¼ â‡‘Î½)","decl":"@[simp, norm_cast]\ntheorem coeFn_add (Î¼ Î½ : FiniteMeasure Î©) : (â‡‘(Î¼ + Î½) : Set Î© â†’ â„â‰¥0) = (â‡‘Î¼ + â‡‘Î½ : Set Î© â†’ â„â‰¥0) := by\n  funext\n  simp only [Pi.add_apply, â† ENNReal.coe_inj, ne_eq, ennreal_coeFn_eq_coeFn_toMeasure,\n    ENNReal.coe_add]\n  norm_cast\n\n"}
{"name":"MeasureTheory.FiniteMeasure.coeFn_smul","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœâµ : MeasurableSpace Î©\nR : Type u_2\ninstâœâ´ : SMul R NNReal\ninstâœÂ³ : SMul R ENNReal\ninstâœÂ² : IsScalarTower R NNReal ENNReal\ninstâœÂ¹ : IsScalarTower R ENNReal ENNReal\ninstâœ : IsScalarTower R NNReal NNReal\nc : R\nÎ¼ : MeasureTheory.FiniteMeasure Î©\nâŠ¢ Eq (â‡‘(HSMul.hSMul c Î¼)) (HSMul.hSMul c â‡‘Î¼)","decl":"@[simp, norm_cast]\ntheorem coeFn_smul [IsScalarTower R â„â‰¥0 â„â‰¥0] (c : R) (Î¼ : FiniteMeasure Î©) :\n    (â‡‘(c â€¢ Î¼) : Set Î© â†’ â„â‰¥0) = c â€¢ (â‡‘Î¼ : Set Î© â†’ â„â‰¥0) := by\n  funext; simp [â† ENNReal.coe_inj, ENNReal.coe_smul]\n\n"}
{"name":"MeasureTheory.FiniteMeasure.toMeasureAddMonoidHom_apply","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœ : MeasurableSpace Î©\naâœ : MeasureTheory.FiniteMeasure Î©\nâŠ¢ Eq (MeasureTheory.FiniteMeasure.toMeasureAddMonoidHom aâœ) â†‘aâœ","decl":"/-- Coercion is an `AddMonoidHom`. -/\n@[simps]\ndef toMeasureAddMonoidHom : FiniteMeasure Î© â†’+ Measure Î© where\n  toFun := (â†‘)\n  map_zero' := toMeasure_zero\n  map_add' := toMeasure_add\n\n"}
{"name":"MeasureTheory.FiniteMeasure.smul_apply","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœâµ : MeasurableSpace Î©\nR : Type u_2\ninstâœâ´ : SMul R NNReal\ninstâœÂ³ : SMul R ENNReal\ninstâœÂ² : IsScalarTower R NNReal ENNReal\ninstâœÂ¹ : IsScalarTower R ENNReal ENNReal\ninstâœ : IsScalarTower R NNReal NNReal\nc : R\nÎ¼ : MeasureTheory.FiniteMeasure Î©\ns : Set Î©\nâŠ¢ Eq ((HSMul.hSMul c Î¼) s) (HSMul.hSMul c (Î¼ s))","decl":"@[simp]\ntheorem smul_apply [IsScalarTower R â„â‰¥0 â„â‰¥0] (c : R) (Î¼ : FiniteMeasure Î©) (s : Set Î©) :\n    (c â€¢ Î¼) s = c â€¢ Î¼ s := by\n  rw [coeFn_smul, Pi.smul_apply]\n\n"}
{"name":"MeasureTheory.FiniteMeasure.restrict_measure_eq","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœ : MeasurableSpace Î©\nÎ¼ : MeasureTheory.FiniteMeasure Î©\nA : Set Î©\nâŠ¢ Eq (â†‘(Î¼.restrict A)) ((â†‘Î¼).restrict A)","decl":"theorem restrict_measure_eq (Î¼ : FiniteMeasure Î©) (A : Set Î©) :\n    (Î¼.restrict A : Measure Î©) = (Î¼ : Measure Î©).restrict A := rfl\n\n"}
{"name":"MeasureTheory.FiniteMeasure.restrict_apply_measure","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœ : MeasurableSpace Î©\nÎ¼ : MeasureTheory.FiniteMeasure Î©\nA s : Set Î©\ns_mble : MeasurableSet s\nâŠ¢ Eq (â†‘(Î¼.restrict A) s) (â†‘Î¼ (Inter.inter s A))","decl":"theorem restrict_apply_measure (Î¼ : FiniteMeasure Î©) (A : Set Î©) {s : Set Î©}\n    (s_mble : MeasurableSet s) : (Î¼.restrict A : Measure Î©) s = (Î¼ : Measure Î©) (s âˆ© A) :=\n  Measure.restrict_apply s_mble\n\n"}
{"name":"MeasureTheory.FiniteMeasure.restrict_apply","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœ : MeasurableSpace Î©\nÎ¼ : MeasureTheory.FiniteMeasure Î©\nA s : Set Î©\ns_mble : MeasurableSet s\nâŠ¢ Eq ((Î¼.restrict A) s) (Î¼ (Inter.inter s A))","decl":"theorem restrict_apply (Î¼ : FiniteMeasure Î©) (A : Set Î©) {s : Set Î©} (s_mble : MeasurableSet s) :\n    (Î¼.restrict A) s = Î¼ (s âˆ© A) := by\n  apply congr_arg ENNReal.toNNReal\n  exact Measure.restrict_apply s_mble\n\n"}
{"name":"MeasureTheory.FiniteMeasure.restrict_mass","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœ : MeasurableSpace Î©\nÎ¼ : MeasureTheory.FiniteMeasure Î©\nA : Set Î©\nâŠ¢ Eq (Î¼.restrict A).mass (Î¼ A)","decl":"theorem restrict_mass (Î¼ : FiniteMeasure Î©) (A : Set Î©) : (Î¼.restrict A).mass = Î¼ A := by\n  simp only [mass, restrict_apply Î¼ A MeasurableSet.univ, univ_inter]\n\n"}
{"name":"MeasureTheory.FiniteMeasure.restrict_eq_zero_iff","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœ : MeasurableSpace Î©\nÎ¼ : MeasureTheory.FiniteMeasure Î©\nA : Set Î©\nâŠ¢ Iff (Eq (Î¼.restrict A) 0) (Eq (Î¼ A) 0)","decl":"theorem restrict_eq_zero_iff (Î¼ : FiniteMeasure Î©) (A : Set Î©) : Î¼.restrict A = 0 â†” Î¼ A = 0 := by\n  rw [â† mass_zero_iff, restrict_mass]\n\n"}
{"name":"MeasureTheory.FiniteMeasure.restrict_nonzero_iff","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœ : MeasurableSpace Î©\nÎ¼ : MeasureTheory.FiniteMeasure Î©\nA : Set Î©\nâŠ¢ Iff (Ne (Î¼.restrict A) 0) (Ne (Î¼ A) 0)","decl":"theorem restrict_nonzero_iff (Î¼ : FiniteMeasure Î©) (A : Set Î©) : Î¼.restrict A â‰  0 â†” Î¼ A â‰  0 := by\n  rw [â† mass_nonzero_iff, restrict_mass]\n\n"}
{"name":"MeasureTheory.FiniteMeasure.ext_of_forall_lintegral_eq","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœÂ³ : MeasurableSpace Î©\ninstâœÂ² : TopologicalSpace Î©\ninstâœÂ¹ : HasOuterApproxClosed Î©\ninstâœ : BorelSpace Î©\nÎ¼ Î½ : MeasureTheory.FiniteMeasure Î©\nh : âˆ€ (f : BoundedContinuousFunction Î© NNReal), Eq (MeasureTheory.lintegral â†‘Î¼ fun x => â†‘(f x)) (MeasureTheory.lintegral â†‘Î½ fun x => â†‘(f x))\nâŠ¢ Eq Î¼ Î½","decl":"/-- Two finite Borel measures are equal if the integrals of all bounded continuous functions with\nrespect to both agree. -/\ntheorem ext_of_forall_lintegral_eq [HasOuterApproxClosed Î©] [BorelSpace Î©]\n    {Î¼ Î½ : FiniteMeasure Î©} (h : âˆ€ (f : Î© â†’áµ‡ â„â‰¥0), âˆ«â» x, f x âˆ‚Î¼ = âˆ«â» x, f x âˆ‚Î½) :\n    Î¼ = Î½ := by\n  apply Subtype.ext\n  change (Î¼ : Measure Î©) = (Î½ : Measure Î©)\n  exact ext_of_forall_lintegral_eq_of_IsFiniteMeasure h\n\n"}
{"name":"MeasureTheory.FiniteMeasure.testAgainstNN_coe_eq","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœÂ¹ : MeasurableSpace Î©\ninstâœ : TopologicalSpace Î©\nÎ¼ : MeasureTheory.FiniteMeasure Î©\nf : BoundedContinuousFunction Î© NNReal\nâŠ¢ Eq (â†‘(Î¼.testAgainstNN f)) (MeasureTheory.lintegral â†‘Î¼ fun Ï‰ => â†‘(f Ï‰))","decl":"@[simp]\ntheorem testAgainstNN_coe_eq {Î¼ : FiniteMeasure Î©} {f : Î© â†’áµ‡ â„â‰¥0} :\n    (Î¼.testAgainstNN f : â„â‰¥0âˆ) = âˆ«â» Ï‰, f Ï‰ âˆ‚(Î¼ : Measure Î©) :=\n  ENNReal.coe_toNNReal (f.lintegral_lt_top_of_nnreal _).ne\n\n"}
{"name":"MeasureTheory.FiniteMeasure.testAgainstNN_const","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœÂ¹ : MeasurableSpace Î©\ninstâœ : TopologicalSpace Î©\nÎ¼ : MeasureTheory.FiniteMeasure Î©\nc : NNReal\nâŠ¢ Eq (Î¼.testAgainstNN (BoundedContinuousFunction.const Î© c)) (HMul.hMul c Î¼.mass)","decl":"theorem testAgainstNN_const (Î¼ : FiniteMeasure Î©) (c : â„â‰¥0) :\n    Î¼.testAgainstNN (BoundedContinuousFunction.const Î© c) = c * Î¼.mass := by\n  simp [â† ENNReal.coe_inj]\n\n"}
{"name":"MeasureTheory.FiniteMeasure.testAgainstNN_mono","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœÂ¹ : MeasurableSpace Î©\ninstâœ : TopologicalSpace Î©\nÎ¼ : MeasureTheory.FiniteMeasure Î©\nf g : BoundedContinuousFunction Î© NNReal\nf_le_g : LE.le â‡‘f â‡‘g\nâŠ¢ LE.le (Î¼.testAgainstNN f) (Î¼.testAgainstNN g)","decl":"theorem testAgainstNN_mono (Î¼ : FiniteMeasure Î©) {f g : Î© â†’áµ‡ â„â‰¥0} (f_le_g : (f : Î© â†’ â„â‰¥0) â‰¤ g) :\n    Î¼.testAgainstNN f â‰¤ Î¼.testAgainstNN g := by\n  simp only [â† ENNReal.coe_le_coe, testAgainstNN_coe_eq]\n  gcongr\n  apply f_le_g\n\n"}
{"name":"MeasureTheory.FiniteMeasure.testAgainstNN_zero","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœÂ¹ : MeasurableSpace Î©\ninstâœ : TopologicalSpace Î©\nÎ¼ : MeasureTheory.FiniteMeasure Î©\nâŠ¢ Eq (Î¼.testAgainstNN 0) 0","decl":"@[simp]\ntheorem testAgainstNN_zero (Î¼ : FiniteMeasure Î©) : Î¼.testAgainstNN 0 = 0 := by\n  simpa only [zero_mul] using Î¼.testAgainstNN_const 0\n\n"}
{"name":"MeasureTheory.FiniteMeasure.testAgainstNN_one","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœÂ¹ : MeasurableSpace Î©\ninstâœ : TopologicalSpace Î©\nÎ¼ : MeasureTheory.FiniteMeasure Î©\nâŠ¢ Eq (Î¼.testAgainstNN 1) Î¼.mass","decl":"@[simp]\ntheorem testAgainstNN_one (Î¼ : FiniteMeasure Î©) : Î¼.testAgainstNN 1 = Î¼.mass := by\n  simp only [testAgainstNN, coe_one, Pi.one_apply, ENNReal.coe_one, lintegral_one]\n  rfl\n\n"}
{"name":"MeasureTheory.FiniteMeasure.zero_testAgainstNN_apply","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœÂ¹ : MeasurableSpace Î©\ninstâœ : TopologicalSpace Î©\nf : BoundedContinuousFunction Î© NNReal\nâŠ¢ Eq (MeasureTheory.FiniteMeasure.testAgainstNN 0 f) 0","decl":"@[simp]\ntheorem zero_testAgainstNN_apply (f : Î© â†’áµ‡ â„â‰¥0) : (0 : FiniteMeasure Î©).testAgainstNN f = 0 := by\n  simp only [testAgainstNN, toMeasure_zero, lintegral_zero_measure, ENNReal.zero_toNNReal]\n\n"}
{"name":"MeasureTheory.FiniteMeasure.zero_testAgainstNN","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœÂ¹ : MeasurableSpace Î©\ninstâœ : TopologicalSpace Î©\nâŠ¢ Eq (MeasureTheory.FiniteMeasure.testAgainstNN 0) 0","decl":"theorem zero_testAgainstNN : (0 : FiniteMeasure Î©).testAgainstNN = 0 := by\n  funext\n  simp only [zero_testAgainstNN_apply, Pi.zero_apply]\n\n"}
{"name":"MeasureTheory.FiniteMeasure.smul_testAgainstNN_apply","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœÂ¹ : MeasurableSpace Î©\ninstâœ : TopologicalSpace Î©\nc : NNReal\nÎ¼ : MeasureTheory.FiniteMeasure Î©\nf : BoundedContinuousFunction Î© NNReal\nâŠ¢ Eq ((HSMul.hSMul c Î¼).testAgainstNN f) (HSMul.hSMul c (Î¼.testAgainstNN f))","decl":"@[simp]\ntheorem smul_testAgainstNN_apply (c : â„â‰¥0) (Î¼ : FiniteMeasure Î©) (f : Î© â†’áµ‡ â„â‰¥0) :\n    (c â€¢ Î¼).testAgainstNN f = c â€¢ Î¼.testAgainstNN f := by\n  simp only [testAgainstNN, toMeasure_smul, smul_eq_mul, â† ENNReal.smul_toNNReal, ENNReal.smul_def,\n    lintegral_smul_measure]\n\n"}
{"name":"MeasureTheory.FiniteMeasure.testAgainstNN_add","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœÂ² : MeasurableSpace Î©\ninstâœÂ¹ : TopologicalSpace Î©\ninstâœ : OpensMeasurableSpace Î©\nÎ¼ : MeasureTheory.FiniteMeasure Î©\nfâ‚ fâ‚‚ : BoundedContinuousFunction Î© NNReal\nâŠ¢ Eq (Î¼.testAgainstNN (HAdd.hAdd fâ‚ fâ‚‚)) (HAdd.hAdd (Î¼.testAgainstNN fâ‚) (Î¼.testAgainstNN fâ‚‚))","decl":"theorem testAgainstNN_add (Î¼ : FiniteMeasure Î©) (fâ‚ fâ‚‚ : Î© â†’áµ‡ â„â‰¥0) :\n    Î¼.testAgainstNN (fâ‚ + fâ‚‚) = Î¼.testAgainstNN fâ‚ + Î¼.testAgainstNN fâ‚‚ := by\n  simp only [â† ENNReal.coe_inj, BoundedContinuousFunction.coe_add, ENNReal.coe_add, Pi.add_apply,\n    testAgainstNN_coe_eq]\n  exact lintegral_add_left (BoundedContinuousFunction.measurable_coe_ennreal_comp _) _\n\n"}
{"name":"MeasureTheory.FiniteMeasure.testAgainstNN_smul","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœÂ¹â° : MeasurableSpace Î©\nR : Type u_2\ninstâœâ¹ : SMul R NNReal\ninstâœâ¸ : SMul R ENNReal\ninstâœâ· : IsScalarTower R NNReal ENNReal\ninstâœâ¶ : IsScalarTower R ENNReal ENNReal\ninstâœâµ : TopologicalSpace Î©\ninstâœâ´ : OpensMeasurableSpace Î©\ninstâœÂ³ : IsScalarTower R NNReal NNReal\ninstâœÂ² : PseudoMetricSpace R\ninstâœÂ¹ : Zero R\ninstâœ : BoundedSMul R NNReal\nÎ¼ : MeasureTheory.FiniteMeasure Î©\nc : R\nf : BoundedContinuousFunction Î© NNReal\nâŠ¢ Eq (Î¼.testAgainstNN (HSMul.hSMul c f)) (HSMul.hSMul c (Î¼.testAgainstNN f))","decl":"theorem testAgainstNN_smul [IsScalarTower R â„â‰¥0 â„â‰¥0] [PseudoMetricSpace R] [Zero R]\n    [BoundedSMul R â„â‰¥0] (Î¼ : FiniteMeasure Î©) (c : R) (f : Î© â†’áµ‡ â„â‰¥0) :\n    Î¼.testAgainstNN (c â€¢ f) = c â€¢ Î¼.testAgainstNN f := by\n  simp only [â† ENNReal.coe_inj, BoundedContinuousFunction.coe_smul, testAgainstNN_coe_eq,\n    ENNReal.coe_smul]\n  simp_rw [â† smul_one_smul â„â‰¥0âˆ c (f _ : â„â‰¥0âˆ), â† smul_one_smul â„â‰¥0âˆ c (lintegral _ _ : â„â‰¥0âˆ),\n    smul_eq_mul]\n  exact lintegral_const_mul (c â€¢ (1 : â„â‰¥0âˆ)) f.measurable_coe_ennreal_comp\n\n"}
{"name":"MeasureTheory.FiniteMeasure.testAgainstNN_lipschitz_estimate","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœÂ² : MeasurableSpace Î©\ninstâœÂ¹ : TopologicalSpace Î©\ninstâœ : OpensMeasurableSpace Î©\nÎ¼ : MeasureTheory.FiniteMeasure Î©\nf g : BoundedContinuousFunction Î© NNReal\nâŠ¢ LE.le (Î¼.testAgainstNN f) (HAdd.hAdd (Î¼.testAgainstNN g) (HMul.hMul (NNDist.nndist f g) Î¼.mass))","decl":"theorem testAgainstNN_lipschitz_estimate (Î¼ : FiniteMeasure Î©) (f g : Î© â†’áµ‡ â„â‰¥0) :\n    Î¼.testAgainstNN f â‰¤ Î¼.testAgainstNN g + nndist f g * Î¼.mass := by\n  simp only [â† Î¼.testAgainstNN_const (nndist f g), â† testAgainstNN_add, â† ENNReal.coe_le_coe,\n    BoundedContinuousFunction.coe_add, const_apply, ENNReal.coe_add, Pi.add_apply,\n    coe_nnreal_ennreal_nndist, testAgainstNN_coe_eq]\n  apply lintegral_mono\n  have le_dist : âˆ€ Ï‰, dist (f Ï‰) (g Ï‰) â‰¤ nndist f g := BoundedContinuousFunction.dist_coe_le_dist\n  intro Ï‰\n  have le' : f Ï‰ â‰¤ g Ï‰ + nndist f g := by\n    calc f Ï‰\n     _ â‰¤ g Ï‰ + nndist (f Ï‰) (g Ï‰)     := NNReal.le_add_nndist (f Ï‰) (g Ï‰)\n     _ â‰¤ g Ï‰ + nndist f g             := (add_le_add_iff_left (g Ï‰)).mpr (le_dist Ï‰)\n  have le : (f Ï‰ : â„â‰¥0âˆ) â‰¤ (g Ï‰ : â„â‰¥0âˆ) + nndist f g := by\n    simpa only [â† ENNReal.coe_add] using (by exact_mod_cast le')\n  rwa [coe_nnreal_ennreal_nndist] at le\n\n"}
{"name":"MeasureTheory.FiniteMeasure.testAgainstNN_lipschitz","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœÂ² : MeasurableSpace Î©\ninstâœÂ¹ : TopologicalSpace Î©\ninstâœ : OpensMeasurableSpace Î©\nÎ¼ : MeasureTheory.FiniteMeasure Î©\nâŠ¢ LipschitzWith Î¼.mass fun f => Î¼.testAgainstNN f","decl":"theorem testAgainstNN_lipschitz (Î¼ : FiniteMeasure Î©) :\n    LipschitzWith Î¼.mass fun f : Î© â†’áµ‡ â„â‰¥0 â†¦ Î¼.testAgainstNN f := by\n  rw [lipschitzWith_iff_dist_le_mul]\n  intro fâ‚ fâ‚‚\n  suffices abs (Î¼.testAgainstNN fâ‚ - Î¼.testAgainstNN fâ‚‚ : â„) â‰¤ Î¼.mass * dist fâ‚ fâ‚‚ by\n    rwa [NNReal.dist_eq]\n  apply abs_le.mpr\n  constructor\n  Â· have key := Î¼.testAgainstNN_lipschitz_estimate fâ‚‚ fâ‚\n    rw [mul_comm] at key\n    suffices â†‘(Î¼.testAgainstNN fâ‚‚) â‰¤ â†‘(Î¼.testAgainstNN fâ‚) + â†‘Î¼.mass * dist fâ‚ fâ‚‚ by linarith\n    simpa [nndist_comm] using NNReal.coe_mono key\n  Â· have key := Î¼.testAgainstNN_lipschitz_estimate fâ‚ fâ‚‚\n    rw [mul_comm] at key\n    suffices â†‘(Î¼.testAgainstNN fâ‚) â‰¤ â†‘(Î¼.testAgainstNN fâ‚‚) + â†‘Î¼.mass * dist fâ‚ fâ‚‚ by linarith\n    simpa using NNReal.coe_mono key\n\n"}
{"name":"MeasureTheory.FiniteMeasure.coe_toWeakDualBCNN","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœÂ² : MeasurableSpace Î©\ninstâœÂ¹ : TopologicalSpace Î©\ninstâœ : OpensMeasurableSpace Î©\nÎ¼ : MeasureTheory.FiniteMeasure Î©\nâŠ¢ Eq (â‡‘Î¼.toWeakDualBCNN) Î¼.testAgainstNN","decl":"@[simp]\ntheorem coe_toWeakDualBCNN (Î¼ : FiniteMeasure Î©) : â‡‘Î¼.toWeakDualBCNN = Î¼.testAgainstNN :=\n  rfl\n\n"}
{"name":"MeasureTheory.FiniteMeasure.toWeakDualBCNN_apply","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœÂ² : MeasurableSpace Î©\ninstâœÂ¹ : TopologicalSpace Î©\ninstâœ : OpensMeasurableSpace Î©\nÎ¼ : MeasureTheory.FiniteMeasure Î©\nf : BoundedContinuousFunction Î© NNReal\nâŠ¢ Eq (Î¼.toWeakDualBCNN f) (MeasureTheory.lintegral â†‘Î¼ fun x => â†‘(f x)).toNNReal","decl":"@[simp]\ntheorem toWeakDualBCNN_apply (Î¼ : FiniteMeasure Î©) (f : Î© â†’áµ‡ â„â‰¥0) :\n    Î¼.toWeakDualBCNN f = (âˆ«â» x, f x âˆ‚(Î¼ : Measure Î©)).toNNReal := rfl\n\n"}
{"name":"MeasureTheory.FiniteMeasure.toWeakDualBCNN_continuous","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœÂ² : MeasurableSpace Î©\ninstâœÂ¹ : TopologicalSpace Î©\ninstâœ : OpensMeasurableSpace Î©\nâŠ¢ Continuous MeasureTheory.FiniteMeasure.toWeakDualBCNN","decl":"theorem toWeakDualBCNN_continuous : Continuous (@toWeakDualBCNN Î© _ _ _) :=\n  continuous_induced_dom\n\n"}
{"name":"MeasureTheory.FiniteMeasure.continuous_testAgainstNN_eval","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœÂ² : MeasurableSpace Î©\ninstâœÂ¹ : TopologicalSpace Î©\ninstâœ : OpensMeasurableSpace Î©\nf : BoundedContinuousFunction Î© NNReal\nâŠ¢ Continuous fun Î¼ => Î¼.testAgainstNN f","decl":"/-- Integration of (nonnegative bounded continuous) test functions against finite Borel measures\ndepends continuously on the measure. -/\ntheorem continuous_testAgainstNN_eval (f : Î© â†’áµ‡ â„â‰¥0) :\n    Continuous fun Î¼ : FiniteMeasure Î© â†¦ Î¼.testAgainstNN f := by\n  show Continuous ((fun Ï† : WeakDual â„â‰¥0 (Î© â†’áµ‡ â„â‰¥0) â†¦ Ï† f) âˆ˜ toWeakDualBCNN)\n  refine Continuous.comp ?_ (toWeakDualBCNN_continuous (Î© := Î©))\n  exact WeakBilin.eval_continuous _ _\n\n"}
{"name":"MeasureTheory.FiniteMeasure.continuous_mass","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœÂ² : MeasurableSpace Î©\ninstâœÂ¹ : TopologicalSpace Î©\ninstâœ : OpensMeasurableSpace Î©\nâŠ¢ Continuous fun Î¼ => Î¼.mass","decl":"/-- The total mass of a finite measure depends continuously on the measure. -/\ntheorem continuous_mass : Continuous fun Î¼ : FiniteMeasure Î© â†¦ Î¼.mass := by\n  simp_rw [â† testAgainstNN_one]; exact continuous_testAgainstNN_eval 1\n\n"}
{"name":"Filter.Tendsto.mass","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœÂ² : MeasurableSpace Î©\ninstâœÂ¹ : TopologicalSpace Î©\ninstâœ : OpensMeasurableSpace Î©\nÎ³ : Type u_3\nF : Filter Î³\nÎ¼s : Î³ â†’ MeasureTheory.FiniteMeasure Î©\nÎ¼ : MeasureTheory.FiniteMeasure Î©\nh : Filter.Tendsto Î¼s F (nhds Î¼)\nâŠ¢ Filter.Tendsto (fun i => (Î¼s i).mass) F (nhds Î¼.mass)","decl":"/-- Convergence of finite measures implies the convergence of their total masses. -/\ntheorem _root_.Filter.Tendsto.mass {Î³ : Type*} {F : Filter Î³} {Î¼s : Î³ â†’ FiniteMeasure Î©}\n    {Î¼ : FiniteMeasure Î©} (h : Tendsto Î¼s F (ğ“ Î¼)) : Tendsto (fun i â†¦ (Î¼s i).mass) F (ğ“ Î¼.mass) :=\n  (continuous_mass.tendsto Î¼).comp h\n\n"}
{"name":"MeasureTheory.FiniteMeasure.tendsto_iff_weakDual_tendsto","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœÂ² : MeasurableSpace Î©\ninstâœÂ¹ : TopologicalSpace Î©\ninstâœ : OpensMeasurableSpace Î©\nÎ³ : Type u_3\nF : Filter Î³\nÎ¼s : Î³ â†’ MeasureTheory.FiniteMeasure Î©\nÎ¼ : MeasureTheory.FiniteMeasure Î©\nâŠ¢ Iff (Filter.Tendsto Î¼s F (nhds Î¼)) (Filter.Tendsto (fun i => (Î¼s i).toWeakDualBCNN) F (nhds Î¼.toWeakDualBCNN))","decl":"theorem tendsto_iff_weakDual_tendsto {Î³ : Type*} {F : Filter Î³} {Î¼s : Î³ â†’ FiniteMeasure Î©}\n    {Î¼ : FiniteMeasure Î©} :\n    Tendsto Î¼s F (ğ“ Î¼) â†” Tendsto (fun i â†¦ (Î¼s i).toWeakDualBCNN) F (ğ“ Î¼.toWeakDualBCNN) :=\n  IsInducing.tendsto_nhds_iff âŸ¨rflâŸ©\n\n"}
{"name":"MeasureTheory.FiniteMeasure.tendsto_iff_forall_toWeakDualBCNN_tendsto","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœÂ² : MeasurableSpace Î©\ninstâœÂ¹ : TopologicalSpace Î©\ninstâœ : OpensMeasurableSpace Î©\nÎ³ : Type u_3\nF : Filter Î³\nÎ¼s : Î³ â†’ MeasureTheory.FiniteMeasure Î©\nÎ¼ : MeasureTheory.FiniteMeasure Î©\nâŠ¢ Iff (Filter.Tendsto Î¼s F (nhds Î¼)) (âˆ€ (f : BoundedContinuousFunction Î© NNReal), Filter.Tendsto (fun i => (Î¼s i).toWeakDualBCNN f) F (nhds (Î¼.toWeakDualBCNN f)))","decl":"theorem tendsto_iff_forall_toWeakDualBCNN_tendsto {Î³ : Type*} {F : Filter Î³}\n    {Î¼s : Î³ â†’ FiniteMeasure Î©} {Î¼ : FiniteMeasure Î©} :\n    Tendsto Î¼s F (ğ“ Î¼) â†”\n      âˆ€ f : Î© â†’áµ‡ â„â‰¥0, Tendsto (fun i â†¦ (Î¼s i).toWeakDualBCNN f) F (ğ“ (Î¼.toWeakDualBCNN f)) := by\n  rw [tendsto_iff_weakDual_tendsto, tendsto_iff_forall_eval_tendsto_topDualPairing]; rfl\n\n"}
{"name":"MeasureTheory.FiniteMeasure.tendsto_iff_forall_testAgainstNN_tendsto","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœÂ² : MeasurableSpace Î©\ninstâœÂ¹ : TopologicalSpace Î©\ninstâœ : OpensMeasurableSpace Î©\nÎ³ : Type u_3\nF : Filter Î³\nÎ¼s : Î³ â†’ MeasureTheory.FiniteMeasure Î©\nÎ¼ : MeasureTheory.FiniteMeasure Î©\nâŠ¢ Iff (Filter.Tendsto Î¼s F (nhds Î¼)) (âˆ€ (f : BoundedContinuousFunction Î© NNReal), Filter.Tendsto (fun i => (Î¼s i).testAgainstNN f) F (nhds (Î¼.testAgainstNN f)))","decl":"theorem tendsto_iff_forall_testAgainstNN_tendsto {Î³ : Type*} {F : Filter Î³}\n    {Î¼s : Î³ â†’ FiniteMeasure Î©} {Î¼ : FiniteMeasure Î©} :\n    Tendsto Î¼s F (ğ“ Î¼) â†”\n      âˆ€ f : Î© â†’áµ‡ â„â‰¥0, Tendsto (fun i â†¦ (Î¼s i).testAgainstNN f) F (ğ“ (Î¼.testAgainstNN f)) := by\n  rw [FiniteMeasure.tendsto_iff_forall_toWeakDualBCNN_tendsto]; rfl\n\n"}
{"name":"MeasureTheory.FiniteMeasure.tendsto_zero_testAgainstNN_of_tendsto_zero_mass","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœÂ² : MeasurableSpace Î©\ninstâœÂ¹ : TopologicalSpace Î©\ninstâœ : OpensMeasurableSpace Î©\nÎ³ : Type u_3\nF : Filter Î³\nÎ¼s : Î³ â†’ MeasureTheory.FiniteMeasure Î©\nmass_lim : Filter.Tendsto (fun i => (Î¼s i).mass) F (nhds 0)\nf : BoundedContinuousFunction Î© NNReal\nâŠ¢ Filter.Tendsto (fun i => (Î¼s i).testAgainstNN f) F (nhds 0)","decl":"/-- If the total masses of finite measures tend to zero, then the measures tend to\nzero. This formulation concerns the associated functionals on bounded continuous\nnonnegative test functions. See `MeasureTheory.FiniteMeasure.tendsto_zero_of_tendsto_zero_mass` for\na formulation stating the weak convergence of measures. -/\ntheorem tendsto_zero_testAgainstNN_of_tendsto_zero_mass {Î³ : Type*} {F : Filter Î³}\n    {Î¼s : Î³ â†’ FiniteMeasure Î©} (mass_lim : Tendsto (fun i â†¦ (Î¼s i).mass) F (ğ“ 0)) (f : Î© â†’áµ‡ â„â‰¥0) :\n    Tendsto (fun i â†¦ (Î¼s i).testAgainstNN f) F (ğ“ 0) := by\n  apply tendsto_iff_dist_tendsto_zero.mpr\n  have obs := fun i â†¦ (Î¼s i).testAgainstNN_lipschitz_estimate f 0\n  simp_rw [testAgainstNN_zero, zero_add] at obs\n  simp_rw [show âˆ€ i, dist ((Î¼s i).testAgainstNN f) 0 = (Î¼s i).testAgainstNN f by\n      simp only [dist_nndist, NNReal.nndist_zero_eq_val', eq_self_iff_true, imp_true_iff]]\n  apply squeeze_zero (fun i â†¦ NNReal.coe_nonneg _) obs\n  have lim_pair : Tendsto (fun i â†¦ (âŸ¨nndist f 0, (Î¼s i).massâŸ© : â„ Ã— â„)) F (ğ“ âŸ¨nndist f 0, 0âŸ©) :=\n    (Prod.tendsto_iff _ _).mpr âŸ¨tendsto_const_nhds, (NNReal.continuous_coe.tendsto 0).comp mass_limâŸ©\n  simpa using tendsto_mul.comp lim_pair\n\n"}
{"name":"MeasureTheory.FiniteMeasure.tendsto_zero_of_tendsto_zero_mass","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœÂ² : MeasurableSpace Î©\ninstâœÂ¹ : TopologicalSpace Î©\ninstâœ : OpensMeasurableSpace Î©\nÎ³ : Type u_3\nF : Filter Î³\nÎ¼s : Î³ â†’ MeasureTheory.FiniteMeasure Î©\nmass_lim : Filter.Tendsto (fun i => (Î¼s i).mass) F (nhds 0)\nâŠ¢ Filter.Tendsto Î¼s F (nhds 0)","decl":"/-- If the total masses of finite measures tend to zero, then the measures tend to zero. -/\ntheorem tendsto_zero_of_tendsto_zero_mass {Î³ : Type*} {F : Filter Î³} {Î¼s : Î³ â†’ FiniteMeasure Î©}\n    (mass_lim : Tendsto (fun i â†¦ (Î¼s i).mass) F (ğ“ 0)) : Tendsto Î¼s F (ğ“ 0) := by\n  rw [tendsto_iff_forall_testAgainstNN_tendsto]\n  intro f\n  convert tendsto_zero_testAgainstNN_of_tendsto_zero_mass mass_lim f\n  rw [zero_testAgainstNN_apply]\n\n"}
{"name":"MeasureTheory.FiniteMeasure.tendsto_iff_forall_lintegral_tendsto","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœÂ² : MeasurableSpace Î©\ninstâœÂ¹ : TopologicalSpace Î©\ninstâœ : OpensMeasurableSpace Î©\nÎ³ : Type u_3\nF : Filter Î³\nÎ¼s : Î³ â†’ MeasureTheory.FiniteMeasure Î©\nÎ¼ : MeasureTheory.FiniteMeasure Î©\nâŠ¢ Iff (Filter.Tendsto Î¼s F (nhds Î¼)) (âˆ€ (f : BoundedContinuousFunction Î© NNReal), Filter.Tendsto (fun i => MeasureTheory.lintegral â†‘(Î¼s i) fun x => â†‘(f x)) F (nhds (MeasureTheory.lintegral â†‘Î¼ fun x => â†‘(f x))))","decl":"/-- A characterization of weak convergence in terms of integrals of bounded continuous\nnonnegative functions. -/\ntheorem tendsto_iff_forall_lintegral_tendsto {Î³ : Type*} {F : Filter Î³} {Î¼s : Î³ â†’ FiniteMeasure Î©}\n    {Î¼ : FiniteMeasure Î©} :\n    Tendsto Î¼s F (ğ“ Î¼) â†”\n      âˆ€ f : Î© â†’áµ‡ â„â‰¥0,\n        Tendsto (fun i â†¦ âˆ«â» x, f x âˆ‚(Î¼s i : Measure Î©)) F (ğ“ (âˆ«â» x, f x âˆ‚(Î¼ : Measure Î©))) := by\n  rw [tendsto_iff_forall_toWeakDualBCNN_tendsto]\n  simp_rw [toWeakDualBCNN_apply _ _, â† testAgainstNN_coe_eq, ENNReal.tendsto_coe,\n    ENNReal.toNNReal_coe]\n\n"}
{"name":"MeasureTheory.FiniteMeasure.injective_toWeakDualBCNN","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœÂ³ : MeasurableSpace Î©\ninstâœÂ² : TopologicalSpace Î©\ninstâœÂ¹ : HasOuterApproxClosed Î©\ninstâœ : BorelSpace Î©\nâŠ¢ Function.Injective MeasureTheory.FiniteMeasure.toWeakDualBCNN","decl":"/-- The mapping `toWeakDualBCNN` from finite Borel measures to the weak dual of `Î© â†’áµ‡ â„â‰¥0` is\ninjective, if in the underlying space `Î©`, indicator functions of closed sets have decreasing\napproximations by sequences of continuous functions (in particular if `Î©` is pseudometrizable). -/\nlemma injective_toWeakDualBCNN :\n    Injective (toWeakDualBCNN : FiniteMeasure Î© â†’ WeakDual â„â‰¥0 (Î© â†’áµ‡ â„â‰¥0)) := by\n  intro Î¼ Î½ hÎ¼Î½\n  apply ext_of_forall_lintegral_eq\n  intro f\n  have key := congr_fun (congrArg DFunLike.coe hÎ¼Î½) f\n  apply (ENNReal.toNNReal_eq_toNNReal_iff' ?_ ?_).mp key\n  Â· exact (lintegral_lt_top_of_nnreal Î¼ f).ne\n  Â· exact (lintegral_lt_top_of_nnreal Î½ f).ne\n\n"}
{"name":"MeasureTheory.FiniteMeasure.isEmbedding_toWeakDualBCNN","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœÂ³ : MeasurableSpace Î©\ninstâœÂ² : TopologicalSpace Î©\ninstâœÂ¹ : HasOuterApproxClosed Î©\ninstâœ : BorelSpace Î©\nâŠ¢ Topology.IsEmbedding MeasureTheory.FiniteMeasure.toWeakDualBCNN","decl":"lemma isEmbedding_toWeakDualBCNN :\n    IsEmbedding (toWeakDualBCNN : FiniteMeasure Î© â†’ WeakDual â„â‰¥0 (Î© â†’áµ‡ â„â‰¥0)) where\n  eq_induced := rfl\n  injective := injective_toWeakDualBCNN\n\n"}
{"name":"MeasureTheory.FiniteMeasure.embedding_toWeakDualBCNN","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœÂ³ : MeasurableSpace Î©\ninstâœÂ² : TopologicalSpace Î©\ninstâœÂ¹ : HasOuterApproxClosed Î©\ninstâœ : BorelSpace Î©\nâŠ¢ Topology.IsEmbedding MeasureTheory.FiniteMeasure.toWeakDualBCNN","decl":"@[deprecated (since := \"2024-10-26\")]\nalias embedding_toWeakDualBCNN := isEmbedding_toWeakDualBCNN\n\n"}
{"name":"MeasureTheory.FiniteMeasure.t2Space","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœÂ³ : MeasurableSpace Î©\ninstâœÂ² : TopologicalSpace Î©\ninstâœÂ¹ : HasOuterApproxClosed Î©\ninstâœ : BorelSpace Î©\nâŠ¢ T2Space (MeasureTheory.FiniteMeasure Î©)","decl":"/-- On topological spaces where indicators of closed sets have decreasing approximating sequences of\ncontinuous functions (`HasOuterApproxClosed`), the topology of weak convergence of finite Borel\nmeasures is Hausdorff (`T2Space`). -/\ninstance t2Space : T2Space (FiniteMeasure Î©) := (isEmbedding_toWeakDualBCNN Î©).t2Space\n\n"}
{"name":"MeasureTheory.FiniteMeasure.tendsto_lintegral_nn_of_le_const","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœÂ² : MeasurableSpace Î©\ninstâœÂ¹ : TopologicalSpace Î©\ninstâœ : OpensMeasurableSpace Î©\nÎ¼ : MeasureTheory.FiniteMeasure Î©\nfs : Nat â†’ BoundedContinuousFunction Î© NNReal\nc : NNReal\nfs_le_const : âˆ€ (n : Nat) (Ï‰ : Î©), LE.le ((fs n) Ï‰) c\nf : Î© â†’ NNReal\nfs_lim : âˆ€ (Ï‰ : Î©), Filter.Tendsto (fun n => (fs n) Ï‰) Filter.atTop (nhds (f Ï‰))\nâŠ¢ Filter.Tendsto (fun n => MeasureTheory.lintegral â†‘Î¼ fun Ï‰ => â†‘((fs n) Ï‰)) Filter.atTop (nhds (MeasureTheory.lintegral â†‘Î¼ fun Ï‰ => â†‘(f Ï‰)))","decl":"/-- A bounded convergence theorem for a finite measure:\nIf a sequence of bounded continuous non-negative functions are uniformly bounded by a constant\nand tend pointwise to a limit, then their integrals (`MeasureTheory.lintegral`) against the finite\nmeasure tend to the integral of the limit.\n\nA related result with more general assumptions is\n`MeasureTheory.tendsto_lintegral_nn_filter_of_le_const`.\n-/\ntheorem tendsto_lintegral_nn_of_le_const (Î¼ : FiniteMeasure Î©) {fs : â„• â†’ Î© â†’áµ‡ â„â‰¥0} {c : â„â‰¥0}\n    (fs_le_const : âˆ€ n Ï‰, fs n Ï‰ â‰¤ c) {f : Î© â†’ â„â‰¥0}\n    (fs_lim : âˆ€ Ï‰, Tendsto (fun n â†¦ fs n Ï‰) atTop (ğ“ (f Ï‰))) :\n    Tendsto (fun n â†¦ âˆ«â» Ï‰, fs n Ï‰ âˆ‚(Î¼ : Measure Î©)) atTop (ğ“ (âˆ«â» Ï‰, f Ï‰ âˆ‚(Î¼ : Measure Î©))) :=\n  tendsto_lintegral_nn_filter_of_le_const Î¼\n    (.of_forall fun n â†¦ .of_forall (fs_le_const n))\n    (.of_forall fs_lim)\n\n"}
{"name":"MeasureTheory.FiniteMeasure.tendsto_testAgainstNN_filter_of_le_const","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœÂ³ : MeasurableSpace Î©\ninstâœÂ² : TopologicalSpace Î©\ninstâœÂ¹ : OpensMeasurableSpace Î©\nÎ¹ : Type u_2\nL : Filter Î¹\ninstâœ : L.IsCountablyGenerated\nÎ¼ : MeasureTheory.FiniteMeasure Î©\nfs : Î¹ â†’ BoundedContinuousFunction Î© NNReal\nc : NNReal\nfs_le_const : Filter.Eventually (fun i => Filter.Eventually (fun Ï‰ => LE.le ((fs i) Ï‰) c) (MeasureTheory.ae â†‘Î¼)) L\nf : BoundedContinuousFunction Î© NNReal\nfs_lim : Filter.Eventually (fun Ï‰ => Filter.Tendsto (fun i => (fs i) Ï‰) L (nhds (f Ï‰))) (MeasureTheory.ae â†‘Î¼)\nâŠ¢ Filter.Tendsto (fun i => Î¼.testAgainstNN (fs i)) L (nhds (Î¼.testAgainstNN f))","decl":"/-- A bounded convergence theorem for a finite measure:\nIf bounded continuous non-negative functions are uniformly bounded by a constant and tend to a\nlimit, then their integrals against the finite measure tend to the integral of the limit.\nThis formulation assumes:\n * the functions tend to a limit along a countably generated filter;\n * the limit is in the almost everywhere sense;\n * boundedness holds almost everywhere;\n * integration is the pairing against non-negative continuous test functions\n   (`MeasureTheory.FiniteMeasure.testAgainstNN`).\n\nA related result using `MeasureTheory.lintegral` for integration is\n`MeasureTheory.FiniteMeasure.tendsto_lintegral_nn_filter_of_le_const`.\n-/\ntheorem tendsto_testAgainstNN_filter_of_le_const {Î¹ : Type*} {L : Filter Î¹}\n    [L.IsCountablyGenerated] {Î¼ : FiniteMeasure Î©} {fs : Î¹ â†’ Î© â†’áµ‡ â„â‰¥0} {c : â„â‰¥0}\n    (fs_le_const : âˆ€á¶  i in L, âˆ€áµ Ï‰ : Î© âˆ‚(Î¼ : Measure Î©), fs i Ï‰ â‰¤ c) {f : Î© â†’áµ‡ â„â‰¥0}\n    (fs_lim : âˆ€áµ Ï‰ : Î© âˆ‚(Î¼ : Measure Î©), Tendsto (fun i â†¦ fs i Ï‰) L (ğ“ (f Ï‰))) :\n    Tendsto (fun i â†¦ Î¼.testAgainstNN (fs i)) L (ğ“ (Î¼.testAgainstNN f)) := by\n  apply (ENNReal.tendsto_toNNReal (f.lintegral_lt_top_of_nnreal (Î¼ : Measure Î©)).ne).comp\n  exact tendsto_lintegral_nn_filter_of_le_const (Î© := Î©) Î¼ fs_le_const fs_lim\n\n"}
{"name":"MeasureTheory.FiniteMeasure.tendsto_testAgainstNN_of_le_const","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœÂ² : MeasurableSpace Î©\ninstâœÂ¹ : TopologicalSpace Î©\ninstâœ : OpensMeasurableSpace Î©\nÎ¼ : MeasureTheory.FiniteMeasure Î©\nfs : Nat â†’ BoundedContinuousFunction Î© NNReal\nc : NNReal\nfs_le_const : âˆ€ (n : Nat) (Ï‰ : Î©), LE.le ((fs n) Ï‰) c\nf : BoundedContinuousFunction Î© NNReal\nfs_lim : âˆ€ (Ï‰ : Î©), Filter.Tendsto (fun n => (fs n) Ï‰) Filter.atTop (nhds (f Ï‰))\nâŠ¢ Filter.Tendsto (fun n => Î¼.testAgainstNN (fs n)) Filter.atTop (nhds (Î¼.testAgainstNN f))","decl":"/-- A bounded convergence theorem for a finite measure:\nIf a sequence of bounded continuous non-negative functions are uniformly bounded by a constant and\ntend pointwise to a limit, then their integrals (`MeasureTheory.FiniteMeasure.testAgainstNN`)\nagainst the finite measure tend to the integral of the limit.\n\nRelated results:\n * `MeasureTheory.FiniteMeasure.tendsto_testAgainstNN_filter_of_le_const`:\n   more general assumptions\n * `MeasureTheory.FiniteMeasure.tendsto_lintegral_nn_of_le_const`:\n   using `MeasureTheory.lintegral` for integration.\n-/\ntheorem tendsto_testAgainstNN_of_le_const {Î¼ : FiniteMeasure Î©} {fs : â„• â†’ Î© â†’áµ‡ â„â‰¥0} {c : â„â‰¥0}\n    (fs_le_const : âˆ€ n Ï‰, fs n Ï‰ â‰¤ c) {f : Î© â†’áµ‡ â„â‰¥0}\n    (fs_lim : âˆ€ Ï‰, Tendsto (fun n â†¦ fs n Ï‰) atTop (ğ“ (f Ï‰))) :\n    Tendsto (fun n â†¦ Î¼.testAgainstNN (fs n)) atTop (ğ“ (Î¼.testAgainstNN f)) :=\n  tendsto_testAgainstNN_filter_of_le_const\n    (.of_forall fun n â†¦ .of_forall (fs_le_const n))\n    (.of_forall fs_lim)\n\n"}
{"name":"MeasureTheory.FiniteMeasure.tendsto_of_forall_integral_tendsto","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœÂ² : MeasurableSpace Î©\ninstâœÂ¹ : TopologicalSpace Î©\ninstâœ : OpensMeasurableSpace Î©\nÎ³ : Type u_2\nF : Filter Î³\nÎ¼s : Î³ â†’ MeasureTheory.FiniteMeasure Î©\nÎ¼ : MeasureTheory.FiniteMeasure Î©\nh : âˆ€ (f : BoundedContinuousFunction Î© Real), Filter.Tendsto (fun i => MeasureTheory.integral â†‘(Î¼s i) fun x => f x) F (nhds (MeasureTheory.integral â†‘Î¼ fun x => f x))\nâŠ¢ Filter.Tendsto Î¼s F (nhds Î¼)","decl":"theorem tendsto_of_forall_integral_tendsto {Î³ : Type*} {F : Filter Î³} {Î¼s : Î³ â†’ FiniteMeasure Î©}\n    {Î¼ : FiniteMeasure Î©}\n    (h : âˆ€ f : Î© â†’áµ‡ â„,\n          Tendsto (fun i â†¦ âˆ« x, f x âˆ‚(Î¼s i : Measure Î©)) F (ğ“ (âˆ« x, f x âˆ‚(Î¼ : Measure Î©)))) :\n    Tendsto Î¼s F (ğ“ Î¼) := by\n  apply tendsto_iff_forall_lintegral_tendsto.mpr\n  intro f\n  apply (ENNReal.tendsto_toReal_iff (fi := F)\n      (fun i â†¦ (f.lintegral_lt_top_of_nnreal (Î¼s i)).ne) (f.lintegral_lt_top_of_nnreal Î¼).ne).mp\n  have lip : LipschitzWith 1 ((â†‘) : â„â‰¥0 â†’ â„) := isometry_subtype_coe.lipschitz\n  set fâ‚€ := BoundedContinuousFunction.comp _ lip f with _def_fâ‚€\n  have fâ‚€_eq : â‡‘fâ‚€ = ((â†‘) : â„â‰¥0 â†’ â„) âˆ˜ â‡‘f := rfl\n  have fâ‚€_nn : 0 â‰¤ â‡‘fâ‚€ := fun _ â†¦ by\n    simp only [fâ‚€_eq, Pi.zero_apply, Function.comp_apply, NNReal.zero_le_coe]\n  have fâ‚€_ae_nn : 0 â‰¤áµ[(Î¼ : Measure Î©)] â‡‘fâ‚€ := .of_forall fâ‚€_nn\n  have fâ‚€_ae_nns : âˆ€ i, 0 â‰¤áµ[(Î¼s i : Measure Î©)] â‡‘fâ‚€ := fun i â†¦ .of_forall fâ‚€_nn\n  have aux :=\n    integral_eq_lintegral_of_nonneg_ae fâ‚€_ae_nn fâ‚€.continuous.measurable.aestronglyMeasurable\n  have auxs := fun i â†¦\n    integral_eq_lintegral_of_nonneg_ae (fâ‚€_ae_nns i) fâ‚€.continuous.measurable.aestronglyMeasurable\n  simp_rw [fâ‚€_eq, Function.comp_apply, ENNReal.ofReal_coe_nnreal] at aux auxs\n  simpa only [â† aux, â† auxs] using h fâ‚€\n\n"}
{"name":"MeasureTheory.FiniteMeasure.tendsto_iff_forall_integral_tendsto","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\ninstâœÂ² : MeasurableSpace Î©\ninstâœÂ¹ : TopologicalSpace Î©\ninstâœ : OpensMeasurableSpace Î©\nÎ³ : Type u_2\nF : Filter Î³\nÎ¼s : Î³ â†’ MeasureTheory.FiniteMeasure Î©\nÎ¼ : MeasureTheory.FiniteMeasure Î©\nâŠ¢ Iff (Filter.Tendsto Î¼s F (nhds Î¼)) (âˆ€ (f : BoundedContinuousFunction Î© Real), Filter.Tendsto (fun i => MeasureTheory.integral â†‘(Î¼s i) fun x => f x) F (nhds (MeasureTheory.integral â†‘Î¼ fun x => f x)))","decl":"/-- A characterization of weak convergence in terms of integrals of bounded continuous\nreal-valued functions. -/\ntheorem tendsto_iff_forall_integral_tendsto {Î³ : Type*} {F : Filter Î³} {Î¼s : Î³ â†’ FiniteMeasure Î©}\n    {Î¼ : FiniteMeasure Î©} :\n    Tendsto Î¼s F (ğ“ Î¼) â†”\n      âˆ€ f : Î© â†’áµ‡ â„,\n        Tendsto (fun i â†¦ âˆ« x, f x âˆ‚(Î¼s i : Measure Î©)) F (ğ“ (âˆ« x, f x âˆ‚(Î¼ : Measure Î©))) := by\n  refine âŸ¨?_, tendsto_of_forall_integral_tendstoâŸ©\n  rw [tendsto_iff_forall_lintegral_tendsto]\n  intro h f\n  simp_rw [BoundedContinuousFunction.integral_eq_integral_nnrealPart_sub]\n  set f_pos := f.nnrealPart with _def_f_pos\n  set f_neg := (-f).nnrealPart with _def_f_neg\n  have tends_pos := (ENNReal.tendsto_toReal (f_pos.lintegral_lt_top_of_nnreal Î¼).ne).comp (h f_pos)\n  have tends_neg := (ENNReal.tendsto_toReal (f_neg.lintegral_lt_top_of_nnreal Î¼).ne).comp (h f_neg)\n  have aux :\n    âˆ€ g : Î© â†’áµ‡ â„â‰¥0,\n      (ENNReal.toReal âˆ˜ fun i : Î³ â†¦ âˆ«â» x : Î©, â†‘(g x) âˆ‚(Î¼s i : Measure Î©)) =\n        fun i : Î³ â†¦ (âˆ«â» x : Î©, â†‘(g x) âˆ‚(Î¼s i : Measure Î©)).toReal :=\n    fun _ â†¦ rfl\n  simp_rw [aux, BoundedContinuousFunction.toReal_lintegral_coe_eq_integral] at tends_pos tends_neg\n  exact Tendsto.sub tends_pos tends_neg\n\n"}
{"name":"MeasureTheory.FiniteMeasure.continuous_integral_boundedContinuousFunction","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î± : Type u_2\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : MeasurableSpace Î±\ninstâœ : OpensMeasurableSpace Î±\nf : BoundedContinuousFunction Î± Real\nâŠ¢ Continuous fun Î¼ => MeasureTheory.integral â†‘Î¼ fun x => f x","decl":"lemma continuous_integral_boundedContinuousFunction\n    {Î± : Type*} [TopologicalSpace Î±] [MeasurableSpace Î±] [OpensMeasurableSpace Î±] (f : Î± â†’áµ‡ â„) :\n    Continuous fun Î¼ : FiniteMeasure Î± â†¦ âˆ« x, f x âˆ‚Î¼ := by\n  rw [continuous_iff_continuousAt]\n  intro Î¼\n  exact continuousAt_of_tendsto_nhds\n    (FiniteMeasure.tendsto_iff_forall_integral_tendsto.mp tendsto_id f)\n\n"}
{"name":"MeasureTheory.FiniteMeasure.toMeasure_map","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\nÎ©' : Type u_2\ninstâœÂ¹ : MeasurableSpace Î©\ninstâœ : MeasurableSpace Î©'\nÎ½ : MeasureTheory.FiniteMeasure Î©\nf : Î© â†’ Î©'\nâŠ¢ Eq (â†‘(Î½.map f)) (MeasureTheory.Measure.map f â†‘Î½)","decl":"@[simp] lemma toMeasure_map (Î½ : FiniteMeasure Î©) (f : Î© â†’ Î©') :\n    (Î½.map f).toMeasure = Î½.toMeasure.map f := rfl\n\n"}
{"name":"MeasureTheory.FiniteMeasure.map_apply'","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\nÎ©' : Type u_2\ninstâœÂ¹ : MeasurableSpace Î©\ninstâœ : MeasurableSpace Î©'\nÎ½ : MeasureTheory.FiniteMeasure Î©\nf : Î© â†’ Î©'\nf_aemble : AEMeasurable f â†‘Î½\nA : Set Î©'\nA_mble : MeasurableSet A\nâŠ¢ Eq (â†‘(Î½.map f) A) (â†‘Î½ (Set.preimage f A))","decl":"/-- Note that this is an equality of elements of `â„â‰¥0âˆ`. See also\n`MeasureTheory.FiniteMeasure.map_apply` for the corresponding equality as elements of `â„â‰¥0`. -/\nlemma map_apply' (Î½ : FiniteMeasure Î©) {f : Î© â†’ Î©'} (f_aemble : AEMeasurable f Î½)\n    {A : Set Î©'} (A_mble : MeasurableSet A) :\n    (Î½.map f : Measure Î©') A = (Î½ : Measure Î©) (f â»Â¹' A) :=\n  Measure.map_apply_of_aemeasurable f_aemble A_mble\n\n"}
{"name":"MeasureTheory.FiniteMeasure.map_apply_of_aemeasurable","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\nÎ©' : Type u_2\ninstâœÂ¹ : MeasurableSpace Î©\ninstâœ : MeasurableSpace Î©'\nÎ½ : MeasureTheory.FiniteMeasure Î©\nf : Î© â†’ Î©'\nf_aemble : AEMeasurable f â†‘Î½\nA : Set Î©'\nA_mble : MeasurableSet A\nâŠ¢ Eq ((Î½.map f) A) (Î½ (Set.preimage f A))","decl":"lemma map_apply_of_aemeasurable (Î½ : FiniteMeasure Î©) {f : Î© â†’ Î©'} (f_aemble : AEMeasurable f Î½)\n    {A : Set Î©'} (A_mble : MeasurableSet A) :\n    Î½.map f A = Î½ (f â»Â¹' A) := by\n  have key := Î½.map_apply' f_aemble A_mble\n  exact (ENNReal.toNNReal_eq_toNNReal_iff' (measure_ne_top _ _) (measure_ne_top _ _)).mpr key\n\n"}
{"name":"MeasureTheory.FiniteMeasure.map_apply","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\nÎ©' : Type u_2\ninstâœÂ¹ : MeasurableSpace Î©\ninstâœ : MeasurableSpace Î©'\nÎ½ : MeasureTheory.FiniteMeasure Î©\nf : Î© â†’ Î©'\nf_mble : Measurable f\nA : Set Î©'\nA_mble : MeasurableSet A\nâŠ¢ Eq ((Î½.map f) A) (Î½ (Set.preimage f A))","decl":"lemma map_apply (Î½ : FiniteMeasure Î©) {f : Î© â†’ Î©'} (f_mble : Measurable f)\n    {A : Set Î©'} (A_mble : MeasurableSet A) :\n    Î½.map f A = Î½ (f â»Â¹' A) :=\n  map_apply_of_aemeasurable Î½ f_mble.aemeasurable A_mble\n\n"}
{"name":"MeasureTheory.FiniteMeasure.map_add","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\nÎ©' : Type u_2\ninstâœÂ¹ : MeasurableSpace Î©\ninstâœ : MeasurableSpace Î©'\nf : Î© â†’ Î©'\nf_mble : Measurable f\nÎ½â‚ Î½â‚‚ : MeasureTheory.FiniteMeasure Î©\nâŠ¢ Eq ((HAdd.hAdd Î½â‚ Î½â‚‚).map f) (HAdd.hAdd (Î½â‚.map f) (Î½â‚‚.map f))","decl":"@[simp] lemma map_add {f : Î© â†’ Î©'} (f_mble : Measurable f) (Î½â‚ Î½â‚‚ : FiniteMeasure Î©) :\n    (Î½â‚ + Î½â‚‚).map f = Î½â‚.map f + Î½â‚‚.map f := by\n  ext s s_mble\n  simp only [map_apply' _ f_mble.aemeasurable s_mble, toMeasure_add, Measure.add_apply]\n\n"}
{"name":"MeasureTheory.FiniteMeasure.map_smul","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\nÎ©' : Type u_2\ninstâœÂ¹ : MeasurableSpace Î©\ninstâœ : MeasurableSpace Î©'\nf : Î© â†’ Î©'\nc : NNReal\nÎ½ : MeasureTheory.FiniteMeasure Î©\nâŠ¢ Eq ((HSMul.hSMul c Î½).map f) (HSMul.hSMul c (Î½.map f))","decl":"@[simp] lemma map_smul {f : Î© â†’ Î©'} (c : â„â‰¥0) (Î½ : FiniteMeasure Î©) :\n    (c â€¢ Î½).map f = c â€¢ (Î½.map f) := by\n  ext s _\n  simp [toMeasure_smul]\n\n"}
{"name":"MeasureTheory.FiniteMeasure.tendsto_map_of_tendsto_of_continuous","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\nÎ©' : Type u_2\ninstâœâµ : MeasurableSpace Î©\ninstâœâ´ : MeasurableSpace Î©'\ninstâœÂ³ : TopologicalSpace Î©\ninstâœÂ² : OpensMeasurableSpace Î©\ninstâœÂ¹ : TopologicalSpace Î©'\ninstâœ : BorelSpace Î©'\nÎ¹ : Type u_3\nL : Filter Î¹\nÎ½s : Î¹ â†’ MeasureTheory.FiniteMeasure Î©\nÎ½ : MeasureTheory.FiniteMeasure Î©\nlim : Filter.Tendsto Î½s L (nhds Î½)\nf : Î© â†’ Î©'\nf_cont : Continuous f\nâŠ¢ Filter.Tendsto (fun i => (Î½s i).map f) L (nhds (Î½.map f))","decl":"/-- If `f : X â†’ Y` is continuous and `Y` is equipped with the Borel sigma algebra, then\n(weak) convergence of `FiniteMeasure`s on `X` implies (weak) convergence of the push-forwards\nof these measures by `f`. -/\nlemma tendsto_map_of_tendsto_of_continuous {Î¹ : Type*} {L : Filter Î¹}\n    (Î½s : Î¹ â†’ FiniteMeasure Î©) (Î½ : FiniteMeasure Î©) (lim : Tendsto Î½s L (ğ“ Î½))\n    {f : Î© â†’ Î©'} (f_cont : Continuous f) :\n    Tendsto (fun i â†¦ (Î½s i).map f) L (ğ“ (Î½.map f)) := by\n  rw [FiniteMeasure.tendsto_iff_forall_lintegral_tendsto] at lim âŠ¢\n  intro g\n  convert lim (g.compContinuous âŸ¨f, f_contâŸ©) <;>\n  Â· simp only [map, compContinuous_apply, ContinuousMap.coe_mk]\n    refine lintegral_map ?_ f_cont.measurable\n    exact (ENNReal.continuous_coe.comp g.continuous).measurable\n\n"}
{"name":"MeasureTheory.FiniteMeasure.continuous_map","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Î© : Type u_1\nÎ©' : Type u_2\ninstâœâµ : MeasurableSpace Î©\ninstâœâ´ : MeasurableSpace Î©'\ninstâœÂ³ : TopologicalSpace Î©\ninstâœÂ² : OpensMeasurableSpace Î©\ninstâœÂ¹ : TopologicalSpace Î©'\ninstâœ : BorelSpace Î©'\nf : Î© â†’ Î©'\nf_cont : Continuous f\nâŠ¢ Continuous fun Î½ => Î½.map f","decl":"/-- If `f : X â†’ Y` is continuous and `Y` is equipped with the Borel sigma algebra, then\nthe push-forward of finite measures `f* : FiniteMeasure X â†’ FiniteMeasure Y` is continuous\n(in the topologies of weak convergence of measures). -/\nlemma continuous_map {f : Î© â†’ Î©'} (f_cont : Continuous f) :\n    Continuous (fun Î½ â†¦ FiniteMeasure.map Î½ f) := by\n  rw [continuous_iff_continuousAt]\n  exact fun _ â†¦ tendsto_map_of_tendsto_of_continuous _ _ continuous_id.continuousAt f_cont\n\n"}
