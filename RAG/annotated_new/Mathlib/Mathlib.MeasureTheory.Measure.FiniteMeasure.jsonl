{"name":"MeasureTheory.FiniteMeasure.isFiniteMeasure","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝ : MeasurableSpace Ω\nμ : MeasureTheory.FiniteMeasure Ω\n⊢ MeasureTheory.IsFiniteMeasure ↑μ","decl":"instance isFiniteMeasure (μ : FiniteMeasure Ω) : IsFiniteMeasure (μ : Measure Ω) := μ.prop\n\n"}
{"name":"MeasureTheory.FiniteMeasure.val_eq_toMeasure","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝ : MeasurableSpace Ω\nν : MeasureTheory.FiniteMeasure Ω\n⊢ Eq ↑ν ↑ν","decl":"@[simp]\ntheorem val_eq_toMeasure (ν : FiniteMeasure Ω) : ν.val = (ν : Measure Ω) := rfl\n\n"}
{"name":"MeasureTheory.FiniteMeasure.toMeasure_injective","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝ : MeasurableSpace Ω\n⊢ Function.Injective MeasureTheory.FiniteMeasure.toMeasure","decl":"theorem toMeasure_injective : Function.Injective ((↑) : FiniteMeasure Ω → Measure Ω) :=\n  Subtype.coe_injective\n\n"}
{"name":"MeasureTheory.FiniteMeasure.coeFn_def","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝ : MeasurableSpace Ω\nμ : MeasureTheory.FiniteMeasure Ω\n⊢ Eq ⇑μ fun s => (↑μ s).toNNReal","decl":"lemma coeFn_def (μ : FiniteMeasure Ω) : μ = fun s ↦ ((μ : Measure Ω) s).toNNReal := rfl\n\n"}
{"name":"MeasureTheory.FiniteMeasure.coeFn_mk","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝ : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nhμ : MeasureTheory.IsFiniteMeasure μ\n⊢ Eq ⇑⟨μ, hμ⟩ fun s => (μ s).toNNReal","decl":"lemma coeFn_mk (μ : Measure Ω) (hμ) :\n    DFunLike.coe (F := FiniteMeasure Ω) ⟨μ, hμ⟩ = fun s ↦ (μ s).toNNReal := rfl\n\n"}
{"name":"MeasureTheory.FiniteMeasure.mk_apply","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝ : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nhμ : MeasureTheory.IsFiniteMeasure μ\ns : Set Ω\n⊢ Eq (⟨μ, hμ⟩ s) (μ s).toNNReal","decl":"@[simp, norm_cast]\nlemma mk_apply (μ : Measure Ω) (hμ) (s : Set Ω) :\n    DFunLike.coe (F := FiniteMeasure Ω) ⟨μ, hμ⟩ s = (μ s).toNNReal := rfl\n\n"}
{"name":"MeasureTheory.FiniteMeasure.ennreal_coeFn_eq_coeFn_toMeasure","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝ : MeasurableSpace Ω\nν : MeasureTheory.FiniteMeasure Ω\ns : Set Ω\n⊢ Eq (↑(ν s)) (↑ν s)","decl":"@[simp]\ntheorem ennreal_coeFn_eq_coeFn_toMeasure (ν : FiniteMeasure Ω) (s : Set Ω) :\n    (ν s : ℝ≥0∞) = (ν : Measure Ω) s :=\n  ENNReal.coe_toNNReal (measure_lt_top (↑ν) s).ne\n\n"}
{"name":"MeasureTheory.FiniteMeasure.null_iff_toMeasure_null","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝ : MeasurableSpace Ω\nν : MeasureTheory.FiniteMeasure Ω\ns : Set Ω\n⊢ Iff (Eq (ν s) 0) (Eq (↑ν s) 0)","decl":"@[simp]\ntheorem null_iff_toMeasure_null (ν : FiniteMeasure Ω) (s : Set Ω) :\n    ν s = 0 ↔ (ν : Measure Ω) s = 0 :=\n  ⟨fun h ↦ by rw [← ennreal_coeFn_eq_coeFn_toMeasure, h, ENNReal.coe_zero],\n   fun h ↦ congrArg ENNReal.toNNReal h⟩\n\n"}
{"name":"MeasureTheory.FiniteMeasure.apply_mono","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝ : MeasurableSpace Ω\nμ : MeasureTheory.FiniteMeasure Ω\ns₁ s₂ : Set Ω\nh : HasSubset.Subset s₁ s₂\n⊢ LE.le (μ s₁) (μ s₂)","decl":"theorem apply_mono (μ : FiniteMeasure Ω) {s₁ s₂ : Set Ω} (h : s₁ ⊆ s₂) : μ s₁ ≤ μ s₂ :=\n  ENNReal.toNNReal_mono (measure_ne_top _ s₂) ((μ : Measure Ω).mono h)\n\n"}
{"name":"MeasureTheory.FiniteMeasure.apply_le_mass","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝ : MeasurableSpace Ω\nμ : MeasureTheory.FiniteMeasure Ω\ns : Set Ω\n⊢ LE.le (μ s) μ.mass","decl":"@[simp] theorem apply_le_mass (μ : FiniteMeasure Ω) (s : Set Ω) : μ s ≤ μ.mass := by\n  simpa using apply_mono μ (subset_univ s)\n\n"}
{"name":"MeasureTheory.FiniteMeasure.ennreal_mass","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝ : MeasurableSpace Ω\nμ : MeasureTheory.FiniteMeasure Ω\n⊢ Eq (↑μ.mass) (↑μ Set.univ)","decl":"@[simp]\ntheorem ennreal_mass {μ : FiniteMeasure Ω} : (μ.mass : ℝ≥0∞) = (μ : Measure Ω) univ :=\n  ennreal_coeFn_eq_coeFn_toMeasure μ Set.univ\n\n"}
{"name":"MeasureTheory.FiniteMeasure.coeFn_zero","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝ : MeasurableSpace Ω\n⊢ Eq (⇑0) 0","decl":"@[simp, norm_cast] lemma coeFn_zero : ⇑(0 : FiniteMeasure Ω) = 0 := rfl\n\n"}
{"name":"MeasureTheory.FiniteMeasure.zero_mass","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝ : MeasurableSpace Ω\n⊢ Eq (MeasureTheory.FiniteMeasure.mass 0) 0","decl":"@[simp]\ntheorem zero_mass : (0 : FiniteMeasure Ω).mass = 0 := rfl\n\n"}
{"name":"MeasureTheory.FiniteMeasure.mass_zero_iff","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝ : MeasurableSpace Ω\nμ : MeasureTheory.FiniteMeasure Ω\n⊢ Iff (Eq μ.mass 0) (Eq μ 0)","decl":"@[simp]\ntheorem mass_zero_iff (μ : FiniteMeasure Ω) : μ.mass = 0 ↔ μ = 0 := by\n  refine ⟨fun μ_mass => ?_, fun hμ => by simp only [hμ, zero_mass]⟩\n  apply toMeasure_injective\n  apply Measure.measure_univ_eq_zero.mp\n  rwa [← ennreal_mass, ENNReal.coe_eq_zero]\n\n"}
{"name":"MeasureTheory.FiniteMeasure.mass_nonzero_iff","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝ : MeasurableSpace Ω\nμ : MeasureTheory.FiniteMeasure Ω\n⊢ Iff (Ne μ.mass 0) (Ne μ 0)","decl":"theorem mass_nonzero_iff (μ : FiniteMeasure Ω) : μ.mass ≠ 0 ↔ μ ≠ 0 :=\n  not_iff_not.mpr <| FiniteMeasure.mass_zero_iff μ\n\n"}
{"name":"MeasureTheory.FiniteMeasure.eq_of_forall_toMeasure_apply_eq","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝ : MeasurableSpace Ω\nμ ν : MeasureTheory.FiniteMeasure Ω\nh : ∀ (s : Set Ω), MeasurableSet s → Eq (↑μ s) (↑ν s)\n⊢ Eq μ ν","decl":"@[ext]\ntheorem eq_of_forall_toMeasure_apply_eq (μ ν : FiniteMeasure Ω)\n    (h : ∀ s : Set Ω, MeasurableSet s → (μ : Measure Ω) s = (ν : Measure Ω) s) : μ = ν := by\n  apply Subtype.ext\n  ext1 s s_mble\n  exact h s s_mble\n\n"}
{"name":"MeasureTheory.FiniteMeasure.eq_of_forall_toMeasure_apply_eq_iff","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝ : MeasurableSpace Ω\nμ ν : MeasureTheory.FiniteMeasure Ω\n⊢ Iff (Eq μ ν) (∀ (s : Set Ω), MeasurableSet s → Eq (↑μ s) (↑ν s))","decl":"@[ext]\ntheorem eq_of_forall_toMeasure_apply_eq (μ ν : FiniteMeasure Ω)\n    (h : ∀ s : Set Ω, MeasurableSet s → (μ : Measure Ω) s = (ν : Measure Ω) s) : μ = ν := by\n  apply Subtype.ext\n  ext1 s s_mble\n  exact h s s_mble\n\n"}
{"name":"MeasureTheory.FiniteMeasure.eq_of_forall_apply_eq","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝ : MeasurableSpace Ω\nμ ν : MeasureTheory.FiniteMeasure Ω\nh : ∀ (s : Set Ω), MeasurableSet s → Eq (μ s) (ν s)\n⊢ Eq μ ν","decl":"theorem eq_of_forall_apply_eq (μ ν : FiniteMeasure Ω)\n    (h : ∀ s : Set Ω, MeasurableSet s → μ s = ν s) : μ = ν := by\n  ext1 s s_mble\n  simpa [ennreal_coeFn_eq_coeFn_toMeasure] using congr_arg ((↑) : ℝ≥0 → ℝ≥0∞) (h s s_mble)\n\n"}
{"name":"MeasureTheory.FiniteMeasure.toMeasure_zero","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝ : MeasurableSpace Ω\n⊢ Eq (↑0) 0","decl":"@[simp, norm_cast]\ntheorem toMeasure_zero : ((↑) : FiniteMeasure Ω → Measure Ω) 0 = 0 := rfl\n\n"}
{"name":"MeasureTheory.FiniteMeasure.toMeasure_add","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝ : MeasurableSpace Ω\nμ ν : MeasureTheory.FiniteMeasure Ω\n⊢ Eq (↑(HAdd.hAdd μ ν)) (HAdd.hAdd ↑μ ↑ν)","decl":"@[norm_cast]\ntheorem toMeasure_add (μ ν : FiniteMeasure Ω) : ↑(μ + ν) = (↑μ + ↑ν : Measure Ω) := rfl\n\n"}
{"name":"MeasureTheory.FiniteMeasure.toMeasure_smul","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝⁴ : MeasurableSpace Ω\nR : Type u_2\ninst✝³ : SMul R NNReal\ninst✝² : SMul R ENNReal\ninst✝¹ : IsScalarTower R NNReal ENNReal\ninst✝ : IsScalarTower R ENNReal ENNReal\nc : R\nμ : MeasureTheory.FiniteMeasure Ω\n⊢ Eq (↑(HSMul.hSMul c μ)) (HSMul.hSMul c ↑μ)","decl":"@[simp, norm_cast]\ntheorem toMeasure_smul (c : R) (μ : FiniteMeasure Ω) : ↑(c • μ) = c • (μ : Measure Ω) :=\n  rfl\n\n"}
{"name":"MeasureTheory.FiniteMeasure.coeFn_add","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝ : MeasurableSpace Ω\nμ ν : MeasureTheory.FiniteMeasure Ω\n⊢ Eq (⇑(HAdd.hAdd μ ν)) (HAdd.hAdd ⇑μ ⇑ν)","decl":"@[simp, norm_cast]\ntheorem coeFn_add (μ ν : FiniteMeasure Ω) : (⇑(μ + ν) : Set Ω → ℝ≥0) = (⇑μ + ⇑ν : Set Ω → ℝ≥0) := by\n  funext\n  simp only [Pi.add_apply, ← ENNReal.coe_inj, ne_eq, ennreal_coeFn_eq_coeFn_toMeasure,\n    ENNReal.coe_add]\n  norm_cast\n\n"}
{"name":"MeasureTheory.FiniteMeasure.coeFn_smul","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝⁵ : MeasurableSpace Ω\nR : Type u_2\ninst✝⁴ : SMul R NNReal\ninst✝³ : SMul R ENNReal\ninst✝² : IsScalarTower R NNReal ENNReal\ninst✝¹ : IsScalarTower R ENNReal ENNReal\ninst✝ : IsScalarTower R NNReal NNReal\nc : R\nμ : MeasureTheory.FiniteMeasure Ω\n⊢ Eq (⇑(HSMul.hSMul c μ)) (HSMul.hSMul c ⇑μ)","decl":"@[simp, norm_cast]\ntheorem coeFn_smul [IsScalarTower R ℝ≥0 ℝ≥0] (c : R) (μ : FiniteMeasure Ω) :\n    (⇑(c • μ) : Set Ω → ℝ≥0) = c • (⇑μ : Set Ω → ℝ≥0) := by\n  funext; simp [← ENNReal.coe_inj, ENNReal.coe_smul]\n\n"}
{"name":"MeasureTheory.FiniteMeasure.toMeasureAddMonoidHom_apply","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝ : MeasurableSpace Ω\na✝ : MeasureTheory.FiniteMeasure Ω\n⊢ Eq (MeasureTheory.FiniteMeasure.toMeasureAddMonoidHom a✝) ↑a✝","decl":"/-- Coercion is an `AddMonoidHom`. -/\n@[simps]\ndef toMeasureAddMonoidHom : FiniteMeasure Ω →+ Measure Ω where\n  toFun := (↑)\n  map_zero' := toMeasure_zero\n  map_add' := toMeasure_add\n\n"}
{"name":"MeasureTheory.FiniteMeasure.smul_apply","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝⁵ : MeasurableSpace Ω\nR : Type u_2\ninst✝⁴ : SMul R NNReal\ninst✝³ : SMul R ENNReal\ninst✝² : IsScalarTower R NNReal ENNReal\ninst✝¹ : IsScalarTower R ENNReal ENNReal\ninst✝ : IsScalarTower R NNReal NNReal\nc : R\nμ : MeasureTheory.FiniteMeasure Ω\ns : Set Ω\n⊢ Eq ((HSMul.hSMul c μ) s) (HSMul.hSMul c (μ s))","decl":"@[simp]\ntheorem smul_apply [IsScalarTower R ℝ≥0 ℝ≥0] (c : R) (μ : FiniteMeasure Ω) (s : Set Ω) :\n    (c • μ) s = c • μ s := by\n  rw [coeFn_smul, Pi.smul_apply]\n\n"}
{"name":"MeasureTheory.FiniteMeasure.restrict_measure_eq","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝ : MeasurableSpace Ω\nμ : MeasureTheory.FiniteMeasure Ω\nA : Set Ω\n⊢ Eq (↑(μ.restrict A)) ((↑μ).restrict A)","decl":"theorem restrict_measure_eq (μ : FiniteMeasure Ω) (A : Set Ω) :\n    (μ.restrict A : Measure Ω) = (μ : Measure Ω).restrict A := rfl\n\n"}
{"name":"MeasureTheory.FiniteMeasure.restrict_apply_measure","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝ : MeasurableSpace Ω\nμ : MeasureTheory.FiniteMeasure Ω\nA s : Set Ω\ns_mble : MeasurableSet s\n⊢ Eq (↑(μ.restrict A) s) (↑μ (Inter.inter s A))","decl":"theorem restrict_apply_measure (μ : FiniteMeasure Ω) (A : Set Ω) {s : Set Ω}\n    (s_mble : MeasurableSet s) : (μ.restrict A : Measure Ω) s = (μ : Measure Ω) (s ∩ A) :=\n  Measure.restrict_apply s_mble\n\n"}
{"name":"MeasureTheory.FiniteMeasure.restrict_apply","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝ : MeasurableSpace Ω\nμ : MeasureTheory.FiniteMeasure Ω\nA s : Set Ω\ns_mble : MeasurableSet s\n⊢ Eq ((μ.restrict A) s) (μ (Inter.inter s A))","decl":"theorem restrict_apply (μ : FiniteMeasure Ω) (A : Set Ω) {s : Set Ω} (s_mble : MeasurableSet s) :\n    (μ.restrict A) s = μ (s ∩ A) := by\n  apply congr_arg ENNReal.toNNReal\n  exact Measure.restrict_apply s_mble\n\n"}
{"name":"MeasureTheory.FiniteMeasure.restrict_mass","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝ : MeasurableSpace Ω\nμ : MeasureTheory.FiniteMeasure Ω\nA : Set Ω\n⊢ Eq (μ.restrict A).mass (μ A)","decl":"theorem restrict_mass (μ : FiniteMeasure Ω) (A : Set Ω) : (μ.restrict A).mass = μ A := by\n  simp only [mass, restrict_apply μ A MeasurableSet.univ, univ_inter]\n\n"}
{"name":"MeasureTheory.FiniteMeasure.restrict_eq_zero_iff","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝ : MeasurableSpace Ω\nμ : MeasureTheory.FiniteMeasure Ω\nA : Set Ω\n⊢ Iff (Eq (μ.restrict A) 0) (Eq (μ A) 0)","decl":"theorem restrict_eq_zero_iff (μ : FiniteMeasure Ω) (A : Set Ω) : μ.restrict A = 0 ↔ μ A = 0 := by\n  rw [← mass_zero_iff, restrict_mass]\n\n"}
{"name":"MeasureTheory.FiniteMeasure.restrict_nonzero_iff","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝ : MeasurableSpace Ω\nμ : MeasureTheory.FiniteMeasure Ω\nA : Set Ω\n⊢ Iff (Ne (μ.restrict A) 0) (Ne (μ A) 0)","decl":"theorem restrict_nonzero_iff (μ : FiniteMeasure Ω) (A : Set Ω) : μ.restrict A ≠ 0 ↔ μ A ≠ 0 := by\n  rw [← mass_nonzero_iff, restrict_mass]\n\n"}
{"name":"MeasureTheory.FiniteMeasure.ext_of_forall_lintegral_eq","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝³ : MeasurableSpace Ω\ninst✝² : TopologicalSpace Ω\ninst✝¹ : HasOuterApproxClosed Ω\ninst✝ : BorelSpace Ω\nμ ν : MeasureTheory.FiniteMeasure Ω\nh : ∀ (f : BoundedContinuousFunction Ω NNReal), Eq (MeasureTheory.lintegral ↑μ fun x => ↑(f x)) (MeasureTheory.lintegral ↑ν fun x => ↑(f x))\n⊢ Eq μ ν","decl":"/-- Two finite Borel measures are equal if the integrals of all bounded continuous functions with\nrespect to both agree. -/\ntheorem ext_of_forall_lintegral_eq [HasOuterApproxClosed Ω] [BorelSpace Ω]\n    {μ ν : FiniteMeasure Ω} (h : ∀ (f : Ω →ᵇ ℝ≥0), ∫⁻ x, f x ∂μ = ∫⁻ x, f x ∂ν) :\n    μ = ν := by\n  apply Subtype.ext\n  change (μ : Measure Ω) = (ν : Measure Ω)\n  exact ext_of_forall_lintegral_eq_of_IsFiniteMeasure h\n\n"}
{"name":"MeasureTheory.FiniteMeasure.testAgainstNN_coe_eq","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝¹ : MeasurableSpace Ω\ninst✝ : TopologicalSpace Ω\nμ : MeasureTheory.FiniteMeasure Ω\nf : BoundedContinuousFunction Ω NNReal\n⊢ Eq (↑(μ.testAgainstNN f)) (MeasureTheory.lintegral ↑μ fun ω => ↑(f ω))","decl":"@[simp]\ntheorem testAgainstNN_coe_eq {μ : FiniteMeasure Ω} {f : Ω →ᵇ ℝ≥0} :\n    (μ.testAgainstNN f : ℝ≥0∞) = ∫⁻ ω, f ω ∂(μ : Measure Ω) :=\n  ENNReal.coe_toNNReal (f.lintegral_lt_top_of_nnreal _).ne\n\n"}
{"name":"MeasureTheory.FiniteMeasure.testAgainstNN_const","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝¹ : MeasurableSpace Ω\ninst✝ : TopologicalSpace Ω\nμ : MeasureTheory.FiniteMeasure Ω\nc : NNReal\n⊢ Eq (μ.testAgainstNN (BoundedContinuousFunction.const Ω c)) (HMul.hMul c μ.mass)","decl":"theorem testAgainstNN_const (μ : FiniteMeasure Ω) (c : ℝ≥0) :\n    μ.testAgainstNN (BoundedContinuousFunction.const Ω c) = c * μ.mass := by\n  simp [← ENNReal.coe_inj]\n\n"}
{"name":"MeasureTheory.FiniteMeasure.testAgainstNN_mono","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝¹ : MeasurableSpace Ω\ninst✝ : TopologicalSpace Ω\nμ : MeasureTheory.FiniteMeasure Ω\nf g : BoundedContinuousFunction Ω NNReal\nf_le_g : LE.le ⇑f ⇑g\n⊢ LE.le (μ.testAgainstNN f) (μ.testAgainstNN g)","decl":"theorem testAgainstNN_mono (μ : FiniteMeasure Ω) {f g : Ω →ᵇ ℝ≥0} (f_le_g : (f : Ω → ℝ≥0) ≤ g) :\n    μ.testAgainstNN f ≤ μ.testAgainstNN g := by\n  simp only [← ENNReal.coe_le_coe, testAgainstNN_coe_eq]\n  gcongr\n  apply f_le_g\n\n"}
{"name":"MeasureTheory.FiniteMeasure.testAgainstNN_zero","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝¹ : MeasurableSpace Ω\ninst✝ : TopologicalSpace Ω\nμ : MeasureTheory.FiniteMeasure Ω\n⊢ Eq (μ.testAgainstNN 0) 0","decl":"@[simp]\ntheorem testAgainstNN_zero (μ : FiniteMeasure Ω) : μ.testAgainstNN 0 = 0 := by\n  simpa only [zero_mul] using μ.testAgainstNN_const 0\n\n"}
{"name":"MeasureTheory.FiniteMeasure.testAgainstNN_one","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝¹ : MeasurableSpace Ω\ninst✝ : TopologicalSpace Ω\nμ : MeasureTheory.FiniteMeasure Ω\n⊢ Eq (μ.testAgainstNN 1) μ.mass","decl":"@[simp]\ntheorem testAgainstNN_one (μ : FiniteMeasure Ω) : μ.testAgainstNN 1 = μ.mass := by\n  simp only [testAgainstNN, coe_one, Pi.one_apply, ENNReal.coe_one, lintegral_one]\n  rfl\n\n"}
{"name":"MeasureTheory.FiniteMeasure.zero_testAgainstNN_apply","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝¹ : MeasurableSpace Ω\ninst✝ : TopologicalSpace Ω\nf : BoundedContinuousFunction Ω NNReal\n⊢ Eq (MeasureTheory.FiniteMeasure.testAgainstNN 0 f) 0","decl":"@[simp]\ntheorem zero_testAgainstNN_apply (f : Ω →ᵇ ℝ≥0) : (0 : FiniteMeasure Ω).testAgainstNN f = 0 := by\n  simp only [testAgainstNN, toMeasure_zero, lintegral_zero_measure, ENNReal.zero_toNNReal]\n\n"}
{"name":"MeasureTheory.FiniteMeasure.zero_testAgainstNN","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝¹ : MeasurableSpace Ω\ninst✝ : TopologicalSpace Ω\n⊢ Eq (MeasureTheory.FiniteMeasure.testAgainstNN 0) 0","decl":"theorem zero_testAgainstNN : (0 : FiniteMeasure Ω).testAgainstNN = 0 := by\n  funext\n  simp only [zero_testAgainstNN_apply, Pi.zero_apply]\n\n"}
{"name":"MeasureTheory.FiniteMeasure.smul_testAgainstNN_apply","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝¹ : MeasurableSpace Ω\ninst✝ : TopologicalSpace Ω\nc : NNReal\nμ : MeasureTheory.FiniteMeasure Ω\nf : BoundedContinuousFunction Ω NNReal\n⊢ Eq ((HSMul.hSMul c μ).testAgainstNN f) (HSMul.hSMul c (μ.testAgainstNN f))","decl":"@[simp]\ntheorem smul_testAgainstNN_apply (c : ℝ≥0) (μ : FiniteMeasure Ω) (f : Ω →ᵇ ℝ≥0) :\n    (c • μ).testAgainstNN f = c • μ.testAgainstNN f := by\n  simp only [testAgainstNN, toMeasure_smul, smul_eq_mul, ← ENNReal.smul_toNNReal, ENNReal.smul_def,\n    lintegral_smul_measure]\n\n"}
{"name":"MeasureTheory.FiniteMeasure.testAgainstNN_add","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝² : MeasurableSpace Ω\ninst✝¹ : TopologicalSpace Ω\ninst✝ : OpensMeasurableSpace Ω\nμ : MeasureTheory.FiniteMeasure Ω\nf₁ f₂ : BoundedContinuousFunction Ω NNReal\n⊢ Eq (μ.testAgainstNN (HAdd.hAdd f₁ f₂)) (HAdd.hAdd (μ.testAgainstNN f₁) (μ.testAgainstNN f₂))","decl":"theorem testAgainstNN_add (μ : FiniteMeasure Ω) (f₁ f₂ : Ω →ᵇ ℝ≥0) :\n    μ.testAgainstNN (f₁ + f₂) = μ.testAgainstNN f₁ + μ.testAgainstNN f₂ := by\n  simp only [← ENNReal.coe_inj, BoundedContinuousFunction.coe_add, ENNReal.coe_add, Pi.add_apply,\n    testAgainstNN_coe_eq]\n  exact lintegral_add_left (BoundedContinuousFunction.measurable_coe_ennreal_comp _) _\n\n"}
{"name":"MeasureTheory.FiniteMeasure.testAgainstNN_smul","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝¹⁰ : MeasurableSpace Ω\nR : Type u_2\ninst✝⁹ : SMul R NNReal\ninst✝⁸ : SMul R ENNReal\ninst✝⁷ : IsScalarTower R NNReal ENNReal\ninst✝⁶ : IsScalarTower R ENNReal ENNReal\ninst✝⁵ : TopologicalSpace Ω\ninst✝⁴ : OpensMeasurableSpace Ω\ninst✝³ : IsScalarTower R NNReal NNReal\ninst✝² : PseudoMetricSpace R\ninst✝¹ : Zero R\ninst✝ : BoundedSMul R NNReal\nμ : MeasureTheory.FiniteMeasure Ω\nc : R\nf : BoundedContinuousFunction Ω NNReal\n⊢ Eq (μ.testAgainstNN (HSMul.hSMul c f)) (HSMul.hSMul c (μ.testAgainstNN f))","decl":"theorem testAgainstNN_smul [IsScalarTower R ℝ≥0 ℝ≥0] [PseudoMetricSpace R] [Zero R]\n    [BoundedSMul R ℝ≥0] (μ : FiniteMeasure Ω) (c : R) (f : Ω →ᵇ ℝ≥0) :\n    μ.testAgainstNN (c • f) = c • μ.testAgainstNN f := by\n  simp only [← ENNReal.coe_inj, BoundedContinuousFunction.coe_smul, testAgainstNN_coe_eq,\n    ENNReal.coe_smul]\n  simp_rw [← smul_one_smul ℝ≥0∞ c (f _ : ℝ≥0∞), ← smul_one_smul ℝ≥0∞ c (lintegral _ _ : ℝ≥0∞),\n    smul_eq_mul]\n  exact lintegral_const_mul (c • (1 : ℝ≥0∞)) f.measurable_coe_ennreal_comp\n\n"}
{"name":"MeasureTheory.FiniteMeasure.testAgainstNN_lipschitz_estimate","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝² : MeasurableSpace Ω\ninst✝¹ : TopologicalSpace Ω\ninst✝ : OpensMeasurableSpace Ω\nμ : MeasureTheory.FiniteMeasure Ω\nf g : BoundedContinuousFunction Ω NNReal\n⊢ LE.le (μ.testAgainstNN f) (HAdd.hAdd (μ.testAgainstNN g) (HMul.hMul (NNDist.nndist f g) μ.mass))","decl":"theorem testAgainstNN_lipschitz_estimate (μ : FiniteMeasure Ω) (f g : Ω →ᵇ ℝ≥0) :\n    μ.testAgainstNN f ≤ μ.testAgainstNN g + nndist f g * μ.mass := by\n  simp only [← μ.testAgainstNN_const (nndist f g), ← testAgainstNN_add, ← ENNReal.coe_le_coe,\n    BoundedContinuousFunction.coe_add, const_apply, ENNReal.coe_add, Pi.add_apply,\n    coe_nnreal_ennreal_nndist, testAgainstNN_coe_eq]\n  apply lintegral_mono\n  have le_dist : ∀ ω, dist (f ω) (g ω) ≤ nndist f g := BoundedContinuousFunction.dist_coe_le_dist\n  intro ω\n  have le' : f ω ≤ g ω + nndist f g := by\n    calc f ω\n     _ ≤ g ω + nndist (f ω) (g ω)     := NNReal.le_add_nndist (f ω) (g ω)\n     _ ≤ g ω + nndist f g             := (add_le_add_iff_left (g ω)).mpr (le_dist ω)\n  have le : (f ω : ℝ≥0∞) ≤ (g ω : ℝ≥0∞) + nndist f g := by\n    simpa only [← ENNReal.coe_add] using (by exact_mod_cast le')\n  rwa [coe_nnreal_ennreal_nndist] at le\n\n"}
{"name":"MeasureTheory.FiniteMeasure.testAgainstNN_lipschitz","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝² : MeasurableSpace Ω\ninst✝¹ : TopologicalSpace Ω\ninst✝ : OpensMeasurableSpace Ω\nμ : MeasureTheory.FiniteMeasure Ω\n⊢ LipschitzWith μ.mass fun f => μ.testAgainstNN f","decl":"theorem testAgainstNN_lipschitz (μ : FiniteMeasure Ω) :\n    LipschitzWith μ.mass fun f : Ω →ᵇ ℝ≥0 ↦ μ.testAgainstNN f := by\n  rw [lipschitzWith_iff_dist_le_mul]\n  intro f₁ f₂\n  suffices abs (μ.testAgainstNN f₁ - μ.testAgainstNN f₂ : ℝ) ≤ μ.mass * dist f₁ f₂ by\n    rwa [NNReal.dist_eq]\n  apply abs_le.mpr\n  constructor\n  · have key := μ.testAgainstNN_lipschitz_estimate f₂ f₁\n    rw [mul_comm] at key\n    suffices ↑(μ.testAgainstNN f₂) ≤ ↑(μ.testAgainstNN f₁) + ↑μ.mass * dist f₁ f₂ by linarith\n    simpa [nndist_comm] using NNReal.coe_mono key\n  · have key := μ.testAgainstNN_lipschitz_estimate f₁ f₂\n    rw [mul_comm] at key\n    suffices ↑(μ.testAgainstNN f₁) ≤ ↑(μ.testAgainstNN f₂) + ↑μ.mass * dist f₁ f₂ by linarith\n    simpa using NNReal.coe_mono key\n\n"}
{"name":"MeasureTheory.FiniteMeasure.coe_toWeakDualBCNN","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝² : MeasurableSpace Ω\ninst✝¹ : TopologicalSpace Ω\ninst✝ : OpensMeasurableSpace Ω\nμ : MeasureTheory.FiniteMeasure Ω\n⊢ Eq (⇑μ.toWeakDualBCNN) μ.testAgainstNN","decl":"@[simp]\ntheorem coe_toWeakDualBCNN (μ : FiniteMeasure Ω) : ⇑μ.toWeakDualBCNN = μ.testAgainstNN :=\n  rfl\n\n"}
{"name":"MeasureTheory.FiniteMeasure.toWeakDualBCNN_apply","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝² : MeasurableSpace Ω\ninst✝¹ : TopologicalSpace Ω\ninst✝ : OpensMeasurableSpace Ω\nμ : MeasureTheory.FiniteMeasure Ω\nf : BoundedContinuousFunction Ω NNReal\n⊢ Eq (μ.toWeakDualBCNN f) (MeasureTheory.lintegral ↑μ fun x => ↑(f x)).toNNReal","decl":"@[simp]\ntheorem toWeakDualBCNN_apply (μ : FiniteMeasure Ω) (f : Ω →ᵇ ℝ≥0) :\n    μ.toWeakDualBCNN f = (∫⁻ x, f x ∂(μ : Measure Ω)).toNNReal := rfl\n\n"}
{"name":"MeasureTheory.FiniteMeasure.toWeakDualBCNN_continuous","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝² : MeasurableSpace Ω\ninst✝¹ : TopologicalSpace Ω\ninst✝ : OpensMeasurableSpace Ω\n⊢ Continuous MeasureTheory.FiniteMeasure.toWeakDualBCNN","decl":"theorem toWeakDualBCNN_continuous : Continuous (@toWeakDualBCNN Ω _ _ _) :=\n  continuous_induced_dom\n\n"}
{"name":"MeasureTheory.FiniteMeasure.continuous_testAgainstNN_eval","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝² : MeasurableSpace Ω\ninst✝¹ : TopologicalSpace Ω\ninst✝ : OpensMeasurableSpace Ω\nf : BoundedContinuousFunction Ω NNReal\n⊢ Continuous fun μ => μ.testAgainstNN f","decl":"/-- Integration of (nonnegative bounded continuous) test functions against finite Borel measures\ndepends continuously on the measure. -/\ntheorem continuous_testAgainstNN_eval (f : Ω →ᵇ ℝ≥0) :\n    Continuous fun μ : FiniteMeasure Ω ↦ μ.testAgainstNN f := by\n  show Continuous ((fun φ : WeakDual ℝ≥0 (Ω →ᵇ ℝ≥0) ↦ φ f) ∘ toWeakDualBCNN)\n  refine Continuous.comp ?_ (toWeakDualBCNN_continuous (Ω := Ω))\n  exact WeakBilin.eval_continuous _ _\n\n"}
{"name":"MeasureTheory.FiniteMeasure.continuous_mass","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝² : MeasurableSpace Ω\ninst✝¹ : TopologicalSpace Ω\ninst✝ : OpensMeasurableSpace Ω\n⊢ Continuous fun μ => μ.mass","decl":"/-- The total mass of a finite measure depends continuously on the measure. -/\ntheorem continuous_mass : Continuous fun μ : FiniteMeasure Ω ↦ μ.mass := by\n  simp_rw [← testAgainstNN_one]; exact continuous_testAgainstNN_eval 1\n\n"}
{"name":"Filter.Tendsto.mass","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝² : MeasurableSpace Ω\ninst✝¹ : TopologicalSpace Ω\ninst✝ : OpensMeasurableSpace Ω\nγ : Type u_3\nF : Filter γ\nμs : γ → MeasureTheory.FiniteMeasure Ω\nμ : MeasureTheory.FiniteMeasure Ω\nh : Filter.Tendsto μs F (nhds μ)\n⊢ Filter.Tendsto (fun i => (μs i).mass) F (nhds μ.mass)","decl":"/-- Convergence of finite measures implies the convergence of their total masses. -/\ntheorem _root_.Filter.Tendsto.mass {γ : Type*} {F : Filter γ} {μs : γ → FiniteMeasure Ω}\n    {μ : FiniteMeasure Ω} (h : Tendsto μs F (𝓝 μ)) : Tendsto (fun i ↦ (μs i).mass) F (𝓝 μ.mass) :=\n  (continuous_mass.tendsto μ).comp h\n\n"}
{"name":"MeasureTheory.FiniteMeasure.tendsto_iff_weakDual_tendsto","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝² : MeasurableSpace Ω\ninst✝¹ : TopologicalSpace Ω\ninst✝ : OpensMeasurableSpace Ω\nγ : Type u_3\nF : Filter γ\nμs : γ → MeasureTheory.FiniteMeasure Ω\nμ : MeasureTheory.FiniteMeasure Ω\n⊢ Iff (Filter.Tendsto μs F (nhds μ)) (Filter.Tendsto (fun i => (μs i).toWeakDualBCNN) F (nhds μ.toWeakDualBCNN))","decl":"theorem tendsto_iff_weakDual_tendsto {γ : Type*} {F : Filter γ} {μs : γ → FiniteMeasure Ω}\n    {μ : FiniteMeasure Ω} :\n    Tendsto μs F (𝓝 μ) ↔ Tendsto (fun i ↦ (μs i).toWeakDualBCNN) F (𝓝 μ.toWeakDualBCNN) :=\n  IsInducing.tendsto_nhds_iff ⟨rfl⟩\n\n"}
{"name":"MeasureTheory.FiniteMeasure.tendsto_iff_forall_toWeakDualBCNN_tendsto","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝² : MeasurableSpace Ω\ninst✝¹ : TopologicalSpace Ω\ninst✝ : OpensMeasurableSpace Ω\nγ : Type u_3\nF : Filter γ\nμs : γ → MeasureTheory.FiniteMeasure Ω\nμ : MeasureTheory.FiniteMeasure Ω\n⊢ Iff (Filter.Tendsto μs F (nhds μ)) (∀ (f : BoundedContinuousFunction Ω NNReal), Filter.Tendsto (fun i => (μs i).toWeakDualBCNN f) F (nhds (μ.toWeakDualBCNN f)))","decl":"theorem tendsto_iff_forall_toWeakDualBCNN_tendsto {γ : Type*} {F : Filter γ}\n    {μs : γ → FiniteMeasure Ω} {μ : FiniteMeasure Ω} :\n    Tendsto μs F (𝓝 μ) ↔\n      ∀ f : Ω →ᵇ ℝ≥0, Tendsto (fun i ↦ (μs i).toWeakDualBCNN f) F (𝓝 (μ.toWeakDualBCNN f)) := by\n  rw [tendsto_iff_weakDual_tendsto, tendsto_iff_forall_eval_tendsto_topDualPairing]; rfl\n\n"}
{"name":"MeasureTheory.FiniteMeasure.tendsto_iff_forall_testAgainstNN_tendsto","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝² : MeasurableSpace Ω\ninst✝¹ : TopologicalSpace Ω\ninst✝ : OpensMeasurableSpace Ω\nγ : Type u_3\nF : Filter γ\nμs : γ → MeasureTheory.FiniteMeasure Ω\nμ : MeasureTheory.FiniteMeasure Ω\n⊢ Iff (Filter.Tendsto μs F (nhds μ)) (∀ (f : BoundedContinuousFunction Ω NNReal), Filter.Tendsto (fun i => (μs i).testAgainstNN f) F (nhds (μ.testAgainstNN f)))","decl":"theorem tendsto_iff_forall_testAgainstNN_tendsto {γ : Type*} {F : Filter γ}\n    {μs : γ → FiniteMeasure Ω} {μ : FiniteMeasure Ω} :\n    Tendsto μs F (𝓝 μ) ↔\n      ∀ f : Ω →ᵇ ℝ≥0, Tendsto (fun i ↦ (μs i).testAgainstNN f) F (𝓝 (μ.testAgainstNN f)) := by\n  rw [FiniteMeasure.tendsto_iff_forall_toWeakDualBCNN_tendsto]; rfl\n\n"}
{"name":"MeasureTheory.FiniteMeasure.tendsto_zero_testAgainstNN_of_tendsto_zero_mass","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝² : MeasurableSpace Ω\ninst✝¹ : TopologicalSpace Ω\ninst✝ : OpensMeasurableSpace Ω\nγ : Type u_3\nF : Filter γ\nμs : γ → MeasureTheory.FiniteMeasure Ω\nmass_lim : Filter.Tendsto (fun i => (μs i).mass) F (nhds 0)\nf : BoundedContinuousFunction Ω NNReal\n⊢ Filter.Tendsto (fun i => (μs i).testAgainstNN f) F (nhds 0)","decl":"/-- If the total masses of finite measures tend to zero, then the measures tend to\nzero. This formulation concerns the associated functionals on bounded continuous\nnonnegative test functions. See `MeasureTheory.FiniteMeasure.tendsto_zero_of_tendsto_zero_mass` for\na formulation stating the weak convergence of measures. -/\ntheorem tendsto_zero_testAgainstNN_of_tendsto_zero_mass {γ : Type*} {F : Filter γ}\n    {μs : γ → FiniteMeasure Ω} (mass_lim : Tendsto (fun i ↦ (μs i).mass) F (𝓝 0)) (f : Ω →ᵇ ℝ≥0) :\n    Tendsto (fun i ↦ (μs i).testAgainstNN f) F (𝓝 0) := by\n  apply tendsto_iff_dist_tendsto_zero.mpr\n  have obs := fun i ↦ (μs i).testAgainstNN_lipschitz_estimate f 0\n  simp_rw [testAgainstNN_zero, zero_add] at obs\n  simp_rw [show ∀ i, dist ((μs i).testAgainstNN f) 0 = (μs i).testAgainstNN f by\n      simp only [dist_nndist, NNReal.nndist_zero_eq_val', eq_self_iff_true, imp_true_iff]]\n  apply squeeze_zero (fun i ↦ NNReal.coe_nonneg _) obs\n  have lim_pair : Tendsto (fun i ↦ (⟨nndist f 0, (μs i).mass⟩ : ℝ × ℝ)) F (𝓝 ⟨nndist f 0, 0⟩) :=\n    (Prod.tendsto_iff _ _).mpr ⟨tendsto_const_nhds, (NNReal.continuous_coe.tendsto 0).comp mass_lim⟩\n  simpa using tendsto_mul.comp lim_pair\n\n"}
{"name":"MeasureTheory.FiniteMeasure.tendsto_zero_of_tendsto_zero_mass","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝² : MeasurableSpace Ω\ninst✝¹ : TopologicalSpace Ω\ninst✝ : OpensMeasurableSpace Ω\nγ : Type u_3\nF : Filter γ\nμs : γ → MeasureTheory.FiniteMeasure Ω\nmass_lim : Filter.Tendsto (fun i => (μs i).mass) F (nhds 0)\n⊢ Filter.Tendsto μs F (nhds 0)","decl":"/-- If the total masses of finite measures tend to zero, then the measures tend to zero. -/\ntheorem tendsto_zero_of_tendsto_zero_mass {γ : Type*} {F : Filter γ} {μs : γ → FiniteMeasure Ω}\n    (mass_lim : Tendsto (fun i ↦ (μs i).mass) F (𝓝 0)) : Tendsto μs F (𝓝 0) := by\n  rw [tendsto_iff_forall_testAgainstNN_tendsto]\n  intro f\n  convert tendsto_zero_testAgainstNN_of_tendsto_zero_mass mass_lim f\n  rw [zero_testAgainstNN_apply]\n\n"}
{"name":"MeasureTheory.FiniteMeasure.tendsto_iff_forall_lintegral_tendsto","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝² : MeasurableSpace Ω\ninst✝¹ : TopologicalSpace Ω\ninst✝ : OpensMeasurableSpace Ω\nγ : Type u_3\nF : Filter γ\nμs : γ → MeasureTheory.FiniteMeasure Ω\nμ : MeasureTheory.FiniteMeasure Ω\n⊢ Iff (Filter.Tendsto μs F (nhds μ)) (∀ (f : BoundedContinuousFunction Ω NNReal), Filter.Tendsto (fun i => MeasureTheory.lintegral ↑(μs i) fun x => ↑(f x)) F (nhds (MeasureTheory.lintegral ↑μ fun x => ↑(f x))))","decl":"/-- A characterization of weak convergence in terms of integrals of bounded continuous\nnonnegative functions. -/\ntheorem tendsto_iff_forall_lintegral_tendsto {γ : Type*} {F : Filter γ} {μs : γ → FiniteMeasure Ω}\n    {μ : FiniteMeasure Ω} :\n    Tendsto μs F (𝓝 μ) ↔\n      ∀ f : Ω →ᵇ ℝ≥0,\n        Tendsto (fun i ↦ ∫⁻ x, f x ∂(μs i : Measure Ω)) F (𝓝 (∫⁻ x, f x ∂(μ : Measure Ω))) := by\n  rw [tendsto_iff_forall_toWeakDualBCNN_tendsto]\n  simp_rw [toWeakDualBCNN_apply _ _, ← testAgainstNN_coe_eq, ENNReal.tendsto_coe,\n    ENNReal.toNNReal_coe]\n\n"}
{"name":"MeasureTheory.FiniteMeasure.injective_toWeakDualBCNN","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝³ : MeasurableSpace Ω\ninst✝² : TopologicalSpace Ω\ninst✝¹ : HasOuterApproxClosed Ω\ninst✝ : BorelSpace Ω\n⊢ Function.Injective MeasureTheory.FiniteMeasure.toWeakDualBCNN","decl":"/-- The mapping `toWeakDualBCNN` from finite Borel measures to the weak dual of `Ω →ᵇ ℝ≥0` is\ninjective, if in the underlying space `Ω`, indicator functions of closed sets have decreasing\napproximations by sequences of continuous functions (in particular if `Ω` is pseudometrizable). -/\nlemma injective_toWeakDualBCNN :\n    Injective (toWeakDualBCNN : FiniteMeasure Ω → WeakDual ℝ≥0 (Ω →ᵇ ℝ≥0)) := by\n  intro μ ν hμν\n  apply ext_of_forall_lintegral_eq\n  intro f\n  have key := congr_fun (congrArg DFunLike.coe hμν) f\n  apply (ENNReal.toNNReal_eq_toNNReal_iff' ?_ ?_).mp key\n  · exact (lintegral_lt_top_of_nnreal μ f).ne\n  · exact (lintegral_lt_top_of_nnreal ν f).ne\n\n"}
{"name":"MeasureTheory.FiniteMeasure.isEmbedding_toWeakDualBCNN","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝³ : MeasurableSpace Ω\ninst✝² : TopologicalSpace Ω\ninst✝¹ : HasOuterApproxClosed Ω\ninst✝ : BorelSpace Ω\n⊢ Topology.IsEmbedding MeasureTheory.FiniteMeasure.toWeakDualBCNN","decl":"lemma isEmbedding_toWeakDualBCNN :\n    IsEmbedding (toWeakDualBCNN : FiniteMeasure Ω → WeakDual ℝ≥0 (Ω →ᵇ ℝ≥0)) where\n  eq_induced := rfl\n  injective := injective_toWeakDualBCNN\n\n"}
{"name":"MeasureTheory.FiniteMeasure.embedding_toWeakDualBCNN","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝³ : MeasurableSpace Ω\ninst✝² : TopologicalSpace Ω\ninst✝¹ : HasOuterApproxClosed Ω\ninst✝ : BorelSpace Ω\n⊢ Topology.IsEmbedding MeasureTheory.FiniteMeasure.toWeakDualBCNN","decl":"@[deprecated (since := \"2024-10-26\")]\nalias embedding_toWeakDualBCNN := isEmbedding_toWeakDualBCNN\n\n"}
{"name":"MeasureTheory.FiniteMeasure.t2Space","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝³ : MeasurableSpace Ω\ninst✝² : TopologicalSpace Ω\ninst✝¹ : HasOuterApproxClosed Ω\ninst✝ : BorelSpace Ω\n⊢ T2Space (MeasureTheory.FiniteMeasure Ω)","decl":"/-- On topological spaces where indicators of closed sets have decreasing approximating sequences of\ncontinuous functions (`HasOuterApproxClosed`), the topology of weak convergence of finite Borel\nmeasures is Hausdorff (`T2Space`). -/\ninstance t2Space : T2Space (FiniteMeasure Ω) := (isEmbedding_toWeakDualBCNN Ω).t2Space\n\n"}
{"name":"MeasureTheory.FiniteMeasure.tendsto_lintegral_nn_of_le_const","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝² : MeasurableSpace Ω\ninst✝¹ : TopologicalSpace Ω\ninst✝ : OpensMeasurableSpace Ω\nμ : MeasureTheory.FiniteMeasure Ω\nfs : Nat → BoundedContinuousFunction Ω NNReal\nc : NNReal\nfs_le_const : ∀ (n : Nat) (ω : Ω), LE.le ((fs n) ω) c\nf : Ω → NNReal\nfs_lim : ∀ (ω : Ω), Filter.Tendsto (fun n => (fs n) ω) Filter.atTop (nhds (f ω))\n⊢ Filter.Tendsto (fun n => MeasureTheory.lintegral ↑μ fun ω => ↑((fs n) ω)) Filter.atTop (nhds (MeasureTheory.lintegral ↑μ fun ω => ↑(f ω)))","decl":"/-- A bounded convergence theorem for a finite measure:\nIf a sequence of bounded continuous non-negative functions are uniformly bounded by a constant\nand tend pointwise to a limit, then their integrals (`MeasureTheory.lintegral`) against the finite\nmeasure tend to the integral of the limit.\n\nA related result with more general assumptions is\n`MeasureTheory.tendsto_lintegral_nn_filter_of_le_const`.\n-/\ntheorem tendsto_lintegral_nn_of_le_const (μ : FiniteMeasure Ω) {fs : ℕ → Ω →ᵇ ℝ≥0} {c : ℝ≥0}\n    (fs_le_const : ∀ n ω, fs n ω ≤ c) {f : Ω → ℝ≥0}\n    (fs_lim : ∀ ω, Tendsto (fun n ↦ fs n ω) atTop (𝓝 (f ω))) :\n    Tendsto (fun n ↦ ∫⁻ ω, fs n ω ∂(μ : Measure Ω)) atTop (𝓝 (∫⁻ ω, f ω ∂(μ : Measure Ω))) :=\n  tendsto_lintegral_nn_filter_of_le_const μ\n    (.of_forall fun n ↦ .of_forall (fs_le_const n))\n    (.of_forall fs_lim)\n\n"}
{"name":"MeasureTheory.FiniteMeasure.tendsto_testAgainstNN_filter_of_le_const","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝³ : MeasurableSpace Ω\ninst✝² : TopologicalSpace Ω\ninst✝¹ : OpensMeasurableSpace Ω\nι : Type u_2\nL : Filter ι\ninst✝ : L.IsCountablyGenerated\nμ : MeasureTheory.FiniteMeasure Ω\nfs : ι → BoundedContinuousFunction Ω NNReal\nc : NNReal\nfs_le_const : Filter.Eventually (fun i => Filter.Eventually (fun ω => LE.le ((fs i) ω) c) (MeasureTheory.ae ↑μ)) L\nf : BoundedContinuousFunction Ω NNReal\nfs_lim : Filter.Eventually (fun ω => Filter.Tendsto (fun i => (fs i) ω) L (nhds (f ω))) (MeasureTheory.ae ↑μ)\n⊢ Filter.Tendsto (fun i => μ.testAgainstNN (fs i)) L (nhds (μ.testAgainstNN f))","decl":"/-- A bounded convergence theorem for a finite measure:\nIf bounded continuous non-negative functions are uniformly bounded by a constant and tend to a\nlimit, then their integrals against the finite measure tend to the integral of the limit.\nThis formulation assumes:\n * the functions tend to a limit along a countably generated filter;\n * the limit is in the almost everywhere sense;\n * boundedness holds almost everywhere;\n * integration is the pairing against non-negative continuous test functions\n   (`MeasureTheory.FiniteMeasure.testAgainstNN`).\n\nA related result using `MeasureTheory.lintegral` for integration is\n`MeasureTheory.FiniteMeasure.tendsto_lintegral_nn_filter_of_le_const`.\n-/\ntheorem tendsto_testAgainstNN_filter_of_le_const {ι : Type*} {L : Filter ι}\n    [L.IsCountablyGenerated] {μ : FiniteMeasure Ω} {fs : ι → Ω →ᵇ ℝ≥0} {c : ℝ≥0}\n    (fs_le_const : ∀ᶠ i in L, ∀ᵐ ω : Ω ∂(μ : Measure Ω), fs i ω ≤ c) {f : Ω →ᵇ ℝ≥0}\n    (fs_lim : ∀ᵐ ω : Ω ∂(μ : Measure Ω), Tendsto (fun i ↦ fs i ω) L (𝓝 (f ω))) :\n    Tendsto (fun i ↦ μ.testAgainstNN (fs i)) L (𝓝 (μ.testAgainstNN f)) := by\n  apply (ENNReal.tendsto_toNNReal (f.lintegral_lt_top_of_nnreal (μ : Measure Ω)).ne).comp\n  exact tendsto_lintegral_nn_filter_of_le_const (Ω := Ω) μ fs_le_const fs_lim\n\n"}
{"name":"MeasureTheory.FiniteMeasure.tendsto_testAgainstNN_of_le_const","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝² : MeasurableSpace Ω\ninst✝¹ : TopologicalSpace Ω\ninst✝ : OpensMeasurableSpace Ω\nμ : MeasureTheory.FiniteMeasure Ω\nfs : Nat → BoundedContinuousFunction Ω NNReal\nc : NNReal\nfs_le_const : ∀ (n : Nat) (ω : Ω), LE.le ((fs n) ω) c\nf : BoundedContinuousFunction Ω NNReal\nfs_lim : ∀ (ω : Ω), Filter.Tendsto (fun n => (fs n) ω) Filter.atTop (nhds (f ω))\n⊢ Filter.Tendsto (fun n => μ.testAgainstNN (fs n)) Filter.atTop (nhds (μ.testAgainstNN f))","decl":"/-- A bounded convergence theorem for a finite measure:\nIf a sequence of bounded continuous non-negative functions are uniformly bounded by a constant and\ntend pointwise to a limit, then their integrals (`MeasureTheory.FiniteMeasure.testAgainstNN`)\nagainst the finite measure tend to the integral of the limit.\n\nRelated results:\n * `MeasureTheory.FiniteMeasure.tendsto_testAgainstNN_filter_of_le_const`:\n   more general assumptions\n * `MeasureTheory.FiniteMeasure.tendsto_lintegral_nn_of_le_const`:\n   using `MeasureTheory.lintegral` for integration.\n-/\ntheorem tendsto_testAgainstNN_of_le_const {μ : FiniteMeasure Ω} {fs : ℕ → Ω →ᵇ ℝ≥0} {c : ℝ≥0}\n    (fs_le_const : ∀ n ω, fs n ω ≤ c) {f : Ω →ᵇ ℝ≥0}\n    (fs_lim : ∀ ω, Tendsto (fun n ↦ fs n ω) atTop (𝓝 (f ω))) :\n    Tendsto (fun n ↦ μ.testAgainstNN (fs n)) atTop (𝓝 (μ.testAgainstNN f)) :=\n  tendsto_testAgainstNN_filter_of_le_const\n    (.of_forall fun n ↦ .of_forall (fs_le_const n))\n    (.of_forall fs_lim)\n\n"}
{"name":"MeasureTheory.FiniteMeasure.tendsto_of_forall_integral_tendsto","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝² : MeasurableSpace Ω\ninst✝¹ : TopologicalSpace Ω\ninst✝ : OpensMeasurableSpace Ω\nγ : Type u_2\nF : Filter γ\nμs : γ → MeasureTheory.FiniteMeasure Ω\nμ : MeasureTheory.FiniteMeasure Ω\nh : ∀ (f : BoundedContinuousFunction Ω Real), Filter.Tendsto (fun i => MeasureTheory.integral ↑(μs i) fun x => f x) F (nhds (MeasureTheory.integral ↑μ fun x => f x))\n⊢ Filter.Tendsto μs F (nhds μ)","decl":"theorem tendsto_of_forall_integral_tendsto {γ : Type*} {F : Filter γ} {μs : γ → FiniteMeasure Ω}\n    {μ : FiniteMeasure Ω}\n    (h : ∀ f : Ω →ᵇ ℝ,\n          Tendsto (fun i ↦ ∫ x, f x ∂(μs i : Measure Ω)) F (𝓝 (∫ x, f x ∂(μ : Measure Ω)))) :\n    Tendsto μs F (𝓝 μ) := by\n  apply tendsto_iff_forall_lintegral_tendsto.mpr\n  intro f\n  apply (ENNReal.tendsto_toReal_iff (fi := F)\n      (fun i ↦ (f.lintegral_lt_top_of_nnreal (μs i)).ne) (f.lintegral_lt_top_of_nnreal μ).ne).mp\n  have lip : LipschitzWith 1 ((↑) : ℝ≥0 → ℝ) := isometry_subtype_coe.lipschitz\n  set f₀ := BoundedContinuousFunction.comp _ lip f with _def_f₀\n  have f₀_eq : ⇑f₀ = ((↑) : ℝ≥0 → ℝ) ∘ ⇑f := rfl\n  have f₀_nn : 0 ≤ ⇑f₀ := fun _ ↦ by\n    simp only [f₀_eq, Pi.zero_apply, Function.comp_apply, NNReal.zero_le_coe]\n  have f₀_ae_nn : 0 ≤ᵐ[(μ : Measure Ω)] ⇑f₀ := .of_forall f₀_nn\n  have f₀_ae_nns : ∀ i, 0 ≤ᵐ[(μs i : Measure Ω)] ⇑f₀ := fun i ↦ .of_forall f₀_nn\n  have aux :=\n    integral_eq_lintegral_of_nonneg_ae f₀_ae_nn f₀.continuous.measurable.aestronglyMeasurable\n  have auxs := fun i ↦\n    integral_eq_lintegral_of_nonneg_ae (f₀_ae_nns i) f₀.continuous.measurable.aestronglyMeasurable\n  simp_rw [f₀_eq, Function.comp_apply, ENNReal.ofReal_coe_nnreal] at aux auxs\n  simpa only [← aux, ← auxs] using h f₀\n\n"}
{"name":"MeasureTheory.FiniteMeasure.tendsto_iff_forall_integral_tendsto","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\ninst✝² : MeasurableSpace Ω\ninst✝¹ : TopologicalSpace Ω\ninst✝ : OpensMeasurableSpace Ω\nγ : Type u_2\nF : Filter γ\nμs : γ → MeasureTheory.FiniteMeasure Ω\nμ : MeasureTheory.FiniteMeasure Ω\n⊢ Iff (Filter.Tendsto μs F (nhds μ)) (∀ (f : BoundedContinuousFunction Ω Real), Filter.Tendsto (fun i => MeasureTheory.integral ↑(μs i) fun x => f x) F (nhds (MeasureTheory.integral ↑μ fun x => f x)))","decl":"/-- A characterization of weak convergence in terms of integrals of bounded continuous\nreal-valued functions. -/\ntheorem tendsto_iff_forall_integral_tendsto {γ : Type*} {F : Filter γ} {μs : γ → FiniteMeasure Ω}\n    {μ : FiniteMeasure Ω} :\n    Tendsto μs F (𝓝 μ) ↔\n      ∀ f : Ω →ᵇ ℝ,\n        Tendsto (fun i ↦ ∫ x, f x ∂(μs i : Measure Ω)) F (𝓝 (∫ x, f x ∂(μ : Measure Ω))) := by\n  refine ⟨?_, tendsto_of_forall_integral_tendsto⟩\n  rw [tendsto_iff_forall_lintegral_tendsto]\n  intro h f\n  simp_rw [BoundedContinuousFunction.integral_eq_integral_nnrealPart_sub]\n  set f_pos := f.nnrealPart with _def_f_pos\n  set f_neg := (-f).nnrealPart with _def_f_neg\n  have tends_pos := (ENNReal.tendsto_toReal (f_pos.lintegral_lt_top_of_nnreal μ).ne).comp (h f_pos)\n  have tends_neg := (ENNReal.tendsto_toReal (f_neg.lintegral_lt_top_of_nnreal μ).ne).comp (h f_neg)\n  have aux :\n    ∀ g : Ω →ᵇ ℝ≥0,\n      (ENNReal.toReal ∘ fun i : γ ↦ ∫⁻ x : Ω, ↑(g x) ∂(μs i : Measure Ω)) =\n        fun i : γ ↦ (∫⁻ x : Ω, ↑(g x) ∂(μs i : Measure Ω)).toReal :=\n    fun _ ↦ rfl\n  simp_rw [aux, BoundedContinuousFunction.toReal_lintegral_coe_eq_integral] at tends_pos tends_neg\n  exact Tendsto.sub tends_pos tends_neg\n\n"}
{"name":"MeasureTheory.FiniteMeasure.continuous_integral_boundedContinuousFunction","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"α : Type u_2\ninst✝² : TopologicalSpace α\ninst✝¹ : MeasurableSpace α\ninst✝ : OpensMeasurableSpace α\nf : BoundedContinuousFunction α Real\n⊢ Continuous fun μ => MeasureTheory.integral ↑μ fun x => f x","decl":"lemma continuous_integral_boundedContinuousFunction\n    {α : Type*} [TopologicalSpace α] [MeasurableSpace α] [OpensMeasurableSpace α] (f : α →ᵇ ℝ) :\n    Continuous fun μ : FiniteMeasure α ↦ ∫ x, f x ∂μ := by\n  rw [continuous_iff_continuousAt]\n  intro μ\n  exact continuousAt_of_tendsto_nhds\n    (FiniteMeasure.tendsto_iff_forall_integral_tendsto.mp tendsto_id f)\n\n"}
{"name":"MeasureTheory.FiniteMeasure.toMeasure_map","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\nΩ' : Type u_2\ninst✝¹ : MeasurableSpace Ω\ninst✝ : MeasurableSpace Ω'\nν : MeasureTheory.FiniteMeasure Ω\nf : Ω → Ω'\n⊢ Eq (↑(ν.map f)) (MeasureTheory.Measure.map f ↑ν)","decl":"@[simp] lemma toMeasure_map (ν : FiniteMeasure Ω) (f : Ω → Ω') :\n    (ν.map f).toMeasure = ν.toMeasure.map f := rfl\n\n"}
{"name":"MeasureTheory.FiniteMeasure.map_apply'","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\nΩ' : Type u_2\ninst✝¹ : MeasurableSpace Ω\ninst✝ : MeasurableSpace Ω'\nν : MeasureTheory.FiniteMeasure Ω\nf : Ω → Ω'\nf_aemble : AEMeasurable f ↑ν\nA : Set Ω'\nA_mble : MeasurableSet A\n⊢ Eq (↑(ν.map f) A) (↑ν (Set.preimage f A))","decl":"/-- Note that this is an equality of elements of `ℝ≥0∞`. See also\n`MeasureTheory.FiniteMeasure.map_apply` for the corresponding equality as elements of `ℝ≥0`. -/\nlemma map_apply' (ν : FiniteMeasure Ω) {f : Ω → Ω'} (f_aemble : AEMeasurable f ν)\n    {A : Set Ω'} (A_mble : MeasurableSet A) :\n    (ν.map f : Measure Ω') A = (ν : Measure Ω) (f ⁻¹' A) :=\n  Measure.map_apply_of_aemeasurable f_aemble A_mble\n\n"}
{"name":"MeasureTheory.FiniteMeasure.map_apply_of_aemeasurable","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\nΩ' : Type u_2\ninst✝¹ : MeasurableSpace Ω\ninst✝ : MeasurableSpace Ω'\nν : MeasureTheory.FiniteMeasure Ω\nf : Ω → Ω'\nf_aemble : AEMeasurable f ↑ν\nA : Set Ω'\nA_mble : MeasurableSet A\n⊢ Eq ((ν.map f) A) (ν (Set.preimage f A))","decl":"lemma map_apply_of_aemeasurable (ν : FiniteMeasure Ω) {f : Ω → Ω'} (f_aemble : AEMeasurable f ν)\n    {A : Set Ω'} (A_mble : MeasurableSet A) :\n    ν.map f A = ν (f ⁻¹' A) := by\n  have key := ν.map_apply' f_aemble A_mble\n  exact (ENNReal.toNNReal_eq_toNNReal_iff' (measure_ne_top _ _) (measure_ne_top _ _)).mpr key\n\n"}
{"name":"MeasureTheory.FiniteMeasure.map_apply","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\nΩ' : Type u_2\ninst✝¹ : MeasurableSpace Ω\ninst✝ : MeasurableSpace Ω'\nν : MeasureTheory.FiniteMeasure Ω\nf : Ω → Ω'\nf_mble : Measurable f\nA : Set Ω'\nA_mble : MeasurableSet A\n⊢ Eq ((ν.map f) A) (ν (Set.preimage f A))","decl":"lemma map_apply (ν : FiniteMeasure Ω) {f : Ω → Ω'} (f_mble : Measurable f)\n    {A : Set Ω'} (A_mble : MeasurableSet A) :\n    ν.map f A = ν (f ⁻¹' A) :=\n  map_apply_of_aemeasurable ν f_mble.aemeasurable A_mble\n\n"}
{"name":"MeasureTheory.FiniteMeasure.map_add","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\nΩ' : Type u_2\ninst✝¹ : MeasurableSpace Ω\ninst✝ : MeasurableSpace Ω'\nf : Ω → Ω'\nf_mble : Measurable f\nν₁ ν₂ : MeasureTheory.FiniteMeasure Ω\n⊢ Eq ((HAdd.hAdd ν₁ ν₂).map f) (HAdd.hAdd (ν₁.map f) (ν₂.map f))","decl":"@[simp] lemma map_add {f : Ω → Ω'} (f_mble : Measurable f) (ν₁ ν₂ : FiniteMeasure Ω) :\n    (ν₁ + ν₂).map f = ν₁.map f + ν₂.map f := by\n  ext s s_mble\n  simp only [map_apply' _ f_mble.aemeasurable s_mble, toMeasure_add, Measure.add_apply]\n\n"}
{"name":"MeasureTheory.FiniteMeasure.map_smul","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\nΩ' : Type u_2\ninst✝¹ : MeasurableSpace Ω\ninst✝ : MeasurableSpace Ω'\nf : Ω → Ω'\nc : NNReal\nν : MeasureTheory.FiniteMeasure Ω\n⊢ Eq ((HSMul.hSMul c ν).map f) (HSMul.hSMul c (ν.map f))","decl":"@[simp] lemma map_smul {f : Ω → Ω'} (c : ℝ≥0) (ν : FiniteMeasure Ω) :\n    (c • ν).map f = c • (ν.map f) := by\n  ext s _\n  simp [toMeasure_smul]\n\n"}
{"name":"MeasureTheory.FiniteMeasure.tendsto_map_of_tendsto_of_continuous","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\nΩ' : Type u_2\ninst✝⁵ : MeasurableSpace Ω\ninst✝⁴ : MeasurableSpace Ω'\ninst✝³ : TopologicalSpace Ω\ninst✝² : OpensMeasurableSpace Ω\ninst✝¹ : TopologicalSpace Ω'\ninst✝ : BorelSpace Ω'\nι : Type u_3\nL : Filter ι\nνs : ι → MeasureTheory.FiniteMeasure Ω\nν : MeasureTheory.FiniteMeasure Ω\nlim : Filter.Tendsto νs L (nhds ν)\nf : Ω → Ω'\nf_cont : Continuous f\n⊢ Filter.Tendsto (fun i => (νs i).map f) L (nhds (ν.map f))","decl":"/-- If `f : X → Y` is continuous and `Y` is equipped with the Borel sigma algebra, then\n(weak) convergence of `FiniteMeasure`s on `X` implies (weak) convergence of the push-forwards\nof these measures by `f`. -/\nlemma tendsto_map_of_tendsto_of_continuous {ι : Type*} {L : Filter ι}\n    (νs : ι → FiniteMeasure Ω) (ν : FiniteMeasure Ω) (lim : Tendsto νs L (𝓝 ν))\n    {f : Ω → Ω'} (f_cont : Continuous f) :\n    Tendsto (fun i ↦ (νs i).map f) L (𝓝 (ν.map f)) := by\n  rw [FiniteMeasure.tendsto_iff_forall_lintegral_tendsto] at lim ⊢\n  intro g\n  convert lim (g.compContinuous ⟨f, f_cont⟩) <;>\n  · simp only [map, compContinuous_apply, ContinuousMap.coe_mk]\n    refine lintegral_map ?_ f_cont.measurable\n    exact (ENNReal.continuous_coe.comp g.continuous).measurable\n\n"}
{"name":"MeasureTheory.FiniteMeasure.continuous_map","module":"Mathlib.MeasureTheory.Measure.FiniteMeasure","initialProofState":"Ω : Type u_1\nΩ' : Type u_2\ninst✝⁵ : MeasurableSpace Ω\ninst✝⁴ : MeasurableSpace Ω'\ninst✝³ : TopologicalSpace Ω\ninst✝² : OpensMeasurableSpace Ω\ninst✝¹ : TopologicalSpace Ω'\ninst✝ : BorelSpace Ω'\nf : Ω → Ω'\nf_cont : Continuous f\n⊢ Continuous fun ν => ν.map f","decl":"/-- If `f : X → Y` is continuous and `Y` is equipped with the Borel sigma algebra, then\nthe push-forward of finite measures `f* : FiniteMeasure X → FiniteMeasure Y` is continuous\n(in the topologies of weak convergence of measures). -/\nlemma continuous_map {f : Ω → Ω'} (f_cont : Continuous f) :\n    Continuous (fun ν ↦ FiniteMeasure.map ν f) := by\n  rw [continuous_iff_continuousAt]\n  exact fun _ ↦ tendsto_map_of_tendsto_of_continuous _ _ continuous_id.continuousAt f_cont\n\n"}
