{"name":"Finsupp.tail_apply","module":"Mathlib.Data.Finsupp.Fin","initialProofState":"n : Nat\ni : Fin n\nM : Type u_1\ninst✝ : Zero M\nt : Finsupp (Fin (HAdd.hAdd n 1)) M\n⊢ Eq (t.tail i) (t i.succ)","decl":"theorem tail_apply : tail t i = t i.succ :=\n  rfl\n\n"}
{"name":"Finsupp.cons_zero","module":"Mathlib.Data.Finsupp.Fin","initialProofState":"n : Nat\nM : Type u_1\ninst✝ : Zero M\ny : M\ns : Finsupp (Fin n) M\n⊢ Eq ((Finsupp.cons y s) 0) y","decl":"@[simp]\ntheorem cons_zero : cons y s 0 = y :=\n  rfl\n\n"}
{"name":"Finsupp.cons_succ","module":"Mathlib.Data.Finsupp.Fin","initialProofState":"n : Nat\ni : Fin n\nM : Type u_1\ninst✝ : Zero M\ny : M\ns : Finsupp (Fin n) M\n⊢ Eq ((Finsupp.cons y s) i.succ) (s i)","decl":"@[simp]\ntheorem cons_succ : cons y s i.succ = s i :=\n  rfl\n\n"}
{"name":"Finsupp.tail_cons","module":"Mathlib.Data.Finsupp.Fin","initialProofState":"n : Nat\nM : Type u_1\ninst✝ : Zero M\ny : M\ns : Finsupp (Fin n) M\n⊢ Eq (Finsupp.cons y s).tail s","decl":"@[simp]\ntheorem tail_cons : tail (cons y s) = s :=\n  ext fun k => by simp only [tail_apply, cons_succ]\n\n"}
{"name":"Finsupp.tail_update_zero","module":"Mathlib.Data.Finsupp.Fin","initialProofState":"n : Nat\nM : Type u_1\ninst✝ : Zero M\ny : M\nt : Finsupp (Fin (HAdd.hAdd n 1)) M\n⊢ Eq (t.update 0 y).tail t.tail","decl":"@[simp]\ntheorem tail_update_zero : tail (update t 0 y) = tail t := by simp [tail]\n\n"}
{"name":"Finsupp.tail_update_succ","module":"Mathlib.Data.Finsupp.Fin","initialProofState":"n : Nat\ni : Fin n\nM : Type u_1\ninst✝ : Zero M\ny : M\nt : Finsupp (Fin (HAdd.hAdd n 1)) M\n⊢ Eq (t.update i.succ y).tail (t.tail.update i y)","decl":"@[simp]\ntheorem tail_update_succ : tail (update t i.succ y) = update (tail t) i y := by ext; simp [tail]\n\n"}
{"name":"Finsupp.cons_tail","module":"Mathlib.Data.Finsupp.Fin","initialProofState":"n : Nat\nM : Type u_1\ninst✝ : Zero M\nt : Finsupp (Fin (HAdd.hAdd n 1)) M\n⊢ Eq (Finsupp.cons (t 0) t.tail) t","decl":"@[simp]\ntheorem cons_tail : cons (t 0) (tail t) = t := by\n  ext a\n  by_cases c_a : a = 0\n  · rw [c_a, cons_zero]\n  · rw [← Fin.succ_pred a c_a, cons_succ, ← tail_apply]\n\n"}
{"name":"Finsupp.cons_zero_zero","module":"Mathlib.Data.Finsupp.Fin","initialProofState":"n : Nat\nM : Type u_1\ninst✝ : Zero M\n⊢ Eq (Finsupp.cons 0 0) 0","decl":"@[simp]\ntheorem cons_zero_zero : cons 0 (0 : Fin n →₀ M) = 0 := by\n  ext a\n  by_cases c : a = 0\n  · simp [c]\n  · rw [← Fin.succ_pred a c, cons_succ]\n    simp\n\n"}
{"name":"Finsupp.cons_ne_zero_of_left","module":"Mathlib.Data.Finsupp.Fin","initialProofState":"n : Nat\nM : Type u_1\ninst✝ : Zero M\ny : M\ns : Finsupp (Fin n) M\nh : Ne y 0\n⊢ Ne (Finsupp.cons y s) 0","decl":"theorem cons_ne_zero_of_left (h : y ≠ 0) : cons y s ≠ 0 := by\n  contrapose! h with c\n  rw [← cons_zero y s, c, Finsupp.coe_zero, Pi.zero_apply]\n\n"}
{"name":"Finsupp.cons_ne_zero_of_right","module":"Mathlib.Data.Finsupp.Fin","initialProofState":"n : Nat\nM : Type u_1\ninst✝ : Zero M\ny : M\ns : Finsupp (Fin n) M\nh : Ne s 0\n⊢ Ne (Finsupp.cons y s) 0","decl":"theorem cons_ne_zero_of_right (h : s ≠ 0) : cons y s ≠ 0 := by\n  contrapose! h with c\n  ext a\n  simp [← cons_succ a y s, c]\n\n"}
{"name":"Finsupp.cons_ne_zero_iff","module":"Mathlib.Data.Finsupp.Fin","initialProofState":"n : Nat\nM : Type u_1\ninst✝ : Zero M\ny : M\ns : Finsupp (Fin n) M\n⊢ Iff (Ne (Finsupp.cons y s) 0) (Or (Ne y 0) (Ne s 0))","decl":"theorem cons_ne_zero_iff : cons y s ≠ 0 ↔ y ≠ 0 ∨ s ≠ 0 := by\n  refine ⟨fun h => ?_, fun h => h.casesOn cons_ne_zero_of_left cons_ne_zero_of_right⟩\n  refine imp_iff_not_or.1 fun h' c => h ?_\n  rw [h', c, Finsupp.cons_zero_zero]\n\n"}
{"name":"Finsupp.cons_support","module":"Mathlib.Data.Finsupp.Fin","initialProofState":"n : Nat\nM : Type u_1\ninst✝ : Zero M\ny : M\ns : Finsupp (Fin n) M\n⊢ HasSubset.Subset (Finsupp.cons y s).support (Insert.insert 0 (Finset.map (Fin.succEmb n) s.support))","decl":"lemma cons_support : (s.cons y).support ⊆ insert 0 (s.support.map (Fin.succEmb n)) := by\n  intro i hi\n  suffices i = 0 ∨ ∃ a, ¬s a = 0 ∧ a.succ = i by simpa\n  apply (Fin.eq_zero_or_eq_succ i).imp id (Exists.imp _)\n  rintro i rfl\n  simpa [Finsupp.mem_support_iff] using hi\n\n"}
{"name":"Finsupp.cons_right_injective","module":"Mathlib.Data.Finsupp.Fin","initialProofState":"n : Nat\nM : Type u_2\ninst✝ : Zero M\ny : M\n⊢ Function.Injective (Finsupp.cons y)","decl":"lemma cons_right_injective {n : ℕ} {M : Type*} [Zero M] (y : M) :\n    Injective (Finsupp.cons y : (Fin n →₀ M) → Fin (n + 1) →₀ M) :=\n  (equivFunOnFinite.symm.injective.comp ((Fin.cons_right_injective _).comp DFunLike.coe_injective))\n\n"}
