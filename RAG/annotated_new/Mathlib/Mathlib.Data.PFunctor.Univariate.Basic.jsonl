{"name":"PFunctor.mk.sizeOf_spec","module":"Mathlib.Data.PFunctor.Univariate.Basic","initialProofState":"A : Type u\nB : A → Type u\n⊢ Eq (SizeOf.sizeOf { A := A, B := B }) (HAdd.hAdd 1 (SizeOf.sizeOf A))","decl":"/-- A polynomial functor `P` is given by a type `A` and a family `B` of types over `A`. `P` maps\nany type `α` to a new type `P α`, which is defined as the sigma type `Σ x, P.B x → α`.\n\nAn element of `P α` is a pair `⟨a, f⟩`, where `a` is an element of a type `A` and\n`f : B a → α`. Think of `a` as the shape of the object and `f` as an index to the relevant\nelements of `α`.\n-/\n@[pp_with_univ]\nstructure PFunctor where\n  /-- The head type -/\n  A : Type u\n  /-- The child family of types -/\n  B : A → Type u\n\n"}
{"name":"PFunctor.mk.inj","module":"Mathlib.Data.PFunctor.Univariate.Basic","initialProofState":"A✝ : Type u\nB✝ : A✝ → Type u\nA : Type u\nB : A → Type u\nx✝ : Eq { A := A✝, B := B✝ } { A := A, B := B }\n⊢ And (Eq A✝ A) (HEq B✝ B)","decl":"/-- A polynomial functor `P` is given by a type `A` and a family `B` of types over `A`. `P` maps\nany type `α` to a new type `P α`, which is defined as the sigma type `Σ x, P.B x → α`.\n\nAn element of `P α` is a pair `⟨a, f⟩`, where `a` is an element of a type `A` and\n`f : B a → α`. Think of `a` as the shape of the object and `f` as an index to the relevant\nelements of `α`.\n-/\n@[pp_with_univ]\nstructure PFunctor where\n  /-- The head type -/\n  A : Type u\n  /-- The child family of types -/\n  B : A → Type u\n\n"}
{"name":"PFunctor.mk.injEq","module":"Mathlib.Data.PFunctor.Univariate.Basic","initialProofState":"A✝ : Type u\nB✝ : A✝ → Type u\nA : Type u\nB : A → Type u\n⊢ Eq (Eq { A := A✝, B := B✝ } { A := A, B := B }) (And (Eq A✝ A) (HEq B✝ B))","decl":"/-- A polynomial functor `P` is given by a type `A` and a family `B` of types over `A`. `P` maps\nany type `α` to a new type `P α`, which is defined as the sigma type `Σ x, P.B x → α`.\n\nAn element of `P α` is a pair `⟨a, f⟩`, where `a` is an element of a type `A` and\n`f : B a → α`. Think of `a` as the shape of the object and `f` as an index to the relevant\nelements of `α`.\n-/\n@[pp_with_univ]\nstructure PFunctor where\n  /-- The head type -/\n  A : Type u\n  /-- The child family of types -/\n  B : A → Type u\n\n"}
{"name":"PFunctor.map_eq_map","module":"Mathlib.Data.PFunctor.Univariate.Basic","initialProofState":"P : PFunctor.{u}\nα β : Type v\nf : α → β\nx : ↑P α\n⊢ Eq (Functor.map f x) (P.map f x)","decl":"/-- We prefer `PFunctor.map` to `Functor.map` because it is universe-polymorphic. -/\n@[simp]\ntheorem map_eq_map {α β : Type v} (f : α → β) (x : P α) : f <$> x = P.map f x :=\n  rfl\n\n"}
{"name":"PFunctor.map_eq","module":"Mathlib.Data.PFunctor.Univariate.Basic","initialProofState":"P : PFunctor.{u}\nα : Type v₁\nβ : Type v₂\nf : α → β\na : P.A\ng : P.B a → α\n⊢ Eq (P.map f ⟨a, g⟩) ⟨a, Function.comp f g⟩","decl":"@[simp]\nprotected theorem map_eq (f : α → β) (a : P.A) (g : P.B a → α) :\n    P.map f ⟨a, g⟩ = ⟨a, f ∘ g⟩ :=\n  rfl\n\n"}
{"name":"PFunctor.id_map","module":"Mathlib.Data.PFunctor.Univariate.Basic","initialProofState":"P : PFunctor.{u}\nα : Type v₁\nx : ↑P α\n⊢ Eq (P.map id x) x","decl":"@[simp]\nprotected theorem id_map : ∀ x : P α, P.map id x = x := fun ⟨_, _⟩ => rfl\n\n"}
{"name":"PFunctor.map_map","module":"Mathlib.Data.PFunctor.Univariate.Basic","initialProofState":"P : PFunctor.{u}\nα : Type v₁\nβ : Type v₂\nγ : Type v₃\nf : α → β\ng : β → γ\nx : ↑P α\n⊢ Eq (P.map g (P.map f x)) (P.map (Function.comp g f) x)","decl":"@[simp]\nprotected theorem map_map (f : α → β) (g : β → γ) :\n    ∀ x : P α, P.map g (P.map f x) = P.map (g ∘ f) x := fun ⟨_, _⟩ => rfl\n\n"}
{"name":"PFunctor.instLawfulFunctorObj","module":"Mathlib.Data.PFunctor.Univariate.Basic","initialProofState":"P : PFunctor.{u}\n⊢ LawfulFunctor ↑P","decl":"instance : LawfulFunctor.{v, max u v} P.Obj where\n  map_const := rfl\n  id_map x := P.id_map x\n  comp_map f g x := P.map_map f g x |>.symm\n\n"}
{"name":"PFunctor.W.dest_mk","module":"Mathlib.Data.PFunctor.Univariate.Basic","initialProofState":"P : PFunctor.{u}\np : ↑P P.W\n⊢ Eq (PFunctor.W.mk p).dest p","decl":"@[simp]\ntheorem W.dest_mk (p : P (W P)) : W.dest (W.mk p) = p := by cases p; rfl\n\n"}
{"name":"PFunctor.W.mk_dest","module":"Mathlib.Data.PFunctor.Univariate.Basic","initialProofState":"P : PFunctor.{u}\np : P.W\n⊢ Eq (PFunctor.W.mk p.dest) p","decl":"@[simp]\ntheorem W.mk_dest (p : W P) : W.mk (W.dest p) = p := by cases p; rfl\n\n"}
{"name":"PFunctor.fst_map","module":"Mathlib.Data.PFunctor.Univariate.Basic","initialProofState":"P : PFunctor.{u}\nα : Type v₁\nβ : Type v₂\nx : ↑P α\nf : α → β\n⊢ Eq (P.map f x).fst x.fst","decl":"@[simp]\ntheorem fst_map (x : P α) (f : α → β) : (P.map f x).1 = x.1 := by cases x; rfl\n\n"}
{"name":"PFunctor.iget_map","module":"Mathlib.Data.PFunctor.Univariate.Basic","initialProofState":"P : PFunctor.{u}\nα : Type v₁\nβ : Type v₂\ninst✝² : DecidableEq P.A\ninst✝¹ : Inhabited α\ninst✝ : Inhabited β\nx : ↑P α\nf : α → β\ni : P.Idx\nh : Eq i.fst x.fst\n⊢ Eq ((P.map f x).iget i) (f (x.iget i))","decl":"@[simp]\ntheorem iget_map [DecidableEq P.A] [Inhabited α] [Inhabited β] (x : P α)\n    (f : α → β) (i : P.Idx) (h : i.1 = x.1) : (P.map f x).iget i = f (x.iget i) := by\n  simp only [Obj.iget, fst_map, *, dif_pos, eq_self_iff_true]\n  cases x\n  rfl\n\n"}
{"name":"PFunctor.liftp_iff","module":"Mathlib.Data.PFunctor.Univariate.Basic","initialProofState":"P : PFunctor.{u}\nα : Type u\np : α → Prop\nx : ↑P α\n⊢ Iff (Functor.Liftp p x) (Exists fun a => Exists fun f => And (Eq x ⟨a, f⟩) (∀ (i : P.B a), p (f i)))","decl":"theorem liftp_iff {α : Type u} (p : α → Prop) (x : P α) :\n    Liftp p x ↔ ∃ a f, x = ⟨a, f⟩ ∧ ∀ i, p (f i) := by\n  constructor\n  · rintro ⟨y, hy⟩\n    cases' h : y with a f\n    refine ⟨a, fun i => (f i).val, ?_, fun i => (f i).property⟩\n    rw [← hy, h, map_eq_map, PFunctor.map_eq]\n    congr\n  rintro ⟨a, f, xeq, pf⟩\n  use ⟨a, fun i => ⟨f i, pf i⟩⟩\n  rw [xeq]; rfl\n\n"}
{"name":"PFunctor.liftp_iff'","module":"Mathlib.Data.PFunctor.Univariate.Basic","initialProofState":"P : PFunctor.{u}\nα : Type u\np : α → Prop\na : P.A\nf : P.B a → α\n⊢ Iff (Functor.Liftp p ⟨a, f⟩) (∀ (i : P.B a), p (f i))","decl":"theorem liftp_iff' {α : Type u} (p : α → Prop) (a : P.A) (f : P.B a → α) :\n    @Liftp.{u} P.Obj _ α p ⟨a, f⟩ ↔ ∀ i, p (f i) := by\n  simp only [liftp_iff, Sigma.mk.inj_iff]; constructor <;> intro h\n  · rcases h with ⟨a', f', heq, h'⟩\n    cases heq\n    assumption\n  repeat' first |constructor|assumption\n\n"}
{"name":"PFunctor.liftr_iff","module":"Mathlib.Data.PFunctor.Univariate.Basic","initialProofState":"P : PFunctor.{u}\nα : Type u\nr : α → α → Prop\nx y : ↑P α\n⊢ Iff (Functor.Liftr r x y) (Exists fun a => Exists fun f₀ => Exists fun f₁ => And (Eq x ⟨a, f₀⟩) (And (Eq y ⟨a, f₁⟩) (∀ (i : P.B a), r (f₀ i) (f₁ i))))","decl":"theorem liftr_iff {α : Type u} (r : α → α → Prop) (x y : P α) :\n    Liftr r x y ↔ ∃ a f₀ f₁, x = ⟨a, f₀⟩ ∧ y = ⟨a, f₁⟩ ∧ ∀ i, r (f₀ i) (f₁ i) := by\n  constructor\n  · rintro ⟨u, xeq, yeq⟩\n    cases' h : u with a f\n    use a, fun i => (f i).val.fst, fun i => (f i).val.snd\n    constructor\n    · rw [← xeq, h]\n      rfl\n    constructor\n    · rw [← yeq, h]\n      rfl\n    intro i\n    exact (f i).property\n  rintro ⟨a, f₀, f₁, xeq, yeq, h⟩\n  use ⟨a, fun i => ⟨(f₀ i, f₁ i), h i⟩⟩\n  constructor\n  · rw [xeq]\n    rfl\n  rw [yeq]; rfl\n\n"}
{"name":"PFunctor.supp_eq","module":"Mathlib.Data.PFunctor.Univariate.Basic","initialProofState":"P : PFunctor.{u}\nα : Type u\na : P.A\nf : P.B a → α\n⊢ Eq (Functor.supp ⟨a, f⟩) (Set.image f Set.univ)","decl":"theorem supp_eq {α : Type u} (a : P.A) (f : P.B a → α) :\n    @supp.{u} P.Obj _ α (⟨a, f⟩ : P α) = f '' univ := by\n  ext x; simp only [supp, image_univ, mem_range, mem_setOf_eq]\n  constructor <;> intro h\n  · apply @h fun x => ∃ y : P.B a, f y = x\n    rw [liftp_iff']\n    intro\n    exact ⟨_, rfl⟩\n  · simp only [liftp_iff']\n    cases h\n    subst x\n    tauto\n\n"}
