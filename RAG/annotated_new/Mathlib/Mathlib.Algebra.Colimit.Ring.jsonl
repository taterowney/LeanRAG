{"name":"Ring.DirectLimit.quotientMk_of","module":"Mathlib.Algebra.Colimit.Ring","initialProofState":"ι : Type u_1\ninst✝¹ : Preorder ι\nG : ι → Type u_2\ninst✝ : (i : ι) → CommRing (G i)\nf : (i j : ι) → LE.le i j → G i → G j\ni : ι\nx : G i\n⊢ Eq ((Ideal.Quotient.mk (Ideal.span (setOf fun a => Or (Exists fun i => Exists fun j => Exists fun H => Exists fun x => Eq (HSub.hSub (FreeCommRing.of ⟨j, f i j H x⟩) (FreeCommRing.of ⟨i, x⟩)) a) (Or (Exists fun i => Eq (HSub.hSub (FreeCommRing.of ⟨i, 1⟩) 1) a) (Or (Exists fun i => Exists fun x => Exists fun y => Eq (HSub.hSub (FreeCommRing.of ⟨i, HAdd.hAdd x y⟩) (HAdd.hAdd (FreeCommRing.of ⟨i, x⟩) (FreeCommRing.of ⟨i, y⟩))) a) (Exists fun i => Exists fun x => Exists fun y => Eq (HSub.hSub (FreeCommRing.of ⟨i, HMul.hMul x y⟩) (HMul.hMul (FreeCommRing.of ⟨i, x⟩) (FreeCommRing.of ⟨i, y⟩))) a)))))) (FreeCommRing.of ⟨i, x⟩)) ((Ring.DirectLimit.of G f i) x)","decl":"theorem quotientMk_of (i x) : Ideal.Quotient.mk _ (.of ⟨i, x⟩) = of G f i x :=\n  rfl\n\n"}
{"name":"Ring.DirectLimit.of_f","module":"Mathlib.Algebra.Colimit.Ring","initialProofState":"ι : Type u_1\ninst✝¹ : Preorder ι\nG : ι → Type u_2\ninst✝ : (i : ι) → CommRing (G i)\nf : (i j : ι) → LE.le i j → G i → G j\ni j : ι\nhij : LE.le i j\nx : G i\n⊢ Eq ((Ring.DirectLimit.of G f j) (f i j hij x)) ((Ring.DirectLimit.of G f i) x)","decl":"@[simp] theorem of_f {i j} (hij) (x) : of G f j (f i j hij x) = of G f i x :=\n  Ideal.Quotient.eq.2 <| subset_span <| Or.inl ⟨i, j, hij, x, rfl⟩\n\n"}
{"name":"Ring.DirectLimit.exists_of","module":"Mathlib.Algebra.Colimit.Ring","initialProofState":"ι : Type u_1\ninst✝³ : Preorder ι\nG : ι → Type u_2\ninst✝² : (i : ι) → CommRing (G i)\nf : (i j : ι) → LE.le i j → G i → G j\ninst✝¹ : Nonempty ι\ninst✝ : IsDirected ι fun x1 x2 => LE.le x1 x2\nz : Ring.DirectLimit G f\n⊢ Exists fun i => Exists fun x => Eq ((Ring.DirectLimit.of G f i) x) z","decl":"/-- Every element of the direct limit corresponds to some element in\nsome component of the directed system. -/\ntheorem exists_of [Nonempty ι] [IsDirected ι (· ≤ ·)] (z : DirectLimit G f) :\n    ∃ i x, of G f i x = z := by\n  obtain ⟨z, rfl⟩ := Ideal.Quotient.mk_surjective z\n  refine z.induction_on ⟨Classical.arbitrary ι, -1, by simp⟩ (fun ⟨i, x⟩ ↦ ⟨i, x, rfl⟩) ?_ ?_ <;>\n    rintro x' y' ⟨i, x, hx⟩ ⟨j, y, hy⟩ <;> have ⟨k, hik, hjk⟩ := exists_ge_ge i j\n  · exact ⟨k, f i k hik x + f j k hjk y, by rw [map_add, of_f, of_f, hx, hy]; rfl⟩\n  · exact ⟨k, f i k hik x * f j k hjk y, by rw [map_mul, of_f, of_f, hx, hy]; rfl⟩\n\n"}
{"name":"Ring.DirectLimit.Polynomial.exists_of","module":"Mathlib.Algebra.Colimit.Ring","initialProofState":"ι : Type u_1\ninst✝³ : Preorder ι\nG : ι → Type u_2\ninst✝² : (i : ι) → CommRing (G i)\nf' : (i j : ι) → LE.le i j → RingHom (G i) (G j)\ninst✝¹ : Nonempty ι\ninst✝ : IsDirected ι fun x1 x2 => LE.le x1 x2\nq : Polynomial (Ring.DirectLimit G fun i j h => ⇑(f' i j h))\n⊢ Exists fun i => Exists fun p => Eq (Polynomial.map (Ring.DirectLimit.of G (fun i j h => ⇑(f' i j h)) i) p) q","decl":"nonrec theorem Polynomial.exists_of [Nonempty ι] [IsDirected ι (· ≤ ·)]\n    (q : Polynomial (DirectLimit G fun i j h ↦ f' i j h)) :\n    ∃ i p, Polynomial.map (of G (fun i j h ↦ f' i j h) i) p = q :=\n  Polynomial.induction_on q\n    (fun z ↦\n      let ⟨i, x, h⟩ := exists_of z\n      ⟨i, C x, by rw [map_C, h]⟩)\n    (fun q₁ q₂ ⟨i₁, p₁, ih₁⟩ ⟨i₂, p₂, ih₂⟩ ↦\n      let ⟨i, h1, h2⟩ := exists_ge_ge i₁ i₂\n      ⟨i, p₁.map (f' i₁ i h1) + p₂.map (f' i₂ i h2), by\n        rw [Polynomial.map_add, map_map, map_map, ← ih₁, ← ih₂]\n        congr 2 <;> ext x <;> simp_rw [RingHom.comp_apply, of_f]⟩)\n    fun n z _ ↦\n    let ⟨i, x, h⟩ := exists_of z\n    ⟨i, C x * X ^ (n + 1), by rw [Polynomial.map_mul, map_C, h, Polynomial.map_pow, map_X]⟩\n\n"}
{"name":"Ring.DirectLimit.induction_on","module":"Mathlib.Algebra.Colimit.Ring","initialProofState":"ι : Type u_1\ninst✝³ : Preorder ι\nG : ι → Type u_2\ninst✝² : (i : ι) → CommRing (G i)\nf : (i j : ι) → LE.le i j → G i → G j\ninst✝¹ : Nonempty ι\ninst✝ : IsDirected ι fun x1 x2 => LE.le x1 x2\nC : Ring.DirectLimit G f → Prop\nz : Ring.DirectLimit G f\nih : ∀ (i : ι) (x : G i), C ((Ring.DirectLimit.of G f i) x)\n⊢ C z","decl":"@[elab_as_elim]\ntheorem induction_on [Nonempty ι] [IsDirected ι (· ≤ ·)] {C : DirectLimit G f → Prop}\n    (z : DirectLimit G f) (ih : ∀ i x, C (of G f i x)) : C z :=\n  let ⟨i, x, hx⟩ := exists_of z\n  hx ▸ ih i x\n\n"}
{"name":"Ring.DirectLimit.lift_of","module":"Mathlib.Algebra.Colimit.Ring","initialProofState":"ι : Type u_1\ninst✝² : Preorder ι\nG : ι → Type u_2\ninst✝¹ : (i : ι) → CommRing (G i)\nf : (i j : ι) → LE.le i j → G i → G j\nP : Type u_3\ninst✝ : CommRing P\ng : (i : ι) → RingHom (G i) P\nHg : ∀ (i j : ι) (hij : LE.le i j) (x : G i), Eq ((g j) (f i j hij x)) ((g i) x)\ni : ι\nx : G i\n⊢ Eq ((Ring.DirectLimit.lift G f P g Hg) ((Ring.DirectLimit.of G f i) x)) ((g i) x)","decl":"@[simp] theorem lift_of (i x) : lift G f P g Hg (of G f i x) = g i x :=\n  FreeCommRing.lift_of _ _\n\n"}
{"name":"Ring.DirectLimit.lift_unique","module":"Mathlib.Algebra.Colimit.Ring","initialProofState":"ι : Type u_1\ninst✝² : Preorder ι\nG : ι → Type u_2\ninst✝¹ : (i : ι) → CommRing (G i)\nf : (i j : ι) → LE.le i j → G i → G j\nP : Type u_3\ninst✝ : CommRing P\nF : RingHom (Ring.DirectLimit G f) P\nx : Ring.DirectLimit G f\n⊢ Eq (F x) ((Ring.DirectLimit.lift G f P (fun i => F.comp (Ring.DirectLimit.of G f i)) ⋯) x)","decl":"theorem lift_unique (F : DirectLimit G f →+* P) (x) :\n    F x = lift G f P (fun i ↦ F.comp <| of G f i) (fun i j hij x ↦ by simp) x := by\n  obtain ⟨x, rfl⟩ := Ideal.Quotient.mk_surjective x\n  exact x.induction_on (by simp) (fun _ ↦ .symm <| lift_of ..)\n    (by simp+contextual) (by simp+contextual)\n\n"}
{"name":"Ring.DirectLimit.lift_injective","module":"Mathlib.Algebra.Colimit.Ring","initialProofState":"ι : Type u_1\ninst✝⁴ : Preorder ι\nG : ι → Type u_2\ninst✝³ : (i : ι) → CommRing (G i)\nf : (i j : ι) → LE.le i j → G i → G j\nP : Type u_3\ninst✝² : CommRing P\ng : (i : ι) → RingHom (G i) P\nHg : ∀ (i j : ι) (hij : LE.le i j) (x : G i), Eq ((g j) (f i j hij x)) ((g i) x)\ninst✝¹ : Nonempty ι\ninst✝ : IsDirected ι fun x1 x2 => LE.le x1 x2\ninjective : ∀ (i : ι), Function.Injective ⇑(g i)\n⊢ Function.Injective ⇑(Ring.DirectLimit.lift G f P g Hg)","decl":"lemma lift_injective [Nonempty ι] [IsDirected ι (· ≤ ·)]\n    (injective : ∀ i, Function.Injective <| g i) :\n    Function.Injective (lift G f P g Hg) := by\n  simp_rw [injective_iff_map_eq_zero] at injective ⊢\n  intros z hz\n  induction z using DirectLimit.induction_on with\n  | ih _ g => rw [lift_of] at hz; rw [injective _ g hz, _root_.map_zero]\n\n"}
{"name":"Ring.DirectLimit.ringEquiv_of","module":"Mathlib.Algebra.Colimit.Ring","initialProofState":"ι : Type u_1\ninst✝⁴ : Preorder ι\nG : ι → Type u_2\ninst✝³ : (i : ι) → CommRing (G i)\nf' : (i j : ι) → LE.le i j → RingHom (G i) (G j)\ninst✝² : DirectedSystem G fun i j h => ⇑(f' i j h)\ninst✝¹ : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝ : Nonempty ι\ni : ι\ng : G i\n⊢ Eq ((Ring.DirectLimit.ringEquiv G f') ((Ring.DirectLimit.of G (fun x1 x2 x3 => ⇑(f' x1 x2 x3)) i) g)) (Quotient.mk (DirectLimit.setoid f') ⟨i, g⟩)","decl":"theorem ringEquiv_of [Nonempty ι] {i g} : ringEquiv G f' (of _ _ i g) = ⟦⟨i, g⟩⟧ := by\n  simp [ringEquiv]; rfl\n\n"}
{"name":"Ring.DirectLimit.ringEquiv_symm_mk","module":"Mathlib.Algebra.Colimit.Ring","initialProofState":"ι : Type u_1\ninst✝⁴ : Preorder ι\nG : ι → Type u_2\ninst✝³ : (i : ι) → CommRing (G i)\nf' : (i j : ι) → LE.le i j → RingHom (G i) (G j)\ninst✝² : DirectedSystem G fun i j h => ⇑(f' i j h)\ninst✝¹ : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝ : Nonempty ι\ng : Sigma fun i => G i\n⊢ Eq ((Ring.DirectLimit.ringEquiv G f').symm (Quotient.mk (DirectLimit.setoid f') g)) ((Ring.DirectLimit.of G (fun x1 x2 x3 => ⇑(f' x1 x2 x3)) g.fst) g.snd)","decl":"theorem ringEquiv_symm_mk [Nonempty ι] {g} : (ringEquiv G f').symm ⟦g⟧ = of _ _ g.1 g.2 := rfl\n\n"}
{"name":"Ring.DirectLimit.of.zero_exact","module":"Mathlib.Algebra.Colimit.Ring","initialProofState":"ι : Type u_1\ninst✝³ : Preorder ι\nG : ι → Type u_2\ninst✝² : (i : ι) → CommRing (G i)\nf' : (i j : ι) → LE.le i j → RingHom (G i) (G j)\ninst✝¹ : DirectedSystem G fun i j h => ⇑(f' i j h)\ninst✝ : IsDirected ι fun x1 x2 => LE.le x1 x2\ni : ι\nx : G i\nhix : Eq ((Ring.DirectLimit.of G (fun x1 x2 x3 => ⇑(f' x1 x2 x3)) i) x) 0\n⊢ Exists fun j => Exists fun hij => Eq ((f' i j hij) x) 0","decl":"/-- A component that corresponds to zero in the direct limit is already zero in some\nbigger module in the directed system. -/\ntheorem of.zero_exact {i x} (hix : of G (f' · · ·) i x = 0) :\n    ∃ (j : _) (hij : i ≤ j), f' i j hij x = 0 := by\n  have := Nonempty.intro i\n  apply_fun ringEquiv _ _ at hix\n  rwa [map_zero, ringEquiv_of, DirectLimit.exists_eq_zero] at hix\n\n"}
{"name":"Ring.DirectLimit.of_injective","module":"Mathlib.Algebra.Colimit.Ring","initialProofState":"ι : Type u_1\ninst✝³ : Preorder ι\nG : ι → Type u_2\ninst✝² : (i : ι) → CommRing (G i)\nf' : (i j : ι) → LE.le i j → RingHom (G i) (G j)\ninst✝¹ : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝ : DirectedSystem G fun i j h => ⇑(f' i j h)\nhf : ∀ (i j : ι) (hij : LE.le i j), Function.Injective ⇑(f' i j hij)\ni : ι\n⊢ Function.Injective ⇑(Ring.DirectLimit.of G (fun i j h => ⇑(f' i j h)) i)","decl":"/-- If the maps in the directed system are injective, then the canonical maps\nfrom the components to the direct limits are injective. -/\ntheorem of_injective [IsDirected ι (· ≤ ·)] [DirectedSystem G fun i j h ↦ f' i j h]\n    (hf : ∀ i j hij, Function.Injective (f' i j hij)) (i) :\n    Function.Injective (of G (fun i j h ↦ f' i j h) i) :=\n  have := Nonempty.intro i\n  ((ringEquiv _ _).comp_injective _).mp\n    fun _ _ eq ↦  DirectLimit.mk_injective f' hf _ (by simpa only [← ringEquiv_of])\n\n"}
{"name":"Ring.DirectLimit.map_apply_of","module":"Mathlib.Algebra.Colimit.Ring","initialProofState":"ι : Type u_1\ninst✝² : Preorder ι\nG : ι → Type u_2\ninst✝¹ : (i : ι) → CommRing (G i)\nf : (i j : ι) → LE.le i j → RingHom (G i) (G j)\nG' : ι → Type u_4\ninst✝ : (i : ι) → CommRing (G' i)\nf' : (i j : ι) → LE.le i j → RingHom (G' i) (G' j)\ng : (i : ι) → RingHom (G i) (G' i)\nhg : ∀ (i j : ι) (h : LE.le i j), Eq ((g j).comp (f i j h)) ((f' i j h).comp (g i))\ni : ι\nx : G i\n⊢ Eq ((Ring.DirectLimit.map g hg) ((Ring.DirectLimit.of G (fun x x_1 h => ⇑(f x x_1 h)) i) x)) ((Ring.DirectLimit.of G' (fun x x_1 h => ⇑(f' x x_1 h)) i) ((g i) x))","decl":"@[simp] lemma map_apply_of (g : (i : ι) → G i →+* G' i)\n    (hg : ∀ i j h, (g j).comp (f i j h) = (f' i j h).comp (g i))\n    {i : ι} (x : G i) :\n    map g hg (of G _ _ x) = of G' (fun _ _ h ↦ f' _ _ h) i (g i x) :=\n  lift_of _ _ _ _ _\n\n"}
{"name":"Ring.DirectLimit.map_id","module":"Mathlib.Algebra.Colimit.Ring","initialProofState":"ι : Type u_1\ninst✝¹ : Preorder ι\nG : ι → Type u_2\ninst✝ : (i : ι) → CommRing (G i)\nf : (i j : ι) → LE.le i j → RingHom (G i) (G j)\n⊢ Eq (Ring.DirectLimit.map (fun x => RingHom.id (G x)) ⋯) (RingHom.id (Ring.DirectLimit G fun x x_1 h => ⇑(f x x_1 h)))","decl":"@[simp] lemma map_id :\n    map (fun _ ↦ RingHom.id _) (fun _ _ _ ↦ rfl) = RingHom.id (DirectLimit G fun _ _ h ↦ f _ _ h) :=\n  DFunLike.ext _ _ fun x ↦ by\n    obtain ⟨x, rfl⟩ := Ideal.Quotient.mk_surjective x\n    refine x.induction_on (by simp) (fun _ ↦ ?_) (by simp+contextual) (by simp+contextual)\n    rw [quotientMk_of, map_apply_of]; rfl\n\n"}
{"name":"Ring.DirectLimit.map_comp","module":"Mathlib.Algebra.Colimit.Ring","initialProofState":"ι : Type u_1\ninst✝³ : Preorder ι\nG : ι → Type u_2\ninst✝² : (i : ι) → CommRing (G i)\nf : (i j : ι) → LE.le i j → RingHom (G i) (G j)\nG' : ι → Type u_4\ninst✝¹ : (i : ι) → CommRing (G' i)\nf' : (i j : ι) → LE.le i j → RingHom (G' i) (G' j)\nG'' : ι → Type u_5\ninst✝ : (i : ι) → CommRing (G'' i)\nf'' : (i j : ι) → LE.le i j → RingHom (G'' i) (G'' j)\ng₁ : (i : ι) → RingHom (G i) (G' i)\ng₂ : (i : ι) → RingHom (G' i) (G'' i)\nhg₁ : ∀ (i j : ι) (h : LE.le i j), Eq ((g₁ j).comp (f i j h)) ((f' i j h).comp (g₁ i))\nhg₂ : ∀ (i j : ι) (h : LE.le i j), Eq ((g₂ j).comp (f' i j h)) ((f'' i j h).comp (g₂ i))\n⊢ Eq ((Ring.DirectLimit.map g₂ hg₂).comp (Ring.DirectLimit.map g₁ hg₁)) (Ring.DirectLimit.map (fun i => (g₂ i).comp (g₁ i)) ⋯)","decl":"lemma map_comp (g₁ : (i : ι) → G i →+* G' i) (g₂ : (i : ι) → G' i →+* G'' i)\n    (hg₁ : ∀ i j h, (g₁ j).comp (f i j h) = (f' i j h).comp (g₁ i))\n    (hg₂ : ∀ i j h, (g₂ j).comp (f' i j h) = (f'' i j h).comp (g₂ i)) :\n    ((map g₂ hg₂).comp (map g₁ hg₁) :\n      DirectLimit G (fun _ _ h ↦ f _ _ h) →+* DirectLimit G'' fun _ _ h ↦ f'' _ _ h) =\n    (map (fun i ↦ (g₂ i).comp (g₁ i)) fun i j h ↦ by\n      rw [RingHom.comp_assoc, hg₁ i, ← RingHom.comp_assoc, hg₂ i, RingHom.comp_assoc] :\n      DirectLimit G (fun _ _ h ↦ f _ _ h) →+* DirectLimit G'' fun _ _ h ↦ f'' _ _ h) :=\n  DFunLike.ext _ _ fun x ↦ by\n    obtain ⟨x, rfl⟩ := Ideal.Quotient.mk_surjective x\n    refine x.induction_on (by simp) (fun _ ↦ ?_) (by simp+contextual) (by simp+contextual)\n    rw [RingHom.comp_apply, quotientMk_of]\n    simp_rw [map_apply_of]\n    rfl\n\n"}
{"name":"Ring.DirectLimit.congr_apply_of","module":"Mathlib.Algebra.Colimit.Ring","initialProofState":"ι : Type u_1\ninst✝² : Preorder ι\nG : ι → Type u_2\ninst✝¹ : (i : ι) → CommRing (G i)\nf : (i j : ι) → LE.le i j → RingHom (G i) (G j)\nG' : ι → Type u_4\ninst✝ : (i : ι) → CommRing (G' i)\nf' : (i j : ι) → LE.le i j → RingHom (G' i) (G' j)\ne : (i : ι) → RingEquiv (G i) (G' i)\nhe : ∀ (i j : ι) (h : LE.le i j), Eq ((e j).toRingHom.comp (f i j h)) ((f' i j h).comp ↑(e i))\ni : ι\ng : G i\n⊢ Eq ((Ring.DirectLimit.congr e he) ((Ring.DirectLimit.of G (fun x x_1 h => ⇑(f x x_1 h)) i) g)) ((Ring.DirectLimit.of G' (fun x x_1 h => ⇑(f' x x_1 h)) i) ((e i) g))","decl":"lemma congr_apply_of (e : (i : ι) → G i ≃+* G' i)\n    (he : ∀ i j h, (e j).toRingHom.comp (f i j h) = (f' i j h).comp (e i))\n    {i : ι} (g : G i) :\n    congr e he (of G _ i g) = of G' (fun _ _ h ↦ f' _ _ h) i (e i g) :=\n  map_apply_of _ he _\n\n"}
{"name":"Ring.DirectLimit.congr_symm_apply_of","module":"Mathlib.Algebra.Colimit.Ring","initialProofState":"ι : Type u_1\ninst✝² : Preorder ι\nG : ι → Type u_2\ninst✝¹ : (i : ι) → CommRing (G i)\nf : (i j : ι) → LE.le i j → RingHom (G i) (G j)\nG' : ι → Type u_4\ninst✝ : (i : ι) → CommRing (G' i)\nf' : (i j : ι) → LE.le i j → RingHom (G' i) (G' j)\ne : (i : ι) → RingEquiv (G i) (G' i)\nhe : ∀ (i j : ι) (h : LE.le i j), Eq ((e j).toRingHom.comp (f i j h)) ((f' i j h).comp ↑(e i))\ni : ι\ng : G' i\n⊢ Eq ((Ring.DirectLimit.congr e he).symm ((Ring.DirectLimit.of G' (fun x x_1 h => ⇑(f' x x_1 h)) i) g)) ((Ring.DirectLimit.of G (fun x x_1 h => ⇑(f x x_1 h)) i) ((e i).symm g))","decl":"lemma congr_symm_apply_of (e : (i : ι) → G i ≃+* G' i)\n    (he : ∀ i j h, (e j).toRingHom.comp (f i j h) = (f' i j h).comp (e i))\n    {i : ι} (g : G' i) :\n    (congr e he).symm (of G' _ i g) = of G (fun _ _ h ↦ f _ _ h) i ((e i).symm g) := by\n  simp only [congr, RingEquiv.ofRingHom_symm_apply, map_apply_of, RingHom.coe_coe]\n\n"}
{"name":"Field.DirectLimit.nontrivial","module":"Mathlib.Algebra.Colimit.Ring","initialProofState":"ι : Type u_1\ninst✝² : Preorder ι\nG : ι → Type u_2\ninst✝¹ : (i : ι) → Field (G i)\nf' : (i j : ι) → LE.le i j → RingHom (G i) (G j)\ninst✝ : DirectedSystem G fun x1 x2 x3 => ⇑(f' x1 x2 x3)\n⊢ Nontrivial (Ring.DirectLimit G fun x1 x2 x3 => ⇑(f' x1 x2 x3))","decl":"instance nontrivial [DirectedSystem G (f' · · ·)] :\n    Nontrivial (Ring.DirectLimit G (f' · · ·)) :=\n  ⟨⟨0, 1,\n      Nonempty.elim (by infer_instance) fun i : ι ↦ by\n        change (0 : Ring.DirectLimit G (f' · · ·)) ≠ 1\n        rw [← (Ring.DirectLimit.of _ _ _).map_one]\n        · intro H; rcases Ring.DirectLimit.of.zero_exact H.symm with ⟨j, hij, hf⟩\n          rw [(f' i j hij).map_one] at hf\n          exact one_ne_zero hf⟩⟩\n\n"}
{"name":"Field.DirectLimit.exists_inv","module":"Mathlib.Algebra.Colimit.Ring","initialProofState":"ι : Type u_1\ninst✝³ : Preorder ι\nG : ι → Type u_2\ninst✝² : Nonempty ι\ninst✝¹ : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝ : (i : ι) → Field (G i)\nf : (i j : ι) → LE.le i j → G i → G j\np : Ring.DirectLimit G f\na✝ : Ne p 0\n⊢ Exists fun y => Eq (HMul.hMul p y) 1","decl":"theorem exists_inv {p : Ring.DirectLimit G f} : p ≠ 0 → ∃ y, p * y = 1 :=\n  Ring.DirectLimit.induction_on p fun i x H ↦\n    ⟨Ring.DirectLimit.of G f i x⁻¹, by\n      rw [← (Ring.DirectLimit.of _ _ _).map_mul,\n        mul_inv_cancel₀ fun h : x = 0 ↦ H <| by rw [h, (Ring.DirectLimit.of _ _ _).map_zero],\n        (Ring.DirectLimit.of _ _ _).map_one]⟩\n\n"}
{"name":"Field.DirectLimit.mul_inv_cancel","module":"Mathlib.Algebra.Colimit.Ring","initialProofState":"ι : Type u_1\ninst✝³ : Preorder ι\nG : ι → Type u_2\ninst✝² : Nonempty ι\ninst✝¹ : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝ : (i : ι) → Field (G i)\nf : (i j : ι) → LE.le i j → G i → G j\np : Ring.DirectLimit G f\nhp : Ne p 0\n⊢ Eq (HMul.hMul p (Field.DirectLimit.inv G f p)) 1","decl":"protected theorem mul_inv_cancel {p : Ring.DirectLimit G f} (hp : p ≠ 0) : p * inv G f p = 1 := by\n  rw [inv, dif_neg hp, Classical.choose_spec (DirectLimit.exists_inv G f hp)]\n\n"}
{"name":"Field.DirectLimit.inv_mul_cancel","module":"Mathlib.Algebra.Colimit.Ring","initialProofState":"ι : Type u_1\ninst✝³ : Preorder ι\nG : ι → Type u_2\ninst✝² : Nonempty ι\ninst✝¹ : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝ : (i : ι) → Field (G i)\nf : (i j : ι) → LE.le i j → G i → G j\np : Ring.DirectLimit G f\nhp : Ne p 0\n⊢ Eq (HMul.hMul (Field.DirectLimit.inv G f p) p) 1","decl":"protected theorem inv_mul_cancel {p : Ring.DirectLimit G f} (hp : p ≠ 0) : inv G f p * p = 1 := by\n  rw [_root_.mul_comm, DirectLimit.mul_inv_cancel G f hp]\n\n"}
