{"name":"CompactIccSpace.isCompact_Icc","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : Preorder Œ±\nself : CompactIccSpace Œ±\na b : Œ±\n‚ä¢ IsCompact (Set.Icc a b)","decl":"/-- This typeclass says that all closed intervals in `Œ±` are compact. This is true for all\nconditionally complete linear orders with order topology and products (finite or infinite)\nof such spaces. -/\nclass CompactIccSpace (Œ± : Type*) [TopologicalSpace Œ±] [Preorder Œ±] : Prop where\n  /-- A closed interval `Set.Icc a b` is a compact set for all `a` and `b`. -/\n  isCompact_Icc : ‚àÄ {a b : Œ±}, IsCompact (Icc a b)\n\n"}
{"name":"CompactIccSpace.mk'","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : Preorder Œ±\nh : ‚àÄ {a b : Œ±}, LE.le a b ‚Üí IsCompact (Set.Icc a b)\n‚ä¢ CompactIccSpace Œ±","decl":"lemma CompactIccSpace.mk' [TopologicalSpace Œ±] [Preorder Œ±]\n    (h : ‚àÄ {a b : Œ±}, a ‚â§ b ‚Üí IsCompact (Icc a b)) : CompactIccSpace Œ± where\n  isCompact_Icc {a b} := by_cases h fun hab => by rw [Icc_eq_empty hab]; exact isCompact_empty\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: drop one `'`\n"}
{"name":"CompactIccSpace.mk''","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : PartialOrder Œ±\nh : ‚àÄ {a b : Œ±}, LT.lt a b ‚Üí IsCompact (Set.Icc a b)\n‚ä¢ CompactIccSpace Œ±","decl":"lemma CompactIccSpace.mk'' [TopologicalSpace Œ±] [PartialOrder Œ±]\n    (h : ‚àÄ {a b : Œ±}, a < b ‚Üí IsCompact (Icc a b)) : CompactIccSpace Œ± :=\n  .mk' fun hab => hab.eq_or_lt.elim (by rintro rfl; simp) h\n\n"}
{"name":"instCompactIccSpaceOrderDual","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : Preorder Œ±\ninst‚úù : CompactIccSpace Œ±\n‚ä¢ CompactIccSpace (OrderDual Œ±)","decl":"instance [TopologicalSpace Œ±] [Preorder Œ±] [CompactIccSpace Œ±] : CompactIccSpace (Œ±·µí·µà) where\n  isCompact_Icc := by\n    intro a b\n    convert isCompact_Icc (Œ± := Œ±) (a := b) (b := a) using 1\n    exact dual_Icc (Œ± := Œ±)\n\n"}
{"name":"ConditionallyCompleteLinearOrder.toCompactIccSpace","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\ninst‚úù¬≤ : ConditionallyCompleteLinearOrder Œ±\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : OrderTopology Œ±\n‚ä¢ CompactIccSpace Œ±","decl":"/-- A closed interval in a conditionally complete linear order is compact. -/\ninstance (priority := 100) ConditionallyCompleteLinearOrder.toCompactIccSpace (Œ± : Type*)\n    [ConditionallyCompleteLinearOrder Œ±] [TopologicalSpace Œ±] [OrderTopology Œ±] :\n    CompactIccSpace Œ± := by\n  refine .mk'' fun {a b} hlt => ?_\n  rcases le_or_lt a b with hab | hab\n  swap\n  ¬∑ simp [hab]\n  refine isCompact_iff_ultrafilter_le_nhds.2 fun f hf => ?_\n  contrapose! hf\n  rw [le_principal_iff]\n  have hpt : ‚àÄ x ‚àà Icc a b, {x} ‚àâ f := fun x hx hxf =>\n    hf x hx ((le_pure_iff.2 hxf).trans (pure_le_nhds x))\n  set s := { x ‚àà Icc a b | Icc a x ‚àâ f }\n  have hsb : b ‚àà upperBounds s := fun x hx => hx.1.2\n  have sbd : BddAbove s := ‚ü®b, hsb‚ü©\n  have ha : a ‚àà s := by simp [s, hpt, hab]\n  rcases hab.eq_or_lt with (rfl | _hlt)\n  ¬∑ exact ha.2\n  -- Porting note: the `obtain` below was instead\n  -- `set c := Sup s`\n  -- `have hsc : IsLUB s c := isLUB_csSup ‚ü®a, ha‚ü© sbd`\n  obtain ‚ü®c, hsc‚ü© : ‚àÉ c, IsLUB s c := ‚ü®sSup s, isLUB_csSup ‚ü®a, ha‚ü© ‚ü®b, hsb‚ü©‚ü©\n  have hc : c ‚àà Icc a b := ‚ü®hsc.1 ha, hsc.2 hsb‚ü©\n  specialize hf c hc\n  have hcs : c ‚àà s := by\n    rcases hc.1.eq_or_lt with (rfl | hlt); ¬∑ assumption\n    refine ‚ü®hc, fun hcf => hf fun U hU => ?_‚ü©\n    rcases (mem_nhdsLE_iff_exists_Ioc_subset' hlt).1 (mem_nhdsWithin_of_mem_nhds hU)\n      with ‚ü®x, hxc, hxU‚ü©\n    rcases ((hsc.frequently_mem ‚ü®a, ha‚ü©).and_eventually (Ioc_mem_nhdsLE hxc)).exists\n      with ‚ü®y, ‚ü®_hyab, hyf‚ü©, hy‚ü©\n    refine mem_of_superset (f.diff_mem_iff.2 ‚ü®hcf, hyf‚ü©) (Subset.trans ?_ hxU)\n    rw [diff_subset_iff]\n    exact Subset.trans Icc_subset_Icc_union_Ioc <| union_subset_union Subset.rfl <|\n      Ioc_subset_Ioc_left hy.1.le\n  rcases hc.2.eq_or_lt with (rfl | hlt)\n  ¬∑ exact hcs.2\n  exfalso\n  refine hf fun U hU => ?_\n  rcases (mem_nhdsGE_iff_exists_mem_Ioc_Ico_subset hlt).1 (mem_nhdsWithin_of_mem_nhds hU)\n    with ‚ü®y, hxy, hyU‚ü©\n  refine mem_of_superset ?_ hyU; clear! U\n  have hy : y ‚àà Icc a b := ‚ü®hc.1.trans hxy.1.le, hxy.2‚ü©\n  by_cases hay : Icc a y ‚àà f\n  ¬∑ refine mem_of_superset (f.diff_mem_iff.2 ‚ü®f.diff_mem_iff.2 ‚ü®hay, hcs.2‚ü©, hpt y hy‚ü©) ?_\n    rw [diff_subset_iff, union_comm, Ico_union_right hxy.1.le, diff_subset_iff]\n    exact Icc_subset_Icc_union_Icc\n  ¬∑ exact ((hsc.1 ‚ü®hy, hay‚ü©).not_lt hxy.1).elim\n\n"}
{"name":"instCompactIccSpaceForall","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œπ : Type u_2\nŒ± : Œπ ‚Üí Type u_3\ninst‚úù¬≤ : (i : Œπ) ‚Üí Preorder (Œ± i)\ninst‚úù¬π : (i : Œπ) ‚Üí TopologicalSpace (Œ± i)\ninst‚úù : ‚àÄ (i : Œπ), CompactIccSpace (Œ± i)\n‚ä¢ CompactIccSpace ((i : Œπ) ‚Üí Œ± i)","decl":"instance {Œπ : Type*} {Œ± : Œπ ‚Üí Type*} [‚àÄ i, Preorder (Œ± i)] [‚àÄ i, TopologicalSpace (Œ± i)]\n    [‚àÄ i, CompactIccSpace (Œ± i)] : CompactIccSpace (‚àÄ i, Œ± i) :=\n  ‚ü®fun {a b} => (pi_univ_Icc a b ‚ñ∏ isCompact_univ_pi) fun _ => isCompact_Icc‚ü©\n\n"}
{"name":"Pi.compact_Icc_space'","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\ninst‚úù¬≤ : Preorder Œ≤\ninst‚úù¬π : TopologicalSpace Œ≤\ninst‚úù : CompactIccSpace Œ≤\n‚ä¢ CompactIccSpace (Œ± ‚Üí Œ≤)","decl":"instance Pi.compact_Icc_space' {Œ± Œ≤ : Type*} [Preorder Œ≤] [TopologicalSpace Œ≤]\n    [CompactIccSpace Œ≤] : CompactIccSpace (Œ± ‚Üí Œ≤) :=\n  inferInstance\n\n"}
{"name":"instCompactIccSpaceProd","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\ninst‚úù‚Åµ : Preorder Œ±\ninst‚úù‚Å¥ : TopologicalSpace Œ±\ninst‚úù¬≥ : CompactIccSpace Œ±\ninst‚úù¬≤ : Preorder Œ≤\ninst‚úù¬π : TopologicalSpace Œ≤\ninst‚úù : CompactIccSpace Œ≤\n‚ä¢ CompactIccSpace (Prod Œ± Œ≤)","decl":"instance {Œ± Œ≤ : Type*} [Preorder Œ±] [TopologicalSpace Œ±] [CompactIccSpace Œ±] [Preorder Œ≤]\n    [TopologicalSpace Œ≤] [CompactIccSpace Œ≤] : CompactIccSpace (Œ± √ó Œ≤) :=\n  ‚ü®fun {a b} => (Icc_prod_eq a b).symm ‚ñ∏ isCompact_Icc.prod isCompact_Icc‚ü©\n\n"}
{"name":"isCompact_uIcc","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\ninst‚úù¬≤ : LinearOrder Œ±\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : CompactIccSpace Œ±\na b : Œ±\n‚ä¢ IsCompact (Set.uIcc a b)","decl":"/-- An unordered closed interval is compact. -/\ntheorem isCompact_uIcc {Œ± : Type*} [LinearOrder Œ±] [TopologicalSpace Œ±] [CompactIccSpace Œ±]\n    {a b : Œ±} : IsCompact (uIcc a b) :=\n  isCompact_Icc\n\n-- See note [lower instance priority]\n"}
{"name":"compactSpace_of_completeLinearOrder","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\ninst‚úù¬≤ : CompleteLinearOrder Œ±\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : OrderTopology Œ±\n‚ä¢ CompactSpace Œ±","decl":"/-- A complete linear order is a compact space.\n\nWe do not register an instance for a `[CompactIccSpace Œ±]` because this would only add instances\nfor products (indexed or not) of complete linear orders, and we have instances with higher priority\nthat cover these cases. -/\ninstance (priority := 100) compactSpace_of_completeLinearOrder {Œ± : Type*} [CompleteLinearOrder Œ±]\n    [TopologicalSpace Œ±] [OrderTopology Œ±] : CompactSpace Œ± :=\n  ‚ü®by simp only [‚Üê Icc_bot_top, isCompact_Icc]‚ü©\n\n"}
{"name":"compactSpace_Icc","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : CompactIccSpace Œ±\na b : Œ±\n‚ä¢ CompactSpace ‚Üë(Set.Icc a b)","decl":"instance compactSpace_Icc (a b : Œ±) : CompactSpace (Icc a b) :=\n  isCompact_iff_compactSpace.mp isCompact_Icc\n\n"}
{"name":"isCompact_Ico_iff","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\ninst‚úù¬≥ : LinearOrder Œ±\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : OrderTopology Œ±\ninst‚úù : DenselyOrdered Œ±\na b : Œ±\n‚ä¢ Iff (IsCompact (Set.Ico a b)) (LE.le b a)","decl":"/-- `Set.Ico a b` is only compact if it is empty. -/\n@[simp]\ntheorem isCompact_Ico_iff {a b : Œ±} : IsCompact (Set.Ico a b) ‚Üî b ‚â§ a :=\n  ‚ü®fun h => isClosed_Ico_iff.mp h.isClosed, by simp_all‚ü©\n\n"}
{"name":"isCompact_Ioc_iff","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\ninst‚úù¬≥ : LinearOrder Œ±\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : OrderTopology Œ±\ninst‚úù : DenselyOrdered Œ±\na b : Œ±\n‚ä¢ Iff (IsCompact (Set.Ioc a b)) (LE.le b a)","decl":"/-- `Set.Ioc a b` is only compact if it is empty. -/\n@[simp]\ntheorem isCompact_Ioc_iff {a b : Œ±} : IsCompact (Set.Ioc a b) ‚Üî b ‚â§ a :=\n  ‚ü®fun h => isClosed_Ioc_iff.mp h.isClosed, by simp_all‚ü©\n\n"}
{"name":"isCompact_Ioo_iff","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\ninst‚úù¬≥ : LinearOrder Œ±\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : OrderTopology Œ±\ninst‚úù : DenselyOrdered Œ±\na b : Œ±\n‚ä¢ Iff (IsCompact (Set.Ioo a b)) (LE.le b a)","decl":"/-- `Set.Ioo a b` is only compact if it is empty. -/\n@[simp]\ntheorem isCompact_Ioo_iff {a b : Œ±} : IsCompact (Set.Ioo a b) ‚Üî b ‚â§ a :=\n  ‚ü®fun h => isClosed_Ioo_iff.mp h.isClosed, by simp_all‚ü©\n\n"}
{"name":"IsCompact.exists_isLeast","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\ninst‚úù¬≤ : LinearOrder Œ±\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : ClosedIicTopology Œ±\ns : Set Œ±\nhs : IsCompact s\nne_s : s.Nonempty\n‚ä¢ Exists fun x => IsLeast s x","decl":"theorem IsCompact.exists_isLeast [ClosedIicTopology Œ±] {s : Set Œ±} (hs : IsCompact s)\n    (ne_s : s.Nonempty) : ‚àÉ x, IsLeast s x := by\n  haveI : Nonempty s := ne_s.to_subtype\n  suffices (s ‚à© ‚ãÇ x ‚àà s, Iic x).Nonempty from\n    ‚ü®this.choose, this.choose_spec.1, mem_iInter‚ÇÇ.mp this.choose_spec.2‚ü©\n  rw [biInter_eq_iInter]\n  by_contra H\n  rw [not_nonempty_iff_eq_empty] at H\n  rcases hs.elim_directed_family_closed (fun x : s => Iic ‚Üëx) (fun x => isClosed_Iic) H\n      (Monotone.directed_ge fun _ _ h => Iic_subset_Iic.mpr h) with ‚ü®x, hx‚ü©\n  exact not_nonempty_iff_eq_empty.mpr hx ‚ü®x, x.2, le_rfl‚ü©\n\n"}
{"name":"IsCompact.exists_isGreatest","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\ninst‚úù¬≤ : LinearOrder Œ±\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : ClosedIciTopology Œ±\ns : Set Œ±\nhs : IsCompact s\nne_s : s.Nonempty\n‚ä¢ Exists fun x => IsGreatest s x","decl":"theorem IsCompact.exists_isGreatest [ClosedIciTopology Œ±] {s : Set Œ±} (hs : IsCompact s)\n    (ne_s : s.Nonempty) : ‚àÉ x, IsGreatest s x :=\n  IsCompact.exists_isLeast (Œ± := Œ±·µí·µà) hs ne_s\n\n"}
{"name":"IsCompact.exists_isGLB","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\ninst‚úù¬≤ : LinearOrder Œ±\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : ClosedIicTopology Œ±\ns : Set Œ±\nhs : IsCompact s\nne_s : s.Nonempty\n‚ä¢ Exists fun x => And (Membership.mem s x) (IsGLB s x)","decl":"theorem IsCompact.exists_isGLB [ClosedIicTopology Œ±] {s : Set Œ±} (hs : IsCompact s)\n    (ne_s : s.Nonempty) : ‚àÉ x ‚àà s, IsGLB s x :=\n  (hs.exists_isLeast ne_s).imp (fun x (hx : IsLeast s x) => ‚ü®hx.1, hx.isGLB‚ü©)\n\n"}
{"name":"IsCompact.exists_isLUB","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\ninst‚úù¬≤ : LinearOrder Œ±\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : ClosedIciTopology Œ±\ns : Set Œ±\nhs : IsCompact s\nne_s : s.Nonempty\n‚ä¢ Exists fun x => And (Membership.mem s x) (IsLUB s x)","decl":"theorem IsCompact.exists_isLUB [ClosedIciTopology Œ±] {s : Set Œ±} (hs : IsCompact s)\n    (ne_s : s.Nonempty) : ‚àÉ x ‚àà s, IsLUB s x :=\n  IsCompact.exists_isGLB (Œ± := Œ±·µí·µà) hs ne_s\n\n"}
{"name":"cocompact_le_atBot_atTop","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\ninst‚úù¬≤ : LinearOrder Œ±\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : CompactIccSpace Œ±\n‚ä¢ LE.le (Filter.cocompact Œ±) (Max.max Filter.atBot Filter.atTop)","decl":"theorem cocompact_le_atBot_atTop [CompactIccSpace Œ±] :\n    cocompact Œ± ‚â§ atBot ‚äî atTop := by\n  refine fun s hs ‚Ü¶ mem_cocompact.mpr <| (isEmpty_or_nonempty Œ±).casesOn ?_ ?_ <;> intro\n  ¬∑ exact ‚ü®‚àÖ, isCompact_empty, fun x _ ‚Ü¶ (IsEmpty.false x).elim‚ü©\n  ¬∑ obtain ‚ü®t, ht‚ü© := mem_atBot_sets.mp hs.1\n    obtain ‚ü®u, hu‚ü© := mem_atTop_sets.mp hs.2\n    refine ‚ü®Icc t u, isCompact_Icc, fun x hx ‚Ü¶ ?_‚ü©\n    exact (not_and_or.mp hx).casesOn (fun h ‚Ü¶ ht x (le_of_not_le h)) fun h ‚Ü¶ hu x (le_of_not_le h)\n\n"}
{"name":"cocompact_le_atBot","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\ninst‚úù¬≥ : LinearOrder Œ±\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : OrderTop Œ±\ninst‚úù : CompactIccSpace Œ±\n‚ä¢ LE.le (Filter.cocompact Œ±) Filter.atBot","decl":"theorem cocompact_le_atBot [OrderTop Œ±] [CompactIccSpace Œ±] :\n    cocompact Œ± ‚â§ atBot := by\n  refine fun _ hs ‚Ü¶ mem_cocompact.mpr <| (isEmpty_or_nonempty Œ±).casesOn ?_ ?_ <;> intro\n  ¬∑ exact ‚ü®‚àÖ, isCompact_empty, fun x _ ‚Ü¶ (IsEmpty.false x).elim‚ü©\n  ¬∑ obtain ‚ü®t, ht‚ü© := mem_atBot_sets.mp hs\n    refine ‚ü®Icc t ‚ä§, isCompact_Icc, fun _ hx ‚Ü¶ ?_‚ü©\n    exact (not_and_or.mp hx).casesOn (fun h ‚Ü¶ ht _ (le_of_not_le h)) (fun h ‚Ü¶ (h le_top).elim)\n\n"}
{"name":"cocompact_le_atTop","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\ninst‚úù¬≥ : LinearOrder Œ±\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : OrderBot Œ±\ninst‚úù : CompactIccSpace Œ±\n‚ä¢ LE.le (Filter.cocompact Œ±) Filter.atTop","decl":"theorem cocompact_le_atTop [OrderBot Œ±] [CompactIccSpace Œ±] :\n    cocompact Œ± ‚â§ atTop :=\n  cocompact_le_atBot (Œ± := Œ±·µí·µà)\n\n"}
{"name":"atBot_le_cocompact","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\ninst‚úù¬≥ : LinearOrder Œ±\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : NoMinOrder Œ±\ninst‚úù : ClosedIicTopology Œ±\n‚ä¢ LE.le Filter.atBot (Filter.cocompact Œ±)","decl":"theorem atBot_le_cocompact [NoMinOrder Œ±] [ClosedIicTopology Œ±] :\n    atBot ‚â§ cocompact Œ± := by\n  refine fun s hs ‚Ü¶ ?_\n  obtain ‚ü®t, ht, hts‚ü© := mem_cocompact.mp hs\n  refine (Set.eq_empty_or_nonempty t).casesOn (fun h_empty ‚Ü¶ ?_) (fun h_nonempty ‚Ü¶ ?_)\n  ¬∑ rewrite [compl_univ_iff.mpr h_empty, univ_subset_iff] at hts\n    convert univ_mem\n  ¬∑ haveI := h_nonempty.nonempty\n    obtain ‚ü®a, ha‚ü© := ht.exists_isLeast h_nonempty\n    obtain ‚ü®b, hb‚ü© := exists_lt a\n    exact Filter.mem_atBot_sets.mpr ‚ü®b, fun b' hb' ‚Ü¶ hts <| Classical.byContradiction\n      fun hc ‚Ü¶ LT.lt.false <| hb'.trans_lt <| hb.trans_le <| ha.2 (not_not_mem.mp hc)‚ü©\n\n"}
{"name":"atTop_le_cocompact","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\ninst‚úù¬≥ : LinearOrder Œ±\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : NoMaxOrder Œ±\ninst‚úù : ClosedIciTopology Œ±\n‚ä¢ LE.le Filter.atTop (Filter.cocompact Œ±)","decl":"theorem atTop_le_cocompact [NoMaxOrder Œ±] [ClosedIciTopology Œ±] :\n    atTop ‚â§ cocompact Œ± :=\n  atBot_le_cocompact (Œ± := Œ±·µí·µà)\n\n"}
{"name":"atBot_atTop_le_cocompact","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\ninst‚úù‚Å¥ : LinearOrder Œ±\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : NoMinOrder Œ±\ninst‚úù¬π : NoMaxOrder Œ±\ninst‚úù : OrderClosedTopology Œ±\n‚ä¢ LE.le (Max.max Filter.atBot Filter.atTop) (Filter.cocompact Œ±)","decl":"theorem atBot_atTop_le_cocompact [NoMinOrder Œ±] [NoMaxOrder Œ±]\n    [OrderClosedTopology Œ±] : atBot ‚äî atTop ‚â§ cocompact Œ± :=\n  sup_le atBot_le_cocompact atTop_le_cocompact\n\n"}
{"name":"cocompact_eq_atBot_atTop","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\ninst‚úù‚Åµ : LinearOrder Œ±\ninst‚úù‚Å¥ : TopologicalSpace Œ±\ninst‚úù¬≥ : NoMaxOrder Œ±\ninst‚úù¬≤ : NoMinOrder Œ±\ninst‚úù¬π : OrderClosedTopology Œ±\ninst‚úù : CompactIccSpace Œ±\n‚ä¢ Eq (Filter.cocompact Œ±) (Max.max Filter.atBot Filter.atTop)","decl":"@[simp 900]\ntheorem cocompact_eq_atBot_atTop [NoMaxOrder Œ±] [NoMinOrder Œ±]\n    [OrderClosedTopology Œ±] [CompactIccSpace Œ±] : cocompact Œ± = atBot ‚äî atTop :=\n  cocompact_le_atBot_atTop.antisymm atBot_atTop_le_cocompact\n\n"}
{"name":"cocompact_eq_atBot","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\ninst‚úù‚Åµ : LinearOrder Œ±\ninst‚úù‚Å¥ : TopologicalSpace Œ±\ninst‚úù¬≥ : NoMinOrder Œ±\ninst‚úù¬≤ : OrderTop Œ±\ninst‚úù¬π : ClosedIicTopology Œ±\ninst‚úù : CompactIccSpace Œ±\n‚ä¢ Eq (Filter.cocompact Œ±) Filter.atBot","decl":"@[simp]\ntheorem cocompact_eq_atBot [NoMinOrder Œ±] [OrderTop Œ±]\n    [ClosedIicTopology Œ±] [CompactIccSpace Œ±] : cocompact Œ± = atBot :=\n  cocompact_le_atBot.antisymm atBot_le_cocompact\n\n"}
{"name":"cocompact_eq_atTop","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\ninst‚úù‚Åµ : LinearOrder Œ±\ninst‚úù‚Å¥ : TopologicalSpace Œ±\ninst‚úù¬≥ : NoMaxOrder Œ±\ninst‚úù¬≤ : OrderBot Œ±\ninst‚úù¬π : ClosedIciTopology Œ±\ninst‚úù : CompactIccSpace Œ±\n‚ä¢ Eq (Filter.cocompact Œ±) Filter.atTop","decl":"@[simp]\ntheorem cocompact_eq_atTop [NoMaxOrder Œ±] [OrderBot Œ±]\n    [ClosedIciTopology Œ±] [CompactIccSpace Œ±] : cocompact Œ± = atTop :=\n  cocompact_le_atTop.antisymm atTop_le_cocompact\n\n"}
{"name":"IsCompact.exists_isMinOn","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\ninst‚úù¬≥ : LinearOrder Œ±\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : TopologicalSpace Œ≤\ninst‚úù : ClosedIicTopology Œ±\ns : Set Œ≤\nhs : IsCompact s\nne_s : s.Nonempty\nf : Œ≤ ‚Üí Œ±\nhf : ContinuousOn f s\n‚ä¢ Exists fun x => And (Membership.mem s x) (IsMinOn f s x)","decl":"/-- The **extreme value theorem**: a continuous function realizes its minimum on a compact set. -/\ntheorem IsCompact.exists_isMinOn [ClosedIicTopology Œ±] {s : Set Œ≤} (hs : IsCompact s)\n    (ne_s : s.Nonempty) {f : Œ≤ ‚Üí Œ±} (hf : ContinuousOn f s) : ‚àÉ x ‚àà s, IsMinOn f s x := by\n  rcases (hs.image_of_continuousOn hf).exists_isLeast (ne_s.image f) with ‚ü®_, ‚ü®x, hxs, rfl‚ü©, hx‚ü©\n  refine ‚ü®x, hxs, forall_mem_image.1 (fun _ hb => hx <| mem_image_of_mem f ?_)‚ü©\n  rwa [(image_id' s).symm]\n\n"}
{"name":"IsCompact.exists_forall_le'","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\ninst‚úù‚Å¥ : LinearOrder Œ±\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : TopologicalSpace Œ≤\ninst‚úù¬π : ClosedIicTopology Œ±\ninst‚úù : NoMaxOrder Œ±\nf : Œ≤ ‚Üí Œ±\ns : Set Œ≤\nhs : IsCompact s\nhf : ContinuousOn f s\na : Œ±\nhf' : ‚àÄ (b : Œ≤), Membership.mem s b ‚Üí LT.lt a (f b)\n‚ä¢ Exists fun a' => And (LT.lt a a') (‚àÄ (b : Œ≤), Membership.mem s b ‚Üí LE.le a' (f b))","decl":"/-- If a continuous function lies strictly above `a` on a compact set,\n  it has a lower bound strictly above `a`. -/\ntheorem IsCompact.exists_forall_le' [ClosedIicTopology Œ±] [NoMaxOrder Œ±] {f : Œ≤ ‚Üí Œ±}\n    {s : Set Œ≤} (hs : IsCompact s) (hf : ContinuousOn f s) {a : Œ±} (hf' : ‚àÄ b ‚àà s, a < f b) :\n    ‚àÉ a', a < a' ‚àß ‚àÄ b ‚àà s, a' ‚â§ f b := by\n  rcases s.eq_empty_or_nonempty with (rfl | hs')\n  ¬∑ obtain ‚ü®a', ha'‚ü© := exists_gt a\n    exact ‚ü®a', ha', fun _ a ‚Ü¶ a.elim‚ü©\n  ¬∑ obtain ‚ü®x, hx, hx'‚ü© := hs.exists_isMinOn hs' hf\n    exact ‚ü®f x, hf' x hx, hx'‚ü©\n\n"}
{"name":"IsCompact.exists_isMaxOn","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\ninst‚úù¬≥ : LinearOrder Œ±\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : TopologicalSpace Œ≤\ninst‚úù : ClosedIciTopology Œ±\ns : Set Œ≤\nhs : IsCompact s\nne_s : s.Nonempty\nf : Œ≤ ‚Üí Œ±\nhf : ContinuousOn f s\n‚ä¢ Exists fun x => And (Membership.mem s x) (IsMaxOn f s x)","decl":"/-- The **extreme value theorem**: a continuous function realizes its maximum on a compact set. -/\ntheorem IsCompact.exists_isMaxOn [ClosedIciTopology Œ±] {s : Set Œ≤} (hs : IsCompact s)\n    (ne_s : s.Nonempty) {f : Œ≤ ‚Üí Œ±} (hf : ContinuousOn f s) : ‚àÉ x ‚àà s, IsMaxOn f s x :=\n  IsCompact.exists_isMinOn (Œ± := Œ±·µí·µà) hs ne_s hf\n\n"}
{"name":"ContinuousOn.exists_isMinOn'","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\ninst‚úù¬≥ : LinearOrder Œ±\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : TopologicalSpace Œ≤\ninst‚úù : ClosedIicTopology Œ±\ns : Set Œ≤\nf : Œ≤ ‚Üí Œ±\nhf : ContinuousOn f s\nhsc : IsClosed s\nx‚ÇÄ : Œ≤\nh‚ÇÄ : Membership.mem s x‚ÇÄ\nhc : Filter.Eventually (fun x => LE.le (f x‚ÇÄ) (f x)) (Min.min (Filter.cocompact Œ≤) (Filter.principal s))\n‚ä¢ Exists fun x => And (Membership.mem s x) (IsMinOn f s x)","decl":"/-- The **extreme value theorem**: if a function `f` is continuous on a closed set `s` and it is\nlarger than a value in its image away from compact sets, then it has a minimum on this set. -/\ntheorem ContinuousOn.exists_isMinOn' [ClosedIicTopology Œ±] {s : Set Œ≤} {f : Œ≤ ‚Üí Œ±}\n    (hf : ContinuousOn f s) (hsc : IsClosed s) {x‚ÇÄ : Œ≤} (h‚ÇÄ : x‚ÇÄ ‚àà s)\n    (hc : ‚àÄ·∂† x in cocompact Œ≤ ‚äì ùìü s, f x‚ÇÄ ‚â§ f x) : ‚àÉ x ‚àà s, IsMinOn f s x := by\n  rcases (hasBasis_cocompact.inf_principal _).eventually_iff.1 hc with ‚ü®K, hK, hKf‚ü©\n  have hsub : insert x‚ÇÄ (K ‚à© s) ‚äÜ s := insert_subset_iff.2 ‚ü®h‚ÇÄ, inter_subset_right‚ü©\n  obtain ‚ü®x, hx, hxf‚ü© : ‚àÉ x ‚àà insert x‚ÇÄ (K ‚à© s), ‚àÄ y ‚àà insert x‚ÇÄ (K ‚à© s), f x ‚â§ f y :=\n    ((hK.inter_right hsc).insert x‚ÇÄ).exists_isMinOn (insert_nonempty _ _) (hf.mono hsub)\n  refine ‚ü®x, hsub hx, fun y hy => ?_‚ü©\n  by_cases hyK : y ‚àà K\n  exacts [hxf _ (Or.inr ‚ü®hyK, hy‚ü©), (hxf _ (Or.inl rfl)).trans (hKf ‚ü®hyK, hy‚ü©)]\n\n"}
{"name":"ContinuousOn.exists_isMaxOn'","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\ninst‚úù¬≥ : LinearOrder Œ±\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : TopologicalSpace Œ≤\ninst‚úù : ClosedIciTopology Œ±\ns : Set Œ≤\nf : Œ≤ ‚Üí Œ±\nhf : ContinuousOn f s\nhsc : IsClosed s\nx‚ÇÄ : Œ≤\nh‚ÇÄ : Membership.mem s x‚ÇÄ\nhc : Filter.Eventually (fun x => LE.le (f x) (f x‚ÇÄ)) (Min.min (Filter.cocompact Œ≤) (Filter.principal s))\n‚ä¢ Exists fun x => And (Membership.mem s x) (IsMaxOn f s x)","decl":"/-- The **extreme value theorem**: if a function `f` is continuous on a closed set `s` and it is\nsmaller than a value in its image away from compact sets, then it has a maximum on this set. -/\ntheorem ContinuousOn.exists_isMaxOn' [ClosedIciTopology Œ±] {s : Set Œ≤} {f : Œ≤ ‚Üí Œ±}\n    (hf : ContinuousOn f s) (hsc : IsClosed s) {x‚ÇÄ : Œ≤} (h‚ÇÄ : x‚ÇÄ ‚àà s)\n    (hc : ‚àÄ·∂† x in cocompact Œ≤ ‚äì ùìü s, f x ‚â§ f x‚ÇÄ) : ‚àÉ x ‚àà s, IsMaxOn f s x :=\n  ContinuousOn.exists_isMinOn' (Œ± := Œ±·µí·µà) hf hsc h‚ÇÄ hc\n\n"}
{"name":"Continuous.exists_forall_le'","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\ninst‚úù¬≥ : LinearOrder Œ±\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : TopologicalSpace Œ≤\ninst‚úù : ClosedIicTopology Œ±\nf : Œ≤ ‚Üí Œ±\nhf : Continuous f\nx‚ÇÄ : Œ≤\nh : Filter.Eventually (fun x => LE.le (f x‚ÇÄ) (f x)) (Filter.cocompact Œ≤)\n‚ä¢ Exists fun x => ‚àÄ (y : Œ≤), LE.le (f x) (f y)","decl":"/-- The **extreme value theorem**: if a continuous function `f` is larger than a value in its range\naway from compact sets, then it has a global minimum. -/\ntheorem Continuous.exists_forall_le' [ClosedIicTopology Œ±] {f : Œ≤ ‚Üí Œ±} (hf : Continuous f)\n    (x‚ÇÄ : Œ≤) (h : ‚àÄ·∂† x in cocompact Œ≤, f x‚ÇÄ ‚â§ f x) : ‚àÉ x : Œ≤, ‚àÄ y : Œ≤, f x ‚â§ f y :=\n  let ‚ü®x, _, hx‚ü© := hf.continuousOn.exists_isMinOn' isClosed_univ (mem_univ x‚ÇÄ)\n    (by rwa [principal_univ, inf_top_eq])\n  ‚ü®x, fun y => hx (mem_univ y)‚ü©\n\n"}
{"name":"Continuous.exists_forall_ge'","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\ninst‚úù¬≥ : LinearOrder Œ±\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : TopologicalSpace Œ≤\ninst‚úù : ClosedIciTopology Œ±\nf : Œ≤ ‚Üí Œ±\nhf : Continuous f\nx‚ÇÄ : Œ≤\nh : Filter.Eventually (fun x => LE.le (f x) (f x‚ÇÄ)) (Filter.cocompact Œ≤)\n‚ä¢ Exists fun x => ‚àÄ (y : Œ≤), LE.le (f y) (f x)","decl":"/-- The **extreme value theorem**: if a continuous function `f` is smaller than a value in its range\naway from compact sets, then it has a global maximum. -/\ntheorem Continuous.exists_forall_ge' [ClosedIciTopology Œ±] {f : Œ≤ ‚Üí Œ±} (hf : Continuous f)\n    (x‚ÇÄ : Œ≤) (h : ‚àÄ·∂† x in cocompact Œ≤, f x ‚â§ f x‚ÇÄ) : ‚àÉ x : Œ≤, ‚àÄ y : Œ≤, f y ‚â§ f x :=\n  Continuous.exists_forall_le' (Œ± := Œ±·µí·µà) hf x‚ÇÄ h\n\n"}
{"name":"Continuous.exists_forall_le","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\ninst‚úù‚Å¥ : LinearOrder Œ±\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : TopologicalSpace Œ≤\ninst‚úù¬π : ClosedIicTopology Œ±\ninst‚úù : Nonempty Œ≤\nf : Œ≤ ‚Üí Œ±\nhf : Continuous f\nhlim : Filter.Tendsto f (Filter.cocompact Œ≤) Filter.atTop\n‚ä¢ Exists fun x => ‚àÄ (y : Œ≤), LE.le (f x) (f y)","decl":"/-- The **extreme value theorem**: if a continuous function `f` tends to infinity away from compact\nsets, then it has a global minimum. -/\ntheorem Continuous.exists_forall_le [ClosedIicTopology Œ±] [Nonempty Œ≤] {f : Œ≤ ‚Üí Œ±}\n    (hf : Continuous f) (hlim : Tendsto f (cocompact Œ≤) atTop) : ‚àÉ x, ‚àÄ y, f x ‚â§ f y := by\n  inhabit Œ≤\n  exact hf.exists_forall_le' default (hlim.eventually <| eventually_ge_atTop _)\n\n"}
{"name":"Continuous.exists_forall_ge","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\ninst‚úù‚Å¥ : LinearOrder Œ±\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : TopologicalSpace Œ≤\ninst‚úù¬π : ClosedIciTopology Œ±\ninst‚úù : Nonempty Œ≤\nf : Œ≤ ‚Üí Œ±\nhf : Continuous f\nhlim : Filter.Tendsto f (Filter.cocompact Œ≤) Filter.atBot\n‚ä¢ Exists fun x => ‚àÄ (y : Œ≤), LE.le (f y) (f x)","decl":"/-- The **extreme value theorem**: if a continuous function `f` tends to negative infinity away from\ncompact sets, then it has a global maximum. -/\ntheorem Continuous.exists_forall_ge [ClosedIciTopology Œ±] [Nonempty Œ≤] {f : Œ≤ ‚Üí Œ±}\n    (hf : Continuous f) (hlim : Tendsto f (cocompact Œ≤) atBot) : ‚àÉ x, ‚àÄ y, f y ‚â§ f x :=\n  Continuous.exists_forall_le (Œ± := Œ±·µí·µà) hf hlim\n\n"}
{"name":"Continuous.exists_forall_le_of_hasCompactMulSupport","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\ninst‚úù‚Åµ : LinearOrder Œ±\ninst‚úù‚Å¥ : TopologicalSpace Œ±\ninst‚úù¬≥ : TopologicalSpace Œ≤\ninst‚úù¬≤ : ClosedIicTopology Œ±\ninst‚úù¬π : Nonempty Œ≤\ninst‚úù : One Œ±\nf : Œ≤ ‚Üí Œ±\nhf : Continuous f\nh : HasCompactMulSupport f\n‚ä¢ Exists fun x => ‚àÄ (y : Œ≤), LE.le (f x) (f y)","decl":"/-- A continuous function with compact support has a global minimum. -/\n@[to_additive \"A continuous function with compact support has a global minimum.\"]\ntheorem Continuous.exists_forall_le_of_hasCompactMulSupport [ClosedIicTopology Œ±] [Nonempty Œ≤]\n    [One Œ±] {f : Œ≤ ‚Üí Œ±} (hf : Continuous f) (h : HasCompactMulSupport f) :\n    ‚àÉ x : Œ≤, ‚àÄ y : Œ≤, f x ‚â§ f y := by\n  obtain ‚ü®_, ‚ü®x, rfl‚ü©, hx‚ü© := (h.isCompact_range hf).exists_isLeast (range_nonempty _)\n  rw [mem_lowerBounds, forall_mem_range] at hx\n  exact ‚ü®x, hx‚ü©\n\n"}
{"name":"Continuous.exists_forall_le_of_hasCompactSupport","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\ninst‚úù‚Åµ : LinearOrder Œ±\ninst‚úù‚Å¥ : TopologicalSpace Œ±\ninst‚úù¬≥ : TopologicalSpace Œ≤\ninst‚úù¬≤ : ClosedIicTopology Œ±\ninst‚úù¬π : Nonempty Œ≤\ninst‚úù : Zero Œ±\nf : Œ≤ ‚Üí Œ±\nhf : Continuous f\nh : HasCompactSupport f\n‚ä¢ Exists fun x => ‚àÄ (y : Œ≤), LE.le (f x) (f y)","decl":"/-- A continuous function with compact support has a global minimum. -/\n@[to_additive \"A continuous function with compact support has a global minimum.\"]\ntheorem Continuous.exists_forall_le_of_hasCompactMulSupport [ClosedIicTopology Œ±] [Nonempty Œ≤]\n    [One Œ±] {f : Œ≤ ‚Üí Œ±} (hf : Continuous f) (h : HasCompactMulSupport f) :\n    ‚àÉ x : Œ≤, ‚àÄ y : Œ≤, f x ‚â§ f y := by\n  obtain ‚ü®_, ‚ü®x, rfl‚ü©, hx‚ü© := (h.isCompact_range hf).exists_isLeast (range_nonempty _)\n  rw [mem_lowerBounds, forall_mem_range] at hx\n  exact ‚ü®x, hx‚ü©\n\n"}
{"name":"Continuous.exists_forall_ge_of_hasCompactMulSupport","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\ninst‚úù‚Åµ : LinearOrder Œ±\ninst‚úù‚Å¥ : TopologicalSpace Œ±\ninst‚úù¬≥ : TopologicalSpace Œ≤\ninst‚úù¬≤ : ClosedIciTopology Œ±\ninst‚úù¬π : Nonempty Œ≤\ninst‚úù : One Œ±\nf : Œ≤ ‚Üí Œ±\nhf : Continuous f\nh : HasCompactMulSupport f\n‚ä¢ Exists fun x => ‚àÄ (y : Œ≤), LE.le (f y) (f x)","decl":"/-- A continuous function with compact support has a global maximum. -/\n@[to_additive \"A continuous function with compact support has a global maximum.\"]\ntheorem Continuous.exists_forall_ge_of_hasCompactMulSupport [ClosedIciTopology Œ±] [Nonempty Œ≤]\n    [One Œ±] {f : Œ≤ ‚Üí Œ±} (hf : Continuous f) (h : HasCompactMulSupport f) :\n    ‚àÉ x : Œ≤, ‚àÄ y : Œ≤, f y ‚â§ f x :=\n  Continuous.exists_forall_le_of_hasCompactMulSupport (Œ± := Œ±·µí·µà) hf h\n\n"}
{"name":"Continuous.exists_forall_ge_of_hasCompactSupport","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\ninst‚úù‚Åµ : LinearOrder Œ±\ninst‚úù‚Å¥ : TopologicalSpace Œ±\ninst‚úù¬≥ : TopologicalSpace Œ≤\ninst‚úù¬≤ : ClosedIciTopology Œ±\ninst‚úù¬π : Nonempty Œ≤\ninst‚úù : Zero Œ±\nf : Œ≤ ‚Üí Œ±\nhf : Continuous f\nh : HasCompactSupport f\n‚ä¢ Exists fun x => ‚àÄ (y : Œ≤), LE.le (f y) (f x)","decl":"/-- A continuous function with compact support has a global maximum. -/\n@[to_additive \"A continuous function with compact support has a global maximum.\"]\ntheorem Continuous.exists_forall_ge_of_hasCompactMulSupport [ClosedIciTopology Œ±] [Nonempty Œ≤]\n    [One Œ±] {f : Œ≤ ‚Üí Œ±} (hf : Continuous f) (h : HasCompactMulSupport f) :\n    ‚àÉ x : Œ≤, ‚àÄ y : Œ≤, f y ‚â§ f x :=\n  Continuous.exists_forall_le_of_hasCompactMulSupport (Œ± := Œ±·µí·µà) hf h\n\n"}
{"name":"IsCompact.bddBelow","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\ninst‚úù¬≥ : LinearOrder Œ±\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : ClosedIicTopology Œ±\ninst‚úù : Nonempty Œ±\ns : Set Œ±\nhs : IsCompact s\n‚ä¢ BddBelow s","decl":"/-- A compact set is bounded below -/\ntheorem IsCompact.bddBelow [ClosedIicTopology Œ±] [Nonempty Œ±] {s : Set Œ±} (hs : IsCompact s) :\n    BddBelow s := by\n  rcases s.eq_empty_or_nonempty with rfl | hne\n  ¬∑ exact bddBelow_empty\n  ¬∑ obtain ‚ü®a, -, has‚ü© := hs.exists_isLeast hne\n    exact ‚ü®a, has‚ü©\n\n"}
{"name":"IsCompact.bddAbove","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\ninst‚úù¬≥ : LinearOrder Œ±\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : ClosedIciTopology Œ±\ninst‚úù : Nonempty Œ±\ns : Set Œ±\nhs : IsCompact s\n‚ä¢ BddAbove s","decl":"/-- A compact set is bounded above -/\ntheorem IsCompact.bddAbove [ClosedIciTopology Œ±] [Nonempty Œ±] {s : Set Œ±} (hs : IsCompact s) :\n    BddAbove s :=\n  IsCompact.bddBelow (Œ± := Œ±·µí·µà) hs\n\n"}
{"name":"IsCompact.bddBelow_image","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\ninst‚úù‚Å¥ : LinearOrder Œ±\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : TopologicalSpace Œ≤\ninst‚úù¬π : ClosedIicTopology Œ±\ninst‚úù : Nonempty Œ±\nf : Œ≤ ‚Üí Œ±\nK : Set Œ≤\nhK : IsCompact K\nhf : ContinuousOn f K\n‚ä¢ BddBelow (Set.image f K)","decl":"/-- A continuous function is bounded below on a compact set. -/\ntheorem IsCompact.bddBelow_image [ClosedIicTopology Œ±] [Nonempty Œ±] {f : Œ≤ ‚Üí Œ±} {K : Set Œ≤}\n    (hK : IsCompact K) (hf : ContinuousOn f K) : BddBelow (f '' K) :=\n  (hK.image_of_continuousOn hf).bddBelow\n\n"}
{"name":"IsCompact.bddAbove_image","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\ninst‚úù‚Å¥ : LinearOrder Œ±\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : TopologicalSpace Œ≤\ninst‚úù¬π : ClosedIciTopology Œ±\ninst‚úù : Nonempty Œ±\nf : Œ≤ ‚Üí Œ±\nK : Set Œ≤\nhK : IsCompact K\nhf : ContinuousOn f K\n‚ä¢ BddAbove (Set.image f K)","decl":"/-- A continuous function is bounded above on a compact set. -/\ntheorem IsCompact.bddAbove_image [ClosedIciTopology Œ±] [Nonempty Œ±] {f : Œ≤ ‚Üí Œ±} {K : Set Œ≤}\n    (hK : IsCompact K) (hf : ContinuousOn f K) : BddAbove (f '' K) :=\n  IsCompact.bddBelow_image (Œ± := Œ±·µí·µà) hK hf\n\n"}
{"name":"Continuous.bddBelow_range_of_hasCompactSupport","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\ninst‚úù‚Å¥ : LinearOrder Œ±\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : TopologicalSpace Œ≤\ninst‚úù¬π : ClosedIicTopology Œ±\ninst‚úù : Zero Œ±\nf : Œ≤ ‚Üí Œ±\nhf : Continuous f\nh : HasCompactSupport f\n‚ä¢ BddBelow (Set.range f)","decl":"/-- A continuous function with compact support is bounded below. -/\n@[to_additive \" A continuous function with compact support is bounded below. \"]\ntheorem Continuous.bddBelow_range_of_hasCompactMulSupport [ClosedIicTopology Œ±] [One Œ±]\n    {f : Œ≤ ‚Üí Œ±} (hf : Continuous f) (h : HasCompactMulSupport f) : BddBelow (range f) :=\n  (h.isCompact_range hf).bddBelow\n\n"}
{"name":"Continuous.bddBelow_range_of_hasCompactMulSupport","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\ninst‚úù‚Å¥ : LinearOrder Œ±\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : TopologicalSpace Œ≤\ninst‚úù¬π : ClosedIicTopology Œ±\ninst‚úù : One Œ±\nf : Œ≤ ‚Üí Œ±\nhf : Continuous f\nh : HasCompactMulSupport f\n‚ä¢ BddBelow (Set.range f)","decl":"/-- A continuous function with compact support is bounded below. -/\n@[to_additive \" A continuous function with compact support is bounded below. \"]\ntheorem Continuous.bddBelow_range_of_hasCompactMulSupport [ClosedIicTopology Œ±] [One Œ±]\n    {f : Œ≤ ‚Üí Œ±} (hf : Continuous f) (h : HasCompactMulSupport f) : BddBelow (range f) :=\n  (h.isCompact_range hf).bddBelow\n\n"}
{"name":"Continuous.bddAbove_range_of_hasCompactMulSupport","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\ninst‚úù‚Å¥ : LinearOrder Œ±\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : TopologicalSpace Œ≤\ninst‚úù¬π : ClosedIciTopology Œ±\ninst‚úù : One Œ±\nf : Œ≤ ‚Üí Œ±\nhf : Continuous f\nh : HasCompactMulSupport f\n‚ä¢ BddAbove (Set.range f)","decl":"/-- A continuous function with compact support is bounded above. -/\n@[to_additive \" A continuous function with compact support is bounded above. \"]\ntheorem Continuous.bddAbove_range_of_hasCompactMulSupport [ClosedIciTopology Œ±] [One Œ±]\n    {f : Œ≤ ‚Üí Œ±} (hf : Continuous f) (h : HasCompactMulSupport f) : BddAbove (range f) :=\n  Continuous.bddBelow_range_of_hasCompactMulSupport (Œ± := Œ±·µí·µà) hf h\n\n"}
{"name":"Continuous.bddAbove_range_of_hasCompactSupport","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\ninst‚úù‚Å¥ : LinearOrder Œ±\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : TopologicalSpace Œ≤\ninst‚úù¬π : ClosedIciTopology Œ±\ninst‚úù : Zero Œ±\nf : Œ≤ ‚Üí Œ±\nhf : Continuous f\nh : HasCompactSupport f\n‚ä¢ BddAbove (Set.range f)","decl":"/-- A continuous function with compact support is bounded above. -/\n@[to_additive \" A continuous function with compact support is bounded above. \"]\ntheorem Continuous.bddAbove_range_of_hasCompactMulSupport [ClosedIciTopology Œ±] [One Œ±]\n    {f : Œ≤ ‚Üí Œ±} (hf : Continuous f) (h : HasCompactMulSupport f) : BddAbove (range f) :=\n  Continuous.bddBelow_range_of_hasCompactMulSupport (Œ± := Œ±·µí·µà) hf h\n\n"}
{"name":"IsCompact.sSup_lt_iff_of_continuous","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\ninst‚úù¬≥ : ConditionallyCompleteLinearOrder Œ±\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : TopologicalSpace Œ≤\ninst‚úù : ClosedIciTopology Œ±\nf : Œ≤ ‚Üí Œ±\nK : Set Œ≤\nhK : IsCompact K\nh0K : K.Nonempty\nhf : ContinuousOn f K\ny : Œ±\n‚ä¢ Iff (LT.lt (SupSet.sSup (Set.image f K)) y) (‚àÄ (x : Œ≤), Membership.mem K x ‚Üí LT.lt (f x) y)","decl":"theorem IsCompact.sSup_lt_iff_of_continuous [ClosedIciTopology Œ±] {f : Œ≤ ‚Üí Œ±} {K : Set Œ≤}\n    (hK : IsCompact K) (h0K : K.Nonempty) (hf : ContinuousOn f K) (y : Œ±) :\n    sSup (f '' K) < y ‚Üî ‚àÄ x ‚àà K, f x < y := by\n  refine ‚ü®fun h x hx => (le_csSup (hK.bddAbove_image hf) <| mem_image_of_mem f hx).trans_lt h,\n    fun h => ?_‚ü©\n  obtain ‚ü®x, hx, h2x‚ü© := hK.exists_isMaxOn h0K hf\n  refine (csSup_le (h0K.image f) ?_).trans_lt (h x hx)\n  rintro _ ‚ü®x', hx', rfl‚ü©; exact h2x hx'\n\n"}
{"name":"IsCompact.lt_sInf_iff_of_continuous","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\ninst‚úù¬≥ : ConditionallyCompleteLinearOrder Œ±\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : TopologicalSpace Œ≤\ninst‚úù : ClosedIicTopology Œ±\nf : Œ≤ ‚Üí Œ±\nK : Set Œ≤\nhK : IsCompact K\nh0K : K.Nonempty\nhf : ContinuousOn f K\ny : Œ±\n‚ä¢ Iff (LT.lt y (InfSet.sInf (Set.image f K))) (‚àÄ (x : Œ≤), Membership.mem K x ‚Üí LT.lt y (f x))","decl":"theorem IsCompact.lt_sInf_iff_of_continuous [ClosedIicTopology Œ±] {f : Œ≤ ‚Üí Œ±} {K : Set Œ≤}\n    (hK : IsCompact K) (h0K : K.Nonempty) (hf : ContinuousOn f K) (y : Œ±) :\n    y < sInf (f '' K) ‚Üî ‚àÄ x ‚àà K, y < f x :=\n  IsCompact.sSup_lt_iff_of_continuous (Œ± := Œ±·µí·µà) hK h0K hf y\n\n"}
{"name":"IsCompact.sInf_mem","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\ninst‚úù¬≤ : ConditionallyCompleteLinearOrder Œ±\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : ClosedIicTopology Œ±\ns : Set Œ±\nhs : IsCompact s\nne_s : s.Nonempty\n‚ä¢ Membership.mem s (InfSet.sInf s)","decl":"theorem IsCompact.sInf_mem [ClosedIicTopology Œ±] {s : Set Œ±} (hs : IsCompact s)\n    (ne_s : s.Nonempty) : sInf s ‚àà s :=\n  let ‚ü®_a, ha‚ü© := hs.exists_isLeast ne_s\n  ha.csInf_mem\n\n"}
{"name":"IsCompact.sSup_mem","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\ninst‚úù¬≤ : ConditionallyCompleteLinearOrder Œ±\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : ClosedIciTopology Œ±\ns : Set Œ±\nhs : IsCompact s\nne_s : s.Nonempty\n‚ä¢ Membership.mem s (SupSet.sSup s)","decl":"theorem IsCompact.sSup_mem [ClosedIciTopology Œ±] {s : Set Œ±} (hs : IsCompact s)\n    (ne_s : s.Nonempty) : sSup s ‚àà s :=\n  IsCompact.sInf_mem (Œ± := Œ±·µí·µà) hs ne_s\n\n"}
{"name":"IsCompact.isGLB_sInf","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\ninst‚úù¬≤ : ConditionallyCompleteLinearOrder Œ±\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : ClosedIicTopology Œ±\ns : Set Œ±\nhs : IsCompact s\nne_s : s.Nonempty\n‚ä¢ IsGLB s (InfSet.sInf s)","decl":"theorem IsCompact.isGLB_sInf [ClosedIicTopology Œ±] {s : Set Œ±} (hs : IsCompact s)\n    (ne_s : s.Nonempty) : IsGLB s (sInf s) :=\n  isGLB_csInf ne_s hs.bddBelow\n\n"}
{"name":"IsCompact.isLUB_sSup","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\ninst‚úù¬≤ : ConditionallyCompleteLinearOrder Œ±\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : ClosedIciTopology Œ±\ns : Set Œ±\nhs : IsCompact s\nne_s : s.Nonempty\n‚ä¢ IsLUB s (SupSet.sSup s)","decl":"theorem IsCompact.isLUB_sSup [ClosedIciTopology Œ±] {s : Set Œ±} (hs : IsCompact s)\n    (ne_s : s.Nonempty) : IsLUB s (sSup s) :=\n  IsCompact.isGLB_sInf (Œ± := Œ±·µí·µà) hs ne_s\n\n"}
{"name":"IsCompact.isLeast_sInf","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\ninst‚úù¬≤ : ConditionallyCompleteLinearOrder Œ±\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : ClosedIicTopology Œ±\ns : Set Œ±\nhs : IsCompact s\nne_s : s.Nonempty\n‚ä¢ IsLeast s (InfSet.sInf s)","decl":"theorem IsCompact.isLeast_sInf [ClosedIicTopology Œ±] {s : Set Œ±} (hs : IsCompact s)\n    (ne_s : s.Nonempty) : IsLeast s (sInf s) :=\n  ‚ü®hs.sInf_mem ne_s, (hs.isGLB_sInf ne_s).1‚ü©\n\n"}
{"name":"IsCompact.isGreatest_sSup","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\ninst‚úù¬≤ : ConditionallyCompleteLinearOrder Œ±\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : ClosedIciTopology Œ±\ns : Set Œ±\nhs : IsCompact s\nne_s : s.Nonempty\n‚ä¢ IsGreatest s (SupSet.sSup s)","decl":"theorem IsCompact.isGreatest_sSup [ClosedIciTopology Œ±] {s : Set Œ±} (hs : IsCompact s)\n    (ne_s : s.Nonempty) : IsGreatest s (sSup s) :=\n  IsCompact.isLeast_sInf (Œ± := Œ±·µí·µà) hs ne_s\n\n"}
{"name":"IsCompact.exists_sInf_image_eq_and_le","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\ninst‚úù¬≥ : ConditionallyCompleteLinearOrder Œ±\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : TopologicalSpace Œ≤\ninst‚úù : ClosedIicTopology Œ±\ns : Set Œ≤\nhs : IsCompact s\nne_s : s.Nonempty\nf : Œ≤ ‚Üí Œ±\nhf : ContinuousOn f s\n‚ä¢ Exists fun x => And (Membership.mem s x) (And (Eq (InfSet.sInf (Set.image f s)) (f x)) (‚àÄ (y : Œ≤), Membership.mem s y ‚Üí LE.le (f x) (f y)))","decl":"theorem IsCompact.exists_sInf_image_eq_and_le [ClosedIicTopology Œ±] {s : Set Œ≤}\n    (hs : IsCompact s) (ne_s : s.Nonempty) {f : Œ≤ ‚Üí Œ±} (hf : ContinuousOn f s) :\n    ‚àÉ x ‚àà s, sInf (f '' s) = f x ‚àß ‚àÄ y ‚àà s, f x ‚â§ f y :=\n  let ‚ü®x, hxs, hx‚ü© := (hs.image_of_continuousOn hf).sInf_mem (ne_s.image f)\n  ‚ü®x, hxs, hx.symm, fun _y hy =>\n    hx.trans_le <| csInf_le (hs.image_of_continuousOn hf).bddBelow <| mem_image_of_mem f hy‚ü©\n\n"}
{"name":"IsCompact.exists_sSup_image_eq_and_ge","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\ninst‚úù¬≥ : ConditionallyCompleteLinearOrder Œ±\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : TopologicalSpace Œ≤\ninst‚úù : ClosedIciTopology Œ±\ns : Set Œ≤\nhs : IsCompact s\nne_s : s.Nonempty\nf : Œ≤ ‚Üí Œ±\nhf : ContinuousOn f s\n‚ä¢ Exists fun x => And (Membership.mem s x) (And (Eq (SupSet.sSup (Set.image f s)) (f x)) (‚àÄ (y : Œ≤), Membership.mem s y ‚Üí LE.le (f y) (f x)))","decl":"theorem IsCompact.exists_sSup_image_eq_and_ge [ClosedIciTopology Œ±] {s : Set Œ≤}\n    (hs : IsCompact s) (ne_s : s.Nonempty) {f : Œ≤ ‚Üí Œ±} (hf : ContinuousOn f s) :\n    ‚àÉ x ‚àà s, sSup (f '' s) = f x ‚àß ‚àÄ y ‚àà s, f y ‚â§ f x :=\n  IsCompact.exists_sInf_image_eq_and_le (Œ± := Œ±·µí·µà) hs ne_s hf\n\n"}
{"name":"IsCompact.exists_sInf_image_eq","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\ninst‚úù¬≥ : ConditionallyCompleteLinearOrder Œ±\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : TopologicalSpace Œ≤\ninst‚úù : ClosedIicTopology Œ±\ns : Set Œ≤\nhs : IsCompact s\nne_s : s.Nonempty\nf : Œ≤ ‚Üí Œ±\nhf : ContinuousOn f s\n‚ä¢ Exists fun x => And (Membership.mem s x) (Eq (InfSet.sInf (Set.image f s)) (f x))","decl":"theorem IsCompact.exists_sInf_image_eq [ClosedIicTopology Œ±] {s : Set Œ≤} (hs : IsCompact s)\n    (ne_s : s.Nonempty) {f : Œ≤ ‚Üí Œ±} (hf : ContinuousOn f s) : ‚àÉ x ‚àà s, sInf (f '' s) = f x :=\n  let ‚ü®x, hxs, hx, _‚ü© := hs.exists_sInf_image_eq_and_le ne_s hf\n  ‚ü®x, hxs, hx‚ü©\n\n"}
{"name":"IsCompact.exists_sSup_image_eq","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\ninst‚úù¬≥ : ConditionallyCompleteLinearOrder Œ±\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : TopologicalSpace Œ≤\ninst‚úù : ClosedIciTopology Œ±\ns : Set Œ≤\nhs : IsCompact s\nne_s : s.Nonempty\nf : Œ≤ ‚Üí Œ±\na‚úù : ContinuousOn f s\n‚ä¢ Exists fun x => And (Membership.mem s x) (Eq (SupSet.sSup (Set.image f s)) (f x))","decl":"theorem IsCompact.exists_sSup_image_eq [ClosedIciTopology Œ±] {s : Set Œ≤} (hs : IsCompact s)\n    (ne_s : s.Nonempty) : ‚àÄ {f : Œ≤ ‚Üí Œ±}, ContinuousOn f s ‚Üí ‚àÉ x ‚àà s, sSup (f '' s) = f x :=\n  IsCompact.exists_sInf_image_eq (Œ± := Œ±·µí·µà) hs ne_s\n\n"}
{"name":"IsCompact.exists_isMinOn_mem_subset","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\ninst‚úù¬≥ : LinearOrder Œ±\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : TopologicalSpace Œ≤\ninst‚úù : ClosedIicTopology Œ±\nf : Œ≤ ‚Üí Œ±\ns t : Set Œ≤\nz : Œ≤\nht : IsCompact t\nhf : ContinuousOn f t\nhz : Membership.mem t z\nhfz : ‚àÄ (z' : Œ≤), Membership.mem (SDiff.sdiff t s) z' ‚Üí LT.lt (f z) (f z')\n‚ä¢ Exists fun x => And (Membership.mem s x) (IsMinOn f t x)","decl":"theorem IsCompact.exists_isMinOn_mem_subset [ClosedIicTopology Œ±] {f : Œ≤ ‚Üí Œ±} {s t : Set Œ≤}\n    {z : Œ≤} (ht : IsCompact t) (hf : ContinuousOn f t) (hz : z ‚àà t)\n    (hfz : ‚àÄ z' ‚àà t \\ s, f z < f z') : ‚àÉ x ‚àà s, IsMinOn f t x :=\n  let ‚ü®x, hxt, hfx‚ü© := ht.exists_isMinOn ‚ü®z, hz‚ü© hf\n  ‚ü®x, by_contra fun hxs => (hfz x ‚ü®hxt, hxs‚ü©).not_le (hfx hz), hfx‚ü©\n\n"}
{"name":"IsCompact.exists_isMaxOn_mem_subset","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\ninst‚úù¬≥ : LinearOrder Œ±\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : TopologicalSpace Œ≤\ninst‚úù : ClosedIciTopology Œ±\nf : Œ≤ ‚Üí Œ±\ns t : Set Œ≤\nz : Œ≤\nht : IsCompact t\nhf : ContinuousOn f t\nhz : Membership.mem t z\nhfz : ‚àÄ (z' : Œ≤), Membership.mem (SDiff.sdiff t s) z' ‚Üí LT.lt (f z') (f z)\n‚ä¢ Exists fun x => And (Membership.mem s x) (IsMaxOn f t x)","decl":"theorem IsCompact.exists_isMaxOn_mem_subset [ClosedIciTopology Œ±] {f : Œ≤ ‚Üí Œ±} {s t : Set Œ≤}\n    {z : Œ≤} (ht : IsCompact t) (hf : ContinuousOn f t) (hz : z ‚àà t)\n    (hfz : ‚àÄ z' ‚àà t \\ s, f z' < f z) : ‚àÉ x ‚àà s, IsMaxOn f t x :=\n  let ‚ü®x, hxt, hfx‚ü© := ht.exists_isMaxOn ‚ü®z, hz‚ü© hf\n  ‚ü®x, by_contra fun hxs => (hfz x ‚ü®hxt, hxs‚ü©).not_le (hfx hz), hfx‚ü©\n\n-- Porting note: rfc: assume `t ‚àà ùìùÀ¢ s` (a.k.a. `s ‚äÜ interior t`) instead of `s ‚äÜ t` and\n-- `IsOpen s`?\n"}
{"name":"IsCompact.exists_isLocalMin_mem_open","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\ninst‚úù¬≥ : LinearOrder Œ±\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : TopologicalSpace Œ≤\ninst‚úù : ClosedIicTopology Œ±\nf : Œ≤ ‚Üí Œ±\ns t : Set Œ≤\nz : Œ≤\nht : IsCompact t\nhst : HasSubset.Subset s t\nhf : ContinuousOn f t\nhz : Membership.mem t z\nhfz : ‚àÄ (z' : Œ≤), Membership.mem (SDiff.sdiff t s) z' ‚Üí LT.lt (f z) (f z')\nhs : IsOpen s\n‚ä¢ Exists fun x => And (Membership.mem s x) (IsLocalMin f x)","decl":"theorem IsCompact.exists_isLocalMin_mem_open [ClosedIicTopology Œ±] {f : Œ≤ ‚Üí Œ±} {s t : Set Œ≤}\n    {z : Œ≤} (ht : IsCompact t) (hst : s ‚äÜ t) (hf : ContinuousOn f t) (hz : z ‚àà t)\n    (hfz : ‚àÄ z' ‚àà t \\ s, f z < f z') (hs : IsOpen s) : ‚àÉ x ‚àà s, IsLocalMin f x :=\n  let ‚ü®x, hxs, h‚ü© := ht.exists_isMinOn_mem_subset hf hz hfz\n  ‚ü®x, hxs, h.isLocalMin <| mem_nhds_iff.2 ‚ü®s, hst, hs, hxs‚ü©‚ü©\n\n"}
{"name":"IsCompact.exists_isLocalMax_mem_open","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\ninst‚úù¬≥ : LinearOrder Œ±\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : TopologicalSpace Œ≤\ninst‚úù : ClosedIciTopology Œ±\nf : Œ≤ ‚Üí Œ±\ns t : Set Œ≤\nz : Œ≤\nht : IsCompact t\nhst : HasSubset.Subset s t\nhf : ContinuousOn f t\nhz : Membership.mem t z\nhfz : ‚àÄ (z' : Œ≤), Membership.mem (SDiff.sdiff t s) z' ‚Üí LT.lt (f z') (f z)\nhs : IsOpen s\n‚ä¢ Exists fun x => And (Membership.mem s x) (IsLocalMax f x)","decl":"theorem IsCompact.exists_isLocalMax_mem_open [ClosedIciTopology Œ±] {f : Œ≤ ‚Üí Œ±} {s t : Set Œ≤}\n    {z : Œ≤} (ht : IsCompact t) (hst : s ‚äÜ t) (hf : ContinuousOn f t) (hz : z ‚àà t)\n    (hfz : ‚àÄ z' ‚àà t \\ s, f z' < f z) (hs : IsOpen s) : ‚àÉ x ‚àà s, IsLocalMax f x :=\n  let ‚ü®x, hxs, h‚ü© := ht.exists_isMaxOn_mem_subset hf hz hfz\n  ‚ü®x, hxs, h.isLocalMax <| mem_nhds_iff.2 ‚ü®s, hst, hs, hxs‚ü©‚ü©\n\n"}
{"name":"eq_Icc_of_connected_compact","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\ninst‚úù¬≤ : ConditionallyCompleteLinearOrder Œ±\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : OrderTopology Œ±\ns : Set Œ±\nh‚ÇÅ : IsConnected s\nh‚ÇÇ : IsCompact s\n‚ä¢ Eq s (Set.Icc (InfSet.sInf s) (SupSet.sSup s))","decl":"theorem eq_Icc_of_connected_compact {s : Set Œ±} (h‚ÇÅ : IsConnected s) (h‚ÇÇ : IsCompact s) :\n    s = Icc (sInf s) (sSup s) :=\n  eq_Icc_csInf_csSup_of_connected_bdd_closed h‚ÇÅ h‚ÇÇ.bddBelow h‚ÇÇ.bddAbove h‚ÇÇ.isClosed\n\n"}
{"name":"IsCompact.continuous_sSup","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\nŒ≥ : Type u_4\ninst‚úù‚Å¥ : ConditionallyCompleteLinearOrder Œ±\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : OrderTopology Œ±\ninst‚úù¬π : TopologicalSpace Œ≤\ninst‚úù : TopologicalSpace Œ≥\nf : Œ≥ ‚Üí Œ≤ ‚Üí Œ±\nK : Set Œ≤\nhK : IsCompact K\nhf : Continuous (Function.HasUncurry.uncurry f)\n‚ä¢ Continuous fun x => SupSet.sSup (Set.image (f x) K)","decl":"/-- If `f : Œ≥ ‚Üí Œ≤ ‚Üí Œ±` is a function that is continuous as a function on `Œ≥ √ó Œ≤`, `Œ±` is a\nconditionally complete linear order, and `K : Set Œ≤` is a compact set, then\n`fun x ‚Ü¶ sSup (f x '' K)` is a continuous function. -/\n/- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: generalize. The following version seems to be true:\n```\ntheorem IsCompact.tendsto_sSup {f : Œ≥ ‚Üí Œ≤ ‚Üí Œ±} {g : Œ≤ ‚Üí Œ±} {K : Set Œ≤} {l : Filter Œ≥}\n    (hK : IsCompact K) (hf : ‚àÄ y ‚àà K, Tendsto ‚Üøf (l √óÀ¢ ùìù[K] y) (ùìù (g y)))\n    (hgc : ContinuousOn g K) :\n    Tendsto (fun x => sSup (f x '' K)) l (ùìù (sSup (g '' K))) := _\n```\nMoreover, it seems that `hgc` follows from `hf` (Yury Kudryashov). -/\ntheorem IsCompact.continuous_sSup {f : Œ≥ ‚Üí Œ≤ ‚Üí Œ±} {K : Set Œ≤} (hK : IsCompact K)\n    (hf : Continuous ‚Üøf) : Continuous fun x => sSup (f x '' K) := by\n  rcases eq_empty_or_nonempty K with (rfl | h0K)\n  ¬∑ simp_rw [image_empty]\n    exact continuous_const\n  rw [continuous_iff_continuousAt]\n  intro x\n  obtain ‚ü®y, hyK, h2y, hy‚ü© :=\n    hK.exists_sSup_image_eq_and_ge h0K\n      (show Continuous fun y => f x y from hf.comp <| Continuous.Prod.mk x).continuousOn\n  rw [ContinuousAt, h2y, tendsto_order]\n  have := tendsto_order.mp ((show Continuous fun x => f x y\n    from hf.comp <| continuous_id.prod_mk continuous_const).tendsto x)\n  refine ‚ü®fun z hz => ?_, fun z hz => ?_‚ü©\n  ¬∑ refine (this.1 z hz).mono fun x' hx' =>\n      hx'.trans_le <| le_csSup ?_ <| mem_image_of_mem (f x') hyK\n    exact hK.bddAbove_image (hf.comp <| Continuous.Prod.mk x').continuousOn\n  ¬∑ have h : ({x} : Set Œ≥) √óÀ¢ K ‚äÜ ‚Üøf ‚Åª¬π' Iio z := by\n      rintro ‚ü®x', y'‚ü© ‚ü®(rfl : x' = x), hy'‚ü©\n      exact (hy y' hy').trans_lt hz\n    obtain ‚ü®u, v, hu, _, hxu, hKv, huv‚ü© :=\n      generalized_tube_lemma isCompact_singleton hK (isOpen_Iio.preimage hf) h\n    refine eventually_of_mem (hu.mem_nhds (singleton_subset_iff.mp hxu)) fun x' hx' => ?_\n    rw [hK.sSup_lt_iff_of_continuous h0K\n        (show Continuous (f x') from hf.comp <| Continuous.Prod.mk x').continuousOn]\n    exact fun y' hy' => huv (mk_mem_prod hx' (hKv hy'))\n\n"}
{"name":"IsCompact.continuous_sInf","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\nŒ≥ : Type u_4\ninst‚úù‚Å¥ : ConditionallyCompleteLinearOrder Œ±\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : OrderTopology Œ±\ninst‚úù¬π : TopologicalSpace Œ≤\ninst‚úù : TopologicalSpace Œ≥\nf : Œ≥ ‚Üí Œ≤ ‚Üí Œ±\nK : Set Œ≤\nhK : IsCompact K\nhf : Continuous (Function.HasUncurry.uncurry f)\n‚ä¢ Continuous fun x => InfSet.sInf (Set.image (f x) K)","decl":"theorem IsCompact.continuous_sInf {f : Œ≥ ‚Üí Œ≤ ‚Üí Œ±} {K : Set Œ≤} (hK : IsCompact K)\n    (hf : Continuous ‚Üøf) : Continuous fun x => sInf (f x '' K) :=\n  IsCompact.continuous_sSup (Œ± := Œ±·µí·µà) hK hf\n\n"}
{"name":"ContinuousOn.image_Icc","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\ninst‚úù‚Å∂ : ConditionallyCompleteLinearOrder Œ±\ninst‚úù‚Åµ : TopologicalSpace Œ±\ninst‚úù‚Å¥ : OrderTopology Œ±\ninst‚úù¬≥ : TopologicalSpace Œ≤\ninst‚úù¬≤ : DenselyOrdered Œ±\ninst‚úù¬π : ConditionallyCompleteLinearOrder Œ≤\ninst‚úù : OrderTopology Œ≤\nf : Œ± ‚Üí Œ≤\na b : Œ±\nhab : LE.le a b\nh : ContinuousOn f (Set.Icc a b)\n‚ä¢ Eq (Set.image f (Set.Icc a b)) (Set.Icc (InfSet.sInf (Set.image f (Set.Icc a b))) (SupSet.sSup (Set.image f (Set.Icc a b))))","decl":"theorem image_Icc (hab : a ‚â§ b) (h : ContinuousOn f <| Icc a b) :\n    f '' Icc a b = Icc (sInf <| f '' Icc a b) (sSup <| f '' Icc a b) :=\n  eq_Icc_of_connected_compact ‚ü®(nonempty_Icc.2 hab).image f, isPreconnected_Icc.image f h‚ü©\n    (isCompact_Icc.image_of_continuousOn h)\n\n"}
{"name":"ContinuousOn.image_uIcc_eq_Icc","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\ninst‚úù‚Å∂ : ConditionallyCompleteLinearOrder Œ±\ninst‚úù‚Åµ : TopologicalSpace Œ±\ninst‚úù‚Å¥ : OrderTopology Œ±\ninst‚úù¬≥ : TopologicalSpace Œ≤\ninst‚úù¬≤ : DenselyOrdered Œ±\ninst‚úù¬π : ConditionallyCompleteLinearOrder Œ≤\ninst‚úù : OrderTopology Œ≤\nf : Œ± ‚Üí Œ≤\na b : Œ±\nh : ContinuousOn f (Set.uIcc a b)\n‚ä¢ Eq (Set.image f (Set.uIcc a b)) (Set.Icc (InfSet.sInf (Set.image f (Set.uIcc a b))) (SupSet.sSup (Set.image f (Set.uIcc a b))))","decl":"theorem image_uIcc_eq_Icc (h : ContinuousOn f [[a, b]]) :\n    f '' [[a, b]] = Icc (sInf (f '' [[a, b]])) (sSup (f '' [[a, b]])) :=\n  image_Icc min_le_max h\n\n"}
{"name":"ContinuousOn.image_uIcc","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\ninst‚úù‚Å∂ : ConditionallyCompleteLinearOrder Œ±\ninst‚úù‚Åµ : TopologicalSpace Œ±\ninst‚úù‚Å¥ : OrderTopology Œ±\ninst‚úù¬≥ : TopologicalSpace Œ≤\ninst‚úù¬≤ : DenselyOrdered Œ±\ninst‚úù¬π : ConditionallyCompleteLinearOrder Œ≤\ninst‚úù : OrderTopology Œ≤\nf : Œ± ‚Üí Œ≤\na b : Œ±\nh : ContinuousOn f (Set.uIcc a b)\n‚ä¢ Eq (Set.image f (Set.uIcc a b)) (Set.uIcc (InfSet.sInf (Set.image f (Set.uIcc a b))) (SupSet.sSup (Set.image f (Set.uIcc a b))))","decl":"theorem image_uIcc (h : ContinuousOn f <| [[a, b]]) :\n    f '' [[a, b]] = [[sInf (f '' [[a, b]]), sSup (f '' [[a, b]])]] := by\n  refine h.image_uIcc_eq_Icc.trans (uIcc_of_le ?_).symm\n  refine csInf_le_csSup ?_ ?_ (nonempty_uIcc.image _) <;> rw [h.image_uIcc_eq_Icc]\n  exacts [bddBelow_Icc, bddAbove_Icc]\n\n"}
{"name":"ContinuousOn.sInf_image_Icc_le","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\ninst‚úù‚Å∂ : ConditionallyCompleteLinearOrder Œ±\ninst‚úù‚Åµ : TopologicalSpace Œ±\ninst‚úù‚Å¥ : OrderTopology Œ±\ninst‚úù¬≥ : TopologicalSpace Œ≤\ninst‚úù¬≤ : DenselyOrdered Œ±\ninst‚úù¬π : ConditionallyCompleteLinearOrder Œ≤\ninst‚úù : OrderTopology Œ≤\nf : Œ± ‚Üí Œ≤\na b c : Œ±\nh : ContinuousOn f (Set.Icc a b)\nhc : Membership.mem (Set.Icc a b) c\n‚ä¢ LE.le (InfSet.sInf (Set.image f (Set.Icc a b))) (f c)","decl":"theorem sInf_image_Icc_le (h : ContinuousOn f <| Icc a b) (hc : c ‚àà Icc a b) :\n    sInf (f '' Icc a b) ‚â§ f c := by\n  have := mem_image_of_mem f hc\n  rw [h.image_Icc (hc.1.trans hc.2)] at this\n  exact this.1\n\n"}
{"name":"ContinuousOn.le_sSup_image_Icc","module":"Mathlib.Topology.Order.Compact","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\ninst‚úù‚Å∂ : ConditionallyCompleteLinearOrder Œ±\ninst‚úù‚Åµ : TopologicalSpace Œ±\ninst‚úù‚Å¥ : OrderTopology Œ±\ninst‚úù¬≥ : TopologicalSpace Œ≤\ninst‚úù¬≤ : DenselyOrdered Œ±\ninst‚úù¬π : ConditionallyCompleteLinearOrder Œ≤\ninst‚úù : OrderTopology Œ≤\nf : Œ± ‚Üí Œ≤\na b c : Œ±\nh : ContinuousOn f (Set.Icc a b)\nhc : Membership.mem (Set.Icc a b) c\n‚ä¢ LE.le (f c) (SupSet.sSup (Set.image f (Set.Icc a b)))","decl":"theorem le_sSup_image_Icc (h : ContinuousOn f <| Icc a b) (hc : c ‚àà Icc a b) :\n    f c ‚â§ sSup (f '' Icc a b) := by\n  have := mem_image_of_mem f hc\n  rw [h.image_Icc (hc.1.trans hc.2)] at this\n  exact this.2\n\n"}
