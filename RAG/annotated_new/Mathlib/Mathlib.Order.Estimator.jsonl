{"name":"Estimator.bound_le","module":"Mathlib.Order.Estimator","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : Thunk α\nε : Type u_3\nself : Estimator a ε\ne : ε\n⊢ LE.le (EstimatorData.bound a e) a.get","decl":"/--\nGiven `[Estimator a ε]`\n* we have `bound a e ≤ a.get`, and\n* `improve a e` returns none iff `bound a e = a.get`,\n  and otherwise it returns a strictly better bound.\n-/\nclass Estimator [Preorder α] (a : Thunk α) (ε : Type*) extends EstimatorData a ε where\n  /-- The calculated bounds are always lower bounds. -/\n  bound_le e : bound e ≤ a.get\n  /-- Calling `improve` either gives a strictly better bound,\n  or a proof that the current bound is exact. -/\n  improve_spec e : match improve e with\n    | none => bound e = a.get\n    | some e' => bound e < bound e'\n\n"}
{"name":"Estimator.improve_spec","module":"Mathlib.Order.Estimator","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : Thunk α\nε : Type u_3\nself : Estimator a ε\ne : ε\n⊢ Estimator.match_1 ε (fun x => Prop) (EstimatorData.improve a e) (fun _ => Eq (EstimatorData.bound a e) a.get) fun e' => LT.lt (EstimatorData.bound a e) (EstimatorData.bound a e')","decl":"/--\nGiven `[Estimator a ε]`\n* we have `bound a e ≤ a.get`, and\n* `improve a e` returns none iff `bound a e = a.get`,\n  and otherwise it returns a strictly better bound.\n-/\nclass Estimator [Preorder α] (a : Thunk α) (ε : Type*) extends EstimatorData a ε where\n  /-- The calculated bounds are always lower bounds. -/\n  bound_le e : bound e ≤ a.get\n  /-- Calling `improve` either gives a strictly better bound,\n  or a proof that the current bound is exact. -/\n  improve_spec e : match improve e with\n    | none => bound e = a.get\n    | some e' => bound e < bound e'\n\n"}
{"name":"instWellFoundedGTUnit","module":"Mathlib.Order.Estimator","initialProofState":"⊢ WellFoundedGT Unit","decl":"instance : WellFoundedGT Unit where\n  wf := ⟨fun .unit => ⟨Unit.unit, nofun⟩⟩\n\n"}
{"name":"instWellFoundedGTTrivial","module":"Mathlib.Order.Estimator","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ WellFoundedGT (Estimator.trivial a)","decl":"instance (a : α) : WellFoundedGT (Estimator.trivial a) :=\n  let f : Estimator.trivial a ≃o Unit := RelIso.ofUniqueOfRefl _ _\n  let f' : Estimator.trivial a ↪o Unit := f.toOrderEmbedding\n  f'.wellFoundedGT\n\n"}
{"name":"Estimator.improveUntilAux_spec","module":"Mathlib.Order.Estimator","initialProofState":"α : Type u_1\nε : Type u_2\ninst✝² : Preorder α\na : Thunk α\np : α → Bool\ninst✝¹ : Estimator a ε\ninst✝ : WellFoundedGT ↑(Set.range (EstimatorData.bound a))\ne : ε\nr : Bool\n⊢ Estimator.improveUntilAux_spec.match_1 (fun x => Prop) (Estimator.improveUntilAux a p e r) (fun a_1 => Not (Eq (p a.get) Bool.true)) fun e' => Eq (p (EstimatorData.bound a e')) Bool.true","decl":"attribute [local instance] WellFoundedGT.toWellFoundedRelation in\n/--\nIf `Estimator.improveUntil a p e` returns `some e'`, then `bound a e'` satisfies `p`.\nOtherwise, that value `a` must not satisfy `p`.\n-/\ntheorem Estimator.improveUntilAux_spec (a : Thunk α) (p : α → Bool)\n    [Estimator a ε] [WellFoundedGT (range (bound a : ε → α))] (e : ε) (r : Bool) :\n    match Estimator.improveUntilAux a p e r with\n    | .error _ => ¬ p a.get\n    | .ok e' => p (bound a e') := by\n  rw [Estimator.improveUntilAux]\n  by_cases h : p (bound a e)\n  · simp only [h]; exact h\n  · simp only [h]\n    match improve a e, improve_spec e with\n    | none, eq =>\n      simp only [Bool.not_eq_true]\n      rw [eq] at h\n      exact Bool.bool_eq_false h\n    | some e', _ =>\n      exact Estimator.improveUntilAux_spec a p e' true\ntermination_by (⟨_, mem_range_self e⟩ : range (bound a))\n\n"}
{"name":"Estimator.improveUntil_spec","module":"Mathlib.Order.Estimator","initialProofState":"α : Type u_1\nε : Type u_2\ninst✝² : Preorder α\na : Thunk α\np : α → Bool\ninst✝¹ : Estimator a ε\ninst✝ : WellFoundedGT ↑(Set.range (EstimatorData.bound a))\ne : ε\n⊢ Estimator.improveUntilAux_spec.match_1 (fun x => Prop) (Estimator.improveUntil a p e) (fun a_1 => Not (Eq (p a.get) Bool.true)) fun e' => Eq (p (EstimatorData.bound a e')) Bool.true","decl":"/--\nIf `Estimator.improveUntil a p e` returns `some e'`, then `bound a e'` satisfies `p`.\nOtherwise, that value `a` must not satisfy `p`.\n-/\ntheorem Estimator.improveUntil_spec\n    (a : Thunk α) (p : α → Bool) [Estimator a ε] [WellFoundedGT (range (bound a : ε → α))] (e : ε) :\n    match Estimator.improveUntil a p e with\n    | .error _ => ¬ p a.get\n    | .ok e' => p (bound a e') :=\n  Estimator.improveUntilAux_spec a p e false\n\n"}
{"name":"instEstimatorDataHAddThunkProd_improve","module":"Mathlib.Order.Estimator","initialProofState":"α : Type u_1\ninst✝² : Add α\na b : Thunk α\nεa : Type u_3\nεb : Type u_4\ninst✝¹ : EstimatorData a εa\ninst✝ : EstimatorData b εb\ne : Prod εa εb\n⊢ Eq (EstimatorData.improve (HAdd.hAdd a b) e) (instEstimatorDataHAddThunkProd.match_1 εa (fun x => Option (Prod εa εb)) (EstimatorData.improve a e.1) (fun e' => Option.some { fst := e', snd := e.2 }) fun _ => instEstimatorDataHAddThunkProd.match_1 εb (fun x => Option (Prod εa εb)) (EstimatorData.improve b e.2) (fun e' => Option.some { fst := e.1, snd := e' }) fun _ => Option.none)","decl":"@[simps]\ninstance [Add α] {a b : Thunk α} (εa εb : Type*) [EstimatorData a εa] [EstimatorData b εb] :\n    EstimatorData (a + b) (εa × εb) where\n  bound e := bound a e.1 + bound b e.2\n  improve e := match improve a e.1 with\n  | some e' => some { e with fst := e' }\n  | none => match improve b e.2 with\n    | some e' => some { e with snd := e' }\n    | none => none\n\n"}
{"name":"instEstimatorDataHAddThunkProd_bound","module":"Mathlib.Order.Estimator","initialProofState":"α : Type u_1\ninst✝² : Add α\na b : Thunk α\nεa : Type u_3\nεb : Type u_4\ninst✝¹ : EstimatorData a εa\ninst✝ : EstimatorData b εb\ne : Prod εa εb\n⊢ Eq (EstimatorData.bound (HAdd.hAdd a b) e) (HAdd.hAdd (EstimatorData.bound a e.1) (EstimatorData.bound b e.2))","decl":"@[simps]\ninstance [Add α] {a b : Thunk α} (εa εb : Type*) [EstimatorData a εa] [EstimatorData b εb] :\n    EstimatorData (a + b) (εa × εb) where\n  bound e := bound a e.1 + bound b e.2\n  improve e := match improve a e.1 with\n  | some e' => some { e with fst := e' }\n  | none => match improve b e.2 with\n    | some e' => some { e with snd := e' }\n    | none => none\n\n"}
{"name":"Estimator.fst.mk.inj","module":"Mathlib.Order.Estimator","initialProofState":"α : Type u_1\nβ : Type u_3\ninst✝² : PartialOrder α\ninst✝¹ : PartialOrder β\np : Thunk (Prod α β)\nε : Type u_4\ninst✝ : Estimator p ε\ninner✝ inner : ε\nx✝ : Eq { inner := inner✝ } { inner := inner }\n⊢ Eq inner✝ inner","decl":"/--\nAn estimator for `(a, b)` can be turned into an estimator for `a`,\nsimply by repeatedly running `improve` until the first factor \"improves\".\nThe hypothesis that `>` is well-founded on `{ q // q ≤ (a, b) }` ensures this terminates.\n-/\nstructure Estimator.fst\n    (p : Thunk (α × β)) (ε : Type*) [Estimator p ε] where\n  /-- The wrapped bound for a value in `α × β`,\n  which we will use as a bound for the first component. -/\n  inner : ε\n\n"}
{"name":"Estimator.fst.mk.injEq","module":"Mathlib.Order.Estimator","initialProofState":"α : Type u_1\nβ : Type u_3\ninst✝² : PartialOrder α\ninst✝¹ : PartialOrder β\np : Thunk (Prod α β)\nε : Type u_4\ninst✝ : Estimator p ε\ninner✝ inner : ε\n⊢ Eq (Eq { inner := inner✝ } { inner := inner }) (Eq inner✝ inner)","decl":"/--\nAn estimator for `(a, b)` can be turned into an estimator for `a`,\nsimply by repeatedly running `improve` until the first factor \"improves\".\nThe hypothesis that `>` is well-founded on `{ q // q ≤ (a, b) }` ensures this terminates.\n-/\nstructure Estimator.fst\n    (p : Thunk (α × β)) (ε : Type*) [Estimator p ε] where\n  /-- The wrapped bound for a value in `α × β`,\n  which we will use as a bound for the first component. -/\n  inner : ε\n\n"}
{"name":"Estimator.fst.mk.sizeOf_spec","module":"Mathlib.Order.Estimator","initialProofState":"α : Type u_1\nβ : Type u_3\ninst✝⁵ : PartialOrder α\ninst✝⁴ : PartialOrder β\np : Thunk (Prod α β)\nε : Type u_4\ninst✝³ : Estimator p ε\ninst✝² : SizeOf α\ninst✝¹ : SizeOf β\ninst✝ : SizeOf ε\ninner : ε\n⊢ Eq (SizeOf.sizeOf { inner := inner }) (HAdd.hAdd 1 (SizeOf.sizeOf inner))","decl":"/--\nAn estimator for `(a, b)` can be turned into an estimator for `a`,\nsimply by repeatedly running `improve` until the first factor \"improves\".\nThe hypothesis that `>` is well-founded on `{ q // q ≤ (a, b) }` ensures this terminates.\n-/\nstructure Estimator.fst\n    (p : Thunk (α × β)) (ε : Type*) [Estimator p ε] where\n  /-- The wrapped bound for a value in `α × β`,\n  which we will use as a bound for the first component. -/\n  inner : ε\n\n"}
{"name":"instWellFoundedGTElemRangeBound","module":"Mathlib.Order.Estimator","initialProofState":"α : Type u_1\nε : Type u_2\ninst✝² : PartialOrder α\ninst✝¹ : ∀ (a : α), WellFoundedGT (Subtype fun x => LE.le x a)\na : Thunk α\ninst✝ : Estimator a ε\n⊢ WellFoundedGT ↑(Set.range (EstimatorData.bound a))","decl":"instance {a : Thunk α} [Estimator a ε] : WellFoundedGT (range (bound a : ε → α)) :=\n  let f : range (bound a : ε → α) ↪o { x // x ≤ a.get } :=\n    Subtype.orderEmbedding (by rintro _ ⟨e, rfl⟩; exact Estimator.bound_le e)\n  f.wellFoundedGT\n\n"}
