{"name":"Valuation.inversion_estimate","module":"Mathlib.Topology.Algebra.Valued.ValuedField","initialProofState":"K : Type u_1\ninstâœÂ¹ : DivisionRing K\nÎ“â‚€ : Type u_2\ninstâœ : LinearOrderedCommGroupWithZero Î“â‚€\nv : Valuation K Î“â‚€\nx y : K\nÎ³ : Units Î“â‚€\ny_ne : Ne y 0\nh : LT.lt (v (HSub.hSub x y)) (Min.min (HMul.hMul (â†‘Î³) (HMul.hMul (v y) (v y))) (v y))\nâŠ¢ LT.lt (v (HSub.hSub (Inv.inv x) (Inv.inv y))) â†‘Î³","decl":"theorem Valuation.inversion_estimate {x y : K} {Î³ : Î“â‚€Ë£} (y_ne : y â‰  0)\n    (h : v (x - y) < min (Î³ * (v y * v y)) (v y)) : v (xâ»Â¹ - yâ»Â¹) < Î³ := by\n  have hyp1 : v (x - y) < Î³ * (v y * v y) := lt_of_lt_of_le h (min_le_left _ _)\n  have hyp1' : v (x - y) * (v y * v y)â»Â¹ < Î³ := mul_inv_lt_of_lt_mulâ‚€ hyp1\n  have hyp2 : v (x - y) < v y := lt_of_lt_of_le h (min_le_right _ _)\n  have key : v x = v y := Valuation.map_eq_of_sub_lt v hyp2\n  have x_ne : x â‰  0 := by\n    intro h\n    apply y_ne\n    rw [h, v.map_zero] at key\n    exact v.zero_iff.1 key.symm\n  have decomp : xâ»Â¹ - yâ»Â¹ = xâ»Â¹ * (y - x) * yâ»Â¹ := by\n    rw [mul_sub_left_distrib, sub_mul, mul_assoc, show y * yâ»Â¹ = 1 from mul_inv_cancelâ‚€ y_ne,\n      show xâ»Â¹ * x = 1 from inv_mul_cancelâ‚€ x_ne, mul_one, one_mul]\n  calc\n    v (xâ»Â¹ - yâ»Â¹) = v (xâ»Â¹ * (y - x) * yâ»Â¹) := by rw [decomp]\n    _ = v xâ»Â¹ * (v <| y - x) * v yâ»Â¹ := by repeat' rw [Valuation.map_mul]\n    _ = (v x)â»Â¹ * (v <| y - x) * (v y)â»Â¹ := by rw [map_invâ‚€, map_invâ‚€]\n    _ = (v <| y - x) * (v y * v y)â»Â¹ := by rw [mul_assoc, mul_comm, key, mul_assoc, mul_inv_rev]\n    _ = (v <| y - x) * (v y * v y)â»Â¹ := rfl\n    _ = (v <| x - y) * (v y * v y)â»Â¹ := by rw [Valuation.map_sub_swap]\n    _ < Î³ := hyp1'\n\n"}
{"name":"Valued.topologicalDivisionRing","module":"Mathlib.Topology.Algebra.Valued.ValuedField","initialProofState":"K : Type u_1\ninstâœÂ² : DivisionRing K\nÎ“â‚€ : Type u_2\ninstâœÂ¹ : LinearOrderedCommGroupWithZero Î“â‚€\ninstâœ : Valued K Î“â‚€\nâŠ¢ TopologicalDivisionRing K","decl":"/-- The topology coming from a valuation on a division ring makes it a topological division ring\n    [BouAC, VI.5.1 middle of Proposition 1] -/\ninstance (priority := 100) Valued.topologicalDivisionRing [Valued K Î“â‚€] :\n    TopologicalDivisionRing K :=\n  { (by infer_instance : TopologicalRing K) with\n    continuousAt_invâ‚€ := by\n      intro x x_ne s s_in\n      cases' Valued.mem_nhds.mp s_in with Î³ hs; clear s_in\n      rw [mem_map, Valued.mem_nhds]\n      change âˆƒ Î³ : Î“â‚€Ë£, { y : K | (v (y - x) : Î“â‚€) < Î³ } âŠ† { x : K | xâ»Â¹ âˆˆ s }\n      have vx_ne := (Valuation.ne_zero_iff <| v).mpr x_ne\n      let Î³' := Units.mk0 _ vx_ne\n      use min (Î³ * (Î³' * Î³')) Î³'\n      intro y y_in\n      apply hs\n      simp only [mem_setOf_eq] at y_in\n      rw [Units.min_val, Units.val_mul, Units.val_mul] at y_in\n      exact Valuation.inversion_estimate _ x_ne y_in }\n\n"}
{"name":"ValuedRing.separated","module":"Mathlib.Topology.Algebra.Valued.ValuedField","initialProofState":"K : Type u_1\ninstâœÂ² : DivisionRing K\nÎ“â‚€ : Type u_2\ninstâœÂ¹ : LinearOrderedCommGroupWithZero Î“â‚€\ninstâœ : Valued K Î“â‚€\nâŠ¢ T0Space K","decl":"/-- A valued division ring is separated. -/\ninstance (priority := 100) ValuedRing.separated [Valued K Î“â‚€] : T0Space K := by\n  suffices T2Space K by infer_instance\n  apply TopologicalAddGroup.t2Space_of_zero_sep\n  intro x x_ne\n  refine âŸ¨{ k | v k < v x }, ?_, fun h => lt_irrefl _ hâŸ©\n  rw [Valued.mem_nhds]\n  have vx_ne := (Valuation.ne_zero_iff <| v).mpr x_ne\n  let Î³' := Units.mk0 _ vx_ne\n  exact âŸ¨Î³', fun y hy => by simpa using hyâŸ©\n\n"}
{"name":"Valued.continuous_valuation","module":"Mathlib.Topology.Algebra.Valued.ValuedField","initialProofState":"K : Type u_1\ninstâœÂ² : DivisionRing K\nÎ“â‚€ : Type u_2\ninstâœÂ¹ : LinearOrderedCommGroupWithZero Î“â‚€\ninstâœ : Valued K Î“â‚€\nâŠ¢ Continuous â‡‘Valued.v","decl":"theorem Valued.continuous_valuation [Valued K Î“â‚€] : Continuous (v : K â†’ Î“â‚€) := by\n  rw [continuous_iff_continuousAt]\n  intro x\n  rcases eq_or_ne x 0 with (rfl | h)\n  Â· rw [ContinuousAt, map_zero, WithZeroTopology.tendsto_zero]\n    intro Î³ hÎ³\n    rw [Filter.Eventually, Valued.mem_nhds_zero]\n    use Units.mk0 Î³ hÎ³; rfl\n  Â· have v_ne : (v x : Î“â‚€) â‰  0 := (Valuation.ne_zero_iff _).mpr h\n    rw [ContinuousAt, WithZeroTopology.tendsto_of_ne_zero v_ne]\n    apply Valued.loc_const v_ne\n\n"}
{"name":"Valued.completable","module":"Mathlib.Topology.Algebra.Valued.ValuedField","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\nÎ“â‚€ : Type u_2\ninstâœ : LinearOrderedCommGroupWithZero Î“â‚€\nhv : Valued K Î“â‚€\nâŠ¢ CompletableTopField K","decl":"/-- A valued field is completable. -/\ninstance (priority := 100) completable : CompletableTopField K :=\n  { ValuedRing.separated with\n    nice := by\n      rintro F hF h0\n      have : âˆƒ Î³â‚€ : Î“â‚€Ë£, âˆƒ M âˆˆ F, âˆ€ x âˆˆ M, (Î³â‚€ : Î“â‚€) â‰¤ v x := by\n        rcases Filter.inf_eq_bot_iff.mp h0 with âŸ¨U, U_in, M, M_in, HâŸ©\n        rcases Valued.mem_nhds_zero.mp U_in with âŸ¨Î³â‚€, hUâŸ©\n        exists Î³â‚€, M, M_in\n        intro x xM\n        apply le_of_not_lt _\n        intro hyp\n        have : x âˆˆ U âˆ© M := âŸ¨hU hyp, xMâŸ©\n        rwa [H] at this\n      rcases this with âŸ¨Î³â‚€, Mâ‚€, Mâ‚€_in, Hâ‚€âŸ©\n      rw [Valued.cauchy_iff] at hF âŠ¢\n      refine âŸ¨hF.1.map _, ?_âŸ©\n      replace hF := hF.2\n      intro Î³\n      rcases hF (min (Î³ * Î³â‚€ * Î³â‚€) Î³â‚€) with âŸ¨Mâ‚, Mâ‚_in, Hâ‚âŸ©\n      clear hF\n      use (fun x : K => xâ»Â¹) '' (Mâ‚€ âˆ© Mâ‚)\n      constructor\n      Â· rw [mem_map]\n        apply mem_of_superset (Filter.inter_mem Mâ‚€_in Mâ‚_in)\n        exact subset_preimage_image _ _\n      Â· rintro _ âŸ¨x, âŸ¨x_inâ‚€, x_inâ‚âŸ©, rflâŸ© _ âŸ¨y, âŸ¨_, y_inâ‚âŸ©, rflâŸ©\n        simp only [mem_setOf_eq]\n        specialize Hâ‚ x x_inâ‚ y y_inâ‚\n        replace x_inâ‚€ := Hâ‚€ x x_inâ‚€\n        clear Hâ‚€\n        apply Valuation.inversion_estimate\n        Â· have : (v x : Î“â‚€) â‰  0 := by\n            intro h\n            rw [h] at x_inâ‚€\n            simp at x_inâ‚€\n          exact (Valuation.ne_zero_iff _).mp this\n        Â· refine lt_of_lt_of_le Hâ‚ ?_\n          rw [Units.min_val]\n          apply min_le_min _ x_inâ‚€\n          rw [mul_assoc]\n          have : ((Î³â‚€ * Î³â‚€ : Î“â‚€Ë£) : Î“â‚€) â‰¤ v x * v x :=\n            calc\n              â†‘Î³â‚€ * â†‘Î³â‚€ â‰¤ â†‘Î³â‚€ * v x := mul_le_mul_left' x_inâ‚€ â†‘Î³â‚€\n              _ â‰¤ _ := mul_le_mul_right' x_inâ‚€ (v x)\n          rw [Units.val_mul]\n          exact mul_le_mul_left' this Î³ }\n\n"}
{"name":"Valued.continuous_extension","module":"Mathlib.Topology.Algebra.Valued.ValuedField","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\nÎ“â‚€ : Type u_2\ninstâœ : LinearOrderedCommGroupWithZero Î“â‚€\nhv : Valued K Î“â‚€\nâŠ¢ Continuous Valued.extension","decl":"theorem continuous_extension : Continuous (Valued.extension : hat K â†’ Î“â‚€) := by\n  refine Completion.isDenseInducing_coe.continuous_extend ?_\n  intro xâ‚€\n  rcases eq_or_ne xâ‚€ 0 with (rfl | h)\n  Â· refine âŸ¨0, ?_âŸ©\n    erw [â† Completion.isDenseInducing_coe.isInducing.nhds_eq_comap]\n    exact Valued.continuous_valuation.tendsto' 0 0 (map_zero v)\n  Â· have preimage_one : v â»Â¹' {(1 : Î“â‚€)} âˆˆ ğ“ (1 : K) := by\n      have : (v (1 : K) : Î“â‚€) â‰  0 := by\n        rw [Valuation.map_one]\n        exact zero_ne_one.symm\n      convert Valued.loc_const this\n      ext x\n      rw [Valuation.map_one, mem_preimage, mem_singleton_iff, mem_setOf_eq]\n    obtain âŸ¨V, V_in, hVâŸ© : âˆƒ V âˆˆ ğ“ (1 : hat K), âˆ€ x : K, (x : hat K) âˆˆ V â†’ (v x : Î“â‚€) = 1 := by\n      rwa [Completion.isDenseInducing_coe.nhds_eq_comap, mem_comap] at preimage_one\n    have : âˆƒ V' âˆˆ ğ“ (1 : hat K), (0 : hat K) âˆ‰ V' âˆ§ âˆ€ (x) (_ : x âˆˆ V') (y) (_ : y âˆˆ V'),\n      x * yâ»Â¹ âˆˆ V := by\n      have : Tendsto (fun p : hat K Ã— hat K => p.1 * p.2â»Â¹) ((ğ“ 1) Ã—Ë¢ (ğ“ 1)) (ğ“ 1) := by\n        rw [â† nhds_prod_eq]\n        conv =>\n          congr\n          rfl\n          rfl\n          rw [â† one_mul (1 : hat K)]\n        refine\n          Tendsto.mul continuous_fst.continuousAt (Tendsto.comp ?_ continuous_snd.continuousAt)\n        -- Porting note: Added `ContinuousAt.tendsto`\n        convert (continuousAt_invâ‚€ (zero_ne_one.symm : 1 â‰  (0 : hat K))).tendsto\n        exact inv_one.symm\n      rcases tendsto_prod_self_iff.mp this V V_in with âŸ¨U, U_in, hUâŸ©\n      let hatKstar := ({0}á¶œ : Set <| hat K)\n      have : hatKstar âˆˆ ğ“ (1 : hat K) := compl_singleton_mem_nhds zero_ne_one.symm\n      use U âˆ© hatKstar, Filter.inter_mem U_in this\n      constructor\n      Â· rintro âŸ¨_, h'âŸ©\n        rw [mem_compl_singleton_iff] at h'\n        exact h' rfl\n      Â· rintro x âŸ¨hx, _âŸ© y âŸ¨hy, _âŸ©\n        apply hU <;> assumption\n    rcases this with âŸ¨V', V'_in, zeroV', hV'âŸ©\n    have nhds_right : (fun x => x * xâ‚€) '' V' âˆˆ ğ“ xâ‚€ := by\n      have l : Function.LeftInverse (fun x : hat K => x * xâ‚€â»Â¹) fun x : hat K => x * xâ‚€ := by\n        intro x\n        simp only [mul_assoc, mul_inv_cancelâ‚€ h, mul_one]\n      have r : Function.RightInverse (fun x : hat K => x * xâ‚€â»Â¹) fun x : hat K => x * xâ‚€ := by\n        intro x\n        simp only [mul_assoc, inv_mul_cancelâ‚€ h, mul_one]\n      have c : Continuous fun x : hat K => x * xâ‚€â»Â¹ := continuous_id.mul continuous_const\n      rw [image_eq_preimage_of_inverse l r]\n      rw [â† mul_inv_cancelâ‚€ h] at V'_in\n      exact c.continuousAt V'_in\n    have : âˆƒ zâ‚€ : K, âˆƒ yâ‚€ âˆˆ V', â†‘zâ‚€ = yâ‚€ * xâ‚€ âˆ§ zâ‚€ â‰  0 := by\n      rcases Completion.denseRange_coe.mem_nhds nhds_right with âŸ¨zâ‚€, yâ‚€, yâ‚€_in, H : yâ‚€ * xâ‚€ = zâ‚€âŸ©\n      refine âŸ¨zâ‚€, yâ‚€, yâ‚€_in, âŸ¨H.symm, ?_âŸ©âŸ©\n      rintro rfl\n      exact mul_ne_zero (ne_of_mem_of_not_mem yâ‚€_in zeroV') h H\n    rcases this with âŸ¨zâ‚€, yâ‚€, yâ‚€_in, hzâ‚€, zâ‚€_neâŸ©\n    have vzâ‚€_ne : (v zâ‚€ : Î“â‚€) â‰  0 := by rwa [Valuation.ne_zero_iff]\n    refine âŸ¨v zâ‚€, ?_âŸ©\n    rw [WithZeroTopology.tendsto_of_ne_zero vzâ‚€_ne, eventually_comap]\n    filter_upwards [nhds_right] with x x_in a ha\n    rcases x_in with âŸ¨y, y_in, rflâŸ©\n    have : (v (a * zâ‚€â»Â¹) : Î“â‚€) = 1 := by\n      apply hV\n      have : (zâ‚€â»Â¹ : K) = (zâ‚€ : hat K)â»Â¹ := map_invâ‚€ (Completion.coeRingHom : K â†’+* hat K) zâ‚€\n      rw [Completion.coe_mul, this, ha, hzâ‚€, mul_inv, mul_comm yâ‚€â»Â¹, â† mul_assoc, mul_assoc y,\n        mul_inv_cancelâ‚€ h, mul_one]\n      solve_by_elim\n    calc\n      v a = v (a * zâ‚€â»Â¹ * zâ‚€) := by rw [mul_assoc, inv_mul_cancelâ‚€ zâ‚€_ne, mul_one]\n      _ = v (a * zâ‚€â»Â¹) * v zâ‚€ := Valuation.map_mul _ _ _\n      _ = v zâ‚€ := by rw [this, one_mul]\n\n"}
{"name":"Valued.extension_extends","module":"Mathlib.Topology.Algebra.Valued.ValuedField","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\nÎ“â‚€ : Type u_2\ninstâœ : LinearOrderedCommGroupWithZero Î“â‚€\nhv : Valued K Î“â‚€\nx : K\nâŠ¢ Eq (Valued.extension â†‘x) (Valued.v x)","decl":"@[simp, norm_cast]\ntheorem extension_extends (x : K) : extension (x : hat K) = v x := by\n  refine Completion.isDenseInducing_coe.extend_eq_of_tendsto ?_\n  rw [â† Completion.isDenseInducing_coe.nhds_eq_comap]\n  exact Valued.continuous_valuation.continuousAt\n\n"}
{"name":"Valued.closure_coe_completion_v_lt","module":"Mathlib.Topology.Algebra.Valued.ValuedField","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\nÎ“â‚€ : Type u_2\ninstâœ : LinearOrderedCommGroupWithZero Î“â‚€\nhv : Valued K Î“â‚€\nÎ³ : Units Î“â‚€\nâŠ¢ Eq (closure (Set.image UniformSpace.Completion.coe' (setOf fun x => LT.lt (Valued.v x) â†‘Î³))) (setOf fun x => LT.lt (Valued.extensionValuation x) â†‘Î³)","decl":"theorem closure_coe_completion_v_lt {Î³ : Î“â‚€Ë£} :\n    closure ((â†‘) '' { x : K | v x < (Î³ : Î“â‚€) }) =\n    { x : hat K | extensionValuation x < (Î³ : Î“â‚€) } := by\n  ext x\n  let Î³â‚€ := extensionValuation x\n  suffices Î³â‚€ â‰  0 â†’ (x âˆˆ closure ((â†‘) '' { x : K | v x < (Î³ : Î“â‚€) }) â†” Î³â‚€ < (Î³ : Î“â‚€)) by\n    rcases eq_or_ne Î³â‚€ 0 with h | h\n    Â· simp only [h, (Valuation.zero_iff _).mp h, mem_setOf_eq, Valuation.map_zero, Units.zero_lt,\n        iff_true]\n      apply subset_closure\n      exact âŸ¨0, by simp only [mem_setOf_eq, Valuation.map_zero, Units.zero_lt, true_and]; rflâŸ©\n    Â· exact this h\n  intro h\n  have hÎ³â‚€ : extension â»Â¹' {Î³â‚€} âˆˆ ğ“ x :=\n    continuous_extension.continuousAt.preimage_mem_nhds\n      (WithZeroTopology.singleton_mem_nhds_of_ne_zero h)\n  rw [mem_closure_iff_nhds']\n  refine âŸ¨fun hx => ?_, fun hx s hs => ?_âŸ©\n  Â· obtain âŸ¨âŸ¨-, y, hyâ‚ : v y < (Î³ : Î“â‚€), rflâŸ©, hyâ‚‚âŸ© := hx _ hÎ³â‚€\n    replace hyâ‚‚ : v y = Î³â‚€ := by simpa using hyâ‚‚\n    rwa [â† hyâ‚‚]\n  Â· obtain âŸ¨y, hyâ‚, hyâ‚‚âŸ© := Completion.denseRange_coe.mem_nhds (inter_mem hÎ³â‚€ hs)\n    replace hyâ‚ : v y = Î³â‚€ := by simpa using hyâ‚\n    rw [â† hyâ‚] at hx\n    exact âŸ¨âŸ¨y, âŸ¨y, hx, rflâŸ©âŸ©, hyâ‚‚âŸ©\n\n"}
{"name":"Valued.valuedCompletion_apply","module":"Mathlib.Topology.Algebra.Valued.ValuedField","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\nÎ“â‚€ : Type u_2\ninstâœ : LinearOrderedCommGroupWithZero Î“â‚€\nhv : Valued K Î“â‚€\nx : K\nâŠ¢ Eq (Valued.v â†‘x) (Valued.v x)","decl":"@[simp]\ntheorem valuedCompletion_apply (x : K) : Valued.v (x : hat K) = v x :=\n  extension_extends x\n\n"}
