{"name":"Valuation.inversion_estimate","module":"Mathlib.Topology.Algebra.Valued.ValuedField","initialProofState":"K : Type u_1\ninst‚úù¬π : DivisionRing K\nŒì‚ÇÄ : Type u_2\ninst‚úù : LinearOrderedCommGroupWithZero Œì‚ÇÄ\nv : Valuation K Œì‚ÇÄ\nx y : K\nŒ≥ : Units Œì‚ÇÄ\ny_ne : Ne y 0\nh : LT.lt (v (HSub.hSub x y)) (Min.min (HMul.hMul (‚ÜëŒ≥) (HMul.hMul (v y) (v y))) (v y))\n‚ä¢ LT.lt (v (HSub.hSub (Inv.inv x) (Inv.inv y))) ‚ÜëŒ≥","decl":"theorem Valuation.inversion_estimate {x y : K} {Œ≥ : Œì‚ÇÄÀ£} (y_ne : y ‚â† 0)\n    (h : v (x - y) < min (Œ≥ * (v y * v y)) (v y)) : v (x‚Åª¬π - y‚Åª¬π) < Œ≥ := by\n  have hyp1 : v (x - y) < Œ≥ * (v y * v y) := lt_of_lt_of_le h (min_le_left _ _)\n  have hyp1' : v (x - y) * (v y * v y)‚Åª¬π < Œ≥ := mul_inv_lt_of_lt_mul‚ÇÄ hyp1\n  have hyp2 : v (x - y) < v y := lt_of_lt_of_le h (min_le_right _ _)\n  have key : v x = v y := Valuation.map_eq_of_sub_lt v hyp2\n  have x_ne : x ‚â† 0 := by\n    intro h\n    apply y_ne\n    rw [h, v.map_zero] at key\n    exact v.zero_iff.1 key.symm\n  have decomp : x‚Åª¬π - y‚Åª¬π = x‚Åª¬π * (y - x) * y‚Åª¬π := by\n    rw [mul_sub_left_distrib, sub_mul, mul_assoc, show y * y‚Åª¬π = 1 from mul_inv_cancel‚ÇÄ y_ne,\n      show x‚Åª¬π * x = 1 from inv_mul_cancel‚ÇÄ x_ne, mul_one, one_mul]\n  calc\n    v (x‚Åª¬π - y‚Åª¬π) = v (x‚Åª¬π * (y - x) * y‚Åª¬π) := by rw [decomp]\n    _ = v x‚Åª¬π * (v <| y - x) * v y‚Åª¬π := by repeat' rw [Valuation.map_mul]\n    _ = (v x)‚Åª¬π * (v <| y - x) * (v y)‚Åª¬π := by rw [map_inv‚ÇÄ, map_inv‚ÇÄ]\n    _ = (v <| y - x) * (v y * v y)‚Åª¬π := by rw [mul_assoc, mul_comm, key, mul_assoc, mul_inv_rev]\n    _ = (v <| y - x) * (v y * v y)‚Åª¬π := rfl\n    _ = (v <| x - y) * (v y * v y)‚Åª¬π := by rw [Valuation.map_sub_swap]\n    _ < Œ≥ := hyp1'\n\n"}
{"name":"Valued.topologicalDivisionRing","module":"Mathlib.Topology.Algebra.Valued.ValuedField","initialProofState":"K : Type u_1\ninst‚úù¬≤ : DivisionRing K\nŒì‚ÇÄ : Type u_2\ninst‚úù¬π : LinearOrderedCommGroupWithZero Œì‚ÇÄ\ninst‚úù : Valued K Œì‚ÇÄ\n‚ä¢ TopologicalDivisionRing K","decl":"/-- The topology coming from a valuation on a division ring makes it a topological division ring\n    [BouAC, VI.5.1 middle of Proposition 1] -/\ninstance (priority := 100) Valued.topologicalDivisionRing [Valued K Œì‚ÇÄ] :\n    TopologicalDivisionRing K :=\n  { (by infer_instance : TopologicalRing K) with\n    continuousAt_inv‚ÇÄ := by\n      intro x x_ne s s_in\n      cases' Valued.mem_nhds.mp s_in with Œ≥ hs; clear s_in\n      rw [mem_map, Valued.mem_nhds]\n      change ‚àÉ Œ≥ : Œì‚ÇÄÀ£, { y : K | (v (y - x) : Œì‚ÇÄ) < Œ≥ } ‚äÜ { x : K | x‚Åª¬π ‚àà s }\n      have vx_ne := (Valuation.ne_zero_iff <| v).mpr x_ne\n      let Œ≥' := Units.mk0 _ vx_ne\n      use min (Œ≥ * (Œ≥' * Œ≥')) Œ≥'\n      intro y y_in\n      apply hs\n      simp only [mem_setOf_eq] at y_in\n      rw [Units.min_val, Units.val_mul, Units.val_mul] at y_in\n      exact Valuation.inversion_estimate _ x_ne y_in }\n\n"}
{"name":"ValuedRing.separated","module":"Mathlib.Topology.Algebra.Valued.ValuedField","initialProofState":"K : Type u_1\ninst‚úù¬≤ : DivisionRing K\nŒì‚ÇÄ : Type u_2\ninst‚úù¬π : LinearOrderedCommGroupWithZero Œì‚ÇÄ\ninst‚úù : Valued K Œì‚ÇÄ\n‚ä¢ T0Space K","decl":"/-- A valued division ring is separated. -/\ninstance (priority := 100) ValuedRing.separated [Valued K Œì‚ÇÄ] : T0Space K := by\n  suffices T2Space K by infer_instance\n  apply TopologicalAddGroup.t2Space_of_zero_sep\n  intro x x_ne\n  refine ‚ü®{ k | v k < v x }, ?_, fun h => lt_irrefl _ h‚ü©\n  rw [Valued.mem_nhds]\n  have vx_ne := (Valuation.ne_zero_iff <| v).mpr x_ne\n  let Œ≥' := Units.mk0 _ vx_ne\n  exact ‚ü®Œ≥', fun y hy => by simpa using hy‚ü©\n\n"}
{"name":"Valued.continuous_valuation","module":"Mathlib.Topology.Algebra.Valued.ValuedField","initialProofState":"K : Type u_1\ninst‚úù¬≤ : DivisionRing K\nŒì‚ÇÄ : Type u_2\ninst‚úù¬π : LinearOrderedCommGroupWithZero Œì‚ÇÄ\ninst‚úù : Valued K Œì‚ÇÄ\n‚ä¢ Continuous ‚áëValued.v","decl":"theorem Valued.continuous_valuation [Valued K Œì‚ÇÄ] : Continuous (v : K ‚Üí Œì‚ÇÄ) := by\n  rw [continuous_iff_continuousAt]\n  intro x\n  rcases eq_or_ne x 0 with (rfl | h)\n  ¬∑ rw [ContinuousAt, map_zero, WithZeroTopology.tendsto_zero]\n    intro Œ≥ hŒ≥\n    rw [Filter.Eventually, Valued.mem_nhds_zero]\n    use Units.mk0 Œ≥ hŒ≥; rfl\n  ¬∑ have v_ne : (v x : Œì‚ÇÄ) ‚â† 0 := (Valuation.ne_zero_iff _).mpr h\n    rw [ContinuousAt, WithZeroTopology.tendsto_of_ne_zero v_ne]\n    apply Valued.loc_const v_ne\n\n"}
{"name":"Valued.completable","module":"Mathlib.Topology.Algebra.Valued.ValuedField","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\nŒì‚ÇÄ : Type u_2\ninst‚úù : LinearOrderedCommGroupWithZero Œì‚ÇÄ\nhv : Valued K Œì‚ÇÄ\n‚ä¢ CompletableTopField K","decl":"/-- A valued field is completable. -/\ninstance (priority := 100) completable : CompletableTopField K :=\n  { ValuedRing.separated with\n    nice := by\n      rintro F hF h0\n      have : ‚àÉ Œ≥‚ÇÄ : Œì‚ÇÄÀ£, ‚àÉ M ‚àà F, ‚àÄ x ‚àà M, (Œ≥‚ÇÄ : Œì‚ÇÄ) ‚â§ v x := by\n        rcases Filter.inf_eq_bot_iff.mp h0 with ‚ü®U, U_in, M, M_in, H‚ü©\n        rcases Valued.mem_nhds_zero.mp U_in with ‚ü®Œ≥‚ÇÄ, hU‚ü©\n        exists Œ≥‚ÇÄ, M, M_in\n        intro x xM\n        apply le_of_not_lt _\n        intro hyp\n        have : x ‚àà U ‚à© M := ‚ü®hU hyp, xM‚ü©\n        rwa [H] at this\n      rcases this with ‚ü®Œ≥‚ÇÄ, M‚ÇÄ, M‚ÇÄ_in, H‚ÇÄ‚ü©\n      rw [Valued.cauchy_iff] at hF ‚ä¢\n      refine ‚ü®hF.1.map _, ?_‚ü©\n      replace hF := hF.2\n      intro Œ≥\n      rcases hF (min (Œ≥ * Œ≥‚ÇÄ * Œ≥‚ÇÄ) Œ≥‚ÇÄ) with ‚ü®M‚ÇÅ, M‚ÇÅ_in, H‚ÇÅ‚ü©\n      clear hF\n      use (fun x : K => x‚Åª¬π) '' (M‚ÇÄ ‚à© M‚ÇÅ)\n      constructor\n      ¬∑ rw [mem_map]\n        apply mem_of_superset (Filter.inter_mem M‚ÇÄ_in M‚ÇÅ_in)\n        exact subset_preimage_image _ _\n      ¬∑ rintro _ ‚ü®x, ‚ü®x_in‚ÇÄ, x_in‚ÇÅ‚ü©, rfl‚ü© _ ‚ü®y, ‚ü®_, y_in‚ÇÅ‚ü©, rfl‚ü©\n        simp only [mem_setOf_eq]\n        specialize H‚ÇÅ x x_in‚ÇÅ y y_in‚ÇÅ\n        replace x_in‚ÇÄ := H‚ÇÄ x x_in‚ÇÄ\n        clear H‚ÇÄ\n        apply Valuation.inversion_estimate\n        ¬∑ have : (v x : Œì‚ÇÄ) ‚â† 0 := by\n            intro h\n            rw [h] at x_in‚ÇÄ\n            simp at x_in‚ÇÄ\n          exact (Valuation.ne_zero_iff _).mp this\n        ¬∑ refine lt_of_lt_of_le H‚ÇÅ ?_\n          rw [Units.min_val]\n          apply min_le_min _ x_in‚ÇÄ\n          rw [mul_assoc]\n          have : ((Œ≥‚ÇÄ * Œ≥‚ÇÄ : Œì‚ÇÄÀ£) : Œì‚ÇÄ) ‚â§ v x * v x :=\n            calc\n              ‚ÜëŒ≥‚ÇÄ * ‚ÜëŒ≥‚ÇÄ ‚â§ ‚ÜëŒ≥‚ÇÄ * v x := mul_le_mul_left' x_in‚ÇÄ ‚ÜëŒ≥‚ÇÄ\n              _ ‚â§ _ := mul_le_mul_right' x_in‚ÇÄ (v x)\n          rw [Units.val_mul]\n          exact mul_le_mul_left' this Œ≥ }\n\n"}
{"name":"Valued.continuous_extension","module":"Mathlib.Topology.Algebra.Valued.ValuedField","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\nŒì‚ÇÄ : Type u_2\ninst‚úù : LinearOrderedCommGroupWithZero Œì‚ÇÄ\nhv : Valued K Œì‚ÇÄ\n‚ä¢ Continuous Valued.extension","decl":"theorem continuous_extension : Continuous (Valued.extension : hat K ‚Üí Œì‚ÇÄ) := by\n  refine Completion.isDenseInducing_coe.continuous_extend ?_\n  intro x‚ÇÄ\n  rcases eq_or_ne x‚ÇÄ 0 with (rfl | h)\n  ¬∑ refine ‚ü®0, ?_‚ü©\n    erw [‚Üê Completion.isDenseInducing_coe.isInducing.nhds_eq_comap]\n    exact Valued.continuous_valuation.tendsto' 0 0 (map_zero v)\n  ¬∑ have preimage_one : v ‚Åª¬π' {(1 : Œì‚ÇÄ)} ‚àà ùìù (1 : K) := by\n      have : (v (1 : K) : Œì‚ÇÄ) ‚â† 0 := by\n        rw [Valuation.map_one]\n        exact zero_ne_one.symm\n      convert Valued.loc_const this\n      ext x\n      rw [Valuation.map_one, mem_preimage, mem_singleton_iff, mem_setOf_eq]\n    obtain ‚ü®V, V_in, hV‚ü© : ‚àÉ V ‚àà ùìù (1 : hat K), ‚àÄ x : K, (x : hat K) ‚àà V ‚Üí (v x : Œì‚ÇÄ) = 1 := by\n      rwa [Completion.isDenseInducing_coe.nhds_eq_comap, mem_comap] at preimage_one\n    have : ‚àÉ V' ‚àà ùìù (1 : hat K), (0 : hat K) ‚àâ V' ‚àß ‚àÄ (x) (_ : x ‚àà V') (y) (_ : y ‚àà V'),\n      x * y‚Åª¬π ‚àà V := by\n      have : Tendsto (fun p : hat K √ó hat K => p.1 * p.2‚Åª¬π) ((ùìù 1) √óÀ¢ (ùìù 1)) (ùìù 1) := by\n        rw [‚Üê nhds_prod_eq]\n        conv =>\n          congr\n          rfl\n          rfl\n          rw [‚Üê one_mul (1 : hat K)]\n        refine\n          Tendsto.mul continuous_fst.continuousAt (Tendsto.comp ?_ continuous_snd.continuousAt)\n        -- Porting note: Added `ContinuousAt.tendsto`\n        convert (continuousAt_inv‚ÇÄ (zero_ne_one.symm : 1 ‚â† (0 : hat K))).tendsto\n        exact inv_one.symm\n      rcases tendsto_prod_self_iff.mp this V V_in with ‚ü®U, U_in, hU‚ü©\n      let hatKstar := ({0}·∂ú : Set <| hat K)\n      have : hatKstar ‚àà ùìù (1 : hat K) := compl_singleton_mem_nhds zero_ne_one.symm\n      use U ‚à© hatKstar, Filter.inter_mem U_in this\n      constructor\n      ¬∑ rintro ‚ü®_, h'‚ü©\n        rw [mem_compl_singleton_iff] at h'\n        exact h' rfl\n      ¬∑ rintro x ‚ü®hx, _‚ü© y ‚ü®hy, _‚ü©\n        apply hU <;> assumption\n    rcases this with ‚ü®V', V'_in, zeroV', hV'‚ü©\n    have nhds_right : (fun x => x * x‚ÇÄ) '' V' ‚àà ùìù x‚ÇÄ := by\n      have l : Function.LeftInverse (fun x : hat K => x * x‚ÇÄ‚Åª¬π) fun x : hat K => x * x‚ÇÄ := by\n        intro x\n        simp only [mul_assoc, mul_inv_cancel‚ÇÄ h, mul_one]\n      have r : Function.RightInverse (fun x : hat K => x * x‚ÇÄ‚Åª¬π) fun x : hat K => x * x‚ÇÄ := by\n        intro x\n        simp only [mul_assoc, inv_mul_cancel‚ÇÄ h, mul_one]\n      have c : Continuous fun x : hat K => x * x‚ÇÄ‚Åª¬π := continuous_id.mul continuous_const\n      rw [image_eq_preimage_of_inverse l r]\n      rw [‚Üê mul_inv_cancel‚ÇÄ h] at V'_in\n      exact c.continuousAt V'_in\n    have : ‚àÉ z‚ÇÄ : K, ‚àÉ y‚ÇÄ ‚àà V', ‚Üëz‚ÇÄ = y‚ÇÄ * x‚ÇÄ ‚àß z‚ÇÄ ‚â† 0 := by\n      rcases Completion.denseRange_coe.mem_nhds nhds_right with ‚ü®z‚ÇÄ, y‚ÇÄ, y‚ÇÄ_in, H : y‚ÇÄ * x‚ÇÄ = z‚ÇÄ‚ü©\n      refine ‚ü®z‚ÇÄ, y‚ÇÄ, y‚ÇÄ_in, ‚ü®H.symm, ?_‚ü©‚ü©\n      rintro rfl\n      exact mul_ne_zero (ne_of_mem_of_not_mem y‚ÇÄ_in zeroV') h H\n    rcases this with ‚ü®z‚ÇÄ, y‚ÇÄ, y‚ÇÄ_in, hz‚ÇÄ, z‚ÇÄ_ne‚ü©\n    have vz‚ÇÄ_ne : (v z‚ÇÄ : Œì‚ÇÄ) ‚â† 0 := by rwa [Valuation.ne_zero_iff]\n    refine ‚ü®v z‚ÇÄ, ?_‚ü©\n    rw [WithZeroTopology.tendsto_of_ne_zero vz‚ÇÄ_ne, eventually_comap]\n    filter_upwards [nhds_right] with x x_in a ha\n    rcases x_in with ‚ü®y, y_in, rfl‚ü©\n    have : (v (a * z‚ÇÄ‚Åª¬π) : Œì‚ÇÄ) = 1 := by\n      apply hV\n      have : (z‚ÇÄ‚Åª¬π : K) = (z‚ÇÄ : hat K)‚Åª¬π := map_inv‚ÇÄ (Completion.coeRingHom : K ‚Üí+* hat K) z‚ÇÄ\n      rw [Completion.coe_mul, this, ha, hz‚ÇÄ, mul_inv, mul_comm y‚ÇÄ‚Åª¬π, ‚Üê mul_assoc, mul_assoc y,\n        mul_inv_cancel‚ÇÄ h, mul_one]\n      solve_by_elim\n    calc\n      v a = v (a * z‚ÇÄ‚Åª¬π * z‚ÇÄ) := by rw [mul_assoc, inv_mul_cancel‚ÇÄ z‚ÇÄ_ne, mul_one]\n      _ = v (a * z‚ÇÄ‚Åª¬π) * v z‚ÇÄ := Valuation.map_mul _ _ _\n      _ = v z‚ÇÄ := by rw [this, one_mul]\n\n"}
{"name":"Valued.extension_extends","module":"Mathlib.Topology.Algebra.Valued.ValuedField","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\nŒì‚ÇÄ : Type u_2\ninst‚úù : LinearOrderedCommGroupWithZero Œì‚ÇÄ\nhv : Valued K Œì‚ÇÄ\nx : K\n‚ä¢ Eq (Valued.extension ‚Üëx) (Valued.v x)","decl":"@[simp, norm_cast]\ntheorem extension_extends (x : K) : extension (x : hat K) = v x := by\n  refine Completion.isDenseInducing_coe.extend_eq_of_tendsto ?_\n  rw [‚Üê Completion.isDenseInducing_coe.nhds_eq_comap]\n  exact Valued.continuous_valuation.continuousAt\n\n"}
{"name":"Valued.closure_coe_completion_v_lt","module":"Mathlib.Topology.Algebra.Valued.ValuedField","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\nŒì‚ÇÄ : Type u_2\ninst‚úù : LinearOrderedCommGroupWithZero Œì‚ÇÄ\nhv : Valued K Œì‚ÇÄ\nŒ≥ : Units Œì‚ÇÄ\n‚ä¢ Eq (closure (Set.image UniformSpace.Completion.coe' (setOf fun x => LT.lt (Valued.v x) ‚ÜëŒ≥))) (setOf fun x => LT.lt (Valued.extensionValuation x) ‚ÜëŒ≥)","decl":"theorem closure_coe_completion_v_lt {Œ≥ : Œì‚ÇÄÀ£} :\n    closure ((‚Üë) '' { x : K | v x < (Œ≥ : Œì‚ÇÄ) }) =\n    { x : hat K | extensionValuation x < (Œ≥ : Œì‚ÇÄ) } := by\n  ext x\n  let Œ≥‚ÇÄ := extensionValuation x\n  suffices Œ≥‚ÇÄ ‚â† 0 ‚Üí (x ‚àà closure ((‚Üë) '' { x : K | v x < (Œ≥ : Œì‚ÇÄ) }) ‚Üî Œ≥‚ÇÄ < (Œ≥ : Œì‚ÇÄ)) by\n    rcases eq_or_ne Œ≥‚ÇÄ 0 with h | h\n    ¬∑ simp only [h, (Valuation.zero_iff _).mp h, mem_setOf_eq, Valuation.map_zero, Units.zero_lt,\n        iff_true]\n      apply subset_closure\n      exact ‚ü®0, by simp only [mem_setOf_eq, Valuation.map_zero, Units.zero_lt, true_and]; rfl‚ü©\n    ¬∑ exact this h\n  intro h\n  have hŒ≥‚ÇÄ : extension ‚Åª¬π' {Œ≥‚ÇÄ} ‚àà ùìù x :=\n    continuous_extension.continuousAt.preimage_mem_nhds\n      (WithZeroTopology.singleton_mem_nhds_of_ne_zero h)\n  rw [mem_closure_iff_nhds']\n  refine ‚ü®fun hx => ?_, fun hx s hs => ?_‚ü©\n  ¬∑ obtain ‚ü®‚ü®-, y, hy‚ÇÅ : v y < (Œ≥ : Œì‚ÇÄ), rfl‚ü©, hy‚ÇÇ‚ü© := hx _ hŒ≥‚ÇÄ\n    replace hy‚ÇÇ : v y = Œ≥‚ÇÄ := by simpa using hy‚ÇÇ\n    rwa [‚Üê hy‚ÇÇ]\n  ¬∑ obtain ‚ü®y, hy‚ÇÅ, hy‚ÇÇ‚ü© := Completion.denseRange_coe.mem_nhds (inter_mem hŒ≥‚ÇÄ hs)\n    replace hy‚ÇÅ : v y = Œ≥‚ÇÄ := by simpa using hy‚ÇÅ\n    rw [‚Üê hy‚ÇÅ] at hx\n    exact ‚ü®‚ü®y, ‚ü®y, hx, rfl‚ü©‚ü©, hy‚ÇÇ‚ü©\n\n"}
{"name":"Valued.valuedCompletion_apply","module":"Mathlib.Topology.Algebra.Valued.ValuedField","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\nŒì‚ÇÄ : Type u_2\ninst‚úù : LinearOrderedCommGroupWithZero Œì‚ÇÄ\nhv : Valued K Œì‚ÇÄ\nx : K\n‚ä¢ Eq (Valued.v ‚Üëx) (Valued.v x)","decl":"@[simp]\ntheorem valuedCompletion_apply (x : K) : Valued.v (x : hat K) = v x :=\n  extension_extends x\n\n"}
