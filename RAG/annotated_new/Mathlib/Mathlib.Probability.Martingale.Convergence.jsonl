{"name":"MeasureTheory.not_frequently_of_upcrossings_lt_top","module":"Mathlib.Probability.Martingale.Convergence","initialProofState":"Ω : Type u_1\na b : Real\nf : Nat → Ω → Real\nω : Ω\nhab : LT.lt a b\nhω : Ne (MeasureTheory.upcrossings a b f ω) Top.top\n⊢ Not (And (Filter.Frequently (fun n => LT.lt (f n ω) a) Filter.atTop) (Filter.Frequently (fun n => LT.lt b (f n ω)) Filter.atTop))","decl":"/-- If a stochastic process has bounded upcrossing from below `a` to above `b`,\nthen it does not frequently visit both below `a` and above `b`. -/\ntheorem not_frequently_of_upcrossings_lt_top (hab : a < b) (hω : upcrossings a b f ω ≠ ∞) :\n    ¬((∃ᶠ n in atTop, f n ω < a) ∧ ∃ᶠ n in atTop, b < f n ω) := by\n  rw [← lt_top_iff_ne_top, upcrossings_lt_top_iff] at hω\n  replace hω : ∃ k, ∀ N, upcrossingsBefore a b f N ω < k := by\n    obtain ⟨k, hk⟩ := hω\n    exact ⟨k + 1, fun N => lt_of_le_of_lt (hk N) k.lt_succ_self⟩\n  rintro ⟨h₁, h₂⟩\n  rw [frequently_atTop] at h₁ h₂\n  refine Classical.not_not.2 hω ?_\n  push_neg\n  intro k\n  induction' k with k ih\n  · simp only [zero_le, exists_const]\n  · obtain ⟨N, hN⟩ := ih\n    obtain ⟨N₁, hN₁, hN₁'⟩ := h₁ N\n    obtain ⟨N₂, hN₂, hN₂'⟩ := h₂ N₁\n    exact ⟨N₂ + 1, Nat.succ_le_of_lt <|\n      lt_of_le_of_lt hN (upcrossingsBefore_lt_of_exists_upcrossing hab hN₁ hN₁' hN₂ hN₂')⟩\n\n"}
{"name":"MeasureTheory.upcrossings_eq_top_of_frequently_lt","module":"Mathlib.Probability.Martingale.Convergence","initialProofState":"Ω : Type u_1\na b : Real\nf : Nat → Ω → Real\nω : Ω\nhab : LT.lt a b\nh₁ : Filter.Frequently (fun n => LT.lt (f n ω) a) Filter.atTop\nh₂ : Filter.Frequently (fun n => LT.lt b (f n ω)) Filter.atTop\n⊢ Eq (MeasureTheory.upcrossings a b f ω) Top.top","decl":"/-- A stochastic process that frequently visits below `a` and above `b` has infinite upcrossings. -/\ntheorem upcrossings_eq_top_of_frequently_lt (hab : a < b) (h₁ : ∃ᶠ n in atTop, f n ω < a)\n    (h₂ : ∃ᶠ n in atTop, b < f n ω) : upcrossings a b f ω = ∞ :=\n  by_contradiction fun h => not_frequently_of_upcrossings_lt_top hab h ⟨h₁, h₂⟩\n\n"}
{"name":"MeasureTheory.tendsto_of_uncrossing_lt_top","module":"Mathlib.Probability.Martingale.Convergence","initialProofState":"Ω : Type u_1\nf : Nat → Ω → Real\nω : Ω\nhf₁ : LT.lt (Filter.liminf (fun n => ↑(NNNorm.nnnorm (f n ω))) Filter.atTop) Top.top\nhf₂ : ∀ (a b : Rat), LT.lt a b → LT.lt (MeasureTheory.upcrossings (↑a) (↑b) f ω) Top.top\n⊢ Exists fun c => Filter.Tendsto (fun n => f n ω) Filter.atTop (nhds c)","decl":"/-- A realization of a stochastic process with bounded upcrossings and bounded liminfs is\nconvergent.\n\nWe use the spelling `< ∞` instead of the standard `≠ ∞` in the assumptions since it is not as easy\nto change `<` to `≠` under binders. -/\ntheorem tendsto_of_uncrossing_lt_top (hf₁ : liminf (fun n => (‖f n ω‖₊ : ℝ≥0∞)) atTop < ∞)\n    (hf₂ : ∀ a b : ℚ, a < b → upcrossings a b f ω < ∞) :\n    ∃ c, Tendsto (fun n => f n ω) atTop (𝓝 c) := by\n  by_cases h : IsBoundedUnder (· ≤ ·) atTop fun n => |f n ω|\n  · rw [isBoundedUnder_le_abs] at h\n    refine tendsto_of_no_upcrossings Rat.denseRange_cast ?_ h.1 h.2\n    rintro _ ⟨a, rfl⟩ _ ⟨b, rfl⟩ hab\n    exact not_frequently_of_upcrossings_lt_top hab (hf₂ a b (Rat.cast_lt.1 hab)).ne\n  · obtain ⟨a, b, hab, h₁, h₂⟩ := ENNReal.exists_upcrossings_of_not_bounded_under hf₁.ne h\n    exact\n      False.elim ((hf₂ a b hab).ne (upcrossings_eq_top_of_frequently_lt (Rat.cast_lt.2 hab) h₁ h₂))\n\n"}
{"name":"MeasureTheory.Submartingale.upcrossings_ae_lt_top'","module":"Mathlib.Probability.Martingale.Convergence","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nℱ : MeasureTheory.Filtration Nat m0\na b : Real\nf : Nat → Ω → Real\nR : NNReal\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhf : MeasureTheory.Submartingale f ℱ μ\nhbdd : ∀ (n : Nat), LE.le (MeasureTheory.eLpNorm (f n) 1 μ) ↑R\nhab : LT.lt a b\n⊢ Filter.Eventually (fun ω => LT.lt (MeasureTheory.upcrossings a b f ω) Top.top) (MeasureTheory.ae μ)","decl":"/-- An L¹-bounded submartingale has bounded upcrossings almost everywhere. -/\ntheorem Submartingale.upcrossings_ae_lt_top' [IsFiniteMeasure μ] (hf : Submartingale f ℱ μ)\n    (hbdd : ∀ n, eLpNorm (f n) 1 μ ≤ R) (hab : a < b) : ∀ᵐ ω ∂μ, upcrossings a b f ω < ∞ := by\n  refine ae_lt_top (hf.adapted.measurable_upcrossings hab) ?_\n  have := hf.mul_lintegral_upcrossings_le_lintegral_pos_part a b\n  rw [mul_comm, ← ENNReal.le_div_iff_mul_le] at this\n  · refine (lt_of_le_of_lt this (ENNReal.div_lt_top ?_ ?_)).ne\n    · have hR' : ∀ n, ∫⁻ ω, ‖f n ω - a‖₊ ∂μ ≤ R + ‖a‖₊ * μ Set.univ := by\n        simp_rw [eLpNorm_one_eq_lintegral_enorm] at hbdd\n        intro n\n        refine (lintegral_mono ?_ : ∫⁻ ω, ‖f n ω - a‖₊ ∂μ ≤ ∫⁻ ω, ‖f n ω‖₊ + ‖a‖₊ ∂μ).trans ?_\n        · intro ω\n          simp_rw [sub_eq_add_neg, ← nnnorm_neg a, ← ENNReal.coe_add, ENNReal.coe_le_coe]\n          exact nnnorm_add_le _ _\n        · simp_rw [lintegral_add_right _ measurable_const, lintegral_const]\n          exact add_le_add (hbdd _) le_rfl\n      refine ne_of_lt (iSup_lt_iff.2 ⟨R + ‖a‖₊ * μ Set.univ, ENNReal.add_lt_top.2\n        ⟨ENNReal.coe_lt_top, ENNReal.mul_lt_top ENNReal.coe_lt_top (measure_lt_top _ _)⟩,\n        fun n => le_trans ?_ (hR' n)⟩)\n      refine lintegral_mono fun ω => ?_\n      rw [ENNReal.ofReal_le_iff_le_toReal, ENNReal.coe_toReal, coe_nnnorm]\n      · by_cases hnonneg : 0 ≤ f n ω - a\n        · rw [posPart_eq_self.2 hnonneg, Real.norm_eq_abs, abs_of_nonneg hnonneg]\n        · rw [posPart_eq_zero.2 (not_le.1 hnonneg).le]\n          exact norm_nonneg _\n      · simp only [Ne, ENNReal.coe_ne_top, not_false_iff]\n    · simp only [hab, Ne, ENNReal.ofReal_eq_zero, sub_nonpos, not_le]\n  · simp only [hab, Ne, ENNReal.ofReal_eq_zero, sub_nonpos, not_le, true_or]\n  · simp only [Ne, ENNReal.ofReal_ne_top, not_false_iff, true_or]\n\n"}
{"name":"MeasureTheory.Submartingale.upcrossings_ae_lt_top","module":"Mathlib.Probability.Martingale.Convergence","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nℱ : MeasureTheory.Filtration Nat m0\nf : Nat → Ω → Real\nR : NNReal\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhf : MeasureTheory.Submartingale f ℱ μ\nhbdd : ∀ (n : Nat), LE.le (MeasureTheory.eLpNorm (f n) 1 μ) ↑R\n⊢ Filter.Eventually (fun ω => ∀ (a b : Rat), LT.lt a b → LT.lt (MeasureTheory.upcrossings (↑a) (↑b) f ω) Top.top) (MeasureTheory.ae μ)","decl":"theorem Submartingale.upcrossings_ae_lt_top [IsFiniteMeasure μ] (hf : Submartingale f ℱ μ)\n    (hbdd : ∀ n, eLpNorm (f n) 1 μ ≤ R) : ∀ᵐ ω ∂μ, ∀ a b : ℚ, a < b → upcrossings a b f ω < ∞ := by\n  simp only [ae_all_iff, eventually_imp_distrib_left]\n  rintro a b hab\n  exact hf.upcrossings_ae_lt_top' hbdd (Rat.cast_lt.2 hab)\n\n"}
{"name":"MeasureTheory.Submartingale.exists_ae_tendsto_of_bdd","module":"Mathlib.Probability.Martingale.Convergence","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nℱ : MeasureTheory.Filtration Nat m0\nf : Nat → Ω → Real\nR : NNReal\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhf : MeasureTheory.Submartingale f ℱ μ\nhbdd : ∀ (n : Nat), LE.le (MeasureTheory.eLpNorm (f n) 1 μ) ↑R\n⊢ Filter.Eventually (fun ω => Exists fun c => Filter.Tendsto (fun n => f n ω) Filter.atTop (nhds c)) (MeasureTheory.ae μ)","decl":"/-- An L¹-bounded submartingale converges almost everywhere. -/\ntheorem Submartingale.exists_ae_tendsto_of_bdd [IsFiniteMeasure μ] (hf : Submartingale f ℱ μ)\n    (hbdd : ∀ n, eLpNorm (f n) 1 μ ≤ R) : ∀ᵐ ω ∂μ, ∃ c, Tendsto (fun n => f n ω) atTop (𝓝 c) := by\n  filter_upwards [hf.upcrossings_ae_lt_top hbdd, ae_bdd_liminf_atTop_of_eLpNorm_bdd one_ne_zero\n    (fun n => (hf.stronglyMeasurable n).measurable.mono (ℱ.le n) le_rfl) hbdd] with ω h₁ h₂\n  exact tendsto_of_uncrossing_lt_top h₂ h₁\n\n"}
{"name":"MeasureTheory.Submartingale.exists_ae_trim_tendsto_of_bdd","module":"Mathlib.Probability.Martingale.Convergence","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nℱ : MeasureTheory.Filtration Nat m0\nf : Nat → Ω → Real\nR : NNReal\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhf : MeasureTheory.Submartingale f ℱ μ\nhbdd : ∀ (n : Nat), LE.le (MeasureTheory.eLpNorm (f n) 1 μ) ↑R\n⊢ Filter.Eventually (fun ω => Exists fun c => Filter.Tendsto (fun n => f n ω) Filter.atTop (nhds c)) (MeasureTheory.ae (μ.trim ⋯))","decl":"theorem Submartingale.exists_ae_trim_tendsto_of_bdd [IsFiniteMeasure μ] (hf : Submartingale f ℱ μ)\n    (hbdd : ∀ n, eLpNorm (f n) 1 μ ≤ R) :\n    ∀ᵐ ω ∂μ.trim (sSup_le fun _ ⟨_, hn⟩ => hn ▸ ℱ.le _ : ⨆ n, ℱ n ≤ m0),\n      ∃ c, Tendsto (fun n => f n ω) atTop (𝓝 c) := by\n  letI := (⨆ n, ℱ n)\n  rw [ae_iff, trim_measurableSet_eq]\n  · exact hf.exists_ae_tendsto_of_bdd hbdd\n  · exact MeasurableSet.compl <| measurableSet_exists_tendsto\n      fun n => (hf.stronglyMeasurable n).measurable.mono (le_sSup ⟨n, rfl⟩) le_rfl\n\n"}
{"name":"MeasureTheory.Submartingale.ae_tendsto_limitProcess","module":"Mathlib.Probability.Martingale.Convergence","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nℱ : MeasureTheory.Filtration Nat m0\nf : Nat → Ω → Real\nR : NNReal\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhf : MeasureTheory.Submartingale f ℱ μ\nhbdd : ∀ (n : Nat), LE.le (MeasureTheory.eLpNorm (f n) 1 μ) ↑R\n⊢ Filter.Eventually (fun ω => Filter.Tendsto (fun n => f n ω) Filter.atTop (nhds (MeasureTheory.Filtration.limitProcess f ℱ μ ω))) (MeasureTheory.ae μ)","decl":"/-- **Almost everywhere martingale convergence theorem**: An L¹-bounded submartingale converges\nalmost everywhere to a `⨆ n, ℱ n`-measurable function. -/\ntheorem Submartingale.ae_tendsto_limitProcess [IsFiniteMeasure μ] (hf : Submartingale f ℱ μ)\n    (hbdd : ∀ n, eLpNorm (f n) 1 μ ≤ R) :\n    ∀ᵐ ω ∂μ, Tendsto (fun n => f n ω) atTop (𝓝 (ℱ.limitProcess f μ ω)) := by\n  classical\n  suffices\n      ∃ g, StronglyMeasurable[⨆ n, ℱ n] g ∧ ∀ᵐ ω ∂μ, Tendsto (fun n => f n ω) atTop (𝓝 (g ω)) by\n    rw [limitProcess, dif_pos this]\n    exact (Classical.choose_spec this).2\n  set g' : Ω → ℝ := fun ω => if h : ∃ c, Tendsto (fun n => f n ω) atTop (𝓝 c) then h.choose else 0\n  have hle : ⨆ n, ℱ n ≤ m0 := sSup_le fun m ⟨n, hn⟩ => hn ▸ ℱ.le _\n  have hg' : ∀ᵐ ω ∂μ.trim hle, Tendsto (fun n => f n ω) atTop (𝓝 (g' ω)) := by\n    filter_upwards [hf.exists_ae_trim_tendsto_of_bdd hbdd] with ω hω\n    simp_rw [g', dif_pos hω]\n    exact hω.choose_spec\n  have hg'm : AEStronglyMeasurable[⨆ n, ℱ n] g' (μ.trim hle) :=\n    (@aemeasurable_of_tendsto_metrizable_ae' _ _ (⨆ n, ℱ n) _ _ _ _ _ _ _\n      (fun n => ((hf.stronglyMeasurable n).measurable.mono (le_sSup ⟨n, rfl⟩ : ℱ n ≤ ⨆ n, ℱ n)\n        le_rfl).aemeasurable) hg').aestronglyMeasurable\n  obtain ⟨g, hgm, hae⟩ := hg'm\n  have hg : ∀ᵐ ω ∂μ.trim hle, Tendsto (fun n => f n ω) atTop (𝓝 (g ω)) := by\n    filter_upwards [hae, hg'] with ω hω hg'ω\n    exact hω ▸ hg'ω\n  exact ⟨g, hgm, measure_eq_zero_of_trim_eq_zero hle hg⟩\n\n"}
{"name":"MeasureTheory.Submartingale.memℒp_limitProcess","module":"Mathlib.Probability.Martingale.Convergence","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nℱ : MeasureTheory.Filtration Nat m0\nf : Nat → Ω → Real\nR : NNReal\np : ENNReal\nhf : MeasureTheory.Submartingale f ℱ μ\nhbdd : ∀ (n : Nat), LE.le (MeasureTheory.eLpNorm (f n) p μ) ↑R\n⊢ MeasureTheory.Memℒp (MeasureTheory.Filtration.limitProcess f ℱ μ) p μ","decl":"/-- The limiting process of an Lᵖ-bounded submartingale is Lᵖ. -/\ntheorem Submartingale.memℒp_limitProcess {p : ℝ≥0∞} (hf : Submartingale f ℱ μ)\n    (hbdd : ∀ n, eLpNorm (f n) p μ ≤ R) : Memℒp (ℱ.limitProcess f μ) p μ :=\n  memℒp_limitProcess_of_eLpNorm_bdd\n    (fun n => ((hf.stronglyMeasurable n).mono (ℱ.le n)).aestronglyMeasurable) hbdd\n\n"}
{"name":"MeasureTheory.Submartingale.tendsto_eLpNorm_one_limitProcess","module":"Mathlib.Probability.Martingale.Convergence","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nℱ : MeasureTheory.Filtration Nat m0\nf : Nat → Ω → Real\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhf : MeasureTheory.Submartingale f ℱ μ\nhunif : MeasureTheory.UniformIntegrable f 1 μ\n⊢ Filter.Tendsto (fun n => MeasureTheory.eLpNorm (HSub.hSub (f n) (MeasureTheory.Filtration.limitProcess f ℱ μ)) 1 μ) Filter.atTop (nhds 0)","decl":"/-- Part a of the **L¹ martingale convergence theorem**: a uniformly integrable submartingale\nadapted to the filtration `ℱ` converges a.e. and in L¹ to an integrable function which is\nmeasurable with respect to the σ-algebra `⨆ n, ℱ n`. -/\ntheorem Submartingale.tendsto_eLpNorm_one_limitProcess (hf : Submartingale f ℱ μ)\n    (hunif : UniformIntegrable f 1 μ) :\n    Tendsto (fun n => eLpNorm (f n - ℱ.limitProcess f μ) 1 μ) atTop (𝓝 0) := by\n  obtain ⟨R, hR⟩ := hunif.2.2\n  have hmeas : ∀ n, AEStronglyMeasurable (f n) μ := fun n =>\n    ((hf.stronglyMeasurable n).mono (ℱ.le _)).aestronglyMeasurable\n  exact tendsto_Lp_finite_of_tendstoInMeasure le_rfl ENNReal.one_ne_top hmeas\n    (memℒp_limitProcess_of_eLpNorm_bdd hmeas hR) hunif.2.1\n    (tendstoInMeasure_of_tendsto_ae hmeas <| hf.ae_tendsto_limitProcess hR)\n\n"}
{"name":"MeasureTheory.Submartingale.ae_tendsto_limitProcess_of_uniformIntegrable","module":"Mathlib.Probability.Martingale.Convergence","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nℱ : MeasureTheory.Filtration Nat m0\nf : Nat → Ω → Real\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhf : MeasureTheory.Submartingale f ℱ μ\nhunif : MeasureTheory.UniformIntegrable f 1 μ\n⊢ Filter.Eventually (fun ω => Filter.Tendsto (fun n => f n ω) Filter.atTop (nhds (MeasureTheory.Filtration.limitProcess f ℱ μ ω))) (MeasureTheory.ae μ)","decl":"theorem Submartingale.ae_tendsto_limitProcess_of_uniformIntegrable (hf : Submartingale f ℱ μ)\n    (hunif : UniformIntegrable f 1 μ) :\n    ∀ᵐ ω ∂μ, Tendsto (fun n => f n ω) atTop (𝓝 (ℱ.limitProcess f μ ω)) :=\n  let ⟨_, hR⟩ := hunif.2.2\n  hf.ae_tendsto_limitProcess hR\n\n"}
{"name":"MeasureTheory.Martingale.eq_condExp_of_tendsto_eLpNorm","module":"Mathlib.Probability.Martingale.Convergence","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\nℱ : MeasureTheory.Filtration Nat m0\nf : Nat → Ω → Real\ng : Ω → Real\nμ : MeasureTheory.Measure Ω\nhf : MeasureTheory.Martingale f ℱ μ\nhg : MeasureTheory.Integrable g μ\nhgtends : Filter.Tendsto (fun n => MeasureTheory.eLpNorm (HSub.hSub (f n) g) 1 μ) Filter.atTop (nhds 0)\nn : Nat\n⊢ (MeasureTheory.ae μ).EventuallyEq (f n) (MeasureTheory.condExp (↑ℱ n) μ g)","decl":"/-- If a martingale `f` adapted to `ℱ` converges in L¹ to `g`, then for all `n`, `f n` is almost\neverywhere equal to `𝔼[g | ℱ n]`. -/\ntheorem Martingale.eq_condExp_of_tendsto_eLpNorm {μ : Measure Ω} (hf : Martingale f ℱ μ)\n    (hg : Integrable g μ) (hgtends : Tendsto (fun n => eLpNorm (f n - g) 1 μ) atTop (𝓝 0)) (n : ℕ) :\n    f n =ᵐ[μ] μ[g|ℱ n] := by\n  rw [← sub_ae_eq_zero, ← eLpNorm_eq_zero_iff (((hf.stronglyMeasurable n).mono (ℱ.le _)).sub\n    (stronglyMeasurable_condExp.mono (ℱ.le _))).aestronglyMeasurable one_ne_zero]\n  have ht : Tendsto (fun m => eLpNorm (μ[f m - g|ℱ n]) 1 μ) atTop (𝓝 0) :=\n    haveI hint : ∀ m, Integrable (f m - g) μ := fun m => (hf.integrable m).sub hg\n    tendsto_of_tendsto_of_tendsto_of_le_of_le tendsto_const_nhds hgtends (fun m => zero_le _)\n      fun m => eLpNorm_one_condExp_le_eLpNorm _\n  have hev : ∀ m ≥ n, eLpNorm (μ[f m - g|ℱ n]) 1 μ = eLpNorm (f n - μ[g|ℱ n]) 1 μ := by\n    refine fun m hm => eLpNorm_congr_ae ((condExp_sub (hf.integrable m) hg _).trans ?_)\n    filter_upwards [hf.2 n m hm] with x hx\n    simp only [hx, Pi.sub_apply]\n  exact tendsto_nhds_unique (tendsto_atTop_of_eventually_const hev) ht\n\n"}
{"name":"MeasureTheory.Martingale.eq_condexp_of_tendsto_eLpNorm","module":"Mathlib.Probability.Martingale.Convergence","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\nℱ : MeasureTheory.Filtration Nat m0\nf : Nat → Ω → Real\ng : Ω → Real\nμ : MeasureTheory.Measure Ω\nhf : MeasureTheory.Martingale f ℱ μ\nhg : MeasureTheory.Integrable g μ\nhgtends : Filter.Tendsto (fun n => MeasureTheory.eLpNorm (HSub.hSub (f n) g) 1 μ) Filter.atTop (nhds 0)\nn : Nat\n⊢ (MeasureTheory.ae μ).EventuallyEq (f n) (MeasureTheory.condExp (↑ℱ n) μ g)","decl":"@[deprecated (since := \"2025-01-21\")]\nalias Martingale.eq_condexp_of_tendsto_eLpNorm := Martingale.eq_condExp_of_tendsto_eLpNorm\n\n"}
{"name":"MeasureTheory.Martingale.ae_eq_condExp_limitProcess","module":"Mathlib.Probability.Martingale.Convergence","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nℱ : MeasureTheory.Filtration Nat m0\nf : Nat → Ω → Real\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhf : MeasureTheory.Martingale f ℱ μ\nhbdd : MeasureTheory.UniformIntegrable f 1 μ\nn : Nat\n⊢ (MeasureTheory.ae μ).EventuallyEq (f n) (MeasureTheory.condExp (↑ℱ n) μ (MeasureTheory.Filtration.limitProcess f ℱ μ))","decl":"/-- Part b of the **L¹ martingale convergence theorem**: if `f` is a uniformly integrable martingale\nadapted to the filtration `ℱ`, then for all `n`, `f n` is almost everywhere equal to the conditional\nexpectation of its limiting process wrt. `ℱ n`. -/\ntheorem Martingale.ae_eq_condExp_limitProcess (hf : Martingale f ℱ μ)\n    (hbdd : UniformIntegrable f 1 μ) (n : ℕ) : f n =ᵐ[μ] μ[ℱ.limitProcess f μ|ℱ n] :=\n  let ⟨_, hR⟩ := hbdd.2.2\n  hf.eq_condExp_of_tendsto_eLpNorm ((memℒp_limitProcess_of_eLpNorm_bdd hbdd.1 hR).integrable le_rfl)\n    (hf.submartingale.tendsto_eLpNorm_one_limitProcess hbdd) n\n\n"}
{"name":"MeasureTheory.Martingale.ae_eq_condexp_limitProcess","module":"Mathlib.Probability.Martingale.Convergence","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nℱ : MeasureTheory.Filtration Nat m0\nf : Nat → Ω → Real\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhf : MeasureTheory.Martingale f ℱ μ\nhbdd : MeasureTheory.UniformIntegrable f 1 μ\nn : Nat\n⊢ (MeasureTheory.ae μ).EventuallyEq (f n) (MeasureTheory.condExp (↑ℱ n) μ (MeasureTheory.Filtration.limitProcess f ℱ μ))","decl":"@[deprecated (since := \"2025-01-21\")]\nalias Martingale.ae_eq_condexp_limitProcess := Martingale.ae_eq_condExp_limitProcess\n\n"}
{"name":"MeasureTheory.Integrable.tendsto_ae_condExp","module":"Mathlib.Probability.Martingale.Convergence","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nℱ : MeasureTheory.Filtration Nat m0\ninst✝ : MeasureTheory.IsFiniteMeasure μ\ng : Ω → Real\nhg : MeasureTheory.Integrable g μ\nhgmeas : MeasureTheory.StronglyMeasurable g\n⊢ Filter.Eventually (fun x => Filter.Tendsto (fun n => MeasureTheory.condExp (↑ℱ n) μ g x) Filter.atTop (nhds (g x))) (MeasureTheory.ae μ)","decl":"/-- Part c of the **L¹ martingale convergence theorem**: Given an integrable function `g` which\nis measurable with respect to `⨆ n, ℱ n` where `ℱ` is a filtration, the martingale defined by\n`𝔼[g | ℱ n]` converges almost everywhere to `g`.\n\nThis martingale also converges to `g` in L¹ and this result is provided by\n`MeasureTheory.Integrable.tendsto_eLpNorm_condExp` -/\ntheorem Integrable.tendsto_ae_condExp (hg : Integrable g μ)\n    (hgmeas : StronglyMeasurable[⨆ n, ℱ n] g) :\n    ∀ᵐ x ∂μ, Tendsto (fun n => (μ[g|ℱ n]) x) atTop (𝓝 (g x)) := by\n  have hle : ⨆ n, ℱ n ≤ m0 := sSup_le fun m ⟨n, hn⟩ => hn ▸ ℱ.le _\n  have hunif : UniformIntegrable (fun n => μ[g|ℱ n]) 1 μ :=\n    hg.uniformIntegrable_condExp_filtration\n  obtain ⟨R, hR⟩ := hunif.2.2\n  have hlimint : Integrable (ℱ.limitProcess (fun n => μ[g|ℱ n]) μ) μ :=\n    (memℒp_limitProcess_of_eLpNorm_bdd hunif.1 hR).integrable le_rfl\n  suffices g =ᵐ[μ] ℱ.limitProcess (fun n x => (μ[g|ℱ n]) x) μ by\n    filter_upwards [this, (martingale_condExp g ℱ μ).submartingale.ae_tendsto_limitProcess hR] with\n      x heq ht\n    rwa [heq]\n  have : ∀ n s, MeasurableSet[ℱ n] s →\n      ∫ x in s, g x ∂μ = ∫ x in s, ℱ.limitProcess (fun n x => (μ[g|ℱ n]) x) μ x ∂μ := by\n    intro n s hs\n    rw [← setIntegral_condExp (ℱ.le n) hg hs, ← setIntegral_condExp (ℱ.le n) hlimint hs]\n    refine setIntegral_congr_ae (ℱ.le _ _ hs) ?_\n    filter_upwards [(martingale_condExp g ℱ μ).ae_eq_condExp_limitProcess hunif n] with x hx _\n    rw [hx]\n  refine ae_eq_of_forall_setIntegral_eq_of_sigmaFinite' hle (fun s _ _ => hg.integrableOn)\n    (fun s _ _ => hlimint.integrableOn) (fun s hs _ => ?_) hgmeas.aestronglyMeasurable\n    stronglyMeasurable_limitProcess.aestronglyMeasurable\n  have hpi : IsPiSystem {s | ∃ n, MeasurableSet[ℱ n] s} := by\n    rw [Set.setOf_exists]\n    exact isPiSystem_iUnion_of_monotone _ (fun n ↦ (ℱ n).isPiSystem_measurableSet) fun _ _ ↦ ℱ.mono\n  induction s, hs\n    using MeasurableSpace.induction_on_inter (MeasurableSpace.measurableSpace_iSup_eq ℱ) hpi with\n  | empty =>\n    simp only [measure_empty, Measure.restrict_empty, integral_zero_measure]\n  | basic s hs =>\n    rcases hs with ⟨n, hn⟩\n    exact this n _ hn\n  | compl t htmeas ht =>\n    have hgeq := @setIntegral_compl _ _ (⨆ n, ℱ n) _ _ _ _ _ htmeas (hg.trim hle hgmeas)\n    have hheq := @setIntegral_compl _ _ (⨆ n, ℱ n) _ _ _ _ _ htmeas\n      (hlimint.trim hle stronglyMeasurable_limitProcess)\n    rw [setIntegral_trim hle hgmeas htmeas.compl,\n      setIntegral_trim hle stronglyMeasurable_limitProcess htmeas.compl, hgeq, hheq, ←\n      setIntegral_trim hle hgmeas htmeas, ←\n      setIntegral_trim hle stronglyMeasurable_limitProcess htmeas, ← integral_trim hle hgmeas, ←\n      integral_trim hle stronglyMeasurable_limitProcess, ← setIntegral_univ,\n      this 0 _ MeasurableSet.univ, setIntegral_univ, ht (measure_lt_top _ _)]\n  | iUnion f hf hfmeas heq =>\n    rw [integral_iUnion (fun n => hle _ (hfmeas n)) hf hg.integrableOn,\n      integral_iUnion (fun n => hle _ (hfmeas n)) hf hlimint.integrableOn]\n    exact tsum_congr fun n => heq _ (measure_lt_top _ _)\n\n"}
{"name":"MeasureTheory.Integrable.tendsto_ae_condexp","module":"Mathlib.Probability.Martingale.Convergence","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nℱ : MeasureTheory.Filtration Nat m0\ninst✝ : MeasureTheory.IsFiniteMeasure μ\ng : Ω → Real\nhg : MeasureTheory.Integrable g μ\nhgmeas : MeasureTheory.StronglyMeasurable g\n⊢ Filter.Eventually (fun x => Filter.Tendsto (fun n => MeasureTheory.condExp (↑ℱ n) μ g x) Filter.atTop (nhds (g x))) (MeasureTheory.ae μ)","decl":"@[deprecated (since := \"2025-01-21\")]\nalias Integrable.tendsto_ae_condexp := Integrable.tendsto_ae_condExp\n\n"}
{"name":"MeasureTheory.Integrable.tendsto_eLpNorm_condExp","module":"Mathlib.Probability.Martingale.Convergence","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nℱ : MeasureTheory.Filtration Nat m0\ninst✝ : MeasureTheory.IsFiniteMeasure μ\ng : Ω → Real\nhg : MeasureTheory.Integrable g μ\nhgmeas : MeasureTheory.StronglyMeasurable g\n⊢ Filter.Tendsto (fun n => MeasureTheory.eLpNorm (HSub.hSub (MeasureTheory.condExp (↑ℱ n) μ g) g) 1 μ) Filter.atTop (nhds 0)","decl":"/-- Part c of the **L¹ martingale convergence theorem**: Given an integrable function `g` which\nis measurable with respect to `⨆ n, ℱ n` where `ℱ` is a filtration, the martingale defined by\n`𝔼[g | ℱ n]` converges in L¹ to `g`.\n\nThis martingale also converges to `g` almost everywhere and this result is provided by\n`MeasureTheory.Integrable.tendsto_ae_condExp` -/\ntheorem Integrable.tendsto_eLpNorm_condExp (hg : Integrable g μ)\n    (hgmeas : StronglyMeasurable[⨆ n, ℱ n] g) :\n    Tendsto (fun n => eLpNorm (μ[g|ℱ n] - g) 1 μ) atTop (𝓝 0) :=\n  tendsto_Lp_finite_of_tendstoInMeasure le_rfl ENNReal.one_ne_top\n    (fun n => (stronglyMeasurable_condExp.mono (ℱ.le n)).aestronglyMeasurable)\n    (memℒp_one_iff_integrable.2 hg) hg.uniformIntegrable_condExp_filtration.2.1\n    (tendstoInMeasure_of_tendsto_ae\n      (fun n => (stronglyMeasurable_condExp.mono (ℱ.le n)).aestronglyMeasurable)\n      (hg.tendsto_ae_condExp hgmeas))\n\n"}
{"name":"MeasureTheory.Integrable.tendsto_eLpNorm_condexp","module":"Mathlib.Probability.Martingale.Convergence","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nℱ : MeasureTheory.Filtration Nat m0\ninst✝ : MeasureTheory.IsFiniteMeasure μ\ng : Ω → Real\nhg : MeasureTheory.Integrable g μ\nhgmeas : MeasureTheory.StronglyMeasurable g\n⊢ Filter.Tendsto (fun n => MeasureTheory.eLpNorm (HSub.hSub (MeasureTheory.condExp (↑ℱ n) μ g) g) 1 μ) Filter.atTop (nhds 0)","decl":"@[deprecated (since := \"2025-01-21\")]\nalias Integrable.tendsto_eLpNorm_condexp := Integrable.tendsto_eLpNorm_condExp\n\n"}
{"name":"MeasureTheory.tendsto_ae_condExp","module":"Mathlib.Probability.Martingale.Convergence","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nℱ : MeasureTheory.Filtration Nat m0\ninst✝ : MeasureTheory.IsFiniteMeasure μ\ng : Ω → Real\n⊢ Filter.Eventually (fun x => Filter.Tendsto (fun n => MeasureTheory.condExp (↑ℱ n) μ g x) Filter.atTop (nhds (MeasureTheory.condExp (iSup fun n => ↑ℱ n) μ g x))) (MeasureTheory.ae μ)","decl":"/-- **Lévy's upward theorem**, almost everywhere version: given a function `g` and a filtration\n`ℱ`, the sequence defined by `𝔼[g | ℱ n]` converges almost everywhere to `𝔼[g | ⨆ n, ℱ n]`. -/\ntheorem tendsto_ae_condExp (g : Ω → ℝ) :\n    ∀ᵐ x ∂μ, Tendsto (fun n => (μ[g|ℱ n]) x) atTop (𝓝 ((μ[g|⨆ n, ℱ n]) x)) := by\n  have ht : ∀ᵐ x ∂μ, Tendsto (fun n => (μ[μ[g|⨆ n, ℱ n]|ℱ n]) x) atTop (𝓝 ((μ[g|⨆ n, ℱ n]) x)) :=\n    integrable_condExp.tendsto_ae_condExp stronglyMeasurable_condExp\n  have heq : ∀ n, ∀ᵐ x ∂μ, (μ[μ[g|⨆ n, ℱ n]|ℱ n]) x = (μ[g|ℱ n]) x := fun n =>\n    condExp_condExp_of_le (le_iSup _ n) (iSup_le fun n => ℱ.le n)\n  rw [← ae_all_iff] at heq\n  filter_upwards [heq, ht] with x hxeq hxt\n  exact hxt.congr hxeq\n\n"}
{"name":"MeasureTheory.tendsto_ae_condexp","module":"Mathlib.Probability.Martingale.Convergence","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nℱ : MeasureTheory.Filtration Nat m0\ninst✝ : MeasureTheory.IsFiniteMeasure μ\ng : Ω → Real\n⊢ Filter.Eventually (fun x => Filter.Tendsto (fun n => MeasureTheory.condExp (↑ℱ n) μ g x) Filter.atTop (nhds (MeasureTheory.condExp (iSup fun n => ↑ℱ n) μ g x))) (MeasureTheory.ae μ)","decl":"@[deprecated (since := \"2025-01-21\")] alias tendsto_ae_condexp := tendsto_ae_condExp\n\n"}
{"name":"MeasureTheory.tendsto_eLpNorm_condExp","module":"Mathlib.Probability.Martingale.Convergence","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nℱ : MeasureTheory.Filtration Nat m0\ninst✝ : MeasureTheory.IsFiniteMeasure μ\ng : Ω → Real\n⊢ Filter.Tendsto (fun n => MeasureTheory.eLpNorm (HSub.hSub (MeasureTheory.condExp (↑ℱ n) μ g) (MeasureTheory.condExp (iSup fun n => ↑ℱ n) μ g)) 1 μ) Filter.atTop (nhds 0)","decl":"/-- **Lévy's upward theorem**, L¹ version: given a function `g` and a filtration `ℱ`, the\nsequence defined by `𝔼[g | ℱ n]` converges in L¹ to `𝔼[g | ⨆ n, ℱ n]`. -/\ntheorem tendsto_eLpNorm_condExp (g : Ω → ℝ) :\n    Tendsto (fun n => eLpNorm (μ[g|ℱ n] - μ[g|⨆ n, ℱ n]) 1 μ) atTop (𝓝 0) := by\n  have ht : Tendsto (fun n => eLpNorm (μ[μ[g|⨆ n, ℱ n]|ℱ n] - μ[g|⨆ n, ℱ n]) 1 μ) atTop (𝓝 0) :=\n    integrable_condExp.tendsto_eLpNorm_condExp stronglyMeasurable_condExp\n  have heq : ∀ n, ∀ᵐ x ∂μ, (μ[μ[g|⨆ n, ℱ n]|ℱ n]) x = (μ[g|ℱ n]) x := fun n =>\n    condExp_condExp_of_le (le_iSup _ n) (iSup_le fun n => ℱ.le n)\n  refine ht.congr fun n => eLpNorm_congr_ae ?_\n  filter_upwards [heq n] with x hxeq\n  simp only [hxeq, Pi.sub_apply]\n\n"}
{"name":"MeasureTheory.tendsto_eLpNorm_condexp","module":"Mathlib.Probability.Martingale.Convergence","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nℱ : MeasureTheory.Filtration Nat m0\ninst✝ : MeasureTheory.IsFiniteMeasure μ\ng : Ω → Real\n⊢ Filter.Tendsto (fun n => MeasureTheory.eLpNorm (HSub.hSub (MeasureTheory.condExp (↑ℱ n) μ g) (MeasureTheory.condExp (iSup fun n => ↑ℱ n) μ g)) 1 μ) Filter.atTop (nhds 0)","decl":"@[deprecated (since := \"2025-01-21\")] alias tendsto_eLpNorm_condexp := tendsto_eLpNorm_condExp\n\n"}
