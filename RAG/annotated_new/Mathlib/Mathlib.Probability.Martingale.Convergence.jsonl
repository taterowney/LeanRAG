{"name":"MeasureTheory.not_frequently_of_upcrossings_lt_top","module":"Mathlib.Probability.Martingale.Convergence","initialProofState":"Î© : Type u_1\na b : Real\nf : Nat â†’ Î© â†’ Real\nÏ‰ : Î©\nhab : LT.lt a b\nhÏ‰ : Ne (MeasureTheory.upcrossings a b f Ï‰) Top.top\nâŠ¢ Not (And (Filter.Frequently (fun n => LT.lt (f n Ï‰) a) Filter.atTop) (Filter.Frequently (fun n => LT.lt b (f n Ï‰)) Filter.atTop))","decl":"/-- If a stochastic process has bounded upcrossing from below `a` to above `b`,\nthen it does not frequently visit both below `a` and above `b`. -/\ntheorem not_frequently_of_upcrossings_lt_top (hab : a < b) (hÏ‰ : upcrossings a b f Ï‰ â‰  âˆ) :\n    Â¬((âˆƒá¶  n in atTop, f n Ï‰ < a) âˆ§ âˆƒá¶  n in atTop, b < f n Ï‰) := by\n  rw [â† lt_top_iff_ne_top, upcrossings_lt_top_iff] at hÏ‰\n  replace hÏ‰ : âˆƒ k, âˆ€ N, upcrossingsBefore a b f N Ï‰ < k := by\n    obtain âŸ¨k, hkâŸ© := hÏ‰\n    exact âŸ¨k + 1, fun N => lt_of_le_of_lt (hk N) k.lt_succ_selfâŸ©\n  rintro âŸ¨hâ‚, hâ‚‚âŸ©\n  rw [frequently_atTop] at hâ‚ hâ‚‚\n  refine Classical.not_not.2 hÏ‰ ?_\n  push_neg\n  intro k\n  induction' k with k ih\n  Â· simp only [zero_le, exists_const]\n  Â· obtain âŸ¨N, hNâŸ© := ih\n    obtain âŸ¨Nâ‚, hNâ‚, hNâ‚'âŸ© := hâ‚ N\n    obtain âŸ¨Nâ‚‚, hNâ‚‚, hNâ‚‚'âŸ© := hâ‚‚ Nâ‚\n    exact âŸ¨Nâ‚‚ + 1, Nat.succ_le_of_lt <|\n      lt_of_le_of_lt hN (upcrossingsBefore_lt_of_exists_upcrossing hab hNâ‚ hNâ‚' hNâ‚‚ hNâ‚‚')âŸ©\n\n"}
{"name":"MeasureTheory.upcrossings_eq_top_of_frequently_lt","module":"Mathlib.Probability.Martingale.Convergence","initialProofState":"Î© : Type u_1\na b : Real\nf : Nat â†’ Î© â†’ Real\nÏ‰ : Î©\nhab : LT.lt a b\nhâ‚ : Filter.Frequently (fun n => LT.lt (f n Ï‰) a) Filter.atTop\nhâ‚‚ : Filter.Frequently (fun n => LT.lt b (f n Ï‰)) Filter.atTop\nâŠ¢ Eq (MeasureTheory.upcrossings a b f Ï‰) Top.top","decl":"/-- A stochastic process that frequently visits below `a` and above `b` has infinite upcrossings. -/\ntheorem upcrossings_eq_top_of_frequently_lt (hab : a < b) (hâ‚ : âˆƒá¶  n in atTop, f n Ï‰ < a)\n    (hâ‚‚ : âˆƒá¶  n in atTop, b < f n Ï‰) : upcrossings a b f Ï‰ = âˆ :=\n  by_contradiction fun h => not_frequently_of_upcrossings_lt_top hab h âŸ¨hâ‚, hâ‚‚âŸ©\n\n"}
{"name":"MeasureTheory.tendsto_of_uncrossing_lt_top","module":"Mathlib.Probability.Martingale.Convergence","initialProofState":"Î© : Type u_1\nf : Nat â†’ Î© â†’ Real\nÏ‰ : Î©\nhfâ‚ : LT.lt (Filter.liminf (fun n => â†‘(NNNorm.nnnorm (f n Ï‰))) Filter.atTop) Top.top\nhfâ‚‚ : âˆ€ (a b : Rat), LT.lt a b â†’ LT.lt (MeasureTheory.upcrossings (â†‘a) (â†‘b) f Ï‰) Top.top\nâŠ¢ Exists fun c => Filter.Tendsto (fun n => f n Ï‰) Filter.atTop (nhds c)","decl":"/-- A realization of a stochastic process with bounded upcrossings and bounded liminfs is\nconvergent.\n\nWe use the spelling `< âˆ` instead of the standard `â‰  âˆ` in the assumptions since it is not as easy\nto change `<` to `â‰ ` under binders. -/\ntheorem tendsto_of_uncrossing_lt_top (hfâ‚ : liminf (fun n => (â€–f n Ï‰â€–â‚Š : â„â‰¥0âˆ)) atTop < âˆ)\n    (hfâ‚‚ : âˆ€ a b : â„š, a < b â†’ upcrossings a b f Ï‰ < âˆ) :\n    âˆƒ c, Tendsto (fun n => f n Ï‰) atTop (ğ“ c) := by\n  by_cases h : IsBoundedUnder (Â· â‰¤ Â·) atTop fun n => |f n Ï‰|\n  Â· rw [isBoundedUnder_le_abs] at h\n    refine tendsto_of_no_upcrossings Rat.denseRange_cast ?_ h.1 h.2\n    rintro _ âŸ¨a, rflâŸ© _ âŸ¨b, rflâŸ© hab\n    exact not_frequently_of_upcrossings_lt_top hab (hfâ‚‚ a b (Rat.cast_lt.1 hab)).ne\n  Â· obtain âŸ¨a, b, hab, hâ‚, hâ‚‚âŸ© := ENNReal.exists_upcrossings_of_not_bounded_under hfâ‚.ne h\n    exact\n      False.elim ((hfâ‚‚ a b hab).ne (upcrossings_eq_top_of_frequently_lt (Rat.cast_lt.2 hab) hâ‚ hâ‚‚))\n\n"}
{"name":"MeasureTheory.Submartingale.upcrossings_ae_lt_top'","module":"Mathlib.Probability.Martingale.Convergence","initialProofState":"Î© : Type u_1\nm0 : MeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\nâ„± : MeasureTheory.Filtration Nat m0\na b : Real\nf : Nat â†’ Î© â†’ Real\nR : NNReal\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nhf : MeasureTheory.Submartingale f â„± Î¼\nhbdd : âˆ€ (n : Nat), LE.le (MeasureTheory.eLpNorm (f n) 1 Î¼) â†‘R\nhab : LT.lt a b\nâŠ¢ Filter.Eventually (fun Ï‰ => LT.lt (MeasureTheory.upcrossings a b f Ï‰) Top.top) (MeasureTheory.ae Î¼)","decl":"/-- An LÂ¹-bounded submartingale has bounded upcrossings almost everywhere. -/\ntheorem Submartingale.upcrossings_ae_lt_top' [IsFiniteMeasure Î¼] (hf : Submartingale f â„± Î¼)\n    (hbdd : âˆ€ n, eLpNorm (f n) 1 Î¼ â‰¤ R) (hab : a < b) : âˆ€áµ Ï‰ âˆ‚Î¼, upcrossings a b f Ï‰ < âˆ := by\n  refine ae_lt_top (hf.adapted.measurable_upcrossings hab) ?_\n  have := hf.mul_lintegral_upcrossings_le_lintegral_pos_part a b\n  rw [mul_comm, â† ENNReal.le_div_iff_mul_le] at this\n  Â· refine (lt_of_le_of_lt this (ENNReal.div_lt_top ?_ ?_)).ne\n    Â· have hR' : âˆ€ n, âˆ«â» Ï‰, â€–f n Ï‰ - aâ€–â‚Š âˆ‚Î¼ â‰¤ R + â€–aâ€–â‚Š * Î¼ Set.univ := by\n        simp_rw [eLpNorm_one_eq_lintegral_enorm] at hbdd\n        intro n\n        refine (lintegral_mono ?_ : âˆ«â» Ï‰, â€–f n Ï‰ - aâ€–â‚Š âˆ‚Î¼ â‰¤ âˆ«â» Ï‰, â€–f n Ï‰â€–â‚Š + â€–aâ€–â‚Š âˆ‚Î¼).trans ?_\n        Â· intro Ï‰\n          simp_rw [sub_eq_add_neg, â† nnnorm_neg a, â† ENNReal.coe_add, ENNReal.coe_le_coe]\n          exact nnnorm_add_le _ _\n        Â· simp_rw [lintegral_add_right _ measurable_const, lintegral_const]\n          exact add_le_add (hbdd _) le_rfl\n      refine ne_of_lt (iSup_lt_iff.2 âŸ¨R + â€–aâ€–â‚Š * Î¼ Set.univ, ENNReal.add_lt_top.2\n        âŸ¨ENNReal.coe_lt_top, ENNReal.mul_lt_top ENNReal.coe_lt_top (measure_lt_top _ _)âŸ©,\n        fun n => le_trans ?_ (hR' n)âŸ©)\n      refine lintegral_mono fun Ï‰ => ?_\n      rw [ENNReal.ofReal_le_iff_le_toReal, ENNReal.coe_toReal, coe_nnnorm]\n      Â· by_cases hnonneg : 0 â‰¤ f n Ï‰ - a\n        Â· rw [posPart_eq_self.2 hnonneg, Real.norm_eq_abs, abs_of_nonneg hnonneg]\n        Â· rw [posPart_eq_zero.2 (not_le.1 hnonneg).le]\n          exact norm_nonneg _\n      Â· simp only [Ne, ENNReal.coe_ne_top, not_false_iff]\n    Â· simp only [hab, Ne, ENNReal.ofReal_eq_zero, sub_nonpos, not_le]\n  Â· simp only [hab, Ne, ENNReal.ofReal_eq_zero, sub_nonpos, not_le, true_or]\n  Â· simp only [Ne, ENNReal.ofReal_ne_top, not_false_iff, true_or]\n\n"}
{"name":"MeasureTheory.Submartingale.upcrossings_ae_lt_top","module":"Mathlib.Probability.Martingale.Convergence","initialProofState":"Î© : Type u_1\nm0 : MeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\nâ„± : MeasureTheory.Filtration Nat m0\nf : Nat â†’ Î© â†’ Real\nR : NNReal\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nhf : MeasureTheory.Submartingale f â„± Î¼\nhbdd : âˆ€ (n : Nat), LE.le (MeasureTheory.eLpNorm (f n) 1 Î¼) â†‘R\nâŠ¢ Filter.Eventually (fun Ï‰ => âˆ€ (a b : Rat), LT.lt a b â†’ LT.lt (MeasureTheory.upcrossings (â†‘a) (â†‘b) f Ï‰) Top.top) (MeasureTheory.ae Î¼)","decl":"theorem Submartingale.upcrossings_ae_lt_top [IsFiniteMeasure Î¼] (hf : Submartingale f â„± Î¼)\n    (hbdd : âˆ€ n, eLpNorm (f n) 1 Î¼ â‰¤ R) : âˆ€áµ Ï‰ âˆ‚Î¼, âˆ€ a b : â„š, a < b â†’ upcrossings a b f Ï‰ < âˆ := by\n  simp only [ae_all_iff, eventually_imp_distrib_left]\n  rintro a b hab\n  exact hf.upcrossings_ae_lt_top' hbdd (Rat.cast_lt.2 hab)\n\n"}
{"name":"MeasureTheory.Submartingale.exists_ae_tendsto_of_bdd","module":"Mathlib.Probability.Martingale.Convergence","initialProofState":"Î© : Type u_1\nm0 : MeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\nâ„± : MeasureTheory.Filtration Nat m0\nf : Nat â†’ Î© â†’ Real\nR : NNReal\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nhf : MeasureTheory.Submartingale f â„± Î¼\nhbdd : âˆ€ (n : Nat), LE.le (MeasureTheory.eLpNorm (f n) 1 Î¼) â†‘R\nâŠ¢ Filter.Eventually (fun Ï‰ => Exists fun c => Filter.Tendsto (fun n => f n Ï‰) Filter.atTop (nhds c)) (MeasureTheory.ae Î¼)","decl":"/-- An LÂ¹-bounded submartingale converges almost everywhere. -/\ntheorem Submartingale.exists_ae_tendsto_of_bdd [IsFiniteMeasure Î¼] (hf : Submartingale f â„± Î¼)\n    (hbdd : âˆ€ n, eLpNorm (f n) 1 Î¼ â‰¤ R) : âˆ€áµ Ï‰ âˆ‚Î¼, âˆƒ c, Tendsto (fun n => f n Ï‰) atTop (ğ“ c) := by\n  filter_upwards [hf.upcrossings_ae_lt_top hbdd, ae_bdd_liminf_atTop_of_eLpNorm_bdd one_ne_zero\n    (fun n => (hf.stronglyMeasurable n).measurable.mono (â„±.le n) le_rfl) hbdd] with Ï‰ hâ‚ hâ‚‚\n  exact tendsto_of_uncrossing_lt_top hâ‚‚ hâ‚\n\n"}
{"name":"MeasureTheory.Submartingale.exists_ae_trim_tendsto_of_bdd","module":"Mathlib.Probability.Martingale.Convergence","initialProofState":"Î© : Type u_1\nm0 : MeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\nâ„± : MeasureTheory.Filtration Nat m0\nf : Nat â†’ Î© â†’ Real\nR : NNReal\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nhf : MeasureTheory.Submartingale f â„± Î¼\nhbdd : âˆ€ (n : Nat), LE.le (MeasureTheory.eLpNorm (f n) 1 Î¼) â†‘R\nâŠ¢ Filter.Eventually (fun Ï‰ => Exists fun c => Filter.Tendsto (fun n => f n Ï‰) Filter.atTop (nhds c)) (MeasureTheory.ae (Î¼.trim â‹¯))","decl":"theorem Submartingale.exists_ae_trim_tendsto_of_bdd [IsFiniteMeasure Î¼] (hf : Submartingale f â„± Î¼)\n    (hbdd : âˆ€ n, eLpNorm (f n) 1 Î¼ â‰¤ R) :\n    âˆ€áµ Ï‰ âˆ‚Î¼.trim (sSup_le fun _ âŸ¨_, hnâŸ© => hn â–¸ â„±.le _ : â¨† n, â„± n â‰¤ m0),\n      âˆƒ c, Tendsto (fun n => f n Ï‰) atTop (ğ“ c) := by\n  letI := (â¨† n, â„± n)\n  rw [ae_iff, trim_measurableSet_eq]\n  Â· exact hf.exists_ae_tendsto_of_bdd hbdd\n  Â· exact MeasurableSet.compl <| measurableSet_exists_tendsto\n      fun n => (hf.stronglyMeasurable n).measurable.mono (le_sSup âŸ¨n, rflâŸ©) le_rfl\n\n"}
{"name":"MeasureTheory.Submartingale.ae_tendsto_limitProcess","module":"Mathlib.Probability.Martingale.Convergence","initialProofState":"Î© : Type u_1\nm0 : MeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\nâ„± : MeasureTheory.Filtration Nat m0\nf : Nat â†’ Î© â†’ Real\nR : NNReal\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nhf : MeasureTheory.Submartingale f â„± Î¼\nhbdd : âˆ€ (n : Nat), LE.le (MeasureTheory.eLpNorm (f n) 1 Î¼) â†‘R\nâŠ¢ Filter.Eventually (fun Ï‰ => Filter.Tendsto (fun n => f n Ï‰) Filter.atTop (nhds (MeasureTheory.Filtration.limitProcess f â„± Î¼ Ï‰))) (MeasureTheory.ae Î¼)","decl":"/-- **Almost everywhere martingale convergence theorem**: An LÂ¹-bounded submartingale converges\nalmost everywhere to a `â¨† n, â„± n`-measurable function. -/\ntheorem Submartingale.ae_tendsto_limitProcess [IsFiniteMeasure Î¼] (hf : Submartingale f â„± Î¼)\n    (hbdd : âˆ€ n, eLpNorm (f n) 1 Î¼ â‰¤ R) :\n    âˆ€áµ Ï‰ âˆ‚Î¼, Tendsto (fun n => f n Ï‰) atTop (ğ“ (â„±.limitProcess f Î¼ Ï‰)) := by\n  classical\n  suffices\n      âˆƒ g, StronglyMeasurable[â¨† n, â„± n] g âˆ§ âˆ€áµ Ï‰ âˆ‚Î¼, Tendsto (fun n => f n Ï‰) atTop (ğ“ (g Ï‰)) by\n    rw [limitProcess, dif_pos this]\n    exact (Classical.choose_spec this).2\n  set g' : Î© â†’ â„ := fun Ï‰ => if h : âˆƒ c, Tendsto (fun n => f n Ï‰) atTop (ğ“ c) then h.choose else 0\n  have hle : â¨† n, â„± n â‰¤ m0 := sSup_le fun m âŸ¨n, hnâŸ© => hn â–¸ â„±.le _\n  have hg' : âˆ€áµ Ï‰ âˆ‚Î¼.trim hle, Tendsto (fun n => f n Ï‰) atTop (ğ“ (g' Ï‰)) := by\n    filter_upwards [hf.exists_ae_trim_tendsto_of_bdd hbdd] with Ï‰ hÏ‰\n    simp_rw [g', dif_pos hÏ‰]\n    exact hÏ‰.choose_spec\n  have hg'm : AEStronglyMeasurable[â¨† n, â„± n] g' (Î¼.trim hle) :=\n    (@aemeasurable_of_tendsto_metrizable_ae' _ _ (â¨† n, â„± n) _ _ _ _ _ _ _\n      (fun n => ((hf.stronglyMeasurable n).measurable.mono (le_sSup âŸ¨n, rflâŸ© : â„± n â‰¤ â¨† n, â„± n)\n        le_rfl).aemeasurable) hg').aestronglyMeasurable\n  obtain âŸ¨g, hgm, haeâŸ© := hg'm\n  have hg : âˆ€áµ Ï‰ âˆ‚Î¼.trim hle, Tendsto (fun n => f n Ï‰) atTop (ğ“ (g Ï‰)) := by\n    filter_upwards [hae, hg'] with Ï‰ hÏ‰ hg'Ï‰\n    exact hÏ‰ â–¸ hg'Ï‰\n  exact âŸ¨g, hgm, measure_eq_zero_of_trim_eq_zero hle hgâŸ©\n\n"}
{"name":"MeasureTheory.Submartingale.memâ„’p_limitProcess","module":"Mathlib.Probability.Martingale.Convergence","initialProofState":"Î© : Type u_1\nm0 : MeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\nâ„± : MeasureTheory.Filtration Nat m0\nf : Nat â†’ Î© â†’ Real\nR : NNReal\np : ENNReal\nhf : MeasureTheory.Submartingale f â„± Î¼\nhbdd : âˆ€ (n : Nat), LE.le (MeasureTheory.eLpNorm (f n) p Î¼) â†‘R\nâŠ¢ MeasureTheory.Memâ„’p (MeasureTheory.Filtration.limitProcess f â„± Î¼) p Î¼","decl":"/-- The limiting process of an Láµ–-bounded submartingale is Láµ–. -/\ntheorem Submartingale.memâ„’p_limitProcess {p : â„â‰¥0âˆ} (hf : Submartingale f â„± Î¼)\n    (hbdd : âˆ€ n, eLpNorm (f n) p Î¼ â‰¤ R) : Memâ„’p (â„±.limitProcess f Î¼) p Î¼ :=\n  memâ„’p_limitProcess_of_eLpNorm_bdd\n    (fun n => ((hf.stronglyMeasurable n).mono (â„±.le n)).aestronglyMeasurable) hbdd\n\n"}
{"name":"MeasureTheory.Submartingale.tendsto_eLpNorm_one_limitProcess","module":"Mathlib.Probability.Martingale.Convergence","initialProofState":"Î© : Type u_1\nm0 : MeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\nâ„± : MeasureTheory.Filtration Nat m0\nf : Nat â†’ Î© â†’ Real\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nhf : MeasureTheory.Submartingale f â„± Î¼\nhunif : MeasureTheory.UniformIntegrable f 1 Î¼\nâŠ¢ Filter.Tendsto (fun n => MeasureTheory.eLpNorm (HSub.hSub (f n) (MeasureTheory.Filtration.limitProcess f â„± Î¼)) 1 Î¼) Filter.atTop (nhds 0)","decl":"/-- Part a of the **LÂ¹ martingale convergence theorem**: a uniformly integrable submartingale\nadapted to the filtration `â„±` converges a.e. and in LÂ¹ to an integrable function which is\nmeasurable with respect to the Ïƒ-algebra `â¨† n, â„± n`. -/\ntheorem Submartingale.tendsto_eLpNorm_one_limitProcess (hf : Submartingale f â„± Î¼)\n    (hunif : UniformIntegrable f 1 Î¼) :\n    Tendsto (fun n => eLpNorm (f n - â„±.limitProcess f Î¼) 1 Î¼) atTop (ğ“ 0) := by\n  obtain âŸ¨R, hRâŸ© := hunif.2.2\n  have hmeas : âˆ€ n, AEStronglyMeasurable (f n) Î¼ := fun n =>\n    ((hf.stronglyMeasurable n).mono (â„±.le _)).aestronglyMeasurable\n  exact tendsto_Lp_finite_of_tendstoInMeasure le_rfl ENNReal.one_ne_top hmeas\n    (memâ„’p_limitProcess_of_eLpNorm_bdd hmeas hR) hunif.2.1\n    (tendstoInMeasure_of_tendsto_ae hmeas <| hf.ae_tendsto_limitProcess hR)\n\n"}
{"name":"MeasureTheory.Submartingale.ae_tendsto_limitProcess_of_uniformIntegrable","module":"Mathlib.Probability.Martingale.Convergence","initialProofState":"Î© : Type u_1\nm0 : MeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\nâ„± : MeasureTheory.Filtration Nat m0\nf : Nat â†’ Î© â†’ Real\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nhf : MeasureTheory.Submartingale f â„± Î¼\nhunif : MeasureTheory.UniformIntegrable f 1 Î¼\nâŠ¢ Filter.Eventually (fun Ï‰ => Filter.Tendsto (fun n => f n Ï‰) Filter.atTop (nhds (MeasureTheory.Filtration.limitProcess f â„± Î¼ Ï‰))) (MeasureTheory.ae Î¼)","decl":"theorem Submartingale.ae_tendsto_limitProcess_of_uniformIntegrable (hf : Submartingale f â„± Î¼)\n    (hunif : UniformIntegrable f 1 Î¼) :\n    âˆ€áµ Ï‰ âˆ‚Î¼, Tendsto (fun n => f n Ï‰) atTop (ğ“ (â„±.limitProcess f Î¼ Ï‰)) :=\n  let âŸ¨_, hRâŸ© := hunif.2.2\n  hf.ae_tendsto_limitProcess hR\n\n"}
{"name":"MeasureTheory.Martingale.eq_condExp_of_tendsto_eLpNorm","module":"Mathlib.Probability.Martingale.Convergence","initialProofState":"Î© : Type u_1\nm0 : MeasurableSpace Î©\nâ„± : MeasureTheory.Filtration Nat m0\nf : Nat â†’ Î© â†’ Real\ng : Î© â†’ Real\nÎ¼ : MeasureTheory.Measure Î©\nhf : MeasureTheory.Martingale f â„± Î¼\nhg : MeasureTheory.Integrable g Î¼\nhgtends : Filter.Tendsto (fun n => MeasureTheory.eLpNorm (HSub.hSub (f n) g) 1 Î¼) Filter.atTop (nhds 0)\nn : Nat\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq (f n) (MeasureTheory.condExp (â†‘â„± n) Î¼ g)","decl":"/-- If a martingale `f` adapted to `â„±` converges in LÂ¹ to `g`, then for all `n`, `f n` is almost\neverywhere equal to `ğ”¼[g | â„± n]`. -/\ntheorem Martingale.eq_condExp_of_tendsto_eLpNorm {Î¼ : Measure Î©} (hf : Martingale f â„± Î¼)\n    (hg : Integrable g Î¼) (hgtends : Tendsto (fun n => eLpNorm (f n - g) 1 Î¼) atTop (ğ“ 0)) (n : â„•) :\n    f n =áµ[Î¼] Î¼[g|â„± n] := by\n  rw [â† sub_ae_eq_zero, â† eLpNorm_eq_zero_iff (((hf.stronglyMeasurable n).mono (â„±.le _)).sub\n    (stronglyMeasurable_condExp.mono (â„±.le _))).aestronglyMeasurable one_ne_zero]\n  have ht : Tendsto (fun m => eLpNorm (Î¼[f m - g|â„± n]) 1 Î¼) atTop (ğ“ 0) :=\n    haveI hint : âˆ€ m, Integrable (f m - g) Î¼ := fun m => (hf.integrable m).sub hg\n    tendsto_of_tendsto_of_tendsto_of_le_of_le tendsto_const_nhds hgtends (fun m => zero_le _)\n      fun m => eLpNorm_one_condExp_le_eLpNorm _\n  have hev : âˆ€ m â‰¥ n, eLpNorm (Î¼[f m - g|â„± n]) 1 Î¼ = eLpNorm (f n - Î¼[g|â„± n]) 1 Î¼ := by\n    refine fun m hm => eLpNorm_congr_ae ((condExp_sub (hf.integrable m) hg _).trans ?_)\n    filter_upwards [hf.2 n m hm] with x hx\n    simp only [hx, Pi.sub_apply]\n  exact tendsto_nhds_unique (tendsto_atTop_of_eventually_const hev) ht\n\n"}
{"name":"MeasureTheory.Martingale.eq_condexp_of_tendsto_eLpNorm","module":"Mathlib.Probability.Martingale.Convergence","initialProofState":"Î© : Type u_1\nm0 : MeasurableSpace Î©\nâ„± : MeasureTheory.Filtration Nat m0\nf : Nat â†’ Î© â†’ Real\ng : Î© â†’ Real\nÎ¼ : MeasureTheory.Measure Î©\nhf : MeasureTheory.Martingale f â„± Î¼\nhg : MeasureTheory.Integrable g Î¼\nhgtends : Filter.Tendsto (fun n => MeasureTheory.eLpNorm (HSub.hSub (f n) g) 1 Î¼) Filter.atTop (nhds 0)\nn : Nat\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq (f n) (MeasureTheory.condExp (â†‘â„± n) Î¼ g)","decl":"@[deprecated (since := \"2025-01-21\")]\nalias Martingale.eq_condexp_of_tendsto_eLpNorm := Martingale.eq_condExp_of_tendsto_eLpNorm\n\n"}
{"name":"MeasureTheory.Martingale.ae_eq_condExp_limitProcess","module":"Mathlib.Probability.Martingale.Convergence","initialProofState":"Î© : Type u_1\nm0 : MeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\nâ„± : MeasureTheory.Filtration Nat m0\nf : Nat â†’ Î© â†’ Real\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nhf : MeasureTheory.Martingale f â„± Î¼\nhbdd : MeasureTheory.UniformIntegrable f 1 Î¼\nn : Nat\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq (f n) (MeasureTheory.condExp (â†‘â„± n) Î¼ (MeasureTheory.Filtration.limitProcess f â„± Î¼))","decl":"/-- Part b of the **LÂ¹ martingale convergence theorem**: if `f` is a uniformly integrable martingale\nadapted to the filtration `â„±`, then for all `n`, `f n` is almost everywhere equal to the conditional\nexpectation of its limiting process wrt. `â„± n`. -/\ntheorem Martingale.ae_eq_condExp_limitProcess (hf : Martingale f â„± Î¼)\n    (hbdd : UniformIntegrable f 1 Î¼) (n : â„•) : f n =áµ[Î¼] Î¼[â„±.limitProcess f Î¼|â„± n] :=\n  let âŸ¨_, hRâŸ© := hbdd.2.2\n  hf.eq_condExp_of_tendsto_eLpNorm ((memâ„’p_limitProcess_of_eLpNorm_bdd hbdd.1 hR).integrable le_rfl)\n    (hf.submartingale.tendsto_eLpNorm_one_limitProcess hbdd) n\n\n"}
{"name":"MeasureTheory.Martingale.ae_eq_condexp_limitProcess","module":"Mathlib.Probability.Martingale.Convergence","initialProofState":"Î© : Type u_1\nm0 : MeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\nâ„± : MeasureTheory.Filtration Nat m0\nf : Nat â†’ Î© â†’ Real\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nhf : MeasureTheory.Martingale f â„± Î¼\nhbdd : MeasureTheory.UniformIntegrable f 1 Î¼\nn : Nat\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq (f n) (MeasureTheory.condExp (â†‘â„± n) Î¼ (MeasureTheory.Filtration.limitProcess f â„± Î¼))","decl":"@[deprecated (since := \"2025-01-21\")]\nalias Martingale.ae_eq_condexp_limitProcess := Martingale.ae_eq_condExp_limitProcess\n\n"}
{"name":"MeasureTheory.Integrable.tendsto_ae_condExp","module":"Mathlib.Probability.Martingale.Convergence","initialProofState":"Î© : Type u_1\nm0 : MeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\nâ„± : MeasureTheory.Filtration Nat m0\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\ng : Î© â†’ Real\nhg : MeasureTheory.Integrable g Î¼\nhgmeas : MeasureTheory.StronglyMeasurable g\nâŠ¢ Filter.Eventually (fun x => Filter.Tendsto (fun n => MeasureTheory.condExp (â†‘â„± n) Î¼ g x) Filter.atTop (nhds (g x))) (MeasureTheory.ae Î¼)","decl":"/-- Part c of the **LÂ¹ martingale convergence theorem**: Given an integrable function `g` which\nis measurable with respect to `â¨† n, â„± n` where `â„±` is a filtration, the martingale defined by\n`ğ”¼[g | â„± n]` converges almost everywhere to `g`.\n\nThis martingale also converges to `g` in LÂ¹ and this result is provided by\n`MeasureTheory.Integrable.tendsto_eLpNorm_condExp` -/\ntheorem Integrable.tendsto_ae_condExp (hg : Integrable g Î¼)\n    (hgmeas : StronglyMeasurable[â¨† n, â„± n] g) :\n    âˆ€áµ x âˆ‚Î¼, Tendsto (fun n => (Î¼[g|â„± n]) x) atTop (ğ“ (g x)) := by\n  have hle : â¨† n, â„± n â‰¤ m0 := sSup_le fun m âŸ¨n, hnâŸ© => hn â–¸ â„±.le _\n  have hunif : UniformIntegrable (fun n => Î¼[g|â„± n]) 1 Î¼ :=\n    hg.uniformIntegrable_condExp_filtration\n  obtain âŸ¨R, hRâŸ© := hunif.2.2\n  have hlimint : Integrable (â„±.limitProcess (fun n => Î¼[g|â„± n]) Î¼) Î¼ :=\n    (memâ„’p_limitProcess_of_eLpNorm_bdd hunif.1 hR).integrable le_rfl\n  suffices g =áµ[Î¼] â„±.limitProcess (fun n x => (Î¼[g|â„± n]) x) Î¼ by\n    filter_upwards [this, (martingale_condExp g â„± Î¼).submartingale.ae_tendsto_limitProcess hR] with\n      x heq ht\n    rwa [heq]\n  have : âˆ€ n s, MeasurableSet[â„± n] s â†’\n      âˆ« x in s, g x âˆ‚Î¼ = âˆ« x in s, â„±.limitProcess (fun n x => (Î¼[g|â„± n]) x) Î¼ x âˆ‚Î¼ := by\n    intro n s hs\n    rw [â† setIntegral_condExp (â„±.le n) hg hs, â† setIntegral_condExp (â„±.le n) hlimint hs]\n    refine setIntegral_congr_ae (â„±.le _ _ hs) ?_\n    filter_upwards [(martingale_condExp g â„± Î¼).ae_eq_condExp_limitProcess hunif n] with x hx _\n    rw [hx]\n  refine ae_eq_of_forall_setIntegral_eq_of_sigmaFinite' hle (fun s _ _ => hg.integrableOn)\n    (fun s _ _ => hlimint.integrableOn) (fun s hs _ => ?_) hgmeas.aestronglyMeasurable\n    stronglyMeasurable_limitProcess.aestronglyMeasurable\n  have hpi : IsPiSystem {s | âˆƒ n, MeasurableSet[â„± n] s} := by\n    rw [Set.setOf_exists]\n    exact isPiSystem_iUnion_of_monotone _ (fun n â†¦ (â„± n).isPiSystem_measurableSet) fun _ _ â†¦ â„±.mono\n  induction s, hs\n    using MeasurableSpace.induction_on_inter (MeasurableSpace.measurableSpace_iSup_eq â„±) hpi with\n  | empty =>\n    simp only [measure_empty, Measure.restrict_empty, integral_zero_measure]\n  | basic s hs =>\n    rcases hs with âŸ¨n, hnâŸ©\n    exact this n _ hn\n  | compl t htmeas ht =>\n    have hgeq := @setIntegral_compl _ _ (â¨† n, â„± n) _ _ _ _ _ htmeas (hg.trim hle hgmeas)\n    have hheq := @setIntegral_compl _ _ (â¨† n, â„± n) _ _ _ _ _ htmeas\n      (hlimint.trim hle stronglyMeasurable_limitProcess)\n    rw [setIntegral_trim hle hgmeas htmeas.compl,\n      setIntegral_trim hle stronglyMeasurable_limitProcess htmeas.compl, hgeq, hheq, â†\n      setIntegral_trim hle hgmeas htmeas, â†\n      setIntegral_trim hle stronglyMeasurable_limitProcess htmeas, â† integral_trim hle hgmeas, â†\n      integral_trim hle stronglyMeasurable_limitProcess, â† setIntegral_univ,\n      this 0 _ MeasurableSet.univ, setIntegral_univ, ht (measure_lt_top _ _)]\n  | iUnion f hf hfmeas heq =>\n    rw [integral_iUnion (fun n => hle _ (hfmeas n)) hf hg.integrableOn,\n      integral_iUnion (fun n => hle _ (hfmeas n)) hf hlimint.integrableOn]\n    exact tsum_congr fun n => heq _ (measure_lt_top _ _)\n\n"}
{"name":"MeasureTheory.Integrable.tendsto_ae_condexp","module":"Mathlib.Probability.Martingale.Convergence","initialProofState":"Î© : Type u_1\nm0 : MeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\nâ„± : MeasureTheory.Filtration Nat m0\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\ng : Î© â†’ Real\nhg : MeasureTheory.Integrable g Î¼\nhgmeas : MeasureTheory.StronglyMeasurable g\nâŠ¢ Filter.Eventually (fun x => Filter.Tendsto (fun n => MeasureTheory.condExp (â†‘â„± n) Î¼ g x) Filter.atTop (nhds (g x))) (MeasureTheory.ae Î¼)","decl":"@[deprecated (since := \"2025-01-21\")]\nalias Integrable.tendsto_ae_condexp := Integrable.tendsto_ae_condExp\n\n"}
{"name":"MeasureTheory.Integrable.tendsto_eLpNorm_condExp","module":"Mathlib.Probability.Martingale.Convergence","initialProofState":"Î© : Type u_1\nm0 : MeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\nâ„± : MeasureTheory.Filtration Nat m0\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\ng : Î© â†’ Real\nhg : MeasureTheory.Integrable g Î¼\nhgmeas : MeasureTheory.StronglyMeasurable g\nâŠ¢ Filter.Tendsto (fun n => MeasureTheory.eLpNorm (HSub.hSub (MeasureTheory.condExp (â†‘â„± n) Î¼ g) g) 1 Î¼) Filter.atTop (nhds 0)","decl":"/-- Part c of the **LÂ¹ martingale convergence theorem**: Given an integrable function `g` which\nis measurable with respect to `â¨† n, â„± n` where `â„±` is a filtration, the martingale defined by\n`ğ”¼[g | â„± n]` converges in LÂ¹ to `g`.\n\nThis martingale also converges to `g` almost everywhere and this result is provided by\n`MeasureTheory.Integrable.tendsto_ae_condExp` -/\ntheorem Integrable.tendsto_eLpNorm_condExp (hg : Integrable g Î¼)\n    (hgmeas : StronglyMeasurable[â¨† n, â„± n] g) :\n    Tendsto (fun n => eLpNorm (Î¼[g|â„± n] - g) 1 Î¼) atTop (ğ“ 0) :=\n  tendsto_Lp_finite_of_tendstoInMeasure le_rfl ENNReal.one_ne_top\n    (fun n => (stronglyMeasurable_condExp.mono (â„±.le n)).aestronglyMeasurable)\n    (memâ„’p_one_iff_integrable.2 hg) hg.uniformIntegrable_condExp_filtration.2.1\n    (tendstoInMeasure_of_tendsto_ae\n      (fun n => (stronglyMeasurable_condExp.mono (â„±.le n)).aestronglyMeasurable)\n      (hg.tendsto_ae_condExp hgmeas))\n\n"}
{"name":"MeasureTheory.Integrable.tendsto_eLpNorm_condexp","module":"Mathlib.Probability.Martingale.Convergence","initialProofState":"Î© : Type u_1\nm0 : MeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\nâ„± : MeasureTheory.Filtration Nat m0\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\ng : Î© â†’ Real\nhg : MeasureTheory.Integrable g Î¼\nhgmeas : MeasureTheory.StronglyMeasurable g\nâŠ¢ Filter.Tendsto (fun n => MeasureTheory.eLpNorm (HSub.hSub (MeasureTheory.condExp (â†‘â„± n) Î¼ g) g) 1 Î¼) Filter.atTop (nhds 0)","decl":"@[deprecated (since := \"2025-01-21\")]\nalias Integrable.tendsto_eLpNorm_condexp := Integrable.tendsto_eLpNorm_condExp\n\n"}
{"name":"MeasureTheory.tendsto_ae_condExp","module":"Mathlib.Probability.Martingale.Convergence","initialProofState":"Î© : Type u_1\nm0 : MeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\nâ„± : MeasureTheory.Filtration Nat m0\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\ng : Î© â†’ Real\nâŠ¢ Filter.Eventually (fun x => Filter.Tendsto (fun n => MeasureTheory.condExp (â†‘â„± n) Î¼ g x) Filter.atTop (nhds (MeasureTheory.condExp (iSup fun n => â†‘â„± n) Î¼ g x))) (MeasureTheory.ae Î¼)","decl":"/-- **LÃ©vy's upward theorem**, almost everywhere version: given a function `g` and a filtration\n`â„±`, the sequence defined by `ğ”¼[g | â„± n]` converges almost everywhere to `ğ”¼[g | â¨† n, â„± n]`. -/\ntheorem tendsto_ae_condExp (g : Î© â†’ â„) :\n    âˆ€áµ x âˆ‚Î¼, Tendsto (fun n => (Î¼[g|â„± n]) x) atTop (ğ“ ((Î¼[g|â¨† n, â„± n]) x)) := by\n  have ht : âˆ€áµ x âˆ‚Î¼, Tendsto (fun n => (Î¼[Î¼[g|â¨† n, â„± n]|â„± n]) x) atTop (ğ“ ((Î¼[g|â¨† n, â„± n]) x)) :=\n    integrable_condExp.tendsto_ae_condExp stronglyMeasurable_condExp\n  have heq : âˆ€ n, âˆ€áµ x âˆ‚Î¼, (Î¼[Î¼[g|â¨† n, â„± n]|â„± n]) x = (Î¼[g|â„± n]) x := fun n =>\n    condExp_condExp_of_le (le_iSup _ n) (iSup_le fun n => â„±.le n)\n  rw [â† ae_all_iff] at heq\n  filter_upwards [heq, ht] with x hxeq hxt\n  exact hxt.congr hxeq\n\n"}
{"name":"MeasureTheory.tendsto_ae_condexp","module":"Mathlib.Probability.Martingale.Convergence","initialProofState":"Î© : Type u_1\nm0 : MeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\nâ„± : MeasureTheory.Filtration Nat m0\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\ng : Î© â†’ Real\nâŠ¢ Filter.Eventually (fun x => Filter.Tendsto (fun n => MeasureTheory.condExp (â†‘â„± n) Î¼ g x) Filter.atTop (nhds (MeasureTheory.condExp (iSup fun n => â†‘â„± n) Î¼ g x))) (MeasureTheory.ae Î¼)","decl":"@[deprecated (since := \"2025-01-21\")] alias tendsto_ae_condexp := tendsto_ae_condExp\n\n"}
{"name":"MeasureTheory.tendsto_eLpNorm_condExp","module":"Mathlib.Probability.Martingale.Convergence","initialProofState":"Î© : Type u_1\nm0 : MeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\nâ„± : MeasureTheory.Filtration Nat m0\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\ng : Î© â†’ Real\nâŠ¢ Filter.Tendsto (fun n => MeasureTheory.eLpNorm (HSub.hSub (MeasureTheory.condExp (â†‘â„± n) Î¼ g) (MeasureTheory.condExp (iSup fun n => â†‘â„± n) Î¼ g)) 1 Î¼) Filter.atTop (nhds 0)","decl":"/-- **LÃ©vy's upward theorem**, LÂ¹ version: given a function `g` and a filtration `â„±`, the\nsequence defined by `ğ”¼[g | â„± n]` converges in LÂ¹ to `ğ”¼[g | â¨† n, â„± n]`. -/\ntheorem tendsto_eLpNorm_condExp (g : Î© â†’ â„) :\n    Tendsto (fun n => eLpNorm (Î¼[g|â„± n] - Î¼[g|â¨† n, â„± n]) 1 Î¼) atTop (ğ“ 0) := by\n  have ht : Tendsto (fun n => eLpNorm (Î¼[Î¼[g|â¨† n, â„± n]|â„± n] - Î¼[g|â¨† n, â„± n]) 1 Î¼) atTop (ğ“ 0) :=\n    integrable_condExp.tendsto_eLpNorm_condExp stronglyMeasurable_condExp\n  have heq : âˆ€ n, âˆ€áµ x âˆ‚Î¼, (Î¼[Î¼[g|â¨† n, â„± n]|â„± n]) x = (Î¼[g|â„± n]) x := fun n =>\n    condExp_condExp_of_le (le_iSup _ n) (iSup_le fun n => â„±.le n)\n  refine ht.congr fun n => eLpNorm_congr_ae ?_\n  filter_upwards [heq n] with x hxeq\n  simp only [hxeq, Pi.sub_apply]\n\n"}
{"name":"MeasureTheory.tendsto_eLpNorm_condexp","module":"Mathlib.Probability.Martingale.Convergence","initialProofState":"Î© : Type u_1\nm0 : MeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\nâ„± : MeasureTheory.Filtration Nat m0\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\ng : Î© â†’ Real\nâŠ¢ Filter.Tendsto (fun n => MeasureTheory.eLpNorm (HSub.hSub (MeasureTheory.condExp (â†‘â„± n) Î¼ g) (MeasureTheory.condExp (iSup fun n => â†‘â„± n) Î¼ g)) 1 Î¼) Filter.atTop (nhds 0)","decl":"@[deprecated (since := \"2025-01-21\")] alias tendsto_eLpNorm_condexp := tendsto_eLpNorm_condExp\n\n"}
