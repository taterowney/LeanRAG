{"name":"countable_iff_exists_injective","module":"Mathlib.Data.Countable.Defs","initialProofState":"α : Sort u\n⊢ Iff (Countable α) (Exists fun f => Function.Injective f)","decl":"/-- A type `α` is countable if there exists an injective map `α → ℕ`. -/\n@[mk_iff countable_iff_exists_injective]\nclass Countable (α : Sort u) : Prop where\n  /-- A type `α` is countable if there exists an injective map `α → ℕ`. -/\n  exists_injective_nat' : ∃ f : α → ℕ, Injective f\n\n"}
{"name":"Countable.exists_injective_nat'","module":"Mathlib.Data.Countable.Defs","initialProofState":"α : Sort u\nself : Countable α\n⊢ Exists fun f => Function.Injective f","decl":"/-- A type `α` is countable if there exists an injective map `α → ℕ`. -/\n@[mk_iff countable_iff_exists_injective]\nclass Countable (α : Sort u) : Prop where\n  /-- A type `α` is countable if there exists an injective map `α → ℕ`. -/\n  exists_injective_nat' : ∃ f : α → ℕ, Injective f\n\n"}
{"name":"Countable.exists_injective_nat","module":"Mathlib.Data.Countable.Defs","initialProofState":"α : Sort u\ninst✝ : Countable α\n⊢ Exists fun f => Function.Injective f","decl":"lemma Countable.exists_injective_nat (α : Sort u) [Countable α] : ∃ f : α → ℕ, Injective f :=\n  Countable.exists_injective_nat'\n\n"}
{"name":"instCountableNat","module":"Mathlib.Data.Countable.Defs","initialProofState":"⊢ Countable Nat","decl":"instance : Countable ℕ :=\n  ⟨⟨id, injective_id⟩⟩\n\n"}
{"name":"Function.Injective.countable","module":"Mathlib.Data.Countable.Defs","initialProofState":"α : Sort u\nβ : Sort v\ninst✝ : Countable β\nf : α → β\nhf : Function.Injective f\n⊢ Countable α","decl":"protected theorem Function.Injective.countable [Countable β] {f : α → β} (hf : Injective f) :\n    Countable α :=\n  let ⟨g, hg⟩ := exists_injective_nat β\n  ⟨⟨g ∘ f, hg.comp hf⟩⟩\n\n"}
{"name":"Function.Surjective.countable","module":"Mathlib.Data.Countable.Defs","initialProofState":"α : Sort u\nβ : Sort v\ninst✝ : Countable α\nf : α → β\nhf : Function.Surjective f\n⊢ Countable β","decl":"protected theorem Function.Surjective.countable [Countable α] {f : α → β} (hf : Surjective f) :\n    Countable β :=\n  (injective_surjInv hf).countable\n\n"}
{"name":"exists_surjective_nat","module":"Mathlib.Data.Countable.Defs","initialProofState":"α : Sort u\ninst✝¹ : Nonempty α\ninst✝ : Countable α\n⊢ Exists fun f => Function.Surjective f","decl":"theorem exists_surjective_nat (α : Sort u) [Nonempty α] [Countable α] : ∃ f : ℕ → α, Surjective f :=\n  let ⟨f, hf⟩ := exists_injective_nat α\n  ⟨invFun f, invFun_surjective hf⟩\n\n"}
{"name":"countable_iff_exists_surjective","module":"Mathlib.Data.Countable.Defs","initialProofState":"α : Sort u\ninst✝ : Nonempty α\n⊢ Iff (Countable α) (Exists fun f => Function.Surjective f)","decl":"theorem countable_iff_exists_surjective [Nonempty α] : Countable α ↔ ∃ f : ℕ → α, Surjective f :=\n  ⟨@exists_surjective_nat _ _, fun ⟨_, hf⟩ ↦ hf.countable⟩\n\n"}
{"name":"Countable.of_equiv","module":"Mathlib.Data.Countable.Defs","initialProofState":"β : Sort v\nα : Sort u_1\ninst✝ : Countable α\ne : Equiv α β\n⊢ Countable β","decl":"theorem Countable.of_equiv (α : Sort*) [Countable α] (e : α ≃ β) : Countable β :=\n  e.symm.injective.countable\n\n"}
{"name":"Equiv.countable_iff","module":"Mathlib.Data.Countable.Defs","initialProofState":"α : Sort u\nβ : Sort v\ne : Equiv α β\n⊢ Iff (Countable α) (Countable β)","decl":"theorem Equiv.countable_iff (e : α ≃ β) : Countable α ↔ Countable β :=\n  ⟨fun h => @Countable.of_equiv _ _ h e, fun h => @Countable.of_equiv _ _ h e.symm⟩\n\n"}
{"name":"instCountableULift","module":"Mathlib.Data.Countable.Defs","initialProofState":"β : Type v\ninst✝ : Countable β\n⊢ Countable (ULift.{u, v} β)","decl":"instance {β : Type v} [Countable β] : Countable (ULift.{u} β) :=\n  Countable.of_equiv _ Equiv.ulift.symm\n\n"}
{"name":"instCountablePLift","module":"Mathlib.Data.Countable.Defs","initialProofState":"α : Sort u\ninst✝ : Countable α\n⊢ Countable (PLift α)","decl":"instance [Countable α] : Countable (PLift α) :=\n  Equiv.plift.injective.countable\n\n"}
{"name":"Subsingleton.to_countable","module":"Mathlib.Data.Countable.Defs","initialProofState":"α : Sort u\ninst✝ : Subsingleton α\n⊢ Countable α","decl":"instance (priority := 100) Subsingleton.to_countable [Subsingleton α] : Countable α :=\n  ⟨⟨fun _ => 0, fun x y _ => Subsingleton.elim x y⟩⟩\n\n"}
{"name":"Subtype.countable","module":"Mathlib.Data.Countable.Defs","initialProofState":"α : Sort u\ninst✝ : Countable α\np : α → Prop\n⊢ Countable (Subtype fun x => p x)","decl":"instance (priority := 500) Subtype.countable [Countable α] {p : α → Prop} :\n    Countable { x // p x } :=\n  Subtype.val_injective.countable\n\n"}
{"name":"instCountableFin","module":"Mathlib.Data.Countable.Defs","initialProofState":"n : Nat\n⊢ Countable (Fin n)","decl":"instance {n : ℕ} : Countable (Fin n) :=\n  Function.Injective.countable (@Fin.eq_of_val_eq n)\n\n"}
{"name":"Finite.to_countable","module":"Mathlib.Data.Countable.Defs","initialProofState":"α : Sort u\ninst✝ : Finite α\n⊢ Countable α","decl":"instance (priority := 100) Finite.to_countable [Finite α] : Countable α :=\n  let ⟨_, ⟨e⟩⟩ := Finite.exists_equiv_fin α\n  Countable.of_equiv _ e.symm\n\n"}
{"name":"instCountablePUnit","module":"Mathlib.Data.Countable.Defs","initialProofState":"⊢ Countable PUnit.{u}","decl":"instance : Countable PUnit.{u} :=\n  Subsingleton.to_countable\n\n"}
{"name":"Prop.countable","module":"Mathlib.Data.Countable.Defs","initialProofState":"p : Prop\n⊢ Countable p","decl":"instance (priority := 100) Prop.countable (p : Prop) : Countable p :=\n  Subsingleton.to_countable\n\n"}
{"name":"Bool.countable","module":"Mathlib.Data.Countable.Defs","initialProofState":"⊢ Countable Bool","decl":"instance Bool.countable : Countable Bool :=\n  ⟨⟨fun b => cond b 0 1, Bool.injective_iff.2 Nat.one_ne_zero⟩⟩\n\n"}
{"name":"Prop.countable'","module":"Mathlib.Data.Countable.Defs","initialProofState":"⊢ Countable Prop","decl":"instance Prop.countable' : Countable Prop :=\n  Countable.of_equiv Bool Equiv.propEquivBool.symm\n\n"}
{"name":"Quotient.countable","module":"Mathlib.Data.Countable.Defs","initialProofState":"α : Sort u\ninst✝ : Countable α\nr : α → α → Prop\n⊢ Countable (Quot r)","decl":"instance (priority := 500) Quotient.countable [Countable α] {r : α → α → Prop} :\n    Countable (Quot r) :=\n  Quot.mk_surjective.countable\n\n"}
{"name":"instCountableQuotient","module":"Mathlib.Data.Countable.Defs","initialProofState":"α : Sort u\ninst✝ : Countable α\ns : Setoid α\n⊢ Countable (Quotient s)","decl":"instance (priority := 500) [Countable α] {s : Setoid α} : Countable (Quotient s) :=\n  (inferInstance : Countable (@Quot α _))\n\n"}
{"name":"Uncountable.not_countable","module":"Mathlib.Data.Countable.Defs","initialProofState":"α : Sort u_1\nself : Uncountable α\n⊢ Not (Countable α)","decl":"/-- A type `α` is uncountable if it is not countable. -/\n@[mk_iff uncountable_iff_not_countable]\nclass Uncountable (α : Sort*) : Prop where\n  /-- A type `α` is uncountable if it is not countable. -/\n  not_countable : ¬Countable α\n\n"}
{"name":"uncountable_iff_not_countable","module":"Mathlib.Data.Countable.Defs","initialProofState":"α : Sort u_1\n⊢ Iff (Uncountable α) (Not (Countable α))","decl":"/-- A type `α` is uncountable if it is not countable. -/\n@[mk_iff uncountable_iff_not_countable]\nclass Uncountable (α : Sort*) : Prop where\n  /-- A type `α` is uncountable if it is not countable. -/\n  not_countable : ¬Countable α\n\n"}
{"name":"not_uncountable_iff","module":"Mathlib.Data.Countable.Defs","initialProofState":"α : Sort u\n⊢ Iff (Not (Uncountable α)) (Countable α)","decl":"lemma not_uncountable_iff : ¬Uncountable α ↔ Countable α := by\n  rw [uncountable_iff_not_countable, not_not]\n\n"}
{"name":"not_countable_iff","module":"Mathlib.Data.Countable.Defs","initialProofState":"α : Sort u\n⊢ Iff (Not (Countable α)) (Uncountable α)","decl":"lemma not_countable_iff : ¬Countable α ↔ Uncountable α := (uncountable_iff_not_countable α).symm\n\n"}
{"name":"not_uncountable","module":"Mathlib.Data.Countable.Defs","initialProofState":"α : Sort u\ninst✝ : Countable α\n⊢ Not (Uncountable α)","decl":"@[simp]\nlemma not_uncountable [Countable α] : ¬Uncountable α := not_uncountable_iff.2 ‹_›\n\n"}
{"name":"not_countable","module":"Mathlib.Data.Countable.Defs","initialProofState":"α : Sort u\ninst✝ : Uncountable α\n⊢ Not (Countable α)","decl":"@[simp]\nlemma not_countable [Uncountable α] : ¬Countable α := Uncountable.not_countable\n\n"}
{"name":"Function.Injective.uncountable","module":"Mathlib.Data.Countable.Defs","initialProofState":"α : Sort u\nβ : Sort v\ninst✝ : Uncountable α\nf : α → β\nhf : Function.Injective f\n⊢ Uncountable β","decl":"protected theorem Function.Injective.uncountable [Uncountable α] {f : α → β} (hf : Injective f) :\n    Uncountable β :=\n  ⟨fun _ ↦ not_countable hf.countable⟩\n\n"}
{"name":"Function.Surjective.uncountable","module":"Mathlib.Data.Countable.Defs","initialProofState":"α : Sort u\nβ : Sort v\ninst✝ : Uncountable β\nf : α → β\nhf : Function.Surjective f\n⊢ Uncountable α","decl":"protected theorem Function.Surjective.uncountable [Uncountable β] {f : α → β} (hf : Surjective f) :\n    Uncountable α := (injective_surjInv hf).uncountable\n\n"}
{"name":"not_injective_uncountable_countable","module":"Mathlib.Data.Countable.Defs","initialProofState":"α : Sort u\nβ : Sort v\ninst✝¹ : Uncountable α\ninst✝ : Countable β\nf : α → β\n⊢ Not (Function.Injective f)","decl":"lemma not_injective_uncountable_countable [Uncountable α] [Countable β] (f : α → β) :\n    ¬Injective f := fun hf ↦ not_countable hf.countable\n\n"}
{"name":"not_surjective_countable_uncountable","module":"Mathlib.Data.Countable.Defs","initialProofState":"α : Sort u\nβ : Sort v\ninst✝¹ : Countable α\ninst✝ : Uncountable β\nf : α → β\n⊢ Not (Function.Surjective f)","decl":"lemma not_surjective_countable_uncountable [Countable α] [Uncountable β] (f : α → β) :\n    ¬Surjective f := fun hf ↦\n  not_countable hf.countable\n\n"}
{"name":"uncountable_iff_forall_not_surjective","module":"Mathlib.Data.Countable.Defs","initialProofState":"α : Sort u\ninst✝ : Nonempty α\n⊢ Iff (Uncountable α) (∀ (f : Nat → α), Not (Function.Surjective f))","decl":"theorem uncountable_iff_forall_not_surjective [Nonempty α] :\n    Uncountable α ↔ ∀ f : ℕ → α, ¬Surjective f := by\n  rw [← not_countable_iff, countable_iff_exists_surjective, not_exists]\n\n"}
{"name":"Uncountable.of_equiv","module":"Mathlib.Data.Countable.Defs","initialProofState":"β : Sort v\nα : Sort u_1\ninst✝ : Uncountable α\ne : Equiv α β\n⊢ Uncountable β","decl":"theorem Uncountable.of_equiv (α : Sort*) [Uncountable α] (e : α ≃ β) : Uncountable β :=\n  e.injective.uncountable\n\n"}
{"name":"Equiv.uncountable_iff","module":"Mathlib.Data.Countable.Defs","initialProofState":"α : Sort u\nβ : Sort v\ne : Equiv α β\n⊢ Iff (Uncountable α) (Uncountable β)","decl":"theorem Equiv.uncountable_iff (e : α ≃ β) : Uncountable α ↔ Uncountable β :=\n  ⟨fun h => @Uncountable.of_equiv _ _ h e, fun h => @Uncountable.of_equiv _ _ h e.symm⟩\n\n"}
{"name":"instUncountableULift","module":"Mathlib.Data.Countable.Defs","initialProofState":"β : Type v\ninst✝ : Uncountable β\n⊢ Uncountable (ULift.{u, v} β)","decl":"instance {β : Type v} [Uncountable β] : Uncountable (ULift.{u} β) :=\n  .of_equiv _ Equiv.ulift.symm\n\n"}
{"name":"instUncountablePLift","module":"Mathlib.Data.Countable.Defs","initialProofState":"α : Sort u\ninst✝ : Uncountable α\n⊢ Uncountable (PLift α)","decl":"instance [Uncountable α] : Uncountable (PLift α) :=\n  .of_equiv _ Equiv.plift.symm\n\n"}
{"name":"instInfiniteOfUncountable","module":"Mathlib.Data.Countable.Defs","initialProofState":"α : Sort u\ninst✝ : Uncountable α\n⊢ Infinite α","decl":"instance (priority := 100) [Uncountable α] : Infinite α :=\n  ⟨fun _ ↦ not_countable (α := α) inferInstance⟩\n"}
