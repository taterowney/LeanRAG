{"name":"PrincipalSeg.cocone_ι_app","module":"Mathlib.CategoryTheory.Limits.Shapes.Preorder.PrincipalSeg","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : PartialOrder α\ninst✝¹ : PartialOrder β\nf : PrincipalSeg (fun x1 x2 => LT.lt x1 x2) fun x1 x2 => LT.lt x1 x2\nC : Type u_3\ninst✝ : CategoryTheory.Category.{u_4, u_3} C\nF : CategoryTheory.Functor β C\ni : α\n⊢ Eq ((f.cocone F).ι.app i) (F.map (CategoryTheory.homOfLE ⋯))","decl":"/-- When `f : α <i β` and a functor `F : β ⥤ C`, this is the cocone\nfor `f.monotone.functor ⋙ F : α ⥤ C` whose point if `F.obj f.top`. -/\n@[simps]\ndef PrincipalSeg.cocone {α β : Type*} [PartialOrder α] [PartialOrder β]\n  (f : α <i β) {C : Type*} [Category C] (F : β ⥤ C) :\n    Cocone (f.monotone.functor ⋙ F) where\n  pt := F.obj f.top\n  ι :=\n    { app i := F.map (homOfLE (f.lt_top i).le)\n      naturality i j f := by\n        dsimp\n        rw [← F.map_comp, comp_id]\n        rfl }\n"}
{"name":"PrincipalSeg.cocone_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Preorder.PrincipalSeg","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : PartialOrder α\ninst✝¹ : PartialOrder β\nf : PrincipalSeg (fun x1 x2 => LT.lt x1 x2) fun x1 x2 => LT.lt x1 x2\nC : Type u_3\ninst✝ : CategoryTheory.Category.{u_4, u_3} C\nF : CategoryTheory.Functor β C\n⊢ Eq (f.cocone F).pt (F.obj f.top)","decl":"/-- When `f : α <i β` and a functor `F : β ⥤ C`, this is the cocone\nfor `f.monotone.functor ⋙ F : α ⥤ C` whose point if `F.obj f.top`. -/\n@[simps]\ndef PrincipalSeg.cocone {α β : Type*} [PartialOrder α] [PartialOrder β]\n  (f : α <i β) {C : Type*} [Category C] (F : β ⥤ C) :\n    Cocone (f.monotone.functor ⋙ F) where\n  pt := F.obj f.top\n  ι :=\n    { app i := F.map (homOfLE (f.lt_top i).le)\n      naturality i j f := by\n        dsimp\n        rw [← F.map_comp, comp_id]\n        rfl }\n"}
