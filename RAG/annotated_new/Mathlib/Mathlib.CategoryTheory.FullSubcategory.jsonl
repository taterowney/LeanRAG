{"name":"CategoryTheory.InducedCategory.isoMk_hom","module":"Mathlib.CategoryTheory.FullSubcategory","initialProofState":"C : Type uâ‚\nD : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{v, uâ‚‚} D\nF : C â†’ D\nX Y : CategoryTheory.InducedCategory D F\nf : CategoryTheory.Iso (F X) (F Y)\nâŠ¢ Eq (CategoryTheory.InducedCategory.isoMk f).hom f.hom","decl":"variable {F} in\n/-- Construct an isomorphism in the induced category\nfrom an isomorphism in the original category. -/\n@[simps] def InducedCategory.isoMk {X Y : InducedCategory D F} (f : F X â‰… F Y) : X â‰… Y where\n  hom := f.hom\n  inv := f.inv\n  hom_inv_id := f.hom_inv_id\n  inv_hom_id := f.inv_hom_id\n\n"}
{"name":"CategoryTheory.InducedCategory.isoMk_inv","module":"Mathlib.CategoryTheory.FullSubcategory","initialProofState":"C : Type uâ‚\nD : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{v, uâ‚‚} D\nF : C â†’ D\nX Y : CategoryTheory.InducedCategory D F\nf : CategoryTheory.Iso (F X) (F Y)\nâŠ¢ Eq (CategoryTheory.InducedCategory.isoMk f).inv f.inv","decl":"variable {F} in\n/-- Construct an isomorphism in the induced category\nfrom an isomorphism in the original category. -/\n@[simps] def InducedCategory.isoMk {X Y : InducedCategory D F} (f : F X â‰… F Y) : X â‰… Y where\n  hom := f.hom\n  inv := f.inv\n  hom_inv_id := f.hom_inv_id\n  inv_hom_id := f.inv_hom_id\n\n"}
{"name":"CategoryTheory.inducedFunctor_map","module":"Mathlib.CategoryTheory.FullSubcategory","initialProofState":"C : Type uâ‚\nD : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{v, uâ‚‚} D\nF : C â†’ D\nXâœ Yâœ : CategoryTheory.InducedCategory D F\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq ((CategoryTheory.inducedFunctor F).map f) f","decl":"/-- The forgetful functor from an induced category to the original category,\nforgetting the extra data.\n-/\n@[simps]\ndef inducedFunctor : InducedCategory D F â¥¤ D where\n  obj := F\n  map f := f\n\n"}
{"name":"CategoryTheory.inducedFunctor_obj","module":"Mathlib.CategoryTheory.FullSubcategory","initialProofState":"C : Type uâ‚\nD : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{v, uâ‚‚} D\nF : C â†’ D\naâœ : C\nâŠ¢ Eq ((CategoryTheory.inducedFunctor F).obj aâœ) (F aâœ)","decl":"/-- The forgetful functor from an induced category to the original category,\nforgetting the extra data.\n-/\n@[simps]\ndef inducedFunctor : InducedCategory D F â¥¤ D where\n  obj := F\n  map f := f\n\n"}
{"name":"CategoryTheory.InducedCategory.full","module":"Mathlib.CategoryTheory.FullSubcategory","initialProofState":"C : Type uâ‚\nD : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{v, uâ‚‚} D\nF : C â†’ D\nâŠ¢ (CategoryTheory.inducedFunctor F).Full","decl":"instance InducedCategory.full : (inducedFunctor F).Full :=\n  (fullyFaithfulInducedFunctor F).full\n\n"}
{"name":"CategoryTheory.InducedCategory.faithful","module":"Mathlib.CategoryTheory.FullSubcategory","initialProofState":"C : Type uâ‚\nD : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{v, uâ‚‚} D\nF : C â†’ D\nâŠ¢ (CategoryTheory.inducedFunctor F).Faithful","decl":"instance InducedCategory.faithful : (inducedFunctor F).Faithful :=\n  (fullyFaithfulInducedFunctor F).faithful\n\n"}
{"name":"CategoryTheory.FullSubcategory.ext_iff","module":"Mathlib.CategoryTheory.FullSubcategory","initialProofState":"C : Type uâ‚\nZ : C â†’ Prop\nx y : CategoryTheory.FullSubcategory Z\nâŠ¢ Iff (Eq x y) (Eq x.obj y.obj)","decl":"/--\nA subtype-like structure for full subcategories. Morphisms just ignore the property. We don't use\nactual subtypes since the simp-normal form `â†‘X` of `X.val` does not work well for full\nsubcategories. -/\n@[ext, stacks 001D \"We do not define 'strictly full' subcategories.\"]\nstructure FullSubcategory where\n  /-- The category of which this is a full subcategory -/\n  obj : C\n  /-- The predicate satisfied by all objects in this subcategory -/\n  property : Z obj\n\n"}
{"name":"CategoryTheory.FullSubcategory.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.FullSubcategory","initialProofState":"C : Type uâ‚\nZ : C â†’ Prop\ninstâœÂ¹ : SizeOf C\ninstâœ : (a : C) â†’ SizeOf (Z a)\nobj : C\nproperty : Z obj\nâŠ¢ Eq (SizeOf.sizeOf { obj := obj, property := property }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf obj)) (SizeOf.sizeOf property))","decl":"/--\nA subtype-like structure for full subcategories. Morphisms just ignore the property. We don't use\nactual subtypes since the simp-normal form `â†‘X` of `X.val` does not work well for full\nsubcategories. -/\n@[ext, stacks 001D \"We do not define 'strictly full' subcategories.\"]\nstructure FullSubcategory where\n  /-- The category of which this is a full subcategory -/\n  obj : C\n  /-- The predicate satisfied by all objects in this subcategory -/\n  property : Z obj\n\n"}
{"name":"CategoryTheory.FullSubcategory.ext","module":"Mathlib.CategoryTheory.FullSubcategory","initialProofState":"C : Type uâ‚\nZ : C â†’ Prop\nx y : CategoryTheory.FullSubcategory Z\nobj : Eq x.obj y.obj\nâŠ¢ Eq x y","decl":"/--\nA subtype-like structure for full subcategories. Morphisms just ignore the property. We don't use\nactual subtypes since the simp-normal form `â†‘X` of `X.val` does not work well for full\nsubcategories. -/\n@[ext, stacks 001D \"We do not define 'strictly full' subcategories.\"]\nstructure FullSubcategory where\n  /-- The category of which this is a full subcategory -/\n  obj : C\n  /-- The predicate satisfied by all objects in this subcategory -/\n  property : Z obj\n\n"}
{"name":"CategoryTheory.FullSubcategory.mk.inj","module":"Mathlib.CategoryTheory.FullSubcategory","initialProofState":"C : Type uâ‚\nZ : C â†’ Prop\nobjâœ : C\npropertyâœ : Z objâœ\nobj : C\nproperty : Z obj\nxâœ : Eq { obj := objâœ, property := propertyâœ } { obj := obj, property := property }\nâŠ¢ Eq objâœ obj","decl":"/--\nA subtype-like structure for full subcategories. Morphisms just ignore the property. We don't use\nactual subtypes since the simp-normal form `â†‘X` of `X.val` does not work well for full\nsubcategories. -/\n@[ext, stacks 001D \"We do not define 'strictly full' subcategories.\"]\nstructure FullSubcategory where\n  /-- The category of which this is a full subcategory -/\n  obj : C\n  /-- The predicate satisfied by all objects in this subcategory -/\n  property : Z obj\n\n"}
{"name":"CategoryTheory.FullSubcategory.mk.injEq","module":"Mathlib.CategoryTheory.FullSubcategory","initialProofState":"C : Type uâ‚\nZ : C â†’ Prop\nobjâœ : C\npropertyâœ : Z objâœ\nobj : C\nproperty : Z obj\nâŠ¢ Eq (Eq { obj := objâœ, property := propertyâœ } { obj := obj, property := property }) (Eq objâœ obj)","decl":"/--\nA subtype-like structure for full subcategories. Morphisms just ignore the property. We don't use\nactual subtypes since the simp-normal form `â†‘X` of `X.val` does not work well for full\nsubcategories. -/\n@[ext, stacks 001D \"We do not define 'strictly full' subcategories.\"]\nstructure FullSubcategory where\n  /-- The category of which this is a full subcategory -/\n  obj : C\n  /-- The predicate satisfied by all objects in this subcategory -/\n  property : Z obj\n\n"}
{"name":"CategoryTheory.FullSubcategory.property","module":"Mathlib.CategoryTheory.FullSubcategory","initialProofState":"C : Type uâ‚\nZ : C â†’ Prop\nself : CategoryTheory.FullSubcategory Z\nâŠ¢ Z self.obj","decl":"/--\nA subtype-like structure for full subcategories. Morphisms just ignore the property. We don't use\nactual subtypes since the simp-normal form `â†‘X` of `X.val` does not work well for full\nsubcategories. -/\n@[ext, stacks 001D \"We do not define 'strictly full' subcategories.\"]\nstructure FullSubcategory where\n  /-- The category of which this is a full subcategory -/\n  obj : C\n  /-- The predicate satisfied by all objects in this subcategory -/\n  property : Z obj\n\n"}
{"name":"CategoryTheory.FullSubcategory.id_def","module":"Mathlib.CategoryTheory.FullSubcategory","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{v, uâ‚} C\nZ : C â†’ Prop\nX : CategoryTheory.FullSubcategory Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.id X) (CategoryTheory.CategoryStruct.id X.obj)","decl":"lemma FullSubcategory.id_def (X : FullSubcategory Z) : ðŸ™ X = ðŸ™ X.obj := rfl\n\n"}
{"name":"CategoryTheory.FullSubcategory.comp_def","module":"Mathlib.CategoryTheory.FullSubcategory","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{v, uâ‚} C\nZâœ : C â†’ Prop\nX Y Z : CategoryTheory.FullSubcategory Zâœ\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp f g)","decl":"lemma FullSubcategory.comp_def {X Y Z : FullSubcategory Z} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) :\n    f â‰« g = (f â‰« g : X.obj âŸ¶ Z.obj) := rfl\n\n"}
{"name":"CategoryTheory.fullSubcategoryInclusion.obj","module":"Mathlib.CategoryTheory.FullSubcategory","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{v, uâ‚} C\nZ : C â†’ Prop\nX : CategoryTheory.FullSubcategory Z\nâŠ¢ Eq ((CategoryTheory.fullSubcategoryInclusion Z).obj X) X.obj","decl":"@[simp]\ntheorem fullSubcategoryInclusion.obj {X} : (fullSubcategoryInclusion Z).obj X = X.obj :=\n  rfl\n\n"}
{"name":"CategoryTheory.fullSubcategoryInclusion.map","module":"Mathlib.CategoryTheory.FullSubcategory","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{v, uâ‚} C\nZ : C â†’ Prop\nX Y : CategoryTheory.FullSubcategory Z\nf : Quiver.Hom X Y\nâŠ¢ Eq ((CategoryTheory.fullSubcategoryInclusion Z).map f) f","decl":"@[simp]\ntheorem fullSubcategoryInclusion.map {X Y} {f : X âŸ¶ Y} : (fullSubcategoryInclusion Z).map f = f :=\n  rfl\n\n"}
{"name":"CategoryTheory.FullSubcategory.full","module":"Mathlib.CategoryTheory.FullSubcategory","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{v, uâ‚} C\nZ : C â†’ Prop\nâŠ¢ (CategoryTheory.fullSubcategoryInclusion Z).Full","decl":"instance FullSubcategory.full : (fullSubcategoryInclusion Z).Full :=\n  (fullyFaithfulFullSubcategoryInclusion _).full\n\n"}
{"name":"CategoryTheory.FullSubcategory.faithful","module":"Mathlib.CategoryTheory.FullSubcategory","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{v, uâ‚} C\nZ : C â†’ Prop\nâŠ¢ (CategoryTheory.fullSubcategoryInclusion Z).Faithful","decl":"instance FullSubcategory.faithful : (fullSubcategoryInclusion Z).Faithful :=\n  (fullyFaithfulFullSubcategoryInclusion _).faithful\n\n"}
{"name":"CategoryTheory.FullSubcategory.map_obj_obj","module":"Mathlib.CategoryTheory.FullSubcategory","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{v, uâ‚} C\nZ Z' : C â†’ Prop\nh : âˆ€ â¦ƒX : Câ¦„, Z X â†’ Z' X\nX : CategoryTheory.FullSubcategory Z\nâŠ¢ Eq ((CategoryTheory.FullSubcategory.map h).obj X).obj X.obj","decl":"/-- An implication of predicates `Z â†’ Z'` induces a functor between full subcategories. -/\n@[simps]\ndef FullSubcategory.map (h : âˆ€ â¦ƒXâ¦„, Z X â†’ Z' X) : FullSubcategory Z â¥¤ FullSubcategory Z' where\n  obj X := âŸ¨X.1, h X.2âŸ©\n  map f := f\n\n"}
{"name":"CategoryTheory.FullSubcategory.map_map","module":"Mathlib.CategoryTheory.FullSubcategory","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{v, uâ‚} C\nZ Z' : C â†’ Prop\nh : âˆ€ â¦ƒX : Câ¦„, Z X â†’ Z' X\nXâœ Yâœ : CategoryTheory.FullSubcategory Z\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq ((CategoryTheory.FullSubcategory.map h).map f) f","decl":"/-- An implication of predicates `Z â†’ Z'` induces a functor between full subcategories. -/\n@[simps]\ndef FullSubcategory.map (h : âˆ€ â¦ƒXâ¦„, Z X â†’ Z' X) : FullSubcategory Z â¥¤ FullSubcategory Z' where\n  obj X := âŸ¨X.1, h X.2âŸ©\n  map f := f\n\n"}
{"name":"CategoryTheory.FullSubcategory.full_map","module":"Mathlib.CategoryTheory.FullSubcategory","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{v, uâ‚} C\nZ Z' : C â†’ Prop\nh : âˆ€ â¦ƒX : Câ¦„, Z X â†’ Z' X\nâŠ¢ (CategoryTheory.FullSubcategory.map h).Full","decl":"instance FullSubcategory.full_map (h : âˆ€ â¦ƒXâ¦„, Z X â†’ Z' X) :\n  (FullSubcategory.map h).Full where map_surjective f := âŸ¨f, rflâŸ©\n\n"}
{"name":"CategoryTheory.FullSubcategory.faithful_map","module":"Mathlib.CategoryTheory.FullSubcategory","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{v, uâ‚} C\nZ Z' : C â†’ Prop\nh : âˆ€ â¦ƒX : Câ¦„, Z X â†’ Z' X\nâŠ¢ (CategoryTheory.FullSubcategory.map h).Faithful","decl":"instance FullSubcategory.faithful_map (h : âˆ€ â¦ƒXâ¦„, Z X â†’ Z' X) :\n  (FullSubcategory.map h).Faithful where\n\n"}
{"name":"CategoryTheory.FullSubcategory.map_inclusion","module":"Mathlib.CategoryTheory.FullSubcategory","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{v, uâ‚} C\nZ Z' : C â†’ Prop\nh : âˆ€ â¦ƒX : Câ¦„, Z X â†’ Z' X\nâŠ¢ Eq ((CategoryTheory.FullSubcategory.map h).comp (CategoryTheory.fullSubcategoryInclusion Z')) (CategoryTheory.fullSubcategoryInclusion Z)","decl":"@[simp]\ntheorem FullSubcategory.map_inclusion (h : âˆ€ â¦ƒXâ¦„, Z X â†’ Z' X) :\n    FullSubcategory.map h â‹™ fullSubcategoryInclusion Z' = fullSubcategoryInclusion Z :=\n  rfl\n\n"}
{"name":"CategoryTheory.FullSubcategory.lift_map","module":"Mathlib.CategoryTheory.FullSubcategory","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{v, uâ‚} C\nD : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nP : D â†’ Prop\nF : CategoryTheory.Functor C D\nhF : âˆ€ (X : C), P (F.obj X)\nXâœ Yâœ : C\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq ((CategoryTheory.FullSubcategory.lift P F hF).map f) (F.map f)","decl":"/-- A functor which maps objects to objects satisfying a certain property induces a lift through\n    the full subcategory of objects satisfying that property. -/\n@[simps]\ndef FullSubcategory.lift (F : C â¥¤ D) (hF : âˆ€ X, P (F.obj X)) : C â¥¤ FullSubcategory P where\n  obj X := âŸ¨F.obj X, hF XâŸ©\n  map f := F.map f\n\n"}
{"name":"CategoryTheory.FullSubcategory.lift_obj_obj","module":"Mathlib.CategoryTheory.FullSubcategory","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{v, uâ‚} C\nD : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nP : D â†’ Prop\nF : CategoryTheory.Functor C D\nhF : âˆ€ (X : C), P (F.obj X)\nX : C\nâŠ¢ Eq ((CategoryTheory.FullSubcategory.lift P F hF).obj X).obj (F.obj X)","decl":"/-- A functor which maps objects to objects satisfying a certain property induces a lift through\n    the full subcategory of objects satisfying that property. -/\n@[simps]\ndef FullSubcategory.lift (F : C â¥¤ D) (hF : âˆ€ X, P (F.obj X)) : C â¥¤ FullSubcategory P where\n  obj X := âŸ¨F.obj X, hF XâŸ©\n  map f := F.map f\n\n"}
{"name":"CategoryTheory.FullSubcategory.lift_comp_inclusion_eq","module":"Mathlib.CategoryTheory.FullSubcategory","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{v, uâ‚} C\nD : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nP : D â†’ Prop\nF : CategoryTheory.Functor C D\nhF : âˆ€ (X : C), P (F.obj X)\nâŠ¢ Eq ((CategoryTheory.FullSubcategory.lift P F hF).comp (CategoryTheory.fullSubcategoryInclusion P)) F","decl":"@[simp]\ntheorem FullSubcategory.lift_comp_inclusion_eq (F : C â¥¤ D) (hF : âˆ€ X, P (F.obj X)) :\n    FullSubcategory.lift P F hF â‹™ fullSubcategoryInclusion P = F :=\n  rfl\n\n"}
{"name":"CategoryTheory.fullSubcategoryInclusion_obj_lift_obj","module":"Mathlib.CategoryTheory.FullSubcategory","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{v, uâ‚} C\nD : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nP : D â†’ Prop\nF : CategoryTheory.Functor C D\nhF : âˆ€ (X : C), P (F.obj X)\nX : C\nâŠ¢ Eq ((CategoryTheory.fullSubcategoryInclusion P).obj ((CategoryTheory.FullSubcategory.lift P F hF).obj X)) (F.obj X)","decl":"@[simp]\ntheorem fullSubcategoryInclusion_obj_lift_obj (F : C â¥¤ D) (hF : âˆ€ X, P (F.obj X)) {X : C} :\n    (fullSubcategoryInclusion P).obj ((FullSubcategory.lift P F hF).obj X) = F.obj X :=\n  rfl\n\n"}
{"name":"CategoryTheory.fullSubcategoryInclusion_map_lift_map","module":"Mathlib.CategoryTheory.FullSubcategory","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{v, uâ‚} C\nD : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nP : D â†’ Prop\nF : CategoryTheory.Functor C D\nhF : âˆ€ (X : C), P (F.obj X)\nX Y : C\nf : Quiver.Hom X Y\nâŠ¢ Eq ((CategoryTheory.fullSubcategoryInclusion P).map ((CategoryTheory.FullSubcategory.lift P F hF).map f)) (F.map f)","decl":"@[simp]\ntheorem fullSubcategoryInclusion_map_lift_map (F : C â¥¤ D) (hF : âˆ€ X, P (F.obj X)) {X Y : C}\n    (f : X âŸ¶ Y) :\n    (fullSubcategoryInclusion P).map ((FullSubcategory.lift P F hF).map f) = F.map f :=\n  rfl\n\n"}
{"name":"CategoryTheory.instFaithfulFullSubcategoryLift","module":"Mathlib.CategoryTheory.FullSubcategory","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{v, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nP : D â†’ Prop\nF : CategoryTheory.Functor C D\nhF : âˆ€ (X : C), P (F.obj X)\ninstâœ : F.Faithful\nâŠ¢ (CategoryTheory.FullSubcategory.lift P F hF).Faithful","decl":"instance (F : C â¥¤ D) (hF : âˆ€ X, P (F.obj X)) [F.Faithful] :\n    (FullSubcategory.lift P F hF).Faithful :=\n  Functor.Faithful.of_comp_iso (FullSubcategory.lift_comp_inclusion P F hF)\n\n"}
{"name":"CategoryTheory.instFullFullSubcategoryLift","module":"Mathlib.CategoryTheory.FullSubcategory","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{v, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nP : D â†’ Prop\nF : CategoryTheory.Functor C D\nhF : âˆ€ (X : C), P (F.obj X)\ninstâœ : F.Full\nâŠ¢ (CategoryTheory.FullSubcategory.lift P F hF).Full","decl":"instance (F : C â¥¤ D) (hF : âˆ€ X, P (F.obj X)) [F.Full] : (FullSubcategory.lift P F hF).Full :=\n  Functor.Full.of_comp_faithful_iso (FullSubcategory.lift_comp_inclusion P F hF)\n\n"}
{"name":"CategoryTheory.FullSubcategory.lift_comp_map","module":"Mathlib.CategoryTheory.FullSubcategory","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{v, uâ‚} C\nD : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nP Q : D â†’ Prop\nF : CategoryTheory.Functor C D\nhF : âˆ€ (X : C), P (F.obj X)\nh : âˆ€ â¦ƒX : Dâ¦„, P X â†’ Q X\nâŠ¢ Eq ((CategoryTheory.FullSubcategory.lift P F hF).comp (CategoryTheory.FullSubcategory.map h)) (CategoryTheory.FullSubcategory.lift Q F â‹¯)","decl":"@[simp]\ntheorem FullSubcategory.lift_comp_map (F : C â¥¤ D) (hF : âˆ€ X, P (F.obj X)) (h : âˆ€ â¦ƒXâ¦„, P X â†’ Q X) :\n    FullSubcategory.lift P F hF â‹™ FullSubcategory.map h =\n      FullSubcategory.lift Q F fun X => h (hF X) :=\n  rfl\n\n"}
