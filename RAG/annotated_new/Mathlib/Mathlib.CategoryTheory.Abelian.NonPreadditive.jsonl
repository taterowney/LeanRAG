{"name":"CategoryTheory.NonPreadditiveAbelian.has_kernels","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.NonPreadditiveAbelian C\n⊢ CategoryTheory.Limits.HasKernels C","decl":"/-- We call a category `NonPreadditiveAbelian` if it has a zero object, kernels, cokernels, binary\n    products and coproducts, and every monomorphism and every epimorphism is normal. -/\nclass NonPreadditiveAbelian extends HasZeroMorphisms C, IsNormalMonoCategory C,\n    IsNormalEpiCategory C where\n  [has_zero_object : HasZeroObject C]\n  [has_kernels : HasKernels C]\n  [has_cokernels : HasCokernels C]\n  [has_finite_products : HasFiniteProducts C]\n  [has_finite_coproducts : HasFiniteCoproducts C]\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.has_zero_object","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.NonPreadditiveAbelian C\n⊢ CategoryTheory.Limits.HasZeroObject C","decl":"/-- We call a category `NonPreadditiveAbelian` if it has a zero object, kernels, cokernels, binary\n    products and coproducts, and every monomorphism and every epimorphism is normal. -/\nclass NonPreadditiveAbelian extends HasZeroMorphisms C, IsNormalMonoCategory C,\n    IsNormalEpiCategory C where\n  [has_zero_object : HasZeroObject C]\n  [has_kernels : HasKernels C]\n  [has_cokernels : HasCokernels C]\n  [has_finite_products : HasFiniteProducts C]\n  [has_finite_coproducts : HasFiniteCoproducts C]\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.has_finite_coproducts","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.NonPreadditiveAbelian C\n⊢ CategoryTheory.Limits.HasFiniteCoproducts C","decl":"/-- We call a category `NonPreadditiveAbelian` if it has a zero object, kernels, cokernels, binary\n    products and coproducts, and every monomorphism and every epimorphism is normal. -/\nclass NonPreadditiveAbelian extends HasZeroMorphisms C, IsNormalMonoCategory C,\n    IsNormalEpiCategory C where\n  [has_zero_object : HasZeroObject C]\n  [has_kernels : HasKernels C]\n  [has_cokernels : HasCokernels C]\n  [has_finite_products : HasFiniteProducts C]\n  [has_finite_coproducts : HasFiniteCoproducts C]\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.has_finite_products","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.NonPreadditiveAbelian C\n⊢ CategoryTheory.Limits.HasFiniteProducts C","decl":"/-- We call a category `NonPreadditiveAbelian` if it has a zero object, kernels, cokernels, binary\n    products and coproducts, and every monomorphism and every epimorphism is normal. -/\nclass NonPreadditiveAbelian extends HasZeroMorphisms C, IsNormalMonoCategory C,\n    IsNormalEpiCategory C where\n  [has_zero_object : HasZeroObject C]\n  [has_kernels : HasKernels C]\n  [has_cokernels : HasCokernels C]\n  [has_finite_products : HasFiniteProducts C]\n  [has_finite_coproducts : HasFiniteCoproducts C]\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.has_cokernels","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.NonPreadditiveAbelian C\n⊢ CategoryTheory.Limits.HasCokernels C","decl":"/-- We call a category `NonPreadditiveAbelian` if it has a zero object, kernels, cokernels, binary\n    products and coproducts, and every monomorphism and every epimorphism is normal. -/\nclass NonPreadditiveAbelian extends HasZeroMorphisms C, IsNormalMonoCategory C,\n    IsNormalEpiCategory C where\n  [has_zero_object : HasZeroObject C]\n  [has_kernels : HasKernels C]\n  [has_cokernels : HasCokernels C]\n  [has_finite_products : HasFiniteProducts C]\n  [has_finite_coproducts : HasFiniteCoproducts C]\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.toIsNormalMonoCategory","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.NonPreadditiveAbelian C\n⊢ CategoryTheory.IsNormalMonoCategory C","decl":"/-- We call a category `NonPreadditiveAbelian` if it has a zero object, kernels, cokernels, binary\n    products and coproducts, and every monomorphism and every epimorphism is normal. -/\nclass NonPreadditiveAbelian extends HasZeroMorphisms C, IsNormalMonoCategory C,\n    IsNormalEpiCategory C where\n  [has_zero_object : HasZeroObject C]\n  [has_kernels : HasKernels C]\n  [has_cokernels : HasCokernels C]\n  [has_finite_products : HasFiniteProducts C]\n  [has_finite_coproducts : HasFiniteCoproducts C]\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.toIsNormalEpiCategory","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.NonPreadditiveAbelian C\n⊢ CategoryTheory.IsNormalEpiCategory C","decl":"/-- We call a category `NonPreadditiveAbelian` if it has a zero object, kernels, cokernels, binary\n    products and coproducts, and every monomorphism and every epimorphism is normal. -/\nclass NonPreadditiveAbelian extends HasZeroMorphisms C, IsNormalMonoCategory C,\n    IsNormalEpiCategory C where\n  [has_zero_object : HasZeroObject C]\n  [has_kernels : HasKernels C]\n  [has_cokernels : HasCokernels C]\n  [has_finite_products : HasFiniteProducts C]\n  [has_finite_coproducts : HasFiniteCoproducts C]\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.instEpiFactorThruImage","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.NonPreadditiveAbelian C\nP Q : C\nf : Quiver.Hom P Q\n⊢ CategoryTheory.Epi (CategoryTheory.Abelian.factorThruImage f)","decl":"/-- The map `p : P ⟶ image f` is an epimorphism -/\ninstance : Epi (Abelian.factorThruImage f) :=\n  let I := Abelian.image f\n  let p := Abelian.factorThruImage f\n  let i := kernel.ι (cokernel.π f)\n  -- It will suffice to consider some g : I ⟶ R such that p ≫ g = 0 and show that g = 0.\n  NormalMonoCategory.epi_of_zero_cancel\n  _ fun R (g : I ⟶ R) (hpg : p ≫ g = 0) => by\n  -- Since C is abelian, u := ker g ≫ i is the kernel of some morphism h.\n  let u := kernel.ι g ≫ i\n  haveI hu := normalMonoOfMono u\n  let h := hu.g\n  -- By hypothesis, p factors through the kernel of g via some t.\n  obtain ⟨t, ht⟩ := kernel.lift' g p hpg\n  have fh : f ≫ h = 0 :=\n    calc\n      f ≫ h = (p ≫ i) ≫ h := (Abelian.image.fac f).symm ▸ rfl\n      _ = ((t ≫ kernel.ι g) ≫ i) ≫ h := ht ▸ rfl\n      _ = t ≫ u ≫ h := by simp only [u, Category.assoc]\n      _ = t ≫ 0 := hu.w ▸ rfl\n      _ = 0 := HasZeroMorphisms.comp_zero _ _\n  -- h factors through the cokernel of f via some l.\n  obtain ⟨l, hl⟩ := cokernel.desc' f h fh\n  have hih : i ≫ h = 0 :=\n    calc\n      i ≫ h = i ≫ cokernel.π f ≫ l := hl ▸ rfl\n      _ = 0 ≫ l := by rw [← Category.assoc, kernel.condition]\n      _ = 0 := zero_comp\n  -- i factors through u = ker h via some s.\n  obtain ⟨s, hs⟩ := NormalMono.lift' u i hih\n  have hs' : (s ≫ kernel.ι g) ≫ i = 𝟙 I ≫ i := by rw [Category.assoc, hs, Category.id_comp]\n  haveI : Epi (kernel.ι g) := epi_of_epi_fac ((cancel_mono _).1 hs')\n  -- ker g is an epimorphism, but ker g ≫ g = 0 = ker g ≫ 0, so g = 0 as required.\n  exact zero_of_epi_comp _ (kernel.condition g)\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.isIso_factorThruImage","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.NonPreadditiveAbelian C\nP Q : C\nf : Quiver.Hom P Q\ninst✝ : CategoryTheory.Mono f\n⊢ CategoryTheory.IsIso (CategoryTheory.Abelian.factorThruImage f)","decl":"instance isIso_factorThruImage [Mono f] : IsIso (Abelian.factorThruImage f) :=\n  isIso_of_mono_of_epi <| Abelian.factorThruImage f\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.instMonoFactorThruCoimage","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.NonPreadditiveAbelian C\nP Q : C\nf : Quiver.Hom P Q\n⊢ CategoryTheory.Mono (CategoryTheory.Abelian.factorThruCoimage f)","decl":"/-- The canonical morphism `i : coimage f ⟶ Q` is a monomorphism -/\ninstance : Mono (Abelian.factorThruCoimage f) :=\n  let I := Abelian.coimage f\n  let i := Abelian.factorThruCoimage f\n  let p := cokernel.π (kernel.ι f)\n  NormalEpiCategory.mono_of_cancel_zero _ fun R (g : R ⟶ I) (hgi : g ≫ i = 0) => by\n    -- Since C is abelian, u := p ≫ coker g is the cokernel of some morphism h.\n    let u := p ≫ cokernel.π g\n    haveI hu := normalEpiOfEpi u\n    let h := hu.g\n    -- By hypothesis, i factors through the cokernel of g via some t.\n    obtain ⟨t, ht⟩ := cokernel.desc' g i hgi\n    have hf : h ≫ f = 0 :=\n      calc\n        h ≫ f = h ≫ p ≫ i := (Abelian.coimage.fac f).symm ▸ rfl\n        _ = h ≫ p ≫ cokernel.π g ≫ t := ht ▸ rfl\n        _ = h ≫ u ≫ t := by simp only [u, Category.assoc]\n        _ = 0 ≫ t := by rw [← Category.assoc, hu.w]\n        _ = 0 := zero_comp\n    -- h factors through the kernel of f via some l.\n    obtain ⟨l, hl⟩ := kernel.lift' f h hf\n    have hhp : h ≫ p = 0 :=\n      calc\n        h ≫ p = (l ≫ kernel.ι f) ≫ p := hl ▸ rfl\n        _ = l ≫ 0 := by rw [Category.assoc, cokernel.condition]\n        _ = 0 := comp_zero\n    -- p factors through u = coker h via some s.\n    obtain ⟨s, hs⟩ := NormalEpi.desc' u p hhp\n    have hs' : p ≫ cokernel.π g ≫ s = p ≫ 𝟙 I := by rw [← Category.assoc, hs, Category.comp_id]\n    haveI : Mono (cokernel.π g) := mono_of_mono_fac ((cancel_epi _).1 hs')\n    -- coker g is a monomorphism, but g ≫ coker g = 0 = 0 ≫ coker g, so g = 0 as required.\n    exact zero_of_comp_mono _ (cokernel.condition g)\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.isIso_factorThruCoimage","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.NonPreadditiveAbelian C\nP Q : C\nf : Quiver.Hom P Q\ninst✝ : CategoryTheory.Epi f\n⊢ CategoryTheory.IsIso (CategoryTheory.Abelian.factorThruCoimage f)","decl":"instance isIso_factorThruCoimage [Epi f] : IsIso (Abelian.factorThruCoimage f) :=\n  isIso_of_mono_of_epi _\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.mono_Δ","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.NonPreadditiveAbelian C\nA : C\n⊢ CategoryTheory.Mono (CategoryTheory.Limits.diag A)","decl":"instance mono_Δ {A : C} : Mono (diag A) :=\n  mono_of_mono_fac <| prod.lift_fst _ _\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.mono_r","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.NonPreadditiveAbelian C\nA : C\n⊢ CategoryTheory.Mono (CategoryTheory.NonPreadditiveAbelian.r A)","decl":"instance mono_r {A : C} : Mono (r A) := by\n  let hl : IsLimit (KernelFork.ofι (diag A) (cokernel.condition (diag A))) :=\n    monoIsKernelOfCokernel _ (colimit.isColimit _)\n  apply NormalEpiCategory.mono_of_cancel_zero\n  intro Z x hx\n  have hxx : (x ≫ prod.lift (𝟙 A) (0 : A ⟶ A)) ≫ cokernel.π (diag A) = 0 := by\n    rw [Category.assoc, hx]\n  obtain ⟨y, hy⟩ := KernelFork.IsLimit.lift' hl _ hxx\n  rw [KernelFork.ι_ofι] at hy\n  have hyy : y = 0 := by\n    erw [← Category.comp_id y, ← Limits.prod.lift_snd (𝟙 A) (𝟙 A), ← Category.assoc, hy,\n      Category.assoc, prod.lift_snd, HasZeroMorphisms.comp_zero]\n  haveI : Mono (prod.lift (𝟙 A) (0 : A ⟶ A)) := mono_of_mono_fac (prod.lift_fst _ _)\n  apply (cancel_mono (prod.lift (𝟙 A) (0 : A ⟶ A))).1\n  rw [← hy, hyy, zero_comp, zero_comp]\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.epi_r","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.NonPreadditiveAbelian C\nA : C\n⊢ CategoryTheory.Epi (CategoryTheory.NonPreadditiveAbelian.r A)","decl":"instance epi_r {A : C} : Epi (r A) := by\n  have hlp : prod.lift (𝟙 A) (0 : A ⟶ A) ≫ Limits.prod.snd = 0 := prod.lift_snd _ _\n  let hp1 : IsLimit (KernelFork.ofι (prod.lift (𝟙 A) (0 : A ⟶ A)) hlp) := by\n    refine Fork.IsLimit.mk _ (fun s => Fork.ι s ≫ Limits.prod.fst) ?_ ?_\n    · intro s\n      apply Limits.prod.hom_ext <;> simp\n    · intro s m h\n      haveI : Mono (prod.lift (𝟙 A) (0 : A ⟶ A)) := mono_of_mono_fac (prod.lift_fst _ _)\n      apply (cancel_mono (prod.lift (𝟙 A) (0 : A ⟶ A))).1\n      convert h\n      apply Limits.prod.hom_ext <;> simp\n  let hp2 : IsColimit (CokernelCofork.ofπ (Limits.prod.snd : A ⨯ A ⟶ A) hlp) :=\n    epiIsCokernelOfKernel _ hp1\n  apply NormalMonoCategory.epi_of_zero_cancel\n  intro Z z hz\n  have h : prod.lift (𝟙 A) (0 : A ⟶ A) ≫ cokernel.π (diag A) ≫ z = 0 := by rw [← Category.assoc, hz]\n  obtain ⟨t, ht⟩ := CokernelCofork.IsColimit.desc' hp2 _ h\n  rw [CokernelCofork.π_ofπ] at ht\n  have htt : t = 0 := by\n    rw [← Category.id_comp t]\n    change 𝟙 A ≫ t = 0\n    rw [← Limits.prod.lift_snd (𝟙 A) (𝟙 A), Category.assoc, ht, ← Category.assoc,\n      cokernel.condition, zero_comp]\n  apply (cancel_epi (cokernel.π (diag A))).1\n  rw [← ht, htt, comp_zero, comp_zero]\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.isIso_r","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.NonPreadditiveAbelian C\nA : C\n⊢ CategoryTheory.IsIso (CategoryTheory.NonPreadditiveAbelian.r A)","decl":"instance isIso_r {A : C} : IsIso (r A) :=\n  isIso_of_mono_of_epi _\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.diag_σ","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.NonPreadditiveAbelian C\nX : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.diag X) CategoryTheory.NonPreadditiveAbelian.σ) 0","decl":"@[reassoc]\ntheorem diag_σ {X : C} : diag X ≫ σ = 0 := by rw [cokernel.condition_assoc, zero_comp]\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.diag_σ_assoc","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.NonPreadditiveAbelian C\nX Z : C\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.diag X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernel.π (CategoryTheory.Limits.diag X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv (CategoryTheory.NonPreadditiveAbelian.r X)) h))) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc]\ntheorem diag_σ {X : C} : diag X ≫ σ = 0 := by rw [cokernel.condition_assoc, zero_comp]\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.lift_σ","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.NonPreadditiveAbelian C\nX : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.id X) 0) CategoryTheory.NonPreadditiveAbelian.σ) (CategoryTheory.CategoryStruct.id X)","decl":"@[reassoc (attr := simp)]\ntheorem lift_σ {X : C} : prod.lift (𝟙 X) 0 ≫ σ = 𝟙 X := by rw [← Category.assoc, IsIso.hom_inv_id]\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.lift_σ_assoc","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.NonPreadditiveAbelian C\nX Z : C\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.id X) 0) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernel.π (CategoryTheory.Limits.diag X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv (CategoryTheory.NonPreadditiveAbelian.r X)) h))) h","decl":"@[reassoc (attr := simp)]\ntheorem lift_σ {X : C} : prod.lift (𝟙 X) 0 ≫ σ = 𝟙 X := by rw [← Category.assoc, IsIso.hom_inv_id]\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.lift_map_assoc","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.NonPreadditiveAbelian C\nX Y : C\nf : Quiver.Hom X Y\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.prod Y Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.id X) 0) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map f f) h)) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.id Y) 0) h))","decl":"@[reassoc]\ntheorem lift_map {X Y : C} (f : X ⟶ Y) :\n    prod.lift (𝟙 X) 0 ≫ Limits.prod.map f f = f ≫ prod.lift (𝟙 Y) 0 := by simp\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.lift_map","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.NonPreadditiveAbelian C\nX Y : C\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.id X) 0) (CategoryTheory.Limits.prod.map f f)) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.id Y) 0))","decl":"@[reassoc]\ntheorem lift_map {X Y : C} (f : X ⟶ Y) :\n    prod.lift (𝟙 X) 0 ≫ Limits.prod.map f f = f ≫ prod.lift (𝟙 Y) 0 := by simp\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.σ_comp","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.NonPreadditiveAbelian C\nX Y : C\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.NonPreadditiveAbelian.σ f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map f f) CategoryTheory.NonPreadditiveAbelian.σ)","decl":"/-- This is the key identity satisfied by `σ`. -/\ntheorem σ_comp {X Y : C} (f : X ⟶ Y) : σ ≫ f = Limits.prod.map f f ≫ σ := by\n  obtain ⟨g, hg⟩ :=\n    CokernelCofork.IsColimit.desc' isColimitσ (Limits.prod.map f f ≫ σ) (by\n      rw [prod.diag_map_assoc, diag_σ, comp_zero])\n  suffices hfg : f = g by rw [← hg, Cofork.π_ofπ, hfg]\n  calc\n    f = f ≫ prod.lift (𝟙 Y) 0 ≫ σ := by rw [lift_σ, Category.comp_id]\n    _ = prod.lift (𝟙 X) 0 ≫ Limits.prod.map f f ≫ σ := by rw [lift_map_assoc]\n    _ = prod.lift (𝟙 X) 0 ≫ σ ≫ g := by rw [← hg, CokernelCofork.π_ofπ]\n    _ = g := by rw [← Category.assoc, lift_σ, Category.id_comp]\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.sub_def","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.NonPreadditiveAbelian C\nX Y : C\na b : Quiver.Hom X Y\n⊢ Eq (HSub.hSub a b) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.lift a b) CategoryTheory.NonPreadditiveAbelian.σ)","decl":"theorem sub_def {X Y : C} (a b : X ⟶ Y) : a - b = prod.lift a b ≫ σ := rfl\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.add_def","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.NonPreadditiveAbelian C\nX Y : C\na b : Quiver.Hom X Y\n⊢ Eq (HAdd.hAdd a b) (HSub.hSub a (Neg.neg b))","decl":"theorem add_def {X Y : C} (a b : X ⟶ Y) : a + b = a - -b := rfl\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.neg_def","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.NonPreadditiveAbelian C\nX Y : C\na : Quiver.Hom X Y\n⊢ Eq (Neg.neg a) (HSub.hSub 0 a)","decl":"theorem neg_def {X Y : C} (a : X ⟶ Y) : -a = 0 - a := rfl\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.sub_zero","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.NonPreadditiveAbelian C\nX Y : C\na : Quiver.Hom X Y\n⊢ Eq (HSub.hSub a 0) a","decl":"theorem sub_zero {X Y : C} (a : X ⟶ Y) : a - 0 = a := by\n  rw [sub_def]\n  conv_lhs =>\n    congr; congr; rw [← Category.comp_id a]\n    case a.g => rw [show 0 = a ≫ (0 : Y ⟶ Y) by simp]\n  rw [← prod.comp_lift, Category.assoc, lift_σ, Category.comp_id]\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.sub_self","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.NonPreadditiveAbelian C\nX Y : C\na : Quiver.Hom X Y\n⊢ Eq (HSub.hSub a a) 0","decl":"theorem sub_self {X Y : C} (a : X ⟶ Y) : a - a = 0 := by\n  rw [sub_def, ← Category.comp_id a, ← prod.comp_lift, Category.assoc, diag_σ, comp_zero]\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.lift_sub_lift","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.NonPreadditiveAbelian C\nX Y : C\na b c d : Quiver.Hom X Y\n⊢ Eq (HSub.hSub (CategoryTheory.Limits.prod.lift a b) (CategoryTheory.Limits.prod.lift c d)) (CategoryTheory.Limits.prod.lift (HSub.hSub a c) (HSub.hSub b d))","decl":"theorem lift_sub_lift {X Y : C} (a b c d : X ⟶ Y) :\n    prod.lift a b - prod.lift c d = prod.lift (a - c) (b - d) := by\n  simp only [sub_def]\n  ext\n  · rw [Category.assoc, σ_comp, prod.lift_map_assoc, prod.lift_fst, prod.lift_fst, prod.lift_fst]\n  · rw [Category.assoc, σ_comp, prod.lift_map_assoc, prod.lift_snd, prod.lift_snd, prod.lift_snd]\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.sub_sub_sub","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.NonPreadditiveAbelian C\nX Y : C\na b c d : Quiver.Hom X Y\n⊢ Eq (HSub.hSub (HSub.hSub a c) (HSub.hSub b d)) (HSub.hSub (HSub.hSub a b) (HSub.hSub c d))","decl":"theorem sub_sub_sub {X Y : C} (a b c d : X ⟶ Y) : a - c - (b - d) = a - b - (c - d) := by\n  rw [sub_def, ← lift_sub_lift, sub_def, Category.assoc, σ_comp, prod.lift_map_assoc]; rfl\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.neg_sub","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.NonPreadditiveAbelian C\nX Y : C\na b : Quiver.Hom X Y\n⊢ Eq (HSub.hSub (Neg.neg a) b) (HSub.hSub (Neg.neg b) a)","decl":"theorem neg_sub {X Y : C} (a b : X ⟶ Y) : -a - b = -b - a := by\n  conv_lhs => rw [neg_def, ← sub_zero b, sub_sub_sub, sub_zero, ← neg_def]\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.neg_neg","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.NonPreadditiveAbelian C\nX Y : C\na : Quiver.Hom X Y\n⊢ Eq (Neg.neg (Neg.neg a)) a","decl":"theorem neg_neg {X Y : C} (a : X ⟶ Y) : - -a = a := by\n  rw [neg_def, neg_def]\n  conv_lhs =>\n    congr; rw [← sub_self a]\n  rw [sub_sub_sub, sub_zero, sub_self, sub_zero]\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.add_comm","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.NonPreadditiveAbelian C\nX Y : C\na b : Quiver.Hom X Y\n⊢ Eq (HAdd.hAdd a b) (HAdd.hAdd b a)","decl":"theorem add_comm {X Y : C} (a b : X ⟶ Y) : a + b = b + a := by\n  rw [add_def]\n  conv_lhs => rw [← neg_neg a]\n  rw [neg_def, neg_def, neg_def, sub_sub_sub]\n  conv_lhs =>\n    congr\n    next => skip\n    rw [← neg_def, neg_sub]\n  rw [sub_sub_sub, add_def, ← neg_def, neg_neg b, neg_def]\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.add_neg","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.NonPreadditiveAbelian C\nX Y : C\na b : Quiver.Hom X Y\n⊢ Eq (HAdd.hAdd a (Neg.neg b)) (HSub.hSub a b)","decl":"theorem add_neg {X Y : C} (a b : X ⟶ Y) : a + -b = a - b := by rw [add_def, neg_neg]\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.add_neg_cancel","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.NonPreadditiveAbelian C\nX Y : C\na : Quiver.Hom X Y\n⊢ Eq (HAdd.hAdd a (Neg.neg a)) 0","decl":"theorem add_neg_cancel {X Y : C} (a : X ⟶ Y) : a + -a = 0 := by rw [add_neg, sub_self]\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.neg_add_cancel","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.NonPreadditiveAbelian C\nX Y : C\na : Quiver.Hom X Y\n⊢ Eq (HAdd.hAdd (Neg.neg a) a) 0","decl":"theorem neg_add_cancel {X Y : C} (a : X ⟶ Y) : -a + a = 0 := by rw [add_comm, add_neg_cancel]\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.neg_sub'","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.NonPreadditiveAbelian C\nX Y : C\na b : Quiver.Hom X Y\n⊢ Eq (Neg.neg (HSub.hSub a b)) (HAdd.hAdd (Neg.neg a) b)","decl":"theorem neg_sub' {X Y : C} (a b : X ⟶ Y) : -(a - b) = -a + b := by\n  rw [neg_def, neg_def]\n  conv_lhs => rw [← sub_self (0 : X ⟶ Y)]\n  rw [sub_sub_sub, add_def, neg_def]\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.neg_add","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.NonPreadditiveAbelian C\nX Y : C\na b : Quiver.Hom X Y\n⊢ Eq (Neg.neg (HAdd.hAdd a b)) (HSub.hSub (Neg.neg a) b)","decl":"theorem neg_add {X Y : C} (a b : X ⟶ Y) : -(a + b) = -a - b := by rw [add_def, neg_sub', add_neg]\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.sub_add","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.NonPreadditiveAbelian C\nX Y : C\na b c : Quiver.Hom X Y\n⊢ Eq (HAdd.hAdd (HSub.hSub a b) c) (HSub.hSub a (HSub.hSub b c))","decl":"theorem sub_add {X Y : C} (a b c : X ⟶ Y) : a - b + c = a - (b - c) := by\n  rw [add_def, neg_def, sub_sub_sub, sub_zero]\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.add_assoc","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.NonPreadditiveAbelian C\nX Y : C\na b c : Quiver.Hom X Y\n⊢ Eq (HAdd.hAdd (HAdd.hAdd a b) c) (HAdd.hAdd a (HAdd.hAdd b c))","decl":"theorem add_assoc {X Y : C} (a b c : X ⟶ Y) : a + b + c = a + (b + c) := by\n  conv_lhs =>\n    congr; rw [add_def]\n  rw [sub_add, ← add_neg, neg_sub', neg_neg]\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.add_zero","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.NonPreadditiveAbelian C\nX Y : C\na : Quiver.Hom X Y\n⊢ Eq (HAdd.hAdd a 0) a","decl":"theorem add_zero {X Y : C} (a : X ⟶ Y) : a + 0 = a := by rw [add_def, neg_def, sub_self, sub_zero]\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.comp_sub","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.NonPreadditiveAbelian C\nX Y Z : C\nf : Quiver.Hom X Y\ng h : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (HSub.hSub g h)) (HSub.hSub (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp f h))","decl":"theorem comp_sub {X Y Z : C} (f : X ⟶ Y) (g h : Y ⟶ Z) : f ≫ (g - h) = f ≫ g - f ≫ h := by\n  rw [sub_def, ← Category.assoc, prod.comp_lift, sub_def]\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.sub_comp","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.NonPreadditiveAbelian C\nX Y Z : C\nf g : Quiver.Hom X Y\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HSub.hSub f g) h) (HSub.hSub (CategoryTheory.CategoryStruct.comp f h) (CategoryTheory.CategoryStruct.comp g h))","decl":"theorem sub_comp {X Y Z : C} (f g : X ⟶ Y) (h : Y ⟶ Z) : (f - g) ≫ h = f ≫ h - g ≫ h := by\n  rw [sub_def, Category.assoc, σ_comp, ← Category.assoc, prod.lift_map, sub_def]\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.comp_add","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.NonPreadditiveAbelian C\nX Y Z : C\nf : Quiver.Hom X Y\ng h : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (HAdd.hAdd g h)) (HAdd.hAdd (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp f h))","decl":"theorem comp_add (X Y Z : C) (f : X ⟶ Y) (g h : Y ⟶ Z) : f ≫ (g + h) = f ≫ g + f ≫ h := by\n  rw [add_def, comp_sub, neg_def, comp_sub, comp_zero, add_def, neg_def]\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.add_comp","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.NonPreadditiveAbelian C\nX Y Z : C\nf g : Quiver.Hom X Y\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HAdd.hAdd f g) h) (HAdd.hAdd (CategoryTheory.CategoryStruct.comp f h) (CategoryTheory.CategoryStruct.comp g h))","decl":"theorem add_comp (X Y Z : C) (f g : X ⟶ Y) (h : Y ⟶ Z) : (f + g) ≫ h = f ≫ h + g ≫ h := by\n  rw [add_def, sub_comp, neg_def, sub_comp, zero_comp, add_def, neg_def]\n\n"}
