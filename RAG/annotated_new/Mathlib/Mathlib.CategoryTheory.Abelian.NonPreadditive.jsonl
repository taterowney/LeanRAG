{"name":"CategoryTheory.NonPreadditiveAbelian.has_kernels","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.NonPreadditiveAbelian C\nâŠ¢ CategoryTheory.Limits.HasKernels C","decl":"/-- We call a category `NonPreadditiveAbelian` if it has a zero object, kernels, cokernels, binary\n    products and coproducts, and every monomorphism and every epimorphism is normal. -/\nclass NonPreadditiveAbelian extends HasZeroMorphisms C, IsNormalMonoCategory C,\n    IsNormalEpiCategory C where\n  [has_zero_object : HasZeroObject C]\n  [has_kernels : HasKernels C]\n  [has_cokernels : HasCokernels C]\n  [has_finite_products : HasFiniteProducts C]\n  [has_finite_coproducts : HasFiniteCoproducts C]\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.has_zero_object","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.NonPreadditiveAbelian C\nâŠ¢ CategoryTheory.Limits.HasZeroObject C","decl":"/-- We call a category `NonPreadditiveAbelian` if it has a zero object, kernels, cokernels, binary\n    products and coproducts, and every monomorphism and every epimorphism is normal. -/\nclass NonPreadditiveAbelian extends HasZeroMorphisms C, IsNormalMonoCategory C,\n    IsNormalEpiCategory C where\n  [has_zero_object : HasZeroObject C]\n  [has_kernels : HasKernels C]\n  [has_cokernels : HasCokernels C]\n  [has_finite_products : HasFiniteProducts C]\n  [has_finite_coproducts : HasFiniteCoproducts C]\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.has_finite_coproducts","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.NonPreadditiveAbelian C\nâŠ¢ CategoryTheory.Limits.HasFiniteCoproducts C","decl":"/-- We call a category `NonPreadditiveAbelian` if it has a zero object, kernels, cokernels, binary\n    products and coproducts, and every monomorphism and every epimorphism is normal. -/\nclass NonPreadditiveAbelian extends HasZeroMorphisms C, IsNormalMonoCategory C,\n    IsNormalEpiCategory C where\n  [has_zero_object : HasZeroObject C]\n  [has_kernels : HasKernels C]\n  [has_cokernels : HasCokernels C]\n  [has_finite_products : HasFiniteProducts C]\n  [has_finite_coproducts : HasFiniteCoproducts C]\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.has_finite_products","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.NonPreadditiveAbelian C\nâŠ¢ CategoryTheory.Limits.HasFiniteProducts C","decl":"/-- We call a category `NonPreadditiveAbelian` if it has a zero object, kernels, cokernels, binary\n    products and coproducts, and every monomorphism and every epimorphism is normal. -/\nclass NonPreadditiveAbelian extends HasZeroMorphisms C, IsNormalMonoCategory C,\n    IsNormalEpiCategory C where\n  [has_zero_object : HasZeroObject C]\n  [has_kernels : HasKernels C]\n  [has_cokernels : HasCokernels C]\n  [has_finite_products : HasFiniteProducts C]\n  [has_finite_coproducts : HasFiniteCoproducts C]\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.has_cokernels","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.NonPreadditiveAbelian C\nâŠ¢ CategoryTheory.Limits.HasCokernels C","decl":"/-- We call a category `NonPreadditiveAbelian` if it has a zero object, kernels, cokernels, binary\n    products and coproducts, and every monomorphism and every epimorphism is normal. -/\nclass NonPreadditiveAbelian extends HasZeroMorphisms C, IsNormalMonoCategory C,\n    IsNormalEpiCategory C where\n  [has_zero_object : HasZeroObject C]\n  [has_kernels : HasKernels C]\n  [has_cokernels : HasCokernels C]\n  [has_finite_products : HasFiniteProducts C]\n  [has_finite_coproducts : HasFiniteCoproducts C]\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.toIsNormalMonoCategory","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.NonPreadditiveAbelian C\nâŠ¢ CategoryTheory.IsNormalMonoCategory C","decl":"/-- We call a category `NonPreadditiveAbelian` if it has a zero object, kernels, cokernels, binary\n    products and coproducts, and every monomorphism and every epimorphism is normal. -/\nclass NonPreadditiveAbelian extends HasZeroMorphisms C, IsNormalMonoCategory C,\n    IsNormalEpiCategory C where\n  [has_zero_object : HasZeroObject C]\n  [has_kernels : HasKernels C]\n  [has_cokernels : HasCokernels C]\n  [has_finite_products : HasFiniteProducts C]\n  [has_finite_coproducts : HasFiniteCoproducts C]\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.toIsNormalEpiCategory","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.NonPreadditiveAbelian C\nâŠ¢ CategoryTheory.IsNormalEpiCategory C","decl":"/-- We call a category `NonPreadditiveAbelian` if it has a zero object, kernels, cokernels, binary\n    products and coproducts, and every monomorphism and every epimorphism is normal. -/\nclass NonPreadditiveAbelian extends HasZeroMorphisms C, IsNormalMonoCategory C,\n    IsNormalEpiCategory C where\n  [has_zero_object : HasZeroObject C]\n  [has_kernels : HasKernels C]\n  [has_cokernels : HasCokernels C]\n  [has_finite_products : HasFiniteProducts C]\n  [has_finite_coproducts : HasFiniteCoproducts C]\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.instEpiFactorThruImage","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.NonPreadditiveAbelian C\nP Q : C\nf : Quiver.Hom P Q\nâŠ¢ CategoryTheory.Epi (CategoryTheory.Abelian.factorThruImage f)","decl":"/-- The map `p : P âŸ¶ image f` is an epimorphism -/\ninstance : Epi (Abelian.factorThruImage f) :=\n  let I := Abelian.image f\n  let p := Abelian.factorThruImage f\n  let i := kernel.Î¹ (cokernel.Ï€ f)\n  -- It will suffice to consider some g : I âŸ¶ R such that p â‰« g = 0 and show that g = 0.\n  NormalMonoCategory.epi_of_zero_cancel\n  _ fun R (g : I âŸ¶ R) (hpg : p â‰« g = 0) => by\n  -- Since C is abelian, u := ker g â‰« i is the kernel of some morphism h.\n  let u := kernel.Î¹ g â‰« i\n  haveI hu := normalMonoOfMono u\n  let h := hu.g\n  -- By hypothesis, p factors through the kernel of g via some t.\n  obtain âŸ¨t, htâŸ© := kernel.lift' g p hpg\n  have fh : f â‰« h = 0 :=\n    calc\n      f â‰« h = (p â‰« i) â‰« h := (Abelian.image.fac f).symm â–¸ rfl\n      _ = ((t â‰« kernel.Î¹ g) â‰« i) â‰« h := ht â–¸ rfl\n      _ = t â‰« u â‰« h := by simp only [u, Category.assoc]\n      _ = t â‰« 0 := hu.w â–¸ rfl\n      _ = 0 := HasZeroMorphisms.comp_zero _ _\n  -- h factors through the cokernel of f via some l.\n  obtain âŸ¨l, hlâŸ© := cokernel.desc' f h fh\n  have hih : i â‰« h = 0 :=\n    calc\n      i â‰« h = i â‰« cokernel.Ï€ f â‰« l := hl â–¸ rfl\n      _ = 0 â‰« l := by rw [â† Category.assoc, kernel.condition]\n      _ = 0 := zero_comp\n  -- i factors through u = ker h via some s.\n  obtain âŸ¨s, hsâŸ© := NormalMono.lift' u i hih\n  have hs' : (s â‰« kernel.Î¹ g) â‰« i = ğŸ™ I â‰« i := by rw [Category.assoc, hs, Category.id_comp]\n  haveI : Epi (kernel.Î¹ g) := epi_of_epi_fac ((cancel_mono _).1 hs')\n  -- ker g is an epimorphism, but ker g â‰« g = 0 = ker g â‰« 0, so g = 0 as required.\n  exact zero_of_epi_comp _ (kernel.condition g)\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.isIso_factorThruImage","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.NonPreadditiveAbelian C\nP Q : C\nf : Quiver.Hom P Q\ninstâœ : CategoryTheory.Mono f\nâŠ¢ CategoryTheory.IsIso (CategoryTheory.Abelian.factorThruImage f)","decl":"instance isIso_factorThruImage [Mono f] : IsIso (Abelian.factorThruImage f) :=\n  isIso_of_mono_of_epi <| Abelian.factorThruImage f\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.instMonoFactorThruCoimage","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.NonPreadditiveAbelian C\nP Q : C\nf : Quiver.Hom P Q\nâŠ¢ CategoryTheory.Mono (CategoryTheory.Abelian.factorThruCoimage f)","decl":"/-- The canonical morphism `i : coimage f âŸ¶ Q` is a monomorphism -/\ninstance : Mono (Abelian.factorThruCoimage f) :=\n  let I := Abelian.coimage f\n  let i := Abelian.factorThruCoimage f\n  let p := cokernel.Ï€ (kernel.Î¹ f)\n  NormalEpiCategory.mono_of_cancel_zero _ fun R (g : R âŸ¶ I) (hgi : g â‰« i = 0) => by\n    -- Since C is abelian, u := p â‰« coker g is the cokernel of some morphism h.\n    let u := p â‰« cokernel.Ï€ g\n    haveI hu := normalEpiOfEpi u\n    let h := hu.g\n    -- By hypothesis, i factors through the cokernel of g via some t.\n    obtain âŸ¨t, htâŸ© := cokernel.desc' g i hgi\n    have hf : h â‰« f = 0 :=\n      calc\n        h â‰« f = h â‰« p â‰« i := (Abelian.coimage.fac f).symm â–¸ rfl\n        _ = h â‰« p â‰« cokernel.Ï€ g â‰« t := ht â–¸ rfl\n        _ = h â‰« u â‰« t := by simp only [u, Category.assoc]\n        _ = 0 â‰« t := by rw [â† Category.assoc, hu.w]\n        _ = 0 := zero_comp\n    -- h factors through the kernel of f via some l.\n    obtain âŸ¨l, hlâŸ© := kernel.lift' f h hf\n    have hhp : h â‰« p = 0 :=\n      calc\n        h â‰« p = (l â‰« kernel.Î¹ f) â‰« p := hl â–¸ rfl\n        _ = l â‰« 0 := by rw [Category.assoc, cokernel.condition]\n        _ = 0 := comp_zero\n    -- p factors through u = coker h via some s.\n    obtain âŸ¨s, hsâŸ© := NormalEpi.desc' u p hhp\n    have hs' : p â‰« cokernel.Ï€ g â‰« s = p â‰« ğŸ™ I := by rw [â† Category.assoc, hs, Category.comp_id]\n    haveI : Mono (cokernel.Ï€ g) := mono_of_mono_fac ((cancel_epi _).1 hs')\n    -- coker g is a monomorphism, but g â‰« coker g = 0 = 0 â‰« coker g, so g = 0 as required.\n    exact zero_of_comp_mono _ (cokernel.condition g)\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.isIso_factorThruCoimage","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.NonPreadditiveAbelian C\nP Q : C\nf : Quiver.Hom P Q\ninstâœ : CategoryTheory.Epi f\nâŠ¢ CategoryTheory.IsIso (CategoryTheory.Abelian.factorThruCoimage f)","decl":"instance isIso_factorThruCoimage [Epi f] : IsIso (Abelian.factorThruCoimage f) :=\n  isIso_of_mono_of_epi _\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.mono_Î”","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.NonPreadditiveAbelian C\nA : C\nâŠ¢ CategoryTheory.Mono (CategoryTheory.Limits.diag A)","decl":"instance mono_Î” {A : C} : Mono (diag A) :=\n  mono_of_mono_fac <| prod.lift_fst _ _\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.mono_r","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.NonPreadditiveAbelian C\nA : C\nâŠ¢ CategoryTheory.Mono (CategoryTheory.NonPreadditiveAbelian.r A)","decl":"instance mono_r {A : C} : Mono (r A) := by\n  let hl : IsLimit (KernelFork.ofÎ¹ (diag A) (cokernel.condition (diag A))) :=\n    monoIsKernelOfCokernel _ (colimit.isColimit _)\n  apply NormalEpiCategory.mono_of_cancel_zero\n  intro Z x hx\n  have hxx : (x â‰« prod.lift (ğŸ™ A) (0 : A âŸ¶ A)) â‰« cokernel.Ï€ (diag A) = 0 := by\n    rw [Category.assoc, hx]\n  obtain âŸ¨y, hyâŸ© := KernelFork.IsLimit.lift' hl _ hxx\n  rw [KernelFork.Î¹_ofÎ¹] at hy\n  have hyy : y = 0 := by\n    erw [â† Category.comp_id y, â† Limits.prod.lift_snd (ğŸ™ A) (ğŸ™ A), â† Category.assoc, hy,\n      Category.assoc, prod.lift_snd, HasZeroMorphisms.comp_zero]\n  haveI : Mono (prod.lift (ğŸ™ A) (0 : A âŸ¶ A)) := mono_of_mono_fac (prod.lift_fst _ _)\n  apply (cancel_mono (prod.lift (ğŸ™ A) (0 : A âŸ¶ A))).1\n  rw [â† hy, hyy, zero_comp, zero_comp]\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.epi_r","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.NonPreadditiveAbelian C\nA : C\nâŠ¢ CategoryTheory.Epi (CategoryTheory.NonPreadditiveAbelian.r A)","decl":"instance epi_r {A : C} : Epi (r A) := by\n  have hlp : prod.lift (ğŸ™ A) (0 : A âŸ¶ A) â‰« Limits.prod.snd = 0 := prod.lift_snd _ _\n  let hp1 : IsLimit (KernelFork.ofÎ¹ (prod.lift (ğŸ™ A) (0 : A âŸ¶ A)) hlp) := by\n    refine Fork.IsLimit.mk _ (fun s => Fork.Î¹ s â‰« Limits.prod.fst) ?_ ?_\n    Â· intro s\n      apply Limits.prod.hom_ext <;> simp\n    Â· intro s m h\n      haveI : Mono (prod.lift (ğŸ™ A) (0 : A âŸ¶ A)) := mono_of_mono_fac (prod.lift_fst _ _)\n      apply (cancel_mono (prod.lift (ğŸ™ A) (0 : A âŸ¶ A))).1\n      convert h\n      apply Limits.prod.hom_ext <;> simp\n  let hp2 : IsColimit (CokernelCofork.ofÏ€ (Limits.prod.snd : A â¨¯ A âŸ¶ A) hlp) :=\n    epiIsCokernelOfKernel _ hp1\n  apply NormalMonoCategory.epi_of_zero_cancel\n  intro Z z hz\n  have h : prod.lift (ğŸ™ A) (0 : A âŸ¶ A) â‰« cokernel.Ï€ (diag A) â‰« z = 0 := by rw [â† Category.assoc, hz]\n  obtain âŸ¨t, htâŸ© := CokernelCofork.IsColimit.desc' hp2 _ h\n  rw [CokernelCofork.Ï€_ofÏ€] at ht\n  have htt : t = 0 := by\n    rw [â† Category.id_comp t]\n    change ğŸ™ A â‰« t = 0\n    rw [â† Limits.prod.lift_snd (ğŸ™ A) (ğŸ™ A), Category.assoc, ht, â† Category.assoc,\n      cokernel.condition, zero_comp]\n  apply (cancel_epi (cokernel.Ï€ (diag A))).1\n  rw [â† ht, htt, comp_zero, comp_zero]\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.isIso_r","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.NonPreadditiveAbelian C\nA : C\nâŠ¢ CategoryTheory.IsIso (CategoryTheory.NonPreadditiveAbelian.r A)","decl":"instance isIso_r {A : C} : IsIso (r A) :=\n  isIso_of_mono_of_epi _\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.diag_Ïƒ","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.NonPreadditiveAbelian C\nX : C\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.diag X) CategoryTheory.NonPreadditiveAbelian.Ïƒ) 0","decl":"@[reassoc]\ntheorem diag_Ïƒ {X : C} : diag X â‰« Ïƒ = 0 := by rw [cokernel.condition_assoc, zero_comp]\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.diag_Ïƒ_assoc","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.NonPreadditiveAbelian C\nX Z : C\nh : Quiver.Hom X Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.diag X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernel.Ï€ (CategoryTheory.Limits.diag X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv (CategoryTheory.NonPreadditiveAbelian.r X)) h))) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc]\ntheorem diag_Ïƒ {X : C} : diag X â‰« Ïƒ = 0 := by rw [cokernel.condition_assoc, zero_comp]\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.lift_Ïƒ","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.NonPreadditiveAbelian C\nX : C\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.id X) 0) CategoryTheory.NonPreadditiveAbelian.Ïƒ) (CategoryTheory.CategoryStruct.id X)","decl":"@[reassoc (attr := simp)]\ntheorem lift_Ïƒ {X : C} : prod.lift (ğŸ™ X) 0 â‰« Ïƒ = ğŸ™ X := by rw [â† Category.assoc, IsIso.hom_inv_id]\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.lift_Ïƒ_assoc","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.NonPreadditiveAbelian C\nX Z : C\nh : Quiver.Hom X Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.id X) 0) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernel.Ï€ (CategoryTheory.Limits.diag X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv (CategoryTheory.NonPreadditiveAbelian.r X)) h))) h","decl":"@[reassoc (attr := simp)]\ntheorem lift_Ïƒ {X : C} : prod.lift (ğŸ™ X) 0 â‰« Ïƒ = ğŸ™ X := by rw [â† Category.assoc, IsIso.hom_inv_id]\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.lift_map_assoc","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.NonPreadditiveAbelian C\nX Y : C\nf : Quiver.Hom X Y\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.prod Y Y) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.id X) 0) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map f f) h)) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.id Y) 0) h))","decl":"@[reassoc]\ntheorem lift_map {X Y : C} (f : X âŸ¶ Y) :\n    prod.lift (ğŸ™ X) 0 â‰« Limits.prod.map f f = f â‰« prod.lift (ğŸ™ Y) 0 := by simp\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.lift_map","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.NonPreadditiveAbelian C\nX Y : C\nf : Quiver.Hom X Y\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.id X) 0) (CategoryTheory.Limits.prod.map f f)) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.id Y) 0))","decl":"@[reassoc]\ntheorem lift_map {X Y : C} (f : X âŸ¶ Y) :\n    prod.lift (ğŸ™ X) 0 â‰« Limits.prod.map f f = f â‰« prod.lift (ğŸ™ Y) 0 := by simp\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.Ïƒ_comp","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.NonPreadditiveAbelian C\nX Y : C\nf : Quiver.Hom X Y\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.NonPreadditiveAbelian.Ïƒ f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map f f) CategoryTheory.NonPreadditiveAbelian.Ïƒ)","decl":"/-- This is the key identity satisfied by `Ïƒ`. -/\ntheorem Ïƒ_comp {X Y : C} (f : X âŸ¶ Y) : Ïƒ â‰« f = Limits.prod.map f f â‰« Ïƒ := by\n  obtain âŸ¨g, hgâŸ© :=\n    CokernelCofork.IsColimit.desc' isColimitÏƒ (Limits.prod.map f f â‰« Ïƒ) (by\n      rw [prod.diag_map_assoc, diag_Ïƒ, comp_zero])\n  suffices hfg : f = g by rw [â† hg, Cofork.Ï€_ofÏ€, hfg]\n  calc\n    f = f â‰« prod.lift (ğŸ™ Y) 0 â‰« Ïƒ := by rw [lift_Ïƒ, Category.comp_id]\n    _ = prod.lift (ğŸ™ X) 0 â‰« Limits.prod.map f f â‰« Ïƒ := by rw [lift_map_assoc]\n    _ = prod.lift (ğŸ™ X) 0 â‰« Ïƒ â‰« g := by rw [â† hg, CokernelCofork.Ï€_ofÏ€]\n    _ = g := by rw [â† Category.assoc, lift_Ïƒ, Category.id_comp]\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.sub_def","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.NonPreadditiveAbelian C\nX Y : C\na b : Quiver.Hom X Y\nâŠ¢ Eq (HSub.hSub a b) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.lift a b) CategoryTheory.NonPreadditiveAbelian.Ïƒ)","decl":"theorem sub_def {X Y : C} (a b : X âŸ¶ Y) : a - b = prod.lift a b â‰« Ïƒ := rfl\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.add_def","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.NonPreadditiveAbelian C\nX Y : C\na b : Quiver.Hom X Y\nâŠ¢ Eq (HAdd.hAdd a b) (HSub.hSub a (Neg.neg b))","decl":"theorem add_def {X Y : C} (a b : X âŸ¶ Y) : a + b = a - -b := rfl\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.neg_def","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.NonPreadditiveAbelian C\nX Y : C\na : Quiver.Hom X Y\nâŠ¢ Eq (Neg.neg a) (HSub.hSub 0 a)","decl":"theorem neg_def {X Y : C} (a : X âŸ¶ Y) : -a = 0 - a := rfl\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.sub_zero","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.NonPreadditiveAbelian C\nX Y : C\na : Quiver.Hom X Y\nâŠ¢ Eq (HSub.hSub a 0) a","decl":"theorem sub_zero {X Y : C} (a : X âŸ¶ Y) : a - 0 = a := by\n  rw [sub_def]\n  conv_lhs =>\n    congr; congr; rw [â† Category.comp_id a]\n    case a.g => rw [show 0 = a â‰« (0 : Y âŸ¶ Y) by simp]\n  rw [â† prod.comp_lift, Category.assoc, lift_Ïƒ, Category.comp_id]\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.sub_self","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.NonPreadditiveAbelian C\nX Y : C\na : Quiver.Hom X Y\nâŠ¢ Eq (HSub.hSub a a) 0","decl":"theorem sub_self {X Y : C} (a : X âŸ¶ Y) : a - a = 0 := by\n  rw [sub_def, â† Category.comp_id a, â† prod.comp_lift, Category.assoc, diag_Ïƒ, comp_zero]\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.lift_sub_lift","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.NonPreadditiveAbelian C\nX Y : C\na b c d : Quiver.Hom X Y\nâŠ¢ Eq (HSub.hSub (CategoryTheory.Limits.prod.lift a b) (CategoryTheory.Limits.prod.lift c d)) (CategoryTheory.Limits.prod.lift (HSub.hSub a c) (HSub.hSub b d))","decl":"theorem lift_sub_lift {X Y : C} (a b c d : X âŸ¶ Y) :\n    prod.lift a b - prod.lift c d = prod.lift (a - c) (b - d) := by\n  simp only [sub_def]\n  ext\n  Â· rw [Category.assoc, Ïƒ_comp, prod.lift_map_assoc, prod.lift_fst, prod.lift_fst, prod.lift_fst]\n  Â· rw [Category.assoc, Ïƒ_comp, prod.lift_map_assoc, prod.lift_snd, prod.lift_snd, prod.lift_snd]\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.sub_sub_sub","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.NonPreadditiveAbelian C\nX Y : C\na b c d : Quiver.Hom X Y\nâŠ¢ Eq (HSub.hSub (HSub.hSub a c) (HSub.hSub b d)) (HSub.hSub (HSub.hSub a b) (HSub.hSub c d))","decl":"theorem sub_sub_sub {X Y : C} (a b c d : X âŸ¶ Y) : a - c - (b - d) = a - b - (c - d) := by\n  rw [sub_def, â† lift_sub_lift, sub_def, Category.assoc, Ïƒ_comp, prod.lift_map_assoc]; rfl\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.neg_sub","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.NonPreadditiveAbelian C\nX Y : C\na b : Quiver.Hom X Y\nâŠ¢ Eq (HSub.hSub (Neg.neg a) b) (HSub.hSub (Neg.neg b) a)","decl":"theorem neg_sub {X Y : C} (a b : X âŸ¶ Y) : -a - b = -b - a := by\n  conv_lhs => rw [neg_def, â† sub_zero b, sub_sub_sub, sub_zero, â† neg_def]\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.neg_neg","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.NonPreadditiveAbelian C\nX Y : C\na : Quiver.Hom X Y\nâŠ¢ Eq (Neg.neg (Neg.neg a)) a","decl":"theorem neg_neg {X Y : C} (a : X âŸ¶ Y) : - -a = a := by\n  rw [neg_def, neg_def]\n  conv_lhs =>\n    congr; rw [â† sub_self a]\n  rw [sub_sub_sub, sub_zero, sub_self, sub_zero]\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.add_comm","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.NonPreadditiveAbelian C\nX Y : C\na b : Quiver.Hom X Y\nâŠ¢ Eq (HAdd.hAdd a b) (HAdd.hAdd b a)","decl":"theorem add_comm {X Y : C} (a b : X âŸ¶ Y) : a + b = b + a := by\n  rw [add_def]\n  conv_lhs => rw [â† neg_neg a]\n  rw [neg_def, neg_def, neg_def, sub_sub_sub]\n  conv_lhs =>\n    congr\n    next => skip\n    rw [â† neg_def, neg_sub]\n  rw [sub_sub_sub, add_def, â† neg_def, neg_neg b, neg_def]\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.add_neg","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.NonPreadditiveAbelian C\nX Y : C\na b : Quiver.Hom X Y\nâŠ¢ Eq (HAdd.hAdd a (Neg.neg b)) (HSub.hSub a b)","decl":"theorem add_neg {X Y : C} (a b : X âŸ¶ Y) : a + -b = a - b := by rw [add_def, neg_neg]\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.add_neg_cancel","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.NonPreadditiveAbelian C\nX Y : C\na : Quiver.Hom X Y\nâŠ¢ Eq (HAdd.hAdd a (Neg.neg a)) 0","decl":"theorem add_neg_cancel {X Y : C} (a : X âŸ¶ Y) : a + -a = 0 := by rw [add_neg, sub_self]\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.neg_add_cancel","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.NonPreadditiveAbelian C\nX Y : C\na : Quiver.Hom X Y\nâŠ¢ Eq (HAdd.hAdd (Neg.neg a) a) 0","decl":"theorem neg_add_cancel {X Y : C} (a : X âŸ¶ Y) : -a + a = 0 := by rw [add_comm, add_neg_cancel]\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.neg_sub'","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.NonPreadditiveAbelian C\nX Y : C\na b : Quiver.Hom X Y\nâŠ¢ Eq (Neg.neg (HSub.hSub a b)) (HAdd.hAdd (Neg.neg a) b)","decl":"theorem neg_sub' {X Y : C} (a b : X âŸ¶ Y) : -(a - b) = -a + b := by\n  rw [neg_def, neg_def]\n  conv_lhs => rw [â† sub_self (0 : X âŸ¶ Y)]\n  rw [sub_sub_sub, add_def, neg_def]\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.neg_add","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.NonPreadditiveAbelian C\nX Y : C\na b : Quiver.Hom X Y\nâŠ¢ Eq (Neg.neg (HAdd.hAdd a b)) (HSub.hSub (Neg.neg a) b)","decl":"theorem neg_add {X Y : C} (a b : X âŸ¶ Y) : -(a + b) = -a - b := by rw [add_def, neg_sub', add_neg]\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.sub_add","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.NonPreadditiveAbelian C\nX Y : C\na b c : Quiver.Hom X Y\nâŠ¢ Eq (HAdd.hAdd (HSub.hSub a b) c) (HSub.hSub a (HSub.hSub b c))","decl":"theorem sub_add {X Y : C} (a b c : X âŸ¶ Y) : a - b + c = a - (b - c) := by\n  rw [add_def, neg_def, sub_sub_sub, sub_zero]\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.add_assoc","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.NonPreadditiveAbelian C\nX Y : C\na b c : Quiver.Hom X Y\nâŠ¢ Eq (HAdd.hAdd (HAdd.hAdd a b) c) (HAdd.hAdd a (HAdd.hAdd b c))","decl":"theorem add_assoc {X Y : C} (a b c : X âŸ¶ Y) : a + b + c = a + (b + c) := by\n  conv_lhs =>\n    congr; rw [add_def]\n  rw [sub_add, â† add_neg, neg_sub', neg_neg]\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.add_zero","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.NonPreadditiveAbelian C\nX Y : C\na : Quiver.Hom X Y\nâŠ¢ Eq (HAdd.hAdd a 0) a","decl":"theorem add_zero {X Y : C} (a : X âŸ¶ Y) : a + 0 = a := by rw [add_def, neg_def, sub_self, sub_zero]\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.comp_sub","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.NonPreadditiveAbelian C\nX Y Z : C\nf : Quiver.Hom X Y\ng h : Quiver.Hom Y Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp f (HSub.hSub g h)) (HSub.hSub (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp f h))","decl":"theorem comp_sub {X Y Z : C} (f : X âŸ¶ Y) (g h : Y âŸ¶ Z) : f â‰« (g - h) = f â‰« g - f â‰« h := by\n  rw [sub_def, â† Category.assoc, prod.comp_lift, sub_def]\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.sub_comp","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.NonPreadditiveAbelian C\nX Y Z : C\nf g : Quiver.Hom X Y\nh : Quiver.Hom Y Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (HSub.hSub f g) h) (HSub.hSub (CategoryTheory.CategoryStruct.comp f h) (CategoryTheory.CategoryStruct.comp g h))","decl":"theorem sub_comp {X Y Z : C} (f g : X âŸ¶ Y) (h : Y âŸ¶ Z) : (f - g) â‰« h = f â‰« h - g â‰« h := by\n  rw [sub_def, Category.assoc, Ïƒ_comp, â† Category.assoc, prod.lift_map, sub_def]\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.comp_add","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.NonPreadditiveAbelian C\nX Y Z : C\nf : Quiver.Hom X Y\ng h : Quiver.Hom Y Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp f (HAdd.hAdd g h)) (HAdd.hAdd (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp f h))","decl":"theorem comp_add (X Y Z : C) (f : X âŸ¶ Y) (g h : Y âŸ¶ Z) : f â‰« (g + h) = f â‰« g + f â‰« h := by\n  rw [add_def, comp_sub, neg_def, comp_sub, comp_zero, add_def, neg_def]\n\n"}
{"name":"CategoryTheory.NonPreadditiveAbelian.add_comp","module":"Mathlib.CategoryTheory.Abelian.NonPreadditive","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.NonPreadditiveAbelian C\nX Y Z : C\nf g : Quiver.Hom X Y\nh : Quiver.Hom Y Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (HAdd.hAdd f g) h) (HAdd.hAdd (CategoryTheory.CategoryStruct.comp f h) (CategoryTheory.CategoryStruct.comp g h))","decl":"theorem add_comp (X Y Z : C) (f g : X âŸ¶ Y) (h : Y âŸ¶ Z) : (f + g) â‰« h = f â‰« h + g â‰« h := by\n  rw [add_def, sub_comp, neg_def, sub_comp, zero_comp, add_def, neg_def]\n\n"}
