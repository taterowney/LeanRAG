{"name":"HallMarriageTheorem.hall_cond_of_erase","module":"Mathlib.Combinatorics.Hall.Finite","initialProofState":"ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\nha : ∀ (s : Finset ι), s.Nonempty → Ne s Finset.univ → LT.lt s.card (s.biUnion t).card\ns' : Finset ↑(setOf fun x' => Ne x' x)\n⊢ LE.le s'.card (s'.biUnion fun x' => (t ↑x').erase a).card","decl":"theorem hall_cond_of_erase {x : ι} (a : α)\n    (ha : ∀ s : Finset ι, s.Nonempty → s ≠ univ → #s < #(s.biUnion t))\n    (s' : Finset { x' : ι | x' ≠ x }) : #s' ≤ #(s'.biUnion fun x' => (t x').erase a) := by\n  haveI := Classical.decEq ι\n  specialize ha (s'.image fun z => z.1)\n  rw [image_nonempty, Finset.card_image_of_injective s' Subtype.coe_injective] at ha\n  by_cases he : s'.Nonempty\n  · have ha' : #s' < #(s'.biUnion fun x => t x) := by\n      convert ha he fun h => by simpa [← h] using mem_univ x using 2\n      ext x\n      simp only [mem_image, mem_biUnion, exists_prop, SetCoe.exists, exists_and_right,\n        exists_eq_right, Subtype.coe_mk]\n    rw [← erase_biUnion]\n    by_cases hb : a ∈ s'.biUnion fun x => t x\n    · rw [card_erase_of_mem hb]\n      exact Nat.le_sub_one_of_lt ha'\n    · rw [erase_eq_of_not_mem hb]\n      exact Nat.le_of_lt ha'\n  · rw [nonempty_iff_ne_empty, not_not] at he\n    subst s'\n    simp\n\n"}
{"name":"HallMarriageTheorem.hall_hard_inductive_step_A","module":"Mathlib.Combinatorics.Hall.Finite","initialProofState":"ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : Nat\nhn : Eq (Fintype.card ι) (HAdd.hAdd n 1)\nht : ∀ (s : Finset ι), LE.le s.card (s.biUnion t).card\nih : ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α), LE.le (Fintype.card ι') n → (∀ (s' : Finset ι'), LE.le s'.card (s'.biUnion t').card) → Exists fun f => And (Function.Injective f) (∀ (x : ι'), Membership.mem (t' x) (f x))\nha : ∀ (s : Finset ι), s.Nonempty → Ne s Finset.univ → LT.lt s.card (s.biUnion t).card\n⊢ Exists fun f => And (Function.Injective f) (∀ (x : ι), Membership.mem (t x) (f x))","decl":"/-- First case of the inductive step: assuming that\n`∀ (s : Finset ι), s.Nonempty → s ≠ univ → #s < #(s.biUnion t)`\nand that the statement of **Hall's Marriage Theorem** is true for all\n`ι'` of cardinality ≤ `n`, then it is true for `ι` of cardinality `n + 1`.\n-/\ntheorem hall_hard_inductive_step_A {n : ℕ} (hn : Fintype.card ι = n + 1)\n    (ht : ∀ s : Finset ι, #s ≤ #(s.biUnion t))\n    (ih :\n      ∀ {ι' : Type u} [Fintype ι'] (t' : ι' → Finset α),\n        Fintype.card ι' ≤ n →\n          (∀ s' : Finset ι', #s' ≤ #(s'.biUnion t')) →\n            ∃ f : ι' → α, Function.Injective f ∧ ∀ x, f x ∈ t' x)\n    (ha : ∀ s : Finset ι, s.Nonempty → s ≠ univ → #s < #(s.biUnion t)) :\n    ∃ f : ι → α, Function.Injective f ∧ ∀ x, f x ∈ t x := by\n  haveI : Nonempty ι := Fintype.card_pos_iff.mp (hn.symm ▸ Nat.succ_pos _)\n  haveI := Classical.decEq ι\n  -- Choose an arbitrary element `x : ι` and `y : t x`.\n  let x := Classical.arbitrary ι\n  have tx_ne : (t x).Nonempty := by\n    rw [← Finset.card_pos]\n    calc\n      0 < 1 := Nat.one_pos\n      _ ≤ #(.biUnion {x} t) := ht {x}\n      _ = (t x).card := by rw [Finset.singleton_biUnion]\n\n  choose y hy using tx_ne\n  -- Restrict to everything except `x` and `y`.\n  let ι' := { x' : ι | x' ≠ x }\n  let t' : ι' → Finset α := fun x' => (t x').erase y\n  have card_ι' : Fintype.card ι' = n :=\n    calc\n      Fintype.card ι' = Fintype.card ι - 1 := Set.card_ne_eq _\n      _ = n := by rw [hn, Nat.add_succ_sub_one, add_zero]\n\n  rcases ih t' card_ι'.le (hall_cond_of_erase y ha) with ⟨f', hfinj, hfr⟩\n  -- Extend the resulting function.\n  refine ⟨fun z => if h : z = x then y else f' ⟨z, h⟩, ?_, ?_⟩\n  · rintro z₁ z₂\n    have key : ∀ {x}, y ≠ f' x := by\n      intro x h\n      simpa [t', ← h] using hfr x\n    by_cases h₁ : z₁ = x <;> by_cases h₂ : z₂ = x <;>\n      simp [h₁, h₂, hfinj.eq_iff, key, key.symm]\n  · intro z\n    simp only [ne_eq, Set.mem_setOf_eq]\n    split_ifs with hz\n    · rwa [hz]\n    · specialize hfr ⟨z, hz⟩\n      rw [mem_erase] at hfr\n      exact hfr.2\n\n"}
{"name":"HallMarriageTheorem.hall_cond_of_restrict","module":"Mathlib.Combinatorics.Hall.Finite","initialProofState":"α : Type v\ninst✝ : DecidableEq α\nι : Type u\nt : ι → Finset α\ns : Finset ι\nht : ∀ (s : Finset ι), LE.le s.card (s.biUnion t).card\ns' : Finset ↑↑s\n⊢ LE.le s'.card (s'.biUnion fun a' => t ↑a').card","decl":"theorem hall_cond_of_restrict {ι : Type u} {t : ι → Finset α} {s : Finset ι}\n    (ht : ∀ s : Finset ι, #s ≤ #(s.biUnion t)) (s' : Finset (s : Set ι)) :\n    #s' ≤ #(s'.biUnion fun a' => t a') := by\n  classical\n    rw [← card_image_of_injective s' Subtype.coe_injective]\n    convert ht (s'.image fun z => z.1) using 1\n    apply congr_arg\n    ext y\n    simp\n\n"}
{"name":"HallMarriageTheorem.hall_cond_of_compl","module":"Mathlib.Combinatorics.Hall.Finite","initialProofState":"α : Type v\ninst✝ : DecidableEq α\nι : Type u\nt : ι → Finset α\ns : Finset ι\nhus : Eq s.card (s.biUnion t).card\nht : ∀ (s : Finset ι), LE.le s.card (s.biUnion t).card\ns' : Finset ↑(HasCompl.compl ↑s)\n⊢ LE.le s'.card (s'.biUnion fun x' => SDiff.sdiff (t ↑x') (s.biUnion t)).card","decl":"theorem hall_cond_of_compl {ι : Type u} {t : ι → Finset α} {s : Finset ι}\n    (hus : #s = #(s.biUnion t)) (ht : ∀ s : Finset ι, #s ≤ #(s.biUnion t))\n    (s' : Finset (sᶜ : Set ι)) : #s' ≤ #(s'.biUnion fun x' => t x' \\ s.biUnion t) := by\n  haveI := Classical.decEq ι\n  have disj : Disjoint s (s'.image fun z => z.1) := by\n    simp only [disjoint_left, not_exists, mem_image, exists_prop, SetCoe.exists, exists_and_right,\n      exists_eq_right, Subtype.coe_mk]\n    intro x hx hc _\n    exact absurd hx hc\n  have : #s' = #(s ∪ s'.image fun z => z.1) - #s := by\n    simp [disj, card_image_of_injective _ Subtype.coe_injective, Nat.add_sub_cancel_left]\n  rw [this, hus]\n  refine (Nat.sub_le_sub_right (ht _) _).trans ?_\n  rw [← card_sdiff]\n  · refine (card_le_card ?_).trans le_rfl\n    intro t\n    simp only [mem_biUnion, mem_sdiff, not_exists, mem_image, and_imp, mem_union, exists_and_right,\n      exists_imp]\n    rintro x (hx | ⟨x', hx', rfl⟩) rat hs\n    · exact False.elim <| (hs x) <| And.intro hx rat\n    · use x', hx', rat, hs\n  · apply biUnion_subset_biUnion_of_subset_left\n    apply subset_union_left\n\n"}
{"name":"HallMarriageTheorem.hall_hard_inductive_step_B","module":"Mathlib.Combinatorics.Hall.Finite","initialProofState":"ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : Nat\nhn : Eq (Fintype.card ι) (HAdd.hAdd n 1)\nht : ∀ (s : Finset ι), LE.le s.card (s.biUnion t).card\nih : ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α), LE.le (Fintype.card ι') n → (∀ (s' : Finset ι'), LE.le s'.card (s'.biUnion t').card) → Exists fun f => And (Function.Injective f) (∀ (x : ι'), Membership.mem (t' x) (f x))\ns : Finset ι\nhs : s.Nonempty\nhns : Ne s Finset.univ\nhus : Eq s.card (s.biUnion t).card\n⊢ Exists fun f => And (Function.Injective f) (∀ (x : ι), Membership.mem (t x) (f x))","decl":"/-- Second case of the inductive step: assuming that\n`∃ (s : Finset ι), s ≠ univ → #s = #(s.biUnion t)`\nand that the statement of **Hall's Marriage Theorem** is true for all\n`ι'` of cardinality ≤ `n`, then it is true for `ι` of cardinality `n + 1`.\n-/\ntheorem hall_hard_inductive_step_B {n : ℕ} (hn : Fintype.card ι = n + 1)\n    (ht : ∀ s : Finset ι, #s ≤ #(s.biUnion t))\n    (ih :\n      ∀ {ι' : Type u} [Fintype ι'] (t' : ι' → Finset α),\n        Fintype.card ι' ≤ n →\n          (∀ s' : Finset ι', #s' ≤ #(s'.biUnion t')) →\n            ∃ f : ι' → α, Function.Injective f ∧ ∀ x, f x ∈ t' x)\n    (s : Finset ι) (hs : s.Nonempty) (hns : s ≠ univ) (hus : #s = #(s.biUnion t)) :\n    ∃ f : ι → α, Function.Injective f ∧ ∀ x, f x ∈ t x := by\n  haveI := Classical.decEq ι\n  -- Restrict to `s`\n  rw [Nat.add_one] at hn\n  have card_ι'_le : Fintype.card s ≤ n := by\n    apply Nat.le_of_lt_succ\n    calc\n      Fintype.card s = #s := Fintype.card_coe _\n      _ < Fintype.card ι := (card_lt_iff_ne_univ _).mpr hns\n      _ = n.succ := hn\n  let t' : s → Finset α := fun x' => t x'\n  rcases ih t' card_ι'_le (hall_cond_of_restrict ht) with ⟨f', hf', hsf'⟩\n  -- Restrict to `sᶜ` in the domain and `(s.biUnion t)ᶜ` in the codomain.\n  set ι'' := (s : Set ι)ᶜ\n  let t'' : ι'' → Finset α := fun a'' => t a'' \\ s.biUnion t\n  have card_ι''_le : Fintype.card ι'' ≤ n := by\n    simp_rw [ι'', ← Nat.lt_succ_iff, ← hn, ← Finset.coe_compl, coe_sort_coe]\n    rwa [Fintype.card_coe, card_compl_lt_iff_nonempty]\n  rcases ih t'' card_ι''_le (hall_cond_of_compl hus ht) with ⟨f'', hf'', hsf''⟩\n  -- Put them together\n  have f'_mem_biUnion : ∀ (x') (hx' : x' ∈ s), f' ⟨x', hx'⟩ ∈ s.biUnion t := by\n    intro x' hx'\n    rw [mem_biUnion]\n    exact ⟨x', hx', hsf' _⟩\n  have f''_not_mem_biUnion : ∀ (x'') (hx'' : ¬x'' ∈ s), ¬f'' ⟨x'', hx''⟩ ∈ s.biUnion t := by\n    intro x'' hx''\n    have h := hsf'' ⟨x'', hx''⟩\n    rw [mem_sdiff] at h\n    exact h.2\n  have im_disj :\n      ∀ (x' x'' : ι) (hx' : x' ∈ s) (hx'' : ¬x'' ∈ s), f' ⟨x', hx'⟩ ≠ f'' ⟨x'', hx''⟩ := by\n    intro x x' hx' hx'' h\n    apply f''_not_mem_biUnion x' hx''\n    rw [← h]\n    apply f'_mem_biUnion x\n  refine ⟨fun x => if h : x ∈ s then f' ⟨x, h⟩ else f'' ⟨x, h⟩, ?_, ?_⟩\n  · refine hf'.dite _ hf'' (@fun x x' => im_disj x x' _ _)\n  · intro x\n    simp only [of_eq_true]\n    split_ifs with h\n    · exact hsf' ⟨x, h⟩\n    · exact sdiff_subset (hsf'' ⟨x, h⟩)\n\n"}
{"name":"HallMarriageTheorem.hall_hard_inductive","module":"Mathlib.Combinatorics.Hall.Finite","initialProofState":"ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Finite ι\nht : ∀ (s : Finset ι), LE.le s.card (s.biUnion t).card\n⊢ Exists fun f => And (Function.Injective f) (∀ (x : ι), Membership.mem (t x) (f x))","decl":"/-- Here we combine the two inductive steps into a full strong induction proof,\ncompleting the proof the harder direction of **Hall's Marriage Theorem**.\n-/\ntheorem hall_hard_inductive (ht : ∀ s : Finset ι, #s ≤ #(s.biUnion t)) :\n    ∃ f : ι → α, Function.Injective f ∧ ∀ x, f x ∈ t x := by\n  cases nonempty_fintype ι\n  induction' hn : Fintype.card ι using Nat.strong_induction_on with n ih generalizing ι\n  rcases n with (_ | n)\n  · rw [Fintype.card_eq_zero_iff] at hn\n    exact ⟨isEmptyElim, isEmptyElim, isEmptyElim⟩\n  · have ih' : ∀ (ι' : Type u) [Fintype ι'] (t' : ι' → Finset α), Fintype.card ι' ≤ n →\n        (∀ s' : Finset ι', #s' ≤ #(s'.biUnion t')) →\n        ∃ f : ι' → α, Function.Injective f ∧ ∀ x, f x ∈ t' x := by\n      intro ι' _ _ hι' ht'\n      exact ih _ (Nat.lt_succ_of_le hι') ht' _ rfl\n    by_cases h : ∀ s : Finset ι, s.Nonempty → s ≠ univ → #s < #(s.biUnion t)\n    · refine hall_hard_inductive_step_A hn ht (@fun ι' => ih' ι') h\n    · push_neg at h\n      rcases h with ⟨s, sne, snu, sle⟩\n      exact hall_hard_inductive_step_B hn ht (@fun ι' => ih' ι')\n        s sne snu (Nat.le_antisymm (ht _) sle)\n\n"}
{"name":"Finset.all_card_le_biUnion_card_iff_existsInjective'","module":"Mathlib.Combinatorics.Hall.Finite","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝¹ : Finite ι\ninst✝ : DecidableEq α\nt : ι → Finset α\n⊢ Iff (∀ (s : Finset ι), LE.le s.card (s.biUnion t).card) (Exists fun f => And (Function.Injective f) (∀ (x : ι), Membership.mem (t x) (f x)))","decl":"/-- This is the version of **Hall's Marriage Theorem** in terms of indexed\nfamilies of finite sets `t : ι → Finset α` with `ι` finite.\nIt states that there is a set of distinct representatives if and only\nif every union of `k` of the sets has at least `k` elements.\n\nSee `Finset.all_card_le_biUnion_card_iff_exists_injective` for a version\nwhere the `Finite ι` constraint is removed.\n-/\ntheorem Finset.all_card_le_biUnion_card_iff_existsInjective' {ι α : Type*} [Finite ι]\n    [DecidableEq α] (t : ι → Finset α) :\n    (∀ s : Finset ι, #s ≤ #(s.biUnion t)) ↔\n      ∃ f : ι → α, Function.Injective f ∧ ∀ x, f x ∈ t x := by\n  constructor\n  · exact HallMarriageTheorem.hall_hard_inductive\n  · rintro ⟨f, hf₁, hf₂⟩ s\n    rw [← card_image_of_injective s hf₁]\n    apply card_le_card\n    intro\n    rw [mem_image, mem_biUnion]\n    rintro ⟨x, hx, rfl⟩\n    exact ⟨x, hx, hf₂ x⟩\n"}
