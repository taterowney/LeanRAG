{"name":"Polynomial.natDegree_list_sum_le","module":"Mathlib.Algebra.Polynomial.BigOperators","initialProofState":"S : Type u_1\ninst✝ : Semiring S\nl : List (Polynomial S)\n⊢ LE.le l.sum.natDegree (List.foldr Max.max 0 (List.map Polynomial.natDegree l))","decl":"theorem natDegree_list_sum_le (l : List S[X]) :\n    natDegree l.sum ≤ (l.map natDegree).foldr max 0 := by\n  apply List.sum_le_foldr_max natDegree\n  · simp\n  · exact natDegree_add_le\n\n"}
{"name":"Polynomial.natDegree_multiset_sum_le","module":"Mathlib.Algebra.Polynomial.BigOperators","initialProofState":"S : Type u_1\ninst✝ : Semiring S\nl : Multiset (Polynomial S)\n⊢ LE.le l.sum.natDegree (Multiset.foldr Max.max 0 (Multiset.map Polynomial.natDegree l))","decl":"theorem natDegree_multiset_sum_le (l : Multiset S[X]) :\n    natDegree l.sum ≤ (l.map natDegree).foldr max 0 :=\n  Quotient.inductionOn l (by simpa using natDegree_list_sum_le)\n\n"}
{"name":"Polynomial.natDegree_sum_le","module":"Mathlib.Algebra.Polynomial.BigOperators","initialProofState":"ι : Type w\ns : Finset ι\nS : Type u_1\ninst✝ : Semiring S\nf : ι → Polynomial S\n⊢ LE.le (s.sum fun i => f i).natDegree (Finset.fold Max.max 0 (Function.comp Polynomial.natDegree f) s)","decl":"theorem natDegree_sum_le (f : ι → S[X]) :\n    natDegree (∑ i ∈ s, f i) ≤ s.fold max 0 (natDegree ∘ f) := by\n  simpa using natDegree_multiset_sum_le (s.val.map f)\n\n"}
{"name":"Polynomial.natDegree_sum_le_of_forall_le","module":"Mathlib.Algebra.Polynomial.BigOperators","initialProofState":"ι : Type w\ns : Finset ι\nS : Type u_1\ninst✝ : Semiring S\nn : Nat\nf : ι → Polynomial S\nh : ∀ (i : ι), Membership.mem s i → LE.le (f i).natDegree n\n⊢ LE.le (s.sum fun i => f i).natDegree n","decl":"lemma natDegree_sum_le_of_forall_le {n : ℕ} (f : ι → S[X]) (h : ∀ i ∈ s, natDegree (f i) ≤ n) :\n    natDegree (∑ i ∈ s, f i) ≤ n :=\n  le_trans (natDegree_sum_le s f) <| (Finset.fold_max_le n).mpr <| by simpa\n\n"}
{"name":"Polynomial.degree_list_sum_le","module":"Mathlib.Algebra.Polynomial.BigOperators","initialProofState":"S : Type u_1\ninst✝ : Semiring S\nl : List (Polynomial S)\n⊢ LE.le l.sum.degree (List.map Polynomial.natDegree l).maximum","decl":"theorem degree_list_sum_le (l : List S[X]) : degree l.sum ≤ (l.map natDegree).maximum := by\n  by_cases h : l.sum = 0\n  · simp [h]\n  · rw [degree_eq_natDegree h]\n    suffices (l.map natDegree).maximum = ((l.map natDegree).foldr max 0 : ℕ) by\n      rw [this]\n      simpa using natDegree_list_sum_le l\n    rw [← List.foldr_max_of_ne_nil]\n    · congr\n    contrapose! h\n    rw [List.map_eq_nil_iff] at h\n    simp [h]\n\n"}
{"name":"Polynomial.natDegree_list_prod_le","module":"Mathlib.Algebra.Polynomial.BigOperators","initialProofState":"S : Type u_1\ninst✝ : Semiring S\nl : List (Polynomial S)\n⊢ LE.le l.prod.natDegree (List.map Polynomial.natDegree l).sum","decl":"theorem natDegree_list_prod_le (l : List S[X]) : natDegree l.prod ≤ (l.map natDegree).sum := by\n  induction' l with hd tl IH\n  · simp\n  · simpa using natDegree_mul_le.trans (add_le_add_left IH _)\n\n"}
{"name":"Polynomial.degree_list_prod_le","module":"Mathlib.Algebra.Polynomial.BigOperators","initialProofState":"S : Type u_1\ninst✝ : Semiring S\nl : List (Polynomial S)\n⊢ LE.le l.prod.degree (List.map Polynomial.degree l).sum","decl":"theorem degree_list_prod_le (l : List S[X]) : degree l.prod ≤ (l.map degree).sum := by\n  induction' l with hd tl IH\n  · simp\n  · simpa using (degree_mul_le _ _).trans (add_le_add_left IH _)\n\n"}
{"name":"Polynomial.coeff_list_prod_of_natDegree_le","module":"Mathlib.Algebra.Polynomial.BigOperators","initialProofState":"S : Type u_1\ninst✝ : Semiring S\nl : List (Polynomial S)\nn : Nat\nhl : ∀ (p : Polynomial S), Membership.mem l p → LE.le p.natDegree n\n⊢ Eq (l.prod.coeff (HMul.hMul l.length n)) (List.map (fun p => p.coeff n) l).prod","decl":"theorem coeff_list_prod_of_natDegree_le (l : List S[X]) (n : ℕ) (hl : ∀ p ∈ l, natDegree p ≤ n) :\n    coeff (List.prod l) (l.length * n) = (l.map fun p => coeff p n).prod := by\n  induction' l with hd tl IH\n  · simp\n  · have hl' : ∀ p ∈ tl, natDegree p ≤ n := fun p hp => hl p (List.mem_cons_of_mem _ hp)\n    simp only [List.prod_cons, List.map, List.length]\n    rw [add_mul, one_mul, add_comm, ← IH hl', mul_comm tl.length]\n    have h : natDegree tl.prod ≤ n * tl.length := by\n      refine (natDegree_list_prod_le _).trans ?_\n      rw [← tl.length_map natDegree, mul_comm]\n      refine List.sum_le_card_nsmul _ _ ?_\n      simpa using hl'\n    have hdn : natDegree hd ≤ n := hl _ (List.mem_cons_self _ _)\n    rcases hdn.eq_or_lt with (rfl | hdn')\n    · rcases h.eq_or_lt with h' | h'\n      · rw [← h', coeff_mul_degree_add_degree, leadingCoeff, leadingCoeff]\n      · rw [coeff_eq_zero_of_natDegree_lt, coeff_eq_zero_of_natDegree_lt h', mul_zero]\n        exact natDegree_mul_le.trans_lt (add_lt_add_left h' _)\n    · rw [coeff_eq_zero_of_natDegree_lt hdn', coeff_eq_zero_of_natDegree_lt, zero_mul]\n      exact natDegree_mul_le.trans_lt (add_lt_add_of_lt_of_le hdn' h)\n\n"}
{"name":"Polynomial.natDegree_multiset_prod_le","module":"Mathlib.Algebra.Polynomial.BigOperators","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nt : Multiset (Polynomial R)\n⊢ LE.le t.prod.natDegree (Multiset.map Polynomial.natDegree t).sum","decl":"theorem natDegree_multiset_prod_le : t.prod.natDegree ≤ (t.map natDegree).sum :=\n  Quotient.inductionOn t (by simpa using natDegree_list_prod_le)\n\n"}
{"name":"Polynomial.natDegree_prod_le","module":"Mathlib.Algebra.Polynomial.BigOperators","initialProofState":"R : Type u\nι : Type w\ns : Finset ι\ninst✝ : CommSemiring R\nf : ι → Polynomial R\n⊢ LE.le (s.prod fun i => f i).natDegree (s.sum fun i => (f i).natDegree)","decl":"theorem natDegree_prod_le : (∏ i ∈ s, f i).natDegree ≤ ∑ i ∈ s, (f i).natDegree := by\n  simpa using natDegree_multiset_prod_le (s.1.map f)\n\n"}
{"name":"Polynomial.degree_multiset_prod_le","module":"Mathlib.Algebra.Polynomial.BigOperators","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nt : Multiset (Polynomial R)\n⊢ LE.le t.prod.degree (Multiset.map Polynomial.degree t).sum","decl":"/-- The degree of a product of polynomials is at most the sum of the degrees,\nwhere the degree of the zero polynomial is ⊥.\n-/\ntheorem degree_multiset_prod_le : t.prod.degree ≤ (t.map Polynomial.degree).sum :=\n  Quotient.inductionOn t (by simpa using degree_list_prod_le)\n\n"}
{"name":"Polynomial.degree_prod_le","module":"Mathlib.Algebra.Polynomial.BigOperators","initialProofState":"R : Type u\nι : Type w\ns : Finset ι\ninst✝ : CommSemiring R\nf : ι → Polynomial R\n⊢ LE.le (s.prod fun i => f i).degree (s.sum fun i => (f i).degree)","decl":"theorem degree_prod_le : (∏ i ∈ s, f i).degree ≤ ∑ i ∈ s, (f i).degree := by\n  simpa only [Multiset.map_map] using degree_multiset_prod_le (s.1.map f)\n\n"}
{"name":"Polynomial.leadingCoeff_multiset_prod'","module":"Mathlib.Algebra.Polynomial.BigOperators","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nt : Multiset (Polynomial R)\nh : Ne (Multiset.map Polynomial.leadingCoeff t).prod 0\n⊢ Eq t.prod.leadingCoeff (Multiset.map Polynomial.leadingCoeff t).prod","decl":"/-- The leading coefficient of a product of polynomials is equal to\nthe product of the leading coefficients, provided that this product is nonzero.\n\nSee `Polynomial.leadingCoeff_multiset_prod` (without the `'`) for a version for integral domains,\nwhere this condition is automatically satisfied.\n-/\ntheorem leadingCoeff_multiset_prod' (h : (t.map leadingCoeff).prod ≠ 0) :\n    t.prod.leadingCoeff = (t.map leadingCoeff).prod := by\n  induction' t using Multiset.induction_on with a t ih; · simp\n  simp only [Multiset.map_cons, Multiset.prod_cons] at h ⊢\n  rw [Polynomial.leadingCoeff_mul']\n  · rw [ih]\n    simp only [ne_eq]\n    apply right_ne_zero_of_mul h\n  · rw [ih]\n    · exact h\n    simp only [ne_eq, not_false_eq_true]\n    apply right_ne_zero_of_mul h\n\n"}
{"name":"Polynomial.leadingCoeff_prod'","module":"Mathlib.Algebra.Polynomial.BigOperators","initialProofState":"R : Type u\nι : Type w\ns : Finset ι\ninst✝ : CommSemiring R\nf : ι → Polynomial R\nh : Ne (s.prod fun i => (f i).leadingCoeff) 0\n⊢ Eq (s.prod fun i => f i).leadingCoeff (s.prod fun i => (f i).leadingCoeff)","decl":"/-- The leading coefficient of a product of polynomials is equal to\nthe product of the leading coefficients, provided that this product is nonzero.\n\nSee `Polynomial.leadingCoeff_prod` (without the `'`) for a version for integral domains,\nwhere this condition is automatically satisfied.\n-/\ntheorem leadingCoeff_prod' (h : (∏ i ∈ s, (f i).leadingCoeff) ≠ 0) :\n    (∏ i ∈ s, f i).leadingCoeff = ∏ i ∈ s, (f i).leadingCoeff := by\n  simpa using leadingCoeff_multiset_prod' (s.1.map f) (by simpa using h)\n\n"}
{"name":"Polynomial.natDegree_multiset_prod'","module":"Mathlib.Algebra.Polynomial.BigOperators","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nt : Multiset (Polynomial R)\nh : Ne (Multiset.map (fun f => f.leadingCoeff) t).prod 0\n⊢ Eq t.prod.natDegree (Multiset.map (fun f => f.natDegree) t).sum","decl":"/-- The degree of a product of polynomials is equal to\nthe sum of the degrees, provided that the product of leading coefficients is nonzero.\n\nSee `Polynomial.natDegree_multiset_prod` (without the `'`) for a version for integral domains,\nwhere this condition is automatically satisfied.\n-/\ntheorem natDegree_multiset_prod' (h : (t.map fun f => leadingCoeff f).prod ≠ 0) :\n    t.prod.natDegree = (t.map fun f => natDegree f).sum := by\n  revert h\n  refine Multiset.induction_on t ?_ fun a t ih ht => ?_; · simp\n  rw [Multiset.map_cons, Multiset.prod_cons] at ht ⊢\n  rw [Multiset.sum_cons, Polynomial.natDegree_mul', ih]\n  · apply right_ne_zero_of_mul ht\n  · rwa [Polynomial.leadingCoeff_multiset_prod']\n    apply right_ne_zero_of_mul ht\n\n"}
{"name":"Polynomial.natDegree_prod'","module":"Mathlib.Algebra.Polynomial.BigOperators","initialProofState":"R : Type u\nι : Type w\ns : Finset ι\ninst✝ : CommSemiring R\nf : ι → Polynomial R\nh : Ne (s.prod fun i => (f i).leadingCoeff) 0\n⊢ Eq (s.prod fun i => f i).natDegree (s.sum fun i => (f i).natDegree)","decl":"/-- The degree of a product of polynomials is equal to\nthe sum of the degrees, provided that the product of leading coefficients is nonzero.\n\nSee `Polynomial.natDegree_prod` (without the `'`) for a version for integral domains,\nwhere this condition is automatically satisfied.\n-/\ntheorem natDegree_prod' (h : (∏ i ∈ s, (f i).leadingCoeff) ≠ 0) :\n    (∏ i ∈ s, f i).natDegree = ∑ i ∈ s, (f i).natDegree := by\n  simpa using natDegree_multiset_prod' (s.1.map f) (by simpa using h)\n\n"}
{"name":"Polynomial.natDegree_multiset_prod_of_monic","module":"Mathlib.Algebra.Polynomial.BigOperators","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nt : Multiset (Polynomial R)\nh : ∀ (f : Polynomial R), Membership.mem t f → f.Monic\n⊢ Eq t.prod.natDegree (Multiset.map Polynomial.natDegree t).sum","decl":"theorem natDegree_multiset_prod_of_monic (h : ∀ f ∈ t, Monic f) :\n    t.prod.natDegree = (t.map natDegree).sum := by\n  nontriviality R\n  apply natDegree_multiset_prod'\n  suffices (t.map fun f => leadingCoeff f).prod = 1 by\n    rw [this]\n    simp\n  convert prod_replicate (Multiset.card t) (1 : R)\n  · simp only [eq_replicate, Multiset.card_map, eq_self_iff_true, true_and]\n    rintro i hi\n    obtain ⟨i, hi, rfl⟩ := Multiset.mem_map.mp hi\n    apply h\n    assumption\n  · simp\n\n"}
{"name":"Polynomial.degree_multiset_prod_of_monic","module":"Mathlib.Algebra.Polynomial.BigOperators","initialProofState":"R : Type u\ninst✝¹ : CommSemiring R\nt : Multiset (Polynomial R)\ninst✝ : Nontrivial R\nh : ∀ (f : Polynomial R), Membership.mem t f → f.Monic\n⊢ Eq t.prod.degree (Multiset.map Polynomial.degree t).sum","decl":"theorem degree_multiset_prod_of_monic [Nontrivial R] (h : ∀ f ∈ t, Monic f) :\n    t.prod.degree = (t.map degree).sum := by\n  have : t.prod ≠ 0 := Monic.ne_zero <| by simpa using monic_multiset_prod_of_monic _ _ h\n  rw [degree_eq_natDegree this, natDegree_multiset_prod_of_monic _ h, Nat.cast_multiset_sum,\n    Multiset.map_map, Function.comp_def,\n    Multiset.map_congr rfl (fun f hf => (degree_eq_natDegree (h f hf).ne_zero).symm)]\n\n"}
{"name":"Polynomial.natDegree_prod_of_monic","module":"Mathlib.Algebra.Polynomial.BigOperators","initialProofState":"R : Type u\nι : Type w\ns : Finset ι\ninst✝ : CommSemiring R\nf : ι → Polynomial R\nh : ∀ (i : ι), Membership.mem s i → (f i).Monic\n⊢ Eq (s.prod fun i => f i).natDegree (s.sum fun i => (f i).natDegree)","decl":"theorem natDegree_prod_of_monic (h : ∀ i ∈ s, (f i).Monic) :\n    (∏ i ∈ s, f i).natDegree = ∑ i ∈ s, (f i).natDegree := by\n  simpa using natDegree_multiset_prod_of_monic (s.1.map f) (by simpa using h)\n\n"}
{"name":"Polynomial.degree_prod_of_monic","module":"Mathlib.Algebra.Polynomial.BigOperators","initialProofState":"R : Type u\nι : Type w\ns : Finset ι\ninst✝¹ : CommSemiring R\nf : ι → Polynomial R\ninst✝ : Nontrivial R\nh : ∀ (i : ι), Membership.mem s i → (f i).Monic\n⊢ Eq (s.prod fun i => f i).degree (s.sum fun i => (f i).degree)","decl":"theorem degree_prod_of_monic [Nontrivial R] (h : ∀ i ∈ s, (f i).Monic) :\n    (∏ i ∈ s, f i).degree = ∑ i ∈ s, (f i).degree := by\n  simpa using degree_multiset_prod_of_monic (s.1.map f) (by simpa using h)\n\n"}
{"name":"Polynomial.coeff_multiset_prod_of_natDegree_le","module":"Mathlib.Algebra.Polynomial.BigOperators","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nt : Multiset (Polynomial R)\nn : Nat\nhl : ∀ (p : Polynomial R), Membership.mem t p → LE.le p.natDegree n\n⊢ Eq (t.prod.coeff (HMul.hMul t.card n)) (Multiset.map (fun p => p.coeff n) t).prod","decl":"theorem coeff_multiset_prod_of_natDegree_le (n : ℕ) (hl : ∀ p ∈ t, natDegree p ≤ n) :\n    coeff t.prod ((Multiset.card t) * n) = (t.map fun p => coeff p n).prod := by\n  induction t using Quotient.inductionOn\n  simpa using coeff_list_prod_of_natDegree_le _ _ hl\n\n"}
{"name":"Polynomial.coeff_prod_of_natDegree_le","module":"Mathlib.Algebra.Polynomial.BigOperators","initialProofState":"R : Type u\nι : Type w\ns : Finset ι\ninst✝ : CommSemiring R\nf : ι → Polynomial R\nn : Nat\nh : ∀ (p : ι), Membership.mem s p → LE.le (f p).natDegree n\n⊢ Eq ((s.prod fun i => f i).coeff (HMul.hMul s.card n)) (s.prod fun i => (f i).coeff n)","decl":"theorem coeff_prod_of_natDegree_le (f : ι → R[X]) (n : ℕ) (h : ∀ p ∈ s, natDegree (f p) ≤ n) :\n    coeff (∏ i ∈ s, f i) (#s * n) = ∏ i ∈ s, coeff (f i) n := by\n  cases' s with l hl\n  convert coeff_multiset_prod_of_natDegree_le (l.map f) n ?_\n  · simp\n  · simp\n  · simpa using h\n\n"}
{"name":"Polynomial.coeff_zero_multiset_prod","module":"Mathlib.Algebra.Polynomial.BigOperators","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nt : Multiset (Polynomial R)\n⊢ Eq (t.prod.coeff 0) (Multiset.map (fun f => f.coeff 0) t).prod","decl":"theorem coeff_zero_multiset_prod : t.prod.coeff 0 = (t.map fun f => coeff f 0).prod := by\n  refine Multiset.induction_on t ?_ fun a t ht => ?_; · simp\n  rw [Multiset.prod_cons, Multiset.map_cons, Multiset.prod_cons, Polynomial.mul_coeff_zero, ht]\n\n"}
{"name":"Polynomial.coeff_zero_prod","module":"Mathlib.Algebra.Polynomial.BigOperators","initialProofState":"R : Type u\nι : Type w\ns : Finset ι\ninst✝ : CommSemiring R\nf : ι → Polynomial R\n⊢ Eq ((s.prod fun i => f i).coeff 0) (s.prod fun i => (f i).coeff 0)","decl":"theorem coeff_zero_prod : (∏ i ∈ s, f i).coeff 0 = ∏ i ∈ s, (f i).coeff 0 := by\n  simpa using coeff_zero_multiset_prod (s.1.map f)\n\n"}
{"name":"Polynomial.multiset_prod_X_sub_C_nextCoeff","module":"Mathlib.Algebra.Polynomial.BigOperators","initialProofState":"R : Type u\ninst✝ : CommRing R\nt : Multiset R\n⊢ Eq (Multiset.map (fun x => HSub.hSub Polynomial.X (Polynomial.C x)) t).prod.nextCoeff (Neg.neg t.sum)","decl":"theorem multiset_prod_X_sub_C_nextCoeff (t : Multiset R) :\n    nextCoeff (t.map fun x => X - C x).prod = -t.sum := by\n  rw [nextCoeff_multiset_prod]\n  · simp only [nextCoeff_X_sub_C]\n    exact t.sum_hom (-AddMonoidHom.id R)\n  · intros\n    apply monic_X_sub_C\n\n"}
{"name":"Polynomial.prod_X_sub_C_nextCoeff","module":"Mathlib.Algebra.Polynomial.BigOperators","initialProofState":"R : Type u\nι : Type w\ninst✝ : CommRing R\ns : Finset ι\nf : ι → R\n⊢ Eq (s.prod fun i => HSub.hSub Polynomial.X (Polynomial.C (f i))).nextCoeff (Neg.neg (s.sum fun i => f i))","decl":"theorem prod_X_sub_C_nextCoeff {s : Finset ι} (f : ι → R) :\n    nextCoeff (∏ i ∈ s, (X - C (f i))) = -∑ i ∈ s, f i := by\n  simpa using multiset_prod_X_sub_C_nextCoeff (s.1.map f)\n\n"}
{"name":"Polynomial.multiset_prod_X_sub_C_coeff_card_pred","module":"Mathlib.Algebra.Polynomial.BigOperators","initialProofState":"R : Type u\ninst✝ : CommRing R\nt : Multiset R\nht : LT.lt 0 t.card\n⊢ Eq ((Multiset.map (fun x => HSub.hSub Polynomial.X (Polynomial.C x)) t).prod.coeff (HSub.hSub t.card 1)) (Neg.neg t.sum)","decl":"theorem multiset_prod_X_sub_C_coeff_card_pred (t : Multiset R) (ht : 0 < Multiset.card t) :\n    (t.map fun x => X - C x).prod.coeff ((Multiset.card t) - 1) = -t.sum := by\n  nontriviality R\n  convert multiset_prod_X_sub_C_nextCoeff (by assumption)\n  rw [nextCoeff, if_neg]\n  swap\n  · rw [natDegree_multiset_prod_of_monic]\n    swap\n    · simp only [Multiset.mem_map]\n      rintro _ ⟨_, _, rfl⟩\n      apply monic_X_sub_C\n    simp_rw [Multiset.sum_eq_zero_iff, Multiset.mem_map]\n    obtain ⟨x, hx⟩ := card_pos_iff_exists_mem.mp ht\n    exact fun h => one_ne_zero <| h 1 ⟨_, ⟨x, hx, rfl⟩, natDegree_X_sub_C _⟩\n  congr; rw [natDegree_multiset_prod_of_monic] <;> · simp [natDegree_X_sub_C, monic_X_sub_C]\n\n"}
{"name":"Polynomial.prod_X_sub_C_coeff_card_pred","module":"Mathlib.Algebra.Polynomial.BigOperators","initialProofState":"R : Type u\nι : Type w\ninst✝ : CommRing R\ns : Finset ι\nf : ι → R\nhs : LT.lt 0 s.card\n⊢ Eq ((s.prod fun i => HSub.hSub Polynomial.X (Polynomial.C (f i))).coeff (HSub.hSub s.card 1)) (Neg.neg (s.sum fun i => f i))","decl":"theorem prod_X_sub_C_coeff_card_pred (s : Finset ι) (f : ι → R) (hs : 0 < #s) :\n    (∏ i ∈ s, (X - C (f i))).coeff (#s - 1) = -∑ i ∈ s, f i := by\n  simpa using multiset_prod_X_sub_C_coeff_card_pred (s.1.map f) (by simpa using hs)\n\n"}
{"name":"Polynomial.natDegree_multiset_prod_X_sub_C_eq_card","module":"Mathlib.Algebra.Polynomial.BigOperators","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\ns : Multiset R\n⊢ Eq (Multiset.map (fun x => HSub.hSub Polynomial.X (Polynomial.C x)) s).prod.natDegree s.card","decl":"@[simp]\nlemma natDegree_multiset_prod_X_sub_C_eq_card (s : Multiset R) :\n    (s.map (X - C ·)).prod.natDegree = Multiset.card s := by\n  rw [natDegree_multiset_prod_of_monic, Multiset.map_map]\n  · simp only [(· ∘ ·), natDegree_X_sub_C, Multiset.map_const', Multiset.sum_replicate, smul_eq_mul,\n      mul_one]\n  · exact Multiset.forall_mem_map_iff.2 fun a _ => monic_X_sub_C a\n\n"}
{"name":"Polynomial.degree_list_prod","module":"Mathlib.Algebra.Polynomial.BigOperators","initialProofState":"R : Type u\ninst✝² : Semiring R\ninst✝¹ : NoZeroDivisors R\ninst✝ : Nontrivial R\nl : List (Polynomial R)\n⊢ Eq l.prod.degree (List.map Polynomial.degree l).sum","decl":"/-- The degree of a product of polynomials is equal to\nthe sum of the degrees, where the degree of the zero polynomial is ⊥.\n`[Nontrivial R]` is needed, otherwise for `l = []` we have `⊥` in the LHS and `0` in the RHS.\n-/\ntheorem degree_list_prod [Nontrivial R] (l : List R[X]) : l.prod.degree = (l.map degree).sum :=\n  map_list_prod (@degreeMonoidHom R _ _ _) l\n\n"}
{"name":"Polynomial.natDegree_prod","module":"Mathlib.Algebra.Polynomial.BigOperators","initialProofState":"R : Type u\nι : Type w\ns : Finset ι\ninst✝¹ : CommSemiring R\ninst✝ : NoZeroDivisors R\nf : ι → Polynomial R\nh : ∀ (i : ι), Membership.mem s i → Ne (f i) 0\n⊢ Eq (s.prod fun i => f i).natDegree (s.sum fun i => (f i).natDegree)","decl":"/-- The degree of a product of polynomials is equal to\nthe sum of the degrees.\n\nSee `Polynomial.natDegree_prod'` (with a `'`) for a version for commutative semirings,\nwhere additionally, the product of the leading coefficients must be nonzero.\n-/\ntheorem natDegree_prod (h : ∀ i ∈ s, f i ≠ 0) :\n    (∏ i ∈ s, f i).natDegree = ∑ i ∈ s, (f i).natDegree := by\n  nontriviality R\n  apply natDegree_prod'\n  rw [prod_ne_zero_iff]\n  intro x hx; simp [h x hx]\n\n"}
{"name":"Polynomial.natDegree_multiset_prod","module":"Mathlib.Algebra.Polynomial.BigOperators","initialProofState":"R : Type u\ninst✝¹ : CommSemiring R\ninst✝ : NoZeroDivisors R\nt : Multiset (Polynomial R)\nh : Not (Membership.mem t 0)\n⊢ Eq t.prod.natDegree (Multiset.map Polynomial.natDegree t).sum","decl":"theorem natDegree_multiset_prod (h : (0 : R[X]) ∉ t) :\n    natDegree t.prod = (t.map natDegree).sum := by\n  nontriviality R\n  rw [natDegree_multiset_prod']\n  simp_rw [Ne, Multiset.prod_eq_zero_iff, Multiset.mem_map, leadingCoeff_eq_zero]\n  rintro ⟨_, h, rfl⟩\n  contradiction\n\n"}
{"name":"Polynomial.degree_multiset_prod","module":"Mathlib.Algebra.Polynomial.BigOperators","initialProofState":"R : Type u\ninst✝² : CommSemiring R\ninst✝¹ : NoZeroDivisors R\nt : Multiset (Polynomial R)\ninst✝ : Nontrivial R\n⊢ Eq t.prod.degree (Multiset.map (fun f => f.degree) t).sum","decl":"/-- The degree of a product of polynomials is equal to\nthe sum of the degrees, where the degree of the zero polynomial is ⊥.\n-/\ntheorem degree_multiset_prod [Nontrivial R] : t.prod.degree = (t.map fun f => degree f).sum :=\n  map_multiset_prod (@degreeMonoidHom R _ _ _) _\n\n"}
{"name":"Polynomial.degree_prod","module":"Mathlib.Algebra.Polynomial.BigOperators","initialProofState":"R : Type u\nι : Type w\ns : Finset ι\ninst✝² : CommSemiring R\ninst✝¹ : NoZeroDivisors R\nf : ι → Polynomial R\ninst✝ : Nontrivial R\n⊢ Eq (s.prod fun i => f i).degree (s.sum fun i => (f i).degree)","decl":"/-- The degree of a product of polynomials is equal to\nthe sum of the degrees, where the degree of the zero polynomial is ⊥.\n-/\ntheorem degree_prod [Nontrivial R] : (∏ i ∈ s, f i).degree = ∑ i ∈ s, (f i).degree :=\n  map_prod (@degreeMonoidHom R _ _ _) _ _\n\n"}
{"name":"Polynomial.leadingCoeff_multiset_prod","module":"Mathlib.Algebra.Polynomial.BigOperators","initialProofState":"R : Type u\ninst✝¹ : CommSemiring R\ninst✝ : NoZeroDivisors R\nt : Multiset (Polynomial R)\n⊢ Eq t.prod.leadingCoeff (Multiset.map (fun f => f.leadingCoeff) t).prod","decl":"/-- The leading coefficient of a product of polynomials is equal to\nthe product of the leading coefficients.\n\nSee `Polynomial.leadingCoeff_multiset_prod'` (with a `'`) for a version for commutative semirings,\nwhere additionally, the product of the leading coefficients must be nonzero.\n-/\ntheorem leadingCoeff_multiset_prod :\n    t.prod.leadingCoeff = (t.map fun f => leadingCoeff f).prod := by\n  rw [← leadingCoeffHom_apply, MonoidHom.map_multiset_prod]\n  simp only [leadingCoeffHom_apply]\n\n"}
{"name":"Polynomial.leadingCoeff_prod","module":"Mathlib.Algebra.Polynomial.BigOperators","initialProofState":"R : Type u\nι : Type w\ns : Finset ι\ninst✝¹ : CommSemiring R\ninst✝ : NoZeroDivisors R\nf : ι → Polynomial R\n⊢ Eq (s.prod fun i => f i).leadingCoeff (s.prod fun i => (f i).leadingCoeff)","decl":"/-- The leading coefficient of a product of polynomials is equal to\nthe product of the leading coefficients.\n\nSee `Polynomial.leadingCoeff_prod'` (with a `'`) for a version for commutative semirings,\nwhere additionally, the product of the leading coefficients must be nonzero.\n-/\ntheorem leadingCoeff_prod : (∏ i ∈ s, f i).leadingCoeff = ∏ i ∈ s, (f i).leadingCoeff := by\n  simpa using leadingCoeff_multiset_prod (s.1.map f)\n\n"}
