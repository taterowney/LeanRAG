{"name":"Filter.atTop.isCountablyGenerated","module":"Mathlib.Order.Filter.AtTopBot.CountablyGenerated","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : Countable α\n⊢ Filter.atTop.IsCountablyGenerated","decl":"instance (priority := 200) atTop.isCountablyGenerated [Preorder α] [Countable α] :\n    (atTop : Filter <| α).IsCountablyGenerated :=\n  isCountablyGenerated_seq _\n\n"}
{"name":"Filter.atBot.isCountablyGenerated","module":"Mathlib.Order.Filter.AtTopBot.CountablyGenerated","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : Countable α\n⊢ Filter.atBot.IsCountablyGenerated","decl":"instance (priority := 200) atBot.isCountablyGenerated [Preorder α] [Countable α] :\n    (atBot : Filter <| α).IsCountablyGenerated :=\n  isCountablyGenerated_seq _\n\n"}
{"name":"Filter.instIsCountablyGeneratedAtTopProd","module":"Mathlib.Order.Filter.AtTopBot.CountablyGenerated","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Preorder α\ninst✝² : Filter.atTop.IsCountablyGenerated\ninst✝¹ : Preorder β\ninst✝ : Filter.atTop.IsCountablyGenerated\n⊢ Filter.atTop.IsCountablyGenerated","decl":"instance instIsCountablyGeneratedAtTopProd [Preorder α] [IsCountablyGenerated (atTop : Filter α)]\n    [Preorder β] [IsCountablyGenerated (atTop : Filter β)] :\n    IsCountablyGenerated (atTop : Filter (α × β)) := by\n  rw [← prod_atTop_atTop_eq]\n  infer_instance\n\n"}
{"name":"Filter.instIsCountablyGeneratedAtBotProd","module":"Mathlib.Order.Filter.AtTopBot.CountablyGenerated","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Preorder α\ninst✝² : Filter.atBot.IsCountablyGenerated\ninst✝¹ : Preorder β\ninst✝ : Filter.atBot.IsCountablyGenerated\n⊢ Filter.atBot.IsCountablyGenerated","decl":"instance instIsCountablyGeneratedAtBotProd [Preorder α] [IsCountablyGenerated (atBot : Filter α)]\n    [Preorder β] [IsCountablyGenerated (atBot : Filter β)] :\n    IsCountablyGenerated (atBot : Filter (α × β)) := by\n  rw [← prod_atBot_atBot_eq]\n  infer_instance\n\n"}
{"name":"OrderDual.instIsCountablyGeneratedAtTop","module":"Mathlib.Order.Filter.AtTopBot.CountablyGenerated","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : Filter.atBot.IsCountablyGenerated\n⊢ Filter.atTop.IsCountablyGenerated","decl":"instance _root_.OrderDual.instIsCountablyGeneratedAtTop [Preorder α]\n    [IsCountablyGenerated (atBot : Filter α)] : IsCountablyGenerated (atTop : Filter αᵒᵈ) := ‹_›\n\n"}
{"name":"OrderDual.instIsCountablyGeneratedAtBot","module":"Mathlib.Order.Filter.AtTopBot.CountablyGenerated","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : Filter.atTop.IsCountablyGenerated\n⊢ Filter.atBot.IsCountablyGenerated","decl":"instance _root_.OrderDual.instIsCountablyGeneratedAtBot [Preorder α]\n    [IsCountablyGenerated (atTop : Filter α)] : IsCountablyGenerated (atBot : Filter αᵒᵈ) := ‹_›\n\n"}
{"name":"Filter.atTop_countable_basis","module":"Mathlib.Order.Filter.AtTopBot.CountablyGenerated","initialProofState":"α : Type u_1\ninst✝³ : Preorder α\ninst✝² : IsDirected α fun x1 x2 => LE.le x1 x2\ninst✝¹ : Nonempty α\ninst✝ : Countable α\n⊢ Filter.atTop.HasCountableBasis (fun x => True) Set.Ici","decl":"lemma atTop_countable_basis [Preorder α] [IsDirected α (· ≤ ·)] [Nonempty α] [Countable α] :\n    HasCountableBasis (atTop : Filter α) (fun _ => True) Ici :=\n  { atTop_basis with countable := to_countable _ }\n\n"}
{"name":"Filter.atBot_countable_basis","module":"Mathlib.Order.Filter.AtTopBot.CountablyGenerated","initialProofState":"α : Type u_1\ninst✝³ : Preorder α\ninst✝² : IsDirected α fun x1 x2 => GE.ge x1 x2\ninst✝¹ : Nonempty α\ninst✝ : Countable α\n⊢ Filter.atBot.HasCountableBasis (fun x => True) Set.Iic","decl":"lemma atBot_countable_basis [Preorder α] [IsDirected α (· ≥ ·)] [Nonempty α] [Countable α] :\n    HasCountableBasis (atBot : Filter α) (fun _ => True) Iic :=\n  { atBot_basis with countable := to_countable _ }\n\n"}
{"name":"Filter.exists_seq_tendsto","module":"Mathlib.Order.Filter.AtTopBot.CountablyGenerated","initialProofState":"α : Type u_1\nf : Filter α\ninst✝¹ : f.IsCountablyGenerated\ninst✝ : f.NeBot\n⊢ Exists fun x => Filter.Tendsto x Filter.atTop f","decl":"/-- If `f` is a nontrivial countably generated filter, then there exists a sequence that converges\nto `f`. -/\ntheorem exists_seq_tendsto (f : Filter α) [IsCountablyGenerated f] [NeBot f] :\n    ∃ x : ℕ → α, Tendsto x atTop f := by\n  obtain ⟨B, h⟩ := f.exists_antitone_basis\n  choose x hx using fun n => Filter.nonempty_of_mem (h.mem n)\n  exact ⟨x, h.tendsto hx⟩\n\n"}
{"name":"Filter.exists_seq_monotone_tendsto_atTop_atTop","module":"Mathlib.Order.Filter.AtTopBot.CountablyGenerated","initialProofState":"α : Type u_3\ninst✝³ : Preorder α\ninst✝² : Nonempty α\ninst✝¹ : IsDirected α fun x1 x2 => LE.le x1 x2\ninst✝ : Filter.atTop.IsCountablyGenerated\n⊢ Exists fun xs => And (Monotone xs) (Filter.Tendsto xs Filter.atTop Filter.atTop)","decl":"theorem exists_seq_monotone_tendsto_atTop_atTop (α : Type*) [Preorder α] [Nonempty α]\n    [IsDirected α (· ≤ ·)] [(atTop : Filter α).IsCountablyGenerated] :\n    ∃ xs : ℕ → α, Monotone xs ∧ Tendsto xs atTop atTop := by\n  obtain ⟨ys, h⟩ := exists_seq_tendsto (atTop : Filter α)\n  choose c hleft hright using exists_ge_ge (α := α)\n  set xs : ℕ → α := fun n => (List.range n).foldl (fun x n ↦ c x (ys n)) (ys 0)\n  have hsucc (n : ℕ) : xs (n + 1) = c (xs n) (ys n) := by simp [xs, List.range_succ]\n  refine ⟨xs, ?_, ?_⟩\n  · refine monotone_nat_of_le_succ fun n ↦ ?_\n    rw [hsucc]\n    apply hleft\n  · refine (tendsto_add_atTop_iff_nat 1).1 <| tendsto_atTop_mono (fun n ↦ ?_) h\n    rw [hsucc]\n    apply hright\n\n"}
{"name":"Filter.exists_seq_antitone_tendsto_atTop_atBot","module":"Mathlib.Order.Filter.AtTopBot.CountablyGenerated","initialProofState":"α : Type u_3\ninst✝³ : Preorder α\ninst✝² : Nonempty α\ninst✝¹ : IsDirected α fun x1 x2 => GE.ge x1 x2\ninst✝ : Filter.atBot.IsCountablyGenerated\n⊢ Exists fun xs => And (Antitone xs) (Filter.Tendsto xs Filter.atTop Filter.atBot)","decl":"theorem exists_seq_antitone_tendsto_atTop_atBot (α : Type*) [Preorder α] [Nonempty α]\n    [IsDirected α (· ≥ ·)] [(atBot : Filter α).IsCountablyGenerated] :\n    ∃ xs : ℕ → α, Antitone xs ∧ Tendsto xs atTop atBot :=\n  exists_seq_monotone_tendsto_atTop_atTop αᵒᵈ\n\n"}
{"name":"Filter.tendsto_iff_seq_tendsto","module":"Mathlib.Order.Filter.AtTopBot.CountablyGenerated","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nk : Filter α\nl : Filter β\ninst✝ : k.IsCountablyGenerated\n⊢ Iff (Filter.Tendsto f k l) (∀ (x : Nat → α), Filter.Tendsto x Filter.atTop k → Filter.Tendsto (Function.comp f x) Filter.atTop l)","decl":"/-- An abstract version of continuity of sequentially continuous functions on metric spaces:\nif a filter `k` is countably generated then `Tendsto f k l` iff for every sequence `u`\nconverging to `k`, `f ∘ u` tends to `l`. -/\ntheorem tendsto_iff_seq_tendsto {f : α → β} {k : Filter α} {l : Filter β} [k.IsCountablyGenerated] :\n    Tendsto f k l ↔ ∀ x : ℕ → α, Tendsto x atTop k → Tendsto (f ∘ x) atTop l := by\n  refine ⟨fun h x hx => h.comp hx, fun H s hs => ?_⟩\n  contrapose! H\n  have : NeBot (k ⊓ 𝓟 (f ⁻¹' sᶜ)) := by simpa [neBot_iff, inf_principal_eq_bot]\n  rcases (k ⊓ 𝓟 (f ⁻¹' sᶜ)).exists_seq_tendsto with ⟨x, hx⟩\n  rw [tendsto_inf, tendsto_principal] at hx\n  refine ⟨x, hx.1, fun h => ?_⟩\n  rcases (hx.2.and (h hs)).exists with ⟨N, hnmem, hmem⟩\n  exact hnmem hmem\n\n"}
{"name":"Filter.tendsto_of_seq_tendsto","module":"Mathlib.Order.Filter.AtTopBot.CountablyGenerated","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nk : Filter α\nl : Filter β\ninst✝ : k.IsCountablyGenerated\na✝ : ∀ (x : Nat → α), Filter.Tendsto x Filter.atTop k → Filter.Tendsto (Function.comp f x) Filter.atTop l\n⊢ Filter.Tendsto f k l","decl":"theorem tendsto_of_seq_tendsto {f : α → β} {k : Filter α} {l : Filter β} [k.IsCountablyGenerated] :\n    (∀ x : ℕ → α, Tendsto x atTop k → Tendsto (f ∘ x) atTop l) → Tendsto f k l :=\n  tendsto_iff_seq_tendsto.2\n\n"}
{"name":"Filter.eventually_iff_seq_eventually","module":"Mathlib.Order.Filter.AtTopBot.CountablyGenerated","initialProofState":"ι : Type u_3\nl : Filter ι\np : ι → Prop\ninst✝ : l.IsCountablyGenerated\n⊢ Iff (Filter.Eventually (fun n => p n) l) (∀ (x : Nat → ι), Filter.Tendsto x Filter.atTop l → Filter.Eventually (fun n => p (x n)) Filter.atTop)","decl":"theorem eventually_iff_seq_eventually {ι : Type*} {l : Filter ι} {p : ι → Prop}\n    [l.IsCountablyGenerated] :\n    (∀ᶠ n in l, p n) ↔ ∀ x : ℕ → ι, Tendsto x atTop l → ∀ᶠ n : ℕ in atTop, p (x n) := by\n  simpa using tendsto_iff_seq_tendsto (f := id) (l := 𝓟 {x | p x})\n\n"}
{"name":"Filter.frequently_iff_seq_frequently","module":"Mathlib.Order.Filter.AtTopBot.CountablyGenerated","initialProofState":"ι : Type u_3\nl : Filter ι\np : ι → Prop\ninst✝ : l.IsCountablyGenerated\n⊢ Iff (Filter.Frequently (fun n => p n) l) (Exists fun x => And (Filter.Tendsto x Filter.atTop l) (Filter.Frequently (fun n => p (x n)) Filter.atTop))","decl":"theorem frequently_iff_seq_frequently {ι : Type*} {l : Filter ι} {p : ι → Prop}\n    [l.IsCountablyGenerated] :\n    (∃ᶠ n in l, p n) ↔ ∃ x : ℕ → ι, Tendsto x atTop l ∧ ∃ᶠ n : ℕ in atTop, p (x n) := by\n  simp only [Filter.Frequently, eventually_iff_seq_eventually (l := l)]\n  push_neg; rfl\n\n"}
{"name":"Filter.exists_seq_forall_of_frequently","module":"Mathlib.Order.Filter.AtTopBot.CountablyGenerated","initialProofState":"ι : Type u_3\nl : Filter ι\np : ι → Prop\ninst✝ : l.IsCountablyGenerated\nh : Filter.Frequently (fun n => p n) l\n⊢ Exists fun ns => And (Filter.Tendsto ns Filter.atTop l) (∀ (n : Nat), p (ns n))","decl":"theorem exists_seq_forall_of_frequently {ι : Type*} {l : Filter ι} {p : ι → Prop}\n    [l.IsCountablyGenerated] (h : ∃ᶠ n in l, p n) :\n    ∃ ns : ℕ → ι, Tendsto ns atTop l ∧ ∀ n, p (ns n) := by\n  rw [frequently_iff_seq_frequently] at h\n  obtain ⟨x, hx_tendsto, hx_freq⟩ := h\n  obtain ⟨n_to_n, h_tendsto, h_freq⟩ := subseq_forall_of_frequently hx_tendsto hx_freq\n  exact ⟨x ∘ n_to_n, h_tendsto, h_freq⟩\n\n"}
{"name":"Filter.frequently_iff_seq_forall","module":"Mathlib.Order.Filter.AtTopBot.CountablyGenerated","initialProofState":"ι : Type u_3\nl : Filter ι\np : ι → Prop\ninst✝ : l.IsCountablyGenerated\n⊢ Iff (Filter.Frequently (fun n => p n) l) (Exists fun ns => And (Filter.Tendsto ns Filter.atTop l) (∀ (n : Nat), p (ns n)))","decl":"lemma frequently_iff_seq_forall {ι : Type*} {l : Filter ι} {p : ι → Prop}\n    [l.IsCountablyGenerated] :\n    (∃ᶠ n in l, p n) ↔ ∃ ns : ℕ → ι, Tendsto ns atTop l ∧ ∀ n, p (ns n) :=\n  ⟨exists_seq_forall_of_frequently, fun ⟨_ns, hnsl, hpns⟩ ↦\n    hnsl.frequently <| Frequently.of_forall hpns⟩\n\n"}
{"name":"Filter.tendsto_of_subseq_tendsto","module":"Mathlib.Order.Filter.AtTopBot.CountablyGenerated","initialProofState":"α : Type u_1\nι : Type u_3\nx : ι → α\nf : Filter α\nl : Filter ι\ninst✝ : l.IsCountablyGenerated\nhxy : ∀ (ns : Nat → ι), Filter.Tendsto ns Filter.atTop l → Exists fun ms => Filter.Tendsto (fun n => x (ns (ms n))) Filter.atTop f\n⊢ Filter.Tendsto x l f","decl":"/-- A sequence converges if every subsequence has a convergent subsequence. -/\ntheorem tendsto_of_subseq_tendsto {ι : Type*} {x : ι → α} {f : Filter α} {l : Filter ι}\n    [l.IsCountablyGenerated]\n    (hxy : ∀ ns : ℕ → ι, Tendsto ns atTop l →\n      ∃ ms : ℕ → ℕ, Tendsto (fun n => x (ns <| ms n)) atTop f) :\n    Tendsto x l f := by\n  contrapose! hxy\n  obtain ⟨s, hs, hfreq⟩ : ∃ s ∈ f, ∃ᶠ n in l, x n ∉ s := by\n    rwa [not_tendsto_iff_exists_frequently_nmem] at hxy\n  obtain ⟨y, hy_tendsto, hy_freq⟩ := exists_seq_forall_of_frequently hfreq\n  refine ⟨y, hy_tendsto, fun ms hms_tendsto ↦ ?_⟩\n  rcases (hms_tendsto.eventually_mem hs).exists with ⟨n, hn⟩\n  exact absurd hn <| hy_freq _\n\n"}
{"name":"Filter.subseq_tendsto_of_neBot","module":"Mathlib.Order.Filter.AtTopBot.CountablyGenerated","initialProofState":"α : Type u_1\nf : Filter α\ninst✝ : f.IsCountablyGenerated\nu : Nat → α\nhx : (Min.min f (Filter.map u Filter.atTop)).NeBot\n⊢ Exists fun θ => And (StrictMono θ) (Filter.Tendsto (Function.comp u θ) Filter.atTop f)","decl":"theorem subseq_tendsto_of_neBot {f : Filter α} [IsCountablyGenerated f] {u : ℕ → α}\n    (hx : NeBot (f ⊓ map u atTop)) : ∃ θ : ℕ → ℕ, StrictMono θ ∧ Tendsto (u ∘ θ) atTop f := by\n  rw [← Filter.push_pull', map_neBot_iff] at hx\n  rcases exists_seq_tendsto (comap u f ⊓ atTop) with ⟨φ, hφ⟩\n  rw [tendsto_inf, tendsto_comap_iff] at hφ\n  obtain ⟨ψ, hψ, hψφ⟩ : ∃ ψ : ℕ → ℕ, StrictMono ψ ∧ StrictMono (φ ∘ ψ) :=\n    strictMono_subseq_of_tendsto_atTop hφ.2\n  exact ⟨φ ∘ ψ, hψφ, hφ.1.comp hψ.tendsto_atTop⟩\n\n"}
