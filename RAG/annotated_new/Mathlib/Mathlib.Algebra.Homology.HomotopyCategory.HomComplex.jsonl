{"name":"CochainComplex.HomComplex.Triplet.hpq","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"n : Int\nself : CochainComplex.HomComplex.Triplet n\n‚ä¢ Eq (HAdd.hAdd self.p n) self.q","decl":"/-- A term of type `HomComplex.Triplet n` consists of two integers `p` and `q`\nsuch that `p + n = q`. (This type is introduced so that the instance\n`AddCommGroup (Cochain F G n)` defined below can be found automatically.) -/\nstructure Triplet (n : ‚Ñ§) where\n  /-- a first integer -/\n  p : ‚Ñ§\n  /-- a second integer -/\n  q : ‚Ñ§\n  /-- the condition on the two integers -/\n  hpq : p + n = q\n\n"}
{"name":"CochainComplex.HomComplex.Triplet.mk.inj","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"n p‚úù q‚úù : Int\nhpq‚úù : Eq (HAdd.hAdd p‚úù n) q‚úù\np q : Int\nhpq : Eq (HAdd.hAdd p n) q\nx‚úù : Eq { p := p‚úù, q := q‚úù, hpq := hpq‚úù } { p := p, q := q, hpq := hpq }\n‚ä¢ And (Eq p‚úù p) (Eq q‚úù q)","decl":"/-- A term of type `HomComplex.Triplet n` consists of two integers `p` and `q`\nsuch that `p + n = q`. (This type is introduced so that the instance\n`AddCommGroup (Cochain F G n)` defined below can be found automatically.) -/\nstructure Triplet (n : ‚Ñ§) where\n  /-- a first integer -/\n  p : ‚Ñ§\n  /-- a second integer -/\n  q : ‚Ñ§\n  /-- the condition on the two integers -/\n  hpq : p + n = q\n\n"}
{"name":"CochainComplex.HomComplex.Triplet.mk.injEq","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"n p‚úù q‚úù : Int\nhpq‚úù : Eq (HAdd.hAdd p‚úù n) q‚úù\np q : Int\nhpq : Eq (HAdd.hAdd p n) q\n‚ä¢ Eq (Eq { p := p‚úù, q := q‚úù, hpq := hpq‚úù } { p := p, q := q, hpq := hpq }) (And (Eq p‚úù p) (Eq q‚úù q))","decl":"/-- A term of type `HomComplex.Triplet n` consists of two integers `p` and `q`\nsuch that `p + n = q`. (This type is introduced so that the instance\n`AddCommGroup (Cochain F G n)` defined below can be found automatically.) -/\nstructure Triplet (n : ‚Ñ§) where\n  /-- a first integer -/\n  p : ‚Ñ§\n  /-- a second integer -/\n  q : ‚Ñ§\n  /-- the condition on the two integers -/\n  hpq : p + n = q\n\n"}
{"name":"CochainComplex.HomComplex.Triplet.mk.sizeOf_spec","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"n p q : Int\nhpq : Eq (HAdd.hAdd p n) q\n‚ä¢ Eq (SizeOf.sizeOf { p := p, q := q, hpq := hpq }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf p)) (SizeOf.sizeOf q)) (SizeOf.sizeOf hpq))","decl":"/-- A term of type `HomComplex.Triplet n` consists of two integers `p` and `q`\nsuch that `p + n = q`. (This type is introduced so that the instance\n`AddCommGroup (Cochain F G n)` defined below can be found automatically.) -/\nstructure Triplet (n : ‚Ñ§) where\n  /-- a first integer -/\n  p : ‚Ñ§\n  /-- a second integer -/\n  q : ‚Ñ§\n  /-- the condition on the two integers -/\n  hpq : p + n = q\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.mk_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nn : Int\nv : (p q : Int) ‚Üí Eq (HAdd.hAdd p n) q ‚Üí Quiver.Hom (F.X p) (G.X q)\np q : Int\nhpq : Eq (HAdd.hAdd p n) q\n‚ä¢ Eq ((CochainComplex.HomComplex.Cochain.mk v).v p q hpq) (v p q hpq)","decl":"@[simp]\nlemma mk_v (v : ‚àÄ (p q : ‚Ñ§) (_ : p + n = q), F.X p ‚ü∂ G.X q) (p q : ‚Ñ§) (hpq : p + n = q) :\n    (Cochain.mk v).v p q hpq = v p q hpq := rfl\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.congr_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nn : Int\nz‚ÇÅ z‚ÇÇ : CochainComplex.HomComplex.Cochain F G n\nh : Eq z‚ÇÅ z‚ÇÇ\np q : Int\nhpq : Eq (HAdd.hAdd p n) q\n‚ä¢ Eq (z‚ÇÅ.v p q hpq) (z‚ÇÇ.v p q hpq)","decl":"lemma congr_v {z‚ÇÅ z‚ÇÇ : Cochain F G n} (h : z‚ÇÅ = z‚ÇÇ) (p q : ‚Ñ§) (hpq : p + n = q) :\n    z‚ÇÅ.v p q hpq = z‚ÇÇ.v p q hpq := by subst h; rfl\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.ext","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nn : Int\nz‚ÇÅ z‚ÇÇ : CochainComplex.HomComplex.Cochain F G n\nh : ‚àÄ (p q : Int) (hpq : Eq (HAdd.hAdd p n) q), Eq (z‚ÇÅ.v p q hpq) (z‚ÇÇ.v p q hpq)\n‚ä¢ Eq z‚ÇÅ z‚ÇÇ","decl":"@[ext]\nlemma ext (z‚ÇÅ z‚ÇÇ : Cochain F G n)\n    (h : ‚àÄ (p q hpq), z‚ÇÅ.v p q hpq = z‚ÇÇ.v p q hpq) : z‚ÇÅ = z‚ÇÇ := by\n  funext ‚ü®p, q, hpq‚ü©\n  apply h\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.ext_iff","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nn : Int\nz‚ÇÅ z‚ÇÇ : CochainComplex.HomComplex.Cochain F G n\n‚ä¢ Iff (Eq z‚ÇÅ z‚ÇÇ) (‚àÄ (p q : Int) (hpq : Eq (HAdd.hAdd p n) q), Eq (z‚ÇÅ.v p q hpq) (z‚ÇÇ.v p q hpq))","decl":"@[ext]\nlemma ext (z‚ÇÅ z‚ÇÇ : Cochain F G n)\n    (h : ‚àÄ (p q hpq), z‚ÇÅ.v p q hpq = z‚ÇÇ.v p q hpq) : z‚ÇÅ = z‚ÇÇ := by\n  funext ‚ü®p, q, hpq‚ü©\n  apply h\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.ext‚ÇÄ_iff","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nz‚ÇÅ z‚ÇÇ : CochainComplex.HomComplex.Cochain F G 0\n‚ä¢ Iff (Eq z‚ÇÅ z‚ÇÇ) (‚àÄ (p : Int), Eq (z‚ÇÅ.v p p ‚ãØ) (z‚ÇÇ.v p p ‚ãØ))","decl":"@[ext 1100]\nlemma ext‚ÇÄ (z‚ÇÅ z‚ÇÇ : Cochain F G 0)\n    (h : ‚àÄ (p : ‚Ñ§), z‚ÇÅ.v p p (add_zero p) = z‚ÇÇ.v p p (add_zero p)) : z‚ÇÅ = z‚ÇÇ := by\n  ext p q hpq\n  obtain rfl : q = p := by rw [‚Üê hpq, add_zero]\n  exact h q\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.ext‚ÇÄ","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nz‚ÇÅ z‚ÇÇ : CochainComplex.HomComplex.Cochain F G 0\nh : ‚àÄ (p : Int), Eq (z‚ÇÅ.v p p ‚ãØ) (z‚ÇÇ.v p p ‚ãØ)\n‚ä¢ Eq z‚ÇÅ z‚ÇÇ","decl":"@[ext 1100]\nlemma ext‚ÇÄ (z‚ÇÅ z‚ÇÇ : Cochain F G 0)\n    (h : ‚àÄ (p : ‚Ñ§), z‚ÇÅ.v p p (add_zero p) = z‚ÇÇ.v p p (add_zero p)) : z‚ÇÅ = z‚ÇÇ := by\n  ext p q hpq\n  obtain rfl : q = p := by rw [‚Üê hpq, add_zero]\n  exact h q\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.zero_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nn p q : Int\nhpq : Eq (HAdd.hAdd p n) q\n‚ä¢ Eq (CochainComplex.HomComplex.Cochain.v 0 p q hpq) 0","decl":"@[simp]\nlemma zero_v {n : ‚Ñ§} (p q : ‚Ñ§) (hpq : p + n = q) :\n    (0 : Cochain F G n).v p q hpq = 0 := rfl\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.add_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nn : Int\nz‚ÇÅ z‚ÇÇ : CochainComplex.HomComplex.Cochain F G n\np q : Int\nhpq : Eq (HAdd.hAdd p n) q\n‚ä¢ Eq ((HAdd.hAdd z‚ÇÅ z‚ÇÇ).v p q hpq) (HAdd.hAdd (z‚ÇÅ.v p q hpq) (z‚ÇÇ.v p q hpq))","decl":"@[simp]\nlemma add_v {n : ‚Ñ§} (z‚ÇÅ z‚ÇÇ : Cochain F G n) (p q : ‚Ñ§) (hpq : p + n = q) :\n    (z‚ÇÅ + z‚ÇÇ).v p q hpq = z‚ÇÅ.v p q hpq + z‚ÇÇ.v p q hpq := rfl\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.sub_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nn : Int\nz‚ÇÅ z‚ÇÇ : CochainComplex.HomComplex.Cochain F G n\np q : Int\nhpq : Eq (HAdd.hAdd p n) q\n‚ä¢ Eq ((HSub.hSub z‚ÇÅ z‚ÇÇ).v p q hpq) (HSub.hSub (z‚ÇÅ.v p q hpq) (z‚ÇÇ.v p q hpq))","decl":"@[simp]\nlemma sub_v {n : ‚Ñ§} (z‚ÇÅ z‚ÇÇ : Cochain F G n) (p q : ‚Ñ§) (hpq : p + n = q) :\n    (z‚ÇÅ - z‚ÇÇ).v p q hpq = z‚ÇÅ.v p q hpq - z‚ÇÇ.v p q hpq := rfl\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.neg_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nn : Int\nz : CochainComplex.HomComplex.Cochain F G n\np q : Int\nhpq : Eq (HAdd.hAdd p n) q\n‚ä¢ Eq ((Neg.neg z).v p q hpq) (Neg.neg (z.v p q hpq))","decl":"@[simp]\nlemma neg_v {n : ‚Ñ§} (z : Cochain F G n) (p q : ‚Ñ§) (hpq : p + n = q) :\n    (-z).v p q hpq = - (z.v p q hpq) := rfl\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.smul_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Preadditive C\nR : Type u_1\ninst‚úù¬π : Ring R\ninst‚úù : CategoryTheory.Linear R C\nF G : CochainComplex C Int\nn : Int\nk : R\nz : CochainComplex.HomComplex.Cochain F G n\np q : Int\nhpq : Eq (HAdd.hAdd p n) q\n‚ä¢ Eq ((HSMul.hSMul k z).v p q hpq) (HSMul.hSMul k (z.v p q hpq))","decl":"@[simp]\nlemma smul_v {n : ‚Ñ§} (k : R) (z : Cochain F G n) (p q : ‚Ñ§) (hpq : p + n = q) :\n    (k ‚Ä¢ z).v p q hpq = k ‚Ä¢ (z.v p q hpq) := rfl\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.units_smul_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Preadditive C\nR : Type u_1\ninst‚úù¬π : Ring R\ninst‚úù : CategoryTheory.Linear R C\nF G : CochainComplex C Int\nn : Int\nk : Units R\nz : CochainComplex.HomComplex.Cochain F G n\np q : Int\nhpq : Eq (HAdd.hAdd p n) q\n‚ä¢ Eq ((HSMul.hSMul k z).v p q hpq) (HSMul.hSMul k (z.v p q hpq))","decl":"@[simp]\nlemma units_smul_v {n : ‚Ñ§} (k : RÀ£) (z : Cochain F G n) (p q : ‚Ñ§) (hpq : p + n = q) :\n    (k ‚Ä¢ z).v p q hpq = k ‚Ä¢ (z.v p q hpq) := rfl\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.ofHoms_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nœà : (p : Int) ‚Üí Quiver.Hom (F.X p) (G.X p)\np : Int\n‚ä¢ Eq ((CochainComplex.HomComplex.Cochain.ofHoms œà).v p p ‚ãØ) (œà p)","decl":"@[simp]\nlemma ofHoms_v (œà : ‚àÄ (p : ‚Ñ§), F.X p ‚ü∂ G.X p) (p : ‚Ñ§) :\n    (ofHoms œà).v p p (add_zero p) = œà p := by\n  simp only [ofHoms, mk_v, eqToHom_refl, comp_id]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.ofHoms_zero","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\n‚ä¢ Eq (CochainComplex.HomComplex.Cochain.ofHoms fun p => 0) 0","decl":"@[simp]\nlemma ofHoms_zero : ofHoms (fun p => (0 : F.X p ‚ü∂ G.X p)) = 0 := by aesop_cat\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.ofHoms_v_comp_d","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nœà : (p : Int) ‚Üí Quiver.Hom (F.X p) (G.X p)\np q q' : Int\nhpq : Eq (HAdd.hAdd p 0) q\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.HomComplex.Cochain.ofHoms œà).v p q hpq) (G.d q q')) (CategoryTheory.CategoryStruct.comp (œà p) (G.d p q'))","decl":"@[simp]\nlemma ofHoms_v_comp_d (œà : ‚àÄ (p : ‚Ñ§), F.X p ‚ü∂ G.X p) (p q q' : ‚Ñ§) (hpq : p + 0 = q) :\n    (ofHoms œà).v p q hpq ‚â´ G.d q q' = œà p ‚â´ G.d p q' := by\n  rw [add_zero] at hpq\n  subst hpq\n  rw [ofHoms_v]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.d_comp_ofHoms_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nœà : (p : Int) ‚Üí Quiver.Hom (F.X p) (G.X p)\np' p q : Int\nhpq : Eq (HAdd.hAdd p 0) q\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.d p' p) ((CochainComplex.HomComplex.Cochain.ofHoms œà).v p q hpq)) (CategoryTheory.CategoryStruct.comp (F.d p' q) (œà q))","decl":"@[simp]\nlemma d_comp_ofHoms_v (œà : ‚àÄ (p : ‚Ñ§), F.X p ‚ü∂ G.X p) (p' p q : ‚Ñ§) (hpq : p + 0 = q) :\n    F.d p' p ‚â´ (ofHoms œà).v p q hpq = F.d p' q ‚â´ œà q := by\n  rw [add_zero] at hpq\n  subst hpq\n  rw [ofHoms_v]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.ofHom_zero","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\n‚ä¢ Eq (CochainComplex.HomComplex.Cochain.ofHom 0) 0","decl":"@[simp]\nlemma ofHom_zero : ofHom (0 : F ‚ü∂ G) = 0 := by\n  simp only [ofHom, HomologicalComplex.zero_f_apply, ofHoms_zero]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.ofHom_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nœÜ : Quiver.Hom F G\np : Int\n‚ä¢ Eq ((CochainComplex.HomComplex.Cochain.ofHom œÜ).v p p ‚ãØ) (œÜ.f p)","decl":"@[simp]\nlemma ofHom_v (œÜ : F ‚ü∂ G) (p : ‚Ñ§) : (ofHom œÜ).v p p (add_zero p) = œÜ.f p := by\n  simp only [ofHom, ofHoms_v]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.ofHom_v_comp_d","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nœÜ : Quiver.Hom F G\np q q' : Int\nhpq : Eq (HAdd.hAdd p 0) q\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.HomComplex.Cochain.ofHom œÜ).v p q hpq) (G.d q q')) (CategoryTheory.CategoryStruct.comp (œÜ.f p) (G.d p q'))","decl":"@[simp]\nlemma ofHom_v_comp_d (œÜ : F ‚ü∂ G) (p q q' : ‚Ñ§) (hpq : p + 0 = q) :\n    (ofHom œÜ).v p q hpq ‚â´ G.d q q' = œÜ.f p ‚â´ G.d p q' := by\n  simp only [ofHom, ofHoms_v_comp_d]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.d_comp_ofHom_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nœÜ : Quiver.Hom F G\np' p q : Int\nhpq : Eq (HAdd.hAdd p 0) q\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.d p' p) ((CochainComplex.HomComplex.Cochain.ofHom œÜ).v p q hpq)) (CategoryTheory.CategoryStruct.comp (F.d p' q) (œÜ.f q))","decl":"@[simp]\nlemma d_comp_ofHom_v (œÜ : F ‚ü∂ G) (p' p q : ‚Ñ§) (hpq : p + 0 = q) :\n    F.d p' p ‚â´ (ofHom œÜ).v p q hpq = F.d p' q ‚â´ œÜ.f q := by\n  simp only [ofHom, d_comp_ofHoms_v]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.ofHom_add","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nœÜ‚ÇÅ œÜ‚ÇÇ : Quiver.Hom F G\n‚ä¢ Eq (CochainComplex.HomComplex.Cochain.ofHom (HAdd.hAdd œÜ‚ÇÅ œÜ‚ÇÇ)) (HAdd.hAdd (CochainComplex.HomComplex.Cochain.ofHom œÜ‚ÇÅ) (CochainComplex.HomComplex.Cochain.ofHom œÜ‚ÇÇ))","decl":"@[simp]\nlemma ofHom_add (œÜ‚ÇÅ œÜ‚ÇÇ : F ‚ü∂ G) :\n    Cochain.ofHom (œÜ‚ÇÅ + œÜ‚ÇÇ) = Cochain.ofHom œÜ‚ÇÅ + Cochain.ofHom œÜ‚ÇÇ := by aesop_cat\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.ofHom_sub","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nœÜ‚ÇÅ œÜ‚ÇÇ : Quiver.Hom F G\n‚ä¢ Eq (CochainComplex.HomComplex.Cochain.ofHom (HSub.hSub œÜ‚ÇÅ œÜ‚ÇÇ)) (HSub.hSub (CochainComplex.HomComplex.Cochain.ofHom œÜ‚ÇÅ) (CochainComplex.HomComplex.Cochain.ofHom œÜ‚ÇÇ))","decl":"@[simp]\nlemma ofHom_sub (œÜ‚ÇÅ œÜ‚ÇÇ : F ‚ü∂ G) :\n    Cochain.ofHom (œÜ‚ÇÅ - œÜ‚ÇÇ) = Cochain.ofHom œÜ‚ÇÅ - Cochain.ofHom œÜ‚ÇÇ := by aesop_cat\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.ofHom_neg","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nœÜ : Quiver.Hom F G\n‚ä¢ Eq (CochainComplex.HomComplex.Cochain.ofHom (Neg.neg œÜ)) (Neg.neg (CochainComplex.HomComplex.Cochain.ofHom œÜ))","decl":"@[simp]\nlemma ofHom_neg (œÜ : F ‚ü∂ G) :\n    Cochain.ofHom (-œÜ) = -Cochain.ofHom œÜ := by aesop_cat\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.ofHomotopy_ofEq","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nœÜ‚ÇÅ œÜ‚ÇÇ : Quiver.Hom F G\nh : Eq œÜ‚ÇÅ œÜ‚ÇÇ\n‚ä¢ Eq (CochainComplex.HomComplex.Cochain.ofHomotopy (Homotopy.ofEq h)) 0","decl":"@[simp]\nlemma ofHomotopy_ofEq {œÜ‚ÇÅ œÜ‚ÇÇ : F ‚ü∂ G} (h : œÜ‚ÇÅ = œÜ‚ÇÇ) :\n    ofHomotopy (Homotopy.ofEq h) = 0 := rfl\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.ofHomotopy_refl","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nœÜ : Quiver.Hom F G\n‚ä¢ Eq (CochainComplex.HomComplex.Cochain.ofHomotopy (Homotopy.refl œÜ)) 0","decl":"@[simp]\nlemma ofHomotopy_refl (œÜ : F ‚ü∂ G) :\n    ofHomotopy (Homotopy.refl œÜ) = 0 := rfl\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.v_comp_XIsoOfEq_hom","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nn : Int\nŒ≥ : CochainComplex.HomComplex.Cochain F G n\np q q' : Int\nhpq : Eq (HAdd.hAdd p n) q\nhq' : Eq q q'\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (Œ≥.v p q hpq) (HomologicalComplex.XIsoOfEq G hq').hom) (Œ≥.v p q' ‚ãØ)","decl":"@[reassoc]\nlemma v_comp_XIsoOfEq_hom\n    (Œ≥ : Cochain F G n) (p q q' : ‚Ñ§) (hpq : p + n = q) (hq' : q = q') :\n    Œ≥.v p q hpq ‚â´ (HomologicalComplex.XIsoOfEq G hq').hom = Œ≥.v p q' (by rw [‚Üê hq', hpq]) := by\n  subst hq'\n  simp only [HomologicalComplex.XIsoOfEq, eqToIso_refl, Iso.refl_hom, comp_id]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.v_comp_XIsoOfEq_hom_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nn : Int\nŒ≥ : CochainComplex.HomComplex.Cochain F G n\np q q' : Int\nhpq : Eq (HAdd.hAdd p n) q\nhq' : Eq q q'\nZ : C\nh : Quiver.Hom (G.X q') Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (Œ≥.v p q hpq) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.XIsoOfEq G hq').hom h)) (CategoryTheory.CategoryStruct.comp (Œ≥.v p q' ‚ãØ) h)","decl":"@[reassoc]\nlemma v_comp_XIsoOfEq_hom\n    (Œ≥ : Cochain F G n) (p q q' : ‚Ñ§) (hpq : p + n = q) (hq' : q = q') :\n    Œ≥.v p q hpq ‚â´ (HomologicalComplex.XIsoOfEq G hq').hom = Œ≥.v p q' (by rw [‚Üê hq', hpq]) := by\n  subst hq'\n  simp only [HomologicalComplex.XIsoOfEq, eqToIso_refl, Iso.refl_hom, comp_id]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.v_comp_XIsoOfEq_inv","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nn : Int\nŒ≥ : CochainComplex.HomComplex.Cochain F G n\np q q' : Int\nhpq : Eq (HAdd.hAdd p n) q\nhq' : Eq q' q\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (Œ≥.v p q hpq) (HomologicalComplex.XIsoOfEq G hq').inv) (Œ≥.v p q' ‚ãØ)","decl":"@[reassoc]\nlemma v_comp_XIsoOfEq_inv\n    (Œ≥ : Cochain F G n) (p q q' : ‚Ñ§) (hpq : p + n = q) (hq' : q' = q) :\n    Œ≥.v p q hpq ‚â´ (HomologicalComplex.XIsoOfEq G hq').inv = Œ≥.v p q' (by rw [hq', hpq]) := by\n  subst hq'\n  simp only [HomologicalComplex.XIsoOfEq, eqToIso_refl, Iso.refl_inv, comp_id]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.v_comp_XIsoOfEq_inv_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nn : Int\nŒ≥ : CochainComplex.HomComplex.Cochain F G n\np q q' : Int\nhpq : Eq (HAdd.hAdd p n) q\nhq' : Eq q' q\nZ : C\nh : Quiver.Hom (G.X q') Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (Œ≥.v p q hpq) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.XIsoOfEq G hq').inv h)) (CategoryTheory.CategoryStruct.comp (Œ≥.v p q' ‚ãØ) h)","decl":"@[reassoc]\nlemma v_comp_XIsoOfEq_inv\n    (Œ≥ : Cochain F G n) (p q q' : ‚Ñ§) (hpq : p + n = q) (hq' : q' = q) :\n    Œ≥.v p q hpq ‚â´ (HomologicalComplex.XIsoOfEq G hq').inv = Œ≥.v p q' (by rw [hq', hpq]) := by\n  subst hq'\n  simp only [HomologicalComplex.XIsoOfEq, eqToIso_refl, Iso.refl_inv, comp_id]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.comp_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G K : CochainComplex C Int\nn‚ÇÅ n‚ÇÇ n‚ÇÅ‚ÇÇ : Int\nz‚ÇÅ : CochainComplex.HomComplex.Cochain F G n‚ÇÅ\nz‚ÇÇ : CochainComplex.HomComplex.Cochain G K n‚ÇÇ\nh : Eq (HAdd.hAdd n‚ÇÅ n‚ÇÇ) n‚ÇÅ‚ÇÇ\np‚ÇÅ p‚ÇÇ p‚ÇÉ : Int\nh‚ÇÅ : Eq (HAdd.hAdd p‚ÇÅ n‚ÇÅ) p‚ÇÇ\nh‚ÇÇ : Eq (HAdd.hAdd p‚ÇÇ n‚ÇÇ) p‚ÇÉ\n‚ä¢ Eq ((z‚ÇÅ.comp z‚ÇÇ h).v p‚ÇÅ p‚ÇÉ ‚ãØ) (CategoryTheory.CategoryStruct.comp (z‚ÇÅ.v p‚ÇÅ p‚ÇÇ h‚ÇÅ) (z‚ÇÇ.v p‚ÇÇ p‚ÇÉ h‚ÇÇ))","decl":"lemma comp_v {n‚ÇÅ n‚ÇÇ n‚ÇÅ‚ÇÇ : ‚Ñ§} (z‚ÇÅ : Cochain F G n‚ÇÅ) (z‚ÇÇ : Cochain G K n‚ÇÇ) (h : n‚ÇÅ + n‚ÇÇ = n‚ÇÅ‚ÇÇ)\n    (p‚ÇÅ p‚ÇÇ p‚ÇÉ : ‚Ñ§) (h‚ÇÅ : p‚ÇÅ + n‚ÇÅ = p‚ÇÇ) (h‚ÇÇ : p‚ÇÇ + n‚ÇÇ = p‚ÇÉ) :\n    (z‚ÇÅ.comp z‚ÇÇ h).v p‚ÇÅ p‚ÇÉ (by rw [‚Üê h‚ÇÇ, ‚Üê h‚ÇÅ, ‚Üê h, add_assoc]) =\n      z‚ÇÅ.v p‚ÇÅ p‚ÇÇ h‚ÇÅ ‚â´ z‚ÇÇ.v p‚ÇÇ p‚ÇÉ h‚ÇÇ := by\n  subst h‚ÇÅ; rfl\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.comp_zero_cochain_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G K : CochainComplex C Int\nn : Int\nz‚ÇÅ : CochainComplex.HomComplex.Cochain F G n\nz‚ÇÇ : CochainComplex.HomComplex.Cochain G K 0\np q : Int\nhpq : Eq (HAdd.hAdd p n) q\n‚ä¢ Eq ((z‚ÇÅ.comp z‚ÇÇ ‚ãØ).v p q hpq) (CategoryTheory.CategoryStruct.comp (z‚ÇÅ.v p q hpq) (z‚ÇÇ.v q q ‚ãØ))","decl":"@[simp]\nlemma comp_zero_cochain_v (z‚ÇÅ : Cochain F G n) (z‚ÇÇ : Cochain G K 0) (p q : ‚Ñ§) (hpq : p + n = q) :\n    (z‚ÇÅ.comp z‚ÇÇ (add_zero n)).v p q hpq = z‚ÇÅ.v p q hpq ‚â´ z‚ÇÇ.v q q (add_zero q) :=\n  comp_v z‚ÇÅ z‚ÇÇ (add_zero n) p q q hpq (add_zero q)\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.zero_cochain_comp_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G K : CochainComplex C Int\nn : Int\nz‚ÇÅ : CochainComplex.HomComplex.Cochain F G 0\nz‚ÇÇ : CochainComplex.HomComplex.Cochain G K n\np q : Int\nhpq : Eq (HAdd.hAdd p n) q\n‚ä¢ Eq ((z‚ÇÅ.comp z‚ÇÇ ‚ãØ).v p q hpq) (CategoryTheory.CategoryStruct.comp (z‚ÇÅ.v p p ‚ãØ) (z‚ÇÇ.v p q hpq))","decl":"@[simp]\nlemma zero_cochain_comp_v (z‚ÇÅ : Cochain F G 0) (z‚ÇÇ : Cochain G K n) (p q : ‚Ñ§) (hpq : p + n = q) :\n    (z‚ÇÅ.comp z‚ÇÇ (zero_add n)).v p q hpq = z‚ÇÅ.v p p (add_zero p) ‚â´ z‚ÇÇ.v p q hpq :=\n  comp_v z‚ÇÅ z‚ÇÇ (zero_add n) p p q (add_zero p) hpq\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.comp_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G K L : CochainComplex C Int\nn‚ÇÅ n‚ÇÇ n‚ÇÉ n‚ÇÅ‚ÇÇ n‚ÇÇ‚ÇÉ n‚ÇÅ‚ÇÇ‚ÇÉ : Int\nz‚ÇÅ : CochainComplex.HomComplex.Cochain F G n‚ÇÅ\nz‚ÇÇ : CochainComplex.HomComplex.Cochain G K n‚ÇÇ\nz‚ÇÉ : CochainComplex.HomComplex.Cochain K L n‚ÇÉ\nh‚ÇÅ‚ÇÇ : Eq (HAdd.hAdd n‚ÇÅ n‚ÇÇ) n‚ÇÅ‚ÇÇ\nh‚ÇÇ‚ÇÉ : Eq (HAdd.hAdd n‚ÇÇ n‚ÇÉ) n‚ÇÇ‚ÇÉ\nh‚ÇÅ‚ÇÇ‚ÇÉ : Eq (HAdd.hAdd (HAdd.hAdd n‚ÇÅ n‚ÇÇ) n‚ÇÉ) n‚ÇÅ‚ÇÇ‚ÇÉ\n‚ä¢ Eq ((z‚ÇÅ.comp z‚ÇÇ h‚ÇÅ‚ÇÇ).comp z‚ÇÉ ‚ãØ) (z‚ÇÅ.comp (z‚ÇÇ.comp z‚ÇÉ h‚ÇÇ‚ÇÉ) ‚ãØ)","decl":"/-- The associativity of the composition of cochains. -/\nlemma comp_assoc {n‚ÇÅ n‚ÇÇ n‚ÇÉ n‚ÇÅ‚ÇÇ n‚ÇÇ‚ÇÉ n‚ÇÅ‚ÇÇ‚ÇÉ : ‚Ñ§}\n    (z‚ÇÅ : Cochain F G n‚ÇÅ) (z‚ÇÇ : Cochain G K n‚ÇÇ) (z‚ÇÉ : Cochain K L n‚ÇÉ)\n    (h‚ÇÅ‚ÇÇ : n‚ÇÅ + n‚ÇÇ = n‚ÇÅ‚ÇÇ) (h‚ÇÇ‚ÇÉ : n‚ÇÇ + n‚ÇÉ = n‚ÇÇ‚ÇÉ) (h‚ÇÅ‚ÇÇ‚ÇÉ : n‚ÇÅ + n‚ÇÇ + n‚ÇÉ = n‚ÇÅ‚ÇÇ‚ÇÉ) :\n    (z‚ÇÅ.comp z‚ÇÇ h‚ÇÅ‚ÇÇ).comp z‚ÇÉ (show n‚ÇÅ‚ÇÇ + n‚ÇÉ = n‚ÇÅ‚ÇÇ‚ÇÉ by rw [‚Üê h‚ÇÅ‚ÇÇ, h‚ÇÅ‚ÇÇ‚ÇÉ]) =\n      z‚ÇÅ.comp (z‚ÇÇ.comp z‚ÇÉ h‚ÇÇ‚ÇÉ) (by rw [‚Üê h‚ÇÇ‚ÇÉ, ‚Üê h‚ÇÅ‚ÇÇ‚ÇÉ, add_assoc]) := by\n  substs h‚ÇÅ‚ÇÇ h‚ÇÇ‚ÇÉ h‚ÇÅ‚ÇÇ‚ÇÉ\n  ext p q hpq\n  rw [comp_v _ _ rfl p (p + n‚ÇÅ + n‚ÇÇ) q (add_assoc _ _ _).symm (by omega),\n    comp_v z‚ÇÅ z‚ÇÇ rfl p (p + n‚ÇÅ) (p + n‚ÇÅ + n‚ÇÇ) (by omega) (by omega),\n    comp_v z‚ÇÅ (z‚ÇÇ.comp z‚ÇÉ rfl) (add_assoc n‚ÇÅ n‚ÇÇ n‚ÇÉ).symm p (p + n‚ÇÅ) q (by omega) (by omega),\n    comp_v z‚ÇÇ z‚ÇÉ rfl (p + n‚ÇÅ) (p + n‚ÇÅ + n‚ÇÇ) q (by omega) (by omega), assoc]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.comp_assoc_of_first_is_zero_cochain","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G K L : CochainComplex C Int\nn‚ÇÇ n‚ÇÉ n‚ÇÇ‚ÇÉ : Int\nz‚ÇÅ : CochainComplex.HomComplex.Cochain F G 0\nz‚ÇÇ : CochainComplex.HomComplex.Cochain G K n‚ÇÇ\nz‚ÇÉ : CochainComplex.HomComplex.Cochain K L n‚ÇÉ\nh‚ÇÇ‚ÇÉ : Eq (HAdd.hAdd n‚ÇÇ n‚ÇÉ) n‚ÇÇ‚ÇÉ\n‚ä¢ Eq ((z‚ÇÅ.comp z‚ÇÇ ‚ãØ).comp z‚ÇÉ h‚ÇÇ‚ÇÉ) (z‚ÇÅ.comp (z‚ÇÇ.comp z‚ÇÉ h‚ÇÇ‚ÇÉ) ‚ãØ)","decl":"@[simp]\nlemma comp_assoc_of_first_is_zero_cochain {n‚ÇÇ n‚ÇÉ n‚ÇÇ‚ÇÉ : ‚Ñ§}\n    (z‚ÇÅ : Cochain F G 0) (z‚ÇÇ : Cochain G K n‚ÇÇ) (z‚ÇÉ : Cochain K L n‚ÇÉ)\n    (h‚ÇÇ‚ÇÉ : n‚ÇÇ + n‚ÇÉ = n‚ÇÇ‚ÇÉ) :\n    (z‚ÇÅ.comp z‚ÇÇ (zero_add n‚ÇÇ)).comp z‚ÇÉ h‚ÇÇ‚ÇÉ = z‚ÇÅ.comp (z‚ÇÇ.comp z‚ÇÉ h‚ÇÇ‚ÇÉ) (zero_add n‚ÇÇ‚ÇÉ) :=\n  comp_assoc _ _ _ _ _ (by omega)\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.comp_assoc_of_second_is_zero_cochain","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G K L : CochainComplex C Int\nn‚ÇÅ n‚ÇÉ n‚ÇÅ‚ÇÉ : Int\nz‚ÇÅ : CochainComplex.HomComplex.Cochain F G n‚ÇÅ\nz‚ÇÇ : CochainComplex.HomComplex.Cochain G K 0\nz‚ÇÉ : CochainComplex.HomComplex.Cochain K L n‚ÇÉ\nh‚ÇÅ‚ÇÉ : Eq (HAdd.hAdd n‚ÇÅ n‚ÇÉ) n‚ÇÅ‚ÇÉ\n‚ä¢ Eq ((z‚ÇÅ.comp z‚ÇÇ ‚ãØ).comp z‚ÇÉ h‚ÇÅ‚ÇÉ) (z‚ÇÅ.comp (z‚ÇÇ.comp z‚ÇÉ ‚ãØ) h‚ÇÅ‚ÇÉ)","decl":"@[simp]\nlemma comp_assoc_of_second_is_zero_cochain {n‚ÇÅ n‚ÇÉ n‚ÇÅ‚ÇÉ : ‚Ñ§}\n    (z‚ÇÅ : Cochain F G n‚ÇÅ) (z‚ÇÇ : Cochain G K 0) (z‚ÇÉ : Cochain K L n‚ÇÉ) (h‚ÇÅ‚ÇÉ : n‚ÇÅ + n‚ÇÉ = n‚ÇÅ‚ÇÉ) :\n    (z‚ÇÅ.comp z‚ÇÇ (add_zero n‚ÇÅ)).comp z‚ÇÉ h‚ÇÅ‚ÇÉ = z‚ÇÅ.comp (z‚ÇÇ.comp z‚ÇÉ (zero_add n‚ÇÉ)) h‚ÇÅ‚ÇÉ :=\n  comp_assoc _ _ _ _ _ (by omega)\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.comp_assoc_of_third_is_zero_cochain","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G K L : CochainComplex C Int\nn‚ÇÅ n‚ÇÇ n‚ÇÅ‚ÇÇ : Int\nz‚ÇÅ : CochainComplex.HomComplex.Cochain F G n‚ÇÅ\nz‚ÇÇ : CochainComplex.HomComplex.Cochain G K n‚ÇÇ\nz‚ÇÉ : CochainComplex.HomComplex.Cochain K L 0\nh‚ÇÅ‚ÇÇ : Eq (HAdd.hAdd n‚ÇÅ n‚ÇÇ) n‚ÇÅ‚ÇÇ\n‚ä¢ Eq ((z‚ÇÅ.comp z‚ÇÇ h‚ÇÅ‚ÇÇ).comp z‚ÇÉ ‚ãØ) (z‚ÇÅ.comp (z‚ÇÇ.comp z‚ÇÉ ‚ãØ) h‚ÇÅ‚ÇÇ)","decl":"@[simp]\nlemma comp_assoc_of_third_is_zero_cochain {n‚ÇÅ n‚ÇÇ n‚ÇÅ‚ÇÇ : ‚Ñ§}\n    (z‚ÇÅ : Cochain F G n‚ÇÅ) (z‚ÇÇ : Cochain G K n‚ÇÇ) (z‚ÇÉ : Cochain K L 0) (h‚ÇÅ‚ÇÇ : n‚ÇÅ + n‚ÇÇ = n‚ÇÅ‚ÇÇ) :\n    (z‚ÇÅ.comp z‚ÇÇ h‚ÇÅ‚ÇÇ).comp z‚ÇÉ (add_zero n‚ÇÅ‚ÇÇ) = z‚ÇÅ.comp (z‚ÇÇ.comp z‚ÇÉ (add_zero n‚ÇÇ)) h‚ÇÅ‚ÇÇ :=\n  comp_assoc _ _ _ _ _ (by omega)\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.comp_assoc_of_second_degree_eq_neg_third_degree","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G K L : CochainComplex C Int\nn‚ÇÅ n‚ÇÇ n‚ÇÅ‚ÇÇ : Int\nz‚ÇÅ : CochainComplex.HomComplex.Cochain F G n‚ÇÅ\nz‚ÇÇ : CochainComplex.HomComplex.Cochain G K (Neg.neg n‚ÇÇ)\nz‚ÇÉ : CochainComplex.HomComplex.Cochain K L n‚ÇÇ\nh‚ÇÅ‚ÇÇ : Eq (HAdd.hAdd n‚ÇÅ (Neg.neg n‚ÇÇ)) n‚ÇÅ‚ÇÇ\n‚ä¢ Eq ((z‚ÇÅ.comp z‚ÇÇ h‚ÇÅ‚ÇÇ).comp z‚ÇÉ ‚ãØ) (z‚ÇÅ.comp (z‚ÇÇ.comp z‚ÇÉ ‚ãØ) ‚ãØ)","decl":"@[simp]\nlemma comp_assoc_of_second_degree_eq_neg_third_degree {n‚ÇÅ n‚ÇÇ n‚ÇÅ‚ÇÇ : ‚Ñ§}\n    (z‚ÇÅ : Cochain F G n‚ÇÅ) (z‚ÇÇ : Cochain G K (-n‚ÇÇ)) (z‚ÇÉ : Cochain K L n‚ÇÇ) (h‚ÇÅ‚ÇÇ : n‚ÇÅ + (-n‚ÇÇ) = n‚ÇÅ‚ÇÇ) :\n    (z‚ÇÅ.comp z‚ÇÇ h‚ÇÅ‚ÇÇ).comp z‚ÇÉ\n      (show n‚ÇÅ‚ÇÇ + n‚ÇÇ = n‚ÇÅ by rw [‚Üê h‚ÇÅ‚ÇÇ, add_assoc, neg_add_cancel, add_zero]) =\n      z‚ÇÅ.comp (z‚ÇÇ.comp z‚ÇÉ (neg_add_cancel n‚ÇÇ)) (add_zero n‚ÇÅ) :=\n  comp_assoc _ _ _ _ _ (by omega)\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.zero_comp","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G K : CochainComplex C Int\nn‚ÇÅ n‚ÇÇ n‚ÇÅ‚ÇÇ : Int\nz‚ÇÇ : CochainComplex.HomComplex.Cochain G K n‚ÇÇ\nh : Eq (HAdd.hAdd n‚ÇÅ n‚ÇÇ) n‚ÇÅ‚ÇÇ\n‚ä¢ Eq (CochainComplex.HomComplex.Cochain.comp 0 z‚ÇÇ h) 0","decl":"@[simp]\nprotected lemma zero_comp {n‚ÇÅ n‚ÇÇ n‚ÇÅ‚ÇÇ : ‚Ñ§} (z‚ÇÇ : Cochain G K n‚ÇÇ)\n    (h : n‚ÇÅ + n‚ÇÇ = n‚ÇÅ‚ÇÇ) : (0 : Cochain F G n‚ÇÅ).comp z‚ÇÇ h = 0 := by\n  ext p q hpq\n  simp only [comp_v _ _ h p _ q rfl (by omega), zero_v, zero_comp]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.add_comp","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G K : CochainComplex C Int\nn‚ÇÅ n‚ÇÇ n‚ÇÅ‚ÇÇ : Int\nz‚ÇÅ z‚ÇÅ' : CochainComplex.HomComplex.Cochain F G n‚ÇÅ\nz‚ÇÇ : CochainComplex.HomComplex.Cochain G K n‚ÇÇ\nh : Eq (HAdd.hAdd n‚ÇÅ n‚ÇÇ) n‚ÇÅ‚ÇÇ\n‚ä¢ Eq ((HAdd.hAdd z‚ÇÅ z‚ÇÅ').comp z‚ÇÇ h) (HAdd.hAdd (z‚ÇÅ.comp z‚ÇÇ h) (z‚ÇÅ'.comp z‚ÇÇ h))","decl":"@[simp]\nprotected lemma add_comp {n‚ÇÅ n‚ÇÇ n‚ÇÅ‚ÇÇ : ‚Ñ§} (z‚ÇÅ z‚ÇÅ' : Cochain F G n‚ÇÅ) (z‚ÇÇ : Cochain G K n‚ÇÇ)\n    (h : n‚ÇÅ + n‚ÇÇ = n‚ÇÅ‚ÇÇ) : (z‚ÇÅ + z‚ÇÅ').comp z‚ÇÇ h = z‚ÇÅ.comp z‚ÇÇ h + z‚ÇÅ'.comp z‚ÇÇ h := by\n  ext p q hpq\n  simp only [comp_v _ _ h p _ q rfl (by omega), add_v, add_comp]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.sub_comp","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G K : CochainComplex C Int\nn‚ÇÅ n‚ÇÇ n‚ÇÅ‚ÇÇ : Int\nz‚ÇÅ z‚ÇÅ' : CochainComplex.HomComplex.Cochain F G n‚ÇÅ\nz‚ÇÇ : CochainComplex.HomComplex.Cochain G K n‚ÇÇ\nh : Eq (HAdd.hAdd n‚ÇÅ n‚ÇÇ) n‚ÇÅ‚ÇÇ\n‚ä¢ Eq ((HSub.hSub z‚ÇÅ z‚ÇÅ').comp z‚ÇÇ h) (HSub.hSub (z‚ÇÅ.comp z‚ÇÇ h) (z‚ÇÅ'.comp z‚ÇÇ h))","decl":"@[simp]\nprotected lemma sub_comp {n‚ÇÅ n‚ÇÇ n‚ÇÅ‚ÇÇ : ‚Ñ§} (z‚ÇÅ z‚ÇÅ' : Cochain F G n‚ÇÅ) (z‚ÇÇ : Cochain G K n‚ÇÇ)\n    (h : n‚ÇÅ + n‚ÇÇ = n‚ÇÅ‚ÇÇ) : (z‚ÇÅ - z‚ÇÅ').comp z‚ÇÇ h = z‚ÇÅ.comp z‚ÇÇ h - z‚ÇÅ'.comp z‚ÇÇ h := by\n  ext p q hpq\n  simp only [comp_v _ _ h p _ q rfl (by omega), sub_v, sub_comp]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.neg_comp","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G K : CochainComplex C Int\nn‚ÇÅ n‚ÇÇ n‚ÇÅ‚ÇÇ : Int\nz‚ÇÅ : CochainComplex.HomComplex.Cochain F G n‚ÇÅ\nz‚ÇÇ : CochainComplex.HomComplex.Cochain G K n‚ÇÇ\nh : Eq (HAdd.hAdd n‚ÇÅ n‚ÇÇ) n‚ÇÅ‚ÇÇ\n‚ä¢ Eq ((Neg.neg z‚ÇÅ).comp z‚ÇÇ h) (Neg.neg (z‚ÇÅ.comp z‚ÇÇ h))","decl":"@[simp]\nprotected lemma neg_comp {n‚ÇÅ n‚ÇÇ n‚ÇÅ‚ÇÇ : ‚Ñ§} (z‚ÇÅ : Cochain F G n‚ÇÅ) (z‚ÇÇ : Cochain G K n‚ÇÇ)\n    (h : n‚ÇÅ + n‚ÇÇ = n‚ÇÅ‚ÇÇ) : (-z‚ÇÅ).comp z‚ÇÇ h = -z‚ÇÅ.comp z‚ÇÇ h := by\n  ext p q hpq\n  simp only [comp_v _ _ h p _ q rfl (by omega), neg_v, neg_comp]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.smul_comp","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Preadditive C\nR : Type u_1\ninst‚úù¬π : Ring R\ninst‚úù : CategoryTheory.Linear R C\nF G K : CochainComplex C Int\nn‚ÇÅ n‚ÇÇ n‚ÇÅ‚ÇÇ : Int\nk : R\nz‚ÇÅ : CochainComplex.HomComplex.Cochain F G n‚ÇÅ\nz‚ÇÇ : CochainComplex.HomComplex.Cochain G K n‚ÇÇ\nh : Eq (HAdd.hAdd n‚ÇÅ n‚ÇÇ) n‚ÇÅ‚ÇÇ\n‚ä¢ Eq ((HSMul.hSMul k z‚ÇÅ).comp z‚ÇÇ h) (HSMul.hSMul k (z‚ÇÅ.comp z‚ÇÇ h))","decl":"@[simp]\nprotected lemma smul_comp {n‚ÇÅ n‚ÇÇ n‚ÇÅ‚ÇÇ : ‚Ñ§} (k : R) (z‚ÇÅ : Cochain F G n‚ÇÅ) (z‚ÇÇ : Cochain G K n‚ÇÇ)\n    (h : n‚ÇÅ + n‚ÇÇ = n‚ÇÅ‚ÇÇ) : (k ‚Ä¢ z‚ÇÅ).comp z‚ÇÇ h = k ‚Ä¢ (z‚ÇÅ.comp z‚ÇÇ h) := by\n  ext p q hpq\n  simp only [comp_v _ _ h p _ q rfl (by omega), smul_v, Linear.smul_comp]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.units_smul_comp","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Preadditive C\nR : Type u_1\ninst‚úù¬π : Ring R\ninst‚úù : CategoryTheory.Linear R C\nF G K : CochainComplex C Int\nn‚ÇÅ n‚ÇÇ n‚ÇÅ‚ÇÇ : Int\nk : Units R\nz‚ÇÅ : CochainComplex.HomComplex.Cochain F G n‚ÇÅ\nz‚ÇÇ : CochainComplex.HomComplex.Cochain G K n‚ÇÇ\nh : Eq (HAdd.hAdd n‚ÇÅ n‚ÇÇ) n‚ÇÅ‚ÇÇ\n‚ä¢ Eq ((HSMul.hSMul k z‚ÇÅ).comp z‚ÇÇ h) (HSMul.hSMul k (z‚ÇÅ.comp z‚ÇÇ h))","decl":"@[simp]\nlemma units_smul_comp {n‚ÇÅ n‚ÇÇ n‚ÇÅ‚ÇÇ : ‚Ñ§} (k : RÀ£) (z‚ÇÅ : Cochain F G n‚ÇÅ) (z‚ÇÇ : Cochain G K n‚ÇÇ)\n    (h : n‚ÇÅ + n‚ÇÇ = n‚ÇÅ‚ÇÇ) : (k ‚Ä¢ z‚ÇÅ).comp z‚ÇÇ h = k ‚Ä¢ (z‚ÇÅ.comp z‚ÇÇ h) := by\n  apply Cochain.smul_comp\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.id_comp","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nn : Int\nz‚ÇÇ : CochainComplex.HomComplex.Cochain F G n\n‚ä¢ Eq ((CochainComplex.HomComplex.Cochain.ofHom (CategoryTheory.CategoryStruct.id F)).comp z‚ÇÇ ‚ãØ) z‚ÇÇ","decl":"@[simp]\nprotected lemma id_comp {n : ‚Ñ§} (z‚ÇÇ : Cochain F G n) :\n    (Cochain.ofHom (ùüô F)).comp z‚ÇÇ (zero_add n) = z‚ÇÇ := by\n  ext p q hpq\n  simp only [zero_cochain_comp_v, ofHom_v, HomologicalComplex.id_f, id_comp]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.comp_zero","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G K : CochainComplex C Int\nn‚ÇÅ n‚ÇÇ n‚ÇÅ‚ÇÇ : Int\nz‚ÇÅ : CochainComplex.HomComplex.Cochain F G n‚ÇÅ\nh : Eq (HAdd.hAdd n‚ÇÅ n‚ÇÇ) n‚ÇÅ‚ÇÇ\n‚ä¢ Eq (z‚ÇÅ.comp 0 h) 0","decl":"@[simp]\nprotected lemma comp_zero {n‚ÇÅ n‚ÇÇ n‚ÇÅ‚ÇÇ : ‚Ñ§} (z‚ÇÅ : Cochain F G n‚ÇÅ)\n    (h : n‚ÇÅ + n‚ÇÇ = n‚ÇÅ‚ÇÇ) : z‚ÇÅ.comp (0 : Cochain G K n‚ÇÇ) h = 0 := by\n  ext p q hpq\n  simp only [comp_v _ _ h p _ q rfl (by omega), zero_v, comp_zero]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.comp_add","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G K : CochainComplex C Int\nn‚ÇÅ n‚ÇÇ n‚ÇÅ‚ÇÇ : Int\nz‚ÇÅ : CochainComplex.HomComplex.Cochain F G n‚ÇÅ\nz‚ÇÇ z‚ÇÇ' : CochainComplex.HomComplex.Cochain G K n‚ÇÇ\nh : Eq (HAdd.hAdd n‚ÇÅ n‚ÇÇ) n‚ÇÅ‚ÇÇ\n‚ä¢ Eq (z‚ÇÅ.comp (HAdd.hAdd z‚ÇÇ z‚ÇÇ') h) (HAdd.hAdd (z‚ÇÅ.comp z‚ÇÇ h) (z‚ÇÅ.comp z‚ÇÇ' h))","decl":"@[simp]\nprotected lemma comp_add {n‚ÇÅ n‚ÇÇ n‚ÇÅ‚ÇÇ : ‚Ñ§} (z‚ÇÅ : Cochain F G n‚ÇÅ) (z‚ÇÇ z‚ÇÇ' : Cochain G K n‚ÇÇ)\n    (h : n‚ÇÅ + n‚ÇÇ = n‚ÇÅ‚ÇÇ) : z‚ÇÅ.comp (z‚ÇÇ + z‚ÇÇ') h = z‚ÇÅ.comp z‚ÇÇ h + z‚ÇÅ.comp z‚ÇÇ' h := by\n  ext p q hpq\n  simp only [comp_v _ _ h p _ q rfl (by omega), add_v, comp_add]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.comp_sub","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G K : CochainComplex C Int\nn‚ÇÅ n‚ÇÇ n‚ÇÅ‚ÇÇ : Int\nz‚ÇÅ : CochainComplex.HomComplex.Cochain F G n‚ÇÅ\nz‚ÇÇ z‚ÇÇ' : CochainComplex.HomComplex.Cochain G K n‚ÇÇ\nh : Eq (HAdd.hAdd n‚ÇÅ n‚ÇÇ) n‚ÇÅ‚ÇÇ\n‚ä¢ Eq (z‚ÇÅ.comp (HSub.hSub z‚ÇÇ z‚ÇÇ') h) (HSub.hSub (z‚ÇÅ.comp z‚ÇÇ h) (z‚ÇÅ.comp z‚ÇÇ' h))","decl":"@[simp]\nprotected lemma comp_sub {n‚ÇÅ n‚ÇÇ n‚ÇÅ‚ÇÇ : ‚Ñ§} (z‚ÇÅ : Cochain F G n‚ÇÅ) (z‚ÇÇ z‚ÇÇ' : Cochain G K n‚ÇÇ)\n    (h : n‚ÇÅ + n‚ÇÇ = n‚ÇÅ‚ÇÇ) : z‚ÇÅ.comp (z‚ÇÇ - z‚ÇÇ') h = z‚ÇÅ.comp z‚ÇÇ h - z‚ÇÅ.comp z‚ÇÇ' h := by\n  ext p q hpq\n  simp only [comp_v _ _ h p _ q rfl (by omega), sub_v, comp_sub]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.comp_neg","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G K : CochainComplex C Int\nn‚ÇÅ n‚ÇÇ n‚ÇÅ‚ÇÇ : Int\nz‚ÇÅ : CochainComplex.HomComplex.Cochain F G n‚ÇÅ\nz‚ÇÇ : CochainComplex.HomComplex.Cochain G K n‚ÇÇ\nh : Eq (HAdd.hAdd n‚ÇÅ n‚ÇÇ) n‚ÇÅ‚ÇÇ\n‚ä¢ Eq (z‚ÇÅ.comp (Neg.neg z‚ÇÇ) h) (Neg.neg (z‚ÇÅ.comp z‚ÇÇ h))","decl":"@[simp]\nprotected lemma comp_neg {n‚ÇÅ n‚ÇÇ n‚ÇÅ‚ÇÇ : ‚Ñ§} (z‚ÇÅ : Cochain F G n‚ÇÅ) (z‚ÇÇ : Cochain G K n‚ÇÇ)\n    (h : n‚ÇÅ + n‚ÇÇ = n‚ÇÅ‚ÇÇ) : z‚ÇÅ.comp (-z‚ÇÇ) h = -z‚ÇÅ.comp z‚ÇÇ h := by\n  ext p q hpq\n  simp only [comp_v _ _ h p _ q rfl (by omega), neg_v, comp_neg]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.comp_smul","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Preadditive C\nR : Type u_1\ninst‚úù¬π : Ring R\ninst‚úù : CategoryTheory.Linear R C\nF G K : CochainComplex C Int\nn‚ÇÅ n‚ÇÇ n‚ÇÅ‚ÇÇ : Int\nz‚ÇÅ : CochainComplex.HomComplex.Cochain F G n‚ÇÅ\nk : R\nz‚ÇÇ : CochainComplex.HomComplex.Cochain G K n‚ÇÇ\nh : Eq (HAdd.hAdd n‚ÇÅ n‚ÇÇ) n‚ÇÅ‚ÇÇ\n‚ä¢ Eq (z‚ÇÅ.comp (HSMul.hSMul k z‚ÇÇ) h) (HSMul.hSMul k (z‚ÇÅ.comp z‚ÇÇ h))","decl":"@[simp]\nprotected lemma comp_smul {n‚ÇÅ n‚ÇÇ n‚ÇÅ‚ÇÇ : ‚Ñ§} (z‚ÇÅ : Cochain F G n‚ÇÅ) (k : R) (z‚ÇÇ : Cochain G K n‚ÇÇ)\n    (h : n‚ÇÅ + n‚ÇÇ = n‚ÇÅ‚ÇÇ ) : z‚ÇÅ.comp (k ‚Ä¢ z‚ÇÇ) h = k ‚Ä¢ (z‚ÇÅ.comp z‚ÇÇ h) := by\n  ext p q hpq\n  simp only [comp_v _ _ h p _ q rfl (by omega), smul_v, Linear.comp_smul]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.comp_units_smul","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Preadditive C\nR : Type u_1\ninst‚úù¬π : Ring R\ninst‚úù : CategoryTheory.Linear R C\nF G K : CochainComplex C Int\nn‚ÇÅ n‚ÇÇ n‚ÇÅ‚ÇÇ : Int\nz‚ÇÅ : CochainComplex.HomComplex.Cochain F G n‚ÇÅ\nk : Units R\nz‚ÇÇ : CochainComplex.HomComplex.Cochain G K n‚ÇÇ\nh : Eq (HAdd.hAdd n‚ÇÅ n‚ÇÇ) n‚ÇÅ‚ÇÇ\n‚ä¢ Eq (z‚ÇÅ.comp (HSMul.hSMul k z‚ÇÇ) h) (HSMul.hSMul k (z‚ÇÅ.comp z‚ÇÇ h))","decl":"@[simp]\nlemma comp_units_smul {n‚ÇÅ n‚ÇÇ n‚ÇÅ‚ÇÇ : ‚Ñ§} (z‚ÇÅ : Cochain F G n‚ÇÅ) (k : RÀ£) (z‚ÇÇ : Cochain G K n‚ÇÇ)\n    (h : n‚ÇÅ + n‚ÇÇ = n‚ÇÅ‚ÇÇ ) : z‚ÇÅ.comp (k ‚Ä¢ z‚ÇÇ) h = k ‚Ä¢ (z‚ÇÅ.comp z‚ÇÇ h) := by\n  apply Cochain.comp_smul\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.comp_id","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nn : Int\nz‚ÇÅ : CochainComplex.HomComplex.Cochain F G n\n‚ä¢ Eq (z‚ÇÅ.comp (CochainComplex.HomComplex.Cochain.ofHom (CategoryTheory.CategoryStruct.id G)) ‚ãØ) z‚ÇÅ","decl":"@[simp]\nprotected lemma comp_id {n : ‚Ñ§} (z‚ÇÅ : Cochain F G n) :\n    z‚ÇÅ.comp (Cochain.ofHom (ùüô G)) (add_zero n) = z‚ÇÅ := by\n  ext p q hpq\n  simp only [comp_zero_cochain_v, ofHom_v, HomologicalComplex.id_f, comp_id]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.ofHoms_comp","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G K : CochainComplex C Int\nœÜ : (p : Int) ‚Üí Quiver.Hom (F.X p) (G.X p)\nœà : (p : Int) ‚Üí Quiver.Hom (G.X p) (K.X p)\n‚ä¢ Eq ((CochainComplex.HomComplex.Cochain.ofHoms œÜ).comp (CochainComplex.HomComplex.Cochain.ofHoms œà) ‚ãØ) (CochainComplex.HomComplex.Cochain.ofHoms fun p => CategoryTheory.CategoryStruct.comp (œÜ p) (œà p))","decl":"@[simp]\nlemma ofHoms_comp (œÜ : ‚àÄ (p : ‚Ñ§), F.X p ‚ü∂ G.X p) (œà : ‚àÄ (p : ‚Ñ§), G.X p ‚ü∂ K.X p) :\n    (ofHoms œÜ).comp (ofHoms œà) (zero_add 0) = ofHoms (fun p => œÜ p ‚â´ œà p) := by aesop_cat\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.ofHom_comp","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G K : CochainComplex C Int\nf : Quiver.Hom F G\ng : Quiver.Hom G K\n‚ä¢ Eq (CochainComplex.HomComplex.Cochain.ofHom (CategoryTheory.CategoryStruct.comp f g)) ((CochainComplex.HomComplex.Cochain.ofHom f).comp (CochainComplex.HomComplex.Cochain.ofHom g) ‚ãØ)","decl":"@[simp]\nlemma ofHom_comp (f : F ‚ü∂ G) (g : G ‚ü∂ K) :\n    ofHom (f ‚â´ g) = (ofHom f).comp (ofHom g) (zero_add 0) := by\n  simp only [ofHom, HomologicalComplex.comp_f, ofHoms_comp]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.diff_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nK : CochainComplex C Int\np q : Int\nhpq : Eq (HAdd.hAdd p 1) q\n‚ä¢ Eq ((CochainComplex.HomComplex.Cochain.diff K).v p q hpq) (K.d p q)","decl":"@[simp]\nlemma diff_v (p q : ‚Ñ§) (hpq : p + 1 = q) : (diff K).v p q hpq = K.d p q := rfl\n\n"}
{"name":"CochainComplex.HomComplex.Œ¥_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nn m : Int\nhnm : Eq (HAdd.hAdd n 1) m\nz : CochainComplex.HomComplex.Cochain F G n\np q : Int\nhpq : Eq (HAdd.hAdd p m) q\nq‚ÇÅ q‚ÇÇ : Int\nhq‚ÇÅ : Eq q‚ÇÅ (HSub.hSub q 1)\nhq‚ÇÇ : Eq (HAdd.hAdd p 1) q‚ÇÇ\n‚ä¢ Eq ((CochainComplex.HomComplex.Œ¥ n m z).v p q hpq) (HAdd.hAdd (CategoryTheory.CategoryStruct.comp (z.v p q‚ÇÅ ‚ãØ) (G.d q‚ÇÅ q)) (HSMul.hSMul m.negOnePow (CategoryTheory.CategoryStruct.comp (F.d p q‚ÇÇ) (z.v q‚ÇÇ q ‚ãØ))))","decl":"lemma Œ¥_v (hnm : n + 1 = m) (z : Cochain F G n) (p q : ‚Ñ§) (hpq : p + m = q) (q‚ÇÅ q‚ÇÇ : ‚Ñ§)\n    (hq‚ÇÅ : q‚ÇÅ = q - 1) (hq‚ÇÇ : p + 1 = q‚ÇÇ) : (Œ¥ n m z).v p q hpq =\n    z.v p q‚ÇÅ (by rw [hq‚ÇÅ, ‚Üê hpq, ‚Üê hnm, ‚Üê add_assoc, add_sub_cancel_right]) ‚â´ G.d q‚ÇÅ q\n      + m.negOnePow ‚Ä¢ F.d p q‚ÇÇ ‚â´ z.v q‚ÇÇ q\n          (by rw [‚Üê hq‚ÇÇ, add_assoc, add_comm 1, hnm, hpq]) := by\n  obtain rfl : q‚ÇÅ = p + n := by omega\n  obtain rfl : q‚ÇÇ = p + m - n := by omega\n  rfl\n\n"}
{"name":"CochainComplex.HomComplex.Œ¥_shape","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nn m : Int\nhnm : Not (Eq (HAdd.hAdd n 1) m)\nz : CochainComplex.HomComplex.Cochain F G n\n‚ä¢ Eq (CochainComplex.HomComplex.Œ¥ n m z) 0","decl":"lemma Œ¥_shape (hnm : ¬¨ n + 1 = m) (z : Cochain F G n) : Œ¥ n m z = 0 := by\n  ext p q hpq\n  dsimp only [Œ¥]\n  rw [Cochain.mk_v, Cochain.zero_v, F.shape, G.shape, comp_zero, zero_add, zero_comp, smul_zero]\n  all_goals\n    simp only [ComplexShape.up_Rel]\n    exact fun _ => hnm (by omega)\n\n"}
{"name":"CochainComplex.HomComplex.Œ¥_hom_apply","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Preadditive C\nR : Type u_1\ninst‚úù¬π : Ring R\ninst‚úù : CategoryTheory.Linear R C\nF G : CochainComplex C Int\nn m : Int\nz : CochainComplex.HomComplex.Cochain F G n\n‚ä¢ Eq ((CochainComplex.HomComplex.Œ¥_hom R F G n m) z) (CochainComplex.HomComplex.Œ¥ n m z)","decl":"/-- The differential on the complex of morphisms between cochain complexes, as a linear map. -/\n@[simps!]\ndef Œ¥_hom : Cochain F G n ‚Üí‚Çó[R] Cochain F G m where\n  toFun := Œ¥ n m\n  map_add' Œ± Œ≤ := by\n    by_cases h : n + 1 = m\n    ¬∑ ext p q hpq\n      dsimp\n      simp only [Œ¥_v n m h _ p q hpq _ _ rfl rfl, Cochain.add_v, add_comp, comp_add, smul_add]\n      abel\n    ¬∑ simp only [Œ¥_shape _ _ h, add_zero]\n  map_smul' r a := by\n    by_cases h : n + 1 = m\n    ¬∑ ext p q hpq\n      dsimp\n      simp only [Œ¥_v n m h _ p q hpq _ _ rfl rfl, Cochain.smul_v, Linear.comp_smul,\n        Linear.smul_comp, smul_add, add_right_inj, smul_comm m.negOnePow r]\n    ¬∑ simp only [Œ¥_shape _ _ h, smul_zero]\n\n"}
{"name":"CochainComplex.HomComplex.Œ¥_add","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nn m : Int\nz‚ÇÅ z‚ÇÇ : CochainComplex.HomComplex.Cochain F G n\n‚ä¢ Eq (CochainComplex.HomComplex.Œ¥ n m (HAdd.hAdd z‚ÇÅ z‚ÇÇ)) (HAdd.hAdd (CochainComplex.HomComplex.Œ¥ n m z‚ÇÅ) (CochainComplex.HomComplex.Œ¥ n m z‚ÇÇ))","decl":"@[simp] lemma Œ¥_add (z‚ÇÅ z‚ÇÇ : Cochain F G n) : Œ¥ n m (z‚ÇÅ + z‚ÇÇ) = Œ¥ n m z‚ÇÅ + Œ¥ n m z‚ÇÇ :=\n  (Œ¥_hom ‚Ñ§ F G n m).map_add z‚ÇÅ z‚ÇÇ\n\n"}
{"name":"CochainComplex.HomComplex.Œ¥_sub","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nn m : Int\nz‚ÇÅ z‚ÇÇ : CochainComplex.HomComplex.Cochain F G n\n‚ä¢ Eq (CochainComplex.HomComplex.Œ¥ n m (HSub.hSub z‚ÇÅ z‚ÇÇ)) (HSub.hSub (CochainComplex.HomComplex.Œ¥ n m z‚ÇÅ) (CochainComplex.HomComplex.Œ¥ n m z‚ÇÇ))","decl":"@[simp] lemma Œ¥_sub (z‚ÇÅ z‚ÇÇ : Cochain F G n) : Œ¥ n m (z‚ÇÅ - z‚ÇÇ) = Œ¥ n m z‚ÇÅ - Œ¥ n m z‚ÇÇ :=\n  (Œ¥_hom ‚Ñ§ F G n m).map_sub z‚ÇÅ z‚ÇÇ\n\n"}
{"name":"CochainComplex.HomComplex.Œ¥_zero","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nn m : Int\n‚ä¢ Eq (CochainComplex.HomComplex.Œ¥ n m 0) 0","decl":"@[simp] lemma Œ¥_zero : Œ¥ n m (0 : Cochain F G n) = 0 := (Œ¥_hom ‚Ñ§ F G n m).map_zero\n\n"}
{"name":"CochainComplex.HomComplex.Œ¥_neg","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nn m : Int\nz : CochainComplex.HomComplex.Cochain F G n\n‚ä¢ Eq (CochainComplex.HomComplex.Œ¥ n m (Neg.neg z)) (Neg.neg (CochainComplex.HomComplex.Œ¥ n m z))","decl":"@[simp] lemma Œ¥_neg (z : Cochain F G n) : Œ¥ n m (-z) = - Œ¥ n m z :=\n  (Œ¥_hom ‚Ñ§ F G n m).map_neg z\n\n"}
{"name":"CochainComplex.HomComplex.Œ¥_smul","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Preadditive C\nR : Type u_1\ninst‚úù¬π : Ring R\ninst‚úù : CategoryTheory.Linear R C\nF G : CochainComplex C Int\nn m : Int\nk : R\nz : CochainComplex.HomComplex.Cochain F G n\n‚ä¢ Eq (CochainComplex.HomComplex.Œ¥ n m (HSMul.hSMul k z)) (HSMul.hSMul k (CochainComplex.HomComplex.Œ¥ n m z))","decl":"@[simp] lemma Œ¥_smul (k : R) (z : Cochain F G n) : Œ¥ n m (k ‚Ä¢ z) = k ‚Ä¢ Œ¥ n m z :=\n  (Œ¥_hom R F G n m).map_smul k z\n\n"}
{"name":"CochainComplex.HomComplex.Œ¥_units_smul","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Preadditive C\nR : Type u_1\ninst‚úù¬π : Ring R\ninst‚úù : CategoryTheory.Linear R C\nF G : CochainComplex C Int\nn m : Int\nk : Units R\nz : CochainComplex.HomComplex.Cochain F G n\n‚ä¢ Eq (CochainComplex.HomComplex.Œ¥ n m (HSMul.hSMul k z)) (HSMul.hSMul k (CochainComplex.HomComplex.Œ¥ n m z))","decl":"@[simp] lemma Œ¥_units_smul (k : RÀ£) (z : Cochain F G n) : Œ¥ n m (k ‚Ä¢ z) = k ‚Ä¢ Œ¥ n m z :=\n  Œ¥_smul ..\n\n"}
{"name":"CochainComplex.HomComplex.Œ¥_Œ¥","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nn‚ÇÄ n‚ÇÅ n‚ÇÇ : Int\nz : CochainComplex.HomComplex.Cochain F G n‚ÇÄ\n‚ä¢ Eq (CochainComplex.HomComplex.Œ¥ n‚ÇÅ n‚ÇÇ (CochainComplex.HomComplex.Œ¥ n‚ÇÄ n‚ÇÅ z)) 0","decl":"lemma Œ¥_Œ¥ (n‚ÇÄ n‚ÇÅ n‚ÇÇ : ‚Ñ§) (z : Cochain F G n‚ÇÄ) : Œ¥ n‚ÇÅ n‚ÇÇ (Œ¥ n‚ÇÄ n‚ÇÅ z) = 0 := by\n  by_cases h‚ÇÅ‚ÇÇ : n‚ÇÅ + 1 = n‚ÇÇ; swap\n  ¬∑ rw [Œ¥_shape _ _ h‚ÇÅ‚ÇÇ]\n  by_cases h‚ÇÄ‚ÇÅ : n‚ÇÄ + 1 = n‚ÇÅ; swap\n  ¬∑ rw [Œ¥_shape _ _ h‚ÇÄ‚ÇÅ, Œ¥_zero]\n  ext p q hpq\n  dsimp\n  simp only [Œ¥_v n‚ÇÅ n‚ÇÇ h‚ÇÅ‚ÇÇ _ p q hpq _ _ rfl rfl,\n    Œ¥_v n‚ÇÄ n‚ÇÅ h‚ÇÄ‚ÇÅ z p (q-1) (by omega) (q-2) _ (by omega) rfl,\n    Œ¥_v n‚ÇÄ n‚ÇÅ h‚ÇÄ‚ÇÅ z (p+1) q (by omega) _ (p+2) rfl (by omega),\n    ‚Üê h‚ÇÅ‚ÇÇ, Int.negOnePow_succ, add_comp, assoc,\n    HomologicalComplex.d_comp_d, comp_zero, zero_add, comp_add,\n    HomologicalComplex.d_comp_d_assoc, zero_comp, smul_zero,\n    add_zero, add_neg_cancel, Units.neg_smul,\n    Linear.units_smul_comp, Linear.comp_units_smul]\n\n"}
{"name":"CochainComplex.HomComplex.Œ¥_comp","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G K : CochainComplex C Int\nn‚ÇÅ n‚ÇÇ n‚ÇÅ‚ÇÇ : Int\nz‚ÇÅ : CochainComplex.HomComplex.Cochain F G n‚ÇÅ\nz‚ÇÇ : CochainComplex.HomComplex.Cochain G K n‚ÇÇ\nh : Eq (HAdd.hAdd n‚ÇÅ n‚ÇÇ) n‚ÇÅ‚ÇÇ\nm‚ÇÅ m‚ÇÇ m‚ÇÅ‚ÇÇ : Int\nh‚ÇÅ‚ÇÇ : Eq (HAdd.hAdd n‚ÇÅ‚ÇÇ 1) m‚ÇÅ‚ÇÇ\nh‚ÇÅ : Eq (HAdd.hAdd n‚ÇÅ 1) m‚ÇÅ\nh‚ÇÇ : Eq (HAdd.hAdd n‚ÇÇ 1) m‚ÇÇ\n‚ä¢ Eq (CochainComplex.HomComplex.Œ¥ n‚ÇÅ‚ÇÇ m‚ÇÅ‚ÇÇ (z‚ÇÅ.comp z‚ÇÇ h)) (HAdd.hAdd (z‚ÇÅ.comp (CochainComplex.HomComplex.Œ¥ n‚ÇÇ m‚ÇÇ z‚ÇÇ) ‚ãØ) (HSMul.hSMul n‚ÇÇ.negOnePow ((CochainComplex.HomComplex.Œ¥ n‚ÇÅ m‚ÇÅ z‚ÇÅ).comp z‚ÇÇ ‚ãØ)))","decl":"lemma Œ¥_comp {n‚ÇÅ n‚ÇÇ n‚ÇÅ‚ÇÇ : ‚Ñ§} (z‚ÇÅ : Cochain F G n‚ÇÅ) (z‚ÇÇ : Cochain G K n‚ÇÇ) (h : n‚ÇÅ + n‚ÇÇ = n‚ÇÅ‚ÇÇ)\n    (m‚ÇÅ m‚ÇÇ m‚ÇÅ‚ÇÇ : ‚Ñ§) (h‚ÇÅ‚ÇÇ : n‚ÇÅ‚ÇÇ + 1 = m‚ÇÅ‚ÇÇ) (h‚ÇÅ : n‚ÇÅ + 1 = m‚ÇÅ) (h‚ÇÇ : n‚ÇÇ + 1 = m‚ÇÇ) :\n    Œ¥ n‚ÇÅ‚ÇÇ m‚ÇÅ‚ÇÇ (z‚ÇÅ.comp z‚ÇÇ h) = z‚ÇÅ.comp (Œ¥ n‚ÇÇ m‚ÇÇ z‚ÇÇ) (by rw [‚Üê h‚ÇÅ‚ÇÇ, ‚Üê h‚ÇÇ, ‚Üê h, add_assoc]) +\n      n‚ÇÇ.negOnePow ‚Ä¢ (Œ¥ n‚ÇÅ m‚ÇÅ z‚ÇÅ).comp z‚ÇÇ\n        (by rw [‚Üê h‚ÇÅ‚ÇÇ, ‚Üê h‚ÇÅ, ‚Üê h, add_assoc, add_comm 1, add_assoc]) := by\n  subst h‚ÇÅ‚ÇÇ h‚ÇÅ h‚ÇÇ h\n  ext p q hpq\n  dsimp\n  rw [z‚ÇÅ.comp_v _ (add_assoc n‚ÇÅ n‚ÇÇ 1).symm p _ q rfl (by omega),\n    Cochain.comp_v _ _ (show n‚ÇÅ + 1 + n‚ÇÇ = n‚ÇÅ + n‚ÇÇ + 1 by omega) p (p+n‚ÇÅ+1) q\n      (by omega) (by omega),\n    Œ¥_v (n‚ÇÅ + n‚ÇÇ) _ rfl (z‚ÇÅ.comp z‚ÇÇ rfl) p q hpq (p + n‚ÇÅ + n‚ÇÇ) _ (by omega) rfl,\n    z‚ÇÅ.comp_v z‚ÇÇ rfl p _ _ rfl rfl,\n    z‚ÇÅ.comp_v z‚ÇÇ rfl (p+1) (p+n‚ÇÅ+1) q (by omega) (by omega),\n    Œ¥_v n‚ÇÇ (n‚ÇÇ+1) rfl z‚ÇÇ (p+n‚ÇÅ) q (by omega) (p+n‚ÇÅ+n‚ÇÇ) _ (by omega) rfl,\n    Œ¥_v n‚ÇÅ (n‚ÇÅ+1) rfl z‚ÇÅ p (p+n‚ÇÅ+1) (by omega) (p+n‚ÇÅ) _ (by omega) rfl]\n  simp only [assoc, comp_add, add_comp, Int.negOnePow_succ, Int.negOnePow_add n‚ÇÅ n‚ÇÇ,\n    Units.neg_smul, comp_neg, neg_comp, smul_neg, smul_smul, Linear.units_smul_comp,\n    mul_comm n‚ÇÅ.negOnePow n‚ÇÇ.negOnePow, Linear.comp_units_smul, smul_add]\n  abel\n\n"}
{"name":"CochainComplex.HomComplex.Œ¥_zero_cochain_comp","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G K : CochainComplex C Int\nn‚ÇÇ : Int\nz‚ÇÅ : CochainComplex.HomComplex.Cochain F G 0\nz‚ÇÇ : CochainComplex.HomComplex.Cochain G K n‚ÇÇ\nm‚ÇÇ : Int\nh‚ÇÇ : Eq (HAdd.hAdd n‚ÇÇ 1) m‚ÇÇ\n‚ä¢ Eq (CochainComplex.HomComplex.Œ¥ n‚ÇÇ m‚ÇÇ (z‚ÇÅ.comp z‚ÇÇ ‚ãØ)) (HAdd.hAdd (z‚ÇÅ.comp (CochainComplex.HomComplex.Œ¥ n‚ÇÇ m‚ÇÇ z‚ÇÇ) ‚ãØ) (HSMul.hSMul n‚ÇÇ.negOnePow ((CochainComplex.HomComplex.Œ¥ 0 1 z‚ÇÅ).comp z‚ÇÇ ‚ãØ)))","decl":"lemma Œ¥_zero_cochain_comp {n‚ÇÇ : ‚Ñ§} (z‚ÇÅ : Cochain F G 0) (z‚ÇÇ : Cochain G K n‚ÇÇ)\n    (m‚ÇÇ : ‚Ñ§) (h‚ÇÇ : n‚ÇÇ + 1 = m‚ÇÇ) :\n    Œ¥ n‚ÇÇ m‚ÇÇ (z‚ÇÅ.comp z‚ÇÇ (zero_add n‚ÇÇ)) =\n      z‚ÇÅ.comp (Œ¥ n‚ÇÇ m‚ÇÇ z‚ÇÇ) (zero_add m‚ÇÇ) +\n      n‚ÇÇ.negOnePow ‚Ä¢ ((Œ¥ 0 1 z‚ÇÅ).comp z‚ÇÇ (by rw [add_comm, h‚ÇÇ])) :=\n  Œ¥_comp z‚ÇÅ z‚ÇÇ (zero_add n‚ÇÇ) 1 m‚ÇÇ m‚ÇÇ h‚ÇÇ (zero_add 1) h‚ÇÇ\n\n"}
{"name":"CochainComplex.HomComplex.Œ¥_comp_zero_cochain","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G K : CochainComplex C Int\nn‚ÇÅ : Int\nz‚ÇÅ : CochainComplex.HomComplex.Cochain F G n‚ÇÅ\nz‚ÇÇ : CochainComplex.HomComplex.Cochain G K 0\nm‚ÇÅ : Int\nh‚ÇÅ : Eq (HAdd.hAdd n‚ÇÅ 1) m‚ÇÅ\n‚ä¢ Eq (CochainComplex.HomComplex.Œ¥ n‚ÇÅ m‚ÇÅ (z‚ÇÅ.comp z‚ÇÇ ‚ãØ)) (HAdd.hAdd (z‚ÇÅ.comp (CochainComplex.HomComplex.Œ¥ 0 1 z‚ÇÇ) h‚ÇÅ) ((CochainComplex.HomComplex.Œ¥ n‚ÇÅ m‚ÇÅ z‚ÇÅ).comp z‚ÇÇ ‚ãØ))","decl":"lemma Œ¥_comp_zero_cochain {n‚ÇÅ : ‚Ñ§} (z‚ÇÅ : Cochain F G n‚ÇÅ) (z‚ÇÇ : Cochain G K 0)\n    (m‚ÇÅ : ‚Ñ§) (h‚ÇÅ : n‚ÇÅ + 1 = m‚ÇÅ) :\n    Œ¥ n‚ÇÅ m‚ÇÅ (z‚ÇÅ.comp z‚ÇÇ (add_zero n‚ÇÅ)) =\n      z‚ÇÅ.comp (Œ¥ 0 1 z‚ÇÇ) h‚ÇÅ + (Œ¥ n‚ÇÅ m‚ÇÅ z‚ÇÅ).comp z‚ÇÇ (add_zero m‚ÇÅ) := by\n  simp only [Œ¥_comp z‚ÇÅ z‚ÇÇ (add_zero n‚ÇÅ) m‚ÇÅ 1 m‚ÇÅ h‚ÇÅ h‚ÇÅ (zero_add 1), one_smul,\n    Int.negOnePow_zero]\n\n"}
{"name":"CochainComplex.HomComplex.Œ¥_zero_cochain_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nz : CochainComplex.HomComplex.Cochain F G 0\np q : Int\nhpq : Eq (HAdd.hAdd p 1) q\n‚ä¢ Eq ((CochainComplex.HomComplex.Œ¥ 0 1 z).v p q hpq) (HSub.hSub (CategoryTheory.CategoryStruct.comp (z.v p p ‚ãØ) (G.d p q)) (CategoryTheory.CategoryStruct.comp (F.d p q) (z.v q q ‚ãØ)))","decl":"@[simp]\nlemma Œ¥_zero_cochain_v (z : Cochain F G 0) (p q : ‚Ñ§) (hpq : p + 1 = q) :\n    (Œ¥ 0 1 z).v p q hpq = z.v p p (add_zero p) ‚â´ G.d p q - F.d p q ‚â´ z.v q q (add_zero q) := by\n  simp only [Œ¥_v 0 1 (zero_add 1) z p q hpq p q (by omega) hpq, zero_add,\n    Int.negOnePow_one, Units.neg_smul, one_smul, sub_eq_add_neg]\n\n"}
{"name":"CochainComplex.HomComplex.Œ¥_ofHom","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\np : Int\nœÜ : Quiver.Hom F G\n‚ä¢ Eq (CochainComplex.HomComplex.Œ¥ 0 p (CochainComplex.HomComplex.Cochain.ofHom œÜ)) 0","decl":"@[simp]\nlemma Œ¥_ofHom {p : ‚Ñ§} (œÜ : F ‚ü∂ G) : Œ¥ 0 p (Cochain.ofHom œÜ) = 0 := by\n  by_cases h : p = 1\n  ¬∑ subst h\n    ext\n    simp\n  ¬∑ rw [Œ¥_shape]\n    omega\n\n"}
{"name":"CochainComplex.HomComplex.Œ¥_ofHomotopy","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nœÜ‚ÇÅ œÜ‚ÇÇ : Quiver.Hom F G\nh : Homotopy œÜ‚ÇÅ œÜ‚ÇÇ\n‚ä¢ Eq (CochainComplex.HomComplex.Œ¥ (-1) 0 (CochainComplex.HomComplex.Cochain.ofHomotopy h)) (HSub.hSub (CochainComplex.HomComplex.Cochain.ofHom œÜ‚ÇÅ) (CochainComplex.HomComplex.Cochain.ofHom œÜ‚ÇÇ))","decl":"@[simp]\nlemma Œ¥_ofHomotopy {œÜ‚ÇÅ œÜ‚ÇÇ : F ‚ü∂ G} (h : Homotopy œÜ‚ÇÅ œÜ‚ÇÇ) :\n    Œ¥ (-1) 0 (Cochain.ofHomotopy h) = Cochain.ofHom œÜ‚ÇÅ - Cochain.ofHom œÜ‚ÇÇ := by\n  ext p\n  have eq := h.comm p\n  rw [dNext_eq h.hom (show (ComplexShape.up ‚Ñ§).Rel p (p+1) by simp),\n    prevD_eq h.hom (show (ComplexShape.up ‚Ñ§).Rel (p-1) p by simp)] at eq\n  rw [Cochain.ofHomotopy, Œ¥_v (-1) 0 (neg_add_cancel 1) _ p p (add_zero p) (p-1) (p+1) rfl rfl]\n  simp only [Cochain.mk_v, neg_add_cancel, one_smul, Int.negOnePow_zero,\n    Cochain.sub_v, Cochain.ofHom_v, eq]\n  abel\n\n"}
{"name":"CochainComplex.HomComplex.Œ¥_neg_one_cochain","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nz : CochainComplex.HomComplex.Cochain F G (-1)\n‚ä¢ Eq (CochainComplex.HomComplex.Œ¥ (-1) 0 z) (CochainComplex.HomComplex.Cochain.ofHom (Homotopy.nullHomotopicMap' fun i j hij => z.v i j ‚ãØ))","decl":"lemma Œ¥_neg_one_cochain (z : Cochain F G (-1)) :\n    Œ¥ (-1) 0 z = Cochain.ofHom (Homotopy.nullHomotopicMap'\n      (fun i j hij => z.v i j (by dsimp at hij; rw [‚Üê hij, add_neg_cancel_right]))) := by\n  ext p\n  rw [Œ¥_v (-1) 0 (neg_add_cancel 1) _ p p (add_zero p) (p-1) (p+1) rfl rfl]\n  simp only [neg_add_cancel, one_smul, Cochain.ofHom_v, Int.negOnePow_zero]\n  rw [Homotopy.nullHomotopicMap'_f (show (ComplexShape.up ‚Ñ§).Rel (p-1) p by simp)\n    (show (ComplexShape.up ‚Ñ§).Rel p (p+1) by simp)]\n  abel\n\n"}
{"name":"CochainComplex.HomComplex_X","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\ni : Int\n‚ä¢ Eq ((F.HomComplex G).X i) (AddCommGrp.of (CochainComplex.HomComplex.Cochain F G i))","decl":"/-- The cochain complex of homomorphisms between two cochain complexes `F` and `G`.\nIn degree `n : ‚Ñ§`, it consists of the abelian group `HomComplex.Cochain F G n`. -/\n@[simps! X d_hom_apply]\ndef HomComplex : CochainComplex AddCommGrp ‚Ñ§ where\n  X i := AddCommGrp.of (Cochain F G i)\n  d i j := AddCommGrp.ofHom (Œ¥_hom ‚Ñ§ F G i j)\n  shape _ _ hij := by ext; simp [Œ¥_shape _ _ hij]\n  d_comp_d' _ _ _ _ _  := by ext; simp [Œ¥_Œ¥]\n\n"}
{"name":"CochainComplex.HomComplex_d_hom_apply","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\ni j : Int\na‚úù : CochainComplex.HomComplex.Cochain F G i\n‚ä¢ Eq ((AddCommGrp.Hom.hom ((F.HomComplex G).d i j)) a‚úù) (CochainComplex.HomComplex.Œ¥ i j a‚úù)","decl":"/-- The cochain complex of homomorphisms between two cochain complexes `F` and `G`.\nIn degree `n : ‚Ñ§`, it consists of the abelian group `HomComplex.Cochain F G n`. -/\n@[simps! X d_hom_apply]\ndef HomComplex : CochainComplex AddCommGrp ‚Ñ§ where\n  X i := AddCommGrp.of (Cochain F G i)\n  d i j := AddCommGrp.ofHom (Œ¥_hom ‚Ñ§ F G i j)\n  shape _ _ hij := by ext; simp [Œ¥_shape _ _ hij]\n  d_comp_d' _ _ _ _ _  := by ext; simp [Œ¥_Œ¥]\n\n"}
{"name":"CochainComplex.HomComplex.Cocycle.mem_iff","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nn m : Int\nhnm : Eq (HAdd.hAdd n 1) m\nz : CochainComplex.HomComplex.Cochain F G n\n‚ä¢ Iff (Membership.mem (CochainComplex.HomComplex.cocycle F G n) z) (Eq (CochainComplex.HomComplex.Œ¥ n m z) 0)","decl":"lemma mem_iff (hnm : n + 1 = m) (z : Cochain F G n) :\n    z ‚àà cocycle F G n ‚Üî Œ¥ n m z = 0 := by subst hnm; rfl\n\n"}
{"name":"CochainComplex.HomComplex.Cocycle.ext_iff","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nn : Int\nz‚ÇÅ z‚ÇÇ : CochainComplex.HomComplex.Cocycle F G n\n‚ä¢ Iff (Eq z‚ÇÅ z‚ÇÇ) (Eq ‚Üëz‚ÇÅ ‚Üëz‚ÇÇ)","decl":"@[ext]\nlemma ext (z‚ÇÅ z‚ÇÇ : Cocycle F G n) (h : (z‚ÇÅ : Cochain F G n) = z‚ÇÇ) : z‚ÇÅ = z‚ÇÇ :=\n  Subtype.ext h\n\n"}
{"name":"CochainComplex.HomComplex.Cocycle.ext","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nn : Int\nz‚ÇÅ z‚ÇÇ : CochainComplex.HomComplex.Cocycle F G n\nh : Eq ‚Üëz‚ÇÅ ‚Üëz‚ÇÇ\n‚ä¢ Eq z‚ÇÅ z‚ÇÇ","decl":"@[ext]\nlemma ext (z‚ÇÅ z‚ÇÇ : Cocycle F G n) (h : (z‚ÇÅ : Cochain F G n) = z‚ÇÇ) : z‚ÇÅ = z‚ÇÇ :=\n  Subtype.ext h\n\n"}
{"name":"CochainComplex.HomComplex.Cocycle.coe_zero","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nn : Int\n‚ä¢ Eq (‚Üë0) 0","decl":"@[simp]\nlemma coe_zero : (‚Üë(0 : Cocycle F G n) : Cochain F G n) = 0 := by rfl\n\n"}
{"name":"CochainComplex.HomComplex.Cocycle.coe_add","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nn : Int\nz‚ÇÅ z‚ÇÇ : CochainComplex.HomComplex.Cocycle F G n\n‚ä¢ Eq (‚Üë(HAdd.hAdd z‚ÇÅ z‚ÇÇ)) (HAdd.hAdd ‚Üëz‚ÇÅ ‚Üëz‚ÇÇ)","decl":"@[simp]\nlemma coe_add (z‚ÇÅ z‚ÇÇ : Cocycle F G n) :\n    (‚Üë(z‚ÇÅ + z‚ÇÇ) : Cochain F G n) = (z‚ÇÅ : Cochain F G n) + (z‚ÇÇ : Cochain F G n) := rfl\n\n"}
{"name":"CochainComplex.HomComplex.Cocycle.coe_neg","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nn : Int\nz : CochainComplex.HomComplex.Cocycle F G n\n‚ä¢ Eq (‚Üë(Neg.neg z)) (Neg.neg ‚Üëz)","decl":"@[simp]\nlemma coe_neg (z : Cocycle F G n) :\n    (‚Üë(-z) : Cochain F G n) = -(z : Cochain F G n) := rfl\n\n"}
{"name":"CochainComplex.HomComplex.Cocycle.coe_smul","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Preadditive C\nR : Type u_1\ninst‚úù¬π : Ring R\ninst‚úù : CategoryTheory.Linear R C\nF G : CochainComplex C Int\nn : Int\nz : CochainComplex.HomComplex.Cocycle F G n\nx : R\n‚ä¢ Eq (‚Üë(HSMul.hSMul x z)) (HSMul.hSMul x ‚Üëz)","decl":"@[simp]\nlemma coe_smul (z : Cocycle F G n) (x : R) :\n    (‚Üë(x ‚Ä¢ z) : Cochain F G n) = x ‚Ä¢ (z : Cochain F G n) := rfl\n\n"}
{"name":"CochainComplex.HomComplex.Cocycle.coe_units_smul","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Preadditive C\nR : Type u_1\ninst‚úù¬π : Ring R\ninst‚úù : CategoryTheory.Linear R C\nF G : CochainComplex C Int\nn : Int\nz : CochainComplex.HomComplex.Cocycle F G n\nx : Units R\n‚ä¢ Eq (‚Üë(HSMul.hSMul x z)) (HSMul.hSMul x ‚Üëz)","decl":"@[simp]\nlemma coe_units_smul (z : Cocycle F G n) (x : RÀ£) :\n    (‚Üë(x ‚Ä¢ z) : Cochain F G n) = x ‚Ä¢ (z : Cochain F G n) := rfl\n\n"}
{"name":"CochainComplex.HomComplex.Cocycle.coe_sub","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nn : Int\nz‚ÇÅ z‚ÇÇ : CochainComplex.HomComplex.Cocycle F G n\n‚ä¢ Eq (‚Üë(HSub.hSub z‚ÇÅ z‚ÇÇ)) (HSub.hSub ‚Üëz‚ÇÅ ‚Üëz‚ÇÇ)","decl":"@[simp]\nlemma coe_sub (z‚ÇÅ z‚ÇÇ : Cocycle F G n) :\n    (‚Üë(z‚ÇÅ - z‚ÇÇ) : Cochain F G n) = (z‚ÇÅ : Cochain F G n) - (z‚ÇÇ : Cochain F G n) := rfl\n\n"}
{"name":"CochainComplex.HomComplex.Cocycle.mk_coe","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nn : Int\nz : CochainComplex.HomComplex.Cochain F G n\nm : Int\nhnm : Eq (HAdd.hAdd n 1) m\nh : Eq (CochainComplex.HomComplex.Œ¥ n m z) 0\n‚ä¢ Eq (‚Üë(CochainComplex.HomComplex.Cocycle.mk z m hnm h)) z","decl":"/-- Constructor for `Cocycle F G n`, taking as inputs `z : Cochain F G n`, an integer\n`m : ‚Ñ§` such that `n + 1 = m`, and the relation `Œ¥ n m z = 0`. -/\n@[simps]\ndef mk (z : Cochain F G n) (m : ‚Ñ§) (hnm : n + 1 = m) (h : Œ¥ n m z = 0) : Cocycle F G n :=\n  ‚ü®z, by simpa only [mem_iff n m hnm z] using h‚ü©\n\n"}
{"name":"CochainComplex.HomComplex.Cocycle.Œ¥_eq_zero","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nn : Int\nz : CochainComplex.HomComplex.Cocycle F G n\nm : Int\n‚ä¢ Eq (CochainComplex.HomComplex.Œ¥ n m ‚Üëz) 0","decl":"@[simp]\nlemma Œ¥_eq_zero {n : ‚Ñ§} (z : Cocycle F G n) (m : ‚Ñ§) : Œ¥ n m (z : Cochain F G n) = 0 := by\n  by_cases h : n + 1 = m\n  ¬∑ rw [‚Üê mem_iff n m h]\n    exact z.2\n  ¬∑ exact Œ¥_shape n m h _\n\n"}
{"name":"CochainComplex.HomComplex.Cocycle.ofHom_coe","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nœÜ : Quiver.Hom F G\n‚ä¢ Eq (‚Üë(CochainComplex.HomComplex.Cocycle.ofHom œÜ)) (CochainComplex.HomComplex.Cochain.ofHom œÜ)","decl":"/-- The `0`-cocycle associated to a morphism in `CochainComplex C ‚Ñ§`. -/\n@[simps!]\ndef ofHom (œÜ : F ‚ü∂ G) : Cocycle F G 0 := mk (Cochain.ofHom œÜ) 1 (zero_add 1) (by simp)\n\n"}
{"name":"CochainComplex.HomComplex.Cocycle.homOf_f","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nz : CochainComplex.HomComplex.Cocycle F G 0\ni : Int\n‚ä¢ Eq (z.homOf.f i) ((‚Üëz).v i i ‚ãØ)","decl":"/-- The morphism in `CochainComplex C ‚Ñ§` associated to a `0`-cocycle. -/\n@[simps]\ndef homOf (z : Cocycle F G 0) : F ‚ü∂ G where\n  f i := (z : Cochain _ _ _).v i i (add_zero i)\n  comm' := by\n    rintro i j rfl\n    rcases z with ‚ü®z, hz‚ü©\n    dsimp\n    rw [mem_iff 0 1 (zero_add 1)] at hz\n    simpa only [Œ¥_zero_cochain_v, Cochain.zero_v, sub_eq_zero]\n      using Cochain.congr_v hz i (i + 1) rfl\n\n"}
{"name":"CochainComplex.HomComplex.Cocycle.homOf_ofHom_eq_self","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nœÜ : Quiver.Hom F G\n‚ä¢ Eq (CochainComplex.HomComplex.Cocycle.ofHom œÜ).homOf œÜ","decl":"@[simp]\nlemma homOf_ofHom_eq_self (œÜ : F ‚ü∂ G) : homOf (ofHom œÜ) = œÜ := by aesop_cat\n\n"}
{"name":"CochainComplex.HomComplex.Cocycle.ofHom_homOf_eq_self","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nz : CochainComplex.HomComplex.Cocycle F G 0\n‚ä¢ Eq (CochainComplex.HomComplex.Cocycle.ofHom z.homOf) z","decl":"@[simp]\nlemma ofHom_homOf_eq_self (z : Cocycle F G 0) : ofHom (homOf z) = z := by aesop_cat\n\n"}
{"name":"CochainComplex.HomComplex.Cocycle.cochain_ofHom_homOf_eq_coe","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nz : CochainComplex.HomComplex.Cocycle F G 0\n‚ä¢ Eq (CochainComplex.HomComplex.Cochain.ofHom z.homOf) ‚Üëz","decl":"@[simp]\nlemma cochain_ofHom_homOf_eq_coe (z : Cocycle F G 0) :\n    Cochain.ofHom (homOf z) = (z : Cochain F G 0) := by\n  simpa only [Cocycle.ext_iff] using ofHom_homOf_eq_self z\n\n"}
{"name":"CochainComplex.HomComplex.Cocycle.equivHom_apply","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nœÜ : Quiver.Hom F G\n‚ä¢ Eq ((CochainComplex.HomComplex.Cocycle.equivHom F G) œÜ) (CochainComplex.HomComplex.Cocycle.ofHom œÜ)","decl":"/-- The additive equivalence between morphisms in `CochainComplex C ‚Ñ§` and `0`-cocycles. -/\n@[simps]\ndef equivHom : (F ‚ü∂ G) ‚âÉ+ Cocycle F G 0 where\n  toFun := ofHom\n  invFun := homOf\n  left_inv := homOf_ofHom_eq_self\n  right_inv := ofHom_homOf_eq_self\n  map_add' := by aesop_cat\n\n"}
{"name":"CochainComplex.HomComplex.Cocycle.equivHom_symm_apply","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nz : CochainComplex.HomComplex.Cocycle F G 0\n‚ä¢ Eq ((CochainComplex.HomComplex.Cocycle.equivHom F G).symm z) z.homOf","decl":"/-- The additive equivalence between morphisms in `CochainComplex C ‚Ñ§` and `0`-cocycles. -/\n@[simps]\ndef equivHom : (F ‚ü∂ G) ‚âÉ+ Cocycle F G 0 where\n  toFun := ofHom\n  invFun := homOf\n  left_inv := homOf_ofHom_eq_self\n  right_inv := ofHom_homOf_eq_self\n  map_add' := by aesop_cat\n\n"}
{"name":"CochainComplex.HomComplex.Cocycle.diff_coe","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nK : CochainComplex C Int\n‚ä¢ Eq (‚Üë(CochainComplex.HomComplex.Cocycle.diff K)) (CochainComplex.HomComplex.Cochain.diff K)","decl":"/-- The `1`-cocycle given by the differential on a cochain complex. -/\n@[simps!]\ndef diff : Cocycle K K 1 :=\n  Cocycle.mk (Cochain.diff K) 2 rfl (by\n    ext p q hpq\n    simp only [Cochain.zero_v, Œ¥_v 1 2 rfl _ p q hpq _ _ rfl rfl, Cochain.diff_v,\n      HomologicalComplex.d_comp_d, smul_zero, add_zero])\n\n"}
{"name":"CochainComplex.HomComplex.Œ¥_comp_zero_cocycle","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G K : CochainComplex C Int\nn : Int\nz‚ÇÅ : CochainComplex.HomComplex.Cochain F G n\nz‚ÇÇ : CochainComplex.HomComplex.Cocycle G K 0\nm : Int\n‚ä¢ Eq (CochainComplex.HomComplex.Œ¥ n m (z‚ÇÅ.comp ‚Üëz‚ÇÇ ‚ãØ)) ((CochainComplex.HomComplex.Œ¥ n m z‚ÇÅ).comp ‚Üëz‚ÇÇ ‚ãØ)","decl":"@[simp]\nlemma Œ¥_comp_zero_cocycle {n : ‚Ñ§} (z‚ÇÅ : Cochain F G n) (z‚ÇÇ : Cocycle G K 0) (m : ‚Ñ§) :\n    Œ¥ n m (z‚ÇÅ.comp z‚ÇÇ.1 (add_zero n)) =\n      (Œ¥ n m z‚ÇÅ).comp z‚ÇÇ.1 (add_zero m) := by\n  by_cases hnm : n + 1 = m\n  ¬∑ simp [Œ¥_comp_zero_cochain _ _ _ hnm]\n  ¬∑ simp [Œ¥_shape _ _ hnm]\n\n"}
{"name":"CochainComplex.HomComplex.Œ¥_comp_ofHom","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G K : CochainComplex C Int\nn : Int\nz‚ÇÅ : CochainComplex.HomComplex.Cochain F G n\nf : Quiver.Hom G K\nm : Int\n‚ä¢ Eq (CochainComplex.HomComplex.Œ¥ n m (z‚ÇÅ.comp (CochainComplex.HomComplex.Cochain.ofHom f) ‚ãØ)) ((CochainComplex.HomComplex.Œ¥ n m z‚ÇÅ).comp (CochainComplex.HomComplex.Cochain.ofHom f) ‚ãØ)","decl":"@[simp]\nlemma Œ¥_comp_ofHom {n : ‚Ñ§} (z‚ÇÅ : Cochain F G n) (f : G ‚ü∂ K) (m : ‚Ñ§) :\n    Œ¥ n m (z‚ÇÅ.comp (Cochain.ofHom f) (add_zero n)) =\n      (Œ¥ n m z‚ÇÅ).comp (Cochain.ofHom f) (add_zero m) := by\n  rw [‚Üê Cocycle.ofHom_coe, Œ¥_comp_zero_cocycle]\n\n\n"}
{"name":"CochainComplex.HomComplex.Œ¥_zero_cocycle_comp","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G K : CochainComplex C Int\nn : Int\nz‚ÇÅ : CochainComplex.HomComplex.Cocycle F G 0\nz‚ÇÇ : CochainComplex.HomComplex.Cochain G K n\nm : Int\n‚ä¢ Eq (CochainComplex.HomComplex.Œ¥ n m ((‚Üëz‚ÇÅ).comp z‚ÇÇ ‚ãØ)) ((‚Üëz‚ÇÅ).comp (CochainComplex.HomComplex.Œ¥ n m z‚ÇÇ) ‚ãØ)","decl":"@[simp]\nlemma Œ¥_zero_cocycle_comp {n : ‚Ñ§} (z‚ÇÅ : Cocycle F G 0) (z‚ÇÇ : Cochain G K n) (m : ‚Ñ§) :\n    Œ¥ n m (z‚ÇÅ.1.comp z‚ÇÇ (zero_add n)) =\n      z‚ÇÅ.1.comp (Œ¥ n m z‚ÇÇ) (zero_add m) := by\n  by_cases hnm : n + 1 = m\n  ¬∑ simp [Œ¥_zero_cochain_comp _ _ _ hnm]\n  ¬∑ simp [Œ¥_shape _ _ hnm]\n\n"}
{"name":"CochainComplex.HomComplex.Œ¥_ofHom_comp","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G K : CochainComplex C Int\nn : Int\nf : Quiver.Hom F G\nz : CochainComplex.HomComplex.Cochain G K n\nm : Int\n‚ä¢ Eq (CochainComplex.HomComplex.Œ¥ n m ((CochainComplex.HomComplex.Cochain.ofHom f).comp z ‚ãØ)) ((CochainComplex.HomComplex.Cochain.ofHom f).comp (CochainComplex.HomComplex.Œ¥ n m z) ‚ãØ)","decl":"@[simp]\nlemma Œ¥_ofHom_comp {n : ‚Ñ§} (f : F ‚ü∂ G) (z : Cochain G K n) (m : ‚Ñ§) :\n    Œ¥ n m ((Cochain.ofHom f).comp z (zero_add n)) =\n      (Cochain.ofHom f).comp (Œ¥ n m z) (zero_add m) := by\n  rw [‚Üê Cocycle.ofHom_coe, Œ¥_zero_cocycle_comp]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.equivHomotopy_apply_coe","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nœÜ‚ÇÅ œÜ‚ÇÇ : Quiver.Hom F G\nho : Homotopy œÜ‚ÇÅ œÜ‚ÇÇ\n‚ä¢ Eq (‚Üë((CochainComplex.HomComplex.Cochain.equivHomotopy œÜ‚ÇÅ œÜ‚ÇÇ) ho)) (CochainComplex.HomComplex.Cochain.ofHomotopy ho)","decl":"/-- Given two morphisms of complexes `œÜ‚ÇÅ œÜ‚ÇÇ : F ‚ü∂ G`, the datum of an homotopy between `œÜ‚ÇÅ` and\n`œÜ‚ÇÇ` is equivalent to the datum of a `1`-cochain `z` such that `Œ¥ (-1) 0 z` is the difference\nof the zero cochains associated to `œÜ‚ÇÇ` and `œÜ‚ÇÅ`. -/\n@[simps]\ndef equivHomotopy (œÜ‚ÇÅ œÜ‚ÇÇ : F ‚ü∂ G) :\n    Homotopy œÜ‚ÇÅ œÜ‚ÇÇ ‚âÉ\n      { z : Cochain F G (-1) // Cochain.ofHom œÜ‚ÇÅ = Œ¥ (-1) 0 z + Cochain.ofHom œÜ‚ÇÇ } where\n  toFun ho := ‚ü®Cochain.ofHomotopy ho, by simp only [Œ¥_ofHomotopy, sub_add_cancel]‚ü©\n  invFun z :=\n    { hom := fun i j => if hij : i + (-1) = j then z.1.v i j hij else 0\n      zero := fun i j (hij : j + 1 ‚â† i) => dif_neg (fun _ => hij (by omega))\n      comm := fun p => by\n        have eq := Cochain.congr_v z.2 p p (add_zero p)\n        have h‚ÇÅ : (ComplexShape.up ‚Ñ§).Rel (p - 1) p := by simp\n        have h‚ÇÇ : (ComplexShape.up ‚Ñ§).Rel p (p + 1) := by simp\n        simp only [Œ¥_neg_one_cochain, Cochain.ofHom_v, ComplexShape.up_Rel, Cochain.add_v,\n          Homotopy.nullHomotopicMap'_f h‚ÇÅ h‚ÇÇ] at eq\n        rw [dNext_eq _ h‚ÇÇ, prevD_eq _ h‚ÇÅ, eq, dif_pos, dif_pos] }\n  left_inv := fun ho => by\n    ext i j\n    dsimp\n    split_ifs with h\n    ¬∑ rfl\n    ¬∑ rw [ho.zero i j (fun h' => h (by dsimp at h'; omega))]\n  right_inv := fun z => by\n    ext p q hpq\n    dsimp [Cochain.ofHomotopy]\n    rw [dif_pos hpq]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.equivHomotopy_symm_apply_hom","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nœÜ‚ÇÅ œÜ‚ÇÇ : Quiver.Hom F G\nz : Subtype fun z => Eq (CochainComplex.HomComplex.Cochain.ofHom œÜ‚ÇÅ) (HAdd.hAdd (CochainComplex.HomComplex.Œ¥ (-1) 0 z) (CochainComplex.HomComplex.Cochain.ofHom œÜ‚ÇÇ))\ni j : Int\n‚ä¢ Eq (((CochainComplex.HomComplex.Cochain.equivHomotopy œÜ‚ÇÅ œÜ‚ÇÇ).symm z).hom i j) (dite (Eq (HAdd.hAdd i (-1)) j) (fun hij => (‚Üëz).v i j hij) fun hij => 0)","decl":"/-- Given two morphisms of complexes `œÜ‚ÇÅ œÜ‚ÇÇ : F ‚ü∂ G`, the datum of an homotopy between `œÜ‚ÇÅ` and\n`œÜ‚ÇÇ` is equivalent to the datum of a `1`-cochain `z` such that `Œ¥ (-1) 0 z` is the difference\nof the zero cochains associated to `œÜ‚ÇÇ` and `œÜ‚ÇÅ`. -/\n@[simps]\ndef equivHomotopy (œÜ‚ÇÅ œÜ‚ÇÇ : F ‚ü∂ G) :\n    Homotopy œÜ‚ÇÅ œÜ‚ÇÇ ‚âÉ\n      { z : Cochain F G (-1) // Cochain.ofHom œÜ‚ÇÅ = Œ¥ (-1) 0 z + Cochain.ofHom œÜ‚ÇÇ } where\n  toFun ho := ‚ü®Cochain.ofHomotopy ho, by simp only [Œ¥_ofHomotopy, sub_add_cancel]‚ü©\n  invFun z :=\n    { hom := fun i j => if hij : i + (-1) = j then z.1.v i j hij else 0\n      zero := fun i j (hij : j + 1 ‚â† i) => dif_neg (fun _ => hij (by omega))\n      comm := fun p => by\n        have eq := Cochain.congr_v z.2 p p (add_zero p)\n        have h‚ÇÅ : (ComplexShape.up ‚Ñ§).Rel (p - 1) p := by simp\n        have h‚ÇÇ : (ComplexShape.up ‚Ñ§).Rel p (p + 1) := by simp\n        simp only [Œ¥_neg_one_cochain, Cochain.ofHom_v, ComplexShape.up_Rel, Cochain.add_v,\n          Homotopy.nullHomotopicMap'_f h‚ÇÅ h‚ÇÇ] at eq\n        rw [dNext_eq _ h‚ÇÇ, prevD_eq _ h‚ÇÅ, eq, dif_pos, dif_pos] }\n  left_inv := fun ho => by\n    ext i j\n    dsimp\n    split_ifs with h\n    ¬∑ rfl\n    ¬∑ rw [ho.zero i j (fun h' => h (by dsimp at h'; omega))]\n  right_inv := fun z => by\n    ext p q hpq\n    dsimp [Cochain.ofHomotopy]\n    rw [dif_pos hpq]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.equivHomotopy_apply_of_eq","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nœÜ‚ÇÅ œÜ‚ÇÇ : Quiver.Hom F G\nh : Eq œÜ‚ÇÅ œÜ‚ÇÇ\n‚ä¢ Eq (‚Üë((CochainComplex.HomComplex.Cochain.equivHomotopy œÜ‚ÇÅ œÜ‚ÇÇ) (Homotopy.ofEq h))) 0","decl":"@[simp]\nlemma equivHomotopy_apply_of_eq {œÜ‚ÇÅ œÜ‚ÇÇ : F ‚ü∂ G} (h : œÜ‚ÇÅ = œÜ‚ÇÇ) :\n    (equivHomotopy _ _ (Homotopy.ofEq h)).1 = 0 := rfl\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.ofHom_injective","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nf‚ÇÅ f‚ÇÇ : Quiver.Hom F G\nh : Eq (CochainComplex.HomComplex.Cochain.ofHom f‚ÇÅ) (CochainComplex.HomComplex.Cochain.ofHom f‚ÇÇ)\n‚ä¢ Eq f‚ÇÅ f‚ÇÇ","decl":"lemma ofHom_injective {f‚ÇÅ f‚ÇÇ : F ‚ü∂ G} (h : ofHom f‚ÇÅ = ofHom f‚ÇÇ) : f‚ÇÅ = f‚ÇÇ :=\n  (Cocycle.equivHom F G).injective (by ext1; exact h)\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.map_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≥ : CategoryTheory.Preadditive C\nK L : CochainComplex C Int\nn : Int\nD : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_2} D\ninst‚úù¬π : CategoryTheory.Preadditive D\nz : CochainComplex.HomComplex.Cochain K L n\nŒ¶ : CategoryTheory.Functor C D\ninst‚úù : Œ¶.Additive\np q : Int\nhpq : Eq (HAdd.hAdd p n) q\n‚ä¢ Eq ((z.map Œ¶).v p q hpq) (Œ¶.map (z.v p q hpq))","decl":"@[simp]\nlemma map_v (p q : ‚Ñ§) (hpq : p + n = q) : (z.map Œ¶).v p q hpq = Œ¶.map (z.v p q hpq) := rfl\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.map_add","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≥ : CategoryTheory.Preadditive C\nK L : CochainComplex C Int\nn : Int\nD : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_2} D\ninst‚úù¬π : CategoryTheory.Preadditive D\nz z' : CochainComplex.HomComplex.Cochain K L n\nŒ¶ : CategoryTheory.Functor C D\ninst‚úù : Œ¶.Additive\n‚ä¢ Eq ((HAdd.hAdd z z').map Œ¶) (HAdd.hAdd (z.map Œ¶) (z'.map Œ¶))","decl":"@[simp]\nlemma map_add : (z + z').map Œ¶ = z.map Œ¶ + z'.map Œ¶ := by aesop_cat\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.map_neg","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≥ : CategoryTheory.Preadditive C\nK L : CochainComplex C Int\nn : Int\nD : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_2} D\ninst‚úù¬π : CategoryTheory.Preadditive D\nz : CochainComplex.HomComplex.Cochain K L n\nŒ¶ : CategoryTheory.Functor C D\ninst‚úù : Œ¶.Additive\n‚ä¢ Eq ((Neg.neg z).map Œ¶) (Neg.neg (z.map Œ¶))","decl":"@[simp]\nlemma map_neg : (-z).map Œ¶ = -z.map Œ¶ := by aesop_cat\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.map_sub","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≥ : CategoryTheory.Preadditive C\nK L : CochainComplex C Int\nn : Int\nD : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_2} D\ninst‚úù¬π : CategoryTheory.Preadditive D\nz z' : CochainComplex.HomComplex.Cochain K L n\nŒ¶ : CategoryTheory.Functor C D\ninst‚úù : Œ¶.Additive\n‚ä¢ Eq ((HSub.hSub z z').map Œ¶) (HSub.hSub (z.map Œ¶) (z'.map Œ¶))","decl":"@[simp]\nlemma map_sub : (z - z').map Œ¶ = z.map Œ¶ - z'.map Œ¶ := by aesop_cat\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.map_zero","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≥ : CategoryTheory.Preadditive C\nK L : CochainComplex C Int\nn : Int\nD : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_2} D\ninst‚úù¬π : CategoryTheory.Preadditive D\nŒ¶ : CategoryTheory.Functor C D\ninst‚úù : Œ¶.Additive\n‚ä¢ Eq (CochainComplex.HomComplex.Cochain.map 0 Œ¶) 0","decl":"@[simp]\nlemma map_zero : (0 : Cochain K L n).map Œ¶ = 0 := by aesop_cat\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.map_comp","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≥ : CategoryTheory.Preadditive C\nF G K : CochainComplex C Int\nD : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_2} D\ninst‚úù¬π : CategoryTheory.Preadditive D\nn‚ÇÅ n‚ÇÇ n‚ÇÅ‚ÇÇ : Int\nz‚ÇÅ : CochainComplex.HomComplex.Cochain F G n‚ÇÅ\nz‚ÇÇ : CochainComplex.HomComplex.Cochain G K n‚ÇÇ\nh : Eq (HAdd.hAdd n‚ÇÅ n‚ÇÇ) n‚ÇÅ‚ÇÇ\nŒ¶ : CategoryTheory.Functor C D\ninst‚úù : Œ¶.Additive\n‚ä¢ Eq ((z‚ÇÅ.comp z‚ÇÇ h).map Œ¶) ((z‚ÇÅ.map Œ¶).comp (z‚ÇÇ.map Œ¶) h)","decl":"@[simp]\nlemma map_comp {n‚ÇÅ n‚ÇÇ n‚ÇÅ‚ÇÇ : ‚Ñ§} (z‚ÇÅ : Cochain F G n‚ÇÅ) (z‚ÇÇ : Cochain G K n‚ÇÇ) (h : n‚ÇÅ + n‚ÇÇ = n‚ÇÅ‚ÇÇ)\n    (Œ¶ : C ‚•§ D) [Œ¶.Additive] :\n    (Cochain.comp z‚ÇÅ z‚ÇÇ h).map Œ¶ = Cochain.comp (z‚ÇÅ.map Œ¶) (z‚ÇÇ.map Œ¶) h := by\n  ext p q hpq\n  dsimp\n  simp only [map_v, comp_v _ _ h p _ q rfl (by omega), Œ¶.map_comp]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.map_ofHom","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≥ : CategoryTheory.Preadditive C\nK L : CochainComplex C Int\nD : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_2} D\ninst‚úù¬π : CategoryTheory.Preadditive D\nf : Quiver.Hom K L\nŒ¶ : CategoryTheory.Functor C D\ninst‚úù : Œ¶.Additive\n‚ä¢ Eq ((CochainComplex.HomComplex.Cochain.ofHom f).map Œ¶) (CochainComplex.HomComplex.Cochain.ofHom ((Œ¶.mapHomologicalComplex (ComplexShape.up Int)).map f))","decl":"@[simp]\nlemma map_ofHom :\n    (Cochain.ofHom f).map Œ¶ = Cochain.ofHom ((Œ¶.mapHomologicalComplex _).map f) := by aesop_cat\n\n"}
{"name":"CochainComplex.HomComplex.Œ¥_map","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≥ : CategoryTheory.Preadditive C\nK L : CochainComplex C Int\nn m : Int\nD : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_2} D\ninst‚úù¬π : CategoryTheory.Preadditive D\nz : CochainComplex.HomComplex.Cochain K L n\nŒ¶ : CategoryTheory.Functor C D\ninst‚úù : Œ¶.Additive\n‚ä¢ Eq (CochainComplex.HomComplex.Œ¥ n m (z.map Œ¶)) ((CochainComplex.HomComplex.Œ¥ n m z).map Œ¶)","decl":"@[simp]\nlemma Œ¥_map : Œ¥ n m (z.map Œ¶) = (Œ¥ n m z).map Œ¶ := by\n  by_cases hnm : n + 1 = m\n  ¬∑ ext p q hpq\n    dsimp\n    simp only [Œ¥_v n m hnm _ p q hpq (q-1) (p+1) rfl rfl,\n      Functor.map_add, Functor.map_comp, Functor.map_units_smul,\n      Cochain.map_v, Functor.mapHomologicalComplex_obj_d]\n  ¬∑ simp only [Œ¥_shape _ _ hnm, Cochain.map_zero]\n\n"}
