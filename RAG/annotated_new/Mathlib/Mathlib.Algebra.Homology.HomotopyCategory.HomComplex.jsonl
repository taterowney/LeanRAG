{"name":"CochainComplex.HomComplex.Triplet.hpq","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"n : Int\nself : CochainComplex.HomComplex.Triplet n\n⊢ Eq (HAdd.hAdd self.p n) self.q","decl":"/-- A term of type `HomComplex.Triplet n` consists of two integers `p` and `q`\nsuch that `p + n = q`. (This type is introduced so that the instance\n`AddCommGroup (Cochain F G n)` defined below can be found automatically.) -/\nstructure Triplet (n : ℤ) where\n  /-- a first integer -/\n  p : ℤ\n  /-- a second integer -/\n  q : ℤ\n  /-- the condition on the two integers -/\n  hpq : p + n = q\n\n"}
{"name":"CochainComplex.HomComplex.Triplet.mk.inj","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"n p✝ q✝ : Int\nhpq✝ : Eq (HAdd.hAdd p✝ n) q✝\np q : Int\nhpq : Eq (HAdd.hAdd p n) q\nx✝ : Eq { p := p✝, q := q✝, hpq := hpq✝ } { p := p, q := q, hpq := hpq }\n⊢ And (Eq p✝ p) (Eq q✝ q)","decl":"/-- A term of type `HomComplex.Triplet n` consists of two integers `p` and `q`\nsuch that `p + n = q`. (This type is introduced so that the instance\n`AddCommGroup (Cochain F G n)` defined below can be found automatically.) -/\nstructure Triplet (n : ℤ) where\n  /-- a first integer -/\n  p : ℤ\n  /-- a second integer -/\n  q : ℤ\n  /-- the condition on the two integers -/\n  hpq : p + n = q\n\n"}
{"name":"CochainComplex.HomComplex.Triplet.mk.injEq","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"n p✝ q✝ : Int\nhpq✝ : Eq (HAdd.hAdd p✝ n) q✝\np q : Int\nhpq : Eq (HAdd.hAdd p n) q\n⊢ Eq (Eq { p := p✝, q := q✝, hpq := hpq✝ } { p := p, q := q, hpq := hpq }) (And (Eq p✝ p) (Eq q✝ q))","decl":"/-- A term of type `HomComplex.Triplet n` consists of two integers `p` and `q`\nsuch that `p + n = q`. (This type is introduced so that the instance\n`AddCommGroup (Cochain F G n)` defined below can be found automatically.) -/\nstructure Triplet (n : ℤ) where\n  /-- a first integer -/\n  p : ℤ\n  /-- a second integer -/\n  q : ℤ\n  /-- the condition on the two integers -/\n  hpq : p + n = q\n\n"}
{"name":"CochainComplex.HomComplex.Triplet.mk.sizeOf_spec","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"n p q : Int\nhpq : Eq (HAdd.hAdd p n) q\n⊢ Eq (SizeOf.sizeOf { p := p, q := q, hpq := hpq }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf p)) (SizeOf.sizeOf q)) (SizeOf.sizeOf hpq))","decl":"/-- A term of type `HomComplex.Triplet n` consists of two integers `p` and `q`\nsuch that `p + n = q`. (This type is introduced so that the instance\n`AddCommGroup (Cochain F G n)` defined below can be found automatically.) -/\nstructure Triplet (n : ℤ) where\n  /-- a first integer -/\n  p : ℤ\n  /-- a second integer -/\n  q : ℤ\n  /-- the condition on the two integers -/\n  hpq : p + n = q\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.mk_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nn : Int\nv : (p q : Int) → Eq (HAdd.hAdd p n) q → Quiver.Hom (F.X p) (G.X q)\np q : Int\nhpq : Eq (HAdd.hAdd p n) q\n⊢ Eq ((CochainComplex.HomComplex.Cochain.mk v).v p q hpq) (v p q hpq)","decl":"@[simp]\nlemma mk_v (v : ∀ (p q : ℤ) (_ : p + n = q), F.X p ⟶ G.X q) (p q : ℤ) (hpq : p + n = q) :\n    (Cochain.mk v).v p q hpq = v p q hpq := rfl\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.congr_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nn : Int\nz₁ z₂ : CochainComplex.HomComplex.Cochain F G n\nh : Eq z₁ z₂\np q : Int\nhpq : Eq (HAdd.hAdd p n) q\n⊢ Eq (z₁.v p q hpq) (z₂.v p q hpq)","decl":"lemma congr_v {z₁ z₂ : Cochain F G n} (h : z₁ = z₂) (p q : ℤ) (hpq : p + n = q) :\n    z₁.v p q hpq = z₂.v p q hpq := by subst h; rfl\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.ext","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nn : Int\nz₁ z₂ : CochainComplex.HomComplex.Cochain F G n\nh : ∀ (p q : Int) (hpq : Eq (HAdd.hAdd p n) q), Eq (z₁.v p q hpq) (z₂.v p q hpq)\n⊢ Eq z₁ z₂","decl":"@[ext]\nlemma ext (z₁ z₂ : Cochain F G n)\n    (h : ∀ (p q hpq), z₁.v p q hpq = z₂.v p q hpq) : z₁ = z₂ := by\n  funext ⟨p, q, hpq⟩\n  apply h\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.ext_iff","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nn : Int\nz₁ z₂ : CochainComplex.HomComplex.Cochain F G n\n⊢ Iff (Eq z₁ z₂) (∀ (p q : Int) (hpq : Eq (HAdd.hAdd p n) q), Eq (z₁.v p q hpq) (z₂.v p q hpq))","decl":"@[ext]\nlemma ext (z₁ z₂ : Cochain F G n)\n    (h : ∀ (p q hpq), z₁.v p q hpq = z₂.v p q hpq) : z₁ = z₂ := by\n  funext ⟨p, q, hpq⟩\n  apply h\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.ext₀_iff","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nz₁ z₂ : CochainComplex.HomComplex.Cochain F G 0\n⊢ Iff (Eq z₁ z₂) (∀ (p : Int), Eq (z₁.v p p ⋯) (z₂.v p p ⋯))","decl":"@[ext 1100]\nlemma ext₀ (z₁ z₂ : Cochain F G 0)\n    (h : ∀ (p : ℤ), z₁.v p p (add_zero p) = z₂.v p p (add_zero p)) : z₁ = z₂ := by\n  ext p q hpq\n  obtain rfl : q = p := by rw [← hpq, add_zero]\n  exact h q\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.ext₀","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nz₁ z₂ : CochainComplex.HomComplex.Cochain F G 0\nh : ∀ (p : Int), Eq (z₁.v p p ⋯) (z₂.v p p ⋯)\n⊢ Eq z₁ z₂","decl":"@[ext 1100]\nlemma ext₀ (z₁ z₂ : Cochain F G 0)\n    (h : ∀ (p : ℤ), z₁.v p p (add_zero p) = z₂.v p p (add_zero p)) : z₁ = z₂ := by\n  ext p q hpq\n  obtain rfl : q = p := by rw [← hpq, add_zero]\n  exact h q\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.zero_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nn p q : Int\nhpq : Eq (HAdd.hAdd p n) q\n⊢ Eq (CochainComplex.HomComplex.Cochain.v 0 p q hpq) 0","decl":"@[simp]\nlemma zero_v {n : ℤ} (p q : ℤ) (hpq : p + n = q) :\n    (0 : Cochain F G n).v p q hpq = 0 := rfl\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.add_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nn : Int\nz₁ z₂ : CochainComplex.HomComplex.Cochain F G n\np q : Int\nhpq : Eq (HAdd.hAdd p n) q\n⊢ Eq ((HAdd.hAdd z₁ z₂).v p q hpq) (HAdd.hAdd (z₁.v p q hpq) (z₂.v p q hpq))","decl":"@[simp]\nlemma add_v {n : ℤ} (z₁ z₂ : Cochain F G n) (p q : ℤ) (hpq : p + n = q) :\n    (z₁ + z₂).v p q hpq = z₁.v p q hpq + z₂.v p q hpq := rfl\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.sub_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nn : Int\nz₁ z₂ : CochainComplex.HomComplex.Cochain F G n\np q : Int\nhpq : Eq (HAdd.hAdd p n) q\n⊢ Eq ((HSub.hSub z₁ z₂).v p q hpq) (HSub.hSub (z₁.v p q hpq) (z₂.v p q hpq))","decl":"@[simp]\nlemma sub_v {n : ℤ} (z₁ z₂ : Cochain F G n) (p q : ℤ) (hpq : p + n = q) :\n    (z₁ - z₂).v p q hpq = z₁.v p q hpq - z₂.v p q hpq := rfl\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.neg_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nn : Int\nz : CochainComplex.HomComplex.Cochain F G n\np q : Int\nhpq : Eq (HAdd.hAdd p n) q\n⊢ Eq ((Neg.neg z).v p q hpq) (Neg.neg (z.v p q hpq))","decl":"@[simp]\nlemma neg_v {n : ℤ} (z : Cochain F G n) (p q : ℤ) (hpq : p + n = q) :\n    (-z).v p q hpq = - (z.v p q hpq) := rfl\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.smul_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Preadditive C\nR : Type u_1\ninst✝¹ : Ring R\ninst✝ : CategoryTheory.Linear R C\nF G : CochainComplex C Int\nn : Int\nk : R\nz : CochainComplex.HomComplex.Cochain F G n\np q : Int\nhpq : Eq (HAdd.hAdd p n) q\n⊢ Eq ((HSMul.hSMul k z).v p q hpq) (HSMul.hSMul k (z.v p q hpq))","decl":"@[simp]\nlemma smul_v {n : ℤ} (k : R) (z : Cochain F G n) (p q : ℤ) (hpq : p + n = q) :\n    (k • z).v p q hpq = k • (z.v p q hpq) := rfl\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.units_smul_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Preadditive C\nR : Type u_1\ninst✝¹ : Ring R\ninst✝ : CategoryTheory.Linear R C\nF G : CochainComplex C Int\nn : Int\nk : Units R\nz : CochainComplex.HomComplex.Cochain F G n\np q : Int\nhpq : Eq (HAdd.hAdd p n) q\n⊢ Eq ((HSMul.hSMul k z).v p q hpq) (HSMul.hSMul k (z.v p q hpq))","decl":"@[simp]\nlemma units_smul_v {n : ℤ} (k : Rˣ) (z : Cochain F G n) (p q : ℤ) (hpq : p + n = q) :\n    (k • z).v p q hpq = k • (z.v p q hpq) := rfl\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.ofHoms_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nψ : (p : Int) → Quiver.Hom (F.X p) (G.X p)\np : Int\n⊢ Eq ((CochainComplex.HomComplex.Cochain.ofHoms ψ).v p p ⋯) (ψ p)","decl":"@[simp]\nlemma ofHoms_v (ψ : ∀ (p : ℤ), F.X p ⟶ G.X p) (p : ℤ) :\n    (ofHoms ψ).v p p (add_zero p) = ψ p := by\n  simp only [ofHoms, mk_v, eqToHom_refl, comp_id]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.ofHoms_zero","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\n⊢ Eq (CochainComplex.HomComplex.Cochain.ofHoms fun p => 0) 0","decl":"@[simp]\nlemma ofHoms_zero : ofHoms (fun p => (0 : F.X p ⟶ G.X p)) = 0 := by aesop_cat\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.ofHoms_v_comp_d","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nψ : (p : Int) → Quiver.Hom (F.X p) (G.X p)\np q q' : Int\nhpq : Eq (HAdd.hAdd p 0) q\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.HomComplex.Cochain.ofHoms ψ).v p q hpq) (G.d q q')) (CategoryTheory.CategoryStruct.comp (ψ p) (G.d p q'))","decl":"@[simp]\nlemma ofHoms_v_comp_d (ψ : ∀ (p : ℤ), F.X p ⟶ G.X p) (p q q' : ℤ) (hpq : p + 0 = q) :\n    (ofHoms ψ).v p q hpq ≫ G.d q q' = ψ p ≫ G.d p q' := by\n  rw [add_zero] at hpq\n  subst hpq\n  rw [ofHoms_v]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.d_comp_ofHoms_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nψ : (p : Int) → Quiver.Hom (F.X p) (G.X p)\np' p q : Int\nhpq : Eq (HAdd.hAdd p 0) q\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.d p' p) ((CochainComplex.HomComplex.Cochain.ofHoms ψ).v p q hpq)) (CategoryTheory.CategoryStruct.comp (F.d p' q) (ψ q))","decl":"@[simp]\nlemma d_comp_ofHoms_v (ψ : ∀ (p : ℤ), F.X p ⟶ G.X p) (p' p q : ℤ) (hpq : p + 0 = q) :\n    F.d p' p ≫ (ofHoms ψ).v p q hpq = F.d p' q ≫ ψ q := by\n  rw [add_zero] at hpq\n  subst hpq\n  rw [ofHoms_v]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.ofHom_zero","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\n⊢ Eq (CochainComplex.HomComplex.Cochain.ofHom 0) 0","decl":"@[simp]\nlemma ofHom_zero : ofHom (0 : F ⟶ G) = 0 := by\n  simp only [ofHom, HomologicalComplex.zero_f_apply, ofHoms_zero]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.ofHom_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\np : Int\n⊢ Eq ((CochainComplex.HomComplex.Cochain.ofHom φ).v p p ⋯) (φ.f p)","decl":"@[simp]\nlemma ofHom_v (φ : F ⟶ G) (p : ℤ) : (ofHom φ).v p p (add_zero p) = φ.f p := by\n  simp only [ofHom, ofHoms_v]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.ofHom_v_comp_d","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\np q q' : Int\nhpq : Eq (HAdd.hAdd p 0) q\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.HomComplex.Cochain.ofHom φ).v p q hpq) (G.d q q')) (CategoryTheory.CategoryStruct.comp (φ.f p) (G.d p q'))","decl":"@[simp]\nlemma ofHom_v_comp_d (φ : F ⟶ G) (p q q' : ℤ) (hpq : p + 0 = q) :\n    (ofHom φ).v p q hpq ≫ G.d q q' = φ.f p ≫ G.d p q' := by\n  simp only [ofHom, ofHoms_v_comp_d]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.d_comp_ofHom_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\np' p q : Int\nhpq : Eq (HAdd.hAdd p 0) q\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.d p' p) ((CochainComplex.HomComplex.Cochain.ofHom φ).v p q hpq)) (CategoryTheory.CategoryStruct.comp (F.d p' q) (φ.f q))","decl":"@[simp]\nlemma d_comp_ofHom_v (φ : F ⟶ G) (p' p q : ℤ) (hpq : p + 0 = q) :\n    F.d p' p ≫ (ofHom φ).v p q hpq = F.d p' q ≫ φ.f q := by\n  simp only [ofHom, d_comp_ofHoms_v]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.ofHom_add","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ₁ φ₂ : Quiver.Hom F G\n⊢ Eq (CochainComplex.HomComplex.Cochain.ofHom (HAdd.hAdd φ₁ φ₂)) (HAdd.hAdd (CochainComplex.HomComplex.Cochain.ofHom φ₁) (CochainComplex.HomComplex.Cochain.ofHom φ₂))","decl":"@[simp]\nlemma ofHom_add (φ₁ φ₂ : F ⟶ G) :\n    Cochain.ofHom (φ₁ + φ₂) = Cochain.ofHom φ₁ + Cochain.ofHom φ₂ := by aesop_cat\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.ofHom_sub","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ₁ φ₂ : Quiver.Hom F G\n⊢ Eq (CochainComplex.HomComplex.Cochain.ofHom (HSub.hSub φ₁ φ₂)) (HSub.hSub (CochainComplex.HomComplex.Cochain.ofHom φ₁) (CochainComplex.HomComplex.Cochain.ofHom φ₂))","decl":"@[simp]\nlemma ofHom_sub (φ₁ φ₂ : F ⟶ G) :\n    Cochain.ofHom (φ₁ - φ₂) = Cochain.ofHom φ₁ - Cochain.ofHom φ₂ := by aesop_cat\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.ofHom_neg","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\n⊢ Eq (CochainComplex.HomComplex.Cochain.ofHom (Neg.neg φ)) (Neg.neg (CochainComplex.HomComplex.Cochain.ofHom φ))","decl":"@[simp]\nlemma ofHom_neg (φ : F ⟶ G) :\n    Cochain.ofHom (-φ) = -Cochain.ofHom φ := by aesop_cat\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.ofHomotopy_ofEq","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ₁ φ₂ : Quiver.Hom F G\nh : Eq φ₁ φ₂\n⊢ Eq (CochainComplex.HomComplex.Cochain.ofHomotopy (Homotopy.ofEq h)) 0","decl":"@[simp]\nlemma ofHomotopy_ofEq {φ₁ φ₂ : F ⟶ G} (h : φ₁ = φ₂) :\n    ofHomotopy (Homotopy.ofEq h) = 0 := rfl\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.ofHomotopy_refl","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\n⊢ Eq (CochainComplex.HomComplex.Cochain.ofHomotopy (Homotopy.refl φ)) 0","decl":"@[simp]\nlemma ofHomotopy_refl (φ : F ⟶ G) :\n    ofHomotopy (Homotopy.refl φ) = 0 := rfl\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.v_comp_XIsoOfEq_hom","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nn : Int\nγ : CochainComplex.HomComplex.Cochain F G n\np q q' : Int\nhpq : Eq (HAdd.hAdd p n) q\nhq' : Eq q q'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (γ.v p q hpq) (HomologicalComplex.XIsoOfEq G hq').hom) (γ.v p q' ⋯)","decl":"@[reassoc]\nlemma v_comp_XIsoOfEq_hom\n    (γ : Cochain F G n) (p q q' : ℤ) (hpq : p + n = q) (hq' : q = q') :\n    γ.v p q hpq ≫ (HomologicalComplex.XIsoOfEq G hq').hom = γ.v p q' (by rw [← hq', hpq]) := by\n  subst hq'\n  simp only [HomologicalComplex.XIsoOfEq, eqToIso_refl, Iso.refl_hom, comp_id]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.v_comp_XIsoOfEq_hom_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nn : Int\nγ : CochainComplex.HomComplex.Cochain F G n\np q q' : Int\nhpq : Eq (HAdd.hAdd p n) q\nhq' : Eq q q'\nZ : C\nh : Quiver.Hom (G.X q') Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (γ.v p q hpq) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.XIsoOfEq G hq').hom h)) (CategoryTheory.CategoryStruct.comp (γ.v p q' ⋯) h)","decl":"@[reassoc]\nlemma v_comp_XIsoOfEq_hom\n    (γ : Cochain F G n) (p q q' : ℤ) (hpq : p + n = q) (hq' : q = q') :\n    γ.v p q hpq ≫ (HomologicalComplex.XIsoOfEq G hq').hom = γ.v p q' (by rw [← hq', hpq]) := by\n  subst hq'\n  simp only [HomologicalComplex.XIsoOfEq, eqToIso_refl, Iso.refl_hom, comp_id]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.v_comp_XIsoOfEq_inv","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nn : Int\nγ : CochainComplex.HomComplex.Cochain F G n\np q q' : Int\nhpq : Eq (HAdd.hAdd p n) q\nhq' : Eq q' q\n⊢ Eq (CategoryTheory.CategoryStruct.comp (γ.v p q hpq) (HomologicalComplex.XIsoOfEq G hq').inv) (γ.v p q' ⋯)","decl":"@[reassoc]\nlemma v_comp_XIsoOfEq_inv\n    (γ : Cochain F G n) (p q q' : ℤ) (hpq : p + n = q) (hq' : q' = q) :\n    γ.v p q hpq ≫ (HomologicalComplex.XIsoOfEq G hq').inv = γ.v p q' (by rw [hq', hpq]) := by\n  subst hq'\n  simp only [HomologicalComplex.XIsoOfEq, eqToIso_refl, Iso.refl_inv, comp_id]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.v_comp_XIsoOfEq_inv_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nn : Int\nγ : CochainComplex.HomComplex.Cochain F G n\np q q' : Int\nhpq : Eq (HAdd.hAdd p n) q\nhq' : Eq q' q\nZ : C\nh : Quiver.Hom (G.X q') Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (γ.v p q hpq) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.XIsoOfEq G hq').inv h)) (CategoryTheory.CategoryStruct.comp (γ.v p q' ⋯) h)","decl":"@[reassoc]\nlemma v_comp_XIsoOfEq_inv\n    (γ : Cochain F G n) (p q q' : ℤ) (hpq : p + n = q) (hq' : q' = q) :\n    γ.v p q hpq ≫ (HomologicalComplex.XIsoOfEq G hq').inv = γ.v p q' (by rw [hq', hpq]) := by\n  subst hq'\n  simp only [HomologicalComplex.XIsoOfEq, eqToIso_refl, Iso.refl_inv, comp_id]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.comp_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G K : CochainComplex C Int\nn₁ n₂ n₁₂ : Int\nz₁ : CochainComplex.HomComplex.Cochain F G n₁\nz₂ : CochainComplex.HomComplex.Cochain G K n₂\nh : Eq (HAdd.hAdd n₁ n₂) n₁₂\np₁ p₂ p₃ : Int\nh₁ : Eq (HAdd.hAdd p₁ n₁) p₂\nh₂ : Eq (HAdd.hAdd p₂ n₂) p₃\n⊢ Eq ((z₁.comp z₂ h).v p₁ p₃ ⋯) (CategoryTheory.CategoryStruct.comp (z₁.v p₁ p₂ h₁) (z₂.v p₂ p₃ h₂))","decl":"lemma comp_v {n₁ n₂ n₁₂ : ℤ} (z₁ : Cochain F G n₁) (z₂ : Cochain G K n₂) (h : n₁ + n₂ = n₁₂)\n    (p₁ p₂ p₃ : ℤ) (h₁ : p₁ + n₁ = p₂) (h₂ : p₂ + n₂ = p₃) :\n    (z₁.comp z₂ h).v p₁ p₃ (by rw [← h₂, ← h₁, ← h, add_assoc]) =\n      z₁.v p₁ p₂ h₁ ≫ z₂.v p₂ p₃ h₂ := by\n  subst h₁; rfl\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.comp_zero_cochain_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G K : CochainComplex C Int\nn : Int\nz₁ : CochainComplex.HomComplex.Cochain F G n\nz₂ : CochainComplex.HomComplex.Cochain G K 0\np q : Int\nhpq : Eq (HAdd.hAdd p n) q\n⊢ Eq ((z₁.comp z₂ ⋯).v p q hpq) (CategoryTheory.CategoryStruct.comp (z₁.v p q hpq) (z₂.v q q ⋯))","decl":"@[simp]\nlemma comp_zero_cochain_v (z₁ : Cochain F G n) (z₂ : Cochain G K 0) (p q : ℤ) (hpq : p + n = q) :\n    (z₁.comp z₂ (add_zero n)).v p q hpq = z₁.v p q hpq ≫ z₂.v q q (add_zero q) :=\n  comp_v z₁ z₂ (add_zero n) p q q hpq (add_zero q)\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.zero_cochain_comp_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G K : CochainComplex C Int\nn : Int\nz₁ : CochainComplex.HomComplex.Cochain F G 0\nz₂ : CochainComplex.HomComplex.Cochain G K n\np q : Int\nhpq : Eq (HAdd.hAdd p n) q\n⊢ Eq ((z₁.comp z₂ ⋯).v p q hpq) (CategoryTheory.CategoryStruct.comp (z₁.v p p ⋯) (z₂.v p q hpq))","decl":"@[simp]\nlemma zero_cochain_comp_v (z₁ : Cochain F G 0) (z₂ : Cochain G K n) (p q : ℤ) (hpq : p + n = q) :\n    (z₁.comp z₂ (zero_add n)).v p q hpq = z₁.v p p (add_zero p) ≫ z₂.v p q hpq :=\n  comp_v z₁ z₂ (zero_add n) p p q (add_zero p) hpq\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.comp_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G K L : CochainComplex C Int\nn₁ n₂ n₃ n₁₂ n₂₃ n₁₂₃ : Int\nz₁ : CochainComplex.HomComplex.Cochain F G n₁\nz₂ : CochainComplex.HomComplex.Cochain G K n₂\nz₃ : CochainComplex.HomComplex.Cochain K L n₃\nh₁₂ : Eq (HAdd.hAdd n₁ n₂) n₁₂\nh₂₃ : Eq (HAdd.hAdd n₂ n₃) n₂₃\nh₁₂₃ : Eq (HAdd.hAdd (HAdd.hAdd n₁ n₂) n₃) n₁₂₃\n⊢ Eq ((z₁.comp z₂ h₁₂).comp z₃ ⋯) (z₁.comp (z₂.comp z₃ h₂₃) ⋯)","decl":"/-- The associativity of the composition of cochains. -/\nlemma comp_assoc {n₁ n₂ n₃ n₁₂ n₂₃ n₁₂₃ : ℤ}\n    (z₁ : Cochain F G n₁) (z₂ : Cochain G K n₂) (z₃ : Cochain K L n₃)\n    (h₁₂ : n₁ + n₂ = n₁₂) (h₂₃ : n₂ + n₃ = n₂₃) (h₁₂₃ : n₁ + n₂ + n₃ = n₁₂₃) :\n    (z₁.comp z₂ h₁₂).comp z₃ (show n₁₂ + n₃ = n₁₂₃ by rw [← h₁₂, h₁₂₃]) =\n      z₁.comp (z₂.comp z₃ h₂₃) (by rw [← h₂₃, ← h₁₂₃, add_assoc]) := by\n  substs h₁₂ h₂₃ h₁₂₃\n  ext p q hpq\n  rw [comp_v _ _ rfl p (p + n₁ + n₂) q (add_assoc _ _ _).symm (by omega),\n    comp_v z₁ z₂ rfl p (p + n₁) (p + n₁ + n₂) (by omega) (by omega),\n    comp_v z₁ (z₂.comp z₃ rfl) (add_assoc n₁ n₂ n₃).symm p (p + n₁) q (by omega) (by omega),\n    comp_v z₂ z₃ rfl (p + n₁) (p + n₁ + n₂) q (by omega) (by omega), assoc]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.comp_assoc_of_first_is_zero_cochain","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G K L : CochainComplex C Int\nn₂ n₃ n₂₃ : Int\nz₁ : CochainComplex.HomComplex.Cochain F G 0\nz₂ : CochainComplex.HomComplex.Cochain G K n₂\nz₃ : CochainComplex.HomComplex.Cochain K L n₃\nh₂₃ : Eq (HAdd.hAdd n₂ n₃) n₂₃\n⊢ Eq ((z₁.comp z₂ ⋯).comp z₃ h₂₃) (z₁.comp (z₂.comp z₃ h₂₃) ⋯)","decl":"@[simp]\nlemma comp_assoc_of_first_is_zero_cochain {n₂ n₃ n₂₃ : ℤ}\n    (z₁ : Cochain F G 0) (z₂ : Cochain G K n₂) (z₃ : Cochain K L n₃)\n    (h₂₃ : n₂ + n₃ = n₂₃) :\n    (z₁.comp z₂ (zero_add n₂)).comp z₃ h₂₃ = z₁.comp (z₂.comp z₃ h₂₃) (zero_add n₂₃) :=\n  comp_assoc _ _ _ _ _ (by omega)\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.comp_assoc_of_second_is_zero_cochain","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G K L : CochainComplex C Int\nn₁ n₃ n₁₃ : Int\nz₁ : CochainComplex.HomComplex.Cochain F G n₁\nz₂ : CochainComplex.HomComplex.Cochain G K 0\nz₃ : CochainComplex.HomComplex.Cochain K L n₃\nh₁₃ : Eq (HAdd.hAdd n₁ n₃) n₁₃\n⊢ Eq ((z₁.comp z₂ ⋯).comp z₃ h₁₃) (z₁.comp (z₂.comp z₃ ⋯) h₁₃)","decl":"@[simp]\nlemma comp_assoc_of_second_is_zero_cochain {n₁ n₃ n₁₃ : ℤ}\n    (z₁ : Cochain F G n₁) (z₂ : Cochain G K 0) (z₃ : Cochain K L n₃) (h₁₃ : n₁ + n₃ = n₁₃) :\n    (z₁.comp z₂ (add_zero n₁)).comp z₃ h₁₃ = z₁.comp (z₂.comp z₃ (zero_add n₃)) h₁₃ :=\n  comp_assoc _ _ _ _ _ (by omega)\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.comp_assoc_of_third_is_zero_cochain","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G K L : CochainComplex C Int\nn₁ n₂ n₁₂ : Int\nz₁ : CochainComplex.HomComplex.Cochain F G n₁\nz₂ : CochainComplex.HomComplex.Cochain G K n₂\nz₃ : CochainComplex.HomComplex.Cochain K L 0\nh₁₂ : Eq (HAdd.hAdd n₁ n₂) n₁₂\n⊢ Eq ((z₁.comp z₂ h₁₂).comp z₃ ⋯) (z₁.comp (z₂.comp z₃ ⋯) h₁₂)","decl":"@[simp]\nlemma comp_assoc_of_third_is_zero_cochain {n₁ n₂ n₁₂ : ℤ}\n    (z₁ : Cochain F G n₁) (z₂ : Cochain G K n₂) (z₃ : Cochain K L 0) (h₁₂ : n₁ + n₂ = n₁₂) :\n    (z₁.comp z₂ h₁₂).comp z₃ (add_zero n₁₂) = z₁.comp (z₂.comp z₃ (add_zero n₂)) h₁₂ :=\n  comp_assoc _ _ _ _ _ (by omega)\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.comp_assoc_of_second_degree_eq_neg_third_degree","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G K L : CochainComplex C Int\nn₁ n₂ n₁₂ : Int\nz₁ : CochainComplex.HomComplex.Cochain F G n₁\nz₂ : CochainComplex.HomComplex.Cochain G K (Neg.neg n₂)\nz₃ : CochainComplex.HomComplex.Cochain K L n₂\nh₁₂ : Eq (HAdd.hAdd n₁ (Neg.neg n₂)) n₁₂\n⊢ Eq ((z₁.comp z₂ h₁₂).comp z₃ ⋯) (z₁.comp (z₂.comp z₃ ⋯) ⋯)","decl":"@[simp]\nlemma comp_assoc_of_second_degree_eq_neg_third_degree {n₁ n₂ n₁₂ : ℤ}\n    (z₁ : Cochain F G n₁) (z₂ : Cochain G K (-n₂)) (z₃ : Cochain K L n₂) (h₁₂ : n₁ + (-n₂) = n₁₂) :\n    (z₁.comp z₂ h₁₂).comp z₃\n      (show n₁₂ + n₂ = n₁ by rw [← h₁₂, add_assoc, neg_add_cancel, add_zero]) =\n      z₁.comp (z₂.comp z₃ (neg_add_cancel n₂)) (add_zero n₁) :=\n  comp_assoc _ _ _ _ _ (by omega)\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.zero_comp","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G K : CochainComplex C Int\nn₁ n₂ n₁₂ : Int\nz₂ : CochainComplex.HomComplex.Cochain G K n₂\nh : Eq (HAdd.hAdd n₁ n₂) n₁₂\n⊢ Eq (CochainComplex.HomComplex.Cochain.comp 0 z₂ h) 0","decl":"@[simp]\nprotected lemma zero_comp {n₁ n₂ n₁₂ : ℤ} (z₂ : Cochain G K n₂)\n    (h : n₁ + n₂ = n₁₂) : (0 : Cochain F G n₁).comp z₂ h = 0 := by\n  ext p q hpq\n  simp only [comp_v _ _ h p _ q rfl (by omega), zero_v, zero_comp]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.add_comp","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G K : CochainComplex C Int\nn₁ n₂ n₁₂ : Int\nz₁ z₁' : CochainComplex.HomComplex.Cochain F G n₁\nz₂ : CochainComplex.HomComplex.Cochain G K n₂\nh : Eq (HAdd.hAdd n₁ n₂) n₁₂\n⊢ Eq ((HAdd.hAdd z₁ z₁').comp z₂ h) (HAdd.hAdd (z₁.comp z₂ h) (z₁'.comp z₂ h))","decl":"@[simp]\nprotected lemma add_comp {n₁ n₂ n₁₂ : ℤ} (z₁ z₁' : Cochain F G n₁) (z₂ : Cochain G K n₂)\n    (h : n₁ + n₂ = n₁₂) : (z₁ + z₁').comp z₂ h = z₁.comp z₂ h + z₁'.comp z₂ h := by\n  ext p q hpq\n  simp only [comp_v _ _ h p _ q rfl (by omega), add_v, add_comp]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.sub_comp","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G K : CochainComplex C Int\nn₁ n₂ n₁₂ : Int\nz₁ z₁' : CochainComplex.HomComplex.Cochain F G n₁\nz₂ : CochainComplex.HomComplex.Cochain G K n₂\nh : Eq (HAdd.hAdd n₁ n₂) n₁₂\n⊢ Eq ((HSub.hSub z₁ z₁').comp z₂ h) (HSub.hSub (z₁.comp z₂ h) (z₁'.comp z₂ h))","decl":"@[simp]\nprotected lemma sub_comp {n₁ n₂ n₁₂ : ℤ} (z₁ z₁' : Cochain F G n₁) (z₂ : Cochain G K n₂)\n    (h : n₁ + n₂ = n₁₂) : (z₁ - z₁').comp z₂ h = z₁.comp z₂ h - z₁'.comp z₂ h := by\n  ext p q hpq\n  simp only [comp_v _ _ h p _ q rfl (by omega), sub_v, sub_comp]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.neg_comp","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G K : CochainComplex C Int\nn₁ n₂ n₁₂ : Int\nz₁ : CochainComplex.HomComplex.Cochain F G n₁\nz₂ : CochainComplex.HomComplex.Cochain G K n₂\nh : Eq (HAdd.hAdd n₁ n₂) n₁₂\n⊢ Eq ((Neg.neg z₁).comp z₂ h) (Neg.neg (z₁.comp z₂ h))","decl":"@[simp]\nprotected lemma neg_comp {n₁ n₂ n₁₂ : ℤ} (z₁ : Cochain F G n₁) (z₂ : Cochain G K n₂)\n    (h : n₁ + n₂ = n₁₂) : (-z₁).comp z₂ h = -z₁.comp z₂ h := by\n  ext p q hpq\n  simp only [comp_v _ _ h p _ q rfl (by omega), neg_v, neg_comp]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.smul_comp","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Preadditive C\nR : Type u_1\ninst✝¹ : Ring R\ninst✝ : CategoryTheory.Linear R C\nF G K : CochainComplex C Int\nn₁ n₂ n₁₂ : Int\nk : R\nz₁ : CochainComplex.HomComplex.Cochain F G n₁\nz₂ : CochainComplex.HomComplex.Cochain G K n₂\nh : Eq (HAdd.hAdd n₁ n₂) n₁₂\n⊢ Eq ((HSMul.hSMul k z₁).comp z₂ h) (HSMul.hSMul k (z₁.comp z₂ h))","decl":"@[simp]\nprotected lemma smul_comp {n₁ n₂ n₁₂ : ℤ} (k : R) (z₁ : Cochain F G n₁) (z₂ : Cochain G K n₂)\n    (h : n₁ + n₂ = n₁₂) : (k • z₁).comp z₂ h = k • (z₁.comp z₂ h) := by\n  ext p q hpq\n  simp only [comp_v _ _ h p _ q rfl (by omega), smul_v, Linear.smul_comp]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.units_smul_comp","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Preadditive C\nR : Type u_1\ninst✝¹ : Ring R\ninst✝ : CategoryTheory.Linear R C\nF G K : CochainComplex C Int\nn₁ n₂ n₁₂ : Int\nk : Units R\nz₁ : CochainComplex.HomComplex.Cochain F G n₁\nz₂ : CochainComplex.HomComplex.Cochain G K n₂\nh : Eq (HAdd.hAdd n₁ n₂) n₁₂\n⊢ Eq ((HSMul.hSMul k z₁).comp z₂ h) (HSMul.hSMul k (z₁.comp z₂ h))","decl":"@[simp]\nlemma units_smul_comp {n₁ n₂ n₁₂ : ℤ} (k : Rˣ) (z₁ : Cochain F G n₁) (z₂ : Cochain G K n₂)\n    (h : n₁ + n₂ = n₁₂) : (k • z₁).comp z₂ h = k • (z₁.comp z₂ h) := by\n  apply Cochain.smul_comp\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.id_comp","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nn : Int\nz₂ : CochainComplex.HomComplex.Cochain F G n\n⊢ Eq ((CochainComplex.HomComplex.Cochain.ofHom (CategoryTheory.CategoryStruct.id F)).comp z₂ ⋯) z₂","decl":"@[simp]\nprotected lemma id_comp {n : ℤ} (z₂ : Cochain F G n) :\n    (Cochain.ofHom (𝟙 F)).comp z₂ (zero_add n) = z₂ := by\n  ext p q hpq\n  simp only [zero_cochain_comp_v, ofHom_v, HomologicalComplex.id_f, id_comp]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.comp_zero","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G K : CochainComplex C Int\nn₁ n₂ n₁₂ : Int\nz₁ : CochainComplex.HomComplex.Cochain F G n₁\nh : Eq (HAdd.hAdd n₁ n₂) n₁₂\n⊢ Eq (z₁.comp 0 h) 0","decl":"@[simp]\nprotected lemma comp_zero {n₁ n₂ n₁₂ : ℤ} (z₁ : Cochain F G n₁)\n    (h : n₁ + n₂ = n₁₂) : z₁.comp (0 : Cochain G K n₂) h = 0 := by\n  ext p q hpq\n  simp only [comp_v _ _ h p _ q rfl (by omega), zero_v, comp_zero]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.comp_add","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G K : CochainComplex C Int\nn₁ n₂ n₁₂ : Int\nz₁ : CochainComplex.HomComplex.Cochain F G n₁\nz₂ z₂' : CochainComplex.HomComplex.Cochain G K n₂\nh : Eq (HAdd.hAdd n₁ n₂) n₁₂\n⊢ Eq (z₁.comp (HAdd.hAdd z₂ z₂') h) (HAdd.hAdd (z₁.comp z₂ h) (z₁.comp z₂' h))","decl":"@[simp]\nprotected lemma comp_add {n₁ n₂ n₁₂ : ℤ} (z₁ : Cochain F G n₁) (z₂ z₂' : Cochain G K n₂)\n    (h : n₁ + n₂ = n₁₂) : z₁.comp (z₂ + z₂') h = z₁.comp z₂ h + z₁.comp z₂' h := by\n  ext p q hpq\n  simp only [comp_v _ _ h p _ q rfl (by omega), add_v, comp_add]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.comp_sub","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G K : CochainComplex C Int\nn₁ n₂ n₁₂ : Int\nz₁ : CochainComplex.HomComplex.Cochain F G n₁\nz₂ z₂' : CochainComplex.HomComplex.Cochain G K n₂\nh : Eq (HAdd.hAdd n₁ n₂) n₁₂\n⊢ Eq (z₁.comp (HSub.hSub z₂ z₂') h) (HSub.hSub (z₁.comp z₂ h) (z₁.comp z₂' h))","decl":"@[simp]\nprotected lemma comp_sub {n₁ n₂ n₁₂ : ℤ} (z₁ : Cochain F G n₁) (z₂ z₂' : Cochain G K n₂)\n    (h : n₁ + n₂ = n₁₂) : z₁.comp (z₂ - z₂') h = z₁.comp z₂ h - z₁.comp z₂' h := by\n  ext p q hpq\n  simp only [comp_v _ _ h p _ q rfl (by omega), sub_v, comp_sub]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.comp_neg","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G K : CochainComplex C Int\nn₁ n₂ n₁₂ : Int\nz₁ : CochainComplex.HomComplex.Cochain F G n₁\nz₂ : CochainComplex.HomComplex.Cochain G K n₂\nh : Eq (HAdd.hAdd n₁ n₂) n₁₂\n⊢ Eq (z₁.comp (Neg.neg z₂) h) (Neg.neg (z₁.comp z₂ h))","decl":"@[simp]\nprotected lemma comp_neg {n₁ n₂ n₁₂ : ℤ} (z₁ : Cochain F G n₁) (z₂ : Cochain G K n₂)\n    (h : n₁ + n₂ = n₁₂) : z₁.comp (-z₂) h = -z₁.comp z₂ h := by\n  ext p q hpq\n  simp only [comp_v _ _ h p _ q rfl (by omega), neg_v, comp_neg]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.comp_smul","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Preadditive C\nR : Type u_1\ninst✝¹ : Ring R\ninst✝ : CategoryTheory.Linear R C\nF G K : CochainComplex C Int\nn₁ n₂ n₁₂ : Int\nz₁ : CochainComplex.HomComplex.Cochain F G n₁\nk : R\nz₂ : CochainComplex.HomComplex.Cochain G K n₂\nh : Eq (HAdd.hAdd n₁ n₂) n₁₂\n⊢ Eq (z₁.comp (HSMul.hSMul k z₂) h) (HSMul.hSMul k (z₁.comp z₂ h))","decl":"@[simp]\nprotected lemma comp_smul {n₁ n₂ n₁₂ : ℤ} (z₁ : Cochain F G n₁) (k : R) (z₂ : Cochain G K n₂)\n    (h : n₁ + n₂ = n₁₂ ) : z₁.comp (k • z₂) h = k • (z₁.comp z₂ h) := by\n  ext p q hpq\n  simp only [comp_v _ _ h p _ q rfl (by omega), smul_v, Linear.comp_smul]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.comp_units_smul","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Preadditive C\nR : Type u_1\ninst✝¹ : Ring R\ninst✝ : CategoryTheory.Linear R C\nF G K : CochainComplex C Int\nn₁ n₂ n₁₂ : Int\nz₁ : CochainComplex.HomComplex.Cochain F G n₁\nk : Units R\nz₂ : CochainComplex.HomComplex.Cochain G K n₂\nh : Eq (HAdd.hAdd n₁ n₂) n₁₂\n⊢ Eq (z₁.comp (HSMul.hSMul k z₂) h) (HSMul.hSMul k (z₁.comp z₂ h))","decl":"@[simp]\nlemma comp_units_smul {n₁ n₂ n₁₂ : ℤ} (z₁ : Cochain F G n₁) (k : Rˣ) (z₂ : Cochain G K n₂)\n    (h : n₁ + n₂ = n₁₂ ) : z₁.comp (k • z₂) h = k • (z₁.comp z₂ h) := by\n  apply Cochain.comp_smul\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.comp_id","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nn : Int\nz₁ : CochainComplex.HomComplex.Cochain F G n\n⊢ Eq (z₁.comp (CochainComplex.HomComplex.Cochain.ofHom (CategoryTheory.CategoryStruct.id G)) ⋯) z₁","decl":"@[simp]\nprotected lemma comp_id {n : ℤ} (z₁ : Cochain F G n) :\n    z₁.comp (Cochain.ofHom (𝟙 G)) (add_zero n) = z₁ := by\n  ext p q hpq\n  simp only [comp_zero_cochain_v, ofHom_v, HomologicalComplex.id_f, comp_id]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.ofHoms_comp","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G K : CochainComplex C Int\nφ : (p : Int) → Quiver.Hom (F.X p) (G.X p)\nψ : (p : Int) → Quiver.Hom (G.X p) (K.X p)\n⊢ Eq ((CochainComplex.HomComplex.Cochain.ofHoms φ).comp (CochainComplex.HomComplex.Cochain.ofHoms ψ) ⋯) (CochainComplex.HomComplex.Cochain.ofHoms fun p => CategoryTheory.CategoryStruct.comp (φ p) (ψ p))","decl":"@[simp]\nlemma ofHoms_comp (φ : ∀ (p : ℤ), F.X p ⟶ G.X p) (ψ : ∀ (p : ℤ), G.X p ⟶ K.X p) :\n    (ofHoms φ).comp (ofHoms ψ) (zero_add 0) = ofHoms (fun p => φ p ≫ ψ p) := by aesop_cat\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.ofHom_comp","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G K : CochainComplex C Int\nf : Quiver.Hom F G\ng : Quiver.Hom G K\n⊢ Eq (CochainComplex.HomComplex.Cochain.ofHom (CategoryTheory.CategoryStruct.comp f g)) ((CochainComplex.HomComplex.Cochain.ofHom f).comp (CochainComplex.HomComplex.Cochain.ofHom g) ⋯)","decl":"@[simp]\nlemma ofHom_comp (f : F ⟶ G) (g : G ⟶ K) :\n    ofHom (f ≫ g) = (ofHom f).comp (ofHom g) (zero_add 0) := by\n  simp only [ofHom, HomologicalComplex.comp_f, ofHoms_comp]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.diff_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nK : CochainComplex C Int\np q : Int\nhpq : Eq (HAdd.hAdd p 1) q\n⊢ Eq ((CochainComplex.HomComplex.Cochain.diff K).v p q hpq) (K.d p q)","decl":"@[simp]\nlemma diff_v (p q : ℤ) (hpq : p + 1 = q) : (diff K).v p q hpq = K.d p q := rfl\n\n"}
{"name":"CochainComplex.HomComplex.δ_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nn m : Int\nhnm : Eq (HAdd.hAdd n 1) m\nz : CochainComplex.HomComplex.Cochain F G n\np q : Int\nhpq : Eq (HAdd.hAdd p m) q\nq₁ q₂ : Int\nhq₁ : Eq q₁ (HSub.hSub q 1)\nhq₂ : Eq (HAdd.hAdd p 1) q₂\n⊢ Eq ((CochainComplex.HomComplex.δ n m z).v p q hpq) (HAdd.hAdd (CategoryTheory.CategoryStruct.comp (z.v p q₁ ⋯) (G.d q₁ q)) (HSMul.hSMul m.negOnePow (CategoryTheory.CategoryStruct.comp (F.d p q₂) (z.v q₂ q ⋯))))","decl":"lemma δ_v (hnm : n + 1 = m) (z : Cochain F G n) (p q : ℤ) (hpq : p + m = q) (q₁ q₂ : ℤ)\n    (hq₁ : q₁ = q - 1) (hq₂ : p + 1 = q₂) : (δ n m z).v p q hpq =\n    z.v p q₁ (by rw [hq₁, ← hpq, ← hnm, ← add_assoc, add_sub_cancel_right]) ≫ G.d q₁ q\n      + m.negOnePow • F.d p q₂ ≫ z.v q₂ q\n          (by rw [← hq₂, add_assoc, add_comm 1, hnm, hpq]) := by\n  obtain rfl : q₁ = p + n := by omega\n  obtain rfl : q₂ = p + m - n := by omega\n  rfl\n\n"}
{"name":"CochainComplex.HomComplex.δ_shape","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nn m : Int\nhnm : Not (Eq (HAdd.hAdd n 1) m)\nz : CochainComplex.HomComplex.Cochain F G n\n⊢ Eq (CochainComplex.HomComplex.δ n m z) 0","decl":"lemma δ_shape (hnm : ¬ n + 1 = m) (z : Cochain F G n) : δ n m z = 0 := by\n  ext p q hpq\n  dsimp only [δ]\n  rw [Cochain.mk_v, Cochain.zero_v, F.shape, G.shape, comp_zero, zero_add, zero_comp, smul_zero]\n  all_goals\n    simp only [ComplexShape.up_Rel]\n    exact fun _ => hnm (by omega)\n\n"}
{"name":"CochainComplex.HomComplex.δ_hom_apply","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Preadditive C\nR : Type u_1\ninst✝¹ : Ring R\ninst✝ : CategoryTheory.Linear R C\nF G : CochainComplex C Int\nn m : Int\nz : CochainComplex.HomComplex.Cochain F G n\n⊢ Eq ((CochainComplex.HomComplex.δ_hom R F G n m) z) (CochainComplex.HomComplex.δ n m z)","decl":"/-- The differential on the complex of morphisms between cochain complexes, as a linear map. -/\n@[simps!]\ndef δ_hom : Cochain F G n →ₗ[R] Cochain F G m where\n  toFun := δ n m\n  map_add' α β := by\n    by_cases h : n + 1 = m\n    · ext p q hpq\n      dsimp\n      simp only [δ_v n m h _ p q hpq _ _ rfl rfl, Cochain.add_v, add_comp, comp_add, smul_add]\n      abel\n    · simp only [δ_shape _ _ h, add_zero]\n  map_smul' r a := by\n    by_cases h : n + 1 = m\n    · ext p q hpq\n      dsimp\n      simp only [δ_v n m h _ p q hpq _ _ rfl rfl, Cochain.smul_v, Linear.comp_smul,\n        Linear.smul_comp, smul_add, add_right_inj, smul_comm m.negOnePow r]\n    · simp only [δ_shape _ _ h, smul_zero]\n\n"}
{"name":"CochainComplex.HomComplex.δ_add","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nn m : Int\nz₁ z₂ : CochainComplex.HomComplex.Cochain F G n\n⊢ Eq (CochainComplex.HomComplex.δ n m (HAdd.hAdd z₁ z₂)) (HAdd.hAdd (CochainComplex.HomComplex.δ n m z₁) (CochainComplex.HomComplex.δ n m z₂))","decl":"@[simp] lemma δ_add (z₁ z₂ : Cochain F G n) : δ n m (z₁ + z₂) = δ n m z₁ + δ n m z₂ :=\n  (δ_hom ℤ F G n m).map_add z₁ z₂\n\n"}
{"name":"CochainComplex.HomComplex.δ_sub","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nn m : Int\nz₁ z₂ : CochainComplex.HomComplex.Cochain F G n\n⊢ Eq (CochainComplex.HomComplex.δ n m (HSub.hSub z₁ z₂)) (HSub.hSub (CochainComplex.HomComplex.δ n m z₁) (CochainComplex.HomComplex.δ n m z₂))","decl":"@[simp] lemma δ_sub (z₁ z₂ : Cochain F G n) : δ n m (z₁ - z₂) = δ n m z₁ - δ n m z₂ :=\n  (δ_hom ℤ F G n m).map_sub z₁ z₂\n\n"}
{"name":"CochainComplex.HomComplex.δ_zero","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nn m : Int\n⊢ Eq (CochainComplex.HomComplex.δ n m 0) 0","decl":"@[simp] lemma δ_zero : δ n m (0 : Cochain F G n) = 0 := (δ_hom ℤ F G n m).map_zero\n\n"}
{"name":"CochainComplex.HomComplex.δ_neg","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nn m : Int\nz : CochainComplex.HomComplex.Cochain F G n\n⊢ Eq (CochainComplex.HomComplex.δ n m (Neg.neg z)) (Neg.neg (CochainComplex.HomComplex.δ n m z))","decl":"@[simp] lemma δ_neg (z : Cochain F G n) : δ n m (-z) = - δ n m z :=\n  (δ_hom ℤ F G n m).map_neg z\n\n"}
{"name":"CochainComplex.HomComplex.δ_smul","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Preadditive C\nR : Type u_1\ninst✝¹ : Ring R\ninst✝ : CategoryTheory.Linear R C\nF G : CochainComplex C Int\nn m : Int\nk : R\nz : CochainComplex.HomComplex.Cochain F G n\n⊢ Eq (CochainComplex.HomComplex.δ n m (HSMul.hSMul k z)) (HSMul.hSMul k (CochainComplex.HomComplex.δ n m z))","decl":"@[simp] lemma δ_smul (k : R) (z : Cochain F G n) : δ n m (k • z) = k • δ n m z :=\n  (δ_hom R F G n m).map_smul k z\n\n"}
{"name":"CochainComplex.HomComplex.δ_units_smul","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Preadditive C\nR : Type u_1\ninst✝¹ : Ring R\ninst✝ : CategoryTheory.Linear R C\nF G : CochainComplex C Int\nn m : Int\nk : Units R\nz : CochainComplex.HomComplex.Cochain F G n\n⊢ Eq (CochainComplex.HomComplex.δ n m (HSMul.hSMul k z)) (HSMul.hSMul k (CochainComplex.HomComplex.δ n m z))","decl":"@[simp] lemma δ_units_smul (k : Rˣ) (z : Cochain F G n) : δ n m (k • z) = k • δ n m z :=\n  δ_smul ..\n\n"}
{"name":"CochainComplex.HomComplex.δ_δ","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nn₀ n₁ n₂ : Int\nz : CochainComplex.HomComplex.Cochain F G n₀\n⊢ Eq (CochainComplex.HomComplex.δ n₁ n₂ (CochainComplex.HomComplex.δ n₀ n₁ z)) 0","decl":"lemma δ_δ (n₀ n₁ n₂ : ℤ) (z : Cochain F G n₀) : δ n₁ n₂ (δ n₀ n₁ z) = 0 := by\n  by_cases h₁₂ : n₁ + 1 = n₂; swap\n  · rw [δ_shape _ _ h₁₂]\n  by_cases h₀₁ : n₀ + 1 = n₁; swap\n  · rw [δ_shape _ _ h₀₁, δ_zero]\n  ext p q hpq\n  dsimp\n  simp only [δ_v n₁ n₂ h₁₂ _ p q hpq _ _ rfl rfl,\n    δ_v n₀ n₁ h₀₁ z p (q-1) (by omega) (q-2) _ (by omega) rfl,\n    δ_v n₀ n₁ h₀₁ z (p+1) q (by omega) _ (p+2) rfl (by omega),\n    ← h₁₂, Int.negOnePow_succ, add_comp, assoc,\n    HomologicalComplex.d_comp_d, comp_zero, zero_add, comp_add,\n    HomologicalComplex.d_comp_d_assoc, zero_comp, smul_zero,\n    add_zero, add_neg_cancel, Units.neg_smul,\n    Linear.units_smul_comp, Linear.comp_units_smul]\n\n"}
{"name":"CochainComplex.HomComplex.δ_comp","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G K : CochainComplex C Int\nn₁ n₂ n₁₂ : Int\nz₁ : CochainComplex.HomComplex.Cochain F G n₁\nz₂ : CochainComplex.HomComplex.Cochain G K n₂\nh : Eq (HAdd.hAdd n₁ n₂) n₁₂\nm₁ m₂ m₁₂ : Int\nh₁₂ : Eq (HAdd.hAdd n₁₂ 1) m₁₂\nh₁ : Eq (HAdd.hAdd n₁ 1) m₁\nh₂ : Eq (HAdd.hAdd n₂ 1) m₂\n⊢ Eq (CochainComplex.HomComplex.δ n₁₂ m₁₂ (z₁.comp z₂ h)) (HAdd.hAdd (z₁.comp (CochainComplex.HomComplex.δ n₂ m₂ z₂) ⋯) (HSMul.hSMul n₂.negOnePow ((CochainComplex.HomComplex.δ n₁ m₁ z₁).comp z₂ ⋯)))","decl":"lemma δ_comp {n₁ n₂ n₁₂ : ℤ} (z₁ : Cochain F G n₁) (z₂ : Cochain G K n₂) (h : n₁ + n₂ = n₁₂)\n    (m₁ m₂ m₁₂ : ℤ) (h₁₂ : n₁₂ + 1 = m₁₂) (h₁ : n₁ + 1 = m₁) (h₂ : n₂ + 1 = m₂) :\n    δ n₁₂ m₁₂ (z₁.comp z₂ h) = z₁.comp (δ n₂ m₂ z₂) (by rw [← h₁₂, ← h₂, ← h, add_assoc]) +\n      n₂.negOnePow • (δ n₁ m₁ z₁).comp z₂\n        (by rw [← h₁₂, ← h₁, ← h, add_assoc, add_comm 1, add_assoc]) := by\n  subst h₁₂ h₁ h₂ h\n  ext p q hpq\n  dsimp\n  rw [z₁.comp_v _ (add_assoc n₁ n₂ 1).symm p _ q rfl (by omega),\n    Cochain.comp_v _ _ (show n₁ + 1 + n₂ = n₁ + n₂ + 1 by omega) p (p+n₁+1) q\n      (by omega) (by omega),\n    δ_v (n₁ + n₂) _ rfl (z₁.comp z₂ rfl) p q hpq (p + n₁ + n₂) _ (by omega) rfl,\n    z₁.comp_v z₂ rfl p _ _ rfl rfl,\n    z₁.comp_v z₂ rfl (p+1) (p+n₁+1) q (by omega) (by omega),\n    δ_v n₂ (n₂+1) rfl z₂ (p+n₁) q (by omega) (p+n₁+n₂) _ (by omega) rfl,\n    δ_v n₁ (n₁+1) rfl z₁ p (p+n₁+1) (by omega) (p+n₁) _ (by omega) rfl]\n  simp only [assoc, comp_add, add_comp, Int.negOnePow_succ, Int.negOnePow_add n₁ n₂,\n    Units.neg_smul, comp_neg, neg_comp, smul_neg, smul_smul, Linear.units_smul_comp,\n    mul_comm n₁.negOnePow n₂.negOnePow, Linear.comp_units_smul, smul_add]\n  abel\n\n"}
{"name":"CochainComplex.HomComplex.δ_zero_cochain_comp","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G K : CochainComplex C Int\nn₂ : Int\nz₁ : CochainComplex.HomComplex.Cochain F G 0\nz₂ : CochainComplex.HomComplex.Cochain G K n₂\nm₂ : Int\nh₂ : Eq (HAdd.hAdd n₂ 1) m₂\n⊢ Eq (CochainComplex.HomComplex.δ n₂ m₂ (z₁.comp z₂ ⋯)) (HAdd.hAdd (z₁.comp (CochainComplex.HomComplex.δ n₂ m₂ z₂) ⋯) (HSMul.hSMul n₂.negOnePow ((CochainComplex.HomComplex.δ 0 1 z₁).comp z₂ ⋯)))","decl":"lemma δ_zero_cochain_comp {n₂ : ℤ} (z₁ : Cochain F G 0) (z₂ : Cochain G K n₂)\n    (m₂ : ℤ) (h₂ : n₂ + 1 = m₂) :\n    δ n₂ m₂ (z₁.comp z₂ (zero_add n₂)) =\n      z₁.comp (δ n₂ m₂ z₂) (zero_add m₂) +\n      n₂.negOnePow • ((δ 0 1 z₁).comp z₂ (by rw [add_comm, h₂])) :=\n  δ_comp z₁ z₂ (zero_add n₂) 1 m₂ m₂ h₂ (zero_add 1) h₂\n\n"}
{"name":"CochainComplex.HomComplex.δ_comp_zero_cochain","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G K : CochainComplex C Int\nn₁ : Int\nz₁ : CochainComplex.HomComplex.Cochain F G n₁\nz₂ : CochainComplex.HomComplex.Cochain G K 0\nm₁ : Int\nh₁ : Eq (HAdd.hAdd n₁ 1) m₁\n⊢ Eq (CochainComplex.HomComplex.δ n₁ m₁ (z₁.comp z₂ ⋯)) (HAdd.hAdd (z₁.comp (CochainComplex.HomComplex.δ 0 1 z₂) h₁) ((CochainComplex.HomComplex.δ n₁ m₁ z₁).comp z₂ ⋯))","decl":"lemma δ_comp_zero_cochain {n₁ : ℤ} (z₁ : Cochain F G n₁) (z₂ : Cochain G K 0)\n    (m₁ : ℤ) (h₁ : n₁ + 1 = m₁) :\n    δ n₁ m₁ (z₁.comp z₂ (add_zero n₁)) =\n      z₁.comp (δ 0 1 z₂) h₁ + (δ n₁ m₁ z₁).comp z₂ (add_zero m₁) := by\n  simp only [δ_comp z₁ z₂ (add_zero n₁) m₁ 1 m₁ h₁ h₁ (zero_add 1), one_smul,\n    Int.negOnePow_zero]\n\n"}
{"name":"CochainComplex.HomComplex.δ_zero_cochain_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nz : CochainComplex.HomComplex.Cochain F G 0\np q : Int\nhpq : Eq (HAdd.hAdd p 1) q\n⊢ Eq ((CochainComplex.HomComplex.δ 0 1 z).v p q hpq) (HSub.hSub (CategoryTheory.CategoryStruct.comp (z.v p p ⋯) (G.d p q)) (CategoryTheory.CategoryStruct.comp (F.d p q) (z.v q q ⋯)))","decl":"@[simp]\nlemma δ_zero_cochain_v (z : Cochain F G 0) (p q : ℤ) (hpq : p + 1 = q) :\n    (δ 0 1 z).v p q hpq = z.v p p (add_zero p) ≫ G.d p q - F.d p q ≫ z.v q q (add_zero q) := by\n  simp only [δ_v 0 1 (zero_add 1) z p q hpq p q (by omega) hpq, zero_add,\n    Int.negOnePow_one, Units.neg_smul, one_smul, sub_eq_add_neg]\n\n"}
{"name":"CochainComplex.HomComplex.δ_ofHom","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\np : Int\nφ : Quiver.Hom F G\n⊢ Eq (CochainComplex.HomComplex.δ 0 p (CochainComplex.HomComplex.Cochain.ofHom φ)) 0","decl":"@[simp]\nlemma δ_ofHom {p : ℤ} (φ : F ⟶ G) : δ 0 p (Cochain.ofHom φ) = 0 := by\n  by_cases h : p = 1\n  · subst h\n    ext\n    simp\n  · rw [δ_shape]\n    omega\n\n"}
{"name":"CochainComplex.HomComplex.δ_ofHomotopy","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ₁ φ₂ : Quiver.Hom F G\nh : Homotopy φ₁ φ₂\n⊢ Eq (CochainComplex.HomComplex.δ (-1) 0 (CochainComplex.HomComplex.Cochain.ofHomotopy h)) (HSub.hSub (CochainComplex.HomComplex.Cochain.ofHom φ₁) (CochainComplex.HomComplex.Cochain.ofHom φ₂))","decl":"@[simp]\nlemma δ_ofHomotopy {φ₁ φ₂ : F ⟶ G} (h : Homotopy φ₁ φ₂) :\n    δ (-1) 0 (Cochain.ofHomotopy h) = Cochain.ofHom φ₁ - Cochain.ofHom φ₂ := by\n  ext p\n  have eq := h.comm p\n  rw [dNext_eq h.hom (show (ComplexShape.up ℤ).Rel p (p+1) by simp),\n    prevD_eq h.hom (show (ComplexShape.up ℤ).Rel (p-1) p by simp)] at eq\n  rw [Cochain.ofHomotopy, δ_v (-1) 0 (neg_add_cancel 1) _ p p (add_zero p) (p-1) (p+1) rfl rfl]\n  simp only [Cochain.mk_v, neg_add_cancel, one_smul, Int.negOnePow_zero,\n    Cochain.sub_v, Cochain.ofHom_v, eq]\n  abel\n\n"}
{"name":"CochainComplex.HomComplex.δ_neg_one_cochain","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nz : CochainComplex.HomComplex.Cochain F G (-1)\n⊢ Eq (CochainComplex.HomComplex.δ (-1) 0 z) (CochainComplex.HomComplex.Cochain.ofHom (Homotopy.nullHomotopicMap' fun i j hij => z.v i j ⋯))","decl":"lemma δ_neg_one_cochain (z : Cochain F G (-1)) :\n    δ (-1) 0 z = Cochain.ofHom (Homotopy.nullHomotopicMap'\n      (fun i j hij => z.v i j (by dsimp at hij; rw [← hij, add_neg_cancel_right]))) := by\n  ext p\n  rw [δ_v (-1) 0 (neg_add_cancel 1) _ p p (add_zero p) (p-1) (p+1) rfl rfl]\n  simp only [neg_add_cancel, one_smul, Cochain.ofHom_v, Int.negOnePow_zero]\n  rw [Homotopy.nullHomotopicMap'_f (show (ComplexShape.up ℤ).Rel (p-1) p by simp)\n    (show (ComplexShape.up ℤ).Rel p (p+1) by simp)]\n  abel\n\n"}
{"name":"CochainComplex.HomComplex_X","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\ni : Int\n⊢ Eq ((F.HomComplex G).X i) (AddCommGrp.of (CochainComplex.HomComplex.Cochain F G i))","decl":"/-- The cochain complex of homomorphisms between two cochain complexes `F` and `G`.\nIn degree `n : ℤ`, it consists of the abelian group `HomComplex.Cochain F G n`. -/\n@[simps! X d_hom_apply]\ndef HomComplex : CochainComplex AddCommGrp ℤ where\n  X i := AddCommGrp.of (Cochain F G i)\n  d i j := AddCommGrp.ofHom (δ_hom ℤ F G i j)\n  shape _ _ hij := by ext; simp [δ_shape _ _ hij]\n  d_comp_d' _ _ _ _ _  := by ext; simp [δ_δ]\n\n"}
{"name":"CochainComplex.HomComplex_d_hom_apply","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\ni j : Int\na✝ : CochainComplex.HomComplex.Cochain F G i\n⊢ Eq ((AddCommGrp.Hom.hom ((F.HomComplex G).d i j)) a✝) (CochainComplex.HomComplex.δ i j a✝)","decl":"/-- The cochain complex of homomorphisms between two cochain complexes `F` and `G`.\nIn degree `n : ℤ`, it consists of the abelian group `HomComplex.Cochain F G n`. -/\n@[simps! X d_hom_apply]\ndef HomComplex : CochainComplex AddCommGrp ℤ where\n  X i := AddCommGrp.of (Cochain F G i)\n  d i j := AddCommGrp.ofHom (δ_hom ℤ F G i j)\n  shape _ _ hij := by ext; simp [δ_shape _ _ hij]\n  d_comp_d' _ _ _ _ _  := by ext; simp [δ_δ]\n\n"}
{"name":"CochainComplex.HomComplex.Cocycle.mem_iff","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nn m : Int\nhnm : Eq (HAdd.hAdd n 1) m\nz : CochainComplex.HomComplex.Cochain F G n\n⊢ Iff (Membership.mem (CochainComplex.HomComplex.cocycle F G n) z) (Eq (CochainComplex.HomComplex.δ n m z) 0)","decl":"lemma mem_iff (hnm : n + 1 = m) (z : Cochain F G n) :\n    z ∈ cocycle F G n ↔ δ n m z = 0 := by subst hnm; rfl\n\n"}
{"name":"CochainComplex.HomComplex.Cocycle.ext_iff","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nn : Int\nz₁ z₂ : CochainComplex.HomComplex.Cocycle F G n\n⊢ Iff (Eq z₁ z₂) (Eq ↑z₁ ↑z₂)","decl":"@[ext]\nlemma ext (z₁ z₂ : Cocycle F G n) (h : (z₁ : Cochain F G n) = z₂) : z₁ = z₂ :=\n  Subtype.ext h\n\n"}
{"name":"CochainComplex.HomComplex.Cocycle.ext","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nn : Int\nz₁ z₂ : CochainComplex.HomComplex.Cocycle F G n\nh : Eq ↑z₁ ↑z₂\n⊢ Eq z₁ z₂","decl":"@[ext]\nlemma ext (z₁ z₂ : Cocycle F G n) (h : (z₁ : Cochain F G n) = z₂) : z₁ = z₂ :=\n  Subtype.ext h\n\n"}
{"name":"CochainComplex.HomComplex.Cocycle.coe_zero","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nn : Int\n⊢ Eq (↑0) 0","decl":"@[simp]\nlemma coe_zero : (↑(0 : Cocycle F G n) : Cochain F G n) = 0 := by rfl\n\n"}
{"name":"CochainComplex.HomComplex.Cocycle.coe_add","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nn : Int\nz₁ z₂ : CochainComplex.HomComplex.Cocycle F G n\n⊢ Eq (↑(HAdd.hAdd z₁ z₂)) (HAdd.hAdd ↑z₁ ↑z₂)","decl":"@[simp]\nlemma coe_add (z₁ z₂ : Cocycle F G n) :\n    (↑(z₁ + z₂) : Cochain F G n) = (z₁ : Cochain F G n) + (z₂ : Cochain F G n) := rfl\n\n"}
{"name":"CochainComplex.HomComplex.Cocycle.coe_neg","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nn : Int\nz : CochainComplex.HomComplex.Cocycle F G n\n⊢ Eq (↑(Neg.neg z)) (Neg.neg ↑z)","decl":"@[simp]\nlemma coe_neg (z : Cocycle F G n) :\n    (↑(-z) : Cochain F G n) = -(z : Cochain F G n) := rfl\n\n"}
{"name":"CochainComplex.HomComplex.Cocycle.coe_smul","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Preadditive C\nR : Type u_1\ninst✝¹ : Ring R\ninst✝ : CategoryTheory.Linear R C\nF G : CochainComplex C Int\nn : Int\nz : CochainComplex.HomComplex.Cocycle F G n\nx : R\n⊢ Eq (↑(HSMul.hSMul x z)) (HSMul.hSMul x ↑z)","decl":"@[simp]\nlemma coe_smul (z : Cocycle F G n) (x : R) :\n    (↑(x • z) : Cochain F G n) = x • (z : Cochain F G n) := rfl\n\n"}
{"name":"CochainComplex.HomComplex.Cocycle.coe_units_smul","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Preadditive C\nR : Type u_1\ninst✝¹ : Ring R\ninst✝ : CategoryTheory.Linear R C\nF G : CochainComplex C Int\nn : Int\nz : CochainComplex.HomComplex.Cocycle F G n\nx : Units R\n⊢ Eq (↑(HSMul.hSMul x z)) (HSMul.hSMul x ↑z)","decl":"@[simp]\nlemma coe_units_smul (z : Cocycle F G n) (x : Rˣ) :\n    (↑(x • z) : Cochain F G n) = x • (z : Cochain F G n) := rfl\n\n"}
{"name":"CochainComplex.HomComplex.Cocycle.coe_sub","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nn : Int\nz₁ z₂ : CochainComplex.HomComplex.Cocycle F G n\n⊢ Eq (↑(HSub.hSub z₁ z₂)) (HSub.hSub ↑z₁ ↑z₂)","decl":"@[simp]\nlemma coe_sub (z₁ z₂ : Cocycle F G n) :\n    (↑(z₁ - z₂) : Cochain F G n) = (z₁ : Cochain F G n) - (z₂ : Cochain F G n) := rfl\n\n"}
{"name":"CochainComplex.HomComplex.Cocycle.mk_coe","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nn : Int\nz : CochainComplex.HomComplex.Cochain F G n\nm : Int\nhnm : Eq (HAdd.hAdd n 1) m\nh : Eq (CochainComplex.HomComplex.δ n m z) 0\n⊢ Eq (↑(CochainComplex.HomComplex.Cocycle.mk z m hnm h)) z","decl":"/-- Constructor for `Cocycle F G n`, taking as inputs `z : Cochain F G n`, an integer\n`m : ℤ` such that `n + 1 = m`, and the relation `δ n m z = 0`. -/\n@[simps]\ndef mk (z : Cochain F G n) (m : ℤ) (hnm : n + 1 = m) (h : δ n m z = 0) : Cocycle F G n :=\n  ⟨z, by simpa only [mem_iff n m hnm z] using h⟩\n\n"}
{"name":"CochainComplex.HomComplex.Cocycle.δ_eq_zero","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nn : Int\nz : CochainComplex.HomComplex.Cocycle F G n\nm : Int\n⊢ Eq (CochainComplex.HomComplex.δ n m ↑z) 0","decl":"@[simp]\nlemma δ_eq_zero {n : ℤ} (z : Cocycle F G n) (m : ℤ) : δ n m (z : Cochain F G n) = 0 := by\n  by_cases h : n + 1 = m\n  · rw [← mem_iff n m h]\n    exact z.2\n  · exact δ_shape n m h _\n\n"}
{"name":"CochainComplex.HomComplex.Cocycle.ofHom_coe","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\n⊢ Eq (↑(CochainComplex.HomComplex.Cocycle.ofHom φ)) (CochainComplex.HomComplex.Cochain.ofHom φ)","decl":"/-- The `0`-cocycle associated to a morphism in `CochainComplex C ℤ`. -/\n@[simps!]\ndef ofHom (φ : F ⟶ G) : Cocycle F G 0 := mk (Cochain.ofHom φ) 1 (zero_add 1) (by simp)\n\n"}
{"name":"CochainComplex.HomComplex.Cocycle.homOf_f","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nz : CochainComplex.HomComplex.Cocycle F G 0\ni : Int\n⊢ Eq (z.homOf.f i) ((↑z).v i i ⋯)","decl":"/-- The morphism in `CochainComplex C ℤ` associated to a `0`-cocycle. -/\n@[simps]\ndef homOf (z : Cocycle F G 0) : F ⟶ G where\n  f i := (z : Cochain _ _ _).v i i (add_zero i)\n  comm' := by\n    rintro i j rfl\n    rcases z with ⟨z, hz⟩\n    dsimp\n    rw [mem_iff 0 1 (zero_add 1)] at hz\n    simpa only [δ_zero_cochain_v, Cochain.zero_v, sub_eq_zero]\n      using Cochain.congr_v hz i (i + 1) rfl\n\n"}
{"name":"CochainComplex.HomComplex.Cocycle.homOf_ofHom_eq_self","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\n⊢ Eq (CochainComplex.HomComplex.Cocycle.ofHom φ).homOf φ","decl":"@[simp]\nlemma homOf_ofHom_eq_self (φ : F ⟶ G) : homOf (ofHom φ) = φ := by aesop_cat\n\n"}
{"name":"CochainComplex.HomComplex.Cocycle.ofHom_homOf_eq_self","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nz : CochainComplex.HomComplex.Cocycle F G 0\n⊢ Eq (CochainComplex.HomComplex.Cocycle.ofHom z.homOf) z","decl":"@[simp]\nlemma ofHom_homOf_eq_self (z : Cocycle F G 0) : ofHom (homOf z) = z := by aesop_cat\n\n"}
{"name":"CochainComplex.HomComplex.Cocycle.cochain_ofHom_homOf_eq_coe","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nz : CochainComplex.HomComplex.Cocycle F G 0\n⊢ Eq (CochainComplex.HomComplex.Cochain.ofHom z.homOf) ↑z","decl":"@[simp]\nlemma cochain_ofHom_homOf_eq_coe (z : Cocycle F G 0) :\n    Cochain.ofHom (homOf z) = (z : Cochain F G 0) := by\n  simpa only [Cocycle.ext_iff] using ofHom_homOf_eq_self z\n\n"}
{"name":"CochainComplex.HomComplex.Cocycle.equivHom_apply","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\n⊢ Eq ((CochainComplex.HomComplex.Cocycle.equivHom F G) φ) (CochainComplex.HomComplex.Cocycle.ofHom φ)","decl":"/-- The additive equivalence between morphisms in `CochainComplex C ℤ` and `0`-cocycles. -/\n@[simps]\ndef equivHom : (F ⟶ G) ≃+ Cocycle F G 0 where\n  toFun := ofHom\n  invFun := homOf\n  left_inv := homOf_ofHom_eq_self\n  right_inv := ofHom_homOf_eq_self\n  map_add' := by aesop_cat\n\n"}
{"name":"CochainComplex.HomComplex.Cocycle.equivHom_symm_apply","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nz : CochainComplex.HomComplex.Cocycle F G 0\n⊢ Eq ((CochainComplex.HomComplex.Cocycle.equivHom F G).symm z) z.homOf","decl":"/-- The additive equivalence between morphisms in `CochainComplex C ℤ` and `0`-cocycles. -/\n@[simps]\ndef equivHom : (F ⟶ G) ≃+ Cocycle F G 0 where\n  toFun := ofHom\n  invFun := homOf\n  left_inv := homOf_ofHom_eq_self\n  right_inv := ofHom_homOf_eq_self\n  map_add' := by aesop_cat\n\n"}
{"name":"CochainComplex.HomComplex.Cocycle.diff_coe","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nK : CochainComplex C Int\n⊢ Eq (↑(CochainComplex.HomComplex.Cocycle.diff K)) (CochainComplex.HomComplex.Cochain.diff K)","decl":"/-- The `1`-cocycle given by the differential on a cochain complex. -/\n@[simps!]\ndef diff : Cocycle K K 1 :=\n  Cocycle.mk (Cochain.diff K) 2 rfl (by\n    ext p q hpq\n    simp only [Cochain.zero_v, δ_v 1 2 rfl _ p q hpq _ _ rfl rfl, Cochain.diff_v,\n      HomologicalComplex.d_comp_d, smul_zero, add_zero])\n\n"}
{"name":"CochainComplex.HomComplex.δ_comp_zero_cocycle","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G K : CochainComplex C Int\nn : Int\nz₁ : CochainComplex.HomComplex.Cochain F G n\nz₂ : CochainComplex.HomComplex.Cocycle G K 0\nm : Int\n⊢ Eq (CochainComplex.HomComplex.δ n m (z₁.comp ↑z₂ ⋯)) ((CochainComplex.HomComplex.δ n m z₁).comp ↑z₂ ⋯)","decl":"@[simp]\nlemma δ_comp_zero_cocycle {n : ℤ} (z₁ : Cochain F G n) (z₂ : Cocycle G K 0) (m : ℤ) :\n    δ n m (z₁.comp z₂.1 (add_zero n)) =\n      (δ n m z₁).comp z₂.1 (add_zero m) := by\n  by_cases hnm : n + 1 = m\n  · simp [δ_comp_zero_cochain _ _ _ hnm]\n  · simp [δ_shape _ _ hnm]\n\n"}
{"name":"CochainComplex.HomComplex.δ_comp_ofHom","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G K : CochainComplex C Int\nn : Int\nz₁ : CochainComplex.HomComplex.Cochain F G n\nf : Quiver.Hom G K\nm : Int\n⊢ Eq (CochainComplex.HomComplex.δ n m (z₁.comp (CochainComplex.HomComplex.Cochain.ofHom f) ⋯)) ((CochainComplex.HomComplex.δ n m z₁).comp (CochainComplex.HomComplex.Cochain.ofHom f) ⋯)","decl":"@[simp]\nlemma δ_comp_ofHom {n : ℤ} (z₁ : Cochain F G n) (f : G ⟶ K) (m : ℤ) :\n    δ n m (z₁.comp (Cochain.ofHom f) (add_zero n)) =\n      (δ n m z₁).comp (Cochain.ofHom f) (add_zero m) := by\n  rw [← Cocycle.ofHom_coe, δ_comp_zero_cocycle]\n\n\n"}
{"name":"CochainComplex.HomComplex.δ_zero_cocycle_comp","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G K : CochainComplex C Int\nn : Int\nz₁ : CochainComplex.HomComplex.Cocycle F G 0\nz₂ : CochainComplex.HomComplex.Cochain G K n\nm : Int\n⊢ Eq (CochainComplex.HomComplex.δ n m ((↑z₁).comp z₂ ⋯)) ((↑z₁).comp (CochainComplex.HomComplex.δ n m z₂) ⋯)","decl":"@[simp]\nlemma δ_zero_cocycle_comp {n : ℤ} (z₁ : Cocycle F G 0) (z₂ : Cochain G K n) (m : ℤ) :\n    δ n m (z₁.1.comp z₂ (zero_add n)) =\n      z₁.1.comp (δ n m z₂) (zero_add m) := by\n  by_cases hnm : n + 1 = m\n  · simp [δ_zero_cochain_comp _ _ _ hnm]\n  · simp [δ_shape _ _ hnm]\n\n"}
{"name":"CochainComplex.HomComplex.δ_ofHom_comp","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G K : CochainComplex C Int\nn : Int\nf : Quiver.Hom F G\nz : CochainComplex.HomComplex.Cochain G K n\nm : Int\n⊢ Eq (CochainComplex.HomComplex.δ n m ((CochainComplex.HomComplex.Cochain.ofHom f).comp z ⋯)) ((CochainComplex.HomComplex.Cochain.ofHom f).comp (CochainComplex.HomComplex.δ n m z) ⋯)","decl":"@[simp]\nlemma δ_ofHom_comp {n : ℤ} (f : F ⟶ G) (z : Cochain G K n) (m : ℤ) :\n    δ n m ((Cochain.ofHom f).comp z (zero_add n)) =\n      (Cochain.ofHom f).comp (δ n m z) (zero_add m) := by\n  rw [← Cocycle.ofHom_coe, δ_zero_cocycle_comp]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.equivHomotopy_apply_coe","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ₁ φ₂ : Quiver.Hom F G\nho : Homotopy φ₁ φ₂\n⊢ Eq (↑((CochainComplex.HomComplex.Cochain.equivHomotopy φ₁ φ₂) ho)) (CochainComplex.HomComplex.Cochain.ofHomotopy ho)","decl":"/-- Given two morphisms of complexes `φ₁ φ₂ : F ⟶ G`, the datum of an homotopy between `φ₁` and\n`φ₂` is equivalent to the datum of a `1`-cochain `z` such that `δ (-1) 0 z` is the difference\nof the zero cochains associated to `φ₂` and `φ₁`. -/\n@[simps]\ndef equivHomotopy (φ₁ φ₂ : F ⟶ G) :\n    Homotopy φ₁ φ₂ ≃\n      { z : Cochain F G (-1) // Cochain.ofHom φ₁ = δ (-1) 0 z + Cochain.ofHom φ₂ } where\n  toFun ho := ⟨Cochain.ofHomotopy ho, by simp only [δ_ofHomotopy, sub_add_cancel]⟩\n  invFun z :=\n    { hom := fun i j => if hij : i + (-1) = j then z.1.v i j hij else 0\n      zero := fun i j (hij : j + 1 ≠ i) => dif_neg (fun _ => hij (by omega))\n      comm := fun p => by\n        have eq := Cochain.congr_v z.2 p p (add_zero p)\n        have h₁ : (ComplexShape.up ℤ).Rel (p - 1) p := by simp\n        have h₂ : (ComplexShape.up ℤ).Rel p (p + 1) := by simp\n        simp only [δ_neg_one_cochain, Cochain.ofHom_v, ComplexShape.up_Rel, Cochain.add_v,\n          Homotopy.nullHomotopicMap'_f h₁ h₂] at eq\n        rw [dNext_eq _ h₂, prevD_eq _ h₁, eq, dif_pos, dif_pos] }\n  left_inv := fun ho => by\n    ext i j\n    dsimp\n    split_ifs with h\n    · rfl\n    · rw [ho.zero i j (fun h' => h (by dsimp at h'; omega))]\n  right_inv := fun z => by\n    ext p q hpq\n    dsimp [Cochain.ofHomotopy]\n    rw [dif_pos hpq]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.equivHomotopy_symm_apply_hom","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ₁ φ₂ : Quiver.Hom F G\nz : Subtype fun z => Eq (CochainComplex.HomComplex.Cochain.ofHom φ₁) (HAdd.hAdd (CochainComplex.HomComplex.δ (-1) 0 z) (CochainComplex.HomComplex.Cochain.ofHom φ₂))\ni j : Int\n⊢ Eq (((CochainComplex.HomComplex.Cochain.equivHomotopy φ₁ φ₂).symm z).hom i j) (dite (Eq (HAdd.hAdd i (-1)) j) (fun hij => (↑z).v i j hij) fun hij => 0)","decl":"/-- Given two morphisms of complexes `φ₁ φ₂ : F ⟶ G`, the datum of an homotopy between `φ₁` and\n`φ₂` is equivalent to the datum of a `1`-cochain `z` such that `δ (-1) 0 z` is the difference\nof the zero cochains associated to `φ₂` and `φ₁`. -/\n@[simps]\ndef equivHomotopy (φ₁ φ₂ : F ⟶ G) :\n    Homotopy φ₁ φ₂ ≃\n      { z : Cochain F G (-1) // Cochain.ofHom φ₁ = δ (-1) 0 z + Cochain.ofHom φ₂ } where\n  toFun ho := ⟨Cochain.ofHomotopy ho, by simp only [δ_ofHomotopy, sub_add_cancel]⟩\n  invFun z :=\n    { hom := fun i j => if hij : i + (-1) = j then z.1.v i j hij else 0\n      zero := fun i j (hij : j + 1 ≠ i) => dif_neg (fun _ => hij (by omega))\n      comm := fun p => by\n        have eq := Cochain.congr_v z.2 p p (add_zero p)\n        have h₁ : (ComplexShape.up ℤ).Rel (p - 1) p := by simp\n        have h₂ : (ComplexShape.up ℤ).Rel p (p + 1) := by simp\n        simp only [δ_neg_one_cochain, Cochain.ofHom_v, ComplexShape.up_Rel, Cochain.add_v,\n          Homotopy.nullHomotopicMap'_f h₁ h₂] at eq\n        rw [dNext_eq _ h₂, prevD_eq _ h₁, eq, dif_pos, dif_pos] }\n  left_inv := fun ho => by\n    ext i j\n    dsimp\n    split_ifs with h\n    · rfl\n    · rw [ho.zero i j (fun h' => h (by dsimp at h'; omega))]\n  right_inv := fun z => by\n    ext p q hpq\n    dsimp [Cochain.ofHomotopy]\n    rw [dif_pos hpq]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.equivHomotopy_apply_of_eq","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ₁ φ₂ : Quiver.Hom F G\nh : Eq φ₁ φ₂\n⊢ Eq (↑((CochainComplex.HomComplex.Cochain.equivHomotopy φ₁ φ₂) (Homotopy.ofEq h))) 0","decl":"@[simp]\nlemma equivHomotopy_apply_of_eq {φ₁ φ₂ : F ⟶ G} (h : φ₁ = φ₂) :\n    (equivHomotopy _ _ (Homotopy.ofEq h)).1 = 0 := rfl\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.ofHom_injective","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nf₁ f₂ : Quiver.Hom F G\nh : Eq (CochainComplex.HomComplex.Cochain.ofHom f₁) (CochainComplex.HomComplex.Cochain.ofHom f₂)\n⊢ Eq f₁ f₂","decl":"lemma ofHom_injective {f₁ f₂ : F ⟶ G} (h : ofHom f₁ = ofHom f₂) : f₁ = f₂ :=\n  (Cocycle.equivHom F G).injective (by ext1; exact h)\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.map_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Preadditive C\nK L : CochainComplex C Int\nn : Int\nD : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_2} D\ninst✝¹ : CategoryTheory.Preadditive D\nz : CochainComplex.HomComplex.Cochain K L n\nΦ : CategoryTheory.Functor C D\ninst✝ : Φ.Additive\np q : Int\nhpq : Eq (HAdd.hAdd p n) q\n⊢ Eq ((z.map Φ).v p q hpq) (Φ.map (z.v p q hpq))","decl":"@[simp]\nlemma map_v (p q : ℤ) (hpq : p + n = q) : (z.map Φ).v p q hpq = Φ.map (z.v p q hpq) := rfl\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.map_add","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Preadditive C\nK L : CochainComplex C Int\nn : Int\nD : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_2} D\ninst✝¹ : CategoryTheory.Preadditive D\nz z' : CochainComplex.HomComplex.Cochain K L n\nΦ : CategoryTheory.Functor C D\ninst✝ : Φ.Additive\n⊢ Eq ((HAdd.hAdd z z').map Φ) (HAdd.hAdd (z.map Φ) (z'.map Φ))","decl":"@[simp]\nlemma map_add : (z + z').map Φ = z.map Φ + z'.map Φ := by aesop_cat\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.map_neg","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Preadditive C\nK L : CochainComplex C Int\nn : Int\nD : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_2} D\ninst✝¹ : CategoryTheory.Preadditive D\nz : CochainComplex.HomComplex.Cochain K L n\nΦ : CategoryTheory.Functor C D\ninst✝ : Φ.Additive\n⊢ Eq ((Neg.neg z).map Φ) (Neg.neg (z.map Φ))","decl":"@[simp]\nlemma map_neg : (-z).map Φ = -z.map Φ := by aesop_cat\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.map_sub","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Preadditive C\nK L : CochainComplex C Int\nn : Int\nD : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_2} D\ninst✝¹ : CategoryTheory.Preadditive D\nz z' : CochainComplex.HomComplex.Cochain K L n\nΦ : CategoryTheory.Functor C D\ninst✝ : Φ.Additive\n⊢ Eq ((HSub.hSub z z').map Φ) (HSub.hSub (z.map Φ) (z'.map Φ))","decl":"@[simp]\nlemma map_sub : (z - z').map Φ = z.map Φ - z'.map Φ := by aesop_cat\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.map_zero","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Preadditive C\nK L : CochainComplex C Int\nn : Int\nD : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_2} D\ninst✝¹ : CategoryTheory.Preadditive D\nΦ : CategoryTheory.Functor C D\ninst✝ : Φ.Additive\n⊢ Eq (CochainComplex.HomComplex.Cochain.map 0 Φ) 0","decl":"@[simp]\nlemma map_zero : (0 : Cochain K L n).map Φ = 0 := by aesop_cat\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.map_comp","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Preadditive C\nF G K : CochainComplex C Int\nD : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_2} D\ninst✝¹ : CategoryTheory.Preadditive D\nn₁ n₂ n₁₂ : Int\nz₁ : CochainComplex.HomComplex.Cochain F G n₁\nz₂ : CochainComplex.HomComplex.Cochain G K n₂\nh : Eq (HAdd.hAdd n₁ n₂) n₁₂\nΦ : CategoryTheory.Functor C D\ninst✝ : Φ.Additive\n⊢ Eq ((z₁.comp z₂ h).map Φ) ((z₁.map Φ).comp (z₂.map Φ) h)","decl":"@[simp]\nlemma map_comp {n₁ n₂ n₁₂ : ℤ} (z₁ : Cochain F G n₁) (z₂ : Cochain G K n₂) (h : n₁ + n₂ = n₁₂)\n    (Φ : C ⥤ D) [Φ.Additive] :\n    (Cochain.comp z₁ z₂ h).map Φ = Cochain.comp (z₁.map Φ) (z₂.map Φ) h := by\n  ext p q hpq\n  dsimp\n  simp only [map_v, comp_v _ _ h p _ q rfl (by omega), Φ.map_comp]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.map_ofHom","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Preadditive C\nK L : CochainComplex C Int\nD : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_2} D\ninst✝¹ : CategoryTheory.Preadditive D\nf : Quiver.Hom K L\nΦ : CategoryTheory.Functor C D\ninst✝ : Φ.Additive\n⊢ Eq ((CochainComplex.HomComplex.Cochain.ofHom f).map Φ) (CochainComplex.HomComplex.Cochain.ofHom ((Φ.mapHomologicalComplex (ComplexShape.up Int)).map f))","decl":"@[simp]\nlemma map_ofHom :\n    (Cochain.ofHom f).map Φ = Cochain.ofHom ((Φ.mapHomologicalComplex _).map f) := by aesop_cat\n\n"}
{"name":"CochainComplex.HomComplex.δ_map","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplex","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Preadditive C\nK L : CochainComplex C Int\nn m : Int\nD : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_2} D\ninst✝¹ : CategoryTheory.Preadditive D\nz : CochainComplex.HomComplex.Cochain K L n\nΦ : CategoryTheory.Functor C D\ninst✝ : Φ.Additive\n⊢ Eq (CochainComplex.HomComplex.δ n m (z.map Φ)) ((CochainComplex.HomComplex.δ n m z).map Φ)","decl":"@[simp]\nlemma δ_map : δ n m (z.map Φ) = (δ n m z).map Φ := by\n  by_cases hnm : n + 1 = m\n  · ext p q hpq\n    dsimp\n    simp only [δ_v n m hnm _ p q hpq (q-1) (p+1) rfl rfl,\n      Functor.map_add, Functor.map_comp, Functor.map_units_smul,\n      Cochain.map_v, Functor.mapHomologicalComplex_obj_d]\n  · simp only [δ_shape _ _ hnm, Cochain.map_zero]\n\n"}
