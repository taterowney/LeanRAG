{"name":"CategoryTheory.StructuredArrow.commaMapEquivalenceFunctor_obj_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.CommaMap","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : Type u‚ÇÉ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} T\nL : CategoryTheory.Functor C T\nR : CategoryTheory.Functor D T\nC' : Type u‚ÇÑ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} C'\nD' : Type u‚ÇÖ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÖ, u‚ÇÖ} D'\nT' : Type u‚ÇÜ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÜ, u‚ÇÜ} T'\nL' : CategoryTheory.Functor C' T'\nR' : CategoryTheory.Functor D' T'\nF‚ÇÅ : CategoryTheory.Functor C C'\nF‚ÇÇ : CategoryTheory.Functor D D'\nF : CategoryTheory.Functor T T'\nŒ± : Quiver.Hom (F‚ÇÅ.comp L') (L.comp F)\nŒ≤ : Quiver.Hom (R.comp F) (F‚ÇÇ.comp R')\ninst‚úù : CategoryTheory.IsIso Œ≤\nX : CategoryTheory.Comma L' R'\nY : CategoryTheory.StructuredArrow X (CategoryTheory.Comma.map Œ± Œ≤)\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.commaMapEquivalenceFunctor Œ± Œ≤ X).obj Y).right (CategoryTheory.StructuredArrow.mk Y.hom.right)","decl":"/-- The functor establishing the equivalence `StructuredArrow.commaMapEquivalence`. -/\n@[simps]\ndef commaMapEquivalenceFunctor [IsIso Œ≤] (X : Comma L' R') :\n    StructuredArrow X (Comma.map Œ± Œ≤) ‚•§ Comma (map‚ÇÇ (ùüô _) Œ±) (map‚ÇÇ X.hom (inv Œ≤)) where\n  obj Y := ‚ü®mk Y.hom.left, mk Y.hom.right,\n    homMk Y.right.hom\n      (by simpa only [Functor.const_obj_obj, map‚ÇÇ_obj_left, mk_left, map‚ÇÇ_obj_right, mk_right,\n        map‚ÇÇ_obj_hom, mk_hom_eq_self, Category.id_comp, Category.assoc, NatIso.isIso_inv_app,\n        Functor.comp_obj, Comma.map_obj_right, Comma.map_obj_left, Comma.map_obj_hom,\n        IsIso.hom_inv_id, Category.comp_id] using\n        congrFun (congrArg CategoryStruct.comp Y.hom.w) (inv (Œ≤.app Y.right.right)))‚ü©\n  map {Y Z} f := ‚ü®homMk f.right.left (congrArg CommaMorphism.left (StructuredArrow.w f)),\n    homMk f.right.right (congrArg CommaMorphism.right (StructuredArrow.w f)),\n    by simp only [Functor.const_obj_obj, map‚ÇÇ_obj_left, mk_left, map‚ÇÇ_obj_right, mk_right,\n      map‚ÇÇ_obj_hom, mk_hom_eq_self, Functor.comp_obj, id_eq, Comma.map_obj_right,\n      Comma.map_obj_left, Comma.map_obj_hom, eq_mp_eq_cast, eq_mpr_eq_cast, hom_eq_iff, comp_right,\n      map‚ÇÇ_map_right, homMk_right, CommaMorphism.w] ‚ü©\n  map_id X := by ext <;> rfl\n  map_comp f g := by ext <;> rfl\n\n"}
{"name":"CategoryTheory.StructuredArrow.commaMapEquivalenceFunctor_map_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.CommaMap","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : Type u‚ÇÉ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} T\nL : CategoryTheory.Functor C T\nR : CategoryTheory.Functor D T\nC' : Type u‚ÇÑ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} C'\nD' : Type u‚ÇÖ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÖ, u‚ÇÖ} D'\nT' : Type u‚ÇÜ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÜ, u‚ÇÜ} T'\nL' : CategoryTheory.Functor C' T'\nR' : CategoryTheory.Functor D' T'\nF‚ÇÅ : CategoryTheory.Functor C C'\nF‚ÇÇ : CategoryTheory.Functor D D'\nF : CategoryTheory.Functor T T'\nŒ± : Quiver.Hom (F‚ÇÅ.comp L') (L.comp F)\nŒ≤ : Quiver.Hom (R.comp F) (F‚ÇÇ.comp R')\ninst‚úù : CategoryTheory.IsIso Œ≤\nX : CategoryTheory.Comma L' R'\nY Z : CategoryTheory.StructuredArrow X (CategoryTheory.Comma.map Œ± Œ≤)\nf : Quiver.Hom Y Z\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.commaMapEquivalenceFunctor Œ± Œ≤ X).map f).left (CategoryTheory.StructuredArrow.homMk f.right.left ‚ãØ)","decl":"/-- The functor establishing the equivalence `StructuredArrow.commaMapEquivalence`. -/\n@[simps]\ndef commaMapEquivalenceFunctor [IsIso Œ≤] (X : Comma L' R') :\n    StructuredArrow X (Comma.map Œ± Œ≤) ‚•§ Comma (map‚ÇÇ (ùüô _) Œ±) (map‚ÇÇ X.hom (inv Œ≤)) where\n  obj Y := ‚ü®mk Y.hom.left, mk Y.hom.right,\n    homMk Y.right.hom\n      (by simpa only [Functor.const_obj_obj, map‚ÇÇ_obj_left, mk_left, map‚ÇÇ_obj_right, mk_right,\n        map‚ÇÇ_obj_hom, mk_hom_eq_self, Category.id_comp, Category.assoc, NatIso.isIso_inv_app,\n        Functor.comp_obj, Comma.map_obj_right, Comma.map_obj_left, Comma.map_obj_hom,\n        IsIso.hom_inv_id, Category.comp_id] using\n        congrFun (congrArg CategoryStruct.comp Y.hom.w) (inv (Œ≤.app Y.right.right)))‚ü©\n  map {Y Z} f := ‚ü®homMk f.right.left (congrArg CommaMorphism.left (StructuredArrow.w f)),\n    homMk f.right.right (congrArg CommaMorphism.right (StructuredArrow.w f)),\n    by simp only [Functor.const_obj_obj, map‚ÇÇ_obj_left, mk_left, map‚ÇÇ_obj_right, mk_right,\n      map‚ÇÇ_obj_hom, mk_hom_eq_self, Functor.comp_obj, id_eq, Comma.map_obj_right,\n      Comma.map_obj_left, Comma.map_obj_hom, eq_mp_eq_cast, eq_mpr_eq_cast, hom_eq_iff, comp_right,\n      map‚ÇÇ_map_right, homMk_right, CommaMorphism.w] ‚ü©\n  map_id X := by ext <;> rfl\n  map_comp f g := by ext <;> rfl\n\n"}
{"name":"CategoryTheory.StructuredArrow.commaMapEquivalenceFunctor_map_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.CommaMap","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : Type u‚ÇÉ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} T\nL : CategoryTheory.Functor C T\nR : CategoryTheory.Functor D T\nC' : Type u‚ÇÑ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} C'\nD' : Type u‚ÇÖ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÖ, u‚ÇÖ} D'\nT' : Type u‚ÇÜ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÜ, u‚ÇÜ} T'\nL' : CategoryTheory.Functor C' T'\nR' : CategoryTheory.Functor D' T'\nF‚ÇÅ : CategoryTheory.Functor C C'\nF‚ÇÇ : CategoryTheory.Functor D D'\nF : CategoryTheory.Functor T T'\nŒ± : Quiver.Hom (F‚ÇÅ.comp L') (L.comp F)\nŒ≤ : Quiver.Hom (R.comp F) (F‚ÇÇ.comp R')\ninst‚úù : CategoryTheory.IsIso Œ≤\nX : CategoryTheory.Comma L' R'\nY Z : CategoryTheory.StructuredArrow X (CategoryTheory.Comma.map Œ± Œ≤)\nf : Quiver.Hom Y Z\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.commaMapEquivalenceFunctor Œ± Œ≤ X).map f).right (CategoryTheory.StructuredArrow.homMk f.right.right ‚ãØ)","decl":"/-- The functor establishing the equivalence `StructuredArrow.commaMapEquivalence`. -/\n@[simps]\ndef commaMapEquivalenceFunctor [IsIso Œ≤] (X : Comma L' R') :\n    StructuredArrow X (Comma.map Œ± Œ≤) ‚•§ Comma (map‚ÇÇ (ùüô _) Œ±) (map‚ÇÇ X.hom (inv Œ≤)) where\n  obj Y := ‚ü®mk Y.hom.left, mk Y.hom.right,\n    homMk Y.right.hom\n      (by simpa only [Functor.const_obj_obj, map‚ÇÇ_obj_left, mk_left, map‚ÇÇ_obj_right, mk_right,\n        map‚ÇÇ_obj_hom, mk_hom_eq_self, Category.id_comp, Category.assoc, NatIso.isIso_inv_app,\n        Functor.comp_obj, Comma.map_obj_right, Comma.map_obj_left, Comma.map_obj_hom,\n        IsIso.hom_inv_id, Category.comp_id] using\n        congrFun (congrArg CategoryStruct.comp Y.hom.w) (inv (Œ≤.app Y.right.right)))‚ü©\n  map {Y Z} f := ‚ü®homMk f.right.left (congrArg CommaMorphism.left (StructuredArrow.w f)),\n    homMk f.right.right (congrArg CommaMorphism.right (StructuredArrow.w f)),\n    by simp only [Functor.const_obj_obj, map‚ÇÇ_obj_left, mk_left, map‚ÇÇ_obj_right, mk_right,\n      map‚ÇÇ_obj_hom, mk_hom_eq_self, Functor.comp_obj, id_eq, Comma.map_obj_right,\n      Comma.map_obj_left, Comma.map_obj_hom, eq_mp_eq_cast, eq_mpr_eq_cast, hom_eq_iff, comp_right,\n      map‚ÇÇ_map_right, homMk_right, CommaMorphism.w] ‚ü©\n  map_id X := by ext <;> rfl\n  map_comp f g := by ext <;> rfl\n\n"}
{"name":"CategoryTheory.StructuredArrow.commaMapEquivalenceFunctor_obj_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.CommaMap","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : Type u‚ÇÉ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} T\nL : CategoryTheory.Functor C T\nR : CategoryTheory.Functor D T\nC' : Type u‚ÇÑ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} C'\nD' : Type u‚ÇÖ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÖ, u‚ÇÖ} D'\nT' : Type u‚ÇÜ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÜ, u‚ÇÜ} T'\nL' : CategoryTheory.Functor C' T'\nR' : CategoryTheory.Functor D' T'\nF‚ÇÅ : CategoryTheory.Functor C C'\nF‚ÇÇ : CategoryTheory.Functor D D'\nF : CategoryTheory.Functor T T'\nŒ± : Quiver.Hom (F‚ÇÅ.comp L') (L.comp F)\nŒ≤ : Quiver.Hom (R.comp F) (F‚ÇÇ.comp R')\ninst‚úù : CategoryTheory.IsIso Œ≤\nX : CategoryTheory.Comma L' R'\nY : CategoryTheory.StructuredArrow X (CategoryTheory.Comma.map Œ± Œ≤)\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.commaMapEquivalenceFunctor Œ± Œ≤ X).obj Y).left (CategoryTheory.StructuredArrow.mk Y.hom.left)","decl":"/-- The functor establishing the equivalence `StructuredArrow.commaMapEquivalence`. -/\n@[simps]\ndef commaMapEquivalenceFunctor [IsIso Œ≤] (X : Comma L' R') :\n    StructuredArrow X (Comma.map Œ± Œ≤) ‚•§ Comma (map‚ÇÇ (ùüô _) Œ±) (map‚ÇÇ X.hom (inv Œ≤)) where\n  obj Y := ‚ü®mk Y.hom.left, mk Y.hom.right,\n    homMk Y.right.hom\n      (by simpa only [Functor.const_obj_obj, map‚ÇÇ_obj_left, mk_left, map‚ÇÇ_obj_right, mk_right,\n        map‚ÇÇ_obj_hom, mk_hom_eq_self, Category.id_comp, Category.assoc, NatIso.isIso_inv_app,\n        Functor.comp_obj, Comma.map_obj_right, Comma.map_obj_left, Comma.map_obj_hom,\n        IsIso.hom_inv_id, Category.comp_id] using\n        congrFun (congrArg CategoryStruct.comp Y.hom.w) (inv (Œ≤.app Y.right.right)))‚ü©\n  map {Y Z} f := ‚ü®homMk f.right.left (congrArg CommaMorphism.left (StructuredArrow.w f)),\n    homMk f.right.right (congrArg CommaMorphism.right (StructuredArrow.w f)),\n    by simp only [Functor.const_obj_obj, map‚ÇÇ_obj_left, mk_left, map‚ÇÇ_obj_right, mk_right,\n      map‚ÇÇ_obj_hom, mk_hom_eq_self, Functor.comp_obj, id_eq, Comma.map_obj_right,\n      Comma.map_obj_left, Comma.map_obj_hom, eq_mp_eq_cast, eq_mpr_eq_cast, hom_eq_iff, comp_right,\n      map‚ÇÇ_map_right, homMk_right, CommaMorphism.w] ‚ü©\n  map_id X := by ext <;> rfl\n  map_comp f g := by ext <;> rfl\n\n"}
{"name":"CategoryTheory.StructuredArrow.commaMapEquivalenceFunctor_obj_hom","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.CommaMap","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : Type u‚ÇÉ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} T\nL : CategoryTheory.Functor C T\nR : CategoryTheory.Functor D T\nC' : Type u‚ÇÑ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} C'\nD' : Type u‚ÇÖ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÖ, u‚ÇÖ} D'\nT' : Type u‚ÇÜ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÜ, u‚ÇÜ} T'\nL' : CategoryTheory.Functor C' T'\nR' : CategoryTheory.Functor D' T'\nF‚ÇÅ : CategoryTheory.Functor C C'\nF‚ÇÇ : CategoryTheory.Functor D D'\nF : CategoryTheory.Functor T T'\nŒ± : Quiver.Hom (F‚ÇÅ.comp L') (L.comp F)\nŒ≤ : Quiver.Hom (R.comp F) (F‚ÇÇ.comp R')\ninst‚úù : CategoryTheory.IsIso Œ≤\nX : CategoryTheory.Comma L' R'\nY : CategoryTheory.StructuredArrow X (CategoryTheory.Comma.map Œ± Œ≤)\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.commaMapEquivalenceFunctor Œ± Œ≤ X).obj Y).hom (CategoryTheory.StructuredArrow.homMk Y.right.hom ‚ãØ)","decl":"/-- The functor establishing the equivalence `StructuredArrow.commaMapEquivalence`. -/\n@[simps]\ndef commaMapEquivalenceFunctor [IsIso Œ≤] (X : Comma L' R') :\n    StructuredArrow X (Comma.map Œ± Œ≤) ‚•§ Comma (map‚ÇÇ (ùüô _) Œ±) (map‚ÇÇ X.hom (inv Œ≤)) where\n  obj Y := ‚ü®mk Y.hom.left, mk Y.hom.right,\n    homMk Y.right.hom\n      (by simpa only [Functor.const_obj_obj, map‚ÇÇ_obj_left, mk_left, map‚ÇÇ_obj_right, mk_right,\n        map‚ÇÇ_obj_hom, mk_hom_eq_self, Category.id_comp, Category.assoc, NatIso.isIso_inv_app,\n        Functor.comp_obj, Comma.map_obj_right, Comma.map_obj_left, Comma.map_obj_hom,\n        IsIso.hom_inv_id, Category.comp_id] using\n        congrFun (congrArg CategoryStruct.comp Y.hom.w) (inv (Œ≤.app Y.right.right)))‚ü©\n  map {Y Z} f := ‚ü®homMk f.right.left (congrArg CommaMorphism.left (StructuredArrow.w f)),\n    homMk f.right.right (congrArg CommaMorphism.right (StructuredArrow.w f)),\n    by simp only [Functor.const_obj_obj, map‚ÇÇ_obj_left, mk_left, map‚ÇÇ_obj_right, mk_right,\n      map‚ÇÇ_obj_hom, mk_hom_eq_self, Functor.comp_obj, id_eq, Comma.map_obj_right,\n      Comma.map_obj_left, Comma.map_obj_hom, eq_mp_eq_cast, eq_mpr_eq_cast, hom_eq_iff, comp_right,\n      map‚ÇÇ_map_right, homMk_right, CommaMorphism.w] ‚ü©\n  map_id X := by ext <;> rfl\n  map_comp f g := by ext <;> rfl\n\n"}
{"name":"CategoryTheory.StructuredArrow.commaMapEquivalenceInverse_map","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.CommaMap","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : Type u‚ÇÉ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} T\nL : CategoryTheory.Functor C T\nR : CategoryTheory.Functor D T\nC' : Type u‚ÇÑ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} C'\nD' : Type u‚ÇÖ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÖ, u‚ÇÖ} D'\nT' : Type u‚ÇÜ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÜ, u‚ÇÜ} T'\nL' : CategoryTheory.Functor C' T'\nR' : CategoryTheory.Functor D' T'\nF‚ÇÅ : CategoryTheory.Functor C C'\nF‚ÇÇ : CategoryTheory.Functor D D'\nF : CategoryTheory.Functor T T'\nŒ± : Quiver.Hom (F‚ÇÅ.comp L') (L.comp F)\nŒ≤ : Quiver.Hom (R.comp F) (F‚ÇÇ.comp R')\ninst‚úù : CategoryTheory.IsIso Œ≤\nX : CategoryTheory.Comma L' R'\nY Z : CategoryTheory.Comma (CategoryTheory.StructuredArrow.map‚ÇÇ (CategoryTheory.CategoryStruct.id (L'.obj X.left)) Œ±) (CategoryTheory.StructuredArrow.map‚ÇÇ X.hom (CategoryTheory.inv Œ≤))\nf : Quiver.Hom Y Z\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.commaMapEquivalenceInverse Œ± Œ≤ X).map f) (CategoryTheory.StructuredArrow.homMk { left := f.left.right, right := f.right.right, w := ‚ãØ } ‚ãØ)","decl":"/-- The inverse functor establishing the equivalence `StructuredArrow.commaMapEquivalence`. -/\n@[simps]\ndef commaMapEquivalenceInverse [IsIso Œ≤] (X : Comma L' R') :\n    Comma (map‚ÇÇ (ùüô _) Œ±) (map‚ÇÇ X.hom (inv Œ≤)) ‚•§ StructuredArrow X (Comma.map Œ± Œ≤) where\n  obj Y := mk (Y := ‚ü®Y.left.right, Y.right.right, Y.hom.right‚ü©)\n    ‚ü®by exact Y.left.hom, by exact Y.right.hom, by\n      simpa using congrFun (congrArg CategoryStruct.comp (StructuredArrow.w Y.hom))\n        (Œ≤.app Y.right.right)‚ü©\n  map {Y Z} f := homMk ‚ü®by exact f.left.right, by exact f.right.right,\n      by exact congrArg CommaMorphism.right f.w‚ü© (by\n      ext\n      <;> simp only [Comma.map_obj_right, Comma.map_obj_left, Comma.map_obj_hom, Functor.comp_obj,\n          map‚ÇÇ_obj_right, map‚ÇÇ_obj_left, Functor.const_obj_obj, map‚ÇÇ_obj_hom, eq_mp_eq_cast, id_eq,\n          mk_left, mk_right, mk_hom_eq_self, Comma.comp_left, Comma.map_map_left, w]\n      ¬∑ simp only [Comma.map_obj_right, Comma.map_obj_left, Comma.map_obj_hom, Functor.comp_obj,\n        map‚ÇÇ_obj_right, map‚ÇÇ_obj_left, Functor.const_obj_obj, map‚ÇÇ_obj_hom, eq_mp_eq_cast, id_eq,\n        mk_left, mk_right, mk_hom_eq_self, Comma.comp_right, Comma.map_map_right, w] )\n  map_id X := by ext <;> rfl\n  map_comp f g := by ext <;> rfl\n\n"}
{"name":"CategoryTheory.StructuredArrow.commaMapEquivalenceInverse_obj","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.CommaMap","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : Type u‚ÇÉ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} T\nL : CategoryTheory.Functor C T\nR : CategoryTheory.Functor D T\nC' : Type u‚ÇÑ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} C'\nD' : Type u‚ÇÖ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÖ, u‚ÇÖ} D'\nT' : Type u‚ÇÜ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÜ, u‚ÇÜ} T'\nL' : CategoryTheory.Functor C' T'\nR' : CategoryTheory.Functor D' T'\nF‚ÇÅ : CategoryTheory.Functor C C'\nF‚ÇÇ : CategoryTheory.Functor D D'\nF : CategoryTheory.Functor T T'\nŒ± : Quiver.Hom (F‚ÇÅ.comp L') (L.comp F)\nŒ≤ : Quiver.Hom (R.comp F) (F‚ÇÇ.comp R')\ninst‚úù : CategoryTheory.IsIso Œ≤\nX : CategoryTheory.Comma L' R'\nY : CategoryTheory.Comma (CategoryTheory.StructuredArrow.map‚ÇÇ (CategoryTheory.CategoryStruct.id (L'.obj X.left)) Œ±) (CategoryTheory.StructuredArrow.map‚ÇÇ X.hom (CategoryTheory.inv Œ≤))\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.commaMapEquivalenceInverse Œ± Œ≤ X).obj Y) (CategoryTheory.StructuredArrow.mk { left := Y.left.hom, right := Y.right.hom, w := ‚ãØ })","decl":"/-- The inverse functor establishing the equivalence `StructuredArrow.commaMapEquivalence`. -/\n@[simps]\ndef commaMapEquivalenceInverse [IsIso Œ≤] (X : Comma L' R') :\n    Comma (map‚ÇÇ (ùüô _) Œ±) (map‚ÇÇ X.hom (inv Œ≤)) ‚•§ StructuredArrow X (Comma.map Œ± Œ≤) where\n  obj Y := mk (Y := ‚ü®Y.left.right, Y.right.right, Y.hom.right‚ü©)\n    ‚ü®by exact Y.left.hom, by exact Y.right.hom, by\n      simpa using congrFun (congrArg CategoryStruct.comp (StructuredArrow.w Y.hom))\n        (Œ≤.app Y.right.right)‚ü©\n  map {Y Z} f := homMk ‚ü®by exact f.left.right, by exact f.right.right,\n      by exact congrArg CommaMorphism.right f.w‚ü© (by\n      ext\n      <;> simp only [Comma.map_obj_right, Comma.map_obj_left, Comma.map_obj_hom, Functor.comp_obj,\n          map‚ÇÇ_obj_right, map‚ÇÇ_obj_left, Functor.const_obj_obj, map‚ÇÇ_obj_hom, eq_mp_eq_cast, id_eq,\n          mk_left, mk_right, mk_hom_eq_self, Comma.comp_left, Comma.map_map_left, w]\n      ¬∑ simp only [Comma.map_obj_right, Comma.map_obj_left, Comma.map_obj_hom, Functor.comp_obj,\n        map‚ÇÇ_obj_right, map‚ÇÇ_obj_left, Functor.const_obj_obj, map‚ÇÇ_obj_hom, eq_mp_eq_cast, id_eq,\n        mk_left, mk_right, mk_hom_eq_self, Comma.comp_right, Comma.map_map_right, w] )\n  map_id X := by ext <;> rfl\n  map_comp f g := by ext <;> rfl\n\n"}
{"name":"CategoryTheory.StructuredArrow.commaMapEquivalenceUnitIso_inv_app_left_down_down","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.CommaMap","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : Type u‚ÇÉ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} T\nL : CategoryTheory.Functor C T\nR : CategoryTheory.Functor D T\nC' : Type u‚ÇÑ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} C'\nD' : Type u‚ÇÖ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÖ, u‚ÇÖ} D'\nT' : Type u‚ÇÜ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÜ, u‚ÇÜ} T'\nL' : CategoryTheory.Functor C' T'\nR' : CategoryTheory.Functor D' T'\nF‚ÇÅ : CategoryTheory.Functor C C'\nF‚ÇÇ : CategoryTheory.Functor D D'\nF : CategoryTheory.Functor T T'\nŒ± : Quiver.Hom (F‚ÇÅ.comp L') (L.comp F)\nŒ≤ : Quiver.Hom (R.comp F) (F‚ÇÇ.comp R')\ninst‚úù : CategoryTheory.IsIso Œ≤\nX‚úù : CategoryTheory.Comma L' R'\nX : CategoryTheory.StructuredArrow X‚úù (CategoryTheory.Comma.map Œ± Œ≤)\n‚ä¢ Eq ‚ãØ ‚ãØ","decl":"/-- The unit establishing the equivalence `StructuredArrow.commaMapEquivalence`. -/\n@[simps!]\ndef commaMapEquivalenceUnitIso [IsIso Œ≤] (X : Comma L' R') :\n    ùü≠ (StructuredArrow X (Comma.map Œ± Œ≤)) ‚âÖ\n      commaMapEquivalenceFunctor Œ± Œ≤ X ‚ãô commaMapEquivalenceInverse Œ± Œ≤ X :=\n  NatIso.ofComponents (fun _ => isoMk (Iso.refl _))\n\n"}
{"name":"CategoryTheory.StructuredArrow.commaMapEquivalenceUnitIso_inv_app_right_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.CommaMap","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : Type u‚ÇÉ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} T\nL : CategoryTheory.Functor C T\nR : CategoryTheory.Functor D T\nC' : Type u‚ÇÑ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} C'\nD' : Type u‚ÇÖ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÖ, u‚ÇÖ} D'\nT' : Type u‚ÇÜ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÜ, u‚ÇÜ} T'\nL' : CategoryTheory.Functor C' T'\nR' : CategoryTheory.Functor D' T'\nF‚ÇÅ : CategoryTheory.Functor C C'\nF‚ÇÇ : CategoryTheory.Functor D D'\nF : CategoryTheory.Functor T T'\nŒ± : Quiver.Hom (F‚ÇÅ.comp L') (L.comp F)\nŒ≤ : Quiver.Hom (R.comp F) (F‚ÇÇ.comp R')\ninst‚úù : CategoryTheory.IsIso Œ≤\nX‚úù : CategoryTheory.Comma L' R'\nX : CategoryTheory.StructuredArrow X‚úù (CategoryTheory.Comma.map Œ± Œ≤)\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.commaMapEquivalenceUnitIso Œ± Œ≤ X‚úù).inv.app X).right.right (CategoryTheory.CategoryStruct.id X.right.right)","decl":"/-- The unit establishing the equivalence `StructuredArrow.commaMapEquivalence`. -/\n@[simps!]\ndef commaMapEquivalenceUnitIso [IsIso Œ≤] (X : Comma L' R') :\n    ùü≠ (StructuredArrow X (Comma.map Œ± Œ≤)) ‚âÖ\n      commaMapEquivalenceFunctor Œ± Œ≤ X ‚ãô commaMapEquivalenceInverse Œ± Œ≤ X :=\n  NatIso.ofComponents (fun _ => isoMk (Iso.refl _))\n\n"}
{"name":"CategoryTheory.StructuredArrow.commaMapEquivalenceUnitIso_hom_app_right_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.CommaMap","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : Type u‚ÇÉ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} T\nL : CategoryTheory.Functor C T\nR : CategoryTheory.Functor D T\nC' : Type u‚ÇÑ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} C'\nD' : Type u‚ÇÖ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÖ, u‚ÇÖ} D'\nT' : Type u‚ÇÜ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÜ, u‚ÇÜ} T'\nL' : CategoryTheory.Functor C' T'\nR' : CategoryTheory.Functor D' T'\nF‚ÇÅ : CategoryTheory.Functor C C'\nF‚ÇÇ : CategoryTheory.Functor D D'\nF : CategoryTheory.Functor T T'\nŒ± : Quiver.Hom (F‚ÇÅ.comp L') (L.comp F)\nŒ≤ : Quiver.Hom (R.comp F) (F‚ÇÇ.comp R')\ninst‚úù : CategoryTheory.IsIso Œ≤\nX‚úù : CategoryTheory.Comma L' R'\nX : CategoryTheory.StructuredArrow X‚úù (CategoryTheory.Comma.map Œ± Œ≤)\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.commaMapEquivalenceUnitIso Œ± Œ≤ X‚úù).hom.app X).right.right (CategoryTheory.CategoryStruct.id X.right.right)","decl":"/-- The unit establishing the equivalence `StructuredArrow.commaMapEquivalence`. -/\n@[simps!]\ndef commaMapEquivalenceUnitIso [IsIso Œ≤] (X : Comma L' R') :\n    ùü≠ (StructuredArrow X (Comma.map Œ± Œ≤)) ‚âÖ\n      commaMapEquivalenceFunctor Œ± Œ≤ X ‚ãô commaMapEquivalenceInverse Œ± Œ≤ X :=\n  NatIso.ofComponents (fun _ => isoMk (Iso.refl _))\n\n"}
{"name":"CategoryTheory.StructuredArrow.commaMapEquivalenceUnitIso_hom_app_right_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.CommaMap","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : Type u‚ÇÉ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} T\nL : CategoryTheory.Functor C T\nR : CategoryTheory.Functor D T\nC' : Type u‚ÇÑ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} C'\nD' : Type u‚ÇÖ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÖ, u‚ÇÖ} D'\nT' : Type u‚ÇÜ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÜ, u‚ÇÜ} T'\nL' : CategoryTheory.Functor C' T'\nR' : CategoryTheory.Functor D' T'\nF‚ÇÅ : CategoryTheory.Functor C C'\nF‚ÇÇ : CategoryTheory.Functor D D'\nF : CategoryTheory.Functor T T'\nŒ± : Quiver.Hom (F‚ÇÅ.comp L') (L.comp F)\nŒ≤ : Quiver.Hom (R.comp F) (F‚ÇÇ.comp R')\ninst‚úù : CategoryTheory.IsIso Œ≤\nX‚úù : CategoryTheory.Comma L' R'\nX : CategoryTheory.StructuredArrow X‚úù (CategoryTheory.Comma.map Œ± Œ≤)\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.commaMapEquivalenceUnitIso Œ± Œ≤ X‚úù).hom.app X).right.left (CategoryTheory.CategoryStruct.id X.right.left)","decl":"/-- The unit establishing the equivalence `StructuredArrow.commaMapEquivalence`. -/\n@[simps!]\ndef commaMapEquivalenceUnitIso [IsIso Œ≤] (X : Comma L' R') :\n    ùü≠ (StructuredArrow X (Comma.map Œ± Œ≤)) ‚âÖ\n      commaMapEquivalenceFunctor Œ± Œ≤ X ‚ãô commaMapEquivalenceInverse Œ± Œ≤ X :=\n  NatIso.ofComponents (fun _ => isoMk (Iso.refl _))\n\n"}
{"name":"CategoryTheory.StructuredArrow.commaMapEquivalenceUnitIso_inv_app_right_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.CommaMap","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : Type u‚ÇÉ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} T\nL : CategoryTheory.Functor C T\nR : CategoryTheory.Functor D T\nC' : Type u‚ÇÑ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} C'\nD' : Type u‚ÇÖ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÖ, u‚ÇÖ} D'\nT' : Type u‚ÇÜ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÜ, u‚ÇÜ} T'\nL' : CategoryTheory.Functor C' T'\nR' : CategoryTheory.Functor D' T'\nF‚ÇÅ : CategoryTheory.Functor C C'\nF‚ÇÇ : CategoryTheory.Functor D D'\nF : CategoryTheory.Functor T T'\nŒ± : Quiver.Hom (F‚ÇÅ.comp L') (L.comp F)\nŒ≤ : Quiver.Hom (R.comp F) (F‚ÇÇ.comp R')\ninst‚úù : CategoryTheory.IsIso Œ≤\nX‚úù : CategoryTheory.Comma L' R'\nX : CategoryTheory.StructuredArrow X‚úù (CategoryTheory.Comma.map Œ± Œ≤)\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.commaMapEquivalenceUnitIso Œ± Œ≤ X‚úù).inv.app X).right.left (CategoryTheory.CategoryStruct.id X.right.left)","decl":"/-- The unit establishing the equivalence `StructuredArrow.commaMapEquivalence`. -/\n@[simps!]\ndef commaMapEquivalenceUnitIso [IsIso Œ≤] (X : Comma L' R') :\n    ùü≠ (StructuredArrow X (Comma.map Œ± Œ≤)) ‚âÖ\n      commaMapEquivalenceFunctor Œ± Œ≤ X ‚ãô commaMapEquivalenceInverse Œ± Œ≤ X :=\n  NatIso.ofComponents (fun _ => isoMk (Iso.refl _))\n\n"}
{"name":"CategoryTheory.StructuredArrow.commaMapEquivalenceUnitIso_hom_app_left_down_down","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.CommaMap","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : Type u‚ÇÉ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} T\nL : CategoryTheory.Functor C T\nR : CategoryTheory.Functor D T\nC' : Type u‚ÇÑ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} C'\nD' : Type u‚ÇÖ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÖ, u‚ÇÖ} D'\nT' : Type u‚ÇÜ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÜ, u‚ÇÜ} T'\nL' : CategoryTheory.Functor C' T'\nR' : CategoryTheory.Functor D' T'\nF‚ÇÅ : CategoryTheory.Functor C C'\nF‚ÇÇ : CategoryTheory.Functor D D'\nF : CategoryTheory.Functor T T'\nŒ± : Quiver.Hom (F‚ÇÅ.comp L') (L.comp F)\nŒ≤ : Quiver.Hom (R.comp F) (F‚ÇÇ.comp R')\ninst‚úù : CategoryTheory.IsIso Œ≤\nX‚úù : CategoryTheory.Comma L' R'\nX : CategoryTheory.StructuredArrow X‚úù (CategoryTheory.Comma.map Œ± Œ≤)\n‚ä¢ Eq ‚ãØ ‚ãØ","decl":"/-- The unit establishing the equivalence `StructuredArrow.commaMapEquivalence`. -/\n@[simps!]\ndef commaMapEquivalenceUnitIso [IsIso Œ≤] (X : Comma L' R') :\n    ùü≠ (StructuredArrow X (Comma.map Œ± Œ≤)) ‚âÖ\n      commaMapEquivalenceFunctor Œ± Œ≤ X ‚ãô commaMapEquivalenceInverse Œ± Œ≤ X :=\n  NatIso.ofComponents (fun _ => isoMk (Iso.refl _))\n\n"}
{"name":"CategoryTheory.StructuredArrow.commaMapEquivalenceCounitIso_inv_app_right_left_down_down","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.CommaMap","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : Type u‚ÇÉ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} T\nL : CategoryTheory.Functor C T\nR : CategoryTheory.Functor D T\nC' : Type u‚ÇÑ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} C'\nD' : Type u‚ÇÖ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÖ, u‚ÇÖ} D'\nT' : Type u‚ÇÜ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÜ, u‚ÇÜ} T'\nL' : CategoryTheory.Functor C' T'\nR' : CategoryTheory.Functor D' T'\nF‚ÇÅ : CategoryTheory.Functor C C'\nF‚ÇÇ : CategoryTheory.Functor D D'\nF : CategoryTheory.Functor T T'\nŒ± : Quiver.Hom (F‚ÇÅ.comp L') (L.comp F)\nŒ≤ : Quiver.Hom (R.comp F) (F‚ÇÇ.comp R')\ninst‚úù : CategoryTheory.IsIso Œ≤\nX‚úù : CategoryTheory.Comma L' R'\nX : CategoryTheory.Comma (CategoryTheory.StructuredArrow.map‚ÇÇ (CategoryTheory.CategoryStruct.id (L'.obj X‚úù.left)) Œ±) (CategoryTheory.StructuredArrow.map‚ÇÇ X‚úù.hom (CategoryTheory.inv Œ≤))\n‚ä¢ Eq ‚ãØ ‚ãØ","decl":"/-- The counit functor establishing the equivalence `StructuredArrow.commaMapEquivalence`. -/\n@[simps!]\ndef commaMapEquivalenceCounitIso [IsIso Œ≤] (X : Comma L' R') :\n    commaMapEquivalenceInverse Œ± Œ≤ X ‚ãô commaMapEquivalenceFunctor Œ± Œ≤ X ‚âÖ\n      ùü≠ (Comma (map‚ÇÇ (ùüô (L'.obj X.left)) Œ±) (map‚ÇÇ X.hom (inv Œ≤))) :=\n  NatIso.ofComponents (fun _ => Comma.isoMk (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.StructuredArrow.commaMapEquivalenceCounitIso_hom_app_right_left_down_down","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.CommaMap","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : Type u‚ÇÉ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} T\nL : CategoryTheory.Functor C T\nR : CategoryTheory.Functor D T\nC' : Type u‚ÇÑ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} C'\nD' : Type u‚ÇÖ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÖ, u‚ÇÖ} D'\nT' : Type u‚ÇÜ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÜ, u‚ÇÜ} T'\nL' : CategoryTheory.Functor C' T'\nR' : CategoryTheory.Functor D' T'\nF‚ÇÅ : CategoryTheory.Functor C C'\nF‚ÇÇ : CategoryTheory.Functor D D'\nF : CategoryTheory.Functor T T'\nŒ± : Quiver.Hom (F‚ÇÅ.comp L') (L.comp F)\nŒ≤ : Quiver.Hom (R.comp F) (F‚ÇÇ.comp R')\ninst‚úù : CategoryTheory.IsIso Œ≤\nX‚úù : CategoryTheory.Comma L' R'\nX : CategoryTheory.Comma (CategoryTheory.StructuredArrow.map‚ÇÇ (CategoryTheory.CategoryStruct.id (L'.obj X‚úù.left)) Œ±) (CategoryTheory.StructuredArrow.map‚ÇÇ X‚úù.hom (CategoryTheory.inv Œ≤))\n‚ä¢ Eq ‚ãØ ‚ãØ","decl":"/-- The counit functor establishing the equivalence `StructuredArrow.commaMapEquivalence`. -/\n@[simps!]\ndef commaMapEquivalenceCounitIso [IsIso Œ≤] (X : Comma L' R') :\n    commaMapEquivalenceInverse Œ± Œ≤ X ‚ãô commaMapEquivalenceFunctor Œ± Œ≤ X ‚âÖ\n      ùü≠ (Comma (map‚ÇÇ (ùüô (L'.obj X.left)) Œ±) (map‚ÇÇ X.hom (inv Œ≤))) :=\n  NatIso.ofComponents (fun _ => Comma.isoMk (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.StructuredArrow.commaMapEquivalenceCounitIso_inv_app_right_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.CommaMap","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : Type u‚ÇÉ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} T\nL : CategoryTheory.Functor C T\nR : CategoryTheory.Functor D T\nC' : Type u‚ÇÑ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} C'\nD' : Type u‚ÇÖ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÖ, u‚ÇÖ} D'\nT' : Type u‚ÇÜ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÜ, u‚ÇÜ} T'\nL' : CategoryTheory.Functor C' T'\nR' : CategoryTheory.Functor D' T'\nF‚ÇÅ : CategoryTheory.Functor C C'\nF‚ÇÇ : CategoryTheory.Functor D D'\nF : CategoryTheory.Functor T T'\nŒ± : Quiver.Hom (F‚ÇÅ.comp L') (L.comp F)\nŒ≤ : Quiver.Hom (R.comp F) (F‚ÇÇ.comp R')\ninst‚úù : CategoryTheory.IsIso Œ≤\nX‚úù : CategoryTheory.Comma L' R'\nX : CategoryTheory.Comma (CategoryTheory.StructuredArrow.map‚ÇÇ (CategoryTheory.CategoryStruct.id (L'.obj X‚úù.left)) Œ±) (CategoryTheory.StructuredArrow.map‚ÇÇ X‚úù.hom (CategoryTheory.inv Œ≤))\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.commaMapEquivalenceCounitIso Œ± Œ≤ X‚úù).inv.app X).right.right (CategoryTheory.CategoryStruct.id X.right.right)","decl":"/-- The counit functor establishing the equivalence `StructuredArrow.commaMapEquivalence`. -/\n@[simps!]\ndef commaMapEquivalenceCounitIso [IsIso Œ≤] (X : Comma L' R') :\n    commaMapEquivalenceInverse Œ± Œ≤ X ‚ãô commaMapEquivalenceFunctor Œ± Œ≤ X ‚âÖ\n      ùü≠ (Comma (map‚ÇÇ (ùüô (L'.obj X.left)) Œ±) (map‚ÇÇ X.hom (inv Œ≤))) :=\n  NatIso.ofComponents (fun _ => Comma.isoMk (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.StructuredArrow.commaMapEquivalenceCounitIso_inv_app_left_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.CommaMap","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : Type u‚ÇÉ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} T\nL : CategoryTheory.Functor C T\nR : CategoryTheory.Functor D T\nC' : Type u‚ÇÑ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} C'\nD' : Type u‚ÇÖ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÖ, u‚ÇÖ} D'\nT' : Type u‚ÇÜ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÜ, u‚ÇÜ} T'\nL' : CategoryTheory.Functor C' T'\nR' : CategoryTheory.Functor D' T'\nF‚ÇÅ : CategoryTheory.Functor C C'\nF‚ÇÇ : CategoryTheory.Functor D D'\nF : CategoryTheory.Functor T T'\nŒ± : Quiver.Hom (F‚ÇÅ.comp L') (L.comp F)\nŒ≤ : Quiver.Hom (R.comp F) (F‚ÇÇ.comp R')\ninst‚úù : CategoryTheory.IsIso Œ≤\nX‚úù : CategoryTheory.Comma L' R'\nX : CategoryTheory.Comma (CategoryTheory.StructuredArrow.map‚ÇÇ (CategoryTheory.CategoryStruct.id (L'.obj X‚úù.left)) Œ±) (CategoryTheory.StructuredArrow.map‚ÇÇ X‚úù.hom (CategoryTheory.inv Œ≤))\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.commaMapEquivalenceCounitIso Œ± Œ≤ X‚úù).inv.app X).left.right (CategoryTheory.CategoryStruct.id X.left.right)","decl":"/-- The counit functor establishing the equivalence `StructuredArrow.commaMapEquivalence`. -/\n@[simps!]\ndef commaMapEquivalenceCounitIso [IsIso Œ≤] (X : Comma L' R') :\n    commaMapEquivalenceInverse Œ± Œ≤ X ‚ãô commaMapEquivalenceFunctor Œ± Œ≤ X ‚âÖ\n      ùü≠ (Comma (map‚ÇÇ (ùüô (L'.obj X.left)) Œ±) (map‚ÇÇ X.hom (inv Œ≤))) :=\n  NatIso.ofComponents (fun _ => Comma.isoMk (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.StructuredArrow.commaMapEquivalenceCounitIso_inv_app_left_left_down_down","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.CommaMap","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : Type u‚ÇÉ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} T\nL : CategoryTheory.Functor C T\nR : CategoryTheory.Functor D T\nC' : Type u‚ÇÑ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} C'\nD' : Type u‚ÇÖ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÖ, u‚ÇÖ} D'\nT' : Type u‚ÇÜ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÜ, u‚ÇÜ} T'\nL' : CategoryTheory.Functor C' T'\nR' : CategoryTheory.Functor D' T'\nF‚ÇÅ : CategoryTheory.Functor C C'\nF‚ÇÇ : CategoryTheory.Functor D D'\nF : CategoryTheory.Functor T T'\nŒ± : Quiver.Hom (F‚ÇÅ.comp L') (L.comp F)\nŒ≤ : Quiver.Hom (R.comp F) (F‚ÇÇ.comp R')\ninst‚úù : CategoryTheory.IsIso Œ≤\nX‚úù : CategoryTheory.Comma L' R'\nX : CategoryTheory.Comma (CategoryTheory.StructuredArrow.map‚ÇÇ (CategoryTheory.CategoryStruct.id (L'.obj X‚úù.left)) Œ±) (CategoryTheory.StructuredArrow.map‚ÇÇ X‚úù.hom (CategoryTheory.inv Œ≤))\n‚ä¢ Eq ‚ãØ ‚ãØ","decl":"/-- The counit functor establishing the equivalence `StructuredArrow.commaMapEquivalence`. -/\n@[simps!]\ndef commaMapEquivalenceCounitIso [IsIso Œ≤] (X : Comma L' R') :\n    commaMapEquivalenceInverse Œ± Œ≤ X ‚ãô commaMapEquivalenceFunctor Œ± Œ≤ X ‚âÖ\n      ùü≠ (Comma (map‚ÇÇ (ùüô (L'.obj X.left)) Œ±) (map‚ÇÇ X.hom (inv Œ≤))) :=\n  NatIso.ofComponents (fun _ => Comma.isoMk (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.StructuredArrow.commaMapEquivalenceCounitIso_hom_app_left_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.CommaMap","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : Type u‚ÇÉ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} T\nL : CategoryTheory.Functor C T\nR : CategoryTheory.Functor D T\nC' : Type u‚ÇÑ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} C'\nD' : Type u‚ÇÖ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÖ, u‚ÇÖ} D'\nT' : Type u‚ÇÜ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÜ, u‚ÇÜ} T'\nL' : CategoryTheory.Functor C' T'\nR' : CategoryTheory.Functor D' T'\nF‚ÇÅ : CategoryTheory.Functor C C'\nF‚ÇÇ : CategoryTheory.Functor D D'\nF : CategoryTheory.Functor T T'\nŒ± : Quiver.Hom (F‚ÇÅ.comp L') (L.comp F)\nŒ≤ : Quiver.Hom (R.comp F) (F‚ÇÇ.comp R')\ninst‚úù : CategoryTheory.IsIso Œ≤\nX‚úù : CategoryTheory.Comma L' R'\nX : CategoryTheory.Comma (CategoryTheory.StructuredArrow.map‚ÇÇ (CategoryTheory.CategoryStruct.id (L'.obj X‚úù.left)) Œ±) (CategoryTheory.StructuredArrow.map‚ÇÇ X‚úù.hom (CategoryTheory.inv Œ≤))\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.commaMapEquivalenceCounitIso Œ± Œ≤ X‚úù).hom.app X).left.right (CategoryTheory.CategoryStruct.id X.left.right)","decl":"/-- The counit functor establishing the equivalence `StructuredArrow.commaMapEquivalence`. -/\n@[simps!]\ndef commaMapEquivalenceCounitIso [IsIso Œ≤] (X : Comma L' R') :\n    commaMapEquivalenceInverse Œ± Œ≤ X ‚ãô commaMapEquivalenceFunctor Œ± Œ≤ X ‚âÖ\n      ùü≠ (Comma (map‚ÇÇ (ùüô (L'.obj X.left)) Œ±) (map‚ÇÇ X.hom (inv Œ≤))) :=\n  NatIso.ofComponents (fun _ => Comma.isoMk (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.StructuredArrow.commaMapEquivalenceCounitIso_hom_app_right_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.CommaMap","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : Type u‚ÇÉ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} T\nL : CategoryTheory.Functor C T\nR : CategoryTheory.Functor D T\nC' : Type u‚ÇÑ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} C'\nD' : Type u‚ÇÖ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÖ, u‚ÇÖ} D'\nT' : Type u‚ÇÜ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÜ, u‚ÇÜ} T'\nL' : CategoryTheory.Functor C' T'\nR' : CategoryTheory.Functor D' T'\nF‚ÇÅ : CategoryTheory.Functor C C'\nF‚ÇÇ : CategoryTheory.Functor D D'\nF : CategoryTheory.Functor T T'\nŒ± : Quiver.Hom (F‚ÇÅ.comp L') (L.comp F)\nŒ≤ : Quiver.Hom (R.comp F) (F‚ÇÇ.comp R')\ninst‚úù : CategoryTheory.IsIso Œ≤\nX‚úù : CategoryTheory.Comma L' R'\nX : CategoryTheory.Comma (CategoryTheory.StructuredArrow.map‚ÇÇ (CategoryTheory.CategoryStruct.id (L'.obj X‚úù.left)) Œ±) (CategoryTheory.StructuredArrow.map‚ÇÇ X‚úù.hom (CategoryTheory.inv Œ≤))\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.commaMapEquivalenceCounitIso Œ± Œ≤ X‚úù).hom.app X).right.right (CategoryTheory.CategoryStruct.id X.right.right)","decl":"/-- The counit functor establishing the equivalence `StructuredArrow.commaMapEquivalence`. -/\n@[simps!]\ndef commaMapEquivalenceCounitIso [IsIso Œ≤] (X : Comma L' R') :\n    commaMapEquivalenceInverse Œ± Œ≤ X ‚ãô commaMapEquivalenceFunctor Œ± Œ≤ X ‚âÖ\n      ùü≠ (Comma (map‚ÇÇ (ùüô (L'.obj X.left)) Œ±) (map‚ÇÇ X.hom (inv Œ≤))) :=\n  NatIso.ofComponents (fun _ => Comma.isoMk (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.StructuredArrow.commaMapEquivalenceCounitIso_hom_app_left_left_down_down","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.CommaMap","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : Type u‚ÇÉ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} T\nL : CategoryTheory.Functor C T\nR : CategoryTheory.Functor D T\nC' : Type u‚ÇÑ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} C'\nD' : Type u‚ÇÖ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÖ, u‚ÇÖ} D'\nT' : Type u‚ÇÜ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÜ, u‚ÇÜ} T'\nL' : CategoryTheory.Functor C' T'\nR' : CategoryTheory.Functor D' T'\nF‚ÇÅ : CategoryTheory.Functor C C'\nF‚ÇÇ : CategoryTheory.Functor D D'\nF : CategoryTheory.Functor T T'\nŒ± : Quiver.Hom (F‚ÇÅ.comp L') (L.comp F)\nŒ≤ : Quiver.Hom (R.comp F) (F‚ÇÇ.comp R')\ninst‚úù : CategoryTheory.IsIso Œ≤\nX‚úù : CategoryTheory.Comma L' R'\nX : CategoryTheory.Comma (CategoryTheory.StructuredArrow.map‚ÇÇ (CategoryTheory.CategoryStruct.id (L'.obj X‚úù.left)) Œ±) (CategoryTheory.StructuredArrow.map‚ÇÇ X‚úù.hom (CategoryTheory.inv Œ≤))\n‚ä¢ Eq ‚ãØ ‚ãØ","decl":"/-- The counit functor establishing the equivalence `StructuredArrow.commaMapEquivalence`. -/\n@[simps!]\ndef commaMapEquivalenceCounitIso [IsIso Œ≤] (X : Comma L' R') :\n    commaMapEquivalenceInverse Œ± Œ≤ X ‚ãô commaMapEquivalenceFunctor Œ± Œ≤ X ‚âÖ\n      ùü≠ (Comma (map‚ÇÇ (ùüô (L'.obj X.left)) Œ±) (map‚ÇÇ X.hom (inv Œ≤))) :=\n  NatIso.ofComponents (fun _ => Comma.isoMk (Iso.refl _) (Iso.refl _))\n\n"}
