{"name":"JordanHolderLattice.second_iso","module":"Mathlib.Order.JordanHolder","initialProofState":"X : Type u\ninst✝ : Lattice X\nself : JordanHolderLattice X\nx y : X\na✝ : JordanHolderLattice.IsMaximal x (Max.max x y)\n⊢ JordanHolderLattice.Iso { fst := x, snd := Max.max x y } { fst := Min.min x y, snd := y }","decl":"/-- A `JordanHolderLattice` is the class for which the Jordan Hölder theorem is proved. A\nJordan Hölder lattice is a lattice equipped with a notion of maximality, `IsMaximal`, and a notion\nof isomorphism of pairs `Iso`. In the example of subgroups of a group, `IsMaximal H K` means that\n`H` is a maximal normal subgroup of `K`, and `Iso (H₁, K₁) (H₂, K₂)` means that the quotient\n`H₁ / K₁` is isomorphic to the quotient `H₂ / K₂`. `Iso` must be symmetric and transitive and must\nsatisfy the second isomorphism theorem `Iso (H, H ⊔ K) (H ⊓ K, K)`.\nExamples include `Subgroup G` if `G` is a group, and `Submodule R M` if `M` is an `R`-module.\n-/\nclass JordanHolderLattice (X : Type u) [Lattice X] where\n  IsMaximal : X → X → Prop\n  lt_of_isMaximal : ∀ {x y}, IsMaximal x y → x < y\n  sup_eq_of_isMaximal : ∀ {x y z}, IsMaximal x z → IsMaximal y z → x ≠ y → x ⊔ y = z\n  isMaximal_inf_left_of_isMaximal_sup :\n    ∀ {x y}, IsMaximal x (x ⊔ y) → IsMaximal y (x ⊔ y) → IsMaximal (x ⊓ y) x\n  Iso : X × X → X × X → Prop\n  iso_symm : ∀ {x y}, Iso x y → Iso y x\n  iso_trans : ∀ {x y z}, Iso x y → Iso y z → Iso x z\n  second_iso : ∀ {x y}, IsMaximal x (x ⊔ y) → Iso (x, x ⊔ y) (x ⊓ y, y)\n\n"}
{"name":"JordanHolderLattice.iso_symm","module":"Mathlib.Order.JordanHolder","initialProofState":"X : Type u\ninst✝ : Lattice X\nself : JordanHolderLattice X\nx y : Prod X X\na✝ : JordanHolderLattice.Iso x y\n⊢ JordanHolderLattice.Iso y x","decl":"/-- A `JordanHolderLattice` is the class for which the Jordan Hölder theorem is proved. A\nJordan Hölder lattice is a lattice equipped with a notion of maximality, `IsMaximal`, and a notion\nof isomorphism of pairs `Iso`. In the example of subgroups of a group, `IsMaximal H K` means that\n`H` is a maximal normal subgroup of `K`, and `Iso (H₁, K₁) (H₂, K₂)` means that the quotient\n`H₁ / K₁` is isomorphic to the quotient `H₂ / K₂`. `Iso` must be symmetric and transitive and must\nsatisfy the second isomorphism theorem `Iso (H, H ⊔ K) (H ⊓ K, K)`.\nExamples include `Subgroup G` if `G` is a group, and `Submodule R M` if `M` is an `R`-module.\n-/\nclass JordanHolderLattice (X : Type u) [Lattice X] where\n  IsMaximal : X → X → Prop\n  lt_of_isMaximal : ∀ {x y}, IsMaximal x y → x < y\n  sup_eq_of_isMaximal : ∀ {x y z}, IsMaximal x z → IsMaximal y z → x ≠ y → x ⊔ y = z\n  isMaximal_inf_left_of_isMaximal_sup :\n    ∀ {x y}, IsMaximal x (x ⊔ y) → IsMaximal y (x ⊔ y) → IsMaximal (x ⊓ y) x\n  Iso : X × X → X × X → Prop\n  iso_symm : ∀ {x y}, Iso x y → Iso y x\n  iso_trans : ∀ {x y z}, Iso x y → Iso y z → Iso x z\n  second_iso : ∀ {x y}, IsMaximal x (x ⊔ y) → Iso (x, x ⊔ y) (x ⊓ y, y)\n\n"}
{"name":"JordanHolderLattice.lt_of_isMaximal","module":"Mathlib.Order.JordanHolder","initialProofState":"X : Type u\ninst✝ : Lattice X\nself : JordanHolderLattice X\nx y : X\na✝ : JordanHolderLattice.IsMaximal x y\n⊢ LT.lt x y","decl":"/-- A `JordanHolderLattice` is the class for which the Jordan Hölder theorem is proved. A\nJordan Hölder lattice is a lattice equipped with a notion of maximality, `IsMaximal`, and a notion\nof isomorphism of pairs `Iso`. In the example of subgroups of a group, `IsMaximal H K` means that\n`H` is a maximal normal subgroup of `K`, and `Iso (H₁, K₁) (H₂, K₂)` means that the quotient\n`H₁ / K₁` is isomorphic to the quotient `H₂ / K₂`. `Iso` must be symmetric and transitive and must\nsatisfy the second isomorphism theorem `Iso (H, H ⊔ K) (H ⊓ K, K)`.\nExamples include `Subgroup G` if `G` is a group, and `Submodule R M` if `M` is an `R`-module.\n-/\nclass JordanHolderLattice (X : Type u) [Lattice X] where\n  IsMaximal : X → X → Prop\n  lt_of_isMaximal : ∀ {x y}, IsMaximal x y → x < y\n  sup_eq_of_isMaximal : ∀ {x y z}, IsMaximal x z → IsMaximal y z → x ≠ y → x ⊔ y = z\n  isMaximal_inf_left_of_isMaximal_sup :\n    ∀ {x y}, IsMaximal x (x ⊔ y) → IsMaximal y (x ⊔ y) → IsMaximal (x ⊓ y) x\n  Iso : X × X → X × X → Prop\n  iso_symm : ∀ {x y}, Iso x y → Iso y x\n  iso_trans : ∀ {x y z}, Iso x y → Iso y z → Iso x z\n  second_iso : ∀ {x y}, IsMaximal x (x ⊔ y) → Iso (x, x ⊔ y) (x ⊓ y, y)\n\n"}
{"name":"JordanHolderLattice.isMaximal_inf_left_of_isMaximal_sup","module":"Mathlib.Order.JordanHolder","initialProofState":"X : Type u\ninst✝ : Lattice X\nself : JordanHolderLattice X\nx y : X\na✝¹ : JordanHolderLattice.IsMaximal x (Max.max x y)\na✝ : JordanHolderLattice.IsMaximal y (Max.max x y)\n⊢ JordanHolderLattice.IsMaximal (Min.min x y) x","decl":"/-- A `JordanHolderLattice` is the class for which the Jordan Hölder theorem is proved. A\nJordan Hölder lattice is a lattice equipped with a notion of maximality, `IsMaximal`, and a notion\nof isomorphism of pairs `Iso`. In the example of subgroups of a group, `IsMaximal H K` means that\n`H` is a maximal normal subgroup of `K`, and `Iso (H₁, K₁) (H₂, K₂)` means that the quotient\n`H₁ / K₁` is isomorphic to the quotient `H₂ / K₂`. `Iso` must be symmetric and transitive and must\nsatisfy the second isomorphism theorem `Iso (H, H ⊔ K) (H ⊓ K, K)`.\nExamples include `Subgroup G` if `G` is a group, and `Submodule R M` if `M` is an `R`-module.\n-/\nclass JordanHolderLattice (X : Type u) [Lattice X] where\n  IsMaximal : X → X → Prop\n  lt_of_isMaximal : ∀ {x y}, IsMaximal x y → x < y\n  sup_eq_of_isMaximal : ∀ {x y z}, IsMaximal x z → IsMaximal y z → x ≠ y → x ⊔ y = z\n  isMaximal_inf_left_of_isMaximal_sup :\n    ∀ {x y}, IsMaximal x (x ⊔ y) → IsMaximal y (x ⊔ y) → IsMaximal (x ⊓ y) x\n  Iso : X × X → X × X → Prop\n  iso_symm : ∀ {x y}, Iso x y → Iso y x\n  iso_trans : ∀ {x y z}, Iso x y → Iso y z → Iso x z\n  second_iso : ∀ {x y}, IsMaximal x (x ⊔ y) → Iso (x, x ⊔ y) (x ⊓ y, y)\n\n"}
{"name":"JordanHolderLattice.sup_eq_of_isMaximal","module":"Mathlib.Order.JordanHolder","initialProofState":"X : Type u\ninst✝ : Lattice X\nself : JordanHolderLattice X\nx y z : X\na✝² : JordanHolderLattice.IsMaximal x z\na✝¹ : JordanHolderLattice.IsMaximal y z\na✝ : Ne x y\n⊢ Eq (Max.max x y) z","decl":"/-- A `JordanHolderLattice` is the class for which the Jordan Hölder theorem is proved. A\nJordan Hölder lattice is a lattice equipped with a notion of maximality, `IsMaximal`, and a notion\nof isomorphism of pairs `Iso`. In the example of subgroups of a group, `IsMaximal H K` means that\n`H` is a maximal normal subgroup of `K`, and `Iso (H₁, K₁) (H₂, K₂)` means that the quotient\n`H₁ / K₁` is isomorphic to the quotient `H₂ / K₂`. `Iso` must be symmetric and transitive and must\nsatisfy the second isomorphism theorem `Iso (H, H ⊔ K) (H ⊓ K, K)`.\nExamples include `Subgroup G` if `G` is a group, and `Submodule R M` if `M` is an `R`-module.\n-/\nclass JordanHolderLattice (X : Type u) [Lattice X] where\n  IsMaximal : X → X → Prop\n  lt_of_isMaximal : ∀ {x y}, IsMaximal x y → x < y\n  sup_eq_of_isMaximal : ∀ {x y z}, IsMaximal x z → IsMaximal y z → x ≠ y → x ⊔ y = z\n  isMaximal_inf_left_of_isMaximal_sup :\n    ∀ {x y}, IsMaximal x (x ⊔ y) → IsMaximal y (x ⊔ y) → IsMaximal (x ⊓ y) x\n  Iso : X × X → X × X → Prop\n  iso_symm : ∀ {x y}, Iso x y → Iso y x\n  iso_trans : ∀ {x y z}, Iso x y → Iso y z → Iso x z\n  second_iso : ∀ {x y}, IsMaximal x (x ⊔ y) → Iso (x, x ⊔ y) (x ⊓ y, y)\n\n"}
{"name":"JordanHolderLattice.iso_trans","module":"Mathlib.Order.JordanHolder","initialProofState":"X : Type u\ninst✝ : Lattice X\nself : JordanHolderLattice X\nx y z : Prod X X\na✝¹ : JordanHolderLattice.Iso x y\na✝ : JordanHolderLattice.Iso y z\n⊢ JordanHolderLattice.Iso x z","decl":"/-- A `JordanHolderLattice` is the class for which the Jordan Hölder theorem is proved. A\nJordan Hölder lattice is a lattice equipped with a notion of maximality, `IsMaximal`, and a notion\nof isomorphism of pairs `Iso`. In the example of subgroups of a group, `IsMaximal H K` means that\n`H` is a maximal normal subgroup of `K`, and `Iso (H₁, K₁) (H₂, K₂)` means that the quotient\n`H₁ / K₁` is isomorphic to the quotient `H₂ / K₂`. `Iso` must be symmetric and transitive and must\nsatisfy the second isomorphism theorem `Iso (H, H ⊔ K) (H ⊓ K, K)`.\nExamples include `Subgroup G` if `G` is a group, and `Submodule R M` if `M` is an `R`-module.\n-/\nclass JordanHolderLattice (X : Type u) [Lattice X] where\n  IsMaximal : X → X → Prop\n  lt_of_isMaximal : ∀ {x y}, IsMaximal x y → x < y\n  sup_eq_of_isMaximal : ∀ {x y z}, IsMaximal x z → IsMaximal y z → x ≠ y → x ⊔ y = z\n  isMaximal_inf_left_of_isMaximal_sup :\n    ∀ {x y}, IsMaximal x (x ⊔ y) → IsMaximal y (x ⊔ y) → IsMaximal (x ⊓ y) x\n  Iso : X × X → X × X → Prop\n  iso_symm : ∀ {x y}, Iso x y → Iso y x\n  iso_trans : ∀ {x y z}, Iso x y → Iso y z → Iso x z\n  second_iso : ∀ {x y}, IsMaximal x (x ⊔ y) → Iso (x, x ⊔ y) (x ⊓ y, y)\n\n"}
{"name":"JordanHolderLattice.isMaximal_inf_right_of_isMaximal_sup","module":"Mathlib.Order.JordanHolder","initialProofState":"X : Type u\ninst✝¹ : Lattice X\ninst✝ : JordanHolderLattice X\nx y : X\nhxz : JordanHolderLattice.IsMaximal x (Max.max x y)\nhyz : JordanHolderLattice.IsMaximal y (Max.max x y)\n⊢ JordanHolderLattice.IsMaximal (Min.min x y) y","decl":"theorem isMaximal_inf_right_of_isMaximal_sup {x y : X} (hxz : IsMaximal x (x ⊔ y))\n    (hyz : IsMaximal y (x ⊔ y)) : IsMaximal (x ⊓ y) y := by\n  rw [inf_comm]\n  rw [sup_comm] at hxz hyz\n  exact isMaximal_inf_left_of_isMaximal_sup hyz hxz\n\n"}
{"name":"JordanHolderLattice.isMaximal_of_eq_inf","module":"Mathlib.Order.JordanHolder","initialProofState":"X : Type u\ninst✝¹ : Lattice X\ninst✝ : JordanHolderLattice X\nx b a y : X\nha : Eq (Min.min x y) a\nhxy : Ne x y\nhxb : JordanHolderLattice.IsMaximal x b\nhyb : JordanHolderLattice.IsMaximal y b\n⊢ JordanHolderLattice.IsMaximal a y","decl":"theorem isMaximal_of_eq_inf (x b : X) {a y : X} (ha : x ⊓ y = a) (hxy : x ≠ y) (hxb : IsMaximal x b)\n    (hyb : IsMaximal y b) : IsMaximal a y := by\n  have hb : x ⊔ y = b := sup_eq_of_isMaximal hxb hyb hxy\n  substs a b\n  exact isMaximal_inf_right_of_isMaximal_sup hxb hyb\n\n"}
{"name":"JordanHolderLattice.second_iso_of_eq","module":"Mathlib.Order.JordanHolder","initialProofState":"X : Type u\ninst✝¹ : Lattice X\ninst✝ : JordanHolderLattice X\nx y a b : X\nhm : JordanHolderLattice.IsMaximal x a\nha : Eq (Max.max x y) a\nhb : Eq (Min.min x y) b\n⊢ JordanHolderLattice.Iso { fst := x, snd := a } { fst := b, snd := y }","decl":"theorem second_iso_of_eq {x y a b : X} (hm : IsMaximal x a) (ha : x ⊔ y = a) (hb : x ⊓ y = b) :\n    Iso (x, a) (b, y) := by substs a b; exact second_iso hm\n\n"}
{"name":"JordanHolderLattice.IsMaximal.iso_refl","module":"Mathlib.Order.JordanHolder","initialProofState":"X : Type u\ninst✝¹ : Lattice X\ninst✝ : JordanHolderLattice X\nx y : X\nh : JordanHolderLattice.IsMaximal x y\n⊢ JordanHolderLattice.Iso { fst := x, snd := y } { fst := x, snd := y }","decl":"theorem IsMaximal.iso_refl {x y : X} (h : IsMaximal x y) : Iso (x, y) (x, y) :=\n  second_iso_of_eq h (sup_eq_right.2 (le_of_lt (lt_of_isMaximal h)))\n    (inf_eq_left.2 (le_of_lt (lt_of_isMaximal h)))\n\n"}
{"name":"CompositionSeries.lt_succ","module":"Mathlib.Order.JordanHolder","initialProofState":"X : Type u\ninst✝¹ : Lattice X\ninst✝ : JordanHolderLattice X\ns : CompositionSeries X\ni : Fin s.length\n⊢ LT.lt (s.toFun i.castSucc) (s.toFun i.succ)","decl":"theorem lt_succ (s : CompositionSeries X) (i : Fin s.length) :\n    s (Fin.castSucc i) < s (Fin.succ i) :=\n  lt_of_isMaximal (s.step _)\n\n"}
{"name":"CompositionSeries.strictMono","module":"Mathlib.Order.JordanHolder","initialProofState":"X : Type u\ninst✝¹ : Lattice X\ninst✝ : JordanHolderLattice X\ns : CompositionSeries X\n⊢ StrictMono s.toFun","decl":"protected theorem strictMono (s : CompositionSeries X) : StrictMono s :=\n  Fin.strictMono_iff_lt_succ.2 s.lt_succ\n\n"}
{"name":"CompositionSeries.injective","module":"Mathlib.Order.JordanHolder","initialProofState":"X : Type u\ninst✝¹ : Lattice X\ninst✝ : JordanHolderLattice X\ns : CompositionSeries X\n⊢ Function.Injective s.toFun","decl":"protected theorem injective (s : CompositionSeries X) : Function.Injective s :=\n  s.strictMono.injective\n\n"}
{"name":"CompositionSeries.inj","module":"Mathlib.Order.JordanHolder","initialProofState":"X : Type u\ninst✝¹ : Lattice X\ninst✝ : JordanHolderLattice X\ns : CompositionSeries X\ni j : Fin s.length.succ\n⊢ Iff (Eq (s.toFun i) (s.toFun j)) (Eq i j)","decl":"@[simp]\nprotected theorem inj (s : CompositionSeries X) {i j : Fin s.length.succ} : s i = s j ↔ i = j :=\n  s.injective.eq_iff\n\n"}
{"name":"CompositionSeries.total","module":"Mathlib.Order.JordanHolder","initialProofState":"X : Type u\ninst✝¹ : Lattice X\ninst✝ : JordanHolderLattice X\ns : CompositionSeries X\nx y : X\nhx : Membership.mem s x\nhy : Membership.mem s y\n⊢ Or (LE.le x y) (LE.le y x)","decl":"theorem total {s : CompositionSeries X} {x y : X} (hx : x ∈ s) (hy : y ∈ s) : x ≤ y ∨ y ≤ x := by\n  rcases Set.mem_range.1 hx with ⟨i, rfl⟩\n  rcases Set.mem_range.1 hy with ⟨j, rfl⟩\n  rw [s.strictMono.le_iff_le, s.strictMono.le_iff_le]\n  exact le_total i j\n\n"}
{"name":"CompositionSeries.toList_sorted","module":"Mathlib.Order.JordanHolder","initialProofState":"X : Type u\ninst✝¹ : Lattice X\ninst✝ : JordanHolderLattice X\ns : CompositionSeries X\n⊢ List.Sorted (fun x1 x2 => LT.lt x1 x2) (RelSeries.toList s)","decl":"theorem toList_sorted (s : CompositionSeries X) : s.toList.Sorted (· < ·) :=\n  List.pairwise_iff_get.2 fun i j h => by\n    dsimp only [RelSeries.toList]\n    rw [List.get_ofFn, List.get_ofFn]\n    exact s.strictMono h\n\n"}
{"name":"CompositionSeries.toList_nodup","module":"Mathlib.Order.JordanHolder","initialProofState":"X : Type u\ninst✝¹ : Lattice X\ninst✝ : JordanHolderLattice X\ns : CompositionSeries X\n⊢ (RelSeries.toList s).Nodup","decl":"theorem toList_nodup (s : CompositionSeries X) : s.toList.Nodup :=\n  s.toList_sorted.nodup\n\n"}
{"name":"CompositionSeries.ext","module":"Mathlib.Order.JordanHolder","initialProofState":"X : Type u\ninst✝¹ : Lattice X\ninst✝ : JordanHolderLattice X\ns₁ s₂ : CompositionSeries X\nh : ∀ (x : X), Iff (Membership.mem s₁ x) (Membership.mem s₂ x)\n⊢ Eq s₁ s₂","decl":"/-- Two `CompositionSeries` are equal if they have the same elements. See also `ext_fun`. -/\n@[ext]\ntheorem ext {s₁ s₂ : CompositionSeries X} (h : ∀ x, x ∈ s₁ ↔ x ∈ s₂) : s₁ = s₂ :=\n  toList_injective <|\n    List.eq_of_perm_of_sorted\n      (by\n        classical\n        exact List.perm_of_nodup_nodup_toFinset_eq s₁.toList_nodup s₂.toList_nodup\n          (Finset.ext <| by simpa only [List.mem_toFinset, RelSeries.mem_toList]))\n      s₁.toList_sorted s₂.toList_sorted\n\n"}
{"name":"CompositionSeries.ext_iff","module":"Mathlib.Order.JordanHolder","initialProofState":"X : Type u\ninst✝¹ : Lattice X\ninst✝ : JordanHolderLattice X\ns₁ s₂ : CompositionSeries X\n⊢ Iff (Eq s₁ s₂) (∀ (x : X), Iff (Membership.mem s₁ x) (Membership.mem s₂ x))","decl":"/-- Two `CompositionSeries` are equal if they have the same elements. See also `ext_fun`. -/\n@[ext]\ntheorem ext {s₁ s₂ : CompositionSeries X} (h : ∀ x, x ∈ s₁ ↔ x ∈ s₂) : s₁ = s₂ :=\n  toList_injective <|\n    List.eq_of_perm_of_sorted\n      (by\n        classical\n        exact List.perm_of_nodup_nodup_toFinset_eq s₁.toList_nodup s₂.toList_nodup\n          (Finset.ext <| by simpa only [List.mem_toFinset, RelSeries.mem_toList]))\n      s₁.toList_sorted s₂.toList_sorted\n\n"}
{"name":"CompositionSeries.le_last","module":"Mathlib.Order.JordanHolder","initialProofState":"X : Type u\ninst✝¹ : Lattice X\ninst✝ : JordanHolderLattice X\ns : CompositionSeries X\ni : Fin (HAdd.hAdd s.length 1)\n⊢ LE.le (s.toFun i) (RelSeries.last s)","decl":"@[simp]\ntheorem le_last {s : CompositionSeries X} (i : Fin (s.length + 1)) : s i ≤ s.last :=\n  s.strictMono.monotone (Fin.le_last _)\n\n"}
{"name":"CompositionSeries.le_last_of_mem","module":"Mathlib.Order.JordanHolder","initialProofState":"X : Type u\ninst✝¹ : Lattice X\ninst✝ : JordanHolderLattice X\ns : CompositionSeries X\nx : X\nhx : Membership.mem s x\n⊢ LE.le x (RelSeries.last s)","decl":"theorem le_last_of_mem {s : CompositionSeries X} {x : X} (hx : x ∈ s) : x ≤ s.last :=\n  let ⟨_i, hi⟩ := Set.mem_range.2 hx\n  hi ▸ le_last _\n\n"}
{"name":"CompositionSeries.head_le","module":"Mathlib.Order.JordanHolder","initialProofState":"X : Type u\ninst✝¹ : Lattice X\ninst✝ : JordanHolderLattice X\ns : CompositionSeries X\ni : Fin (HAdd.hAdd s.length 1)\n⊢ LE.le (RelSeries.head s) (s.toFun i)","decl":"@[simp]\ntheorem head_le {s : CompositionSeries X} (i : Fin (s.length + 1)) : s.head ≤ s i :=\n  s.strictMono.monotone (Fin.zero_le _)\n\n"}
{"name":"CompositionSeries.head_le_of_mem","module":"Mathlib.Order.JordanHolder","initialProofState":"X : Type u\ninst✝¹ : Lattice X\ninst✝ : JordanHolderLattice X\ns : CompositionSeries X\nx : X\nhx : Membership.mem s x\n⊢ LE.le (RelSeries.head s) x","decl":"theorem head_le_of_mem {s : CompositionSeries X} {x : X} (hx : x ∈ s) : s.head ≤ x :=\n  let ⟨_i, hi⟩ := Set.mem_range.2 hx\n  hi ▸ head_le _\n\n"}
{"name":"CompositionSeries.last_eraseLast_le","module":"Mathlib.Order.JordanHolder","initialProofState":"X : Type u\ninst✝¹ : Lattice X\ninst✝ : JordanHolderLattice X\ns : CompositionSeries X\n⊢ LE.le (RelSeries.eraseLast s).last (RelSeries.last s)","decl":"theorem last_eraseLast_le (s : CompositionSeries X) : s.eraseLast.last ≤ s.last := by\n  simp [eraseLast, last, s.strictMono.le_iff_le, Fin.le_iff_val_le_val]\n\n"}
{"name":"CompositionSeries.mem_eraseLast_of_ne_of_mem","module":"Mathlib.Order.JordanHolder","initialProofState":"X : Type u\ninst✝¹ : Lattice X\ninst✝ : JordanHolderLattice X\ns : CompositionSeries X\nx : X\nhx : Ne x (RelSeries.last s)\nhxs : Membership.mem s x\n⊢ Membership.mem (RelSeries.eraseLast s) x","decl":"theorem mem_eraseLast_of_ne_of_mem {s : CompositionSeries X} {x : X}\n    (hx : x ≠ s.last) (hxs : x ∈ s) : x ∈ s.eraseLast := by\n  rcases hxs with ⟨i, rfl⟩\n  have hi : (i : ℕ) < (s.length - 1).succ := by\n    conv_rhs => rw [← Nat.succ_sub (length_pos_of_nontrivial ⟨_, ⟨i, rfl⟩, _, s.last_mem, hx⟩),\n      Nat.add_one_sub_one]\n    exact lt_of_le_of_ne (Nat.le_of_lt_succ i.2) (by simpa [last, s.inj, Fin.ext_iff] using hx)\n  refine ⟨Fin.castSucc (n := s.length + 1) i, ?_⟩\n  simp [Fin.ext_iff, Nat.mod_eq_of_lt hi]\n\n"}
{"name":"CompositionSeries.mem_eraseLast","module":"Mathlib.Order.JordanHolder","initialProofState":"X : Type u\ninst✝¹ : Lattice X\ninst✝ : JordanHolderLattice X\ns : CompositionSeries X\nx : X\nh : LT.lt 0 s.length\n⊢ Iff (Membership.mem (RelSeries.eraseLast s) x) (And (Ne x (RelSeries.last s)) (Membership.mem s x))","decl":"theorem mem_eraseLast {s : CompositionSeries X} {x : X} (h : 0 < s.length) :\n    x ∈ s.eraseLast ↔ x ≠ s.last ∧ x ∈ s := by\n  simp only [RelSeries.mem_def, eraseLast]\n  constructor\n  · rintro ⟨i, rfl⟩\n    have hi : (i : ℕ) < s.length := by\n      conv_rhs => rw [← Nat.add_one_sub_one s.length, Nat.succ_sub h]\n      exact i.2\n    -- Porting note (https://github.com/leanprover-community/mathlib4/issues/10745): was `simp [top, Fin.ext_iff, ne_of_lt hi]`.\n    simp [last, Fin.ext_iff, ne_of_lt hi, -Set.mem_range, Set.mem_range_self]\n  · intro h\n    exact mem_eraseLast_of_ne_of_mem h.1 h.2\n\n"}
{"name":"CompositionSeries.lt_last_of_mem_eraseLast","module":"Mathlib.Order.JordanHolder","initialProofState":"X : Type u\ninst✝¹ : Lattice X\ninst✝ : JordanHolderLattice X\ns : CompositionSeries X\nx : X\nh : LT.lt 0 s.length\nhx : Membership.mem (RelSeries.eraseLast s) x\n⊢ LT.lt x (RelSeries.last s)","decl":"theorem lt_last_of_mem_eraseLast {s : CompositionSeries X} {x : X} (h : 0 < s.length)\n    (hx : x ∈ s.eraseLast) : x < s.last :=\n  lt_of_le_of_ne (le_last_of_mem ((mem_eraseLast h).1 hx).2) ((mem_eraseLast h).1 hx).1\n\n"}
{"name":"CompositionSeries.isMaximal_eraseLast_last","module":"Mathlib.Order.JordanHolder","initialProofState":"X : Type u\ninst✝¹ : Lattice X\ninst✝ : JordanHolderLattice X\ns : CompositionSeries X\nh : LT.lt 0 s.length\n⊢ JordanHolderLattice.IsMaximal (RelSeries.eraseLast s).last (RelSeries.last s)","decl":"theorem isMaximal_eraseLast_last {s : CompositionSeries X} (h : 0 < s.length) :\n    IsMaximal s.eraseLast.last s.last := by\n  have : s.length - 1 + 1 = s.length := by\n    conv_rhs => rw [← Nat.add_one_sub_one s.length]; rw [Nat.succ_sub h]\n  rw [last_eraseLast, last]\n  convert s.step ⟨s.length - 1, by omega⟩; ext; simp [this]\n\n"}
{"name":"CompositionSeries.eq_snoc_eraseLast","module":"Mathlib.Order.JordanHolder","initialProofState":"X : Type u\ninst✝¹ : Lattice X\ninst✝ : JordanHolderLattice X\ns : CompositionSeries X\nh : LT.lt 0 s.length\n⊢ Eq s ((RelSeries.eraseLast s).snoc (RelSeries.last s) ⋯)","decl":"theorem eq_snoc_eraseLast {s : CompositionSeries X} (h : 0 < s.length) :\n    s = snoc (eraseLast s) s.last (isMaximal_eraseLast_last h) := by\n  ext x\n  simp only [mem_snoc, mem_eraseLast h, ne_eq]\n  by_cases h : x = s.last <;> simp [*, s.last_mem]\n\n"}
{"name":"CompositionSeries.snoc_eraseLast_last","module":"Mathlib.Order.JordanHolder","initialProofState":"X : Type u\ninst✝¹ : Lattice X\ninst✝ : JordanHolderLattice X\ns : CompositionSeries X\nh : JordanHolderLattice.IsMaximal (RelSeries.eraseLast s).last (RelSeries.last s)\n⊢ Eq ((RelSeries.eraseLast s).snoc (RelSeries.last s) h) s","decl":"@[simp]\ntheorem snoc_eraseLast_last {s : CompositionSeries X} (h : IsMaximal s.eraseLast.last s.last) :\n    s.eraseLast.snoc s.last h = s :=\n  have h : 0 < s.length :=\n    Nat.pos_of_ne_zero (fun hs => ne_of_gt (lt_of_isMaximal h) <| by simp [last, Fin.ext_iff, hs])\n  (eq_snoc_eraseLast h).symm\n\n"}
{"name":"CompositionSeries.Equivalent.refl","module":"Mathlib.Order.JordanHolder","initialProofState":"X : Type u\ninst✝¹ : Lattice X\ninst✝ : JordanHolderLattice X\ns : CompositionSeries X\n⊢ s.Equivalent s","decl":"@[refl]\ntheorem refl (s : CompositionSeries X) : Equivalent s s :=\n  ⟨Equiv.refl _, fun _ => (s.step _).iso_refl⟩\n\n"}
{"name":"CompositionSeries.Equivalent.symm","module":"Mathlib.Order.JordanHolder","initialProofState":"X : Type u\ninst✝¹ : Lattice X\ninst✝ : JordanHolderLattice X\ns₁ s₂ : CompositionSeries X\nh : s₁.Equivalent s₂\n⊢ s₂.Equivalent s₁","decl":"@[symm]\ntheorem symm {s₁ s₂ : CompositionSeries X} (h : Equivalent s₁ s₂) : Equivalent s₂ s₁ :=\n  ⟨h.choose.symm, fun i => iso_symm (by simpa using h.choose_spec (h.choose.symm i))⟩\n\n"}
{"name":"CompositionSeries.Equivalent.trans","module":"Mathlib.Order.JordanHolder","initialProofState":"X : Type u\ninst✝¹ : Lattice X\ninst✝ : JordanHolderLattice X\ns₁ s₂ s₃ : CompositionSeries X\nh₁ : s₁.Equivalent s₂\nh₂ : s₂.Equivalent s₃\n⊢ s₁.Equivalent s₃","decl":"@[trans]\ntheorem trans {s₁ s₂ s₃ : CompositionSeries X} (h₁ : Equivalent s₁ s₂) (h₂ : Equivalent s₂ s₃) :\n    Equivalent s₁ s₃ :=\n  ⟨h₁.choose.trans h₂.choose,\n    fun i => iso_trans (h₁.choose_spec i) (h₂.choose_spec (h₁.choose i))⟩\n\n"}
{"name":"CompositionSeries.Equivalent.smash","module":"Mathlib.Order.JordanHolder","initialProofState":"X : Type u\ninst✝¹ : Lattice X\ninst✝ : JordanHolderLattice X\ns₁ s₂ t₁ t₂ : CompositionSeries X\nhs : Eq (RelSeries.last s₁) (RelSeries.head s₂)\nht : Eq (RelSeries.last t₁) (RelSeries.head t₂)\nh₁ : s₁.Equivalent t₁\nh₂ : s₂.Equivalent t₂\n⊢ CompositionSeries.Equivalent (RelSeries.smash s₁ s₂ hs) (RelSeries.smash t₁ t₂ ht)","decl":"protected theorem smash {s₁ s₂ t₁ t₂ : CompositionSeries X}\n    (hs : s₁.last = s₂.head) (ht : t₁.last = t₂.head)\n    (h₁ : Equivalent s₁ t₁) (h₂ : Equivalent s₂ t₂) :\n    Equivalent (smash s₁ s₂ hs) (smash t₁ t₂ ht) :=\n  let e : Fin (s₁.length + s₂.length) ≃ Fin (t₁.length + t₂.length) :=\n    calc\n      Fin (s₁.length + s₂.length) ≃ (Fin s₁.length) ⊕ (Fin s₂.length) := finSumFinEquiv.symm\n      _ ≃ (Fin t₁.length) ⊕ (Fin t₂.length) := Equiv.sumCongr h₁.choose h₂.choose\n      _ ≃ Fin (t₁.length + t₂.length) := finSumFinEquiv\n  ⟨e, by\n    intro i\n    refine Fin.addCases ?_ ?_ i\n    · intro i\n      simpa [-smash_toFun, e, smash_castAdd, smash_succ_castAdd] using h₁.choose_spec i\n    · intro i\n      simpa [-smash_toFun, e, smash_natAdd, smash_succ_natAdd] using h₂.choose_spec i⟩\n\n"}
{"name":"CompositionSeries.Equivalent.snoc","module":"Mathlib.Order.JordanHolder","initialProofState":"X : Type u\ninst✝¹ : Lattice X\ninst✝ : JordanHolderLattice X\ns₁ s₂ : CompositionSeries X\nx₁ x₂ : X\nhsat₁ : JordanHolderLattice.IsMaximal (RelSeries.last s₁) x₁\nhsat₂ : JordanHolderLattice.IsMaximal (RelSeries.last s₂) x₂\nhequiv : s₁.Equivalent s₂\nhlast : JordanHolderLattice.Iso { fst := RelSeries.last s₁, snd := x₁ } { fst := RelSeries.last s₂, snd := x₂ }\n⊢ CompositionSeries.Equivalent (RelSeries.snoc s₁ x₁ hsat₁) (RelSeries.snoc s₂ x₂ hsat₂)","decl":"protected theorem snoc {s₁ s₂ : CompositionSeries X} {x₁ x₂ : X} {hsat₁ : IsMaximal s₁.last x₁}\n    {hsat₂ : IsMaximal s₂.last x₂} (hequiv : Equivalent s₁ s₂)\n    (hlast : Iso (s₁.last, x₁) (s₂.last, x₂)) : Equivalent (s₁.snoc x₁ hsat₁) (s₂.snoc x₂ hsat₂) :=\n  let e : Fin s₁.length.succ ≃ Fin s₂.length.succ :=\n    calc\n      Fin (s₁.length + 1) ≃ Option (Fin s₁.length) := finSuccEquivLast\n      _ ≃ Option (Fin s₂.length) := Functor.mapEquiv Option hequiv.choose\n      _ ≃ Fin (s₂.length + 1) := finSuccEquivLast.symm\n  ⟨e, fun i => by\n    refine Fin.lastCases ?_ ?_ i\n    · simpa [e, apply_last] using hlast\n    · intro i\n      simpa [e, Fin.succ_castSucc] using hequiv.choose_spec i⟩\n\n"}
{"name":"CompositionSeries.Equivalent.length_eq","module":"Mathlib.Order.JordanHolder","initialProofState":"X : Type u\ninst✝¹ : Lattice X\ninst✝ : JordanHolderLattice X\ns₁ s₂ : CompositionSeries X\nh : s₁.Equivalent s₂\n⊢ Eq s₁.length s₂.length","decl":"theorem length_eq {s₁ s₂ : CompositionSeries X} (h : Equivalent s₁ s₂) : s₁.length = s₂.length := by\n  simpa using Fintype.card_congr h.choose\n\n"}
{"name":"CompositionSeries.Equivalent.snoc_snoc_swap","module":"Mathlib.Order.JordanHolder","initialProofState":"X : Type u\ninst✝¹ : Lattice X\ninst✝ : JordanHolderLattice X\ns : CompositionSeries X\nx₁ x₂ y₁ y₂ : X\nhsat₁ : JordanHolderLattice.IsMaximal (RelSeries.last s) x₁\nhsat₂ : JordanHolderLattice.IsMaximal (RelSeries.last s) x₂\nhsaty₁ : JordanHolderLattice.IsMaximal (RelSeries.snoc s x₁ hsat₁).last y₁\nhsaty₂ : JordanHolderLattice.IsMaximal (RelSeries.snoc s x₂ hsat₂).last y₂\nhr₁ : JordanHolderLattice.Iso { fst := RelSeries.last s, snd := x₁ } { fst := x₂, snd := y₂ }\nhr₂ : JordanHolderLattice.Iso { fst := x₁, snd := y₁ } { fst := RelSeries.last s, snd := x₂ }\n⊢ CompositionSeries.Equivalent ((RelSeries.snoc s x₁ hsat₁).snoc y₁ hsaty₁) ((RelSeries.snoc s x₂ hsat₂).snoc y₂ hsaty₂)","decl":"theorem snoc_snoc_swap {s : CompositionSeries X} {x₁ x₂ y₁ y₂ : X} {hsat₁ : IsMaximal s.last x₁}\n    {hsat₂ : IsMaximal s.last x₂} {hsaty₁ : IsMaximal (snoc s x₁ hsat₁).last y₁}\n    {hsaty₂ : IsMaximal (snoc s x₂ hsat₂).last y₂} (hr₁ : Iso (s.last, x₁) (x₂, y₂))\n    (hr₂ : Iso (x₁, y₁) (s.last, x₂)) :\n    Equivalent (snoc (snoc s x₁ hsat₁) y₁ hsaty₁) (snoc (snoc s x₂ hsat₂) y₂ hsaty₂) :=\n  let e : Fin (s.length + 1 + 1) ≃ Fin (s.length + 1 + 1) :=\n    Equiv.swap (Fin.last _) (Fin.castSucc (Fin.last _))\n  have h1 : ∀ {i : Fin s.length},\n      (Fin.castSucc (Fin.castSucc i)) ≠ (Fin.castSucc (Fin.last _)) := fun {_} =>\n    ne_of_lt (by simp [Fin.castSucc_lt_last])\n  have h2 : ∀ {i : Fin s.length},\n      (Fin.castSucc (Fin.castSucc i)) ≠ Fin.last _ := fun {_} =>\n    ne_of_lt (by simp [Fin.castSucc_lt_last])\n  ⟨e, by\n    intro i\n    dsimp only [e]\n    refine Fin.lastCases ?_ (fun i => ?_) i\n    · erw [Equiv.swap_apply_left, snoc_castSucc,\n      show (snoc s x₁ hsat₁).toFun (Fin.last _) = x₁ from last_snoc _ _ _, Fin.succ_last,\n      show ((s.snoc x₁ hsat₁).snoc y₁ hsaty₁).toFun (Fin.last _) = y₁ from last_snoc _ _ _,\n      snoc_castSucc, snoc_castSucc, Fin.succ_castSucc, snoc_castSucc, Fin.succ_last,\n      show (s.snoc _ hsat₂).toFun (Fin.last _) = x₂ from last_snoc _ _ _]\n      exact hr₂\n    · refine Fin.lastCases ?_ (fun i => ?_) i\n      · erw [Equiv.swap_apply_right, snoc_castSucc, snoc_castSucc, snoc_castSucc,\n          Fin.succ_castSucc, snoc_castSucc, Fin.succ_last, last_snoc', last_snoc', last_snoc']\n        exact hr₁\n      · erw [Equiv.swap_apply_of_ne_of_ne h2 h1, snoc_castSucc, snoc_castSucc,\n          snoc_castSucc, snoc_castSucc, Fin.succ_castSucc, snoc_castSucc,\n          Fin.succ_castSucc, snoc_castSucc, snoc_castSucc, snoc_castSucc]\n        exact (s.step i).iso_refl⟩\n\n"}
{"name":"CompositionSeries.length_eq_zero_of_head_eq_head_of_last_eq_last_of_length_eq_zero","module":"Mathlib.Order.JordanHolder","initialProofState":"X : Type u\ninst✝¹ : Lattice X\ninst✝ : JordanHolderLattice X\ns₁ s₂ : CompositionSeries X\nhb : Eq (RelSeries.head s₁) (RelSeries.head s₂)\nht : Eq (RelSeries.last s₁) (RelSeries.last s₂)\nhs₁ : Eq s₁.length 0\n⊢ Eq s₂.length 0","decl":"theorem length_eq_zero_of_head_eq_head_of_last_eq_last_of_length_eq_zero\n    {s₁ s₂ : CompositionSeries X} (hb : s₁.head = s₂.head)\n    (ht : s₁.last = s₂.last) (hs₁ : s₁.length = 0) : s₂.length = 0 := by\n  have : Fin.last s₂.length = (0 : Fin s₂.length.succ) :=\n    s₂.injective (hb.symm.trans ((congr_arg s₁ (Fin.ext (by simp [hs₁]))).trans ht)).symm\n  simpa [Fin.ext_iff]\n\n"}
{"name":"CompositionSeries.length_pos_of_head_eq_head_of_last_eq_last_of_length_pos","module":"Mathlib.Order.JordanHolder","initialProofState":"X : Type u\ninst✝¹ : Lattice X\ninst✝ : JordanHolderLattice X\ns₁ s₂ : CompositionSeries X\nhb : Eq (RelSeries.head s₁) (RelSeries.head s₂)\nht : Eq (RelSeries.last s₁) (RelSeries.last s₂)\na✝ : LT.lt 0 s₁.length\n⊢ LT.lt 0 s₂.length","decl":"theorem length_pos_of_head_eq_head_of_last_eq_last_of_length_pos {s₁ s₂ : CompositionSeries X}\n    (hb : s₁.head = s₂.head) (ht : s₁.last = s₂.last) : 0 < s₁.length → 0 < s₂.length :=\n  not_imp_not.1\n    (by\n      simpa only [pos_iff_ne_zero, ne_eq, Decidable.not_not] using\n        length_eq_zero_of_head_eq_head_of_last_eq_last_of_length_eq_zero hb.symm ht.symm)\n\n"}
{"name":"CompositionSeries.eq_of_head_eq_head_of_last_eq_last_of_length_eq_zero","module":"Mathlib.Order.JordanHolder","initialProofState":"X : Type u\ninst✝¹ : Lattice X\ninst✝ : JordanHolderLattice X\ns₁ s₂ : CompositionSeries X\nhb : Eq (RelSeries.head s₁) (RelSeries.head s₂)\nht : Eq (RelSeries.last s₁) (RelSeries.last s₂)\nhs₁0 : Eq s₁.length 0\n⊢ Eq s₁ s₂","decl":"theorem eq_of_head_eq_head_of_last_eq_last_of_length_eq_zero {s₁ s₂ : CompositionSeries X}\n    (hb : s₁.head = s₂.head) (ht : s₁.last = s₂.last) (hs₁0 : s₁.length = 0) : s₁ = s₂ := by\n  have : ∀ x, x ∈ s₁ ↔ x = s₁.last := fun x =>\n    ⟨fun hx =>  subsingleton_of_length_eq_zero hs₁0 hx s₁.last_mem, fun hx => hx.symm ▸ s₁.last_mem⟩\n  have : ∀ x, x ∈ s₂ ↔ x = s₂.last := fun x =>\n    ⟨fun hx =>\n      subsingleton_of_length_eq_zero\n        (length_eq_zero_of_head_eq_head_of_last_eq_last_of_length_eq_zero hb ht\n          hs₁0) hx s₂.last_mem,\n      fun hx => hx.symm ▸ s₂.last_mem⟩\n  ext\n  simp [*]\n\n"}
{"name":"CompositionSeries.exists_last_eq_snoc_equivalent","module":"Mathlib.Order.JordanHolder","initialProofState":"X : Type u\ninst✝¹ : Lattice X\ninst✝ : JordanHolderLattice X\ns : CompositionSeries X\nx : X\nhm : JordanHolderLattice.IsMaximal x (RelSeries.last s)\nhb : LE.le (RelSeries.head s) x\n⊢ Exists fun t => And (Eq (RelSeries.head t) (RelSeries.head s)) (And (Eq (HAdd.hAdd t.length 1) s.length) (Exists fun htx => s.Equivalent (RelSeries.snoc t (RelSeries.last s) ⋯)))","decl":"/-- Given a `CompositionSeries`, `s`, and an element `x`\nsuch that `x` is maximal inside `s.last` there is a series, `t`,\nsuch that `t.last = x`, `t.head = s.head`\nand `snoc t s.last _` is equivalent to `s`. -/\ntheorem exists_last_eq_snoc_equivalent (s : CompositionSeries X) (x : X) (hm : IsMaximal x s.last)\n    (hb : s.head ≤ x) :\n    ∃ t : CompositionSeries X,\n      t.head = s.head ∧ t.length + 1 = s.length ∧\n      ∃ htx : t.last = x,\n        Equivalent s (snoc t s.last (show IsMaximal t.last _ from htx.symm ▸ hm)) := by\n  induction' hn : s.length with n ih generalizing s x\n  · exact\n      (ne_of_gt (lt_of_le_of_lt hb (lt_of_isMaximal hm))\n          (subsingleton_of_length_eq_zero hn s.last_mem s.head_mem)).elim\n  · have h0s : 0 < s.length := hn.symm ▸ Nat.succ_pos _\n    by_cases hetx : s.eraseLast.last = x\n    · use s.eraseLast\n      simp [← hetx, hn]\n      -- Porting note: `rfl` is required.\n      rfl\n    · have imxs : IsMaximal (x ⊓ s.eraseLast.last) s.eraseLast.last :=\n        isMaximal_of_eq_inf x s.last rfl (Ne.symm hetx) hm (isMaximal_eraseLast_last h0s)\n      have := ih _ _ imxs (le_inf (by simpa) (le_last_of_mem s.eraseLast.head_mem)) (by simp [hn])\n      rcases this with ⟨t, htb, htl, htt, hteqv⟩\n      have hmtx : IsMaximal t.last x :=\n        isMaximal_of_eq_inf s.eraseLast.last s.last (by rw [inf_comm, htt]) hetx\n          (isMaximal_eraseLast_last h0s) hm\n      use snoc t x hmtx\n      refine ⟨by simp [htb], by simp [htl], by simp, ?_⟩\n      have : s.Equivalent ((snoc t s.eraseLast.last <| show IsMaximal t.last _ from\n        htt.symm ▸ imxs).snoc s.last\n          (by simpa using isMaximal_eraseLast_last h0s)) := by\n        conv_lhs => rw [eq_snoc_eraseLast h0s]\n        exact Equivalent.snoc hteqv (by simpa using (isMaximal_eraseLast_last h0s).iso_refl)\n      refine this.trans <| Equivalent.snoc_snoc_swap\n        (iso_symm\n            (second_iso_of_eq hm\n              (sup_eq_of_isMaximal hm (isMaximal_eraseLast_last h0s) (Ne.symm hetx)) htt.symm))\n        (second_iso_of_eq (isMaximal_eraseLast_last h0s)\n            (sup_eq_of_isMaximal (isMaximal_eraseLast_last h0s) hm hetx) (by rw [inf_comm, htt]))\n\n"}
{"name":"CompositionSeries.jordan_holder","module":"Mathlib.Order.JordanHolder","initialProofState":"X : Type u\ninst✝¹ : Lattice X\ninst✝ : JordanHolderLattice X\ns₁ s₂ : CompositionSeries X\nhb : Eq (RelSeries.head s₁) (RelSeries.head s₂)\nht : Eq (RelSeries.last s₁) (RelSeries.last s₂)\n⊢ s₁.Equivalent s₂","decl":"/-- The **Jordan-Hölder** theorem, stated for any `JordanHolderLattice`.\nIf two composition series start and finish at the same place, they are equivalent. -/\ntheorem jordan_holder (s₁ s₂ : CompositionSeries X)\n    (hb : s₁.head = s₂.head) (ht : s₁.last = s₂.last) :\n    Equivalent s₁ s₂ := by\n  induction' hle : s₁.length with n ih generalizing s₁ s₂\n  · rw [eq_of_head_eq_head_of_last_eq_last_of_length_eq_zero hb ht hle]\n  · have h0s₂ : 0 < s₂.length :=\n      length_pos_of_head_eq_head_of_last_eq_last_of_length_pos hb ht (hle.symm ▸ Nat.succ_pos _)\n    rcases exists_last_eq_snoc_equivalent s₁ s₂.eraseLast.last\n        (ht.symm ▸ isMaximal_eraseLast_last h0s₂)\n        (hb.symm ▸ s₂.head_eraseLast ▸ head_le_of_mem (last_mem _)) with\n      ⟨t, htb, htl, htt, hteq⟩\n    have := ih t s₂.eraseLast (by simp [htb, ← hb]) htt (Nat.succ_inj'.1 (htl.trans hle))\n    refine hteq.trans ?_\n    conv_rhs => rw [eq_snoc_eraseLast h0s₂]\n    simp only [ht]\n    exact Equivalent.snoc this (by simpa [htt] using (isMaximal_eraseLast_last h0s₂).iso_refl)\n\n"}
