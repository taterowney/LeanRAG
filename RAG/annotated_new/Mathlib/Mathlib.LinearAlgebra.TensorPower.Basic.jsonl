{"name":"PiTensorProduct.gradedMonoid_eq_of_reindex_cast","module":"Mathlib.LinearAlgebra.TensorPower.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nιι : Type u_3\nι : ιι → Type u_4\na b : GradedMonoid fun ii => PiTensorProduct R fun x => M\nh : Eq a.fst b.fst\na✝ : Eq ((PiTensorProduct.reindex R (fun x => M) (Equiv.cast ⋯)) a.snd) b.snd\n⊢ Eq a b","decl":"/-- Two dependent pairs of tensor products are equal if their index is equal and the contents\nare equal after a canonical reindexing. -/\n@[ext (iff := false)]\ntheorem gradedMonoid_eq_of_reindex_cast {ιι : Type*} {ι : ιι → Type*} :\n    ∀ {a b : GradedMonoid fun ii => ⨂[R] _ : ι ii, M} (h : a.fst = b.fst),\n      reindex R (fun _ ↦ M) (Equiv.cast <| congr_arg ι h) a.snd = b.snd → a = b\n  | ⟨ai, a⟩, ⟨bi, b⟩ => fun (hi : ai = bi) (h : reindex R (fun _ ↦ M) _ a = b) => by\n    subst hi\n    simp_all\n\n"}
{"name":"TensorPower.gOne_def","module":"Mathlib.LinearAlgebra.TensorPower.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Eq GradedMonoid.GOne.one ((PiTensorProduct.tprod R) Fin.elim0)","decl":"theorem gOne_def : ₜ1 = tprod R (@Fin.elim0 M) :=\n  rfl\n\n"}
{"name":"TensorPower.gMul_def","module":"Mathlib.LinearAlgebra.TensorPower.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ni j : Nat\na : TensorPower R i M\nb : TensorPower R j M\n⊢ Eq (GradedMonoid.GMul.mul a b) (TensorPower.mulEquiv (TensorProduct.tmul R a b))","decl":"theorem gMul_def {i j} (a : ⨂[R]^i M) (b : (⨂[R]^j) M) :\n    a ₜ* b = @mulEquiv R M _ _ _ i j (a ⊗ₜ b) :=\n  rfl\n\n"}
{"name":"TensorPower.gMul_eq_coe_linearMap","module":"Mathlib.LinearAlgebra.TensorPower.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ni j : Nat\na : TensorPower R i M\nb : TensorPower R j M\n⊢ Eq (GradedMonoid.GMul.mul a b) ((((TensorProduct.mk R (TensorPower R i M) (TensorPower R j M)).compr₂ ↑TensorPower.mulEquiv) a) b)","decl":"theorem gMul_eq_coe_linearMap {i j} (a : ⨂[R]^i M) (b : (⨂[R]^j) M) :\n    a ₜ* b = ((TensorProduct.mk R _ _).compr₂ ↑(mulEquiv : _ ≃ₗ[R] (⨂[R]^(i + j)) M) :\n      ⨂[R]^i M →ₗ[R] (⨂[R]^j) M →ₗ[R] (⨂[R]^(i + j)) M) a b :=\n  rfl\n\n"}
{"name":"TensorPower.cast_tprod","module":"Mathlib.LinearAlgebra.TensorPower.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ni j : Nat\nh : Eq i j\na : Fin i → M\n⊢ Eq ((TensorPower.cast R M h) ((PiTensorProduct.tprod R) a)) ((PiTensorProduct.tprod R) (Function.comp a (Fin.cast ⋯)))","decl":"theorem cast_tprod {i j} (h : i = j) (a : Fin i → M) :\n    cast R M h (tprod R a) = tprod R (a ∘ Fin.cast h.symm) :=\n  reindex_tprod _ _\n\n"}
{"name":"TensorPower.cast_refl","module":"Mathlib.LinearAlgebra.TensorPower.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ni : Nat\nh : Eq i i\n⊢ Eq (TensorPower.cast R M h) (LinearEquiv.refl R (TensorPower R i M))","decl":"@[simp]\ntheorem cast_refl {i} (h : i = i) : cast R M h = LinearEquiv.refl _ _ :=\n  (congr_arg (reindex R fun _ ↦ M) <| finCongr_refl h).trans reindex_refl\n\n"}
{"name":"TensorPower.cast_symm","module":"Mathlib.LinearAlgebra.TensorPower.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ni j : Nat\nh : Eq i j\n⊢ Eq (TensorPower.cast R M h).symm (TensorPower.cast R M ⋯)","decl":"@[simp]\ntheorem cast_symm {i j} (h : i = j) : (cast R M h).symm = cast R M h.symm :=\n  reindex_symm _\n\n"}
{"name":"TensorPower.cast_trans","module":"Mathlib.LinearAlgebra.TensorPower.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ni j k : Nat\nh : Eq i j\nh' : Eq j k\n⊢ Eq ((TensorPower.cast R M h).trans (TensorPower.cast R M h')) (TensorPower.cast R M ⋯)","decl":"@[simp]\ntheorem cast_trans {i j k} (h : i = j) (h' : j = k) :\n    (cast R M h).trans (cast R M h') = cast R M (h.trans h') :=\n  reindex_trans _ _\n\n"}
{"name":"TensorPower.cast_cast","module":"Mathlib.LinearAlgebra.TensorPower.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ni j k : Nat\nh : Eq i j\nh' : Eq j k\na : TensorPower R i M\n⊢ Eq ((TensorPower.cast R M h') ((TensorPower.cast R M h) a)) ((TensorPower.cast R M ⋯) a)","decl":"@[simp]\ntheorem cast_cast {i j k} (h : i = j) (h' : j = k) (a : ⨂[R]^i M) :\n    cast R M h' (cast R M h a) = cast R M (h.trans h') a :=\n  reindex_reindex _ _ _\n\n"}
{"name":"TensorPower.gradedMonoid_eq_of_cast","module":"Mathlib.LinearAlgebra.TensorPower.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\na b : GradedMonoid fun n => PiTensorProduct R fun x => M\nh : Eq a.fst b.fst\nh2 : Eq ((TensorPower.cast R M h) a.snd) b.snd\n⊢ Eq a b","decl":"@[ext (iff := false)]\ntheorem gradedMonoid_eq_of_cast {a b : GradedMonoid fun n => ⨂[R] _ : Fin n, M} (h : a.fst = b.fst)\n    (h2 : cast R M h a.snd = b.snd) : a = b := by\n  refine gradedMonoid_eq_of_reindex_cast h ?_\n  rw [cast] at h2\n  rw [← finCongr_eq_equivCast, ← h2]\n\n"}
{"name":"TensorPower.cast_eq_cast","module":"Mathlib.LinearAlgebra.TensorPower.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ni j : Nat\nh : Eq i j\n⊢ Eq (⇑(TensorPower.cast R M h)) (cast ⋯)","decl":"theorem cast_eq_cast {i j} (h : i = j) :\n    ⇑(cast R M h) = _root_.cast (congrArg (fun i => ⨂[R]^i M) h) := by\n  subst h\n  rw [cast_refl]\n  rfl\n\n"}
{"name":"TensorPower.tprod_mul_tprod","module":"Mathlib.LinearAlgebra.TensorPower.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nna nb : Nat\na : Fin na → M\nb : Fin nb → M\n⊢ Eq (GradedMonoid.GMul.mul ((PiTensorProduct.tprod R) a) ((PiTensorProduct.tprod R) b)) ((PiTensorProduct.tprod R) (Fin.append a b))","decl":"theorem tprod_mul_tprod {na nb} (a : Fin na → M) (b : Fin nb → M) :\n    tprod R a ₜ* tprod R b = tprod R (Fin.append a b) := by\n  dsimp [gMul_def, mulEquiv]\n  rw [tmulEquiv_apply R M a b]\n  refine (reindex_tprod _ _).trans ?_\n  congr 1\n  dsimp only [Fin.append, finSumFinEquiv, Equiv.coe_fn_symm_mk]\n  apply funext\n  apply Fin.addCases <;> simp\n\n"}
{"name":"TensorPower.one_mul","module":"Mathlib.LinearAlgebra.TensorPower.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nn : Nat\na : TensorPower R n M\n⊢ Eq ((TensorPower.cast R M ⋯) (GradedMonoid.GMul.mul GradedMonoid.GOne.one a)) a","decl":"theorem one_mul {n} (a : ⨂[R]^n M) : cast R M (zero_add n) (ₜ1 ₜ* a) = a := by\n  rw [gMul_def, gOne_def]\n  induction a using PiTensorProduct.induction_on with\n  | smul_tprod r a =>\n    rw [TensorProduct.tmul_smul, LinearEquiv.map_smul, LinearEquiv.map_smul, ← gMul_def,\n      tprod_mul_tprod, cast_tprod]\n    congr 2 with i\n    rw [Fin.elim0_append]\n    refine congr_arg a (Fin.ext ?_)\n    simp\n  | add x y hx hy =>\n    rw [TensorProduct.tmul_add, map_add, map_add, hx, hy]\n\n"}
{"name":"TensorPower.mul_one","module":"Mathlib.LinearAlgebra.TensorPower.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nn : Nat\na : TensorPower R n M\n⊢ Eq ((TensorPower.cast R M ⋯) (GradedMonoid.GMul.mul a GradedMonoid.GOne.one)) a","decl":"theorem mul_one {n} (a : ⨂[R]^n M) : cast R M (add_zero _) (a ₜ* ₜ1) = a := by\n  rw [gMul_def, gOne_def]\n  induction a using PiTensorProduct.induction_on with\n  | smul_tprod r a =>\n    rw [← TensorProduct.smul_tmul', LinearEquiv.map_smul, LinearEquiv.map_smul, ← gMul_def,\n      tprod_mul_tprod R a _, cast_tprod]\n    congr 2 with i\n    rw [Fin.append_elim0]\n    refine congr_arg a (Fin.ext ?_)\n    simp\n  | add x y hx hy =>\n    rw [TensorProduct.add_tmul, map_add, map_add, hx, hy]\n\n"}
{"name":"TensorPower.mul_assoc","module":"Mathlib.LinearAlgebra.TensorPower.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nna nb nc : Nat\na : TensorPower R na M\nb : TensorPower R nb M\nc : TensorPower R nc M\n⊢ Eq ((TensorPower.cast R M ⋯) (GradedMonoid.GMul.mul (GradedMonoid.GMul.mul a b) c)) (GradedMonoid.GMul.mul a (GradedMonoid.GMul.mul b c))","decl":"theorem mul_assoc {na nb nc} (a : (⨂[R]^na) M) (b : (⨂[R]^nb) M) (c : (⨂[R]^nc) M) :\n    cast R M (add_assoc _ _ _) (a ₜ* b ₜ* c) = a ₜ* (b ₜ* c) := by\n  let mul : ∀ n m : ℕ, ⨂[R]^n M →ₗ[R] (⨂[R]^m) M →ₗ[R] (⨂[R]^(n + m)) M := fun n m =>\n    (TensorProduct.mk R _ _).compr₂ ↑(mulEquiv : _ ≃ₗ[R] (⨂[R]^(n + m)) M)\n  -- replace `a`, `b`, `c` with `tprod R a`, `tprod R b`, `tprod R c`\n  let e : (⨂[R]^(na + nb + nc)) M ≃ₗ[R] (⨂[R]^(na + (nb + nc))) M := cast R M (add_assoc _ _ _)\n  let lhs : (⨂[R]^na) M →ₗ[R] (⨂[R]^nb) M →ₗ[R] (⨂[R]^nc) M →ₗ[R] (⨂[R]^(na + (nb + nc))) M :=\n    (LinearMap.llcomp R _ _ _ ((mul _ nc).compr₂ e.toLinearMap)).comp (mul na nb)\n  have lhs_eq : ∀ a b c, lhs a b c = e (a ₜ* b ₜ* c) := fun _ _ _ => rfl\n  let rhs : (⨂[R]^na) M →ₗ[R] (⨂[R]^nb) M →ₗ[R] (⨂[R]^nc) M →ₗ[R] (⨂[R]^(na + (nb + nc))) M :=\n    (LinearMap.llcomp R _ _ _ (LinearMap.lflip (R := R)) <|\n        (LinearMap.llcomp R _ _ _ (mul na _).flip).comp (mul nb nc)).flip\n  have rhs_eq : ∀ a b c, rhs a b c = a ₜ* (b ₜ* c) := fun _ _ _ => rfl\n  suffices lhs = rhs from\n    LinearMap.congr_fun (LinearMap.congr_fun (LinearMap.congr_fun this a) b) c\n  ext a b c\n  -- clean up\n  simp only [e, LinearMap.compMultilinearMap_apply, lhs_eq, rhs_eq, tprod_mul_tprod, cast_tprod]\n  congr with j\n  rw [Fin.append_assoc]\n  refine congr_arg (Fin.append a (Fin.append b c)) (Fin.ext ?_)\n  rw [Fin.coe_cast, Fin.coe_cast]\n\n-- for now we just use the default for the `gnpow` field as it's easier.\n"}
{"name":"TensorPower.algebraMap₀_eq_smul_one","module":"Mathlib.LinearAlgebra.TensorPower.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nr : R\n⊢ Eq (TensorPower.algebraMap₀ r) (HSMul.hSMul r GradedMonoid.GOne.one)","decl":"theorem algebraMap₀_eq_smul_one (r : R) : (algebraMap₀ r : (⨂[R]^0) M) = r • ₜ1 := by\n  simp [algebraMap₀]; congr\n\n"}
{"name":"TensorPower.algebraMap₀_one","module":"Mathlib.LinearAlgebra.TensorPower.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Eq (TensorPower.algebraMap₀ 1) GradedMonoid.GOne.one","decl":"theorem algebraMap₀_one : (algebraMap₀ 1 : (⨂[R]^0) M) = ₜ1 :=\n  (algebraMap₀_eq_smul_one 1).trans (one_smul _ _)\n\n"}
{"name":"TensorPower.algebraMap₀_mul","module":"Mathlib.LinearAlgebra.TensorPower.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nn : Nat\nr : R\na : TensorPower R n M\n⊢ Eq ((TensorPower.cast R M ⋯) (GradedMonoid.GMul.mul (TensorPower.algebraMap₀ r) a)) (HSMul.hSMul r a)","decl":"theorem algebraMap₀_mul {n} (r : R) (a : ⨂[R]^n M) :\n    cast R M (zero_add _) (algebraMap₀ r ₜ* a) = r • a := by\n  rw [gMul_eq_coe_linearMap, algebraMap₀_eq_smul_one, LinearMap.map_smul₂,\n    LinearEquiv.map_smul, ← gMul_eq_coe_linearMap, one_mul]\n\n"}
{"name":"TensorPower.mul_algebraMap₀","module":"Mathlib.LinearAlgebra.TensorPower.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nn : Nat\nr : R\na : TensorPower R n M\n⊢ Eq ((TensorPower.cast R M ⋯) (GradedMonoid.GMul.mul a (TensorPower.algebraMap₀ r))) (HSMul.hSMul r a)","decl":"theorem mul_algebraMap₀ {n} (r : R) (a : ⨂[R]^n M) :\n    cast R M (add_zero _) (a ₜ* algebraMap₀ r) = r • a := by\n  rw [gMul_eq_coe_linearMap, algebraMap₀_eq_smul_one, LinearMap.map_smul,\n    LinearEquiv.map_smul, ← gMul_eq_coe_linearMap, mul_one]\n\n"}
{"name":"TensorPower.algebraMap₀_mul_algebraMap₀","module":"Mathlib.LinearAlgebra.TensorPower.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nr s : R\n⊢ Eq ((TensorPower.cast R M ⋯) (GradedMonoid.GMul.mul (TensorPower.algebraMap₀ r) (TensorPower.algebraMap₀ s))) (TensorPower.algebraMap₀ (HMul.hMul r s))","decl":"theorem algebraMap₀_mul_algebraMap₀ (r s : R) :\n    cast R M (add_zero _) (algebraMap₀ r ₜ* algebraMap₀ s) = algebraMap₀ (r * s) := by\n  rw [← smul_eq_mul, LinearEquiv.map_smul]\n  exact algebraMap₀_mul r (@algebraMap₀ R M _ _ _ s)\n\n"}
{"name":"TensorPower.galgebra_toFun_def","module":"Mathlib.LinearAlgebra.TensorPower.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nr : R\n⊢ Eq (DirectSum.GAlgebra.toFun r) (TensorPower.algebraMap₀ r)","decl":"theorem galgebra_toFun_def (r : R) :\n    DirectSum.GAlgebra.toFun (A := fun i ↦ ⨂[R]^i M) r = algebraMap₀ r :=\n  rfl\n\n"}
