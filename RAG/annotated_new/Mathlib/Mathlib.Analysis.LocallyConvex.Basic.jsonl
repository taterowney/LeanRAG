{"name":"absorbs_iff_norm","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝¹ : SeminormedRing 𝕜\ninst✝ : SMul 𝕜 E\nA B : Set E\n⊢ Iff (Absorbs 𝕜 A B) (Exists fun r => ∀ (c : 𝕜), LE.le r (Norm.norm c) → HasSubset.Subset B (HSMul.hSMul c A))","decl":"lemma absorbs_iff_norm : Absorbs 𝕜 A B ↔ ∃ r, ∀ c : 𝕜, r ≤ ‖c‖ → B ⊆ c • A :=\n  Filter.atTop_basis.cobounded_of_norm.eventually_iff.trans <| by simp only [true_and]; rfl\n\n"}
{"name":"Absorbs.of_norm","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝¹ : SeminormedRing 𝕜\ninst✝ : SMul 𝕜 E\nA B : Set E\na✝ : Exists fun r => ∀ (c : 𝕜), LE.le r (Norm.norm c) → HasSubset.Subset B (HSMul.hSMul c A)\n⊢ Absorbs 𝕜 A B","decl":"alias ⟨_, Absorbs.of_norm⟩ := absorbs_iff_norm\n\n"}
{"name":"Absorbs.exists_pos","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝¹ : SeminormedRing 𝕜\ninst✝ : SMul 𝕜 E\nA B : Set E\nh : Absorbs 𝕜 A B\n⊢ Exists fun r => And (GT.gt r 0) (∀ (c : 𝕜), LE.le r (Norm.norm c) → HasSubset.Subset B (HSMul.hSMul c A))","decl":"lemma Absorbs.exists_pos (h : Absorbs 𝕜 A B) : ∃ r > 0, ∀ c : 𝕜, r ≤ ‖c‖ → B ⊆ c • A :=\n  let ⟨r, hr₁, hr⟩ := (Filter.atTop_basis' 1).cobounded_of_norm.eventually_iff.1 h\n  ⟨r, one_pos.trans_le hr₁, hr⟩\n\n"}
{"name":"balanced_iff_smul_mem","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝¹ : SeminormedRing 𝕜\ninst✝ : SMul 𝕜 E\ns : Set E\n⊢ Iff (Balanced 𝕜 s) (∀ ⦃a : 𝕜⦄, LE.le (Norm.norm a) 1 → ∀ ⦃x : E⦄, Membership.mem s x → Membership.mem s (HSMul.hSMul a x))","decl":"theorem balanced_iff_smul_mem : Balanced 𝕜 s ↔ ∀ ⦃a : 𝕜⦄, ‖a‖ ≤ 1 → ∀ ⦃x : E⦄, x ∈ s → a • x ∈ s :=\n  forall₂_congr fun _a _ha => smul_set_subset_iff\n\n"}
{"name":"Balanced.smul_mem","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝¹ : SeminormedRing 𝕜\ninst✝ : SMul 𝕜 E\ns : Set E\na✝² : Balanced 𝕜 s\na : 𝕜\na✝¹ : LE.le (Norm.norm a) 1\nx : E\na✝ : Membership.mem s x\n⊢ Membership.mem s (HSMul.hSMul a x)","decl":"alias ⟨Balanced.smul_mem, _⟩ := balanced_iff_smul_mem\n\n"}
{"name":"balanced_iff_closedBall_smul","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝¹ : SeminormedRing 𝕜\ninst✝ : SMul 𝕜 E\ns : Set E\n⊢ Iff (Balanced 𝕜 s) (HasSubset.Subset (HSMul.hSMul (Metric.closedBall 0 1) s) s)","decl":"theorem balanced_iff_closedBall_smul : Balanced 𝕜 s ↔ Metric.closedBall (0 : 𝕜) 1 • s ⊆ s := by\n  simp [balanced_iff_smul_mem, smul_subset_iff]\n\n"}
{"name":"balanced_empty","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝¹ : SeminormedRing 𝕜\ninst✝ : SMul 𝕜 E\n⊢ Balanced 𝕜 EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem balanced_empty : Balanced 𝕜 (∅ : Set E) := fun _ _ => by rw [smul_set_empty]\n\n"}
{"name":"balanced_univ","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝¹ : SeminormedRing 𝕜\ninst✝ : SMul 𝕜 E\n⊢ Balanced 𝕜 Set.univ","decl":"@[simp]\ntheorem balanced_univ : Balanced 𝕜 (univ : Set E) := fun _a _ha => subset_univ _\n\n"}
{"name":"Balanced.union","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝¹ : SeminormedRing 𝕜\ninst✝ : SMul 𝕜 E\nA B : Set E\nhA : Balanced 𝕜 A\nhB : Balanced 𝕜 B\n⊢ Balanced 𝕜 (Union.union A B)","decl":"theorem Balanced.union (hA : Balanced 𝕜 A) (hB : Balanced 𝕜 B) : Balanced 𝕜 (A ∪ B) := fun _a ha =>\n  smul_set_union.subset.trans <| union_subset_union (hA _ ha) <| hB _ ha\n\n"}
{"name":"Balanced.inter","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝¹ : SeminormedRing 𝕜\ninst✝ : SMul 𝕜 E\nA B : Set E\nhA : Balanced 𝕜 A\nhB : Balanced 𝕜 B\n⊢ Balanced 𝕜 (Inter.inter A B)","decl":"theorem Balanced.inter (hA : Balanced 𝕜 A) (hB : Balanced 𝕜 B) : Balanced 𝕜 (A ∩ B) := fun _a ha =>\n  smul_set_inter_subset.trans <| inter_subset_inter (hA _ ha) <| hB _ ha\n\n"}
{"name":"balanced_iUnion","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_3\nι : Sort u_4\ninst✝¹ : SeminormedRing 𝕜\ninst✝ : SMul 𝕜 E\nf : ι → Set E\nh : ∀ (i : ι), Balanced 𝕜 (f i)\n⊢ Balanced 𝕜 (Set.iUnion fun i => f i)","decl":"theorem balanced_iUnion {f : ι → Set E} (h : ∀ i, Balanced 𝕜 (f i)) : Balanced 𝕜 (⋃ i, f i) :=\n  fun _a ha => (smul_set_iUnion _ _).subset.trans <| iUnion_mono fun _ => h _ _ ha\n\n"}
{"name":"balanced_iUnion₂","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_3\nι : Sort u_4\nκ : ι → Sort u_5\ninst✝¹ : SeminormedRing 𝕜\ninst✝ : SMul 𝕜 E\nf : (i : ι) → κ i → Set E\nh : ∀ (i : ι) (j : κ i), Balanced 𝕜 (f i j)\n⊢ Balanced 𝕜 (Set.iUnion fun i => Set.iUnion fun j => f i j)","decl":"theorem balanced_iUnion₂ {f : ∀ i, κ i → Set E} (h : ∀ i j, Balanced 𝕜 (f i j)) :\n    Balanced 𝕜 (⋃ (i) (j), f i j) :=\n  balanced_iUnion fun _ => balanced_iUnion <| h _\n\n"}
{"name":"Balanced.sInter","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝¹ : SeminormedRing 𝕜\ninst✝ : SMul 𝕜 E\nS : Set (Set E)\nh : ∀ (s : Set E), Membership.mem S s → Balanced 𝕜 s\n⊢ Balanced 𝕜 S.sInter","decl":"theorem Balanced.sInter {S : Set (Set E)} (h : ∀ s ∈ S, Balanced 𝕜 s) : Balanced 𝕜 (⋂₀ S) :=\n  fun _ _ => (smul_set_sInter_subset ..).trans (fun _ _ => by aesop)\n\n"}
{"name":"balanced_iInter","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_3\nι : Sort u_4\ninst✝¹ : SeminormedRing 𝕜\ninst✝ : SMul 𝕜 E\nf : ι → Set E\nh : ∀ (i : ι), Balanced 𝕜 (f i)\n⊢ Balanced 𝕜 (Set.iInter fun i => f i)","decl":"theorem balanced_iInter {f : ι → Set E} (h : ∀ i, Balanced 𝕜 (f i)) : Balanced 𝕜 (⋂ i, f i) :=\n  fun _a ha => (smul_set_iInter_subset _ _).trans <| iInter_mono fun _ => h _ _ ha\n\n"}
{"name":"balanced_iInter₂","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_3\nι : Sort u_4\nκ : ι → Sort u_5\ninst✝¹ : SeminormedRing 𝕜\ninst✝ : SMul 𝕜 E\nf : (i : ι) → κ i → Set E\nh : ∀ (i : ι) (j : κ i), Balanced 𝕜 (f i j)\n⊢ Balanced 𝕜 (Set.iInter fun i => Set.iInter fun j => f i j)","decl":"theorem balanced_iInter₂ {f : ∀ i, κ i → Set E} (h : ∀ i j, Balanced 𝕜 (f i j)) :\n    Balanced 𝕜 (⋂ (i) (j), f i j) :=\n  balanced_iInter fun _ => balanced_iInter <| h _\n\n"}
{"name":"Balanced.smul","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"𝕜 : Type u_1\n𝕝 : Type u_2\nE : Type u_3\ninst✝³ : SeminormedRing 𝕜\ninst✝² : SMul 𝕜 E\ns : Set E\ninst✝¹ : SMul 𝕝 E\ninst✝ : SMulCommClass 𝕜 𝕝 E\na : 𝕝\nhs : Balanced 𝕜 s\n⊢ Balanced 𝕜 (HSMul.hSMul a s)","decl":"theorem Balanced.smul (a : 𝕝) (hs : Balanced 𝕜 s) : Balanced 𝕜 (a • s) := fun _b hb =>\n  (smul_comm _ _ _).subset.trans <| smul_set_mono <| hs _ hb\n\n"}
{"name":"Balanced.neg","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\ns : Set E\na✝ : Balanced 𝕜 s\n⊢ Balanced 𝕜 (Neg.neg s)","decl":"theorem Balanced.neg : Balanced 𝕜 s → Balanced 𝕜 (-s) :=\n  forall₂_imp fun _ _ h => (smul_set_neg _ _).subset.trans <| neg_subset_neg.2 h\n\n"}
{"name":"balanced_neg","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\ns : Set E\n⊢ Iff (Balanced 𝕜 (Neg.neg s)) (Balanced 𝕜 s)","decl":"@[simp]\ntheorem balanced_neg : Balanced 𝕜 (-s) ↔ Balanced 𝕜 s :=\n  ⟨fun h ↦ neg_neg s ▸ h.neg, fun h ↦ h.neg⟩\n\n"}
{"name":"Balanced.neg_mem_iff","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝³ : SeminormedRing 𝕜\ninst✝² : AddCommGroup E\ninst✝¹ : Module 𝕜 E\ns : Set E\ninst✝ : NormOneClass 𝕜\nh : Balanced 𝕜 s\nx : E\n⊢ Iff (Membership.mem s (Neg.neg x)) (Membership.mem s x)","decl":"theorem Balanced.neg_mem_iff [NormOneClass 𝕜] (h : Balanced 𝕜 s) {x : E} : -x ∈ s ↔ x ∈ s :=\n  ⟨fun hx ↦ by simpa using h.smul_mem (a := -1) (by simp) hx,\n    fun hx ↦ by simpa using h.smul_mem (a := -1) (by simp) hx⟩\n\n"}
{"name":"Balanced.neg_eq","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝³ : SeminormedRing 𝕜\ninst✝² : AddCommGroup E\ninst✝¹ : Module 𝕜 E\ns : Set E\ninst✝ : NormOneClass 𝕜\nh : Balanced 𝕜 s\n⊢ Eq (Neg.neg s) s","decl":"theorem Balanced.neg_eq [NormOneClass 𝕜] (h : Balanced 𝕜 s) : -s = s :=\n  Set.ext fun _ ↦ h.neg_mem_iff\n\n"}
{"name":"Balanced.add","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\ns t : Set E\nhs : Balanced 𝕜 s\nht : Balanced 𝕜 t\n⊢ Balanced 𝕜 (HAdd.hAdd s t)","decl":"theorem Balanced.add (hs : Balanced 𝕜 s) (ht : Balanced 𝕜 t) : Balanced 𝕜 (s + t) := fun _a ha =>\n  (smul_add _ _ _).subset.trans <| add_subset_add (hs _ ha) <| ht _ ha\n\n"}
{"name":"Balanced.sub","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\ns t : Set E\nhs : Balanced 𝕜 s\nht : Balanced 𝕜 t\n⊢ Balanced 𝕜 (HSub.hSub s t)","decl":"theorem Balanced.sub (hs : Balanced 𝕜 s) (ht : Balanced 𝕜 t) : Balanced 𝕜 (s - t) := by\n  simp_rw [sub_eq_add_neg]\n  exact hs.add ht.neg\n\n"}
{"name":"balanced_zero","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\n⊢ Balanced 𝕜 0","decl":"theorem balanced_zero : Balanced 𝕜 (0 : Set E) := fun _a _ha => (smul_zero _).subset\n\n"}
{"name":"absorbs_iff_eventually_nhdsWithin_zero","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝² : NormedDivisionRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\ns t : Set E\n⊢ Iff (Absorbs 𝕜 s t) (Filter.Eventually (fun c => Set.MapsTo (fun x => HSMul.hSMul c x) t s) (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0))))","decl":"theorem absorbs_iff_eventually_nhdsWithin_zero :\n    Absorbs 𝕜 s t ↔ ∀ᶠ c : 𝕜 in 𝓝[≠] 0, MapsTo (c • ·) t s := by\n  rw [absorbs_iff_eventually_cobounded_mapsTo, ← Filter.inv_cobounded₀]; rfl\n\n"}
{"name":"Absorbs.eventually_nhdsWithin_zero","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝² : NormedDivisionRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\ns t : Set E\na✝ : Absorbs 𝕜 s t\n⊢ Filter.Eventually (fun c => Set.MapsTo (fun x => HSMul.hSMul c x) t s) (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0)))","decl":"alias ⟨Absorbs.eventually_nhdsWithin_zero, _⟩ := absorbs_iff_eventually_nhdsWithin_zero\n\n"}
{"name":"absorbent_iff_eventually_nhdsWithin_zero","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝² : NormedDivisionRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\ns : Set E\n⊢ Iff (Absorbent 𝕜 s) (∀ (x : E), Filter.Eventually (fun c => Membership.mem s (HSMul.hSMul c x)) (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0))))","decl":"theorem absorbent_iff_eventually_nhdsWithin_zero :\n    Absorbent 𝕜 s ↔ ∀ x : E, ∀ᶠ c : 𝕜 in 𝓝[≠] 0, c • x ∈ s :=\n  forall_congr' fun x ↦ by simp only [absorbs_iff_eventually_nhdsWithin_zero, mapsTo_singleton]\n\n"}
{"name":"Absorbent.eventually_nhdsWithin_zero","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝² : NormedDivisionRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\ns : Set E\na✝ : Absorbent 𝕜 s\nx : E\n⊢ Filter.Eventually (fun c => Membership.mem s (HSMul.hSMul c x)) (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0)))","decl":"alias ⟨Absorbent.eventually_nhdsWithin_zero, _⟩ := absorbent_iff_eventually_nhdsWithin_zero\n\n"}
{"name":"absorbs_iff_eventually_nhds_zero","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝² : NormedDivisionRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\ns t : Set E\nh₀ : Membership.mem s 0\n⊢ Iff (Absorbs 𝕜 s t) (Filter.Eventually (fun c => Set.MapsTo (fun x => HSMul.hSMul c x) t s) (nhds 0))","decl":"theorem absorbs_iff_eventually_nhds_zero (h₀ : 0 ∈ s) :\n    Absorbs 𝕜 s t ↔ ∀ᶠ c : 𝕜 in 𝓝 0, MapsTo (c • ·) t s := by\n  rw [← nhdsWithin_compl_singleton_sup_pure, Filter.eventually_sup, Filter.eventually_pure,\n    ← absorbs_iff_eventually_nhdsWithin_zero, and_iff_left]\n  intro x _\n  simpa only [zero_smul]\n\n"}
{"name":"Absorbs.eventually_nhds_zero","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝² : NormedDivisionRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\ns t : Set E\nh : Absorbs 𝕜 s t\nh₀ : Membership.mem s 0\n⊢ Filter.Eventually (fun c => Set.MapsTo (fun x => HSMul.hSMul c x) t s) (nhds 0)","decl":"theorem Absorbs.eventually_nhds_zero (h : Absorbs 𝕜 s t) (h₀ : 0 ∈ s) :\n    ∀ᶠ c : 𝕜 in 𝓝 0, MapsTo (c • ·) t s :=\n  (absorbs_iff_eventually_nhds_zero h₀).1 h\n\n"}
{"name":"Balanced.smul_mono","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"𝕜 : Type u_1\n𝕝 : Type u_2\nE : Type u_3\ninst✝⁶ : NormedField 𝕜\ninst✝⁵ : NormedRing 𝕝\ninst✝⁴ : NormedSpace 𝕜 𝕝\ninst✝³ : AddCommGroup E\ninst✝² : Module 𝕜 E\ninst✝¹ : SMulWithZero 𝕝 E\ninst✝ : IsScalarTower 𝕜 𝕝 E\ns : Set E\nhs : Balanced 𝕝 s\na : 𝕝\nb : 𝕜\nh : LE.le (Norm.norm a) (Norm.norm b)\n⊢ HasSubset.Subset (HSMul.hSMul a s) (HSMul.hSMul b s)","decl":"/-- Scalar multiplication (by possibly different types) of a balanced set is monotone. -/\ntheorem Balanced.smul_mono (hs : Balanced 𝕝 s) {a : 𝕝} {b : 𝕜} (h : ‖a‖ ≤ ‖b‖) : a • s ⊆ b • s := by\n  obtain rfl | hb := eq_or_ne b 0\n  · rw [norm_zero, norm_le_zero_iff] at h\n    simp only [h, ← image_smul, zero_smul, Subset.rfl]\n  · calc\n      a • s = b • (b⁻¹ • a) • s := by rw [smul_assoc, smul_inv_smul₀ hb]\n      _ ⊆ b • s := smul_set_mono <| hs _ <| by\n        rw [norm_smul, norm_inv, ← div_eq_inv_mul]\n        exact div_le_one_of_le₀ h (norm_nonneg _)\n\n"}
{"name":"Balanced.smul_mem_mono","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"𝕜 : Type u_1\n𝕝 : Type u_2\nE : Type u_3\ninst✝⁷ : NormedField 𝕜\ninst✝⁶ : NormedRing 𝕝\ninst✝⁵ : NormedSpace 𝕜 𝕝\ninst✝⁴ : AddCommGroup E\ninst✝³ : Module 𝕜 E\ninst✝² : SMulWithZero 𝕝 E\ninst✝¹ : IsScalarTower 𝕜 𝕝 E\ns : Set E\nx : E\ninst✝ : SMulCommClass 𝕝 𝕜 E\nhs : Balanced 𝕝 s\na : 𝕜\nb : 𝕝\nha : Membership.mem s (HSMul.hSMul a x)\nhba : LE.le (Norm.norm b) (Norm.norm a)\n⊢ Membership.mem s (HSMul.hSMul b x)","decl":"theorem Balanced.smul_mem_mono [SMulCommClass 𝕝 𝕜 E] (hs : Balanced 𝕝 s) {a : 𝕜} {b : 𝕝}\n    (ha : a • x ∈ s) (hba : ‖b‖ ≤ ‖a‖) : b • x ∈ s := by\n  rcases eq_or_ne a 0 with rfl | ha₀\n  · simp_all\n  · calc\n      (a⁻¹ • b) • a • x ∈ s := by\n        refine hs.smul_mem ?_ ha\n        rw [norm_smul, norm_inv, ← div_eq_inv_mul]\n        exact div_le_one_of_le₀ hba (norm_nonneg _)\n      (a⁻¹ • b) • a • x = b • x := by rw [smul_comm, smul_assoc, smul_inv_smul₀ ha₀]\n\n"}
{"name":"Balanced.subset_smul","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝² : NormedField 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\nA : Set E\na : 𝕜\nhA : Balanced 𝕜 A\nha : LE.le 1 (Norm.norm a)\n⊢ HasSubset.Subset A (HSMul.hSMul a A)","decl":"theorem Balanced.subset_smul (hA : Balanced 𝕜 A) (ha : 1 ≤ ‖a‖) : A ⊆ a • A := by\n  rw [← @norm_one 𝕜] at ha; simpa using hA.smul_mono ha\n\n"}
{"name":"Balanced.smul_congr","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝² : NormedField 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\nA : Set E\na b : 𝕜\nhs : Balanced 𝕜 A\nh : Eq (Norm.norm a) (Norm.norm b)\n⊢ Eq (HSMul.hSMul a A) (HSMul.hSMul b A)","decl":"theorem Balanced.smul_congr (hs : Balanced 𝕜 A) (h : ‖a‖ = ‖b‖) : a • A = b • A :=\n  (hs.smul_mono h.le).antisymm (hs.smul_mono h.ge)\n\n"}
{"name":"Balanced.smul_eq","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝² : NormedField 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\nA : Set E\na : 𝕜\nhA : Balanced 𝕜 A\nha : Eq (Norm.norm a) 1\n⊢ Eq (HSMul.hSMul a A) A","decl":"theorem Balanced.smul_eq (hA : Balanced 𝕜 A) (ha : ‖a‖ = 1) : a • A = A :=\n  (hA _ ha.le).antisymm <| hA.subset_smul ha.ge\n\n"}
{"name":"Balanced.absorbs_self","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝² : NormedField 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\nA : Set E\nhA : Balanced 𝕜 A\n⊢ Absorbs 𝕜 A A","decl":"/-- A balanced set absorbs itself. -/\ntheorem Balanced.absorbs_self (hA : Balanced 𝕜 A) : Absorbs 𝕜 A A :=\n  .of_norm ⟨1, fun _ => hA.subset_smul⟩\n\n"}
{"name":"Balanced.smul_mem_iff","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝² : NormedField 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\ns : Set E\nx : E\na b : 𝕜\nhs : Balanced 𝕜 s\nh : Eq (Norm.norm a) (Norm.norm b)\n⊢ Iff (Membership.mem s (HSMul.hSMul a x)) (Membership.mem s (HSMul.hSMul b x))","decl":"theorem Balanced.smul_mem_iff (hs : Balanced 𝕜 s) (h : ‖a‖ = ‖b‖) : a • x ∈ s ↔ b • x ∈ s :=\n  ⟨(hs.smul_mem_mono · h.ge), (hs.smul_mem_mono · h.le)⟩\n\n"}
{"name":"absorbent_nhds_zero","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝⁴ : NormedField 𝕜\ninst✝³ : AddCommGroup E\ninst✝² : Module 𝕜 E\nA : Set E\ninst✝¹ : TopologicalSpace E\ninst✝ : ContinuousSMul 𝕜 E\nhA : Membership.mem (nhds 0) A\n⊢ Absorbent 𝕜 A","decl":"/-- Every neighbourhood of the origin is absorbent. -/\ntheorem absorbent_nhds_zero (hA : A ∈ 𝓝 (0 : E)) : Absorbent 𝕜 A :=\n  absorbent_iff_inv_smul.2 fun x ↦ Filter.tendsto_inv₀_cobounded.smul tendsto_const_nhds <| by\n    rwa [zero_smul]\n\n"}
{"name":"Balanced.zero_insert_interior","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝⁴ : NormedField 𝕜\ninst✝³ : AddCommGroup E\ninst✝² : Module 𝕜 E\nA : Set E\ninst✝¹ : TopologicalSpace E\ninst✝ : ContinuousSMul 𝕜 E\nhA : Balanced 𝕜 A\n⊢ Balanced 𝕜 (Insert.insert 0 (interior A))","decl":"/-- The union of `{0}` with the interior of a balanced set is balanced. -/\ntheorem Balanced.zero_insert_interior (hA : Balanced 𝕜 A) :\n    Balanced 𝕜 (insert 0 (interior A)) := by\n  intro a ha\n  obtain rfl | h := eq_or_ne a 0\n  · rw [zero_smul_set]\n    exacts [subset_union_left, ⟨0, Or.inl rfl⟩]\n  · rw [← image_smul, image_insert_eq, smul_zero]\n    apply insert_subset_insert\n    exact ((isOpenMap_smul₀ h).mapsTo_interior <| hA.smul_mem ha).image_subset\n\n"}
{"name":"Balanced.interior","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝⁴ : NormedField 𝕜\ninst✝³ : AddCommGroup E\ninst✝² : Module 𝕜 E\nA : Set E\ninst✝¹ : TopologicalSpace E\ninst✝ : ContinuousSMul 𝕜 E\nhA : Balanced 𝕜 A\nh : Membership.mem (interior A) 0\n⊢ Balanced 𝕜 (interior A)","decl":"/-- The interior of a balanced set is balanced if it contains the origin. -/\nprotected theorem Balanced.interior (hA : Balanced 𝕜 A) (h : (0 : E) ∈ interior A) :\n    Balanced 𝕜 (interior A) := by\n  rw [← insert_eq_self.2 h]\n  exact hA.zero_insert_interior\n\n"}
{"name":"Balanced.closure","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝⁴ : NormedField 𝕜\ninst✝³ : AddCommGroup E\ninst✝² : Module 𝕜 E\nA : Set E\ninst✝¹ : TopologicalSpace E\ninst✝ : ContinuousSMul 𝕜 E\nhA : Balanced 𝕜 A\n⊢ Balanced 𝕜 (closure A)","decl":"protected theorem Balanced.closure (hA : Balanced 𝕜 A) : Balanced 𝕜 (closure A) := fun _a ha =>\n  (image_closure_subset_closure_image <| continuous_const_smul _).trans <|\n    closure_mono <| hA _ ha\n\n"}
{"name":"Balanced.convexHull","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : AddCommGroup E\ninst✝² : Module 𝕜 E\ns : Set E\ninst✝¹ : Module Real E\ninst✝ : SMulCommClass Real 𝕜 E\nhs : Balanced 𝕜 s\n⊢ Balanced 𝕜 ((convexHull Real) s)","decl":"protected theorem Balanced.convexHull (hs : Balanced 𝕜 s) : Balanced 𝕜 (convexHull ℝ s) := by\n  suffices Convex ℝ { x | ∀ a : 𝕜, ‖a‖ ≤ 1 → a • x ∈ convexHull ℝ s } by\n    rw [balanced_iff_smul_mem] at hs ⊢\n    refine fun a ha x hx => convexHull_min ?_ this hx a ha\n    exact fun y hy a ha => subset_convexHull ℝ s (hs ha hy)\n  intro x hx y hy u v hu hv huv a ha\n  simp only [smul_add, ← smul_comm]\n  exact convex_convexHull ℝ s (hx a ha) (hy a ha) hu hv huv\n\n"}
{"name":"balanced_iff_neg_mem","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"E : Type u_3\ninst✝¹ : AddCommGroup E\ninst✝ : Module Real E\ns : Set E\nhs : Convex Real s\n⊢ Iff (Balanced Real s) (∀ ⦃x : E⦄, Membership.mem s x → Membership.mem s (Neg.neg x))","decl":"theorem balanced_iff_neg_mem (hs : Convex ℝ s) : Balanced ℝ s ↔ ∀ ⦃x⦄, x ∈ s → -x ∈ s := by\n  refine ⟨fun h x => h.neg_mem_iff.2, fun h a ha => smul_set_subset_iff.2 fun x hx => ?_⟩\n  rw [Real.norm_eq_abs, abs_le] at ha\n  rw [show a = -((1 - a) / 2) + (a - -1) / 2 by ring, add_smul, neg_smul, ← smul_neg]\n  exact hs (h hx) hx (div_nonneg (sub_nonneg_of_le ha.2) zero_le_two)\n    (div_nonneg (sub_nonneg_of_le ha.1) zero_le_two) (by ring)\n\n"}
