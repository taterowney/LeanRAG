{"name":"absorbs_iff_norm","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœÂ¹ : SeminormedRing ğ•œ\ninstâœ : SMul ğ•œ E\nA B : Set E\nâŠ¢ Iff (Absorbs ğ•œ A B) (Exists fun r => âˆ€ (c : ğ•œ), LE.le r (Norm.norm c) â†’ HasSubset.Subset B (HSMul.hSMul c A))","decl":"lemma absorbs_iff_norm : Absorbs ğ•œ A B â†” âˆƒ r, âˆ€ c : ğ•œ, r â‰¤ â€–câ€– â†’ B âŠ† c â€¢ A :=\n  Filter.atTop_basis.cobounded_of_norm.eventually_iff.trans <| by simp only [true_and]; rfl\n\n"}
{"name":"Absorbs.of_norm","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœÂ¹ : SeminormedRing ğ•œ\ninstâœ : SMul ğ•œ E\nA B : Set E\naâœ : Exists fun r => âˆ€ (c : ğ•œ), LE.le r (Norm.norm c) â†’ HasSubset.Subset B (HSMul.hSMul c A)\nâŠ¢ Absorbs ğ•œ A B","decl":"alias âŸ¨_, Absorbs.of_normâŸ© := absorbs_iff_norm\n\n"}
{"name":"Absorbs.exists_pos","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœÂ¹ : SeminormedRing ğ•œ\ninstâœ : SMul ğ•œ E\nA B : Set E\nh : Absorbs ğ•œ A B\nâŠ¢ Exists fun r => And (GT.gt r 0) (âˆ€ (c : ğ•œ), LE.le r (Norm.norm c) â†’ HasSubset.Subset B (HSMul.hSMul c A))","decl":"lemma Absorbs.exists_pos (h : Absorbs ğ•œ A B) : âˆƒ r > 0, âˆ€ c : ğ•œ, r â‰¤ â€–câ€– â†’ B âŠ† c â€¢ A :=\n  let âŸ¨r, hrâ‚, hrâŸ© := (Filter.atTop_basis' 1).cobounded_of_norm.eventually_iff.1 h\n  âŸ¨r, one_pos.trans_le hrâ‚, hrâŸ©\n\n"}
{"name":"balanced_iff_smul_mem","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœÂ¹ : SeminormedRing ğ•œ\ninstâœ : SMul ğ•œ E\ns : Set E\nâŠ¢ Iff (Balanced ğ•œ s) (âˆ€ â¦ƒa : ğ•œâ¦„, LE.le (Norm.norm a) 1 â†’ âˆ€ â¦ƒx : Eâ¦„, Membership.mem s x â†’ Membership.mem s (HSMul.hSMul a x))","decl":"theorem balanced_iff_smul_mem : Balanced ğ•œ s â†” âˆ€ â¦ƒa : ğ•œâ¦„, â€–aâ€– â‰¤ 1 â†’ âˆ€ â¦ƒx : Eâ¦„, x âˆˆ s â†’ a â€¢ x âˆˆ s :=\n  forallâ‚‚_congr fun _a _ha => smul_set_subset_iff\n\n"}
{"name":"Balanced.smul_mem","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœÂ¹ : SeminormedRing ğ•œ\ninstâœ : SMul ğ•œ E\ns : Set E\naâœÂ² : Balanced ğ•œ s\na : ğ•œ\naâœÂ¹ : LE.le (Norm.norm a) 1\nx : E\naâœ : Membership.mem s x\nâŠ¢ Membership.mem s (HSMul.hSMul a x)","decl":"alias âŸ¨Balanced.smul_mem, _âŸ© := balanced_iff_smul_mem\n\n"}
{"name":"balanced_iff_closedBall_smul","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœÂ¹ : SeminormedRing ğ•œ\ninstâœ : SMul ğ•œ E\ns : Set E\nâŠ¢ Iff (Balanced ğ•œ s) (HasSubset.Subset (HSMul.hSMul (Metric.closedBall 0 1) s) s)","decl":"theorem balanced_iff_closedBall_smul : Balanced ğ•œ s â†” Metric.closedBall (0 : ğ•œ) 1 â€¢ s âŠ† s := by\n  simp [balanced_iff_smul_mem, smul_subset_iff]\n\n"}
{"name":"balanced_empty","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœÂ¹ : SeminormedRing ğ•œ\ninstâœ : SMul ğ•œ E\nâŠ¢ Balanced ğ•œ EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem balanced_empty : Balanced ğ•œ (âˆ… : Set E) := fun _ _ => by rw [smul_set_empty]\n\n"}
{"name":"balanced_univ","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœÂ¹ : SeminormedRing ğ•œ\ninstâœ : SMul ğ•œ E\nâŠ¢ Balanced ğ•œ Set.univ","decl":"@[simp]\ntheorem balanced_univ : Balanced ğ•œ (univ : Set E) := fun _a _ha => subset_univ _\n\n"}
{"name":"Balanced.union","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœÂ¹ : SeminormedRing ğ•œ\ninstâœ : SMul ğ•œ E\nA B : Set E\nhA : Balanced ğ•œ A\nhB : Balanced ğ•œ B\nâŠ¢ Balanced ğ•œ (Union.union A B)","decl":"theorem Balanced.union (hA : Balanced ğ•œ A) (hB : Balanced ğ•œ B) : Balanced ğ•œ (A âˆª B) := fun _a ha =>\n  smul_set_union.subset.trans <| union_subset_union (hA _ ha) <| hB _ ha\n\n"}
{"name":"Balanced.inter","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœÂ¹ : SeminormedRing ğ•œ\ninstâœ : SMul ğ•œ E\nA B : Set E\nhA : Balanced ğ•œ A\nhB : Balanced ğ•œ B\nâŠ¢ Balanced ğ•œ (Inter.inter A B)","decl":"theorem Balanced.inter (hA : Balanced ğ•œ A) (hB : Balanced ğ•œ B) : Balanced ğ•œ (A âˆ© B) := fun _a ha =>\n  smul_set_inter_subset.trans <| inter_subset_inter (hA _ ha) <| hB _ ha\n\n"}
{"name":"balanced_iUnion","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\nÎ¹ : Sort u_4\ninstâœÂ¹ : SeminormedRing ğ•œ\ninstâœ : SMul ğ•œ E\nf : Î¹ â†’ Set E\nh : âˆ€ (i : Î¹), Balanced ğ•œ (f i)\nâŠ¢ Balanced ğ•œ (Set.iUnion fun i => f i)","decl":"theorem balanced_iUnion {f : Î¹ â†’ Set E} (h : âˆ€ i, Balanced ğ•œ (f i)) : Balanced ğ•œ (â‹ƒ i, f i) :=\n  fun _a ha => (smul_set_iUnion _ _).subset.trans <| iUnion_mono fun _ => h _ _ ha\n\n"}
{"name":"balanced_iUnionâ‚‚","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\nÎ¹ : Sort u_4\nÎº : Î¹ â†’ Sort u_5\ninstâœÂ¹ : SeminormedRing ğ•œ\ninstâœ : SMul ğ•œ E\nf : (i : Î¹) â†’ Îº i â†’ Set E\nh : âˆ€ (i : Î¹) (j : Îº i), Balanced ğ•œ (f i j)\nâŠ¢ Balanced ğ•œ (Set.iUnion fun i => Set.iUnion fun j => f i j)","decl":"theorem balanced_iUnionâ‚‚ {f : âˆ€ i, Îº i â†’ Set E} (h : âˆ€ i j, Balanced ğ•œ (f i j)) :\n    Balanced ğ•œ (â‹ƒ (i) (j), f i j) :=\n  balanced_iUnion fun _ => balanced_iUnion <| h _\n\n"}
{"name":"Balanced.sInter","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœÂ¹ : SeminormedRing ğ•œ\ninstâœ : SMul ğ•œ E\nS : Set (Set E)\nh : âˆ€ (s : Set E), Membership.mem S s â†’ Balanced ğ•œ s\nâŠ¢ Balanced ğ•œ S.sInter","decl":"theorem Balanced.sInter {S : Set (Set E)} (h : âˆ€ s âˆˆ S, Balanced ğ•œ s) : Balanced ğ•œ (â‹‚â‚€ S) :=\n  fun _ _ => (smul_set_sInter_subset ..).trans (fun _ _ => by aesop)\n\n"}
{"name":"balanced_iInter","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\nÎ¹ : Sort u_4\ninstâœÂ¹ : SeminormedRing ğ•œ\ninstâœ : SMul ğ•œ E\nf : Î¹ â†’ Set E\nh : âˆ€ (i : Î¹), Balanced ğ•œ (f i)\nâŠ¢ Balanced ğ•œ (Set.iInter fun i => f i)","decl":"theorem balanced_iInter {f : Î¹ â†’ Set E} (h : âˆ€ i, Balanced ğ•œ (f i)) : Balanced ğ•œ (â‹‚ i, f i) :=\n  fun _a ha => (smul_set_iInter_subset _ _).trans <| iInter_mono fun _ => h _ _ ha\n\n"}
{"name":"balanced_iInterâ‚‚","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\nÎ¹ : Sort u_4\nÎº : Î¹ â†’ Sort u_5\ninstâœÂ¹ : SeminormedRing ğ•œ\ninstâœ : SMul ğ•œ E\nf : (i : Î¹) â†’ Îº i â†’ Set E\nh : âˆ€ (i : Î¹) (j : Îº i), Balanced ğ•œ (f i j)\nâŠ¢ Balanced ğ•œ (Set.iInter fun i => Set.iInter fun j => f i j)","decl":"theorem balanced_iInterâ‚‚ {f : âˆ€ i, Îº i â†’ Set E} (h : âˆ€ i j, Balanced ğ•œ (f i j)) :\n    Balanced ğ•œ (â‹‚ (i) (j), f i j) :=\n  balanced_iInter fun _ => balanced_iInter <| h _\n\n"}
{"name":"Balanced.smul","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"ğ•œ : Type u_1\nğ• : Type u_2\nE : Type u_3\ninstâœÂ³ : SeminormedRing ğ•œ\ninstâœÂ² : SMul ğ•œ E\ns : Set E\ninstâœÂ¹ : SMul ğ• E\ninstâœ : SMulCommClass ğ•œ ğ• E\na : ğ•\nhs : Balanced ğ•œ s\nâŠ¢ Balanced ğ•œ (HSMul.hSMul a s)","decl":"theorem Balanced.smul (a : ğ•) (hs : Balanced ğ•œ s) : Balanced ğ•œ (a â€¢ s) := fun _b hb =>\n  (smul_comm _ _ _).subset.trans <| smul_set_mono <| hs _ hb\n\n"}
{"name":"Balanced.neg","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\ns : Set E\naâœ : Balanced ğ•œ s\nâŠ¢ Balanced ğ•œ (Neg.neg s)","decl":"theorem Balanced.neg : Balanced ğ•œ s â†’ Balanced ğ•œ (-s) :=\n  forallâ‚‚_imp fun _ _ h => (smul_set_neg _ _).subset.trans <| neg_subset_neg.2 h\n\n"}
{"name":"balanced_neg","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\ns : Set E\nâŠ¢ Iff (Balanced ğ•œ (Neg.neg s)) (Balanced ğ•œ s)","decl":"@[simp]\ntheorem balanced_neg : Balanced ğ•œ (-s) â†” Balanced ğ•œ s :=\n  âŸ¨fun h â†¦ neg_neg s â–¸ h.neg, fun h â†¦ h.negâŸ©\n\n"}
{"name":"Balanced.neg_mem_iff","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœÂ³ : SeminormedRing ğ•œ\ninstâœÂ² : AddCommGroup E\ninstâœÂ¹ : Module ğ•œ E\ns : Set E\ninstâœ : NormOneClass ğ•œ\nh : Balanced ğ•œ s\nx : E\nâŠ¢ Iff (Membership.mem s (Neg.neg x)) (Membership.mem s x)","decl":"theorem Balanced.neg_mem_iff [NormOneClass ğ•œ] (h : Balanced ğ•œ s) {x : E} : -x âˆˆ s â†” x âˆˆ s :=\n  âŸ¨fun hx â†¦ by simpa using h.smul_mem (a := -1) (by simp) hx,\n    fun hx â†¦ by simpa using h.smul_mem (a := -1) (by simp) hxâŸ©\n\n"}
{"name":"Balanced.neg_eq","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœÂ³ : SeminormedRing ğ•œ\ninstâœÂ² : AddCommGroup E\ninstâœÂ¹ : Module ğ•œ E\ns : Set E\ninstâœ : NormOneClass ğ•œ\nh : Balanced ğ•œ s\nâŠ¢ Eq (Neg.neg s) s","decl":"theorem Balanced.neg_eq [NormOneClass ğ•œ] (h : Balanced ğ•œ s) : -s = s :=\n  Set.ext fun _ â†¦ h.neg_mem_iff\n\n"}
{"name":"Balanced.add","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\ns t : Set E\nhs : Balanced ğ•œ s\nht : Balanced ğ•œ t\nâŠ¢ Balanced ğ•œ (HAdd.hAdd s t)","decl":"theorem Balanced.add (hs : Balanced ğ•œ s) (ht : Balanced ğ•œ t) : Balanced ğ•œ (s + t) := fun _a ha =>\n  (smul_add _ _ _).subset.trans <| add_subset_add (hs _ ha) <| ht _ ha\n\n"}
{"name":"Balanced.sub","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\ns t : Set E\nhs : Balanced ğ•œ s\nht : Balanced ğ•œ t\nâŠ¢ Balanced ğ•œ (HSub.hSub s t)","decl":"theorem Balanced.sub (hs : Balanced ğ•œ s) (ht : Balanced ğ•œ t) : Balanced ğ•œ (s - t) := by\n  simp_rw [sub_eq_add_neg]\n  exact hs.add ht.neg\n\n"}
{"name":"balanced_zero","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\nâŠ¢ Balanced ğ•œ 0","decl":"theorem balanced_zero : Balanced ğ•œ (0 : Set E) := fun _a _ha => (smul_zero _).subset\n\n"}
{"name":"absorbs_iff_eventually_nhdsWithin_zero","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœÂ² : NormedDivisionRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\ns t : Set E\nâŠ¢ Iff (Absorbs ğ•œ s t) (Filter.Eventually (fun c => Set.MapsTo (fun x => HSMul.hSMul c x) t s) (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0))))","decl":"theorem absorbs_iff_eventually_nhdsWithin_zero :\n    Absorbs ğ•œ s t â†” âˆ€á¶  c : ğ•œ in ğ“[â‰ ] 0, MapsTo (c â€¢ Â·) t s := by\n  rw [absorbs_iff_eventually_cobounded_mapsTo, â† Filter.inv_coboundedâ‚€]; rfl\n\n"}
{"name":"Absorbs.eventually_nhdsWithin_zero","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœÂ² : NormedDivisionRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\ns t : Set E\naâœ : Absorbs ğ•œ s t\nâŠ¢ Filter.Eventually (fun c => Set.MapsTo (fun x => HSMul.hSMul c x) t s) (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0)))","decl":"alias âŸ¨Absorbs.eventually_nhdsWithin_zero, _âŸ© := absorbs_iff_eventually_nhdsWithin_zero\n\n"}
{"name":"absorbent_iff_eventually_nhdsWithin_zero","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœÂ² : NormedDivisionRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\ns : Set E\nâŠ¢ Iff (Absorbent ğ•œ s) (âˆ€ (x : E), Filter.Eventually (fun c => Membership.mem s (HSMul.hSMul c x)) (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0))))","decl":"theorem absorbent_iff_eventually_nhdsWithin_zero :\n    Absorbent ğ•œ s â†” âˆ€ x : E, âˆ€á¶  c : ğ•œ in ğ“[â‰ ] 0, c â€¢ x âˆˆ s :=\n  forall_congr' fun x â†¦ by simp only [absorbs_iff_eventually_nhdsWithin_zero, mapsTo_singleton]\n\n"}
{"name":"Absorbent.eventually_nhdsWithin_zero","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœÂ² : NormedDivisionRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\ns : Set E\naâœ : Absorbent ğ•œ s\nx : E\nâŠ¢ Filter.Eventually (fun c => Membership.mem s (HSMul.hSMul c x)) (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0)))","decl":"alias âŸ¨Absorbent.eventually_nhdsWithin_zero, _âŸ© := absorbent_iff_eventually_nhdsWithin_zero\n\n"}
{"name":"absorbs_iff_eventually_nhds_zero","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœÂ² : NormedDivisionRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\ns t : Set E\nhâ‚€ : Membership.mem s 0\nâŠ¢ Iff (Absorbs ğ•œ s t) (Filter.Eventually (fun c => Set.MapsTo (fun x => HSMul.hSMul c x) t s) (nhds 0))","decl":"theorem absorbs_iff_eventually_nhds_zero (hâ‚€ : 0 âˆˆ s) :\n    Absorbs ğ•œ s t â†” âˆ€á¶  c : ğ•œ in ğ“ 0, MapsTo (c â€¢ Â·) t s := by\n  rw [â† nhdsWithin_compl_singleton_sup_pure, Filter.eventually_sup, Filter.eventually_pure,\n    â† absorbs_iff_eventually_nhdsWithin_zero, and_iff_left]\n  intro x _\n  simpa only [zero_smul]\n\n"}
{"name":"Absorbs.eventually_nhds_zero","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœÂ² : NormedDivisionRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\ns t : Set E\nh : Absorbs ğ•œ s t\nhâ‚€ : Membership.mem s 0\nâŠ¢ Filter.Eventually (fun c => Set.MapsTo (fun x => HSMul.hSMul c x) t s) (nhds 0)","decl":"theorem Absorbs.eventually_nhds_zero (h : Absorbs ğ•œ s t) (hâ‚€ : 0 âˆˆ s) :\n    âˆ€á¶  c : ğ•œ in ğ“ 0, MapsTo (c â€¢ Â·) t s :=\n  (absorbs_iff_eventually_nhds_zero hâ‚€).1 h\n\n"}
{"name":"Balanced.smul_mono","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"ğ•œ : Type u_1\nğ• : Type u_2\nE : Type u_3\ninstâœâ¶ : NormedField ğ•œ\ninstâœâµ : NormedRing ğ•\ninstâœâ´ : NormedSpace ğ•œ ğ•\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : SMulWithZero ğ• E\ninstâœ : IsScalarTower ğ•œ ğ• E\ns : Set E\nhs : Balanced ğ• s\na : ğ•\nb : ğ•œ\nh : LE.le (Norm.norm a) (Norm.norm b)\nâŠ¢ HasSubset.Subset (HSMul.hSMul a s) (HSMul.hSMul b s)","decl":"/-- Scalar multiplication (by possibly different types) of a balanced set is monotone. -/\ntheorem Balanced.smul_mono (hs : Balanced ğ• s) {a : ğ•} {b : ğ•œ} (h : â€–aâ€– â‰¤ â€–bâ€–) : a â€¢ s âŠ† b â€¢ s := by\n  obtain rfl | hb := eq_or_ne b 0\n  Â· rw [norm_zero, norm_le_zero_iff] at h\n    simp only [h, â† image_smul, zero_smul, Subset.rfl]\n  Â· calc\n      a â€¢ s = b â€¢ (bâ»Â¹ â€¢ a) â€¢ s := by rw [smul_assoc, smul_inv_smulâ‚€ hb]\n      _ âŠ† b â€¢ s := smul_set_mono <| hs _ <| by\n        rw [norm_smul, norm_inv, â† div_eq_inv_mul]\n        exact div_le_one_of_leâ‚€ h (norm_nonneg _)\n\n"}
{"name":"Balanced.smul_mem_mono","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"ğ•œ : Type u_1\nğ• : Type u_2\nE : Type u_3\ninstâœâ· : NormedField ğ•œ\ninstâœâ¶ : NormedRing ğ•\ninstâœâµ : NormedSpace ğ•œ ğ•\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : Module ğ•œ E\ninstâœÂ² : SMulWithZero ğ• E\ninstâœÂ¹ : IsScalarTower ğ•œ ğ• E\ns : Set E\nx : E\ninstâœ : SMulCommClass ğ• ğ•œ E\nhs : Balanced ğ• s\na : ğ•œ\nb : ğ•\nha : Membership.mem s (HSMul.hSMul a x)\nhba : LE.le (Norm.norm b) (Norm.norm a)\nâŠ¢ Membership.mem s (HSMul.hSMul b x)","decl":"theorem Balanced.smul_mem_mono [SMulCommClass ğ• ğ•œ E] (hs : Balanced ğ• s) {a : ğ•œ} {b : ğ•}\n    (ha : a â€¢ x âˆˆ s) (hba : â€–bâ€– â‰¤ â€–aâ€–) : b â€¢ x âˆˆ s := by\n  rcases eq_or_ne a 0 with rfl | haâ‚€\n  Â· simp_all\n  Â· calc\n      (aâ»Â¹ â€¢ b) â€¢ a â€¢ x âˆˆ s := by\n        refine hs.smul_mem ?_ ha\n        rw [norm_smul, norm_inv, â† div_eq_inv_mul]\n        exact div_le_one_of_leâ‚€ hba (norm_nonneg _)\n      (aâ»Â¹ â€¢ b) â€¢ a â€¢ x = b â€¢ x := by rw [smul_comm, smul_assoc, smul_inv_smulâ‚€ haâ‚€]\n\n"}
{"name":"Balanced.subset_smul","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\nA : Set E\na : ğ•œ\nhA : Balanced ğ•œ A\nha : LE.le 1 (Norm.norm a)\nâŠ¢ HasSubset.Subset A (HSMul.hSMul a A)","decl":"theorem Balanced.subset_smul (hA : Balanced ğ•œ A) (ha : 1 â‰¤ â€–aâ€–) : A âŠ† a â€¢ A := by\n  rw [â† @norm_one ğ•œ] at ha; simpa using hA.smul_mono ha\n\n"}
{"name":"Balanced.smul_congr","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\nA : Set E\na b : ğ•œ\nhs : Balanced ğ•œ A\nh : Eq (Norm.norm a) (Norm.norm b)\nâŠ¢ Eq (HSMul.hSMul a A) (HSMul.hSMul b A)","decl":"theorem Balanced.smul_congr (hs : Balanced ğ•œ A) (h : â€–aâ€– = â€–bâ€–) : a â€¢ A = b â€¢ A :=\n  (hs.smul_mono h.le).antisymm (hs.smul_mono h.ge)\n\n"}
{"name":"Balanced.smul_eq","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\nA : Set E\na : ğ•œ\nhA : Balanced ğ•œ A\nha : Eq (Norm.norm a) 1\nâŠ¢ Eq (HSMul.hSMul a A) A","decl":"theorem Balanced.smul_eq (hA : Balanced ğ•œ A) (ha : â€–aâ€– = 1) : a â€¢ A = A :=\n  (hA _ ha.le).antisymm <| hA.subset_smul ha.ge\n\n"}
{"name":"Balanced.absorbs_self","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\nA : Set E\nhA : Balanced ğ•œ A\nâŠ¢ Absorbs ğ•œ A A","decl":"/-- A balanced set absorbs itself. -/\ntheorem Balanced.absorbs_self (hA : Balanced ğ•œ A) : Absorbs ğ•œ A A :=\n  .of_norm âŸ¨1, fun _ => hA.subset_smulâŸ©\n\n"}
{"name":"Balanced.smul_mem_iff","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\ns : Set E\nx : E\na b : ğ•œ\nhs : Balanced ğ•œ s\nh : Eq (Norm.norm a) (Norm.norm b)\nâŠ¢ Iff (Membership.mem s (HSMul.hSMul a x)) (Membership.mem s (HSMul.hSMul b x))","decl":"theorem Balanced.smul_mem_iff (hs : Balanced ğ•œ s) (h : â€–aâ€– = â€–bâ€–) : a â€¢ x âˆˆ s â†” b â€¢ x âˆˆ s :=\n  âŸ¨(hs.smul_mem_mono Â· h.ge), (hs.smul_mem_mono Â· h.le)âŸ©\n\n"}
{"name":"absorbent_nhds_zero","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœâ´ : NormedField ğ•œ\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module ğ•œ E\nA : Set E\ninstâœÂ¹ : TopologicalSpace E\ninstâœ : ContinuousSMul ğ•œ E\nhA : Membership.mem (nhds 0) A\nâŠ¢ Absorbent ğ•œ A","decl":"/-- Every neighbourhood of the origin is absorbent. -/\ntheorem absorbent_nhds_zero (hA : A âˆˆ ğ“ (0 : E)) : Absorbent ğ•œ A :=\n  absorbent_iff_inv_smul.2 fun x â†¦ Filter.tendsto_invâ‚€_cobounded.smul tendsto_const_nhds <| by\n    rwa [zero_smul]\n\n"}
{"name":"Balanced.zero_insert_interior","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœâ´ : NormedField ğ•œ\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module ğ•œ E\nA : Set E\ninstâœÂ¹ : TopologicalSpace E\ninstâœ : ContinuousSMul ğ•œ E\nhA : Balanced ğ•œ A\nâŠ¢ Balanced ğ•œ (Insert.insert 0 (interior A))","decl":"/-- The union of `{0}` with the interior of a balanced set is balanced. -/\ntheorem Balanced.zero_insert_interior (hA : Balanced ğ•œ A) :\n    Balanced ğ•œ (insert 0 (interior A)) := by\n  intro a ha\n  obtain rfl | h := eq_or_ne a 0\n  Â· rw [zero_smul_set]\n    exacts [subset_union_left, âŸ¨0, Or.inl rflâŸ©]\n  Â· rw [â† image_smul, image_insert_eq, smul_zero]\n    apply insert_subset_insert\n    exact ((isOpenMap_smulâ‚€ h).mapsTo_interior <| hA.smul_mem ha).image_subset\n\n"}
{"name":"Balanced.interior","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœâ´ : NormedField ğ•œ\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module ğ•œ E\nA : Set E\ninstâœÂ¹ : TopologicalSpace E\ninstâœ : ContinuousSMul ğ•œ E\nhA : Balanced ğ•œ A\nh : Membership.mem (interior A) 0\nâŠ¢ Balanced ğ•œ (interior A)","decl":"/-- The interior of a balanced set is balanced if it contains the origin. -/\nprotected theorem Balanced.interior (hA : Balanced ğ•œ A) (h : (0 : E) âˆˆ interior A) :\n    Balanced ğ•œ (interior A) := by\n  rw [â† insert_eq_self.2 h]\n  exact hA.zero_insert_interior\n\n"}
{"name":"Balanced.closure","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœâ´ : NormedField ğ•œ\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module ğ•œ E\nA : Set E\ninstâœÂ¹ : TopologicalSpace E\ninstâœ : ContinuousSMul ğ•œ E\nhA : Balanced ğ•œ A\nâŠ¢ Balanced ğ•œ (closure A)","decl":"protected theorem Balanced.closure (hA : Balanced ğ•œ A) : Balanced ğ•œ (closure A) := fun _a ha =>\n  (image_closure_subset_closure_image <| continuous_const_smul _).trans <|\n    closure_mono <| hA _ ha\n\n"}
{"name":"Balanced.convexHull","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module ğ•œ E\ns : Set E\ninstâœÂ¹ : Module Real E\ninstâœ : SMulCommClass Real ğ•œ E\nhs : Balanced ğ•œ s\nâŠ¢ Balanced ğ•œ ((convexHull Real) s)","decl":"protected theorem Balanced.convexHull (hs : Balanced ğ•œ s) : Balanced ğ•œ (convexHull â„ s) := by\n  suffices Convex â„ { x | âˆ€ a : ğ•œ, â€–aâ€– â‰¤ 1 â†’ a â€¢ x âˆˆ convexHull â„ s } by\n    rw [balanced_iff_smul_mem] at hs âŠ¢\n    refine fun a ha x hx => convexHull_min ?_ this hx a ha\n    exact fun y hy a ha => subset_convexHull â„ s (hs ha hy)\n  intro x hx y hy u v hu hv huv a ha\n  simp only [smul_add, â† smul_comm]\n  exact convex_convexHull â„ s (hx a ha) (hy a ha) hu hv huv\n\n"}
{"name":"balanced_iff_neg_mem","module":"Mathlib.Analysis.LocallyConvex.Basic","initialProofState":"E : Type u_3\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module Real E\ns : Set E\nhs : Convex Real s\nâŠ¢ Iff (Balanced Real s) (âˆ€ â¦ƒx : Eâ¦„, Membership.mem s x â†’ Membership.mem s (Neg.neg x))","decl":"theorem balanced_iff_neg_mem (hs : Convex â„ s) : Balanced â„ s â†” âˆ€ â¦ƒxâ¦„, x âˆˆ s â†’ -x âˆˆ s := by\n  refine âŸ¨fun h x => h.neg_mem_iff.2, fun h a ha => smul_set_subset_iff.2 fun x hx => ?_âŸ©\n  rw [Real.norm_eq_abs, abs_le] at ha\n  rw [show a = -((1 - a) / 2) + (a - -1) / 2 by ring, add_smul, neg_smul, â† smul_neg]\n  exact hs (h hx) hx (div_nonneg (sub_nonneg_of_le ha.2) zero_le_two)\n    (div_nonneg (sub_nonneg_of_le ha.1) zero_le_two) (by ring)\n\n"}
