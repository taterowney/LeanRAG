{"name":"IsPreconnected.subset_isClopen","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"Î± : Type u\ninstâœ : TopologicalSpace Î±\ns t : Set Î±\nhs : IsPreconnected s\nht : IsClopen t\nhne : (Inter.inter s t).Nonempty\nâŠ¢ HasSubset.Subset s t","decl":"/-- Preconnected sets are either contained in or disjoint to any given clopen set. -/\ntheorem IsPreconnected.subset_isClopen {s t : Set Î±} (hs : IsPreconnected s) (ht : IsClopen t)\n    (hne : (s âˆ© t).Nonempty) : s âŠ† t :=\n  hs.subset_left_of_subset_union ht.isOpen ht.compl.isOpen disjoint_compl_right (by simp) hne\n\n"}
{"name":"Sigma.isConnected_iff","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"Î¹ : Type u_1\nÏ€ : Î¹ â†’ Type u_2\ninstâœ : (i : Î¹) â†’ TopologicalSpace (Ï€ i)\ns : Set (Sigma fun i => Ï€ i)\nâŠ¢ Iff (IsConnected s) (Exists fun i => Exists fun t => And (IsConnected t) (Eq s (Set.image (Sigma.mk i) t)))","decl":"theorem Sigma.isConnected_iff [âˆ€ i, TopologicalSpace (Ï€ i)] {s : Set (Î£i, Ï€ i)} :\n    IsConnected s â†” âˆƒ i t, IsConnected t âˆ§ s = Sigma.mk i '' t := by\n  refine âŸ¨fun hs => ?_, ?_âŸ©\n  Â· obtain âŸ¨âŸ¨i, xâŸ©, hxâŸ© := hs.nonempty\n    have : s âŠ† range (Sigma.mk i) :=\n      hs.isPreconnected.subset_isClopen isClopen_range_sigmaMk âŸ¨âŸ¨i, xâŸ©, hx, x, rflâŸ©\n    exact âŸ¨i, Sigma.mk i â»Â¹' s, hs.preimage_of_isOpenMap sigma_mk_injective isOpenMap_sigmaMk this,\n      (Set.image_preimage_eq_of_subset this).symmâŸ©\n  Â· rintro âŸ¨i, t, ht, rflâŸ©\n    exact ht.image _ continuous_sigmaMk.continuousOn\n\n"}
{"name":"Sigma.isPreconnected_iff","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"Î¹ : Type u_1\nÏ€ : Î¹ â†’ Type u_2\nhÎ¹ : Nonempty Î¹\ninstâœ : (i : Î¹) â†’ TopologicalSpace (Ï€ i)\ns : Set (Sigma fun i => Ï€ i)\nâŠ¢ Iff (IsPreconnected s) (Exists fun i => Exists fun t => And (IsPreconnected t) (Eq s (Set.image (Sigma.mk i) t)))","decl":"theorem Sigma.isPreconnected_iff [hÎ¹ : Nonempty Î¹] [âˆ€ i, TopologicalSpace (Ï€ i)]\n    {s : Set (Î£i, Ï€ i)} : IsPreconnected s â†” âˆƒ i t, IsPreconnected t âˆ§ s = Sigma.mk i '' t := by\n  refine âŸ¨fun hs => ?_, ?_âŸ©\n  Â· obtain rfl | h := s.eq_empty_or_nonempty\n    Â· exact âŸ¨Classical.choice hÎ¹, âˆ…, isPreconnected_empty, (Set.image_empty _).symmâŸ©\n    Â· obtain âŸ¨a, t, ht, rflâŸ© := Sigma.isConnected_iff.1 âŸ¨h, hsâŸ©\n      exact âŸ¨a, t, ht.isPreconnected, rflâŸ©\n  Â· rintro âŸ¨a, t, ht, rflâŸ©\n    exact ht.image _ continuous_sigmaMk.continuousOn\n\n"}
{"name":"Sum.isConnected_iff","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalSpace Î²\ns : Set (Sum Î± Î²)\nâŠ¢ Iff (IsConnected s) (Or (Exists fun t => And (IsConnected t) (Eq s (Set.image Sum.inl t))) (Exists fun t => And (IsConnected t) (Eq s (Set.image Sum.inr t))))","decl":"theorem Sum.isConnected_iff [TopologicalSpace Î²] {s : Set (Î± âŠ• Î²)} :\n    IsConnected s â†”\n      (âˆƒ t, IsConnected t âˆ§ s = Sum.inl '' t) âˆ¨ âˆƒ t, IsConnected t âˆ§ s = Sum.inr '' t := by\n  refine âŸ¨fun hs => ?_, ?_âŸ©\n  Â· obtain âŸ¨x | x, hxâŸ© := hs.nonempty\n    Â· have h : s âŠ† range Sum.inl :=\n        hs.isPreconnected.subset_isClopen isClopen_range_inl âŸ¨.inl x, hx, x, rflâŸ©\n      refine Or.inl âŸ¨Sum.inl â»Â¹' s, ?_, ?_âŸ©\n      Â· exact hs.preimage_of_isOpenMap Sum.inl_injective isOpenMap_inl h\n      Â· exact (image_preimage_eq_of_subset h).symm\n    Â· have h : s âŠ† range Sum.inr :=\n        hs.isPreconnected.subset_isClopen isClopen_range_inr âŸ¨.inr x, hx, x, rflâŸ©\n      refine Or.inr âŸ¨Sum.inr â»Â¹' s, ?_, ?_âŸ©\n      Â· exact hs.preimage_of_isOpenMap Sum.inr_injective isOpenMap_inr h\n      Â· exact (image_preimage_eq_of_subset h).symm\n  Â· rintro (âŸ¨t, ht, rflâŸ© | âŸ¨t, ht, rflâŸ©)\n    Â· exact ht.image _ continuous_inl.continuousOn\n    Â· exact ht.image _ continuous_inr.continuousOn\n\n"}
{"name":"Sum.isPreconnected_iff","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalSpace Î²\ns : Set (Sum Î± Î²)\nâŠ¢ Iff (IsPreconnected s) (Or (Exists fun t => And (IsPreconnected t) (Eq s (Set.image Sum.inl t))) (Exists fun t => And (IsPreconnected t) (Eq s (Set.image Sum.inr t))))","decl":"theorem Sum.isPreconnected_iff [TopologicalSpace Î²] {s : Set (Î± âŠ• Î²)} :\n    IsPreconnected s â†”\n      (âˆƒ t, IsPreconnected t âˆ§ s = Sum.inl '' t) âˆ¨ âˆƒ t, IsPreconnected t âˆ§ s = Sum.inr '' t := by\n  refine âŸ¨fun hs => ?_, ?_âŸ©\n  Â· obtain rfl | h := s.eq_empty_or_nonempty\n    Â· exact Or.inl âŸ¨âˆ…, isPreconnected_empty, (Set.image_empty _).symmâŸ©\n    obtain âŸ¨t, ht, rflâŸ© | âŸ¨t, ht, rflâŸ© := Sum.isConnected_iff.1 âŸ¨h, hsâŸ©\n    Â· exact Or.inl âŸ¨t, ht.isPreconnected, rflâŸ©\n    Â· exact Or.inr âŸ¨t, ht.isPreconnected, rflâŸ©\n  Â· rintro (âŸ¨t, ht, rflâŸ© | âŸ¨t, ht, rflâŸ©)\n    Â· exact ht.image _ continuous_inl.continuousOn\n    Â· exact ht.image _ continuous_inr.continuousOn\n\n"}
{"name":"Continuous.exists_lift_sigma","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"Î± : Type u\nÎ¹ : Type u_1\nÏ€ : Î¹ â†’ Type u_2\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : ConnectedSpace Î±\ninstâœ : (i : Î¹) â†’ TopologicalSpace (Ï€ i)\nf : Î± â†’ Sigma fun i => Ï€ i\nhf : Continuous f\nâŠ¢ Exists fun i => Exists fun g => And (Continuous g) (Eq f (Function.comp (Sigma.mk i) g))","decl":"/-- A continuous map from a connected space to a disjoint union `Î£ i, Ï€ i` can be lifted to one of\nthe components `Ï€ i`. See also `ContinuousMap.exists_lift_sigma` for a version with bundled\n`ContinuousMap`s. -/\ntheorem Continuous.exists_lift_sigma [ConnectedSpace Î±] [âˆ€ i, TopologicalSpace (Ï€ i)]\n    {f : Î± â†’ Î£ i, Ï€ i} (hf : Continuous f) :\n    âˆƒ (i : Î¹) (g : Î± â†’ Ï€ i), Continuous g âˆ§ f = Sigma.mk i âˆ˜ g := by\n  obtain âŸ¨i, hiâŸ© : âˆƒ i, range f âŠ† range (.mk i) := by\n    rcases Sigma.isConnected_iff.1 (isConnected_range hf) with âŸ¨i, s, -, hsâŸ©\n    exact âŸ¨i, hs.trans_subset (image_subset_range _ _)âŸ©\n  rcases range_subset_range_iff_exists_comp.1 hi with âŸ¨g, rflâŸ©\n  refine âŸ¨i, g, ?_, rflâŸ©\n  rwa [â† IsEmbedding.sigmaMk.continuous_iff] at hf\n\n"}
{"name":"nonempty_inter","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"Î± : Type u\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : PreconnectedSpace Î±\ns t : Set Î±\naâœâ´ : IsOpen s\naâœÂ³ : IsOpen t\naâœÂ² : Eq (Union.union s t) Set.univ\naâœÂ¹ : s.Nonempty\naâœ : t.Nonempty\nâŠ¢ (Inter.inter s t).Nonempty","decl":"theorem nonempty_inter [PreconnectedSpace Î±] {s t : Set Î±} :\n    IsOpen s â†’ IsOpen t â†’ s âˆª t = univ â†’ s.Nonempty â†’ t.Nonempty â†’ (s âˆ© t).Nonempty := by\n  simpa only [univ_inter, univ_subset_iff] using @PreconnectedSpace.isPreconnected_univ Î± _ _ s t\n\n"}
{"name":"isClopen_iff","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"Î± : Type u\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : PreconnectedSpace Î±\ns : Set Î±\nâŠ¢ Iff (IsClopen s) (Or (Eq s EmptyCollection.emptyCollection) (Eq s Set.univ))","decl":"theorem isClopen_iff [PreconnectedSpace Î±] {s : Set Î±} : IsClopen s â†” s = âˆ… âˆ¨ s = univ :=\n  âŸ¨fun hs =>\n    by_contradiction fun h =>\n      have h1 : s â‰  âˆ… âˆ§ sá¶œ â‰  âˆ… :=\n        âŸ¨mt Or.inl h,\n          mt (fun h2 => Or.inr <| (by rw [â† compl_compl s, h2, compl_empty] : s = univ)) hâŸ©\n      let âŸ¨_, h2, h3âŸ© :=\n        nonempty_inter hs.2 hs.1.isOpen_compl (union_compl_self s) (nonempty_iff_ne_empty.2 h1.1)\n          (nonempty_iff_ne_empty.2 h1.2)\n      h3 h2,\n    by rintro (rfl | rfl) <;> [exact isClopen_empty; exact isClopen_univ]âŸ©\n\n"}
{"name":"IsClopen.eq_univ","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"Î± : Type u\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : PreconnectedSpace Î±\ns : Set Î±\nh' : IsClopen s\nh : s.Nonempty\nâŠ¢ Eq s Set.univ","decl":"theorem IsClopen.eq_univ [PreconnectedSpace Î±] {s : Set Î±} (h' : IsClopen s) (h : s.Nonempty) :\n    s = univ :=\n  (isClopen_iff.mp h').resolve_left h.ne_empty\n\n"}
{"name":"isClopen_preimage_val","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"X : Type u_3\ninstâœ : TopologicalSpace X\nu v : Set X\nhu : IsOpen u\nhuv : Disjoint (frontier u) v\nâŠ¢ IsClopen (Set.preimage Subtype.val u)","decl":"open Set.Notation in\nlemma isClopen_preimage_val {X : Type*} [TopologicalSpace X] {u v : Set X}\n    (hu : IsOpen u) (huv : Disjoint (frontier u) v) : IsClopen (v â†“âˆ© u) := by\n  refine âŸ¨?_, isOpen_induced hu (f := Subtype.val)âŸ©\n  refine isClosed_induced_iff.mpr âŸ¨closure u, isClosed_closure, ?_âŸ©\n  apply image_val_injective\n  simp only [Subtype.image_preimage_coe]\n  rw [closure_eq_self_union_frontier, inter_union_distrib_left, inter_comm _ (frontier u),\n    huv.inter_eq, union_empty]\n\n"}
{"name":"subsingleton_of_disjoint_isClopen","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"Î± : Type u\nÎ¹ : Type u_1\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : PreconnectedSpace Î±\ns : Î¹ â†’ Set Î±\nh_nonempty : âˆ€ (i : Î¹), (s i).Nonempty\nh_disj : Pairwise (Function.onFun Disjoint s)\nh_clopen : âˆ€ (i : Î¹), IsClopen (s i)\nâŠ¢ Subsingleton Î¹","decl":"/-- In a preconnected space, any disjoint family of non-empty clopen subsets has at most one\nelement. -/\nlemma subsingleton_of_disjoint_isClopen\n    (h_clopen : âˆ€ i, IsClopen (s i)) :\n    Subsingleton Î¹ := by\n  replace h_nonempty : âˆ€ i, s i â‰  âˆ… := by intro i; rw [â† nonempty_iff_ne_empty]; exact h_nonempty i\n  rw [â† not_nontrivial_iff_subsingleton]\n  by_contra contra\n  obtain âŸ¨i, j, h_neâŸ© := contra\n  replace h_ne : s i âˆ© s j = âˆ… := by\n    simpa only [â† bot_eq_empty, eq_bot_iff, â† inf_eq_inter, â† disjoint_iff_inf_le] using h_disj h_ne\n  cases' isClopen_iff.mp (h_clopen i) with hi hi\n  Â· exact h_nonempty i hi\n  Â· rw [hi, univ_inter] at h_ne\n    exact h_nonempty j h_ne\n\n"}
{"name":"subsingleton_of_disjoint_isOpen_iUnion_eq_univ","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"Î± : Type u\nÎ¹ : Type u_1\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : PreconnectedSpace Î±\ns : Î¹ â†’ Set Î±\nh_nonempty : âˆ€ (i : Î¹), (s i).Nonempty\nh_disj : Pairwise (Function.onFun Disjoint s)\nh_open : âˆ€ (i : Î¹), IsOpen (s i)\nh_Union : Eq (Set.iUnion fun i => s i) Set.univ\nâŠ¢ Subsingleton Î¹","decl":"/-- In a preconnected space, any disjoint cover by non-empty open subsets has at most one\nelement. -/\nlemma subsingleton_of_disjoint_isOpen_iUnion_eq_univ\n    (h_open : âˆ€ i, IsOpen (s i)) (h_Union : â‹ƒ i, s i = univ) :\n    Subsingleton Î¹ := by\n  refine subsingleton_of_disjoint_isClopen h_nonempty h_disj (fun i â†¦ âŸ¨?_, h_open iâŸ©)\n  rw [â† isOpen_compl_iff, compl_eq_univ_diff, â† h_Union, iUnion_diff]\n  refine isOpen_iUnion (fun j â†¦ ?_)\n  rcases eq_or_ne i j with rfl | h_ne\n  Â· simp\n  Â· simpa only [(h_disj h_ne.symm).sdiff_eq_left] using h_open j\n\n"}
{"name":"subsingleton_of_disjoint_isClosed_iUnion_eq_univ","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"Î± : Type u\nÎ¹ : Type u_1\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : PreconnectedSpace Î±\ns : Î¹ â†’ Set Î±\nh_nonempty : âˆ€ (i : Î¹), (s i).Nonempty\nh_disj : Pairwise (Function.onFun Disjoint s)\ninstâœ : Finite Î¹\nh_closed : âˆ€ (i : Î¹), IsClosed (s i)\nh_Union : Eq (Set.iUnion fun i => s i) Set.univ\nâŠ¢ Subsingleton Î¹","decl":"/-- In a preconnected space, any finite disjoint cover by non-empty closed subsets has at most one\nelement. -/\nlemma subsingleton_of_disjoint_isClosed_iUnion_eq_univ [Finite Î¹]\n    (h_closed : âˆ€ i, IsClosed (s i)) (h_Union : â‹ƒ i, s i = univ) :\n    Subsingleton Î¹ := by\n  refine subsingleton_of_disjoint_isClopen h_nonempty h_disj (fun i â†¦ âŸ¨h_closed i, ?_âŸ©)\n  rw [â† isClosed_compl_iff, compl_eq_univ_diff, â† h_Union, iUnion_diff]\n  refine isClosed_iUnion_of_finite (fun j â†¦ ?_)\n  rcases eq_or_ne i j with rfl | h_ne\n  Â· simp\n  Â· simpa only [(h_disj h_ne.symm).sdiff_eq_left] using h_closed j\n\n"}
{"name":"frontier_eq_empty_iff","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"Î± : Type u\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : PreconnectedSpace Î±\ns : Set Î±\nâŠ¢ Iff (Eq (frontier s) EmptyCollection.emptyCollection) (Or (Eq s EmptyCollection.emptyCollection) (Eq s Set.univ))","decl":"theorem frontier_eq_empty_iff [PreconnectedSpace Î±] {s : Set Î±} :\n    frontier s = âˆ… â†” s = âˆ… âˆ¨ s = univ :=\n  isClopen_iff_frontier_eq_empty.symm.trans isClopen_iff\n\n"}
{"name":"nonempty_frontier_iff","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"Î± : Type u\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : PreconnectedSpace Î±\ns : Set Î±\nâŠ¢ Iff (frontier s).Nonempty (And s.Nonempty (Ne s Set.univ))","decl":"theorem nonempty_frontier_iff [PreconnectedSpace Î±] {s : Set Î±} :\n    (frontier s).Nonempty â†” s.Nonempty âˆ§ s â‰  univ := by\n  simp only [nonempty_iff_ne_empty, Ne, frontier_eq_empty_iff, not_or]\n\n"}
{"name":"PreconnectedSpace.inductionâ‚‚'","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"Î± : Type u\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : PreconnectedSpace Î±\nP : Î± â†’ Î± â†’ Prop\nh : âˆ€ (x : Î±), Filter.Eventually (fun y => And (P x y) (P y x)) (nhds x)\nh' : Transitive P\nx y : Î±\nâŠ¢ P x y","decl":"/-- In a preconnected space, given a transitive relation `P`, if `P x y` and `P y x` are true\nfor `y` close enough to `x`, then `P x y` holds for all `x, y`. This is a version of the fact\nthat, if an equivalence relation has open classes, then it has a single equivalence class. -/\nlemma PreconnectedSpace.inductionâ‚‚' [PreconnectedSpace Î±] (P : Î± â†’ Î± â†’ Prop)\n    (h : âˆ€ x, âˆ€á¶  y in ğ“ x, P x y âˆ§ P y x) (h' : Transitive P) (x y : Î±) :\n    P x y := by\n  let u := {z | P x z}\n  have A : IsClosed u := by\n    apply isClosed_iff_nhds.2 (fun z hz â†¦ ?_)\n    rcases hz _ (h z) with âŸ¨t, ht, h'tâŸ©\n    exact h' h't ht.2\n  have B : IsOpen u := by\n    apply isOpen_iff_mem_nhds.2 (fun z hz â†¦ ?_)\n    filter_upwards [h z] with t ht\n    exact h' hz ht.1\n  have C : u.Nonempty := âŸ¨x, (mem_of_mem_nhds (h x)).1âŸ©\n  have D : u = Set.univ := IsClopen.eq_univ âŸ¨A, BâŸ© C\n  show y âˆˆ u\n  simp [D]\n\n"}
{"name":"PreconnectedSpace.inductionâ‚‚","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"Î± : Type u\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : PreconnectedSpace Î±\nP : Î± â†’ Î± â†’ Prop\nh : âˆ€ (x : Î±), Filter.Eventually (fun y => P x y) (nhds x)\nh' : Transitive P\nh'' : Symmetric P\nx y : Î±\nâŠ¢ P x y","decl":"/-- In a preconnected space, if a symmetric transitive relation `P x y` is true for `y` close\nenough to `x`, then it holds for all `x, y`. This is a version of the fact that, if an equivalence\nrelation has open classes, then it has a single equivalence class. -/\nlemma PreconnectedSpace.inductionâ‚‚ [PreconnectedSpace Î±] (P : Î± â†’ Î± â†’ Prop)\n    (h : âˆ€ x, âˆ€á¶  y in ğ“ x, P x y) (h' : Transitive P) (h'' : Symmetric P) (x y : Î±) :\n    P x y := by\n  refine PreconnectedSpace.inductionâ‚‚' P (fun z â†¦ ?_) h' x y\n  filter_upwards [h z] with a ha\n  exact âŸ¨ha, h'' haâŸ©\n\n"}
{"name":"IsPreconnected.inductionâ‚‚'","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"Î± : Type u\ninstâœ : TopologicalSpace Î±\ns : Set Î±\nhs : IsPreconnected s\nP : Î± â†’ Î± â†’ Prop\nh : âˆ€ (x : Î±), Membership.mem s x â†’ Filter.Eventually (fun y => And (P x y) (P y x)) (nhdsWithin x s)\nh' : âˆ€ (x y z : Î±), Membership.mem s x â†’ Membership.mem s y â†’ Membership.mem s z â†’ P x y â†’ P y z â†’ P x z\nx y : Î±\nhx : Membership.mem s x\nhy : Membership.mem s y\nâŠ¢ P x y","decl":"/-- In a preconnected set, given a transitive relation `P`, if `P x y` and `P y x` are true\nfor `y` close enough to `x`, then `P x y` holds for all `x, y`. This is a version of the fact\nthat, if an equivalence relation has open classes, then it has a single equivalence class. -/\nlemma IsPreconnected.inductionâ‚‚' {s : Set Î±} (hs : IsPreconnected s) (P : Î± â†’ Î± â†’ Prop)\n    (h : âˆ€ x âˆˆ s, âˆ€á¶  y in ğ“[s] x, P x y âˆ§ P y x)\n    (h' : âˆ€ x y z, x âˆˆ s â†’ y âˆˆ s â†’ z âˆˆ s â†’ P x y â†’ P y z â†’ P x z)\n    {x y : Î±} (hx : x âˆˆ s) (hy : y âˆˆ s) : P x y := by\n  let Q : s â†’ s â†’ Prop := fun a b â†¦ P a b\n  show Q âŸ¨x, hxâŸ© âŸ¨y, hyâŸ©\n  have : PreconnectedSpace s := Subtype.preconnectedSpace hs\n  apply PreconnectedSpace.inductionâ‚‚'\n  Â· rintro âŸ¨x, hxâŸ©\n    have Z := h x hx\n    rwa [nhdsWithin_eq_map_subtype_coe] at Z\n  Â· rintro âŸ¨a, haâŸ© âŸ¨b, hbâŸ© âŸ¨c, hcâŸ© hab hbc\n    exact h' a b c ha hb hc hab hbc\n\n"}
{"name":"IsPreconnected.inductionâ‚‚","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"Î± : Type u\ninstâœ : TopologicalSpace Î±\ns : Set Î±\nhs : IsPreconnected s\nP : Î± â†’ Î± â†’ Prop\nh : âˆ€ (x : Î±), Membership.mem s x â†’ Filter.Eventually (fun y => P x y) (nhdsWithin x s)\nh' : âˆ€ (x y z : Î±), Membership.mem s x â†’ Membership.mem s y â†’ Membership.mem s z â†’ P x y â†’ P y z â†’ P x z\nh'' : âˆ€ (x y : Î±), Membership.mem s x â†’ Membership.mem s y â†’ P x y â†’ P y x\nx y : Î±\nhx : Membership.mem s x\nhy : Membership.mem s y\nâŠ¢ P x y","decl":"/-- In a preconnected set, if a symmetric transitive relation `P x y` is true for `y` close\nenough to `x`, then it holds for all `x, y`. This is a version of the fact that, if an equivalence\nrelation has open classes, then it has a single equivalence class. -/\nlemma IsPreconnected.inductionâ‚‚ {s : Set Î±} (hs : IsPreconnected s) (P : Î± â†’ Î± â†’ Prop)\n    (h : âˆ€ x âˆˆ s, âˆ€á¶  y in ğ“[s] x, P x y)\n    (h' : âˆ€ x y z, x âˆˆ s â†’ y âˆˆ s â†’ z âˆˆ s â†’ P x y â†’ P y z â†’ P x z)\n    (h'' : âˆ€ x y, x âˆˆ s â†’ y âˆˆ s â†’ P x y â†’ P y x)\n    {x y : Î±} (hx : x âˆˆ s) (hy : y âˆˆ s) : P x y := by\n  apply hs.inductionâ‚‚' P (fun z hz â†¦ ?_) h' hx hy\n  filter_upwards [h z hz, self_mem_nhdsWithin] with a ha h'a\n  exact âŸ¨ha, h'' z a hz h'a haâŸ©\n\n"}
{"name":"isPreconnected_iff_subset_of_disjoint","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"Î± : Type u\ninstâœ : TopologicalSpace Î±\ns : Set Î±\nâŠ¢ Iff (IsPreconnected s) (âˆ€ (u v : Set Î±), IsOpen u â†’ IsOpen v â†’ HasSubset.Subset s (Union.union u v) â†’ Eq (Inter.inter s (Inter.inter u v)) EmptyCollection.emptyCollection â†’ Or (HasSubset.Subset s u) (HasSubset.Subset s v))","decl":"/-- A set `s` is preconnected if and only if for every cover by two open sets that are disjoint on\n`s`, it is contained in one of the two covering sets. -/\ntheorem isPreconnected_iff_subset_of_disjoint {s : Set Î±} :\n    IsPreconnected s â†”\n      âˆ€ u v, IsOpen u â†’ IsOpen v â†’ s âŠ† u âˆª v â†’ s âˆ© (u âˆ© v) = âˆ… â†’ s âŠ† u âˆ¨ s âŠ† v := by\n  constructor <;> intro h\n  Â· intro u v hu hv hs huv\n    specialize h u v hu hv hs\n    contrapose! huv\n    simp only [not_subset] at huv\n    rcases huv with âŸ¨âŸ¨x, hxs, hxuâŸ©, âŸ¨y, hys, hyvâŸ©âŸ©\n    have hxv : x âˆˆ v := or_iff_not_imp_left.mp (hs hxs) hxu\n    have hyu : y âˆˆ u := or_iff_not_imp_right.mp (hs hys) hyv\n    exact h âŸ¨y, hys, hyuâŸ© âŸ¨x, hxs, hxvâŸ©\n  Â· intro u v hu hv hs hsu hsv\n    by_contra H\n    specialize h u v hu hv hs (Set.not_nonempty_iff_eq_empty.mp H)\n    apply H\n    cases' h with h h\n    Â· rcases hsv with âŸ¨x, hxs, hxvâŸ©\n      exact âŸ¨x, hxs, âŸ¨h hxs, hxvâŸ©âŸ©\n    Â· rcases hsu with âŸ¨x, hxs, hxuâŸ©\n      exact âŸ¨x, hxs, âŸ¨hxu, h hxsâŸ©âŸ©\n\n"}
{"name":"isConnected_iff_sUnion_disjoint_open","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"Î± : Type u\ninstâœ : TopologicalSpace Î±\ns : Set Î±\nâŠ¢ Iff (IsConnected s) (âˆ€ (U : Finset (Set Î±)), (âˆ€ (u v : Set Î±), Membership.mem U u â†’ Membership.mem U v â†’ (Inter.inter s (Inter.inter u v)).Nonempty â†’ Eq u v) â†’ (âˆ€ (u : Set Î±), Membership.mem U u â†’ IsOpen u) â†’ HasSubset.Subset s (â†‘U).sUnion â†’ Exists fun u => And (Membership.mem U u) (HasSubset.Subset s u))","decl":"/-- A set `s` is connected if and only if\nfor every cover by a finite collection of open sets that are pairwise disjoint on `s`,\nit is contained in one of the members of the collection. -/\ntheorem isConnected_iff_sUnion_disjoint_open {s : Set Î±} :\n    IsConnected s â†”\n      âˆ€ U : Finset (Set Î±), (âˆ€ u v : Set Î±, u âˆˆ U â†’ v âˆˆ U â†’ (s âˆ© (u âˆ© v)).Nonempty â†’ u = v) â†’\n        (âˆ€ u âˆˆ U, IsOpen u) â†’ (s âŠ† â‹ƒâ‚€ â†‘U) â†’ âˆƒ u âˆˆ U, s âŠ† u := by\n  rw [IsConnected, isPreconnected_iff_subset_of_disjoint]\n  classical\n  refine âŸ¨fun âŸ¨hne, hâŸ© U hU hUo hsU => ?_, fun h => âŸ¨?_, fun u v hu hv hs hsuv => ?_âŸ©âŸ©\n  Â· induction U using Finset.induction_on with\n    | empty => exact absurd (by simpa using hsU) hne.not_subset_empty\n    | @insert u U uU IH =>\n      simp only [â† forall_cond_comm, Finset.forall_mem_insert, Finset.exists_mem_insert,\n        Finset.coe_insert, sUnion_insert, implies_true, true_and] at *\n      refine (h _ hUo.1 (â‹ƒâ‚€ â†‘U) (isOpen_sUnion hUo.2) hsU ?_).imp_right ?_\n      Â· refine subset_empty_iff.1 fun x âŸ¨hxs, hxu, v, hvU, hxvâŸ© => ?_\n        exact ne_of_mem_of_not_mem hvU uU (hU.1 v hvU âŸ¨x, hxs, hxu, hxvâŸ©).symm\n      Â· exact IH (fun u hu => (hU.2 u hu).2) hUo.2\n  Â· simpa [subset_empty_iff, nonempty_iff_ne_empty] using h âˆ…\n  Â· rw [â† not_nonempty_iff_eq_empty] at hsuv\n    have := hsuv; rw [inter_comm u] at this\n    simpa [*, or_imp, forall_and] using h {u, v}\n\n-- Porting note: `IsPreconnected.subset_isClopen` moved up from here\n\n"}
{"name":"disjoint_or_subset_of_isClopen","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"Î± : Type u\ninstâœ : TopologicalSpace Î±\ns t : Set Î±\nhs : IsPreconnected s\nht : IsClopen t\nâŠ¢ Or (Disjoint s t) (HasSubset.Subset s t)","decl":"/-- Preconnected sets are either contained in or disjoint to any given clopen set. -/\ntheorem disjoint_or_subset_of_isClopen {s t : Set Î±} (hs : IsPreconnected s) (ht : IsClopen t) :\n    Disjoint s t âˆ¨ s âŠ† t :=\n  (disjoint_or_nonempty_inter s t).imp_right <| hs.subset_isClopen ht\n\n"}
{"name":"isPreconnected_iff_subset_of_disjoint_closed","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"Î± : Type u\ninstâœ : TopologicalSpace Î±\ns : Set Î±\nâŠ¢ Iff (IsPreconnected s) (âˆ€ (u v : Set Î±), IsClosed u â†’ IsClosed v â†’ HasSubset.Subset s (Union.union u v) â†’ Eq (Inter.inter s (Inter.inter u v)) EmptyCollection.emptyCollection â†’ Or (HasSubset.Subset s u) (HasSubset.Subset s v))","decl":"/-- A set `s` is preconnected if and only if\nfor every cover by two closed sets that are disjoint on `s`,\nit is contained in one of the two covering sets. -/\ntheorem isPreconnected_iff_subset_of_disjoint_closed :\n    IsPreconnected s â†”\n      âˆ€ u v, IsClosed u â†’ IsClosed v â†’ s âŠ† u âˆª v â†’ s âˆ© (u âˆ© v) = âˆ… â†’ s âŠ† u âˆ¨ s âŠ† v := by\n  constructor <;> intro h\n  Â· intro u v hu hv hs huv\n    rw [isPreconnected_closed_iff] at h\n    specialize h u v hu hv hs\n    contrapose! huv\n    simp only [not_subset] at huv\n    rcases huv with âŸ¨âŸ¨x, hxs, hxuâŸ©, âŸ¨y, hys, hyvâŸ©âŸ©\n    have hxv : x âˆˆ v := or_iff_not_imp_left.mp (hs hxs) hxu\n    have hyu : y âˆˆ u := or_iff_not_imp_right.mp (hs hys) hyv\n    exact h âŸ¨y, hys, hyuâŸ© âŸ¨x, hxs, hxvâŸ©\n  Â· rw [isPreconnected_closed_iff]\n    intro u v hu hv hs hsu hsv\n    by_contra H\n    specialize h u v hu hv hs (Set.not_nonempty_iff_eq_empty.mp H)\n    apply H\n    cases' h with h h\n    Â· rcases hsv with âŸ¨x, hxs, hxvâŸ©\n      exact âŸ¨x, hxs, âŸ¨h hxs, hxvâŸ©âŸ©\n    Â· rcases hsu with âŸ¨x, hxs, hxuâŸ©\n      exact âŸ¨x, hxs, âŸ¨hxu, h hxsâŸ©âŸ©\n\n"}
{"name":"isPreconnected_iff_subset_of_fully_disjoint_closed","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"Î± : Type u\ninstâœ : TopologicalSpace Î±\ns : Set Î±\nhs : IsClosed s\nâŠ¢ Iff (IsPreconnected s) (âˆ€ (u v : Set Î±), IsClosed u â†’ IsClosed v â†’ HasSubset.Subset s (Union.union u v) â†’ Disjoint u v â†’ Or (HasSubset.Subset s u) (HasSubset.Subset s v))","decl":"/-- A closed set `s` is preconnected if and only if for every cover by two closed sets that are\ndisjoint, it is contained in one of the two covering sets. -/\ntheorem isPreconnected_iff_subset_of_fully_disjoint_closed {s : Set Î±} (hs : IsClosed s) :\n    IsPreconnected s â†”\n      âˆ€ u v, IsClosed u â†’ IsClosed v â†’ s âŠ† u âˆª v â†’ Disjoint u v â†’ s âŠ† u âˆ¨ s âŠ† v := by\n  refine isPreconnected_iff_subset_of_disjoint_closed.trans âŸ¨?_, ?_âŸ© <;> intro H u v hu hv hss huv\n  Â· apply H u v hu hv hss\n    rw [huv.inter_eq, inter_empty]\n  have H1 := H (u âˆ© s) (v âˆ© s)\n  rw [subset_inter_iff, subset_inter_iff] at H1\n  simp only [Subset.refl, and_true] at H1\n  apply H1 (hu.inter hs) (hv.inter hs)\n  Â· rw [â† union_inter_distrib_right]\n    exact subset_inter hss Subset.rfl\n  Â· rwa [disjoint_iff_inter_eq_empty, â† inter_inter_distrib_right, inter_comm]\n\n"}
{"name":"IsClopen.connectedComponent_subset","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"Î± : Type u\ninstâœ : TopologicalSpace Î±\ns : Set Î±\nx : Î±\nhs : IsClopen s\nhx : Membership.mem s x\nâŠ¢ HasSubset.Subset (connectedComponent x) s","decl":"theorem IsClopen.connectedComponent_subset {x} (hs : IsClopen s) (hx : x âˆˆ s) :\n    connectedComponent x âŠ† s :=\n  isPreconnected_connectedComponent.subset_isClopen hs âŸ¨x, mem_connectedComponent, hxâŸ©\n\n"}
{"name":"connectedComponent_subset_iInter_isClopen","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"Î± : Type u\ninstâœ : TopologicalSpace Î±\nx : Î±\nâŠ¢ HasSubset.Subset (connectedComponent x) (Set.iInter fun Z => â†‘Z)","decl":"/-- The connected component of a point is always a subset of the intersection of all its clopen\nneighbourhoods. -/\ntheorem connectedComponent_subset_iInter_isClopen {x : Î±} :\n    connectedComponent x âŠ† â‹‚ Z : { Z : Set Î± // IsClopen Z âˆ§ x âˆˆ Z }, Z :=\n  subset_iInter fun Z => Z.2.1.connectedComponent_subset Z.2.2\n\n"}
{"name":"IsClopen.biUnion_connectedComponent_eq","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"Î± : Type u\ninstâœ : TopologicalSpace Î±\nZ : Set Î±\nh : IsClopen Z\nâŠ¢ Eq (Set.iUnion fun x => Set.iUnion fun h => connectedComponent x) Z","decl":"/-- A clopen set is the union of its connected components. -/\ntheorem IsClopen.biUnion_connectedComponent_eq {Z : Set Î±} (h : IsClopen Z) :\n    â‹ƒ x âˆˆ Z, connectedComponent x = Z :=\n  Subset.antisymm (iUnionâ‚‚_subset fun _ => h.connectedComponent_subset) fun _ h =>\n    mem_iUnionâ‚‚_of_mem h mem_connectedComponent\n\n"}
{"name":"IsClopen.biUnion_connectedComponentIn","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"X : Type u_3\ninstâœ : TopologicalSpace X\nu v : Set X\nhu : IsClopen (Set.preimage Subtype.val u)\nhuvâ‚ : HasSubset.Subset u v\nâŠ¢ Eq u (Set.iUnion fun x => Set.iUnion fun h => connectedComponentIn v x)","decl":"open Set.Notation in\n/-- If `u v : Set X` and `u âŠ† v` is clopen in `v`, then `u` is the union of the connected\ncomponents of `v` in `X` which intersect `u`. -/\nlemma IsClopen.biUnion_connectedComponentIn {X : Type*} [TopologicalSpace X] {u v : Set X}\n    (hu : IsClopen (v â†“âˆ© u)) (huvâ‚ : u âŠ† v) :\n    u = â‹ƒ x âˆˆ u, connectedComponentIn v x := by\n  have := congr(((â†‘) : Set v â†’ Set X) $(hu.biUnion_connectedComponent_eq.symm))\n  simp only [Subtype.image_preimage_coe, mem_preimage, iUnion_coe_set, image_val_iUnion,\n    inter_eq_right.mpr huvâ‚] at this\n  nth_rw 1 [this]\n  congr! 2 with x hx\n  simp only [â† connectedComponentIn_eq_image]\n  exact le_antisymm (iUnion_subset fun _ â†¦ le_rfl) <|\n    iUnion_subset fun hx â†¦ subset_iUnionâ‚‚_of_subset (huvâ‚ hx) hx le_rfl\n\n"}
{"name":"preimage_connectedComponent_connected","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalSpace Î²\nf : Î± â†’ Î²\nconnected_fibers : âˆ€ (t : Î²), IsConnected (Set.preimage f (Singleton.singleton t))\nhcl : âˆ€ (T : Set Î²), Iff (IsClosed T) (IsClosed (Set.preimage f T))\nt : Î²\nâŠ¢ IsConnected (Set.preimage f (connectedComponent t))","decl":"/-- The preimage of a connected component is preconnected if the function has connected fibers\nand a subset is closed iff the preimage is. -/\ntheorem preimage_connectedComponent_connected\n    (connected_fibers : âˆ€ t : Î², IsConnected (f â»Â¹' {t}))\n    (hcl : âˆ€ T : Set Î², IsClosed T â†” IsClosed (f â»Â¹' T)) (t : Î²) :\n    IsConnected (f â»Â¹' connectedComponent t) := by\n  -- The following proof is essentially https://stacks.math.columbia.edu/tag/0377\n  -- although the statement is slightly different\n  have hf : Surjective f := Surjective.of_comp fun t : Î² => (connected_fibers t).1\n  refine âŸ¨Nonempty.preimage connectedComponent_nonempty hf, ?_âŸ©\n  have hT : IsClosed (f â»Â¹' connectedComponent t) :=\n    (hcl (connectedComponent t)).1 isClosed_connectedComponent\n  -- To show it's preconnected we decompose (f â»Â¹' connectedComponent t) as a subset of two\n  -- closed disjoint sets in Î±. We want to show that it's a subset of either.\n  rw [isPreconnected_iff_subset_of_fully_disjoint_closed hT]\n  intro u v hu hv huv uv_disj\n  -- To do this we decompose connectedComponent t into Tâ‚ and Tâ‚‚\n  -- we will show that connectedComponent t is a subset of either and hence\n  -- (f â»Â¹' connectedComponent t) is a subset of u or v\n  let Tâ‚ := { t' âˆˆ connectedComponent t | f â»Â¹' {t'} âŠ† u }\n  let Tâ‚‚ := { t' âˆˆ connectedComponent t | f â»Â¹' {t'} âŠ† v }\n  have fiber_decomp : âˆ€ t' âˆˆ connectedComponent t, f â»Â¹' {t'} âŠ† u âˆ¨ f â»Â¹' {t'} âŠ† v := by\n    intro t' ht'\n    apply isPreconnected_iff_subset_of_disjoint_closed.1 (connected_fibers t').2 u v hu hv\n    Â· exact Subset.trans (preimage_mono (singleton_subset_iff.2 ht')) huv\n    rw [uv_disj.inter_eq, inter_empty]\n  have Tâ‚_u : f â»Â¹' Tâ‚ = f â»Â¹' connectedComponent t âˆ© u := by\n    apply eq_of_subset_of_subset\n    Â· rw [â† biUnion_preimage_singleton]\n      refine iUnionâ‚‚_subset fun t' ht' => subset_inter ?_ ht'.2\n      rw [hf.preimage_subset_preimage_iff, singleton_subset_iff]\n      exact ht'.1\n    rintro a âŸ¨hat, hauâŸ©\n    constructor\n    Â· exact mem_preimage.1 hat\n    refine (fiber_decomp (f a) (mem_preimage.1 hat)).resolve_right fun h => ?_\n    exact uv_disj.subset_compl_right hau (h rfl)\n  -- This proof is exactly the same as the above (modulo some symmetry)\n  have Tâ‚‚_v : f â»Â¹' Tâ‚‚ = f â»Â¹' connectedComponent t âˆ© v := by\n    apply eq_of_subset_of_subset\n    Â· rw [â† biUnion_preimage_singleton]\n      refine iUnionâ‚‚_subset fun t' ht' => subset_inter ?_ ht'.2\n      rw [hf.preimage_subset_preimage_iff, singleton_subset_iff]\n      exact ht'.1\n    rintro a âŸ¨hat, havâŸ©\n    constructor\n    Â· exact mem_preimage.1 hat\n    Â· refine (fiber_decomp (f a) (mem_preimage.1 hat)).resolve_left fun h => ?_\n      exact uv_disj.subset_compl_left hav (h rfl)\n  -- Now we show Tâ‚, Tâ‚‚ are closed, cover connectedComponent t and are disjoint.\n  have hTâ‚ : IsClosed Tâ‚ := (hcl Tâ‚).2 (Tâ‚_u.symm â–¸ IsClosed.inter hT hu)\n  have hTâ‚‚ : IsClosed Tâ‚‚ := (hcl Tâ‚‚).2 (Tâ‚‚_v.symm â–¸ IsClosed.inter hT hv)\n  have T_decomp : connectedComponent t âŠ† Tâ‚ âˆª Tâ‚‚ := fun t' ht' => by\n    rw [mem_union t' Tâ‚ Tâ‚‚]\n    cases' fiber_decomp t' ht' with htu htv\n    Â· left\n      exact âŸ¨ht', htuâŸ©\n    right\n    exact âŸ¨ht', htvâŸ©\n  have T_disjoint : Disjoint Tâ‚ Tâ‚‚ := by\n    refine Disjoint.of_preimage hf ?_\n    rw [Tâ‚_u, Tâ‚‚_v, disjoint_iff_inter_eq_empty, â† inter_inter_distrib_left, uv_disj.inter_eq,\n      inter_empty]\n  -- Now we do cases on whether (connectedComponent t) is a subset of Tâ‚ or Tâ‚‚ to show\n  -- that the preimage is a subset of u or v.\n  cases' (isPreconnected_iff_subset_of_fully_disjoint_closed isClosed_connectedComponent).1\n    isPreconnected_connectedComponent Tâ‚ Tâ‚‚ hTâ‚ hTâ‚‚ T_decomp T_disjoint with h h\n  Â· left\n    rw [Subset.antisymm_iff] at Tâ‚_u\n    suffices f â»Â¹' connectedComponent t âŠ† f â»Â¹' Tâ‚\n      from (this.trans Tâ‚_u.1).trans inter_subset_right\n    exact preimage_mono h\n  Â· right\n    rw [Subset.antisymm_iff] at Tâ‚‚_v\n    suffices f â»Â¹' connectedComponent t âŠ† f â»Â¹' Tâ‚‚\n      from (this.trans Tâ‚‚_v.1).trans inter_subset_right\n    exact preimage_mono h\n\n"}
{"name":"Topology.IsQuotientMap.preimage_connectedComponent","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalSpace Î²\nf : Î± â†’ Î²\nhf : Topology.IsQuotientMap f\nh_fibers : âˆ€ (y : Î²), IsConnected (Set.preimage f (Singleton.singleton y))\na : Î±\nâŠ¢ Eq (Set.preimage f (connectedComponent (f a))) (connectedComponent a)","decl":"theorem Topology.IsQuotientMap.preimage_connectedComponent (hf : IsQuotientMap f)\n    (h_fibers : âˆ€ y : Î², IsConnected (f â»Â¹' {y})) (a : Î±) :\n    f â»Â¹' connectedComponent (f a) = connectedComponent a :=\n  ((preimage_connectedComponent_connected h_fibers (fun _ => hf.isClosed_preimage.symm)\n      _).subset_connectedComponent mem_connectedComponent).antisymm\n    (hf.continuous.mapsTo_connectedComponent a)\n\n"}
{"name":"QuotientMap.preimage_connectedComponent","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalSpace Î²\nf : Î± â†’ Î²\nhf : Topology.IsQuotientMap f\nh_fibers : âˆ€ (y : Î²), IsConnected (Set.preimage f (Singleton.singleton y))\na : Î±\nâŠ¢ Eq (Set.preimage f (connectedComponent (f a))) (connectedComponent a)","decl":"@[deprecated (since := \"2024-10-22\")]\nalias QuotientMap.preimage_connectedComponent := IsQuotientMap.preimage_connectedComponent\n\n"}
{"name":"Topology.IsQuotientMap.image_connectedComponent","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalSpace Î²\nf : Î± â†’ Î²\nhf : Topology.IsQuotientMap f\nh_fibers : âˆ€ (y : Î²), IsConnected (Set.preimage f (Singleton.singleton y))\na : Î±\nâŠ¢ Eq (Set.image f (connectedComponent a)) (connectedComponent (f a))","decl":"lemma Topology.IsQuotientMap.image_connectedComponent {f : Î± â†’ Î²} (hf : IsQuotientMap f)\n    (h_fibers : âˆ€ y : Î², IsConnected (f â»Â¹' {y})) (a : Î±) :\n    f '' connectedComponent a = connectedComponent (f a) := by\n  rw [â† hf.preimage_connectedComponent h_fibers, image_preimage_eq _ hf.surjective]\n\n"}
{"name":"QuotientMap.image_connectedComponent","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalSpace Î²\nf : Î± â†’ Î²\nhf : Topology.IsQuotientMap f\nh_fibers : âˆ€ (y : Î²), IsConnected (Set.preimage f (Singleton.singleton y))\na : Î±\nâŠ¢ Eq (Set.image f (connectedComponent a)) (connectedComponent (f a))","decl":"@[deprecated (since := \"2024-10-22\")]\nalias QuotientMap.image_connectedComponent := IsQuotientMap.image_connectedComponent\n\n"}
{"name":"ConnectedComponents.coe_eq_coe","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"Î± : Type u\ninstâœ : TopologicalSpace Î±\nx y : Î±\nâŠ¢ Iff (Eq (ConnectedComponents.mk x) (ConnectedComponents.mk y)) (Eq (connectedComponent x) (connectedComponent y))","decl":"@[simp]\ntheorem coe_eq_coe {x y : Î±} :\n    (x : ConnectedComponents Î±) = y â†” connectedComponent x = connectedComponent y :=\n  Quotient.eq''\n\n"}
{"name":"ConnectedComponents.coe_ne_coe","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"Î± : Type u\ninstâœ : TopologicalSpace Î±\nx y : Î±\nâŠ¢ Iff (Ne (ConnectedComponents.mk x) (ConnectedComponents.mk y)) (Ne (connectedComponent x) (connectedComponent y))","decl":"theorem coe_ne_coe {x y : Î±} :\n    (x : ConnectedComponents Î±) â‰  y â†” connectedComponent x â‰  connectedComponent y :=\n  coe_eq_coe.not\n\n"}
{"name":"ConnectedComponents.coe_eq_coe'","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"Î± : Type u\ninstâœ : TopologicalSpace Î±\nx y : Î±\nâŠ¢ Iff (Eq (ConnectedComponents.mk x) (ConnectedComponents.mk y)) (Membership.mem (connectedComponent y) x)","decl":"theorem coe_eq_coe' {x y : Î±} : (x : ConnectedComponents Î±) = y â†” x âˆˆ connectedComponent y :=\n  coe_eq_coe.trans connectedComponent_eq_iff_mem\n\n"}
{"name":"ConnectedComponents.surjective_coe","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"Î± : Type u\ninstâœ : TopologicalSpace Î±\nâŠ¢ Function.Surjective ConnectedComponents.mk","decl":"theorem surjective_coe : Surjective (mk : Î± â†’ ConnectedComponents Î±) :=\n  Quot.mk_surjective\n\n"}
{"name":"ConnectedComponents.isQuotientMap_coe","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"Î± : Type u\ninstâœ : TopologicalSpace Î±\nâŠ¢ Topology.IsQuotientMap ConnectedComponents.mk","decl":"theorem isQuotientMap_coe : IsQuotientMap (mk : Î± â†’ ConnectedComponents Î±) :=\n  isQuotientMap_quot_mk\n\n"}
{"name":"ConnectedComponents.quotientMap_coe","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"Î± : Type u\ninstâœ : TopologicalSpace Î±\nâŠ¢ Topology.IsQuotientMap ConnectedComponents.mk","decl":"@[deprecated (since := \"2024-10-22\")]\nalias quotientMap_coe := isQuotientMap_coe\n\n"}
{"name":"ConnectedComponents.continuous_coe","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"Î± : Type u\ninstâœ : TopologicalSpace Î±\nâŠ¢ Continuous ConnectedComponents.mk","decl":"@[continuity]\ntheorem continuous_coe : Continuous (mk : Î± â†’ ConnectedComponents Î±) :=\n  isQuotientMap_coe.continuous\n\n"}
{"name":"ConnectedComponents.range_coe","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"Î± : Type u\ninstâœ : TopologicalSpace Î±\nâŠ¢ Eq (Set.range ConnectedComponents.mk) Set.univ","decl":"@[simp]\ntheorem range_coe : range (mk : Î± â†’ ConnectedComponents Î±) = univ :=\n  surjective_coe.range_eq\n\n"}
{"name":"connectedComponents_preimage_singleton","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"Î± : Type u\ninstâœ : TopologicalSpace Î±\nx : Î±\nâŠ¢ Eq (Set.preimage ConnectedComponents.mk (Singleton.singleton (ConnectedComponents.mk x))) (connectedComponent x)","decl":"/-- The preimage of a singleton in `connectedComponents` is the connected component\nof an element in the equivalence class. -/\ntheorem connectedComponents_preimage_singleton {x : Î±} :\n    (â†‘) â»Â¹' ({â†‘x} : Set (ConnectedComponents Î±)) = connectedComponent x := by\n  ext y\n  rw [mem_preimage, mem_singleton_iff, ConnectedComponents.coe_eq_coe']\n\n"}
{"name":"connectedComponents_preimage_image","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"Î± : Type u\ninstâœ : TopologicalSpace Î±\nU : Set Î±\nâŠ¢ Eq (Set.preimage ConnectedComponents.mk (Set.image ConnectedComponents.mk U)) (Set.iUnion fun x => Set.iUnion fun h => connectedComponent x)","decl":"/-- The preimage of the image of a set under the quotient map to `connectedComponents Î±`\nis the union of the connected components of the elements in it. -/\ntheorem connectedComponents_preimage_image (U : Set Î±) :\n    (â†‘) â»Â¹' ((â†‘) '' U : Set (ConnectedComponents Î±)) = â‹ƒ x âˆˆ U, connectedComponent x := by\n  simp only [connectedComponents_preimage_singleton, preimage_iUnionâ‚‚, image_eq_iUnion]\n\n\n\n"}
{"name":"isPreconnected_of_forall_constant","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"Î± : Type u\ninstâœ : TopologicalSpace Î±\ns : Set Î±\nhs : âˆ€ (f : Î± â†’ Bool), ContinuousOn f s â†’ âˆ€ (x : Î±), Membership.mem s x â†’ âˆ€ (y : Î±), Membership.mem s y â†’ Eq (f x) (f y)\nâŠ¢ IsPreconnected s","decl":"/-- If every map to `Bool` (a discrete two-element space), that is\ncontinuous on a set `s`, is constant on s, then s is preconnected -/\ntheorem isPreconnected_of_forall_constant {s : Set Î±}\n    (hs : âˆ€ f : Î± â†’ Bool, ContinuousOn f s â†’ âˆ€ x âˆˆ s, âˆ€ y âˆˆ s, f x = f y) : IsPreconnected s := by\n  unfold IsPreconnected\n  by_contra!\n  rcases this with âŸ¨u, v, u_op, v_op, hsuv, âŸ¨x, x_in_s, x_in_uâŸ©, âŸ¨y, y_in_s, y_in_vâŸ©, HâŸ©\n  have hy : y âˆ‰ u := fun y_in_u => eq_empty_iff_forall_not_mem.mp H y âŸ¨y_in_s, âŸ¨y_in_u, y_in_vâŸ©âŸ©\n  have : ContinuousOn u.boolIndicator s := by\n    apply (continuousOn_boolIndicator_iff_isClopen _ _).mpr âŸ¨_, _âŸ©\n    Â· rw [preimage_subtype_coe_eq_compl hsuv H]\n      exact (v_op.preimage continuous_subtype_val).isClosed_compl\n    Â· exact u_op.preimage continuous_subtype_val\n  simpa [(u.mem_iff_boolIndicator _).mp x_in_u, (u.not_mem_iff_boolIndicator _).mp hy] using\n    hs _ this x x_in_s y y_in_s\n\n"}
{"name":"preconnectedSpace_of_forall_constant","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"Î± : Type u\ninstâœ : TopologicalSpace Î±\nhs : âˆ€ (f : Î± â†’ Bool), Continuous f â†’ âˆ€ (x y : Î±), Eq (f x) (f y)\nâŠ¢ PreconnectedSpace Î±","decl":"/-- A `PreconnectedSpace` version of `isPreconnected_of_forall_constant` -/\ntheorem preconnectedSpace_of_forall_constant\n    (hs : âˆ€ f : Î± â†’ Bool, Continuous f â†’ âˆ€ x y, f x = f y) : PreconnectedSpace Î± :=\n  âŸ¨isPreconnected_of_forall_constant fun f hf x _ y _ =>\n      hs f (continuous_iff_continuousOn_univ.mpr hf) x yâŸ©\n"}
