{"name":"IsPreconnected.subset_isClopen","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\ns t : Set α\nhs : IsPreconnected s\nht : IsClopen t\nhne : (Inter.inter s t).Nonempty\n⊢ HasSubset.Subset s t","decl":"/-- Preconnected sets are either contained in or disjoint to any given clopen set. -/\ntheorem IsPreconnected.subset_isClopen {s t : Set α} (hs : IsPreconnected s) (ht : IsClopen t)\n    (hne : (s ∩ t).Nonempty) : s ⊆ t :=\n  hs.subset_left_of_subset_union ht.isOpen ht.compl.isOpen disjoint_compl_right (by simp) hne\n\n"}
{"name":"Sigma.isConnected_iff","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"ι : Type u_1\nπ : ι → Type u_2\ninst✝ : (i : ι) → TopologicalSpace (π i)\ns : Set (Sigma fun i => π i)\n⊢ Iff (IsConnected s) (Exists fun i => Exists fun t => And (IsConnected t) (Eq s (Set.image (Sigma.mk i) t)))","decl":"theorem Sigma.isConnected_iff [∀ i, TopologicalSpace (π i)] {s : Set (Σi, π i)} :\n    IsConnected s ↔ ∃ i t, IsConnected t ∧ s = Sigma.mk i '' t := by\n  refine ⟨fun hs => ?_, ?_⟩\n  · obtain ⟨⟨i, x⟩, hx⟩ := hs.nonempty\n    have : s ⊆ range (Sigma.mk i) :=\n      hs.isPreconnected.subset_isClopen isClopen_range_sigmaMk ⟨⟨i, x⟩, hx, x, rfl⟩\n    exact ⟨i, Sigma.mk i ⁻¹' s, hs.preimage_of_isOpenMap sigma_mk_injective isOpenMap_sigmaMk this,\n      (Set.image_preimage_eq_of_subset this).symm⟩\n  · rintro ⟨i, t, ht, rfl⟩\n    exact ht.image _ continuous_sigmaMk.continuousOn\n\n"}
{"name":"Sigma.isPreconnected_iff","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"ι : Type u_1\nπ : ι → Type u_2\nhι : Nonempty ι\ninst✝ : (i : ι) → TopologicalSpace (π i)\ns : Set (Sigma fun i => π i)\n⊢ Iff (IsPreconnected s) (Exists fun i => Exists fun t => And (IsPreconnected t) (Eq s (Set.image (Sigma.mk i) t)))","decl":"theorem Sigma.isPreconnected_iff [hι : Nonempty ι] [∀ i, TopologicalSpace (π i)]\n    {s : Set (Σi, π i)} : IsPreconnected s ↔ ∃ i t, IsPreconnected t ∧ s = Sigma.mk i '' t := by\n  refine ⟨fun hs => ?_, ?_⟩\n  · obtain rfl | h := s.eq_empty_or_nonempty\n    · exact ⟨Classical.choice hι, ∅, isPreconnected_empty, (Set.image_empty _).symm⟩\n    · obtain ⟨a, t, ht, rfl⟩ := Sigma.isConnected_iff.1 ⟨h, hs⟩\n      exact ⟨a, t, ht.isPreconnected, rfl⟩\n  · rintro ⟨a, t, ht, rfl⟩\n    exact ht.image _ continuous_sigmaMk.continuousOn\n\n"}
{"name":"Sum.isConnected_iff","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\ns : Set (Sum α β)\n⊢ Iff (IsConnected s) (Or (Exists fun t => And (IsConnected t) (Eq s (Set.image Sum.inl t))) (Exists fun t => And (IsConnected t) (Eq s (Set.image Sum.inr t))))","decl":"theorem Sum.isConnected_iff [TopologicalSpace β] {s : Set (α ⊕ β)} :\n    IsConnected s ↔\n      (∃ t, IsConnected t ∧ s = Sum.inl '' t) ∨ ∃ t, IsConnected t ∧ s = Sum.inr '' t := by\n  refine ⟨fun hs => ?_, ?_⟩\n  · obtain ⟨x | x, hx⟩ := hs.nonempty\n    · have h : s ⊆ range Sum.inl :=\n        hs.isPreconnected.subset_isClopen isClopen_range_inl ⟨.inl x, hx, x, rfl⟩\n      refine Or.inl ⟨Sum.inl ⁻¹' s, ?_, ?_⟩\n      · exact hs.preimage_of_isOpenMap Sum.inl_injective isOpenMap_inl h\n      · exact (image_preimage_eq_of_subset h).symm\n    · have h : s ⊆ range Sum.inr :=\n        hs.isPreconnected.subset_isClopen isClopen_range_inr ⟨.inr x, hx, x, rfl⟩\n      refine Or.inr ⟨Sum.inr ⁻¹' s, ?_, ?_⟩\n      · exact hs.preimage_of_isOpenMap Sum.inr_injective isOpenMap_inr h\n      · exact (image_preimage_eq_of_subset h).symm\n  · rintro (⟨t, ht, rfl⟩ | ⟨t, ht, rfl⟩)\n    · exact ht.image _ continuous_inl.continuousOn\n    · exact ht.image _ continuous_inr.continuousOn\n\n"}
{"name":"Sum.isPreconnected_iff","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\ns : Set (Sum α β)\n⊢ Iff (IsPreconnected s) (Or (Exists fun t => And (IsPreconnected t) (Eq s (Set.image Sum.inl t))) (Exists fun t => And (IsPreconnected t) (Eq s (Set.image Sum.inr t))))","decl":"theorem Sum.isPreconnected_iff [TopologicalSpace β] {s : Set (α ⊕ β)} :\n    IsPreconnected s ↔\n      (∃ t, IsPreconnected t ∧ s = Sum.inl '' t) ∨ ∃ t, IsPreconnected t ∧ s = Sum.inr '' t := by\n  refine ⟨fun hs => ?_, ?_⟩\n  · obtain rfl | h := s.eq_empty_or_nonempty\n    · exact Or.inl ⟨∅, isPreconnected_empty, (Set.image_empty _).symm⟩\n    obtain ⟨t, ht, rfl⟩ | ⟨t, ht, rfl⟩ := Sum.isConnected_iff.1 ⟨h, hs⟩\n    · exact Or.inl ⟨t, ht.isPreconnected, rfl⟩\n    · exact Or.inr ⟨t, ht.isPreconnected, rfl⟩\n  · rintro (⟨t, ht, rfl⟩ | ⟨t, ht, rfl⟩)\n    · exact ht.image _ continuous_inl.continuousOn\n    · exact ht.image _ continuous_inr.continuousOn\n\n"}
{"name":"Continuous.exists_lift_sigma","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"α : Type u\nι : Type u_1\nπ : ι → Type u_2\ninst✝² : TopologicalSpace α\ninst✝¹ : ConnectedSpace α\ninst✝ : (i : ι) → TopologicalSpace (π i)\nf : α → Sigma fun i => π i\nhf : Continuous f\n⊢ Exists fun i => Exists fun g => And (Continuous g) (Eq f (Function.comp (Sigma.mk i) g))","decl":"/-- A continuous map from a connected space to a disjoint union `Σ i, π i` can be lifted to one of\nthe components `π i`. See also `ContinuousMap.exists_lift_sigma` for a version with bundled\n`ContinuousMap`s. -/\ntheorem Continuous.exists_lift_sigma [ConnectedSpace α] [∀ i, TopologicalSpace (π i)]\n    {f : α → Σ i, π i} (hf : Continuous f) :\n    ∃ (i : ι) (g : α → π i), Continuous g ∧ f = Sigma.mk i ∘ g := by\n  obtain ⟨i, hi⟩ : ∃ i, range f ⊆ range (.mk i) := by\n    rcases Sigma.isConnected_iff.1 (isConnected_range hf) with ⟨i, s, -, hs⟩\n    exact ⟨i, hs.trans_subset (image_subset_range _ _)⟩\n  rcases range_subset_range_iff_exists_comp.1 hi with ⟨g, rfl⟩\n  refine ⟨i, g, ?_, rfl⟩\n  rwa [← IsEmbedding.sigmaMk.continuous_iff] at hf\n\n"}
{"name":"nonempty_inter","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"α : Type u\ninst✝¹ : TopologicalSpace α\ninst✝ : PreconnectedSpace α\ns t : Set α\na✝⁴ : IsOpen s\na✝³ : IsOpen t\na✝² : Eq (Union.union s t) Set.univ\na✝¹ : s.Nonempty\na✝ : t.Nonempty\n⊢ (Inter.inter s t).Nonempty","decl":"theorem nonempty_inter [PreconnectedSpace α] {s t : Set α} :\n    IsOpen s → IsOpen t → s ∪ t = univ → s.Nonempty → t.Nonempty → (s ∩ t).Nonempty := by\n  simpa only [univ_inter, univ_subset_iff] using @PreconnectedSpace.isPreconnected_univ α _ _ s t\n\n"}
{"name":"isClopen_iff","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"α : Type u\ninst✝¹ : TopologicalSpace α\ninst✝ : PreconnectedSpace α\ns : Set α\n⊢ Iff (IsClopen s) (Or (Eq s EmptyCollection.emptyCollection) (Eq s Set.univ))","decl":"theorem isClopen_iff [PreconnectedSpace α] {s : Set α} : IsClopen s ↔ s = ∅ ∨ s = univ :=\n  ⟨fun hs =>\n    by_contradiction fun h =>\n      have h1 : s ≠ ∅ ∧ sᶜ ≠ ∅ :=\n        ⟨mt Or.inl h,\n          mt (fun h2 => Or.inr <| (by rw [← compl_compl s, h2, compl_empty] : s = univ)) h⟩\n      let ⟨_, h2, h3⟩ :=\n        nonempty_inter hs.2 hs.1.isOpen_compl (union_compl_self s) (nonempty_iff_ne_empty.2 h1.1)\n          (nonempty_iff_ne_empty.2 h1.2)\n      h3 h2,\n    by rintro (rfl | rfl) <;> [exact isClopen_empty; exact isClopen_univ]⟩\n\n"}
{"name":"IsClopen.eq_univ","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"α : Type u\ninst✝¹ : TopologicalSpace α\ninst✝ : PreconnectedSpace α\ns : Set α\nh' : IsClopen s\nh : s.Nonempty\n⊢ Eq s Set.univ","decl":"theorem IsClopen.eq_univ [PreconnectedSpace α] {s : Set α} (h' : IsClopen s) (h : s.Nonempty) :\n    s = univ :=\n  (isClopen_iff.mp h').resolve_left h.ne_empty\n\n"}
{"name":"isClopen_preimage_val","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"X : Type u_3\ninst✝ : TopologicalSpace X\nu v : Set X\nhu : IsOpen u\nhuv : Disjoint (frontier u) v\n⊢ IsClopen (Set.preimage Subtype.val u)","decl":"open Set.Notation in\nlemma isClopen_preimage_val {X : Type*} [TopologicalSpace X] {u v : Set X}\n    (hu : IsOpen u) (huv : Disjoint (frontier u) v) : IsClopen (v ↓∩ u) := by\n  refine ⟨?_, isOpen_induced hu (f := Subtype.val)⟩\n  refine isClosed_induced_iff.mpr ⟨closure u, isClosed_closure, ?_⟩\n  apply image_val_injective\n  simp only [Subtype.image_preimage_coe]\n  rw [closure_eq_self_union_frontier, inter_union_distrib_left, inter_comm _ (frontier u),\n    huv.inter_eq, union_empty]\n\n"}
{"name":"subsingleton_of_disjoint_isClopen","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"α : Type u\nι : Type u_1\ninst✝¹ : TopologicalSpace α\ninst✝ : PreconnectedSpace α\ns : ι → Set α\nh_nonempty : ∀ (i : ι), (s i).Nonempty\nh_disj : Pairwise (Function.onFun Disjoint s)\nh_clopen : ∀ (i : ι), IsClopen (s i)\n⊢ Subsingleton ι","decl":"/-- In a preconnected space, any disjoint family of non-empty clopen subsets has at most one\nelement. -/\nlemma subsingleton_of_disjoint_isClopen\n    (h_clopen : ∀ i, IsClopen (s i)) :\n    Subsingleton ι := by\n  replace h_nonempty : ∀ i, s i ≠ ∅ := by intro i; rw [← nonempty_iff_ne_empty]; exact h_nonempty i\n  rw [← not_nontrivial_iff_subsingleton]\n  by_contra contra\n  obtain ⟨i, j, h_ne⟩ := contra\n  replace h_ne : s i ∩ s j = ∅ := by\n    simpa only [← bot_eq_empty, eq_bot_iff, ← inf_eq_inter, ← disjoint_iff_inf_le] using h_disj h_ne\n  cases' isClopen_iff.mp (h_clopen i) with hi hi\n  · exact h_nonempty i hi\n  · rw [hi, univ_inter] at h_ne\n    exact h_nonempty j h_ne\n\n"}
{"name":"subsingleton_of_disjoint_isOpen_iUnion_eq_univ","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"α : Type u\nι : Type u_1\ninst✝¹ : TopologicalSpace α\ninst✝ : PreconnectedSpace α\ns : ι → Set α\nh_nonempty : ∀ (i : ι), (s i).Nonempty\nh_disj : Pairwise (Function.onFun Disjoint s)\nh_open : ∀ (i : ι), IsOpen (s i)\nh_Union : Eq (Set.iUnion fun i => s i) Set.univ\n⊢ Subsingleton ι","decl":"/-- In a preconnected space, any disjoint cover by non-empty open subsets has at most one\nelement. -/\nlemma subsingleton_of_disjoint_isOpen_iUnion_eq_univ\n    (h_open : ∀ i, IsOpen (s i)) (h_Union : ⋃ i, s i = univ) :\n    Subsingleton ι := by\n  refine subsingleton_of_disjoint_isClopen h_nonempty h_disj (fun i ↦ ⟨?_, h_open i⟩)\n  rw [← isOpen_compl_iff, compl_eq_univ_diff, ← h_Union, iUnion_diff]\n  refine isOpen_iUnion (fun j ↦ ?_)\n  rcases eq_or_ne i j with rfl | h_ne\n  · simp\n  · simpa only [(h_disj h_ne.symm).sdiff_eq_left] using h_open j\n\n"}
{"name":"subsingleton_of_disjoint_isClosed_iUnion_eq_univ","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"α : Type u\nι : Type u_1\ninst✝² : TopologicalSpace α\ninst✝¹ : PreconnectedSpace α\ns : ι → Set α\nh_nonempty : ∀ (i : ι), (s i).Nonempty\nh_disj : Pairwise (Function.onFun Disjoint s)\ninst✝ : Finite ι\nh_closed : ∀ (i : ι), IsClosed (s i)\nh_Union : Eq (Set.iUnion fun i => s i) Set.univ\n⊢ Subsingleton ι","decl":"/-- In a preconnected space, any finite disjoint cover by non-empty closed subsets has at most one\nelement. -/\nlemma subsingleton_of_disjoint_isClosed_iUnion_eq_univ [Finite ι]\n    (h_closed : ∀ i, IsClosed (s i)) (h_Union : ⋃ i, s i = univ) :\n    Subsingleton ι := by\n  refine subsingleton_of_disjoint_isClopen h_nonempty h_disj (fun i ↦ ⟨h_closed i, ?_⟩)\n  rw [← isClosed_compl_iff, compl_eq_univ_diff, ← h_Union, iUnion_diff]\n  refine isClosed_iUnion_of_finite (fun j ↦ ?_)\n  rcases eq_or_ne i j with rfl | h_ne\n  · simp\n  · simpa only [(h_disj h_ne.symm).sdiff_eq_left] using h_closed j\n\n"}
{"name":"frontier_eq_empty_iff","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"α : Type u\ninst✝¹ : TopologicalSpace α\ninst✝ : PreconnectedSpace α\ns : Set α\n⊢ Iff (Eq (frontier s) EmptyCollection.emptyCollection) (Or (Eq s EmptyCollection.emptyCollection) (Eq s Set.univ))","decl":"theorem frontier_eq_empty_iff [PreconnectedSpace α] {s : Set α} :\n    frontier s = ∅ ↔ s = ∅ ∨ s = univ :=\n  isClopen_iff_frontier_eq_empty.symm.trans isClopen_iff\n\n"}
{"name":"nonempty_frontier_iff","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"α : Type u\ninst✝¹ : TopologicalSpace α\ninst✝ : PreconnectedSpace α\ns : Set α\n⊢ Iff (frontier s).Nonempty (And s.Nonempty (Ne s Set.univ))","decl":"theorem nonempty_frontier_iff [PreconnectedSpace α] {s : Set α} :\n    (frontier s).Nonempty ↔ s.Nonempty ∧ s ≠ univ := by\n  simp only [nonempty_iff_ne_empty, Ne, frontier_eq_empty_iff, not_or]\n\n"}
{"name":"PreconnectedSpace.induction₂'","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"α : Type u\ninst✝¹ : TopologicalSpace α\ninst✝ : PreconnectedSpace α\nP : α → α → Prop\nh : ∀ (x : α), Filter.Eventually (fun y => And (P x y) (P y x)) (nhds x)\nh' : Transitive P\nx y : α\n⊢ P x y","decl":"/-- In a preconnected space, given a transitive relation `P`, if `P x y` and `P y x` are true\nfor `y` close enough to `x`, then `P x y` holds for all `x, y`. This is a version of the fact\nthat, if an equivalence relation has open classes, then it has a single equivalence class. -/\nlemma PreconnectedSpace.induction₂' [PreconnectedSpace α] (P : α → α → Prop)\n    (h : ∀ x, ∀ᶠ y in 𝓝 x, P x y ∧ P y x) (h' : Transitive P) (x y : α) :\n    P x y := by\n  let u := {z | P x z}\n  have A : IsClosed u := by\n    apply isClosed_iff_nhds.2 (fun z hz ↦ ?_)\n    rcases hz _ (h z) with ⟨t, ht, h't⟩\n    exact h' h't ht.2\n  have B : IsOpen u := by\n    apply isOpen_iff_mem_nhds.2 (fun z hz ↦ ?_)\n    filter_upwards [h z] with t ht\n    exact h' hz ht.1\n  have C : u.Nonempty := ⟨x, (mem_of_mem_nhds (h x)).1⟩\n  have D : u = Set.univ := IsClopen.eq_univ ⟨A, B⟩ C\n  show y ∈ u\n  simp [D]\n\n"}
{"name":"PreconnectedSpace.induction₂","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"α : Type u\ninst✝¹ : TopologicalSpace α\ninst✝ : PreconnectedSpace α\nP : α → α → Prop\nh : ∀ (x : α), Filter.Eventually (fun y => P x y) (nhds x)\nh' : Transitive P\nh'' : Symmetric P\nx y : α\n⊢ P x y","decl":"/-- In a preconnected space, if a symmetric transitive relation `P x y` is true for `y` close\nenough to `x`, then it holds for all `x, y`. This is a version of the fact that, if an equivalence\nrelation has open classes, then it has a single equivalence class. -/\nlemma PreconnectedSpace.induction₂ [PreconnectedSpace α] (P : α → α → Prop)\n    (h : ∀ x, ∀ᶠ y in 𝓝 x, P x y) (h' : Transitive P) (h'' : Symmetric P) (x y : α) :\n    P x y := by\n  refine PreconnectedSpace.induction₂' P (fun z ↦ ?_) h' x y\n  filter_upwards [h z] with a ha\n  exact ⟨ha, h'' ha⟩\n\n"}
{"name":"IsPreconnected.induction₂'","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\ns : Set α\nhs : IsPreconnected s\nP : α → α → Prop\nh : ∀ (x : α), Membership.mem s x → Filter.Eventually (fun y => And (P x y) (P y x)) (nhdsWithin x s)\nh' : ∀ (x y z : α), Membership.mem s x → Membership.mem s y → Membership.mem s z → P x y → P y z → P x z\nx y : α\nhx : Membership.mem s x\nhy : Membership.mem s y\n⊢ P x y","decl":"/-- In a preconnected set, given a transitive relation `P`, if `P x y` and `P y x` are true\nfor `y` close enough to `x`, then `P x y` holds for all `x, y`. This is a version of the fact\nthat, if an equivalence relation has open classes, then it has a single equivalence class. -/\nlemma IsPreconnected.induction₂' {s : Set α} (hs : IsPreconnected s) (P : α → α → Prop)\n    (h : ∀ x ∈ s, ∀ᶠ y in 𝓝[s] x, P x y ∧ P y x)\n    (h' : ∀ x y z, x ∈ s → y ∈ s → z ∈ s → P x y → P y z → P x z)\n    {x y : α} (hx : x ∈ s) (hy : y ∈ s) : P x y := by\n  let Q : s → s → Prop := fun a b ↦ P a b\n  show Q ⟨x, hx⟩ ⟨y, hy⟩\n  have : PreconnectedSpace s := Subtype.preconnectedSpace hs\n  apply PreconnectedSpace.induction₂'\n  · rintro ⟨x, hx⟩\n    have Z := h x hx\n    rwa [nhdsWithin_eq_map_subtype_coe] at Z\n  · rintro ⟨a, ha⟩ ⟨b, hb⟩ ⟨c, hc⟩ hab hbc\n    exact h' a b c ha hb hc hab hbc\n\n"}
{"name":"IsPreconnected.induction₂","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\ns : Set α\nhs : IsPreconnected s\nP : α → α → Prop\nh : ∀ (x : α), Membership.mem s x → Filter.Eventually (fun y => P x y) (nhdsWithin x s)\nh' : ∀ (x y z : α), Membership.mem s x → Membership.mem s y → Membership.mem s z → P x y → P y z → P x z\nh'' : ∀ (x y : α), Membership.mem s x → Membership.mem s y → P x y → P y x\nx y : α\nhx : Membership.mem s x\nhy : Membership.mem s y\n⊢ P x y","decl":"/-- In a preconnected set, if a symmetric transitive relation `P x y` is true for `y` close\nenough to `x`, then it holds for all `x, y`. This is a version of the fact that, if an equivalence\nrelation has open classes, then it has a single equivalence class. -/\nlemma IsPreconnected.induction₂ {s : Set α} (hs : IsPreconnected s) (P : α → α → Prop)\n    (h : ∀ x ∈ s, ∀ᶠ y in 𝓝[s] x, P x y)\n    (h' : ∀ x y z, x ∈ s → y ∈ s → z ∈ s → P x y → P y z → P x z)\n    (h'' : ∀ x y, x ∈ s → y ∈ s → P x y → P y x)\n    {x y : α} (hx : x ∈ s) (hy : y ∈ s) : P x y := by\n  apply hs.induction₂' P (fun z hz ↦ ?_) h' hx hy\n  filter_upwards [h z hz, self_mem_nhdsWithin] with a ha h'a\n  exact ⟨ha, h'' z a hz h'a ha⟩\n\n"}
{"name":"isPreconnected_iff_subset_of_disjoint","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\ns : Set α\n⊢ Iff (IsPreconnected s) (∀ (u v : Set α), IsOpen u → IsOpen v → HasSubset.Subset s (Union.union u v) → Eq (Inter.inter s (Inter.inter u v)) EmptyCollection.emptyCollection → Or (HasSubset.Subset s u) (HasSubset.Subset s v))","decl":"/-- A set `s` is preconnected if and only if for every cover by two open sets that are disjoint on\n`s`, it is contained in one of the two covering sets. -/\ntheorem isPreconnected_iff_subset_of_disjoint {s : Set α} :\n    IsPreconnected s ↔\n      ∀ u v, IsOpen u → IsOpen v → s ⊆ u ∪ v → s ∩ (u ∩ v) = ∅ → s ⊆ u ∨ s ⊆ v := by\n  constructor <;> intro h\n  · intro u v hu hv hs huv\n    specialize h u v hu hv hs\n    contrapose! huv\n    simp only [not_subset] at huv\n    rcases huv with ⟨⟨x, hxs, hxu⟩, ⟨y, hys, hyv⟩⟩\n    have hxv : x ∈ v := or_iff_not_imp_left.mp (hs hxs) hxu\n    have hyu : y ∈ u := or_iff_not_imp_right.mp (hs hys) hyv\n    exact h ⟨y, hys, hyu⟩ ⟨x, hxs, hxv⟩\n  · intro u v hu hv hs hsu hsv\n    by_contra H\n    specialize h u v hu hv hs (Set.not_nonempty_iff_eq_empty.mp H)\n    apply H\n    cases' h with h h\n    · rcases hsv with ⟨x, hxs, hxv⟩\n      exact ⟨x, hxs, ⟨h hxs, hxv⟩⟩\n    · rcases hsu with ⟨x, hxs, hxu⟩\n      exact ⟨x, hxs, ⟨hxu, h hxs⟩⟩\n\n"}
{"name":"isConnected_iff_sUnion_disjoint_open","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\ns : Set α\n⊢ Iff (IsConnected s) (∀ (U : Finset (Set α)), (∀ (u v : Set α), Membership.mem U u → Membership.mem U v → (Inter.inter s (Inter.inter u v)).Nonempty → Eq u v) → (∀ (u : Set α), Membership.mem U u → IsOpen u) → HasSubset.Subset s (↑U).sUnion → Exists fun u => And (Membership.mem U u) (HasSubset.Subset s u))","decl":"/-- A set `s` is connected if and only if\nfor every cover by a finite collection of open sets that are pairwise disjoint on `s`,\nit is contained in one of the members of the collection. -/\ntheorem isConnected_iff_sUnion_disjoint_open {s : Set α} :\n    IsConnected s ↔\n      ∀ U : Finset (Set α), (∀ u v : Set α, u ∈ U → v ∈ U → (s ∩ (u ∩ v)).Nonempty → u = v) →\n        (∀ u ∈ U, IsOpen u) → (s ⊆ ⋃₀ ↑U) → ∃ u ∈ U, s ⊆ u := by\n  rw [IsConnected, isPreconnected_iff_subset_of_disjoint]\n  classical\n  refine ⟨fun ⟨hne, h⟩ U hU hUo hsU => ?_, fun h => ⟨?_, fun u v hu hv hs hsuv => ?_⟩⟩\n  · induction U using Finset.induction_on with\n    | empty => exact absurd (by simpa using hsU) hne.not_subset_empty\n    | @insert u U uU IH =>\n      simp only [← forall_cond_comm, Finset.forall_mem_insert, Finset.exists_mem_insert,\n        Finset.coe_insert, sUnion_insert, implies_true, true_and] at *\n      refine (h _ hUo.1 (⋃₀ ↑U) (isOpen_sUnion hUo.2) hsU ?_).imp_right ?_\n      · refine subset_empty_iff.1 fun x ⟨hxs, hxu, v, hvU, hxv⟩ => ?_\n        exact ne_of_mem_of_not_mem hvU uU (hU.1 v hvU ⟨x, hxs, hxu, hxv⟩).symm\n      · exact IH (fun u hu => (hU.2 u hu).2) hUo.2\n  · simpa [subset_empty_iff, nonempty_iff_ne_empty] using h ∅\n  · rw [← not_nonempty_iff_eq_empty] at hsuv\n    have := hsuv; rw [inter_comm u] at this\n    simpa [*, or_imp, forall_and] using h {u, v}\n\n-- Porting note: `IsPreconnected.subset_isClopen` moved up from here\n\n"}
{"name":"disjoint_or_subset_of_isClopen","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\ns t : Set α\nhs : IsPreconnected s\nht : IsClopen t\n⊢ Or (Disjoint s t) (HasSubset.Subset s t)","decl":"/-- Preconnected sets are either contained in or disjoint to any given clopen set. -/\ntheorem disjoint_or_subset_of_isClopen {s t : Set α} (hs : IsPreconnected s) (ht : IsClopen t) :\n    Disjoint s t ∨ s ⊆ t :=\n  (disjoint_or_nonempty_inter s t).imp_right <| hs.subset_isClopen ht\n\n"}
{"name":"isPreconnected_iff_subset_of_disjoint_closed","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\ns : Set α\n⊢ Iff (IsPreconnected s) (∀ (u v : Set α), IsClosed u → IsClosed v → HasSubset.Subset s (Union.union u v) → Eq (Inter.inter s (Inter.inter u v)) EmptyCollection.emptyCollection → Or (HasSubset.Subset s u) (HasSubset.Subset s v))","decl":"/-- A set `s` is preconnected if and only if\nfor every cover by two closed sets that are disjoint on `s`,\nit is contained in one of the two covering sets. -/\ntheorem isPreconnected_iff_subset_of_disjoint_closed :\n    IsPreconnected s ↔\n      ∀ u v, IsClosed u → IsClosed v → s ⊆ u ∪ v → s ∩ (u ∩ v) = ∅ → s ⊆ u ∨ s ⊆ v := by\n  constructor <;> intro h\n  · intro u v hu hv hs huv\n    rw [isPreconnected_closed_iff] at h\n    specialize h u v hu hv hs\n    contrapose! huv\n    simp only [not_subset] at huv\n    rcases huv with ⟨⟨x, hxs, hxu⟩, ⟨y, hys, hyv⟩⟩\n    have hxv : x ∈ v := or_iff_not_imp_left.mp (hs hxs) hxu\n    have hyu : y ∈ u := or_iff_not_imp_right.mp (hs hys) hyv\n    exact h ⟨y, hys, hyu⟩ ⟨x, hxs, hxv⟩\n  · rw [isPreconnected_closed_iff]\n    intro u v hu hv hs hsu hsv\n    by_contra H\n    specialize h u v hu hv hs (Set.not_nonempty_iff_eq_empty.mp H)\n    apply H\n    cases' h with h h\n    · rcases hsv with ⟨x, hxs, hxv⟩\n      exact ⟨x, hxs, ⟨h hxs, hxv⟩⟩\n    · rcases hsu with ⟨x, hxs, hxu⟩\n      exact ⟨x, hxs, ⟨hxu, h hxs⟩⟩\n\n"}
{"name":"isPreconnected_iff_subset_of_fully_disjoint_closed","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\ns : Set α\nhs : IsClosed s\n⊢ Iff (IsPreconnected s) (∀ (u v : Set α), IsClosed u → IsClosed v → HasSubset.Subset s (Union.union u v) → Disjoint u v → Or (HasSubset.Subset s u) (HasSubset.Subset s v))","decl":"/-- A closed set `s` is preconnected if and only if for every cover by two closed sets that are\ndisjoint, it is contained in one of the two covering sets. -/\ntheorem isPreconnected_iff_subset_of_fully_disjoint_closed {s : Set α} (hs : IsClosed s) :\n    IsPreconnected s ↔\n      ∀ u v, IsClosed u → IsClosed v → s ⊆ u ∪ v → Disjoint u v → s ⊆ u ∨ s ⊆ v := by\n  refine isPreconnected_iff_subset_of_disjoint_closed.trans ⟨?_, ?_⟩ <;> intro H u v hu hv hss huv\n  · apply H u v hu hv hss\n    rw [huv.inter_eq, inter_empty]\n  have H1 := H (u ∩ s) (v ∩ s)\n  rw [subset_inter_iff, subset_inter_iff] at H1\n  simp only [Subset.refl, and_true] at H1\n  apply H1 (hu.inter hs) (hv.inter hs)\n  · rw [← union_inter_distrib_right]\n    exact subset_inter hss Subset.rfl\n  · rwa [disjoint_iff_inter_eq_empty, ← inter_inter_distrib_right, inter_comm]\n\n"}
{"name":"IsClopen.connectedComponent_subset","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\ns : Set α\nx : α\nhs : IsClopen s\nhx : Membership.mem s x\n⊢ HasSubset.Subset (connectedComponent x) s","decl":"theorem IsClopen.connectedComponent_subset {x} (hs : IsClopen s) (hx : x ∈ s) :\n    connectedComponent x ⊆ s :=\n  isPreconnected_connectedComponent.subset_isClopen hs ⟨x, mem_connectedComponent, hx⟩\n\n"}
{"name":"connectedComponent_subset_iInter_isClopen","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nx : α\n⊢ HasSubset.Subset (connectedComponent x) (Set.iInter fun Z => ↑Z)","decl":"/-- The connected component of a point is always a subset of the intersection of all its clopen\nneighbourhoods. -/\ntheorem connectedComponent_subset_iInter_isClopen {x : α} :\n    connectedComponent x ⊆ ⋂ Z : { Z : Set α // IsClopen Z ∧ x ∈ Z }, Z :=\n  subset_iInter fun Z => Z.2.1.connectedComponent_subset Z.2.2\n\n"}
{"name":"IsClopen.biUnion_connectedComponent_eq","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nZ : Set α\nh : IsClopen Z\n⊢ Eq (Set.iUnion fun x => Set.iUnion fun h => connectedComponent x) Z","decl":"/-- A clopen set is the union of its connected components. -/\ntheorem IsClopen.biUnion_connectedComponent_eq {Z : Set α} (h : IsClopen Z) :\n    ⋃ x ∈ Z, connectedComponent x = Z :=\n  Subset.antisymm (iUnion₂_subset fun _ => h.connectedComponent_subset) fun _ h =>\n    mem_iUnion₂_of_mem h mem_connectedComponent\n\n"}
{"name":"IsClopen.biUnion_connectedComponentIn","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"X : Type u_3\ninst✝ : TopologicalSpace X\nu v : Set X\nhu : IsClopen (Set.preimage Subtype.val u)\nhuv₁ : HasSubset.Subset u v\n⊢ Eq u (Set.iUnion fun x => Set.iUnion fun h => connectedComponentIn v x)","decl":"open Set.Notation in\n/-- If `u v : Set X` and `u ⊆ v` is clopen in `v`, then `u` is the union of the connected\ncomponents of `v` in `X` which intersect `u`. -/\nlemma IsClopen.biUnion_connectedComponentIn {X : Type*} [TopologicalSpace X] {u v : Set X}\n    (hu : IsClopen (v ↓∩ u)) (huv₁ : u ⊆ v) :\n    u = ⋃ x ∈ u, connectedComponentIn v x := by\n  have := congr(((↑) : Set v → Set X) $(hu.biUnion_connectedComponent_eq.symm))\n  simp only [Subtype.image_preimage_coe, mem_preimage, iUnion_coe_set, image_val_iUnion,\n    inter_eq_right.mpr huv₁] at this\n  nth_rw 1 [this]\n  congr! 2 with x hx\n  simp only [← connectedComponentIn_eq_image]\n  exact le_antisymm (iUnion_subset fun _ ↦ le_rfl) <|\n    iUnion_subset fun hx ↦ subset_iUnion₂_of_subset (huv₁ hx) hx le_rfl\n\n"}
{"name":"preimage_connectedComponent_connected","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\nf : α → β\nconnected_fibers : ∀ (t : β), IsConnected (Set.preimage f (Singleton.singleton t))\nhcl : ∀ (T : Set β), Iff (IsClosed T) (IsClosed (Set.preimage f T))\nt : β\n⊢ IsConnected (Set.preimage f (connectedComponent t))","decl":"/-- The preimage of a connected component is preconnected if the function has connected fibers\nand a subset is closed iff the preimage is. -/\ntheorem preimage_connectedComponent_connected\n    (connected_fibers : ∀ t : β, IsConnected (f ⁻¹' {t}))\n    (hcl : ∀ T : Set β, IsClosed T ↔ IsClosed (f ⁻¹' T)) (t : β) :\n    IsConnected (f ⁻¹' connectedComponent t) := by\n  -- The following proof is essentially https://stacks.math.columbia.edu/tag/0377\n  -- although the statement is slightly different\n  have hf : Surjective f := Surjective.of_comp fun t : β => (connected_fibers t).1\n  refine ⟨Nonempty.preimage connectedComponent_nonempty hf, ?_⟩\n  have hT : IsClosed (f ⁻¹' connectedComponent t) :=\n    (hcl (connectedComponent t)).1 isClosed_connectedComponent\n  -- To show it's preconnected we decompose (f ⁻¹' connectedComponent t) as a subset of two\n  -- closed disjoint sets in α. We want to show that it's a subset of either.\n  rw [isPreconnected_iff_subset_of_fully_disjoint_closed hT]\n  intro u v hu hv huv uv_disj\n  -- To do this we decompose connectedComponent t into T₁ and T₂\n  -- we will show that connectedComponent t is a subset of either and hence\n  -- (f ⁻¹' connectedComponent t) is a subset of u or v\n  let T₁ := { t' ∈ connectedComponent t | f ⁻¹' {t'} ⊆ u }\n  let T₂ := { t' ∈ connectedComponent t | f ⁻¹' {t'} ⊆ v }\n  have fiber_decomp : ∀ t' ∈ connectedComponent t, f ⁻¹' {t'} ⊆ u ∨ f ⁻¹' {t'} ⊆ v := by\n    intro t' ht'\n    apply isPreconnected_iff_subset_of_disjoint_closed.1 (connected_fibers t').2 u v hu hv\n    · exact Subset.trans (preimage_mono (singleton_subset_iff.2 ht')) huv\n    rw [uv_disj.inter_eq, inter_empty]\n  have T₁_u : f ⁻¹' T₁ = f ⁻¹' connectedComponent t ∩ u := by\n    apply eq_of_subset_of_subset\n    · rw [← biUnion_preimage_singleton]\n      refine iUnion₂_subset fun t' ht' => subset_inter ?_ ht'.2\n      rw [hf.preimage_subset_preimage_iff, singleton_subset_iff]\n      exact ht'.1\n    rintro a ⟨hat, hau⟩\n    constructor\n    · exact mem_preimage.1 hat\n    refine (fiber_decomp (f a) (mem_preimage.1 hat)).resolve_right fun h => ?_\n    exact uv_disj.subset_compl_right hau (h rfl)\n  -- This proof is exactly the same as the above (modulo some symmetry)\n  have T₂_v : f ⁻¹' T₂ = f ⁻¹' connectedComponent t ∩ v := by\n    apply eq_of_subset_of_subset\n    · rw [← biUnion_preimage_singleton]\n      refine iUnion₂_subset fun t' ht' => subset_inter ?_ ht'.2\n      rw [hf.preimage_subset_preimage_iff, singleton_subset_iff]\n      exact ht'.1\n    rintro a ⟨hat, hav⟩\n    constructor\n    · exact mem_preimage.1 hat\n    · refine (fiber_decomp (f a) (mem_preimage.1 hat)).resolve_left fun h => ?_\n      exact uv_disj.subset_compl_left hav (h rfl)\n  -- Now we show T₁, T₂ are closed, cover connectedComponent t and are disjoint.\n  have hT₁ : IsClosed T₁ := (hcl T₁).2 (T₁_u.symm ▸ IsClosed.inter hT hu)\n  have hT₂ : IsClosed T₂ := (hcl T₂).2 (T₂_v.symm ▸ IsClosed.inter hT hv)\n  have T_decomp : connectedComponent t ⊆ T₁ ∪ T₂ := fun t' ht' => by\n    rw [mem_union t' T₁ T₂]\n    cases' fiber_decomp t' ht' with htu htv\n    · left\n      exact ⟨ht', htu⟩\n    right\n    exact ⟨ht', htv⟩\n  have T_disjoint : Disjoint T₁ T₂ := by\n    refine Disjoint.of_preimage hf ?_\n    rw [T₁_u, T₂_v, disjoint_iff_inter_eq_empty, ← inter_inter_distrib_left, uv_disj.inter_eq,\n      inter_empty]\n  -- Now we do cases on whether (connectedComponent t) is a subset of T₁ or T₂ to show\n  -- that the preimage is a subset of u or v.\n  cases' (isPreconnected_iff_subset_of_fully_disjoint_closed isClosed_connectedComponent).1\n    isPreconnected_connectedComponent T₁ T₂ hT₁ hT₂ T_decomp T_disjoint with h h\n  · left\n    rw [Subset.antisymm_iff] at T₁_u\n    suffices f ⁻¹' connectedComponent t ⊆ f ⁻¹' T₁\n      from (this.trans T₁_u.1).trans inter_subset_right\n    exact preimage_mono h\n  · right\n    rw [Subset.antisymm_iff] at T₂_v\n    suffices f ⁻¹' connectedComponent t ⊆ f ⁻¹' T₂\n      from (this.trans T₂_v.1).trans inter_subset_right\n    exact preimage_mono h\n\n"}
{"name":"Topology.IsQuotientMap.preimage_connectedComponent","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\nf : α → β\nhf : Topology.IsQuotientMap f\nh_fibers : ∀ (y : β), IsConnected (Set.preimage f (Singleton.singleton y))\na : α\n⊢ Eq (Set.preimage f (connectedComponent (f a))) (connectedComponent a)","decl":"theorem Topology.IsQuotientMap.preimage_connectedComponent (hf : IsQuotientMap f)\n    (h_fibers : ∀ y : β, IsConnected (f ⁻¹' {y})) (a : α) :\n    f ⁻¹' connectedComponent (f a) = connectedComponent a :=\n  ((preimage_connectedComponent_connected h_fibers (fun _ => hf.isClosed_preimage.symm)\n      _).subset_connectedComponent mem_connectedComponent).antisymm\n    (hf.continuous.mapsTo_connectedComponent a)\n\n"}
{"name":"QuotientMap.preimage_connectedComponent","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\nf : α → β\nhf : Topology.IsQuotientMap f\nh_fibers : ∀ (y : β), IsConnected (Set.preimage f (Singleton.singleton y))\na : α\n⊢ Eq (Set.preimage f (connectedComponent (f a))) (connectedComponent a)","decl":"@[deprecated (since := \"2024-10-22\")]\nalias QuotientMap.preimage_connectedComponent := IsQuotientMap.preimage_connectedComponent\n\n"}
{"name":"Topology.IsQuotientMap.image_connectedComponent","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\nf : α → β\nhf : Topology.IsQuotientMap f\nh_fibers : ∀ (y : β), IsConnected (Set.preimage f (Singleton.singleton y))\na : α\n⊢ Eq (Set.image f (connectedComponent a)) (connectedComponent (f a))","decl":"lemma Topology.IsQuotientMap.image_connectedComponent {f : α → β} (hf : IsQuotientMap f)\n    (h_fibers : ∀ y : β, IsConnected (f ⁻¹' {y})) (a : α) :\n    f '' connectedComponent a = connectedComponent (f a) := by\n  rw [← hf.preimage_connectedComponent h_fibers, image_preimage_eq _ hf.surjective]\n\n"}
{"name":"QuotientMap.image_connectedComponent","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\nf : α → β\nhf : Topology.IsQuotientMap f\nh_fibers : ∀ (y : β), IsConnected (Set.preimage f (Singleton.singleton y))\na : α\n⊢ Eq (Set.image f (connectedComponent a)) (connectedComponent (f a))","decl":"@[deprecated (since := \"2024-10-22\")]\nalias QuotientMap.image_connectedComponent := IsQuotientMap.image_connectedComponent\n\n"}
{"name":"ConnectedComponents.coe_eq_coe","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nx y : α\n⊢ Iff (Eq (ConnectedComponents.mk x) (ConnectedComponents.mk y)) (Eq (connectedComponent x) (connectedComponent y))","decl":"@[simp]\ntheorem coe_eq_coe {x y : α} :\n    (x : ConnectedComponents α) = y ↔ connectedComponent x = connectedComponent y :=\n  Quotient.eq''\n\n"}
{"name":"ConnectedComponents.coe_ne_coe","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nx y : α\n⊢ Iff (Ne (ConnectedComponents.mk x) (ConnectedComponents.mk y)) (Ne (connectedComponent x) (connectedComponent y))","decl":"theorem coe_ne_coe {x y : α} :\n    (x : ConnectedComponents α) ≠ y ↔ connectedComponent x ≠ connectedComponent y :=\n  coe_eq_coe.not\n\n"}
{"name":"ConnectedComponents.coe_eq_coe'","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nx y : α\n⊢ Iff (Eq (ConnectedComponents.mk x) (ConnectedComponents.mk y)) (Membership.mem (connectedComponent y) x)","decl":"theorem coe_eq_coe' {x y : α} : (x : ConnectedComponents α) = y ↔ x ∈ connectedComponent y :=\n  coe_eq_coe.trans connectedComponent_eq_iff_mem\n\n"}
{"name":"ConnectedComponents.surjective_coe","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\n⊢ Function.Surjective ConnectedComponents.mk","decl":"theorem surjective_coe : Surjective (mk : α → ConnectedComponents α) :=\n  Quot.mk_surjective\n\n"}
{"name":"ConnectedComponents.isQuotientMap_coe","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\n⊢ Topology.IsQuotientMap ConnectedComponents.mk","decl":"theorem isQuotientMap_coe : IsQuotientMap (mk : α → ConnectedComponents α) :=\n  isQuotientMap_quot_mk\n\n"}
{"name":"ConnectedComponents.quotientMap_coe","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\n⊢ Topology.IsQuotientMap ConnectedComponents.mk","decl":"@[deprecated (since := \"2024-10-22\")]\nalias quotientMap_coe := isQuotientMap_coe\n\n"}
{"name":"ConnectedComponents.continuous_coe","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\n⊢ Continuous ConnectedComponents.mk","decl":"@[continuity]\ntheorem continuous_coe : Continuous (mk : α → ConnectedComponents α) :=\n  isQuotientMap_coe.continuous\n\n"}
{"name":"ConnectedComponents.range_coe","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\n⊢ Eq (Set.range ConnectedComponents.mk) Set.univ","decl":"@[simp]\ntheorem range_coe : range (mk : α → ConnectedComponents α) = univ :=\n  surjective_coe.range_eq\n\n"}
{"name":"connectedComponents_preimage_singleton","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nx : α\n⊢ Eq (Set.preimage ConnectedComponents.mk (Singleton.singleton (ConnectedComponents.mk x))) (connectedComponent x)","decl":"/-- The preimage of a singleton in `connectedComponents` is the connected component\nof an element in the equivalence class. -/\ntheorem connectedComponents_preimage_singleton {x : α} :\n    (↑) ⁻¹' ({↑x} : Set (ConnectedComponents α)) = connectedComponent x := by\n  ext y\n  rw [mem_preimage, mem_singleton_iff, ConnectedComponents.coe_eq_coe']\n\n"}
{"name":"connectedComponents_preimage_image","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nU : Set α\n⊢ Eq (Set.preimage ConnectedComponents.mk (Set.image ConnectedComponents.mk U)) (Set.iUnion fun x => Set.iUnion fun h => connectedComponent x)","decl":"/-- The preimage of the image of a set under the quotient map to `connectedComponents α`\nis the union of the connected components of the elements in it. -/\ntheorem connectedComponents_preimage_image (U : Set α) :\n    (↑) ⁻¹' ((↑) '' U : Set (ConnectedComponents α)) = ⋃ x ∈ U, connectedComponent x := by\n  simp only [connectedComponents_preimage_singleton, preimage_iUnion₂, image_eq_iUnion]\n\n\n\n"}
{"name":"isPreconnected_of_forall_constant","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\ns : Set α\nhs : ∀ (f : α → Bool), ContinuousOn f s → ∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem s y → Eq (f x) (f y)\n⊢ IsPreconnected s","decl":"/-- If every map to `Bool` (a discrete two-element space), that is\ncontinuous on a set `s`, is constant on s, then s is preconnected -/\ntheorem isPreconnected_of_forall_constant {s : Set α}\n    (hs : ∀ f : α → Bool, ContinuousOn f s → ∀ x ∈ s, ∀ y ∈ s, f x = f y) : IsPreconnected s := by\n  unfold IsPreconnected\n  by_contra!\n  rcases this with ⟨u, v, u_op, v_op, hsuv, ⟨x, x_in_s, x_in_u⟩, ⟨y, y_in_s, y_in_v⟩, H⟩\n  have hy : y ∉ u := fun y_in_u => eq_empty_iff_forall_not_mem.mp H y ⟨y_in_s, ⟨y_in_u, y_in_v⟩⟩\n  have : ContinuousOn u.boolIndicator s := by\n    apply (continuousOn_boolIndicator_iff_isClopen _ _).mpr ⟨_, _⟩\n    · rw [preimage_subtype_coe_eq_compl hsuv H]\n      exact (v_op.preimage continuous_subtype_val).isClosed_compl\n    · exact u_op.preimage continuous_subtype_val\n  simpa [(u.mem_iff_boolIndicator _).mp x_in_u, (u.not_mem_iff_boolIndicator _).mp hy] using\n    hs _ this x x_in_s y y_in_s\n\n"}
{"name":"preconnectedSpace_of_forall_constant","module":"Mathlib.Topology.Connected.Clopen","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nhs : ∀ (f : α → Bool), Continuous f → ∀ (x y : α), Eq (f x) (f y)\n⊢ PreconnectedSpace α","decl":"/-- A `PreconnectedSpace` version of `isPreconnected_of_forall_constant` -/\ntheorem preconnectedSpace_of_forall_constant\n    (hs : ∀ f : α → Bool, Continuous f → ∀ x y, f x = f y) : PreconnectedSpace α :=\n  ⟨isPreconnected_of_forall_constant fun f hf x _ y _ =>\n      hs f (continuous_iff_continuousOn_univ.mpr hf) x y⟩\n"}
