{"name":"CategoryTheory.IsSkeletonOf.eqv","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor D C\nself : CategoryTheory.IsSkeletonOf C D F\n‚ä¢ F.IsEquivalence","decl":"/-- `IsSkeletonOf C D F` says that `F : D ‚•§ C` exhibits `D` as a skeletal full subcategory of `C`,\nin particular `F` is a (strong) equivalence and `D` is skeletal.\n-/\nstructure IsSkeletonOf (F : D ‚•§ C) : Prop where\n  /-- The category `D` has isomorphic objects equal -/\n  skel : Skeletal D\n  /-- The functor `F` is an equivalence -/\n  eqv : F.IsEquivalence := by infer_instance\n\n"}
{"name":"CategoryTheory.IsSkeletonOf.skel","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor D C\nself : CategoryTheory.IsSkeletonOf C D F\n‚ä¢ CategoryTheory.Skeletal D","decl":"/-- `IsSkeletonOf C D F` says that `F : D ‚•§ C` exhibits `D` as a skeletal full subcategory of `C`,\nin particular `F` is a (strong) equivalence and `D` is skeletal.\n-/\nstructure IsSkeletonOf (F : D ‚•§ C) : Prop where\n  /-- The category `D` has isomorphic objects equal -/\n  skel : Skeletal D\n  /-- The functor `F` is an equivalence -/\n  eqv : F.IsEquivalence := by infer_instance\n\n"}
{"name":"CategoryTheory.Functor.eq_of_iso","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF‚ÇÅ F‚ÇÇ : CategoryTheory.Functor D C\ninst‚úù : Quiver.IsThin C\nhC : CategoryTheory.Skeletal C\nhF : CategoryTheory.Iso F‚ÇÅ F‚ÇÇ\n‚ä¢ Eq F‚ÇÅ F‚ÇÇ","decl":"/-- If `C` is thin and skeletal, then any naturally isomorphic functors to `C` are equal. -/\ntheorem Functor.eq_of_iso {F‚ÇÅ F‚ÇÇ : D ‚•§ C} [Quiver.IsThin C] (hC : Skeletal C) (hF : F‚ÇÅ ‚âÖ F‚ÇÇ) :\n    F‚ÇÅ = F‚ÇÇ :=\n  Functor.ext (fun X => hC ‚ü®hF.app X‚ü©) fun _ _ _ => Subsingleton.elim _ _\n\n"}
{"name":"CategoryTheory.functor_skeletal","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù : Quiver.IsThin C\nhC : CategoryTheory.Skeletal C\n‚ä¢ CategoryTheory.Skeletal (CategoryTheory.Functor D C)","decl":"/-- If `C` is thin and skeletal, `D ‚•§ C` is skeletal.\n`CategoryTheory.functor_thin` shows it is thin also.\n-/\ntheorem functor_skeletal [Quiver.IsThin C] (hC : Skeletal C) : Skeletal (D ‚•§ C) := fun _ _ h =>\n  h.elim (Functor.eq_of_iso hC)\n\n"}
{"name":"CategoryTheory.fromSkeleton_map","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX‚úù Y‚úù : CategoryTheory.InducedCategory C Quotient.out\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.fromSkeleton C).map f) f","decl":"/-- The functor from the skeleton of `C` to `C`. -/\n@[simps!]\nnoncomputable def fromSkeleton : Skeleton C ‚•§ C :=\n  inducedFunctor _\n\n-- Porting note: previously `fromSkeleton` used `deriving Faithful, Full`\n"}
{"name":"CategoryTheory.fromSkeleton_obj","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\na‚úù : Quotient (CategoryTheory.isIsomorphicSetoid C)\n‚ä¢ Eq ((CategoryTheory.fromSkeleton C).obj a‚úù) a‚úù.out","decl":"/-- The functor from the skeleton of `C` to `C`. -/\n@[simps!]\nnoncomputable def fromSkeleton : Skeleton C ‚•§ C :=\n  inducedFunctor _\n\n-- Porting note: previously `fromSkeleton` used `deriving Faithful, Full`\n"}
{"name":"CategoryTheory.instFullSkeletonFromSkeleton","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\n‚ä¢ (CategoryTheory.fromSkeleton C).Full","decl":"noncomputable instance : (fromSkeleton C).Full := by\n  apply InducedCategory.full\n"}
{"name":"CategoryTheory.instFaithfulSkeletonFromSkeleton","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\n‚ä¢ (CategoryTheory.fromSkeleton C).Faithful","decl":"noncomputable instance : (fromSkeleton C).Faithful := by\n  apply InducedCategory.faithful\n\n"}
{"name":"CategoryTheory.instEssSurjSkeletonFromSkeleton","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\n‚ä¢ (CategoryTheory.fromSkeleton C).EssSurj","decl":"instance : (fromSkeleton C).EssSurj where mem_essImage X := ‚ü®Quotient.mk' X, Quotient.mk_out X‚ü©\n\n-- Porting note: named this instance\n"}
{"name":"CategoryTheory.fromSkeleton.isEquivalence","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\n‚ä¢ (CategoryTheory.fromSkeleton C).IsEquivalence","decl":"noncomputable instance fromSkeleton.isEquivalence : (fromSkeleton C).IsEquivalence where\n\n"}
{"name":"CategoryTheory.toSkeletonFunctor_map","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.toSkeletonFunctor C).map f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.preCounitIso X).hom (CategoryTheory.CategoryStruct.comp f (CategoryTheory.preCounitIso Y).inv))","decl":"/-- An inverse to `fromSkeleton C` that forms an equivalence with it. -/\n@[simps] noncomputable def toSkeletonFunctor : C ‚•§ Skeleton C where\n  obj := toSkeleton\n  map {X Y} f := by apply (preCounitIso X).hom ‚â´ f ‚â´ (preCounitIso Y).inv\n  map_id _ := by aesop\n  map_comp _ _ := by change _ = CategoryStruct.comp (obj := C) _ _; simp\n\n"}
{"name":"CategoryTheory.toSkeletonFunctor_obj","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\n‚ä¢ Eq ((CategoryTheory.toSkeletonFunctor C).obj X) (CategoryTheory.toSkeleton X)","decl":"/-- An inverse to `fromSkeleton C` that forms an equivalence with it. -/\n@[simps] noncomputable def toSkeletonFunctor : C ‚•§ Skeleton C where\n  obj := toSkeleton\n  map {X Y} f := by apply (preCounitIso X).hom ‚â´ f ‚â´ (preCounitIso Y).inv\n  map_id _ := by aesop\n  map_comp _ _ := by change _ = CategoryStruct.comp (obj := C) _ _; simp\n\n"}
{"name":"CategoryTheory.skeletonEquivalence_unitIso","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\n‚ä¢ Eq (CategoryTheory.skeletonEquivalence C).unitIso (CategoryTheory.NatIso.ofComponents (fun X => CategoryTheory.InducedCategory.isoMk (Nonempty.some ‚ãØ).symm) ‚ãØ)","decl":"/-- The equivalence between the skeleton and the category itself. -/\n@[simps] noncomputable def skeletonEquivalence : Skeleton C ‚âå C where\n  functor := fromSkeleton C\n  inverse := toSkeletonFunctor C\n  unitIso := NatIso.ofComponents\n    (fun X ‚Ü¶ InducedCategory.isoMk (Nonempty.some <| Quotient.mk_out X.out).symm)\n    fun _ ‚Ü¶ .symm <| Iso.inv_hom_id_assoc _ _\n  counitIso := NatIso.ofComponents preCounitIso\n  functor_unitIso_comp _ := Iso.inv_hom_id _\n\n"}
{"name":"CategoryTheory.skeletonEquivalence_functor","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\n‚ä¢ Eq (CategoryTheory.skeletonEquivalence C).functor (CategoryTheory.fromSkeleton C)","decl":"/-- The equivalence between the skeleton and the category itself. -/\n@[simps] noncomputable def skeletonEquivalence : Skeleton C ‚âå C where\n  functor := fromSkeleton C\n  inverse := toSkeletonFunctor C\n  unitIso := NatIso.ofComponents\n    (fun X ‚Ü¶ InducedCategory.isoMk (Nonempty.some <| Quotient.mk_out X.out).symm)\n    fun _ ‚Ü¶ .symm <| Iso.inv_hom_id_assoc _ _\n  counitIso := NatIso.ofComponents preCounitIso\n  functor_unitIso_comp _ := Iso.inv_hom_id _\n\n"}
{"name":"CategoryTheory.skeletonEquivalence_inverse","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\n‚ä¢ Eq (CategoryTheory.skeletonEquivalence C).inverse (CategoryTheory.toSkeletonFunctor C)","decl":"/-- The equivalence between the skeleton and the category itself. -/\n@[simps] noncomputable def skeletonEquivalence : Skeleton C ‚âå C where\n  functor := fromSkeleton C\n  inverse := toSkeletonFunctor C\n  unitIso := NatIso.ofComponents\n    (fun X ‚Ü¶ InducedCategory.isoMk (Nonempty.some <| Quotient.mk_out X.out).symm)\n    fun _ ‚Ü¶ .symm <| Iso.inv_hom_id_assoc _ _\n  counitIso := NatIso.ofComponents preCounitIso\n  functor_unitIso_comp _ := Iso.inv_hom_id _\n\n"}
{"name":"CategoryTheory.skeletonEquivalence_counitIso","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\n‚ä¢ Eq (CategoryTheory.skeletonEquivalence C).counitIso (CategoryTheory.NatIso.ofComponents CategoryTheory.preCounitIso ‚ãØ)","decl":"/-- The equivalence between the skeleton and the category itself. -/\n@[simps] noncomputable def skeletonEquivalence : Skeleton C ‚âå C where\n  functor := fromSkeleton C\n  inverse := toSkeletonFunctor C\n  unitIso := NatIso.ofComponents\n    (fun X ‚Ü¶ InducedCategory.isoMk (Nonempty.some <| Quotient.mk_out X.out).symm)\n    fun _ ‚Ü¶ .symm <| Iso.inv_hom_id_assoc _ _\n  counitIso := NatIso.ofComponents preCounitIso\n  functor_unitIso_comp _ := Iso.inv_hom_id _\n\n"}
{"name":"CategoryTheory.skeleton_skeletal","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\n‚ä¢ CategoryTheory.Skeletal (CategoryTheory.Skeleton C)","decl":"theorem skeleton_skeletal : Skeletal (Skeleton C) := by\n  rintro X Y ‚ü®h‚ü©\n  have : X.out ‚âà Y.out := ‚ü®(fromSkeleton C).mapIso h‚ü©\n  simpa using Quotient.sound this\n\n"}
{"name":"CategoryTheory.skeleton_isSkeleton","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\n‚ä¢ CategoryTheory.IsSkeletonOf C (CategoryTheory.Skeleton C) (CategoryTheory.fromSkeleton C)","decl":"/-- The `skeleton` of `C` given by choice is a skeleton of `C`. -/\nlemma skeleton_isSkeleton : IsSkeletonOf C (Skeleton C) (fromSkeleton C) where\n  skel := skeleton_skeletal C\n  eqv := fromSkeleton.isEquivalence C\n\n"}
{"name":"CategoryTheory.toThinSkeleton_obj","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\na : C\n‚ä¢ Eq ((CategoryTheory.toThinSkeleton C).obj a) (Quotient.mk' a)","decl":"/-- The functor from a category to its thin skeleton. -/\n@[simps]\ndef toThinSkeleton : C ‚•§ ThinSkeleton C where\n  obj := @Quotient.mk' C _\n  map f := homOfLE (Nonempty.intro f)\n\n"}
{"name":"CategoryTheory.toThinSkeleton_map","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX‚úù Y‚úù : C\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.toThinSkeleton C).map f) (CategoryTheory.homOfLE ‚ãØ)","decl":"/-- The functor from a category to its thin skeleton. -/\n@[simps]\ndef toThinSkeleton : C ‚•§ ThinSkeleton C where\n  obj := @Quotient.mk' C _\n  map f := homOfLE (Nonempty.intro f)\n\n"}
{"name":"CategoryTheory.ThinSkeleton.thin","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\n‚ä¢ Quiver.IsThin (CategoryTheory.ThinSkeleton C)","decl":"/-- The thin skeleton is thin. -/\ninstance thin : Quiver.IsThin (ThinSkeleton C) := fun _ _ =>\n  ‚ü®by\n    rintro ‚ü®‚ü®f‚ÇÅ‚ü©‚ü© ‚ü®‚ü®_‚ü©‚ü©\n    rfl‚ü©\n\n"}
{"name":"CategoryTheory.ThinSkeleton.map_obj","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\na‚úù : Quotient (CategoryTheory.isIsomorphicSetoid C)\n‚ä¢ Eq ((CategoryTheory.ThinSkeleton.map F).obj a‚úù) (Quotient.map F.obj ‚ãØ a‚úù)","decl":"/-- A functor `C ‚•§ D` computably lowers to a functor `ThinSkeleton C ‚•§ ThinSkeleton D`. -/\n@[simps]\ndef map (F : C ‚•§ D) : ThinSkeleton C ‚•§ ThinSkeleton D where\n  obj := Quotient.map F.obj fun _ _ ‚ü®hX‚ü© => ‚ü®F.mapIso hX‚ü©\n  map {X} {Y} := Quotient.recOnSubsingleton‚ÇÇ X Y fun _ _ k => homOfLE (k.le.elim fun t => ‚ü®F.map t‚ü©)\n\n"}
{"name":"CategoryTheory.ThinSkeleton.map_map","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX Y : CategoryTheory.ThinSkeleton C\na‚úù : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.ThinSkeleton.map F).map a‚úù) (Quotient.recOnSubsingleton‚ÇÇ (motive := fun x x_1 => Quiver.Hom x x_1 ‚Üí Quiver.Hom (Quotient.map F.obj ‚ãØ x) (Quotient.map F.obj ‚ãØ x_1)) X Y (fun x x_1 k => CategoryTheory.homOfLE ‚ãØ) a‚úù)","decl":"/-- A functor `C ‚•§ D` computably lowers to a functor `ThinSkeleton C ‚•§ ThinSkeleton D`. -/\n@[simps]\ndef map (F : C ‚•§ D) : ThinSkeleton C ‚•§ ThinSkeleton D where\n  obj := Quotient.map F.obj fun _ _ ‚ü®hX‚ü© => ‚ü®F.mapIso hX‚ü©\n  map {X} {Y} := Quotient.recOnSubsingleton‚ÇÇ X Y fun _ _ k => homOfLE (k.le.elim fun t => ‚ü®F.map t‚ü©)\n\n"}
{"name":"CategoryTheory.ThinSkeleton.comp_toThinSkeleton","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\n‚ä¢ Eq (F.comp (CategoryTheory.toThinSkeleton D)) ((CategoryTheory.toThinSkeleton C).comp (CategoryTheory.ThinSkeleton.map F))","decl":"theorem comp_toThinSkeleton (F : C ‚•§ D) : F ‚ãô toThinSkeleton D = toThinSkeleton C ‚ãô map F :=\n  rfl\n\n"}
{"name":"CategoryTheory.ThinSkeleton.map‚ÇÇ_obj","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C (CategoryTheory.Functor D E)\na‚úù : CategoryTheory.ThinSkeleton C\n‚ä¢ Eq ((CategoryTheory.ThinSkeleton.map‚ÇÇ F).obj a‚úù) (CategoryTheory.ThinSkeleton.map‚ÇÇFunctor F a‚úù)","decl":"/-- A functor `C ‚•§ D ‚•§ E` computably lowers to a functor\n`ThinSkeleton C ‚•§ ThinSkeleton D ‚•§ ThinSkeleton E` -/\n@[simps]\ndef map‚ÇÇ (F : C ‚•§ D ‚•§ E) : ThinSkeleton C ‚•§ ThinSkeleton D ‚•§ ThinSkeleton E where\n  obj := map‚ÇÇFunctor F\n  map := map‚ÇÇNatTrans F\n\n"}
{"name":"CategoryTheory.ThinSkeleton.map‚ÇÇ_map","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C (CategoryTheory.Functor D E)\nX‚úù Y‚úù : CategoryTheory.ThinSkeleton C\na‚úù : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.ThinSkeleton.map‚ÇÇ F).map a‚úù) (CategoryTheory.ThinSkeleton.map‚ÇÇNatTrans F a‚úù)","decl":"/-- A functor `C ‚•§ D ‚•§ E` computably lowers to a functor\n`ThinSkeleton C ‚•§ ThinSkeleton D ‚•§ ThinSkeleton E` -/\n@[simps]\ndef map‚ÇÇ (F : C ‚•§ D ‚•§ E) : ThinSkeleton C ‚•§ ThinSkeleton D ‚•§ ThinSkeleton E where\n  obj := map‚ÇÇFunctor F\n  map := map‚ÇÇNatTrans F\n\n"}
{"name":"CategoryTheory.ThinSkeleton.toThinSkeleton_faithful","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\n‚ä¢ (CategoryTheory.toThinSkeleton C).Faithful","decl":"instance toThinSkeleton_faithful : (toThinSkeleton C).Faithful where\n\n"}
{"name":"CategoryTheory.ThinSkeleton.fromThinSkeleton_map","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : Quiver.IsThin C\nx y : CategoryTheory.ThinSkeleton C\na‚úù : Quiver.Hom x y\n‚ä¢ Eq ((CategoryTheory.ThinSkeleton.fromThinSkeleton C).map a‚úù) (Quotient.recOnSubsingleton‚ÇÇ (motive := fun x x_1 => Quiver.Hom x x_1 ‚Üí Quiver.Hom (Quotient.out x) (Quotient.out x_1)) x y (fun X Y f => CategoryTheory.CategoryStruct.comp (Nonempty.some ‚ãØ).hom (CategoryTheory.CategoryStruct.comp (Nonempty.some ‚ãØ) (Nonempty.some ‚ãØ).inv)) a‚úù)","decl":"/-- Use `Quotient.out` to create a functor out of the thin skeleton. -/\n@[simps]\nnoncomputable def fromThinSkeleton : ThinSkeleton C ‚•§ C where\n  obj := Quotient.out\n  map {x} {y} :=\n    Quotient.recOnSubsingleton‚ÇÇ x y fun X Y f =>\n      (Nonempty.some (Quotient.mk_out X)).hom ‚â´ f.le.some ‚â´ (Nonempty.some (Quotient.mk_out Y)).inv\n\n"}
{"name":"CategoryTheory.ThinSkeleton.fromThinSkeleton_obj","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : Quiver.IsThin C\na‚úù : Quotient (CategoryTheory.isIsomorphicSetoid C)\n‚ä¢ Eq ((CategoryTheory.ThinSkeleton.fromThinSkeleton C).obj a‚úù) a‚úù.out","decl":"/-- Use `Quotient.out` to create a functor out of the thin skeleton. -/\n@[simps]\nnoncomputable def fromThinSkeleton : ThinSkeleton C ‚•§ C where\n  obj := Quotient.out\n  map {x} {y} :=\n    Quotient.recOnSubsingleton‚ÇÇ x y fun X Y f =>\n      (Nonempty.some (Quotient.mk_out X)).hom ‚â´ f.le.some ‚â´ (Nonempty.some (Quotient.mk_out Y)).inv\n\n"}
{"name":"CategoryTheory.ThinSkeleton.fromThinSkeleton_isEquivalence","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : Quiver.IsThin C\n‚ä¢ (CategoryTheory.ThinSkeleton.fromThinSkeleton C).IsEquivalence","decl":"noncomputable instance fromThinSkeleton_isEquivalence : (fromThinSkeleton C).IsEquivalence :=\n  (equivalence C).isEquivalence_functor\n\n"}
{"name":"CategoryTheory.ThinSkeleton.equiv_of_both_ways","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : Quiver.IsThin C\nX Y : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y X\n‚ä¢ HasEquiv.Equiv X Y","decl":"theorem equiv_of_both_ways {X Y : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ X) : X ‚âà Y :=\n  ‚ü®iso_of_both_ways f g‚ü©\n\n"}
{"name":"CategoryTheory.ThinSkeleton.skeletal","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : Quiver.IsThin C\n‚ä¢ CategoryTheory.Skeletal (CategoryTheory.ThinSkeleton C)","decl":"theorem skeletal : Skeletal (ThinSkeleton C) := fun X Y =>\n  Quotient.inductionOn‚ÇÇ X Y fun _ _ h => h.elim fun i => i.1.le.antisymm i.2.le\n\n"}
{"name":"CategoryTheory.ThinSkeleton.map_comp_eq","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\ninst‚úù : Quiver.IsThin C\nF : CategoryTheory.Functor E D\nG : CategoryTheory.Functor D C\n‚ä¢ Eq (CategoryTheory.ThinSkeleton.map (F.comp G)) ((CategoryTheory.ThinSkeleton.map F).comp (CategoryTheory.ThinSkeleton.map G))","decl":"theorem map_comp_eq (F : E ‚•§ D) (G : D ‚•§ C) : map (F ‚ãô G) = map F ‚ãô map G :=\n  Functor.eq_of_iso skeletal <|\n    NatIso.ofComponents fun X => Quotient.recOnSubsingleton X fun _ => Iso.refl _\n\n"}
{"name":"CategoryTheory.ThinSkeleton.map_id_eq","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : Quiver.IsThin C\n‚ä¢ Eq (CategoryTheory.ThinSkeleton.map (CategoryTheory.Functor.id C)) (CategoryTheory.Functor.id (CategoryTheory.ThinSkeleton C))","decl":"theorem map_id_eq : map (ùü≠ C) = ùü≠ (ThinSkeleton C) :=\n  Functor.eq_of_iso skeletal <|\n    NatIso.ofComponents fun X => Quotient.recOnSubsingleton X fun _ => Iso.refl _\n\n"}
{"name":"CategoryTheory.ThinSkeleton.map_iso_eq","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù : Quiver.IsThin C\nF‚ÇÅ F‚ÇÇ : CategoryTheory.Functor D C\nh : CategoryTheory.Iso F‚ÇÅ F‚ÇÇ\n‚ä¢ Eq (CategoryTheory.ThinSkeleton.map F‚ÇÅ) (CategoryTheory.ThinSkeleton.map F‚ÇÇ)","decl":"theorem map_iso_eq {F‚ÇÅ F‚ÇÇ : D ‚•§ C} (h : F‚ÇÅ ‚âÖ F‚ÇÇ) : map F‚ÇÅ = map F‚ÇÇ :=\n  Functor.eq_of_iso skeletal\n    { hom := mapNatTrans h.hom\n      inv := mapNatTrans h.inv }\n\n"}
{"name":"CategoryTheory.ThinSkeleton.thinSkeleton_isSkeleton","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : Quiver.IsThin C\n‚ä¢ CategoryTheory.IsSkeletonOf C (CategoryTheory.ThinSkeleton C) (CategoryTheory.ThinSkeleton.fromThinSkeleton C)","decl":"/-- `fromThinSkeleton C` exhibits the thin skeleton as a skeleton. -/\nlemma thinSkeleton_isSkeleton : IsSkeletonOf C (ThinSkeleton C) (fromThinSkeleton C) where\n  skel := skeletal\n\n"}
