{"name":"CategoryTheory.IsSkeletonOf.eqv","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor D C\nself : CategoryTheory.IsSkeletonOf C D F\n⊢ F.IsEquivalence","decl":"/-- `IsSkeletonOf C D F` says that `F : D ⥤ C` exhibits `D` as a skeletal full subcategory of `C`,\nin particular `F` is a (strong) equivalence and `D` is skeletal.\n-/\nstructure IsSkeletonOf (F : D ⥤ C) : Prop where\n  /-- The category `D` has isomorphic objects equal -/\n  skel : Skeletal D\n  /-- The functor `F` is an equivalence -/\n  eqv : F.IsEquivalence := by infer_instance\n\n"}
{"name":"CategoryTheory.IsSkeletonOf.skel","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor D C\nself : CategoryTheory.IsSkeletonOf C D F\n⊢ CategoryTheory.Skeletal D","decl":"/-- `IsSkeletonOf C D F` says that `F : D ⥤ C` exhibits `D` as a skeletal full subcategory of `C`,\nin particular `F` is a (strong) equivalence and `D` is skeletal.\n-/\nstructure IsSkeletonOf (F : D ⥤ C) : Prop where\n  /-- The category `D` has isomorphic objects equal -/\n  skel : Skeletal D\n  /-- The functor `F` is an equivalence -/\n  eqv : F.IsEquivalence := by infer_instance\n\n"}
{"name":"CategoryTheory.Functor.eq_of_iso","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF₁ F₂ : CategoryTheory.Functor D C\ninst✝ : Quiver.IsThin C\nhC : CategoryTheory.Skeletal C\nhF : CategoryTheory.Iso F₁ F₂\n⊢ Eq F₁ F₂","decl":"/-- If `C` is thin and skeletal, then any naturally isomorphic functors to `C` are equal. -/\ntheorem Functor.eq_of_iso {F₁ F₂ : D ⥤ C} [Quiver.IsThin C] (hC : Skeletal C) (hF : F₁ ≅ F₂) :\n    F₁ = F₂ :=\n  Functor.ext (fun X => hC ⟨hF.app X⟩) fun _ _ _ => Subsingleton.elim _ _\n\n"}
{"name":"CategoryTheory.functor_skeletal","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : Quiver.IsThin C\nhC : CategoryTheory.Skeletal C\n⊢ CategoryTheory.Skeletal (CategoryTheory.Functor D C)","decl":"/-- If `C` is thin and skeletal, `D ⥤ C` is skeletal.\n`CategoryTheory.functor_thin` shows it is thin also.\n-/\ntheorem functor_skeletal [Quiver.IsThin C] (hC : Skeletal C) : Skeletal (D ⥤ C) := fun _ _ h =>\n  h.elim (Functor.eq_of_iso hC)\n\n"}
{"name":"CategoryTheory.fromSkeleton_map","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX✝ Y✝ : CategoryTheory.InducedCategory C Quotient.out\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.fromSkeleton C).map f) f","decl":"/-- The functor from the skeleton of `C` to `C`. -/\n@[simps!]\nnoncomputable def fromSkeleton : Skeleton C ⥤ C :=\n  inducedFunctor _\n\n-- Porting note: previously `fromSkeleton` used `deriving Faithful, Full`\n"}
{"name":"CategoryTheory.fromSkeleton_obj","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\na✝ : Quotient (CategoryTheory.isIsomorphicSetoid C)\n⊢ Eq ((CategoryTheory.fromSkeleton C).obj a✝) a✝.out","decl":"/-- The functor from the skeleton of `C` to `C`. -/\n@[simps!]\nnoncomputable def fromSkeleton : Skeleton C ⥤ C :=\n  inducedFunctor _\n\n-- Porting note: previously `fromSkeleton` used `deriving Faithful, Full`\n"}
{"name":"CategoryTheory.instFullSkeletonFromSkeleton","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\n⊢ (CategoryTheory.fromSkeleton C).Full","decl":"noncomputable instance : (fromSkeleton C).Full := by\n  apply InducedCategory.full\n"}
{"name":"CategoryTheory.instFaithfulSkeletonFromSkeleton","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\n⊢ (CategoryTheory.fromSkeleton C).Faithful","decl":"noncomputable instance : (fromSkeleton C).Faithful := by\n  apply InducedCategory.faithful\n\n"}
{"name":"CategoryTheory.instEssSurjSkeletonFromSkeleton","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\n⊢ (CategoryTheory.fromSkeleton C).EssSurj","decl":"instance : (fromSkeleton C).EssSurj where mem_essImage X := ⟨Quotient.mk' X, Quotient.mk_out X⟩\n\n-- Porting note: named this instance\n"}
{"name":"CategoryTheory.fromSkeleton.isEquivalence","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\n⊢ (CategoryTheory.fromSkeleton C).IsEquivalence","decl":"noncomputable instance fromSkeleton.isEquivalence : (fromSkeleton C).IsEquivalence where\n\n"}
{"name":"CategoryTheory.toSkeletonFunctor_map","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\nf : Quiver.Hom X Y\n⊢ Eq ((CategoryTheory.toSkeletonFunctor C).map f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.preCounitIso X).hom (CategoryTheory.CategoryStruct.comp f (CategoryTheory.preCounitIso Y).inv))","decl":"/-- An inverse to `fromSkeleton C` that forms an equivalence with it. -/\n@[simps] noncomputable def toSkeletonFunctor : C ⥤ Skeleton C where\n  obj := toSkeleton\n  map {X Y} f := by apply (preCounitIso X).hom ≫ f ≫ (preCounitIso Y).inv\n  map_id _ := by aesop\n  map_comp _ _ := by change _ = CategoryStruct.comp (obj := C) _ _; simp\n\n"}
{"name":"CategoryTheory.toSkeletonFunctor_obj","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\n⊢ Eq ((CategoryTheory.toSkeletonFunctor C).obj X) (CategoryTheory.toSkeleton X)","decl":"/-- An inverse to `fromSkeleton C` that forms an equivalence with it. -/\n@[simps] noncomputable def toSkeletonFunctor : C ⥤ Skeleton C where\n  obj := toSkeleton\n  map {X Y} f := by apply (preCounitIso X).hom ≫ f ≫ (preCounitIso Y).inv\n  map_id _ := by aesop\n  map_comp _ _ := by change _ = CategoryStruct.comp (obj := C) _ _; simp\n\n"}
{"name":"CategoryTheory.skeletonEquivalence_unitIso","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\n⊢ Eq (CategoryTheory.skeletonEquivalence C).unitIso (CategoryTheory.NatIso.ofComponents (fun X => CategoryTheory.InducedCategory.isoMk (Nonempty.some ⋯).symm) ⋯)","decl":"/-- The equivalence between the skeleton and the category itself. -/\n@[simps] noncomputable def skeletonEquivalence : Skeleton C ≌ C where\n  functor := fromSkeleton C\n  inverse := toSkeletonFunctor C\n  unitIso := NatIso.ofComponents\n    (fun X ↦ InducedCategory.isoMk (Nonempty.some <| Quotient.mk_out X.out).symm)\n    fun _ ↦ .symm <| Iso.inv_hom_id_assoc _ _\n  counitIso := NatIso.ofComponents preCounitIso\n  functor_unitIso_comp _ := Iso.inv_hom_id _\n\n"}
{"name":"CategoryTheory.skeletonEquivalence_functor","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\n⊢ Eq (CategoryTheory.skeletonEquivalence C).functor (CategoryTheory.fromSkeleton C)","decl":"/-- The equivalence between the skeleton and the category itself. -/\n@[simps] noncomputable def skeletonEquivalence : Skeleton C ≌ C where\n  functor := fromSkeleton C\n  inverse := toSkeletonFunctor C\n  unitIso := NatIso.ofComponents\n    (fun X ↦ InducedCategory.isoMk (Nonempty.some <| Quotient.mk_out X.out).symm)\n    fun _ ↦ .symm <| Iso.inv_hom_id_assoc _ _\n  counitIso := NatIso.ofComponents preCounitIso\n  functor_unitIso_comp _ := Iso.inv_hom_id _\n\n"}
{"name":"CategoryTheory.skeletonEquivalence_inverse","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\n⊢ Eq (CategoryTheory.skeletonEquivalence C).inverse (CategoryTheory.toSkeletonFunctor C)","decl":"/-- The equivalence between the skeleton and the category itself. -/\n@[simps] noncomputable def skeletonEquivalence : Skeleton C ≌ C where\n  functor := fromSkeleton C\n  inverse := toSkeletonFunctor C\n  unitIso := NatIso.ofComponents\n    (fun X ↦ InducedCategory.isoMk (Nonempty.some <| Quotient.mk_out X.out).symm)\n    fun _ ↦ .symm <| Iso.inv_hom_id_assoc _ _\n  counitIso := NatIso.ofComponents preCounitIso\n  functor_unitIso_comp _ := Iso.inv_hom_id _\n\n"}
{"name":"CategoryTheory.skeletonEquivalence_counitIso","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\n⊢ Eq (CategoryTheory.skeletonEquivalence C).counitIso (CategoryTheory.NatIso.ofComponents CategoryTheory.preCounitIso ⋯)","decl":"/-- The equivalence between the skeleton and the category itself. -/\n@[simps] noncomputable def skeletonEquivalence : Skeleton C ≌ C where\n  functor := fromSkeleton C\n  inverse := toSkeletonFunctor C\n  unitIso := NatIso.ofComponents\n    (fun X ↦ InducedCategory.isoMk (Nonempty.some <| Quotient.mk_out X.out).symm)\n    fun _ ↦ .symm <| Iso.inv_hom_id_assoc _ _\n  counitIso := NatIso.ofComponents preCounitIso\n  functor_unitIso_comp _ := Iso.inv_hom_id _\n\n"}
{"name":"CategoryTheory.skeleton_skeletal","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\n⊢ CategoryTheory.Skeletal (CategoryTheory.Skeleton C)","decl":"theorem skeleton_skeletal : Skeletal (Skeleton C) := by\n  rintro X Y ⟨h⟩\n  have : X.out ≈ Y.out := ⟨(fromSkeleton C).mapIso h⟩\n  simpa using Quotient.sound this\n\n"}
{"name":"CategoryTheory.skeleton_isSkeleton","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\n⊢ CategoryTheory.IsSkeletonOf C (CategoryTheory.Skeleton C) (CategoryTheory.fromSkeleton C)","decl":"/-- The `skeleton` of `C` given by choice is a skeleton of `C`. -/\nlemma skeleton_isSkeleton : IsSkeletonOf C (Skeleton C) (fromSkeleton C) where\n  skel := skeleton_skeletal C\n  eqv := fromSkeleton.isEquivalence C\n\n"}
{"name":"CategoryTheory.toThinSkeleton_obj","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\na : C\n⊢ Eq ((CategoryTheory.toThinSkeleton C).obj a) (Quotient.mk' a)","decl":"/-- The functor from a category to its thin skeleton. -/\n@[simps]\ndef toThinSkeleton : C ⥤ ThinSkeleton C where\n  obj := @Quotient.mk' C _\n  map f := homOfLE (Nonempty.intro f)\n\n"}
{"name":"CategoryTheory.toThinSkeleton_map","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX✝ Y✝ : C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.toThinSkeleton C).map f) (CategoryTheory.homOfLE ⋯)","decl":"/-- The functor from a category to its thin skeleton. -/\n@[simps]\ndef toThinSkeleton : C ⥤ ThinSkeleton C where\n  obj := @Quotient.mk' C _\n  map f := homOfLE (Nonempty.intro f)\n\n"}
{"name":"CategoryTheory.ThinSkeleton.thin","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\n⊢ Quiver.IsThin (CategoryTheory.ThinSkeleton C)","decl":"/-- The thin skeleton is thin. -/\ninstance thin : Quiver.IsThin (ThinSkeleton C) := fun _ _ =>\n  ⟨by\n    rintro ⟨⟨f₁⟩⟩ ⟨⟨_⟩⟩\n    rfl⟩\n\n"}
{"name":"CategoryTheory.ThinSkeleton.map_obj","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\na✝ : Quotient (CategoryTheory.isIsomorphicSetoid C)\n⊢ Eq ((CategoryTheory.ThinSkeleton.map F).obj a✝) (Quotient.map F.obj ⋯ a✝)","decl":"/-- A functor `C ⥤ D` computably lowers to a functor `ThinSkeleton C ⥤ ThinSkeleton D`. -/\n@[simps]\ndef map (F : C ⥤ D) : ThinSkeleton C ⥤ ThinSkeleton D where\n  obj := Quotient.map F.obj fun _ _ ⟨hX⟩ => ⟨F.mapIso hX⟩\n  map {X} {Y} := Quotient.recOnSubsingleton₂ X Y fun _ _ k => homOfLE (k.le.elim fun t => ⟨F.map t⟩)\n\n"}
{"name":"CategoryTheory.ThinSkeleton.map_map","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nX Y : CategoryTheory.ThinSkeleton C\na✝ : Quiver.Hom X Y\n⊢ Eq ((CategoryTheory.ThinSkeleton.map F).map a✝) (Quotient.recOnSubsingleton₂ (motive := fun x x_1 => Quiver.Hom x x_1 → Quiver.Hom (Quotient.map F.obj ⋯ x) (Quotient.map F.obj ⋯ x_1)) X Y (fun x x_1 k => CategoryTheory.homOfLE ⋯) a✝)","decl":"/-- A functor `C ⥤ D` computably lowers to a functor `ThinSkeleton C ⥤ ThinSkeleton D`. -/\n@[simps]\ndef map (F : C ⥤ D) : ThinSkeleton C ⥤ ThinSkeleton D where\n  obj := Quotient.map F.obj fun _ _ ⟨hX⟩ => ⟨F.mapIso hX⟩\n  map {X} {Y} := Quotient.recOnSubsingleton₂ X Y fun _ _ k => homOfLE (k.le.elim fun t => ⟨F.map t⟩)\n\n"}
{"name":"CategoryTheory.ThinSkeleton.comp_toThinSkeleton","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\n⊢ Eq (F.comp (CategoryTheory.toThinSkeleton D)) ((CategoryTheory.toThinSkeleton C).comp (CategoryTheory.ThinSkeleton.map F))","decl":"theorem comp_toThinSkeleton (F : C ⥤ D) : F ⋙ toThinSkeleton D = toThinSkeleton C ⋙ map F :=\n  rfl\n\n"}
{"name":"CategoryTheory.ThinSkeleton.map₂_obj","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C (CategoryTheory.Functor D E)\na✝ : CategoryTheory.ThinSkeleton C\n⊢ Eq ((CategoryTheory.ThinSkeleton.map₂ F).obj a✝) (CategoryTheory.ThinSkeleton.map₂Functor F a✝)","decl":"/-- A functor `C ⥤ D ⥤ E` computably lowers to a functor\n`ThinSkeleton C ⥤ ThinSkeleton D ⥤ ThinSkeleton E` -/\n@[simps]\ndef map₂ (F : C ⥤ D ⥤ E) : ThinSkeleton C ⥤ ThinSkeleton D ⥤ ThinSkeleton E where\n  obj := map₂Functor F\n  map := map₂NatTrans F\n\n"}
{"name":"CategoryTheory.ThinSkeleton.map₂_map","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C (CategoryTheory.Functor D E)\nX✝ Y✝ : CategoryTheory.ThinSkeleton C\na✝ : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.ThinSkeleton.map₂ F).map a✝) (CategoryTheory.ThinSkeleton.map₂NatTrans F a✝)","decl":"/-- A functor `C ⥤ D ⥤ E` computably lowers to a functor\n`ThinSkeleton C ⥤ ThinSkeleton D ⥤ ThinSkeleton E` -/\n@[simps]\ndef map₂ (F : C ⥤ D ⥤ E) : ThinSkeleton C ⥤ ThinSkeleton D ⥤ ThinSkeleton E where\n  obj := map₂Functor F\n  map := map₂NatTrans F\n\n"}
{"name":"CategoryTheory.ThinSkeleton.toThinSkeleton_faithful","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\n⊢ (CategoryTheory.toThinSkeleton C).Faithful","decl":"instance toThinSkeleton_faithful : (toThinSkeleton C).Faithful where\n\n"}
{"name":"CategoryTheory.ThinSkeleton.fromThinSkeleton_map","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : Quiver.IsThin C\nx y : CategoryTheory.ThinSkeleton C\na✝ : Quiver.Hom x y\n⊢ Eq ((CategoryTheory.ThinSkeleton.fromThinSkeleton C).map a✝) (Quotient.recOnSubsingleton₂ (motive := fun x x_1 => Quiver.Hom x x_1 → Quiver.Hom (Quotient.out x) (Quotient.out x_1)) x y (fun X Y f => CategoryTheory.CategoryStruct.comp (Nonempty.some ⋯).hom (CategoryTheory.CategoryStruct.comp (Nonempty.some ⋯) (Nonempty.some ⋯).inv)) a✝)","decl":"/-- Use `Quotient.out` to create a functor out of the thin skeleton. -/\n@[simps]\nnoncomputable def fromThinSkeleton : ThinSkeleton C ⥤ C where\n  obj := Quotient.out\n  map {x} {y} :=\n    Quotient.recOnSubsingleton₂ x y fun X Y f =>\n      (Nonempty.some (Quotient.mk_out X)).hom ≫ f.le.some ≫ (Nonempty.some (Quotient.mk_out Y)).inv\n\n"}
{"name":"CategoryTheory.ThinSkeleton.fromThinSkeleton_obj","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : Quiver.IsThin C\na✝ : Quotient (CategoryTheory.isIsomorphicSetoid C)\n⊢ Eq ((CategoryTheory.ThinSkeleton.fromThinSkeleton C).obj a✝) a✝.out","decl":"/-- Use `Quotient.out` to create a functor out of the thin skeleton. -/\n@[simps]\nnoncomputable def fromThinSkeleton : ThinSkeleton C ⥤ C where\n  obj := Quotient.out\n  map {x} {y} :=\n    Quotient.recOnSubsingleton₂ x y fun X Y f =>\n      (Nonempty.some (Quotient.mk_out X)).hom ≫ f.le.some ≫ (Nonempty.some (Quotient.mk_out Y)).inv\n\n"}
{"name":"CategoryTheory.ThinSkeleton.fromThinSkeleton_isEquivalence","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : Quiver.IsThin C\n⊢ (CategoryTheory.ThinSkeleton.fromThinSkeleton C).IsEquivalence","decl":"noncomputable instance fromThinSkeleton_isEquivalence : (fromThinSkeleton C).IsEquivalence :=\n  (equivalence C).isEquivalence_functor\n\n"}
{"name":"CategoryTheory.ThinSkeleton.equiv_of_both_ways","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : Quiver.IsThin C\nX Y : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y X\n⊢ HasEquiv.Equiv X Y","decl":"theorem equiv_of_both_ways {X Y : C} (f : X ⟶ Y) (g : Y ⟶ X) : X ≈ Y :=\n  ⟨iso_of_both_ways f g⟩\n\n"}
{"name":"CategoryTheory.ThinSkeleton.skeletal","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : Quiver.IsThin C\n⊢ CategoryTheory.Skeletal (CategoryTheory.ThinSkeleton C)","decl":"theorem skeletal : Skeletal (ThinSkeleton C) := fun X Y =>\n  Quotient.inductionOn₂ X Y fun _ _ h => h.elim fun i => i.1.le.antisymm i.2.le\n\n"}
{"name":"CategoryTheory.ThinSkeleton.map_comp_eq","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} E\ninst✝ : Quiver.IsThin C\nF : CategoryTheory.Functor E D\nG : CategoryTheory.Functor D C\n⊢ Eq (CategoryTheory.ThinSkeleton.map (F.comp G)) ((CategoryTheory.ThinSkeleton.map F).comp (CategoryTheory.ThinSkeleton.map G))","decl":"theorem map_comp_eq (F : E ⥤ D) (G : D ⥤ C) : map (F ⋙ G) = map F ⋙ map G :=\n  Functor.eq_of_iso skeletal <|\n    NatIso.ofComponents fun X => Quotient.recOnSubsingleton X fun _ => Iso.refl _\n\n"}
{"name":"CategoryTheory.ThinSkeleton.map_id_eq","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : Quiver.IsThin C\n⊢ Eq (CategoryTheory.ThinSkeleton.map (CategoryTheory.Functor.id C)) (CategoryTheory.Functor.id (CategoryTheory.ThinSkeleton C))","decl":"theorem map_id_eq : map (𝟭 C) = 𝟭 (ThinSkeleton C) :=\n  Functor.eq_of_iso skeletal <|\n    NatIso.ofComponents fun X => Quotient.recOnSubsingleton X fun _ => Iso.refl _\n\n"}
{"name":"CategoryTheory.ThinSkeleton.map_iso_eq","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : Quiver.IsThin C\nF₁ F₂ : CategoryTheory.Functor D C\nh : CategoryTheory.Iso F₁ F₂\n⊢ Eq (CategoryTheory.ThinSkeleton.map F₁) (CategoryTheory.ThinSkeleton.map F₂)","decl":"theorem map_iso_eq {F₁ F₂ : D ⥤ C} (h : F₁ ≅ F₂) : map F₁ = map F₂ :=\n  Functor.eq_of_iso skeletal\n    { hom := mapNatTrans h.hom\n      inv := mapNatTrans h.inv }\n\n"}
{"name":"CategoryTheory.ThinSkeleton.thinSkeleton_isSkeleton","module":"Mathlib.CategoryTheory.Skeletal","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : Quiver.IsThin C\n⊢ CategoryTheory.IsSkeletonOf C (CategoryTheory.ThinSkeleton C) (CategoryTheory.ThinSkeleton.fromThinSkeleton C)","decl":"/-- `fromThinSkeleton C` exhibits the thin skeleton as a skeleton. -/\nlemma thinSkeleton_isSkeleton : IsSkeletonOf C (ThinSkeleton C) (fromThinSkeleton C) where\n  skel := skeletal\n\n"}
