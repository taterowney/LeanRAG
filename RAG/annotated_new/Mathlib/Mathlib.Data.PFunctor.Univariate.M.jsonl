{"name":"PFunctor.Approx.CofixA.intro.inj","module":"Mathlib.Data.PFunctor.Univariate.M","initialProofState":"F : PFunctor.{u}\nn : Nat\na✝² : F.A\na✝¹ : F.B a✝² → PFunctor.Approx.CofixA F n\na : F.A\na✝ : F.B a → PFunctor.Approx.CofixA F n\nx✝ : Eq (PFunctor.Approx.CofixA.intro a✝² a✝¹) (PFunctor.Approx.CofixA.intro a a✝)\n⊢ And (Eq a✝² a) (HEq a✝¹ a✝)","decl":"/-- `CofixA F n` is an `n` level approximation of an M-type -/\ninductive CofixA : ℕ → Type u\n  | continue : CofixA 0\n  | intro {n} : ∀ a, (F.B a → CofixA n) → CofixA (succ n)\n\n"}
{"name":"PFunctor.Approx.CofixA.intro.sizeOf_spec","module":"Mathlib.Data.PFunctor.Univariate.M","initialProofState":"F : PFunctor.{u}\nn : Nat\na : F.A\na✝ : F.B a → PFunctor.Approx.CofixA F n\n⊢ Eq (SizeOf.sizeOf (PFunctor.Approx.CofixA.intro a a✝)) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf n)) (SizeOf.sizeOf a))","decl":"/-- `CofixA F n` is an `n` level approximation of an M-type -/\ninductive CofixA : ℕ → Type u\n  | continue : CofixA 0\n  | intro {n} : ∀ a, (F.B a → CofixA n) → CofixA (succ n)\n\n"}
{"name":"PFunctor.Approx.CofixA.intro.injEq","module":"Mathlib.Data.PFunctor.Univariate.M","initialProofState":"F : PFunctor.{u}\nn : Nat\na✝² : F.A\na✝¹ : F.B a✝² → PFunctor.Approx.CofixA F n\na : F.A\na✝ : F.B a → PFunctor.Approx.CofixA F n\n⊢ Eq (Eq (PFunctor.Approx.CofixA.intro a✝² a✝¹) (PFunctor.Approx.CofixA.intro a a✝)) (And (Eq a✝² a) (HEq a✝¹ a✝))","decl":"/-- `CofixA F n` is an `n` level approximation of an M-type -/\ninductive CofixA : ℕ → Type u\n  | continue : CofixA 0\n  | intro {n} : ∀ a, (F.B a → CofixA n) → CofixA (succ n)\n\n"}
{"name":"PFunctor.Approx.CofixA.continue.sizeOf_spec","module":"Mathlib.Data.PFunctor.Univariate.M","initialProofState":"F : PFunctor.{u}\n⊢ Eq (SizeOf.sizeOf PFunctor.Approx.CofixA.continue) 1","decl":"/-- `CofixA F n` is an `n` level approximation of an M-type -/\ninductive CofixA : ℕ → Type u\n  | continue : CofixA 0\n  | intro {n} : ∀ a, (F.B a → CofixA n) → CofixA (succ n)\n\n"}
{"name":"PFunctor.Approx.cofixA_eq_zero","module":"Mathlib.Data.PFunctor.Univariate.M","initialProofState":"F : PFunctor.{u}\nx y : PFunctor.Approx.CofixA F 0\n⊢ Eq x y","decl":"theorem cofixA_eq_zero : ∀ x y : CofixA F 0, x = y\n  | CofixA.continue, CofixA.continue => rfl\n\n"}
{"name":"PFunctor.Approx.approx_eta","module":"Mathlib.Data.PFunctor.Univariate.M","initialProofState":"F : PFunctor.{u}\nn : Nat\nx : PFunctor.Approx.CofixA F (HAdd.hAdd n 1)\n⊢ Eq x (PFunctor.Approx.CofixA.intro (PFunctor.Approx.head' x) (PFunctor.Approx.children' x))","decl":"theorem approx_eta {n : ℕ} (x : CofixA F (n + 1)) : x = CofixA.intro (head' x) (children' x) := by\n  cases x; rfl\n\n"}
{"name":"PFunctor.Approx.Agree.brecOn","module":"Mathlib.Data.PFunctor.Univariate.M","initialProofState":"F : PFunctor.{u}\nmotive✝ : {n : Nat} → (a : PFunctor.Approx.CofixA F n) → (a_1 : PFunctor.Approx.CofixA F (HAdd.hAdd n 1)) → PFunctor.Approx.Agree a a_1 → Prop\nn : Nat\na✝¹ : PFunctor.Approx.CofixA F n\na✝ : PFunctor.Approx.CofixA F (HAdd.hAdd n 1)\nx✝ : PFunctor.Approx.Agree a✝¹ a✝\nih✝ : ∀ {n : Nat} (a : PFunctor.Approx.CofixA F n) (a_1 : PFunctor.Approx.CofixA F (HAdd.hAdd n 1)) (x : PFunctor.Approx.Agree a a_1), x.below → motive✝ a a_1 x\n⊢ motive✝ a✝¹ a✝ x✝","decl":"/-- Relation between two approximations of the cofix of a pfunctor\nthat state they both contain the same data until one of them is truncated -/\ninductive Agree : ∀ {n : ℕ}, CofixA F n → CofixA F (n + 1) → Prop\n  | continu (x : CofixA F 0) (y : CofixA F 1) : Agree x y\n  | intro {n} {a} (x : F.B a → CofixA F n) (x' : F.B a → CofixA F (n + 1)) :\n    (∀ i : F.B a, Agree (x i) (x' i)) → Agree (CofixA.intro a x) (CofixA.intro a x')\n\n"}
{"name":"PFunctor.Approx.agree_trivial","module":"Mathlib.Data.PFunctor.Univariate.M","initialProofState":"F : PFunctor.{u}\nx : PFunctor.Approx.CofixA F 0\ny : PFunctor.Approx.CofixA F 1\n⊢ PFunctor.Approx.Agree x y","decl":"@[simp]\ntheorem agree_trivial {x : CofixA F 0} {y : CofixA F 1} : Agree x y := by constructor\n\n"}
{"name":"PFunctor.Approx.agree_trival","module":"Mathlib.Data.PFunctor.Univariate.M","initialProofState":"F : PFunctor.{u}\nx : PFunctor.Approx.CofixA F 0\ny : PFunctor.Approx.CofixA F 1\n⊢ PFunctor.Approx.Agree x y","decl":"@[deprecated (since := \"2024-12-25\")] alias agree_trival := agree_trivial\n\n"}
{"name":"PFunctor.Approx.agree_children","module":"Mathlib.Data.PFunctor.Univariate.M","initialProofState":"F : PFunctor.{u}\nn : Nat\nx : PFunctor.Approx.CofixA F n.succ\ny : PFunctor.Approx.CofixA F (HAdd.hAdd n.succ 1)\ni : F.B (PFunctor.Approx.head' x)\nj : F.B (PFunctor.Approx.head' y)\nh₀ : HEq i j\nh₁ : PFunctor.Approx.Agree x y\n⊢ PFunctor.Approx.Agree (PFunctor.Approx.children' x i) (PFunctor.Approx.children' y j)","decl":"theorem agree_children {n : ℕ} (x : CofixA F (succ n)) (y : CofixA F (succ n + 1)) {i j}\n    (h₀ : HEq i j) (h₁ : Agree x y) : Agree (children' x i) (children' y j) := by\n  cases' h₁ with _ _ _ _ _ _ hagree; cases h₀\n  apply hagree\n\n"}
{"name":"PFunctor.Approx.truncate_eq_of_agree","module":"Mathlib.Data.PFunctor.Univariate.M","initialProofState":"F : PFunctor.{u}\nn : Nat\nx : PFunctor.Approx.CofixA F n\ny : PFunctor.Approx.CofixA F n.succ\nh : PFunctor.Approx.Agree x y\n⊢ Eq (PFunctor.Approx.truncate y) x","decl":"theorem truncate_eq_of_agree {n : ℕ} (x : CofixA F n) (y : CofixA F (succ n)) (h : Agree x y) :\n    truncate y = x := by\n  induction n <;> cases x <;> cases y\n  · rfl\n  · -- cases' h with _ _ _ _ _ h₀ h₁\n    cases h\n    simp only [truncate, Function.comp_def, eq_self_iff_true, heq_iff_eq]\n    -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): used to be `ext y`\n    rename_i n_ih a f y h₁\n    suffices (fun x => truncate (y x)) = f\n      by simp [this]\n    funext y\n\n    apply n_ih\n    apply h₁\n\n"}
{"name":"PFunctor.Approx.P_corec","module":"Mathlib.Data.PFunctor.Univariate.M","initialProofState":"F : PFunctor.{u}\nX : Type w\nf : X → ↑F X\ni : X\nn : Nat\n⊢ PFunctor.Approx.Agree (PFunctor.Approx.sCorec f i n) (PFunctor.Approx.sCorec f i n.succ)","decl":"theorem P_corec (i : X) (n : ℕ) : Agree (sCorec f i n) (sCorec f i (succ n)) := by\n  induction' n with n n_ih generalizing i\n  constructor\n  cases' f i with y g\n  constructor\n  introv\n  apply n_ih\n\n"}
{"name":"PFunctor.Approx.CofixA.instSubsingleton","module":"Mathlib.Data.PFunctor.Univariate.M","initialProofState":"F : PFunctor.{u}\n⊢ Subsingleton (PFunctor.Approx.CofixA F 0)","decl":"instance CofixA.instSubsingleton : Subsingleton (CofixA F 0) :=\n  ⟨by rintro ⟨⟩ ⟨⟩; rfl⟩\n\n"}
{"name":"PFunctor.Approx.head_succ'","module":"Mathlib.Data.PFunctor.Univariate.M","initialProofState":"F : PFunctor.{u}\nn m : Nat\nx : (n : Nat) → PFunctor.Approx.CofixA F n\nHconsistent : PFunctor.Approx.AllAgree x\n⊢ Eq (PFunctor.Approx.head' (x n.succ)) (PFunctor.Approx.head' (x m.succ))","decl":"theorem head_succ' (n m : ℕ) (x : ∀ n, CofixA F n) (Hconsistent : AllAgree x) :\n    head' (x (succ n)) = head' (x (succ m)) := by\n  suffices ∀ n, head' (x (succ n)) = head' (x 1) by simp [this]\n  clear m n\n  intro n\n  cases' h₀ : x (succ n) with _ i₀ f₀\n  cases' h₁ : x 1 with _ i₁ f₁\n  dsimp only [head']\n  induction' n with n n_ih\n  · rw [h₁] at h₀\n    cases h₀\n    trivial\n  · have H := Hconsistent (succ n)\n    cases' h₂ : x (succ n) with _ i₂ f₂\n    rw [h₀, h₂] at H\n    apply n_ih (truncate ∘ f₀)\n    rw [h₂]\n    cases' H with _ _ _ _ _ _ hagree\n    congr\n    funext j\n    dsimp only [comp_apply]\n    rw [truncate_eq_of_agree]\n    apply hagree\n\n"}
{"name":"PFunctor.MIntl.mk.sizeOf_spec","module":"Mathlib.Data.PFunctor.Univariate.M","initialProofState":"F : PFunctor.{u}\napprox : (n : Nat) → PFunctor.Approx.CofixA F n\nconsistent : PFunctor.Approx.AllAgree approx\n⊢ Eq (SizeOf.sizeOf { approx := approx, consistent := consistent }) 1","decl":"/-- Internal definition for `M`. It is needed to avoid name clashes\nbetween `M.mk` and `M.casesOn` and the declarations generated for\nthe structure -/\nstructure MIntl where\n  /-- An `n`-th level approximation, for each depth `n` -/\n  approx : ∀ n, CofixA F n\n  /-- Each approximation agrees with the next -/\n  consistent : AllAgree approx\n\n"}
{"name":"PFunctor.MIntl.consistent","module":"Mathlib.Data.PFunctor.Univariate.M","initialProofState":"F : PFunctor.{u}\nself : F.MIntl\n⊢ PFunctor.Approx.AllAgree self.approx","decl":"/-- Internal definition for `M`. It is needed to avoid name clashes\nbetween `M.mk` and `M.casesOn` and the declarations generated for\nthe structure -/\nstructure MIntl where\n  /-- An `n`-th level approximation, for each depth `n` -/\n  approx : ∀ n, CofixA F n\n  /-- Each approximation agrees with the next -/\n  consistent : AllAgree approx\n\n"}
{"name":"PFunctor.MIntl.mk.inj","module":"Mathlib.Data.PFunctor.Univariate.M","initialProofState":"F : PFunctor.{u}\napprox✝ : (n : Nat) → PFunctor.Approx.CofixA F n\nconsistent✝ : PFunctor.Approx.AllAgree approx✝\napprox : (n : Nat) → PFunctor.Approx.CofixA F n\nconsistent : PFunctor.Approx.AllAgree approx\nx✝ : Eq { approx := approx✝, consistent := consistent✝ } { approx := approx, consistent := consistent }\n⊢ Eq approx✝ approx","decl":"/-- Internal definition for `M`. It is needed to avoid name clashes\nbetween `M.mk` and `M.casesOn` and the declarations generated for\nthe structure -/\nstructure MIntl where\n  /-- An `n`-th level approximation, for each depth `n` -/\n  approx : ∀ n, CofixA F n\n  /-- Each approximation agrees with the next -/\n  consistent : AllAgree approx\n\n"}
{"name":"PFunctor.MIntl.mk.injEq","module":"Mathlib.Data.PFunctor.Univariate.M","initialProofState":"F : PFunctor.{u}\napprox✝ : (n : Nat) → PFunctor.Approx.CofixA F n\nconsistent✝ : PFunctor.Approx.AllAgree approx✝\napprox : (n : Nat) → PFunctor.Approx.CofixA F n\nconsistent : PFunctor.Approx.AllAgree approx\n⊢ Eq (Eq { approx := approx✝, consistent := consistent✝ } { approx := approx, consistent := consistent }) (Eq approx✝ approx)","decl":"/-- Internal definition for `M`. It is needed to avoid name clashes\nbetween `M.mk` and `M.casesOn` and the declarations generated for\nthe structure -/\nstructure MIntl where\n  /-- An `n`-th level approximation, for each depth `n` -/\n  approx : ∀ n, CofixA F n\n  /-- Each approximation agrees with the next -/\n  consistent : AllAgree approx\n\n"}
{"name":"PFunctor.M.default_consistent","module":"Mathlib.Data.PFunctor.Univariate.M","initialProofState":"F : PFunctor.{u}\ninst✝ : Inhabited F.A\nn : Nat\n⊢ PFunctor.Approx.Agree Inhabited.default Inhabited.default","decl":"theorem M.default_consistent [Inhabited F.A] : ∀ n, Agree (default : CofixA F n) default\n  | 0 => Agree.continu _ _\n  | succ n => Agree.intro _ _ fun _ => M.default_consistent n\n\n"}
{"name":"PFunctor.M.ext'","module":"Mathlib.Data.PFunctor.Univariate.M","initialProofState":"F : PFunctor.{u}\nx y : F.M\nH : ∀ (i : Nat), Eq (x.approx i) (y.approx i)\n⊢ Eq x y","decl":"theorem ext' (x y : M F) (H : ∀ i : ℕ, x.approx i = y.approx i) : x = y := by\n  cases x\n  cases y\n  congr with n\n  apply H\n\n"}
{"name":"PFunctor.M.head_succ","module":"Mathlib.Data.PFunctor.Univariate.M","initialProofState":"F : PFunctor.{u}\nn m : Nat\nx : F.M\n⊢ Eq (PFunctor.Approx.head' (x.approx n.succ)) (PFunctor.Approx.head' (x.approx m.succ))","decl":"theorem head_succ (n m : ℕ) (x : M F) : head' (x.approx (succ n)) = head' (x.approx (succ m)) :=\n  head_succ' n m _ x.consistent\n\n"}
{"name":"PFunctor.M.head_eq_head'","module":"Mathlib.Data.PFunctor.Univariate.M","initialProofState":"F : PFunctor.{u}\nx : F.M\nn : Nat\n⊢ Eq x.head (PFunctor.Approx.head' (x.approx (HAdd.hAdd n 1)))","decl":"theorem head_eq_head' : ∀ (x : M F) (n : ℕ), head x = head' (x.approx <| n + 1)\n  | ⟨_, h⟩, _ => head_succ' _ _ _ h\n\n"}
{"name":"PFunctor.M.head'_eq_head","module":"Mathlib.Data.PFunctor.Univariate.M","initialProofState":"F : PFunctor.{u}\nx : F.M\nn : Nat\n⊢ Eq (PFunctor.Approx.head' (x.approx (HAdd.hAdd n 1))) x.head","decl":"theorem head'_eq_head : ∀ (x : M F) (n : ℕ), head' (x.approx <| n + 1) = head x\n  | ⟨_, h⟩, _ => head_succ' _ _ _ h\n\n"}
{"name":"PFunctor.M.truncate_approx","module":"Mathlib.Data.PFunctor.Univariate.M","initialProofState":"F : PFunctor.{u}\nx : F.M\nn : Nat\n⊢ Eq (PFunctor.Approx.truncate (x.approx (HAdd.hAdd n 1))) (x.approx n)","decl":"theorem truncate_approx (x : M F) (n : ℕ) : truncate (x.approx <| n + 1) = x.approx n :=\n  truncate_eq_of_agree _ _ (x.consistent _)\n\n"}
{"name":"PFunctor.M.Approx.P_mk","module":"Mathlib.Data.PFunctor.Univariate.M","initialProofState":"F : PFunctor.{u}\nx : ↑F F.M\n⊢ PFunctor.Approx.AllAgree (PFunctor.M.Approx.sMk x)","decl":"protected theorem P_mk (x : F (M F)) : AllAgree (Approx.sMk x)\n  | 0 => by constructor\n  | succ n => by\n    constructor\n    introv\n    apply (x.2 i).consistent\n\n"}
{"name":"PFunctor.M.dest_mk","module":"Mathlib.Data.PFunctor.Univariate.M","initialProofState":"F : PFunctor.{u}\nx : ↑F F.M\n⊢ Eq (PFunctor.M.mk x).dest x","decl":"@[simp]\ntheorem dest_mk (x : F (M F)) : dest (M.mk x) = x := rfl\n\n"}
{"name":"PFunctor.M.mk_dest","module":"Mathlib.Data.PFunctor.Univariate.M","initialProofState":"F : PFunctor.{u}\nx : F.M\n⊢ Eq (PFunctor.M.mk x.dest) x","decl":"@[simp]\ntheorem mk_dest (x : M F) : M.mk (dest x) = x := by\n  apply ext'\n  intro n\n  dsimp only [M.mk]\n  induction' n with n\n  · apply @Subsingleton.elim _ CofixA.instSubsingleton\n  dsimp only [Approx.sMk, dest, head]\n  cases' h : x.approx (succ n) with _ hd ch\n  have h' : hd = head' (x.approx 1) := by\n    rw [← head_succ' n, h, head']\n    apply x.consistent\n  revert ch\n  rw [h']\n  intros ch h\n  congr\n  ext a\n  dsimp only [children]\n  generalize hh : cast _ a = a''\n  rw [cast_eq_iff_heq] at hh\n  revert a''\n  rw [h]\n  intros _ hh\n  cases hh\n  rfl\n\n"}
{"name":"PFunctor.M.mk_inj","module":"Mathlib.Data.PFunctor.Univariate.M","initialProofState":"F : PFunctor.{u}\nx y : ↑F F.M\nh : Eq (PFunctor.M.mk x) (PFunctor.M.mk y)\n⊢ Eq x y","decl":"theorem mk_inj {x y : F (M F)} (h : M.mk x = M.mk y) : x = y := by rw [← dest_mk x, h, dest_mk]\n\n"}
{"name":"PFunctor.M.approx_mk","module":"Mathlib.Data.PFunctor.Univariate.M","initialProofState":"F : PFunctor.{u}\na : F.A\nf : F.B a → F.M\ni : Nat\n⊢ Eq ((PFunctor.M.mk ⟨a, f⟩).approx i.succ) (PFunctor.Approx.CofixA.intro a fun j => (f j).approx i)","decl":"theorem approx_mk (a : F.A) (f : F.B a → M F) (i : ℕ) :\n    (M.mk ⟨a, f⟩).approx (succ i) = CofixA.intro a fun j => (f j).approx i :=\n  rfl\n\n"}
{"name":"PFunctor.M.agree'_refl","module":"Mathlib.Data.PFunctor.Univariate.M","initialProofState":"F : PFunctor.{u}\nn : Nat\nx : F.M\n⊢ PFunctor.M.Agree' n x x","decl":"@[simp]\ntheorem agree'_refl {n : ℕ} (x : M F) : Agree' n x x := by\n  induction' n with _ n_ih generalizing x <;>\n  induction x using PFunctor.M.casesOn' <;> constructor <;> try rfl\n  intros\n  apply n_ih\n\n"}
{"name":"PFunctor.M.agree_iff_agree'","module":"Mathlib.Data.PFunctor.Univariate.M","initialProofState":"F : PFunctor.{u}\nn : Nat\nx y : F.M\n⊢ Iff (PFunctor.Approx.Agree (x.approx n) (y.approx (HAdd.hAdd n 1))) (PFunctor.M.Agree' n x y)","decl":"theorem agree_iff_agree' {n : ℕ} (x y : M F) :\n    Agree (x.approx n) (y.approx <| n + 1) ↔ Agree' n x y := by\n  constructor <;> intro h\n  · induction' n with _ n_ih generalizing x y\n    · constructor\n    · induction x using PFunctor.M.casesOn'\n      induction y using PFunctor.M.casesOn'\n      simp only [approx_mk] at h\n      cases' h with _ _ _ _ _ _ hagree\n      constructor <;> try rfl\n      intro i\n      apply n_ih\n      apply hagree\n  · induction' n with _ n_ih generalizing x y\n    · constructor\n    · cases' h with _ _ _ a x' y'\n      induction' x using PFunctor.M.casesOn' with x_a x_f\n      induction' y using PFunctor.M.casesOn' with y_a y_f\n      simp only [approx_mk]\n      have h_a_1 := mk_inj ‹M.mk ⟨x_a, x_f⟩ = M.mk ⟨a, x'⟩›\n      cases h_a_1\n      replace h_a_2 := mk_inj ‹M.mk ⟨y_a, y_f⟩ = M.mk ⟨a, y'⟩›\n      cases h_a_2\n      constructor\n      intro i\n      apply n_ih\n      simp [*]\n\n"}
{"name":"PFunctor.M.cases_mk","module":"Mathlib.Data.PFunctor.Univariate.M","initialProofState":"F : PFunctor.{u}\nr : F.M → Sort u_2\nx : ↑F F.M\nf : (x : ↑F F.M) → r (PFunctor.M.mk x)\n⊢ Eq (PFunctor.M.cases f (PFunctor.M.mk x)) (f x)","decl":"@[simp]\ntheorem cases_mk {r : M F → Sort*} (x : F (M F)) (f : ∀ x : F (M F), r (M.mk x)) :\n    PFunctor.M.cases f (M.mk x) = f x := by\n  dsimp only [M.mk, PFunctor.M.cases, dest, head, Approx.sMk, head']\n  cases x; dsimp only [Approx.sMk]\n  simp only [Eq.mpr]\n  apply congrFun\n  rfl\n\n"}
{"name":"PFunctor.M.casesOn_mk","module":"Mathlib.Data.PFunctor.Univariate.M","initialProofState":"F : PFunctor.{u}\nr : F.M → Sort u_2\nx : ↑F F.M\nf : (x : ↑F F.M) → r (PFunctor.M.mk x)\n⊢ Eq ((PFunctor.M.mk x).casesOn f) (f x)","decl":"@[simp]\ntheorem casesOn_mk {r : M F → Sort*} (x : F (M F)) (f : ∀ x : F (M F), r (M.mk x)) :\n    PFunctor.M.casesOn (M.mk x) f = f x :=\n  cases_mk x f\n\n"}
{"name":"PFunctor.M.casesOn_mk'","module":"Mathlib.Data.PFunctor.Univariate.M","initialProofState":"F : PFunctor.{u}\nr : F.M → Sort u_2\na : F.A\nx : F.B a → F.M\nf : (a : F.A) → (f : F.B a → F.M) → r (PFunctor.M.mk ⟨a, f⟩)\n⊢ Eq ((PFunctor.M.mk ⟨a, x⟩).casesOn' f) (f a x)","decl":"@[simp]\ntheorem casesOn_mk' {r : M F → Sort*} {a} (x : F.B a → M F)\n    (f : ∀ (a) (f : F.B a → M F), r (M.mk ⟨a, f⟩)) :\n    PFunctor.M.casesOn' (M.mk ⟨a, x⟩) f = f a x :=\n  @cases_mk F r ⟨a, x⟩ (fun ⟨a, g⟩ => f a g)\n\n"}
{"name":"PFunctor.M.isPath_cons","module":"Mathlib.Data.PFunctor.Univariate.M","initialProofState":"F : PFunctor.{u}\nxs : PFunctor.Approx.Path F\na a' : F.A\nf : F.B a → F.M\ni : F.B a'\na✝ : PFunctor.M.IsPath (List.cons ⟨a', i⟩ xs) (PFunctor.M.mk ⟨a, f⟩)\n⊢ Eq a a'","decl":"theorem isPath_cons {xs : Path F} {a a'} {f : F.B a → M F} {i : F.B a'} :\n    IsPath (⟨a', i⟩ :: xs) (M.mk ⟨a, f⟩) → a = a' := by\n  generalize h : M.mk ⟨a, f⟩ = x\n  rintro (_ | ⟨_, _, _, _, rfl, _⟩)\n  cases mk_inj h\n  rfl\n\n"}
{"name":"PFunctor.M.isPath_cons'","module":"Mathlib.Data.PFunctor.Univariate.M","initialProofState":"F : PFunctor.{u}\nxs : PFunctor.Approx.Path F\na : F.A\nf : F.B a → F.M\ni : F.B a\na✝ : PFunctor.M.IsPath (List.cons ⟨a, i⟩ xs) (PFunctor.M.mk ⟨a, f⟩)\n⊢ PFunctor.M.IsPath xs (f i)","decl":"theorem isPath_cons' {xs : Path F} {a} {f : F.B a → M F} {i : F.B a} :\n    IsPath (⟨a, i⟩ :: xs) (M.mk ⟨a, f⟩) → IsPath xs (f i) := by\n  generalize h : M.mk ⟨a, f⟩ = x\n  rintro (_ | ⟨_, _, _, _, rfl, hp⟩)\n  cases mk_inj h\n  exact hp\n\n"}
{"name":"PFunctor.M.iselect_eq_default","module":"Mathlib.Data.PFunctor.Univariate.M","initialProofState":"F : PFunctor.{u}\ninst✝¹ : DecidableEq F.A\ninst✝ : Inhabited F.M\nps : PFunctor.Approx.Path F\nx : F.M\nh : Not (PFunctor.M.IsPath ps x)\n⊢ Eq (PFunctor.M.iselect ps x) Inhabited.default.head","decl":"theorem iselect_eq_default [DecidableEq F.A] [Inhabited (M F)] (ps : Path F) (x : M F)\n    (h : ¬IsPath ps x) : iselect ps x = head default := by\n  induction' ps with ps_hd ps_tail ps_ih generalizing x\n  · exfalso\n    apply h\n    constructor\n  · cases' ps_hd with a i\n    induction' x using PFunctor.M.casesOn' with x_a x_f\n    simp only [iselect, isubtree] at ps_ih ⊢\n    by_cases h'' : a = x_a\n    · subst x_a\n      simp only [dif_pos, eq_self_iff_true, casesOn_mk']\n      rw [ps_ih]\n      intro h'\n      apply h\n      constructor <;> try rfl\n      apply h'\n    · simp [*]\n\n"}
{"name":"PFunctor.M.head_mk","module":"Mathlib.Data.PFunctor.Univariate.M","initialProofState":"F : PFunctor.{u}\nx : ↑F F.M\n⊢ Eq (PFunctor.M.mk x).head x.fst","decl":"@[simp]\ntheorem head_mk (x : F (M F)) : head (M.mk x) = x.1 :=\n  Eq.symm <|\n    calc\n      x.1 = (dest (M.mk x)).1 := by rw [dest_mk]\n      _ = head (M.mk x) := rfl\n\n"}
{"name":"PFunctor.M.children_mk","module":"Mathlib.Data.PFunctor.Univariate.M","initialProofState":"F : PFunctor.{u}\na : F.A\nx : F.B a → F.M\ni : F.B (PFunctor.M.mk ⟨a, x⟩).head\n⊢ Eq ((PFunctor.M.mk ⟨a, x⟩).children i) (x (cast ⋯ i))","decl":"theorem children_mk {a} (x : F.B a → M F) (i : F.B (head (M.mk ⟨a, x⟩))) :\n    children (M.mk ⟨a, x⟩) i = x (cast (by rw [head_mk]) i) := by apply ext'; intro n; rfl\n\n"}
{"name":"PFunctor.M.ichildren_mk","module":"Mathlib.Data.PFunctor.Univariate.M","initialProofState":"F : PFunctor.{u}\ninst✝¹ : DecidableEq F.A\ninst✝ : Inhabited F.M\nx : ↑F F.M\ni : F.Idx\n⊢ Eq (PFunctor.M.ichildren i (PFunctor.M.mk x)) (x.iget i)","decl":"@[simp]\ntheorem ichildren_mk [DecidableEq F.A] [Inhabited (M F)] (x : F (M F)) (i : F.Idx) :\n    ichildren i (M.mk x) = x.iget i := by\n  dsimp only [ichildren, PFunctor.Obj.iget]\n  congr with h\n\n"}
{"name":"PFunctor.M.isubtree_cons","module":"Mathlib.Data.PFunctor.Univariate.M","initialProofState":"F : PFunctor.{u}\ninst✝¹ : DecidableEq F.A\ninst✝ : Inhabited F.M\nps : PFunctor.Approx.Path F\na : F.A\nf : F.B a → F.M\ni : F.B a\n⊢ Eq (PFunctor.M.isubtree (List.cons ⟨a, i⟩ ps) (PFunctor.M.mk ⟨a, f⟩)) (PFunctor.M.isubtree ps (f i))","decl":"@[simp]\ntheorem isubtree_cons [DecidableEq F.A] [Inhabited (M F)] (ps : Path F) {a} (f : F.B a → M F)\n    {i : F.B a} : isubtree (⟨_, i⟩ :: ps) (M.mk ⟨a, f⟩) = isubtree ps (f i) := by\n  simp only [isubtree, ichildren_mk, PFunctor.Obj.iget, dif_pos, isubtree, M.casesOn_mk']; rfl\n\n"}
{"name":"PFunctor.M.iselect_nil","module":"Mathlib.Data.PFunctor.Univariate.M","initialProofState":"F : PFunctor.{u}\ninst✝¹ : DecidableEq F.A\ninst✝ : Inhabited F.M\na : F.A\nf : F.B a → F.M\n⊢ Eq (PFunctor.M.iselect List.nil (PFunctor.M.mk ⟨a, f⟩)) a","decl":"@[simp]\ntheorem iselect_nil [DecidableEq F.A] [Inhabited (M F)] {a} (f : F.B a → M F) :\n    iselect nil (M.mk ⟨a, f⟩) = a := rfl\n\n"}
{"name":"PFunctor.M.iselect_cons","module":"Mathlib.Data.PFunctor.Univariate.M","initialProofState":"F : PFunctor.{u}\ninst✝¹ : DecidableEq F.A\ninst✝ : Inhabited F.M\nps : PFunctor.Approx.Path F\na : F.A\nf : F.B a → F.M\ni : F.B a\n⊢ Eq (PFunctor.M.iselect (List.cons ⟨a, i⟩ ps) (PFunctor.M.mk ⟨a, f⟩)) (PFunctor.M.iselect ps (f i))","decl":"@[simp]\ntheorem iselect_cons [DecidableEq F.A] [Inhabited (M F)] (ps : Path F) {a} (f : F.B a → M F) {i} :\n    iselect (⟨a, i⟩ :: ps) (M.mk ⟨a, f⟩) = iselect ps (f i) := by simp only [iselect, isubtree_cons]\n\n"}
{"name":"PFunctor.M.corec_def","module":"Mathlib.Data.PFunctor.Univariate.M","initialProofState":"F : PFunctor.{u}\nX : Type u_2\nf : X → ↑F X\nx₀ : X\n⊢ Eq (PFunctor.M.corec f x₀) (PFunctor.M.mk (F.map (PFunctor.M.corec f) (f x₀)))","decl":"theorem corec_def {X} (f : X → F X) (x₀ : X) : M.corec f x₀ = M.mk (F.map (M.corec f) (f x₀)) := by\n  dsimp only [M.corec, M.mk]\n  congr with n\n  cases' n with n\n  · dsimp only [sCorec, Approx.sMk]\n  · dsimp only [sCorec, Approx.sMk]\n    cases f x₀\n    dsimp only [PFunctor.map]\n    congr\n\n"}
{"name":"PFunctor.M.ext_aux","module":"Mathlib.Data.PFunctor.Univariate.M","initialProofState":"F : PFunctor.{u}\ninst✝¹ : Inhabited F.M\ninst✝ : DecidableEq F.A\nn : Nat\nx y z : F.M\nhx : PFunctor.M.Agree' n z x\nhy : PFunctor.M.Agree' n z y\nhrec : ∀ (ps : PFunctor.Approx.Path F), Eq n (List.length ps) → Eq (PFunctor.M.iselect ps x) (PFunctor.M.iselect ps y)\n⊢ Eq (x.approx (HAdd.hAdd n 1)) (y.approx (HAdd.hAdd n 1))","decl":"theorem ext_aux [Inhabited (M F)] [DecidableEq F.A] {n : ℕ} (x y z : M F) (hx : Agree' n z x)\n    (hy : Agree' n z y) (hrec : ∀ ps : Path F, n = ps.length → iselect ps x = iselect ps y) :\n    x.approx (n + 1) = y.approx (n + 1) := by\n  induction' n with n n_ih generalizing x y z\n  · specialize hrec [] rfl\n    induction x using PFunctor.M.casesOn'\n    induction y using PFunctor.M.casesOn'\n    simp only [iselect_nil] at hrec\n    subst hrec\n    simp only [approx_mk, eq_self_iff_true, heq_iff_eq, zero_eq, CofixA.intro.injEq,\n      heq_eq_eq, eq_iff_true_of_subsingleton, and_self]\n  · cases hx\n    cases hy\n    induction x using PFunctor.M.casesOn'\n    induction y using PFunctor.M.casesOn'\n    subst z\n    iterate 3 (have := mk_inj ‹_›; cases this)\n    rename_i n_ih a f₃ f₂ hAgree₂ _ _ h₂ _ _ f₁ h₁ hAgree₁ clr\n    simp only [approx_mk, eq_self_iff_true, heq_iff_eq]\n\n    have := mk_inj h₁\n    cases this; clear h₁\n    have := mk_inj h₂\n    cases this; clear h₂\n\n    congr\n    ext i\n    apply n_ih\n    · solve_by_elim\n    · solve_by_elim\n    introv h\n    specialize hrec (⟨_, i⟩ :: ps) (congr_arg _ h)\n    simp only [iselect_cons] at hrec\n    exact hrec\n\n"}
{"name":"PFunctor.M.ext","module":"Mathlib.Data.PFunctor.Univariate.M","initialProofState":"F : PFunctor.{u}\ninst✝ : Inhabited F.M\nx y : F.M\nH : ∀ (ps : PFunctor.Approx.Path F), Eq (PFunctor.M.iselect ps x) (PFunctor.M.iselect ps y)\n⊢ Eq x y","decl":"theorem ext [Inhabited (M F)] (x y : M F) (H : ∀ ps : Path F, iselect ps x = iselect ps y) :\n    x = y := by\n  apply ext'; intro i\n  induction' i with i i_ih\n  · cases x.approx 0\n    cases y.approx 0\n    constructor\n  · apply ext_aux x y x\n    · rw [← agree_iff_agree']\n      apply x.consistent\n    · rw [← agree_iff_agree', i_ih]\n      apply y.consistent\n    introv H'\n    dsimp only [iselect] at H\n    cases H'\n    apply H ps\n\n"}
{"name":"PFunctor.M.IsBisimulation.head","module":"Mathlib.Data.PFunctor.Univariate.M","initialProofState":"F : PFunctor.{u}\nR : F.M → F.M → Prop\nself : PFunctor.M.IsBisimulation R\na a' : F.A\nf : F.B a → F.M\nf' : F.B a' → F.M\na✝ : R (PFunctor.M.mk ⟨a, f⟩) (PFunctor.M.mk ⟨a', f'⟩)\n⊢ Eq a a'","decl":"/-- Bisimulation is the standard proof technique for equality between\ninfinite tree-like structures -/\nstructure IsBisimulation : Prop where\n  /-- The head of the trees are equal -/\n  head : ∀ {a a'} {f f'}, M.mk ⟨a, f⟩ ~ M.mk ⟨a', f'⟩ → a = a'\n  /-- The tails are equal -/\n  tail : ∀ {a} {f f' : F.B a → M F}, M.mk ⟨a, f⟩ ~ M.mk ⟨a, f'⟩ → ∀ i : F.B a, f i ~ f' i\n\n"}
{"name":"PFunctor.M.IsBisimulation.tail","module":"Mathlib.Data.PFunctor.Univariate.M","initialProofState":"F : PFunctor.{u}\nR : F.M → F.M → Prop\nself : PFunctor.M.IsBisimulation R\na : F.A\nf f' : F.B a → F.M\na✝ : R (PFunctor.M.mk ⟨a, f⟩) (PFunctor.M.mk ⟨a, f'⟩)\ni : F.B a\n⊢ R (f i) (f' i)","decl":"/-- Bisimulation is the standard proof technique for equality between\ninfinite tree-like structures -/\nstructure IsBisimulation : Prop where\n  /-- The head of the trees are equal -/\n  head : ∀ {a a'} {f f'}, M.mk ⟨a, f⟩ ~ M.mk ⟨a', f'⟩ → a = a'\n  /-- The tails are equal -/\n  tail : ∀ {a} {f f' : F.B a → M F}, M.mk ⟨a, f⟩ ~ M.mk ⟨a, f'⟩ → ∀ i : F.B a, f i ~ f' i\n\n"}
{"name":"PFunctor.M.nth_of_bisim","module":"Mathlib.Data.PFunctor.Univariate.M","initialProofState":"F : PFunctor.{u}\nR : F.M → F.M → Prop\ninst✝ : Inhabited F.M\nbisim : PFunctor.M.IsBisimulation R\ns₁ s₂ : F.M\nps : PFunctor.Approx.Path F\na✝¹ : R s₁ s₂\na✝ : Or (PFunctor.M.IsPath ps s₁) (PFunctor.M.IsPath ps s₂)\n⊢ And (Eq (PFunctor.M.iselect ps s₁) (PFunctor.M.iselect ps s₂)) (Exists fun a => Exists fun f => Exists fun f' => And (Eq (PFunctor.M.isubtree ps s₁) (PFunctor.M.mk ⟨a, f⟩)) (And (Eq (PFunctor.M.isubtree ps s₂) (PFunctor.M.mk ⟨a, f'⟩)) (∀ (i : F.B a), R (f i) (f' i))))","decl":"theorem nth_of_bisim [Inhabited (M F)] (bisim : IsBisimulation R) (s₁ s₂) (ps : Path F) :\n    (R s₁ s₂) →\n      IsPath ps s₁ ∨ IsPath ps s₂ →\n        iselect ps s₁ = iselect ps s₂ ∧\n          ∃ (a : _) (f f' : F.B a → M F),\n            isubtree ps s₁ = M.mk ⟨a, f⟩ ∧\n              isubtree ps s₂ = M.mk ⟨a, f'⟩ ∧ ∀ i : F.B a, f i ~ f' i := by\n  intro h₀ hh\n  induction' s₁ using PFunctor.M.casesOn' with a f\n  induction' s₂ using PFunctor.M.casesOn' with a' f'\n  obtain rfl : a = a' := bisim.head h₀\n  induction' ps with i ps ps_ih generalizing a f f'\n  · exists rfl, a, f, f', rfl, rfl\n    apply bisim.tail h₀\n  cases' i with a' i\n  obtain rfl : a = a' := by rcases hh with hh|hh <;> cases isPath_cons hh <;> rfl\n  dsimp only [iselect] at ps_ih ⊢\n  have h₁ := bisim.tail h₀ i\n  induction' h : f i using PFunctor.M.casesOn' with a₀ f₀\n  induction' h' : f' i using PFunctor.M.casesOn' with a₁ f₁\n  simp only [h, h', isubtree_cons] at ps_ih ⊢\n  rw [h, h'] at h₁\n  obtain rfl : a₀ = a₁ := bisim.head h₁\n  apply ps_ih _ _ _ h₁\n  rw [← h, ← h']\n  apply Or.imp isPath_cons' isPath_cons' hh\n\n"}
{"name":"PFunctor.M.eq_of_bisim","module":"Mathlib.Data.PFunctor.Univariate.M","initialProofState":"F : PFunctor.{u}\nR : F.M → F.M → Prop\ninst✝ : Nonempty F.M\nbisim : PFunctor.M.IsBisimulation R\ns₁ s₂ : F.M\na✝ : R s₁ s₂\n⊢ Eq s₁ s₂","decl":"theorem eq_of_bisim [Nonempty (M F)] (bisim : IsBisimulation R) : ∀ s₁ s₂, R s₁ s₂ → s₁ = s₂ := by\n  inhabit M F\n  introv Hr; apply ext\n  introv\n  by_cases h : IsPath ps s₁ ∨ IsPath ps s₂\n  · have H := nth_of_bisim R bisim _ _ ps Hr h\n    exact H.left\n  · rw [not_or] at h\n    cases' h with h₀ h₁\n    simp only [iselect_eq_default, *, not_false_iff]\n\n"}
{"name":"PFunctor.M.dest_corec","module":"Mathlib.Data.PFunctor.Univariate.M","initialProofState":"P : PFunctor.{u}\nα : Type u_2\ng : α → ↑P α\nx : α\n⊢ Eq (PFunctor.M.corec g x).dest (P.map (PFunctor.M.corec g) (g x))","decl":"theorem dest_corec (g : α → P α) (x : α) : M.dest (M.corec g x) = P.map (M.corec g) (g x) := by\n  rw [corec_def, dest_mk]\n\n"}
{"name":"PFunctor.M.bisim","module":"Mathlib.Data.PFunctor.Univariate.M","initialProofState":"P : PFunctor.{u}\nR : P.M → P.M → Prop\nh : ∀ (x y : P.M), R x y → Exists fun a => Exists fun f => Exists fun f' => And (Eq x.dest ⟨a, f⟩) (And (Eq y.dest ⟨a, f'⟩) (∀ (i : P.B a), R (f i) (f' i)))\nx y : P.M\na✝ : R x y\n⊢ Eq x y","decl":"theorem bisim (R : M P → M P → Prop)\n    (h : ∀ x y, R x y → ∃ a f f', M.dest x = ⟨a, f⟩ ∧ M.dest y = ⟨a, f'⟩ ∧ ∀ i, R (f i) (f' i)) :\n    ∀ x y, R x y → x = y := by\n  introv h'\n  haveI := Inhabited.mk x.head\n  apply eq_of_bisim R _ _ _ h'; clear h' x y\n  constructor <;> introv ih <;> rcases h _ _ ih with ⟨a'', g, g', h₀, h₁, h₂⟩ <;> clear h\n  · replace h₀ := congr_arg Sigma.fst h₀\n    replace h₁ := congr_arg Sigma.fst h₁\n    simp only [dest_mk] at h₀ h₁\n    rw [h₀, h₁]\n  · simp only [dest_mk] at h₀ h₁\n    cases h₀\n    cases h₁\n    apply h₂\n\n"}
{"name":"PFunctor.M.bisim'","module":"Mathlib.Data.PFunctor.Univariate.M","initialProofState":"P : PFunctor.{u}\nα : Type u_3\nQ : α → Prop\nu v : α → P.M\nh : ∀ (x : α), Q x → Exists fun a => Exists fun f => Exists fun f' => And (Eq (u x).dest ⟨a, f⟩) (And (Eq (v x).dest ⟨a, f'⟩) (∀ (i : P.B a), Exists fun x' => And (Q x') (And (Eq (f i) (u x')) (Eq (f' i) (v x')))))\nx : α\na✝ : Q x\n⊢ Eq (u x) (v x)","decl":"theorem bisim' {α : Type*} (Q : α → Prop) (u v : α → M P)\n    (h : ∀ x, Q x → ∃ a f f',\n          M.dest (u x) = ⟨a, f⟩\n          ∧ M.dest (v x) = ⟨a, f'⟩\n          ∧ ∀ i, ∃ x', Q x' ∧ f i = u x' ∧ f' i = v x'\n      ) :\n    ∀ x, Q x → u x = v x := fun x Qx =>\n  let R := fun w z : M P => ∃ x', Q x' ∧ w = u x' ∧ z = v x'\n  @M.bisim P R\n    (fun _ _ ⟨x', Qx', xeq, yeq⟩ =>\n      let ⟨a, f, f', ux'eq, vx'eq, h'⟩ := h x' Qx'\n      ⟨a, f, f', xeq.symm ▸ ux'eq, yeq.symm ▸ vx'eq, h'⟩)\n    _ _ ⟨x, Qx, rfl, rfl⟩\n\n-- for the record, show M_bisim follows from _bisim'\n"}
{"name":"PFunctor.M.bisim_equiv","module":"Mathlib.Data.PFunctor.Univariate.M","initialProofState":"P : PFunctor.{u}\nR : P.M → P.M → Prop\nh : ∀ (x y : P.M), R x y → Exists fun a => Exists fun f => Exists fun f' => And (Eq x.dest ⟨a, f⟩) (And (Eq y.dest ⟨a, f'⟩) (∀ (i : P.B a), R (f i) (f' i)))\nx y : P.M\na✝ : R x y\n⊢ Eq x y","decl":"theorem bisim_equiv (R : M P → M P → Prop)\n    (h : ∀ x y, R x y → ∃ a f f', M.dest x = ⟨a, f⟩ ∧ M.dest y = ⟨a, f'⟩ ∧ ∀ i, R (f i) (f' i)) :\n    ∀ x y, R x y → x = y := fun x y Rxy =>\n  let Q : M P × M P → Prop := fun p => R p.fst p.snd\n  bisim' Q Prod.fst Prod.snd\n    (fun p Qp =>\n      let ⟨a, f, f', hx, hy, h'⟩ := h p.fst p.snd Qp\n      ⟨a, f, f', hx, hy, fun i => ⟨⟨f i, f' i⟩, h' i, rfl, rfl⟩⟩)\n    ⟨x, y⟩ Rxy\n\n"}
{"name":"PFunctor.M.corec_unique","module":"Mathlib.Data.PFunctor.Univariate.M","initialProofState":"P : PFunctor.{u}\nα : Type u_2\ng : α → ↑P α\nf : α → P.M\nhyp : ∀ (x : α), Eq (f x).dest (P.map f (g x))\n⊢ Eq f (PFunctor.M.corec g)","decl":"theorem corec_unique (g : α → P α) (f : α → M P) (hyp : ∀ x, M.dest (f x) = P.map f (g x)) :\n    f = M.corec g := by\n  ext x\n  apply bisim' (fun _ => True) _ _ _ _ trivial\n  clear x\n  intro x _\n  cases' gxeq : g x with a f'\n  have h₀ : M.dest (f x) = ⟨a, f ∘ f'⟩ := by rw [hyp, gxeq, PFunctor.map_eq]\n  have h₁ : M.dest (M.corec g x) = ⟨a, M.corec g ∘ f'⟩ := by rw [dest_corec, gxeq, PFunctor.map_eq]\n  refine ⟨_, _, _, h₀, h₁, ?_⟩\n  intro i\n  exact ⟨f' i, trivial, rfl, rfl⟩\n\n"}
