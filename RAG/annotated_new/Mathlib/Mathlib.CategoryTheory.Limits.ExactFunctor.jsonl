{"name":"CategoryTheory.instFullLeftExactFunctorFunctorForget","module":"Mathlib.CategoryTheory.Limits.ExactFunctor","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\n⊢ (CategoryTheory.LeftExactFunctor.forget C D).Full","decl":"instance : (LeftExactFunctor.forget C D).Full :=\n  FullSubcategory.full _\n\n"}
{"name":"CategoryTheory.instFaithfulLeftExactFunctorFunctorForget","module":"Mathlib.CategoryTheory.Limits.ExactFunctor","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\n⊢ (CategoryTheory.LeftExactFunctor.forget C D).Faithful","decl":"instance : (LeftExactFunctor.forget C D).Faithful :=\n  FullSubcategory.faithful _\n\n"}
{"name":"CategoryTheory.instFullRightExactFunctorFunctorForget","module":"Mathlib.CategoryTheory.Limits.ExactFunctor","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\n⊢ (CategoryTheory.RightExactFunctor.forget C D).Full","decl":"instance : (RightExactFunctor.forget C D).Full :=\n  FullSubcategory.full _\n\n"}
{"name":"CategoryTheory.instFaithfulRightExactFunctorFunctorForget","module":"Mathlib.CategoryTheory.Limits.ExactFunctor","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\n⊢ (CategoryTheory.RightExactFunctor.forget C D).Faithful","decl":"instance : (RightExactFunctor.forget C D).Faithful :=\n  FullSubcategory.faithful _\n\n"}
{"name":"CategoryTheory.instFullExactFunctorFunctorForget","module":"Mathlib.CategoryTheory.Limits.ExactFunctor","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\n⊢ (CategoryTheory.ExactFunctor.forget C D).Full","decl":"instance : (ExactFunctor.forget C D).Full :=\n  FullSubcategory.full _\n\n"}
{"name":"CategoryTheory.instFaithfulExactFunctorFunctorForget","module":"Mathlib.CategoryTheory.Limits.ExactFunctor","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\n⊢ (CategoryTheory.ExactFunctor.forget C D).Faithful","decl":"instance : (ExactFunctor.forget C D).Faithful :=\n  FullSubcategory.faithful _\n\n"}
{"name":"CategoryTheory.instFullExactFunctorLeftExactFunctorOfExact","module":"Mathlib.CategoryTheory.Limits.ExactFunctor","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\n⊢ (CategoryTheory.LeftExactFunctor.ofExact C D).Full","decl":"instance : (LeftExactFunctor.ofExact C D).Full :=\n  FullSubcategory.full_map _\n\n"}
{"name":"CategoryTheory.instFaithfulExactFunctorLeftExactFunctorOfExact","module":"Mathlib.CategoryTheory.Limits.ExactFunctor","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\n⊢ (CategoryTheory.LeftExactFunctor.ofExact C D).Faithful","decl":"instance : (LeftExactFunctor.ofExact C D).Faithful :=\n  FullSubcategory.faithful_map _\n\n"}
{"name":"CategoryTheory.instFullExactFunctorRightExactFunctorOfExact","module":"Mathlib.CategoryTheory.Limits.ExactFunctor","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\n⊢ (CategoryTheory.RightExactFunctor.ofExact C D).Full","decl":"instance : (RightExactFunctor.ofExact C D).Full :=\n  FullSubcategory.full_map _\n\n"}
{"name":"CategoryTheory.instFaithfulExactFunctorRightExactFunctorOfExact","module":"Mathlib.CategoryTheory.Limits.ExactFunctor","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\n⊢ (CategoryTheory.RightExactFunctor.ofExact C D).Faithful","decl":"instance : (RightExactFunctor.ofExact C D).Faithful :=\n  FullSubcategory.faithful_map _\n\n"}
{"name":"CategoryTheory.LeftExactFunctor.ofExact_obj","module":"Mathlib.CategoryTheory.Limits.ExactFunctor","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.ExactFunctor C D\n⊢ Eq ((CategoryTheory.LeftExactFunctor.ofExact C D).obj F) { obj := F.obj, property := ⋯ }","decl":"@[simp]\ntheorem LeftExactFunctor.ofExact_obj (F : C ⥤ₑ D) :\n    (LeftExactFunctor.ofExact C D).obj F = ⟨F.1, F.2.1⟩ :=\n  rfl\n\n"}
{"name":"CategoryTheory.RightExactFunctor.ofExact_obj","module":"Mathlib.CategoryTheory.Limits.ExactFunctor","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.ExactFunctor C D\n⊢ Eq ((CategoryTheory.RightExactFunctor.ofExact C D).obj F) { obj := F.obj, property := ⋯ }","decl":"@[simp]\ntheorem RightExactFunctor.ofExact_obj (F : C ⥤ₑ D) :\n    (RightExactFunctor.ofExact C D).obj F = ⟨F.1, F.2.2⟩ :=\n  rfl\n\n"}
{"name":"CategoryTheory.LeftExactFunctor.ofExact_map","module":"Mathlib.CategoryTheory.Limits.ExactFunctor","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF G : CategoryTheory.ExactFunctor C D\nα : Quiver.Hom F G\n⊢ Eq ((CategoryTheory.LeftExactFunctor.ofExact C D).map α) α","decl":"@[simp]\ntheorem LeftExactFunctor.ofExact_map {F G : C ⥤ₑ D} (α : F ⟶ G) :\n    (LeftExactFunctor.ofExact C D).map α = α :=\n  rfl\n\n"}
{"name":"CategoryTheory.RightExactFunctor.ofExact_map","module":"Mathlib.CategoryTheory.Limits.ExactFunctor","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF G : CategoryTheory.ExactFunctor C D\nα : Quiver.Hom F G\n⊢ Eq ((CategoryTheory.RightExactFunctor.ofExact C D).map α) α","decl":"@[simp]\ntheorem RightExactFunctor.ofExact_map {F G : C ⥤ₑ D} (α : F ⟶ G) :\n    (RightExactFunctor.ofExact C D).map α = α :=\n  rfl\n\n"}
{"name":"CategoryTheory.LeftExactFunctor.forget_obj","module":"Mathlib.CategoryTheory.Limits.ExactFunctor","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.LeftExactFunctor C D\n⊢ Eq ((CategoryTheory.LeftExactFunctor.forget C D).obj F) F.obj","decl":"@[simp]\ntheorem LeftExactFunctor.forget_obj (F : C ⥤ₗ D) : (LeftExactFunctor.forget C D).obj F = F.1 :=\n  rfl\n\n"}
{"name":"CategoryTheory.RightExactFunctor.forget_obj","module":"Mathlib.CategoryTheory.Limits.ExactFunctor","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.RightExactFunctor C D\n⊢ Eq ((CategoryTheory.RightExactFunctor.forget C D).obj F) F.obj","decl":"@[simp]\ntheorem RightExactFunctor.forget_obj (F : C ⥤ᵣ D) : (RightExactFunctor.forget C D).obj F = F.1 :=\n  rfl\n\n"}
{"name":"CategoryTheory.ExactFunctor.forget_obj","module":"Mathlib.CategoryTheory.Limits.ExactFunctor","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.ExactFunctor C D\n⊢ Eq ((CategoryTheory.ExactFunctor.forget C D).obj F) F.obj","decl":"@[simp]\ntheorem ExactFunctor.forget_obj (F : C ⥤ₑ D) : (ExactFunctor.forget C D).obj F = F.1 :=\n  rfl\n\n"}
{"name":"CategoryTheory.LeftExactFunctor.forget_map","module":"Mathlib.CategoryTheory.Limits.ExactFunctor","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF G : CategoryTheory.LeftExactFunctor C D\nα : Quiver.Hom F G\n⊢ Eq ((CategoryTheory.LeftExactFunctor.forget C D).map α) α","decl":"@[simp]\ntheorem LeftExactFunctor.forget_map {F G : C ⥤ₗ D} (α : F ⟶ G) :\n    (LeftExactFunctor.forget C D).map α = α :=\n  rfl\n\n"}
{"name":"CategoryTheory.RightExactFunctor.forget_map","module":"Mathlib.CategoryTheory.Limits.ExactFunctor","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF G : CategoryTheory.RightExactFunctor C D\nα : Quiver.Hom F G\n⊢ Eq ((CategoryTheory.RightExactFunctor.forget C D).map α) α","decl":"@[simp]\ntheorem RightExactFunctor.forget_map {F G : C ⥤ᵣ D} (α : F ⟶ G) :\n    (RightExactFunctor.forget C D).map α = α :=\n  rfl\n\n"}
{"name":"CategoryTheory.ExactFunctor.forget_map","module":"Mathlib.CategoryTheory.Limits.ExactFunctor","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF G : CategoryTheory.ExactFunctor C D\nα : Quiver.Hom F G\n⊢ Eq ((CategoryTheory.ExactFunctor.forget C D).map α) α","decl":"@[simp]\ntheorem ExactFunctor.forget_map {F G : C ⥤ₑ D} (α : F ⟶ G) : (ExactFunctor.forget C D).map α = α :=\n  rfl\n\n"}
{"name":"CategoryTheory.LeftExactFunctor.of_fst","module":"Mathlib.CategoryTheory.Limits.ExactFunctor","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.PreservesFiniteLimits F\n⊢ Eq (CategoryTheory.LeftExactFunctor.of F).obj F","decl":"@[simp]\ntheorem LeftExactFunctor.of_fst (F : C ⥤ D) [PreservesFiniteLimits F] :\n    (LeftExactFunctor.of F).obj = F :=\n  rfl\n\n"}
{"name":"CategoryTheory.RightExactFunctor.of_fst","module":"Mathlib.CategoryTheory.Limits.ExactFunctor","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.PreservesFiniteColimits F\n⊢ Eq (CategoryTheory.RightExactFunctor.of F).obj F","decl":"@[simp]\ntheorem RightExactFunctor.of_fst (F : C ⥤ D) [PreservesFiniteColimits F] :\n    (RightExactFunctor.of F).obj = F :=\n  rfl\n\n"}
{"name":"CategoryTheory.ExactFunctor.of_fst","module":"Mathlib.CategoryTheory.Limits.ExactFunctor","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝¹ : CategoryTheory.Limits.PreservesFiniteLimits F\ninst✝ : CategoryTheory.Limits.PreservesFiniteColimits F\n⊢ Eq (CategoryTheory.ExactFunctor.of F).obj F","decl":"@[simp]\ntheorem ExactFunctor.of_fst (F : C ⥤ D) [PreservesFiniteLimits F] [PreservesFiniteColimits F] :\n    (ExactFunctor.of F).obj = F :=\n  rfl\n\n"}
{"name":"CategoryTheory.LeftExactFunctor.forget_obj_of","module":"Mathlib.CategoryTheory.Limits.ExactFunctor","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.PreservesFiniteLimits F\n⊢ Eq ((CategoryTheory.LeftExactFunctor.forget C D).obj (CategoryTheory.LeftExactFunctor.of F)) F","decl":"theorem LeftExactFunctor.forget_obj_of (F : C ⥤ D) [PreservesFiniteLimits F] :\n    (LeftExactFunctor.forget C D).obj (LeftExactFunctor.of F) = F :=\n  rfl\n\n"}
{"name":"CategoryTheory.RightExactFunctor.forget_obj_of","module":"Mathlib.CategoryTheory.Limits.ExactFunctor","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.PreservesFiniteColimits F\n⊢ Eq ((CategoryTheory.RightExactFunctor.forget C D).obj (CategoryTheory.RightExactFunctor.of F)) F","decl":"theorem RightExactFunctor.forget_obj_of (F : C ⥤ D) [PreservesFiniteColimits F] :\n    (RightExactFunctor.forget C D).obj (RightExactFunctor.of F) = F :=\n  rfl\n\n"}
{"name":"CategoryTheory.ExactFunctor.forget_obj_of","module":"Mathlib.CategoryTheory.Limits.ExactFunctor","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝¹ : CategoryTheory.Limits.PreservesFiniteLimits F\ninst✝ : CategoryTheory.Limits.PreservesFiniteColimits F\n⊢ Eq ((CategoryTheory.ExactFunctor.forget C D).obj (CategoryTheory.ExactFunctor.of F)) F","decl":"theorem ExactFunctor.forget_obj_of (F : C ⥤ D) [PreservesFiniteLimits F]\n    [PreservesFiniteColimits F] : (ExactFunctor.forget C D).obj (ExactFunctor.of F) = F :=\n  rfl\n\n"}
{"name":"CategoryTheory.instPreservesFiniteLimitsObjFunctor","module":"Mathlib.CategoryTheory.Limits.ExactFunctor","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.LeftExactFunctor C D\n⊢ CategoryTheory.Limits.PreservesFiniteLimits F.obj","decl":"noncomputable instance (F : C ⥤ₗ D) : PreservesFiniteLimits F.obj :=\n  F.property\n\n"}
{"name":"CategoryTheory.instPreservesFiniteColimitsObjFunctor","module":"Mathlib.CategoryTheory.Limits.ExactFunctor","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.RightExactFunctor C D\n⊢ CategoryTheory.Limits.PreservesFiniteColimits F.obj","decl":"noncomputable instance (F : C ⥤ᵣ D) : PreservesFiniteColimits F.obj :=\n  F.property\n\n"}
{"name":"CategoryTheory.instPreservesFiniteLimitsObjFunctorAndPreservesFiniteColimits","module":"Mathlib.CategoryTheory.Limits.ExactFunctor","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.ExactFunctor C D\n⊢ CategoryTheory.Limits.PreservesFiniteLimits F.obj","decl":"noncomputable instance (F : C ⥤ₑ D) : PreservesFiniteLimits F.obj :=\n  F.property.1\n\n"}
{"name":"CategoryTheory.instPreservesFiniteColimitsObjFunctorAndPreservesFiniteLimits","module":"Mathlib.CategoryTheory.Limits.ExactFunctor","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.ExactFunctor C D\n⊢ CategoryTheory.Limits.PreservesFiniteColimits F.obj","decl":"noncomputable instance (F : C ⥤ₑ D) : PreservesFiniteColimits F.obj :=\n  F.property.2\n\n"}
{"name":"CategoryTheory.LeftExactFunctor.whiskeringLeft_obj_obj_obj_map","module":"Mathlib.CategoryTheory.Limits.ExactFunctor","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.LeftExactFunctor C D\nX : CategoryTheory.LeftExactFunctor D E\nX✝ Y✝ : C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((((CategoryTheory.LeftExactFunctor.whiskeringLeft C D E).obj F).obj X).obj.map f) (X.obj.map (F.obj.map f))","decl":"/-- Whiskering a left exact functor by a left exact functor yields a left exact functor. -/\n@[simps!]\ndef LeftExactFunctor.whiskeringLeft : (C ⥤ₗ D) ⥤ (D ⥤ₗ E) ⥤ (C ⥤ₗ E) where\n  obj F := FullSubcategory.lift _ (forget _ _ ⋙ (CategoryTheory.whiskeringLeft C D E).obj F.obj)\n    (fun G => by dsimp; exact comp_preservesFiniteLimits _ _)\n  map {F G} η :=\n    { app := fun H => ((CategoryTheory.whiskeringLeft C D E).map η).app H.obj\n      naturality := fun _ _ f => ((CategoryTheory.whiskeringLeft C D E).map η).naturality f }\n  map_id X := by\n    rw [FullSubcategory.id_def]\n    aesop_cat\n  map_comp f g := by\n    rw [FullSubcategory.comp_def]\n    aesop_cat\n\n"}
{"name":"CategoryTheory.LeftExactFunctor.whiskeringLeft_obj_obj_obj_obj","module":"Mathlib.CategoryTheory.Limits.ExactFunctor","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.LeftExactFunctor C D\nX✝ : CategoryTheory.LeftExactFunctor D E\nX : C\n⊢ Eq ((((CategoryTheory.LeftExactFunctor.whiskeringLeft C D E).obj F).obj X✝).obj.obj X) (X✝.obj.obj (F.obj.obj X))","decl":"/-- Whiskering a left exact functor by a left exact functor yields a left exact functor. -/\n@[simps!]\ndef LeftExactFunctor.whiskeringLeft : (C ⥤ₗ D) ⥤ (D ⥤ₗ E) ⥤ (C ⥤ₗ E) where\n  obj F := FullSubcategory.lift _ (forget _ _ ⋙ (CategoryTheory.whiskeringLeft C D E).obj F.obj)\n    (fun G => by dsimp; exact comp_preservesFiniteLimits _ _)\n  map {F G} η :=\n    { app := fun H => ((CategoryTheory.whiskeringLeft C D E).map η).app H.obj\n      naturality := fun _ _ f => ((CategoryTheory.whiskeringLeft C D E).map η).naturality f }\n  map_id X := by\n    rw [FullSubcategory.id_def]\n    aesop_cat\n  map_comp f g := by\n    rw [FullSubcategory.comp_def]\n    aesop_cat\n\n"}
{"name":"CategoryTheory.LeftExactFunctor.whiskeringLeft_map_app_app","module":"Mathlib.CategoryTheory.Limits.ExactFunctor","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF G : CategoryTheory.LeftExactFunctor C D\nη : Quiver.Hom F G\nH : CategoryTheory.LeftExactFunctor D E\nc : C\n⊢ Eq ((((CategoryTheory.LeftExactFunctor.whiskeringLeft C D E).map η).app H).app c) (H.obj.map (η.app c))","decl":"/-- Whiskering a left exact functor by a left exact functor yields a left exact functor. -/\n@[simps!]\ndef LeftExactFunctor.whiskeringLeft : (C ⥤ₗ D) ⥤ (D ⥤ₗ E) ⥤ (C ⥤ₗ E) where\n  obj F := FullSubcategory.lift _ (forget _ _ ⋙ (CategoryTheory.whiskeringLeft C D E).obj F.obj)\n    (fun G => by dsimp; exact comp_preservesFiniteLimits _ _)\n  map {F G} η :=\n    { app := fun H => ((CategoryTheory.whiskeringLeft C D E).map η).app H.obj\n      naturality := fun _ _ f => ((CategoryTheory.whiskeringLeft C D E).map η).naturality f }\n  map_id X := by\n    rw [FullSubcategory.id_def]\n    aesop_cat\n  map_comp f g := by\n    rw [FullSubcategory.comp_def]\n    aesop_cat\n\n"}
{"name":"CategoryTheory.LeftExactFunctor.whiskeringLeft_obj_map_app","module":"Mathlib.CategoryTheory.Limits.ExactFunctor","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.LeftExactFunctor C D\nX✝ Y✝ : CategoryTheory.LeftExactFunctor D E\nf : Quiver.Hom X✝ Y✝\nX : C\n⊢ Eq ((((CategoryTheory.LeftExactFunctor.whiskeringLeft C D E).obj F).map f).app X) (f.app (F.obj.obj X))","decl":"/-- Whiskering a left exact functor by a left exact functor yields a left exact functor. -/\n@[simps!]\ndef LeftExactFunctor.whiskeringLeft : (C ⥤ₗ D) ⥤ (D ⥤ₗ E) ⥤ (C ⥤ₗ E) where\n  obj F := FullSubcategory.lift _ (forget _ _ ⋙ (CategoryTheory.whiskeringLeft C D E).obj F.obj)\n    (fun G => by dsimp; exact comp_preservesFiniteLimits _ _)\n  map {F G} η :=\n    { app := fun H => ((CategoryTheory.whiskeringLeft C D E).map η).app H.obj\n      naturality := fun _ _ f => ((CategoryTheory.whiskeringLeft C D E).map η).naturality f }\n  map_id X := by\n    rw [FullSubcategory.id_def]\n    aesop_cat\n  map_comp f g := by\n    rw [FullSubcategory.comp_def]\n    aesop_cat\n\n"}
{"name":"CategoryTheory.LeftExactFunctor.whiskeringRight_obj_obj_obj_map","module":"Mathlib.CategoryTheory.Limits.ExactFunctor","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.LeftExactFunctor D E\nX : CategoryTheory.LeftExactFunctor C D\nX✝ Y✝ : C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((((CategoryTheory.LeftExactFunctor.whiskeringRight C D E).obj F).obj X).obj.map f) (F.obj.map (X.obj.map f))","decl":"/-- Whiskering a left exact functor by a left exact functor yields a left exact functor. -/\n@[simps!]\ndef LeftExactFunctor.whiskeringRight : (D ⥤ₗ E) ⥤ (C ⥤ₗ D) ⥤ (C ⥤ₗ E) where\n  obj F := FullSubcategory.lift _ (forget _ _ ⋙ (CategoryTheory.whiskeringRight C D E).obj F.obj)\n    (fun G => by dsimp; exact comp_preservesFiniteLimits _ _)\n  map {F G} η :=\n    { app := fun H => ((CategoryTheory.whiskeringRight C D E).map η).app H.obj\n      naturality := fun _ _ f => ((CategoryTheory.whiskeringRight C D E).map η).naturality f }\n  map_id X := by\n    rw [FullSubcategory.id_def]\n    aesop_cat\n  map_comp f g := by\n    rw [FullSubcategory.comp_def]\n    aesop_cat\n\n"}
{"name":"CategoryTheory.LeftExactFunctor.whiskeringRight_map_app_app","module":"Mathlib.CategoryTheory.Limits.ExactFunctor","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF G : CategoryTheory.LeftExactFunctor D E\nη : Quiver.Hom F G\nH : CategoryTheory.LeftExactFunctor C D\nc : C\n⊢ Eq ((((CategoryTheory.LeftExactFunctor.whiskeringRight C D E).map η).app H).app c) (η.app (H.obj.obj c))","decl":"/-- Whiskering a left exact functor by a left exact functor yields a left exact functor. -/\n@[simps!]\ndef LeftExactFunctor.whiskeringRight : (D ⥤ₗ E) ⥤ (C ⥤ₗ D) ⥤ (C ⥤ₗ E) where\n  obj F := FullSubcategory.lift _ (forget _ _ ⋙ (CategoryTheory.whiskeringRight C D E).obj F.obj)\n    (fun G => by dsimp; exact comp_preservesFiniteLimits _ _)\n  map {F G} η :=\n    { app := fun H => ((CategoryTheory.whiskeringRight C D E).map η).app H.obj\n      naturality := fun _ _ f => ((CategoryTheory.whiskeringRight C D E).map η).naturality f }\n  map_id X := by\n    rw [FullSubcategory.id_def]\n    aesop_cat\n  map_comp f g := by\n    rw [FullSubcategory.comp_def]\n    aesop_cat\n\n"}
{"name":"CategoryTheory.LeftExactFunctor.whiskeringRight_obj_map_app","module":"Mathlib.CategoryTheory.Limits.ExactFunctor","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.LeftExactFunctor D E\nX✝ Y✝ : CategoryTheory.LeftExactFunctor C D\nf : Quiver.Hom X✝ Y✝\nX : C\n⊢ Eq ((((CategoryTheory.LeftExactFunctor.whiskeringRight C D E).obj F).map f).app X) (F.obj.map (f.app X))","decl":"/-- Whiskering a left exact functor by a left exact functor yields a left exact functor. -/\n@[simps!]\ndef LeftExactFunctor.whiskeringRight : (D ⥤ₗ E) ⥤ (C ⥤ₗ D) ⥤ (C ⥤ₗ E) where\n  obj F := FullSubcategory.lift _ (forget _ _ ⋙ (CategoryTheory.whiskeringRight C D E).obj F.obj)\n    (fun G => by dsimp; exact comp_preservesFiniteLimits _ _)\n  map {F G} η :=\n    { app := fun H => ((CategoryTheory.whiskeringRight C D E).map η).app H.obj\n      naturality := fun _ _ f => ((CategoryTheory.whiskeringRight C D E).map η).naturality f }\n  map_id X := by\n    rw [FullSubcategory.id_def]\n    aesop_cat\n  map_comp f g := by\n    rw [FullSubcategory.comp_def]\n    aesop_cat\n\n"}
{"name":"CategoryTheory.LeftExactFunctor.whiskeringRight_obj_obj_obj_obj","module":"Mathlib.CategoryTheory.Limits.ExactFunctor","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.LeftExactFunctor D E\nX✝ : CategoryTheory.LeftExactFunctor C D\nX : C\n⊢ Eq ((((CategoryTheory.LeftExactFunctor.whiskeringRight C D E).obj F).obj X✝).obj.obj X) (F.obj.obj (X✝.obj.obj X))","decl":"/-- Whiskering a left exact functor by a left exact functor yields a left exact functor. -/\n@[simps!]\ndef LeftExactFunctor.whiskeringRight : (D ⥤ₗ E) ⥤ (C ⥤ₗ D) ⥤ (C ⥤ₗ E) where\n  obj F := FullSubcategory.lift _ (forget _ _ ⋙ (CategoryTheory.whiskeringRight C D E).obj F.obj)\n    (fun G => by dsimp; exact comp_preservesFiniteLimits _ _)\n  map {F G} η :=\n    { app := fun H => ((CategoryTheory.whiskeringRight C D E).map η).app H.obj\n      naturality := fun _ _ f => ((CategoryTheory.whiskeringRight C D E).map η).naturality f }\n  map_id X := by\n    rw [FullSubcategory.id_def]\n    aesop_cat\n  map_comp f g := by\n    rw [FullSubcategory.comp_def]\n    aesop_cat\n\n"}
{"name":"CategoryTheory.RightExactFunctor.whiskeringLeft_map_app_app","module":"Mathlib.CategoryTheory.Limits.ExactFunctor","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF G : CategoryTheory.RightExactFunctor C D\nη : Quiver.Hom F G\nH : CategoryTheory.RightExactFunctor D E\nc : C\n⊢ Eq ((((CategoryTheory.RightExactFunctor.whiskeringLeft C D E).map η).app H).app c) (H.obj.map (η.app c))","decl":"/-- Whiskering a right exact functor by a right exact functor yields a right exact functor. -/\n@[simps!]\ndef RightExactFunctor.whiskeringLeft : (C ⥤ᵣ D) ⥤ (D ⥤ᵣ E) ⥤ (C ⥤ᵣ E) where\n  obj F := FullSubcategory.lift _ (forget _ _ ⋙ (CategoryTheory.whiskeringLeft C D E).obj F.obj)\n    (fun G => by dsimp; exact comp_preservesFiniteColimits _ _)\n  map {F G} η :=\n    { app := fun H => ((CategoryTheory.whiskeringLeft C D E).map η).app H.obj\n      naturality := fun _ _ f => ((CategoryTheory.whiskeringLeft C D E).map η).naturality f }\n  map_id X := by\n    rw [FullSubcategory.id_def]\n    aesop_cat\n  map_comp f g := by\n    rw [FullSubcategory.comp_def]\n    aesop_cat\n\n"}
{"name":"CategoryTheory.RightExactFunctor.whiskeringLeft_obj_obj_obj_obj","module":"Mathlib.CategoryTheory.Limits.ExactFunctor","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.RightExactFunctor C D\nX✝ : CategoryTheory.RightExactFunctor D E\nX : C\n⊢ Eq ((((CategoryTheory.RightExactFunctor.whiskeringLeft C D E).obj F).obj X✝).obj.obj X) (X✝.obj.obj (F.obj.obj X))","decl":"/-- Whiskering a right exact functor by a right exact functor yields a right exact functor. -/\n@[simps!]\ndef RightExactFunctor.whiskeringLeft : (C ⥤ᵣ D) ⥤ (D ⥤ᵣ E) ⥤ (C ⥤ᵣ E) where\n  obj F := FullSubcategory.lift _ (forget _ _ ⋙ (CategoryTheory.whiskeringLeft C D E).obj F.obj)\n    (fun G => by dsimp; exact comp_preservesFiniteColimits _ _)\n  map {F G} η :=\n    { app := fun H => ((CategoryTheory.whiskeringLeft C D E).map η).app H.obj\n      naturality := fun _ _ f => ((CategoryTheory.whiskeringLeft C D E).map η).naturality f }\n  map_id X := by\n    rw [FullSubcategory.id_def]\n    aesop_cat\n  map_comp f g := by\n    rw [FullSubcategory.comp_def]\n    aesop_cat\n\n"}
{"name":"CategoryTheory.RightExactFunctor.whiskeringLeft_obj_map_app","module":"Mathlib.CategoryTheory.Limits.ExactFunctor","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.RightExactFunctor C D\nX✝ Y✝ : CategoryTheory.RightExactFunctor D E\nf : Quiver.Hom X✝ Y✝\nX : C\n⊢ Eq ((((CategoryTheory.RightExactFunctor.whiskeringLeft C D E).obj F).map f).app X) (f.app (F.obj.obj X))","decl":"/-- Whiskering a right exact functor by a right exact functor yields a right exact functor. -/\n@[simps!]\ndef RightExactFunctor.whiskeringLeft : (C ⥤ᵣ D) ⥤ (D ⥤ᵣ E) ⥤ (C ⥤ᵣ E) where\n  obj F := FullSubcategory.lift _ (forget _ _ ⋙ (CategoryTheory.whiskeringLeft C D E).obj F.obj)\n    (fun G => by dsimp; exact comp_preservesFiniteColimits _ _)\n  map {F G} η :=\n    { app := fun H => ((CategoryTheory.whiskeringLeft C D E).map η).app H.obj\n      naturality := fun _ _ f => ((CategoryTheory.whiskeringLeft C D E).map η).naturality f }\n  map_id X := by\n    rw [FullSubcategory.id_def]\n    aesop_cat\n  map_comp f g := by\n    rw [FullSubcategory.comp_def]\n    aesop_cat\n\n"}
{"name":"CategoryTheory.RightExactFunctor.whiskeringLeft_obj_obj_obj_map","module":"Mathlib.CategoryTheory.Limits.ExactFunctor","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.RightExactFunctor C D\nX : CategoryTheory.RightExactFunctor D E\nX✝ Y✝ : C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((((CategoryTheory.RightExactFunctor.whiskeringLeft C D E).obj F).obj X).obj.map f) (X.obj.map (F.obj.map f))","decl":"/-- Whiskering a right exact functor by a right exact functor yields a right exact functor. -/\n@[simps!]\ndef RightExactFunctor.whiskeringLeft : (C ⥤ᵣ D) ⥤ (D ⥤ᵣ E) ⥤ (C ⥤ᵣ E) where\n  obj F := FullSubcategory.lift _ (forget _ _ ⋙ (CategoryTheory.whiskeringLeft C D E).obj F.obj)\n    (fun G => by dsimp; exact comp_preservesFiniteColimits _ _)\n  map {F G} η :=\n    { app := fun H => ((CategoryTheory.whiskeringLeft C D E).map η).app H.obj\n      naturality := fun _ _ f => ((CategoryTheory.whiskeringLeft C D E).map η).naturality f }\n  map_id X := by\n    rw [FullSubcategory.id_def]\n    aesop_cat\n  map_comp f g := by\n    rw [FullSubcategory.comp_def]\n    aesop_cat\n\n"}
{"name":"CategoryTheory.RightExactFunctor.whiskeringRight_obj_obj_obj_obj","module":"Mathlib.CategoryTheory.Limits.ExactFunctor","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.RightExactFunctor D E\nX✝ : CategoryTheory.RightExactFunctor C D\nX : C\n⊢ Eq ((((CategoryTheory.RightExactFunctor.whiskeringRight C D E).obj F).obj X✝).obj.obj X) (F.obj.obj (X✝.obj.obj X))","decl":"/-- Whiskering a right exact functor by a right exact functor yields a right exact functor. -/\n@[simps!]\ndef RightExactFunctor.whiskeringRight : (D ⥤ᵣ E) ⥤ (C ⥤ᵣ D) ⥤ (C ⥤ᵣ E) where\n  obj F := FullSubcategory.lift _ (forget _ _ ⋙ (CategoryTheory.whiskeringRight C D E).obj F.obj)\n    (fun G => by dsimp; exact comp_preservesFiniteColimits _ _)\n  map {F G} η :=\n    { app := fun H => ((CategoryTheory.whiskeringRight C D E).map η).app H.obj\n      naturality := fun _ _ f => ((CategoryTheory.whiskeringRight C D E).map η).naturality f }\n  map_id X := by\n    rw [FullSubcategory.id_def]\n    aesop_cat\n  map_comp f g := by\n    rw [FullSubcategory.comp_def]\n    aesop_cat\n\n"}
{"name":"CategoryTheory.RightExactFunctor.whiskeringRight_obj_map_app","module":"Mathlib.CategoryTheory.Limits.ExactFunctor","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.RightExactFunctor D E\nX✝ Y✝ : CategoryTheory.RightExactFunctor C D\nf : Quiver.Hom X✝ Y✝\nX : C\n⊢ Eq ((((CategoryTheory.RightExactFunctor.whiskeringRight C D E).obj F).map f).app X) (F.obj.map (f.app X))","decl":"/-- Whiskering a right exact functor by a right exact functor yields a right exact functor. -/\n@[simps!]\ndef RightExactFunctor.whiskeringRight : (D ⥤ᵣ E) ⥤ (C ⥤ᵣ D) ⥤ (C ⥤ᵣ E) where\n  obj F := FullSubcategory.lift _ (forget _ _ ⋙ (CategoryTheory.whiskeringRight C D E).obj F.obj)\n    (fun G => by dsimp; exact comp_preservesFiniteColimits _ _)\n  map {F G} η :=\n    { app := fun H => ((CategoryTheory.whiskeringRight C D E).map η).app H.obj\n      naturality := fun _ _ f => ((CategoryTheory.whiskeringRight C D E).map η).naturality f }\n  map_id X := by\n    rw [FullSubcategory.id_def]\n    aesop_cat\n  map_comp f g := by\n    rw [FullSubcategory.comp_def]\n    aesop_cat\n\n"}
{"name":"CategoryTheory.RightExactFunctor.whiskeringRight_map_app_app","module":"Mathlib.CategoryTheory.Limits.ExactFunctor","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF G : CategoryTheory.RightExactFunctor D E\nη : Quiver.Hom F G\nH : CategoryTheory.RightExactFunctor C D\nc : C\n⊢ Eq ((((CategoryTheory.RightExactFunctor.whiskeringRight C D E).map η).app H).app c) (η.app (H.obj.obj c))","decl":"/-- Whiskering a right exact functor by a right exact functor yields a right exact functor. -/\n@[simps!]\ndef RightExactFunctor.whiskeringRight : (D ⥤ᵣ E) ⥤ (C ⥤ᵣ D) ⥤ (C ⥤ᵣ E) where\n  obj F := FullSubcategory.lift _ (forget _ _ ⋙ (CategoryTheory.whiskeringRight C D E).obj F.obj)\n    (fun G => by dsimp; exact comp_preservesFiniteColimits _ _)\n  map {F G} η :=\n    { app := fun H => ((CategoryTheory.whiskeringRight C D E).map η).app H.obj\n      naturality := fun _ _ f => ((CategoryTheory.whiskeringRight C D E).map η).naturality f }\n  map_id X := by\n    rw [FullSubcategory.id_def]\n    aesop_cat\n  map_comp f g := by\n    rw [FullSubcategory.comp_def]\n    aesop_cat\n\n"}
{"name":"CategoryTheory.RightExactFunctor.whiskeringRight_obj_obj_obj_map","module":"Mathlib.CategoryTheory.Limits.ExactFunctor","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.RightExactFunctor D E\nX : CategoryTheory.RightExactFunctor C D\nX✝ Y✝ : C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((((CategoryTheory.RightExactFunctor.whiskeringRight C D E).obj F).obj X).obj.map f) (F.obj.map (X.obj.map f))","decl":"/-- Whiskering a right exact functor by a right exact functor yields a right exact functor. -/\n@[simps!]\ndef RightExactFunctor.whiskeringRight : (D ⥤ᵣ E) ⥤ (C ⥤ᵣ D) ⥤ (C ⥤ᵣ E) where\n  obj F := FullSubcategory.lift _ (forget _ _ ⋙ (CategoryTheory.whiskeringRight C D E).obj F.obj)\n    (fun G => by dsimp; exact comp_preservesFiniteColimits _ _)\n  map {F G} η :=\n    { app := fun H => ((CategoryTheory.whiskeringRight C D E).map η).app H.obj\n      naturality := fun _ _ f => ((CategoryTheory.whiskeringRight C D E).map η).naturality f }\n  map_id X := by\n    rw [FullSubcategory.id_def]\n    aesop_cat\n  map_comp f g := by\n    rw [FullSubcategory.comp_def]\n    aesop_cat\n\n"}
{"name":"CategoryTheory.ExactFunctor.whiskeringLeft_obj_obj_obj_map","module":"Mathlib.CategoryTheory.Limits.ExactFunctor","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.ExactFunctor C D\nX : CategoryTheory.ExactFunctor D E\nX✝ Y✝ : C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((((CategoryTheory.ExactFunctor.whiskeringLeft C D E).obj F).obj X).obj.map f) (X.obj.map (F.obj.map f))","decl":"/-- Whiskering an exact functor by an exact functor yields an exact functor. -/\n@[simps!]\ndef ExactFunctor.whiskeringLeft : (C ⥤ₑ D) ⥤ (D ⥤ₑ E) ⥤ (C ⥤ₑ E) where\n  obj F := FullSubcategory.lift _ (forget _ _ ⋙ (CategoryTheory.whiskeringLeft C D E).obj F.obj)\n    (fun G => ⟨by dsimp; exact comp_preservesFiniteLimits _ _,\n      by dsimp; exact comp_preservesFiniteColimits _ _⟩)\n  map {F G} η :=\n    { app := fun H => ((CategoryTheory.whiskeringLeft C D E).map η).app H.obj\n      naturality := fun _ _ f => ((CategoryTheory.whiskeringLeft C D E).map η).naturality f }\n  map_id X := by\n    rw [FullSubcategory.id_def]\n    aesop_cat\n  map_comp f g := by\n    rw [FullSubcategory.comp_def]\n    aesop_cat\n\n"}
{"name":"CategoryTheory.ExactFunctor.whiskeringLeft_obj_map_app","module":"Mathlib.CategoryTheory.Limits.ExactFunctor","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.ExactFunctor C D\nX✝ Y✝ : CategoryTheory.ExactFunctor D E\nf : Quiver.Hom X✝ Y✝\nX : C\n⊢ Eq ((((CategoryTheory.ExactFunctor.whiskeringLeft C D E).obj F).map f).app X) (f.app (F.obj.obj X))","decl":"/-- Whiskering an exact functor by an exact functor yields an exact functor. -/\n@[simps!]\ndef ExactFunctor.whiskeringLeft : (C ⥤ₑ D) ⥤ (D ⥤ₑ E) ⥤ (C ⥤ₑ E) where\n  obj F := FullSubcategory.lift _ (forget _ _ ⋙ (CategoryTheory.whiskeringLeft C D E).obj F.obj)\n    (fun G => ⟨by dsimp; exact comp_preservesFiniteLimits _ _,\n      by dsimp; exact comp_preservesFiniteColimits _ _⟩)\n  map {F G} η :=\n    { app := fun H => ((CategoryTheory.whiskeringLeft C D E).map η).app H.obj\n      naturality := fun _ _ f => ((CategoryTheory.whiskeringLeft C D E).map η).naturality f }\n  map_id X := by\n    rw [FullSubcategory.id_def]\n    aesop_cat\n  map_comp f g := by\n    rw [FullSubcategory.comp_def]\n    aesop_cat\n\n"}
{"name":"CategoryTheory.ExactFunctor.whiskeringLeft_obj_obj_obj_obj","module":"Mathlib.CategoryTheory.Limits.ExactFunctor","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.ExactFunctor C D\nX✝ : CategoryTheory.ExactFunctor D E\nX : C\n⊢ Eq ((((CategoryTheory.ExactFunctor.whiskeringLeft C D E).obj F).obj X✝).obj.obj X) (X✝.obj.obj (F.obj.obj X))","decl":"/-- Whiskering an exact functor by an exact functor yields an exact functor. -/\n@[simps!]\ndef ExactFunctor.whiskeringLeft : (C ⥤ₑ D) ⥤ (D ⥤ₑ E) ⥤ (C ⥤ₑ E) where\n  obj F := FullSubcategory.lift _ (forget _ _ ⋙ (CategoryTheory.whiskeringLeft C D E).obj F.obj)\n    (fun G => ⟨by dsimp; exact comp_preservesFiniteLimits _ _,\n      by dsimp; exact comp_preservesFiniteColimits _ _⟩)\n  map {F G} η :=\n    { app := fun H => ((CategoryTheory.whiskeringLeft C D E).map η).app H.obj\n      naturality := fun _ _ f => ((CategoryTheory.whiskeringLeft C D E).map η).naturality f }\n  map_id X := by\n    rw [FullSubcategory.id_def]\n    aesop_cat\n  map_comp f g := by\n    rw [FullSubcategory.comp_def]\n    aesop_cat\n\n"}
{"name":"CategoryTheory.ExactFunctor.whiskeringLeft_map_app_app","module":"Mathlib.CategoryTheory.Limits.ExactFunctor","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF G : CategoryTheory.ExactFunctor C D\nη : Quiver.Hom F G\nH : CategoryTheory.ExactFunctor D E\nc : C\n⊢ Eq ((((CategoryTheory.ExactFunctor.whiskeringLeft C D E).map η).app H).app c) (H.obj.map (η.app c))","decl":"/-- Whiskering an exact functor by an exact functor yields an exact functor. -/\n@[simps!]\ndef ExactFunctor.whiskeringLeft : (C ⥤ₑ D) ⥤ (D ⥤ₑ E) ⥤ (C ⥤ₑ E) where\n  obj F := FullSubcategory.lift _ (forget _ _ ⋙ (CategoryTheory.whiskeringLeft C D E).obj F.obj)\n    (fun G => ⟨by dsimp; exact comp_preservesFiniteLimits _ _,\n      by dsimp; exact comp_preservesFiniteColimits _ _⟩)\n  map {F G} η :=\n    { app := fun H => ((CategoryTheory.whiskeringLeft C D E).map η).app H.obj\n      naturality := fun _ _ f => ((CategoryTheory.whiskeringLeft C D E).map η).naturality f }\n  map_id X := by\n    rw [FullSubcategory.id_def]\n    aesop_cat\n  map_comp f g := by\n    rw [FullSubcategory.comp_def]\n    aesop_cat\n\n"}
{"name":"CategoryTheory.ExactFunctor.whiskeringRight_obj_obj_obj_obj","module":"Mathlib.CategoryTheory.Limits.ExactFunctor","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.ExactFunctor D E\nX✝ : CategoryTheory.ExactFunctor C D\nX : C\n⊢ Eq ((((CategoryTheory.ExactFunctor.whiskeringRight C D E).obj F).obj X✝).obj.obj X) (F.obj.obj (X✝.obj.obj X))","decl":"/-- Whiskering an exact functor by an exact functor yields an exact functor. -/\n@[simps!]\ndef ExactFunctor.whiskeringRight : (D ⥤ₑ E) ⥤ (C ⥤ₑ D) ⥤ (C ⥤ₑ E) where\n  obj F := FullSubcategory.lift _ (forget _ _ ⋙ (CategoryTheory.whiskeringRight C D E).obj F.obj)\n    (fun G => ⟨by dsimp; exact comp_preservesFiniteLimits _ _,\n      by dsimp; exact comp_preservesFiniteColimits _ _⟩)\n  map {F G} η :=\n    { app := fun H => ((CategoryTheory.whiskeringRight C D E).map η).app H.obj\n      naturality := fun _ _ f => ((CategoryTheory.whiskeringRight C D E).map η).naturality f }\n  map_id X := by\n    rw [FullSubcategory.id_def]\n    aesop_cat\n  map_comp f g := by\n    rw [FullSubcategory.comp_def]\n    aesop_cat\n\n"}
{"name":"CategoryTheory.ExactFunctor.whiskeringRight_map_app_app","module":"Mathlib.CategoryTheory.Limits.ExactFunctor","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF G : CategoryTheory.ExactFunctor D E\nη : Quiver.Hom F G\nH : CategoryTheory.ExactFunctor C D\nc : C\n⊢ Eq ((((CategoryTheory.ExactFunctor.whiskeringRight C D E).map η).app H).app c) (η.app (H.obj.obj c))","decl":"/-- Whiskering an exact functor by an exact functor yields an exact functor. -/\n@[simps!]\ndef ExactFunctor.whiskeringRight : (D ⥤ₑ E) ⥤ (C ⥤ₑ D) ⥤ (C ⥤ₑ E) where\n  obj F := FullSubcategory.lift _ (forget _ _ ⋙ (CategoryTheory.whiskeringRight C D E).obj F.obj)\n    (fun G => ⟨by dsimp; exact comp_preservesFiniteLimits _ _,\n      by dsimp; exact comp_preservesFiniteColimits _ _⟩)\n  map {F G} η :=\n    { app := fun H => ((CategoryTheory.whiskeringRight C D E).map η).app H.obj\n      naturality := fun _ _ f => ((CategoryTheory.whiskeringRight C D E).map η).naturality f }\n  map_id X := by\n    rw [FullSubcategory.id_def]\n    aesop_cat\n  map_comp f g := by\n    rw [FullSubcategory.comp_def]\n    aesop_cat\n\n"}
{"name":"CategoryTheory.ExactFunctor.whiskeringRight_obj_map_app","module":"Mathlib.CategoryTheory.Limits.ExactFunctor","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.ExactFunctor D E\nX✝ Y✝ : CategoryTheory.ExactFunctor C D\nf : Quiver.Hom X✝ Y✝\nX : C\n⊢ Eq ((((CategoryTheory.ExactFunctor.whiskeringRight C D E).obj F).map f).app X) (F.obj.map (f.app X))","decl":"/-- Whiskering an exact functor by an exact functor yields an exact functor. -/\n@[simps!]\ndef ExactFunctor.whiskeringRight : (D ⥤ₑ E) ⥤ (C ⥤ₑ D) ⥤ (C ⥤ₑ E) where\n  obj F := FullSubcategory.lift _ (forget _ _ ⋙ (CategoryTheory.whiskeringRight C D E).obj F.obj)\n    (fun G => ⟨by dsimp; exact comp_preservesFiniteLimits _ _,\n      by dsimp; exact comp_preservesFiniteColimits _ _⟩)\n  map {F G} η :=\n    { app := fun H => ((CategoryTheory.whiskeringRight C D E).map η).app H.obj\n      naturality := fun _ _ f => ((CategoryTheory.whiskeringRight C D E).map η).naturality f }\n  map_id X := by\n    rw [FullSubcategory.id_def]\n    aesop_cat\n  map_comp f g := by\n    rw [FullSubcategory.comp_def]\n    aesop_cat\n\n"}
{"name":"CategoryTheory.ExactFunctor.whiskeringRight_obj_obj_obj_map","module":"Mathlib.CategoryTheory.Limits.ExactFunctor","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.ExactFunctor D E\nX : CategoryTheory.ExactFunctor C D\nX✝ Y✝ : C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((((CategoryTheory.ExactFunctor.whiskeringRight C D E).obj F).obj X).obj.map f) (F.obj.map (X.obj.map f))","decl":"/-- Whiskering an exact functor by an exact functor yields an exact functor. -/\n@[simps!]\ndef ExactFunctor.whiskeringRight : (D ⥤ₑ E) ⥤ (C ⥤ₑ D) ⥤ (C ⥤ₑ E) where\n  obj F := FullSubcategory.lift _ (forget _ _ ⋙ (CategoryTheory.whiskeringRight C D E).obj F.obj)\n    (fun G => ⟨by dsimp; exact comp_preservesFiniteLimits _ _,\n      by dsimp; exact comp_preservesFiniteColimits _ _⟩)\n  map {F G} η :=\n    { app := fun H => ((CategoryTheory.whiskeringRight C D E).map η).app H.obj\n      naturality := fun _ _ f => ((CategoryTheory.whiskeringRight C D E).map η).naturality f }\n  map_id X := by\n    rw [FullSubcategory.id_def]\n    aesop_cat\n  map_comp f g := by\n    rw [FullSubcategory.comp_def]\n    aesop_cat\n\n"}
