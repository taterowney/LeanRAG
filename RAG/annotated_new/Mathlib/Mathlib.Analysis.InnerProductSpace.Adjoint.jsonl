{"name":"ContinuousLinearMap.adjointAux_apply","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁵ : RCLike 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedAddCommGroup F\ninst✝² : InnerProductSpace 𝕜 E\ninst✝¹ : InnerProductSpace 𝕜 F\ninst✝ : CompleteSpace E\nA : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : F\n⊢ Eq ((ContinuousLinearMap.adjointAux A) x) ((InnerProductSpace.toDual 𝕜 E).symm ((ContinuousLinearMap.toSesqForm A) x))","decl":"@[simp]\ntheorem adjointAux_apply (A : E →L[𝕜] F) (x : F) :\n    adjointAux A x = ((toDual 𝕜 E).symm : NormedSpace.Dual 𝕜 E → E) ((toSesqForm A) x) :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.adjointAux_inner_left","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁵ : RCLike 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedAddCommGroup F\ninst✝² : InnerProductSpace 𝕜 E\ninst✝¹ : InnerProductSpace 𝕜 F\ninst✝ : CompleteSpace E\nA : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\ny : F\n⊢ Eq (Inner.inner ((ContinuousLinearMap.adjointAux A) y) x) (Inner.inner y (A x))","decl":"theorem adjointAux_inner_left (A : E →L[𝕜] F) (x : E) (y : F) : ⟪adjointAux A y, x⟫ = ⟪y, A x⟫ := by\n  rw [adjointAux_apply, toDual_symm_apply, toSesqForm_apply_coe, coe_comp', innerSL_apply_coe,\n    Function.comp_apply]\n\n"}
{"name":"ContinuousLinearMap.adjointAux_inner_right","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁵ : RCLike 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedAddCommGroup F\ninst✝² : InnerProductSpace 𝕜 E\ninst✝¹ : InnerProductSpace 𝕜 F\ninst✝ : CompleteSpace E\nA : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\ny : F\n⊢ Eq (Inner.inner x ((ContinuousLinearMap.adjointAux A) y)) (Inner.inner (A x) y)","decl":"theorem adjointAux_inner_right (A : E →L[𝕜] F) (x : E) (y : F) :\n    ⟪x, adjointAux A y⟫ = ⟪A x, y⟫ := by\n  rw [← inner_conj_symm, adjointAux_inner_left, inner_conj_symm]\n\n"}
{"name":"ContinuousLinearMap.adjointAux_adjointAux","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁶ : RCLike 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : InnerProductSpace 𝕜 E\ninst✝² : InnerProductSpace 𝕜 F\ninst✝¹ : CompleteSpace E\ninst✝ : CompleteSpace F\nA : ContinuousLinearMap (RingHom.id 𝕜) E F\n⊢ Eq (ContinuousLinearMap.adjointAux (ContinuousLinearMap.adjointAux A)) A","decl":"theorem adjointAux_adjointAux (A : E →L[𝕜] F) : adjointAux (adjointAux A) = A := by\n  ext v\n  refine ext_inner_left 𝕜 fun w => ?_\n  rw [adjointAux_inner_right, adjointAux_inner_left]\n\n"}
{"name":"ContinuousLinearMap.adjointAux_norm","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁶ : RCLike 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : InnerProductSpace 𝕜 E\ninst✝² : InnerProductSpace 𝕜 F\ninst✝¹ : CompleteSpace E\ninst✝ : CompleteSpace F\nA : ContinuousLinearMap (RingHom.id 𝕜) E F\n⊢ Eq (Norm.norm (ContinuousLinearMap.adjointAux A)) (Norm.norm A)","decl":"@[simp]\ntheorem adjointAux_norm (A : E →L[𝕜] F) : ‖adjointAux A‖ = ‖A‖ := by\n  refine le_antisymm ?_ ?_\n  · refine ContinuousLinearMap.opNorm_le_bound _ (norm_nonneg _) fun x => ?_\n    rw [adjointAux_apply, LinearIsometryEquiv.norm_map]\n    exact toSesqForm_apply_norm_le\n  · nth_rw 1 [← adjointAux_adjointAux A]\n    refine ContinuousLinearMap.opNorm_le_bound _ (norm_nonneg _) fun x => ?_\n    rw [adjointAux_apply, LinearIsometryEquiv.norm_map]\n    exact toSesqForm_apply_norm_le\n\n"}
{"name":"ContinuousLinearMap.adjoint_inner_left","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁶ : RCLike 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : InnerProductSpace 𝕜 E\ninst✝² : InnerProductSpace 𝕜 F\ninst✝¹ : CompleteSpace E\ninst✝ : CompleteSpace F\nA : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\ny : F\n⊢ Eq (Inner.inner ((ContinuousLinearMap.adjoint A) y) x) (Inner.inner y (A x))","decl":"/-- The fundamental property of the adjoint. -/\ntheorem adjoint_inner_left (A : E →L[𝕜] F) (x : E) (y : F) : ⟪(A†) y, x⟫ = ⟪y, A x⟫ :=\n  adjointAux_inner_left A x y\n\n"}
{"name":"ContinuousLinearMap.adjoint_inner_right","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁶ : RCLike 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : InnerProductSpace 𝕜 E\ninst✝² : InnerProductSpace 𝕜 F\ninst✝¹ : CompleteSpace E\ninst✝ : CompleteSpace F\nA : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\ny : F\n⊢ Eq (Inner.inner x ((ContinuousLinearMap.adjoint A) y)) (Inner.inner (A x) y)","decl":"/-- The fundamental property of the adjoint. -/\ntheorem adjoint_inner_right (A : E →L[𝕜] F) (x : E) (y : F) : ⟪x, (A†) y⟫ = ⟪A x, y⟫ :=\n  adjointAux_inner_right A x y\n\n"}
{"name":"ContinuousLinearMap.adjoint_adjoint","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁶ : RCLike 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : InnerProductSpace 𝕜 E\ninst✝² : InnerProductSpace 𝕜 F\ninst✝¹ : CompleteSpace E\ninst✝ : CompleteSpace F\nA : ContinuousLinearMap (RingHom.id 𝕜) E F\n⊢ Eq (ContinuousLinearMap.adjoint (ContinuousLinearMap.adjoint A)) A","decl":"/-- The adjoint is involutive. -/\n@[simp]\ntheorem adjoint_adjoint (A : E →L[𝕜] F) : A†† = A :=\n  adjointAux_adjointAux A\n\n"}
{"name":"ContinuousLinearMap.adjoint_comp","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninst✝⁹ : RCLike 𝕜\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : NormedAddCommGroup F\ninst✝⁶ : NormedAddCommGroup G\ninst✝⁵ : InnerProductSpace 𝕜 E\ninst✝⁴ : InnerProductSpace 𝕜 F\ninst✝³ : InnerProductSpace 𝕜 G\ninst✝² : CompleteSpace E\ninst✝¹ : CompleteSpace G\ninst✝ : CompleteSpace F\nA : ContinuousLinearMap (RingHom.id 𝕜) F G\nB : ContinuousLinearMap (RingHom.id 𝕜) E F\n⊢ Eq (ContinuousLinearMap.adjoint (A.comp B)) ((ContinuousLinearMap.adjoint B).comp (ContinuousLinearMap.adjoint A))","decl":"/-- The adjoint of the composition of two operators is the composition of the two adjoints\nin reverse order. -/\n@[simp]\ntheorem adjoint_comp (A : F →L[𝕜] G) (B : E →L[𝕜] F) : (A ∘L B)† = B† ∘L A† := by\n  ext v\n  refine ext_inner_left 𝕜 fun w => ?_\n  simp only [adjoint_inner_right, ContinuousLinearMap.coe_comp', Function.comp_apply]\n\n"}
{"name":"ContinuousLinearMap.apply_norm_sq_eq_inner_adjoint_left","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁶ : RCLike 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : InnerProductSpace 𝕜 E\ninst✝² : InnerProductSpace 𝕜 F\ninst✝¹ : CompleteSpace E\ninst✝ : CompleteSpace F\nA : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\n⊢ Eq (HPow.hPow (Norm.norm (A x)) 2) (RCLike.re (Inner.inner (((ContinuousLinearMap.adjoint A).comp A) x) x))","decl":"theorem apply_norm_sq_eq_inner_adjoint_left (A : E →L[𝕜] F) (x : E) :\n    ‖A x‖ ^ 2 = re ⟪(A† ∘L A) x, x⟫ := by\n  have h : ⟪(A† ∘L A) x, x⟫ = ⟪A x, A x⟫ := by rw [← adjoint_inner_left]; rfl\n  rw [h, ← inner_self_eq_norm_sq (𝕜 := 𝕜) _]\n\n"}
{"name":"ContinuousLinearMap.apply_norm_eq_sqrt_inner_adjoint_left","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁶ : RCLike 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : InnerProductSpace 𝕜 E\ninst✝² : InnerProductSpace 𝕜 F\ninst✝¹ : CompleteSpace E\ninst✝ : CompleteSpace F\nA : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\n⊢ Eq (Norm.norm (A x)) (RCLike.re (Inner.inner (((ContinuousLinearMap.adjoint A).comp A) x) x)).sqrt","decl":"theorem apply_norm_eq_sqrt_inner_adjoint_left (A : E →L[𝕜] F) (x : E) :\n    ‖A x‖ = √(re ⟪(A† ∘L A) x, x⟫) := by\n  rw [← apply_norm_sq_eq_inner_adjoint_left, Real.sqrt_sq (norm_nonneg _)]\n\n"}
{"name":"ContinuousLinearMap.apply_norm_sq_eq_inner_adjoint_right","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁶ : RCLike 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : InnerProductSpace 𝕜 E\ninst✝² : InnerProductSpace 𝕜 F\ninst✝¹ : CompleteSpace E\ninst✝ : CompleteSpace F\nA : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\n⊢ Eq (HPow.hPow (Norm.norm (A x)) 2) (RCLike.re (Inner.inner x (((ContinuousLinearMap.adjoint A).comp A) x)))","decl":"theorem apply_norm_sq_eq_inner_adjoint_right (A : E →L[𝕜] F) (x : E) :\n    ‖A x‖ ^ 2 = re ⟪x, (A† ∘L A) x⟫ := by\n  have h : ⟪x, (A† ∘L A) x⟫ = ⟪A x, A x⟫ := by rw [← adjoint_inner_right]; rfl\n  rw [h, ← inner_self_eq_norm_sq (𝕜 := 𝕜) _]\n\n"}
{"name":"ContinuousLinearMap.apply_norm_eq_sqrt_inner_adjoint_right","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁶ : RCLike 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : InnerProductSpace 𝕜 E\ninst✝² : InnerProductSpace 𝕜 F\ninst✝¹ : CompleteSpace E\ninst✝ : CompleteSpace F\nA : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\n⊢ Eq (Norm.norm (A x)) (RCLike.re (Inner.inner x (((ContinuousLinearMap.adjoint A).comp A) x))).sqrt","decl":"theorem apply_norm_eq_sqrt_inner_adjoint_right (A : E →L[𝕜] F) (x : E) :\n    ‖A x‖ = √(re ⟪x, (A† ∘L A) x⟫) := by\n  rw [← apply_norm_sq_eq_inner_adjoint_right, Real.sqrt_sq (norm_nonneg _)]\n\n"}
{"name":"ContinuousLinearMap.eq_adjoint_iff","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁶ : RCLike 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : InnerProductSpace 𝕜 E\ninst✝² : InnerProductSpace 𝕜 F\ninst✝¹ : CompleteSpace E\ninst✝ : CompleteSpace F\nA : ContinuousLinearMap (RingHom.id 𝕜) E F\nB : ContinuousLinearMap (RingHom.id 𝕜) F E\n⊢ Iff (Eq A (ContinuousLinearMap.adjoint B)) (∀ (x : E) (y : F), Eq (Inner.inner (A x) y) (Inner.inner x (B y)))","decl":"/-- The adjoint is unique: a map `A` is the adjoint of `B` iff it satisfies `⟪A x, y⟫ = ⟪x, B y⟫`\nfor all `x` and `y`. -/\ntheorem eq_adjoint_iff (A : E →L[𝕜] F) (B : F →L[𝕜] E) : A = B† ↔ ∀ x y, ⟪A x, y⟫ = ⟪x, B y⟫ := by\n  refine ⟨fun h x y => by rw [h, adjoint_inner_left], fun h => ?_⟩\n  ext x\n  exact ext_inner_right 𝕜 fun y => by simp only [adjoint_inner_left, h x y]\n\n"}
{"name":"ContinuousLinearMap.adjoint_id","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : RCLike 𝕜\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : CompleteSpace E\n⊢ Eq (ContinuousLinearMap.adjoint (ContinuousLinearMap.id 𝕜 E)) (ContinuousLinearMap.id 𝕜 E)","decl":"@[simp]\ntheorem adjoint_id :\n    ContinuousLinearMap.adjoint (ContinuousLinearMap.id 𝕜 E) = ContinuousLinearMap.id 𝕜 E := by\n  refine Eq.symm ?_\n  rw [eq_adjoint_iff]\n  simp\n\n"}
{"name":"Submodule.adjoint_subtypeL","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁴ : RCLike 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : InnerProductSpace 𝕜 E\ninst✝¹ : CompleteSpace E\nU : Submodule 𝕜 E\ninst✝ : CompleteSpace (Subtype fun x => Membership.mem U x)\n⊢ Eq (ContinuousLinearMap.adjoint U.subtypeL) (orthogonalProjection U)","decl":"theorem _root_.Submodule.adjoint_subtypeL (U : Submodule 𝕜 E) [CompleteSpace U] :\n    U.subtypeL† = orthogonalProjection U := by\n  symm\n  rw [eq_adjoint_iff]\n  intro x u\n  rw [U.coe_inner, inner_orthogonalProjection_left_eq_right,\n    orthogonalProjection_mem_subspace_eq_self]\n  rfl\n\n"}
{"name":"Submodule.adjoint_orthogonalProjection","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁴ : RCLike 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : InnerProductSpace 𝕜 E\ninst✝¹ : CompleteSpace E\nU : Submodule 𝕜 E\ninst✝ : CompleteSpace (Subtype fun x => Membership.mem U x)\n⊢ Eq (ContinuousLinearMap.adjoint (orthogonalProjection U)) U.subtypeL","decl":"theorem _root_.Submodule.adjoint_orthogonalProjection (U : Submodule 𝕜 E) [CompleteSpace U] :\n    (orthogonalProjection U : E →L[𝕜] U)† = U.subtypeL := by\n  rw [← U.adjoint_subtypeL, adjoint_adjoint]\n\n"}
{"name":"ContinuousLinearMap.instStarModuleId","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : RCLike 𝕜\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : CompleteSpace E\n⊢ StarModule 𝕜 (ContinuousLinearMap (RingHom.id 𝕜) E E)","decl":"instance : StarModule 𝕜 (E →L[𝕜] E) :=\n  ⟨LinearIsometryEquiv.map_smulₛₗ adjoint⟩\n\n"}
{"name":"ContinuousLinearMap.star_eq_adjoint","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : RCLike 𝕜\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : CompleteSpace E\nA : ContinuousLinearMap (RingHom.id 𝕜) E E\n⊢ Eq (Star.star A) (ContinuousLinearMap.adjoint A)","decl":"theorem star_eq_adjoint (A : E →L[𝕜] E) : star A = A† :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.isSelfAdjoint_iff'","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : RCLike 𝕜\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : CompleteSpace E\nA : ContinuousLinearMap (RingHom.id 𝕜) E E\n⊢ Iff (IsSelfAdjoint A) (Eq (ContinuousLinearMap.adjoint A) A)","decl":"/-- A continuous linear operator is self-adjoint iff it is equal to its adjoint. -/\ntheorem isSelfAdjoint_iff' {A : E →L[𝕜] E} : IsSelfAdjoint A ↔ ContinuousLinearMap.adjoint A = A :=\n  Iff.rfl\n\n"}
{"name":"ContinuousLinearMap.norm_adjoint_comp_self","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁶ : RCLike 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : InnerProductSpace 𝕜 E\ninst✝² : InnerProductSpace 𝕜 F\ninst✝¹ : CompleteSpace E\ninst✝ : CompleteSpace F\nA : ContinuousLinearMap (RingHom.id 𝕜) E F\n⊢ Eq (Norm.norm ((ContinuousLinearMap.adjoint A).comp A)) (HMul.hMul (Norm.norm A) (Norm.norm A))","decl":"theorem norm_adjoint_comp_self (A : E →L[𝕜] F) :\n    ‖ContinuousLinearMap.adjoint A ∘L A‖ = ‖A‖ * ‖A‖ := by\n  refine le_antisymm ?_ ?_\n  · calc\n      ‖A† ∘L A‖ ≤ ‖A†‖ * ‖A‖ := opNorm_comp_le _ _\n      _ = ‖A‖ * ‖A‖ := by rw [LinearIsometryEquiv.norm_map]\n  · rw [← sq, ← Real.sqrt_le_sqrt_iff (norm_nonneg _), Real.sqrt_sq (norm_nonneg _)]\n    refine opNorm_le_bound _ (Real.sqrt_nonneg _) fun x => ?_\n    have :=\n      calc\n        re ⟪(A† ∘L A) x, x⟫ ≤ ‖(A† ∘L A) x‖ * ‖x‖ := re_inner_le_norm _ _\n        _ ≤ ‖A† ∘L A‖ * ‖x‖ * ‖x‖ := mul_le_mul_of_nonneg_right (le_opNorm _ _) (norm_nonneg _)\n    calc\n      ‖A x‖ = √(re ⟪(A† ∘L A) x, x⟫) := by rw [apply_norm_eq_sqrt_inner_adjoint_left]\n      _ ≤ √(‖A† ∘L A‖ * ‖x‖ * ‖x‖) := Real.sqrt_le_sqrt this\n      _ = √‖A† ∘L A‖ * ‖x‖ := by\n        simp_rw [mul_assoc, Real.sqrt_mul (norm_nonneg _) (‖x‖ * ‖x‖),\n          Real.sqrt_mul_self (norm_nonneg x)]\n\n"}
{"name":"ContinuousLinearMap.instCStarRingId","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : RCLike 𝕜\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : CompleteSpace E\n⊢ CStarRing (ContinuousLinearMap (RingHom.id 𝕜) E E)","decl":"/-- The C⋆-algebra instance when `𝕜 := ℂ` can be found in\n`Analysis.CStarAlgebra.ContinuousLinearMap`. -/\ninstance : CStarRing (E →L[𝕜] E) where\n  norm_mul_self_le x := le_of_eq <| Eq.symm <| norm_adjoint_comp_self x\n\n"}
{"name":"ContinuousLinearMap.isAdjointPair_inner","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁶ : RCLike 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : InnerProductSpace 𝕜 E\ninst✝² : InnerProductSpace 𝕜 F\ninst✝¹ : CompleteSpace E\ninst✝ : CompleteSpace F\nA : ContinuousLinearMap (RingHom.id 𝕜) E F\n⊢ sesqFormOfInner.IsAdjointPair sesqFormOfInner ⇑A ⇑(ContinuousLinearMap.adjoint A)","decl":"theorem isAdjointPair_inner (A : E →L[𝕜] F) :\n    LinearMap.IsAdjointPair (sesqFormOfInner : E →ₗ[𝕜] E →ₗ⋆[𝕜] 𝕜)\n      (sesqFormOfInner : F →ₗ[𝕜] F →ₗ⋆[𝕜] 𝕜) A (A†) := by\n  intro x y\n  simp only [sesqFormOfInner_apply_apply, adjoint_inner_left, coe_coe]\n\n"}
{"name":"IsSelfAdjoint.adjoint_eq","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : RCLike 𝕜\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : CompleteSpace E\nA : ContinuousLinearMap (RingHom.id 𝕜) E E\nhA : IsSelfAdjoint A\n⊢ Eq (ContinuousLinearMap.adjoint A) A","decl":"theorem adjoint_eq {A : E →L[𝕜] E} (hA : IsSelfAdjoint A) : ContinuousLinearMap.adjoint A = A :=\n  hA\n\n"}
{"name":"IsSelfAdjoint.isSymmetric","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : RCLike 𝕜\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : CompleteSpace E\nA : ContinuousLinearMap (RingHom.id 𝕜) E E\nhA : IsSelfAdjoint A\n⊢ (↑A).IsSymmetric","decl":"/-- Every self-adjoint operator on an inner product space is symmetric. -/\ntheorem isSymmetric {A : E →L[𝕜] E} (hA : IsSelfAdjoint A) : (A : E →ₗ[𝕜] E).IsSymmetric := by\n  intro x y\n  rw_mod_cast [← A.adjoint_inner_right, hA.adjoint_eq]\n\n"}
{"name":"IsSelfAdjoint.conj_adjoint","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁶ : RCLike 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : InnerProductSpace 𝕜 E\ninst✝² : InnerProductSpace 𝕜 F\ninst✝¹ : CompleteSpace E\ninst✝ : CompleteSpace F\nT : ContinuousLinearMap (RingHom.id 𝕜) E E\nhT : IsSelfAdjoint T\nS : ContinuousLinearMap (RingHom.id 𝕜) E F\n⊢ IsSelfAdjoint (S.comp (T.comp (ContinuousLinearMap.adjoint S)))","decl":"/-- Conjugating preserves self-adjointness. -/\ntheorem conj_adjoint {T : E →L[𝕜] E} (hT : IsSelfAdjoint T) (S : E →L[𝕜] F) :\n    IsSelfAdjoint (S ∘L T ∘L ContinuousLinearMap.adjoint S) := by\n  rw [isSelfAdjoint_iff'] at hT ⊢\n  simp only [hT, adjoint_comp, adjoint_adjoint]\n  exact ContinuousLinearMap.comp_assoc _ _ _\n\n"}
{"name":"IsSelfAdjoint.adjoint_conj","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁶ : RCLike 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : InnerProductSpace 𝕜 E\ninst✝² : InnerProductSpace 𝕜 F\ninst✝¹ : CompleteSpace E\ninst✝ : CompleteSpace F\nT : ContinuousLinearMap (RingHom.id 𝕜) E E\nhT : IsSelfAdjoint T\nS : ContinuousLinearMap (RingHom.id 𝕜) F E\n⊢ IsSelfAdjoint ((ContinuousLinearMap.adjoint S).comp (T.comp S))","decl":"/-- Conjugating preserves self-adjointness. -/\ntheorem adjoint_conj {T : E →L[𝕜] E} (hT : IsSelfAdjoint T) (S : F →L[𝕜] E) :\n    IsSelfAdjoint (ContinuousLinearMap.adjoint S ∘L T ∘L S) := by\n  rw [isSelfAdjoint_iff'] at hT ⊢\n  simp only [hT, adjoint_comp, adjoint_adjoint]\n  exact ContinuousLinearMap.comp_assoc _ _ _\n\n"}
{"name":"ContinuousLinearMap.isSelfAdjoint_iff_isSymmetric","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : RCLike 𝕜\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : CompleteSpace E\nA : ContinuousLinearMap (RingHom.id 𝕜) E E\n⊢ Iff (IsSelfAdjoint A) (↑A).IsSymmetric","decl":"theorem _root_.ContinuousLinearMap.isSelfAdjoint_iff_isSymmetric {A : E →L[𝕜] E} :\n    IsSelfAdjoint A ↔ (A : E →ₗ[𝕜] E).IsSymmetric :=\n  ⟨fun hA => hA.isSymmetric, fun hA =>\n    ext fun x => ext_inner_right 𝕜 fun y => (A.adjoint_inner_left y x).symm ▸ (hA x y).symm⟩\n\n"}
{"name":"LinearMap.IsSymmetric.isSelfAdjoint","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : RCLike 𝕜\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : CompleteSpace E\nA : ContinuousLinearMap (RingHom.id 𝕜) E E\nhA : (↑A).IsSymmetric\n⊢ IsSelfAdjoint A","decl":"theorem _root_.LinearMap.IsSymmetric.isSelfAdjoint {A : E →L[𝕜] E}\n    (hA : (A : E →ₗ[𝕜] E).IsSymmetric) : IsSelfAdjoint A := by\n  rwa [← ContinuousLinearMap.isSelfAdjoint_iff_isSymmetric] at hA\n\n"}
{"name":"orthogonalProjection_isSelfAdjoint","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁴ : RCLike 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : InnerProductSpace 𝕜 E\ninst✝¹ : CompleteSpace E\nU : Submodule 𝕜 E\ninst✝ : CompleteSpace (Subtype fun x => Membership.mem U x)\n⊢ IsSelfAdjoint (U.subtypeL.comp (orthogonalProjection U))","decl":"/-- The orthogonal projection is self-adjoint. -/\ntheorem _root_.orthogonalProjection_isSelfAdjoint (U : Submodule 𝕜 E) [CompleteSpace U] :\n    IsSelfAdjoint (U.subtypeL ∘L orthogonalProjection U) :=\n  (orthogonalProjection_isSymmetric U).isSelfAdjoint\n\n"}
{"name":"IsSelfAdjoint.conj_orthogonalProjection","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁴ : RCLike 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : InnerProductSpace 𝕜 E\ninst✝¹ : CompleteSpace E\nT : ContinuousLinearMap (RingHom.id 𝕜) E E\nhT : IsSelfAdjoint T\nU : Submodule 𝕜 E\ninst✝ : CompleteSpace (Subtype fun x => Membership.mem U x)\n⊢ IsSelfAdjoint (U.subtypeL.comp ((orthogonalProjection U).comp (T.comp (U.subtypeL.comp (orthogonalProjection U)))))","decl":"theorem conj_orthogonalProjection {T : E →L[𝕜] E} (hT : IsSelfAdjoint T) (U : Submodule 𝕜 E)\n    [CompleteSpace U] :\n    IsSelfAdjoint\n      (U.subtypeL ∘L orthogonalProjection U ∘L T ∘L U.subtypeL ∘L orthogonalProjection U) := by\n  rw [← ContinuousLinearMap.comp_assoc]\n  nth_rw 1 [← (orthogonalProjection_isSelfAdjoint U).adjoint_eq]\n  exact hT.adjoint_conj _\n\n"}
{"name":"LinearMap.IsSymmetric.coe_toSelfAdjoint","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : RCLike 𝕜\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : CompleteSpace E\nT : LinearMap (RingHom.id 𝕜) E E\nhT : T.IsSymmetric\n⊢ Eq (↑↑hT.toSelfAdjoint) T","decl":"theorem IsSymmetric.coe_toSelfAdjoint (hT : IsSymmetric T) : (hT.toSelfAdjoint : E →ₗ[𝕜] E) = T :=\n  rfl\n\n"}
{"name":"LinearMap.IsSymmetric.toSelfAdjoint_apply","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : RCLike 𝕜\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : CompleteSpace E\nT : LinearMap (RingHom.id 𝕜) E E\nhT : T.IsSymmetric\nx : E\n⊢ Eq (↑hT.toSelfAdjoint x) (T x)","decl":"theorem IsSymmetric.toSelfAdjoint_apply (hT : IsSymmetric T) {x : E} :\n    (hT.toSelfAdjoint : E → E) x = T x :=\n  rfl\n\n"}
{"name":"LinearMap.adjoint_toContinuousLinearMap","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁶ : RCLike 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : InnerProductSpace 𝕜 E\ninst✝² : InnerProductSpace 𝕜 F\ninst✝¹ : FiniteDimensional 𝕜 E\ninst✝ : FiniteDimensional 𝕜 F\nA : LinearMap (RingHom.id 𝕜) E F\n⊢ Eq (LinearMap.toContinuousLinearMap (LinearMap.adjoint A)) (ContinuousLinearMap.adjoint (LinearMap.toContinuousLinearMap A))","decl":"theorem adjoint_toContinuousLinearMap (A : E →ₗ[𝕜] F) :\n    haveI := FiniteDimensional.complete 𝕜 E\n    haveI := FiniteDimensional.complete 𝕜 F\n    LinearMap.toContinuousLinearMap (LinearMap.adjoint A) =\n      ContinuousLinearMap.adjoint (LinearMap.toContinuousLinearMap A) :=\n  rfl\n\n"}
{"name":"LinearMap.adjoint_eq_toCLM_adjoint","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁶ : RCLike 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : InnerProductSpace 𝕜 E\ninst✝² : InnerProductSpace 𝕜 F\ninst✝¹ : FiniteDimensional 𝕜 E\ninst✝ : FiniteDimensional 𝕜 F\nA : LinearMap (RingHom.id 𝕜) E F\n⊢ Eq (LinearMap.adjoint A) ↑(ContinuousLinearMap.adjoint (LinearMap.toContinuousLinearMap A))","decl":"theorem adjoint_eq_toCLM_adjoint (A : E →ₗ[𝕜] F) :\n    haveI := FiniteDimensional.complete 𝕜 E\n    haveI := FiniteDimensional.complete 𝕜 F\n    LinearMap.adjoint A = ContinuousLinearMap.adjoint (LinearMap.toContinuousLinearMap A) :=\n  rfl\n\n"}
{"name":"LinearMap.adjoint_inner_left","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁶ : RCLike 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : InnerProductSpace 𝕜 E\ninst✝² : InnerProductSpace 𝕜 F\ninst✝¹ : FiniteDimensional 𝕜 E\ninst✝ : FiniteDimensional 𝕜 F\nA : LinearMap (RingHom.id 𝕜) E F\nx : E\ny : F\n⊢ Eq (Inner.inner ((LinearMap.adjoint A) y) x) (Inner.inner y (A x))","decl":"/-- The fundamental property of the adjoint. -/\ntheorem adjoint_inner_left (A : E →ₗ[𝕜] F) (x : E) (y : F) : ⟪adjoint A y, x⟫ = ⟪y, A x⟫ := by\n  haveI := FiniteDimensional.complete 𝕜 E\n  haveI := FiniteDimensional.complete 𝕜 F\n  rw [← coe_toContinuousLinearMap A, adjoint_eq_toCLM_adjoint]\n  exact ContinuousLinearMap.adjoint_inner_left _ x y\n\n"}
{"name":"LinearMap.adjoint_inner_right","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁶ : RCLike 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : InnerProductSpace 𝕜 E\ninst✝² : InnerProductSpace 𝕜 F\ninst✝¹ : FiniteDimensional 𝕜 E\ninst✝ : FiniteDimensional 𝕜 F\nA : LinearMap (RingHom.id 𝕜) E F\nx : E\ny : F\n⊢ Eq (Inner.inner x ((LinearMap.adjoint A) y)) (Inner.inner (A x) y)","decl":"/-- The fundamental property of the adjoint. -/\ntheorem adjoint_inner_right (A : E →ₗ[𝕜] F) (x : E) (y : F) : ⟪x, adjoint A y⟫ = ⟪A x, y⟫ := by\n  haveI := FiniteDimensional.complete 𝕜 E\n  haveI := FiniteDimensional.complete 𝕜 F\n  rw [← coe_toContinuousLinearMap A, adjoint_eq_toCLM_adjoint]\n  exact ContinuousLinearMap.adjoint_inner_right _ x y\n\n"}
{"name":"LinearMap.adjoint_adjoint","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁶ : RCLike 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : InnerProductSpace 𝕜 E\ninst✝² : InnerProductSpace 𝕜 F\ninst✝¹ : FiniteDimensional 𝕜 E\ninst✝ : FiniteDimensional 𝕜 F\nA : LinearMap (RingHom.id 𝕜) E F\n⊢ Eq (LinearMap.adjoint (LinearMap.adjoint A)) A","decl":"/-- The adjoint is involutive. -/\n@[simp]\ntheorem adjoint_adjoint (A : E →ₗ[𝕜] F) : LinearMap.adjoint (LinearMap.adjoint A) = A := by\n  ext v\n  refine ext_inner_left 𝕜 fun w => ?_\n  rw [adjoint_inner_right, adjoint_inner_left]\n\n"}
{"name":"LinearMap.adjoint_comp","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninst✝⁹ : RCLike 𝕜\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : NormedAddCommGroup F\ninst✝⁶ : NormedAddCommGroup G\ninst✝⁵ : InnerProductSpace 𝕜 E\ninst✝⁴ : InnerProductSpace 𝕜 F\ninst✝³ : InnerProductSpace 𝕜 G\ninst✝² : FiniteDimensional 𝕜 E\ninst✝¹ : FiniteDimensional 𝕜 F\ninst✝ : FiniteDimensional 𝕜 G\nA : LinearMap (RingHom.id 𝕜) F G\nB : LinearMap (RingHom.id 𝕜) E F\n⊢ Eq (LinearMap.adjoint (A.comp B)) ((LinearMap.adjoint B).comp (LinearMap.adjoint A))","decl":"/-- The adjoint of the composition of two operators is the composition of the two adjoints\nin reverse order. -/\n@[simp]\ntheorem adjoint_comp (A : F →ₗ[𝕜] G) (B : E →ₗ[𝕜] F) :\n    LinearMap.adjoint (A ∘ₗ B) = LinearMap.adjoint B ∘ₗ LinearMap.adjoint A := by\n  ext v\n  refine ext_inner_left 𝕜 fun w => ?_\n  simp only [adjoint_inner_right, LinearMap.coe_comp, Function.comp_apply]\n\n"}
{"name":"LinearMap.eq_adjoint_iff","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁶ : RCLike 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : InnerProductSpace 𝕜 E\ninst✝² : InnerProductSpace 𝕜 F\ninst✝¹ : FiniteDimensional 𝕜 E\ninst✝ : FiniteDimensional 𝕜 F\nA : LinearMap (RingHom.id 𝕜) E F\nB : LinearMap (RingHom.id 𝕜) F E\n⊢ Iff (Eq A (LinearMap.adjoint B)) (∀ (x : E) (y : F), Eq (Inner.inner (A x) y) (Inner.inner x (B y)))","decl":"/-- The adjoint is unique: a map `A` is the adjoint of `B` iff it satisfies `⟪A x, y⟫ = ⟪x, B y⟫`\nfor all `x` and `y`. -/\ntheorem eq_adjoint_iff (A : E →ₗ[𝕜] F) (B : F →ₗ[𝕜] E) :\n    A = LinearMap.adjoint B ↔ ∀ x y, ⟪A x, y⟫ = ⟪x, B y⟫ := by\n  refine ⟨fun h x y => by rw [h, adjoint_inner_left], fun h => ?_⟩\n  ext x\n  exact ext_inner_right 𝕜 fun y => by simp only [adjoint_inner_left, h x y]\n\n"}
{"name":"LinearMap.eq_adjoint_iff_basis","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁶ : RCLike 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : InnerProductSpace 𝕜 E\ninst✝² : InnerProductSpace 𝕜 F\ninst✝¹ : FiniteDimensional 𝕜 E\ninst✝ : FiniteDimensional 𝕜 F\nι₁ : Type u_5\nι₂ : Type u_6\nb₁ : Basis ι₁ 𝕜 E\nb₂ : Basis ι₂ 𝕜 F\nA : LinearMap (RingHom.id 𝕜) E F\nB : LinearMap (RingHom.id 𝕜) F E\n⊢ Iff (Eq A (LinearMap.adjoint B)) (∀ (i₁ : ι₁) (i₂ : ι₂), Eq (Inner.inner (A (b₁ i₁)) (b₂ i₂)) (Inner.inner (b₁ i₁) (B (b₂ i₂))))","decl":"/-- The adjoint is unique: a map `A` is the adjoint of `B` iff it satisfies `⟪A x, y⟫ = ⟪x, B y⟫`\nfor all basis vectors `x` and `y`. -/\ntheorem eq_adjoint_iff_basis {ι₁ : Type*} {ι₂ : Type*} (b₁ : Basis ι₁ 𝕜 E) (b₂ : Basis ι₂ 𝕜 F)\n    (A : E →ₗ[𝕜] F) (B : F →ₗ[𝕜] E) :\n    A = LinearMap.adjoint B ↔ ∀ (i₁ : ι₁) (i₂ : ι₂), ⟪A (b₁ i₁), b₂ i₂⟫ = ⟪b₁ i₁, B (b₂ i₂)⟫ := by\n  refine ⟨fun h x y => by rw [h, adjoint_inner_left], fun h => ?_⟩\n  refine Basis.ext b₁ fun i₁ => ?_\n  exact ext_inner_right_basis b₂ fun i₂ => by simp only [adjoint_inner_left, h i₁ i₂]\n\n"}
{"name":"LinearMap.eq_adjoint_iff_basis_left","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁶ : RCLike 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : InnerProductSpace 𝕜 E\ninst✝² : InnerProductSpace 𝕜 F\ninst✝¹ : FiniteDimensional 𝕜 E\ninst✝ : FiniteDimensional 𝕜 F\nι : Type u_5\nb : Basis ι 𝕜 E\nA : LinearMap (RingHom.id 𝕜) E F\nB : LinearMap (RingHom.id 𝕜) F E\n⊢ Iff (Eq A (LinearMap.adjoint B)) (∀ (i : ι) (y : F), Eq (Inner.inner (A (b i)) y) (Inner.inner (b i) (B y)))","decl":"theorem eq_adjoint_iff_basis_left {ι : Type*} (b : Basis ι 𝕜 E) (A : E →ₗ[𝕜] F) (B : F →ₗ[𝕜] E) :\n    A = LinearMap.adjoint B ↔ ∀ i y, ⟪A (b i), y⟫ = ⟪b i, B y⟫ := by\n  refine ⟨fun h x y => by rw [h, adjoint_inner_left], fun h => Basis.ext b fun i => ?_⟩\n  exact ext_inner_right 𝕜 fun y => by simp only [h i, adjoint_inner_left]\n\n"}
{"name":"LinearMap.eq_adjoint_iff_basis_right","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁶ : RCLike 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : InnerProductSpace 𝕜 E\ninst✝² : InnerProductSpace 𝕜 F\ninst✝¹ : FiniteDimensional 𝕜 E\ninst✝ : FiniteDimensional 𝕜 F\nι : Type u_5\nb : Basis ι 𝕜 F\nA : LinearMap (RingHom.id 𝕜) E F\nB : LinearMap (RingHom.id 𝕜) F E\n⊢ Iff (Eq A (LinearMap.adjoint B)) (∀ (i : ι) (x : E), Eq (Inner.inner (A x) (b i)) (Inner.inner x (B (b i))))","decl":"theorem eq_adjoint_iff_basis_right {ι : Type*} (b : Basis ι 𝕜 F) (A : E →ₗ[𝕜] F) (B : F →ₗ[𝕜] E) :\n    A = LinearMap.adjoint B ↔ ∀ i x, ⟪A x, b i⟫ = ⟪x, B (b i)⟫ := by\n  refine ⟨fun h x y => by rw [h, adjoint_inner_left], fun h => ?_⟩\n  ext x\n  exact ext_inner_right_basis b fun i => by simp only [h i, adjoint_inner_left]\n\n"}
{"name":"LinearMap.instStarModuleId","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : RCLike 𝕜\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : FiniteDimensional 𝕜 E\n⊢ StarModule 𝕜 (LinearMap (RingHom.id 𝕜) E E)","decl":"instance : StarModule 𝕜 (E →ₗ[𝕜] E) :=\n  ⟨LinearEquiv.map_smulₛₗ adjoint⟩\n\n"}
{"name":"LinearMap.star_eq_adjoint","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : RCLike 𝕜\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : FiniteDimensional 𝕜 E\nA : LinearMap (RingHom.id 𝕜) E E\n⊢ Eq (Star.star A) (LinearMap.adjoint A)","decl":"theorem star_eq_adjoint (A : E →ₗ[𝕜] E) : star A = LinearMap.adjoint A :=\n  rfl\n\n"}
{"name":"LinearMap.isSelfAdjoint_iff'","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : RCLike 𝕜\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : FiniteDimensional 𝕜 E\nA : LinearMap (RingHom.id 𝕜) E E\n⊢ Iff (IsSelfAdjoint A) (Eq (LinearMap.adjoint A) A)","decl":"/-- A continuous linear operator is self-adjoint iff it is equal to its adjoint. -/\ntheorem isSelfAdjoint_iff' {A : E →ₗ[𝕜] E} : IsSelfAdjoint A ↔ LinearMap.adjoint A = A :=\n  Iff.rfl\n\n"}
{"name":"LinearMap.isSymmetric_iff_isSelfAdjoint","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : RCLike 𝕜\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : FiniteDimensional 𝕜 E\nA : LinearMap (RingHom.id 𝕜) E E\n⊢ Iff A.IsSymmetric (IsSelfAdjoint A)","decl":"theorem isSymmetric_iff_isSelfAdjoint (A : E →ₗ[𝕜] E) : IsSymmetric A ↔ IsSelfAdjoint A := by\n  rw [isSelfAdjoint_iff', IsSymmetric, ← LinearMap.eq_adjoint_iff]\n  exact eq_comm\n\n"}
{"name":"LinearMap.isAdjointPair_inner","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁶ : RCLike 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : InnerProductSpace 𝕜 E\ninst✝² : InnerProductSpace 𝕜 F\ninst✝¹ : FiniteDimensional 𝕜 E\ninst✝ : FiniteDimensional 𝕜 F\nA : LinearMap (RingHom.id 𝕜) E F\n⊢ sesqFormOfInner.IsAdjointPair sesqFormOfInner ⇑A ⇑(LinearMap.adjoint A)","decl":"theorem isAdjointPair_inner (A : E →ₗ[𝕜] F) :\n    IsAdjointPair (sesqFormOfInner : E →ₗ[𝕜] E →ₗ⋆[𝕜] 𝕜) (sesqFormOfInner : F →ₗ[𝕜] F →ₗ⋆[𝕜] 𝕜) A\n      (LinearMap.adjoint A) := by\n  intro x y\n  simp only [sesqFormOfInner_apply_apply, adjoint_inner_left]\n\n"}
{"name":"LinearMap.isSymmetric_adjoint_mul_self","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : RCLike 𝕜\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : FiniteDimensional 𝕜 E\nT : LinearMap (RingHom.id 𝕜) E E\n⊢ (HMul.hMul (LinearMap.adjoint T) T).IsSymmetric","decl":"/-- The Gram operator T†T is symmetric. -/\ntheorem isSymmetric_adjoint_mul_self (T : E →ₗ[𝕜] E) : IsSymmetric (LinearMap.adjoint T * T) := by\n  intro x y\n  simp only [mul_apply, adjoint_inner_left, adjoint_inner_right]\n\n"}
{"name":"LinearMap.re_inner_adjoint_mul_self_nonneg","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : RCLike 𝕜\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : FiniteDimensional 𝕜 E\nT : LinearMap (RingHom.id 𝕜) E E\nx : E\n⊢ LE.le 0 (RCLike.re (Inner.inner x ((HMul.hMul (LinearMap.adjoint T) T) x)))","decl":"/-- The Gram operator T†T is a positive operator. -/\ntheorem re_inner_adjoint_mul_self_nonneg (T : E →ₗ[𝕜] E) (x : E) :\n    0 ≤ re ⟪x, (LinearMap.adjoint T * T) x⟫ := by\n  simp only [mul_apply, adjoint_inner_right, inner_self_eq_norm_sq_to_K]\n  norm_cast\n  exact sq_nonneg _\n\n"}
{"name":"LinearMap.im_inner_adjoint_mul_self_eq_zero","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : RCLike 𝕜\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : FiniteDimensional 𝕜 E\nT : LinearMap (RingHom.id 𝕜) E E\nx : E\n⊢ Eq (RCLike.im (Inner.inner x ((LinearMap.adjoint T) (T x)))) 0","decl":"@[simp]\ntheorem im_inner_adjoint_mul_self_eq_zero (T : E →ₗ[𝕜] E) (x : E) :\n    im ⟪x, LinearMap.adjoint T (T x)⟫ = 0 := by\n  simp only [mul_apply, adjoint_inner_right, inner_self_eq_norm_sq_to_K]\n  norm_cast\n\n"}
{"name":"ContinuousLinearMap.inner_map_map_iff_adjoint_comp_self","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : RCLike 𝕜\nH : Type u_5\ninst✝⁵ : NormedAddCommGroup H\ninst✝⁴ : InnerProductSpace 𝕜 H\ninst✝³ : CompleteSpace H\nK : Type u_6\ninst✝² : NormedAddCommGroup K\ninst✝¹ : InnerProductSpace 𝕜 K\ninst✝ : CompleteSpace K\nu : ContinuousLinearMap (RingHom.id 𝕜) H K\n⊢ Iff (∀ (x y : H), Eq (Inner.inner (u x) (u y)) (Inner.inner x y)) (Eq ((ContinuousLinearMap.adjoint u).comp u) 1)","decl":"theorem inner_map_map_iff_adjoint_comp_self (u : H →L[𝕜] K) :\n    (∀ x y : H, ⟪u x, u y⟫_𝕜 = ⟪x, y⟫_𝕜) ↔ adjoint u ∘L u = 1 := by\n  refine ⟨fun h ↦ ext fun x ↦ ?_, fun h ↦ ?_⟩\n  · refine ext_inner_right 𝕜 fun y ↦ ?_\n    simpa [star_eq_adjoint, adjoint_inner_left] using h x y\n  · simp [← adjoint_inner_left, ← comp_apply, h]\n\n"}
{"name":"ContinuousLinearMap.norm_map_iff_adjoint_comp_self","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : RCLike 𝕜\nH : Type u_5\ninst✝⁵ : NormedAddCommGroup H\ninst✝⁴ : InnerProductSpace 𝕜 H\ninst✝³ : CompleteSpace H\nK : Type u_6\ninst✝² : NormedAddCommGroup K\ninst✝¹ : InnerProductSpace 𝕜 K\ninst✝ : CompleteSpace K\nu : ContinuousLinearMap (RingHom.id 𝕜) H K\n⊢ Iff (∀ (x : H), Eq (Norm.norm (u x)) (Norm.norm x)) (Eq ((ContinuousLinearMap.adjoint u).comp u) 1)","decl":"theorem norm_map_iff_adjoint_comp_self (u : H →L[𝕜] K) :\n    (∀ x : H, ‖u x‖ = ‖x‖) ↔ adjoint u ∘L u = 1 := by\n  rw [LinearMap.norm_map_iff_inner_map_map u, u.inner_map_map_iff_adjoint_comp_self]\n\n"}
{"name":"LinearIsometryEquiv.adjoint_eq_symm","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : RCLike 𝕜\nH : Type u_5\ninst✝⁵ : NormedAddCommGroup H\ninst✝⁴ : InnerProductSpace 𝕜 H\ninst✝³ : CompleteSpace H\nK : Type u_6\ninst✝² : NormedAddCommGroup K\ninst✝¹ : InnerProductSpace 𝕜 K\ninst✝ : CompleteSpace K\ne : LinearIsometryEquiv (RingHom.id 𝕜) H K\n⊢ Eq (ContinuousLinearMap.adjoint ↑{ toLinearEquiv := e.toLinearEquiv, continuous_toFun := ⋯, continuous_invFun := ⋯ }) ↑{ toLinearEquiv := e.symm.toLinearEquiv, continuous_toFun := ⋯, continuous_invFun := ⋯ }","decl":"@[simp]\nlemma _root_.LinearIsometryEquiv.adjoint_eq_symm (e : H ≃ₗᵢ[𝕜] K) :\n    adjoint (e : H →L[𝕜] K) = e.symm :=\n  let e' := (e : H →L[𝕜] K)\n  calc\n    adjoint e' = adjoint e' ∘L (e' ∘L e.symm) := by\n      convert (adjoint e').comp_id.symm\n      ext\n      simp [e']\n    _ = e.symm := by\n      rw [← comp_assoc, norm_map_iff_adjoint_comp_self e' |>.mp e.norm_map]\n      exact (e.symm : K →L[𝕜] H).id_comp\n\n"}
{"name":"LinearIsometryEquiv.star_eq_symm","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\ninst✝³ : RCLike 𝕜\nH : Type u_5\ninst✝² : NormedAddCommGroup H\ninst✝¹ : InnerProductSpace 𝕜 H\ninst✝ : CompleteSpace H\ne : LinearIsometryEquiv (RingHom.id 𝕜) H H\n⊢ Eq (Star.star ↑{ toLinearEquiv := e.toLinearEquiv, continuous_toFun := ⋯, continuous_invFun := ⋯ }) ↑{ toLinearEquiv := e.symm.toLinearEquiv, continuous_toFun := ⋯, continuous_invFun := ⋯ }","decl":"@[simp]\nlemma _root_.LinearIsometryEquiv.star_eq_symm (e : H ≃ₗᵢ[𝕜] H) :\n    star (e : H →L[𝕜] H) = e.symm :=\n  e.adjoint_eq_symm\n\n"}
{"name":"ContinuousLinearMap.norm_map_of_mem_unitary","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\ninst✝³ : RCLike 𝕜\nH : Type u_5\ninst✝² : NormedAddCommGroup H\ninst✝¹ : InnerProductSpace 𝕜 H\ninst✝ : CompleteSpace H\nu : ContinuousLinearMap (RingHom.id 𝕜) H H\nhu : Membership.mem (unitary (ContinuousLinearMap (RingHom.id 𝕜) H H)) u\nx : H\n⊢ Eq (Norm.norm (u x)) (Norm.norm x)","decl":"theorem norm_map_of_mem_unitary {u : H →L[𝕜] H} (hu : u ∈ unitary (H →L[𝕜] H)) (x : H) :\n    ‖u x‖ = ‖x‖ :=\n  -- Elaborates faster with this broken out https://github.com/leanprover-community/mathlib4/issues/11299\n  have := unitary.star_mul_self_of_mem hu\n  u.norm_map_iff_adjoint_comp_self.mpr this x\n\n"}
{"name":"ContinuousLinearMap.inner_map_map_of_mem_unitary","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\ninst✝³ : RCLike 𝕜\nH : Type u_5\ninst✝² : NormedAddCommGroup H\ninst✝¹ : InnerProductSpace 𝕜 H\ninst✝ : CompleteSpace H\nu : ContinuousLinearMap (RingHom.id 𝕜) H H\nhu : Membership.mem (unitary (ContinuousLinearMap (RingHom.id 𝕜) H H)) u\nx y : H\n⊢ Eq (Inner.inner (u x) (u y)) (Inner.inner x y)","decl":"theorem inner_map_map_of_mem_unitary {u : H →L[𝕜] H} (hu : u ∈ unitary (H →L[𝕜] H)) (x y : H) :\n    ⟪u x, u y⟫_𝕜 = ⟪x, y⟫_𝕜 :=\n  -- Elaborates faster with this broken out https://github.com/leanprover-community/mathlib4/issues/11299\n  have := unitary.star_mul_self_of_mem hu\n  u.inner_map_map_iff_adjoint_comp_self.mpr this x y\n\n"}
{"name":"unitary.norm_map","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\ninst✝³ : RCLike 𝕜\nH : Type u_5\ninst✝² : NormedAddCommGroup H\ninst✝¹ : InnerProductSpace 𝕜 H\ninst✝ : CompleteSpace H\nu : Subtype fun x => Membership.mem (unitary (ContinuousLinearMap (RingHom.id 𝕜) H H)) x\nx : H\n⊢ Eq (Norm.norm (↑u x)) (Norm.norm x)","decl":"theorem norm_map (u : unitary (H →L[𝕜] H)) (x : H) : ‖(u : H →L[𝕜] H) x‖ = ‖x‖ :=\n  u.val.norm_map_of_mem_unitary u.property x\n\n"}
{"name":"unitary.inner_map_map","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\ninst✝³ : RCLike 𝕜\nH : Type u_5\ninst✝² : NormedAddCommGroup H\ninst✝¹ : InnerProductSpace 𝕜 H\ninst✝ : CompleteSpace H\nu : Subtype fun x => Membership.mem (unitary (ContinuousLinearMap (RingHom.id 𝕜) H H)) x\nx y : H\n⊢ Eq (Inner.inner (↑u x) (↑u y)) (Inner.inner x y)","decl":"theorem inner_map_map (u : unitary (H →L[𝕜] H)) (x y : H) :\n    ⟪(u : H →L[𝕜] H) x, (u : H →L[𝕜] H) y⟫_𝕜 = ⟪x, y⟫_𝕜 :=\n  u.val.inner_map_map_of_mem_unitary u.property x y\n\n"}
{"name":"unitary.linearIsometryEquiv_coe_apply","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\ninst✝³ : RCLike 𝕜\nH : Type u_5\ninst✝² : NormedAddCommGroup H\ninst✝¹ : InnerProductSpace 𝕜 H\ninst✝ : CompleteSpace H\nu : Subtype fun x => Membership.mem (unitary (ContinuousLinearMap (RingHom.id 𝕜) H H)) x\n⊢ Eq ↑{ toLinearEquiv := (unitary.linearIsometryEquiv u).toLinearEquiv, continuous_toFun := ⋯, continuous_invFun := ⋯ } ↑u","decl":"@[simp]\nlemma linearIsometryEquiv_coe_apply (u : unitary (H →L[𝕜] H)) :\n    linearIsometryEquiv u = (u : H →L[𝕜] H) :=\n  rfl\n\n"}
{"name":"unitary.linearIsometryEquiv_coe_symm_apply","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\ninst✝³ : RCLike 𝕜\nH : Type u_5\ninst✝² : NormedAddCommGroup H\ninst✝¹ : InnerProductSpace 𝕜 H\ninst✝ : CompleteSpace H\ne : LinearIsometryEquiv (RingHom.id 𝕜) H H\n⊢ Eq ↑(unitary.linearIsometryEquiv.symm e) ↑{ toLinearEquiv := e.toLinearEquiv, continuous_toFun := ⋯, continuous_invFun := ⋯ }","decl":"@[simp]\nlemma linearIsometryEquiv_coe_symm_apply (e : H ≃ₗᵢ[𝕜] H) :\n    linearIsometryEquiv.symm e = (e : H →L[𝕜] H) :=\n  rfl\n\n"}
{"name":"Matrix.toLin_conjTranspose","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝¹⁰ : RCLike 𝕜\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedAddCommGroup F\ninst✝⁷ : InnerProductSpace 𝕜 E\ninst✝⁶ : InnerProductSpace 𝕜 F\nm : Type u_5\nn : Type u_6\ninst✝⁵ : Fintype m\ninst✝⁴ : DecidableEq m\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\ninst✝¹ : FiniteDimensional 𝕜 E\ninst✝ : FiniteDimensional 𝕜 F\nv₁ : OrthonormalBasis n 𝕜 E\nv₂ : OrthonormalBasis m 𝕜 F\nA : Matrix m n 𝕜\n⊢ Eq ((Matrix.toLin v₂.toBasis v₁.toBasis) A.conjTranspose) (LinearMap.adjoint ((Matrix.toLin v₁.toBasis v₂.toBasis) A))","decl":"/-- The linear map associated to the conjugate transpose of a matrix corresponding to two\northonormal bases is the adjoint of the linear map associated to the matrix. -/\nlemma Matrix.toLin_conjTranspose (A : Matrix m n 𝕜) :\n    toLin v₂.toBasis v₁.toBasis Aᴴ = adjoint (toLin v₁.toBasis v₂.toBasis A) := by\n  refine eq_adjoint_iff_basis v₂.toBasis v₁.toBasis _ _ |>.mpr fun i j ↦ ?_\n  simp_rw [toLin_self]\n  simp [sum_inner, inner_smul_left, inner_sum, inner_smul_right,\n    orthonormal_iff_ite.mp v₁.orthonormal, orthonormal_iff_ite.mp v₂.orthonormal]\n\n"}
{"name":"LinearMap.toMatrix_adjoint","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝¹⁰ : RCLike 𝕜\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedAddCommGroup F\ninst✝⁷ : InnerProductSpace 𝕜 E\ninst✝⁶ : InnerProductSpace 𝕜 F\nm : Type u_5\nn : Type u_6\ninst✝⁵ : Fintype m\ninst✝⁴ : DecidableEq m\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\ninst✝¹ : FiniteDimensional 𝕜 E\ninst✝ : FiniteDimensional 𝕜 F\nv₁ : OrthonormalBasis n 𝕜 E\nv₂ : OrthonormalBasis m 𝕜 F\nf : LinearMap (RingHom.id 𝕜) E F\n⊢ Eq ((LinearMap.toMatrix v₂.toBasis v₁.toBasis) (LinearMap.adjoint f)) ((LinearMap.toMatrix v₁.toBasis v₂.toBasis) f).conjTranspose","decl":"/-- The matrix associated to the adjoint of a linear map corresponding to two orthonormal bases\nis the conjugate transpose of the matrix associated to the linear map. -/\nlemma LinearMap.toMatrix_adjoint (f : E →ₗ[𝕜] F) :\n    toMatrix v₂.toBasis v₁.toBasis (adjoint f) = (toMatrix v₁.toBasis v₂.toBasis f)ᴴ :=\n  toLin v₂.toBasis v₁.toBasis |>.injective <| by simp [toLin_conjTranspose]\n\n"}
{"name":"LinearMap.toMatrixOrthonormal_symm_apply","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁵ : RCLike 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : InnerProductSpace 𝕜 E\nn : Type u_6\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : FiniteDimensional 𝕜 E\nv₁ : OrthonormalBasis n 𝕜 E\na✝ : Matrix n n 𝕜\n⊢ Eq ((LinearMap.toMatrixOrthonormal v₁).symm a✝) ((LinearMap.toMatrix v₁.toBasis v₁.toBasis).invFun a✝)","decl":"/-- The star algebra equivalence between the linear endomorphisms of finite-dimensional inner\nproduct space and square matrices induced by the choice of an orthonormal basis. -/\n@[simps]\ndef LinearMap.toMatrixOrthonormal : (E →ₗ[𝕜] E) ≃⋆ₐ[𝕜] Matrix n n 𝕜 :=\n  { LinearMap.toMatrix v₁.toBasis v₁.toBasis with\n    map_mul' := LinearMap.toMatrix_mul v₁.toBasis\n    map_star' := LinearMap.toMatrix_adjoint v₁ v₁ }\n\n"}
{"name":"LinearMap.toMatrixOrthonormal_apply","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁵ : RCLike 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : InnerProductSpace 𝕜 E\nn : Type u_6\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : FiniteDimensional 𝕜 E\nv₁ : OrthonormalBasis n 𝕜 E\na✝ : LinearMap (RingHom.id 𝕜) E E\n⊢ Eq ((LinearMap.toMatrixOrthonormal v₁) a✝) ((↑(LinearMap.toMatrix v₁.toBasis v₁.toBasis)).toFun a✝)","decl":"/-- The star algebra equivalence between the linear endomorphisms of finite-dimensional inner\nproduct space and square matrices induced by the choice of an orthonormal basis. -/\n@[simps]\ndef LinearMap.toMatrixOrthonormal : (E →ₗ[𝕜] E) ≃⋆ₐ[𝕜] Matrix n n 𝕜 :=\n  { LinearMap.toMatrix v₁.toBasis v₁.toBasis with\n    map_mul' := LinearMap.toMatrix_mul v₁.toBasis\n    map_star' := LinearMap.toMatrix_adjoint v₁ v₁ }\n\n"}
{"name":"Matrix.toEuclideanLin_conjTranspose_eq_adjoint","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : RCLike 𝕜\nm : Type u_5\nn : Type u_6\ninst✝³ : Fintype m\ninst✝² : DecidableEq m\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nA : Matrix m n 𝕜\n⊢ Eq (Matrix.toEuclideanLin A.conjTranspose) (LinearMap.adjoint (Matrix.toEuclideanLin A))","decl":"/-- The adjoint of the linear map associated to a matrix is the linear map associated to the\nconjugate transpose of that matrix. -/\ntheorem Matrix.toEuclideanLin_conjTranspose_eq_adjoint (A : Matrix m n 𝕜) :\n    Matrix.toEuclideanLin A.conjTranspose = LinearMap.adjoint (Matrix.toEuclideanLin A) :=\n  A.toLin_conjTranspose (EuclideanSpace.basisFun n 𝕜) (EuclideanSpace.basisFun m 𝕜)\n\n"}
