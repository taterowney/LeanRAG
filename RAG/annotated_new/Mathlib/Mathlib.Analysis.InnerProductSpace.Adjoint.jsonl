{"name":"ContinuousLinearMap.adjointAux_apply","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâµ : RCLike ğ•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : InnerProductSpace ğ•œ E\ninstâœÂ¹ : InnerProductSpace ğ•œ F\ninstâœ : CompleteSpace E\nA : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : F\nâŠ¢ Eq ((ContinuousLinearMap.adjointAux A) x) ((InnerProductSpace.toDual ğ•œ E).symm ((ContinuousLinearMap.toSesqForm A) x))","decl":"@[simp]\ntheorem adjointAux_apply (A : E â†’L[ğ•œ] F) (x : F) :\n    adjointAux A x = ((toDual ğ•œ E).symm : NormedSpace.Dual ğ•œ E â†’ E) ((toSesqForm A) x) :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.adjointAux_inner_left","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâµ : RCLike ğ•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : InnerProductSpace ğ•œ E\ninstâœÂ¹ : InnerProductSpace ğ•œ F\ninstâœ : CompleteSpace E\nA : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\ny : F\nâŠ¢ Eq (Inner.inner ((ContinuousLinearMap.adjointAux A) y) x) (Inner.inner y (A x))","decl":"theorem adjointAux_inner_left (A : E â†’L[ğ•œ] F) (x : E) (y : F) : âŸªadjointAux A y, xâŸ« = âŸªy, A xâŸ« := by\n  rw [adjointAux_apply, toDual_symm_apply, toSesqForm_apply_coe, coe_comp', innerSL_apply_coe,\n    Function.comp_apply]\n\n"}
{"name":"ContinuousLinearMap.adjointAux_inner_right","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâµ : RCLike ğ•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : InnerProductSpace ğ•œ E\ninstâœÂ¹ : InnerProductSpace ğ•œ F\ninstâœ : CompleteSpace E\nA : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\ny : F\nâŠ¢ Eq (Inner.inner x ((ContinuousLinearMap.adjointAux A) y)) (Inner.inner (A x) y)","decl":"theorem adjointAux_inner_right (A : E â†’L[ğ•œ] F) (x : E) (y : F) :\n    âŸªx, adjointAux A yâŸ« = âŸªA x, yâŸ« := by\n  rw [â† inner_conj_symm, adjointAux_inner_left, inner_conj_symm]\n\n"}
{"name":"ContinuousLinearMap.adjointAux_adjointAux","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ¶ : RCLike ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : InnerProductSpace ğ•œ E\ninstâœÂ² : InnerProductSpace ğ•œ F\ninstâœÂ¹ : CompleteSpace E\ninstâœ : CompleteSpace F\nA : ContinuousLinearMap (RingHom.id ğ•œ) E F\nâŠ¢ Eq (ContinuousLinearMap.adjointAux (ContinuousLinearMap.adjointAux A)) A","decl":"theorem adjointAux_adjointAux (A : E â†’L[ğ•œ] F) : adjointAux (adjointAux A) = A := by\n  ext v\n  refine ext_inner_left ğ•œ fun w => ?_\n  rw [adjointAux_inner_right, adjointAux_inner_left]\n\n"}
{"name":"ContinuousLinearMap.adjointAux_norm","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ¶ : RCLike ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : InnerProductSpace ğ•œ E\ninstâœÂ² : InnerProductSpace ğ•œ F\ninstâœÂ¹ : CompleteSpace E\ninstâœ : CompleteSpace F\nA : ContinuousLinearMap (RingHom.id ğ•œ) E F\nâŠ¢ Eq (Norm.norm (ContinuousLinearMap.adjointAux A)) (Norm.norm A)","decl":"@[simp]\ntheorem adjointAux_norm (A : E â†’L[ğ•œ] F) : â€–adjointAux Aâ€– = â€–Aâ€– := by\n  refine le_antisymm ?_ ?_\n  Â· refine ContinuousLinearMap.opNorm_le_bound _ (norm_nonneg _) fun x => ?_\n    rw [adjointAux_apply, LinearIsometryEquiv.norm_map]\n    exact toSesqForm_apply_norm_le\n  Â· nth_rw 1 [â† adjointAux_adjointAux A]\n    refine ContinuousLinearMap.opNorm_le_bound _ (norm_nonneg _) fun x => ?_\n    rw [adjointAux_apply, LinearIsometryEquiv.norm_map]\n    exact toSesqForm_apply_norm_le\n\n"}
{"name":"ContinuousLinearMap.adjoint_inner_left","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ¶ : RCLike ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : InnerProductSpace ğ•œ E\ninstâœÂ² : InnerProductSpace ğ•œ F\ninstâœÂ¹ : CompleteSpace E\ninstâœ : CompleteSpace F\nA : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\ny : F\nâŠ¢ Eq (Inner.inner ((ContinuousLinearMap.adjoint A) y) x) (Inner.inner y (A x))","decl":"/-- The fundamental property of the adjoint. -/\ntheorem adjoint_inner_left (A : E â†’L[ğ•œ] F) (x : E) (y : F) : âŸª(Aâ€ ) y, xâŸ« = âŸªy, A xâŸ« :=\n  adjointAux_inner_left A x y\n\n"}
{"name":"ContinuousLinearMap.adjoint_inner_right","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ¶ : RCLike ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : InnerProductSpace ğ•œ E\ninstâœÂ² : InnerProductSpace ğ•œ F\ninstâœÂ¹ : CompleteSpace E\ninstâœ : CompleteSpace F\nA : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\ny : F\nâŠ¢ Eq (Inner.inner x ((ContinuousLinearMap.adjoint A) y)) (Inner.inner (A x) y)","decl":"/-- The fundamental property of the adjoint. -/\ntheorem adjoint_inner_right (A : E â†’L[ğ•œ] F) (x : E) (y : F) : âŸªx, (Aâ€ ) yâŸ« = âŸªA x, yâŸ« :=\n  adjointAux_inner_right A x y\n\n"}
{"name":"ContinuousLinearMap.adjoint_adjoint","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ¶ : RCLike ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : InnerProductSpace ğ•œ E\ninstâœÂ² : InnerProductSpace ğ•œ F\ninstâœÂ¹ : CompleteSpace E\ninstâœ : CompleteSpace F\nA : ContinuousLinearMap (RingHom.id ğ•œ) E F\nâŠ¢ Eq (ContinuousLinearMap.adjoint (ContinuousLinearMap.adjoint A)) A","decl":"/-- The adjoint is involutive. -/\n@[simp]\ntheorem adjoint_adjoint (A : E â†’L[ğ•œ] F) : Aâ€ â€  = A :=\n  adjointAux_adjointAux A\n\n"}
{"name":"ContinuousLinearMap.adjoint_comp","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninstâœâ¹ : RCLike ğ•œ\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedAddCommGroup F\ninstâœâ¶ : NormedAddCommGroup G\ninstâœâµ : InnerProductSpace ğ•œ E\ninstâœâ´ : InnerProductSpace ğ•œ F\ninstâœÂ³ : InnerProductSpace ğ•œ G\ninstâœÂ² : CompleteSpace E\ninstâœÂ¹ : CompleteSpace G\ninstâœ : CompleteSpace F\nA : ContinuousLinearMap (RingHom.id ğ•œ) F G\nB : ContinuousLinearMap (RingHom.id ğ•œ) E F\nâŠ¢ Eq (ContinuousLinearMap.adjoint (A.comp B)) ((ContinuousLinearMap.adjoint B).comp (ContinuousLinearMap.adjoint A))","decl":"/-- The adjoint of the composition of two operators is the composition of the two adjoints\nin reverse order. -/\n@[simp]\ntheorem adjoint_comp (A : F â†’L[ğ•œ] G) (B : E â†’L[ğ•œ] F) : (A âˆ˜L B)â€  = Bâ€  âˆ˜L Aâ€  := by\n  ext v\n  refine ext_inner_left ğ•œ fun w => ?_\n  simp only [adjoint_inner_right, ContinuousLinearMap.coe_comp', Function.comp_apply]\n\n"}
{"name":"ContinuousLinearMap.apply_norm_sq_eq_inner_adjoint_left","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ¶ : RCLike ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : InnerProductSpace ğ•œ E\ninstâœÂ² : InnerProductSpace ğ•œ F\ninstâœÂ¹ : CompleteSpace E\ninstâœ : CompleteSpace F\nA : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\nâŠ¢ Eq (HPow.hPow (Norm.norm (A x)) 2) (RCLike.re (Inner.inner (((ContinuousLinearMap.adjoint A).comp A) x) x))","decl":"theorem apply_norm_sq_eq_inner_adjoint_left (A : E â†’L[ğ•œ] F) (x : E) :\n    â€–A xâ€– ^ 2 = re âŸª(Aâ€  âˆ˜L A) x, xâŸ« := by\n  have h : âŸª(Aâ€  âˆ˜L A) x, xâŸ« = âŸªA x, A xâŸ« := by rw [â† adjoint_inner_left]; rfl\n  rw [h, â† inner_self_eq_norm_sq (ğ•œ := ğ•œ) _]\n\n"}
{"name":"ContinuousLinearMap.apply_norm_eq_sqrt_inner_adjoint_left","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ¶ : RCLike ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : InnerProductSpace ğ•œ E\ninstâœÂ² : InnerProductSpace ğ•œ F\ninstâœÂ¹ : CompleteSpace E\ninstâœ : CompleteSpace F\nA : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\nâŠ¢ Eq (Norm.norm (A x)) (RCLike.re (Inner.inner (((ContinuousLinearMap.adjoint A).comp A) x) x)).sqrt","decl":"theorem apply_norm_eq_sqrt_inner_adjoint_left (A : E â†’L[ğ•œ] F) (x : E) :\n    â€–A xâ€– = âˆš(re âŸª(Aâ€  âˆ˜L A) x, xâŸ«) := by\n  rw [â† apply_norm_sq_eq_inner_adjoint_left, Real.sqrt_sq (norm_nonneg _)]\n\n"}
{"name":"ContinuousLinearMap.apply_norm_sq_eq_inner_adjoint_right","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ¶ : RCLike ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : InnerProductSpace ğ•œ E\ninstâœÂ² : InnerProductSpace ğ•œ F\ninstâœÂ¹ : CompleteSpace E\ninstâœ : CompleteSpace F\nA : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\nâŠ¢ Eq (HPow.hPow (Norm.norm (A x)) 2) (RCLike.re (Inner.inner x (((ContinuousLinearMap.adjoint A).comp A) x)))","decl":"theorem apply_norm_sq_eq_inner_adjoint_right (A : E â†’L[ğ•œ] F) (x : E) :\n    â€–A xâ€– ^ 2 = re âŸªx, (Aâ€  âˆ˜L A) xâŸ« := by\n  have h : âŸªx, (Aâ€  âˆ˜L A) xâŸ« = âŸªA x, A xâŸ« := by rw [â† adjoint_inner_right]; rfl\n  rw [h, â† inner_self_eq_norm_sq (ğ•œ := ğ•œ) _]\n\n"}
{"name":"ContinuousLinearMap.apply_norm_eq_sqrt_inner_adjoint_right","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ¶ : RCLike ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : InnerProductSpace ğ•œ E\ninstâœÂ² : InnerProductSpace ğ•œ F\ninstâœÂ¹ : CompleteSpace E\ninstâœ : CompleteSpace F\nA : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\nâŠ¢ Eq (Norm.norm (A x)) (RCLike.re (Inner.inner x (((ContinuousLinearMap.adjoint A).comp A) x))).sqrt","decl":"theorem apply_norm_eq_sqrt_inner_adjoint_right (A : E â†’L[ğ•œ] F) (x : E) :\n    â€–A xâ€– = âˆš(re âŸªx, (Aâ€  âˆ˜L A) xâŸ«) := by\n  rw [â† apply_norm_sq_eq_inner_adjoint_right, Real.sqrt_sq (norm_nonneg _)]\n\n"}
{"name":"ContinuousLinearMap.eq_adjoint_iff","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ¶ : RCLike ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : InnerProductSpace ğ•œ E\ninstâœÂ² : InnerProductSpace ğ•œ F\ninstâœÂ¹ : CompleteSpace E\ninstâœ : CompleteSpace F\nA : ContinuousLinearMap (RingHom.id ğ•œ) E F\nB : ContinuousLinearMap (RingHom.id ğ•œ) F E\nâŠ¢ Iff (Eq A (ContinuousLinearMap.adjoint B)) (âˆ€ (x : E) (y : F), Eq (Inner.inner (A x) y) (Inner.inner x (B y)))","decl":"/-- The adjoint is unique: a map `A` is the adjoint of `B` iff it satisfies `âŸªA x, yâŸ« = âŸªx, B yâŸ«`\nfor all `x` and `y`. -/\ntheorem eq_adjoint_iff (A : E â†’L[ğ•œ] F) (B : F â†’L[ğ•œ] E) : A = Bâ€  â†” âˆ€ x y, âŸªA x, yâŸ« = âŸªx, B yâŸ« := by\n  refine âŸ¨fun h x y => by rw [h, adjoint_inner_left], fun h => ?_âŸ©\n  ext x\n  exact ext_inner_right ğ•œ fun y => by simp only [adjoint_inner_left, h x y]\n\n"}
{"name":"ContinuousLinearMap.adjoint_id","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : CompleteSpace E\nâŠ¢ Eq (ContinuousLinearMap.adjoint (ContinuousLinearMap.id ğ•œ E)) (ContinuousLinearMap.id ğ•œ E)","decl":"@[simp]\ntheorem adjoint_id :\n    ContinuousLinearMap.adjoint (ContinuousLinearMap.id ğ•œ E) = ContinuousLinearMap.id ğ•œ E := by\n  refine Eq.symm ?_\n  rw [eq_adjoint_iff]\n  simp\n\n"}
{"name":"Submodule.adjoint_subtypeL","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : RCLike ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\ninstâœÂ¹ : CompleteSpace E\nU : Submodule ğ•œ E\ninstâœ : CompleteSpace (Subtype fun x => Membership.mem U x)\nâŠ¢ Eq (ContinuousLinearMap.adjoint U.subtypeL) (orthogonalProjection U)","decl":"theorem _root_.Submodule.adjoint_subtypeL (U : Submodule ğ•œ E) [CompleteSpace U] :\n    U.subtypeLâ€  = orthogonalProjection U := by\n  symm\n  rw [eq_adjoint_iff]\n  intro x u\n  rw [U.coe_inner, inner_orthogonalProjection_left_eq_right,\n    orthogonalProjection_mem_subspace_eq_self]\n  rfl\n\n"}
{"name":"Submodule.adjoint_orthogonalProjection","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : RCLike ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\ninstâœÂ¹ : CompleteSpace E\nU : Submodule ğ•œ E\ninstâœ : CompleteSpace (Subtype fun x => Membership.mem U x)\nâŠ¢ Eq (ContinuousLinearMap.adjoint (orthogonalProjection U)) U.subtypeL","decl":"theorem _root_.Submodule.adjoint_orthogonalProjection (U : Submodule ğ•œ E) [CompleteSpace U] :\n    (orthogonalProjection U : E â†’L[ğ•œ] U)â€  = U.subtypeL := by\n  rw [â† U.adjoint_subtypeL, adjoint_adjoint]\n\n"}
{"name":"ContinuousLinearMap.instStarModuleId","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : CompleteSpace E\nâŠ¢ StarModule ğ•œ (ContinuousLinearMap (RingHom.id ğ•œ) E E)","decl":"instance : StarModule ğ•œ (E â†’L[ğ•œ] E) :=\n  âŸ¨LinearIsometryEquiv.map_smulâ‚›â‚— adjointâŸ©\n\n"}
{"name":"ContinuousLinearMap.star_eq_adjoint","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : CompleteSpace E\nA : ContinuousLinearMap (RingHom.id ğ•œ) E E\nâŠ¢ Eq (Star.star A) (ContinuousLinearMap.adjoint A)","decl":"theorem star_eq_adjoint (A : E â†’L[ğ•œ] E) : star A = Aâ€  :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.isSelfAdjoint_iff'","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : CompleteSpace E\nA : ContinuousLinearMap (RingHom.id ğ•œ) E E\nâŠ¢ Iff (IsSelfAdjoint A) (Eq (ContinuousLinearMap.adjoint A) A)","decl":"/-- A continuous linear operator is self-adjoint iff it is equal to its adjoint. -/\ntheorem isSelfAdjoint_iff' {A : E â†’L[ğ•œ] E} : IsSelfAdjoint A â†” ContinuousLinearMap.adjoint A = A :=\n  Iff.rfl\n\n"}
{"name":"ContinuousLinearMap.norm_adjoint_comp_self","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ¶ : RCLike ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : InnerProductSpace ğ•œ E\ninstâœÂ² : InnerProductSpace ğ•œ F\ninstâœÂ¹ : CompleteSpace E\ninstâœ : CompleteSpace F\nA : ContinuousLinearMap (RingHom.id ğ•œ) E F\nâŠ¢ Eq (Norm.norm ((ContinuousLinearMap.adjoint A).comp A)) (HMul.hMul (Norm.norm A) (Norm.norm A))","decl":"theorem norm_adjoint_comp_self (A : E â†’L[ğ•œ] F) :\n    â€–ContinuousLinearMap.adjoint A âˆ˜L Aâ€– = â€–Aâ€– * â€–Aâ€– := by\n  refine le_antisymm ?_ ?_\n  Â· calc\n      â€–Aâ€  âˆ˜L Aâ€– â‰¤ â€–Aâ€ â€– * â€–Aâ€– := opNorm_comp_le _ _\n      _ = â€–Aâ€– * â€–Aâ€– := by rw [LinearIsometryEquiv.norm_map]\n  Â· rw [â† sq, â† Real.sqrt_le_sqrt_iff (norm_nonneg _), Real.sqrt_sq (norm_nonneg _)]\n    refine opNorm_le_bound _ (Real.sqrt_nonneg _) fun x => ?_\n    have :=\n      calc\n        re âŸª(Aâ€  âˆ˜L A) x, xâŸ« â‰¤ â€–(Aâ€  âˆ˜L A) xâ€– * â€–xâ€– := re_inner_le_norm _ _\n        _ â‰¤ â€–Aâ€  âˆ˜L Aâ€– * â€–xâ€– * â€–xâ€– := mul_le_mul_of_nonneg_right (le_opNorm _ _) (norm_nonneg _)\n    calc\n      â€–A xâ€– = âˆš(re âŸª(Aâ€  âˆ˜L A) x, xâŸ«) := by rw [apply_norm_eq_sqrt_inner_adjoint_left]\n      _ â‰¤ âˆš(â€–Aâ€  âˆ˜L Aâ€– * â€–xâ€– * â€–xâ€–) := Real.sqrt_le_sqrt this\n      _ = âˆšâ€–Aâ€  âˆ˜L Aâ€– * â€–xâ€– := by\n        simp_rw [mul_assoc, Real.sqrt_mul (norm_nonneg _) (â€–xâ€– * â€–xâ€–),\n          Real.sqrt_mul_self (norm_nonneg x)]\n\n"}
{"name":"ContinuousLinearMap.instCStarRingId","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : CompleteSpace E\nâŠ¢ CStarRing (ContinuousLinearMap (RingHom.id ğ•œ) E E)","decl":"/-- The Câ‹†-algebra instance when `ğ•œ := â„‚` can be found in\n`Analysis.CStarAlgebra.ContinuousLinearMap`. -/\ninstance : CStarRing (E â†’L[ğ•œ] E) where\n  norm_mul_self_le x := le_of_eq <| Eq.symm <| norm_adjoint_comp_self x\n\n"}
{"name":"ContinuousLinearMap.isAdjointPair_inner","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ¶ : RCLike ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : InnerProductSpace ğ•œ E\ninstâœÂ² : InnerProductSpace ğ•œ F\ninstâœÂ¹ : CompleteSpace E\ninstâœ : CompleteSpace F\nA : ContinuousLinearMap (RingHom.id ğ•œ) E F\nâŠ¢ sesqFormOfInner.IsAdjointPair sesqFormOfInner â‡‘A â‡‘(ContinuousLinearMap.adjoint A)","decl":"theorem isAdjointPair_inner (A : E â†’L[ğ•œ] F) :\n    LinearMap.IsAdjointPair (sesqFormOfInner : E â†’â‚—[ğ•œ] E â†’â‚—â‹†[ğ•œ] ğ•œ)\n      (sesqFormOfInner : F â†’â‚—[ğ•œ] F â†’â‚—â‹†[ğ•œ] ğ•œ) A (Aâ€ ) := by\n  intro x y\n  simp only [sesqFormOfInner_apply_apply, adjoint_inner_left, coe_coe]\n\n"}
{"name":"IsSelfAdjoint.adjoint_eq","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : CompleteSpace E\nA : ContinuousLinearMap (RingHom.id ğ•œ) E E\nhA : IsSelfAdjoint A\nâŠ¢ Eq (ContinuousLinearMap.adjoint A) A","decl":"theorem adjoint_eq {A : E â†’L[ğ•œ] E} (hA : IsSelfAdjoint A) : ContinuousLinearMap.adjoint A = A :=\n  hA\n\n"}
{"name":"IsSelfAdjoint.isSymmetric","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : CompleteSpace E\nA : ContinuousLinearMap (RingHom.id ğ•œ) E E\nhA : IsSelfAdjoint A\nâŠ¢ (â†‘A).IsSymmetric","decl":"/-- Every self-adjoint operator on an inner product space is symmetric. -/\ntheorem isSymmetric {A : E â†’L[ğ•œ] E} (hA : IsSelfAdjoint A) : (A : E â†’â‚—[ğ•œ] E).IsSymmetric := by\n  intro x y\n  rw_mod_cast [â† A.adjoint_inner_right, hA.adjoint_eq]\n\n"}
{"name":"IsSelfAdjoint.conj_adjoint","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ¶ : RCLike ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : InnerProductSpace ğ•œ E\ninstâœÂ² : InnerProductSpace ğ•œ F\ninstâœÂ¹ : CompleteSpace E\ninstâœ : CompleteSpace F\nT : ContinuousLinearMap (RingHom.id ğ•œ) E E\nhT : IsSelfAdjoint T\nS : ContinuousLinearMap (RingHom.id ğ•œ) E F\nâŠ¢ IsSelfAdjoint (S.comp (T.comp (ContinuousLinearMap.adjoint S)))","decl":"/-- Conjugating preserves self-adjointness. -/\ntheorem conj_adjoint {T : E â†’L[ğ•œ] E} (hT : IsSelfAdjoint T) (S : E â†’L[ğ•œ] F) :\n    IsSelfAdjoint (S âˆ˜L T âˆ˜L ContinuousLinearMap.adjoint S) := by\n  rw [isSelfAdjoint_iff'] at hT âŠ¢\n  simp only [hT, adjoint_comp, adjoint_adjoint]\n  exact ContinuousLinearMap.comp_assoc _ _ _\n\n"}
{"name":"IsSelfAdjoint.adjoint_conj","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ¶ : RCLike ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : InnerProductSpace ğ•œ E\ninstâœÂ² : InnerProductSpace ğ•œ F\ninstâœÂ¹ : CompleteSpace E\ninstâœ : CompleteSpace F\nT : ContinuousLinearMap (RingHom.id ğ•œ) E E\nhT : IsSelfAdjoint T\nS : ContinuousLinearMap (RingHom.id ğ•œ) F E\nâŠ¢ IsSelfAdjoint ((ContinuousLinearMap.adjoint S).comp (T.comp S))","decl":"/-- Conjugating preserves self-adjointness. -/\ntheorem adjoint_conj {T : E â†’L[ğ•œ] E} (hT : IsSelfAdjoint T) (S : F â†’L[ğ•œ] E) :\n    IsSelfAdjoint (ContinuousLinearMap.adjoint S âˆ˜L T âˆ˜L S) := by\n  rw [isSelfAdjoint_iff'] at hT âŠ¢\n  simp only [hT, adjoint_comp, adjoint_adjoint]\n  exact ContinuousLinearMap.comp_assoc _ _ _\n\n"}
{"name":"ContinuousLinearMap.isSelfAdjoint_iff_isSymmetric","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : CompleteSpace E\nA : ContinuousLinearMap (RingHom.id ğ•œ) E E\nâŠ¢ Iff (IsSelfAdjoint A) (â†‘A).IsSymmetric","decl":"theorem _root_.ContinuousLinearMap.isSelfAdjoint_iff_isSymmetric {A : E â†’L[ğ•œ] E} :\n    IsSelfAdjoint A â†” (A : E â†’â‚—[ğ•œ] E).IsSymmetric :=\n  âŸ¨fun hA => hA.isSymmetric, fun hA =>\n    ext fun x => ext_inner_right ğ•œ fun y => (A.adjoint_inner_left y x).symm â–¸ (hA x y).symmâŸ©\n\n"}
{"name":"LinearMap.IsSymmetric.isSelfAdjoint","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : CompleteSpace E\nA : ContinuousLinearMap (RingHom.id ğ•œ) E E\nhA : (â†‘A).IsSymmetric\nâŠ¢ IsSelfAdjoint A","decl":"theorem _root_.LinearMap.IsSymmetric.isSelfAdjoint {A : E â†’L[ğ•œ] E}\n    (hA : (A : E â†’â‚—[ğ•œ] E).IsSymmetric) : IsSelfAdjoint A := by\n  rwa [â† ContinuousLinearMap.isSelfAdjoint_iff_isSymmetric] at hA\n\n"}
{"name":"orthogonalProjection_isSelfAdjoint","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : RCLike ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\ninstâœÂ¹ : CompleteSpace E\nU : Submodule ğ•œ E\ninstâœ : CompleteSpace (Subtype fun x => Membership.mem U x)\nâŠ¢ IsSelfAdjoint (U.subtypeL.comp (orthogonalProjection U))","decl":"/-- The orthogonal projection is self-adjoint. -/\ntheorem _root_.orthogonalProjection_isSelfAdjoint (U : Submodule ğ•œ E) [CompleteSpace U] :\n    IsSelfAdjoint (U.subtypeL âˆ˜L orthogonalProjection U) :=\n  (orthogonalProjection_isSymmetric U).isSelfAdjoint\n\n"}
{"name":"IsSelfAdjoint.conj_orthogonalProjection","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : RCLike ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\ninstâœÂ¹ : CompleteSpace E\nT : ContinuousLinearMap (RingHom.id ğ•œ) E E\nhT : IsSelfAdjoint T\nU : Submodule ğ•œ E\ninstâœ : CompleteSpace (Subtype fun x => Membership.mem U x)\nâŠ¢ IsSelfAdjoint (U.subtypeL.comp ((orthogonalProjection U).comp (T.comp (U.subtypeL.comp (orthogonalProjection U)))))","decl":"theorem conj_orthogonalProjection {T : E â†’L[ğ•œ] E} (hT : IsSelfAdjoint T) (U : Submodule ğ•œ E)\n    [CompleteSpace U] :\n    IsSelfAdjoint\n      (U.subtypeL âˆ˜L orthogonalProjection U âˆ˜L T âˆ˜L U.subtypeL âˆ˜L orthogonalProjection U) := by\n  rw [â† ContinuousLinearMap.comp_assoc]\n  nth_rw 1 [â† (orthogonalProjection_isSelfAdjoint U).adjoint_eq]\n  exact hT.adjoint_conj _\n\n"}
{"name":"LinearMap.IsSymmetric.coe_toSelfAdjoint","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : CompleteSpace E\nT : LinearMap (RingHom.id ğ•œ) E E\nhT : T.IsSymmetric\nâŠ¢ Eq (â†‘â†‘hT.toSelfAdjoint) T","decl":"theorem IsSymmetric.coe_toSelfAdjoint (hT : IsSymmetric T) : (hT.toSelfAdjoint : E â†’â‚—[ğ•œ] E) = T :=\n  rfl\n\n"}
{"name":"LinearMap.IsSymmetric.toSelfAdjoint_apply","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : CompleteSpace E\nT : LinearMap (RingHom.id ğ•œ) E E\nhT : T.IsSymmetric\nx : E\nâŠ¢ Eq (â†‘hT.toSelfAdjoint x) (T x)","decl":"theorem IsSymmetric.toSelfAdjoint_apply (hT : IsSymmetric T) {x : E} :\n    (hT.toSelfAdjoint : E â†’ E) x = T x :=\n  rfl\n\n"}
{"name":"LinearMap.adjoint_toContinuousLinearMap","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ¶ : RCLike ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : InnerProductSpace ğ•œ E\ninstâœÂ² : InnerProductSpace ğ•œ F\ninstâœÂ¹ : FiniteDimensional ğ•œ E\ninstâœ : FiniteDimensional ğ•œ F\nA : LinearMap (RingHom.id ğ•œ) E F\nâŠ¢ Eq (LinearMap.toContinuousLinearMap (LinearMap.adjoint A)) (ContinuousLinearMap.adjoint (LinearMap.toContinuousLinearMap A))","decl":"theorem adjoint_toContinuousLinearMap (A : E â†’â‚—[ğ•œ] F) :\n    haveI := FiniteDimensional.complete ğ•œ E\n    haveI := FiniteDimensional.complete ğ•œ F\n    LinearMap.toContinuousLinearMap (LinearMap.adjoint A) =\n      ContinuousLinearMap.adjoint (LinearMap.toContinuousLinearMap A) :=\n  rfl\n\n"}
{"name":"LinearMap.adjoint_eq_toCLM_adjoint","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ¶ : RCLike ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : InnerProductSpace ğ•œ E\ninstâœÂ² : InnerProductSpace ğ•œ F\ninstâœÂ¹ : FiniteDimensional ğ•œ E\ninstâœ : FiniteDimensional ğ•œ F\nA : LinearMap (RingHom.id ğ•œ) E F\nâŠ¢ Eq (LinearMap.adjoint A) â†‘(ContinuousLinearMap.adjoint (LinearMap.toContinuousLinearMap A))","decl":"theorem adjoint_eq_toCLM_adjoint (A : E â†’â‚—[ğ•œ] F) :\n    haveI := FiniteDimensional.complete ğ•œ E\n    haveI := FiniteDimensional.complete ğ•œ F\n    LinearMap.adjoint A = ContinuousLinearMap.adjoint (LinearMap.toContinuousLinearMap A) :=\n  rfl\n\n"}
{"name":"LinearMap.adjoint_inner_left","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ¶ : RCLike ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : InnerProductSpace ğ•œ E\ninstâœÂ² : InnerProductSpace ğ•œ F\ninstâœÂ¹ : FiniteDimensional ğ•œ E\ninstâœ : FiniteDimensional ğ•œ F\nA : LinearMap (RingHom.id ğ•œ) E F\nx : E\ny : F\nâŠ¢ Eq (Inner.inner ((LinearMap.adjoint A) y) x) (Inner.inner y (A x))","decl":"/-- The fundamental property of the adjoint. -/\ntheorem adjoint_inner_left (A : E â†’â‚—[ğ•œ] F) (x : E) (y : F) : âŸªadjoint A y, xâŸ« = âŸªy, A xâŸ« := by\n  haveI := FiniteDimensional.complete ğ•œ E\n  haveI := FiniteDimensional.complete ğ•œ F\n  rw [â† coe_toContinuousLinearMap A, adjoint_eq_toCLM_adjoint]\n  exact ContinuousLinearMap.adjoint_inner_left _ x y\n\n"}
{"name":"LinearMap.adjoint_inner_right","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ¶ : RCLike ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : InnerProductSpace ğ•œ E\ninstâœÂ² : InnerProductSpace ğ•œ F\ninstâœÂ¹ : FiniteDimensional ğ•œ E\ninstâœ : FiniteDimensional ğ•œ F\nA : LinearMap (RingHom.id ğ•œ) E F\nx : E\ny : F\nâŠ¢ Eq (Inner.inner x ((LinearMap.adjoint A) y)) (Inner.inner (A x) y)","decl":"/-- The fundamental property of the adjoint. -/\ntheorem adjoint_inner_right (A : E â†’â‚—[ğ•œ] F) (x : E) (y : F) : âŸªx, adjoint A yâŸ« = âŸªA x, yâŸ« := by\n  haveI := FiniteDimensional.complete ğ•œ E\n  haveI := FiniteDimensional.complete ğ•œ F\n  rw [â† coe_toContinuousLinearMap A, adjoint_eq_toCLM_adjoint]\n  exact ContinuousLinearMap.adjoint_inner_right _ x y\n\n"}
{"name":"LinearMap.adjoint_adjoint","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ¶ : RCLike ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : InnerProductSpace ğ•œ E\ninstâœÂ² : InnerProductSpace ğ•œ F\ninstâœÂ¹ : FiniteDimensional ğ•œ E\ninstâœ : FiniteDimensional ğ•œ F\nA : LinearMap (RingHom.id ğ•œ) E F\nâŠ¢ Eq (LinearMap.adjoint (LinearMap.adjoint A)) A","decl":"/-- The adjoint is involutive. -/\n@[simp]\ntheorem adjoint_adjoint (A : E â†’â‚—[ğ•œ] F) : LinearMap.adjoint (LinearMap.adjoint A) = A := by\n  ext v\n  refine ext_inner_left ğ•œ fun w => ?_\n  rw [adjoint_inner_right, adjoint_inner_left]\n\n"}
{"name":"LinearMap.adjoint_comp","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninstâœâ¹ : RCLike ğ•œ\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedAddCommGroup F\ninstâœâ¶ : NormedAddCommGroup G\ninstâœâµ : InnerProductSpace ğ•œ E\ninstâœâ´ : InnerProductSpace ğ•œ F\ninstâœÂ³ : InnerProductSpace ğ•œ G\ninstâœÂ² : FiniteDimensional ğ•œ E\ninstâœÂ¹ : FiniteDimensional ğ•œ F\ninstâœ : FiniteDimensional ğ•œ G\nA : LinearMap (RingHom.id ğ•œ) F G\nB : LinearMap (RingHom.id ğ•œ) E F\nâŠ¢ Eq (LinearMap.adjoint (A.comp B)) ((LinearMap.adjoint B).comp (LinearMap.adjoint A))","decl":"/-- The adjoint of the composition of two operators is the composition of the two adjoints\nin reverse order. -/\n@[simp]\ntheorem adjoint_comp (A : F â†’â‚—[ğ•œ] G) (B : E â†’â‚—[ğ•œ] F) :\n    LinearMap.adjoint (A âˆ˜â‚— B) = LinearMap.adjoint B âˆ˜â‚— LinearMap.adjoint A := by\n  ext v\n  refine ext_inner_left ğ•œ fun w => ?_\n  simp only [adjoint_inner_right, LinearMap.coe_comp, Function.comp_apply]\n\n"}
{"name":"LinearMap.eq_adjoint_iff","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ¶ : RCLike ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : InnerProductSpace ğ•œ E\ninstâœÂ² : InnerProductSpace ğ•œ F\ninstâœÂ¹ : FiniteDimensional ğ•œ E\ninstâœ : FiniteDimensional ğ•œ F\nA : LinearMap (RingHom.id ğ•œ) E F\nB : LinearMap (RingHom.id ğ•œ) F E\nâŠ¢ Iff (Eq A (LinearMap.adjoint B)) (âˆ€ (x : E) (y : F), Eq (Inner.inner (A x) y) (Inner.inner x (B y)))","decl":"/-- The adjoint is unique: a map `A` is the adjoint of `B` iff it satisfies `âŸªA x, yâŸ« = âŸªx, B yâŸ«`\nfor all `x` and `y`. -/\ntheorem eq_adjoint_iff (A : E â†’â‚—[ğ•œ] F) (B : F â†’â‚—[ğ•œ] E) :\n    A = LinearMap.adjoint B â†” âˆ€ x y, âŸªA x, yâŸ« = âŸªx, B yâŸ« := by\n  refine âŸ¨fun h x y => by rw [h, adjoint_inner_left], fun h => ?_âŸ©\n  ext x\n  exact ext_inner_right ğ•œ fun y => by simp only [adjoint_inner_left, h x y]\n\n"}
{"name":"LinearMap.eq_adjoint_iff_basis","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ¶ : RCLike ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : InnerProductSpace ğ•œ E\ninstâœÂ² : InnerProductSpace ğ•œ F\ninstâœÂ¹ : FiniteDimensional ğ•œ E\ninstâœ : FiniteDimensional ğ•œ F\nÎ¹â‚ : Type u_5\nÎ¹â‚‚ : Type u_6\nbâ‚ : Basis Î¹â‚ ğ•œ E\nbâ‚‚ : Basis Î¹â‚‚ ğ•œ F\nA : LinearMap (RingHom.id ğ•œ) E F\nB : LinearMap (RingHom.id ğ•œ) F E\nâŠ¢ Iff (Eq A (LinearMap.adjoint B)) (âˆ€ (iâ‚ : Î¹â‚) (iâ‚‚ : Î¹â‚‚), Eq (Inner.inner (A (bâ‚ iâ‚)) (bâ‚‚ iâ‚‚)) (Inner.inner (bâ‚ iâ‚) (B (bâ‚‚ iâ‚‚))))","decl":"/-- The adjoint is unique: a map `A` is the adjoint of `B` iff it satisfies `âŸªA x, yâŸ« = âŸªx, B yâŸ«`\nfor all basis vectors `x` and `y`. -/\ntheorem eq_adjoint_iff_basis {Î¹â‚ : Type*} {Î¹â‚‚ : Type*} (bâ‚ : Basis Î¹â‚ ğ•œ E) (bâ‚‚ : Basis Î¹â‚‚ ğ•œ F)\n    (A : E â†’â‚—[ğ•œ] F) (B : F â†’â‚—[ğ•œ] E) :\n    A = LinearMap.adjoint B â†” âˆ€ (iâ‚ : Î¹â‚) (iâ‚‚ : Î¹â‚‚), âŸªA (bâ‚ iâ‚), bâ‚‚ iâ‚‚âŸ« = âŸªbâ‚ iâ‚, B (bâ‚‚ iâ‚‚)âŸ« := by\n  refine âŸ¨fun h x y => by rw [h, adjoint_inner_left], fun h => ?_âŸ©\n  refine Basis.ext bâ‚ fun iâ‚ => ?_\n  exact ext_inner_right_basis bâ‚‚ fun iâ‚‚ => by simp only [adjoint_inner_left, h iâ‚ iâ‚‚]\n\n"}
{"name":"LinearMap.eq_adjoint_iff_basis_left","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ¶ : RCLike ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : InnerProductSpace ğ•œ E\ninstâœÂ² : InnerProductSpace ğ•œ F\ninstâœÂ¹ : FiniteDimensional ğ•œ E\ninstâœ : FiniteDimensional ğ•œ F\nÎ¹ : Type u_5\nb : Basis Î¹ ğ•œ E\nA : LinearMap (RingHom.id ğ•œ) E F\nB : LinearMap (RingHom.id ğ•œ) F E\nâŠ¢ Iff (Eq A (LinearMap.adjoint B)) (âˆ€ (i : Î¹) (y : F), Eq (Inner.inner (A (b i)) y) (Inner.inner (b i) (B y)))","decl":"theorem eq_adjoint_iff_basis_left {Î¹ : Type*} (b : Basis Î¹ ğ•œ E) (A : E â†’â‚—[ğ•œ] F) (B : F â†’â‚—[ğ•œ] E) :\n    A = LinearMap.adjoint B â†” âˆ€ i y, âŸªA (b i), yâŸ« = âŸªb i, B yâŸ« := by\n  refine âŸ¨fun h x y => by rw [h, adjoint_inner_left], fun h => Basis.ext b fun i => ?_âŸ©\n  exact ext_inner_right ğ•œ fun y => by simp only [h i, adjoint_inner_left]\n\n"}
{"name":"LinearMap.eq_adjoint_iff_basis_right","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ¶ : RCLike ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : InnerProductSpace ğ•œ E\ninstâœÂ² : InnerProductSpace ğ•œ F\ninstâœÂ¹ : FiniteDimensional ğ•œ E\ninstâœ : FiniteDimensional ğ•œ F\nÎ¹ : Type u_5\nb : Basis Î¹ ğ•œ F\nA : LinearMap (RingHom.id ğ•œ) E F\nB : LinearMap (RingHom.id ğ•œ) F E\nâŠ¢ Iff (Eq A (LinearMap.adjoint B)) (âˆ€ (i : Î¹) (x : E), Eq (Inner.inner (A x) (b i)) (Inner.inner x (B (b i))))","decl":"theorem eq_adjoint_iff_basis_right {Î¹ : Type*} (b : Basis Î¹ ğ•œ F) (A : E â†’â‚—[ğ•œ] F) (B : F â†’â‚—[ğ•œ] E) :\n    A = LinearMap.adjoint B â†” âˆ€ i x, âŸªA x, b iâŸ« = âŸªx, B (b i)âŸ« := by\n  refine âŸ¨fun h x y => by rw [h, adjoint_inner_left], fun h => ?_âŸ©\n  ext x\n  exact ext_inner_right_basis b fun i => by simp only [h i, adjoint_inner_left]\n\n"}
{"name":"LinearMap.instStarModuleId","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : FiniteDimensional ğ•œ E\nâŠ¢ StarModule ğ•œ (LinearMap (RingHom.id ğ•œ) E E)","decl":"instance : StarModule ğ•œ (E â†’â‚—[ğ•œ] E) :=\n  âŸ¨LinearEquiv.map_smulâ‚›â‚— adjointâŸ©\n\n"}
{"name":"LinearMap.star_eq_adjoint","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : FiniteDimensional ğ•œ E\nA : LinearMap (RingHom.id ğ•œ) E E\nâŠ¢ Eq (Star.star A) (LinearMap.adjoint A)","decl":"theorem star_eq_adjoint (A : E â†’â‚—[ğ•œ] E) : star A = LinearMap.adjoint A :=\n  rfl\n\n"}
{"name":"LinearMap.isSelfAdjoint_iff'","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : FiniteDimensional ğ•œ E\nA : LinearMap (RingHom.id ğ•œ) E E\nâŠ¢ Iff (IsSelfAdjoint A) (Eq (LinearMap.adjoint A) A)","decl":"/-- A continuous linear operator is self-adjoint iff it is equal to its adjoint. -/\ntheorem isSelfAdjoint_iff' {A : E â†’â‚—[ğ•œ] E} : IsSelfAdjoint A â†” LinearMap.adjoint A = A :=\n  Iff.rfl\n\n"}
{"name":"LinearMap.isSymmetric_iff_isSelfAdjoint","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : FiniteDimensional ğ•œ E\nA : LinearMap (RingHom.id ğ•œ) E E\nâŠ¢ Iff A.IsSymmetric (IsSelfAdjoint A)","decl":"theorem isSymmetric_iff_isSelfAdjoint (A : E â†’â‚—[ğ•œ] E) : IsSymmetric A â†” IsSelfAdjoint A := by\n  rw [isSelfAdjoint_iff', IsSymmetric, â† LinearMap.eq_adjoint_iff]\n  exact eq_comm\n\n"}
{"name":"LinearMap.isAdjointPair_inner","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ¶ : RCLike ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : InnerProductSpace ğ•œ E\ninstâœÂ² : InnerProductSpace ğ•œ F\ninstâœÂ¹ : FiniteDimensional ğ•œ E\ninstâœ : FiniteDimensional ğ•œ F\nA : LinearMap (RingHom.id ğ•œ) E F\nâŠ¢ sesqFormOfInner.IsAdjointPair sesqFormOfInner â‡‘A â‡‘(LinearMap.adjoint A)","decl":"theorem isAdjointPair_inner (A : E â†’â‚—[ğ•œ] F) :\n    IsAdjointPair (sesqFormOfInner : E â†’â‚—[ğ•œ] E â†’â‚—â‹†[ğ•œ] ğ•œ) (sesqFormOfInner : F â†’â‚—[ğ•œ] F â†’â‚—â‹†[ğ•œ] ğ•œ) A\n      (LinearMap.adjoint A) := by\n  intro x y\n  simp only [sesqFormOfInner_apply_apply, adjoint_inner_left]\n\n"}
{"name":"LinearMap.isSymmetric_adjoint_mul_self","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : FiniteDimensional ğ•œ E\nT : LinearMap (RingHom.id ğ•œ) E E\nâŠ¢ (HMul.hMul (LinearMap.adjoint T) T).IsSymmetric","decl":"/-- The Gram operator Tâ€ T is symmetric. -/\ntheorem isSymmetric_adjoint_mul_self (T : E â†’â‚—[ğ•œ] E) : IsSymmetric (LinearMap.adjoint T * T) := by\n  intro x y\n  simp only [mul_apply, adjoint_inner_left, adjoint_inner_right]\n\n"}
{"name":"LinearMap.re_inner_adjoint_mul_self_nonneg","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : FiniteDimensional ğ•œ E\nT : LinearMap (RingHom.id ğ•œ) E E\nx : E\nâŠ¢ LE.le 0 (RCLike.re (Inner.inner x ((HMul.hMul (LinearMap.adjoint T) T) x)))","decl":"/-- The Gram operator Tâ€ T is a positive operator. -/\ntheorem re_inner_adjoint_mul_self_nonneg (T : E â†’â‚—[ğ•œ] E) (x : E) :\n    0 â‰¤ re âŸªx, (LinearMap.adjoint T * T) xâŸ« := by\n  simp only [mul_apply, adjoint_inner_right, inner_self_eq_norm_sq_to_K]\n  norm_cast\n  exact sq_nonneg _\n\n"}
{"name":"LinearMap.im_inner_adjoint_mul_self_eq_zero","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : FiniteDimensional ğ•œ E\nT : LinearMap (RingHom.id ğ•œ) E E\nx : E\nâŠ¢ Eq (RCLike.im (Inner.inner x ((LinearMap.adjoint T) (T x)))) 0","decl":"@[simp]\ntheorem im_inner_adjoint_mul_self_eq_zero (T : E â†’â‚—[ğ•œ] E) (x : E) :\n    im âŸªx, LinearMap.adjoint T (T x)âŸ« = 0 := by\n  simp only [mul_apply, adjoint_inner_right, inner_self_eq_norm_sq_to_K]\n  norm_cast\n\n"}
{"name":"ContinuousLinearMap.inner_map_map_iff_adjoint_comp_self","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : RCLike ğ•œ\nH : Type u_5\ninstâœâµ : NormedAddCommGroup H\ninstâœâ´ : InnerProductSpace ğ•œ H\ninstâœÂ³ : CompleteSpace H\nK : Type u_6\ninstâœÂ² : NormedAddCommGroup K\ninstâœÂ¹ : InnerProductSpace ğ•œ K\ninstâœ : CompleteSpace K\nu : ContinuousLinearMap (RingHom.id ğ•œ) H K\nâŠ¢ Iff (âˆ€ (x y : H), Eq (Inner.inner (u x) (u y)) (Inner.inner x y)) (Eq ((ContinuousLinearMap.adjoint u).comp u) 1)","decl":"theorem inner_map_map_iff_adjoint_comp_self (u : H â†’L[ğ•œ] K) :\n    (âˆ€ x y : H, âŸªu x, u yâŸ«_ğ•œ = âŸªx, yâŸ«_ğ•œ) â†” adjoint u âˆ˜L u = 1 := by\n  refine âŸ¨fun h â†¦ ext fun x â†¦ ?_, fun h â†¦ ?_âŸ©\n  Â· refine ext_inner_right ğ•œ fun y â†¦ ?_\n    simpa [star_eq_adjoint, adjoint_inner_left] using h x y\n  Â· simp [â† adjoint_inner_left, â† comp_apply, h]\n\n"}
{"name":"ContinuousLinearMap.norm_map_iff_adjoint_comp_self","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : RCLike ğ•œ\nH : Type u_5\ninstâœâµ : NormedAddCommGroup H\ninstâœâ´ : InnerProductSpace ğ•œ H\ninstâœÂ³ : CompleteSpace H\nK : Type u_6\ninstâœÂ² : NormedAddCommGroup K\ninstâœÂ¹ : InnerProductSpace ğ•œ K\ninstâœ : CompleteSpace K\nu : ContinuousLinearMap (RingHom.id ğ•œ) H K\nâŠ¢ Iff (âˆ€ (x : H), Eq (Norm.norm (u x)) (Norm.norm x)) (Eq ((ContinuousLinearMap.adjoint u).comp u) 1)","decl":"theorem norm_map_iff_adjoint_comp_self (u : H â†’L[ğ•œ] K) :\n    (âˆ€ x : H, â€–u xâ€– = â€–xâ€–) â†” adjoint u âˆ˜L u = 1 := by\n  rw [LinearMap.norm_map_iff_inner_map_map u, u.inner_map_map_iff_adjoint_comp_self]\n\n"}
{"name":"LinearIsometryEquiv.adjoint_eq_symm","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : RCLike ğ•œ\nH : Type u_5\ninstâœâµ : NormedAddCommGroup H\ninstâœâ´ : InnerProductSpace ğ•œ H\ninstâœÂ³ : CompleteSpace H\nK : Type u_6\ninstâœÂ² : NormedAddCommGroup K\ninstâœÂ¹ : InnerProductSpace ğ•œ K\ninstâœ : CompleteSpace K\ne : LinearIsometryEquiv (RingHom.id ğ•œ) H K\nâŠ¢ Eq (ContinuousLinearMap.adjoint â†‘{ toLinearEquiv := e.toLinearEquiv, continuous_toFun := â‹¯, continuous_invFun := â‹¯ }) â†‘{ toLinearEquiv := e.symm.toLinearEquiv, continuous_toFun := â‹¯, continuous_invFun := â‹¯ }","decl":"@[simp]\nlemma _root_.LinearIsometryEquiv.adjoint_eq_symm (e : H â‰ƒâ‚—áµ¢[ğ•œ] K) :\n    adjoint (e : H â†’L[ğ•œ] K) = e.symm :=\n  let e' := (e : H â†’L[ğ•œ] K)\n  calc\n    adjoint e' = adjoint e' âˆ˜L (e' âˆ˜L e.symm) := by\n      convert (adjoint e').comp_id.symm\n      ext\n      simp [e']\n    _ = e.symm := by\n      rw [â† comp_assoc, norm_map_iff_adjoint_comp_self e' |>.mp e.norm_map]\n      exact (e.symm : K â†’L[ğ•œ] H).id_comp\n\n"}
{"name":"LinearIsometryEquiv.star_eq_symm","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : RCLike ğ•œ\nH : Type u_5\ninstâœÂ² : NormedAddCommGroup H\ninstâœÂ¹ : InnerProductSpace ğ•œ H\ninstâœ : CompleteSpace H\ne : LinearIsometryEquiv (RingHom.id ğ•œ) H H\nâŠ¢ Eq (Star.star â†‘{ toLinearEquiv := e.toLinearEquiv, continuous_toFun := â‹¯, continuous_invFun := â‹¯ }) â†‘{ toLinearEquiv := e.symm.toLinearEquiv, continuous_toFun := â‹¯, continuous_invFun := â‹¯ }","decl":"@[simp]\nlemma _root_.LinearIsometryEquiv.star_eq_symm (e : H â‰ƒâ‚—áµ¢[ğ•œ] H) :\n    star (e : H â†’L[ğ•œ] H) = e.symm :=\n  e.adjoint_eq_symm\n\n"}
{"name":"ContinuousLinearMap.norm_map_of_mem_unitary","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : RCLike ğ•œ\nH : Type u_5\ninstâœÂ² : NormedAddCommGroup H\ninstâœÂ¹ : InnerProductSpace ğ•œ H\ninstâœ : CompleteSpace H\nu : ContinuousLinearMap (RingHom.id ğ•œ) H H\nhu : Membership.mem (unitary (ContinuousLinearMap (RingHom.id ğ•œ) H H)) u\nx : H\nâŠ¢ Eq (Norm.norm (u x)) (Norm.norm x)","decl":"theorem norm_map_of_mem_unitary {u : H â†’L[ğ•œ] H} (hu : u âˆˆ unitary (H â†’L[ğ•œ] H)) (x : H) :\n    â€–u xâ€– = â€–xâ€– :=\n  -- Elaborates faster with this broken out https://github.com/leanprover-community/mathlib4/issues/11299\n  have := unitary.star_mul_self_of_mem hu\n  u.norm_map_iff_adjoint_comp_self.mpr this x\n\n"}
{"name":"ContinuousLinearMap.inner_map_map_of_mem_unitary","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : RCLike ğ•œ\nH : Type u_5\ninstâœÂ² : NormedAddCommGroup H\ninstâœÂ¹ : InnerProductSpace ğ•œ H\ninstâœ : CompleteSpace H\nu : ContinuousLinearMap (RingHom.id ğ•œ) H H\nhu : Membership.mem (unitary (ContinuousLinearMap (RingHom.id ğ•œ) H H)) u\nx y : H\nâŠ¢ Eq (Inner.inner (u x) (u y)) (Inner.inner x y)","decl":"theorem inner_map_map_of_mem_unitary {u : H â†’L[ğ•œ] H} (hu : u âˆˆ unitary (H â†’L[ğ•œ] H)) (x y : H) :\n    âŸªu x, u yâŸ«_ğ•œ = âŸªx, yâŸ«_ğ•œ :=\n  -- Elaborates faster with this broken out https://github.com/leanprover-community/mathlib4/issues/11299\n  have := unitary.star_mul_self_of_mem hu\n  u.inner_map_map_iff_adjoint_comp_self.mpr this x y\n\n"}
{"name":"unitary.norm_map","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : RCLike ğ•œ\nH : Type u_5\ninstâœÂ² : NormedAddCommGroup H\ninstâœÂ¹ : InnerProductSpace ğ•œ H\ninstâœ : CompleteSpace H\nu : Subtype fun x => Membership.mem (unitary (ContinuousLinearMap (RingHom.id ğ•œ) H H)) x\nx : H\nâŠ¢ Eq (Norm.norm (â†‘u x)) (Norm.norm x)","decl":"theorem norm_map (u : unitary (H â†’L[ğ•œ] H)) (x : H) : â€–(u : H â†’L[ğ•œ] H) xâ€– = â€–xâ€– :=\n  u.val.norm_map_of_mem_unitary u.property x\n\n"}
{"name":"unitary.inner_map_map","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : RCLike ğ•œ\nH : Type u_5\ninstâœÂ² : NormedAddCommGroup H\ninstâœÂ¹ : InnerProductSpace ğ•œ H\ninstâœ : CompleteSpace H\nu : Subtype fun x => Membership.mem (unitary (ContinuousLinearMap (RingHom.id ğ•œ) H H)) x\nx y : H\nâŠ¢ Eq (Inner.inner (â†‘u x) (â†‘u y)) (Inner.inner x y)","decl":"theorem inner_map_map (u : unitary (H â†’L[ğ•œ] H)) (x y : H) :\n    âŸª(u : H â†’L[ğ•œ] H) x, (u : H â†’L[ğ•œ] H) yâŸ«_ğ•œ = âŸªx, yâŸ«_ğ•œ :=\n  u.val.inner_map_map_of_mem_unitary u.property x y\n\n"}
{"name":"unitary.linearIsometryEquiv_coe_apply","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : RCLike ğ•œ\nH : Type u_5\ninstâœÂ² : NormedAddCommGroup H\ninstâœÂ¹ : InnerProductSpace ğ•œ H\ninstâœ : CompleteSpace H\nu : Subtype fun x => Membership.mem (unitary (ContinuousLinearMap (RingHom.id ğ•œ) H H)) x\nâŠ¢ Eq â†‘{ toLinearEquiv := (unitary.linearIsometryEquiv u).toLinearEquiv, continuous_toFun := â‹¯, continuous_invFun := â‹¯ } â†‘u","decl":"@[simp]\nlemma linearIsometryEquiv_coe_apply (u : unitary (H â†’L[ğ•œ] H)) :\n    linearIsometryEquiv u = (u : H â†’L[ğ•œ] H) :=\n  rfl\n\n"}
{"name":"unitary.linearIsometryEquiv_coe_symm_apply","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : RCLike ğ•œ\nH : Type u_5\ninstâœÂ² : NormedAddCommGroup H\ninstâœÂ¹ : InnerProductSpace ğ•œ H\ninstâœ : CompleteSpace H\ne : LinearIsometryEquiv (RingHom.id ğ•œ) H H\nâŠ¢ Eq â†‘(unitary.linearIsometryEquiv.symm e) â†‘{ toLinearEquiv := e.toLinearEquiv, continuous_toFun := â‹¯, continuous_invFun := â‹¯ }","decl":"@[simp]\nlemma linearIsometryEquiv_coe_symm_apply (e : H â‰ƒâ‚—áµ¢[ğ•œ] H) :\n    linearIsometryEquiv.symm e = (e : H â†’L[ğ•œ] H) :=\n  rfl\n\n"}
{"name":"Matrix.toLin_conjTranspose","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœÂ¹â° : RCLike ğ•œ\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedAddCommGroup F\ninstâœâ· : InnerProductSpace ğ•œ E\ninstâœâ¶ : InnerProductSpace ğ•œ F\nm : Type u_5\nn : Type u_6\ninstâœâµ : Fintype m\ninstâœâ´ : DecidableEq m\ninstâœÂ³ : Fintype n\ninstâœÂ² : DecidableEq n\ninstâœÂ¹ : FiniteDimensional ğ•œ E\ninstâœ : FiniteDimensional ğ•œ F\nvâ‚ : OrthonormalBasis n ğ•œ E\nvâ‚‚ : OrthonormalBasis m ğ•œ F\nA : Matrix m n ğ•œ\nâŠ¢ Eq ((Matrix.toLin vâ‚‚.toBasis vâ‚.toBasis) A.conjTranspose) (LinearMap.adjoint ((Matrix.toLin vâ‚.toBasis vâ‚‚.toBasis) A))","decl":"/-- The linear map associated to the conjugate transpose of a matrix corresponding to two\northonormal bases is the adjoint of the linear map associated to the matrix. -/\nlemma Matrix.toLin_conjTranspose (A : Matrix m n ğ•œ) :\n    toLin vâ‚‚.toBasis vâ‚.toBasis Aá´´ = adjoint (toLin vâ‚.toBasis vâ‚‚.toBasis A) := by\n  refine eq_adjoint_iff_basis vâ‚‚.toBasis vâ‚.toBasis _ _ |>.mpr fun i j â†¦ ?_\n  simp_rw [toLin_self]\n  simp [sum_inner, inner_smul_left, inner_sum, inner_smul_right,\n    orthonormal_iff_ite.mp vâ‚.orthonormal, orthonormal_iff_ite.mp vâ‚‚.orthonormal]\n\n"}
{"name":"LinearMap.toMatrix_adjoint","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœÂ¹â° : RCLike ğ•œ\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedAddCommGroup F\ninstâœâ· : InnerProductSpace ğ•œ E\ninstâœâ¶ : InnerProductSpace ğ•œ F\nm : Type u_5\nn : Type u_6\ninstâœâµ : Fintype m\ninstâœâ´ : DecidableEq m\ninstâœÂ³ : Fintype n\ninstâœÂ² : DecidableEq n\ninstâœÂ¹ : FiniteDimensional ğ•œ E\ninstâœ : FiniteDimensional ğ•œ F\nvâ‚ : OrthonormalBasis n ğ•œ E\nvâ‚‚ : OrthonormalBasis m ğ•œ F\nf : LinearMap (RingHom.id ğ•œ) E F\nâŠ¢ Eq ((LinearMap.toMatrix vâ‚‚.toBasis vâ‚.toBasis) (LinearMap.adjoint f)) ((LinearMap.toMatrix vâ‚.toBasis vâ‚‚.toBasis) f).conjTranspose","decl":"/-- The matrix associated to the adjoint of a linear map corresponding to two orthonormal bases\nis the conjugate transpose of the matrix associated to the linear map. -/\nlemma LinearMap.toMatrix_adjoint (f : E â†’â‚—[ğ•œ] F) :\n    toMatrix vâ‚‚.toBasis vâ‚.toBasis (adjoint f) = (toMatrix vâ‚.toBasis vâ‚‚.toBasis f)á´´ :=\n  toLin vâ‚‚.toBasis vâ‚.toBasis |>.injective <| by simp [toLin_conjTranspose]\n\n"}
{"name":"LinearMap.toMatrixOrthonormal_symm_apply","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâµ : RCLike ğ•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : InnerProductSpace ğ•œ E\nn : Type u_6\ninstâœÂ² : Fintype n\ninstâœÂ¹ : DecidableEq n\ninstâœ : FiniteDimensional ğ•œ E\nvâ‚ : OrthonormalBasis n ğ•œ E\naâœ : Matrix n n ğ•œ\nâŠ¢ Eq ((LinearMap.toMatrixOrthonormal vâ‚).symm aâœ) ((LinearMap.toMatrix vâ‚.toBasis vâ‚.toBasis).invFun aâœ)","decl":"/-- The star algebra equivalence between the linear endomorphisms of finite-dimensional inner\nproduct space and square matrices induced by the choice of an orthonormal basis. -/\n@[simps]\ndef LinearMap.toMatrixOrthonormal : (E â†’â‚—[ğ•œ] E) â‰ƒâ‹†â‚[ğ•œ] Matrix n n ğ•œ :=\n  { LinearMap.toMatrix vâ‚.toBasis vâ‚.toBasis with\n    map_mul' := LinearMap.toMatrix_mul vâ‚.toBasis\n    map_star' := LinearMap.toMatrix_adjoint vâ‚ vâ‚ }\n\n"}
{"name":"LinearMap.toMatrixOrthonormal_apply","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâµ : RCLike ğ•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : InnerProductSpace ğ•œ E\nn : Type u_6\ninstâœÂ² : Fintype n\ninstâœÂ¹ : DecidableEq n\ninstâœ : FiniteDimensional ğ•œ E\nvâ‚ : OrthonormalBasis n ğ•œ E\naâœ : LinearMap (RingHom.id ğ•œ) E E\nâŠ¢ Eq ((LinearMap.toMatrixOrthonormal vâ‚) aâœ) ((â†‘(LinearMap.toMatrix vâ‚.toBasis vâ‚.toBasis)).toFun aâœ)","decl":"/-- The star algebra equivalence between the linear endomorphisms of finite-dimensional inner\nproduct space and square matrices induced by the choice of an orthonormal basis. -/\n@[simps]\ndef LinearMap.toMatrixOrthonormal : (E â†’â‚—[ğ•œ] E) â‰ƒâ‹†â‚[ğ•œ] Matrix n n ğ•œ :=\n  { LinearMap.toMatrix vâ‚.toBasis vâ‚.toBasis with\n    map_mul' := LinearMap.toMatrix_mul vâ‚.toBasis\n    map_star' := LinearMap.toMatrix_adjoint vâ‚ vâ‚ }\n\n"}
{"name":"Matrix.toEuclideanLin_conjTranspose_eq_adjoint","module":"Mathlib.Analysis.InnerProductSpace.Adjoint","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : RCLike ğ•œ\nm : Type u_5\nn : Type u_6\ninstâœÂ³ : Fintype m\ninstâœÂ² : DecidableEq m\ninstâœÂ¹ : Fintype n\ninstâœ : DecidableEq n\nA : Matrix m n ğ•œ\nâŠ¢ Eq (Matrix.toEuclideanLin A.conjTranspose) (LinearMap.adjoint (Matrix.toEuclideanLin A))","decl":"/-- The adjoint of the linear map associated to a matrix is the linear map associated to the\nconjugate transpose of that matrix. -/\ntheorem Matrix.toEuclideanLin_conjTranspose_eq_adjoint (A : Matrix m n ğ•œ) :\n    Matrix.toEuclideanLin A.conjTranspose = LinearMap.adjoint (Matrix.toEuclideanLin A) :=\n  A.toLin_conjTranspose (EuclideanSpace.basisFun n ğ•œ) (EuclideanSpace.basisFun m ğ•œ)\n\n"}
