{"name":"CategoryTheory.Presieve.preservesTerminal_of_isSheaf_for_empty","module":"Mathlib.CategoryTheory.Sites.Preserves","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nI : C\nF : CategoryTheory.Functor (Opposite C) (Type w)\nhF : CategoryTheory.Presieve.IsSheafFor F (CategoryTheory.Presieve.ofArrows Empty.elim fun a => Empty.instIsEmpty.elim a)\nhI : CategoryTheory.Limits.IsInitial I\n‚ä¢ CategoryTheory.Limits.PreservesLimit (CategoryTheory.Functor.empty (Opposite C)) F","decl":"include hF in\n/--\nIf `F` is a presheaf which satisfies the sheaf condition with respect to the empty presieve on the\ninitial object, then `F` preserves terminal objects.\n-/\nlemma preservesTerminal_of_isSheaf_for_empty (hI : IsInitial I) :\n    PreservesLimit (Functor.empty.{0} C·µí·µñ) F :=\n  have := hI.hasInitial\n  (preservesTerminal_of_iso F\n    ((F.mapIso (terminalIsoIsTerminal (terminalOpOfInitial initialIsInitial)) ‚â™‚â´\n    (F.mapIso (initialIsoIsInitial hI).symm.op) ‚â™‚â´\n    (terminalIsoIsTerminal (isTerminal_of_isSheafFor_empty_presieve I F hF)).symm)))\n\n"}
{"name":"CategoryTheory.Presieve.piComparison_fac","module":"Mathlib.CategoryTheory.Sites.Preserves","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Opposite C) (Type w)\nŒ± : Type\nX : Œ± ‚Üí C\nc : CategoryTheory.Limits.Cofan X\nhc : CategoryTheory.Limits.IsColimit c\n‚ä¢ letFun ‚ãØ fun this => Eq (CategoryTheory.Limits.piComparison F fun x => { unop := X x }) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.Limits.opCoproductIsoProduct' hc (CategoryTheory.Limits.productIsProduct fun x => { unop := X x })).inv) (CategoryTheory.Equalizer.Presieve.Arrows.forkMap F X c.inj))","decl":"theorem piComparison_fac :\n    have : HasCoproduct X := ‚ü®‚ü®c, hc‚ü©‚ü©\n    piComparison F (fun x ‚Ü¶ op (X x)) = F.map (opCoproductIsoProduct' hc (productIsProduct _)).inv ‚â´\n    Equalizer.Presieve.Arrows.forkMap F X c.inj := by\n  have : HasCoproduct X := ‚ü®‚ü®c, hc‚ü©‚ü©\n  dsimp only [Equalizer.Presieve.Arrows.forkMap]\n  have h : Pi.lift (fun i ‚Ü¶ F.map (c.inj i).op) =\n      F.map (Pi.lift (fun i ‚Ü¶ (c.inj i).op)) ‚â´ piComparison F _ := by simp\n  rw [h, ‚Üê Category.assoc, ‚Üê Functor.map_comp]\n  have hh : Pi.lift (fun i ‚Ü¶ (c.inj i).op) = (productIsProduct (op <| X ¬∑)).lift c.op := by\n    simp [Pi.lift, productIsProduct]\n  rw [hh, ‚Üê desc_op_comp_opCoproductIsoProduct'_hom hc]\n  simp\n\n"}
{"name":"CategoryTheory.Presieve.isSheafFor_of_preservesProduct","module":"Mathlib.CategoryTheory.Sites.Preserves","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Opposite C) (Type w)\nŒ± : Type\nX : Œ± ‚Üí C\nc : CategoryTheory.Limits.Cofan X\nhc : CategoryTheory.Limits.IsColimit c\ninst‚úù¬π : (CategoryTheory.Presieve.ofArrows X c.inj).hasPullbacks\ninst‚úù : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Discrete.functor fun x => { unop := X x }) F\n‚ä¢ CategoryTheory.Presieve.IsSheafFor F (CategoryTheory.Presieve.ofArrows X c.inj)","decl":"include hc in\n/--\nIf `F` preserves a particular product, then it `IsSheafFor` the corresponding presieve of arrows.\n-/\ntheorem isSheafFor_of_preservesProduct [PreservesLimit (Discrete.functor (fun x ‚Ü¶ op (X x))) F] :\n    (ofArrows X c.inj).IsSheafFor F := by\n  rw [Equalizer.Presieve.Arrows.sheaf_condition, Limits.Types.type_equalizer_iff_unique]\n  have : HasCoproduct X := ‚ü®‚ü®c, hc‚ü©‚ü©\n  have hi : IsIso (piComparison F (fun x ‚Ü¶ op (X x))) := inferInstance\n  rw [piComparison_fac (hc := hc), isIso_iff_bijective, Function.bijective_iff_existsUnique] at hi\n  intro b _\n  obtain ‚ü®t, ht‚ÇÅ, ht‚ÇÇ‚ü© := hi b\n  refine ‚ü®F.map ((opCoproductIsoProduct' hc (productIsProduct _)).inv) t, ht‚ÇÅ, fun y hy ‚Ü¶ ?_‚ü©\n  apply_fun F.map ((opCoproductIsoProduct' hc (productIsProduct _)).hom) using injective_of_mono _\n  simp only [‚Üê FunctorToTypes.map_comp_apply, Iso.op, Category.assoc]\n  rw [ht‚ÇÇ (F.map ((opCoproductIsoProduct' hc (productIsProduct _)).hom) y) (by simp [‚Üê hy])]\n  change (ùüô (F.obj (‚àè·∂ú fun x ‚Ü¶ op (X x)))) t = _\n  rw [‚Üê Functor.map_id]\n  refine congrFun ?_ t\n  congr\n  simp [Iso.eq_inv_comp, ‚Üê Category.assoc, ‚Üê op_comp, eq_comm, ‚Üê Iso.eq_comp_inv]\n\n"}
{"name":"CategoryTheory.Presieve.firstMap_eq_secondMap","module":"Mathlib.CategoryTheory.Sites.Preserves","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nI : C\nF : CategoryTheory.Functor (Opposite C) (Type w)\nhF : CategoryTheory.Presieve.IsSheafFor F (CategoryTheory.Presieve.ofArrows Empty.elim fun a => Empty.instIsEmpty.elim a)\nhI : CategoryTheory.Limits.IsInitial I\nŒ± : Type\nX : Œ± ‚Üí C\nc : CategoryTheory.Limits.Cofan X\ninst‚úù¬≤ : (CategoryTheory.Presieve.ofArrows X c.inj).hasPullbacks\ninst‚úù¬π : CategoryTheory.Limits.HasInitial C\ninst‚úù : ‚àÄ (i : Œ±), CategoryTheory.Mono (c.inj i)\nhd : Pairwise fun i j => CategoryTheory.IsPullback (CategoryTheory.Limits.initial.to (X i)) (CategoryTheory.Limits.initial.to (X j)) (c.inj i) (c.inj j)\n‚ä¢ Eq (CategoryTheory.Equalizer.Presieve.Arrows.firstMap F X c.inj) (CategoryTheory.Equalizer.Presieve.Arrows.secondMap F X c.inj)","decl":"include hd hF hI in\n/--\nThe two parallel maps in the equalizer diagram for the sheaf condition corresponding to the\ninclusion maps in a disjoint coproduct are equal.\n-/\ntheorem firstMap_eq_secondMap :\n    Equalizer.Presieve.Arrows.firstMap F X c.inj =\n    Equalizer.Presieve.Arrows.secondMap F X c.inj := by\n  ext a ‚ü®i, j‚ü©\n  simp only [Equalizer.Presieve.Arrows.firstMap, Types.pi_lift_œÄ_apply, types_comp_apply,\n    Equalizer.Presieve.Arrows.secondMap]\n  by_cases hi : i = j\n  ¬∑ rw [hi, Mono.right_cancellation _ _ pullback.condition]\n  ¬∑ have := preservesTerminal_of_isSheaf_for_empty F hF hI\n    apply_fun (F.mapIso ((hd hi).isoPullback).op ‚â™‚â´ F.mapIso (terminalIsoIsTerminal\n      (terminalOpOfInitial initialIsInitial)).symm ‚â™‚â´ (PreservesTerminal.iso F)).hom using\n      injective_of_mono _\n    ext ‚ü®i‚ü©\n    exact i.elim\n\n"}
{"name":"CategoryTheory.Presieve.preservesProduct_of_isSheafFor","module":"Mathlib.CategoryTheory.Sites.Preserves","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nI : C\nF : CategoryTheory.Functor (Opposite C) (Type w)\nhF : CategoryTheory.Presieve.IsSheafFor F (CategoryTheory.Presieve.ofArrows Empty.elim fun a => Empty.instIsEmpty.elim a)\nhI : CategoryTheory.Limits.IsInitial I\nŒ± : Type\nX : Œ± ‚Üí C\nc : CategoryTheory.Limits.Cofan X\nhc : CategoryTheory.Limits.IsColimit c\ninst‚úù¬≤ : (CategoryTheory.Presieve.ofArrows X c.inj).hasPullbacks\ninst‚úù¬π : CategoryTheory.Limits.HasInitial C\ninst‚úù : ‚àÄ (i : Œ±), CategoryTheory.Mono (c.inj i)\nhd : Pairwise fun i j => CategoryTheory.IsPullback (CategoryTheory.Limits.initial.to (X i)) (CategoryTheory.Limits.initial.to (X j)) (c.inj i) (c.inj j)\nhF' : CategoryTheory.Presieve.IsSheafFor F (CategoryTheory.Presieve.ofArrows X c.inj)\n‚ä¢ CategoryTheory.Limits.PreservesLimit (CategoryTheory.Discrete.functor fun x => { unop := X x }) F","decl":"include hc hd hF hI in\n/--\nIf `F` is a presheaf which `IsSheafFor` a presieve of arrows and the empty presieve, then it\npreserves the product corresponding to the presieve of arrows.\n-/\nlemma preservesProduct_of_isSheafFor\n    (hF' : (ofArrows X c.inj).IsSheafFor F) :\n    PreservesLimit (Discrete.functor (fun x ‚Ü¶ op (X x))) F := by\n  have : HasCoproduct X := ‚ü®‚ü®c, hc‚ü©‚ü©\n  refine @PreservesProduct.of_iso_comparison _ _ _ _ F _ (fun x ‚Ü¶ op (X x)) _ _ ?_\n  rw [piComparison_fac (hc := hc)]\n  refine IsIso.comp_isIso' inferInstance ?_\n  rw [isIso_iff_bijective, Function.bijective_iff_existsUnique]\n  rw [Equalizer.Presieve.Arrows.sheaf_condition, Limits.Types.type_equalizer_iff_unique] at hF'\n  exact fun b ‚Ü¶ hF' b (congr_fun (firstMap_eq_secondMap F hF hI c hd) b)\n\n"}
{"name":"CategoryTheory.Presieve.isSheafFor_iff_preservesProduct","module":"Mathlib.CategoryTheory.Sites.Preserves","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nI : C\nF : CategoryTheory.Functor (Opposite C) (Type w)\nhF : CategoryTheory.Presieve.IsSheafFor F (CategoryTheory.Presieve.ofArrows Empty.elim fun a => Empty.instIsEmpty.elim a)\nhI : CategoryTheory.Limits.IsInitial I\nŒ± : Type\nX : Œ± ‚Üí C\nc : CategoryTheory.Limits.Cofan X\nhc : CategoryTheory.Limits.IsColimit c\ninst‚úù¬≤ : (CategoryTheory.Presieve.ofArrows X c.inj).hasPullbacks\ninst‚úù¬π : CategoryTheory.Limits.HasInitial C\ninst‚úù : ‚àÄ (i : Œ±), CategoryTheory.Mono (c.inj i)\nhd : Pairwise fun i j => CategoryTheory.IsPullback (CategoryTheory.Limits.initial.to (X i)) (CategoryTheory.Limits.initial.to (X j)) (c.inj i) (c.inj j)\n‚ä¢ Iff (CategoryTheory.Presieve.IsSheafFor F (CategoryTheory.Presieve.ofArrows X c.inj)) (Nonempty (CategoryTheory.Limits.PreservesLimit (CategoryTheory.Discrete.functor fun x => { unop := X x }) F))","decl":"include hc hd hF hI in\ntheorem isSheafFor_iff_preservesProduct : (ofArrows X c.inj).IsSheafFor F ‚Üî\n    Nonempty (PreservesLimit (Discrete.functor (fun x ‚Ü¶ op (X x))) F) := by\n  refine ‚ü®fun hF' ‚Ü¶ ‚ü®preservesProduct_of_isSheafFor _ hF hI c hc hd hF'‚ü©, fun hF' ‚Ü¶ ?_‚ü©\n  let _ := hF'.some\n  exact isSheafFor_of_preservesProduct F c hc\n\n"}
