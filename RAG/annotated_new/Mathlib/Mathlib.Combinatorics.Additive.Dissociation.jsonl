{"name":"addDissociated_iff_sum_eq_subsingleton","module":"Mathlib.Combinatorics.Additive.Dissociation","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\ns : Set α\n⊢ Iff (AddDissociated s) (∀ (a : α), (setOf fun t => And (HasSubset.Subset (↑t) s) (Eq (t.sum fun x => x) a)).Subsingleton)","decl":"@[to_additive] lemma mulDissociated_iff_sum_eq_subsingleton :\n    MulDissociated s ↔ ∀ a, {t : Finset α | ↑t ⊆ s ∧ ∏ x ∈ t, x = a}.Subsingleton :=\n  ⟨fun hs _ _t ht _u hu ↦ hs ht.1 hu.1 <| ht.2.trans hu.2.symm,\n    fun hs _t ht _u hu htu ↦ hs _ ⟨ht, htu⟩ ⟨hu, rfl⟩⟩\n\n"}
{"name":"mulDissociated_iff_sum_eq_subsingleton","module":"Mathlib.Combinatorics.Additive.Dissociation","initialProofState":"α : Type u_1\ninst✝ : CommGroup α\ns : Set α\n⊢ Iff (MulDissociated s) (∀ (a : α), (setOf fun t => And (HasSubset.Subset (↑t) s) (Eq (t.prod fun x => x) a)).Subsingleton)","decl":"@[to_additive] lemma mulDissociated_iff_sum_eq_subsingleton :\n    MulDissociated s ↔ ∀ a, {t : Finset α | ↑t ⊆ s ∧ ∏ x ∈ t, x = a}.Subsingleton :=\n  ⟨fun hs _ _t ht _u hu ↦ hs ht.1 hu.1 <| ht.2.trans hu.2.symm,\n    fun hs _t ht _u hu htu ↦ hs _ ⟨ht, htu⟩ ⟨hu, rfl⟩⟩\n\n"}
{"name":"AddDissociated.subset","module":"Mathlib.Combinatorics.Additive.Dissociation","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\ns t : Set α\nhst : HasSubset.Subset s t\nht : AddDissociated t\n⊢ AddDissociated s","decl":"@[to_additive] lemma MulDissociated.subset {t : Set α} (hst : s ⊆ t) (ht : MulDissociated t) :\n    MulDissociated s := ht.mono fun _ ↦ hst.trans'\n\n"}
{"name":"MulDissociated.subset","module":"Mathlib.Combinatorics.Additive.Dissociation","initialProofState":"α : Type u_1\ninst✝ : CommGroup α\ns t : Set α\nhst : HasSubset.Subset s t\nht : MulDissociated t\n⊢ MulDissociated s","decl":"@[to_additive] lemma MulDissociated.subset {t : Set α} (hst : s ⊆ t) (ht : MulDissociated t) :\n    MulDissociated s := ht.mono fun _ ↦ hst.trans'\n\n"}
{"name":"addDissociated_empty","module":"Mathlib.Combinatorics.Additive.Dissociation","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\n⊢ AddDissociated EmptyCollection.emptyCollection","decl":"@[to_additive (attr := simp)] lemma mulDissociated_empty : MulDissociated (∅ : Set α) := by\n  simp [MulDissociated, subset_empty_iff]\n\n"}
{"name":"mulDissociated_empty","module":"Mathlib.Combinatorics.Additive.Dissociation","initialProofState":"α : Type u_1\ninst✝ : CommGroup α\n⊢ MulDissociated EmptyCollection.emptyCollection","decl":"@[to_additive (attr := simp)] lemma mulDissociated_empty : MulDissociated (∅ : Set α) := by\n  simp [MulDissociated, subset_empty_iff]\n\n"}
{"name":"mulDissociated_singleton","module":"Mathlib.Combinatorics.Additive.Dissociation","initialProofState":"α : Type u_1\ninst✝ : CommGroup α\na : α\n⊢ Iff (MulDissociated (Singleton.singleton a)) (Ne a 1)","decl":"@[to_additive (attr := simp)]\nlemma mulDissociated_singleton : MulDissociated ({a} : Set α) ↔ a ≠ 1 := by\n  simp [MulDissociated, setOf_or, (Finset.singleton_ne_empty _).symm, -subset_singleton_iff,\n    Finset.coe_subset_singleton]\n\n"}
{"name":"addDissociated_singleton","module":"Mathlib.Combinatorics.Additive.Dissociation","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\na : α\n⊢ Iff (AddDissociated (Singleton.singleton a)) (Ne a 0)","decl":"@[to_additive (attr := simp)]\nlemma mulDissociated_singleton : MulDissociated ({a} : Set α) ↔ a ≠ 1 := by\n  simp [MulDissociated, setOf_or, (Finset.singleton_ne_empty _).symm, -subset_singleton_iff,\n    Finset.coe_subset_singleton]\n\n"}
{"name":"not_mulDissociated","module":"Mathlib.Combinatorics.Additive.Dissociation","initialProofState":"α : Type u_1\ninst✝ : CommGroup α\ns : Set α\n⊢ Iff (Not (MulDissociated s)) (Exists fun t => And (HasSubset.Subset (↑t) s) (Exists fun u => And (HasSubset.Subset (↑u) s) (And (Ne t u) (Eq (t.prod fun x => x) (u.prod fun x => x)))))","decl":"@[to_additive (attr := simp)]\nlemma not_mulDissociated :\n    ¬ MulDissociated s ↔\n      ∃ t : Finset α, ↑t ⊆ s ∧ ∃ u : Finset α, ↑u ⊆ s ∧ t ≠ u ∧ ∏ x ∈ t, x = ∏ x ∈ u, x := by\n  simp [MulDissociated, InjOn]; aesop\n\n"}
{"name":"not_addDissociated","module":"Mathlib.Combinatorics.Additive.Dissociation","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\ns : Set α\n⊢ Iff (Not (AddDissociated s)) (Exists fun t => And (HasSubset.Subset (↑t) s) (Exists fun u => And (HasSubset.Subset (↑u) s) (And (Ne t u) (Eq (t.sum fun x => x) (u.sum fun x => x)))))","decl":"@[to_additive (attr := simp)]\nlemma not_mulDissociated :\n    ¬ MulDissociated s ↔\n      ∃ t : Finset α, ↑t ⊆ s ∧ ∃ u : Finset α, ↑u ⊆ s ∧ t ≠ u ∧ ∏ x ∈ t, x = ∏ x ∈ u, x := by\n  simp [MulDissociated, InjOn]; aesop\n\n"}
{"name":"not_addDissociated_iff_exists_disjoint","module":"Mathlib.Combinatorics.Additive.Dissociation","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\ns : Set α\n⊢ Iff (Not (AddDissociated s)) (Exists fun t => Exists fun u => And (HasSubset.Subset (↑t) s) (And (HasSubset.Subset (↑u) s) (And (Disjoint t u) (And (Ne t u) (Eq (t.sum fun a => a) (u.sum fun a => a))))))","decl":"@[to_additive]\nlemma not_mulDissociated_iff_exists_disjoint :\n    ¬ MulDissociated s ↔\n      ∃ t u : Finset α, ↑t ⊆ s ∧ ↑u ⊆ s ∧ Disjoint t u ∧ t ≠ u ∧ ∏ a ∈ t, a = ∏ a ∈ u, a := by\n  classical\n  refine not_mulDissociated.trans\n    ⟨?_, fun ⟨t, u, ht, hu, _, htune, htusum⟩ ↦ ⟨t, ht, u, hu, htune, htusum⟩⟩\n  rintro ⟨t, ht, u, hu, htu, h⟩\n  refine ⟨t \\ u, u \\ t, ?_, ?_, disjoint_sdiff_sdiff, sdiff_ne_sdiff_iff.2 htu,\n    Finset.prod_sdiff_eq_prod_sdiff_iff.2 h⟩ <;> push_cast <;> exact diff_subset.trans ‹_›\n\n"}
{"name":"not_mulDissociated_iff_exists_disjoint","module":"Mathlib.Combinatorics.Additive.Dissociation","initialProofState":"α : Type u_1\ninst✝ : CommGroup α\ns : Set α\n⊢ Iff (Not (MulDissociated s)) (Exists fun t => Exists fun u => And (HasSubset.Subset (↑t) s) (And (HasSubset.Subset (↑u) s) (And (Disjoint t u) (And (Ne t u) (Eq (t.prod fun a => a) (u.prod fun a => a))))))","decl":"@[to_additive]\nlemma not_mulDissociated_iff_exists_disjoint :\n    ¬ MulDissociated s ↔\n      ∃ t u : Finset α, ↑t ⊆ s ∧ ↑u ⊆ s ∧ Disjoint t u ∧ t ≠ u ∧ ∏ a ∈ t, a = ∏ a ∈ u, a := by\n  classical\n  refine not_mulDissociated.trans\n    ⟨?_, fun ⟨t, u, ht, hu, _, htune, htusum⟩ ↦ ⟨t, ht, u, hu, htune, htusum⟩⟩\n  rintro ⟨t, ht, u, hu, htu, h⟩\n  refine ⟨t \\ u, u \\ t, ?_, ?_, disjoint_sdiff_sdiff, sdiff_ne_sdiff_iff.2 htu,\n    Finset.prod_sdiff_eq_prod_sdiff_iff.2 h⟩ <;> push_cast <;> exact diff_subset.trans ‹_›\n\n"}
{"name":"MulEquiv.mulDissociated_preimage","module":"Mathlib.Combinatorics.Additive.Dissociation","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CommGroup α\ninst✝ : CommGroup β\ns : Set α\ne : MulEquiv β α\n⊢ Iff (MulDissociated (Set.preimage (⇑e) s)) (MulDissociated s)","decl":"@[to_additive (attr := simp)] lemma MulEquiv.mulDissociated_preimage (e : β ≃* α) :\n    MulDissociated (e ⁻¹' s) ↔ MulDissociated s := by\n  simp [MulDissociated, InjOn, ← e.finsetCongr.forall_congr_right, ← e.apply_eq_iff_eq,\n    (Finset.map_injective _).eq_iff]\n\n"}
{"name":"AddEquiv.addDissociated_preimage","module":"Mathlib.Combinatorics.Additive.Dissociation","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : AddCommGroup α\ninst✝ : AddCommGroup β\ns : Set α\ne : AddEquiv β α\n⊢ Iff (AddDissociated (Set.preimage (⇑e) s)) (AddDissociated s)","decl":"@[to_additive (attr := simp)] lemma MulEquiv.mulDissociated_preimage (e : β ≃* α) :\n    MulDissociated (e ⁻¹' s) ↔ MulDissociated s := by\n  simp [MulDissociated, InjOn, ← e.finsetCongr.forall_congr_right, ← e.apply_eq_iff_eq,\n    (Finset.map_injective _).eq_iff]\n\n"}
{"name":"addDissociated_neg","module":"Mathlib.Combinatorics.Additive.Dissociation","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\ns : Set α\n⊢ Iff (AddDissociated (Neg.neg s)) (AddDissociated s)","decl":"@[to_additive (attr := simp)] lemma mulDissociated_inv : MulDissociated s⁻¹ ↔ MulDissociated s :=\n  (MulEquiv.inv α).mulDissociated_preimage\n\n"}
{"name":"mulDissociated_inv","module":"Mathlib.Combinatorics.Additive.Dissociation","initialProofState":"α : Type u_1\ninst✝ : CommGroup α\ns : Set α\n⊢ Iff (MulDissociated (Inv.inv s)) (MulDissociated s)","decl":"@[to_additive (attr := simp)] lemma mulDissociated_inv : MulDissociated s⁻¹ ↔ MulDissociated s :=\n  (MulEquiv.inv α).mulDissociated_preimage\n\n"}
{"name":"AddDissociated.neg","module":"Mathlib.Combinatorics.Additive.Dissociation","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\ns : Set α\na✝ : AddDissociated s\n⊢ AddDissociated (Neg.neg s)","decl":"@[to_additive] protected alias ⟨MulDissociated.of_inv, MulDissociated.inv⟩ := mulDissociated_inv\n\n"}
{"name":"MulDissociated.inv","module":"Mathlib.Combinatorics.Additive.Dissociation","initialProofState":"α : Type u_1\ninst✝ : CommGroup α\ns : Set α\na✝ : MulDissociated s\n⊢ MulDissociated (Inv.inv s)","decl":"@[to_additive] protected alias ⟨MulDissociated.of_inv, MulDissociated.inv⟩ := mulDissociated_inv\n\n"}
{"name":"AddDissociated.of_neg","module":"Mathlib.Combinatorics.Additive.Dissociation","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\ns : Set α\na✝ : AddDissociated (Neg.neg s)\n⊢ AddDissociated s","decl":"@[to_additive] protected alias ⟨MulDissociated.of_inv, MulDissociated.inv⟩ := mulDissociated_inv\n\n"}
{"name":"MulDissociated.of_inv","module":"Mathlib.Combinatorics.Additive.Dissociation","initialProofState":"α : Type u_1\ninst✝ : CommGroup α\ns : Set α\na✝ : MulDissociated (Inv.inv s)\n⊢ MulDissociated s","decl":"@[to_additive] protected alias ⟨MulDissociated.of_inv, MulDissociated.inv⟩ := mulDissociated_inv\n\n"}
{"name":"Finset.mem_addSpan","module":"Mathlib.Combinatorics.Additive.Dissociation","initialProofState":"α : Type u_1\ninst✝² : AddCommGroup α\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ns : Finset α\na : α\n⊢ Iff (Membership.mem s.addSpan a) (Exists fun ε => And (∀ (a : α), Or (Eq (ε a) (-1)) (Or (Eq (ε a) 0) (Eq (ε a) 1))) (Eq (s.sum fun a => HSMul.hSMul (ε a) a) a))","decl":"@[to_additive (attr := simp)]\nlemma mem_mulSpan :\n    a ∈ mulSpan s ↔ ∃ ε : α → ℤ, (∀ a, ε a = -1 ∨ ε a = 0 ∨ ε a = 1) ∧ ∏ a ∈ s, a ^ ε a = a := by\n  simp [mulSpan]\n\n"}
{"name":"Finset.mem_mulSpan","module":"Mathlib.Combinatorics.Additive.Dissociation","initialProofState":"α : Type u_1\ninst✝² : CommGroup α\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ns : Finset α\na : α\n⊢ Iff (Membership.mem s.mulSpan a) (Exists fun ε => And (∀ (a : α), Or (Eq (ε a) (-1)) (Or (Eq (ε a) 0) (Eq (ε a) 1))) (Eq (s.prod fun a => HPow.hPow a (ε a)) a))","decl":"@[to_additive (attr := simp)]\nlemma mem_mulSpan :\n    a ∈ mulSpan s ↔ ∃ ε : α → ℤ, (∀ a, ε a = -1 ∨ ε a = 0 ∨ ε a = 1) ∧ ∏ a ∈ s, a ^ ε a = a := by\n  simp [mulSpan]\n\n"}
{"name":"Finset.subset_mulSpan","module":"Mathlib.Combinatorics.Additive.Dissociation","initialProofState":"α : Type u_1\ninst✝² : CommGroup α\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ns : Finset α\n⊢ HasSubset.Subset s s.mulSpan","decl":"@[to_additive (attr := simp)]\nlemma subset_mulSpan : s ⊆ mulSpan s := fun a ha ↦\n  mem_mulSpan.2 ⟨Pi.single a 1, fun b ↦ by obtain rfl | hab := eq_or_ne a b <;> simp [*], by\n    simp [Pi.single, Function.update, pow_ite, ha]⟩\n\n"}
{"name":"Finset.subset_addSpan","module":"Mathlib.Combinatorics.Additive.Dissociation","initialProofState":"α : Type u_1\ninst✝² : AddCommGroup α\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ns : Finset α\n⊢ HasSubset.Subset s s.addSpan","decl":"@[to_additive (attr := simp)]\nlemma subset_mulSpan : s ⊆ mulSpan s := fun a ha ↦\n  mem_mulSpan.2 ⟨Pi.single a 1, fun b ↦ by obtain rfl | hab := eq_or_ne a b <;> simp [*], by\n    simp [Pi.single, Function.update, pow_ite, ha]⟩\n\n"}
{"name":"Finset.sum_sub_sum_mem_addSpan","module":"Mathlib.Combinatorics.Additive.Dissociation","initialProofState":"α : Type u_1\ninst✝² : AddCommGroup α\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ns t u : Finset α\nht : HasSubset.Subset t s\nhu : HasSubset.Subset u s\n⊢ Membership.mem s.addSpan (HSub.hSub (t.sum fun a => a) (u.sum fun a => a))","decl":"@[to_additive]\nlemma prod_div_prod_mem_mulSpan (ht : t ⊆ s) (hu : u ⊆ s) :\n    (∏ a ∈ t, a) / ∏ a ∈ u, a ∈ mulSpan s :=\n  mem_mulSpan.2 ⟨Set.indicator t 1 - Set.indicator u 1, fun a ↦ by\n    by_cases a ∈ t <;> by_cases a ∈ u <;> simp [*], by simp [prod_div_distrib, zpow_sub,\n      ← div_eq_mul_inv, Set.indicator, pow_ite, inter_eq_right.2, *]⟩\n\n"}
{"name":"Finset.prod_div_prod_mem_mulSpan","module":"Mathlib.Combinatorics.Additive.Dissociation","initialProofState":"α : Type u_1\ninst✝² : CommGroup α\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ns t u : Finset α\nht : HasSubset.Subset t s\nhu : HasSubset.Subset u s\n⊢ Membership.mem s.mulSpan (HDiv.hDiv (t.prod fun a => a) (u.prod fun a => a))","decl":"@[to_additive]\nlemma prod_div_prod_mem_mulSpan (ht : t ⊆ s) (hu : u ⊆ s) :\n    (∏ a ∈ t, a) / ∏ a ∈ u, a ∈ mulSpan s :=\n  mem_mulSpan.2 ⟨Set.indicator t 1 - Set.indicator u 1, fun a ↦ by\n    by_cases a ∈ t <;> by_cases a ∈ u <;> simp [*], by simp [prod_div_distrib, zpow_sub,\n      ← div_eq_mul_inv, Set.indicator, pow_ite, inter_eq_right.2, *]⟩\n\n"}
{"name":"Finset.exists_subset_addSpan_card_le_of_forall_addDissociated","module":"Mathlib.Combinatorics.Additive.Dissociation","initialProofState":"α : Type u_1\ninst✝² : AddCommGroup α\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ns : Finset α\nd : Nat\nhs : ∀ (s' : Finset α), HasSubset.Subset s' s → AddDissociated ↑s' → LE.le s'.card d\n⊢ Exists fun s' => And (HasSubset.Subset s' s) (And (LE.le s'.card d) (HasSubset.Subset s s'.addSpan))","decl":"/-- If every dissociated subset of `s` has size at most `d`, then `s` is actually generated by a\nsubset of size at most `d`.\n\nThis is a dissociation analog of the fact that a set whose linearly independent subsets all have\nsize at most `d` is of dimension at most `d` itself. -/\n@[to_additive \"If every dissociated subset of `s` has size at most `d`, then `s` is actually\ngenerated by a subset of size at most `d`.\n\nThis is a dissociation analog of the fact that a set whose linearly independent subspaces all have\nsize at most `d` is of dimension at most `d` itself.\"]\nlemma exists_subset_mulSpan_card_le_of_forall_mulDissociated\n    (hs : ∀ s', s' ⊆ s → MulDissociated (s' : Set α) → s'.card ≤ d) :\n    ∃ s', s' ⊆ s ∧ s'.card ≤ d ∧ s ⊆ mulSpan s' := by\n  classical\n  obtain ⟨s', hs', hs'max⟩ :=\n    exists_maximal (s.powerset.filter fun s' : Finset α ↦ MulDissociated (s' : Set α))\n      ⟨∅, mem_filter.2 ⟨empty_mem_powerset _, by simp⟩⟩\n  simp only [mem_filter, mem_powerset, lt_eq_subset, and_imp] at hs' hs'max\n  refine ⟨s', hs'.1, hs _ hs'.1 hs'.2, fun a ha ↦ ?_⟩\n  by_cases ha' : a ∈ s'\n  · exact subset_mulSpan ha'\n  obtain ⟨t, u, ht, hu, htu⟩ := not_mulDissociated_iff_exists_disjoint.1 fun h ↦\n    hs'max _ (insert_subset_iff.2 ⟨ha, hs'.1⟩) h <| ssubset_insert ha'\n  by_cases hat : a ∈ t\n  · have : a = (∏ b ∈ u, b) / ∏ b ∈ t.erase a, b := by\n      rw [prod_erase_eq_div hat, htu.2.2, div_div_self']\n    rw [this]\n    exact prod_div_prod_mem_mulSpan\n      ((subset_insert_iff_of_not_mem <| disjoint_left.1 htu.1 hat).1 hu) (subset_insert_iff.1 ht)\n  rw [coe_subset, subset_insert_iff_of_not_mem hat] at ht\n  by_cases hau : a ∈ u\n  · have : a = (∏ b ∈ t, b) / ∏ b ∈ u.erase a, b := by\n      rw [prod_erase_eq_div hau, htu.2.2, div_div_self']\n    rw [this]\n    exact prod_div_prod_mem_mulSpan ht (subset_insert_iff.1 hu)\n  · rw [coe_subset, subset_insert_iff_of_not_mem hau] at hu\n    cases not_mulDissociated_iff_exists_disjoint.2 ⟨t, u, ht, hu, htu⟩ hs'.2\n\n"}
{"name":"Finset.exists_subset_mulSpan_card_le_of_forall_mulDissociated","module":"Mathlib.Combinatorics.Additive.Dissociation","initialProofState":"α : Type u_1\ninst✝² : CommGroup α\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ns : Finset α\nd : Nat\nhs : ∀ (s' : Finset α), HasSubset.Subset s' s → MulDissociated ↑s' → LE.le s'.card d\n⊢ Exists fun s' => And (HasSubset.Subset s' s) (And (LE.le s'.card d) (HasSubset.Subset s s'.mulSpan))","decl":"/-- If every dissociated subset of `s` has size at most `d`, then `s` is actually generated by a\nsubset of size at most `d`.\n\nThis is a dissociation analog of the fact that a set whose linearly independent subsets all have\nsize at most `d` is of dimension at most `d` itself. -/\n@[to_additive \"If every dissociated subset of `s` has size at most `d`, then `s` is actually\ngenerated by a subset of size at most `d`.\n\nThis is a dissociation analog of the fact that a set whose linearly independent subspaces all have\nsize at most `d` is of dimension at most `d` itself.\"]\nlemma exists_subset_mulSpan_card_le_of_forall_mulDissociated\n    (hs : ∀ s', s' ⊆ s → MulDissociated (s' : Set α) → s'.card ≤ d) :\n    ∃ s', s' ⊆ s ∧ s'.card ≤ d ∧ s ⊆ mulSpan s' := by\n  classical\n  obtain ⟨s', hs', hs'max⟩ :=\n    exists_maximal (s.powerset.filter fun s' : Finset α ↦ MulDissociated (s' : Set α))\n      ⟨∅, mem_filter.2 ⟨empty_mem_powerset _, by simp⟩⟩\n  simp only [mem_filter, mem_powerset, lt_eq_subset, and_imp] at hs' hs'max\n  refine ⟨s', hs'.1, hs _ hs'.1 hs'.2, fun a ha ↦ ?_⟩\n  by_cases ha' : a ∈ s'\n  · exact subset_mulSpan ha'\n  obtain ⟨t, u, ht, hu, htu⟩ := not_mulDissociated_iff_exists_disjoint.1 fun h ↦\n    hs'max _ (insert_subset_iff.2 ⟨ha, hs'.1⟩) h <| ssubset_insert ha'\n  by_cases hat : a ∈ t\n  · have : a = (∏ b ∈ u, b) / ∏ b ∈ t.erase a, b := by\n      rw [prod_erase_eq_div hat, htu.2.2, div_div_self']\n    rw [this]\n    exact prod_div_prod_mem_mulSpan\n      ((subset_insert_iff_of_not_mem <| disjoint_left.1 htu.1 hat).1 hu) (subset_insert_iff.1 ht)\n  rw [coe_subset, subset_insert_iff_of_not_mem hat] at ht\n  by_cases hau : a ∈ u\n  · have : a = (∏ b ∈ t, b) / ∏ b ∈ u.erase a, b := by\n      rw [prod_erase_eq_div hau, htu.2.2, div_div_self']\n    rw [this]\n    exact prod_div_prod_mem_mulSpan ht (subset_insert_iff.1 hu)\n  · rw [coe_subset, subset_insert_iff_of_not_mem hau] at hu\n    cases not_mulDissociated_iff_exists_disjoint.2 ⟨t, u, ht, hu, htu⟩ hs'.2\n\n"}
