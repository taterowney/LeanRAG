{"name":"Rat.cast_pow","module":"Mathlib.Data.Rat.Cast.Lemmas","initialProofState":"α : Type u_1\ninst✝ : DivisionRing α\np : Rat\nn : Nat\n⊢ Eq (↑(HPow.hPow p n)) (HPow.hPow (↑p) n)","decl":"@[simp, norm_cast]\nlemma cast_pow (p : ℚ) (n : ℕ) : ↑(p ^ n) = (p ^ n : α) := by\n  rw [cast_def, cast_def, den_pow, num_pow, Nat.cast_pow, Int.cast_pow, div_eq_mul_inv, ← inv_pow,\n    ← (Int.cast_commute _ _).mul_pow, ← div_eq_mul_inv]\n\n-- Porting note: rewrote proof\n"}
{"name":"Rat.cast_inv_nat","module":"Mathlib.Data.Rat.Cast.Lemmas","initialProofState":"α : Type u_1\ninst✝ : DivisionRing α\nn : Nat\n⊢ Eq (↑(Inv.inv ↑n)) (Inv.inv ↑n)","decl":"@[simp]\ntheorem cast_inv_nat (n : ℕ) : ((n⁻¹ : ℚ) : α) = (n : α)⁻¹ := by\n  cases' n with n\n  · simp\n  rw [cast_def, inv_natCast_num, inv_natCast_den, if_neg n.succ_ne_zero,\n    Int.sign_eq_one_of_pos (Int.ofNat_succ_pos n), Int.cast_one, one_div]\n\n-- Porting note: proof got a lot easier - is this still the intended statement?\n"}
{"name":"Rat.cast_inv_int","module":"Mathlib.Data.Rat.Cast.Lemmas","initialProofState":"α : Type u_1\ninst✝ : DivisionRing α\nn : Int\n⊢ Eq (↑(Inv.inv ↑n)) (Inv.inv ↑n)","decl":"@[simp]\ntheorem cast_inv_int (n : ℤ) : ((n⁻¹ : ℚ) : α) = (n : α)⁻¹ := by\n  cases' n with n n\n  · simp [ofInt_eq_cast, cast_inv_nat]\n  · simp only [ofInt_eq_cast, Int.cast_negSucc, ← Nat.cast_succ, cast_neg, inv_neg, cast_inv_nat]\n\n"}
{"name":"Rat.cast_nnratCast","module":"Mathlib.Data.Rat.Cast.Lemmas","initialProofState":"K : Type u_2\ninst✝ : DivisionRing K\nq : NNRat\n⊢ Eq ↑↑q ↑q","decl":"@[simp, norm_cast]\ntheorem cast_nnratCast {K} [DivisionRing K] (q : ℚ≥0) :\n    ((q : ℚ) : K) = (q : K) := by\n  rw [Rat.cast_def, NNRat.cast_def, NNRat.cast_def]\n  have hn := @num_div_eq_of_coprime q.num q.den ?hdp q.coprime_num_den\n  on_goal 1 => have hd := @den_div_eq_of_coprime q.num q.den ?hdp q.coprime_num_den\n  case hdp => simpa only [Int.ofNat_pos] using q.den_pos\n  simp only [Int.cast_natCast, Nat.cast_inj] at hn hd\n  rw [hn, hd, Int.cast_natCast]\n\n"}
{"name":"Rat.cast_ofScientific","module":"Mathlib.Data.Rat.Cast.Lemmas","initialProofState":"K : Type u_2\ninst✝ : DivisionRing K\nm : Nat\ns : Bool\ne : Nat\n⊢ Eq (↑(OfScientific.ofScientific m s e)) (OfScientific.ofScientific m s e)","decl":"/-- Casting a scientific literal via `ℚ` is the same as casting directly. -/\n@[simp, norm_cast]\ntheorem cast_ofScientific {K} [DivisionRing K] (m : ℕ) (s : Bool) (e : ℕ) :\n    (OfScientific.ofScientific m s e : ℚ) = (OfScientific.ofScientific m s e : K) := by\n  rw [← NNRat.cast_ofScientific (K := K), ← NNRat.cast_ofScientific, cast_nnratCast]\n\n"}
{"name":"NNRat.cast_pow","module":"Mathlib.Data.Rat.Cast.Lemmas","initialProofState":"K : Type u_1\ninst✝ : DivisionSemiring K\nq : NNRat\nn : Nat\n⊢ Eq (↑(HPow.hPow q n)) (HPow.hPow (↑q) n)","decl":"@[simp, norm_cast]\ntheorem cast_pow {K} [DivisionSemiring K] (q : ℚ≥0) (n : ℕ) :\n    NNRat.cast (q ^ n) = (NNRat.cast q : K) ^ n := by\n  rw [cast_def, cast_def, den_pow, num_pow, Nat.cast_pow, Nat.cast_pow, div_eq_mul_inv, ← inv_pow,\n    ← (Nat.cast_commute _ _).mul_pow, ← div_eq_mul_inv]\n\n"}
{"name":"NNRat.cast_zpow_of_ne_zero","module":"Mathlib.Data.Rat.Cast.Lemmas","initialProofState":"K : Type u_1\ninst✝ : DivisionSemiring K\nq : NNRat\nz : Int\nhq : Ne (↑q.num) 0\n⊢ Eq (↑(HPow.hPow q z)) (HPow.hPow (↑q) z)","decl":"theorem cast_zpow_of_ne_zero {K} [DivisionSemiring K] (q : ℚ≥0) (z : ℤ) (hq : (q.num : K) ≠ 0) :\n    NNRat.cast (q ^ z) = (NNRat.cast q : K) ^ z := by\n  obtain ⟨n, rfl | rfl⟩ := z.eq_nat_or_neg\n  · simp\n  · simp_rw [zpow_neg, zpow_natCast, ← inv_pow, NNRat.cast_pow]\n    congr\n    rw [cast_inv_of_ne_zero hq]\n\n"}
{"name":"NNRat.Nonneg.coe_ofScientific","module":"Mathlib.Data.Rat.Cast.Lemmas","initialProofState":"K : Type u_1\ninst✝ : LinearOrderedField K\nm : Nat\ns : Bool\ne : Nat\n⊢ Eq (↑(OfScientific.ofScientific m s e)) (OfScientific.ofScientific m s e)","decl":"open OfScientific in\ntheorem Nonneg.coe_ofScientific {K} [LinearOrderedField K] (m : ℕ) (s : Bool) (e : ℕ) :\n    (ofScientific m s e : {x : K // 0 ≤ x}).val = ofScientific m s e := rfl\n\n"}
