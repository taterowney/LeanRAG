{"name":"CategoryTheory.Functor.reflects_precoherent","module":"Mathlib.CategoryTheory.Sites.Coherent.ReflectsPrecoherent","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁷ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁶ : CategoryTheory.Category.{u_4, u_2} D\nF : CategoryTheory.Functor C D\ninst✝⁵ : F.PreservesFiniteEffectiveEpiFamilies\ninst✝⁴ : F.ReflectsFiniteEffectiveEpiFamilies\ninst✝³ : F.EffectivelyEnough\ninst✝² : CategoryTheory.Precoherent D\ninst✝¹ : F.Full\ninst✝ : F.Faithful\n⊢ CategoryTheory.Precoherent C","decl":"include F in\nlemma Functor.reflects_precoherent : Precoherent C where\n  pullback {B₁ B₂} f α _ X₁ π₁ _ := by\n    obtain ⟨β, _, Y₂, τ₂, H, i, ι, hh⟩ := Precoherent.pullback (F.map f) _ _\n      (fun a ↦ F.map (π₁ a)) inferInstance\n    refine ⟨β, inferInstance, _, fun b ↦ F.preimage (F.effectiveEpiOver (Y₂ b) ≫ τ₂ b),\n      F.finite_effectiveEpiFamily_of_map _ _ ?_,\n        ⟨i, fun b ↦ F.preimage (F.effectiveEpiOver (Y₂ b) ≫ ι b), ?_⟩⟩\n    · simp only [Functor.map_preimage]\n      infer_instance\n    · intro b\n      apply F.map_injective\n      simp [hh b]\n\n"}
