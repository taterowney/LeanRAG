{"name":"IsCompact.measure_eq_biInf_integral_hasCompactSupport","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"X : Type u_1\ninst✝⁶ : TopologicalSpace X\ninst✝⁵ : MeasurableSpace X\ninst✝⁴ : BorelSpace X\nk : Set X\nhk : IsCompact k\nμ : MeasureTheory.Measure X\ninst✝³ : MeasureTheory.IsFiniteMeasureOnCompacts μ\ninst✝² : μ.InnerRegularCompactLTTop\ninst✝¹ : LocallyCompactSpace X\ninst✝ : RegularSpace X\n⊢ Eq (μ k) (iInf fun f => iInf fun x => iInf fun x => iInf fun x => iInf fun x => ENNReal.ofReal (MeasureTheory.integral μ fun x => f x))","decl":"/-- In a locally compact regular space with an inner regular measure, the measure of a compact\nset `k` is the infimum of the integrals of compactly supported functions equal to `1` on `k`. -/\nlemma IsCompact.measure_eq_biInf_integral_hasCompactSupport\n    {X : Type*} [TopologicalSpace X] [MeasurableSpace X] [BorelSpace X]\n    {k : Set X} (hk : IsCompact k)\n    (μ : Measure X) [IsFiniteMeasureOnCompacts μ] [InnerRegularCompactLTTop μ]\n    [LocallyCompactSpace X] [RegularSpace X] :\n    μ k = ⨅ (f : X → ℝ) (_ : Continuous f) (_ : HasCompactSupport f) (_ : EqOn f 1 k)\n      (_ : 0 ≤ f), ENNReal.ofReal (∫ x, f x ∂μ) := by\n  apply le_antisymm\n  · simp only [le_iInf_iff]\n    intro f f_cont f_comp fk f_nonneg\n    apply (f_cont.integrable_of_hasCompactSupport f_comp).measure_le_integral\n    · exact Eventually.of_forall f_nonneg\n    · exact fun x hx ↦ by simp [fk hx]\n  · apply le_of_forall_lt' (fun r hr ↦ ?_)\n    simp only [iInf_lt_iff, exists_prop, exists_and_left]\n    obtain ⟨U, kU, U_open, mu_U⟩ : ∃ U, k ⊆ U ∧ IsOpen U ∧ μ U < r :=\n      hk.exists_isOpen_lt_of_lt r hr\n    obtain ⟨⟨f, f_cont⟩, fk, fU, f_comp, f_range⟩ : ∃ (f : C(X, ℝ)), EqOn f 1 k ∧ EqOn f 0 Uᶜ\n        ∧ HasCompactSupport f ∧ ∀ (x : X), f x ∈ Icc 0 1 := exists_continuous_one_zero_of_isCompact\n      hk U_open.isClosed_compl (disjoint_compl_right_iff_subset.mpr kU)\n    refine ⟨f, f_cont, f_comp, fk, fun x ↦ (f_range x).1, ?_⟩\n    exact (integral_le_measure (fun x _hx ↦ (f_range x).2) (fun x hx ↦ (fU hx).le)).trans_lt mu_U\n\n"}
{"name":"MeasureTheory.continuous_integral_apply_inv_mul","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninst✝⁸ : TopologicalSpace G\ninst✝⁷ : LocallyCompactSpace G\ninst✝⁶ : Group G\ninst✝⁵ : TopologicalGroup G\ninst✝⁴ : MeasurableSpace G\ninst✝³ : BorelSpace G\nμ : MeasureTheory.Measure G\ninst✝² : MeasureTheory.IsFiniteMeasureOnCompacts μ\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\ng : G → E\nhg : Continuous g\nh'g : HasCompactSupport g\n⊢ Continuous fun x => MeasureTheory.integral μ fun y => g (HMul.hMul (Inv.inv y) x)","decl":"/-- The parameterized integral `x ↦ ∫ y, g (y⁻¹ * x) ∂μ` depends continuously on `y` when `g` is a\ncompactly supported continuous function on a topological group `G`, and `μ` is finite on compact\nsets. -/\n@[to_additive]\nlemma continuous_integral_apply_inv_mul\n    {G : Type*} [TopologicalSpace G] [LocallyCompactSpace G] [Group G] [TopologicalGroup G]\n    [MeasurableSpace G] [BorelSpace G]\n    {μ : Measure G} [IsFiniteMeasureOnCompacts μ] {E : Type*} [NormedAddCommGroup E]\n    [NormedSpace ℝ E] {g : G → E}\n    (hg : Continuous g) (h'g : HasCompactSupport g) :\n    Continuous (fun (x : G) ↦ ∫ y, g (y⁻¹ * x) ∂μ) := by\n  let k := tsupport g\n  have k_comp : IsCompact k := h'g\n  apply continuous_iff_continuousAt.2 (fun x₀ ↦ ?_)\n  obtain ⟨t, t_comp, ht⟩ : ∃ t, IsCompact t ∧ t ∈ 𝓝 x₀ := exists_compact_mem_nhds x₀\n  let k' : Set G := t • k⁻¹\n  have k'_comp : IsCompact k' := t_comp.smul_set k_comp.inv\n  have A : ContinuousOn (fun (x : G) ↦ ∫ y, g (y⁻¹ * x) ∂μ) t := by\n    apply continuousOn_integral_of_compact_support k'_comp\n    · exact (hg.comp (continuous_snd.inv.mul continuous_fst)).continuousOn\n    · intro p x hp hx\n      contrapose! hx\n      refine ⟨p, hp, p⁻¹ * x, ?_, by simp⟩\n      simpa only [Set.mem_inv, mul_inv_rev, inv_inv] using subset_tsupport _ hx\n  exact A.continuousAt ht\n\n"}
{"name":"MeasureTheory.continuous_integral_apply_neg_add","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninst✝⁸ : TopologicalSpace G\ninst✝⁷ : LocallyCompactSpace G\ninst✝⁶ : AddGroup G\ninst✝⁵ : TopologicalAddGroup G\ninst✝⁴ : MeasurableSpace G\ninst✝³ : BorelSpace G\nμ : MeasureTheory.Measure G\ninst✝² : MeasureTheory.IsFiniteMeasureOnCompacts μ\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\ng : G → E\nhg : Continuous g\nh'g : HasCompactSupport g\n⊢ Continuous fun x => MeasureTheory.integral μ fun y => g (HAdd.hAdd (Neg.neg y) x)","decl":"/-- The parameterized integral `x ↦ ∫ y, g (y⁻¹ * x) ∂μ` depends continuously on `y` when `g` is a\ncompactly supported continuous function on a topological group `G`, and `μ` is finite on compact\nsets. -/\n@[to_additive]\nlemma continuous_integral_apply_inv_mul\n    {G : Type*} [TopologicalSpace G] [LocallyCompactSpace G] [Group G] [TopologicalGroup G]\n    [MeasurableSpace G] [BorelSpace G]\n    {μ : Measure G} [IsFiniteMeasureOnCompacts μ] {E : Type*} [NormedAddCommGroup E]\n    [NormedSpace ℝ E] {g : G → E}\n    (hg : Continuous g) (h'g : HasCompactSupport g) :\n    Continuous (fun (x : G) ↦ ∫ y, g (y⁻¹ * x) ∂μ) := by\n  let k := tsupport g\n  have k_comp : IsCompact k := h'g\n  apply continuous_iff_continuousAt.2 (fun x₀ ↦ ?_)\n  obtain ⟨t, t_comp, ht⟩ : ∃ t, IsCompact t ∧ t ∈ 𝓝 x₀ := exists_compact_mem_nhds x₀\n  let k' : Set G := t • k⁻¹\n  have k'_comp : IsCompact k' := t_comp.smul_set k_comp.inv\n  have A : ContinuousOn (fun (x : G) ↦ ∫ y, g (y⁻¹ * x) ∂μ) t := by\n    apply continuousOn_integral_of_compact_support k'_comp\n    · exact (hg.comp (continuous_snd.inv.mul continuous_fst)).continuousOn\n    · intro p x hp hx\n      contrapose! hx\n      refine ⟨p, hp, p⁻¹ * x, ?_, by simp⟩\n      simpa only [Set.mem_inv, mul_inv_rev, inv_inv] using subset_tsupport _ hx\n  exact A.continuousAt ht\n\n"}
{"name":"MeasureTheory.Measure.integral_isMulLeftInvariant_isMulRightInvariant_combo","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninst✝⁹ : TopologicalSpace G\ninst✝⁸ : Group G\ninst✝⁷ : TopologicalGroup G\ninst✝⁶ : MeasurableSpace G\ninst✝⁵ : BorelSpace G\nμ ν : MeasureTheory.Measure G\ninst✝⁴ : MeasureTheory.IsFiniteMeasureOnCompacts μ\ninst✝³ : MeasureTheory.IsFiniteMeasureOnCompacts ν\ninst✝² : μ.IsMulLeftInvariant\ninst✝¹ : ν.IsMulRightInvariant\ninst✝ : ν.IsOpenPosMeasure\nf g : G → Real\nhf : Continuous f\nh'f : HasCompactSupport f\nhg : Continuous g\nh'g : HasCompactSupport g\ng_nonneg : LE.le 0 g\nx₀ : G\ng_pos : Ne (g x₀) 0\n⊢ Eq (MeasureTheory.integral μ fun x => f x) (HMul.hMul (MeasureTheory.integral ν fun y => HMul.hMul (f y) (Inv.inv (MeasureTheory.integral ν fun z => g (HMul.hMul (Inv.inv z) y)))) (MeasureTheory.integral μ fun x => g x))","decl":"/-- In a group with a left invariant measure `μ` and a right invariant measure `ν`, one can express\nintegrals with respect to `μ` as integrals with respect to `ν` up to a constant scaling factor\n(given in the statement as `∫ x, g x ∂μ` where `g` is a fixed reference function) and an\nexplicit density `y ↦ 1/∫ z, g (z⁻¹ * y) ∂ν`. -/\n@[to_additive]\nlemma integral_isMulLeftInvariant_isMulRightInvariant_combo\n    {μ ν : Measure G} [IsFiniteMeasureOnCompacts μ] [IsFiniteMeasureOnCompacts ν]\n    [IsMulLeftInvariant μ] [IsMulRightInvariant ν] [IsOpenPosMeasure ν]\n    {f g : G → ℝ} (hf : Continuous f) (h'f : HasCompactSupport f)\n    (hg : Continuous g) (h'g : HasCompactSupport g) (g_nonneg : 0 ≤ g) {x₀ : G} (g_pos : g x₀ ≠ 0) :\n    ∫ x, f x ∂μ = (∫ y, f y * (∫ z, g (z⁻¹ * y) ∂ν)⁻¹ ∂ν) * ∫ x, g x ∂μ := by\n  -- The group has to be locally compact, otherwise all integrals vanish and the result is trivial.\n  rcases h'f.eq_zero_or_locallyCompactSpace_of_group hf with Hf|Hf\n  · simp [Hf]\n  let D : G → ℝ := fun (x : G) ↦ ∫ y, g (y⁻¹ * x) ∂ν\n  have D_cont : Continuous D := continuous_integral_apply_inv_mul hg h'g\n  have D_pos : ∀ x, 0 < D x := by\n    intro x\n    have C : Continuous (fun y ↦ g (y⁻¹ * x)) := hg.comp (continuous_inv.mul continuous_const)\n    apply (integral_pos_iff_support_of_nonneg _ _).2\n    · apply C.isOpen_support.measure_pos ν\n      exact ⟨x * x₀⁻¹, by simpa using g_pos⟩\n    · exact fun y ↦ g_nonneg (y⁻¹ * x)\n    · apply C.integrable_of_hasCompactSupport\n      exact h'g.comp_homeomorph ((Homeomorph.inv G).trans (Homeomorph.mulRight x))\n  calc\n  ∫ x, f x ∂μ = ∫ x, f x * (D x)⁻¹ * D x ∂μ := by\n    congr with x; rw [mul_assoc, inv_mul_cancel₀ (D_pos x).ne', mul_one]\n  _ = ∫ x, (∫ y, f x * (D x)⁻¹ * g (y⁻¹ * x) ∂ν) ∂μ := by simp_rw [D, integral_mul_left]\n  _ = ∫ y, (∫ x, f x * (D x)⁻¹ * g (y⁻¹ * x) ∂μ) ∂ν := by\n      apply integral_integral_swap_of_hasCompactSupport\n      · apply Continuous.mul\n        · exact (hf.comp continuous_fst).mul\n            ((D_cont.comp continuous_fst).inv₀ (fun x ↦ (D_pos _).ne'))\n        · exact hg.comp (continuous_snd.inv.mul continuous_fst)\n      · let K := tsupport f\n        have K_comp : IsCompact K := h'f\n        let L := tsupport g\n        have L_comp : IsCompact L := h'g\n        let M := (fun (p : G × G) ↦ p.1 * p.2⁻¹) '' (K ×ˢ L)\n        have M_comp : IsCompact M :=\n          (K_comp.prod L_comp).image (continuous_fst.mul continuous_snd.inv)\n        have M'_comp : IsCompact (closure M) := M_comp.closure\n        have : ∀ (p : G × G), p ∉ K ×ˢ closure M → f p.1 * (D p.1)⁻¹ * g (p.2⁻¹ * p.1) = 0 := by\n          rintro ⟨x, y⟩ hxy\n          by_cases H : x ∈ K; swap\n          · simp [image_eq_zero_of_nmem_tsupport H]\n          have : g (y⁻¹ * x) = 0 := by\n            apply image_eq_zero_of_nmem_tsupport\n            contrapose! hxy\n            simp only [mem_prod, H, true_and]\n            apply subset_closure\n            simp only [M, mem_image, mem_prod, Prod.exists]\n            exact ⟨x, y⁻¹ * x, ⟨H, hxy⟩, by group⟩\n          simp [this]\n        apply HasCompactSupport.intro' (K_comp.prod M'_comp) ?_ this\n        exact (isClosed_tsupport f).prod isClosed_closure\n  _ = ∫ y, (∫ x, f (y * x) * (D (y * x))⁻¹ * g x ∂μ) ∂ν := by\n      congr with y\n      rw [← integral_mul_left_eq_self _ y]\n      simp\n  _ = ∫ x, (∫ y, f (y * x) * (D (y * x))⁻¹ * g x ∂ν) ∂μ := by\n      apply (integral_integral_swap_of_hasCompactSupport _ _).symm\n      · apply Continuous.mul ?_ (hg.comp continuous_fst)\n        exact (hf.comp (continuous_snd.mul continuous_fst)).mul\n          ((D_cont.comp (continuous_snd.mul continuous_fst)).inv₀ (fun x ↦ (D_pos _).ne'))\n      · let K := tsupport f\n        have K_comp : IsCompact K := h'f\n        let L := tsupport g\n        have L_comp : IsCompact L := h'g\n        let M := (fun (p : G × G) ↦ p.1 * p.2⁻¹) '' (K ×ˢ L)\n        have M_comp : IsCompact M :=\n          (K_comp.prod L_comp).image (continuous_fst.mul continuous_snd.inv)\n        have M'_comp : IsCompact (closure M) := M_comp.closure\n        have : ∀ (p : G × G), p ∉ L ×ˢ closure M →\n            f (p.2 * p.1) * (D (p.2 * p.1))⁻¹ * g p.1 = 0 := by\n          rintro ⟨x, y⟩ hxy\n          by_cases H : x ∈ L; swap\n          · simp [image_eq_zero_of_nmem_tsupport H]\n          have : f (y * x) = 0 := by\n            apply image_eq_zero_of_nmem_tsupport\n            contrapose! hxy\n            simp only [mem_prod, H, true_and]\n            apply subset_closure\n            simp only [M, mem_image, mem_prod, Prod.exists]\n            exact ⟨y * x, x, ⟨hxy, H⟩, by group⟩\n          simp [this]\n        apply HasCompactSupport.intro' (L_comp.prod M'_comp) ?_ this\n        exact (isClosed_tsupport g).prod isClosed_closure\n  _ = ∫ x, (∫ y, f y * (D y)⁻¹ ∂ν) * g x ∂μ := by\n      simp_rw [integral_mul_right]\n      congr with x\n      conv_rhs => rw [← integral_mul_right_eq_self _ x]\n  _ = (∫ y, f y * (D y)⁻¹ ∂ν) * ∫ x, g x ∂μ := integral_mul_left _ _\n\n"}
{"name":"MeasureTheory.Measure.integral_isAddLeftInvariant_isAddRightInvariant_combo","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninst✝⁹ : TopologicalSpace G\ninst✝⁸ : AddGroup G\ninst✝⁷ : TopologicalAddGroup G\ninst✝⁶ : MeasurableSpace G\ninst✝⁵ : BorelSpace G\nμ ν : MeasureTheory.Measure G\ninst✝⁴ : MeasureTheory.IsFiniteMeasureOnCompacts μ\ninst✝³ : MeasureTheory.IsFiniteMeasureOnCompacts ν\ninst✝² : μ.IsAddLeftInvariant\ninst✝¹ : ν.IsAddRightInvariant\ninst✝ : ν.IsOpenPosMeasure\nf g : G → Real\nhf : Continuous f\nh'f : HasCompactSupport f\nhg : Continuous g\nh'g : HasCompactSupport g\ng_nonneg : LE.le 0 g\nx₀ : G\ng_pos : Ne (g x₀) 0\n⊢ Eq (MeasureTheory.integral μ fun x => f x) (HMul.hMul (MeasureTheory.integral ν fun y => HMul.hMul (f y) (Inv.inv (MeasureTheory.integral ν fun z => g (HAdd.hAdd (Neg.neg z) y)))) (MeasureTheory.integral μ fun x => g x))","decl":"/-- In a group with a left invariant measure `μ` and a right invariant measure `ν`, one can express\nintegrals with respect to `μ` as integrals with respect to `ν` up to a constant scaling factor\n(given in the statement as `∫ x, g x ∂μ` where `g` is a fixed reference function) and an\nexplicit density `y ↦ 1/∫ z, g (z⁻¹ * y) ∂ν`. -/\n@[to_additive]\nlemma integral_isMulLeftInvariant_isMulRightInvariant_combo\n    {μ ν : Measure G} [IsFiniteMeasureOnCompacts μ] [IsFiniteMeasureOnCompacts ν]\n    [IsMulLeftInvariant μ] [IsMulRightInvariant ν] [IsOpenPosMeasure ν]\n    {f g : G → ℝ} (hf : Continuous f) (h'f : HasCompactSupport f)\n    (hg : Continuous g) (h'g : HasCompactSupport g) (g_nonneg : 0 ≤ g) {x₀ : G} (g_pos : g x₀ ≠ 0) :\n    ∫ x, f x ∂μ = (∫ y, f y * (∫ z, g (z⁻¹ * y) ∂ν)⁻¹ ∂ν) * ∫ x, g x ∂μ := by\n  -- The group has to be locally compact, otherwise all integrals vanish and the result is trivial.\n  rcases h'f.eq_zero_or_locallyCompactSpace_of_group hf with Hf|Hf\n  · simp [Hf]\n  let D : G → ℝ := fun (x : G) ↦ ∫ y, g (y⁻¹ * x) ∂ν\n  have D_cont : Continuous D := continuous_integral_apply_inv_mul hg h'g\n  have D_pos : ∀ x, 0 < D x := by\n    intro x\n    have C : Continuous (fun y ↦ g (y⁻¹ * x)) := hg.comp (continuous_inv.mul continuous_const)\n    apply (integral_pos_iff_support_of_nonneg _ _).2\n    · apply C.isOpen_support.measure_pos ν\n      exact ⟨x * x₀⁻¹, by simpa using g_pos⟩\n    · exact fun y ↦ g_nonneg (y⁻¹ * x)\n    · apply C.integrable_of_hasCompactSupport\n      exact h'g.comp_homeomorph ((Homeomorph.inv G).trans (Homeomorph.mulRight x))\n  calc\n  ∫ x, f x ∂μ = ∫ x, f x * (D x)⁻¹ * D x ∂μ := by\n    congr with x; rw [mul_assoc, inv_mul_cancel₀ (D_pos x).ne', mul_one]\n  _ = ∫ x, (∫ y, f x * (D x)⁻¹ * g (y⁻¹ * x) ∂ν) ∂μ := by simp_rw [D, integral_mul_left]\n  _ = ∫ y, (∫ x, f x * (D x)⁻¹ * g (y⁻¹ * x) ∂μ) ∂ν := by\n      apply integral_integral_swap_of_hasCompactSupport\n      · apply Continuous.mul\n        · exact (hf.comp continuous_fst).mul\n            ((D_cont.comp continuous_fst).inv₀ (fun x ↦ (D_pos _).ne'))\n        · exact hg.comp (continuous_snd.inv.mul continuous_fst)\n      · let K := tsupport f\n        have K_comp : IsCompact K := h'f\n        let L := tsupport g\n        have L_comp : IsCompact L := h'g\n        let M := (fun (p : G × G) ↦ p.1 * p.2⁻¹) '' (K ×ˢ L)\n        have M_comp : IsCompact M :=\n          (K_comp.prod L_comp).image (continuous_fst.mul continuous_snd.inv)\n        have M'_comp : IsCompact (closure M) := M_comp.closure\n        have : ∀ (p : G × G), p ∉ K ×ˢ closure M → f p.1 * (D p.1)⁻¹ * g (p.2⁻¹ * p.1) = 0 := by\n          rintro ⟨x, y⟩ hxy\n          by_cases H : x ∈ K; swap\n          · simp [image_eq_zero_of_nmem_tsupport H]\n          have : g (y⁻¹ * x) = 0 := by\n            apply image_eq_zero_of_nmem_tsupport\n            contrapose! hxy\n            simp only [mem_prod, H, true_and]\n            apply subset_closure\n            simp only [M, mem_image, mem_prod, Prod.exists]\n            exact ⟨x, y⁻¹ * x, ⟨H, hxy⟩, by group⟩\n          simp [this]\n        apply HasCompactSupport.intro' (K_comp.prod M'_comp) ?_ this\n        exact (isClosed_tsupport f).prod isClosed_closure\n  _ = ∫ y, (∫ x, f (y * x) * (D (y * x))⁻¹ * g x ∂μ) ∂ν := by\n      congr with y\n      rw [← integral_mul_left_eq_self _ y]\n      simp\n  _ = ∫ x, (∫ y, f (y * x) * (D (y * x))⁻¹ * g x ∂ν) ∂μ := by\n      apply (integral_integral_swap_of_hasCompactSupport _ _).symm\n      · apply Continuous.mul ?_ (hg.comp continuous_fst)\n        exact (hf.comp (continuous_snd.mul continuous_fst)).mul\n          ((D_cont.comp (continuous_snd.mul continuous_fst)).inv₀ (fun x ↦ (D_pos _).ne'))\n      · let K := tsupport f\n        have K_comp : IsCompact K := h'f\n        let L := tsupport g\n        have L_comp : IsCompact L := h'g\n        let M := (fun (p : G × G) ↦ p.1 * p.2⁻¹) '' (K ×ˢ L)\n        have M_comp : IsCompact M :=\n          (K_comp.prod L_comp).image (continuous_fst.mul continuous_snd.inv)\n        have M'_comp : IsCompact (closure M) := M_comp.closure\n        have : ∀ (p : G × G), p ∉ L ×ˢ closure M →\n            f (p.2 * p.1) * (D (p.2 * p.1))⁻¹ * g p.1 = 0 := by\n          rintro ⟨x, y⟩ hxy\n          by_cases H : x ∈ L; swap\n          · simp [image_eq_zero_of_nmem_tsupport H]\n          have : f (y * x) = 0 := by\n            apply image_eq_zero_of_nmem_tsupport\n            contrapose! hxy\n            simp only [mem_prod, H, true_and]\n            apply subset_closure\n            simp only [M, mem_image, mem_prod, Prod.exists]\n            exact ⟨y * x, x, ⟨hxy, H⟩, by group⟩\n          simp [this]\n        apply HasCompactSupport.intro' (L_comp.prod M'_comp) ?_ this\n        exact (isClosed_tsupport g).prod isClosed_closure\n  _ = ∫ x, (∫ y, f y * (D y)⁻¹ ∂ν) * g x ∂μ := by\n      simp_rw [integral_mul_right]\n      congr with x\n      conv_rhs => rw [← integral_mul_right_eq_self _ x]\n  _ = (∫ y, f y * (D y)⁻¹ ∂ν) * ∫ x, g x ∂μ := integral_mul_left _ _\n\n"}
{"name":"MeasureTheory.Measure.exists_integral_isMulLeftInvariant_eq_smul_of_hasCompactSupport","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninst✝⁷ : TopologicalSpace G\ninst✝⁶ : Group G\ninst✝⁵ : TopologicalGroup G\ninst✝⁴ : MeasurableSpace G\ninst✝³ : BorelSpace G\nμ' μ : MeasureTheory.Measure G\ninst✝² : μ.IsHaarMeasure\ninst✝¹ : MeasureTheory.IsFiniteMeasureOnCompacts μ'\ninst✝ : μ'.IsMulLeftInvariant\n⊢ Exists fun c => ∀ (f : G → Real), Continuous f → HasCompactSupport f → Eq (MeasureTheory.integral μ' fun x => f x) (MeasureTheory.integral (HSMul.hSMul c μ) fun x => f x)","decl":"/-- Given two left-invariant measures which are finite on\ncompacts, they coincide in the following sense: they give the same value to the integral of\ncontinuous compactly supported functions, up to a multiplicative constant. -/\n@[to_additive exists_integral_isAddLeftInvariant_eq_smul_of_hasCompactSupport]\nlemma exists_integral_isMulLeftInvariant_eq_smul_of_hasCompactSupport (μ' μ : Measure G)\n    [IsHaarMeasure μ] [IsFiniteMeasureOnCompacts μ'] [IsMulLeftInvariant μ'] :\n    ∃ (c : ℝ≥0), ∀ (f : G → ℝ), Continuous f → HasCompactSupport f →\n      ∫ x, f x ∂μ' = ∫ x, f x ∂(c • μ) := by\n  -- The group has to be locally compact, otherwise all integrals vanish and the result is trivial.\n  by_cases H : LocallyCompactSpace G; swap\n  · refine ⟨0, fun f f_cont f_comp ↦ ?_⟩\n    rcases f_comp.eq_zero_or_locallyCompactSpace_of_group f_cont with hf|hf\n    · simp [hf]\n    · exact (H hf).elim\n  -- Fix some nonzero continuous function with compact support `g`.\n  obtain ⟨⟨g, g_cont⟩, g_comp, g_nonneg, g_one⟩ :\n    ∃ (g : C(G, ℝ)), HasCompactSupport g ∧ 0 ≤ g ∧ g 1 ≠ 0 := exists_continuous_nonneg_pos 1\n  have int_g_pos : 0 < ∫ x, g x ∂μ :=\n    g_cont.integral_pos_of_hasCompactSupport_nonneg_nonzero g_comp g_nonneg g_one\n  -- The proportionality constant we are looking for will be the ratio of the integrals of `g`\n  -- with respect to `μ'` and `μ`.\n  let c : ℝ := (∫ x, g x ∂μ) ⁻¹ * (∫ x, g x ∂μ')\n  have c_nonneg : 0 ≤ c :=\n    mul_nonneg (inv_nonneg.2 (integral_nonneg g_nonneg)) (integral_nonneg g_nonneg)\n  refine ⟨⟨c, c_nonneg⟩, fun f f_cont f_comp ↦ ?_⟩\n  /- use the lemma `integral_mulLeftInvariant_mulRightInvariant_combo` for `μ` and then `μ'`\n  to reexpress the integral of `f` as the integral of `g` times a factor which only depends\n  on a right-invariant measure `ν`. We use `ν = μ.inv` for convenience. -/\n  let ν := μ.inv\n  have A : ∫ x, f x ∂μ = (∫ y, f y * (∫ z, g (z⁻¹ * y) ∂ν)⁻¹ ∂ν) * ∫ x, g x ∂μ :=\n    integral_isMulLeftInvariant_isMulRightInvariant_combo f_cont f_comp g_cont g_comp g_nonneg g_one\n  rw [← mul_inv_eq_iff_eq_mul₀ int_g_pos.ne'] at A\n  have B : ∫ x, f x ∂μ' = (∫ y, f y * (∫ z, g (z⁻¹ * y) ∂ν)⁻¹ ∂ν) * ∫ x, g x ∂μ' :=\n    integral_isMulLeftInvariant_isMulRightInvariant_combo f_cont f_comp g_cont g_comp g_nonneg g_one\n  /- Since the `ν`-factor is the same for `μ` and `μ'`, this gives the result. -/\n  rw [← A, mul_assoc, mul_comm] at B\n  simp [B, integral_smul_nnreal_measure, c, NNReal.smul_def]\n\n"}
{"name":"MeasureTheory.Measure.exists_integral_isAddLeftInvariant_eq_smul_of_hasCompactSupport","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninst✝⁷ : TopologicalSpace G\ninst✝⁶ : AddGroup G\ninst✝⁵ : TopologicalAddGroup G\ninst✝⁴ : MeasurableSpace G\ninst✝³ : BorelSpace G\nμ' μ : MeasureTheory.Measure G\ninst✝² : μ.IsAddHaarMeasure\ninst✝¹ : MeasureTheory.IsFiniteMeasureOnCompacts μ'\ninst✝ : μ'.IsAddLeftInvariant\n⊢ Exists fun c => ∀ (f : G → Real), Continuous f → HasCompactSupport f → Eq (MeasureTheory.integral μ' fun x => f x) (MeasureTheory.integral (HSMul.hSMul c μ) fun x => f x)","decl":"/-- Given two left-invariant measures which are finite on\ncompacts, they coincide in the following sense: they give the same value to the integral of\ncontinuous compactly supported functions, up to a multiplicative constant. -/\n@[to_additive exists_integral_isAddLeftInvariant_eq_smul_of_hasCompactSupport]\nlemma exists_integral_isMulLeftInvariant_eq_smul_of_hasCompactSupport (μ' μ : Measure G)\n    [IsHaarMeasure μ] [IsFiniteMeasureOnCompacts μ'] [IsMulLeftInvariant μ'] :\n    ∃ (c : ℝ≥0), ∀ (f : G → ℝ), Continuous f → HasCompactSupport f →\n      ∫ x, f x ∂μ' = ∫ x, f x ∂(c • μ) := by\n  -- The group has to be locally compact, otherwise all integrals vanish and the result is trivial.\n  by_cases H : LocallyCompactSpace G; swap\n  · refine ⟨0, fun f f_cont f_comp ↦ ?_⟩\n    rcases f_comp.eq_zero_or_locallyCompactSpace_of_group f_cont with hf|hf\n    · simp [hf]\n    · exact (H hf).elim\n  -- Fix some nonzero continuous function with compact support `g`.\n  obtain ⟨⟨g, g_cont⟩, g_comp, g_nonneg, g_one⟩ :\n    ∃ (g : C(G, ℝ)), HasCompactSupport g ∧ 0 ≤ g ∧ g 1 ≠ 0 := exists_continuous_nonneg_pos 1\n  have int_g_pos : 0 < ∫ x, g x ∂μ :=\n    g_cont.integral_pos_of_hasCompactSupport_nonneg_nonzero g_comp g_nonneg g_one\n  -- The proportionality constant we are looking for will be the ratio of the integrals of `g`\n  -- with respect to `μ'` and `μ`.\n  let c : ℝ := (∫ x, g x ∂μ) ⁻¹ * (∫ x, g x ∂μ')\n  have c_nonneg : 0 ≤ c :=\n    mul_nonneg (inv_nonneg.2 (integral_nonneg g_nonneg)) (integral_nonneg g_nonneg)\n  refine ⟨⟨c, c_nonneg⟩, fun f f_cont f_comp ↦ ?_⟩\n  /- use the lemma `integral_mulLeftInvariant_mulRightInvariant_combo` for `μ` and then `μ'`\n  to reexpress the integral of `f` as the integral of `g` times a factor which only depends\n  on a right-invariant measure `ν`. We use `ν = μ.inv` for convenience. -/\n  let ν := μ.inv\n  have A : ∫ x, f x ∂μ = (∫ y, f y * (∫ z, g (z⁻¹ * y) ∂ν)⁻¹ ∂ν) * ∫ x, g x ∂μ :=\n    integral_isMulLeftInvariant_isMulRightInvariant_combo f_cont f_comp g_cont g_comp g_nonneg g_one\n  rw [← mul_inv_eq_iff_eq_mul₀ int_g_pos.ne'] at A\n  have B : ∫ x, f x ∂μ' = (∫ y, f y * (∫ z, g (z⁻¹ * y) ∂ν)⁻¹ ∂ν) * ∫ x, g x ∂μ' :=\n    integral_isMulLeftInvariant_isMulRightInvariant_combo f_cont f_comp g_cont g_comp g_nonneg g_one\n  /- Since the `ν`-factor is the same for `μ` and `μ'`, this gives the result. -/\n  rw [← A, mul_assoc, mul_comm] at B\n  simp [B, integral_smul_nnreal_measure, c, NNReal.smul_def]\n\n"}
{"name":"MeasureTheory.Measure.integral_isMulLeftInvariant_eq_smul_of_hasCompactSupport","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninst✝⁷ : TopologicalSpace G\ninst✝⁶ : Group G\ninst✝⁵ : TopologicalGroup G\ninst✝⁴ : MeasurableSpace G\ninst✝³ : BorelSpace G\nμ' μ : MeasureTheory.Measure G\ninst✝² : μ.IsHaarMeasure\ninst✝¹ : MeasureTheory.IsFiniteMeasureOnCompacts μ'\ninst✝ : μ'.IsMulLeftInvariant\nf : G → Real\nhf : Continuous f\nh'f : HasCompactSupport f\n⊢ Eq (MeasureTheory.integral μ' fun x => f x) (MeasureTheory.integral (HSMul.hSMul (μ'.haarScalarFactor μ) μ) fun x => f x)","decl":"/-- Two left invariant measures integrate in the same way continuous compactly supported functions,\nup to the scalar `haarScalarFactor μ' μ`. See also\n`measure_isMulInvariant_eq_smul_of_isCompact_closure`, which gives the same result for compact\nsets, and `measure_isHaarMeasure_eq_smul_of_isOpen` for open sets. -/\n@[to_additive integral_isAddLeftInvariant_eq_smul_of_hasCompactSupport\n\"Two left invariant measures integrate in the same way continuous compactly supported functions,\nup to the scalar `addHaarScalarFactor μ' μ`. See also\n`measure_isAddInvariant_eq_smul_of_isCompact_closure`, which gives the same result for compact\nsets, and `measure_isAddHaarMeasure_eq_smul_of_isOpen` for open sets.\"]\ntheorem integral_isMulLeftInvariant_eq_smul_of_hasCompactSupport\n    (μ' μ : Measure G) [IsHaarMeasure μ] [IsFiniteMeasureOnCompacts μ'] [IsMulLeftInvariant μ']\n    {f : G → ℝ} (hf : Continuous f) (h'f : HasCompactSupport f) :\n    ∫ x, f x ∂μ' = ∫ x, f x ∂(haarScalarFactor μ' μ • μ) := by\n  classical\n  rcases h'f.eq_zero_or_locallyCompactSpace_of_group hf with Hf|Hf\n  · simp [Hf]\n  · simp only [haarScalarFactor, Hf, not_true_eq_false, ite_false]\n    exact (exists_integral_isMulLeftInvariant_eq_smul_of_hasCompactSupport μ' μ).choose_spec\n      f hf h'f\n\n"}
{"name":"MeasureTheory.Measure.integral_isAddLeftInvariant_eq_smul_of_hasCompactSupport","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninst✝⁷ : TopologicalSpace G\ninst✝⁶ : AddGroup G\ninst✝⁵ : TopologicalAddGroup G\ninst✝⁴ : MeasurableSpace G\ninst✝³ : BorelSpace G\nμ' μ : MeasureTheory.Measure G\ninst✝² : μ.IsAddHaarMeasure\ninst✝¹ : MeasureTheory.IsFiniteMeasureOnCompacts μ'\ninst✝ : μ'.IsAddLeftInvariant\nf : G → Real\nhf : Continuous f\nh'f : HasCompactSupport f\n⊢ Eq (MeasureTheory.integral μ' fun x => f x) (MeasureTheory.integral (HSMul.hSMul (μ'.addHaarScalarFactor μ) μ) fun x => f x)","decl":"/-- Two left invariant measures integrate in the same way continuous compactly supported functions,\nup to the scalar `haarScalarFactor μ' μ`. See also\n`measure_isMulInvariant_eq_smul_of_isCompact_closure`, which gives the same result for compact\nsets, and `measure_isHaarMeasure_eq_smul_of_isOpen` for open sets. -/\n@[to_additive integral_isAddLeftInvariant_eq_smul_of_hasCompactSupport\n\"Two left invariant measures integrate in the same way continuous compactly supported functions,\nup to the scalar `addHaarScalarFactor μ' μ`. See also\n`measure_isAddInvariant_eq_smul_of_isCompact_closure`, which gives the same result for compact\nsets, and `measure_isAddHaarMeasure_eq_smul_of_isOpen` for open sets.\"]\ntheorem integral_isMulLeftInvariant_eq_smul_of_hasCompactSupport\n    (μ' μ : Measure G) [IsHaarMeasure μ] [IsFiniteMeasureOnCompacts μ'] [IsMulLeftInvariant μ']\n    {f : G → ℝ} (hf : Continuous f) (h'f : HasCompactSupport f) :\n    ∫ x, f x ∂μ' = ∫ x, f x ∂(haarScalarFactor μ' μ • μ) := by\n  classical\n  rcases h'f.eq_zero_or_locallyCompactSpace_of_group hf with Hf|Hf\n  · simp [Hf]\n  · simp only [haarScalarFactor, Hf, not_true_eq_false, ite_false]\n    exact (exists_integral_isMulLeftInvariant_eq_smul_of_hasCompactSupport μ' μ).choose_spec\n      f hf h'f\n\n"}
{"name":"MeasureTheory.Measure.addHaarScalarFactor_eq_integral_div","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninst✝⁷ : TopologicalSpace G\ninst✝⁶ : AddGroup G\ninst✝⁵ : TopologicalAddGroup G\ninst✝⁴ : MeasurableSpace G\ninst✝³ : BorelSpace G\nμ' μ : MeasureTheory.Measure G\ninst✝² : μ.IsAddHaarMeasure\ninst✝¹ : MeasureTheory.IsFiniteMeasureOnCompacts μ'\ninst✝ : μ'.IsAddLeftInvariant\nf : G → Real\nhf : Continuous f\nh'f : HasCompactSupport f\nint_nonzero : Ne (MeasureTheory.integral μ fun x => f x) 0\n⊢ Eq (↑(μ'.addHaarScalarFactor μ)) (HDiv.hDiv (MeasureTheory.integral μ' fun x => f x) (MeasureTheory.integral μ fun x => f x))","decl":"@[to_additive addHaarScalarFactor_eq_integral_div]\nlemma haarScalarFactor_eq_integral_div (μ' μ : Measure G) [IsHaarMeasure μ]\n    [IsFiniteMeasureOnCompacts μ'] [IsMulLeftInvariant μ'] {f : G → ℝ} (hf : Continuous f)\n    (h'f : HasCompactSupport f) (int_nonzero : ∫ x, f x ∂μ ≠ 0) :\n    haarScalarFactor μ' μ = (∫ x, f x ∂μ') / ∫ x, f x ∂μ := by\n  have := integral_isMulLeftInvariant_eq_smul_of_hasCompactSupport μ' μ hf h'f\n  rw [integral_smul_nnreal_measure] at this\n  exact EuclideanDomain.eq_div_of_mul_eq_left int_nonzero this.symm\n\n"}
{"name":"MeasureTheory.Measure.haarScalarFactor_eq_integral_div","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninst✝⁷ : TopologicalSpace G\ninst✝⁶ : Group G\ninst✝⁵ : TopologicalGroup G\ninst✝⁴ : MeasurableSpace G\ninst✝³ : BorelSpace G\nμ' μ : MeasureTheory.Measure G\ninst✝² : μ.IsHaarMeasure\ninst✝¹ : MeasureTheory.IsFiniteMeasureOnCompacts μ'\ninst✝ : μ'.IsMulLeftInvariant\nf : G → Real\nhf : Continuous f\nh'f : HasCompactSupport f\nint_nonzero : Ne (MeasureTheory.integral μ fun x => f x) 0\n⊢ Eq (↑(μ'.haarScalarFactor μ)) (HDiv.hDiv (MeasureTheory.integral μ' fun x => f x) (MeasureTheory.integral μ fun x => f x))","decl":"@[to_additive addHaarScalarFactor_eq_integral_div]\nlemma haarScalarFactor_eq_integral_div (μ' μ : Measure G) [IsHaarMeasure μ]\n    [IsFiniteMeasureOnCompacts μ'] [IsMulLeftInvariant μ'] {f : G → ℝ} (hf : Continuous f)\n    (h'f : HasCompactSupport f) (int_nonzero : ∫ x, f x ∂μ ≠ 0) :\n    haarScalarFactor μ' μ = (∫ x, f x ∂μ') / ∫ x, f x ∂μ := by\n  have := integral_isMulLeftInvariant_eq_smul_of_hasCompactSupport μ' μ hf h'f\n  rw [integral_smul_nnreal_measure] at this\n  exact EuclideanDomain.eq_div_of_mul_eq_left int_nonzero this.symm\n\n"}
{"name":"MeasureTheory.Measure.addHaarScalarFactor_smul","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninst✝⁸ : TopologicalSpace G\ninst✝⁷ : AddGroup G\ninst✝⁶ : TopologicalAddGroup G\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : BorelSpace G\ninst✝³ : LocallyCompactSpace G\nμ' μ : MeasureTheory.Measure G\ninst✝² : μ.IsAddHaarMeasure\ninst✝¹ : MeasureTheory.IsFiniteMeasureOnCompacts μ'\ninst✝ : μ'.IsAddLeftInvariant\nc : NNReal\n⊢ Eq ((HSMul.hSMul c μ').addHaarScalarFactor μ) (HSMul.hSMul c (μ'.addHaarScalarFactor μ))","decl":"@[to_additive (attr := simp) addHaarScalarFactor_smul]\nlemma haarScalarFactor_smul [LocallyCompactSpace G] (μ' μ : Measure G) [IsHaarMeasure μ]\n    [IsFiniteMeasureOnCompacts μ'] [IsMulLeftInvariant μ'] {c : ℝ≥0} :\n    haarScalarFactor (c • μ') μ = c • haarScalarFactor μ' μ := by\n  obtain ⟨⟨g, g_cont⟩, g_comp, g_nonneg, g_one⟩ :\n    ∃ g : C(G, ℝ), HasCompactSupport g ∧ 0 ≤ g ∧ g 1 ≠ 0 := exists_continuous_nonneg_pos 1\n  have int_g_ne_zero : ∫ x, g x ∂μ ≠ 0 :=\n    ne_of_gt (g_cont.integral_pos_of_hasCompactSupport_nonneg_nonzero g_comp g_nonneg g_one)\n  apply NNReal.coe_injective\n  calc\n    haarScalarFactor (c • μ') μ = (∫ x, g x ∂(c • μ')) / ∫ x, g x ∂μ :=\n      haarScalarFactor_eq_integral_div _ _ g_cont g_comp int_g_ne_zero\n    _ = (c • (∫ x, g x ∂μ')) / ∫ x, g x ∂μ := by simp\n    _ = c • ((∫ x, g x ∂μ') / ∫ x, g x ∂μ) := smul_div_assoc c _ _\n    _ = c • haarScalarFactor μ' μ := by\n      rw [← haarScalarFactor_eq_integral_div _ _ g_cont g_comp int_g_ne_zero]\n\n"}
{"name":"MeasureTheory.Measure.haarScalarFactor_smul","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninst✝⁸ : TopologicalSpace G\ninst✝⁷ : Group G\ninst✝⁶ : TopologicalGroup G\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : BorelSpace G\ninst✝³ : LocallyCompactSpace G\nμ' μ : MeasureTheory.Measure G\ninst✝² : μ.IsHaarMeasure\ninst✝¹ : MeasureTheory.IsFiniteMeasureOnCompacts μ'\ninst✝ : μ'.IsMulLeftInvariant\nc : NNReal\n⊢ Eq ((HSMul.hSMul c μ').haarScalarFactor μ) (HSMul.hSMul c (μ'.haarScalarFactor μ))","decl":"@[to_additive (attr := simp) addHaarScalarFactor_smul]\nlemma haarScalarFactor_smul [LocallyCompactSpace G] (μ' μ : Measure G) [IsHaarMeasure μ]\n    [IsFiniteMeasureOnCompacts μ'] [IsMulLeftInvariant μ'] {c : ℝ≥0} :\n    haarScalarFactor (c • μ') μ = c • haarScalarFactor μ' μ := by\n  obtain ⟨⟨g, g_cont⟩, g_comp, g_nonneg, g_one⟩ :\n    ∃ g : C(G, ℝ), HasCompactSupport g ∧ 0 ≤ g ∧ g 1 ≠ 0 := exists_continuous_nonneg_pos 1\n  have int_g_ne_zero : ∫ x, g x ∂μ ≠ 0 :=\n    ne_of_gt (g_cont.integral_pos_of_hasCompactSupport_nonneg_nonzero g_comp g_nonneg g_one)\n  apply NNReal.coe_injective\n  calc\n    haarScalarFactor (c • μ') μ = (∫ x, g x ∂(c • μ')) / ∫ x, g x ∂μ :=\n      haarScalarFactor_eq_integral_div _ _ g_cont g_comp int_g_ne_zero\n    _ = (c • (∫ x, g x ∂μ')) / ∫ x, g x ∂μ := by simp\n    _ = c • ((∫ x, g x ∂μ') / ∫ x, g x ∂μ) := smul_div_assoc c _ _\n    _ = c • haarScalarFactor μ' μ := by\n      rw [← haarScalarFactor_eq_integral_div _ _ g_cont g_comp int_g_ne_zero]\n\n"}
{"name":"MeasureTheory.Measure.addHaarScalarFactor_self","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninst✝⁵ : TopologicalSpace G\ninst✝⁴ : AddGroup G\ninst✝³ : TopologicalAddGroup G\ninst✝² : MeasurableSpace G\ninst✝¹ : BorelSpace G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsAddHaarMeasure\n⊢ Eq (μ.addHaarScalarFactor μ) 1","decl":"@[to_additive (attr := simp)]\nlemma haarScalarFactor_self (μ : Measure G) [IsHaarMeasure μ] :\n    haarScalarFactor μ μ = 1 := by\n  by_cases hG : LocallyCompactSpace G; swap\n  · simp [haarScalarFactor, hG]\n  obtain ⟨⟨g, g_cont⟩, g_comp, g_nonneg, g_one⟩ :\n    ∃ g : C(G, ℝ), HasCompactSupport g ∧ 0 ≤ g ∧ g 1 ≠ 0 := exists_continuous_nonneg_pos 1\n  have int_g_ne_zero : ∫ x, g x ∂μ ≠ 0 :=\n    ne_of_gt (g_cont.integral_pos_of_hasCompactSupport_nonneg_nonzero g_comp g_nonneg g_one)\n  apply NNReal.coe_injective\n  calc\n    haarScalarFactor μ μ = (∫ x, g x ∂μ) / ∫ x, g x ∂μ :=\n      haarScalarFactor_eq_integral_div _ _ g_cont g_comp int_g_ne_zero\n    _ = 1 := div_self int_g_ne_zero\n\n"}
{"name":"MeasureTheory.Measure.haarScalarFactor_self","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninst✝⁵ : TopologicalSpace G\ninst✝⁴ : Group G\ninst✝³ : TopologicalGroup G\ninst✝² : MeasurableSpace G\ninst✝¹ : BorelSpace G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsHaarMeasure\n⊢ Eq (μ.haarScalarFactor μ) 1","decl":"@[to_additive (attr := simp)]\nlemma haarScalarFactor_self (μ : Measure G) [IsHaarMeasure μ] :\n    haarScalarFactor μ μ = 1 := by\n  by_cases hG : LocallyCompactSpace G; swap\n  · simp [haarScalarFactor, hG]\n  obtain ⟨⟨g, g_cont⟩, g_comp, g_nonneg, g_one⟩ :\n    ∃ g : C(G, ℝ), HasCompactSupport g ∧ 0 ≤ g ∧ g 1 ≠ 0 := exists_continuous_nonneg_pos 1\n  have int_g_ne_zero : ∫ x, g x ∂μ ≠ 0 :=\n    ne_of_gt (g_cont.integral_pos_of_hasCompactSupport_nonneg_nonzero g_comp g_nonneg g_one)\n  apply NNReal.coe_injective\n  calc\n    haarScalarFactor μ μ = (∫ x, g x ∂μ) / ∫ x, g x ∂μ :=\n      haarScalarFactor_eq_integral_div _ _ g_cont g_comp int_g_ne_zero\n    _ = 1 := div_self int_g_ne_zero\n\n"}
{"name":"MeasureTheory.Measure.addHaarScalarFactor_eq_mul","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninst✝⁸ : TopologicalSpace G\ninst✝⁷ : AddGroup G\ninst✝⁶ : TopologicalAddGroup G\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : BorelSpace G\nμ' μ ν : MeasureTheory.Measure G\ninst✝³ : μ.IsAddHaarMeasure\ninst✝² : ν.IsAddHaarMeasure\ninst✝¹ : MeasureTheory.IsFiniteMeasureOnCompacts μ'\ninst✝ : μ'.IsAddLeftInvariant\n⊢ Eq (μ'.addHaarScalarFactor ν) (HMul.hMul (μ'.addHaarScalarFactor μ) (μ.addHaarScalarFactor ν))","decl":"@[to_additive addHaarScalarFactor_eq_mul]\nlemma haarScalarFactor_eq_mul (μ' μ ν : Measure G)\n    [IsHaarMeasure μ] [IsHaarMeasure ν] [IsFiniteMeasureOnCompacts μ'] [IsMulLeftInvariant μ'] :\n    haarScalarFactor μ' ν = haarScalarFactor μ' μ * haarScalarFactor μ ν := by\n  -- The group has to be locally compact, otherwise the scalar factor is 1 by definition.\n  by_cases hG : LocallyCompactSpace G; swap\n  · simp [haarScalarFactor, hG]\n  -- Fix some nonzero continuous function with compact support `g`.\n  obtain ⟨⟨g, g_cont⟩, g_comp, g_nonneg, g_one⟩ :\n    ∃ (g : C(G, ℝ)), HasCompactSupport g ∧ 0 ≤ g ∧ g 1 ≠ 0 := exists_continuous_nonneg_pos 1\n  have Z := integral_isMulLeftInvariant_eq_smul_of_hasCompactSupport μ' μ g_cont g_comp\n  simp only [integral_smul_nnreal_measure, smul_smul,\n    integral_isMulLeftInvariant_eq_smul_of_hasCompactSupport μ' ν g_cont g_comp,\n    integral_isMulLeftInvariant_eq_smul_of_hasCompactSupport μ ν g_cont g_comp] at Z\n  have int_g_pos : 0 < ∫ x, g x ∂ν := by\n    apply (integral_pos_iff_support_of_nonneg g_nonneg _).2\n    · exact IsOpen.measure_pos ν g_cont.isOpen_support ⟨1, g_one⟩\n    · exact g_cont.integrable_of_hasCompactSupport g_comp\n  change (haarScalarFactor μ' ν : ℝ) * ∫ (x : G), g x ∂ν =\n    (haarScalarFactor μ' μ * haarScalarFactor μ ν : ℝ≥0) * ∫ (x : G), g x ∂ν at Z\n  simpa only [mul_eq_mul_right_iff (M₀ := ℝ), int_g_pos.ne', or_false, ← NNReal.eq_iff] using Z\n\n"}
{"name":"MeasureTheory.Measure.haarScalarFactor_eq_mul","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninst✝⁸ : TopologicalSpace G\ninst✝⁷ : Group G\ninst✝⁶ : TopologicalGroup G\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : BorelSpace G\nμ' μ ν : MeasureTheory.Measure G\ninst✝³ : μ.IsHaarMeasure\ninst✝² : ν.IsHaarMeasure\ninst✝¹ : MeasureTheory.IsFiniteMeasureOnCompacts μ'\ninst✝ : μ'.IsMulLeftInvariant\n⊢ Eq (μ'.haarScalarFactor ν) (HMul.hMul (μ'.haarScalarFactor μ) (μ.haarScalarFactor ν))","decl":"@[to_additive addHaarScalarFactor_eq_mul]\nlemma haarScalarFactor_eq_mul (μ' μ ν : Measure G)\n    [IsHaarMeasure μ] [IsHaarMeasure ν] [IsFiniteMeasureOnCompacts μ'] [IsMulLeftInvariant μ'] :\n    haarScalarFactor μ' ν = haarScalarFactor μ' μ * haarScalarFactor μ ν := by\n  -- The group has to be locally compact, otherwise the scalar factor is 1 by definition.\n  by_cases hG : LocallyCompactSpace G; swap\n  · simp [haarScalarFactor, hG]\n  -- Fix some nonzero continuous function with compact support `g`.\n  obtain ⟨⟨g, g_cont⟩, g_comp, g_nonneg, g_one⟩ :\n    ∃ (g : C(G, ℝ)), HasCompactSupport g ∧ 0 ≤ g ∧ g 1 ≠ 0 := exists_continuous_nonneg_pos 1\n  have Z := integral_isMulLeftInvariant_eq_smul_of_hasCompactSupport μ' μ g_cont g_comp\n  simp only [integral_smul_nnreal_measure, smul_smul,\n    integral_isMulLeftInvariant_eq_smul_of_hasCompactSupport μ' ν g_cont g_comp,\n    integral_isMulLeftInvariant_eq_smul_of_hasCompactSupport μ ν g_cont g_comp] at Z\n  have int_g_pos : 0 < ∫ x, g x ∂ν := by\n    apply (integral_pos_iff_support_of_nonneg g_nonneg _).2\n    · exact IsOpen.measure_pos ν g_cont.isOpen_support ⟨1, g_one⟩\n    · exact g_cont.integrable_of_hasCompactSupport g_comp\n  change (haarScalarFactor μ' ν : ℝ) * ∫ (x : G), g x ∂ν =\n    (haarScalarFactor μ' μ * haarScalarFactor μ ν : ℝ≥0) * ∫ (x : G), g x ∂ν at Z\n  simpa only [mul_eq_mul_right_iff (M₀ := ℝ), int_g_pos.ne', or_false, ← NNReal.eq_iff] using Z\n\n"}
{"name":"MeasureTheory.Measure.addHaarScalarFactor_eq_add","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninst✝⁸ : TopologicalSpace G\ninst✝⁷ : AddGroup G\ninst✝⁶ : TopologicalAddGroup G\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : BorelSpace G\nμ' μ ν : MeasureTheory.Measure G\ninst✝³ : μ.IsAddHaarMeasure\ninst✝² : ν.IsAddHaarMeasure\ninst✝¹ : MeasureTheory.IsFiniteMeasureOnCompacts μ'\ninst✝ : μ'.IsAddLeftInvariant\n⊢ Eq (μ'.addHaarScalarFactor ν) (HMul.hMul (μ'.addHaarScalarFactor μ) (μ.addHaarScalarFactor ν))","decl":"@[deprecated (since := \"2024-11-05\")] alias addHaarScalarFactor_eq_add := addHaarScalarFactor_eq_mul\n\n"}
{"name":"MeasureTheory.Measure.addHaarScalarFactor_pos_of_isAddHaarMeasure","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninst✝⁶ : TopologicalSpace G\ninst✝⁵ : AddGroup G\ninst✝⁴ : TopologicalAddGroup G\ninst✝³ : MeasurableSpace G\ninst✝² : BorelSpace G\nμ' μ : MeasureTheory.Measure G\ninst✝¹ : μ.IsAddHaarMeasure\ninst✝ : μ'.IsAddHaarMeasure\n⊢ LT.lt 0 (μ'.addHaarScalarFactor μ)","decl":"/-- The scalar factor between two left-invariant measures is non-zero when both measures are\npositive on open sets. -/\n@[to_additive]\nlemma haarScalarFactor_pos_of_isHaarMeasure (μ' μ : Measure G) [IsHaarMeasure μ]\n    [IsHaarMeasure μ'] : 0 < haarScalarFactor μ' μ :=\n  pos_iff_ne_zero.2 (fun H ↦ by simpa [H] using haarScalarFactor_eq_mul μ' μ μ')\n\n"}
{"name":"MeasureTheory.Measure.haarScalarFactor_pos_of_isHaarMeasure","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninst✝⁶ : TopologicalSpace G\ninst✝⁵ : Group G\ninst✝⁴ : TopologicalGroup G\ninst✝³ : MeasurableSpace G\ninst✝² : BorelSpace G\nμ' μ : MeasureTheory.Measure G\ninst✝¹ : μ.IsHaarMeasure\ninst✝ : μ'.IsHaarMeasure\n⊢ LT.lt 0 (μ'.haarScalarFactor μ)","decl":"/-- The scalar factor between two left-invariant measures is non-zero when both measures are\npositive on open sets. -/\n@[to_additive]\nlemma haarScalarFactor_pos_of_isHaarMeasure (μ' μ : Measure G) [IsHaarMeasure μ]\n    [IsHaarMeasure μ'] : 0 < haarScalarFactor μ' μ :=\n  pos_iff_ne_zero.2 (fun H ↦ by simpa [H] using haarScalarFactor_eq_mul μ' μ μ')\n\n"}
{"name":"MeasureTheory.Measure.measure_preimage_isAddLeftInvariant_eq_smul_of_hasCompactSupport","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninst✝⁷ : TopologicalSpace G\ninst✝⁶ : AddGroup G\ninst✝⁵ : TopologicalAddGroup G\ninst✝⁴ : MeasurableSpace G\ninst✝³ : BorelSpace G\nμ' μ : MeasureTheory.Measure G\ninst✝² : μ.IsAddHaarMeasure\ninst✝¹ : MeasureTheory.IsFiniteMeasureOnCompacts μ'\ninst✝ : μ'.IsAddLeftInvariant\nf : G → Real\nhf : Continuous f\nh'f : HasCompactSupport f\n⊢ Eq (μ' (Set.preimage f (Singleton.singleton 1))) (HSMul.hSMul (μ'.addHaarScalarFactor μ) (μ (Set.preimage f (Singleton.singleton 1))))","decl":"/-- Two left invariant measures give the same mass to level sets of continuous compactly supported\nfunctions, up to the scalar `haarScalarFactor μ' μ`.\n\nAuxiliary lemma in the proof of the more general\n`measure_isMulInvariant_eq_smul_of_isCompact_closure`, which works for any set with\ncompact closure. -/\n@[to_additive measure_preimage_isAddLeftInvariant_eq_smul_of_hasCompactSupport\n\"Two left invariant measures give the same mass to level sets of continuous compactly supported\nfunctions, up to the scalar `addHaarScalarFactor μ' μ`.\n\nAuxiliary lemma in the proof of the more general\n`measure_isAddInvariant_eq_smul_of_isCompact_closure`, which works for any set with\ncompact closure.\"]\nlemma measure_preimage_isMulLeftInvariant_eq_smul_of_hasCompactSupport\n    (μ' μ : Measure G) [IsHaarMeasure μ] [IsFiniteMeasureOnCompacts μ'] [IsMulLeftInvariant μ']\n    {f : G → ℝ} (hf : Continuous f) (h'f : HasCompactSupport f) :\n    μ' (f ⁻¹' {1}) = haarScalarFactor μ' μ • μ (f ⁻¹' {1}) := by\n  /- This follows from the fact that the two measures integrate in the same way continuous\n  functions, by approximating the indicator function of `f ⁻¹' {1}` by continuous functions\n  (namely `vₙ ∘ f` where `vₙ` is equal to `1` at `1`, and `0` outside of a small neighborhood\n  `(1 - uₙ, 1 + uₙ)` where `uₙ` is a sequence tending to `0`).\n  We use `vₙ = thickenedIndicator uₙ {1}` to take advantage of existing lemmas. -/\n  obtain ⟨u, -, u_mem, u_lim⟩ : ∃ u, StrictAnti u ∧ (∀ (n : ℕ), u n ∈ Ioo 0 1)\n    ∧ Tendsto u atTop (𝓝 0) := exists_seq_strictAnti_tendsto' (zero_lt_one : (0 : ℝ) < 1)\n  let v : ℕ → ℝ → ℝ := fun n x ↦ thickenedIndicator (u_mem n).1 ({1} : Set ℝ) x\n  have vf_cont n : Continuous ((v n) ∘ f) := by\n    apply Continuous.comp (continuous_induced_dom.comp ?_) hf\n    exact BoundedContinuousFunction.continuous (thickenedIndicator (u_mem n).left {1})\n  have I : ∀ (ν : Measure G), IsFiniteMeasureOnCompacts ν →\n      Tendsto (fun n ↦ ∫ x, v n (f x) ∂ν) atTop\n      (𝓝 (∫ x, Set.indicator ({1} : Set ℝ) (fun _ ↦ 1) (f x) ∂ν)) := by\n    intro ν hν\n    apply tendsto_integral_of_dominated_convergence\n        (bound := (tsupport f).indicator (fun (_ : G) ↦ (1 : ℝ)) )\n    · exact fun n ↦ (vf_cont n).aestronglyMeasurable\n    · apply IntegrableOn.integrable_indicator _ (isClosed_tsupport f).measurableSet\n      simpa using IsCompact.measure_lt_top h'f\n    · refine fun n ↦ Eventually.of_forall (fun x ↦ ?_)\n      by_cases hx : x ∈ tsupport f\n      · simp only [v, Real.norm_eq_abs, NNReal.abs_eq, hx, indicator_of_mem]\n        norm_cast\n        exact thickenedIndicator_le_one _ _ _\n      · simp only [v, Real.norm_eq_abs, NNReal.abs_eq, hx, not_false_eq_true, indicator_of_not_mem]\n        rw [thickenedIndicator_zero]\n        · simp\n        · simpa [image_eq_zero_of_nmem_tsupport hx] using (u_mem n).2.le\n    · filter_upwards with x\n      have T := tendsto_pi_nhds.1 (thickenedIndicator_tendsto_indicator_closure\n        (fun n ↦ (u_mem n).1) u_lim ({1} : Set ℝ)) (f x)\n      simp only [thickenedIndicator_apply, closure_singleton] at T\n      convert NNReal.tendsto_coe.2 T\n      simp\n  have M n : ∫ (x : G), v n (f x) ∂μ' = ∫ (x : G), v n (f x) ∂(haarScalarFactor μ' μ • μ) := by\n    apply integral_isMulLeftInvariant_eq_smul_of_hasCompactSupport μ' μ (vf_cont n)\n    apply h'f.comp_left\n    simp only [v, thickenedIndicator_apply, NNReal.coe_eq_zero]\n    rw [thickenedIndicatorAux_zero (u_mem n).1]\n    · simp only [ENNReal.zero_toNNReal]\n    · simpa using (u_mem n).2.le\n  have I1 := I μ' (by infer_instance)\n  simp_rw [M] at I1\n  have J1 : ∫ (x : G), indicator {1} (fun _ ↦ (1 : ℝ)) (f x) ∂μ'\n      = ∫ (x : G), indicator {1} (fun _ ↦ 1) (f x) ∂(haarScalarFactor μ' μ • μ) :=\n    tendsto_nhds_unique I1 (I (haarScalarFactor μ' μ • μ) (by infer_instance))\n  have J2 : ENNReal.toReal (μ' (f ⁻¹' {1}))\n      = ENNReal.toReal ((haarScalarFactor μ' μ • μ) (f ⁻¹' {1})) := by\n    have : (fun x ↦ indicator {1} (fun _ ↦ (1 : ℝ)) (f x)) =\n        (fun x ↦ indicator (f ⁻¹' {1}) (fun _ ↦ (1 : ℝ)) x) := by\n      ext x\n      exact (indicator_comp_right f (s := ({1} : Set ℝ)) (g := (fun _ ↦ (1 : ℝ))) (x := x)).symm\n    have mf : MeasurableSet (f ⁻¹' {1}) := (isClosed_singleton.preimage hf).measurableSet\n    simpa only [this, mf, integral_indicator_const, smul_eq_mul, mul_one, Pi.smul_apply,\n      nnreal_smul_coe_apply, ENNReal.toReal_mul, ENNReal.coe_toReal] using J1\n  have C : IsCompact (f ⁻¹' {1}) := h'f.isCompact_preimage hf isClosed_singleton (by simp)\n  rw [ENNReal.toReal_eq_toReal C.measure_lt_top.ne C.measure_lt_top.ne] at J2\n  simpa using J2\n\n"}
{"name":"MeasureTheory.Measure.measure_preimage_isMulLeftInvariant_eq_smul_of_hasCompactSupport","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninst✝⁷ : TopologicalSpace G\ninst✝⁶ : Group G\ninst✝⁵ : TopologicalGroup G\ninst✝⁴ : MeasurableSpace G\ninst✝³ : BorelSpace G\nμ' μ : MeasureTheory.Measure G\ninst✝² : μ.IsHaarMeasure\ninst✝¹ : MeasureTheory.IsFiniteMeasureOnCompacts μ'\ninst✝ : μ'.IsMulLeftInvariant\nf : G → Real\nhf : Continuous f\nh'f : HasCompactSupport f\n⊢ Eq (μ' (Set.preimage f (Singleton.singleton 1))) (HSMul.hSMul (μ'.haarScalarFactor μ) (μ (Set.preimage f (Singleton.singleton 1))))","decl":"/-- Two left invariant measures give the same mass to level sets of continuous compactly supported\nfunctions, up to the scalar `haarScalarFactor μ' μ`.\n\nAuxiliary lemma in the proof of the more general\n`measure_isMulInvariant_eq_smul_of_isCompact_closure`, which works for any set with\ncompact closure. -/\n@[to_additive measure_preimage_isAddLeftInvariant_eq_smul_of_hasCompactSupport\n\"Two left invariant measures give the same mass to level sets of continuous compactly supported\nfunctions, up to the scalar `addHaarScalarFactor μ' μ`.\n\nAuxiliary lemma in the proof of the more general\n`measure_isAddInvariant_eq_smul_of_isCompact_closure`, which works for any set with\ncompact closure.\"]\nlemma measure_preimage_isMulLeftInvariant_eq_smul_of_hasCompactSupport\n    (μ' μ : Measure G) [IsHaarMeasure μ] [IsFiniteMeasureOnCompacts μ'] [IsMulLeftInvariant μ']\n    {f : G → ℝ} (hf : Continuous f) (h'f : HasCompactSupport f) :\n    μ' (f ⁻¹' {1}) = haarScalarFactor μ' μ • μ (f ⁻¹' {1}) := by\n  /- This follows from the fact that the two measures integrate in the same way continuous\n  functions, by approximating the indicator function of `f ⁻¹' {1}` by continuous functions\n  (namely `vₙ ∘ f` where `vₙ` is equal to `1` at `1`, and `0` outside of a small neighborhood\n  `(1 - uₙ, 1 + uₙ)` where `uₙ` is a sequence tending to `0`).\n  We use `vₙ = thickenedIndicator uₙ {1}` to take advantage of existing lemmas. -/\n  obtain ⟨u, -, u_mem, u_lim⟩ : ∃ u, StrictAnti u ∧ (∀ (n : ℕ), u n ∈ Ioo 0 1)\n    ∧ Tendsto u atTop (𝓝 0) := exists_seq_strictAnti_tendsto' (zero_lt_one : (0 : ℝ) < 1)\n  let v : ℕ → ℝ → ℝ := fun n x ↦ thickenedIndicator (u_mem n).1 ({1} : Set ℝ) x\n  have vf_cont n : Continuous ((v n) ∘ f) := by\n    apply Continuous.comp (continuous_induced_dom.comp ?_) hf\n    exact BoundedContinuousFunction.continuous (thickenedIndicator (u_mem n).left {1})\n  have I : ∀ (ν : Measure G), IsFiniteMeasureOnCompacts ν →\n      Tendsto (fun n ↦ ∫ x, v n (f x) ∂ν) atTop\n      (𝓝 (∫ x, Set.indicator ({1} : Set ℝ) (fun _ ↦ 1) (f x) ∂ν)) := by\n    intro ν hν\n    apply tendsto_integral_of_dominated_convergence\n        (bound := (tsupport f).indicator (fun (_ : G) ↦ (1 : ℝ)) )\n    · exact fun n ↦ (vf_cont n).aestronglyMeasurable\n    · apply IntegrableOn.integrable_indicator _ (isClosed_tsupport f).measurableSet\n      simpa using IsCompact.measure_lt_top h'f\n    · refine fun n ↦ Eventually.of_forall (fun x ↦ ?_)\n      by_cases hx : x ∈ tsupport f\n      · simp only [v, Real.norm_eq_abs, NNReal.abs_eq, hx, indicator_of_mem]\n        norm_cast\n        exact thickenedIndicator_le_one _ _ _\n      · simp only [v, Real.norm_eq_abs, NNReal.abs_eq, hx, not_false_eq_true, indicator_of_not_mem]\n        rw [thickenedIndicator_zero]\n        · simp\n        · simpa [image_eq_zero_of_nmem_tsupport hx] using (u_mem n).2.le\n    · filter_upwards with x\n      have T := tendsto_pi_nhds.1 (thickenedIndicator_tendsto_indicator_closure\n        (fun n ↦ (u_mem n).1) u_lim ({1} : Set ℝ)) (f x)\n      simp only [thickenedIndicator_apply, closure_singleton] at T\n      convert NNReal.tendsto_coe.2 T\n      simp\n  have M n : ∫ (x : G), v n (f x) ∂μ' = ∫ (x : G), v n (f x) ∂(haarScalarFactor μ' μ • μ) := by\n    apply integral_isMulLeftInvariant_eq_smul_of_hasCompactSupport μ' μ (vf_cont n)\n    apply h'f.comp_left\n    simp only [v, thickenedIndicator_apply, NNReal.coe_eq_zero]\n    rw [thickenedIndicatorAux_zero (u_mem n).1]\n    · simp only [ENNReal.zero_toNNReal]\n    · simpa using (u_mem n).2.le\n  have I1 := I μ' (by infer_instance)\n  simp_rw [M] at I1\n  have J1 : ∫ (x : G), indicator {1} (fun _ ↦ (1 : ℝ)) (f x) ∂μ'\n      = ∫ (x : G), indicator {1} (fun _ ↦ 1) (f x) ∂(haarScalarFactor μ' μ • μ) :=\n    tendsto_nhds_unique I1 (I (haarScalarFactor μ' μ • μ) (by infer_instance))\n  have J2 : ENNReal.toReal (μ' (f ⁻¹' {1}))\n      = ENNReal.toReal ((haarScalarFactor μ' μ • μ) (f ⁻¹' {1})) := by\n    have : (fun x ↦ indicator {1} (fun _ ↦ (1 : ℝ)) (f x)) =\n        (fun x ↦ indicator (f ⁻¹' {1}) (fun _ ↦ (1 : ℝ)) x) := by\n      ext x\n      exact (indicator_comp_right f (s := ({1} : Set ℝ)) (g := (fun _ ↦ (1 : ℝ))) (x := x)).symm\n    have mf : MeasurableSet (f ⁻¹' {1}) := (isClosed_singleton.preimage hf).measurableSet\n    simpa only [this, mf, integral_indicator_const, smul_eq_mul, mul_one, Pi.smul_apply,\n      nnreal_smul_coe_apply, ENNReal.toReal_mul, ENNReal.coe_toReal] using J1\n  have C : IsCompact (f ⁻¹' {1}) := h'f.isCompact_preimage hf isClosed_singleton (by simp)\n  rw [ENNReal.toReal_eq_toReal C.measure_lt_top.ne C.measure_lt_top.ne] at J2\n  simpa using J2\n\n"}
{"name":"MeasureTheory.Measure.smul_measure_isAddInvariant_le_of_isCompact_closure","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninst✝⁹ : TopologicalSpace G\ninst✝⁸ : AddGroup G\ninst✝⁷ : TopologicalAddGroup G\ninst✝⁶ : MeasurableSpace G\ninst✝⁵ : BorelSpace G\ninst✝⁴ : LocallyCompactSpace G\nμ' μ : MeasureTheory.Measure G\ninst✝³ : μ.IsAddHaarMeasure\ninst✝² : MeasureTheory.IsFiniteMeasureOnCompacts μ'\ninst✝¹ : μ'.IsAddLeftInvariant\ninst✝ : μ.InnerRegularCompactLTTop\ns : Set G\nhs : MeasurableSet s\nh's : IsCompact (closure s)\n⊢ LE.le (HSMul.hSMul (μ'.addHaarScalarFactor μ) (μ s)) (μ' s)","decl":"/-- If an invariant measure is inner regular, then it gives less mass to sets with compact closure\nthan any other invariant measure, up to the scalar `haarScalarFactor μ' μ`.\n\nAuxiliary lemma in the proof of the more general\n`measure_isMulInvariant_eq_smul_of_isCompact_closure`, which gives equality for any\nset with compact closure. -/\n@[to_additive smul_measure_isAddInvariant_le_of_isCompact_closure\n\"If an invariant measure is inner regular, then it gives less mass to sets with compact closure\nthan any other invariant measure, up to the scalar `addHaarScalarFactor μ' μ`.\n\nAuxiliary lemma in the proof of the more general\n`measure_isAddInvariant_eq_smul_of_isCompact_closure`, which gives equality for any\nset with compact closure.\"]\nlemma smul_measure_isMulInvariant_le_of_isCompact_closure [LocallyCompactSpace G]\n    (μ' μ : Measure G) [IsHaarMeasure μ] [IsFiniteMeasureOnCompacts μ'] [IsMulLeftInvariant μ']\n    [InnerRegularCompactLTTop μ]\n    {s : Set G} (hs : MeasurableSet s) (h's : IsCompact (closure s)) :\n    haarScalarFactor μ' μ • μ s ≤ μ' s := by\n  apply le_of_forall_lt (fun r hr ↦ ?_)\n  let ν := haarScalarFactor μ' μ • μ\n  have : ν s ≠ ∞ := ((measure_mono subset_closure).trans_lt h's.measure_lt_top).ne\n  obtain ⟨-, hf, ⟨f, f_cont, f_comp, rfl⟩, νf⟩ :\n      ∃ K ⊆ s, (∃ f, Continuous f ∧ HasCompactSupport f ∧ K = f ⁻¹' {1}) ∧ r < ν K :=\n    innerRegularWRT_preimage_one_hasCompactSupport_measure_ne_top_of_group ⟨hs, this⟩ r\n      (by convert hr)\n  calc\n  r < ν (f ⁻¹' {1}) := νf\n  _ = μ' (f ⁻¹' {1}) :=\n    (measure_preimage_isMulLeftInvariant_eq_smul_of_hasCompactSupport _ _ f_cont f_comp).symm\n  _ ≤ μ' s := measure_mono hf\n\n"}
{"name":"MeasureTheory.Measure.smul_measure_isMulInvariant_le_of_isCompact_closure","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninst✝⁹ : TopologicalSpace G\ninst✝⁸ : Group G\ninst✝⁷ : TopologicalGroup G\ninst✝⁶ : MeasurableSpace G\ninst✝⁵ : BorelSpace G\ninst✝⁴ : LocallyCompactSpace G\nμ' μ : MeasureTheory.Measure G\ninst✝³ : μ.IsHaarMeasure\ninst✝² : MeasureTheory.IsFiniteMeasureOnCompacts μ'\ninst✝¹ : μ'.IsMulLeftInvariant\ninst✝ : μ.InnerRegularCompactLTTop\ns : Set G\nhs : MeasurableSet s\nh's : IsCompact (closure s)\n⊢ LE.le (HSMul.hSMul (μ'.haarScalarFactor μ) (μ s)) (μ' s)","decl":"/-- If an invariant measure is inner regular, then it gives less mass to sets with compact closure\nthan any other invariant measure, up to the scalar `haarScalarFactor μ' μ`.\n\nAuxiliary lemma in the proof of the more general\n`measure_isMulInvariant_eq_smul_of_isCompact_closure`, which gives equality for any\nset with compact closure. -/\n@[to_additive smul_measure_isAddInvariant_le_of_isCompact_closure\n\"If an invariant measure is inner regular, then it gives less mass to sets with compact closure\nthan any other invariant measure, up to the scalar `addHaarScalarFactor μ' μ`.\n\nAuxiliary lemma in the proof of the more general\n`measure_isAddInvariant_eq_smul_of_isCompact_closure`, which gives equality for any\nset with compact closure.\"]\nlemma smul_measure_isMulInvariant_le_of_isCompact_closure [LocallyCompactSpace G]\n    (μ' μ : Measure G) [IsHaarMeasure μ] [IsFiniteMeasureOnCompacts μ'] [IsMulLeftInvariant μ']\n    [InnerRegularCompactLTTop μ]\n    {s : Set G} (hs : MeasurableSet s) (h's : IsCompact (closure s)) :\n    haarScalarFactor μ' μ • μ s ≤ μ' s := by\n  apply le_of_forall_lt (fun r hr ↦ ?_)\n  let ν := haarScalarFactor μ' μ • μ\n  have : ν s ≠ ∞ := ((measure_mono subset_closure).trans_lt h's.measure_lt_top).ne\n  obtain ⟨-, hf, ⟨f, f_cont, f_comp, rfl⟩, νf⟩ :\n      ∃ K ⊆ s, (∃ f, Continuous f ∧ HasCompactSupport f ∧ K = f ⁻¹' {1}) ∧ r < ν K :=\n    innerRegularWRT_preimage_one_hasCompactSupport_measure_ne_top_of_group ⟨hs, this⟩ r\n      (by convert hr)\n  calc\n  r < ν (f ⁻¹' {1}) := νf\n  _ = μ' (f ⁻¹' {1}) :=\n    (measure_preimage_isMulLeftInvariant_eq_smul_of_hasCompactSupport _ _ f_cont f_comp).symm\n  _ ≤ μ' s := measure_mono hf\n\n"}
{"name":"MeasureTheory.Measure.measure_isAddInvariant_eq_smul_of_isCompact_closure_of_innerRegularCompactLTTop","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninst✝⁹ : TopologicalSpace G\ninst✝⁸ : AddGroup G\ninst✝⁷ : TopologicalAddGroup G\ninst✝⁶ : MeasurableSpace G\ninst✝⁵ : BorelSpace G\ninst✝⁴ : LocallyCompactSpace G\nμ' μ : MeasureTheory.Measure G\ninst✝³ : μ.IsAddHaarMeasure\ninst✝² : MeasureTheory.IsFiniteMeasureOnCompacts μ'\ninst✝¹ : μ'.IsAddLeftInvariant\ninst✝ : μ.InnerRegularCompactLTTop\ns : Set G\nhs : MeasurableSet s\nh's : IsCompact (closure s)\n⊢ Eq (μ' s) (HSMul.hSMul (μ'.addHaarScalarFactor μ) (μ s))","decl":"/-- If an invariant measure is inner regular, then it gives the same mass to measurable sets with\ncompact closure as any other invariant measure, up to the scalar `haarScalarFactor μ' μ`.\n\nAuxiliary lemma in the proof of the more general\n`measure_isMulInvariant_eq_smul_of_isCompact_closure`, which works for any set with\ncompact closure, and removes the inner regularity assumption. -/\n@[to_additive measure_isAddInvariant_eq_smul_of_isCompact_closure_of_innerRegularCompactLTTop\n\" If an invariant measure is inner regular, then it gives the same mass to measurable sets with\ncompact closure as any other invariant measure, up to the scalar `addHaarScalarFactor μ' μ`.\n\nAuxiliary lemma in the proof of the more general\n`measure_isAddInvariant_eq_smul_of_isCompact_closure`, which works for any set with\ncompact closure, and removes the inner regularity assumption.\"]\nlemma measure_isMulInvariant_eq_smul_of_isCompact_closure_of_innerRegularCompactLTTop\n    [LocallyCompactSpace G]\n    (μ' μ : Measure G) [IsHaarMeasure μ] [IsFiniteMeasureOnCompacts μ'] [IsMulLeftInvariant μ']\n    [InnerRegularCompactLTTop μ]\n    {s : Set G} (hs : MeasurableSet s) (h's : IsCompact (closure s)) :\n    μ' s = haarScalarFactor μ' μ • μ s := by\n  apply le_antisymm ?_ (smul_measure_isMulInvariant_le_of_isCompact_closure μ' μ hs h's)\n  let ν := haarScalarFactor μ' μ • μ\n  change μ' s ≤ ν s\n  obtain ⟨⟨f, f_cont⟩, hf, -, f_comp, -⟩ : ∃ f : C(G, ℝ), EqOn f 1 (closure s) ∧ EqOn f 0 ∅\n      ∧ HasCompactSupport f ∧ ∀ x, f x ∈ Icc (0 : ℝ) 1 :=\n    exists_continuous_one_zero_of_isCompact h's isClosed_empty (disjoint_empty _)\n  let t := f ⁻¹' {1}\n  have t_closed : IsClosed t := isClosed_singleton.preimage f_cont\n  have t_comp : IsCompact t := f_comp.isCompact_preimage f_cont isClosed_singleton (by simp)\n  have st : s ⊆ t := (IsClosed.closure_subset_iff t_closed).mp hf\n  have A : ν (t \\ s) ≤ μ' (t \\ s) := by\n    apply smul_measure_isMulInvariant_le_of_isCompact_closure _ _ (t_closed.measurableSet.diff hs)\n    exact t_comp.closure_of_subset diff_subset\n  have B : μ' t = ν t :=\n    measure_preimage_isMulLeftInvariant_eq_smul_of_hasCompactSupport _ _ f_cont f_comp\n  rwa [measure_diff st hs.nullMeasurableSet, measure_diff st hs.nullMeasurableSet, ← B,\n    ENNReal.sub_le_sub_iff_left] at A\n  · exact measure_mono st\n  · exact t_comp.measure_lt_top.ne\n  · exact ((measure_mono st).trans_lt t_comp.measure_lt_top).ne\n  · exact ((measure_mono st).trans_lt t_comp.measure_lt_top).ne\n\n"}
{"name":"MeasureTheory.Measure.measure_isMulInvariant_eq_smul_of_isCompact_closure_of_innerRegularCompactLTTop","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninst✝⁹ : TopologicalSpace G\ninst✝⁸ : Group G\ninst✝⁷ : TopologicalGroup G\ninst✝⁶ : MeasurableSpace G\ninst✝⁵ : BorelSpace G\ninst✝⁴ : LocallyCompactSpace G\nμ' μ : MeasureTheory.Measure G\ninst✝³ : μ.IsHaarMeasure\ninst✝² : MeasureTheory.IsFiniteMeasureOnCompacts μ'\ninst✝¹ : μ'.IsMulLeftInvariant\ninst✝ : μ.InnerRegularCompactLTTop\ns : Set G\nhs : MeasurableSet s\nh's : IsCompact (closure s)\n⊢ Eq (μ' s) (HSMul.hSMul (μ'.haarScalarFactor μ) (μ s))","decl":"/-- If an invariant measure is inner regular, then it gives the same mass to measurable sets with\ncompact closure as any other invariant measure, up to the scalar `haarScalarFactor μ' μ`.\n\nAuxiliary lemma in the proof of the more general\n`measure_isMulInvariant_eq_smul_of_isCompact_closure`, which works for any set with\ncompact closure, and removes the inner regularity assumption. -/\n@[to_additive measure_isAddInvariant_eq_smul_of_isCompact_closure_of_innerRegularCompactLTTop\n\" If an invariant measure is inner regular, then it gives the same mass to measurable sets with\ncompact closure as any other invariant measure, up to the scalar `addHaarScalarFactor μ' μ`.\n\nAuxiliary lemma in the proof of the more general\n`measure_isAddInvariant_eq_smul_of_isCompact_closure`, which works for any set with\ncompact closure, and removes the inner regularity assumption.\"]\nlemma measure_isMulInvariant_eq_smul_of_isCompact_closure_of_innerRegularCompactLTTop\n    [LocallyCompactSpace G]\n    (μ' μ : Measure G) [IsHaarMeasure μ] [IsFiniteMeasureOnCompacts μ'] [IsMulLeftInvariant μ']\n    [InnerRegularCompactLTTop μ]\n    {s : Set G} (hs : MeasurableSet s) (h's : IsCompact (closure s)) :\n    μ' s = haarScalarFactor μ' μ • μ s := by\n  apply le_antisymm ?_ (smul_measure_isMulInvariant_le_of_isCompact_closure μ' μ hs h's)\n  let ν := haarScalarFactor μ' μ • μ\n  change μ' s ≤ ν s\n  obtain ⟨⟨f, f_cont⟩, hf, -, f_comp, -⟩ : ∃ f : C(G, ℝ), EqOn f 1 (closure s) ∧ EqOn f 0 ∅\n      ∧ HasCompactSupport f ∧ ∀ x, f x ∈ Icc (0 : ℝ) 1 :=\n    exists_continuous_one_zero_of_isCompact h's isClosed_empty (disjoint_empty _)\n  let t := f ⁻¹' {1}\n  have t_closed : IsClosed t := isClosed_singleton.preimage f_cont\n  have t_comp : IsCompact t := f_comp.isCompact_preimage f_cont isClosed_singleton (by simp)\n  have st : s ⊆ t := (IsClosed.closure_subset_iff t_closed).mp hf\n  have A : ν (t \\ s) ≤ μ' (t \\ s) := by\n    apply smul_measure_isMulInvariant_le_of_isCompact_closure _ _ (t_closed.measurableSet.diff hs)\n    exact t_comp.closure_of_subset diff_subset\n  have B : μ' t = ν t :=\n    measure_preimage_isMulLeftInvariant_eq_smul_of_hasCompactSupport _ _ f_cont f_comp\n  rwa [measure_diff st hs.nullMeasurableSet, measure_diff st hs.nullMeasurableSet, ← B,\n    ENNReal.sub_le_sub_iff_left] at A\n  · exact measure_mono st\n  · exact t_comp.measure_lt_top.ne\n  · exact ((measure_mono st).trans_lt t_comp.measure_lt_top).ne\n  · exact ((measure_mono st).trans_lt t_comp.measure_lt_top).ne\n\n"}
{"name":"MeasureTheory.Measure.measure_isMulInvariant_eq_smul_of_isCompact_closure_of_measurableSet","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninst✝⁸ : TopologicalSpace G\ninst✝⁷ : Group G\ninst✝⁶ : TopologicalGroup G\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : BorelSpace G\ninst✝³ : LocallyCompactSpace G\nμ' μ : MeasureTheory.Measure G\ninst✝² : μ.IsHaarMeasure\ninst✝¹ : MeasureTheory.IsFiniteMeasureOnCompacts μ'\ninst✝ : μ'.IsMulLeftInvariant\ns : Set G\nhs : MeasurableSet s\nh's : IsCompact (closure s)\n⊢ Eq (μ' s) (HSMul.hSMul (μ'.haarScalarFactor μ) (μ s))","decl":"/-- Given an invariant measure then it gives the same mass to measurable sets with\ncompact closure as any other invariant measure, up to the scalar `haarScalarFactor μ' μ`.\n\nAuxiliary lemma in the proof of the more general\n`measure_isMulInvariant_eq_smul_of_isCompact_closure`, which removes the\nmeasurability assumption. -/\n@[to_additive measure_isAddInvariant_eq_smul_of_isCompact_closure_of_measurableSet\n\"Given an invariant measure then it gives the same mass to measurable sets with\ncompact closure as any other invariant measure, up to the scalar `addHaarScalarFactor μ' μ`.\n\nAuxiliary lemma in the proof of the more general\n`measure_isAddInvariant_eq_smul_of_isCompact_closure`, which removes the\nmeasurability assumption.\"]\nlemma measure_isMulInvariant_eq_smul_of_isCompact_closure_of_measurableSet [LocallyCompactSpace G]\n    (μ' μ : Measure G) [IsHaarMeasure μ] [IsFiniteMeasureOnCompacts μ'] [IsMulLeftInvariant μ']\n    {s : Set G} (hs : MeasurableSet s) (h's : IsCompact (closure s)) :\n    μ' s = haarScalarFactor μ' μ • μ s := by\n  let ν : Measure G := haar\n  have A : μ' s = haarScalarFactor μ' ν • ν s :=\n    measure_isMulInvariant_eq_smul_of_isCompact_closure_of_innerRegularCompactLTTop μ' ν hs h's\n  have B : μ s = haarScalarFactor μ ν • ν s :=\n    measure_isMulInvariant_eq_smul_of_isCompact_closure_of_innerRegularCompactLTTop μ ν hs h's\n  rw [A, B, smul_smul, haarScalarFactor_eq_mul μ' μ ν]\n\n"}
{"name":"MeasureTheory.Measure.measure_isAddInvariant_eq_smul_of_isCompact_closure_of_measurableSet","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninst✝⁸ : TopologicalSpace G\ninst✝⁷ : AddGroup G\ninst✝⁶ : TopologicalAddGroup G\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : BorelSpace G\ninst✝³ : LocallyCompactSpace G\nμ' μ : MeasureTheory.Measure G\ninst✝² : μ.IsAddHaarMeasure\ninst✝¹ : MeasureTheory.IsFiniteMeasureOnCompacts μ'\ninst✝ : μ'.IsAddLeftInvariant\ns : Set G\nhs : MeasurableSet s\nh's : IsCompact (closure s)\n⊢ Eq (μ' s) (HSMul.hSMul (μ'.addHaarScalarFactor μ) (μ s))","decl":"/-- Given an invariant measure then it gives the same mass to measurable sets with\ncompact closure as any other invariant measure, up to the scalar `haarScalarFactor μ' μ`.\n\nAuxiliary lemma in the proof of the more general\n`measure_isMulInvariant_eq_smul_of_isCompact_closure`, which removes the\nmeasurability assumption. -/\n@[to_additive measure_isAddInvariant_eq_smul_of_isCompact_closure_of_measurableSet\n\"Given an invariant measure then it gives the same mass to measurable sets with\ncompact closure as any other invariant measure, up to the scalar `addHaarScalarFactor μ' μ`.\n\nAuxiliary lemma in the proof of the more general\n`measure_isAddInvariant_eq_smul_of_isCompact_closure`, which removes the\nmeasurability assumption.\"]\nlemma measure_isMulInvariant_eq_smul_of_isCompact_closure_of_measurableSet [LocallyCompactSpace G]\n    (μ' μ : Measure G) [IsHaarMeasure μ] [IsFiniteMeasureOnCompacts μ'] [IsMulLeftInvariant μ']\n    {s : Set G} (hs : MeasurableSet s) (h's : IsCompact (closure s)) :\n    μ' s = haarScalarFactor μ' μ • μ s := by\n  let ν : Measure G := haar\n  have A : μ' s = haarScalarFactor μ' ν • ν s :=\n    measure_isMulInvariant_eq_smul_of_isCompact_closure_of_innerRegularCompactLTTop μ' ν hs h's\n  have B : μ s = haarScalarFactor μ ν • ν s :=\n    measure_isMulInvariant_eq_smul_of_isCompact_closure_of_innerRegularCompactLTTop μ ν hs h's\n  rw [A, B, smul_smul, haarScalarFactor_eq_mul μ' μ ν]\n\n"}
{"name":"MeasureTheory.Measure.measure_isAddInvariant_eq_smul_of_isCompact_closure","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninst✝⁸ : TopologicalSpace G\ninst✝⁷ : AddGroup G\ninst✝⁶ : TopologicalAddGroup G\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : BorelSpace G\ninst✝³ : LocallyCompactSpace G\nμ' μ : MeasureTheory.Measure G\ninst✝² : μ.IsAddHaarMeasure\ninst✝¹ : MeasureTheory.IsFiniteMeasureOnCompacts μ'\ninst✝ : μ'.IsAddLeftInvariant\ns : Set G\nh's : IsCompact (closure s)\n⊢ Eq (μ' s) (HSMul.hSMul (μ'.addHaarScalarFactor μ) (μ s))","decl":"/-- **Uniqueness of left-invariant measures**:\nGiven two left-invariant measures which are finite on compacts, they coincide in the following\nsense: they give the same value to sets with compact closure, up to the multiplicative\nconstant `haarScalarFactor μ' μ`. -/\n@[to_additive measure_isAddInvariant_eq_smul_of_isCompact_closure\n\"**Uniqueness of left-invariant measures**:\nGiven two left-invariant measures which are finite on compacts, they coincide in the following\nsense: they give the same value to sets with compact closure, up to the multiplicative\nconstant `addHaarScalarFactor μ' μ`. \"]\ntheorem measure_isMulInvariant_eq_smul_of_isCompact_closure [LocallyCompactSpace G]\n    (μ' μ : Measure G) [IsHaarMeasure μ] [IsFiniteMeasureOnCompacts μ'] [IsMulLeftInvariant μ']\n    {s : Set G} (h's : IsCompact (closure s)) :\n    μ' s = haarScalarFactor μ' μ • μ s := by\n  let ν := haarScalarFactor μ' μ • μ\n  apply le_antisymm\n  · calc\n    μ' s ≤ μ' ((toMeasurable ν s) ∩ (closure s)) :=\n      measure_mono <| subset_inter (subset_toMeasurable ν s) subset_closure\n    _ = ν ((toMeasurable ν s) ∩ (closure s)) := by\n      apply measure_isMulInvariant_eq_smul_of_isCompact_closure_of_measurableSet _ _ _ _\n      · exact (measurableSet_toMeasurable ν s).inter isClosed_closure.measurableSet\n      · exact h's.closure_of_subset inter_subset_right\n    _ ≤ ν (toMeasurable ν s) := measure_mono inter_subset_left\n    _ = ν s := measure_toMeasurable s\n  · calc\n    ν s ≤ ν ((toMeasurable μ' s) ∩ (closure s)) :=\n      measure_mono <| subset_inter (subset_toMeasurable μ' s) subset_closure\n    _ = μ' ((toMeasurable μ' s) ∩ (closure s)) := by\n      apply (measure_isMulInvariant_eq_smul_of_isCompact_closure_of_measurableSet _ _ _ _).symm\n      · exact (measurableSet_toMeasurable μ' s).inter isClosed_closure.measurableSet\n      · exact h's.closure_of_subset inter_subset_right\n    _ ≤ μ' (toMeasurable μ' s) := measure_mono inter_subset_left\n    _ = μ' s := measure_toMeasurable s\n\n"}
{"name":"MeasureTheory.Measure.measure_isMulInvariant_eq_smul_of_isCompact_closure","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninst✝⁸ : TopologicalSpace G\ninst✝⁷ : Group G\ninst✝⁶ : TopologicalGroup G\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : BorelSpace G\ninst✝³ : LocallyCompactSpace G\nμ' μ : MeasureTheory.Measure G\ninst✝² : μ.IsHaarMeasure\ninst✝¹ : MeasureTheory.IsFiniteMeasureOnCompacts μ'\ninst✝ : μ'.IsMulLeftInvariant\ns : Set G\nh's : IsCompact (closure s)\n⊢ Eq (μ' s) (HSMul.hSMul (μ'.haarScalarFactor μ) (μ s))","decl":"/-- **Uniqueness of left-invariant measures**:\nGiven two left-invariant measures which are finite on compacts, they coincide in the following\nsense: they give the same value to sets with compact closure, up to the multiplicative\nconstant `haarScalarFactor μ' μ`. -/\n@[to_additive measure_isAddInvariant_eq_smul_of_isCompact_closure\n\"**Uniqueness of left-invariant measures**:\nGiven two left-invariant measures which are finite on compacts, they coincide in the following\nsense: they give the same value to sets with compact closure, up to the multiplicative\nconstant `addHaarScalarFactor μ' μ`. \"]\ntheorem measure_isMulInvariant_eq_smul_of_isCompact_closure [LocallyCompactSpace G]\n    (μ' μ : Measure G) [IsHaarMeasure μ] [IsFiniteMeasureOnCompacts μ'] [IsMulLeftInvariant μ']\n    {s : Set G} (h's : IsCompact (closure s)) :\n    μ' s = haarScalarFactor μ' μ • μ s := by\n  let ν := haarScalarFactor μ' μ • μ\n  apply le_antisymm\n  · calc\n    μ' s ≤ μ' ((toMeasurable ν s) ∩ (closure s)) :=\n      measure_mono <| subset_inter (subset_toMeasurable ν s) subset_closure\n    _ = ν ((toMeasurable ν s) ∩ (closure s)) := by\n      apply measure_isMulInvariant_eq_smul_of_isCompact_closure_of_measurableSet _ _ _ _\n      · exact (measurableSet_toMeasurable ν s).inter isClosed_closure.measurableSet\n      · exact h's.closure_of_subset inter_subset_right\n    _ ≤ ν (toMeasurable ν s) := measure_mono inter_subset_left\n    _ = ν s := measure_toMeasurable s\n  · calc\n    ν s ≤ ν ((toMeasurable μ' s) ∩ (closure s)) :=\n      measure_mono <| subset_inter (subset_toMeasurable μ' s) subset_closure\n    _ = μ' ((toMeasurable μ' s) ∩ (closure s)) := by\n      apply (measure_isMulInvariant_eq_smul_of_isCompact_closure_of_measurableSet _ _ _ _).symm\n      · exact (measurableSet_toMeasurable μ' s).inter isClosed_closure.measurableSet\n      · exact h's.closure_of_subset inter_subset_right\n    _ ≤ μ' (toMeasurable μ' s) := measure_mono inter_subset_left\n    _ = μ' s := measure_toMeasurable s\n\n"}
{"name":"MeasureTheory.Measure.isMulInvariant_eq_smul_of_compactSpace","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninst✝⁸ : TopologicalSpace G\ninst✝⁷ : Group G\ninst✝⁶ : TopologicalGroup G\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : BorelSpace G\ninst✝³ : CompactSpace G\nμ' μ : MeasureTheory.Measure G\ninst✝² : μ.IsHaarMeasure\ninst✝¹ : μ'.IsMulLeftInvariant\ninst✝ : MeasureTheory.IsFiniteMeasureOnCompacts μ'\n⊢ Eq μ' (HSMul.hSMul (μ'.haarScalarFactor μ) μ)","decl":"/-- **Uniqueness of Haar measures**:\nTwo Haar measures on a compact group coincide up to a multiplicative factor. -/\n@[to_additive isAddInvariant_eq_smul_of_compactSpace]\nlemma isMulInvariant_eq_smul_of_compactSpace [CompactSpace G] (μ' μ : Measure G)\n    [IsHaarMeasure μ] [IsMulLeftInvariant μ'] [IsFiniteMeasureOnCompacts μ'] :\n    μ' = haarScalarFactor μ' μ • μ := by\n  ext s _hs\n  exact measure_isMulInvariant_eq_smul_of_isCompact_closure _ _ isClosed_closure.isCompact\n\n"}
{"name":"MeasureTheory.Measure.isAddInvariant_eq_smul_of_compactSpace","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninst✝⁸ : TopologicalSpace G\ninst✝⁷ : AddGroup G\ninst✝⁶ : TopologicalAddGroup G\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : BorelSpace G\ninst✝³ : CompactSpace G\nμ' μ : MeasureTheory.Measure G\ninst✝² : μ.IsAddHaarMeasure\ninst✝¹ : μ'.IsAddLeftInvariant\ninst✝ : MeasureTheory.IsFiniteMeasureOnCompacts μ'\n⊢ Eq μ' (HSMul.hSMul (μ'.addHaarScalarFactor μ) μ)","decl":"/-- **Uniqueness of Haar measures**:\nTwo Haar measures on a compact group coincide up to a multiplicative factor. -/\n@[to_additive isAddInvariant_eq_smul_of_compactSpace]\nlemma isMulInvariant_eq_smul_of_compactSpace [CompactSpace G] (μ' μ : Measure G)\n    [IsHaarMeasure μ] [IsMulLeftInvariant μ'] [IsFiniteMeasureOnCompacts μ'] :\n    μ' = haarScalarFactor μ' μ • μ := by\n  ext s _hs\n  exact measure_isMulInvariant_eq_smul_of_isCompact_closure _ _ isClosed_closure.isCompact\n\n"}
{"name":"MeasureTheory.Measure.instInnerRegularOfIsAddHaarMeasureOfCompactSpace","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninst✝⁵ : TopologicalSpace G\ninst✝⁴ : AddGroup G\ninst✝³ : MeasurableSpace G\ninst✝² : CompactSpace G\nμ : MeasureTheory.Measure G\ninst✝¹ : μ.IsAddLeftInvariant\ninst✝ : MeasureTheory.IsFiniteMeasureOnCompacts μ\n⊢ μ.InnerRegular","decl":"@[to_additive]\ninstance (priority := 100) instInnerRegularOfIsHaarMeasureOfCompactSpace\n    [CompactSpace G] (μ : Measure G) [IsMulLeftInvariant μ] [IsFiniteMeasureOnCompacts μ] :\n    InnerRegular μ := by\n  rw [isMulInvariant_eq_smul_of_compactSpace μ haar]\n  infer_instance\n\n"}
{"name":"MeasureTheory.Measure.instInnerRegularOfIsHaarMeasureOfCompactSpace","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninst✝⁵ : TopologicalSpace G\ninst✝⁴ : Group G\ninst✝³ : MeasurableSpace G\ninst✝² : CompactSpace G\nμ : MeasureTheory.Measure G\ninst✝¹ : μ.IsMulLeftInvariant\ninst✝ : MeasureTheory.IsFiniteMeasureOnCompacts μ\n⊢ μ.InnerRegular","decl":"@[to_additive]\ninstance (priority := 100) instInnerRegularOfIsHaarMeasureOfCompactSpace\n    [CompactSpace G] (μ : Measure G) [IsMulLeftInvariant μ] [IsFiniteMeasureOnCompacts μ] :\n    InnerRegular μ := by\n  rw [isMulInvariant_eq_smul_of_compactSpace μ haar]\n  infer_instance\n\n"}
{"name":"MeasureTheory.Measure.instRegularOfIsHaarMeasureOfCompactSpace","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninst✝⁵ : TopologicalSpace G\ninst✝⁴ : Group G\ninst✝³ : MeasurableSpace G\ninst✝² : CompactSpace G\nμ : MeasureTheory.Measure G\ninst✝¹ : μ.IsMulLeftInvariant\ninst✝ : MeasureTheory.IsFiniteMeasureOnCompacts μ\n⊢ μ.Regular","decl":"@[to_additive]\ninstance (priority := 100) instRegularOfIsHaarMeasureOfCompactSpace\n    [CompactSpace G] (μ : Measure G) [IsMulLeftInvariant μ] [IsFiniteMeasureOnCompacts μ] :\n    Regular μ := by\n  rw [isMulInvariant_eq_smul_of_compactSpace μ haar]\n  infer_instance\n\n"}
{"name":"MeasureTheory.Measure.instRegularOfIsAddHaarMeasureOfCompactSpace","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninst✝⁵ : TopologicalSpace G\ninst✝⁴ : AddGroup G\ninst✝³ : MeasurableSpace G\ninst✝² : CompactSpace G\nμ : MeasureTheory.Measure G\ninst✝¹ : μ.IsAddLeftInvariant\ninst✝ : MeasureTheory.IsFiniteMeasureOnCompacts μ\n⊢ μ.Regular","decl":"@[to_additive]\ninstance (priority := 100) instRegularOfIsHaarMeasureOfCompactSpace\n    [CompactSpace G] (μ : Measure G) [IsMulLeftInvariant μ] [IsFiniteMeasureOnCompacts μ] :\n    Regular μ := by\n  rw [isMulInvariant_eq_smul_of_compactSpace μ haar]\n  infer_instance\n\n"}
{"name":"MeasureTheory.Measure.isHaarMeasure_eq_of_isProbabilityMeasure","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninst✝⁹ : TopologicalSpace G\ninst✝⁸ : Group G\ninst✝⁷ : TopologicalGroup G\ninst✝⁶ : MeasurableSpace G\ninst✝⁵ : BorelSpace G\ninst✝⁴ : LocallyCompactSpace G\nμ' μ : MeasureTheory.Measure G\ninst✝³ : MeasureTheory.IsProbabilityMeasure μ\ninst✝² : MeasureTheory.IsProbabilityMeasure μ'\ninst✝¹ : μ.IsHaarMeasure\ninst✝ : μ'.IsHaarMeasure\n⊢ Eq μ' μ","decl":"/-- **Uniqueness of Haar measures**:\nTwo Haar measures which are probability measures coincide. -/\n@[to_additive]\nlemma isHaarMeasure_eq_of_isProbabilityMeasure [LocallyCompactSpace G] (μ' μ : Measure G)\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [IsHaarMeasure μ] [IsHaarMeasure μ'] :\n    μ' = μ := by\n  have : CompactSpace G := by\n    by_contra H\n    rw [not_compactSpace_iff] at H\n    simpa using measure_univ_of_isMulLeftInvariant μ\n  have A s : μ' s = haarScalarFactor μ' μ • μ s :=\n    measure_isMulInvariant_eq_smul_of_isCompact_closure _ _ isClosed_closure.isCompact\n  have Z := A univ\n  simp only [measure_univ, ENNReal.smul_def, smul_eq_mul, mul_one, ENNReal.one_eq_coe] at Z\n  ext s _hs\n  simp [A s, ← Z]\n\n"}
{"name":"MeasureTheory.Measure.isAddHaarMeasure_eq_of_isProbabilityMeasure","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninst✝⁹ : TopologicalSpace G\ninst✝⁸ : AddGroup G\ninst✝⁷ : TopologicalAddGroup G\ninst✝⁶ : MeasurableSpace G\ninst✝⁵ : BorelSpace G\ninst✝⁴ : LocallyCompactSpace G\nμ' μ : MeasureTheory.Measure G\ninst✝³ : MeasureTheory.IsProbabilityMeasure μ\ninst✝² : MeasureTheory.IsProbabilityMeasure μ'\ninst✝¹ : μ.IsAddHaarMeasure\ninst✝ : μ'.IsAddHaarMeasure\n⊢ Eq μ' μ","decl":"/-- **Uniqueness of Haar measures**:\nTwo Haar measures which are probability measures coincide. -/\n@[to_additive]\nlemma isHaarMeasure_eq_of_isProbabilityMeasure [LocallyCompactSpace G] (μ' μ : Measure G)\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [IsHaarMeasure μ] [IsHaarMeasure μ'] :\n    μ' = μ := by\n  have : CompactSpace G := by\n    by_contra H\n    rw [not_compactSpace_iff] at H\n    simpa using measure_univ_of_isMulLeftInvariant μ\n  have A s : μ' s = haarScalarFactor μ' μ • μ s :=\n    measure_isMulInvariant_eq_smul_of_isCompact_closure _ _ isClosed_closure.isCompact\n  have Z := A univ\n  simp only [measure_univ, ENNReal.smul_def, smul_eq_mul, mul_one, ENNReal.one_eq_coe] at Z\n  ext s _hs\n  simp [A s, ← Z]\n\n"}
{"name":"MeasureTheory.Measure.measure_isHaarMeasure_eq_smul_of_isEverywherePos","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninst✝⁷ : TopologicalSpace G\ninst✝⁶ : Group G\ninst✝⁵ : TopologicalGroup G\ninst✝⁴ : MeasurableSpace G\ninst✝³ : BorelSpace G\ninst✝² : LocallyCompactSpace G\nμ' μ : MeasureTheory.Measure G\ninst✝¹ : μ.IsHaarMeasure\ninst✝ : μ'.IsHaarMeasure\ns : Set G\nhs : MeasurableSet s\nh's : μ.IsEverywherePos s\n⊢ Eq (μ' s) (HSMul.hSMul (μ'.haarScalarFactor μ) (μ s))","decl":"@[to_additive measure_isAddHaarMeasure_eq_smul_of_isEverywherePos]\ntheorem measure_isHaarMeasure_eq_smul_of_isEverywherePos [LocallyCompactSpace G]\n    (μ' μ : Measure G) [IsHaarMeasure μ] [IsHaarMeasure μ']\n    {s : Set G} (hs : MeasurableSet s) (h's : IsEverywherePos μ s) :\n    μ' s = haarScalarFactor μ' μ • μ s := by\n  let ν := haarScalarFactor μ' μ • μ\n  change μ' s = ν s\n  /- Fix a compact neighborhood `k` of the identity, and consider a maximal disjoint family `m` of\n  sets `x • k` centered at points in `s`. Then `s` is covered by the sets `x • (k * k⁻¹)` by\n  maximality. If the family is countable, then since `μ'` and `ν` coincide in compact sets, and\n  the measure of a countable disjoint union is the sum of the measures, we get `μ' s = ν s`.\n  Otherwise, the family is uncountable, and each intersection with `s` has positive measure by\n  the everywhere positivity assumption, so `ν s = ∞`, and `μ' s = ∞` in the same way. -/\n  obtain ⟨k, k_comp, k_closed, k_mem⟩ : ∃ k, IsCompact k ∧ IsClosed k ∧ k ∈ 𝓝 (1 : G) := by\n    rcases exists_compact_mem_nhds (1 : G) with ⟨k, hk, hmem⟩\n    exact ⟨closure k, hk.closure, isClosed_closure, mem_of_superset hmem subset_closure⟩\n  have one_k : 1 ∈ k := mem_of_mem_nhds k_mem\n  let A : Set (Set G) := {t | t ⊆ s ∧ PairwiseDisjoint t (fun x ↦ x • k)}\n  obtain ⟨m, m_max⟩ : ∃ m, Maximal (· ∈ A) m := by\n    apply zorn_subset\n    intro c cA hc\n    refine ⟨⋃ a ∈ c, a, ⟨?_, ?_⟩, ?_⟩\n    · simp only [iUnion_subset_iff]\n      intro a ac x hx\n      simp only [A, subset_def, mem_setOf_eq] at cA\n      exact (cA _ ac).1 x hx\n    · rintro x hx y hy hxy\n      simp only [mem_iUnion, exists_prop] at hx hy\n      rcases hx with ⟨a, ac, xa⟩\n      rcases hy with ⟨b, bc, yb⟩\n      obtain ⟨m, mc, am, bm⟩ : ∃ m ∈ c, a ⊆ m ∧ b ⊆ m := hc.directedOn _ ac _ bc\n      exact (cA mc).2 (am xa) (bm yb) hxy\n    · intro a ac\n      exact subset_biUnion_of_mem (u := id) ac\n  obtain ⟨hms : m ⊆ s, hdj : PairwiseDisjoint m (fun x ↦ x • k)⟩ := m_max.prop\n  have sm : s ⊆ ⋃ x ∈ m, x • (k * k⁻¹) := by\n    intro y hy\n    by_cases h'y : m ∪ {y} ∈ A\n    · have ym : y ∈ m := m_max.mem_of_prop_insert (by simpa using h'y)\n      have : y ∈ y • (k * k⁻¹) := by\n        simpa using mem_leftCoset y (Set.mul_mem_mul one_k (Set.inv_mem_inv.mpr one_k))\n      exact mem_biUnion ym this\n    · obtain ⟨x, xm, -, z, zy, zx⟩ : ∃ x ∈ m, y ≠ x ∧ ∃ z, z ∈ y • k ∧ z ∈ x • k := by\n        simpa [A, hms, hy, insert_subset_iff, pairwiseDisjoint_insert, hdj, not_disjoint_iff]\n          using h'y\n      have : y ∈ x • (k * k⁻¹) := by\n        rw [show y = x * ((x⁻¹ * z) * (y⁻¹ * z)⁻¹) by group]\n        have : (x⁻¹ * z) * (y⁻¹ * z)⁻¹ ∈ k * k⁻¹ := Set.mul_mem_mul ((mem_leftCoset_iff x).mp zx)\n          (Set.inv_mem_inv.mpr ((mem_leftCoset_iff y).mp zy))\n        exact mem_leftCoset x this\n      exact mem_biUnion xm this\n  rcases eq_empty_or_nonempty m with rfl|hm\n  · simp only [mem_empty_iff_false, iUnion_of_empty, iUnion_empty, subset_empty_iff] at sm\n    simp [sm]\n  by_cases h'm : Set.Countable m\n  · rcases h'm.exists_eq_range hm with ⟨f, rfl⟩\n    have M i : MeasurableSet (disjointed (fun n ↦ s ∩ f n • (k * k⁻¹)) i) := by\n      apply MeasurableSet.disjointed (fun j ↦ hs.inter ?_)\n      have : IsClosed (k • k⁻¹) := IsClosed.smul_left_of_isCompact k_closed.inv k_comp\n      exact (IsClosed.smul this (f j)).measurableSet\n    simp only [mem_range, iUnion_exists, iUnion_iUnion_eq'] at sm\n    have s_eq : s = ⋃ n, s ∩ (f n • (k * k⁻¹)) := by rwa [← inter_iUnion, eq_comm, inter_eq_left]\n    have I : μ' s = ∑' n, μ' (disjointed (fun n ↦ s ∩ f n • (k * k⁻¹)) n) := by\n      rw [← measure_iUnion (disjoint_disjointed _) M, iUnion_disjointed, ← s_eq]\n    have J : ν s = ∑' n, ν (disjointed (fun n ↦ s ∩ f n • (k * k⁻¹)) n) := by\n      rw [← measure_iUnion (disjoint_disjointed _) M, iUnion_disjointed, ← s_eq]\n    rw [I, J]\n    congr with n\n    apply measure_isMulInvariant_eq_smul_of_isCompact_closure\n    have : IsCompact (f n • (k * k⁻¹)) := IsCompact.smul (f n) (k_comp.mul k_comp.inv)\n    exact this.closure_of_subset <| (disjointed_subset _ _).trans inter_subset_right\n  · have H : ∀ (ρ : Measure G), IsEverywherePos ρ s → ρ s = ∞ := by\n      intro ρ hρ\n      have M : ∀ (i : ↑m), MeasurableSet (s ∩ (i : G) • k) :=\n        fun i ↦ hs.inter (IsClosed.smul k_closed _).measurableSet\n      contrapose! h'm\n      have : ∑' (x : m), ρ (s ∩ ((x : G) • k)) < ∞ := by\n        apply lt_of_le_of_lt (MeasureTheory.tsum_meas_le_meas_iUnion_of_disjoint _ M _) _\n        · have I : PairwiseDisjoint m fun x ↦ s ∩ x • k :=\n            hdj.mono (fun x ↦ inter_subset_right)\n          exact I.on_injective Subtype.val_injective (fun x ↦ x.2)\n        · exact lt_of_le_of_lt (measure_mono (by simp [inter_subset_left])) h'm.lt_top\n      have C : Set.Countable (support fun (i : m) ↦ ρ (s ∩ (i : G) • k)) :=\n        Summable.countable_support_ennreal this.ne\n      have : support (fun (i : m) ↦ ρ (s ∩ (i : G) • k)) = univ := by\n        refine eq_univ_iff_forall.2 fun i ↦ ?_\n        refine ne_of_gt (hρ (i : G) (hms i.2) _ ?_)\n        exact inter_mem_nhdsWithin s (by simpa)\n      rw [this] at C\n      have : Countable m := countable_univ_iff.mp C\n      exact to_countable m\n    have Hν : IsEverywherePos ν s :=\n      h's.smul_measure_nnreal (haarScalarFactor_pos_of_isHaarMeasure _ _).ne'\n    have Hμ' : IsEverywherePos μ' s := by\n      apply Hν.of_forall_exists_nhds_eq (fun x _hx ↦ ?_)\n      obtain ⟨t, t_comp, t_mem⟩ : ∃ t, IsCompact t ∧ t ∈ 𝓝 x := exists_compact_mem_nhds x\n      refine ⟨t, t_mem, fun u hu ↦ ?_⟩\n      apply measure_isMulInvariant_eq_smul_of_isCompact_closure\n      exact t_comp.closure_of_subset hu\n    rw [H ν Hν, H μ' Hμ']\n\n"}
{"name":"MeasureTheory.Measure.measure_isAddHaarMeasure_eq_smul_of_isEverywherePos","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninst✝⁷ : TopologicalSpace G\ninst✝⁶ : AddGroup G\ninst✝⁵ : TopologicalAddGroup G\ninst✝⁴ : MeasurableSpace G\ninst✝³ : BorelSpace G\ninst✝² : LocallyCompactSpace G\nμ' μ : MeasureTheory.Measure G\ninst✝¹ : μ.IsAddHaarMeasure\ninst✝ : μ'.IsAddHaarMeasure\ns : Set G\nhs : MeasurableSet s\nh's : μ.IsEverywherePos s\n⊢ Eq (μ' s) (HSMul.hSMul (μ'.addHaarScalarFactor μ) (μ s))","decl":"@[to_additive measure_isAddHaarMeasure_eq_smul_of_isEverywherePos]\ntheorem measure_isHaarMeasure_eq_smul_of_isEverywherePos [LocallyCompactSpace G]\n    (μ' μ : Measure G) [IsHaarMeasure μ] [IsHaarMeasure μ']\n    {s : Set G} (hs : MeasurableSet s) (h's : IsEverywherePos μ s) :\n    μ' s = haarScalarFactor μ' μ • μ s := by\n  let ν := haarScalarFactor μ' μ • μ\n  change μ' s = ν s\n  /- Fix a compact neighborhood `k` of the identity, and consider a maximal disjoint family `m` of\n  sets `x • k` centered at points in `s`. Then `s` is covered by the sets `x • (k * k⁻¹)` by\n  maximality. If the family is countable, then since `μ'` and `ν` coincide in compact sets, and\n  the measure of a countable disjoint union is the sum of the measures, we get `μ' s = ν s`.\n  Otherwise, the family is uncountable, and each intersection with `s` has positive measure by\n  the everywhere positivity assumption, so `ν s = ∞`, and `μ' s = ∞` in the same way. -/\n  obtain ⟨k, k_comp, k_closed, k_mem⟩ : ∃ k, IsCompact k ∧ IsClosed k ∧ k ∈ 𝓝 (1 : G) := by\n    rcases exists_compact_mem_nhds (1 : G) with ⟨k, hk, hmem⟩\n    exact ⟨closure k, hk.closure, isClosed_closure, mem_of_superset hmem subset_closure⟩\n  have one_k : 1 ∈ k := mem_of_mem_nhds k_mem\n  let A : Set (Set G) := {t | t ⊆ s ∧ PairwiseDisjoint t (fun x ↦ x • k)}\n  obtain ⟨m, m_max⟩ : ∃ m, Maximal (· ∈ A) m := by\n    apply zorn_subset\n    intro c cA hc\n    refine ⟨⋃ a ∈ c, a, ⟨?_, ?_⟩, ?_⟩\n    · simp only [iUnion_subset_iff]\n      intro a ac x hx\n      simp only [A, subset_def, mem_setOf_eq] at cA\n      exact (cA _ ac).1 x hx\n    · rintro x hx y hy hxy\n      simp only [mem_iUnion, exists_prop] at hx hy\n      rcases hx with ⟨a, ac, xa⟩\n      rcases hy with ⟨b, bc, yb⟩\n      obtain ⟨m, mc, am, bm⟩ : ∃ m ∈ c, a ⊆ m ∧ b ⊆ m := hc.directedOn _ ac _ bc\n      exact (cA mc).2 (am xa) (bm yb) hxy\n    · intro a ac\n      exact subset_biUnion_of_mem (u := id) ac\n  obtain ⟨hms : m ⊆ s, hdj : PairwiseDisjoint m (fun x ↦ x • k)⟩ := m_max.prop\n  have sm : s ⊆ ⋃ x ∈ m, x • (k * k⁻¹) := by\n    intro y hy\n    by_cases h'y : m ∪ {y} ∈ A\n    · have ym : y ∈ m := m_max.mem_of_prop_insert (by simpa using h'y)\n      have : y ∈ y • (k * k⁻¹) := by\n        simpa using mem_leftCoset y (Set.mul_mem_mul one_k (Set.inv_mem_inv.mpr one_k))\n      exact mem_biUnion ym this\n    · obtain ⟨x, xm, -, z, zy, zx⟩ : ∃ x ∈ m, y ≠ x ∧ ∃ z, z ∈ y • k ∧ z ∈ x • k := by\n        simpa [A, hms, hy, insert_subset_iff, pairwiseDisjoint_insert, hdj, not_disjoint_iff]\n          using h'y\n      have : y ∈ x • (k * k⁻¹) := by\n        rw [show y = x * ((x⁻¹ * z) * (y⁻¹ * z)⁻¹) by group]\n        have : (x⁻¹ * z) * (y⁻¹ * z)⁻¹ ∈ k * k⁻¹ := Set.mul_mem_mul ((mem_leftCoset_iff x).mp zx)\n          (Set.inv_mem_inv.mpr ((mem_leftCoset_iff y).mp zy))\n        exact mem_leftCoset x this\n      exact mem_biUnion xm this\n  rcases eq_empty_or_nonempty m with rfl|hm\n  · simp only [mem_empty_iff_false, iUnion_of_empty, iUnion_empty, subset_empty_iff] at sm\n    simp [sm]\n  by_cases h'm : Set.Countable m\n  · rcases h'm.exists_eq_range hm with ⟨f, rfl⟩\n    have M i : MeasurableSet (disjointed (fun n ↦ s ∩ f n • (k * k⁻¹)) i) := by\n      apply MeasurableSet.disjointed (fun j ↦ hs.inter ?_)\n      have : IsClosed (k • k⁻¹) := IsClosed.smul_left_of_isCompact k_closed.inv k_comp\n      exact (IsClosed.smul this (f j)).measurableSet\n    simp only [mem_range, iUnion_exists, iUnion_iUnion_eq'] at sm\n    have s_eq : s = ⋃ n, s ∩ (f n • (k * k⁻¹)) := by rwa [← inter_iUnion, eq_comm, inter_eq_left]\n    have I : μ' s = ∑' n, μ' (disjointed (fun n ↦ s ∩ f n • (k * k⁻¹)) n) := by\n      rw [← measure_iUnion (disjoint_disjointed _) M, iUnion_disjointed, ← s_eq]\n    have J : ν s = ∑' n, ν (disjointed (fun n ↦ s ∩ f n • (k * k⁻¹)) n) := by\n      rw [← measure_iUnion (disjoint_disjointed _) M, iUnion_disjointed, ← s_eq]\n    rw [I, J]\n    congr with n\n    apply measure_isMulInvariant_eq_smul_of_isCompact_closure\n    have : IsCompact (f n • (k * k⁻¹)) := IsCompact.smul (f n) (k_comp.mul k_comp.inv)\n    exact this.closure_of_subset <| (disjointed_subset _ _).trans inter_subset_right\n  · have H : ∀ (ρ : Measure G), IsEverywherePos ρ s → ρ s = ∞ := by\n      intro ρ hρ\n      have M : ∀ (i : ↑m), MeasurableSet (s ∩ (i : G) • k) :=\n        fun i ↦ hs.inter (IsClosed.smul k_closed _).measurableSet\n      contrapose! h'm\n      have : ∑' (x : m), ρ (s ∩ ((x : G) • k)) < ∞ := by\n        apply lt_of_le_of_lt (MeasureTheory.tsum_meas_le_meas_iUnion_of_disjoint _ M _) _\n        · have I : PairwiseDisjoint m fun x ↦ s ∩ x • k :=\n            hdj.mono (fun x ↦ inter_subset_right)\n          exact I.on_injective Subtype.val_injective (fun x ↦ x.2)\n        · exact lt_of_le_of_lt (measure_mono (by simp [inter_subset_left])) h'm.lt_top\n      have C : Set.Countable (support fun (i : m) ↦ ρ (s ∩ (i : G) • k)) :=\n        Summable.countable_support_ennreal this.ne\n      have : support (fun (i : m) ↦ ρ (s ∩ (i : G) • k)) = univ := by\n        refine eq_univ_iff_forall.2 fun i ↦ ?_\n        refine ne_of_gt (hρ (i : G) (hms i.2) _ ?_)\n        exact inter_mem_nhdsWithin s (by simpa)\n      rw [this] at C\n      have : Countable m := countable_univ_iff.mp C\n      exact to_countable m\n    have Hν : IsEverywherePos ν s :=\n      h's.smul_measure_nnreal (haarScalarFactor_pos_of_isHaarMeasure _ _).ne'\n    have Hμ' : IsEverywherePos μ' s := by\n      apply Hν.of_forall_exists_nhds_eq (fun x _hx ↦ ?_)\n      obtain ⟨t, t_comp, t_mem⟩ : ∃ t, IsCompact t ∧ t ∈ 𝓝 x := exists_compact_mem_nhds x\n      refine ⟨t, t_mem, fun u hu ↦ ?_⟩\n      apply measure_isMulInvariant_eq_smul_of_isCompact_closure\n      exact t_comp.closure_of_subset hu\n    rw [H ν Hν, H μ' Hμ']\n\n"}
{"name":"MeasureTheory.Measure.measure_isAddHaarMeasure_eq_smul_of_isOpen","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninst✝⁷ : TopologicalSpace G\ninst✝⁶ : AddGroup G\ninst✝⁵ : TopologicalAddGroup G\ninst✝⁴ : MeasurableSpace G\ninst✝³ : BorelSpace G\ninst✝² : LocallyCompactSpace G\nμ' μ : MeasureTheory.Measure G\ninst✝¹ : μ.IsAddHaarMeasure\ninst✝ : μ'.IsAddHaarMeasure\ns : Set G\nhs : IsOpen s\n⊢ Eq (μ' s) (HSMul.hSMul (μ'.addHaarScalarFactor μ) (μ s))","decl":"/-- **Uniqueness of Haar measures**:\nGiven two Haar measures, they coincide in the following sense: they give the same value to open\nsets, up to the multiplicative constant `haarScalarFactor μ' μ`. -/\n@[to_additive measure_isAddHaarMeasure_eq_smul_of_isOpen\n\"**Uniqueness of Haar measures**:\nGiven two additive Haar measures, they coincide in the following sense: they give the same value to\nopen sets, up to the multiplicative constant `addHaarScalarFactor μ' μ`.\"]\ntheorem measure_isHaarMeasure_eq_smul_of_isOpen [LocallyCompactSpace G]\n    (μ' μ : Measure G) [IsHaarMeasure μ] [IsHaarMeasure μ'] {s : Set G} (hs : IsOpen s) :\n    μ' s = haarScalarFactor μ' μ • μ s :=\n  measure_isHaarMeasure_eq_smul_of_isEverywherePos μ' μ hs.measurableSet hs.isEverywherePos\n\n"}
{"name":"MeasureTheory.Measure.measure_isHaarMeasure_eq_smul_of_isOpen","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninst✝⁷ : TopologicalSpace G\ninst✝⁶ : Group G\ninst✝⁵ : TopologicalGroup G\ninst✝⁴ : MeasurableSpace G\ninst✝³ : BorelSpace G\ninst✝² : LocallyCompactSpace G\nμ' μ : MeasureTheory.Measure G\ninst✝¹ : μ.IsHaarMeasure\ninst✝ : μ'.IsHaarMeasure\ns : Set G\nhs : IsOpen s\n⊢ Eq (μ' s) (HSMul.hSMul (μ'.haarScalarFactor μ) (μ s))","decl":"/-- **Uniqueness of Haar measures**:\nGiven two Haar measures, they coincide in the following sense: they give the same value to open\nsets, up to the multiplicative constant `haarScalarFactor μ' μ`. -/\n@[to_additive measure_isAddHaarMeasure_eq_smul_of_isOpen\n\"**Uniqueness of Haar measures**:\nGiven two additive Haar measures, they coincide in the following sense: they give the same value to\nopen sets, up to the multiplicative constant `addHaarScalarFactor μ' μ`.\"]\ntheorem measure_isHaarMeasure_eq_smul_of_isOpen [LocallyCompactSpace G]\n    (μ' μ : Measure G) [IsHaarMeasure μ] [IsHaarMeasure μ'] {s : Set G} (hs : IsOpen s) :\n    μ' s = haarScalarFactor μ' μ • μ s :=\n  measure_isHaarMeasure_eq_smul_of_isEverywherePos μ' μ hs.measurableSet hs.isEverywherePos\n\n"}
{"name":"MeasureTheory.Measure.measure_isMulLeftInvariant_eq_smul_of_ne_top","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninst✝¹⁰ : TopologicalSpace G\ninst✝⁹ : Group G\ninst✝⁸ : TopologicalGroup G\ninst✝⁷ : MeasurableSpace G\ninst✝⁶ : BorelSpace G\ninst✝⁵ : LocallyCompactSpace G\nμ' μ : MeasureTheory.Measure G\ninst✝⁴ : μ.IsHaarMeasure\ninst✝³ : MeasureTheory.IsFiniteMeasureOnCompacts μ'\ninst✝² : μ'.IsMulLeftInvariant\ninst✝¹ : μ.InnerRegularCompactLTTop\ninst✝ : μ'.InnerRegularCompactLTTop\ns : Set G\nhs : Ne (μ s) Top.top\nh's : Ne (μ' s) Top.top\n⊢ Eq (μ' s) (HSMul.hSMul (μ'.haarScalarFactor μ) (μ s))","decl":"/-- **Uniqueness of left-invariant measures**:\nGiven two left-invariant measures which are finite on\ncompacts and inner regular for finite measure sets with respect to compact sets,\nthey coincide in the following sense: they give the same value to finite measure sets,\nup to a multiplicative constant. -/\n@[to_additive]\nlemma measure_isMulLeftInvariant_eq_smul_of_ne_top [LocallyCompactSpace G]\n    (μ' μ : Measure G) [IsHaarMeasure μ] [IsFiniteMeasureOnCompacts μ'] [IsMulLeftInvariant μ']\n    [InnerRegularCompactLTTop μ] [InnerRegularCompactLTTop μ'] {s : Set G}\n    (hs : μ s ≠ ∞) (h's : μ' s ≠ ∞) : μ' s = haarScalarFactor μ' μ • μ s := by\n  /- We know that the measures integrate in the same way continuous compactly supported functions,\n  up to the factor `c = haarScalarFactor μ' μ`. -/\n  let c := haarScalarFactor μ' μ\n  /- By regularity, every measurable set of finite measure may be approximated by compact sets.\n  Therefore, the measures coincide on measurable sets of finite measure. -/\n  have B : ∀ s, MeasurableSet s → μ s < ∞ → μ' s < ∞ → μ' s = (c • μ) s := by\n    intro s s_meas hs h's\n    have : (c • μ) s ≠ ∞ := by simp [ENNReal.mul_eq_top, hs.ne]\n    rw [s_meas.measure_eq_iSup_isCompact_of_ne_top h's.ne,\n        s_meas.measure_eq_iSup_isCompact_of_ne_top this]\n    congr! 4 with K _Ks K_comp\n    exact measure_isMulInvariant_eq_smul_of_isCompact_closure μ' μ K_comp.closure\n  /- Finally, replace an arbitrary finite measure set with a measurable version, and use the\n  version for measurable sets. -/\n  let t := toMeasurable μ' s ∩ toMeasurable μ s\n  have st : s ⊆ t := subset_inter (subset_toMeasurable μ' s) (subset_toMeasurable μ s)\n  have mu'_t : μ' t = μ' s := by\n    apply le_antisymm\n    · exact (measure_mono inter_subset_left).trans (measure_toMeasurable s).le\n    · exact measure_mono st\n  have mu_t : μ t = μ s := by\n    apply le_antisymm\n    · exact (measure_mono inter_subset_right).trans (measure_toMeasurable s).le\n    · exact measure_mono st\n  simp only [← mu'_t, smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, ← mu_t,\n    nnreal_smul_coe_apply]\n  apply B\n  · exact (measurableSet_toMeasurable _ _).inter (measurableSet_toMeasurable _ _)\n  · exact mu_t.le.trans_lt hs.lt_top\n  · exact mu'_t.le.trans_lt h's.lt_top\n\n"}
{"name":"MeasureTheory.Measure.measure_isAddLeftInvariant_eq_vadd_of_ne_top","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninst✝¹⁰ : TopologicalSpace G\ninst✝⁹ : AddGroup G\ninst✝⁸ : TopologicalAddGroup G\ninst✝⁷ : MeasurableSpace G\ninst✝⁶ : BorelSpace G\ninst✝⁵ : LocallyCompactSpace G\nμ' μ : MeasureTheory.Measure G\ninst✝⁴ : μ.IsAddHaarMeasure\ninst✝³ : MeasureTheory.IsFiniteMeasureOnCompacts μ'\ninst✝² : μ'.IsAddLeftInvariant\ninst✝¹ : μ.InnerRegularCompactLTTop\ninst✝ : μ'.InnerRegularCompactLTTop\ns : Set G\nhs : Ne (μ s) Top.top\nh's : Ne (μ' s) Top.top\n⊢ Eq (μ' s) (HSMul.hSMul (μ'.addHaarScalarFactor μ) (μ s))","decl":"/-- **Uniqueness of left-invariant measures**:\nGiven two left-invariant measures which are finite on\ncompacts and inner regular for finite measure sets with respect to compact sets,\nthey coincide in the following sense: they give the same value to finite measure sets,\nup to a multiplicative constant. -/\n@[to_additive]\nlemma measure_isMulLeftInvariant_eq_smul_of_ne_top [LocallyCompactSpace G]\n    (μ' μ : Measure G) [IsHaarMeasure μ] [IsFiniteMeasureOnCompacts μ'] [IsMulLeftInvariant μ']\n    [InnerRegularCompactLTTop μ] [InnerRegularCompactLTTop μ'] {s : Set G}\n    (hs : μ s ≠ ∞) (h's : μ' s ≠ ∞) : μ' s = haarScalarFactor μ' μ • μ s := by\n  /- We know that the measures integrate in the same way continuous compactly supported functions,\n  up to the factor `c = haarScalarFactor μ' μ`. -/\n  let c := haarScalarFactor μ' μ\n  /- By regularity, every measurable set of finite measure may be approximated by compact sets.\n  Therefore, the measures coincide on measurable sets of finite measure. -/\n  have B : ∀ s, MeasurableSet s → μ s < ∞ → μ' s < ∞ → μ' s = (c • μ) s := by\n    intro s s_meas hs h's\n    have : (c • μ) s ≠ ∞ := by simp [ENNReal.mul_eq_top, hs.ne]\n    rw [s_meas.measure_eq_iSup_isCompact_of_ne_top h's.ne,\n        s_meas.measure_eq_iSup_isCompact_of_ne_top this]\n    congr! 4 with K _Ks K_comp\n    exact measure_isMulInvariant_eq_smul_of_isCompact_closure μ' μ K_comp.closure\n  /- Finally, replace an arbitrary finite measure set with a measurable version, and use the\n  version for measurable sets. -/\n  let t := toMeasurable μ' s ∩ toMeasurable μ s\n  have st : s ⊆ t := subset_inter (subset_toMeasurable μ' s) (subset_toMeasurable μ s)\n  have mu'_t : μ' t = μ' s := by\n    apply le_antisymm\n    · exact (measure_mono inter_subset_left).trans (measure_toMeasurable s).le\n    · exact measure_mono st\n  have mu_t : μ t = μ s := by\n    apply le_antisymm\n    · exact (measure_mono inter_subset_right).trans (measure_toMeasurable s).le\n    · exact measure_mono st\n  simp only [← mu'_t, smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, ← mu_t,\n    nnreal_smul_coe_apply]\n  apply B\n  · exact (measurableSet_toMeasurable _ _).inter (measurableSet_toMeasurable _ _)\n  · exact mu_t.le.trans_lt hs.lt_top\n  · exact mu'_t.le.trans_lt h's.lt_top\n\n"}
{"name":"MeasureTheory.Measure.isMulLeftInvariant_eq_smul_of_innerRegular","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninst✝¹⁰ : TopologicalSpace G\ninst✝⁹ : Group G\ninst✝⁸ : TopologicalGroup G\ninst✝⁷ : MeasurableSpace G\ninst✝⁶ : BorelSpace G\ninst✝⁵ : LocallyCompactSpace G\nμ' μ : MeasureTheory.Measure G\ninst✝⁴ : μ.IsHaarMeasure\ninst✝³ : MeasureTheory.IsFiniteMeasureOnCompacts μ'\ninst✝² : μ'.IsMulLeftInvariant\ninst✝¹ : μ.InnerRegular\ninst✝ : μ'.InnerRegular\n⊢ Eq μ' (HSMul.hSMul (μ'.haarScalarFactor μ) μ)","decl":"/-- **Uniqueness of left-invariant measures**:\nGiven two left-invariant measures which are finite\non compacts and inner regular, they coincide up to a multiplicative constant. -/\n@[to_additive isAddLeftInvariant_eq_smul_of_innerRegular]\nlemma isMulLeftInvariant_eq_smul_of_innerRegular [LocallyCompactSpace G]\n    (μ' μ : Measure G) [IsHaarMeasure μ] [IsFiniteMeasureOnCompacts μ'] [IsMulLeftInvariant μ']\n    [InnerRegular μ] [InnerRegular μ'] :\n    μ' = haarScalarFactor μ' μ • μ := by\n  ext s hs\n  rw [hs.measure_eq_iSup_isCompact, hs.measure_eq_iSup_isCompact]\n  congr! 4 with K _Ks K_comp\n  exact measure_isMulLeftInvariant_eq_smul_of_ne_top μ' μ K_comp.measure_lt_top.ne\n    K_comp.measure_lt_top.ne\n\n"}
{"name":"MeasureTheory.Measure.isAddLeftInvariant_eq_smul_of_innerRegular","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninst✝¹⁰ : TopologicalSpace G\ninst✝⁹ : AddGroup G\ninst✝⁸ : TopologicalAddGroup G\ninst✝⁷ : MeasurableSpace G\ninst✝⁶ : BorelSpace G\ninst✝⁵ : LocallyCompactSpace G\nμ' μ : MeasureTheory.Measure G\ninst✝⁴ : μ.IsAddHaarMeasure\ninst✝³ : MeasureTheory.IsFiniteMeasureOnCompacts μ'\ninst✝² : μ'.IsAddLeftInvariant\ninst✝¹ : μ.InnerRegular\ninst✝ : μ'.InnerRegular\n⊢ Eq μ' (HSMul.hSMul (μ'.addHaarScalarFactor μ) μ)","decl":"/-- **Uniqueness of left-invariant measures**:\nGiven two left-invariant measures which are finite\non compacts and inner regular, they coincide up to a multiplicative constant. -/\n@[to_additive isAddLeftInvariant_eq_smul_of_innerRegular]\nlemma isMulLeftInvariant_eq_smul_of_innerRegular [LocallyCompactSpace G]\n    (μ' μ : Measure G) [IsHaarMeasure μ] [IsFiniteMeasureOnCompacts μ'] [IsMulLeftInvariant μ']\n    [InnerRegular μ] [InnerRegular μ'] :\n    μ' = haarScalarFactor μ' μ • μ := by\n  ext s hs\n  rw [hs.measure_eq_iSup_isCompact, hs.measure_eq_iSup_isCompact]\n  congr! 4 with K _Ks K_comp\n  exact measure_isMulLeftInvariant_eq_smul_of_ne_top μ' μ K_comp.measure_lt_top.ne\n    K_comp.measure_lt_top.ne\n\n"}
{"name":"MeasureTheory.Measure.isAddLeftInvariant_eq_smul_of_regular","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninst✝¹⁰ : TopologicalSpace G\ninst✝⁹ : AddGroup G\ninst✝⁸ : TopologicalAddGroup G\ninst✝⁷ : MeasurableSpace G\ninst✝⁶ : BorelSpace G\ninst✝⁵ : LocallyCompactSpace G\nμ' μ : MeasureTheory.Measure G\ninst✝⁴ : μ.IsAddHaarMeasure\ninst✝³ : MeasureTheory.IsFiniteMeasureOnCompacts μ'\ninst✝² : μ'.IsAddLeftInvariant\ninst✝¹ : μ.Regular\ninst✝ : μ'.Regular\n⊢ Eq μ' (HSMul.hSMul (μ'.addHaarScalarFactor μ) μ)","decl":"/-- **Uniqueness of left-invariant measures**:\nGiven two left-invariant measures which are finite\non compacts and regular, they coincide up to a multiplicative constant. -/\n@[to_additive isAddLeftInvariant_eq_smul_of_regular]\nlemma isMulLeftInvariant_eq_smul_of_regular [LocallyCompactSpace G]\n    (μ' μ : Measure G) [IsHaarMeasure μ] [IsFiniteMeasureOnCompacts μ'] [IsMulLeftInvariant μ']\n    [Regular μ] [Regular μ'] :\n    μ' = haarScalarFactor μ' μ • μ := by\n  have A : ∀ U, IsOpen U → μ' U = (haarScalarFactor μ' μ • μ) U := by\n    intro U hU\n    rw [hU.measure_eq_iSup_isCompact, hU.measure_eq_iSup_isCompact]\n    congr! 4 with K _KU K_comp\n    exact measure_isMulLeftInvariant_eq_smul_of_ne_top μ' μ K_comp.measure_lt_top.ne\n      K_comp.measure_lt_top.ne\n  ext s _hs\n  rw [s.measure_eq_iInf_isOpen, s.measure_eq_iInf_isOpen]\n  congr! 4 with U _sU U_open\n  exact A U U_open\n\n"}
{"name":"MeasureTheory.Measure.isMulLeftInvariant_eq_smul_of_regular","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninst✝¹⁰ : TopologicalSpace G\ninst✝⁹ : Group G\ninst✝⁸ : TopologicalGroup G\ninst✝⁷ : MeasurableSpace G\ninst✝⁶ : BorelSpace G\ninst✝⁵ : LocallyCompactSpace G\nμ' μ : MeasureTheory.Measure G\ninst✝⁴ : μ.IsHaarMeasure\ninst✝³ : MeasureTheory.IsFiniteMeasureOnCompacts μ'\ninst✝² : μ'.IsMulLeftInvariant\ninst✝¹ : μ.Regular\ninst✝ : μ'.Regular\n⊢ Eq μ' (HSMul.hSMul (μ'.haarScalarFactor μ) μ)","decl":"/-- **Uniqueness of left-invariant measures**:\nGiven two left-invariant measures which are finite\non compacts and regular, they coincide up to a multiplicative constant. -/\n@[to_additive isAddLeftInvariant_eq_smul_of_regular]\nlemma isMulLeftInvariant_eq_smul_of_regular [LocallyCompactSpace G]\n    (μ' μ : Measure G) [IsHaarMeasure μ] [IsFiniteMeasureOnCompacts μ'] [IsMulLeftInvariant μ']\n    [Regular μ] [Regular μ'] :\n    μ' = haarScalarFactor μ' μ • μ := by\n  have A : ∀ U, IsOpen U → μ' U = (haarScalarFactor μ' μ • μ) U := by\n    intro U hU\n    rw [hU.measure_eq_iSup_isCompact, hU.measure_eq_iSup_isCompact]\n    congr! 4 with K _KU K_comp\n    exact measure_isMulLeftInvariant_eq_smul_of_ne_top μ' μ K_comp.measure_lt_top.ne\n      K_comp.measure_lt_top.ne\n  ext s _hs\n  rw [s.measure_eq_iInf_isOpen, s.measure_eq_iInf_isOpen]\n  congr! 4 with U _sU U_open\n  exact A U U_open\n\n"}
{"name":"MeasureTheory.Measure.isAddLeftInvariant_eq_smul","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninst✝⁹ : TopologicalSpace G\ninst✝⁸ : AddGroup G\ninst✝⁷ : TopologicalAddGroup G\ninst✝⁶ : MeasurableSpace G\ninst✝⁵ : BorelSpace G\ninst✝⁴ : LocallyCompactSpace G\ninst✝³ : SecondCountableTopology G\nμ' μ : MeasureTheory.Measure G\ninst✝² : μ.IsAddHaarMeasure\ninst✝¹ : MeasureTheory.IsFiniteMeasureOnCompacts μ'\ninst✝ : μ'.IsAddLeftInvariant\n⊢ Eq μ' (HSMul.hSMul (μ'.addHaarScalarFactor μ) μ)","decl":"/-- **Uniqueness of left-invariant measures**:\nTwo Haar measures coincide up to a multiplicative constant in a second countable group. -/\n@[to_additive isAddLeftInvariant_eq_smul]\nlemma isMulLeftInvariant_eq_smul [LocallyCompactSpace G] [SecondCountableTopology G]\n    (μ' μ : Measure G) [IsHaarMeasure μ] [IsFiniteMeasureOnCompacts μ'] [IsMulLeftInvariant μ'] :\n    μ' = haarScalarFactor μ' μ • μ :=\n  isMulLeftInvariant_eq_smul_of_regular μ' μ\n  -- one could use as well `isMulLeftInvariant_eq_smul_of_innerRegular`, as in a\n  -- second countable topological space all Haar measures are regular and inner regular\n\n\n"}
{"name":"MeasureTheory.Measure.isMulLeftInvariant_eq_smul","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninst✝⁹ : TopologicalSpace G\ninst✝⁸ : Group G\ninst✝⁷ : TopologicalGroup G\ninst✝⁶ : MeasurableSpace G\ninst✝⁵ : BorelSpace G\ninst✝⁴ : LocallyCompactSpace G\ninst✝³ : SecondCountableTopology G\nμ' μ : MeasureTheory.Measure G\ninst✝² : μ.IsHaarMeasure\ninst✝¹ : MeasureTheory.IsFiniteMeasureOnCompacts μ'\ninst✝ : μ'.IsMulLeftInvariant\n⊢ Eq μ' (HSMul.hSMul (μ'.haarScalarFactor μ) μ)","decl":"/-- **Uniqueness of left-invariant measures**:\nTwo Haar measures coincide up to a multiplicative constant in a second countable group. -/\n@[to_additive isAddLeftInvariant_eq_smul]\nlemma isMulLeftInvariant_eq_smul [LocallyCompactSpace G] [SecondCountableTopology G]\n    (μ' μ : Measure G) [IsHaarMeasure μ] [IsFiniteMeasureOnCompacts μ'] [IsMulLeftInvariant μ'] :\n    μ' = haarScalarFactor μ' μ • μ :=\n  isMulLeftInvariant_eq_smul_of_regular μ' μ\n  -- one could use as well `isMulLeftInvariant_eq_smul_of_innerRegular`, as in a\n  -- second countable topological space all Haar measures are regular and inner regular\n\n\n"}
{"name":"MeasureTheory.Measure.absolutelyContinuous_isHaarMeasure","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninst✝⁹ : TopologicalSpace G\ninst✝⁸ : Group G\ninst✝⁷ : TopologicalGroup G\ninst✝⁶ : MeasurableSpace G\ninst✝⁵ : BorelSpace G\ninst✝⁴ : LocallyCompactSpace G\ninst✝³ : SecondCountableTopology G\nμ ν : MeasureTheory.Measure G\ninst✝² : MeasureTheory.SigmaFinite μ\ninst✝¹ : μ.IsMulLeftInvariant\ninst✝ : ν.IsHaarMeasure\n⊢ μ.AbsolutelyContinuous ν","decl":"/-- An invariant σ-finite measure is absolutely continuous with respect to a Haar measure in a\nsecond countable group. -/\n@[to_additive\n\"An invariant measure is absolutely continuous with respect to an additive Haar measure. \"]\ntheorem absolutelyContinuous_isHaarMeasure [LocallyCompactSpace G]\n    [SecondCountableTopology G] (μ ν : Measure G)\n    [SigmaFinite μ] [IsMulLeftInvariant μ] [IsHaarMeasure ν] : μ ≪ ν := by\n  have K : PositiveCompacts G := Classical.arbitrary _\n  have h : haarMeasure K = (haarScalarFactor (haarMeasure K) ν : ℝ≥0∞) • ν :=\n    isMulLeftInvariant_eq_smul (haarMeasure K) ν\n  rw [haarMeasure_unique μ K, h, smul_smul]\n  exact smul_absolutelyContinuous\n\n"}
{"name":"MeasureTheory.Measure.absolutelyContinuous_isAddHaarMeasure","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninst✝⁹ : TopologicalSpace G\ninst✝⁸ : AddGroup G\ninst✝⁷ : TopologicalAddGroup G\ninst✝⁶ : MeasurableSpace G\ninst✝⁵ : BorelSpace G\ninst✝⁴ : LocallyCompactSpace G\ninst✝³ : SecondCountableTopology G\nμ ν : MeasureTheory.Measure G\ninst✝² : MeasureTheory.SigmaFinite μ\ninst✝¹ : μ.IsAddLeftInvariant\ninst✝ : ν.IsAddHaarMeasure\n⊢ μ.AbsolutelyContinuous ν","decl":"/-- An invariant σ-finite measure is absolutely continuous with respect to a Haar measure in a\nsecond countable group. -/\n@[to_additive\n\"An invariant measure is absolutely continuous with respect to an additive Haar measure. \"]\ntheorem absolutelyContinuous_isHaarMeasure [LocallyCompactSpace G]\n    [SecondCountableTopology G] (μ ν : Measure G)\n    [SigmaFinite μ] [IsMulLeftInvariant μ] [IsHaarMeasure ν] : μ ≪ ν := by\n  have K : PositiveCompacts G := Classical.arbitrary _\n  have h : haarMeasure K = (haarScalarFactor (haarMeasure K) ν : ℝ≥0∞) • ν :=\n    isMulLeftInvariant_eq_smul (haarMeasure K) ν\n  rw [haarMeasure_unique μ K, h, smul_smul]\n  exact smul_absolutelyContinuous\n\n"}
{"name":"AddMonoidHom.measurePreserving","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninst✝¹² : TopologicalSpace G\ninst✝¹¹ : AddGroup G\ninst✝¹⁰ : TopologicalAddGroup G\ninst✝⁹ : MeasurableSpace G\ninst✝⁸ : BorelSpace G\nH : Type u_2\ninst✝⁷ : AddGroup H\ninst✝⁶ : TopologicalSpace H\ninst✝⁵ : TopologicalAddGroup H\ninst✝⁴ : CompactSpace H\ninst✝³ : MeasurableSpace H\ninst✝² : BorelSpace H\nμ : MeasureTheory.Measure G\ninst✝¹ : μ.IsAddHaarMeasure\nν : MeasureTheory.Measure H\ninst✝ : ν.IsAddHaarMeasure\nf : AddMonoidHom G H\nhcont : Continuous ⇑f\nhsurj : Function.Surjective ⇑f\nhuniv : Eq (μ Set.univ) (ν Set.univ)\n⊢ MeasureTheory.MeasurePreserving (⇑f) μ ν","decl":"/-- A continuous surjective monoid homomorphism of topological groups with compact codomain\nis measure preserving, provided that the Haar measures on the domain and on the codomain\nhave the same total mass.\n-/\n@[to_additive\n  \"A continuous surjective additive monoid homomorphism of topological groups with compact codomain\nis measure preserving, provided that the Haar measures on the domain and on the codomain\nhave the same total mass.\"]\ntheorem _root_.MonoidHom.measurePreserving\n    {H : Type*} [Group H] [TopologicalSpace H] [TopologicalGroup H] [CompactSpace H]\n    [MeasurableSpace H] [BorelSpace H]\n    {μ : Measure G} [IsHaarMeasure μ] {ν : Measure H} [IsHaarMeasure ν]\n    {f : G →* H} (hcont : Continuous f) (hsurj : Surjective f) (huniv : μ univ = ν univ) :\n    MeasurePreserving f μ ν where\n  measurable := hcont.measurable\n  map_eq := by\n    have : IsFiniteMeasure μ := ⟨by rw [huniv]; apply measure_lt_top⟩\n    have : (μ.map f).IsHaarMeasure := isHaarMeasure_map_of_isFiniteMeasure μ f hcont hsurj\n    set C : ℝ≥0 := haarScalarFactor (μ.map f) ν\n    have hC : μ.map f = C • ν := isMulLeftInvariant_eq_smul_of_innerRegular _ _\n    suffices C = 1 by rwa [this, one_smul] at hC\n    have : C * ν univ = 1 * ν univ := by\n      rw [one_mul, ← smul_eq_mul, ← ENNReal.smul_def, ← smul_apply, ← hC,\n        map_apply hcont.measurable .univ, preimage_univ, huniv]\n    rwa [ENNReal.mul_left_inj (NeZero.ne _) (measure_ne_top _ _), ENNReal.coe_eq_one] at this\n\n"}
{"name":"MonoidHom.measurePreserving","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninst✝¹² : TopologicalSpace G\ninst✝¹¹ : Group G\ninst✝¹⁰ : TopologicalGroup G\ninst✝⁹ : MeasurableSpace G\ninst✝⁸ : BorelSpace G\nH : Type u_2\ninst✝⁷ : Group H\ninst✝⁶ : TopologicalSpace H\ninst✝⁵ : TopologicalGroup H\ninst✝⁴ : CompactSpace H\ninst✝³ : MeasurableSpace H\ninst✝² : BorelSpace H\nμ : MeasureTheory.Measure G\ninst✝¹ : μ.IsHaarMeasure\nν : MeasureTheory.Measure H\ninst✝ : ν.IsHaarMeasure\nf : MonoidHom G H\nhcont : Continuous ⇑f\nhsurj : Function.Surjective ⇑f\nhuniv : Eq (μ Set.univ) (ν Set.univ)\n⊢ MeasureTheory.MeasurePreserving (⇑f) μ ν","decl":"/-- A continuous surjective monoid homomorphism of topological groups with compact codomain\nis measure preserving, provided that the Haar measures on the domain and on the codomain\nhave the same total mass.\n-/\n@[to_additive\n  \"A continuous surjective additive monoid homomorphism of topological groups with compact codomain\nis measure preserving, provided that the Haar measures on the domain and on the codomain\nhave the same total mass.\"]\ntheorem _root_.MonoidHom.measurePreserving\n    {H : Type*} [Group H] [TopologicalSpace H] [TopologicalGroup H] [CompactSpace H]\n    [MeasurableSpace H] [BorelSpace H]\n    {μ : Measure G} [IsHaarMeasure μ] {ν : Measure H} [IsHaarMeasure ν]\n    {f : G →* H} (hcont : Continuous f) (hsurj : Surjective f) (huniv : μ univ = ν univ) :\n    MeasurePreserving f μ ν where\n  measurable := hcont.measurable\n  map_eq := by\n    have : IsFiniteMeasure μ := ⟨by rw [huniv]; apply measure_lt_top⟩\n    have : (μ.map f).IsHaarMeasure := isHaarMeasure_map_of_isFiniteMeasure μ f hcont hsurj\n    set C : ℝ≥0 := haarScalarFactor (μ.map f) ν\n    have hC : μ.map f = C • ν := isMulLeftInvariant_eq_smul_of_innerRegular _ _\n    suffices C = 1 by rwa [this, one_smul] at hC\n    have : C * ν univ = 1 * ν univ := by\n      rw [one_mul, ← smul_eq_mul, ← ENNReal.smul_def, ← smul_apply, ← hC,\n        map_apply hcont.measurable .univ, preimage_univ, huniv]\n    rwa [ENNReal.mul_left_inj (NeZero.ne _) (measure_ne_top _ _), ENNReal.coe_eq_one] at this\n\n"}
{"name":"MeasureTheory.Measure.IsAddHaarMeasure.isNegInvariant_of_regular","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninst✝⁴ : AddCommGroup G\ninst✝³ : TopologicalSpace G\ninst✝² : MeasurableSpace G\nμ : MeasureTheory.Measure G\ninst✝¹ : LocallyCompactSpace G\ninst✝ : μ.Regular\n⊢ μ.IsNegInvariant","decl":"/-- Any regular Haar measure is invariant under inversion in an abelian group. -/\n@[to_additive \"Any regular additive Haar measure is invariant under negation in an abelian group.\"]\ninstance (priority := 100) IsHaarMeasure.isInvInvariant_of_regular\n    [LocallyCompactSpace G] [Regular μ] : IsInvInvariant μ := by\n  -- the image measure is a Haar measure. By uniqueness up to multiplication, it is of the form\n  -- `c μ`. Applying again inversion, one gets the measure `c^2 μ`. But since inversion is an\n  -- involution, this is also `μ`. Hence, `c^2 = 1`, which implies `c = 1`.\n  constructor\n  let c : ℝ≥0∞ := haarScalarFactor μ.inv μ\n  have hc : μ.inv = c • μ := isMulLeftInvariant_eq_smul_of_regular μ.inv μ\n  have : map Inv.inv (map Inv.inv μ) = c ^ 2 • μ := by\n    rw [← inv_def μ, hc, Measure.map_smul, ← inv_def μ, hc, smul_smul, pow_two]\n  have μeq : μ = c ^ 2 • μ := by\n    rw [map_map continuous_inv.measurable continuous_inv.measurable] at this\n    simpa only [inv_involutive, Involutive.comp_self, Measure.map_id]\n  have K : PositiveCompacts G := Classical.arbitrary _\n  have : c ^ 2 * μ K = 1 ^ 2 * μ K := by\n    conv_rhs => rw [μeq]\n    simp\n  have : c ^ 2 = 1 ^ 2 :=\n    (ENNReal.mul_left_inj (measure_pos_of_nonempty_interior _ K.interior_nonempty).ne'\n          K.isCompact.measure_lt_top.ne).1 this\n  have : c = 1 := (ENNReal.pow_right_strictMono two_ne_zero).injective this\n  rw [hc, this, one_smul]\n\n"}
{"name":"MeasureTheory.Measure.IsHaarMeasure.isInvInvariant_of_regular","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninst✝⁴ : CommGroup G\ninst✝³ : TopologicalSpace G\ninst✝² : MeasurableSpace G\nμ : MeasureTheory.Measure G\ninst✝¹ : LocallyCompactSpace G\ninst✝ : μ.Regular\n⊢ μ.IsInvInvariant","decl":"/-- Any regular Haar measure is invariant under inversion in an abelian group. -/\n@[to_additive \"Any regular additive Haar measure is invariant under negation in an abelian group.\"]\ninstance (priority := 100) IsHaarMeasure.isInvInvariant_of_regular\n    [LocallyCompactSpace G] [Regular μ] : IsInvInvariant μ := by\n  -- the image measure is a Haar measure. By uniqueness up to multiplication, it is of the form\n  -- `c μ`. Applying again inversion, one gets the measure `c^2 μ`. But since inversion is an\n  -- involution, this is also `μ`. Hence, `c^2 = 1`, which implies `c = 1`.\n  constructor\n  let c : ℝ≥0∞ := haarScalarFactor μ.inv μ\n  have hc : μ.inv = c • μ := isMulLeftInvariant_eq_smul_of_regular μ.inv μ\n  have : map Inv.inv (map Inv.inv μ) = c ^ 2 • μ := by\n    rw [← inv_def μ, hc, Measure.map_smul, ← inv_def μ, hc, smul_smul, pow_two]\n  have μeq : μ = c ^ 2 • μ := by\n    rw [map_map continuous_inv.measurable continuous_inv.measurable] at this\n    simpa only [inv_involutive, Involutive.comp_self, Measure.map_id]\n  have K : PositiveCompacts G := Classical.arbitrary _\n  have : c ^ 2 * μ K = 1 ^ 2 * μ K := by\n    conv_rhs => rw [μeq]\n    simp\n  have : c ^ 2 = 1 ^ 2 :=\n    (ENNReal.mul_left_inj (measure_pos_of_nonempty_interior _ K.interior_nonempty).ne'\n          K.isCompact.measure_lt_top.ne).1 this\n  have : c = 1 := (ENNReal.pow_right_strictMono two_ne_zero).injective this\n  rw [hc, this, one_smul]\n\n"}
{"name":"MeasureTheory.Measure.IsAddHaarMeasure.isNegInvariant_of_innerRegular","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninst✝⁴ : AddCommGroup G\ninst✝³ : TopologicalSpace G\ninst✝² : MeasurableSpace G\nμ : MeasureTheory.Measure G\ninst✝¹ : LocallyCompactSpace G\ninst✝ : μ.InnerRegular\n⊢ μ.IsNegInvariant","decl":"/-- Any inner regular Haar measure is invariant under inversion in an abelian group. -/\n@[to_additive \"Any regular additive Haar measure is invariant under negation in an abelian group.\"]\ninstance (priority := 100) IsHaarMeasure.isInvInvariant_of_innerRegular\n    [LocallyCompactSpace G] [InnerRegular μ] : IsInvInvariant μ := by\n  -- the image measure is a Haar measure. By uniqueness up to multiplication, it is of the form\n  -- `c μ`. Applying again inversion, one gets the measure `c^2 μ`. But since inversion is an\n  -- involution, this is also `μ`. Hence, `c^2 = 1`, which implies `c = 1`.\n  constructor\n  let c : ℝ≥0∞ := haarScalarFactor μ.inv μ\n  have hc : μ.inv = c • μ := isMulLeftInvariant_eq_smul_of_innerRegular μ.inv μ\n  have : map Inv.inv (map Inv.inv μ) = c ^ 2 • μ := by\n    rw [← inv_def μ, hc, Measure.map_smul, ← inv_def μ, hc, smul_smul, pow_two]\n  have μeq : μ = c ^ 2 • μ := by\n    rw [map_map continuous_inv.measurable continuous_inv.measurable] at this\n    simpa only [inv_involutive, Involutive.comp_self, Measure.map_id]\n  have K : PositiveCompacts G := Classical.arbitrary _\n  have : c ^ 2 * μ K = 1 ^ 2 * μ K := by\n    conv_rhs => rw [μeq]\n    simp\n  have : c ^ 2 = 1 ^ 2 :=\n    (ENNReal.mul_left_inj (measure_pos_of_nonempty_interior _ K.interior_nonempty).ne'\n          K.isCompact.measure_lt_top.ne).1 this\n  have : c = 1 := (ENNReal.pow_right_strictMono two_ne_zero).injective this\n  rw [hc, this, one_smul]\n\n"}
{"name":"MeasureTheory.Measure.IsHaarMeasure.isInvInvariant_of_innerRegular","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninst✝⁴ : CommGroup G\ninst✝³ : TopologicalSpace G\ninst✝² : MeasurableSpace G\nμ : MeasureTheory.Measure G\ninst✝¹ : LocallyCompactSpace G\ninst✝ : μ.InnerRegular\n⊢ μ.IsInvInvariant","decl":"/-- Any inner regular Haar measure is invariant under inversion in an abelian group. -/\n@[to_additive \"Any regular additive Haar measure is invariant under negation in an abelian group.\"]\ninstance (priority := 100) IsHaarMeasure.isInvInvariant_of_innerRegular\n    [LocallyCompactSpace G] [InnerRegular μ] : IsInvInvariant μ := by\n  -- the image measure is a Haar measure. By uniqueness up to multiplication, it is of the form\n  -- `c μ`. Applying again inversion, one gets the measure `c^2 μ`. But since inversion is an\n  -- involution, this is also `μ`. Hence, `c^2 = 1`, which implies `c = 1`.\n  constructor\n  let c : ℝ≥0∞ := haarScalarFactor μ.inv μ\n  have hc : μ.inv = c • μ := isMulLeftInvariant_eq_smul_of_innerRegular μ.inv μ\n  have : map Inv.inv (map Inv.inv μ) = c ^ 2 • μ := by\n    rw [← inv_def μ, hc, Measure.map_smul, ← inv_def μ, hc, smul_smul, pow_two]\n  have μeq : μ = c ^ 2 • μ := by\n    rw [map_map continuous_inv.measurable continuous_inv.measurable] at this\n    simpa only [inv_involutive, Involutive.comp_self, Measure.map_id]\n  have K : PositiveCompacts G := Classical.arbitrary _\n  have : c ^ 2 * μ K = 1 ^ 2 * μ K := by\n    conv_rhs => rw [μeq]\n    simp\n  have : c ^ 2 = 1 ^ 2 :=\n    (ENNReal.mul_left_inj (measure_pos_of_nonempty_interior _ K.interior_nonempty).ne'\n          K.isCompact.measure_lt_top.ne).1 this\n  have : c = 1 := (ENNReal.pow_right_strictMono two_ne_zero).injective this\n  rw [hc, this, one_smul]\n\n"}
{"name":"MeasureTheory.Measure.measurePreserving_zpow","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninst✝⁷ : CommGroup G\ninst✝⁶ : TopologicalSpace G\ninst✝⁵ : TopologicalGroup G\ninst✝⁴ : MeasurableSpace G\ninst✝³ : BorelSpace G\nμ : MeasureTheory.Measure G\ninst✝² : μ.IsHaarMeasure\ninst✝¹ : CompactSpace G\ninst✝ : RootableBy G Int\nn : Int\nhn : Ne n 0\n⊢ MeasureTheory.MeasurePreserving (fun g => HPow.hPow g n) μ μ","decl":"@[to_additive]\ntheorem measurePreserving_zpow [CompactSpace G] [RootableBy G ℤ] {n : ℤ} (hn : n ≠ 0) :\n    MeasurePreserving (fun g : G => g ^ n) μ μ :=\n  (zpowGroupHom n).measurePreserving (μ := μ) (continuous_zpow n)\n    (RootableBy.surjective_pow G ℤ hn) rfl\n\n"}
{"name":"MeasureTheory.Measure.measurePreserving_zsmul","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninst✝⁷ : AddCommGroup G\ninst✝⁶ : TopologicalSpace G\ninst✝⁵ : TopologicalAddGroup G\ninst✝⁴ : MeasurableSpace G\ninst✝³ : BorelSpace G\nμ : MeasureTheory.Measure G\ninst✝² : μ.IsAddHaarMeasure\ninst✝¹ : CompactSpace G\ninst✝ : DivisibleBy G Int\nn : Int\nhn : Ne n 0\n⊢ MeasureTheory.MeasurePreserving (fun g => HSMul.hSMul n g) μ μ","decl":"@[to_additive]\ntheorem measurePreserving_zpow [CompactSpace G] [RootableBy G ℤ] {n : ℤ} (hn : n ≠ 0) :\n    MeasurePreserving (fun g : G => g ^ n) μ μ :=\n  (zpowGroupHom n).measurePreserving (μ := μ) (continuous_zpow n)\n    (RootableBy.surjective_pow G ℤ hn) rfl\n\n"}
{"name":"MeasureTheory.Measure.MeasurePreserving.zpow","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninst✝⁸ : CommGroup G\ninst✝⁷ : TopologicalSpace G\ninst✝⁶ : TopologicalGroup G\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : BorelSpace G\nμ : MeasureTheory.Measure G\ninst✝³ : μ.IsHaarMeasure\ninst✝² : CompactSpace G\ninst✝¹ : RootableBy G Int\nn : Int\nhn : Ne n 0\nX : Type u_2\ninst✝ : MeasurableSpace X\nμ' : MeasureTheory.Measure X\nf : X → G\nhf : MeasureTheory.MeasurePreserving f μ' μ\n⊢ MeasureTheory.MeasurePreserving (fun x => HPow.hPow (f x) n) μ' μ","decl":"@[to_additive]\ntheorem MeasurePreserving.zpow [CompactSpace G] [RootableBy G ℤ]\n    {n : ℤ} (hn : n ≠ 0) {X : Type*}\n    [MeasurableSpace X] {μ' : Measure X} {f : X → G} (hf : MeasurePreserving f μ' μ) :\n    MeasurePreserving (fun x => f x ^ n) μ' μ :=\n  (measurePreserving_zpow μ hn).comp hf\n\n"}
{"name":"MeasureTheory.Measure.MeasurePreserving.zsmul","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninst✝⁸ : AddCommGroup G\ninst✝⁷ : TopologicalSpace G\ninst✝⁶ : TopologicalAddGroup G\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : BorelSpace G\nμ : MeasureTheory.Measure G\ninst✝³ : μ.IsAddHaarMeasure\ninst✝² : CompactSpace G\ninst✝¹ : DivisibleBy G Int\nn : Int\nhn : Ne n 0\nX : Type u_2\ninst✝ : MeasurableSpace X\nμ' : MeasureTheory.Measure X\nf : X → G\nhf : MeasureTheory.MeasurePreserving f μ' μ\n⊢ MeasureTheory.MeasurePreserving (fun x => HSMul.hSMul n (f x)) μ' μ","decl":"@[to_additive]\ntheorem MeasurePreserving.zpow [CompactSpace G] [RootableBy G ℤ]\n    {n : ℤ} (hn : n ≠ 0) {X : Type*}\n    [MeasurableSpace X] {μ' : Measure X} {f : X → G} (hf : MeasurePreserving f μ' μ) :\n    MeasurePreserving (fun x => f x ^ n) μ' μ :=\n  (measurePreserving_zpow μ hn).comp hf\n\n"}
