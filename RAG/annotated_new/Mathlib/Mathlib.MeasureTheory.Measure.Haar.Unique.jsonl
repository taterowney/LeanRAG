{"name":"IsCompact.measure_eq_biInf_integral_hasCompactSupport","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"X : Type u_1\ninstâœâ¶ : TopologicalSpace X\ninstâœâµ : MeasurableSpace X\ninstâœâ´ : BorelSpace X\nk : Set X\nhk : IsCompact k\nÎ¼ : MeasureTheory.Measure X\ninstâœÂ³ : MeasureTheory.IsFiniteMeasureOnCompacts Î¼\ninstâœÂ² : Î¼.InnerRegularCompactLTTop\ninstâœÂ¹ : LocallyCompactSpace X\ninstâœ : RegularSpace X\nâŠ¢ Eq (Î¼ k) (iInf fun f => iInf fun x => iInf fun x => iInf fun x => iInf fun x => ENNReal.ofReal (MeasureTheory.integral Î¼ fun x => f x))","decl":"/-- In a locally compact regular space with an inner regular measure, the measure of a compact\nset `k` is the infimum of the integrals of compactly supported functions equal to `1` on `k`. -/\nlemma IsCompact.measure_eq_biInf_integral_hasCompactSupport\n    {X : Type*} [TopologicalSpace X] [MeasurableSpace X] [BorelSpace X]\n    {k : Set X} (hk : IsCompact k)\n    (Î¼ : Measure X) [IsFiniteMeasureOnCompacts Î¼] [InnerRegularCompactLTTop Î¼]\n    [LocallyCompactSpace X] [RegularSpace X] :\n    Î¼ k = â¨… (f : X â†’ â„) (_ : Continuous f) (_ : HasCompactSupport f) (_ : EqOn f 1 k)\n      (_ : 0 â‰¤ f), ENNReal.ofReal (âˆ« x, f x âˆ‚Î¼) := by\n  apply le_antisymm\n  Â· simp only [le_iInf_iff]\n    intro f f_cont f_comp fk f_nonneg\n    apply (f_cont.integrable_of_hasCompactSupport f_comp).measure_le_integral\n    Â· exact Eventually.of_forall f_nonneg\n    Â· exact fun x hx â†¦ by simp [fk hx]\n  Â· apply le_of_forall_lt' (fun r hr â†¦ ?_)\n    simp only [iInf_lt_iff, exists_prop, exists_and_left]\n    obtain âŸ¨U, kU, U_open, mu_UâŸ© : âˆƒ U, k âŠ† U âˆ§ IsOpen U âˆ§ Î¼ U < r :=\n      hk.exists_isOpen_lt_of_lt r hr\n    obtain âŸ¨âŸ¨f, f_contâŸ©, fk, fU, f_comp, f_rangeâŸ© : âˆƒ (f : C(X, â„)), EqOn f 1 k âˆ§ EqOn f 0 Uá¶œ\n        âˆ§ HasCompactSupport f âˆ§ âˆ€ (x : X), f x âˆˆ Icc 0 1 := exists_continuous_one_zero_of_isCompact\n      hk U_open.isClosed_compl (disjoint_compl_right_iff_subset.mpr kU)\n    refine âŸ¨f, f_cont, f_comp, fk, fun x â†¦ (f_range x).1, ?_âŸ©\n    exact (integral_le_measure (fun x _hx â†¦ (f_range x).2) (fun x hx â†¦ (fU hx).le)).trans_lt mu_U\n\n"}
{"name":"MeasureTheory.continuous_integral_apply_inv_mul","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninstâœâ¸ : TopologicalSpace G\ninstâœâ· : LocallyCompactSpace G\ninstâœâ¶ : Group G\ninstâœâµ : TopologicalGroup G\ninstâœâ´ : MeasurableSpace G\ninstâœÂ³ : BorelSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœÂ² : MeasureTheory.IsFiniteMeasureOnCompacts Î¼\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\ng : G â†’ E\nhg : Continuous g\nh'g : HasCompactSupport g\nâŠ¢ Continuous fun x => MeasureTheory.integral Î¼ fun y => g (HMul.hMul (Inv.inv y) x)","decl":"/-- The parameterized integral `x â†¦ âˆ« y, g (yâ»Â¹ * x) âˆ‚Î¼` depends continuously on `y` when `g` is a\ncompactly supported continuous function on a topological group `G`, and `Î¼` is finite on compact\nsets. -/\n@[to_additive]\nlemma continuous_integral_apply_inv_mul\n    {G : Type*} [TopologicalSpace G] [LocallyCompactSpace G] [Group G] [TopologicalGroup G]\n    [MeasurableSpace G] [BorelSpace G]\n    {Î¼ : Measure G} [IsFiniteMeasureOnCompacts Î¼] {E : Type*} [NormedAddCommGroup E]\n    [NormedSpace â„ E] {g : G â†’ E}\n    (hg : Continuous g) (h'g : HasCompactSupport g) :\n    Continuous (fun (x : G) â†¦ âˆ« y, g (yâ»Â¹ * x) âˆ‚Î¼) := by\n  let k := tsupport g\n  have k_comp : IsCompact k := h'g\n  apply continuous_iff_continuousAt.2 (fun xâ‚€ â†¦ ?_)\n  obtain âŸ¨t, t_comp, htâŸ© : âˆƒ t, IsCompact t âˆ§ t âˆˆ ğ“ xâ‚€ := exists_compact_mem_nhds xâ‚€\n  let k' : Set G := t â€¢ kâ»Â¹\n  have k'_comp : IsCompact k' := t_comp.smul_set k_comp.inv\n  have A : ContinuousOn (fun (x : G) â†¦ âˆ« y, g (yâ»Â¹ * x) âˆ‚Î¼) t := by\n    apply continuousOn_integral_of_compact_support k'_comp\n    Â· exact (hg.comp (continuous_snd.inv.mul continuous_fst)).continuousOn\n    Â· intro p x hp hx\n      contrapose! hx\n      refine âŸ¨p, hp, pâ»Â¹ * x, ?_, by simpâŸ©\n      simpa only [Set.mem_inv, mul_inv_rev, inv_inv] using subset_tsupport _ hx\n  exact A.continuousAt ht\n\n"}
{"name":"MeasureTheory.continuous_integral_apply_neg_add","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninstâœâ¸ : TopologicalSpace G\ninstâœâ· : LocallyCompactSpace G\ninstâœâ¶ : AddGroup G\ninstâœâµ : TopologicalAddGroup G\ninstâœâ´ : MeasurableSpace G\ninstâœÂ³ : BorelSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœÂ² : MeasureTheory.IsFiniteMeasureOnCompacts Î¼\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\ng : G â†’ E\nhg : Continuous g\nh'g : HasCompactSupport g\nâŠ¢ Continuous fun x => MeasureTheory.integral Î¼ fun y => g (HAdd.hAdd (Neg.neg y) x)","decl":"/-- The parameterized integral `x â†¦ âˆ« y, g (yâ»Â¹ * x) âˆ‚Î¼` depends continuously on `y` when `g` is a\ncompactly supported continuous function on a topological group `G`, and `Î¼` is finite on compact\nsets. -/\n@[to_additive]\nlemma continuous_integral_apply_inv_mul\n    {G : Type*} [TopologicalSpace G] [LocallyCompactSpace G] [Group G] [TopologicalGroup G]\n    [MeasurableSpace G] [BorelSpace G]\n    {Î¼ : Measure G} [IsFiniteMeasureOnCompacts Î¼] {E : Type*} [NormedAddCommGroup E]\n    [NormedSpace â„ E] {g : G â†’ E}\n    (hg : Continuous g) (h'g : HasCompactSupport g) :\n    Continuous (fun (x : G) â†¦ âˆ« y, g (yâ»Â¹ * x) âˆ‚Î¼) := by\n  let k := tsupport g\n  have k_comp : IsCompact k := h'g\n  apply continuous_iff_continuousAt.2 (fun xâ‚€ â†¦ ?_)\n  obtain âŸ¨t, t_comp, htâŸ© : âˆƒ t, IsCompact t âˆ§ t âˆˆ ğ“ xâ‚€ := exists_compact_mem_nhds xâ‚€\n  let k' : Set G := t â€¢ kâ»Â¹\n  have k'_comp : IsCompact k' := t_comp.smul_set k_comp.inv\n  have A : ContinuousOn (fun (x : G) â†¦ âˆ« y, g (yâ»Â¹ * x) âˆ‚Î¼) t := by\n    apply continuousOn_integral_of_compact_support k'_comp\n    Â· exact (hg.comp (continuous_snd.inv.mul continuous_fst)).continuousOn\n    Â· intro p x hp hx\n      contrapose! hx\n      refine âŸ¨p, hp, pâ»Â¹ * x, ?_, by simpâŸ©\n      simpa only [Set.mem_inv, mul_inv_rev, inv_inv] using subset_tsupport _ hx\n  exact A.continuousAt ht\n\n"}
{"name":"MeasureTheory.Measure.integral_isMulLeftInvariant_isMulRightInvariant_combo","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninstâœâ¹ : TopologicalSpace G\ninstâœâ¸ : Group G\ninstâœâ· : TopologicalGroup G\ninstâœâ¶ : MeasurableSpace G\ninstâœâµ : BorelSpace G\nÎ¼ Î½ : MeasureTheory.Measure G\ninstâœâ´ : MeasureTheory.IsFiniteMeasureOnCompacts Î¼\ninstâœÂ³ : MeasureTheory.IsFiniteMeasureOnCompacts Î½\ninstâœÂ² : Î¼.IsMulLeftInvariant\ninstâœÂ¹ : Î½.IsMulRightInvariant\ninstâœ : Î½.IsOpenPosMeasure\nf g : G â†’ Real\nhf : Continuous f\nh'f : HasCompactSupport f\nhg : Continuous g\nh'g : HasCompactSupport g\ng_nonneg : LE.le 0 g\nxâ‚€ : G\ng_pos : Ne (g xâ‚€) 0\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => f x) (HMul.hMul (MeasureTheory.integral Î½ fun y => HMul.hMul (f y) (Inv.inv (MeasureTheory.integral Î½ fun z => g (HMul.hMul (Inv.inv z) y)))) (MeasureTheory.integral Î¼ fun x => g x))","decl":"/-- In a group with a left invariant measure `Î¼` and a right invariant measure `Î½`, one can express\nintegrals with respect to `Î¼` as integrals with respect to `Î½` up to a constant scaling factor\n(given in the statement as `âˆ« x, g x âˆ‚Î¼` where `g` is a fixed reference function) and an\nexplicit density `y â†¦ 1/âˆ« z, g (zâ»Â¹ * y) âˆ‚Î½`. -/\n@[to_additive]\nlemma integral_isMulLeftInvariant_isMulRightInvariant_combo\n    {Î¼ Î½ : Measure G} [IsFiniteMeasureOnCompacts Î¼] [IsFiniteMeasureOnCompacts Î½]\n    [IsMulLeftInvariant Î¼] [IsMulRightInvariant Î½] [IsOpenPosMeasure Î½]\n    {f g : G â†’ â„} (hf : Continuous f) (h'f : HasCompactSupport f)\n    (hg : Continuous g) (h'g : HasCompactSupport g) (g_nonneg : 0 â‰¤ g) {xâ‚€ : G} (g_pos : g xâ‚€ â‰  0) :\n    âˆ« x, f x âˆ‚Î¼ = (âˆ« y, f y * (âˆ« z, g (zâ»Â¹ * y) âˆ‚Î½)â»Â¹ âˆ‚Î½) * âˆ« x, g x âˆ‚Î¼ := by\n  -- The group has to be locally compact, otherwise all integrals vanish and the result is trivial.\n  rcases h'f.eq_zero_or_locallyCompactSpace_of_group hf with Hf|Hf\n  Â· simp [Hf]\n  let D : G â†’ â„ := fun (x : G) â†¦ âˆ« y, g (yâ»Â¹ * x) âˆ‚Î½\n  have D_cont : Continuous D := continuous_integral_apply_inv_mul hg h'g\n  have D_pos : âˆ€ x, 0 < D x := by\n    intro x\n    have C : Continuous (fun y â†¦ g (yâ»Â¹ * x)) := hg.comp (continuous_inv.mul continuous_const)\n    apply (integral_pos_iff_support_of_nonneg _ _).2\n    Â· apply C.isOpen_support.measure_pos Î½\n      exact âŸ¨x * xâ‚€â»Â¹, by simpa using g_posâŸ©\n    Â· exact fun y â†¦ g_nonneg (yâ»Â¹ * x)\n    Â· apply C.integrable_of_hasCompactSupport\n      exact h'g.comp_homeomorph ((Homeomorph.inv G).trans (Homeomorph.mulRight x))\n  calc\n  âˆ« x, f x âˆ‚Î¼ = âˆ« x, f x * (D x)â»Â¹ * D x âˆ‚Î¼ := by\n    congr with x; rw [mul_assoc, inv_mul_cancelâ‚€ (D_pos x).ne', mul_one]\n  _ = âˆ« x, (âˆ« y, f x * (D x)â»Â¹ * g (yâ»Â¹ * x) âˆ‚Î½) âˆ‚Î¼ := by simp_rw [D, integral_mul_left]\n  _ = âˆ« y, (âˆ« x, f x * (D x)â»Â¹ * g (yâ»Â¹ * x) âˆ‚Î¼) âˆ‚Î½ := by\n      apply integral_integral_swap_of_hasCompactSupport\n      Â· apply Continuous.mul\n        Â· exact (hf.comp continuous_fst).mul\n            ((D_cont.comp continuous_fst).invâ‚€ (fun x â†¦ (D_pos _).ne'))\n        Â· exact hg.comp (continuous_snd.inv.mul continuous_fst)\n      Â· let K := tsupport f\n        have K_comp : IsCompact K := h'f\n        let L := tsupport g\n        have L_comp : IsCompact L := h'g\n        let M := (fun (p : G Ã— G) â†¦ p.1 * p.2â»Â¹) '' (K Ã—Ë¢ L)\n        have M_comp : IsCompact M :=\n          (K_comp.prod L_comp).image (continuous_fst.mul continuous_snd.inv)\n        have M'_comp : IsCompact (closure M) := M_comp.closure\n        have : âˆ€ (p : G Ã— G), p âˆ‰ K Ã—Ë¢ closure M â†’ f p.1 * (D p.1)â»Â¹ * g (p.2â»Â¹ * p.1) = 0 := by\n          rintro âŸ¨x, yâŸ© hxy\n          by_cases H : x âˆˆ K; swap\n          Â· simp [image_eq_zero_of_nmem_tsupport H]\n          have : g (yâ»Â¹ * x) = 0 := by\n            apply image_eq_zero_of_nmem_tsupport\n            contrapose! hxy\n            simp only [mem_prod, H, true_and]\n            apply subset_closure\n            simp only [M, mem_image, mem_prod, Prod.exists]\n            exact âŸ¨x, yâ»Â¹ * x, âŸ¨H, hxyâŸ©, by groupâŸ©\n          simp [this]\n        apply HasCompactSupport.intro' (K_comp.prod M'_comp) ?_ this\n        exact (isClosed_tsupport f).prod isClosed_closure\n  _ = âˆ« y, (âˆ« x, f (y * x) * (D (y * x))â»Â¹ * g x âˆ‚Î¼) âˆ‚Î½ := by\n      congr with y\n      rw [â† integral_mul_left_eq_self _ y]\n      simp\n  _ = âˆ« x, (âˆ« y, f (y * x) * (D (y * x))â»Â¹ * g x âˆ‚Î½) âˆ‚Î¼ := by\n      apply (integral_integral_swap_of_hasCompactSupport _ _).symm\n      Â· apply Continuous.mul ?_ (hg.comp continuous_fst)\n        exact (hf.comp (continuous_snd.mul continuous_fst)).mul\n          ((D_cont.comp (continuous_snd.mul continuous_fst)).invâ‚€ (fun x â†¦ (D_pos _).ne'))\n      Â· let K := tsupport f\n        have K_comp : IsCompact K := h'f\n        let L := tsupport g\n        have L_comp : IsCompact L := h'g\n        let M := (fun (p : G Ã— G) â†¦ p.1 * p.2â»Â¹) '' (K Ã—Ë¢ L)\n        have M_comp : IsCompact M :=\n          (K_comp.prod L_comp).image (continuous_fst.mul continuous_snd.inv)\n        have M'_comp : IsCompact (closure M) := M_comp.closure\n        have : âˆ€ (p : G Ã— G), p âˆ‰ L Ã—Ë¢ closure M â†’\n            f (p.2 * p.1) * (D (p.2 * p.1))â»Â¹ * g p.1 = 0 := by\n          rintro âŸ¨x, yâŸ© hxy\n          by_cases H : x âˆˆ L; swap\n          Â· simp [image_eq_zero_of_nmem_tsupport H]\n          have : f (y * x) = 0 := by\n            apply image_eq_zero_of_nmem_tsupport\n            contrapose! hxy\n            simp only [mem_prod, H, true_and]\n            apply subset_closure\n            simp only [M, mem_image, mem_prod, Prod.exists]\n            exact âŸ¨y * x, x, âŸ¨hxy, HâŸ©, by groupâŸ©\n          simp [this]\n        apply HasCompactSupport.intro' (L_comp.prod M'_comp) ?_ this\n        exact (isClosed_tsupport g).prod isClosed_closure\n  _ = âˆ« x, (âˆ« y, f y * (D y)â»Â¹ âˆ‚Î½) * g x âˆ‚Î¼ := by\n      simp_rw [integral_mul_right]\n      congr with x\n      conv_rhs => rw [â† integral_mul_right_eq_self _ x]\n  _ = (âˆ« y, f y * (D y)â»Â¹ âˆ‚Î½) * âˆ« x, g x âˆ‚Î¼ := integral_mul_left _ _\n\n"}
{"name":"MeasureTheory.Measure.integral_isAddLeftInvariant_isAddRightInvariant_combo","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninstâœâ¹ : TopologicalSpace G\ninstâœâ¸ : AddGroup G\ninstâœâ· : TopologicalAddGroup G\ninstâœâ¶ : MeasurableSpace G\ninstâœâµ : BorelSpace G\nÎ¼ Î½ : MeasureTheory.Measure G\ninstâœâ´ : MeasureTheory.IsFiniteMeasureOnCompacts Î¼\ninstâœÂ³ : MeasureTheory.IsFiniteMeasureOnCompacts Î½\ninstâœÂ² : Î¼.IsAddLeftInvariant\ninstâœÂ¹ : Î½.IsAddRightInvariant\ninstâœ : Î½.IsOpenPosMeasure\nf g : G â†’ Real\nhf : Continuous f\nh'f : HasCompactSupport f\nhg : Continuous g\nh'g : HasCompactSupport g\ng_nonneg : LE.le 0 g\nxâ‚€ : G\ng_pos : Ne (g xâ‚€) 0\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => f x) (HMul.hMul (MeasureTheory.integral Î½ fun y => HMul.hMul (f y) (Inv.inv (MeasureTheory.integral Î½ fun z => g (HAdd.hAdd (Neg.neg z) y)))) (MeasureTheory.integral Î¼ fun x => g x))","decl":"/-- In a group with a left invariant measure `Î¼` and a right invariant measure `Î½`, one can express\nintegrals with respect to `Î¼` as integrals with respect to `Î½` up to a constant scaling factor\n(given in the statement as `âˆ« x, g x âˆ‚Î¼` where `g` is a fixed reference function) and an\nexplicit density `y â†¦ 1/âˆ« z, g (zâ»Â¹ * y) âˆ‚Î½`. -/\n@[to_additive]\nlemma integral_isMulLeftInvariant_isMulRightInvariant_combo\n    {Î¼ Î½ : Measure G} [IsFiniteMeasureOnCompacts Î¼] [IsFiniteMeasureOnCompacts Î½]\n    [IsMulLeftInvariant Î¼] [IsMulRightInvariant Î½] [IsOpenPosMeasure Î½]\n    {f g : G â†’ â„} (hf : Continuous f) (h'f : HasCompactSupport f)\n    (hg : Continuous g) (h'g : HasCompactSupport g) (g_nonneg : 0 â‰¤ g) {xâ‚€ : G} (g_pos : g xâ‚€ â‰  0) :\n    âˆ« x, f x âˆ‚Î¼ = (âˆ« y, f y * (âˆ« z, g (zâ»Â¹ * y) âˆ‚Î½)â»Â¹ âˆ‚Î½) * âˆ« x, g x âˆ‚Î¼ := by\n  -- The group has to be locally compact, otherwise all integrals vanish and the result is trivial.\n  rcases h'f.eq_zero_or_locallyCompactSpace_of_group hf with Hf|Hf\n  Â· simp [Hf]\n  let D : G â†’ â„ := fun (x : G) â†¦ âˆ« y, g (yâ»Â¹ * x) âˆ‚Î½\n  have D_cont : Continuous D := continuous_integral_apply_inv_mul hg h'g\n  have D_pos : âˆ€ x, 0 < D x := by\n    intro x\n    have C : Continuous (fun y â†¦ g (yâ»Â¹ * x)) := hg.comp (continuous_inv.mul continuous_const)\n    apply (integral_pos_iff_support_of_nonneg _ _).2\n    Â· apply C.isOpen_support.measure_pos Î½\n      exact âŸ¨x * xâ‚€â»Â¹, by simpa using g_posâŸ©\n    Â· exact fun y â†¦ g_nonneg (yâ»Â¹ * x)\n    Â· apply C.integrable_of_hasCompactSupport\n      exact h'g.comp_homeomorph ((Homeomorph.inv G).trans (Homeomorph.mulRight x))\n  calc\n  âˆ« x, f x âˆ‚Î¼ = âˆ« x, f x * (D x)â»Â¹ * D x âˆ‚Î¼ := by\n    congr with x; rw [mul_assoc, inv_mul_cancelâ‚€ (D_pos x).ne', mul_one]\n  _ = âˆ« x, (âˆ« y, f x * (D x)â»Â¹ * g (yâ»Â¹ * x) âˆ‚Î½) âˆ‚Î¼ := by simp_rw [D, integral_mul_left]\n  _ = âˆ« y, (âˆ« x, f x * (D x)â»Â¹ * g (yâ»Â¹ * x) âˆ‚Î¼) âˆ‚Î½ := by\n      apply integral_integral_swap_of_hasCompactSupport\n      Â· apply Continuous.mul\n        Â· exact (hf.comp continuous_fst).mul\n            ((D_cont.comp continuous_fst).invâ‚€ (fun x â†¦ (D_pos _).ne'))\n        Â· exact hg.comp (continuous_snd.inv.mul continuous_fst)\n      Â· let K := tsupport f\n        have K_comp : IsCompact K := h'f\n        let L := tsupport g\n        have L_comp : IsCompact L := h'g\n        let M := (fun (p : G Ã— G) â†¦ p.1 * p.2â»Â¹) '' (K Ã—Ë¢ L)\n        have M_comp : IsCompact M :=\n          (K_comp.prod L_comp).image (continuous_fst.mul continuous_snd.inv)\n        have M'_comp : IsCompact (closure M) := M_comp.closure\n        have : âˆ€ (p : G Ã— G), p âˆ‰ K Ã—Ë¢ closure M â†’ f p.1 * (D p.1)â»Â¹ * g (p.2â»Â¹ * p.1) = 0 := by\n          rintro âŸ¨x, yâŸ© hxy\n          by_cases H : x âˆˆ K; swap\n          Â· simp [image_eq_zero_of_nmem_tsupport H]\n          have : g (yâ»Â¹ * x) = 0 := by\n            apply image_eq_zero_of_nmem_tsupport\n            contrapose! hxy\n            simp only [mem_prod, H, true_and]\n            apply subset_closure\n            simp only [M, mem_image, mem_prod, Prod.exists]\n            exact âŸ¨x, yâ»Â¹ * x, âŸ¨H, hxyâŸ©, by groupâŸ©\n          simp [this]\n        apply HasCompactSupport.intro' (K_comp.prod M'_comp) ?_ this\n        exact (isClosed_tsupport f).prod isClosed_closure\n  _ = âˆ« y, (âˆ« x, f (y * x) * (D (y * x))â»Â¹ * g x âˆ‚Î¼) âˆ‚Î½ := by\n      congr with y\n      rw [â† integral_mul_left_eq_self _ y]\n      simp\n  _ = âˆ« x, (âˆ« y, f (y * x) * (D (y * x))â»Â¹ * g x âˆ‚Î½) âˆ‚Î¼ := by\n      apply (integral_integral_swap_of_hasCompactSupport _ _).symm\n      Â· apply Continuous.mul ?_ (hg.comp continuous_fst)\n        exact (hf.comp (continuous_snd.mul continuous_fst)).mul\n          ((D_cont.comp (continuous_snd.mul continuous_fst)).invâ‚€ (fun x â†¦ (D_pos _).ne'))\n      Â· let K := tsupport f\n        have K_comp : IsCompact K := h'f\n        let L := tsupport g\n        have L_comp : IsCompact L := h'g\n        let M := (fun (p : G Ã— G) â†¦ p.1 * p.2â»Â¹) '' (K Ã—Ë¢ L)\n        have M_comp : IsCompact M :=\n          (K_comp.prod L_comp).image (continuous_fst.mul continuous_snd.inv)\n        have M'_comp : IsCompact (closure M) := M_comp.closure\n        have : âˆ€ (p : G Ã— G), p âˆ‰ L Ã—Ë¢ closure M â†’\n            f (p.2 * p.1) * (D (p.2 * p.1))â»Â¹ * g p.1 = 0 := by\n          rintro âŸ¨x, yâŸ© hxy\n          by_cases H : x âˆˆ L; swap\n          Â· simp [image_eq_zero_of_nmem_tsupport H]\n          have : f (y * x) = 0 := by\n            apply image_eq_zero_of_nmem_tsupport\n            contrapose! hxy\n            simp only [mem_prod, H, true_and]\n            apply subset_closure\n            simp only [M, mem_image, mem_prod, Prod.exists]\n            exact âŸ¨y * x, x, âŸ¨hxy, HâŸ©, by groupâŸ©\n          simp [this]\n        apply HasCompactSupport.intro' (L_comp.prod M'_comp) ?_ this\n        exact (isClosed_tsupport g).prod isClosed_closure\n  _ = âˆ« x, (âˆ« y, f y * (D y)â»Â¹ âˆ‚Î½) * g x âˆ‚Î¼ := by\n      simp_rw [integral_mul_right]\n      congr with x\n      conv_rhs => rw [â† integral_mul_right_eq_self _ x]\n  _ = (âˆ« y, f y * (D y)â»Â¹ âˆ‚Î½) * âˆ« x, g x âˆ‚Î¼ := integral_mul_left _ _\n\n"}
{"name":"MeasureTheory.Measure.exists_integral_isMulLeftInvariant_eq_smul_of_hasCompactSupport","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninstâœâ· : TopologicalSpace G\ninstâœâ¶ : Group G\ninstâœâµ : TopologicalGroup G\ninstâœâ´ : MeasurableSpace G\ninstâœÂ³ : BorelSpace G\nÎ¼' Î¼ : MeasureTheory.Measure G\ninstâœÂ² : Î¼.IsHaarMeasure\ninstâœÂ¹ : MeasureTheory.IsFiniteMeasureOnCompacts Î¼'\ninstâœ : Î¼'.IsMulLeftInvariant\nâŠ¢ Exists fun c => âˆ€ (f : G â†’ Real), Continuous f â†’ HasCompactSupport f â†’ Eq (MeasureTheory.integral Î¼' fun x => f x) (MeasureTheory.integral (HSMul.hSMul c Î¼) fun x => f x)","decl":"/-- Given two left-invariant measures which are finite on\ncompacts, they coincide in the following sense: they give the same value to the integral of\ncontinuous compactly supported functions, up to a multiplicative constant. -/\n@[to_additive exists_integral_isAddLeftInvariant_eq_smul_of_hasCompactSupport]\nlemma exists_integral_isMulLeftInvariant_eq_smul_of_hasCompactSupport (Î¼' Î¼ : Measure G)\n    [IsHaarMeasure Î¼] [IsFiniteMeasureOnCompacts Î¼'] [IsMulLeftInvariant Î¼'] :\n    âˆƒ (c : â„â‰¥0), âˆ€ (f : G â†’ â„), Continuous f â†’ HasCompactSupport f â†’\n      âˆ« x, f x âˆ‚Î¼' = âˆ« x, f x âˆ‚(c â€¢ Î¼) := by\n  -- The group has to be locally compact, otherwise all integrals vanish and the result is trivial.\n  by_cases H : LocallyCompactSpace G; swap\n  Â· refine âŸ¨0, fun f f_cont f_comp â†¦ ?_âŸ©\n    rcases f_comp.eq_zero_or_locallyCompactSpace_of_group f_cont with hf|hf\n    Â· simp [hf]\n    Â· exact (H hf).elim\n  -- Fix some nonzero continuous function with compact support `g`.\n  obtain âŸ¨âŸ¨g, g_contâŸ©, g_comp, g_nonneg, g_oneâŸ© :\n    âˆƒ (g : C(G, â„)), HasCompactSupport g âˆ§ 0 â‰¤ g âˆ§ g 1 â‰  0 := exists_continuous_nonneg_pos 1\n  have int_g_pos : 0 < âˆ« x, g x âˆ‚Î¼ :=\n    g_cont.integral_pos_of_hasCompactSupport_nonneg_nonzero g_comp g_nonneg g_one\n  -- The proportionality constant we are looking for will be the ratio of the integrals of `g`\n  -- with respect to `Î¼'` and `Î¼`.\n  let c : â„ := (âˆ« x, g x âˆ‚Î¼) â»Â¹ * (âˆ« x, g x âˆ‚Î¼')\n  have c_nonneg : 0 â‰¤ c :=\n    mul_nonneg (inv_nonneg.2 (integral_nonneg g_nonneg)) (integral_nonneg g_nonneg)\n  refine âŸ¨âŸ¨c, c_nonnegâŸ©, fun f f_cont f_comp â†¦ ?_âŸ©\n  /- use the lemma `integral_mulLeftInvariant_mulRightInvariant_combo` for `Î¼` and then `Î¼'`\n  to reexpress the integral of `f` as the integral of `g` times a factor which only depends\n  on a right-invariant measure `Î½`. We use `Î½ = Î¼.inv` for convenience. -/\n  let Î½ := Î¼.inv\n  have A : âˆ« x, f x âˆ‚Î¼ = (âˆ« y, f y * (âˆ« z, g (zâ»Â¹ * y) âˆ‚Î½)â»Â¹ âˆ‚Î½) * âˆ« x, g x âˆ‚Î¼ :=\n    integral_isMulLeftInvariant_isMulRightInvariant_combo f_cont f_comp g_cont g_comp g_nonneg g_one\n  rw [â† mul_inv_eq_iff_eq_mulâ‚€ int_g_pos.ne'] at A\n  have B : âˆ« x, f x âˆ‚Î¼' = (âˆ« y, f y * (âˆ« z, g (zâ»Â¹ * y) âˆ‚Î½)â»Â¹ âˆ‚Î½) * âˆ« x, g x âˆ‚Î¼' :=\n    integral_isMulLeftInvariant_isMulRightInvariant_combo f_cont f_comp g_cont g_comp g_nonneg g_one\n  /- Since the `Î½`-factor is the same for `Î¼` and `Î¼'`, this gives the result. -/\n  rw [â† A, mul_assoc, mul_comm] at B\n  simp [B, integral_smul_nnreal_measure, c, NNReal.smul_def]\n\n"}
{"name":"MeasureTheory.Measure.exists_integral_isAddLeftInvariant_eq_smul_of_hasCompactSupport","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninstâœâ· : TopologicalSpace G\ninstâœâ¶ : AddGroup G\ninstâœâµ : TopologicalAddGroup G\ninstâœâ´ : MeasurableSpace G\ninstâœÂ³ : BorelSpace G\nÎ¼' Î¼ : MeasureTheory.Measure G\ninstâœÂ² : Î¼.IsAddHaarMeasure\ninstâœÂ¹ : MeasureTheory.IsFiniteMeasureOnCompacts Î¼'\ninstâœ : Î¼'.IsAddLeftInvariant\nâŠ¢ Exists fun c => âˆ€ (f : G â†’ Real), Continuous f â†’ HasCompactSupport f â†’ Eq (MeasureTheory.integral Î¼' fun x => f x) (MeasureTheory.integral (HSMul.hSMul c Î¼) fun x => f x)","decl":"/-- Given two left-invariant measures which are finite on\ncompacts, they coincide in the following sense: they give the same value to the integral of\ncontinuous compactly supported functions, up to a multiplicative constant. -/\n@[to_additive exists_integral_isAddLeftInvariant_eq_smul_of_hasCompactSupport]\nlemma exists_integral_isMulLeftInvariant_eq_smul_of_hasCompactSupport (Î¼' Î¼ : Measure G)\n    [IsHaarMeasure Î¼] [IsFiniteMeasureOnCompacts Î¼'] [IsMulLeftInvariant Î¼'] :\n    âˆƒ (c : â„â‰¥0), âˆ€ (f : G â†’ â„), Continuous f â†’ HasCompactSupport f â†’\n      âˆ« x, f x âˆ‚Î¼' = âˆ« x, f x âˆ‚(c â€¢ Î¼) := by\n  -- The group has to be locally compact, otherwise all integrals vanish and the result is trivial.\n  by_cases H : LocallyCompactSpace G; swap\n  Â· refine âŸ¨0, fun f f_cont f_comp â†¦ ?_âŸ©\n    rcases f_comp.eq_zero_or_locallyCompactSpace_of_group f_cont with hf|hf\n    Â· simp [hf]\n    Â· exact (H hf).elim\n  -- Fix some nonzero continuous function with compact support `g`.\n  obtain âŸ¨âŸ¨g, g_contâŸ©, g_comp, g_nonneg, g_oneâŸ© :\n    âˆƒ (g : C(G, â„)), HasCompactSupport g âˆ§ 0 â‰¤ g âˆ§ g 1 â‰  0 := exists_continuous_nonneg_pos 1\n  have int_g_pos : 0 < âˆ« x, g x âˆ‚Î¼ :=\n    g_cont.integral_pos_of_hasCompactSupport_nonneg_nonzero g_comp g_nonneg g_one\n  -- The proportionality constant we are looking for will be the ratio of the integrals of `g`\n  -- with respect to `Î¼'` and `Î¼`.\n  let c : â„ := (âˆ« x, g x âˆ‚Î¼) â»Â¹ * (âˆ« x, g x âˆ‚Î¼')\n  have c_nonneg : 0 â‰¤ c :=\n    mul_nonneg (inv_nonneg.2 (integral_nonneg g_nonneg)) (integral_nonneg g_nonneg)\n  refine âŸ¨âŸ¨c, c_nonnegâŸ©, fun f f_cont f_comp â†¦ ?_âŸ©\n  /- use the lemma `integral_mulLeftInvariant_mulRightInvariant_combo` for `Î¼` and then `Î¼'`\n  to reexpress the integral of `f` as the integral of `g` times a factor which only depends\n  on a right-invariant measure `Î½`. We use `Î½ = Î¼.inv` for convenience. -/\n  let Î½ := Î¼.inv\n  have A : âˆ« x, f x âˆ‚Î¼ = (âˆ« y, f y * (âˆ« z, g (zâ»Â¹ * y) âˆ‚Î½)â»Â¹ âˆ‚Î½) * âˆ« x, g x âˆ‚Î¼ :=\n    integral_isMulLeftInvariant_isMulRightInvariant_combo f_cont f_comp g_cont g_comp g_nonneg g_one\n  rw [â† mul_inv_eq_iff_eq_mulâ‚€ int_g_pos.ne'] at A\n  have B : âˆ« x, f x âˆ‚Î¼' = (âˆ« y, f y * (âˆ« z, g (zâ»Â¹ * y) âˆ‚Î½)â»Â¹ âˆ‚Î½) * âˆ« x, g x âˆ‚Î¼' :=\n    integral_isMulLeftInvariant_isMulRightInvariant_combo f_cont f_comp g_cont g_comp g_nonneg g_one\n  /- Since the `Î½`-factor is the same for `Î¼` and `Î¼'`, this gives the result. -/\n  rw [â† A, mul_assoc, mul_comm] at B\n  simp [B, integral_smul_nnreal_measure, c, NNReal.smul_def]\n\n"}
{"name":"MeasureTheory.Measure.integral_isMulLeftInvariant_eq_smul_of_hasCompactSupport","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninstâœâ· : TopologicalSpace G\ninstâœâ¶ : Group G\ninstâœâµ : TopologicalGroup G\ninstâœâ´ : MeasurableSpace G\ninstâœÂ³ : BorelSpace G\nÎ¼' Î¼ : MeasureTheory.Measure G\ninstâœÂ² : Î¼.IsHaarMeasure\ninstâœÂ¹ : MeasureTheory.IsFiniteMeasureOnCompacts Î¼'\ninstâœ : Î¼'.IsMulLeftInvariant\nf : G â†’ Real\nhf : Continuous f\nh'f : HasCompactSupport f\nâŠ¢ Eq (MeasureTheory.integral Î¼' fun x => f x) (MeasureTheory.integral (HSMul.hSMul (Î¼'.haarScalarFactor Î¼) Î¼) fun x => f x)","decl":"/-- Two left invariant measures integrate in the same way continuous compactly supported functions,\nup to the scalar `haarScalarFactor Î¼' Î¼`. See also\n`measure_isMulInvariant_eq_smul_of_isCompact_closure`, which gives the same result for compact\nsets, and `measure_isHaarMeasure_eq_smul_of_isOpen` for open sets. -/\n@[to_additive integral_isAddLeftInvariant_eq_smul_of_hasCompactSupport\n\"Two left invariant measures integrate in the same way continuous compactly supported functions,\nup to the scalar `addHaarScalarFactor Î¼' Î¼`. See also\n`measure_isAddInvariant_eq_smul_of_isCompact_closure`, which gives the same result for compact\nsets, and `measure_isAddHaarMeasure_eq_smul_of_isOpen` for open sets.\"]\ntheorem integral_isMulLeftInvariant_eq_smul_of_hasCompactSupport\n    (Î¼' Î¼ : Measure G) [IsHaarMeasure Î¼] [IsFiniteMeasureOnCompacts Î¼'] [IsMulLeftInvariant Î¼']\n    {f : G â†’ â„} (hf : Continuous f) (h'f : HasCompactSupport f) :\n    âˆ« x, f x âˆ‚Î¼' = âˆ« x, f x âˆ‚(haarScalarFactor Î¼' Î¼ â€¢ Î¼) := by\n  classical\n  rcases h'f.eq_zero_or_locallyCompactSpace_of_group hf with Hf|Hf\n  Â· simp [Hf]\n  Â· simp only [haarScalarFactor, Hf, not_true_eq_false, ite_false]\n    exact (exists_integral_isMulLeftInvariant_eq_smul_of_hasCompactSupport Î¼' Î¼).choose_spec\n      f hf h'f\n\n"}
{"name":"MeasureTheory.Measure.integral_isAddLeftInvariant_eq_smul_of_hasCompactSupport","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninstâœâ· : TopologicalSpace G\ninstâœâ¶ : AddGroup G\ninstâœâµ : TopologicalAddGroup G\ninstâœâ´ : MeasurableSpace G\ninstâœÂ³ : BorelSpace G\nÎ¼' Î¼ : MeasureTheory.Measure G\ninstâœÂ² : Î¼.IsAddHaarMeasure\ninstâœÂ¹ : MeasureTheory.IsFiniteMeasureOnCompacts Î¼'\ninstâœ : Î¼'.IsAddLeftInvariant\nf : G â†’ Real\nhf : Continuous f\nh'f : HasCompactSupport f\nâŠ¢ Eq (MeasureTheory.integral Î¼' fun x => f x) (MeasureTheory.integral (HSMul.hSMul (Î¼'.addHaarScalarFactor Î¼) Î¼) fun x => f x)","decl":"/-- Two left invariant measures integrate in the same way continuous compactly supported functions,\nup to the scalar `haarScalarFactor Î¼' Î¼`. See also\n`measure_isMulInvariant_eq_smul_of_isCompact_closure`, which gives the same result for compact\nsets, and `measure_isHaarMeasure_eq_smul_of_isOpen` for open sets. -/\n@[to_additive integral_isAddLeftInvariant_eq_smul_of_hasCompactSupport\n\"Two left invariant measures integrate in the same way continuous compactly supported functions,\nup to the scalar `addHaarScalarFactor Î¼' Î¼`. See also\n`measure_isAddInvariant_eq_smul_of_isCompact_closure`, which gives the same result for compact\nsets, and `measure_isAddHaarMeasure_eq_smul_of_isOpen` for open sets.\"]\ntheorem integral_isMulLeftInvariant_eq_smul_of_hasCompactSupport\n    (Î¼' Î¼ : Measure G) [IsHaarMeasure Î¼] [IsFiniteMeasureOnCompacts Î¼'] [IsMulLeftInvariant Î¼']\n    {f : G â†’ â„} (hf : Continuous f) (h'f : HasCompactSupport f) :\n    âˆ« x, f x âˆ‚Î¼' = âˆ« x, f x âˆ‚(haarScalarFactor Î¼' Î¼ â€¢ Î¼) := by\n  classical\n  rcases h'f.eq_zero_or_locallyCompactSpace_of_group hf with Hf|Hf\n  Â· simp [Hf]\n  Â· simp only [haarScalarFactor, Hf, not_true_eq_false, ite_false]\n    exact (exists_integral_isMulLeftInvariant_eq_smul_of_hasCompactSupport Î¼' Î¼).choose_spec\n      f hf h'f\n\n"}
{"name":"MeasureTheory.Measure.addHaarScalarFactor_eq_integral_div","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninstâœâ· : TopologicalSpace G\ninstâœâ¶ : AddGroup G\ninstâœâµ : TopologicalAddGroup G\ninstâœâ´ : MeasurableSpace G\ninstâœÂ³ : BorelSpace G\nÎ¼' Î¼ : MeasureTheory.Measure G\ninstâœÂ² : Î¼.IsAddHaarMeasure\ninstâœÂ¹ : MeasureTheory.IsFiniteMeasureOnCompacts Î¼'\ninstâœ : Î¼'.IsAddLeftInvariant\nf : G â†’ Real\nhf : Continuous f\nh'f : HasCompactSupport f\nint_nonzero : Ne (MeasureTheory.integral Î¼ fun x => f x) 0\nâŠ¢ Eq (â†‘(Î¼'.addHaarScalarFactor Î¼)) (HDiv.hDiv (MeasureTheory.integral Î¼' fun x => f x) (MeasureTheory.integral Î¼ fun x => f x))","decl":"@[to_additive addHaarScalarFactor_eq_integral_div]\nlemma haarScalarFactor_eq_integral_div (Î¼' Î¼ : Measure G) [IsHaarMeasure Î¼]\n    [IsFiniteMeasureOnCompacts Î¼'] [IsMulLeftInvariant Î¼'] {f : G â†’ â„} (hf : Continuous f)\n    (h'f : HasCompactSupport f) (int_nonzero : âˆ« x, f x âˆ‚Î¼ â‰  0) :\n    haarScalarFactor Î¼' Î¼ = (âˆ« x, f x âˆ‚Î¼') / âˆ« x, f x âˆ‚Î¼ := by\n  have := integral_isMulLeftInvariant_eq_smul_of_hasCompactSupport Î¼' Î¼ hf h'f\n  rw [integral_smul_nnreal_measure] at this\n  exact EuclideanDomain.eq_div_of_mul_eq_left int_nonzero this.symm\n\n"}
{"name":"MeasureTheory.Measure.haarScalarFactor_eq_integral_div","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninstâœâ· : TopologicalSpace G\ninstâœâ¶ : Group G\ninstâœâµ : TopologicalGroup G\ninstâœâ´ : MeasurableSpace G\ninstâœÂ³ : BorelSpace G\nÎ¼' Î¼ : MeasureTheory.Measure G\ninstâœÂ² : Î¼.IsHaarMeasure\ninstâœÂ¹ : MeasureTheory.IsFiniteMeasureOnCompacts Î¼'\ninstâœ : Î¼'.IsMulLeftInvariant\nf : G â†’ Real\nhf : Continuous f\nh'f : HasCompactSupport f\nint_nonzero : Ne (MeasureTheory.integral Î¼ fun x => f x) 0\nâŠ¢ Eq (â†‘(Î¼'.haarScalarFactor Î¼)) (HDiv.hDiv (MeasureTheory.integral Î¼' fun x => f x) (MeasureTheory.integral Î¼ fun x => f x))","decl":"@[to_additive addHaarScalarFactor_eq_integral_div]\nlemma haarScalarFactor_eq_integral_div (Î¼' Î¼ : Measure G) [IsHaarMeasure Î¼]\n    [IsFiniteMeasureOnCompacts Î¼'] [IsMulLeftInvariant Î¼'] {f : G â†’ â„} (hf : Continuous f)\n    (h'f : HasCompactSupport f) (int_nonzero : âˆ« x, f x âˆ‚Î¼ â‰  0) :\n    haarScalarFactor Î¼' Î¼ = (âˆ« x, f x âˆ‚Î¼') / âˆ« x, f x âˆ‚Î¼ := by\n  have := integral_isMulLeftInvariant_eq_smul_of_hasCompactSupport Î¼' Î¼ hf h'f\n  rw [integral_smul_nnreal_measure] at this\n  exact EuclideanDomain.eq_div_of_mul_eq_left int_nonzero this.symm\n\n"}
{"name":"MeasureTheory.Measure.addHaarScalarFactor_smul","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninstâœâ¸ : TopologicalSpace G\ninstâœâ· : AddGroup G\ninstâœâ¶ : TopologicalAddGroup G\ninstâœâµ : MeasurableSpace G\ninstâœâ´ : BorelSpace G\ninstâœÂ³ : LocallyCompactSpace G\nÎ¼' Î¼ : MeasureTheory.Measure G\ninstâœÂ² : Î¼.IsAddHaarMeasure\ninstâœÂ¹ : MeasureTheory.IsFiniteMeasureOnCompacts Î¼'\ninstâœ : Î¼'.IsAddLeftInvariant\nc : NNReal\nâŠ¢ Eq ((HSMul.hSMul c Î¼').addHaarScalarFactor Î¼) (HSMul.hSMul c (Î¼'.addHaarScalarFactor Î¼))","decl":"@[to_additive (attr := simp) addHaarScalarFactor_smul]\nlemma haarScalarFactor_smul [LocallyCompactSpace G] (Î¼' Î¼ : Measure G) [IsHaarMeasure Î¼]\n    [IsFiniteMeasureOnCompacts Î¼'] [IsMulLeftInvariant Î¼'] {c : â„â‰¥0} :\n    haarScalarFactor (c â€¢ Î¼') Î¼ = c â€¢ haarScalarFactor Î¼' Î¼ := by\n  obtain âŸ¨âŸ¨g, g_contâŸ©, g_comp, g_nonneg, g_oneâŸ© :\n    âˆƒ g : C(G, â„), HasCompactSupport g âˆ§ 0 â‰¤ g âˆ§ g 1 â‰  0 := exists_continuous_nonneg_pos 1\n  have int_g_ne_zero : âˆ« x, g x âˆ‚Î¼ â‰  0 :=\n    ne_of_gt (g_cont.integral_pos_of_hasCompactSupport_nonneg_nonzero g_comp g_nonneg g_one)\n  apply NNReal.coe_injective\n  calc\n    haarScalarFactor (c â€¢ Î¼') Î¼ = (âˆ« x, g x âˆ‚(c â€¢ Î¼')) / âˆ« x, g x âˆ‚Î¼ :=\n      haarScalarFactor_eq_integral_div _ _ g_cont g_comp int_g_ne_zero\n    _ = (c â€¢ (âˆ« x, g x âˆ‚Î¼')) / âˆ« x, g x âˆ‚Î¼ := by simp\n    _ = c â€¢ ((âˆ« x, g x âˆ‚Î¼') / âˆ« x, g x âˆ‚Î¼) := smul_div_assoc c _ _\n    _ = c â€¢ haarScalarFactor Î¼' Î¼ := by\n      rw [â† haarScalarFactor_eq_integral_div _ _ g_cont g_comp int_g_ne_zero]\n\n"}
{"name":"MeasureTheory.Measure.haarScalarFactor_smul","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninstâœâ¸ : TopologicalSpace G\ninstâœâ· : Group G\ninstâœâ¶ : TopologicalGroup G\ninstâœâµ : MeasurableSpace G\ninstâœâ´ : BorelSpace G\ninstâœÂ³ : LocallyCompactSpace G\nÎ¼' Î¼ : MeasureTheory.Measure G\ninstâœÂ² : Î¼.IsHaarMeasure\ninstâœÂ¹ : MeasureTheory.IsFiniteMeasureOnCompacts Î¼'\ninstâœ : Î¼'.IsMulLeftInvariant\nc : NNReal\nâŠ¢ Eq ((HSMul.hSMul c Î¼').haarScalarFactor Î¼) (HSMul.hSMul c (Î¼'.haarScalarFactor Î¼))","decl":"@[to_additive (attr := simp) addHaarScalarFactor_smul]\nlemma haarScalarFactor_smul [LocallyCompactSpace G] (Î¼' Î¼ : Measure G) [IsHaarMeasure Î¼]\n    [IsFiniteMeasureOnCompacts Î¼'] [IsMulLeftInvariant Î¼'] {c : â„â‰¥0} :\n    haarScalarFactor (c â€¢ Î¼') Î¼ = c â€¢ haarScalarFactor Î¼' Î¼ := by\n  obtain âŸ¨âŸ¨g, g_contâŸ©, g_comp, g_nonneg, g_oneâŸ© :\n    âˆƒ g : C(G, â„), HasCompactSupport g âˆ§ 0 â‰¤ g âˆ§ g 1 â‰  0 := exists_continuous_nonneg_pos 1\n  have int_g_ne_zero : âˆ« x, g x âˆ‚Î¼ â‰  0 :=\n    ne_of_gt (g_cont.integral_pos_of_hasCompactSupport_nonneg_nonzero g_comp g_nonneg g_one)\n  apply NNReal.coe_injective\n  calc\n    haarScalarFactor (c â€¢ Î¼') Î¼ = (âˆ« x, g x âˆ‚(c â€¢ Î¼')) / âˆ« x, g x âˆ‚Î¼ :=\n      haarScalarFactor_eq_integral_div _ _ g_cont g_comp int_g_ne_zero\n    _ = (c â€¢ (âˆ« x, g x âˆ‚Î¼')) / âˆ« x, g x âˆ‚Î¼ := by simp\n    _ = c â€¢ ((âˆ« x, g x âˆ‚Î¼') / âˆ« x, g x âˆ‚Î¼) := smul_div_assoc c _ _\n    _ = c â€¢ haarScalarFactor Î¼' Î¼ := by\n      rw [â† haarScalarFactor_eq_integral_div _ _ g_cont g_comp int_g_ne_zero]\n\n"}
{"name":"MeasureTheory.Measure.addHaarScalarFactor_self","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninstâœâµ : TopologicalSpace G\ninstâœâ´ : AddGroup G\ninstâœÂ³ : TopologicalAddGroup G\ninstâœÂ² : MeasurableSpace G\ninstâœÂ¹ : BorelSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœ : Î¼.IsAddHaarMeasure\nâŠ¢ Eq (Î¼.addHaarScalarFactor Î¼) 1","decl":"@[to_additive (attr := simp)]\nlemma haarScalarFactor_self (Î¼ : Measure G) [IsHaarMeasure Î¼] :\n    haarScalarFactor Î¼ Î¼ = 1 := by\n  by_cases hG : LocallyCompactSpace G; swap\n  Â· simp [haarScalarFactor, hG]\n  obtain âŸ¨âŸ¨g, g_contâŸ©, g_comp, g_nonneg, g_oneâŸ© :\n    âˆƒ g : C(G, â„), HasCompactSupport g âˆ§ 0 â‰¤ g âˆ§ g 1 â‰  0 := exists_continuous_nonneg_pos 1\n  have int_g_ne_zero : âˆ« x, g x âˆ‚Î¼ â‰  0 :=\n    ne_of_gt (g_cont.integral_pos_of_hasCompactSupport_nonneg_nonzero g_comp g_nonneg g_one)\n  apply NNReal.coe_injective\n  calc\n    haarScalarFactor Î¼ Î¼ = (âˆ« x, g x âˆ‚Î¼) / âˆ« x, g x âˆ‚Î¼ :=\n      haarScalarFactor_eq_integral_div _ _ g_cont g_comp int_g_ne_zero\n    _ = 1 := div_self int_g_ne_zero\n\n"}
{"name":"MeasureTheory.Measure.haarScalarFactor_self","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninstâœâµ : TopologicalSpace G\ninstâœâ´ : Group G\ninstâœÂ³ : TopologicalGroup G\ninstâœÂ² : MeasurableSpace G\ninstâœÂ¹ : BorelSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœ : Î¼.IsHaarMeasure\nâŠ¢ Eq (Î¼.haarScalarFactor Î¼) 1","decl":"@[to_additive (attr := simp)]\nlemma haarScalarFactor_self (Î¼ : Measure G) [IsHaarMeasure Î¼] :\n    haarScalarFactor Î¼ Î¼ = 1 := by\n  by_cases hG : LocallyCompactSpace G; swap\n  Â· simp [haarScalarFactor, hG]\n  obtain âŸ¨âŸ¨g, g_contâŸ©, g_comp, g_nonneg, g_oneâŸ© :\n    âˆƒ g : C(G, â„), HasCompactSupport g âˆ§ 0 â‰¤ g âˆ§ g 1 â‰  0 := exists_continuous_nonneg_pos 1\n  have int_g_ne_zero : âˆ« x, g x âˆ‚Î¼ â‰  0 :=\n    ne_of_gt (g_cont.integral_pos_of_hasCompactSupport_nonneg_nonzero g_comp g_nonneg g_one)\n  apply NNReal.coe_injective\n  calc\n    haarScalarFactor Î¼ Î¼ = (âˆ« x, g x âˆ‚Î¼) / âˆ« x, g x âˆ‚Î¼ :=\n      haarScalarFactor_eq_integral_div _ _ g_cont g_comp int_g_ne_zero\n    _ = 1 := div_self int_g_ne_zero\n\n"}
{"name":"MeasureTheory.Measure.addHaarScalarFactor_eq_mul","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninstâœâ¸ : TopologicalSpace G\ninstâœâ· : AddGroup G\ninstâœâ¶ : TopologicalAddGroup G\ninstâœâµ : MeasurableSpace G\ninstâœâ´ : BorelSpace G\nÎ¼' Î¼ Î½ : MeasureTheory.Measure G\ninstâœÂ³ : Î¼.IsAddHaarMeasure\ninstâœÂ² : Î½.IsAddHaarMeasure\ninstâœÂ¹ : MeasureTheory.IsFiniteMeasureOnCompacts Î¼'\ninstâœ : Î¼'.IsAddLeftInvariant\nâŠ¢ Eq (Î¼'.addHaarScalarFactor Î½) (HMul.hMul (Î¼'.addHaarScalarFactor Î¼) (Î¼.addHaarScalarFactor Î½))","decl":"@[to_additive addHaarScalarFactor_eq_mul]\nlemma haarScalarFactor_eq_mul (Î¼' Î¼ Î½ : Measure G)\n    [IsHaarMeasure Î¼] [IsHaarMeasure Î½] [IsFiniteMeasureOnCompacts Î¼'] [IsMulLeftInvariant Î¼'] :\n    haarScalarFactor Î¼' Î½ = haarScalarFactor Î¼' Î¼ * haarScalarFactor Î¼ Î½ := by\n  -- The group has to be locally compact, otherwise the scalar factor is 1 by definition.\n  by_cases hG : LocallyCompactSpace G; swap\n  Â· simp [haarScalarFactor, hG]\n  -- Fix some nonzero continuous function with compact support `g`.\n  obtain âŸ¨âŸ¨g, g_contâŸ©, g_comp, g_nonneg, g_oneâŸ© :\n    âˆƒ (g : C(G, â„)), HasCompactSupport g âˆ§ 0 â‰¤ g âˆ§ g 1 â‰  0 := exists_continuous_nonneg_pos 1\n  have Z := integral_isMulLeftInvariant_eq_smul_of_hasCompactSupport Î¼' Î¼ g_cont g_comp\n  simp only [integral_smul_nnreal_measure, smul_smul,\n    integral_isMulLeftInvariant_eq_smul_of_hasCompactSupport Î¼' Î½ g_cont g_comp,\n    integral_isMulLeftInvariant_eq_smul_of_hasCompactSupport Î¼ Î½ g_cont g_comp] at Z\n  have int_g_pos : 0 < âˆ« x, g x âˆ‚Î½ := by\n    apply (integral_pos_iff_support_of_nonneg g_nonneg _).2\n    Â· exact IsOpen.measure_pos Î½ g_cont.isOpen_support âŸ¨1, g_oneâŸ©\n    Â· exact g_cont.integrable_of_hasCompactSupport g_comp\n  change (haarScalarFactor Î¼' Î½ : â„) * âˆ« (x : G), g x âˆ‚Î½ =\n    (haarScalarFactor Î¼' Î¼ * haarScalarFactor Î¼ Î½ : â„â‰¥0) * âˆ« (x : G), g x âˆ‚Î½ at Z\n  simpa only [mul_eq_mul_right_iff (Mâ‚€ := â„), int_g_pos.ne', or_false, â† NNReal.eq_iff] using Z\n\n"}
{"name":"MeasureTheory.Measure.haarScalarFactor_eq_mul","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninstâœâ¸ : TopologicalSpace G\ninstâœâ· : Group G\ninstâœâ¶ : TopologicalGroup G\ninstâœâµ : MeasurableSpace G\ninstâœâ´ : BorelSpace G\nÎ¼' Î¼ Î½ : MeasureTheory.Measure G\ninstâœÂ³ : Î¼.IsHaarMeasure\ninstâœÂ² : Î½.IsHaarMeasure\ninstâœÂ¹ : MeasureTheory.IsFiniteMeasureOnCompacts Î¼'\ninstâœ : Î¼'.IsMulLeftInvariant\nâŠ¢ Eq (Î¼'.haarScalarFactor Î½) (HMul.hMul (Î¼'.haarScalarFactor Î¼) (Î¼.haarScalarFactor Î½))","decl":"@[to_additive addHaarScalarFactor_eq_mul]\nlemma haarScalarFactor_eq_mul (Î¼' Î¼ Î½ : Measure G)\n    [IsHaarMeasure Î¼] [IsHaarMeasure Î½] [IsFiniteMeasureOnCompacts Î¼'] [IsMulLeftInvariant Î¼'] :\n    haarScalarFactor Î¼' Î½ = haarScalarFactor Î¼' Î¼ * haarScalarFactor Î¼ Î½ := by\n  -- The group has to be locally compact, otherwise the scalar factor is 1 by definition.\n  by_cases hG : LocallyCompactSpace G; swap\n  Â· simp [haarScalarFactor, hG]\n  -- Fix some nonzero continuous function with compact support `g`.\n  obtain âŸ¨âŸ¨g, g_contâŸ©, g_comp, g_nonneg, g_oneâŸ© :\n    âˆƒ (g : C(G, â„)), HasCompactSupport g âˆ§ 0 â‰¤ g âˆ§ g 1 â‰  0 := exists_continuous_nonneg_pos 1\n  have Z := integral_isMulLeftInvariant_eq_smul_of_hasCompactSupport Î¼' Î¼ g_cont g_comp\n  simp only [integral_smul_nnreal_measure, smul_smul,\n    integral_isMulLeftInvariant_eq_smul_of_hasCompactSupport Î¼' Î½ g_cont g_comp,\n    integral_isMulLeftInvariant_eq_smul_of_hasCompactSupport Î¼ Î½ g_cont g_comp] at Z\n  have int_g_pos : 0 < âˆ« x, g x âˆ‚Î½ := by\n    apply (integral_pos_iff_support_of_nonneg g_nonneg _).2\n    Â· exact IsOpen.measure_pos Î½ g_cont.isOpen_support âŸ¨1, g_oneâŸ©\n    Â· exact g_cont.integrable_of_hasCompactSupport g_comp\n  change (haarScalarFactor Î¼' Î½ : â„) * âˆ« (x : G), g x âˆ‚Î½ =\n    (haarScalarFactor Î¼' Î¼ * haarScalarFactor Î¼ Î½ : â„â‰¥0) * âˆ« (x : G), g x âˆ‚Î½ at Z\n  simpa only [mul_eq_mul_right_iff (Mâ‚€ := â„), int_g_pos.ne', or_false, â† NNReal.eq_iff] using Z\n\n"}
{"name":"MeasureTheory.Measure.addHaarScalarFactor_eq_add","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninstâœâ¸ : TopologicalSpace G\ninstâœâ· : AddGroup G\ninstâœâ¶ : TopologicalAddGroup G\ninstâœâµ : MeasurableSpace G\ninstâœâ´ : BorelSpace G\nÎ¼' Î¼ Î½ : MeasureTheory.Measure G\ninstâœÂ³ : Î¼.IsAddHaarMeasure\ninstâœÂ² : Î½.IsAddHaarMeasure\ninstâœÂ¹ : MeasureTheory.IsFiniteMeasureOnCompacts Î¼'\ninstâœ : Î¼'.IsAddLeftInvariant\nâŠ¢ Eq (Î¼'.addHaarScalarFactor Î½) (HMul.hMul (Î¼'.addHaarScalarFactor Î¼) (Î¼.addHaarScalarFactor Î½))","decl":"@[deprecated (since := \"2024-11-05\")] alias addHaarScalarFactor_eq_add := addHaarScalarFactor_eq_mul\n\n"}
{"name":"MeasureTheory.Measure.addHaarScalarFactor_pos_of_isAddHaarMeasure","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninstâœâ¶ : TopologicalSpace G\ninstâœâµ : AddGroup G\ninstâœâ´ : TopologicalAddGroup G\ninstâœÂ³ : MeasurableSpace G\ninstâœÂ² : BorelSpace G\nÎ¼' Î¼ : MeasureTheory.Measure G\ninstâœÂ¹ : Î¼.IsAddHaarMeasure\ninstâœ : Î¼'.IsAddHaarMeasure\nâŠ¢ LT.lt 0 (Î¼'.addHaarScalarFactor Î¼)","decl":"/-- The scalar factor between two left-invariant measures is non-zero when both measures are\npositive on open sets. -/\n@[to_additive]\nlemma haarScalarFactor_pos_of_isHaarMeasure (Î¼' Î¼ : Measure G) [IsHaarMeasure Î¼]\n    [IsHaarMeasure Î¼'] : 0 < haarScalarFactor Î¼' Î¼ :=\n  pos_iff_ne_zero.2 (fun H â†¦ by simpa [H] using haarScalarFactor_eq_mul Î¼' Î¼ Î¼')\n\n"}
{"name":"MeasureTheory.Measure.haarScalarFactor_pos_of_isHaarMeasure","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninstâœâ¶ : TopologicalSpace G\ninstâœâµ : Group G\ninstâœâ´ : TopologicalGroup G\ninstâœÂ³ : MeasurableSpace G\ninstâœÂ² : BorelSpace G\nÎ¼' Î¼ : MeasureTheory.Measure G\ninstâœÂ¹ : Î¼.IsHaarMeasure\ninstâœ : Î¼'.IsHaarMeasure\nâŠ¢ LT.lt 0 (Î¼'.haarScalarFactor Î¼)","decl":"/-- The scalar factor between two left-invariant measures is non-zero when both measures are\npositive on open sets. -/\n@[to_additive]\nlemma haarScalarFactor_pos_of_isHaarMeasure (Î¼' Î¼ : Measure G) [IsHaarMeasure Î¼]\n    [IsHaarMeasure Î¼'] : 0 < haarScalarFactor Î¼' Î¼ :=\n  pos_iff_ne_zero.2 (fun H â†¦ by simpa [H] using haarScalarFactor_eq_mul Î¼' Î¼ Î¼')\n\n"}
{"name":"MeasureTheory.Measure.measure_preimage_isAddLeftInvariant_eq_smul_of_hasCompactSupport","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninstâœâ· : TopologicalSpace G\ninstâœâ¶ : AddGroup G\ninstâœâµ : TopologicalAddGroup G\ninstâœâ´ : MeasurableSpace G\ninstâœÂ³ : BorelSpace G\nÎ¼' Î¼ : MeasureTheory.Measure G\ninstâœÂ² : Î¼.IsAddHaarMeasure\ninstâœÂ¹ : MeasureTheory.IsFiniteMeasureOnCompacts Î¼'\ninstâœ : Î¼'.IsAddLeftInvariant\nf : G â†’ Real\nhf : Continuous f\nh'f : HasCompactSupport f\nâŠ¢ Eq (Î¼' (Set.preimage f (Singleton.singleton 1))) (HSMul.hSMul (Î¼'.addHaarScalarFactor Î¼) (Î¼ (Set.preimage f (Singleton.singleton 1))))","decl":"/-- Two left invariant measures give the same mass to level sets of continuous compactly supported\nfunctions, up to the scalar `haarScalarFactor Î¼' Î¼`.\n\nAuxiliary lemma in the proof of the more general\n`measure_isMulInvariant_eq_smul_of_isCompact_closure`, which works for any set with\ncompact closure. -/\n@[to_additive measure_preimage_isAddLeftInvariant_eq_smul_of_hasCompactSupport\n\"Two left invariant measures give the same mass to level sets of continuous compactly supported\nfunctions, up to the scalar `addHaarScalarFactor Î¼' Î¼`.\n\nAuxiliary lemma in the proof of the more general\n`measure_isAddInvariant_eq_smul_of_isCompact_closure`, which works for any set with\ncompact closure.\"]\nlemma measure_preimage_isMulLeftInvariant_eq_smul_of_hasCompactSupport\n    (Î¼' Î¼ : Measure G) [IsHaarMeasure Î¼] [IsFiniteMeasureOnCompacts Î¼'] [IsMulLeftInvariant Î¼']\n    {f : G â†’ â„} (hf : Continuous f) (h'f : HasCompactSupport f) :\n    Î¼' (f â»Â¹' {1}) = haarScalarFactor Î¼' Î¼ â€¢ Î¼ (f â»Â¹' {1}) := by\n  /- This follows from the fact that the two measures integrate in the same way continuous\n  functions, by approximating the indicator function of `f â»Â¹' {1}` by continuous functions\n  (namely `vâ‚™ âˆ˜ f` where `vâ‚™` is equal to `1` at `1`, and `0` outside of a small neighborhood\n  `(1 - uâ‚™, 1 + uâ‚™)` where `uâ‚™` is a sequence tending to `0`).\n  We use `vâ‚™ = thickenedIndicator uâ‚™ {1}` to take advantage of existing lemmas. -/\n  obtain âŸ¨u, -, u_mem, u_limâŸ© : âˆƒ u, StrictAnti u âˆ§ (âˆ€ (n : â„•), u n âˆˆ Ioo 0 1)\n    âˆ§ Tendsto u atTop (ğ“ 0) := exists_seq_strictAnti_tendsto' (zero_lt_one : (0 : â„) < 1)\n  let v : â„• â†’ â„ â†’ â„ := fun n x â†¦ thickenedIndicator (u_mem n).1 ({1} : Set â„) x\n  have vf_cont n : Continuous ((v n) âˆ˜ f) := by\n    apply Continuous.comp (continuous_induced_dom.comp ?_) hf\n    exact BoundedContinuousFunction.continuous (thickenedIndicator (u_mem n).left {1})\n  have I : âˆ€ (Î½ : Measure G), IsFiniteMeasureOnCompacts Î½ â†’\n      Tendsto (fun n â†¦ âˆ« x, v n (f x) âˆ‚Î½) atTop\n      (ğ“ (âˆ« x, Set.indicator ({1} : Set â„) (fun _ â†¦ 1) (f x) âˆ‚Î½)) := by\n    intro Î½ hÎ½\n    apply tendsto_integral_of_dominated_convergence\n        (bound := (tsupport f).indicator (fun (_ : G) â†¦ (1 : â„)) )\n    Â· exact fun n â†¦ (vf_cont n).aestronglyMeasurable\n    Â· apply IntegrableOn.integrable_indicator _ (isClosed_tsupport f).measurableSet\n      simpa using IsCompact.measure_lt_top h'f\n    Â· refine fun n â†¦ Eventually.of_forall (fun x â†¦ ?_)\n      by_cases hx : x âˆˆ tsupport f\n      Â· simp only [v, Real.norm_eq_abs, NNReal.abs_eq, hx, indicator_of_mem]\n        norm_cast\n        exact thickenedIndicator_le_one _ _ _\n      Â· simp only [v, Real.norm_eq_abs, NNReal.abs_eq, hx, not_false_eq_true, indicator_of_not_mem]\n        rw [thickenedIndicator_zero]\n        Â· simp\n        Â· simpa [image_eq_zero_of_nmem_tsupport hx] using (u_mem n).2.le\n    Â· filter_upwards with x\n      have T := tendsto_pi_nhds.1 (thickenedIndicator_tendsto_indicator_closure\n        (fun n â†¦ (u_mem n).1) u_lim ({1} : Set â„)) (f x)\n      simp only [thickenedIndicator_apply, closure_singleton] at T\n      convert NNReal.tendsto_coe.2 T\n      simp\n  have M n : âˆ« (x : G), v n (f x) âˆ‚Î¼' = âˆ« (x : G), v n (f x) âˆ‚(haarScalarFactor Î¼' Î¼ â€¢ Î¼) := by\n    apply integral_isMulLeftInvariant_eq_smul_of_hasCompactSupport Î¼' Î¼ (vf_cont n)\n    apply h'f.comp_left\n    simp only [v, thickenedIndicator_apply, NNReal.coe_eq_zero]\n    rw [thickenedIndicatorAux_zero (u_mem n).1]\n    Â· simp only [ENNReal.zero_toNNReal]\n    Â· simpa using (u_mem n).2.le\n  have I1 := I Î¼' (by infer_instance)\n  simp_rw [M] at I1\n  have J1 : âˆ« (x : G), indicator {1} (fun _ â†¦ (1 : â„)) (f x) âˆ‚Î¼'\n      = âˆ« (x : G), indicator {1} (fun _ â†¦ 1) (f x) âˆ‚(haarScalarFactor Î¼' Î¼ â€¢ Î¼) :=\n    tendsto_nhds_unique I1 (I (haarScalarFactor Î¼' Î¼ â€¢ Î¼) (by infer_instance))\n  have J2 : ENNReal.toReal (Î¼' (f â»Â¹' {1}))\n      = ENNReal.toReal ((haarScalarFactor Î¼' Î¼ â€¢ Î¼) (f â»Â¹' {1})) := by\n    have : (fun x â†¦ indicator {1} (fun _ â†¦ (1 : â„)) (f x)) =\n        (fun x â†¦ indicator (f â»Â¹' {1}) (fun _ â†¦ (1 : â„)) x) := by\n      ext x\n      exact (indicator_comp_right f (s := ({1} : Set â„)) (g := (fun _ â†¦ (1 : â„))) (x := x)).symm\n    have mf : MeasurableSet (f â»Â¹' {1}) := (isClosed_singleton.preimage hf).measurableSet\n    simpa only [this, mf, integral_indicator_const, smul_eq_mul, mul_one, Pi.smul_apply,\n      nnreal_smul_coe_apply, ENNReal.toReal_mul, ENNReal.coe_toReal] using J1\n  have C : IsCompact (f â»Â¹' {1}) := h'f.isCompact_preimage hf isClosed_singleton (by simp)\n  rw [ENNReal.toReal_eq_toReal C.measure_lt_top.ne C.measure_lt_top.ne] at J2\n  simpa using J2\n\n"}
{"name":"MeasureTheory.Measure.measure_preimage_isMulLeftInvariant_eq_smul_of_hasCompactSupport","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninstâœâ· : TopologicalSpace G\ninstâœâ¶ : Group G\ninstâœâµ : TopologicalGroup G\ninstâœâ´ : MeasurableSpace G\ninstâœÂ³ : BorelSpace G\nÎ¼' Î¼ : MeasureTheory.Measure G\ninstâœÂ² : Î¼.IsHaarMeasure\ninstâœÂ¹ : MeasureTheory.IsFiniteMeasureOnCompacts Î¼'\ninstâœ : Î¼'.IsMulLeftInvariant\nf : G â†’ Real\nhf : Continuous f\nh'f : HasCompactSupport f\nâŠ¢ Eq (Î¼' (Set.preimage f (Singleton.singleton 1))) (HSMul.hSMul (Î¼'.haarScalarFactor Î¼) (Î¼ (Set.preimage f (Singleton.singleton 1))))","decl":"/-- Two left invariant measures give the same mass to level sets of continuous compactly supported\nfunctions, up to the scalar `haarScalarFactor Î¼' Î¼`.\n\nAuxiliary lemma in the proof of the more general\n`measure_isMulInvariant_eq_smul_of_isCompact_closure`, which works for any set with\ncompact closure. -/\n@[to_additive measure_preimage_isAddLeftInvariant_eq_smul_of_hasCompactSupport\n\"Two left invariant measures give the same mass to level sets of continuous compactly supported\nfunctions, up to the scalar `addHaarScalarFactor Î¼' Î¼`.\n\nAuxiliary lemma in the proof of the more general\n`measure_isAddInvariant_eq_smul_of_isCompact_closure`, which works for any set with\ncompact closure.\"]\nlemma measure_preimage_isMulLeftInvariant_eq_smul_of_hasCompactSupport\n    (Î¼' Î¼ : Measure G) [IsHaarMeasure Î¼] [IsFiniteMeasureOnCompacts Î¼'] [IsMulLeftInvariant Î¼']\n    {f : G â†’ â„} (hf : Continuous f) (h'f : HasCompactSupport f) :\n    Î¼' (f â»Â¹' {1}) = haarScalarFactor Î¼' Î¼ â€¢ Î¼ (f â»Â¹' {1}) := by\n  /- This follows from the fact that the two measures integrate in the same way continuous\n  functions, by approximating the indicator function of `f â»Â¹' {1}` by continuous functions\n  (namely `vâ‚™ âˆ˜ f` where `vâ‚™` is equal to `1` at `1`, and `0` outside of a small neighborhood\n  `(1 - uâ‚™, 1 + uâ‚™)` where `uâ‚™` is a sequence tending to `0`).\n  We use `vâ‚™ = thickenedIndicator uâ‚™ {1}` to take advantage of existing lemmas. -/\n  obtain âŸ¨u, -, u_mem, u_limâŸ© : âˆƒ u, StrictAnti u âˆ§ (âˆ€ (n : â„•), u n âˆˆ Ioo 0 1)\n    âˆ§ Tendsto u atTop (ğ“ 0) := exists_seq_strictAnti_tendsto' (zero_lt_one : (0 : â„) < 1)\n  let v : â„• â†’ â„ â†’ â„ := fun n x â†¦ thickenedIndicator (u_mem n).1 ({1} : Set â„) x\n  have vf_cont n : Continuous ((v n) âˆ˜ f) := by\n    apply Continuous.comp (continuous_induced_dom.comp ?_) hf\n    exact BoundedContinuousFunction.continuous (thickenedIndicator (u_mem n).left {1})\n  have I : âˆ€ (Î½ : Measure G), IsFiniteMeasureOnCompacts Î½ â†’\n      Tendsto (fun n â†¦ âˆ« x, v n (f x) âˆ‚Î½) atTop\n      (ğ“ (âˆ« x, Set.indicator ({1} : Set â„) (fun _ â†¦ 1) (f x) âˆ‚Î½)) := by\n    intro Î½ hÎ½\n    apply tendsto_integral_of_dominated_convergence\n        (bound := (tsupport f).indicator (fun (_ : G) â†¦ (1 : â„)) )\n    Â· exact fun n â†¦ (vf_cont n).aestronglyMeasurable\n    Â· apply IntegrableOn.integrable_indicator _ (isClosed_tsupport f).measurableSet\n      simpa using IsCompact.measure_lt_top h'f\n    Â· refine fun n â†¦ Eventually.of_forall (fun x â†¦ ?_)\n      by_cases hx : x âˆˆ tsupport f\n      Â· simp only [v, Real.norm_eq_abs, NNReal.abs_eq, hx, indicator_of_mem]\n        norm_cast\n        exact thickenedIndicator_le_one _ _ _\n      Â· simp only [v, Real.norm_eq_abs, NNReal.abs_eq, hx, not_false_eq_true, indicator_of_not_mem]\n        rw [thickenedIndicator_zero]\n        Â· simp\n        Â· simpa [image_eq_zero_of_nmem_tsupport hx] using (u_mem n).2.le\n    Â· filter_upwards with x\n      have T := tendsto_pi_nhds.1 (thickenedIndicator_tendsto_indicator_closure\n        (fun n â†¦ (u_mem n).1) u_lim ({1} : Set â„)) (f x)\n      simp only [thickenedIndicator_apply, closure_singleton] at T\n      convert NNReal.tendsto_coe.2 T\n      simp\n  have M n : âˆ« (x : G), v n (f x) âˆ‚Î¼' = âˆ« (x : G), v n (f x) âˆ‚(haarScalarFactor Î¼' Î¼ â€¢ Î¼) := by\n    apply integral_isMulLeftInvariant_eq_smul_of_hasCompactSupport Î¼' Î¼ (vf_cont n)\n    apply h'f.comp_left\n    simp only [v, thickenedIndicator_apply, NNReal.coe_eq_zero]\n    rw [thickenedIndicatorAux_zero (u_mem n).1]\n    Â· simp only [ENNReal.zero_toNNReal]\n    Â· simpa using (u_mem n).2.le\n  have I1 := I Î¼' (by infer_instance)\n  simp_rw [M] at I1\n  have J1 : âˆ« (x : G), indicator {1} (fun _ â†¦ (1 : â„)) (f x) âˆ‚Î¼'\n      = âˆ« (x : G), indicator {1} (fun _ â†¦ 1) (f x) âˆ‚(haarScalarFactor Î¼' Î¼ â€¢ Î¼) :=\n    tendsto_nhds_unique I1 (I (haarScalarFactor Î¼' Î¼ â€¢ Î¼) (by infer_instance))\n  have J2 : ENNReal.toReal (Î¼' (f â»Â¹' {1}))\n      = ENNReal.toReal ((haarScalarFactor Î¼' Î¼ â€¢ Î¼) (f â»Â¹' {1})) := by\n    have : (fun x â†¦ indicator {1} (fun _ â†¦ (1 : â„)) (f x)) =\n        (fun x â†¦ indicator (f â»Â¹' {1}) (fun _ â†¦ (1 : â„)) x) := by\n      ext x\n      exact (indicator_comp_right f (s := ({1} : Set â„)) (g := (fun _ â†¦ (1 : â„))) (x := x)).symm\n    have mf : MeasurableSet (f â»Â¹' {1}) := (isClosed_singleton.preimage hf).measurableSet\n    simpa only [this, mf, integral_indicator_const, smul_eq_mul, mul_one, Pi.smul_apply,\n      nnreal_smul_coe_apply, ENNReal.toReal_mul, ENNReal.coe_toReal] using J1\n  have C : IsCompact (f â»Â¹' {1}) := h'f.isCompact_preimage hf isClosed_singleton (by simp)\n  rw [ENNReal.toReal_eq_toReal C.measure_lt_top.ne C.measure_lt_top.ne] at J2\n  simpa using J2\n\n"}
{"name":"MeasureTheory.Measure.smul_measure_isAddInvariant_le_of_isCompact_closure","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninstâœâ¹ : TopologicalSpace G\ninstâœâ¸ : AddGroup G\ninstâœâ· : TopologicalAddGroup G\ninstâœâ¶ : MeasurableSpace G\ninstâœâµ : BorelSpace G\ninstâœâ´ : LocallyCompactSpace G\nÎ¼' Î¼ : MeasureTheory.Measure G\ninstâœÂ³ : Î¼.IsAddHaarMeasure\ninstâœÂ² : MeasureTheory.IsFiniteMeasureOnCompacts Î¼'\ninstâœÂ¹ : Î¼'.IsAddLeftInvariant\ninstâœ : Î¼.InnerRegularCompactLTTop\ns : Set G\nhs : MeasurableSet s\nh's : IsCompact (closure s)\nâŠ¢ LE.le (HSMul.hSMul (Î¼'.addHaarScalarFactor Î¼) (Î¼ s)) (Î¼' s)","decl":"/-- If an invariant measure is inner regular, then it gives less mass to sets with compact closure\nthan any other invariant measure, up to the scalar `haarScalarFactor Î¼' Î¼`.\n\nAuxiliary lemma in the proof of the more general\n`measure_isMulInvariant_eq_smul_of_isCompact_closure`, which gives equality for any\nset with compact closure. -/\n@[to_additive smul_measure_isAddInvariant_le_of_isCompact_closure\n\"If an invariant measure is inner regular, then it gives less mass to sets with compact closure\nthan any other invariant measure, up to the scalar `addHaarScalarFactor Î¼' Î¼`.\n\nAuxiliary lemma in the proof of the more general\n`measure_isAddInvariant_eq_smul_of_isCompact_closure`, which gives equality for any\nset with compact closure.\"]\nlemma smul_measure_isMulInvariant_le_of_isCompact_closure [LocallyCompactSpace G]\n    (Î¼' Î¼ : Measure G) [IsHaarMeasure Î¼] [IsFiniteMeasureOnCompacts Î¼'] [IsMulLeftInvariant Î¼']\n    [InnerRegularCompactLTTop Î¼]\n    {s : Set G} (hs : MeasurableSet s) (h's : IsCompact (closure s)) :\n    haarScalarFactor Î¼' Î¼ â€¢ Î¼ s â‰¤ Î¼' s := by\n  apply le_of_forall_lt (fun r hr â†¦ ?_)\n  let Î½ := haarScalarFactor Î¼' Î¼ â€¢ Î¼\n  have : Î½ s â‰  âˆ := ((measure_mono subset_closure).trans_lt h's.measure_lt_top).ne\n  obtain âŸ¨-, hf, âŸ¨f, f_cont, f_comp, rflâŸ©, Î½fâŸ© :\n      âˆƒ K âŠ† s, (âˆƒ f, Continuous f âˆ§ HasCompactSupport f âˆ§ K = f â»Â¹' {1}) âˆ§ r < Î½ K :=\n    innerRegularWRT_preimage_one_hasCompactSupport_measure_ne_top_of_group âŸ¨hs, thisâŸ© r\n      (by convert hr)\n  calc\n  r < Î½ (f â»Â¹' {1}) := Î½f\n  _ = Î¼' (f â»Â¹' {1}) :=\n    (measure_preimage_isMulLeftInvariant_eq_smul_of_hasCompactSupport _ _ f_cont f_comp).symm\n  _ â‰¤ Î¼' s := measure_mono hf\n\n"}
{"name":"MeasureTheory.Measure.smul_measure_isMulInvariant_le_of_isCompact_closure","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninstâœâ¹ : TopologicalSpace G\ninstâœâ¸ : Group G\ninstâœâ· : TopologicalGroup G\ninstâœâ¶ : MeasurableSpace G\ninstâœâµ : BorelSpace G\ninstâœâ´ : LocallyCompactSpace G\nÎ¼' Î¼ : MeasureTheory.Measure G\ninstâœÂ³ : Î¼.IsHaarMeasure\ninstâœÂ² : MeasureTheory.IsFiniteMeasureOnCompacts Î¼'\ninstâœÂ¹ : Î¼'.IsMulLeftInvariant\ninstâœ : Î¼.InnerRegularCompactLTTop\ns : Set G\nhs : MeasurableSet s\nh's : IsCompact (closure s)\nâŠ¢ LE.le (HSMul.hSMul (Î¼'.haarScalarFactor Î¼) (Î¼ s)) (Î¼' s)","decl":"/-- If an invariant measure is inner regular, then it gives less mass to sets with compact closure\nthan any other invariant measure, up to the scalar `haarScalarFactor Î¼' Î¼`.\n\nAuxiliary lemma in the proof of the more general\n`measure_isMulInvariant_eq_smul_of_isCompact_closure`, which gives equality for any\nset with compact closure. -/\n@[to_additive smul_measure_isAddInvariant_le_of_isCompact_closure\n\"If an invariant measure is inner regular, then it gives less mass to sets with compact closure\nthan any other invariant measure, up to the scalar `addHaarScalarFactor Î¼' Î¼`.\n\nAuxiliary lemma in the proof of the more general\n`measure_isAddInvariant_eq_smul_of_isCompact_closure`, which gives equality for any\nset with compact closure.\"]\nlemma smul_measure_isMulInvariant_le_of_isCompact_closure [LocallyCompactSpace G]\n    (Î¼' Î¼ : Measure G) [IsHaarMeasure Î¼] [IsFiniteMeasureOnCompacts Î¼'] [IsMulLeftInvariant Î¼']\n    [InnerRegularCompactLTTop Î¼]\n    {s : Set G} (hs : MeasurableSet s) (h's : IsCompact (closure s)) :\n    haarScalarFactor Î¼' Î¼ â€¢ Î¼ s â‰¤ Î¼' s := by\n  apply le_of_forall_lt (fun r hr â†¦ ?_)\n  let Î½ := haarScalarFactor Î¼' Î¼ â€¢ Î¼\n  have : Î½ s â‰  âˆ := ((measure_mono subset_closure).trans_lt h's.measure_lt_top).ne\n  obtain âŸ¨-, hf, âŸ¨f, f_cont, f_comp, rflâŸ©, Î½fâŸ© :\n      âˆƒ K âŠ† s, (âˆƒ f, Continuous f âˆ§ HasCompactSupport f âˆ§ K = f â»Â¹' {1}) âˆ§ r < Î½ K :=\n    innerRegularWRT_preimage_one_hasCompactSupport_measure_ne_top_of_group âŸ¨hs, thisâŸ© r\n      (by convert hr)\n  calc\n  r < Î½ (f â»Â¹' {1}) := Î½f\n  _ = Î¼' (f â»Â¹' {1}) :=\n    (measure_preimage_isMulLeftInvariant_eq_smul_of_hasCompactSupport _ _ f_cont f_comp).symm\n  _ â‰¤ Î¼' s := measure_mono hf\n\n"}
{"name":"MeasureTheory.Measure.measure_isAddInvariant_eq_smul_of_isCompact_closure_of_innerRegularCompactLTTop","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninstâœâ¹ : TopologicalSpace G\ninstâœâ¸ : AddGroup G\ninstâœâ· : TopologicalAddGroup G\ninstâœâ¶ : MeasurableSpace G\ninstâœâµ : BorelSpace G\ninstâœâ´ : LocallyCompactSpace G\nÎ¼' Î¼ : MeasureTheory.Measure G\ninstâœÂ³ : Î¼.IsAddHaarMeasure\ninstâœÂ² : MeasureTheory.IsFiniteMeasureOnCompacts Î¼'\ninstâœÂ¹ : Î¼'.IsAddLeftInvariant\ninstâœ : Î¼.InnerRegularCompactLTTop\ns : Set G\nhs : MeasurableSet s\nh's : IsCompact (closure s)\nâŠ¢ Eq (Î¼' s) (HSMul.hSMul (Î¼'.addHaarScalarFactor Î¼) (Î¼ s))","decl":"/-- If an invariant measure is inner regular, then it gives the same mass to measurable sets with\ncompact closure as any other invariant measure, up to the scalar `haarScalarFactor Î¼' Î¼`.\n\nAuxiliary lemma in the proof of the more general\n`measure_isMulInvariant_eq_smul_of_isCompact_closure`, which works for any set with\ncompact closure, and removes the inner regularity assumption. -/\n@[to_additive measure_isAddInvariant_eq_smul_of_isCompact_closure_of_innerRegularCompactLTTop\n\" If an invariant measure is inner regular, then it gives the same mass to measurable sets with\ncompact closure as any other invariant measure, up to the scalar `addHaarScalarFactor Î¼' Î¼`.\n\nAuxiliary lemma in the proof of the more general\n`measure_isAddInvariant_eq_smul_of_isCompact_closure`, which works for any set with\ncompact closure, and removes the inner regularity assumption.\"]\nlemma measure_isMulInvariant_eq_smul_of_isCompact_closure_of_innerRegularCompactLTTop\n    [LocallyCompactSpace G]\n    (Î¼' Î¼ : Measure G) [IsHaarMeasure Î¼] [IsFiniteMeasureOnCompacts Î¼'] [IsMulLeftInvariant Î¼']\n    [InnerRegularCompactLTTop Î¼]\n    {s : Set G} (hs : MeasurableSet s) (h's : IsCompact (closure s)) :\n    Î¼' s = haarScalarFactor Î¼' Î¼ â€¢ Î¼ s := by\n  apply le_antisymm ?_ (smul_measure_isMulInvariant_le_of_isCompact_closure Î¼' Î¼ hs h's)\n  let Î½ := haarScalarFactor Î¼' Î¼ â€¢ Î¼\n  change Î¼' s â‰¤ Î½ s\n  obtain âŸ¨âŸ¨f, f_contâŸ©, hf, -, f_comp, -âŸ© : âˆƒ f : C(G, â„), EqOn f 1 (closure s) âˆ§ EqOn f 0 âˆ…\n      âˆ§ HasCompactSupport f âˆ§ âˆ€ x, f x âˆˆ Icc (0 : â„) 1 :=\n    exists_continuous_one_zero_of_isCompact h's isClosed_empty (disjoint_empty _)\n  let t := f â»Â¹' {1}\n  have t_closed : IsClosed t := isClosed_singleton.preimage f_cont\n  have t_comp : IsCompact t := f_comp.isCompact_preimage f_cont isClosed_singleton (by simp)\n  have st : s âŠ† t := (IsClosed.closure_subset_iff t_closed).mp hf\n  have A : Î½ (t \\ s) â‰¤ Î¼' (t \\ s) := by\n    apply smul_measure_isMulInvariant_le_of_isCompact_closure _ _ (t_closed.measurableSet.diff hs)\n    exact t_comp.closure_of_subset diff_subset\n  have B : Î¼' t = Î½ t :=\n    measure_preimage_isMulLeftInvariant_eq_smul_of_hasCompactSupport _ _ f_cont f_comp\n  rwa [measure_diff st hs.nullMeasurableSet, measure_diff st hs.nullMeasurableSet, â† B,\n    ENNReal.sub_le_sub_iff_left] at A\n  Â· exact measure_mono st\n  Â· exact t_comp.measure_lt_top.ne\n  Â· exact ((measure_mono st).trans_lt t_comp.measure_lt_top).ne\n  Â· exact ((measure_mono st).trans_lt t_comp.measure_lt_top).ne\n\n"}
{"name":"MeasureTheory.Measure.measure_isMulInvariant_eq_smul_of_isCompact_closure_of_innerRegularCompactLTTop","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninstâœâ¹ : TopologicalSpace G\ninstâœâ¸ : Group G\ninstâœâ· : TopologicalGroup G\ninstâœâ¶ : MeasurableSpace G\ninstâœâµ : BorelSpace G\ninstâœâ´ : LocallyCompactSpace G\nÎ¼' Î¼ : MeasureTheory.Measure G\ninstâœÂ³ : Î¼.IsHaarMeasure\ninstâœÂ² : MeasureTheory.IsFiniteMeasureOnCompacts Î¼'\ninstâœÂ¹ : Î¼'.IsMulLeftInvariant\ninstâœ : Î¼.InnerRegularCompactLTTop\ns : Set G\nhs : MeasurableSet s\nh's : IsCompact (closure s)\nâŠ¢ Eq (Î¼' s) (HSMul.hSMul (Î¼'.haarScalarFactor Î¼) (Î¼ s))","decl":"/-- If an invariant measure is inner regular, then it gives the same mass to measurable sets with\ncompact closure as any other invariant measure, up to the scalar `haarScalarFactor Î¼' Î¼`.\n\nAuxiliary lemma in the proof of the more general\n`measure_isMulInvariant_eq_smul_of_isCompact_closure`, which works for any set with\ncompact closure, and removes the inner regularity assumption. -/\n@[to_additive measure_isAddInvariant_eq_smul_of_isCompact_closure_of_innerRegularCompactLTTop\n\" If an invariant measure is inner regular, then it gives the same mass to measurable sets with\ncompact closure as any other invariant measure, up to the scalar `addHaarScalarFactor Î¼' Î¼`.\n\nAuxiliary lemma in the proof of the more general\n`measure_isAddInvariant_eq_smul_of_isCompact_closure`, which works for any set with\ncompact closure, and removes the inner regularity assumption.\"]\nlemma measure_isMulInvariant_eq_smul_of_isCompact_closure_of_innerRegularCompactLTTop\n    [LocallyCompactSpace G]\n    (Î¼' Î¼ : Measure G) [IsHaarMeasure Î¼] [IsFiniteMeasureOnCompacts Î¼'] [IsMulLeftInvariant Î¼']\n    [InnerRegularCompactLTTop Î¼]\n    {s : Set G} (hs : MeasurableSet s) (h's : IsCompact (closure s)) :\n    Î¼' s = haarScalarFactor Î¼' Î¼ â€¢ Î¼ s := by\n  apply le_antisymm ?_ (smul_measure_isMulInvariant_le_of_isCompact_closure Î¼' Î¼ hs h's)\n  let Î½ := haarScalarFactor Î¼' Î¼ â€¢ Î¼\n  change Î¼' s â‰¤ Î½ s\n  obtain âŸ¨âŸ¨f, f_contâŸ©, hf, -, f_comp, -âŸ© : âˆƒ f : C(G, â„), EqOn f 1 (closure s) âˆ§ EqOn f 0 âˆ…\n      âˆ§ HasCompactSupport f âˆ§ âˆ€ x, f x âˆˆ Icc (0 : â„) 1 :=\n    exists_continuous_one_zero_of_isCompact h's isClosed_empty (disjoint_empty _)\n  let t := f â»Â¹' {1}\n  have t_closed : IsClosed t := isClosed_singleton.preimage f_cont\n  have t_comp : IsCompact t := f_comp.isCompact_preimage f_cont isClosed_singleton (by simp)\n  have st : s âŠ† t := (IsClosed.closure_subset_iff t_closed).mp hf\n  have A : Î½ (t \\ s) â‰¤ Î¼' (t \\ s) := by\n    apply smul_measure_isMulInvariant_le_of_isCompact_closure _ _ (t_closed.measurableSet.diff hs)\n    exact t_comp.closure_of_subset diff_subset\n  have B : Î¼' t = Î½ t :=\n    measure_preimage_isMulLeftInvariant_eq_smul_of_hasCompactSupport _ _ f_cont f_comp\n  rwa [measure_diff st hs.nullMeasurableSet, measure_diff st hs.nullMeasurableSet, â† B,\n    ENNReal.sub_le_sub_iff_left] at A\n  Â· exact measure_mono st\n  Â· exact t_comp.measure_lt_top.ne\n  Â· exact ((measure_mono st).trans_lt t_comp.measure_lt_top).ne\n  Â· exact ((measure_mono st).trans_lt t_comp.measure_lt_top).ne\n\n"}
{"name":"MeasureTheory.Measure.measure_isMulInvariant_eq_smul_of_isCompact_closure_of_measurableSet","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninstâœâ¸ : TopologicalSpace G\ninstâœâ· : Group G\ninstâœâ¶ : TopologicalGroup G\ninstâœâµ : MeasurableSpace G\ninstâœâ´ : BorelSpace G\ninstâœÂ³ : LocallyCompactSpace G\nÎ¼' Î¼ : MeasureTheory.Measure G\ninstâœÂ² : Î¼.IsHaarMeasure\ninstâœÂ¹ : MeasureTheory.IsFiniteMeasureOnCompacts Î¼'\ninstâœ : Î¼'.IsMulLeftInvariant\ns : Set G\nhs : MeasurableSet s\nh's : IsCompact (closure s)\nâŠ¢ Eq (Î¼' s) (HSMul.hSMul (Î¼'.haarScalarFactor Î¼) (Î¼ s))","decl":"/-- Given an invariant measure then it gives the same mass to measurable sets with\ncompact closure as any other invariant measure, up to the scalar `haarScalarFactor Î¼' Î¼`.\n\nAuxiliary lemma in the proof of the more general\n`measure_isMulInvariant_eq_smul_of_isCompact_closure`, which removes the\nmeasurability assumption. -/\n@[to_additive measure_isAddInvariant_eq_smul_of_isCompact_closure_of_measurableSet\n\"Given an invariant measure then it gives the same mass to measurable sets with\ncompact closure as any other invariant measure, up to the scalar `addHaarScalarFactor Î¼' Î¼`.\n\nAuxiliary lemma in the proof of the more general\n`measure_isAddInvariant_eq_smul_of_isCompact_closure`, which removes the\nmeasurability assumption.\"]\nlemma measure_isMulInvariant_eq_smul_of_isCompact_closure_of_measurableSet [LocallyCompactSpace G]\n    (Î¼' Î¼ : Measure G) [IsHaarMeasure Î¼] [IsFiniteMeasureOnCompacts Î¼'] [IsMulLeftInvariant Î¼']\n    {s : Set G} (hs : MeasurableSet s) (h's : IsCompact (closure s)) :\n    Î¼' s = haarScalarFactor Î¼' Î¼ â€¢ Î¼ s := by\n  let Î½ : Measure G := haar\n  have A : Î¼' s = haarScalarFactor Î¼' Î½ â€¢ Î½ s :=\n    measure_isMulInvariant_eq_smul_of_isCompact_closure_of_innerRegularCompactLTTop Î¼' Î½ hs h's\n  have B : Î¼ s = haarScalarFactor Î¼ Î½ â€¢ Î½ s :=\n    measure_isMulInvariant_eq_smul_of_isCompact_closure_of_innerRegularCompactLTTop Î¼ Î½ hs h's\n  rw [A, B, smul_smul, haarScalarFactor_eq_mul Î¼' Î¼ Î½]\n\n"}
{"name":"MeasureTheory.Measure.measure_isAddInvariant_eq_smul_of_isCompact_closure_of_measurableSet","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninstâœâ¸ : TopologicalSpace G\ninstâœâ· : AddGroup G\ninstâœâ¶ : TopologicalAddGroup G\ninstâœâµ : MeasurableSpace G\ninstâœâ´ : BorelSpace G\ninstâœÂ³ : LocallyCompactSpace G\nÎ¼' Î¼ : MeasureTheory.Measure G\ninstâœÂ² : Î¼.IsAddHaarMeasure\ninstâœÂ¹ : MeasureTheory.IsFiniteMeasureOnCompacts Î¼'\ninstâœ : Î¼'.IsAddLeftInvariant\ns : Set G\nhs : MeasurableSet s\nh's : IsCompact (closure s)\nâŠ¢ Eq (Î¼' s) (HSMul.hSMul (Î¼'.addHaarScalarFactor Î¼) (Î¼ s))","decl":"/-- Given an invariant measure then it gives the same mass to measurable sets with\ncompact closure as any other invariant measure, up to the scalar `haarScalarFactor Î¼' Î¼`.\n\nAuxiliary lemma in the proof of the more general\n`measure_isMulInvariant_eq_smul_of_isCompact_closure`, which removes the\nmeasurability assumption. -/\n@[to_additive measure_isAddInvariant_eq_smul_of_isCompact_closure_of_measurableSet\n\"Given an invariant measure then it gives the same mass to measurable sets with\ncompact closure as any other invariant measure, up to the scalar `addHaarScalarFactor Î¼' Î¼`.\n\nAuxiliary lemma in the proof of the more general\n`measure_isAddInvariant_eq_smul_of_isCompact_closure`, which removes the\nmeasurability assumption.\"]\nlemma measure_isMulInvariant_eq_smul_of_isCompact_closure_of_measurableSet [LocallyCompactSpace G]\n    (Î¼' Î¼ : Measure G) [IsHaarMeasure Î¼] [IsFiniteMeasureOnCompacts Î¼'] [IsMulLeftInvariant Î¼']\n    {s : Set G} (hs : MeasurableSet s) (h's : IsCompact (closure s)) :\n    Î¼' s = haarScalarFactor Î¼' Î¼ â€¢ Î¼ s := by\n  let Î½ : Measure G := haar\n  have A : Î¼' s = haarScalarFactor Î¼' Î½ â€¢ Î½ s :=\n    measure_isMulInvariant_eq_smul_of_isCompact_closure_of_innerRegularCompactLTTop Î¼' Î½ hs h's\n  have B : Î¼ s = haarScalarFactor Î¼ Î½ â€¢ Î½ s :=\n    measure_isMulInvariant_eq_smul_of_isCompact_closure_of_innerRegularCompactLTTop Î¼ Î½ hs h's\n  rw [A, B, smul_smul, haarScalarFactor_eq_mul Î¼' Î¼ Î½]\n\n"}
{"name":"MeasureTheory.Measure.measure_isAddInvariant_eq_smul_of_isCompact_closure","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninstâœâ¸ : TopologicalSpace G\ninstâœâ· : AddGroup G\ninstâœâ¶ : TopologicalAddGroup G\ninstâœâµ : MeasurableSpace G\ninstâœâ´ : BorelSpace G\ninstâœÂ³ : LocallyCompactSpace G\nÎ¼' Î¼ : MeasureTheory.Measure G\ninstâœÂ² : Î¼.IsAddHaarMeasure\ninstâœÂ¹ : MeasureTheory.IsFiniteMeasureOnCompacts Î¼'\ninstâœ : Î¼'.IsAddLeftInvariant\ns : Set G\nh's : IsCompact (closure s)\nâŠ¢ Eq (Î¼' s) (HSMul.hSMul (Î¼'.addHaarScalarFactor Î¼) (Î¼ s))","decl":"/-- **Uniqueness of left-invariant measures**:\nGiven two left-invariant measures which are finite on compacts, they coincide in the following\nsense: they give the same value to sets with compact closure, up to the multiplicative\nconstant `haarScalarFactor Î¼' Î¼`. -/\n@[to_additive measure_isAddInvariant_eq_smul_of_isCompact_closure\n\"**Uniqueness of left-invariant measures**:\nGiven two left-invariant measures which are finite on compacts, they coincide in the following\nsense: they give the same value to sets with compact closure, up to the multiplicative\nconstant `addHaarScalarFactor Î¼' Î¼`. \"]\ntheorem measure_isMulInvariant_eq_smul_of_isCompact_closure [LocallyCompactSpace G]\n    (Î¼' Î¼ : Measure G) [IsHaarMeasure Î¼] [IsFiniteMeasureOnCompacts Î¼'] [IsMulLeftInvariant Î¼']\n    {s : Set G} (h's : IsCompact (closure s)) :\n    Î¼' s = haarScalarFactor Î¼' Î¼ â€¢ Î¼ s := by\n  let Î½ := haarScalarFactor Î¼' Î¼ â€¢ Î¼\n  apply le_antisymm\n  Â· calc\n    Î¼' s â‰¤ Î¼' ((toMeasurable Î½ s) âˆ© (closure s)) :=\n      measure_mono <| subset_inter (subset_toMeasurable Î½ s) subset_closure\n    _ = Î½ ((toMeasurable Î½ s) âˆ© (closure s)) := by\n      apply measure_isMulInvariant_eq_smul_of_isCompact_closure_of_measurableSet _ _ _ _\n      Â· exact (measurableSet_toMeasurable Î½ s).inter isClosed_closure.measurableSet\n      Â· exact h's.closure_of_subset inter_subset_right\n    _ â‰¤ Î½ (toMeasurable Î½ s) := measure_mono inter_subset_left\n    _ = Î½ s := measure_toMeasurable s\n  Â· calc\n    Î½ s â‰¤ Î½ ((toMeasurable Î¼' s) âˆ© (closure s)) :=\n      measure_mono <| subset_inter (subset_toMeasurable Î¼' s) subset_closure\n    _ = Î¼' ((toMeasurable Î¼' s) âˆ© (closure s)) := by\n      apply (measure_isMulInvariant_eq_smul_of_isCompact_closure_of_measurableSet _ _ _ _).symm\n      Â· exact (measurableSet_toMeasurable Î¼' s).inter isClosed_closure.measurableSet\n      Â· exact h's.closure_of_subset inter_subset_right\n    _ â‰¤ Î¼' (toMeasurable Î¼' s) := measure_mono inter_subset_left\n    _ = Î¼' s := measure_toMeasurable s\n\n"}
{"name":"MeasureTheory.Measure.measure_isMulInvariant_eq_smul_of_isCompact_closure","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninstâœâ¸ : TopologicalSpace G\ninstâœâ· : Group G\ninstâœâ¶ : TopologicalGroup G\ninstâœâµ : MeasurableSpace G\ninstâœâ´ : BorelSpace G\ninstâœÂ³ : LocallyCompactSpace G\nÎ¼' Î¼ : MeasureTheory.Measure G\ninstâœÂ² : Î¼.IsHaarMeasure\ninstâœÂ¹ : MeasureTheory.IsFiniteMeasureOnCompacts Î¼'\ninstâœ : Î¼'.IsMulLeftInvariant\ns : Set G\nh's : IsCompact (closure s)\nâŠ¢ Eq (Î¼' s) (HSMul.hSMul (Î¼'.haarScalarFactor Î¼) (Î¼ s))","decl":"/-- **Uniqueness of left-invariant measures**:\nGiven two left-invariant measures which are finite on compacts, they coincide in the following\nsense: they give the same value to sets with compact closure, up to the multiplicative\nconstant `haarScalarFactor Î¼' Î¼`. -/\n@[to_additive measure_isAddInvariant_eq_smul_of_isCompact_closure\n\"**Uniqueness of left-invariant measures**:\nGiven two left-invariant measures which are finite on compacts, they coincide in the following\nsense: they give the same value to sets with compact closure, up to the multiplicative\nconstant `addHaarScalarFactor Î¼' Î¼`. \"]\ntheorem measure_isMulInvariant_eq_smul_of_isCompact_closure [LocallyCompactSpace G]\n    (Î¼' Î¼ : Measure G) [IsHaarMeasure Î¼] [IsFiniteMeasureOnCompacts Î¼'] [IsMulLeftInvariant Î¼']\n    {s : Set G} (h's : IsCompact (closure s)) :\n    Î¼' s = haarScalarFactor Î¼' Î¼ â€¢ Î¼ s := by\n  let Î½ := haarScalarFactor Î¼' Î¼ â€¢ Î¼\n  apply le_antisymm\n  Â· calc\n    Î¼' s â‰¤ Î¼' ((toMeasurable Î½ s) âˆ© (closure s)) :=\n      measure_mono <| subset_inter (subset_toMeasurable Î½ s) subset_closure\n    _ = Î½ ((toMeasurable Î½ s) âˆ© (closure s)) := by\n      apply measure_isMulInvariant_eq_smul_of_isCompact_closure_of_measurableSet _ _ _ _\n      Â· exact (measurableSet_toMeasurable Î½ s).inter isClosed_closure.measurableSet\n      Â· exact h's.closure_of_subset inter_subset_right\n    _ â‰¤ Î½ (toMeasurable Î½ s) := measure_mono inter_subset_left\n    _ = Î½ s := measure_toMeasurable s\n  Â· calc\n    Î½ s â‰¤ Î½ ((toMeasurable Î¼' s) âˆ© (closure s)) :=\n      measure_mono <| subset_inter (subset_toMeasurable Î¼' s) subset_closure\n    _ = Î¼' ((toMeasurable Î¼' s) âˆ© (closure s)) := by\n      apply (measure_isMulInvariant_eq_smul_of_isCompact_closure_of_measurableSet _ _ _ _).symm\n      Â· exact (measurableSet_toMeasurable Î¼' s).inter isClosed_closure.measurableSet\n      Â· exact h's.closure_of_subset inter_subset_right\n    _ â‰¤ Î¼' (toMeasurable Î¼' s) := measure_mono inter_subset_left\n    _ = Î¼' s := measure_toMeasurable s\n\n"}
{"name":"MeasureTheory.Measure.isMulInvariant_eq_smul_of_compactSpace","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninstâœâ¸ : TopologicalSpace G\ninstâœâ· : Group G\ninstâœâ¶ : TopologicalGroup G\ninstâœâµ : MeasurableSpace G\ninstâœâ´ : BorelSpace G\ninstâœÂ³ : CompactSpace G\nÎ¼' Î¼ : MeasureTheory.Measure G\ninstâœÂ² : Î¼.IsHaarMeasure\ninstâœÂ¹ : Î¼'.IsMulLeftInvariant\ninstâœ : MeasureTheory.IsFiniteMeasureOnCompacts Î¼'\nâŠ¢ Eq Î¼' (HSMul.hSMul (Î¼'.haarScalarFactor Î¼) Î¼)","decl":"/-- **Uniqueness of Haar measures**:\nTwo Haar measures on a compact group coincide up to a multiplicative factor. -/\n@[to_additive isAddInvariant_eq_smul_of_compactSpace]\nlemma isMulInvariant_eq_smul_of_compactSpace [CompactSpace G] (Î¼' Î¼ : Measure G)\n    [IsHaarMeasure Î¼] [IsMulLeftInvariant Î¼'] [IsFiniteMeasureOnCompacts Î¼'] :\n    Î¼' = haarScalarFactor Î¼' Î¼ â€¢ Î¼ := by\n  ext s _hs\n  exact measure_isMulInvariant_eq_smul_of_isCompact_closure _ _ isClosed_closure.isCompact\n\n"}
{"name":"MeasureTheory.Measure.isAddInvariant_eq_smul_of_compactSpace","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninstâœâ¸ : TopologicalSpace G\ninstâœâ· : AddGroup G\ninstâœâ¶ : TopologicalAddGroup G\ninstâœâµ : MeasurableSpace G\ninstâœâ´ : BorelSpace G\ninstâœÂ³ : CompactSpace G\nÎ¼' Î¼ : MeasureTheory.Measure G\ninstâœÂ² : Î¼.IsAddHaarMeasure\ninstâœÂ¹ : Î¼'.IsAddLeftInvariant\ninstâœ : MeasureTheory.IsFiniteMeasureOnCompacts Î¼'\nâŠ¢ Eq Î¼' (HSMul.hSMul (Î¼'.addHaarScalarFactor Î¼) Î¼)","decl":"/-- **Uniqueness of Haar measures**:\nTwo Haar measures on a compact group coincide up to a multiplicative factor. -/\n@[to_additive isAddInvariant_eq_smul_of_compactSpace]\nlemma isMulInvariant_eq_smul_of_compactSpace [CompactSpace G] (Î¼' Î¼ : Measure G)\n    [IsHaarMeasure Î¼] [IsMulLeftInvariant Î¼'] [IsFiniteMeasureOnCompacts Î¼'] :\n    Î¼' = haarScalarFactor Î¼' Î¼ â€¢ Î¼ := by\n  ext s _hs\n  exact measure_isMulInvariant_eq_smul_of_isCompact_closure _ _ isClosed_closure.isCompact\n\n"}
{"name":"MeasureTheory.Measure.instInnerRegularOfIsAddHaarMeasureOfCompactSpace","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninstâœâµ : TopologicalSpace G\ninstâœâ´ : AddGroup G\ninstâœÂ³ : MeasurableSpace G\ninstâœÂ² : CompactSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœÂ¹ : Î¼.IsAddLeftInvariant\ninstâœ : MeasureTheory.IsFiniteMeasureOnCompacts Î¼\nâŠ¢ Î¼.InnerRegular","decl":"@[to_additive]\ninstance (priority := 100) instInnerRegularOfIsHaarMeasureOfCompactSpace\n    [CompactSpace G] (Î¼ : Measure G) [IsMulLeftInvariant Î¼] [IsFiniteMeasureOnCompacts Î¼] :\n    InnerRegular Î¼ := by\n  rw [isMulInvariant_eq_smul_of_compactSpace Î¼ haar]\n  infer_instance\n\n"}
{"name":"MeasureTheory.Measure.instInnerRegularOfIsHaarMeasureOfCompactSpace","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninstâœâµ : TopologicalSpace G\ninstâœâ´ : Group G\ninstâœÂ³ : MeasurableSpace G\ninstâœÂ² : CompactSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœÂ¹ : Î¼.IsMulLeftInvariant\ninstâœ : MeasureTheory.IsFiniteMeasureOnCompacts Î¼\nâŠ¢ Î¼.InnerRegular","decl":"@[to_additive]\ninstance (priority := 100) instInnerRegularOfIsHaarMeasureOfCompactSpace\n    [CompactSpace G] (Î¼ : Measure G) [IsMulLeftInvariant Î¼] [IsFiniteMeasureOnCompacts Î¼] :\n    InnerRegular Î¼ := by\n  rw [isMulInvariant_eq_smul_of_compactSpace Î¼ haar]\n  infer_instance\n\n"}
{"name":"MeasureTheory.Measure.instRegularOfIsHaarMeasureOfCompactSpace","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninstâœâµ : TopologicalSpace G\ninstâœâ´ : Group G\ninstâœÂ³ : MeasurableSpace G\ninstâœÂ² : CompactSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœÂ¹ : Î¼.IsMulLeftInvariant\ninstâœ : MeasureTheory.IsFiniteMeasureOnCompacts Î¼\nâŠ¢ Î¼.Regular","decl":"@[to_additive]\ninstance (priority := 100) instRegularOfIsHaarMeasureOfCompactSpace\n    [CompactSpace G] (Î¼ : Measure G) [IsMulLeftInvariant Î¼] [IsFiniteMeasureOnCompacts Î¼] :\n    Regular Î¼ := by\n  rw [isMulInvariant_eq_smul_of_compactSpace Î¼ haar]\n  infer_instance\n\n"}
{"name":"MeasureTheory.Measure.instRegularOfIsAddHaarMeasureOfCompactSpace","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninstâœâµ : TopologicalSpace G\ninstâœâ´ : AddGroup G\ninstâœÂ³ : MeasurableSpace G\ninstâœÂ² : CompactSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœÂ¹ : Î¼.IsAddLeftInvariant\ninstâœ : MeasureTheory.IsFiniteMeasureOnCompacts Î¼\nâŠ¢ Î¼.Regular","decl":"@[to_additive]\ninstance (priority := 100) instRegularOfIsHaarMeasureOfCompactSpace\n    [CompactSpace G] (Î¼ : Measure G) [IsMulLeftInvariant Î¼] [IsFiniteMeasureOnCompacts Î¼] :\n    Regular Î¼ := by\n  rw [isMulInvariant_eq_smul_of_compactSpace Î¼ haar]\n  infer_instance\n\n"}
{"name":"MeasureTheory.Measure.isHaarMeasure_eq_of_isProbabilityMeasure","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninstâœâ¹ : TopologicalSpace G\ninstâœâ¸ : Group G\ninstâœâ· : TopologicalGroup G\ninstâœâ¶ : MeasurableSpace G\ninstâœâµ : BorelSpace G\ninstâœâ´ : LocallyCompactSpace G\nÎ¼' Î¼ : MeasureTheory.Measure G\ninstâœÂ³ : MeasureTheory.IsProbabilityMeasure Î¼\ninstâœÂ² : MeasureTheory.IsProbabilityMeasure Î¼'\ninstâœÂ¹ : Î¼.IsHaarMeasure\ninstâœ : Î¼'.IsHaarMeasure\nâŠ¢ Eq Î¼' Î¼","decl":"/-- **Uniqueness of Haar measures**:\nTwo Haar measures which are probability measures coincide. -/\n@[to_additive]\nlemma isHaarMeasure_eq_of_isProbabilityMeasure [LocallyCompactSpace G] (Î¼' Î¼ : Measure G)\n    [IsProbabilityMeasure Î¼] [IsProbabilityMeasure Î¼'] [IsHaarMeasure Î¼] [IsHaarMeasure Î¼'] :\n    Î¼' = Î¼ := by\n  have : CompactSpace G := by\n    by_contra H\n    rw [not_compactSpace_iff] at H\n    simpa using measure_univ_of_isMulLeftInvariant Î¼\n  have A s : Î¼' s = haarScalarFactor Î¼' Î¼ â€¢ Î¼ s :=\n    measure_isMulInvariant_eq_smul_of_isCompact_closure _ _ isClosed_closure.isCompact\n  have Z := A univ\n  simp only [measure_univ, ENNReal.smul_def, smul_eq_mul, mul_one, ENNReal.one_eq_coe] at Z\n  ext s _hs\n  simp [A s, â† Z]\n\n"}
{"name":"MeasureTheory.Measure.isAddHaarMeasure_eq_of_isProbabilityMeasure","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninstâœâ¹ : TopologicalSpace G\ninstâœâ¸ : AddGroup G\ninstâœâ· : TopologicalAddGroup G\ninstâœâ¶ : MeasurableSpace G\ninstâœâµ : BorelSpace G\ninstâœâ´ : LocallyCompactSpace G\nÎ¼' Î¼ : MeasureTheory.Measure G\ninstâœÂ³ : MeasureTheory.IsProbabilityMeasure Î¼\ninstâœÂ² : MeasureTheory.IsProbabilityMeasure Î¼'\ninstâœÂ¹ : Î¼.IsAddHaarMeasure\ninstâœ : Î¼'.IsAddHaarMeasure\nâŠ¢ Eq Î¼' Î¼","decl":"/-- **Uniqueness of Haar measures**:\nTwo Haar measures which are probability measures coincide. -/\n@[to_additive]\nlemma isHaarMeasure_eq_of_isProbabilityMeasure [LocallyCompactSpace G] (Î¼' Î¼ : Measure G)\n    [IsProbabilityMeasure Î¼] [IsProbabilityMeasure Î¼'] [IsHaarMeasure Î¼] [IsHaarMeasure Î¼'] :\n    Î¼' = Î¼ := by\n  have : CompactSpace G := by\n    by_contra H\n    rw [not_compactSpace_iff] at H\n    simpa using measure_univ_of_isMulLeftInvariant Î¼\n  have A s : Î¼' s = haarScalarFactor Î¼' Î¼ â€¢ Î¼ s :=\n    measure_isMulInvariant_eq_smul_of_isCompact_closure _ _ isClosed_closure.isCompact\n  have Z := A univ\n  simp only [measure_univ, ENNReal.smul_def, smul_eq_mul, mul_one, ENNReal.one_eq_coe] at Z\n  ext s _hs\n  simp [A s, â† Z]\n\n"}
{"name":"MeasureTheory.Measure.measure_isHaarMeasure_eq_smul_of_isEverywherePos","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninstâœâ· : TopologicalSpace G\ninstâœâ¶ : Group G\ninstâœâµ : TopologicalGroup G\ninstâœâ´ : MeasurableSpace G\ninstâœÂ³ : BorelSpace G\ninstâœÂ² : LocallyCompactSpace G\nÎ¼' Î¼ : MeasureTheory.Measure G\ninstâœÂ¹ : Î¼.IsHaarMeasure\ninstâœ : Î¼'.IsHaarMeasure\ns : Set G\nhs : MeasurableSet s\nh's : Î¼.IsEverywherePos s\nâŠ¢ Eq (Î¼' s) (HSMul.hSMul (Î¼'.haarScalarFactor Î¼) (Î¼ s))","decl":"@[to_additive measure_isAddHaarMeasure_eq_smul_of_isEverywherePos]\ntheorem measure_isHaarMeasure_eq_smul_of_isEverywherePos [LocallyCompactSpace G]\n    (Î¼' Î¼ : Measure G) [IsHaarMeasure Î¼] [IsHaarMeasure Î¼']\n    {s : Set G} (hs : MeasurableSet s) (h's : IsEverywherePos Î¼ s) :\n    Î¼' s = haarScalarFactor Î¼' Î¼ â€¢ Î¼ s := by\n  let Î½ := haarScalarFactor Î¼' Î¼ â€¢ Î¼\n  change Î¼' s = Î½ s\n  /- Fix a compact neighborhood `k` of the identity, and consider a maximal disjoint family `m` of\n  sets `x â€¢ k` centered at points in `s`. Then `s` is covered by the sets `x â€¢ (k * kâ»Â¹)` by\n  maximality. If the family is countable, then since `Î¼'` and `Î½` coincide in compact sets, and\n  the measure of a countable disjoint union is the sum of the measures, we get `Î¼' s = Î½ s`.\n  Otherwise, the family is uncountable, and each intersection with `s` has positive measure by\n  the everywhere positivity assumption, so `Î½ s = âˆ`, and `Î¼' s = âˆ` in the same way. -/\n  obtain âŸ¨k, k_comp, k_closed, k_memâŸ© : âˆƒ k, IsCompact k âˆ§ IsClosed k âˆ§ k âˆˆ ğ“ (1 : G) := by\n    rcases exists_compact_mem_nhds (1 : G) with âŸ¨k, hk, hmemâŸ©\n    exact âŸ¨closure k, hk.closure, isClosed_closure, mem_of_superset hmem subset_closureâŸ©\n  have one_k : 1 âˆˆ k := mem_of_mem_nhds k_mem\n  let A : Set (Set G) := {t | t âŠ† s âˆ§ PairwiseDisjoint t (fun x â†¦ x â€¢ k)}\n  obtain âŸ¨m, m_maxâŸ© : âˆƒ m, Maximal (Â· âˆˆ A) m := by\n    apply zorn_subset\n    intro c cA hc\n    refine âŸ¨â‹ƒ a âˆˆ c, a, âŸ¨?_, ?_âŸ©, ?_âŸ©\n    Â· simp only [iUnion_subset_iff]\n      intro a ac x hx\n      simp only [A, subset_def, mem_setOf_eq] at cA\n      exact (cA _ ac).1 x hx\n    Â· rintro x hx y hy hxy\n      simp only [mem_iUnion, exists_prop] at hx hy\n      rcases hx with âŸ¨a, ac, xaâŸ©\n      rcases hy with âŸ¨b, bc, ybâŸ©\n      obtain âŸ¨m, mc, am, bmâŸ© : âˆƒ m âˆˆ c, a âŠ† m âˆ§ b âŠ† m := hc.directedOn _ ac _ bc\n      exact (cA mc).2 (am xa) (bm yb) hxy\n    Â· intro a ac\n      exact subset_biUnion_of_mem (u := id) ac\n  obtain âŸ¨hms : m âŠ† s, hdj : PairwiseDisjoint m (fun x â†¦ x â€¢ k)âŸ© := m_max.prop\n  have sm : s âŠ† â‹ƒ x âˆˆ m, x â€¢ (k * kâ»Â¹) := by\n    intro y hy\n    by_cases h'y : m âˆª {y} âˆˆ A\n    Â· have ym : y âˆˆ m := m_max.mem_of_prop_insert (by simpa using h'y)\n      have : y âˆˆ y â€¢ (k * kâ»Â¹) := by\n        simpa using mem_leftCoset y (Set.mul_mem_mul one_k (Set.inv_mem_inv.mpr one_k))\n      exact mem_biUnion ym this\n    Â· obtain âŸ¨x, xm, -, z, zy, zxâŸ© : âˆƒ x âˆˆ m, y â‰  x âˆ§ âˆƒ z, z âˆˆ y â€¢ k âˆ§ z âˆˆ x â€¢ k := by\n        simpa [A, hms, hy, insert_subset_iff, pairwiseDisjoint_insert, hdj, not_disjoint_iff]\n          using h'y\n      have : y âˆˆ x â€¢ (k * kâ»Â¹) := by\n        rw [show y = x * ((xâ»Â¹ * z) * (yâ»Â¹ * z)â»Â¹) by group]\n        have : (xâ»Â¹ * z) * (yâ»Â¹ * z)â»Â¹ âˆˆ k * kâ»Â¹ := Set.mul_mem_mul ((mem_leftCoset_iff x).mp zx)\n          (Set.inv_mem_inv.mpr ((mem_leftCoset_iff y).mp zy))\n        exact mem_leftCoset x this\n      exact mem_biUnion xm this\n  rcases eq_empty_or_nonempty m with rfl|hm\n  Â· simp only [mem_empty_iff_false, iUnion_of_empty, iUnion_empty, subset_empty_iff] at sm\n    simp [sm]\n  by_cases h'm : Set.Countable m\n  Â· rcases h'm.exists_eq_range hm with âŸ¨f, rflâŸ©\n    have M i : MeasurableSet (disjointed (fun n â†¦ s âˆ© f n â€¢ (k * kâ»Â¹)) i) := by\n      apply MeasurableSet.disjointed (fun j â†¦ hs.inter ?_)\n      have : IsClosed (k â€¢ kâ»Â¹) := IsClosed.smul_left_of_isCompact k_closed.inv k_comp\n      exact (IsClosed.smul this (f j)).measurableSet\n    simp only [mem_range, iUnion_exists, iUnion_iUnion_eq'] at sm\n    have s_eq : s = â‹ƒ n, s âˆ© (f n â€¢ (k * kâ»Â¹)) := by rwa [â† inter_iUnion, eq_comm, inter_eq_left]\n    have I : Î¼' s = âˆ‘' n, Î¼' (disjointed (fun n â†¦ s âˆ© f n â€¢ (k * kâ»Â¹)) n) := by\n      rw [â† measure_iUnion (disjoint_disjointed _) M, iUnion_disjointed, â† s_eq]\n    have J : Î½ s = âˆ‘' n, Î½ (disjointed (fun n â†¦ s âˆ© f n â€¢ (k * kâ»Â¹)) n) := by\n      rw [â† measure_iUnion (disjoint_disjointed _) M, iUnion_disjointed, â† s_eq]\n    rw [I, J]\n    congr with n\n    apply measure_isMulInvariant_eq_smul_of_isCompact_closure\n    have : IsCompact (f n â€¢ (k * kâ»Â¹)) := IsCompact.smul (f n) (k_comp.mul k_comp.inv)\n    exact this.closure_of_subset <| (disjointed_subset _ _).trans inter_subset_right\n  Â· have H : âˆ€ (Ï : Measure G), IsEverywherePos Ï s â†’ Ï s = âˆ := by\n      intro Ï hÏ\n      have M : âˆ€ (i : â†‘m), MeasurableSet (s âˆ© (i : G) â€¢ k) :=\n        fun i â†¦ hs.inter (IsClosed.smul k_closed _).measurableSet\n      contrapose! h'm\n      have : âˆ‘' (x : m), Ï (s âˆ© ((x : G) â€¢ k)) < âˆ := by\n        apply lt_of_le_of_lt (MeasureTheory.tsum_meas_le_meas_iUnion_of_disjoint _ M _) _\n        Â· have I : PairwiseDisjoint m fun x â†¦ s âˆ© x â€¢ k :=\n            hdj.mono (fun x â†¦ inter_subset_right)\n          exact I.on_injective Subtype.val_injective (fun x â†¦ x.2)\n        Â· exact lt_of_le_of_lt (measure_mono (by simp [inter_subset_left])) h'm.lt_top\n      have C : Set.Countable (support fun (i : m) â†¦ Ï (s âˆ© (i : G) â€¢ k)) :=\n        Summable.countable_support_ennreal this.ne\n      have : support (fun (i : m) â†¦ Ï (s âˆ© (i : G) â€¢ k)) = univ := by\n        refine eq_univ_iff_forall.2 fun i â†¦ ?_\n        refine ne_of_gt (hÏ (i : G) (hms i.2) _ ?_)\n        exact inter_mem_nhdsWithin s (by simpa)\n      rw [this] at C\n      have : Countable m := countable_univ_iff.mp C\n      exact to_countable m\n    have HÎ½ : IsEverywherePos Î½ s :=\n      h's.smul_measure_nnreal (haarScalarFactor_pos_of_isHaarMeasure _ _).ne'\n    have HÎ¼' : IsEverywherePos Î¼' s := by\n      apply HÎ½.of_forall_exists_nhds_eq (fun x _hx â†¦ ?_)\n      obtain âŸ¨t, t_comp, t_memâŸ© : âˆƒ t, IsCompact t âˆ§ t âˆˆ ğ“ x := exists_compact_mem_nhds x\n      refine âŸ¨t, t_mem, fun u hu â†¦ ?_âŸ©\n      apply measure_isMulInvariant_eq_smul_of_isCompact_closure\n      exact t_comp.closure_of_subset hu\n    rw [H Î½ HÎ½, H Î¼' HÎ¼']\n\n"}
{"name":"MeasureTheory.Measure.measure_isAddHaarMeasure_eq_smul_of_isEverywherePos","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninstâœâ· : TopologicalSpace G\ninstâœâ¶ : AddGroup G\ninstâœâµ : TopologicalAddGroup G\ninstâœâ´ : MeasurableSpace G\ninstâœÂ³ : BorelSpace G\ninstâœÂ² : LocallyCompactSpace G\nÎ¼' Î¼ : MeasureTheory.Measure G\ninstâœÂ¹ : Î¼.IsAddHaarMeasure\ninstâœ : Î¼'.IsAddHaarMeasure\ns : Set G\nhs : MeasurableSet s\nh's : Î¼.IsEverywherePos s\nâŠ¢ Eq (Î¼' s) (HSMul.hSMul (Î¼'.addHaarScalarFactor Î¼) (Î¼ s))","decl":"@[to_additive measure_isAddHaarMeasure_eq_smul_of_isEverywherePos]\ntheorem measure_isHaarMeasure_eq_smul_of_isEverywherePos [LocallyCompactSpace G]\n    (Î¼' Î¼ : Measure G) [IsHaarMeasure Î¼] [IsHaarMeasure Î¼']\n    {s : Set G} (hs : MeasurableSet s) (h's : IsEverywherePos Î¼ s) :\n    Î¼' s = haarScalarFactor Î¼' Î¼ â€¢ Î¼ s := by\n  let Î½ := haarScalarFactor Î¼' Î¼ â€¢ Î¼\n  change Î¼' s = Î½ s\n  /- Fix a compact neighborhood `k` of the identity, and consider a maximal disjoint family `m` of\n  sets `x â€¢ k` centered at points in `s`. Then `s` is covered by the sets `x â€¢ (k * kâ»Â¹)` by\n  maximality. If the family is countable, then since `Î¼'` and `Î½` coincide in compact sets, and\n  the measure of a countable disjoint union is the sum of the measures, we get `Î¼' s = Î½ s`.\n  Otherwise, the family is uncountable, and each intersection with `s` has positive measure by\n  the everywhere positivity assumption, so `Î½ s = âˆ`, and `Î¼' s = âˆ` in the same way. -/\n  obtain âŸ¨k, k_comp, k_closed, k_memâŸ© : âˆƒ k, IsCompact k âˆ§ IsClosed k âˆ§ k âˆˆ ğ“ (1 : G) := by\n    rcases exists_compact_mem_nhds (1 : G) with âŸ¨k, hk, hmemâŸ©\n    exact âŸ¨closure k, hk.closure, isClosed_closure, mem_of_superset hmem subset_closureâŸ©\n  have one_k : 1 âˆˆ k := mem_of_mem_nhds k_mem\n  let A : Set (Set G) := {t | t âŠ† s âˆ§ PairwiseDisjoint t (fun x â†¦ x â€¢ k)}\n  obtain âŸ¨m, m_maxâŸ© : âˆƒ m, Maximal (Â· âˆˆ A) m := by\n    apply zorn_subset\n    intro c cA hc\n    refine âŸ¨â‹ƒ a âˆˆ c, a, âŸ¨?_, ?_âŸ©, ?_âŸ©\n    Â· simp only [iUnion_subset_iff]\n      intro a ac x hx\n      simp only [A, subset_def, mem_setOf_eq] at cA\n      exact (cA _ ac).1 x hx\n    Â· rintro x hx y hy hxy\n      simp only [mem_iUnion, exists_prop] at hx hy\n      rcases hx with âŸ¨a, ac, xaâŸ©\n      rcases hy with âŸ¨b, bc, ybâŸ©\n      obtain âŸ¨m, mc, am, bmâŸ© : âˆƒ m âˆˆ c, a âŠ† m âˆ§ b âŠ† m := hc.directedOn _ ac _ bc\n      exact (cA mc).2 (am xa) (bm yb) hxy\n    Â· intro a ac\n      exact subset_biUnion_of_mem (u := id) ac\n  obtain âŸ¨hms : m âŠ† s, hdj : PairwiseDisjoint m (fun x â†¦ x â€¢ k)âŸ© := m_max.prop\n  have sm : s âŠ† â‹ƒ x âˆˆ m, x â€¢ (k * kâ»Â¹) := by\n    intro y hy\n    by_cases h'y : m âˆª {y} âˆˆ A\n    Â· have ym : y âˆˆ m := m_max.mem_of_prop_insert (by simpa using h'y)\n      have : y âˆˆ y â€¢ (k * kâ»Â¹) := by\n        simpa using mem_leftCoset y (Set.mul_mem_mul one_k (Set.inv_mem_inv.mpr one_k))\n      exact mem_biUnion ym this\n    Â· obtain âŸ¨x, xm, -, z, zy, zxâŸ© : âˆƒ x âˆˆ m, y â‰  x âˆ§ âˆƒ z, z âˆˆ y â€¢ k âˆ§ z âˆˆ x â€¢ k := by\n        simpa [A, hms, hy, insert_subset_iff, pairwiseDisjoint_insert, hdj, not_disjoint_iff]\n          using h'y\n      have : y âˆˆ x â€¢ (k * kâ»Â¹) := by\n        rw [show y = x * ((xâ»Â¹ * z) * (yâ»Â¹ * z)â»Â¹) by group]\n        have : (xâ»Â¹ * z) * (yâ»Â¹ * z)â»Â¹ âˆˆ k * kâ»Â¹ := Set.mul_mem_mul ((mem_leftCoset_iff x).mp zx)\n          (Set.inv_mem_inv.mpr ((mem_leftCoset_iff y).mp zy))\n        exact mem_leftCoset x this\n      exact mem_biUnion xm this\n  rcases eq_empty_or_nonempty m with rfl|hm\n  Â· simp only [mem_empty_iff_false, iUnion_of_empty, iUnion_empty, subset_empty_iff] at sm\n    simp [sm]\n  by_cases h'm : Set.Countable m\n  Â· rcases h'm.exists_eq_range hm with âŸ¨f, rflâŸ©\n    have M i : MeasurableSet (disjointed (fun n â†¦ s âˆ© f n â€¢ (k * kâ»Â¹)) i) := by\n      apply MeasurableSet.disjointed (fun j â†¦ hs.inter ?_)\n      have : IsClosed (k â€¢ kâ»Â¹) := IsClosed.smul_left_of_isCompact k_closed.inv k_comp\n      exact (IsClosed.smul this (f j)).measurableSet\n    simp only [mem_range, iUnion_exists, iUnion_iUnion_eq'] at sm\n    have s_eq : s = â‹ƒ n, s âˆ© (f n â€¢ (k * kâ»Â¹)) := by rwa [â† inter_iUnion, eq_comm, inter_eq_left]\n    have I : Î¼' s = âˆ‘' n, Î¼' (disjointed (fun n â†¦ s âˆ© f n â€¢ (k * kâ»Â¹)) n) := by\n      rw [â† measure_iUnion (disjoint_disjointed _) M, iUnion_disjointed, â† s_eq]\n    have J : Î½ s = âˆ‘' n, Î½ (disjointed (fun n â†¦ s âˆ© f n â€¢ (k * kâ»Â¹)) n) := by\n      rw [â† measure_iUnion (disjoint_disjointed _) M, iUnion_disjointed, â† s_eq]\n    rw [I, J]\n    congr with n\n    apply measure_isMulInvariant_eq_smul_of_isCompact_closure\n    have : IsCompact (f n â€¢ (k * kâ»Â¹)) := IsCompact.smul (f n) (k_comp.mul k_comp.inv)\n    exact this.closure_of_subset <| (disjointed_subset _ _).trans inter_subset_right\n  Â· have H : âˆ€ (Ï : Measure G), IsEverywherePos Ï s â†’ Ï s = âˆ := by\n      intro Ï hÏ\n      have M : âˆ€ (i : â†‘m), MeasurableSet (s âˆ© (i : G) â€¢ k) :=\n        fun i â†¦ hs.inter (IsClosed.smul k_closed _).measurableSet\n      contrapose! h'm\n      have : âˆ‘' (x : m), Ï (s âˆ© ((x : G) â€¢ k)) < âˆ := by\n        apply lt_of_le_of_lt (MeasureTheory.tsum_meas_le_meas_iUnion_of_disjoint _ M _) _\n        Â· have I : PairwiseDisjoint m fun x â†¦ s âˆ© x â€¢ k :=\n            hdj.mono (fun x â†¦ inter_subset_right)\n          exact I.on_injective Subtype.val_injective (fun x â†¦ x.2)\n        Â· exact lt_of_le_of_lt (measure_mono (by simp [inter_subset_left])) h'm.lt_top\n      have C : Set.Countable (support fun (i : m) â†¦ Ï (s âˆ© (i : G) â€¢ k)) :=\n        Summable.countable_support_ennreal this.ne\n      have : support (fun (i : m) â†¦ Ï (s âˆ© (i : G) â€¢ k)) = univ := by\n        refine eq_univ_iff_forall.2 fun i â†¦ ?_\n        refine ne_of_gt (hÏ (i : G) (hms i.2) _ ?_)\n        exact inter_mem_nhdsWithin s (by simpa)\n      rw [this] at C\n      have : Countable m := countable_univ_iff.mp C\n      exact to_countable m\n    have HÎ½ : IsEverywherePos Î½ s :=\n      h's.smul_measure_nnreal (haarScalarFactor_pos_of_isHaarMeasure _ _).ne'\n    have HÎ¼' : IsEverywherePos Î¼' s := by\n      apply HÎ½.of_forall_exists_nhds_eq (fun x _hx â†¦ ?_)\n      obtain âŸ¨t, t_comp, t_memâŸ© : âˆƒ t, IsCompact t âˆ§ t âˆˆ ğ“ x := exists_compact_mem_nhds x\n      refine âŸ¨t, t_mem, fun u hu â†¦ ?_âŸ©\n      apply measure_isMulInvariant_eq_smul_of_isCompact_closure\n      exact t_comp.closure_of_subset hu\n    rw [H Î½ HÎ½, H Î¼' HÎ¼']\n\n"}
{"name":"MeasureTheory.Measure.measure_isAddHaarMeasure_eq_smul_of_isOpen","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninstâœâ· : TopologicalSpace G\ninstâœâ¶ : AddGroup G\ninstâœâµ : TopologicalAddGroup G\ninstâœâ´ : MeasurableSpace G\ninstâœÂ³ : BorelSpace G\ninstâœÂ² : LocallyCompactSpace G\nÎ¼' Î¼ : MeasureTheory.Measure G\ninstâœÂ¹ : Î¼.IsAddHaarMeasure\ninstâœ : Î¼'.IsAddHaarMeasure\ns : Set G\nhs : IsOpen s\nâŠ¢ Eq (Î¼' s) (HSMul.hSMul (Î¼'.addHaarScalarFactor Î¼) (Î¼ s))","decl":"/-- **Uniqueness of Haar measures**:\nGiven two Haar measures, they coincide in the following sense: they give the same value to open\nsets, up to the multiplicative constant `haarScalarFactor Î¼' Î¼`. -/\n@[to_additive measure_isAddHaarMeasure_eq_smul_of_isOpen\n\"**Uniqueness of Haar measures**:\nGiven two additive Haar measures, they coincide in the following sense: they give the same value to\nopen sets, up to the multiplicative constant `addHaarScalarFactor Î¼' Î¼`.\"]\ntheorem measure_isHaarMeasure_eq_smul_of_isOpen [LocallyCompactSpace G]\n    (Î¼' Î¼ : Measure G) [IsHaarMeasure Î¼] [IsHaarMeasure Î¼'] {s : Set G} (hs : IsOpen s) :\n    Î¼' s = haarScalarFactor Î¼' Î¼ â€¢ Î¼ s :=\n  measure_isHaarMeasure_eq_smul_of_isEverywherePos Î¼' Î¼ hs.measurableSet hs.isEverywherePos\n\n"}
{"name":"MeasureTheory.Measure.measure_isHaarMeasure_eq_smul_of_isOpen","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninstâœâ· : TopologicalSpace G\ninstâœâ¶ : Group G\ninstâœâµ : TopologicalGroup G\ninstâœâ´ : MeasurableSpace G\ninstâœÂ³ : BorelSpace G\ninstâœÂ² : LocallyCompactSpace G\nÎ¼' Î¼ : MeasureTheory.Measure G\ninstâœÂ¹ : Î¼.IsHaarMeasure\ninstâœ : Î¼'.IsHaarMeasure\ns : Set G\nhs : IsOpen s\nâŠ¢ Eq (Î¼' s) (HSMul.hSMul (Î¼'.haarScalarFactor Î¼) (Î¼ s))","decl":"/-- **Uniqueness of Haar measures**:\nGiven two Haar measures, they coincide in the following sense: they give the same value to open\nsets, up to the multiplicative constant `haarScalarFactor Î¼' Î¼`. -/\n@[to_additive measure_isAddHaarMeasure_eq_smul_of_isOpen\n\"**Uniqueness of Haar measures**:\nGiven two additive Haar measures, they coincide in the following sense: they give the same value to\nopen sets, up to the multiplicative constant `addHaarScalarFactor Î¼' Î¼`.\"]\ntheorem measure_isHaarMeasure_eq_smul_of_isOpen [LocallyCompactSpace G]\n    (Î¼' Î¼ : Measure G) [IsHaarMeasure Î¼] [IsHaarMeasure Î¼'] {s : Set G} (hs : IsOpen s) :\n    Î¼' s = haarScalarFactor Î¼' Î¼ â€¢ Î¼ s :=\n  measure_isHaarMeasure_eq_smul_of_isEverywherePos Î¼' Î¼ hs.measurableSet hs.isEverywherePos\n\n"}
{"name":"MeasureTheory.Measure.measure_isMulLeftInvariant_eq_smul_of_ne_top","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninstâœÂ¹â° : TopologicalSpace G\ninstâœâ¹ : Group G\ninstâœâ¸ : TopologicalGroup G\ninstâœâ· : MeasurableSpace G\ninstâœâ¶ : BorelSpace G\ninstâœâµ : LocallyCompactSpace G\nÎ¼' Î¼ : MeasureTheory.Measure G\ninstâœâ´ : Î¼.IsHaarMeasure\ninstâœÂ³ : MeasureTheory.IsFiniteMeasureOnCompacts Î¼'\ninstâœÂ² : Î¼'.IsMulLeftInvariant\ninstâœÂ¹ : Î¼.InnerRegularCompactLTTop\ninstâœ : Î¼'.InnerRegularCompactLTTop\ns : Set G\nhs : Ne (Î¼ s) Top.top\nh's : Ne (Î¼' s) Top.top\nâŠ¢ Eq (Î¼' s) (HSMul.hSMul (Î¼'.haarScalarFactor Î¼) (Î¼ s))","decl":"/-- **Uniqueness of left-invariant measures**:\nGiven two left-invariant measures which are finite on\ncompacts and inner regular for finite measure sets with respect to compact sets,\nthey coincide in the following sense: they give the same value to finite measure sets,\nup to a multiplicative constant. -/\n@[to_additive]\nlemma measure_isMulLeftInvariant_eq_smul_of_ne_top [LocallyCompactSpace G]\n    (Î¼' Î¼ : Measure G) [IsHaarMeasure Î¼] [IsFiniteMeasureOnCompacts Î¼'] [IsMulLeftInvariant Î¼']\n    [InnerRegularCompactLTTop Î¼] [InnerRegularCompactLTTop Î¼'] {s : Set G}\n    (hs : Î¼ s â‰  âˆ) (h's : Î¼' s â‰  âˆ) : Î¼' s = haarScalarFactor Î¼' Î¼ â€¢ Î¼ s := by\n  /- We know that the measures integrate in the same way continuous compactly supported functions,\n  up to the factor `c = haarScalarFactor Î¼' Î¼`. -/\n  let c := haarScalarFactor Î¼' Î¼\n  /- By regularity, every measurable set of finite measure may be approximated by compact sets.\n  Therefore, the measures coincide on measurable sets of finite measure. -/\n  have B : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ Î¼' s < âˆ â†’ Î¼' s = (c â€¢ Î¼) s := by\n    intro s s_meas hs h's\n    have : (c â€¢ Î¼) s â‰  âˆ := by simp [ENNReal.mul_eq_top, hs.ne]\n    rw [s_meas.measure_eq_iSup_isCompact_of_ne_top h's.ne,\n        s_meas.measure_eq_iSup_isCompact_of_ne_top this]\n    congr! 4 with K _Ks K_comp\n    exact measure_isMulInvariant_eq_smul_of_isCompact_closure Î¼' Î¼ K_comp.closure\n  /- Finally, replace an arbitrary finite measure set with a measurable version, and use the\n  version for measurable sets. -/\n  let t := toMeasurable Î¼' s âˆ© toMeasurable Î¼ s\n  have st : s âŠ† t := subset_inter (subset_toMeasurable Î¼' s) (subset_toMeasurable Î¼ s)\n  have mu'_t : Î¼' t = Î¼' s := by\n    apply le_antisymm\n    Â· exact (measure_mono inter_subset_left).trans (measure_toMeasurable s).le\n    Â· exact measure_mono st\n  have mu_t : Î¼ t = Î¼ s := by\n    apply le_antisymm\n    Â· exact (measure_mono inter_subset_right).trans (measure_toMeasurable s).le\n    Â· exact measure_mono st\n  simp only [â† mu'_t, smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, â† mu_t,\n    nnreal_smul_coe_apply]\n  apply B\n  Â· exact (measurableSet_toMeasurable _ _).inter (measurableSet_toMeasurable _ _)\n  Â· exact mu_t.le.trans_lt hs.lt_top\n  Â· exact mu'_t.le.trans_lt h's.lt_top\n\n"}
{"name":"MeasureTheory.Measure.measure_isAddLeftInvariant_eq_vadd_of_ne_top","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninstâœÂ¹â° : TopologicalSpace G\ninstâœâ¹ : AddGroup G\ninstâœâ¸ : TopologicalAddGroup G\ninstâœâ· : MeasurableSpace G\ninstâœâ¶ : BorelSpace G\ninstâœâµ : LocallyCompactSpace G\nÎ¼' Î¼ : MeasureTheory.Measure G\ninstâœâ´ : Î¼.IsAddHaarMeasure\ninstâœÂ³ : MeasureTheory.IsFiniteMeasureOnCompacts Î¼'\ninstâœÂ² : Î¼'.IsAddLeftInvariant\ninstâœÂ¹ : Î¼.InnerRegularCompactLTTop\ninstâœ : Î¼'.InnerRegularCompactLTTop\ns : Set G\nhs : Ne (Î¼ s) Top.top\nh's : Ne (Î¼' s) Top.top\nâŠ¢ Eq (Î¼' s) (HSMul.hSMul (Î¼'.addHaarScalarFactor Î¼) (Î¼ s))","decl":"/-- **Uniqueness of left-invariant measures**:\nGiven two left-invariant measures which are finite on\ncompacts and inner regular for finite measure sets with respect to compact sets,\nthey coincide in the following sense: they give the same value to finite measure sets,\nup to a multiplicative constant. -/\n@[to_additive]\nlemma measure_isMulLeftInvariant_eq_smul_of_ne_top [LocallyCompactSpace G]\n    (Î¼' Î¼ : Measure G) [IsHaarMeasure Î¼] [IsFiniteMeasureOnCompacts Î¼'] [IsMulLeftInvariant Î¼']\n    [InnerRegularCompactLTTop Î¼] [InnerRegularCompactLTTop Î¼'] {s : Set G}\n    (hs : Î¼ s â‰  âˆ) (h's : Î¼' s â‰  âˆ) : Î¼' s = haarScalarFactor Î¼' Î¼ â€¢ Î¼ s := by\n  /- We know that the measures integrate in the same way continuous compactly supported functions,\n  up to the factor `c = haarScalarFactor Î¼' Î¼`. -/\n  let c := haarScalarFactor Î¼' Î¼\n  /- By regularity, every measurable set of finite measure may be approximated by compact sets.\n  Therefore, the measures coincide on measurable sets of finite measure. -/\n  have B : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ Î¼' s < âˆ â†’ Î¼' s = (c â€¢ Î¼) s := by\n    intro s s_meas hs h's\n    have : (c â€¢ Î¼) s â‰  âˆ := by simp [ENNReal.mul_eq_top, hs.ne]\n    rw [s_meas.measure_eq_iSup_isCompact_of_ne_top h's.ne,\n        s_meas.measure_eq_iSup_isCompact_of_ne_top this]\n    congr! 4 with K _Ks K_comp\n    exact measure_isMulInvariant_eq_smul_of_isCompact_closure Î¼' Î¼ K_comp.closure\n  /- Finally, replace an arbitrary finite measure set with a measurable version, and use the\n  version for measurable sets. -/\n  let t := toMeasurable Î¼' s âˆ© toMeasurable Î¼ s\n  have st : s âŠ† t := subset_inter (subset_toMeasurable Î¼' s) (subset_toMeasurable Î¼ s)\n  have mu'_t : Î¼' t = Î¼' s := by\n    apply le_antisymm\n    Â· exact (measure_mono inter_subset_left).trans (measure_toMeasurable s).le\n    Â· exact measure_mono st\n  have mu_t : Î¼ t = Î¼ s := by\n    apply le_antisymm\n    Â· exact (measure_mono inter_subset_right).trans (measure_toMeasurable s).le\n    Â· exact measure_mono st\n  simp only [â† mu'_t, smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, â† mu_t,\n    nnreal_smul_coe_apply]\n  apply B\n  Â· exact (measurableSet_toMeasurable _ _).inter (measurableSet_toMeasurable _ _)\n  Â· exact mu_t.le.trans_lt hs.lt_top\n  Â· exact mu'_t.le.trans_lt h's.lt_top\n\n"}
{"name":"MeasureTheory.Measure.isMulLeftInvariant_eq_smul_of_innerRegular","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninstâœÂ¹â° : TopologicalSpace G\ninstâœâ¹ : Group G\ninstâœâ¸ : TopologicalGroup G\ninstâœâ· : MeasurableSpace G\ninstâœâ¶ : BorelSpace G\ninstâœâµ : LocallyCompactSpace G\nÎ¼' Î¼ : MeasureTheory.Measure G\ninstâœâ´ : Î¼.IsHaarMeasure\ninstâœÂ³ : MeasureTheory.IsFiniteMeasureOnCompacts Î¼'\ninstâœÂ² : Î¼'.IsMulLeftInvariant\ninstâœÂ¹ : Î¼.InnerRegular\ninstâœ : Î¼'.InnerRegular\nâŠ¢ Eq Î¼' (HSMul.hSMul (Î¼'.haarScalarFactor Î¼) Î¼)","decl":"/-- **Uniqueness of left-invariant measures**:\nGiven two left-invariant measures which are finite\non compacts and inner regular, they coincide up to a multiplicative constant. -/\n@[to_additive isAddLeftInvariant_eq_smul_of_innerRegular]\nlemma isMulLeftInvariant_eq_smul_of_innerRegular [LocallyCompactSpace G]\n    (Î¼' Î¼ : Measure G) [IsHaarMeasure Î¼] [IsFiniteMeasureOnCompacts Î¼'] [IsMulLeftInvariant Î¼']\n    [InnerRegular Î¼] [InnerRegular Î¼'] :\n    Î¼' = haarScalarFactor Î¼' Î¼ â€¢ Î¼ := by\n  ext s hs\n  rw [hs.measure_eq_iSup_isCompact, hs.measure_eq_iSup_isCompact]\n  congr! 4 with K _Ks K_comp\n  exact measure_isMulLeftInvariant_eq_smul_of_ne_top Î¼' Î¼ K_comp.measure_lt_top.ne\n    K_comp.measure_lt_top.ne\n\n"}
{"name":"MeasureTheory.Measure.isAddLeftInvariant_eq_smul_of_innerRegular","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninstâœÂ¹â° : TopologicalSpace G\ninstâœâ¹ : AddGroup G\ninstâœâ¸ : TopologicalAddGroup G\ninstâœâ· : MeasurableSpace G\ninstâœâ¶ : BorelSpace G\ninstâœâµ : LocallyCompactSpace G\nÎ¼' Î¼ : MeasureTheory.Measure G\ninstâœâ´ : Î¼.IsAddHaarMeasure\ninstâœÂ³ : MeasureTheory.IsFiniteMeasureOnCompacts Î¼'\ninstâœÂ² : Î¼'.IsAddLeftInvariant\ninstâœÂ¹ : Î¼.InnerRegular\ninstâœ : Î¼'.InnerRegular\nâŠ¢ Eq Î¼' (HSMul.hSMul (Î¼'.addHaarScalarFactor Î¼) Î¼)","decl":"/-- **Uniqueness of left-invariant measures**:\nGiven two left-invariant measures which are finite\non compacts and inner regular, they coincide up to a multiplicative constant. -/\n@[to_additive isAddLeftInvariant_eq_smul_of_innerRegular]\nlemma isMulLeftInvariant_eq_smul_of_innerRegular [LocallyCompactSpace G]\n    (Î¼' Î¼ : Measure G) [IsHaarMeasure Î¼] [IsFiniteMeasureOnCompacts Î¼'] [IsMulLeftInvariant Î¼']\n    [InnerRegular Î¼] [InnerRegular Î¼'] :\n    Î¼' = haarScalarFactor Î¼' Î¼ â€¢ Î¼ := by\n  ext s hs\n  rw [hs.measure_eq_iSup_isCompact, hs.measure_eq_iSup_isCompact]\n  congr! 4 with K _Ks K_comp\n  exact measure_isMulLeftInvariant_eq_smul_of_ne_top Î¼' Î¼ K_comp.measure_lt_top.ne\n    K_comp.measure_lt_top.ne\n\n"}
{"name":"MeasureTheory.Measure.isAddLeftInvariant_eq_smul_of_regular","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninstâœÂ¹â° : TopologicalSpace G\ninstâœâ¹ : AddGroup G\ninstâœâ¸ : TopologicalAddGroup G\ninstâœâ· : MeasurableSpace G\ninstâœâ¶ : BorelSpace G\ninstâœâµ : LocallyCompactSpace G\nÎ¼' Î¼ : MeasureTheory.Measure G\ninstâœâ´ : Î¼.IsAddHaarMeasure\ninstâœÂ³ : MeasureTheory.IsFiniteMeasureOnCompacts Î¼'\ninstâœÂ² : Î¼'.IsAddLeftInvariant\ninstâœÂ¹ : Î¼.Regular\ninstâœ : Î¼'.Regular\nâŠ¢ Eq Î¼' (HSMul.hSMul (Î¼'.addHaarScalarFactor Î¼) Î¼)","decl":"/-- **Uniqueness of left-invariant measures**:\nGiven two left-invariant measures which are finite\non compacts and regular, they coincide up to a multiplicative constant. -/\n@[to_additive isAddLeftInvariant_eq_smul_of_regular]\nlemma isMulLeftInvariant_eq_smul_of_regular [LocallyCompactSpace G]\n    (Î¼' Î¼ : Measure G) [IsHaarMeasure Î¼] [IsFiniteMeasureOnCompacts Î¼'] [IsMulLeftInvariant Î¼']\n    [Regular Î¼] [Regular Î¼'] :\n    Î¼' = haarScalarFactor Î¼' Î¼ â€¢ Î¼ := by\n  have A : âˆ€ U, IsOpen U â†’ Î¼' U = (haarScalarFactor Î¼' Î¼ â€¢ Î¼) U := by\n    intro U hU\n    rw [hU.measure_eq_iSup_isCompact, hU.measure_eq_iSup_isCompact]\n    congr! 4 with K _KU K_comp\n    exact measure_isMulLeftInvariant_eq_smul_of_ne_top Î¼' Î¼ K_comp.measure_lt_top.ne\n      K_comp.measure_lt_top.ne\n  ext s _hs\n  rw [s.measure_eq_iInf_isOpen, s.measure_eq_iInf_isOpen]\n  congr! 4 with U _sU U_open\n  exact A U U_open\n\n"}
{"name":"MeasureTheory.Measure.isMulLeftInvariant_eq_smul_of_regular","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninstâœÂ¹â° : TopologicalSpace G\ninstâœâ¹ : Group G\ninstâœâ¸ : TopologicalGroup G\ninstâœâ· : MeasurableSpace G\ninstâœâ¶ : BorelSpace G\ninstâœâµ : LocallyCompactSpace G\nÎ¼' Î¼ : MeasureTheory.Measure G\ninstâœâ´ : Î¼.IsHaarMeasure\ninstâœÂ³ : MeasureTheory.IsFiniteMeasureOnCompacts Î¼'\ninstâœÂ² : Î¼'.IsMulLeftInvariant\ninstâœÂ¹ : Î¼.Regular\ninstâœ : Î¼'.Regular\nâŠ¢ Eq Î¼' (HSMul.hSMul (Î¼'.haarScalarFactor Î¼) Î¼)","decl":"/-- **Uniqueness of left-invariant measures**:\nGiven two left-invariant measures which are finite\non compacts and regular, they coincide up to a multiplicative constant. -/\n@[to_additive isAddLeftInvariant_eq_smul_of_regular]\nlemma isMulLeftInvariant_eq_smul_of_regular [LocallyCompactSpace G]\n    (Î¼' Î¼ : Measure G) [IsHaarMeasure Î¼] [IsFiniteMeasureOnCompacts Î¼'] [IsMulLeftInvariant Î¼']\n    [Regular Î¼] [Regular Î¼'] :\n    Î¼' = haarScalarFactor Î¼' Î¼ â€¢ Î¼ := by\n  have A : âˆ€ U, IsOpen U â†’ Î¼' U = (haarScalarFactor Î¼' Î¼ â€¢ Î¼) U := by\n    intro U hU\n    rw [hU.measure_eq_iSup_isCompact, hU.measure_eq_iSup_isCompact]\n    congr! 4 with K _KU K_comp\n    exact measure_isMulLeftInvariant_eq_smul_of_ne_top Î¼' Î¼ K_comp.measure_lt_top.ne\n      K_comp.measure_lt_top.ne\n  ext s _hs\n  rw [s.measure_eq_iInf_isOpen, s.measure_eq_iInf_isOpen]\n  congr! 4 with U _sU U_open\n  exact A U U_open\n\n"}
{"name":"MeasureTheory.Measure.isAddLeftInvariant_eq_smul","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninstâœâ¹ : TopologicalSpace G\ninstâœâ¸ : AddGroup G\ninstâœâ· : TopologicalAddGroup G\ninstâœâ¶ : MeasurableSpace G\ninstâœâµ : BorelSpace G\ninstâœâ´ : LocallyCompactSpace G\ninstâœÂ³ : SecondCountableTopology G\nÎ¼' Î¼ : MeasureTheory.Measure G\ninstâœÂ² : Î¼.IsAddHaarMeasure\ninstâœÂ¹ : MeasureTheory.IsFiniteMeasureOnCompacts Î¼'\ninstâœ : Î¼'.IsAddLeftInvariant\nâŠ¢ Eq Î¼' (HSMul.hSMul (Î¼'.addHaarScalarFactor Î¼) Î¼)","decl":"/-- **Uniqueness of left-invariant measures**:\nTwo Haar measures coincide up to a multiplicative constant in a second countable group. -/\n@[to_additive isAddLeftInvariant_eq_smul]\nlemma isMulLeftInvariant_eq_smul [LocallyCompactSpace G] [SecondCountableTopology G]\n    (Î¼' Î¼ : Measure G) [IsHaarMeasure Î¼] [IsFiniteMeasureOnCompacts Î¼'] [IsMulLeftInvariant Î¼'] :\n    Î¼' = haarScalarFactor Î¼' Î¼ â€¢ Î¼ :=\n  isMulLeftInvariant_eq_smul_of_regular Î¼' Î¼\n  -- one could use as well `isMulLeftInvariant_eq_smul_of_innerRegular`, as in a\n  -- second countable topological space all Haar measures are regular and inner regular\n\n\n"}
{"name":"MeasureTheory.Measure.isMulLeftInvariant_eq_smul","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninstâœâ¹ : TopologicalSpace G\ninstâœâ¸ : Group G\ninstâœâ· : TopologicalGroup G\ninstâœâ¶ : MeasurableSpace G\ninstâœâµ : BorelSpace G\ninstâœâ´ : LocallyCompactSpace G\ninstâœÂ³ : SecondCountableTopology G\nÎ¼' Î¼ : MeasureTheory.Measure G\ninstâœÂ² : Î¼.IsHaarMeasure\ninstâœÂ¹ : MeasureTheory.IsFiniteMeasureOnCompacts Î¼'\ninstâœ : Î¼'.IsMulLeftInvariant\nâŠ¢ Eq Î¼' (HSMul.hSMul (Î¼'.haarScalarFactor Î¼) Î¼)","decl":"/-- **Uniqueness of left-invariant measures**:\nTwo Haar measures coincide up to a multiplicative constant in a second countable group. -/\n@[to_additive isAddLeftInvariant_eq_smul]\nlemma isMulLeftInvariant_eq_smul [LocallyCompactSpace G] [SecondCountableTopology G]\n    (Î¼' Î¼ : Measure G) [IsHaarMeasure Î¼] [IsFiniteMeasureOnCompacts Î¼'] [IsMulLeftInvariant Î¼'] :\n    Î¼' = haarScalarFactor Î¼' Î¼ â€¢ Î¼ :=\n  isMulLeftInvariant_eq_smul_of_regular Î¼' Î¼\n  -- one could use as well `isMulLeftInvariant_eq_smul_of_innerRegular`, as in a\n  -- second countable topological space all Haar measures are regular and inner regular\n\n\n"}
{"name":"MeasureTheory.Measure.absolutelyContinuous_isHaarMeasure","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninstâœâ¹ : TopologicalSpace G\ninstâœâ¸ : Group G\ninstâœâ· : TopologicalGroup G\ninstâœâ¶ : MeasurableSpace G\ninstâœâµ : BorelSpace G\ninstâœâ´ : LocallyCompactSpace G\ninstâœÂ³ : SecondCountableTopology G\nÎ¼ Î½ : MeasureTheory.Measure G\ninstâœÂ² : MeasureTheory.SigmaFinite Î¼\ninstâœÂ¹ : Î¼.IsMulLeftInvariant\ninstâœ : Î½.IsHaarMeasure\nâŠ¢ Î¼.AbsolutelyContinuous Î½","decl":"/-- An invariant Ïƒ-finite measure is absolutely continuous with respect to a Haar measure in a\nsecond countable group. -/\n@[to_additive\n\"An invariant measure is absolutely continuous with respect to an additive Haar measure. \"]\ntheorem absolutelyContinuous_isHaarMeasure [LocallyCompactSpace G]\n    [SecondCountableTopology G] (Î¼ Î½ : Measure G)\n    [SigmaFinite Î¼] [IsMulLeftInvariant Î¼] [IsHaarMeasure Î½] : Î¼ â‰ª Î½ := by\n  have K : PositiveCompacts G := Classical.arbitrary _\n  have h : haarMeasure K = (haarScalarFactor (haarMeasure K) Î½ : â„â‰¥0âˆ) â€¢ Î½ :=\n    isMulLeftInvariant_eq_smul (haarMeasure K) Î½\n  rw [haarMeasure_unique Î¼ K, h, smul_smul]\n  exact smul_absolutelyContinuous\n\n"}
{"name":"MeasureTheory.Measure.absolutelyContinuous_isAddHaarMeasure","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninstâœâ¹ : TopologicalSpace G\ninstâœâ¸ : AddGroup G\ninstâœâ· : TopologicalAddGroup G\ninstâœâ¶ : MeasurableSpace G\ninstâœâµ : BorelSpace G\ninstâœâ´ : LocallyCompactSpace G\ninstâœÂ³ : SecondCountableTopology G\nÎ¼ Î½ : MeasureTheory.Measure G\ninstâœÂ² : MeasureTheory.SigmaFinite Î¼\ninstâœÂ¹ : Î¼.IsAddLeftInvariant\ninstâœ : Î½.IsAddHaarMeasure\nâŠ¢ Î¼.AbsolutelyContinuous Î½","decl":"/-- An invariant Ïƒ-finite measure is absolutely continuous with respect to a Haar measure in a\nsecond countable group. -/\n@[to_additive\n\"An invariant measure is absolutely continuous with respect to an additive Haar measure. \"]\ntheorem absolutelyContinuous_isHaarMeasure [LocallyCompactSpace G]\n    [SecondCountableTopology G] (Î¼ Î½ : Measure G)\n    [SigmaFinite Î¼] [IsMulLeftInvariant Î¼] [IsHaarMeasure Î½] : Î¼ â‰ª Î½ := by\n  have K : PositiveCompacts G := Classical.arbitrary _\n  have h : haarMeasure K = (haarScalarFactor (haarMeasure K) Î½ : â„â‰¥0âˆ) â€¢ Î½ :=\n    isMulLeftInvariant_eq_smul (haarMeasure K) Î½\n  rw [haarMeasure_unique Î¼ K, h, smul_smul]\n  exact smul_absolutelyContinuous\n\n"}
{"name":"AddMonoidHom.measurePreserving","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninstâœÂ¹Â² : TopologicalSpace G\ninstâœÂ¹Â¹ : AddGroup G\ninstâœÂ¹â° : TopologicalAddGroup G\ninstâœâ¹ : MeasurableSpace G\ninstâœâ¸ : BorelSpace G\nH : Type u_2\ninstâœâ· : AddGroup H\ninstâœâ¶ : TopologicalSpace H\ninstâœâµ : TopologicalAddGroup H\ninstâœâ´ : CompactSpace H\ninstâœÂ³ : MeasurableSpace H\ninstâœÂ² : BorelSpace H\nÎ¼ : MeasureTheory.Measure G\ninstâœÂ¹ : Î¼.IsAddHaarMeasure\nÎ½ : MeasureTheory.Measure H\ninstâœ : Î½.IsAddHaarMeasure\nf : AddMonoidHom G H\nhcont : Continuous â‡‘f\nhsurj : Function.Surjective â‡‘f\nhuniv : Eq (Î¼ Set.univ) (Î½ Set.univ)\nâŠ¢ MeasureTheory.MeasurePreserving (â‡‘f) Î¼ Î½","decl":"/-- A continuous surjective monoid homomorphism of topological groups with compact codomain\nis measure preserving, provided that the Haar measures on the domain and on the codomain\nhave the same total mass.\n-/\n@[to_additive\n  \"A continuous surjective additive monoid homomorphism of topological groups with compact codomain\nis measure preserving, provided that the Haar measures on the domain and on the codomain\nhave the same total mass.\"]\ntheorem _root_.MonoidHom.measurePreserving\n    {H : Type*} [Group H] [TopologicalSpace H] [TopologicalGroup H] [CompactSpace H]\n    [MeasurableSpace H] [BorelSpace H]\n    {Î¼ : Measure G} [IsHaarMeasure Î¼] {Î½ : Measure H} [IsHaarMeasure Î½]\n    {f : G â†’* H} (hcont : Continuous f) (hsurj : Surjective f) (huniv : Î¼ univ = Î½ univ) :\n    MeasurePreserving f Î¼ Î½ where\n  measurable := hcont.measurable\n  map_eq := by\n    have : IsFiniteMeasure Î¼ := âŸ¨by rw [huniv]; apply measure_lt_topâŸ©\n    have : (Î¼.map f).IsHaarMeasure := isHaarMeasure_map_of_isFiniteMeasure Î¼ f hcont hsurj\n    set C : â„â‰¥0 := haarScalarFactor (Î¼.map f) Î½\n    have hC : Î¼.map f = C â€¢ Î½ := isMulLeftInvariant_eq_smul_of_innerRegular _ _\n    suffices C = 1 by rwa [this, one_smul] at hC\n    have : C * Î½ univ = 1 * Î½ univ := by\n      rw [one_mul, â† smul_eq_mul, â† ENNReal.smul_def, â† smul_apply, â† hC,\n        map_apply hcont.measurable .univ, preimage_univ, huniv]\n    rwa [ENNReal.mul_left_inj (NeZero.ne _) (measure_ne_top _ _), ENNReal.coe_eq_one] at this\n\n"}
{"name":"MonoidHom.measurePreserving","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninstâœÂ¹Â² : TopologicalSpace G\ninstâœÂ¹Â¹ : Group G\ninstâœÂ¹â° : TopologicalGroup G\ninstâœâ¹ : MeasurableSpace G\ninstâœâ¸ : BorelSpace G\nH : Type u_2\ninstâœâ· : Group H\ninstâœâ¶ : TopologicalSpace H\ninstâœâµ : TopologicalGroup H\ninstâœâ´ : CompactSpace H\ninstâœÂ³ : MeasurableSpace H\ninstâœÂ² : BorelSpace H\nÎ¼ : MeasureTheory.Measure G\ninstâœÂ¹ : Î¼.IsHaarMeasure\nÎ½ : MeasureTheory.Measure H\ninstâœ : Î½.IsHaarMeasure\nf : MonoidHom G H\nhcont : Continuous â‡‘f\nhsurj : Function.Surjective â‡‘f\nhuniv : Eq (Î¼ Set.univ) (Î½ Set.univ)\nâŠ¢ MeasureTheory.MeasurePreserving (â‡‘f) Î¼ Î½","decl":"/-- A continuous surjective monoid homomorphism of topological groups with compact codomain\nis measure preserving, provided that the Haar measures on the domain and on the codomain\nhave the same total mass.\n-/\n@[to_additive\n  \"A continuous surjective additive monoid homomorphism of topological groups with compact codomain\nis measure preserving, provided that the Haar measures on the domain and on the codomain\nhave the same total mass.\"]\ntheorem _root_.MonoidHom.measurePreserving\n    {H : Type*} [Group H] [TopologicalSpace H] [TopologicalGroup H] [CompactSpace H]\n    [MeasurableSpace H] [BorelSpace H]\n    {Î¼ : Measure G} [IsHaarMeasure Î¼] {Î½ : Measure H} [IsHaarMeasure Î½]\n    {f : G â†’* H} (hcont : Continuous f) (hsurj : Surjective f) (huniv : Î¼ univ = Î½ univ) :\n    MeasurePreserving f Î¼ Î½ where\n  measurable := hcont.measurable\n  map_eq := by\n    have : IsFiniteMeasure Î¼ := âŸ¨by rw [huniv]; apply measure_lt_topâŸ©\n    have : (Î¼.map f).IsHaarMeasure := isHaarMeasure_map_of_isFiniteMeasure Î¼ f hcont hsurj\n    set C : â„â‰¥0 := haarScalarFactor (Î¼.map f) Î½\n    have hC : Î¼.map f = C â€¢ Î½ := isMulLeftInvariant_eq_smul_of_innerRegular _ _\n    suffices C = 1 by rwa [this, one_smul] at hC\n    have : C * Î½ univ = 1 * Î½ univ := by\n      rw [one_mul, â† smul_eq_mul, â† ENNReal.smul_def, â† smul_apply, â† hC,\n        map_apply hcont.measurable .univ, preimage_univ, huniv]\n    rwa [ENNReal.mul_left_inj (NeZero.ne _) (measure_ne_top _ _), ENNReal.coe_eq_one] at this\n\n"}
{"name":"MeasureTheory.Measure.IsAddHaarMeasure.isNegInvariant_of_regular","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninstâœâ´ : AddCommGroup G\ninstâœÂ³ : TopologicalSpace G\ninstâœÂ² : MeasurableSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœÂ¹ : LocallyCompactSpace G\ninstâœ : Î¼.Regular\nâŠ¢ Î¼.IsNegInvariant","decl":"/-- Any regular Haar measure is invariant under inversion in an abelian group. -/\n@[to_additive \"Any regular additive Haar measure is invariant under negation in an abelian group.\"]\ninstance (priority := 100) IsHaarMeasure.isInvInvariant_of_regular\n    [LocallyCompactSpace G] [Regular Î¼] : IsInvInvariant Î¼ := by\n  -- the image measure is a Haar measure. By uniqueness up to multiplication, it is of the form\n  -- `c Î¼`. Applying again inversion, one gets the measure `c^2 Î¼`. But since inversion is an\n  -- involution, this is also `Î¼`. Hence, `c^2 = 1`, which implies `c = 1`.\n  constructor\n  let c : â„â‰¥0âˆ := haarScalarFactor Î¼.inv Î¼\n  have hc : Î¼.inv = c â€¢ Î¼ := isMulLeftInvariant_eq_smul_of_regular Î¼.inv Î¼\n  have : map Inv.inv (map Inv.inv Î¼) = c ^ 2 â€¢ Î¼ := by\n    rw [â† inv_def Î¼, hc, Measure.map_smul, â† inv_def Î¼, hc, smul_smul, pow_two]\n  have Î¼eq : Î¼ = c ^ 2 â€¢ Î¼ := by\n    rw [map_map continuous_inv.measurable continuous_inv.measurable] at this\n    simpa only [inv_involutive, Involutive.comp_self, Measure.map_id]\n  have K : PositiveCompacts G := Classical.arbitrary _\n  have : c ^ 2 * Î¼ K = 1 ^ 2 * Î¼ K := by\n    conv_rhs => rw [Î¼eq]\n    simp\n  have : c ^ 2 = 1 ^ 2 :=\n    (ENNReal.mul_left_inj (measure_pos_of_nonempty_interior _ K.interior_nonempty).ne'\n          K.isCompact.measure_lt_top.ne).1 this\n  have : c = 1 := (ENNReal.pow_right_strictMono two_ne_zero).injective this\n  rw [hc, this, one_smul]\n\n"}
{"name":"MeasureTheory.Measure.IsHaarMeasure.isInvInvariant_of_regular","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninstâœâ´ : CommGroup G\ninstâœÂ³ : TopologicalSpace G\ninstâœÂ² : MeasurableSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœÂ¹ : LocallyCompactSpace G\ninstâœ : Î¼.Regular\nâŠ¢ Î¼.IsInvInvariant","decl":"/-- Any regular Haar measure is invariant under inversion in an abelian group. -/\n@[to_additive \"Any regular additive Haar measure is invariant under negation in an abelian group.\"]\ninstance (priority := 100) IsHaarMeasure.isInvInvariant_of_regular\n    [LocallyCompactSpace G] [Regular Î¼] : IsInvInvariant Î¼ := by\n  -- the image measure is a Haar measure. By uniqueness up to multiplication, it is of the form\n  -- `c Î¼`. Applying again inversion, one gets the measure `c^2 Î¼`. But since inversion is an\n  -- involution, this is also `Î¼`. Hence, `c^2 = 1`, which implies `c = 1`.\n  constructor\n  let c : â„â‰¥0âˆ := haarScalarFactor Î¼.inv Î¼\n  have hc : Î¼.inv = c â€¢ Î¼ := isMulLeftInvariant_eq_smul_of_regular Î¼.inv Î¼\n  have : map Inv.inv (map Inv.inv Î¼) = c ^ 2 â€¢ Î¼ := by\n    rw [â† inv_def Î¼, hc, Measure.map_smul, â† inv_def Î¼, hc, smul_smul, pow_two]\n  have Î¼eq : Î¼ = c ^ 2 â€¢ Î¼ := by\n    rw [map_map continuous_inv.measurable continuous_inv.measurable] at this\n    simpa only [inv_involutive, Involutive.comp_self, Measure.map_id]\n  have K : PositiveCompacts G := Classical.arbitrary _\n  have : c ^ 2 * Î¼ K = 1 ^ 2 * Î¼ K := by\n    conv_rhs => rw [Î¼eq]\n    simp\n  have : c ^ 2 = 1 ^ 2 :=\n    (ENNReal.mul_left_inj (measure_pos_of_nonempty_interior _ K.interior_nonempty).ne'\n          K.isCompact.measure_lt_top.ne).1 this\n  have : c = 1 := (ENNReal.pow_right_strictMono two_ne_zero).injective this\n  rw [hc, this, one_smul]\n\n"}
{"name":"MeasureTheory.Measure.IsAddHaarMeasure.isNegInvariant_of_innerRegular","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninstâœâ´ : AddCommGroup G\ninstâœÂ³ : TopologicalSpace G\ninstâœÂ² : MeasurableSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœÂ¹ : LocallyCompactSpace G\ninstâœ : Î¼.InnerRegular\nâŠ¢ Î¼.IsNegInvariant","decl":"/-- Any inner regular Haar measure is invariant under inversion in an abelian group. -/\n@[to_additive \"Any regular additive Haar measure is invariant under negation in an abelian group.\"]\ninstance (priority := 100) IsHaarMeasure.isInvInvariant_of_innerRegular\n    [LocallyCompactSpace G] [InnerRegular Î¼] : IsInvInvariant Î¼ := by\n  -- the image measure is a Haar measure. By uniqueness up to multiplication, it is of the form\n  -- `c Î¼`. Applying again inversion, one gets the measure `c^2 Î¼`. But since inversion is an\n  -- involution, this is also `Î¼`. Hence, `c^2 = 1`, which implies `c = 1`.\n  constructor\n  let c : â„â‰¥0âˆ := haarScalarFactor Î¼.inv Î¼\n  have hc : Î¼.inv = c â€¢ Î¼ := isMulLeftInvariant_eq_smul_of_innerRegular Î¼.inv Î¼\n  have : map Inv.inv (map Inv.inv Î¼) = c ^ 2 â€¢ Î¼ := by\n    rw [â† inv_def Î¼, hc, Measure.map_smul, â† inv_def Î¼, hc, smul_smul, pow_two]\n  have Î¼eq : Î¼ = c ^ 2 â€¢ Î¼ := by\n    rw [map_map continuous_inv.measurable continuous_inv.measurable] at this\n    simpa only [inv_involutive, Involutive.comp_self, Measure.map_id]\n  have K : PositiveCompacts G := Classical.arbitrary _\n  have : c ^ 2 * Î¼ K = 1 ^ 2 * Î¼ K := by\n    conv_rhs => rw [Î¼eq]\n    simp\n  have : c ^ 2 = 1 ^ 2 :=\n    (ENNReal.mul_left_inj (measure_pos_of_nonempty_interior _ K.interior_nonempty).ne'\n          K.isCompact.measure_lt_top.ne).1 this\n  have : c = 1 := (ENNReal.pow_right_strictMono two_ne_zero).injective this\n  rw [hc, this, one_smul]\n\n"}
{"name":"MeasureTheory.Measure.IsHaarMeasure.isInvInvariant_of_innerRegular","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninstâœâ´ : CommGroup G\ninstâœÂ³ : TopologicalSpace G\ninstâœÂ² : MeasurableSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœÂ¹ : LocallyCompactSpace G\ninstâœ : Î¼.InnerRegular\nâŠ¢ Î¼.IsInvInvariant","decl":"/-- Any inner regular Haar measure is invariant under inversion in an abelian group. -/\n@[to_additive \"Any regular additive Haar measure is invariant under negation in an abelian group.\"]\ninstance (priority := 100) IsHaarMeasure.isInvInvariant_of_innerRegular\n    [LocallyCompactSpace G] [InnerRegular Î¼] : IsInvInvariant Î¼ := by\n  -- the image measure is a Haar measure. By uniqueness up to multiplication, it is of the form\n  -- `c Î¼`. Applying again inversion, one gets the measure `c^2 Î¼`. But since inversion is an\n  -- involution, this is also `Î¼`. Hence, `c^2 = 1`, which implies `c = 1`.\n  constructor\n  let c : â„â‰¥0âˆ := haarScalarFactor Î¼.inv Î¼\n  have hc : Î¼.inv = c â€¢ Î¼ := isMulLeftInvariant_eq_smul_of_innerRegular Î¼.inv Î¼\n  have : map Inv.inv (map Inv.inv Î¼) = c ^ 2 â€¢ Î¼ := by\n    rw [â† inv_def Î¼, hc, Measure.map_smul, â† inv_def Î¼, hc, smul_smul, pow_two]\n  have Î¼eq : Î¼ = c ^ 2 â€¢ Î¼ := by\n    rw [map_map continuous_inv.measurable continuous_inv.measurable] at this\n    simpa only [inv_involutive, Involutive.comp_self, Measure.map_id]\n  have K : PositiveCompacts G := Classical.arbitrary _\n  have : c ^ 2 * Î¼ K = 1 ^ 2 * Î¼ K := by\n    conv_rhs => rw [Î¼eq]\n    simp\n  have : c ^ 2 = 1 ^ 2 :=\n    (ENNReal.mul_left_inj (measure_pos_of_nonempty_interior _ K.interior_nonempty).ne'\n          K.isCompact.measure_lt_top.ne).1 this\n  have : c = 1 := (ENNReal.pow_right_strictMono two_ne_zero).injective this\n  rw [hc, this, one_smul]\n\n"}
{"name":"MeasureTheory.Measure.measurePreserving_zpow","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninstâœâ· : CommGroup G\ninstâœâ¶ : TopologicalSpace G\ninstâœâµ : TopologicalGroup G\ninstâœâ´ : MeasurableSpace G\ninstâœÂ³ : BorelSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœÂ² : Î¼.IsHaarMeasure\ninstâœÂ¹ : CompactSpace G\ninstâœ : RootableBy G Int\nn : Int\nhn : Ne n 0\nâŠ¢ MeasureTheory.MeasurePreserving (fun g => HPow.hPow g n) Î¼ Î¼","decl":"@[to_additive]\ntheorem measurePreserving_zpow [CompactSpace G] [RootableBy G â„¤] {n : â„¤} (hn : n â‰  0) :\n    MeasurePreserving (fun g : G => g ^ n) Î¼ Î¼ :=\n  (zpowGroupHom n).measurePreserving (Î¼ := Î¼) (continuous_zpow n)\n    (RootableBy.surjective_pow G â„¤ hn) rfl\n\n"}
{"name":"MeasureTheory.Measure.measurePreserving_zsmul","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninstâœâ· : AddCommGroup G\ninstâœâ¶ : TopologicalSpace G\ninstâœâµ : TopologicalAddGroup G\ninstâœâ´ : MeasurableSpace G\ninstâœÂ³ : BorelSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœÂ² : Î¼.IsAddHaarMeasure\ninstâœÂ¹ : CompactSpace G\ninstâœ : DivisibleBy G Int\nn : Int\nhn : Ne n 0\nâŠ¢ MeasureTheory.MeasurePreserving (fun g => HSMul.hSMul n g) Î¼ Î¼","decl":"@[to_additive]\ntheorem measurePreserving_zpow [CompactSpace G] [RootableBy G â„¤] {n : â„¤} (hn : n â‰  0) :\n    MeasurePreserving (fun g : G => g ^ n) Î¼ Î¼ :=\n  (zpowGroupHom n).measurePreserving (Î¼ := Î¼) (continuous_zpow n)\n    (RootableBy.surjective_pow G â„¤ hn) rfl\n\n"}
{"name":"MeasureTheory.Measure.MeasurePreserving.zpow","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninstâœâ¸ : CommGroup G\ninstâœâ· : TopologicalSpace G\ninstâœâ¶ : TopologicalGroup G\ninstâœâµ : MeasurableSpace G\ninstâœâ´ : BorelSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœÂ³ : Î¼.IsHaarMeasure\ninstâœÂ² : CompactSpace G\ninstâœÂ¹ : RootableBy G Int\nn : Int\nhn : Ne n 0\nX : Type u_2\ninstâœ : MeasurableSpace X\nÎ¼' : MeasureTheory.Measure X\nf : X â†’ G\nhf : MeasureTheory.MeasurePreserving f Î¼' Î¼\nâŠ¢ MeasureTheory.MeasurePreserving (fun x => HPow.hPow (f x) n) Î¼' Î¼","decl":"@[to_additive]\ntheorem MeasurePreserving.zpow [CompactSpace G] [RootableBy G â„¤]\n    {n : â„¤} (hn : n â‰  0) {X : Type*}\n    [MeasurableSpace X] {Î¼' : Measure X} {f : X â†’ G} (hf : MeasurePreserving f Î¼' Î¼) :\n    MeasurePreserving (fun x => f x ^ n) Î¼' Î¼ :=\n  (measurePreserving_zpow Î¼ hn).comp hf\n\n"}
{"name":"MeasureTheory.Measure.MeasurePreserving.zsmul","module":"Mathlib.MeasureTheory.Measure.Haar.Unique","initialProofState":"G : Type u_1\ninstâœâ¸ : AddCommGroup G\ninstâœâ· : TopologicalSpace G\ninstâœâ¶ : TopologicalAddGroup G\ninstâœâµ : MeasurableSpace G\ninstâœâ´ : BorelSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœÂ³ : Î¼.IsAddHaarMeasure\ninstâœÂ² : CompactSpace G\ninstâœÂ¹ : DivisibleBy G Int\nn : Int\nhn : Ne n 0\nX : Type u_2\ninstâœ : MeasurableSpace X\nÎ¼' : MeasureTheory.Measure X\nf : X â†’ G\nhf : MeasureTheory.MeasurePreserving f Î¼' Î¼\nâŠ¢ MeasureTheory.MeasurePreserving (fun x => HSMul.hSMul n (f x)) Î¼' Î¼","decl":"@[to_additive]\ntheorem MeasurePreserving.zpow [CompactSpace G] [RootableBy G â„¤]\n    {n : â„¤} (hn : n â‰  0) {X : Type*}\n    [MeasurableSpace X] {Î¼' : Measure X} {f : X â†’ G} (hf : MeasurePreserving f Î¼' Î¼) :\n    MeasurePreserving (fun x => f x ^ n) Î¼' Î¼ :=\n  (measurePreserving_zpow Î¼ hn).comp hf\n\n"}
