{"name":"IsCauSeq.of_abv_le","module":"Mathlib.Algebra.Order.CauSeq.BigOperators","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\nf : Nat → β\na : Nat → α\nn : Nat\nhm : ∀ (m : Nat), LE.le n m → LE.le (abv (f m)) (a m)\na✝ : IsCauSeq abs fun n => (Finset.range n).sum fun i => a i\n⊢ IsCauSeq abv fun n => (Finset.range n).sum fun i => f i","decl":"lemma of_abv_le (n : ℕ) (hm : ∀ m, n ≤ m → abv (f m) ≤ a m) :\n    IsCauSeq abs (fun n ↦ ∑ i ∈ range n, a i) → IsCauSeq abv fun n ↦ ∑ i ∈ range n, f i := by\n  intro hg ε ε0\n  cases' hg (ε / 2) (div_pos ε0 (by norm_num)) with i hi\n  exists max n i\n  intro j ji\n  have hi₁ := hi j (le_trans (le_max_right n i) ji)\n  have hi₂ := hi (max n i) (le_max_right n i)\n  have sub_le :=\n    abs_sub_le (∑ k ∈ range j, a k) (∑ k ∈ range i, a k) (∑ k ∈ range (max n i), a k)\n  have := add_lt_add hi₁ hi₂\n  rw [abs_sub_comm (∑ k ∈ range (max n i), a k), add_halves ε] at this\n  refine lt_of_le_of_lt (le_trans (le_trans ?_ (le_abs_self _)) sub_le) this\n  generalize hk : j - max n i = k\n  clear this hi₂ hi₁ hi ε0 ε hg sub_le\n  rw [tsub_eq_iff_eq_add_of_le ji] at hk\n  rw [hk]\n  dsimp only\n  clear hk ji j\n  induction' k with k' hi\n  · simp [abv_zero abv]\n  simp only [Nat.succ_add, Nat.succ_eq_add_one, Finset.sum_range_succ_comm]\n  simp only [add_assoc, sub_eq_add_neg]\n  refine le_trans (abv_add _ _ _) ?_\n  simp only [sub_eq_add_neg] at hi\n  exact add_le_add (hm _ (le_add_of_nonneg_of_le (Nat.zero_le _) (le_max_left _ _))) hi\n\n"}
{"name":"IsCauSeq.of_abv","module":"Mathlib.Algebra.Order.CauSeq.BigOperators","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\nf : Nat → β\nhf : IsCauSeq abs fun m => (Finset.range m).sum fun n => abv (f n)\n⊢ IsCauSeq abv fun m => (Finset.range m).sum fun n => f n","decl":"lemma of_abv (hf : IsCauSeq abs fun m ↦ ∑ n ∈ range m, abv (f n)) :\n    IsCauSeq abv fun m ↦ ∑ n ∈ range m, f n :=\n  hf.of_abv_le 0 fun _ _ ↦ le_rfl\n\n"}
{"name":"cauchy_product","module":"Mathlib.Algebra.Order.CauSeq.BigOperators","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\nf g : Nat → β\nha : IsCauSeq abs fun m => (Finset.range m).sum fun n => abv (f n)\nhb : IsCauSeq abv fun m => (Finset.range m).sum fun n => g n\nε : α\nε0 : LT.lt 0 ε\n⊢ Exists fun i => ∀ (j : Nat), GE.ge j i → LT.lt (abv (HSub.hSub (HMul.hMul ((Finset.range j).sum fun k => f k) ((Finset.range j).sum fun k => g k)) ((Finset.range j).sum fun n => (Finset.range (HAdd.hAdd n 1)).sum fun m => HMul.hMul (f m) (g (HSub.hSub n m))))) ε","decl":"theorem _root_.cauchy_product (ha : IsCauSeq abs fun m ↦ ∑ n ∈ range m, abv (f n))\n    (hb : IsCauSeq abv fun m ↦ ∑ n ∈ range m, g n) (ε : α) (ε0 : 0 < ε) :\n    ∃ i : ℕ, ∀ j ≥ i,\n      abv ((∑ k ∈ range j, f k) * ∑ k ∈ range j, g k -\n        ∑ n ∈ range j, ∑ m ∈ range (n + 1), f m * g (n - m)) < ε := by\n  let ⟨P, hP⟩ := ha.bounded\n  let ⟨Q, hQ⟩ := hb.bounded\n  have hP0 : 0 < P := lt_of_le_of_lt (abs_nonneg _) (hP 0)\n  have hPε0 : 0 < ε / (2 * P) := div_pos ε0 (mul_pos (show (2 : α) > 0 by norm_num) hP0)\n  let ⟨N, hN⟩ := hb.cauchy₂ hPε0\n  have hQε0 : 0 < ε / (4 * Q) :=\n    div_pos ε0 (mul_pos (show (0 : α) < 4 by norm_num) (lt_of_le_of_lt (abv_nonneg _ _) (hQ 0)))\n  let ⟨M, hM⟩ := ha.cauchy₂ hQε0\n  refine ⟨2 * (max N M + 1), fun K hK ↦ ?_⟩\n  have h₁ :\n    (∑ m ∈ range K, ∑ k ∈ range (m + 1), f k * g (m - k)) =\n      ∑ m ∈ range K, ∑ n ∈ range (K - m), f m * g n := by\n    simpa using sum_range_diag_flip K fun m n ↦ f m * g n\n  have h₂ :\n    (fun i ↦ ∑ k ∈ range (K - i), f i * g k) = fun i ↦ f i * ∑ k ∈ range (K - i), g k := by\n    simp [Finset.mul_sum]\n  have h₃ :\n    ∑ i ∈ range K, f i * ∑ k ∈ range (K - i), g k =\n      ∑ i ∈ range K, f i * (∑ k ∈ range (K - i), g k - ∑ k ∈ range K, g k) +\n        ∑ i ∈ range K, f i * ∑ k ∈ range K, g k := by\n    rw [← sum_add_distrib]; simp [(mul_add _ _ _).symm]\n  have two_mul_two : (4 : α) = 2 * 2 := by norm_num\n  have hQ0 : Q ≠ 0 := fun h ↦ by simp [h, lt_irrefl] at hQε0\n  have h2Q0 : 2 * Q ≠ 0 := mul_ne_zero two_ne_zero hQ0\n  have hε : ε / (2 * P) * P + ε / (4 * Q) * (2 * Q) = ε := by\n    rw [← div_div, div_mul_cancel₀ _ (Ne.symm (ne_of_lt hP0)), two_mul_two, mul_assoc, ← div_div,\n      div_mul_cancel₀ _ h2Q0, add_halves]\n  have hNMK : max N M + 1 < K :=\n    lt_of_lt_of_le (by rw [two_mul]; exact lt_add_of_pos_left _ (Nat.succ_pos _)) hK\n  have hKN : N < K :=\n    calc\n      N ≤ max N M := le_max_left _ _\n      _ < max N M + 1 := Nat.lt_succ_self _\n      _ < K := hNMK\n  have hsumlesum :\n      (∑ i ∈ range (max N M + 1),\n        abv (f i) * abv ((∑ k ∈ range (K - i), g k) - ∑ k ∈ range K, g k)) ≤\n      ∑ i ∈ range (max N M + 1), abv (f i) * (ε / (2 * P)) := by\n    gcongr with m hmJ\n    refine le_of_lt <| hN (K - m) (le_tsub_of_add_le_left <| hK.trans' ?_) K hKN.le\n    rw [two_mul]\n    gcongr\n    · exact (mem_range.1 hmJ).le\n    · exact Nat.le_succ_of_le (le_max_left _ _)\n  have hsumltP : (∑ n ∈ range (max N M + 1), abv (f n)) < P :=\n    calc\n      (∑ n ∈ range (max N M + 1), abv (f n)) = |∑ n ∈ range (max N M + 1), abv (f n)| :=\n        Eq.symm (abs_of_nonneg (sum_nonneg fun x _ ↦ abv_nonneg abv (f x)))\n      _ < P := hP (max N M + 1)\n\n  rw [h₁, h₂, h₃, sum_mul, ← sub_sub, sub_right_comm, sub_self, zero_sub, abv_neg abv]\n  refine lt_of_le_of_lt (IsAbsoluteValue.abv_sum _ _ _) ?_\n  suffices\n    (∑ i ∈ range (max N M + 1),\n          abv (f i) * abv ((∑ k ∈ range (K - i), g k) - ∑ k ∈ range K, g k)) +\n        ((∑ i ∈ range K, abv (f i) * abv ((∑ k ∈ range (K - i), g k) - ∑ k ∈ range K, g k)) -\n          ∑ i ∈ range (max N M + 1),\n            abv (f i) * abv ((∑ k ∈ range (K - i), g k) - ∑ k ∈ range K, g k)) <\n      ε / (2 * P) * P + ε / (4 * Q) * (2 * Q) by\n    rw [hε] at this\n    simpa [abv_mul abv] using this\n  gcongr\n  · exact lt_of_le_of_lt hsumlesum\n        (by rw [← sum_mul, mul_comm]; gcongr)\n  rw [sum_range_sub_sum_range (le_of_lt hNMK)]\n  calc\n    (∑ i ∈ range K with max N M + 1 ≤ i,\n          abv (f i) * abv ((∑ k ∈ range (K - i), g k) - ∑ k ∈ range K, g k)) ≤\n        ∑ i ∈ range K with max N M + 1 ≤ i, abv (f i) * (2 * Q) := by\n        gcongr\n        rw [sub_eq_add_neg]\n        refine le_trans (abv_add _ _ _) ?_\n        rw [two_mul, abv_neg abv]\n        gcongr <;> exact le_of_lt (hQ _)\n    _ < ε / (4 * Q) * (2 * Q) := by\n        rw [← sum_mul, ← sum_range_sub_sum_range (le_of_lt hNMK)]\n        have := lt_of_le_of_lt (abv_nonneg _ _) (hQ 0)\n        gcongr\n        exact (le_abs_self _).trans_lt <|\n          hM _ ((Nat.le_succ_of_le (le_max_right _ _)).trans hNMK.le) _ <|\n            Nat.le_succ_of_le <| le_max_right _ _\n\n"}
{"name":"IsCauSeq.of_decreasing_bounded","module":"Mathlib.Algebra.Order.CauSeq.BigOperators","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrderedField α\ninst✝ : Archimedean α\nf : Nat → α\na : α\nm : Nat\nham : ∀ (n : Nat), GE.ge n m → LE.le (abs (f n)) a\nhnm : ∀ (n : Nat), GE.ge n m → LE.le (f n.succ) (f n)\n⊢ IsCauSeq abs f","decl":"lemma of_decreasing_bounded (f : ℕ → α) {a : α} {m : ℕ} (ham : ∀ n ≥ m, |f n| ≤ a)\n    (hnm : ∀ n ≥ m, f n.succ ≤ f n) : IsCauSeq abs f := fun ε ε0 ↦ by\n  classical\n  let ⟨k, hk⟩ := Archimedean.arch a ε0\n  have h : ∃ l, ∀ n ≥ m, a - l • ε < f n :=\n    ⟨k + k + 1, fun n hnm ↦\n      lt_of_lt_of_le (show a - (k + (k + 1)) • ε < -|f n| from\n          lt_neg.1 <| (ham n hnm).trans_lt\n              (by\n                rw [neg_sub, lt_sub_iff_add_lt, add_nsmul, add_nsmul, one_nsmul]\n                exact add_lt_add_of_le_of_lt hk (lt_of_le_of_lt hk (lt_add_of_pos_right _ ε0))))\n        (neg_le.2 <| abs_neg (f n) ▸ le_abs_self _)⟩\n  let l := Nat.find h\n  have hl : ∀ n : ℕ, n ≥ m → f n > a - l • ε := Nat.find_spec h\n  have hl0 : l ≠ 0 := fun hl0 ↦\n    not_lt_of_ge (ham m le_rfl)\n      (lt_of_lt_of_le (by have := hl m (le_refl m); simpa [hl0] using this) (le_abs_self (f m)))\n  cases' not_forall.1 (Nat.find_min h (Nat.pred_lt hl0)) with i hi\n  rw [Classical.not_imp, not_lt] at hi\n  exists i\n  intro j hj\n  have hfij : f j ≤ f i := (Nat.rel_of_forall_rel_succ_of_le_of_le (· ≥ ·) hnm hi.1 hj).le\n  rw [abs_of_nonpos (sub_nonpos.2 hfij), neg_sub, sub_lt_iff_lt_add']\n  calc\n    f i ≤ a - Nat.pred l • ε := hi.2\n    _ = a - l • ε + ε := by\n      conv =>\n        rhs\n        rw [← Nat.succ_pred_eq_of_pos (Nat.pos_of_ne_zero hl0), succ_nsmul, sub_add,\n          add_sub_cancel_right]\n    _ < f j + ε := add_lt_add_right (hl j (le_trans hi.1 hj)) _\n\n"}
{"name":"IsCauSeq.of_mono_bounded","module":"Mathlib.Algebra.Order.CauSeq.BigOperators","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrderedField α\ninst✝ : Archimedean α\nf : Nat → α\na : α\nm : Nat\nham : ∀ (n : Nat), GE.ge n m → LE.le (abs (f n)) a\nhnm : ∀ (n : Nat), GE.ge n m → LE.le (f n) (f n.succ)\n⊢ IsCauSeq abs f","decl":"lemma of_mono_bounded (f : ℕ → α) {a : α} {m : ℕ} (ham : ∀ n ≥ m, |f n| ≤ a)\n    (hnm : ∀ n ≥ m, f n ≤ f n.succ) : IsCauSeq abs f :=\n  (of_decreasing_bounded (-f) (a := a) (m := m) (by simpa using ham) <| by simpa using hnm).of_neg\n\n"}
{"name":"IsCauSeq.geo_series","module":"Mathlib.Algebra.Order.CauSeq.BigOperators","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : LinearOrderedField α\ninst✝³ : Ring β\nabv : β → α\ninst✝² : IsAbsoluteValue abv\ninst✝¹ : Archimedean α\ninst✝ : Nontrivial β\nx : β\nhx1 : LT.lt (abv x) 1\n⊢ IsCauSeq abv fun n => (Finset.range n).sum fun m => HPow.hPow x m","decl":"lemma geo_series [Nontrivial β] (x : β) (hx1 : abv x < 1) :\n    IsCauSeq abv fun n ↦ ∑ m ∈ range n, x ^ m := by\n  have hx1' : abv x ≠ 1 := fun h ↦ by simp [h, lt_irrefl] at hx1\n  refine of_abv ?_\n  simp only [abv_pow abv, geom_sum_eq hx1']\n  conv in _ / _ => rw [← neg_div_neg_eq, neg_sub, neg_sub]\n  have : 0 < 1 - abv x := sub_pos.2 hx1\n  refine @of_mono_bounded _ _ _ _ ((1 : α) / (1 - abv x)) 0 ?_ ?_\n  · intro n _\n    rw [abs_of_nonneg]\n    · gcongr\n      exact sub_le_self _ (abv_pow abv x n ▸ abv_nonneg _ _)\n    refine div_nonneg (sub_nonneg.2 ?_) (sub_nonneg.2 <| le_of_lt hx1)\n    exact pow_le_one₀ (by positivity) hx1.le\n  · intro n _\n    rw [← one_mul (abv x ^ n), pow_succ']\n    gcongr\n\n"}
{"name":"IsCauSeq.geo_series_const","module":"Mathlib.Algebra.Order.CauSeq.BigOperators","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrderedField α\ninst✝ : Archimedean α\na x : α\nhx1 : LT.lt (abs x) 1\n⊢ IsCauSeq abs fun m => (Finset.range m).sum fun n => HMul.hMul a (HPow.hPow x n)","decl":"lemma geo_series_const (a : α) {x : α} (hx1 : |x| < 1) :\n    IsCauSeq abs fun m ↦ ∑ n ∈ range m, (a * x ^ n) := by\n  simpa [mul_sum, Pi.mul_def] using (const a).mul (geo_series x hx1)\n\n"}
{"name":"IsCauSeq.series_ratio_test","module":"Mathlib.Algebra.Order.CauSeq.BigOperators","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : LinearOrderedField α\ninst✝² : Ring β\nabv : β → α\ninst✝¹ : IsAbsoluteValue abv\ninst✝ : Archimedean α\nf : Nat → β\nn : Nat\nr : α\nhr0 : LE.le 0 r\nhr1 : LT.lt r 1\nh : ∀ (m : Nat), LE.le n m → LE.le (abv (f m.succ)) (HMul.hMul r (abv (f m)))\n⊢ IsCauSeq abv fun m => (Finset.range m).sum fun n => f n","decl":"lemma series_ratio_test {f : ℕ → β} (n : ℕ) (r : α) (hr0 : 0 ≤ r) (hr1 : r < 1)\n    (h : ∀ m, n ≤ m → abv (f m.succ) ≤ r * abv (f m)) :\n    IsCauSeq abv fun m ↦ ∑ n ∈ range m, f n := by\n  have har1 : |r| < 1 := by rwa [abs_of_nonneg hr0]\n  refine (geo_series_const (abv (f n.succ) * r⁻¹ ^ n.succ) har1).of_abv_le n.succ fun m hmn ↦ ?_\n  obtain rfl | hr := hr0.eq_or_lt\n  · have m_pos := lt_of_lt_of_le (Nat.succ_pos n) hmn\n    have := h m.pred (Nat.le_of_succ_le_succ (by rwa [Nat.succ_pred_eq_of_pos m_pos]))\n    simpa [Nat.sub_add_cancel m_pos, pow_succ] using this\n  generalize hk : m - n.succ = k\n  replace hk : m = k + n.succ := (tsub_eq_iff_eq_add_of_le hmn).1 hk\n  induction' k with k ih generalizing m n\n  · rw [hk, Nat.zero_add, mul_right_comm, inv_pow _ _, ← div_eq_mul_inv, mul_div_cancel_right₀]\n    positivity\n  · have kn : k + n.succ ≥ n.succ := by\n      rw [← zero_add n.succ]; exact add_le_add (Nat.zero_le _) (by simp)\n    rw [hk, Nat.succ_add, pow_succ r, ← mul_assoc]\n    refine\n      le_trans (by rw [mul_comm] <;> exact h _ (Nat.le_of_succ_le kn))\n        (mul_le_mul_of_nonneg_right ?_ hr0)\n    exact ih _ h _ (by simp) rfl\n\n"}
