{"name":"Finset.sym2_val","module":"Mathlib.Data.Finset.Sym","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Eq s.sym2.val s.val.sym2","decl":"/-- `s.sym2` is the finset of all unordered pairs of elements from `s`.\nIt is the image of `s ×ˢ s` under the quotient `α × α → Sym2 α`. -/\n@[simps]\nprotected def sym2 (s : Finset α) : Finset (Sym2 α) := ⟨s.1.sym2, s.2.sym2⟩\n\n"}
{"name":"Finset.mk_mem_sym2_iff","module":"Mathlib.Data.Finset.Sym","initialProofState":"α : Type u_1\ns : Finset α\na b : α\n⊢ Iff (Membership.mem s.sym2 (Sym2.mk { fst := a, snd := b })) (And (Membership.mem s a) (Membership.mem s b))","decl":"theorem mk_mem_sym2_iff : s(a, b) ∈ s.sym2 ↔ a ∈ s ∧ b ∈ s := by\n  rw [mem_mk, sym2_val, Multiset.mk_mem_sym2_iff, mem_mk, mem_mk]\n\n"}
{"name":"Finset.mem_sym2_iff","module":"Mathlib.Data.Finset.Sym","initialProofState":"α : Type u_1\ns : Finset α\nm : Sym2 α\n⊢ Iff (Membership.mem s.sym2 m) (∀ (a : α), Membership.mem m a → Membership.mem s a)","decl":"@[simp]\ntheorem mem_sym2_iff {m : Sym2 α} : m ∈ s.sym2 ↔ ∀ a ∈ m, a ∈ s := by\n  rw [mem_mk, sym2_val, Multiset.mem_sym2_iff]\n  simp only [mem_val]\n\n"}
{"name":"Finset.sym2_cons","module":"Mathlib.Data.Finset.Sym","initialProofState":"α : Type u_1\na : α\ns : Finset α\nha : Not (Membership.mem s a)\n⊢ Eq (Finset.cons a s ha).sym2 ((Finset.map (Sym2.mkEmbedding a) (Finset.cons a s ha)).disjUnion s.sym2 ⋯)","decl":"theorem sym2_cons (a : α) (s : Finset α) (ha : a ∉ s) :\n    (s.cons a ha).sym2 = ((s.cons a ha).map <| Sym2.mkEmbedding a).disjUnion s.sym2 (by\n      simp [Finset.disjoint_left, ha]) :=\n  val_injective <| Multiset.sym2_cons _ _\n\n"}
{"name":"Finset.sym2_insert","module":"Mathlib.Data.Finset.Sym","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Finset α\n⊢ Eq (Insert.insert a s).sym2 (Union.union (Finset.image (fun b => Sym2.mk { fst := a, snd := b }) (Insert.insert a s)) s.sym2)","decl":"theorem sym2_insert [DecidableEq α] (a : α) (s : Finset α) :\n    (insert a s).sym2 = ((insert a s).image fun b => s(a, b)) ∪ s.sym2 := by\n  obtain ha | ha := Decidable.em (a ∈ s)\n  · simp only [insert_eq_of_mem ha, right_eq_union, image_subset_iff]\n    aesop\n  · simpa [map_eq_image] using sym2_cons a s ha\n\n"}
{"name":"Finset.sym2_map","module":"Mathlib.Data.Finset.Sym","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Function.Embedding α β\ns : Finset α\n⊢ Eq (Finset.map f s).sym2 (Finset.map f.sym2Map s.sym2)","decl":"theorem sym2_map (f : α ↪ β) (s : Finset α) : (s.map f).sym2 = s.sym2.map (.sym2Map f) :=\n  val_injective <| s.val.sym2_map _\n\n"}
{"name":"Finset.sym2_image","module":"Mathlib.Data.Finset.Sym","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : DecidableEq β\nf : α → β\ns : Finset α\n⊢ Eq (Finset.image f s).sym2 (Finset.image (Sym2.map f) s.sym2)","decl":"theorem sym2_image [DecidableEq β] (f : α → β) (s : Finset α) :\n    (s.image f).sym2 = s.sym2.image (Sym2.map f) := by\n  apply val_injective\n  dsimp [Finset.sym2]\n  rw [← Multiset.dedup_sym2, Multiset.sym2_map]\n\n"}
{"name":"Finset.sym2_univ","module":"Mathlib.Data.Finset.Sym","initialProofState":"α : Type u_1\ninst✝ : Fintype α\ninst : optParam (Fintype (Sym2 α)) Sym2.instFintype\n⊢ Eq Finset.univ.sym2 Finset.univ","decl":"@[simp]\ntheorem sym2_univ [Fintype α] (inst : Fintype (Sym2 α) := Sym2.instFintype) :\n    (univ : Finset α).sym2 = univ := by\n  ext\n  simp only [mem_sym2_iff, mem_univ, implies_true]\n\n"}
{"name":"Finset.sym2_mono","module":"Mathlib.Data.Finset.Sym","initialProofState":"α : Type u_1\ns t : Finset α\nh : HasSubset.Subset s t\n⊢ HasSubset.Subset s.sym2 t.sym2","decl":"@[simp, mono]\ntheorem sym2_mono (h : s ⊆ t) : s.sym2 ⊆ t.sym2 := by\n  rw [← val_le_iff, sym2_val, sym2_val]\n  apply Multiset.sym2_mono\n  rwa [val_le_iff]\n\n"}
{"name":"Finset.monotone_sym2","module":"Mathlib.Data.Finset.Sym","initialProofState":"α : Type u_1\n⊢ Monotone Finset.sym2","decl":"theorem monotone_sym2 : Monotone (Finset.sym2 : Finset α → _) := fun _ _ => sym2_mono\n\n"}
{"name":"Finset.injective_sym2","module":"Mathlib.Data.Finset.Sym","initialProofState":"α : Type u_1\n⊢ Function.Injective Finset.sym2","decl":"theorem injective_sym2 : Function.Injective (Finset.sym2 : Finset α → _) := by\n  intro s t h\n  ext x\n  simpa using congr(s(x, x) ∈ $h)\n\n"}
{"name":"Finset.strictMono_sym2","module":"Mathlib.Data.Finset.Sym","initialProofState":"α : Type u_1\n⊢ StrictMono Finset.sym2","decl":"theorem strictMono_sym2 : StrictMono (Finset.sym2 : Finset α → _) :=\n  monotone_sym2.strictMono_of_injective injective_sym2\n\n"}
{"name":"Finset.sym2_toFinset","module":"Mathlib.Data.Finset.Sym","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nm : Multiset α\n⊢ Eq m.toFinset.sym2 m.sym2.toFinset","decl":"theorem sym2_toFinset [DecidableEq α] (m : Multiset α) :\n    m.toFinset.sym2 = m.sym2.toFinset := by\n  ext z\n  refine z.ind fun x y ↦ ?_\n  simp only [mk_mem_sym2_iff, Multiset.mem_toFinset, Multiset.mk_mem_sym2_iff]\n\n"}
{"name":"Finset.sym2_empty","module":"Mathlib.Data.Finset.Sym","initialProofState":"α : Type u_1\n⊢ Eq EmptyCollection.emptyCollection.sym2 EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem sym2_empty : (∅ : Finset α).sym2 = ∅ := rfl\n\n"}
{"name":"Finset.sym2_eq_empty","module":"Mathlib.Data.Finset.Sym","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Iff (Eq s.sym2 EmptyCollection.emptyCollection) (Eq s EmptyCollection.emptyCollection)","decl":"@[simp]\ntheorem sym2_eq_empty : s.sym2 = ∅ ↔ s = ∅ := by\n  rw [← val_eq_zero, sym2_val, Multiset.sym2_eq_zero_iff, val_eq_zero]\n\n"}
{"name":"Finset.sym2_nonempty","module":"Mathlib.Data.Finset.Sym","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Iff s.sym2.Nonempty s.Nonempty","decl":"@[simp]\ntheorem sym2_nonempty : s.sym2.Nonempty ↔ s.Nonempty := by\n  rw [← not_iff_not]\n  simp_rw [not_nonempty_iff_eq_empty, sym2_eq_empty]\n\n"}
{"name":"Finset.Nonempty.sym2","module":"Mathlib.Data.Finset.Sym","initialProofState":"α : Type u_1\ns : Finset α\na✝ : s.Nonempty\n⊢ s.sym2.Nonempty","decl":"@[aesop safe apply (rule_sets := [finsetNonempty])]\nprotected alias ⟨_, Nonempty.sym2⟩ := sym2_nonempty\n\n"}
{"name":"Finset.sym2_singleton","module":"Mathlib.Data.Finset.Sym","initialProofState":"α : Type u_1\na : α\n⊢ Eq (Singleton.singleton a).sym2 (Singleton.singleton (Sym2.diag a))","decl":"@[simp]\ntheorem sym2_singleton (a : α) : ({a} : Finset α).sym2 = {Sym2.diag a} := rfl\n\n"}
{"name":"Finset.card_sym2","module":"Mathlib.Data.Finset.Sym","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Eq s.sym2.card ((HAdd.hAdd s.card 1).choose 2)","decl":"/-- Finset **stars and bars** for the case `n = 2`. -/\ntheorem card_sym2 (s : Finset α) : s.sym2.card = Nat.choose (s.card + 1) 2 := by\n  rw [card_def, sym2_val, Multiset.card_sym2, ← card_def]\n\n"}
{"name":"Finset.sym2_eq_image","module":"Mathlib.Data.Finset.Sym","initialProofState":"α : Type u_1\ns : Finset α\ninst✝ : DecidableEq α\n⊢ Eq s.sym2 (Finset.image Sym2.mk (SProd.sprod s s))","decl":"theorem sym2_eq_image : s.sym2 = (s ×ˢ s).image Sym2.mk := by\n  ext z\n  refine z.ind fun x y ↦ ?_\n  rw [mk_mem_sym2_iff, mem_image]\n  constructor\n  · intro h\n    use (x, y)\n    simp only [mem_product, h, and_self, true_and]\n  · rintro ⟨⟨a, b⟩, h⟩\n    simp only [mem_product, Sym2.eq_iff] at h\n    obtain ⟨h, (⟨rfl, rfl⟩ | ⟨rfl, rfl⟩)⟩ := h\n      <;> simp [h]\n\n"}
{"name":"Finset.isDiag_mk_of_mem_diag","module":"Mathlib.Data.Finset.Sym","initialProofState":"α : Type u_1\ns : Finset α\ninst✝ : DecidableEq α\na : Prod α α\nh : Membership.mem s.diag a\n⊢ (Sym2.mk a).IsDiag","decl":"theorem isDiag_mk_of_mem_diag {a : α × α} (h : a ∈ s.diag) : (Sym2.mk a).IsDiag :=\n  (Sym2.isDiag_iff_proj_eq _).2 (mem_diag.1 h).2\n\n"}
{"name":"Finset.not_isDiag_mk_of_mem_offDiag","module":"Mathlib.Data.Finset.Sym","initialProofState":"α : Type u_1\ns : Finset α\ninst✝ : DecidableEq α\na : Prod α α\nh : Membership.mem s.offDiag a\n⊢ Not (Sym2.mk a).IsDiag","decl":"theorem not_isDiag_mk_of_mem_offDiag {a : α × α} (h : a ∈ s.offDiag) :\n    ¬ (Sym2.mk a).IsDiag := by\n  rw [Sym2.isDiag_iff_proj_eq]\n  exact (mem_offDiag.1 h).2.2\n\n"}
{"name":"Finset.diag_mem_sym2_mem_iff","module":"Mathlib.Data.Finset.Sym","initialProofState":"α : Type u_1\ns : Finset α\na : α\n⊢ Iff (∀ (b : α), Membership.mem (Sym2.diag a) b → Membership.mem s b) (Membership.mem s a)","decl":"@[simp]\ntheorem diag_mem_sym2_mem_iff : (∀ b, b ∈ Sym2.diag a → b ∈ s) ↔ a ∈ s := by\n  rw [← mem_sym2_iff]\n  exact mk_mem_sym2_iff.trans <| and_self_iff\n\n"}
{"name":"Finset.diag_mem_sym2_iff","module":"Mathlib.Data.Finset.Sym","initialProofState":"α : Type u_1\ns : Finset α\na : α\n⊢ Iff (Membership.mem s.sym2 (Sym2.diag a)) (Membership.mem s a)","decl":"theorem diag_mem_sym2_iff : Sym2.diag a ∈ s.sym2 ↔ a ∈ s := by simp [diag_mem_sym2_mem_iff]\n\n"}
{"name":"Finset.image_diag_union_image_offDiag","module":"Mathlib.Data.Finset.Sym","initialProofState":"α : Type u_1\ns : Finset α\ninst✝ : DecidableEq α\n⊢ Eq (Union.union (Finset.image Sym2.mk s.diag) (Finset.image Sym2.mk s.offDiag)) s.sym2","decl":"theorem image_diag_union_image_offDiag [DecidableEq α] :\n    s.diag.image Sym2.mk ∪ s.offDiag.image Sym2.mk = s.sym2 := by\n  rw [← image_union, diag_union_offDiag, sym2_eq_image]\n\n"}
{"name":"Finset.sym_zero","module":"Mathlib.Data.Finset.Sym","initialProofState":"α : Type u_1\ns : Finset α\ninst✝ : DecidableEq α\n⊢ Eq (s.sym 0) (Singleton.singleton EmptyCollection.emptyCollection)","decl":"@[simp]\ntheorem sym_zero : s.sym 0 = {∅} := rfl\n\n"}
{"name":"Finset.sym_succ","module":"Mathlib.Data.Finset.Sym","initialProofState":"α : Type u_1\ns : Finset α\ninst✝ : DecidableEq α\nn : Nat\n⊢ Eq (s.sym (HAdd.hAdd n 1)) (s.sup fun a => Finset.image (Sym.cons a) (s.sym n))","decl":"@[simp]\ntheorem sym_succ : s.sym (n + 1) = s.sup fun a ↦ (s.sym n).image <| Sym.cons a := rfl\n\n"}
{"name":"Finset.mem_sym_iff","module":"Mathlib.Data.Finset.Sym","initialProofState":"α : Type u_1\ns : Finset α\ninst✝ : DecidableEq α\nn : Nat\nm : Sym α n\n⊢ Iff (Membership.mem (s.sym n) m) (∀ (a : α), Membership.mem m a → Membership.mem s a)","decl":"@[simp]\ntheorem mem_sym_iff {m : Sym α n} : m ∈ s.sym n ↔ ∀ a ∈ m, a ∈ s := by\n  induction' n with n ih\n  · refine mem_singleton.trans ⟨?_, fun _ ↦ Sym.eq_nil_of_card_zero _⟩\n    rintro rfl\n    exact fun a ha ↦ (Finset.not_mem_empty _ ha).elim\n  refine mem_sup.trans ⟨?_, fun h ↦ ?_⟩\n  · rintro ⟨a, ha, he⟩ b hb\n    rw [mem_image] at he\n    obtain ⟨m, he, rfl⟩ := he\n    rw [Sym.mem_cons] at hb\n    obtain rfl | hb := hb\n    · exact ha\n    · exact ih.1 he _ hb\n  · obtain ⟨a, m, rfl⟩ := m.exists_eq_cons_of_succ\n    exact\n      ⟨a, h _ <| Sym.mem_cons_self _ _,\n        mem_image_of_mem _ <| ih.2 fun b hb ↦ h _ <| Sym.mem_cons_of_mem hb⟩\n\n"}
{"name":"Finset.sym_empty","module":"Mathlib.Data.Finset.Sym","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nn : Nat\n⊢ Eq (EmptyCollection.emptyCollection.sym (HAdd.hAdd n 1)) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem sym_empty (n : ℕ) : (∅ : Finset α).sym (n + 1) = ∅ := rfl\n\n"}
{"name":"Finset.replicate_mem_sym","module":"Mathlib.Data.Finset.Sym","initialProofState":"α : Type u_1\ns : Finset α\na : α\ninst✝ : DecidableEq α\nha : Membership.mem s a\nn : Nat\n⊢ Membership.mem (s.sym n) (Sym.replicate n a)","decl":"theorem replicate_mem_sym (ha : a ∈ s) (n : ℕ) : Sym.replicate n a ∈ s.sym n :=\n  mem_sym_iff.2 fun b hb ↦ by rwa [(Sym.mem_replicate.1 hb).2]\n\n"}
{"name":"Finset.Nonempty.sym","module":"Mathlib.Data.Finset.Sym","initialProofState":"α : Type u_1\ns : Finset α\ninst✝ : DecidableEq α\nh : s.Nonempty\nn : Nat\n⊢ (s.sym n).Nonempty","decl":"protected theorem Nonempty.sym (h : s.Nonempty) (n : ℕ) : (s.sym n).Nonempty :=\n  let ⟨_a, ha⟩ := h\n  ⟨_, replicate_mem_sym ha n⟩\n\n"}
{"name":"Finset.sym_singleton","module":"Mathlib.Data.Finset.Sym","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\nn : Nat\n⊢ Eq ((Singleton.singleton a).sym n) (Singleton.singleton (Sym.replicate n a))","decl":"@[simp]\ntheorem sym_singleton (a : α) (n : ℕ) : ({a} : Finset α).sym n = {Sym.replicate n a} :=\n  eq_singleton_iff_unique_mem.2\n    ⟨replicate_mem_sym (mem_singleton.2 rfl) _, fun _s hs ↦\n      Sym.eq_replicate_iff.2 fun _b hb ↦ eq_of_mem_singleton <| mem_sym_iff.1 hs _ hb⟩\n\n"}
{"name":"Finset.eq_empty_of_sym_eq_empty","module":"Mathlib.Data.Finset.Sym","initialProofState":"α : Type u_1\ns : Finset α\ninst✝ : DecidableEq α\nn : Nat\nh : Eq (s.sym n) EmptyCollection.emptyCollection\n⊢ Eq s EmptyCollection.emptyCollection","decl":"theorem eq_empty_of_sym_eq_empty (h : s.sym n = ∅) : s = ∅ := by\n  rw [← not_nonempty_iff_eq_empty] at h ⊢\n  exact fun hs ↦ h (hs.sym _)\n\n"}
{"name":"Finset.sym_eq_empty","module":"Mathlib.Data.Finset.Sym","initialProofState":"α : Type u_1\ns : Finset α\ninst✝ : DecidableEq α\nn : Nat\n⊢ Iff (Eq (s.sym n) EmptyCollection.emptyCollection) (And (Ne n 0) (Eq s EmptyCollection.emptyCollection))","decl":"@[simp]\ntheorem sym_eq_empty : s.sym n = ∅ ↔ n ≠ 0 ∧ s = ∅ := by\n  cases n\n  · exact iff_of_false (singleton_ne_empty _) fun h ↦ (h.1 rfl).elim\n  · refine ⟨fun h ↦ ⟨Nat.succ_ne_zero _, eq_empty_of_sym_eq_empty h⟩, ?_⟩\n    rintro ⟨_, rfl⟩\n    exact sym_empty _\n\n"}
{"name":"Finset.sym_nonempty","module":"Mathlib.Data.Finset.Sym","initialProofState":"α : Type u_1\ns : Finset α\ninst✝ : DecidableEq α\nn : Nat\n⊢ Iff (s.sym n).Nonempty (Or (Eq n 0) s.Nonempty)","decl":"@[simp]\ntheorem sym_nonempty : (s.sym n).Nonempty ↔ n = 0 ∨ s.Nonempty := by\n  simp only [nonempty_iff_ne_empty, ne_eq, sym_eq_empty, not_and_or, not_ne_iff]\n\n"}
{"name":"Finset.sym_univ","module":"Mathlib.Data.Finset.Sym","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nn : Nat\n⊢ Eq (Finset.univ.sym n) Finset.univ","decl":"@[simp]\ntheorem sym_univ [Fintype α] (n : ℕ) : (univ : Finset α).sym n = univ :=\n  eq_univ_iff_forall.2 fun _s ↦ mem_sym_iff.2 fun _a _ ↦ mem_univ _\n\n"}
{"name":"Finset.sym_mono","module":"Mathlib.Data.Finset.Sym","initialProofState":"α : Type u_1\ns t : Finset α\ninst✝ : DecidableEq α\nh : HasSubset.Subset s t\nn : Nat\n⊢ HasSubset.Subset (s.sym n) (t.sym n)","decl":"@[simp]\ntheorem sym_mono (h : s ⊆ t) (n : ℕ) : s.sym n ⊆ t.sym n := fun _m hm ↦\n  mem_sym_iff.2 fun _a ha ↦ h <| mem_sym_iff.1 hm _ ha\n\n"}
{"name":"Finset.sym_inter","module":"Mathlib.Data.Finset.Sym","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nn : Nat\n⊢ Eq ((Inter.inter s t).sym n) (Inter.inter (s.sym n) (t.sym n))","decl":"@[simp]\ntheorem sym_inter (s t : Finset α) (n : ℕ) : (s ∩ t).sym n = s.sym n ∩ t.sym n := by\n  ext m\n  simp only [mem_inter, mem_sym_iff, imp_and, forall_and]\n\n"}
{"name":"Finset.sym_union","module":"Mathlib.Data.Finset.Sym","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nn : Nat\n⊢ HasSubset.Subset (Union.union (s.sym n) (t.sym n)) ((Union.union s t).sym n)","decl":"@[simp]\ntheorem sym_union (s t : Finset α) (n : ℕ) : s.sym n ∪ t.sym n ⊆ (s ∪ t).sym n :=\n  union_subset (sym_mono subset_union_left n) (sym_mono subset_union_right n)\n\n"}
{"name":"Finset.sym_fill_mem","module":"Mathlib.Data.Finset.Sym","initialProofState":"α : Type u_1\ns : Finset α\ninst✝ : DecidableEq α\nn : Nat\na : α\ni : Fin (HAdd.hAdd n 1)\nm : Sym α (HSub.hSub n ↑i)\nh : Membership.mem (s.sym (HSub.hSub n ↑i)) m\n⊢ Membership.mem ((Insert.insert a s).sym n) (Sym.fill a i m)","decl":"theorem sym_fill_mem (a : α) {i : Fin (n + 1)} {m : Sym α (n - i)} (h : m ∈ s.sym (n - i)) :\n    m.fill a i ∈ (insert a s).sym n :=\n  mem_sym_iff.2 fun b hb ↦\n    mem_insert.2 <| (Sym.mem_fill_iff.1 hb).imp And.right <| mem_sym_iff.1 h b\n\n"}
{"name":"Finset.sym_filterNe_mem","module":"Mathlib.Data.Finset.Sym","initialProofState":"α : Type u_1\ns : Finset α\ninst✝ : DecidableEq α\nn : Nat\nm : Sym α n\na : α\nh : Membership.mem (s.sym n) m\n⊢ Membership.mem ((s.erase a).sym (HSub.hSub n ↑(Sym.filterNe a m).fst)) (Sym.filterNe a m).snd","decl":"theorem sym_filterNe_mem {m : Sym α n} (a : α) (h : m ∈ s.sym n) :\n    (m.filterNe a).2 ∈ (Finset.erase s a).sym (n - (m.filterNe a).1) :=\n  mem_sym_iff.2 fun b H ↦\n    mem_erase.2 <| (Multiset.mem_filter.1 H).symm.imp Ne.symm <| mem_sym_iff.1 h b\n\n"}
{"name":"Finset.symInsertEquiv_apply_snd_coe","module":"Mathlib.Data.Finset.Sym","initialProofState":"α : Type u_1\ns : Finset α\na : α\ninst✝ : DecidableEq α\nn : Nat\nh : Not (Membership.mem s a)\nm : Subtype fun x => Membership.mem ((Insert.insert a s).sym n) x\n⊢ Eq (↑((Finset.symInsertEquiv h) m).snd) (Sym.filterNe a ↑m).snd","decl":"/-- If `a` does not belong to the finset `s`, then the `n`th symmetric power of `{a} ∪ s` is\n  in 1-1 correspondence with the disjoint union of the `n - i`th symmetric powers of `s`,\n  for `0 ≤ i ≤ n`. -/\n@[simps]\ndef symInsertEquiv (h : a ∉ s) : (insert a s).sym n ≃ Σi : Fin (n + 1), s.sym (n - i) where\n  toFun m := ⟨_, (m.1.filterNe a).2, by convert sym_filterNe_mem a m.2; rw [erase_insert h]⟩\n  invFun m := ⟨m.2.1.fill a m.1, sym_fill_mem a m.2.2⟩\n  left_inv m := Subtype.ext <| m.1.fill_filterNe a\n  right_inv := fun ⟨i, m, hm⟩ ↦ by\n    refine Function.Injective.sigma_map (β₂ := ?_) (f₂ := ?_)\n        (Function.injective_id) (fun i ↦ ?_) ?_\n    · exact fun i ↦ Sym α (n - i)\n    swap\n    · exact Subtype.coe_injective\n    refine Eq.trans ?_ (Sym.filter_ne_fill a _ ?_)\n    exacts [rfl, h ∘ mem_sym_iff.1 hm a]\n\n"}
{"name":"Finset.symInsertEquiv_apply_fst","module":"Mathlib.Data.Finset.Sym","initialProofState":"α : Type u_1\ns : Finset α\na : α\ninst✝ : DecidableEq α\nn : Nat\nh : Not (Membership.mem s a)\nm : Subtype fun x => Membership.mem ((Insert.insert a s).sym n) x\n⊢ Eq ((Finset.symInsertEquiv h) m).fst (Sym.filterNe a ↑m).fst","decl":"/-- If `a` does not belong to the finset `s`, then the `n`th symmetric power of `{a} ∪ s` is\n  in 1-1 correspondence with the disjoint union of the `n - i`th symmetric powers of `s`,\n  for `0 ≤ i ≤ n`. -/\n@[simps]\ndef symInsertEquiv (h : a ∉ s) : (insert a s).sym n ≃ Σi : Fin (n + 1), s.sym (n - i) where\n  toFun m := ⟨_, (m.1.filterNe a).2, by convert sym_filterNe_mem a m.2; rw [erase_insert h]⟩\n  invFun m := ⟨m.2.1.fill a m.1, sym_fill_mem a m.2.2⟩\n  left_inv m := Subtype.ext <| m.1.fill_filterNe a\n  right_inv := fun ⟨i, m, hm⟩ ↦ by\n    refine Function.Injective.sigma_map (β₂ := ?_) (f₂ := ?_)\n        (Function.injective_id) (fun i ↦ ?_) ?_\n    · exact fun i ↦ Sym α (n - i)\n    swap\n    · exact Subtype.coe_injective\n    refine Eq.trans ?_ (Sym.filter_ne_fill a _ ?_)\n    exacts [rfl, h ∘ mem_sym_iff.1 hm a]\n\n"}
{"name":"Finset.symInsertEquiv_symm_apply_coe","module":"Mathlib.Data.Finset.Sym","initialProofState":"α : Type u_1\ns : Finset α\na : α\ninst✝ : DecidableEq α\nn : Nat\nh : Not (Membership.mem s a)\nm : Sigma fun i => Subtype fun x => Membership.mem (s.sym (HSub.hSub n ↑i)) x\n⊢ Eq (↑((Finset.symInsertEquiv h).symm m)) (Sym.fill a m.fst ↑m.snd)","decl":"/-- If `a` does not belong to the finset `s`, then the `n`th symmetric power of `{a} ∪ s` is\n  in 1-1 correspondence with the disjoint union of the `n - i`th symmetric powers of `s`,\n  for `0 ≤ i ≤ n`. -/\n@[simps]\ndef symInsertEquiv (h : a ∉ s) : (insert a s).sym n ≃ Σi : Fin (n + 1), s.sym (n - i) where\n  toFun m := ⟨_, (m.1.filterNe a).2, by convert sym_filterNe_mem a m.2; rw [erase_insert h]⟩\n  invFun m := ⟨m.2.1.fill a m.1, sym_fill_mem a m.2.2⟩\n  left_inv m := Subtype.ext <| m.1.fill_filterNe a\n  right_inv := fun ⟨i, m, hm⟩ ↦ by\n    refine Function.Injective.sigma_map (β₂ := ?_) (f₂ := ?_)\n        (Function.injective_id) (fun i ↦ ?_) ?_\n    · exact fun i ↦ Sym α (n - i)\n    swap\n    · exact Subtype.coe_injective\n    refine Eq.trans ?_ (Sym.filter_ne_fill a _ ?_)\n    exacts [rfl, h ∘ mem_sym_iff.1 hm a]\n\n"}
