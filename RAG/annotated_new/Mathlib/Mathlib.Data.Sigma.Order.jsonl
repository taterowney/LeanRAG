{"name":"Sigma.mk_le_mk_iff","module":"Mathlib.Data.Sigma.Order","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝ : (i : ι) → LE (α i)\ni : ι\na b : α i\n⊢ Iff (LE.le ⟨i, a⟩ ⟨i, b⟩) (LE.le a b)","decl":"@[simp]\ntheorem mk_le_mk_iff [∀ i, LE (α i)] {i : ι} {a b : α i} : (⟨i, a⟩ : Sigma α) ≤ ⟨i, b⟩ ↔ a ≤ b :=\n  ⟨fun ⟨_, _, _, h⟩ => h, Sigma.le.fiber _ _ _⟩\n\n"}
{"name":"Sigma.mk_lt_mk_iff","module":"Mathlib.Data.Sigma.Order","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝ : (i : ι) → LT (α i)\ni : ι\na b : α i\n⊢ Iff (LT.lt ⟨i, a⟩ ⟨i, b⟩) (LT.lt a b)","decl":"@[simp]\ntheorem mk_lt_mk_iff [∀ i, LT (α i)] {i : ι} {a b : α i} : (⟨i, a⟩ : Sigma α) < ⟨i, b⟩ ↔ a < b :=\n  ⟨fun ⟨_, _, _, h⟩ => h, Sigma.lt.fiber _ _ _⟩\n\n"}
{"name":"Sigma.le_def","module":"Mathlib.Data.Sigma.Order","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝ : (i : ι) → LE (α i)\na b : Sigma fun i => α i\n⊢ Iff (LE.le a b) (Exists fun h => LE.le (Eq.rec a.snd h) b.snd)","decl":"theorem le_def [∀ i, LE (α i)] {a b : Σi, α i} : a ≤ b ↔ ∃ h : a.1 = b.1, h.rec a.2 ≤ b.2 := by\n  constructor\n  · rintro ⟨i, a, b, h⟩\n    exact ⟨rfl, h⟩\n  · obtain ⟨i, a⟩ := a\n    obtain ⟨j, b⟩ := b\n    rintro ⟨rfl : i = j, h⟩\n    exact le.fiber _ _ _ h\n\n"}
{"name":"Sigma.lt_def","module":"Mathlib.Data.Sigma.Order","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝ : (i : ι) → LT (α i)\na b : Sigma fun i => α i\n⊢ Iff (LT.lt a b) (Exists fun h => LT.lt (Eq.rec a.snd h) b.snd)","decl":"theorem lt_def [∀ i, LT (α i)] {a b : Σi, α i} : a < b ↔ ∃ h : a.1 = b.1, h.rec a.2 < b.2 := by\n  constructor\n  · rintro ⟨i, a, b, h⟩\n    exact ⟨rfl, h⟩\n  · obtain ⟨i, a⟩ := a\n    obtain ⟨j, b⟩ := b\n    rintro ⟨rfl : i = j, h⟩\n    exact lt.fiber _ _ _ h\n\n"}
{"name":"Sigma.instDenselyOrdered","module":"Mathlib.Data.Sigma.Order","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝¹ : (i : ι) → Preorder (α i)\ninst✝ : ∀ (i : ι), DenselyOrdered (α i)\n⊢ DenselyOrdered (Sigma fun i => α i)","decl":"instance [∀ i, Preorder (α i)] [∀ i, DenselyOrdered (α i)] : DenselyOrdered (Σi, α i) where\n  dense := by\n    rintro ⟨i, a⟩ ⟨_, _⟩ ⟨_, _, b, h⟩\n    obtain ⟨c, ha, hb⟩ := exists_between h\n    exact ⟨⟨i, c⟩, lt.fiber i a c ha, lt.fiber i c b hb⟩\n\n"}
{"name":"Sigma.Lex.le_def","module":"Mathlib.Data.Sigma.Order","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝¹ : LT ι\ninst✝ : (i : ι) → LE (α i)\na b : Lex (Sigma fun i => α i)\n⊢ Iff (LE.le a b) (Or (LT.lt a.fst b.fst) (Exists fun h => LE.le (Eq.rec a.snd h) b.snd))","decl":"theorem le_def [LT ι] [∀ i, LE (α i)] {a b : Σₗ i, α i} :\n    a ≤ b ↔ a.1 < b.1 ∨ ∃ h : a.1 = b.1, h.rec a.2 ≤ b.2 :=\n  Sigma.lex_iff\n\n"}
{"name":"Sigma.Lex.lt_def","module":"Mathlib.Data.Sigma.Order","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝¹ : LT ι\ninst✝ : (i : ι) → LT (α i)\na b : Lex (Sigma fun i => α i)\n⊢ Iff (LT.lt a b) (Or (LT.lt a.fst b.fst) (Exists fun h => LT.lt (Eq.rec a.snd h) b.snd))","decl":"theorem lt_def [LT ι] [∀ i, LT (α i)] {a b : Σₗ i, α i} :\n    a < b ↔ a.1 < b.1 ∨ ∃ h : a.1 = b.1, h.rec a.2 < b.2 :=\n  Sigma.lex_iff\n\n"}
{"name":"Sigma.Lex.denselyOrdered","module":"Mathlib.Data.Sigma.Order","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝⁴ : Preorder ι\ninst✝³ : DenselyOrdered ι\ninst✝² : ∀ (i : ι), Nonempty (α i)\ninst✝¹ : (i : ι) → Preorder (α i)\ninst✝ : ∀ (i : ι), DenselyOrdered (α i)\n⊢ DenselyOrdered (Lex (Sigma fun i => α i))","decl":"instance denselyOrdered [Preorder ι] [DenselyOrdered ι] [∀ i, Nonempty (α i)] [∀ i, Preorder (α i)]\n    [∀ i, DenselyOrdered (α i)] : DenselyOrdered (Σₗ i, α i) where\n  dense := by\n    rintro ⟨i, a⟩ ⟨j, b⟩ (⟨_, _, h⟩ | ⟨_, b, h⟩)\n    · obtain ⟨k, hi, hj⟩ := exists_between h\n      obtain ⟨c⟩ : Nonempty (α k) := inferInstance\n      exact ⟨⟨k, c⟩, left _ _ hi, left _ _ hj⟩\n    · obtain ⟨c, ha, hb⟩ := exists_between h\n      exact ⟨⟨i, c⟩, right _ _ ha, right _ _ hb⟩\n\n"}
{"name":"Sigma.Lex.denselyOrdered_of_noMaxOrder","module":"Mathlib.Data.Sigma.Order","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝³ : Preorder ι\ninst✝² : (i : ι) → Preorder (α i)\ninst✝¹ : ∀ (i : ι), DenselyOrdered (α i)\ninst✝ : ∀ (i : ι), NoMaxOrder (α i)\n⊢ DenselyOrdered (Lex (Sigma fun i => α i))","decl":"instance denselyOrdered_of_noMaxOrder [Preorder ι] [∀ i, Preorder (α i)]\n    [∀ i, DenselyOrdered (α i)] [∀ i, NoMaxOrder (α i)] :\n    DenselyOrdered (Σₗ i, α i) where\n  dense := by\n    rintro ⟨i, a⟩ ⟨j, b⟩ (⟨_, _, h⟩ | ⟨_, b, h⟩)\n    · obtain ⟨c, ha⟩ := exists_gt a\n      exact ⟨⟨i, c⟩, right _ _ ha, left _ _ h⟩\n    · obtain ⟨c, ha, hb⟩ := exists_between h\n      exact ⟨⟨i, c⟩, right _ _ ha, right _ _ hb⟩\n\n"}
{"name":"Sigma.Lex.denselyOrdered_of_noMinOrder","module":"Mathlib.Data.Sigma.Order","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝³ : Preorder ι\ninst✝² : (i : ι) → Preorder (α i)\ninst✝¹ : ∀ (i : ι), DenselyOrdered (α i)\ninst✝ : ∀ (i : ι), NoMinOrder (α i)\n⊢ DenselyOrdered (Lex (Sigma fun i => α i))","decl":"instance denselyOrdered_of_noMinOrder [Preorder ι] [∀ i, Preorder (α i)]\n    [∀ i, DenselyOrdered (α i)] [∀ i, NoMinOrder (α i)] :\n    DenselyOrdered (Σₗ i, α i) where\n  dense := by\n    rintro ⟨i, a⟩ ⟨j, b⟩ (⟨_, _, h⟩ | ⟨_, b, h⟩)\n    · obtain ⟨c, hb⟩ := exists_lt b\n      exact ⟨⟨j, c⟩, left _ _ h, right _ _ hb⟩\n    · obtain ⟨c, ha, hb⟩ := exists_between h\n      exact ⟨⟨i, c⟩, right _ _ ha, right _ _ hb⟩\n\n"}
{"name":"Sigma.Lex.noMaxOrder_of_nonempty","module":"Mathlib.Data.Sigma.Order","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝³ : Preorder ι\ninst✝² : (i : ι) → Preorder (α i)\ninst✝¹ : NoMaxOrder ι\ninst✝ : ∀ (i : ι), Nonempty (α i)\n⊢ NoMaxOrder (Lex (Sigma fun i => α i))","decl":"instance noMaxOrder_of_nonempty [Preorder ι] [∀ i, Preorder (α i)] [NoMaxOrder ι]\n    [∀ i, Nonempty (α i)] : NoMaxOrder (Σₗ i, α i) where\n  exists_gt := by\n    rintro ⟨i, a⟩\n    obtain ⟨j, h⟩ := exists_gt i\n    obtain ⟨b⟩ : Nonempty (α j) := inferInstance\n    exact ⟨⟨j, b⟩, left _ _ h⟩\n\n"}
{"name":"Sigma.Lex.noMinOrder_of_nonempty","module":"Mathlib.Data.Sigma.Order","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝³ : Preorder ι\ninst✝² : (i : ι) → Preorder (α i)\ninst✝¹ : NoMinOrder ι\ninst✝ : ∀ (i : ι), Nonempty (α i)\n⊢ NoMinOrder (Lex (Sigma fun i => α i))","decl":"instance noMinOrder_of_nonempty [Preorder ι] [∀ i, Preorder (α i)] [NoMinOrder ι]\n    [∀ i, Nonempty (α i)] : NoMinOrder (Σₗ i, α i) where\n  exists_lt := by\n    rintro ⟨i, a⟩\n    obtain ⟨j, h⟩ := exists_lt i\n    obtain ⟨b⟩ : Nonempty (α j) := inferInstance\n    exact ⟨⟨j, b⟩, left _ _ h⟩\n\n"}
{"name":"Sigma.Lex.noMaxOrder","module":"Mathlib.Data.Sigma.Order","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝² : Preorder ι\ninst✝¹ : (i : ι) → Preorder (α i)\ninst✝ : ∀ (i : ι), NoMaxOrder (α i)\n⊢ NoMaxOrder (Lex (Sigma fun i => α i))","decl":"instance noMaxOrder [Preorder ι] [∀ i, Preorder (α i)] [∀ i, NoMaxOrder (α i)] :\n    NoMaxOrder (Σₗ i, α i) where\n  exists_gt := by\n    rintro ⟨i, a⟩\n    obtain ⟨b, h⟩ := exists_gt a\n    exact ⟨⟨i, b⟩, right _ _ h⟩\n\n"}
{"name":"Sigma.Lex.noMinOrder","module":"Mathlib.Data.Sigma.Order","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝² : Preorder ι\ninst✝¹ : (i : ι) → Preorder (α i)\ninst✝ : ∀ (i : ι), NoMinOrder (α i)\n⊢ NoMinOrder (Lex (Sigma fun i => α i))","decl":"instance noMinOrder [Preorder ι] [∀ i, Preorder (α i)] [∀ i, NoMinOrder (α i)] :\n    NoMinOrder (Σₗ i, α i) where\n  exists_lt := by\n    rintro ⟨i, a⟩\n    obtain ⟨b, h⟩ := exists_lt a\n    exact ⟨⟨i, b⟩, right _ _ h⟩\n\n"}
