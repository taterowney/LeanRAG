{"name":"log_add_one_le_harmonic","module":"Mathlib.NumberTheory.Harmonic.Bounds","initialProofState":"n : Nat\n⊢ LE.le (Real.log ↑(HAdd.hAdd n 1)) ↑(harmonic n)","decl":"theorem log_add_one_le_harmonic (n : ℕ) :\n    Real.log ↑(n+1) ≤ harmonic n := by\n  calc _ = ∫ x in (1 : ℕ)..↑(n+1), x⁻¹ := ?_\n       _ ≤ ∑ d ∈ Finset.Icc 1 n, (d : ℝ)⁻¹ := ?_\n       _ = harmonic n := ?_\n  · rw [Nat.cast_one, integral_inv (by simp [(show ¬ (1 : ℝ) ≤ 0 by norm_num)]), div_one]\n  · exact (inv_antitoneOn_Icc_right <| by norm_num).integral_le_sum_Ico (Nat.le_add_left 1 n)\n  · simp only [harmonic_eq_sum_Icc, Rat.cast_sum, Rat.cast_inv, Rat.cast_natCast]\n\n"}
{"name":"harmonic_le_one_add_log","module":"Mathlib.NumberTheory.Harmonic.Bounds","initialProofState":"n : Nat\n⊢ LE.le (↑(harmonic n)) (HAdd.hAdd 1 (Real.log ↑n))","decl":"theorem harmonic_le_one_add_log (n : ℕ) :\n    harmonic n ≤ 1 + Real.log n := by\n  by_cases hn0 : n = 0\n  · simp [hn0]\n  have hn : 1 ≤ n := Nat.one_le_iff_ne_zero.mpr hn0\n  simp_rw [harmonic_eq_sum_Icc, Rat.cast_sum, Rat.cast_inv, Rat.cast_natCast]\n  rw [← Finset.sum_erase_add (Finset.Icc 1 n) _ (Finset.left_mem_Icc.mpr hn), add_comm,\n    Nat.cast_one, inv_one]\n  refine add_le_add_left ?_ 1\n  simp only [Nat.lt_one_iff, Finset.mem_Icc, Finset.Icc_erase_left]\n  calc ∑ d ∈ .Ico 2 (n + 1), (d : ℝ)⁻¹\n    _ = ∑ d ∈ .Ico 2 (n + 1), (↑(d + 1) - 1)⁻¹ := ?_\n    _ ≤ ∫ x in (2).. ↑(n + 1), (x - 1)⁻¹  := ?_\n    _ = ∫ x in (1)..n, x⁻¹ := ?_\n    _ = Real.log ↑n := ?_\n  · simp_rw [Nat.cast_add, Nat.cast_one, add_sub_cancel_right]\n  · exact @AntitoneOn.sum_le_integral_Ico 2 (n + 1) (fun x : ℝ ↦ (x - 1)⁻¹) (by linarith [hn]) <|\n      sub_inv_antitoneOn_Icc_right (by norm_num)\n  · convert intervalIntegral.integral_comp_sub_right _ 1\n    · norm_num\n    · simp only [Nat.cast_add, Nat.cast_one, add_sub_cancel_right]\n  · convert integral_inv _\n    · rw [div_one]\n    · simp only [Nat.one_le_cast, hn, Set.uIcc_of_le, Set.mem_Icc, Nat.cast_nonneg,\n        and_true, not_le, zero_lt_one]\n\n"}
{"name":"log_le_harmonic_floor","module":"Mathlib.NumberTheory.Harmonic.Bounds","initialProofState":"y : Real\nhy : LE.le 0 y\n⊢ LE.le (Real.log y) ↑(harmonic (Nat.floor y))","decl":"theorem log_le_harmonic_floor (y : ℝ) (hy : 0 ≤ y) :\n    Real.log y ≤ harmonic ⌊y⌋₊ := by\n  by_cases h0 : y = 0\n  · simp [h0]\n  · calc\n      _ ≤ Real.log ↑(Nat.floor y + 1) := ?_\n      _ ≤ _ := log_add_one_le_harmonic _\n    gcongr\n    apply (Nat.le_ceil y).trans\n    norm_cast\n    exact Nat.ceil_le_floor_add_one y\n\n"}
{"name":"harmonic_floor_le_one_add_log","module":"Mathlib.NumberTheory.Harmonic.Bounds","initialProofState":"y : Real\nhy : LE.le 1 y\n⊢ LE.le (↑(harmonic (Nat.floor y))) (HAdd.hAdd 1 (Real.log y))","decl":"theorem harmonic_floor_le_one_add_log (y : ℝ) (hy : 1 ≤ y) :\n    harmonic ⌊y⌋₊ ≤ 1 + Real.log y := by\n  refine (harmonic_le_one_add_log _).trans ?_\n  gcongr\n  · exact_mod_cast Nat.floor_pos.mpr hy\n  · exact Nat.floor_le <| zero_le_one.trans hy\n"}
