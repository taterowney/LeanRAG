{"name":"instIsTransNatLeHAddOfNat","module":"Mathlib.Data.Nat.Fib.Zeckendorf","initialProofState":"⊢ IsTrans Nat fun a b => LE.le (HAdd.hAdd b 2) a","decl":"@[nolint defLemma docBlame]\nlocal instance : IsTrans ℕ fun a b ↦ b + 2 ≤ a where\n  trans _a _b _c hba hcb := hcb.trans <| le_self_add.trans hba\n\n"}
{"name":"List.IsZeckendorfRep_nil","module":"Mathlib.Data.Nat.Fib.Zeckendorf","initialProofState":"⊢ List.nil.IsZeckendorfRep","decl":"@[simp]\nlemma IsZeckendorfRep_nil : IsZeckendorfRep [] := by simp [IsZeckendorfRep]\n\n"}
{"name":"List.IsZeckendorfRep.sum_fib_lt","module":"Mathlib.Data.Nat.Fib.Zeckendorf","initialProofState":"n : Nat\nl : List Nat\na✝¹ : l.IsZeckendorfRep\na✝ : ∀ (a : Nat), Membership.mem (HAppend.hAppend l (List.cons 0 List.nil)).head? a → LT.lt a n\n⊢ LT.lt (List.map Nat.fib l).sum (Nat.fib n)","decl":"lemma IsZeckendorfRep.sum_fib_lt : ∀ {n l}, IsZeckendorfRep l → (∀ a ∈ (l ++ [0]).head?, a < n) →\n    (l.map fib).sum < fib n\n  | _, [], _, hn => fib_pos.2 <| hn _ rfl\n  | n, a :: l, hl, hn => by\n    simp only [IsZeckendorfRep, cons_append, chain'_iff_pairwise, pairwise_cons] at hl\n    have : ∀ b, b ∈ head? (l ++ [0]) → b < a - 1 :=\n      fun b hb ↦ lt_tsub_iff_right.2 <| hl.1 _ <| mem_of_mem_head? hb\n    simp only [mem_append, mem_singleton, ← chain'_iff_pairwise, or_imp, forall_and, forall_eq,\n      zero_add] at hl\n    simp only [map, List.sum_cons]\n    refine (add_lt_add_left (sum_fib_lt hl.2 this) _).trans_le ?_\n    rw [add_comm, ← fib_add_one (hl.1.2.trans_lt' zero_lt_two).ne']\n    exact fib_mono (hn _ rfl)\n\n"}
{"name":"Nat.fib_greatestFib_le","module":"Mathlib.Data.Nat.Fib.Zeckendorf","initialProofState":"n : Nat\n⊢ LE.le (Nat.fib n.greatestFib) n","decl":"lemma fib_greatestFib_le (n : ℕ) : fib (greatestFib n) ≤ n :=\n  findGreatest_spec (P := (fun k ↦ fib k ≤ n)) (zero_le _) <| zero_le _\n\n"}
{"name":"Nat.greatestFib_mono","module":"Mathlib.Data.Nat.Fib.Zeckendorf","initialProofState":"⊢ Monotone Nat.greatestFib","decl":"lemma greatestFib_mono : Monotone greatestFib :=\n  fun _a _b hab ↦ findGreatest_mono (fun _k ↦ hab.trans') <| add_le_add_right hab _\n\n"}
{"name":"Nat.le_greatestFib","module":"Mathlib.Data.Nat.Fib.Zeckendorf","initialProofState":"m n : Nat\n⊢ Iff (LE.le m n.greatestFib) (LE.le (Nat.fib m) n)","decl":"@[simp] lemma le_greatestFib : m ≤ greatestFib n ↔ fib m ≤ n :=\n  ⟨fun h ↦ (fib_mono h).trans <| fib_greatestFib_le _,\n    fun h ↦ le_findGreatest (m.le_fib_add_one.trans <| add_le_add_right h _) h⟩\n\n"}
{"name":"Nat.greatestFib_lt","module":"Mathlib.Data.Nat.Fib.Zeckendorf","initialProofState":"m n : Nat\n⊢ Iff (LT.lt m.greatestFib n) (LT.lt m (Nat.fib n))","decl":"@[simp] lemma greatestFib_lt : greatestFib m < n ↔ m < fib n :=\n  lt_iff_lt_of_le_iff_le le_greatestFib\n\n"}
{"name":"Nat.lt_fib_greatestFib_add_one","module":"Mathlib.Data.Nat.Fib.Zeckendorf","initialProofState":"n : Nat\n⊢ LT.lt n (Nat.fib (HAdd.hAdd n.greatestFib 1))","decl":"lemma lt_fib_greatestFib_add_one (n : ℕ) : n < fib (greatestFib n + 1) :=\n  greatestFib_lt.1 <| lt_succ_self _\n\n"}
{"name":"Nat.greatestFib_fib","module":"Mathlib.Data.Nat.Fib.Zeckendorf","initialProofState":"n : Nat\na✝ : Ne n 1\n⊢ Eq (Nat.fib n).greatestFib n","decl":"@[simp] lemma greatestFib_fib : ∀ {n}, n ≠ 1 → greatestFib (fib n) = n\n  | 0, _ => rfl\n  | _n + 2, _ => findGreatest_eq_iff.2\n    ⟨le_fib_add_one _, fun _ ↦ le_rfl, fun _m hnm _ ↦ ((fib_lt_fib le_add_self).2 hnm).not_le⟩\n\n"}
{"name":"Nat.greatestFib_eq_zero","module":"Mathlib.Data.Nat.Fib.Zeckendorf","initialProofState":"n : Nat\n⊢ Iff (Eq n.greatestFib 0) (Eq n 0)","decl":"@[simp] lemma greatestFib_eq_zero : greatestFib n = 0 ↔ n = 0 :=\n  ⟨fun h ↦ by simpa using findGreatest_eq_zero_iff.1 h zero_lt_one le_add_self, by rintro rfl; rfl⟩\n\n"}
{"name":"Nat.greatestFib_ne_zero","module":"Mathlib.Data.Nat.Fib.Zeckendorf","initialProofState":"n : Nat\n⊢ Iff (Ne n.greatestFib 0) (Ne n 0)","decl":"lemma greatestFib_ne_zero : greatestFib n ≠ 0 ↔ n ≠ 0 := greatestFib_eq_zero.not\n\n"}
{"name":"Nat.greatestFib_pos","module":"Mathlib.Data.Nat.Fib.Zeckendorf","initialProofState":"n : Nat\n⊢ Iff (LT.lt 0 n.greatestFib) (LT.lt 0 n)","decl":"@[simp] lemma greatestFib_pos : 0 < greatestFib n ↔ 0 < n := by simp [pos_iff_ne_zero]\n\n"}
{"name":"Nat.greatestFib_sub_fib_greatestFib_le_greatestFib","module":"Mathlib.Data.Nat.Fib.Zeckendorf","initialProofState":"n : Nat\nhn : Ne n 0\n⊢ LE.le (HSub.hSub n (Nat.fib n.greatestFib)).greatestFib (HSub.hSub n.greatestFib 2)","decl":"lemma greatestFib_sub_fib_greatestFib_le_greatestFib (hn : n ≠ 0) :\n    greatestFib (n - fib (greatestFib n)) ≤ greatestFib n - 2 := by\n  rw [← Nat.lt_succ_iff, greatestFib_lt, tsub_lt_iff_right n.fib_greatestFib_le, Nat.sub_succ,\n    succ_pred, ← fib_add_one]\n  · exact n.lt_fib_greatestFib_add_one\n  · simpa\n  · simpa [← succ_le_iff, tsub_eq_zero_iff_le] using hn.bot_lt\n\n"}
{"name":"Nat.zeckendorf_zero","module":"Mathlib.Data.Nat.Fib.Zeckendorf","initialProofState":"⊢ Eq (Nat.zeckendorf 0) List.nil","decl":"@[simp] lemma zeckendorf_zero : zeckendorf 0 = [] := zeckendorf.eq_1 ..\n\n"}
{"name":"Nat.zeckendorf_succ","module":"Mathlib.Data.Nat.Fib.Zeckendorf","initialProofState":"n : Nat\n⊢ Eq (HAdd.hAdd n 1).zeckendorf (List.cons (HAdd.hAdd n 1).greatestFib (HSub.hSub (HAdd.hAdd n 1) (Nat.fib (HAdd.hAdd n 1).greatestFib)).zeckendorf)","decl":"@[simp] lemma zeckendorf_succ (n : ℕ) :\n    zeckendorf (n + 1) = greatestFib (n + 1) :: zeckendorf (n + 1 - fib (greatestFib (n + 1))) :=\n  zeckendorf.eq_2 ..\n\n"}
{"name":"Nat.zeckendorf_of_pos","module":"Mathlib.Data.Nat.Fib.Zeckendorf","initialProofState":"n : Nat\na✝ : LT.lt 0 n\n⊢ Eq n.zeckendorf (List.cons n.greatestFib (HSub.hSub n (Nat.fib n.greatestFib)).zeckendorf)","decl":"@[simp] lemma zeckendorf_of_pos : ∀ {n}, 0 < n →\n    zeckendorf n = greatestFib n :: zeckendorf (n - fib (greatestFib n))\n  | _n + 1, _ => zeckendorf_succ _\n\n"}
{"name":"Nat.isZeckendorfRep_zeckendorf","module":"Mathlib.Data.Nat.Fib.Zeckendorf","initialProofState":"n : Nat\n⊢ n.zeckendorf.IsZeckendorfRep","decl":"lemma isZeckendorfRep_zeckendorf : ∀ n, (zeckendorf n).IsZeckendorfRep\n  | 0 => by simp only [zeckendorf_zero, IsZeckendorfRep_nil]\n  | n + 1 => by\n    rw [zeckendorf_succ, IsZeckendorfRep, List.cons_append]\n    refine (isZeckendorfRep_zeckendorf _).cons' (fun a ha ↦ ?_)\n    obtain h | h := eq_zero_or_pos (n + 1 - fib (greatestFib (n + 1)))\n    · simp only [h, zeckendorf_zero, nil_append, head?_cons, Option.mem_some_iff] at ha\n      subst ha\n      exact le_greatestFib.2 le_add_self\n    rw [zeckendorf_of_pos h, cons_append, head?_cons, Option.mem_some_iff] at ha\n    subst a\n    exact add_le_of_le_tsub_right_of_le (le_greatestFib.2 le_add_self)\n      (greatestFib_sub_fib_greatestFib_le_greatestFib n.succ_ne_zero)\n\n"}
{"name":"Nat.zeckendorf_sum_fib","module":"Mathlib.Data.Nat.Fib.Zeckendorf","initialProofState":"l : List Nat\na✝ : l.IsZeckendorfRep\n⊢ Eq (List.map Nat.fib l).sum.zeckendorf l","decl":"lemma zeckendorf_sum_fib : ∀ {l}, IsZeckendorfRep l → zeckendorf (l.map fib).sum = l\n  | [], _ => by simp only [map_nil, List.sum_nil, zeckendorf_zero]\n  | a :: l, hl => by\n    have hl' := hl\n    simp only [IsZeckendorfRep, cons_append, chain'_iff_pairwise, pairwise_cons, mem_append,\n      mem_singleton, or_imp, forall_and, forall_eq, zero_add] at hl\n    rw [← chain'_iff_pairwise] at hl\n    have ha : 0 < a := hl.1.2.trans_lt' zero_lt_two\n    suffices h : greatestFib (fib a + sum (map fib l)) = a by\n      simp only [map, List.sum_cons, add_pos_iff, fib_pos.2 ha, true_or, zeckendorf_of_pos, h,\n      add_tsub_cancel_left, zeckendorf_sum_fib hl.2]\n    simp only [add_comm, add_assoc, greatestFib, findGreatest_eq_iff, ne_eq, ha.ne',\n      not_false_eq_true, le_add_iff_nonneg_left, _root_.zero_le, forall_true_left, not_le, true_and]\n    refine ⟨le_add_of_le_right <| le_fib_add_one _, fun n hn _ ↦ ?_⟩\n    rw [add_comm, ← List.sum_cons, ← map_cons]\n    exact hl'.sum_fib_lt (by simpa)\n\n"}
{"name":"Nat.sum_zeckendorf_fib","module":"Mathlib.Data.Nat.Fib.Zeckendorf","initialProofState":"n : Nat\n⊢ Eq (List.map Nat.fib n.zeckendorf).sum n","decl":"@[simp] lemma sum_zeckendorf_fib (n : ℕ) : (n.zeckendorf.map fib).sum = n := by\n  induction n using zeckendorf.induct <;> simp_all [fib_greatestFib_le]\n\n"}
