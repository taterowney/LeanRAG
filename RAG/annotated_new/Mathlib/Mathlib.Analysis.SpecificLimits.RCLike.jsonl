{"name":"RCLike.tendsto_inverse_atTop_nhds_zero_nat","module":"Mathlib.Analysis.SpecificLimits.RCLike","initialProofState":"𝕜 : Type u_1\ninst✝ : RCLike 𝕜\n⊢ Filter.Tendsto (fun n => Inv.inv ↑n) Filter.atTop (nhds 0)","decl":"theorem RCLike.tendsto_inverse_atTop_nhds_zero_nat :\n    Tendsto (fun n : ℕ => (n : 𝕜)⁻¹) atTop (𝓝 0) := by\n  convert tendsto_algebraMap_inverse_atTop_nhds_zero_nat 𝕜\n  simp\n\n"}
{"name":"RCLike.tendsto_add_mul_div_add_mul_atTop_nhds","module":"Mathlib.Analysis.SpecificLimits.RCLike","initialProofState":"𝕜 : Type u_1\ninst✝ : RCLike 𝕜\na b c d : 𝕜\nhd : Ne d 0\n⊢ Filter.Tendsto (fun k => HDiv.hDiv (HAdd.hAdd a (HMul.hMul c ↑k)) (HAdd.hAdd b (HMul.hMul d ↑k))) Filter.atTop (nhds (HDiv.hDiv c d))","decl":"theorem RCLike.tendsto_add_mul_div_add_mul_atTop_nhds (a b c : 𝕜) {d : 𝕜} (hd : d ≠ 0) :\n    Tendsto (fun k : ℕ ↦ (a + c * k) / (b + d * k)) atTop (𝓝 (c / d)) := by\n  apply Filter.Tendsto.congr'\n  case f₁ => exact fun k ↦ (a * (↑k)⁻¹ + c) / (b * (↑k)⁻¹ + d)\n  · refine (eventually_ne_atTop 0).mp (Eventually.of_forall ?_)\n    intro h hx\n    field_simp [hx]\n  · apply Filter.Tendsto.div _ _ hd\n    all_goals\n      apply zero_add (_ : 𝕜) ▸ Filter.Tendsto.add_const _ _\n      apply mul_zero (_ : 𝕜) ▸ Filter.Tendsto.const_mul _ _\n      exact RCLike.tendsto_inverse_atTop_nhds_zero_nat 𝕜\n"}
