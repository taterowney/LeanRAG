{"name":"CategoryTheory.Presheaf.freeYoneda_map","module":"Mathlib.CategoryTheory.Generator.Presheaf","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nA : Type u'\ninst‚úù¬π : CategoryTheory.Category.{v', u'} A\ninst‚úù : CategoryTheory.Limits.HasCoproducts A\nX : C\nM : A\nX‚úù Y‚úù : Opposite C\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Presheaf.freeYoneda X M).map f) (CategoryTheory.Limits.Sigma.map' ((CategoryTheory.yoneda.obj X).map f) fun x => CategoryTheory.CategoryStruct.id M)","decl":"/-- Given `X : C` and `M : A`, this is the presheaf `C·µí·µñ ‚•§ A` which sends\n`Y : C·µí·µñ` to the coproduct of copies of `M` indexed by `Y.unop ‚ü∂ X`. -/\n@[simps]\nnoncomputable def freeYoneda (X : C) (M : A) : C·µí·µñ ‚•§ A where\n  obj Y := ‚àê (fun (i : (yoneda.obj X).obj Y) ‚Ü¶ M)\n  map f := Sigma.map' ((yoneda.obj X).map f) (fun _ ‚Ü¶ ùüô M)\n\n"}
{"name":"CategoryTheory.Presheaf.freeYoneda_obj","module":"Mathlib.CategoryTheory.Generator.Presheaf","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nA : Type u'\ninst‚úù¬π : CategoryTheory.Category.{v', u'} A\ninst‚úù : CategoryTheory.Limits.HasCoproducts A\nX : C\nM : A\nY : Opposite C\n‚ä¢ Eq ((CategoryTheory.Presheaf.freeYoneda X M).obj Y) (CategoryTheory.Limits.sigmaObj fun i => M)","decl":"/-- Given `X : C` and `M : A`, this is the presheaf `C·µí·µñ ‚•§ A` which sends\n`Y : C·µí·µñ` to the coproduct of copies of `M` indexed by `Y.unop ‚ü∂ X`. -/\n@[simps]\nnoncomputable def freeYoneda (X : C) (M : A) : C·µí·µñ ‚•§ A where\n  obj Y := ‚àê (fun (i : (yoneda.obj X).obj Y) ‚Ü¶ M)\n  map f := Sigma.map' ((yoneda.obj X).map f) (fun _ ‚Ü¶ ùüô M)\n\n"}
{"name":"CategoryTheory.Presheaf.freeYonedaHomEquiv_comp","module":"Mathlib.CategoryTheory.Generator.Presheaf","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nA : Type u'\ninst‚úù¬π : CategoryTheory.Category.{v', u'} A\ninst‚úù : CategoryTheory.Limits.HasCoproducts A\nX : C\nM : A\nF G : CategoryTheory.Functor (Opposite C) A\nŒ± : Quiver.Hom (CategoryTheory.Presheaf.freeYoneda X M) F\nf : Quiver.Hom F G\n‚ä¢ Eq (CategoryTheory.Presheaf.freeYonedaHomEquiv (CategoryTheory.CategoryStruct.comp Œ± f)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Presheaf.freeYonedaHomEquiv Œ±) (f.app { unop := X }))","decl":"@[reassoc]\nlemma freeYonedaHomEquiv_comp {X : C} {M : A} {F G : C·µí·µñ ‚•§ A}\n    (Œ± : freeYoneda X M ‚ü∂ F) (f : F ‚ü∂ G) :\n    freeYonedaHomEquiv (Œ± ‚â´ f) = freeYonedaHomEquiv Œ± ‚â´ f.app (op X) := by\n  simp [freeYonedaHomEquiv]\n\n"}
{"name":"CategoryTheory.Presheaf.freeYonedaHomEquiv_comp_assoc","module":"Mathlib.CategoryTheory.Generator.Presheaf","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nA : Type u'\ninst‚úù¬π : CategoryTheory.Category.{v', u'} A\ninst‚úù : CategoryTheory.Limits.HasCoproducts A\nX : C\nM : A\nF G : CategoryTheory.Functor (Opposite C) A\nŒ± : Quiver.Hom (CategoryTheory.Presheaf.freeYoneda X M) F\nf : Quiver.Hom F G\nZ : A\nh : Quiver.Hom (G.obj { unop := X }) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Presheaf.freeYonedaHomEquiv (CategoryTheory.CategoryStruct.comp Œ± f)) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Presheaf.freeYonedaHomEquiv Œ±) (CategoryTheory.CategoryStruct.comp (f.app { unop := X }) h))","decl":"@[reassoc]\nlemma freeYonedaHomEquiv_comp {X : C} {M : A} {F G : C·µí·µñ ‚•§ A}\n    (Œ± : freeYoneda X M ‚ü∂ F) (f : F ‚ü∂ G) :\n    freeYonedaHomEquiv (Œ± ‚â´ f) = freeYonedaHomEquiv Œ± ‚â´ f.app (op X) := by\n  simp [freeYonedaHomEquiv]\n\n"}
{"name":"CategoryTheory.Presheaf.freeYonedaHomEquiv_symm_comp_assoc","module":"Mathlib.CategoryTheory.Generator.Presheaf","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nA : Type u'\ninst‚úù¬π : CategoryTheory.Category.{v', u'} A\ninst‚úù : CategoryTheory.Limits.HasCoproducts A\nX : C\nM : A\nF G : CategoryTheory.Functor (Opposite C) A\nŒ± : Quiver.Hom M (F.obj { unop := X })\nf : Quiver.Hom F G\nZ : CategoryTheory.Functor (Opposite C) A\nh : Quiver.Hom G Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Presheaf.freeYonedaHomEquiv.symm Œ±) (CategoryTheory.CategoryStruct.comp f h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Presheaf.freeYonedaHomEquiv.symm (CategoryTheory.CategoryStruct.comp Œ± (f.app { unop := X }))) h)","decl":"@[reassoc]\nlemma freeYonedaHomEquiv_symm_comp {X : C} {M : A} {F G : C·µí·µñ ‚•§ A} (Œ± : M ‚ü∂ F.obj (op X))\n    (f : F ‚ü∂ G) :\n    freeYonedaHomEquiv.symm Œ± ‚â´ f = freeYonedaHomEquiv.symm (Œ± ‚â´ f.app (op X)) := by\n  obtain ‚ü®Œ≤, rfl‚ü© := freeYonedaHomEquiv.surjective Œ±\n  apply freeYonedaHomEquiv.injective\n  simp only [Equiv.symm_apply_apply, freeYonedaHomEquiv_comp, Equiv.apply_symm_apply]\n\n"}
{"name":"CategoryTheory.Presheaf.freeYonedaHomEquiv_symm_comp","module":"Mathlib.CategoryTheory.Generator.Presheaf","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nA : Type u'\ninst‚úù¬π : CategoryTheory.Category.{v', u'} A\ninst‚úù : CategoryTheory.Limits.HasCoproducts A\nX : C\nM : A\nF G : CategoryTheory.Functor (Opposite C) A\nŒ± : Quiver.Hom M (F.obj { unop := X })\nf : Quiver.Hom F G\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Presheaf.freeYonedaHomEquiv.symm Œ±) f) (CategoryTheory.Presheaf.freeYonedaHomEquiv.symm (CategoryTheory.CategoryStruct.comp Œ± (f.app { unop := X })))","decl":"@[reassoc]\nlemma freeYonedaHomEquiv_symm_comp {X : C} {M : A} {F G : C·µí·µñ ‚•§ A} (Œ± : M ‚ü∂ F.obj (op X))\n    (f : F ‚ü∂ G) :\n    freeYonedaHomEquiv.symm Œ± ‚â´ f = freeYonedaHomEquiv.symm (Œ± ‚â´ f.app (op X)) := by\n  obtain ‚ü®Œ≤, rfl‚ü© := freeYonedaHomEquiv.surjective Œ±\n  apply freeYonedaHomEquiv.injective\n  simp only [Equiv.symm_apply_apply, freeYonedaHomEquiv_comp, Equiv.apply_symm_apply]\n\n"}
{"name":"CategoryTheory.Presheaf.isSeparating","module":"Mathlib.CategoryTheory.Generator.Presheaf","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nA : Type u'\ninst‚úù¬π : CategoryTheory.Category.{v', u'} A\ninst‚úù : CategoryTheory.Limits.HasCoproducts A\nŒπ : Type w\nS : Œπ ‚Üí A\nhS : CategoryTheory.IsSeparating (Set.range S)\n‚ä¢ CategoryTheory.IsSeparating (Set.range fun x => CategoryTheory.Presheaf.isSeparating.match_1 C (fun x => CategoryTheory.Functor (Opposite C) A) x fun X i => CategoryTheory.Presheaf.freeYoneda X (S i))","decl":"lemma isSeparating {Œπ : Type w} {S : Œπ ‚Üí A} (hS : IsSeparating (Set.range S)) :\n    IsSeparating (Set.range (fun (‚ü®X, i‚ü© : C √ó Œπ) ‚Ü¶ freeYoneda X (S i))) := by\n  intro F G f g h\n  ext ‚ü®X‚ü©\n  refine hS _ _ ?_\n  rintro _ ‚ü®i, rfl‚ü© Œ±\n  apply freeYonedaHomEquiv.symm.injective\n  simpa only [freeYonedaHomEquiv_symm_comp] using\n    h _ ‚ü®‚ü®X, i‚ü©, rfl‚ü© (freeYonedaHomEquiv.symm Œ±)\n\n"}
{"name":"CategoryTheory.Presheaf.isSeparator","module":"Mathlib.CategoryTheory.Generator.Presheaf","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\nA : Type u'\ninst‚úù¬≥ : CategoryTheory.Category.{v', u'} A\ninst‚úù¬≤ : CategoryTheory.Limits.HasCoproducts A\nŒπ : Type w\nS : Œπ ‚Üí A\nhS : CategoryTheory.IsSeparating (Set.range S)\ninst‚úù¬π : CategoryTheory.Limits.HasCoproduct fun x => CategoryTheory.Presheaf.isSeparating.match_1 C (fun x => CategoryTheory.Functor (Opposite C) A) x fun X i => CategoryTheory.Presheaf.freeYoneda X (S i)\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms A\n‚ä¢ CategoryTheory.IsSeparator (CategoryTheory.Limits.sigmaObj fun x => CategoryTheory.Presheaf.isSeparating.match_1 C (fun x => CategoryTheory.Functor (Opposite C) A) x fun X i => CategoryTheory.Presheaf.freeYoneda X (S i))","decl":"lemma isSeparator {Œπ : Type w} {S : Œπ ‚Üí A} (hS : IsSeparating (Set.range S))\n    [HasCoproduct (fun (‚ü®X, i‚ü© : C √ó Œπ) ‚Ü¶ freeYoneda X (S i))]\n    [HasZeroMorphisms A] :\n    IsSeparator (‚àê (fun (‚ü®X, i‚ü© : C √ó Œπ) ‚Ü¶ freeYoneda X (S i))) :=\n  (isSeparating C hS).isSeparator_coproduct\n\n"}
{"name":"CategoryTheory.Presheaf.hasSeparator","module":"Mathlib.CategoryTheory.Generator.Presheaf","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\nA : Type u'\ninst‚úù‚Å¥ : CategoryTheory.Category.{v', u'} A\ninst‚úù¬≥ : CategoryTheory.Limits.HasCoproducts A\ninst‚úù¬≤ : CategoryTheory.HasSeparator A\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms A\ninst‚úù : CategoryTheory.Limits.HasCoproducts A\n‚ä¢ CategoryTheory.HasSeparator (CategoryTheory.Functor (Opposite C) A)","decl":"variable (A) in\ninstance hasSeparator [HasSeparator A] [HasZeroMorphisms A] [HasCoproducts.{u} A] :\n    HasSeparator (C·µí·µñ ‚•§ A) where\n  hasSeparator := ‚ü®_, isSeparator C (S := fun (_ : Unit) ‚Ü¶ separator A)\n      (by simpa using isSeparator_separator A)‚ü©\n\n"}
