{"name":"EuclideanDomain.toNontrivial","module":"Mathlib.Algebra.EuclideanDomain.Defs","initialProofState":"R : Type u\nself : EuclideanDomain R\n⊢ Nontrivial R","decl":"/-- A `EuclideanDomain` is a non-trivial commutative ring with a division and a remainder,\n  satisfying `b * (a / b) + a % b = a`.\n  The definition of a Euclidean domain usually includes a valuation function `R → ℕ`.\n  This definition is slightly generalised to include a well founded relation\n  `r` with the property that `r (a % b) b`, instead of a valuation. -/\nclass EuclideanDomain (R : Type u) extends CommRing R, Nontrivial R where\n  /-- A division function (denoted `/`) on `R`.\n    This satisfies the property `b * (a / b) + a % b = a`, where `%` denotes `remainder`. -/\n  protected quotient : R → R → R\n  /-- Division by zero should always give zero by convention. -/\n  protected quotient_zero : ∀ a, quotient a 0 = 0\n  /-- A remainder function (denoted `%`) on `R`.\n    This satisfies the property `b * (a / b) + a % b = a`, where `/` denotes `quotient`. -/\n  protected remainder : R → R → R\n  /-- The property that links the quotient and remainder functions.\n    This allows us to compute GCDs and LCMs. -/\n  protected quotient_mul_add_remainder_eq : ∀ a b, b * quotient a b + remainder a b = a\n  /-- A well-founded relation on `R`, satisfying `r (a % b) b`.\n    This ensures that the GCD algorithm always terminates. -/\n  protected r : R → R → Prop\n  /-- The relation `r` must be well-founded.\n    This ensures that the GCD algorithm always terminates. -/\n  r_wellFounded : WellFounded r\n  /-- The relation `r` satisfies `r (a % b) b`. -/\n  protected remainder_lt : ∀ (a) {b}, b ≠ 0 → r (remainder a b) b\n  /-- An additional constraint on `r`. -/\n  mul_left_not_lt : ∀ (a) {b}, b ≠ 0 → ¬r (a * b) a\n\n"}
{"name":"EuclideanDomain.remainder_lt","module":"Mathlib.Algebra.EuclideanDomain.Defs","initialProofState":"R : Type u\nself : EuclideanDomain R\na b : R\na✝ : Ne b 0\n⊢ EuclideanDomain.r (EuclideanDomain.remainder a b) b","decl":"/-- A `EuclideanDomain` is a non-trivial commutative ring with a division and a remainder,\n  satisfying `b * (a / b) + a % b = a`.\n  The definition of a Euclidean domain usually includes a valuation function `R → ℕ`.\n  This definition is slightly generalised to include a well founded relation\n  `r` with the property that `r (a % b) b`, instead of a valuation. -/\nclass EuclideanDomain (R : Type u) extends CommRing R, Nontrivial R where\n  /-- A division function (denoted `/`) on `R`.\n    This satisfies the property `b * (a / b) + a % b = a`, where `%` denotes `remainder`. -/\n  protected quotient : R → R → R\n  /-- Division by zero should always give zero by convention. -/\n  protected quotient_zero : ∀ a, quotient a 0 = 0\n  /-- A remainder function (denoted `%`) on `R`.\n    This satisfies the property `b * (a / b) + a % b = a`, where `/` denotes `quotient`. -/\n  protected remainder : R → R → R\n  /-- The property that links the quotient and remainder functions.\n    This allows us to compute GCDs and LCMs. -/\n  protected quotient_mul_add_remainder_eq : ∀ a b, b * quotient a b + remainder a b = a\n  /-- A well-founded relation on `R`, satisfying `r (a % b) b`.\n    This ensures that the GCD algorithm always terminates. -/\n  protected r : R → R → Prop\n  /-- The relation `r` must be well-founded.\n    This ensures that the GCD algorithm always terminates. -/\n  r_wellFounded : WellFounded r\n  /-- The relation `r` satisfies `r (a % b) b`. -/\n  protected remainder_lt : ∀ (a) {b}, b ≠ 0 → r (remainder a b) b\n  /-- An additional constraint on `r`. -/\n  mul_left_not_lt : ∀ (a) {b}, b ≠ 0 → ¬r (a * b) a\n\n"}
{"name":"EuclideanDomain.r_wellFounded","module":"Mathlib.Algebra.EuclideanDomain.Defs","initialProofState":"R : Type u\nself : EuclideanDomain R\n⊢ WellFounded EuclideanDomain.r","decl":"/-- A `EuclideanDomain` is a non-trivial commutative ring with a division and a remainder,\n  satisfying `b * (a / b) + a % b = a`.\n  The definition of a Euclidean domain usually includes a valuation function `R → ℕ`.\n  This definition is slightly generalised to include a well founded relation\n  `r` with the property that `r (a % b) b`, instead of a valuation. -/\nclass EuclideanDomain (R : Type u) extends CommRing R, Nontrivial R where\n  /-- A division function (denoted `/`) on `R`.\n    This satisfies the property `b * (a / b) + a % b = a`, where `%` denotes `remainder`. -/\n  protected quotient : R → R → R\n  /-- Division by zero should always give zero by convention. -/\n  protected quotient_zero : ∀ a, quotient a 0 = 0\n  /-- A remainder function (denoted `%`) on `R`.\n    This satisfies the property `b * (a / b) + a % b = a`, where `/` denotes `quotient`. -/\n  protected remainder : R → R → R\n  /-- The property that links the quotient and remainder functions.\n    This allows us to compute GCDs and LCMs. -/\n  protected quotient_mul_add_remainder_eq : ∀ a b, b * quotient a b + remainder a b = a\n  /-- A well-founded relation on `R`, satisfying `r (a % b) b`.\n    This ensures that the GCD algorithm always terminates. -/\n  protected r : R → R → Prop\n  /-- The relation `r` must be well-founded.\n    This ensures that the GCD algorithm always terminates. -/\n  r_wellFounded : WellFounded r\n  /-- The relation `r` satisfies `r (a % b) b`. -/\n  protected remainder_lt : ∀ (a) {b}, b ≠ 0 → r (remainder a b) b\n  /-- An additional constraint on `r`. -/\n  mul_left_not_lt : ∀ (a) {b}, b ≠ 0 → ¬r (a * b) a\n\n"}
{"name":"EuclideanDomain.quotient_mul_add_remainder_eq","module":"Mathlib.Algebra.EuclideanDomain.Defs","initialProofState":"R : Type u\nself : EuclideanDomain R\na b : R\n⊢ Eq (HAdd.hAdd (HMul.hMul b (EuclideanDomain.quotient a b)) (EuclideanDomain.remainder a b)) a","decl":"/-- A `EuclideanDomain` is a non-trivial commutative ring with a division and a remainder,\n  satisfying `b * (a / b) + a % b = a`.\n  The definition of a Euclidean domain usually includes a valuation function `R → ℕ`.\n  This definition is slightly generalised to include a well founded relation\n  `r` with the property that `r (a % b) b`, instead of a valuation. -/\nclass EuclideanDomain (R : Type u) extends CommRing R, Nontrivial R where\n  /-- A division function (denoted `/`) on `R`.\n    This satisfies the property `b * (a / b) + a % b = a`, where `%` denotes `remainder`. -/\n  protected quotient : R → R → R\n  /-- Division by zero should always give zero by convention. -/\n  protected quotient_zero : ∀ a, quotient a 0 = 0\n  /-- A remainder function (denoted `%`) on `R`.\n    This satisfies the property `b * (a / b) + a % b = a`, where `/` denotes `quotient`. -/\n  protected remainder : R → R → R\n  /-- The property that links the quotient and remainder functions.\n    This allows us to compute GCDs and LCMs. -/\n  protected quotient_mul_add_remainder_eq : ∀ a b, b * quotient a b + remainder a b = a\n  /-- A well-founded relation on `R`, satisfying `r (a % b) b`.\n    This ensures that the GCD algorithm always terminates. -/\n  protected r : R → R → Prop\n  /-- The relation `r` must be well-founded.\n    This ensures that the GCD algorithm always terminates. -/\n  r_wellFounded : WellFounded r\n  /-- The relation `r` satisfies `r (a % b) b`. -/\n  protected remainder_lt : ∀ (a) {b}, b ≠ 0 → r (remainder a b) b\n  /-- An additional constraint on `r`. -/\n  mul_left_not_lt : ∀ (a) {b}, b ≠ 0 → ¬r (a * b) a\n\n"}
{"name":"EuclideanDomain.mul_left_not_lt","module":"Mathlib.Algebra.EuclideanDomain.Defs","initialProofState":"R : Type u\nself : EuclideanDomain R\na b : R\na✝ : Ne b 0\n⊢ Not (EuclideanDomain.r (HMul.hMul a b) a)","decl":"/-- A `EuclideanDomain` is a non-trivial commutative ring with a division and a remainder,\n  satisfying `b * (a / b) + a % b = a`.\n  The definition of a Euclidean domain usually includes a valuation function `R → ℕ`.\n  This definition is slightly generalised to include a well founded relation\n  `r` with the property that `r (a % b) b`, instead of a valuation. -/\nclass EuclideanDomain (R : Type u) extends CommRing R, Nontrivial R where\n  /-- A division function (denoted `/`) on `R`.\n    This satisfies the property `b * (a / b) + a % b = a`, where `%` denotes `remainder`. -/\n  protected quotient : R → R → R\n  /-- Division by zero should always give zero by convention. -/\n  protected quotient_zero : ∀ a, quotient a 0 = 0\n  /-- A remainder function (denoted `%`) on `R`.\n    This satisfies the property `b * (a / b) + a % b = a`, where `/` denotes `quotient`. -/\n  protected remainder : R → R → R\n  /-- The property that links the quotient and remainder functions.\n    This allows us to compute GCDs and LCMs. -/\n  protected quotient_mul_add_remainder_eq : ∀ a b, b * quotient a b + remainder a b = a\n  /-- A well-founded relation on `R`, satisfying `r (a % b) b`.\n    This ensures that the GCD algorithm always terminates. -/\n  protected r : R → R → Prop\n  /-- The relation `r` must be well-founded.\n    This ensures that the GCD algorithm always terminates. -/\n  r_wellFounded : WellFounded r\n  /-- The relation `r` satisfies `r (a % b) b`. -/\n  protected remainder_lt : ∀ (a) {b}, b ≠ 0 → r (remainder a b) b\n  /-- An additional constraint on `r`. -/\n  mul_left_not_lt : ∀ (a) {b}, b ≠ 0 → ¬r (a * b) a\n\n"}
{"name":"EuclideanDomain.quotient_zero","module":"Mathlib.Algebra.EuclideanDomain.Defs","initialProofState":"R : Type u\nself : EuclideanDomain R\na : R\n⊢ Eq (EuclideanDomain.quotient a 0) 0","decl":"/-- A `EuclideanDomain` is a non-trivial commutative ring with a division and a remainder,\n  satisfying `b * (a / b) + a % b = a`.\n  The definition of a Euclidean domain usually includes a valuation function `R → ℕ`.\n  This definition is slightly generalised to include a well founded relation\n  `r` with the property that `r (a % b) b`, instead of a valuation. -/\nclass EuclideanDomain (R : Type u) extends CommRing R, Nontrivial R where\n  /-- A division function (denoted `/`) on `R`.\n    This satisfies the property `b * (a / b) + a % b = a`, where `%` denotes `remainder`. -/\n  protected quotient : R → R → R\n  /-- Division by zero should always give zero by convention. -/\n  protected quotient_zero : ∀ a, quotient a 0 = 0\n  /-- A remainder function (denoted `%`) on `R`.\n    This satisfies the property `b * (a / b) + a % b = a`, where `/` denotes `quotient`. -/\n  protected remainder : R → R → R\n  /-- The property that links the quotient and remainder functions.\n    This allows us to compute GCDs and LCMs. -/\n  protected quotient_mul_add_remainder_eq : ∀ a b, b * quotient a b + remainder a b = a\n  /-- A well-founded relation on `R`, satisfying `r (a % b) b`.\n    This ensures that the GCD algorithm always terminates. -/\n  protected r : R → R → Prop\n  /-- The relation `r` must be well-founded.\n    This ensures that the GCD algorithm always terminates. -/\n  r_wellFounded : WellFounded r\n  /-- The relation `r` satisfies `r (a % b) b`. -/\n  protected remainder_lt : ∀ (a) {b}, b ≠ 0 → r (remainder a b) b\n  /-- An additional constraint on `r`. -/\n  mul_left_not_lt : ∀ (a) {b}, b ≠ 0 → ¬r (a * b) a\n\n"}
{"name":"EuclideanDomain.isWellFounded","module":"Mathlib.Algebra.EuclideanDomain.Defs","initialProofState":"R : Type u\ninst✝ : EuclideanDomain R\n⊢ IsWellFounded R fun x1 x2 => EuclideanDomain.r x1 x2","decl":"instance isWellFounded : IsWellFounded R (· ≺ ·) where\n  wf := r_wellFounded\n\n-- see Note [lower instance priority]\n"}
{"name":"EuclideanDomain.div_add_mod","module":"Mathlib.Algebra.EuclideanDomain.Defs","initialProofState":"R : Type u\ninst✝ : EuclideanDomain R\na b : R\n⊢ Eq (HAdd.hAdd (HMul.hMul b (HDiv.hDiv a b)) (HMod.hMod a b)) a","decl":"theorem div_add_mod (a b : R) : b * (a / b) + a % b = a :=\n  EuclideanDomain.quotient_mul_add_remainder_eq _ _\n\n"}
{"name":"EuclideanDomain.mod_add_div","module":"Mathlib.Algebra.EuclideanDomain.Defs","initialProofState":"R : Type u\ninst✝ : EuclideanDomain R\na b : R\n⊢ Eq (HAdd.hAdd (HMod.hMod a b) (HMul.hMul b (HDiv.hDiv a b))) a","decl":"theorem mod_add_div (a b : R) : a % b + b * (a / b) = a :=\n  (add_comm _ _).trans (div_add_mod _ _)\n\n"}
{"name":"EuclideanDomain.mod_add_div'","module":"Mathlib.Algebra.EuclideanDomain.Defs","initialProofState":"R : Type u\ninst✝ : EuclideanDomain R\nm k : R\n⊢ Eq (HAdd.hAdd (HMod.hMod m k) (HMul.hMul (HDiv.hDiv m k) k)) m","decl":"theorem mod_add_div' (m k : R) : m % k + m / k * k = m := by\n  rw [mul_comm]\n  exact mod_add_div _ _\n\n"}
{"name":"EuclideanDomain.div_add_mod'","module":"Mathlib.Algebra.EuclideanDomain.Defs","initialProofState":"R : Type u\ninst✝ : EuclideanDomain R\nm k : R\n⊢ Eq (HAdd.hAdd (HMul.hMul (HDiv.hDiv m k) k) (HMod.hMod m k)) m","decl":"theorem div_add_mod' (m k : R) : m / k * k + m % k = m := by\n  rw [mul_comm]\n  exact div_add_mod _ _\n\n"}
{"name":"EuclideanDomain.mod_eq_sub_mul_div","module":"Mathlib.Algebra.EuclideanDomain.Defs","initialProofState":"R : Type u_1\ninst✝ : EuclideanDomain R\na b : R\n⊢ Eq (HMod.hMod a b) (HSub.hSub a (HMul.hMul b (HDiv.hDiv a b)))","decl":"theorem mod_eq_sub_mul_div {R : Type*} [EuclideanDomain R] (a b : R) : a % b = a - b * (a / b) :=\n  calc\n    a % b = b * (a / b) + a % b - b * (a / b) := (add_sub_cancel_left _ _).symm\n    _ = a - b * (a / b) := by rw [div_add_mod]\n\n"}
{"name":"EuclideanDomain.mod_lt","module":"Mathlib.Algebra.EuclideanDomain.Defs","initialProofState":"R : Type u\ninst✝ : EuclideanDomain R\na b : R\na✝ : Ne b 0\n⊢ EuclideanDomain.r (HMod.hMod a b) b","decl":"theorem mod_lt : ∀ (a) {b : R}, b ≠ 0 → a % b ≺ b :=\n  EuclideanDomain.remainder_lt\n\n"}
{"name":"EuclideanDomain.mul_right_not_lt","module":"Mathlib.Algebra.EuclideanDomain.Defs","initialProofState":"R : Type u\ninst✝ : EuclideanDomain R\na b : R\nh : Ne a 0\n⊢ Not (EuclideanDomain.r (HMul.hMul a b) b)","decl":"theorem mul_right_not_lt {a : R} (b) (h : a ≠ 0) : ¬a * b ≺ b := by\n  rw [mul_comm]\n  exact mul_left_not_lt b h\n\n"}
{"name":"EuclideanDomain.mod_zero","module":"Mathlib.Algebra.EuclideanDomain.Defs","initialProofState":"R : Type u\ninst✝ : EuclideanDomain R\na : R\n⊢ Eq (HMod.hMod a 0) a","decl":"@[simp]\ntheorem mod_zero (a : R) : a % 0 = a := by simpa only [zero_mul, zero_add] using div_add_mod a 0\n\n"}
{"name":"EuclideanDomain.lt_one","module":"Mathlib.Algebra.EuclideanDomain.Defs","initialProofState":"R : Type u\ninst✝ : EuclideanDomain R\na : R\na✝ : EuclideanDomain.r a 1\n⊢ Eq a 0","decl":"theorem lt_one (a : R) : a ≺ (1 : R) → a = 0 :=\n  haveI := Classical.dec\n  not_imp_not.1 fun h => by simpa only [one_mul] using mul_left_not_lt 1 h\n\n"}
{"name":"EuclideanDomain.val_dvd_le","module":"Mathlib.Algebra.EuclideanDomain.Defs","initialProofState":"R : Type u\ninst✝ : EuclideanDomain R\na b : R\na✝¹ : Dvd.dvd b a\na✝ : Ne a 0\n⊢ Not (EuclideanDomain.r a b)","decl":"theorem val_dvd_le : ∀ a b : R, b ∣ a → a ≠ 0 → ¬a ≺ b\n  | _, b, ⟨d, rfl⟩, ha => mul_left_not_lt b (mt (by rintro rfl; exact mul_zero _) ha)\n\n"}
{"name":"EuclideanDomain.div_zero","module":"Mathlib.Algebra.EuclideanDomain.Defs","initialProofState":"R : Type u\ninst✝ : EuclideanDomain R\na : R\n⊢ Eq (HDiv.hDiv a 0) 0","decl":"@[simp]\ntheorem div_zero (a : R) : a / 0 = 0 :=\n  EuclideanDomain.quotient_zero a\n\n"}
{"name":"EuclideanDomain.GCD.induction","module":"Mathlib.Algebra.EuclideanDomain.Defs","initialProofState":"R : Type u\ninst✝ : EuclideanDomain R\nP : R → R → Prop\na b : R\nH0 : ∀ (x : R), P 0 x\nH1 : ∀ (a b : R), Ne a 0 → P (HMod.hMod b a) a → P a b\n⊢ P a b","decl":"@[elab_as_elim]\ntheorem GCD.induction {P : R → R → Prop} (a b : R) (H0 : ∀ x, P 0 x)\n    (H1 : ∀ a b, a ≠ 0 → P (b % a) a → P a b) : P a b := by\n  classical\n  exact if a0 : a = 0 then\n    a0.symm ▸ H0 b\n  else\n    have _ := mod_lt b a0\n    H1 _ _ a0 (GCD.induction (b % a) a H0 H1)\ntermination_by a\n\n"}
{"name":"EuclideanDomain.gcd_zero_left","module":"Mathlib.Algebra.EuclideanDomain.Defs","initialProofState":"R : Type u\ninst✝¹ : EuclideanDomain R\ninst✝ : DecidableEq R\na : R\n⊢ Eq (EuclideanDomain.gcd 0 a) a","decl":"@[simp]\ntheorem gcd_zero_left (a : R) : gcd 0 a = a := by\n  rw [gcd]\n  exact if_pos rfl\n\n"}
{"name":"EuclideanDomain.xgcd_zero_left","module":"Mathlib.Algebra.EuclideanDomain.Defs","initialProofState":"R : Type u\ninst✝¹ : EuclideanDomain R\ninst✝ : DecidableEq R\ns t r' s' t' : R\n⊢ Eq (EuclideanDomain.xgcdAux 0 s t r' s' t') { fst := r', snd := { fst := s', snd := t' } }","decl":"@[simp]\ntheorem xgcd_zero_left {s t r' s' t' : R} : xgcdAux 0 s t r' s' t' = (r', s', t') := by\n  unfold xgcdAux\n  exact if_pos rfl\n\n"}
{"name":"EuclideanDomain.xgcdAux_rec","module":"Mathlib.Algebra.EuclideanDomain.Defs","initialProofState":"R : Type u\ninst✝¹ : EuclideanDomain R\ninst✝ : DecidableEq R\nr s t r' s' t' : R\nh : Ne r 0\n⊢ Eq (EuclideanDomain.xgcdAux r s t r' s' t') (EuclideanDomain.xgcdAux (HMod.hMod r' r) (HSub.hSub s' (HMul.hMul (HDiv.hDiv r' r) s)) (HSub.hSub t' (HMul.hMul (HDiv.hDiv r' r) t)) r s t)","decl":"theorem xgcdAux_rec {r s t r' s' t' : R} (h : r ≠ 0) :\n    xgcdAux r s t r' s' t' = xgcdAux (r' % r) (s' - r' / r * s) (t' - r' / r * t) r s t := by\n  conv =>\n    lhs\n    rw [xgcdAux]\n  exact if_neg h\n\n"}
{"name":"EuclideanDomain.gcdA_zero_left","module":"Mathlib.Algebra.EuclideanDomain.Defs","initialProofState":"R : Type u\ninst✝¹ : EuclideanDomain R\ninst✝ : DecidableEq R\ns : R\n⊢ Eq (EuclideanDomain.gcdA 0 s) 0","decl":"@[simp]\ntheorem gcdA_zero_left {s : R} : gcdA 0 s = 0 := by\n  unfold gcdA\n  rw [xgcd, xgcd_zero_left]\n\n"}
{"name":"EuclideanDomain.gcdB_zero_left","module":"Mathlib.Algebra.EuclideanDomain.Defs","initialProofState":"R : Type u\ninst✝¹ : EuclideanDomain R\ninst✝ : DecidableEq R\ns : R\n⊢ Eq (EuclideanDomain.gcdB 0 s) 1","decl":"@[simp]\ntheorem gcdB_zero_left {s : R} : gcdB 0 s = 1 := by\n  unfold gcdB\n  rw [xgcd, xgcd_zero_left]\n\n"}
{"name":"EuclideanDomain.xgcd_val","module":"Mathlib.Algebra.EuclideanDomain.Defs","initialProofState":"R : Type u\ninst✝¹ : EuclideanDomain R\ninst✝ : DecidableEq R\nx y : R\n⊢ Eq (EuclideanDomain.xgcd x y) { fst := EuclideanDomain.gcdA x y, snd := EuclideanDomain.gcdB x y }","decl":"theorem xgcd_val (x y : R) : xgcd x y = (gcdA x y, gcdB x y) :=\n  rfl\n\n"}
