{"name":"SpectrumRestricts.compactSpace","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Restrict","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\ninst✝⁸ : Semifield R\ninst✝⁷ : Semifield S\ninst✝⁶ : Ring A\ninst✝⁵ : Algebra R S\ninst✝⁴ : Algebra R A\ninst✝³ : Algebra S A\ninst✝² : IsScalarTower R S A\ninst✝¹ : TopologicalSpace R\ninst✝ : TopologicalSpace S\na : A\nf : ContinuousMap S R\nh : SpectrumRestricts a ⇑f\nh_cpct : CompactSpace ↑(spectrum S a)\n⊢ CompactSpace ↑(spectrum R a)","decl":"lemma compactSpace {R S A : Type*} [Semifield R] [Semifield S] [Ring A]\n    [Algebra R S] [Algebra R A] [Algebra S A] [IsScalarTower R S A] [TopologicalSpace R]\n    [TopologicalSpace S] {a : A} (f : C(S, R)) (h : SpectrumRestricts a f)\n    [h_cpct : CompactSpace (spectrum S a)] : CompactSpace (spectrum R a) := by\n  rw [← isCompact_iff_compactSpace] at h_cpct ⊢\n  exact h.image ▸ h_cpct.image (map_continuous f)\n\n"}
{"name":"SpectrumRestricts.starAlgHom_apply","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Restrict","initialProofState":"R : Type u\nS : Type v\nA : Type w\ninst✝¹⁷ : Semifield R\ninst✝¹⁶ : StarRing R\ninst✝¹⁵ : TopologicalSpace R\ninst✝¹⁴ : TopologicalSemiring R\ninst✝¹³ : ContinuousStar R\ninst✝¹² : Semifield S\ninst✝¹¹ : StarRing S\ninst✝¹⁰ : TopologicalSpace S\ninst✝⁹ : TopologicalSemiring S\ninst✝⁸ : ContinuousStar S\ninst✝⁷ : Ring A\ninst✝⁶ : StarRing A\ninst✝⁵ : Algebra R S\ninst✝⁴ : Algebra R A\ninst✝³ : Algebra S A\ninst✝² : IsScalarTower R S A\ninst✝¹ : StarModule R S\ninst✝ : ContinuousSMul R S\na : A\nφ : StarAlgHom S (ContinuousMap (↑(spectrum S a)) S) A\nf : ContinuousMap S R\nh : SpectrumRestricts a ⇑f\na✝ : ContinuousMap (↑(spectrum R a)) R\n⊢ Eq ((SpectrumRestricts.starAlgHom φ h) a✝) (φ ({ toFun := ⇑(StarAlgHom.ofId R S), continuous_toFun := ⋯ }.comp (a✝.comp { toFun := Subtype.map ⇑f ⋯, continuous_toFun := ⋯ })))","decl":"/-- If the spectrum of an element restricts to a smaller scalar ring, then a continuous functional\ncalculus over the larger scalar ring descends to the smaller one. -/\n@[simps!]\ndef starAlgHom {R : Type u} {S : Type v} {A : Type w} [Semifield R]\n    [StarRing R] [TopologicalSpace R] [TopologicalSemiring R] [ContinuousStar R] [Semifield S]\n    [StarRing S] [TopologicalSpace S] [TopologicalSemiring S] [ContinuousStar S] [Ring A]\n    [StarRing A] [Algebra R S] [Algebra R A] [Algebra S A]\n    [IsScalarTower R S A] [StarModule R S] [ContinuousSMul R S] {a : A}\n    (φ : C(spectrum S a, S) →⋆ₐ[S] A) {f : C(S, R)} (h : SpectrumRestricts a f) :\n    C(spectrum R a, R) →⋆ₐ[R] A :=\n  (φ.restrictScalars R).comp <|\n    (ContinuousMap.compStarAlgHom (spectrum S a) (.ofId R S) (algebraMapCLM R S).continuous).comp <|\n      ContinuousMap.compStarAlgHom' R R\n        ⟨Subtype.map f h.subset_preimage, (map_continuous f).subtype_map\n          fun x (hx : x ∈ spectrum S a) => h.subset_preimage hx⟩\n\n"}
{"name":"SpectrumRestricts.starAlgHom_id","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Restrict","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\ninst✝¹⁷ : Semifield R\ninst✝¹⁶ : StarRing R\ninst✝¹⁵ : MetricSpace R\ninst✝¹⁴ : TopologicalSemiring R\ninst✝¹³ : ContinuousStar R\ninst✝¹² : Semifield S\ninst✝¹¹ : StarRing S\ninst✝¹⁰ : MetricSpace S\ninst✝⁹ : TopologicalSemiring S\ninst✝⁸ : ContinuousStar S\ninst✝⁷ : Ring A\ninst✝⁶ : StarRing A\ninst✝⁵ : Algebra S A\ninst✝⁴ : Algebra R S\ninst✝³ : Algebra R A\ninst✝² : IsScalarTower R S A\ninst✝¹ : StarModule R S\ninst✝ : ContinuousSMul R S\na : A\nφ : StarAlgHom S (ContinuousMap (↑(spectrum S a)) S) A\nf : ContinuousMap S R\nh : SpectrumRestricts a ⇑f\nh_id : Eq (φ (ContinuousMap.restrict (spectrum S a) (ContinuousMap.id S))) a\n⊢ Eq ((SpectrumRestricts.starAlgHom φ h) (ContinuousMap.restrict (spectrum R a) (ContinuousMap.id R))) a","decl":"lemma starAlgHom_id {a : A} {φ : C(spectrum S a, S) →⋆ₐ[S] A} {f : C(S, R)}\n    (h : SpectrumRestricts a f) (h_id : φ (.restrict (spectrum S a) <| .id S) = a) :\n    h.starAlgHom φ (.restrict (spectrum R a) <| .id R) = a := by\n  simp only [SpectrumRestricts.starAlgHom_apply]\n  convert h_id\n  ext x\n  exact h.rightInvOn x.2\n\n"}
{"name":"SpectrumRestricts.isClosedEmbedding_starAlgHom","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Restrict","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\ninst✝¹⁹ : Semifield R\ninst✝¹⁸ : StarRing R\ninst✝¹⁷ : MetricSpace R\ninst✝¹⁶ : TopologicalSemiring R\ninst✝¹⁵ : ContinuousStar R\ninst✝¹⁴ : Semifield S\ninst✝¹³ : StarRing S\ninst✝¹² : MetricSpace S\ninst✝¹¹ : TopologicalSemiring S\ninst✝¹⁰ : ContinuousStar S\ninst✝⁹ : Ring A\ninst✝⁸ : StarRing A\ninst✝⁷ : Algebra S A\ninst✝⁶ : Algebra R S\ninst✝⁵ : Algebra R A\ninst✝⁴ : IsScalarTower R S A\ninst✝³ : StarModule R S\ninst✝² : ContinuousSMul R S\ninst✝¹ : TopologicalSpace A\ninst✝ : CompleteSpace R\na : A\nφ : StarAlgHom S (ContinuousMap (↑(spectrum S a)) S) A\nhφ : Topology.IsClosedEmbedding ⇑φ\nf : ContinuousMap S R\nh : SpectrumRestricts a ⇑f\nhalg : IsUniformEmbedding ⇑(algebraMap R S)\n⊢ Topology.IsClosedEmbedding ⇑(SpectrumRestricts.starAlgHom φ h)","decl":"lemma isClosedEmbedding_starAlgHom {a : A} {φ : C(spectrum S a, S) →⋆ₐ[S] A}\n    (hφ : IsClosedEmbedding φ) {f : C(S, R)} (h : SpectrumRestricts a f)\n    (halg : IsUniformEmbedding (algebraMap R S)) :\n    IsClosedEmbedding (h.starAlgHom φ) :=\n  hφ.comp <| IsUniformEmbedding.isClosedEmbedding <| .comp\n    (ContinuousMap.isUniformEmbedding_comp _ halg)\n    (UniformEquiv.arrowCongr h.homeomorph.symm (.refl _) |>.isUniformEmbedding)\n\n"}
{"name":"SpectrumRestricts.closedEmbedding_starAlgHom","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Restrict","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\ninst✝¹⁹ : Semifield R\ninst✝¹⁸ : StarRing R\ninst✝¹⁷ : MetricSpace R\ninst✝¹⁶ : TopologicalSemiring R\ninst✝¹⁵ : ContinuousStar R\ninst✝¹⁴ : Semifield S\ninst✝¹³ : StarRing S\ninst✝¹² : MetricSpace S\ninst✝¹¹ : TopologicalSemiring S\ninst✝¹⁰ : ContinuousStar S\ninst✝⁹ : Ring A\ninst✝⁸ : StarRing A\ninst✝⁷ : Algebra S A\ninst✝⁶ : Algebra R S\ninst✝⁵ : Algebra R A\ninst✝⁴ : IsScalarTower R S A\ninst✝³ : StarModule R S\ninst✝² : ContinuousSMul R S\ninst✝¹ : TopologicalSpace A\ninst✝ : CompleteSpace R\na : A\nφ : StarAlgHom S (ContinuousMap (↑(spectrum S a)) S) A\nhφ : Topology.IsClosedEmbedding ⇑φ\nf : ContinuousMap S R\nh : SpectrumRestricts a ⇑f\nhalg : IsUniformEmbedding ⇑(algebraMap R S)\n⊢ Topology.IsClosedEmbedding ⇑(SpectrumRestricts.starAlgHom φ h)","decl":"@[deprecated (since := \"2024-10-20\")]\nalias closedEmbedding_starAlgHom := isClosedEmbedding_starAlgHom\n\n"}
{"name":"SpectrumRestricts.cfc","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Restrict","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\np q : A → Prop\ninst✝²⁰ : Semifield R\ninst✝¹⁹ : StarRing R\ninst✝¹⁸ : MetricSpace R\ninst✝¹⁷ : TopologicalSemiring R\ninst✝¹⁶ : ContinuousStar R\ninst✝¹⁵ : Semifield S\ninst✝¹⁴ : StarRing S\ninst✝¹³ : MetricSpace S\ninst✝¹² : TopologicalSemiring S\ninst✝¹¹ : ContinuousStar S\ninst✝¹⁰ : Ring A\ninst✝⁹ : StarRing A\ninst✝⁸ : Algebra S A\ninst✝⁷ : Algebra R S\ninst✝⁶ : Algebra R A\ninst✝⁵ : IsScalarTower R S A\ninst✝⁴ : StarModule R S\ninst✝³ : ContinuousSMul R S\ninst✝² : TopologicalSpace A\ninst✝¹ : ContinuousFunctionalCalculus S q\ninst✝ : CompleteSpace R\nf : ContinuousMap S R\nhalg : IsUniformEmbedding ⇑(algebraMap R S)\nh0 : p 0\nh : ∀ (a : A), Iff (p a) (And (q a) (SpectrumRestricts a ⇑f))\n⊢ ContinuousFunctionalCalculus R p","decl":"/-- Given a `ContinuousFunctionalCalculus S q`. If we form the predicate `p` for `a : A`\ncharacterized by: `q a` and the spectrum of `a` restricts to the scalar subring `R` via\n`f : C(S, R)`, then we can get a restricted functional calculus\n`ContinuousFunctionalCalculus R p`. -/\nprotected theorem cfc (f : C(S, R)) (halg : IsUniformEmbedding (algebraMap R S)) (h0 : p 0)\n    (h : ∀ a, p a ↔ q a ∧ SpectrumRestricts a f) :\n    ContinuousFunctionalCalculus R p where\n  predicate_zero := h0\n  spectrum_nonempty a ha := ((h a).mp ha).2.image ▸\n    (ContinuousFunctionalCalculus.spectrum_nonempty a ((h a).mp ha).1 |>.image f)\n  compactSpace_spectrum a := by\n    have := ContinuousFunctionalCalculus.compactSpace_spectrum (R := S) a\n    rw [← isCompact_iff_compactSpace] at this ⊢\n    simpa using halg.isClosedEmbedding.isCompact_preimage this\n  exists_cfc_of_predicate a ha := by\n    refine ⟨((h a).mp ha).2.starAlgHom (cfcHom ((h a).mp ha).1 (R := S)),\n      ?hom_isClosedEmbedding, ?hom_id, ?hom_map_spectrum, ?predicate_hom⟩\n    case hom_isClosedEmbedding =>\n      exact ((h a).mp ha).2.isClosedEmbedding_starAlgHom\n        (cfcHom_isClosedEmbedding ((h a).mp ha).1) halg\n    case hom_id => exact ((h a).mp ha).2.starAlgHom_id <| cfcHom_id ((h a).mp ha).1\n    case hom_map_spectrum =>\n      intro g\n      rw [SpectrumRestricts.starAlgHom_apply]\n      simp only [← @spectrum.preimage_algebraMap (R := R) S, cfcHom_map_spectrum]\n      ext x\n      constructor\n      · rintro ⟨y, hy⟩\n        have := congr_arg f hy\n        simp only [ContinuousMap.coe_mk, ContinuousMap.comp_apply, StarAlgHom.ofId_apply] at this\n        rw [((h a).mp ha).2.left_inv _, ((h a).mp ha).2.left_inv _] at this\n        exact ⟨_, this⟩\n      · rintro ⟨y, rfl⟩\n        rw [Set.mem_preimage]\n        refine ⟨⟨algebraMap R S y, spectrum.algebraMap_mem S y.prop⟩, ?_⟩\n        simp only [ContinuousMap.coe_mk, ContinuousMap.comp_apply, StarAlgHom.ofId_apply]\n        congr\n        exact Subtype.ext (((h a).mp ha).2.left_inv y)\n    case predicate_hom =>\n      intro g\n      rw [h]\n      refine ⟨cfcHom_predicate _ _, ?_⟩\n      refine .of_rightInvOn (((h a).mp ha).2.left_inv) fun s hs ↦ ?_\n      rw [SpectrumRestricts.starAlgHom_apply, cfcHom_map_spectrum] at hs\n      obtain ⟨r, rfl⟩ := hs\n      simp [((h a).mp ha).2.left_inv _]\n\n"}
{"name":"SpectrumRestricts.cfcHom_eq_restrict","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Restrict","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\np q : A → Prop\ninst✝²² : Semifield R\ninst✝²¹ : StarRing R\ninst✝²⁰ : MetricSpace R\ninst✝¹⁹ : TopologicalSemiring R\ninst✝¹⁸ : ContinuousStar R\ninst✝¹⁷ : Semifield S\ninst✝¹⁶ : StarRing S\ninst✝¹⁵ : MetricSpace S\ninst✝¹⁴ : TopologicalSemiring S\ninst✝¹³ : ContinuousStar S\ninst✝¹² : Ring A\ninst✝¹¹ : StarRing A\ninst✝¹⁰ : Algebra S A\ninst✝⁹ : Algebra R S\ninst✝⁸ : Algebra R A\ninst✝⁷ : IsScalarTower R S A\ninst✝⁶ : StarModule R S\ninst✝⁵ : ContinuousSMul R S\ninst✝⁴ : TopologicalSpace A\ninst✝³ : ContinuousFunctionalCalculus S q\ninst✝² : CompleteSpace R\ninst✝¹ : ContinuousFunctionalCalculus R p\ninst✝ : ContinuousMap.UniqueHom R A\nf : ContinuousMap S R\nhalg : IsUniformEmbedding ⇑(algebraMap R S)\na : A\nhpa : p a\nhqa : q a\nh : SpectrumRestricts a ⇑f\n⊢ Eq (cfcHom hpa) (SpectrumRestricts.starAlgHom (cfcHom hqa) h)","decl":"lemma cfcHom_eq_restrict (f : C(S, R)) (halg : IsUniformEmbedding (algebraMap R S))\n    {a : A} (hpa : p a) (hqa : q a) (h : SpectrumRestricts a f) :\n    cfcHom hpa = h.starAlgHom (cfcHom hqa) := by\n  apply cfcHom_eq_of_continuous_of_map_id\n  · exact h.isClosedEmbedding_starAlgHom (cfcHom_isClosedEmbedding hqa) halg |>.continuous\n  · exact h.starAlgHom_id (cfcHom_id hqa)\n\n"}
{"name":"SpectrumRestricts.cfc_eq_restrict","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Restrict","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\np q : A → Prop\ninst✝²² : Semifield R\ninst✝²¹ : StarRing R\ninst✝²⁰ : MetricSpace R\ninst✝¹⁹ : TopologicalSemiring R\ninst✝¹⁸ : ContinuousStar R\ninst✝¹⁷ : Semifield S\ninst✝¹⁶ : StarRing S\ninst✝¹⁵ : MetricSpace S\ninst✝¹⁴ : TopologicalSemiring S\ninst✝¹³ : ContinuousStar S\ninst✝¹² : Ring A\ninst✝¹¹ : StarRing A\ninst✝¹⁰ : Algebra S A\ninst✝⁹ : Algebra R S\ninst✝⁸ : Algebra R A\ninst✝⁷ : IsScalarTower R S A\ninst✝⁶ : StarModule R S\ninst✝⁵ : ContinuousSMul R S\ninst✝⁴ : TopologicalSpace A\ninst✝³ : ContinuousFunctionalCalculus S q\ninst✝² : CompleteSpace R\ninst✝¹ : ContinuousFunctionalCalculus R p\ninst✝ : ContinuousMap.UniqueHom R A\nf : ContinuousMap S R\nhalg : IsUniformEmbedding ⇑(algebraMap R S)\na : A\nhpa : p a\nhqa : q a\nh : SpectrumRestricts a ⇑f\ng : R → R\n⊢ Eq (cfc g a) (cfc (fun x => (algebraMap R S) (g (f x))) a)","decl":"lemma cfc_eq_restrict (f : C(S, R)) (halg : IsUniformEmbedding (algebraMap R S)) {a : A} (hpa : p a)\n    (hqa : q a) (h : SpectrumRestricts a f) (g : R → R) :\n    cfc g a = cfc (fun x ↦ algebraMap R S (g (f x))) a := by\n  by_cases hg : ContinuousOn g (spectrum R a)\n  · rw [cfc_apply g a, cfcHom_eq_restrict f halg hpa hqa h, SpectrumRestricts.starAlgHom_apply,\n      cfcHom_eq_cfc_extend 0]\n    apply cfc_congr fun x hx ↦ ?_\n    lift x to spectrum S a using hx\n    simp [Function.comp, Subtype.val_injective.extend_apply]\n  · have : ¬ ContinuousOn (fun x ↦ algebraMap R S (g (f x)) : S → S) (spectrum S a) := by\n      refine fun hg' ↦ hg ?_\n      rw [halg.isEmbedding.continuousOn_iff]\n      simpa [halg.isEmbedding.continuousOn_iff, Function.comp_def, h.left_inv _] using\n        hg'.comp halg.isEmbedding.continuous.continuousOn (fun _ : R ↦ spectrum.algebraMap_mem S)\n    rw [cfc_apply_of_not_continuousOn a hg, cfc_apply_of_not_continuousOn a this]\n\n"}
{"name":"QuasispectrumRestricts.nonUnitalStarAlgHom_apply","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Restrict","initialProofState":"R : Type u\nS : Type v\nA : Type w\ninst✝¹⁹ : Semifield R\ninst✝¹⁸ : StarRing R\ninst✝¹⁷ : TopologicalSpace R\ninst✝¹⁶ : TopologicalSemiring R\ninst✝¹⁵ : ContinuousStar R\ninst✝¹⁴ : Field S\ninst✝¹³ : StarRing S\ninst✝¹² : TopologicalSpace S\ninst✝¹¹ : TopologicalRing S\ninst✝¹⁰ : ContinuousStar S\ninst✝⁹ : NonUnitalRing A\ninst✝⁸ : StarRing A\ninst✝⁷ : Algebra R S\ninst✝⁶ : Module R A\ninst✝⁵ : Module S A\ninst✝⁴ : IsScalarTower S A A\ninst✝³ : SMulCommClass S A A\ninst✝² : IsScalarTower R S A\ninst✝¹ : StarModule R S\ninst✝ : ContinuousSMul R S\na : A\nφ : NonUnitalStarAlgHom S (ContinuousMapZero (↑(quasispectrum S a)) S) A\nf : ContinuousMap S R\nh : QuasispectrumRestricts a ⇑f\na✝ : ContinuousMapZero (↑(quasispectrum R a)) R\n⊢ Eq ((QuasispectrumRestricts.nonUnitalStarAlgHom φ h) a✝) (φ ({ toFun := ⇑(StarAlgHom.ofId R S), continuous_toFun := ⋯, map_zero' := ⋯ }.comp (a✝.comp { toFun := Subtype.map ⇑f ⋯, continuous_toFun := ⋯, map_zero' := ⋯ })))","decl":"/-- If the quasispectrum of an element restricts to a smaller scalar ring, then a non-unital\ncontinuous functional calculus over the larger scalar ring descends to the smaller one. -/\n@[simps!]\ndef nonUnitalStarAlgHom {R : Type u} {S : Type v} {A : Type w} [Semifield R]\n    [StarRing R] [TopologicalSpace R] [TopologicalSemiring R] [ContinuousStar R] [Field S]\n    [StarRing S] [TopologicalSpace S] [TopologicalRing S] [ContinuousStar S] [NonUnitalRing A]\n    [StarRing A] [Algebra R S] [Module R A] [Module S A] [IsScalarTower S A A] [SMulCommClass S A A]\n    [IsScalarTower R S A] [StarModule R S] [ContinuousSMul R S] {a : A}\n    (φ : C(σₙ S a, S)₀ →⋆ₙₐ[S] A) {f : C(S, R)} (h : QuasispectrumRestricts a f) :\n    C(σₙ R a, R)₀ →⋆ₙₐ[R] A :=\n  (φ.restrictScalars R).comp <|\n    (nonUnitalStarAlgHom_postcomp (σₙ S a) (StarAlgHom.ofId R S) (algebraMapCLM R S).continuous)\n      |>.comp <| nonUnitalStarAlgHom_precomp R\n        ⟨⟨Subtype.map f h.subset_preimage, (map_continuous f).subtype_map\n          fun x (hx : x ∈ σₙ S a) => h.subset_preimage hx⟩, Subtype.ext h.map_zero⟩\n\n"}
{"name":"QuasispectrumRestricts.nonUnitalStarAlgHom_id","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Restrict","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\ninst✝¹⁹ : Semifield R\ninst✝¹⁸ : StarRing R\ninst✝¹⁷ : MetricSpace R\ninst✝¹⁶ : TopologicalSemiring R\ninst✝¹⁵ : ContinuousStar R\ninst✝¹⁴ : Field S\ninst✝¹³ : StarRing S\ninst✝¹² : MetricSpace S\ninst✝¹¹ : TopologicalRing S\ninst✝¹⁰ : ContinuousStar S\ninst✝⁹ : NonUnitalRing A\ninst✝⁸ : StarRing A\ninst✝⁷ : Module S A\ninst✝⁶ : IsScalarTower S A A\ninst✝⁵ : SMulCommClass S A A\ninst✝⁴ : Algebra R S\ninst✝³ : Module R A\ninst✝² : IsScalarTower R S A\ninst✝¹ : StarModule R S\ninst✝ : ContinuousSMul R S\na : A\nφ : NonUnitalStarAlgHom S (ContinuousMapZero (↑(quasispectrum S a)) S) A\nf : ContinuousMap S R\nh : QuasispectrumRestricts a ⇑f\nh_id : Eq (φ (ContinuousMapZero.id ⋯)) a\n⊢ Eq ((QuasispectrumRestricts.nonUnitalStarAlgHom φ h) (ContinuousMapZero.id ⋯)) a","decl":"lemma nonUnitalStarAlgHom_id {a : A} {φ : C(σₙ S a, S)₀ →⋆ₙₐ[S] A} {f : C(S, R)}\n    (h : QuasispectrumRestricts a f) (h_id : φ (.id rfl) = a) :\n    h.nonUnitalStarAlgHom φ (.id rfl) = a := by\n  simp only [QuasispectrumRestricts.nonUnitalStarAlgHom_apply]\n  convert h_id\n  ext x\n  exact h.rightInvOn x.2\n\n"}
{"name":"QuasispectrumRestricts.isClosedEmbedding_nonUnitalStarAlgHom","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Restrict","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\ninst✝²¹ : Semifield R\ninst✝²⁰ : StarRing R\ninst✝¹⁹ : MetricSpace R\ninst✝¹⁸ : TopologicalSemiring R\ninst✝¹⁷ : ContinuousStar R\ninst✝¹⁶ : Field S\ninst✝¹⁵ : StarRing S\ninst✝¹⁴ : MetricSpace S\ninst✝¹³ : TopologicalRing S\ninst✝¹² : ContinuousStar S\ninst✝¹¹ : NonUnitalRing A\ninst✝¹⁰ : StarRing A\ninst✝⁹ : Module S A\ninst✝⁸ : IsScalarTower S A A\ninst✝⁷ : SMulCommClass S A A\ninst✝⁶ : Algebra R S\ninst✝⁵ : Module R A\ninst✝⁴ : IsScalarTower R S A\ninst✝³ : StarModule R S\ninst✝² : ContinuousSMul R S\ninst✝¹ : TopologicalSpace A\ninst✝ : CompleteSpace R\na : A\nφ : NonUnitalStarAlgHom S (ContinuousMapZero (↑(quasispectrum S a)) S) A\nhφ : Topology.IsClosedEmbedding ⇑φ\nf : ContinuousMap S R\nh : QuasispectrumRestricts a ⇑f\nhalg : IsUniformEmbedding ⇑(algebraMap R S)\n⊢ Topology.IsClosedEmbedding ⇑(QuasispectrumRestricts.nonUnitalStarAlgHom φ h)","decl":"lemma isClosedEmbedding_nonUnitalStarAlgHom {a : A} {φ : C(σₙ S a, S)₀ →⋆ₙₐ[S] A}\n    (hφ : IsClosedEmbedding φ) {f : C(S, R)} (h : QuasispectrumRestricts a f)\n    (halg : IsUniformEmbedding (algebraMap R S)) :\n    IsClosedEmbedding (h.nonUnitalStarAlgHom φ) := by\n  have : h.homeomorph.symm 0 = 0 := Subtype.ext (map_zero <| algebraMap _ _)\n  refine hφ.comp <| IsUniformEmbedding.isClosedEmbedding <| .comp\n    (ContinuousMapZero.isUniformEmbedding_comp _ halg)\n    (UniformEquiv.arrowCongrLeft₀ h.homeomorph.symm this |>.isUniformEmbedding)\n\n"}
{"name":"QuasispectrumRestricts.closedEmbedding_nonUnitalStarAlgHom","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Restrict","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\ninst✝²¹ : Semifield R\ninst✝²⁰ : StarRing R\ninst✝¹⁹ : MetricSpace R\ninst✝¹⁸ : TopologicalSemiring R\ninst✝¹⁷ : ContinuousStar R\ninst✝¹⁶ : Field S\ninst✝¹⁵ : StarRing S\ninst✝¹⁴ : MetricSpace S\ninst✝¹³ : TopologicalRing S\ninst✝¹² : ContinuousStar S\ninst✝¹¹ : NonUnitalRing A\ninst✝¹⁰ : StarRing A\ninst✝⁹ : Module S A\ninst✝⁸ : IsScalarTower S A A\ninst✝⁷ : SMulCommClass S A A\ninst✝⁶ : Algebra R S\ninst✝⁵ : Module R A\ninst✝⁴ : IsScalarTower R S A\ninst✝³ : StarModule R S\ninst✝² : ContinuousSMul R S\ninst✝¹ : TopologicalSpace A\ninst✝ : CompleteSpace R\na : A\nφ : NonUnitalStarAlgHom S (ContinuousMapZero (↑(quasispectrum S a)) S) A\nhφ : Topology.IsClosedEmbedding ⇑φ\nf : ContinuousMap S R\nh : QuasispectrumRestricts a ⇑f\nhalg : IsUniformEmbedding ⇑(algebraMap R S)\n⊢ Topology.IsClosedEmbedding ⇑(QuasispectrumRestricts.nonUnitalStarAlgHom φ h)","decl":"@[deprecated (since := \"2024-10-20\")]\nalias closedEmbedding_nonUnitalStarAlgHom := isClosedEmbedding_nonUnitalStarAlgHom\n\n"}
{"name":"QuasispectrumRestricts.cfc","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Restrict","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\np q : A → Prop\ninst✝²⁴ : Semifield R\ninst✝²³ : StarRing R\ninst✝²² : MetricSpace R\ninst✝²¹ : TopologicalSemiring R\ninst✝²⁰ : ContinuousStar R\ninst✝¹⁹ : Field S\ninst✝¹⁸ : StarRing S\ninst✝¹⁷ : MetricSpace S\ninst✝¹⁶ : TopologicalRing S\ninst✝¹⁵ : ContinuousStar S\ninst✝¹⁴ : NonUnitalRing A\ninst✝¹³ : StarRing A\ninst✝¹² : Module S A\ninst✝¹¹ : IsScalarTower S A A\ninst✝¹⁰ : SMulCommClass S A A\ninst✝⁹ : Algebra R S\ninst✝⁸ : Module R A\ninst✝⁷ : IsScalarTower R S A\ninst✝⁶ : StarModule R S\ninst✝⁵ : ContinuousSMul R S\ninst✝⁴ : TopologicalSpace A\ninst✝³ : NonUnitalContinuousFunctionalCalculus S q\ninst✝² : CompleteSpace R\ninst✝¹ : IsScalarTower R A A\ninst✝ : SMulCommClass R A A\nf : ContinuousMap S R\nhalg : IsUniformEmbedding ⇑(algebraMap R S)\nh0 : p 0\nh : ∀ (a : A), Iff (p a) (And (q a) (QuasispectrumRestricts a ⇑f))\n⊢ NonUnitalContinuousFunctionalCalculus R p","decl":"/-- Given a `NonUnitalContinuousFunctionalCalculus S q`. If we form the predicate `p` for `a : A`\ncharacterized by: `q a` and the quasispectrum of `a` restricts to the scalar subring `R` via\n`f : C(S, R)`, then we can get a restricted functional calculus\n`NonUnitalContinuousFunctionalCalculus R p`. -/\nprotected theorem cfc (f : C(S, R)) (halg : IsUniformEmbedding (algebraMap R S)) (h0 : p 0)\n    (h : ∀ a, p a ↔ q a ∧ QuasispectrumRestricts a f) :\n    NonUnitalContinuousFunctionalCalculus R p where\n  predicate_zero := h0\n  compactSpace_quasispectrum a := by\n    have := NonUnitalContinuousFunctionalCalculus.compactSpace_quasispectrum (R := S) a\n    rw [← isCompact_iff_compactSpace] at this ⊢\n    simpa using halg.isClosedEmbedding.isCompact_preimage this\n  exists_cfc_of_predicate a ha := by\n    refine ⟨((h a).mp ha).2.nonUnitalStarAlgHom (cfcₙHom ((h a).mp ha).1 (R := S)),\n      ?hom_isClosedEmbedding, ?hom_id, ?hom_map_spectrum, ?predicate_hom⟩\n    case hom_isClosedEmbedding =>\n      exact ((h a).mp ha).2.isClosedEmbedding_nonUnitalStarAlgHom\n        (cfcₙHom_isClosedEmbedding ((h a).mp ha).1) halg\n    case hom_id => exact ((h a).mp ha).2.nonUnitalStarAlgHom_id <| cfcₙHom_id ((h a).mp ha).1\n    case hom_map_spectrum =>\n      intro g\n      rw [nonUnitalStarAlgHom_apply]\n      simp only [← @quasispectrum.preimage_algebraMap (R := R) S, cfcₙHom_map_quasispectrum]\n      ext x\n      constructor\n      · rintro ⟨y, hy⟩\n        have := congr_arg f hy\n        simp only [nonUnitalStarAlgHom_postcomp_apply, NonUnitalStarAlgHom.coe_coe,\n          Function.comp_apply, comp_apply, coe_mk, ContinuousMap.coe_mk, StarAlgHom.ofId_apply]\n          at this\n        rw [((h a).mp ha).2.left_inv _, ((h a).mp ha).2.left_inv _] at this\n        exact ⟨_, this⟩\n      · rintro ⟨y, rfl⟩\n        rw [Set.mem_preimage]\n        refine ⟨⟨algebraMap R S y, quasispectrum.algebraMap_mem S y.prop⟩, ?_⟩\n        simp only [nonUnitalStarAlgHom_postcomp_apply, NonUnitalStarAlgHom.coe_coe,\n          Function.comp_apply, comp_apply, coe_mk, ContinuousMap.coe_mk, StarAlgHom.ofId_apply]\n        congr\n        exact Subtype.ext (((h a).mp ha).2.left_inv y)\n    case predicate_hom =>\n      intro g\n      rw [h]\n      refine ⟨cfcₙHom_predicate _ _, ?_⟩\n      refine { rightInvOn := fun s hs ↦ ?_, left_inv := ((h a).mp ha).2.left_inv }\n      rw [nonUnitalStarAlgHom_apply,\n        cfcₙHom_map_quasispectrum] at hs\n      obtain ⟨r, rfl⟩ := hs\n      simp [((h a).mp ha).2.left_inv _]\n\n"}
{"name":"QuasispectrumRestricts.cfcₙHom_eq_restrict","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Restrict","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\np q : A → Prop\ninst✝²⁶ : Semifield R\ninst✝²⁵ : StarRing R\ninst✝²⁴ : MetricSpace R\ninst✝²³ : TopologicalSemiring R\ninst✝²² : ContinuousStar R\ninst✝²¹ : Field S\ninst✝²⁰ : StarRing S\ninst✝¹⁹ : MetricSpace S\ninst✝¹⁸ : TopologicalRing S\ninst✝¹⁷ : ContinuousStar S\ninst✝¹⁶ : NonUnitalRing A\ninst✝¹⁵ : StarRing A\ninst✝¹⁴ : Module S A\ninst✝¹³ : IsScalarTower S A A\ninst✝¹² : SMulCommClass S A A\ninst✝¹¹ : Algebra R S\ninst✝¹⁰ : Module R A\ninst✝⁹ : IsScalarTower R S A\ninst✝⁸ : StarModule R S\ninst✝⁷ : ContinuousSMul R S\ninst✝⁶ : TopologicalSpace A\ninst✝⁵ : NonUnitalContinuousFunctionalCalculus S q\ninst✝⁴ : CompleteSpace R\ninst✝³ : IsScalarTower R A A\ninst✝² : SMulCommClass R A A\ninst✝¹ : NonUnitalContinuousFunctionalCalculus R p\ninst✝ : ContinuousMapZero.UniqueHom R A\nf : ContinuousMap S R\nhalg : IsUniformEmbedding ⇑(algebraMap R S)\na : A\nhpa : p a\nhqa : q a\nh : QuasispectrumRestricts a ⇑f\n⊢ Eq (cfcₙHom hpa) (QuasispectrumRestricts.nonUnitalStarAlgHom (cfcₙHom hqa) h)","decl":"lemma cfcₙHom_eq_restrict (f : C(S, R)) (halg : IsUniformEmbedding (algebraMap R S)) {a : A}\n    (hpa : p a) (hqa : q a) (h : QuasispectrumRestricts a f) :\n    cfcₙHom hpa = h.nonUnitalStarAlgHom (cfcₙHom hqa) := by\n  apply cfcₙHom_eq_of_continuous_of_map_id\n  · exact h.isClosedEmbedding_nonUnitalStarAlgHom (cfcₙHom_isClosedEmbedding hqa) halg |>.continuous\n  · exact h.nonUnitalStarAlgHom_id (cfcₙHom_id hqa)\n\n"}
{"name":"QuasispectrumRestricts.cfcₙ_eq_restrict","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Restrict","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\np q : A → Prop\ninst✝²⁶ : Semifield R\ninst✝²⁵ : StarRing R\ninst✝²⁴ : MetricSpace R\ninst✝²³ : TopologicalSemiring R\ninst✝²² : ContinuousStar R\ninst✝²¹ : Field S\ninst✝²⁰ : StarRing S\ninst✝¹⁹ : MetricSpace S\ninst✝¹⁸ : TopologicalRing S\ninst✝¹⁷ : ContinuousStar S\ninst✝¹⁶ : NonUnitalRing A\ninst✝¹⁵ : StarRing A\ninst✝¹⁴ : Module S A\ninst✝¹³ : IsScalarTower S A A\ninst✝¹² : SMulCommClass S A A\ninst✝¹¹ : Algebra R S\ninst✝¹⁰ : Module R A\ninst✝⁹ : IsScalarTower R S A\ninst✝⁸ : StarModule R S\ninst✝⁷ : ContinuousSMul R S\ninst✝⁶ : TopologicalSpace A\ninst✝⁵ : NonUnitalContinuousFunctionalCalculus S q\ninst✝⁴ : CompleteSpace R\ninst✝³ : IsScalarTower R A A\ninst✝² : SMulCommClass R A A\ninst✝¹ : NonUnitalContinuousFunctionalCalculus R p\ninst✝ : ContinuousMapZero.UniqueHom R A\nf : ContinuousMap S R\nhalg : IsUniformEmbedding ⇑(algebraMap R S)\na : A\nhpa : p a\nhqa : q a\nh : QuasispectrumRestricts a ⇑f\ng : R → R\n⊢ Eq (cfcₙ g a) (cfcₙ (fun x => (algebraMap R S) (g (f x))) a)","decl":"lemma cfcₙ_eq_restrict (f : C(S, R)) (halg : IsUniformEmbedding (algebraMap R S)) {a : A}\n    (hpa : p a) (hqa : q a) (h : QuasispectrumRestricts a f) (g : R → R) :\n    cfcₙ g a = cfcₙ (fun x ↦ algebraMap R S (g (f x))) a := by\n  by_cases hg : ContinuousOn g (σₙ R a) ∧ g 0 = 0\n  · obtain ⟨hg, hg0⟩ := hg\n    rw [cfcₙ_apply g a, cfcₙHom_eq_restrict f halg hpa hqa h, nonUnitalStarAlgHom_apply,\n      cfcₙHom_eq_cfcₙ_extend 0]\n    apply cfcₙ_congr fun x hx ↦ ?_\n    lift x to σₙ S a using hx\n    simp [Function.comp, Subtype.val_injective.extend_apply]\n  · simp only [not_and_or] at hg\n    obtain (hg | hg) := hg\n    · have : ¬ ContinuousOn (fun x ↦ algebraMap R S (g (f x)) : S → S) (σₙ S a) := by\n        refine fun hg' ↦ hg ?_\n        rw [halg.isEmbedding.continuousOn_iff]\n        simpa [halg.isEmbedding.continuousOn_iff, Function.comp_def, h.left_inv _] using\n          hg'.comp halg.isEmbedding.continuous.continuousOn\n          (fun _ : R ↦ quasispectrum.algebraMap_mem S)\n      rw [cfcₙ_apply_of_not_continuousOn a hg, cfcₙ_apply_of_not_continuousOn a this]\n    · rw [cfcₙ_apply_of_not_map_zero a hg, cfcₙ_apply_of_not_map_zero a (by simpa [h.map_zero])]\n\n"}
