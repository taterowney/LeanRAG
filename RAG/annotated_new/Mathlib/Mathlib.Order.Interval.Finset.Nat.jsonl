{"name":"Nat.Icc_eq_range'","module":"Mathlib.Order.Interval.Finset.Nat","initialProofState":"a b : Nat\n⊢ Eq (Finset.Icc a b) { val := ↑(List.range' a (HSub.hSub (HAdd.hAdd b 1) a)), nodup := ⋯ }","decl":"theorem Icc_eq_range' : Icc a b = ⟨List.range' a (b + 1 - a), List.nodup_range' _ _⟩ :=\n  rfl\n\n"}
{"name":"Nat.Ico_eq_range'","module":"Mathlib.Order.Interval.Finset.Nat","initialProofState":"a b : Nat\n⊢ Eq (Finset.Ico a b) { val := ↑(List.range' a (HSub.hSub b a)), nodup := ⋯ }","decl":"theorem Ico_eq_range' : Ico a b = ⟨List.range' a (b - a), List.nodup_range' _ _⟩ :=\n  rfl\n\n"}
{"name":"Nat.Ioc_eq_range'","module":"Mathlib.Order.Interval.Finset.Nat","initialProofState":"a b : Nat\n⊢ Eq (Finset.Ioc a b) { val := ↑(List.range' (HAdd.hAdd a 1) (HSub.hSub b a)), nodup := ⋯ }","decl":"theorem Ioc_eq_range' : Ioc a b = ⟨List.range' (a + 1) (b - a), List.nodup_range' _ _⟩ :=\n  rfl\n\n"}
{"name":"Nat.Ioo_eq_range'","module":"Mathlib.Order.Interval.Finset.Nat","initialProofState":"a b : Nat\n⊢ Eq (Finset.Ioo a b) { val := ↑(List.range' (HAdd.hAdd a 1) (HSub.hSub (HSub.hSub b a) 1)), nodup := ⋯ }","decl":"theorem Ioo_eq_range' : Ioo a b = ⟨List.range' (a + 1) (b - a - 1), List.nodup_range' _ _⟩ :=\n  rfl\n\n"}
{"name":"Nat.uIcc_eq_range'","module":"Mathlib.Order.Interval.Finset.Nat","initialProofState":"a b : Nat\n⊢ Eq (Finset.uIcc a b) { val := ↑(List.range' (Min.min a b) (HSub.hSub (HAdd.hAdd (Max.max a b) 1) (Min.min a b))), nodup := ⋯ }","decl":"theorem uIcc_eq_range' :\n    uIcc a b = ⟨List.range' (min a b) (max a b + 1 - min a b), List.nodup_range' _ _⟩ := rfl\n\n"}
{"name":"Nat.Iio_eq_range","module":"Mathlib.Order.Interval.Finset.Nat","initialProofState":"⊢ Eq Finset.Iio Finset.range","decl":"theorem Iio_eq_range : Iio = range := by\n  ext b x\n  rw [mem_Iio, mem_range]\n\n"}
{"name":"Nat.Ico_zero_eq_range","module":"Mathlib.Order.Interval.Finset.Nat","initialProofState":"⊢ Eq (Finset.Ico 0) Finset.range","decl":"@[simp]\ntheorem Ico_zero_eq_range : Ico 0 = range := by rw [← Nat.bot_eq_zero, ← Iio_eq_Ico, Iio_eq_range]\n\n"}
{"name":"Nat.range_eq_Icc_zero_sub_one","module":"Mathlib.Order.Interval.Finset.Nat","initialProofState":"n : Nat\nhn : Ne n 0\n⊢ Eq (Finset.range n) (Finset.Icc 0 (HSub.hSub n 1))","decl":"lemma range_eq_Icc_zero_sub_one (n : ℕ) (hn : n ≠ 0) : range n = Icc 0 (n - 1) := by\n  ext b\n  simp_all only [mem_Icc, zero_le, true_and, mem_range]\n  exact lt_iff_le_pred (zero_lt_of_ne_zero hn)\n\n"}
{"name":"Finset.range_eq_Ico","module":"Mathlib.Order.Interval.Finset.Nat","initialProofState":"⊢ Eq Finset.range (Finset.Ico 0)","decl":"theorem _root_.Finset.range_eq_Ico : range = Ico 0 :=\n  Ico_zero_eq_range.symm\n\n"}
{"name":"Nat.range_succ_eq_Icc_zero","module":"Mathlib.Order.Interval.Finset.Nat","initialProofState":"n : Nat\n⊢ Eq (Finset.range (HAdd.hAdd n 1)) (Finset.Icc 0 n)","decl":"theorem range_succ_eq_Icc_zero (n : ℕ) : range (n + 1) = Icc 0 n := by\n  rw [range_eq_Icc_zero_sub_one _ (Nat.add_one_ne_zero _), Nat.add_sub_cancel_right]\n\n"}
{"name":"Nat.card_Icc","module":"Mathlib.Order.Interval.Finset.Nat","initialProofState":"a b : Nat\n⊢ Eq (Finset.Icc a b).card (HSub.hSub (HAdd.hAdd b 1) a)","decl":"@[simp] lemma card_Icc : #(Icc a b) = b + 1 - a := List.length_range' ..\n"}
{"name":"Nat.card_Ico","module":"Mathlib.Order.Interval.Finset.Nat","initialProofState":"a b : Nat\n⊢ Eq (Finset.Ico a b).card (HSub.hSub b a)","decl":"@[simp] lemma card_Ico : #(Ico a b) = b - a := List.length_range' ..\n"}
{"name":"Nat.card_Ioc","module":"Mathlib.Order.Interval.Finset.Nat","initialProofState":"a b : Nat\n⊢ Eq (Finset.Ioc a b).card (HSub.hSub b a)","decl":"@[simp] lemma card_Ioc : #(Ioc a b) = b - a := List.length_range' ..\n"}
{"name":"Nat.card_Ioo","module":"Mathlib.Order.Interval.Finset.Nat","initialProofState":"a b : Nat\n⊢ Eq (Finset.Ioo a b).card (HSub.hSub (HSub.hSub b a) 1)","decl":"@[simp] lemma card_Ioo : #(Ioo a b) = b - a - 1 := List.length_range' ..\n\n"}
{"name":"Nat.card_uIcc","module":"Mathlib.Order.Interval.Finset.Nat","initialProofState":"a b : Nat\n⊢ Eq (Finset.uIcc a b).card (HAdd.hAdd (HSub.hSub ↑b ↑a).natAbs 1)","decl":"@[simp]\ntheorem card_uIcc : #(uIcc a b) = (b - a : ℤ).natAbs + 1 :=\n  (card_Icc _ _).trans <| by rw [← Int.natCast_inj, Int.ofNat_sub] <;> omega\n\n"}
{"name":"Nat.card_Iic","module":"Mathlib.Order.Interval.Finset.Nat","initialProofState":"b : Nat\n⊢ Eq (Finset.Iic b).card (HAdd.hAdd b 1)","decl":"@[simp]\nlemma card_Iic : #(Iic b) = b + 1 := by rw [Iic_eq_Icc, card_Icc, Nat.bot_eq_zero, Nat.sub_zero]\n\n"}
{"name":"Nat.card_Iio","module":"Mathlib.Order.Interval.Finset.Nat","initialProofState":"b : Nat\n⊢ Eq (Finset.Iio b).card b","decl":"@[simp]\ntheorem card_Iio : #(Iio b) = b := by rw [Iio_eq_Ico, card_Ico, Nat.bot_eq_zero, Nat.sub_zero]\n\n"}
{"name":"Nat.card_fintypeIcc","module":"Mathlib.Order.Interval.Finset.Nat","initialProofState":"a b : Nat\n⊢ Eq (Fintype.card ↑(Set.Icc a b)) (HSub.hSub (HAdd.hAdd b 1) a)","decl":"theorem card_fintypeIcc : Fintype.card (Set.Icc a b) = b + 1 - a := by\n  rw [Fintype.card_ofFinset, card_Icc]\n\n"}
{"name":"Nat.card_fintypeIco","module":"Mathlib.Order.Interval.Finset.Nat","initialProofState":"a b : Nat\n⊢ Eq (Fintype.card ↑(Set.Ico a b)) (HSub.hSub b a)","decl":"theorem card_fintypeIco : Fintype.card (Set.Ico a b) = b - a := by\n  rw [Fintype.card_ofFinset, card_Ico]\n\n"}
{"name":"Nat.card_fintypeIoc","module":"Mathlib.Order.Interval.Finset.Nat","initialProofState":"a b : Nat\n⊢ Eq (Fintype.card ↑(Set.Ioc a b)) (HSub.hSub b a)","decl":"theorem card_fintypeIoc : Fintype.card (Set.Ioc a b) = b - a := by\n  rw [Fintype.card_ofFinset, card_Ioc]\n\n"}
{"name":"Nat.card_fintypeIoo","module":"Mathlib.Order.Interval.Finset.Nat","initialProofState":"a b : Nat\n⊢ Eq (Fintype.card ↑(Set.Ioo a b)) (HSub.hSub (HSub.hSub b a) 1)","decl":"theorem card_fintypeIoo : Fintype.card (Set.Ioo a b) = b - a - 1 := by\n  rw [Fintype.card_ofFinset, card_Ioo]\n\n"}
{"name":"Nat.card_fintypeIic","module":"Mathlib.Order.Interval.Finset.Nat","initialProofState":"b : Nat\n⊢ Eq (Fintype.card ↑(Set.Iic b)) (HAdd.hAdd b 1)","decl":"theorem card_fintypeIic : Fintype.card (Set.Iic b) = b + 1 := by\n  rw [Fintype.card_ofFinset, card_Iic]\n\n"}
{"name":"Nat.card_fintypeIio","module":"Mathlib.Order.Interval.Finset.Nat","initialProofState":"b : Nat\n⊢ Eq (Fintype.card ↑(Set.Iio b)) b","decl":"theorem card_fintypeIio : Fintype.card (Set.Iio b) = b := by rw [Fintype.card_ofFinset, card_Iio]\n\n-- TODO@Yaël: Generalize all the following lemmas to `SuccOrder`\n"}
{"name":"Nat.Icc_succ_left","module":"Mathlib.Order.Interval.Finset.Nat","initialProofState":"a b : Nat\n⊢ Eq (Finset.Icc a.succ b) (Finset.Ioc a b)","decl":"theorem Icc_succ_left : Icc a.succ b = Ioc a b := by\n  ext x\n  rw [mem_Icc, mem_Ioc, succ_le_iff]\n\n"}
{"name":"Nat.Ico_succ_right","module":"Mathlib.Order.Interval.Finset.Nat","initialProofState":"a b : Nat\n⊢ Eq (Finset.Ico a b.succ) (Finset.Icc a b)","decl":"theorem Ico_succ_right : Ico a b.succ = Icc a b := by\n  ext x\n  rw [mem_Ico, mem_Icc, Nat.lt_succ_iff]\n\n"}
{"name":"Nat.Ico_succ_left","module":"Mathlib.Order.Interval.Finset.Nat","initialProofState":"a b : Nat\n⊢ Eq (Finset.Ico a.succ b) (Finset.Ioo a b)","decl":"theorem Ico_succ_left : Ico a.succ b = Ioo a b := by\n  ext x\n  rw [mem_Ico, mem_Ioo, succ_le_iff]\n\n"}
{"name":"Nat.Icc_pred_right","module":"Mathlib.Order.Interval.Finset.Nat","initialProofState":"a b : Nat\nh : LT.lt 0 b\n⊢ Eq (Finset.Icc a (HSub.hSub b 1)) (Finset.Ico a b)","decl":"theorem Icc_pred_right {b : ℕ} (h : 0 < b) : Icc a (b - 1) = Ico a b := by\n  ext x\n  rw [mem_Icc, mem_Ico, lt_iff_le_pred h]\n\n"}
{"name":"Nat.Ico_succ_succ","module":"Mathlib.Order.Interval.Finset.Nat","initialProofState":"a b : Nat\n⊢ Eq (Finset.Ico a.succ b.succ) (Finset.Ioc a b)","decl":"theorem Ico_succ_succ : Ico a.succ b.succ = Ioc a b := by\n  ext x\n  rw [mem_Ico, mem_Ioc, succ_le_iff, Nat.lt_succ_iff]\n\n"}
{"name":"Nat.Ico_succ_singleton","module":"Mathlib.Order.Interval.Finset.Nat","initialProofState":"a : Nat\n⊢ Eq (Finset.Ico a (HAdd.hAdd a 1)) (Singleton.singleton a)","decl":"@[simp]\ntheorem Ico_succ_singleton : Ico a (a + 1) = {a} := by rw [Ico_succ_right, Icc_self]\n\n"}
{"name":"Nat.Ico_pred_singleton","module":"Mathlib.Order.Interval.Finset.Nat","initialProofState":"a : Nat\nh : LT.lt 0 a\n⊢ Eq (Finset.Ico (HSub.hSub a 1) a) (Singleton.singleton (HSub.hSub a 1))","decl":"@[simp]\ntheorem Ico_pred_singleton {a : ℕ} (h : 0 < a) : Ico (a - 1) a = {a - 1} := by\n  rw [← Icc_pred_right _ h, Icc_self]\n\n"}
{"name":"Nat.Ioc_succ_singleton","module":"Mathlib.Order.Interval.Finset.Nat","initialProofState":"b : Nat\n⊢ Eq (Finset.Ioc b (HAdd.hAdd b 1)) (Singleton.singleton (HAdd.hAdd b 1))","decl":"@[simp]\ntheorem Ioc_succ_singleton : Ioc b (b + 1) = {b + 1} := by rw [← Nat.Icc_succ_left, Icc_self]\n\n"}
{"name":"Nat.Ico_succ_right_eq_insert_Ico","module":"Mathlib.Order.Interval.Finset.Nat","initialProofState":"a b : Nat\nh : LE.le a b\n⊢ Eq (Finset.Ico a (HAdd.hAdd b 1)) (Insert.insert b (Finset.Ico a b))","decl":"theorem Ico_succ_right_eq_insert_Ico (h : a ≤ b) : Ico a (b + 1) = insert b (Ico a b) := by\n  rw [Ico_succ_right, ← Ico_insert_right h]\n\n"}
{"name":"Nat.Ico_insert_succ_left","module":"Mathlib.Order.Interval.Finset.Nat","initialProofState":"a b : Nat\nh : LT.lt a b\n⊢ Eq (Insert.insert a (Finset.Ico a.succ b)) (Finset.Ico a b)","decl":"theorem Ico_insert_succ_left (h : a < b) : insert a (Ico a.succ b) = Ico a b := by\n  rw [Ico_succ_left, ← Ioo_insert_left h]\n\n"}
{"name":"Nat.Icc_insert_succ_left","module":"Mathlib.Order.Interval.Finset.Nat","initialProofState":"a b : Nat\nh : LE.le a b\n⊢ Eq (Insert.insert a (Finset.Icc (HAdd.hAdd a 1) b)) (Finset.Icc a b)","decl":"lemma Icc_insert_succ_left (h : a ≤ b) : insert a (Icc (a + 1) b) = Icc a b := by\n  ext x\n  simp only [mem_insert, mem_Icc]\n  omega\n\n"}
{"name":"Nat.Icc_insert_succ_right","module":"Mathlib.Order.Interval.Finset.Nat","initialProofState":"a b : Nat\nh : LE.le a (HAdd.hAdd b 1)\n⊢ Eq (Insert.insert (HAdd.hAdd b 1) (Finset.Icc a b)) (Finset.Icc a (HAdd.hAdd b 1))","decl":"lemma Icc_insert_succ_right (h : a ≤ b + 1) : insert (b + 1) (Icc a b) = Icc a (b + 1) := by\n  ext x\n  simp only [mem_insert, mem_Icc]\n  omega\n\n"}
{"name":"Nat.image_sub_const_Ico","module":"Mathlib.Order.Interval.Finset.Nat","initialProofState":"a b c : Nat\nh : LE.le c a\n⊢ Eq (Finset.image (fun x => HSub.hSub x c) (Finset.Ico a b)) (Finset.Ico (HSub.hSub a c) (HSub.hSub b c))","decl":"theorem image_sub_const_Ico (h : c ≤ a) :\n    ((Ico a b).image fun x => x - c) = Ico (a - c) (b - c) := by\n  ext x\n  simp_rw [mem_image, mem_Ico]\n  refine ⟨?_, fun h ↦ ⟨x + c, by omega⟩⟩\n  rintro ⟨x, hx, rfl⟩\n  omega\n\n"}
{"name":"Nat.Ico_image_const_sub_eq_Ico","module":"Mathlib.Order.Interval.Finset.Nat","initialProofState":"a b c : Nat\nhac : LE.le a c\n⊢ Eq (Finset.image (fun x => HSub.hSub c x) (Finset.Ico a b)) (Finset.Ico (HSub.hSub (HAdd.hAdd c 1) b) (HSub.hSub (HAdd.hAdd c 1) a))","decl":"theorem Ico_image_const_sub_eq_Ico (hac : a ≤ c) :\n    ((Ico a b).image fun x => c - x) = Ico (c + 1 - b) (c + 1 - a) := by\n  ext x\n  simp_rw [mem_image, mem_Ico]\n  refine ⟨?_, fun h ↦ ⟨c - x, by omega⟩⟩\n  rintro ⟨x, hx, rfl⟩\n  omega\n\n"}
{"name":"Nat.Ico_succ_left_eq_erase_Ico","module":"Mathlib.Order.Interval.Finset.Nat","initialProofState":"a b : Nat\n⊢ Eq (Finset.Ico a.succ b) ((Finset.Ico a b).erase a)","decl":"theorem Ico_succ_left_eq_erase_Ico : Ico a.succ b = erase (Ico a b) a := by\n  ext x\n  rw [Ico_succ_left, mem_erase, mem_Ico, mem_Ioo, ← and_assoc, ne_comm,\n    and_comm (a := a ≠ x), lt_iff_le_and_ne]\n\n"}
{"name":"Nat.mod_injOn_Ico","module":"Mathlib.Order.Interval.Finset.Nat","initialProofState":"n a : Nat\n⊢ Set.InjOn (fun x => HMod.hMod x a) ↑(Finset.Ico n (HAdd.hAdd n a))","decl":"theorem mod_injOn_Ico (n a : ℕ) : Set.InjOn (· % a) (Finset.Ico n (n + a)) := by\n  induction' n with n ih\n  · simp only [zero_add, Ico_zero_eq_range]\n    rintro k hk l hl (hkl : k % a = l % a)\n    simp only [Finset.mem_range, Finset.mem_coe] at hk hl\n    rwa [mod_eq_of_lt hk, mod_eq_of_lt hl] at hkl\n  rw [Ico_succ_left_eq_erase_Ico, succ_add, succ_eq_add_one,\n    Ico_succ_right_eq_insert_Ico (by omega)]\n  rintro k hk l hl (hkl : k % a = l % a)\n  have ha : 0 < a := Nat.pos_iff_ne_zero.2 <| by rintro rfl; simp at hk\n  simp only [Finset.mem_coe, Finset.mem_insert, Finset.mem_erase] at hk hl\n  rcases hk with ⟨hkn, rfl | hk⟩ <;> rcases hl with ⟨hln, rfl | hl⟩\n  · rfl\n  · rw [add_mod_right] at hkl\n    refine (hln <| ih hl ?_ hkl.symm).elim\n    simpa using Nat.lt_add_of_pos_right (n := n) ha\n  · rw [add_mod_right] at hkl\n    suffices k = n by contradiction\n    refine ih hk ?_ hkl\n    simpa using Nat.lt_add_of_pos_right (n := n) ha\n  · refine ih ?_ ?_ hkl <;> simp only [Finset.mem_coe, hk, hl]\n\n"}
{"name":"Nat.image_Ico_mod","module":"Mathlib.Order.Interval.Finset.Nat","initialProofState":"n a : Nat\n⊢ Eq (Finset.image (fun x => HMod.hMod x a) (Finset.Ico n (HAdd.hAdd n a))) (Finset.range a)","decl":"/-- Note that while this lemma cannot be easily generalized to a type class, it holds for ℤ as\nwell. See `Int.image_Ico_emod` for the ℤ version. -/\ntheorem image_Ico_mod (n a : ℕ) : (Ico n (n + a)).image (· % a) = range a := by\n  obtain rfl | ha := eq_or_ne a 0\n  · rw [range_zero, add_zero, Ico_self, image_empty]\n  ext i\n  simp only [mem_image, exists_prop, mem_range, mem_Ico]\n  constructor\n  · rintro ⟨i, _, rfl⟩\n    exact mod_lt i ha.bot_lt\n  intro hia\n  have hn := Nat.mod_add_div n a\n  obtain hi | hi := lt_or_le i (n % a)\n  · refine ⟨i + a * (n / a + 1), ⟨?_, ?_⟩, ?_⟩\n    · rw [add_comm (n / a), Nat.mul_add, mul_one, ← add_assoc]\n      refine hn.symm.le.trans (Nat.add_le_add_right ?_ _)\n      simpa only [zero_add] using add_le_add (zero_le i) (Nat.mod_lt n ha.bot_lt).le\n    · refine lt_of_lt_of_le (Nat.add_lt_add_right hi (a * (n / a + 1))) ?_\n      rw [Nat.mul_add, mul_one, ← add_assoc, hn]\n    · rw [Nat.add_mul_mod_self_left, Nat.mod_eq_of_lt hia]\n  · refine ⟨i + a * (n / a), ⟨?_, ?_⟩, ?_⟩\n    · omega\n    · omega\n    · rw [Nat.add_mul_mod_self_left, Nat.mod_eq_of_lt hia]\n\n"}
{"name":"Nat.multiset_Ico_map_mod","module":"Mathlib.Order.Interval.Finset.Nat","initialProofState":"n a : Nat\n⊢ Eq (Multiset.map (fun x => HMod.hMod x a) (Multiset.Ico n (HAdd.hAdd n a))) (Multiset.range a)","decl":"theorem multiset_Ico_map_mod (n a : ℕ) :\n    (Multiset.Ico n (n + a)).map (· % a) = Multiset.range a := by\n  convert congr_arg Finset.val (image_Ico_mod n a)\n  refine ((nodup_map_iff_inj_on (Finset.Ico _ _).nodup).2 <| ?_).dedup.symm\n  exact mod_injOn_Ico _ _\n\n"}
{"name":"Finset.range_image_pred_top_sub","module":"Mathlib.Order.Interval.Finset.Nat","initialProofState":"n : Nat\n⊢ Eq (Finset.image (fun j => HSub.hSub (HSub.hSub n 1) j) (Finset.range n)) (Finset.range n)","decl":"theorem range_image_pred_top_sub (n : ℕ) :\n    ((Finset.range n).image fun j => n - 1 - j) = Finset.range n := by\n  cases n\n  · rw [range_zero, image_empty]\n  · rw [Finset.range_eq_Ico, Nat.Ico_image_const_sub_eq_Ico (Nat.zero_le _)]\n    simp_rw [succ_sub_succ, Nat.sub_zero, Nat.sub_self]\n\n"}
{"name":"Finset.range_add_eq_union","module":"Mathlib.Order.Interval.Finset.Nat","initialProofState":"a b : Nat\n⊢ Eq (Finset.range (HAdd.hAdd a b)) (Union.union (Finset.range a) (Finset.map (addLeftEmbedding a) (Finset.range b)))","decl":"theorem range_add_eq_union : range (a + b) = range a ∪ (range b).map (addLeftEmbedding a) := by\n  rw [Finset.range_eq_Ico, map_eq_image]\n  convert (Ico_union_Ico_eq_Ico a.zero_le (a.le_add_right b)).symm\n  ext x\n  simp only [Ico_zero_eq_range, mem_image, mem_range, addLeftEmbedding_apply, mem_Ico]\n  constructor\n  · aesop\n  · rintro h\n    exact ⟨x - a, by omega⟩\n\n"}
{"name":"Nat.decreasing_induction_of_not_bddAbove","module":"Mathlib.Order.Interval.Finset.Nat","initialProofState":"P : Nat → Prop\nh : ∀ (n : Nat), P (HAdd.hAdd n 1) → P n\nhP : Not (BddAbove (setOf fun x => P x))\nn : Nat\n⊢ P n","decl":"theorem Nat.decreasing_induction_of_not_bddAbove (h : ∀ n, P (n + 1) → P n)\n    (hP : ¬BddAbove { x | P x }) (n : ℕ) : P n :=\n  let ⟨_, hm, hl⟩ := not_bddAbove_iff.1 hP n\n  decreasingInduction (fun _ _ => h _) hm hl.le\n\n"}
{"name":"Nat.strong_decreasing_induction","module":"Mathlib.Order.Interval.Finset.Nat","initialProofState":"P : Nat → Prop\nbase : Exists fun n => ∀ (m : Nat), GT.gt m n → P m\nstep : ∀ (n : Nat), (∀ (m : Nat), GT.gt m n → P m) → P n\nn : Nat\n⊢ P n","decl":"@[elab_as_elim]\nlemma Nat.strong_decreasing_induction (base : ∃ n, ∀ m > n, P m) (step : ∀ n, (∀ m > n, P m) → P n)\n    (n : ℕ) : P n := by\n  apply Nat.decreasing_induction_of_not_bddAbove (P := fun n ↦ ∀ m ≥ n, P m) _ _ n n le_rfl\n  · intro n ih m hm\n    rcases hm.eq_or_lt with rfl | hm\n    · exact step n ih\n    · exact ih m hm\n  · rintro ⟨b, hb⟩\n    rcases base with ⟨n, hn⟩\n    specialize @hb (n + b + 1) (fun m hm ↦ hn _ _)\n    all_goals omega\n\n"}
{"name":"Nat.decreasing_induction_of_infinite","module":"Mathlib.Order.Interval.Finset.Nat","initialProofState":"P : Nat → Prop\nh : ∀ (n : Nat), P (HAdd.hAdd n 1) → P n\nhP : (setOf fun x => P x).Infinite\nn : Nat\n⊢ P n","decl":"theorem Nat.decreasing_induction_of_infinite\n    (h : ∀ n, P (n + 1) → P n) (hP : { x | P x }.Infinite) (n : ℕ) : P n :=\n  Nat.decreasing_induction_of_not_bddAbove h (mt BddAbove.finite hP) n\n\n"}
{"name":"Nat.cauchy_induction'","module":"Mathlib.Order.Interval.Finset.Nat","initialProofState":"P : Nat → Prop\nseed : Nat\nh : ∀ (n : Nat), P (HAdd.hAdd n 1) → P n\nhs : P seed\nhi : ∀ (x : Nat), LE.le seed x → P x → Exists fun y => And (LT.lt x y) (P y)\nn : Nat\n⊢ P n","decl":"theorem Nat.cauchy_induction' (seed : ℕ) (h : ∀ n, P (n + 1) → P n) (hs : P seed)\n    (hi : ∀ x, seed ≤ x → P x → ∃ y, x < y ∧ P y) (n : ℕ) : P n := by\n  apply Nat.decreasing_induction_of_infinite h fun hf => _\n  intro hf\n  obtain ⟨m, hP, hm⟩ := hf.exists_maximal_wrt id _ ⟨seed, hs⟩\n  obtain ⟨y, hl, hy⟩ := hi m (le_of_not_lt fun hl => hl.ne <| hm seed hs hl.le) hP\n  exact hl.ne (hm y hy hl.le)\n\n"}
{"name":"Nat.cauchy_induction","module":"Mathlib.Order.Interval.Finset.Nat","initialProofState":"P : Nat → Prop\nh : ∀ (n : Nat), P (HAdd.hAdd n 1) → P n\nseed : Nat\nhs : P seed\nf : Nat → Nat\nhf : ∀ (x : Nat), LE.le seed x → P x → And (LT.lt x (f x)) (P (f x))\nn : Nat\n⊢ P n","decl":"theorem Nat.cauchy_induction (h : ∀ n, P (n + 1) → P n) (seed : ℕ) (hs : P seed) (f : ℕ → ℕ)\n    (hf : ∀ x, seed ≤ x → P x → x < f x ∧ P (f x)) (n : ℕ) : P n :=\n  seed.cauchy_induction' h hs (fun x hl hx => ⟨f x, hf x hl hx⟩) n\n\n"}
{"name":"Nat.cauchy_induction_mul","module":"Mathlib.Order.Interval.Finset.Nat","initialProofState":"P : Nat → Prop\nh : ∀ (n : Nat), P (HAdd.hAdd n 1) → P n\nk seed : Nat\nhk : LT.lt 1 k\nhs : P seed.succ\nhm : ∀ (x : Nat), LT.lt seed x → P x → P (HMul.hMul k x)\nn : Nat\n⊢ P n","decl":"theorem Nat.cauchy_induction_mul (h : ∀ (n : ℕ), P (n + 1) → P n) (k seed : ℕ) (hk : 1 < k)\n    (hs : P seed.succ) (hm : ∀ x, seed < x → P x → P (k * x)) (n : ℕ) : P n := by\n  apply Nat.cauchy_induction h _ hs (k * ·) fun x hl hP => ⟨_, hm x hl hP⟩\n  intro _ hl _\n  convert (Nat.mul_lt_mul_right <| seed.succ_pos.trans_le hl).2 hk\n  rw [one_mul]\n\n"}
{"name":"Nat.cauchy_induction_two_mul","module":"Mathlib.Order.Interval.Finset.Nat","initialProofState":"P : Nat → Prop\nh : ∀ (n : Nat), P (HAdd.hAdd n 1) → P n\nseed : Nat\nhs : P seed.succ\nhm : ∀ (x : Nat), LT.lt seed x → P x → P (HMul.hMul 2 x)\nn : Nat\n⊢ P n","decl":"theorem Nat.cauchy_induction_two_mul (h : ∀ n, P (n + 1) → P n) (seed : ℕ) (hs : P seed.succ)\n    (hm : ∀ x, seed < x → P x → P (2 * x)) (n : ℕ) : P n :=\n  Nat.cauchy_induction_mul h 2 seed Nat.one_lt_two hs hm n\n\n"}
{"name":"Nat.pow_imp_self_of_one_lt","module":"Mathlib.Order.Interval.Finset.Nat","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nk : Nat\nhk : LT.lt 1 k\nP : M → Prop\nhmul : ∀ (x y : M), P x → Or (P (HMul.hMul x y)) (P (HMul.hMul y x))\nhpow : ∀ (x : M), P (HPow.hPow x k) → P x\nn : Nat\nx : M\na✝ : P (HPow.hPow x n)\n⊢ P x","decl":"theorem Nat.pow_imp_self_of_one_lt {M} [Monoid M] (k : ℕ) (hk : 1 < k)\n    (P : M → Prop) (hmul : ∀ x y, P x → P (x * y) ∨ P (y * x))\n    (hpow : ∀ x, P (x ^ k) → P x) : ∀ n x, P (x ^ n) → P x :=\n  k.cauchy_induction_mul (fun n ih x hx ↦ ih x <| (hmul _ x hx).elim\n    (fun h ↦ by rwa [_root_.pow_succ]) fun h ↦ by rwa [_root_.pow_succ']) 0 hk\n    (fun x hx ↦ pow_one x ▸ hx) fun n _ hn x hx ↦ hpow x <| hn _ <| (pow_mul x k n).subst hx\n\n"}
