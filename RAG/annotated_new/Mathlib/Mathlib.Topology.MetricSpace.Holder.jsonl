{"name":"holderOnWith_empty","module":"Mathlib.Topology.MetricSpace.Holder","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : PseudoEMetricSpace X\ninst‚úù : PseudoEMetricSpace Y\nC r : NNReal\nf : X ‚Üí Y\n‚ä¢ HolderOnWith C r f EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem holderOnWith_empty (C r : ‚Ñù‚â•0) (f : X ‚Üí Y) : HolderOnWith C r f ‚àÖ := fun _ hx => hx.elim\n\n"}
{"name":"holderOnWith_singleton","module":"Mathlib.Topology.MetricSpace.Holder","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : PseudoEMetricSpace X\ninst‚úù : PseudoEMetricSpace Y\nC r : NNReal\nf : X ‚Üí Y\nx : X\n‚ä¢ HolderOnWith C r f (Singleton.singleton x)","decl":"@[simp]\ntheorem holderOnWith_singleton (C r : ‚Ñù‚â•0) (f : X ‚Üí Y) (x : X) : HolderOnWith C r f {x} := by\n  rintro a (rfl : a = x) b (rfl : b = a)\n  rw [edist_self]\n  exact zero_le _\n\n"}
{"name":"Set.Subsingleton.holderOnWith","module":"Mathlib.Topology.MetricSpace.Holder","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : PseudoEMetricSpace X\ninst‚úù : PseudoEMetricSpace Y\ns : Set X\nhs : s.Subsingleton\nC r : NNReal\nf : X ‚Üí Y\n‚ä¢ HolderOnWith C r f s","decl":"theorem Set.Subsingleton.holderOnWith {s : Set X} (hs : s.Subsingleton) (C r : ‚Ñù‚â•0) (f : X ‚Üí Y) :\n    HolderOnWith C r f s :=\n  hs.induction_on (holderOnWith_empty C r f) (holderOnWith_singleton C r f)\n\n"}
{"name":"holderOnWith_univ","module":"Mathlib.Topology.MetricSpace.Holder","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : PseudoEMetricSpace X\ninst‚úù : PseudoEMetricSpace Y\nC r : NNReal\nf : X ‚Üí Y\n‚ä¢ Iff (HolderOnWith C r f Set.univ) (HolderWith C r f)","decl":"theorem holderOnWith_univ {C r : ‚Ñù‚â•0} {f : X ‚Üí Y} : HolderOnWith C r f univ ‚Üî HolderWith C r f := by\n  simp only [HolderOnWith, HolderWith, mem_univ, true_imp_iff]\n\n"}
{"name":"holderOnWith_one","module":"Mathlib.Topology.MetricSpace.Holder","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : PseudoEMetricSpace X\ninst‚úù : PseudoEMetricSpace Y\nC : NNReal\nf : X ‚Üí Y\ns : Set X\n‚ä¢ Iff (HolderOnWith C 1 f s) (LipschitzOnWith C f s)","decl":"@[simp]\ntheorem holderOnWith_one {C : ‚Ñù‚â•0} {f : X ‚Üí Y} {s : Set X} :\n    HolderOnWith C 1 f s ‚Üî LipschitzOnWith C f s := by\n  simp only [HolderOnWith, LipschitzOnWith, NNReal.coe_one, ENNReal.rpow_one]\n\n"}
{"name":"LipschitzOnWith.holderOnWith","module":"Mathlib.Topology.MetricSpace.Holder","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : PseudoEMetricSpace X\ninst‚úù : PseudoEMetricSpace Y\nC : NNReal\nf : X ‚Üí Y\ns : Set X\na‚úù : LipschitzOnWith C f s\n‚ä¢ HolderOnWith C 1 f s","decl":"alias ‚ü®_, LipschitzOnWith.holderOnWith‚ü© := holderOnWith_one\n\n"}
{"name":"holderWith_one","module":"Mathlib.Topology.MetricSpace.Holder","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : PseudoEMetricSpace X\ninst‚úù : PseudoEMetricSpace Y\nC : NNReal\nf : X ‚Üí Y\n‚ä¢ Iff (HolderWith C 1 f) (LipschitzWith C f)","decl":"@[simp]\ntheorem holderWith_one {C : ‚Ñù‚â•0} {f : X ‚Üí Y} : HolderWith C 1 f ‚Üî LipschitzWith C f :=\n  holderOnWith_univ.symm.trans <| holderOnWith_one.trans lipschitzOnWith_univ\n\n"}
{"name":"LipschitzWith.holderWith","module":"Mathlib.Topology.MetricSpace.Holder","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : PseudoEMetricSpace X\ninst‚úù : PseudoEMetricSpace Y\nC : NNReal\nf : X ‚Üí Y\na‚úù : LipschitzWith C f\n‚ä¢ HolderWith C 1 f","decl":"alias ‚ü®_, LipschitzWith.holderWith‚ü© := holderWith_one\n\n"}
{"name":"holderWith_id","module":"Mathlib.Topology.MetricSpace.Holder","initialProofState":"X : Type u_1\ninst‚úù : PseudoEMetricSpace X\n‚ä¢ HolderWith 1 1 id","decl":"theorem holderWith_id : HolderWith 1 1 (id : X ‚Üí X) :=\n  LipschitzWith.id.holderWith\n\n"}
{"name":"HolderWith.holderOnWith","module":"Mathlib.Topology.MetricSpace.Holder","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : PseudoEMetricSpace X\ninst‚úù : PseudoEMetricSpace Y\nC r : NNReal\nf : X ‚Üí Y\nh : HolderWith C r f\ns : Set X\n‚ä¢ HolderOnWith C r f s","decl":"protected theorem HolderWith.holderOnWith {C r : ‚Ñù‚â•0} {f : X ‚Üí Y} (h : HolderWith C r f)\n    (s : Set X) : HolderOnWith C r f s := fun x _ y _ => h x y\n\n"}
{"name":"HolderOnWith.edist_le","module":"Mathlib.Topology.MetricSpace.Holder","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : PseudoEMetricSpace X\ninst‚úù : PseudoEMetricSpace Y\nC r : NNReal\nf : X ‚Üí Y\ns : Set X\nh : HolderOnWith C r f s\nx y : X\nhx : Membership.mem s x\nhy : Membership.mem s y\n‚ä¢ LE.le (EDist.edist (f x) (f y)) (HMul.hMul (‚ÜëC) (HPow.hPow (EDist.edist x y) ‚Üër))","decl":"theorem edist_le (h : HolderOnWith C r f s) {x y : X} (hx : x ‚àà s) (hy : y ‚àà s) :\n    edist (f x) (f y) ‚â§ (C : ‚Ñù‚â•0‚àû) * edist x y ^ (r : ‚Ñù) :=\n  h x hx y hy\n\n"}
{"name":"HolderOnWith.edist_le_of_le","module":"Mathlib.Topology.MetricSpace.Holder","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : PseudoEMetricSpace X\ninst‚úù : PseudoEMetricSpace Y\nC r : NNReal\nf : X ‚Üí Y\ns : Set X\nh : HolderOnWith C r f s\nx y : X\nhx : Membership.mem s x\nhy : Membership.mem s y\nd : ENNReal\nhd : LE.le (EDist.edist x y) d\n‚ä¢ LE.le (EDist.edist (f x) (f y)) (HMul.hMul (‚ÜëC) (HPow.hPow d ‚Üër))","decl":"theorem edist_le_of_le (h : HolderOnWith C r f s) {x y : X} (hx : x ‚àà s) (hy : y ‚àà s) {d : ‚Ñù‚â•0‚àû}\n    (hd : edist x y ‚â§ d) : edist (f x) (f y) ‚â§ (C : ‚Ñù‚â•0‚àû) * d ^ (r : ‚Ñù) :=\n  (h.edist_le hx hy).trans <| by gcongr\n\n"}
{"name":"HolderOnWith.comp","module":"Mathlib.Topology.MetricSpace.Holder","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst‚úù¬≤ : PseudoEMetricSpace X\ninst‚úù¬π : PseudoEMetricSpace Y\ninst‚úù : PseudoEMetricSpace Z\ns : Set X\nCg rg : NNReal\ng : Y ‚Üí Z\nt : Set Y\nhg : HolderOnWith Cg rg g t\nCf rf : NNReal\nf : X ‚Üí Y\nhf : HolderOnWith Cf rf f s\nhst : Set.MapsTo f s t\n‚ä¢ HolderOnWith (HMul.hMul Cg (HPow.hPow Cf ‚Üërg)) (HMul.hMul rg rf) (Function.comp g f) s","decl":"theorem comp {Cg rg : ‚Ñù‚â•0} {g : Y ‚Üí Z} {t : Set Y} (hg : HolderOnWith Cg rg g t) {Cf rf : ‚Ñù‚â•0}\n    {f : X ‚Üí Y} (hf : HolderOnWith Cf rf f s) (hst : MapsTo f s t) :\n    HolderOnWith (Cg * Cf ^ (rg : ‚Ñù)) (rg * rf) (g ‚àò f) s := by\n  intro x hx y hy\n  rw [ENNReal.coe_mul, mul_comm rg, NNReal.coe_mul, ENNReal.rpow_mul, mul_assoc,\n    ENNReal.coe_rpow_of_nonneg _ rg.coe_nonneg, ‚Üê ENNReal.mul_rpow_of_nonneg _ _ rg.coe_nonneg]\n  exact hg.edist_le_of_le (hst hx) (hst hy) (hf.edist_le hx hy)\n\n"}
{"name":"HolderOnWith.comp_holderWith","module":"Mathlib.Topology.MetricSpace.Holder","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst‚úù¬≤ : PseudoEMetricSpace X\ninst‚úù¬π : PseudoEMetricSpace Y\ninst‚úù : PseudoEMetricSpace Z\nCg rg : NNReal\ng : Y ‚Üí Z\nt : Set Y\nhg : HolderOnWith Cg rg g t\nCf rf : NNReal\nf : X ‚Üí Y\nhf : HolderWith Cf rf f\nht : ‚àÄ (x : X), Membership.mem t (f x)\n‚ä¢ HolderWith (HMul.hMul Cg (HPow.hPow Cf ‚Üërg)) (HMul.hMul rg rf) (Function.comp g f)","decl":"theorem comp_holderWith {Cg rg : ‚Ñù‚â•0} {g : Y ‚Üí Z} {t : Set Y} (hg : HolderOnWith Cg rg g t)\n    {Cf rf : ‚Ñù‚â•0} {f : X ‚Üí Y} (hf : HolderWith Cf rf f) (ht : ‚àÄ x, f x ‚àà t) :\n    HolderWith (Cg * Cf ^ (rg : ‚Ñù)) (rg * rf) (g ‚àò f) :=\n  holderOnWith_univ.mp <| hg.comp (hf.holderOnWith univ) fun x _ => ht x\n\n"}
{"name":"HolderOnWith.uniformContinuousOn","module":"Mathlib.Topology.MetricSpace.Holder","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : PseudoEMetricSpace X\ninst‚úù : PseudoEMetricSpace Y\nC r : NNReal\nf : X ‚Üí Y\ns : Set X\nhf : HolderOnWith C r f s\nh0 : LT.lt 0 r\n‚ä¢ UniformContinuousOn f s","decl":"/-- A H√∂lder continuous function is uniformly continuous -/\nprotected theorem uniformContinuousOn (hf : HolderOnWith C r f s) (h0 : 0 < r) :\n    UniformContinuousOn f s := by\n  refine EMetric.uniformContinuousOn_iff.2 fun Œµ Œµpos => ?_\n  have : Tendsto (fun d : ‚Ñù‚â•0‚àû => (C : ‚Ñù‚â•0‚àû) * d ^ (r : ‚Ñù)) (ùìù 0) (ùìù 0) :=\n    ENNReal.tendsto_const_mul_rpow_nhds_zero_of_pos ENNReal.coe_ne_top h0\n  rcases ENNReal.nhds_zero_basis.mem_iff.1 (this (gt_mem_nhds Œµpos)) with ‚ü®Œ¥, Œ¥0, H‚ü©\n  exact ‚ü®Œ¥, Œ¥0, fun hx y hy h => (hf.edist_le hx hy).trans_lt (H h)‚ü©\n\n"}
{"name":"HolderOnWith.continuousOn","module":"Mathlib.Topology.MetricSpace.Holder","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : PseudoEMetricSpace X\ninst‚úù : PseudoEMetricSpace Y\nC r : NNReal\nf : X ‚Üí Y\ns : Set X\nhf : HolderOnWith C r f s\nh0 : LT.lt 0 r\n‚ä¢ ContinuousOn f s","decl":"protected theorem continuousOn (hf : HolderOnWith C r f s) (h0 : 0 < r) : ContinuousOn f s :=\n  (hf.uniformContinuousOn h0).continuousOn\n\n"}
{"name":"HolderOnWith.mono","module":"Mathlib.Topology.MetricSpace.Holder","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : PseudoEMetricSpace X\ninst‚úù : PseudoEMetricSpace Y\nC r : NNReal\nf : X ‚Üí Y\ns t : Set X\nhf : HolderOnWith C r f s\nht : HasSubset.Subset t s\n‚ä¢ HolderOnWith C r f t","decl":"protected theorem mono (hf : HolderOnWith C r f s) (ht : t ‚äÜ s) : HolderOnWith C r f t :=\n  fun _ hx _ hy => hf.edist_le (ht hx) (ht hy)\n\n"}
{"name":"HolderOnWith.ediam_image_le_of_le","module":"Mathlib.Topology.MetricSpace.Holder","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : PseudoEMetricSpace X\ninst‚úù : PseudoEMetricSpace Y\nC r : NNReal\nf : X ‚Üí Y\ns : Set X\nhf : HolderOnWith C r f s\nd : ENNReal\nhd : LE.le (EMetric.diam s) d\n‚ä¢ LE.le (EMetric.diam (Set.image f s)) (HMul.hMul (‚ÜëC) (HPow.hPow d ‚Üër))","decl":"theorem ediam_image_le_of_le (hf : HolderOnWith C r f s) {d : ‚Ñù‚â•0‚àû} (hd : EMetric.diam s ‚â§ d) :\n    EMetric.diam (f '' s) ‚â§ (C : ‚Ñù‚â•0‚àû) * d ^ (r : ‚Ñù) :=\n  EMetric.diam_image_le_iff.2 fun _ hx _ hy =>\n    hf.edist_le_of_le hx hy <| (EMetric.edist_le_diam_of_mem hx hy).trans hd\n\n"}
{"name":"HolderOnWith.ediam_image_le","module":"Mathlib.Topology.MetricSpace.Holder","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : PseudoEMetricSpace X\ninst‚úù : PseudoEMetricSpace Y\nC r : NNReal\nf : X ‚Üí Y\ns : Set X\nhf : HolderOnWith C r f s\n‚ä¢ LE.le (EMetric.diam (Set.image f s)) (HMul.hMul (‚ÜëC) (HPow.hPow (EMetric.diam s) ‚Üër))","decl":"theorem ediam_image_le (hf : HolderOnWith C r f s) :\n    EMetric.diam (f '' s) ‚â§ (C : ‚Ñù‚â•0‚àû) * EMetric.diam s ^ (r : ‚Ñù) :=\n  hf.ediam_image_le_of_le le_rfl\n\n"}
{"name":"HolderOnWith.ediam_image_le_of_subset","module":"Mathlib.Topology.MetricSpace.Holder","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : PseudoEMetricSpace X\ninst‚úù : PseudoEMetricSpace Y\nC r : NNReal\nf : X ‚Üí Y\ns t : Set X\nhf : HolderOnWith C r f s\nht : HasSubset.Subset t s\n‚ä¢ LE.le (EMetric.diam (Set.image f t)) (HMul.hMul (‚ÜëC) (HPow.hPow (EMetric.diam t) ‚Üër))","decl":"theorem ediam_image_le_of_subset (hf : HolderOnWith C r f s) (ht : t ‚äÜ s) :\n    EMetric.diam (f '' t) ‚â§ (C : ‚Ñù‚â•0‚àû) * EMetric.diam t ^ (r : ‚Ñù) :=\n  (hf.mono ht).ediam_image_le\n\n"}
{"name":"HolderOnWith.ediam_image_le_of_subset_of_le","module":"Mathlib.Topology.MetricSpace.Holder","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : PseudoEMetricSpace X\ninst‚úù : PseudoEMetricSpace Y\nC r : NNReal\nf : X ‚Üí Y\ns t : Set X\nhf : HolderOnWith C r f s\nht : HasSubset.Subset t s\nd : ENNReal\nhd : LE.le (EMetric.diam t) d\n‚ä¢ LE.le (EMetric.diam (Set.image f t)) (HMul.hMul (‚ÜëC) (HPow.hPow d ‚Üër))","decl":"theorem ediam_image_le_of_subset_of_le (hf : HolderOnWith C r f s) (ht : t ‚äÜ s) {d : ‚Ñù‚â•0‚àû}\n    (hd : EMetric.diam t ‚â§ d) : EMetric.diam (f '' t) ‚â§ (C : ‚Ñù‚â•0‚àû) * d ^ (r : ‚Ñù) :=\n  (hf.mono ht).ediam_image_le_of_le hd\n\n"}
{"name":"HolderOnWith.ediam_image_inter_le_of_le","module":"Mathlib.Topology.MetricSpace.Holder","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : PseudoEMetricSpace X\ninst‚úù : PseudoEMetricSpace Y\nC r : NNReal\nf : X ‚Üí Y\ns t : Set X\nhf : HolderOnWith C r f s\nd : ENNReal\nhd : LE.le (EMetric.diam t) d\n‚ä¢ LE.le (EMetric.diam (Set.image f (Inter.inter t s))) (HMul.hMul (‚ÜëC) (HPow.hPow d ‚Üër))","decl":"theorem ediam_image_inter_le_of_le (hf : HolderOnWith C r f s) {d : ‚Ñù‚â•0‚àû}\n    (hd : EMetric.diam t ‚â§ d) : EMetric.diam (f '' (t ‚à© s)) ‚â§ (C : ‚Ñù‚â•0‚àû) * d ^ (r : ‚Ñù) :=\n  hf.ediam_image_le_of_subset_of_le inter_subset_right <|\n    (EMetric.diam_mono inter_subset_left).trans hd\n\n"}
{"name":"HolderOnWith.ediam_image_inter_le","module":"Mathlib.Topology.MetricSpace.Holder","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : PseudoEMetricSpace X\ninst‚úù : PseudoEMetricSpace Y\nC r : NNReal\nf : X ‚Üí Y\ns : Set X\nhf : HolderOnWith C r f s\nt : Set X\n‚ä¢ LE.le (EMetric.diam (Set.image f (Inter.inter t s))) (HMul.hMul (‚ÜëC) (HPow.hPow (EMetric.diam t) ‚Üër))","decl":"theorem ediam_image_inter_le (hf : HolderOnWith C r f s) (t : Set X) :\n    EMetric.diam (f '' (t ‚à© s)) ‚â§ (C : ‚Ñù‚â•0‚àû) * EMetric.diam t ^ (r : ‚Ñù) :=\n  hf.ediam_image_inter_le_of_le le_rfl\n\n"}
{"name":"HolderWith.restrict_iff","module":"Mathlib.Topology.MetricSpace.Holder","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : PseudoEMetricSpace X\ninst‚úù : PseudoEMetricSpace Y\nC r : NNReal\nf : X ‚Üí Y\ns : Set X\n‚ä¢ Iff (HolderWith C r (s.restrict f)) (HolderOnWith C r f s)","decl":"theorem restrict_iff {s : Set X} : HolderWith C r (s.restrict f) ‚Üî HolderOnWith C r f s := by\n  simp [HolderWith, HolderOnWith]\n\n"}
{"name":"HolderOnWith.holderWith","module":"Mathlib.Topology.MetricSpace.Holder","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : PseudoEMetricSpace X\ninst‚úù : PseudoEMetricSpace Y\nC r : NNReal\nf : X ‚Üí Y\ns : Set X\na‚úù : HolderOnWith C r f s\n‚ä¢ HolderWith C r (s.restrict f)","decl":"protected alias ‚ü®_, _root_.HolderOnWith.holderWith‚ü© := restrict_iff\n\n"}
{"name":"HolderWith.edist_le","module":"Mathlib.Topology.MetricSpace.Holder","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : PseudoEMetricSpace X\ninst‚úù : PseudoEMetricSpace Y\nC r : NNReal\nf : X ‚Üí Y\nh : HolderWith C r f\nx y : X\n‚ä¢ LE.le (EDist.edist (f x) (f y)) (HMul.hMul (‚ÜëC) (HPow.hPow (EDist.edist x y) ‚Üër))","decl":"theorem edist_le (h : HolderWith C r f) (x y : X) :\n    edist (f x) (f y) ‚â§ (C : ‚Ñù‚â•0‚àû) * edist x y ^ (r : ‚Ñù) :=\n  h x y\n\n"}
{"name":"HolderWith.edist_le_of_le","module":"Mathlib.Topology.MetricSpace.Holder","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : PseudoEMetricSpace X\ninst‚úù : PseudoEMetricSpace Y\nC r : NNReal\nf : X ‚Üí Y\nh : HolderWith C r f\nx y : X\nd : ENNReal\nhd : LE.le (EDist.edist x y) d\n‚ä¢ LE.le (EDist.edist (f x) (f y)) (HMul.hMul (‚ÜëC) (HPow.hPow d ‚Üër))","decl":"theorem edist_le_of_le (h : HolderWith C r f) {x y : X} {d : ‚Ñù‚â•0‚àû} (hd : edist x y ‚â§ d) :\n    edist (f x) (f y) ‚â§ (C : ‚Ñù‚â•0‚àû) * d ^ (r : ‚Ñù) :=\n  (h.holderOnWith univ).edist_le_of_le trivial trivial hd\n\n"}
{"name":"HolderWith.comp","module":"Mathlib.Topology.MetricSpace.Holder","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst‚úù¬≤ : PseudoEMetricSpace X\ninst‚úù¬π : PseudoEMetricSpace Y\ninst‚úù : PseudoEMetricSpace Z\nCg rg : NNReal\ng : Y ‚Üí Z\nhg : HolderWith Cg rg g\nCf rf : NNReal\nf : X ‚Üí Y\nhf : HolderWith Cf rf f\n‚ä¢ HolderWith (HMul.hMul Cg (HPow.hPow Cf ‚Üërg)) (HMul.hMul rg rf) (Function.comp g f)","decl":"theorem comp {Cg rg : ‚Ñù‚â•0} {g : Y ‚Üí Z} (hg : HolderWith Cg rg g) {Cf rf : ‚Ñù‚â•0} {f : X ‚Üí Y}\n    (hf : HolderWith Cf rf f) : HolderWith (Cg * Cf ^ (rg : ‚Ñù)) (rg * rf) (g ‚àò f) :=\n  (hg.holderOnWith univ).comp_holderWith hf fun _ => trivial\n\n"}
{"name":"HolderWith.comp_holderOnWith","module":"Mathlib.Topology.MetricSpace.Holder","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst‚úù¬≤ : PseudoEMetricSpace X\ninst‚úù¬π : PseudoEMetricSpace Y\ninst‚úù : PseudoEMetricSpace Z\nCg rg : NNReal\ng : Y ‚Üí Z\nhg : HolderWith Cg rg g\nCf rf : NNReal\nf : X ‚Üí Y\ns : Set X\nhf : HolderOnWith Cf rf f s\n‚ä¢ HolderOnWith (HMul.hMul Cg (HPow.hPow Cf ‚Üërg)) (HMul.hMul rg rf) (Function.comp g f) s","decl":"theorem comp_holderOnWith {Cg rg : ‚Ñù‚â•0} {g : Y ‚Üí Z} (hg : HolderWith Cg rg g) {Cf rf : ‚Ñù‚â•0}\n    {f : X ‚Üí Y} {s : Set X} (hf : HolderOnWith Cf rf f s) :\n    HolderOnWith (Cg * Cf ^ (rg : ‚Ñù)) (rg * rf) (g ‚àò f) s :=\n  (hg.holderOnWith univ).comp hf fun _ _ => trivial\n\n"}
{"name":"HolderWith.uniformContinuous","module":"Mathlib.Topology.MetricSpace.Holder","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : PseudoEMetricSpace X\ninst‚úù : PseudoEMetricSpace Y\nC r : NNReal\nf : X ‚Üí Y\nhf : HolderWith C r f\nh0 : LT.lt 0 r\n‚ä¢ UniformContinuous f","decl":"/-- A H√∂lder continuous function is uniformly continuous -/\nprotected theorem uniformContinuous (hf : HolderWith C r f) (h0 : 0 < r) : UniformContinuous f :=\n  uniformContinuousOn_univ.mp <| (hf.holderOnWith univ).uniformContinuousOn h0\n\n"}
{"name":"HolderWith.continuous","module":"Mathlib.Topology.MetricSpace.Holder","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : PseudoEMetricSpace X\ninst‚úù : PseudoEMetricSpace Y\nC r : NNReal\nf : X ‚Üí Y\nhf : HolderWith C r f\nh0 : LT.lt 0 r\n‚ä¢ Continuous f","decl":"protected theorem continuous (hf : HolderWith C r f) (h0 : 0 < r) : Continuous f :=\n  (hf.uniformContinuous h0).continuous\n\n"}
{"name":"HolderWith.ediam_image_le","module":"Mathlib.Topology.MetricSpace.Holder","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : PseudoEMetricSpace X\ninst‚úù : PseudoEMetricSpace Y\nC r : NNReal\nf : X ‚Üí Y\nhf : HolderWith C r f\ns : Set X\n‚ä¢ LE.le (EMetric.diam (Set.image f s)) (HMul.hMul (‚ÜëC) (HPow.hPow (EMetric.diam s) ‚Üër))","decl":"theorem ediam_image_le (hf : HolderWith C r f) (s : Set X) :\n    EMetric.diam (f '' s) ‚â§ (C : ‚Ñù‚â•0‚àû) * EMetric.diam s ^ (r : ‚Ñù) :=\n  EMetric.diam_image_le_iff.2 fun _ hx _ hy =>\n    hf.edist_le_of_le <| EMetric.edist_le_diam_of_mem hx hy\n\n"}
{"name":"HolderWith.const","module":"Mathlib.Topology.MetricSpace.Holder","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : PseudoEMetricSpace X\ninst‚úù : PseudoEMetricSpace Y\nC r : NNReal\ny : Y\n‚ä¢ HolderWith C r (Function.const X y)","decl":"lemma const {y : Y} :\n    HolderWith C r (Function.const X y) := fun x‚ÇÅ x‚ÇÇ => by\n  simp only [Function.const_apply, edist_self, zero_le]\n\n"}
{"name":"HolderWith.zero","module":"Mathlib.Topology.MetricSpace.Holder","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : PseudoEMetricSpace X\ninst‚úù¬π : PseudoEMetricSpace Y\nC r : NNReal\ninst‚úù : Zero Y\n‚ä¢ HolderWith C r 0","decl":"lemma zero [Zero Y] : HolderWith C r (0 : X ‚Üí Y) := .const\n\n"}
{"name":"HolderWith.of_isEmpty","module":"Mathlib.Topology.MetricSpace.Holder","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : PseudoEMetricSpace X\ninst‚úù¬π : PseudoEMetricSpace Y\nC r : NNReal\nf : X ‚Üí Y\ninst‚úù : IsEmpty X\n‚ä¢ HolderWith C r f","decl":"lemma of_isEmpty [IsEmpty X] : HolderWith C r f := isEmptyElim\n\n"}
{"name":"HolderWith.mono","module":"Mathlib.Topology.MetricSpace.Holder","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : PseudoEMetricSpace X\ninst‚úù : PseudoEMetricSpace Y\nC r : NNReal\nf : X ‚Üí Y\nC' : NNReal\nhf : HolderWith C r f\nh : LE.le C C'\n‚ä¢ HolderWith C' r f","decl":"lemma mono {C' : ‚Ñù‚â•0} (hf : HolderWith C r f) (h : C ‚â§ C') :\n    HolderWith C' r f :=\n  fun x‚ÇÅ x‚ÇÇ ‚Ü¶ (hf x‚ÇÅ x‚ÇÇ).trans (mul_right_mono (coe_le_coe.2 h))\n\n"}
{"name":"HolderOnWith.nndist_le_of_le","module":"Mathlib.Topology.MetricSpace.Holder","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : PseudoMetricSpace X\ninst‚úù : PseudoMetricSpace Y\nC r : NNReal\nf : X ‚Üí Y\ns : Set X\nx y : X\nhf : HolderOnWith C r f s\nhx : Membership.mem s x\nhy : Membership.mem s y\nd : NNReal\nhd : LE.le (NNDist.nndist x y) d\n‚ä¢ LE.le (NNDist.nndist (f x) (f y)) (HMul.hMul C (HPow.hPow d ‚Üër))","decl":"theorem nndist_le_of_le (hf : HolderOnWith C r f s) (hx : x ‚àà s) (hy : y ‚àà s)\n    {d : ‚Ñù‚â•0} (hd : nndist x y ‚â§ d) : nndist (f x) (f y) ‚â§ C * d ^ (r : ‚Ñù) := by\n  rw [‚Üê ENNReal.coe_le_coe, ‚Üê edist_nndist, ENNReal.coe_mul,\n    ENNReal.coe_rpow_of_nonneg _ r.coe_nonneg]\n  apply hf.edist_le_of_le hx hy\n  rwa [edist_nndist, ENNReal.coe_le_coe]\n\n"}
{"name":"HolderOnWith.nndist_le","module":"Mathlib.Topology.MetricSpace.Holder","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : PseudoMetricSpace X\ninst‚úù : PseudoMetricSpace Y\nC r : NNReal\nf : X ‚Üí Y\ns : Set X\nx y : X\nhf : HolderOnWith C r f s\nhx : Membership.mem s x\nhy : Membership.mem s y\n‚ä¢ LE.le (NNDist.nndist (f x) (f y)) (HMul.hMul C (HPow.hPow (NNDist.nndist x y) ‚Üër))","decl":"theorem nndist_le (hf : HolderOnWith C r f s) (hx : x ‚àà s) (hy : y ‚àà s) :\n    nndist (f x) (f y) ‚â§ C * nndist x y ^ (r : ‚Ñù) :=\n  hf.nndist_le_of_le hx hy le_rfl\n\n"}
{"name":"HolderOnWith.dist_le_of_le","module":"Mathlib.Topology.MetricSpace.Holder","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : PseudoMetricSpace X\ninst‚úù : PseudoMetricSpace Y\nC r : NNReal\nf : X ‚Üí Y\ns : Set X\nx y : X\nhf : HolderOnWith C r f s\nhx : Membership.mem s x\nhy : Membership.mem s y\nd : Real\nhd : LE.le (Dist.dist x y) d\n‚ä¢ LE.le (Dist.dist (f x) (f y)) (HMul.hMul (‚ÜëC) (HPow.hPow d ‚Üër))","decl":"theorem dist_le_of_le (hf : HolderOnWith C r f s) (hx : x ‚àà s) (hy : y ‚àà s)\n    {d : ‚Ñù} (hd : dist x y ‚â§ d) : dist (f x) (f y) ‚â§ C * d ^ (r : ‚Ñù) := by\n  lift d to ‚Ñù‚â•0 using dist_nonneg.trans hd\n  rw [dist_nndist] at hd ‚ä¢\n  norm_cast at hd ‚ä¢\n  exact hf.nndist_le_of_le hx hy hd\n\n"}
{"name":"HolderOnWith.dist_le","module":"Mathlib.Topology.MetricSpace.Holder","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : PseudoMetricSpace X\ninst‚úù : PseudoMetricSpace Y\nC r : NNReal\nf : X ‚Üí Y\ns : Set X\nx y : X\nhf : HolderOnWith C r f s\nhx : Membership.mem s x\nhy : Membership.mem s y\n‚ä¢ LE.le (Dist.dist (f x) (f y)) (HMul.hMul (‚ÜëC) (HPow.hPow (Dist.dist x y) ‚Üër))","decl":"theorem dist_le (hf : HolderOnWith C r f s) (hx : x ‚àà s) (hy : y ‚àà s) :\n    dist (f x) (f y) ‚â§ C * dist x y ^ (r : ‚Ñù) :=\n  hf.dist_le_of_le hx hy le_rfl\n\n"}
{"name":"HolderWith.nndist_le_of_le","module":"Mathlib.Topology.MetricSpace.Holder","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : PseudoMetricSpace X\ninst‚úù : PseudoMetricSpace Y\nC r : NNReal\nf : X ‚Üí Y\nhf : HolderWith C r f\nx y : X\nd : NNReal\nhd : LE.le (NNDist.nndist x y) d\n‚ä¢ LE.le (NNDist.nndist (f x) (f y)) (HMul.hMul C (HPow.hPow d ‚Üër))","decl":"theorem nndist_le_of_le (hf : HolderWith C r f) {x y : X} {d : ‚Ñù‚â•0} (hd : nndist x y ‚â§ d) :\n    nndist (f x) (f y) ‚â§ C * d ^ (r : ‚Ñù) :=\n  (hf.holderOnWith univ).nndist_le_of_le (mem_univ x) (mem_univ y) hd\n\n"}
{"name":"HolderWith.nndist_le","module":"Mathlib.Topology.MetricSpace.Holder","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : PseudoMetricSpace X\ninst‚úù : PseudoMetricSpace Y\nC r : NNReal\nf : X ‚Üí Y\nhf : HolderWith C r f\nx y : X\n‚ä¢ LE.le (NNDist.nndist (f x) (f y)) (HMul.hMul C (HPow.hPow (NNDist.nndist x y) ‚Üër))","decl":"theorem nndist_le (hf : HolderWith C r f) (x y : X) :\n    nndist (f x) (f y) ‚â§ C * nndist x y ^ (r : ‚Ñù) :=\n  hf.nndist_le_of_le le_rfl\n\n"}
{"name":"HolderWith.dist_le_of_le","module":"Mathlib.Topology.MetricSpace.Holder","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : PseudoMetricSpace X\ninst‚úù : PseudoMetricSpace Y\nC r : NNReal\nf : X ‚Üí Y\nhf : HolderWith C r f\nx y : X\nd : Real\nhd : LE.le (Dist.dist x y) d\n‚ä¢ LE.le (Dist.dist (f x) (f y)) (HMul.hMul (‚ÜëC) (HPow.hPow d ‚Üër))","decl":"theorem dist_le_of_le (hf : HolderWith C r f) {x y : X} {d : ‚Ñù} (hd : dist x y ‚â§ d) :\n    dist (f x) (f y) ‚â§ C * d ^ (r : ‚Ñù) :=\n  (hf.holderOnWith univ).dist_le_of_le (mem_univ x) (mem_univ y) hd\n\n"}
{"name":"HolderWith.dist_le","module":"Mathlib.Topology.MetricSpace.Holder","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : PseudoMetricSpace X\ninst‚úù : PseudoMetricSpace Y\nC r : NNReal\nf : X ‚Üí Y\nhf : HolderWith C r f\nx y : X\n‚ä¢ LE.le (Dist.dist (f x) (f y)) (HMul.hMul (‚ÜëC) (HPow.hPow (Dist.dist x y) ‚Üër))","decl":"theorem dist_le (hf : HolderWith C r f) (x y : X) : dist (f x) (f y) ‚â§ C * dist x y ^ (r : ‚Ñù) :=\n  hf.dist_le_of_le le_rfl\n\n"}
{"name":"holderWith_zero_iff","module":"Mathlib.Topology.MetricSpace.Holder","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : PseudoMetricSpace X\ninst‚úù : MetricSpace Y\nr : NNReal\nf : X ‚Üí Y\n‚ä¢ Iff (HolderWith 0 r f) (‚àÄ (x‚ÇÅ x‚ÇÇ : X), Eq (f x‚ÇÅ) (f x‚ÇÇ))","decl":"@[simp]\nlemma holderWith_zero_iff : HolderWith 0 r f ‚Üî ‚àÄ x‚ÇÅ x‚ÇÇ, f x‚ÇÅ = f x‚ÇÇ := by\n  refine ‚ü®fun h x‚ÇÅ x‚ÇÇ => ?_, fun h x‚ÇÅ x‚ÇÇ => h x‚ÇÅ x‚ÇÇ ‚ñ∏ ?_‚ü©\n  ¬∑ specialize h x‚ÇÅ x‚ÇÇ\n    simp [ENNReal.coe_zero, zero_mul, nonpos_iff_eq_zero, edist_eq_zero] at h\n    assumption\n  ¬∑ simp only [edist_self, ENNReal.coe_zero, zero_mul, le_refl]\n\n"}
{"name":"HolderWith.add","module":"Mathlib.Topology.MetricSpace.Holder","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : PseudoMetricSpace X\ninst‚úù : SeminormedAddCommGroup Y\nC C' r : NNReal\nf g : X ‚Üí Y\nhf : HolderWith C r f\nhg : HolderWith C' r g\n‚ä¢ HolderWith (HAdd.hAdd C C') r (HAdd.hAdd f g)","decl":"lemma add (hf : HolderWith C r f) (hg : HolderWith C' r g) :\n    HolderWith (C + C') r (f + g) := fun x‚ÇÅ x‚ÇÇ => by\n  refine le_trans (edist_add_add_le _ _ _ _) <| le_trans (add_le_add (hf x‚ÇÅ x‚ÇÇ) (hg x‚ÇÅ x‚ÇÇ)) ?_\n  rw [coe_add, add_mul]\n\n"}
{"name":"HolderWith.smul","module":"Mathlib.Topology.MetricSpace.Holder","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù‚Å¥ : PseudoMetricSpace X\ninst‚úù¬≥ : SeminormedAddCommGroup Y\nC r : NNReal\nf : X ‚Üí Y\nŒ± : Type u_4\ninst‚úù¬≤ : NormedDivisionRing Œ±\ninst‚úù¬π : Module Œ± Y\ninst‚úù : BoundedSMul Œ± Y\na : Œ±\nhf : HolderWith C r f\n‚ä¢ HolderWith (HMul.hMul C (NNNorm.nnnorm a)) r (HSMul.hSMul a f)","decl":"lemma smul {Œ±} [NormedDivisionRing Œ±] [Module Œ± Y] [BoundedSMul Œ± Y] (a : Œ±)\n    (hf : HolderWith C r f) : HolderWith (C * ‚Äña‚Äñ‚Çä) r (a ‚Ä¢ f) := fun x‚ÇÅ x‚ÇÇ => by\n  rw [Pi.smul_apply, coe_mul, Pi.smul_apply, edist_smul‚ÇÄ, mul_comm (C : ‚Ñù‚â•0‚àû),\n    ENNReal.smul_def, smul_eq_mul, mul_assoc]\n  gcongr\n  exact hf x‚ÇÅ x‚ÇÇ\n\n"}
