{"name":"tendsto_ite","module":"Mathlib.Topology.IndicatorConstPointwise","initialProofState":"ι : Type u_3\nL : Filter ι\nβ : Type u_4\np : ι → Prop\ninst✝¹ : DecidablePred p\nq : Prop\ninst✝ : Decidable q\na b : β\nF G : Filter β\nhaG : Membership.mem G (HasCompl.compl (Singleton.singleton a))\nhbF : Membership.mem F (HasCompl.compl (Singleton.singleton b))\nhaF : LE.le (Filter.principal (Singleton.singleton a)) F\nhbG : LE.le (Filter.principal (Singleton.singleton b)) G\n⊢ Iff (Filter.Tendsto (fun i => ite (p i) a b) L (ite q F G)) (Filter.Eventually (fun i => Iff (p i) q) L)","decl":"lemma tendsto_ite {β : Type*} {p : ι → Prop} [DecidablePred p] {q : Prop} [Decidable q]\n    {a b : β} {F G : Filter β}\n    (haG : {a}ᶜ ∈ G) (hbF : {b}ᶜ ∈ F) (haF : principal {a} ≤ F) (hbG : principal {b} ≤ G) :\n    Tendsto (fun i ↦ if p i then a else b) L (if q then F else G) ↔ ∀ᶠ i in L, p i ↔ q := by\n  constructor <;> intro h\n  · by_cases hq : q\n    · simp only [hq, ite_true] at h\n      filter_upwards [mem_map.mp (h hbF)] with i hi\n      simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage, Set.mem_singleton_iff,\n        ite_eq_right_iff, not_forall, exists_prop] at hi\n      tauto\n    · simp only [hq, ite_false] at h\n      filter_upwards [mem_map.mp (h haG)] with i hi\n      simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage, Set.mem_singleton_iff,\n        ite_eq_left_iff, not_forall, exists_prop] at hi\n      tauto\n  · have obs : (fun _ ↦ if q then a else b) =ᶠ[L] (fun i ↦ if p i then a else b) := by\n      filter_upwards [h] with i hi\n      simp only [hi]\n    apply Tendsto.congr' obs\n    by_cases hq : q\n    · simp only [hq, iff_true, ite_true]\n      apply le_trans _ haF\n      simp only [principal_singleton, le_pure_iff, mem_map, Set.mem_singleton_iff,\n        Set.preimage_const_of_mem, univ_mem]\n    · simp only [hq, ite_false]\n      apply le_trans _ hbG\n      simp only [principal_singleton, le_pure_iff, mem_map, Set.mem_singleton_iff,\n        Set.preimage_const_of_mem, univ_mem]\n\n"}
{"name":"tendsto_indicator_const_apply_iff_eventually'","module":"Mathlib.Topology.IndicatorConstPointwise","initialProofState":"α : Type u_1\nA : Set α\nβ : Type u_2\ninst✝¹ : Zero β\ninst✝ : TopologicalSpace β\nι : Type u_3\nL : Filter ι\nAs : ι → Set α\nb : β\nnhd_b : Membership.mem (nhds b) (HasCompl.compl (Singleton.singleton 0))\nnhd_o : Membership.mem (nhds 0) (HasCompl.compl (Singleton.singleton b))\nx : α\n⊢ Iff (Filter.Tendsto (fun i => (As i).indicator (fun x => b) x) L (nhds (A.indicator (fun x => b) x))) (Filter.Eventually (fun i => Iff (Membership.mem (As i) x) (Membership.mem A x)) L)","decl":"lemma tendsto_indicator_const_apply_iff_eventually' (b : β)\n    (nhd_b : {0}ᶜ ∈ 𝓝 b) (nhd_o : {b}ᶜ ∈ 𝓝 0) (x : α) :\n    Tendsto (fun i ↦ (As i).indicator (fun (_ : α) ↦ b) x) L (𝓝 (A.indicator (fun (_ : α) ↦ b) x))\n      ↔ ∀ᶠ i in L, (x ∈ As i ↔ x ∈ A) := by\n  classical\n  have heart := @tendsto_ite ι L β (fun i ↦ x ∈ As i) _ (x ∈ A) _ b 0 (𝓝 b) (𝓝 (0 : β))\n                nhd_o nhd_b ?_ ?_\n  · convert heart\n    by_cases hxA : x ∈ A <;> simp [hxA]\n  · simp only [principal_singleton, le_def, mem_pure]\n    exact fun s s_nhd ↦ mem_of_mem_nhds s_nhd\n  · simp only [principal_singleton, le_def, mem_pure]\n    exact fun s s_nhd ↦ mem_of_mem_nhds s_nhd\n\n"}
{"name":"tendsto_indicator_const_iff_forall_eventually'","module":"Mathlib.Topology.IndicatorConstPointwise","initialProofState":"α : Type u_1\nA : Set α\nβ : Type u_2\ninst✝¹ : Zero β\ninst✝ : TopologicalSpace β\nι : Type u_3\nL : Filter ι\nAs : ι → Set α\nb : β\nnhd_b : Membership.mem (nhds b) (HasCompl.compl (Singleton.singleton 0))\nnhd_o : Membership.mem (nhds 0) (HasCompl.compl (Singleton.singleton b))\n⊢ Iff (Filter.Tendsto (fun i => (As i).indicator fun x => b) L (nhds (A.indicator fun x => b))) (∀ (x : α), Filter.Eventually (fun i => Iff (Membership.mem (As i) x) (Membership.mem A x)) L)","decl":"lemma tendsto_indicator_const_iff_forall_eventually'\n    (b : β) (nhd_b : {0}ᶜ ∈ 𝓝 b) (nhd_o : {b}ᶜ ∈ 𝓝 0) :\n    Tendsto (fun i ↦ (As i).indicator (fun (_ : α) ↦ b)) L (𝓝 (A.indicator (fun (_ : α) ↦ b)))\n      ↔ ∀ x, ∀ᶠ i in L, (x ∈ As i ↔ x ∈ A) := by\n  simp_rw [tendsto_pi_nhds]\n  apply forall_congr'\n  exact tendsto_indicator_const_apply_iff_eventually' L b nhd_b nhd_o\n\n"}
{"name":"tendsto_indicator_const_apply_iff_eventually","module":"Mathlib.Topology.IndicatorConstPointwise","initialProofState":"α : Type u_1\nA : Set α\nβ : Type u_2\ninst✝³ : Zero β\ninst✝² : TopologicalSpace β\nι : Type u_3\nL : Filter ι\nAs : ι → Set α\ninst✝¹ : T1Space β\nb : β\ninst✝ : NeZero b\nx : α\n⊢ Iff (Filter.Tendsto (fun i => (As i).indicator (fun x => b) x) L (nhds (A.indicator (fun x => b) x))) (Filter.Eventually (fun i => Iff (Membership.mem (As i) x) (Membership.mem A x)) L)","decl":"/-- The indicator functions of `Asᵢ` evaluated at `x` tend to the indicator function of `A`\nevaluated at `x` if and only if we eventually have the equivalence `x ∈ Asᵢ ↔ x ∈ A`. -/\n@[simp] lemma tendsto_indicator_const_apply_iff_eventually [T1Space β] (b : β) [NeZero b]\n    (x : α) :\n    Tendsto (fun i ↦ (As i).indicator (fun (_ : α) ↦ b) x) L (𝓝 (A.indicator (fun (_ : α) ↦ b) x))\n      ↔ ∀ᶠ i in L, (x ∈ As i ↔ x ∈ A) := by\n  apply tendsto_indicator_const_apply_iff_eventually' _ b\n  · simp only [compl_singleton_mem_nhds_iff, ne_eq, NeZero.ne, not_false_eq_true]\n  · simp only [compl_singleton_mem_nhds_iff, ne_eq, (NeZero.ne b).symm, not_false_eq_true]\n\n"}
{"name":"tendsto_indicator_const_iff_forall_eventually","module":"Mathlib.Topology.IndicatorConstPointwise","initialProofState":"α : Type u_1\nA : Set α\nβ : Type u_2\ninst✝³ : Zero β\ninst✝² : TopologicalSpace β\nι : Type u_3\nL : Filter ι\nAs : ι → Set α\ninst✝¹ : T1Space β\nb : β\ninst✝ : NeZero b\n⊢ Iff (Filter.Tendsto (fun i => (As i).indicator fun x => b) L (nhds (A.indicator fun x => b))) (∀ (x : α), Filter.Eventually (fun i => Iff (Membership.mem (As i) x) (Membership.mem A x)) L)","decl":"/-- The indicator functions of `Asᵢ` tend to the indicator function of `A` pointwise if and only if\nfor every `x`, we eventually have the equivalence `x ∈ Asᵢ ↔ x ∈ A`. -/\n@[simp] lemma tendsto_indicator_const_iff_forall_eventually [T1Space β] (b : β) [NeZero b] :\n    Tendsto (fun i ↦ (As i).indicator (fun (_ : α) ↦ b)) L (𝓝 (A.indicator (fun (_ : α) ↦ b)))\n      ↔ ∀ x, ∀ᶠ i in L, (x ∈ As i ↔ x ∈ A) := by\n  apply tendsto_indicator_const_iff_forall_eventually' _ b\n  · simp only [compl_singleton_mem_nhds_iff, ne_eq, NeZero.ne, not_false_eq_true]\n  · simp only [compl_singleton_mem_nhds_iff, ne_eq, (NeZero.ne b).symm, not_false_eq_true]\n\n"}
{"name":"tendsto_indicator_const_iff_tendsto_pi_pure'","module":"Mathlib.Topology.IndicatorConstPointwise","initialProofState":"α : Type u_1\nA : Set α\nβ : Type u_2\ninst✝¹ : Zero β\ninst✝ : TopologicalSpace β\nι : Type u_3\nL : Filter ι\nAs : ι → Set α\nb : β\nnhd_b : Membership.mem (nhds b) (HasCompl.compl (Singleton.singleton 0))\nnhd_o : Membership.mem (nhds 0) (HasCompl.compl (Singleton.singleton b))\n⊢ Iff (Filter.Tendsto (fun i => (As i).indicator fun x => b) L (nhds (A.indicator fun x => b))) (Filter.Tendsto As L (Filter.pi fun x => Pure.pure (Membership.mem A x)))","decl":"lemma tendsto_indicator_const_iff_tendsto_pi_pure'\n    (b : β) (nhd_b : {0}ᶜ ∈ 𝓝 b) (nhd_o : {b}ᶜ ∈ 𝓝 0) :\n    Tendsto (fun i ↦ (As i).indicator (fun (_ : α) ↦ b)) L (𝓝 (A.indicator (fun (_ : α) ↦ b)))\n      ↔ (Tendsto As L <| Filter.pi (pure <| · ∈ A)) := by\n  rw [tendsto_indicator_const_iff_forall_eventually' _ b nhd_b nhd_o, tendsto_pi]\n  simp_rw [tendsto_pure]\n  aesop\n\n"}
{"name":"tendsto_indicator_const_iff_tendsto_pi_pure","module":"Mathlib.Topology.IndicatorConstPointwise","initialProofState":"α : Type u_1\nA : Set α\nβ : Type u_2\ninst✝³ : Zero β\ninst✝² : TopologicalSpace β\nι : Type u_3\nL : Filter ι\nAs : ι → Set α\ninst✝¹ : T1Space β\nb : β\ninst✝ : NeZero b\n⊢ Iff (Filter.Tendsto (fun i => (As i).indicator fun x => b) L (nhds (A.indicator fun x => b))) (Filter.Tendsto As L (Filter.pi fun x => Pure.pure (Membership.mem A x)))","decl":"lemma tendsto_indicator_const_iff_tendsto_pi_pure [T1Space β] (b : β) [NeZero b] :\n    Tendsto (fun i ↦ (As i).indicator (fun (_ : α) ↦ b)) L (𝓝 (A.indicator (fun (_ : α) ↦ b)))\n      ↔ (Tendsto As L <| Filter.pi (pure <| · ∈ A)) := by\n  rw [tendsto_indicator_const_iff_forall_eventually _ b, tendsto_pi]\n  simp_rw [tendsto_pure]\n  aesop\n"}
