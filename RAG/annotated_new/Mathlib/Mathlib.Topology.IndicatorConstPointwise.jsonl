{"name":"tendsto_ite","module":"Mathlib.Topology.IndicatorConstPointwise","initialProofState":"Î¹ : Type u_3\nL : Filter Î¹\nÎ² : Type u_4\np : Î¹ â†’ Prop\ninstâœÂ¹ : DecidablePred p\nq : Prop\ninstâœ : Decidable q\na b : Î²\nF G : Filter Î²\nhaG : Membership.mem G (HasCompl.compl (Singleton.singleton a))\nhbF : Membership.mem F (HasCompl.compl (Singleton.singleton b))\nhaF : LE.le (Filter.principal (Singleton.singleton a)) F\nhbG : LE.le (Filter.principal (Singleton.singleton b)) G\nâŠ¢ Iff (Filter.Tendsto (fun i => ite (p i) a b) L (ite q F G)) (Filter.Eventually (fun i => Iff (p i) q) L)","decl":"lemma tendsto_ite {Î² : Type*} {p : Î¹ â†’ Prop} [DecidablePred p] {q : Prop} [Decidable q]\n    {a b : Î²} {F G : Filter Î²}\n    (haG : {a}á¶œ âˆˆ G) (hbF : {b}á¶œ âˆˆ F) (haF : principal {a} â‰¤ F) (hbG : principal {b} â‰¤ G) :\n    Tendsto (fun i â†¦ if p i then a else b) L (if q then F else G) â†” âˆ€á¶  i in L, p i â†” q := by\n  constructor <;> intro h\n  Â· by_cases hq : q\n    Â· simp only [hq, ite_true] at h\n      filter_upwards [mem_map.mp (h hbF)] with i hi\n      simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage, Set.mem_singleton_iff,\n        ite_eq_right_iff, not_forall, exists_prop] at hi\n      tauto\n    Â· simp only [hq, ite_false] at h\n      filter_upwards [mem_map.mp (h haG)] with i hi\n      simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage, Set.mem_singleton_iff,\n        ite_eq_left_iff, not_forall, exists_prop] at hi\n      tauto\n  Â· have obs : (fun _ â†¦ if q then a else b) =á¶ [L] (fun i â†¦ if p i then a else b) := by\n      filter_upwards [h] with i hi\n      simp only [hi]\n    apply Tendsto.congr' obs\n    by_cases hq : q\n    Â· simp only [hq, iff_true, ite_true]\n      apply le_trans _ haF\n      simp only [principal_singleton, le_pure_iff, mem_map, Set.mem_singleton_iff,\n        Set.preimage_const_of_mem, univ_mem]\n    Â· simp only [hq, ite_false]\n      apply le_trans _ hbG\n      simp only [principal_singleton, le_pure_iff, mem_map, Set.mem_singleton_iff,\n        Set.preimage_const_of_mem, univ_mem]\n\n"}
{"name":"tendsto_indicator_const_apply_iff_eventually'","module":"Mathlib.Topology.IndicatorConstPointwise","initialProofState":"Î± : Type u_1\nA : Set Î±\nÎ² : Type u_2\ninstâœÂ¹ : Zero Î²\ninstâœ : TopologicalSpace Î²\nÎ¹ : Type u_3\nL : Filter Î¹\nAs : Î¹ â†’ Set Î±\nb : Î²\nnhd_b : Membership.mem (nhds b) (HasCompl.compl (Singleton.singleton 0))\nnhd_o : Membership.mem (nhds 0) (HasCompl.compl (Singleton.singleton b))\nx : Î±\nâŠ¢ Iff (Filter.Tendsto (fun i => (As i).indicator (fun x => b) x) L (nhds (A.indicator (fun x => b) x))) (Filter.Eventually (fun i => Iff (Membership.mem (As i) x) (Membership.mem A x)) L)","decl":"lemma tendsto_indicator_const_apply_iff_eventually' (b : Î²)\n    (nhd_b : {0}á¶œ âˆˆ ğ“ b) (nhd_o : {b}á¶œ âˆˆ ğ“ 0) (x : Î±) :\n    Tendsto (fun i â†¦ (As i).indicator (fun (_ : Î±) â†¦ b) x) L (ğ“ (A.indicator (fun (_ : Î±) â†¦ b) x))\n      â†” âˆ€á¶  i in L, (x âˆˆ As i â†” x âˆˆ A) := by\n  classical\n  have heart := @tendsto_ite Î¹ L Î² (fun i â†¦ x âˆˆ As i) _ (x âˆˆ A) _ b 0 (ğ“ b) (ğ“ (0 : Î²))\n                nhd_o nhd_b ?_ ?_\n  Â· convert heart\n    by_cases hxA : x âˆˆ A <;> simp [hxA]\n  Â· simp only [principal_singleton, le_def, mem_pure]\n    exact fun s s_nhd â†¦ mem_of_mem_nhds s_nhd\n  Â· simp only [principal_singleton, le_def, mem_pure]\n    exact fun s s_nhd â†¦ mem_of_mem_nhds s_nhd\n\n"}
{"name":"tendsto_indicator_const_iff_forall_eventually'","module":"Mathlib.Topology.IndicatorConstPointwise","initialProofState":"Î± : Type u_1\nA : Set Î±\nÎ² : Type u_2\ninstâœÂ¹ : Zero Î²\ninstâœ : TopologicalSpace Î²\nÎ¹ : Type u_3\nL : Filter Î¹\nAs : Î¹ â†’ Set Î±\nb : Î²\nnhd_b : Membership.mem (nhds b) (HasCompl.compl (Singleton.singleton 0))\nnhd_o : Membership.mem (nhds 0) (HasCompl.compl (Singleton.singleton b))\nâŠ¢ Iff (Filter.Tendsto (fun i => (As i).indicator fun x => b) L (nhds (A.indicator fun x => b))) (âˆ€ (x : Î±), Filter.Eventually (fun i => Iff (Membership.mem (As i) x) (Membership.mem A x)) L)","decl":"lemma tendsto_indicator_const_iff_forall_eventually'\n    (b : Î²) (nhd_b : {0}á¶œ âˆˆ ğ“ b) (nhd_o : {b}á¶œ âˆˆ ğ“ 0) :\n    Tendsto (fun i â†¦ (As i).indicator (fun (_ : Î±) â†¦ b)) L (ğ“ (A.indicator (fun (_ : Î±) â†¦ b)))\n      â†” âˆ€ x, âˆ€á¶  i in L, (x âˆˆ As i â†” x âˆˆ A) := by\n  simp_rw [tendsto_pi_nhds]\n  apply forall_congr'\n  exact tendsto_indicator_const_apply_iff_eventually' L b nhd_b nhd_o\n\n"}
{"name":"tendsto_indicator_const_apply_iff_eventually","module":"Mathlib.Topology.IndicatorConstPointwise","initialProofState":"Î± : Type u_1\nA : Set Î±\nÎ² : Type u_2\ninstâœÂ³ : Zero Î²\ninstâœÂ² : TopologicalSpace Î²\nÎ¹ : Type u_3\nL : Filter Î¹\nAs : Î¹ â†’ Set Î±\ninstâœÂ¹ : T1Space Î²\nb : Î²\ninstâœ : NeZero b\nx : Î±\nâŠ¢ Iff (Filter.Tendsto (fun i => (As i).indicator (fun x => b) x) L (nhds (A.indicator (fun x => b) x))) (Filter.Eventually (fun i => Iff (Membership.mem (As i) x) (Membership.mem A x)) L)","decl":"/-- The indicator functions of `Asáµ¢` evaluated at `x` tend to the indicator function of `A`\nevaluated at `x` if and only if we eventually have the equivalence `x âˆˆ Asáµ¢ â†” x âˆˆ A`. -/\n@[simp] lemma tendsto_indicator_const_apply_iff_eventually [T1Space Î²] (b : Î²) [NeZero b]\n    (x : Î±) :\n    Tendsto (fun i â†¦ (As i).indicator (fun (_ : Î±) â†¦ b) x) L (ğ“ (A.indicator (fun (_ : Î±) â†¦ b) x))\n      â†” âˆ€á¶  i in L, (x âˆˆ As i â†” x âˆˆ A) := by\n  apply tendsto_indicator_const_apply_iff_eventually' _ b\n  Â· simp only [compl_singleton_mem_nhds_iff, ne_eq, NeZero.ne, not_false_eq_true]\n  Â· simp only [compl_singleton_mem_nhds_iff, ne_eq, (NeZero.ne b).symm, not_false_eq_true]\n\n"}
{"name":"tendsto_indicator_const_iff_forall_eventually","module":"Mathlib.Topology.IndicatorConstPointwise","initialProofState":"Î± : Type u_1\nA : Set Î±\nÎ² : Type u_2\ninstâœÂ³ : Zero Î²\ninstâœÂ² : TopologicalSpace Î²\nÎ¹ : Type u_3\nL : Filter Î¹\nAs : Î¹ â†’ Set Î±\ninstâœÂ¹ : T1Space Î²\nb : Î²\ninstâœ : NeZero b\nâŠ¢ Iff (Filter.Tendsto (fun i => (As i).indicator fun x => b) L (nhds (A.indicator fun x => b))) (âˆ€ (x : Î±), Filter.Eventually (fun i => Iff (Membership.mem (As i) x) (Membership.mem A x)) L)","decl":"/-- The indicator functions of `Asáµ¢` tend to the indicator function of `A` pointwise if and only if\nfor every `x`, we eventually have the equivalence `x âˆˆ Asáµ¢ â†” x âˆˆ A`. -/\n@[simp] lemma tendsto_indicator_const_iff_forall_eventually [T1Space Î²] (b : Î²) [NeZero b] :\n    Tendsto (fun i â†¦ (As i).indicator (fun (_ : Î±) â†¦ b)) L (ğ“ (A.indicator (fun (_ : Î±) â†¦ b)))\n      â†” âˆ€ x, âˆ€á¶  i in L, (x âˆˆ As i â†” x âˆˆ A) := by\n  apply tendsto_indicator_const_iff_forall_eventually' _ b\n  Â· simp only [compl_singleton_mem_nhds_iff, ne_eq, NeZero.ne, not_false_eq_true]\n  Â· simp only [compl_singleton_mem_nhds_iff, ne_eq, (NeZero.ne b).symm, not_false_eq_true]\n\n"}
{"name":"tendsto_indicator_const_iff_tendsto_pi_pure'","module":"Mathlib.Topology.IndicatorConstPointwise","initialProofState":"Î± : Type u_1\nA : Set Î±\nÎ² : Type u_2\ninstâœÂ¹ : Zero Î²\ninstâœ : TopologicalSpace Î²\nÎ¹ : Type u_3\nL : Filter Î¹\nAs : Î¹ â†’ Set Î±\nb : Î²\nnhd_b : Membership.mem (nhds b) (HasCompl.compl (Singleton.singleton 0))\nnhd_o : Membership.mem (nhds 0) (HasCompl.compl (Singleton.singleton b))\nâŠ¢ Iff (Filter.Tendsto (fun i => (As i).indicator fun x => b) L (nhds (A.indicator fun x => b))) (Filter.Tendsto As L (Filter.pi fun x => Pure.pure (Membership.mem A x)))","decl":"lemma tendsto_indicator_const_iff_tendsto_pi_pure'\n    (b : Î²) (nhd_b : {0}á¶œ âˆˆ ğ“ b) (nhd_o : {b}á¶œ âˆˆ ğ“ 0) :\n    Tendsto (fun i â†¦ (As i).indicator (fun (_ : Î±) â†¦ b)) L (ğ“ (A.indicator (fun (_ : Î±) â†¦ b)))\n      â†” (Tendsto As L <| Filter.pi (pure <| Â· âˆˆ A)) := by\n  rw [tendsto_indicator_const_iff_forall_eventually' _ b nhd_b nhd_o, tendsto_pi]\n  simp_rw [tendsto_pure]\n  aesop\n\n"}
{"name":"tendsto_indicator_const_iff_tendsto_pi_pure","module":"Mathlib.Topology.IndicatorConstPointwise","initialProofState":"Î± : Type u_1\nA : Set Î±\nÎ² : Type u_2\ninstâœÂ³ : Zero Î²\ninstâœÂ² : TopologicalSpace Î²\nÎ¹ : Type u_3\nL : Filter Î¹\nAs : Î¹ â†’ Set Î±\ninstâœÂ¹ : T1Space Î²\nb : Î²\ninstâœ : NeZero b\nâŠ¢ Iff (Filter.Tendsto (fun i => (As i).indicator fun x => b) L (nhds (A.indicator fun x => b))) (Filter.Tendsto As L (Filter.pi fun x => Pure.pure (Membership.mem A x)))","decl":"lemma tendsto_indicator_const_iff_tendsto_pi_pure [T1Space Î²] (b : Î²) [NeZero b] :\n    Tendsto (fun i â†¦ (As i).indicator (fun (_ : Î±) â†¦ b)) L (ğ“ (A.indicator (fun (_ : Î±) â†¦ b)))\n      â†” (Tendsto As L <| Filter.pi (pure <| Â· âˆˆ A)) := by\n  rw [tendsto_indicator_const_iff_forall_eventually _ b, tendsto_pi]\n  simp_rw [tendsto_pure]\n  aesop\n"}
