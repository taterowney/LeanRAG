{"name":"IsLinearMap.map_add","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\nf : M → M₂\nself : IsLinearMap R f\nx y : M\n⊢ Eq (f (HAdd.hAdd x y)) (HAdd.hAdd (f x) (f y))","decl":"/-- A map `f` between modules over a semiring is linear if it satisfies the two properties\n`f (x + y) = f x + f y` and `f (c • x) = c • f x`. The predicate `IsLinearMap R f` asserts this\nproperty. A bundled version is available with `LinearMap`, and should be favored over\n`IsLinearMap` most of the time. -/\nstructure IsLinearMap (R : Type u) {M : Type v} {M₂ : Type w} [Semiring R] [AddCommMonoid M]\n  [AddCommMonoid M₂] [Module R M] [Module R M₂] (f : M → M₂) : Prop where\n  /-- A linear map preserves addition. -/\n  map_add : ∀ x y, f (x + y) = f x + f y\n  /-- A linear map preserves scalar multiplication. -/\n  map_smul : ∀ (c : R) (x), f (c • x) = c • f x\n\n"}
{"name":"IsLinearMap.map_smul","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\nf : M → M₂\nself : IsLinearMap R f\nc : R\nx : M\n⊢ Eq (f (HSMul.hSMul c x)) (HSMul.hSMul c (f x))","decl":"/-- A map `f` between modules over a semiring is linear if it satisfies the two properties\n`f (x + y) = f x + f y` and `f (c • x) = c • f x`. The predicate `IsLinearMap R f` asserts this\nproperty. A bundled version is available with `LinearMap`, and should be favored over\n`IsLinearMap` most of the time. -/\nstructure IsLinearMap (R : Type u) {M : Type v} {M₂ : Type w} [Semiring R] [AddCommMonoid M]\n  [AddCommMonoid M₂] [Module R M] [Module R M₂] (f : M → M₂) : Prop where\n  /-- A linear map preserves addition. -/\n  map_add : ∀ x y, f (x + y) = f x + f y\n  /-- A linear map preserves scalar multiplication. -/\n  map_smul : ∀ (c : R) (x), f (c • x) = c • f x\n\n"}
{"name":"LinearMap.mk.injEq","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_14\nS : Type u_15\ninst✝⁵ : Semiring R\ninst✝⁴ : Semiring S\nσ : RingHom R S\nM : Type u_16\nM₂ : Type u_17\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module S M₂\ntoAddHom✝ : AddHom M M₂\nmap_smul'✝ : ∀ (m : R) (x : M), Eq (toAddHom✝.toFun (HSMul.hSMul m x)) (HSMul.hSMul (σ m) (toAddHom✝.toFun x))\ntoAddHom : AddHom M M₂\nmap_smul' : ∀ (m : R) (x : M), Eq (toAddHom.toFun (HSMul.hSMul m x)) (HSMul.hSMul (σ m) (toAddHom.toFun x))\n⊢ Eq (Eq { toAddHom := toAddHom✝, map_smul' := map_smul'✝ } { toAddHom := toAddHom, map_smul' := map_smul' }) (Eq toAddHom✝ toAddHom)","decl":"/-- A map `f` between an `R`-module and an `S`-module over a ring homomorphism `σ : R →+* S`\nis semilinear if it satisfies the two properties `f (x + y) = f x + f y` and\n`f (c • x) = (σ c) • f x`. Elements of `LinearMap σ M M₂` (available under the notation\n`M →ₛₗ[σ] M₂`) are bundled versions of such maps. For plain linear maps (i.e. for which\n`σ = RingHom.id R`), the notation `M →ₗ[R] M₂` is available. An unbundled version of plain linear\nmaps is available with the predicate `IsLinearMap`, but it should be avoided most of the time. -/\nstructure LinearMap {R S : Type*} [Semiring R] [Semiring S] (σ : R →+* S) (M : Type*)\n    (M₂ : Type*) [AddCommMonoid M] [AddCommMonoid M₂] [Module R M] [Module S M₂] extends\n    AddHom M M₂, MulActionHom σ M M₂\n\n"}
{"name":"LinearMap.mk.inj","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_14\nS : Type u_15\ninst✝⁵ : Semiring R\ninst✝⁴ : Semiring S\nσ : RingHom R S\nM : Type u_16\nM₂ : Type u_17\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module S M₂\ntoAddHom✝ : AddHom M M₂\nmap_smul'✝ : ∀ (m : R) (x : M), Eq (toAddHom✝.toFun (HSMul.hSMul m x)) (HSMul.hSMul (σ m) (toAddHom✝.toFun x))\ntoAddHom : AddHom M M₂\nmap_smul' : ∀ (m : R) (x : M), Eq (toAddHom.toFun (HSMul.hSMul m x)) (HSMul.hSMul (σ m) (toAddHom.toFun x))\nx✝ : Eq { toAddHom := toAddHom✝, map_smul' := map_smul'✝ } { toAddHom := toAddHom, map_smul' := map_smul' }\n⊢ Eq toAddHom✝ toAddHom","decl":"/-- A map `f` between an `R`-module and an `S`-module over a ring homomorphism `σ : R →+* S`\nis semilinear if it satisfies the two properties `f (x + y) = f x + f y` and\n`f (c • x) = (σ c) • f x`. Elements of `LinearMap σ M M₂` (available under the notation\n`M →ₛₗ[σ] M₂`) are bundled versions of such maps. For plain linear maps (i.e. for which\n`σ = RingHom.id R`), the notation `M →ₗ[R] M₂` is available. An unbundled version of plain linear\nmaps is available with the predicate `IsLinearMap`, but it should be avoided most of the time. -/\nstructure LinearMap {R S : Type*} [Semiring R] [Semiring S] (σ : R →+* S) (M : Type*)\n    (M₂ : Type*) [AddCommMonoid M] [AddCommMonoid M₂] [Module R M] [Module S M₂] extends\n    AddHom M M₂, MulActionHom σ M M₂\n\n"}
{"name":"LinearMap.map_smul'","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_14\nS : Type u_15\ninst✝⁵ : Semiring R\ninst✝⁴ : Semiring S\nσ : RingHom R S\nM : Type u_16\nM₂ : Type u_17\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module S M₂\nself : LinearMap σ M M₂\nm : R\nx : M\n⊢ Eq (self.toFun (HSMul.hSMul m x)) (HSMul.hSMul (σ m) (self.toFun x))","decl":"/-- A map `f` between an `R`-module and an `S`-module over a ring homomorphism `σ : R →+* S`\nis semilinear if it satisfies the two properties `f (x + y) = f x + f y` and\n`f (c • x) = (σ c) • f x`. Elements of `LinearMap σ M M₂` (available under the notation\n`M →ₛₗ[σ] M₂`) are bundled versions of such maps. For plain linear maps (i.e. for which\n`σ = RingHom.id R`), the notation `M →ₗ[R] M₂` is available. An unbundled version of plain linear\nmaps is available with the predicate `IsLinearMap`, but it should be avoided most of the time. -/\nstructure LinearMap {R S : Type*} [Semiring R] [Semiring S] (σ : R →+* S) (M : Type*)\n    (M₂ : Type*) [AddCommMonoid M] [AddCommMonoid M₂] [Module R M] [Module S M₂] extends\n    AddHom M M₂, MulActionHom σ M M₂\n\n"}
{"name":"LinearMap.mk.sizeOf_spec","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_14\nS : Type u_15\ninst✝⁹ : Semiring R\ninst✝⁸ : Semiring S\nσ : RingHom R S\nM : Type u_16\nM₂ : Type u_17\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid M₂\ninst✝⁵ : Module R M\ninst✝⁴ : Module S M₂\ninst✝³ : SizeOf R\ninst✝² : SizeOf S\ninst✝¹ : SizeOf M\ninst✝ : SizeOf M₂\ntoAddHom : AddHom M M₂\nmap_smul' : ∀ (m : R) (x : M), Eq (toAddHom.toFun (HSMul.hSMul m x)) (HSMul.hSMul (σ m) (toAddHom.toFun x))\n⊢ Eq (SizeOf.sizeOf { toAddHom := toAddHom, map_smul' := map_smul' }) (HAdd.hAdd 1 (SizeOf.sizeOf toAddHom))","decl":"/-- A map `f` between an `R`-module and an `S`-module over a ring homomorphism `σ : R →+* S`\nis semilinear if it satisfies the two properties `f (x + y) = f x + f y` and\n`f (c • x) = (σ c) • f x`. Elements of `LinearMap σ M M₂` (available under the notation\n`M →ₛₗ[σ] M₂`) are bundled versions of such maps. For plain linear maps (i.e. for which\n`σ = RingHom.id R`), the notation `M →ₗ[R] M₂` is available. An unbundled version of plain linear\nmaps is available with the predicate `IsLinearMap`, but it should be avoided most of the time. -/\nstructure LinearMap {R S : Type*} [Semiring R] [Semiring S] (σ : R →+* S) (M : Type*)\n    (M₂ : Type*) [AddCommMonoid M] [AddCommMonoid M₂] [Module R M] [Module S M₂] extends\n    AddHom M M₂, MulActionHom σ M M₂\n\n"}
{"name":"SemilinearMapClass.toAddHomClass","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"F : Type u_14\nR : outParam (Type u_15)\nS : outParam (Type u_16)\ninst✝⁶ : Semiring R\ninst✝⁵ : Semiring S\nσ : outParam (RingHom R S)\nM : outParam (Type u_17)\nM₂ : outParam (Type u_18)\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid M₂\ninst✝² : Module R M\ninst✝¹ : Module S M₂\ninst✝ : FunLike F M M₂\nself : SemilinearMapClass F σ M M₂\n⊢ AddHomClass F M M₂","decl":"/-- `SemilinearMapClass F σ M M₂` asserts `F` is a type of bundled `σ`-semilinear maps `M → M₂`.\n\nSee also `LinearMapClass F R M M₂` for the case where `σ` is the identity map on `R`.\n\nA map `f` between an `R`-module and an `S`-module over a ring homomorphism `σ : R →+* S`\nis semilinear if it satisfies the two properties `f (x + y) = f x + f y` and\n`f (c • x) = (σ c) • f x`. -/\nclass SemilinearMapClass (F : Type*) {R S : outParam Type*} [Semiring R] [Semiring S]\n  (σ : outParam (R →+* S)) (M M₂ : outParam Type*) [AddCommMonoid M] [AddCommMonoid M₂]\n    [Module R M] [Module S M₂] [FunLike F M M₂]\n    extends AddHomClass F M M₂, MulActionSemiHomClass F σ M M₂ : Prop\n\n"}
{"name":"SemilinearMapClass.toMulActionSemiHomClass","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"F : Type u_14\nR : outParam (Type u_15)\nS : outParam (Type u_16)\ninst✝⁶ : Semiring R\ninst✝⁵ : Semiring S\nσ : outParam (RingHom R S)\nM : outParam (Type u_17)\nM₂ : outParam (Type u_18)\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid M₂\ninst✝² : Module R M\ninst✝¹ : Module S M₂\ninst✝ : FunLike F M M₂\nself : SemilinearMapClass F σ M M₂\n⊢ MulActionSemiHomClass F (⇑σ) M M₂","decl":"/-- `SemilinearMapClass F σ M M₂` asserts `F` is a type of bundled `σ`-semilinear maps `M → M₂`.\n\nSee also `LinearMapClass F R M M₂` for the case where `σ` is the identity map on `R`.\n\nA map `f` between an `R`-module and an `S`-module over a ring homomorphism `σ : R →+* S`\nis semilinear if it satisfies the two properties `f (x + y) = f x + f y` and\n`f (c • x) = (σ c) • f x`. -/\nclass SemilinearMapClass (F : Type*) {R S : outParam Type*} [Semiring R] [Semiring S]\n  (σ : outParam (R →+* S)) (M M₂ : outParam Type*) [AddCommMonoid M] [AddCommMonoid M₂]\n    [Module R M] [Module S M₂] [FunLike F M M₂]\n    extends AddHomClass F M M₂, MulActionSemiHomClass F σ M M₂ : Prop\n\n"}
{"name":"LinearMapClass.map_smul","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : outParam (Type u_14)\nM : outParam (Type u_15)\nM₂ : outParam (Type u_16)\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : Module R M\ninst✝² : Module R M₂\nF : Type u_17\ninst✝¹ : FunLike F M M₂\ninst✝ : LinearMapClass F R M M₂\nf : F\nr : R\nx : M\n⊢ Eq (f (HSMul.hSMul r x)) (HSMul.hSMul r (f x))","decl":"protected lemma LinearMapClass.map_smul {R M M₂ : outParam Type*} [Semiring R] [AddCommMonoid M]\n    [AddCommMonoid M₂] [Module R M] [Module R M₂]\n    {F : Type*} [FunLike F M M₂] [LinearMapClass F R M M₂] (f : F) (r : R) (x : M) :\n    f (r • x) = r • f x := by rw [_root_.map_smul]\n\n"}
{"name":"SemilinearMapClass.instAddMonoidHomClass","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_8\nM₃ : Type u_11\nF : Type u_14\ninst✝⁷ : Semiring R\ninst✝⁶ : Semiring S\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M₃\ninst✝³ : Module R M\ninst✝² : Module S M₃\nσ : RingHom R S\ninst✝¹ : FunLike F M M₃\ninst✝ : SemilinearMapClass F σ M M₃\n⊢ AddMonoidHomClass F M M₃","decl":"instance (priority := 100) instAddMonoidHomClass [FunLike F M M₃] [SemilinearMapClass F σ M M₃] :\n    AddMonoidHomClass F M M₃ :=\n  { SemilinearMapClass.toAddHomClass with\n    map_zero := fun f ↦\n      show f 0 = 0 by\n        rw [← zero_smul R (0 : M), map_smulₛₗ]\n        simp }\n\n"}
{"name":"SemilinearMapClass.distribMulActionSemiHomClass","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_8\nM₃ : Type u_11\nF : Type u_14\ninst✝⁷ : Semiring R\ninst✝⁶ : Semiring S\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M₃\ninst✝³ : Module R M\ninst✝² : Module S M₃\nσ : RingHom R S\ninst✝¹ : FunLike F M M₃\ninst✝ : SemilinearMapClass F σ M M₃\n⊢ DistribMulActionSemiHomClass F (⇑σ) M M₃","decl":"instance (priority := 100) distribMulActionSemiHomClass\n    [FunLike F M M₃] [SemilinearMapClass F σ M M₃] :\n    DistribMulActionSemiHomClass F σ M M₃ :=\n  { SemilinearMapClass.toAddHomClass with\n    map_smulₛₗ := fun f c x ↦ by rw [map_smulₛₗ] }\n\n"}
{"name":"SemilinearMapClass.map_smul_inv","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_8\nM₃ : Type u_11\nF : Type u_14\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring S\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₃\ninst✝⁴ : Module R M\ninst✝³ : Module S M₃\nσ : RingHom R S\nf : F\ninst✝² : FunLike F M M₃\ninst✝¹ : SemilinearMapClass F σ M M₃\nσ' : RingHom S R\ninst✝ : RingHomInvPair σ σ'\nc : S\nx : M\n⊢ Eq (HSMul.hSMul c (f x)) (f (HSMul.hSMul (σ' c) x))","decl":"theorem map_smul_inv {σ' : S →+* R} [RingHomInvPair σ σ'] (c : S) (x : M) :\n    c • f x = f (σ' c • x) := by simp [map_smulₛₗ _]\n\n"}
{"name":"LinearMap.semilinearMapClass","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_8\nM₃ : Type u_11\ninst✝⁵ : Semiring R\ninst✝⁴ : Semiring S\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₃\ninst✝¹ : Module R M\ninst✝ : Module S M₃\nσ : RingHom R S\n⊢ SemilinearMapClass (LinearMap σ M M₃) σ M M₃","decl":"instance semilinearMapClass : SemilinearMapClass (M →ₛₗ[σ] M₃) σ M M₃ where\n  map_add f := f.map_add'\n  map_smulₛₗ := LinearMap.map_smul'\n\n"}
{"name":"LinearMap.coe_coe","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_8\nM₃ : Type u_11\ninst✝⁷ : Semiring R\ninst✝⁶ : Semiring S\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M₃\ninst✝³ : Module R M\ninst✝² : Module S M₃\nσ : RingHom R S\nF : Type u_14\ninst✝¹ : FunLike F M M₃\ninst✝ : SemilinearMapClass F σ M M₃\nf : F\n⊢ Eq ⇑↑f ⇑f","decl":"@[simp, norm_cast]\nlemma coe_coe {F : Type*} [FunLike F M M₃] [SemilinearMapClass F σ M M₃] {f : F} :\n    ⇑(f : M →ₛₗ[σ] M₃) = f :=\n  rfl\n\n"}
{"name":"LinearMap.coe_toAddHom","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_8\nM₃ : Type u_11\ninst✝⁵ : Semiring R\ninst✝⁴ : Semiring S\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₃\ninst✝¹ : Module R M\ninst✝ : Module S M₃\nσ : RingHom R S\nf : LinearMap σ M M₃\n⊢ Eq ⇑f.toAddHom ⇑f","decl":"@[simp]\ntheorem coe_toAddHom (f : M →ₛₗ[σ] M₃) : ⇑f.toAddHom = f := rfl\n\n-- Porting note: no longer a `simp`\n"}
{"name":"LinearMap.toFun_eq_coe","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_8\nM₃ : Type u_11\ninst✝⁵ : Semiring R\ninst✝⁴ : Semiring S\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₃\ninst✝¹ : Module R M\ninst✝ : Module S M₃\nσ : RingHom R S\nf : LinearMap σ M M₃\n⊢ Eq f.toFun ⇑f","decl":"theorem toFun_eq_coe {f : M →ₛₗ[σ] M₃} : f.toFun = (f : M → M₃) := rfl\n\n"}
{"name":"LinearMap.ext","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_8\nM₃ : Type u_11\ninst✝⁵ : Semiring R\ninst✝⁴ : Semiring S\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₃\ninst✝¹ : Module R M\ninst✝ : Module S M₃\nσ : RingHom R S\nf g : LinearMap σ M M₃\nh : ∀ (x : M), Eq (f x) (g x)\n⊢ Eq f g","decl":"@[ext]\ntheorem ext {f g : M →ₛₗ[σ] M₃} (h : ∀ x, f x = g x) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"LinearMap.ext_iff","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_8\nM₃ : Type u_11\ninst✝⁵ : Semiring R\ninst✝⁴ : Semiring S\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₃\ninst✝¹ : Module R M\ninst✝ : Module S M₃\nσ : RingHom R S\nf g : LinearMap σ M M₃\n⊢ Iff (Eq f g) (∀ (x : M), Eq (f x) (g x))","decl":"@[ext]\ntheorem ext {f g : M →ₛₗ[σ] M₃} (h : ∀ x, f x = g x) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"LinearMap.coe_copy","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_8\nM₃ : Type u_11\ninst✝⁵ : Semiring R\ninst✝⁴ : Semiring S\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₃\ninst✝¹ : Module R M\ninst✝ : Module S M₃\nσ : RingHom R S\nf : LinearMap σ M M₃\nf' : M → M₃\nh : Eq f' ⇑f\n⊢ Eq (⇑(f.copy f' h)) f'","decl":"@[simp]\ntheorem coe_copy (f : M →ₛₗ[σ] M₃) (f' : M → M₃) (h : f' = ⇑f) : ⇑(f.copy f' h) = f' :=\n  rfl\n\n"}
{"name":"LinearMap.copy_eq","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_8\nM₃ : Type u_11\ninst✝⁵ : Semiring R\ninst✝⁴ : Semiring S\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₃\ninst✝¹ : Module R M\ninst✝ : Module S M₃\nσ : RingHom R S\nf : LinearMap σ M M₃\nf' : M → M₃\nh : Eq f' ⇑f\n⊢ Eq (f.copy f' h) f","decl":"theorem copy_eq (f : M →ₛₗ[σ] M₃) (f' : M → M₃) (h : f' = ⇑f) : f.copy f' h = f :=\n  DFunLike.ext' h\n\n"}
{"name":"LinearMap.coe_mk","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_8\nM₃ : Type u_11\ninst✝⁵ : Semiring R\ninst✝⁴ : Semiring S\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₃\ninst✝¹ : Module R M\ninst✝ : Module S M₃\nσ : RingHom R S\nf : AddHom M M₃\nh : ∀ (m : R) (x : M), Eq (f.toFun (HSMul.hSMul m x)) (HSMul.hSMul (σ m) (f.toFun x))\n⊢ Eq ⇑{ toAddHom := f, map_smul' := h } ⇑f","decl":"@[simp]\ntheorem coe_mk {σ : R →+* S} (f : AddHom M M₃) (h) :\n    ((LinearMap.mk f h : M →ₛₗ[σ] M₃) : M → M₃) = f :=\n  rfl\n\n-- Porting note: This theorem is new.\n"}
{"name":"LinearMap.coe_addHom_mk","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_8\nM₃ : Type u_11\ninst✝⁵ : Semiring R\ninst✝⁴ : Semiring S\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₃\ninst✝¹ : Module R M\ninst✝ : Module S M₃\nσ : RingHom R S\nf : AddHom M M₃\nh : ∀ (m : R) (x : M), Eq (f.toFun (HSMul.hSMul m x)) (HSMul.hSMul (σ m) (f.toFun x))\n⊢ Eq (↑{ toAddHom := f, map_smul' := h }) f","decl":"@[simp]\ntheorem coe_addHom_mk {σ : R →+* S} (f : AddHom M M₃) (h) :\n    ((LinearMap.mk f h : M →ₛₗ[σ] M₃) : AddHom M M₃) = f :=\n  rfl\n\n"}
{"name":"LinearMap.coe_semilinearMap","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_8\nM₃ : Type u_11\ninst✝⁷ : Semiring R\ninst✝⁶ : Semiring S\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M₃\ninst✝³ : Module R M\ninst✝² : Module S M₃\nσ : RingHom R S\nF : Type u_14\ninst✝¹ : FunLike F M M₃\ninst✝ : SemilinearMapClass F σ M M₃\nf : F\n⊢ Eq ⇑↑f ⇑f","decl":"theorem coe_semilinearMap {F : Type*} [FunLike F M M₃] [SemilinearMapClass F σ M M₃] (f : F) :\n    ((f : M →ₛₗ[σ] M₃) : M → M₃) = f :=\n  rfl\n\n"}
{"name":"LinearMap.toLinearMap_injective","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_8\nM₃ : Type u_11\ninst✝⁷ : Semiring R\ninst✝⁶ : Semiring S\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M₃\ninst✝³ : Module R M\ninst✝² : Module S M₃\nσ : RingHom R S\nF : Type u_14\ninst✝¹ : FunLike F M M₃\ninst✝ : SemilinearMapClass F σ M M₃\nf g : F\nh : Eq ↑f ↑g\n⊢ Eq f g","decl":"theorem toLinearMap_injective {F : Type*} [FunLike F M M₃] [SemilinearMapClass F σ M M₃]\n    {f g : F} (h : (f : M →ₛₗ[σ] M₃) = (g : M →ₛₗ[σ] M₃)) :\n    f = g := by\n  apply DFunLike.ext\n  intro m\n  exact DFunLike.congr_fun h m\n\n"}
{"name":"LinearMap.id_apply","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_1\nM : Type u_8\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx : M\n⊢ Eq (LinearMap.id x) x","decl":"theorem id_apply (x : M) : @id R M _ _ _ x = x :=\n  rfl\n\n"}
{"name":"LinearMap.id_coe","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_1\nM : Type u_8\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Eq (⇑LinearMap.id) id","decl":"@[simp, norm_cast]\ntheorem id_coe : ((LinearMap.id : M →ₗ[R] M) : M → M) = _root_.id :=\n  rfl\n\n"}
{"name":"LinearMap.id'_apply","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_1\nM : Type u_8\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\nσ : RingHom R R\ninst✝ : RingHomId σ\nx : M\n⊢ Eq (LinearMap.id' x) x","decl":"/-- A generalisation of `LinearMap.id` that constructs the identity function\nas a `σ`-semilinear map for any ring homomorphism `σ` which we know is the identity. -/\n@[simps]\ndef id' {σ : R →+* R} [RingHomId σ] : M →ₛₗ[σ] M where\n  toFun x := x\n  map_add' _ _ := rfl\n  map_smul' r x := by\n    have := (RingHomId.eq_id : σ = _)\n    subst this\n    rfl\n\n"}
{"name":"LinearMap.id'_coe","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_1\nM : Type u_8\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\nσ : RingHom R R\ninst✝ : RingHomId σ\n⊢ Eq (⇑LinearMap.id') id","decl":"@[simp, norm_cast]\ntheorem id'_coe {σ : R →+* R} [RingHomId σ] : ((id' : M →ₛₗ[σ] M) : M → M) = _root_.id :=\n  rfl\n\n"}
{"name":"LinearMap.isLinear","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_1\nM : Type u_8\nM₂ : Type u_10\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\nfₗ : LinearMap (RingHom.id R) M M₂\n⊢ IsLinearMap R ⇑fₗ","decl":"theorem isLinear : IsLinearMap R fₗ :=\n  ⟨fₗ.map_add', fₗ.map_smul'⟩\n\n"}
{"name":"LinearMap.coe_injective","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_8\nM₃ : Type u_11\ninst✝⁵ : Semiring R\ninst✝⁴ : Semiring S\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₃\ninst✝¹ : Module R M\ninst✝ : Module S M₃\nσ : RingHom R S\n⊢ Function.Injective DFunLike.coe","decl":"theorem coe_injective : Injective (DFunLike.coe : (M →ₛₗ[σ] M₃) → _) :=\n  DFunLike.coe_injective\n\n"}
{"name":"LinearMap.congr_arg","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_8\nM₃ : Type u_11\ninst✝⁵ : Semiring R\ninst✝⁴ : Semiring S\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₃\ninst✝¹ : Module R M\ninst✝ : Module S M₃\nσ : RingHom R S\nf : LinearMap σ M M₃\nx x' : M\na✝ : Eq x x'\n⊢ Eq (f x) (f x')","decl":"protected theorem congr_arg {x x' : M} : x = x' → f x = f x' :=\n  DFunLike.congr_arg f\n\n"}
{"name":"LinearMap.congr_fun","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_8\nM₃ : Type u_11\ninst✝⁵ : Semiring R\ninst✝⁴ : Semiring S\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₃\ninst✝¹ : Module R M\ninst✝ : Module S M₃\nσ : RingHom R S\nf g : LinearMap σ M M₃\nh : Eq f g\nx : M\n⊢ Eq (f x) (g x)","decl":"/-- If two linear maps are equal, they are equal at each point. -/\nprotected theorem congr_fun (h : f = g) (x : M) : f x = g x :=\n  DFunLike.congr_fun h x\n\n"}
{"name":"LinearMap.mk_coe","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_8\nM₃ : Type u_11\ninst✝⁵ : Semiring R\ninst✝⁴ : Semiring S\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₃\ninst✝¹ : Module R M\ninst✝ : Module S M₃\nσ : RingHom R S\nf : LinearMap σ M M₃\nh : ∀ (m : R) (x : M), Eq ((↑f).toFun (HSMul.hSMul m x)) (HSMul.hSMul (σ m) ((↑f).toFun x))\n⊢ Eq { toAddHom := ↑f, map_smul' := h } f","decl":"@[simp]\ntheorem mk_coe (f : M →ₛₗ[σ] M₃) (h) : (LinearMap.mk f h : M →ₛₗ[σ] M₃) = f :=\n  rfl\n\n"}
{"name":"LinearMap.map_add","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_8\nM₃ : Type u_11\ninst✝⁵ : Semiring R\ninst✝⁴ : Semiring S\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₃\ninst✝¹ : Module R M\ninst✝ : Module S M₃\nσ : RingHom R S\nf : LinearMap σ M M₃\nx y : M\n⊢ Eq (f (HAdd.hAdd x y)) (HAdd.hAdd (f x) (f y))","decl":"protected theorem map_add (x y : M) : f (x + y) = f x + f y :=\n  map_add f x y\n\n"}
{"name":"LinearMap.map_zero","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_8\nM₃ : Type u_11\ninst✝⁵ : Semiring R\ninst✝⁴ : Semiring S\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₃\ninst✝¹ : Module R M\ninst✝ : Module S M₃\nσ : RingHom R S\nf : LinearMap σ M M₃\n⊢ Eq (f 0) 0","decl":"protected theorem map_zero : f 0 = 0 :=\n  map_zero f\n\n-- Porting note: `simp` wasn't picking up `map_smulₛₗ` for `LinearMap`s without specifying\n-- `map_smulₛₗ f`, so we marked this as `@[simp]` in Mathlib3.\n-- For Mathlib4, let's try without the `@[simp]` attribute and hope it won't need to be re-enabled.\n-- This has to be re-tagged as `@[simp]` in https://github.com/leanprover-community/mathlib4/pull/8386 (see also https://github.com/leanprover/lean4/issues/3107).\n"}
{"name":"LinearMap.map_smulₛₗ","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_8\nM₃ : Type u_11\ninst✝⁵ : Semiring R\ninst✝⁴ : Semiring S\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₃\ninst✝¹ : Module R M\ninst✝ : Module S M₃\nσ : RingHom R S\nf : LinearMap σ M M₃\nc : R\nx : M\n⊢ Eq (f (HSMul.hSMul c x)) (HSMul.hSMul (σ c) (f x))","decl":"@[simp]\nprotected theorem map_smulₛₗ (c : R) (x : M) : f (c • x) = σ c • f x :=\n  map_smulₛₗ f c x\n\n"}
{"name":"LinearMap.map_smul","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_1\nM : Type u_8\nM₂ : Type u_10\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\nfₗ : LinearMap (RingHom.id R) M M₂\nc : R\nx : M\n⊢ Eq (fₗ (HSMul.hSMul c x)) (HSMul.hSMul c (fₗ x))","decl":"protected theorem map_smul (c : R) (x : M) : fₗ (c • x) = c • fₗ x :=\n  map_smul fₗ c x\n\n"}
{"name":"LinearMap.map_smul_inv","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_8\nM₃ : Type u_11\ninst✝⁶ : Semiring R\ninst✝⁵ : Semiring S\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid M₃\ninst✝² : Module R M\ninst✝¹ : Module S M₃\nσ : RingHom R S\nf : LinearMap σ M M₃\nσ' : RingHom S R\ninst✝ : RingHomInvPair σ σ'\nc : S\nx : M\n⊢ Eq (HSMul.hSMul c (f x)) (f (HSMul.hSMul (σ' c) x))","decl":"protected theorem map_smul_inv {σ' : S →+* R} [RingHomInvPair σ σ'] (c : S) (x : M) :\n    c • f x = f (σ' c • x) := by simp\n\n"}
{"name":"LinearMap.map_eq_zero_iff","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_8\nM₃ : Type u_11\ninst✝⁵ : Semiring R\ninst✝⁴ : Semiring S\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₃\ninst✝¹ : Module R M\ninst✝ : Module S M₃\nσ : RingHom R S\nf : LinearMap σ M M₃\nh : Function.Injective ⇑f\nx : M\n⊢ Iff (Eq (f x) 0) (Eq x 0)","decl":"@[simp]\ntheorem map_eq_zero_iff (h : Function.Injective f) {x : M} : f x = 0 ↔ x = 0 :=\n  _root_.map_eq_zero_iff f h\n\n"}
{"name":"LinearMap.CompatibleSMul.map_smul","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"M : Type u_8\nM₂ : Type u_10\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\nR : Type u_14\nS : Type u_15\ninst✝⁴ : Semiring S\ninst✝³ : SMul R M\ninst✝² : Module S M\ninst✝¹ : SMul R M₂\ninst✝ : Module S M₂\nself : LinearMap.CompatibleSMul M M₂ R S\nfₗ : LinearMap (RingHom.id S) M M₂\nc : R\nx : M\n⊢ Eq (fₗ (HSMul.hSMul c x)) (HSMul.hSMul c (fₗ x))","decl":"/-- A typeclass for `SMul` structures which can be moved through a `LinearMap`.\nThis typeclass is generated automatically from an `IsScalarTower` instance, but exists so that\nwe can also add an instance for `AddCommGroup.toIntModule`, allowing `z •` to be moved even if\n`S` does not support negation.\n-/\nclass CompatibleSMul (R S : Type*) [Semiring S] [SMul R M] [Module S M] [SMul R M₂]\n  [Module S M₂] : Prop where\n  /-- Scalar multiplication by `R` of `M` can be moved through linear maps. -/\n  map_smul : ∀ (fₗ : M →ₗ[S] M₂) (c : R) (x : M), fₗ (c • x) = c • fₗ x\n\n"}
{"name":"LinearMap.IsScalarTower.compatibleSMul","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"M : Type u_8\nM₂ : Type u_10\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : AddCommMonoid M₂\nR : Type u_14\nS : Type u_15\ninst✝⁷ : Semiring S\ninst✝⁶ : SMul R M\ninst✝⁵ : Module S M\ninst✝⁴ : SMul R M₂\ninst✝³ : Module S M₂\ninst✝² : SMul R S\ninst✝¹ : IsScalarTower R S M\ninst✝ : IsScalarTower R S M₂\n⊢ LinearMap.CompatibleSMul M M₂ R S","decl":"instance (priority := 100) IsScalarTower.compatibleSMul [SMul R S]\n    [IsScalarTower R S M] [IsScalarTower R S M₂] :\n    CompatibleSMul M M₂ R S :=\n  ⟨fun fₗ c x ↦ by rw [← smul_one_smul S c x, ← smul_one_smul S c (fₗ x), map_smul]⟩\n\n"}
{"name":"LinearMap.IsScalarTower.compatibleSMul'","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"M : Type u_8\ninst✝⁵ : AddCommMonoid M\nR : Type u_14\nS : Type u_15\ninst✝⁴ : Semiring S\ninst✝³ : SMul R M\ninst✝² : Module S M\ninst✝¹ : SMul R S\ninst✝ : IsScalarTower R S M\n⊢ LinearMap.CompatibleSMul S M R S","decl":"instance IsScalarTower.compatibleSMul' [SMul R S] [IsScalarTower R S M] :\n    CompatibleSMul S M R S where\n  map_smul := (IsScalarTower.smulHomClass R S M (S →ₗ[S] M)).map_smulₛₗ\n\n"}
{"name":"LinearMap.map_smul_of_tower","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"M : Type u_8\nM₂ : Type u_10\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid M₂\nR : Type u_14\nS : Type u_15\ninst✝⁵ : Semiring S\ninst✝⁴ : SMul R M\ninst✝³ : Module S M\ninst✝² : SMul R M₂\ninst✝¹ : Module S M₂\ninst✝ : LinearMap.CompatibleSMul M M₂ R S\nfₗ : LinearMap (RingHom.id S) M M₂\nc : R\nx : M\n⊢ Eq (fₗ (HSMul.hSMul c x)) (HSMul.hSMul c (fₗ x))","decl":"@[simp]\ntheorem map_smul_of_tower [CompatibleSMul M M₂ R S] (fₗ : M →ₗ[S] M₂) (c : R) (x : M) :\n    fₗ (c • x) = c • fₗ x :=\n  CompatibleSMul.map_smul fₗ c x\n\n"}
{"name":"LinearMap.isScalarTower_of_injective","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"M : Type u_8\nM₂ : Type u_10\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : AddCommMonoid M₂\nR : Type u_14\nS : Type u_15\ninst✝⁷ : Semiring S\ninst✝⁶ : SMul R M\ninst✝⁵ : Module S M\ninst✝⁴ : SMul R M₂\ninst✝³ : Module S M₂\ninst✝² : SMul R S\ninst✝¹ : LinearMap.CompatibleSMul M M₂ R S\ninst✝ : IsScalarTower R S M₂\nf : LinearMap (RingHom.id S) M M₂\nhf : Function.Injective ⇑f\n⊢ IsScalarTower R S M","decl":"variable (R R) in\ntheorem isScalarTower_of_injective [SMul R S] [CompatibleSMul M M₂ R S] [IsScalarTower R S M₂]\n    (f : M →ₗ[S] M₂) (hf : Function.Injective f) : IsScalarTower R S M where\n  smul_assoc r s _ := hf <| by rw [f.map_smul_of_tower r, map_smul, map_smul, smul_assoc]\n\n"}
{"name":"LinearMap.isLinearMap_of_compatibleSMul","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_8\nM₂ : Type u_10\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring S\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R M₂\ninst✝² : Module S M\ninst✝¹ : Module S M₂\ninst✝ : LinearMap.CompatibleSMul M M₂ R S\nf : LinearMap (RingHom.id S) M M₂\n⊢ IsLinearMap R ⇑f","decl":"variable (R) in\ntheorem isLinearMap_of_compatibleSMul [Module S M] [Module S M₂] [CompatibleSMul M M₂ R S]\n    (f : M →ₗ[S] M₂) : IsLinearMap R f where\n  map_add := map_add f\n  map_smul := map_smul_of_tower f\n\n"}
{"name":"LinearMap.toAddMonoidHom_coe","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_8\nM₃ : Type u_11\ninst✝⁵ : Semiring R\ninst✝⁴ : Semiring S\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₃\ninst✝¹ : Module R M\ninst✝ : Module S M₃\nσ : RingHom R S\nf : LinearMap σ M M₃\n⊢ Eq ⇑f.toAddMonoidHom ⇑f","decl":"@[simp]\ntheorem toAddMonoidHom_coe : ⇑f.toAddMonoidHom = f :=\n  rfl\n\n"}
{"name":"LinearMap.coe_restrictScalars","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_8\nM₂ : Type u_10\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring S\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R M₂\ninst✝² : Module S M\ninst✝¹ : Module S M₂\ninst✝ : LinearMap.CompatibleSMul M M₂ R S\nf : LinearMap (RingHom.id S) M M₂\n⊢ Eq ⇑(↑R f) ⇑f","decl":"@[simp, norm_cast]\ntheorem coe_restrictScalars (f : M →ₗ[S] M₂) : ((f : M →ₗ[R] M₂) : M → M₂) = f :=\n  rfl\n\n"}
{"name":"LinearMap.restrictScalars_apply","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_8\nM₂ : Type u_10\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring S\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R M₂\ninst✝² : Module S M\ninst✝¹ : Module S M₂\ninst✝ : LinearMap.CompatibleSMul M M₂ R S\nfₗ : LinearMap (RingHom.id S) M M₂\nx : M\n⊢ Eq ((↑R fₗ) x) (fₗ x)","decl":"theorem restrictScalars_apply (fₗ : M →ₗ[S] M₂) (x) : restrictScalars R fₗ x = fₗ x :=\n  rfl\n\n"}
{"name":"LinearMap.restrictScalars_injective","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_8\nM₂ : Type u_10\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring S\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R M₂\ninst✝² : Module S M\ninst✝¹ : Module S M₂\ninst✝ : LinearMap.CompatibleSMul M M₂ R S\n⊢ Function.Injective ↑R","decl":"theorem restrictScalars_injective :\n    Function.Injective (restrictScalars R : (M →ₗ[S] M₂) → M →ₗ[R] M₂) := fun _ _ h ↦\n  ext (LinearMap.congr_fun h :)\n\n"}
{"name":"LinearMap.restrictScalars_inj","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_8\nM₂ : Type u_10\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring S\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R M₂\ninst✝² : Module S M\ninst✝¹ : Module S M₂\ninst✝ : LinearMap.CompatibleSMul M M₂ R S\nfₗ gₗ : LinearMap (RingHom.id S) M M₂\n⊢ Iff (Eq (↑R fₗ) (↑R gₗ)) (Eq fₗ gₗ)","decl":"@[simp]\ntheorem restrictScalars_inj (fₗ gₗ : M →ₗ[S] M₂) :\n    fₗ.restrictScalars R = gₗ.restrictScalars R ↔ fₗ = gₗ :=\n  (restrictScalars_injective R).eq_iff\n\n"}
{"name":"LinearMap.toAddMonoidHom_injective","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_8\nM₃ : Type u_11\ninst✝⁵ : Semiring R\ninst✝⁴ : Semiring S\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₃\ninst✝¹ : Module R M\ninst✝ : Module S M₃\nσ : RingHom R S\n⊢ Function.Injective LinearMap.toAddMonoidHom","decl":"theorem toAddMonoidHom_injective :\n    Function.Injective (toAddMonoidHom : (M →ₛₗ[σ] M₃) → M →+ M₃) := fun fₗ gₗ h ↦\n  ext <| (DFunLike.congr_fun h : ∀ x, fₗ.toAddMonoidHom x = gₗ.toAddMonoidHom x)\n\n"}
{"name":"LinearMap.ext_ring","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM₃ : Type u_11\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : AddCommMonoid M₃\ninst✝ : Module S M₃\nσ : RingHom R S\nf g : LinearMap σ R M₃\nh : Eq (f 1) (g 1)\n⊢ Eq f g","decl":"/-- If two `σ`-linear maps from `R` are equal on `1`, then they are equal. -/\n@[ext high]\ntheorem ext_ring {f g : R →ₛₗ[σ] M₃} (h : f 1 = g 1) : f = g :=\n  ext fun x ↦ by rw [← mul_one x, ← smul_eq_mul, f.map_smulₛₗ, g.map_smulₛₗ, h]\n\n"}
{"name":"LinearMap.ext_ring_iff","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM₃ : Type u_11\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : AddCommMonoid M₃\ninst✝ : Module S M₃\nσ : RingHom R S\nf g : LinearMap σ R M₃\n⊢ Iff (Eq f g) (Eq (f 1) (g 1))","decl":"/-- If two `σ`-linear maps from `R` are equal on `1`, then they are equal. -/\n@[ext high]\ntheorem ext_ring {f g : R →ₛₗ[σ] M₃} (h : f 1 = g 1) : f = g :=\n  ext fun x ↦ by rw [← mul_one x, ← smul_eq_mul, f.map_smulₛₗ, g.map_smulₛₗ, h]\n\n"}
{"name":"RingHom.toSemilinearMap_apply","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_1\nS : Type u_5\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingHom R S\na✝ : R\n⊢ Eq (f.toSemilinearMap a✝) ((↑↑f).toFun a✝)","decl":"/-- Interpret a `RingHom` `f` as an `f`-semilinear map. -/\n@[simps]\ndef _root_.RingHom.toSemilinearMap (f : R →+* S) : R →ₛₗ[f] S :=\n  { f with\n    map_smul' := f.map_mul }\n\n"}
{"name":"LinearMap.comp_apply","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R₁ : Type u_2\nR₂ : Type u_3\nR₃ : Type u_4\nM₁ : Type u_9\nM₂ : Type u_10\nM₃ : Type u_11\ninst✝⁶ : Semiring R₁\ninst✝⁵ : Semiring R₂\ninst✝⁴ : Semiring R₃\ninst✝³ : AddCommMonoid M₁\ninst✝² : AddCommMonoid M₂\ninst✝¹ : AddCommMonoid M₃\nmodule_M₁ : Module R₁ M₁\nmodule_M₂ : Module R₂ M₂\nmodule_M₃ : Module R₃ M₃\nσ₁₂ : RingHom R₁ R₂\nσ₂₃ : RingHom R₂ R₃\nσ₁₃ : RingHom R₁ R₃\ninst✝ : RingHomCompTriple σ₁₂ σ₂₃ σ₁₃\nf : LinearMap σ₂₃ M₂ M₃\ng : LinearMap σ₁₂ M₁ M₂\nx : M₁\n⊢ Eq ((f.comp g) x) (f (g x))","decl":"theorem comp_apply (x : M₁) : f.comp g x = f (g x) :=\n  rfl\n\n"}
{"name":"LinearMap.coe_comp","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R₁ : Type u_2\nR₂ : Type u_3\nR₃ : Type u_4\nM₁ : Type u_9\nM₂ : Type u_10\nM₃ : Type u_11\ninst✝⁶ : Semiring R₁\ninst✝⁵ : Semiring R₂\ninst✝⁴ : Semiring R₃\ninst✝³ : AddCommMonoid M₁\ninst✝² : AddCommMonoid M₂\ninst✝¹ : AddCommMonoid M₃\nmodule_M₁ : Module R₁ M₁\nmodule_M₂ : Module R₂ M₂\nmodule_M₃ : Module R₃ M₃\nσ₁₂ : RingHom R₁ R₂\nσ₂₃ : RingHom R₂ R₃\nσ₁₃ : RingHom R₁ R₃\ninst✝ : RingHomCompTriple σ₁₂ σ₂₃ σ₁₃\nf : LinearMap σ₂₃ M₂ M₃\ng : LinearMap σ₁₂ M₁ M₂\n⊢ Eq (⇑(f.comp g)) (Function.comp ⇑f ⇑g)","decl":"@[simp, norm_cast]\ntheorem coe_comp : (f.comp g : M₁ → M₃) = f ∘ g :=\n  rfl\n\n"}
{"name":"LinearMap.comp_id","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R₂ : Type u_3\nR₃ : Type u_4\nM₂ : Type u_10\nM₃ : Type u_11\ninst✝³ : Semiring R₂\ninst✝² : Semiring R₃\ninst✝¹ : AddCommMonoid M₂\ninst✝ : AddCommMonoid M₃\nmodule_M₂ : Module R₂ M₂\nmodule_M₃ : Module R₃ M₃\nσ₂₃ : RingHom R₂ R₃\nf : LinearMap σ₂₃ M₂ M₃\n⊢ Eq (f.comp LinearMap.id) f","decl":"@[simp]\ntheorem comp_id : f.comp id = f :=\n  rfl\n\n"}
{"name":"LinearMap.id_comp","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R₂ : Type u_3\nR₃ : Type u_4\nM₂ : Type u_10\nM₃ : Type u_11\ninst✝³ : Semiring R₂\ninst✝² : Semiring R₃\ninst✝¹ : AddCommMonoid M₂\ninst✝ : AddCommMonoid M₃\nmodule_M₂ : Module R₂ M₂\nmodule_M₃ : Module R₃ M₃\nσ₂₃ : RingHom R₂ R₃\nf : LinearMap σ₂₃ M₂ M₃\n⊢ Eq (LinearMap.id.comp f) f","decl":"@[simp]\ntheorem id_comp : id.comp f = f :=\n  rfl\n\n"}
{"name":"LinearMap.comp_assoc","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R₁ : Type u_2\nR₂ : Type u_3\nR₃ : Type u_4\nM₁ : Type u_9\nM₂ : Type u_10\nM₃ : Type u_11\ninst✝¹² : Semiring R₁\ninst✝¹¹ : Semiring R₂\ninst✝¹⁰ : Semiring R₃\ninst✝⁹ : AddCommMonoid M₁\ninst✝⁸ : AddCommMonoid M₂\ninst✝⁷ : AddCommMonoid M₃\nmodule_M₁ : Module R₁ M₁\nmodule_M₂ : Module R₂ M₂\nmodule_M₃ : Module R₃ M₃\nσ₁₂ : RingHom R₁ R₂\nσ₂₃ : RingHom R₂ R₃\nσ₁₃ : RingHom R₁ R₃\ninst✝⁶ : RingHomCompTriple σ₁₂ σ₂₃ σ₁₃\nR₄ : Type u_14\nM₄ : Type u_15\ninst✝⁵ : Semiring R₄\ninst✝⁴ : AddCommMonoid M₄\ninst✝³ : Module R₄ M₄\nσ₃₄ : RingHom R₃ R₄\nσ₂₄ : RingHom R₂ R₄\nσ₁₄ : RingHom R₁ R₄\ninst✝² : RingHomCompTriple σ₂₃ σ₃₄ σ₂₄\ninst✝¹ : RingHomCompTriple σ₁₃ σ₃₄ σ₁₄\ninst✝ : RingHomCompTriple σ₁₂ σ₂₄ σ₁₄\nf : LinearMap σ₁₂ M₁ M₂\ng : LinearMap σ₂₃ M₂ M₃\nh : LinearMap σ₃₄ M₃ M₄\n⊢ Eq ((h.comp g).comp f) (h.comp (g.comp f))","decl":"theorem comp_assoc\n    {R₄ M₄ : Type*} [Semiring R₄] [AddCommMonoid M₄] [Module R₄ M₄]\n    {σ₃₄ : R₃ →+* R₄} {σ₂₄ : R₂ →+* R₄} {σ₁₄ : R₁ →+* R₄}\n    [RingHomCompTriple σ₂₃ σ₃₄ σ₂₄] [RingHomCompTriple σ₁₃ σ₃₄ σ₁₄] [RingHomCompTriple σ₁₂ σ₂₄ σ₁₄]\n    (f : M₁ →ₛₗ[σ₁₂] M₂) (g : M₂ →ₛₗ[σ₂₃] M₃) (h : M₃ →ₛₗ[σ₃₄] M₄) :\n    ((h.comp g : M₂ →ₛₗ[σ₂₄] M₄).comp f : M₁ →ₛₗ[σ₁₄] M₄) = h.comp (g.comp f : M₁ →ₛₗ[σ₁₃] M₃) :=\n  rfl\n\n"}
{"name":"Function.Surjective.injective_linearMapComp_right","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R₁ : Type u_2\nR₂ : Type u_3\nR₃ : Type u_4\nM₁ : Type u_9\nM₂ : Type u_10\nM₃ : Type u_11\ninst✝⁶ : Semiring R₁\ninst✝⁵ : Semiring R₂\ninst✝⁴ : Semiring R₃\ninst✝³ : AddCommMonoid M₁\ninst✝² : AddCommMonoid M₂\ninst✝¹ : AddCommMonoid M₃\nmodule_M₁ : Module R₁ M₁\nmodule_M₂ : Module R₂ M₂\nmodule_M₃ : Module R₃ M₃\nσ₁₂ : RingHom R₁ R₂\nσ₂₃ : RingHom R₂ R₃\nσ₁₃ : RingHom R₁ R₃\ninst✝ : RingHomCompTriple σ₁₂ σ₂₃ σ₁₃\ng : LinearMap σ₁₂ M₁ M₂\nhg : Function.Surjective ⇑g\n⊢ Function.Injective fun f => f.comp g","decl":"/-- The linear map version of `Function.Surjective.injective_comp_right` -/\nlemma _root_.Function.Surjective.injective_linearMapComp_right (hg : Surjective g) :\n    Injective fun f : M₂ →ₛₗ[σ₂₃] M₃ ↦ f.comp g :=\n  fun _ _ h ↦ ext <| hg.forall.2 (LinearMap.ext_iff.1 h)\n\n"}
{"name":"LinearMap.cancel_right","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R₁ : Type u_2\nR₂ : Type u_3\nR₃ : Type u_4\nM₁ : Type u_9\nM₂ : Type u_10\nM₃ : Type u_11\ninst✝⁶ : Semiring R₁\ninst✝⁵ : Semiring R₂\ninst✝⁴ : Semiring R₃\ninst✝³ : AddCommMonoid M₁\ninst✝² : AddCommMonoid M₂\ninst✝¹ : AddCommMonoid M₃\nmodule_M₁ : Module R₁ M₁\nmodule_M₂ : Module R₂ M₂\nmodule_M₃ : Module R₃ M₃\nσ₁₂ : RingHom R₁ R₂\nσ₂₃ : RingHom R₂ R₃\nσ₁₃ : RingHom R₁ R₃\ninst✝ : RingHomCompTriple σ₁₂ σ₂₃ σ₁₃\nf : LinearMap σ₂₃ M₂ M₃\ng : LinearMap σ₁₂ M₁ M₂\nf' : LinearMap σ₂₃ M₂ M₃\nhg : Function.Surjective ⇑g\n⊢ Iff (Eq (f.comp g) (f'.comp g)) (Eq f f')","decl":"@[simp]\ntheorem cancel_right (hg : Surjective g) : f.comp g = f'.comp g ↔ f = f' :=\n  hg.injective_linearMapComp_right.eq_iff\n\n"}
{"name":"Function.Injective.injective_linearMapComp_left","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R₁ : Type u_2\nR₂ : Type u_3\nR₃ : Type u_4\nM₁ : Type u_9\nM₂ : Type u_10\nM₃ : Type u_11\ninst✝⁶ : Semiring R₁\ninst✝⁵ : Semiring R₂\ninst✝⁴ : Semiring R₃\ninst✝³ : AddCommMonoid M₁\ninst✝² : AddCommMonoid M₂\ninst✝¹ : AddCommMonoid M₃\nmodule_M₁ : Module R₁ M₁\nmodule_M₂ : Module R₂ M₂\nmodule_M₃ : Module R₃ M₃\nσ₁₂ : RingHom R₁ R₂\nσ₂₃ : RingHom R₂ R₃\nσ₁₃ : RingHom R₁ R₃\ninst✝ : RingHomCompTriple σ₁₂ σ₂₃ σ₁₃\nf : LinearMap σ₂₃ M₂ M₃\nhf : Function.Injective ⇑f\n⊢ Function.Injective fun g => f.comp g","decl":"/-- The linear map version of `Function.Injective.comp_left` -/\nlemma _root_.Function.Injective.injective_linearMapComp_left (hf : Injective f) :\n    Injective fun g : M₁ →ₛₗ[σ₁₂] M₂ ↦ f.comp g :=\n  fun g₁ g₂ (h : f.comp g₁ = f.comp g₂) ↦ ext fun x ↦ hf <| by rw [← comp_apply, h, comp_apply]\n\n"}
{"name":"LinearMap.cancel_left","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R₁ : Type u_2\nR₂ : Type u_3\nR₃ : Type u_4\nM₁ : Type u_9\nM₂ : Type u_10\nM₃ : Type u_11\ninst✝⁶ : Semiring R₁\ninst✝⁵ : Semiring R₂\ninst✝⁴ : Semiring R₃\ninst✝³ : AddCommMonoid M₁\ninst✝² : AddCommMonoid M₂\ninst✝¹ : AddCommMonoid M₃\nmodule_M₁ : Module R₁ M₁\nmodule_M₂ : Module R₂ M₂\nmodule_M₃ : Module R₃ M₃\nσ₁₂ : RingHom R₁ R₂\nσ₂₃ : RingHom R₂ R₃\nσ₁₃ : RingHom R₁ R₃\ninst✝ : RingHomCompTriple σ₁₂ σ₂₃ σ₁₃\nf : LinearMap σ₂₃ M₂ M₃\ng g' : LinearMap σ₁₂ M₁ M₂\nhf : Function.Injective ⇑f\n⊢ Iff (Eq (f.comp g) (f.comp g')) (Eq g g')","decl":"@[simp]\ntheorem cancel_left (hf : Injective f) : f.comp g = f.comp g' ↔ g = g' :=\n  hf.injective_linearMapComp_left.eq_iff\n\n"}
{"name":"LinearMap.injective_of_comp_eq_id","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_8\nM₂ : Type u_10\ninst✝⁶ : Semiring R\ninst✝⁵ : Semiring S\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid M₂\ninst✝² : Module R M\ninst✝¹ : Module S M₂\nσ : RingHom R S\nσ' : RingHom S R\ninst✝ : RingHomInvPair σ σ'\nf : LinearMap σ M M₂\ng : LinearMap σ' M₂ M\nh : Eq (g.comp f) LinearMap.id\n⊢ Function.Injective ⇑f","decl":"theorem injective_of_comp_eq_id : Injective f :=\n  .of_comp (f := g) <| by simp_rw [← coe_comp, h, id_coe, bijective_id.1]\n\n"}
{"name":"LinearMap.surjective_of_comp_eq_id","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_8\nM₂ : Type u_10\ninst✝⁶ : Semiring R\ninst✝⁵ : Semiring S\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid M₂\ninst✝² : Module R M\ninst✝¹ : Module S M₂\nσ : RingHom R S\nσ' : RingHom S R\ninst✝ : RingHomInvPair σ σ'\nf : LinearMap σ M M₂\ng : LinearMap σ' M₂ M\nh : Eq (g.comp f) LinearMap.id\n⊢ Function.Surjective ⇑g","decl":"theorem surjective_of_comp_eq_id : Surjective g :=\n  .of_comp (g := f) <| by simp_rw [← coe_comp, h, id_coe, bijective_id.2]\n\n"}
{"name":"LinearMap.map_neg","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_8\nM₂ : Type u_10\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : AddCommGroup M\ninst✝ : AddCommGroup M₂\nmodule_M : Module R M\nmodule_M₂ : Module S M₂\nσ : RingHom R S\nf : LinearMap σ M M₂\nx : M\n⊢ Eq (f (Neg.neg x)) (Neg.neg (f x))","decl":"protected theorem map_neg (x : M) : f (-x) = -f x :=\n  map_neg f x\n\n"}
{"name":"LinearMap.map_sub","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_8\nM₂ : Type u_10\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : AddCommGroup M\ninst✝ : AddCommGroup M₂\nmodule_M : Module R M\nmodule_M₂ : Module S M₂\nσ : RingHom R S\nf : LinearMap σ M M₂\nx y : M\n⊢ Eq (f (HSub.hSub x y)) (HSub.hSub (f x) (f y))","decl":"protected theorem map_sub (x y : M) : f (x - y) = f x - f y :=\n  map_sub f x y\n\n"}
{"name":"LinearMap.CompatibleSMul.intModule","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"M : Type u_8\nM₂ : Type u_10\ninst✝⁴ : AddCommGroup M\ninst✝³ : AddCommGroup M₂\nS : Type u_14\ninst✝² : Semiring S\ninst✝¹ : Module S M\ninst✝ : Module S M₂\n⊢ LinearMap.CompatibleSMul M M₂ Int S","decl":"instance CompatibleSMul.intModule {S : Type*} [Semiring S] [Module S M] [Module S M₂] :\n    CompatibleSMul M M₂ ℤ S :=\n  ⟨fun fₗ c x ↦ by\n    induction c using Int.induction_on with\n    | hz => simp\n    | hp n ih => simp [add_smul, ih]\n    | hn n ih => simp [sub_smul, ih]⟩\n\n"}
{"name":"LinearMap.CompatibleSMul.units","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"M : Type u_8\nM₂ : Type u_10\ninst✝⁸ : AddCommGroup M\ninst✝⁷ : AddCommGroup M₂\nR : Type u_14\nS : Type u_15\ninst✝⁶ : Monoid R\ninst✝⁵ : MulAction R M\ninst✝⁴ : MulAction R M₂\ninst✝³ : Semiring S\ninst✝² : Module S M\ninst✝¹ : Module S M₂\ninst✝ : LinearMap.CompatibleSMul M M₂ R S\n⊢ LinearMap.CompatibleSMul M M₂ (Units R) S","decl":"instance CompatibleSMul.units {R S : Type*} [Monoid R] [MulAction R M] [MulAction R M₂]\n    [Semiring S] [Module S M] [Module S M₂] [CompatibleSMul M M₂ R S] : CompatibleSMul M M₂ Rˣ S :=\n  ⟨fun fₗ c x ↦ (CompatibleSMul.map_smul fₗ (c : R) x :)⟩\n\n"}
{"name":"Module.compHom.toLinearMap_apply","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_14\nS : Type u_15\ninst✝¹ : Semiring R\ninst✝ : Semiring S\ng : RingHom R S\na : R\n⊢ Eq ((Module.compHom.toLinearMap g) a) (g a)","decl":"/-- `g : R →+* S` is `R`-linear when the module structure on `S` is `Module.compHom S g` . -/\n@[simps]\ndef compHom.toLinearMap {R S : Type*} [Semiring R] [Semiring S] (g : R →+* S) :\n    letI := compHom S g; R →ₗ[R] S :=\n  letI := compHom S g\n  { toFun := (g : R → S)\n    map_add' := g.map_add\n    map_smul' := g.map_mul }\n\n"}
{"name":"DistribMulActionHom.instSemilinearMapClass","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_8\nM₂ : Type u_10\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : Semiring R\ninst✝² : Module R M\ninst✝¹ : Semiring S\ninst✝ : Module S M₂\nσ : RingHom R S\n⊢ SemilinearMapClass (DistribMulActionHom (↑σ) M M₂) σ M M₂","decl":"instance : SemilinearMapClass (M →ₑ+[σ.toMonoidHom] M₂) σ M M₂ where\n\n"}
{"name":"DistribMulActionHom.instLinearMapClassId","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_1\nM : Type u_8\nM₃ : Type u_11\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid M₃\ninst✝² : Semiring R\ninst✝¹ : Module R M\ninst✝ : Module R M₃\n⊢ LinearMapClass (DistribMulActionHom (MonoidHom.id R) M M₃) R M M₃","decl":"/-- A `DistribMulActionHom` between two modules is a linear map. -/\ninstance : LinearMapClass (M →+[R] M₃) R M M₃ where\n\n-- Porting note: because coercions get unfolded, there is no need for this rewrite\n\n-- Porting note: removed @[norm_cast] attribute due to error:\n-- norm_cast: badly shaped lemma, rhs can't start with coe\n"}
{"name":"DistribMulActionHom.coe_toLinearMap","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_8\nM₂ : Type u_10\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : Semiring R\ninst✝² : Module R M\ninst✝¹ : Semiring S\ninst✝ : Module S M₂\nσ : RingHom R S\nf : DistribMulActionHom (↑σ) M M₂\n⊢ Eq ⇑↑f ⇑f","decl":"@[simp]\ntheorem coe_toLinearMap (f : M →ₑ+[σ.toMonoidHom] M₂) : ((f : M →ₛₗ[σ] M₂) : M → M₂) = f :=\n  rfl\n\n"}
{"name":"DistribMulActionHom.toLinearMap_injective","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_8\nM₂ : Type u_10\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : Semiring R\ninst✝² : Module R M\ninst✝¹ : Semiring S\ninst✝ : Module S M₂\nσ : RingHom R S\nf g : DistribMulActionHom (↑σ) M M₂\nh : Eq ↑f ↑g\n⊢ Eq f g","decl":"theorem toLinearMap_injective {f g : M →ₑ+[σ.toMonoidHom] M₂}\n    (h : (f : M →ₛₗ[σ] M₂) = (g : M →ₛₗ[σ] M₂)) :\n    f = g := by\n  ext m\n  exact LinearMap.congr_fun h m\n\n"}
{"name":"IsLinearMap.mk'_apply","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_1\nM : Type u_8\nM₂ : Type u_10\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\nf : M → M₂\nlin : IsLinearMap R f\nx : M\n⊢ Eq ((IsLinearMap.mk' f lin) x) (f x)","decl":"@[simp]\ntheorem mk'_apply {f : M → M₂} (lin : IsLinearMap R f) (x : M) : mk' f lin x = f x :=\n  rfl\n\n"}
{"name":"IsLinearMap.isLinearMap_smul","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_14\nM : Type u_15\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nc : R\n⊢ IsLinearMap R fun z => HSMul.hSMul c z","decl":"theorem isLinearMap_smul {R M : Type*} [CommSemiring R] [AddCommMonoid M] [Module R M] (c : R) :\n    IsLinearMap R fun z : M ↦ c • z := by\n  refine IsLinearMap.mk (smul_add c) ?_\n  intro _ _\n  simp only [smul_smul, mul_comm]\n\n"}
{"name":"IsLinearMap.isLinearMap_smul'","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_14\nM : Type u_15\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\na : M\n⊢ IsLinearMap R fun c => HSMul.hSMul c a","decl":"theorem isLinearMap_smul' {R M : Type*} [Semiring R] [AddCommMonoid M] [Module R M] (a : M) :\n    IsLinearMap R fun c : R ↦ c • a :=\n  IsLinearMap.mk (fun x y ↦ add_smul x y a) fun x y ↦ mul_smul x y a\n\n"}
{"name":"IsLinearMap.map_zero","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_1\nM : Type u_8\nM₂ : Type u_10\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\nf : M → M₂\nlin : IsLinearMap R f\n⊢ Eq (f 0) 0","decl":"theorem map_zero {f : M → M₂} (lin : IsLinearMap R f) : f (0 : M) = (0 : M₂) :=\n  (lin.mk' f).map_zero\n\n"}
{"name":"IsLinearMap.isLinearMap_neg","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_1\nM : Type u_8\ninst✝² : Semiring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ IsLinearMap R fun z => Neg.neg z","decl":"theorem isLinearMap_neg : IsLinearMap R fun z : M ↦ -z :=\n  IsLinearMap.mk neg_add fun x y ↦ (smul_neg x y).symm\n\n"}
{"name":"IsLinearMap.map_neg","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_1\nM : Type u_8\nM₂ : Type u_10\ninst✝⁴ : Semiring R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\nf : M → M₂\nlin : IsLinearMap R f\nx : M\n⊢ Eq (f (Neg.neg x)) (Neg.neg (f x))","decl":"theorem map_neg {f : M → M₂} (lin : IsLinearMap R f) (x : M) : f (-x) = -f x :=\n  (lin.mk' f).map_neg x\n\n"}
{"name":"IsLinearMap.map_sub","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_1\nM : Type u_8\nM₂ : Type u_10\ninst✝⁴ : Semiring R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\nf : M → M₂\nlin : IsLinearMap R f\nx y : M\n⊢ Eq (f (HSub.hSub x y)) (HSub.hSub (f x) (f y))","decl":"theorem map_sub {f : M → M₂} (lin : IsLinearMap R f) (x y : M) : f (x - y) = f x - f y :=\n  (lin.mk' f).map_sub x y\n\n"}
{"name":"AddMonoidHom.toNatLinearMap_injective","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"M : Type u_8\nM₂ : Type u_10\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid M₂\n⊢ Function.Injective AddMonoidHom.toNatLinearMap","decl":"theorem AddMonoidHom.toNatLinearMap_injective [AddCommMonoid M] [AddCommMonoid M₂] :\n    Function.Injective (@AddMonoidHom.toNatLinearMap M M₂ _ _) := by\n  intro f g h\n  ext x\n  exact LinearMap.congr_fun h x\n\n"}
{"name":"AddMonoidHom.toIntLinearMap_injective","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"M : Type u_8\nM₂ : Type u_10\ninst✝¹ : AddCommGroup M\ninst✝ : AddCommGroup M₂\n⊢ Function.Injective AddMonoidHom.toIntLinearMap","decl":"theorem AddMonoidHom.toIntLinearMap_injective [AddCommGroup M] [AddCommGroup M₂] :\n    Function.Injective (@AddMonoidHom.toIntLinearMap M M₂ _ _) := by\n  intro f g h\n  ext x\n  exact LinearMap.congr_fun h x\n\n"}
{"name":"AddMonoidHom.coe_toIntLinearMap","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"M : Type u_8\nM₂ : Type u_10\ninst✝¹ : AddCommGroup M\ninst✝ : AddCommGroup M₂\nf : AddMonoidHom M M₂\n⊢ Eq ⇑f.toIntLinearMap ⇑f","decl":"@[simp]\ntheorem AddMonoidHom.coe_toIntLinearMap [AddCommGroup M] [AddCommGroup M₂] (f : M →+ M₂) :\n    ⇑f.toIntLinearMap = f :=\n  rfl\n\n"}
{"name":"LinearMap.smul_apply","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_1\nR₂ : Type u_3\nS : Type u_5\nM : Type u_8\nM₂ : Type u_10\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\ninst✝² : Monoid S\ninst✝¹ : DistribMulAction S M₂\ninst✝ : SMulCommClass R₂ S M₂\na : S\nf : LinearMap σ₁₂ M M₂\nx : M\n⊢ Eq ((HSMul.hSMul a f) x) (HSMul.hSMul a (f x))","decl":"@[simp]\ntheorem smul_apply (a : S) (f : M →ₛₗ[σ₁₂] M₂) (x : M) : (a • f) x = a • f x :=\n  rfl\n\n"}
{"name":"LinearMap.coe_smul","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_1\nR₂ : Type u_3\nS : Type u_5\nM : Type u_8\nM₂ : Type u_10\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\ninst✝² : Monoid S\ninst✝¹ : DistribMulAction S M₂\ninst✝ : SMulCommClass R₂ S M₂\na : S\nf : LinearMap σ₁₂ M M₂\n⊢ Eq (⇑(HSMul.hSMul a f)) (HSMul.hSMul a ⇑f)","decl":"theorem coe_smul (a : S) (f : M →ₛₗ[σ₁₂] M₂) : (a • f : M →ₛₗ[σ₁₂] M₂) = a • (f : M → M₂) :=\n  rfl\n\n"}
{"name":"LinearMap.instSMulCommClass","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_1\nR₂ : Type u_3\nS : Type u_5\nT : Type u_7\nM : Type u_8\nM₂ : Type u_10\ninst✝¹⁰ : Semiring R\ninst✝⁹ : Semiring R₂\ninst✝⁸ : AddCommMonoid M\ninst✝⁷ : AddCommMonoid M₂\ninst✝⁶ : Module R M\ninst✝⁵ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\ninst✝⁴ : Monoid S\ninst✝³ : DistribMulAction S M₂\ninst✝² : Monoid T\ninst✝¹ : DistribMulAction T M₂\ninst✝ : SMulCommClass S T M₂\n⊢ SMulCommClass S T (LinearMap σ₁₂ M M₂)","decl":"instance [SMulCommClass S T M₂] : SMulCommClass S T (M →ₛₗ[σ₁₂] M₂) :=\n  ⟨fun _ _ _ ↦ ext fun _ ↦ smul_comm _ _ _⟩\n\n-- example application of this instance: if S -> T -> R are homomorphisms of commutative rings and\n-- M and M₂ are R-modules then the S-module and T-module structures on Hom_R(M,M₂) are compatible.\n"}
{"name":"LinearMap.instIsScalarTower","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_1\nR₂ : Type u_3\nS : Type u_5\nT : Type u_7\nM : Type u_8\nM₂ : Type u_10\ninst✝¹¹ : Semiring R\ninst✝¹⁰ : Semiring R₂\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : AddCommMonoid M₂\ninst✝⁷ : Module R M\ninst✝⁶ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\ninst✝⁵ : Monoid S\ninst✝⁴ : DistribMulAction S M₂\ninst✝³ : Monoid T\ninst✝² : DistribMulAction T M₂\ninst✝¹ : SMul S T\ninst✝ : IsScalarTower S T M₂\n⊢ IsScalarTower S T (LinearMap σ₁₂ M M₂)","decl":"instance [SMul S T] [IsScalarTower S T M₂] : IsScalarTower S T (M →ₛₗ[σ₁₂] M₂) where\n  smul_assoc _ _ _ := ext fun _ ↦ smul_assoc _ _ _\n\n"}
{"name":"LinearMap.instIsCentralScalarOfSMulCommClassMulOpposite","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_1\nR₂ : Type u_3\nS : Type u_5\nM : Type u_8\nM₂ : Type u_10\ninst✝¹⁰ : Semiring R\ninst✝⁹ : Semiring R₂\ninst✝⁸ : AddCommMonoid M\ninst✝⁷ : AddCommMonoid M₂\ninst✝⁶ : Module R M\ninst✝⁵ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\ninst✝⁴ : Monoid S\ninst✝³ : DistribMulAction S M₂\ninst✝² : DistribMulAction (MulOpposite S) M₂\ninst✝¹ : SMulCommClass R₂ (MulOpposite S) M₂\ninst✝ : IsCentralScalar S M₂\n⊢ IsCentralScalar S (LinearMap σ₁₂ M M₂)","decl":"instance [DistribMulAction Sᵐᵒᵖ M₂] [SMulCommClass R₂ Sᵐᵒᵖ M₂] [IsCentralScalar S M₂] :\n    IsCentralScalar S (M →ₛₗ[σ₁₂] M₂) where\n  op_smul_eq_smul _ _ := ext fun _ ↦ op_smul_eq_smul _ _\n\n"}
{"name":"LinearMap.zero_apply","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R₁ : Type u_2\nR₂ : Type u_3\nM : Type u_8\nM₂ : Type u_10\ninst✝⁵ : Semiring R₁\ninst✝⁴ : Semiring R₂\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R₁ M\ninst✝ : Module R₂ M₂\nσ₁₂ : RingHom R₁ R₂\nx : M\n⊢ Eq (0 x) 0","decl":"@[simp]\ntheorem zero_apply (x : M) : (0 : M →ₛₗ[σ₁₂] M₂) x = 0 :=\n  rfl\n\n"}
{"name":"LinearMap.comp_zero","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R₁ : Type u_2\nR₂ : Type u_3\nR₃ : Type u_4\nM : Type u_8\nM₂ : Type u_10\nM₃ : Type u_11\ninst✝⁹ : Semiring R₁\ninst✝⁸ : Semiring R₂\ninst✝⁷ : Semiring R₃\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : AddCommMonoid M₃\ninst✝³ : Module R₁ M\ninst✝² : Module R₂ M₂\ninst✝¹ : Module R₃ M₃\nσ₁₂ : RingHom R₁ R₂\nσ₂₃ : RingHom R₂ R₃\nσ₁₃ : RingHom R₁ R₃\ninst✝ : RingHomCompTriple σ₁₂ σ₂₃ σ₁₃\ng : LinearMap σ₂₃ M₂ M₃\n⊢ Eq (g.comp 0) 0","decl":"@[simp]\ntheorem comp_zero (g : M₂ →ₛₗ[σ₂₃] M₃) : (g.comp (0 : M →ₛₗ[σ₁₂] M₂) : M →ₛₗ[σ₁₃] M₃) = 0 :=\n  ext fun c ↦ by rw [comp_apply, zero_apply, zero_apply, g.map_zero]\n\n"}
{"name":"LinearMap.zero_comp","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R₁ : Type u_2\nR₂ : Type u_3\nR₃ : Type u_4\nM : Type u_8\nM₂ : Type u_10\nM₃ : Type u_11\ninst✝⁹ : Semiring R₁\ninst✝⁸ : Semiring R₂\ninst✝⁷ : Semiring R₃\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : AddCommMonoid M₃\ninst✝³ : Module R₁ M\ninst✝² : Module R₂ M₂\ninst✝¹ : Module R₃ M₃\nσ₁₂ : RingHom R₁ R₂\nσ₂₃ : RingHom R₂ R₃\nσ₁₃ : RingHom R₁ R₃\ninst✝ : RingHomCompTriple σ₁₂ σ₂₃ σ₁₃\nf : LinearMap σ₁₂ M M₂\n⊢ Eq (LinearMap.comp 0 f) 0","decl":"@[simp]\ntheorem zero_comp (f : M →ₛₗ[σ₁₂] M₂) : ((0 : M₂ →ₛₗ[σ₂₃] M₃).comp f : M →ₛₗ[σ₁₃] M₃) = 0 :=\n  rfl\n\n"}
{"name":"LinearMap.default_def","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R₁ : Type u_2\nR₂ : Type u_3\nM : Type u_8\nM₂ : Type u_10\ninst✝⁵ : Semiring R₁\ninst✝⁴ : Semiring R₂\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R₁ M\ninst✝ : Module R₂ M₂\nσ₁₂ : RingHom R₁ R₂\n⊢ Eq Inhabited.default 0","decl":"@[simp]\ntheorem default_def : (default : M →ₛₗ[σ₁₂] M₂) = 0 :=\n  rfl\n\n"}
{"name":"LinearMap.add_apply","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R₁ : Type u_2\nR₂ : Type u_3\nM : Type u_8\nM₂ : Type u_10\ninst✝⁵ : Semiring R₁\ninst✝⁴ : Semiring R₂\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R₁ M\ninst✝ : Module R₂ M₂\nσ₁₂ : RingHom R₁ R₂\nf g : LinearMap σ₁₂ M M₂\nx : M\n⊢ Eq ((HAdd.hAdd f g) x) (HAdd.hAdd (f x) (g x))","decl":"@[simp]\ntheorem add_apply (f g : M →ₛₗ[σ₁₂] M₂) (x : M) : (f + g) x = f x + g x :=\n  rfl\n\n"}
{"name":"LinearMap.add_comp","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R₁ : Type u_2\nR₂ : Type u_3\nR₃ : Type u_4\nM : Type u_8\nM₂ : Type u_10\nM₃ : Type u_11\ninst✝⁹ : Semiring R₁\ninst✝⁸ : Semiring R₂\ninst✝⁷ : Semiring R₃\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : AddCommMonoid M₃\ninst✝³ : Module R₁ M\ninst✝² : Module R₂ M₂\ninst✝¹ : Module R₃ M₃\nσ₁₂ : RingHom R₁ R₂\nσ₂₃ : RingHom R₂ R₃\nσ₁₃ : RingHom R₁ R₃\ninst✝ : RingHomCompTriple σ₁₂ σ₂₃ σ₁₃\nf : LinearMap σ₁₂ M M₂\ng h : LinearMap σ₂₃ M₂ M₃\n⊢ Eq ((HAdd.hAdd h g).comp f) (HAdd.hAdd (h.comp f) (g.comp f))","decl":"theorem add_comp (f : M →ₛₗ[σ₁₂] M₂) (g h : M₂ →ₛₗ[σ₂₃] M₃) :\n    ((h + g).comp f : M →ₛₗ[σ₁₃] M₃) = h.comp f + g.comp f :=\n  rfl\n\n"}
{"name":"LinearMap.comp_add","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R₁ : Type u_2\nR₂ : Type u_3\nR₃ : Type u_4\nM : Type u_8\nM₂ : Type u_10\nM₃ : Type u_11\ninst✝⁹ : Semiring R₁\ninst✝⁸ : Semiring R₂\ninst✝⁷ : Semiring R₃\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : AddCommMonoid M₃\ninst✝³ : Module R₁ M\ninst✝² : Module R₂ M₂\ninst✝¹ : Module R₃ M₃\nσ₁₂ : RingHom R₁ R₂\nσ₂₃ : RingHom R₂ R₃\nσ₁₃ : RingHom R₁ R₃\ninst✝ : RingHomCompTriple σ₁₂ σ₂₃ σ₁₃\nf g : LinearMap σ₁₂ M M₂\nh : LinearMap σ₂₃ M₂ M₃\n⊢ Eq (h.comp (HAdd.hAdd f g)) (HAdd.hAdd (h.comp f) (h.comp g))","decl":"theorem comp_add (f g : M →ₛₗ[σ₁₂] M₂) (h : M₂ →ₛₗ[σ₂₃] M₃) :\n    (h.comp (f + g) : M →ₛₗ[σ₁₃] M₃) = h.comp f + h.comp g :=\n  ext fun _ ↦ h.map_add _ _\n\n"}
{"name":"LinearMap.neg_apply","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R₁ : Type u_2\nR₂ : Type u_3\nM : Type u_8\nN₂ : Type u_12\ninst✝⁵ : Semiring R₁\ninst✝⁴ : Semiring R₂\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommGroup N₂\ninst✝¹ : Module R₁ M\ninst✝ : Module R₂ N₂\nσ₁₂ : RingHom R₁ R₂\nf : LinearMap σ₁₂ M N₂\nx : M\n⊢ Eq ((Neg.neg f) x) (Neg.neg (f x))","decl":"@[simp]\ntheorem neg_apply (f : M →ₛₗ[σ₁₂] N₂) (x : M) : (-f) x = -f x :=\n  rfl\n\n"}
{"name":"LinearMap.neg_comp","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R₁ : Type u_2\nR₂ : Type u_3\nR₃ : Type u_4\nM : Type u_8\nM₂ : Type u_10\nN₃ : Type u_13\ninst✝⁹ : Semiring R₁\ninst✝⁸ : Semiring R₂\ninst✝⁷ : Semiring R₃\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : AddCommGroup N₃\ninst✝³ : Module R₁ M\ninst✝² : Module R₂ M₂\ninst✝¹ : Module R₃ N₃\nσ₁₂ : RingHom R₁ R₂\nσ₂₃ : RingHom R₂ R₃\nσ₁₃ : RingHom R₁ R₃\ninst✝ : RingHomCompTriple σ₁₂ σ₂₃ σ₁₃\nf : LinearMap σ₁₂ M M₂\ng : LinearMap σ₂₃ M₂ N₃\n⊢ Eq ((Neg.neg g).comp f) (Neg.neg (g.comp f))","decl":"@[simp]\ntheorem neg_comp (f : M →ₛₗ[σ₁₂] M₂) (g : M₂ →ₛₗ[σ₂₃] N₃) : (-g).comp f = -g.comp f :=\n  rfl\n\n"}
{"name":"LinearMap.comp_neg","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R₁ : Type u_2\nR₂ : Type u_3\nR₃ : Type u_4\nM : Type u_8\nN₂ : Type u_12\nN₃ : Type u_13\ninst✝⁹ : Semiring R₁\ninst✝⁸ : Semiring R₂\ninst✝⁷ : Semiring R₃\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommGroup N₂\ninst✝⁴ : AddCommGroup N₃\ninst✝³ : Module R₁ M\ninst✝² : Module R₂ N₂\ninst✝¹ : Module R₃ N₃\nσ₁₂ : RingHom R₁ R₂\nσ₂₃ : RingHom R₂ R₃\nσ₁₃ : RingHom R₁ R₃\ninst✝ : RingHomCompTriple σ₁₂ σ₂₃ σ₁₃\nf : LinearMap σ₁₂ M N₂\ng : LinearMap σ₂₃ N₂ N₃\n⊢ Eq (g.comp (Neg.neg f)) (Neg.neg (g.comp f))","decl":"@[simp]\ntheorem comp_neg (f : M →ₛₗ[σ₁₂] N₂) (g : N₂ →ₛₗ[σ₂₃] N₃) : g.comp (-f) = -g.comp f :=\n  ext fun _ ↦ g.map_neg _\n\n"}
{"name":"LinearMap.sub_apply","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R₁ : Type u_2\nR₂ : Type u_3\nM : Type u_8\nN₂ : Type u_12\ninst✝⁵ : Semiring R₁\ninst✝⁴ : Semiring R₂\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommGroup N₂\ninst✝¹ : Module R₁ M\ninst✝ : Module R₂ N₂\nσ₁₂ : RingHom R₁ R₂\nf g : LinearMap σ₁₂ M N₂\nx : M\n⊢ Eq ((HSub.hSub f g) x) (HSub.hSub (f x) (g x))","decl":"@[simp]\ntheorem sub_apply (f g : M →ₛₗ[σ₁₂] N₂) (x : M) : (f - g) x = f x - g x :=\n  rfl\n\n"}
{"name":"LinearMap.sub_comp","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R₁ : Type u_2\nR₂ : Type u_3\nR₃ : Type u_4\nM : Type u_8\nM₂ : Type u_10\nN₃ : Type u_13\ninst✝⁹ : Semiring R₁\ninst✝⁸ : Semiring R₂\ninst✝⁷ : Semiring R₃\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : AddCommGroup N₃\ninst✝³ : Module R₁ M\ninst✝² : Module R₂ M₂\ninst✝¹ : Module R₃ N₃\nσ₁₂ : RingHom R₁ R₂\nσ₂₃ : RingHom R₂ R₃\nσ₁₃ : RingHom R₁ R₃\ninst✝ : RingHomCompTriple σ₁₂ σ₂₃ σ₁₃\nf : LinearMap σ₁₂ M M₂\ng h : LinearMap σ₂₃ M₂ N₃\n⊢ Eq ((HSub.hSub g h).comp f) (HSub.hSub (g.comp f) (h.comp f))","decl":"theorem sub_comp (f : M →ₛₗ[σ₁₂] M₂) (g h : M₂ →ₛₗ[σ₂₃] N₃) :\n    (g - h).comp f = g.comp f - h.comp f :=\n  rfl\n\n"}
{"name":"LinearMap.comp_sub","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R₁ : Type u_2\nR₂ : Type u_3\nR₃ : Type u_4\nM : Type u_8\nN₂ : Type u_12\nN₃ : Type u_13\ninst✝⁹ : Semiring R₁\ninst✝⁸ : Semiring R₂\ninst✝⁷ : Semiring R₃\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommGroup N₂\ninst✝⁴ : AddCommGroup N₃\ninst✝³ : Module R₁ M\ninst✝² : Module R₂ N₂\ninst✝¹ : Module R₃ N₃\nσ₁₂ : RingHom R₁ R₂\nσ₂₃ : RingHom R₂ R₃\nσ₁₃ : RingHom R₁ R₃\ninst✝ : RingHomCompTriple σ₁₂ σ₂₃ σ₁₃\nf g : LinearMap σ₁₂ M N₂\nh : LinearMap σ₂₃ N₂ N₃\n⊢ Eq (h.comp (HSub.hSub g f)) (HSub.hSub (h.comp g) (h.comp f))","decl":"theorem comp_sub (f g : M →ₛₗ[σ₁₂] N₂) (h : N₂ →ₛₗ[σ₂₃] N₃) :\n    h.comp (g - f) = h.comp g - h.comp f :=\n  ext fun _ ↦ h.map_sub _ _\n\n"}
{"name":"LinearMap.evalAddMonoidHom_apply","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R₁ : Type u_2\nR₂ : Type u_3\nM : Type u_8\nM₂ : Type u_10\ninst✝⁵ : Semiring R₁\ninst✝⁴ : Semiring R₂\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R₁ M\ninst✝ : Module R₂ M₂\nσ₁₂ : RingHom R₁ R₂\na : M\nf : LinearMap σ₁₂ M M₂\n⊢ Eq ((LinearMap.evalAddMonoidHom a) f) (f a)","decl":"/-- Evaluation of a `σ₁₂`-linear map at a fixed `a`, as an `AddMonoidHom`. -/\n@[simps]\ndef evalAddMonoidHom (a : M) : (M →ₛₗ[σ₁₂] M₂) →+ M₂ where\n  toFun f := f a\n  map_add' f g := LinearMap.add_apply f g a\n  map_zero' := rfl\n\n"}
{"name":"LinearMap.toAddMonoidHom'_apply","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R₁ : Type u_2\nR₂ : Type u_3\nM : Type u_8\nM₂ : Type u_10\ninst✝⁵ : Semiring R₁\ninst✝⁴ : Semiring R₂\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R₁ M\ninst✝ : Module R₂ M₂\nσ₁₂ : RingHom R₁ R₂\nf : LinearMap σ₁₂ M M₂\n⊢ Eq (LinearMap.toAddMonoidHom' f) f.toAddMonoidHom","decl":"/-- `LinearMap.toAddMonoidHom` promoted to an `AddMonoidHom`. -/\n@[simps]\ndef toAddMonoidHom' : (M →ₛₗ[σ₁₂] M₂) →+ M →+ M₂ where\n  toFun := toAddMonoidHom\n  map_zero' := by ext; rfl\n  map_add' := by intros; ext; rfl\n\n"}
{"name":"LinearMap.identityMapOfZeroModuleIsZero","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R₁ : Type u_2\nM : Type u_8\ninst✝³ : Semiring R₁\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R₁ M\ninst✝ : Subsingleton M\n⊢ Eq LinearMap.id 0","decl":"/-- If `M` is the zero module, then the identity map of `M` is the zero map. -/\n@[simp]\ntheorem identityMapOfZeroModuleIsZero [Subsingleton M] : id (R := R₁) (M := M) = 0 :=\n  Subsingleton.eq_zero id\n\n"}
{"name":"LinearMap.smul_comp","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_1\nR₂ : Type u_3\nR₃ : Type u_4\nS₃ : Type u_6\nM : Type u_8\nM₂ : Type u_10\nM₃ : Type u_11\ninst✝¹² : Semiring R\ninst✝¹¹ : Semiring R₂\ninst✝¹⁰ : Semiring R₃\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : AddCommMonoid M₂\ninst✝⁷ : AddCommMonoid M₃\ninst✝⁶ : Module R M\ninst✝⁵ : Module R₂ M₂\ninst✝⁴ : Module R₃ M₃\nσ₁₂ : RingHom R R₂\nσ₂₃ : RingHom R₂ R₃\nσ₁₃ : RingHom R R₃\ninst✝³ : RingHomCompTriple σ₁₂ σ₂₃ σ₁₃\ninst✝² : Monoid S₃\ninst✝¹ : DistribMulAction S₃ M₃\ninst✝ : SMulCommClass R₃ S₃ M₃\na : S₃\ng : LinearMap σ₂₃ M₂ M₃\nf : LinearMap σ₁₂ M M₂\n⊢ Eq ((HSMul.hSMul a g).comp f) (HSMul.hSMul a (g.comp f))","decl":"theorem smul_comp (a : S₃) (g : M₂ →ₛₗ[σ₂₃] M₃) (f : M →ₛₗ[σ₁₂] M₂) :\n    (a • g).comp f = a • g.comp f :=\n  rfl\n\n-- TODO: generalize this to semilinear maps\n"}
{"name":"LinearMap.comp_smul","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_8\nM₂ : Type u_10\nM₃ : Type u_11\ninst✝¹² : Semiring R\ninst✝¹¹ : AddCommMonoid M\ninst✝¹⁰ : AddCommMonoid M₂\ninst✝⁹ : AddCommMonoid M₃\ninst✝⁸ : Module R M\ninst✝⁷ : Monoid S\ninst✝⁶ : DistribMulAction S M₂\ninst✝⁵ : Module R M₂\ninst✝⁴ : Module R M₃\ninst✝³ : SMulCommClass R S M₂\ninst✝² : DistribMulAction S M₃\ninst✝¹ : SMulCommClass R S M₃\ninst✝ : LinearMap.CompatibleSMul M₃ M₂ S R\ng : LinearMap (RingHom.id R) M₃ M₂\na : S\nf : LinearMap (RingHom.id R) M M₃\n⊢ Eq (g.comp (HSMul.hSMul a f)) (HSMul.hSMul a (g.comp f))","decl":"theorem comp_smul [Module R M₂] [Module R M₃] [SMulCommClass R S M₂] [DistribMulAction S M₃]\n    [SMulCommClass R S M₃] [CompatibleSMul M₃ M₂ S R] (g : M₃ →ₗ[R] M₂) (a : S) (f : M →ₗ[R] M₃) :\n    g.comp (a • f) = a • g.comp f :=\n  ext fun _ ↦ g.map_smul_of_tower _ _\n\n"}
{"name":"LinearMap.restrictScalars_zero","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_14\nS : Type u_15\nM : Type u_16\nN : Type u_17\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring S\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid N\ninst✝⁴ : Module R M\ninst✝³ : Module R N\ninst✝² : Module S M\ninst✝¹ : Module S N\ninst✝ : LinearMap.CompatibleSMul M N R S\n⊢ Eq (↑R 0) 0","decl":"variable (R S M N) in\n@[simp]\nlemma restrictScalars_zero : (0 : M →ₗ[S] N).restrictScalars R = 0 :=\n  rfl\n\n"}
{"name":"LinearMap.restrictScalars_add","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_14\nS : Type u_15\nM : Type u_16\nN : Type u_17\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring S\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid N\ninst✝⁴ : Module R M\ninst✝³ : Module R N\ninst✝² : Module S M\ninst✝¹ : Module S N\ninst✝ : LinearMap.CompatibleSMul M N R S\nf g : LinearMap (RingHom.id S) M N\n⊢ Eq (↑R (HAdd.hAdd f g)) (HAdd.hAdd (↑R f) (↑R g))","decl":"@[simp]\ntheorem restrictScalars_add (f g : M →ₗ[S] N) :\n    (f + g).restrictScalars R = f.restrictScalars R + g.restrictScalars R :=\n  rfl\n\n"}
{"name":"LinearMap.restrictScalars_neg","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_14\nS : Type u_15\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring S\nM : Type u_19\nN : Type u_20\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : AddCommGroup N\ninst✝⁴ : Module R M\ninst✝³ : Module R N\ninst✝² : Module S M\ninst✝¹ : Module S N\ninst✝ : LinearMap.CompatibleSMul M N R S\nf : LinearMap (RingHom.id S) M N\n⊢ Eq (↑R (Neg.neg f)) (Neg.neg (↑R f))","decl":"@[simp]\ntheorem restrictScalars_neg {M N : Type*} [AddCommGroup M] [AddCommGroup N]\n    [Module R M] [Module R N] [Module S M] [Module S N] [CompatibleSMul M N R S]\n    (f : M →ₗ[S] N) : (-f).restrictScalars R = -f.restrictScalars R :=\n  rfl\n\n"}
{"name":"LinearMap.restrictScalars_smul","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_14\nS : Type u_15\nM : Type u_16\nN : Type u_17\ninst✝¹² : Semiring R\ninst✝¹¹ : Semiring S\ninst✝¹⁰ : AddCommMonoid M\ninst✝⁹ : AddCommMonoid N\ninst✝⁸ : Module R M\ninst✝⁷ : Module R N\ninst✝⁶ : Module S M\ninst✝⁵ : Module S N\ninst✝⁴ : LinearMap.CompatibleSMul M N R S\nR₁ : Type u_19\ninst✝³ : Semiring R₁\ninst✝² : Module R₁ N\ninst✝¹ : SMulCommClass S R₁ N\ninst✝ : SMulCommClass R R₁ N\nc : R₁\nf : LinearMap (RingHom.id S) M N\n⊢ Eq (↑R (HSMul.hSMul c f)) (HSMul.hSMul c (↑R f))","decl":"@[simp]\ntheorem restrictScalars_smul (c : R₁) (f : M →ₗ[S] N) :\n    (c • f).restrictScalars R = c • f.restrictScalars R :=\n  rfl\n\n"}
{"name":"LinearMap.restrictScalars_comp","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_14\nS : Type u_15\nM : Type u_16\nN : Type u_17\nP : Type u_18\ninst✝¹³ : Semiring R\ninst✝¹² : Semiring S\ninst✝¹¹ : AddCommMonoid M\ninst✝¹⁰ : AddCommMonoid N\ninst✝⁹ : Module R M\ninst✝⁸ : Module R N\ninst✝⁷ : Module S M\ninst✝⁶ : Module S N\ninst✝⁵ : LinearMap.CompatibleSMul M N R S\ninst✝⁴ : AddCommMonoid P\ninst✝³ : Module S P\ninst✝² : Module R P\ninst✝¹ : LinearMap.CompatibleSMul N P R S\ninst✝ : LinearMap.CompatibleSMul M P R S\nf : LinearMap (RingHom.id S) N P\ng : LinearMap (RingHom.id S) M N\n⊢ Eq (↑R (f.comp g)) ((↑R f).comp (↑R g))","decl":"@[simp]\nlemma restrictScalars_comp [AddCommMonoid P] [Module S P] [Module R P]\n    [CompatibleSMul N P R S] [CompatibleSMul M P R S] (f : N →ₗ[S] P) (g : M →ₗ[S] N) :\n    (f ∘ₗ g).restrictScalars R = f.restrictScalars R ∘ₗ g.restrictScalars R := by\n  rfl\n\n"}
{"name":"LinearMap.restrictScalars_trans","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_14\nS : Type u_15\nM : Type u_16\nN : Type u_17\ninst✝¹³ : Semiring R\ninst✝¹² : Semiring S\ninst✝¹¹ : AddCommMonoid M\ninst✝¹⁰ : AddCommMonoid N\ninst✝⁹ : Module R M\ninst✝⁸ : Module R N\ninst✝⁷ : Module S M\ninst✝⁶ : Module S N\ninst✝⁵ : LinearMap.CompatibleSMul M N R S\nT : Type u_20\ninst✝⁴ : CommSemiring T\ninst✝³ : Module T M\ninst✝² : Module T N\ninst✝¹ : LinearMap.CompatibleSMul M N S T\ninst✝ : LinearMap.CompatibleSMul M N R T\nf : LinearMap (RingHom.id T) M N\n⊢ Eq (↑R (↑S f)) (↑R f)","decl":"@[simp]\nlemma restrictScalars_trans {T : Type*} [CommSemiring T] [Module T M] [Module T N]\n    [CompatibleSMul M N S T] [CompatibleSMul M N R T] (f : M →ₗ[T] N) :\n    (f.restrictScalars S).restrictScalars R = f.restrictScalars R :=\n  rfl\n\n"}
{"name":"LinearMap.restrictScalarsₗ_apply","module":"Mathlib.Algebra.Module.LinearMap.Defs","initialProofState":"R : Type u_14\nS : Type u_15\nM : Type u_16\nN : Type u_17\ninst✝¹² : Semiring R\ninst✝¹¹ : Semiring S\ninst✝¹⁰ : AddCommMonoid M\ninst✝⁹ : AddCommMonoid N\ninst✝⁸ : Module R M\ninst✝⁷ : Module R N\ninst✝⁶ : Module S M\ninst✝⁵ : Module S N\ninst✝⁴ : LinearMap.CompatibleSMul M N R S\nR₁ : Type u_19\ninst✝³ : Semiring R₁\ninst✝² : Module R₁ N\ninst✝¹ : SMulCommClass S R₁ N\ninst✝ : SMulCommClass R R₁ N\nfₗ : LinearMap (RingHom.id S) M N\n⊢ Eq ((LinearMap.restrictScalarsₗ R S M N R₁) fₗ) (↑R fₗ)","decl":"/-- `LinearMap.restrictScalars` as a `LinearMap`. -/\n@[simps apply]\ndef restrictScalarsₗ : (M →ₗ[S] N) →ₗ[R₁] M →ₗ[R] N where\n  toFun := restrictScalars R\n  map_add' := restrictScalars_add\n  map_smul' := restrictScalars_smul\n\n"}
