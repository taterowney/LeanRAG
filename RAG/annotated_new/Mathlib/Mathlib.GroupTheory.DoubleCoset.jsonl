{"name":"Doset.doset_eq_image2","module":"Mathlib.GroupTheory.DoubleCoset","initialProofState":"α : Type u_2\ninst✝ : Mul α\na : α\ns t : Set α\n⊢ Eq (Doset.doset a s t) (Set.image2 (fun x1 x2 => HMul.hMul (HMul.hMul x1 a) x2) s t)","decl":"lemma doset_eq_image2 (a : α) (s t : Set α) : doset a s t = Set.image2 (· * a * ·) s t := by\n  simp_rw [doset, Set.mul_singleton, ← Set.image2_mul, Set.image2_image_left]\n\n"}
{"name":"Doset.mem_doset","module":"Mathlib.GroupTheory.DoubleCoset","initialProofState":"α : Type u_2\ninst✝ : Mul α\ns t : Set α\na b : α\n⊢ Iff (Membership.mem (Doset.doset a s t) b) (Exists fun x => And (Membership.mem s x) (Exists fun y => And (Membership.mem t y) (Eq b (HMul.hMul (HMul.hMul x a) y))))","decl":"theorem mem_doset {s t : Set α} {a b : α} : b ∈ doset a s t ↔ ∃ x ∈ s, ∃ y ∈ t, b = x * a * y := by\n  simp only [doset_eq_image2, Set.mem_image2, eq_comm]\n\n"}
{"name":"Doset.mem_doset_self","module":"Mathlib.GroupTheory.DoubleCoset","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K : Subgroup G\na : G\n⊢ Membership.mem (Doset.doset a ↑H ↑K) a","decl":"theorem mem_doset_self (H K : Subgroup G) (a : G) : a ∈ doset a H K :=\n  mem_doset.mpr ⟨1, H.one_mem, 1, K.one_mem, (one_mul a).symm.trans (mul_one (1 * a)).symm⟩\n\n"}
{"name":"Doset.doset_eq_of_mem","module":"Mathlib.GroupTheory.DoubleCoset","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K : Subgroup G\na b : G\nhb : Membership.mem (Doset.doset a ↑H ↑K) b\n⊢ Eq (Doset.doset b ↑H ↑K) (Doset.doset a ↑H ↑K)","decl":"theorem doset_eq_of_mem {H K : Subgroup G} {a b : G} (hb : b ∈ doset a H K) :\n    doset b H K = doset a H K := by\n  obtain ⟨h, hh, k, hk, rfl⟩ := mem_doset.1 hb\n  rw [doset, doset, ← Set.singleton_mul_singleton, ← Set.singleton_mul_singleton, mul_assoc,\n    mul_assoc, Subgroup.singleton_mul_subgroup hk, ← mul_assoc, ← mul_assoc,\n    Subgroup.subgroup_mul_singleton hh]\n\n"}
{"name":"Doset.mem_doset_of_not_disjoint","module":"Mathlib.GroupTheory.DoubleCoset","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K : Subgroup G\na b : G\nh : Not (Disjoint (Doset.doset a ↑H ↑K) (Doset.doset b ↑H ↑K))\n⊢ Membership.mem (Doset.doset a ↑H ↑K) b","decl":"theorem mem_doset_of_not_disjoint {H K : Subgroup G} {a b : G}\n    (h : ¬Disjoint (doset a H K) (doset b H K)) : b ∈ doset a H K := by\n  rw [Set.not_disjoint_iff] at h\n  simp only [mem_doset] at *\n  obtain ⟨x, ⟨l, hl, r, hr, hrx⟩, y, hy, ⟨r', hr', rfl⟩⟩ := h\n  refine ⟨y⁻¹ * l, H.mul_mem (H.inv_mem hy) hl, r * r'⁻¹, K.mul_mem hr (K.inv_mem hr'), ?_⟩\n  rwa [mul_assoc, mul_assoc, eq_inv_mul_iff_mul_eq, ← mul_assoc, ← mul_assoc, eq_mul_inv_iff_mul_eq]\n\n"}
{"name":"Doset.eq_of_not_disjoint","module":"Mathlib.GroupTheory.DoubleCoset","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K : Subgroup G\na b : G\nh : Not (Disjoint (Doset.doset a ↑H ↑K) (Doset.doset b ↑H ↑K))\n⊢ Eq (Doset.doset a ↑H ↑K) (Doset.doset b ↑H ↑K)","decl":"theorem eq_of_not_disjoint {H K : Subgroup G} {a b : G}\n    (h : ¬Disjoint (doset a H K) (doset b H K)) : doset a H K = doset b H K := by\n  rw [disjoint_comm] at h\n  have ha : a ∈ doset b H K := mem_doset_of_not_disjoint h\n  apply doset_eq_of_mem ha\n\n"}
{"name":"Doset.rel_iff","module":"Mathlib.GroupTheory.DoubleCoset","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K : Subgroup G\nx y : G\n⊢ Iff ((Doset.setoid ↑H ↑K) x y) (Exists fun a => And (Membership.mem H a) (Exists fun b => And (Membership.mem K b) (Eq y (HMul.hMul (HMul.hMul a x) b))))","decl":"theorem rel_iff {H K : Subgroup G} {x y : G} :\n    setoid ↑H ↑K x y ↔ ∃ a ∈ H, ∃ b ∈ K, y = a * x * b :=\n  Iff.trans\n    ⟨fun (hxy : doset x H K = doset y H K) => hxy ▸ mem_doset_self H K y,\n      fun hxy => (doset_eq_of_mem hxy).symm⟩ mem_doset\n\n"}
{"name":"Doset.bot_rel_eq_leftRel","module":"Mathlib.GroupTheory.DoubleCoset","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\n⊢ Eq ⇑(Doset.setoid ↑Bot.bot ↑H) ⇑(QuotientGroup.leftRel H)","decl":"theorem bot_rel_eq_leftRel (H : Subgroup G) :\n    ⇑(setoid ↑(⊥ : Subgroup G) ↑H) = ⇑(QuotientGroup.leftRel H) := by\n  ext a b\n  rw [rel_iff, QuotientGroup.leftRel_apply]\n  constructor\n  · rintro ⟨a, rfl : a = 1, b, hb, rfl⟩\n    rwa [one_mul, inv_mul_cancel_left]\n  · rintro (h : a⁻¹ * b ∈ H)\n    exact ⟨1, rfl, a⁻¹ * b, h, by rw [one_mul, mul_inv_cancel_left]⟩\n\n"}
{"name":"Doset.rel_bot_eq_right_group_rel","module":"Mathlib.GroupTheory.DoubleCoset","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\n⊢ Eq ⇑(Doset.setoid ↑H ↑Bot.bot) ⇑(QuotientGroup.rightRel H)","decl":"theorem rel_bot_eq_right_group_rel (H : Subgroup G) :\n    ⇑(setoid ↑H ↑(⊥ : Subgroup G)) = ⇑(QuotientGroup.rightRel H) := by\n  ext a b\n  rw [rel_iff, QuotientGroup.rightRel_apply]\n  constructor\n  · rintro ⟨b, hb, a, rfl : a = 1, rfl⟩\n    rwa [mul_one, mul_inv_cancel_right]\n  · rintro (h : b * a⁻¹ ∈ H)\n    exact ⟨b * a⁻¹, h, 1, rfl, by rw [mul_one, inv_mul_cancel_right]⟩\n\n"}
{"name":"Doset.eq","module":"Mathlib.GroupTheory.DoubleCoset","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K : Subgroup G\na b : G\n⊢ Iff (Eq (Doset.mk H K a) (Doset.mk H K b)) (Exists fun h => And (Membership.mem H h) (Exists fun k => And (Membership.mem K k) (Eq b (HMul.hMul (HMul.hMul h a) k))))","decl":"theorem eq (H K : Subgroup G) (a b : G) :\n    mk H K a = mk H K b ↔ ∃ h ∈ H, ∃ k ∈ K, b = h * a * k := by\n  rw [Quotient.eq'']\n  apply rel_iff\n\n"}
{"name":"Doset.out_eq'","module":"Mathlib.GroupTheory.DoubleCoset","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K : Subgroup G\nq : Doset.Quotient ↑H ↑K\n⊢ Eq (Doset.mk H K (Quotient.out q)) q","decl":"theorem out_eq' (H K : Subgroup G) (q : Quotient ↑H ↑K) : mk H K q.out = q :=\n  Quotient.out_eq' q\n\n"}
{"name":"Doset.mk_out_eq_mul","module":"Mathlib.GroupTheory.DoubleCoset","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K : Subgroup G\ng : G\n⊢ Exists fun h => Exists fun k => And (Membership.mem H h) (And (Membership.mem K k) (Eq (Quotient.out (Doset.mk H K g)) (HMul.hMul (HMul.hMul h g) k)))","decl":"theorem mk_out_eq_mul (H K : Subgroup G) (g : G) :\n    ∃ h k : G, h ∈ H ∧ k ∈ K ∧ (mk H K g : Quotient ↑H ↑K).out = h * g * k := by\n  have := eq H K (mk H K g : Quotient ↑H ↑K).out g\n  rw [out_eq'] at this\n  obtain ⟨h, h_h, k, hk, T⟩ := this.1 rfl\n  refine ⟨h⁻¹, k⁻¹, H.inv_mem h_h, K.inv_mem hk, eq_mul_inv_of_mul_eq (eq_inv_mul_of_mul_eq ?_)⟩\n  rw [← mul_assoc, ← T]\n\n"}
{"name":"Doset.mk_out'_eq_mul","module":"Mathlib.GroupTheory.DoubleCoset","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K : Subgroup G\ng : G\n⊢ Exists fun h => Exists fun k => And (Membership.mem H h) (And (Membership.mem K k) (Eq (Quotient.out (Doset.mk H K g)) (HMul.hMul (HMul.hMul h g) k)))","decl":"@[deprecated (since := \"2024-10-19\")] alias mk_out'_eq_mul := mk_out_eq_mul\n\n"}
{"name":"Doset.mk_eq_of_doset_eq","module":"Mathlib.GroupTheory.DoubleCoset","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K : Subgroup G\na b : G\nh : Eq (Doset.doset a ↑H ↑K) (Doset.doset b ↑H ↑K)\n⊢ Eq (Doset.mk H K a) (Doset.mk H K b)","decl":"theorem mk_eq_of_doset_eq {H K : Subgroup G} {a b : G} (h : doset a H K = doset b H K) :\n    mk H K a = mk H K b := by\n  rw [eq]\n  exact mem_doset.mp (h.symm ▸ mem_doset_self H K b)\n\n"}
{"name":"Doset.disjoint_out","module":"Mathlib.GroupTheory.DoubleCoset","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K : Subgroup G\na b : Doset.Quotient ↑H ↑K\na✝ : Ne a b\n⊢ Disjoint (Doset.doset (Quotient.out a) ↑H ↑K) (Doset.doset (Quotient.out b) ↑H ↑K)","decl":"theorem disjoint_out {H K : Subgroup G} {a b : Quotient H K} :\n    a ≠ b → Disjoint (doset a.out H K) (doset b.out (H : Set G) K) := by\n  contrapose!\n  intro h\n  simpa [out_eq'] using mk_eq_of_doset_eq (eq_of_not_disjoint h)\n\n"}
{"name":"Doset.disjoint_out'","module":"Mathlib.GroupTheory.DoubleCoset","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K : Subgroup G\na b : Doset.Quotient ↑H ↑K\na✝ : Ne a b\n⊢ Disjoint (Doset.doset (Quotient.out a) ↑H ↑K) (Doset.doset (Quotient.out b) ↑H ↑K)","decl":"@[deprecated (since := \"2024-10-19\")] alias disjoint_out' := disjoint_out\n\n"}
{"name":"Doset.union_quotToDoset","module":"Mathlib.GroupTheory.DoubleCoset","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K : Subgroup G\n⊢ Eq (Set.iUnion fun q => Doset.quotToDoset H K q) Set.univ","decl":"theorem union_quotToDoset (H K : Subgroup G) : ⋃ q, quotToDoset H K q = Set.univ := by\n  ext x\n  simp only [Set.mem_iUnion, quotToDoset, mem_doset, SetLike.mem_coe, exists_prop, Set.mem_univ,\n    iff_true]\n  use mk H K x\n  obtain ⟨h, k, h3, h4, h5⟩ := mk_out_eq_mul H K x\n  refine ⟨h⁻¹, H.inv_mem h3, k⁻¹, K.inv_mem h4, ?_⟩\n  simp only [h5, Subgroup.coe_mk, ← mul_assoc, one_mul, inv_mul_cancel, mul_inv_cancel_right]\n\n"}
{"name":"Doset.doset_union_rightCoset","module":"Mathlib.GroupTheory.DoubleCoset","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K : Subgroup G\na : G\n⊢ Eq (Set.iUnion fun k => HSMul.hSMul (MulOpposite.op (HMul.hMul a ↑k)) ↑H) (Doset.doset a ↑H ↑K)","decl":"theorem doset_union_rightCoset (H K : Subgroup G) (a : G) :\n    ⋃ k : K, op (a * k) • ↑H = doset a H K := by\n  ext x\n  simp only [mem_rightCoset_iff, exists_prop, mul_inv_rev, Set.mem_iUnion, mem_doset,\n    Subgroup.mem_carrier, SetLike.mem_coe]\n  constructor\n  · rintro ⟨y, h_h⟩\n    refine ⟨x * (y⁻¹ * a⁻¹), h_h, y, y.2, ?_⟩\n    simp only [← mul_assoc, Subgroup.coe_mk, inv_mul_cancel_right, InvMemClass.coe_inv]\n  · rintro ⟨x, hx, y, hy, hxy⟩\n    refine ⟨⟨y, hy⟩, ?_⟩\n    simp only [hxy, ← mul_assoc, hx, mul_inv_cancel_right, Subgroup.coe_mk]\n\n"}
{"name":"Doset.doset_union_leftCoset","module":"Mathlib.GroupTheory.DoubleCoset","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K : Subgroup G\na : G\n⊢ Eq (Set.iUnion fun h => HSMul.hSMul (HMul.hMul (↑h) a) ↑K) (Doset.doset a ↑H ↑K)","decl":"theorem doset_union_leftCoset (H K : Subgroup G) (a : G) :\n    ⋃ h : H, (h * a : G) • ↑K = doset a H K := by\n  ext x\n  simp only [mem_leftCoset_iff, mul_inv_rev, Set.mem_iUnion, mem_doset]\n  constructor\n  · rintro ⟨y, h_h⟩\n    refine ⟨y, y.2, a⁻¹ * y⁻¹ * x, h_h, ?_⟩\n    simp only [← mul_assoc, one_mul, mul_inv_cancel, mul_inv_cancel_right, InvMemClass.coe_inv]\n  · rintro ⟨x, hx, y, hy, hxy⟩\n    refine ⟨⟨x, hx⟩, ?_⟩\n    simp only [hxy, ← mul_assoc, hy, one_mul, inv_mul_cancel, Subgroup.coe_mk, inv_mul_cancel_right]\n\n"}
{"name":"Doset.left_bot_eq_left_quot","module":"Mathlib.GroupTheory.DoubleCoset","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\n⊢ Eq (Doset.Quotient ↑Bot.bot ↑H) (HasQuotient.Quotient G H)","decl":"theorem left_bot_eq_left_quot (H : Subgroup G) :\n    Quotient (⊥ : Subgroup G) (H : Set G) = (G ⧸ H) := by\n  unfold Quotient\n  congr\n  ext\n  simp_rw [← bot_rel_eq_leftRel H]\n\n"}
{"name":"Doset.right_bot_eq_right_quot","module":"Mathlib.GroupTheory.DoubleCoset","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\n⊢ Eq (Doset.Quotient ↑H ↑Bot.bot) (Quotient (QuotientGroup.rightRel H))","decl":"theorem right_bot_eq_right_quot (H : Subgroup G) :\n    Quotient (H : Set G) (⊥ : Subgroup G) = _root_.Quotient (QuotientGroup.rightRel H) := by\n  unfold Quotient\n  congr\n  ext\n  simp_rw [← rel_bot_eq_right_group_rel H]\n\n"}
