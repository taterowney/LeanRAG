{"name":"PMF.pure_apply","module":"Mathlib.Probability.ProbabilityMassFunction.Monad","initialProofState":"α : Type u_1\na a' : α\n⊢ Eq ((PMF.pure a) a') (ite (Eq a' a) 1 0)","decl":"open scoped Classical in\n@[simp]\ntheorem pure_apply : pure a a' = if a' = a then 1 else 0 := rfl\n\n"}
{"name":"PMF.support_pure","module":"Mathlib.Probability.ProbabilityMassFunction.Monad","initialProofState":"α : Type u_1\na : α\n⊢ Eq (PMF.pure a).support (Singleton.singleton a)","decl":"@[simp]\ntheorem support_pure : (pure a).support = {a} :=\n  Set.ext fun a' => by simp [mem_support_iff]\n\n"}
{"name":"PMF.mem_support_pure_iff","module":"Mathlib.Probability.ProbabilityMassFunction.Monad","initialProofState":"α : Type u_1\na a' : α\n⊢ Iff (Membership.mem (PMF.pure a).support a') (Eq a' a)","decl":"theorem mem_support_pure_iff : a' ∈ (pure a).support ↔ a' = a := by simp\n\n"}
{"name":"PMF.pure_apply_self","module":"Mathlib.Probability.ProbabilityMassFunction.Monad","initialProofState":"α : Type u_1\na : α\n⊢ Eq ((PMF.pure a) a) 1","decl":"theorem pure_apply_self : pure a a = 1 :=\n  if_pos rfl\n\n"}
{"name":"PMF.pure_apply_of_ne","module":"Mathlib.Probability.ProbabilityMassFunction.Monad","initialProofState":"α : Type u_1\na a' : α\nh : Ne a' a\n⊢ Eq ((PMF.pure a) a') 0","decl":"theorem pure_apply_of_ne (h : a' ≠ a) : pure a a' = 0 :=\n  if_neg h\n\n"}
{"name":"PMF.toOuterMeasure_pure_apply","module":"Mathlib.Probability.ProbabilityMassFunction.Monad","initialProofState":"α : Type u_1\na : α\ns : Set α\n⊢ Eq ((PMF.pure a).toOuterMeasure s) (ite (Membership.mem s a) 1 0)","decl":"open scoped Classical in\n@[simp]\ntheorem toOuterMeasure_pure_apply : (pure a).toOuterMeasure s = if a ∈ s then 1 else 0 := by\n  refine (toOuterMeasure_apply (pure a) s).trans ?_\n  split_ifs with ha\n  · refine (tsum_congr fun b => ?_).trans (tsum_ite_eq a 1)\n    exact ite_eq_left_iff.2 fun hb =>\n      symm (ite_eq_right_iff.2 fun h => (hb <| h.symm ▸ ha).elim)\n  · refine (tsum_congr fun b => ?_).trans tsum_zero\n    exact ite_eq_right_iff.2 fun hb =>\n      ite_eq_right_iff.2 fun h => (ha <| h ▸ hb).elim\n\n"}
{"name":"PMF.toMeasure_pure_apply","module":"Mathlib.Probability.ProbabilityMassFunction.Monad","initialProofState":"α : Type u_1\na : α\ns : Set α\ninst✝ : MeasurableSpace α\nhs : MeasurableSet s\n⊢ Eq ((PMF.pure a).toMeasure s) (ite (Membership.mem s a) 1 0)","decl":"open scoped Classical in\n/-- The measure of a set under `pure a` is `1` for sets containing `a` and `0` otherwise. -/\n@[simp]\ntheorem toMeasure_pure_apply (hs : MeasurableSet s) :\n    (pure a).toMeasure s = if a ∈ s then 1 else 0 :=\n  (toMeasure_apply_eq_toOuterMeasure_apply (pure a) s hs).trans (toOuterMeasure_pure_apply a s)\n\n"}
{"name":"PMF.toMeasure_pure","module":"Mathlib.Probability.ProbabilityMassFunction.Monad","initialProofState":"α : Type u_1\na : α\ninst✝ : MeasurableSpace α\n⊢ Eq (PMF.pure a).toMeasure (MeasureTheory.Measure.dirac a)","decl":"theorem toMeasure_pure : (pure a).toMeasure = Measure.dirac a :=\n  Measure.ext fun s hs => by rw [toMeasure_pure_apply a s hs, Measure.dirac_apply' a hs]; rfl\n\n"}
{"name":"PMF.toPMF_dirac","module":"Mathlib.Probability.ProbabilityMassFunction.Monad","initialProofState":"α : Type u_1\na : α\ninst✝¹ : MeasurableSpace α\ninst✝ : Countable α\nh : MeasurableSingletonClass α\n⊢ Eq (MeasureTheory.Measure.dirac a).toPMF (PMF.pure a)","decl":"@[simp]\ntheorem toPMF_dirac [Countable α] [h : MeasurableSingletonClass α] :\n    (Measure.dirac a).toPMF = pure a := by\n  rw [toPMF_eq_iff_toMeasure_eq, toMeasure_pure]\n\n"}
{"name":"PMF.bind_apply","module":"Mathlib.Probability.ProbabilityMassFunction.Monad","initialProofState":"α : Type u_1\nβ : Type u_2\np : PMF α\nf : α → PMF β\nb : β\n⊢ Eq ((p.bind f) b) (tsum fun a => HMul.hMul (p a) ((f a) b))","decl":"@[simp]\ntheorem bind_apply (b : β) : p.bind f b = ∑' a, p a * f a b := rfl\n\n"}
{"name":"PMF.support_bind","module":"Mathlib.Probability.ProbabilityMassFunction.Monad","initialProofState":"α : Type u_1\nβ : Type u_2\np : PMF α\nf : α → PMF β\n⊢ Eq (p.bind f).support (Set.iUnion fun a => Set.iUnion fun h => (f a).support)","decl":"@[simp]\ntheorem support_bind : (p.bind f).support = ⋃ a ∈ p.support, (f a).support :=\n  Set.ext fun b => by simp [mem_support_iff, ENNReal.tsum_eq_zero, not_or]\n\n"}
{"name":"PMF.mem_support_bind_iff","module":"Mathlib.Probability.ProbabilityMassFunction.Monad","initialProofState":"α : Type u_1\nβ : Type u_2\np : PMF α\nf : α → PMF β\nb : β\n⊢ Iff (Membership.mem (p.bind f).support b) (Exists fun a => And (Membership.mem p.support a) (Membership.mem (f a).support b))","decl":"theorem mem_support_bind_iff (b : β) :\n    b ∈ (p.bind f).support ↔ ∃ a ∈ p.support, b ∈ (f a).support := by\n  simp only [support_bind, Set.mem_iUnion, Set.mem_setOf_eq, exists_prop]\n\n"}
{"name":"PMF.pure_bind","module":"Mathlib.Probability.ProbabilityMassFunction.Monad","initialProofState":"α : Type u_1\nβ : Type u_2\na : α\nf : α → PMF β\n⊢ Eq ((PMF.pure a).bind f) (f a)","decl":"@[simp]\ntheorem pure_bind (a : α) (f : α → PMF β) : (pure a).bind f = f a := by\n  classical\n  have : ∀ b a', ite (a' = a) (f a' b) 0 = ite (a' = a) (f a b) 0 := fun b a' => by\n    split_ifs with h <;> simp [h]\n  ext b\n  simp [this]\n\n"}
{"name":"PMF.bind_pure","module":"Mathlib.Probability.ProbabilityMassFunction.Monad","initialProofState":"α : Type u_1\np : PMF α\n⊢ Eq (p.bind PMF.pure) p","decl":"@[simp]\ntheorem bind_pure : p.bind pure = p :=\n  PMF.ext fun x => (bind_apply _ _ _).trans (_root_.trans\n    (tsum_eq_single x fun y hy => by rw [pure_apply_of_ne _ _ hy.symm, mul_zero]) <|\n    by rw [pure_apply_self, mul_one])\n\n"}
{"name":"PMF.bind_const","module":"Mathlib.Probability.ProbabilityMassFunction.Monad","initialProofState":"α : Type u_1\nβ : Type u_2\np : PMF α\nq : PMF β\n⊢ Eq (p.bind fun x => q) q","decl":"@[simp]\ntheorem bind_const (p : PMF α) (q : PMF β) : (p.bind fun _ => q) = q :=\n  PMF.ext fun x => by rw [bind_apply, ENNReal.tsum_mul_right, tsum_coe, one_mul]\n\n"}
{"name":"PMF.bind_bind","module":"Mathlib.Probability.ProbabilityMassFunction.Monad","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\np : PMF α\nf : α → PMF β\ng : β → PMF γ\n⊢ Eq ((p.bind f).bind g) (p.bind fun a => (f a).bind g)","decl":"@[simp]\ntheorem bind_bind : (p.bind f).bind g = p.bind fun a => (f a).bind g :=\n  PMF.ext fun b => by\n    simpa only [ENNReal.coe_inj.symm, bind_apply, ENNReal.tsum_mul_left.symm,\n      ENNReal.tsum_mul_right.symm, mul_assoc, mul_left_comm, mul_comm] using ENNReal.tsum_comm\n\n"}
{"name":"PMF.bind_comm","module":"Mathlib.Probability.ProbabilityMassFunction.Monad","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\np : PMF α\nq : PMF β\nf : α → β → PMF γ\n⊢ Eq (p.bind fun a => q.bind (f a)) (q.bind fun b => p.bind fun a => f a b)","decl":"theorem bind_comm (p : PMF α) (q : PMF β) (f : α → β → PMF γ) :\n    (p.bind fun a => q.bind (f a)) = q.bind fun b => p.bind fun a => f a b :=\n  PMF.ext fun b => by\n    simpa only [ENNReal.coe_inj.symm, bind_apply, ENNReal.tsum_mul_left.symm,\n      ENNReal.tsum_mul_right.symm, mul_assoc, mul_left_comm, mul_comm] using ENNReal.tsum_comm\n\n"}
{"name":"PMF.toOuterMeasure_bind_apply","module":"Mathlib.Probability.ProbabilityMassFunction.Monad","initialProofState":"α : Type u_1\nβ : Type u_2\np : PMF α\nf : α → PMF β\ns : Set β\n⊢ Eq ((p.bind f).toOuterMeasure s) (tsum fun a => HMul.hMul (p a) ((f a).toOuterMeasure s))","decl":"@[simp]\ntheorem toOuterMeasure_bind_apply :\n    (p.bind f).toOuterMeasure s = ∑' a, p a * (f a).toOuterMeasure s := by\n  classical\n  calc\n    (p.bind f).toOuterMeasure s = ∑' b, if b ∈ s then ∑' a, p a * f a b else 0 := by\n      simp [toOuterMeasure_apply, Set.indicator_apply]\n    _ = ∑' (b) (a), p a * if b ∈ s then f a b else 0 := tsum_congr fun b => by split_ifs <;> simp\n    _ = ∑' (a) (b), p a * if b ∈ s then f a b else 0 :=\n      (tsum_comm' ENNReal.summable (fun _ => ENNReal.summable) fun _ => ENNReal.summable)\n    _ = ∑' a, p a * ∑' b, if b ∈ s then f a b else 0 := tsum_congr fun _ => ENNReal.tsum_mul_left\n    _ = ∑' a, p a * ∑' b, if b ∈ s then f a b else 0 :=\n      (tsum_congr fun a => (congr_arg fun x => p a * x) <| tsum_congr fun b => by split_ifs <;> rfl)\n    _ = ∑' a, p a * (f a).toOuterMeasure s :=\n      tsum_congr fun a => by simp only [toOuterMeasure_apply, Set.indicator_apply]\n\n"}
{"name":"PMF.toMeasure_bind_apply","module":"Mathlib.Probability.ProbabilityMassFunction.Monad","initialProofState":"α : Type u_1\nβ : Type u_2\np : PMF α\nf : α → PMF β\ns : Set β\ninst✝ : MeasurableSpace β\nhs : MeasurableSet s\n⊢ Eq ((p.bind f).toMeasure s) (tsum fun a => HMul.hMul (p a) ((f a).toMeasure s))","decl":"/-- The measure of a set under `p.bind f` is the sum over `a : α`\n  of the probability of `a` under `p` times the measure of the set under `f a`. -/\n@[simp]\ntheorem toMeasure_bind_apply [MeasurableSpace β] (hs : MeasurableSet s) :\n    (p.bind f).toMeasure s = ∑' a, p a * (f a).toMeasure s :=\n  (toMeasure_apply_eq_toOuterMeasure_apply (p.bind f) s hs).trans\n    ((toOuterMeasure_bind_apply p f s).trans\n      (tsum_congr fun a =>\n        congr_arg (fun x => p a * x) (toMeasure_apply_eq_toOuterMeasure_apply (f a) s hs).symm))\n\n"}
{"name":"PMF.bindOnSupport_apply","module":"Mathlib.Probability.ProbabilityMassFunction.Monad","initialProofState":"α : Type u_1\nβ : Type u_2\np : PMF α\nf : (a : α) → Membership.mem p.support a → PMF β\nb : β\n⊢ Eq ((p.bindOnSupport f) b) (tsum fun a => HMul.hMul (p a) (dite (Eq (p a) 0) (fun h => 0) fun h => (f a h) b))","decl":"@[simp]\ntheorem bindOnSupport_apply (b : β) :\n    p.bindOnSupport f b = ∑' a, p a * if h : p a = 0 then 0 else f a h b := rfl\n\n"}
{"name":"PMF.support_bindOnSupport","module":"Mathlib.Probability.ProbabilityMassFunction.Monad","initialProofState":"α : Type u_1\nβ : Type u_2\np : PMF α\nf : (a : α) → Membership.mem p.support a → PMF β\n⊢ Eq (p.bindOnSupport f).support (Set.iUnion fun a => Set.iUnion fun h => (f a h).support)","decl":"@[simp]\ntheorem support_bindOnSupport :\n    (p.bindOnSupport f).support = ⋃ (a : α) (h : a ∈ p.support), (f a h).support := by\n  refine Set.ext fun b => ?_\n  simp only [ENNReal.tsum_eq_zero, not_or, mem_support_iff, bindOnSupport_apply, Ne, not_forall,\n    mul_eq_zero, Set.mem_iUnion]\n  exact\n    ⟨fun hb =>\n      let ⟨a, ⟨ha, ha'⟩⟩ := hb\n      ⟨a, ha, by simpa [ha] using ha'⟩,\n      fun hb =>\n      let ⟨a, ha, ha'⟩ := hb\n      ⟨a, ⟨ha, by simpa [(mem_support_iff _ a).1 ha] using ha'⟩⟩⟩\n\n"}
{"name":"PMF.mem_support_bindOnSupport_iff","module":"Mathlib.Probability.ProbabilityMassFunction.Monad","initialProofState":"α : Type u_1\nβ : Type u_2\np : PMF α\nf : (a : α) → Membership.mem p.support a → PMF β\nb : β\n⊢ Iff (Membership.mem (p.bindOnSupport f).support b) (Exists fun a => Exists fun h => Membership.mem (f a h).support b)","decl":"theorem mem_support_bindOnSupport_iff (b : β) :\n    b ∈ (p.bindOnSupport f).support ↔ ∃ (a : α) (h : a ∈ p.support), b ∈ (f a h).support := by\n  simp only [support_bindOnSupport, Set.mem_setOf_eq, Set.mem_iUnion]\n\n"}
{"name":"PMF.bindOnSupport_eq_bind","module":"Mathlib.Probability.ProbabilityMassFunction.Monad","initialProofState":"α : Type u_1\nβ : Type u_2\np : PMF α\nf : α → PMF β\n⊢ Eq (p.bindOnSupport fun a x => f a) (p.bind f)","decl":"/-- `bindOnSupport` reduces to `bind` if `f` doesn't depend on the additional hypothesis. -/\n@[simp]\ntheorem bindOnSupport_eq_bind (p : PMF α) (f : α → PMF β) :\n    (p.bindOnSupport fun a _ => f a) = p.bind f := by\n  ext b\n  have : ∀ a, ite (p a = 0) 0 (p a * f a b) = p a * f a b :=\n    fun a => ite_eq_right_iff.2 fun h => h.symm ▸ symm (zero_mul <| f a b)\n  simp only [bindOnSupport_apply fun a _ => f a, p.bind_apply f, dite_eq_ite, mul_ite,\n    mul_zero, this]\n\n"}
{"name":"PMF.bindOnSupport_eq_zero_iff","module":"Mathlib.Probability.ProbabilityMassFunction.Monad","initialProofState":"α : Type u_1\nβ : Type u_2\np : PMF α\nf : (a : α) → Membership.mem p.support a → PMF β\nb : β\n⊢ Iff (Eq ((p.bindOnSupport f) b) 0) (∀ (a : α) (ha : Ne (p a) 0), Eq ((f a ha) b) 0)","decl":"theorem bindOnSupport_eq_zero_iff (b : β) :\n    p.bindOnSupport f b = 0 ↔ ∀ (a) (ha : p a ≠ 0), f a ha b = 0 := by\n  simp only [bindOnSupport_apply, ENNReal.tsum_eq_zero, mul_eq_zero, or_iff_not_imp_left]\n  exact ⟨fun h a ha => Trans.trans (dif_neg ha).symm (h a ha),\n    fun h a ha => Trans.trans (dif_neg ha) (h a ha)⟩\n\n"}
{"name":"PMF.pure_bindOnSupport","module":"Mathlib.Probability.ProbabilityMassFunction.Monad","initialProofState":"α : Type u_1\nβ : Type u_2\na : α\nf : (a' : α) → Membership.mem (PMF.pure a).support a' → PMF β\n⊢ Eq ((PMF.pure a).bindOnSupport f) (f a ⋯)","decl":"@[simp]\ntheorem pure_bindOnSupport (a : α) (f : ∀ (a' : α) (_ : a' ∈ (pure a).support), PMF β) :\n    (pure a).bindOnSupport f = f a ((mem_support_pure_iff a a).mpr rfl) := by\n  refine PMF.ext fun b => ?_\n  simp only [bindOnSupport_apply, pure_apply]\n  classical\n  refine _root_.trans (tsum_congr fun a' => ?_) (tsum_ite_eq a _)\n  by_cases h : a' = a <;> simp [h]\n\n"}
{"name":"PMF.bindOnSupport_pure","module":"Mathlib.Probability.ProbabilityMassFunction.Monad","initialProofState":"α : Type u_1\np : PMF α\n⊢ Eq (p.bindOnSupport fun a x => PMF.pure a) p","decl":"theorem bindOnSupport_pure (p : PMF α) : (p.bindOnSupport fun a _ => pure a) = p := by\n  simp only [PMF.bind_pure, PMF.bindOnSupport_eq_bind]\n\n"}
{"name":"PMF.bindOnSupport_bindOnSupport","module":"Mathlib.Probability.ProbabilityMassFunction.Monad","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\np : PMF α\nf : (a : α) → Membership.mem p.support a → PMF β\ng : (b : β) → Membership.mem (p.bindOnSupport f).support b → PMF γ\n⊢ Eq ((p.bindOnSupport f).bindOnSupport g) (p.bindOnSupport fun a ha => (f a ha).bindOnSupport fun b hb => g b ⋯)","decl":"@[simp]\ntheorem bindOnSupport_bindOnSupport (p : PMF α) (f : ∀ a ∈ p.support, PMF β)\n    (g : ∀ b ∈ (p.bindOnSupport f).support, PMF γ) :\n    (p.bindOnSupport f).bindOnSupport g =\n      p.bindOnSupport fun a ha =>\n        (f a ha).bindOnSupport fun b hb =>\n          g b ((mem_support_bindOnSupport_iff f b).mpr ⟨a, ha, hb⟩) := by\n  refine PMF.ext fun a => ?_\n  dsimp only [bindOnSupport_apply]\n  simp only [← tsum_dite_right, ENNReal.tsum_mul_left.symm, ENNReal.tsum_mul_right.symm]\n  classical\n  simp only [ENNReal.tsum_eq_zero, dite_eq_left_iff]\n  refine ENNReal.tsum_comm.trans (tsum_congr fun a' => tsum_congr fun b => ?_)\n  split_ifs with h _ h_1 _ h_2\n  any_goals ring1\n  · have := h_1 a'\n    simp? [h] at this says simp only [h, ↓reduceDIte, mul_eq_zero, false_or] at this\n    contradiction\n  · simp [h_2]\n\n"}
{"name":"PMF.bindOnSupport_comm","module":"Mathlib.Probability.ProbabilityMassFunction.Monad","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\np : PMF α\nq : PMF β\nf : (a : α) → Membership.mem p.support a → (b : β) → Membership.mem q.support b → PMF γ\n⊢ Eq (p.bindOnSupport fun a ha => q.bindOnSupport (f a ha)) (q.bindOnSupport fun b hb => p.bindOnSupport fun a ha => f a ha b hb)","decl":"theorem bindOnSupport_comm (p : PMF α) (q : PMF β) (f : ∀ a ∈ p.support, ∀ b ∈ q.support, PMF γ) :\n    (p.bindOnSupport fun a ha => q.bindOnSupport (f a ha)) =\n      q.bindOnSupport fun b hb => p.bindOnSupport fun a ha => f a ha b hb := by\n  apply PMF.ext; rintro c\n  simp only [ENNReal.coe_inj.symm, bindOnSupport_apply, ← tsum_dite_right,\n    ENNReal.tsum_mul_left.symm, ENNReal.tsum_mul_right.symm]\n  refine _root_.trans ENNReal.tsum_comm (tsum_congr fun b => tsum_congr fun a => ?_)\n  split_ifs with h1 h2 h2 <;> ring\n\n"}
{"name":"PMF.toOuterMeasure_bindOnSupport_apply","module":"Mathlib.Probability.ProbabilityMassFunction.Monad","initialProofState":"α : Type u_1\nβ : Type u_2\np : PMF α\nf : (a : α) → Membership.mem p.support a → PMF β\ns : Set β\n⊢ Eq ((p.bindOnSupport f).toOuterMeasure s) (tsum fun a => HMul.hMul (p a) (dite (Eq (p a) 0) (fun h => 0) fun h => (f a h).toOuterMeasure s))","decl":"@[simp]\ntheorem toOuterMeasure_bindOnSupport_apply :\n    (p.bindOnSupport f).toOuterMeasure s =\n      ∑' a, p a * if h : p a = 0 then 0 else (f a h).toOuterMeasure s := by\n  simp only [toOuterMeasure_apply, Set.indicator_apply, bindOnSupport_apply]\n  classical\n  calc\n    (∑' b, ite (b ∈ s) (∑' a, p a * dite (p a = 0) (fun h => 0) fun h => f a h b) 0) =\n        ∑' (b) (a), ite (b ∈ s) (p a * dite (p a = 0) (fun h => 0) fun h => f a h b) 0 :=\n      tsum_congr fun b => by split_ifs with hbs <;> simp only [eq_self_iff_true, tsum_zero]\n    _ = ∑' (a) (b), ite (b ∈ s) (p a * dite (p a = 0) (fun h => 0) fun h => f a h b) 0 :=\n      ENNReal.tsum_comm\n    _ = ∑' a, p a * ∑' b, ite (b ∈ s) (dite (p a = 0) (fun h => 0) fun h => f a h b) 0 :=\n      (tsum_congr fun a => by simp only [← ENNReal.tsum_mul_left, mul_ite, mul_zero])\n    _ = ∑' a, p a * dite (p a = 0) (fun h => 0) fun h => ∑' b, ite (b ∈ s) (f a h b) 0 :=\n      tsum_congr fun a => by split_ifs with ha <;> simp only [ite_self, tsum_zero, eq_self_iff_true]\n\n"}
{"name":"PMF.toMeasure_bindOnSupport_apply","module":"Mathlib.Probability.ProbabilityMassFunction.Monad","initialProofState":"α : Type u_1\nβ : Type u_2\np : PMF α\nf : (a : α) → Membership.mem p.support a → PMF β\ns : Set β\ninst✝ : MeasurableSpace β\nhs : MeasurableSet s\n⊢ Eq ((p.bindOnSupport f).toMeasure s) (tsum fun a => HMul.hMul (p a) (dite (Eq (p a) 0) (fun h => 0) fun h => (f a h).toMeasure s))","decl":"/-- The measure of a set under `p.bindOnSupport f` is the sum over `a : α`\n  of the probability of `a` under `p` times the measure of the set under `f a _`.\n  The additional if statement is needed since `f` is only a partial function. -/\n@[simp]\ntheorem toMeasure_bindOnSupport_apply [MeasurableSpace β] (hs : MeasurableSet s) :\n    (p.bindOnSupport f).toMeasure s =\n      ∑' a, p a * if h : p a = 0 then 0 else (f a h).toMeasure s := by\n  simp only [toMeasure_apply_eq_toOuterMeasure_apply _ _ hs, toOuterMeasure_bindOnSupport_apply]\n\n"}
