{"name":"Computation.destruct_eq_pure","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\ns : Computation α\na : α\na✝ : Eq s.destruct (Sum.inl a)\n⊢ Eq s (Computation.pure a)","decl":"theorem destruct_eq_pure {s : Computation α} {a : α} : destruct s = Sum.inl a → s = pure a := by\n  dsimp [destruct]\n  induction' f0 : s.1 0 with _ <;> intro h\n  · contradiction\n  · apply Subtype.eq\n    funext n\n    induction' n with n IH\n    · injection h with h'\n      rwa [h'] at f0\n    · exact s.2 IH\n\n"}
{"name":"Computation.destruct_eq_think","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\ns s' : Computation α\na✝ : Eq s.destruct (Sum.inr s')\n⊢ Eq s s'.think","decl":"theorem destruct_eq_think {s : Computation α} {s'} : destruct s = Sum.inr s' → s = think s' := by\n  dsimp [destruct]\n  induction' f0 : s.1 0 with a' <;> intro h\n  · injection h with h'\n    rw [← h']\n    cases' s with f al\n    apply Subtype.eq\n    dsimp [think, tail]\n    rw [← f0]\n    exact (Stream'.eta f).symm\n  · contradiction\n\n"}
{"name":"Computation.destruct_pure","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\na : α\n⊢ Eq (Computation.pure a).destruct (Sum.inl a)","decl":"@[simp]\ntheorem destruct_pure (a : α) : destruct (pure a) = Sum.inl a :=\n  rfl\n\n"}
{"name":"Computation.destruct_think","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\ns : Computation α\n⊢ Eq s.think.destruct (Sum.inr s)","decl":"@[simp]\ntheorem destruct_think : ∀ s : Computation α, destruct (think s) = Sum.inr s\n  | ⟨_, _⟩ => rfl\n\n"}
{"name":"Computation.destruct_empty","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\n⊢ Eq (Computation.empty α).destruct (Sum.inr (Computation.empty α))","decl":"@[simp]\ntheorem destruct_empty : destruct (empty α) = Sum.inr (empty α) :=\n  rfl\n\n"}
{"name":"Computation.head_pure","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\na : α\n⊢ Eq (Computation.pure a).head (Option.some a)","decl":"@[simp]\ntheorem head_pure (a : α) : head (pure a) = some a :=\n  rfl\n\n"}
{"name":"Computation.head_think","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\ns : Computation α\n⊢ Eq s.think.head Option.none","decl":"@[simp]\ntheorem head_think (s : Computation α) : head (think s) = none :=\n  rfl\n\n"}
{"name":"Computation.head_empty","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\n⊢ Eq (Computation.empty α).head Option.none","decl":"@[simp]\ntheorem head_empty : head (empty α) = none :=\n  rfl\n\n"}
{"name":"Computation.tail_pure","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\na : α\n⊢ Eq (Computation.pure a).tail (Computation.pure a)","decl":"@[simp]\ntheorem tail_pure (a : α) : tail (pure a) = pure a :=\n  rfl\n\n"}
{"name":"Computation.tail_think","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\ns : Computation α\n⊢ Eq s.think.tail s","decl":"@[simp]\ntheorem tail_think (s : Computation α) : tail (think s) = s := by\n  cases' s with f al; apply Subtype.eq; dsimp [tail, think]\n\n"}
{"name":"Computation.tail_empty","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\n⊢ Eq (Computation.empty α).tail (Computation.empty α)","decl":"@[simp]\ntheorem tail_empty : tail (empty α) = empty α :=\n  rfl\n\n"}
{"name":"Computation.think_empty","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\n⊢ Eq (Computation.empty α) (Computation.empty α).think","decl":"theorem think_empty : empty α = think (empty α) :=\n  destruct_eq_think destruct_empty\n\n"}
{"name":"Computation.corec_eq","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\nβ : Type v\nf : β → Sum α β\nb : β\n⊢ Eq (Computation.corec f b).destruct (Computation.rmap (Computation.corec f) (f b))","decl":"@[simp]\ntheorem corec_eq (f : β → α ⊕ β) (b : β) : destruct (corec f b) = rmap (corec f) (f b) := by\n  dsimp [corec, destruct]\n  rw [show Stream'.corec' (Corec.f f) (Sum.inr b) 0 =\n    Sum.rec Option.some (fun _ ↦ none) (f b) by\n    dsimp [Corec.f, Stream'.corec', Stream'.corec, Stream'.map, Stream'.get, Stream'.iterate]\n    match (f b) with\n    | Sum.inl x => rfl\n    | Sum.inr x => rfl\n    ]\n  induction' h : f b with a b'; · rfl\n  dsimp [Corec.f, destruct]\n  apply congr_arg; apply Subtype.eq\n  dsimp [corec, tail]\n  rw [Stream'.corec'_eq, Stream'.tail_cons]\n  dsimp [Corec.f]; rw [h]\n\n"}
{"name":"Computation.eq_of_bisim","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\nR : Computation α → Computation α → Prop\nbisim : Computation.IsBisimulation R\ns₁ s₂ : Computation α\nr : R s₁ s₂\n⊢ Eq s₁ s₂","decl":"theorem eq_of_bisim (bisim : IsBisimulation R) {s₁ s₂} (r : s₁ ~ s₂) : s₁ = s₂ := by\n  apply Subtype.eq\n  apply Stream'.eq_of_bisim fun x y => ∃ s s' : Computation α, s.1 = x ∧ s'.1 = y ∧ R s s'\n  · dsimp [Stream'.IsBisimulation]\n    intro t₁ t₂ e\n    match t₁, t₂, e with\n    | _, _, ⟨s, s', rfl, rfl, r⟩ =>\n      suffices head s = head s' ∧ R (tail s) (tail s') from\n        And.imp id (fun r => ⟨tail s, tail s', by cases s; rfl, by cases s'; rfl, r⟩) this\n      have h := bisim r; revert r h\n      apply recOn s _ _ <;> intro r' <;> apply recOn s' _ _ <;> intro a' r h\n      · constructor <;> dsimp at h\n        · rw [h]\n        · rw [h] at r\n          rw [tail_pure, tail_pure,h]\n          assumption\n      · rw [destruct_pure, destruct_think] at h\n        exact False.elim h\n      · rw [destruct_pure, destruct_think] at h\n        exact False.elim h\n      · simp_all\n  · exact ⟨s₁, s₂, rfl, rfl, r⟩\n\n"}
{"name":"Computation.le_stable","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\ns : Computation α\na : α\nm n : Nat\nh : LE.le m n\na✝ : Eq (↑s m) (Option.some a)\n⊢ Eq (↑s n) (Option.some a)","decl":"theorem le_stable (s : Computation α) {a m n} (h : m ≤ n) : s.1 m = some a → s.1 n = some a := by\n  cases' s with f al\n  induction' h with n _ IH\n  exacts [id, fun h2 => al (IH h2)]\n\n"}
{"name":"Computation.mem_unique","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\ns : Computation α\na b : α\na✝¹ : Membership.mem s a\na✝ : Membership.mem s b\n⊢ Eq a b","decl":"theorem mem_unique {s : Computation α} {a b : α} : a ∈ s → b ∈ s → a = b\n  | ⟨m, ha⟩, ⟨n, hb⟩ => by\n    injection\n      (le_stable s (le_max_left m n) ha.symm).symm.trans (le_stable s (le_max_right m n) hb.symm)\n\n"}
{"name":"Computation.Mem.left_unique","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\n⊢ Relator.LeftUnique fun x1 x2 => Membership.mem x2 x1","decl":"theorem Mem.left_unique : Relator.LeftUnique ((· ∈ ·) : α → Computation α → Prop) := fun _ _ _ =>\n  mem_unique\n\n"}
{"name":"Computation.Terminates.term","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\ns : Computation α\nself : s.Terminates\n⊢ Exists fun a => Membership.mem s a","decl":"/-- `Terminates s` asserts that the computation `s` eventually terminates with some value. -/\nclass Terminates (s : Computation α) : Prop where\n  /-- assertion that there is some term `a` such that the `Computation` terminates -/\n  term : ∃ a, a ∈ s\n\n"}
{"name":"Computation.terminates_iff","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\ns : Computation α\n⊢ Iff s.Terminates (Exists fun a => Membership.mem s a)","decl":"theorem terminates_iff (s : Computation α) : Terminates s ↔ ∃ a, a ∈ s :=\n  ⟨fun h => h.1, Terminates.mk⟩\n\n"}
{"name":"Computation.terminates_of_mem","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\ns : Computation α\na : α\nh : Membership.mem s a\n⊢ s.Terminates","decl":"theorem terminates_of_mem {s : Computation α} {a : α} (h : a ∈ s) : Terminates s :=\n  ⟨⟨a, h⟩⟩\n\n"}
{"name":"Computation.terminates_def","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\ns : Computation α\n⊢ Iff s.Terminates (Exists fun n => Eq (↑s n).isSome Bool.true)","decl":"theorem terminates_def (s : Computation α) : Terminates s ↔ ∃ n, (s.1 n).isSome :=\n  ⟨fun ⟨⟨a, n, h⟩⟩ =>\n    ⟨n, by\n      dsimp [Stream'.get] at h\n      rw [← h]\n      exact rfl⟩,\n    fun ⟨n, h⟩ => ⟨⟨Option.get _ h, n, (Option.eq_some_of_isSome h).symm⟩⟩⟩\n\n"}
{"name":"Computation.ret_mem","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\na : α\n⊢ Membership.mem (Computation.pure a) a","decl":"theorem ret_mem (a : α) : a ∈ pure a :=\n  Exists.intro 0 rfl\n\n"}
{"name":"Computation.eq_of_pure_mem","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\na a' : α\nh : Membership.mem (Computation.pure a) a'\n⊢ Eq a' a","decl":"theorem eq_of_pure_mem {a a' : α} (h : a' ∈ pure a) : a' = a :=\n  mem_unique h (ret_mem _)\n\n"}
{"name":"Computation.ret_terminates","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\na : α\n⊢ (Computation.pure a).Terminates","decl":"instance ret_terminates (a : α) : Terminates (pure a) :=\n  terminates_of_mem (ret_mem _)\n\n"}
{"name":"Computation.think_mem","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\ns : Computation α\na : α\na✝ : Membership.mem s a\n⊢ Membership.mem s.think a","decl":"theorem think_mem {s : Computation α} {a} : a ∈ s → a ∈ think s\n  | ⟨n, h⟩ => ⟨n + 1, h⟩\n\n"}
{"name":"Computation.think_terminates","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\ns : Computation α\ninst✝ : s.Terminates\n⊢ s.think.Terminates","decl":"instance think_terminates (s : Computation α) : ∀ [Terminates s], Terminates (think s)\n  | ⟨⟨a, n, h⟩⟩ => ⟨⟨a, n + 1, h⟩⟩\n\n"}
{"name":"Computation.of_think_mem","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\ns : Computation α\na : α\na✝ : Membership.mem s.think a\n⊢ Membership.mem s a","decl":"theorem of_think_mem {s : Computation α} {a} : a ∈ think s → a ∈ s\n  | ⟨n, h⟩ => by\n    cases' n with n'\n    · contradiction\n    · exact ⟨n', h⟩\n\n"}
{"name":"Computation.of_think_terminates","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\ns : Computation α\na✝ : s.think.Terminates\n⊢ s.Terminates","decl":"theorem of_think_terminates {s : Computation α} : Terminates (think s) → Terminates s\n  | ⟨⟨a, h⟩⟩ => ⟨⟨a, of_think_mem h⟩⟩\n\n"}
{"name":"Computation.not_mem_empty","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\na : α\n⊢ Not (Membership.mem (Computation.empty α) a)","decl":"theorem not_mem_empty (a : α) : a ∉ empty α := fun ⟨n, h⟩ => by contradiction\n\n"}
{"name":"Computation.not_terminates_empty","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\n⊢ Not (Computation.empty α).Terminates","decl":"theorem not_terminates_empty : ¬Terminates (empty α) := fun ⟨⟨a, h⟩⟩ => not_mem_empty a h\n\n"}
{"name":"Computation.eq_empty_of_not_terminates","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\ns : Computation α\nH : Not s.Terminates\n⊢ Eq s (Computation.empty α)","decl":"theorem eq_empty_of_not_terminates {s} (H : ¬Terminates s) : s = empty α := by\n  apply Subtype.eq; funext n\n  induction' h : s.val n with _; · rfl\n  refine absurd ?_ H; exact ⟨⟨_, _, h.symm⟩⟩\n\n"}
{"name":"Computation.thinkN_mem","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\ns : Computation α\na : α\nn : Nat\n⊢ Iff (Membership.mem (s.thinkN n) a) (Membership.mem s a)","decl":"theorem thinkN_mem {s : Computation α} {a} : ∀ n, a ∈ thinkN s n ↔ a ∈ s\n  | 0 => Iff.rfl\n  | n + 1 => Iff.trans ⟨of_think_mem, think_mem⟩ (thinkN_mem n)\n\n"}
{"name":"Computation.thinkN_terminates","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\ns : Computation α\ninst✝ : s.Terminates\nn : Nat\n⊢ (s.thinkN n).Terminates","decl":"instance thinkN_terminates (s : Computation α) : ∀ [Terminates s] (n), Terminates (thinkN s n)\n  | ⟨⟨a, h⟩⟩, n => ⟨⟨a, (thinkN_mem n).2 h⟩⟩\n\n"}
{"name":"Computation.of_thinkN_terminates","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\ns : Computation α\nn : Nat\na✝ : (s.thinkN n).Terminates\n⊢ s.Terminates","decl":"theorem of_thinkN_terminates (s : Computation α) (n) : Terminates (thinkN s n) → Terminates s\n  | ⟨⟨a, h⟩⟩ => ⟨⟨a, (thinkN_mem _).1 h⟩⟩\n\n"}
{"name":"Computation.mem_promises","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\ns : Computation α\na : α\na✝ : Membership.mem s a\n⊢ s.Promises a","decl":"theorem mem_promises {s : Computation α} {a : α} : a ∈ s → s ~> a := fun h _ => mem_unique h\n\n"}
{"name":"Computation.empty_promises","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\na : α\n⊢ (Computation.empty α).Promises a","decl":"theorem empty_promises (a : α) : empty α ~> a := fun _ h => absurd h (not_mem_empty _)\n\n"}
{"name":"Computation.get_mem","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\ns : Computation α\nh : s.Terminates\n⊢ Membership.mem s s.get","decl":"theorem get_mem : get s ∈ s :=\n  Exists.intro (length s) (Option.eq_some_of_isSome _).symm\n\n"}
{"name":"Computation.get_eq_of_mem","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\ns : Computation α\nh : s.Terminates\na : α\na✝ : Membership.mem s a\n⊢ Eq s.get a","decl":"theorem get_eq_of_mem {a} : a ∈ s → get s = a :=\n  mem_unique (get_mem _)\n\n"}
{"name":"Computation.mem_of_get_eq","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\ns : Computation α\nh : s.Terminates\na : α\na✝ : Eq s.get a\n⊢ Membership.mem s a","decl":"theorem mem_of_get_eq {a} : get s = a → a ∈ s := by intro h; rw [← h]; apply get_mem\n\n"}
{"name":"Computation.get_think","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\ns : Computation α\nh : s.Terminates\n⊢ Eq s.think.get s.get","decl":"@[simp]\ntheorem get_think : get (think s) = get s :=\n  get_eq_of_mem _ <|\n    let ⟨n, h⟩ := get_mem s\n    ⟨n + 1, h⟩\n\n"}
{"name":"Computation.get_thinkN","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\ns : Computation α\nh : s.Terminates\nn : Nat\n⊢ Eq (s.thinkN n).get s.get","decl":"@[simp]\ntheorem get_thinkN (n) : get (thinkN s n) = get s :=\n  get_eq_of_mem _ <| (thinkN_mem _).2 (get_mem _)\n\n"}
{"name":"Computation.get_promises","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\ns : Computation α\nh : s.Terminates\n⊢ s.Promises s.get","decl":"theorem get_promises : s ~> get s := fun _ => get_eq_of_mem _\n\n"}
{"name":"Computation.mem_of_promises","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\ns : Computation α\nh : s.Terminates\na : α\np : s.Promises a\n⊢ Membership.mem s a","decl":"theorem mem_of_promises {a} (p : s ~> a) : a ∈ s := by\n  cases' h with h\n  cases' h with a' h\n  rw [p h]\n  exact h\n\n"}
{"name":"Computation.get_eq_of_promises","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\ns : Computation α\nh : s.Terminates\na : α\na✝ : s.Promises a\n⊢ Eq s.get a","decl":"theorem get_eq_of_promises {a} : s ~> a → get s = a :=\n  get_eq_of_mem _ ∘ mem_of_promises _\n\n"}
{"name":"Computation.results_of_terminates","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\ns : Computation α\n_T : s.Terminates\n⊢ s.Results s.get s.length","decl":"theorem results_of_terminates (s : Computation α) [_T : Terminates s] :\n    Results s (get s) (length s) :=\n  ⟨get_mem _, rfl⟩\n\n"}
{"name":"Computation.results_of_terminates'","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\ns : Computation α\nT : s.Terminates\na : α\nh : Membership.mem s a\n⊢ s.Results a s.length","decl":"theorem results_of_terminates' (s : Computation α) [T : Terminates s] {a} (h : a ∈ s) :\n    Results s a (length s) := by rw [← get_eq_of_mem _ h]; apply results_of_terminates\n\n"}
{"name":"Computation.Results.mem","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\ns : Computation α\na : α\nn : Nat\na✝ : s.Results a n\n⊢ Membership.mem s a","decl":"theorem Results.mem {s : Computation α} {a n} : Results s a n → a ∈ s\n  | ⟨m, _⟩ => m\n\n"}
{"name":"Computation.Results.terminates","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\ns : Computation α\na : α\nn : Nat\nh : s.Results a n\n⊢ s.Terminates","decl":"theorem Results.terminates {s : Computation α} {a n} (h : Results s a n) : Terminates s :=\n  terminates_of_mem h.mem\n\n"}
{"name":"Computation.Results.length","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\ns : Computation α\na : α\nn : Nat\n_T : s.Terminates\na✝ : s.Results a n\n⊢ Eq s.length n","decl":"theorem Results.length {s : Computation α} {a n} [_T : Terminates s] : Results s a n → length s = n\n  | ⟨_, h⟩ => h\n\n"}
{"name":"Computation.Results.val_unique","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\ns : Computation α\na b : α\nm n : Nat\nh1 : s.Results a m\nh2 : s.Results b n\n⊢ Eq a b","decl":"theorem Results.val_unique {s : Computation α} {a b m n} (h1 : Results s a m) (h2 : Results s b n) :\n    a = b :=\n  mem_unique h1.mem h2.mem\n\n"}
{"name":"Computation.Results.len_unique","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\ns : Computation α\na b : α\nm n : Nat\nh1 : s.Results a m\nh2 : s.Results b n\n⊢ Eq m n","decl":"theorem Results.len_unique {s : Computation α} {a b m n} (h1 : Results s a m) (h2 : Results s b n) :\n    m = n := by haveI := h1.terminates; haveI := h2.terminates; rw [← h1.length, h2.length]\n\n"}
{"name":"Computation.exists_results_of_mem","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\ns : Computation α\na : α\nh : Membership.mem s a\n⊢ Exists fun n => s.Results a n","decl":"theorem exists_results_of_mem {s : Computation α} {a} (h : a ∈ s) : ∃ n, Results s a n :=\n  haveI := terminates_of_mem h\n  ⟨_, results_of_terminates' s h⟩\n\n"}
{"name":"Computation.get_pure","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\na : α\n⊢ Eq (Computation.pure a).get a","decl":"@[simp]\ntheorem get_pure (a : α) : get (pure a) = a :=\n  get_eq_of_mem _ ⟨0, rfl⟩\n\n"}
{"name":"Computation.length_pure","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\na : α\n⊢ Eq (Computation.pure a).length 0","decl":"@[simp]\ntheorem length_pure (a : α) : length (pure a) = 0 :=\n  let h := Computation.ret_terminates a\n  Nat.eq_zero_of_le_zero <| Nat.find_min' ((terminates_def (pure a)).1 h) rfl\n\n"}
{"name":"Computation.results_pure","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\na : α\n⊢ (Computation.pure a).Results a 0","decl":"theorem results_pure (a : α) : Results (pure a) a 0 :=\n  ⟨ret_mem a, length_pure _⟩\n\n"}
{"name":"Computation.length_think","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\ns : Computation α\nh : s.Terminates\n⊢ Eq s.think.length (HAdd.hAdd s.length 1)","decl":"@[simp]\ntheorem length_think (s : Computation α) [h : Terminates s] : length (think s) = length s + 1 := by\n  apply le_antisymm\n  · exact Nat.find_min' _ (Nat.find_spec ((terminates_def _).1 h))\n  · have : (Option.isSome ((think s).val (length (think s))) : Prop) :=\n      Nat.find_spec ((terminates_def _).1 s.think_terminates)\n    revert this; cases' length (think s) with n <;> intro this\n    · simp [think, Stream'.cons] at this\n    · apply Nat.succ_le_succ\n      apply Nat.find_min'\n      apply this\n\n"}
{"name":"Computation.results_think","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\ns : Computation α\na : α\nn : Nat\nh : s.Results a n\n⊢ s.think.Results a (HAdd.hAdd n 1)","decl":"theorem results_think {s : Computation α} {a n} (h : Results s a n) : Results (think s) a (n + 1) :=\n  haveI := h.terminates\n  ⟨think_mem h.mem, by rw [length_think, h.length]⟩\n\n"}
{"name":"Computation.of_results_think","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\ns : Computation α\na : α\nn : Nat\nh : s.think.Results a n\n⊢ Exists fun m => And (s.Results a m) (Eq n (HAdd.hAdd m 1))","decl":"theorem of_results_think {s : Computation α} {a n} (h : Results (think s) a n) :\n    ∃ m, Results s a m ∧ n = m + 1 := by\n  haveI := of_think_terminates h.terminates\n  have := results_of_terminates' _ (of_think_mem h.mem)\n  exact ⟨_, this, Results.len_unique h (results_think this)⟩\n\n"}
{"name":"Computation.results_think_iff","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\ns : Computation α\na : α\nn : Nat\n⊢ Iff (s.think.Results a (HAdd.hAdd n 1)) (s.Results a n)","decl":"@[simp]\ntheorem results_think_iff {s : Computation α} {a n} : Results (think s) a (n + 1) ↔ Results s a n :=\n  ⟨fun h => by\n    let ⟨n', r, e⟩ := of_results_think h\n    injection e with h'; rwa [h'], results_think⟩\n\n"}
{"name":"Computation.results_thinkN","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\ns : Computation α\na : α\nm n : Nat\na✝ : s.Results a m\n⊢ (s.thinkN n).Results a (HAdd.hAdd m n)","decl":"theorem results_thinkN {s : Computation α} {a m} :\n    ∀ n, Results s a m → Results (thinkN s n) a (m + n)\n  | 0, h => h\n  | n + 1, h => results_think (results_thinkN n h)\n\n"}
{"name":"Computation.results_thinkN_pure","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\na : α\nn : Nat\n⊢ ((Computation.pure a).thinkN n).Results a n","decl":"theorem results_thinkN_pure (a : α) (n) : Results (thinkN (pure a) n) a n := by\n  have := results_thinkN n (results_pure a); rwa [Nat.zero_add] at this\n\n"}
{"name":"Computation.length_thinkN","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\ns : Computation α\n_h : s.Terminates\nn : Nat\n⊢ Eq (s.thinkN n).length (HAdd.hAdd s.length n)","decl":"@[simp]\ntheorem length_thinkN (s : Computation α) [_h : Terminates s] (n) :\n    length (thinkN s n) = length s + n :=\n  (results_thinkN n (results_of_terminates _)).length\n\n"}
{"name":"Computation.eq_thinkN","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\ns : Computation α\na : α\nn : Nat\nh : s.Results a n\n⊢ Eq s ((Computation.pure a).thinkN n)","decl":"theorem eq_thinkN {s : Computation α} {a n} (h : Results s a n) : s = thinkN (pure a) n := by\n  revert s\n  induction n with | zero => _ | succ n IH => _ <;>\n  (intro s; apply recOn s (fun a' => _) fun s => _) <;> intro a h\n  · rw [← eq_of_pure_mem h.mem]\n    rfl\n  · cases' of_results_think h with n h\n    cases h\n    contradiction\n  · have := h.len_unique (results_pure _)\n    contradiction\n  · rw [IH (results_think_iff.1 h)]\n    rfl\n\n"}
{"name":"Computation.eq_thinkN'","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\ns : Computation α\n_h : s.Terminates\n⊢ Eq s ((Computation.pure s.get).thinkN s.length)","decl":"theorem eq_thinkN' (s : Computation α) [_h : Terminates s] :\n    s = thinkN (pure (get s)) (length s) :=\n  eq_thinkN (results_of_terminates _)\n\n"}
{"name":"Computation.has_bind_eq_bind","module":"Mathlib.Data.Seq.Computation","initialProofState":"α β : Type u\nc : Computation α\nf : α → Computation β\n⊢ Eq (Bind.bind c f) (c.bind f)","decl":"theorem has_bind_eq_bind {β} (c : Computation α) (f : α → Computation β) : c >>= f = bind c f :=\n  rfl\n\n"}
{"name":"Computation.map_pure","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\nβ : Type v\nf : α → β\na : α\n⊢ Eq (Computation.map f (Computation.pure a)) (Computation.pure (f a))","decl":"@[simp]\ntheorem map_pure (f : α → β) (a) : map f (pure a) = pure (f a) :=\n  rfl\n\n"}
{"name":"Computation.map_think","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ns : Computation α\n⊢ Eq (Computation.map f s.think) (Computation.map f s).think","decl":"@[simp]\ntheorem map_think (f : α → β) : ∀ s, map f (think s) = think (map f s)\n  | ⟨s, al⟩ => by apply Subtype.eq; dsimp [think, map]; rw [Stream'.map_cons]\n\n"}
{"name":"Computation.destruct_map","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ns : Computation α\n⊢ Eq (Computation.map f s).destruct (Computation.lmap f (Computation.rmap (Computation.map f) s.destruct))","decl":"@[simp]\ntheorem destruct_map (f : α → β) (s) : destruct (map f s) = lmap f (rmap (map f) (destruct s)) := by\n  apply s.recOn <;> intro <;> simp\n\n"}
{"name":"Computation.map_id","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\ns : Computation α\n⊢ Eq (Computation.map id s) s","decl":"@[simp]\ntheorem map_id : ∀ s : Computation α, map id s = s\n  | ⟨f, al⟩ => by\n    apply Subtype.eq; simp only [map, comp_apply, id_eq]\n    have e : @Option.rec α (fun _ => Option α) none some = id := by ext ⟨⟩ <;> rfl\n    have h : ((fun x : Option α => x) = id) := rfl\n    simp [e, h, Stream'.map_id]\n\n"}
{"name":"Computation.map_comp","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\nf : α → β\ng : β → γ\ns : Computation α\n⊢ Eq (Computation.map (Function.comp g f) s) (Computation.map g (Computation.map f s))","decl":"theorem map_comp (f : α → β) (g : β → γ) : ∀ s : Computation α, map (g ∘ f) s = map g (map f s)\n  | ⟨s, al⟩ => by\n    apply Subtype.eq; dsimp [map]\n    apply congr_arg fun f : _ → Option γ => Stream'.map f s\n    ext ⟨⟩ <;> rfl\n\n"}
{"name":"Computation.ret_bind","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\nβ : Type v\na : α\nf : α → Computation β\n⊢ Eq ((Computation.pure a).bind f) (f a)","decl":"@[simp]\ntheorem ret_bind (a) (f : α → Computation β) : bind (pure a) f = f a := by\n  apply\n    eq_of_bisim fun c₁ c₂ => c₁ = bind (pure a) f ∧ c₂ = f a ∨ c₁ = corec (Bind.f f) (Sum.inr c₂)\n  · intro c₁ c₂ h\n    match c₁, c₂, h with\n    | _, _, Or.inl ⟨rfl, rfl⟩ =>\n      simp only [BisimO, bind, Bind.f, corec_eq, rmap, destruct_pure]\n      cases' destruct (f a) with b cb <;> simp [Bind.g]\n    | _, c, Or.inr rfl =>\n      simp only [BisimO, Bind.f, corec_eq, rmap]\n      cases' destruct c with b cb <;> simp [Bind.g]\n  · simp\n\n"}
{"name":"Computation.think_bind","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\nβ : Type v\nc : Computation α\nf : α → Computation β\n⊢ Eq (c.think.bind f) (c.bind f).think","decl":"@[simp]\ntheorem think_bind (c) (f : α → Computation β) : bind (think c) f = think (bind c f) :=\n  destruct_eq_think <| by simp [bind, Bind.f]\n\n"}
{"name":"Computation.bind_pure","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ns : Computation α\n⊢ Eq (s.bind (Function.comp Computation.pure f)) (Computation.map f s)","decl":"@[simp]\ntheorem bind_pure (f : α → β) (s) : bind s (pure ∘ f) = map f s := by\n  apply eq_of_bisim fun c₁ c₂ => c₁ = c₂ ∨ ∃ s, c₁ = bind s (pure ∘ f) ∧ c₂ = map f s\n  · intro c₁ c₂ h\n    match c₁, c₂, h with\n    | _, c₂, Or.inl (Eq.refl _) => cases' destruct c₂ with b cb <;> simp\n    | _, _, Or.inr ⟨s, rfl, rfl⟩ =>\n      apply recOn s <;> intro s\n      · simp\n      · simpa using Or.inr ⟨s, rfl, rfl⟩\n  · exact Or.inr ⟨s, rfl, rfl⟩\n\n-- Porting note: used to use `rw [bind_pure]`\n"}
{"name":"Computation.bind_pure'","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\ns : Computation α\n⊢ Eq (s.bind Computation.pure) s","decl":"@[simp]\ntheorem bind_pure' (s : Computation α) : bind s pure = s := by\n  apply eq_of_bisim fun c₁ c₂ => c₁ = c₂ ∨ ∃ s, c₁ = bind s pure ∧ c₂ = s\n  · intro c₁ c₂ h\n    match c₁, c₂, h with\n    | _, c₂, Or.inl (Eq.refl _) => cases' destruct c₂ with b cb <;> simp\n    | _, _, Or.inr ⟨s, rfl, rfl⟩ =>\n      apply recOn s <;> intro s <;> simp\n  · exact Or.inr ⟨s, rfl, rfl⟩\n\n"}
{"name":"Computation.bind_assoc","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ns : Computation α\nf : α → Computation β\ng : β → Computation γ\n⊢ Eq ((s.bind f).bind g) (s.bind fun x => (f x).bind g)","decl":"@[simp]\ntheorem bind_assoc (s : Computation α) (f : α → Computation β) (g : β → Computation γ) :\n    bind (bind s f) g = bind s fun x : α => bind (f x) g := by\n  apply\n    eq_of_bisim fun c₁ c₂ =>\n      c₁ = c₂ ∨ ∃ s, c₁ = bind (bind s f) g ∧ c₂ = bind s fun x : α => bind (f x) g\n  · intro c₁ c₂ h\n    match c₁, c₂, h with\n    | _, c₂, Or.inl (Eq.refl _) => cases' destruct c₂ with b cb <;> simp\n    | _, _, Or.inr ⟨s, rfl, rfl⟩ =>\n      apply recOn s <;> intro s\n      · simp only [BisimO, ret_bind]; generalize f s = fs\n        apply recOn fs <;> intro t <;> simp\n        · cases' destruct (g t) with b cb <;> simp\n      · simpa  [BisimO] using Or.inr ⟨s, rfl, rfl⟩\n  · exact Or.inr ⟨s, rfl, rfl⟩\n\n"}
{"name":"Computation.results_bind","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\nβ : Type v\ns : Computation α\nf : α → Computation β\na : α\nb : β\nm n : Nat\nh1 : s.Results a m\nh2 : (f a).Results b n\n⊢ (s.bind f).Results b (HAdd.hAdd n m)","decl":"theorem results_bind {s : Computation α} {f : α → Computation β} {a b m n} (h1 : Results s a m)\n    (h2 : Results (f a) b n) : Results (bind s f) b (n + m) := by\n  have := h1.mem; revert m\n  apply memRecOn this _ fun s IH => _\n  · intro _ h1\n    rw [ret_bind]\n    rw [h1.len_unique (results_pure _)]\n    exact h2\n  · intro _ h3 _ h1\n    rw [think_bind]\n    cases' of_results_think h1 with m' h\n    cases' h with h1 e\n    rw [e]\n    exact results_think (h3 h1)\n\n"}
{"name":"Computation.mem_bind","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\nβ : Type v\ns : Computation α\nf : α → Computation β\na : α\nb : β\nh1 : Membership.mem s a\nh2 : Membership.mem (f a) b\n⊢ Membership.mem (s.bind f) b","decl":"theorem mem_bind {s : Computation α} {f : α → Computation β} {a b} (h1 : a ∈ s) (h2 : b ∈ f a) :\n    b ∈ bind s f :=\n  let ⟨_, h1⟩ := exists_results_of_mem h1\n  let ⟨_, h2⟩ := exists_results_of_mem h2\n  (results_bind h1 h2).mem\n\n"}
{"name":"Computation.terminates_bind","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\nβ : Type v\ns : Computation α\nf : α → Computation β\ninst✝¹ : s.Terminates\ninst✝ : (f s.get).Terminates\n⊢ (s.bind f).Terminates","decl":"instance terminates_bind (s : Computation α) (f : α → Computation β) [Terminates s]\n    [Terminates (f (get s))] : Terminates (bind s f) :=\n  terminates_of_mem (mem_bind (get_mem s) (get_mem (f (get s))))\n\n"}
{"name":"Computation.get_bind","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\nβ : Type v\ns : Computation α\nf : α → Computation β\ninst✝¹ : s.Terminates\ninst✝ : (f s.get).Terminates\n⊢ Eq (s.bind f).get (f s.get).get","decl":"@[simp]\ntheorem get_bind (s : Computation α) (f : α → Computation β) [Terminates s]\n    [Terminates (f (get s))] : get (bind s f) = get (f (get s)) :=\n  get_eq_of_mem _ (mem_bind (get_mem s) (get_mem (f (get s))))\n\n"}
{"name":"Computation.length_bind","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\nβ : Type v\ns : Computation α\nf : α → Computation β\n_T1 : s.Terminates\n_T2 : (f s.get).Terminates\n⊢ Eq (s.bind f).length (HAdd.hAdd (f s.get).length s.length)","decl":"@[simp]\ntheorem length_bind (s : Computation α) (f : α → Computation β) [_T1 : Terminates s]\n    [_T2 : Terminates (f (get s))] : length (bind s f) = length (f (get s)) + length s :=\n  (results_of_terminates _).len_unique <|\n    results_bind (results_of_terminates _) (results_of_terminates _)\n\n"}
{"name":"Computation.of_results_bind","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\nβ : Type v\ns : Computation α\nf : α → Computation β\nb : β\nk : Nat\na✝ : (s.bind f).Results b k\n⊢ Exists fun a => Exists fun m => Exists fun n => And (s.Results a m) (And ((f a).Results b n) (Eq k (HAdd.hAdd n m)))","decl":"theorem of_results_bind {s : Computation α} {f : α → Computation β} {b k} :\n    Results (bind s f) b k → ∃ a m n, Results s a m ∧ Results (f a) b n ∧ k = n + m := by\n  induction k generalizing s with | zero => _ | succ n IH => _\n    <;> apply recOn s (fun a => _) fun s' => _ <;> intro e h\n  · simp only [ret_bind] at h\n    exact ⟨e, _, _, results_pure _, h, rfl⟩\n  · have := congr_arg head (eq_thinkN h)\n    contradiction\n  · simp only [ret_bind] at h\n    exact ⟨e, _, n + 1, results_pure _, h, rfl⟩\n  · simp only [think_bind, results_think_iff] at h\n    let ⟨a, m, n', h1, h2, e'⟩ := IH h\n    rw [e']\n    exact ⟨a, m.succ, n', results_think h1, h2, rfl⟩\n\n"}
{"name":"Computation.exists_of_mem_bind","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\nβ : Type v\ns : Computation α\nf : α → Computation β\nb : β\nh : Membership.mem (s.bind f) b\n⊢ Exists fun a => And (Membership.mem s a) (Membership.mem (f a) b)","decl":"theorem exists_of_mem_bind {s : Computation α} {f : α → Computation β} {b} (h : b ∈ bind s f) :\n    ∃ a ∈ s, b ∈ f a :=\n  let ⟨_, h⟩ := exists_results_of_mem h\n  let ⟨a, _, _, h1, h2, _⟩ := of_results_bind h\n  ⟨a, h1.mem, h2.mem⟩\n\n"}
{"name":"Computation.bind_promises","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\nβ : Type v\ns : Computation α\nf : α → Computation β\na : α\nb : β\nh1 : s.Promises a\nh2 : (f a).Promises b\n⊢ (s.bind f).Promises b","decl":"theorem bind_promises {s : Computation α} {f : α → Computation β} {a b} (h1 : s ~> a)\n    (h2 : f a ~> b) : bind s f ~> b := fun b' bB => by\n  rcases exists_of_mem_bind bB with ⟨a', a's, ba'⟩\n  rw [← h1 a's] at ba'; exact h2 ba'\n\n"}
{"name":"Computation.instLawfulMonad","module":"Mathlib.Data.Seq.Computation","initialProofState":"⊢ LawfulMonad Computation","decl":"instance : LawfulMonad Computation := LawfulMonad.mk'\n  (id_map := @map_id)\n  (bind_pure_comp := @bind_pure)\n  (pure_bind := @ret_bind)\n  (bind_assoc := @bind_assoc)\n\n"}
{"name":"Computation.has_map_eq_map","module":"Mathlib.Data.Seq.Computation","initialProofState":"α β : Type u\nf : α → β\nc : Computation α\n⊢ Eq (Functor.map f c) (Computation.map f c)","decl":"theorem has_map_eq_map {β} (f : α → β) (c : Computation α) : f <$> c = map f c :=\n  rfl\n\n"}
{"name":"Computation.pure_def","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\na : α\n⊢ Eq (Pure.pure a) (Computation.pure a)","decl":"@[simp]\ntheorem pure_def (a) : (return a : Computation α) = pure a :=\n  rfl\n\n"}
{"name":"Computation.map_pure'","module":"Mathlib.Data.Seq.Computation","initialProofState":"α β : Type u_1\nf : α → β\na : α\n⊢ Eq (Functor.map f (Computation.pure a)) (Computation.pure (f a))","decl":"@[simp]\ntheorem map_pure' {α β} : ∀ (f : α → β) (a), f <$> pure a = pure (f a) :=\n  map_pure\n\n"}
{"name":"Computation.map_think'","module":"Mathlib.Data.Seq.Computation","initialProofState":"α β : Type u_1\nf : α → β\ns : Computation α\n⊢ Eq (Functor.map f s.think) (Functor.map f s).think","decl":"@[simp]\ntheorem map_think' {α β} : ∀ (f : α → β) (s), f <$> think s = think (f <$> s) :=\n  map_think\n\n"}
{"name":"Computation.mem_map","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\nβ : Type v\nf : α → β\na : α\ns : Computation α\nm : Membership.mem s a\n⊢ Membership.mem (Computation.map f s) (f a)","decl":"theorem mem_map (f : α → β) {a} {s : Computation α} (m : a ∈ s) : f a ∈ map f s := by\n  rw [← bind_pure]; apply mem_bind m; apply ret_mem\n\n"}
{"name":"Computation.exists_of_mem_map","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nb : β\ns : Computation α\nh : Membership.mem (Computation.map f s) b\n⊢ Exists fun a => And (Membership.mem s a) (Eq (f a) b)","decl":"theorem exists_of_mem_map {f : α → β} {b : β} {s : Computation α} (h : b ∈ map f s) :\n    ∃ a, a ∈ s ∧ f a = b := by\n  rw [← bind_pure] at h\n  let ⟨a, as, fb⟩ := exists_of_mem_bind h\n  exact ⟨a, as, mem_unique (ret_mem _) fb⟩\n\n"}
{"name":"Computation.terminates_map","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ns : Computation α\ninst✝ : s.Terminates\n⊢ (Computation.map f s).Terminates","decl":"instance terminates_map (f : α → β) (s : Computation α) [Terminates s] : Terminates (map f s) := by\n  rw [← bind_pure]; exact terminates_of_mem (mem_bind (get_mem s) (get_mem (α := β) (f (get s))))\n\n"}
{"name":"Computation.terminates_map_iff","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ns : Computation α\n⊢ Iff (Computation.map f s).Terminates s.Terminates","decl":"theorem terminates_map_iff (f : α → β) (s : Computation α) : Terminates (map f s) ↔ Terminates s :=\n  ⟨fun ⟨⟨_, h⟩⟩ =>\n    let ⟨_, h1, _⟩ := exists_of_mem_map h\n    ⟨⟨_, h1⟩⟩,\n    @Computation.terminates_map _ _ _ _⟩\n\n-- Parallel computation\n"}
{"name":"Computation.ret_orElse","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\na : α\nc₂ : Computation α\n⊢ Eq (HOrElse.hOrElse (Computation.pure a) fun x => c₂) (Computation.pure a)","decl":"@[simp]\ntheorem ret_orElse (a : α) (c₂ : Computation α) : (pure a <|> c₂) = pure a :=\n  destruct_eq_pure <| by\n    unfold_projs\n    simp [orElse]\n\n-- Porting note: Added unfolds as the code does not work without it\n"}
{"name":"Computation.orElse_pure","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\nc₁ : Computation α\na : α\n⊢ Eq (HOrElse.hOrElse c₁.think fun x => Computation.pure a) (Computation.pure a)","decl":"@[simp]\ntheorem orElse_pure (c₁ : Computation α) (a : α) : (think c₁ <|> pure a) = pure a :=\n  destruct_eq_pure <| by\n    unfold_projs\n    simp [orElse]\n\n-- Porting note: Added unfolds as the code does not work without it\n"}
{"name":"Computation.orElse_think","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\nc₁ c₂ : Computation α\n⊢ Eq (HOrElse.hOrElse c₁.think fun x => c₂.think) (HOrElse.hOrElse c₁ fun x => c₂).think","decl":"@[simp]\ntheorem orElse_think (c₁ c₂ : Computation α) : (think c₁ <|> think c₂) = think (c₁ <|> c₂) :=\n  destruct_eq_think <| by\n    unfold_projs\n    simp [orElse]\n\n"}
{"name":"Computation.empty_orElse","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\nc : Computation α\n⊢ Eq (HOrElse.hOrElse (Computation.empty α) fun x => c) c","decl":"@[simp]\ntheorem empty_orElse (c) : (empty α <|> c) = c := by\n  apply eq_of_bisim (fun c₁ c₂ => (empty α <|> c₂) = c₁) _ rfl\n  intro s' s h; rw [← h]\n  apply recOn s <;> intro s <;> rw [think_empty] <;> simp\n  rw [← think_empty]\n\n"}
{"name":"Computation.orElse_empty","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\nc : Computation α\n⊢ Eq (HOrElse.hOrElse c fun x => Computation.empty α) c","decl":"@[simp]\ntheorem orElse_empty (c : Computation α) : (c <|> empty α) = c := by\n  apply eq_of_bisim (fun c₁ c₂ => (c₂ <|> empty α) = c₁) _ rfl\n  intro s' s h; rw [← h]\n  apply recOn s <;> intro s <;> rw [think_empty] <;> simp\n  rw [← think_empty]\n\n"}
{"name":"Computation.Equiv.refl","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\ns : Computation α\n⊢ s.Equiv s","decl":"@[refl]\ntheorem Equiv.refl (s : Computation α) : s ~ s := fun _ => Iff.rfl\n\n"}
{"name":"Computation.Equiv.symm","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\ns t : Computation α\na✝ : s.Equiv t\n⊢ t.Equiv s","decl":"@[symm]\ntheorem Equiv.symm {s t : Computation α} : s ~ t → t ~ s := fun h a => (h a).symm\n\n"}
{"name":"Computation.Equiv.trans","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\ns t u : Computation α\na✝¹ : s.Equiv t\na✝ : t.Equiv u\n⊢ s.Equiv u","decl":"@[trans]\ntheorem Equiv.trans {s t u : Computation α} : s ~ t → t ~ u → s ~ u := fun h1 h2 a =>\n  (h1 a).trans (h2 a)\n\n"}
{"name":"Computation.Equiv.equivalence","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\n⊢ Equivalence Computation.Equiv","decl":"theorem Equiv.equivalence : Equivalence (@Equiv α) :=\n  ⟨@Equiv.refl _, @Equiv.symm _, @Equiv.trans _⟩\n\n"}
{"name":"Computation.equiv_of_mem","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\ns t : Computation α\na : α\nh1 : Membership.mem s a\nh2 : Membership.mem t a\n⊢ s.Equiv t","decl":"theorem equiv_of_mem {s t : Computation α} {a} (h1 : a ∈ s) (h2 : a ∈ t) : s ~ t := fun a' =>\n  ⟨fun ma => by rw [mem_unique ma h1]; exact h2, fun ma => by rw [mem_unique ma h2]; exact h1⟩\n\n"}
{"name":"Computation.terminates_congr","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\nc₁ c₂ : Computation α\nh : c₁.Equiv c₂\n⊢ Iff c₁.Terminates c₂.Terminates","decl":"theorem terminates_congr {c₁ c₂ : Computation α} (h : c₁ ~ c₂) : Terminates c₁ ↔ Terminates c₂ := by\n  simp only [terminates_iff, exists_congr h]\n\n"}
{"name":"Computation.promises_congr","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\nc₁ c₂ : Computation α\nh : c₁.Equiv c₂\na : α\n⊢ Iff (c₁.Promises a) (c₂.Promises a)","decl":"theorem promises_congr {c₁ c₂ : Computation α} (h : c₁ ~ c₂) (a) : c₁ ~> a ↔ c₂ ~> a :=\n  forall_congr' fun a' => imp_congr (h a') Iff.rfl\n\n"}
{"name":"Computation.get_equiv","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\nc₁ c₂ : Computation α\nh : c₁.Equiv c₂\ninst✝¹ : c₁.Terminates\ninst✝ : c₂.Terminates\n⊢ Eq c₁.get c₂.get","decl":"theorem get_equiv {c₁ c₂ : Computation α} (h : c₁ ~ c₂) [Terminates c₁] [Terminates c₂] :\n    get c₁ = get c₂ :=\n  get_eq_of_mem _ <| (h _).2 <| get_mem _\n\n"}
{"name":"Computation.think_equiv","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\ns : Computation α\n⊢ s.think.Equiv s","decl":"theorem think_equiv (s : Computation α) : think s ~ s := fun _ => ⟨of_think_mem, think_mem⟩\n\n"}
{"name":"Computation.thinkN_equiv","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\ns : Computation α\nn : Nat\n⊢ (s.thinkN n).Equiv s","decl":"theorem thinkN_equiv (s : Computation α) (n) : thinkN s n ~ s := fun _ => thinkN_mem n\n\n"}
{"name":"Computation.bind_congr","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\nβ : Type v\ns1 s2 : Computation α\nf1 f2 : α → Computation β\nh1 : s1.Equiv s2\nh2 : ∀ (a : α), (f1 a).Equiv (f2 a)\n⊢ (s1.bind f1).Equiv (s2.bind f2)","decl":"theorem bind_congr {s1 s2 : Computation α} {f1 f2 : α → Computation β} (h1 : s1 ~ s2)\n    (h2 : ∀ a, f1 a ~ f2 a) : bind s1 f1 ~ bind s2 f2 := fun b =>\n  ⟨fun h =>\n    let ⟨a, ha, hb⟩ := exists_of_mem_bind h\n    mem_bind ((h1 a).1 ha) ((h2 a b).1 hb),\n    fun h =>\n    let ⟨a, ha, hb⟩ := exists_of_mem_bind h\n    mem_bind ((h1 a).2 ha) ((h2 a b).2 hb)⟩\n\n"}
{"name":"Computation.equiv_pure_of_mem","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\ns : Computation α\na : α\nh : Membership.mem s a\n⊢ s.Equiv (Computation.pure a)","decl":"theorem equiv_pure_of_mem {s : Computation α} {a} (h : a ∈ s) : s ~ pure a :=\n  equiv_of_mem h (ret_mem _)\n\n"}
{"name":"Computation.LiftRel.swap","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\nβ : Type v\nR : α → β → Prop\nca : Computation α\ncb : Computation β\n⊢ Iff (Computation.LiftRel (Function.swap R) cb ca) (Computation.LiftRel R ca cb)","decl":"theorem LiftRel.swap (R : α → β → Prop) (ca : Computation α) (cb : Computation β) :\n    LiftRel (swap R) cb ca ↔ LiftRel R ca cb :=\n  @and_comm _ _\n\n"}
{"name":"Computation.lift_eq_iff_equiv","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\nc₁ c₂ : Computation α\n⊢ Iff (Computation.LiftRel (fun x1 x2 => Eq x1 x2) c₁ c₂) (c₁.Equiv c₂)","decl":"theorem lift_eq_iff_equiv (c₁ c₂ : Computation α) : LiftRel (· = ·) c₁ c₂ ↔ c₁ ~ c₂ :=\n  ⟨fun ⟨h1, h2⟩ a =>\n    ⟨fun a1 => by let ⟨b, b2, ab⟩ := h1 a1; rwa [ab],\n     fun a2 => by let ⟨b, b1, ab⟩ := h2 a2; rwa [← ab]⟩,\n    fun e => ⟨fun {a} a1 => ⟨a, (e _).1 a1, rfl⟩, fun {a} a2 => ⟨a, (e _).2 a2, rfl⟩⟩⟩\n\n"}
{"name":"Computation.LiftRel.refl","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\nR : α → α → Prop\nH : Reflexive R\n⊢ Reflexive (Computation.LiftRel R)","decl":"theorem LiftRel.refl (R : α → α → Prop) (H : Reflexive R) : Reflexive (LiftRel R) := fun _ =>\n  ⟨fun {a} as => ⟨a, as, H a⟩, fun {b} bs => ⟨b, bs, H b⟩⟩\n\n"}
{"name":"Computation.LiftRel.symm","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\nR : α → α → Prop\nH : Symmetric R\n⊢ Symmetric (Computation.LiftRel R)","decl":"theorem LiftRel.symm (R : α → α → Prop) (H : Symmetric R) : Symmetric (LiftRel R) :=\n  fun _ _ ⟨l, r⟩ =>\n  ⟨fun {_} a2 =>\n    let ⟨b, b1, ab⟩ := r a2\n    ⟨b, b1, H ab⟩,\n    fun {_} a1 =>\n    let ⟨b, b2, ab⟩ := l a1\n    ⟨b, b2, H ab⟩⟩\n\n"}
{"name":"Computation.LiftRel.trans","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\nR : α → α → Prop\nH : Transitive R\n⊢ Transitive (Computation.LiftRel R)","decl":"theorem LiftRel.trans (R : α → α → Prop) (H : Transitive R) : Transitive (LiftRel R) :=\n  fun _ _ _ ⟨l1, r1⟩ ⟨l2, r2⟩ =>\n  ⟨fun {_} a1 =>\n    let ⟨_, b2, ab⟩ := l1 a1\n    let ⟨c, c3, bc⟩ := l2 b2\n    ⟨c, c3, H ab bc⟩,\n    fun {_} c3 =>\n    let ⟨_, b2, bc⟩ := r2 c3\n    let ⟨a, a1, ab⟩ := r1 b2\n    ⟨a, a1, H ab bc⟩⟩\n\n"}
{"name":"Computation.LiftRel.equiv","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\nR : α → α → Prop\na✝ : Equivalence R\n⊢ Equivalence (Computation.LiftRel R)","decl":"theorem LiftRel.equiv (R : α → α → Prop) : Equivalence R → Equivalence (LiftRel R)\n  | ⟨refl, symm, trans⟩ => ⟨LiftRel.refl R refl, by apply LiftRel.symm; apply symm,\n    by apply LiftRel.trans; apply trans⟩\n  -- Porting note: The code above was:\n  -- | ⟨refl, symm, trans⟩ => ⟨LiftRel.refl R refl, LiftRel.symm R symm, LiftRel.trans R trans⟩\n  --\n  -- The code fails to identify `symm` as being symmetric.\n\n"}
{"name":"Computation.LiftRel.imp","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\nβ : Type v\nR S : α → β → Prop\nH : ∀ {a : α} {b : β}, R a b → S a b\ns : Computation α\nt : Computation β\na✝ : Computation.LiftRel R s t\n⊢ Computation.LiftRel S s t","decl":"theorem LiftRel.imp {R S : α → β → Prop} (H : ∀ {a b}, R a b → S a b) (s t) :\n    LiftRel R s t → LiftRel S s t\n  | ⟨l, r⟩ =>\n    ⟨fun {_} as =>\n      let ⟨b, bt, ab⟩ := l as\n      ⟨b, bt, H ab⟩,\n      fun {_} bt =>\n      let ⟨a, as, ab⟩ := r bt\n      ⟨a, as, H ab⟩⟩\n\n"}
{"name":"Computation.terminates_of_liftRel","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\nβ : Type v\nR : α → β → Prop\ns : Computation α\nt : Computation β\na✝ : Computation.LiftRel R s t\n⊢ Iff s.Terminates t.Terminates","decl":"theorem terminates_of_liftRel {R : α → β → Prop} {s t} :\n    LiftRel R s t → (Terminates s ↔ Terminates t)\n  | ⟨l, r⟩ =>\n    ⟨fun ⟨⟨_, as⟩⟩ =>\n      let ⟨b, bt, _⟩ := l as\n      ⟨⟨b, bt⟩⟩,\n      fun ⟨⟨_, bt⟩⟩ =>\n      let ⟨a, as, _⟩ := r bt\n      ⟨⟨a, as⟩⟩⟩\n\n"}
{"name":"Computation.rel_of_liftRel","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\nβ : Type v\nR : α → β → Prop\nca : Computation α\ncb : Computation β\na✝² : Computation.LiftRel R ca cb\na : α\nb : β\na✝¹ : Membership.mem ca a\na✝ : Membership.mem cb b\n⊢ R a b","decl":"theorem rel_of_liftRel {R : α → β → Prop} {ca cb} :\n    LiftRel R ca cb → ∀ {a b}, a ∈ ca → b ∈ cb → R a b\n  | ⟨l, _⟩, a, b, ma, mb => by\n    let ⟨b', mb', ab'⟩ := l ma\n    rw [mem_unique mb mb']; exact ab'\n\n"}
{"name":"Computation.liftRel_of_mem","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\nβ : Type v\nR : α → β → Prop\na : α\nb : β\nca : Computation α\ncb : Computation β\nma : Membership.mem ca a\nmb : Membership.mem cb b\nab : R a b\n⊢ Computation.LiftRel R ca cb","decl":"theorem liftRel_of_mem {R : α → β → Prop} {a b ca cb} (ma : a ∈ ca) (mb : b ∈ cb) (ab : R a b) :\n    LiftRel R ca cb :=\n  ⟨fun {a'} ma' => by rw [mem_unique ma' ma]; exact ⟨b, mb, ab⟩, fun {b'} mb' => by\n    rw [mem_unique mb' mb]; exact ⟨a, ma, ab⟩⟩\n\n"}
{"name":"Computation.exists_of_liftRel_left","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\nβ : Type v\nR : α → β → Prop\nca : Computation α\ncb : Computation β\nH : Computation.LiftRel R ca cb\na : α\nh : Membership.mem ca a\n⊢ Exists fun b => And (Membership.mem cb b) (R a b)","decl":"theorem exists_of_liftRel_left {R : α → β → Prop} {ca cb} (H : LiftRel R ca cb) {a} (h : a ∈ ca) :\n    ∃ b, b ∈ cb ∧ R a b :=\n  H.left h\n\n"}
{"name":"Computation.exists_of_liftRel_right","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\nβ : Type v\nR : α → β → Prop\nca : Computation α\ncb : Computation β\nH : Computation.LiftRel R ca cb\nb : β\nh : Membership.mem cb b\n⊢ Exists fun a => And (Membership.mem ca a) (R a b)","decl":"theorem exists_of_liftRel_right {R : α → β → Prop} {ca cb} (H : LiftRel R ca cb) {b} (h : b ∈ cb) :\n    ∃ a, a ∈ ca ∧ R a b :=\n  H.right h\n\n"}
{"name":"Computation.liftRel_def","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\nβ : Type v\nR : α → β → Prop\nca : Computation α\ncb : Computation β\n⊢ Iff (Computation.LiftRel R ca cb) (And (Iff ca.Terminates cb.Terminates) (∀ {a : α} {b : β}, Membership.mem ca a → Membership.mem cb b → R a b))","decl":"theorem liftRel_def {R : α → β → Prop} {ca cb} :\n    LiftRel R ca cb ↔ (Terminates ca ↔ Terminates cb) ∧ ∀ {a b}, a ∈ ca → b ∈ cb → R a b :=\n  ⟨fun h =>\n    ⟨terminates_of_liftRel h, fun {a b} ma mb => by\n      let ⟨b', mb', ab⟩ := h.left ma\n      rwa [mem_unique mb mb']⟩,\n    fun ⟨l, r⟩ =>\n    ⟨fun {_} ma =>\n      let ⟨⟨b, mb⟩⟩ := l.1 ⟨⟨_, ma⟩⟩\n      ⟨b, mb, r ma mb⟩,\n      fun {_} mb =>\n      let ⟨⟨a, ma⟩⟩ := l.2 ⟨⟨_, mb⟩⟩\n      ⟨a, ma, r ma mb⟩⟩⟩\n\n"}
{"name":"Computation.liftRel_bind","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\nδ : Type u_1\nR : α → β → Prop\nS : γ → δ → Prop\ns1 : Computation α\ns2 : Computation β\nf1 : α → Computation γ\nf2 : β → Computation δ\nh1 : Computation.LiftRel R s1 s2\nh2 : ∀ {a : α} {b : β}, R a b → Computation.LiftRel S (f1 a) (f2 b)\n⊢ Computation.LiftRel S (s1.bind f1) (s2.bind f2)","decl":"theorem liftRel_bind {δ} (R : α → β → Prop) (S : γ → δ → Prop) {s1 : Computation α}\n    {s2 : Computation β} {f1 : α → Computation γ} {f2 : β → Computation δ} (h1 : LiftRel R s1 s2)\n    (h2 : ∀ {a b}, R a b → LiftRel S (f1 a) (f2 b)) : LiftRel S (bind s1 f1) (bind s2 f2) :=\n  let ⟨l1, r1⟩ := h1\n  ⟨fun {_} cB =>\n    let ⟨_, a1, c₁⟩ := exists_of_mem_bind cB\n    let ⟨_, b2, ab⟩ := l1 a1\n    let ⟨l2, _⟩ := h2 ab\n    let ⟨_, d2, cd⟩ := l2 c₁\n    ⟨_, mem_bind b2 d2, cd⟩,\n    fun {_} dB =>\n    let ⟨_, b1, d1⟩ := exists_of_mem_bind dB\n    let ⟨_, a2, ab⟩ := r1 b1\n    let ⟨_, r2⟩ := h2 ab\n    let ⟨_, c₂, cd⟩ := r2 d1\n    ⟨_, mem_bind a2 c₂, cd⟩⟩\n\n"}
{"name":"Computation.liftRel_pure_left","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\nβ : Type v\nR : α → β → Prop\na : α\ncb : Computation β\n⊢ Iff (Computation.LiftRel R (Computation.pure a) cb) (Exists fun b => And (Membership.mem cb b) (R a b))","decl":"@[simp]\ntheorem liftRel_pure_left (R : α → β → Prop) (a : α) (cb : Computation β) :\n    LiftRel R (pure a) cb ↔ ∃ b, b ∈ cb ∧ R a b :=\n  ⟨fun ⟨l, _⟩ => l (ret_mem _), fun ⟨b, mb, ab⟩ =>\n    ⟨fun {a'} ma' => by rw [eq_of_pure_mem ma']; exact ⟨b, mb, ab⟩, fun {b'} mb' =>\n      ⟨_, ret_mem _, by rw [mem_unique mb' mb]; exact ab⟩⟩⟩\n\n"}
{"name":"Computation.liftRel_pure_right","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\nβ : Type v\nR : α → β → Prop\nca : Computation α\nb : β\n⊢ Iff (Computation.LiftRel R ca (Computation.pure b)) (Exists fun a => And (Membership.mem ca a) (R a b))","decl":"@[simp]\ntheorem liftRel_pure_right (R : α → β → Prop) (ca : Computation α) (b : β) :\n    LiftRel R ca (pure b) ↔ ∃ a, a ∈ ca ∧ R a b := by rw [LiftRel.swap, liftRel_pure_left]\n\n-- Porting note: `simpNF` wants to simplify based on `liftRel_pure_right` but point is to prove\n-- a general invariant on `LiftRel`\n"}
{"name":"Computation.liftRel_pure","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\nβ : Type v\nR : α → β → Prop\na : α\nb : β\n⊢ Iff (Computation.LiftRel R (Computation.pure a) (Computation.pure b)) (R a b)","decl":"@[simp, nolint simpNF]\ntheorem liftRel_pure (R : α → β → Prop) (a : α) (b : β) :\n    LiftRel R (pure a) (pure b) ↔ R a b := by\n  rw [liftRel_pure_left]\n  exact ⟨fun ⟨b', mb', ab'⟩ => by rwa [eq_of_pure_mem mb'] at ab', fun ab => ⟨_, ret_mem _, ab⟩⟩\n\n"}
{"name":"Computation.liftRel_think_left","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\nβ : Type v\nR : α → β → Prop\nca : Computation α\ncb : Computation β\n⊢ Iff (Computation.LiftRel R ca.think cb) (Computation.LiftRel R ca cb)","decl":"@[simp]\ntheorem liftRel_think_left (R : α → β → Prop) (ca : Computation α) (cb : Computation β) :\n    LiftRel R (think ca) cb ↔ LiftRel R ca cb :=\n  and_congr (forall_congr' fun _ => imp_congr ⟨of_think_mem, think_mem⟩ Iff.rfl)\n    (forall_congr' fun _ =>\n      imp_congr Iff.rfl <| exists_congr fun _ => and_congr ⟨of_think_mem, think_mem⟩ Iff.rfl)\n\n"}
{"name":"Computation.liftRel_think_right","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\nβ : Type v\nR : α → β → Prop\nca : Computation α\ncb : Computation β\n⊢ Iff (Computation.LiftRel R ca cb.think) (Computation.LiftRel R ca cb)","decl":"@[simp]\ntheorem liftRel_think_right (R : α → β → Prop) (ca : Computation α) (cb : Computation β) :\n    LiftRel R ca (think cb) ↔ LiftRel R ca cb := by\n  rw [← LiftRel.swap R, ← LiftRel.swap R]; apply liftRel_think_left\n\n"}
{"name":"Computation.liftRel_mem_cases","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\nβ : Type v\nR : α → β → Prop\nca : Computation α\ncb : Computation β\nHa : ∀ (a : α), Membership.mem ca a → Computation.LiftRel R ca cb\nHb : ∀ (b : β), Membership.mem cb b → Computation.LiftRel R ca cb\n⊢ Computation.LiftRel R ca cb","decl":"theorem liftRel_mem_cases {R : α → β → Prop} {ca cb} (Ha : ∀ a ∈ ca, LiftRel R ca cb)\n    (Hb : ∀ b ∈ cb, LiftRel R ca cb) : LiftRel R ca cb :=\n  ⟨fun {_} ma => (Ha _ ma).left ma, fun {_} mb => (Hb _ mb).right mb⟩\n\n"}
{"name":"Computation.liftRel_congr","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\nβ : Type v\nR : α → β → Prop\nca ca' : Computation α\ncb cb' : Computation β\nha : ca.Equiv ca'\nhb : cb.Equiv cb'\n⊢ Iff (Computation.LiftRel R ca cb) (Computation.LiftRel R ca' cb')","decl":"theorem liftRel_congr {R : α → β → Prop} {ca ca' : Computation α} {cb cb' : Computation β}\n    (ha : ca ~ ca') (hb : cb ~ cb') : LiftRel R ca cb ↔ LiftRel R ca' cb' :=\n  and_congr\n    (forall_congr' fun _ => imp_congr (ha _) <| exists_congr fun _ => and_congr (hb _) Iff.rfl)\n    (forall_congr' fun _ => imp_congr (hb _) <| exists_congr fun _ => and_congr (ha _) Iff.rfl)\n\n"}
{"name":"Computation.liftRel_map","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\nδ : Type u_1\nR : α → β → Prop\nS : γ → δ → Prop\ns1 : Computation α\ns2 : Computation β\nf1 : α → γ\nf2 : β → δ\nh1 : Computation.LiftRel R s1 s2\nh2 : ∀ {a : α} {b : β}, R a b → S (f1 a) (f2 b)\n⊢ Computation.LiftRel S (Computation.map f1 s1) (Computation.map f2 s2)","decl":"theorem liftRel_map {δ} (R : α → β → Prop) (S : γ → δ → Prop) {s1 : Computation α}\n    {s2 : Computation β} {f1 : α → γ} {f2 : β → δ} (h1 : LiftRel R s1 s2)\n    (h2 : ∀ {a b}, R a b → S (f1 a) (f2 b)) : LiftRel S (map f1 s1) (map f2 s2) := by\n  -- Porting note: The line below was:\n  -- rw [← bind_pure, ← bind_pure]; apply lift_rel_bind _ _ h1; simp; exact @h2\n  --\n  -- The code fails to work on the last exact.\n  rw [← bind_pure, ← bind_pure]; apply liftRel_bind _ _ h1\n  simp only [comp_apply, liftRel_pure_right]\n  intros a b h; exact ⟨f1 a, ⟨ret_mem _, @h2 a b h⟩⟩\n\n-- Porting note: deleted initial arguments `(_R : α → α → Prop) (_S : β → β → Prop)`: unused\n"}
{"name":"Computation.map_congr","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\nβ : Type v\ns1 s2 : Computation α\nf : α → β\nh1 : s1.Equiv s2\n⊢ (Computation.map f s1).Equiv (Computation.map f s2)","decl":"theorem map_congr {s1 s2 : Computation α} {f : α → β}\n    (h1 : s1 ~ s2) : map f s1 ~ map f s2 := by\n  rw [← lift_eq_iff_equiv]\n  exact liftRel_map Eq _ ((lift_eq_iff_equiv _ _).2 h1) fun {a} b => congr_arg _\n\n"}
{"name":"Computation.liftRelAux_inl_inl","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\nβ : Type v\nR : α → β → Prop\nC : Computation α → Computation β → Prop\na : α\nb : β\n⊢ Eq (Computation.LiftRelAux R C (Sum.inl a) (Sum.inl b)) (R a b)","decl":"@[simp] lemma liftRelAux_inl_inl {a : α} {b : β} :\n  LiftRelAux R C (Sum.inl a) (Sum.inl b) = R a b := rfl\n"}
{"name":"Computation.liftRelAux_inl_inr","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\nβ : Type v\nR : α → β → Prop\nC : Computation α → Computation β → Prop\na : α\ncb : Computation β\n⊢ Eq (Computation.LiftRelAux R C (Sum.inl a) (Sum.inr cb)) (Exists fun b => And (Membership.mem cb b) (R a b))","decl":"@[simp] lemma liftRelAux_inl_inr {a : α} {cb} :\n    LiftRelAux R C (Sum.inl a) (Sum.inr cb) = ∃ b, b ∈ cb ∧ R a b :=\n  rfl\n"}
{"name":"Computation.liftRelAux_inr_inl","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\nβ : Type v\nR : α → β → Prop\nC : Computation α → Computation β → Prop\nb : β\nca : Computation α\n⊢ Eq (Computation.LiftRelAux R C (Sum.inr ca) (Sum.inl b)) (Exists fun a => And (Membership.mem ca a) (R a b))","decl":"@[simp] lemma liftRelAux_inr_inl {b : β} {ca} :\n    LiftRelAux R C (Sum.inr ca) (Sum.inl b) = ∃ a, a ∈ ca ∧ R a b :=\n  rfl\n"}
{"name":"Computation.liftRelAux_inr_inr","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\nβ : Type v\nR : α → β → Prop\nC : Computation α → Computation β → Prop\nca : Computation α\ncb : Computation β\n⊢ Eq (Computation.LiftRelAux R C (Sum.inr ca) (Sum.inr cb)) (C ca cb)","decl":"@[simp] lemma liftRelAux_inr_inr {ca cb} :\n    LiftRelAux R C (Sum.inr ca) (Sum.inr cb) = C ca cb :=\n  rfl\n\n"}
{"name":"Computation.LiftRelAux.ret_left","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\nβ : Type v\nR : α → β → Prop\nC : Computation α → Computation β → Prop\na : α\ncb : Computation β\n⊢ Iff (Computation.LiftRelAux R C (Sum.inl a) cb.destruct) (Exists fun b => And (Membership.mem cb b) (R a b))","decl":"@[simp]\ntheorem LiftRelAux.ret_left (R : α → β → Prop) (C : Computation α → Computation β → Prop) (a cb) :\n    LiftRelAux R C (Sum.inl a) (destruct cb) ↔ ∃ b, b ∈ cb ∧ R a b := by\n  apply cb.recOn (fun b => _) fun cb => _\n  · intro b\n    exact\n      ⟨fun h => ⟨_, ret_mem _, h⟩, fun ⟨b', mb, h⟩ => by rw [mem_unique (ret_mem _) mb]; exact h⟩\n  · intro\n    rw [destruct_think]\n    exact ⟨fun ⟨b, h, r⟩ => ⟨b, think_mem h, r⟩, fun ⟨b, h, r⟩ => ⟨b, of_think_mem h, r⟩⟩\n\n"}
{"name":"Computation.LiftRelAux.swap","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\nβ : Type v\nR : α → β → Prop\nC : Computation α → Computation β → Prop\na : Sum α (Computation α)\nb : Sum β (Computation β)\n⊢ Eq (Computation.LiftRelAux (Function.swap R) (Function.swap C) b a) (Computation.LiftRelAux R C a b)","decl":"theorem LiftRelAux.swap (R : α → β → Prop) (C) (a b) :\n    LiftRelAux (swap R) (swap C) b a = LiftRelAux R C a b := by\n  cases' a with a ca <;> cases' b with b cb <;> simp only [LiftRelAux]\n\n"}
{"name":"Computation.LiftRelAux.ret_right","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\nβ : Type v\nR : α → β → Prop\nC : Computation α → Computation β → Prop\nb : β\nca : Computation α\n⊢ Iff (Computation.LiftRelAux R C ca.destruct (Sum.inl b)) (Exists fun a => And (Membership.mem ca a) (R a b))","decl":"@[simp]\ntheorem LiftRelAux.ret_right (R : α → β → Prop) (C : Computation α → Computation β → Prop) (b ca) :\n    LiftRelAux R C (destruct ca) (Sum.inl b) ↔ ∃ a, a ∈ ca ∧ R a b := by\n  rw [← LiftRelAux.swap, LiftRelAux.ret_left]\n\n"}
{"name":"Computation.LiftRelRec.lem","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\nβ : Type v\nR : α → β → Prop\nC : Computation α → Computation β → Prop\nH : ∀ {ca : Computation α} {cb : Computation β}, C ca cb → Computation.LiftRelAux R C ca.destruct cb.destruct\nca : Computation α\ncb : Computation β\nHc : C ca cb\na : α\nha : Membership.mem ca a\n⊢ Computation.LiftRel R ca cb","decl":"theorem LiftRelRec.lem {R : α → β → Prop} (C : Computation α → Computation β → Prop)\n    (H : ∀ {ca cb}, C ca cb → LiftRelAux R C (destruct ca) (destruct cb)) (ca cb) (Hc : C ca cb) (a)\n    (ha : a ∈ ca) : LiftRel R ca cb := by\n  revert cb\n  refine memRecOn (C := (fun ca ↦ ∀ (cb : Computation β), C ca cb → LiftRel R ca cb))\n    ha ?_ (fun ca' IH => ?_) <;> intro cb Hc <;> have h := H Hc\n  · simp only [destruct_pure, LiftRelAux.ret_left] at h\n    simp [h]\n  · simp only [liftRel_think_left]\n    revert h\n    apply cb.recOn (fun b => _) fun cb' => _ <;> intros _ h\n    · simpa using h\n    · simpa [h] using IH _ h\n\n"}
{"name":"Computation.liftRel_rec","module":"Mathlib.Data.Seq.Computation","initialProofState":"α : Type u\nβ : Type v\nR : α → β → Prop\nC : Computation α → Computation β → Prop\nH : ∀ {ca : Computation α} {cb : Computation β}, C ca cb → Computation.LiftRelAux R C ca.destruct cb.destruct\nca : Computation α\ncb : Computation β\nHc : C ca cb\n⊢ Computation.LiftRel R ca cb","decl":"theorem liftRel_rec {R : α → β → Prop} (C : Computation α → Computation β → Prop)\n    (H : ∀ {ca cb}, C ca cb → LiftRelAux R C (destruct ca) (destruct cb)) (ca cb) (Hc : C ca cb) :\n    LiftRel R ca cb :=\n  liftRel_mem_cases (LiftRelRec.lem C (@H) ca cb Hc) fun b hb =>\n    (LiftRel.swap _ _ _).2 <|\n      LiftRelRec.lem (swap C) (fun {_ _} h => cast (LiftRelAux.swap _ _ _ _).symm <| H h) cb ca Hc b\n        hb\n\n"}
