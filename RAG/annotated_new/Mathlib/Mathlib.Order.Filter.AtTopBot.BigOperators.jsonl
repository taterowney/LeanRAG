{"name":"Filter.map_atTop_finset_sum_le_of_sum_eq","module":"Mathlib.Order.Filter.AtTopBot.BigOperators","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_3\ninst✝ : AddCommMonoid M\nf : α → M\ng : β → M\nh_eq : ∀ (u : Finset β), Exists fun v => ∀ (v' : Finset α), HasSubset.Subset v v' → Exists fun u' => And (HasSubset.Subset u u') (Eq (u'.sum fun x => g x) (v'.sum fun b => f b))\n⊢ LE.le (Filter.map (fun s => s.sum fun b => f b) Filter.atTop) (Filter.map (fun s => s.sum fun x => g x) Filter.atTop)","decl":"/-- Let `f` and `g` be two maps to the same commutative monoid. This lemma gives a sufficient\ncondition for comparison of the filter `atTop.map (fun s ↦ ∏ b ∈ s, f b)` with\n`atTop.map (fun s ↦ ∏ b ∈ s, g b)`. This is useful to compare the set of limit points of\n`Π b in s, f b` as `s → atTop` with the similar set for `g`. -/\n@[to_additive \"Let `f` and `g` be two maps to the same commutative additive monoid. This lemma gives\na sufficient condition for comparison of the filter `atTop.map (fun s ↦ ∑ b ∈ s, f b)` with\n`atTop.map (fun s ↦ ∑ b ∈ s, g b)`. This is useful to compare the set of limit points of\n`∑ b ∈ s, f b` as `s → atTop` with the similar set for `g`.\"]\ntheorem Filter.map_atTop_finset_prod_le_of_prod_eq {f : α → M} {g : β → M}\n    (h_eq : ∀ u : Finset β,\n      ∃ v : Finset α, ∀ v', v ⊆ v' → ∃ u', u ⊆ u' ∧ ∏ x ∈ u', g x = ∏ b ∈ v', f b) :\n    (atTop.map fun s : Finset α => ∏ b ∈ s, f b) ≤\n      atTop.map fun s : Finset β => ∏ x ∈ s, g x := by\n  classical\n    refine ((atTop_basis.map _).le_basis_iff (atTop_basis.map _)).2 fun b _ => ?_\n    let ⟨v, hv⟩ := h_eq b\n    refine ⟨v, trivial, ?_⟩\n    simpa [Finset.image_subset_iff] using hv\n\n"}
{"name":"Filter.map_atTop_finset_prod_le_of_prod_eq","module":"Mathlib.Order.Filter.AtTopBot.BigOperators","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_3\ninst✝ : CommMonoid M\nf : α → M\ng : β → M\nh_eq : ∀ (u : Finset β), Exists fun v => ∀ (v' : Finset α), HasSubset.Subset v v' → Exists fun u' => And (HasSubset.Subset u u') (Eq (u'.prod fun x => g x) (v'.prod fun b => f b))\n⊢ LE.le (Filter.map (fun s => s.prod fun b => f b) Filter.atTop) (Filter.map (fun s => s.prod fun x => g x) Filter.atTop)","decl":"/-- Let `f` and `g` be two maps to the same commutative monoid. This lemma gives a sufficient\ncondition for comparison of the filter `atTop.map (fun s ↦ ∏ b ∈ s, f b)` with\n`atTop.map (fun s ↦ ∏ b ∈ s, g b)`. This is useful to compare the set of limit points of\n`Π b in s, f b` as `s → atTop` with the similar set for `g`. -/\n@[to_additive \"Let `f` and `g` be two maps to the same commutative additive monoid. This lemma gives\na sufficient condition for comparison of the filter `atTop.map (fun s ↦ ∑ b ∈ s, f b)` with\n`atTop.map (fun s ↦ ∑ b ∈ s, g b)`. This is useful to compare the set of limit points of\n`∑ b ∈ s, f b` as `s → atTop` with the similar set for `g`.\"]\ntheorem Filter.map_atTop_finset_prod_le_of_prod_eq {f : α → M} {g : β → M}\n    (h_eq : ∀ u : Finset β,\n      ∃ v : Finset α, ∀ v', v ⊆ v' → ∃ u', u ⊆ u' ∧ ∏ x ∈ u', g x = ∏ b ∈ v', f b) :\n    (atTop.map fun s : Finset α => ∏ b ∈ s, f b) ≤\n      atTop.map fun s : Finset β => ∏ x ∈ s, g x := by\n  classical\n    refine ((atTop_basis.map _).le_basis_iff (atTop_basis.map _)).2 fun b _ => ?_\n    let ⟨v, hv⟩ := h_eq b\n    refine ⟨v, trivial, ?_⟩\n    simpa [Finset.image_subset_iff] using hv\n\n"}
{"name":"Function.Injective.map_atTop_finset_sum_eq","module":"Mathlib.Order.Filter.AtTopBot.BigOperators","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_3\ninst✝ : AddCommMonoid M\ng : α → β\nhg : Function.Injective g\nf : β → M\nhf : ∀ (x : β), Not (Membership.mem (Set.range g) x) → Eq (f x) 0\n⊢ Eq (Filter.map (fun s => s.sum fun i => f (g i)) Filter.atTop) (Filter.map (fun s => s.sum fun i => f i) Filter.atTop)","decl":"/-- Let `g : γ → β` be an injective function and `f : β → α` be a function from the codomain of `g`\nto a commutative monoid. Suppose that `f x = 1` outside of the range of `g`. Then the filters\n`atTop.map (fun s ↦ ∏ i ∈ s, f (g i))` and `atTop.map (fun s ↦ ∏ i ∈ s, f i)` coincide.\n\nThe additive version of this lemma is used to prove the equality `∑' x, f (g x) = ∑' y, f y` under\nthe same assumptions. -/\n@[to_additive]\ntheorem Function.Injective.map_atTop_finset_prod_eq {g : α → β}\n    (hg : Function.Injective g) {f : β → M} (hf : ∀ x, x ∉ Set.range g → f x = 1) :\n    map (fun s => ∏ i ∈ s, f (g i)) atTop = map (fun s => ∏ i ∈ s, f i) atTop := by\n  haveI := Classical.decEq β\n  apply le_antisymm <;> refine map_atTop_finset_prod_le_of_prod_eq fun s => ?_\n  · refine ⟨s.preimage g hg.injOn, fun t ht => ?_⟩\n    refine ⟨t.image g ∪ s, Finset.subset_union_right, ?_⟩\n    rw [← Finset.prod_image hg.injOn]\n    refine (prod_subset subset_union_left ?_).symm\n    simp only [Finset.mem_union, Finset.mem_image]\n    refine fun y hy hyt => hf y (mt ?_ hyt)\n    rintro ⟨x, rfl⟩\n    exact ⟨x, ht (Finset.mem_preimage.2 <| hy.resolve_left hyt), rfl⟩\n  · refine ⟨s.image g, fun t ht => ?_⟩\n    simp only [← prod_preimage _ _ hg.injOn _ fun x _ => hf x]\n    exact ⟨_, (image_subset_iff_subset_preimage _).1 ht, rfl⟩\n\n"}
{"name":"Function.Injective.map_atTop_finset_prod_eq","module":"Mathlib.Order.Filter.AtTopBot.BigOperators","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_3\ninst✝ : CommMonoid M\ng : α → β\nhg : Function.Injective g\nf : β → M\nhf : ∀ (x : β), Not (Membership.mem (Set.range g) x) → Eq (f x) 1\n⊢ Eq (Filter.map (fun s => s.prod fun i => f (g i)) Filter.atTop) (Filter.map (fun s => s.prod fun i => f i) Filter.atTop)","decl":"/-- Let `g : γ → β` be an injective function and `f : β → α` be a function from the codomain of `g`\nto a commutative monoid. Suppose that `f x = 1` outside of the range of `g`. Then the filters\n`atTop.map (fun s ↦ ∏ i ∈ s, f (g i))` and `atTop.map (fun s ↦ ∏ i ∈ s, f i)` coincide.\n\nThe additive version of this lemma is used to prove the equality `∑' x, f (g x) = ∑' y, f y` under\nthe same assumptions. -/\n@[to_additive]\ntheorem Function.Injective.map_atTop_finset_prod_eq {g : α → β}\n    (hg : Function.Injective g) {f : β → M} (hf : ∀ x, x ∉ Set.range g → f x = 1) :\n    map (fun s => ∏ i ∈ s, f (g i)) atTop = map (fun s => ∏ i ∈ s, f i) atTop := by\n  haveI := Classical.decEq β\n  apply le_antisymm <;> refine map_atTop_finset_prod_le_of_prod_eq fun s => ?_\n  · refine ⟨s.preimage g hg.injOn, fun t ht => ?_⟩\n    refine ⟨t.image g ∪ s, Finset.subset_union_right, ?_⟩\n    rw [← Finset.prod_image hg.injOn]\n    refine (prod_subset subset_union_left ?_).symm\n    simp only [Finset.mem_union, Finset.mem_image]\n    refine fun y hy hyt => hf y (mt ?_ hyt)\n    rintro ⟨x, rfl⟩\n    exact ⟨x, ht (Finset.mem_preimage.2 <| hy.resolve_left hyt), rfl⟩\n  · refine ⟨s.image g, fun t ht => ?_⟩\n    simp only [← prod_preimage _ _ hg.injOn _ fun x _ => hf x]\n    exact ⟨_, (image_subset_iff_subset_preimage _).1 ht, rfl⟩\n\n"}
