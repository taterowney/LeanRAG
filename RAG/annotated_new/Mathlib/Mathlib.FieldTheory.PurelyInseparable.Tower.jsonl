{"name":"LinearIndependent.map_of_isPurelyInseparable_of_isSeparable","module":"Mathlib.FieldTheory.PurelyInseparable.Tower","initialProofState":"F : Type u\nE : Type v\ninst✝⁷ : Field F\ninst✝⁶ : Field E\ninst✝⁵ : Algebra F E\nK : Type w\ninst✝⁴ : Field K\ninst✝³ : Algebra F K\ninst✝² : Algebra E K\ninst✝¹ : IsScalarTower F E K\ninst✝ : IsPurelyInseparable F E\nι : Type u_1\nv : ι → K\nhsep : ∀ (i : ι), IsSeparable F (v i)\nh : LinearIndependent F v\n⊢ LinearIndependent E v","decl":"variable {F K} in\n/-- If `K / E / F` is a field extension tower such that `E / F` is purely inseparable,\nif `{ u_i }` is a family of separable elements of `K` which is `F`-linearly independent,\nthen it is also `E`-linearly independent. -/\ntheorem LinearIndependent.map_of_isPurelyInseparable_of_isSeparable [IsPurelyInseparable F E]\n    {ι : Type*} {v : ι → K} (hsep : ∀ i : ι, IsSeparable F (v i))\n    (h : LinearIndependent F v) : LinearIndependent E v := by\n  obtain ⟨q, _⟩ := ExpChar.exists F\n  haveI := expChar_of_injective_algebraMap (algebraMap F K).injective q\n  refine linearIndependent_iff.mpr fun l hl ↦ Finsupp.ext fun i ↦ ?_\n  choose f hf using fun i ↦ (isPurelyInseparable_iff_pow_mem F q).1 ‹_› (l i)\n  let n := l.support.sup f\n  have := (expChar_pow_pos F q n).ne'\n  replace hf (i : ι) : l i ^ q ^ n ∈ (algebraMap F E).range := by\n    by_cases hs : i ∈ l.support\n    · convert pow_mem (hf i) (q ^ (n - f i)) using 1\n      rw [← pow_mul, ← pow_add, Nat.add_sub_of_le (Finset.le_sup hs)]\n    exact ⟨0, by rw [map_zero, Finsupp.not_mem_support_iff.1 hs, zero_pow this]⟩\n  choose lF hlF using hf\n  let lF₀ := Finsupp.onFinset l.support lF fun i ↦ by\n    contrapose!\n    refine fun hs ↦ (injective_iff_map_eq_zero _).mp (algebraMap F E).injective _ ?_\n    rw [hlF, Finsupp.not_mem_support_iff.1 hs, zero_pow this]\n  replace h := linearIndependent_iff.1 (h.map_pow_expChar_pow_of_isSeparable' q n hsep) lF₀ <| by\n    replace hl := congr($hl ^ q ^ n)\n    rw [Finsupp.linearCombination_apply, Finsupp.sum, sum_pow_char_pow, zero_pow this] at hl\n    rw [← hl, Finsupp.linearCombination_apply,\n      Finsupp.onFinset_sum _ (fun _ ↦ by exact zero_smul _ _)]\n    refine Finset.sum_congr rfl fun i _ ↦ ?_\n    simp_rw [Algebra.smul_def, mul_pow, IsScalarTower.algebraMap_apply F E K, hlF, map_pow]\n  refine pow_eq_zero ((hlF _).symm.trans ?_)\n  convert map_zero (algebraMap F E)\n  exact congr($h i)\n\n"}
{"name":"Field.sepDegree_eq_of_isPurelyInseparable_of_isSeparable","module":"Mathlib.FieldTheory.PurelyInseparable.Tower","initialProofState":"F : Type u\nE : Type v\ninst✝⁸ : Field F\ninst✝⁷ : Field E\ninst✝⁶ : Algebra F E\nK : Type w\ninst✝⁵ : Field K\ninst✝⁴ : Algebra F K\ninst✝³ : Algebra E K\ninst✝² : IsScalarTower F E K\ninst✝¹ : IsPurelyInseparable F E\ninst✝ : Algebra.IsSeparable E K\n⊢ Eq (Field.sepDegree F K) (Module.rank E K)","decl":"/-- If `K / E / F` is a field extension tower, such that `E / F` is purely inseparable and `K / E`\nis separable, then the separable degree of `K / F` is equal to the degree of `K / E`.\nIt is a special case of `Field.lift_sepDegree_mul_lift_sepDegree_of_isAlgebraic`, and is an\nintermediate result used to prove it. -/\nlemma sepDegree_eq_of_isPurelyInseparable_of_isSeparable\n    [IsPurelyInseparable F E] [Algebra.IsSeparable E K] : sepDegree F K = Module.rank E K := by\n  let S := separableClosure F K\n  have h := S.adjoin_rank_le_of_isAlgebraic_right E\n  rw [separableClosure.adjoin_eq_of_isAlgebraic_of_isSeparable K, rank_top'] at h\n  obtain ⟨ι, ⟨b⟩⟩ := Basis.exists_basis F S\n  exact h.antisymm' (b.mk_eq_rank'' ▸ (b.linearIndependent.map' S.val.toLinearMap\n    (LinearMap.ker_eq_bot_of_injective S.val.injective)\n    |>.map_of_isPurelyInseparable_of_isSeparable E (fun i ↦\n      by simpa only [IsSeparable, minpoly_eq] using Algebra.IsSeparable.isSeparable F (b i))\n    |>.cardinal_le_rank))\n\n"}
{"name":"Field.lift_rank_mul_lift_sepDegree_of_isSeparable","module":"Mathlib.FieldTheory.PurelyInseparable.Tower","initialProofState":"F : Type u\nE : Type v\ninst✝⁷ : Field F\ninst✝⁶ : Field E\ninst✝⁵ : Algebra F E\nK : Type w\ninst✝⁴ : Field K\ninst✝³ : Algebra F K\ninst✝² : Algebra E K\ninst✝¹ : IsScalarTower F E K\ninst✝ : Algebra.IsSeparable F E\n⊢ Eq (HMul.hMul (Cardinal.lift.{w, v} (Module.rank F E)) (Cardinal.lift.{v, w} (Field.sepDegree E K))) (Cardinal.lift.{v, w} (Field.sepDegree F K))","decl":"/-- If `K / E / F` is a field extension tower, such that `E / F` is separable,\nthen $[E:F] [K:E]_s = [K:F]_s$.\nIt is a special case of `Field.lift_sepDegree_mul_lift_sepDegree_of_isAlgebraic`, and is an\nintermediate result used to prove it. -/\nlemma lift_rank_mul_lift_sepDegree_of_isSeparable [Algebra.IsSeparable F E] :\n    Cardinal.lift.{w} (Module.rank F E) * Cardinal.lift.{v} (sepDegree E K) =\n    Cardinal.lift.{v} (sepDegree F K) := by\n  rw [sepDegree, sepDegree, separableClosure.eq_restrictScalars_of_isSeparable F E K]\n  exact lift_rank_mul_lift_rank F E (separableClosure E K)\n\n"}
{"name":"Field.rank_mul_sepDegree_of_isSeparable","module":"Mathlib.FieldTheory.PurelyInseparable.Tower","initialProofState":"F : Type u\nE : Type v\ninst✝⁷ : Field F\ninst✝⁶ : Field E\ninst✝⁵ : Algebra F E\nK : Type v\ninst✝⁴ : Field K\ninst✝³ : Algebra F K\ninst✝² : Algebra E K\ninst✝¹ : IsScalarTower F E K\ninst✝ : Algebra.IsSeparable F E\n⊢ Eq (HMul.hMul (Module.rank F E) (Field.sepDegree E K)) (Field.sepDegree F K)","decl":"/-- The same-universe version of `Field.lift_rank_mul_lift_sepDegree_of_isSeparable`. -/\nlemma rank_mul_sepDegree_of_isSeparable (K : Type v) [Field K] [Algebra F K]\n    [Algebra E K] [IsScalarTower F E K] [Algebra.IsSeparable F E] :\n    Module.rank F E * sepDegree E K = sepDegree F K := by\n  simpa only [Cardinal.lift_id] using lift_rank_mul_lift_sepDegree_of_isSeparable F E K\n\n"}
{"name":"Field.sepDegree_eq_of_isPurelyInseparable","module":"Mathlib.FieldTheory.PurelyInseparable.Tower","initialProofState":"F : Type u\nE : Type v\ninst✝⁷ : Field F\ninst✝⁶ : Field E\ninst✝⁵ : Algebra F E\nK : Type w\ninst✝⁴ : Field K\ninst✝³ : Algebra F K\ninst✝² : Algebra E K\ninst✝¹ : IsScalarTower F E K\ninst✝ : IsPurelyInseparable F E\n⊢ Eq (Field.sepDegree F K) (Field.sepDegree E K)","decl":"/-- If `K / E / F` is a field extension tower, such that `E / F` is purely inseparable,\nthen $[K:F]_s = [K:E]_s$.\nIt is a special case of `Field.lift_sepDegree_mul_lift_sepDegree_of_isAlgebraic`, and is an\nintermediate result used to prove it. -/\nlemma sepDegree_eq_of_isPurelyInseparable [IsPurelyInseparable F E] :\n    sepDegree F K = sepDegree E K := by\n  convert sepDegree_eq_of_isPurelyInseparable_of_isSeparable F E (separableClosure E K)\n  haveI : IsScalarTower F (separableClosure E K) K := IsScalarTower.of_algebraMap_eq (congrFun rfl)\n  rw [sepDegree, ← separableClosure.map_eq_of_separableClosure_eq_bot F\n    (separableClosure.separableClosure_eq_bot E K)]\n  exact (separableClosure F (separableClosure E K)).equivMap\n    (IsScalarTower.toAlgHom F (separableClosure E K) K) |>.symm.toLinearEquiv.rank_eq\n\n"}
{"name":"Field.lift_sepDegree_mul_lift_sepDegree_of_isAlgebraic","module":"Mathlib.FieldTheory.PurelyInseparable.Tower","initialProofState":"F : Type u\nE : Type v\ninst✝⁷ : Field F\ninst✝⁶ : Field E\ninst✝⁵ : Algebra F E\nK : Type w\ninst✝⁴ : Field K\ninst✝³ : Algebra F K\ninst✝² : Algebra E K\ninst✝¹ : IsScalarTower F E K\ninst✝ : Algebra.IsAlgebraic F E\n⊢ Eq (HMul.hMul (Cardinal.lift.{w, v} (Field.sepDegree F E)) (Cardinal.lift.{v, w} (Field.sepDegree E K))) (Cardinal.lift.{v, w} (Field.sepDegree F K))","decl":"/-- If `K / E / F` is a field extension tower, such that `E / F` is algebraic, then their\nseparable degrees satisfy the tower law: $[E:F]_s [K:E]_s = [K:F]_s$. -/\ntheorem lift_sepDegree_mul_lift_sepDegree_of_isAlgebraic [Algebra.IsAlgebraic F E] :\n    Cardinal.lift.{w} (sepDegree F E) * Cardinal.lift.{v} (sepDegree E K) =\n    Cardinal.lift.{v} (sepDegree F K) := by\n  have h := lift_rank_mul_lift_sepDegree_of_isSeparable F (separableClosure F E) K\n  haveI := separableClosure.isPurelyInseparable F E\n  rwa [sepDegree_eq_of_isPurelyInseparable (separableClosure F E) E K] at h\n\n"}
{"name":"Field.sepDegree_mul_sepDegree_of_isAlgebraic","module":"Mathlib.FieldTheory.PurelyInseparable.Tower","initialProofState":"F : Type u\nE : Type v\ninst✝⁷ : Field F\ninst✝⁶ : Field E\ninst✝⁵ : Algebra F E\nK : Type v\ninst✝⁴ : Field K\ninst✝³ : Algebra F K\ninst✝² : Algebra E K\ninst✝¹ : IsScalarTower F E K\ninst✝ : Algebra.IsAlgebraic F E\n⊢ Eq (HMul.hMul (Field.sepDegree F E) (Field.sepDegree E K)) (Field.sepDegree F K)","decl":"/-- The same-universe version of `Field.lift_sepDegree_mul_lift_sepDegree_of_isAlgebraic`. -/\n@[stacks 09HK \"Part 1\"]\ntheorem sepDegree_mul_sepDegree_of_isAlgebraic (K : Type v) [Field K] [Algebra F K]\n    [Algebra E K] [IsScalarTower F E K] [Algebra.IsAlgebraic F E] :\n    sepDegree F E * sepDegree E K = sepDegree F K := by\n  simpa only [Cardinal.lift_id] using lift_sepDegree_mul_lift_sepDegree_of_isAlgebraic F E K\n\n"}
{"name":"IntermediateField.sepDegree_adjoin_eq_of_isAlgebraic_of_isPurelyInseparable","module":"Mathlib.FieldTheory.PurelyInseparable.Tower","initialProofState":"F : Type u\nE : Type v\ninst✝⁸ : Field F\ninst✝⁷ : Field E\ninst✝⁶ : Algebra F E\nK : Type w\ninst✝⁵ : Field K\ninst✝⁴ : Algebra F K\ninst✝³ : Algebra E K\ninst✝² : IsScalarTower F E K\nS : Set K\ninst✝¹ : Algebra.IsAlgebraic F (Subtype fun x => Membership.mem (IntermediateField.adjoin F S) x)\ninst✝ : IsPurelyInseparable F E\n⊢ Eq (Field.sepDegree E (Subtype fun x => Membership.mem (IntermediateField.adjoin E S) x)) (Field.sepDegree F (Subtype fun x => Membership.mem (IntermediateField.adjoin F S) x))","decl":"variable {F K} in\n/-- If `K / E / F` is a field extension tower, such that `E / F` is purely inseparable, then\nfor any subset `S` of `K` such that `F(S) / F` is algebraic, the `E(S) / E` and `F(S) / F` have\nthe same separable degree. -/\ntheorem IntermediateField.sepDegree_adjoin_eq_of_isAlgebraic_of_isPurelyInseparable\n    (S : Set K) [Algebra.IsAlgebraic F (adjoin F S)] [IsPurelyInseparable F E] :\n    sepDegree E (adjoin E S) = sepDegree F (adjoin F S) := by\n  set M := adjoin F S\n  set L := adjoin E S\n  let E' := (IsScalarTower.toAlgHom F E K).fieldRange\n  let j : E ≃ₐ[F] E' := AlgEquiv.ofInjectiveField (IsScalarTower.toAlgHom F E K)\n  have hi : M ≤ L.restrictScalars F := by\n    rw [restrictScalars_adjoin_of_algEquiv (E := K) j rfl, restrictScalars_adjoin]\n    exact adjoin.mono _ _ _ Set.subset_union_right\n  let i : M →+* L := Subsemiring.inclusion hi\n  letI : Algebra M L := i.toAlgebra\n  letI : SMul M L := Algebra.toSMul\n  haveI : IsScalarTower F M L := IsScalarTower.of_algebraMap_eq (congrFun rfl)\n  haveI : IsPurelyInseparable M L := by\n    change IsPurelyInseparable M (extendScalars hi)\n    obtain ⟨q, _⟩ := ExpChar.exists F\n    have : extendScalars hi = adjoin M (E' : Set K) := restrictScalars_injective F <| by\n      conv_lhs => rw [extendScalars_restrictScalars, restrictScalars_adjoin_of_algEquiv\n        (E := K) j rfl, ← adjoin_self F E', adjoin_adjoin_comm]\n    rw [this, isPurelyInseparable_adjoin_iff_pow_mem _ _ q]\n    rintro x ⟨y, hy⟩\n    obtain ⟨n, z, hz⟩ := IsPurelyInseparable.pow_mem F q y\n    refine ⟨n, algebraMap F M z, ?_⟩\n    rw [← IsScalarTower.algebraMap_apply, IsScalarTower.algebraMap_apply F E K, hz, ← hy, map_pow,\n      AlgHom.toRingHom_eq_coe, IsScalarTower.coe_toAlgHom]\n  have h := lift_sepDegree_mul_lift_sepDegree_of_isAlgebraic F E L\n  rw [IsPurelyInseparable.sepDegree_eq_one F E, Cardinal.lift_one, one_mul] at h\n  rw [Cardinal.lift_injective h, ← sepDegree_mul_sepDegree_of_isAlgebraic F M L,\n    IsPurelyInseparable.sepDegree_eq_one M L, mul_one]\n\n"}
{"name":"IntermediateField.sepDegree_adjoin_eq_of_isAlgebraic_of_isPurelyInseparable'","module":"Mathlib.FieldTheory.PurelyInseparable.Tower","initialProofState":"F : Type u\nE : Type v\ninst✝⁸ : Field F\ninst✝⁷ : Field E\ninst✝⁶ : Algebra F E\nK : Type w\ninst✝⁵ : Field K\ninst✝⁴ : Algebra F K\ninst✝³ : Algebra E K\ninst✝² : IsScalarTower F E K\nS : IntermediateField F K\ninst✝¹ : Algebra.IsAlgebraic F (Subtype fun x => Membership.mem S x)\ninst✝ : IsPurelyInseparable F E\n⊢ Eq (Field.sepDegree E (Subtype fun x => Membership.mem (IntermediateField.adjoin E ↑S) x)) (Field.sepDegree F (Subtype fun x => Membership.mem S x))","decl":"variable {F K} in\n/-- If `K / E / F` is a field extension tower, such that `E / F` is purely inseparable, then\nfor any intermediate field `S` of `K / F` such that `S / F` is algebraic, the `E(S) / E` and\n`S / F` have the same separable degree. -/\ntheorem IntermediateField.sepDegree_adjoin_eq_of_isAlgebraic_of_isPurelyInseparable'\n    (S : IntermediateField F K) [Algebra.IsAlgebraic F S] [IsPurelyInseparable F E] :\n    sepDegree E (adjoin E (S : Set K)) = sepDegree F S := by\n  have : Algebra.IsAlgebraic F (adjoin F (S : Set K)) := by rwa [adjoin_self]\n  have := sepDegree_adjoin_eq_of_isAlgebraic_of_isPurelyInseparable (F := F) E (S : Set K)\n  rwa [adjoin_self] at this\n\n"}
{"name":"minpoly.map_eq_of_isSeparable_of_isPurelyInseparable","module":"Mathlib.FieldTheory.PurelyInseparable.Tower","initialProofState":"F : Type u\nE : Type v\ninst✝⁷ : Field F\ninst✝⁶ : Field E\ninst✝⁵ : Algebra F E\nK : Type w\ninst✝⁴ : Field K\ninst✝³ : Algebra F K\ninst✝² : Algebra E K\ninst✝¹ : IsScalarTower F E K\nx : K\nhsep : IsSeparable F x\ninst✝ : IsPurelyInseparable F E\n⊢ Eq (Polynomial.map (algebraMap F E) (minpoly F x)) (minpoly E x)","decl":"variable {F K} in\n/-- If `K / E / F` is a field extension tower, such that `E / F` is purely inseparable, then\nfor any element `x` of `K` separable over `F`, it has the same minimal polynomials over `F` and\nover `E`. -/\ntheorem minpoly.map_eq_of_isSeparable_of_isPurelyInseparable (x : K)\n    (hsep : IsSeparable F x) [IsPurelyInseparable F E] :\n    (minpoly F x).map (algebraMap F E) = minpoly E x := by\n  have hi := IsSeparable.isIntegral hsep\n  have hi' : IsIntegral E x := IsIntegral.tower_top hi\n  refine eq_of_monic_of_dvd_of_natDegree_le (monic hi') ((monic hi).map (algebraMap F E))\n    (dvd_map_of_isScalarTower F E x) (le_of_eq ?_)\n  have hsep' := IsSeparable.tower_top E hsep\n  haveI := (isSeparable_adjoin_simple_iff_isSeparable _ _).2 hsep\n  haveI := (isSeparable_adjoin_simple_iff_isSeparable _ _).2 hsep'\n  have := Algebra.IsSeparable.isAlgebraic F F⟮x⟯\n  have := Algebra.IsSeparable.isAlgebraic E E⟮x⟯\n  rw [Polynomial.natDegree_map, ← adjoin.finrank hi, ← adjoin.finrank hi',\n    ← finSepDegree_eq_finrank_of_isSeparable F _, ← finSepDegree_eq_finrank_of_isSeparable E _,\n    finSepDegree_eq, finSepDegree_eq,\n    sepDegree_adjoin_eq_of_isAlgebraic_of_isPurelyInseparable (F := F) E]\n\n"}
{"name":"Polynomial.Separable.map_irreducible_of_isPurelyInseparable","module":"Mathlib.FieldTheory.PurelyInseparable.Tower","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\nf : Polynomial F\nhsep : f.Separable\nhirr : Irreducible f\ninst✝ : IsPurelyInseparable F E\n⊢ Irreducible (Polynomial.map (algebraMap F E) f)","decl":"variable {F} in\n/-- If `E / F` is a purely inseparable field extension, `f` is a separable irreducible polynomial\nover `F`, then it is also irreducible over `E`. -/\ntheorem Polynomial.Separable.map_irreducible_of_isPurelyInseparable {f : F[X]} (hsep : f.Separable)\n    (hirr : Irreducible f) [IsPurelyInseparable F E] : Irreducible (f.map (algebraMap F E)) := by\n  let K := AlgebraicClosure E\n  obtain ⟨x, hx⟩ := IsAlgClosed.exists_aeval_eq_zero K f\n    (natDegree_pos_iff_degree_pos.1 hirr.natDegree_pos).ne'\n  have ha : Associated f (minpoly F x) := by\n    have := isUnit_C.2 (leadingCoeff_ne_zero.2 hirr.ne_zero).isUnit.inv\n    exact ⟨this.unit, by rw [IsUnit.unit_spec, minpoly.eq_of_irreducible hirr hx]⟩\n  have ha' : Associated (f.map (algebraMap F E)) ((minpoly F x).map (algebraMap F E)) :=\n    ha.map (mapRingHom (algebraMap F E)).toMonoidHom\n  have heq := minpoly.map_eq_of_isSeparable_of_isPurelyInseparable E x (ha.separable hsep)\n  rw [ha'.irreducible_iff, heq]\n  exact minpoly.irreducible (Algebra.IsIntegral.isIntegral x)\n\n"}
