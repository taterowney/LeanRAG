{"name":"IsLocallyConstant.tfae","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù : TopologicalSpace X\nf : X ‚Üí Y\n‚ä¢ (List.cons (IsLocallyConstant f) (List.cons (‚àÄ (x : X), Filter.Eventually (fun x' => Eq (f x') (f x)) (nhds x)) (List.cons (‚àÄ (x : X), IsOpen (setOf fun x' => Eq (f x') (f x))) (List.cons (‚àÄ (y : Y), IsOpen (Set.preimage f (Singleton.singleton y))) (List.cons (‚àÄ (x : X), Exists fun U => And (IsOpen U) (And (Membership.mem U x) (‚àÄ (x' : X), Membership.mem U x' ‚Üí Eq (f x') (f x)))) List.nil))))).TFAE","decl":"open List in\nprotected theorem tfae (f : X ‚Üí Y) :\n    TFAE [IsLocallyConstant f,\n      ‚àÄ x, ‚àÄ·∂† x' in ùìù x, f x' = f x,\n      ‚àÄ x, IsOpen { x' | f x' = f x },\n      ‚àÄ y, IsOpen (f ‚Åª¬π' {y}),\n      ‚àÄ x, ‚àÉ U : Set X, IsOpen U ‚àß x ‚àà U ‚àß ‚àÄ x' ‚àà U, f x' = f x] := by\n  tfae_have 1 ‚Üí 4 := fun h y => h {y}\n  tfae_have 4 ‚Üí 3 := fun h x => h (f x)\n  tfae_have 3 ‚Üí 2 := fun h x => IsOpen.mem_nhds (h x) rfl\n  tfae_have 2 ‚Üí 5\n  | h, x => by\n    rcases mem_nhds_iff.1 (h x) with ‚ü®U, eq, hU, hx‚ü©\n    exact ‚ü®U, hU, hx, eq‚ü©\n  tfae_have 5 ‚Üí 1\n  | h, s => by\n    refine isOpen_iff_forall_mem_open.2 fun x hx ‚Ü¶ ?_\n    rcases h x with ‚ü®U, hU, hxU, eq‚ü©\n    exact ‚ü®U, fun x' hx' => mem_preimage.2 <| (eq x' hx').symm ‚ñ∏ hx, hU, hxU‚ü©\n  tfae_finish\n\n"}
{"name":"IsLocallyConstant.of_discrete","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : DiscreteTopology X\nf : X ‚Üí Y\n‚ä¢ IsLocallyConstant f","decl":"@[nontriviality]\ntheorem of_discrete [DiscreteTopology X] (f : X ‚Üí Y) : IsLocallyConstant f := fun _ =>\n  isOpen_discrete _\n\n"}
{"name":"IsLocallyConstant.isOpen_fiber","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù : TopologicalSpace X\nf : X ‚Üí Y\nhf : IsLocallyConstant f\ny : Y\n‚ä¢ IsOpen (setOf fun x => Eq (f x) y)","decl":"theorem isOpen_fiber {f : X ‚Üí Y} (hf : IsLocallyConstant f) (y : Y) : IsOpen { x | f x = y } :=\n  hf {y}\n\n"}
{"name":"IsLocallyConstant.isClosed_fiber","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù : TopologicalSpace X\nf : X ‚Üí Y\nhf : IsLocallyConstant f\ny : Y\n‚ä¢ IsClosed (setOf fun x => Eq (f x) y)","decl":"theorem isClosed_fiber {f : X ‚Üí Y} (hf : IsLocallyConstant f) (y : Y) : IsClosed { x | f x = y } :=\n  ‚ü®hf {y}·∂ú‚ü©\n\n"}
{"name":"IsLocallyConstant.isClopen_fiber","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù : TopologicalSpace X\nf : X ‚Üí Y\nhf : IsLocallyConstant f\ny : Y\n‚ä¢ IsClopen (setOf fun x => Eq (f x) y)","decl":"theorem isClopen_fiber {f : X ‚Üí Y} (hf : IsLocallyConstant f) (y : Y) : IsClopen { x | f x = y } :=\n  ‚ü®isClosed_fiber hf _,  isOpen_fiber hf _‚ü©\n\n"}
{"name":"IsLocallyConstant.iff_exists_open","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù : TopologicalSpace X\nf : X ‚Üí Y\n‚ä¢ Iff (IsLocallyConstant f) (‚àÄ (x : X), Exists fun U => And (IsOpen U) (And (Membership.mem U x) (‚àÄ (x' : X), Membership.mem U x' ‚Üí Eq (f x') (f x))))","decl":"theorem iff_exists_open (f : X ‚Üí Y) :\n    IsLocallyConstant f ‚Üî ‚àÄ x, ‚àÉ U : Set X, IsOpen U ‚àß x ‚àà U ‚àß ‚àÄ x' ‚àà U, f x' = f x :=\n  (IsLocallyConstant.tfae f).out 0 4\n\n"}
{"name":"IsLocallyConstant.iff_eventually_eq","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù : TopologicalSpace X\nf : X ‚Üí Y\n‚ä¢ Iff (IsLocallyConstant f) (‚àÄ (x : X), Filter.Eventually (fun y => Eq (f y) (f x)) (nhds x))","decl":"theorem iff_eventually_eq (f : X ‚Üí Y) : IsLocallyConstant f ‚Üî ‚àÄ x, ‚àÄ·∂† y in ùìù x, f y = f x :=\n  (IsLocallyConstant.tfae f).out 0 1\n\n"}
{"name":"IsLocallyConstant.exists_open","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù : TopologicalSpace X\nf : X ‚Üí Y\nhf : IsLocallyConstant f\nx : X\n‚ä¢ Exists fun U => And (IsOpen U) (And (Membership.mem U x) (‚àÄ (x' : X), Membership.mem U x' ‚Üí Eq (f x') (f x)))","decl":"theorem exists_open {f : X ‚Üí Y} (hf : IsLocallyConstant f) (x : X) :\n    ‚àÉ U : Set X, IsOpen U ‚àß x ‚àà U ‚àß ‚àÄ x' ‚àà U, f x' = f x :=\n  (iff_exists_open f).1 hf x\n\n"}
{"name":"IsLocallyConstant.eventually_eq","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù : TopologicalSpace X\nf : X ‚Üí Y\nhf : IsLocallyConstant f\nx : X\n‚ä¢ Filter.Eventually (fun y => Eq (f y) (f x)) (nhds x)","decl":"protected theorem eventually_eq {f : X ‚Üí Y} (hf : IsLocallyConstant f) (x : X) :\n    ‚àÄ·∂† y in ùìù x, f y = f x :=\n  (iff_eventually_eq f).1 hf x\n\n"}
{"name":"IsLocallyConstant.iff_isOpen_fiber_apply","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù : TopologicalSpace X\nf : X ‚Üí Y\n‚ä¢ Iff (IsLocallyConstant f) (‚àÄ (x : X), IsOpen (Set.preimage f (Singleton.singleton (f x))))","decl":"theorem iff_isOpen_fiber_apply {f : X ‚Üí Y} : IsLocallyConstant f ‚Üî ‚àÄ x, IsOpen (f ‚Åª¬π' {f x}) :=\n  (IsLocallyConstant.tfae f).out 0 2\n\n"}
{"name":"IsLocallyConstant.iff_isOpen_fiber","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù : TopologicalSpace X\nf : X ‚Üí Y\n‚ä¢ Iff (IsLocallyConstant f) (‚àÄ (y : Y), IsOpen (Set.preimage f (Singleton.singleton y)))","decl":"theorem iff_isOpen_fiber {f : X ‚Üí Y} : IsLocallyConstant f ‚Üî ‚àÄ y, IsOpen (f ‚Åª¬π' {y}) :=\n  (IsLocallyConstant.tfae f).out 0 3\n\n"}
{"name":"IsLocallyConstant.continuous","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\nhf : IsLocallyConstant f\n‚ä¢ Continuous f","decl":"protected theorem continuous [TopologicalSpace Y] {f : X ‚Üí Y} (hf : IsLocallyConstant f) :\n    Continuous f :=\n  ‚ü®fun _ _ => hf _‚ü©\n\n"}
{"name":"IsLocallyConstant.iff_continuous","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\nx‚úù : TopologicalSpace Y\ninst‚úù : DiscreteTopology Y\nf : X ‚Üí Y\n‚ä¢ Iff (IsLocallyConstant f) (Continuous f)","decl":"theorem iff_continuous {_ : TopologicalSpace Y} [DiscreteTopology Y] (f : X ‚Üí Y) :\n    IsLocallyConstant f ‚Üî Continuous f :=\n  ‚ü®IsLocallyConstant.continuous, fun h s => h.isOpen_preimage s (isOpen_discrete _)‚ü©\n\n"}
{"name":"IsLocallyConstant.of_constant","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù : TopologicalSpace X\nf : X ‚Üí Y\nh : ‚àÄ (x y : X), Eq (f x) (f y)\n‚ä¢ IsLocallyConstant f","decl":"theorem of_constant (f : X ‚Üí Y) (h : ‚àÄ x y, f x = f y) : IsLocallyConstant f :=\n  (iff_eventually_eq f).2 fun _ => Eventually.of_forall fun _ => h _ _\n\n"}
{"name":"IsLocallyConstant.const","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù : TopologicalSpace X\ny : Y\n‚ä¢ IsLocallyConstant (Function.const X y)","decl":"protected theorem const (y : Y) : IsLocallyConstant (Function.const X y) :=\n  of_constant _ fun _ _ => rfl\n\n"}
{"name":"IsLocallyConstant.comp","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst‚úù : TopologicalSpace X\nf : X ‚Üí Y\nhf : IsLocallyConstant f\ng : Y ‚Üí Z\n‚ä¢ IsLocallyConstant (Function.comp g f)","decl":"protected theorem comp {f : X ‚Üí Y} (hf : IsLocallyConstant f) (g : Y ‚Üí Z) :\n    IsLocallyConstant (g ‚àò f) := fun s => by\n  rw [Set.preimage_comp]\n  exact hf _\n\n"}
{"name":"IsLocallyConstant.prod_mk","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù : TopologicalSpace X\nY' : Type u_5\nf : X ‚Üí Y\nf' : X ‚Üí Y'\nhf : IsLocallyConstant f\nhf' : IsLocallyConstant f'\n‚ä¢ IsLocallyConstant fun x => { fst := f x, snd := f' x }","decl":"theorem prod_mk {Y'} {f : X ‚Üí Y} {f' : X ‚Üí Y'} (hf : IsLocallyConstant f)\n    (hf' : IsLocallyConstant f') : IsLocallyConstant fun x => (f x, f' x) :=\n  (iff_eventually_eq _).2 fun x =>\n    (hf.eventually_eq x).mp <| (hf'.eventually_eq x).mono fun _ hf' hf => Prod.ext hf hf'\n\n"}
{"name":"IsLocallyConstant.comp‚ÇÇ","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nY‚ÇÅ : Type u_5\nY‚ÇÇ : Type u_6\nZ : Type u_7\nf : X ‚Üí Y‚ÇÅ\ng : X ‚Üí Y‚ÇÇ\nhf : IsLocallyConstant f\nhg : IsLocallyConstant g\nh : Y‚ÇÅ ‚Üí Y‚ÇÇ ‚Üí Z\n‚ä¢ IsLocallyConstant fun x => h (f x) (g x)","decl":"theorem comp‚ÇÇ {Y‚ÇÅ Y‚ÇÇ Z : Type*} {f : X ‚Üí Y‚ÇÅ} {g : X ‚Üí Y‚ÇÇ} (hf : IsLocallyConstant f)\n    (hg : IsLocallyConstant g) (h : Y‚ÇÅ ‚Üí Y‚ÇÇ ‚Üí Z) : IsLocallyConstant fun x => h (f x) (g x) :=\n  (hf.prod_mk hg).comp fun x : Y‚ÇÅ √ó Y‚ÇÇ => h x.1 x.2\n\n"}
{"name":"IsLocallyConstant.comp_continuous","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\ng : Y ‚Üí Z\nf : X ‚Üí Y\nhg : IsLocallyConstant g\nhf : Continuous f\n‚ä¢ IsLocallyConstant (Function.comp g f)","decl":"theorem comp_continuous [TopologicalSpace Y] {g : Y ‚Üí Z} {f : X ‚Üí Y} (hg : IsLocallyConstant g)\n    (hf : Continuous f) : IsLocallyConstant (g ‚àò f) := fun s => by\n  rw [Set.preimage_comp]\n  exact hf.isOpen_preimage _ (hg _)\n\n"}
{"name":"IsLocallyConstant.apply_eq_of_isPreconnected","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù : TopologicalSpace X\nf : X ‚Üí Y\nhf : IsLocallyConstant f\ns : Set X\nhs : IsPreconnected s\nx y : X\nhx : Membership.mem s x\nhy : Membership.mem s y\n‚ä¢ Eq (f x) (f y)","decl":"/-- A locally constant function is constant on any preconnected set. -/\ntheorem apply_eq_of_isPreconnected {f : X ‚Üí Y} (hf : IsLocallyConstant f) {s : Set X}\n    (hs : IsPreconnected s) {x y : X} (hx : x ‚àà s) (hy : y ‚àà s) : f x = f y := by\n  let U := f ‚Åª¬π' {f y}\n  suffices x ‚àâ U·∂ú from Classical.not_not.1 this\n  intro hxV\n  specialize hs U U·∂ú (hf {f y}) (hf {f y}·∂ú) _ ‚ü®y, ‚ü®hy, rfl‚ü©‚ü© ‚ü®x, ‚ü®hx, hxV‚ü©‚ü©\n  ¬∑ simp only [union_compl_self, subset_univ]\n  ¬∑ simp only [inter_empty, Set.not_nonempty_empty, inter_compl_self] at hs\n\n"}
{"name":"IsLocallyConstant.apply_eq_of_preconnectedSpace","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : PreconnectedSpace X\nf : X ‚Üí Y\nhf : IsLocallyConstant f\nx y : X\n‚ä¢ Eq (f x) (f y)","decl":"theorem apply_eq_of_preconnectedSpace [PreconnectedSpace X] {f : X ‚Üí Y} (hf : IsLocallyConstant f)\n    (x y : X) : f x = f y :=\n  hf.apply_eq_of_isPreconnected isPreconnected_univ trivial trivial\n\n"}
{"name":"IsLocallyConstant.eq_const","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : PreconnectedSpace X\nf : X ‚Üí Y\nhf : IsLocallyConstant f\nx : X\n‚ä¢ Eq f (Function.const X (f x))","decl":"theorem eq_const [PreconnectedSpace X] {f : X ‚Üí Y} (hf : IsLocallyConstant f) (x : X) :\n    f = Function.const X (f x) :=\n  funext fun y => hf.apply_eq_of_preconnectedSpace y x\n\n"}
{"name":"IsLocallyConstant.exists_eq_const","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : PreconnectedSpace X\ninst‚úù : Nonempty Y\nf : X ‚Üí Y\nhf : IsLocallyConstant f\n‚ä¢ Exists fun y => Eq f (Function.const X y)","decl":"theorem exists_eq_const [PreconnectedSpace X] [Nonempty Y] {f : X ‚Üí Y} (hf : IsLocallyConstant f) :\n    ‚àÉ y, f = Function.const X y := by\n  cases' isEmpty_or_nonempty X with h h\n  ¬∑ exact ‚ü®Classical.arbitrary Y, funext <| h.elim‚ü©\n  ¬∑ exact ‚ü®f (Classical.arbitrary X), hf.eq_const _‚ü©\n\n"}
{"name":"IsLocallyConstant.iff_is_const","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : PreconnectedSpace X\nf : X ‚Üí Y\n‚ä¢ Iff (IsLocallyConstant f) (‚àÄ (x y : X), Eq (f x) (f y))","decl":"theorem iff_is_const [PreconnectedSpace X] {f : X ‚Üí Y} : IsLocallyConstant f ‚Üî ‚àÄ x y, f x = f y :=\n  ‚ü®fun h _ _ => h.apply_eq_of_isPreconnected isPreconnected_univ trivial trivial, of_constant _‚ü©\n\n"}
{"name":"IsLocallyConstant.range_finite","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : CompactSpace X\nf : X ‚Üí Y\nhf : IsLocallyConstant f\n‚ä¢ (Set.range f).Finite","decl":"theorem range_finite [CompactSpace X] {f : X ‚Üí Y} (hf : IsLocallyConstant f) :\n    (Set.range f).Finite := by\n  letI : TopologicalSpace Y := ‚ä•; haveI := discreteTopology_bot Y\n  exact (isCompact_range hf.continuous).finite_of_discrete\n\n"}
{"name":"IsLocallyConstant.zero","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : Zero Y\n‚ä¢ IsLocallyConstant 0","decl":"@[to_additive]\ntheorem one [One Y] : IsLocallyConstant (1 : X ‚Üí Y) := IsLocallyConstant.const 1\n\n"}
{"name":"IsLocallyConstant.one","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : One Y\n‚ä¢ IsLocallyConstant 1","decl":"@[to_additive]\ntheorem one [One Y] : IsLocallyConstant (1 : X ‚Üí Y) := IsLocallyConstant.const 1\n\n"}
{"name":"IsLocallyConstant.inv","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : Inv Y\nf : X ‚Üí Y\nhf : IsLocallyConstant f\n‚ä¢ IsLocallyConstant (Inv.inv f)","decl":"@[to_additive]\ntheorem inv [Inv Y] ‚¶Éf : X ‚Üí Y‚¶Ñ (hf : IsLocallyConstant f) : IsLocallyConstant f‚Åª¬π :=\n  hf.comp fun x => x‚Åª¬π\n\n"}
{"name":"IsLocallyConstant.neg","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : Neg Y\nf : X ‚Üí Y\nhf : IsLocallyConstant f\n‚ä¢ IsLocallyConstant (Neg.neg f)","decl":"@[to_additive]\ntheorem inv [Inv Y] ‚¶Éf : X ‚Üí Y‚¶Ñ (hf : IsLocallyConstant f) : IsLocallyConstant f‚Åª¬π :=\n  hf.comp fun x => x‚Åª¬π\n\n"}
{"name":"IsLocallyConstant.add","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : Add Y\nf g : X ‚Üí Y\nhf : IsLocallyConstant f\nhg : IsLocallyConstant g\n‚ä¢ IsLocallyConstant (HAdd.hAdd f g)","decl":"@[to_additive]\ntheorem mul [Mul Y] ‚¶Éf g : X ‚Üí Y‚¶Ñ (hf : IsLocallyConstant f) (hg : IsLocallyConstant g) :\n    IsLocallyConstant (f * g) :=\n  hf.comp‚ÇÇ hg (¬∑ * ¬∑)\n\n"}
{"name":"IsLocallyConstant.mul","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : Mul Y\nf g : X ‚Üí Y\nhf : IsLocallyConstant f\nhg : IsLocallyConstant g\n‚ä¢ IsLocallyConstant (HMul.hMul f g)","decl":"@[to_additive]\ntheorem mul [Mul Y] ‚¶Éf g : X ‚Üí Y‚¶Ñ (hf : IsLocallyConstant f) (hg : IsLocallyConstant g) :\n    IsLocallyConstant (f * g) :=\n  hf.comp‚ÇÇ hg (¬∑ * ¬∑)\n\n"}
{"name":"IsLocallyConstant.div","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : Div Y\nf g : X ‚Üí Y\nhf : IsLocallyConstant f\nhg : IsLocallyConstant g\n‚ä¢ IsLocallyConstant (HDiv.hDiv f g)","decl":"@[to_additive]\ntheorem div [Div Y] ‚¶Éf g : X ‚Üí Y‚¶Ñ (hf : IsLocallyConstant f) (hg : IsLocallyConstant g) :\n    IsLocallyConstant (f / g) :=\n  hf.comp‚ÇÇ hg (¬∑ / ¬∑)\n\n"}
{"name":"IsLocallyConstant.sub","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : Sub Y\nf g : X ‚Üí Y\nhf : IsLocallyConstant f\nhg : IsLocallyConstant g\n‚ä¢ IsLocallyConstant (HSub.hSub f g)","decl":"@[to_additive]\ntheorem div [Div Y] ‚¶Éf g : X ‚Üí Y‚¶Ñ (hf : IsLocallyConstant f) (hg : IsLocallyConstant g) :\n    IsLocallyConstant (f / g) :=\n  hf.comp‚ÇÇ hg (¬∑ / ¬∑)\n\n"}
{"name":"IsLocallyConstant.desc","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nŒ± : Type u_5\nŒ≤ : Type u_6\nf : X ‚Üí Œ±\ng : Œ± ‚Üí Œ≤\nh : IsLocallyConstant (Function.comp g f)\ninj : Function.Injective g\n‚ä¢ IsLocallyConstant f","decl":"/-- If a composition of a function `f` followed by an injection `g` is locally\nconstant, then the locally constant property descends to `f`. -/\ntheorem desc {Œ± Œ≤ : Type*} (f : X ‚Üí Œ±) (g : Œ± ‚Üí Œ≤) (h : IsLocallyConstant (g ‚àò f))\n    (inj : Function.Injective g) : IsLocallyConstant f := fun s => by\n  rw [‚Üê preimage_image_eq s inj, preimage_preimage]\n  exact h (g '' s)\n\n"}
{"name":"IsLocallyConstant.of_constant_on_connected_components","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : LocallyConnectedSpace X\nf : X ‚Üí Y\nh : ‚àÄ (x y : X), Membership.mem (connectedComponent x) y ‚Üí Eq (f y) (f x)\n‚ä¢ IsLocallyConstant f","decl":"theorem of_constant_on_connected_components [LocallyConnectedSpace X] {f : X ‚Üí Y}\n    (h : ‚àÄ x, ‚àÄ y ‚àà connectedComponent x, f y = f x) : IsLocallyConstant f :=\n  (iff_exists_open _).2 fun x =>\n    ‚ü®connectedComponent x, isOpen_connectedComponent, mem_connectedComponent, h x‚ü©\n\n"}
{"name":"IsLocallyConstant.of_constant_on_connected_clopens","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : LocallyConnectedSpace X\nf : X ‚Üí Y\nh : ‚àÄ (U : Set X), IsConnected U ‚Üí IsClopen U ‚Üí ‚àÄ (x : X), Membership.mem U x ‚Üí ‚àÄ (y : X), Membership.mem U y ‚Üí Eq (f y) (f x)\n‚ä¢ IsLocallyConstant f","decl":"theorem of_constant_on_connected_clopens [LocallyConnectedSpace X] {f : X ‚Üí Y}\n    (h : ‚àÄ U : Set X, IsConnected U ‚Üí IsClopen U ‚Üí ‚àÄ x ‚àà U, ‚àÄ y ‚àà U, f y = f x) :\n    IsLocallyConstant f :=\n  of_constant_on_connected_components fun x =>\n    h (connectedComponent x) isConnected_connectedComponent isClopen_connectedComponent x\n      mem_connectedComponent\n\n"}
{"name":"IsLocallyConstant.of_constant_on_preconnected_clopens","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : LocallyConnectedSpace X\nf : X ‚Üí Y\nh : ‚àÄ (U : Set X), IsPreconnected U ‚Üí IsClopen U ‚Üí ‚àÄ (x : X), Membership.mem U x ‚Üí ‚àÄ (y : X), Membership.mem U y ‚Üí Eq (f y) (f x)\n‚ä¢ IsLocallyConstant f","decl":"theorem of_constant_on_preconnected_clopens [LocallyConnectedSpace X] {f : X ‚Üí Y}\n    (h : ‚àÄ U : Set X, IsPreconnected U ‚Üí IsClopen U ‚Üí ‚àÄ x ‚àà U, ‚àÄ y ‚àà U, f y = f x) :\n    IsLocallyConstant f :=\n  of_constant_on_connected_clopens fun U hU ‚Ü¶ h U hU.isPreconnected\n\n"}
{"name":"LocallyConstant.mk.injEq","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_5\nY : Type u_6\ninst‚úù : TopologicalSpace X\ntoFun‚úù : X ‚Üí Y\nisLocallyConstant‚úù : IsLocallyConstant toFun‚úù\ntoFun : X ‚Üí Y\nisLocallyConstant : IsLocallyConstant toFun\n‚ä¢ Eq (Eq { toFun := toFun‚úù, isLocallyConstant := isLocallyConstant‚úù } { toFun := toFun, isLocallyConstant := isLocallyConstant }) (Eq toFun‚úù toFun)","decl":"/-- A (bundled) locally constant function from a topological space `X` to a type `Y`. -/\nstructure LocallyConstant (X Y : Type*) [TopologicalSpace X] where\n  /-- The underlying function. -/\n  protected toFun : X ‚Üí Y\n  /-- The map is locally constant. -/\n  protected isLocallyConstant : IsLocallyConstant toFun\n\n"}
{"name":"LocallyConstant.mk.inj","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_5\nY : Type u_6\ninst‚úù : TopologicalSpace X\ntoFun‚úù : X ‚Üí Y\nisLocallyConstant‚úù : IsLocallyConstant toFun‚úù\ntoFun : X ‚Üí Y\nisLocallyConstant : IsLocallyConstant toFun\nx‚úù : Eq { toFun := toFun‚úù, isLocallyConstant := isLocallyConstant‚úù } { toFun := toFun, isLocallyConstant := isLocallyConstant }\n‚ä¢ Eq toFun‚úù toFun","decl":"/-- A (bundled) locally constant function from a topological space `X` to a type `Y`. -/\nstructure LocallyConstant (X Y : Type*) [TopologicalSpace X] where\n  /-- The underlying function. -/\n  protected toFun : X ‚Üí Y\n  /-- The map is locally constant. -/\n  protected isLocallyConstant : IsLocallyConstant toFun\n\n"}
{"name":"LocallyConstant.mk.sizeOf_spec","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_5\nY : Type u_6\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : SizeOf X\ninst‚úù : SizeOf Y\ntoFun : X ‚Üí Y\nisLocallyConstant : IsLocallyConstant toFun\n‚ä¢ Eq (SizeOf.sizeOf { toFun := toFun, isLocallyConstant := isLocallyConstant }) 1","decl":"/-- A (bundled) locally constant function from a topological space `X` to a type `Y`. -/\nstructure LocallyConstant (X Y : Type*) [TopologicalSpace X] where\n  /-- The underlying function. -/\n  protected toFun : X ‚Üí Y\n  /-- The map is locally constant. -/\n  protected isLocallyConstant : IsLocallyConstant toFun\n\n"}
{"name":"LocallyConstant.isLocallyConstant","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_5\nY : Type u_6\ninst‚úù : TopologicalSpace X\nself : LocallyConstant X Y\n‚ä¢ IsLocallyConstant self.toFun","decl":"/-- A (bundled) locally constant function from a topological space `X` to a type `Y`. -/\nstructure LocallyConstant (X Y : Type*) [TopologicalSpace X] where\n  /-- The underlying function. -/\n  protected toFun : X ‚Üí Y\n  /-- The map is locally constant. -/\n  protected isLocallyConstant : IsLocallyConstant toFun\n\n"}
{"name":"LocallyConstant.toFun_eq_coe","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù : TopologicalSpace X\nf : LocallyConstant X Y\n‚ä¢ Eq f.toFun ‚áëf","decl":"@[simp]\ntheorem toFun_eq_coe (f : LocallyConstant X Y) : f.toFun = f :=\n  rfl\n\n"}
{"name":"LocallyConstant.coe_mk","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù : TopologicalSpace X\nf : X ‚Üí Y\nh : IsLocallyConstant f\n‚ä¢ Eq (‚áë{ toFun := f, isLocallyConstant := h }) f","decl":"@[simp]\ntheorem coe_mk (f : X ‚Üí Y) (h) : ‚áë(‚ü®f, h‚ü© : LocallyConstant X Y) = f :=\n  rfl\n\n"}
{"name":"LocallyConstant.congr_fun","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù : TopologicalSpace X\nf g : LocallyConstant X Y\nh : Eq f g\nx : X\n‚ä¢ Eq (f x) (g x)","decl":"protected theorem congr_fun {f g : LocallyConstant X Y} (h : f = g) (x : X) : f x = g x :=\n  DFunLike.congr_fun h x\n\n"}
{"name":"LocallyConstant.congr_arg","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù : TopologicalSpace X\nf : LocallyConstant X Y\nx y : X\nh : Eq x y\n‚ä¢ Eq (f x) (f y)","decl":"protected theorem congr_arg (f : LocallyConstant X Y) {x y : X} (h : x = y) : f x = f y :=\n  DFunLike.congr_arg f h\n\n"}
{"name":"LocallyConstant.coe_injective","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù : TopologicalSpace X\n‚ä¢ Function.Injective DFunLike.coe","decl":"theorem coe_injective : @Function.Injective (LocallyConstant X Y) (X ‚Üí Y) (‚Üë) := fun _ _ =>\n  DFunLike.ext'\n\n"}
{"name":"LocallyConstant.coe_inj","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù : TopologicalSpace X\nf g : LocallyConstant X Y\n‚ä¢ Iff (Eq ‚áëf ‚áëg) (Eq f g)","decl":"@[norm_cast]\ntheorem coe_inj {f g : LocallyConstant X Y} : (f : X ‚Üí Y) = g ‚Üî f = g :=\n  coe_injective.eq_iff\n\n"}
{"name":"LocallyConstant.ext_iff","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù : TopologicalSpace X\nf g : LocallyConstant X Y\n‚ä¢ Iff (Eq f g) (‚àÄ (x : X), Eq (f x) (g x))","decl":"@[ext]\ntheorem ext ‚¶Éf g : LocallyConstant X Y‚¶Ñ (h : ‚àÄ x, f x = g x) : f = g :=\n  DFunLike.ext _ _ h\n\n"}
{"name":"LocallyConstant.ext","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù : TopologicalSpace X\nf g : LocallyConstant X Y\nh : ‚àÄ (x : X), Eq (f x) (g x)\n‚ä¢ Eq f g","decl":"@[ext]\ntheorem ext ‚¶Éf g : LocallyConstant X Y‚¶Ñ (h : ‚àÄ x, f x = g x) : f = g :=\n  DFunLike.ext _ _ h\n\n"}
{"name":"LocallyConstant.continuous","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : LocallyConstant X Y\n‚ä¢ Continuous ‚áëf","decl":"protected theorem continuous : Continuous f :=\n  f.isLocallyConstant.continuous\n\n"}
{"name":"LocallyConstant.coe_continuousMap","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : LocallyConstant X Y\n‚ä¢ Eq ‚áë‚Üëf ‚áëf","decl":"@[simp] theorem coe_continuousMap : ((f : C(X, Y)) : X ‚Üí Y) = (f : X ‚Üí Y) := rfl\n\n"}
{"name":"LocallyConstant.toContinuousMap_injective","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\n‚ä¢ Function.Injective LocallyConstant.toContinuousMap","decl":"theorem toContinuousMap_injective :\n    Function.Injective (toContinuousMap : LocallyConstant X Y ‚Üí C(X, Y)) := fun _ _ h =>\n  ext (ContinuousMap.congr_fun h)\n\n"}
{"name":"LocallyConstant.coe_const","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù : TopologicalSpace X\ny : Y\n‚ä¢ Eq (‚áë(LocallyConstant.const X y)) (Function.const X y)","decl":"@[simp]\ntheorem coe_const (y : Y) : (const X y : X ‚Üí Y) = Function.const X y :=\n  rfl\n\n"}
{"name":"LocallyConstant.ofIsClopen_fiber_zero","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_5\ninst‚úù¬π : TopologicalSpace X\nU : Set X\ninst‚úù : (x : X) ‚Üí Decidable (Membership.mem U x)\nhU : IsClopen U\n‚ä¢ Eq (Set.preimage (‚áë(LocallyConstant.ofIsClopen hU)) (Singleton.singleton 0)) U","decl":"@[simp]\ntheorem ofIsClopen_fiber_zero {X : Type*} [TopologicalSpace X] {U : Set X} [‚àÄ x, Decidable (x ‚àà U)]\n    (hU : IsClopen U) : ofIsClopen hU ‚Åª¬π' ({0} : Set (Fin 2)) = U := by\n  ext\n  simp only [ofIsClopen, mem_singleton_iff, Fin.one_eq_zero_iff, coe_mk, mem_preimage,\n    ite_eq_left_iff, Nat.succ_succ_ne_one]\n  tauto\n\n"}
{"name":"LocallyConstant.ofIsClopen_fiber_one","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_5\ninst‚úù¬π : TopologicalSpace X\nU : Set X\ninst‚úù : (x : X) ‚Üí Decidable (Membership.mem U x)\nhU : IsClopen U\n‚ä¢ Eq (Set.preimage (‚áë(LocallyConstant.ofIsClopen hU)) (Singleton.singleton 1)) (HasCompl.compl U)","decl":"@[simp]\ntheorem ofIsClopen_fiber_one {X : Type*} [TopologicalSpace X] {U : Set X} [‚àÄ x, Decidable (x ‚àà U)]\n    (hU : IsClopen U) : ofIsClopen hU ‚Åª¬π' ({1} : Set (Fin 2)) = U·∂ú := by\n  ext\n  simp only [ofIsClopen, mem_singleton_iff, coe_mk, Fin.zero_eq_one_iff, mem_preimage,\n    ite_eq_right_iff, mem_compl_iff, Nat.succ_succ_ne_one]\n\n"}
{"name":"LocallyConstant.locallyConstant_eq_of_fiber_zero_eq","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_5\ninst‚úù : TopologicalSpace X\nf g : LocallyConstant X (Fin 2)\nh : Eq (Set.preimage (‚áëf) (Singleton.singleton 0)) (Set.preimage (‚áëg) (Singleton.singleton 0))\n‚ä¢ Eq f g","decl":"theorem locallyConstant_eq_of_fiber_zero_eq {X : Type*} [TopologicalSpace X]\n    (f g : LocallyConstant X (Fin 2)) (h : f ‚Åª¬π' ({0} : Set (Fin 2)) = g ‚Åª¬π' {0}) : f = g := by\n  simp only [Set.ext_iff, mem_singleton_iff, mem_preimage] at h\n  ext1 x\n  exact Fin.fin_two_eq_of_eq_zero_iff (h x)\n\n"}
{"name":"LocallyConstant.range_finite","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : CompactSpace X\nf : LocallyConstant X Y\n‚ä¢ (Set.range ‚áëf).Finite","decl":"theorem range_finite [CompactSpace X] (f : LocallyConstant X Y) : (Set.range f).Finite :=\n  f.isLocallyConstant.range_finite\n\n"}
{"name":"LocallyConstant.apply_eq_of_isPreconnected","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù : TopologicalSpace X\nf : LocallyConstant X Y\ns : Set X\nhs : IsPreconnected s\nx y : X\nhx : Membership.mem s x\nhy : Membership.mem s y\n‚ä¢ Eq (f x) (f y)","decl":"theorem apply_eq_of_isPreconnected (f : LocallyConstant X Y) {s : Set X} (hs : IsPreconnected s)\n    {x y : X} (hx : x ‚àà s) (hy : y ‚àà s) : f x = f y :=\n  f.isLocallyConstant.apply_eq_of_isPreconnected hs hx hy\n\n"}
{"name":"LocallyConstant.apply_eq_of_preconnectedSpace","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : PreconnectedSpace X\nf : LocallyConstant X Y\nx y : X\n‚ä¢ Eq (f x) (f y)","decl":"theorem apply_eq_of_preconnectedSpace [PreconnectedSpace X] (f : LocallyConstant X Y) (x y : X) :\n    f x = f y :=\n  f.isLocallyConstant.apply_eq_of_isPreconnected isPreconnected_univ trivial trivial\n\n"}
{"name":"LocallyConstant.eq_const","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : PreconnectedSpace X\nf : LocallyConstant X Y\nx : X\n‚ä¢ Eq f (LocallyConstant.const X (f x))","decl":"theorem eq_const [PreconnectedSpace X] (f : LocallyConstant X Y) (x : X) : f = const X (f x) :=\n  ext fun _ => apply_eq_of_preconnectedSpace f _ _\n\n"}
{"name":"LocallyConstant.exists_eq_const","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : PreconnectedSpace X\ninst‚úù : Nonempty Y\nf : LocallyConstant X Y\n‚ä¢ Exists fun y => Eq f (LocallyConstant.const X y)","decl":"theorem exists_eq_const [PreconnectedSpace X] [Nonempty Y] (f : LocallyConstant X Y) :\n    ‚àÉ y, f = const X y := by\n  rcases Classical.em (Nonempty X) with (‚ü®‚ü®x‚ü©‚ü© | hX)\n  ¬∑ exact ‚ü®f x, f.eq_const x‚ü©\n  ¬∑ exact ‚ü®Classical.arbitrary Y, ext fun x => (hX ‚ü®x‚ü©).elim‚ü©\n\n"}
{"name":"LocallyConstant.map_apply","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst‚úù : TopologicalSpace X\nf : Y ‚Üí Z\ng : LocallyConstant X Y\n‚ä¢ Eq (‚áë(LocallyConstant.map f g)) (Function.comp f ‚áëg)","decl":"@[simp]\ntheorem map_apply (f : Y ‚Üí Z) (g : LocallyConstant X Y) : ‚áë(map f g) = f ‚àò g :=\n  rfl\n\n"}
{"name":"LocallyConstant.map_id","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù : TopologicalSpace X\n‚ä¢ Eq (LocallyConstant.map id) id","decl":"@[simp]\ntheorem map_id : @map X Y Y _ id = id := rfl\n\n"}
{"name":"LocallyConstant.map_comp","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nY‚ÇÅ : Type u_5\nY‚ÇÇ : Type u_6\nY‚ÇÉ : Type u_7\ng : Y‚ÇÇ ‚Üí Y‚ÇÉ\nf : Y‚ÇÅ ‚Üí Y‚ÇÇ\n‚ä¢ Eq (Function.comp (LocallyConstant.map g) (LocallyConstant.map f)) (LocallyConstant.map (Function.comp g f))","decl":"@[simp]\ntheorem map_comp {Y‚ÇÅ Y‚ÇÇ Y‚ÇÉ : Type*} (g : Y‚ÇÇ ‚Üí Y‚ÇÉ) (f : Y‚ÇÅ ‚Üí Y‚ÇÇ) :\n    @map X _ _ _ g ‚àò map f = map (g ‚àò f) := rfl\n\n"}
{"name":"LocallyConstant.unflip_flip","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_5\nŒ± : Type u_6\nŒ≤ : Type u_7\ninst‚úù¬π : Finite Œ±\ninst‚úù : TopologicalSpace X\nf : LocallyConstant X (Œ± ‚Üí Œ≤)\n‚ä¢ Eq (LocallyConstant.unflip f.flip) f","decl":"@[simp]\ntheorem unflip_flip {X Œ± Œ≤ : Type*} [Finite Œ±] [TopologicalSpace X]\n    (f : LocallyConstant X (Œ± ‚Üí Œ≤)) : unflip f.flip = f := rfl\n\n"}
{"name":"LocallyConstant.flip_unflip","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_5\nŒ± : Type u_6\nŒ≤ : Type u_7\ninst‚úù¬π : Finite Œ±\ninst‚úù : TopologicalSpace X\nf : Œ± ‚Üí LocallyConstant X Œ≤\n‚ä¢ Eq (LocallyConstant.unflip f).flip f","decl":"@[simp]\ntheorem flip_unflip {X Œ± Œ≤ : Type*} [Finite Œ±] [TopologicalSpace X]\n    (f : Œ± ‚Üí LocallyConstant X Œ≤) : (unflip f).flip = f := rfl\n\n"}
{"name":"LocallyConstant.coe_comap","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : ContinuousMap X Y\ng : LocallyConstant Y Z\n‚ä¢ Eq (‚áë(LocallyConstant.comap f g)) (Function.comp ‚áëg ‚áëf)","decl":"@[simp]\ntheorem coe_comap (f : C(X, Y)) (g : LocallyConstant Y Z) :\n    (comap f g) = g ‚àò f := rfl\n\n"}
{"name":"LocallyConstant.coe_comap_apply","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : ContinuousMap X Y\ng : LocallyConstant Y Z\nx : X\n‚ä¢ Eq ((LocallyConstant.comap f g) x) (g (f x))","decl":"theorem coe_comap_apply (f : C(X, Y)) (g : LocallyConstant Y Z) (x : X) :\n    comap f g x = g (f x) := rfl\n\n"}
{"name":"LocallyConstant.comap_id","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nZ : Type u_3\ninst‚úù : TopologicalSpace X\n‚ä¢ Eq (LocallyConstant.comap (ContinuousMap.id X)) id","decl":"@[simp]\ntheorem comap_id : comap (@ContinuousMap.id X _) = @id (LocallyConstant X Z) := rfl\n\n"}
{"name":"LocallyConstant.comap_comp","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\nW : Type u_5\ninst‚úù : TopologicalSpace W\nf : ContinuousMap W X\ng : ContinuousMap X Y\n‚ä¢ Eq (LocallyConstant.comap (g.comp f)) (Function.comp (LocallyConstant.comap f) (LocallyConstant.comap g))","decl":"theorem comap_comp {W : Type*} [TopologicalSpace W] (f : C(W, X)) (g : C(X, Y)) :\n    comap (Z := Z) (g.comp f) = comap f ‚àò comap g := rfl\n\n"}
{"name":"LocallyConstant.comap_comap","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\nW : Type u_5\ninst‚úù : TopologicalSpace W\nf : ContinuousMap W X\ng : ContinuousMap X Y\nx : LocallyConstant Y Z\n‚ä¢ Eq (LocallyConstant.comap f (LocallyConstant.comap g x)) (LocallyConstant.comap (g.comp f) x)","decl":"theorem comap_comap {W : Type*} [TopologicalSpace W] (f : C(W, X)) (g : C(X, Y))\n    (x : LocallyConstant Y Z) : comap f (comap g x) = comap (g.comp f) x := rfl\n\n"}
{"name":"LocallyConstant.comap_const","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : ContinuousMap X Y\ny : Y\nh : ‚àÄ (x : X), Eq (f x) y\n‚ä¢ Eq (LocallyConstant.comap f) fun g => LocallyConstant.const X (g y)","decl":"theorem comap_const (f : C(X, Y)) (y : Y) (h : ‚àÄ x, f x = y) :\n    (comap f : LocallyConstant Y Z ‚Üí LocallyConstant X Z) = fun g => const X (g y) := by\n  ext; simp [h]\n\n"}
{"name":"LocallyConstant.comap_injective","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : ContinuousMap X Y\nhfs : Function.Surjective f.toFun\n‚ä¢ Function.Injective (LocallyConstant.comap f)","decl":"lemma comap_injective (f : C(X, Y)) (hfs : f.1.Surjective) :\n    (comap (Z := Z) f).Injective := by\n  intro a b h\n  ext y\n  obtain ‚ü®x, hx‚ü© := hfs y\n  simpa [‚Üê hx] using LocallyConstant.congr_fun h x\n\n"}
{"name":"LocallyConstant.coe_desc","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_5\nŒ± : Type u_6\nŒ≤ : Type u_7\ninst‚úù : TopologicalSpace X\nf : X ‚Üí Œ±\ng : Œ± ‚Üí Œ≤\nh : LocallyConstant X Œ≤\ncond : Eq (Function.comp g f) ‚áëh\ninj : Function.Injective g\n‚ä¢ Eq (‚áë(LocallyConstant.desc f h cond inj)) f","decl":"@[simp]\ntheorem coe_desc {X Œ± Œ≤ : Type*} [TopologicalSpace X] (f : X ‚Üí Œ±) (g : Œ± ‚Üí Œ≤)\n    (h : LocallyConstant X Œ≤) (cond : g ‚àò f = h) (inj : Function.Injective g) :\n    ‚áë(desc f h cond inj) = f :=\n  rfl\n\n"}
{"name":"LocallyConstant.indicator_apply","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\nR : Type u_5\ninst‚úù : Zero R\nU : Set X\nf : LocallyConstant X R\nhU : IsClopen U\nx : X\n‚ä¢ Eq ((f.indicator hU) x) (U.indicator (‚áëf) x)","decl":"/-- Given a clopen set `U` and a locally constant function `f`, `LocallyConstant.mulIndicator`\n  returns the locally constant function that is `f` on `U` and `1` otherwise. -/\n@[to_additive (attr := simps) \"Given a clopen set `U` and a locally constant function `f`,\n  `LocallyConstant.indicator` returns the locally constant function that is `f` on `U` and `0`\n  otherwise. \"]\nnoncomputable def mulIndicator (hU : IsClopen U) : LocallyConstant X R where\n  toFun := Set.mulIndicator U f\n  isLocallyConstant := fun s => by\n    rw [mulIndicator_preimage, Set.ite, Set.diff_eq]\n    exact ((f.2 s).inter hU.isOpen).union ((IsLocallyConstant.const 1 s).inter hU.compl.isOpen)\n\n"}
{"name":"LocallyConstant.mulIndicator_apply","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\nR : Type u_5\ninst‚úù : One R\nU : Set X\nf : LocallyConstant X R\nhU : IsClopen U\nx : X\n‚ä¢ Eq ((f.mulIndicator hU) x) (U.mulIndicator (‚áëf) x)","decl":"/-- Given a clopen set `U` and a locally constant function `f`, `LocallyConstant.mulIndicator`\n  returns the locally constant function that is `f` on `U` and `1` otherwise. -/\n@[to_additive (attr := simps) \"Given a clopen set `U` and a locally constant function `f`,\n  `LocallyConstant.indicator` returns the locally constant function that is `f` on `U` and `0`\n  otherwise. \"]\nnoncomputable def mulIndicator (hU : IsClopen U) : LocallyConstant X R where\n  toFun := Set.mulIndicator U f\n  isLocallyConstant := fun s => by\n    rw [mulIndicator_preimage, Set.ite, Set.diff_eq]\n    exact ((f.2 s).inter hU.isOpen).union ((IsLocallyConstant.const 1 s).inter hU.compl.isOpen)\n\n"}
{"name":"LocallyConstant.mulIndicator_apply_eq_if","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\nR : Type u_5\ninst‚úù : One R\nU : Set X\nf : LocallyConstant X R\na : X\nhU : IsClopen U\n‚ä¢ Eq ((f.mulIndicator hU) a) (ite (Membership.mem U a) (f a) 1)","decl":"open Classical in\n@[to_additive]\ntheorem mulIndicator_apply_eq_if (hU : IsClopen U) :\n    mulIndicator f hU a = if a ‚àà U then f a else 1 :=\n  Set.mulIndicator_apply U f a\n\n"}
{"name":"LocallyConstant.indicator_apply_eq_if","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\nR : Type u_5\ninst‚úù : Zero R\nU : Set X\nf : LocallyConstant X R\na : X\nhU : IsClopen U\n‚ä¢ Eq ((f.indicator hU) a) (ite (Membership.mem U a) (f a) 0)","decl":"open Classical in\n@[to_additive]\ntheorem mulIndicator_apply_eq_if (hU : IsClopen U) :\n    mulIndicator f hU a = if a ‚àà U then f a else 1 :=\n  Set.mulIndicator_apply U f a\n\n"}
{"name":"LocallyConstant.indicator_of_mem","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\nR : Type u_5\ninst‚úù : Zero R\nU : Set X\nf : LocallyConstant X R\na : X\nhU : IsClopen U\nh : Membership.mem U a\n‚ä¢ Eq ((f.indicator hU) a) (f a)","decl":"@[to_additive]\ntheorem mulIndicator_of_mem (hU : IsClopen U) (h : a ‚àà U) : f.mulIndicator hU a = f a :=\n  Set.mulIndicator_of_mem h _\n\n"}
{"name":"LocallyConstant.mulIndicator_of_mem","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\nR : Type u_5\ninst‚úù : One R\nU : Set X\nf : LocallyConstant X R\na : X\nhU : IsClopen U\nh : Membership.mem U a\n‚ä¢ Eq ((f.mulIndicator hU) a) (f a)","decl":"@[to_additive]\ntheorem mulIndicator_of_mem (hU : IsClopen U) (h : a ‚àà U) : f.mulIndicator hU a = f a :=\n  Set.mulIndicator_of_mem h _\n\n"}
{"name":"LocallyConstant.indicator_of_not_mem","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\nR : Type u_5\ninst‚úù : Zero R\nU : Set X\nf : LocallyConstant X R\na : X\nhU : IsClopen U\nh : Not (Membership.mem U a)\n‚ä¢ Eq ((f.indicator hU) a) 0","decl":"@[to_additive]\ntheorem mulIndicator_of_not_mem (hU : IsClopen U) (h : a ‚àâ U) : f.mulIndicator hU a = 1 :=\n  Set.mulIndicator_of_not_mem h _\n\n"}
{"name":"LocallyConstant.mulIndicator_of_not_mem","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\nR : Type u_5\ninst‚úù : One R\nU : Set X\nf : LocallyConstant X R\na : X\nhU : IsClopen U\nh : Not (Membership.mem U a)\n‚ä¢ Eq ((f.mulIndicator hU) a) 1","decl":"@[to_additive]\ntheorem mulIndicator_of_not_mem (hU : IsClopen U) (h : a ‚àâ U) : f.mulIndicator hU a = 1 :=\n  Set.mulIndicator_of_not_mem h _\n\n"}
{"name":"LocallyConstant.congrLeft_symm_apply","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\ne : Homeomorph X Y\ng : LocallyConstant Y Z\n‚ä¢ Eq ((LocallyConstant.congrLeft e).symm g) (LocallyConstant.comap (‚Üëe) g)","decl":"/--\nThe equivalence between `LocallyConstant X Z` and `LocallyConstant Y Z` given a\nhomeomorphism `X ‚âÉ‚Çú Y`\n-/\n@[simps]\ndef congrLeft [TopologicalSpace Y] (e : X ‚âÉ‚Çú Y) : LocallyConstant X Z ‚âÉ LocallyConstant Y Z where\n  toFun := comap e.symm\n  invFun := comap e\n  left_inv := by\n    intro\n    simp [comap_comap]\n  right_inv := by\n    intro\n    simp [comap_comap]\n\n"}
{"name":"LocallyConstant.congrLeft_apply","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\ne : Homeomorph X Y\ng : LocallyConstant X Z\n‚ä¢ Eq ((LocallyConstant.congrLeft e) g) (LocallyConstant.comap (‚Üëe.symm) g)","decl":"/--\nThe equivalence between `LocallyConstant X Z` and `LocallyConstant Y Z` given a\nhomeomorphism `X ‚âÉ‚Çú Y`\n-/\n@[simps]\ndef congrLeft [TopologicalSpace Y] (e : X ‚âÉ‚Çú Y) : LocallyConstant X Z ‚âÉ LocallyConstant Y Z where\n  toFun := comap e.symm\n  invFun := comap e\n  left_inv := by\n    intro\n    simp [comap_comap]\n  right_inv := by\n    intro\n    simp [comap_comap]\n\n"}
{"name":"LocallyConstant.congrRight_symm_apply","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst‚úù : TopologicalSpace X\ne : Equiv Y Z\ng : LocallyConstant X Z\n‚ä¢ Eq ((LocallyConstant.congrRight e).symm g) (LocallyConstant.map (‚áëe.symm) g)","decl":"/--\nThe equivalence between `LocallyConstant X Y` and `LocallyConstant X Z` given an\nequivalence `Y ‚âÉ Z`\n-/\n@[simps]\ndef congrRight (e : Y ‚âÉ Z) : LocallyConstant X Y ‚âÉ LocallyConstant X Z where\n  toFun := map e\n  invFun := map e.symm\n  left_inv := by intro; ext; simp\n  right_inv := by intro; ext; simp\n\n"}
{"name":"LocallyConstant.congrRight_apply","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst‚úù : TopologicalSpace X\ne : Equiv Y Z\ng : LocallyConstant X Y\n‚ä¢ Eq ((LocallyConstant.congrRight e) g) (LocallyConstant.map (‚áëe) g)","decl":"/--\nThe equivalence between `LocallyConstant X Y` and `LocallyConstant X Z` given an\nequivalence `Y ‚âÉ Z`\n-/\n@[simps]\ndef congrRight (e : Y ‚âÉ Z) : LocallyConstant X Y ‚âÉ LocallyConstant X Z where\n  toFun := map e\n  invFun := map e.symm\n  left_inv := by intro; ext; simp\n  right_inv := by intro; ext; simp\n\n"}
{"name":"LocallyConstant.piecewise_apply_left","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nZ : Type u_3\ninst‚úù¬π : TopologicalSpace X\nC‚ÇÅ C‚ÇÇ : Set X\nh‚ÇÅ : IsClosed C‚ÇÅ\nh‚ÇÇ : IsClosed C‚ÇÇ\nh : Eq (Union.union C‚ÇÅ C‚ÇÇ) Set.univ\nf : LocallyConstant (‚ÜëC‚ÇÅ) Z\ng : LocallyConstant (‚ÜëC‚ÇÇ) Z\nhfg : ‚àÄ (x : X) (hx : Membership.mem (Inter.inter C‚ÇÅ C‚ÇÇ) x), Eq (f ‚ü®x, ‚ãØ‚ü©) (g ‚ü®x, ‚ãØ‚ü©)\ninst‚úù : DecidablePred fun x => Membership.mem C‚ÇÅ x\nx : X\nhx : Membership.mem C‚ÇÅ x\n‚ä¢ Eq ((LocallyConstant.piecewise h‚ÇÅ h‚ÇÇ h f g hfg) x) (f ‚ü®x, hx‚ü©)","decl":"@[simp]\nlemma piecewise_apply_left {C‚ÇÅ C‚ÇÇ : Set X} (h‚ÇÅ : IsClosed C‚ÇÅ) (h‚ÇÇ : IsClosed C‚ÇÇ)\n    (h : C‚ÇÅ ‚à™ C‚ÇÇ = Set.univ) (f : LocallyConstant C‚ÇÅ Z) (g : LocallyConstant C‚ÇÇ Z)\n    (hfg : ‚àÄ (x : X) (hx : x ‚àà C‚ÇÅ ‚à© C‚ÇÇ), f ‚ü®x, hx.1‚ü© = g ‚ü®x, hx.2‚ü©)\n    [DecidablePred (¬∑ ‚àà C‚ÇÅ)] (x : X) (hx : x ‚àà C‚ÇÅ) :\n    piecewise h‚ÇÅ h‚ÇÇ h f g hfg x = f ‚ü®x, hx‚ü© := by\n  simp only [piecewise, Set.mem_preimage, continuous_subtype_val.restrictPreimage,\n    coe_comap, Function.comp_apply, coe_mk]\n  rw [dif_pos hx]\n\n"}
{"name":"LocallyConstant.piecewise_apply_right","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nZ : Type u_3\ninst‚úù¬π : TopologicalSpace X\nC‚ÇÅ C‚ÇÇ : Set X\nh‚ÇÅ : IsClosed C‚ÇÅ\nh‚ÇÇ : IsClosed C‚ÇÇ\nh : Eq (Union.union C‚ÇÅ C‚ÇÇ) Set.univ\nf : LocallyConstant (‚ÜëC‚ÇÅ) Z\ng : LocallyConstant (‚ÜëC‚ÇÇ) Z\nhfg : ‚àÄ (x : X) (hx : Membership.mem (Inter.inter C‚ÇÅ C‚ÇÇ) x), Eq (f ‚ü®x, ‚ãØ‚ü©) (g ‚ü®x, ‚ãØ‚ü©)\ninst‚úù : DecidablePred fun x => Membership.mem C‚ÇÅ x\nx : X\nhx : Membership.mem C‚ÇÇ x\n‚ä¢ Eq ((LocallyConstant.piecewise h‚ÇÅ h‚ÇÇ h f g hfg) x) (g ‚ü®x, hx‚ü©)","decl":"@[simp]\nlemma piecewise_apply_right {C‚ÇÅ C‚ÇÇ : Set X} (h‚ÇÅ : IsClosed C‚ÇÅ) (h‚ÇÇ : IsClosed C‚ÇÇ)\n    (h : C‚ÇÅ ‚à™ C‚ÇÇ = Set.univ) (f : LocallyConstant C‚ÇÅ Z) (g : LocallyConstant C‚ÇÇ Z)\n    (hfg : ‚àÄ (x : X) (hx : x ‚àà C‚ÇÅ ‚à© C‚ÇÇ), f ‚ü®x, hx.1‚ü© = g ‚ü®x, hx.2‚ü©)\n    [DecidablePred (¬∑ ‚àà C‚ÇÅ)] (x : X) (hx : x ‚àà C‚ÇÇ) :\n    piecewise h‚ÇÅ h‚ÇÇ h f g hfg x = g ‚ü®x, hx‚ü© := by\n  simp only [piecewise, Set.mem_preimage, continuous_subtype_val.restrictPreimage,\n    coe_comap, Function.comp_apply, coe_mk]\n  split_ifs with h\n  ¬∑ exact hfg x ‚ü®h, hx‚ü©\n  ¬∑ rfl\n\n"}
{"name":"LocallyConstant.piecewise'_apply_left","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nZ : Type u_3\ninst‚úù¬π : TopologicalSpace X\nC‚ÇÄ C‚ÇÅ C‚ÇÇ : Set X\nh‚ÇÄ : HasSubset.Subset C‚ÇÄ (Union.union C‚ÇÅ C‚ÇÇ)\nh‚ÇÅ : IsClosed C‚ÇÅ\nh‚ÇÇ : IsClosed C‚ÇÇ\nf‚ÇÅ : LocallyConstant (‚ÜëC‚ÇÅ) Z\nf‚ÇÇ : LocallyConstant (‚ÜëC‚ÇÇ) Z\ninst‚úù : DecidablePred fun x => Membership.mem C‚ÇÅ x\nhf : ‚àÄ (x : X) (hx : Membership.mem (Inter.inter C‚ÇÅ C‚ÇÇ) x), Eq (f‚ÇÅ ‚ü®x, ‚ãØ‚ü©) (f‚ÇÇ ‚ü®x, ‚ãØ‚ü©)\nx : ‚ÜëC‚ÇÄ\nhx : Membership.mem C‚ÇÅ ‚Üëx\n‚ä¢ Eq ((LocallyConstant.piecewise' h‚ÇÄ h‚ÇÅ h‚ÇÇ f‚ÇÅ f‚ÇÇ hf) x) (f‚ÇÅ ‚ü®‚Üëx, hx‚ü©)","decl":"@[simp]\nlemma piecewise'_apply_left {C‚ÇÄ C‚ÇÅ C‚ÇÇ : Set X} (h‚ÇÄ : C‚ÇÄ ‚äÜ C‚ÇÅ ‚à™ C‚ÇÇ) (h‚ÇÅ : IsClosed C‚ÇÅ)\n    (h‚ÇÇ : IsClosed C‚ÇÇ) (f‚ÇÅ : LocallyConstant C‚ÇÅ Z) (f‚ÇÇ : LocallyConstant C‚ÇÇ Z)\n    [DecidablePred (¬∑ ‚àà C‚ÇÅ)] (hf : ‚àÄ x (hx : x ‚àà C‚ÇÅ ‚à© C‚ÇÇ), f‚ÇÅ ‚ü®x, hx.1‚ü© = f‚ÇÇ ‚ü®x, hx.2‚ü©)\n    (x : C‚ÇÄ) (hx : x.val ‚àà C‚ÇÅ) :\n    piecewise' h‚ÇÄ h‚ÇÅ h‚ÇÇ f‚ÇÅ f‚ÇÇ hf x = f‚ÇÅ ‚ü®x.val, hx‚ü© := by\n  letI : ‚àÄ j : C‚ÇÄ, Decidable (j ‚àà Subtype.val ‚Åª¬π' C‚ÇÅ) := fun j ‚Ü¶ decidable_of_iff (‚Üëj ‚àà C‚ÇÅ) Iff.rfl\n  rw [piecewise', piecewise_apply_left (f := (f‚ÇÅ.comap\n    ‚ü®(restrictPreimage C‚ÇÅ ((‚Üë) : C‚ÇÄ ‚Üí X)), continuous_subtype_val.restrictPreimage‚ü©))\n    (hx := hx)]\n  rfl\n\n"}
{"name":"LocallyConstant.piecewise'_apply_right","module":"Mathlib.Topology.LocallyConstant.Basic","initialProofState":"X : Type u_1\nZ : Type u_3\ninst‚úù¬π : TopologicalSpace X\nC‚ÇÄ C‚ÇÅ C‚ÇÇ : Set X\nh‚ÇÄ : HasSubset.Subset C‚ÇÄ (Union.union C‚ÇÅ C‚ÇÇ)\nh‚ÇÅ : IsClosed C‚ÇÅ\nh‚ÇÇ : IsClosed C‚ÇÇ\nf‚ÇÅ : LocallyConstant (‚ÜëC‚ÇÅ) Z\nf‚ÇÇ : LocallyConstant (‚ÜëC‚ÇÇ) Z\ninst‚úù : DecidablePred fun x => Membership.mem C‚ÇÅ x\nhf : ‚àÄ (x : X) (hx : Membership.mem (Inter.inter C‚ÇÅ C‚ÇÇ) x), Eq (f‚ÇÅ ‚ü®x, ‚ãØ‚ü©) (f‚ÇÇ ‚ü®x, ‚ãØ‚ü©)\nx : ‚ÜëC‚ÇÄ\nhx : Membership.mem C‚ÇÇ ‚Üëx\n‚ä¢ Eq ((LocallyConstant.piecewise' h‚ÇÄ h‚ÇÅ h‚ÇÇ f‚ÇÅ f‚ÇÇ hf) x) (f‚ÇÇ ‚ü®‚Üëx, hx‚ü©)","decl":"@[simp]\nlemma piecewise'_apply_right {C‚ÇÄ C‚ÇÅ C‚ÇÇ : Set X} (h‚ÇÄ : C‚ÇÄ ‚äÜ C‚ÇÅ ‚à™ C‚ÇÇ) (h‚ÇÅ : IsClosed C‚ÇÅ)\n    (h‚ÇÇ : IsClosed C‚ÇÇ) (f‚ÇÅ : LocallyConstant C‚ÇÅ Z) (f‚ÇÇ : LocallyConstant C‚ÇÇ Z)\n    [DecidablePred (¬∑ ‚àà C‚ÇÅ)] (hf : ‚àÄ x (hx : x ‚àà C‚ÇÅ ‚à© C‚ÇÇ), f‚ÇÅ ‚ü®x, hx.1‚ü© = f‚ÇÇ ‚ü®x, hx.2‚ü©)\n    (x : C‚ÇÄ) (hx : x.val ‚àà C‚ÇÇ) :\n    piecewise' h‚ÇÄ h‚ÇÅ h‚ÇÇ f‚ÇÅ f‚ÇÇ hf x = f‚ÇÇ ‚ü®x.val, hx‚ü© := by\n  letI : ‚àÄ j : C‚ÇÄ, Decidable (j ‚àà Subtype.val ‚Åª¬π' C‚ÇÅ) := fun j ‚Ü¶ decidable_of_iff (‚Üëj ‚àà C‚ÇÅ) Iff.rfl\n  rw [piecewise', piecewise_apply_right (f := (f‚ÇÅ.comap\n    ‚ü®(restrictPreimage C‚ÇÅ ((‚Üë) : C‚ÇÄ ‚Üí X)), continuous_subtype_val.restrictPreimage‚ü©))\n    (hx := hx)]\n  rfl\n\n"}
