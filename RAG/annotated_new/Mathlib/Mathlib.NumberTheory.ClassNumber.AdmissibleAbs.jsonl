{"name":"AbsoluteValue.exists_partition_int","module":"Mathlib.NumberTheory.ClassNumber.AdmissibleAbs","initialProofState":"n : Nat\nε : Real\nhε : LT.lt 0 ε\nb : Int\nhb : Ne b 0\nA : Fin n → Int\n⊢ Exists fun t => ∀ (i₀ i₁ : Fin n), Eq (t i₀) (t i₁) → LT.lt (↑(abs (HSub.hSub (HMod.hMod (A i₁) b) (HMod.hMod (A i₀) b)))) (HSMul.hSMul (abs b) ε)","decl":"/-- We can partition a finite family into `partition_card ε` sets, such that the remainders\nin each set are close together. -/\ntheorem exists_partition_int (n : ℕ) {ε : ℝ} (hε : 0 < ε) {b : ℤ} (hb : b ≠ 0) (A : Fin n → ℤ) :\n    ∃ t : Fin n → Fin ⌈1 / ε⌉₊,\n    ∀ i₀ i₁, t i₀ = t i₁ → ↑(abs (A i₁ % b - A i₀ % b)) < abs b • ε := by\n  have hb' : (0 : ℝ) < ↑(abs b) := Int.cast_pos.mpr (abs_pos.mpr hb)\n  have hbε : 0 < abs b • ε := by\n    rw [Algebra.smul_def]\n    exact mul_pos hb' hε\n  have hfloor : ∀ i, 0 ≤ floor ((A i % b : ℤ) / abs b • ε : ℝ) :=\n    fun _ ↦ floor_nonneg.mpr (div_nonneg (cast_nonneg.mpr (emod_nonneg _ hb)) hbε.le)\n  refine ⟨fun i ↦ ⟨natAbs (floor ((A i % b : ℤ) / abs b • ε : ℝ)), ?_⟩, ?_⟩\n  · rw [← ofNat_lt, natAbs_of_nonneg (hfloor i), floor_lt, Algebra.smul_def, eq_intCast, ← div_div]\n    apply lt_of_lt_of_le _ (Nat.le_ceil _)\n    gcongr\n    rw [div_lt_one hb', cast_lt]\n    exact Int.emod_lt _ hb\n  intro i₀ i₁ hi\n  have hi : (⌊↑(A i₀ % b) / abs b • ε⌋.natAbs : ℤ) = ⌊↑(A i₁ % b) / abs b • ε⌋.natAbs :=\n    congr_arg ((↑) : ℕ → ℤ) (Fin.mk_eq_mk.mp hi)\n  rw [natAbs_of_nonneg (hfloor i₀), natAbs_of_nonneg (hfloor i₁)] at hi\n  have hi := abs_sub_lt_one_of_floor_eq_floor hi\n  rw [abs_sub_comm, ← sub_div, abs_div, abs_of_nonneg hbε.le, div_lt_iff₀ hbε, one_mul] at hi\n  rwa [Int.cast_abs, Int.cast_sub]\n\n"}
