{"name":"List.length_iterate","module":"Mathlib.Data.List.Iterate","initialProofState":"α : Type u_1\nf : α → α\na : α\nn : Nat\n⊢ Eq (List.iterate f a n).length n","decl":"@[simp]\ntheorem length_iterate (f : α → α) (a : α) (n : ℕ) : length (iterate f a n) = n := by\n  induction n generalizing a <;> simp [*]\n\n"}
{"name":"List.iterate_eq_nil","module":"Mathlib.Data.List.Iterate","initialProofState":"α : Type u_1\nf : α → α\na : α\nn : Nat\n⊢ Iff (Eq (List.iterate f a n) List.nil) (Eq n 0)","decl":"@[simp]\ntheorem iterate_eq_nil {f : α → α} {a : α} {n : ℕ} : iterate f a n = [] ↔ n = 0 := by\n  rw [← length_eq_zero, length_iterate]\n\n"}
{"name":"List.getElem?_iterate","module":"Mathlib.Data.List.Iterate","initialProofState":"α : Type u_1\nf : α → α\na : α\nn i : Nat\na✝ : LT.lt i n\n⊢ Eq (GetElem?.getElem? (List.iterate f a n) i) (Option.some (Nat.iterate f i a))","decl":"theorem getElem?_iterate (f : α → α) (a : α) :\n    ∀ (n i : ℕ), i < n → (iterate f a n)[i]? = f^[i] a\n  | n + 1, 0    , _ => by simp\n  | n + 1, i + 1, h => by simp [getElem?_iterate f (f a) n i (by simpa using h)]\n\n"}
{"name":"List.get?_iterate","module":"Mathlib.Data.List.Iterate","initialProofState":"α : Type u_1\nf : α → α\na : α\nn i : Nat\nh : LT.lt i n\n⊢ Eq ((List.iterate f a n).get? i) (Option.some (Nat.iterate f i a))","decl":"@[deprecated getElem?_iterate (since := \"2024-08-23\")]\ntheorem get?_iterate (f : α → α) (a : α) (n i : ℕ) (h : i < n) :\n    get? (iterate f a n) i = f^[i] a := by\n  simp only [get?_eq_getElem?, getElem?_iterate, h]\n\n"}
{"name":"List.getElem_iterate","module":"Mathlib.Data.List.Iterate","initialProofState":"α : Type u_1\nf : α → α\na : α\nn i : Nat\nh : LT.lt i (List.iterate f a n).length\n⊢ Eq (GetElem.getElem (List.iterate f a n) i ⋯) (Nat.iterate f i a)","decl":"@[simp]\ntheorem getElem_iterate (f : α → α) (a : α) (n : ℕ) (i : Nat) (h : i < (iterate f a n).length) :\n    (iterate f a n)[i] = f^[i] a :=\n  getElem_eq_iff.2 <| getElem?_iterate _ _ _ _ <| by rwa [length_iterate] at h\n\n"}
{"name":"List.get_iterate","module":"Mathlib.Data.List.Iterate","initialProofState":"α : Type u_1\nf : α → α\na : α\nn : Nat\ni : Fin (List.iterate f a n).length\n⊢ Eq ((List.iterate f a n).get i) (Nat.iterate f (↑i) a)","decl":"@[deprecated getElem_iterate (since := \"2024-08-23\")]\ntheorem get_iterate (f : α → α) (a : α) (n : ℕ) (i : Fin (iterate f a n).length) :\n    get (iterate f a n) i = f^[↑i] a := by\n  simp\n\n"}
{"name":"List.mem_iterate","module":"Mathlib.Data.List.Iterate","initialProofState":"α : Type u_1\nf : α → α\na : α\nn : Nat\nb : α\n⊢ Iff (Membership.mem (List.iterate f a n) b) (Exists fun m => And (LT.lt m n) (Eq b (Nat.iterate f m a)))","decl":"@[simp]\ntheorem mem_iterate {f : α → α} {a : α} {n : ℕ} {b : α} :\n    b ∈ iterate f a n ↔ ∃ m < n, b = f^[m] a := by\n  simp [List.mem_iff_get, Fin.exists_iff, eq_comm (b := b)]\n\n"}
{"name":"List.range_map_iterate","module":"Mathlib.Data.List.Iterate","initialProofState":"α : Type u_1\nn : Nat\nf : α → α\na : α\n⊢ Eq (List.map (fun x => Nat.iterate f x a) (List.range n)) (List.iterate f a n)","decl":"@[simp]\ntheorem range_map_iterate (n : ℕ) (f : α → α) (a : α) :\n    (List.range n).map (f^[·] a) = List.iterate f a n := by\n  apply List.ext_getElem <;> simp\n\n"}
{"name":"List.iterate_add","module":"Mathlib.Data.List.Iterate","initialProofState":"α : Type u_1\nf : α → α\na : α\nm n : Nat\n⊢ Eq (List.iterate f a (HAdd.hAdd m n)) (HAppend.hAppend (List.iterate f a m) (List.iterate f (Nat.iterate f m a) n))","decl":"theorem iterate_add (f : α → α) (a : α) (m n : ℕ) :\n    iterate f a (m + n) = iterate f a m ++ iterate f (f^[m] a) n := by\n  induction m generalizing a with\n  | zero => simp\n  | succ n ih => rw [iterate, add_right_comm, iterate, ih, Nat.iterate, cons_append]\n\n"}
{"name":"List.take_iterate","module":"Mathlib.Data.List.Iterate","initialProofState":"α : Type u_1\nf : α → α\na : α\nm n : Nat\n⊢ Eq (List.take m (List.iterate f a n)) (List.iterate f a (Min.min m n))","decl":"theorem take_iterate (f : α → α) (a : α) (m n : ℕ) :\n    take m (iterate f a n) = iterate f a (min m n) := by\n  rw [← range_map_iterate, ← range_map_iterate, ← map_take, take_range]\n\n"}
