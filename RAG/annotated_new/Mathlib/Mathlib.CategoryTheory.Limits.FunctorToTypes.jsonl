{"name":"CategoryTheory.FunctorToTypes.jointly_surjective","module":"Mathlib.CategoryTheory.Limits.FunctorToTypes","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\nF : CategoryTheory.Functor J (CategoryTheory.Functor K (Type w))\nk : K\nt : CategoryTheory.Limits.Cocone F\nh : CategoryTheory.Limits.IsColimit t\nx : t.pt.obj k\ninst✝ : ∀ (k : K), CategoryTheory.Limits.HasColimit (F.flip.obj k)\n⊢ Exists fun j => Exists fun y => Eq x ((t.ι.app j).app k y)","decl":"theorem jointly_surjective (k : K) {t : Cocone F} (h : IsColimit t) (x : t.pt.obj k)\n    [∀ k, HasColimit (F.flip.obj k)] : ∃ j y, x = (t.ι.app j).app k y := by\n  let hev := isColimitOfPreserves ((evaluation _ _).obj k) h\n  obtain ⟨j, y, rfl⟩ := Types.jointly_surjective _ hev x\n  exact ⟨j, y, by simp⟩\n\n"}
{"name":"CategoryTheory.FunctorToTypes.jointly_surjective'","module":"Mathlib.CategoryTheory.Limits.FunctorToTypes","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\nF : CategoryTheory.Functor J (CategoryTheory.Functor K (Type w))\ninst✝ : ∀ (k : K), CategoryTheory.Limits.HasColimit (F.flip.obj k)\nk : K\nx : (CategoryTheory.Limits.colimit F).obj k\n⊢ Exists fun j => Exists fun y => Eq x ((CategoryTheory.Limits.colimit.ι F j).app k y)","decl":"theorem jointly_surjective' [∀ k, HasColimit (F.flip.obj k)] (k : K) (x : (colimit F).obj k) :\n    ∃ j y, x = (colimit.ι F j).app k y :=\n  jointly_surjective _ _ (colimit.isColimit _) x\n\n"}
{"name":"CategoryTheory.FunctorToTypes.colimit.map_ι_apply","module":"Mathlib.CategoryTheory.Limits.FunctorToTypes","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\nF : CategoryTheory.Functor J (CategoryTheory.Functor K (Type w))\ninst✝ : CategoryTheory.Limits.HasColimit F\nj : J\nk k' : K\nf : Quiver.Hom k k'\nx : (F.obj j).obj k\n⊢ Eq ((CategoryTheory.Limits.colimit F).map f ((CategoryTheory.Limits.colimit.ι F j).app k x)) ((CategoryTheory.Limits.colimit.ι F j).app k' ((F.obj j).map f x))","decl":"theorem colimit.map_ι_apply [HasColimit F] (j : J) {k k' : K} {f : k ⟶ k'} {x} :\n    (colimit F).map f ((colimit.ι F j).app _ x) = (colimit.ι F j).app _ ((F.obj j).map f x) :=\n  congrFun ((colimit.ι F j).naturality _).symm _\n\n"}
