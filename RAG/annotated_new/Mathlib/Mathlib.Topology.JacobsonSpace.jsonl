{"name":"mem_closedPoints_iff","module":"Mathlib.Topology.JacobsonSpace","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx : X\n⊢ Iff (Membership.mem (closedPoints X) x) (IsClosed (Singleton.singleton x))","decl":"@[simp]\nlemma mem_closedPoints_iff {x} : x ∈ closedPoints X ↔ IsClosed {x} := Iff.rfl\n\n"}
{"name":"preimage_closedPoints_subset","module":"Mathlib.Topology.JacobsonSpace","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nhf : Function.Injective f\nhf' : Continuous f\n⊢ HasSubset.Subset (Set.preimage f (closedPoints Y)) (closedPoints X)","decl":"lemma preimage_closedPoints_subset (hf : Function.Injective f) (hf' : Continuous f) :\n    f ⁻¹' closedPoints Y ⊆ closedPoints X := by\n  intros x hx\n  rw [mem_closedPoints_iff]\n  convert continuous_iff_isClosed.mp hf' _ hx\n  rw [← Set.image_singleton, Set.preimage_image_eq _ hf]\n\n"}
{"name":"Topology.IsClosedEmbedding.preimage_closedPoints","module":"Mathlib.Topology.JacobsonSpace","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nhf : Topology.IsClosedEmbedding f\n⊢ Eq (Set.preimage f (closedPoints Y)) (closedPoints X)","decl":"lemma Topology.IsClosedEmbedding.preimage_closedPoints (hf : IsClosedEmbedding f) :\n    f ⁻¹' closedPoints Y = closedPoints X := by\n  ext x\n  simp [mem_closedPoints_iff, ← Set.image_singleton, hf.isClosed_iff_image_isClosed]\n\n"}
{"name":"closedPoints_eq_univ","module":"Mathlib.Topology.JacobsonSpace","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : T1Space X\n⊢ Eq (closedPoints X) Set.univ","decl":"lemma closedPoints_eq_univ [T1Space X] :\n    closedPoints X = Set.univ :=\n  Set.eq_univ_iff_forall.mpr fun _ ↦ isClosed_singleton\n\n"}
{"name":"jacobsonSpace_iff","module":"Mathlib.Topology.JacobsonSpace","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\n⊢ Iff (JacobsonSpace X) (∀ {Z : Set X}, IsClosed Z → Eq (closure (Inter.inter Z (closedPoints X))) Z)","decl":"/-- The class of jacobson spaces, i.e.\nspaces such that the set of closed points are dense in every closed subspace. -/\n@[mk_iff, stacks 005U]\nclass JacobsonSpace : Prop where\n  closure_inter_closedPoints : ∀ {Z}, IsClosed Z → closure (Z ∩ closedPoints X) = Z\n\n"}
{"name":"JacobsonSpace.closure_inter_closedPoints","module":"Mathlib.Topology.JacobsonSpace","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nself : JacobsonSpace X\nZ : Set X\na✝ : IsClosed Z\n⊢ Eq (closure (Inter.inter Z (closedPoints X))) Z","decl":"/-- The class of jacobson spaces, i.e.\nspaces such that the set of closed points are dense in every closed subspace. -/\n@[mk_iff, stacks 005U]\nclass JacobsonSpace : Prop where\n  closure_inter_closedPoints : ∀ {Z}, IsClosed Z → closure (Z ∩ closedPoints X) = Z\n\n"}
{"name":"closure_closedPoints","module":"Mathlib.Topology.JacobsonSpace","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : JacobsonSpace X\n⊢ Eq (closure (closedPoints X)) Set.univ","decl":"lemma closure_closedPoints [JacobsonSpace X] : closure (closedPoints X) = Set.univ := by\n  simpa using closure_inter_closedPoints isClosed_univ\n\n"}
{"name":"jacobsonSpace_iff_locallyClosed","module":"Mathlib.Topology.JacobsonSpace","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\n⊢ Iff (JacobsonSpace X) (∀ (Z : Set X), Z.Nonempty → IsLocallyClosed Z → (Inter.inter Z (closedPoints X)).Nonempty)","decl":"lemma jacobsonSpace_iff_locallyClosed :\n    JacobsonSpace X ↔ ∀ Z, Z.Nonempty → IsLocallyClosed Z → (Z ∩ closedPoints X).Nonempty := by\n  rw [jacobsonSpace_iff]\n  constructor\n  · simp_rw [isLocallyClosed_iff_isOpen_coborder, coborder, isOpen_compl_iff,\n      Set.nonempty_iff_ne_empty]\n    intros H Z hZ hZ' e\n    have : Z ⊆ closure Z \\ Z := by\n      refine subset_closure.trans ?_\n      nth_rw 1 [← H isClosed_closure]\n      rw [hZ'.closure_subset_iff, Set.subset_diff, Set.disjoint_iff, Set.inter_assoc,\n        Set.inter_comm _ Z, e]\n      exact ⟨Set.inter_subset_left, Set.inter_subset_right⟩\n    rw [Set.subset_diff, disjoint_self, Set.bot_eq_empty] at this\n    exact hZ this.2\n  · intro H Z hZ\n    refine subset_antisymm (hZ.closure_subset_iff.mpr Set.inter_subset_left) ?_\n    rw [← Set.disjoint_compl_left_iff_subset, Set.disjoint_iff_inter_eq_empty,\n      ← Set.not_nonempty_iff_eq_empty]\n    intro H'\n    have := H _ H' (isClosed_closure.isOpen_compl.isLocallyClosed.inter hZ.isLocallyClosed)\n    rw [Set.nonempty_iff_ne_empty, Set.inter_assoc, ne_eq,\n      ← Set.disjoint_iff_inter_eq_empty, Set.disjoint_compl_left_iff_subset] at this\n    exact this subset_closure\n\n"}
{"name":"nonempty_inter_closedPoints","module":"Mathlib.Topology.JacobsonSpace","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : JacobsonSpace X\nZ : Set X\nhZ : Z.Nonempty\nhZ' : IsLocallyClosed Z\n⊢ (Inter.inter Z (closedPoints X)).Nonempty","decl":"lemma nonempty_inter_closedPoints [JacobsonSpace X] {Z : Set X}\n    (hZ : Z.Nonempty) (hZ' : IsLocallyClosed Z) : (Z ∩ closedPoints X).Nonempty :=\n  jacobsonSpace_iff_locallyClosed.mp inferInstance Z hZ hZ'\n\n"}
{"name":"isClosed_singleton_of_isLocallyClosed_singleton","module":"Mathlib.Topology.JacobsonSpace","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : JacobsonSpace X\nx : X\nhx : IsLocallyClosed (Singleton.singleton x)\n⊢ IsClosed (Singleton.singleton x)","decl":"lemma isClosed_singleton_of_isLocallyClosed_singleton [JacobsonSpace X] {x : X}\n    (hx : IsLocallyClosed {x}) : IsClosed {x} := by\n  obtain ⟨_, ⟨y, rfl : y = x, rfl⟩, hy'⟩ :=\n    nonempty_inter_closedPoints (Set.singleton_nonempty x) hx\n  exact hy'\n\n"}
{"name":"Topology.IsOpenEmbedding.preimage_closedPoints","module":"Mathlib.Topology.JacobsonSpace","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\nf : X → Y\nhf : Topology.IsOpenEmbedding f\ninst✝ : JacobsonSpace Y\n⊢ Eq (Set.preimage f (closedPoints Y)) (closedPoints X)","decl":"lemma Topology.IsOpenEmbedding.preimage_closedPoints (hf : IsOpenEmbedding f) [JacobsonSpace Y] :\n    f ⁻¹' closedPoints Y = closedPoints X := by\n  apply subset_antisymm (preimage_closedPoints_subset hf.injective hf.continuous)\n  intros x hx\n  apply isClosed_singleton_of_isLocallyClosed_singleton\n  rw [← Set.image_singleton]\n  exact (hx.isLocallyClosed.image hf.isInducing hf.isOpen_range.isLocallyClosed)\n\n"}
{"name":"JacobsonSpace.of_isOpenEmbedding","module":"Mathlib.Topology.JacobsonSpace","initialProofState":"X : Type u_2\nY : Type u_1\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\nf : X → Y\ninst✝ : JacobsonSpace Y\nhf : Topology.IsOpenEmbedding f\n⊢ JacobsonSpace X","decl":"lemma JacobsonSpace.of_isOpenEmbedding [JacobsonSpace Y] (hf : IsOpenEmbedding f) :\n    JacobsonSpace X := by\n  rw [jacobsonSpace_iff_locallyClosed, ← hf.preimage_closedPoints]\n  intros Z hZ hZ'\n  obtain ⟨_, ⟨x, hx, rfl⟩, hx'⟩ := nonempty_inter_closedPoints\n    (hZ.image f) (hZ'.image hf.isInducing hf.isOpen_range.isLocallyClosed)\n  exact ⟨_, hx, hx'⟩\n\n"}
{"name":"JacobsonSpace.of_isClosedEmbedding","module":"Mathlib.Topology.JacobsonSpace","initialProofState":"X : Type u_2\nY : Type u_1\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\nf : X → Y\ninst✝ : JacobsonSpace Y\nhf : Topology.IsClosedEmbedding f\n⊢ JacobsonSpace X","decl":"lemma JacobsonSpace.of_isClosedEmbedding [JacobsonSpace Y] (hf : IsClosedEmbedding f) :\n    JacobsonSpace X := by\n  rw [jacobsonSpace_iff_locallyClosed, ← hf.preimage_closedPoints]\n  intros Z hZ hZ'\n  obtain ⟨_, ⟨x, hx, rfl⟩, hx'⟩ := nonempty_inter_closedPoints\n    (hZ.image f) (hZ'.image hf.isInducing hf.isClosed_range.isLocallyClosed)\n  exact ⟨_, hx, hx'⟩\n\n"}
{"name":"JacobsonSpace.discreteTopology","module":"Mathlib.Topology.JacobsonSpace","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : JacobsonSpace X\nh : (closedPoints X).Finite\n⊢ DiscreteTopology X","decl":"lemma JacobsonSpace.discreteTopology [JacobsonSpace X]\n    (h : (closedPoints X).Finite) : DiscreteTopology X := by\n  have : closedPoints X = Set.univ := by\n    rw [← Set.univ_subset_iff, ← closure_closedPoints,\n      closure_subset_iff_isClosed, ← (closedPoints X).biUnion_of_singleton]\n    exact h.isClosed_biUnion fun _ ↦ id\n  have inst : Finite X := Set.finite_univ_iff.mp (this ▸ h)\n  rw [← forall_open_iff_discrete]\n  intro s\n  rw [← isClosed_compl_iff, ← sᶜ.biUnion_of_singleton]\n  refine sᶜ.toFinite.isClosed_biUnion fun x _ ↦ ?_\n  rw [← mem_closedPoints_iff, this]\n  trivial\n\n"}
{"name":"instDiscreteTopologyOfFiniteOfJacobsonSpace","module":"Mathlib.Topology.JacobsonSpace","initialProofState":"X : Type u_1\ninst✝² : TopologicalSpace X\ninst✝¹ : Finite X\ninst✝ : JacobsonSpace X\n⊢ DiscreteTopology X","decl":"instance (priority := 100) [Finite X] [JacobsonSpace X] : DiscreteTopology X :=\n  JacobsonSpace.discreteTopology (Set.toFinite _)\n\n"}
{"name":"instJacobsonSpaceOfT1Space","module":"Mathlib.Topology.JacobsonSpace","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : T1Space X\n⊢ JacobsonSpace X","decl":"instance (priority := 100) [T1Space X] : JacobsonSpace X :=\n  ⟨by simp [closedPoints_eq_univ, closure_eq_iff_isClosed]⟩\n\n"}
{"name":"jacobsonSpace_iff_of_iSup_eq_top","module":"Mathlib.Topology.JacobsonSpace","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\nι : Type u_1\nU : ι → TopologicalSpace.Opens X\nhU : Eq (iSup U) Top.top\n⊢ Iff (JacobsonSpace X) (∀ (i : ι), JacobsonSpace (Subtype fun x => Membership.mem (U i) x))","decl":"open TopologicalSpace in\nlemma jacobsonSpace_iff_of_iSup_eq_top {ι : Type*} {U : ι → Opens X} (hU : iSup U = ⊤) :\n    JacobsonSpace X ↔ ∀ i, JacobsonSpace (U i) := by\n  refine ⟨fun H i ↦ .of_isOpenEmbedding (U i).2.isOpenEmbedding_subtypeVal, fun H ↦ ?_⟩\n  rw [jacobsonSpace_iff_locallyClosed]\n  intros Z hZ hZ'\n  have : (⋃ i, (U i : Set X)) = Set.univ := by rw [← Opens.coe_iSup]; injection hU\n  have : (⋃ i, Z ∩ U i) = Z := by rw [← Set.inter_iUnion, this, Set.inter_univ]\n  rw [← this, Set.nonempty_iUnion] at hZ\n  obtain ⟨i, x, hx, hx'⟩ := hZ\n  obtain ⟨y, hy, hy'⟩ := (jacobsonSpace_iff_locallyClosed.mp (H i)) (Subtype.val ⁻¹' Z)\n    ⟨⟨x, hx'⟩, hx⟩ (hZ'.preimage continuous_subtype_val)\n  refine ⟨y, hy, (isClosed_iff_coe_preimage_of_iSup_eq_top hU _).mpr fun j ↦ ?_⟩\n  by_cases h : (y : X) ∈ U j\n  · convert_to IsClosed {(⟨y, h⟩ : U j)}\n    · ext z; exact @Subtype.coe_inj _ _ z ⟨y, h⟩\n    apply isClosed_singleton_of_isLocallyClosed_singleton\n    convert (hy'.isLocallyClosed.image IsEmbedding.subtypeVal.isInducing\n      (U i).2.isOpenEmbedding_subtypeVal.isOpen_range.isLocallyClosed).preimage\n      continuous_subtype_val\n    rw [Set.image_singleton]\n    ext z\n    exact (@Subtype.coe_inj _ _ z ⟨y, h⟩).symm\n  · convert isClosed_empty\n    rw [Set.eq_empty_iff_forall_not_mem]\n    intro z (hz : z.1 = y.1)\n    exact h (hz ▸ z.2)\n"}
