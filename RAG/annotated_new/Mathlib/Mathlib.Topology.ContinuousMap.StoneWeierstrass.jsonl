{"name":"ContinuousMap.attachBound_apply_coe","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : CompactSpace X\nf : ContinuousMap X Real\nx : X\n‚ä¢ Eq (‚Üë(f.attachBound x)) (f x)","decl":"@[simp]\ntheorem attachBound_apply_coe (f : C(X, ‚Ñù)) (x : X) : ((attachBound f) x : ‚Ñù) = f x :=\n  rfl\n\n"}
{"name":"ContinuousMap.polynomial_comp_attachBound","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : CompactSpace X\nA : Subalgebra Real (ContinuousMap X Real)\nf : Subtype fun x => Membership.mem A x\ng : Polynomial Real\n‚ä¢ Eq ((g.toContinuousMapOn (Set.Icc (Neg.neg (Norm.norm f)) (Norm.norm f))).comp (‚Üëf).attachBound) ‚Üë((Polynomial.aeval f) g)","decl":"theorem polynomial_comp_attachBound (A : Subalgebra ‚Ñù C(X, ‚Ñù)) (f : A) (g : ‚Ñù[X]) :\n    (g.toContinuousMapOn (Set.Icc (-‚Äñf‚Äñ) ‚Äñf‚Äñ)).comp (f : C(X, ‚Ñù)).attachBound =\n      Polynomial.aeval f g := by\n  ext\n  simp only [Polynomial.aeval_subalgebra_coe, Polynomial.aeval_continuousMap_apply]\n  simp\n\n"}
{"name":"ContinuousMap.polynomial_comp_attachBound_mem","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : CompactSpace X\nA : Subalgebra Real (ContinuousMap X Real)\nf : Subtype fun x => Membership.mem A x\ng : Polynomial Real\n‚ä¢ Membership.mem A ((g.toContinuousMapOn (Set.Icc (Neg.neg (Norm.norm f)) (Norm.norm f))).comp (‚Üëf).attachBound)","decl":"/-- Given a continuous function `f` in a subalgebra of `C(X, ‚Ñù)`, postcomposing by a polynomial\ngives another function in `A`.\n\nThis lemma proves something slightly more subtle than this:\nwe take `f`, and think of it as a function into the restricted target `Set.Icc (-‚Äñf‚Äñ) ‚Äñf‚Äñ)`,\nand then postcompose with a polynomial function on that interval.\nThis is in fact the same situation as above, and so also gives a function in `A`.\n-/\ntheorem polynomial_comp_attachBound_mem (A : Subalgebra ‚Ñù C(X, ‚Ñù)) (f : A) (g : ‚Ñù[X]) :\n    (g.toContinuousMapOn (Set.Icc (-‚Äñf‚Äñ) ‚Äñf‚Äñ)).comp (f : C(X, ‚Ñù)).attachBound ‚àà A := by\n  rw [polynomial_comp_attachBound]\n  apply SetLike.coe_mem\n\n"}
{"name":"ContinuousMap.comp_attachBound_mem_closure","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : CompactSpace X\nA : Subalgebra Real (ContinuousMap X Real)\nf : Subtype fun x => Membership.mem A x\np : ContinuousMap (‚Üë(Set.Icc (Neg.neg (Norm.norm f)) (Norm.norm f))) Real\n‚ä¢ Membership.mem A.topologicalClosure (p.comp (‚Üëf).attachBound)","decl":"theorem comp_attachBound_mem_closure (A : Subalgebra ‚Ñù C(X, ‚Ñù)) (f : A)\n    (p : C(Set.Icc (-‚Äñf‚Äñ) ‚Äñf‚Äñ, ‚Ñù)) : p.comp (attachBound (f : C(X, ‚Ñù))) ‚àà A.topologicalClosure := by\n  -- `p` itself is in the closure of polynomials, by the Weierstrass theorem,\n  have mem_closure : p ‚àà (polynomialFunctions (Set.Icc (-‚Äñf‚Äñ) ‚Äñf‚Äñ)).topologicalClosure :=\n    continuousMap_mem_polynomialFunctions_closure _ _ p\n  -- and so there are polynomials arbitrarily close.\n  have frequently_mem_polynomials := mem_closure_iff_frequently.mp mem_closure\n  -- To prove `p.comp (attachBound f)` is in the closure of `A`,\n  -- we show there are elements of `A` arbitrarily close.\n  apply mem_closure_iff_frequently.mpr\n  -- To show that, we pull back the polynomials close to `p`,\n  refine\n    ((compRightContinuousMap ‚Ñù (attachBound (f : C(X, ‚Ñù)))).continuousAt\n            p).tendsto.frequently_map\n      _ ?_ frequently_mem_polynomials\n  -- but need to show that those pullbacks are actually in `A`.\n  rintro _ ‚ü®g, ‚ü®-, rfl‚ü©‚ü©\n  simp only [SetLike.mem_coe, AlgHom.coe_toRingHom, compRightContinuousMap_apply,\n    Polynomial.toContinuousMapOnAlgHom_apply]\n  apply polynomial_comp_attachBound_mem\n\n"}
{"name":"ContinuousMap.abs_mem_subalgebra_closure","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : CompactSpace X\nA : Subalgebra Real (ContinuousMap X Real)\nf : Subtype fun x => Membership.mem A x\n‚ä¢ Membership.mem A.topologicalClosure (abs ‚Üëf)","decl":"theorem abs_mem_subalgebra_closure (A : Subalgebra ‚Ñù C(X, ‚Ñù)) (f : A) :\n    |(f : C(X, ‚Ñù))| ‚àà A.topologicalClosure := by\n  let f' := attachBound (f : C(X, ‚Ñù))\n  let abs : C(Set.Icc (-‚Äñf‚Äñ) ‚Äñf‚Äñ, ‚Ñù) := { toFun := fun x : Set.Icc (-‚Äñf‚Äñ) ‚Äñf‚Äñ => |(x : ‚Ñù)| }\n  change abs.comp f' ‚àà A.topologicalClosure\n  apply comp_attachBound_mem_closure\n\n"}
{"name":"ContinuousMap.inf_mem_subalgebra_closure","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : CompactSpace X\nA : Subalgebra Real (ContinuousMap X Real)\nf g : Subtype fun x => Membership.mem A x\n‚ä¢ Membership.mem A.topologicalClosure (Min.min ‚Üëf ‚Üëg)","decl":"theorem inf_mem_subalgebra_closure (A : Subalgebra ‚Ñù C(X, ‚Ñù)) (f g : A) :\n    (f : C(X, ‚Ñù)) ‚äì (g : C(X, ‚Ñù)) ‚àà A.topologicalClosure := by\n  rw [inf_eq_half_smul_add_sub_abs_sub' ‚Ñù]\n  refine\n    A.topologicalClosure.smul_mem\n      (A.topologicalClosure.sub_mem\n        (A.topologicalClosure.add_mem (A.le_topologicalClosure f.property)\n          (A.le_topologicalClosure g.property))\n        ?_)\n      _\n  exact mod_cast abs_mem_subalgebra_closure A _\n\n"}
{"name":"ContinuousMap.inf_mem_closed_subalgebra","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : CompactSpace X\nA : Subalgebra Real (ContinuousMap X Real)\nh : IsClosed ‚ÜëA\nf g : Subtype fun x => Membership.mem A x\n‚ä¢ Membership.mem A (Min.min ‚Üëf ‚Üëg)","decl":"theorem inf_mem_closed_subalgebra (A : Subalgebra ‚Ñù C(X, ‚Ñù)) (h : IsClosed (A : Set C(X, ‚Ñù)))\n    (f g : A) : (f : C(X, ‚Ñù)) ‚äì (g : C(X, ‚Ñù)) ‚àà A := by\n  convert inf_mem_subalgebra_closure A f g\n  apply SetLike.ext'\n  symm\n  erw [closure_eq_iff_isClosed]\n  exact h\n\n"}
{"name":"ContinuousMap.sup_mem_subalgebra_closure","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : CompactSpace X\nA : Subalgebra Real (ContinuousMap X Real)\nf g : Subtype fun x => Membership.mem A x\n‚ä¢ Membership.mem A.topologicalClosure (Max.max ‚Üëf ‚Üëg)","decl":"theorem sup_mem_subalgebra_closure (A : Subalgebra ‚Ñù C(X, ‚Ñù)) (f g : A) :\n    (f : C(X, ‚Ñù)) ‚äî (g : C(X, ‚Ñù)) ‚àà A.topologicalClosure := by\n  rw [sup_eq_half_smul_add_add_abs_sub' ‚Ñù]\n  refine\n    A.topologicalClosure.smul_mem\n      (A.topologicalClosure.add_mem\n        (A.topologicalClosure.add_mem (A.le_topologicalClosure f.property)\n          (A.le_topologicalClosure g.property))\n        ?_)\n      _\n  exact mod_cast abs_mem_subalgebra_closure A _\n\n"}
{"name":"ContinuousMap.sup_mem_closed_subalgebra","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : CompactSpace X\nA : Subalgebra Real (ContinuousMap X Real)\nh : IsClosed ‚ÜëA\nf g : Subtype fun x => Membership.mem A x\n‚ä¢ Membership.mem A (Max.max ‚Üëf ‚Üëg)","decl":"theorem sup_mem_closed_subalgebra (A : Subalgebra ‚Ñù C(X, ‚Ñù)) (h : IsClosed (A : Set C(X, ‚Ñù)))\n    (f g : A) : (f : C(X, ‚Ñù)) ‚äî (g : C(X, ‚Ñù)) ‚àà A := by\n  convert sup_mem_subalgebra_closure A f g\n  apply SetLike.ext'\n  symm\n  erw [closure_eq_iff_isClosed]\n  exact h\n\n"}
{"name":"ContinuousMap.sublattice_closure_eq_top","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : CompactSpace X\nL : Set (ContinuousMap X Real)\nnA : L.Nonempty\ninf_mem : ‚àÄ (f : ContinuousMap X Real), Membership.mem L f ‚Üí ‚àÄ (g : ContinuousMap X Real), Membership.mem L g ‚Üí Membership.mem L (Min.min f g)\nsup_mem : ‚àÄ (f : ContinuousMap X Real), Membership.mem L f ‚Üí ‚àÄ (g : ContinuousMap X Real), Membership.mem L g ‚Üí Membership.mem L (Max.max f g)\nsep : L.SeparatesPointsStrongly\n‚ä¢ Eq (closure L) Top.top","decl":"theorem sublattice_closure_eq_top (L : Set C(X, ‚Ñù)) (nA : L.Nonempty)\n    (inf_mem : ‚àÄ·µâ (f ‚àà L) (g ‚àà L), f ‚äì g ‚àà L)\n    (sup_mem : ‚àÄ·µâ (f ‚àà L) (g ‚àà L), f ‚äî g ‚àà L) (sep : L.SeparatesPointsStrongly) :\n    closure L = ‚ä§ := by\n  -- We start by boiling down to a statement about close approximation.\n  rw [eq_top_iff]\n  rintro f -\n  refine\n    Filter.Frequently.mem_closure\n      ((Filter.HasBasis.frequently_iff Metric.nhds_basis_ball).mpr fun Œµ pos => ?_)\n  simp only [exists_prop, Metric.mem_ball]\n  -- It will be helpful to assume `X` is nonempty later,\n  -- so we get that out of the way here.\n  by_cases nX : Nonempty X\n  swap\n  ¬∑ exact ‚ü®nA.some, (dist_lt_iff pos).mpr fun x => False.elim (nX ‚ü®x‚ü©), nA.choose_spec‚ü©\n  /-\n    The strategy now is to pick a family of continuous functions `g x y` in `A`\n    with the property that `g x y x = f x` and `g x y y = f y`\n    (this is immediate from `h : SeparatesPointsStrongly`)\n    then use continuity to see that `g x y` is close to `f` near both `x` and `y`,\n    and finally using compactness to produce the desired function `h`\n    as a maximum over finitely many `x` of a minimum over finitely many `y` of the `g x y`.\n    -/\n  dsimp only [Set.SeparatesPointsStrongly] at sep\n  choose g hg w‚ÇÅ w‚ÇÇ using sep f\n  -- For each `x y`, we define `U x y` to be `{z | f z - Œµ < g x y z}`,\n  -- and observe this is a neighbourhood of `y`.\n  let U : X ‚Üí X ‚Üí Set X := fun x y => {z | f z - Œµ < g x y z}\n  have U_nhd_y : ‚àÄ x y, U x y ‚àà ùìù y := by\n    intro x y\n    refine IsOpen.mem_nhds ?_ ?_\n    ¬∑ apply isOpen_lt <;> continuity\n    ¬∑ rw [Set.mem_setOf_eq, w‚ÇÇ]\n      exact sub_lt_self _ pos\n  -- Fixing `x` for a moment, we have a family of functions `fun y ‚Ü¶ g x y`\n  -- which on different patches (the `U x y`) are greater than `f z - Œµ`.\n  -- Taking the supremum of these functions\n  -- indexed by a finite collection of patches which cover `X`\n  -- will give us an element of `A` that is globally greater than `f z - Œµ`\n  -- and still equal to `f x` at `x`.\n  -- Since `X` is compact, for every `x` there is some finset `ys t`\n  -- so the union of the `U x y` for `y ‚àà ys x` still covers everything.\n  let ys : X ‚Üí Finset X := fun x => (CompactSpace.elim_nhds_subcover (U x) (U_nhd_y x)).choose\n  let ys_w : ‚àÄ x, ‚ãÉ y ‚àà ys x, U x y = ‚ä§ := fun x =>\n    (CompactSpace.elim_nhds_subcover (U x) (U_nhd_y x)).choose_spec\n  have ys_nonempty : ‚àÄ x, (ys x).Nonempty := fun x =>\n    Set.nonempty_of_union_eq_top_of_nonempty _ _ nX (ys_w x)\n  -- Thus for each `x` we have the desired `h x : A` so `f z - Œµ < h x z` everywhere\n  -- and `h x x = f x`.\n  let h : X ‚Üí L := fun x =>\n    ‚ü®(ys x).sup' (ys_nonempty x) fun y => (g x y : C(X, ‚Ñù)),\n      Finset.sup'_mem _ sup_mem _ _ _ fun y _ => hg x y‚ü©\n  have lt_h : ‚àÄ x z, f z - Œµ < (h x : X ‚Üí ‚Ñù) z := by\n    intro x z\n    obtain ‚ü®y, ym, zm‚ü© := Set.exists_set_mem_of_union_eq_top _ _ (ys_w x) z\n    dsimp [h]\n    simp only [Subtype.coe_mk, coe_sup', Finset.sup'_apply, Finset.lt_sup'_iff]\n    exact ‚ü®y, ym, zm‚ü©\n  have h_eq : ‚àÄ x, (h x : X ‚Üí ‚Ñù) x = f x := by intro x; simp [h, w‚ÇÅ]\n  -- For each `x`, we define `W x` to be `{z | h x z < f z + Œµ}`,\n  let W : X ‚Üí Set X := fun x => {z | (h x : X ‚Üí ‚Ñù) z < f z + Œµ}\n  -- This is still a neighbourhood of `x`.\n  have W_nhd : ‚àÄ x, W x ‚àà ùìù x := by\n    intro x\n    refine IsOpen.mem_nhds ?_ ?_\n    ¬∑ apply isOpen_lt <;> fun_prop\n    ¬∑ dsimp only [W, Set.mem_setOf_eq]\n      rw [h_eq]\n      exact lt_add_of_pos_right _ pos\n  -- Since `X` is compact, there is some finset `ys t`\n  -- so the union of the `W x` for `x ‚àà xs` still covers everything.\n  let xs : Finset X := (CompactSpace.elim_nhds_subcover W W_nhd).choose\n  let xs_w : ‚ãÉ x ‚àà xs, W x = ‚ä§ := (CompactSpace.elim_nhds_subcover W W_nhd).choose_spec\n  have xs_nonempty : xs.Nonempty := Set.nonempty_of_union_eq_top_of_nonempty _ _ nX xs_w\n  -- Finally our candidate function is the infimum over `x ‚àà xs` of the `h x`.\n  -- This function is then globally less than `f z + Œµ`.\n  let k : (L : Type _) :=\n    ‚ü®xs.inf' xs_nonempty fun x => (h x : C(X, ‚Ñù)),\n      Finset.inf'_mem _ inf_mem _ _ _ fun x _ => (h x).2‚ü©\n  refine ‚ü®k.1, ?_, k.2‚ü©\n  -- We just need to verify the bound, which we do pointwise.\n  rw [dist_lt_iff pos]\n  intro z\n  -- We rewrite into this particular form,\n  -- so that simp lemmas about inequalities involving `Finset.inf'` can fire.\n  rw [show ‚àÄ a b Œµ : ‚Ñù, dist a b < Œµ ‚Üî a < b + Œµ ‚àß b - Œµ < a by\n        intros; simp only [‚Üê Metric.mem_ball, Real.ball_eq_Ioo, Set.mem_Ioo, and_comm]]\n  fconstructor\n  ¬∑ dsimp\n    simp only [k, Finset.inf'_lt_iff, ContinuousMap.inf'_apply]\n    exact Set.exists_set_mem_of_union_eq_top _ _ xs_w z\n  ¬∑ dsimp\n    simp only [k, Finset.lt_inf'_iff, ContinuousMap.inf'_apply]\n    rintro x -\n    apply lt_h\n\n"}
{"name":"ContinuousMap.subalgebra_topologicalClosure_eq_top_of_separatesPoints","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : CompactSpace X\nA : Subalgebra Real (ContinuousMap X Real)\nw : A.SeparatesPoints\n‚ä¢ Eq A.topologicalClosure Top.top","decl":"/-- The **Stone-Weierstrass Approximation Theorem**,\nthat a subalgebra `A` of `C(X, ‚Ñù)`, where `X` is a compact topological space,\nis dense if it separates points.\n-/\ntheorem subalgebra_topologicalClosure_eq_top_of_separatesPoints (A : Subalgebra ‚Ñù C(X, ‚Ñù))\n    (w : A.SeparatesPoints) : A.topologicalClosure = ‚ä§ := by\n  -- The closure of `A` is closed under taking `sup` and `inf`,\n  -- and separates points strongly (since `A` does),\n  -- so we can apply `sublattice_closure_eq_top`.\n  apply SetLike.ext'\n  let L := A.topologicalClosure\n  have n : Set.Nonempty (L : Set C(X, ‚Ñù)) := ‚ü®(1 : C(X, ‚Ñù)), A.le_topologicalClosure A.one_mem‚ü©\n  convert\n    sublattice_closure_eq_top (L : Set C(X, ‚Ñù)) n\n      (fun f fm g gm => inf_mem_closed_subalgebra L A.isClosed_topologicalClosure ‚ü®f, fm‚ü© ‚ü®g, gm‚ü©)\n      (fun f fm g gm => sup_mem_closed_subalgebra L A.isClosed_topologicalClosure ‚ü®f, fm‚ü© ‚ü®g, gm‚ü©)\n      (Subalgebra.SeparatesPoints.strongly\n        (Subalgebra.separatesPoints_monotone A.le_topologicalClosure w))\n  simp [L]\n\n"}
{"name":"ContinuousMap.continuousMap_mem_subalgebra_closure_of_separatesPoints","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : CompactSpace X\nA : Subalgebra Real (ContinuousMap X Real)\nw : A.SeparatesPoints\nf : ContinuousMap X Real\n‚ä¢ Membership.mem A.topologicalClosure f","decl":"/-- An alternative statement of the Stone-Weierstrass theorem.\n\nIf `A` is a subalgebra of `C(X, ‚Ñù)` which separates points (and `X` is compact),\nevery real-valued continuous function on `X` is a uniform limit of elements of `A`.\n-/\ntheorem continuousMap_mem_subalgebra_closure_of_separatesPoints (A : Subalgebra ‚Ñù C(X, ‚Ñù))\n    (w : A.SeparatesPoints) (f : C(X, ‚Ñù)) : f ‚àà A.topologicalClosure := by\n  rw [subalgebra_topologicalClosure_eq_top_of_separatesPoints A w]\n  simp\n\n"}
{"name":"ContinuousMap.exists_mem_subalgebra_near_continuousMap_of_separatesPoints","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : CompactSpace X\nA : Subalgebra Real (ContinuousMap X Real)\nw : A.SeparatesPoints\nf : ContinuousMap X Real\nŒµ : Real\npos : LT.lt 0 Œµ\n‚ä¢ Exists fun g => LT.lt (Norm.norm (HSub.hSub (‚Üëg) f)) Œµ","decl":"/-- An alternative statement of the Stone-Weierstrass theorem,\nfor those who like their epsilons.\n\nIf `A` is a subalgebra of `C(X, ‚Ñù)` which separates points (and `X` is compact),\nevery real-valued continuous function on `X` is within any `Œµ > 0` of some element of `A`.\n-/\ntheorem exists_mem_subalgebra_near_continuousMap_of_separatesPoints (A : Subalgebra ‚Ñù C(X, ‚Ñù))\n    (w : A.SeparatesPoints) (f : C(X, ‚Ñù)) (Œµ : ‚Ñù) (pos : 0 < Œµ) :\n    ‚àÉ g : A, ‚Äñ(g : C(X, ‚Ñù)) - f‚Äñ < Œµ := by\n  have w :=\n    mem_closure_iff_frequently.mp (continuousMap_mem_subalgebra_closure_of_separatesPoints A w f)\n  rw [Metric.nhds_basis_ball.frequently_iff] at w\n  obtain ‚ü®g, H, m‚ü© := w Œµ pos\n  rw [Metric.mem_ball, dist_eq_norm] at H\n  exact ‚ü®‚ü®g, m‚ü©, H‚ü©\n\n"}
{"name":"ContinuousMap.exists_mem_subalgebra_near_continuous_of_separatesPoints","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : CompactSpace X\nA : Subalgebra Real (ContinuousMap X Real)\nw : A.SeparatesPoints\nf : X ‚Üí Real\nc : Continuous f\nŒµ : Real\npos : LT.lt 0 Œµ\n‚ä¢ Exists fun g => ‚àÄ (x : X), LT.lt (Norm.norm (HSub.hSub (‚Üëg x) (f x))) Œµ","decl":"/-- An alternative statement of the Stone-Weierstrass theorem,\nfor those who like their epsilons and don't like bundled continuous functions.\n\nIf `A` is a subalgebra of `C(X, ‚Ñù)` which separates points (and `X` is compact),\nevery real-valued continuous function on `X` is within any `Œµ > 0` of some element of `A`.\n-/\ntheorem exists_mem_subalgebra_near_continuous_of_separatesPoints (A : Subalgebra ‚Ñù C(X, ‚Ñù))\n    (w : A.SeparatesPoints) (f : X ‚Üí ‚Ñù) (c : Continuous f) (Œµ : ‚Ñù) (pos : 0 < Œµ) :\n    ‚àÉ g : A, ‚àÄ x, ‚Äñ(g : X ‚Üí ‚Ñù) x - f x‚Äñ < Œµ := by\n  obtain ‚ü®g, b‚ü© := exists_mem_subalgebra_near_continuousMap_of_separatesPoints A w ‚ü®f, c‚ü© Œµ pos\n  use g\n  rwa [norm_lt_iff _ pos] at b\n\n"}
{"name":"Subalgebra.SeparatesPoints.rclike_to_real","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"ùïú : Type u_1\nX : Type u_2\ninst‚úù¬π : RCLike ùïú\ninst‚úù : TopologicalSpace X\nA : StarSubalgebra ùïú (ContinuousMap X ùïú)\nhA : A.SeparatesPoints\n‚ä¢ (Subalgebra.comap (AlgHom.compLeftContinuous Real RCLike.ofRealAm ‚ãØ) (Subalgebra.restrictScalars Real A.toSubalgebra)).SeparatesPoints","decl":"/-- If a star subalgebra of `C(X, ùïú)` separates points, then the real subalgebra\nof its purely real-valued elements also separates points. -/\ntheorem Subalgebra.SeparatesPoints.rclike_to_real {A : StarSubalgebra ùïú C(X, ùïú)}\n    (hA : A.SeparatesPoints) :\n      ((A.restrictScalars ‚Ñù).comap\n        (ofRealAm.compLeftContinuous ‚Ñù continuous_ofReal)).SeparatesPoints := by\n  intro x‚ÇÅ x‚ÇÇ hx\n  -- Let `f` in the subalgebra `A` separate the points `x‚ÇÅ`, `x‚ÇÇ`\n  obtain ‚ü®_, ‚ü®f, hfA, rfl‚ü©, hf‚ü© := hA hx\n  let F : C(X, ùïú) := f - const _ (f x‚ÇÇ)\n  -- Subtract the constant `f x‚ÇÇ` from `f`; this is still an element of the subalgebra\n  have hFA : F ‚àà A := by\n    refine A.sub_mem hfA (@Eq.subst _ (¬∑ ‚àà A) _ _ ?_ <| A.smul_mem A.one_mem <| f x‚ÇÇ)\n    ext1\n    simp only [coe_smul, coe_one, smul_apply, one_apply, Algebra.id.smul_eq_mul, mul_one,\n      const_apply]\n  -- Consider now the function `fun x ‚Ü¶ |f x - f x‚ÇÇ| ^ 2`\n  refine ‚ü®_, ‚ü®‚ü®(‚ÄñF ¬∑‚Äñ ^ 2), by continuity‚ü©, ?_, rfl‚ü©, ?_‚ü©\n  ¬∑ -- This is also an element of the subalgebra, and takes only real values\n    rw [SetLike.mem_coe, Subalgebra.mem_comap]\n    convert (A.restrictScalars ‚Ñù).mul_mem hFA (star_mem hFA : star F ‚àà A)\n    ext1\n    simp [‚Üê RCLike.mul_conj]\n  ¬∑ -- And it also separates the points `x‚ÇÅ`, `x‚ÇÇ`\n    simpa [F] using sub_ne_zero.mpr hf\n\n"}
{"name":"ContinuousMap.starSubalgebra_topologicalClosure_eq_top_of_separatesPoints","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"ùïú : Type u_1\nX : Type u_2\ninst‚úù¬≤ : RCLike ùïú\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : CompactSpace X\nA : StarSubalgebra ùïú (ContinuousMap X ùïú)\nhA : A.SeparatesPoints\n‚ä¢ Eq A.topologicalClosure Top.top","decl":"/-- The Stone-Weierstrass approximation theorem, `RCLike` version, that a star subalgebra `A` of\n`C(X, ùïú)`, where `X` is a compact topological space and `RCLike ùïú`, is dense if it separates\npoints. -/\ntheorem ContinuousMap.starSubalgebra_topologicalClosure_eq_top_of_separatesPoints\n    (A : StarSubalgebra ùïú C(X, ùïú)) (hA : A.SeparatesPoints) : A.topologicalClosure = ‚ä§ := by\n  rw [StarSubalgebra.eq_top_iff]\n  -- Let `I` be the natural inclusion of `C(X, ‚Ñù)` into `C(X, ùïú)`\n  let I : C(X, ‚Ñù) ‚Üí‚Çó[‚Ñù] C(X, ùïú) := ofRealCLM.compLeftContinuous ‚Ñù X\n  -- The main point of the proof is that its range (i.e., every real-valued function) is contained\n  -- in the closure of `A`\n  have key : LinearMap.range I ‚â§ (A.toSubmodule.restrictScalars ‚Ñù).topologicalClosure := by\n    -- Let `A‚ÇÄ` be the subalgebra of `C(X, ‚Ñù)` consisting of `A`'s purely real elements; it is the\n    -- preimage of `A` under `I`.  In this argument we only need its submodule structure.\n    let A‚ÇÄ : Submodule ‚Ñù C(X, ‚Ñù) := (A.toSubmodule.restrictScalars ‚Ñù).comap I\n    -- By `Subalgebra.SeparatesPoints.rclike_to_real`, this subalgebra also separates points, so\n    -- we may apply the real Stone-Weierstrass result to it.\n    have SW : A‚ÇÄ.topologicalClosure = ‚ä§ :=\n      haveI := subalgebra_topologicalClosure_eq_top_of_separatesPoints _ hA.rclike_to_real\n      congr_arg Subalgebra.toSubmodule this\n    rw [‚Üê Submodule.map_top, ‚Üê SW]\n    -- So it suffices to prove that the image under `I` of the closure of `A‚ÇÄ` is contained in the\n    -- closure of `A`, which follows by abstract nonsense\n    have h‚ÇÅ := A‚ÇÄ.topologicalClosure_map ((@ofRealCLM ùïú _).compLeftContinuousCompact X)\n    have h‚ÇÇ := (A.toSubmodule.restrictScalars ‚Ñù).map_comap_le I\n    exact h‚ÇÅ.trans (Submodule.topologicalClosure_mono h‚ÇÇ)\n  -- In particular, for a function `f` in `C(X, ùïú)`, the real and imaginary parts of `f` are in the\n  -- closure of `A`\n  intro f\n  let f_re : C(X, ‚Ñù) := (‚ü®RCLike.re, RCLike.reCLM.continuous‚ü© : C(ùïú, ‚Ñù)).comp f\n  let f_im : C(X, ‚Ñù) := (‚ü®RCLike.im, RCLike.imCLM.continuous‚ü© : C(ùïú, ‚Ñù)).comp f\n  have h_f_re : I f_re ‚àà A.topologicalClosure := key ‚ü®f_re, rfl‚ü©\n  have h_f_im : I f_im ‚àà A.topologicalClosure := key ‚ü®f_im, rfl‚ü©\n  -- So `f_re + I ‚Ä¢ f_im` is in the closure of `A`\n  have := A.topologicalClosure.add_mem h_f_re (A.topologicalClosure.smul_mem h_f_im RCLike.I)\n  rw [StarSubalgebra.mem_toSubalgebra] at this\n  convert this\n  -- And this, of course, is just `f`\n  ext\n  apply Eq.symm\n  simp [I, f_re, f_im, mul_comm RCLike.I _]\n\n"}
{"name":"polynomialFunctions.topologicalClosure","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"s : Set Real\ninst‚úù : CompactSpace ‚Üës\n‚ä¢ Eq (polynomialFunctions s).topologicalClosure Top.top","decl":"/-- Polynomial functions in are dense in `C(s, ‚Ñù)` when `s` is compact.\n\nSee `polynomialFunctions_closure_eq_top` for the special case `s = Set.Icc a b` which does not use\nthe full Stone-Weierstrass theorem. Of course, that version could be used to prove this one as\nwell. -/\ntheorem polynomialFunctions.topologicalClosure (s : Set ‚Ñù)\n    [CompactSpace s] : (polynomialFunctions s).topologicalClosure = ‚ä§ :=\n  ContinuousMap.subalgebra_topologicalClosure_eq_top_of_separatesPoints _\n    (polynomialFunctions_separatesPoints s)\n\n"}
{"name":"polynomialFunctions.starClosure_topologicalClosure","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"ùïú : Type u_1\ninst‚úù¬π : RCLike ùïú\ns : Set ùïú\ninst‚úù : CompactSpace ‚Üës\n‚ä¢ Eq (polynomialFunctions s).starClosure.topologicalClosure Top.top","decl":"/-- The star subalgebra generated by polynomials functions is dense in `C(s, ùïú)` when `s` is\ncompact and `ùïú` is either `‚Ñù` or `‚ÑÇ`. -/\ntheorem polynomialFunctions.starClosure_topologicalClosure {ùïú : Type*} [RCLike ùïú] (s : Set ùïú)\n    [CompactSpace s] : (polynomialFunctions s).starClosure.topologicalClosure = ‚ä§ :=\n  ContinuousMap.starSubalgebra_topologicalClosure_eq_top_of_separatesPoints _\n    (Subalgebra.separatesPoints_monotone le_sup_left (polynomialFunctions_separatesPoints s))\n\n"}
{"name":"ContinuousMap.induction_on","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"ùïú : Type u_1\ninst‚úù : RCLike ùïú\ns : Set ùïú\np : ContinuousMap (‚Üës) ùïú ‚Üí Prop\nconst : ‚àÄ (r : ùïú), p (ContinuousMap.const (‚Üës) r)\nid : p (ContinuousMap.restrict s (ContinuousMap.id ùïú))\nstar_id : p (Star.star (ContinuousMap.restrict s (ContinuousMap.id ùïú)))\nadd : ‚àÄ (f g : ContinuousMap (‚Üës) ùïú), p f ‚Üí p g ‚Üí p (HAdd.hAdd f g)\nmul : ‚àÄ (f g : ContinuousMap (‚Üës) ùïú), p f ‚Üí p g ‚Üí p (HMul.hMul f g)\nclosure : (‚àÄ (f : ContinuousMap (‚Üës) ùïú), Membership.mem (polynomialFunctions s).starClosure f ‚Üí p f) ‚Üí ‚àÄ (f : ContinuousMap (‚Üës) ùïú), p f\nf : ContinuousMap (‚Üës) ùïú\n‚ä¢ p f","decl":"/-- An induction principle for `C(s, ùïú)`. -/\n@[elab_as_elim]\ntheorem ContinuousMap.induction_on {ùïú : Type*} [RCLike ùïú] {s : Set ùïú}\n    {p : C(s, ùïú) ‚Üí Prop} (const : ‚àÄ r, p (.const s r)) (id : p (.restrict s <| .id ùïú))\n    (star_id : p (star (.restrict s <| .id ùïú)))\n    (add : ‚àÄ f g, p f ‚Üí p g ‚Üí p (f + g)) (mul : ‚àÄ f g, p f ‚Üí p g ‚Üí p (f * g))\n    (closure : (‚àÄ f ‚àà (polynomialFunctions s).starClosure, p f) ‚Üí ‚àÄ f, p f) (f : C(s, ùïú)) :\n    p f := by\n  refine closure (fun f hf => ?_) f\n  rw [polynomialFunctions.starClosure_eq_adjoin_X] at hf\n  induction hf using Algebra.adjoin_induction with\n  | mem f hf =>\n    simp only [Set.mem_union, Set.mem_singleton_iff, Set.mem_star] at hf\n    rw [star_eq_iff_star_eq, eq_comm (b := f)] at hf\n    obtain (rfl | rfl) := hf\n    all_goals simpa only [toContinuousMapOnAlgHom_apply, toContinuousMapOn_X_eq_restrict_id]\n  | algebraMap r => exact const r\n  | add _ _ _ _ hf hg => exact add _ _ hf hg\n  | mul _ _ _ _ hf hg => exact mul _ _ hf hg\n\n"}
{"name":"ContinuousMap.induction_on_of_compact","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"ùïú : Type u_1\ninst‚úù¬π : RCLike ùïú\ns : Set ùïú\ninst‚úù : CompactSpace ‚Üës\np : ContinuousMap (‚Üës) ùïú ‚Üí Prop\nconst : ‚àÄ (r : ùïú), p (ContinuousMap.const (‚Üës) r)\nid : p (ContinuousMap.restrict s (ContinuousMap.id ùïú))\nstar_id : p (Star.star (ContinuousMap.restrict s (ContinuousMap.id ùïú)))\nadd : ‚àÄ (f g : ContinuousMap (‚Üës) ùïú), p f ‚Üí p g ‚Üí p (HAdd.hAdd f g)\nmul : ‚àÄ (f g : ContinuousMap (‚Üës) ùïú), p f ‚Üí p g ‚Üí p (HMul.hMul f g)\nfrequently : ‚àÄ (f : ContinuousMap (‚Üës) ùïú), Filter.Frequently (fun g => p g) (nhds f) ‚Üí p f\nf : ContinuousMap (‚Üës) ùïú\n‚ä¢ p f","decl":"open Topology in\n@[elab_as_elim]\ntheorem ContinuousMap.induction_on_of_compact {ùïú : Type*} [RCLike ùïú] {s : Set ùïú} [CompactSpace s]\n    {p : C(s, ùïú) ‚Üí Prop} (const : ‚àÄ r, p (.const s r)) (id : p (.restrict s <| .id ùïú))\n    (star_id : p (star (.restrict s <| .id ùïú)))\n    (add : ‚àÄ f g, p f ‚Üí p g ‚Üí p (f + g)) (mul : ‚àÄ f g, p f ‚Üí p g ‚Üí p (f * g))\n    (frequently : ‚àÄ f, (‚àÉ·∂† g in ùìù f, p g) ‚Üí p f) (f : C(s, ùïú)) :\n    p f := by\n  refine f.induction_on const id star_id add mul fun h f ‚Ü¶ frequently f ?_\n  have := polynomialFunctions.starClosure_topologicalClosure s ‚ñ∏ mem_top (x := f)\n  rw [‚Üê SetLike.mem_coe, topologicalClosure_coe, mem_closure_iff_frequently] at this\n  exact this.mp <| .of_forall h\n\n"}
{"name":"ContinuousMap.algHom_ext_map_X","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"A : Type u_1\ninst‚úù‚Å¥ : Ring A\ninst‚úù¬≥ : Algebra Real A\ninst‚úù¬≤ : TopologicalSpace A\ninst‚úù¬π : T2Space A\ns : Set Real\ninst‚úù : CompactSpace ‚Üës\nœÜ œà : AlgHom Real (ContinuousMap (‚Üës) Real) A\nhœÜ : Continuous ‚áëœÜ\nhœà : Continuous ‚áëœà\nh : Eq (œÜ ((Polynomial.toContinuousMapOnAlgHom s) Polynomial.X)) (œà ((Polynomial.toContinuousMapOnAlgHom s) Polynomial.X))\n‚ä¢ Eq œÜ œà","decl":"/-- Continuous algebra homomorphisms from `C(s, ‚Ñù)` into an `‚Ñù`-algebra `A` which agree\nat `X : ùïú[X]` (interpreted as a continuous map) are, in fact, equal. -/\n@[ext (iff := false)]\ntheorem ContinuousMap.algHom_ext_map_X {A : Type*} [Ring A]\n    [Algebra ‚Ñù A] [TopologicalSpace A] [T2Space A] {s : Set ‚Ñù} [CompactSpace s]\n    {œÜ œà : C(s, ‚Ñù) ‚Üí‚Çê[‚Ñù] A} (hœÜ : Continuous œÜ) (hœà : Continuous œà)\n    (h : œÜ (toContinuousMapOnAlgHom s X) = œà (toContinuousMapOnAlgHom s X)) : œÜ = œà := by\n  suffices (‚ä§ : Subalgebra ‚Ñù C(s, ‚Ñù)) ‚â§ AlgHom.equalizer œÜ œà from\n    AlgHom.ext fun x => this (by trivial)\n  rw [‚Üê polynomialFunctions.topologicalClosure s]\n  exact Subalgebra.topologicalClosure_minimal (polynomialFunctions s)\n    (polynomialFunctions.le_equalizer s œÜ œà h) (isClosed_eq hœÜ hœà)\n\n"}
{"name":"ContinuousMap.starAlgHom_ext_map_X","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"ùïú : Type u_1\nA : Type u_2\ninst‚úù‚Å∂ : RCLike ùïú\ninst‚úù‚Åµ : Ring A\ninst‚úù‚Å¥ : StarRing A\ninst‚úù¬≥ : Algebra ùïú A\ninst‚úù¬≤ : TopologicalSpace A\ninst‚úù¬π : T2Space A\ns : Set ùïú\ninst‚úù : CompactSpace ‚Üës\nœÜ œà : StarAlgHom ùïú (ContinuousMap (‚Üës) ùïú) A\nhœÜ : Continuous ‚áëœÜ\nhœà : Continuous ‚áëœà\nh : Eq (œÜ ((Polynomial.toContinuousMapOnAlgHom s) Polynomial.X)) (œà ((Polynomial.toContinuousMapOnAlgHom s) Polynomial.X))\n‚ä¢ Eq œÜ œà","decl":"/-- Continuous star algebra homomorphisms from `C(s, ùïú)` into a star `ùïú`-algebra `A` which agree\nat `X : ùïú[X]` (interpreted as a continuous map) are, in fact, equal. -/\n@[ext (iff := false)]\ntheorem ContinuousMap.starAlgHom_ext_map_X {ùïú A : Type*} [RCLike ùïú] [Ring A] [StarRing A]\n    [Algebra ùïú A] [TopologicalSpace A] [T2Space A] {s : Set ùïú} [CompactSpace s]\n    {œÜ œà : C(s, ùïú) ‚Üí‚ãÜ‚Çê[ùïú] A} (hœÜ : Continuous œÜ) (hœà : Continuous œà)\n    (h : œÜ (toContinuousMapOnAlgHom s X) = œà (toContinuousMapOnAlgHom s X)) : œÜ = œà := by\n  suffices (‚ä§ : StarSubalgebra ùïú C(s, ùïú)) ‚â§ StarAlgHom.equalizer œÜ œà from\n    StarAlgHom.ext fun x => this mem_top\n  rw [‚Üê polynomialFunctions.starClosure_topologicalClosure s]\n  exact StarSubalgebra.topologicalClosure_minimal\n    (polynomialFunctions.starClosure_le_equalizer s œÜ œà h) (isClosed_eq hœÜ hœà)\n\n"}
{"name":"ContinuousMap.adjoin_id_eq_span_one_union","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"ùïú : Type u_1\ninst‚úù : RCLike ùïú\ns : Set ùïú\n‚ä¢ Eq ‚Üë(StarAlgebra.adjoin ùïú (Singleton.singleton (ContinuousMap.restrict s (ContinuousMap.id ùïú)))) ‚Üë(Submodule.span ùïú (Union.union (Singleton.singleton 1) ‚Üë(NonUnitalStarAlgebra.adjoin ùïú (Singleton.singleton (ContinuousMap.restrict s (ContinuousMap.id ùïú))))))","decl":"lemma adjoin_id_eq_span_one_union (s : Set ùïú) :\n    ((StarAlgebra.adjoin ùïú {(restrict s (.id ùïú) : C(s, ùïú))}) : Set C(s, ùïú)) =\n      span ùïú ({(1 : C(s, ùïú))} ‚à™ (adjoin ùïú {(restrict s (.id ùïú) : C(s, ùïú))})) := by\n  ext x\n  rw [SetLike.mem_coe, SetLike.mem_coe, ‚Üê StarAlgebra.adjoin_nonUnitalStarSubalgebra,\n    ‚Üê StarSubalgebra.mem_toSubalgebra, ‚Üê Subalgebra.mem_toSubmodule,\n    StarAlgebra.adjoin_nonUnitalStarSubalgebra_eq_span, span_union, span_eq_toSubmodule]\n\n"}
{"name":"ContinuousMap.adjoin_id_eq_span_one_add","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"ùïú : Type u_1\ninst‚úù : RCLike ùïú\ns : Set ùïú\n‚ä¢ Eq (‚Üë(StarAlgebra.adjoin ùïú (Singleton.singleton (ContinuousMap.restrict s (ContinuousMap.id ùïú))))) (HAdd.hAdd ‚Üë(Submodule.span ùïú (Singleton.singleton 1)) ‚Üë(NonUnitalStarAlgebra.adjoin ùïú (Singleton.singleton (ContinuousMap.restrict s (ContinuousMap.id ùïú)))))","decl":"open Pointwise in\nlemma adjoin_id_eq_span_one_add (s : Set ùïú) :\n    ((StarAlgebra.adjoin ùïú {(restrict s (.id ùïú) : C(s, ùïú))}) : Set C(s, ùïú)) =\n      (span ùïú {(1 : C(s, ùïú))} : Set C(s, ùïú)) + (adjoin ùïú {(restrict s (.id ùïú) : C(s, ùïú))}) := by\n  ext x\n  rw [SetLike.mem_coe, ‚Üê StarAlgebra.adjoin_nonUnitalStarSubalgebra,\n    ‚Üê StarSubalgebra.mem_toSubalgebra, ‚Üê Subalgebra.mem_toSubmodule,\n    StarAlgebra.adjoin_nonUnitalStarSubalgebra_eq_span, mem_sup]\n  simp [Set.mem_add]\n\n"}
{"name":"ContinuousMap.nonUnitalStarAlgebraAdjoin_id_subset_ker_evalStarAlgHom","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"ùïú : Type u_1\ninst‚úù : RCLike ùïú\ns : Set ùïú\nh0 : Membership.mem s 0\n‚ä¢ HasSubset.Subset ‚Üë(NonUnitalStarAlgebra.adjoin ùïú (Singleton.singleton (ContinuousMap.restrict s (ContinuousMap.id ùïú)))) ‚Üë(RingHom.ker (ContinuousMap.evalStarAlgHom ùïú ùïú ‚ü®0, h0‚ü©))","decl":"lemma nonUnitalStarAlgebraAdjoin_id_subset_ker_evalStarAlgHom {s : Set ùïú} (h0 : 0 ‚àà s) :\n    (adjoin ùïú {restrict s (.id ùïú)} : Set C(s, ùïú)) ‚äÜ\n      RingHom.ker (evalStarAlgHom ùïú ùïú (‚ü®0, h0‚ü© : s)) := by\n  intro f hf\n  induction hf using adjoin_induction with\n  | mem f hf =>\n    obtain rfl := Set.mem_singleton_iff.mp hf\n    rfl\n  | add f g _ _ hf hg => exact add_mem hf hg\n  | zero => exact zero_mem _\n  | mul f g _ _ _ hg => exact Ideal.mul_mem_left _ f hg\n  | smul r f _ hf =>\n    rw [SetLike.mem_coe, RingHom.mem_ker] at hf ‚ä¢\n    rw [map_smul, hf, smul_zero]\n  | star f _ hf =>\n    rw [SetLike.mem_coe, RingHom.mem_ker] at hf ‚ä¢\n    rw [map_star, hf, star_zero]\n\n"}
{"name":"ContinuousMap.ker_evalStarAlgHom_inter_adjoin_id","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"ùïú : Type u_1\ninst‚úù : RCLike ùïú\ns : Set ùïú\nh0 : Membership.mem s 0\n‚ä¢ Eq (Inter.inter ‚Üë(StarAlgebra.adjoin ùïú (Singleton.singleton (ContinuousMap.restrict s (ContinuousMap.id ùïú)))) ‚Üë(RingHom.ker (ContinuousMap.evalStarAlgHom ùïú ùïú ‚ü®0, h0‚ü©))) ‚Üë(NonUnitalStarAlgebra.adjoin ùïú (Singleton.singleton (ContinuousMap.restrict s (ContinuousMap.id ùïú))))","decl":"lemma ker_evalStarAlgHom_inter_adjoin_id (s : Set ùïú) (h0 : 0 ‚àà s) :\n    (StarAlgebra.adjoin ùïú {restrict s (.id ùïú)} : Set C(s, ùïú)) ‚à©\n      RingHom.ker (evalStarAlgHom ùïú ùïú (‚ü®0, h0‚ü© : s)) = adjoin ùïú {restrict s (.id ùïú)} := by\n  ext f\n  constructor\n  ¬∑ rintro ‚ü®hf‚ÇÅ, hf‚ÇÇ‚ü©\n    rw [SetLike.mem_coe] at hf‚ÇÇ ‚ä¢\n    simp_rw [adjoin_id_eq_span_one_add, Set.mem_add, SetLike.mem_coe, mem_span_singleton] at hf‚ÇÅ\n    obtain ‚ü®-, ‚ü®r, rfl‚ü©, f, hf, rfl‚ü© := hf‚ÇÅ\n    have := nonUnitalStarAlgebraAdjoin_id_subset_ker_evalStarAlgHom h0 hf\n    simp only [SetLike.mem_coe, RingHom.mem_ker, evalStarAlgHom_apply] at hf‚ÇÇ this\n    rw [add_apply, this, add_zero, smul_apply, one_apply, smul_eq_mul, mul_one] at hf‚ÇÇ\n    rwa [hf‚ÇÇ, zero_smul, zero_add]\n  ¬∑ simp only [Set.mem_inter_iff, SetLike.mem_coe]\n    refine fun hf ‚Ü¶ ‚ü®?_, nonUnitalStarAlgebraAdjoin_id_subset_ker_evalStarAlgHom h0 hf‚ü©\n    exact adjoin_le_starAlgebra_adjoin _ _ hf\n\n-- the statement should be in terms of non unital subalgebras, but we lack API\n"}
{"name":"ContinuousMap.AlgHom.closure_ker_inter","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"F : Type u_2\nS : Type u_3\nK : Type u_4\nA : Type u_5\ninst‚úù¬π¬≥ : CommRing K\ninst‚úù¬π¬≤ : Ring A\ninst‚úù¬π¬π : Algebra K A\ninst‚úù¬π‚Å∞ : TopologicalSpace K\ninst‚úù‚Åπ : T1Space K\ninst‚úù‚Å∏ : TopologicalSpace A\ninst‚úù‚Å∑ : ContinuousSub A\ninst‚úù‚Å∂ : ContinuousSMul K A\ninst‚úù‚Åµ : FunLike F A K\ninst‚úù‚Å¥ : AlgHomClass F K A K\ninst‚úù¬≥ : SetLike S A\ninst‚úù¬≤ : OneMemClass S A\ninst‚úù¬π : AddSubgroupClass S A\ninst‚úù : SMulMemClass S K A\nœÜ : F\nhœÜ : Continuous ‚áëœÜ\ns : S\n‚ä¢ Eq (closure (Inter.inter ‚Üës ‚Üë(RingHom.ker œÜ))) (Inter.inter (closure ‚Üës) ‚Üë(RingHom.ker œÜ))","decl":"open RingHom Filter Topology in\ntheorem AlgHom.closure_ker_inter {F S K A : Type*} [CommRing K] [Ring A] [Algebra K A]\n    [TopologicalSpace K] [T1Space K] [TopologicalSpace A] [ContinuousSub A] [ContinuousSMul K A]\n    [FunLike F A K] [AlgHomClass F K A K] [SetLike S A] [OneMemClass S A] [AddSubgroupClass S A]\n    [SMulMemClass S K A] (œÜ : F) (hœÜ : Continuous œÜ) (s : S) :\n    closure (s ‚à© RingHom.ker œÜ) = closure s ‚à© (ker œÜ : Set A) := by\n  refine subset_antisymm ?_ ?_\n  ¬∑ simpa only [ker_eq, (isClosed_singleton.preimage hœÜ).closure_eq]\n      using closure_inter_subset_inter_closure s (ker œÜ : Set A)\n  ¬∑ intro x ‚ü®hxs, (hxœÜ : œÜ x = 0)‚ü©\n    rw [mem_closure_iff_clusterPt, ClusterPt] at hxs\n    have : Tendsto (fun y ‚Ü¶ y - œÜ y ‚Ä¢ 1) (ùìù x ‚äì ùìü s) (ùìù x) := by\n      conv => congr; rfl; rfl; rw [‚Üê sub_zero x, ‚Üê zero_smul K 1, ‚Üê hxœÜ]\n      exact Filter.tendsto_inf_left (Continuous.tendsto (by fun_prop) x)\n    refine mem_closure_of_tendsto this <| eventually_inf_principal.mpr ?_\n    filter_upwards [] with g hg using\n      ‚ü®sub_mem hg (SMulMemClass.smul_mem _ <| one_mem _), by simp [RingHom.mem_ker]‚ü©\n\n"}
{"name":"ContinuousMap.ker_evalStarAlgHom_eq_closure_adjoin_id","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"ùïú : Type u_1\ninst‚úù¬π : RCLike ùïú\ns : Set ùïú\nh0 : Membership.mem s 0\ninst‚úù : CompactSpace ‚Üës\n‚ä¢ Eq (‚Üë(RingHom.ker (ContinuousMap.evalStarAlgHom ùïú ùïú ‚ü®0, h0‚ü©))) (closure ‚Üë(NonUnitalStarAlgebra.adjoin ùïú (Singleton.singleton (ContinuousMap.restrict s (ContinuousMap.id ùïú)))))","decl":"lemma ker_evalStarAlgHom_eq_closure_adjoin_id (s : Set ùïú) (h0 : 0 ‚àà s) [CompactSpace s] :\n    (RingHom.ker (evalStarAlgHom ùïú ùïú (‚ü®0, h0‚ü© : s)) : Set C(s, ùïú)) =\n      closure (adjoin ùïú {(restrict s (.id ùïú))}) := by\n  rw [‚Üê ker_evalStarAlgHom_inter_adjoin_id s h0,\n    AlgHom.closure_ker_inter (œÜ := evalStarAlgHom ùïú ùïú (X := s) ‚ü®0, h0‚ü©) (continuous_eval_const _) _]\n  convert (Set.univ_inter _).symm\n  rw [‚Üê Polynomial.toContinuousMapOn_X_eq_restrict_id, ‚Üê Polynomial.toContinuousMapOnAlgHom_apply,\n    ‚Üê polynomialFunctions.starClosure_eq_adjoin_X s]\n  congrm(($(polynomialFunctions.starClosure_topologicalClosure s) : Set C(s, ùïú)))\n\n"}
{"name":"ContinuousMapZero.adjoin_id_dense","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"ùïú : Type u_1\ninst‚úù¬≤ : RCLike ùïú\ns : Set ùïú\ninst‚úù¬π : Zero ‚Üës\nh0 : Eq (‚Üë0) 0\ninst‚úù : CompactSpace ‚Üës\n‚ä¢ Dense ‚Üë(NonUnitalStarAlgebra.adjoin ùïú (Singleton.singleton (ContinuousMapZero.id h0)))","decl":"/-- If `s : Set ùïú` with `RCLike ùïú` is compact and contains `0`, then the non-unital star subalgebra\ngenerated by the identity function in `C(s, ùïú)‚ÇÄ` is dense. This can be seen as a version of the\nWeierstrass approximation theorem. -/\nlemma ContinuousMapZero.adjoin_id_dense {s : Set ùïú} [Zero s] (h0 : ((0 : s) : ùïú) = 0)\n    [CompactSpace s] : Dense (adjoin ùïú {(.id h0 : C(s, ùïú)‚ÇÄ)} : Set C(s, ùïú)‚ÇÄ) := by\n  have h0' : 0 ‚àà s := h0 ‚ñ∏ (0 : s).property\n  rw [dense_iff_closure_eq,\n    ‚Üê isClosedEmbedding_toContinuousMap.injective.preimage_image (closure _),\n    ‚Üê isClosedEmbedding_toContinuousMap.closure_image_eq, ‚Üê coe_toContinuousMapHom,\n    ‚Üê NonUnitalStarSubalgebra.coe_map, NonUnitalStarAlgHom.map_adjoin_singleton,\n    toContinuousMapHom_apply, toContinuousMap_id h0,\n    ‚Üê ContinuousMap.ker_evalStarAlgHom_eq_closure_adjoin_id s h0']\n  apply Set.eq_univ_of_forall fun f ‚Ü¶ ?_\n  simp only [Set.mem_preimage, toContinuousMapHom_apply, SetLike.mem_coe, RingHom.mem_ker,\n    ContinuousMap.evalStarAlgHom_apply, ContinuousMap.coe_coe]\n  rw [show ‚ü®0, h0'‚ü© = (0 : s) by ext; exact h0.symm, _root_.map_zero f]\n\n"}
{"name":"ContinuousMapZero.induction_on","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"ùïú : Type u_1\ninst‚úù¬π : RCLike ùïú\ns : Set ùïú\ninst‚úù : Zero ‚Üës\nh0 : Eq (‚Üë0) 0\np : ContinuousMapZero (‚Üës) ùïú ‚Üí Prop\nzero : p 0\nid : p (ContinuousMapZero.id h0)\nstar_id : p (Star.star (ContinuousMapZero.id h0))\nadd : ‚àÄ (f g : ContinuousMapZero (‚Üës) ùïú), p f ‚Üí p g ‚Üí p (HAdd.hAdd f g)\nmul : ‚àÄ (f g : ContinuousMapZero (‚Üës) ùïú), p f ‚Üí p g ‚Üí p (HMul.hMul f g)\nsmul : ‚àÄ (r : ùïú) (f : ContinuousMapZero (‚Üës) ùïú), p f ‚Üí p (HSMul.hSMul r f)\nclosure : (‚àÄ (f : ContinuousMapZero (‚Üës) ùïú), Membership.mem (NonUnitalStarAlgebra.adjoin ùïú (Singleton.singleton (ContinuousMapZero.id h0))) f ‚Üí p f) ‚Üí ‚àÄ (f : ContinuousMapZero (‚Üës) ùïú), p f\nf : ContinuousMapZero (‚Üës) ùïú\n‚ä¢ p f","decl":"/-- An induction principle for `C(s, ùïú)‚ÇÄ`. -/\n@[elab_as_elim]\nlemma ContinuousMapZero.induction_on {s : Set ùïú} [Zero s] (h0 : ((0 : s) : ùïú) = 0)\n    {p : C(s, ùïú)‚ÇÄ ‚Üí Prop} (zero : p 0) (id : p (.id h0)) (star_id : p (star (.id h0)))\n    (add : ‚àÄ f g, p f ‚Üí p g ‚Üí p (f + g)) (mul : ‚àÄ f g, p f ‚Üí p g ‚Üí p (f * g))\n    (smul : ‚àÄ (r : ùïú) f, p f ‚Üí p (r ‚Ä¢ f))\n    (closure : (‚àÄ f ‚àà adjoin ùïú {(.id h0 : C(s, ùïú)‚ÇÄ)}, p f) ‚Üí ‚àÄ f, p f) (f : C(s, ùïú)‚ÇÄ) :\n    p f := by\n  refine closure (fun f hf => ?_) f\n  induction hf using NonUnitalAlgebra.adjoin_induction with\n  | mem f hf =>\n    simp only [Set.mem_union, Set.mem_singleton_iff, Set.mem_star] at hf\n    rw [star_eq_iff_star_eq, eq_comm (b := f)] at hf\n    obtain (rfl | rfl) := hf\n    all_goals assumption\n  | zero => exact zero\n  | add _ _ _ _ hf hg => exact add _ _ hf hg\n  | mul _ _ _ _ hf hg => exact mul _ _ hf hg\n  | smul _ _ _ hf => exact smul _ _ hf\n\n"}
{"name":"ContinuousMapZero.induction_on_of_compact","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"ùïú : Type u_1\ninst‚úù¬≤ : RCLike ùïú\ns : Set ùïú\ninst‚úù¬π : Zero ‚Üës\nh0 : Eq (‚Üë0) 0\ninst‚úù : CompactSpace ‚Üës\np : ContinuousMapZero (‚Üës) ùïú ‚Üí Prop\nzero : p 0\nid : p (ContinuousMapZero.id h0)\nstar_id : p (Star.star (ContinuousMapZero.id h0))\nadd : ‚àÄ (f g : ContinuousMapZero (‚Üës) ùïú), p f ‚Üí p g ‚Üí p (HAdd.hAdd f g)\nmul : ‚àÄ (f g : ContinuousMapZero (‚Üës) ùïú), p f ‚Üí p g ‚Üí p (HMul.hMul f g)\nsmul : ‚àÄ (r : ùïú) (f : ContinuousMapZero (‚Üës) ùïú), p f ‚Üí p (HSMul.hSMul r f)\nfrequently : ‚àÄ (f : ContinuousMapZero (‚Üës) ùïú), Filter.Frequently (fun g => p g) (nhds f) ‚Üí p f\nf : ContinuousMapZero (‚Üës) ùïú\n‚ä¢ p f","decl":"open Topology in\n@[elab_as_elim]\ntheorem ContinuousMapZero.induction_on_of_compact {s : Set ùïú} [Zero s] (h0 : ((0 : s) : ùïú) = 0)\n    [CompactSpace s] {p : C(s, ùïú)‚ÇÄ ‚Üí Prop} (zero : p 0) (id : p (.id h0))\n    (star_id : p (star (.id h0))) (add : ‚àÄ f g, p f ‚Üí p g ‚Üí p (f + g))\n    (mul : ‚àÄ f g, p f ‚Üí p g ‚Üí p (f * g)) (smul : ‚àÄ (r : ùïú) f, p f ‚Üí p (r ‚Ä¢ f))\n    (frequently : ‚àÄ f, (‚àÉ·∂† g in ùìù f, p g) ‚Üí p f) (f : C(s, ùïú)‚ÇÄ) :\n    p f := by\n  refine f.induction_on h0 zero id star_id add mul smul fun h f ‚Ü¶ frequently f ?_\n  have := (ContinuousMapZero.adjoin_id_dense h0).closure_eq ‚ñ∏ Set.mem_univ (x := f)\n  exact mem_closure_iff_frequently.mp this |>.mp <| .of_forall h\n\n"}
{"name":"ContinuousMapZero.nonUnitalStarAlgHom_apply_mul_eq_zero","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"ùïú : Type u_2\nA : Type u_3\ninst‚úù‚Åπ : RCLike ùïú\ninst‚úù‚Å∏ : NonUnitalRing A\ninst‚úù‚Å∑ : StarRing A\ninst‚úù‚Å∂ : TopologicalSpace A\ninst‚úù‚Åµ : TopologicalSemiring A\ninst‚úù‚Å¥ : T2Space A\ninst‚úù¬≥ : Module ùïú A\ninst‚úù¬≤ : IsScalarTower ùïú A A\ns : Set ùïú\ninst‚úù¬π : Zero ‚Üës\ninst‚úù : CompactSpace ‚Üës\nh0 : Eq (‚Üë0) 0\nœÜ : NonUnitalStarAlgHom ùïú (ContinuousMapZero (‚Üës) ùïú) A\na : A\nhmul_id : Eq (HMul.hMul (œÜ (ContinuousMapZero.id h0)) a) 0\nhmul_star_id : Eq (HMul.hMul (œÜ (Star.star (ContinuousMapZero.id h0))) a) 0\nhœÜ : Continuous ‚áëœÜ\nf : ContinuousMapZero (‚Üës) ùïú\n‚ä¢ Eq (HMul.hMul (œÜ f) a) 0","decl":"lemma ContinuousMapZero.nonUnitalStarAlgHom_apply_mul_eq_zero {ùïú A : Type*}\n    [RCLike ùïú] [NonUnitalRing A] [StarRing A] [TopologicalSpace A] [TopologicalSemiring A]\n    [T2Space A] [Module ùïú A] [IsScalarTower ùïú A A] {s : Set ùïú} [Zero s] [CompactSpace s]\n    (h0 : (0 : s) = (0 : ùïú)) (œÜ : C(s, ùïú)‚ÇÄ ‚Üí‚ãÜ‚Çô‚Çê[ùïú] A) (a : A) (hmul_id : œÜ (.id h0) * a = 0)\n    (hmul_star_id : œÜ (star (.id h0)) * a = 0) (hœÜ : Continuous œÜ) (f : C(s, ùïú)‚ÇÄ) :\n    œÜ f * a = 0 := by\n  induction f using ContinuousMapZero.induction_on_of_compact h0 with\n  | zero => simp [map_zero]\n  | id => exact hmul_id\n  | star_id => exact hmul_star_id\n  | add _ _ h‚ÇÅ h‚ÇÇ => simp only [map_add, add_mul, h‚ÇÅ, h‚ÇÇ, zero_add]\n  | mul _ _ _ h => simp only [map_mul, mul_assoc, h, mul_zero]\n  | smul _ _ h => rw [map_smul, smul_mul_assoc, h, smul_zero]\n  | frequently f h => exact h.mem_of_closed <| isClosed_eq (by fun_prop) continuous_zero\n\n"}
{"name":"ContinuousMapZero.mul_nonUnitalStarAlgHom_apply_eq_zero","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"ùïú : Type u_2\nA : Type u_3\ninst‚úù‚Åπ : RCLike ùïú\ninst‚úù‚Å∏ : NonUnitalRing A\ninst‚úù‚Å∑ : StarRing A\ninst‚úù‚Å∂ : TopologicalSpace A\ninst‚úù‚Åµ : TopologicalSemiring A\ninst‚úù‚Å¥ : T2Space A\ninst‚úù¬≥ : Module ùïú A\ninst‚úù¬≤ : SMulCommClass ùïú A A\ns : Set ùïú\ninst‚úù¬π : Zero ‚Üës\ninst‚úù : CompactSpace ‚Üës\nh0 : Eq (‚Üë0) 0\nœÜ : NonUnitalStarAlgHom ùïú (ContinuousMapZero (‚Üës) ùïú) A\na : A\nhmul_id : Eq (HMul.hMul a (œÜ (ContinuousMapZero.id h0))) 0\nhmul_star_id : Eq (HMul.hMul a (œÜ (Star.star (ContinuousMapZero.id h0)))) 0\nhœÜ : Continuous ‚áëœÜ\nf : ContinuousMapZero (‚Üës) ùïú\n‚ä¢ Eq (HMul.hMul a (œÜ f)) 0","decl":"lemma ContinuousMapZero.mul_nonUnitalStarAlgHom_apply_eq_zero {ùïú A : Type*}\n    [RCLike ùïú] [NonUnitalRing A] [StarRing A] [TopologicalSpace A] [TopologicalSemiring A]\n    [T2Space A] [Module ùïú A] [SMulCommClass ùïú A A] {s : Set ùïú} [Zero s] [CompactSpace s]\n    (h0 : (0 : s) = (0 : ùïú)) (œÜ : C(s, ùïú)‚ÇÄ ‚Üí‚ãÜ‚Çô‚Çê[ùïú] A) (a : A) (hmul_id : a * œÜ (.id h0) = 0)\n    (hmul_star_id : a * œÜ (star (.id h0)) = 0) (hœÜ : Continuous œÜ) (f : C(s, ùïú)‚ÇÄ) :\n    a * œÜ f = 0 := by\n  induction f using ContinuousMapZero.induction_on_of_compact h0 with\n  | zero => simp [map_zero]\n  | id => exact hmul_id\n  | star_id => exact hmul_star_id\n  | add _ _ h‚ÇÅ h‚ÇÇ => simp only [map_add, mul_add, h‚ÇÅ, h‚ÇÇ, zero_add]\n  | mul _ _ h _ => simp only [map_mul, ‚Üê mul_assoc, h, zero_mul]\n  | smul _ _ h => rw [map_smul, mul_smul_comm, h, smul_zero]\n  | frequently f h => exact h.mem_of_closed <| isClosed_eq (by fun_prop) continuous_zero\n\n"}
