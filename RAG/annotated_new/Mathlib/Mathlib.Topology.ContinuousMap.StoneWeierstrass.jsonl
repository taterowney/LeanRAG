{"name":"ContinuousMap.attachBound_apply_coe","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : CompactSpace X\nf : ContinuousMap X Real\nx : X\nâŠ¢ Eq (â†‘(f.attachBound x)) (f x)","decl":"@[simp]\ntheorem attachBound_apply_coe (f : C(X, â„)) (x : X) : ((attachBound f) x : â„) = f x :=\n  rfl\n\n"}
{"name":"ContinuousMap.polynomial_comp_attachBound","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : CompactSpace X\nA : Subalgebra Real (ContinuousMap X Real)\nf : Subtype fun x => Membership.mem A x\ng : Polynomial Real\nâŠ¢ Eq ((g.toContinuousMapOn (Set.Icc (Neg.neg (Norm.norm f)) (Norm.norm f))).comp (â†‘f).attachBound) â†‘((Polynomial.aeval f) g)","decl":"theorem polynomial_comp_attachBound (A : Subalgebra â„ C(X, â„)) (f : A) (g : â„[X]) :\n    (g.toContinuousMapOn (Set.Icc (-â€–fâ€–) â€–fâ€–)).comp (f : C(X, â„)).attachBound =\n      Polynomial.aeval f g := by\n  ext\n  simp only [Polynomial.aeval_subalgebra_coe, Polynomial.aeval_continuousMap_apply]\n  simp\n\n"}
{"name":"ContinuousMap.polynomial_comp_attachBound_mem","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : CompactSpace X\nA : Subalgebra Real (ContinuousMap X Real)\nf : Subtype fun x => Membership.mem A x\ng : Polynomial Real\nâŠ¢ Membership.mem A ((g.toContinuousMapOn (Set.Icc (Neg.neg (Norm.norm f)) (Norm.norm f))).comp (â†‘f).attachBound)","decl":"/-- Given a continuous function `f` in a subalgebra of `C(X, â„)`, postcomposing by a polynomial\ngives another function in `A`.\n\nThis lemma proves something slightly more subtle than this:\nwe take `f`, and think of it as a function into the restricted target `Set.Icc (-â€–fâ€–) â€–fâ€–)`,\nand then postcompose with a polynomial function on that interval.\nThis is in fact the same situation as above, and so also gives a function in `A`.\n-/\ntheorem polynomial_comp_attachBound_mem (A : Subalgebra â„ C(X, â„)) (f : A) (g : â„[X]) :\n    (g.toContinuousMapOn (Set.Icc (-â€–fâ€–) â€–fâ€–)).comp (f : C(X, â„)).attachBound âˆˆ A := by\n  rw [polynomial_comp_attachBound]\n  apply SetLike.coe_mem\n\n"}
{"name":"ContinuousMap.comp_attachBound_mem_closure","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : CompactSpace X\nA : Subalgebra Real (ContinuousMap X Real)\nf : Subtype fun x => Membership.mem A x\np : ContinuousMap (â†‘(Set.Icc (Neg.neg (Norm.norm f)) (Norm.norm f))) Real\nâŠ¢ Membership.mem A.topologicalClosure (p.comp (â†‘f).attachBound)","decl":"theorem comp_attachBound_mem_closure (A : Subalgebra â„ C(X, â„)) (f : A)\n    (p : C(Set.Icc (-â€–fâ€–) â€–fâ€–, â„)) : p.comp (attachBound (f : C(X, â„))) âˆˆ A.topologicalClosure := by\n  -- `p` itself is in the closure of polynomials, by the Weierstrass theorem,\n  have mem_closure : p âˆˆ (polynomialFunctions (Set.Icc (-â€–fâ€–) â€–fâ€–)).topologicalClosure :=\n    continuousMap_mem_polynomialFunctions_closure _ _ p\n  -- and so there are polynomials arbitrarily close.\n  have frequently_mem_polynomials := mem_closure_iff_frequently.mp mem_closure\n  -- To prove `p.comp (attachBound f)` is in the closure of `A`,\n  -- we show there are elements of `A` arbitrarily close.\n  apply mem_closure_iff_frequently.mpr\n  -- To show that, we pull back the polynomials close to `p`,\n  refine\n    ((compRightContinuousMap â„ (attachBound (f : C(X, â„)))).continuousAt\n            p).tendsto.frequently_map\n      _ ?_ frequently_mem_polynomials\n  -- but need to show that those pullbacks are actually in `A`.\n  rintro _ âŸ¨g, âŸ¨-, rflâŸ©âŸ©\n  simp only [SetLike.mem_coe, AlgHom.coe_toRingHom, compRightContinuousMap_apply,\n    Polynomial.toContinuousMapOnAlgHom_apply]\n  apply polynomial_comp_attachBound_mem\n\n"}
{"name":"ContinuousMap.abs_mem_subalgebra_closure","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : CompactSpace X\nA : Subalgebra Real (ContinuousMap X Real)\nf : Subtype fun x => Membership.mem A x\nâŠ¢ Membership.mem A.topologicalClosure (abs â†‘f)","decl":"theorem abs_mem_subalgebra_closure (A : Subalgebra â„ C(X, â„)) (f : A) :\n    |(f : C(X, â„))| âˆˆ A.topologicalClosure := by\n  let f' := attachBound (f : C(X, â„))\n  let abs : C(Set.Icc (-â€–fâ€–) â€–fâ€–, â„) := { toFun := fun x : Set.Icc (-â€–fâ€–) â€–fâ€– => |(x : â„)| }\n  change abs.comp f' âˆˆ A.topologicalClosure\n  apply comp_attachBound_mem_closure\n\n"}
{"name":"ContinuousMap.inf_mem_subalgebra_closure","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : CompactSpace X\nA : Subalgebra Real (ContinuousMap X Real)\nf g : Subtype fun x => Membership.mem A x\nâŠ¢ Membership.mem A.topologicalClosure (Min.min â†‘f â†‘g)","decl":"theorem inf_mem_subalgebra_closure (A : Subalgebra â„ C(X, â„)) (f g : A) :\n    (f : C(X, â„)) âŠ“ (g : C(X, â„)) âˆˆ A.topologicalClosure := by\n  rw [inf_eq_half_smul_add_sub_abs_sub' â„]\n  refine\n    A.topologicalClosure.smul_mem\n      (A.topologicalClosure.sub_mem\n        (A.topologicalClosure.add_mem (A.le_topologicalClosure f.property)\n          (A.le_topologicalClosure g.property))\n        ?_)\n      _\n  exact mod_cast abs_mem_subalgebra_closure A _\n\n"}
{"name":"ContinuousMap.inf_mem_closed_subalgebra","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : CompactSpace X\nA : Subalgebra Real (ContinuousMap X Real)\nh : IsClosed â†‘A\nf g : Subtype fun x => Membership.mem A x\nâŠ¢ Membership.mem A (Min.min â†‘f â†‘g)","decl":"theorem inf_mem_closed_subalgebra (A : Subalgebra â„ C(X, â„)) (h : IsClosed (A : Set C(X, â„)))\n    (f g : A) : (f : C(X, â„)) âŠ“ (g : C(X, â„)) âˆˆ A := by\n  convert inf_mem_subalgebra_closure A f g\n  apply SetLike.ext'\n  symm\n  erw [closure_eq_iff_isClosed]\n  exact h\n\n"}
{"name":"ContinuousMap.sup_mem_subalgebra_closure","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : CompactSpace X\nA : Subalgebra Real (ContinuousMap X Real)\nf g : Subtype fun x => Membership.mem A x\nâŠ¢ Membership.mem A.topologicalClosure (Max.max â†‘f â†‘g)","decl":"theorem sup_mem_subalgebra_closure (A : Subalgebra â„ C(X, â„)) (f g : A) :\n    (f : C(X, â„)) âŠ” (g : C(X, â„)) âˆˆ A.topologicalClosure := by\n  rw [sup_eq_half_smul_add_add_abs_sub' â„]\n  refine\n    A.topologicalClosure.smul_mem\n      (A.topologicalClosure.add_mem\n        (A.topologicalClosure.add_mem (A.le_topologicalClosure f.property)\n          (A.le_topologicalClosure g.property))\n        ?_)\n      _\n  exact mod_cast abs_mem_subalgebra_closure A _\n\n"}
{"name":"ContinuousMap.sup_mem_closed_subalgebra","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : CompactSpace X\nA : Subalgebra Real (ContinuousMap X Real)\nh : IsClosed â†‘A\nf g : Subtype fun x => Membership.mem A x\nâŠ¢ Membership.mem A (Max.max â†‘f â†‘g)","decl":"theorem sup_mem_closed_subalgebra (A : Subalgebra â„ C(X, â„)) (h : IsClosed (A : Set C(X, â„)))\n    (f g : A) : (f : C(X, â„)) âŠ” (g : C(X, â„)) âˆˆ A := by\n  convert sup_mem_subalgebra_closure A f g\n  apply SetLike.ext'\n  symm\n  erw [closure_eq_iff_isClosed]\n  exact h\n\n"}
{"name":"ContinuousMap.sublattice_closure_eq_top","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : CompactSpace X\nL : Set (ContinuousMap X Real)\nnA : L.Nonempty\ninf_mem : âˆ€ (f : ContinuousMap X Real), Membership.mem L f â†’ âˆ€ (g : ContinuousMap X Real), Membership.mem L g â†’ Membership.mem L (Min.min f g)\nsup_mem : âˆ€ (f : ContinuousMap X Real), Membership.mem L f â†’ âˆ€ (g : ContinuousMap X Real), Membership.mem L g â†’ Membership.mem L (Max.max f g)\nsep : L.SeparatesPointsStrongly\nâŠ¢ Eq (closure L) Top.top","decl":"theorem sublattice_closure_eq_top (L : Set C(X, â„)) (nA : L.Nonempty)\n    (inf_mem : âˆ€áµ‰ (f âˆˆ L) (g âˆˆ L), f âŠ“ g âˆˆ L)\n    (sup_mem : âˆ€áµ‰ (f âˆˆ L) (g âˆˆ L), f âŠ” g âˆˆ L) (sep : L.SeparatesPointsStrongly) :\n    closure L = âŠ¤ := by\n  -- We start by boiling down to a statement about close approximation.\n  rw [eq_top_iff]\n  rintro f -\n  refine\n    Filter.Frequently.mem_closure\n      ((Filter.HasBasis.frequently_iff Metric.nhds_basis_ball).mpr fun Îµ pos => ?_)\n  simp only [exists_prop, Metric.mem_ball]\n  -- It will be helpful to assume `X` is nonempty later,\n  -- so we get that out of the way here.\n  by_cases nX : Nonempty X\n  swap\n  Â· exact âŸ¨nA.some, (dist_lt_iff pos).mpr fun x => False.elim (nX âŸ¨xâŸ©), nA.choose_specâŸ©\n  /-\n    The strategy now is to pick a family of continuous functions `g x y` in `A`\n    with the property that `g x y x = f x` and `g x y y = f y`\n    (this is immediate from `h : SeparatesPointsStrongly`)\n    then use continuity to see that `g x y` is close to `f` near both `x` and `y`,\n    and finally using compactness to produce the desired function `h`\n    as a maximum over finitely many `x` of a minimum over finitely many `y` of the `g x y`.\n    -/\n  dsimp only [Set.SeparatesPointsStrongly] at sep\n  choose g hg wâ‚ wâ‚‚ using sep f\n  -- For each `x y`, we define `U x y` to be `{z | f z - Îµ < g x y z}`,\n  -- and observe this is a neighbourhood of `y`.\n  let U : X â†’ X â†’ Set X := fun x y => {z | f z - Îµ < g x y z}\n  have U_nhd_y : âˆ€ x y, U x y âˆˆ ğ“ y := by\n    intro x y\n    refine IsOpen.mem_nhds ?_ ?_\n    Â· apply isOpen_lt <;> continuity\n    Â· rw [Set.mem_setOf_eq, wâ‚‚]\n      exact sub_lt_self _ pos\n  -- Fixing `x` for a moment, we have a family of functions `fun y â†¦ g x y`\n  -- which on different patches (the `U x y`) are greater than `f z - Îµ`.\n  -- Taking the supremum of these functions\n  -- indexed by a finite collection of patches which cover `X`\n  -- will give us an element of `A` that is globally greater than `f z - Îµ`\n  -- and still equal to `f x` at `x`.\n  -- Since `X` is compact, for every `x` there is some finset `ys t`\n  -- so the union of the `U x y` for `y âˆˆ ys x` still covers everything.\n  let ys : X â†’ Finset X := fun x => (CompactSpace.elim_nhds_subcover (U x) (U_nhd_y x)).choose\n  let ys_w : âˆ€ x, â‹ƒ y âˆˆ ys x, U x y = âŠ¤ := fun x =>\n    (CompactSpace.elim_nhds_subcover (U x) (U_nhd_y x)).choose_spec\n  have ys_nonempty : âˆ€ x, (ys x).Nonempty := fun x =>\n    Set.nonempty_of_union_eq_top_of_nonempty _ _ nX (ys_w x)\n  -- Thus for each `x` we have the desired `h x : A` so `f z - Îµ < h x z` everywhere\n  -- and `h x x = f x`.\n  let h : X â†’ L := fun x =>\n    âŸ¨(ys x).sup' (ys_nonempty x) fun y => (g x y : C(X, â„)),\n      Finset.sup'_mem _ sup_mem _ _ _ fun y _ => hg x yâŸ©\n  have lt_h : âˆ€ x z, f z - Îµ < (h x : X â†’ â„) z := by\n    intro x z\n    obtain âŸ¨y, ym, zmâŸ© := Set.exists_set_mem_of_union_eq_top _ _ (ys_w x) z\n    dsimp [h]\n    simp only [Subtype.coe_mk, coe_sup', Finset.sup'_apply, Finset.lt_sup'_iff]\n    exact âŸ¨y, ym, zmâŸ©\n  have h_eq : âˆ€ x, (h x : X â†’ â„) x = f x := by intro x; simp [h, wâ‚]\n  -- For each `x`, we define `W x` to be `{z | h x z < f z + Îµ}`,\n  let W : X â†’ Set X := fun x => {z | (h x : X â†’ â„) z < f z + Îµ}\n  -- This is still a neighbourhood of `x`.\n  have W_nhd : âˆ€ x, W x âˆˆ ğ“ x := by\n    intro x\n    refine IsOpen.mem_nhds ?_ ?_\n    Â· apply isOpen_lt <;> fun_prop\n    Â· dsimp only [W, Set.mem_setOf_eq]\n      rw [h_eq]\n      exact lt_add_of_pos_right _ pos\n  -- Since `X` is compact, there is some finset `ys t`\n  -- so the union of the `W x` for `x âˆˆ xs` still covers everything.\n  let xs : Finset X := (CompactSpace.elim_nhds_subcover W W_nhd).choose\n  let xs_w : â‹ƒ x âˆˆ xs, W x = âŠ¤ := (CompactSpace.elim_nhds_subcover W W_nhd).choose_spec\n  have xs_nonempty : xs.Nonempty := Set.nonempty_of_union_eq_top_of_nonempty _ _ nX xs_w\n  -- Finally our candidate function is the infimum over `x âˆˆ xs` of the `h x`.\n  -- This function is then globally less than `f z + Îµ`.\n  let k : (L : Type _) :=\n    âŸ¨xs.inf' xs_nonempty fun x => (h x : C(X, â„)),\n      Finset.inf'_mem _ inf_mem _ _ _ fun x _ => (h x).2âŸ©\n  refine âŸ¨k.1, ?_, k.2âŸ©\n  -- We just need to verify the bound, which we do pointwise.\n  rw [dist_lt_iff pos]\n  intro z\n  -- We rewrite into this particular form,\n  -- so that simp lemmas about inequalities involving `Finset.inf'` can fire.\n  rw [show âˆ€ a b Îµ : â„, dist a b < Îµ â†” a < b + Îµ âˆ§ b - Îµ < a by\n        intros; simp only [â† Metric.mem_ball, Real.ball_eq_Ioo, Set.mem_Ioo, and_comm]]\n  fconstructor\n  Â· dsimp\n    simp only [k, Finset.inf'_lt_iff, ContinuousMap.inf'_apply]\n    exact Set.exists_set_mem_of_union_eq_top _ _ xs_w z\n  Â· dsimp\n    simp only [k, Finset.lt_inf'_iff, ContinuousMap.inf'_apply]\n    rintro x -\n    apply lt_h\n\n"}
{"name":"ContinuousMap.subalgebra_topologicalClosure_eq_top_of_separatesPoints","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : CompactSpace X\nA : Subalgebra Real (ContinuousMap X Real)\nw : A.SeparatesPoints\nâŠ¢ Eq A.topologicalClosure Top.top","decl":"/-- The **Stone-Weierstrass Approximation Theorem**,\nthat a subalgebra `A` of `C(X, â„)`, where `X` is a compact topological space,\nis dense if it separates points.\n-/\ntheorem subalgebra_topologicalClosure_eq_top_of_separatesPoints (A : Subalgebra â„ C(X, â„))\n    (w : A.SeparatesPoints) : A.topologicalClosure = âŠ¤ := by\n  -- The closure of `A` is closed under taking `sup` and `inf`,\n  -- and separates points strongly (since `A` does),\n  -- so we can apply `sublattice_closure_eq_top`.\n  apply SetLike.ext'\n  let L := A.topologicalClosure\n  have n : Set.Nonempty (L : Set C(X, â„)) := âŸ¨(1 : C(X, â„)), A.le_topologicalClosure A.one_memâŸ©\n  convert\n    sublattice_closure_eq_top (L : Set C(X, â„)) n\n      (fun f fm g gm => inf_mem_closed_subalgebra L A.isClosed_topologicalClosure âŸ¨f, fmâŸ© âŸ¨g, gmâŸ©)\n      (fun f fm g gm => sup_mem_closed_subalgebra L A.isClosed_topologicalClosure âŸ¨f, fmâŸ© âŸ¨g, gmâŸ©)\n      (Subalgebra.SeparatesPoints.strongly\n        (Subalgebra.separatesPoints_monotone A.le_topologicalClosure w))\n  simp [L]\n\n"}
{"name":"ContinuousMap.continuousMap_mem_subalgebra_closure_of_separatesPoints","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : CompactSpace X\nA : Subalgebra Real (ContinuousMap X Real)\nw : A.SeparatesPoints\nf : ContinuousMap X Real\nâŠ¢ Membership.mem A.topologicalClosure f","decl":"/-- An alternative statement of the Stone-Weierstrass theorem.\n\nIf `A` is a subalgebra of `C(X, â„)` which separates points (and `X` is compact),\nevery real-valued continuous function on `X` is a uniform limit of elements of `A`.\n-/\ntheorem continuousMap_mem_subalgebra_closure_of_separatesPoints (A : Subalgebra â„ C(X, â„))\n    (w : A.SeparatesPoints) (f : C(X, â„)) : f âˆˆ A.topologicalClosure := by\n  rw [subalgebra_topologicalClosure_eq_top_of_separatesPoints A w]\n  simp\n\n"}
{"name":"ContinuousMap.exists_mem_subalgebra_near_continuousMap_of_separatesPoints","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : CompactSpace X\nA : Subalgebra Real (ContinuousMap X Real)\nw : A.SeparatesPoints\nf : ContinuousMap X Real\nÎµ : Real\npos : LT.lt 0 Îµ\nâŠ¢ Exists fun g => LT.lt (Norm.norm (HSub.hSub (â†‘g) f)) Îµ","decl":"/-- An alternative statement of the Stone-Weierstrass theorem,\nfor those who like their epsilons.\n\nIf `A` is a subalgebra of `C(X, â„)` which separates points (and `X` is compact),\nevery real-valued continuous function on `X` is within any `Îµ > 0` of some element of `A`.\n-/\ntheorem exists_mem_subalgebra_near_continuousMap_of_separatesPoints (A : Subalgebra â„ C(X, â„))\n    (w : A.SeparatesPoints) (f : C(X, â„)) (Îµ : â„) (pos : 0 < Îµ) :\n    âˆƒ g : A, â€–(g : C(X, â„)) - fâ€– < Îµ := by\n  have w :=\n    mem_closure_iff_frequently.mp (continuousMap_mem_subalgebra_closure_of_separatesPoints A w f)\n  rw [Metric.nhds_basis_ball.frequently_iff] at w\n  obtain âŸ¨g, H, mâŸ© := w Îµ pos\n  rw [Metric.mem_ball, dist_eq_norm] at H\n  exact âŸ¨âŸ¨g, mâŸ©, HâŸ©\n\n"}
{"name":"ContinuousMap.exists_mem_subalgebra_near_continuous_of_separatesPoints","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : CompactSpace X\nA : Subalgebra Real (ContinuousMap X Real)\nw : A.SeparatesPoints\nf : X â†’ Real\nc : Continuous f\nÎµ : Real\npos : LT.lt 0 Îµ\nâŠ¢ Exists fun g => âˆ€ (x : X), LT.lt (Norm.norm (HSub.hSub (â†‘g x) (f x))) Îµ","decl":"/-- An alternative statement of the Stone-Weierstrass theorem,\nfor those who like their epsilons and don't like bundled continuous functions.\n\nIf `A` is a subalgebra of `C(X, â„)` which separates points (and `X` is compact),\nevery real-valued continuous function on `X` is within any `Îµ > 0` of some element of `A`.\n-/\ntheorem exists_mem_subalgebra_near_continuous_of_separatesPoints (A : Subalgebra â„ C(X, â„))\n    (w : A.SeparatesPoints) (f : X â†’ â„) (c : Continuous f) (Îµ : â„) (pos : 0 < Îµ) :\n    âˆƒ g : A, âˆ€ x, â€–(g : X â†’ â„) x - f xâ€– < Îµ := by\n  obtain âŸ¨g, bâŸ© := exists_mem_subalgebra_near_continuousMap_of_separatesPoints A w âŸ¨f, câŸ© Îµ pos\n  use g\n  rwa [norm_lt_iff _ pos] at b\n\n"}
{"name":"Subalgebra.SeparatesPoints.rclike_to_real","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"ğ•œ : Type u_1\nX : Type u_2\ninstâœÂ¹ : RCLike ğ•œ\ninstâœ : TopologicalSpace X\nA : StarSubalgebra ğ•œ (ContinuousMap X ğ•œ)\nhA : A.SeparatesPoints\nâŠ¢ (Subalgebra.comap (AlgHom.compLeftContinuous Real RCLike.ofRealAm â‹¯) (Subalgebra.restrictScalars Real A.toSubalgebra)).SeparatesPoints","decl":"/-- If a star subalgebra of `C(X, ğ•œ)` separates points, then the real subalgebra\nof its purely real-valued elements also separates points. -/\ntheorem Subalgebra.SeparatesPoints.rclike_to_real {A : StarSubalgebra ğ•œ C(X, ğ•œ)}\n    (hA : A.SeparatesPoints) :\n      ((A.restrictScalars â„).comap\n        (ofRealAm.compLeftContinuous â„ continuous_ofReal)).SeparatesPoints := by\n  intro xâ‚ xâ‚‚ hx\n  -- Let `f` in the subalgebra `A` separate the points `xâ‚`, `xâ‚‚`\n  obtain âŸ¨_, âŸ¨f, hfA, rflâŸ©, hfâŸ© := hA hx\n  let F : C(X, ğ•œ) := f - const _ (f xâ‚‚)\n  -- Subtract the constant `f xâ‚‚` from `f`; this is still an element of the subalgebra\n  have hFA : F âˆˆ A := by\n    refine A.sub_mem hfA (@Eq.subst _ (Â· âˆˆ A) _ _ ?_ <| A.smul_mem A.one_mem <| f xâ‚‚)\n    ext1\n    simp only [coe_smul, coe_one, smul_apply, one_apply, Algebra.id.smul_eq_mul, mul_one,\n      const_apply]\n  -- Consider now the function `fun x â†¦ |f x - f xâ‚‚| ^ 2`\n  refine âŸ¨_, âŸ¨âŸ¨(â€–F Â·â€– ^ 2), by continuityâŸ©, ?_, rflâŸ©, ?_âŸ©\n  Â· -- This is also an element of the subalgebra, and takes only real values\n    rw [SetLike.mem_coe, Subalgebra.mem_comap]\n    convert (A.restrictScalars â„).mul_mem hFA (star_mem hFA : star F âˆˆ A)\n    ext1\n    simp [â† RCLike.mul_conj]\n  Â· -- And it also separates the points `xâ‚`, `xâ‚‚`\n    simpa [F] using sub_ne_zero.mpr hf\n\n"}
{"name":"ContinuousMap.starSubalgebra_topologicalClosure_eq_top_of_separatesPoints","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"ğ•œ : Type u_1\nX : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : CompactSpace X\nA : StarSubalgebra ğ•œ (ContinuousMap X ğ•œ)\nhA : A.SeparatesPoints\nâŠ¢ Eq A.topologicalClosure Top.top","decl":"/-- The Stone-Weierstrass approximation theorem, `RCLike` version, that a star subalgebra `A` of\n`C(X, ğ•œ)`, where `X` is a compact topological space and `RCLike ğ•œ`, is dense if it separates\npoints. -/\ntheorem ContinuousMap.starSubalgebra_topologicalClosure_eq_top_of_separatesPoints\n    (A : StarSubalgebra ğ•œ C(X, ğ•œ)) (hA : A.SeparatesPoints) : A.topologicalClosure = âŠ¤ := by\n  rw [StarSubalgebra.eq_top_iff]\n  -- Let `I` be the natural inclusion of `C(X, â„)` into `C(X, ğ•œ)`\n  let I : C(X, â„) â†’â‚—[â„] C(X, ğ•œ) := ofRealCLM.compLeftContinuous â„ X\n  -- The main point of the proof is that its range (i.e., every real-valued function) is contained\n  -- in the closure of `A`\n  have key : LinearMap.range I â‰¤ (A.toSubmodule.restrictScalars â„).topologicalClosure := by\n    -- Let `Aâ‚€` be the subalgebra of `C(X, â„)` consisting of `A`'s purely real elements; it is the\n    -- preimage of `A` under `I`.  In this argument we only need its submodule structure.\n    let Aâ‚€ : Submodule â„ C(X, â„) := (A.toSubmodule.restrictScalars â„).comap I\n    -- By `Subalgebra.SeparatesPoints.rclike_to_real`, this subalgebra also separates points, so\n    -- we may apply the real Stone-Weierstrass result to it.\n    have SW : Aâ‚€.topologicalClosure = âŠ¤ :=\n      haveI := subalgebra_topologicalClosure_eq_top_of_separatesPoints _ hA.rclike_to_real\n      congr_arg Subalgebra.toSubmodule this\n    rw [â† Submodule.map_top, â† SW]\n    -- So it suffices to prove that the image under `I` of the closure of `Aâ‚€` is contained in the\n    -- closure of `A`, which follows by abstract nonsense\n    have hâ‚ := Aâ‚€.topologicalClosure_map ((@ofRealCLM ğ•œ _).compLeftContinuousCompact X)\n    have hâ‚‚ := (A.toSubmodule.restrictScalars â„).map_comap_le I\n    exact hâ‚.trans (Submodule.topologicalClosure_mono hâ‚‚)\n  -- In particular, for a function `f` in `C(X, ğ•œ)`, the real and imaginary parts of `f` are in the\n  -- closure of `A`\n  intro f\n  let f_re : C(X, â„) := (âŸ¨RCLike.re, RCLike.reCLM.continuousâŸ© : C(ğ•œ, â„)).comp f\n  let f_im : C(X, â„) := (âŸ¨RCLike.im, RCLike.imCLM.continuousâŸ© : C(ğ•œ, â„)).comp f\n  have h_f_re : I f_re âˆˆ A.topologicalClosure := key âŸ¨f_re, rflâŸ©\n  have h_f_im : I f_im âˆˆ A.topologicalClosure := key âŸ¨f_im, rflâŸ©\n  -- So `f_re + I â€¢ f_im` is in the closure of `A`\n  have := A.topologicalClosure.add_mem h_f_re (A.topologicalClosure.smul_mem h_f_im RCLike.I)\n  rw [StarSubalgebra.mem_toSubalgebra] at this\n  convert this\n  -- And this, of course, is just `f`\n  ext\n  apply Eq.symm\n  simp [I, f_re, f_im, mul_comm RCLike.I _]\n\n"}
{"name":"polynomialFunctions.topologicalClosure","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"s : Set Real\ninstâœ : CompactSpace â†‘s\nâŠ¢ Eq (polynomialFunctions s).topologicalClosure Top.top","decl":"/-- Polynomial functions in are dense in `C(s, â„)` when `s` is compact.\n\nSee `polynomialFunctions_closure_eq_top` for the special case `s = Set.Icc a b` which does not use\nthe full Stone-Weierstrass theorem. Of course, that version could be used to prove this one as\nwell. -/\ntheorem polynomialFunctions.topologicalClosure (s : Set â„)\n    [CompactSpace s] : (polynomialFunctions s).topologicalClosure = âŠ¤ :=\n  ContinuousMap.subalgebra_topologicalClosure_eq_top_of_separatesPoints _\n    (polynomialFunctions_separatesPoints s)\n\n"}
{"name":"polynomialFunctions.starClosure_topologicalClosure","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹ : RCLike ğ•œ\ns : Set ğ•œ\ninstâœ : CompactSpace â†‘s\nâŠ¢ Eq (polynomialFunctions s).starClosure.topologicalClosure Top.top","decl":"/-- The star subalgebra generated by polynomials functions is dense in `C(s, ğ•œ)` when `s` is\ncompact and `ğ•œ` is either `â„` or `â„‚`. -/\ntheorem polynomialFunctions.starClosure_topologicalClosure {ğ•œ : Type*} [RCLike ğ•œ] (s : Set ğ•œ)\n    [CompactSpace s] : (polynomialFunctions s).starClosure.topologicalClosure = âŠ¤ :=\n  ContinuousMap.starSubalgebra_topologicalClosure_eq_top_of_separatesPoints _\n    (Subalgebra.separatesPoints_monotone le_sup_left (polynomialFunctions_separatesPoints s))\n\n"}
{"name":"ContinuousMap.induction_on","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"ğ•œ : Type u_1\ninstâœ : RCLike ğ•œ\ns : Set ğ•œ\np : ContinuousMap (â†‘s) ğ•œ â†’ Prop\nconst : âˆ€ (r : ğ•œ), p (ContinuousMap.const (â†‘s) r)\nid : p (ContinuousMap.restrict s (ContinuousMap.id ğ•œ))\nstar_id : p (Star.star (ContinuousMap.restrict s (ContinuousMap.id ğ•œ)))\nadd : âˆ€ (f g : ContinuousMap (â†‘s) ğ•œ), p f â†’ p g â†’ p (HAdd.hAdd f g)\nmul : âˆ€ (f g : ContinuousMap (â†‘s) ğ•œ), p f â†’ p g â†’ p (HMul.hMul f g)\nclosure : (âˆ€ (f : ContinuousMap (â†‘s) ğ•œ), Membership.mem (polynomialFunctions s).starClosure f â†’ p f) â†’ âˆ€ (f : ContinuousMap (â†‘s) ğ•œ), p f\nf : ContinuousMap (â†‘s) ğ•œ\nâŠ¢ p f","decl":"/-- An induction principle for `C(s, ğ•œ)`. -/\n@[elab_as_elim]\ntheorem ContinuousMap.induction_on {ğ•œ : Type*} [RCLike ğ•œ] {s : Set ğ•œ}\n    {p : C(s, ğ•œ) â†’ Prop} (const : âˆ€ r, p (.const s r)) (id : p (.restrict s <| .id ğ•œ))\n    (star_id : p (star (.restrict s <| .id ğ•œ)))\n    (add : âˆ€ f g, p f â†’ p g â†’ p (f + g)) (mul : âˆ€ f g, p f â†’ p g â†’ p (f * g))\n    (closure : (âˆ€ f âˆˆ (polynomialFunctions s).starClosure, p f) â†’ âˆ€ f, p f) (f : C(s, ğ•œ)) :\n    p f := by\n  refine closure (fun f hf => ?_) f\n  rw [polynomialFunctions.starClosure_eq_adjoin_X] at hf\n  induction hf using Algebra.adjoin_induction with\n  | mem f hf =>\n    simp only [Set.mem_union, Set.mem_singleton_iff, Set.mem_star] at hf\n    rw [star_eq_iff_star_eq, eq_comm (b := f)] at hf\n    obtain (rfl | rfl) := hf\n    all_goals simpa only [toContinuousMapOnAlgHom_apply, toContinuousMapOn_X_eq_restrict_id]\n  | algebraMap r => exact const r\n  | add _ _ _ _ hf hg => exact add _ _ hf hg\n  | mul _ _ _ _ hf hg => exact mul _ _ hf hg\n\n"}
{"name":"ContinuousMap.induction_on_of_compact","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹ : RCLike ğ•œ\ns : Set ğ•œ\ninstâœ : CompactSpace â†‘s\np : ContinuousMap (â†‘s) ğ•œ â†’ Prop\nconst : âˆ€ (r : ğ•œ), p (ContinuousMap.const (â†‘s) r)\nid : p (ContinuousMap.restrict s (ContinuousMap.id ğ•œ))\nstar_id : p (Star.star (ContinuousMap.restrict s (ContinuousMap.id ğ•œ)))\nadd : âˆ€ (f g : ContinuousMap (â†‘s) ğ•œ), p f â†’ p g â†’ p (HAdd.hAdd f g)\nmul : âˆ€ (f g : ContinuousMap (â†‘s) ğ•œ), p f â†’ p g â†’ p (HMul.hMul f g)\nfrequently : âˆ€ (f : ContinuousMap (â†‘s) ğ•œ), Filter.Frequently (fun g => p g) (nhds f) â†’ p f\nf : ContinuousMap (â†‘s) ğ•œ\nâŠ¢ p f","decl":"open Topology in\n@[elab_as_elim]\ntheorem ContinuousMap.induction_on_of_compact {ğ•œ : Type*} [RCLike ğ•œ] {s : Set ğ•œ} [CompactSpace s]\n    {p : C(s, ğ•œ) â†’ Prop} (const : âˆ€ r, p (.const s r)) (id : p (.restrict s <| .id ğ•œ))\n    (star_id : p (star (.restrict s <| .id ğ•œ)))\n    (add : âˆ€ f g, p f â†’ p g â†’ p (f + g)) (mul : âˆ€ f g, p f â†’ p g â†’ p (f * g))\n    (frequently : âˆ€ f, (âˆƒá¶  g in ğ“ f, p g) â†’ p f) (f : C(s, ğ•œ)) :\n    p f := by\n  refine f.induction_on const id star_id add mul fun h f â†¦ frequently f ?_\n  have := polynomialFunctions.starClosure_topologicalClosure s â–¸ mem_top (x := f)\n  rw [â† SetLike.mem_coe, topologicalClosure_coe, mem_closure_iff_frequently] at this\n  exact this.mp <| .of_forall h\n\n"}
{"name":"ContinuousMap.algHom_ext_map_X","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"A : Type u_1\ninstâœâ´ : Ring A\ninstâœÂ³ : Algebra Real A\ninstâœÂ² : TopologicalSpace A\ninstâœÂ¹ : T2Space A\ns : Set Real\ninstâœ : CompactSpace â†‘s\nÏ† Ïˆ : AlgHom Real (ContinuousMap (â†‘s) Real) A\nhÏ† : Continuous â‡‘Ï†\nhÏˆ : Continuous â‡‘Ïˆ\nh : Eq (Ï† ((Polynomial.toContinuousMapOnAlgHom s) Polynomial.X)) (Ïˆ ((Polynomial.toContinuousMapOnAlgHom s) Polynomial.X))\nâŠ¢ Eq Ï† Ïˆ","decl":"/-- Continuous algebra homomorphisms from `C(s, â„)` into an `â„`-algebra `A` which agree\nat `X : ğ•œ[X]` (interpreted as a continuous map) are, in fact, equal. -/\n@[ext (iff := false)]\ntheorem ContinuousMap.algHom_ext_map_X {A : Type*} [Ring A]\n    [Algebra â„ A] [TopologicalSpace A] [T2Space A] {s : Set â„} [CompactSpace s]\n    {Ï† Ïˆ : C(s, â„) â†’â‚[â„] A} (hÏ† : Continuous Ï†) (hÏˆ : Continuous Ïˆ)\n    (h : Ï† (toContinuousMapOnAlgHom s X) = Ïˆ (toContinuousMapOnAlgHom s X)) : Ï† = Ïˆ := by\n  suffices (âŠ¤ : Subalgebra â„ C(s, â„)) â‰¤ AlgHom.equalizer Ï† Ïˆ from\n    AlgHom.ext fun x => this (by trivial)\n  rw [â† polynomialFunctions.topologicalClosure s]\n  exact Subalgebra.topologicalClosure_minimal (polynomialFunctions s)\n    (polynomialFunctions.le_equalizer s Ï† Ïˆ h) (isClosed_eq hÏ† hÏˆ)\n\n"}
{"name":"ContinuousMap.starAlgHom_ext_map_X","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ¶ : RCLike ğ•œ\ninstâœâµ : Ring A\ninstâœâ´ : StarRing A\ninstâœÂ³ : Algebra ğ•œ A\ninstâœÂ² : TopologicalSpace A\ninstâœÂ¹ : T2Space A\ns : Set ğ•œ\ninstâœ : CompactSpace â†‘s\nÏ† Ïˆ : StarAlgHom ğ•œ (ContinuousMap (â†‘s) ğ•œ) A\nhÏ† : Continuous â‡‘Ï†\nhÏˆ : Continuous â‡‘Ïˆ\nh : Eq (Ï† ((Polynomial.toContinuousMapOnAlgHom s) Polynomial.X)) (Ïˆ ((Polynomial.toContinuousMapOnAlgHom s) Polynomial.X))\nâŠ¢ Eq Ï† Ïˆ","decl":"/-- Continuous star algebra homomorphisms from `C(s, ğ•œ)` into a star `ğ•œ`-algebra `A` which agree\nat `X : ğ•œ[X]` (interpreted as a continuous map) are, in fact, equal. -/\n@[ext (iff := false)]\ntheorem ContinuousMap.starAlgHom_ext_map_X {ğ•œ A : Type*} [RCLike ğ•œ] [Ring A] [StarRing A]\n    [Algebra ğ•œ A] [TopologicalSpace A] [T2Space A] {s : Set ğ•œ} [CompactSpace s]\n    {Ï† Ïˆ : C(s, ğ•œ) â†’â‹†â‚[ğ•œ] A} (hÏ† : Continuous Ï†) (hÏˆ : Continuous Ïˆ)\n    (h : Ï† (toContinuousMapOnAlgHom s X) = Ïˆ (toContinuousMapOnAlgHom s X)) : Ï† = Ïˆ := by\n  suffices (âŠ¤ : StarSubalgebra ğ•œ C(s, ğ•œ)) â‰¤ StarAlgHom.equalizer Ï† Ïˆ from\n    StarAlgHom.ext fun x => this mem_top\n  rw [â† polynomialFunctions.starClosure_topologicalClosure s]\n  exact StarSubalgebra.topologicalClosure_minimal\n    (polynomialFunctions.starClosure_le_equalizer s Ï† Ïˆ h) (isClosed_eq hÏ† hÏˆ)\n\n"}
{"name":"ContinuousMap.adjoin_id_eq_span_one_union","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"ğ•œ : Type u_1\ninstâœ : RCLike ğ•œ\ns : Set ğ•œ\nâŠ¢ Eq â†‘(StarAlgebra.adjoin ğ•œ (Singleton.singleton (ContinuousMap.restrict s (ContinuousMap.id ğ•œ)))) â†‘(Submodule.span ğ•œ (Union.union (Singleton.singleton 1) â†‘(NonUnitalStarAlgebra.adjoin ğ•œ (Singleton.singleton (ContinuousMap.restrict s (ContinuousMap.id ğ•œ))))))","decl":"lemma adjoin_id_eq_span_one_union (s : Set ğ•œ) :\n    ((StarAlgebra.adjoin ğ•œ {(restrict s (.id ğ•œ) : C(s, ğ•œ))}) : Set C(s, ğ•œ)) =\n      span ğ•œ ({(1 : C(s, ğ•œ))} âˆª (adjoin ğ•œ {(restrict s (.id ğ•œ) : C(s, ğ•œ))})) := by\n  ext x\n  rw [SetLike.mem_coe, SetLike.mem_coe, â† StarAlgebra.adjoin_nonUnitalStarSubalgebra,\n    â† StarSubalgebra.mem_toSubalgebra, â† Subalgebra.mem_toSubmodule,\n    StarAlgebra.adjoin_nonUnitalStarSubalgebra_eq_span, span_union, span_eq_toSubmodule]\n\n"}
{"name":"ContinuousMap.adjoin_id_eq_span_one_add","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"ğ•œ : Type u_1\ninstâœ : RCLike ğ•œ\ns : Set ğ•œ\nâŠ¢ Eq (â†‘(StarAlgebra.adjoin ğ•œ (Singleton.singleton (ContinuousMap.restrict s (ContinuousMap.id ğ•œ))))) (HAdd.hAdd â†‘(Submodule.span ğ•œ (Singleton.singleton 1)) â†‘(NonUnitalStarAlgebra.adjoin ğ•œ (Singleton.singleton (ContinuousMap.restrict s (ContinuousMap.id ğ•œ)))))","decl":"open Pointwise in\nlemma adjoin_id_eq_span_one_add (s : Set ğ•œ) :\n    ((StarAlgebra.adjoin ğ•œ {(restrict s (.id ğ•œ) : C(s, ğ•œ))}) : Set C(s, ğ•œ)) =\n      (span ğ•œ {(1 : C(s, ğ•œ))} : Set C(s, ğ•œ)) + (adjoin ğ•œ {(restrict s (.id ğ•œ) : C(s, ğ•œ))}) := by\n  ext x\n  rw [SetLike.mem_coe, â† StarAlgebra.adjoin_nonUnitalStarSubalgebra,\n    â† StarSubalgebra.mem_toSubalgebra, â† Subalgebra.mem_toSubmodule,\n    StarAlgebra.adjoin_nonUnitalStarSubalgebra_eq_span, mem_sup]\n  simp [Set.mem_add]\n\n"}
{"name":"ContinuousMap.nonUnitalStarAlgebraAdjoin_id_subset_ker_evalStarAlgHom","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"ğ•œ : Type u_1\ninstâœ : RCLike ğ•œ\ns : Set ğ•œ\nh0 : Membership.mem s 0\nâŠ¢ HasSubset.Subset â†‘(NonUnitalStarAlgebra.adjoin ğ•œ (Singleton.singleton (ContinuousMap.restrict s (ContinuousMap.id ğ•œ)))) â†‘(RingHom.ker (ContinuousMap.evalStarAlgHom ğ•œ ğ•œ âŸ¨0, h0âŸ©))","decl":"lemma nonUnitalStarAlgebraAdjoin_id_subset_ker_evalStarAlgHom {s : Set ğ•œ} (h0 : 0 âˆˆ s) :\n    (adjoin ğ•œ {restrict s (.id ğ•œ)} : Set C(s, ğ•œ)) âŠ†\n      RingHom.ker (evalStarAlgHom ğ•œ ğ•œ (âŸ¨0, h0âŸ© : s)) := by\n  intro f hf\n  induction hf using adjoin_induction with\n  | mem f hf =>\n    obtain rfl := Set.mem_singleton_iff.mp hf\n    rfl\n  | add f g _ _ hf hg => exact add_mem hf hg\n  | zero => exact zero_mem _\n  | mul f g _ _ _ hg => exact Ideal.mul_mem_left _ f hg\n  | smul r f _ hf =>\n    rw [SetLike.mem_coe, RingHom.mem_ker] at hf âŠ¢\n    rw [map_smul, hf, smul_zero]\n  | star f _ hf =>\n    rw [SetLike.mem_coe, RingHom.mem_ker] at hf âŠ¢\n    rw [map_star, hf, star_zero]\n\n"}
{"name":"ContinuousMap.ker_evalStarAlgHom_inter_adjoin_id","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"ğ•œ : Type u_1\ninstâœ : RCLike ğ•œ\ns : Set ğ•œ\nh0 : Membership.mem s 0\nâŠ¢ Eq (Inter.inter â†‘(StarAlgebra.adjoin ğ•œ (Singleton.singleton (ContinuousMap.restrict s (ContinuousMap.id ğ•œ)))) â†‘(RingHom.ker (ContinuousMap.evalStarAlgHom ğ•œ ğ•œ âŸ¨0, h0âŸ©))) â†‘(NonUnitalStarAlgebra.adjoin ğ•œ (Singleton.singleton (ContinuousMap.restrict s (ContinuousMap.id ğ•œ))))","decl":"lemma ker_evalStarAlgHom_inter_adjoin_id (s : Set ğ•œ) (h0 : 0 âˆˆ s) :\n    (StarAlgebra.adjoin ğ•œ {restrict s (.id ğ•œ)} : Set C(s, ğ•œ)) âˆ©\n      RingHom.ker (evalStarAlgHom ğ•œ ğ•œ (âŸ¨0, h0âŸ© : s)) = adjoin ğ•œ {restrict s (.id ğ•œ)} := by\n  ext f\n  constructor\n  Â· rintro âŸ¨hfâ‚, hfâ‚‚âŸ©\n    rw [SetLike.mem_coe] at hfâ‚‚ âŠ¢\n    simp_rw [adjoin_id_eq_span_one_add, Set.mem_add, SetLike.mem_coe, mem_span_singleton] at hfâ‚\n    obtain âŸ¨-, âŸ¨r, rflâŸ©, f, hf, rflâŸ© := hfâ‚\n    have := nonUnitalStarAlgebraAdjoin_id_subset_ker_evalStarAlgHom h0 hf\n    simp only [SetLike.mem_coe, RingHom.mem_ker, evalStarAlgHom_apply] at hfâ‚‚ this\n    rw [add_apply, this, add_zero, smul_apply, one_apply, smul_eq_mul, mul_one] at hfâ‚‚\n    rwa [hfâ‚‚, zero_smul, zero_add]\n  Â· simp only [Set.mem_inter_iff, SetLike.mem_coe]\n    refine fun hf â†¦ âŸ¨?_, nonUnitalStarAlgebraAdjoin_id_subset_ker_evalStarAlgHom h0 hfâŸ©\n    exact adjoin_le_starAlgebra_adjoin _ _ hf\n\n-- the statement should be in terms of non unital subalgebras, but we lack API\n"}
{"name":"ContinuousMap.AlgHom.closure_ker_inter","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"F : Type u_2\nS : Type u_3\nK : Type u_4\nA : Type u_5\ninstâœÂ¹Â³ : CommRing K\ninstâœÂ¹Â² : Ring A\ninstâœÂ¹Â¹ : Algebra K A\ninstâœÂ¹â° : TopologicalSpace K\ninstâœâ¹ : T1Space K\ninstâœâ¸ : TopologicalSpace A\ninstâœâ· : ContinuousSub A\ninstâœâ¶ : ContinuousSMul K A\ninstâœâµ : FunLike F A K\ninstâœâ´ : AlgHomClass F K A K\ninstâœÂ³ : SetLike S A\ninstâœÂ² : OneMemClass S A\ninstâœÂ¹ : AddSubgroupClass S A\ninstâœ : SMulMemClass S K A\nÏ† : F\nhÏ† : Continuous â‡‘Ï†\ns : S\nâŠ¢ Eq (closure (Inter.inter â†‘s â†‘(RingHom.ker Ï†))) (Inter.inter (closure â†‘s) â†‘(RingHom.ker Ï†))","decl":"open RingHom Filter Topology in\ntheorem AlgHom.closure_ker_inter {F S K A : Type*} [CommRing K] [Ring A] [Algebra K A]\n    [TopologicalSpace K] [T1Space K] [TopologicalSpace A] [ContinuousSub A] [ContinuousSMul K A]\n    [FunLike F A K] [AlgHomClass F K A K] [SetLike S A] [OneMemClass S A] [AddSubgroupClass S A]\n    [SMulMemClass S K A] (Ï† : F) (hÏ† : Continuous Ï†) (s : S) :\n    closure (s âˆ© RingHom.ker Ï†) = closure s âˆ© (ker Ï† : Set A) := by\n  refine subset_antisymm ?_ ?_\n  Â· simpa only [ker_eq, (isClosed_singleton.preimage hÏ†).closure_eq]\n      using closure_inter_subset_inter_closure s (ker Ï† : Set A)\n  Â· intro x âŸ¨hxs, (hxÏ† : Ï† x = 0)âŸ©\n    rw [mem_closure_iff_clusterPt, ClusterPt] at hxs\n    have : Tendsto (fun y â†¦ y - Ï† y â€¢ 1) (ğ“ x âŠ“ ğ“Ÿ s) (ğ“ x) := by\n      conv => congr; rfl; rfl; rw [â† sub_zero x, â† zero_smul K 1, â† hxÏ†]\n      exact Filter.tendsto_inf_left (Continuous.tendsto (by fun_prop) x)\n    refine mem_closure_of_tendsto this <| eventually_inf_principal.mpr ?_\n    filter_upwards [] with g hg using\n      âŸ¨sub_mem hg (SMulMemClass.smul_mem _ <| one_mem _), by simp [RingHom.mem_ker]âŸ©\n\n"}
{"name":"ContinuousMap.ker_evalStarAlgHom_eq_closure_adjoin_id","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹ : RCLike ğ•œ\ns : Set ğ•œ\nh0 : Membership.mem s 0\ninstâœ : CompactSpace â†‘s\nâŠ¢ Eq (â†‘(RingHom.ker (ContinuousMap.evalStarAlgHom ğ•œ ğ•œ âŸ¨0, h0âŸ©))) (closure â†‘(NonUnitalStarAlgebra.adjoin ğ•œ (Singleton.singleton (ContinuousMap.restrict s (ContinuousMap.id ğ•œ)))))","decl":"lemma ker_evalStarAlgHom_eq_closure_adjoin_id (s : Set ğ•œ) (h0 : 0 âˆˆ s) [CompactSpace s] :\n    (RingHom.ker (evalStarAlgHom ğ•œ ğ•œ (âŸ¨0, h0âŸ© : s)) : Set C(s, ğ•œ)) =\n      closure (adjoin ğ•œ {(restrict s (.id ğ•œ))}) := by\n  rw [â† ker_evalStarAlgHom_inter_adjoin_id s h0,\n    AlgHom.closure_ker_inter (Ï† := evalStarAlgHom ğ•œ ğ•œ (X := s) âŸ¨0, h0âŸ©) (continuous_eval_const _) _]\n  convert (Set.univ_inter _).symm\n  rw [â† Polynomial.toContinuousMapOn_X_eq_restrict_id, â† Polynomial.toContinuousMapOnAlgHom_apply,\n    â† polynomialFunctions.starClosure_eq_adjoin_X s]\n  congrm(($(polynomialFunctions.starClosure_topologicalClosure s) : Set C(s, ğ•œ)))\n\n"}
{"name":"ContinuousMapZero.adjoin_id_dense","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : RCLike ğ•œ\ns : Set ğ•œ\ninstâœÂ¹ : Zero â†‘s\nh0 : Eq (â†‘0) 0\ninstâœ : CompactSpace â†‘s\nâŠ¢ Dense â†‘(NonUnitalStarAlgebra.adjoin ğ•œ (Singleton.singleton (ContinuousMapZero.id h0)))","decl":"/-- If `s : Set ğ•œ` with `RCLike ğ•œ` is compact and contains `0`, then the non-unital star subalgebra\ngenerated by the identity function in `C(s, ğ•œ)â‚€` is dense. This can be seen as a version of the\nWeierstrass approximation theorem. -/\nlemma ContinuousMapZero.adjoin_id_dense {s : Set ğ•œ} [Zero s] (h0 : ((0 : s) : ğ•œ) = 0)\n    [CompactSpace s] : Dense (adjoin ğ•œ {(.id h0 : C(s, ğ•œ)â‚€)} : Set C(s, ğ•œ)â‚€) := by\n  have h0' : 0 âˆˆ s := h0 â–¸ (0 : s).property\n  rw [dense_iff_closure_eq,\n    â† isClosedEmbedding_toContinuousMap.injective.preimage_image (closure _),\n    â† isClosedEmbedding_toContinuousMap.closure_image_eq, â† coe_toContinuousMapHom,\n    â† NonUnitalStarSubalgebra.coe_map, NonUnitalStarAlgHom.map_adjoin_singleton,\n    toContinuousMapHom_apply, toContinuousMap_id h0,\n    â† ContinuousMap.ker_evalStarAlgHom_eq_closure_adjoin_id s h0']\n  apply Set.eq_univ_of_forall fun f â†¦ ?_\n  simp only [Set.mem_preimage, toContinuousMapHom_apply, SetLike.mem_coe, RingHom.mem_ker,\n    ContinuousMap.evalStarAlgHom_apply, ContinuousMap.coe_coe]\n  rw [show âŸ¨0, h0'âŸ© = (0 : s) by ext; exact h0.symm, _root_.map_zero f]\n\n"}
{"name":"ContinuousMapZero.induction_on","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹ : RCLike ğ•œ\ns : Set ğ•œ\ninstâœ : Zero â†‘s\nh0 : Eq (â†‘0) 0\np : ContinuousMapZero (â†‘s) ğ•œ â†’ Prop\nzero : p 0\nid : p (ContinuousMapZero.id h0)\nstar_id : p (Star.star (ContinuousMapZero.id h0))\nadd : âˆ€ (f g : ContinuousMapZero (â†‘s) ğ•œ), p f â†’ p g â†’ p (HAdd.hAdd f g)\nmul : âˆ€ (f g : ContinuousMapZero (â†‘s) ğ•œ), p f â†’ p g â†’ p (HMul.hMul f g)\nsmul : âˆ€ (r : ğ•œ) (f : ContinuousMapZero (â†‘s) ğ•œ), p f â†’ p (HSMul.hSMul r f)\nclosure : (âˆ€ (f : ContinuousMapZero (â†‘s) ğ•œ), Membership.mem (NonUnitalStarAlgebra.adjoin ğ•œ (Singleton.singleton (ContinuousMapZero.id h0))) f â†’ p f) â†’ âˆ€ (f : ContinuousMapZero (â†‘s) ğ•œ), p f\nf : ContinuousMapZero (â†‘s) ğ•œ\nâŠ¢ p f","decl":"/-- An induction principle for `C(s, ğ•œ)â‚€`. -/\n@[elab_as_elim]\nlemma ContinuousMapZero.induction_on {s : Set ğ•œ} [Zero s] (h0 : ((0 : s) : ğ•œ) = 0)\n    {p : C(s, ğ•œ)â‚€ â†’ Prop} (zero : p 0) (id : p (.id h0)) (star_id : p (star (.id h0)))\n    (add : âˆ€ f g, p f â†’ p g â†’ p (f + g)) (mul : âˆ€ f g, p f â†’ p g â†’ p (f * g))\n    (smul : âˆ€ (r : ğ•œ) f, p f â†’ p (r â€¢ f))\n    (closure : (âˆ€ f âˆˆ adjoin ğ•œ {(.id h0 : C(s, ğ•œ)â‚€)}, p f) â†’ âˆ€ f, p f) (f : C(s, ğ•œ)â‚€) :\n    p f := by\n  refine closure (fun f hf => ?_) f\n  induction hf using NonUnitalAlgebra.adjoin_induction with\n  | mem f hf =>\n    simp only [Set.mem_union, Set.mem_singleton_iff, Set.mem_star] at hf\n    rw [star_eq_iff_star_eq, eq_comm (b := f)] at hf\n    obtain (rfl | rfl) := hf\n    all_goals assumption\n  | zero => exact zero\n  | add _ _ _ _ hf hg => exact add _ _ hf hg\n  | mul _ _ _ _ hf hg => exact mul _ _ hf hg\n  | smul _ _ _ hf => exact smul _ _ hf\n\n"}
{"name":"ContinuousMapZero.induction_on_of_compact","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : RCLike ğ•œ\ns : Set ğ•œ\ninstâœÂ¹ : Zero â†‘s\nh0 : Eq (â†‘0) 0\ninstâœ : CompactSpace â†‘s\np : ContinuousMapZero (â†‘s) ğ•œ â†’ Prop\nzero : p 0\nid : p (ContinuousMapZero.id h0)\nstar_id : p (Star.star (ContinuousMapZero.id h0))\nadd : âˆ€ (f g : ContinuousMapZero (â†‘s) ğ•œ), p f â†’ p g â†’ p (HAdd.hAdd f g)\nmul : âˆ€ (f g : ContinuousMapZero (â†‘s) ğ•œ), p f â†’ p g â†’ p (HMul.hMul f g)\nsmul : âˆ€ (r : ğ•œ) (f : ContinuousMapZero (â†‘s) ğ•œ), p f â†’ p (HSMul.hSMul r f)\nfrequently : âˆ€ (f : ContinuousMapZero (â†‘s) ğ•œ), Filter.Frequently (fun g => p g) (nhds f) â†’ p f\nf : ContinuousMapZero (â†‘s) ğ•œ\nâŠ¢ p f","decl":"open Topology in\n@[elab_as_elim]\ntheorem ContinuousMapZero.induction_on_of_compact {s : Set ğ•œ} [Zero s] (h0 : ((0 : s) : ğ•œ) = 0)\n    [CompactSpace s] {p : C(s, ğ•œ)â‚€ â†’ Prop} (zero : p 0) (id : p (.id h0))\n    (star_id : p (star (.id h0))) (add : âˆ€ f g, p f â†’ p g â†’ p (f + g))\n    (mul : âˆ€ f g, p f â†’ p g â†’ p (f * g)) (smul : âˆ€ (r : ğ•œ) f, p f â†’ p (r â€¢ f))\n    (frequently : âˆ€ f, (âˆƒá¶  g in ğ“ f, p g) â†’ p f) (f : C(s, ğ•œ)â‚€) :\n    p f := by\n  refine f.induction_on h0 zero id star_id add mul smul fun h f â†¦ frequently f ?_\n  have := (ContinuousMapZero.adjoin_id_dense h0).closure_eq â–¸ Set.mem_univ (x := f)\n  exact mem_closure_iff_frequently.mp this |>.mp <| .of_forall h\n\n"}
{"name":"ContinuousMapZero.nonUnitalStarAlgHom_apply_mul_eq_zero","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"ğ•œ : Type u_2\nA : Type u_3\ninstâœâ¹ : RCLike ğ•œ\ninstâœâ¸ : NonUnitalRing A\ninstâœâ· : StarRing A\ninstâœâ¶ : TopologicalSpace A\ninstâœâµ : TopologicalSemiring A\ninstâœâ´ : T2Space A\ninstâœÂ³ : Module ğ•œ A\ninstâœÂ² : IsScalarTower ğ•œ A A\ns : Set ğ•œ\ninstâœÂ¹ : Zero â†‘s\ninstâœ : CompactSpace â†‘s\nh0 : Eq (â†‘0) 0\nÏ† : NonUnitalStarAlgHom ğ•œ (ContinuousMapZero (â†‘s) ğ•œ) A\na : A\nhmul_id : Eq (HMul.hMul (Ï† (ContinuousMapZero.id h0)) a) 0\nhmul_star_id : Eq (HMul.hMul (Ï† (Star.star (ContinuousMapZero.id h0))) a) 0\nhÏ† : Continuous â‡‘Ï†\nf : ContinuousMapZero (â†‘s) ğ•œ\nâŠ¢ Eq (HMul.hMul (Ï† f) a) 0","decl":"lemma ContinuousMapZero.nonUnitalStarAlgHom_apply_mul_eq_zero {ğ•œ A : Type*}\n    [RCLike ğ•œ] [NonUnitalRing A] [StarRing A] [TopologicalSpace A] [TopologicalSemiring A]\n    [T2Space A] [Module ğ•œ A] [IsScalarTower ğ•œ A A] {s : Set ğ•œ} [Zero s] [CompactSpace s]\n    (h0 : (0 : s) = (0 : ğ•œ)) (Ï† : C(s, ğ•œ)â‚€ â†’â‹†â‚™â‚[ğ•œ] A) (a : A) (hmul_id : Ï† (.id h0) * a = 0)\n    (hmul_star_id : Ï† (star (.id h0)) * a = 0) (hÏ† : Continuous Ï†) (f : C(s, ğ•œ)â‚€) :\n    Ï† f * a = 0 := by\n  induction f using ContinuousMapZero.induction_on_of_compact h0 with\n  | zero => simp [map_zero]\n  | id => exact hmul_id\n  | star_id => exact hmul_star_id\n  | add _ _ hâ‚ hâ‚‚ => simp only [map_add, add_mul, hâ‚, hâ‚‚, zero_add]\n  | mul _ _ _ h => simp only [map_mul, mul_assoc, h, mul_zero]\n  | smul _ _ h => rw [map_smul, smul_mul_assoc, h, smul_zero]\n  | frequently f h => exact h.mem_of_closed <| isClosed_eq (by fun_prop) continuous_zero\n\n"}
{"name":"ContinuousMapZero.mul_nonUnitalStarAlgHom_apply_eq_zero","module":"Mathlib.Topology.ContinuousMap.StoneWeierstrass","initialProofState":"ğ•œ : Type u_2\nA : Type u_3\ninstâœâ¹ : RCLike ğ•œ\ninstâœâ¸ : NonUnitalRing A\ninstâœâ· : StarRing A\ninstâœâ¶ : TopologicalSpace A\ninstâœâµ : TopologicalSemiring A\ninstâœâ´ : T2Space A\ninstâœÂ³ : Module ğ•œ A\ninstâœÂ² : SMulCommClass ğ•œ A A\ns : Set ğ•œ\ninstâœÂ¹ : Zero â†‘s\ninstâœ : CompactSpace â†‘s\nh0 : Eq (â†‘0) 0\nÏ† : NonUnitalStarAlgHom ğ•œ (ContinuousMapZero (â†‘s) ğ•œ) A\na : A\nhmul_id : Eq (HMul.hMul a (Ï† (ContinuousMapZero.id h0))) 0\nhmul_star_id : Eq (HMul.hMul a (Ï† (Star.star (ContinuousMapZero.id h0)))) 0\nhÏ† : Continuous â‡‘Ï†\nf : ContinuousMapZero (â†‘s) ğ•œ\nâŠ¢ Eq (HMul.hMul a (Ï† f)) 0","decl":"lemma ContinuousMapZero.mul_nonUnitalStarAlgHom_apply_eq_zero {ğ•œ A : Type*}\n    [RCLike ğ•œ] [NonUnitalRing A] [StarRing A] [TopologicalSpace A] [TopologicalSemiring A]\n    [T2Space A] [Module ğ•œ A] [SMulCommClass ğ•œ A A] {s : Set ğ•œ} [Zero s] [CompactSpace s]\n    (h0 : (0 : s) = (0 : ğ•œ)) (Ï† : C(s, ğ•œ)â‚€ â†’â‹†â‚™â‚[ğ•œ] A) (a : A) (hmul_id : a * Ï† (.id h0) = 0)\n    (hmul_star_id : a * Ï† (star (.id h0)) = 0) (hÏ† : Continuous Ï†) (f : C(s, ğ•œ)â‚€) :\n    a * Ï† f = 0 := by\n  induction f using ContinuousMapZero.induction_on_of_compact h0 with\n  | zero => simp [map_zero]\n  | id => exact hmul_id\n  | star_id => exact hmul_star_id\n  | add _ _ hâ‚ hâ‚‚ => simp only [map_add, mul_add, hâ‚, hâ‚‚, zero_add]\n  | mul _ _ h _ => simp only [map_mul, â† mul_assoc, h, zero_mul]\n  | smul _ _ h => rw [map_smul, mul_smul_comm, h, smul_zero]\n  | frequently f h => exact h.mem_of_closed <| isClosed_eq (by fun_prop) continuous_zero\n\n"}
