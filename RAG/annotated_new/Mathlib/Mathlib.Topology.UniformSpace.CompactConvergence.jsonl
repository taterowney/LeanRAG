{"name":"ContinuousMap.tendsto_iff_forall_isCompact_tendstoUniformlyOn","module":"Mathlib.Topology.UniformSpace.CompactConvergence","initialProofState":"Œ± : Type u‚ÇÅ\nŒ≤ : Type u‚ÇÇ\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : UniformSpace Œ≤\nŒπ : Type u‚ÇÉ\np : Filter Œπ\nF : Œπ ‚Üí ContinuousMap Œ± Œ≤\nf : ContinuousMap Œ± Œ≤\n‚ä¢ Iff (Filter.Tendsto F p (nhds f)) (‚àÄ (K : Set Œ±), IsCompact K ‚Üí TendstoUniformlyOn (fun i a => (F i) a) (‚áëf) p K)","decl":"/-- Compact-open topology on `C(Œ±, Œ≤)` agrees with the topology of uniform convergence on compacts:\na family of continuous functions `F i` tends to `f` in the compact-open topology\nif and only if the `F i` tends to `f` uniformly on all compact sets. -/\ntheorem tendsto_iff_forall_isCompact_tendstoUniformlyOn\n    {Œπ : Type u‚ÇÉ} {p : Filter Œπ} {F : Œπ ‚Üí C(Œ±, Œ≤)} {f} :\n    Tendsto F p (ùìù f) ‚Üî ‚àÄ K, IsCompact K ‚Üí TendstoUniformlyOn (fun i a => F i a) f p K := by\n  rw [tendsto_nhds_compactOpen]\n  constructor\n  ¬∑ -- Let us prove that convergence in the compact-open topology\n    -- implies uniform convergence on compacts.\n    -- Consider a compact set `K`\n    intro h K hK\n    -- Since `K` is compact, it suffices to prove locally uniform convergence\n    rw [‚Üê tendstoLocallyUniformlyOn_iff_tendstoUniformlyOn_of_compact hK]\n    -- Now choose an entourage `U` in the codomain and a point `x ‚àà K`.\n    intro U hU x _\n    -- Choose an open symmetric entourage `V` such that `V ‚óã V ‚äÜ U`.\n    rcases comp_open_symm_mem_uniformity_sets hU with ‚ü®V, hV, hVo, hVsymm, hVU‚ü©\n    -- Then choose a closed entourage `W ‚äÜ V`\n    rcases mem_uniformity_isClosed hV with ‚ü®W, hW, hWc, hWU‚ü©\n    -- Consider `s = {y ‚àà K | (f x, f y) ‚àà W}`\n    set s := K ‚à© f ‚Åª¬π' ball (f x) W\n    -- This is a neighbourhood of `x` within `K`, because `W` is an entourage.\n    have hnhds : s ‚àà ùìù[K] x := inter_mem_nhdsWithin _ <| f.continuousAt _ (ball_mem_nhds _ hW)\n    -- This set is compact because it is an intersection of `K`\n    -- with a closed set `{y | (f x, f y) ‚àà W} = f ‚Åª¬π' UniformSpace.ball (f x) W`\n    have hcomp : IsCompact s := hK.inter_right <| (isClosed_ball _ hWc).preimage f.continuous\n    -- `f` maps `s` to the open set `ball (f x) V = {z | (f x, z) ‚àà V}`\n    have hmaps : MapsTo f s (ball (f x) V) := fun x hx ‚Ü¶ hWU hx.2\n    use s, hnhds\n    -- Continuous maps `F i` in a neighbourhood of `f` map `s` to `ball (f x) V` as well.\n    refine (h s hcomp _ (isOpen_ball _ hVo) hmaps).mono fun g hg y hy ‚Ü¶ ?_\n    -- Then for `y ‚àà s` we have `(f y, f x) ‚àà V` and `(f x, F i y) ‚àà V`, thus `(f y, F i y) ‚àà U`\n    exact hVU ‚ü®f x, hVsymm.mk_mem_comm.2 <| hmaps hy, hg hy‚ü©\n  ¬∑ -- Now we prove that uniform convergence on compacts\n    -- implies convergence in the compact-open topology\n    -- Consider a compact set `K`, an open set `U`, and a continuous map `f` that maps `K` to `U`\n    intro h K hK U hU hf\n    -- Due to Lebesgue number lemma, there exists an entourage `V`\n    -- such that `U` includes the `V`-thickening of `f '' K`.\n    rcases lebesgue_number_of_compact_open (hK.image (map_continuous f)) hU hf.image_subset\n        with ‚ü®V, hV, -, hVf‚ü©\n    -- Then any continuous map that is uniformly `V`-close to `f` on `K`\n    -- maps `K` to `U` as well\n    filter_upwards [h K hK V hV] with g hg x hx using hVf _ (mem_image_of_mem f hx) (hg x hx)\n\n"}
{"name":"ContinuousMap.tendsto_iff_forall_compact_tendstoUniformlyOn","module":"Mathlib.Topology.UniformSpace.CompactConvergence","initialProofState":"Œ± : Type u‚ÇÅ\nŒ≤ : Type u‚ÇÇ\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : UniformSpace Œ≤\nŒπ : Type u‚ÇÉ\np : Filter Œπ\nF : Œπ ‚Üí ContinuousMap Œ± Œ≤\nf : ContinuousMap Œ± Œ≤\n‚ä¢ Iff (Filter.Tendsto F p (nhds f)) (‚àÄ (K : Set Œ±), IsCompact K ‚Üí TendstoUniformlyOn (fun i a => (F i) a) (‚áëf) p K)","decl":"@[deprecated (since := \"2024-11-19\")] alias\ntendsto_iff_forall_compact_tendstoUniformlyOn := tendsto_iff_forall_isCompact_tendstoUniformlyOn\n\n"}
{"name":"ContinuousMap.toUniformOnFun_toFun","module":"Mathlib.Topology.UniformSpace.CompactConvergence","initialProofState":"Œ± : Type u‚ÇÅ\nŒ≤ : Type u‚ÇÇ\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : UniformSpace Œ≤\nf : ContinuousMap Œ± Œ≤\n‚ä¢ Eq ((UniformOnFun.toFun (setOf fun K => IsCompact K)) f.toUniformOnFunIsCompact) ‚áëf","decl":"@[simp]\ntheorem toUniformOnFun_toFun (f : C(Œ±, Œ≤)) :\n    UniformOnFun.toFun _ f.toUniformOnFunIsCompact = f := rfl\n\n"}
{"name":"ContinuousMap.range_toUniformOnFunIsCompact","module":"Mathlib.Topology.UniformSpace.CompactConvergence","initialProofState":"Œ± : Type u‚ÇÅ\nŒ≤ : Type u‚ÇÇ\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : UniformSpace Œ≤\n‚ä¢ Eq (Set.range ContinuousMap.toUniformOnFunIsCompact) (setOf fun f => Continuous f)","decl":"theorem range_toUniformOnFunIsCompact :\n    range (toUniformOnFunIsCompact) = {f : UniformOnFun Œ± Œ≤ {K | IsCompact K} | Continuous f} :=\n  Set.ext fun f ‚Ü¶ ‚ü®fun g ‚Ü¶ g.choose_spec ‚ñ∏ g.choose.2, fun hf ‚Ü¶ ‚ü®‚ü®f, hf‚ü©, rfl‚ü©‚ü©\n\n"}
{"name":"ContinuousMap.isUniformEmbedding_toUniformOnFunIsCompact","module":"Mathlib.Topology.UniformSpace.CompactConvergence","initialProofState":"Œ± : Type u‚ÇÅ\nŒ≤ : Type u‚ÇÇ\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : UniformSpace Œ≤\n‚ä¢ IsUniformEmbedding ContinuousMap.toUniformOnFunIsCompact","decl":"theorem isUniformEmbedding_toUniformOnFunIsCompact :\n    IsUniformEmbedding (toUniformOnFunIsCompact : C(Œ±, Œ≤) ‚Üí Œ± ‚Üí·µ§[{K | IsCompact K}] Œ≤) where\n  comap_uniformity := rfl\n  injective := DFunLike.coe_injective\n\n"}
{"name":"ContinuousMap.uniformEmbedding_toUniformOnFunIsCompact","module":"Mathlib.Topology.UniformSpace.CompactConvergence","initialProofState":"Œ± : Type u‚ÇÅ\nŒ≤ : Type u‚ÇÇ\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : UniformSpace Œ≤\n‚ä¢ IsUniformEmbedding ContinuousMap.toUniformOnFunIsCompact","decl":"@[deprecated (since := \"2024-10-01\")]\nalias uniformEmbedding_toUniformOnFunIsCompact := isUniformEmbedding_toUniformOnFunIsCompact\n\n-- The following definitions and theorems\n-- used to be a part of the construction of the `UniformSpace C(Œ±, Œ≤)` structure\n-- before it was migrated to `UniformOnFun`\n\n"}
{"name":"Filter.HasBasis.compactConvergenceUniformity","module":"Mathlib.Topology.UniformSpace.CompactConvergence","initialProofState":"Œ± : Type u‚ÇÅ\nŒ≤ : Type u‚ÇÇ\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : UniformSpace Œ≤\nŒπ : Type u_1\npi : Œπ ‚Üí Prop\ns : Œπ ‚Üí Set (Prod Œ≤ Œ≤)\nh : (uniformity Œ≤).HasBasis pi s\n‚ä¢ (uniformity (ContinuousMap Œ± Œ≤)).HasBasis (fun p => And (IsCompact p.1) (pi p.2)) fun p => setOf fun fg => ‚àÄ (x : Œ±), Membership.mem p.1 x ‚Üí Membership.mem (s p.2) { fst := fg.1 x, snd := fg.2 x }","decl":"theorem _root_.Filter.HasBasis.compactConvergenceUniformity {Œπ : Type*} {pi : Œπ ‚Üí Prop}\n    {s : Œπ ‚Üí Set (Œ≤ √ó Œ≤)} (h : (ùì§ Œ≤).HasBasis pi s) :\n    HasBasis (ùì§ C(Œ±, Œ≤)) (fun p : Set Œ± √ó Œπ => IsCompact p.1 ‚àß pi p.2) fun p =>\n      { fg : C(Œ±, Œ≤) √ó C(Œ±, Œ≤) | ‚àÄ x ‚àà p.1, (fg.1 x, fg.2 x) ‚àà s p.2 } := by\n  rw [‚Üê isUniformEmbedding_toUniformOnFunIsCompact.comap_uniformity]\n  exact .comap _ <| UniformOnFun.hasBasis_uniformity_of_basis _ _ {K | IsCompact K}\n    ‚ü®‚àÖ, isCompact_empty‚ü© (directedOn_of_sup_mem fun _ _ ‚Ü¶ IsCompact.union) h\n\n"}
{"name":"ContinuousMap.hasBasis_compactConvergenceUniformity","module":"Mathlib.Topology.UniformSpace.CompactConvergence","initialProofState":"Œ± : Type u‚ÇÅ\nŒ≤ : Type u‚ÇÇ\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : UniformSpace Œ≤\n‚ä¢ (uniformity (ContinuousMap Œ± Œ≤)).HasBasis (fun p => And (IsCompact p.1) (Membership.mem (uniformity Œ≤) p.2)) fun p => setOf fun fg => ‚àÄ (x : Œ±), Membership.mem p.1 x ‚Üí Membership.mem p.2 { fst := fg.1 x, snd := fg.2 x }","decl":"theorem hasBasis_compactConvergenceUniformity :\n    HasBasis (ùì§ C(Œ±, Œ≤)) (fun p : Set Œ± √ó Set (Œ≤ √ó Œ≤) => IsCompact p.1 ‚àß p.2 ‚àà ùì§ Œ≤) fun p =>\n      { fg : C(Œ±, Œ≤) √ó C(Œ±, Œ≤) | ‚àÄ x ‚àà p.1, (fg.1 x, fg.2 x) ‚àà p.2 } :=\n  (basis_sets _).compactConvergenceUniformity\n\n"}
{"name":"ContinuousMap.mem_compactConvergence_entourage_iff","module":"Mathlib.Topology.UniformSpace.CompactConvergence","initialProofState":"Œ± : Type u‚ÇÅ\nŒ≤ : Type u‚ÇÇ\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : UniformSpace Œ≤\nX : Set (Prod (ContinuousMap Œ± Œ≤) (ContinuousMap Œ± Œ≤))\n‚ä¢ Iff (Membership.mem (uniformity (ContinuousMap Œ± Œ≤)) X) (Exists fun K => Exists fun V => And (IsCompact K) (And (Membership.mem (uniformity Œ≤) V) (HasSubset.Subset (setOf fun fg => ‚àÄ (x : Œ±), Membership.mem K x ‚Üí Membership.mem V { fst := fg.1 x, snd := fg.2 x }) X)))","decl":"theorem mem_compactConvergence_entourage_iff (X : Set (C(Œ±, Œ≤) √ó C(Œ±, Œ≤))) :\n    X ‚àà ùì§ C(Œ±, Œ≤) ‚Üî\n      ‚àÉ (K : Set Œ±) (V : Set (Œ≤ √ó Œ≤)), IsCompact K ‚àß V ‚àà ùì§ Œ≤ ‚àß\n        { fg : C(Œ±, Œ≤) √ó C(Œ±, Œ≤) | ‚àÄ x ‚àà K, (fg.1 x, fg.2 x) ‚àà V } ‚äÜ X := by\n  simp [hasBasis_compactConvergenceUniformity.mem_iff, and_assoc]\n\n"}
{"name":"CompactExhaustion.hasBasis_compactConvergenceUniformity","module":"Mathlib.Topology.UniformSpace.CompactConvergence","initialProofState":"Œ± : Type u‚ÇÅ\nŒ≤ : Type u‚ÇÇ\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : UniformSpace Œ≤\nŒπ : Type u_1\np : Œπ ‚Üí Prop\nV : Œπ ‚Üí Set (Prod Œ≤ Œ≤)\nK : CompactExhaustion Œ±\nhb : (uniformity Œ≤).HasBasis p V\n‚ä¢ (uniformity (ContinuousMap Œ± Œ≤)).HasBasis (fun i => p i.2) fun i => setOf fun fg => ‚àÄ (x : Œ±), Membership.mem (K i.1) x ‚Üí Membership.mem (V i.2) { fst := fg.1 x, snd := fg.2 x }","decl":"/-- If `K` is a compact exhaustion of `Œ±`\nand `V i` bounded by `p i` is a basis of entourages of `Œ≤`,\nthen `fun (n, i) ‚Ü¶ {(f, g) | ‚àÄ x ‚àà K n, (f x, g x) ‚àà V i}` bounded by `p i`\nis a basis of entourages of `C(Œ±, Œ≤)`. -/\ntheorem _root_.CompactExhaustion.hasBasis_compactConvergenceUniformity {Œπ : Type*}\n    {p : Œπ ‚Üí Prop} {V : Œπ ‚Üí Set (Œ≤ √ó Œ≤)} (K : CompactExhaustion Œ±) (hb : (ùì§ Œ≤).HasBasis p V) :\n    HasBasis (ùì§ C(Œ±, Œ≤)) (fun i : ‚Ñï √ó Œπ ‚Ü¶ p i.2) fun i ‚Ü¶\n      {fg | ‚àÄ x ‚àà K i.1, (fg.1 x, fg.2 x) ‚àà V i.2} :=\n  (UniformOnFun.hasBasis_uniformity_of_covering_of_basis {K | IsCompact K} K.isCompact\n    (Monotone.directed_le K.subset) (fun _ ‚Ü¶ K.exists_superset_of_isCompact) hb).comap _\n\n"}
{"name":"CompactExhaustion.hasAntitoneBasis_compactConvergenceUniformity","module":"Mathlib.Topology.UniformSpace.CompactConvergence","initialProofState":"Œ± : Type u‚ÇÅ\nŒ≤ : Type u‚ÇÇ\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : UniformSpace Œ≤\nV : Nat ‚Üí Set (Prod Œ≤ Œ≤)\nK : CompactExhaustion Œ±\nhb : (uniformity Œ≤).HasAntitoneBasis V\n‚ä¢ (uniformity (ContinuousMap Œ± Œ≤)).HasAntitoneBasis fun n => setOf fun fg => ‚àÄ (x : Œ±), Membership.mem (K n) x ‚Üí Membership.mem (V n) { fst := fg.1 x, snd := fg.2 x }","decl":"theorem _root_.CompactExhaustion.hasAntitoneBasis_compactConvergenceUniformity\n    {V : ‚Ñï ‚Üí Set (Œ≤ √ó Œ≤)} (K : CompactExhaustion Œ±) (hb : (ùì§ Œ≤).HasAntitoneBasis V) :\n    HasAntitoneBasis (ùì§ C(Œ±, Œ≤)) fun n ‚Ü¶ {fg | ‚àÄ x ‚àà K n, (fg.1 x, fg.2 x) ‚àà V n} :=\n  (UniformOnFun.hasAntitoneBasis_uniformity {K | IsCompact K} K.isCompact\n    K.subset (fun _ ‚Ü¶ K.exists_superset_of_isCompact) hb).comap _\n\n"}
{"name":"ContinuousMap.instIsCountablyGeneratedProdUniformityOfWeaklyLocallyCompactSpaceOfSigmaCompactSpace","module":"Mathlib.Topology.UniformSpace.CompactConvergence","initialProofState":"Œ± : Type u‚ÇÅ\nŒ≤ : Type u‚ÇÇ\ninst‚úù‚Å¥ : TopologicalSpace Œ±\ninst‚úù¬≥ : UniformSpace Œ≤\ninst‚úù¬≤ : WeaklyLocallyCompactSpace Œ±\ninst‚úù¬π : SigmaCompactSpace Œ±\ninst‚úù : (uniformity Œ≤).IsCountablyGenerated\n‚ä¢ (uniformity (ContinuousMap Œ± Œ≤)).IsCountablyGenerated","decl":"/-- If `Œ±` is a weakly locally compact œÉ-compact space\n(e.g., a proper pseudometric space or a compact spaces)\nand the uniformity on `Œ≤` is pseudometrizable,\nthen the uniformity on `C(Œ±, Œ≤)` is pseudometrizable too.\n-/\ninstance [WeaklyLocallyCompactSpace Œ±] [SigmaCompactSpace Œ±] [IsCountablyGenerated (ùì§ Œ≤)] :\n    IsCountablyGenerated (ùì§ (C(Œ±, Œ≤))) :=\n  let ‚ü®_V, hV‚ü© := exists_antitone_basis (ùì§ Œ≤)\n  ((CompactExhaustion.choice Œ±).hasAntitoneBasis_compactConvergenceUniformity\n    hV).isCountablyGenerated\n\n"}
{"name":"ContinuousMap.tendsto_of_tendstoLocallyUniformly","module":"Mathlib.Topology.UniformSpace.CompactConvergence","initialProofState":"Œ± : Type u‚ÇÅ\nŒ≤ : Type u‚ÇÇ\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : UniformSpace Œ≤\nf : ContinuousMap Œ± Œ≤\nŒπ : Type u‚ÇÉ\np : Filter Œπ\nF : Œπ ‚Üí ContinuousMap Œ± Œ≤\nh : TendstoLocallyUniformly (fun i a => (F i) a) (‚áëf) p\n‚ä¢ Filter.Tendsto F p (nhds f)","decl":"/-- Locally uniform convergence implies convergence in the compact-open topology. -/\ntheorem tendsto_of_tendstoLocallyUniformly (h : TendstoLocallyUniformly (fun i a => F i a) f p) :\n    Tendsto F p (ùìù f) := by\n  rw [tendsto_iff_forall_isCompact_tendstoUniformlyOn]\n  intro K hK\n  rw [‚Üê tendstoLocallyUniformlyOn_iff_tendstoUniformlyOn_of_compact hK]\n  exact h.tendstoLocallyUniformlyOn\n\n"}
{"name":"ContinuousMap.tendsto_iff_tendstoLocallyUniformly","module":"Mathlib.Topology.UniformSpace.CompactConvergence","initialProofState":"Œ± : Type u‚ÇÅ\nŒ≤ : Type u‚ÇÇ\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : UniformSpace Œ≤\nf : ContinuousMap Œ± Œ≤\nŒπ : Type u‚ÇÉ\np : Filter Œπ\nF : Œπ ‚Üí ContinuousMap Œ± Œ≤\ninst‚úù : WeaklyLocallyCompactSpace Œ±\n‚ä¢ Iff (Filter.Tendsto F p (nhds f)) (TendstoLocallyUniformly (fun i a => (F i) a) (‚áëf) p)","decl":"/-- In a weakly locally compact space,\nconvergence in the compact-open topology is the same as locally uniform convergence.\n\nThe right-to-left implication holds in any topological space,\nsee `ContinuousMap.tendsto_of_tendstoLocallyUniformly`. -/\ntheorem tendsto_iff_tendstoLocallyUniformly [WeaklyLocallyCompactSpace Œ±] :\n    Tendsto F p (ùìù f) ‚Üî TendstoLocallyUniformly (fun i a => F i a) f p := by\n  refine ‚ü®fun h V hV x ‚Ü¶ ?_, tendsto_of_tendstoLocallyUniformly‚ü©\n  rw [tendsto_iff_forall_isCompact_tendstoUniformlyOn] at h\n  obtain ‚ü®n, hn‚ÇÅ, hn‚ÇÇ‚ü© := exists_compact_mem_nhds x\n  exact ‚ü®n, hn‚ÇÇ, h n hn‚ÇÅ V hV‚ü©\n\n"}
{"name":"ContinuousMap.uniformContinuous_comp","module":"Mathlib.Topology.UniformSpace.CompactConvergence","initialProofState":"Œ± : Type u‚ÇÅ\nŒ≤ : Type u‚ÇÇ\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : UniformSpace Œ≤\nŒ¥ : Type u_2\ninst‚úù : UniformSpace Œ¥\ng : ContinuousMap Œ≤ Œ¥\nhg : UniformContinuous ‚áëg\n‚ä¢ UniformContinuous g.comp","decl":"theorem uniformContinuous_comp (g : C(Œ≤, Œ¥)) (hg : UniformContinuous g) :\n    UniformContinuous (ContinuousMap.comp g : C(Œ±, Œ≤) ‚Üí C(Œ±, Œ¥)) :=\n  isUniformEmbedding_toUniformOnFunIsCompact.uniformContinuous_iff.mpr <|\n    UniformOnFun.postcomp_uniformContinuous hg |>.comp\n      isUniformEmbedding_toUniformOnFunIsCompact.uniformContinuous\n\n"}
{"name":"ContinuousMap.isUniformInducing_comp","module":"Mathlib.Topology.UniformSpace.CompactConvergence","initialProofState":"Œ± : Type u‚ÇÅ\nŒ≤ : Type u‚ÇÇ\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : UniformSpace Œ≤\nŒ¥ : Type u_2\ninst‚úù : UniformSpace Œ¥\ng : ContinuousMap Œ≤ Œ¥\nhg : IsUniformInducing ‚áëg\n‚ä¢ IsUniformInducing g.comp","decl":"theorem isUniformInducing_comp (g : C(Œ≤, Œ¥)) (hg : IsUniformInducing g) :\n    IsUniformInducing (ContinuousMap.comp g : C(Œ±, Œ≤) ‚Üí C(Œ±, Œ¥)) :=\n  isUniformEmbedding_toUniformOnFunIsCompact.isUniformInducing.of_comp_iff.mp <|\n    UniformOnFun.postcomp_isUniformInducing hg |>.comp\n      isUniformEmbedding_toUniformOnFunIsCompact.isUniformInducing\n\n"}
{"name":"ContinuousMap.uniformInducing_comp","module":"Mathlib.Topology.UniformSpace.CompactConvergence","initialProofState":"Œ± : Type u‚ÇÅ\nŒ≤ : Type u‚ÇÇ\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : UniformSpace Œ≤\nŒ¥ : Type u_2\ninst‚úù : UniformSpace Œ¥\ng : ContinuousMap Œ≤ Œ¥\nhg : IsUniformInducing ‚áëg\n‚ä¢ IsUniformInducing g.comp","decl":"@[deprecated (since := \"2024-10-05\")]\nalias uniformInducing_comp := isUniformInducing_comp\n\n"}
{"name":"ContinuousMap.isUniformEmbedding_comp","module":"Mathlib.Topology.UniformSpace.CompactConvergence","initialProofState":"Œ± : Type u‚ÇÅ\nŒ≤ : Type u‚ÇÇ\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : UniformSpace Œ≤\nŒ¥ : Type u_2\ninst‚úù : UniformSpace Œ¥\ng : ContinuousMap Œ≤ Œ¥\nhg : IsUniformEmbedding ‚áëg\n‚ä¢ IsUniformEmbedding g.comp","decl":"theorem isUniformEmbedding_comp (g : C(Œ≤, Œ¥)) (hg : IsUniformEmbedding g) :\n    IsUniformEmbedding (ContinuousMap.comp g : C(Œ±, Œ≤) ‚Üí C(Œ±, Œ¥)) :=\n  isUniformEmbedding_toUniformOnFunIsCompact.of_comp_iff.mp <|\n    UniformOnFun.postcomp_isUniformEmbedding hg |>.comp\n      isUniformEmbedding_toUniformOnFunIsCompact\n\n"}
{"name":"ContinuousMap.uniformEmbedding_comp","module":"Mathlib.Topology.UniformSpace.CompactConvergence","initialProofState":"Œ± : Type u‚ÇÅ\nŒ≤ : Type u‚ÇÇ\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : UniformSpace Œ≤\nŒ¥ : Type u_2\ninst‚úù : UniformSpace Œ¥\ng : ContinuousMap Œ≤ Œ¥\nhg : IsUniformEmbedding ‚áëg\n‚ä¢ IsUniformEmbedding g.comp","decl":"@[deprecated (since := \"2024-10-01\")]\nalias uniformEmbedding_comp := isUniformEmbedding_comp\n\n"}
{"name":"ContinuousMap.uniformContinuous_comp_left","module":"Mathlib.Topology.UniformSpace.CompactConvergence","initialProofState":"Œ± : Type u‚ÇÅ\nŒ≤ : Type u‚ÇÇ\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : UniformSpace Œ≤\nŒ≥ : Type u_1\ninst‚úù : TopologicalSpace Œ≥\ng : ContinuousMap Œ± Œ≥\n‚ä¢ UniformContinuous fun f => f.comp g","decl":"theorem uniformContinuous_comp_left (g : C(Œ±, Œ≥)) :\n    UniformContinuous (fun f ‚Ü¶ f.comp g : C(Œ≥, Œ≤) ‚Üí C(Œ±, Œ≤)) :=\n  isUniformEmbedding_toUniformOnFunIsCompact.uniformContinuous_iff.mpr <|\n    UniformOnFun.precomp_uniformContinuous (fun _ hK ‚Ü¶ hK.image g.continuous) |>.comp\n      isUniformEmbedding_toUniformOnFunIsCompact.uniformContinuous\n\n"}
{"name":"ContinuousMap.hasBasis_compactConvergenceUniformity_of_compact","module":"Mathlib.Topology.UniformSpace.CompactConvergence","initialProofState":"Œ± : Type u‚ÇÅ\nŒ≤ : Type u‚ÇÇ\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : UniformSpace Œ≤\ninst‚úù : CompactSpace Œ±\n‚ä¢ (uniformity (ContinuousMap Œ± Œ≤)).HasBasis (fun V => Membership.mem (uniformity Œ≤) V) fun V => setOf fun fg => ‚àÄ (x : Œ±), Membership.mem V { fst := fg.1 x, snd := fg.2 x }","decl":"theorem hasBasis_compactConvergenceUniformity_of_compact :\n    HasBasis (ùì§ C(Œ±, Œ≤)) (fun V : Set (Œ≤ √ó Œ≤) => V ‚àà ùì§ Œ≤) fun V =>\n      { fg : C(Œ±, Œ≤) √ó C(Œ±, Œ≤) | ‚àÄ x, (fg.1 x, fg.2 x) ‚àà V } :=\n  hasBasis_compactConvergenceUniformity.to_hasBasis\n    (fun p hp => ‚ü®p.2, hp.2, fun _fg hfg x _hx => hfg x‚ü©) fun V hV =>\n    ‚ü®‚ü®univ, V‚ü©, ‚ü®isCompact_univ, hV‚ü©, fun _fg hfg x => hfg x (mem_univ x)‚ü©\n\n"}
{"name":"ContinuousMap.tendsto_iff_tendstoUniformly","module":"Mathlib.Topology.UniformSpace.CompactConvergence","initialProofState":"Œ± : Type u‚ÇÅ\nŒ≤ : Type u‚ÇÇ\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : UniformSpace Œ≤\nf : ContinuousMap Œ± Œ≤\nŒπ : Type u‚ÇÉ\np : Filter Œπ\nF : Œπ ‚Üí ContinuousMap Œ± Œ≤\ninst‚úù : CompactSpace Œ±\n‚ä¢ Iff (Filter.Tendsto F p (nhds f)) (TendstoUniformly (fun i a => (F i) a) (‚áëf) p)","decl":"/-- Convergence in the compact-open topology is the same as uniform convergence for sequences of\ncontinuous functions on a compact space. -/\ntheorem tendsto_iff_tendstoUniformly :\n    Tendsto F p (ùìù f) ‚Üî TendstoUniformly (fun i a => F i a) f p := by\n  rw [tendsto_iff_forall_isCompact_tendstoUniformlyOn, ‚Üê tendstoUniformlyOn_univ]\n  exact ‚ü®fun h => h univ isCompact_univ, fun h K _hK => h.mono (subset_univ K)‚ü©\n\n"}
{"name":"ContinuousMap.uniformSpace_eq_inf_precomp_of_cover","module":"Mathlib.Topology.UniformSpace.CompactConvergence","initialProofState":"Œ± : Type u‚ÇÅ\nŒ≤ : Type u‚ÇÇ\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : UniformSpace Œ≤\nŒ¥‚ÇÅ : Type u_1\nŒ¥‚ÇÇ : Type u_2\ninst‚úù¬π : TopologicalSpace Œ¥‚ÇÅ\ninst‚úù : TopologicalSpace Œ¥‚ÇÇ\nœÜ‚ÇÅ : ContinuousMap Œ¥‚ÇÅ Œ±\nœÜ‚ÇÇ : ContinuousMap Œ¥‚ÇÇ Œ±\nh_proper‚ÇÅ : IsProperMap ‚áëœÜ‚ÇÅ\nh_proper‚ÇÇ : IsProperMap ‚áëœÜ‚ÇÇ\nh_cover : Eq (Union.union (Set.range ‚áëœÜ‚ÇÅ) (Set.range ‚áëœÜ‚ÇÇ)) Set.univ\n‚ä¢ Eq (inferInstanceAs (UniformSpace (ContinuousMap Œ± Œ≤))) (Min.min (UniformSpace.comap (fun x => x.comp œÜ‚ÇÅ) inferInstance) (UniformSpace.comap (fun x => x.comp œÜ‚ÇÇ) inferInstance))","decl":"theorem uniformSpace_eq_inf_precomp_of_cover {Œ¥‚ÇÅ Œ¥‚ÇÇ : Type*} [TopologicalSpace Œ¥‚ÇÅ]\n    [TopologicalSpace Œ¥‚ÇÇ] (œÜ‚ÇÅ : C(Œ¥‚ÇÅ, Œ±)) (œÜ‚ÇÇ : C(Œ¥‚ÇÇ, Œ±)) (h_proper‚ÇÅ : IsProperMap œÜ‚ÇÅ)\n    (h_proper‚ÇÇ : IsProperMap œÜ‚ÇÇ) (h_cover : range œÜ‚ÇÅ ‚à™ range œÜ‚ÇÇ = univ) :\n    (inferInstanceAs <| UniformSpace C(Œ±, Œ≤)) =\n      .comap (comp ¬∑ œÜ‚ÇÅ) inferInstance ‚äì\n      .comap (comp ¬∑ œÜ‚ÇÇ) inferInstance := by\n  -- We check the analogous result for `UniformOnFun` using\n  -- `UniformOnFun.uniformSpace_eq_inf_precomp_of_cover`...\n  set ùîñ : Set (Set Œ±) := {K | IsCompact K}\n  set ùîó‚ÇÅ : Set (Set Œ¥‚ÇÅ) := {K | IsCompact K}\n  set ùîó‚ÇÇ : Set (Set Œ¥‚ÇÇ) := {K | IsCompact K}\n  have h_image‚ÇÅ : MapsTo (œÜ‚ÇÅ '' ¬∑) ùîó‚ÇÅ ùîñ := fun K hK ‚Ü¶ hK.image œÜ‚ÇÅ.continuous\n  have h_image‚ÇÇ : MapsTo (œÜ‚ÇÇ '' ¬∑) ùîó‚ÇÇ ùîñ := fun K hK ‚Ü¶ hK.image œÜ‚ÇÇ.continuous\n  have h_preimage‚ÇÅ : MapsTo (œÜ‚ÇÅ ‚Åª¬π' ¬∑) ùîñ ùîó‚ÇÅ := fun K ‚Ü¶ h_proper‚ÇÅ.isCompact_preimage\n  have h_preimage‚ÇÇ : MapsTo (œÜ‚ÇÇ ‚Åª¬π' ¬∑) ùîñ ùîó‚ÇÇ := fun K ‚Ü¶ h_proper‚ÇÇ.isCompact_preimage\n  have h_cover' : ‚àÄ S ‚àà ùîñ, S ‚äÜ range œÜ‚ÇÅ ‚à™ range œÜ‚ÇÇ := fun S _ ‚Ü¶ h_cover ‚ñ∏ subset_univ _\n  -- ... and we just pull it back.\n  simp_rw +zetaDelta [compactConvergenceUniformSpace, replaceTopology_eq,\n    UniformOnFun.uniformSpace_eq_inf_precomp_of_cover _ _ _ _ _\n      h_image‚ÇÅ h_image‚ÇÇ h_preimage‚ÇÅ h_preimage‚ÇÇ h_cover',\n    UniformSpace.comap_inf, ‚Üê UniformSpace.comap_comap]\n  rfl\n\n"}
{"name":"ContinuousMap.uniformSpace_eq_iInf_precomp_of_cover","module":"Mathlib.Topology.UniformSpace.CompactConvergence","initialProofState":"Œ± : Type u‚ÇÅ\nŒ≤ : Type u‚ÇÇ\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : UniformSpace Œ≤\nŒπ : Type u‚ÇÉ\nŒ¥ : Œπ ‚Üí Type u_1\ninst‚úù : (i : Œπ) ‚Üí TopologicalSpace (Œ¥ i)\nœÜ : (i : Œπ) ‚Üí ContinuousMap (Œ¥ i) Œ±\nh_proper : ‚àÄ (i : Œπ), IsProperMap ‚áë(œÜ i)\nh_lf : LocallyFinite fun i => Set.range ‚áë(œÜ i)\nh_cover : Eq (Set.iUnion fun i => Set.range ‚áë(œÜ i)) Set.univ\n‚ä¢ Eq (inferInstanceAs (UniformSpace (ContinuousMap Œ± Œ≤))) (iInf fun i => UniformSpace.comap (fun x => x.comp (œÜ i)) inferInstance)","decl":"theorem uniformSpace_eq_iInf_precomp_of_cover {Œ¥ : Œπ ‚Üí Type*} [‚àÄ i, TopologicalSpace (Œ¥ i)]\n    (œÜ : Œ† i, C(Œ¥ i, Œ±)) (h_proper : ‚àÄ i, IsProperMap (œÜ i))\n    (h_lf : LocallyFinite fun i ‚Ü¶ range (œÜ i)) (h_cover : ‚ãÉ i, range (œÜ i) = univ) :\n    (inferInstanceAs <| UniformSpace C(Œ±, Œ≤)) = ‚®Ö i, .comap (comp ¬∑ (œÜ i)) inferInstance := by\n  -- We check the analogous result for `UniformOnFun` using\n  -- `UniformOnFun.uniformSpace_eq_iInf_precomp_of_cover`...\n  set ùîñ : Set (Set Œ±) := {K | IsCompact K}\n  set ùîó : Œ† i, Set (Set (Œ¥ i)) := fun i ‚Ü¶ {K | IsCompact K}\n  have h_image : ‚àÄ i, MapsTo (œÜ i '' ¬∑) (ùîó i) ùîñ := fun i K hK ‚Ü¶ hK.image (œÜ i).continuous\n  have h_preimage : ‚àÄ i, MapsTo (œÜ i ‚Åª¬π' ¬∑) ùîñ (ùîó i) := fun i K ‚Ü¶ (h_proper i).isCompact_preimage\n  have h_cover' : ‚àÄ S ‚àà ùîñ, ‚àÉ I : Set Œπ, I.Finite ‚àß S ‚äÜ ‚ãÉ i ‚àà I, range (œÜ i) := fun S hS ‚Ü¶ by\n    refine ‚ü®{i | (range (œÜ i) ‚à© S).Nonempty}, h_lf.finite_nonempty_inter_compact hS,\n      inter_eq_right.mp ?_‚ü©\n    simp_rw [iUnion‚ÇÇ_inter, mem_setOf, iUnion_nonempty_self, ‚Üê iUnion_inter, h_cover, univ_inter]\n  -- ... and we just pull it back.\n  simp_rw +zetaDelta [compactConvergenceUniformSpace, replaceTopology_eq,\n    UniformOnFun.uniformSpace_eq_iInf_precomp_of_cover _ _ _ h_image h_preimage h_cover',\n    UniformSpace.comap_iInf, ‚Üê UniformSpace.comap_comap]\n  rfl\n\n"}
{"name":"ContinuousMap.completeSpace_of_restrictGenTopology","module":"Mathlib.Topology.UniformSpace.CompactConvergence","initialProofState":"Œ± : Type u‚ÇÅ\nŒ≤ : Type u‚ÇÇ\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : UniformSpace Œ≤\ninst‚úù : CompleteSpace Œ≤\nh : Topology.RestrictGenTopology (setOf fun K => IsCompact K)\n‚ä¢ CompleteSpace (ContinuousMap Œ± Œ≤)","decl":"/-- If the topology on `Œ±` is generated by its restrictions to compact sets, then the space of\ncontinuous maps `C(Œ±, Œ≤)` is complete (wrt the compact convergence uniformity).\n\nSufficient conditions on `Œ±` to satisfy this condition are (weak) local compactness (see\n`ContinuousMap.instCompleteSpaceOfWeaklyLocallyCompactSpace`) and sequential compactness (see\n`ContinuousMap.instCompleteSpaceOfSequentialSpace`). -/\nlemma completeSpace_of_restrictGenTopology (h : RestrictGenTopology {K : Set Œ± | IsCompact K}) :\n    CompleteSpace C(Œ±, Œ≤) := by\n  rw [completeSpace_iff_isComplete_range\n    isUniformEmbedding_toUniformOnFunIsCompact.isUniformInducing,\n    range_toUniformOnFunIsCompact, ‚Üê completeSpace_coe_iff_isComplete]\n  exact (UniformOnFun.isClosed_setOf_continuous h).completeSpace_coe\n\n"}
{"name":"ContinuousMap.instCompleteSpaceOfWeaklyLocallyCompactSpace","module":"Mathlib.Topology.UniformSpace.CompactConvergence","initialProofState":"Œ± : Type u‚ÇÅ\nŒ≤ : Type u‚ÇÇ\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : UniformSpace Œ≤\ninst‚úù¬π : CompleteSpace Œ≤\ninst‚úù : WeaklyLocallyCompactSpace Œ±\n‚ä¢ CompleteSpace (ContinuousMap Œ± Œ≤)","decl":"instance instCompleteSpaceOfWeaklyLocallyCompactSpace [WeaklyLocallyCompactSpace Œ±] :\n    CompleteSpace C(Œ±, Œ≤) :=\n  completeSpace_of_restrictGenTopology RestrictGenTopology.isCompact_of_weaklyLocallyCompact\n\n"}
{"name":"ContinuousMap.instCompleteSpaceOfSequentialSpace","module":"Mathlib.Topology.UniformSpace.CompactConvergence","initialProofState":"Œ± : Type u‚ÇÅ\nŒ≤ : Type u‚ÇÇ\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : UniformSpace Œ≤\ninst‚úù¬π : CompleteSpace Œ≤\ninst‚úù : SequentialSpace Œ±\n‚ä¢ CompleteSpace (ContinuousMap Œ± Œ≤)","decl":"instance instCompleteSpaceOfSequentialSpace [SequentialSpace Œ±] :\n    CompleteSpace C(Œ±, Œ≤) :=\n  completeSpace_of_restrictGenTopology RestrictGenTopology.isCompact_of_seq\n\n"}
