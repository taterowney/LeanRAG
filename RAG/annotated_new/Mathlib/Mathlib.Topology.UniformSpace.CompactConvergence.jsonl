{"name":"ContinuousMap.tendsto_iff_forall_isCompact_tendstoUniformlyOn","module":"Mathlib.Topology.UniformSpace.CompactConvergence","initialProofState":"α : Type u₁\nβ : Type u₂\ninst✝¹ : TopologicalSpace α\ninst✝ : UniformSpace β\nι : Type u₃\np : Filter ι\nF : ι → ContinuousMap α β\nf : ContinuousMap α β\n⊢ Iff (Filter.Tendsto F p (nhds f)) (∀ (K : Set α), IsCompact K → TendstoUniformlyOn (fun i a => (F i) a) (⇑f) p K)","decl":"/-- Compact-open topology on `C(α, β)` agrees with the topology of uniform convergence on compacts:\na family of continuous functions `F i` tends to `f` in the compact-open topology\nif and only if the `F i` tends to `f` uniformly on all compact sets. -/\ntheorem tendsto_iff_forall_isCompact_tendstoUniformlyOn\n    {ι : Type u₃} {p : Filter ι} {F : ι → C(α, β)} {f} :\n    Tendsto F p (𝓝 f) ↔ ∀ K, IsCompact K → TendstoUniformlyOn (fun i a => F i a) f p K := by\n  rw [tendsto_nhds_compactOpen]\n  constructor\n  · -- Let us prove that convergence in the compact-open topology\n    -- implies uniform convergence on compacts.\n    -- Consider a compact set `K`\n    intro h K hK\n    -- Since `K` is compact, it suffices to prove locally uniform convergence\n    rw [← tendstoLocallyUniformlyOn_iff_tendstoUniformlyOn_of_compact hK]\n    -- Now choose an entourage `U` in the codomain and a point `x ∈ K`.\n    intro U hU x _\n    -- Choose an open symmetric entourage `V` such that `V ○ V ⊆ U`.\n    rcases comp_open_symm_mem_uniformity_sets hU with ⟨V, hV, hVo, hVsymm, hVU⟩\n    -- Then choose a closed entourage `W ⊆ V`\n    rcases mem_uniformity_isClosed hV with ⟨W, hW, hWc, hWU⟩\n    -- Consider `s = {y ∈ K | (f x, f y) ∈ W}`\n    set s := K ∩ f ⁻¹' ball (f x) W\n    -- This is a neighbourhood of `x` within `K`, because `W` is an entourage.\n    have hnhds : s ∈ 𝓝[K] x := inter_mem_nhdsWithin _ <| f.continuousAt _ (ball_mem_nhds _ hW)\n    -- This set is compact because it is an intersection of `K`\n    -- with a closed set `{y | (f x, f y) ∈ W} = f ⁻¹' UniformSpace.ball (f x) W`\n    have hcomp : IsCompact s := hK.inter_right <| (isClosed_ball _ hWc).preimage f.continuous\n    -- `f` maps `s` to the open set `ball (f x) V = {z | (f x, z) ∈ V}`\n    have hmaps : MapsTo f s (ball (f x) V) := fun x hx ↦ hWU hx.2\n    use s, hnhds\n    -- Continuous maps `F i` in a neighbourhood of `f` map `s` to `ball (f x) V` as well.\n    refine (h s hcomp _ (isOpen_ball _ hVo) hmaps).mono fun g hg y hy ↦ ?_\n    -- Then for `y ∈ s` we have `(f y, f x) ∈ V` and `(f x, F i y) ∈ V`, thus `(f y, F i y) ∈ U`\n    exact hVU ⟨f x, hVsymm.mk_mem_comm.2 <| hmaps hy, hg hy⟩\n  · -- Now we prove that uniform convergence on compacts\n    -- implies convergence in the compact-open topology\n    -- Consider a compact set `K`, an open set `U`, and a continuous map `f` that maps `K` to `U`\n    intro h K hK U hU hf\n    -- Due to Lebesgue number lemma, there exists an entourage `V`\n    -- such that `U` includes the `V`-thickening of `f '' K`.\n    rcases lebesgue_number_of_compact_open (hK.image (map_continuous f)) hU hf.image_subset\n        with ⟨V, hV, -, hVf⟩\n    -- Then any continuous map that is uniformly `V`-close to `f` on `K`\n    -- maps `K` to `U` as well\n    filter_upwards [h K hK V hV] with g hg x hx using hVf _ (mem_image_of_mem f hx) (hg x hx)\n\n"}
{"name":"ContinuousMap.tendsto_iff_forall_compact_tendstoUniformlyOn","module":"Mathlib.Topology.UniformSpace.CompactConvergence","initialProofState":"α : Type u₁\nβ : Type u₂\ninst✝¹ : TopologicalSpace α\ninst✝ : UniformSpace β\nι : Type u₃\np : Filter ι\nF : ι → ContinuousMap α β\nf : ContinuousMap α β\n⊢ Iff (Filter.Tendsto F p (nhds f)) (∀ (K : Set α), IsCompact K → TendstoUniformlyOn (fun i a => (F i) a) (⇑f) p K)","decl":"@[deprecated (since := \"2024-11-19\")] alias\ntendsto_iff_forall_compact_tendstoUniformlyOn := tendsto_iff_forall_isCompact_tendstoUniformlyOn\n\n"}
{"name":"ContinuousMap.toUniformOnFun_toFun","module":"Mathlib.Topology.UniformSpace.CompactConvergence","initialProofState":"α : Type u₁\nβ : Type u₂\ninst✝¹ : TopologicalSpace α\ninst✝ : UniformSpace β\nf : ContinuousMap α β\n⊢ Eq ((UniformOnFun.toFun (setOf fun K => IsCompact K)) f.toUniformOnFunIsCompact) ⇑f","decl":"@[simp]\ntheorem toUniformOnFun_toFun (f : C(α, β)) :\n    UniformOnFun.toFun _ f.toUniformOnFunIsCompact = f := rfl\n\n"}
{"name":"ContinuousMap.range_toUniformOnFunIsCompact","module":"Mathlib.Topology.UniformSpace.CompactConvergence","initialProofState":"α : Type u₁\nβ : Type u₂\ninst✝¹ : TopologicalSpace α\ninst✝ : UniformSpace β\n⊢ Eq (Set.range ContinuousMap.toUniformOnFunIsCompact) (setOf fun f => Continuous f)","decl":"theorem range_toUniformOnFunIsCompact :\n    range (toUniformOnFunIsCompact) = {f : UniformOnFun α β {K | IsCompact K} | Continuous f} :=\n  Set.ext fun f ↦ ⟨fun g ↦ g.choose_spec ▸ g.choose.2, fun hf ↦ ⟨⟨f, hf⟩, rfl⟩⟩\n\n"}
{"name":"ContinuousMap.isUniformEmbedding_toUniformOnFunIsCompact","module":"Mathlib.Topology.UniformSpace.CompactConvergence","initialProofState":"α : Type u₁\nβ : Type u₂\ninst✝¹ : TopologicalSpace α\ninst✝ : UniformSpace β\n⊢ IsUniformEmbedding ContinuousMap.toUniformOnFunIsCompact","decl":"theorem isUniformEmbedding_toUniformOnFunIsCompact :\n    IsUniformEmbedding (toUniformOnFunIsCompact : C(α, β) → α →ᵤ[{K | IsCompact K}] β) where\n  comap_uniformity := rfl\n  injective := DFunLike.coe_injective\n\n"}
{"name":"ContinuousMap.uniformEmbedding_toUniformOnFunIsCompact","module":"Mathlib.Topology.UniformSpace.CompactConvergence","initialProofState":"α : Type u₁\nβ : Type u₂\ninst✝¹ : TopologicalSpace α\ninst✝ : UniformSpace β\n⊢ IsUniformEmbedding ContinuousMap.toUniformOnFunIsCompact","decl":"@[deprecated (since := \"2024-10-01\")]\nalias uniformEmbedding_toUniformOnFunIsCompact := isUniformEmbedding_toUniformOnFunIsCompact\n\n-- The following definitions and theorems\n-- used to be a part of the construction of the `UniformSpace C(α, β)` structure\n-- before it was migrated to `UniformOnFun`\n\n"}
{"name":"Filter.HasBasis.compactConvergenceUniformity","module":"Mathlib.Topology.UniformSpace.CompactConvergence","initialProofState":"α : Type u₁\nβ : Type u₂\ninst✝¹ : TopologicalSpace α\ninst✝ : UniformSpace β\nι : Type u_1\npi : ι → Prop\ns : ι → Set (Prod β β)\nh : (uniformity β).HasBasis pi s\n⊢ (uniformity (ContinuousMap α β)).HasBasis (fun p => And (IsCompact p.1) (pi p.2)) fun p => setOf fun fg => ∀ (x : α), Membership.mem p.1 x → Membership.mem (s p.2) { fst := fg.1 x, snd := fg.2 x }","decl":"theorem _root_.Filter.HasBasis.compactConvergenceUniformity {ι : Type*} {pi : ι → Prop}\n    {s : ι → Set (β × β)} (h : (𝓤 β).HasBasis pi s) :\n    HasBasis (𝓤 C(α, β)) (fun p : Set α × ι => IsCompact p.1 ∧ pi p.2) fun p =>\n      { fg : C(α, β) × C(α, β) | ∀ x ∈ p.1, (fg.1 x, fg.2 x) ∈ s p.2 } := by\n  rw [← isUniformEmbedding_toUniformOnFunIsCompact.comap_uniformity]\n  exact .comap _ <| UniformOnFun.hasBasis_uniformity_of_basis _ _ {K | IsCompact K}\n    ⟨∅, isCompact_empty⟩ (directedOn_of_sup_mem fun _ _ ↦ IsCompact.union) h\n\n"}
{"name":"ContinuousMap.hasBasis_compactConvergenceUniformity","module":"Mathlib.Topology.UniformSpace.CompactConvergence","initialProofState":"α : Type u₁\nβ : Type u₂\ninst✝¹ : TopologicalSpace α\ninst✝ : UniformSpace β\n⊢ (uniformity (ContinuousMap α β)).HasBasis (fun p => And (IsCompact p.1) (Membership.mem (uniformity β) p.2)) fun p => setOf fun fg => ∀ (x : α), Membership.mem p.1 x → Membership.mem p.2 { fst := fg.1 x, snd := fg.2 x }","decl":"theorem hasBasis_compactConvergenceUniformity :\n    HasBasis (𝓤 C(α, β)) (fun p : Set α × Set (β × β) => IsCompact p.1 ∧ p.2 ∈ 𝓤 β) fun p =>\n      { fg : C(α, β) × C(α, β) | ∀ x ∈ p.1, (fg.1 x, fg.2 x) ∈ p.2 } :=\n  (basis_sets _).compactConvergenceUniformity\n\n"}
{"name":"ContinuousMap.mem_compactConvergence_entourage_iff","module":"Mathlib.Topology.UniformSpace.CompactConvergence","initialProofState":"α : Type u₁\nβ : Type u₂\ninst✝¹ : TopologicalSpace α\ninst✝ : UniformSpace β\nX : Set (Prod (ContinuousMap α β) (ContinuousMap α β))\n⊢ Iff (Membership.mem (uniformity (ContinuousMap α β)) X) (Exists fun K => Exists fun V => And (IsCompact K) (And (Membership.mem (uniformity β) V) (HasSubset.Subset (setOf fun fg => ∀ (x : α), Membership.mem K x → Membership.mem V { fst := fg.1 x, snd := fg.2 x }) X)))","decl":"theorem mem_compactConvergence_entourage_iff (X : Set (C(α, β) × C(α, β))) :\n    X ∈ 𝓤 C(α, β) ↔\n      ∃ (K : Set α) (V : Set (β × β)), IsCompact K ∧ V ∈ 𝓤 β ∧\n        { fg : C(α, β) × C(α, β) | ∀ x ∈ K, (fg.1 x, fg.2 x) ∈ V } ⊆ X := by\n  simp [hasBasis_compactConvergenceUniformity.mem_iff, and_assoc]\n\n"}
{"name":"CompactExhaustion.hasBasis_compactConvergenceUniformity","module":"Mathlib.Topology.UniformSpace.CompactConvergence","initialProofState":"α : Type u₁\nβ : Type u₂\ninst✝¹ : TopologicalSpace α\ninst✝ : UniformSpace β\nι : Type u_1\np : ι → Prop\nV : ι → Set (Prod β β)\nK : CompactExhaustion α\nhb : (uniformity β).HasBasis p V\n⊢ (uniformity (ContinuousMap α β)).HasBasis (fun i => p i.2) fun i => setOf fun fg => ∀ (x : α), Membership.mem (K i.1) x → Membership.mem (V i.2) { fst := fg.1 x, snd := fg.2 x }","decl":"/-- If `K` is a compact exhaustion of `α`\nand `V i` bounded by `p i` is a basis of entourages of `β`,\nthen `fun (n, i) ↦ {(f, g) | ∀ x ∈ K n, (f x, g x) ∈ V i}` bounded by `p i`\nis a basis of entourages of `C(α, β)`. -/\ntheorem _root_.CompactExhaustion.hasBasis_compactConvergenceUniformity {ι : Type*}\n    {p : ι → Prop} {V : ι → Set (β × β)} (K : CompactExhaustion α) (hb : (𝓤 β).HasBasis p V) :\n    HasBasis (𝓤 C(α, β)) (fun i : ℕ × ι ↦ p i.2) fun i ↦\n      {fg | ∀ x ∈ K i.1, (fg.1 x, fg.2 x) ∈ V i.2} :=\n  (UniformOnFun.hasBasis_uniformity_of_covering_of_basis {K | IsCompact K} K.isCompact\n    (Monotone.directed_le K.subset) (fun _ ↦ K.exists_superset_of_isCompact) hb).comap _\n\n"}
{"name":"CompactExhaustion.hasAntitoneBasis_compactConvergenceUniformity","module":"Mathlib.Topology.UniformSpace.CompactConvergence","initialProofState":"α : Type u₁\nβ : Type u₂\ninst✝¹ : TopologicalSpace α\ninst✝ : UniformSpace β\nV : Nat → Set (Prod β β)\nK : CompactExhaustion α\nhb : (uniformity β).HasAntitoneBasis V\n⊢ (uniformity (ContinuousMap α β)).HasAntitoneBasis fun n => setOf fun fg => ∀ (x : α), Membership.mem (K n) x → Membership.mem (V n) { fst := fg.1 x, snd := fg.2 x }","decl":"theorem _root_.CompactExhaustion.hasAntitoneBasis_compactConvergenceUniformity\n    {V : ℕ → Set (β × β)} (K : CompactExhaustion α) (hb : (𝓤 β).HasAntitoneBasis V) :\n    HasAntitoneBasis (𝓤 C(α, β)) fun n ↦ {fg | ∀ x ∈ K n, (fg.1 x, fg.2 x) ∈ V n} :=\n  (UniformOnFun.hasAntitoneBasis_uniformity {K | IsCompact K} K.isCompact\n    K.subset (fun _ ↦ K.exists_superset_of_isCompact) hb).comap _\n\n"}
{"name":"ContinuousMap.instIsCountablyGeneratedProdUniformityOfWeaklyLocallyCompactSpaceOfSigmaCompactSpace","module":"Mathlib.Topology.UniformSpace.CompactConvergence","initialProofState":"α : Type u₁\nβ : Type u₂\ninst✝⁴ : TopologicalSpace α\ninst✝³ : UniformSpace β\ninst✝² : WeaklyLocallyCompactSpace α\ninst✝¹ : SigmaCompactSpace α\ninst✝ : (uniformity β).IsCountablyGenerated\n⊢ (uniformity (ContinuousMap α β)).IsCountablyGenerated","decl":"/-- If `α` is a weakly locally compact σ-compact space\n(e.g., a proper pseudometric space or a compact spaces)\nand the uniformity on `β` is pseudometrizable,\nthen the uniformity on `C(α, β)` is pseudometrizable too.\n-/\ninstance [WeaklyLocallyCompactSpace α] [SigmaCompactSpace α] [IsCountablyGenerated (𝓤 β)] :\n    IsCountablyGenerated (𝓤 (C(α, β))) :=\n  let ⟨_V, hV⟩ := exists_antitone_basis (𝓤 β)\n  ((CompactExhaustion.choice α).hasAntitoneBasis_compactConvergenceUniformity\n    hV).isCountablyGenerated\n\n"}
{"name":"ContinuousMap.tendsto_of_tendstoLocallyUniformly","module":"Mathlib.Topology.UniformSpace.CompactConvergence","initialProofState":"α : Type u₁\nβ : Type u₂\ninst✝¹ : TopologicalSpace α\ninst✝ : UniformSpace β\nf : ContinuousMap α β\nι : Type u₃\np : Filter ι\nF : ι → ContinuousMap α β\nh : TendstoLocallyUniformly (fun i a => (F i) a) (⇑f) p\n⊢ Filter.Tendsto F p (nhds f)","decl":"/-- Locally uniform convergence implies convergence in the compact-open topology. -/\ntheorem tendsto_of_tendstoLocallyUniformly (h : TendstoLocallyUniformly (fun i a => F i a) f p) :\n    Tendsto F p (𝓝 f) := by\n  rw [tendsto_iff_forall_isCompact_tendstoUniformlyOn]\n  intro K hK\n  rw [← tendstoLocallyUniformlyOn_iff_tendstoUniformlyOn_of_compact hK]\n  exact h.tendstoLocallyUniformlyOn\n\n"}
{"name":"ContinuousMap.tendsto_iff_tendstoLocallyUniformly","module":"Mathlib.Topology.UniformSpace.CompactConvergence","initialProofState":"α : Type u₁\nβ : Type u₂\ninst✝² : TopologicalSpace α\ninst✝¹ : UniformSpace β\nf : ContinuousMap α β\nι : Type u₃\np : Filter ι\nF : ι → ContinuousMap α β\ninst✝ : WeaklyLocallyCompactSpace α\n⊢ Iff (Filter.Tendsto F p (nhds f)) (TendstoLocallyUniformly (fun i a => (F i) a) (⇑f) p)","decl":"/-- In a weakly locally compact space,\nconvergence in the compact-open topology is the same as locally uniform convergence.\n\nThe right-to-left implication holds in any topological space,\nsee `ContinuousMap.tendsto_of_tendstoLocallyUniformly`. -/\ntheorem tendsto_iff_tendstoLocallyUniformly [WeaklyLocallyCompactSpace α] :\n    Tendsto F p (𝓝 f) ↔ TendstoLocallyUniformly (fun i a => F i a) f p := by\n  refine ⟨fun h V hV x ↦ ?_, tendsto_of_tendstoLocallyUniformly⟩\n  rw [tendsto_iff_forall_isCompact_tendstoUniformlyOn] at h\n  obtain ⟨n, hn₁, hn₂⟩ := exists_compact_mem_nhds x\n  exact ⟨n, hn₂, h n hn₁ V hV⟩\n\n"}
{"name":"ContinuousMap.uniformContinuous_comp","module":"Mathlib.Topology.UniformSpace.CompactConvergence","initialProofState":"α : Type u₁\nβ : Type u₂\ninst✝² : TopologicalSpace α\ninst✝¹ : UniformSpace β\nδ : Type u_2\ninst✝ : UniformSpace δ\ng : ContinuousMap β δ\nhg : UniformContinuous ⇑g\n⊢ UniformContinuous g.comp","decl":"theorem uniformContinuous_comp (g : C(β, δ)) (hg : UniformContinuous g) :\n    UniformContinuous (ContinuousMap.comp g : C(α, β) → C(α, δ)) :=\n  isUniformEmbedding_toUniformOnFunIsCompact.uniformContinuous_iff.mpr <|\n    UniformOnFun.postcomp_uniformContinuous hg |>.comp\n      isUniformEmbedding_toUniformOnFunIsCompact.uniformContinuous\n\n"}
{"name":"ContinuousMap.isUniformInducing_comp","module":"Mathlib.Topology.UniformSpace.CompactConvergence","initialProofState":"α : Type u₁\nβ : Type u₂\ninst✝² : TopologicalSpace α\ninst✝¹ : UniformSpace β\nδ : Type u_2\ninst✝ : UniformSpace δ\ng : ContinuousMap β δ\nhg : IsUniformInducing ⇑g\n⊢ IsUniformInducing g.comp","decl":"theorem isUniformInducing_comp (g : C(β, δ)) (hg : IsUniformInducing g) :\n    IsUniformInducing (ContinuousMap.comp g : C(α, β) → C(α, δ)) :=\n  isUniformEmbedding_toUniformOnFunIsCompact.isUniformInducing.of_comp_iff.mp <|\n    UniformOnFun.postcomp_isUniformInducing hg |>.comp\n      isUniformEmbedding_toUniformOnFunIsCompact.isUniformInducing\n\n"}
{"name":"ContinuousMap.uniformInducing_comp","module":"Mathlib.Topology.UniformSpace.CompactConvergence","initialProofState":"α : Type u₁\nβ : Type u₂\ninst✝² : TopologicalSpace α\ninst✝¹ : UniformSpace β\nδ : Type u_2\ninst✝ : UniformSpace δ\ng : ContinuousMap β δ\nhg : IsUniformInducing ⇑g\n⊢ IsUniformInducing g.comp","decl":"@[deprecated (since := \"2024-10-05\")]\nalias uniformInducing_comp := isUniformInducing_comp\n\n"}
{"name":"ContinuousMap.isUniformEmbedding_comp","module":"Mathlib.Topology.UniformSpace.CompactConvergence","initialProofState":"α : Type u₁\nβ : Type u₂\ninst✝² : TopologicalSpace α\ninst✝¹ : UniformSpace β\nδ : Type u_2\ninst✝ : UniformSpace δ\ng : ContinuousMap β δ\nhg : IsUniformEmbedding ⇑g\n⊢ IsUniformEmbedding g.comp","decl":"theorem isUniformEmbedding_comp (g : C(β, δ)) (hg : IsUniformEmbedding g) :\n    IsUniformEmbedding (ContinuousMap.comp g : C(α, β) → C(α, δ)) :=\n  isUniformEmbedding_toUniformOnFunIsCompact.of_comp_iff.mp <|\n    UniformOnFun.postcomp_isUniformEmbedding hg |>.comp\n      isUniformEmbedding_toUniformOnFunIsCompact\n\n"}
{"name":"ContinuousMap.uniformEmbedding_comp","module":"Mathlib.Topology.UniformSpace.CompactConvergence","initialProofState":"α : Type u₁\nβ : Type u₂\ninst✝² : TopologicalSpace α\ninst✝¹ : UniformSpace β\nδ : Type u_2\ninst✝ : UniformSpace δ\ng : ContinuousMap β δ\nhg : IsUniformEmbedding ⇑g\n⊢ IsUniformEmbedding g.comp","decl":"@[deprecated (since := \"2024-10-01\")]\nalias uniformEmbedding_comp := isUniformEmbedding_comp\n\n"}
{"name":"ContinuousMap.uniformContinuous_comp_left","module":"Mathlib.Topology.UniformSpace.CompactConvergence","initialProofState":"α : Type u₁\nβ : Type u₂\ninst✝² : TopologicalSpace α\ninst✝¹ : UniformSpace β\nγ : Type u_1\ninst✝ : TopologicalSpace γ\ng : ContinuousMap α γ\n⊢ UniformContinuous fun f => f.comp g","decl":"theorem uniformContinuous_comp_left (g : C(α, γ)) :\n    UniformContinuous (fun f ↦ f.comp g : C(γ, β) → C(α, β)) :=\n  isUniformEmbedding_toUniformOnFunIsCompact.uniformContinuous_iff.mpr <|\n    UniformOnFun.precomp_uniformContinuous (fun _ hK ↦ hK.image g.continuous) |>.comp\n      isUniformEmbedding_toUniformOnFunIsCompact.uniformContinuous\n\n"}
{"name":"ContinuousMap.hasBasis_compactConvergenceUniformity_of_compact","module":"Mathlib.Topology.UniformSpace.CompactConvergence","initialProofState":"α : Type u₁\nβ : Type u₂\ninst✝² : TopologicalSpace α\ninst✝¹ : UniformSpace β\ninst✝ : CompactSpace α\n⊢ (uniformity (ContinuousMap α β)).HasBasis (fun V => Membership.mem (uniformity β) V) fun V => setOf fun fg => ∀ (x : α), Membership.mem V { fst := fg.1 x, snd := fg.2 x }","decl":"theorem hasBasis_compactConvergenceUniformity_of_compact :\n    HasBasis (𝓤 C(α, β)) (fun V : Set (β × β) => V ∈ 𝓤 β) fun V =>\n      { fg : C(α, β) × C(α, β) | ∀ x, (fg.1 x, fg.2 x) ∈ V } :=\n  hasBasis_compactConvergenceUniformity.to_hasBasis\n    (fun p hp => ⟨p.2, hp.2, fun _fg hfg x _hx => hfg x⟩) fun V hV =>\n    ⟨⟨univ, V⟩, ⟨isCompact_univ, hV⟩, fun _fg hfg x => hfg x (mem_univ x)⟩\n\n"}
{"name":"ContinuousMap.tendsto_iff_tendstoUniformly","module":"Mathlib.Topology.UniformSpace.CompactConvergence","initialProofState":"α : Type u₁\nβ : Type u₂\ninst✝² : TopologicalSpace α\ninst✝¹ : UniformSpace β\nf : ContinuousMap α β\nι : Type u₃\np : Filter ι\nF : ι → ContinuousMap α β\ninst✝ : CompactSpace α\n⊢ Iff (Filter.Tendsto F p (nhds f)) (TendstoUniformly (fun i a => (F i) a) (⇑f) p)","decl":"/-- Convergence in the compact-open topology is the same as uniform convergence for sequences of\ncontinuous functions on a compact space. -/\ntheorem tendsto_iff_tendstoUniformly :\n    Tendsto F p (𝓝 f) ↔ TendstoUniformly (fun i a => F i a) f p := by\n  rw [tendsto_iff_forall_isCompact_tendstoUniformlyOn, ← tendstoUniformlyOn_univ]\n  exact ⟨fun h => h univ isCompact_univ, fun h K _hK => h.mono (subset_univ K)⟩\n\n"}
{"name":"ContinuousMap.uniformSpace_eq_inf_precomp_of_cover","module":"Mathlib.Topology.UniformSpace.CompactConvergence","initialProofState":"α : Type u₁\nβ : Type u₂\ninst✝³ : TopologicalSpace α\ninst✝² : UniformSpace β\nδ₁ : Type u_1\nδ₂ : Type u_2\ninst✝¹ : TopologicalSpace δ₁\ninst✝ : TopologicalSpace δ₂\nφ₁ : ContinuousMap δ₁ α\nφ₂ : ContinuousMap δ₂ α\nh_proper₁ : IsProperMap ⇑φ₁\nh_proper₂ : IsProperMap ⇑φ₂\nh_cover : Eq (Union.union (Set.range ⇑φ₁) (Set.range ⇑φ₂)) Set.univ\n⊢ Eq (inferInstanceAs (UniformSpace (ContinuousMap α β))) (Min.min (UniformSpace.comap (fun x => x.comp φ₁) inferInstance) (UniformSpace.comap (fun x => x.comp φ₂) inferInstance))","decl":"theorem uniformSpace_eq_inf_precomp_of_cover {δ₁ δ₂ : Type*} [TopologicalSpace δ₁]\n    [TopologicalSpace δ₂] (φ₁ : C(δ₁, α)) (φ₂ : C(δ₂, α)) (h_proper₁ : IsProperMap φ₁)\n    (h_proper₂ : IsProperMap φ₂) (h_cover : range φ₁ ∪ range φ₂ = univ) :\n    (inferInstanceAs <| UniformSpace C(α, β)) =\n      .comap (comp · φ₁) inferInstance ⊓\n      .comap (comp · φ₂) inferInstance := by\n  -- We check the analogous result for `UniformOnFun` using\n  -- `UniformOnFun.uniformSpace_eq_inf_precomp_of_cover`...\n  set 𝔖 : Set (Set α) := {K | IsCompact K}\n  set 𝔗₁ : Set (Set δ₁) := {K | IsCompact K}\n  set 𝔗₂ : Set (Set δ₂) := {K | IsCompact K}\n  have h_image₁ : MapsTo (φ₁ '' ·) 𝔗₁ 𝔖 := fun K hK ↦ hK.image φ₁.continuous\n  have h_image₂ : MapsTo (φ₂ '' ·) 𝔗₂ 𝔖 := fun K hK ↦ hK.image φ₂.continuous\n  have h_preimage₁ : MapsTo (φ₁ ⁻¹' ·) 𝔖 𝔗₁ := fun K ↦ h_proper₁.isCompact_preimage\n  have h_preimage₂ : MapsTo (φ₂ ⁻¹' ·) 𝔖 𝔗₂ := fun K ↦ h_proper₂.isCompact_preimage\n  have h_cover' : ∀ S ∈ 𝔖, S ⊆ range φ₁ ∪ range φ₂ := fun S _ ↦ h_cover ▸ subset_univ _\n  -- ... and we just pull it back.\n  simp_rw +zetaDelta [compactConvergenceUniformSpace, replaceTopology_eq,\n    UniformOnFun.uniformSpace_eq_inf_precomp_of_cover _ _ _ _ _\n      h_image₁ h_image₂ h_preimage₁ h_preimage₂ h_cover',\n    UniformSpace.comap_inf, ← UniformSpace.comap_comap]\n  rfl\n\n"}
{"name":"ContinuousMap.uniformSpace_eq_iInf_precomp_of_cover","module":"Mathlib.Topology.UniformSpace.CompactConvergence","initialProofState":"α : Type u₁\nβ : Type u₂\ninst✝² : TopologicalSpace α\ninst✝¹ : UniformSpace β\nι : Type u₃\nδ : ι → Type u_1\ninst✝ : (i : ι) → TopologicalSpace (δ i)\nφ : (i : ι) → ContinuousMap (δ i) α\nh_proper : ∀ (i : ι), IsProperMap ⇑(φ i)\nh_lf : LocallyFinite fun i => Set.range ⇑(φ i)\nh_cover : Eq (Set.iUnion fun i => Set.range ⇑(φ i)) Set.univ\n⊢ Eq (inferInstanceAs (UniformSpace (ContinuousMap α β))) (iInf fun i => UniformSpace.comap (fun x => x.comp (φ i)) inferInstance)","decl":"theorem uniformSpace_eq_iInf_precomp_of_cover {δ : ι → Type*} [∀ i, TopologicalSpace (δ i)]\n    (φ : Π i, C(δ i, α)) (h_proper : ∀ i, IsProperMap (φ i))\n    (h_lf : LocallyFinite fun i ↦ range (φ i)) (h_cover : ⋃ i, range (φ i) = univ) :\n    (inferInstanceAs <| UniformSpace C(α, β)) = ⨅ i, .comap (comp · (φ i)) inferInstance := by\n  -- We check the analogous result for `UniformOnFun` using\n  -- `UniformOnFun.uniformSpace_eq_iInf_precomp_of_cover`...\n  set 𝔖 : Set (Set α) := {K | IsCompact K}\n  set 𝔗 : Π i, Set (Set (δ i)) := fun i ↦ {K | IsCompact K}\n  have h_image : ∀ i, MapsTo (φ i '' ·) (𝔗 i) 𝔖 := fun i K hK ↦ hK.image (φ i).continuous\n  have h_preimage : ∀ i, MapsTo (φ i ⁻¹' ·) 𝔖 (𝔗 i) := fun i K ↦ (h_proper i).isCompact_preimage\n  have h_cover' : ∀ S ∈ 𝔖, ∃ I : Set ι, I.Finite ∧ S ⊆ ⋃ i ∈ I, range (φ i) := fun S hS ↦ by\n    refine ⟨{i | (range (φ i) ∩ S).Nonempty}, h_lf.finite_nonempty_inter_compact hS,\n      inter_eq_right.mp ?_⟩\n    simp_rw [iUnion₂_inter, mem_setOf, iUnion_nonempty_self, ← iUnion_inter, h_cover, univ_inter]\n  -- ... and we just pull it back.\n  simp_rw +zetaDelta [compactConvergenceUniformSpace, replaceTopology_eq,\n    UniformOnFun.uniformSpace_eq_iInf_precomp_of_cover _ _ _ h_image h_preimage h_cover',\n    UniformSpace.comap_iInf, ← UniformSpace.comap_comap]\n  rfl\n\n"}
{"name":"ContinuousMap.completeSpace_of_restrictGenTopology","module":"Mathlib.Topology.UniformSpace.CompactConvergence","initialProofState":"α : Type u₁\nβ : Type u₂\ninst✝² : TopologicalSpace α\ninst✝¹ : UniformSpace β\ninst✝ : CompleteSpace β\nh : Topology.RestrictGenTopology (setOf fun K => IsCompact K)\n⊢ CompleteSpace (ContinuousMap α β)","decl":"/-- If the topology on `α` is generated by its restrictions to compact sets, then the space of\ncontinuous maps `C(α, β)` is complete (wrt the compact convergence uniformity).\n\nSufficient conditions on `α` to satisfy this condition are (weak) local compactness (see\n`ContinuousMap.instCompleteSpaceOfWeaklyLocallyCompactSpace`) and sequential compactness (see\n`ContinuousMap.instCompleteSpaceOfSequentialSpace`). -/\nlemma completeSpace_of_restrictGenTopology (h : RestrictGenTopology {K : Set α | IsCompact K}) :\n    CompleteSpace C(α, β) := by\n  rw [completeSpace_iff_isComplete_range\n    isUniformEmbedding_toUniformOnFunIsCompact.isUniformInducing,\n    range_toUniformOnFunIsCompact, ← completeSpace_coe_iff_isComplete]\n  exact (UniformOnFun.isClosed_setOf_continuous h).completeSpace_coe\n\n"}
{"name":"ContinuousMap.instCompleteSpaceOfWeaklyLocallyCompactSpace","module":"Mathlib.Topology.UniformSpace.CompactConvergence","initialProofState":"α : Type u₁\nβ : Type u₂\ninst✝³ : TopologicalSpace α\ninst✝² : UniformSpace β\ninst✝¹ : CompleteSpace β\ninst✝ : WeaklyLocallyCompactSpace α\n⊢ CompleteSpace (ContinuousMap α β)","decl":"instance instCompleteSpaceOfWeaklyLocallyCompactSpace [WeaklyLocallyCompactSpace α] :\n    CompleteSpace C(α, β) :=\n  completeSpace_of_restrictGenTopology RestrictGenTopology.isCompact_of_weaklyLocallyCompact\n\n"}
{"name":"ContinuousMap.instCompleteSpaceOfSequentialSpace","module":"Mathlib.Topology.UniformSpace.CompactConvergence","initialProofState":"α : Type u₁\nβ : Type u₂\ninst✝³ : TopologicalSpace α\ninst✝² : UniformSpace β\ninst✝¹ : CompleteSpace β\ninst✝ : SequentialSpace α\n⊢ CompleteSpace (ContinuousMap α β)","decl":"instance instCompleteSpaceOfSequentialSpace [SequentialSpace α] :\n    CompleteSpace C(α, β) :=\n  completeSpace_of_restrictGenTopology RestrictGenTopology.isCompact_of_seq\n\n"}
