{"name":"CategoryTheory.Over.CreatesConnected.raiseCone_π_app","module":"Mathlib.CategoryTheory.Limits.Constructions.Over.Connected","initialProofState":"J : Type u'\ninst✝² : CategoryTheory.Category.{v', u'} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.IsConnected J\nB : C\nF : CategoryTheory.Functor J (CategoryTheory.Over B)\nc : CategoryTheory.Limits.Cone (F.comp (CategoryTheory.Over.forget B))\nj : J\n⊢ Eq ((CategoryTheory.Over.CreatesConnected.raiseCone c).π.app j) (CategoryTheory.Over.homMk (c.π.app j) ⋯)","decl":"/-- (Impl) Given a cone in the base category, raise it to a cone in the over category. Note this is\nwhere the connected assumption is used.\n-/\n@[simps]\ndef raiseCone [IsConnected J] {B : C} {F : J ⥤ Over B} (c : Cone (F ⋙ forget B)) :\n    Cone F where\n  pt := Over.mk (c.π.app (Classical.arbitrary J) ≫ (F.obj (Classical.arbitrary J)).hom)\n  π :=\n    { app := fun j =>\n        Over.homMk (c.π.app j) (nat_trans_from_is_connected (c.π ≫ natTransInOver F) j _)\n      naturality := by\n        intro X Y f\n        apply CommaMorphism.ext\n        · simpa using (c.w f).symm\n        · simp }\n\n"}
{"name":"CategoryTheory.Over.CreatesConnected.raiseCone_pt","module":"Mathlib.CategoryTheory.Limits.Constructions.Over.Connected","initialProofState":"J : Type u'\ninst✝² : CategoryTheory.Category.{v', u'} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.IsConnected J\nB : C\nF : CategoryTheory.Functor J (CategoryTheory.Over B)\nc : CategoryTheory.Limits.Cone (F.comp (CategoryTheory.Over.forget B))\n⊢ Eq (CategoryTheory.Over.CreatesConnected.raiseCone c).pt (CategoryTheory.Over.mk (CategoryTheory.CategoryStruct.comp (c.π.app (Classical.arbitrary J)) (F.obj (Classical.arbitrary J)).hom))","decl":"/-- (Impl) Given a cone in the base category, raise it to a cone in the over category. Note this is\nwhere the connected assumption is used.\n-/\n@[simps]\ndef raiseCone [IsConnected J] {B : C} {F : J ⥤ Over B} (c : Cone (F ⋙ forget B)) :\n    Cone F where\n  pt := Over.mk (c.π.app (Classical.arbitrary J) ≫ (F.obj (Classical.arbitrary J)).hom)\n  π :=\n    { app := fun j =>\n        Over.homMk (c.π.app j) (nat_trans_from_is_connected (c.π ≫ natTransInOver F) j _)\n      naturality := by\n        intro X Y f\n        apply CommaMorphism.ext\n        · simpa using (c.w f).symm\n        · simp }\n\n"}
{"name":"CategoryTheory.Over.CreatesConnected.raised_cone_lowers_to_original","module":"Mathlib.CategoryTheory.Limits.Constructions.Over.Connected","initialProofState":"J : Type u'\ninst✝² : CategoryTheory.Category.{v', u'} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.IsConnected J\nB : C\nF : CategoryTheory.Functor J (CategoryTheory.Over B)\nc : CategoryTheory.Limits.Cone (F.comp (CategoryTheory.Over.forget B))\n⊢ Eq ((CategoryTheory.Over.forget B).mapCone (CategoryTheory.Over.CreatesConnected.raiseCone c)) c","decl":"theorem raised_cone_lowers_to_original [IsConnected J] {B : C} {F : J ⥤ Over B}\n    (c : Cone (F ⋙ forget B)) :\n    (forget B).mapCone (raiseCone c) = c := by aesop_cat\n\n"}
{"name":"CategoryTheory.Over.has_connected_limits","module":"Mathlib.CategoryTheory.Limits.Constructions.Over.Connected","initialProofState":"J : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} J\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nB : C\ninst✝¹ : CategoryTheory.IsConnected J\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape J C\n⊢ CategoryTheory.Limits.HasLimitsOfShape J (CategoryTheory.Over B)","decl":"/-- The over category has any connected limit which the original category has. -/\ninstance has_connected_limits {B : C} [IsConnected J] [HasLimitsOfShape J C] :\n    HasLimitsOfShape J (Over B) where\n  has_limit F := hasLimit_of_created F (forget B)\n\n"}
