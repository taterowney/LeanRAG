{"name":"TopCat.Presheaf.SheafCondition.pairwiseToOpensLeCover_obj","module":"Mathlib.Topology.Sheaves.SheafCondition.PairwiseIntersections","initialProofState":"X : TopCat\nŒπ : Type w\nU : Œπ ‚Üí TopologicalSpace.Opens ‚ÜëX\na‚úù : CategoryTheory.Pairwise Œπ\n‚ä¢ Eq ((TopCat.Presheaf.SheafCondition.pairwiseToOpensLeCover U).obj a‚úù) (TopCat.Presheaf.SheafCondition.pairwiseToOpensLeCoverObj U a‚úù)","decl":"/-- The category of single and double intersections of the `U i` maps into the category\nof open sets below some `U i`.\n-/\n@[simps]\ndef pairwiseToOpensLeCover : Pairwise Œπ ‚•§ OpensLeCover U where\n  obj := pairwiseToOpensLeCoverObj U\n  map {_ _} i := pairwiseToOpensLeCoverMap U i\n\n"}
{"name":"TopCat.Presheaf.SheafCondition.pairwiseToOpensLeCover_map","module":"Mathlib.Topology.Sheaves.SheafCondition.PairwiseIntersections","initialProofState":"X : TopCat\nŒπ : Type w\nU : Œπ ‚Üí TopologicalSpace.Opens ‚ÜëX\nx‚úù¬π x‚úù : CategoryTheory.Pairwise Œπ\ni : Quiver.Hom x‚úù¬π x‚úù\n‚ä¢ Eq ((TopCat.Presheaf.SheafCondition.pairwiseToOpensLeCover U).map i) (TopCat.Presheaf.SheafCondition.pairwiseToOpensLeCoverMap U i)","decl":"/-- The category of single and double intersections of the `U i` maps into the category\nof open sets below some `U i`.\n-/\n@[simps]\ndef pairwiseToOpensLeCover : Pairwise Œπ ‚•§ OpensLeCover U where\n  obj := pairwiseToOpensLeCoverObj U\n  map {_ _} i := pairwiseToOpensLeCoverMap U i\n\n"}
{"name":"TopCat.Presheaf.SheafCondition.instNonemptyStructuredArrowPairwiseOpensLeCoverPairwiseToOpensLeCover","module":"Mathlib.Topology.Sheaves.SheafCondition.PairwiseIntersections","initialProofState":"X : TopCat\nŒπ : Type w\nU : Œπ ‚Üí TopologicalSpace.Opens ‚ÜëX\nV : TopCat.Presheaf.SheafCondition.OpensLeCover U\n‚ä¢ Nonempty (CategoryTheory.StructuredArrow V (TopCat.Presheaf.SheafCondition.pairwiseToOpensLeCover U))","decl":"instance (V : OpensLeCover U) : Nonempty (StructuredArrow V (pairwiseToOpensLeCover U)) :=\n  ‚ü®@StructuredArrow.mk _ _ _ _ _ (single V.index) _ V.homToIndex‚ü©\n\n-- This is a case bash: for each pair of types of objects in `Pairwise Œπ`,\n-- we have to explicitly construct a zigzag.\n"}
{"name":"TopCat.Presheaf.SheafCondition.instFinalPairwiseOpensLeCoverPairwiseToOpensLeCover","module":"Mathlib.Topology.Sheaves.SheafCondition.PairwiseIntersections","initialProofState":"X : TopCat\nŒπ : Type w\nU : Œπ ‚Üí TopologicalSpace.Opens ‚ÜëX\n‚ä¢ (TopCat.Presheaf.SheafCondition.pairwiseToOpensLeCover U).Final","decl":"/-- The diagram consisting of the `U i` and `U i ‚äì U j` is cofinal in the diagram\nof all opens contained in some `U i`.\n-/\ninstance : Functor.Final (pairwiseToOpensLeCover U) :=\n  ‚ü®fun V =>\n    isConnected_of_zigzag fun A B => by\n      rcases A with ‚ü®‚ü®‚ü®‚ü©‚ü©, ‚ü®i‚ü© | ‚ü®i, j‚ü©, a‚ü© <;> rcases B with ‚ü®‚ü®‚ü®‚ü©‚ü©, ‚ü®i'‚ü© | ‚ü®i', j'‚ü©, b‚ü©\n      ¬∑ refine\n          ‚ü®[{   left := ‚ü®‚ü®‚ü©‚ü©\n                right := pair i i'\n                hom := (le_inf a.le b.le).hom }, _], ?_, rfl‚ü©\n        exact\n          List.Chain.cons\n            (Or.inr\n              ‚ü®{  left := ùüô _\n                  right := left i i' }‚ü©)\n            (List.Chain.cons\n              (Or.inl\n                ‚ü®{  left := ùüô _\n                    right := right i i' }‚ü©)\n              List.Chain.nil)\n      ¬∑ refine\n          ‚ü®[{   left := ‚ü®‚ü®‚ü©‚ü©\n                right := pair i' i\n                hom := (le_inf (b.le.trans inf_le_left) a.le).hom },\n              { left := ‚ü®‚ü®‚ü©‚ü©\n                right := single i'\n                hom := (b.le.trans inf_le_left).hom }, _], ?_, rfl‚ü©\n        exact\n          List.Chain.cons\n            (Or.inr\n              ‚ü®{  left := ùüô _\n                  right := right i' i }‚ü©)\n            (List.Chain.cons\n              (Or.inl\n                ‚ü®{  left := ùüô _\n                    right := left i' i }‚ü©)\n              (List.Chain.cons\n                (Or.inr\n                  ‚ü®{  left := ùüô _\n                      right := left i' j' }‚ü©)\n                List.Chain.nil))\n      ¬∑ refine\n          ‚ü®[{   left := ‚ü®‚ü®‚ü©‚ü©\n                right := single i\n                hom := (a.le.trans inf_le_left).hom },\n              { left := ‚ü®‚ü®‚ü©‚ü©\n                right := pair i i'\n                hom := (le_inf (a.le.trans inf_le_left) b.le).hom }, _], ?_, rfl‚ü©\n        exact\n          List.Chain.cons\n            (Or.inl\n              ‚ü®{  left := ùüô _\n                  right := left i j }‚ü©)\n            (List.Chain.cons\n              (Or.inr\n                ‚ü®{  left := ùüô _\n                    right := left i i' }‚ü©)\n              (List.Chain.cons\n                (Or.inl\n                  ‚ü®{  left := ùüô _\n                      right := right i i' }‚ü©)\n                List.Chain.nil))\n      ¬∑ refine\n          ‚ü®[{   left := ‚ü®‚ü®‚ü©‚ü©\n                right := single i\n                hom := (a.le.trans inf_le_left).hom },\n              { left := ‚ü®‚ü®‚ü©‚ü©\n                right := pair i i'\n                hom := (le_inf (a.le.trans inf_le_left) (b.le.trans inf_le_left)).hom },\n              { left := ‚ü®‚ü®‚ü©‚ü©\n                right := single i'\n                hom := (b.le.trans inf_le_left).hom }, _], ?_, rfl‚ü©\n        exact\n          List.Chain.cons\n            (Or.inl\n              ‚ü®{  left := ùüô _\n                  right := left i j }‚ü©)\n            (List.Chain.cons\n              (Or.inr\n                ‚ü®{  left := ùüô _\n                    right := left i i' }‚ü©)\n              (List.Chain.cons\n                (Or.inl\n                  ‚ü®{  left := ùüô _\n                      right := right i i' }‚ü©)\n                (List.Chain.cons\n                  (Or.inr\n                    ‚ü®{  left := ùüô _\n                        right := left i' j' }‚ü©)\n                  List.Chain.nil)))‚ü©\n\n"}
{"name":"TopCat.Presheaf.isSheafOpensLeCover_iff_isSheafPairwiseIntersections","module":"Mathlib.Topology.Sheaves.SheafCondition.PairwiseIntersections","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : TopCat\nF : TopCat.Presheaf C X\n‚ä¢ Iff F.IsSheafOpensLeCover F.IsSheafPairwiseIntersections","decl":"/-- The sheaf condition\nin terms of a limit diagram over all `{ V : Opens X // ‚àÉ i, V ‚â§ U i }`\nis equivalent to the reformulation\nin terms of a limit diagram over `U i` and `U i ‚äì U j`.\n-/\ntheorem isSheafOpensLeCover_iff_isSheafPairwiseIntersections :\n    F.IsSheafOpensLeCover ‚Üî F.IsSheafPairwiseIntersections :=\n  forall‚ÇÇ_congr fun _ U =>\n    Equiv.nonempty_congr <|\n      calc\n        IsLimit (F.mapCone (opensLeCoverCocone U).op) ‚âÉ\n            IsLimit ((F.mapCone (opensLeCoverCocone U).op).whisker (pairwiseToOpensLeCover U).op) :=\n          (Functor.Initial.isLimitWhiskerEquiv (pairwiseToOpensLeCover U).op _).symm\n        _ ‚âÉ IsLimit (F.mapCone ((opensLeCoverCocone U).op.whisker (pairwiseToOpensLeCover U).op)) :=\n          (IsLimit.equivIsoLimit F.mapConeWhisker.symm)\n        _ ‚âÉ\n            IsLimit\n              ((Cones.postcomposeEquivalence _).functor.obj\n                (F.mapCone ((opensLeCoverCocone U).op.whisker (pairwiseToOpensLeCover U).op))) :=\n          (IsLimit.postcomposeHomEquiv _ _).symm\n        _ ‚âÉ\n            IsLimit\n              (F.mapCone\n                ((Cones.postcomposeEquivalence _).functor.obj\n                  ((opensLeCoverCocone U).op.whisker (pairwiseToOpensLeCover U).op))) :=\n          (IsLimit.equivIsoLimit (Functor.mapConePostcomposeEquivalenceFunctor _).symm)\n        _ ‚âÉ IsLimit (F.mapCone (Pairwise.cocone U).op) :=\n          IsLimit.equivIsoLimit ((Cones.functoriality _ _).mapIso (pairwiseCoconeIso U :).symm)\n\n"}
{"name":"TopCat.Presheaf.isSheaf_iff_isSheafPairwiseIntersections","module":"Mathlib.Topology.Sheaves.SheafCondition.PairwiseIntersections","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : TopCat\nF : TopCat.Presheaf C X\n‚ä¢ Iff F.IsSheaf F.IsSheafPairwiseIntersections","decl":"/-- The sheaf condition in terms of an equalizer diagram is equivalent\nto the reformulation in terms of a limit diagram over `U i` and `U i ‚äì U j`.\n-/\ntheorem isSheaf_iff_isSheafPairwiseIntersections : F.IsSheaf ‚Üî F.IsSheafPairwiseIntersections := by\n  rw [isSheaf_iff_isSheafOpensLeCover,\n    isSheafOpensLeCover_iff_isSheafPairwiseIntersections]\n\n"}
{"name":"TopCat.Presheaf.isSheaf_iff_isSheafPreservesLimitPairwiseIntersections","module":"Mathlib.Topology.Sheaves.SheafCondition.PairwiseIntersections","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : TopCat\nF : TopCat.Presheaf C X\n‚ä¢ Iff F.IsSheaf F.IsSheafPreservesLimitPairwiseIntersections","decl":"/-- The sheaf condition in terms of an equalizer diagram is equivalent\nto the reformulation in terms of the presheaf preserving the limit of the diagram\nconsisting of the `U i` and `U i ‚äì U j`.\n-/\ntheorem isSheaf_iff_isSheafPreservesLimitPairwiseIntersections :\n    F.IsSheaf ‚Üî F.IsSheafPreservesLimitPairwiseIntersections := by\n  rw [isSheaf_iff_isSheafPairwiseIntersections]\n  constructor\n  ¬∑ intro h Œπ U\n    exact ‚ü®preservesLimit_of_preserves_limit_cone (Pairwise.coconeIsColimit U).op (h U).some‚ü©\n  ¬∑ intro h Œπ U\n    haveI := (h U).some\n    exact ‚ü®isLimitOfPreserves _ (Pairwise.coconeIsColimit U).op‚ü©\n\n"}
{"name":"TopCat.Sheaf.interUnionPullbackCone_pt","module":"Mathlib.Topology.Sheaves.SheafCondition.PairwiseIntersections","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : TopCat\nF : TopCat.Sheaf C X\nU V : TopologicalSpace.Opens ‚ÜëX\n‚ä¢ Eq (F.interUnionPullbackCone U V).pt (F.val.obj { unop := Max.max U V })","decl":"@[simp]\ntheorem interUnionPullbackCone_pt : (interUnionPullbackCone F U V).pt = F.1.obj (op <| U ‚äî V) :=\n  rfl\n\n"}
{"name":"TopCat.Sheaf.interUnionPullbackCone_fst","module":"Mathlib.Topology.Sheaves.SheafCondition.PairwiseIntersections","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : TopCat\nF : TopCat.Sheaf C X\nU V : TopologicalSpace.Opens ‚ÜëX\n‚ä¢ Eq (F.interUnionPullbackCone U V).fst (F.val.map (CategoryTheory.homOfLE ‚ãØ).op)","decl":"@[simp]\ntheorem interUnionPullbackCone_fst :\n    (interUnionPullbackCone F U V).fst = F.1.map (homOfLE le_sup_left).op :=\n  rfl\n\n"}
{"name":"TopCat.Sheaf.interUnionPullbackCone_snd","module":"Mathlib.Topology.Sheaves.SheafCondition.PairwiseIntersections","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : TopCat\nF : TopCat.Sheaf C X\nU V : TopologicalSpace.Opens ‚ÜëX\n‚ä¢ Eq (F.interUnionPullbackCone U V).snd (F.val.map (CategoryTheory.homOfLE ‚ãØ).op)","decl":"@[simp]\ntheorem interUnionPullbackCone_snd :\n    (interUnionPullbackCone F U V).snd = F.1.map (homOfLE le_sup_right).op :=\n  rfl\n\n"}
{"name":"TopCat.Sheaf.interUnionPullbackConeLift_left","module":"Mathlib.Topology.Sheaves.SheafCondition.PairwiseIntersections","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : TopCat\nF : TopCat.Sheaf C X\nU V : TopologicalSpace.Opens ‚ÜëX\ns : CategoryTheory.Limits.PullbackCone (F.val.map (CategoryTheory.homOfLE ‚ãØ).op) (F.val.map (CategoryTheory.homOfLE ‚ãØ).op)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.interUnionPullbackConeLift U V s) (F.val.map (CategoryTheory.homOfLE ‚ãØ).op)) s.fst","decl":"theorem interUnionPullbackConeLift_left :\n    interUnionPullbackConeLift F U V s ‚â´ F.1.map (homOfLE le_sup_left).op = s.fst := by\n  erw [Category.assoc]\n  simp_rw [‚Üê F.1.map_comp]\n  exact\n    (F.presheaf.isSheaf_iff_isSheafPairwiseIntersections.mp F.2 _).some.fac _ <|\n      op <| Pairwise.single <| ULift.up WalkingPair.left\n\n"}
{"name":"TopCat.Sheaf.interUnionPullbackConeLift_right","module":"Mathlib.Topology.Sheaves.SheafCondition.PairwiseIntersections","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : TopCat\nF : TopCat.Sheaf C X\nU V : TopologicalSpace.Opens ‚ÜëX\ns : CategoryTheory.Limits.PullbackCone (F.val.map (CategoryTheory.homOfLE ‚ãØ).op) (F.val.map (CategoryTheory.homOfLE ‚ãØ).op)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.interUnionPullbackConeLift U V s) (F.val.map (CategoryTheory.homOfLE ‚ãØ).op)) s.snd","decl":"theorem interUnionPullbackConeLift_right :\n    interUnionPullbackConeLift F U V s ‚â´ F.1.map (homOfLE le_sup_right).op = s.snd := by\n  erw [Category.assoc]\n  simp_rw [‚Üê F.1.map_comp]\n  exact\n    (F.presheaf.isSheaf_iff_isSheafPairwiseIntersections.mp F.2 _).some.fac _ <|\n      op <| Pairwise.single <| ULift.up WalkingPair.right\n\n"}
