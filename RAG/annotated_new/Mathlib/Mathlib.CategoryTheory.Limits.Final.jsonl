{"name":"CategoryTheory.Functor.Final.out","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nself : F.Final\nd : D\n⊢ CategoryTheory.IsConnected (CategoryTheory.StructuredArrow d F)","decl":"/--\nA functor `F : C ⥤ D` is final if for every `d : D`, the comma category of morphisms `d ⟶ F.obj c`\nis connected. -/\n@[stacks 04E6]\nclass Final (F : C ⥤ D) : Prop where\n  out (d : D) : IsConnected (StructuredArrow d F)\n\n"}
{"name":"CategoryTheory.Functor.Initial.out","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nself : F.Initial\nd : D\n⊢ CategoryTheory.IsConnected (CategoryTheory.CostructuredArrow F d)","decl":"/-- A functor `F : C ⥤ D` is initial if for every `d : D`, the comma category of morphisms\n`F.obj c ⟶ d` is connected.\n-/\nclass Initial (F : C ⥤ D) : Prop where\n  out (d : D) : IsConnected (CostructuredArrow F d)\n\n"}
{"name":"CategoryTheory.Functor.final_op_of_initial","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : F.Initial\n⊢ F.op.Final","decl":"instance final_op_of_initial (F : C ⥤ D) [Initial F] : Final F.op where\n  out d := isConnected_of_equivalent (costructuredArrowOpEquivalence F (unop d))\n\n"}
{"name":"CategoryTheory.Functor.initial_op_of_final","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : F.Final\n⊢ F.op.Initial","decl":"instance initial_op_of_final (F : C ⥤ D) [Final F] : Initial F.op where\n  out d := isConnected_of_equivalent (structuredArrowOpEquivalence F (unop d))\n\n"}
{"name":"CategoryTheory.Functor.final_of_initial_op","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : F.op.Initial\n⊢ F.Final","decl":"theorem final_of_initial_op (F : C ⥤ D) [Initial F.op] : Final F :=\n  {\n    out := fun d =>\n      @isConnected_of_isConnected_op _ _\n        (isConnected_of_equivalent (structuredArrowOpEquivalence F d).symm) }\n\n"}
{"name":"CategoryTheory.Functor.initial_of_final_op","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : F.op.Final\n⊢ F.Initial","decl":"theorem initial_of_final_op (F : C ⥤ D) [Final F.op] : Initial F :=\n  {\n    out := fun d =>\n      @isConnected_of_isConnected_op _ _\n        (isConnected_of_equivalent (costructuredArrowOpEquivalence F d).symm) }\n\n"}
{"name":"CategoryTheory.Functor.final_of_adjunction","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction L R\n⊢ R.Final","decl":"/-- If a functor `R : D ⥤ C` is a right adjoint, it is final. -/\ntheorem final_of_adjunction {L : C ⥤ D} {R : D ⥤ C} (adj : L ⊣ R) : Final R :=\n  { out := fun c =>\n      let u : StructuredArrow c R := StructuredArrow.mk (adj.unit.app c)\n      @zigzag_isConnected _ _ ⟨u⟩ fun f g =>\n        Relation.ReflTransGen.trans\n          (Relation.ReflTransGen.single\n            (show Zag f u from\n              Or.inr ⟨StructuredArrow.homMk ((adj.homEquiv c f.right).symm f.hom) (by simp [u])⟩))\n          (Relation.ReflTransGen.single\n            (show Zag u g from\n              Or.inl ⟨StructuredArrow.homMk ((adj.homEquiv c g.right).symm g.hom) (by simp [u])⟩)) }\n\n"}
{"name":"CategoryTheory.Functor.initial_of_adjunction","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction L R\n⊢ L.Initial","decl":"/-- If a functor `L : C ⥤ D` is a left adjoint, it is initial. -/\ntheorem initial_of_adjunction {L : C ⥤ D} {R : D ⥤ C} (adj : L ⊣ R) : Initial L :=\n  { out := fun d =>\n      let u : CostructuredArrow L d := CostructuredArrow.mk (adj.counit.app d)\n      @zigzag_isConnected _ _ ⟨u⟩ fun f g =>\n        Relation.ReflTransGen.trans\n          (Relation.ReflTransGen.single\n            (show Zag f u from\n              Or.inl ⟨CostructuredArrow.homMk (adj.homEquiv f.left d f.hom) (by simp [u])⟩))\n          (Relation.ReflTransGen.single\n            (show Zag u g from\n              Or.inr ⟨CostructuredArrow.homMk (adj.homEquiv g.left d g.hom) (by simp [u])⟩)) }\n\n"}
{"name":"CategoryTheory.Functor.final_of_isRightAdjoint","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : F.IsRightAdjoint\n⊢ F.Final","decl":"instance (priority := 100) final_of_isRightAdjoint (F : C ⥤ D) [IsRightAdjoint F] : Final F :=\n  final_of_adjunction (Adjunction.ofIsRightAdjoint F)\n\n"}
{"name":"CategoryTheory.Functor.initial_of_isLeftAdjoint","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : F.IsLeftAdjoint\n⊢ F.Initial","decl":"instance (priority := 100) initial_of_isLeftAdjoint (F : C ⥤ D) [IsLeftAdjoint F] : Initial F :=\n  initial_of_adjunction (Adjunction.ofIsLeftAdjoint F)\n\n"}
{"name":"CategoryTheory.Functor.final_of_natIso","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF F' : CategoryTheory.Functor C D\ninst✝ : F.Final\ni : CategoryTheory.Iso F F'\n⊢ F'.Final","decl":"theorem final_of_natIso {F F' : C ⥤ D} [Final F] (i : F ≅ F') : Final F' where\n  out _ := isConnected_of_equivalent (StructuredArrow.mapNatIso i)\n\n"}
{"name":"CategoryTheory.Functor.final_natIso_iff","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF F' : CategoryTheory.Functor C D\ni : CategoryTheory.Iso F F'\n⊢ Iff F.Final F'.Final","decl":"theorem final_natIso_iff {F F' : C ⥤ D} (i : F ≅ F') : Final F ↔ Final F' :=\n  ⟨fun _ => final_of_natIso i, fun _ => final_of_natIso i.symm⟩\n\n"}
{"name":"CategoryTheory.Functor.initial_of_natIso","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF F' : CategoryTheory.Functor C D\ninst✝ : F.Initial\ni : CategoryTheory.Iso F F'\n⊢ F'.Initial","decl":"theorem initial_of_natIso {F F' : C ⥤ D} [Initial F] (i : F ≅ F') : Initial F' where\n  out _ := isConnected_of_equivalent (CostructuredArrow.mapNatIso i)\n\n"}
{"name":"CategoryTheory.Functor.initial_natIso_iff","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF F' : CategoryTheory.Functor C D\ni : CategoryTheory.Iso F F'\n⊢ Iff F.Initial F'.Initial","decl":"theorem initial_natIso_iff {F F' : C ⥤ D} (i : F ≅ F') : Initial F ↔ Initial F' :=\n  ⟨fun _ => initial_of_natIso i, fun _ => initial_of_natIso i.symm⟩\n\n"}
{"name":"CategoryTheory.Functor.Final.instNonemptyStructuredArrow","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : F.Final\nd : D\n⊢ Nonempty (CategoryTheory.StructuredArrow d F)","decl":"instance (d : D) : Nonempty (StructuredArrow d F) :=\n  IsConnected.is_nonempty\n\n"}
{"name":"CategoryTheory.Functor.Final.extendCocone_map_hom","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.Final\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nG : CategoryTheory.Functor D E\nX✝ Y✝ : CategoryTheory.Limits.Cocone (F.comp G)\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.Functor.Final.extendCocone.map f).hom f.hom","decl":"/-- Given a cocone over `F ⋙ G`, we can construct a `Cocone G` with the same cocone point.\n-/\n@[simps]\ndef extendCocone : Cocone (F ⋙ G) ⥤ Cocone G where\n  obj c :=\n    { pt := c.pt\n      ι :=\n        { app := fun X => G.map (homToLift F X) ≫ c.ι.app (lift F X)\n          naturality := fun X Y f => by\n            dsimp; simp only [Category.comp_id]\n            -- This would be true if we'd chosen `lift F X` to be `lift F Y`\n            -- and `homToLift F X` to be `f ≫ homToLift F Y`.\n            apply\n              induction F fun Z k =>\n                G.map f ≫ G.map (homToLift F Y) ≫ c.ι.app (lift F Y) = G.map k ≫ c.ι.app Z\n            · intro Z₁ Z₂ k₁ k₂ g a z\n              rw [← a, Functor.map_comp, Category.assoc, ← Functor.comp_map, c.w, z]\n            · intro Z₁ Z₂ k₁ k₂ g a z\n              rw [← a, Functor.map_comp, Category.assoc, ← Functor.comp_map, c.w] at z\n              rw [z]\n            · rw [← Functor.map_comp_assoc] } }\n  map f := { hom := f.hom }\n\n"}
{"name":"CategoryTheory.Functor.Final.extendCocone_obj_ι_app","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.Final\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nG : CategoryTheory.Functor D E\nc : CategoryTheory.Limits.Cocone (F.comp G)\nX : D\n⊢ Eq ((CategoryTheory.Functor.Final.extendCocone.obj c).ι.app X) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Functor.Final.homToLift F X)) (c.ι.app (CategoryTheory.Functor.Final.lift F X)))","decl":"/-- Given a cocone over `F ⋙ G`, we can construct a `Cocone G` with the same cocone point.\n-/\n@[simps]\ndef extendCocone : Cocone (F ⋙ G) ⥤ Cocone G where\n  obj c :=\n    { pt := c.pt\n      ι :=\n        { app := fun X => G.map (homToLift F X) ≫ c.ι.app (lift F X)\n          naturality := fun X Y f => by\n            dsimp; simp only [Category.comp_id]\n            -- This would be true if we'd chosen `lift F X` to be `lift F Y`\n            -- and `homToLift F X` to be `f ≫ homToLift F Y`.\n            apply\n              induction F fun Z k =>\n                G.map f ≫ G.map (homToLift F Y) ≫ c.ι.app (lift F Y) = G.map k ≫ c.ι.app Z\n            · intro Z₁ Z₂ k₁ k₂ g a z\n              rw [← a, Functor.map_comp, Category.assoc, ← Functor.comp_map, c.w, z]\n            · intro Z₁ Z₂ k₁ k₂ g a z\n              rw [← a, Functor.map_comp, Category.assoc, ← Functor.comp_map, c.w] at z\n              rw [z]\n            · rw [← Functor.map_comp_assoc] } }\n  map f := { hom := f.hom }\n\n"}
{"name":"CategoryTheory.Functor.Final.extendCocone_obj_pt","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.Final\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nG : CategoryTheory.Functor D E\nc : CategoryTheory.Limits.Cocone (F.comp G)\n⊢ Eq (CategoryTheory.Functor.Final.extendCocone.obj c).pt c.pt","decl":"/-- Given a cocone over `F ⋙ G`, we can construct a `Cocone G` with the same cocone point.\n-/\n@[simps]\ndef extendCocone : Cocone (F ⋙ G) ⥤ Cocone G where\n  obj c :=\n    { pt := c.pt\n      ι :=\n        { app := fun X => G.map (homToLift F X) ≫ c.ι.app (lift F X)\n          naturality := fun X Y f => by\n            dsimp; simp only [Category.comp_id]\n            -- This would be true if we'd chosen `lift F X` to be `lift F Y`\n            -- and `homToLift F X` to be `f ≫ homToLift F Y`.\n            apply\n              induction F fun Z k =>\n                G.map f ≫ G.map (homToLift F Y) ≫ c.ι.app (lift F Y) = G.map k ≫ c.ι.app Z\n            · intro Z₁ Z₂ k₁ k₂ g a z\n              rw [← a, Functor.map_comp, Category.assoc, ← Functor.comp_map, c.w, z]\n            · intro Z₁ Z₂ k₁ k₂ g a z\n              rw [← a, Functor.map_comp, Category.assoc, ← Functor.comp_map, c.w] at z\n              rw [z]\n            · rw [← Functor.map_comp_assoc] } }\n  map f := { hom := f.hom }\n\n"}
{"name":"CategoryTheory.Functor.Final.extendCocone_obj_ι_app'","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.Final\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nG : CategoryTheory.Functor D E\nc : CategoryTheory.Limits.Cocone (F.comp G)\nX : D\nY : C\nf : Quiver.Hom X (F.obj Y)\n⊢ Eq ((CategoryTheory.Functor.Final.extendCocone.obj c).ι.app X) (CategoryTheory.CategoryStruct.comp (G.map f) (c.ι.app Y))","decl":"/-- Alternative equational lemma for `(extendCocone c).ι.app` in case a lift of the object\nis given explicitly. -/\nlemma extendCocone_obj_ι_app' (c : Cocone (F ⋙ G)) {X : D} {Y : C} (f : X ⟶ F.obj Y) :\n    (extendCocone.obj c).ι.app X = G.map f ≫ c.ι.app Y := by\n  apply induction (k₀ := f) (z := rfl) F fun Z g =>\n    G.map g ≫ c.ι.app Z = G.map f ≫ c.ι.app Y\n  · intro _ _ _ _ _ h₁ h₂\n    simp [← h₁, ← Functor.comp_map, c.ι.naturality, h₂]\n  · intro _ _ _ _ _ h₁ h₂\n    simp [← h₂, ← h₁, ← Functor.comp_map, c.ι.naturality]\n\n"}
{"name":"CategoryTheory.Functor.Final.colimit_cocone_comp_aux","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.Final\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nG : CategoryTheory.Functor D E\ns : CategoryTheory.Limits.Cocone (F.comp G)\nj : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Functor.Final.homToLift F (F.obj j))) (s.ι.app (CategoryTheory.Functor.Final.lift F (F.obj j)))) (s.ι.app j)","decl":"@[simp]\ntheorem colimit_cocone_comp_aux (s : Cocone (F ⋙ G)) (j : C) :\n    G.map (homToLift F (F.obj j)) ≫ s.ι.app (lift F (F.obj j)) = s.ι.app j := by\n  -- This point is that this would be true if we took `lift (F.obj j)` to just be `j`\n  -- and `homToLift (F.obj j)` to be `𝟙 (F.obj j)`.\n  apply induction F fun X k => G.map k ≫ s.ι.app X = (s.ι.app j :)\n  · intro j₁ j₂ k₁ k₂ f w h\n    rw [← w]\n    rw [← s.w f] at h\n    simpa using h\n  · intro j₁ j₂ k₁ k₂ f w h\n    rw [← w] at h\n    rw [← s.w f]\n    simpa using h\n  · exact s.w (𝟙 _)\n\n"}
{"name":"CategoryTheory.Functor.Final.coconesEquiv_inverse","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.Final\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nG : CategoryTheory.Functor D E\n⊢ Eq (CategoryTheory.Functor.Final.coconesEquiv F G).inverse (CategoryTheory.Limits.Cocones.whiskering F)","decl":"/-- If `F` is final,\nthe category of cocones on `F ⋙ G` is equivalent to the category of cocones on `G`,\nfor any `G : D ⥤ E`.\n-/\n@[simps]\ndef coconesEquiv : Cocone (F ⋙ G) ≌ Cocone G where\n  functor := extendCocone\n  inverse := Cocones.whiskering F\n  unitIso := NatIso.ofComponents fun c => Cocones.ext (Iso.refl _)\n  counitIso := NatIso.ofComponents fun c => Cocones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Functor.Final.coconesEquiv_functor","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.Final\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nG : CategoryTheory.Functor D E\n⊢ Eq (CategoryTheory.Functor.Final.coconesEquiv F G).functor CategoryTheory.Functor.Final.extendCocone","decl":"/-- If `F` is final,\nthe category of cocones on `F ⋙ G` is equivalent to the category of cocones on `G`,\nfor any `G : D ⥤ E`.\n-/\n@[simps]\ndef coconesEquiv : Cocone (F ⋙ G) ≌ Cocone G where\n  functor := extendCocone\n  inverse := Cocones.whiskering F\n  unitIso := NatIso.ofComponents fun c => Cocones.ext (Iso.refl _)\n  counitIso := NatIso.ofComponents fun c => Cocones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Functor.Final.coconesEquiv_counitIso","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.Final\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nG : CategoryTheory.Functor D E\n⊢ Eq (CategoryTheory.Functor.Final.coconesEquiv F G).counitIso (CategoryTheory.NatIso.ofComponents (fun c => CategoryTheory.Limits.Cocones.ext (CategoryTheory.Iso.refl (((CategoryTheory.Limits.Cocones.whiskering F).comp CategoryTheory.Functor.Final.extendCocone).obj c).pt) ⋯) ⋯)","decl":"/-- If `F` is final,\nthe category of cocones on `F ⋙ G` is equivalent to the category of cocones on `G`,\nfor any `G : D ⥤ E`.\n-/\n@[simps]\ndef coconesEquiv : Cocone (F ⋙ G) ≌ Cocone G where\n  functor := extendCocone\n  inverse := Cocones.whiskering F\n  unitIso := NatIso.ofComponents fun c => Cocones.ext (Iso.refl _)\n  counitIso := NatIso.ofComponents fun c => Cocones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Functor.Final.coconesEquiv_unitIso","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.Final\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nG : CategoryTheory.Functor D E\n⊢ Eq (CategoryTheory.Functor.Final.coconesEquiv F G).unitIso (CategoryTheory.NatIso.ofComponents (fun c => CategoryTheory.Limits.Cocones.ext (CategoryTheory.Iso.refl ((CategoryTheory.Functor.id (CategoryTheory.Limits.Cocone (F.comp G))).obj c).pt) ⋯) ⋯)","decl":"/-- If `F` is final,\nthe category of cocones on `F ⋙ G` is equivalent to the category of cocones on `G`,\nfor any `G : D ⥤ E`.\n-/\n@[simps]\ndef coconesEquiv : Cocone (F ⋙ G) ≌ Cocone G where\n  functor := extendCocone\n  inverse := Cocones.whiskering F\n  unitIso := NatIso.ofComponents fun c => Cocones.ext (Iso.refl _)\n  counitIso := NatIso.ofComponents fun c => Cocones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Functor.Final.colimitCoconeComp_isColimit","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.Final\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nG : CategoryTheory.Functor D E\nt : CategoryTheory.Limits.ColimitCocone G\n⊢ Eq (CategoryTheory.Functor.Final.colimitCoconeComp F t).isColimit ((CategoryTheory.Functor.Final.isColimitWhiskerEquiv F t.cocone).symm t.isColimit)","decl":"/-- Given a colimit cocone over `G : D ⥤ E` we can construct a colimit cocone over `F ⋙ G`. -/\n@[simps]\ndef colimitCoconeComp (t : ColimitCocone G) : ColimitCocone (F ⋙ G) where\n  cocone := _\n  isColimit := (isColimitWhiskerEquiv F _).symm t.isColimit\n\n"}
{"name":"CategoryTheory.Functor.Final.colimitCoconeComp_cocone","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.Final\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nG : CategoryTheory.Functor D E\nt : CategoryTheory.Limits.ColimitCocone G\n⊢ Eq (CategoryTheory.Functor.Final.colimitCoconeComp F t).cocone (CategoryTheory.Limits.Cocone.whisker F t.cocone)","decl":"/-- Given a colimit cocone over `G : D ⥤ E` we can construct a colimit cocone over `F ⋙ G`. -/\n@[simps]\ndef colimitCoconeComp (t : ColimitCocone G) : ColimitCocone (F ⋙ G) where\n  cocone := _\n  isColimit := (isColimitWhiskerEquiv F _).symm t.isColimit\n\n"}
{"name":"CategoryTheory.Functor.Final.comp_hasColimit","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝² : F.Final\nE : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} E\nG : CategoryTheory.Functor D E\ninst✝ : CategoryTheory.Limits.HasColimit G\n⊢ CategoryTheory.Limits.HasColimit (F.comp G)","decl":"instance (priority := 100) comp_hasColimit [HasColimit G] : HasColimit (F ⋙ G) :=\n  HasColimit.mk (colimitCoconeComp F (getColimitCocone G))\n\n"}
{"name":"CategoryTheory.Functor.Final.comp_preservesColimit","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nE : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} E\nG : CategoryTheory.Functor D E\nB : Type u₄\ninst✝¹ : CategoryTheory.Category.{v₄, u₄} B\nH : CategoryTheory.Functor E B\ninst✝ : CategoryTheory.Limits.PreservesColimit G H\n⊢ CategoryTheory.Limits.PreservesColimit (F.comp G) H","decl":"instance (priority := 100) comp_preservesColimit {B : Type u₄} [Category.{v₄} B] {H : E ⥤ B}\n    [PreservesColimit G H] : PreservesColimit (F ⋙ G) H where\n  preserves {c} hc := by\n    refine ⟨isColimitExtendCoconeEquiv (G := G ⋙ H) F (H.mapCocone c) ?_⟩\n    let hc' := isColimitOfPreserves H ((isColimitExtendCoconeEquiv F c).symm hc)\n    exact IsColimit.ofIsoColimit hc' (Cocones.ext (Iso.refl _) (by simp))\n\n"}
{"name":"CategoryTheory.Functor.Final.comp_reflectsColimit","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nE : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} E\nG : CategoryTheory.Functor D E\nB : Type u₄\ninst✝¹ : CategoryTheory.Category.{v₄, u₄} B\nH : CategoryTheory.Functor E B\ninst✝ : CategoryTheory.Limits.ReflectsColimit G H\n⊢ CategoryTheory.Limits.ReflectsColimit (F.comp G) H","decl":"instance (priority := 100) comp_reflectsColimit {B : Type u₄} [Category.{v₄} B] {H : E ⥤ B}\n    [ReflectsColimit G H] : ReflectsColimit (F ⋙ G) H where\n  reflects {c} hc := by\n    refine ⟨isColimitExtendCoconeEquiv F _ (isColimitOfReflects H ?_)⟩\n    let hc' := (isColimitExtendCoconeEquiv (G := G ⋙ H) F _).symm hc\n    exact IsColimit.ofIsoColimit hc' (Cocones.ext (Iso.refl _) (by simp))\n\n"}
{"name":"CategoryTheory.Functor.Final.colimit_pre_isIso","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝² : F.Final\nE : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} E\nG : CategoryTheory.Functor D E\ninst✝ : CategoryTheory.Limits.HasColimit G\n⊢ CategoryTheory.IsIso (CategoryTheory.Limits.colimit.pre G F)","decl":"instance colimit_pre_isIso [HasColimit G] : IsIso (colimit.pre G F) := by\n  rw [colimit.pre_eq (colimitCoconeComp F (getColimitCocone G)) (getColimitCocone G)]\n  erw [IsColimit.desc_self]\n  dsimp\n  infer_instance\n\n"}
{"name":"CategoryTheory.Functor.Final.colimitIso_hom","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝² : F.Final\nE : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} E\nG : CategoryTheory.Functor D E\ninst✝ : CategoryTheory.Limits.HasColimit G\n⊢ Eq (CategoryTheory.Functor.Final.colimitIso F G).hom (CategoryTheory.Limits.colimit.pre G F)","decl":"/-- When `F : C ⥤ D` is final, and `G : D ⥤ E` has a colimit, then `F ⋙ G` has a colimit also and\n`colimit (F ⋙ G) ≅ colimit G`. -/\n@[simps! (config := .lemmasOnly), stacks 04E7]\ndef colimitIso [HasColimit G] : colimit (F ⋙ G) ≅ colimit G :=\n  asIso (colimit.pre G F)\n\n"}
{"name":"CategoryTheory.Functor.Final.colimitIso_inv","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝² : F.Final\nE : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} E\nG : CategoryTheory.Functor D E\ninst✝ : CategoryTheory.Limits.HasColimit G\n⊢ Eq (CategoryTheory.Functor.Final.colimitIso F G).inv (CategoryTheory.inv (CategoryTheory.Limits.colimit.pre G F))","decl":"/-- When `F : C ⥤ D` is final, and `G : D ⥤ E` has a colimit, then `F ⋙ G` has a colimit also and\n`colimit (F ⋙ G) ≅ colimit G`. -/\n@[simps! (config := .lemmasOnly), stacks 04E7]\ndef colimitIso [HasColimit G] : colimit (F ⋙ G) ≅ colimit G :=\n  asIso (colimit.pre G F)\n\n"}
{"name":"CategoryTheory.Functor.Final.ι_colimitIso_hom","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝² : F.Final\nE : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} E\nG : CategoryTheory.Functor D E\ninst✝ : CategoryTheory.Limits.HasColimit G\nX : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι (F.comp G) X) (CategoryTheory.Functor.Final.colimitIso F G).hom) (CategoryTheory.Limits.colimit.ι G (F.obj X))","decl":"@[reassoc (attr := simp)]\ntheorem ι_colimitIso_hom [HasColimit G] (X : C) :\n    colimit.ι (F ⋙ G) X ≫ (colimitIso F G).hom = colimit.ι G (F.obj X) := by\n  simp [colimitIso]\n\n"}
{"name":"CategoryTheory.Functor.Final.ι_colimitIso_hom_assoc","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝² : F.Final\nE : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} E\nG : CategoryTheory.Functor D E\ninst✝ : CategoryTheory.Limits.HasColimit G\nX : C\nZ : E\nh : Quiver.Hom (CategoryTheory.Limits.colimit G) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι (F.comp G) X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.Final.colimitIso F G).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι G (F.obj X)) h)","decl":"@[reassoc (attr := simp)]\ntheorem ι_colimitIso_hom [HasColimit G] (X : C) :\n    colimit.ι (F ⋙ G) X ≫ (colimitIso F G).hom = colimit.ι G (F.obj X) := by\n  simp [colimitIso]\n\n"}
{"name":"CategoryTheory.Functor.Final.ι_colimitIso_inv","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝² : F.Final\nE : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} E\nG : CategoryTheory.Functor D E\ninst✝ : CategoryTheory.Limits.HasColimit G\nX : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι G (F.obj X)) (CategoryTheory.Functor.Final.colimitIso F G).inv) (CategoryTheory.Limits.colimit.ι (F.comp G) X)","decl":"@[reassoc (attr := simp)]\ntheorem ι_colimitIso_inv [HasColimit G] (X : C) :\n    colimit.ι G (F.obj X) ≫ (colimitIso F G).inv = colimit.ι (F ⋙ G) X := by\n  simp [colimitIso]\n\n"}
{"name":"CategoryTheory.Functor.Final.ι_colimitIso_inv_assoc","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝² : F.Final\nE : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} E\nG : CategoryTheory.Functor D E\ninst✝ : CategoryTheory.Limits.HasColimit G\nX : C\nZ : E\nh : Quiver.Hom (CategoryTheory.Limits.colimit (F.comp G)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι G (F.obj X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.Final.colimitIso F G).inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι (F.comp G) X) h)","decl":"@[reassoc (attr := simp)]\ntheorem ι_colimitIso_inv [HasColimit G] (X : C) :\n    colimit.ι G (F.obj X) ≫ (colimitIso F G).inv = colimit.ι (F ⋙ G) X := by\n  simp [colimitIso]\n\n"}
{"name":"CategoryTheory.Functor.Final.colimitCoconeOfComp_isColimit","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.Final\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nG : CategoryTheory.Functor D E\nt : CategoryTheory.Limits.ColimitCocone (F.comp G)\n⊢ Eq (CategoryTheory.Functor.Final.colimitCoconeOfComp F t).isColimit ((CategoryTheory.Functor.Final.isColimitExtendCoconeEquiv F t.cocone).symm t.isColimit)","decl":"/-- Given a colimit cocone over `F ⋙ G` we can construct a colimit cocone over `G`. -/\n@[simps]\ndef colimitCoconeOfComp (t : ColimitCocone (F ⋙ G)) : ColimitCocone G where\n  cocone := extendCocone.obj t.cocone\n  isColimit := (isColimitExtendCoconeEquiv F _).symm t.isColimit\n\n"}
{"name":"CategoryTheory.Functor.Final.colimitCoconeOfComp_cocone","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.Final\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nG : CategoryTheory.Functor D E\nt : CategoryTheory.Limits.ColimitCocone (F.comp G)\n⊢ Eq (CategoryTheory.Functor.Final.colimitCoconeOfComp F t).cocone (CategoryTheory.Functor.Final.extendCocone.obj t.cocone)","decl":"/-- Given a colimit cocone over `F ⋙ G` we can construct a colimit cocone over `G`. -/\n@[simps]\ndef colimitCoconeOfComp (t : ColimitCocone (F ⋙ G)) : ColimitCocone G where\n  cocone := extendCocone.obj t.cocone\n  isColimit := (isColimitExtendCoconeEquiv F _).symm t.isColimit\n\n"}
{"name":"CategoryTheory.Functor.Final.hasColimit_of_comp","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝² : F.Final\nE : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} E\nG : CategoryTheory.Functor D E\ninst✝ : CategoryTheory.Limits.HasColimit (F.comp G)\n⊢ CategoryTheory.Limits.HasColimit G","decl":"/-- When `F` is final, and `F ⋙ G` has a colimit, then `G` has a colimit also.\n\nWe can't make this an instance, because `F` is not determined by the goal.\n(Even if this weren't a problem, it would cause a loop with `comp_hasColimit`.)\n-/\ntheorem hasColimit_of_comp [HasColimit (F ⋙ G)] : HasColimit G :=\n  HasColimit.mk (colimitCoconeOfComp F (getColimitCocone (F ⋙ G)))\n\n"}
{"name":"CategoryTheory.Functor.Final.preservesColimit_of_comp","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝³ : F.Final\nE : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} E\nG : CategoryTheory.Functor D E\nB : Type u₄\ninst✝¹ : CategoryTheory.Category.{v₄, u₄} B\nH : CategoryTheory.Functor E B\ninst✝ : CategoryTheory.Limits.PreservesColimit (F.comp G) H\n⊢ CategoryTheory.Limits.PreservesColimit G H","decl":"theorem preservesColimit_of_comp {B : Type u₄} [Category.{v₄} B] {H : E ⥤ B}\n    [PreservesColimit (F ⋙ G) H] : PreservesColimit G H where\n  preserves {c} hc := by\n    refine ⟨isColimitWhiskerEquiv F _ ?_⟩\n    let hc' := isColimitOfPreserves H ((isColimitWhiskerEquiv F _).symm hc)\n    exact IsColimit.ofIsoColimit hc' (Cocones.ext (Iso.refl _) (by simp))\n\n"}
{"name":"CategoryTheory.Functor.Final.reflectsColimit_of_comp","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝³ : F.Final\nE : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} E\nG : CategoryTheory.Functor D E\nB : Type u₄\ninst✝¹ : CategoryTheory.Category.{v₄, u₄} B\nH : CategoryTheory.Functor E B\ninst✝ : CategoryTheory.Limits.ReflectsColimit (F.comp G) H\n⊢ CategoryTheory.Limits.ReflectsColimit G H","decl":"theorem reflectsColimit_of_comp {B : Type u₄} [Category.{v₄} B] {H : E ⥤ B}\n    [ReflectsColimit (F ⋙ G) H] : ReflectsColimit G H where\n  reflects {c} hc := by\n    refine ⟨isColimitWhiskerEquiv F _ (isColimitOfReflects H ?_)⟩\n    let hc' := (isColimitWhiskerEquiv F _).symm hc\n    exact IsColimit.ofIsoColimit hc' (Cocones.ext (Iso.refl _) (by simp))\n\n"}
{"name":"CategoryTheory.Functor.Final.hasColimitsOfShape_of_final","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝² : F.Final\nE : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} E\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape C E\n⊢ CategoryTheory.Limits.HasColimitsOfShape D E","decl":"include F in\ntheorem hasColimitsOfShape_of_final [HasColimitsOfShape C E] : HasColimitsOfShape D E where\n  has_colimit := fun _ => hasColimit_of_comp F\n\n"}
{"name":"CategoryTheory.Functor.Final.preservesColimitsOfShape_of_final","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝³ : F.Final\nE : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} E\nB : Type u₄\ninst✝¹ : CategoryTheory.Category.{v₄, u₄} B\nH : CategoryTheory.Functor E B\ninst✝ : CategoryTheory.Limits.PreservesColimitsOfShape C H\n⊢ CategoryTheory.Limits.PreservesColimitsOfShape D H","decl":"include F in\ntheorem preservesColimitsOfShape_of_final {B : Type u₄} [Category.{v₄} B] (H : E ⥤ B)\n    [PreservesColimitsOfShape C H] : PreservesColimitsOfShape D H where\n  preservesColimit := preservesColimit_of_comp F\n\n"}
{"name":"CategoryTheory.Functor.Final.reflectsColimitsOfShape_of_final","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝³ : F.Final\nE : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} E\nB : Type u₄\ninst✝¹ : CategoryTheory.Category.{v₄, u₄} B\nH : CategoryTheory.Functor E B\ninst✝ : CategoryTheory.Limits.ReflectsColimitsOfShape C H\n⊢ CategoryTheory.Limits.ReflectsColimitsOfShape D H","decl":"include F in\ntheorem reflectsColimitsOfShape_of_final {B : Type u₄} [Category.{v₄} B] (H : E ⥤ B)\n    [ReflectsColimitsOfShape C H] : ReflectsColimitsOfShape D H where\n  reflectsColimit := reflectsColimit_of_comp F\n\n"}
{"name":"CategoryTheory.Functor.Final.zigzag_of_eqvGen_quot_rel","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type v\ninst✝¹ : CategoryTheory.Category.{v, v} C\nD : Type u₁\ninst✝ : CategoryTheory.Category.{v, u₁} D\nF : CategoryTheory.Functor C D\nd : D\nf₁ f₂ : Sigma fun X => Quiver.Hom d (F.obj X)\nt : Relation.EqvGen (CategoryTheory.Limits.Types.Quot.Rel (F.comp (CategoryTheory.coyoneda.obj { unop := d }))) f₁ f₂\n⊢ CategoryTheory.Zigzag (CategoryTheory.StructuredArrow.mk f₁.snd) (CategoryTheory.StructuredArrow.mk f₂.snd)","decl":"theorem zigzag_of_eqvGen_quot_rel {F : C ⥤ D} {d : D} {f₁ f₂ : ΣX, d ⟶ F.obj X}\n    (t : Relation.EqvGen (Types.Quot.Rel.{v, v} (F ⋙ coyoneda.obj (op d))) f₁ f₂) :\n    Zigzag (StructuredArrow.mk f₁.2) (StructuredArrow.mk f₂.2) := by\n  induction t with\n  | rel x y r =>\n    obtain ⟨f, w⟩ := r\n    fconstructor\n    swap\n    · fconstructor\n    left; fconstructor\n    exact StructuredArrow.homMk f\n  | refl => fconstructor\n  | symm x y _ ih =>\n    apply zigzag_symmetric\n    exact ih\n  | trans x y z _ _ ih₁ ih₂ =>\n    apply Relation.ReflTransGen.trans\n    · exact ih₁\n    · exact ih₂\n\n"}
{"name":"CategoryTheory.Functor.final_of_colimit_comp_coyoneda_iso_pUnit","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type v\ninst✝¹ : CategoryTheory.Category.{v, v} C\nD : Type u₁\ninst✝ : CategoryTheory.Category.{v, u₁} D\nF : CategoryTheory.Functor C D\nI : (d : D) → CategoryTheory.Iso (CategoryTheory.Limits.colimit (F.comp (CategoryTheory.coyoneda.obj { unop := d }))) PUnit.{v + 1}\n⊢ F.Final","decl":"/-- If `colimit (F ⋙ coyoneda.obj (op d)) ≅ PUnit` for all `d : D`, then `F` is final.\n-/\ntheorem final_of_colimit_comp_coyoneda_iso_pUnit\n    (I : ∀ d, colimit (F ⋙ coyoneda.obj (op d)) ≅ PUnit) : Final F :=\n  ⟨fun d => by\n    have : Nonempty (StructuredArrow d F) := by\n      have := (I d).inv PUnit.unit\n      obtain ⟨j, y, rfl⟩ := Limits.Types.jointly_surjective'.{v, v} this\n      exact ⟨StructuredArrow.mk y⟩\n    apply zigzag_isConnected\n    rintro ⟨⟨⟨⟩⟩, X₁, f₁⟩ ⟨⟨⟨⟩⟩, X₂, f₂⟩\n    let y₁ := colimit.ι (F ⋙ coyoneda.obj (op d)) X₁ f₁\n    let y₂ := colimit.ι (F ⋙ coyoneda.obj (op d)) X₂ f₂\n    have e : y₁ = y₂ := by\n      apply (I d).toEquiv.injective\n      ext\n    have t := Types.colimit_eq.{v, v} e\n    clear e y₁ y₂\n    exact Final.zigzag_of_eqvGen_quot_rel t⟩\n\n"}
{"name":"CategoryTheory.Functor.final_of_isTerminal_colimit_comp_yoneda","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type v\ninst✝¹ : CategoryTheory.Category.{v, v} C\nD : Type u₁\ninst✝ : CategoryTheory.Category.{v, u₁} D\nF : CategoryTheory.Functor C D\nh : CategoryTheory.Limits.IsTerminal (CategoryTheory.Limits.colimit (F.comp CategoryTheory.yoneda))\n⊢ F.Final","decl":"/-- A variant of `final_of_colimit_comp_coyoneda_iso_pUnit` where we bind the various claims\n    about `colimit (F ⋙ coyoneda.obj (Opposite.op d))` for each `d : D` into a single claim about\n    the presheaf `colimit (F ⋙ yoneda)`. -/\ntheorem final_of_isTerminal_colimit_comp_yoneda\n    (h : IsTerminal (colimit (F ⋙ yoneda))) : Final F := by\n  refine final_of_colimit_comp_coyoneda_iso_pUnit _ (fun d => ?_)\n  refine Types.isTerminalEquivIsoPUnit _ ?_\n  let b := IsTerminal.isTerminalObj ((evaluation _ _).obj (Opposite.op d)) _ h\n  exact b.ofIso <| preservesColimitIso ((evaluation _ _).obj (Opposite.op d)) (F ⋙ yoneda)\n\n"}
{"name":"CategoryTheory.Functor.final_iff_isIso_colimit_pre","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type v\ninst✝¹ : CategoryTheory.Category.{v, v} C\nD : Type v\ninst✝ : CategoryTheory.Category.{v, v} D\nF : CategoryTheory.Functor C D\n⊢ Iff F.Final (∀ (G : CategoryTheory.Functor D (Type v)), CategoryTheory.IsIso (CategoryTheory.Limits.colimit.pre G F))","decl":"theorem final_iff_isIso_colimit_pre : Final F ↔ ∀ G : D ⥤ Type v, IsIso (colimit.pre G F) :=\n  ⟨fun _ => inferInstance,\n   fun _ => final_of_colimit_comp_coyoneda_iso_pUnit _ fun _ => Final.colimitCompCoyonedaIso _ _⟩\n\n"}
{"name":"CategoryTheory.Functor.Initial.instNonemptyCostructuredArrow","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : F.Initial\nd : D\n⊢ Nonempty (CategoryTheory.CostructuredArrow F d)","decl":"instance (d : D) : Nonempty (CostructuredArrow F d) :=\n  IsConnected.is_nonempty\n\n"}
{"name":"CategoryTheory.Functor.Initial.extendCone_obj_pt","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.Initial\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nG : CategoryTheory.Functor D E\nc : CategoryTheory.Limits.Cone (F.comp G)\n⊢ Eq (CategoryTheory.Functor.Initial.extendCone.obj c).pt c.pt","decl":"/-- Given a cone over `F ⋙ G`, we can construct a `Cone G` with the same cocone point.\n-/\n@[simps]\ndef extendCone : Cone (F ⋙ G) ⥤ Cone G where\n  obj c :=\n    { pt := c.pt\n      π :=\n        { app := fun d => c.π.app (lift F d) ≫ G.map (homToLift F d)\n          naturality := fun X Y f => by\n            dsimp; simp only [Category.id_comp, Category.assoc]\n            -- This would be true if we'd chosen `lift F Y` to be `lift F X`\n            -- and `homToLift F Y` to be `homToLift F X ≫ f`.\n            apply\n              induction F fun Z k =>\n                (c.π.app Z ≫ G.map k : c.pt ⟶ _) =\n                  c.π.app (lift F X) ≫ G.map (homToLift F X) ≫ G.map f\n            · intro Z₁ Z₂ k₁ k₂ g a z\n              rw [← a, Functor.map_comp, ← Functor.comp_map, ← Category.assoc, ← Category.assoc,\n                c.w] at z\n              rw [z, Category.assoc]\n            · intro Z₁ Z₂ k₁ k₂ g a z\n              rw [← a, Functor.map_comp, ← Functor.comp_map, ← Category.assoc, ← Category.assoc,\n                c.w, z, Category.assoc]\n            · rw [← Functor.map_comp] } }\n  map f := { hom := f.hom }\n\n"}
{"name":"CategoryTheory.Functor.Initial.extendCone_map_hom","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.Initial\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nG : CategoryTheory.Functor D E\nX✝ Y✝ : CategoryTheory.Limits.Cone (F.comp G)\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.Functor.Initial.extendCone.map f).hom f.hom","decl":"/-- Given a cone over `F ⋙ G`, we can construct a `Cone G` with the same cocone point.\n-/\n@[simps]\ndef extendCone : Cone (F ⋙ G) ⥤ Cone G where\n  obj c :=\n    { pt := c.pt\n      π :=\n        { app := fun d => c.π.app (lift F d) ≫ G.map (homToLift F d)\n          naturality := fun X Y f => by\n            dsimp; simp only [Category.id_comp, Category.assoc]\n            -- This would be true if we'd chosen `lift F Y` to be `lift F X`\n            -- and `homToLift F Y` to be `homToLift F X ≫ f`.\n            apply\n              induction F fun Z k =>\n                (c.π.app Z ≫ G.map k : c.pt ⟶ _) =\n                  c.π.app (lift F X) ≫ G.map (homToLift F X) ≫ G.map f\n            · intro Z₁ Z₂ k₁ k₂ g a z\n              rw [← a, Functor.map_comp, ← Functor.comp_map, ← Category.assoc, ← Category.assoc,\n                c.w] at z\n              rw [z, Category.assoc]\n            · intro Z₁ Z₂ k₁ k₂ g a z\n              rw [← a, Functor.map_comp, ← Functor.comp_map, ← Category.assoc, ← Category.assoc,\n                c.w, z, Category.assoc]\n            · rw [← Functor.map_comp] } }\n  map f := { hom := f.hom }\n\n"}
{"name":"CategoryTheory.Functor.Initial.extendCone_obj_π_app","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.Initial\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nG : CategoryTheory.Functor D E\nc : CategoryTheory.Limits.Cone (F.comp G)\nd : D\n⊢ Eq ((CategoryTheory.Functor.Initial.extendCone.obj c).π.app d) (CategoryTheory.CategoryStruct.comp (c.π.app (CategoryTheory.Functor.Initial.lift F d)) (G.map (CategoryTheory.Functor.Initial.homToLift F d)))","decl":"/-- Given a cone over `F ⋙ G`, we can construct a `Cone G` with the same cocone point.\n-/\n@[simps]\ndef extendCone : Cone (F ⋙ G) ⥤ Cone G where\n  obj c :=\n    { pt := c.pt\n      π :=\n        { app := fun d => c.π.app (lift F d) ≫ G.map (homToLift F d)\n          naturality := fun X Y f => by\n            dsimp; simp only [Category.id_comp, Category.assoc]\n            -- This would be true if we'd chosen `lift F Y` to be `lift F X`\n            -- and `homToLift F Y` to be `homToLift F X ≫ f`.\n            apply\n              induction F fun Z k =>\n                (c.π.app Z ≫ G.map k : c.pt ⟶ _) =\n                  c.π.app (lift F X) ≫ G.map (homToLift F X) ≫ G.map f\n            · intro Z₁ Z₂ k₁ k₂ g a z\n              rw [← a, Functor.map_comp, ← Functor.comp_map, ← Category.assoc, ← Category.assoc,\n                c.w] at z\n              rw [z, Category.assoc]\n            · intro Z₁ Z₂ k₁ k₂ g a z\n              rw [← a, Functor.map_comp, ← Functor.comp_map, ← Category.assoc, ← Category.assoc,\n                c.w, z, Category.assoc]\n            · rw [← Functor.map_comp] } }\n  map f := { hom := f.hom }\n\n"}
{"name":"CategoryTheory.Functor.Initial.extendCone_obj_π_app'","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.Initial\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nG : CategoryTheory.Functor D E\nc : CategoryTheory.Limits.Cone (F.comp G)\nX : C\nY : D\nf : Quiver.Hom (F.obj X) Y\n⊢ Eq ((CategoryTheory.Functor.Initial.extendCone.obj c).π.app Y) (CategoryTheory.CategoryStruct.comp (c.π.app X) (G.map f))","decl":"/-- Alternative equational lemma for `(extendCone c).π.app` in case a lift of the object\nis given explicitly. -/\nlemma extendCone_obj_π_app' (c : Cone (F ⋙ G)) {X : C} {Y : D} (f : F.obj X ⟶ Y) :\n    (extendCone.obj c).π.app Y = c.π.app X ≫ G.map f := by\n  apply induction (k₀ := f) (z := rfl) F fun Z g =>\n    c.π.app Z ≫ G.map g = c.π.app X ≫ G.map f\n  · intro _ _ _ _ _ h₁ h₂\n    simp [← h₂, ← h₁, ← Functor.comp_map, c.π.naturality]\n  · intro _ _ _ _ _ h₁ h₂\n    simp [← h₁, ← Functor.comp_map, c.π.naturality, h₂]\n\n"}
{"name":"CategoryTheory.Functor.Initial.limit_cone_comp_aux","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.Initial\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nG : CategoryTheory.Functor D E\ns : CategoryTheory.Limits.Cone (F.comp G)\nj : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (s.π.app (CategoryTheory.Functor.Initial.lift F (F.obj j))) (G.map (CategoryTheory.Functor.Initial.homToLift F (F.obj j)))) (s.π.app j)","decl":"@[simp]\ntheorem limit_cone_comp_aux (s : Cone (F ⋙ G)) (j : C) :\n    s.π.app (lift F (F.obj j)) ≫ G.map (homToLift F (F.obj j)) = s.π.app j := by\n  -- This point is that this would be true if we took `lift (F.obj j)` to just be `j`\n  -- and `homToLift (F.obj j)` to be `𝟙 (F.obj j)`.\n  apply induction F fun X k => s.π.app X ≫ G.map k = (s.π.app j :)\n  · intro j₁ j₂ k₁ k₂ f w h\n    rw [← s.w f]\n    rw [← w] at h\n    simpa using h\n  · intro j₁ j₂ k₁ k₂ f w h\n    rw [← s.w f] at h\n    rw [← w]\n    simpa using h\n  · exact s.w (𝟙 _)\n\n"}
{"name":"CategoryTheory.Functor.Initial.conesEquiv_inverse","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.Initial\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nG : CategoryTheory.Functor D E\n⊢ Eq (CategoryTheory.Functor.Initial.conesEquiv F G).inverse (CategoryTheory.Limits.Cones.whiskering F)","decl":"/-- If `F` is initial,\nthe category of cones on `F ⋙ G` is equivalent to the category of cones on `G`,\nfor any `G : D ⥤ E`.\n-/\n@[simps]\ndef conesEquiv : Cone (F ⋙ G) ≌ Cone G where\n  functor := extendCone\n  inverse := Cones.whiskering F\n  unitIso := NatIso.ofComponents fun c => Cones.ext (Iso.refl _)\n  counitIso := NatIso.ofComponents fun c => Cones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Functor.Initial.conesEquiv_counitIso","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.Initial\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nG : CategoryTheory.Functor D E\n⊢ Eq (CategoryTheory.Functor.Initial.conesEquiv F G).counitIso (CategoryTheory.NatIso.ofComponents (fun c => CategoryTheory.Limits.Cones.ext (CategoryTheory.Iso.refl (((CategoryTheory.Limits.Cones.whiskering F).comp CategoryTheory.Functor.Initial.extendCone).obj c).pt) ⋯) ⋯)","decl":"/-- If `F` is initial,\nthe category of cones on `F ⋙ G` is equivalent to the category of cones on `G`,\nfor any `G : D ⥤ E`.\n-/\n@[simps]\ndef conesEquiv : Cone (F ⋙ G) ≌ Cone G where\n  functor := extendCone\n  inverse := Cones.whiskering F\n  unitIso := NatIso.ofComponents fun c => Cones.ext (Iso.refl _)\n  counitIso := NatIso.ofComponents fun c => Cones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Functor.Initial.conesEquiv_unitIso","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.Initial\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nG : CategoryTheory.Functor D E\n⊢ Eq (CategoryTheory.Functor.Initial.conesEquiv F G).unitIso (CategoryTheory.NatIso.ofComponents (fun c => CategoryTheory.Limits.Cones.ext (CategoryTheory.Iso.refl ((CategoryTheory.Functor.id (CategoryTheory.Limits.Cone (F.comp G))).obj c).pt) ⋯) ⋯)","decl":"/-- If `F` is initial,\nthe category of cones on `F ⋙ G` is equivalent to the category of cones on `G`,\nfor any `G : D ⥤ E`.\n-/\n@[simps]\ndef conesEquiv : Cone (F ⋙ G) ≌ Cone G where\n  functor := extendCone\n  inverse := Cones.whiskering F\n  unitIso := NatIso.ofComponents fun c => Cones.ext (Iso.refl _)\n  counitIso := NatIso.ofComponents fun c => Cones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Functor.Initial.conesEquiv_functor","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.Initial\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nG : CategoryTheory.Functor D E\n⊢ Eq (CategoryTheory.Functor.Initial.conesEquiv F G).functor CategoryTheory.Functor.Initial.extendCone","decl":"/-- If `F` is initial,\nthe category of cones on `F ⋙ G` is equivalent to the category of cones on `G`,\nfor any `G : D ⥤ E`.\n-/\n@[simps]\ndef conesEquiv : Cone (F ⋙ G) ≌ Cone G where\n  functor := extendCone\n  inverse := Cones.whiskering F\n  unitIso := NatIso.ofComponents fun c => Cones.ext (Iso.refl _)\n  counitIso := NatIso.ofComponents fun c => Cones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Functor.Initial.limitConeComp_cone","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.Initial\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nG : CategoryTheory.Functor D E\nt : CategoryTheory.Limits.LimitCone G\n⊢ Eq (CategoryTheory.Functor.Initial.limitConeComp F t).cone (CategoryTheory.Limits.Cone.whisker F t.cone)","decl":"/-- Given a limit cone over `G : D ⥤ E` we can construct a limit cone over `F ⋙ G`. -/\n@[simps]\ndef limitConeComp (t : LimitCone G) : LimitCone (F ⋙ G) where\n  cone := _\n  isLimit := (isLimitWhiskerEquiv F _).symm t.isLimit\n\n"}
{"name":"CategoryTheory.Functor.Initial.limitConeComp_isLimit","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.Initial\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nG : CategoryTheory.Functor D E\nt : CategoryTheory.Limits.LimitCone G\n⊢ Eq (CategoryTheory.Functor.Initial.limitConeComp F t).isLimit ((CategoryTheory.Functor.Initial.isLimitWhiskerEquiv F t.cone).symm t.isLimit)","decl":"/-- Given a limit cone over `G : D ⥤ E` we can construct a limit cone over `F ⋙ G`. -/\n@[simps]\ndef limitConeComp (t : LimitCone G) : LimitCone (F ⋙ G) where\n  cone := _\n  isLimit := (isLimitWhiskerEquiv F _).symm t.isLimit\n\n"}
{"name":"CategoryTheory.Functor.Initial.comp_hasLimit","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝² : F.Initial\nE : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} E\nG : CategoryTheory.Functor D E\ninst✝ : CategoryTheory.Limits.HasLimit G\n⊢ CategoryTheory.Limits.HasLimit (F.comp G)","decl":"instance (priority := 100) comp_hasLimit [HasLimit G] : HasLimit (F ⋙ G) :=\n  HasLimit.mk (limitConeComp F (getLimitCone G))\n\n"}
{"name":"CategoryTheory.Functor.Initial.comp_preservesLimit","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nE : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} E\nG : CategoryTheory.Functor D E\nB : Type u₄\ninst✝¹ : CategoryTheory.Category.{v₄, u₄} B\nH : CategoryTheory.Functor E B\ninst✝ : CategoryTheory.Limits.PreservesLimit G H\n⊢ CategoryTheory.Limits.PreservesLimit (F.comp G) H","decl":"instance (priority := 100) comp_preservesLimit {B : Type u₄} [Category.{v₄} B] {H : E ⥤ B}\n    [PreservesLimit G H] : PreservesLimit (F ⋙ G) H where\n  preserves {c} hc := by\n    refine ⟨isLimitExtendConeEquiv (G := G ⋙ H) F (H.mapCone c) ?_⟩\n    let hc' := isLimitOfPreserves H ((isLimitExtendConeEquiv F c).symm hc)\n    exact IsLimit.ofIsoLimit hc' (Cones.ext (Iso.refl _) (by simp))\n\n"}
{"name":"CategoryTheory.Functor.Initial.comp_reflectsLimit","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nE : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} E\nG : CategoryTheory.Functor D E\nB : Type u₄\ninst✝¹ : CategoryTheory.Category.{v₄, u₄} B\nH : CategoryTheory.Functor E B\ninst✝ : CategoryTheory.Limits.ReflectsLimit G H\n⊢ CategoryTheory.Limits.ReflectsLimit (F.comp G) H","decl":"instance (priority := 100) comp_reflectsLimit {B : Type u₄} [Category.{v₄} B] {H : E ⥤ B}\n    [ReflectsLimit G H] : ReflectsLimit (F ⋙ G) H where\n  reflects {c} hc := by\n    refine ⟨isLimitExtendConeEquiv F _ (isLimitOfReflects H ?_)⟩\n    let hc' := (isLimitExtendConeEquiv (G := G ⋙ H) F _).symm hc\n    exact IsLimit.ofIsoLimit hc' (Cones.ext (Iso.refl _) (by simp))\n\n"}
{"name":"CategoryTheory.Functor.Initial.limit_pre_isIso","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝² : F.Initial\nE : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} E\nG : CategoryTheory.Functor D E\ninst✝ : CategoryTheory.Limits.HasLimit G\n⊢ CategoryTheory.IsIso (CategoryTheory.Limits.limit.pre G F)","decl":"instance limit_pre_isIso [HasLimit G] : IsIso (limit.pre G F) := by\n  rw [limit.pre_eq (limitConeComp F (getLimitCone G)) (getLimitCone G)]\n  erw [IsLimit.lift_self]\n  dsimp\n  infer_instance\n\n"}
{"name":"CategoryTheory.Functor.Initial.limitIso_inv","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝² : F.Initial\nE : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} E\nG : CategoryTheory.Functor D E\ninst✝ : CategoryTheory.Limits.HasLimit G\n⊢ Eq (CategoryTheory.Functor.Initial.limitIso F G).inv (CategoryTheory.Limits.limit.pre G F)","decl":"/-- When `F : C ⥤ D` is initial, and `G : D ⥤ E` has a limit, then `F ⋙ G` has a limit also and\n`limit (F ⋙ G) ≅ limit G`. -/\n@[simps! (config := .lemmasOnly), stacks 04E7]\ndef limitIso [HasLimit G] : limit (F ⋙ G) ≅ limit G :=\n  (asIso (limit.pre G F)).symm\n\n"}
{"name":"CategoryTheory.Functor.Initial.limitIso_hom","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝² : F.Initial\nE : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} E\nG : CategoryTheory.Functor D E\ninst✝ : CategoryTheory.Limits.HasLimit G\n⊢ Eq (CategoryTheory.Functor.Initial.limitIso F G).hom (CategoryTheory.inv (CategoryTheory.Limits.limit.pre G F))","decl":"/-- When `F : C ⥤ D` is initial, and `G : D ⥤ E` has a limit, then `F ⋙ G` has a limit also and\n`limit (F ⋙ G) ≅ limit G`. -/\n@[simps! (config := .lemmasOnly), stacks 04E7]\ndef limitIso [HasLimit G] : limit (F ⋙ G) ≅ limit G :=\n  (asIso (limit.pre G F)).symm\n\n"}
{"name":"CategoryTheory.Functor.Initial.limitConeOfComp_isLimit","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.Initial\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nG : CategoryTheory.Functor D E\nt : CategoryTheory.Limits.LimitCone (F.comp G)\n⊢ Eq (CategoryTheory.Functor.Initial.limitConeOfComp F t).isLimit ((CategoryTheory.Functor.Initial.isLimitExtendConeEquiv F t.cone).symm t.isLimit)","decl":"/-- Given a limit cone over `F ⋙ G` we can construct a limit cone over `G`. -/\n@[simps]\ndef limitConeOfComp (t : LimitCone (F ⋙ G)) : LimitCone G where\n  cone := extendCone.obj t.cone\n  isLimit := (isLimitExtendConeEquiv F _).symm t.isLimit\n\n"}
{"name":"CategoryTheory.Functor.Initial.limitConeOfComp_cone","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.Initial\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nG : CategoryTheory.Functor D E\nt : CategoryTheory.Limits.LimitCone (F.comp G)\n⊢ Eq (CategoryTheory.Functor.Initial.limitConeOfComp F t).cone (CategoryTheory.Functor.Initial.extendCone.obj t.cone)","decl":"/-- Given a limit cone over `F ⋙ G` we can construct a limit cone over `G`. -/\n@[simps]\ndef limitConeOfComp (t : LimitCone (F ⋙ G)) : LimitCone G where\n  cone := extendCone.obj t.cone\n  isLimit := (isLimitExtendConeEquiv F _).symm t.isLimit\n\n"}
{"name":"CategoryTheory.Functor.Initial.hasLimit_of_comp","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝² : F.Initial\nE : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} E\nG : CategoryTheory.Functor D E\ninst✝ : CategoryTheory.Limits.HasLimit (F.comp G)\n⊢ CategoryTheory.Limits.HasLimit G","decl":"/-- When `F` is initial, and `F ⋙ G` has a limit, then `G` has a limit also.\n\nWe can't make this an instance, because `F` is not determined by the goal.\n(Even if this weren't a problem, it would cause a loop with `comp_hasLimit`.)\n-/\ntheorem hasLimit_of_comp [HasLimit (F ⋙ G)] : HasLimit G :=\n  HasLimit.mk (limitConeOfComp F (getLimitCone (F ⋙ G)))\n\n"}
{"name":"CategoryTheory.Functor.Initial.preservesLimit_of_comp","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝³ : F.Initial\nE : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} E\nG : CategoryTheory.Functor D E\nB : Type u₄\ninst✝¹ : CategoryTheory.Category.{v₄, u₄} B\nH : CategoryTheory.Functor E B\ninst✝ : CategoryTheory.Limits.PreservesLimit (F.comp G) H\n⊢ CategoryTheory.Limits.PreservesLimit G H","decl":"theorem preservesLimit_of_comp {B : Type u₄} [Category.{v₄} B] {H : E ⥤ B}\n    [PreservesLimit (F ⋙ G) H] : PreservesLimit G H where\n  preserves {c} hc := by\n    refine ⟨isLimitWhiskerEquiv F _ ?_⟩\n    let hc' := isLimitOfPreserves H ((isLimitWhiskerEquiv F _).symm hc)\n    exact IsLimit.ofIsoLimit hc' (Cones.ext (Iso.refl _) (by simp))\n\n"}
{"name":"CategoryTheory.Functor.Initial.reflectsLimit_of_comp","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝³ : F.Initial\nE : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} E\nG : CategoryTheory.Functor D E\nB : Type u₄\ninst✝¹ : CategoryTheory.Category.{v₄, u₄} B\nH : CategoryTheory.Functor E B\ninst✝ : CategoryTheory.Limits.ReflectsLimit (F.comp G) H\n⊢ CategoryTheory.Limits.ReflectsLimit G H","decl":"theorem reflectsLimit_of_comp {B : Type u₄} [Category.{v₄} B] {H : E ⥤ B}\n    [ReflectsLimit (F ⋙ G) H] : ReflectsLimit G H where\n  reflects {c} hc := by\n    refine ⟨isLimitWhiskerEquiv F _ (isLimitOfReflects H ?_)⟩\n    let hc' := (isLimitWhiskerEquiv F _).symm hc\n    exact IsLimit.ofIsoLimit hc' (Cones.ext (Iso.refl _) (by simp))\n\n"}
{"name":"CategoryTheory.Functor.Initial.hasLimitsOfShape_of_initial","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝² : F.Initial\nE : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} E\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape C E\n⊢ CategoryTheory.Limits.HasLimitsOfShape D E","decl":"include F in\ntheorem hasLimitsOfShape_of_initial [HasLimitsOfShape C E] : HasLimitsOfShape D E where\n  has_limit := fun _ => hasLimit_of_comp F\n\n"}
{"name":"CategoryTheory.Functor.Initial.preservesLimitsOfShape_of_initial","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝³ : F.Initial\nE : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} E\nB : Type u₄\ninst✝¹ : CategoryTheory.Category.{v₄, u₄} B\nH : CategoryTheory.Functor E B\ninst✝ : CategoryTheory.Limits.PreservesLimitsOfShape C H\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape D H","decl":"include F in\ntheorem preservesLimitsOfShape_of_initial {B : Type u₄} [Category.{v₄} B] (H : E ⥤ B)\n    [PreservesLimitsOfShape C H] : PreservesLimitsOfShape D H where\n  preservesLimit := preservesLimit_of_comp F\n\n"}
{"name":"CategoryTheory.Functor.Initial.reflectsLimitsOfShape_of_initial","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝³ : F.Initial\nE : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} E\nB : Type u₄\ninst✝¹ : CategoryTheory.Category.{v₄, u₄} B\nH : CategoryTheory.Functor E B\ninst✝ : CategoryTheory.Limits.ReflectsLimitsOfShape C H\n⊢ CategoryTheory.Limits.ReflectsLimitsOfShape D H","decl":"include F in\ntheorem reflectsLimitsOfShape_of_initial {B : Type u₄} [Category.{v₄} B] (H : E ⥤ B)\n    [ReflectsLimitsOfShape C H] : ReflectsLimitsOfShape D H where\n  reflectsLimit := reflectsLimit_of_comp F\n\n"}
{"name":"CategoryTheory.Functor.final_of_comp_full_faithful","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst✝² : G.Full\ninst✝¹ : G.Faithful\ninst✝ : (F.comp G).Final\n⊢ F.Final","decl":"/-- The hypotheses also imply that `G` is final, see `final_of_comp_full_faithful'`. -/\ntheorem final_of_comp_full_faithful [Full G] [Faithful G] [Final (F ⋙ G)] : Final F where\n  out d := isConnected_of_equivalent (StructuredArrow.post d F G).asEquivalence.symm\n\n"}
{"name":"CategoryTheory.Functor.initial_of_comp_full_faithful","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst✝² : G.Full\ninst✝¹ : G.Faithful\ninst✝ : (F.comp G).Initial\n⊢ F.Initial","decl":"/-- The hypotheses also imply that `G` is initial, see `initial_of_comp_full_faithful'`. -/\ntheorem initial_of_comp_full_faithful [Full G] [Faithful G] [Initial (F ⋙ G)] : Initial F where\n  out d := isConnected_of_equivalent (CostructuredArrow.post F G d).asEquivalence.symm\n\n"}
{"name":"CategoryTheory.Functor.final_comp_equivalence","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst✝¹ : F.Final\ninst✝ : G.IsEquivalence\n⊢ (F.comp G).Final","decl":"/-- See also the strictly more general `final_comp` below. -/\ntheorem final_comp_equivalence [Final F] [IsEquivalence G] : Final (F ⋙ G) :=\n  let i : F ≅ (F ⋙ G) ⋙ G.inv := isoWhiskerLeft F G.asEquivalence.unitIso\n  have : Final ((F ⋙ G) ⋙ G.inv) := final_of_natIso i\n  final_of_comp_full_faithful (F ⋙ G) G.inv\n\n"}
{"name":"CategoryTheory.Functor.initial_comp_equivalence","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst✝¹ : F.Initial\ninst✝ : G.IsEquivalence\n⊢ (F.comp G).Initial","decl":"/-- See also the strictly more general `initial_comp` below. -/\ntheorem initial_comp_equivalence [Initial F] [IsEquivalence G] : Initial (F ⋙ G) :=\n  let i : F ≅ (F ⋙ G) ⋙ G.inv := isoWhiskerLeft F G.asEquivalence.unitIso\n  have : Initial ((F ⋙ G) ⋙ G.inv) := initial_of_natIso i\n  initial_of_comp_full_faithful (F ⋙ G) G.inv\n\n"}
{"name":"CategoryTheory.Functor.final_equivalence_comp","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst✝¹ : F.IsEquivalence\ninst✝ : G.Final\n⊢ (F.comp G).Final","decl":"/-- See also the strictly more general `final_comp` below. -/\ntheorem final_equivalence_comp [IsEquivalence F] [Final G] : Final (F ⋙ G) where\n  out d := isConnected_of_equivalent (StructuredArrow.pre d F G).asEquivalence.symm\n\n"}
{"name":"CategoryTheory.Functor.initial_equivalence_comp","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst✝¹ : F.IsEquivalence\ninst✝ : G.Initial\n⊢ (F.comp G).Initial","decl":"/-- See also the strictly more general `initial_comp` below. -/\ntheorem initial_equivalence_comp [IsEquivalence F] [Initial G] : Initial (F ⋙ G) where\n  out d := isConnected_of_equivalent (CostructuredArrow.pre F G d).asEquivalence.symm\n\n"}
{"name":"CategoryTheory.Functor.final_of_equivalence_comp","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst✝¹ : F.IsEquivalence\ninst✝ : (F.comp G).Final\n⊢ G.Final","decl":"/-- See also the strictly more general `final_of_final_comp` below. -/\ntheorem final_of_equivalence_comp [IsEquivalence F] [Final (F ⋙ G)] : Final G where\n  out d := isConnected_of_equivalent (StructuredArrow.pre d F G).asEquivalence\n\n"}
{"name":"CategoryTheory.Functor.initial_of_equivalence_comp","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst✝¹ : F.IsEquivalence\ninst✝ : (F.comp G).Initial\n⊢ G.Initial","decl":"/-- See also the strictly more general `initial_of_initial_comp` below. -/\ntheorem initial_of_equivalence_comp [IsEquivalence F] [Initial (F ⋙ G)] : Initial G where\n  out d := isConnected_of_equivalent (CostructuredArrow.pre F G d).asEquivalence\n\n"}
{"name":"CategoryTheory.Functor.final_iff_comp_equivalence","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst✝ : G.IsEquivalence\n⊢ Iff F.Final (F.comp G).Final","decl":"/-- See also the strictly more general `final_iff_comp_final_full_faithful` below. -/\ntheorem final_iff_comp_equivalence [IsEquivalence G] : Final F ↔ Final (F ⋙ G) :=\n  ⟨fun _ => final_comp_equivalence _ _, fun _ => final_of_comp_full_faithful _ G⟩\n\n"}
{"name":"CategoryTheory.Functor.final_iff_equivalence_comp","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst✝ : F.IsEquivalence\n⊢ Iff G.Final (F.comp G).Final","decl":"/-- See also the strictly more general `final_iff_final_comp` below. -/\ntheorem final_iff_equivalence_comp [IsEquivalence F] : Final G ↔ Final (F ⋙ G) :=\n  ⟨fun _ => final_equivalence_comp _ _, fun _ => final_of_equivalence_comp F _⟩\n\n"}
{"name":"CategoryTheory.Functor.initial_iff_comp_equivalence","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst✝ : G.IsEquivalence\n⊢ Iff F.Initial (F.comp G).Initial","decl":"/-- See also the strictly more general `initial_iff_comp_initial_full_faithful` below. -/\ntheorem initial_iff_comp_equivalence [IsEquivalence G] : Initial F ↔ Initial (F ⋙ G) :=\n  ⟨fun _ => initial_comp_equivalence _ _, fun _ => initial_of_comp_full_faithful _ G⟩\n\n"}
{"name":"CategoryTheory.Functor.initial_iff_equivalence_comp","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst✝ : F.IsEquivalence\n⊢ Iff G.Initial (F.comp G).Initial","decl":"/-- See also the strictly more general `initial_iff_initial_comp` below. -/\ntheorem initial_iff_equivalence_comp [IsEquivalence F] : Initial G ↔ Initial (F ⋙ G) :=\n  ⟨fun _ => initial_equivalence_comp _ _, fun _ => initial_of_equivalence_comp F _⟩\n\n"}
{"name":"CategoryTheory.Functor.final_comp","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\nhF : F.Final\nhG : G.Final\n⊢ (F.comp G).Final","decl":"instance final_comp [hF : Final F] [hG : Final G] : Final (F ⋙ G) := by\n  let s₁ : C ≌ AsSmall.{max u₁ v₁ u₂ v₂ u₃ v₃} C := AsSmall.equiv\n  let s₂ : D ≌ AsSmall.{max u₁ v₁ u₂ v₂ u₃ v₃} D := AsSmall.equiv\n  let s₃ : E ≌ AsSmall.{max u₁ v₁ u₂ v₂ u₃ v₃} E := AsSmall.equiv\n  let i : s₁.inverse ⋙ (F ⋙ G) ⋙ s₃.functor ≅\n      (s₁.inverse ⋙ F ⋙ s₂.functor) ⋙ (s₂.inverse ⋙ G ⋙ s₃.functor) :=\n    isoWhiskerLeft (s₁.inverse ⋙ F) (isoWhiskerRight s₂.unitIso (G ⋙ s₃.functor))\n  rw [final_iff_comp_equivalence (F ⋙ G) s₃.functor, final_iff_equivalence_comp s₁.inverse,\n    final_natIso_iff i, final_iff_isIso_colimit_pre]\n  rw [final_iff_comp_equivalence F s₂.functor, final_iff_equivalence_comp s₁.inverse,\n    final_iff_isIso_colimit_pre] at hF\n  rw [final_iff_comp_equivalence G s₃.functor, final_iff_equivalence_comp s₂.inverse,\n    final_iff_isIso_colimit_pre] at hG\n  intro H\n  rw [← colimit.pre_pre]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Functor.initial_comp","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst✝¹ : F.Initial\ninst✝ : G.Initial\n⊢ (F.comp G).Initial","decl":"instance initial_comp [Initial F] [Initial G] : Initial (F ⋙ G) := by\n  suffices Final (F ⋙ G).op from initial_of_final_op _\n  exact final_comp F.op G.op\n\n"}
{"name":"CategoryTheory.Functor.final_of_final_comp","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\nhF : F.Final\nhFG : (F.comp G).Final\n⊢ G.Final","decl":"theorem final_of_final_comp [hF : Final F] [hFG : Final (F ⋙ G)] : Final G := by\n  let s₁ : C ≌ AsSmall.{max u₁ v₁ u₂ v₂ u₃ v₃} C := AsSmall.equiv\n  let s₂ : D ≌ AsSmall.{max u₁ v₁ u₂ v₂ u₃ v₃} D := AsSmall.equiv\n  let s₃ : E ≌ AsSmall.{max u₁ v₁ u₂ v₂ u₃ v₃} E := AsSmall.equiv\n  let _i : s₁.inverse ⋙ (F ⋙ G) ⋙ s₃.functor ≅\n      (s₁.inverse ⋙ F ⋙ s₂.functor) ⋙ (s₂.inverse ⋙ G ⋙ s₃.functor) :=\n    isoWhiskerLeft (s₁.inverse ⋙ F) (isoWhiskerRight s₂.unitIso (G ⋙ s₃.functor))\n  rw [final_iff_comp_equivalence G s₃.functor, final_iff_equivalence_comp s₂.inverse,\n    final_iff_isIso_colimit_pre]\n  rw [final_iff_comp_equivalence F s₂.functor, final_iff_equivalence_comp s₁.inverse,\n    final_iff_isIso_colimit_pre] at hF\n  rw [final_iff_comp_equivalence (F ⋙ G) s₃.functor, final_iff_equivalence_comp s₁.inverse,\n    final_natIso_iff _i, final_iff_isIso_colimit_pre] at hFG\n  intro H\n  replace hFG := hFG H\n  rw [← colimit.pre_pre] at hFG\n  exact IsIso.of_isIso_comp_left (colimit.pre _ (s₁.inverse ⋙ F ⋙ s₂.functor)) _\n\n"}
{"name":"CategoryTheory.Functor.initial_of_initial_comp","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst✝¹ : F.Initial\ninst✝ : (F.comp G).Initial\n⊢ G.Initial","decl":"theorem initial_of_initial_comp [Initial F] [Initial (F ⋙ G)] : Initial G := by\n  suffices Final G.op from initial_of_final_op _\n  have : Final (F.op ⋙ G.op) := show Final (F ⋙ G).op from inferInstance\n  exact final_of_final_comp F.op G.op\n\n"}
{"name":"CategoryTheory.Functor.final_of_comp_full_faithful'","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst✝² : G.Full\ninst✝¹ : G.Faithful\ninst✝ : (F.comp G).Final\n⊢ G.Final","decl":"/-- The hypotheses also imply that `F` is final, see `final_of_comp_full_faithful`. -/\ntheorem final_of_comp_full_faithful' [Full G] [Faithful G] [Final (F ⋙ G)] : Final G :=\n  have := final_of_comp_full_faithful F G\n  final_of_final_comp F G\n\n"}
{"name":"CategoryTheory.Functor.initial_of_comp_full_faithful'","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst✝² : G.Full\ninst✝¹ : G.Faithful\ninst✝ : (F.comp G).Initial\n⊢ G.Initial","decl":"/-- The hypotheses also imply that `F` is initial, see `initial_of_comp_full_faithful`. -/\ntheorem initial_of_comp_full_faithful' [Full G] [Faithful G] [Initial (F ⋙ G)] : Initial G :=\n  have := initial_of_comp_full_faithful F G\n  initial_of_initial_comp F G\n\n"}
{"name":"CategoryTheory.Functor.final_iff_comp_final_full_faithful","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst✝² : G.Final\ninst✝¹ : G.Full\ninst✝ : G.Faithful\n⊢ Iff F.Final (F.comp G).Final","decl":"theorem final_iff_comp_final_full_faithful [Final G] [Full G] [Faithful G] :\n    Final F ↔ Final (F ⋙ G) :=\n  ⟨fun _ => final_comp _ _, fun _ => final_of_comp_full_faithful F G⟩\n\n"}
{"name":"CategoryTheory.Functor.initial_iff_comp_initial_full_faithful","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst✝² : G.Initial\ninst✝¹ : G.Full\ninst✝ : G.Faithful\n⊢ Iff F.Initial (F.comp G).Initial","decl":"theorem initial_iff_comp_initial_full_faithful [Initial G] [Full G] [Faithful G] :\n    Initial F ↔ Initial (F ⋙ G) :=\n  ⟨fun _ => initial_comp _ _, fun _ => initial_of_comp_full_faithful F G⟩\n\n"}
{"name":"CategoryTheory.Functor.final_iff_final_comp","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst✝ : F.Final\n⊢ Iff G.Final (F.comp G).Final","decl":"theorem final_iff_final_comp [Final F] : Final G ↔ Final (F ⋙ G) :=\n  ⟨fun _ => final_comp _ _, fun _ => final_of_final_comp F G⟩\n\n"}
{"name":"CategoryTheory.Functor.initial_iff_initial_comp","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst✝ : F.Initial\n⊢ Iff G.Initial (F.comp G).Initial","decl":"theorem initial_iff_initial_comp [Initial F] : Initial G ↔ Initial (F ⋙ G) :=\n  ⟨fun _ => initial_comp _ _, fun _ => initial_of_initial_comp F G⟩\n\n"}
{"name":"CategoryTheory.IsFilteredOrEmpty.of_final","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.Final\ninst✝ : CategoryTheory.IsFilteredOrEmpty C\n⊢ CategoryTheory.IsFilteredOrEmpty D","decl":"/-- Final functors preserve filteredness.\n\nThis can be seen as a generalization of `IsFiltered.of_right_adjoint` (which states that right\nadjoints preserve filteredness), as right adjoints are always final, see `final_of_adjunction`.\n-/\ntheorem IsFilteredOrEmpty.of_final (F : C ⥤ D) [Final F] [IsFilteredOrEmpty C] :\n    IsFilteredOrEmpty D where\n  cocone_objs X Y := ⟨F.obj (IsFiltered.max (Final.lift F X) (Final.lift F Y)),\n    Final.homToLift F X ≫ F.map (IsFiltered.leftToMax _ _),\n    ⟨Final.homToLift F Y ≫ F.map (IsFiltered.rightToMax _ _), trivial⟩⟩\n  cocone_maps {X Y} f g := by\n    let P : StructuredArrow X F → Prop := fun h => ∃ (Z : C) (q₁ : h.right ⟶ Z)\n      (q₂ : Final.lift F Y ⟶ Z), h.hom ≫ F.map q₁ = f ≫ Final.homToLift F Y ≫ F.map q₂\n    rsuffices ⟨Z, q₁, q₂, h⟩ : Nonempty (P (StructuredArrow.mk (g ≫ Final.homToLift F Y)))\n    · refine ⟨F.obj (IsFiltered.coeq q₁ q₂),\n        Final.homToLift F Y ≫ F.map (q₁ ≫ IsFiltered.coeqHom q₁ q₂), ?_⟩\n      conv_lhs => rw [IsFiltered.coeq_condition]\n      simp only [F.map_comp, ← reassoc_of% h, StructuredArrow.mk_hom_eq_self, Category.assoc]\n    have h₀ : P (StructuredArrow.mk (f ≫ Final.homToLift F Y)) := ⟨_, 𝟙 _, 𝟙 _, by simp⟩\n    refine isPreconnected_induction P ?_ ?_ h₀ _\n    · rintro U V h ⟨Z, q₁, q₂, hq⟩\n      obtain ⟨W, q₃, q₄, hq'⟩ := IsFiltered.span q₁ h.right\n      refine ⟨W, q₄, q₂ ≫ q₃, ?_⟩\n      rw [F.map_comp, ← reassoc_of% hq, ← F.map_comp, hq', F.map_comp, StructuredArrow.w_assoc]\n    · rintro U V h ⟨Z, q₁, q₂, hq⟩\n      exact ⟨Z, h.right ≫ q₁, q₂, by simp only [F.map_comp, StructuredArrow.w_assoc, hq]⟩\n\n"}
{"name":"CategoryTheory.IsFiltered.of_final","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.Final\ninst✝ : CategoryTheory.IsFiltered C\n⊢ CategoryTheory.IsFiltered D","decl":"/-- Final functors preserve filteredness.\n\nThis can be seen as a generalization of `IsFiltered.of_right_adjoint` (which states that right\nadjoints preserve filteredness), as right adjoints are always final, see `final_of_adjunction`.\n-/\ntheorem IsFiltered.of_final (F : C ⥤ D) [Final F] [IsFiltered C] : IsFiltered D :=\n{ IsFilteredOrEmpty.of_final F with\n  nonempty := Nonempty.map F.obj IsFiltered.nonempty }\n\n"}
{"name":"CategoryTheory.IsCofilteredOrEmpty.of_initial","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.Initial\ninst✝ : CategoryTheory.IsCofilteredOrEmpty C\n⊢ CategoryTheory.IsCofilteredOrEmpty D","decl":"/-- Initial functors preserve cofilteredness.\n\nThis can be seen as a generalization of `IsCofiltered.of_left_adjoint` (which states that left\nadjoints preserve cofilteredness), as right adjoints are always initial,\nsee `initial_of_adjunction`.\n-/\ntheorem IsCofilteredOrEmpty.of_initial (F : C ⥤ D) [Initial F] [IsCofilteredOrEmpty C] :\n    IsCofilteredOrEmpty D :=\n  have : IsFilteredOrEmpty Dᵒᵖ := IsFilteredOrEmpty.of_final F.op\n  isCofilteredOrEmpty_of_isFilteredOrEmpty_op _\n\n"}
{"name":"CategoryTheory.IsCofiltered.of_initial","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.Initial\ninst✝ : CategoryTheory.IsCofiltered C\n⊢ CategoryTheory.IsCofiltered D","decl":"/-- Initial functors preserve cofilteredness.\n\nThis can be seen as a generalization of `IsCofiltered.of_left_adjoint` (which states that left\nadjoints preserve cofilteredness), as right adjoints are always initial,\nsee `initial_of_adjunction`.\n-/\ntheorem IsCofiltered.of_initial (F : C ⥤ D) [Initial F] [IsCofiltered C] : IsCofiltered D :=\n  have : IsFiltered Dᵒᵖ := IsFiltered.of_final F.op\n  isCofiltered_of_isFiltered_op _\n\n"}
{"name":"CategoryTheory.StructuredArrow.final_pre","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} E\nT : CategoryTheory.Functor C D\ninst✝ : T.Final\nS : CategoryTheory.Functor D E\nX : E\n⊢ (CategoryTheory.StructuredArrow.pre X T S).Final","decl":"/-- The functor `StructuredArrow.pre X T S` is final if `T` is final. -/\ninstance StructuredArrow.final_pre (T : C ⥤ D) [Final T] (S : D ⥤ E) (X : E) :\n    Final (pre X T S) := by\n  refine ⟨fun f => ?_⟩\n  rw [isConnected_iff_of_equivalence (StructuredArrow.preEquivalence T f)]\n  exact Final.out f.right\n\n"}
{"name":"CategoryTheory.CostructuredArrow.initial_pre","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} E\nT : CategoryTheory.Functor C D\ninst✝ : T.Initial\nS : CategoryTheory.Functor D E\nX : E\n⊢ (CategoryTheory.CostructuredArrow.pre T S X).Initial","decl":"/-- The functor `CostructuredArrow.pre X T S` is initial if `T` is initial. -/\ninstance CostructuredArrow.initial_pre (T : C ⥤ D) [Initial T] (S : D ⥤ E) (X : E) :\n    Initial (CostructuredArrow.pre T S X) := by\n  refine ⟨fun f => ?_⟩\n  rw [isConnected_iff_of_equivalence (CostructuredArrow.preEquivalence T f)]\n  exact Initial.out f.left\n\n"}
{"name":"CategoryTheory.Grothendieck.final_pre","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor D CategoryTheory.Cat\nG : CategoryTheory.Functor C D\nhG : G.Final\n⊢ (CategoryTheory.Grothendieck.pre F G).Final","decl":"instance Grothendieck.final_pre [hG : Final G] : (Grothendieck.pre F G).Final := by\n  constructor\n  rintro ⟨d, f⟩\n  let ⟨u, c, g⟩ : Nonempty (StructuredArrow d G) := inferInstance\n  letI :  Nonempty (StructuredArrow ⟨d, f⟩ (pre F G)) :=\n    ⟨u, ⟨c, (F.map g).obj f⟩, ⟨(by exact g), (by exact 𝟙 _)⟩⟩\n  apply zigzag_isConnected\n  rintro ⟨⟨⟨⟩⟩, ⟨bi, fi⟩, ⟨gbi, gfi⟩⟩ ⟨⟨⟨⟩⟩, ⟨bj, fj⟩, ⟨gbj, gfj⟩⟩\n  dsimp at fj fi gfi gbi gbj gfj\n  apply Zigzag.trans (j₂ := StructuredArrow.mk (Y := ⟨bi, ((F.map gbi).obj f)⟩)\n      (Grothendieck.Hom.mk gbi (𝟙 _)))\n    (.of_zag (.inr ⟨StructuredArrow.homMk (Grothendieck.Hom.mk (by dsimp; exact 𝟙 _)\n      (eqToHom (by simp) ≫ gfi)) (by apply Grothendieck.ext <;> simp)⟩))\n  refine Zigzag.trans (j₂ := StructuredArrow.mk (Y := ⟨bj, ((F.map gbj).obj f)⟩)\n      (Grothendieck.Hom.mk gbj (𝟙 _))) ?_\n    (.of_zag (.inl ⟨StructuredArrow.homMk (Grothendieck.Hom.mk (by dsimp; exact 𝟙 _)\n      (eqToHom (by simp) ≫ gfj)) (by apply Grothendieck.ext <;> simp)⟩))\n  exact zigzag_prefunctor_obj_of_zigzag (Grothendieck.structuredArrowToStructuredArrowPre F G d f)\n    (isPreconnected_zigzag (.mk gbi) (.mk gbj))\n\n"}
{"name":"CategoryTheory.instFinalProdProd","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\nC' : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} C'\nD' : Type u₄\ninst✝² : CategoryTheory.Category.{v₄, u₄} D'\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor C' D'\ninst✝¹ : F.Final\ninst✝ : G.Final\n⊢ (F.prod G).Final","decl":"instance [F.Final] [G.Final] : (F.prod G).Final where\n  out := fun ⟨d, d'⟩ => isConnected_of_equivalent (StructuredArrow.prodEquivalence d d' F G).symm\n\n"}
