{"name":"CategoryTheory.Functor.Final.out","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\nself : F.Final\nd : D\nâŠ¢ CategoryTheory.IsConnected (CategoryTheory.StructuredArrow d F)","decl":"/--\nA functor `F : C â¥¤ D` is final if for every `d : D`, the comma category of morphisms `d âŸ¶ F.obj c`\nis connected. -/\n@[stacks 04E6]\nclass Final (F : C â¥¤ D) : Prop where\n  out (d : D) : IsConnected (StructuredArrow d F)\n\n"}
{"name":"CategoryTheory.Functor.Initial.out","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\nself : F.Initial\nd : D\nâŠ¢ CategoryTheory.IsConnected (CategoryTheory.CostructuredArrow F d)","decl":"/-- A functor `F : C â¥¤ D` is initial if for every `d : D`, the comma category of morphisms\n`F.obj c âŸ¶ d` is connected.\n-/\nclass Initial (F : C â¥¤ D) : Prop where\n  out (d : D) : IsConnected (CostructuredArrow F d)\n\n"}
{"name":"CategoryTheory.Functor.final_op_of_initial","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœ : F.Initial\nâŠ¢ F.op.Final","decl":"instance final_op_of_initial (F : C â¥¤ D) [Initial F] : Final F.op where\n  out d := isConnected_of_equivalent (costructuredArrowOpEquivalence F (unop d))\n\n"}
{"name":"CategoryTheory.Functor.initial_op_of_final","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœ : F.Final\nâŠ¢ F.op.Initial","decl":"instance initial_op_of_final (F : C â¥¤ D) [Final F] : Initial F.op where\n  out d := isConnected_of_equivalent (structuredArrowOpEquivalence F (unop d))\n\n"}
{"name":"CategoryTheory.Functor.final_of_initial_op","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœ : F.op.Initial\nâŠ¢ F.Final","decl":"theorem final_of_initial_op (F : C â¥¤ D) [Initial F.op] : Final F :=\n  {\n    out := fun d =>\n      @isConnected_of_isConnected_op _ _\n        (isConnected_of_equivalent (structuredArrowOpEquivalence F d).symm) }\n\n"}
{"name":"CategoryTheory.Functor.initial_of_final_op","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœ : F.op.Final\nâŠ¢ F.Initial","decl":"theorem initial_of_final_op (F : C â¥¤ D) [Final F.op] : Initial F :=\n  {\n    out := fun d =>\n      @isConnected_of_isConnected_op _ _\n        (isConnected_of_equivalent (costructuredArrowOpEquivalence F d).symm) }\n\n"}
{"name":"CategoryTheory.Functor.final_of_adjunction","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction L R\nâŠ¢ R.Final","decl":"/-- If a functor `R : D â¥¤ C` is a right adjoint, it is final. -/\ntheorem final_of_adjunction {L : C â¥¤ D} {R : D â¥¤ C} (adj : L âŠ£ R) : Final R :=\n  { out := fun c =>\n      let u : StructuredArrow c R := StructuredArrow.mk (adj.unit.app c)\n      @zigzag_isConnected _ _ âŸ¨uâŸ© fun f g =>\n        Relation.ReflTransGen.trans\n          (Relation.ReflTransGen.single\n            (show Zag f u from\n              Or.inr âŸ¨StructuredArrow.homMk ((adj.homEquiv c f.right).symm f.hom) (by simp [u])âŸ©))\n          (Relation.ReflTransGen.single\n            (show Zag u g from\n              Or.inl âŸ¨StructuredArrow.homMk ((adj.homEquiv c g.right).symm g.hom) (by simp [u])âŸ©)) }\n\n"}
{"name":"CategoryTheory.Functor.initial_of_adjunction","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction L R\nâŠ¢ L.Initial","decl":"/-- If a functor `L : C â¥¤ D` is a left adjoint, it is initial. -/\ntheorem initial_of_adjunction {L : C â¥¤ D} {R : D â¥¤ C} (adj : L âŠ£ R) : Initial L :=\n  { out := fun d =>\n      let u : CostructuredArrow L d := CostructuredArrow.mk (adj.counit.app d)\n      @zigzag_isConnected _ _ âŸ¨uâŸ© fun f g =>\n        Relation.ReflTransGen.trans\n          (Relation.ReflTransGen.single\n            (show Zag f u from\n              Or.inl âŸ¨CostructuredArrow.homMk (adj.homEquiv f.left d f.hom) (by simp [u])âŸ©))\n          (Relation.ReflTransGen.single\n            (show Zag u g from\n              Or.inr âŸ¨CostructuredArrow.homMk (adj.homEquiv g.left d g.hom) (by simp [u])âŸ©)) }\n\n"}
{"name":"CategoryTheory.Functor.final_of_isRightAdjoint","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœ : F.IsRightAdjoint\nâŠ¢ F.Final","decl":"instance (priority := 100) final_of_isRightAdjoint (F : C â¥¤ D) [IsRightAdjoint F] : Final F :=\n  final_of_adjunction (Adjunction.ofIsRightAdjoint F)\n\n"}
{"name":"CategoryTheory.Functor.initial_of_isLeftAdjoint","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœ : F.IsLeftAdjoint\nâŠ¢ F.Initial","decl":"instance (priority := 100) initial_of_isLeftAdjoint (F : C â¥¤ D) [IsLeftAdjoint F] : Initial F :=\n  initial_of_adjunction (Adjunction.ofIsLeftAdjoint F)\n\n"}
{"name":"CategoryTheory.Functor.final_of_natIso","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF F' : CategoryTheory.Functor C D\ninstâœ : F.Final\ni : CategoryTheory.Iso F F'\nâŠ¢ F'.Final","decl":"theorem final_of_natIso {F F' : C â¥¤ D} [Final F] (i : F â‰… F') : Final F' where\n  out _ := isConnected_of_equivalent (StructuredArrow.mapNatIso i)\n\n"}
{"name":"CategoryTheory.Functor.final_natIso_iff","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF F' : CategoryTheory.Functor C D\ni : CategoryTheory.Iso F F'\nâŠ¢ Iff F.Final F'.Final","decl":"theorem final_natIso_iff {F F' : C â¥¤ D} (i : F â‰… F') : Final F â†” Final F' :=\n  âŸ¨fun _ => final_of_natIso i, fun _ => final_of_natIso i.symmâŸ©\n\n"}
{"name":"CategoryTheory.Functor.initial_of_natIso","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF F' : CategoryTheory.Functor C D\ninstâœ : F.Initial\ni : CategoryTheory.Iso F F'\nâŠ¢ F'.Initial","decl":"theorem initial_of_natIso {F F' : C â¥¤ D} [Initial F] (i : F â‰… F') : Initial F' where\n  out _ := isConnected_of_equivalent (CostructuredArrow.mapNatIso i)\n\n"}
{"name":"CategoryTheory.Functor.initial_natIso_iff","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF F' : CategoryTheory.Functor C D\ni : CategoryTheory.Iso F F'\nâŠ¢ Iff F.Initial F'.Initial","decl":"theorem initial_natIso_iff {F F' : C â¥¤ D} (i : F â‰… F') : Initial F â†” Initial F' :=\n  âŸ¨fun _ => initial_of_natIso i, fun _ => initial_of_natIso i.symmâŸ©\n\n"}
{"name":"CategoryTheory.Functor.Final.instNonemptyStructuredArrow","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœ : F.Final\nd : D\nâŠ¢ Nonempty (CategoryTheory.StructuredArrow d F)","decl":"instance (d : D) : Nonempty (StructuredArrow d F) :=\n  IsConnected.is_nonempty\n\n"}
{"name":"CategoryTheory.Functor.Final.extendCocone_map_hom","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœÂ¹ : F.Final\nE : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nG : CategoryTheory.Functor D E\nXâœ Yâœ : CategoryTheory.Limits.Cocone (F.comp G)\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq (CategoryTheory.Functor.Final.extendCocone.map f).hom f.hom","decl":"/-- Given a cocone over `F â‹™ G`, we can construct a `Cocone G` with the same cocone point.\n-/\n@[simps]\ndef extendCocone : Cocone (F â‹™ G) â¥¤ Cocone G where\n  obj c :=\n    { pt := c.pt\n      Î¹ :=\n        { app := fun X => G.map (homToLift F X) â‰« c.Î¹.app (lift F X)\n          naturality := fun X Y f => by\n            dsimp; simp only [Category.comp_id]\n            -- This would be true if we'd chosen `lift F X` to be `lift F Y`\n            -- and `homToLift F X` to be `f â‰« homToLift F Y`.\n            apply\n              induction F fun Z k =>\n                G.map f â‰« G.map (homToLift F Y) â‰« c.Î¹.app (lift F Y) = G.map k â‰« c.Î¹.app Z\n            Â· intro Zâ‚ Zâ‚‚ kâ‚ kâ‚‚ g a z\n              rw [â† a, Functor.map_comp, Category.assoc, â† Functor.comp_map, c.w, z]\n            Â· intro Zâ‚ Zâ‚‚ kâ‚ kâ‚‚ g a z\n              rw [â† a, Functor.map_comp, Category.assoc, â† Functor.comp_map, c.w] at z\n              rw [z]\n            Â· rw [â† Functor.map_comp_assoc] } }\n  map f := { hom := f.hom }\n\n"}
{"name":"CategoryTheory.Functor.Final.extendCocone_obj_Î¹_app","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœÂ¹ : F.Final\nE : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nG : CategoryTheory.Functor D E\nc : CategoryTheory.Limits.Cocone (F.comp G)\nX : D\nâŠ¢ Eq ((CategoryTheory.Functor.Final.extendCocone.obj c).Î¹.app X) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Functor.Final.homToLift F X)) (c.Î¹.app (CategoryTheory.Functor.Final.lift F X)))","decl":"/-- Given a cocone over `F â‹™ G`, we can construct a `Cocone G` with the same cocone point.\n-/\n@[simps]\ndef extendCocone : Cocone (F â‹™ G) â¥¤ Cocone G where\n  obj c :=\n    { pt := c.pt\n      Î¹ :=\n        { app := fun X => G.map (homToLift F X) â‰« c.Î¹.app (lift F X)\n          naturality := fun X Y f => by\n            dsimp; simp only [Category.comp_id]\n            -- This would be true if we'd chosen `lift F X` to be `lift F Y`\n            -- and `homToLift F X` to be `f â‰« homToLift F Y`.\n            apply\n              induction F fun Z k =>\n                G.map f â‰« G.map (homToLift F Y) â‰« c.Î¹.app (lift F Y) = G.map k â‰« c.Î¹.app Z\n            Â· intro Zâ‚ Zâ‚‚ kâ‚ kâ‚‚ g a z\n              rw [â† a, Functor.map_comp, Category.assoc, â† Functor.comp_map, c.w, z]\n            Â· intro Zâ‚ Zâ‚‚ kâ‚ kâ‚‚ g a z\n              rw [â† a, Functor.map_comp, Category.assoc, â† Functor.comp_map, c.w] at z\n              rw [z]\n            Â· rw [â† Functor.map_comp_assoc] } }\n  map f := { hom := f.hom }\n\n"}
{"name":"CategoryTheory.Functor.Final.extendCocone_obj_pt","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœÂ¹ : F.Final\nE : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nG : CategoryTheory.Functor D E\nc : CategoryTheory.Limits.Cocone (F.comp G)\nâŠ¢ Eq (CategoryTheory.Functor.Final.extendCocone.obj c).pt c.pt","decl":"/-- Given a cocone over `F â‹™ G`, we can construct a `Cocone G` with the same cocone point.\n-/\n@[simps]\ndef extendCocone : Cocone (F â‹™ G) â¥¤ Cocone G where\n  obj c :=\n    { pt := c.pt\n      Î¹ :=\n        { app := fun X => G.map (homToLift F X) â‰« c.Î¹.app (lift F X)\n          naturality := fun X Y f => by\n            dsimp; simp only [Category.comp_id]\n            -- This would be true if we'd chosen `lift F X` to be `lift F Y`\n            -- and `homToLift F X` to be `f â‰« homToLift F Y`.\n            apply\n              induction F fun Z k =>\n                G.map f â‰« G.map (homToLift F Y) â‰« c.Î¹.app (lift F Y) = G.map k â‰« c.Î¹.app Z\n            Â· intro Zâ‚ Zâ‚‚ kâ‚ kâ‚‚ g a z\n              rw [â† a, Functor.map_comp, Category.assoc, â† Functor.comp_map, c.w, z]\n            Â· intro Zâ‚ Zâ‚‚ kâ‚ kâ‚‚ g a z\n              rw [â† a, Functor.map_comp, Category.assoc, â† Functor.comp_map, c.w] at z\n              rw [z]\n            Â· rw [â† Functor.map_comp_assoc] } }\n  map f := { hom := f.hom }\n\n"}
{"name":"CategoryTheory.Functor.Final.extendCocone_obj_Î¹_app'","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœÂ¹ : F.Final\nE : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nG : CategoryTheory.Functor D E\nc : CategoryTheory.Limits.Cocone (F.comp G)\nX : D\nY : C\nf : Quiver.Hom X (F.obj Y)\nâŠ¢ Eq ((CategoryTheory.Functor.Final.extendCocone.obj c).Î¹.app X) (CategoryTheory.CategoryStruct.comp (G.map f) (c.Î¹.app Y))","decl":"/-- Alternative equational lemma for `(extendCocone c).Î¹.app` in case a lift of the object\nis given explicitly. -/\nlemma extendCocone_obj_Î¹_app' (c : Cocone (F â‹™ G)) {X : D} {Y : C} (f : X âŸ¶ F.obj Y) :\n    (extendCocone.obj c).Î¹.app X = G.map f â‰« c.Î¹.app Y := by\n  apply induction (kâ‚€ := f) (z := rfl) F fun Z g =>\n    G.map g â‰« c.Î¹.app Z = G.map f â‰« c.Î¹.app Y\n  Â· intro _ _ _ _ _ hâ‚ hâ‚‚\n    simp [â† hâ‚, â† Functor.comp_map, c.Î¹.naturality, hâ‚‚]\n  Â· intro _ _ _ _ _ hâ‚ hâ‚‚\n    simp [â† hâ‚‚, â† hâ‚, â† Functor.comp_map, c.Î¹.naturality]\n\n"}
{"name":"CategoryTheory.Functor.Final.colimit_cocone_comp_aux","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœÂ¹ : F.Final\nE : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nG : CategoryTheory.Functor D E\ns : CategoryTheory.Limits.Cocone (F.comp G)\nj : C\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Functor.Final.homToLift F (F.obj j))) (s.Î¹.app (CategoryTheory.Functor.Final.lift F (F.obj j)))) (s.Î¹.app j)","decl":"@[simp]\ntheorem colimit_cocone_comp_aux (s : Cocone (F â‹™ G)) (j : C) :\n    G.map (homToLift F (F.obj j)) â‰« s.Î¹.app (lift F (F.obj j)) = s.Î¹.app j := by\n  -- This point is that this would be true if we took `lift (F.obj j)` to just be `j`\n  -- and `homToLift (F.obj j)` to be `ğŸ™ (F.obj j)`.\n  apply induction F fun X k => G.map k â‰« s.Î¹.app X = (s.Î¹.app j :)\n  Â· intro jâ‚ jâ‚‚ kâ‚ kâ‚‚ f w h\n    rw [â† w]\n    rw [â† s.w f] at h\n    simpa using h\n  Â· intro jâ‚ jâ‚‚ kâ‚ kâ‚‚ f w h\n    rw [â† w] at h\n    rw [â† s.w f]\n    simpa using h\n  Â· exact s.w (ğŸ™ _)\n\n"}
{"name":"CategoryTheory.Functor.Final.coconesEquiv_inverse","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœÂ¹ : F.Final\nE : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nG : CategoryTheory.Functor D E\nâŠ¢ Eq (CategoryTheory.Functor.Final.coconesEquiv F G).inverse (CategoryTheory.Limits.Cocones.whiskering F)","decl":"/-- If `F` is final,\nthe category of cocones on `F â‹™ G` is equivalent to the category of cocones on `G`,\nfor any `G : D â¥¤ E`.\n-/\n@[simps]\ndef coconesEquiv : Cocone (F â‹™ G) â‰Œ Cocone G where\n  functor := extendCocone\n  inverse := Cocones.whiskering F\n  unitIso := NatIso.ofComponents fun c => Cocones.ext (Iso.refl _)\n  counitIso := NatIso.ofComponents fun c => Cocones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Functor.Final.coconesEquiv_functor","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœÂ¹ : F.Final\nE : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nG : CategoryTheory.Functor D E\nâŠ¢ Eq (CategoryTheory.Functor.Final.coconesEquiv F G).functor CategoryTheory.Functor.Final.extendCocone","decl":"/-- If `F` is final,\nthe category of cocones on `F â‹™ G` is equivalent to the category of cocones on `G`,\nfor any `G : D â¥¤ E`.\n-/\n@[simps]\ndef coconesEquiv : Cocone (F â‹™ G) â‰Œ Cocone G where\n  functor := extendCocone\n  inverse := Cocones.whiskering F\n  unitIso := NatIso.ofComponents fun c => Cocones.ext (Iso.refl _)\n  counitIso := NatIso.ofComponents fun c => Cocones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Functor.Final.coconesEquiv_counitIso","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœÂ¹ : F.Final\nE : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nG : CategoryTheory.Functor D E\nâŠ¢ Eq (CategoryTheory.Functor.Final.coconesEquiv F G).counitIso (CategoryTheory.NatIso.ofComponents (fun c => CategoryTheory.Limits.Cocones.ext (CategoryTheory.Iso.refl (((CategoryTheory.Limits.Cocones.whiskering F).comp CategoryTheory.Functor.Final.extendCocone).obj c).pt) â‹¯) â‹¯)","decl":"/-- If `F` is final,\nthe category of cocones on `F â‹™ G` is equivalent to the category of cocones on `G`,\nfor any `G : D â¥¤ E`.\n-/\n@[simps]\ndef coconesEquiv : Cocone (F â‹™ G) â‰Œ Cocone G where\n  functor := extendCocone\n  inverse := Cocones.whiskering F\n  unitIso := NatIso.ofComponents fun c => Cocones.ext (Iso.refl _)\n  counitIso := NatIso.ofComponents fun c => Cocones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Functor.Final.coconesEquiv_unitIso","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœÂ¹ : F.Final\nE : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nG : CategoryTheory.Functor D E\nâŠ¢ Eq (CategoryTheory.Functor.Final.coconesEquiv F G).unitIso (CategoryTheory.NatIso.ofComponents (fun c => CategoryTheory.Limits.Cocones.ext (CategoryTheory.Iso.refl ((CategoryTheory.Functor.id (CategoryTheory.Limits.Cocone (F.comp G))).obj c).pt) â‹¯) â‹¯)","decl":"/-- If `F` is final,\nthe category of cocones on `F â‹™ G` is equivalent to the category of cocones on `G`,\nfor any `G : D â¥¤ E`.\n-/\n@[simps]\ndef coconesEquiv : Cocone (F â‹™ G) â‰Œ Cocone G where\n  functor := extendCocone\n  inverse := Cocones.whiskering F\n  unitIso := NatIso.ofComponents fun c => Cocones.ext (Iso.refl _)\n  counitIso := NatIso.ofComponents fun c => Cocones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Functor.Final.colimitCoconeComp_isColimit","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœÂ¹ : F.Final\nE : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nG : CategoryTheory.Functor D E\nt : CategoryTheory.Limits.ColimitCocone G\nâŠ¢ Eq (CategoryTheory.Functor.Final.colimitCoconeComp F t).isColimit ((CategoryTheory.Functor.Final.isColimitWhiskerEquiv F t.cocone).symm t.isColimit)","decl":"/-- Given a colimit cocone over `G : D â¥¤ E` we can construct a colimit cocone over `F â‹™ G`. -/\n@[simps]\ndef colimitCoconeComp (t : ColimitCocone G) : ColimitCocone (F â‹™ G) where\n  cocone := _\n  isColimit := (isColimitWhiskerEquiv F _).symm t.isColimit\n\n"}
{"name":"CategoryTheory.Functor.Final.colimitCoconeComp_cocone","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœÂ¹ : F.Final\nE : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nG : CategoryTheory.Functor D E\nt : CategoryTheory.Limits.ColimitCocone G\nâŠ¢ Eq (CategoryTheory.Functor.Final.colimitCoconeComp F t).cocone (CategoryTheory.Limits.Cocone.whisker F t.cocone)","decl":"/-- Given a colimit cocone over `G : D â¥¤ E` we can construct a colimit cocone over `F â‹™ G`. -/\n@[simps]\ndef colimitCoconeComp (t : ColimitCocone G) : ColimitCocone (F â‹™ G) where\n  cocone := _\n  isColimit := (isColimitWhiskerEquiv F _).symm t.isColimit\n\n"}
{"name":"CategoryTheory.Functor.Final.comp_hasColimit","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœÂ² : F.Final\nE : Type uâ‚ƒ\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nG : CategoryTheory.Functor D E\ninstâœ : CategoryTheory.Limits.HasColimit G\nâŠ¢ CategoryTheory.Limits.HasColimit (F.comp G)","decl":"instance (priority := 100) comp_hasColimit [HasColimit G] : HasColimit (F â‹™ G) :=\n  HasColimit.mk (colimitCoconeComp F (getColimitCocone G))\n\n"}
{"name":"CategoryTheory.Functor.Final.comp_preservesColimit","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\nE : Type uâ‚ƒ\ninstâœÂ² : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nG : CategoryTheory.Functor D E\nB : Type uâ‚„\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚„, uâ‚„} B\nH : CategoryTheory.Functor E B\ninstâœ : CategoryTheory.Limits.PreservesColimit G H\nâŠ¢ CategoryTheory.Limits.PreservesColimit (F.comp G) H","decl":"instance (priority := 100) comp_preservesColimit {B : Type uâ‚„} [Category.{vâ‚„} B] {H : E â¥¤ B}\n    [PreservesColimit G H] : PreservesColimit (F â‹™ G) H where\n  preserves {c} hc := by\n    refine âŸ¨isColimitExtendCoconeEquiv (G := G â‹™ H) F (H.mapCocone c) ?_âŸ©\n    let hc' := isColimitOfPreserves H ((isColimitExtendCoconeEquiv F c).symm hc)\n    exact IsColimit.ofIsoColimit hc' (Cocones.ext (Iso.refl _) (by simp))\n\n"}
{"name":"CategoryTheory.Functor.Final.comp_reflectsColimit","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\nE : Type uâ‚ƒ\ninstâœÂ² : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nG : CategoryTheory.Functor D E\nB : Type uâ‚„\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚„, uâ‚„} B\nH : CategoryTheory.Functor E B\ninstâœ : CategoryTheory.Limits.ReflectsColimit G H\nâŠ¢ CategoryTheory.Limits.ReflectsColimit (F.comp G) H","decl":"instance (priority := 100) comp_reflectsColimit {B : Type uâ‚„} [Category.{vâ‚„} B] {H : E â¥¤ B}\n    [ReflectsColimit G H] : ReflectsColimit (F â‹™ G) H where\n  reflects {c} hc := by\n    refine âŸ¨isColimitExtendCoconeEquiv F _ (isColimitOfReflects H ?_)âŸ©\n    let hc' := (isColimitExtendCoconeEquiv (G := G â‹™ H) F _).symm hc\n    exact IsColimit.ofIsoColimit hc' (Cocones.ext (Iso.refl _) (by simp))\n\n"}
{"name":"CategoryTheory.Functor.Final.colimit_pre_isIso","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœÂ² : F.Final\nE : Type uâ‚ƒ\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nG : CategoryTheory.Functor D E\ninstâœ : CategoryTheory.Limits.HasColimit G\nâŠ¢ CategoryTheory.IsIso (CategoryTheory.Limits.colimit.pre G F)","decl":"instance colimit_pre_isIso [HasColimit G] : IsIso (colimit.pre G F) := by\n  rw [colimit.pre_eq (colimitCoconeComp F (getColimitCocone G)) (getColimitCocone G)]\n  erw [IsColimit.desc_self]\n  dsimp\n  infer_instance\n\n"}
{"name":"CategoryTheory.Functor.Final.colimitIso_hom","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœÂ² : F.Final\nE : Type uâ‚ƒ\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nG : CategoryTheory.Functor D E\ninstâœ : CategoryTheory.Limits.HasColimit G\nâŠ¢ Eq (CategoryTheory.Functor.Final.colimitIso F G).hom (CategoryTheory.Limits.colimit.pre G F)","decl":"/-- When `F : C â¥¤ D` is final, and `G : D â¥¤ E` has a colimit, then `F â‹™ G` has a colimit also and\n`colimit (F â‹™ G) â‰… colimit G`. -/\n@[simps! (config := .lemmasOnly), stacks 04E7]\ndef colimitIso [HasColimit G] : colimit (F â‹™ G) â‰… colimit G :=\n  asIso (colimit.pre G F)\n\n"}
{"name":"CategoryTheory.Functor.Final.colimitIso_inv","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœÂ² : F.Final\nE : Type uâ‚ƒ\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nG : CategoryTheory.Functor D E\ninstâœ : CategoryTheory.Limits.HasColimit G\nâŠ¢ Eq (CategoryTheory.Functor.Final.colimitIso F G).inv (CategoryTheory.inv (CategoryTheory.Limits.colimit.pre G F))","decl":"/-- When `F : C â¥¤ D` is final, and `G : D â¥¤ E` has a colimit, then `F â‹™ G` has a colimit also and\n`colimit (F â‹™ G) â‰… colimit G`. -/\n@[simps! (config := .lemmasOnly), stacks 04E7]\ndef colimitIso [HasColimit G] : colimit (F â‹™ G) â‰… colimit G :=\n  asIso (colimit.pre G F)\n\n"}
{"name":"CategoryTheory.Functor.Final.Î¹_colimitIso_hom","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœÂ² : F.Final\nE : Type uâ‚ƒ\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nG : CategoryTheory.Functor D E\ninstâœ : CategoryTheory.Limits.HasColimit G\nX : C\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ (F.comp G) X) (CategoryTheory.Functor.Final.colimitIso F G).hom) (CategoryTheory.Limits.colimit.Î¹ G (F.obj X))","decl":"@[reassoc (attr := simp)]\ntheorem Î¹_colimitIso_hom [HasColimit G] (X : C) :\n    colimit.Î¹ (F â‹™ G) X â‰« (colimitIso F G).hom = colimit.Î¹ G (F.obj X) := by\n  simp [colimitIso]\n\n"}
{"name":"CategoryTheory.Functor.Final.Î¹_colimitIso_hom_assoc","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœÂ² : F.Final\nE : Type uâ‚ƒ\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nG : CategoryTheory.Functor D E\ninstâœ : CategoryTheory.Limits.HasColimit G\nX : C\nZ : E\nh : Quiver.Hom (CategoryTheory.Limits.colimit G) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ (F.comp G) X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.Final.colimitIso F G).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ G (F.obj X)) h)","decl":"@[reassoc (attr := simp)]\ntheorem Î¹_colimitIso_hom [HasColimit G] (X : C) :\n    colimit.Î¹ (F â‹™ G) X â‰« (colimitIso F G).hom = colimit.Î¹ G (F.obj X) := by\n  simp [colimitIso]\n\n"}
{"name":"CategoryTheory.Functor.Final.Î¹_colimitIso_inv","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœÂ² : F.Final\nE : Type uâ‚ƒ\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nG : CategoryTheory.Functor D E\ninstâœ : CategoryTheory.Limits.HasColimit G\nX : C\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ G (F.obj X)) (CategoryTheory.Functor.Final.colimitIso F G).inv) (CategoryTheory.Limits.colimit.Î¹ (F.comp G) X)","decl":"@[reassoc (attr := simp)]\ntheorem Î¹_colimitIso_inv [HasColimit G] (X : C) :\n    colimit.Î¹ G (F.obj X) â‰« (colimitIso F G).inv = colimit.Î¹ (F â‹™ G) X := by\n  simp [colimitIso]\n\n"}
{"name":"CategoryTheory.Functor.Final.Î¹_colimitIso_inv_assoc","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœÂ² : F.Final\nE : Type uâ‚ƒ\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nG : CategoryTheory.Functor D E\ninstâœ : CategoryTheory.Limits.HasColimit G\nX : C\nZ : E\nh : Quiver.Hom (CategoryTheory.Limits.colimit (F.comp G)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ G (F.obj X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.Final.colimitIso F G).inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ (F.comp G) X) h)","decl":"@[reassoc (attr := simp)]\ntheorem Î¹_colimitIso_inv [HasColimit G] (X : C) :\n    colimit.Î¹ G (F.obj X) â‰« (colimitIso F G).inv = colimit.Î¹ (F â‹™ G) X := by\n  simp [colimitIso]\n\n"}
{"name":"CategoryTheory.Functor.Final.colimitCoconeOfComp_isColimit","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœÂ¹ : F.Final\nE : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nG : CategoryTheory.Functor D E\nt : CategoryTheory.Limits.ColimitCocone (F.comp G)\nâŠ¢ Eq (CategoryTheory.Functor.Final.colimitCoconeOfComp F t).isColimit ((CategoryTheory.Functor.Final.isColimitExtendCoconeEquiv F t.cocone).symm t.isColimit)","decl":"/-- Given a colimit cocone over `F â‹™ G` we can construct a colimit cocone over `G`. -/\n@[simps]\ndef colimitCoconeOfComp (t : ColimitCocone (F â‹™ G)) : ColimitCocone G where\n  cocone := extendCocone.obj t.cocone\n  isColimit := (isColimitExtendCoconeEquiv F _).symm t.isColimit\n\n"}
{"name":"CategoryTheory.Functor.Final.colimitCoconeOfComp_cocone","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœÂ¹ : F.Final\nE : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nG : CategoryTheory.Functor D E\nt : CategoryTheory.Limits.ColimitCocone (F.comp G)\nâŠ¢ Eq (CategoryTheory.Functor.Final.colimitCoconeOfComp F t).cocone (CategoryTheory.Functor.Final.extendCocone.obj t.cocone)","decl":"/-- Given a colimit cocone over `F â‹™ G` we can construct a colimit cocone over `G`. -/\n@[simps]\ndef colimitCoconeOfComp (t : ColimitCocone (F â‹™ G)) : ColimitCocone G where\n  cocone := extendCocone.obj t.cocone\n  isColimit := (isColimitExtendCoconeEquiv F _).symm t.isColimit\n\n"}
{"name":"CategoryTheory.Functor.Final.hasColimit_of_comp","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœÂ² : F.Final\nE : Type uâ‚ƒ\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nG : CategoryTheory.Functor D E\ninstâœ : CategoryTheory.Limits.HasColimit (F.comp G)\nâŠ¢ CategoryTheory.Limits.HasColimit G","decl":"/-- When `F` is final, and `F â‹™ G` has a colimit, then `G` has a colimit also.\n\nWe can't make this an instance, because `F` is not determined by the goal.\n(Even if this weren't a problem, it would cause a loop with `comp_hasColimit`.)\n-/\ntheorem hasColimit_of_comp [HasColimit (F â‹™ G)] : HasColimit G :=\n  HasColimit.mk (colimitCoconeOfComp F (getColimitCocone (F â‹™ G)))\n\n"}
{"name":"CategoryTheory.Functor.Final.preservesColimit_of_comp","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœâµ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœÂ³ : F.Final\nE : Type uâ‚ƒ\ninstâœÂ² : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nG : CategoryTheory.Functor D E\nB : Type uâ‚„\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚„, uâ‚„} B\nH : CategoryTheory.Functor E B\ninstâœ : CategoryTheory.Limits.PreservesColimit (F.comp G) H\nâŠ¢ CategoryTheory.Limits.PreservesColimit G H","decl":"theorem preservesColimit_of_comp {B : Type uâ‚„} [Category.{vâ‚„} B] {H : E â¥¤ B}\n    [PreservesColimit (F â‹™ G) H] : PreservesColimit G H where\n  preserves {c} hc := by\n    refine âŸ¨isColimitWhiskerEquiv F _ ?_âŸ©\n    let hc' := isColimitOfPreserves H ((isColimitWhiskerEquiv F _).symm hc)\n    exact IsColimit.ofIsoColimit hc' (Cocones.ext (Iso.refl _) (by simp))\n\n"}
{"name":"CategoryTheory.Functor.Final.reflectsColimit_of_comp","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœâµ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœÂ³ : F.Final\nE : Type uâ‚ƒ\ninstâœÂ² : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nG : CategoryTheory.Functor D E\nB : Type uâ‚„\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚„, uâ‚„} B\nH : CategoryTheory.Functor E B\ninstâœ : CategoryTheory.Limits.ReflectsColimit (F.comp G) H\nâŠ¢ CategoryTheory.Limits.ReflectsColimit G H","decl":"theorem reflectsColimit_of_comp {B : Type uâ‚„} [Category.{vâ‚„} B] {H : E â¥¤ B}\n    [ReflectsColimit (F â‹™ G) H] : ReflectsColimit G H where\n  reflects {c} hc := by\n    refine âŸ¨isColimitWhiskerEquiv F _ (isColimitOfReflects H ?_)âŸ©\n    let hc' := (isColimitWhiskerEquiv F _).symm hc\n    exact IsColimit.ofIsoColimit hc' (Cocones.ext (Iso.refl _) (by simp))\n\n"}
{"name":"CategoryTheory.Functor.Final.hasColimitsOfShape_of_final","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœÂ² : F.Final\nE : Type uâ‚ƒ\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\ninstâœ : CategoryTheory.Limits.HasColimitsOfShape C E\nâŠ¢ CategoryTheory.Limits.HasColimitsOfShape D E","decl":"include F in\ntheorem hasColimitsOfShape_of_final [HasColimitsOfShape C E] : HasColimitsOfShape D E where\n  has_colimit := fun _ => hasColimit_of_comp F\n\n"}
{"name":"CategoryTheory.Functor.Final.preservesColimitsOfShape_of_final","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœâµ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœÂ³ : F.Final\nE : Type uâ‚ƒ\ninstâœÂ² : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nB : Type uâ‚„\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚„, uâ‚„} B\nH : CategoryTheory.Functor E B\ninstâœ : CategoryTheory.Limits.PreservesColimitsOfShape C H\nâŠ¢ CategoryTheory.Limits.PreservesColimitsOfShape D H","decl":"include F in\ntheorem preservesColimitsOfShape_of_final {B : Type uâ‚„} [Category.{vâ‚„} B] (H : E â¥¤ B)\n    [PreservesColimitsOfShape C H] : PreservesColimitsOfShape D H where\n  preservesColimit := preservesColimit_of_comp F\n\n"}
{"name":"CategoryTheory.Functor.Final.reflectsColimitsOfShape_of_final","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœâµ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœÂ³ : F.Final\nE : Type uâ‚ƒ\ninstâœÂ² : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nB : Type uâ‚„\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚„, uâ‚„} B\nH : CategoryTheory.Functor E B\ninstâœ : CategoryTheory.Limits.ReflectsColimitsOfShape C H\nâŠ¢ CategoryTheory.Limits.ReflectsColimitsOfShape D H","decl":"include F in\ntheorem reflectsColimitsOfShape_of_final {B : Type uâ‚„} [Category.{vâ‚„} B] (H : E â¥¤ B)\n    [ReflectsColimitsOfShape C H] : ReflectsColimitsOfShape D H where\n  reflectsColimit := reflectsColimit_of_comp F\n\n"}
{"name":"CategoryTheory.Functor.Final.zigzag_of_eqvGen_quot_rel","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type v\ninstâœÂ¹ : CategoryTheory.Category.{v, v} C\nD : Type uâ‚\ninstâœ : CategoryTheory.Category.{v, uâ‚} D\nF : CategoryTheory.Functor C D\nd : D\nfâ‚ fâ‚‚ : Sigma fun X => Quiver.Hom d (F.obj X)\nt : Relation.EqvGen (CategoryTheory.Limits.Types.Quot.Rel (F.comp (CategoryTheory.coyoneda.obj { unop := d }))) fâ‚ fâ‚‚\nâŠ¢ CategoryTheory.Zigzag (CategoryTheory.StructuredArrow.mk fâ‚.snd) (CategoryTheory.StructuredArrow.mk fâ‚‚.snd)","decl":"theorem zigzag_of_eqvGen_quot_rel {F : C â¥¤ D} {d : D} {fâ‚ fâ‚‚ : Î£X, d âŸ¶ F.obj X}\n    (t : Relation.EqvGen (Types.Quot.Rel.{v, v} (F â‹™ coyoneda.obj (op d))) fâ‚ fâ‚‚) :\n    Zigzag (StructuredArrow.mk fâ‚.2) (StructuredArrow.mk fâ‚‚.2) := by\n  induction t with\n  | rel x y r =>\n    obtain âŸ¨f, wâŸ© := r\n    fconstructor\n    swap\n    Â· fconstructor\n    left; fconstructor\n    exact StructuredArrow.homMk f\n  | refl => fconstructor\n  | symm x y _ ih =>\n    apply zigzag_symmetric\n    exact ih\n  | trans x y z _ _ ihâ‚ ihâ‚‚ =>\n    apply Relation.ReflTransGen.trans\n    Â· exact ihâ‚\n    Â· exact ihâ‚‚\n\n"}
{"name":"CategoryTheory.Functor.final_of_colimit_comp_coyoneda_iso_pUnit","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type v\ninstâœÂ¹ : CategoryTheory.Category.{v, v} C\nD : Type uâ‚\ninstâœ : CategoryTheory.Category.{v, uâ‚} D\nF : CategoryTheory.Functor C D\nI : (d : D) â†’ CategoryTheory.Iso (CategoryTheory.Limits.colimit (F.comp (CategoryTheory.coyoneda.obj { unop := d }))) PUnit.{v + 1}\nâŠ¢ F.Final","decl":"/-- If `colimit (F â‹™ coyoneda.obj (op d)) â‰… PUnit` for all `d : D`, then `F` is final.\n-/\ntheorem final_of_colimit_comp_coyoneda_iso_pUnit\n    (I : âˆ€ d, colimit (F â‹™ coyoneda.obj (op d)) â‰… PUnit) : Final F :=\n  âŸ¨fun d => by\n    have : Nonempty (StructuredArrow d F) := by\n      have := (I d).inv PUnit.unit\n      obtain âŸ¨j, y, rflâŸ© := Limits.Types.jointly_surjective'.{v, v} this\n      exact âŸ¨StructuredArrow.mk yâŸ©\n    apply zigzag_isConnected\n    rintro âŸ¨âŸ¨âŸ¨âŸ©âŸ©, Xâ‚, fâ‚âŸ© âŸ¨âŸ¨âŸ¨âŸ©âŸ©, Xâ‚‚, fâ‚‚âŸ©\n    let yâ‚ := colimit.Î¹ (F â‹™ coyoneda.obj (op d)) Xâ‚ fâ‚\n    let yâ‚‚ := colimit.Î¹ (F â‹™ coyoneda.obj (op d)) Xâ‚‚ fâ‚‚\n    have e : yâ‚ = yâ‚‚ := by\n      apply (I d).toEquiv.injective\n      ext\n    have t := Types.colimit_eq.{v, v} e\n    clear e yâ‚ yâ‚‚\n    exact Final.zigzag_of_eqvGen_quot_rel tâŸ©\n\n"}
{"name":"CategoryTheory.Functor.final_of_isTerminal_colimit_comp_yoneda","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type v\ninstâœÂ¹ : CategoryTheory.Category.{v, v} C\nD : Type uâ‚\ninstâœ : CategoryTheory.Category.{v, uâ‚} D\nF : CategoryTheory.Functor C D\nh : CategoryTheory.Limits.IsTerminal (CategoryTheory.Limits.colimit (F.comp CategoryTheory.yoneda))\nâŠ¢ F.Final","decl":"/-- A variant of `final_of_colimit_comp_coyoneda_iso_pUnit` where we bind the various claims\n    about `colimit (F â‹™ coyoneda.obj (Opposite.op d))` for each `d : D` into a single claim about\n    the presheaf `colimit (F â‹™ yoneda)`. -/\ntheorem final_of_isTerminal_colimit_comp_yoneda\n    (h : IsTerminal (colimit (F â‹™ yoneda))) : Final F := by\n  refine final_of_colimit_comp_coyoneda_iso_pUnit _ (fun d => ?_)\n  refine Types.isTerminalEquivIsoPUnit _ ?_\n  let b := IsTerminal.isTerminalObj ((evaluation _ _).obj (Opposite.op d)) _ h\n  exact b.ofIso <| preservesColimitIso ((evaluation _ _).obj (Opposite.op d)) (F â‹™ yoneda)\n\n"}
{"name":"CategoryTheory.Functor.final_iff_isIso_colimit_pre","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type v\ninstâœÂ¹ : CategoryTheory.Category.{v, v} C\nD : Type v\ninstâœ : CategoryTheory.Category.{v, v} D\nF : CategoryTheory.Functor C D\nâŠ¢ Iff F.Final (âˆ€ (G : CategoryTheory.Functor D (Type v)), CategoryTheory.IsIso (CategoryTheory.Limits.colimit.pre G F))","decl":"theorem final_iff_isIso_colimit_pre : Final F â†” âˆ€ G : D â¥¤ Type v, IsIso (colimit.pre G F) :=\n  âŸ¨fun _ => inferInstance,\n   fun _ => final_of_colimit_comp_coyoneda_iso_pUnit _ fun _ => Final.colimitCompCoyonedaIso _ _âŸ©\n\n"}
{"name":"CategoryTheory.Functor.Initial.instNonemptyCostructuredArrow","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœ : F.Initial\nd : D\nâŠ¢ Nonempty (CategoryTheory.CostructuredArrow F d)","decl":"instance (d : D) : Nonempty (CostructuredArrow F d) :=\n  IsConnected.is_nonempty\n\n"}
{"name":"CategoryTheory.Functor.Initial.extendCone_obj_pt","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœÂ¹ : F.Initial\nE : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nG : CategoryTheory.Functor D E\nc : CategoryTheory.Limits.Cone (F.comp G)\nâŠ¢ Eq (CategoryTheory.Functor.Initial.extendCone.obj c).pt c.pt","decl":"/-- Given a cone over `F â‹™ G`, we can construct a `Cone G` with the same cocone point.\n-/\n@[simps]\ndef extendCone : Cone (F â‹™ G) â¥¤ Cone G where\n  obj c :=\n    { pt := c.pt\n      Ï€ :=\n        { app := fun d => c.Ï€.app (lift F d) â‰« G.map (homToLift F d)\n          naturality := fun X Y f => by\n            dsimp; simp only [Category.id_comp, Category.assoc]\n            -- This would be true if we'd chosen `lift F Y` to be `lift F X`\n            -- and `homToLift F Y` to be `homToLift F X â‰« f`.\n            apply\n              induction F fun Z k =>\n                (c.Ï€.app Z â‰« G.map k : c.pt âŸ¶ _) =\n                  c.Ï€.app (lift F X) â‰« G.map (homToLift F X) â‰« G.map f\n            Â· intro Zâ‚ Zâ‚‚ kâ‚ kâ‚‚ g a z\n              rw [â† a, Functor.map_comp, â† Functor.comp_map, â† Category.assoc, â† Category.assoc,\n                c.w] at z\n              rw [z, Category.assoc]\n            Â· intro Zâ‚ Zâ‚‚ kâ‚ kâ‚‚ g a z\n              rw [â† a, Functor.map_comp, â† Functor.comp_map, â† Category.assoc, â† Category.assoc,\n                c.w, z, Category.assoc]\n            Â· rw [â† Functor.map_comp] } }\n  map f := { hom := f.hom }\n\n"}
{"name":"CategoryTheory.Functor.Initial.extendCone_map_hom","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœÂ¹ : F.Initial\nE : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nG : CategoryTheory.Functor D E\nXâœ Yâœ : CategoryTheory.Limits.Cone (F.comp G)\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq (CategoryTheory.Functor.Initial.extendCone.map f).hom f.hom","decl":"/-- Given a cone over `F â‹™ G`, we can construct a `Cone G` with the same cocone point.\n-/\n@[simps]\ndef extendCone : Cone (F â‹™ G) â¥¤ Cone G where\n  obj c :=\n    { pt := c.pt\n      Ï€ :=\n        { app := fun d => c.Ï€.app (lift F d) â‰« G.map (homToLift F d)\n          naturality := fun X Y f => by\n            dsimp; simp only [Category.id_comp, Category.assoc]\n            -- This would be true if we'd chosen `lift F Y` to be `lift F X`\n            -- and `homToLift F Y` to be `homToLift F X â‰« f`.\n            apply\n              induction F fun Z k =>\n                (c.Ï€.app Z â‰« G.map k : c.pt âŸ¶ _) =\n                  c.Ï€.app (lift F X) â‰« G.map (homToLift F X) â‰« G.map f\n            Â· intro Zâ‚ Zâ‚‚ kâ‚ kâ‚‚ g a z\n              rw [â† a, Functor.map_comp, â† Functor.comp_map, â† Category.assoc, â† Category.assoc,\n                c.w] at z\n              rw [z, Category.assoc]\n            Â· intro Zâ‚ Zâ‚‚ kâ‚ kâ‚‚ g a z\n              rw [â† a, Functor.map_comp, â† Functor.comp_map, â† Category.assoc, â† Category.assoc,\n                c.w, z, Category.assoc]\n            Â· rw [â† Functor.map_comp] } }\n  map f := { hom := f.hom }\n\n"}
{"name":"CategoryTheory.Functor.Initial.extendCone_obj_Ï€_app","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœÂ¹ : F.Initial\nE : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nG : CategoryTheory.Functor D E\nc : CategoryTheory.Limits.Cone (F.comp G)\nd : D\nâŠ¢ Eq ((CategoryTheory.Functor.Initial.extendCone.obj c).Ï€.app d) (CategoryTheory.CategoryStruct.comp (c.Ï€.app (CategoryTheory.Functor.Initial.lift F d)) (G.map (CategoryTheory.Functor.Initial.homToLift F d)))","decl":"/-- Given a cone over `F â‹™ G`, we can construct a `Cone G` with the same cocone point.\n-/\n@[simps]\ndef extendCone : Cone (F â‹™ G) â¥¤ Cone G where\n  obj c :=\n    { pt := c.pt\n      Ï€ :=\n        { app := fun d => c.Ï€.app (lift F d) â‰« G.map (homToLift F d)\n          naturality := fun X Y f => by\n            dsimp; simp only [Category.id_comp, Category.assoc]\n            -- This would be true if we'd chosen `lift F Y` to be `lift F X`\n            -- and `homToLift F Y` to be `homToLift F X â‰« f`.\n            apply\n              induction F fun Z k =>\n                (c.Ï€.app Z â‰« G.map k : c.pt âŸ¶ _) =\n                  c.Ï€.app (lift F X) â‰« G.map (homToLift F X) â‰« G.map f\n            Â· intro Zâ‚ Zâ‚‚ kâ‚ kâ‚‚ g a z\n              rw [â† a, Functor.map_comp, â† Functor.comp_map, â† Category.assoc, â† Category.assoc,\n                c.w] at z\n              rw [z, Category.assoc]\n            Â· intro Zâ‚ Zâ‚‚ kâ‚ kâ‚‚ g a z\n              rw [â† a, Functor.map_comp, â† Functor.comp_map, â† Category.assoc, â† Category.assoc,\n                c.w, z, Category.assoc]\n            Â· rw [â† Functor.map_comp] } }\n  map f := { hom := f.hom }\n\n"}
{"name":"CategoryTheory.Functor.Initial.extendCone_obj_Ï€_app'","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœÂ¹ : F.Initial\nE : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nG : CategoryTheory.Functor D E\nc : CategoryTheory.Limits.Cone (F.comp G)\nX : C\nY : D\nf : Quiver.Hom (F.obj X) Y\nâŠ¢ Eq ((CategoryTheory.Functor.Initial.extendCone.obj c).Ï€.app Y) (CategoryTheory.CategoryStruct.comp (c.Ï€.app X) (G.map f))","decl":"/-- Alternative equational lemma for `(extendCone c).Ï€.app` in case a lift of the object\nis given explicitly. -/\nlemma extendCone_obj_Ï€_app' (c : Cone (F â‹™ G)) {X : C} {Y : D} (f : F.obj X âŸ¶ Y) :\n    (extendCone.obj c).Ï€.app Y = c.Ï€.app X â‰« G.map f := by\n  apply induction (kâ‚€ := f) (z := rfl) F fun Z g =>\n    c.Ï€.app Z â‰« G.map g = c.Ï€.app X â‰« G.map f\n  Â· intro _ _ _ _ _ hâ‚ hâ‚‚\n    simp [â† hâ‚‚, â† hâ‚, â† Functor.comp_map, c.Ï€.naturality]\n  Â· intro _ _ _ _ _ hâ‚ hâ‚‚\n    simp [â† hâ‚, â† Functor.comp_map, c.Ï€.naturality, hâ‚‚]\n\n"}
{"name":"CategoryTheory.Functor.Initial.limit_cone_comp_aux","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœÂ¹ : F.Initial\nE : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nG : CategoryTheory.Functor D E\ns : CategoryTheory.Limits.Cone (F.comp G)\nj : C\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (s.Ï€.app (CategoryTheory.Functor.Initial.lift F (F.obj j))) (G.map (CategoryTheory.Functor.Initial.homToLift F (F.obj j)))) (s.Ï€.app j)","decl":"@[simp]\ntheorem limit_cone_comp_aux (s : Cone (F â‹™ G)) (j : C) :\n    s.Ï€.app (lift F (F.obj j)) â‰« G.map (homToLift F (F.obj j)) = s.Ï€.app j := by\n  -- This point is that this would be true if we took `lift (F.obj j)` to just be `j`\n  -- and `homToLift (F.obj j)` to be `ğŸ™ (F.obj j)`.\n  apply induction F fun X k => s.Ï€.app X â‰« G.map k = (s.Ï€.app j :)\n  Â· intro jâ‚ jâ‚‚ kâ‚ kâ‚‚ f w h\n    rw [â† s.w f]\n    rw [â† w] at h\n    simpa using h\n  Â· intro jâ‚ jâ‚‚ kâ‚ kâ‚‚ f w h\n    rw [â† s.w f] at h\n    rw [â† w]\n    simpa using h\n  Â· exact s.w (ğŸ™ _)\n\n"}
{"name":"CategoryTheory.Functor.Initial.conesEquiv_inverse","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœÂ¹ : F.Initial\nE : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nG : CategoryTheory.Functor D E\nâŠ¢ Eq (CategoryTheory.Functor.Initial.conesEquiv F G).inverse (CategoryTheory.Limits.Cones.whiskering F)","decl":"/-- If `F` is initial,\nthe category of cones on `F â‹™ G` is equivalent to the category of cones on `G`,\nfor any `G : D â¥¤ E`.\n-/\n@[simps]\ndef conesEquiv : Cone (F â‹™ G) â‰Œ Cone G where\n  functor := extendCone\n  inverse := Cones.whiskering F\n  unitIso := NatIso.ofComponents fun c => Cones.ext (Iso.refl _)\n  counitIso := NatIso.ofComponents fun c => Cones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Functor.Initial.conesEquiv_counitIso","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœÂ¹ : F.Initial\nE : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nG : CategoryTheory.Functor D E\nâŠ¢ Eq (CategoryTheory.Functor.Initial.conesEquiv F G).counitIso (CategoryTheory.NatIso.ofComponents (fun c => CategoryTheory.Limits.Cones.ext (CategoryTheory.Iso.refl (((CategoryTheory.Limits.Cones.whiskering F).comp CategoryTheory.Functor.Initial.extendCone).obj c).pt) â‹¯) â‹¯)","decl":"/-- If `F` is initial,\nthe category of cones on `F â‹™ G` is equivalent to the category of cones on `G`,\nfor any `G : D â¥¤ E`.\n-/\n@[simps]\ndef conesEquiv : Cone (F â‹™ G) â‰Œ Cone G where\n  functor := extendCone\n  inverse := Cones.whiskering F\n  unitIso := NatIso.ofComponents fun c => Cones.ext (Iso.refl _)\n  counitIso := NatIso.ofComponents fun c => Cones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Functor.Initial.conesEquiv_unitIso","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœÂ¹ : F.Initial\nE : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nG : CategoryTheory.Functor D E\nâŠ¢ Eq (CategoryTheory.Functor.Initial.conesEquiv F G).unitIso (CategoryTheory.NatIso.ofComponents (fun c => CategoryTheory.Limits.Cones.ext (CategoryTheory.Iso.refl ((CategoryTheory.Functor.id (CategoryTheory.Limits.Cone (F.comp G))).obj c).pt) â‹¯) â‹¯)","decl":"/-- If `F` is initial,\nthe category of cones on `F â‹™ G` is equivalent to the category of cones on `G`,\nfor any `G : D â¥¤ E`.\n-/\n@[simps]\ndef conesEquiv : Cone (F â‹™ G) â‰Œ Cone G where\n  functor := extendCone\n  inverse := Cones.whiskering F\n  unitIso := NatIso.ofComponents fun c => Cones.ext (Iso.refl _)\n  counitIso := NatIso.ofComponents fun c => Cones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Functor.Initial.conesEquiv_functor","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœÂ¹ : F.Initial\nE : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nG : CategoryTheory.Functor D E\nâŠ¢ Eq (CategoryTheory.Functor.Initial.conesEquiv F G).functor CategoryTheory.Functor.Initial.extendCone","decl":"/-- If `F` is initial,\nthe category of cones on `F â‹™ G` is equivalent to the category of cones on `G`,\nfor any `G : D â¥¤ E`.\n-/\n@[simps]\ndef conesEquiv : Cone (F â‹™ G) â‰Œ Cone G where\n  functor := extendCone\n  inverse := Cones.whiskering F\n  unitIso := NatIso.ofComponents fun c => Cones.ext (Iso.refl _)\n  counitIso := NatIso.ofComponents fun c => Cones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Functor.Initial.limitConeComp_cone","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœÂ¹ : F.Initial\nE : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nG : CategoryTheory.Functor D E\nt : CategoryTheory.Limits.LimitCone G\nâŠ¢ Eq (CategoryTheory.Functor.Initial.limitConeComp F t).cone (CategoryTheory.Limits.Cone.whisker F t.cone)","decl":"/-- Given a limit cone over `G : D â¥¤ E` we can construct a limit cone over `F â‹™ G`. -/\n@[simps]\ndef limitConeComp (t : LimitCone G) : LimitCone (F â‹™ G) where\n  cone := _\n  isLimit := (isLimitWhiskerEquiv F _).symm t.isLimit\n\n"}
{"name":"CategoryTheory.Functor.Initial.limitConeComp_isLimit","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœÂ¹ : F.Initial\nE : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nG : CategoryTheory.Functor D E\nt : CategoryTheory.Limits.LimitCone G\nâŠ¢ Eq (CategoryTheory.Functor.Initial.limitConeComp F t).isLimit ((CategoryTheory.Functor.Initial.isLimitWhiskerEquiv F t.cone).symm t.isLimit)","decl":"/-- Given a limit cone over `G : D â¥¤ E` we can construct a limit cone over `F â‹™ G`. -/\n@[simps]\ndef limitConeComp (t : LimitCone G) : LimitCone (F â‹™ G) where\n  cone := _\n  isLimit := (isLimitWhiskerEquiv F _).symm t.isLimit\n\n"}
{"name":"CategoryTheory.Functor.Initial.comp_hasLimit","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœÂ² : F.Initial\nE : Type uâ‚ƒ\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nG : CategoryTheory.Functor D E\ninstâœ : CategoryTheory.Limits.HasLimit G\nâŠ¢ CategoryTheory.Limits.HasLimit (F.comp G)","decl":"instance (priority := 100) comp_hasLimit [HasLimit G] : HasLimit (F â‹™ G) :=\n  HasLimit.mk (limitConeComp F (getLimitCone G))\n\n"}
{"name":"CategoryTheory.Functor.Initial.comp_preservesLimit","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\nE : Type uâ‚ƒ\ninstâœÂ² : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nG : CategoryTheory.Functor D E\nB : Type uâ‚„\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚„, uâ‚„} B\nH : CategoryTheory.Functor E B\ninstâœ : CategoryTheory.Limits.PreservesLimit G H\nâŠ¢ CategoryTheory.Limits.PreservesLimit (F.comp G) H","decl":"instance (priority := 100) comp_preservesLimit {B : Type uâ‚„} [Category.{vâ‚„} B] {H : E â¥¤ B}\n    [PreservesLimit G H] : PreservesLimit (F â‹™ G) H where\n  preserves {c} hc := by\n    refine âŸ¨isLimitExtendConeEquiv (G := G â‹™ H) F (H.mapCone c) ?_âŸ©\n    let hc' := isLimitOfPreserves H ((isLimitExtendConeEquiv F c).symm hc)\n    exact IsLimit.ofIsoLimit hc' (Cones.ext (Iso.refl _) (by simp))\n\n"}
{"name":"CategoryTheory.Functor.Initial.comp_reflectsLimit","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\nE : Type uâ‚ƒ\ninstâœÂ² : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nG : CategoryTheory.Functor D E\nB : Type uâ‚„\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚„, uâ‚„} B\nH : CategoryTheory.Functor E B\ninstâœ : CategoryTheory.Limits.ReflectsLimit G H\nâŠ¢ CategoryTheory.Limits.ReflectsLimit (F.comp G) H","decl":"instance (priority := 100) comp_reflectsLimit {B : Type uâ‚„} [Category.{vâ‚„} B] {H : E â¥¤ B}\n    [ReflectsLimit G H] : ReflectsLimit (F â‹™ G) H where\n  reflects {c} hc := by\n    refine âŸ¨isLimitExtendConeEquiv F _ (isLimitOfReflects H ?_)âŸ©\n    let hc' := (isLimitExtendConeEquiv (G := G â‹™ H) F _).symm hc\n    exact IsLimit.ofIsoLimit hc' (Cones.ext (Iso.refl _) (by simp))\n\n"}
{"name":"CategoryTheory.Functor.Initial.limit_pre_isIso","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœÂ² : F.Initial\nE : Type uâ‚ƒ\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nG : CategoryTheory.Functor D E\ninstâœ : CategoryTheory.Limits.HasLimit G\nâŠ¢ CategoryTheory.IsIso (CategoryTheory.Limits.limit.pre G F)","decl":"instance limit_pre_isIso [HasLimit G] : IsIso (limit.pre G F) := by\n  rw [limit.pre_eq (limitConeComp F (getLimitCone G)) (getLimitCone G)]\n  erw [IsLimit.lift_self]\n  dsimp\n  infer_instance\n\n"}
{"name":"CategoryTheory.Functor.Initial.limitIso_inv","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœÂ² : F.Initial\nE : Type uâ‚ƒ\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nG : CategoryTheory.Functor D E\ninstâœ : CategoryTheory.Limits.HasLimit G\nâŠ¢ Eq (CategoryTheory.Functor.Initial.limitIso F G).inv (CategoryTheory.Limits.limit.pre G F)","decl":"/-- When `F : C â¥¤ D` is initial, and `G : D â¥¤ E` has a limit, then `F â‹™ G` has a limit also and\n`limit (F â‹™ G) â‰… limit G`. -/\n@[simps! (config := .lemmasOnly), stacks 04E7]\ndef limitIso [HasLimit G] : limit (F â‹™ G) â‰… limit G :=\n  (asIso (limit.pre G F)).symm\n\n"}
{"name":"CategoryTheory.Functor.Initial.limitIso_hom","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœÂ² : F.Initial\nE : Type uâ‚ƒ\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nG : CategoryTheory.Functor D E\ninstâœ : CategoryTheory.Limits.HasLimit G\nâŠ¢ Eq (CategoryTheory.Functor.Initial.limitIso F G).hom (CategoryTheory.inv (CategoryTheory.Limits.limit.pre G F))","decl":"/-- When `F : C â¥¤ D` is initial, and `G : D â¥¤ E` has a limit, then `F â‹™ G` has a limit also and\n`limit (F â‹™ G) â‰… limit G`. -/\n@[simps! (config := .lemmasOnly), stacks 04E7]\ndef limitIso [HasLimit G] : limit (F â‹™ G) â‰… limit G :=\n  (asIso (limit.pre G F)).symm\n\n"}
{"name":"CategoryTheory.Functor.Initial.limitConeOfComp_isLimit","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœÂ¹ : F.Initial\nE : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nG : CategoryTheory.Functor D E\nt : CategoryTheory.Limits.LimitCone (F.comp G)\nâŠ¢ Eq (CategoryTheory.Functor.Initial.limitConeOfComp F t).isLimit ((CategoryTheory.Functor.Initial.isLimitExtendConeEquiv F t.cone).symm t.isLimit)","decl":"/-- Given a limit cone over `F â‹™ G` we can construct a limit cone over `G`. -/\n@[simps]\ndef limitConeOfComp (t : LimitCone (F â‹™ G)) : LimitCone G where\n  cone := extendCone.obj t.cone\n  isLimit := (isLimitExtendConeEquiv F _).symm t.isLimit\n\n"}
{"name":"CategoryTheory.Functor.Initial.limitConeOfComp_cone","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœÂ¹ : F.Initial\nE : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nG : CategoryTheory.Functor D E\nt : CategoryTheory.Limits.LimitCone (F.comp G)\nâŠ¢ Eq (CategoryTheory.Functor.Initial.limitConeOfComp F t).cone (CategoryTheory.Functor.Initial.extendCone.obj t.cone)","decl":"/-- Given a limit cone over `F â‹™ G` we can construct a limit cone over `G`. -/\n@[simps]\ndef limitConeOfComp (t : LimitCone (F â‹™ G)) : LimitCone G where\n  cone := extendCone.obj t.cone\n  isLimit := (isLimitExtendConeEquiv F _).symm t.isLimit\n\n"}
{"name":"CategoryTheory.Functor.Initial.hasLimit_of_comp","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœÂ² : F.Initial\nE : Type uâ‚ƒ\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nG : CategoryTheory.Functor D E\ninstâœ : CategoryTheory.Limits.HasLimit (F.comp G)\nâŠ¢ CategoryTheory.Limits.HasLimit G","decl":"/-- When `F` is initial, and `F â‹™ G` has a limit, then `G` has a limit also.\n\nWe can't make this an instance, because `F` is not determined by the goal.\n(Even if this weren't a problem, it would cause a loop with `comp_hasLimit`.)\n-/\ntheorem hasLimit_of_comp [HasLimit (F â‹™ G)] : HasLimit G :=\n  HasLimit.mk (limitConeOfComp F (getLimitCone (F â‹™ G)))\n\n"}
{"name":"CategoryTheory.Functor.Initial.preservesLimit_of_comp","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœâµ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœÂ³ : F.Initial\nE : Type uâ‚ƒ\ninstâœÂ² : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nG : CategoryTheory.Functor D E\nB : Type uâ‚„\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚„, uâ‚„} B\nH : CategoryTheory.Functor E B\ninstâœ : CategoryTheory.Limits.PreservesLimit (F.comp G) H\nâŠ¢ CategoryTheory.Limits.PreservesLimit G H","decl":"theorem preservesLimit_of_comp {B : Type uâ‚„} [Category.{vâ‚„} B] {H : E â¥¤ B}\n    [PreservesLimit (F â‹™ G) H] : PreservesLimit G H where\n  preserves {c} hc := by\n    refine âŸ¨isLimitWhiskerEquiv F _ ?_âŸ©\n    let hc' := isLimitOfPreserves H ((isLimitWhiskerEquiv F _).symm hc)\n    exact IsLimit.ofIsoLimit hc' (Cones.ext (Iso.refl _) (by simp))\n\n"}
{"name":"CategoryTheory.Functor.Initial.reflectsLimit_of_comp","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœâµ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœÂ³ : F.Initial\nE : Type uâ‚ƒ\ninstâœÂ² : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nG : CategoryTheory.Functor D E\nB : Type uâ‚„\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚„, uâ‚„} B\nH : CategoryTheory.Functor E B\ninstâœ : CategoryTheory.Limits.ReflectsLimit (F.comp G) H\nâŠ¢ CategoryTheory.Limits.ReflectsLimit G H","decl":"theorem reflectsLimit_of_comp {B : Type uâ‚„} [Category.{vâ‚„} B] {H : E â¥¤ B}\n    [ReflectsLimit (F â‹™ G) H] : ReflectsLimit G H where\n  reflects {c} hc := by\n    refine âŸ¨isLimitWhiskerEquiv F _ (isLimitOfReflects H ?_)âŸ©\n    let hc' := (isLimitWhiskerEquiv F _).symm hc\n    exact IsLimit.ofIsoLimit hc' (Cones.ext (Iso.refl _) (by simp))\n\n"}
{"name":"CategoryTheory.Functor.Initial.hasLimitsOfShape_of_initial","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœÂ² : F.Initial\nE : Type uâ‚ƒ\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\ninstâœ : CategoryTheory.Limits.HasLimitsOfShape C E\nâŠ¢ CategoryTheory.Limits.HasLimitsOfShape D E","decl":"include F in\ntheorem hasLimitsOfShape_of_initial [HasLimitsOfShape C E] : HasLimitsOfShape D E where\n  has_limit := fun _ => hasLimit_of_comp F\n\n"}
{"name":"CategoryTheory.Functor.Initial.preservesLimitsOfShape_of_initial","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœâµ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœÂ³ : F.Initial\nE : Type uâ‚ƒ\ninstâœÂ² : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nB : Type uâ‚„\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚„, uâ‚„} B\nH : CategoryTheory.Functor E B\ninstâœ : CategoryTheory.Limits.PreservesLimitsOfShape C H\nâŠ¢ CategoryTheory.Limits.PreservesLimitsOfShape D H","decl":"include F in\ntheorem preservesLimitsOfShape_of_initial {B : Type uâ‚„} [Category.{vâ‚„} B] (H : E â¥¤ B)\n    [PreservesLimitsOfShape C H] : PreservesLimitsOfShape D H where\n  preservesLimit := preservesLimit_of_comp F\n\n"}
{"name":"CategoryTheory.Functor.Initial.reflectsLimitsOfShape_of_initial","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœâµ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœÂ³ : F.Initial\nE : Type uâ‚ƒ\ninstâœÂ² : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nB : Type uâ‚„\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚„, uâ‚„} B\nH : CategoryTheory.Functor E B\ninstâœ : CategoryTheory.Limits.ReflectsLimitsOfShape C H\nâŠ¢ CategoryTheory.Limits.ReflectsLimitsOfShape D H","decl":"include F in\ntheorem reflectsLimitsOfShape_of_initial {B : Type uâ‚„} [Category.{vâ‚„} B] (H : E â¥¤ B)\n    [ReflectsLimitsOfShape C H] : ReflectsLimitsOfShape D H where\n  reflectsLimit := reflectsLimit_of_comp F\n\n"}
{"name":"CategoryTheory.Functor.final_of_comp_full_faithful","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœâµ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nE : Type uâ‚ƒ\ninstâœÂ³ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninstâœÂ² : G.Full\ninstâœÂ¹ : G.Faithful\ninstâœ : (F.comp G).Final\nâŠ¢ F.Final","decl":"/-- The hypotheses also imply that `G` is final, see `final_of_comp_full_faithful'`. -/\ntheorem final_of_comp_full_faithful [Full G] [Faithful G] [Final (F â‹™ G)] : Final F where\n  out d := isConnected_of_equivalent (StructuredArrow.post d F G).asEquivalence.symm\n\n"}
{"name":"CategoryTheory.Functor.initial_of_comp_full_faithful","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœâµ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nE : Type uâ‚ƒ\ninstâœÂ³ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninstâœÂ² : G.Full\ninstâœÂ¹ : G.Faithful\ninstâœ : (F.comp G).Initial\nâŠ¢ F.Initial","decl":"/-- The hypotheses also imply that `G` is initial, see `initial_of_comp_full_faithful'`. -/\ntheorem initial_of_comp_full_faithful [Full G] [Faithful G] [Initial (F â‹™ G)] : Initial F where\n  out d := isConnected_of_equivalent (CostructuredArrow.post F G d).asEquivalence.symm\n\n"}
{"name":"CategoryTheory.Functor.final_comp_equivalence","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nE : Type uâ‚ƒ\ninstâœÂ² : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninstâœÂ¹ : F.Final\ninstâœ : G.IsEquivalence\nâŠ¢ (F.comp G).Final","decl":"/-- See also the strictly more general `final_comp` below. -/\ntheorem final_comp_equivalence [Final F] [IsEquivalence G] : Final (F â‹™ G) :=\n  let i : F â‰… (F â‹™ G) â‹™ G.inv := isoWhiskerLeft F G.asEquivalence.unitIso\n  have : Final ((F â‹™ G) â‹™ G.inv) := final_of_natIso i\n  final_of_comp_full_faithful (F â‹™ G) G.inv\n\n"}
{"name":"CategoryTheory.Functor.initial_comp_equivalence","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nE : Type uâ‚ƒ\ninstâœÂ² : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninstâœÂ¹ : F.Initial\ninstâœ : G.IsEquivalence\nâŠ¢ (F.comp G).Initial","decl":"/-- See also the strictly more general `initial_comp` below. -/\ntheorem initial_comp_equivalence [Initial F] [IsEquivalence G] : Initial (F â‹™ G) :=\n  let i : F â‰… (F â‹™ G) â‹™ G.inv := isoWhiskerLeft F G.asEquivalence.unitIso\n  have : Initial ((F â‹™ G) â‹™ G.inv) := initial_of_natIso i\n  initial_of_comp_full_faithful (F â‹™ G) G.inv\n\n"}
{"name":"CategoryTheory.Functor.final_equivalence_comp","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nE : Type uâ‚ƒ\ninstâœÂ² : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninstâœÂ¹ : F.IsEquivalence\ninstâœ : G.Final\nâŠ¢ (F.comp G).Final","decl":"/-- See also the strictly more general `final_comp` below. -/\ntheorem final_equivalence_comp [IsEquivalence F] [Final G] : Final (F â‹™ G) where\n  out d := isConnected_of_equivalent (StructuredArrow.pre d F G).asEquivalence.symm\n\n"}
{"name":"CategoryTheory.Functor.initial_equivalence_comp","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nE : Type uâ‚ƒ\ninstâœÂ² : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninstâœÂ¹ : F.IsEquivalence\ninstâœ : G.Initial\nâŠ¢ (F.comp G).Initial","decl":"/-- See also the strictly more general `initial_comp` below. -/\ntheorem initial_equivalence_comp [IsEquivalence F] [Initial G] : Initial (F â‹™ G) where\n  out d := isConnected_of_equivalent (CostructuredArrow.pre F G d).asEquivalence.symm\n\n"}
{"name":"CategoryTheory.Functor.final_of_equivalence_comp","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nE : Type uâ‚ƒ\ninstâœÂ² : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninstâœÂ¹ : F.IsEquivalence\ninstâœ : (F.comp G).Final\nâŠ¢ G.Final","decl":"/-- See also the strictly more general `final_of_final_comp` below. -/\ntheorem final_of_equivalence_comp [IsEquivalence F] [Final (F â‹™ G)] : Final G where\n  out d := isConnected_of_equivalent (StructuredArrow.pre d F G).asEquivalence\n\n"}
{"name":"CategoryTheory.Functor.initial_of_equivalence_comp","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nE : Type uâ‚ƒ\ninstâœÂ² : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninstâœÂ¹ : F.IsEquivalence\ninstâœ : (F.comp G).Initial\nâŠ¢ G.Initial","decl":"/-- See also the strictly more general `initial_of_initial_comp` below. -/\ntheorem initial_of_equivalence_comp [IsEquivalence F] [Initial (F â‹™ G)] : Initial G where\n  out d := isConnected_of_equivalent (CostructuredArrow.pre F G d).asEquivalence\n\n"}
{"name":"CategoryTheory.Functor.final_iff_comp_equivalence","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nE : Type uâ‚ƒ\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninstâœ : G.IsEquivalence\nâŠ¢ Iff F.Final (F.comp G).Final","decl":"/-- See also the strictly more general `final_iff_comp_final_full_faithful` below. -/\ntheorem final_iff_comp_equivalence [IsEquivalence G] : Final F â†” Final (F â‹™ G) :=\n  âŸ¨fun _ => final_comp_equivalence _ _, fun _ => final_of_comp_full_faithful _ GâŸ©\n\n"}
{"name":"CategoryTheory.Functor.final_iff_equivalence_comp","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nE : Type uâ‚ƒ\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninstâœ : F.IsEquivalence\nâŠ¢ Iff G.Final (F.comp G).Final","decl":"/-- See also the strictly more general `final_iff_final_comp` below. -/\ntheorem final_iff_equivalence_comp [IsEquivalence F] : Final G â†” Final (F â‹™ G) :=\n  âŸ¨fun _ => final_equivalence_comp _ _, fun _ => final_of_equivalence_comp F _âŸ©\n\n"}
{"name":"CategoryTheory.Functor.initial_iff_comp_equivalence","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nE : Type uâ‚ƒ\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninstâœ : G.IsEquivalence\nâŠ¢ Iff F.Initial (F.comp G).Initial","decl":"/-- See also the strictly more general `initial_iff_comp_initial_full_faithful` below. -/\ntheorem initial_iff_comp_equivalence [IsEquivalence G] : Initial F â†” Initial (F â‹™ G) :=\n  âŸ¨fun _ => initial_comp_equivalence _ _, fun _ => initial_of_comp_full_faithful _ GâŸ©\n\n"}
{"name":"CategoryTheory.Functor.initial_iff_equivalence_comp","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nE : Type uâ‚ƒ\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninstâœ : F.IsEquivalence\nâŠ¢ Iff G.Initial (F.comp G).Initial","decl":"/-- See also the strictly more general `initial_iff_initial_comp` below. -/\ntheorem initial_iff_equivalence_comp [IsEquivalence F] : Initial G â†” Initial (F â‹™ G) :=\n  âŸ¨fun _ => initial_equivalence_comp _ _, fun _ => initial_of_equivalence_comp F _âŸ©\n\n"}
{"name":"CategoryTheory.Functor.final_comp","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nE : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\nhF : F.Final\nhG : G.Final\nâŠ¢ (F.comp G).Final","decl":"instance final_comp [hF : Final F] [hG : Final G] : Final (F â‹™ G) := by\n  let sâ‚ : C â‰Œ AsSmall.{max uâ‚ vâ‚ uâ‚‚ vâ‚‚ uâ‚ƒ vâ‚ƒ} C := AsSmall.equiv\n  let sâ‚‚ : D â‰Œ AsSmall.{max uâ‚ vâ‚ uâ‚‚ vâ‚‚ uâ‚ƒ vâ‚ƒ} D := AsSmall.equiv\n  let sâ‚ƒ : E â‰Œ AsSmall.{max uâ‚ vâ‚ uâ‚‚ vâ‚‚ uâ‚ƒ vâ‚ƒ} E := AsSmall.equiv\n  let i : sâ‚.inverse â‹™ (F â‹™ G) â‹™ sâ‚ƒ.functor â‰…\n      (sâ‚.inverse â‹™ F â‹™ sâ‚‚.functor) â‹™ (sâ‚‚.inverse â‹™ G â‹™ sâ‚ƒ.functor) :=\n    isoWhiskerLeft (sâ‚.inverse â‹™ F) (isoWhiskerRight sâ‚‚.unitIso (G â‹™ sâ‚ƒ.functor))\n  rw [final_iff_comp_equivalence (F â‹™ G) sâ‚ƒ.functor, final_iff_equivalence_comp sâ‚.inverse,\n    final_natIso_iff i, final_iff_isIso_colimit_pre]\n  rw [final_iff_comp_equivalence F sâ‚‚.functor, final_iff_equivalence_comp sâ‚.inverse,\n    final_iff_isIso_colimit_pre] at hF\n  rw [final_iff_comp_equivalence G sâ‚ƒ.functor, final_iff_equivalence_comp sâ‚‚.inverse,\n    final_iff_isIso_colimit_pre] at hG\n  intro H\n  rw [â† colimit.pre_pre]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Functor.initial_comp","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nE : Type uâ‚ƒ\ninstâœÂ² : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninstâœÂ¹ : F.Initial\ninstâœ : G.Initial\nâŠ¢ (F.comp G).Initial","decl":"instance initial_comp [Initial F] [Initial G] : Initial (F â‹™ G) := by\n  suffices Final (F â‹™ G).op from initial_of_final_op _\n  exact final_comp F.op G.op\n\n"}
{"name":"CategoryTheory.Functor.final_of_final_comp","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nE : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\nhF : F.Final\nhFG : (F.comp G).Final\nâŠ¢ G.Final","decl":"theorem final_of_final_comp [hF : Final F] [hFG : Final (F â‹™ G)] : Final G := by\n  let sâ‚ : C â‰Œ AsSmall.{max uâ‚ vâ‚ uâ‚‚ vâ‚‚ uâ‚ƒ vâ‚ƒ} C := AsSmall.equiv\n  let sâ‚‚ : D â‰Œ AsSmall.{max uâ‚ vâ‚ uâ‚‚ vâ‚‚ uâ‚ƒ vâ‚ƒ} D := AsSmall.equiv\n  let sâ‚ƒ : E â‰Œ AsSmall.{max uâ‚ vâ‚ uâ‚‚ vâ‚‚ uâ‚ƒ vâ‚ƒ} E := AsSmall.equiv\n  let _i : sâ‚.inverse â‹™ (F â‹™ G) â‹™ sâ‚ƒ.functor â‰…\n      (sâ‚.inverse â‹™ F â‹™ sâ‚‚.functor) â‹™ (sâ‚‚.inverse â‹™ G â‹™ sâ‚ƒ.functor) :=\n    isoWhiskerLeft (sâ‚.inverse â‹™ F) (isoWhiskerRight sâ‚‚.unitIso (G â‹™ sâ‚ƒ.functor))\n  rw [final_iff_comp_equivalence G sâ‚ƒ.functor, final_iff_equivalence_comp sâ‚‚.inverse,\n    final_iff_isIso_colimit_pre]\n  rw [final_iff_comp_equivalence F sâ‚‚.functor, final_iff_equivalence_comp sâ‚.inverse,\n    final_iff_isIso_colimit_pre] at hF\n  rw [final_iff_comp_equivalence (F â‹™ G) sâ‚ƒ.functor, final_iff_equivalence_comp sâ‚.inverse,\n    final_natIso_iff _i, final_iff_isIso_colimit_pre] at hFG\n  intro H\n  replace hFG := hFG H\n  rw [â† colimit.pre_pre] at hFG\n  exact IsIso.of_isIso_comp_left (colimit.pre _ (sâ‚.inverse â‹™ F â‹™ sâ‚‚.functor)) _\n\n"}
{"name":"CategoryTheory.Functor.initial_of_initial_comp","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nE : Type uâ‚ƒ\ninstâœÂ² : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninstâœÂ¹ : F.Initial\ninstâœ : (F.comp G).Initial\nâŠ¢ G.Initial","decl":"theorem initial_of_initial_comp [Initial F] [Initial (F â‹™ G)] : Initial G := by\n  suffices Final G.op from initial_of_final_op _\n  have : Final (F.op â‹™ G.op) := show Final (F â‹™ G).op from inferInstance\n  exact final_of_final_comp F.op G.op\n\n"}
{"name":"CategoryTheory.Functor.final_of_comp_full_faithful'","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœâµ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nE : Type uâ‚ƒ\ninstâœÂ³ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninstâœÂ² : G.Full\ninstâœÂ¹ : G.Faithful\ninstâœ : (F.comp G).Final\nâŠ¢ G.Final","decl":"/-- The hypotheses also imply that `F` is final, see `final_of_comp_full_faithful`. -/\ntheorem final_of_comp_full_faithful' [Full G] [Faithful G] [Final (F â‹™ G)] : Final G :=\n  have := final_of_comp_full_faithful F G\n  final_of_final_comp F G\n\n"}
{"name":"CategoryTheory.Functor.initial_of_comp_full_faithful'","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœâµ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nE : Type uâ‚ƒ\ninstâœÂ³ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninstâœÂ² : G.Full\ninstâœÂ¹ : G.Faithful\ninstâœ : (F.comp G).Initial\nâŠ¢ G.Initial","decl":"/-- The hypotheses also imply that `F` is initial, see `initial_of_comp_full_faithful`. -/\ntheorem initial_of_comp_full_faithful' [Full G] [Faithful G] [Initial (F â‹™ G)] : Initial G :=\n  have := initial_of_comp_full_faithful F G\n  initial_of_initial_comp F G\n\n"}
{"name":"CategoryTheory.Functor.final_iff_comp_final_full_faithful","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœâµ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nE : Type uâ‚ƒ\ninstâœÂ³ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninstâœÂ² : G.Final\ninstâœÂ¹ : G.Full\ninstâœ : G.Faithful\nâŠ¢ Iff F.Final (F.comp G).Final","decl":"theorem final_iff_comp_final_full_faithful [Final G] [Full G] [Faithful G] :\n    Final F â†” Final (F â‹™ G) :=\n  âŸ¨fun _ => final_comp _ _, fun _ => final_of_comp_full_faithful F GâŸ©\n\n"}
{"name":"CategoryTheory.Functor.initial_iff_comp_initial_full_faithful","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœâµ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nE : Type uâ‚ƒ\ninstâœÂ³ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninstâœÂ² : G.Initial\ninstâœÂ¹ : G.Full\ninstâœ : G.Faithful\nâŠ¢ Iff F.Initial (F.comp G).Initial","decl":"theorem initial_iff_comp_initial_full_faithful [Initial G] [Full G] [Faithful G] :\n    Initial F â†” Initial (F â‹™ G) :=\n  âŸ¨fun _ => initial_comp _ _, fun _ => initial_of_comp_full_faithful F GâŸ©\n\n"}
{"name":"CategoryTheory.Functor.final_iff_final_comp","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nE : Type uâ‚ƒ\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninstâœ : F.Final\nâŠ¢ Iff G.Final (F.comp G).Final","decl":"theorem final_iff_final_comp [Final F] : Final G â†” Final (F â‹™ G) :=\n  âŸ¨fun _ => final_comp _ _, fun _ => final_of_final_comp F GâŸ©\n\n"}
{"name":"CategoryTheory.Functor.initial_iff_initial_comp","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nE : Type uâ‚ƒ\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninstâœ : F.Initial\nâŠ¢ Iff G.Initial (F.comp G).Initial","decl":"theorem initial_iff_initial_comp [Initial F] : Initial G â†” Initial (F â‹™ G) :=\n  âŸ¨fun _ => initial_comp _ _, fun _ => initial_of_initial_comp F GâŸ©\n\n"}
{"name":"CategoryTheory.IsFilteredOrEmpty.of_final","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœÂ¹ : F.Final\ninstâœ : CategoryTheory.IsFilteredOrEmpty C\nâŠ¢ CategoryTheory.IsFilteredOrEmpty D","decl":"/-- Final functors preserve filteredness.\n\nThis can be seen as a generalization of `IsFiltered.of_right_adjoint` (which states that right\nadjoints preserve filteredness), as right adjoints are always final, see `final_of_adjunction`.\n-/\ntheorem IsFilteredOrEmpty.of_final (F : C â¥¤ D) [Final F] [IsFilteredOrEmpty C] :\n    IsFilteredOrEmpty D where\n  cocone_objs X Y := âŸ¨F.obj (IsFiltered.max (Final.lift F X) (Final.lift F Y)),\n    Final.homToLift F X â‰« F.map (IsFiltered.leftToMax _ _),\n    âŸ¨Final.homToLift F Y â‰« F.map (IsFiltered.rightToMax _ _), trivialâŸ©âŸ©\n  cocone_maps {X Y} f g := by\n    let P : StructuredArrow X F â†’ Prop := fun h => âˆƒ (Z : C) (qâ‚ : h.right âŸ¶ Z)\n      (qâ‚‚ : Final.lift F Y âŸ¶ Z), h.hom â‰« F.map qâ‚ = f â‰« Final.homToLift F Y â‰« F.map qâ‚‚\n    rsuffices âŸ¨Z, qâ‚, qâ‚‚, hâŸ© : Nonempty (P (StructuredArrow.mk (g â‰« Final.homToLift F Y)))\n    Â· refine âŸ¨F.obj (IsFiltered.coeq qâ‚ qâ‚‚),\n        Final.homToLift F Y â‰« F.map (qâ‚ â‰« IsFiltered.coeqHom qâ‚ qâ‚‚), ?_âŸ©\n      conv_lhs => rw [IsFiltered.coeq_condition]\n      simp only [F.map_comp, â† reassoc_of% h, StructuredArrow.mk_hom_eq_self, Category.assoc]\n    have hâ‚€ : P (StructuredArrow.mk (f â‰« Final.homToLift F Y)) := âŸ¨_, ğŸ™ _, ğŸ™ _, by simpâŸ©\n    refine isPreconnected_induction P ?_ ?_ hâ‚€ _\n    Â· rintro U V h âŸ¨Z, qâ‚, qâ‚‚, hqâŸ©\n      obtain âŸ¨W, qâ‚ƒ, qâ‚„, hq'âŸ© := IsFiltered.span qâ‚ h.right\n      refine âŸ¨W, qâ‚„, qâ‚‚ â‰« qâ‚ƒ, ?_âŸ©\n      rw [F.map_comp, â† reassoc_of% hq, â† F.map_comp, hq', F.map_comp, StructuredArrow.w_assoc]\n    Â· rintro U V h âŸ¨Z, qâ‚, qâ‚‚, hqâŸ©\n      exact âŸ¨Z, h.right â‰« qâ‚, qâ‚‚, by simp only [F.map_comp, StructuredArrow.w_assoc, hq]âŸ©\n\n"}
{"name":"CategoryTheory.IsFiltered.of_final","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœÂ¹ : F.Final\ninstâœ : CategoryTheory.IsFiltered C\nâŠ¢ CategoryTheory.IsFiltered D","decl":"/-- Final functors preserve filteredness.\n\nThis can be seen as a generalization of `IsFiltered.of_right_adjoint` (which states that right\nadjoints preserve filteredness), as right adjoints are always final, see `final_of_adjunction`.\n-/\ntheorem IsFiltered.of_final (F : C â¥¤ D) [Final F] [IsFiltered C] : IsFiltered D :=\n{ IsFilteredOrEmpty.of_final F with\n  nonempty := Nonempty.map F.obj IsFiltered.nonempty }\n\n"}
{"name":"CategoryTheory.IsCofilteredOrEmpty.of_initial","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœÂ¹ : F.Initial\ninstâœ : CategoryTheory.IsCofilteredOrEmpty C\nâŠ¢ CategoryTheory.IsCofilteredOrEmpty D","decl":"/-- Initial functors preserve cofilteredness.\n\nThis can be seen as a generalization of `IsCofiltered.of_left_adjoint` (which states that left\nadjoints preserve cofilteredness), as right adjoints are always initial,\nsee `initial_of_adjunction`.\n-/\ntheorem IsCofilteredOrEmpty.of_initial (F : C â¥¤ D) [Initial F] [IsCofilteredOrEmpty C] :\n    IsCofilteredOrEmpty D :=\n  have : IsFilteredOrEmpty Dáµ’áµ– := IsFilteredOrEmpty.of_final F.op\n  isCofilteredOrEmpty_of_isFilteredOrEmpty_op _\n\n"}
{"name":"CategoryTheory.IsCofiltered.of_initial","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœÂ¹ : F.Initial\ninstâœ : CategoryTheory.IsCofiltered C\nâŠ¢ CategoryTheory.IsCofiltered D","decl":"/-- Initial functors preserve cofilteredness.\n\nThis can be seen as a generalization of `IsCofiltered.of_left_adjoint` (which states that left\nadjoints preserve cofilteredness), as right adjoints are always initial,\nsee `initial_of_adjunction`.\n-/\ntheorem IsCofiltered.of_initial (F : C â¥¤ D) [Initial F] [IsCofiltered C] : IsCofiltered D :=\n  have : IsFiltered Dáµ’áµ– := IsFiltered.of_final F.op\n  isCofiltered_of_isFiltered_op _\n\n"}
{"name":"CategoryTheory.StructuredArrow.final_pre","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nE : Type uâ‚ƒ\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nT : CategoryTheory.Functor C D\ninstâœ : T.Final\nS : CategoryTheory.Functor D E\nX : E\nâŠ¢ (CategoryTheory.StructuredArrow.pre X T S).Final","decl":"/-- The functor `StructuredArrow.pre X T S` is final if `T` is final. -/\ninstance StructuredArrow.final_pre (T : C â¥¤ D) [Final T] (S : D â¥¤ E) (X : E) :\n    Final (pre X T S) := by\n  refine âŸ¨fun f => ?_âŸ©\n  rw [isConnected_iff_of_equivalence (StructuredArrow.preEquivalence T f)]\n  exact Final.out f.right\n\n"}
{"name":"CategoryTheory.CostructuredArrow.initial_pre","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nE : Type uâ‚ƒ\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nT : CategoryTheory.Functor C D\ninstâœ : T.Initial\nS : CategoryTheory.Functor D E\nX : E\nâŠ¢ (CategoryTheory.CostructuredArrow.pre T S X).Initial","decl":"/-- The functor `CostructuredArrow.pre X T S` is initial if `T` is initial. -/\ninstance CostructuredArrow.initial_pre (T : C â¥¤ D) [Initial T] (S : D â¥¤ E) (X : E) :\n    Initial (CostructuredArrow.pre T S X) := by\n  refine âŸ¨fun f => ?_âŸ©\n  rw [isConnected_iff_of_equivalence (CostructuredArrow.preEquivalence T f)]\n  exact Initial.out f.left\n\n"}
{"name":"CategoryTheory.Grothendieck.final_pre","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor D CategoryTheory.Cat\nG : CategoryTheory.Functor C D\nhG : G.Final\nâŠ¢ (CategoryTheory.Grothendieck.pre F G).Final","decl":"instance Grothendieck.final_pre [hG : Final G] : (Grothendieck.pre F G).Final := by\n  constructor\n  rintro âŸ¨d, fâŸ©\n  let âŸ¨u, c, gâŸ© : Nonempty (StructuredArrow d G) := inferInstance\n  letI :  Nonempty (StructuredArrow âŸ¨d, fâŸ© (pre F G)) :=\n    âŸ¨u, âŸ¨c, (F.map g).obj fâŸ©, âŸ¨(by exact g), (by exact ğŸ™ _)âŸ©âŸ©\n  apply zigzag_isConnected\n  rintro âŸ¨âŸ¨âŸ¨âŸ©âŸ©, âŸ¨bi, fiâŸ©, âŸ¨gbi, gfiâŸ©âŸ© âŸ¨âŸ¨âŸ¨âŸ©âŸ©, âŸ¨bj, fjâŸ©, âŸ¨gbj, gfjâŸ©âŸ©\n  dsimp at fj fi gfi gbi gbj gfj\n  apply Zigzag.trans (jâ‚‚ := StructuredArrow.mk (Y := âŸ¨bi, ((F.map gbi).obj f)âŸ©)\n      (Grothendieck.Hom.mk gbi (ğŸ™ _)))\n    (.of_zag (.inr âŸ¨StructuredArrow.homMk (Grothendieck.Hom.mk (by dsimp; exact ğŸ™ _)\n      (eqToHom (by simp) â‰« gfi)) (by apply Grothendieck.ext <;> simp)âŸ©))\n  refine Zigzag.trans (jâ‚‚ := StructuredArrow.mk (Y := âŸ¨bj, ((F.map gbj).obj f)âŸ©)\n      (Grothendieck.Hom.mk gbj (ğŸ™ _))) ?_\n    (.of_zag (.inl âŸ¨StructuredArrow.homMk (Grothendieck.Hom.mk (by dsimp; exact ğŸ™ _)\n      (eqToHom (by simp) â‰« gfj)) (by apply Grothendieck.ext <;> simp)âŸ©))\n  exact zigzag_prefunctor_obj_of_zigzag (Grothendieck.structuredArrowToStructuredArrowPre F G d f)\n    (isPreconnected_zigzag (.mk gbi) (.mk gbj))\n\n"}
{"name":"CategoryTheory.instFinalProdProd","module":"Mathlib.CategoryTheory.Limits.Final","initialProofState":"C : Type uâ‚\ninstâœâµ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nC' : Type uâ‚ƒ\ninstâœÂ³ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} C'\nD' : Type uâ‚„\ninstâœÂ² : CategoryTheory.Category.{vâ‚„, uâ‚„} D'\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor C' D'\ninstâœÂ¹ : F.Final\ninstâœ : G.Final\nâŠ¢ (F.prod G).Final","decl":"instance [F.Final] [G.Final] : (F.prod G).Final where\n  out := fun âŸ¨d, d'âŸ© => isConnected_of_equivalent (StructuredArrow.prodEquivalence d d' F G).symm\n\n"}
