{"name":"CategoryTheory.HomOrthogonal.eq_zero","module":"Mathlib.CategoryTheory.Preadditive.HomOrthogonal","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nŒπ : Type u_1\ns : Œπ ‚Üí C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\no : CategoryTheory.HomOrthogonal s\ni j : Œπ\nw : Ne i j\nf : Quiver.Hom (s i) (s j)\n‚ä¢ Eq f 0","decl":"theorem eq_zero [HasZeroMorphisms C] (o : HomOrthogonal s) {i j : Œπ} (w : i ‚â† j) (f : s i ‚ü∂ s j) :\n    f = 0 :=\n  (o w).elim _ _\n\n"}
{"name":"CategoryTheory.HomOrthogonal.matrixDecomposition_apply","module":"Mathlib.CategoryTheory.Preadditive.HomOrthogonal","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\nŒπ : Type u_1\ns : Œπ ‚Üí C\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬≤ : CategoryTheory.Limits.HasFiniteBiproducts C\no : CategoryTheory.HomOrthogonal s\nŒ± Œ≤ : Type\ninst‚úù¬π : Finite Œ±\ninst‚úù : Finite Œ≤\nf : Œ± ‚Üí Œπ\ng : Œ≤ ‚Üí Œπ\nz : Quiver.Hom (CategoryTheory.Limits.biproduct fun a => s (f a)) (CategoryTheory.Limits.biproduct fun b => s (g b))\ni : Œπ\nj : ‚Üë(Set.preimage g (Singleton.singleton i))\nk : ‚Üë(Set.preimage f (Singleton.singleton i))\n‚ä¢ Eq (o.matrixDecomposition z i j k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.components z ‚Üëk ‚Üëj) (CategoryTheory.eqToHom ‚ãØ)))","decl":"open scoped Classical in\n/-- Morphisms between two direct sums over a hom orthogonal family `s : Œπ ‚Üí C`\nare equivalent to block diagonal matrices,\nwith blocks indexed by `Œπ`,\nand matrix entries in `i`-th block living in the endomorphisms of `s i`. -/\n@[simps]\nnoncomputable def matrixDecomposition (o : HomOrthogonal s) {Œ± Œ≤ : Type} [Finite Œ±] [Finite Œ≤]\n    {f : Œ± ‚Üí Œπ} {g : Œ≤ ‚Üí Œπ} :\n    ((‚®Å fun a => s (f a)) ‚ü∂ ‚®Å fun b => s (g b)) ‚âÉ\n      ‚àÄ i : Œπ, Matrix (g ‚Åª¬π' {i}) (f ‚Åª¬π' {i}) (End (s i)) where\n  toFun z i j k :=\n    eqToHom\n        (by\n          rcases k with ‚ü®k, ‚ü®‚ü©‚ü©\n          simp) ‚â´\n      biproduct.components z k j ‚â´\n        eqToHom\n          (by\n            rcases j with ‚ü®j, ‚ü®‚ü©‚ü©\n            simp)\n  invFun z :=\n    biproduct.matrix fun j k =>\n      if h : f j = g k then z (f j) ‚ü®k, by simp [h]‚ü© ‚ü®j, by simp‚ü© ‚â´ eqToHom (by simp [h]) else 0\n  left_inv z := by\n    ext j k\n    simp only [biproduct.matrix_œÄ, biproduct.Œπ_desc]\n    split_ifs with h\n    ¬∑ simp\n      rfl\n    ¬∑ symm\n      apply o.eq_zero h\n  right_inv z := by\n    ext i ‚ü®j, w‚ü© ‚ü®k, ‚ü®‚ü©‚ü©\n    simp only [eqToHom_refl, biproduct.matrix_components, Category.id_comp]\n    split_ifs with h\n    ¬∑ simp\n    ¬∑ exfalso\n      exact h w.symm\n\n"}
{"name":"CategoryTheory.HomOrthogonal.matrixDecomposition_symm_apply","module":"Mathlib.CategoryTheory.Preadditive.HomOrthogonal","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\nŒπ : Type u_1\ns : Œπ ‚Üí C\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬≤ : CategoryTheory.Limits.HasFiniteBiproducts C\no : CategoryTheory.HomOrthogonal s\nŒ± Œ≤ : Type\ninst‚úù¬π : Finite Œ±\ninst‚úù : Finite Œ≤\nf : Œ± ‚Üí Œπ\ng : Œ≤ ‚Üí Œπ\nz : (i : Œπ) ‚Üí Matrix (‚Üë(Set.preimage g (Singleton.singleton i))) (‚Üë(Set.preimage f (Singleton.singleton i))) (CategoryTheory.End (s i))\n‚ä¢ Eq (o.matrixDecomposition.symm z) (CategoryTheory.Limits.biproduct.matrix fun j k => dite (Eq (f j) (g k)) (fun h => CategoryTheory.CategoryStruct.comp (z (f j) ‚ü®k, ‚ãØ‚ü© ‚ü®j, ‚ãØ‚ü©) (CategoryTheory.eqToHom ‚ãØ)) fun h => 0)","decl":"open scoped Classical in\n/-- Morphisms between two direct sums over a hom orthogonal family `s : Œπ ‚Üí C`\nare equivalent to block diagonal matrices,\nwith blocks indexed by `Œπ`,\nand matrix entries in `i`-th block living in the endomorphisms of `s i`. -/\n@[simps]\nnoncomputable def matrixDecomposition (o : HomOrthogonal s) {Œ± Œ≤ : Type} [Finite Œ±] [Finite Œ≤]\n    {f : Œ± ‚Üí Œπ} {g : Œ≤ ‚Üí Œπ} :\n    ((‚®Å fun a => s (f a)) ‚ü∂ ‚®Å fun b => s (g b)) ‚âÉ\n      ‚àÄ i : Œπ, Matrix (g ‚Åª¬π' {i}) (f ‚Åª¬π' {i}) (End (s i)) where\n  toFun z i j k :=\n    eqToHom\n        (by\n          rcases k with ‚ü®k, ‚ü®‚ü©‚ü©\n          simp) ‚â´\n      biproduct.components z k j ‚â´\n        eqToHom\n          (by\n            rcases j with ‚ü®j, ‚ü®‚ü©‚ü©\n            simp)\n  invFun z :=\n    biproduct.matrix fun j k =>\n      if h : f j = g k then z (f j) ‚ü®k, by simp [h]‚ü© ‚ü®j, by simp‚ü© ‚â´ eqToHom (by simp [h]) else 0\n  left_inv z := by\n    ext j k\n    simp only [biproduct.matrix_œÄ, biproduct.Œπ_desc]\n    split_ifs with h\n    ¬∑ simp\n      rfl\n    ¬∑ symm\n      apply o.eq_zero h\n  right_inv z := by\n    ext i ‚ü®j, w‚ü© ‚ü®k, ‚ü®‚ü©‚ü©\n    simp only [eqToHom_refl, biproduct.matrix_components, Category.id_comp]\n    split_ifs with h\n    ¬∑ simp\n    ¬∑ exfalso\n      exact h w.symm\n\n"}
{"name":"CategoryTheory.HomOrthogonal.matrixDecompositionAddEquiv_symm_apply","module":"Mathlib.CategoryTheory.Preadditive.HomOrthogonal","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\nŒπ : Type u_1\ns : Œπ ‚Üí C\ninst‚úù¬≥ : CategoryTheory.Preadditive C\ninst‚úù¬≤ : CategoryTheory.Limits.HasFiniteBiproducts C\no : CategoryTheory.HomOrthogonal s\nŒ± Œ≤ : Type\ninst‚úù¬π : Finite Œ±\ninst‚úù : Finite Œ≤\nf : Œ± ‚Üí Œπ\ng : Œ≤ ‚Üí Œπ\nz : (i : Œπ) ‚Üí Matrix (‚Üë(Set.preimage g (Singleton.singleton i))) (‚Üë(Set.preimage f (Singleton.singleton i))) (CategoryTheory.End (s i))\n‚ä¢ Eq (o.matrixDecompositionAddEquiv.symm z) (CategoryTheory.Limits.biproduct.matrix fun j k => ite (Eq (f j) (g k)) (CategoryTheory.CategoryStruct.comp (z (f j) ‚ü®k, ‚ãØ‚ü© ‚ü®j, ‚ãØ‚ü©) (CategoryTheory.eqToHom ‚ãØ)) 0)","decl":"/-- `HomOrthogonal.matrixDecomposition` as an additive equivalence. -/\n@[simps!]\nnoncomputable def matrixDecompositionAddEquiv (o : HomOrthogonal s) {Œ± Œ≤ : Type} [Finite Œ±]\n    [Finite Œ≤] {f : Œ± ‚Üí Œπ} {g : Œ≤ ‚Üí Œπ} :\n    ((‚®Å fun a => s (f a)) ‚ü∂ ‚®Å fun b => s (g b)) ‚âÉ+\n      ‚àÄ i : Œπ, Matrix (g ‚Åª¬π' {i}) (f ‚Åª¬π' {i}) (End (s i)) :=\n  { o.matrixDecomposition with\n    map_add' := fun w z => by\n      ext\n      dsimp [biproduct.components]\n      simp }\n\n"}
{"name":"CategoryTheory.HomOrthogonal.matrixDecompositionAddEquiv_apply","module":"Mathlib.CategoryTheory.Preadditive.HomOrthogonal","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\nŒπ : Type u_1\ns : Œπ ‚Üí C\ninst‚úù¬≥ : CategoryTheory.Preadditive C\ninst‚úù¬≤ : CategoryTheory.Limits.HasFiniteBiproducts C\no : CategoryTheory.HomOrthogonal s\nŒ± Œ≤ : Type\ninst‚úù¬π : Finite Œ±\ninst‚úù : Finite Œ≤\nf : Œ± ‚Üí Œπ\ng : Œ≤ ‚Üí Œπ\nz : Quiver.Hom (CategoryTheory.Limits.biproduct fun a => s (f a)) (CategoryTheory.Limits.biproduct fun b => s (g b))\ni : Œπ\nj : ‚Üë(Set.preimage g (Singleton.singleton i))\nk : ‚Üë(Set.preimage f (Singleton.singleton i))\n‚ä¢ Eq (o.matrixDecompositionAddEquiv z i j k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.components z ‚Üëk ‚Üëj) (CategoryTheory.eqToHom ‚ãØ)))","decl":"/-- `HomOrthogonal.matrixDecomposition` as an additive equivalence. -/\n@[simps!]\nnoncomputable def matrixDecompositionAddEquiv (o : HomOrthogonal s) {Œ± Œ≤ : Type} [Finite Œ±]\n    [Finite Œ≤] {f : Œ± ‚Üí Œπ} {g : Œ≤ ‚Üí Œπ} :\n    ((‚®Å fun a => s (f a)) ‚ü∂ ‚®Å fun b => s (g b)) ‚âÉ+\n      ‚àÄ i : Œπ, Matrix (g ‚Åª¬π' {i}) (f ‚Åª¬π' {i}) (End (s i)) :=\n  { o.matrixDecomposition with\n    map_add' := fun w z => by\n      ext\n      dsimp [biproduct.components]\n      simp }\n\n"}
{"name":"CategoryTheory.HomOrthogonal.matrixDecomposition_id","module":"Mathlib.CategoryTheory.Preadditive.HomOrthogonal","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nŒπ : Type u_1\ns : Œπ ‚Üí C\ninst‚úù¬≤ : CategoryTheory.Preadditive C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteBiproducts C\no : CategoryTheory.HomOrthogonal s\nŒ± : Type\ninst‚úù : Finite Œ±\nf : Œ± ‚Üí Œπ\ni : Œπ\n‚ä¢ Eq (o.matrixDecomposition (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.biproduct fun a => s (f a))) i) 1","decl":"open scoped Classical in\n@[simp]\ntheorem matrixDecomposition_id (o : HomOrthogonal s) {Œ± : Type} [Finite Œ±] {f : Œ± ‚Üí Œπ} (i : Œπ) :\n    o.matrixDecomposition (ùüô (‚®Å fun a => s (f a))) i = 1 := by\n  ext ‚ü®b, ‚ü®‚ü©‚ü© ‚ü®a, j_property‚ü©\n  simp only [Set.mem_preimage, Set.mem_singleton_iff] at j_property\n  simp only [Category.comp_id, Category.id_comp, Category.assoc, End.one_def, eqToHom_refl,\n    Matrix.one_apply, HomOrthogonal.matrixDecomposition_apply, biproduct.components]\n  split_ifs with h\n  ¬∑ cases h\n    simp\n  ¬∑ simp only [Subtype.mk.injEq] at h\n    -- Porting note: used to be `convert comp_zero`, but that does not work anymore\n    have : biproduct.Œπ (fun a ‚Ü¶ s (f a)) a ‚â´ biproduct.œÄ (fun b ‚Ü¶ s (f b)) b = 0 := by\n      simpa using biproduct.Œπ_œÄ_ne _ (Ne.symm h)\n    rw [this, comp_zero]\n\n"}
{"name":"CategoryTheory.HomOrthogonal.matrixDecomposition_comp","module":"Mathlib.CategoryTheory.Preadditive.HomOrthogonal","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\nŒπ : Type u_1\ns : Œπ ‚Üí C\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\ninst‚úù¬≥ : CategoryTheory.Limits.HasFiniteBiproducts C\no : CategoryTheory.HomOrthogonal s\nŒ± Œ≤ Œ≥ : Type\ninst‚úù¬≤ : Finite Œ±\ninst‚úù¬π : Fintype Œ≤\ninst‚úù : Finite Œ≥\nf : Œ± ‚Üí Œπ\ng : Œ≤ ‚Üí Œπ\nh : Œ≥ ‚Üí Œπ\nz : Quiver.Hom (CategoryTheory.Limits.biproduct fun a => s (f a)) (CategoryTheory.Limits.biproduct fun b => s (g b))\nw : Quiver.Hom (CategoryTheory.Limits.biproduct fun b => s (g b)) (CategoryTheory.Limits.biproduct fun c => s (h c))\ni : Œπ\n‚ä¢ Eq (o.matrixDecomposition (CategoryTheory.CategoryStruct.comp z w) i) (HMul.hMul (o.matrixDecomposition w i) (o.matrixDecomposition z i))","decl":"open scoped Classical in\ntheorem matrixDecomposition_comp (o : HomOrthogonal s) {Œ± Œ≤ Œ≥ : Type} [Finite Œ±] [Fintype Œ≤]\n    [Finite Œ≥] {f : Œ± ‚Üí Œπ} {g : Œ≤ ‚Üí Œπ} {h : Œ≥ ‚Üí Œπ} (z : (‚®Å fun a => s (f a)) ‚ü∂ ‚®Å fun b => s (g b))\n    (w : (‚®Å fun b => s (g b)) ‚ü∂ ‚®Å fun c => s (h c)) (i : Œπ) :\n    o.matrixDecomposition (z ‚â´ w) i = o.matrixDecomposition w i * o.matrixDecomposition z i := by\n  ext ‚ü®c, ‚ü®‚ü©‚ü© ‚ü®a, j_property‚ü©\n  simp only [Set.mem_preimage, Set.mem_singleton_iff] at j_property\n  simp only [Matrix.mul_apply, Limits.biproduct.components,\n    HomOrthogonal.matrixDecomposition_apply, Category.comp_id, Category.id_comp, Category.assoc,\n    End.mul_def, eqToHom_refl, eqToHom_trans_assoc, Finset.sum_congr]\n  conv_lhs => rw [‚Üê Category.id_comp w, ‚Üê biproduct.total]\n  simp only [Preadditive.sum_comp, Preadditive.comp_sum]\n  apply Finset.sum_congr_set\n  ¬∑ simp\n  ¬∑ intro b nm\n    simp only [Set.mem_preimage, Set.mem_singleton_iff] at nm\n    simp only [Category.assoc]\n    -- Porting note: this used to be 4 times `convert comp_zero`\n    have : biproduct.Œπ (fun b ‚Ü¶ s (g b)) b ‚â´ w ‚â´ biproduct.œÄ (fun b ‚Ü¶ s (h b)) c = 0 := by\n      apply o.eq_zero nm\n    simp only [this, comp_zero]\n\n"}
{"name":"CategoryTheory.HomOrthogonal.matrixDecompositionLinearEquiv_apply","module":"Mathlib.CategoryTheory.Preadditive.HomOrthogonal","initialProofState":"C : Type u\ninst‚úù‚Å∂ : CategoryTheory.Category.{v, u} C\nŒπ : Type u_1\ns : Œπ ‚Üí C\ninst‚úù‚Åµ : CategoryTheory.Preadditive C\ninst‚úù‚Å¥ : CategoryTheory.Limits.HasFiniteBiproducts C\nR : Type u_2\ninst‚úù¬≥ : Semiring R\ninst‚úù¬≤ : CategoryTheory.Linear R C\no : CategoryTheory.HomOrthogonal s\nŒ± Œ≤ : Type\ninst‚úù¬π : Finite Œ±\ninst‚úù : Finite Œ≤\nf : Œ± ‚Üí Œπ\ng : Œ≤ ‚Üí Œπ\na‚úù : Quiver.Hom (CategoryTheory.Limits.biproduct fun a => s (f a)) (CategoryTheory.Limits.biproduct fun b => s (g b))\ni : Œπ\n‚ä¢ Eq (o.matrixDecompositionLinearEquiv a‚úù i) (o.matrixDecompositionAddEquiv.toFun a‚úù i)","decl":"/-- `HomOrthogonal.MatrixDecomposition` as an `R`-linear equivalence. -/\n@[simps]\nnoncomputable def matrixDecompositionLinearEquiv (o : HomOrthogonal s) {Œ± Œ≤ : Type} [Finite Œ±]\n    [Finite Œ≤] {f : Œ± ‚Üí Œπ} {g : Œ≤ ‚Üí Œπ} :\n    ((‚®Å fun a => s (f a)) ‚ü∂ ‚®Å fun b => s (g b)) ‚âÉ‚Çó[R]\n      ‚àÄ i : Œπ, Matrix (g ‚Åª¬π' {i}) (f ‚Åª¬π' {i}) (End (s i)) :=\n  { o.matrixDecompositionAddEquiv with\n    map_smul' := fun w z => by\n      ext\n      dsimp [biproduct.components]\n      simp }\n\n"}
{"name":"CategoryTheory.HomOrthogonal.matrixDecompositionLinearEquiv_symm_apply","module":"Mathlib.CategoryTheory.Preadditive.HomOrthogonal","initialProofState":"C : Type u\ninst‚úù‚Å∂ : CategoryTheory.Category.{v, u} C\nŒπ : Type u_1\ns : Œπ ‚Üí C\ninst‚úù‚Åµ : CategoryTheory.Preadditive C\ninst‚úù‚Å¥ : CategoryTheory.Limits.HasFiniteBiproducts C\nR : Type u_2\ninst‚úù¬≥ : Semiring R\ninst‚úù¬≤ : CategoryTheory.Linear R C\no : CategoryTheory.HomOrthogonal s\nŒ± Œ≤ : Type\ninst‚úù¬π : Finite Œ±\ninst‚úù : Finite Œ≤\nf : Œ± ‚Üí Œπ\ng : Œ≤ ‚Üí Œπ\na‚úù : (i : Œπ) ‚Üí Matrix (‚Üë(Set.preimage g (Singleton.singleton i))) (‚Üë(Set.preimage f (Singleton.singleton i))) (CategoryTheory.End (s i))\n‚ä¢ Eq (o.matrixDecompositionLinearEquiv.symm a‚úù) (o.matrixDecompositionAddEquiv.invFun a‚úù)","decl":"/-- `HomOrthogonal.MatrixDecomposition` as an `R`-linear equivalence. -/\n@[simps]\nnoncomputable def matrixDecompositionLinearEquiv (o : HomOrthogonal s) {Œ± Œ≤ : Type} [Finite Œ±]\n    [Finite Œ≤] {f : Œ± ‚Üí Œπ} {g : Œ≤ ‚Üí Œπ} :\n    ((‚®Å fun a => s (f a)) ‚ü∂ ‚®Å fun b => s (g b)) ‚âÉ‚Çó[R]\n      ‚àÄ i : Œπ, Matrix (g ‚Åª¬π' {i}) (f ‚Åª¬π' {i}) (End (s i)) :=\n  { o.matrixDecompositionAddEquiv with\n    map_smul' := fun w z => by\n      ext\n      dsimp [biproduct.components]\n      simp }\n\n"}
{"name":"CategoryTheory.HomOrthogonal.equiv_of_iso","module":"Mathlib.CategoryTheory.Preadditive.HomOrthogonal","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\nŒπ : Type u_1\ns : Œπ ‚Üí C\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\ninst‚úù¬≥ : CategoryTheory.Limits.HasFiniteBiproducts C\ninst‚úù¬≤ : ‚àÄ (i : Œπ), InvariantBasisNumber (CategoryTheory.End (s i))\no : CategoryTheory.HomOrthogonal s\nŒ± Œ≤ : Type\ninst‚úù¬π : Finite Œ±\ninst‚úù : Finite Œ≤\nf : Œ± ‚Üí Œπ\ng : Œ≤ ‚Üí Œπ\ni : CategoryTheory.Iso (CategoryTheory.Limits.biproduct fun a => s (f a)) (CategoryTheory.Limits.biproduct fun b => s (g b))\n‚ä¢ Exists fun e => ‚àÄ (a : Œ±), Eq (g (e a)) (f a)","decl":"/-- Given a hom orthogonal family `s : Œπ ‚Üí C`\nfor which each `End (s i)` is a ring with invariant basis number (e.g. if each `s i` is simple),\nif two direct sums over `s` are isomorphic, then they have the same multiplicities.\n-/\ntheorem equiv_of_iso (o : HomOrthogonal s) {Œ± Œ≤ : Type} [Finite Œ±] [Finite Œ≤] {f : Œ± ‚Üí Œπ}\n    {g : Œ≤ ‚Üí Œπ} (i : (‚®Å fun a => s (f a)) ‚âÖ ‚®Å fun b => s (g b)) :\n    ‚àÉ e : Œ± ‚âÉ Œ≤, ‚àÄ a, g (e a) = f a := by\n  classical\n  refine ‚ü®Equiv.ofPreimageEquiv ?_, fun a => Equiv.ofPreimageEquiv_map _ _‚ü©\n  intro c\n  apply Nonempty.some\n  apply Cardinal.eq.1\n  cases nonempty_fintype Œ±; cases nonempty_fintype Œ≤\n  simp only [Cardinal.mk_fintype, Nat.cast_inj]\n  exact\n    Matrix.square_of_invertible (o.matrixDecomposition i.inv c) (o.matrixDecomposition i.hom c)\n      (by\n        rw [‚Üê o.matrixDecomposition_comp]\n        simp)\n      (by\n        rw [‚Üê o.matrixDecomposition_comp]\n        simp)\n\n"}
