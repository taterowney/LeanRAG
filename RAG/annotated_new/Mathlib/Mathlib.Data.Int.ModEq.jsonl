{"name":"Int.ModEq.refl","module":"Mathlib.Data.Int.ModEq","initialProofState":"n a : Int\n⊢ n.ModEq a a","decl":"@[refl, simp]\nprotected theorem refl (a : ℤ) : a ≡ a [ZMOD n] :=\n  @rfl _ _\n\n"}
{"name":"Int.ModEq.rfl","module":"Mathlib.Data.Int.ModEq","initialProofState":"n a : Int\n⊢ n.ModEq a a","decl":"protected theorem rfl : a ≡ a [ZMOD n] :=\n  ModEq.refl _\n\n"}
{"name":"Int.ModEq.instIsRefl","module":"Mathlib.Data.Int.ModEq","initialProofState":"n : Int\n⊢ IsRefl Int n.ModEq","decl":"instance : IsRefl _ (ModEq n) :=\n  ⟨ModEq.refl⟩\n\n"}
{"name":"Int.ModEq.symm","module":"Mathlib.Data.Int.ModEq","initialProofState":"n a b : Int\na✝ : n.ModEq a b\n⊢ n.ModEq b a","decl":"@[symm]\nprotected theorem symm : a ≡ b [ZMOD n] → b ≡ a [ZMOD n] :=\n  Eq.symm\n\n"}
{"name":"Int.ModEq.trans","module":"Mathlib.Data.Int.ModEq","initialProofState":"n a b c : Int\na✝¹ : n.ModEq a b\na✝ : n.ModEq b c\n⊢ n.ModEq a c","decl":"@[trans]\nprotected theorem trans : a ≡ b [ZMOD n] → b ≡ c [ZMOD n] → a ≡ c [ZMOD n] :=\n  Eq.trans\n\n"}
{"name":"Int.ModEq.instIsTrans","module":"Mathlib.Data.Int.ModEq","initialProofState":"n : Int\n⊢ IsTrans Int n.ModEq","decl":"instance : IsTrans ℤ (ModEq n) where\n  trans := @Int.ModEq.trans n\n\n"}
{"name":"Int.ModEq.eq","module":"Mathlib.Data.Int.ModEq","initialProofState":"n a b : Int\na✝ : n.ModEq a b\n⊢ Eq (HMod.hMod a n) (HMod.hMod b n)","decl":"protected theorem eq : a ≡ b [ZMOD n] → a % n = b % n := id\n\n"}
{"name":"Int.modEq_comm","module":"Mathlib.Data.Int.ModEq","initialProofState":"n a b : Int\n⊢ Iff (n.ModEq a b) (n.ModEq b a)","decl":"theorem modEq_comm : a ≡ b [ZMOD n] ↔ b ≡ a [ZMOD n] := ⟨ModEq.symm, ModEq.symm⟩\n\n"}
{"name":"Int.natCast_modEq_iff","module":"Mathlib.Data.Int.ModEq","initialProofState":"a b n : Nat\n⊢ Iff ((↑n).ModEq ↑a ↑b) (n.ModEq a b)","decl":"theorem natCast_modEq_iff {a b n : ℕ} : a ≡ b [ZMOD n] ↔ a ≡ b [MOD n] := by\n  unfold ModEq Nat.ModEq; rw [← Int.ofNat_inj]; simp [natCast_mod]\n\n"}
{"name":"Int.modEq_zero_iff_dvd","module":"Mathlib.Data.Int.ModEq","initialProofState":"n a : Int\n⊢ Iff (n.ModEq a 0) (Dvd.dvd n a)","decl":"theorem modEq_zero_iff_dvd : a ≡ 0 [ZMOD n] ↔ n ∣ a := by\n  rw [ModEq, zero_emod, dvd_iff_emod_eq_zero]\n\n"}
{"name":"Dvd.dvd.modEq_zero_int","module":"Mathlib.Data.Int.ModEq","initialProofState":"n a : Int\nh : Dvd.dvd n a\n⊢ n.ModEq a 0","decl":"theorem _root_.Dvd.dvd.modEq_zero_int (h : n ∣ a) : a ≡ 0 [ZMOD n] :=\n  modEq_zero_iff_dvd.2 h\n\n"}
{"name":"Dvd.dvd.zero_modEq_int","module":"Mathlib.Data.Int.ModEq","initialProofState":"n a : Int\nh : Dvd.dvd n a\n⊢ n.ModEq 0 a","decl":"theorem _root_.Dvd.dvd.zero_modEq_int (h : n ∣ a) : 0 ≡ a [ZMOD n] :=\n  h.modEq_zero_int.symm\n\n"}
{"name":"Int.modEq_iff_dvd","module":"Mathlib.Data.Int.ModEq","initialProofState":"n a b : Int\n⊢ Iff (n.ModEq a b) (Dvd.dvd n (HSub.hSub b a))","decl":"theorem modEq_iff_dvd : a ≡ b [ZMOD n] ↔ n ∣ b - a := by\n  rw [ModEq, eq_comm]\n  simp [emod_eq_emod_iff_emod_sub_eq_zero, dvd_iff_emod_eq_zero]\n\n"}
{"name":"Int.modEq_iff_add_fac","module":"Mathlib.Data.Int.ModEq","initialProofState":"a b n : Int\n⊢ Iff (n.ModEq a b) (Exists fun t => Eq b (HAdd.hAdd a (HMul.hMul n t)))","decl":"theorem modEq_iff_add_fac {a b n : ℤ} : a ≡ b [ZMOD n] ↔ ∃ t, b = a + n * t := by\n  rw [modEq_iff_dvd]\n  exact exists_congr fun t => sub_eq_iff_eq_add'\n\n"}
{"name":"Int.modEq_of_dvd","module":"Mathlib.Data.Int.ModEq","initialProofState":"n a b : Int\na✝ : Dvd.dvd n (HSub.hSub b a)\n⊢ n.ModEq a b","decl":"alias ⟨ModEq.dvd, modEq_of_dvd⟩ := modEq_iff_dvd\n\n"}
{"name":"Int.ModEq.dvd","module":"Mathlib.Data.Int.ModEq","initialProofState":"n a b : Int\na✝ : n.ModEq a b\n⊢ Dvd.dvd n (HSub.hSub b a)","decl":"alias ⟨ModEq.dvd, modEq_of_dvd⟩ := modEq_iff_dvd\n\n"}
{"name":"Int.mod_modEq","module":"Mathlib.Data.Int.ModEq","initialProofState":"a n : Int\n⊢ n.ModEq (HMod.hMod a n) a","decl":"theorem mod_modEq (a n) : a % n ≡ a [ZMOD n] :=\n  emod_emod _ _\n\n"}
{"name":"Int.neg_modEq_neg","module":"Mathlib.Data.Int.ModEq","initialProofState":"n a b : Int\n⊢ Iff (n.ModEq (Neg.neg a) (Neg.neg b)) (n.ModEq a b)","decl":"@[simp]\ntheorem neg_modEq_neg : -a ≡ -b [ZMOD n] ↔ a ≡ b [ZMOD n] := by\n  simp only [modEq_iff_dvd, (by omega : -b - -a = -(b - a)), Int.dvd_neg]\n\n"}
{"name":"Int.modEq_neg","module":"Mathlib.Data.Int.ModEq","initialProofState":"n a b : Int\n⊢ Iff ((Neg.neg n).ModEq a b) (n.ModEq a b)","decl":"@[simp]\ntheorem modEq_neg : a ≡ b [ZMOD -n] ↔ a ≡ b [ZMOD n] := by simp [modEq_iff_dvd]\n\n"}
{"name":"Int.ModEq.of_dvd","module":"Mathlib.Data.Int.ModEq","initialProofState":"m n a b : Int\nd : Dvd.dvd m n\nh : n.ModEq a b\n⊢ m.ModEq a b","decl":"protected theorem of_dvd (d : m ∣ n) (h : a ≡ b [ZMOD n]) : a ≡ b [ZMOD m] :=\n  modEq_iff_dvd.2 <| d.trans h.dvd\n\n"}
{"name":"Int.ModEq.mul_left'","module":"Mathlib.Data.Int.ModEq","initialProofState":"n a b c : Int\nh : n.ModEq a b\n⊢ (HMul.hMul c n).ModEq (HMul.hMul c a) (HMul.hMul c b)","decl":"protected theorem mul_left' (h : a ≡ b [ZMOD n]) : c * a ≡ c * b [ZMOD c * n] := by\n  obtain hc | rfl | hc := lt_trichotomy c 0\n  · rw [← neg_modEq_neg, ← modEq_neg, ← Int.neg_mul, ← Int.neg_mul, ← Int.neg_mul]\n    simp only [ModEq, mul_emod_mul_of_pos _ _ (neg_pos.2 hc), h.eq]\n  · simp only [Int.zero_mul, ModEq.rfl]\n  · simp only [ModEq, mul_emod_mul_of_pos _ _ hc, h.eq]\n\n"}
{"name":"Int.ModEq.mul_right'","module":"Mathlib.Data.Int.ModEq","initialProofState":"n a b c : Int\nh : n.ModEq a b\n⊢ (HMul.hMul n c).ModEq (HMul.hMul a c) (HMul.hMul b c)","decl":"protected theorem mul_right' (h : a ≡ b [ZMOD n]) : a * c ≡ b * c [ZMOD n * c] := by\n  rw [mul_comm a, mul_comm b, mul_comm n]; exact h.mul_left'\n\n"}
{"name":"Int.ModEq.add","module":"Mathlib.Data.Int.ModEq","initialProofState":"n a b c d : Int\nh₁ : n.ModEq a b\nh₂ : n.ModEq c d\n⊢ n.ModEq (HAdd.hAdd a c) (HAdd.hAdd b d)","decl":"@[gcongr]\nprotected theorem add (h₁ : a ≡ b [ZMOD n]) (h₂ : c ≡ d [ZMOD n]) : a + c ≡ b + d [ZMOD n] :=\n  modEq_iff_dvd.2 <| by convert Int.dvd_add h₁.dvd h₂.dvd using 1; omega\n\n"}
{"name":"Int.ModEq.add_left","module":"Mathlib.Data.Int.ModEq","initialProofState":"n a b c : Int\nh : n.ModEq a b\n⊢ n.ModEq (HAdd.hAdd c a) (HAdd.hAdd c b)","decl":"@[gcongr] protected theorem add_left (c : ℤ) (h : a ≡ b [ZMOD n]) : c + a ≡ c + b [ZMOD n] :=\n  ModEq.rfl.add h\n\n"}
{"name":"Int.ModEq.add_right","module":"Mathlib.Data.Int.ModEq","initialProofState":"n a b c : Int\nh : n.ModEq a b\n⊢ n.ModEq (HAdd.hAdd a c) (HAdd.hAdd b c)","decl":"@[gcongr] protected theorem add_right (c : ℤ) (h : a ≡ b [ZMOD n]) : a + c ≡ b + c [ZMOD n] :=\n  h.add ModEq.rfl\n\n"}
{"name":"Int.ModEq.add_left_cancel","module":"Mathlib.Data.Int.ModEq","initialProofState":"n a b c d : Int\nh₁ : n.ModEq a b\nh₂ : n.ModEq (HAdd.hAdd a c) (HAdd.hAdd b d)\n⊢ n.ModEq c d","decl":"protected theorem add_left_cancel (h₁ : a ≡ b [ZMOD n]) (h₂ : a + c ≡ b + d [ZMOD n]) :\n    c ≡ d [ZMOD n] :=\n  have : d - c = b + d - (a + c) - (b - a) := by omega\n  modEq_iff_dvd.2 <| by\n    rw [this]\n    exact Int.dvd_sub h₂.dvd h₁.dvd\n\n"}
{"name":"Int.ModEq.add_left_cancel'","module":"Mathlib.Data.Int.ModEq","initialProofState":"n a b c : Int\nh : n.ModEq (HAdd.hAdd c a) (HAdd.hAdd c b)\n⊢ n.ModEq a b","decl":"protected theorem add_left_cancel' (c : ℤ) (h : c + a ≡ c + b [ZMOD n]) : a ≡ b [ZMOD n] :=\n  ModEq.rfl.add_left_cancel h\n\n"}
{"name":"Int.ModEq.add_right_cancel","module":"Mathlib.Data.Int.ModEq","initialProofState":"n a b c d : Int\nh₁ : n.ModEq c d\nh₂ : n.ModEq (HAdd.hAdd a c) (HAdd.hAdd b d)\n⊢ n.ModEq a b","decl":"protected theorem add_right_cancel (h₁ : c ≡ d [ZMOD n]) (h₂ : a + c ≡ b + d [ZMOD n]) :\n    a ≡ b [ZMOD n] := by\n  rw [add_comm a, add_comm b] at h₂\n  exact h₁.add_left_cancel h₂\n\n"}
{"name":"Int.ModEq.add_right_cancel'","module":"Mathlib.Data.Int.ModEq","initialProofState":"n a b c : Int\nh : n.ModEq (HAdd.hAdd a c) (HAdd.hAdd b c)\n⊢ n.ModEq a b","decl":"protected theorem add_right_cancel' (c : ℤ) (h : a + c ≡ b + c [ZMOD n]) : a ≡ b [ZMOD n] :=\n  ModEq.rfl.add_right_cancel h\n\n"}
{"name":"Int.ModEq.neg","module":"Mathlib.Data.Int.ModEq","initialProofState":"n a b : Int\nh : n.ModEq a b\n⊢ n.ModEq (Neg.neg a) (Neg.neg b)","decl":"@[gcongr] protected theorem neg (h : a ≡ b [ZMOD n]) : -a ≡ -b [ZMOD n] :=\n  h.add_left_cancel (by simp_rw [← sub_eq_add_neg, sub_self]; rfl)\n\n"}
{"name":"Int.ModEq.sub","module":"Mathlib.Data.Int.ModEq","initialProofState":"n a b c d : Int\nh₁ : n.ModEq a b\nh₂ : n.ModEq c d\n⊢ n.ModEq (HSub.hSub a c) (HSub.hSub b d)","decl":"@[gcongr]\nprotected theorem sub (h₁ : a ≡ b [ZMOD n]) (h₂ : c ≡ d [ZMOD n]) : a - c ≡ b - d [ZMOD n] := by\n  rw [sub_eq_add_neg, sub_eq_add_neg]\n  exact h₁.add h₂.neg\n\n"}
{"name":"Int.ModEq.sub_left","module":"Mathlib.Data.Int.ModEq","initialProofState":"n a b c : Int\nh : n.ModEq a b\n⊢ n.ModEq (HSub.hSub c a) (HSub.hSub c b)","decl":"@[gcongr] protected theorem sub_left (c : ℤ) (h : a ≡ b [ZMOD n]) : c - a ≡ c - b [ZMOD n] :=\n  ModEq.rfl.sub h\n\n"}
{"name":"Int.ModEq.sub_right","module":"Mathlib.Data.Int.ModEq","initialProofState":"n a b c : Int\nh : n.ModEq a b\n⊢ n.ModEq (HSub.hSub a c) (HSub.hSub b c)","decl":"@[gcongr] protected theorem sub_right (c : ℤ) (h : a ≡ b [ZMOD n]) : a - c ≡ b - c [ZMOD n] :=\n  h.sub ModEq.rfl\n\n"}
{"name":"Int.ModEq.mul_left","module":"Mathlib.Data.Int.ModEq","initialProofState":"n a b c : Int\nh : n.ModEq a b\n⊢ n.ModEq (HMul.hMul c a) (HMul.hMul c b)","decl":"@[gcongr] protected theorem mul_left (c : ℤ) (h : a ≡ b [ZMOD n]) : c * a ≡ c * b [ZMOD n] :=\n  h.mul_left'.of_dvd <| dvd_mul_left _ _\n\n"}
{"name":"Int.ModEq.mul_right","module":"Mathlib.Data.Int.ModEq","initialProofState":"n a b c : Int\nh : n.ModEq a b\n⊢ n.ModEq (HMul.hMul a c) (HMul.hMul b c)","decl":"@[gcongr] protected theorem mul_right (c : ℤ) (h : a ≡ b [ZMOD n]) : a * c ≡ b * c [ZMOD n] :=\n  h.mul_right'.of_dvd <| dvd_mul_right _ _\n\n"}
{"name":"Int.ModEq.mul","module":"Mathlib.Data.Int.ModEq","initialProofState":"n a b c d : Int\nh₁ : n.ModEq a b\nh₂ : n.ModEq c d\n⊢ n.ModEq (HMul.hMul a c) (HMul.hMul b d)","decl":"@[gcongr]\nprotected theorem mul (h₁ : a ≡ b [ZMOD n]) (h₂ : c ≡ d [ZMOD n]) : a * c ≡ b * d [ZMOD n] :=\n  (h₂.mul_left _).trans (h₁.mul_right _)\n\n"}
{"name":"Int.ModEq.pow","module":"Mathlib.Data.Int.ModEq","initialProofState":"n a b : Int\nm : Nat\nh : n.ModEq a b\n⊢ n.ModEq (HPow.hPow a m) (HPow.hPow b m)","decl":"@[gcongr] protected theorem pow (m : ℕ) (h : a ≡ b [ZMOD n]) : a ^ m ≡ b ^ m [ZMOD n] := by\n  induction' m with d hd; · rfl\n  rw [pow_succ, pow_succ]\n  exact hd.mul h\n\n"}
{"name":"Int.ModEq.of_mul_left","module":"Mathlib.Data.Int.ModEq","initialProofState":"n a b m : Int\nh : (HMul.hMul m n).ModEq a b\n⊢ n.ModEq a b","decl":"lemma of_mul_left (m : ℤ) (h : a ≡ b [ZMOD m * n]) : a ≡ b [ZMOD n] := by\n  rw [modEq_iff_dvd] at *; exact (dvd_mul_left n m).trans h\n\n"}
{"name":"Int.ModEq.of_mul_right","module":"Mathlib.Data.Int.ModEq","initialProofState":"n a b m : Int\na✝ : (HMul.hMul n m).ModEq a b\n⊢ n.ModEq a b","decl":"lemma of_mul_right (m : ℤ) : a ≡ b [ZMOD n * m] → a ≡ b [ZMOD n] :=\n  mul_comm m n ▸ of_mul_left _\n\n"}
{"name":"Int.ModEq.cancel_right_div_gcd","module":"Mathlib.Data.Int.ModEq","initialProofState":"m a b c : Int\nhm : LT.lt 0 m\nh : m.ModEq (HMul.hMul a c) (HMul.hMul b c)\n⊢ (HDiv.hDiv m ↑(m.gcd c)).ModEq a b","decl":"/-- To cancel a common factor `c` from a `ModEq` we must divide the modulus `m` by `gcd m c`. -/\ntheorem cancel_right_div_gcd (hm : 0 < m) (h : a * c ≡ b * c [ZMOD m]) :\n    a ≡ b [ZMOD m / gcd m c] := by\n  letI d := gcd m c\n  rw [modEq_iff_dvd] at h ⊢\n  -- Porting note: removed `show` due to https://github.com/leanprover-community/mathlib4/issues/3305\n  refine Int.dvd_of_dvd_mul_right_of_gcd_one (?_ : m / d ∣ c / d * (b - a)) ?_\n  · rw [mul_comm, ← Int.mul_ediv_assoc (b - a) gcd_dvd_right, Int.sub_mul]\n    exact Int.ediv_dvd_ediv gcd_dvd_left h\n  · rw [gcd_div gcd_dvd_left gcd_dvd_right, natAbs_ofNat,\n      Nat.div_self (gcd_pos_of_ne_zero_left c hm.ne')]\n\n"}
{"name":"Int.ModEq.cancel_left_div_gcd","module":"Mathlib.Data.Int.ModEq","initialProofState":"m a b c : Int\nhm : LT.lt 0 m\nh : m.ModEq (HMul.hMul c a) (HMul.hMul c b)\n⊢ (HDiv.hDiv m ↑(m.gcd c)).ModEq a b","decl":"/-- To cancel a common factor `c` from a `ModEq` we must divide the modulus `m` by `gcd m c`. -/\ntheorem cancel_left_div_gcd (hm : 0 < m) (h : c * a ≡ c * b [ZMOD m]) : a ≡ b [ZMOD m / gcd m c] :=\n  cancel_right_div_gcd hm <| by simpa [mul_comm] using h\n\n"}
{"name":"Int.ModEq.of_div","module":"Mathlib.Data.Int.ModEq","initialProofState":"m a b c : Int\nh : (HDiv.hDiv m c).ModEq (HDiv.hDiv a c) (HDiv.hDiv b c)\nha✝¹ : Dvd.dvd c a\nha✝ : Dvd.dvd c b\nha : Dvd.dvd c m\n⊢ m.ModEq a b","decl":"theorem of_div (h : a / c ≡ b / c [ZMOD m / c]) (ha : c ∣ a) (ha : c ∣ b) (ha : c ∣ m) :\n    a ≡ b [ZMOD m] := by convert h.mul_left' <;> rwa [Int.mul_ediv_cancel']\n\n"}
{"name":"Int.modEq_one","module":"Mathlib.Data.Int.ModEq","initialProofState":"a b : Int\n⊢ Int.ModEq 1 a b","decl":"theorem modEq_one : a ≡ b [ZMOD 1] :=\n  modEq_of_dvd (one_dvd _)\n\n"}
{"name":"Int.modEq_sub","module":"Mathlib.Data.Int.ModEq","initialProofState":"a b : Int\n⊢ (HSub.hSub a b).ModEq a b","decl":"theorem modEq_sub (a b : ℤ) : a ≡ b [ZMOD a - b] :=\n  (modEq_of_dvd dvd_rfl).symm\n\n"}
{"name":"Int.modEq_zero_iff","module":"Mathlib.Data.Int.ModEq","initialProofState":"a b : Int\n⊢ Iff (Int.ModEq 0 a b) (Eq a b)","decl":"@[simp]\ntheorem modEq_zero_iff : a ≡ b [ZMOD 0] ↔ a = b := by rw [ModEq, emod_zero, emod_zero]\n\n"}
{"name":"Int.add_modEq_left","module":"Mathlib.Data.Int.ModEq","initialProofState":"n a : Int\n⊢ n.ModEq (HAdd.hAdd n a) a","decl":"@[simp]\ntheorem add_modEq_left : n + a ≡ a [ZMOD n] := ModEq.symm <| modEq_iff_dvd.2 <| by simp\n\n"}
{"name":"Int.add_modEq_right","module":"Mathlib.Data.Int.ModEq","initialProofState":"n a : Int\n⊢ n.ModEq (HAdd.hAdd a n) a","decl":"@[simp]\ntheorem add_modEq_right : a + n ≡ a [ZMOD n] := ModEq.symm <| modEq_iff_dvd.2 <| by simp\n\n"}
{"name":"Int.modEq_and_modEq_iff_modEq_mul","module":"Mathlib.Data.Int.ModEq","initialProofState":"a b m n : Int\nhmn : m.natAbs.Coprime n.natAbs\n⊢ Iff (And (m.ModEq a b) (n.ModEq a b)) ((HMul.hMul m n).ModEq a b)","decl":"theorem modEq_and_modEq_iff_modEq_mul {a b m n : ℤ} (hmn : m.natAbs.Coprime n.natAbs) :\n    a ≡ b [ZMOD m] ∧ a ≡ b [ZMOD n] ↔ a ≡ b [ZMOD m * n] :=\n  ⟨fun h => by\n    rw [modEq_iff_dvd, modEq_iff_dvd] at h\n    rw [modEq_iff_dvd, ← natAbs_dvd, ← dvd_natAbs, natCast_dvd_natCast, natAbs_mul]\n    refine hmn.mul_dvd_of_dvd_of_dvd ?_ ?_ <;>\n      rw [← natCast_dvd_natCast, natAbs_dvd, dvd_natAbs] <;>\n      tauto,\n    fun h => ⟨h.of_mul_right _, h.of_mul_left _⟩⟩\n\n"}
{"name":"Int.gcd_a_modEq","module":"Mathlib.Data.Int.ModEq","initialProofState":"a b : Nat\n⊢ (↑b).ModEq (HMul.hMul (↑a) (a.gcdA b)) ↑(a.gcd b)","decl":"theorem gcd_a_modEq (a b : ℕ) : (a : ℤ) * Nat.gcdA a b ≡ Nat.gcd a b [ZMOD b] := by\n  rw [← add_zero ((a : ℤ) * _), Nat.gcd_eq_gcd_ab]\n  exact (dvd_mul_right _ _).zero_modEq_int.add_left _\n\n"}
{"name":"Int.modEq_add_fac","module":"Mathlib.Data.Int.ModEq","initialProofState":"a b n c : Int\nha : n.ModEq a b\n⊢ n.ModEq (HAdd.hAdd a (HMul.hMul n c)) b","decl":"theorem modEq_add_fac {a b n : ℤ} (c : ℤ) (ha : a ≡ b [ZMOD n]) : a + n * c ≡ b [ZMOD n] :=\n  calc\n    a + n * c ≡ b + n * c [ZMOD n] := ha.add_right _\n    _ ≡ b + 0 [ZMOD n] := (dvd_mul_right _ _).modEq_zero_int.add_left _\n    _ ≡ b [ZMOD n] := by rw [add_zero]\n\n"}
{"name":"Int.modEq_sub_fac","module":"Mathlib.Data.Int.ModEq","initialProofState":"a b n c : Int\nha : n.ModEq a b\n⊢ n.ModEq (HSub.hSub a (HMul.hMul n c)) b","decl":"theorem modEq_sub_fac {a b n : ℤ} (c : ℤ) (ha : a ≡ b [ZMOD n]) : a - n * c ≡ b [ZMOD n] := by\n  convert Int.modEq_add_fac (-c) ha using 1; rw [Int.mul_neg, sub_eq_add_neg]\n\n"}
{"name":"Int.modEq_add_fac_self","module":"Mathlib.Data.Int.ModEq","initialProofState":"a t n : Int\n⊢ n.ModEq (HAdd.hAdd a (HMul.hMul n t)) a","decl":"theorem modEq_add_fac_self {a t n : ℤ} : a + n * t ≡ a [ZMOD n] :=\n  modEq_add_fac _ ModEq.rfl\n\n"}
{"name":"Int.mod_coprime","module":"Mathlib.Data.Int.ModEq","initialProofState":"a b : Nat\nhab : a.Coprime b\n⊢ Exists fun y => (↑b).ModEq (HMul.hMul (↑a) y) 1","decl":"theorem mod_coprime {a b : ℕ} (hab : Nat.Coprime a b) : ∃ y : ℤ, a * y ≡ 1 [ZMOD b] :=\n  ⟨Nat.gcdA a b,\n    have hgcd : Nat.gcd a b = 1 := Nat.Coprime.gcd_eq_one hab\n    calc\n      ↑a * Nat.gcdA a b ≡ ↑a * Nat.gcdA a b + ↑b * Nat.gcdB a b [ZMOD ↑b] :=\n        ModEq.symm <| modEq_add_fac _ <| ModEq.refl _\n      _ ≡ 1 [ZMOD ↑b] := by rw [← Nat.gcd_eq_gcd_ab, hgcd]; rfl\n      ⟩\n\n"}
{"name":"Int.existsUnique_equiv","module":"Mathlib.Data.Int.ModEq","initialProofState":"a b : Int\nhb : LT.lt 0 b\n⊢ Exists fun z => And (LE.le 0 z) (And (LT.lt z b) (b.ModEq z a))","decl":"theorem existsUnique_equiv (a : ℤ) {b : ℤ} (hb : 0 < b) :\n    ∃ z : ℤ, 0 ≤ z ∧ z < b ∧ z ≡ a [ZMOD b] :=\n  ⟨a % b, emod_nonneg _ (ne_of_gt hb),\n    by\n      have : a % b < |b| := emod_lt _ (ne_of_gt hb)\n      rwa [abs_of_pos hb] at this, by simp [ModEq]⟩\n\n"}
{"name":"Int.exists_unique_equiv","module":"Mathlib.Data.Int.ModEq","initialProofState":"a b : Int\nhb : LT.lt 0 b\n⊢ Exists fun z => And (LE.le 0 z) (And (LT.lt z b) (b.ModEq z a))","decl":"@[deprecated (since := \"2024-12-17\")] alias exists_unique_equiv := existsUnique_equiv\n\n"}
{"name":"Int.existsUnique_equiv_nat","module":"Mathlib.Data.Int.ModEq","initialProofState":"a b : Int\nhb : LT.lt 0 b\n⊢ Exists fun z => And (LT.lt (↑z) b) (b.ModEq (↑z) a)","decl":"theorem existsUnique_equiv_nat (a : ℤ) {b : ℤ} (hb : 0 < b) : ∃ z : ℕ, ↑z < b ∧ ↑z ≡ a [ZMOD b] :=\n  let ⟨z, hz1, hz2, hz3⟩ := existsUnique_equiv a hb\n  ⟨z.natAbs, by\n    constructor <;> rw [natAbs_of_nonneg hz1] <;> assumption⟩\n\n"}
{"name":"Int.exists_unique_equiv_nat","module":"Mathlib.Data.Int.ModEq","initialProofState":"a b : Int\nhb : LT.lt 0 b\n⊢ Exists fun z => And (LT.lt (↑z) b) (b.ModEq (↑z) a)","decl":"@[deprecated (since := \"2024-12-17\")] alias exists_unique_equiv_nat := existsUnique_equiv_nat\n\n"}
{"name":"Int.mod_mul_right_mod","module":"Mathlib.Data.Int.ModEq","initialProofState":"a b c : Int\n⊢ Eq (HMod.hMod (HMod.hMod a (HMul.hMul b c)) b) (HMod.hMod a b)","decl":"theorem mod_mul_right_mod (a b c : ℤ) : a % (b * c) % b = a % b :=\n  (mod_modEq _ _).of_mul_right _\n\n"}
{"name":"Int.mod_mul_left_mod","module":"Mathlib.Data.Int.ModEq","initialProofState":"a b c : Int\n⊢ Eq (HMod.hMod (HMod.hMod a (HMul.hMul b c)) c) (HMod.hMod a c)","decl":"theorem mod_mul_left_mod (a b c : ℤ) : a % (b * c) % c = a % c :=\n  (mod_modEq _ _).of_mul_left _\n\n"}
