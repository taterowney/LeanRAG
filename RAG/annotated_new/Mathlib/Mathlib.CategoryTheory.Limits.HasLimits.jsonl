{"name":"CategoryTheory.Limits.LimitCone.mk.injEq","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\nconeâœ : CategoryTheory.Limits.Cone F\nisLimitâœ : CategoryTheory.Limits.IsLimit coneâœ\ncone : CategoryTheory.Limits.Cone F\nisLimit : CategoryTheory.Limits.IsLimit cone\nâŠ¢ Eq (Eq { cone := coneâœ, isLimit := isLimitâœ } { cone := cone, isLimit := isLimit }) (And (Eq coneâœ cone) (HEq isLimitâœ isLimit))","decl":"/-- `LimitCone F` contains a cone over `F` together with the information that it is a limit. -/\nstructure LimitCone (F : J â¥¤ C) where\n  /-- The cone itself -/\n  cone : Cone F\n  /-- The proof that is the limit cone -/\n  isLimit : IsLimit cone\n\n"}
{"name":"CategoryTheory.Limits.LimitCone.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœÂ¹ : SizeOf J\ninstâœ : SizeOf C\ncone : CategoryTheory.Limits.Cone F\nisLimit : CategoryTheory.Limits.IsLimit cone\nâŠ¢ Eq (SizeOf.sizeOf { cone := cone, isLimit := isLimit }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf cone)) (SizeOf.sizeOf isLimit))","decl":"/-- `LimitCone F` contains a cone over `F` together with the information that it is a limit. -/\nstructure LimitCone (F : J â¥¤ C) where\n  /-- The cone itself -/\n  cone : Cone F\n  /-- The proof that is the limit cone -/\n  isLimit : IsLimit cone\n\n"}
{"name":"CategoryTheory.Limits.LimitCone.mk.inj","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\nconeâœ : CategoryTheory.Limits.Cone F\nisLimitâœ : CategoryTheory.Limits.IsLimit coneâœ\ncone : CategoryTheory.Limits.Cone F\nisLimit : CategoryTheory.Limits.IsLimit cone\nxâœ : Eq { cone := coneâœ, isLimit := isLimitâœ } { cone := cone, isLimit := isLimit }\nâŠ¢ And (Eq coneâœ cone) (HEq isLimitâœ isLimit)","decl":"/-- `LimitCone F` contains a cone over `F` together with the information that it is a limit. -/\nstructure LimitCone (F : J â¥¤ C) where\n  /-- The cone itself -/\n  cone : Cone F\n  /-- The proof that is the limit cone -/\n  isLimit : IsLimit cone\n\n"}
{"name":"CategoryTheory.Limits.HasLimit.exists_limit","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\nself : CategoryTheory.Limits.HasLimit F\nâŠ¢ Nonempty (CategoryTheory.Limits.LimitCone F)","decl":"/-- `HasLimit F` represents the mere existence of a limit for `F`. -/\nclass HasLimit (F : J â¥¤ C) : Prop where mk' ::\n  /-- There is some limit cone for `F` -/\n  exists_limit : Nonempty (LimitCone F)\n\n"}
{"name":"CategoryTheory.Limits.HasLimit.mk","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\nd : CategoryTheory.Limits.LimitCone F\nâŠ¢ CategoryTheory.Limits.HasLimit F","decl":"theorem HasLimit.mk {F : J â¥¤ C} (d : LimitCone F) : HasLimit F :=\n  âŸ¨Nonempty.intro dâŸ©\n\n"}
{"name":"CategoryTheory.Limits.HasLimitsOfShape.has_limit","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.Limits.HasLimitsOfShape J C\nF : CategoryTheory.Functor J C\nâŠ¢ CategoryTheory.Limits.HasLimit F","decl":"/-- `C` has limits of shape `J` if there exists a limit for every functor `F : J â¥¤ C`. -/\nclass HasLimitsOfShape : Prop where\n  /-- All functors `F : J â¥¤ C` from `J` have limits -/\n  has_limit : âˆ€ F : J â¥¤ C, HasLimit F := by infer_instance\n\n"}
{"name":"CategoryTheory.Limits.HasLimitsOfSize.has_limits_of_shape","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.Limits.HasLimitsOfSize.{vâ‚, uâ‚, v, u} C\nJ : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} J\nâŠ¢ CategoryTheory.Limits.HasLimitsOfShape J C","decl":"/-- `C` has all limits of size `vâ‚ uâ‚` (`HasLimitsOfSize.{vâ‚ uâ‚} C`)\nif it has limits of every shape `J : Type uâ‚` with `[Category.{vâ‚} J]`.\n-/\n@[pp_with_univ]\nclass HasLimitsOfSize (C : Type u) [Category.{v} C] : Prop where\n  /-- All functors `F : J â¥¤ C` from all small `J` have limits -/\n  has_limits_of_shape : âˆ€ (J : Type uâ‚) [Category.{vâ‚} J], HasLimitsOfShape J C := by\n    infer_instance\n\n"}
{"name":"CategoryTheory.Limits.HasLimits.has_limits_of_shape","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasLimits C\nJ : Type v\ninstâœ : CategoryTheory.Category.{v, v} J\nâŠ¢ CategoryTheory.Limits.HasLimitsOfShape J C","decl":"theorem HasLimits.has_limits_of_shape {C : Type u} [Category.{v} C] [HasLimits C] (J : Type v)\n    [Category.{v} J] : HasLimitsOfShape J C :=\n  HasLimitsOfSize.has_limits_of_shape J\n\n"}
{"name":"CategoryTheory.Limits.hasLimitOfHasLimitsOfShape","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nJ : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} J\ninstâœ : CategoryTheory.Limits.HasLimitsOfShape J C\nF : CategoryTheory.Functor J C\nâŠ¢ CategoryTheory.Limits.HasLimit F","decl":"instance (priority := 100) hasLimitOfHasLimitsOfShape {J : Type uâ‚} [Category.{vâ‚} J]\n    [HasLimitsOfShape J C] (F : J â¥¤ C) : HasLimit F :=\n  HasLimitsOfShape.has_limit F\n\n-- see Note [lower instance priority]\n"}
{"name":"CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nJ : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} J\ninstâœ : CategoryTheory.Limits.HasLimitsOfSize.{vâ‚, uâ‚, v, u} C\nâŠ¢ CategoryTheory.Limits.HasLimitsOfShape J C","decl":"instance (priority := 100) hasLimitsOfShapeOfHasLimits {J : Type uâ‚} [Category.{vâ‚} J]\n    [HasLimitsOfSize.{vâ‚, uâ‚} C] : HasLimitsOfShape J C :=\n  HasLimitsOfSize.has_limits_of_shape J\n\n-- Interface to the `HasLimit` class.\n"}
{"name":"CategoryTheory.Limits.limit.Ï€_comp_eqToHom_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœ : CategoryTheory.Limits.HasLimit F\nj j' : J\nhj : Eq j j'\nZ : C\nh : Quiver.Hom (F.obj j') Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ F j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom â‹¯) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ F j') h)","decl":"@[reassoc]\ntheorem limit.Ï€_comp_eqToHom (F : J â¥¤ C) [HasLimit F] {j j' : J} (hj : j = j') :\n    limit.Ï€ F j â‰« eqToHom (by subst hj; rfl) = limit.Ï€ F j' := by\n  subst hj\n  simp\n\n"}
{"name":"CategoryTheory.Limits.limit.Ï€_comp_eqToHom","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœ : CategoryTheory.Limits.HasLimit F\nj j' : J\nhj : Eq j j'\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ F j) (CategoryTheory.eqToHom â‹¯)) (CategoryTheory.Limits.limit.Ï€ F j')","decl":"@[reassoc]\ntheorem limit.Ï€_comp_eqToHom (F : J â¥¤ C) [HasLimit F] {j j' : J} (hj : j = j') :\n    limit.Ï€ F j â‰« eqToHom (by subst hj; rfl) = limit.Ï€ F j' := by\n  subst hj\n  simp\n\n"}
{"name":"CategoryTheory.Limits.limit.cone_x","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœ : CategoryTheory.Limits.HasLimit F\nâŠ¢ Eq (CategoryTheory.Limits.limit.cone F).pt (CategoryTheory.Limits.limit F)","decl":"@[simp]\ntheorem limit.cone_x {F : J â¥¤ C} [HasLimit F] : (limit.cone F).pt = limit F :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.limit.cone_Ï€","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœ : CategoryTheory.Limits.HasLimit F\nâŠ¢ Eq (CategoryTheory.Limits.limit.cone F).Ï€.app (CategoryTheory.Limits.limit.Ï€ F)","decl":"@[simp]\ntheorem limit.cone_Ï€ {F : J â¥¤ C} [HasLimit F] : (limit.cone F).Ï€.app = limit.Ï€ _ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.limit.w_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœ : CategoryTheory.Limits.HasLimit F\nj j' : J\nf : Quiver.Hom j j'\nZ : C\nh : Quiver.Hom (F.obj j') Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ F j) (CategoryTheory.CategoryStruct.comp (F.map f) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ F j') h)","decl":"@[reassoc (attr := simp)]\ntheorem limit.w (F : J â¥¤ C) [HasLimit F] {j j' : J} (f : j âŸ¶ j') :\n    limit.Ï€ F j â‰« F.map f = limit.Ï€ F j' :=\n  (limit.cone F).w f\n\n"}
{"name":"CategoryTheory.Limits.limit.w","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœ : CategoryTheory.Limits.HasLimit F\nj j' : J\nf : Quiver.Hom j j'\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ F j) (F.map f)) (CategoryTheory.Limits.limit.Ï€ F j')","decl":"@[reassoc (attr := simp)]\ntheorem limit.w (F : J â¥¤ C) [HasLimit F] {j j' : J} (f : j âŸ¶ j') :\n    limit.Ï€ F j â‰« F.map f = limit.Ï€ F j' :=\n  (limit.cone F).w f\n\n"}
{"name":"CategoryTheory.Limits.limit.isLimit_lift","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœ : CategoryTheory.Limits.HasLimit F\nc : CategoryTheory.Limits.Cone F\nâŠ¢ Eq ((CategoryTheory.Limits.limit.isLimit F).lift c) (CategoryTheory.Limits.limit.lift F c)","decl":"@[simp]\ntheorem limit.isLimit_lift {F : J â¥¤ C} [HasLimit F] (c : Cone F) :\n    (limit.isLimit F).lift c = limit.lift F c :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.limit.lift_Ï€_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœ : CategoryTheory.Limits.HasLimit F\nc : CategoryTheory.Limits.Cone F\nj : J\nZ : C\nh : Quiver.Hom (F.obj j) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.lift F c) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ F j) h)) (CategoryTheory.CategoryStruct.comp (c.Ï€.app j) h)","decl":"@[reassoc (attr := simp)]\ntheorem limit.lift_Ï€ {F : J â¥¤ C} [HasLimit F] (c : Cone F) (j : J) :\n    limit.lift F c â‰« limit.Ï€ F j = c.Ï€.app j :=\n  IsLimit.fac _ c j\n\n"}
{"name":"CategoryTheory.Limits.limit.lift_Ï€","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœ : CategoryTheory.Limits.HasLimit F\nc : CategoryTheory.Limits.Cone F\nj : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.lift F c) (CategoryTheory.Limits.limit.Ï€ F j)) (c.Ï€.app j)","decl":"@[reassoc (attr := simp)]\ntheorem limit.lift_Ï€ {F : J â¥¤ C} [HasLimit F] (c : Cone F) (j : J) :\n    limit.lift F c â‰« limit.Ï€ F j = c.Ï€.app j :=\n  IsLimit.fac _ c j\n\n"}
{"name":"CategoryTheory.Limits.limMap_Ï€_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor J C\ninstâœÂ¹ : CategoryTheory.Limits.HasLimit F\ninstâœ : CategoryTheory.Limits.HasLimit G\nÎ± : Quiver.Hom F G\nj : J\nZ : C\nh : Quiver.Hom (G.obj j) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limMap Î±) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ G j) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ F j) (CategoryTheory.CategoryStruct.comp (Î±.app j) h))","decl":"@[reassoc (attr := simp)]\ntheorem limMap_Ï€ {F G : J â¥¤ C} [HasLimit F] [HasLimit G] (Î± : F âŸ¶ G) (j : J) :\n    limMap Î± â‰« limit.Ï€ G j = limit.Ï€ F j â‰« Î±.app j :=\n  limit.lift_Ï€ _ j\n\n"}
{"name":"CategoryTheory.Limits.limMap_Ï€","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor J C\ninstâœÂ¹ : CategoryTheory.Limits.HasLimit F\ninstâœ : CategoryTheory.Limits.HasLimit G\nÎ± : Quiver.Hom F G\nj : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limMap Î±) (CategoryTheory.Limits.limit.Ï€ G j)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ F j) (Î±.app j))","decl":"@[reassoc (attr := simp)]\ntheorem limMap_Ï€ {F G : J â¥¤ C} [HasLimit F] [HasLimit G] (Î± : F âŸ¶ G) (j : J) :\n    limMap Î± â‰« limit.Ï€ G j = limit.Ï€ F j â‰« Î±.app j :=\n  limit.lift_Ï€ _ j\n\n"}
{"name":"CategoryTheory.Limits.limit.coneMorphism_hom","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœ : CategoryTheory.Limits.HasLimit F\nc : CategoryTheory.Limits.Cone F\nâŠ¢ Eq (CategoryTheory.Limits.limit.coneMorphism c).hom (CategoryTheory.Limits.limit.lift F c)","decl":"@[simp]\ntheorem limit.coneMorphism_hom {F : J â¥¤ C} [HasLimit F] (c : Cone F) :\n    (limit.coneMorphism c).hom = limit.lift F c :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.limit.coneMorphism_Ï€","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœ : CategoryTheory.Limits.HasLimit F\nc : CategoryTheory.Limits.Cone F\nj : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.coneMorphism c).hom (CategoryTheory.Limits.limit.Ï€ F j)) (c.Ï€.app j)","decl":"theorem limit.coneMorphism_Ï€ {F : J â¥¤ C} [HasLimit F] (c : Cone F) (j : J) :\n    (limit.coneMorphism c).hom â‰« limit.Ï€ F j = c.Ï€.app j := by simp\n\n"}
{"name":"CategoryTheory.Limits.limit.conePointUniqueUpToIso_hom_comp","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœ : CategoryTheory.Limits.HasLimit F\nc : CategoryTheory.Limits.Cone F\nhc : CategoryTheory.Limits.IsLimit c\nj : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (hc.conePointUniqueUpToIso (CategoryTheory.Limits.limit.isLimit F)).hom (CategoryTheory.Limits.limit.Ï€ F j)) (c.Ï€.app j)","decl":"@[reassoc (attr := simp)]\ntheorem limit.conePointUniqueUpToIso_hom_comp {F : J â¥¤ C} [HasLimit F] {c : Cone F} (hc : IsLimit c)\n    (j : J) : (IsLimit.conePointUniqueUpToIso hc (limit.isLimit _)).hom â‰« limit.Ï€ F j = c.Ï€.app j :=\n  IsLimit.conePointUniqueUpToIso_hom_comp _ _ _\n\n"}
{"name":"CategoryTheory.Limits.limit.conePointUniqueUpToIso_hom_comp_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœ : CategoryTheory.Limits.HasLimit F\nc : CategoryTheory.Limits.Cone F\nhc : CategoryTheory.Limits.IsLimit c\nj : J\nZ : C\nh : Quiver.Hom (F.obj j) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (hc.conePointUniqueUpToIso (CategoryTheory.Limits.limit.isLimit F)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ F j) h)) (CategoryTheory.CategoryStruct.comp (c.Ï€.app j) h)","decl":"@[reassoc (attr := simp)]\ntheorem limit.conePointUniqueUpToIso_hom_comp {F : J â¥¤ C} [HasLimit F] {c : Cone F} (hc : IsLimit c)\n    (j : J) : (IsLimit.conePointUniqueUpToIso hc (limit.isLimit _)).hom â‰« limit.Ï€ F j = c.Ï€.app j :=\n  IsLimit.conePointUniqueUpToIso_hom_comp _ _ _\n\n"}
{"name":"CategoryTheory.Limits.limit.conePointUniqueUpToIso_inv_comp","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœ : CategoryTheory.Limits.HasLimit F\nc : CategoryTheory.Limits.Cone F\nhc : CategoryTheory.Limits.IsLimit c\nj : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Limits.limit.isLimit F).conePointUniqueUpToIso hc).inv (CategoryTheory.Limits.limit.Ï€ F j)) (c.Ï€.app j)","decl":"@[reassoc (attr := simp)]\ntheorem limit.conePointUniqueUpToIso_inv_comp {F : J â¥¤ C} [HasLimit F] {c : Cone F} (hc : IsLimit c)\n    (j : J) : (IsLimit.conePointUniqueUpToIso (limit.isLimit _) hc).inv â‰« limit.Ï€ F j = c.Ï€.app j :=\n  IsLimit.conePointUniqueUpToIso_inv_comp _ _ _\n\n"}
{"name":"CategoryTheory.Limits.limit.conePointUniqueUpToIso_inv_comp_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœ : CategoryTheory.Limits.HasLimit F\nc : CategoryTheory.Limits.Cone F\nhc : CategoryTheory.Limits.IsLimit c\nj : J\nZ : C\nh : Quiver.Hom (F.obj j) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Limits.limit.isLimit F).conePointUniqueUpToIso hc).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ F j) h)) (CategoryTheory.CategoryStruct.comp (c.Ï€.app j) h)","decl":"@[reassoc (attr := simp)]\ntheorem limit.conePointUniqueUpToIso_inv_comp {F : J â¥¤ C} [HasLimit F] {c : Cone F} (hc : IsLimit c)\n    (j : J) : (IsLimit.conePointUniqueUpToIso (limit.isLimit _) hc).inv â‰« limit.Ï€ F j = c.Ï€.app j :=\n  IsLimit.conePointUniqueUpToIso_inv_comp _ _ _\n\n"}
{"name":"CategoryTheory.Limits.limit.existsUnique","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœ : CategoryTheory.Limits.HasLimit F\nt : CategoryTheory.Limits.Cone F\nâŠ¢ ExistsUnique fun l => âˆ€ (j : J), Eq (CategoryTheory.CategoryStruct.comp l (CategoryTheory.Limits.limit.Ï€ F j)) (t.Ï€.app j)","decl":"theorem limit.existsUnique {F : J â¥¤ C} [HasLimit F] (t : Cone F) :\n    âˆƒ! l : t.pt âŸ¶ limit F, âˆ€ j, l â‰« limit.Ï€ F j = t.Ï€.app j :=\n  (limit.isLimit F).existsUnique _\n\n"}
{"name":"CategoryTheory.Limits.limit.isoLimitCone_hom_Ï€","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœ : CategoryTheory.Limits.HasLimit F\nt : CategoryTheory.Limits.LimitCone F\nj : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.isoLimitCone t).hom (t.cone.Ï€.app j)) (CategoryTheory.Limits.limit.Ï€ F j)","decl":"@[reassoc (attr := simp)]\ntheorem limit.isoLimitCone_hom_Ï€ {F : J â¥¤ C} [HasLimit F] (t : LimitCone F) (j : J) :\n    (limit.isoLimitCone t).hom â‰« t.cone.Ï€.app j = limit.Ï€ F j := by\n  dsimp [limit.isoLimitCone, IsLimit.conePointUniqueUpToIso]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.limit.isoLimitCone_hom_Ï€_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœ : CategoryTheory.Limits.HasLimit F\nt : CategoryTheory.Limits.LimitCone F\nj : J\nZ : C\nh : Quiver.Hom (F.obj j) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.isoLimitCone t).hom (CategoryTheory.CategoryStruct.comp (t.cone.Ï€.app j) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ F j) h)","decl":"@[reassoc (attr := simp)]\ntheorem limit.isoLimitCone_hom_Ï€ {F : J â¥¤ C} [HasLimit F] (t : LimitCone F) (j : J) :\n    (limit.isoLimitCone t).hom â‰« t.cone.Ï€.app j = limit.Ï€ F j := by\n  dsimp [limit.isoLimitCone, IsLimit.conePointUniqueUpToIso]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.limit.isoLimitCone_inv_Ï€","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœ : CategoryTheory.Limits.HasLimit F\nt : CategoryTheory.Limits.LimitCone F\nj : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.isoLimitCone t).inv (CategoryTheory.Limits.limit.Ï€ F j)) (t.cone.Ï€.app j)","decl":"@[reassoc (attr := simp)]\ntheorem limit.isoLimitCone_inv_Ï€ {F : J â¥¤ C} [HasLimit F] (t : LimitCone F) (j : J) :\n    (limit.isoLimitCone t).inv â‰« limit.Ï€ F j = t.cone.Ï€.app j := by\n  dsimp [limit.isoLimitCone, IsLimit.conePointUniqueUpToIso]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.limit.isoLimitCone_inv_Ï€_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœ : CategoryTheory.Limits.HasLimit F\nt : CategoryTheory.Limits.LimitCone F\nj : J\nZ : C\nh : Quiver.Hom (F.obj j) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.isoLimitCone t).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ F j) h)) (CategoryTheory.CategoryStruct.comp (t.cone.Ï€.app j) h)","decl":"@[reassoc (attr := simp)]\ntheorem limit.isoLimitCone_inv_Ï€ {F : J â¥¤ C} [HasLimit F] (t : LimitCone F) (j : J) :\n    (limit.isoLimitCone t).inv â‰« limit.Ï€ F j = t.cone.Ï€.app j := by\n  dsimp [limit.isoLimitCone, IsLimit.conePointUniqueUpToIso]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.limit.hom_ext","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœ : CategoryTheory.Limits.HasLimit F\nX : C\nf f' : Quiver.Hom X (CategoryTheory.Limits.limit F)\nw : âˆ€ (j : J), Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.Limits.limit.Ï€ F j)) (CategoryTheory.CategoryStruct.comp f' (CategoryTheory.Limits.limit.Ï€ F j))\nâŠ¢ Eq f f'","decl":"@[ext]\ntheorem limit.hom_ext {F : J â¥¤ C} [HasLimit F] {X : C} {f f' : X âŸ¶ limit F}\n    (w : âˆ€ j, f â‰« limit.Ï€ F j = f' â‰« limit.Ï€ F j) : f = f' :=\n  (limit.isLimit F).hom_ext w\n\n"}
{"name":"CategoryTheory.Limits.limit.hom_ext_iff","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœ : CategoryTheory.Limits.HasLimit F\nX : C\nf f' : Quiver.Hom X (CategoryTheory.Limits.limit F)\nâŠ¢ Iff (Eq f f') (âˆ€ (j : J), Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.Limits.limit.Ï€ F j)) (CategoryTheory.CategoryStruct.comp f' (CategoryTheory.Limits.limit.Ï€ F j)))","decl":"@[ext]\ntheorem limit.hom_ext {F : J â¥¤ C} [HasLimit F] {X : C} {f f' : X âŸ¶ limit F}\n    (w : âˆ€ j, f â‰« limit.Ï€ F j = f' â‰« limit.Ï€ F j) : f = f' :=\n  (limit.isLimit F).hom_ext w\n\n"}
{"name":"CategoryTheory.Limits.limit.lift_map","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor J C\ninstâœÂ¹ : CategoryTheory.Limits.HasLimit F\ninstâœ : CategoryTheory.Limits.HasLimit G\nc : CategoryTheory.Limits.Cone F\nÎ± : Quiver.Hom F G\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.lift F c) (CategoryTheory.Limits.limMap Î±)) (CategoryTheory.Limits.limit.lift G ((CategoryTheory.Limits.Cones.postcompose Î±).obj c))","decl":"@[reassoc (attr := simp)]\ntheorem limit.lift_map {F G : J â¥¤ C} [HasLimit F] [HasLimit G] (c : Cone F) (Î± : F âŸ¶ G) :\n    limit.lift F c â‰« limMap Î± = limit.lift G ((Cones.postcompose Î±).obj c) := by\n  ext\n  rw [assoc, limMap_Ï€, limit.lift_Ï€_assoc, limit.lift_Ï€]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.limit.lift_map_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor J C\ninstâœÂ¹ : CategoryTheory.Limits.HasLimit F\ninstâœ : CategoryTheory.Limits.HasLimit G\nc : CategoryTheory.Limits.Cone F\nÎ± : Quiver.Hom F G\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.limit G) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.lift F c) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limMap Î±) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.lift G ((CategoryTheory.Limits.Cones.postcompose Î±).obj c)) h)","decl":"@[reassoc (attr := simp)]\ntheorem limit.lift_map {F G : J â¥¤ C} [HasLimit F] [HasLimit G] (c : Cone F) (Î± : F âŸ¶ G) :\n    limit.lift F c â‰« limMap Î± = limit.lift G ((Cones.postcompose Î±).obj c) := by\n  ext\n  rw [assoc, limMap_Ï€, limit.lift_Ï€_assoc, limit.lift_Ï€]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.limit.lift_cone","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœ : CategoryTheory.Limits.HasLimit F\nâŠ¢ Eq (CategoryTheory.Limits.limit.lift F (CategoryTheory.Limits.limit.cone F)) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.limit F))","decl":"@[simp]\ntheorem limit.lift_cone {F : J â¥¤ C} [HasLimit F] : limit.lift F (limit.cone F) = ğŸ™ (limit F) :=\n  (limit.isLimit _).lift_self\n\n"}
{"name":"CategoryTheory.Limits.limit.homIso_hom","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœ : CategoryTheory.Limits.HasLimit F\nW : C\nf : ULift.{uâ‚, v} (Quiver.Hom W (CategoryTheory.Limits.limit F))\nâŠ¢ Eq ((CategoryTheory.Limits.limit.homIso F W).hom f) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.const J).map f.down) (CategoryTheory.Limits.limit.cone F).Ï€)","decl":"@[simp]\ntheorem limit.homIso_hom (F : J â¥¤ C) [HasLimit F] {W : C} (f : ULift (W âŸ¶ limit F)) :\n    (limit.homIso F W).hom f = (const J).map f.down â‰« (limit.cone F).Ï€ :=\n  (limit.isLimit F).homIso_hom f\n\n"}
{"name":"CategoryTheory.Limits.limit.lift_extend","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœ : CategoryTheory.Limits.HasLimit F\nc : CategoryTheory.Limits.Cone F\nX : C\nf : Quiver.Hom X c.pt\nâŠ¢ Eq (CategoryTheory.Limits.limit.lift F (c.extend f)) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.Limits.limit.lift F c))","decl":"theorem limit.lift_extend {F : J â¥¤ C} [HasLimit F] (c : Cone F) {X : C} (f : X âŸ¶ c.pt) :\n    limit.lift F (c.extend f) = f â‰« limit.lift F c := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.hasLimitOfIso","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor J C\ninstâœ : CategoryTheory.Limits.HasLimit F\nÎ± : CategoryTheory.Iso F G\nâŠ¢ CategoryTheory.Limits.HasLimit G","decl":"/-- If a functor `F` has a limit, so does any naturally isomorphic functor.\n-/\ntheorem hasLimitOfIso {F G : J â¥¤ C} [HasLimit F] (Î± : F â‰… G) : HasLimit G :=\n  HasLimit.mk\n    { cone := (Cones.postcompose Î±.hom).obj (limit.cone F)\n      isLimit := (IsLimit.postcomposeHomEquiv _ _).symm (limit.isLimit F) }\n\n-- See the construction of limits from products and equalizers\n-- for an example usage.\n"}
{"name":"CategoryTheory.Limits.HasLimit.ofConesIso","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\nJ K : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚} K\nF : CategoryTheory.Functor J C\nG : CategoryTheory.Functor K C\nh : CategoryTheory.Iso F.cones G.cones\ninstâœ : CategoryTheory.Limits.HasLimit F\nâŠ¢ CategoryTheory.Limits.HasLimit G","decl":"/-- If a functor `G` has the same collection of cones as a functor `F`\nwhich has a limit, then `G` also has a limit. -/\ntheorem HasLimit.ofConesIso {J K : Type uâ‚} [Category.{vâ‚} J] [Category.{vâ‚‚} K] (F : J â¥¤ C)\n    (G : K â¥¤ C) (h : F.cones â‰… G.cones) [HasLimit F] : HasLimit G :=\n  HasLimit.mk âŸ¨_, IsLimit.ofNatIso (IsLimit.natIso (limit.isLimit F) â‰ªâ‰« h)âŸ©\n\n"}
{"name":"CategoryTheory.Limits.HasLimit.isoOfNatIso_hom_Ï€","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor J C\ninstâœÂ¹ : CategoryTheory.Limits.HasLimit F\ninstâœ : CategoryTheory.Limits.HasLimit G\nw : CategoryTheory.Iso F G\nj : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.HasLimit.isoOfNatIso w).hom (CategoryTheory.Limits.limit.Ï€ G j)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ F j) (w.hom.app j))","decl":"@[reassoc (attr := simp)]\ntheorem HasLimit.isoOfNatIso_hom_Ï€ {F G : J â¥¤ C} [HasLimit F] [HasLimit G] (w : F â‰… G) (j : J) :\n    (HasLimit.isoOfNatIso w).hom â‰« limit.Ï€ G j = limit.Ï€ F j â‰« w.hom.app j :=\n  IsLimit.conePointsIsoOfNatIso_hom_comp _ _ _ _\n\n"}
{"name":"CategoryTheory.Limits.HasLimit.isoOfNatIso_hom_Ï€_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor J C\ninstâœÂ¹ : CategoryTheory.Limits.HasLimit F\ninstâœ : CategoryTheory.Limits.HasLimit G\nw : CategoryTheory.Iso F G\nj : J\nZ : C\nh : Quiver.Hom (G.obj j) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.HasLimit.isoOfNatIso w).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ G j) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ F j) (CategoryTheory.CategoryStruct.comp (w.hom.app j) h))","decl":"@[reassoc (attr := simp)]\ntheorem HasLimit.isoOfNatIso_hom_Ï€ {F G : J â¥¤ C} [HasLimit F] [HasLimit G] (w : F â‰… G) (j : J) :\n    (HasLimit.isoOfNatIso w).hom â‰« limit.Ï€ G j = limit.Ï€ F j â‰« w.hom.app j :=\n  IsLimit.conePointsIsoOfNatIso_hom_comp _ _ _ _\n\n"}
{"name":"CategoryTheory.Limits.HasLimit.isoOfNatIso_inv_Ï€_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor J C\ninstâœÂ¹ : CategoryTheory.Limits.HasLimit F\ninstâœ : CategoryTheory.Limits.HasLimit G\nw : CategoryTheory.Iso F G\nj : J\nZ : C\nh : Quiver.Hom (F.obj j) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.HasLimit.isoOfNatIso w).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ F j) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ G j) (CategoryTheory.CategoryStruct.comp (w.inv.app j) h))","decl":"@[reassoc (attr := simp)]\ntheorem HasLimit.isoOfNatIso_inv_Ï€ {F G : J â¥¤ C} [HasLimit F] [HasLimit G] (w : F â‰… G) (j : J) :\n    (HasLimit.isoOfNatIso w).inv â‰« limit.Ï€ F j = limit.Ï€ G j â‰« w.inv.app j :=\n  IsLimit.conePointsIsoOfNatIso_inv_comp _ _ _ _\n\n"}
{"name":"CategoryTheory.Limits.HasLimit.isoOfNatIso_inv_Ï€","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor J C\ninstâœÂ¹ : CategoryTheory.Limits.HasLimit F\ninstâœ : CategoryTheory.Limits.HasLimit G\nw : CategoryTheory.Iso F G\nj : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.HasLimit.isoOfNatIso w).inv (CategoryTheory.Limits.limit.Ï€ F j)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ G j) (w.inv.app j))","decl":"@[reassoc (attr := simp)]\ntheorem HasLimit.isoOfNatIso_inv_Ï€ {F G : J â¥¤ C} [HasLimit F] [HasLimit G] (w : F â‰… G) (j : J) :\n    (HasLimit.isoOfNatIso w).inv â‰« limit.Ï€ F j = limit.Ï€ G j â‰« w.inv.app j :=\n  IsLimit.conePointsIsoOfNatIso_inv_comp _ _ _ _\n\n"}
{"name":"CategoryTheory.Limits.HasLimit.lift_isoOfNatIso_hom","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor J C\ninstâœÂ¹ : CategoryTheory.Limits.HasLimit F\ninstâœ : CategoryTheory.Limits.HasLimit G\nt : CategoryTheory.Limits.Cone F\nw : CategoryTheory.Iso F G\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.lift F t) (CategoryTheory.Limits.HasLimit.isoOfNatIso w).hom) (CategoryTheory.Limits.limit.lift G ((CategoryTheory.Limits.Cones.postcompose w.hom).obj t))","decl":"@[reassoc (attr := simp)]\ntheorem HasLimit.lift_isoOfNatIso_hom {F G : J â¥¤ C} [HasLimit F] [HasLimit G] (t : Cone F)\n    (w : F â‰… G) :\n    limit.lift F t â‰« (HasLimit.isoOfNatIso w).hom =\n      limit.lift G ((Cones.postcompose w.hom).obj _) :=\n  IsLimit.lift_comp_conePointsIsoOfNatIso_hom _ _ _\n\n"}
{"name":"CategoryTheory.Limits.HasLimit.lift_isoOfNatIso_hom_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor J C\ninstâœÂ¹ : CategoryTheory.Limits.HasLimit F\ninstâœ : CategoryTheory.Limits.HasLimit G\nt : CategoryTheory.Limits.Cone F\nw : CategoryTheory.Iso F G\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.limit G) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.lift F t) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.HasLimit.isoOfNatIso w).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.lift G ((CategoryTheory.Limits.Cones.postcompose w.hom).obj t)) h)","decl":"@[reassoc (attr := simp)]\ntheorem HasLimit.lift_isoOfNatIso_hom {F G : J â¥¤ C} [HasLimit F] [HasLimit G] (t : Cone F)\n    (w : F â‰… G) :\n    limit.lift F t â‰« (HasLimit.isoOfNatIso w).hom =\n      limit.lift G ((Cones.postcompose w.hom).obj _) :=\n  IsLimit.lift_comp_conePointsIsoOfNatIso_hom _ _ _\n\n"}
{"name":"CategoryTheory.Limits.HasLimit.lift_isoOfNatIso_inv_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor J C\ninstâœÂ¹ : CategoryTheory.Limits.HasLimit F\ninstâœ : CategoryTheory.Limits.HasLimit G\nt : CategoryTheory.Limits.Cone G\nw : CategoryTheory.Iso F G\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.limit F) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.lift G t) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.HasLimit.isoOfNatIso w).inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.lift F ((CategoryTheory.Limits.Cones.postcompose w.inv).obj t)) h)","decl":"@[reassoc (attr := simp)]\ntheorem HasLimit.lift_isoOfNatIso_inv {F G : J â¥¤ C} [HasLimit F] [HasLimit G] (t : Cone G)\n    (w : F â‰… G) :\n    limit.lift G t â‰« (HasLimit.isoOfNatIso w).inv =\n      limit.lift F ((Cones.postcompose w.inv).obj _) :=\n  IsLimit.lift_comp_conePointsIsoOfNatIso_inv _ _ _\n\n"}
{"name":"CategoryTheory.Limits.HasLimit.lift_isoOfNatIso_inv","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor J C\ninstâœÂ¹ : CategoryTheory.Limits.HasLimit F\ninstâœ : CategoryTheory.Limits.HasLimit G\nt : CategoryTheory.Limits.Cone G\nw : CategoryTheory.Iso F G\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.lift G t) (CategoryTheory.Limits.HasLimit.isoOfNatIso w).inv) (CategoryTheory.Limits.limit.lift F ((CategoryTheory.Limits.Cones.postcompose w.inv).obj t))","decl":"@[reassoc (attr := simp)]\ntheorem HasLimit.lift_isoOfNatIso_inv {F G : J â¥¤ C} [HasLimit F] [HasLimit G] (t : Cone G)\n    (w : F â‰… G) :\n    limit.lift G t â‰« (HasLimit.isoOfNatIso w).inv =\n      limit.lift F ((Cones.postcompose w.inv).obj _) :=\n  IsLimit.lift_comp_conePointsIsoOfNatIso_inv _ _ _\n\n"}
{"name":"CategoryTheory.Limits.HasLimit.isoOfEquivalence_hom_Ï€","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} J\nK : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} K\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœÂ¹ : CategoryTheory.Limits.HasLimit F\nG : CategoryTheory.Functor K C\ninstâœ : CategoryTheory.Limits.HasLimit G\ne : CategoryTheory.Equivalence J K\nw : CategoryTheory.Iso (e.functor.comp G) F\nk : K\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.HasLimit.isoOfEquivalence e w).hom (CategoryTheory.Limits.limit.Ï€ G k)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ F (e.inverse.obj k)) (CategoryTheory.CategoryStruct.comp (w.inv.app (e.inverse.obj k)) (G.map (e.counit.app k))))","decl":"@[simp]\ntheorem HasLimit.isoOfEquivalence_hom_Ï€ {F : J â¥¤ C} [HasLimit F] {G : K â¥¤ C} [HasLimit G]\n    (e : J â‰Œ K) (w : e.functor â‹™ G â‰… F) (k : K) :\n    (HasLimit.isoOfEquivalence e w).hom â‰« limit.Ï€ G k =\n      limit.Ï€ F (e.inverse.obj k) â‰« w.inv.app (e.inverse.obj k) â‰« G.map (e.counit.app k) := by\n  simp only [HasLimit.isoOfEquivalence, IsLimit.conePointsIsoOfEquivalence_hom]\n  dsimp\n  simp\n\n"}
{"name":"CategoryTheory.Limits.HasLimit.isoOfEquivalence_inv_Ï€","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} J\nK : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} K\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœÂ¹ : CategoryTheory.Limits.HasLimit F\nG : CategoryTheory.Functor K C\ninstâœ : CategoryTheory.Limits.HasLimit G\ne : CategoryTheory.Equivalence J K\nw : CategoryTheory.Iso (e.functor.comp G) F\nj : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.HasLimit.isoOfEquivalence e w).inv (CategoryTheory.Limits.limit.Ï€ F j)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ G (e.functor.obj j)) (w.hom.app j))","decl":"@[simp]\ntheorem HasLimit.isoOfEquivalence_inv_Ï€ {F : J â¥¤ C} [HasLimit F] {G : K â¥¤ C} [HasLimit G]\n    (e : J â‰Œ K) (w : e.functor â‹™ G â‰… F) (j : J) :\n    (HasLimit.isoOfEquivalence e w).inv â‰« limit.Ï€ F j =\n    limit.Ï€ G (e.functor.obj j) â‰« w.hom.app j := by\n  simp only [HasLimit.isoOfEquivalence, IsLimit.conePointsIsoOfEquivalence_hom]\n  dsimp\n  simp\n\n"}
{"name":"CategoryTheory.Limits.limit.pre_Ï€","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} J\nK : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} K\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœÂ¹ : CategoryTheory.Limits.HasLimit F\nE : CategoryTheory.Functor K J\ninstâœ : CategoryTheory.Limits.HasLimit (E.comp F)\nk : K\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.pre F E) (CategoryTheory.Limits.limit.Ï€ (E.comp F) k)) (CategoryTheory.Limits.limit.Ï€ F (E.obj k))","decl":"@[reassoc (attr := simp)]\ntheorem limit.pre_Ï€ (k : K) : limit.pre F E â‰« limit.Ï€ (E â‹™ F) k = limit.Ï€ F (E.obj k) := by\n  erw [IsLimit.fac]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.limit.pre_Ï€_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} J\nK : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} K\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœÂ¹ : CategoryTheory.Limits.HasLimit F\nE : CategoryTheory.Functor K J\ninstâœ : CategoryTheory.Limits.HasLimit (E.comp F)\nk : K\nZ : C\nh : Quiver.Hom (F.obj (E.obj k)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.pre F E) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ (E.comp F) k) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ F (E.obj k)) h)","decl":"@[reassoc (attr := simp)]\ntheorem limit.pre_Ï€ (k : K) : limit.pre F E â‰« limit.Ï€ (E â‹™ F) k = limit.Ï€ F (E.obj k) := by\n  erw [IsLimit.fac]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.limit.lift_pre","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} J\nK : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} K\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœÂ¹ : CategoryTheory.Limits.HasLimit F\nE : CategoryTheory.Functor K J\ninstâœ : CategoryTheory.Limits.HasLimit (E.comp F)\nc : CategoryTheory.Limits.Cone F\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.lift F c) (CategoryTheory.Limits.limit.pre F E)) (CategoryTheory.Limits.limit.lift (E.comp F) (CategoryTheory.Limits.Cone.whisker E c))","decl":"@[simp]\ntheorem limit.lift_pre (c : Cone F) :\n    limit.lift F c â‰« limit.pre F E = limit.lift (E â‹™ F) (c.whisker E) := by ext; simp\n\n"}
{"name":"CategoryTheory.Limits.limit.pre_pre","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœâµ : CategoryTheory.Category.{vâ‚, uâ‚} J\nK : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} K\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœÂ² : CategoryTheory.Limits.HasLimit F\nE : CategoryTheory.Functor K J\ninstâœÂ¹ : CategoryTheory.Limits.HasLimit (E.comp F)\nL : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} L\nD : CategoryTheory.Functor L K\nh : CategoryTheory.Limits.HasLimit (D.comp (E.comp F))\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.pre F E) (CategoryTheory.Limits.limit.pre (E.comp F) D)) (CategoryTheory.Limits.limit.pre F (D.comp E))","decl":"@[simp]\ntheorem limit.pre_pre [h : HasLimit (D â‹™ E â‹™ F)] : haveI : HasLimit ((D â‹™ E) â‹™ F) := h\n    limit.pre F E â‰« limit.pre (E â‹™ F) D = limit.pre F (D â‹™ E) := by\n  haveI : HasLimit ((D â‹™ E) â‹™ F) := h\n  ext j; erw [assoc, limit.pre_Ï€, limit.pre_Ï€, limit.pre_Ï€]; rfl\n\n"}
{"name":"CategoryTheory.Limits.limit.pre_eq","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} J\nK : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} K\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœÂ¹ : CategoryTheory.Limits.HasLimit F\nE : CategoryTheory.Functor K J\ninstâœ : CategoryTheory.Limits.HasLimit (E.comp F)\ns : CategoryTheory.Limits.LimitCone (E.comp F)\nt : CategoryTheory.Limits.LimitCone F\nâŠ¢ Eq (CategoryTheory.Limits.limit.pre F E) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.isoLimitCone t).hom (CategoryTheory.CategoryStruct.comp (s.isLimit.lift (CategoryTheory.Limits.Cone.whisker E t.cone)) (CategoryTheory.Limits.limit.isoLimitCone s).inv))","decl":"/-- -\nIf we have particular limit cones available for `E â‹™ F` and for `F`,\nwe obtain a formula for `limit.pre F E`.\n-/\ntheorem limit.pre_eq (s : LimitCone (E â‹™ F)) (t : LimitCone F) :\n    limit.pre F E = (limit.isoLimitCone t).hom â‰« s.isLimit.lift (t.cone.whisker E) â‰«\n      (limit.isoLimitCone s).inv := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.limit.post_Ï€_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninstâœÂ² : CategoryTheory.Category.{v', u'} D\nF : CategoryTheory.Functor J C\ninstâœÂ¹ : CategoryTheory.Limits.HasLimit F\nG : CategoryTheory.Functor C D\ninstâœ : CategoryTheory.Limits.HasLimit (F.comp G)\nj : J\nZ : D\nh : Quiver.Hom (G.obj (F.obj j)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.post F G) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ (F.comp G) j) h)) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.limit.Ï€ F j)) h)","decl":"@[reassoc (attr := simp)]\ntheorem limit.post_Ï€ (j : J) : limit.post F G â‰« limit.Ï€ (F â‹™ G) j = G.map (limit.Ï€ F j) := by\n  erw [IsLimit.fac]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.limit.post_Ï€","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninstâœÂ² : CategoryTheory.Category.{v', u'} D\nF : CategoryTheory.Functor J C\ninstâœÂ¹ : CategoryTheory.Limits.HasLimit F\nG : CategoryTheory.Functor C D\ninstâœ : CategoryTheory.Limits.HasLimit (F.comp G)\nj : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.post F G) (CategoryTheory.Limits.limit.Ï€ (F.comp G) j)) (G.map (CategoryTheory.Limits.limit.Ï€ F j))","decl":"@[reassoc (attr := simp)]\ntheorem limit.post_Ï€ (j : J) : limit.post F G â‰« limit.Ï€ (F â‹™ G) j = G.map (limit.Ï€ F j) := by\n  erw [IsLimit.fac]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.limit.lift_post","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninstâœÂ² : CategoryTheory.Category.{v', u'} D\nF : CategoryTheory.Functor J C\ninstâœÂ¹ : CategoryTheory.Limits.HasLimit F\nG : CategoryTheory.Functor C D\ninstâœ : CategoryTheory.Limits.HasLimit (F.comp G)\nc : CategoryTheory.Limits.Cone F\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.limit.lift F c)) (CategoryTheory.Limits.limit.post F G)) (CategoryTheory.Limits.limit.lift (F.comp G) (G.mapCone c))","decl":"@[simp]\ntheorem limit.lift_post (c : Cone F) :\n    G.map (limit.lift F c) â‰« limit.post F G = limit.lift (F â‹™ G) (G.mapCone c) := by\n  ext\n  rw [assoc, limit.post_Ï€, â† G.map_comp, limit.lift_Ï€, limit.lift_Ï€]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.limit.post_post","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœâµ : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninstâœÂ³ : CategoryTheory.Category.{v', u'} D\nF : CategoryTheory.Functor J C\ninstâœÂ² : CategoryTheory.Limits.HasLimit F\nG : CategoryTheory.Functor C D\ninstâœÂ¹ : CategoryTheory.Limits.HasLimit (F.comp G)\nE : Type u''\ninstâœ : CategoryTheory.Category.{v'', u''} E\nH : CategoryTheory.Functor D E\nh : CategoryTheory.Limits.HasLimit ((F.comp G).comp H)\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (H.map (CategoryTheory.Limits.limit.post F G)) (CategoryTheory.Limits.limit.post (F.comp G) H)) (CategoryTheory.Limits.limit.post F (G.comp H))","decl":"@[simp]\ntheorem limit.post_post {E : Type u''} [Category.{v''} E] (H : D â¥¤ E) [h : HasLimit ((F â‹™ G) â‹™ H)] :\n    -- H G (limit F) âŸ¶ H (limit (F â‹™ G)) âŸ¶ limit ((F â‹™ G) â‹™ H) equals\n    -- H G (limit F) âŸ¶ limit (F â‹™ (G â‹™ H))\n    haveI : HasLimit (F â‹™ G â‹™ H) := h\n    H.map (limit.post F G) â‰« limit.post (F â‹™ G) H = limit.post F (G â‹™ H) := by\n  haveI : HasLimit (F â‹™ G â‹™ H) := h\n  ext; erw [assoc, limit.post_Ï€, â† H.map_comp, limit.post_Ï€, limit.post_Ï€]; rfl\n\n"}
{"name":"CategoryTheory.Limits.limit.pre_post","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœâ¶ : CategoryTheory.Category.{vâ‚, uâ‚} J\nK : Type uâ‚‚\ninstâœâµ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} K\nC : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninstâœÂ³ : CategoryTheory.Category.{v', u'} D\nE : CategoryTheory.Functor K J\nF : CategoryTheory.Functor J C\nG : CategoryTheory.Functor C D\ninstâœÂ² : CategoryTheory.Limits.HasLimit F\ninstâœÂ¹ : CategoryTheory.Limits.HasLimit (E.comp F)\ninstâœ : CategoryTheory.Limits.HasLimit (F.comp G)\nh : CategoryTheory.Limits.HasLimit ((E.comp F).comp G)\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.limit.pre F E)) (CategoryTheory.Limits.limit.post (E.comp F) G)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.post F G) (CategoryTheory.Limits.limit.pre (F.comp G) E))","decl":"theorem limit.pre_post {D : Type u'} [Category.{v'} D] (E : K â¥¤ J) (F : J â¥¤ C) (G : C â¥¤ D)\n    [HasLimit F] [HasLimit (E â‹™ F)] [HasLimit (F â‹™ G)]\n    [h : HasLimit ((E â‹™ F) â‹™ G)] :-- G (limit F) âŸ¶ G (limit (E â‹™ F)) âŸ¶ limit ((E â‹™ F) â‹™ G) vs\n            -- G (limit F) âŸ¶ limit F â‹™ G âŸ¶ limit (E â‹™ (F â‹™ G)) or\n    haveI : HasLimit (E â‹™ F â‹™ G) := h\n    G.map (limit.pre F E) â‰« limit.post (E â‹™ F) G = limit.post F G â‰« limit.pre (F â‹™ G) E := by\n  haveI : HasLimit (E â‹™ F â‹™ G) := h\n  ext; erw [assoc, limit.post_Ï€, â† G.map_comp, limit.pre_Ï€, assoc, limit.pre_Ï€, limit.post_Ï€]\n\n"}
{"name":"CategoryTheory.Limits.hasLimitEquivalenceComp","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} J\nK : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} K\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ne : CategoryTheory.Equivalence K J\ninstâœ : CategoryTheory.Limits.HasLimit F\nâŠ¢ CategoryTheory.Limits.HasLimit (e.functor.comp F)","decl":"instance hasLimitEquivalenceComp (e : K â‰Œ J) [HasLimit F] : HasLimit (e.functor â‹™ F) :=\n  HasLimit.mk\n    { cone := Cone.whisker e.functor (limit.cone F)\n      isLimit := IsLimit.whiskerEquivalence (limit.isLimit F) e }\n\n-- Porting note: testing whether this still needed\n-- attribute [local elab_without_expected_type] inv_fun_id_assoc\n\n-- not entirely sure why this is needed\n"}
{"name":"CategoryTheory.Limits.hasLimitOfEquivalenceComp","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} J\nK : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} K\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ne : CategoryTheory.Equivalence K J\ninstâœ : CategoryTheory.Limits.HasLimit (e.functor.comp F)\nâŠ¢ CategoryTheory.Limits.HasLimit F","decl":"/-- If a `E â‹™ F` has a limit, and `E` is an equivalence, we can construct a limit of `F`.\n-/\ntheorem hasLimitOfEquivalenceComp (e : K â‰Œ J) [HasLimit (e.functor â‹™ F)] : HasLimit F := by\n  haveI : HasLimit (e.inverse â‹™ e.functor â‹™ F) := Limits.hasLimitEquivalenceComp e.symm\n  apply hasLimitOfIso (e.invFunIdAssoc F)\n\n-- `hasLimitCompEquivalence` and `hasLimitOfCompEquivalence`\n-- are proved in `CategoryTheory/Adjunction/Limits.lean`.\n"}
{"name":"CategoryTheory.Limits.lim_map","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasLimitsOfShape J C\nXâœ Yâœ : CategoryTheory.Functor J C\nÎ± : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq (CategoryTheory.Limits.lim.map Î±) (CategoryTheory.Limits.limMap Î±)","decl":"/-- `limit F` is functorial in `F`, when `C` has all limits of shape `J`. -/\n@[simps]\ndef lim : (J â¥¤ C) â¥¤ C where\n  obj F := limit F\n  map Î± := limMap Î±\n  map_id F := by\n    apply Limits.limit.hom_ext; intro j\n    simp\n  map_comp Î± Î² := by\n    apply Limits.limit.hom_ext; intro j\n    simp [assoc]\n\n"}
{"name":"CategoryTheory.Limits.lim_obj","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasLimitsOfShape J C\nF : CategoryTheory.Functor J C\nâŠ¢ Eq (CategoryTheory.Limits.lim.obj F) (CategoryTheory.Limits.limit F)","decl":"/-- `limit F` is functorial in `F`, when `C` has all limits of shape `J`. -/\n@[simps]\ndef lim : (J â¥¤ C) â¥¤ C where\n  obj F := limit F\n  map Î± := limMap Î±\n  map_id F := by\n    apply Limits.limit.hom_ext; intro j\n    simp\n  map_comp Î± Î² := by\n    apply Limits.limit.hom_ext; intro j\n    simp [assoc]\n\n"}
{"name":"CategoryTheory.Limits.limMap_eq","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœ : CategoryTheory.Limits.HasLimitsOfShape J C\nG : CategoryTheory.Functor J C\nÎ± : Quiver.Hom F G\nâŠ¢ Eq (CategoryTheory.Limits.limMap Î±) (CategoryTheory.Limits.lim.map Î±)","decl":"theorem limMap_eq : limMap Î± = lim.map Î± := rfl\n\n"}
{"name":"CategoryTheory.Limits.limit.map_pre","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} J\nK : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} K\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœÂ¹ : CategoryTheory.Limits.HasLimitsOfShape J C\nG : CategoryTheory.Functor J C\nÎ± : Quiver.Hom F G\ninstâœ : CategoryTheory.Limits.HasLimitsOfShape K C\nE : CategoryTheory.Functor K J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.lim.map Î±) (CategoryTheory.Limits.limit.pre G E)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.pre F E) (CategoryTheory.Limits.lim.map (CategoryTheory.whiskerLeft E Î±)))","decl":"theorem limit.map_pre [HasLimitsOfShape K C] (E : K â¥¤ J) :\n    lim.map Î± â‰« limit.pre G E = limit.pre F E â‰« lim.map (whiskerLeft E Î±) := by\n  ext\n  simp\n\n"}
{"name":"CategoryTheory.Limits.limit.map_pre'","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} J\nK : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} K\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasLimitsOfShape J C\ninstâœ : CategoryTheory.Limits.HasLimitsOfShape K C\nF : CategoryTheory.Functor J C\nEâ‚ Eâ‚‚ : CategoryTheory.Functor K J\nÎ± : Quiver.Hom Eâ‚ Eâ‚‚\nâŠ¢ Eq (CategoryTheory.Limits.limit.pre F Eâ‚‚) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.pre F Eâ‚) (CategoryTheory.Limits.lim.map (CategoryTheory.whiskerRight Î± F)))","decl":"theorem limit.map_pre' [HasLimitsOfShape K C] (F : J â¥¤ C) {Eâ‚ Eâ‚‚ : K â¥¤ J} (Î± : Eâ‚ âŸ¶ Eâ‚‚) :\n    limit.pre F Eâ‚‚ = limit.pre F Eâ‚ â‰« lim.map (whiskerRight Î± F) := by\n  ext1; simp [â† category.assoc]\n\n"}
{"name":"CategoryTheory.Limits.limit.id_pre","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasLimitsOfShape J C\nF : CategoryTheory.Functor J C\nâŠ¢ Eq (CategoryTheory.Limits.limit.pre F (CategoryTheory.Functor.id J)) (CategoryTheory.Limits.lim.map F.leftUnitor.inv)","decl":"theorem limit.id_pre (F : J â¥¤ C) : limit.pre F (ğŸ­ _) = lim.map (Functor.leftUnitor F).inv := by\n  aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.limit.map_post","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœÂ² : CategoryTheory.Limits.HasLimitsOfShape J C\nG : CategoryTheory.Functor J C\nÎ± : Quiver.Hom F G\nD : Type u'\ninstâœÂ¹ : CategoryTheory.Category.{v', u'} D\ninstâœ : CategoryTheory.Limits.HasLimitsOfShape J D\nH : CategoryTheory.Functor C D\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (H.map (CategoryTheory.Limits.limMap Î±)) (CategoryTheory.Limits.limit.post G H)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.post F H) (CategoryTheory.Limits.limMap (CategoryTheory.whiskerRight Î± H)))","decl":"theorem limit.map_post {D : Type u'} [Category.{v'} D] [HasLimitsOfShape J D] (H : C â¥¤ D) :\n    /- H (limit F) âŸ¶ H (limit G) âŸ¶ limit (G â‹™ H) vs\n     H (limit F) âŸ¶ limit (F â‹™ H) âŸ¶ limit (G â‹™ H) -/\n    H.map (limMap Î±) â‰« limit.post G H = limit.post F H â‰« limMap (whiskerRight Î± H) := by\n  ext\n  simp only [whiskerRight_app, limMap_Ï€, assoc, limit.post_Ï€_assoc, limit.post_Ï€, â† H.map_comp]\n\n"}
{"name":"CategoryTheory.Limits.instIsRightAdjointFunctorLim","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasLimitsOfShape J C\nâŠ¢ CategoryTheory.Limits.lim.IsRightAdjoint","decl":"instance : IsRightAdjoint (lim : (J â¥¤ C) â¥¤ C) :=\n  âŸ¨_, âŸ¨constLimAdjâŸ©âŸ©\n\n"}
{"name":"CategoryTheory.Limits.limMap_mono'","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor J C\ninstâœÂ¹ : CategoryTheory.Limits.HasLimitsOfShape J C\nÎ± : Quiver.Hom F G\ninstâœ : CategoryTheory.Mono Î±\nâŠ¢ CategoryTheory.Mono (CategoryTheory.Limits.limMap Î±)","decl":"instance limMap_mono' {F G : J â¥¤ C} [HasLimitsOfShape J C] (Î± : F âŸ¶ G) [Mono Î±] : Mono (limMap Î±) :=\n  (lim : (J â¥¤ C) â¥¤ C).map_mono Î±\n\n"}
{"name":"CategoryTheory.Limits.limMap_mono","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor J C\ninstâœÂ² : CategoryTheory.Limits.HasLimit F\ninstâœÂ¹ : CategoryTheory.Limits.HasLimit G\nÎ± : Quiver.Hom F G\ninstâœ : âˆ€ (j : J), CategoryTheory.Mono (Î±.app j)\nâŠ¢ CategoryTheory.Mono (CategoryTheory.Limits.limMap Î±)","decl":"instance limMap_mono {F G : J â¥¤ C} [HasLimit F] [HasLimit G] (Î± : F âŸ¶ G) [âˆ€ j, Mono (Î±.app j)] :\n    Mono (limMap Î±) :=\n  âŸ¨fun {Z} u v h =>\n    limit.hom_ext fun j => (cancel_mono (Î±.app j)).1 <| by simpa using h =â‰« limit.Ï€ _ jâŸ©\n\n"}
{"name":"CategoryTheory.Limits.coneOfAdj_pt","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nL : CategoryTheory.Functor (CategoryTheory.Functor J C) C\nadj : CategoryTheory.Adjunction (CategoryTheory.Functor.const J) L\nF : CategoryTheory.Functor J C\nâŠ¢ Eq (CategoryTheory.Limits.coneOfAdj adj F).pt (L.obj F)","decl":"/-- The limit cone obtained from a right adjoint of the constant functor. -/\n@[simps]\nnoncomputable def coneOfAdj (F : J â¥¤ C) : Cone F where\n  pt := L.obj F\n  Ï€ := adj.counit.app F\n\n"}
{"name":"CategoryTheory.Limits.coneOfAdj_Ï€","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nL : CategoryTheory.Functor (CategoryTheory.Functor J C) C\nadj : CategoryTheory.Adjunction (CategoryTheory.Functor.const J) L\nF : CategoryTheory.Functor J C\nâŠ¢ Eq (CategoryTheory.Limits.coneOfAdj adj F).Ï€ (adj.counit.app F)","decl":"/-- The limit cone obtained from a right adjoint of the constant functor. -/\n@[simps]\nnoncomputable def coneOfAdj (F : J â¥¤ C) : Cone F where\n  pt := L.obj F\n  Ï€ := adj.counit.app F\n\n"}
{"name":"CategoryTheory.Limits.isLimitConeOfAdj_lift","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nL : CategoryTheory.Functor (CategoryTheory.Functor J C) C\nadj : CategoryTheory.Adjunction (CategoryTheory.Functor.const J) L\nF : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cone F\nâŠ¢ Eq ((CategoryTheory.Limits.isLimitConeOfAdj adj F).lift s) ((adj.homEquiv s.pt F) s.Ï€)","decl":"/-- The cones defined by `coneOfAdj` are limit cones. -/\n@[simps]\ndef isLimitConeOfAdj (F : J â¥¤ C) :\n    IsLimit (coneOfAdj adj F) where\n  lift s := adj.homEquiv _ _ s.Ï€\n  fac s j := by\n    have eq := NatTrans.congr_app (adj.counit.naturality s.Ï€) j\n    have eq' := NatTrans.congr_app (adj.left_triangle_components s.pt) j\n    dsimp at eq eq' âŠ¢\n    rw [adj.homEquiv_unit, assoc, eq, reassoc_of% eq']\n  uniq s m hm := (adj.homEquiv _ _).symm.injective (by ext j; simpa using hm j)\n\n"}
{"name":"CategoryTheory.Limits.hasLimitsOfShape_of_equivalence","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nJ' : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} J'\ne : CategoryTheory.Equivalence J J'\ninstâœ : CategoryTheory.Limits.HasLimitsOfShape J C\nâŠ¢ CategoryTheory.Limits.HasLimitsOfShape J' C","decl":"/-- We can transport limits of shape `J` along an equivalence `J â‰Œ J'`.\n-/\ntheorem hasLimitsOfShape_of_equivalence {J' : Type uâ‚‚} [Category.{vâ‚‚} J'] (e : J â‰Œ J')\n    [HasLimitsOfShape J C] : HasLimitsOfShape J' C := by\n  constructor\n  intro F\n  apply hasLimitOfEquivalenceComp e\n\n"}
{"name":"CategoryTheory.Limits.hasLimitsOfSizeOfUnivLE","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : UnivLE.{vâ‚‚, vâ‚}\ninstâœÂ¹ : UnivLE.{uâ‚‚, uâ‚}\ninstâœ : CategoryTheory.Limits.HasLimitsOfSize.{vâ‚, uâ‚, v, u} C\nâŠ¢ CategoryTheory.Limits.HasLimitsOfSize.{vâ‚‚, uâ‚‚, v, u} C","decl":"/-- A category that has larger limits also has smaller limits. -/\ntheorem hasLimitsOfSizeOfUnivLE [UnivLE.{vâ‚‚, vâ‚}] [UnivLE.{uâ‚‚, uâ‚}]\n    [HasLimitsOfSize.{vâ‚, uâ‚} C] : HasLimitsOfSize.{vâ‚‚, uâ‚‚} C where\n  has_limits_of_shape J {_} := hasLimitsOfShape_of_equivalence\n    ((ShrinkHoms.equivalence J).trans <| Shrink.equivalence _).symm\n\n"}
{"name":"CategoryTheory.Limits.hasLimitsOfSizeShrink","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasLimitsOfSize.{max vâ‚ vâ‚‚, max uâ‚ uâ‚‚, v, u} C\nâŠ¢ CategoryTheory.Limits.HasLimitsOfSize.{vâ‚, uâ‚, v, u} C","decl":"/-- `hasLimitsOfSizeShrink.{v u} C` tries to obtain `HasLimitsOfSize.{v u} C`\nfrom some other `HasLimitsOfSize C`.\n-/\ntheorem hasLimitsOfSizeShrink [HasLimitsOfSize.{max vâ‚ vâ‚‚, max uâ‚ uâ‚‚} C] :\n    HasLimitsOfSize.{vâ‚, uâ‚} C := hasLimitsOfSizeOfUnivLE.{max vâ‚ vâ‚‚, max uâ‚ uâ‚‚} C\n\n"}
{"name":"CategoryTheory.Limits.hasSmallestLimitsOfHasLimits","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasLimits C\nâŠ¢ CategoryTheory.Limits.HasLimitsOfSize.{0, 0, v, u} C","decl":"instance (priority := 100) hasSmallestLimitsOfHasLimits [HasLimits C] : HasLimitsOfSize.{0, 0} C :=\n  hasLimitsOfSizeShrink.{0, 0} C\n\n"}
{"name":"CategoryTheory.Limits.ColimitCocone.mk.injEq","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ncoconeâœ : CategoryTheory.Limits.Cocone F\nisColimitâœ : CategoryTheory.Limits.IsColimit coconeâœ\ncocone : CategoryTheory.Limits.Cocone F\nisColimit : CategoryTheory.Limits.IsColimit cocone\nâŠ¢ Eq (Eq { cocone := coconeâœ, isColimit := isColimitâœ } { cocone := cocone, isColimit := isColimit }) (And (Eq coconeâœ cocone) (HEq isColimitâœ isColimit))","decl":"/-- `ColimitCocone F` contains a cocone over `F` together with the information that it is a\n    colimit. -/\nstructure ColimitCocone (F : J â¥¤ C) where\n  /-- The cocone itself -/\n  cocone : Cocone F\n  /-- The proof that it is the colimit cocone -/\n  isColimit : IsColimit cocone\n\n"}
{"name":"CategoryTheory.Limits.ColimitCocone.mk.inj","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ncoconeâœ : CategoryTheory.Limits.Cocone F\nisColimitâœ : CategoryTheory.Limits.IsColimit coconeâœ\ncocone : CategoryTheory.Limits.Cocone F\nisColimit : CategoryTheory.Limits.IsColimit cocone\nxâœ : Eq { cocone := coconeâœ, isColimit := isColimitâœ } { cocone := cocone, isColimit := isColimit }\nâŠ¢ And (Eq coconeâœ cocone) (HEq isColimitâœ isColimit)","decl":"/-- `ColimitCocone F` contains a cocone over `F` together with the information that it is a\n    colimit. -/\nstructure ColimitCocone (F : J â¥¤ C) where\n  /-- The cocone itself -/\n  cocone : Cocone F\n  /-- The proof that it is the colimit cocone -/\n  isColimit : IsColimit cocone\n\n"}
{"name":"CategoryTheory.Limits.ColimitCocone.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœÂ¹ : SizeOf J\ninstâœ : SizeOf C\ncocone : CategoryTheory.Limits.Cocone F\nisColimit : CategoryTheory.Limits.IsColimit cocone\nâŠ¢ Eq (SizeOf.sizeOf { cocone := cocone, isColimit := isColimit }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf cocone)) (SizeOf.sizeOf isColimit))","decl":"/-- `ColimitCocone F` contains a cocone over `F` together with the information that it is a\n    colimit. -/\nstructure ColimitCocone (F : J â¥¤ C) where\n  /-- The cocone itself -/\n  cocone : Cocone F\n  /-- The proof that it is the colimit cocone -/\n  isColimit : IsColimit cocone\n\n"}
{"name":"CategoryTheory.Limits.HasColimit.exists_colimit","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\nself : CategoryTheory.Limits.HasColimit F\nâŠ¢ Nonempty (CategoryTheory.Limits.ColimitCocone F)","decl":"/-- `HasColimit F` represents the mere existence of a colimit for `F`. -/\nclass HasColimit (F : J â¥¤ C) : Prop where mk' ::\n  /-- There exists a colimit for `F` -/\n  exists_colimit : Nonempty (ColimitCocone F)\n\n"}
{"name":"CategoryTheory.Limits.HasColimit.mk","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\nd : CategoryTheory.Limits.ColimitCocone F\nâŠ¢ CategoryTheory.Limits.HasColimit F","decl":"theorem HasColimit.mk {F : J â¥¤ C} (d : ColimitCocone F) : HasColimit F :=\n  âŸ¨Nonempty.intro dâŸ©\n\n"}
{"name":"CategoryTheory.Limits.HasColimitsOfShape.has_colimit","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.Limits.HasColimitsOfShape J C\nF : CategoryTheory.Functor J C\nâŠ¢ CategoryTheory.Limits.HasColimit F","decl":"/-- `C` has colimits of shape `J` if there exists a colimit for every functor `F : J â¥¤ C`. -/\nclass HasColimitsOfShape : Prop where\n  /-- All `F : J â¥¤ C` have colimits for a fixed `J` -/\n  has_colimit : âˆ€ F : J â¥¤ C, HasColimit F := by infer_instance\n\n"}
{"name":"CategoryTheory.Limits.HasColimitsOfSize.has_colimits_of_shape","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.Limits.HasColimitsOfSize.{vâ‚, uâ‚, v, u} C\nJ : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} J\nâŠ¢ CategoryTheory.Limits.HasColimitsOfShape J C","decl":"/-- `C` has all colimits of size `vâ‚ uâ‚` (`HasColimitsOfSize.{vâ‚ uâ‚} C`)\nif it has colimits of every shape `J : Type uâ‚` with `[Category.{vâ‚} J]`.\n-/\n@[pp_with_univ]\nclass HasColimitsOfSize (C : Type u) [Category.{v} C] : Prop where\n  /-- All `F : J â¥¤ C` have colimits for all small `J` -/\n  has_colimits_of_shape : âˆ€ (J : Type uâ‚) [Category.{vâ‚} J], HasColimitsOfShape J C := by\n    infer_instance\n\n"}
{"name":"CategoryTheory.Limits.HasColimits.hasColimitsOfShape","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasColimits C\nJ : Type v\ninstâœ : CategoryTheory.Category.{v, v} J\nâŠ¢ CategoryTheory.Limits.HasColimitsOfShape J C","decl":"theorem HasColimits.hasColimitsOfShape {C : Type u} [Category.{v} C] [HasColimits C] (J : Type v)\n    [Category.{v} J] : HasColimitsOfShape J C :=\n  HasColimitsOfSize.has_colimits_of_shape J\n\n"}
{"name":"CategoryTheory.Limits.hasColimitOfHasColimitsOfShape","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nJ : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} J\ninstâœ : CategoryTheory.Limits.HasColimitsOfShape J C\nF : CategoryTheory.Functor J C\nâŠ¢ CategoryTheory.Limits.HasColimit F","decl":"instance (priority := 100) hasColimitOfHasColimitsOfShape {J : Type uâ‚} [Category.{vâ‚} J]\n    [HasColimitsOfShape J C] (F : J â¥¤ C) : HasColimit F :=\n  HasColimitsOfShape.has_colimit F\n\n-- see Note [lower instance priority]\n"}
{"name":"CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nJ : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} J\ninstâœ : CategoryTheory.Limits.HasColimitsOfSize.{vâ‚, uâ‚, v, u} C\nâŠ¢ CategoryTheory.Limits.HasColimitsOfShape J C","decl":"instance (priority := 100) hasColimitsOfShapeOfHasColimitsOfSize {J : Type uâ‚} [Category.{vâ‚} J]\n    [HasColimitsOfSize.{vâ‚, uâ‚} C] : HasColimitsOfShape J C :=\n  HasColimitsOfSize.has_colimits_of_shape J\n\n-- Interface to the `HasColimit` class.\n"}
{"name":"CategoryTheory.Limits.colimit.eqToHom_comp_Î¹_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœ : CategoryTheory.Limits.HasColimit F\nj j' : J\nhj : Eq j j'\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.colimit F) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom â‹¯) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ F j) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ F j') h)","decl":"@[reassoc]\ntheorem colimit.eqToHom_comp_Î¹ (F : J â¥¤ C) [HasColimit F] {j j' : J} (hj : j = j') :\n    eqToHom (by subst hj; rfl) â‰« colimit.Î¹ F j = colimit.Î¹ F j'  := by\n  subst hj\n  simp\n\n"}
{"name":"CategoryTheory.Limits.colimit.eqToHom_comp_Î¹","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœ : CategoryTheory.Limits.HasColimit F\nj j' : J\nhj : Eq j j'\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom â‹¯) (CategoryTheory.Limits.colimit.Î¹ F j)) (CategoryTheory.Limits.colimit.Î¹ F j')","decl":"@[reassoc]\ntheorem colimit.eqToHom_comp_Î¹ (F : J â¥¤ C) [HasColimit F] {j j' : J} (hj : j = j') :\n    eqToHom (by subst hj; rfl) â‰« colimit.Î¹ F j = colimit.Î¹ F j'  := by\n  subst hj\n  simp\n\n"}
{"name":"CategoryTheory.Limits.colimit.cocone_Î¹","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœ : CategoryTheory.Limits.HasColimit F\nj : J\nâŠ¢ Eq ((CategoryTheory.Limits.colimit.cocone F).Î¹.app j) (CategoryTheory.Limits.colimit.Î¹ F j)","decl":"@[simp]\ntheorem colimit.cocone_Î¹ {F : J â¥¤ C} [HasColimit F] (j : J) :\n    (colimit.cocone F).Î¹.app j = colimit.Î¹ _ j :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.colimit.cocone_x","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœ : CategoryTheory.Limits.HasColimit F\nâŠ¢ Eq (CategoryTheory.Limits.colimit.cocone F).pt (CategoryTheory.Limits.colimit F)","decl":"@[simp]\ntheorem colimit.cocone_x {F : J â¥¤ C} [HasColimit F] : (colimit.cocone F).pt = colimit F :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.colimit.w","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœ : CategoryTheory.Limits.HasColimit F\nj j' : J\nf : Quiver.Hom j j'\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (F.map f) (CategoryTheory.Limits.colimit.Î¹ F j')) (CategoryTheory.Limits.colimit.Î¹ F j)","decl":"@[reassoc (attr := simp)]\ntheorem colimit.w (F : J â¥¤ C) [HasColimit F] {j j' : J} (f : j âŸ¶ j') :\n    F.map f â‰« colimit.Î¹ F j' = colimit.Î¹ F j :=\n  (colimit.cocone F).w f\n\n"}
{"name":"CategoryTheory.Limits.colimit.w_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœ : CategoryTheory.Limits.HasColimit F\nj j' : J\nf : Quiver.Hom j j'\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.colimit F) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (F.map f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ F j') h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ F j) h)","decl":"@[reassoc (attr := simp)]\ntheorem colimit.w (F : J â¥¤ C) [HasColimit F] {j j' : J} (f : j âŸ¶ j') :\n    F.map f â‰« colimit.Î¹ F j' = colimit.Î¹ F j :=\n  (colimit.cocone F).w f\n\n"}
{"name":"CategoryTheory.Limits.colimit.isColimit_desc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœ : CategoryTheory.Limits.HasColimit F\nc : CategoryTheory.Limits.Cocone F\nâŠ¢ Eq ((CategoryTheory.Limits.colimit.isColimit F).desc c) (CategoryTheory.Limits.colimit.desc F c)","decl":"@[simp]\ntheorem colimit.isColimit_desc {F : J â¥¤ C} [HasColimit F] (c : Cocone F) :\n    (colimit.isColimit F).desc c = colimit.desc F c :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.colimit.Î¹_desc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœ : CategoryTheory.Limits.HasColimit F\nc : CategoryTheory.Limits.Cocone F\nj : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ F j) (CategoryTheory.Limits.colimit.desc F c)) (c.Î¹.app j)","decl":"/-- We have lots of lemmas describing how to simplify `colimit.Î¹ F j â‰« _`,\nand combined with `colimit.ext` we rely on these lemmas for many calculations.\n\nHowever, since `Category.assoc` is a `@[simp]` lemma, often expressions are\nright associated, and it's hard to apply these lemmas about `colimit.Î¹`.\n\nWe thus use `reassoc` to define additional `@[simp]` lemmas, with an arbitrary extra morphism.\n(see `Tactic/reassoc_axiom.lean`)\n -/\n@[reassoc (attr := simp)]\ntheorem colimit.Î¹_desc {F : J â¥¤ C} [HasColimit F] (c : Cocone F) (j : J) :\n    colimit.Î¹ F j â‰« colimit.desc F c = c.Î¹.app j :=\n  IsColimit.fac _ c j\n\n"}
{"name":"CategoryTheory.Limits.colimit.Î¹_desc_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœ : CategoryTheory.Limits.HasColimit F\nc : CategoryTheory.Limits.Cocone F\nj : J\nZ : C\nh : Quiver.Hom c.pt Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ F j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.desc F c) h)) (CategoryTheory.CategoryStruct.comp (c.Î¹.app j) h)","decl":"/-- We have lots of lemmas describing how to simplify `colimit.Î¹ F j â‰« _`,\nand combined with `colimit.ext` we rely on these lemmas for many calculations.\n\nHowever, since `Category.assoc` is a `@[simp]` lemma, often expressions are\nright associated, and it's hard to apply these lemmas about `colimit.Î¹`.\n\nWe thus use `reassoc` to define additional `@[simp]` lemmas, with an arbitrary extra morphism.\n(see `Tactic/reassoc_axiom.lean`)\n -/\n@[reassoc (attr := simp)]\ntheorem colimit.Î¹_desc {F : J â¥¤ C} [HasColimit F] (c : Cocone F) (j : J) :\n    colimit.Î¹ F j â‰« colimit.desc F c = c.Î¹.app j :=\n  IsColimit.fac _ c j\n\n"}
{"name":"CategoryTheory.Limits.Î¹_colimMap_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor J C\ninstâœÂ¹ : CategoryTheory.Limits.HasColimit F\ninstâœ : CategoryTheory.Limits.HasColimit G\nÎ± : Quiver.Hom F G\nj : J\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.colimit G) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ F j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimMap Î±) h)) (CategoryTheory.CategoryStruct.comp (Î±.app j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ G j) h))","decl":"@[reassoc (attr := simp)]\ntheorem Î¹_colimMap {F G : J â¥¤ C} [HasColimit F] [HasColimit G] (Î± : F âŸ¶ G) (j : J) :\n    colimit.Î¹ F j â‰« colimMap Î± = Î±.app j â‰« colimit.Î¹ G j :=\n  colimit.Î¹_desc _ j\n\n"}
{"name":"CategoryTheory.Limits.Î¹_colimMap","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor J C\ninstâœÂ¹ : CategoryTheory.Limits.HasColimit F\ninstâœ : CategoryTheory.Limits.HasColimit G\nÎ± : Quiver.Hom F G\nj : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ F j) (CategoryTheory.Limits.colimMap Î±)) (CategoryTheory.CategoryStruct.comp (Î±.app j) (CategoryTheory.Limits.colimit.Î¹ G j))","decl":"@[reassoc (attr := simp)]\ntheorem Î¹_colimMap {F G : J â¥¤ C} [HasColimit F] [HasColimit G] (Î± : F âŸ¶ G) (j : J) :\n    colimit.Î¹ F j â‰« colimMap Î± = Î±.app j â‰« colimit.Î¹ G j :=\n  colimit.Î¹_desc _ j\n\n"}
{"name":"CategoryTheory.Limits.colimit.coconeMorphism_hom","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœ : CategoryTheory.Limits.HasColimit F\nc : CategoryTheory.Limits.Cocone F\nâŠ¢ Eq (CategoryTheory.Limits.colimit.coconeMorphism c).hom (CategoryTheory.Limits.colimit.desc F c)","decl":"@[simp]\ntheorem colimit.coconeMorphism_hom {F : J â¥¤ C} [HasColimit F] (c : Cocone F) :\n    (colimit.coconeMorphism c).hom = colimit.desc F c :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.colimit.Î¹_coconeMorphism","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœ : CategoryTheory.Limits.HasColimit F\nc : CategoryTheory.Limits.Cocone F\nj : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ F j) (CategoryTheory.Limits.colimit.coconeMorphism c).hom) (c.Î¹.app j)","decl":"theorem colimit.Î¹_coconeMorphism {F : J â¥¤ C} [HasColimit F] (c : Cocone F) (j : J) :\n    colimit.Î¹ F j â‰« (colimit.coconeMorphism c).hom = c.Î¹.app j := by simp\n\n"}
{"name":"CategoryTheory.Limits.colimit.comp_coconePointUniqueUpToIso_hom_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœ : CategoryTheory.Limits.HasColimit F\nc : CategoryTheory.Limits.Cocone F\nhc : CategoryTheory.Limits.IsColimit c\nj : J\nZ : C\nh : Quiver.Hom c.pt Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ F j) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Limits.colimit.isColimit F).coconePointUniqueUpToIso hc).hom h)) (CategoryTheory.CategoryStruct.comp (c.Î¹.app j) h)","decl":"@[reassoc (attr := simp)]\ntheorem colimit.comp_coconePointUniqueUpToIso_hom {F : J â¥¤ C} [HasColimit F] {c : Cocone F}\n    (hc : IsColimit c) (j : J) :\n    colimit.Î¹ F j â‰« (IsColimit.coconePointUniqueUpToIso (colimit.isColimit _) hc).hom = c.Î¹.app j :=\n  IsColimit.comp_coconePointUniqueUpToIso_hom _ _ _\n\n"}
{"name":"CategoryTheory.Limits.colimit.comp_coconePointUniqueUpToIso_hom","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœ : CategoryTheory.Limits.HasColimit F\nc : CategoryTheory.Limits.Cocone F\nhc : CategoryTheory.Limits.IsColimit c\nj : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ F j) ((CategoryTheory.Limits.colimit.isColimit F).coconePointUniqueUpToIso hc).hom) (c.Î¹.app j)","decl":"@[reassoc (attr := simp)]\ntheorem colimit.comp_coconePointUniqueUpToIso_hom {F : J â¥¤ C} [HasColimit F] {c : Cocone F}\n    (hc : IsColimit c) (j : J) :\n    colimit.Î¹ F j â‰« (IsColimit.coconePointUniqueUpToIso (colimit.isColimit _) hc).hom = c.Î¹.app j :=\n  IsColimit.comp_coconePointUniqueUpToIso_hom _ _ _\n\n"}
{"name":"CategoryTheory.Limits.colimit.comp_coconePointUniqueUpToIso_inv","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœ : CategoryTheory.Limits.HasColimit F\nc : CategoryTheory.Limits.Cocone F\nhc : CategoryTheory.Limits.IsColimit c\nj : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ F j) (hc.coconePointUniqueUpToIso (CategoryTheory.Limits.colimit.isColimit F)).inv) (c.Î¹.app j)","decl":"@[reassoc (attr := simp)]\ntheorem colimit.comp_coconePointUniqueUpToIso_inv {F : J â¥¤ C} [HasColimit F] {c : Cocone F}\n    (hc : IsColimit c) (j : J) :\n    colimit.Î¹ F j â‰« (IsColimit.coconePointUniqueUpToIso hc (colimit.isColimit _)).inv = c.Î¹.app j :=\n  IsColimit.comp_coconePointUniqueUpToIso_inv _ _ _\n\n"}
{"name":"CategoryTheory.Limits.colimit.comp_coconePointUniqueUpToIso_inv_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœ : CategoryTheory.Limits.HasColimit F\nc : CategoryTheory.Limits.Cocone F\nhc : CategoryTheory.Limits.IsColimit c\nj : J\nZ : C\nh : Quiver.Hom c.pt Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ F j) (CategoryTheory.CategoryStruct.comp (hc.coconePointUniqueUpToIso (CategoryTheory.Limits.colimit.isColimit F)).inv h)) (CategoryTheory.CategoryStruct.comp (c.Î¹.app j) h)","decl":"@[reassoc (attr := simp)]\ntheorem colimit.comp_coconePointUniqueUpToIso_inv {F : J â¥¤ C} [HasColimit F] {c : Cocone F}\n    (hc : IsColimit c) (j : J) :\n    colimit.Î¹ F j â‰« (IsColimit.coconePointUniqueUpToIso hc (colimit.isColimit _)).inv = c.Î¹.app j :=\n  IsColimit.comp_coconePointUniqueUpToIso_inv _ _ _\n\n"}
{"name":"CategoryTheory.Limits.colimit.existsUnique","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœ : CategoryTheory.Limits.HasColimit F\nt : CategoryTheory.Limits.Cocone F\nâŠ¢ ExistsUnique fun d => âˆ€ (j : J), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ F j) d) (t.Î¹.app j)","decl":"theorem colimit.existsUnique {F : J â¥¤ C} [HasColimit F] (t : Cocone F) :\n    âˆƒ! d : colimit F âŸ¶ t.pt, âˆ€ j, colimit.Î¹ F j â‰« d = t.Î¹.app j :=\n  (colimit.isColimit F).existsUnique _\n\n"}
{"name":"CategoryTheory.Limits.colimit.isoColimitCocone_Î¹_hom_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœ : CategoryTheory.Limits.HasColimit F\nt : CategoryTheory.Limits.ColimitCocone F\nj : J\nZ : C\nh : Quiver.Hom t.cocone.pt Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ F j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.isoColimitCocone t).hom h)) (CategoryTheory.CategoryStruct.comp (t.cocone.Î¹.app j) h)","decl":"@[reassoc (attr := simp)]\ntheorem colimit.isoColimitCocone_Î¹_hom {F : J â¥¤ C} [HasColimit F] (t : ColimitCocone F) (j : J) :\n    colimit.Î¹ F j â‰« (colimit.isoColimitCocone t).hom = t.cocone.Î¹.app j := by\n  dsimp [colimit.isoColimitCocone, IsColimit.coconePointUniqueUpToIso]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.colimit.isoColimitCocone_Î¹_hom","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœ : CategoryTheory.Limits.HasColimit F\nt : CategoryTheory.Limits.ColimitCocone F\nj : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ F j) (CategoryTheory.Limits.colimit.isoColimitCocone t).hom) (t.cocone.Î¹.app j)","decl":"@[reassoc (attr := simp)]\ntheorem colimit.isoColimitCocone_Î¹_hom {F : J â¥¤ C} [HasColimit F] (t : ColimitCocone F) (j : J) :\n    colimit.Î¹ F j â‰« (colimit.isoColimitCocone t).hom = t.cocone.Î¹.app j := by\n  dsimp [colimit.isoColimitCocone, IsColimit.coconePointUniqueUpToIso]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.colimit.isoColimitCocone_Î¹_inv","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœ : CategoryTheory.Limits.HasColimit F\nt : CategoryTheory.Limits.ColimitCocone F\nj : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (t.cocone.Î¹.app j) (CategoryTheory.Limits.colimit.isoColimitCocone t).inv) (CategoryTheory.Limits.colimit.Î¹ F j)","decl":"@[reassoc (attr := simp)]\ntheorem colimit.isoColimitCocone_Î¹_inv {F : J â¥¤ C} [HasColimit F] (t : ColimitCocone F) (j : J) :\n    t.cocone.Î¹.app j â‰« (colimit.isoColimitCocone t).inv = colimit.Î¹ F j := by\n  dsimp [colimit.isoColimitCocone, IsColimit.coconePointUniqueUpToIso]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.colimit.isoColimitCocone_Î¹_inv_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœ : CategoryTheory.Limits.HasColimit F\nt : CategoryTheory.Limits.ColimitCocone F\nj : J\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.colimit F) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (t.cocone.Î¹.app j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.isoColimitCocone t).inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ F j) h)","decl":"@[reassoc (attr := simp)]\ntheorem colimit.isoColimitCocone_Î¹_inv {F : J â¥¤ C} [HasColimit F] (t : ColimitCocone F) (j : J) :\n    t.cocone.Î¹.app j â‰« (colimit.isoColimitCocone t).inv = colimit.Î¹ F j := by\n  dsimp [colimit.isoColimitCocone, IsColimit.coconePointUniqueUpToIso]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.colimit.hom_ext_iff","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœ : CategoryTheory.Limits.HasColimit F\nX : C\nf f' : Quiver.Hom (CategoryTheory.Limits.colimit F) X\nâŠ¢ Iff (Eq f f') (âˆ€ (j : J), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ F j) f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ F j) f'))","decl":"@[ext]\ntheorem colimit.hom_ext {F : J â¥¤ C} [HasColimit F] {X : C} {f f' : colimit F âŸ¶ X}\n    (w : âˆ€ j, colimit.Î¹ F j â‰« f = colimit.Î¹ F j â‰« f') : f = f' :=\n  (colimit.isColimit F).hom_ext w\n\n"}
{"name":"CategoryTheory.Limits.colimit.hom_ext","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœ : CategoryTheory.Limits.HasColimit F\nX : C\nf f' : Quiver.Hom (CategoryTheory.Limits.colimit F) X\nw : âˆ€ (j : J), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ F j) f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ F j) f')\nâŠ¢ Eq f f'","decl":"@[ext]\ntheorem colimit.hom_ext {F : J â¥¤ C} [HasColimit F] {X : C} {f f' : colimit F âŸ¶ X}\n    (w : âˆ€ j, colimit.Î¹ F j â‰« f = colimit.Î¹ F j â‰« f') : f = f' :=\n  (colimit.isColimit F).hom_ext w\n\n"}
{"name":"CategoryTheory.Limits.colimit.desc_cocone","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœ : CategoryTheory.Limits.HasColimit F\nâŠ¢ Eq (CategoryTheory.Limits.colimit.desc F (CategoryTheory.Limits.colimit.cocone F)) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.colimit F))","decl":"@[simp]\ntheorem colimit.desc_cocone {F : J â¥¤ C} [HasColimit F] :\n    colimit.desc F (colimit.cocone F) = ğŸ™ (colimit F) :=\n  (colimit.isColimit _).desc_self\n\n"}
{"name":"CategoryTheory.Limits.colimit.homIso_hom","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœ : CategoryTheory.Limits.HasColimit F\nW : C\nf : ULift.{uâ‚, v} (Quiver.Hom (CategoryTheory.Limits.colimit F) W)\nâŠ¢ Eq ((CategoryTheory.Limits.colimit.homIso F W).hom f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.cocone F).Î¹ ((CategoryTheory.Functor.const J).map f.down))","decl":"@[simp]\ntheorem colimit.homIso_hom (F : J â¥¤ C) [HasColimit F] {W : C} (f : ULift (colimit F âŸ¶ W)) :\n    (colimit.homIso F W).hom f = (colimit.cocone F).Î¹ â‰« (const J).map f.down :=\n  (colimit.isColimit F).homIso_hom f\n\n"}
{"name":"CategoryTheory.Limits.colimit.desc_extend","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœ : CategoryTheory.Limits.HasColimit F\nc : CategoryTheory.Limits.Cocone F\nX : C\nf : Quiver.Hom c.pt X\nâŠ¢ Eq (CategoryTheory.Limits.colimit.desc F (c.extend f)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.desc F c) f)","decl":"theorem colimit.desc_extend (F : J â¥¤ C) [HasColimit F] (c : Cocone F) {X : C} (f : c.pt âŸ¶ X) :\n    colimit.desc F (c.extend f) = colimit.desc F c â‰« f := by ext1; rw [â† Category.assoc]; simp\n\n-- This has the isomorphism pointing in the opposite direction than in `has_limit_of_iso`.\n-- This is intentional; it seems to help with elaboration.\n"}
{"name":"CategoryTheory.Limits.hasColimitOfIso","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor J C\ninstâœ : CategoryTheory.Limits.HasColimit F\nÎ± : CategoryTheory.Iso G F\nâŠ¢ CategoryTheory.Limits.HasColimit G","decl":"/-- If `F` has a colimit, so does any naturally isomorphic functor.\n-/\ntheorem hasColimitOfIso {F G : J â¥¤ C} [HasColimit F] (Î± : G â‰… F) : HasColimit G :=\n  HasColimit.mk\n    { cocone := (Cocones.precompose Î±.hom).obj (colimit.cocone F)\n      isColimit := (IsColimit.precomposeHomEquiv _ _).symm (colimit.isColimit F) }\n\n"}
{"name":"CategoryTheory.Limits.HasColimit.ofCoconesIso","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nK : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚} K\nF : CategoryTheory.Functor J C\nG : CategoryTheory.Functor K C\nh : CategoryTheory.Iso F.cocones G.cocones\ninstâœ : CategoryTheory.Limits.HasColimit F\nâŠ¢ CategoryTheory.Limits.HasColimit G","decl":"/-- If a functor `G` has the same collection of cocones as a functor `F`\nwhich has a colimit, then `G` also has a colimit. -/\ntheorem HasColimit.ofCoconesIso {K : Type uâ‚} [Category.{vâ‚‚} K] (F : J â¥¤ C) (G : K â¥¤ C)\n    (h : F.cocones â‰… G.cocones) [HasColimit F] : HasColimit G :=\n  HasColimit.mk âŸ¨_, IsColimit.ofNatIso (IsColimit.natIso (colimit.isColimit F) â‰ªâ‰« h)âŸ©\n\n"}
{"name":"CategoryTheory.Limits.HasColimit.isoOfNatIso_Î¹_hom_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor J C\ninstâœÂ¹ : CategoryTheory.Limits.HasColimit F\ninstâœ : CategoryTheory.Limits.HasColimit G\nw : CategoryTheory.Iso F G\nj : J\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.colimit G) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ F j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.HasColimit.isoOfNatIso w).hom h)) (CategoryTheory.CategoryStruct.comp (w.hom.app j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ G j) h))","decl":"@[reassoc (attr := simp)]\ntheorem HasColimit.isoOfNatIso_Î¹_hom {F G : J â¥¤ C} [HasColimit F] [HasColimit G] (w : F â‰… G)\n    (j : J) : colimit.Î¹ F j â‰« (HasColimit.isoOfNatIso w).hom = w.hom.app j â‰« colimit.Î¹ G j :=\n  IsColimit.comp_coconePointsIsoOfNatIso_hom _ _ _ _\n\n"}
{"name":"CategoryTheory.Limits.HasColimit.isoOfNatIso_Î¹_hom","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor J C\ninstâœÂ¹ : CategoryTheory.Limits.HasColimit F\ninstâœ : CategoryTheory.Limits.HasColimit G\nw : CategoryTheory.Iso F G\nj : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ F j) (CategoryTheory.Limits.HasColimit.isoOfNatIso w).hom) (CategoryTheory.CategoryStruct.comp (w.hom.app j) (CategoryTheory.Limits.colimit.Î¹ G j))","decl":"@[reassoc (attr := simp)]\ntheorem HasColimit.isoOfNatIso_Î¹_hom {F G : J â¥¤ C} [HasColimit F] [HasColimit G] (w : F â‰… G)\n    (j : J) : colimit.Î¹ F j â‰« (HasColimit.isoOfNatIso w).hom = w.hom.app j â‰« colimit.Î¹ G j :=\n  IsColimit.comp_coconePointsIsoOfNatIso_hom _ _ _ _\n\n"}
{"name":"CategoryTheory.Limits.HasColimit.isoOfNatIso_Î¹_inv_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor J C\ninstâœÂ¹ : CategoryTheory.Limits.HasColimit F\ninstâœ : CategoryTheory.Limits.HasColimit G\nw : CategoryTheory.Iso F G\nj : J\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.colimit F) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ G j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.HasColimit.isoOfNatIso w).inv h)) (CategoryTheory.CategoryStruct.comp (w.inv.app j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ F j) h))","decl":"@[reassoc (attr := simp)]\ntheorem HasColimit.isoOfNatIso_Î¹_inv {F G : J â¥¤ C} [HasColimit F] [HasColimit G] (w : F â‰… G)\n    (j : J) : colimit.Î¹ G j â‰« (HasColimit.isoOfNatIso w).inv = w.inv.app j â‰« colimit.Î¹ F j :=\n  IsColimit.comp_coconePointsIsoOfNatIso_inv _ _ _ _\n\n"}
{"name":"CategoryTheory.Limits.HasColimit.isoOfNatIso_Î¹_inv","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor J C\ninstâœÂ¹ : CategoryTheory.Limits.HasColimit F\ninstâœ : CategoryTheory.Limits.HasColimit G\nw : CategoryTheory.Iso F G\nj : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ G j) (CategoryTheory.Limits.HasColimit.isoOfNatIso w).inv) (CategoryTheory.CategoryStruct.comp (w.inv.app j) (CategoryTheory.Limits.colimit.Î¹ F j))","decl":"@[reassoc (attr := simp)]\ntheorem HasColimit.isoOfNatIso_Î¹_inv {F G : J â¥¤ C} [HasColimit F] [HasColimit G] (w : F â‰… G)\n    (j : J) : colimit.Î¹ G j â‰« (HasColimit.isoOfNatIso w).inv = w.inv.app j â‰« colimit.Î¹ F j :=\n  IsColimit.comp_coconePointsIsoOfNatIso_inv _ _ _ _\n\n"}
{"name":"CategoryTheory.Limits.HasColimit.isoOfNatIso_hom_desc_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor J C\ninstâœÂ¹ : CategoryTheory.Limits.HasColimit F\ninstâœ : CategoryTheory.Limits.HasColimit G\nt : CategoryTheory.Limits.Cocone G\nw : CategoryTheory.Iso F G\nZ : C\nh : Quiver.Hom t.pt Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.HasColimit.isoOfNatIso w).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.desc G t) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.desc F ((CategoryTheory.Limits.Cocones.precompose w.hom).obj t)) h)","decl":"@[reassoc (attr := simp)]\ntheorem HasColimit.isoOfNatIso_hom_desc {F G : J â¥¤ C} [HasColimit F] [HasColimit G] (t : Cocone G)\n    (w : F â‰… G) :\n    (HasColimit.isoOfNatIso w).hom â‰« colimit.desc G t =\n      colimit.desc F ((Cocones.precompose w.hom).obj _) :=\n  IsColimit.coconePointsIsoOfNatIso_hom_desc _ _ _\n\n"}
{"name":"CategoryTheory.Limits.HasColimit.isoOfNatIso_hom_desc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor J C\ninstâœÂ¹ : CategoryTheory.Limits.HasColimit F\ninstâœ : CategoryTheory.Limits.HasColimit G\nt : CategoryTheory.Limits.Cocone G\nw : CategoryTheory.Iso F G\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.HasColimit.isoOfNatIso w).hom (CategoryTheory.Limits.colimit.desc G t)) (CategoryTheory.Limits.colimit.desc F ((CategoryTheory.Limits.Cocones.precompose w.hom).obj t))","decl":"@[reassoc (attr := simp)]\ntheorem HasColimit.isoOfNatIso_hom_desc {F G : J â¥¤ C} [HasColimit F] [HasColimit G] (t : Cocone G)\n    (w : F â‰… G) :\n    (HasColimit.isoOfNatIso w).hom â‰« colimit.desc G t =\n      colimit.desc F ((Cocones.precompose w.hom).obj _) :=\n  IsColimit.coconePointsIsoOfNatIso_hom_desc _ _ _\n\n"}
{"name":"CategoryTheory.Limits.HasColimit.isoOfNatIso_inv_desc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor J C\ninstâœÂ¹ : CategoryTheory.Limits.HasColimit F\ninstâœ : CategoryTheory.Limits.HasColimit G\nt : CategoryTheory.Limits.Cocone F\nw : CategoryTheory.Iso F G\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.HasColimit.isoOfNatIso w).inv (CategoryTheory.Limits.colimit.desc F t)) (CategoryTheory.Limits.colimit.desc G ((CategoryTheory.Limits.Cocones.precompose w.inv).obj t))","decl":"@[reassoc (attr := simp)]\ntheorem HasColimit.isoOfNatIso_inv_desc {F G : J â¥¤ C} [HasColimit F] [HasColimit G] (t : Cocone F)\n    (w : F â‰… G) :\n    (HasColimit.isoOfNatIso w).inv â‰« colimit.desc F t =\n      colimit.desc G ((Cocones.precompose w.inv).obj _) :=\n  IsColimit.coconePointsIsoOfNatIso_inv_desc _ _ _\n\n"}
{"name":"CategoryTheory.Limits.HasColimit.isoOfNatIso_inv_desc_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor J C\ninstâœÂ¹ : CategoryTheory.Limits.HasColimit F\ninstâœ : CategoryTheory.Limits.HasColimit G\nt : CategoryTheory.Limits.Cocone F\nw : CategoryTheory.Iso F G\nZ : C\nh : Quiver.Hom t.pt Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.HasColimit.isoOfNatIso w).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.desc F t) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.desc G ((CategoryTheory.Limits.Cocones.precompose w.inv).obj t)) h)","decl":"@[reassoc (attr := simp)]\ntheorem HasColimit.isoOfNatIso_inv_desc {F G : J â¥¤ C} [HasColimit F] [HasColimit G] (t : Cocone F)\n    (w : F â‰… G) :\n    (HasColimit.isoOfNatIso w).inv â‰« colimit.desc F t =\n      colimit.desc G ((Cocones.precompose w.inv).obj _) :=\n  IsColimit.coconePointsIsoOfNatIso_inv_desc _ _ _\n\n"}
{"name":"CategoryTheory.Limits.HasColimit.isoOfEquivalence_hom_Ï€","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} J\nK : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} K\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœÂ¹ : CategoryTheory.Limits.HasColimit F\nG : CategoryTheory.Functor K C\ninstâœ : CategoryTheory.Limits.HasColimit G\ne : CategoryTheory.Equivalence J K\nw : CategoryTheory.Iso (e.functor.comp G) F\nj : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ F j) (CategoryTheory.Limits.HasColimit.isoOfEquivalence e w).hom) (CategoryTheory.CategoryStruct.comp (F.map (e.unit.app j)) (CategoryTheory.CategoryStruct.comp (w.inv.app ((e.functor.comp e.inverse).obj j)) (CategoryTheory.Limits.colimit.Î¹ G (e.functor.obj ((e.functor.comp e.inverse).obj j)))))","decl":"@[simp]\ntheorem HasColimit.isoOfEquivalence_hom_Ï€ {F : J â¥¤ C} [HasColimit F] {G : K â¥¤ C} [HasColimit G]\n    (e : J â‰Œ K) (w : e.functor â‹™ G â‰… F) (j : J) :\n    colimit.Î¹ F j â‰« (HasColimit.isoOfEquivalence e w).hom =\n      F.map (e.unit.app j) â‰« w.inv.app _ â‰« colimit.Î¹ G _ := by\n  simp [HasColimit.isoOfEquivalence, IsColimit.coconePointsIsoOfEquivalence_inv]\n\n"}
{"name":"CategoryTheory.Limits.HasColimit.isoOfEquivalence_inv_Ï€","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} J\nK : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} K\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœÂ¹ : CategoryTheory.Limits.HasColimit F\nG : CategoryTheory.Functor K C\ninstâœ : CategoryTheory.Limits.HasColimit G\ne : CategoryTheory.Equivalence J K\nw : CategoryTheory.Iso (e.functor.comp G) F\nk : K\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ G k) (CategoryTheory.Limits.HasColimit.isoOfEquivalence e w).inv) (CategoryTheory.CategoryStruct.comp (G.map (e.counitInv.app k)) (CategoryTheory.CategoryStruct.comp (w.hom.app (e.inverse.obj k)) (CategoryTheory.Limits.colimit.Î¹ F (e.inverse.obj k))))","decl":"@[simp]\ntheorem HasColimit.isoOfEquivalence_inv_Ï€ {F : J â¥¤ C} [HasColimit F] {G : K â¥¤ C} [HasColimit G]\n    (e : J â‰Œ K) (w : e.functor â‹™ G â‰… F) (k : K) :\n    colimit.Î¹ G k â‰« (HasColimit.isoOfEquivalence e w).inv =\n      G.map (e.counitInv.app k) â‰« w.hom.app (e.inverse.obj k) â‰« colimit.Î¹ F (e.inverse.obj k) := by\n  simp [HasColimit.isoOfEquivalence, IsColimit.coconePointsIsoOfEquivalence_inv]\n\n"}
{"name":"CategoryTheory.Limits.colimit.Î¹_pre","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} J\nK : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} K\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœÂ¹ : CategoryTheory.Limits.HasColimit F\nE : CategoryTheory.Functor K J\ninstâœ : CategoryTheory.Limits.HasColimit (E.comp F)\nk : K\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ (E.comp F) k) (CategoryTheory.Limits.colimit.pre F E)) (CategoryTheory.Limits.colimit.Î¹ F (E.obj k))","decl":"@[reassoc (attr := simp)]\ntheorem colimit.Î¹_pre (k : K) : colimit.Î¹ (E â‹™ F) k â‰« colimit.pre F E = colimit.Î¹ F (E.obj k) := by\n  erw [IsColimit.fac]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.colimit.Î¹_pre_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} J\nK : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} K\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœÂ¹ : CategoryTheory.Limits.HasColimit F\nE : CategoryTheory.Functor K J\ninstâœ : CategoryTheory.Limits.HasColimit (E.comp F)\nk : K\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.colimit F) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ (E.comp F) k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.pre F E) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ F (E.obj k)) h)","decl":"@[reassoc (attr := simp)]\ntheorem colimit.Î¹_pre (k : K) : colimit.Î¹ (E â‹™ F) k â‰« colimit.pre F E = colimit.Î¹ F (E.obj k) := by\n  erw [IsColimit.fac]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.colimit.Î¹_inv_pre","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœâµ : CategoryTheory.Category.{vâ‚, uâ‚} J\nK : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} K\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœÂ² : CategoryTheory.Limits.HasColimit F\nE : CategoryTheory.Functor K J\ninstâœÂ¹ : CategoryTheory.Limits.HasColimit (E.comp F)\ninstâœ : CategoryTheory.IsIso (CategoryTheory.Limits.colimit.pre F E)\nk : K\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ F (E.obj k)) (CategoryTheory.inv (CategoryTheory.Limits.colimit.pre F E))) (CategoryTheory.Limits.colimit.Î¹ (E.comp F) k)","decl":"@[reassoc (attr := simp)]\ntheorem colimit.Î¹_inv_pre [IsIso (pre F E)] (k : K) :\n    colimit.Î¹ F (E.obj k) â‰« inv (colimit.pre F E) = colimit.Î¹ (E â‹™ F) k := by\n  simp [IsIso.comp_inv_eq]\n\n"}
{"name":"CategoryTheory.Limits.colimit.Î¹_inv_pre_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœâµ : CategoryTheory.Category.{vâ‚, uâ‚} J\nK : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} K\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœÂ² : CategoryTheory.Limits.HasColimit F\nE : CategoryTheory.Functor K J\ninstâœÂ¹ : CategoryTheory.Limits.HasColimit (E.comp F)\ninstâœ : CategoryTheory.IsIso (CategoryTheory.Limits.colimit.pre F E)\nk : K\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.colimit (E.comp F)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ F (E.obj k)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv (CategoryTheory.Limits.colimit.pre F E)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ (E.comp F) k) h)","decl":"@[reassoc (attr := simp)]\ntheorem colimit.Î¹_inv_pre [IsIso (pre F E)] (k : K) :\n    colimit.Î¹ F (E.obj k) â‰« inv (colimit.pre F E) = colimit.Î¹ (E â‹™ F) k := by\n  simp [IsIso.comp_inv_eq]\n\n"}
{"name":"CategoryTheory.Limits.colimit.pre_desc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} J\nK : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} K\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœÂ¹ : CategoryTheory.Limits.HasColimit F\nE : CategoryTheory.Functor K J\ninstâœ : CategoryTheory.Limits.HasColimit (E.comp F)\nc : CategoryTheory.Limits.Cocone F\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.pre F E) (CategoryTheory.Limits.colimit.desc F c)) (CategoryTheory.Limits.colimit.desc (E.comp F) (CategoryTheory.Limits.Cocone.whisker E c))","decl":"@[reassoc (attr := simp)]\ntheorem colimit.pre_desc (c : Cocone F) :\n    colimit.pre F E â‰« colimit.desc F c = colimit.desc (E â‹™ F) (c.whisker E) := by\n  ext; rw [â† assoc, colimit.Î¹_pre]; simp\n\n"}
{"name":"CategoryTheory.Limits.colimit.pre_desc_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} J\nK : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} K\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœÂ¹ : CategoryTheory.Limits.HasColimit F\nE : CategoryTheory.Functor K J\ninstâœ : CategoryTheory.Limits.HasColimit (E.comp F)\nc : CategoryTheory.Limits.Cocone F\nZ : C\nh : Quiver.Hom c.pt Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.pre F E) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.desc F c) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.desc (E.comp F) (CategoryTheory.Limits.Cocone.whisker E c)) h)","decl":"@[reassoc (attr := simp)]\ntheorem colimit.pre_desc (c : Cocone F) :\n    colimit.pre F E â‰« colimit.desc F c = colimit.desc (E â‹™ F) (c.whisker E) := by\n  ext; rw [â† assoc, colimit.Î¹_pre]; simp\n\n"}
{"name":"CategoryTheory.Limits.colimit.pre_pre","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœâµ : CategoryTheory.Category.{vâ‚, uâ‚} J\nK : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} K\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœÂ² : CategoryTheory.Limits.HasColimit F\nE : CategoryTheory.Functor K J\ninstâœÂ¹ : CategoryTheory.Limits.HasColimit (E.comp F)\nL : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} L\nD : CategoryTheory.Functor L K\nh : CategoryTheory.Limits.HasColimit (D.comp (E.comp F))\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.pre (E.comp F) D) (CategoryTheory.Limits.colimit.pre F E)) (CategoryTheory.Limits.colimit.pre F (D.comp E))","decl":"@[simp]\ntheorem colimit.pre_pre [h : HasColimit (D â‹™ E â‹™ F)] :\n    haveI : HasColimit ((D â‹™ E) â‹™ F) := h\n    colimit.pre (E â‹™ F) D â‰« colimit.pre F E = colimit.pre F (D â‹™ E) := by\n  ext j\n  rw [â† assoc, colimit.Î¹_pre, colimit.Î¹_pre]\n  haveI : HasColimit ((D â‹™ E) â‹™ F) := h\n  exact (colimit.Î¹_pre F (D â‹™ E) j).symm\n\n"}
{"name":"CategoryTheory.Limits.colimit.pre_eq","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} J\nK : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} K\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœÂ¹ : CategoryTheory.Limits.HasColimit F\nE : CategoryTheory.Functor K J\ninstâœ : CategoryTheory.Limits.HasColimit (E.comp F)\ns : CategoryTheory.Limits.ColimitCocone (E.comp F)\nt : CategoryTheory.Limits.ColimitCocone F\nâŠ¢ Eq (CategoryTheory.Limits.colimit.pre F E) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.isoColimitCocone s).hom (CategoryTheory.CategoryStruct.comp (s.isColimit.desc (CategoryTheory.Limits.Cocone.whisker E t.cocone)) (CategoryTheory.Limits.colimit.isoColimitCocone t).inv))","decl":"/-- -\nIf we have particular colimit cocones available for `E â‹™ F` and for `F`,\nwe obtain a formula for `colimit.pre F E`.\n-/\ntheorem colimit.pre_eq (s : ColimitCocone (E â‹™ F)) (t : ColimitCocone F) :\n    colimit.pre F E =\n      (colimit.isoColimitCocone s).hom â‰«\n        s.isColimit.desc (t.cocone.whisker E) â‰« (colimit.isoColimitCocone t).inv := by\n  aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.colimit.Î¹_post","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\nD : Type u'\ninstâœÂ² : CategoryTheory.Category.{v', u'} D\ninstâœÂ¹ : CategoryTheory.Limits.HasColimit F\nG : CategoryTheory.Functor C D\ninstâœ : CategoryTheory.Limits.HasColimit (F.comp G)\nj : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ (F.comp G) j) (CategoryTheory.Limits.colimit.post F G)) (G.map (CategoryTheory.Limits.colimit.Î¹ F j))","decl":"@[reassoc (attr := simp)]\ntheorem colimit.Î¹_post (j : J) :\n    colimit.Î¹ (F â‹™ G) j â‰« colimit.post F G = G.map (colimit.Î¹ F j) := by\n  erw [IsColimit.fac]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.colimit.Î¹_post_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\nD : Type u'\ninstâœÂ² : CategoryTheory.Category.{v', u'} D\ninstâœÂ¹ : CategoryTheory.Limits.HasColimit F\nG : CategoryTheory.Functor C D\ninstâœ : CategoryTheory.Limits.HasColimit (F.comp G)\nj : J\nZ : D\nh : Quiver.Hom (G.obj (CategoryTheory.Limits.colimit F)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ (F.comp G) j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.post F G) h)) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.colimit.Î¹ F j)) h)","decl":"@[reassoc (attr := simp)]\ntheorem colimit.Î¹_post (j : J) :\n    colimit.Î¹ (F â‹™ G) j â‰« colimit.post F G = G.map (colimit.Î¹ F j) := by\n  erw [IsColimit.fac]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.colimit.post_desc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\nD : Type u'\ninstâœÂ² : CategoryTheory.Category.{v', u'} D\ninstâœÂ¹ : CategoryTheory.Limits.HasColimit F\nG : CategoryTheory.Functor C D\ninstâœ : CategoryTheory.Limits.HasColimit (F.comp G)\nc : CategoryTheory.Limits.Cocone F\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.post F G) (G.map (CategoryTheory.Limits.colimit.desc F c))) (CategoryTheory.Limits.colimit.desc (F.comp G) (G.mapCocone c))","decl":"@[simp]\ntheorem colimit.post_desc (c : Cocone F) :\n    colimit.post F G â‰« G.map (colimit.desc F c) = colimit.desc (F â‹™ G) (G.mapCocone c) := by\n  ext\n  rw [â† assoc, colimit.Î¹_post, â† G.map_comp, colimit.Î¹_desc, colimit.Î¹_desc]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.colimit.post_post","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœâµ : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\nD : Type u'\ninstâœÂ³ : CategoryTheory.Category.{v', u'} D\ninstâœÂ² : CategoryTheory.Limits.HasColimit F\nG : CategoryTheory.Functor C D\ninstâœÂ¹ : CategoryTheory.Limits.HasColimit (F.comp G)\nE : Type u''\ninstâœ : CategoryTheory.Category.{v'', u''} E\nH : CategoryTheory.Functor D E\nh : CategoryTheory.Limits.HasColimit ((F.comp G).comp H)\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.post (F.comp G) H) (H.map (CategoryTheory.Limits.colimit.post F G))) (CategoryTheory.Limits.colimit.post F (G.comp H))","decl":"@[simp]\ntheorem colimit.post_post {E : Type u''} [Category.{v''} E] (H : D â¥¤ E)\n    -- H G (colimit F) âŸ¶ H (colimit (F â‹™ G)) âŸ¶ colimit ((F â‹™ G) â‹™ H) equals\n    -- H G (colimit F) âŸ¶ colimit (F â‹™ (G â‹™ H))\n    [h : HasColimit ((F â‹™ G) â‹™ H)] : haveI : HasColimit (F â‹™ G â‹™ H) := h\n    colimit.post (F â‹™ G) H â‰« H.map (colimit.post F G) = colimit.post F (G â‹™ H) := by\n  ext j\n  rw [â† assoc, colimit.Î¹_post, â† H.map_comp, colimit.Î¹_post]\n  haveI : HasColimit (F â‹™ G â‹™ H) := h\n  exact (colimit.Î¹_post F (G â‹™ H) j).symm\n\n"}
{"name":"CategoryTheory.Limits.colimit.pre_post","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœâ¶ : CategoryTheory.Category.{vâ‚, uâ‚} J\nK : Type uâ‚‚\ninstâœâµ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} K\nC : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninstâœÂ³ : CategoryTheory.Category.{v', u'} D\nE : CategoryTheory.Functor K J\nF : CategoryTheory.Functor J C\nG : CategoryTheory.Functor C D\ninstâœÂ² : CategoryTheory.Limits.HasColimit F\ninstâœÂ¹ : CategoryTheory.Limits.HasColimit (E.comp F)\ninstâœ : CategoryTheory.Limits.HasColimit (F.comp G)\nh : CategoryTheory.Limits.HasColimit ((E.comp F).comp G)\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.post (E.comp F) G) (G.map (CategoryTheory.Limits.colimit.pre F E))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.pre (F.comp G) E) (CategoryTheory.Limits.colimit.post F G))","decl":"theorem colimit.pre_post {D : Type u'} [Category.{v'} D] (E : K â¥¤ J) (F : J â¥¤ C) (G : C â¥¤ D)\n    [HasColimit F] [HasColimit (E â‹™ F)] [HasColimit (F â‹™ G)] [h : HasColimit ((E â‹™ F) â‹™ G)] :\n    -- G (colimit F) âŸ¶ G (colimit (E â‹™ F)) âŸ¶ colimit ((E â‹™ F) â‹™ G) vs\n    -- G (colimit F) âŸ¶ colimit F â‹™ G âŸ¶ colimit (E â‹™ (F â‹™ G)) or\n    haveI : HasColimit (E â‹™ F â‹™ G) := h\n    colimit.post (E â‹™ F) G â‰« G.map (colimit.pre F E) =\n      colimit.pre (F â‹™ G) E â‰« colimit.post F G := by\n  ext j\n  rw [â† assoc, colimit.Î¹_post, â† G.map_comp, colimit.Î¹_pre, â† assoc]\n  haveI : HasColimit (E â‹™ F â‹™ G) := h\n  erw [colimit.Î¹_pre (F â‹™ G) E j, colimit.Î¹_post]\n\n"}
{"name":"CategoryTheory.Limits.hasColimit_equivalence_comp","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} J\nK : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} K\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ne : CategoryTheory.Equivalence K J\ninstâœ : CategoryTheory.Limits.HasColimit F\nâŠ¢ CategoryTheory.Limits.HasColimit (e.functor.comp F)","decl":"instance hasColimit_equivalence_comp (e : K â‰Œ J) [HasColimit F] : HasColimit (e.functor â‹™ F) :=\n  HasColimit.mk\n    { cocone := Cocone.whisker e.functor (colimit.cocone F)\n      isColimit := IsColimit.whiskerEquivalence (colimit.isColimit F) e }\n\n"}
{"name":"CategoryTheory.Limits.hasColimit_of_equivalence_comp","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} J\nK : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} K\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ne : CategoryTheory.Equivalence K J\ninstâœ : CategoryTheory.Limits.HasColimit (e.functor.comp F)\nâŠ¢ CategoryTheory.Limits.HasColimit F","decl":"/-- If a `E â‹™ F` has a colimit, and `E` is an equivalence, we can construct a colimit of `F`.\n-/\ntheorem hasColimit_of_equivalence_comp (e : K â‰Œ J) [HasColimit (e.functor â‹™ F)] : HasColimit F := by\n  haveI : HasColimit (e.inverse â‹™ e.functor â‹™ F) := Limits.hasColimit_equivalence_comp e.symm\n  apply hasColimitOfIso (e.invFunIdAssoc F).symm\n\n"}
{"name":"CategoryTheory.Limits.colim_map","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasColimitsOfShape J C\nXâœ Yâœ : CategoryTheory.Functor J C\nÎ± : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq (CategoryTheory.Limits.colim.map Î±) (CategoryTheory.Limits.colimMap Î±)","decl":"/-- `colimit F` is functorial in `F`, when `C` has all colimits of shape `J`. -/\n@[simps]\ndef colim : (J â¥¤ C) â¥¤ C where\n  obj F := colimit F\n  map Î± := colimMap Î±\n\n"}
{"name":"CategoryTheory.Limits.colim_obj","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasColimitsOfShape J C\nF : CategoryTheory.Functor J C\nâŠ¢ Eq (CategoryTheory.Limits.colim.obj F) (CategoryTheory.Limits.colimit F)","decl":"/-- `colimit F` is functorial in `F`, when `C` has all colimits of shape `J`. -/\n@[simps]\ndef colim : (J â¥¤ C) â¥¤ C where\n  obj F := colimit F\n  map Î± := colimMap Î±\n\n"}
{"name":"CategoryTheory.Limits.colimMap_eq","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœ : CategoryTheory.Limits.HasColimitsOfShape J C\nG : CategoryTheory.Functor J C\nÎ± : Quiver.Hom F G\nâŠ¢ Eq (CategoryTheory.Limits.colimMap Î±) (CategoryTheory.Limits.colim.map Î±)","decl":"theorem colimMap_eq : colimMap Î± = colim.map Î± := rfl\n\n"}
{"name":"CategoryTheory.Limits.colimit.Î¹_map","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœ : CategoryTheory.Limits.HasColimitsOfShape J C\nG : CategoryTheory.Functor J C\nÎ± : Quiver.Hom F G\nj : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ F j) (CategoryTheory.Limits.colim.map Î±)) (CategoryTheory.CategoryStruct.comp (Î±.app j) (CategoryTheory.Limits.colimit.Î¹ G j))","decl":"@[reassoc]\ntheorem colimit.Î¹_map (j : J) : colimit.Î¹ F j â‰« colim.map Î± = Î±.app j â‰« colimit.Î¹ G j := by simp\n\n"}
{"name":"CategoryTheory.Limits.colimit.Î¹_map_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœ : CategoryTheory.Limits.HasColimitsOfShape J C\nG : CategoryTheory.Functor J C\nÎ± : Quiver.Hom F G\nj : J\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.colim.obj G) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ F j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colim.map Î±) h)) (CategoryTheory.CategoryStruct.comp (Î±.app j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ G j) h))","decl":"@[reassoc]\ntheorem colimit.Î¹_map (j : J) : colimit.Î¹ F j â‰« colim.map Î± = Î±.app j â‰« colimit.Î¹ G j := by simp\n\n"}
{"name":"CategoryTheory.Limits.colimit.map_desc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœ : CategoryTheory.Limits.HasColimitsOfShape J C\nG : CategoryTheory.Functor J C\nÎ± : Quiver.Hom F G\nc : CategoryTheory.Limits.Cocone G\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimMap Î±) (CategoryTheory.Limits.colimit.desc G c)) (CategoryTheory.Limits.colimit.desc F ((CategoryTheory.Limits.Cocones.precompose Î±).obj c))","decl":"@[reassoc (attr := simp)]\ntheorem colimit.map_desc (c : Cocone G) :\n    colimMap Î± â‰« colimit.desc G c = colimit.desc F ((Cocones.precompose Î±).obj c) := by\n  ext j\n  simp [â† assoc, colimit.Î¹_map, assoc, colimit.Î¹_desc, colimit.Î¹_desc]\n\n"}
{"name":"CategoryTheory.Limits.colimit.map_desc_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœ : CategoryTheory.Limits.HasColimitsOfShape J C\nG : CategoryTheory.Functor J C\nÎ± : Quiver.Hom F G\nc : CategoryTheory.Limits.Cocone G\nZ : C\nh : Quiver.Hom c.pt Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimMap Î±) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.desc G c) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.desc F ((CategoryTheory.Limits.Cocones.precompose Î±).obj c)) h)","decl":"@[reassoc (attr := simp)]\ntheorem colimit.map_desc (c : Cocone G) :\n    colimMap Î± â‰« colimit.desc G c = colimit.desc F ((Cocones.precompose Î±).obj c) := by\n  ext j\n  simp [â† assoc, colimit.Î¹_map, assoc, colimit.Î¹_desc, colimit.Î¹_desc]\n\n"}
{"name":"CategoryTheory.Limits.colimit.pre_map","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} J\nK : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} K\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœÂ¹ : CategoryTheory.Limits.HasColimitsOfShape J C\nG : CategoryTheory.Functor J C\nÎ± : Quiver.Hom F G\ninstâœ : CategoryTheory.Limits.HasColimitsOfShape K C\nE : CategoryTheory.Functor K J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.pre F E) (CategoryTheory.Limits.colim.map Î±)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colim.map (CategoryTheory.whiskerLeft E Î±)) (CategoryTheory.Limits.colimit.pre G E))","decl":"theorem colimit.pre_map [HasColimitsOfShape K C] (E : K â¥¤ J) :\n    colimit.pre F E â‰« colim.map Î± = colim.map (whiskerLeft E Î±) â‰« colimit.pre G E := by\n  ext\n  rw [â† assoc, colimit.Î¹_pre, colimit.Î¹_map, â† assoc, colimit.Î¹_map, assoc, colimit.Î¹_pre]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.colimit.pre_map'","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} J\nK : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} K\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasColimitsOfShape J C\ninstâœ : CategoryTheory.Limits.HasColimitsOfShape K C\nF : CategoryTheory.Functor J C\nEâ‚ Eâ‚‚ : CategoryTheory.Functor K J\nÎ± : Quiver.Hom Eâ‚ Eâ‚‚\nâŠ¢ Eq (CategoryTheory.Limits.colimit.pre F Eâ‚) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colim.map (CategoryTheory.whiskerRight Î± F)) (CategoryTheory.Limits.colimit.pre F Eâ‚‚))","decl":"theorem colimit.pre_map' [HasColimitsOfShape K C] (F : J â¥¤ C) {Eâ‚ Eâ‚‚ : K â¥¤ J} (Î± : Eâ‚ âŸ¶ Eâ‚‚) :\n    colimit.pre F Eâ‚ = colim.map (whiskerRight Î± F) â‰« colimit.pre F Eâ‚‚ := by\n  ext1\n  simp [â† assoc, assoc]\n\n"}
{"name":"CategoryTheory.Limits.colimit.pre_id","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasColimitsOfShape J C\nF : CategoryTheory.Functor J C\nâŠ¢ Eq (CategoryTheory.Limits.colimit.pre F (CategoryTheory.Functor.id J)) (CategoryTheory.Limits.colim.map F.leftUnitor.hom)","decl":"theorem colimit.pre_id (F : J â¥¤ C) :\n    colimit.pre F (ğŸ­ _) = colim.map (Functor.leftUnitor F).hom := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.colimit.map_post","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninstâœÂ² : CategoryTheory.Limits.HasColimitsOfShape J C\nG : CategoryTheory.Functor J C\nÎ± : Quiver.Hom F G\nD : Type u'\ninstâœÂ¹ : CategoryTheory.Category.{v', u'} D\ninstâœ : CategoryTheory.Limits.HasColimitsOfShape J D\nH : CategoryTheory.Functor C D\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.post F H) (H.map (CategoryTheory.Limits.colim.map Î±))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colim.map (CategoryTheory.whiskerRight Î± H)) (CategoryTheory.Limits.colimit.post G H))","decl":"theorem colimit.map_post {D : Type u'} [Category.{v'} D] [HasColimitsOfShape J D]\n    (H : C â¥¤ D) :/- H (colimit F) âŸ¶ H (colimit G) âŸ¶ colimit (G â‹™ H) vs\n             H (colimit F) âŸ¶ colimit (F â‹™ H) âŸ¶ colimit (G â‹™ H) -/\n          colimit.post\n          F H â‰«\n        H.map (colim.map Î±) =\n      colim.map (whiskerRight Î± H) â‰« colimit.post G H := by\n  ext\n  rw [â† assoc, colimit.Î¹_post, â† H.map_comp, colimit.Î¹_map, H.map_comp]\n  rw [â† assoc, colimit.Î¹_map, assoc, colimit.Î¹_post]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.instIsLeftAdjointFunctorColim","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasColimitsOfShape J C\nâŠ¢ CategoryTheory.Limits.colim.IsLeftAdjoint","decl":"instance : IsLeftAdjoint (colim : (J â¥¤ C) â¥¤ C) :=\n  âŸ¨_, âŸ¨colimConstAdjâŸ©âŸ©\n\n"}
{"name":"CategoryTheory.Limits.colimMap_epi'","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor J C\ninstâœÂ¹ : CategoryTheory.Limits.HasColimitsOfShape J C\nÎ± : Quiver.Hom F G\ninstâœ : CategoryTheory.Epi Î±\nâŠ¢ CategoryTheory.Epi (CategoryTheory.Limits.colimMap Î±)","decl":"instance colimMap_epi' {F G : J â¥¤ C} [HasColimitsOfShape J C] (Î± : F âŸ¶ G) [Epi Î±] :\n    Epi (colimMap Î±) :=\n  (colim : (J â¥¤ C) â¥¤ C).map_epi Î±\n\n"}
{"name":"CategoryTheory.Limits.colimMap_epi","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor J C\ninstâœÂ² : CategoryTheory.Limits.HasColimit F\ninstâœÂ¹ : CategoryTheory.Limits.HasColimit G\nÎ± : Quiver.Hom F G\ninstâœ : âˆ€ (j : J), CategoryTheory.Epi (Î±.app j)\nâŠ¢ CategoryTheory.Epi (CategoryTheory.Limits.colimMap Î±)","decl":"instance colimMap_epi {F G : J â¥¤ C} [HasColimit F] [HasColimit G] (Î± : F âŸ¶ G) [âˆ€ j, Epi (Î±.app j)] :\n    Epi (colimMap Î±) :=\n  âŸ¨fun {Z} u v h =>\n    colimit.hom_ext fun j => (cancel_epi (Î±.app j)).1 <| by simpa using colimit.Î¹ _ j â‰«= hâŸ©\n\n"}
{"name":"CategoryTheory.Limits.hasColimitsOfShape_of_equivalence","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nJ' : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} J'\ne : CategoryTheory.Equivalence J J'\ninstâœ : CategoryTheory.Limits.HasColimitsOfShape J C\nâŠ¢ CategoryTheory.Limits.HasColimitsOfShape J' C","decl":"/-- We can transport colimits of shape `J` along an equivalence `J â‰Œ J'`.\n-/\ntheorem hasColimitsOfShape_of_equivalence {J' : Type uâ‚‚} [Category.{vâ‚‚} J'] (e : J â‰Œ J')\n    [HasColimitsOfShape J C] : HasColimitsOfShape J' C := by\n  constructor\n  intro F\n  apply hasColimit_of_equivalence_comp e\n\n"}
{"name":"CategoryTheory.Limits.hasColimitsOfSizeOfUnivLE","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : UnivLE.{vâ‚‚, vâ‚}\ninstâœÂ¹ : UnivLE.{uâ‚‚, uâ‚}\ninstâœ : CategoryTheory.Limits.HasColimitsOfSize.{vâ‚, uâ‚, v, u} C\nâŠ¢ CategoryTheory.Limits.HasColimitsOfSize.{vâ‚‚, uâ‚‚, v, u} C","decl":"/-- A category that has larger colimits also has smaller colimits. -/\ntheorem hasColimitsOfSizeOfUnivLE [UnivLE.{vâ‚‚, vâ‚}] [UnivLE.{uâ‚‚, uâ‚}]\n    [HasColimitsOfSize.{vâ‚, uâ‚} C] : HasColimitsOfSize.{vâ‚‚, uâ‚‚} C where\n  has_colimits_of_shape J {_} := hasColimitsOfShape_of_equivalence\n    ((ShrinkHoms.equivalence J).trans <| Shrink.equivalence _).symm\n\n"}
{"name":"CategoryTheory.Limits.hasColimitsOfSizeShrink","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasColimitsOfSize.{max vâ‚ vâ‚‚, max uâ‚ uâ‚‚, v, u} C\nâŠ¢ CategoryTheory.Limits.HasColimitsOfSize.{vâ‚, uâ‚, v, u} C","decl":"/-- `hasColimitsOfSizeShrink.{v u} C` tries to obtain `HasColimitsOfSize.{v u} C`\nfrom some other `HasColimitsOfSize C`.\n-/\ntheorem hasColimitsOfSizeShrink [HasColimitsOfSize.{max vâ‚ vâ‚‚, max uâ‚ uâ‚‚} C] :\n    HasColimitsOfSize.{vâ‚, uâ‚} C := hasColimitsOfSizeOfUnivLE.{max vâ‚ vâ‚‚, max uâ‚ uâ‚‚} C\n\n"}
{"name":"CategoryTheory.Limits.hasSmallestColimitsOfHasColimits","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasColimits C\nâŠ¢ CategoryTheory.Limits.HasColimitsOfSize.{0, 0, v, u} C","decl":"instance (priority := 100) hasSmallestColimitsOfHasColimits [HasColimits C] :\n    HasColimitsOfSize.{0, 0} C :=\n  hasColimitsOfSizeShrink.{0, 0} C\n\n"}
