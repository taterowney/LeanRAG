{"name":"CategoryTheory.Limits.LimitCone.mk.injEq","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ncone✝ : CategoryTheory.Limits.Cone F\nisLimit✝ : CategoryTheory.Limits.IsLimit cone✝\ncone : CategoryTheory.Limits.Cone F\nisLimit : CategoryTheory.Limits.IsLimit cone\n⊢ Eq (Eq { cone := cone✝, isLimit := isLimit✝ } { cone := cone, isLimit := isLimit }) (And (Eq cone✝ cone) (HEq isLimit✝ isLimit))","decl":"/-- `LimitCone F` contains a cone over `F` together with the information that it is a limit. -/\nstructure LimitCone (F : J ⥤ C) where\n  /-- The cone itself -/\n  cone : Cone F\n  /-- The proof that is the limit cone -/\n  isLimit : IsLimit cone\n\n"}
{"name":"CategoryTheory.Limits.LimitCone.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝¹ : SizeOf J\ninst✝ : SizeOf C\ncone : CategoryTheory.Limits.Cone F\nisLimit : CategoryTheory.Limits.IsLimit cone\n⊢ Eq (SizeOf.sizeOf { cone := cone, isLimit := isLimit }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf cone)) (SizeOf.sizeOf isLimit))","decl":"/-- `LimitCone F` contains a cone over `F` together with the information that it is a limit. -/\nstructure LimitCone (F : J ⥤ C) where\n  /-- The cone itself -/\n  cone : Cone F\n  /-- The proof that is the limit cone -/\n  isLimit : IsLimit cone\n\n"}
{"name":"CategoryTheory.Limits.LimitCone.mk.inj","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ncone✝ : CategoryTheory.Limits.Cone F\nisLimit✝ : CategoryTheory.Limits.IsLimit cone✝\ncone : CategoryTheory.Limits.Cone F\nisLimit : CategoryTheory.Limits.IsLimit cone\nx✝ : Eq { cone := cone✝, isLimit := isLimit✝ } { cone := cone, isLimit := isLimit }\n⊢ And (Eq cone✝ cone) (HEq isLimit✝ isLimit)","decl":"/-- `LimitCone F` contains a cone over `F` together with the information that it is a limit. -/\nstructure LimitCone (F : J ⥤ C) where\n  /-- The cone itself -/\n  cone : Cone F\n  /-- The proof that is the limit cone -/\n  isLimit : IsLimit cone\n\n"}
{"name":"CategoryTheory.Limits.HasLimit.exists_limit","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\nself : CategoryTheory.Limits.HasLimit F\n⊢ Nonempty (CategoryTheory.Limits.LimitCone F)","decl":"/-- `HasLimit F` represents the mere existence of a limit for `F`. -/\nclass HasLimit (F : J ⥤ C) : Prop where mk' ::\n  /-- There is some limit cone for `F` -/\n  exists_limit : Nonempty (LimitCone F)\n\n"}
{"name":"CategoryTheory.Limits.HasLimit.mk","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\nd : CategoryTheory.Limits.LimitCone F\n⊢ CategoryTheory.Limits.HasLimit F","decl":"theorem HasLimit.mk {F : J ⥤ C} (d : LimitCone F) : HasLimit F :=\n  ⟨Nonempty.intro d⟩\n\n"}
{"name":"CategoryTheory.Limits.HasLimitsOfShape.has_limit","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.Limits.HasLimitsOfShape J C\nF : CategoryTheory.Functor J C\n⊢ CategoryTheory.Limits.HasLimit F","decl":"/-- `C` has limits of shape `J` if there exists a limit for every functor `F : J ⥤ C`. -/\nclass HasLimitsOfShape : Prop where\n  /-- All functors `F : J ⥤ C` from `J` have limits -/\n  has_limit : ∀ F : J ⥤ C, HasLimit F := by infer_instance\n\n"}
{"name":"CategoryTheory.Limits.HasLimitsOfSize.has_limits_of_shape","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.Limits.HasLimitsOfSize.{v₁, u₁, v, u} C\nJ : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} J\n⊢ CategoryTheory.Limits.HasLimitsOfShape J C","decl":"/-- `C` has all limits of size `v₁ u₁` (`HasLimitsOfSize.{v₁ u₁} C`)\nif it has limits of every shape `J : Type u₁` with `[Category.{v₁} J]`.\n-/\n@[pp_with_univ]\nclass HasLimitsOfSize (C : Type u) [Category.{v} C] : Prop where\n  /-- All functors `F : J ⥤ C` from all small `J` have limits -/\n  has_limits_of_shape : ∀ (J : Type u₁) [Category.{v₁} J], HasLimitsOfShape J C := by\n    infer_instance\n\n"}
{"name":"CategoryTheory.Limits.HasLimits.has_limits_of_shape","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasLimits C\nJ : Type v\ninst✝ : CategoryTheory.Category.{v, v} J\n⊢ CategoryTheory.Limits.HasLimitsOfShape J C","decl":"theorem HasLimits.has_limits_of_shape {C : Type u} [Category.{v} C] [HasLimits C] (J : Type v)\n    [Category.{v} J] : HasLimitsOfShape J C :=\n  HasLimitsOfSize.has_limits_of_shape J\n\n"}
{"name":"CategoryTheory.Limits.hasLimitOfHasLimitsOfShape","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape J C\nF : CategoryTheory.Functor J C\n⊢ CategoryTheory.Limits.HasLimit F","decl":"instance (priority := 100) hasLimitOfHasLimitsOfShape {J : Type u₁} [Category.{v₁} J]\n    [HasLimitsOfShape J C] (F : J ⥤ C) : HasLimit F :=\n  HasLimitsOfShape.has_limit F\n\n-- see Note [lower instance priority]\n"}
{"name":"CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\ninst✝ : CategoryTheory.Limits.HasLimitsOfSize.{v₁, u₁, v, u} C\n⊢ CategoryTheory.Limits.HasLimitsOfShape J C","decl":"instance (priority := 100) hasLimitsOfShapeOfHasLimits {J : Type u₁} [Category.{v₁} J]\n    [HasLimitsOfSize.{v₁, u₁} C] : HasLimitsOfShape J C :=\n  HasLimitsOfSize.has_limits_of_shape J\n\n-- Interface to the `HasLimit` class.\n"}
{"name":"CategoryTheory.Limits.limit.π_comp_eqToHom_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasLimit F\nj j' : J\nhj : Eq j j'\nZ : C\nh : Quiver.Hom (F.obj j') Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π F j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ⋯) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π F j') h)","decl":"@[reassoc]\ntheorem limit.π_comp_eqToHom (F : J ⥤ C) [HasLimit F] {j j' : J} (hj : j = j') :\n    limit.π F j ≫ eqToHom (by subst hj; rfl) = limit.π F j' := by\n  subst hj\n  simp\n\n"}
{"name":"CategoryTheory.Limits.limit.π_comp_eqToHom","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasLimit F\nj j' : J\nhj : Eq j j'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π F j) (CategoryTheory.eqToHom ⋯)) (CategoryTheory.Limits.limit.π F j')","decl":"@[reassoc]\ntheorem limit.π_comp_eqToHom (F : J ⥤ C) [HasLimit F] {j j' : J} (hj : j = j') :\n    limit.π F j ≫ eqToHom (by subst hj; rfl) = limit.π F j' := by\n  subst hj\n  simp\n\n"}
{"name":"CategoryTheory.Limits.limit.cone_x","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasLimit F\n⊢ Eq (CategoryTheory.Limits.limit.cone F).pt (CategoryTheory.Limits.limit F)","decl":"@[simp]\ntheorem limit.cone_x {F : J ⥤ C} [HasLimit F] : (limit.cone F).pt = limit F :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.limit.cone_π","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasLimit F\n⊢ Eq (CategoryTheory.Limits.limit.cone F).π.app (CategoryTheory.Limits.limit.π F)","decl":"@[simp]\ntheorem limit.cone_π {F : J ⥤ C} [HasLimit F] : (limit.cone F).π.app = limit.π _ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.limit.w_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasLimit F\nj j' : J\nf : Quiver.Hom j j'\nZ : C\nh : Quiver.Hom (F.obj j') Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π F j) (CategoryTheory.CategoryStruct.comp (F.map f) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π F j') h)","decl":"@[reassoc (attr := simp)]\ntheorem limit.w (F : J ⥤ C) [HasLimit F] {j j' : J} (f : j ⟶ j') :\n    limit.π F j ≫ F.map f = limit.π F j' :=\n  (limit.cone F).w f\n\n"}
{"name":"CategoryTheory.Limits.limit.w","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasLimit F\nj j' : J\nf : Quiver.Hom j j'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π F j) (F.map f)) (CategoryTheory.Limits.limit.π F j')","decl":"@[reassoc (attr := simp)]\ntheorem limit.w (F : J ⥤ C) [HasLimit F] {j j' : J} (f : j ⟶ j') :\n    limit.π F j ≫ F.map f = limit.π F j' :=\n  (limit.cone F).w f\n\n"}
{"name":"CategoryTheory.Limits.limit.isLimit_lift","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasLimit F\nc : CategoryTheory.Limits.Cone F\n⊢ Eq ((CategoryTheory.Limits.limit.isLimit F).lift c) (CategoryTheory.Limits.limit.lift F c)","decl":"@[simp]\ntheorem limit.isLimit_lift {F : J ⥤ C} [HasLimit F] (c : Cone F) :\n    (limit.isLimit F).lift c = limit.lift F c :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.limit.lift_π_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasLimit F\nc : CategoryTheory.Limits.Cone F\nj : J\nZ : C\nh : Quiver.Hom (F.obj j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.lift F c) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π F j) h)) (CategoryTheory.CategoryStruct.comp (c.π.app j) h)","decl":"@[reassoc (attr := simp)]\ntheorem limit.lift_π {F : J ⥤ C} [HasLimit F] (c : Cone F) (j : J) :\n    limit.lift F c ≫ limit.π F j = c.π.app j :=\n  IsLimit.fac _ c j\n\n"}
{"name":"CategoryTheory.Limits.limit.lift_π","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasLimit F\nc : CategoryTheory.Limits.Cone F\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.lift F c) (CategoryTheory.Limits.limit.π F j)) (c.π.app j)","decl":"@[reassoc (attr := simp)]\ntheorem limit.lift_π {F : J ⥤ C} [HasLimit F] (c : Cone F) (j : J) :\n    limit.lift F c ≫ limit.π F j = c.π.app j :=\n  IsLimit.fac _ c j\n\n"}
{"name":"CategoryTheory.Limits.limMap_π_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.HasLimit F\ninst✝ : CategoryTheory.Limits.HasLimit G\nα : Quiver.Hom F G\nj : J\nZ : C\nh : Quiver.Hom (G.obj j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limMap α) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π G j) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π F j) (CategoryTheory.CategoryStruct.comp (α.app j) h))","decl":"@[reassoc (attr := simp)]\ntheorem limMap_π {F G : J ⥤ C} [HasLimit F] [HasLimit G] (α : F ⟶ G) (j : J) :\n    limMap α ≫ limit.π G j = limit.π F j ≫ α.app j :=\n  limit.lift_π _ j\n\n"}
{"name":"CategoryTheory.Limits.limMap_π","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.HasLimit F\ninst✝ : CategoryTheory.Limits.HasLimit G\nα : Quiver.Hom F G\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limMap α) (CategoryTheory.Limits.limit.π G j)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π F j) (α.app j))","decl":"@[reassoc (attr := simp)]\ntheorem limMap_π {F G : J ⥤ C} [HasLimit F] [HasLimit G] (α : F ⟶ G) (j : J) :\n    limMap α ≫ limit.π G j = limit.π F j ≫ α.app j :=\n  limit.lift_π _ j\n\n"}
{"name":"CategoryTheory.Limits.limit.coneMorphism_hom","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasLimit F\nc : CategoryTheory.Limits.Cone F\n⊢ Eq (CategoryTheory.Limits.limit.coneMorphism c).hom (CategoryTheory.Limits.limit.lift F c)","decl":"@[simp]\ntheorem limit.coneMorphism_hom {F : J ⥤ C} [HasLimit F] (c : Cone F) :\n    (limit.coneMorphism c).hom = limit.lift F c :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.limit.coneMorphism_π","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasLimit F\nc : CategoryTheory.Limits.Cone F\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.coneMorphism c).hom (CategoryTheory.Limits.limit.π F j)) (c.π.app j)","decl":"theorem limit.coneMorphism_π {F : J ⥤ C} [HasLimit F] (c : Cone F) (j : J) :\n    (limit.coneMorphism c).hom ≫ limit.π F j = c.π.app j := by simp\n\n"}
{"name":"CategoryTheory.Limits.limit.conePointUniqueUpToIso_hom_comp","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasLimit F\nc : CategoryTheory.Limits.Cone F\nhc : CategoryTheory.Limits.IsLimit c\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (hc.conePointUniqueUpToIso (CategoryTheory.Limits.limit.isLimit F)).hom (CategoryTheory.Limits.limit.π F j)) (c.π.app j)","decl":"@[reassoc (attr := simp)]\ntheorem limit.conePointUniqueUpToIso_hom_comp {F : J ⥤ C} [HasLimit F] {c : Cone F} (hc : IsLimit c)\n    (j : J) : (IsLimit.conePointUniqueUpToIso hc (limit.isLimit _)).hom ≫ limit.π F j = c.π.app j :=\n  IsLimit.conePointUniqueUpToIso_hom_comp _ _ _\n\n"}
{"name":"CategoryTheory.Limits.limit.conePointUniqueUpToIso_hom_comp_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasLimit F\nc : CategoryTheory.Limits.Cone F\nhc : CategoryTheory.Limits.IsLimit c\nj : J\nZ : C\nh : Quiver.Hom (F.obj j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (hc.conePointUniqueUpToIso (CategoryTheory.Limits.limit.isLimit F)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π F j) h)) (CategoryTheory.CategoryStruct.comp (c.π.app j) h)","decl":"@[reassoc (attr := simp)]\ntheorem limit.conePointUniqueUpToIso_hom_comp {F : J ⥤ C} [HasLimit F] {c : Cone F} (hc : IsLimit c)\n    (j : J) : (IsLimit.conePointUniqueUpToIso hc (limit.isLimit _)).hom ≫ limit.π F j = c.π.app j :=\n  IsLimit.conePointUniqueUpToIso_hom_comp _ _ _\n\n"}
{"name":"CategoryTheory.Limits.limit.conePointUniqueUpToIso_inv_comp","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasLimit F\nc : CategoryTheory.Limits.Cone F\nhc : CategoryTheory.Limits.IsLimit c\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Limits.limit.isLimit F).conePointUniqueUpToIso hc).inv (CategoryTheory.Limits.limit.π F j)) (c.π.app j)","decl":"@[reassoc (attr := simp)]\ntheorem limit.conePointUniqueUpToIso_inv_comp {F : J ⥤ C} [HasLimit F] {c : Cone F} (hc : IsLimit c)\n    (j : J) : (IsLimit.conePointUniqueUpToIso (limit.isLimit _) hc).inv ≫ limit.π F j = c.π.app j :=\n  IsLimit.conePointUniqueUpToIso_inv_comp _ _ _\n\n"}
{"name":"CategoryTheory.Limits.limit.conePointUniqueUpToIso_inv_comp_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasLimit F\nc : CategoryTheory.Limits.Cone F\nhc : CategoryTheory.Limits.IsLimit c\nj : J\nZ : C\nh : Quiver.Hom (F.obj j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Limits.limit.isLimit F).conePointUniqueUpToIso hc).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π F j) h)) (CategoryTheory.CategoryStruct.comp (c.π.app j) h)","decl":"@[reassoc (attr := simp)]\ntheorem limit.conePointUniqueUpToIso_inv_comp {F : J ⥤ C} [HasLimit F] {c : Cone F} (hc : IsLimit c)\n    (j : J) : (IsLimit.conePointUniqueUpToIso (limit.isLimit _) hc).inv ≫ limit.π F j = c.π.app j :=\n  IsLimit.conePointUniqueUpToIso_inv_comp _ _ _\n\n"}
{"name":"CategoryTheory.Limits.limit.existsUnique","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasLimit F\nt : CategoryTheory.Limits.Cone F\n⊢ ExistsUnique fun l => ∀ (j : J), Eq (CategoryTheory.CategoryStruct.comp l (CategoryTheory.Limits.limit.π F j)) (t.π.app j)","decl":"theorem limit.existsUnique {F : J ⥤ C} [HasLimit F] (t : Cone F) :\n    ∃! l : t.pt ⟶ limit F, ∀ j, l ≫ limit.π F j = t.π.app j :=\n  (limit.isLimit F).existsUnique _\n\n"}
{"name":"CategoryTheory.Limits.limit.isoLimitCone_hom_π","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasLimit F\nt : CategoryTheory.Limits.LimitCone F\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.isoLimitCone t).hom (t.cone.π.app j)) (CategoryTheory.Limits.limit.π F j)","decl":"@[reassoc (attr := simp)]\ntheorem limit.isoLimitCone_hom_π {F : J ⥤ C} [HasLimit F] (t : LimitCone F) (j : J) :\n    (limit.isoLimitCone t).hom ≫ t.cone.π.app j = limit.π F j := by\n  dsimp [limit.isoLimitCone, IsLimit.conePointUniqueUpToIso]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.limit.isoLimitCone_hom_π_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasLimit F\nt : CategoryTheory.Limits.LimitCone F\nj : J\nZ : C\nh : Quiver.Hom (F.obj j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.isoLimitCone t).hom (CategoryTheory.CategoryStruct.comp (t.cone.π.app j) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π F j) h)","decl":"@[reassoc (attr := simp)]\ntheorem limit.isoLimitCone_hom_π {F : J ⥤ C} [HasLimit F] (t : LimitCone F) (j : J) :\n    (limit.isoLimitCone t).hom ≫ t.cone.π.app j = limit.π F j := by\n  dsimp [limit.isoLimitCone, IsLimit.conePointUniqueUpToIso]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.limit.isoLimitCone_inv_π","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasLimit F\nt : CategoryTheory.Limits.LimitCone F\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.isoLimitCone t).inv (CategoryTheory.Limits.limit.π F j)) (t.cone.π.app j)","decl":"@[reassoc (attr := simp)]\ntheorem limit.isoLimitCone_inv_π {F : J ⥤ C} [HasLimit F] (t : LimitCone F) (j : J) :\n    (limit.isoLimitCone t).inv ≫ limit.π F j = t.cone.π.app j := by\n  dsimp [limit.isoLimitCone, IsLimit.conePointUniqueUpToIso]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.limit.isoLimitCone_inv_π_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasLimit F\nt : CategoryTheory.Limits.LimitCone F\nj : J\nZ : C\nh : Quiver.Hom (F.obj j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.isoLimitCone t).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π F j) h)) (CategoryTheory.CategoryStruct.comp (t.cone.π.app j) h)","decl":"@[reassoc (attr := simp)]\ntheorem limit.isoLimitCone_inv_π {F : J ⥤ C} [HasLimit F] (t : LimitCone F) (j : J) :\n    (limit.isoLimitCone t).inv ≫ limit.π F j = t.cone.π.app j := by\n  dsimp [limit.isoLimitCone, IsLimit.conePointUniqueUpToIso]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.limit.hom_ext","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasLimit F\nX : C\nf f' : Quiver.Hom X (CategoryTheory.Limits.limit F)\nw : ∀ (j : J), Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.Limits.limit.π F j)) (CategoryTheory.CategoryStruct.comp f' (CategoryTheory.Limits.limit.π F j))\n⊢ Eq f f'","decl":"@[ext]\ntheorem limit.hom_ext {F : J ⥤ C} [HasLimit F] {X : C} {f f' : X ⟶ limit F}\n    (w : ∀ j, f ≫ limit.π F j = f' ≫ limit.π F j) : f = f' :=\n  (limit.isLimit F).hom_ext w\n\n"}
{"name":"CategoryTheory.Limits.limit.hom_ext_iff","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasLimit F\nX : C\nf f' : Quiver.Hom X (CategoryTheory.Limits.limit F)\n⊢ Iff (Eq f f') (∀ (j : J), Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.Limits.limit.π F j)) (CategoryTheory.CategoryStruct.comp f' (CategoryTheory.Limits.limit.π F j)))","decl":"@[ext]\ntheorem limit.hom_ext {F : J ⥤ C} [HasLimit F] {X : C} {f f' : X ⟶ limit F}\n    (w : ∀ j, f ≫ limit.π F j = f' ≫ limit.π F j) : f = f' :=\n  (limit.isLimit F).hom_ext w\n\n"}
{"name":"CategoryTheory.Limits.limit.lift_map","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.HasLimit F\ninst✝ : CategoryTheory.Limits.HasLimit G\nc : CategoryTheory.Limits.Cone F\nα : Quiver.Hom F G\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.lift F c) (CategoryTheory.Limits.limMap α)) (CategoryTheory.Limits.limit.lift G ((CategoryTheory.Limits.Cones.postcompose α).obj c))","decl":"@[reassoc (attr := simp)]\ntheorem limit.lift_map {F G : J ⥤ C} [HasLimit F] [HasLimit G] (c : Cone F) (α : F ⟶ G) :\n    limit.lift F c ≫ limMap α = limit.lift G ((Cones.postcompose α).obj c) := by\n  ext\n  rw [assoc, limMap_π, limit.lift_π_assoc, limit.lift_π]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.limit.lift_map_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.HasLimit F\ninst✝ : CategoryTheory.Limits.HasLimit G\nc : CategoryTheory.Limits.Cone F\nα : Quiver.Hom F G\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.limit G) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.lift F c) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limMap α) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.lift G ((CategoryTheory.Limits.Cones.postcompose α).obj c)) h)","decl":"@[reassoc (attr := simp)]\ntheorem limit.lift_map {F G : J ⥤ C} [HasLimit F] [HasLimit G] (c : Cone F) (α : F ⟶ G) :\n    limit.lift F c ≫ limMap α = limit.lift G ((Cones.postcompose α).obj c) := by\n  ext\n  rw [assoc, limMap_π, limit.lift_π_assoc, limit.lift_π]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.limit.lift_cone","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasLimit F\n⊢ Eq (CategoryTheory.Limits.limit.lift F (CategoryTheory.Limits.limit.cone F)) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.limit F))","decl":"@[simp]\ntheorem limit.lift_cone {F : J ⥤ C} [HasLimit F] : limit.lift F (limit.cone F) = 𝟙 (limit F) :=\n  (limit.isLimit _).lift_self\n\n"}
{"name":"CategoryTheory.Limits.limit.homIso_hom","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasLimit F\nW : C\nf : ULift.{u₁, v} (Quiver.Hom W (CategoryTheory.Limits.limit F))\n⊢ Eq ((CategoryTheory.Limits.limit.homIso F W).hom f) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.const J).map f.down) (CategoryTheory.Limits.limit.cone F).π)","decl":"@[simp]\ntheorem limit.homIso_hom (F : J ⥤ C) [HasLimit F] {W : C} (f : ULift (W ⟶ limit F)) :\n    (limit.homIso F W).hom f = (const J).map f.down ≫ (limit.cone F).π :=\n  (limit.isLimit F).homIso_hom f\n\n"}
{"name":"CategoryTheory.Limits.limit.lift_extend","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasLimit F\nc : CategoryTheory.Limits.Cone F\nX : C\nf : Quiver.Hom X c.pt\n⊢ Eq (CategoryTheory.Limits.limit.lift F (c.extend f)) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.Limits.limit.lift F c))","decl":"theorem limit.lift_extend {F : J ⥤ C} [HasLimit F] (c : Cone F) {X : C} (f : X ⟶ c.pt) :\n    limit.lift F (c.extend f) = f ≫ limit.lift F c := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.hasLimitOfIso","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasLimit F\nα : CategoryTheory.Iso F G\n⊢ CategoryTheory.Limits.HasLimit G","decl":"/-- If a functor `F` has a limit, so does any naturally isomorphic functor.\n-/\ntheorem hasLimitOfIso {F G : J ⥤ C} [HasLimit F] (α : F ≅ G) : HasLimit G :=\n  HasLimit.mk\n    { cone := (Cones.postcompose α.hom).obj (limit.cone F)\n      isLimit := (IsLimit.postcomposeHomEquiv _ _).symm (limit.isLimit F) }\n\n-- See the construction of limits from products and equalizers\n-- for an example usage.\n"}
{"name":"CategoryTheory.Limits.HasLimit.ofConesIso","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ K : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\ninst✝¹ : CategoryTheory.Category.{v₂, u₁} K\nF : CategoryTheory.Functor J C\nG : CategoryTheory.Functor K C\nh : CategoryTheory.Iso F.cones G.cones\ninst✝ : CategoryTheory.Limits.HasLimit F\n⊢ CategoryTheory.Limits.HasLimit G","decl":"/-- If a functor `G` has the same collection of cones as a functor `F`\nwhich has a limit, then `G` also has a limit. -/\ntheorem HasLimit.ofConesIso {J K : Type u₁} [Category.{v₁} J] [Category.{v₂} K] (F : J ⥤ C)\n    (G : K ⥤ C) (h : F.cones ≅ G.cones) [HasLimit F] : HasLimit G :=\n  HasLimit.mk ⟨_, IsLimit.ofNatIso (IsLimit.natIso (limit.isLimit F) ≪≫ h)⟩\n\n"}
{"name":"CategoryTheory.Limits.HasLimit.isoOfNatIso_hom_π","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.HasLimit F\ninst✝ : CategoryTheory.Limits.HasLimit G\nw : CategoryTheory.Iso F G\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.HasLimit.isoOfNatIso w).hom (CategoryTheory.Limits.limit.π G j)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π F j) (w.hom.app j))","decl":"@[reassoc (attr := simp)]\ntheorem HasLimit.isoOfNatIso_hom_π {F G : J ⥤ C} [HasLimit F] [HasLimit G] (w : F ≅ G) (j : J) :\n    (HasLimit.isoOfNatIso w).hom ≫ limit.π G j = limit.π F j ≫ w.hom.app j :=\n  IsLimit.conePointsIsoOfNatIso_hom_comp _ _ _ _\n\n"}
{"name":"CategoryTheory.Limits.HasLimit.isoOfNatIso_hom_π_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.HasLimit F\ninst✝ : CategoryTheory.Limits.HasLimit G\nw : CategoryTheory.Iso F G\nj : J\nZ : C\nh : Quiver.Hom (G.obj j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.HasLimit.isoOfNatIso w).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π G j) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π F j) (CategoryTheory.CategoryStruct.comp (w.hom.app j) h))","decl":"@[reassoc (attr := simp)]\ntheorem HasLimit.isoOfNatIso_hom_π {F G : J ⥤ C} [HasLimit F] [HasLimit G] (w : F ≅ G) (j : J) :\n    (HasLimit.isoOfNatIso w).hom ≫ limit.π G j = limit.π F j ≫ w.hom.app j :=\n  IsLimit.conePointsIsoOfNatIso_hom_comp _ _ _ _\n\n"}
{"name":"CategoryTheory.Limits.HasLimit.isoOfNatIso_inv_π_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.HasLimit F\ninst✝ : CategoryTheory.Limits.HasLimit G\nw : CategoryTheory.Iso F G\nj : J\nZ : C\nh : Quiver.Hom (F.obj j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.HasLimit.isoOfNatIso w).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π F j) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π G j) (CategoryTheory.CategoryStruct.comp (w.inv.app j) h))","decl":"@[reassoc (attr := simp)]\ntheorem HasLimit.isoOfNatIso_inv_π {F G : J ⥤ C} [HasLimit F] [HasLimit G] (w : F ≅ G) (j : J) :\n    (HasLimit.isoOfNatIso w).inv ≫ limit.π F j = limit.π G j ≫ w.inv.app j :=\n  IsLimit.conePointsIsoOfNatIso_inv_comp _ _ _ _\n\n"}
{"name":"CategoryTheory.Limits.HasLimit.isoOfNatIso_inv_π","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.HasLimit F\ninst✝ : CategoryTheory.Limits.HasLimit G\nw : CategoryTheory.Iso F G\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.HasLimit.isoOfNatIso w).inv (CategoryTheory.Limits.limit.π F j)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π G j) (w.inv.app j))","decl":"@[reassoc (attr := simp)]\ntheorem HasLimit.isoOfNatIso_inv_π {F G : J ⥤ C} [HasLimit F] [HasLimit G] (w : F ≅ G) (j : J) :\n    (HasLimit.isoOfNatIso w).inv ≫ limit.π F j = limit.π G j ≫ w.inv.app j :=\n  IsLimit.conePointsIsoOfNatIso_inv_comp _ _ _ _\n\n"}
{"name":"CategoryTheory.Limits.HasLimit.lift_isoOfNatIso_hom","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.HasLimit F\ninst✝ : CategoryTheory.Limits.HasLimit G\nt : CategoryTheory.Limits.Cone F\nw : CategoryTheory.Iso F G\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.lift F t) (CategoryTheory.Limits.HasLimit.isoOfNatIso w).hom) (CategoryTheory.Limits.limit.lift G ((CategoryTheory.Limits.Cones.postcompose w.hom).obj t))","decl":"@[reassoc (attr := simp)]\ntheorem HasLimit.lift_isoOfNatIso_hom {F G : J ⥤ C} [HasLimit F] [HasLimit G] (t : Cone F)\n    (w : F ≅ G) :\n    limit.lift F t ≫ (HasLimit.isoOfNatIso w).hom =\n      limit.lift G ((Cones.postcompose w.hom).obj _) :=\n  IsLimit.lift_comp_conePointsIsoOfNatIso_hom _ _ _\n\n"}
{"name":"CategoryTheory.Limits.HasLimit.lift_isoOfNatIso_hom_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.HasLimit F\ninst✝ : CategoryTheory.Limits.HasLimit G\nt : CategoryTheory.Limits.Cone F\nw : CategoryTheory.Iso F G\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.limit G) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.lift F t) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.HasLimit.isoOfNatIso w).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.lift G ((CategoryTheory.Limits.Cones.postcompose w.hom).obj t)) h)","decl":"@[reassoc (attr := simp)]\ntheorem HasLimit.lift_isoOfNatIso_hom {F G : J ⥤ C} [HasLimit F] [HasLimit G] (t : Cone F)\n    (w : F ≅ G) :\n    limit.lift F t ≫ (HasLimit.isoOfNatIso w).hom =\n      limit.lift G ((Cones.postcompose w.hom).obj _) :=\n  IsLimit.lift_comp_conePointsIsoOfNatIso_hom _ _ _\n\n"}
{"name":"CategoryTheory.Limits.HasLimit.lift_isoOfNatIso_inv_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.HasLimit F\ninst✝ : CategoryTheory.Limits.HasLimit G\nt : CategoryTheory.Limits.Cone G\nw : CategoryTheory.Iso F G\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.limit F) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.lift G t) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.HasLimit.isoOfNatIso w).inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.lift F ((CategoryTheory.Limits.Cones.postcompose w.inv).obj t)) h)","decl":"@[reassoc (attr := simp)]\ntheorem HasLimit.lift_isoOfNatIso_inv {F G : J ⥤ C} [HasLimit F] [HasLimit G] (t : Cone G)\n    (w : F ≅ G) :\n    limit.lift G t ≫ (HasLimit.isoOfNatIso w).inv =\n      limit.lift F ((Cones.postcompose w.inv).obj _) :=\n  IsLimit.lift_comp_conePointsIsoOfNatIso_inv _ _ _\n\n"}
{"name":"CategoryTheory.Limits.HasLimit.lift_isoOfNatIso_inv","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.HasLimit F\ninst✝ : CategoryTheory.Limits.HasLimit G\nt : CategoryTheory.Limits.Cone G\nw : CategoryTheory.Iso F G\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.lift G t) (CategoryTheory.Limits.HasLimit.isoOfNatIso w).inv) (CategoryTheory.Limits.limit.lift F ((CategoryTheory.Limits.Cones.postcompose w.inv).obj t))","decl":"@[reassoc (attr := simp)]\ntheorem HasLimit.lift_isoOfNatIso_inv {F G : J ⥤ C} [HasLimit F] [HasLimit G] (t : Cone G)\n    (w : F ≅ G) :\n    limit.lift G t ≫ (HasLimit.isoOfNatIso w).inv =\n      limit.lift F ((Cones.postcompose w.inv).obj _) :=\n  IsLimit.lift_comp_conePointsIsoOfNatIso_inv _ _ _\n\n"}
{"name":"CategoryTheory.Limits.HasLimit.isoOfEquivalence_hom_π","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} K\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.HasLimit F\nG : CategoryTheory.Functor K C\ninst✝ : CategoryTheory.Limits.HasLimit G\ne : CategoryTheory.Equivalence J K\nw : CategoryTheory.Iso (e.functor.comp G) F\nk : K\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.HasLimit.isoOfEquivalence e w).hom (CategoryTheory.Limits.limit.π G k)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π F (e.inverse.obj k)) (CategoryTheory.CategoryStruct.comp (w.inv.app (e.inverse.obj k)) (G.map (e.counit.app k))))","decl":"@[simp]\ntheorem HasLimit.isoOfEquivalence_hom_π {F : J ⥤ C} [HasLimit F] {G : K ⥤ C} [HasLimit G]\n    (e : J ≌ K) (w : e.functor ⋙ G ≅ F) (k : K) :\n    (HasLimit.isoOfEquivalence e w).hom ≫ limit.π G k =\n      limit.π F (e.inverse.obj k) ≫ w.inv.app (e.inverse.obj k) ≫ G.map (e.counit.app k) := by\n  simp only [HasLimit.isoOfEquivalence, IsLimit.conePointsIsoOfEquivalence_hom]\n  dsimp\n  simp\n\n"}
{"name":"CategoryTheory.Limits.HasLimit.isoOfEquivalence_inv_π","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} K\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.HasLimit F\nG : CategoryTheory.Functor K C\ninst✝ : CategoryTheory.Limits.HasLimit G\ne : CategoryTheory.Equivalence J K\nw : CategoryTheory.Iso (e.functor.comp G) F\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.HasLimit.isoOfEquivalence e w).inv (CategoryTheory.Limits.limit.π F j)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π G (e.functor.obj j)) (w.hom.app j))","decl":"@[simp]\ntheorem HasLimit.isoOfEquivalence_inv_π {F : J ⥤ C} [HasLimit F] {G : K ⥤ C} [HasLimit G]\n    (e : J ≌ K) (w : e.functor ⋙ G ≅ F) (j : J) :\n    (HasLimit.isoOfEquivalence e w).inv ≫ limit.π F j =\n    limit.π G (e.functor.obj j) ≫ w.hom.app j := by\n  simp only [HasLimit.isoOfEquivalence, IsLimit.conePointsIsoOfEquivalence_hom]\n  dsimp\n  simp\n\n"}
{"name":"CategoryTheory.Limits.limit.pre_π","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} K\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.HasLimit F\nE : CategoryTheory.Functor K J\ninst✝ : CategoryTheory.Limits.HasLimit (E.comp F)\nk : K\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.pre F E) (CategoryTheory.Limits.limit.π (E.comp F) k)) (CategoryTheory.Limits.limit.π F (E.obj k))","decl":"@[reassoc (attr := simp)]\ntheorem limit.pre_π (k : K) : limit.pre F E ≫ limit.π (E ⋙ F) k = limit.π F (E.obj k) := by\n  erw [IsLimit.fac]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.limit.pre_π_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} K\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.HasLimit F\nE : CategoryTheory.Functor K J\ninst✝ : CategoryTheory.Limits.HasLimit (E.comp F)\nk : K\nZ : C\nh : Quiver.Hom (F.obj (E.obj k)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.pre F E) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π (E.comp F) k) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π F (E.obj k)) h)","decl":"@[reassoc (attr := simp)]\ntheorem limit.pre_π (k : K) : limit.pre F E ≫ limit.π (E ⋙ F) k = limit.π F (E.obj k) := by\n  erw [IsLimit.fac]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.limit.lift_pre","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} K\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.HasLimit F\nE : CategoryTheory.Functor K J\ninst✝ : CategoryTheory.Limits.HasLimit (E.comp F)\nc : CategoryTheory.Limits.Cone F\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.lift F c) (CategoryTheory.Limits.limit.pre F E)) (CategoryTheory.Limits.limit.lift (E.comp F) (CategoryTheory.Limits.Cone.whisker E c))","decl":"@[simp]\ntheorem limit.lift_pre (c : Cone F) :\n    limit.lift F c ≫ limit.pre F E = limit.lift (E ⋙ F) (c.whisker E) := by ext; simp\n\n"}
{"name":"CategoryTheory.Limits.limit.pre_pre","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} K\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝² : CategoryTheory.Limits.HasLimit F\nE : CategoryTheory.Functor K J\ninst✝¹ : CategoryTheory.Limits.HasLimit (E.comp F)\nL : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} L\nD : CategoryTheory.Functor L K\nh : CategoryTheory.Limits.HasLimit (D.comp (E.comp F))\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.pre F E) (CategoryTheory.Limits.limit.pre (E.comp F) D)) (CategoryTheory.Limits.limit.pre F (D.comp E))","decl":"@[simp]\ntheorem limit.pre_pre [h : HasLimit (D ⋙ E ⋙ F)] : haveI : HasLimit ((D ⋙ E) ⋙ F) := h\n    limit.pre F E ≫ limit.pre (E ⋙ F) D = limit.pre F (D ⋙ E) := by\n  haveI : HasLimit ((D ⋙ E) ⋙ F) := h\n  ext j; erw [assoc, limit.pre_π, limit.pre_π, limit.pre_π]; rfl\n\n"}
{"name":"CategoryTheory.Limits.limit.pre_eq","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} K\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.HasLimit F\nE : CategoryTheory.Functor K J\ninst✝ : CategoryTheory.Limits.HasLimit (E.comp F)\ns : CategoryTheory.Limits.LimitCone (E.comp F)\nt : CategoryTheory.Limits.LimitCone F\n⊢ Eq (CategoryTheory.Limits.limit.pre F E) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.isoLimitCone t).hom (CategoryTheory.CategoryStruct.comp (s.isLimit.lift (CategoryTheory.Limits.Cone.whisker E t.cone)) (CategoryTheory.Limits.limit.isoLimitCone s).inv))","decl":"/-- -\nIf we have particular limit cones available for `E ⋙ F` and for `F`,\nwe obtain a formula for `limit.pre F E`.\n-/\ntheorem limit.pre_eq (s : LimitCone (E ⋙ F)) (t : LimitCone F) :\n    limit.pre F E = (limit.isoLimitCone t).hom ≫ s.isLimit.lift (t.cone.whisker E) ≫\n      (limit.isoLimitCone s).inv := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.limit.post_π_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝² : CategoryTheory.Category.{v', u'} D\nF : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.HasLimit F\nG : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.HasLimit (F.comp G)\nj : J\nZ : D\nh : Quiver.Hom (G.obj (F.obj j)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.post F G) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π (F.comp G) j) h)) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.limit.π F j)) h)","decl":"@[reassoc (attr := simp)]\ntheorem limit.post_π (j : J) : limit.post F G ≫ limit.π (F ⋙ G) j = G.map (limit.π F j) := by\n  erw [IsLimit.fac]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.limit.post_π","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝² : CategoryTheory.Category.{v', u'} D\nF : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.HasLimit F\nG : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.HasLimit (F.comp G)\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.post F G) (CategoryTheory.Limits.limit.π (F.comp G) j)) (G.map (CategoryTheory.Limits.limit.π F j))","decl":"@[reassoc (attr := simp)]\ntheorem limit.post_π (j : J) : limit.post F G ≫ limit.π (F ⋙ G) j = G.map (limit.π F j) := by\n  erw [IsLimit.fac]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.limit.lift_post","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝² : CategoryTheory.Category.{v', u'} D\nF : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.HasLimit F\nG : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.HasLimit (F.comp G)\nc : CategoryTheory.Limits.Cone F\n⊢ Eq (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.limit.lift F c)) (CategoryTheory.Limits.limit.post F G)) (CategoryTheory.Limits.limit.lift (F.comp G) (G.mapCone c))","decl":"@[simp]\ntheorem limit.lift_post (c : Cone F) :\n    G.map (limit.lift F c) ≫ limit.post F G = limit.lift (F ⋙ G) (G.mapCone c) := by\n  ext\n  rw [assoc, limit.post_π, ← G.map_comp, limit.lift_π, limit.lift_π]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.limit.post_post","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} D\nF : CategoryTheory.Functor J C\ninst✝² : CategoryTheory.Limits.HasLimit F\nG : CategoryTheory.Functor C D\ninst✝¹ : CategoryTheory.Limits.HasLimit (F.comp G)\nE : Type u''\ninst✝ : CategoryTheory.Category.{v'', u''} E\nH : CategoryTheory.Functor D E\nh : CategoryTheory.Limits.HasLimit ((F.comp G).comp H)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (H.map (CategoryTheory.Limits.limit.post F G)) (CategoryTheory.Limits.limit.post (F.comp G) H)) (CategoryTheory.Limits.limit.post F (G.comp H))","decl":"@[simp]\ntheorem limit.post_post {E : Type u''} [Category.{v''} E] (H : D ⥤ E) [h : HasLimit ((F ⋙ G) ⋙ H)] :\n    -- H G (limit F) ⟶ H (limit (F ⋙ G)) ⟶ limit ((F ⋙ G) ⋙ H) equals\n    -- H G (limit F) ⟶ limit (F ⋙ (G ⋙ H))\n    haveI : HasLimit (F ⋙ G ⋙ H) := h\n    H.map (limit.post F G) ≫ limit.post (F ⋙ G) H = limit.post F (G ⋙ H) := by\n  haveI : HasLimit (F ⋙ G ⋙ H) := h\n  ext; erw [assoc, limit.post_π, ← H.map_comp, limit.post_π, limit.post_π]; rfl\n\n"}
{"name":"CategoryTheory.Limits.limit.pre_post","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} K\nC : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} D\nE : CategoryTheory.Functor K J\nF : CategoryTheory.Functor J C\nG : CategoryTheory.Functor C D\ninst✝² : CategoryTheory.Limits.HasLimit F\ninst✝¹ : CategoryTheory.Limits.HasLimit (E.comp F)\ninst✝ : CategoryTheory.Limits.HasLimit (F.comp G)\nh : CategoryTheory.Limits.HasLimit ((E.comp F).comp G)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.limit.pre F E)) (CategoryTheory.Limits.limit.post (E.comp F) G)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.post F G) (CategoryTheory.Limits.limit.pre (F.comp G) E))","decl":"theorem limit.pre_post {D : Type u'} [Category.{v'} D] (E : K ⥤ J) (F : J ⥤ C) (G : C ⥤ D)\n    [HasLimit F] [HasLimit (E ⋙ F)] [HasLimit (F ⋙ G)]\n    [h : HasLimit ((E ⋙ F) ⋙ G)] :-- G (limit F) ⟶ G (limit (E ⋙ F)) ⟶ limit ((E ⋙ F) ⋙ G) vs\n            -- G (limit F) ⟶ limit F ⋙ G ⟶ limit (E ⋙ (F ⋙ G)) or\n    haveI : HasLimit (E ⋙ F ⋙ G) := h\n    G.map (limit.pre F E) ≫ limit.post (E ⋙ F) G = limit.post F G ≫ limit.pre (F ⋙ G) E := by\n  haveI : HasLimit (E ⋙ F ⋙ G) := h\n  ext; erw [assoc, limit.post_π, ← G.map_comp, limit.pre_π, assoc, limit.pre_π, limit.post_π]\n\n"}
{"name":"CategoryTheory.Limits.hasLimitEquivalenceComp","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} K\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ne : CategoryTheory.Equivalence K J\ninst✝ : CategoryTheory.Limits.HasLimit F\n⊢ CategoryTheory.Limits.HasLimit (e.functor.comp F)","decl":"instance hasLimitEquivalenceComp (e : K ≌ J) [HasLimit F] : HasLimit (e.functor ⋙ F) :=\n  HasLimit.mk\n    { cone := Cone.whisker e.functor (limit.cone F)\n      isLimit := IsLimit.whiskerEquivalence (limit.isLimit F) e }\n\n-- Porting note: testing whether this still needed\n-- attribute [local elab_without_expected_type] inv_fun_id_assoc\n\n-- not entirely sure why this is needed\n"}
{"name":"CategoryTheory.Limits.hasLimitOfEquivalenceComp","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} K\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ne : CategoryTheory.Equivalence K J\ninst✝ : CategoryTheory.Limits.HasLimit (e.functor.comp F)\n⊢ CategoryTheory.Limits.HasLimit F","decl":"/-- If a `E ⋙ F` has a limit, and `E` is an equivalence, we can construct a limit of `F`.\n-/\ntheorem hasLimitOfEquivalenceComp (e : K ≌ J) [HasLimit (e.functor ⋙ F)] : HasLimit F := by\n  haveI : HasLimit (e.inverse ⋙ e.functor ⋙ F) := Limits.hasLimitEquivalenceComp e.symm\n  apply hasLimitOfIso (e.invFunIdAssoc F)\n\n-- `hasLimitCompEquivalence` and `hasLimitOfCompEquivalence`\n-- are proved in `CategoryTheory/Adjunction/Limits.lean`.\n"}
{"name":"CategoryTheory.Limits.lim_map","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape J C\nX✝ Y✝ : CategoryTheory.Functor J C\nα : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.Limits.lim.map α) (CategoryTheory.Limits.limMap α)","decl":"/-- `limit F` is functorial in `F`, when `C` has all limits of shape `J`. -/\n@[simps]\ndef lim : (J ⥤ C) ⥤ C where\n  obj F := limit F\n  map α := limMap α\n  map_id F := by\n    apply Limits.limit.hom_ext; intro j\n    simp\n  map_comp α β := by\n    apply Limits.limit.hom_ext; intro j\n    simp [assoc]\n\n"}
{"name":"CategoryTheory.Limits.lim_obj","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape J C\nF : CategoryTheory.Functor J C\n⊢ Eq (CategoryTheory.Limits.lim.obj F) (CategoryTheory.Limits.limit F)","decl":"/-- `limit F` is functorial in `F`, when `C` has all limits of shape `J`. -/\n@[simps]\ndef lim : (J ⥤ C) ⥤ C where\n  obj F := limit F\n  map α := limMap α\n  map_id F := by\n    apply Limits.limit.hom_ext; intro j\n    simp\n  map_comp α β := by\n    apply Limits.limit.hom_ext; intro j\n    simp [assoc]\n\n"}
{"name":"CategoryTheory.Limits.limMap_eq","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape J C\nG : CategoryTheory.Functor J C\nα : Quiver.Hom F G\n⊢ Eq (CategoryTheory.Limits.limMap α) (CategoryTheory.Limits.lim.map α)","decl":"theorem limMap_eq : limMap α = lim.map α := rfl\n\n"}
{"name":"CategoryTheory.Limits.limit.map_pre","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} K\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.HasLimitsOfShape J C\nG : CategoryTheory.Functor J C\nα : Quiver.Hom F G\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape K C\nE : CategoryTheory.Functor K J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.lim.map α) (CategoryTheory.Limits.limit.pre G E)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.pre F E) (CategoryTheory.Limits.lim.map (CategoryTheory.whiskerLeft E α)))","decl":"theorem limit.map_pre [HasLimitsOfShape K C] (E : K ⥤ J) :\n    lim.map α ≫ limit.pre G E = limit.pre F E ≫ lim.map (whiskerLeft E α) := by\n  ext\n  simp\n\n"}
{"name":"CategoryTheory.Limits.limit.map_pre'","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} K\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasLimitsOfShape J C\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape K C\nF : CategoryTheory.Functor J C\nE₁ E₂ : CategoryTheory.Functor K J\nα : Quiver.Hom E₁ E₂\n⊢ Eq (CategoryTheory.Limits.limit.pre F E₂) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.pre F E₁) (CategoryTheory.Limits.lim.map (CategoryTheory.whiskerRight α F)))","decl":"theorem limit.map_pre' [HasLimitsOfShape K C] (F : J ⥤ C) {E₁ E₂ : K ⥤ J} (α : E₁ ⟶ E₂) :\n    limit.pre F E₂ = limit.pre F E₁ ≫ lim.map (whiskerRight α F) := by\n  ext1; simp [← category.assoc]\n\n"}
{"name":"CategoryTheory.Limits.limit.id_pre","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape J C\nF : CategoryTheory.Functor J C\n⊢ Eq (CategoryTheory.Limits.limit.pre F (CategoryTheory.Functor.id J)) (CategoryTheory.Limits.lim.map F.leftUnitor.inv)","decl":"theorem limit.id_pre (F : J ⥤ C) : limit.pre F (𝟭 _) = lim.map (Functor.leftUnitor F).inv := by\n  aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.limit.map_post","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝² : CategoryTheory.Limits.HasLimitsOfShape J C\nG : CategoryTheory.Functor J C\nα : Quiver.Hom F G\nD : Type u'\ninst✝¹ : CategoryTheory.Category.{v', u'} D\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape J D\nH : CategoryTheory.Functor C D\n⊢ Eq (CategoryTheory.CategoryStruct.comp (H.map (CategoryTheory.Limits.limMap α)) (CategoryTheory.Limits.limit.post G H)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.post F H) (CategoryTheory.Limits.limMap (CategoryTheory.whiskerRight α H)))","decl":"theorem limit.map_post {D : Type u'} [Category.{v'} D] [HasLimitsOfShape J D] (H : C ⥤ D) :\n    /- H (limit F) ⟶ H (limit G) ⟶ limit (G ⋙ H) vs\n     H (limit F) ⟶ limit (F ⋙ H) ⟶ limit (G ⋙ H) -/\n    H.map (limMap α) ≫ limit.post G H = limit.post F H ≫ limMap (whiskerRight α H) := by\n  ext\n  simp only [whiskerRight_app, limMap_π, assoc, limit.post_π_assoc, limit.post_π, ← H.map_comp]\n\n"}
{"name":"CategoryTheory.Limits.instIsRightAdjointFunctorLim","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape J C\n⊢ CategoryTheory.Limits.lim.IsRightAdjoint","decl":"instance : IsRightAdjoint (lim : (J ⥤ C) ⥤ C) :=\n  ⟨_, ⟨constLimAdj⟩⟩\n\n"}
{"name":"CategoryTheory.Limits.limMap_mono'","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.HasLimitsOfShape J C\nα : Quiver.Hom F G\ninst✝ : CategoryTheory.Mono α\n⊢ CategoryTheory.Mono (CategoryTheory.Limits.limMap α)","decl":"instance limMap_mono' {F G : J ⥤ C} [HasLimitsOfShape J C] (α : F ⟶ G) [Mono α] : Mono (limMap α) :=\n  (lim : (J ⥤ C) ⥤ C).map_mono α\n\n"}
{"name":"CategoryTheory.Limits.limMap_mono","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor J C\ninst✝² : CategoryTheory.Limits.HasLimit F\ninst✝¹ : CategoryTheory.Limits.HasLimit G\nα : Quiver.Hom F G\ninst✝ : ∀ (j : J), CategoryTheory.Mono (α.app j)\n⊢ CategoryTheory.Mono (CategoryTheory.Limits.limMap α)","decl":"instance limMap_mono {F G : J ⥤ C} [HasLimit F] [HasLimit G] (α : F ⟶ G) [∀ j, Mono (α.app j)] :\n    Mono (limMap α) :=\n  ⟨fun {Z} u v h =>\n    limit.hom_ext fun j => (cancel_mono (α.app j)).1 <| by simpa using h =≫ limit.π _ j⟩\n\n"}
{"name":"CategoryTheory.Limits.coneOfAdj_pt","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nL : CategoryTheory.Functor (CategoryTheory.Functor J C) C\nadj : CategoryTheory.Adjunction (CategoryTheory.Functor.const J) L\nF : CategoryTheory.Functor J C\n⊢ Eq (CategoryTheory.Limits.coneOfAdj adj F).pt (L.obj F)","decl":"/-- The limit cone obtained from a right adjoint of the constant functor. -/\n@[simps]\nnoncomputable def coneOfAdj (F : J ⥤ C) : Cone F where\n  pt := L.obj F\n  π := adj.counit.app F\n\n"}
{"name":"CategoryTheory.Limits.coneOfAdj_π","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nL : CategoryTheory.Functor (CategoryTheory.Functor J C) C\nadj : CategoryTheory.Adjunction (CategoryTheory.Functor.const J) L\nF : CategoryTheory.Functor J C\n⊢ Eq (CategoryTheory.Limits.coneOfAdj adj F).π (adj.counit.app F)","decl":"/-- The limit cone obtained from a right adjoint of the constant functor. -/\n@[simps]\nnoncomputable def coneOfAdj (F : J ⥤ C) : Cone F where\n  pt := L.obj F\n  π := adj.counit.app F\n\n"}
{"name":"CategoryTheory.Limits.isLimitConeOfAdj_lift","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nL : CategoryTheory.Functor (CategoryTheory.Functor J C) C\nadj : CategoryTheory.Adjunction (CategoryTheory.Functor.const J) L\nF : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cone F\n⊢ Eq ((CategoryTheory.Limits.isLimitConeOfAdj adj F).lift s) ((adj.homEquiv s.pt F) s.π)","decl":"/-- The cones defined by `coneOfAdj` are limit cones. -/\n@[simps]\ndef isLimitConeOfAdj (F : J ⥤ C) :\n    IsLimit (coneOfAdj adj F) where\n  lift s := adj.homEquiv _ _ s.π\n  fac s j := by\n    have eq := NatTrans.congr_app (adj.counit.naturality s.π) j\n    have eq' := NatTrans.congr_app (adj.left_triangle_components s.pt) j\n    dsimp at eq eq' ⊢\n    rw [adj.homEquiv_unit, assoc, eq, reassoc_of% eq']\n  uniq s m hm := (adj.homEquiv _ _).symm.injective (by ext j; simpa using hm j)\n\n"}
{"name":"CategoryTheory.Limits.hasLimitsOfShape_of_equivalence","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ' : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} J'\ne : CategoryTheory.Equivalence J J'\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape J C\n⊢ CategoryTheory.Limits.HasLimitsOfShape J' C","decl":"/-- We can transport limits of shape `J` along an equivalence `J ≌ J'`.\n-/\ntheorem hasLimitsOfShape_of_equivalence {J' : Type u₂} [Category.{v₂} J'] (e : J ≌ J')\n    [HasLimitsOfShape J C] : HasLimitsOfShape J' C := by\n  constructor\n  intro F\n  apply hasLimitOfEquivalenceComp e\n\n"}
{"name":"CategoryTheory.Limits.hasLimitsOfSizeOfUnivLE","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : UnivLE.{v₂, v₁}\ninst✝¹ : UnivLE.{u₂, u₁}\ninst✝ : CategoryTheory.Limits.HasLimitsOfSize.{v₁, u₁, v, u} C\n⊢ CategoryTheory.Limits.HasLimitsOfSize.{v₂, u₂, v, u} C","decl":"/-- A category that has larger limits also has smaller limits. -/\ntheorem hasLimitsOfSizeOfUnivLE [UnivLE.{v₂, v₁}] [UnivLE.{u₂, u₁}]\n    [HasLimitsOfSize.{v₁, u₁} C] : HasLimitsOfSize.{v₂, u₂} C where\n  has_limits_of_shape J {_} := hasLimitsOfShape_of_equivalence\n    ((ShrinkHoms.equivalence J).trans <| Shrink.equivalence _).symm\n\n"}
{"name":"CategoryTheory.Limits.hasLimitsOfSizeShrink","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasLimitsOfSize.{max v₁ v₂, max u₁ u₂, v, u} C\n⊢ CategoryTheory.Limits.HasLimitsOfSize.{v₁, u₁, v, u} C","decl":"/-- `hasLimitsOfSizeShrink.{v u} C` tries to obtain `HasLimitsOfSize.{v u} C`\nfrom some other `HasLimitsOfSize C`.\n-/\ntheorem hasLimitsOfSizeShrink [HasLimitsOfSize.{max v₁ v₂, max u₁ u₂} C] :\n    HasLimitsOfSize.{v₁, u₁} C := hasLimitsOfSizeOfUnivLE.{max v₁ v₂, max u₁ u₂} C\n\n"}
{"name":"CategoryTheory.Limits.hasSmallestLimitsOfHasLimits","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasLimits C\n⊢ CategoryTheory.Limits.HasLimitsOfSize.{0, 0, v, u} C","decl":"instance (priority := 100) hasSmallestLimitsOfHasLimits [HasLimits C] : HasLimitsOfSize.{0, 0} C :=\n  hasLimitsOfSizeShrink.{0, 0} C\n\n"}
{"name":"CategoryTheory.Limits.ColimitCocone.mk.injEq","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ncocone✝ : CategoryTheory.Limits.Cocone F\nisColimit✝ : CategoryTheory.Limits.IsColimit cocone✝\ncocone : CategoryTheory.Limits.Cocone F\nisColimit : CategoryTheory.Limits.IsColimit cocone\n⊢ Eq (Eq { cocone := cocone✝, isColimit := isColimit✝ } { cocone := cocone, isColimit := isColimit }) (And (Eq cocone✝ cocone) (HEq isColimit✝ isColimit))","decl":"/-- `ColimitCocone F` contains a cocone over `F` together with the information that it is a\n    colimit. -/\nstructure ColimitCocone (F : J ⥤ C) where\n  /-- The cocone itself -/\n  cocone : Cocone F\n  /-- The proof that it is the colimit cocone -/\n  isColimit : IsColimit cocone\n\n"}
{"name":"CategoryTheory.Limits.ColimitCocone.mk.inj","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ncocone✝ : CategoryTheory.Limits.Cocone F\nisColimit✝ : CategoryTheory.Limits.IsColimit cocone✝\ncocone : CategoryTheory.Limits.Cocone F\nisColimit : CategoryTheory.Limits.IsColimit cocone\nx✝ : Eq { cocone := cocone✝, isColimit := isColimit✝ } { cocone := cocone, isColimit := isColimit }\n⊢ And (Eq cocone✝ cocone) (HEq isColimit✝ isColimit)","decl":"/-- `ColimitCocone F` contains a cocone over `F` together with the information that it is a\n    colimit. -/\nstructure ColimitCocone (F : J ⥤ C) where\n  /-- The cocone itself -/\n  cocone : Cocone F\n  /-- The proof that it is the colimit cocone -/\n  isColimit : IsColimit cocone\n\n"}
{"name":"CategoryTheory.Limits.ColimitCocone.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝¹ : SizeOf J\ninst✝ : SizeOf C\ncocone : CategoryTheory.Limits.Cocone F\nisColimit : CategoryTheory.Limits.IsColimit cocone\n⊢ Eq (SizeOf.sizeOf { cocone := cocone, isColimit := isColimit }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf cocone)) (SizeOf.sizeOf isColimit))","decl":"/-- `ColimitCocone F` contains a cocone over `F` together with the information that it is a\n    colimit. -/\nstructure ColimitCocone (F : J ⥤ C) where\n  /-- The cocone itself -/\n  cocone : Cocone F\n  /-- The proof that it is the colimit cocone -/\n  isColimit : IsColimit cocone\n\n"}
{"name":"CategoryTheory.Limits.HasColimit.exists_colimit","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\nself : CategoryTheory.Limits.HasColimit F\n⊢ Nonempty (CategoryTheory.Limits.ColimitCocone F)","decl":"/-- `HasColimit F` represents the mere existence of a colimit for `F`. -/\nclass HasColimit (F : J ⥤ C) : Prop where mk' ::\n  /-- There exists a colimit for `F` -/\n  exists_colimit : Nonempty (ColimitCocone F)\n\n"}
{"name":"CategoryTheory.Limits.HasColimit.mk","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\nd : CategoryTheory.Limits.ColimitCocone F\n⊢ CategoryTheory.Limits.HasColimit F","decl":"theorem HasColimit.mk {F : J ⥤ C} (d : ColimitCocone F) : HasColimit F :=\n  ⟨Nonempty.intro d⟩\n\n"}
{"name":"CategoryTheory.Limits.HasColimitsOfShape.has_colimit","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.Limits.HasColimitsOfShape J C\nF : CategoryTheory.Functor J C\n⊢ CategoryTheory.Limits.HasColimit F","decl":"/-- `C` has colimits of shape `J` if there exists a colimit for every functor `F : J ⥤ C`. -/\nclass HasColimitsOfShape : Prop where\n  /-- All `F : J ⥤ C` have colimits for a fixed `J` -/\n  has_colimit : ∀ F : J ⥤ C, HasColimit F := by infer_instance\n\n"}
{"name":"CategoryTheory.Limits.HasColimitsOfSize.has_colimits_of_shape","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.Limits.HasColimitsOfSize.{v₁, u₁, v, u} C\nJ : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} J\n⊢ CategoryTheory.Limits.HasColimitsOfShape J C","decl":"/-- `C` has all colimits of size `v₁ u₁` (`HasColimitsOfSize.{v₁ u₁} C`)\nif it has colimits of every shape `J : Type u₁` with `[Category.{v₁} J]`.\n-/\n@[pp_with_univ]\nclass HasColimitsOfSize (C : Type u) [Category.{v} C] : Prop where\n  /-- All `F : J ⥤ C` have colimits for all small `J` -/\n  has_colimits_of_shape : ∀ (J : Type u₁) [Category.{v₁} J], HasColimitsOfShape J C := by\n    infer_instance\n\n"}
{"name":"CategoryTheory.Limits.HasColimits.hasColimitsOfShape","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasColimits C\nJ : Type v\ninst✝ : CategoryTheory.Category.{v, v} J\n⊢ CategoryTheory.Limits.HasColimitsOfShape J C","decl":"theorem HasColimits.hasColimitsOfShape {C : Type u} [Category.{v} C] [HasColimits C] (J : Type v)\n    [Category.{v} J] : HasColimitsOfShape J C :=\n  HasColimitsOfSize.has_colimits_of_shape J\n\n"}
{"name":"CategoryTheory.Limits.hasColimitOfHasColimitsOfShape","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape J C\nF : CategoryTheory.Functor J C\n⊢ CategoryTheory.Limits.HasColimit F","decl":"instance (priority := 100) hasColimitOfHasColimitsOfShape {J : Type u₁} [Category.{v₁} J]\n    [HasColimitsOfShape J C] (F : J ⥤ C) : HasColimit F :=\n  HasColimitsOfShape.has_colimit F\n\n-- see Note [lower instance priority]\n"}
{"name":"CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\ninst✝ : CategoryTheory.Limits.HasColimitsOfSize.{v₁, u₁, v, u} C\n⊢ CategoryTheory.Limits.HasColimitsOfShape J C","decl":"instance (priority := 100) hasColimitsOfShapeOfHasColimitsOfSize {J : Type u₁} [Category.{v₁} J]\n    [HasColimitsOfSize.{v₁, u₁} C] : HasColimitsOfShape J C :=\n  HasColimitsOfSize.has_colimits_of_shape J\n\n-- Interface to the `HasColimit` class.\n"}
{"name":"CategoryTheory.Limits.colimit.eqToHom_comp_ι_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasColimit F\nj j' : J\nhj : Eq j j'\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.colimit F) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ⋯) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι F j) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι F j') h)","decl":"@[reassoc]\ntheorem colimit.eqToHom_comp_ι (F : J ⥤ C) [HasColimit F] {j j' : J} (hj : j = j') :\n    eqToHom (by subst hj; rfl) ≫ colimit.ι F j = colimit.ι F j'  := by\n  subst hj\n  simp\n\n"}
{"name":"CategoryTheory.Limits.colimit.eqToHom_comp_ι","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasColimit F\nj j' : J\nhj : Eq j j'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ⋯) (CategoryTheory.Limits.colimit.ι F j)) (CategoryTheory.Limits.colimit.ι F j')","decl":"@[reassoc]\ntheorem colimit.eqToHom_comp_ι (F : J ⥤ C) [HasColimit F] {j j' : J} (hj : j = j') :\n    eqToHom (by subst hj; rfl) ≫ colimit.ι F j = colimit.ι F j'  := by\n  subst hj\n  simp\n\n"}
{"name":"CategoryTheory.Limits.colimit.cocone_ι","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasColimit F\nj : J\n⊢ Eq ((CategoryTheory.Limits.colimit.cocone F).ι.app j) (CategoryTheory.Limits.colimit.ι F j)","decl":"@[simp]\ntheorem colimit.cocone_ι {F : J ⥤ C} [HasColimit F] (j : J) :\n    (colimit.cocone F).ι.app j = colimit.ι _ j :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.colimit.cocone_x","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasColimit F\n⊢ Eq (CategoryTheory.Limits.colimit.cocone F).pt (CategoryTheory.Limits.colimit F)","decl":"@[simp]\ntheorem colimit.cocone_x {F : J ⥤ C} [HasColimit F] : (colimit.cocone F).pt = colimit F :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.colimit.w","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasColimit F\nj j' : J\nf : Quiver.Hom j j'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map f) (CategoryTheory.Limits.colimit.ι F j')) (CategoryTheory.Limits.colimit.ι F j)","decl":"@[reassoc (attr := simp)]\ntheorem colimit.w (F : J ⥤ C) [HasColimit F] {j j' : J} (f : j ⟶ j') :\n    F.map f ≫ colimit.ι F j' = colimit.ι F j :=\n  (colimit.cocone F).w f\n\n"}
{"name":"CategoryTheory.Limits.colimit.w_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasColimit F\nj j' : J\nf : Quiver.Hom j j'\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.colimit F) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι F j') h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι F j) h)","decl":"@[reassoc (attr := simp)]\ntheorem colimit.w (F : J ⥤ C) [HasColimit F] {j j' : J} (f : j ⟶ j') :\n    F.map f ≫ colimit.ι F j' = colimit.ι F j :=\n  (colimit.cocone F).w f\n\n"}
{"name":"CategoryTheory.Limits.colimit.isColimit_desc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasColimit F\nc : CategoryTheory.Limits.Cocone F\n⊢ Eq ((CategoryTheory.Limits.colimit.isColimit F).desc c) (CategoryTheory.Limits.colimit.desc F c)","decl":"@[simp]\ntheorem colimit.isColimit_desc {F : J ⥤ C} [HasColimit F] (c : Cocone F) :\n    (colimit.isColimit F).desc c = colimit.desc F c :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.colimit.ι_desc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasColimit F\nc : CategoryTheory.Limits.Cocone F\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι F j) (CategoryTheory.Limits.colimit.desc F c)) (c.ι.app j)","decl":"/-- We have lots of lemmas describing how to simplify `colimit.ι F j ≫ _`,\nand combined with `colimit.ext` we rely on these lemmas for many calculations.\n\nHowever, since `Category.assoc` is a `@[simp]` lemma, often expressions are\nright associated, and it's hard to apply these lemmas about `colimit.ι`.\n\nWe thus use `reassoc` to define additional `@[simp]` lemmas, with an arbitrary extra morphism.\n(see `Tactic/reassoc_axiom.lean`)\n -/\n@[reassoc (attr := simp)]\ntheorem colimit.ι_desc {F : J ⥤ C} [HasColimit F] (c : Cocone F) (j : J) :\n    colimit.ι F j ≫ colimit.desc F c = c.ι.app j :=\n  IsColimit.fac _ c j\n\n"}
{"name":"CategoryTheory.Limits.colimit.ι_desc_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasColimit F\nc : CategoryTheory.Limits.Cocone F\nj : J\nZ : C\nh : Quiver.Hom c.pt Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι F j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.desc F c) h)) (CategoryTheory.CategoryStruct.comp (c.ι.app j) h)","decl":"/-- We have lots of lemmas describing how to simplify `colimit.ι F j ≫ _`,\nand combined with `colimit.ext` we rely on these lemmas for many calculations.\n\nHowever, since `Category.assoc` is a `@[simp]` lemma, often expressions are\nright associated, and it's hard to apply these lemmas about `colimit.ι`.\n\nWe thus use `reassoc` to define additional `@[simp]` lemmas, with an arbitrary extra morphism.\n(see `Tactic/reassoc_axiom.lean`)\n -/\n@[reassoc (attr := simp)]\ntheorem colimit.ι_desc {F : J ⥤ C} [HasColimit F] (c : Cocone F) (j : J) :\n    colimit.ι F j ≫ colimit.desc F c = c.ι.app j :=\n  IsColimit.fac _ c j\n\n"}
{"name":"CategoryTheory.Limits.ι_colimMap_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.HasColimit F\ninst✝ : CategoryTheory.Limits.HasColimit G\nα : Quiver.Hom F G\nj : J\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.colimit G) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι F j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimMap α) h)) (CategoryTheory.CategoryStruct.comp (α.app j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι G j) h))","decl":"@[reassoc (attr := simp)]\ntheorem ι_colimMap {F G : J ⥤ C} [HasColimit F] [HasColimit G] (α : F ⟶ G) (j : J) :\n    colimit.ι F j ≫ colimMap α = α.app j ≫ colimit.ι G j :=\n  colimit.ι_desc _ j\n\n"}
{"name":"CategoryTheory.Limits.ι_colimMap","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.HasColimit F\ninst✝ : CategoryTheory.Limits.HasColimit G\nα : Quiver.Hom F G\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι F j) (CategoryTheory.Limits.colimMap α)) (CategoryTheory.CategoryStruct.comp (α.app j) (CategoryTheory.Limits.colimit.ι G j))","decl":"@[reassoc (attr := simp)]\ntheorem ι_colimMap {F G : J ⥤ C} [HasColimit F] [HasColimit G] (α : F ⟶ G) (j : J) :\n    colimit.ι F j ≫ colimMap α = α.app j ≫ colimit.ι G j :=\n  colimit.ι_desc _ j\n\n"}
{"name":"CategoryTheory.Limits.colimit.coconeMorphism_hom","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasColimit F\nc : CategoryTheory.Limits.Cocone F\n⊢ Eq (CategoryTheory.Limits.colimit.coconeMorphism c).hom (CategoryTheory.Limits.colimit.desc F c)","decl":"@[simp]\ntheorem colimit.coconeMorphism_hom {F : J ⥤ C} [HasColimit F] (c : Cocone F) :\n    (colimit.coconeMorphism c).hom = colimit.desc F c :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.colimit.ι_coconeMorphism","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasColimit F\nc : CategoryTheory.Limits.Cocone F\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι F j) (CategoryTheory.Limits.colimit.coconeMorphism c).hom) (c.ι.app j)","decl":"theorem colimit.ι_coconeMorphism {F : J ⥤ C} [HasColimit F] (c : Cocone F) (j : J) :\n    colimit.ι F j ≫ (colimit.coconeMorphism c).hom = c.ι.app j := by simp\n\n"}
{"name":"CategoryTheory.Limits.colimit.comp_coconePointUniqueUpToIso_hom_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasColimit F\nc : CategoryTheory.Limits.Cocone F\nhc : CategoryTheory.Limits.IsColimit c\nj : J\nZ : C\nh : Quiver.Hom c.pt Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι F j) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Limits.colimit.isColimit F).coconePointUniqueUpToIso hc).hom h)) (CategoryTheory.CategoryStruct.comp (c.ι.app j) h)","decl":"@[reassoc (attr := simp)]\ntheorem colimit.comp_coconePointUniqueUpToIso_hom {F : J ⥤ C} [HasColimit F] {c : Cocone F}\n    (hc : IsColimit c) (j : J) :\n    colimit.ι F j ≫ (IsColimit.coconePointUniqueUpToIso (colimit.isColimit _) hc).hom = c.ι.app j :=\n  IsColimit.comp_coconePointUniqueUpToIso_hom _ _ _\n\n"}
{"name":"CategoryTheory.Limits.colimit.comp_coconePointUniqueUpToIso_hom","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasColimit F\nc : CategoryTheory.Limits.Cocone F\nhc : CategoryTheory.Limits.IsColimit c\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι F j) ((CategoryTheory.Limits.colimit.isColimit F).coconePointUniqueUpToIso hc).hom) (c.ι.app j)","decl":"@[reassoc (attr := simp)]\ntheorem colimit.comp_coconePointUniqueUpToIso_hom {F : J ⥤ C} [HasColimit F] {c : Cocone F}\n    (hc : IsColimit c) (j : J) :\n    colimit.ι F j ≫ (IsColimit.coconePointUniqueUpToIso (colimit.isColimit _) hc).hom = c.ι.app j :=\n  IsColimit.comp_coconePointUniqueUpToIso_hom _ _ _\n\n"}
{"name":"CategoryTheory.Limits.colimit.comp_coconePointUniqueUpToIso_inv","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasColimit F\nc : CategoryTheory.Limits.Cocone F\nhc : CategoryTheory.Limits.IsColimit c\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι F j) (hc.coconePointUniqueUpToIso (CategoryTheory.Limits.colimit.isColimit F)).inv) (c.ι.app j)","decl":"@[reassoc (attr := simp)]\ntheorem colimit.comp_coconePointUniqueUpToIso_inv {F : J ⥤ C} [HasColimit F] {c : Cocone F}\n    (hc : IsColimit c) (j : J) :\n    colimit.ι F j ≫ (IsColimit.coconePointUniqueUpToIso hc (colimit.isColimit _)).inv = c.ι.app j :=\n  IsColimit.comp_coconePointUniqueUpToIso_inv _ _ _\n\n"}
{"name":"CategoryTheory.Limits.colimit.comp_coconePointUniqueUpToIso_inv_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasColimit F\nc : CategoryTheory.Limits.Cocone F\nhc : CategoryTheory.Limits.IsColimit c\nj : J\nZ : C\nh : Quiver.Hom c.pt Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι F j) (CategoryTheory.CategoryStruct.comp (hc.coconePointUniqueUpToIso (CategoryTheory.Limits.colimit.isColimit F)).inv h)) (CategoryTheory.CategoryStruct.comp (c.ι.app j) h)","decl":"@[reassoc (attr := simp)]\ntheorem colimit.comp_coconePointUniqueUpToIso_inv {F : J ⥤ C} [HasColimit F] {c : Cocone F}\n    (hc : IsColimit c) (j : J) :\n    colimit.ι F j ≫ (IsColimit.coconePointUniqueUpToIso hc (colimit.isColimit _)).inv = c.ι.app j :=\n  IsColimit.comp_coconePointUniqueUpToIso_inv _ _ _\n\n"}
{"name":"CategoryTheory.Limits.colimit.existsUnique","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasColimit F\nt : CategoryTheory.Limits.Cocone F\n⊢ ExistsUnique fun d => ∀ (j : J), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι F j) d) (t.ι.app j)","decl":"theorem colimit.existsUnique {F : J ⥤ C} [HasColimit F] (t : Cocone F) :\n    ∃! d : colimit F ⟶ t.pt, ∀ j, colimit.ι F j ≫ d = t.ι.app j :=\n  (colimit.isColimit F).existsUnique _\n\n"}
{"name":"CategoryTheory.Limits.colimit.isoColimitCocone_ι_hom_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasColimit F\nt : CategoryTheory.Limits.ColimitCocone F\nj : J\nZ : C\nh : Quiver.Hom t.cocone.pt Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι F j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.isoColimitCocone t).hom h)) (CategoryTheory.CategoryStruct.comp (t.cocone.ι.app j) h)","decl":"@[reassoc (attr := simp)]\ntheorem colimit.isoColimitCocone_ι_hom {F : J ⥤ C} [HasColimit F] (t : ColimitCocone F) (j : J) :\n    colimit.ι F j ≫ (colimit.isoColimitCocone t).hom = t.cocone.ι.app j := by\n  dsimp [colimit.isoColimitCocone, IsColimit.coconePointUniqueUpToIso]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.colimit.isoColimitCocone_ι_hom","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasColimit F\nt : CategoryTheory.Limits.ColimitCocone F\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι F j) (CategoryTheory.Limits.colimit.isoColimitCocone t).hom) (t.cocone.ι.app j)","decl":"@[reassoc (attr := simp)]\ntheorem colimit.isoColimitCocone_ι_hom {F : J ⥤ C} [HasColimit F] (t : ColimitCocone F) (j : J) :\n    colimit.ι F j ≫ (colimit.isoColimitCocone t).hom = t.cocone.ι.app j := by\n  dsimp [colimit.isoColimitCocone, IsColimit.coconePointUniqueUpToIso]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.colimit.isoColimitCocone_ι_inv","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasColimit F\nt : CategoryTheory.Limits.ColimitCocone F\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (t.cocone.ι.app j) (CategoryTheory.Limits.colimit.isoColimitCocone t).inv) (CategoryTheory.Limits.colimit.ι F j)","decl":"@[reassoc (attr := simp)]\ntheorem colimit.isoColimitCocone_ι_inv {F : J ⥤ C} [HasColimit F] (t : ColimitCocone F) (j : J) :\n    t.cocone.ι.app j ≫ (colimit.isoColimitCocone t).inv = colimit.ι F j := by\n  dsimp [colimit.isoColimitCocone, IsColimit.coconePointUniqueUpToIso]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.colimit.isoColimitCocone_ι_inv_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasColimit F\nt : CategoryTheory.Limits.ColimitCocone F\nj : J\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.colimit F) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (t.cocone.ι.app j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.isoColimitCocone t).inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι F j) h)","decl":"@[reassoc (attr := simp)]\ntheorem colimit.isoColimitCocone_ι_inv {F : J ⥤ C} [HasColimit F] (t : ColimitCocone F) (j : J) :\n    t.cocone.ι.app j ≫ (colimit.isoColimitCocone t).inv = colimit.ι F j := by\n  dsimp [colimit.isoColimitCocone, IsColimit.coconePointUniqueUpToIso]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.colimit.hom_ext_iff","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasColimit F\nX : C\nf f' : Quiver.Hom (CategoryTheory.Limits.colimit F) X\n⊢ Iff (Eq f f') (∀ (j : J), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι F j) f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι F j) f'))","decl":"@[ext]\ntheorem colimit.hom_ext {F : J ⥤ C} [HasColimit F] {X : C} {f f' : colimit F ⟶ X}\n    (w : ∀ j, colimit.ι F j ≫ f = colimit.ι F j ≫ f') : f = f' :=\n  (colimit.isColimit F).hom_ext w\n\n"}
{"name":"CategoryTheory.Limits.colimit.hom_ext","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasColimit F\nX : C\nf f' : Quiver.Hom (CategoryTheory.Limits.colimit F) X\nw : ∀ (j : J), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι F j) f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι F j) f')\n⊢ Eq f f'","decl":"@[ext]\ntheorem colimit.hom_ext {F : J ⥤ C} [HasColimit F] {X : C} {f f' : colimit F ⟶ X}\n    (w : ∀ j, colimit.ι F j ≫ f = colimit.ι F j ≫ f') : f = f' :=\n  (colimit.isColimit F).hom_ext w\n\n"}
{"name":"CategoryTheory.Limits.colimit.desc_cocone","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasColimit F\n⊢ Eq (CategoryTheory.Limits.colimit.desc F (CategoryTheory.Limits.colimit.cocone F)) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.colimit F))","decl":"@[simp]\ntheorem colimit.desc_cocone {F : J ⥤ C} [HasColimit F] :\n    colimit.desc F (colimit.cocone F) = 𝟙 (colimit F) :=\n  (colimit.isColimit _).desc_self\n\n"}
{"name":"CategoryTheory.Limits.colimit.homIso_hom","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasColimit F\nW : C\nf : ULift.{u₁, v} (Quiver.Hom (CategoryTheory.Limits.colimit F) W)\n⊢ Eq ((CategoryTheory.Limits.colimit.homIso F W).hom f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.cocone F).ι ((CategoryTheory.Functor.const J).map f.down))","decl":"@[simp]\ntheorem colimit.homIso_hom (F : J ⥤ C) [HasColimit F] {W : C} (f : ULift (colimit F ⟶ W)) :\n    (colimit.homIso F W).hom f = (colimit.cocone F).ι ≫ (const J).map f.down :=\n  (colimit.isColimit F).homIso_hom f\n\n"}
{"name":"CategoryTheory.Limits.colimit.desc_extend","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasColimit F\nc : CategoryTheory.Limits.Cocone F\nX : C\nf : Quiver.Hom c.pt X\n⊢ Eq (CategoryTheory.Limits.colimit.desc F (c.extend f)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.desc F c) f)","decl":"theorem colimit.desc_extend (F : J ⥤ C) [HasColimit F] (c : Cocone F) {X : C} (f : c.pt ⟶ X) :\n    colimit.desc F (c.extend f) = colimit.desc F c ≫ f := by ext1; rw [← Category.assoc]; simp\n\n-- This has the isomorphism pointing in the opposite direction than in `has_limit_of_iso`.\n-- This is intentional; it seems to help with elaboration.\n"}
{"name":"CategoryTheory.Limits.hasColimitOfIso","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasColimit F\nα : CategoryTheory.Iso G F\n⊢ CategoryTheory.Limits.HasColimit G","decl":"/-- If `F` has a colimit, so does any naturally isomorphic functor.\n-/\ntheorem hasColimitOfIso {F G : J ⥤ C} [HasColimit F] (α : G ≅ F) : HasColimit G :=\n  HasColimit.mk\n    { cocone := (Cocones.precompose α.hom).obj (colimit.cocone F)\n      isColimit := (IsColimit.precomposeHomEquiv _ _).symm (colimit.isColimit F) }\n\n"}
{"name":"CategoryTheory.Limits.HasColimit.ofCoconesIso","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nK : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₂, u₁} K\nF : CategoryTheory.Functor J C\nG : CategoryTheory.Functor K C\nh : CategoryTheory.Iso F.cocones G.cocones\ninst✝ : CategoryTheory.Limits.HasColimit F\n⊢ CategoryTheory.Limits.HasColimit G","decl":"/-- If a functor `G` has the same collection of cocones as a functor `F`\nwhich has a colimit, then `G` also has a colimit. -/\ntheorem HasColimit.ofCoconesIso {K : Type u₁} [Category.{v₂} K] (F : J ⥤ C) (G : K ⥤ C)\n    (h : F.cocones ≅ G.cocones) [HasColimit F] : HasColimit G :=\n  HasColimit.mk ⟨_, IsColimit.ofNatIso (IsColimit.natIso (colimit.isColimit F) ≪≫ h)⟩\n\n"}
{"name":"CategoryTheory.Limits.HasColimit.isoOfNatIso_ι_hom_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.HasColimit F\ninst✝ : CategoryTheory.Limits.HasColimit G\nw : CategoryTheory.Iso F G\nj : J\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.colimit G) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι F j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.HasColimit.isoOfNatIso w).hom h)) (CategoryTheory.CategoryStruct.comp (w.hom.app j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι G j) h))","decl":"@[reassoc (attr := simp)]\ntheorem HasColimit.isoOfNatIso_ι_hom {F G : J ⥤ C} [HasColimit F] [HasColimit G] (w : F ≅ G)\n    (j : J) : colimit.ι F j ≫ (HasColimit.isoOfNatIso w).hom = w.hom.app j ≫ colimit.ι G j :=\n  IsColimit.comp_coconePointsIsoOfNatIso_hom _ _ _ _\n\n"}
{"name":"CategoryTheory.Limits.HasColimit.isoOfNatIso_ι_hom","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.HasColimit F\ninst✝ : CategoryTheory.Limits.HasColimit G\nw : CategoryTheory.Iso F G\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι F j) (CategoryTheory.Limits.HasColimit.isoOfNatIso w).hom) (CategoryTheory.CategoryStruct.comp (w.hom.app j) (CategoryTheory.Limits.colimit.ι G j))","decl":"@[reassoc (attr := simp)]\ntheorem HasColimit.isoOfNatIso_ι_hom {F G : J ⥤ C} [HasColimit F] [HasColimit G] (w : F ≅ G)\n    (j : J) : colimit.ι F j ≫ (HasColimit.isoOfNatIso w).hom = w.hom.app j ≫ colimit.ι G j :=\n  IsColimit.comp_coconePointsIsoOfNatIso_hom _ _ _ _\n\n"}
{"name":"CategoryTheory.Limits.HasColimit.isoOfNatIso_ι_inv_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.HasColimit F\ninst✝ : CategoryTheory.Limits.HasColimit G\nw : CategoryTheory.Iso F G\nj : J\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.colimit F) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι G j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.HasColimit.isoOfNatIso w).inv h)) (CategoryTheory.CategoryStruct.comp (w.inv.app j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι F j) h))","decl":"@[reassoc (attr := simp)]\ntheorem HasColimit.isoOfNatIso_ι_inv {F G : J ⥤ C} [HasColimit F] [HasColimit G] (w : F ≅ G)\n    (j : J) : colimit.ι G j ≫ (HasColimit.isoOfNatIso w).inv = w.inv.app j ≫ colimit.ι F j :=\n  IsColimit.comp_coconePointsIsoOfNatIso_inv _ _ _ _\n\n"}
{"name":"CategoryTheory.Limits.HasColimit.isoOfNatIso_ι_inv","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.HasColimit F\ninst✝ : CategoryTheory.Limits.HasColimit G\nw : CategoryTheory.Iso F G\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι G j) (CategoryTheory.Limits.HasColimit.isoOfNatIso w).inv) (CategoryTheory.CategoryStruct.comp (w.inv.app j) (CategoryTheory.Limits.colimit.ι F j))","decl":"@[reassoc (attr := simp)]\ntheorem HasColimit.isoOfNatIso_ι_inv {F G : J ⥤ C} [HasColimit F] [HasColimit G] (w : F ≅ G)\n    (j : J) : colimit.ι G j ≫ (HasColimit.isoOfNatIso w).inv = w.inv.app j ≫ colimit.ι F j :=\n  IsColimit.comp_coconePointsIsoOfNatIso_inv _ _ _ _\n\n"}
{"name":"CategoryTheory.Limits.HasColimit.isoOfNatIso_hom_desc_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.HasColimit F\ninst✝ : CategoryTheory.Limits.HasColimit G\nt : CategoryTheory.Limits.Cocone G\nw : CategoryTheory.Iso F G\nZ : C\nh : Quiver.Hom t.pt Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.HasColimit.isoOfNatIso w).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.desc G t) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.desc F ((CategoryTheory.Limits.Cocones.precompose w.hom).obj t)) h)","decl":"@[reassoc (attr := simp)]\ntheorem HasColimit.isoOfNatIso_hom_desc {F G : J ⥤ C} [HasColimit F] [HasColimit G] (t : Cocone G)\n    (w : F ≅ G) :\n    (HasColimit.isoOfNatIso w).hom ≫ colimit.desc G t =\n      colimit.desc F ((Cocones.precompose w.hom).obj _) :=\n  IsColimit.coconePointsIsoOfNatIso_hom_desc _ _ _\n\n"}
{"name":"CategoryTheory.Limits.HasColimit.isoOfNatIso_hom_desc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.HasColimit F\ninst✝ : CategoryTheory.Limits.HasColimit G\nt : CategoryTheory.Limits.Cocone G\nw : CategoryTheory.Iso F G\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.HasColimit.isoOfNatIso w).hom (CategoryTheory.Limits.colimit.desc G t)) (CategoryTheory.Limits.colimit.desc F ((CategoryTheory.Limits.Cocones.precompose w.hom).obj t))","decl":"@[reassoc (attr := simp)]\ntheorem HasColimit.isoOfNatIso_hom_desc {F G : J ⥤ C} [HasColimit F] [HasColimit G] (t : Cocone G)\n    (w : F ≅ G) :\n    (HasColimit.isoOfNatIso w).hom ≫ colimit.desc G t =\n      colimit.desc F ((Cocones.precompose w.hom).obj _) :=\n  IsColimit.coconePointsIsoOfNatIso_hom_desc _ _ _\n\n"}
{"name":"CategoryTheory.Limits.HasColimit.isoOfNatIso_inv_desc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.HasColimit F\ninst✝ : CategoryTheory.Limits.HasColimit G\nt : CategoryTheory.Limits.Cocone F\nw : CategoryTheory.Iso F G\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.HasColimit.isoOfNatIso w).inv (CategoryTheory.Limits.colimit.desc F t)) (CategoryTheory.Limits.colimit.desc G ((CategoryTheory.Limits.Cocones.precompose w.inv).obj t))","decl":"@[reassoc (attr := simp)]\ntheorem HasColimit.isoOfNatIso_inv_desc {F G : J ⥤ C} [HasColimit F] [HasColimit G] (t : Cocone F)\n    (w : F ≅ G) :\n    (HasColimit.isoOfNatIso w).inv ≫ colimit.desc F t =\n      colimit.desc G ((Cocones.precompose w.inv).obj _) :=\n  IsColimit.coconePointsIsoOfNatIso_inv_desc _ _ _\n\n"}
{"name":"CategoryTheory.Limits.HasColimit.isoOfNatIso_inv_desc_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.HasColimit F\ninst✝ : CategoryTheory.Limits.HasColimit G\nt : CategoryTheory.Limits.Cocone F\nw : CategoryTheory.Iso F G\nZ : C\nh : Quiver.Hom t.pt Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.HasColimit.isoOfNatIso w).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.desc F t) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.desc G ((CategoryTheory.Limits.Cocones.precompose w.inv).obj t)) h)","decl":"@[reassoc (attr := simp)]\ntheorem HasColimit.isoOfNatIso_inv_desc {F G : J ⥤ C} [HasColimit F] [HasColimit G] (t : Cocone F)\n    (w : F ≅ G) :\n    (HasColimit.isoOfNatIso w).inv ≫ colimit.desc F t =\n      colimit.desc G ((Cocones.precompose w.inv).obj _) :=\n  IsColimit.coconePointsIsoOfNatIso_inv_desc _ _ _\n\n"}
{"name":"CategoryTheory.Limits.HasColimit.isoOfEquivalence_hom_π","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} K\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.HasColimit F\nG : CategoryTheory.Functor K C\ninst✝ : CategoryTheory.Limits.HasColimit G\ne : CategoryTheory.Equivalence J K\nw : CategoryTheory.Iso (e.functor.comp G) F\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι F j) (CategoryTheory.Limits.HasColimit.isoOfEquivalence e w).hom) (CategoryTheory.CategoryStruct.comp (F.map (e.unit.app j)) (CategoryTheory.CategoryStruct.comp (w.inv.app ((e.functor.comp e.inverse).obj j)) (CategoryTheory.Limits.colimit.ι G (e.functor.obj ((e.functor.comp e.inverse).obj j)))))","decl":"@[simp]\ntheorem HasColimit.isoOfEquivalence_hom_π {F : J ⥤ C} [HasColimit F] {G : K ⥤ C} [HasColimit G]\n    (e : J ≌ K) (w : e.functor ⋙ G ≅ F) (j : J) :\n    colimit.ι F j ≫ (HasColimit.isoOfEquivalence e w).hom =\n      F.map (e.unit.app j) ≫ w.inv.app _ ≫ colimit.ι G _ := by\n  simp [HasColimit.isoOfEquivalence, IsColimit.coconePointsIsoOfEquivalence_inv]\n\n"}
{"name":"CategoryTheory.Limits.HasColimit.isoOfEquivalence_inv_π","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} K\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.HasColimit F\nG : CategoryTheory.Functor K C\ninst✝ : CategoryTheory.Limits.HasColimit G\ne : CategoryTheory.Equivalence J K\nw : CategoryTheory.Iso (e.functor.comp G) F\nk : K\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι G k) (CategoryTheory.Limits.HasColimit.isoOfEquivalence e w).inv) (CategoryTheory.CategoryStruct.comp (G.map (e.counitInv.app k)) (CategoryTheory.CategoryStruct.comp (w.hom.app (e.inverse.obj k)) (CategoryTheory.Limits.colimit.ι F (e.inverse.obj k))))","decl":"@[simp]\ntheorem HasColimit.isoOfEquivalence_inv_π {F : J ⥤ C} [HasColimit F] {G : K ⥤ C} [HasColimit G]\n    (e : J ≌ K) (w : e.functor ⋙ G ≅ F) (k : K) :\n    colimit.ι G k ≫ (HasColimit.isoOfEquivalence e w).inv =\n      G.map (e.counitInv.app k) ≫ w.hom.app (e.inverse.obj k) ≫ colimit.ι F (e.inverse.obj k) := by\n  simp [HasColimit.isoOfEquivalence, IsColimit.coconePointsIsoOfEquivalence_inv]\n\n"}
{"name":"CategoryTheory.Limits.colimit.ι_pre","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} K\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.HasColimit F\nE : CategoryTheory.Functor K J\ninst✝ : CategoryTheory.Limits.HasColimit (E.comp F)\nk : K\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι (E.comp F) k) (CategoryTheory.Limits.colimit.pre F E)) (CategoryTheory.Limits.colimit.ι F (E.obj k))","decl":"@[reassoc (attr := simp)]\ntheorem colimit.ι_pre (k : K) : colimit.ι (E ⋙ F) k ≫ colimit.pre F E = colimit.ι F (E.obj k) := by\n  erw [IsColimit.fac]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.colimit.ι_pre_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} K\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.HasColimit F\nE : CategoryTheory.Functor K J\ninst✝ : CategoryTheory.Limits.HasColimit (E.comp F)\nk : K\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.colimit F) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι (E.comp F) k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.pre F E) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι F (E.obj k)) h)","decl":"@[reassoc (attr := simp)]\ntheorem colimit.ι_pre (k : K) : colimit.ι (E ⋙ F) k ≫ colimit.pre F E = colimit.ι F (E.obj k) := by\n  erw [IsColimit.fac]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.colimit.ι_inv_pre","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} K\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝² : CategoryTheory.Limits.HasColimit F\nE : CategoryTheory.Functor K J\ninst✝¹ : CategoryTheory.Limits.HasColimit (E.comp F)\ninst✝ : CategoryTheory.IsIso (CategoryTheory.Limits.colimit.pre F E)\nk : K\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι F (E.obj k)) (CategoryTheory.inv (CategoryTheory.Limits.colimit.pre F E))) (CategoryTheory.Limits.colimit.ι (E.comp F) k)","decl":"@[reassoc (attr := simp)]\ntheorem colimit.ι_inv_pre [IsIso (pre F E)] (k : K) :\n    colimit.ι F (E.obj k) ≫ inv (colimit.pre F E) = colimit.ι (E ⋙ F) k := by\n  simp [IsIso.comp_inv_eq]\n\n"}
{"name":"CategoryTheory.Limits.colimit.ι_inv_pre_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} K\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝² : CategoryTheory.Limits.HasColimit F\nE : CategoryTheory.Functor K J\ninst✝¹ : CategoryTheory.Limits.HasColimit (E.comp F)\ninst✝ : CategoryTheory.IsIso (CategoryTheory.Limits.colimit.pre F E)\nk : K\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.colimit (E.comp F)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι F (E.obj k)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv (CategoryTheory.Limits.colimit.pre F E)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι (E.comp F) k) h)","decl":"@[reassoc (attr := simp)]\ntheorem colimit.ι_inv_pre [IsIso (pre F E)] (k : K) :\n    colimit.ι F (E.obj k) ≫ inv (colimit.pre F E) = colimit.ι (E ⋙ F) k := by\n  simp [IsIso.comp_inv_eq]\n\n"}
{"name":"CategoryTheory.Limits.colimit.pre_desc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} K\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.HasColimit F\nE : CategoryTheory.Functor K J\ninst✝ : CategoryTheory.Limits.HasColimit (E.comp F)\nc : CategoryTheory.Limits.Cocone F\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.pre F E) (CategoryTheory.Limits.colimit.desc F c)) (CategoryTheory.Limits.colimit.desc (E.comp F) (CategoryTheory.Limits.Cocone.whisker E c))","decl":"@[reassoc (attr := simp)]\ntheorem colimit.pre_desc (c : Cocone F) :\n    colimit.pre F E ≫ colimit.desc F c = colimit.desc (E ⋙ F) (c.whisker E) := by\n  ext; rw [← assoc, colimit.ι_pre]; simp\n\n"}
{"name":"CategoryTheory.Limits.colimit.pre_desc_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} K\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.HasColimit F\nE : CategoryTheory.Functor K J\ninst✝ : CategoryTheory.Limits.HasColimit (E.comp F)\nc : CategoryTheory.Limits.Cocone F\nZ : C\nh : Quiver.Hom c.pt Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.pre F E) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.desc F c) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.desc (E.comp F) (CategoryTheory.Limits.Cocone.whisker E c)) h)","decl":"@[reassoc (attr := simp)]\ntheorem colimit.pre_desc (c : Cocone F) :\n    colimit.pre F E ≫ colimit.desc F c = colimit.desc (E ⋙ F) (c.whisker E) := by\n  ext; rw [← assoc, colimit.ι_pre]; simp\n\n"}
{"name":"CategoryTheory.Limits.colimit.pre_pre","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} K\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝² : CategoryTheory.Limits.HasColimit F\nE : CategoryTheory.Functor K J\ninst✝¹ : CategoryTheory.Limits.HasColimit (E.comp F)\nL : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} L\nD : CategoryTheory.Functor L K\nh : CategoryTheory.Limits.HasColimit (D.comp (E.comp F))\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.pre (E.comp F) D) (CategoryTheory.Limits.colimit.pre F E)) (CategoryTheory.Limits.colimit.pre F (D.comp E))","decl":"@[simp]\ntheorem colimit.pre_pre [h : HasColimit (D ⋙ E ⋙ F)] :\n    haveI : HasColimit ((D ⋙ E) ⋙ F) := h\n    colimit.pre (E ⋙ F) D ≫ colimit.pre F E = colimit.pre F (D ⋙ E) := by\n  ext j\n  rw [← assoc, colimit.ι_pre, colimit.ι_pre]\n  haveI : HasColimit ((D ⋙ E) ⋙ F) := h\n  exact (colimit.ι_pre F (D ⋙ E) j).symm\n\n"}
{"name":"CategoryTheory.Limits.colimit.pre_eq","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} K\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.HasColimit F\nE : CategoryTheory.Functor K J\ninst✝ : CategoryTheory.Limits.HasColimit (E.comp F)\ns : CategoryTheory.Limits.ColimitCocone (E.comp F)\nt : CategoryTheory.Limits.ColimitCocone F\n⊢ Eq (CategoryTheory.Limits.colimit.pre F E) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.isoColimitCocone s).hom (CategoryTheory.CategoryStruct.comp (s.isColimit.desc (CategoryTheory.Limits.Cocone.whisker E t.cocone)) (CategoryTheory.Limits.colimit.isoColimitCocone t).inv))","decl":"/-- -\nIf we have particular colimit cocones available for `E ⋙ F` and for `F`,\nwe obtain a formula for `colimit.pre F E`.\n-/\ntheorem colimit.pre_eq (s : ColimitCocone (E ⋙ F)) (t : ColimitCocone F) :\n    colimit.pre F E =\n      (colimit.isoColimitCocone s).hom ≫\n        s.isColimit.desc (t.cocone.whisker E) ≫ (colimit.isoColimitCocone t).inv := by\n  aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.colimit.ι_post","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\nD : Type u'\ninst✝² : CategoryTheory.Category.{v', u'} D\ninst✝¹ : CategoryTheory.Limits.HasColimit F\nG : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.HasColimit (F.comp G)\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι (F.comp G) j) (CategoryTheory.Limits.colimit.post F G)) (G.map (CategoryTheory.Limits.colimit.ι F j))","decl":"@[reassoc (attr := simp)]\ntheorem colimit.ι_post (j : J) :\n    colimit.ι (F ⋙ G) j ≫ colimit.post F G = G.map (colimit.ι F j) := by\n  erw [IsColimit.fac]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.colimit.ι_post_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\nD : Type u'\ninst✝² : CategoryTheory.Category.{v', u'} D\ninst✝¹ : CategoryTheory.Limits.HasColimit F\nG : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.HasColimit (F.comp G)\nj : J\nZ : D\nh : Quiver.Hom (G.obj (CategoryTheory.Limits.colimit F)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι (F.comp G) j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.post F G) h)) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.colimit.ι F j)) h)","decl":"@[reassoc (attr := simp)]\ntheorem colimit.ι_post (j : J) :\n    colimit.ι (F ⋙ G) j ≫ colimit.post F G = G.map (colimit.ι F j) := by\n  erw [IsColimit.fac]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.colimit.post_desc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\nD : Type u'\ninst✝² : CategoryTheory.Category.{v', u'} D\ninst✝¹ : CategoryTheory.Limits.HasColimit F\nG : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.HasColimit (F.comp G)\nc : CategoryTheory.Limits.Cocone F\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.post F G) (G.map (CategoryTheory.Limits.colimit.desc F c))) (CategoryTheory.Limits.colimit.desc (F.comp G) (G.mapCocone c))","decl":"@[simp]\ntheorem colimit.post_desc (c : Cocone F) :\n    colimit.post F G ≫ G.map (colimit.desc F c) = colimit.desc (F ⋙ G) (G.mapCocone c) := by\n  ext\n  rw [← assoc, colimit.ι_post, ← G.map_comp, colimit.ι_desc, colimit.ι_desc]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.colimit.post_post","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\nD : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} D\ninst✝² : CategoryTheory.Limits.HasColimit F\nG : CategoryTheory.Functor C D\ninst✝¹ : CategoryTheory.Limits.HasColimit (F.comp G)\nE : Type u''\ninst✝ : CategoryTheory.Category.{v'', u''} E\nH : CategoryTheory.Functor D E\nh : CategoryTheory.Limits.HasColimit ((F.comp G).comp H)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.post (F.comp G) H) (H.map (CategoryTheory.Limits.colimit.post F G))) (CategoryTheory.Limits.colimit.post F (G.comp H))","decl":"@[simp]\ntheorem colimit.post_post {E : Type u''} [Category.{v''} E] (H : D ⥤ E)\n    -- H G (colimit F) ⟶ H (colimit (F ⋙ G)) ⟶ colimit ((F ⋙ G) ⋙ H) equals\n    -- H G (colimit F) ⟶ colimit (F ⋙ (G ⋙ H))\n    [h : HasColimit ((F ⋙ G) ⋙ H)] : haveI : HasColimit (F ⋙ G ⋙ H) := h\n    colimit.post (F ⋙ G) H ≫ H.map (colimit.post F G) = colimit.post F (G ⋙ H) := by\n  ext j\n  rw [← assoc, colimit.ι_post, ← H.map_comp, colimit.ι_post]\n  haveI : HasColimit (F ⋙ G ⋙ H) := h\n  exact (colimit.ι_post F (G ⋙ H) j).symm\n\n"}
{"name":"CategoryTheory.Limits.colimit.pre_post","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} K\nC : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} D\nE : CategoryTheory.Functor K J\nF : CategoryTheory.Functor J C\nG : CategoryTheory.Functor C D\ninst✝² : CategoryTheory.Limits.HasColimit F\ninst✝¹ : CategoryTheory.Limits.HasColimit (E.comp F)\ninst✝ : CategoryTheory.Limits.HasColimit (F.comp G)\nh : CategoryTheory.Limits.HasColimit ((E.comp F).comp G)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.post (E.comp F) G) (G.map (CategoryTheory.Limits.colimit.pre F E))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.pre (F.comp G) E) (CategoryTheory.Limits.colimit.post F G))","decl":"theorem colimit.pre_post {D : Type u'} [Category.{v'} D] (E : K ⥤ J) (F : J ⥤ C) (G : C ⥤ D)\n    [HasColimit F] [HasColimit (E ⋙ F)] [HasColimit (F ⋙ G)] [h : HasColimit ((E ⋙ F) ⋙ G)] :\n    -- G (colimit F) ⟶ G (colimit (E ⋙ F)) ⟶ colimit ((E ⋙ F) ⋙ G) vs\n    -- G (colimit F) ⟶ colimit F ⋙ G ⟶ colimit (E ⋙ (F ⋙ G)) or\n    haveI : HasColimit (E ⋙ F ⋙ G) := h\n    colimit.post (E ⋙ F) G ≫ G.map (colimit.pre F E) =\n      colimit.pre (F ⋙ G) E ≫ colimit.post F G := by\n  ext j\n  rw [← assoc, colimit.ι_post, ← G.map_comp, colimit.ι_pre, ← assoc]\n  haveI : HasColimit (E ⋙ F ⋙ G) := h\n  erw [colimit.ι_pre (F ⋙ G) E j, colimit.ι_post]\n\n"}
{"name":"CategoryTheory.Limits.hasColimit_equivalence_comp","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} K\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ne : CategoryTheory.Equivalence K J\ninst✝ : CategoryTheory.Limits.HasColimit F\n⊢ CategoryTheory.Limits.HasColimit (e.functor.comp F)","decl":"instance hasColimit_equivalence_comp (e : K ≌ J) [HasColimit F] : HasColimit (e.functor ⋙ F) :=\n  HasColimit.mk\n    { cocone := Cocone.whisker e.functor (colimit.cocone F)\n      isColimit := IsColimit.whiskerEquivalence (colimit.isColimit F) e }\n\n"}
{"name":"CategoryTheory.Limits.hasColimit_of_equivalence_comp","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} K\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ne : CategoryTheory.Equivalence K J\ninst✝ : CategoryTheory.Limits.HasColimit (e.functor.comp F)\n⊢ CategoryTheory.Limits.HasColimit F","decl":"/-- If a `E ⋙ F` has a colimit, and `E` is an equivalence, we can construct a colimit of `F`.\n-/\ntheorem hasColimit_of_equivalence_comp (e : K ≌ J) [HasColimit (e.functor ⋙ F)] : HasColimit F := by\n  haveI : HasColimit (e.inverse ⋙ e.functor ⋙ F) := Limits.hasColimit_equivalence_comp e.symm\n  apply hasColimitOfIso (e.invFunIdAssoc F).symm\n\n"}
{"name":"CategoryTheory.Limits.colim_map","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape J C\nX✝ Y✝ : CategoryTheory.Functor J C\nα : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.Limits.colim.map α) (CategoryTheory.Limits.colimMap α)","decl":"/-- `colimit F` is functorial in `F`, when `C` has all colimits of shape `J`. -/\n@[simps]\ndef colim : (J ⥤ C) ⥤ C where\n  obj F := colimit F\n  map α := colimMap α\n\n"}
{"name":"CategoryTheory.Limits.colim_obj","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape J C\nF : CategoryTheory.Functor J C\n⊢ Eq (CategoryTheory.Limits.colim.obj F) (CategoryTheory.Limits.colimit F)","decl":"/-- `colimit F` is functorial in `F`, when `C` has all colimits of shape `J`. -/\n@[simps]\ndef colim : (J ⥤ C) ⥤ C where\n  obj F := colimit F\n  map α := colimMap α\n\n"}
{"name":"CategoryTheory.Limits.colimMap_eq","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape J C\nG : CategoryTheory.Functor J C\nα : Quiver.Hom F G\n⊢ Eq (CategoryTheory.Limits.colimMap α) (CategoryTheory.Limits.colim.map α)","decl":"theorem colimMap_eq : colimMap α = colim.map α := rfl\n\n"}
{"name":"CategoryTheory.Limits.colimit.ι_map","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape J C\nG : CategoryTheory.Functor J C\nα : Quiver.Hom F G\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι F j) (CategoryTheory.Limits.colim.map α)) (CategoryTheory.CategoryStruct.comp (α.app j) (CategoryTheory.Limits.colimit.ι G j))","decl":"@[reassoc]\ntheorem colimit.ι_map (j : J) : colimit.ι F j ≫ colim.map α = α.app j ≫ colimit.ι G j := by simp\n\n"}
{"name":"CategoryTheory.Limits.colimit.ι_map_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape J C\nG : CategoryTheory.Functor J C\nα : Quiver.Hom F G\nj : J\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.colim.obj G) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι F j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colim.map α) h)) (CategoryTheory.CategoryStruct.comp (α.app j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι G j) h))","decl":"@[reassoc]\ntheorem colimit.ι_map (j : J) : colimit.ι F j ≫ colim.map α = α.app j ≫ colimit.ι G j := by simp\n\n"}
{"name":"CategoryTheory.Limits.colimit.map_desc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape J C\nG : CategoryTheory.Functor J C\nα : Quiver.Hom F G\nc : CategoryTheory.Limits.Cocone G\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimMap α) (CategoryTheory.Limits.colimit.desc G c)) (CategoryTheory.Limits.colimit.desc F ((CategoryTheory.Limits.Cocones.precompose α).obj c))","decl":"@[reassoc (attr := simp)]\ntheorem colimit.map_desc (c : Cocone G) :\n    colimMap α ≫ colimit.desc G c = colimit.desc F ((Cocones.precompose α).obj c) := by\n  ext j\n  simp [← assoc, colimit.ι_map, assoc, colimit.ι_desc, colimit.ι_desc]\n\n"}
{"name":"CategoryTheory.Limits.colimit.map_desc_assoc","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape J C\nG : CategoryTheory.Functor J C\nα : Quiver.Hom F G\nc : CategoryTheory.Limits.Cocone G\nZ : C\nh : Quiver.Hom c.pt Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimMap α) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.desc G c) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.desc F ((CategoryTheory.Limits.Cocones.precompose α).obj c)) h)","decl":"@[reassoc (attr := simp)]\ntheorem colimit.map_desc (c : Cocone G) :\n    colimMap α ≫ colimit.desc G c = colimit.desc F ((Cocones.precompose α).obj c) := by\n  ext j\n  simp [← assoc, colimit.ι_map, assoc, colimit.ι_desc, colimit.ι_desc]\n\n"}
{"name":"CategoryTheory.Limits.colimit.pre_map","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} K\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.HasColimitsOfShape J C\nG : CategoryTheory.Functor J C\nα : Quiver.Hom F G\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape K C\nE : CategoryTheory.Functor K J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.pre F E) (CategoryTheory.Limits.colim.map α)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colim.map (CategoryTheory.whiskerLeft E α)) (CategoryTheory.Limits.colimit.pre G E))","decl":"theorem colimit.pre_map [HasColimitsOfShape K C] (E : K ⥤ J) :\n    colimit.pre F E ≫ colim.map α = colim.map (whiskerLeft E α) ≫ colimit.pre G E := by\n  ext\n  rw [← assoc, colimit.ι_pre, colimit.ι_map, ← assoc, colimit.ι_map, assoc, colimit.ι_pre]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.colimit.pre_map'","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} K\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasColimitsOfShape J C\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape K C\nF : CategoryTheory.Functor J C\nE₁ E₂ : CategoryTheory.Functor K J\nα : Quiver.Hom E₁ E₂\n⊢ Eq (CategoryTheory.Limits.colimit.pre F E₁) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colim.map (CategoryTheory.whiskerRight α F)) (CategoryTheory.Limits.colimit.pre F E₂))","decl":"theorem colimit.pre_map' [HasColimitsOfShape K C] (F : J ⥤ C) {E₁ E₂ : K ⥤ J} (α : E₁ ⟶ E₂) :\n    colimit.pre F E₁ = colim.map (whiskerRight α F) ≫ colimit.pre F E₂ := by\n  ext1\n  simp [← assoc, assoc]\n\n"}
{"name":"CategoryTheory.Limits.colimit.pre_id","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape J C\nF : CategoryTheory.Functor J C\n⊢ Eq (CategoryTheory.Limits.colimit.pre F (CategoryTheory.Functor.id J)) (CategoryTheory.Limits.colim.map F.leftUnitor.hom)","decl":"theorem colimit.pre_id (F : J ⥤ C) :\n    colimit.pre F (𝟭 _) = colim.map (Functor.leftUnitor F).hom := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.colimit.map_post","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝² : CategoryTheory.Limits.HasColimitsOfShape J C\nG : CategoryTheory.Functor J C\nα : Quiver.Hom F G\nD : Type u'\ninst✝¹ : CategoryTheory.Category.{v', u'} D\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape J D\nH : CategoryTheory.Functor C D\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.post F H) (H.map (CategoryTheory.Limits.colim.map α))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colim.map (CategoryTheory.whiskerRight α H)) (CategoryTheory.Limits.colimit.post G H))","decl":"theorem colimit.map_post {D : Type u'} [Category.{v'} D] [HasColimitsOfShape J D]\n    (H : C ⥤ D) :/- H (colimit F) ⟶ H (colimit G) ⟶ colimit (G ⋙ H) vs\n             H (colimit F) ⟶ colimit (F ⋙ H) ⟶ colimit (G ⋙ H) -/\n          colimit.post\n          F H ≫\n        H.map (colim.map α) =\n      colim.map (whiskerRight α H) ≫ colimit.post G H := by\n  ext\n  rw [← assoc, colimit.ι_post, ← H.map_comp, colimit.ι_map, H.map_comp]\n  rw [← assoc, colimit.ι_map, assoc, colimit.ι_post]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.instIsLeftAdjointFunctorColim","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape J C\n⊢ CategoryTheory.Limits.colim.IsLeftAdjoint","decl":"instance : IsLeftAdjoint (colim : (J ⥤ C) ⥤ C) :=\n  ⟨_, ⟨colimConstAdj⟩⟩\n\n"}
{"name":"CategoryTheory.Limits.colimMap_epi'","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.HasColimitsOfShape J C\nα : Quiver.Hom F G\ninst✝ : CategoryTheory.Epi α\n⊢ CategoryTheory.Epi (CategoryTheory.Limits.colimMap α)","decl":"instance colimMap_epi' {F G : J ⥤ C} [HasColimitsOfShape J C] (α : F ⟶ G) [Epi α] :\n    Epi (colimMap α) :=\n  (colim : (J ⥤ C) ⥤ C).map_epi α\n\n"}
{"name":"CategoryTheory.Limits.colimMap_epi","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor J C\ninst✝² : CategoryTheory.Limits.HasColimit F\ninst✝¹ : CategoryTheory.Limits.HasColimit G\nα : Quiver.Hom F G\ninst✝ : ∀ (j : J), CategoryTheory.Epi (α.app j)\n⊢ CategoryTheory.Epi (CategoryTheory.Limits.colimMap α)","decl":"instance colimMap_epi {F G : J ⥤ C} [HasColimit F] [HasColimit G] (α : F ⟶ G) [∀ j, Epi (α.app j)] :\n    Epi (colimMap α) :=\n  ⟨fun {Z} u v h =>\n    colimit.hom_ext fun j => (cancel_epi (α.app j)).1 <| by simpa using colimit.ι _ j ≫= h⟩\n\n"}
{"name":"CategoryTheory.Limits.hasColimitsOfShape_of_equivalence","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"J : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ' : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} J'\ne : CategoryTheory.Equivalence J J'\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape J C\n⊢ CategoryTheory.Limits.HasColimitsOfShape J' C","decl":"/-- We can transport colimits of shape `J` along an equivalence `J ≌ J'`.\n-/\ntheorem hasColimitsOfShape_of_equivalence {J' : Type u₂} [Category.{v₂} J'] (e : J ≌ J')\n    [HasColimitsOfShape J C] : HasColimitsOfShape J' C := by\n  constructor\n  intro F\n  apply hasColimit_of_equivalence_comp e\n\n"}
{"name":"CategoryTheory.Limits.hasColimitsOfSizeOfUnivLE","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : UnivLE.{v₂, v₁}\ninst✝¹ : UnivLE.{u₂, u₁}\ninst✝ : CategoryTheory.Limits.HasColimitsOfSize.{v₁, u₁, v, u} C\n⊢ CategoryTheory.Limits.HasColimitsOfSize.{v₂, u₂, v, u} C","decl":"/-- A category that has larger colimits also has smaller colimits. -/\ntheorem hasColimitsOfSizeOfUnivLE [UnivLE.{v₂, v₁}] [UnivLE.{u₂, u₁}]\n    [HasColimitsOfSize.{v₁, u₁} C] : HasColimitsOfSize.{v₂, u₂} C where\n  has_colimits_of_shape J {_} := hasColimitsOfShape_of_equivalence\n    ((ShrinkHoms.equivalence J).trans <| Shrink.equivalence _).symm\n\n"}
{"name":"CategoryTheory.Limits.hasColimitsOfSizeShrink","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasColimitsOfSize.{max v₁ v₂, max u₁ u₂, v, u} C\n⊢ CategoryTheory.Limits.HasColimitsOfSize.{v₁, u₁, v, u} C","decl":"/-- `hasColimitsOfSizeShrink.{v u} C` tries to obtain `HasColimitsOfSize.{v u} C`\nfrom some other `HasColimitsOfSize C`.\n-/\ntheorem hasColimitsOfSizeShrink [HasColimitsOfSize.{max v₁ v₂, max u₁ u₂} C] :\n    HasColimitsOfSize.{v₁, u₁} C := hasColimitsOfSizeOfUnivLE.{max v₁ v₂, max u₁ u₂} C\n\n"}
{"name":"CategoryTheory.Limits.hasSmallestColimitsOfHasColimits","module":"Mathlib.CategoryTheory.Limits.HasLimits","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasColimits C\n⊢ CategoryTheory.Limits.HasColimitsOfSize.{0, 0, v, u} C","decl":"instance (priority := 100) hasSmallestColimitsOfHasColimits [HasColimits C] :\n    HasColimitsOfSize.{0, 0} C :=\n  hasColimitsOfSizeShrink.{0, 0} C\n\n"}
