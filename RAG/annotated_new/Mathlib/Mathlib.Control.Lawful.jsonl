{"name":"StateT.run_mk","module":"Mathlib.Control.Lawful","initialProofState":"σ : Type u\nm : Type u → Type v\nα : Type u\nf : σ → m (Prod α σ)\nst : σ\n⊢ Eq ((StateT.mk f).run st) (f st)","decl":"@[simp]\ntheorem run_mk (f : σ → m (α × σ)) (st : σ) : StateT.run (StateT.mk f) st = f st :=\n  rfl\n\n-- Porting note: `StateT.adapt` is removed.\n\n"}
{"name":"ExceptT.run_monadLift","module":"Mathlib.Control.Lawful","initialProofState":"α ε : Type u\nm : Type u → Type v\nn : Type u → Type u_1\ninst✝¹ : Monad m\ninst✝ : MonadLiftT n m\nx : n α\n⊢ Eq (MonadLiftT.monadLift x).run (Functor.map Except.ok (MonadLiftT.monadLift x))","decl":"@[simp]\ntheorem run_monadLift {n} [Monad m] [MonadLiftT n m] (x : n α) :\n    (monadLift x : ExceptT ε m α).run = Except.ok <$> (monadLift x : m α) :=\n  rfl\n\n"}
{"name":"ExceptT.run_monadMap","module":"Mathlib.Control.Lawful","initialProofState":"α ε : Type u\nm : Type u → Type v\nx : ExceptT ε m α\nn : Type u → Type u_1\ninst✝ : MonadFunctorT n m\nf : {α : Type u} → n α → n α\n⊢ Eq (MonadFunctorT.monadMap f x).run (MonadFunctorT.monadMap f x.run)","decl":"@[simp]\ntheorem run_monadMap {n} [MonadFunctorT n m] (f : ∀ {α}, n α → n α) :\n    (monadMap (@f) x : ExceptT ε m α).run = monadMap (@f) x.run :=\n  rfl\n\n"}
{"name":"ReaderT.run_mk","module":"Mathlib.Control.Lawful","initialProofState":"m : Type u → Type v\nα σ : Type u\nf : σ → m α\nr : σ\n⊢ Eq ((ReaderT.mk f).run r) (f r)","decl":"@[simp]\ntheorem run_mk (f : σ → m α) (r : σ) : ReaderT.run (ReaderT.mk f) r = f r :=\n  rfl\n\n"}
{"name":"OptionT.ext","module":"Mathlib.Control.Lawful","initialProofState":"α : Type u\nm : Type u → Type v\nx x' : OptionT m α\nh : Eq x.run x'.run\n⊢ Eq x x'","decl":"@[ext] theorem ext {x x' : OptionT m α} (h : x.run = x'.run) : x = x' :=\n  h\n\n-- Porting note: This is proven by proj reduction in Lean 3.\n"}
{"name":"OptionT.ext_iff","module":"Mathlib.Control.Lawful","initialProofState":"α : Type u\nm : Type u → Type v\nx x' : OptionT m α\n⊢ Iff (Eq x x') (Eq x.run x'.run)","decl":"@[ext] theorem ext {x x' : OptionT m α} (h : x.run = x'.run) : x = x' :=\n  h\n\n-- Porting note: This is proven by proj reduction in Lean 3.\n"}
{"name":"OptionT.run_mk","module":"Mathlib.Control.Lawful","initialProofState":"α : Type u\nm : Type u → Type v\nx : m (Option α)\n⊢ Eq (OptionT.mk x).run x","decl":"@[simp]\ntheorem run_mk (x : m (Option α)) : OptionT.run (OptionT.mk x) = x :=\n  rfl\n\n"}
{"name":"OptionT.run_pure","module":"Mathlib.Control.Lawful","initialProofState":"α : Type u\nm : Type u → Type v\ninst✝ : Monad m\na : α\n⊢ Eq (Pure.pure a).run (Pure.pure (Option.some a))","decl":"@[simp]\ntheorem run_pure (a) : (pure a : OptionT m α).run = pure (some a) :=\n  rfl\n\n"}
{"name":"OptionT.run_bind","module":"Mathlib.Control.Lawful","initialProofState":"α β : Type u\nm : Type u → Type v\nx : OptionT m α\ninst✝ : Monad m\nf : α → OptionT m β\n⊢ Eq (Bind.bind x f).run (Bind.bind x.run fun x => OptionT.run_bind.match_1 (fun x => m (Option β)) x (fun a => (f a).run) fun _ => Pure.pure Option.none)","decl":"@[simp]\ntheorem run_bind (f : α → OptionT m β) :\n    (x >>= f).run = x.run >>= fun\n                              | some a => OptionT.run (f a)\n                              | none   => pure none :=\n  rfl\n\n"}
{"name":"OptionT.run_map","module":"Mathlib.Control.Lawful","initialProofState":"α β : Type u\nm : Type u → Type v\nx : OptionT m α\ninst✝¹ : Monad m\nf : α → β\ninst✝ : LawfulMonad m\n⊢ Eq (Functor.map f x).run (Functor.map (Option.map f) x.run)","decl":"@[simp]\ntheorem run_map (f : α → β) [LawfulMonad m] : (f <$> x).run = Option.map f <$> x.run := by\n  rw [← bind_pure_comp _ x.run]\n  change x.run >>= (fun\n                     | some a => OptionT.run (pure (f a))\n                     | none   => pure none) = _\n  apply bind_congr\n  intro a; cases a <;> simp [Option.map, Option.bind]\n\n"}
{"name":"OptionT.run_monadLift","module":"Mathlib.Control.Lawful","initialProofState":"α : Type u\nm : Type u → Type v\ninst✝¹ : Monad m\nn : Type u → Type u_1\ninst✝ : MonadLiftT n m\nx : n α\n⊢ Eq (MonadLiftT.monadLift x).run (Bind.bind (MonadLiftT.monadLift x) fun a => Pure.pure (Option.some a))","decl":"@[simp]\ntheorem run_monadLift {n} [MonadLiftT n m] (x : n α) :\n    (monadLift x : OptionT m α).run = (monadLift x : m α) >>= fun a => pure (some a) :=\n  rfl\n\n"}
{"name":"OptionT.run_monadMap","module":"Mathlib.Control.Lawful","initialProofState":"α : Type u\nm : Type u → Type v\nx : OptionT m α\nn : Type u → Type u_1\ninst✝ : MonadFunctorT n m\nf : {α : Type u} → n α → n α\n⊢ Eq (MonadFunctorT.monadMap f x).run (MonadFunctorT.monadMap f x.run)","decl":"@[simp]\ntheorem run_monadMap {n} [MonadFunctorT n m] (f : ∀ {α}, n α → n α) :\n    (monadMap (@f) x : OptionT m α).run = monadMap (@f) x.run :=\n  rfl\n\n"}
{"name":"instLawfulMonadOptionT","module":"Mathlib.Control.Lawful","initialProofState":"m : Type u → Type v\ninst✝¹ : Monad m\ninst✝ : LawfulMonad m\n⊢ LawfulMonad (OptionT m)","decl":"instance (m : Type u → Type v) [Monad m] [LawfulMonad m] : LawfulMonad (OptionT m) :=\n  LawfulMonad.mk'\n    (id_map := by\n      intros; apply OptionT.ext; simp only [OptionT.run_map]\n      rw [map_congr, id_map]\n      intro a; cases a <;> rfl)\n    (bind_assoc := by\n      intros; apply OptionT.ext; simp only [OptionT.run_bind, bind_assoc]\n      rw [bind_congr]\n      intro a; cases a <;> simp)\n    (pure_bind := by intros; apply OptionT.ext; simp)\n"}
