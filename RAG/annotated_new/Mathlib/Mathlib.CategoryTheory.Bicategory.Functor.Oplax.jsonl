{"name":"CategoryTheory.OplaxFunctor.mk.injEq","module":"Mathlib.CategoryTheory.Bicategory.Functor.Oplax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\ntoPrelaxFunctor‚úù : CategoryTheory.PrelaxFunctor B C\nmapId‚úù : (a : B) ‚Üí Quiver.Hom (toPrelaxFunctor‚úù.map (CategoryTheory.CategoryStruct.id a)) (CategoryTheory.CategoryStruct.id (toPrelaxFunctor‚úù.obj a))\nmapComp‚úù : {a b c : B} ‚Üí (f : Quiver.Hom a b) ‚Üí (g : Quiver.Hom b c) ‚Üí Quiver.Hom (toPrelaxFunctor‚úù.map (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (toPrelaxFunctor‚úù.map f) (toPrelaxFunctor‚úù.map g))\nmapComp_naturality_left‚úù : autoParam (‚àÄ {a b c : B} {f f' : Quiver.Hom a b} (Œ∑ : Quiver.Hom f f') (g : Quiver.Hom b c), Eq (CategoryTheory.CategoryStruct.comp (toPrelaxFunctor‚úù.map‚ÇÇ (CategoryTheory.Bicategory.whiskerRight Œ∑ g)) (mapComp‚úù f' g)) (CategoryTheory.CategoryStruct.comp (mapComp‚úù f g) (CategoryTheory.Bicategory.whiskerRight (toPrelaxFunctor‚úù.map‚ÇÇ Œ∑) (toPrelaxFunctor‚úù.map g)))) _auto‚úù\nmapComp_naturality_right‚úù : autoParam (‚àÄ {a b c : B} (f : Quiver.Hom a b) {g g' : Quiver.Hom b c} (Œ∑ : Quiver.Hom g g'), Eq (CategoryTheory.CategoryStruct.comp (toPrelaxFunctor‚úù.map‚ÇÇ (CategoryTheory.Bicategory.whiskerLeft f Œ∑)) (mapComp‚úù f g')) (CategoryTheory.CategoryStruct.comp (mapComp‚úù f g) (CategoryTheory.Bicategory.whiskerLeft (toPrelaxFunctor‚úù.map f) (toPrelaxFunctor‚úù.map‚ÇÇ Œ∑)))) _auto‚úù\nmap‚ÇÇ_associator‚úù : autoParam (‚àÄ {a b c d : B} (f : Quiver.Hom a b) (g : Quiver.Hom b c) (h : Quiver.Hom c d), Eq (CategoryTheory.CategoryStruct.comp (toPrelaxFunctor‚úù.map‚ÇÇ (CategoryTheory.Bicategory.associator f g h).hom) (CategoryTheory.CategoryStruct.comp (mapComp‚úù f (CategoryTheory.CategoryStruct.comp g h)) (CategoryTheory.Bicategory.whiskerLeft (toPrelaxFunctor‚úù.map f) (mapComp‚úù g h)))) (CategoryTheory.CategoryStruct.comp (mapComp‚úù (CategoryTheory.CategoryStruct.comp f g) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapComp‚úù f g) (toPrelaxFunctor‚úù.map h)) (CategoryTheory.Bicategory.associator (toPrelaxFunctor‚úù.map f) (toPrelaxFunctor‚úù.map g) (toPrelaxFunctor‚úù.map h)).hom))) _auto‚úù\nmap‚ÇÇ_leftUnitor‚úù : autoParam (‚àÄ {a b : B} (f : Quiver.Hom a b), Eq (toPrelaxFunctor‚úù.map‚ÇÇ (CategoryTheory.Bicategory.leftUnitor f).hom) (CategoryTheory.CategoryStruct.comp (mapComp‚úù (CategoryTheory.CategoryStruct.id a) f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapId‚úù a) (toPrelaxFunctor‚úù.map f)) (CategoryTheory.Bicategory.leftUnitor (toPrelaxFunctor‚úù.map f)).hom))) _auto‚úù\nmap‚ÇÇ_rightUnitor‚úù : autoParam (‚àÄ {a b : B} (f : Quiver.Hom a b), Eq (toPrelaxFunctor‚úù.map‚ÇÇ (CategoryTheory.Bicategory.rightUnitor f).hom) (CategoryTheory.CategoryStruct.comp (mapComp‚úù f (CategoryTheory.CategoryStruct.id b)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (toPrelaxFunctor‚úù.map f) (mapId‚úù b)) (CategoryTheory.Bicategory.rightUnitor (toPrelaxFunctor‚úù.map f)).hom))) _auto‚úù\ntoPrelaxFunctor : CategoryTheory.PrelaxFunctor B C\nmapId : (a : B) ‚Üí Quiver.Hom (toPrelaxFunctor.map (CategoryTheory.CategoryStruct.id a)) (CategoryTheory.CategoryStruct.id (toPrelaxFunctor.obj a))\nmapComp : {a b c : B} ‚Üí (f : Quiver.Hom a b) ‚Üí (g : Quiver.Hom b c) ‚Üí Quiver.Hom (toPrelaxFunctor.map (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (toPrelaxFunctor.map f) (toPrelaxFunctor.map g))\nmapComp_naturality_left : autoParam (‚àÄ {a b c : B} {f f' : Quiver.Hom a b} (Œ∑ : Quiver.Hom f f') (g : Quiver.Hom b c), Eq (CategoryTheory.CategoryStruct.comp (toPrelaxFunctor.map‚ÇÇ (CategoryTheory.Bicategory.whiskerRight Œ∑ g)) (mapComp f' g)) (CategoryTheory.CategoryStruct.comp (mapComp f g) (CategoryTheory.Bicategory.whiskerRight (toPrelaxFunctor.map‚ÇÇ Œ∑) (toPrelaxFunctor.map g)))) _auto‚úù\nmapComp_naturality_right : autoParam (‚àÄ {a b c : B} (f : Quiver.Hom a b) {g g' : Quiver.Hom b c} (Œ∑ : Quiver.Hom g g'), Eq (CategoryTheory.CategoryStruct.comp (toPrelaxFunctor.map‚ÇÇ (CategoryTheory.Bicategory.whiskerLeft f Œ∑)) (mapComp f g')) (CategoryTheory.CategoryStruct.comp (mapComp f g) (CategoryTheory.Bicategory.whiskerLeft (toPrelaxFunctor.map f) (toPrelaxFunctor.map‚ÇÇ Œ∑)))) _auto‚úù\nmap‚ÇÇ_associator : autoParam (‚àÄ {a b c d : B} (f : Quiver.Hom a b) (g : Quiver.Hom b c) (h : Quiver.Hom c d), Eq (CategoryTheory.CategoryStruct.comp (toPrelaxFunctor.map‚ÇÇ (CategoryTheory.Bicategory.associator f g h).hom) (CategoryTheory.CategoryStruct.comp (mapComp f (CategoryTheory.CategoryStruct.comp g h)) (CategoryTheory.Bicategory.whiskerLeft (toPrelaxFunctor.map f) (mapComp g h)))) (CategoryTheory.CategoryStruct.comp (mapComp (CategoryTheory.CategoryStruct.comp f g) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapComp f g) (toPrelaxFunctor.map h)) (CategoryTheory.Bicategory.associator (toPrelaxFunctor.map f) (toPrelaxFunctor.map g) (toPrelaxFunctor.map h)).hom))) _auto‚úù\nmap‚ÇÇ_leftUnitor : autoParam (‚àÄ {a b : B} (f : Quiver.Hom a b), Eq (toPrelaxFunctor.map‚ÇÇ (CategoryTheory.Bicategory.leftUnitor f).hom) (CategoryTheory.CategoryStruct.comp (mapComp (CategoryTheory.CategoryStruct.id a) f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapId a) (toPrelaxFunctor.map f)) (CategoryTheory.Bicategory.leftUnitor (toPrelaxFunctor.map f)).hom))) _auto‚úù\nmap‚ÇÇ_rightUnitor : autoParam (‚àÄ {a b : B} (f : Quiver.Hom a b), Eq (toPrelaxFunctor.map‚ÇÇ (CategoryTheory.Bicategory.rightUnitor f).hom) (CategoryTheory.CategoryStruct.comp (mapComp f (CategoryTheory.CategoryStruct.id b)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (toPrelaxFunctor.map f) (mapId b)) (CategoryTheory.Bicategory.rightUnitor (toPrelaxFunctor.map f)).hom))) _auto‚úù\n‚ä¢ Eq (Eq { toPrelaxFunctor := toPrelaxFunctor‚úù, mapId := mapId‚úù, mapComp := mapComp‚úù, mapComp_naturality_left := mapComp_naturality_left‚úù, mapComp_naturality_right := mapComp_naturality_right‚úù, map‚ÇÇ_associator := map‚ÇÇ_associator‚úù, map‚ÇÇ_leftUnitor := map‚ÇÇ_leftUnitor‚úù, map‚ÇÇ_rightUnitor := map‚ÇÇ_rightUnitor‚úù } { toPrelaxFunctor := toPrelaxFunctor, mapId := mapId, mapComp := mapComp, mapComp_naturality_left := mapComp_naturality_left, mapComp_naturality_right := mapComp_naturality_right, map‚ÇÇ_associator := map‚ÇÇ_associator, map‚ÇÇ_leftUnitor := map‚ÇÇ_leftUnitor, map‚ÇÇ_rightUnitor := map‚ÇÇ_rightUnitor }) (And (Eq toPrelaxFunctor‚úù toPrelaxFunctor) (And (HEq mapId‚úù mapId) (HEq mapComp‚úù mapComp)))","decl":"/-- An oplax functor `F` between bicategories `B` and `C` consists of a function between objects\n`F.obj`, a function between 1-morphisms `F.map`, and a function between 2-morphisms `F.map‚ÇÇ`.\n\nUnlike functors between categories, `F.map` do not need to strictly commute with the composition,\nand do not need to strictly preserve the identity. Instead, there are specified 2-morphisms\n`F.map (ùüô a) ‚ü∂ ùüô (F.obj a)` and `F.map (f ‚â´ g) ‚ü∂ F.map f ‚â´ F.map g`.\n\n`F.map‚ÇÇ` strictly commute with compositions and preserve the identity. They also preserve the\nassociator, the left unitor, and the right unitor modulo some adjustments of domains and codomains\nof 2-morphisms.\n-/\nstructure OplaxFunctor (B : Type u‚ÇÅ) [Bicategory.{w‚ÇÅ, v‚ÇÅ} B] (C : Type u‚ÇÇ)\n  [Bicategory.{w‚ÇÇ, v‚ÇÇ} C] extends PrelaxFunctor B C where\n  /-- The 2-morphism underlying the oplax unity constraint. -/\n  mapId (a : B) : map (ùüô a) ‚ü∂ ùüô (obj a)\n  /-- The 2-morphism underlying the oplax functoriality constraint. -/\n  mapComp {a b c : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) : map (f ‚â´ g) ‚ü∂ map f ‚â´ map g\n  /-- Naturality of the oplax functoriality constraint, on the left. -/\n  mapComp_naturality_left :\n    ‚àÄ {a b c : B} {f f' : a ‚ü∂ b} (Œ∑ : f ‚ü∂ f') (g : b ‚ü∂ c),\n      map‚ÇÇ (Œ∑ ‚ñ∑ g) ‚â´ mapComp f' g = mapComp f g ‚â´ map‚ÇÇ Œ∑ ‚ñ∑ map g := by\n    aesop_cat\n  /-- Naturality of the lax functoriality constraight, on the right. -/\n  mapComp_naturality_right :\n    ‚àÄ {a b c : B} (f : a ‚ü∂ b) {g g' : b ‚ü∂ c} (Œ∑ : g ‚ü∂ g'),\n      map‚ÇÇ (f ‚óÅ Œ∑) ‚â´ mapComp f g' = mapComp f g ‚â´ map f ‚óÅ map‚ÇÇ Œ∑ := by\n    aesop_cat\n  /-- Oplax associativity. -/\n  map‚ÇÇ_associator :\n    ‚àÄ {a b c d : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d),\n      map‚ÇÇ (Œ±_ f g h).hom ‚â´ mapComp f (g ‚â´ h) ‚â´ map f ‚óÅ mapComp g h =\n    mapComp (f ‚â´ g) h ‚â´ mapComp f g ‚ñ∑ map h ‚â´ (Œ±_ (map f) (map g) (map h)).hom := by\n    aesop_cat\n  /-- Oplax left unity. -/\n  map‚ÇÇ_leftUnitor :\n    ‚àÄ {a b : B} (f : a ‚ü∂ b),\n      map‚ÇÇ (Œª_ f).hom = mapComp (ùüô a) f ‚â´ mapId a ‚ñ∑ map f ‚â´ (Œª_ (map f)).hom := by\n    aesop_cat\n  /-- Oplax right unity. -/\n  map‚ÇÇ_rightUnitor :\n    ‚àÄ {a b : B} (f : a ‚ü∂ b),\n      map‚ÇÇ (œÅ_ f).hom = mapComp f (ùüô b) ‚â´ map f ‚óÅ mapId b ‚â´ (œÅ_ (map f)).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.OplaxFunctor.mapComp_naturality_right","module":"Mathlib.CategoryTheory.Bicategory.Functor.Oplax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nself : CategoryTheory.OplaxFunctor B C\na b c : B\nf : Quiver.Hom a b\ng g' : Quiver.Hom b c\nŒ∑ : Quiver.Hom g g'\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (self.map‚ÇÇ (CategoryTheory.Bicategory.whiskerLeft f Œ∑)) (self.mapComp f g')) (CategoryTheory.CategoryStruct.comp (self.mapComp f g) (CategoryTheory.Bicategory.whiskerLeft (self.map f) (self.map‚ÇÇ Œ∑)))","decl":"/-- An oplax functor `F` between bicategories `B` and `C` consists of a function between objects\n`F.obj`, a function between 1-morphisms `F.map`, and a function between 2-morphisms `F.map‚ÇÇ`.\n\nUnlike functors between categories, `F.map` do not need to strictly commute with the composition,\nand do not need to strictly preserve the identity. Instead, there are specified 2-morphisms\n`F.map (ùüô a) ‚ü∂ ùüô (F.obj a)` and `F.map (f ‚â´ g) ‚ü∂ F.map f ‚â´ F.map g`.\n\n`F.map‚ÇÇ` strictly commute with compositions and preserve the identity. They also preserve the\nassociator, the left unitor, and the right unitor modulo some adjustments of domains and codomains\nof 2-morphisms.\n-/\nstructure OplaxFunctor (B : Type u‚ÇÅ) [Bicategory.{w‚ÇÅ, v‚ÇÅ} B] (C : Type u‚ÇÇ)\n  [Bicategory.{w‚ÇÇ, v‚ÇÇ} C] extends PrelaxFunctor B C where\n  /-- The 2-morphism underlying the oplax unity constraint. -/\n  mapId (a : B) : map (ùüô a) ‚ü∂ ùüô (obj a)\n  /-- The 2-morphism underlying the oplax functoriality constraint. -/\n  mapComp {a b c : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) : map (f ‚â´ g) ‚ü∂ map f ‚â´ map g\n  /-- Naturality of the oplax functoriality constraint, on the left. -/\n  mapComp_naturality_left :\n    ‚àÄ {a b c : B} {f f' : a ‚ü∂ b} (Œ∑ : f ‚ü∂ f') (g : b ‚ü∂ c),\n      map‚ÇÇ (Œ∑ ‚ñ∑ g) ‚â´ mapComp f' g = mapComp f g ‚â´ map‚ÇÇ Œ∑ ‚ñ∑ map g := by\n    aesop_cat\n  /-- Naturality of the lax functoriality constraight, on the right. -/\n  mapComp_naturality_right :\n    ‚àÄ {a b c : B} (f : a ‚ü∂ b) {g g' : b ‚ü∂ c} (Œ∑ : g ‚ü∂ g'),\n      map‚ÇÇ (f ‚óÅ Œ∑) ‚â´ mapComp f g' = mapComp f g ‚â´ map f ‚óÅ map‚ÇÇ Œ∑ := by\n    aesop_cat\n  /-- Oplax associativity. -/\n  map‚ÇÇ_associator :\n    ‚àÄ {a b c d : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d),\n      map‚ÇÇ (Œ±_ f g h).hom ‚â´ mapComp f (g ‚â´ h) ‚â´ map f ‚óÅ mapComp g h =\n    mapComp (f ‚â´ g) h ‚â´ mapComp f g ‚ñ∑ map h ‚â´ (Œ±_ (map f) (map g) (map h)).hom := by\n    aesop_cat\n  /-- Oplax left unity. -/\n  map‚ÇÇ_leftUnitor :\n    ‚àÄ {a b : B} (f : a ‚ü∂ b),\n      map‚ÇÇ (Œª_ f).hom = mapComp (ùüô a) f ‚â´ mapId a ‚ñ∑ map f ‚â´ (Œª_ (map f)).hom := by\n    aesop_cat\n  /-- Oplax right unity. -/\n  map‚ÇÇ_rightUnitor :\n    ‚àÄ {a b : B} (f : a ‚ü∂ b),\n      map‚ÇÇ (œÅ_ f).hom = mapComp f (ùüô b) ‚â´ map f ‚óÅ mapId b ‚â´ (œÅ_ (map f)).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.OplaxFunctor.map‚ÇÇ_rightUnitor","module":"Mathlib.CategoryTheory.Bicategory.Functor.Oplax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nself : CategoryTheory.OplaxFunctor B C\na b : B\nf : Quiver.Hom a b\n‚ä¢ Eq (self.map‚ÇÇ (CategoryTheory.Bicategory.rightUnitor f).hom) (CategoryTheory.CategoryStruct.comp (self.mapComp f (CategoryTheory.CategoryStruct.id b)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (self.map f) (self.mapId b)) (CategoryTheory.Bicategory.rightUnitor (self.map f)).hom))","decl":"/-- An oplax functor `F` between bicategories `B` and `C` consists of a function between objects\n`F.obj`, a function between 1-morphisms `F.map`, and a function between 2-morphisms `F.map‚ÇÇ`.\n\nUnlike functors between categories, `F.map` do not need to strictly commute with the composition,\nand do not need to strictly preserve the identity. Instead, there are specified 2-morphisms\n`F.map (ùüô a) ‚ü∂ ùüô (F.obj a)` and `F.map (f ‚â´ g) ‚ü∂ F.map f ‚â´ F.map g`.\n\n`F.map‚ÇÇ` strictly commute with compositions and preserve the identity. They also preserve the\nassociator, the left unitor, and the right unitor modulo some adjustments of domains and codomains\nof 2-morphisms.\n-/\nstructure OplaxFunctor (B : Type u‚ÇÅ) [Bicategory.{w‚ÇÅ, v‚ÇÅ} B] (C : Type u‚ÇÇ)\n  [Bicategory.{w‚ÇÇ, v‚ÇÇ} C] extends PrelaxFunctor B C where\n  /-- The 2-morphism underlying the oplax unity constraint. -/\n  mapId (a : B) : map (ùüô a) ‚ü∂ ùüô (obj a)\n  /-- The 2-morphism underlying the oplax functoriality constraint. -/\n  mapComp {a b c : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) : map (f ‚â´ g) ‚ü∂ map f ‚â´ map g\n  /-- Naturality of the oplax functoriality constraint, on the left. -/\n  mapComp_naturality_left :\n    ‚àÄ {a b c : B} {f f' : a ‚ü∂ b} (Œ∑ : f ‚ü∂ f') (g : b ‚ü∂ c),\n      map‚ÇÇ (Œ∑ ‚ñ∑ g) ‚â´ mapComp f' g = mapComp f g ‚â´ map‚ÇÇ Œ∑ ‚ñ∑ map g := by\n    aesop_cat\n  /-- Naturality of the lax functoriality constraight, on the right. -/\n  mapComp_naturality_right :\n    ‚àÄ {a b c : B} (f : a ‚ü∂ b) {g g' : b ‚ü∂ c} (Œ∑ : g ‚ü∂ g'),\n      map‚ÇÇ (f ‚óÅ Œ∑) ‚â´ mapComp f g' = mapComp f g ‚â´ map f ‚óÅ map‚ÇÇ Œ∑ := by\n    aesop_cat\n  /-- Oplax associativity. -/\n  map‚ÇÇ_associator :\n    ‚àÄ {a b c d : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d),\n      map‚ÇÇ (Œ±_ f g h).hom ‚â´ mapComp f (g ‚â´ h) ‚â´ map f ‚óÅ mapComp g h =\n    mapComp (f ‚â´ g) h ‚â´ mapComp f g ‚ñ∑ map h ‚â´ (Œ±_ (map f) (map g) (map h)).hom := by\n    aesop_cat\n  /-- Oplax left unity. -/\n  map‚ÇÇ_leftUnitor :\n    ‚àÄ {a b : B} (f : a ‚ü∂ b),\n      map‚ÇÇ (Œª_ f).hom = mapComp (ùüô a) f ‚â´ mapId a ‚ñ∑ map f ‚â´ (Œª_ (map f)).hom := by\n    aesop_cat\n  /-- Oplax right unity. -/\n  map‚ÇÇ_rightUnitor :\n    ‚àÄ {a b : B} (f : a ‚ü∂ b),\n      map‚ÇÇ (œÅ_ f).hom = mapComp f (ùüô b) ‚â´ map f ‚óÅ mapId b ‚â´ (œÅ_ (map f)).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.OplaxFunctor.mapComp_naturality_left","module":"Mathlib.CategoryTheory.Bicategory.Functor.Oplax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nself : CategoryTheory.OplaxFunctor B C\na b c : B\nf f' : Quiver.Hom a b\nŒ∑ : Quiver.Hom f f'\ng : Quiver.Hom b c\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (self.map‚ÇÇ (CategoryTheory.Bicategory.whiskerRight Œ∑ g)) (self.mapComp f' g)) (CategoryTheory.CategoryStruct.comp (self.mapComp f g) (CategoryTheory.Bicategory.whiskerRight (self.map‚ÇÇ Œ∑) (self.map g)))","decl":"/-- An oplax functor `F` between bicategories `B` and `C` consists of a function between objects\n`F.obj`, a function between 1-morphisms `F.map`, and a function between 2-morphisms `F.map‚ÇÇ`.\n\nUnlike functors between categories, `F.map` do not need to strictly commute with the composition,\nand do not need to strictly preserve the identity. Instead, there are specified 2-morphisms\n`F.map (ùüô a) ‚ü∂ ùüô (F.obj a)` and `F.map (f ‚â´ g) ‚ü∂ F.map f ‚â´ F.map g`.\n\n`F.map‚ÇÇ` strictly commute with compositions and preserve the identity. They also preserve the\nassociator, the left unitor, and the right unitor modulo some adjustments of domains and codomains\nof 2-morphisms.\n-/\nstructure OplaxFunctor (B : Type u‚ÇÅ) [Bicategory.{w‚ÇÅ, v‚ÇÅ} B] (C : Type u‚ÇÇ)\n  [Bicategory.{w‚ÇÇ, v‚ÇÇ} C] extends PrelaxFunctor B C where\n  /-- The 2-morphism underlying the oplax unity constraint. -/\n  mapId (a : B) : map (ùüô a) ‚ü∂ ùüô (obj a)\n  /-- The 2-morphism underlying the oplax functoriality constraint. -/\n  mapComp {a b c : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) : map (f ‚â´ g) ‚ü∂ map f ‚â´ map g\n  /-- Naturality of the oplax functoriality constraint, on the left. -/\n  mapComp_naturality_left :\n    ‚àÄ {a b c : B} {f f' : a ‚ü∂ b} (Œ∑ : f ‚ü∂ f') (g : b ‚ü∂ c),\n      map‚ÇÇ (Œ∑ ‚ñ∑ g) ‚â´ mapComp f' g = mapComp f g ‚â´ map‚ÇÇ Œ∑ ‚ñ∑ map g := by\n    aesop_cat\n  /-- Naturality of the lax functoriality constraight, on the right. -/\n  mapComp_naturality_right :\n    ‚àÄ {a b c : B} (f : a ‚ü∂ b) {g g' : b ‚ü∂ c} (Œ∑ : g ‚ü∂ g'),\n      map‚ÇÇ (f ‚óÅ Œ∑) ‚â´ mapComp f g' = mapComp f g ‚â´ map f ‚óÅ map‚ÇÇ Œ∑ := by\n    aesop_cat\n  /-- Oplax associativity. -/\n  map‚ÇÇ_associator :\n    ‚àÄ {a b c d : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d),\n      map‚ÇÇ (Œ±_ f g h).hom ‚â´ mapComp f (g ‚â´ h) ‚â´ map f ‚óÅ mapComp g h =\n    mapComp (f ‚â´ g) h ‚â´ mapComp f g ‚ñ∑ map h ‚â´ (Œ±_ (map f) (map g) (map h)).hom := by\n    aesop_cat\n  /-- Oplax left unity. -/\n  map‚ÇÇ_leftUnitor :\n    ‚àÄ {a b : B} (f : a ‚ü∂ b),\n      map‚ÇÇ (Œª_ f).hom = mapComp (ùüô a) f ‚â´ mapId a ‚ñ∑ map f ‚â´ (Œª_ (map f)).hom := by\n    aesop_cat\n  /-- Oplax right unity. -/\n  map‚ÇÇ_rightUnitor :\n    ‚àÄ {a b : B} (f : a ‚ü∂ b),\n      map‚ÇÇ (œÅ_ f).hom = mapComp f (ùüô b) ‚â´ map f ‚óÅ mapId b ‚â´ (œÅ_ (map f)).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.OplaxFunctor.map‚ÇÇ_associator","module":"Mathlib.CategoryTheory.Bicategory.Functor.Oplax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nself : CategoryTheory.OplaxFunctor B C\na b c d : B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\nh : Quiver.Hom c d\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (self.map‚ÇÇ (CategoryTheory.Bicategory.associator f g h).hom) (CategoryTheory.CategoryStruct.comp (self.mapComp f (CategoryTheory.CategoryStruct.comp g h)) (CategoryTheory.Bicategory.whiskerLeft (self.map f) (self.mapComp g h)))) (CategoryTheory.CategoryStruct.comp (self.mapComp (CategoryTheory.CategoryStruct.comp f g) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (self.mapComp f g) (self.map h)) (CategoryTheory.Bicategory.associator (self.map f) (self.map g) (self.map h)).hom))","decl":"/-- An oplax functor `F` between bicategories `B` and `C` consists of a function between objects\n`F.obj`, a function between 1-morphisms `F.map`, and a function between 2-morphisms `F.map‚ÇÇ`.\n\nUnlike functors between categories, `F.map` do not need to strictly commute with the composition,\nand do not need to strictly preserve the identity. Instead, there are specified 2-morphisms\n`F.map (ùüô a) ‚ü∂ ùüô (F.obj a)` and `F.map (f ‚â´ g) ‚ü∂ F.map f ‚â´ F.map g`.\n\n`F.map‚ÇÇ` strictly commute with compositions and preserve the identity. They also preserve the\nassociator, the left unitor, and the right unitor modulo some adjustments of domains and codomains\nof 2-morphisms.\n-/\nstructure OplaxFunctor (B : Type u‚ÇÅ) [Bicategory.{w‚ÇÅ, v‚ÇÅ} B] (C : Type u‚ÇÇ)\n  [Bicategory.{w‚ÇÇ, v‚ÇÇ} C] extends PrelaxFunctor B C where\n  /-- The 2-morphism underlying the oplax unity constraint. -/\n  mapId (a : B) : map (ùüô a) ‚ü∂ ùüô (obj a)\n  /-- The 2-morphism underlying the oplax functoriality constraint. -/\n  mapComp {a b c : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) : map (f ‚â´ g) ‚ü∂ map f ‚â´ map g\n  /-- Naturality of the oplax functoriality constraint, on the left. -/\n  mapComp_naturality_left :\n    ‚àÄ {a b c : B} {f f' : a ‚ü∂ b} (Œ∑ : f ‚ü∂ f') (g : b ‚ü∂ c),\n      map‚ÇÇ (Œ∑ ‚ñ∑ g) ‚â´ mapComp f' g = mapComp f g ‚â´ map‚ÇÇ Œ∑ ‚ñ∑ map g := by\n    aesop_cat\n  /-- Naturality of the lax functoriality constraight, on the right. -/\n  mapComp_naturality_right :\n    ‚àÄ {a b c : B} (f : a ‚ü∂ b) {g g' : b ‚ü∂ c} (Œ∑ : g ‚ü∂ g'),\n      map‚ÇÇ (f ‚óÅ Œ∑) ‚â´ mapComp f g' = mapComp f g ‚â´ map f ‚óÅ map‚ÇÇ Œ∑ := by\n    aesop_cat\n  /-- Oplax associativity. -/\n  map‚ÇÇ_associator :\n    ‚àÄ {a b c d : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d),\n      map‚ÇÇ (Œ±_ f g h).hom ‚â´ mapComp f (g ‚â´ h) ‚â´ map f ‚óÅ mapComp g h =\n    mapComp (f ‚â´ g) h ‚â´ mapComp f g ‚ñ∑ map h ‚â´ (Œ±_ (map f) (map g) (map h)).hom := by\n    aesop_cat\n  /-- Oplax left unity. -/\n  map‚ÇÇ_leftUnitor :\n    ‚àÄ {a b : B} (f : a ‚ü∂ b),\n      map‚ÇÇ (Œª_ f).hom = mapComp (ùüô a) f ‚â´ mapId a ‚ñ∑ map f ‚â´ (Œª_ (map f)).hom := by\n    aesop_cat\n  /-- Oplax right unity. -/\n  map‚ÇÇ_rightUnitor :\n    ‚àÄ {a b : B} (f : a ‚ü∂ b),\n      map‚ÇÇ (œÅ_ f).hom = mapComp f (ùüô b) ‚â´ map f ‚óÅ mapId b ‚â´ (œÅ_ (map f)).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.OplaxFunctor.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Bicategory.Functor.Oplax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Bicategory C\ninst‚úù¬π : SizeOf B\ninst‚úù : SizeOf C\ntoPrelaxFunctor : CategoryTheory.PrelaxFunctor B C\nmapId : (a : B) ‚Üí Quiver.Hom (toPrelaxFunctor.map (CategoryTheory.CategoryStruct.id a)) (CategoryTheory.CategoryStruct.id (toPrelaxFunctor.obj a))\nmapComp : {a b c : B} ‚Üí (f : Quiver.Hom a b) ‚Üí (g : Quiver.Hom b c) ‚Üí Quiver.Hom (toPrelaxFunctor.map (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (toPrelaxFunctor.map f) (toPrelaxFunctor.map g))\nmapComp_naturality_left : autoParam (‚àÄ {a b c : B} {f f' : Quiver.Hom a b} (Œ∑ : Quiver.Hom f f') (g : Quiver.Hom b c), Eq (CategoryTheory.CategoryStruct.comp (toPrelaxFunctor.map‚ÇÇ (CategoryTheory.Bicategory.whiskerRight Œ∑ g)) (mapComp f' g)) (CategoryTheory.CategoryStruct.comp (mapComp f g) (CategoryTheory.Bicategory.whiskerRight (toPrelaxFunctor.map‚ÇÇ Œ∑) (toPrelaxFunctor.map g)))) _auto‚úù\nmapComp_naturality_right : autoParam (‚àÄ {a b c : B} (f : Quiver.Hom a b) {g g' : Quiver.Hom b c} (Œ∑ : Quiver.Hom g g'), Eq (CategoryTheory.CategoryStruct.comp (toPrelaxFunctor.map‚ÇÇ (CategoryTheory.Bicategory.whiskerLeft f Œ∑)) (mapComp f g')) (CategoryTheory.CategoryStruct.comp (mapComp f g) (CategoryTheory.Bicategory.whiskerLeft (toPrelaxFunctor.map f) (toPrelaxFunctor.map‚ÇÇ Œ∑)))) _auto‚úù\nmap‚ÇÇ_associator : autoParam (‚àÄ {a b c d : B} (f : Quiver.Hom a b) (g : Quiver.Hom b c) (h : Quiver.Hom c d), Eq (CategoryTheory.CategoryStruct.comp (toPrelaxFunctor.map‚ÇÇ (CategoryTheory.Bicategory.associator f g h).hom) (CategoryTheory.CategoryStruct.comp (mapComp f (CategoryTheory.CategoryStruct.comp g h)) (CategoryTheory.Bicategory.whiskerLeft (toPrelaxFunctor.map f) (mapComp g h)))) (CategoryTheory.CategoryStruct.comp (mapComp (CategoryTheory.CategoryStruct.comp f g) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapComp f g) (toPrelaxFunctor.map h)) (CategoryTheory.Bicategory.associator (toPrelaxFunctor.map f) (toPrelaxFunctor.map g) (toPrelaxFunctor.map h)).hom))) _auto‚úù\nmap‚ÇÇ_leftUnitor : autoParam (‚àÄ {a b : B} (f : Quiver.Hom a b), Eq (toPrelaxFunctor.map‚ÇÇ (CategoryTheory.Bicategory.leftUnitor f).hom) (CategoryTheory.CategoryStruct.comp (mapComp (CategoryTheory.CategoryStruct.id a) f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapId a) (toPrelaxFunctor.map f)) (CategoryTheory.Bicategory.leftUnitor (toPrelaxFunctor.map f)).hom))) _auto‚úù\nmap‚ÇÇ_rightUnitor : autoParam (‚àÄ {a b : B} (f : Quiver.Hom a b), Eq (toPrelaxFunctor.map‚ÇÇ (CategoryTheory.Bicategory.rightUnitor f).hom) (CategoryTheory.CategoryStruct.comp (mapComp f (CategoryTheory.CategoryStruct.id b)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (toPrelaxFunctor.map f) (mapId b)) (CategoryTheory.Bicategory.rightUnitor (toPrelaxFunctor.map f)).hom))) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf { toPrelaxFunctor := toPrelaxFunctor, mapId := mapId, mapComp := mapComp, mapComp_naturality_left := mapComp_naturality_left, mapComp_naturality_right := mapComp_naturality_right, map‚ÇÇ_associator := map‚ÇÇ_associator, map‚ÇÇ_leftUnitor := map‚ÇÇ_leftUnitor, map‚ÇÇ_rightUnitor := map‚ÇÇ_rightUnitor }) (HAdd.hAdd 1 (SizeOf.sizeOf toPrelaxFunctor))","decl":"/-- An oplax functor `F` between bicategories `B` and `C` consists of a function between objects\n`F.obj`, a function between 1-morphisms `F.map`, and a function between 2-morphisms `F.map‚ÇÇ`.\n\nUnlike functors between categories, `F.map` do not need to strictly commute with the composition,\nand do not need to strictly preserve the identity. Instead, there are specified 2-morphisms\n`F.map (ùüô a) ‚ü∂ ùüô (F.obj a)` and `F.map (f ‚â´ g) ‚ü∂ F.map f ‚â´ F.map g`.\n\n`F.map‚ÇÇ` strictly commute with compositions and preserve the identity. They also preserve the\nassociator, the left unitor, and the right unitor modulo some adjustments of domains and codomains\nof 2-morphisms.\n-/\nstructure OplaxFunctor (B : Type u‚ÇÅ) [Bicategory.{w‚ÇÅ, v‚ÇÅ} B] (C : Type u‚ÇÇ)\n  [Bicategory.{w‚ÇÇ, v‚ÇÇ} C] extends PrelaxFunctor B C where\n  /-- The 2-morphism underlying the oplax unity constraint. -/\n  mapId (a : B) : map (ùüô a) ‚ü∂ ùüô (obj a)\n  /-- The 2-morphism underlying the oplax functoriality constraint. -/\n  mapComp {a b c : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) : map (f ‚â´ g) ‚ü∂ map f ‚â´ map g\n  /-- Naturality of the oplax functoriality constraint, on the left. -/\n  mapComp_naturality_left :\n    ‚àÄ {a b c : B} {f f' : a ‚ü∂ b} (Œ∑ : f ‚ü∂ f') (g : b ‚ü∂ c),\n      map‚ÇÇ (Œ∑ ‚ñ∑ g) ‚â´ mapComp f' g = mapComp f g ‚â´ map‚ÇÇ Œ∑ ‚ñ∑ map g := by\n    aesop_cat\n  /-- Naturality of the lax functoriality constraight, on the right. -/\n  mapComp_naturality_right :\n    ‚àÄ {a b c : B} (f : a ‚ü∂ b) {g g' : b ‚ü∂ c} (Œ∑ : g ‚ü∂ g'),\n      map‚ÇÇ (f ‚óÅ Œ∑) ‚â´ mapComp f g' = mapComp f g ‚â´ map f ‚óÅ map‚ÇÇ Œ∑ := by\n    aesop_cat\n  /-- Oplax associativity. -/\n  map‚ÇÇ_associator :\n    ‚àÄ {a b c d : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d),\n      map‚ÇÇ (Œ±_ f g h).hom ‚â´ mapComp f (g ‚â´ h) ‚â´ map f ‚óÅ mapComp g h =\n    mapComp (f ‚â´ g) h ‚â´ mapComp f g ‚ñ∑ map h ‚â´ (Œ±_ (map f) (map g) (map h)).hom := by\n    aesop_cat\n  /-- Oplax left unity. -/\n  map‚ÇÇ_leftUnitor :\n    ‚àÄ {a b : B} (f : a ‚ü∂ b),\n      map‚ÇÇ (Œª_ f).hom = mapComp (ùüô a) f ‚â´ mapId a ‚ñ∑ map f ‚â´ (Œª_ (map f)).hom := by\n    aesop_cat\n  /-- Oplax right unity. -/\n  map‚ÇÇ_rightUnitor :\n    ‚àÄ {a b : B} (f : a ‚ü∂ b),\n      map‚ÇÇ (œÅ_ f).hom = mapComp f (ùüô b) ‚â´ map f ‚óÅ mapId b ‚â´ (œÅ_ (map f)).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.OplaxFunctor.mk.inj","module":"Mathlib.CategoryTheory.Bicategory.Functor.Oplax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\ntoPrelaxFunctor‚úù : CategoryTheory.PrelaxFunctor B C\nmapId‚úù : (a : B) ‚Üí Quiver.Hom (toPrelaxFunctor‚úù.map (CategoryTheory.CategoryStruct.id a)) (CategoryTheory.CategoryStruct.id (toPrelaxFunctor‚úù.obj a))\nmapComp‚úù : {a b c : B} ‚Üí (f : Quiver.Hom a b) ‚Üí (g : Quiver.Hom b c) ‚Üí Quiver.Hom (toPrelaxFunctor‚úù.map (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (toPrelaxFunctor‚úù.map f) (toPrelaxFunctor‚úù.map g))\nmapComp_naturality_left‚úù : autoParam (‚àÄ {a b c : B} {f f' : Quiver.Hom a b} (Œ∑ : Quiver.Hom f f') (g : Quiver.Hom b c), Eq (CategoryTheory.CategoryStruct.comp (toPrelaxFunctor‚úù.map‚ÇÇ (CategoryTheory.Bicategory.whiskerRight Œ∑ g)) (mapComp‚úù f' g)) (CategoryTheory.CategoryStruct.comp (mapComp‚úù f g) (CategoryTheory.Bicategory.whiskerRight (toPrelaxFunctor‚úù.map‚ÇÇ Œ∑) (toPrelaxFunctor‚úù.map g)))) _auto‚úù\nmapComp_naturality_right‚úù : autoParam (‚àÄ {a b c : B} (f : Quiver.Hom a b) {g g' : Quiver.Hom b c} (Œ∑ : Quiver.Hom g g'), Eq (CategoryTheory.CategoryStruct.comp (toPrelaxFunctor‚úù.map‚ÇÇ (CategoryTheory.Bicategory.whiskerLeft f Œ∑)) (mapComp‚úù f g')) (CategoryTheory.CategoryStruct.comp (mapComp‚úù f g) (CategoryTheory.Bicategory.whiskerLeft (toPrelaxFunctor‚úù.map f) (toPrelaxFunctor‚úù.map‚ÇÇ Œ∑)))) _auto‚úù\nmap‚ÇÇ_associator‚úù : autoParam (‚àÄ {a b c d : B} (f : Quiver.Hom a b) (g : Quiver.Hom b c) (h : Quiver.Hom c d), Eq (CategoryTheory.CategoryStruct.comp (toPrelaxFunctor‚úù.map‚ÇÇ (CategoryTheory.Bicategory.associator f g h).hom) (CategoryTheory.CategoryStruct.comp (mapComp‚úù f (CategoryTheory.CategoryStruct.comp g h)) (CategoryTheory.Bicategory.whiskerLeft (toPrelaxFunctor‚úù.map f) (mapComp‚úù g h)))) (CategoryTheory.CategoryStruct.comp (mapComp‚úù (CategoryTheory.CategoryStruct.comp f g) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapComp‚úù f g) (toPrelaxFunctor‚úù.map h)) (CategoryTheory.Bicategory.associator (toPrelaxFunctor‚úù.map f) (toPrelaxFunctor‚úù.map g) (toPrelaxFunctor‚úù.map h)).hom))) _auto‚úù\nmap‚ÇÇ_leftUnitor‚úù : autoParam (‚àÄ {a b : B} (f : Quiver.Hom a b), Eq (toPrelaxFunctor‚úù.map‚ÇÇ (CategoryTheory.Bicategory.leftUnitor f).hom) (CategoryTheory.CategoryStruct.comp (mapComp‚úù (CategoryTheory.CategoryStruct.id a) f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapId‚úù a) (toPrelaxFunctor‚úù.map f)) (CategoryTheory.Bicategory.leftUnitor (toPrelaxFunctor‚úù.map f)).hom))) _auto‚úù\nmap‚ÇÇ_rightUnitor‚úù : autoParam (‚àÄ {a b : B} (f : Quiver.Hom a b), Eq (toPrelaxFunctor‚úù.map‚ÇÇ (CategoryTheory.Bicategory.rightUnitor f).hom) (CategoryTheory.CategoryStruct.comp (mapComp‚úù f (CategoryTheory.CategoryStruct.id b)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (toPrelaxFunctor‚úù.map f) (mapId‚úù b)) (CategoryTheory.Bicategory.rightUnitor (toPrelaxFunctor‚úù.map f)).hom))) _auto‚úù\ntoPrelaxFunctor : CategoryTheory.PrelaxFunctor B C\nmapId : (a : B) ‚Üí Quiver.Hom (toPrelaxFunctor.map (CategoryTheory.CategoryStruct.id a)) (CategoryTheory.CategoryStruct.id (toPrelaxFunctor.obj a))\nmapComp : {a b c : B} ‚Üí (f : Quiver.Hom a b) ‚Üí (g : Quiver.Hom b c) ‚Üí Quiver.Hom (toPrelaxFunctor.map (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (toPrelaxFunctor.map f) (toPrelaxFunctor.map g))\nmapComp_naturality_left : autoParam (‚àÄ {a b c : B} {f f' : Quiver.Hom a b} (Œ∑ : Quiver.Hom f f') (g : Quiver.Hom b c), Eq (CategoryTheory.CategoryStruct.comp (toPrelaxFunctor.map‚ÇÇ (CategoryTheory.Bicategory.whiskerRight Œ∑ g)) (mapComp f' g)) (CategoryTheory.CategoryStruct.comp (mapComp f g) (CategoryTheory.Bicategory.whiskerRight (toPrelaxFunctor.map‚ÇÇ Œ∑) (toPrelaxFunctor.map g)))) _auto‚úù\nmapComp_naturality_right : autoParam (‚àÄ {a b c : B} (f : Quiver.Hom a b) {g g' : Quiver.Hom b c} (Œ∑ : Quiver.Hom g g'), Eq (CategoryTheory.CategoryStruct.comp (toPrelaxFunctor.map‚ÇÇ (CategoryTheory.Bicategory.whiskerLeft f Œ∑)) (mapComp f g')) (CategoryTheory.CategoryStruct.comp (mapComp f g) (CategoryTheory.Bicategory.whiskerLeft (toPrelaxFunctor.map f) (toPrelaxFunctor.map‚ÇÇ Œ∑)))) _auto‚úù\nmap‚ÇÇ_associator : autoParam (‚àÄ {a b c d : B} (f : Quiver.Hom a b) (g : Quiver.Hom b c) (h : Quiver.Hom c d), Eq (CategoryTheory.CategoryStruct.comp (toPrelaxFunctor.map‚ÇÇ (CategoryTheory.Bicategory.associator f g h).hom) (CategoryTheory.CategoryStruct.comp (mapComp f (CategoryTheory.CategoryStruct.comp g h)) (CategoryTheory.Bicategory.whiskerLeft (toPrelaxFunctor.map f) (mapComp g h)))) (CategoryTheory.CategoryStruct.comp (mapComp (CategoryTheory.CategoryStruct.comp f g) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapComp f g) (toPrelaxFunctor.map h)) (CategoryTheory.Bicategory.associator (toPrelaxFunctor.map f) (toPrelaxFunctor.map g) (toPrelaxFunctor.map h)).hom))) _auto‚úù\nmap‚ÇÇ_leftUnitor : autoParam (‚àÄ {a b : B} (f : Quiver.Hom a b), Eq (toPrelaxFunctor.map‚ÇÇ (CategoryTheory.Bicategory.leftUnitor f).hom) (CategoryTheory.CategoryStruct.comp (mapComp (CategoryTheory.CategoryStruct.id a) f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapId a) (toPrelaxFunctor.map f)) (CategoryTheory.Bicategory.leftUnitor (toPrelaxFunctor.map f)).hom))) _auto‚úù\nmap‚ÇÇ_rightUnitor : autoParam (‚àÄ {a b : B} (f : Quiver.Hom a b), Eq (toPrelaxFunctor.map‚ÇÇ (CategoryTheory.Bicategory.rightUnitor f).hom) (CategoryTheory.CategoryStruct.comp (mapComp f (CategoryTheory.CategoryStruct.id b)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (toPrelaxFunctor.map f) (mapId b)) (CategoryTheory.Bicategory.rightUnitor (toPrelaxFunctor.map f)).hom))) _auto‚úù\nx‚úù : Eq { toPrelaxFunctor := toPrelaxFunctor‚úù, mapId := mapId‚úù, mapComp := mapComp‚úù, mapComp_naturality_left := mapComp_naturality_left‚úù, mapComp_naturality_right := mapComp_naturality_right‚úù, map‚ÇÇ_associator := map‚ÇÇ_associator‚úù, map‚ÇÇ_leftUnitor := map‚ÇÇ_leftUnitor‚úù, map‚ÇÇ_rightUnitor := map‚ÇÇ_rightUnitor‚úù } { toPrelaxFunctor := toPrelaxFunctor, mapId := mapId, mapComp := mapComp, mapComp_naturality_left := mapComp_naturality_left, mapComp_naturality_right := mapComp_naturality_right, map‚ÇÇ_associator := map‚ÇÇ_associator, map‚ÇÇ_leftUnitor := map‚ÇÇ_leftUnitor, map‚ÇÇ_rightUnitor := map‚ÇÇ_rightUnitor }\n‚ä¢ And (Eq toPrelaxFunctor‚úù toPrelaxFunctor) (And (HEq mapId‚úù mapId) (HEq mapComp‚úù mapComp))","decl":"/-- An oplax functor `F` between bicategories `B` and `C` consists of a function between objects\n`F.obj`, a function between 1-morphisms `F.map`, and a function between 2-morphisms `F.map‚ÇÇ`.\n\nUnlike functors between categories, `F.map` do not need to strictly commute with the composition,\nand do not need to strictly preserve the identity. Instead, there are specified 2-morphisms\n`F.map (ùüô a) ‚ü∂ ùüô (F.obj a)` and `F.map (f ‚â´ g) ‚ü∂ F.map f ‚â´ F.map g`.\n\n`F.map‚ÇÇ` strictly commute with compositions and preserve the identity. They also preserve the\nassociator, the left unitor, and the right unitor modulo some adjustments of domains and codomains\nof 2-morphisms.\n-/\nstructure OplaxFunctor (B : Type u‚ÇÅ) [Bicategory.{w‚ÇÅ, v‚ÇÅ} B] (C : Type u‚ÇÇ)\n  [Bicategory.{w‚ÇÇ, v‚ÇÇ} C] extends PrelaxFunctor B C where\n  /-- The 2-morphism underlying the oplax unity constraint. -/\n  mapId (a : B) : map (ùüô a) ‚ü∂ ùüô (obj a)\n  /-- The 2-morphism underlying the oplax functoriality constraint. -/\n  mapComp {a b c : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) : map (f ‚â´ g) ‚ü∂ map f ‚â´ map g\n  /-- Naturality of the oplax functoriality constraint, on the left. -/\n  mapComp_naturality_left :\n    ‚àÄ {a b c : B} {f f' : a ‚ü∂ b} (Œ∑ : f ‚ü∂ f') (g : b ‚ü∂ c),\n      map‚ÇÇ (Œ∑ ‚ñ∑ g) ‚â´ mapComp f' g = mapComp f g ‚â´ map‚ÇÇ Œ∑ ‚ñ∑ map g := by\n    aesop_cat\n  /-- Naturality of the lax functoriality constraight, on the right. -/\n  mapComp_naturality_right :\n    ‚àÄ {a b c : B} (f : a ‚ü∂ b) {g g' : b ‚ü∂ c} (Œ∑ : g ‚ü∂ g'),\n      map‚ÇÇ (f ‚óÅ Œ∑) ‚â´ mapComp f g' = mapComp f g ‚â´ map f ‚óÅ map‚ÇÇ Œ∑ := by\n    aesop_cat\n  /-- Oplax associativity. -/\n  map‚ÇÇ_associator :\n    ‚àÄ {a b c d : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d),\n      map‚ÇÇ (Œ±_ f g h).hom ‚â´ mapComp f (g ‚â´ h) ‚â´ map f ‚óÅ mapComp g h =\n    mapComp (f ‚â´ g) h ‚â´ mapComp f g ‚ñ∑ map h ‚â´ (Œ±_ (map f) (map g) (map h)).hom := by\n    aesop_cat\n  /-- Oplax left unity. -/\n  map‚ÇÇ_leftUnitor :\n    ‚àÄ {a b : B} (f : a ‚ü∂ b),\n      map‚ÇÇ (Œª_ f).hom = mapComp (ùüô a) f ‚â´ mapId a ‚ñ∑ map f ‚â´ (Œª_ (map f)).hom := by\n    aesop_cat\n  /-- Oplax right unity. -/\n  map‚ÇÇ_rightUnitor :\n    ‚àÄ {a b : B} (f : a ‚ü∂ b),\n      map‚ÇÇ (œÅ_ f).hom = mapComp f (ùüô b) ‚â´ map f ‚óÅ mapId b ‚â´ (œÅ_ (map f)).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.OplaxFunctor.map‚ÇÇ_leftUnitor","module":"Mathlib.CategoryTheory.Bicategory.Functor.Oplax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nself : CategoryTheory.OplaxFunctor B C\na b : B\nf : Quiver.Hom a b\n‚ä¢ Eq (self.map‚ÇÇ (CategoryTheory.Bicategory.leftUnitor f).hom) (CategoryTheory.CategoryStruct.comp (self.mapComp (CategoryTheory.CategoryStruct.id a) f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (self.mapId a) (self.map f)) (CategoryTheory.Bicategory.leftUnitor (self.map f)).hom))","decl":"/-- An oplax functor `F` between bicategories `B` and `C` consists of a function between objects\n`F.obj`, a function between 1-morphisms `F.map`, and a function between 2-morphisms `F.map‚ÇÇ`.\n\nUnlike functors between categories, `F.map` do not need to strictly commute with the composition,\nand do not need to strictly preserve the identity. Instead, there are specified 2-morphisms\n`F.map (ùüô a) ‚ü∂ ùüô (F.obj a)` and `F.map (f ‚â´ g) ‚ü∂ F.map f ‚â´ F.map g`.\n\n`F.map‚ÇÇ` strictly commute with compositions and preserve the identity. They also preserve the\nassociator, the left unitor, and the right unitor modulo some adjustments of domains and codomains\nof 2-morphisms.\n-/\nstructure OplaxFunctor (B : Type u‚ÇÅ) [Bicategory.{w‚ÇÅ, v‚ÇÅ} B] (C : Type u‚ÇÇ)\n  [Bicategory.{w‚ÇÇ, v‚ÇÇ} C] extends PrelaxFunctor B C where\n  /-- The 2-morphism underlying the oplax unity constraint. -/\n  mapId (a : B) : map (ùüô a) ‚ü∂ ùüô (obj a)\n  /-- The 2-morphism underlying the oplax functoriality constraint. -/\n  mapComp {a b c : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) : map (f ‚â´ g) ‚ü∂ map f ‚â´ map g\n  /-- Naturality of the oplax functoriality constraint, on the left. -/\n  mapComp_naturality_left :\n    ‚àÄ {a b c : B} {f f' : a ‚ü∂ b} (Œ∑ : f ‚ü∂ f') (g : b ‚ü∂ c),\n      map‚ÇÇ (Œ∑ ‚ñ∑ g) ‚â´ mapComp f' g = mapComp f g ‚â´ map‚ÇÇ Œ∑ ‚ñ∑ map g := by\n    aesop_cat\n  /-- Naturality of the lax functoriality constraight, on the right. -/\n  mapComp_naturality_right :\n    ‚àÄ {a b c : B} (f : a ‚ü∂ b) {g g' : b ‚ü∂ c} (Œ∑ : g ‚ü∂ g'),\n      map‚ÇÇ (f ‚óÅ Œ∑) ‚â´ mapComp f g' = mapComp f g ‚â´ map f ‚óÅ map‚ÇÇ Œ∑ := by\n    aesop_cat\n  /-- Oplax associativity. -/\n  map‚ÇÇ_associator :\n    ‚àÄ {a b c d : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d),\n      map‚ÇÇ (Œ±_ f g h).hom ‚â´ mapComp f (g ‚â´ h) ‚â´ map f ‚óÅ mapComp g h =\n    mapComp (f ‚â´ g) h ‚â´ mapComp f g ‚ñ∑ map h ‚â´ (Œ±_ (map f) (map g) (map h)).hom := by\n    aesop_cat\n  /-- Oplax left unity. -/\n  map‚ÇÇ_leftUnitor :\n    ‚àÄ {a b : B} (f : a ‚ü∂ b),\n      map‚ÇÇ (Œª_ f).hom = mapComp (ùüô a) f ‚â´ mapId a ‚ñ∑ map f ‚â´ (Œª_ (map f)).hom := by\n    aesop_cat\n  /-- Oplax right unity. -/\n  map‚ÇÇ_rightUnitor :\n    ‚àÄ {a b : B} (f : a ‚ü∂ b),\n      map‚ÇÇ (œÅ_ f).hom = mapComp f (ùüô b) ‚â´ map f ‚óÅ mapId b ‚â´ (œÅ_ (map f)).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.OplaxFunctor.mapComp_naturality_left_app","module":"Mathlib.CategoryTheory.Bicategory.Functor.Oplax","initialProofState":"B : Type u_1\ninst‚úù : CategoryTheory.Bicategory B\nself : CategoryTheory.OplaxFunctor B CategoryTheory.Cat\na b c : B\nf f' : Quiver.Hom a b\nŒ∑ : Quiver.Hom f f'\ng : Quiver.Hom b c\nX : ‚Üë(self.obj a)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((self.map‚ÇÇ (CategoryTheory.Bicategory.whiskerRight Œ∑ g)).app X) ((self.mapComp f' g).app X)) (CategoryTheory.CategoryStruct.comp ((self.mapComp f g).app X) ((self.map g).map ((self.map‚ÇÇ Œ∑).app X)))","decl":"attribute [reassoc (attr := simp), to_app (attr := simp)]\n  mapComp_naturality_left mapComp_naturality_right map‚ÇÇ_associator\n"}
{"name":"CategoryTheory.OplaxFunctor.mapComp_naturality_right_assoc","module":"Mathlib.CategoryTheory.Bicategory.Functor.Oplax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nself : CategoryTheory.OplaxFunctor B C\na b c : B\nf : Quiver.Hom a b\ng g' : Quiver.Hom b c\nŒ∑ : Quiver.Hom g g'\nZ : Quiver.Hom (self.obj a) (self.obj c)\nh : Quiver.Hom (CategoryTheory.CategoryStruct.comp (self.map f) (self.map g')) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (self.map‚ÇÇ (CategoryTheory.Bicategory.whiskerLeft f Œ∑)) (CategoryTheory.CategoryStruct.comp (self.mapComp f g') h)) (CategoryTheory.CategoryStruct.comp (self.mapComp f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (self.map f) (self.map‚ÇÇ Œ∑)) h))","decl":"attribute [reassoc (attr := simp), to_app (attr := simp)]\n  mapComp_naturality_left mapComp_naturality_right map‚ÇÇ_associator\n"}
{"name":"CategoryTheory.OplaxFunctor.map‚ÇÇ_associator_assoc","module":"Mathlib.CategoryTheory.Bicategory.Functor.Oplax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nself : CategoryTheory.OplaxFunctor B C\na b c d : B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\nh‚úù : Quiver.Hom c d\nZ : Quiver.Hom (self.obj a) (self.obj d)\nh : Quiver.Hom (CategoryTheory.CategoryStruct.comp (self.map f) (CategoryTheory.CategoryStruct.comp (self.map g) (self.map h‚úù))) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (self.map‚ÇÇ (CategoryTheory.Bicategory.associator f g h‚úù).hom) (CategoryTheory.CategoryStruct.comp (self.mapComp f (CategoryTheory.CategoryStruct.comp g h‚úù)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (self.map f) (self.mapComp g h‚úù)) h))) (CategoryTheory.CategoryStruct.comp (self.mapComp (CategoryTheory.CategoryStruct.comp f g) h‚úù) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (self.mapComp f g) (self.map h‚úù)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (self.map f) (self.map g) (self.map h‚úù)).hom h)))","decl":"attribute [reassoc (attr := simp), to_app (attr := simp)]\n  mapComp_naturality_left mapComp_naturality_right map‚ÇÇ_associator\n"}
{"name":"CategoryTheory.OplaxFunctor.map‚ÇÇ_associator_app","module":"Mathlib.CategoryTheory.Bicategory.Functor.Oplax","initialProofState":"B : Type u_1\ninst‚úù : CategoryTheory.Bicategory B\nself : CategoryTheory.OplaxFunctor B CategoryTheory.Cat\na b c d : B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\nh : Quiver.Hom c d\nX : ‚Üë(self.obj a)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((self.map‚ÇÇ (CategoryTheory.Bicategory.associator f g h).hom).app X) (CategoryTheory.CategoryStruct.comp ((self.mapComp f (CategoryTheory.CategoryStruct.comp g h)).app X) ((self.mapComp g h).app ((self.map f).obj X)))) (CategoryTheory.CategoryStruct.comp ((self.mapComp (CategoryTheory.CategoryStruct.comp f g) h).app X) (CategoryTheory.CategoryStruct.comp ((self.map h).map ((self.mapComp f g).app X)) ((CategoryTheory.Bicategory.associator (self.map f) (self.map g) (self.map h)).hom.app X)))","decl":"attribute [reassoc (attr := simp), to_app (attr := simp)]\n  mapComp_naturality_left mapComp_naturality_right map‚ÇÇ_associator\n"}
{"name":"CategoryTheory.OplaxFunctor.mapComp_naturality_left_assoc","module":"Mathlib.CategoryTheory.Bicategory.Functor.Oplax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nself : CategoryTheory.OplaxFunctor B C\na b c : B\nf f' : Quiver.Hom a b\nŒ∑ : Quiver.Hom f f'\ng : Quiver.Hom b c\nZ : Quiver.Hom (self.obj a) (self.obj c)\nh : Quiver.Hom (CategoryTheory.CategoryStruct.comp (self.map f') (self.map g)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (self.map‚ÇÇ (CategoryTheory.Bicategory.whiskerRight Œ∑ g)) (CategoryTheory.CategoryStruct.comp (self.mapComp f' g) h)) (CategoryTheory.CategoryStruct.comp (self.mapComp f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (self.map‚ÇÇ Œ∑) (self.map g)) h))","decl":"attribute [reassoc (attr := simp), to_app (attr := simp)]\n  mapComp_naturality_left mapComp_naturality_right map‚ÇÇ_associator\n"}
{"name":"CategoryTheory.OplaxFunctor.mapComp_naturality_right_app","module":"Mathlib.CategoryTheory.Bicategory.Functor.Oplax","initialProofState":"B : Type u_1\ninst‚úù : CategoryTheory.Bicategory B\nself : CategoryTheory.OplaxFunctor B CategoryTheory.Cat\na b c : B\nf : Quiver.Hom a b\ng g' : Quiver.Hom b c\nŒ∑ : Quiver.Hom g g'\nX : ‚Üë(self.obj a)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((self.map‚ÇÇ (CategoryTheory.Bicategory.whiskerLeft f Œ∑)).app X) ((self.mapComp f g').app X)) (CategoryTheory.CategoryStruct.comp ((self.mapComp f g).app X) ((self.map‚ÇÇ Œ∑).app ((self.map f).obj X)))","decl":"attribute [reassoc (attr := simp), to_app (attr := simp)]\n  mapComp_naturality_left mapComp_naturality_right map‚ÇÇ_associator\n"}
{"name":"CategoryTheory.OplaxFunctor.map‚ÇÇ_leftUnitor_app","module":"Mathlib.CategoryTheory.Bicategory.Functor.Oplax","initialProofState":"B : Type u_1\ninst‚úù : CategoryTheory.Bicategory B\nself : CategoryTheory.OplaxFunctor B CategoryTheory.Cat\na b : B\nf : Quiver.Hom a b\nX : ‚Üë(self.obj a)\n‚ä¢ Eq ((self.map‚ÇÇ (CategoryTheory.Bicategory.leftUnitor f).hom).app X) (CategoryTheory.CategoryStruct.comp ((self.mapComp (CategoryTheory.CategoryStruct.id a) f).app X) (CategoryTheory.CategoryStruct.comp ((self.map f).map ((self.mapId a).app X)) ((CategoryTheory.Bicategory.leftUnitor (self.map f)).hom.app X)))","decl":"attribute [simp, reassoc, to_app] map‚ÇÇ_leftUnitor map‚ÇÇ_rightUnitor\n\n"}
{"name":"CategoryTheory.OplaxFunctor.map‚ÇÇ_rightUnitor_app","module":"Mathlib.CategoryTheory.Bicategory.Functor.Oplax","initialProofState":"B : Type u_1\ninst‚úù : CategoryTheory.Bicategory B\nself : CategoryTheory.OplaxFunctor B CategoryTheory.Cat\na b : B\nf : Quiver.Hom a b\nX : ‚Üë(self.obj a)\n‚ä¢ Eq ((self.map‚ÇÇ (CategoryTheory.Bicategory.rightUnitor f).hom).app X) (CategoryTheory.CategoryStruct.comp ((self.mapComp f (CategoryTheory.CategoryStruct.id b)).app X) (CategoryTheory.CategoryStruct.comp ((self.mapId b).app ((self.map f).obj X)) ((CategoryTheory.Bicategory.rightUnitor (self.map f)).hom.app X)))","decl":"attribute [simp, reassoc, to_app] map‚ÇÇ_leftUnitor map‚ÇÇ_rightUnitor\n\n"}
{"name":"CategoryTheory.OplaxFunctor.map‚ÇÇ_leftUnitor_assoc","module":"Mathlib.CategoryTheory.Bicategory.Functor.Oplax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nself : CategoryTheory.OplaxFunctor B C\na b : B\nf : Quiver.Hom a b\nZ : Quiver.Hom (self.obj a) (self.obj b)\nh : Quiver.Hom (self.map f) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (self.map‚ÇÇ (CategoryTheory.Bicategory.leftUnitor f).hom) h) (CategoryTheory.CategoryStruct.comp (self.mapComp (CategoryTheory.CategoryStruct.id a) f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (self.mapId a) (self.map f)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.leftUnitor (self.map f)).hom h)))","decl":"attribute [simp, reassoc, to_app] map‚ÇÇ_leftUnitor map‚ÇÇ_rightUnitor\n\n"}
{"name":"CategoryTheory.OplaxFunctor.map‚ÇÇ_rightUnitor_assoc","module":"Mathlib.CategoryTheory.Bicategory.Functor.Oplax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nself : CategoryTheory.OplaxFunctor B C\na b : B\nf : Quiver.Hom a b\nZ : Quiver.Hom (self.obj a) (self.obj b)\nh : Quiver.Hom (self.map f) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (self.map‚ÇÇ (CategoryTheory.Bicategory.rightUnitor f).hom) h) (CategoryTheory.CategoryStruct.comp (self.mapComp f (CategoryTheory.CategoryStruct.id b)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (self.map f) (self.mapId b)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.rightUnitor (self.map f)).hom h)))","decl":"attribute [simp, reassoc, to_app] map‚ÇÇ_leftUnitor map‚ÇÇ_rightUnitor\n\n"}
{"name":"CategoryTheory.OplaxFunctor.mapComp_assoc_right_assoc","module":"Mathlib.CategoryTheory.Bicategory.Functor.Oplax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.OplaxFunctor B C\na b c d : B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\nh‚úù : Quiver.Hom c d\nZ : Quiver.Hom (F.obj a) (F.obj d)\nh : Quiver.Hom (CategoryTheory.CategoryStruct.comp (F.map f) (CategoryTheory.CategoryStruct.comp (F.map g) (F.map h‚úù))) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.mapComp f (CategoryTheory.CategoryStruct.comp g h‚úù)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (F.map f) (F.mapComp g h‚úù)) h)) (CategoryTheory.CategoryStruct.comp (F.map‚ÇÇ (CategoryTheory.Bicategory.associator f g h‚úù).inv) (CategoryTheory.CategoryStruct.comp (F.mapComp (CategoryTheory.CategoryStruct.comp f g) h‚úù) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.mapComp f g) (F.map h‚úù)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (F.map f) (F.map g) (F.map h‚úù)).hom h))))","decl":"@[reassoc, to_app]\nlemma mapComp_assoc_right {a b c d : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) :\n    F.mapComp f (g ‚â´ h) ‚â´ F.map f ‚óÅ F.mapComp g h = F.map‚ÇÇ (Œ±_ f g h).inv ‚â´\n    F.mapComp (f ‚â´ g) h ‚â´ F.mapComp f g ‚ñ∑ F.map h ‚â´\n    (Œ±_ (F.map f) (F.map g) (F.map h)).hom := by\n  rw [‚Üê F.map‚ÇÇ_associator, ‚Üê F.map‚ÇÇ_comp_assoc]\n  simp\n\n"}
{"name":"CategoryTheory.OplaxFunctor.mapComp_assoc_right","module":"Mathlib.CategoryTheory.Bicategory.Functor.Oplax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.OplaxFunctor B C\na b c d : B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\nh : Quiver.Hom c d\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.mapComp f (CategoryTheory.CategoryStruct.comp g h)) (CategoryTheory.Bicategory.whiskerLeft (F.map f) (F.mapComp g h))) (CategoryTheory.CategoryStruct.comp (F.map‚ÇÇ (CategoryTheory.Bicategory.associator f g h).inv) (CategoryTheory.CategoryStruct.comp (F.mapComp (CategoryTheory.CategoryStruct.comp f g) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.mapComp f g) (F.map h)) (CategoryTheory.Bicategory.associator (F.map f) (F.map g) (F.map h)).hom)))","decl":"@[reassoc, to_app]\nlemma mapComp_assoc_right {a b c d : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) :\n    F.mapComp f (g ‚â´ h) ‚â´ F.map f ‚óÅ F.mapComp g h = F.map‚ÇÇ (Œ±_ f g h).inv ‚â´\n    F.mapComp (f ‚â´ g) h ‚â´ F.mapComp f g ‚ñ∑ F.map h ‚â´\n    (Œ±_ (F.map f) (F.map g) (F.map h)).hom := by\n  rw [‚Üê F.map‚ÇÇ_associator, ‚Üê F.map‚ÇÇ_comp_assoc]\n  simp\n\n"}
{"name":"CategoryTheory.OplaxFunctor.mapComp_assoc_right_app","module":"Mathlib.CategoryTheory.Bicategory.Functor.Oplax","initialProofState":"B : Type u_1\ninst‚úù : CategoryTheory.Bicategory B\nF : CategoryTheory.OplaxFunctor B CategoryTheory.Cat\na b c d : B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\nh : Quiver.Hom c d\nX : ‚Üë(F.obj a)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((F.mapComp f (CategoryTheory.CategoryStruct.comp g h)).app X) ((F.mapComp g h).app ((F.map f).obj X))) (CategoryTheory.CategoryStruct.comp ((F.map‚ÇÇ (CategoryTheory.Bicategory.associator f g h).inv).app X) (CategoryTheory.CategoryStruct.comp ((F.mapComp (CategoryTheory.CategoryStruct.comp f g) h).app X) (CategoryTheory.CategoryStruct.comp ((F.map h).map ((F.mapComp f g).app X)) ((CategoryTheory.Bicategory.associator (F.map f) (F.map g) (F.map h)).hom.app X))))","decl":"@[reassoc, to_app]\nlemma mapComp_assoc_right {a b c d : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) :\n    F.mapComp f (g ‚â´ h) ‚â´ F.map f ‚óÅ F.mapComp g h = F.map‚ÇÇ (Œ±_ f g h).inv ‚â´\n    F.mapComp (f ‚â´ g) h ‚â´ F.mapComp f g ‚ñ∑ F.map h ‚â´\n    (Œ±_ (F.map f) (F.map g) (F.map h)).hom := by\n  rw [‚Üê F.map‚ÇÇ_associator, ‚Üê F.map‚ÇÇ_comp_assoc]\n  simp\n\n"}
{"name":"CategoryTheory.OplaxFunctor.mapComp_assoc_left_app","module":"Mathlib.CategoryTheory.Bicategory.Functor.Oplax","initialProofState":"B : Type u_1\ninst‚úù : CategoryTheory.Bicategory B\nF : CategoryTheory.OplaxFunctor B CategoryTheory.Cat\na b c d : B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\nh : Quiver.Hom c d\nX : ‚Üë(F.obj a)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((F.mapComp (CategoryTheory.CategoryStruct.comp f g) h).app X) ((F.map h).map ((F.mapComp f g).app X))) (CategoryTheory.CategoryStruct.comp ((F.map‚ÇÇ (CategoryTheory.Bicategory.associator f g h).hom).app X) (CategoryTheory.CategoryStruct.comp ((F.mapComp f (CategoryTheory.CategoryStruct.comp g h)).app X) (CategoryTheory.CategoryStruct.comp ((F.mapComp g h).app ((F.map f).obj X)) ((CategoryTheory.Bicategory.associator (F.map f) (F.map g) (F.map h)).inv.app X))))","decl":"@[reassoc, to_app]\nlemma mapComp_assoc_left {a b c d : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) :\n    F.mapComp (f ‚â´ g) h ‚â´ F.mapComp f g ‚ñ∑ F.map h =\n    F.map‚ÇÇ (Œ±_ f g h).hom ‚â´ F.mapComp f (g ‚â´ h) ‚â´ F.map f ‚óÅ F.mapComp g h\n    ‚â´ (Œ±_ (F.map f) (F.map g) (F.map h)).inv := by\n  simp\n\n"}
{"name":"CategoryTheory.OplaxFunctor.mapComp_assoc_left","module":"Mathlib.CategoryTheory.Bicategory.Functor.Oplax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.OplaxFunctor B C\na b c d : B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\nh : Quiver.Hom c d\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.mapComp (CategoryTheory.CategoryStruct.comp f g) h) (CategoryTheory.Bicategory.whiskerRight (F.mapComp f g) (F.map h))) (CategoryTheory.CategoryStruct.comp (F.map‚ÇÇ (CategoryTheory.Bicategory.associator f g h).hom) (CategoryTheory.CategoryStruct.comp (F.mapComp f (CategoryTheory.CategoryStruct.comp g h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (F.map f) (F.mapComp g h)) (CategoryTheory.Bicategory.associator (F.map f) (F.map g) (F.map h)).inv)))","decl":"@[reassoc, to_app]\nlemma mapComp_assoc_left {a b c d : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) :\n    F.mapComp (f ‚â´ g) h ‚â´ F.mapComp f g ‚ñ∑ F.map h =\n    F.map‚ÇÇ (Œ±_ f g h).hom ‚â´ F.mapComp f (g ‚â´ h) ‚â´ F.map f ‚óÅ F.mapComp g h\n    ‚â´ (Œ±_ (F.map f) (F.map g) (F.map h)).inv := by\n  simp\n\n"}
{"name":"CategoryTheory.OplaxFunctor.mapComp_assoc_left_assoc","module":"Mathlib.CategoryTheory.Bicategory.Functor.Oplax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.OplaxFunctor B C\na b c d : B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\nh‚úù : Quiver.Hom c d\nZ : Quiver.Hom (F.obj a) (F.obj d)\nh : Quiver.Hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp (F.map f) (F.map g)) (F.map h‚úù)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.mapComp (CategoryTheory.CategoryStruct.comp f g) h‚úù) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.mapComp f g) (F.map h‚úù)) h)) (CategoryTheory.CategoryStruct.comp (F.map‚ÇÇ (CategoryTheory.Bicategory.associator f g h‚úù).hom) (CategoryTheory.CategoryStruct.comp (F.mapComp f (CategoryTheory.CategoryStruct.comp g h‚úù)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (F.map f) (F.mapComp g h‚úù)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (F.map f) (F.map g) (F.map h‚úù)).inv h))))","decl":"@[reassoc, to_app]\nlemma mapComp_assoc_left {a b c d : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) :\n    F.mapComp (f ‚â´ g) h ‚â´ F.mapComp f g ‚ñ∑ F.map h =\n    F.map‚ÇÇ (Œ±_ f g h).hom ‚â´ F.mapComp f (g ‚â´ h) ‚â´ F.map f ‚óÅ F.mapComp g h\n    ‚â´ (Œ±_ (F.map f) (F.map g) (F.map h)).inv := by\n  simp\n\n"}
{"name":"CategoryTheory.OplaxFunctor.id_mapId","module":"Mathlib.CategoryTheory.Bicategory.Functor.Oplax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Bicategory B\na : B\n‚ä¢ Eq ((CategoryTheory.OplaxFunctor.id B).mapId a) (CategoryTheory.CategoryStruct.id (CategoryTheory.CategoryStruct.id a))","decl":"/-- The identity oplax functor. -/\n@[simps]\ndef id (B : Type u‚ÇÅ) [Bicategory.{w‚ÇÅ, v‚ÇÅ} B] : OplaxFunctor B B where\n  toPrelaxFunctor := PrelaxFunctor.id B\n  mapId := fun a => ùüô (ùüô a)\n  mapComp := fun f g => ùüô (f ‚â´ g)\n\n"}
{"name":"CategoryTheory.OplaxFunctor.id_toPrelaxFunctor","module":"Mathlib.CategoryTheory.Bicategory.Functor.Oplax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Bicategory B\n‚ä¢ Eq (CategoryTheory.OplaxFunctor.id B).toPrelaxFunctor (CategoryTheory.PrelaxFunctor.id B)","decl":"/-- The identity oplax functor. -/\n@[simps]\ndef id (B : Type u‚ÇÅ) [Bicategory.{w‚ÇÅ, v‚ÇÅ} B] : OplaxFunctor B B where\n  toPrelaxFunctor := PrelaxFunctor.id B\n  mapId := fun a => ùüô (ùüô a)\n  mapComp := fun f g => ùüô (f ‚â´ g)\n\n"}
{"name":"CategoryTheory.OplaxFunctor.id_mapComp","module":"Mathlib.CategoryTheory.Bicategory.Functor.Oplax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Bicategory B\na‚úù b‚úù c‚úù : B\nf : Quiver.Hom a‚úù b‚úù\ng : Quiver.Hom b‚úù c‚úù\n‚ä¢ Eq ((CategoryTheory.OplaxFunctor.id B).mapComp f g) (CategoryTheory.CategoryStruct.id (CategoryTheory.CategoryStruct.comp f g))","decl":"/-- The identity oplax functor. -/\n@[simps]\ndef id (B : Type u‚ÇÅ) [Bicategory.{w‚ÇÅ, v‚ÇÅ} B] : OplaxFunctor B B where\n  toPrelaxFunctor := PrelaxFunctor.id B\n  mapId := fun a => ùüô (ùüô a)\n  mapComp := fun f g => ùüô (f ‚â´ g)\n\n"}
{"name":"CategoryTheory.OplaxFunctor.PseudoCore.mapCompIso_hom","module":"Mathlib.CategoryTheory.Bicategory.Functor.Oplax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.OplaxFunctor B C\nself : F.PseudoCore\na b c : B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\n‚ä¢ Eq (self.mapCompIso f g).hom (F.mapComp f g)","decl":"/-- A structure on an oplax functor that promotes an oplax functor to a pseudofunctor.\n\nSee `Pseudofunctor.mkOfOplax`. -/\nstructure PseudoCore (F : OplaxFunctor B C) where\n  /-- The isomorphism giving rise to the oplax unity constraint -/\n  mapIdIso (a : B) : F.map (ùüô a) ‚âÖ ùüô (F.obj a)\n  /-- The isomorphism giving rise to the oplax functoriality constraint -/\n  mapCompIso {a b c : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) : F.map (f ‚â´ g) ‚âÖ F.map f ‚â´ F.map g\n  /-- `mapIdIso` gives rise to the oplax unity constraint -/\n  mapIdIso_hom : ‚àÄ {a : B}, (mapIdIso a).hom = F.mapId a := by aesop_cat\n  /-- `mapCompIso` gives rise to the oplax functoriality constraint -/\n  mapCompIso_hom :\n    ‚àÄ {a b c : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c), (mapCompIso f g).hom = F.mapComp f g := by aesop_cat\n\n"}
{"name":"CategoryTheory.OplaxFunctor.PseudoCore.mapIdIso_hom","module":"Mathlib.CategoryTheory.Bicategory.Functor.Oplax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.OplaxFunctor B C\nself : F.PseudoCore\na : B\n‚ä¢ Eq (self.mapIdIso a).hom (F.mapId a)","decl":"/-- A structure on an oplax functor that promotes an oplax functor to a pseudofunctor.\n\nSee `Pseudofunctor.mkOfOplax`. -/\nstructure PseudoCore (F : OplaxFunctor B C) where\n  /-- The isomorphism giving rise to the oplax unity constraint -/\n  mapIdIso (a : B) : F.map (ùüô a) ‚âÖ ùüô (F.obj a)\n  /-- The isomorphism giving rise to the oplax functoriality constraint -/\n  mapCompIso {a b c : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) : F.map (f ‚â´ g) ‚âÖ F.map f ‚â´ F.map g\n  /-- `mapIdIso` gives rise to the oplax unity constraint -/\n  mapIdIso_hom : ‚àÄ {a : B}, (mapIdIso a).hom = F.mapId a := by aesop_cat\n  /-- `mapCompIso` gives rise to the oplax functoriality constraint -/\n  mapCompIso_hom :\n    ‚àÄ {a b c : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c), (mapCompIso f g).hom = F.mapComp f g := by aesop_cat\n\n"}
{"name":"CategoryTheory.OplaxFunctor.PseudoCore.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Bicategory.Functor.Oplax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Bicategory C\nF : CategoryTheory.OplaxFunctor B C\ninst‚úù¬π : SizeOf B\ninst‚úù : SizeOf C\nmapIdIso : (a : B) ‚Üí CategoryTheory.Iso (F.map (CategoryTheory.CategoryStruct.id a)) (CategoryTheory.CategoryStruct.id (F.obj a))\nmapCompIso : {a b c : B} ‚Üí (f : Quiver.Hom a b) ‚Üí (g : Quiver.Hom b c) ‚Üí CategoryTheory.Iso (F.map (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (F.map f) (F.map g))\nmapIdIso_hom : autoParam (‚àÄ {a : B}, Eq (mapIdIso a).hom (F.mapId a)) _auto‚úù\nmapCompIso_hom : autoParam (‚àÄ {a b c : B} (f : Quiver.Hom a b) (g : Quiver.Hom b c), Eq (mapCompIso f g).hom (F.mapComp f g)) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf { mapIdIso := mapIdIso, mapCompIso := mapCompIso, mapIdIso_hom := mapIdIso_hom, mapCompIso_hom := mapCompIso_hom }) 1","decl":"/-- A structure on an oplax functor that promotes an oplax functor to a pseudofunctor.\n\nSee `Pseudofunctor.mkOfOplax`. -/\nstructure PseudoCore (F : OplaxFunctor B C) where\n  /-- The isomorphism giving rise to the oplax unity constraint -/\n  mapIdIso (a : B) : F.map (ùüô a) ‚âÖ ùüô (F.obj a)\n  /-- The isomorphism giving rise to the oplax functoriality constraint -/\n  mapCompIso {a b c : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) : F.map (f ‚â´ g) ‚âÖ F.map f ‚â´ F.map g\n  /-- `mapIdIso` gives rise to the oplax unity constraint -/\n  mapIdIso_hom : ‚àÄ {a : B}, (mapIdIso a).hom = F.mapId a := by aesop_cat\n  /-- `mapCompIso` gives rise to the oplax functoriality constraint -/\n  mapCompIso_hom :\n    ‚àÄ {a b c : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c), (mapCompIso f g).hom = F.mapComp f g := by aesop_cat\n\n"}
{"name":"CategoryTheory.OplaxFunctor.PseudoCore.mk.inj","module":"Mathlib.CategoryTheory.Bicategory.Functor.Oplax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.OplaxFunctor B C\nmapIdIso‚úù : (a : B) ‚Üí CategoryTheory.Iso (F.map (CategoryTheory.CategoryStruct.id a)) (CategoryTheory.CategoryStruct.id (F.obj a))\nmapCompIso‚úù : {a b c : B} ‚Üí (f : Quiver.Hom a b) ‚Üí (g : Quiver.Hom b c) ‚Üí CategoryTheory.Iso (F.map (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (F.map f) (F.map g))\nmapIdIso_hom‚úù : autoParam (‚àÄ {a : B}, Eq (mapIdIso‚úù a).hom (F.mapId a)) _auto‚úù\nmapCompIso_hom‚úù : autoParam (‚àÄ {a b c : B} (f : Quiver.Hom a b) (g : Quiver.Hom b c), Eq (mapCompIso‚úù f g).hom (F.mapComp f g)) _auto‚úù\nmapIdIso : (a : B) ‚Üí CategoryTheory.Iso (F.map (CategoryTheory.CategoryStruct.id a)) (CategoryTheory.CategoryStruct.id (F.obj a))\nmapCompIso : {a b c : B} ‚Üí (f : Quiver.Hom a b) ‚Üí (g : Quiver.Hom b c) ‚Üí CategoryTheory.Iso (F.map (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (F.map f) (F.map g))\nmapIdIso_hom : autoParam (‚àÄ {a : B}, Eq (mapIdIso a).hom (F.mapId a)) _auto‚úù\nmapCompIso_hom : autoParam (‚àÄ {a b c : B} (f : Quiver.Hom a b) (g : Quiver.Hom b c), Eq (mapCompIso f g).hom (F.mapComp f g)) _auto‚úù\nx‚úù : Eq { mapIdIso := mapIdIso‚úù, mapCompIso := mapCompIso‚úù, mapIdIso_hom := mapIdIso_hom‚úù, mapCompIso_hom := mapCompIso_hom‚úù } { mapIdIso := mapIdIso, mapCompIso := mapCompIso, mapIdIso_hom := mapIdIso_hom, mapCompIso_hom := mapCompIso_hom }\n‚ä¢ And (Eq mapIdIso‚úù mapIdIso) (Eq mapCompIso‚úù mapCompIso)","decl":"/-- A structure on an oplax functor that promotes an oplax functor to a pseudofunctor.\n\nSee `Pseudofunctor.mkOfOplax`. -/\nstructure PseudoCore (F : OplaxFunctor B C) where\n  /-- The isomorphism giving rise to the oplax unity constraint -/\n  mapIdIso (a : B) : F.map (ùüô a) ‚âÖ ùüô (F.obj a)\n  /-- The isomorphism giving rise to the oplax functoriality constraint -/\n  mapCompIso {a b c : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) : F.map (f ‚â´ g) ‚âÖ F.map f ‚â´ F.map g\n  /-- `mapIdIso` gives rise to the oplax unity constraint -/\n  mapIdIso_hom : ‚àÄ {a : B}, (mapIdIso a).hom = F.mapId a := by aesop_cat\n  /-- `mapCompIso` gives rise to the oplax functoriality constraint -/\n  mapCompIso_hom :\n    ‚àÄ {a b c : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c), (mapCompIso f g).hom = F.mapComp f g := by aesop_cat\n\n"}
{"name":"CategoryTheory.OplaxFunctor.PseudoCore.mk.injEq","module":"Mathlib.CategoryTheory.Bicategory.Functor.Oplax","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.OplaxFunctor B C\nmapIdIso‚úù : (a : B) ‚Üí CategoryTheory.Iso (F.map (CategoryTheory.CategoryStruct.id a)) (CategoryTheory.CategoryStruct.id (F.obj a))\nmapCompIso‚úù : {a b c : B} ‚Üí (f : Quiver.Hom a b) ‚Üí (g : Quiver.Hom b c) ‚Üí CategoryTheory.Iso (F.map (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (F.map f) (F.map g))\nmapIdIso_hom‚úù : autoParam (‚àÄ {a : B}, Eq (mapIdIso‚úù a).hom (F.mapId a)) _auto‚úù\nmapCompIso_hom‚úù : autoParam (‚àÄ {a b c : B} (f : Quiver.Hom a b) (g : Quiver.Hom b c), Eq (mapCompIso‚úù f g).hom (F.mapComp f g)) _auto‚úù\nmapIdIso : (a : B) ‚Üí CategoryTheory.Iso (F.map (CategoryTheory.CategoryStruct.id a)) (CategoryTheory.CategoryStruct.id (F.obj a))\nmapCompIso : {a b c : B} ‚Üí (f : Quiver.Hom a b) ‚Üí (g : Quiver.Hom b c) ‚Üí CategoryTheory.Iso (F.map (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (F.map f) (F.map g))\nmapIdIso_hom : autoParam (‚àÄ {a : B}, Eq (mapIdIso a).hom (F.mapId a)) _auto‚úù\nmapCompIso_hom : autoParam (‚àÄ {a b c : B} (f : Quiver.Hom a b) (g : Quiver.Hom b c), Eq (mapCompIso f g).hom (F.mapComp f g)) _auto‚úù\n‚ä¢ Eq (Eq { mapIdIso := mapIdIso‚úù, mapCompIso := mapCompIso‚úù, mapIdIso_hom := mapIdIso_hom‚úù, mapCompIso_hom := mapCompIso_hom‚úù } { mapIdIso := mapIdIso, mapCompIso := mapCompIso, mapIdIso_hom := mapIdIso_hom, mapCompIso_hom := mapCompIso_hom }) (And (Eq mapIdIso‚úù mapIdIso) (Eq mapCompIso‚úù mapCompIso))","decl":"/-- A structure on an oplax functor that promotes an oplax functor to a pseudofunctor.\n\nSee `Pseudofunctor.mkOfOplax`. -/\nstructure PseudoCore (F : OplaxFunctor B C) where\n  /-- The isomorphism giving rise to the oplax unity constraint -/\n  mapIdIso (a : B) : F.map (ùüô a) ‚âÖ ùüô (F.obj a)\n  /-- The isomorphism giving rise to the oplax functoriality constraint -/\n  mapCompIso {a b c : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) : F.map (f ‚â´ g) ‚âÖ F.map f ‚â´ F.map g\n  /-- `mapIdIso` gives rise to the oplax unity constraint -/\n  mapIdIso_hom : ‚àÄ {a : B}, (mapIdIso a).hom = F.mapId a := by aesop_cat\n  /-- `mapCompIso` gives rise to the oplax functoriality constraint -/\n  mapCompIso_hom :\n    ‚àÄ {a b c : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c), (mapCompIso f g).hom = F.mapComp f g := by aesop_cat\n\n"}
