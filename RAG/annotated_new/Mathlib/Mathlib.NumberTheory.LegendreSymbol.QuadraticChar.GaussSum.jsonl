{"name":"quadraticChar_two","module":"Mathlib.NumberTheory.LegendreSymbol.QuadraticChar.GaussSum","initialProofState":"F : Type u_1\ninst✝² : Field F\ninst✝¹ : Fintype F\ninst✝ : DecidableEq F\nhF : Ne (ringChar F) 2\n⊢ Eq ((quadraticChar F) 2) (ZMod.χ₈ ↑(Fintype.card F))","decl":"/-- The value of the quadratic character at `2` -/\ntheorem quadraticChar_two [DecidableEq F] (hF : ringChar F ≠ 2) :\n    quadraticChar F 2 = χ₈ (Fintype.card F) :=\n  IsQuadratic.eq_of_eq_coe (quadraticChar_isQuadratic F) isQuadratic_χ₈ hF\n    ((quadraticChar_eq_pow_of_char_ne_two' hF 2).trans (FiniteField.two_pow_card hF))\n\n"}
{"name":"FiniteField.isSquare_two_iff","module":"Mathlib.NumberTheory.LegendreSymbol.QuadraticChar.GaussSum","initialProofState":"F : Type u_1\ninst✝¹ : Field F\ninst✝ : Fintype F\n⊢ Iff (IsSquare 2) (And (Ne (HMod.hMod (Fintype.card F) 8) 3) (Ne (HMod.hMod (Fintype.card F) 8) 5))","decl":"/-- `2` is a square in `F` iff `#F` is not congruent to `3` or `5` mod `8`. -/\ntheorem FiniteField.isSquare_two_iff :\n    IsSquare (2 : F) ↔ Fintype.card F % 8 ≠ 3 ∧ Fintype.card F % 8 ≠ 5 := by\n  classical\n  by_cases hF : ringChar F = 2\n  · have h := FiniteField.even_card_of_char_two hF\n    simp only [FiniteField.isSquare_of_char_two hF, true_iff]\n    omega\n  · have h := FiniteField.odd_card_of_char_ne_two hF\n    rw [← quadraticChar_one_iff_isSquare (Ring.two_ne_zero hF), quadraticChar_two hF,\n      χ₈_nat_eq_if_mod_eight]\n    omega\n\n"}
{"name":"quadraticChar_neg_two","module":"Mathlib.NumberTheory.LegendreSymbol.QuadraticChar.GaussSum","initialProofState":"F : Type u_1\ninst✝² : Field F\ninst✝¹ : Fintype F\ninst✝ : DecidableEq F\nhF : Ne (ringChar F) 2\n⊢ Eq ((quadraticChar F) (-2)) (ZMod.χ₈' ↑(Fintype.card F))","decl":"/-- The value of the quadratic character at `-2` -/\ntheorem quadraticChar_neg_two [DecidableEq F] (hF : ringChar F ≠ 2) :\n    quadraticChar F (-2) = χ₈' (Fintype.card F) := by\n  rw [(by norm_num : (-2 : F) = -1 * 2), map_mul, χ₈'_eq_χ₄_mul_χ₈, quadraticChar_neg_one hF,\n    quadraticChar_two hF, @cast_natCast _ (ZMod 4) _ _ _ (by decide : 4 ∣ 8)]\n\n"}
{"name":"FiniteField.isSquare_neg_two_iff","module":"Mathlib.NumberTheory.LegendreSymbol.QuadraticChar.GaussSum","initialProofState":"F : Type u_1\ninst✝¹ : Field F\ninst✝ : Fintype F\n⊢ Iff (IsSquare (-2)) (And (Ne (HMod.hMod (Fintype.card F) 8) 5) (Ne (HMod.hMod (Fintype.card F) 8) 7))","decl":"/-- `-2` is a square in `F` iff `#F` is not congruent to `5` or `7` mod `8`. -/\ntheorem FiniteField.isSquare_neg_two_iff :\n    IsSquare (-2 : F) ↔ Fintype.card F % 8 ≠ 5 ∧ Fintype.card F % 8 ≠ 7 := by\n  classical\n  by_cases hF : ringChar F = 2\n  · have h := FiniteField.even_card_of_char_two hF\n    simp only [FiniteField.isSquare_of_char_two hF, true_iff]\n    omega\n  · have h := FiniteField.odd_card_of_char_ne_two hF\n    rw [← quadraticChar_one_iff_isSquare (neg_ne_zero.mpr (Ring.two_ne_zero hF)),\n      quadraticChar_neg_two hF, χ₈'_nat_eq_if_mod_eight]\n    omega\n\n"}
{"name":"quadraticChar_card_card","module":"Mathlib.NumberTheory.LegendreSymbol.QuadraticChar.GaussSum","initialProofState":"F : Type u_1\ninst✝⁵ : Field F\ninst✝⁴ : Fintype F\ninst✝³ : DecidableEq F\nhF : Ne (ringChar F) 2\nF' : Type u_2\ninst✝² : Field F'\ninst✝¹ : Fintype F'\ninst✝ : DecidableEq F'\nhF' : Ne (ringChar F') 2\nh : Ne (ringChar F') (ringChar F)\n⊢ Eq ((quadraticChar F) ↑(Fintype.card F')) ((quadraticChar F') (HMul.hMul ↑((quadraticChar F) (-1)) ↑(Fintype.card F)))","decl":"/-- The relation between the values of the quadratic character of one field `F` at the\ncardinality of another field `F'` and of the quadratic character of `F'` at the cardinality\nof `F`. -/\ntheorem quadraticChar_card_card [DecidableEq F] (hF : ringChar F ≠ 2) {F' : Type*} [Field F']\n    [Fintype F'] [DecidableEq F'] (hF' : ringChar F' ≠ 2) (h : ringChar F' ≠ ringChar F) :\n    quadraticChar F (Fintype.card F') =\n    quadraticChar F' (quadraticChar F (-1) * Fintype.card F) := by\n  let χ := (quadraticChar F).ringHomComp (algebraMap ℤ F')\n  have hχ₁ : χ ≠ 1 := by\n    obtain ⟨a, ha⟩ := quadraticChar_exists_neg_one' hF\n    refine ne_one_iff.mpr ⟨a, ?_⟩\n    simpa only [ringHomComp_apply, ha, eq_intCast, Int.cast_neg, Int.cast_one, χ] using\n      Ring.neg_one_ne_one_of_char_ne_two hF'\n  have h := Char.card_pow_card hχ₁ ((quadraticChar_isQuadratic F).comp _) h hF'\n  rw [← quadraticChar_eq_pow_of_char_ne_two' hF'] at h\n  exact (IsQuadratic.eq_of_eq_coe (quadraticChar_isQuadratic F')\n    (quadraticChar_isQuadratic F) hF' h).symm\n\n"}
{"name":"quadraticChar_odd_prime","module":"Mathlib.NumberTheory.LegendreSymbol.QuadraticChar.GaussSum","initialProofState":"F : Type u_1\ninst✝³ : Field F\ninst✝² : Fintype F\ninst✝¹ : DecidableEq F\nhF : Ne (ringChar F) 2\np : Nat\ninst✝ : Fact (Nat.Prime p)\nhp₁ : Ne p 2\nhp₂ : Ne (ringChar F) p\n⊢ Eq ((quadraticChar F) ↑p) ((quadraticChar (ZMod p)) (HMul.hMul ↑(ZMod.χ₄ ↑(Fintype.card F)) ↑(Fintype.card F)))","decl":"/-- The value of the quadratic character at an odd prime `p` different from `ringChar F`. -/\ntheorem quadraticChar_odd_prime [DecidableEq F] (hF : ringChar F ≠ 2) {p : ℕ} [Fact p.Prime]\n    (hp₁ : p ≠ 2) (hp₂ : ringChar F ≠ p) :\n    quadraticChar F p = quadraticChar (ZMod p) (χ₄ (Fintype.card F) * Fintype.card F) := by\n  rw [← quadraticChar_neg_one hF]\n  have h := quadraticChar_card_card hF (ne_of_eq_of_ne (ringChar_zmod_n p) hp₁)\n    (ne_of_eq_of_ne (ringChar_zmod_n p) hp₂.symm)\n  rwa [card p] at h\n\n"}
{"name":"FiniteField.isSquare_odd_prime_iff","module":"Mathlib.NumberTheory.LegendreSymbol.QuadraticChar.GaussSum","initialProofState":"F : Type u_1\ninst✝² : Field F\ninst✝¹ : Fintype F\nhF : Ne (ringChar F) 2\np : Nat\ninst✝ : Fact (Nat.Prime p)\nhp : Ne p 2\n⊢ Iff (IsSquare ↑p) (Ne ((quadraticChar (ZMod p)) (HMul.hMul ↑(ZMod.χ₄ ↑(Fintype.card F)) ↑(Fintype.card F))) (-1))","decl":"/-- An odd prime `p` is a square in `F` iff the quadratic character of `ZMod p` does not\ntake the value `-1` on `χ₄#F * #F`. -/\ntheorem FiniteField.isSquare_odd_prime_iff (hF : ringChar F ≠ 2) {p : ℕ} [Fact p.Prime]\n    (hp : p ≠ 2) :\n    IsSquare (p : F) ↔ quadraticChar (ZMod p) (χ₄ (Fintype.card F) * Fintype.card F) ≠ -1 := by\n  classical\n  by_cases hFp : ringChar F = p\n  · rw [show (p : F) = 0 by rw [← hFp]; exact ringChar.Nat.cast_ringChar]\n    simp only [IsSquare.zero, Ne, true_iff, map_mul]\n    obtain ⟨n, _, hc⟩ := FiniteField.card F (ringChar F)\n    have hchar : ringChar F = ringChar (ZMod p) := by rw [hFp]; exact (ringChar_zmod_n p).symm\n    conv => enter [1, 1, 2]; rw [hc, Nat.cast_pow, map_pow, hchar, map_ringChar]\n    simp only [zero_pow n.ne_zero, mul_zero, zero_eq_neg, one_ne_zero, not_false_iff]\n  · rw [← Iff.not_left (@quadraticChar_neg_one_iff_not_isSquare F _ _ _ _),\n      quadraticChar_odd_prime hF hp]\n    exact hFp\n\n"}
