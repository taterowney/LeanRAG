{"name":"Subring.coe_op","module":"Mathlib.Algebra.Ring.Subring.MulOpposite","initialProofState":"R : Type u_2\ninst✝ : Ring R\nS : Subring R\n⊢ Eq (↑S.op) (Set.preimage MulOpposite.unop ↑S)","decl":"/-- Pull a subring back to an opposite subring along `MulOpposite.unop` -/\n@[simps! coe toSubsemiring]\nprotected def op (S : Subring R) : Subring Rᵐᵒᵖ where\n  toSubsemiring := S.toSubsemiring.op\n  neg_mem' {x} hx := neg_mem (show x.unop ∈ S from hx)\n\n"}
{"name":"Subring.op_toSubsemiring","module":"Mathlib.Algebra.Ring.Subring.MulOpposite","initialProofState":"R : Type u_2\ninst✝ : Ring R\nS : Subring R\n⊢ Eq S.op.toSubsemiring S.op","decl":"/-- Pull a subring back to an opposite subring along `MulOpposite.unop` -/\n@[simps! coe toSubsemiring]\nprotected def op (S : Subring R) : Subring Rᵐᵒᵖ where\n  toSubsemiring := S.toSubsemiring.op\n  neg_mem' {x} hx := neg_mem (show x.unop ∈ S from hx)\n\n"}
{"name":"Subring.mem_op","module":"Mathlib.Algebra.Ring.Subring.MulOpposite","initialProofState":"R : Type u_2\ninst✝ : Ring R\nx : MulOpposite R\nS : Subring R\n⊢ Iff (Membership.mem S.op x) (Membership.mem S (MulOpposite.unop x))","decl":"@[simp]\ntheorem mem_op {x : Rᵐᵒᵖ} {S : Subring R} : x ∈ S.op ↔ x.unop ∈ S := Iff.rfl\n\n"}
{"name":"Subring.coe_unop","module":"Mathlib.Algebra.Ring.Subring.MulOpposite","initialProofState":"R : Type u_2\ninst✝ : Ring R\nS : Subring (MulOpposite R)\n⊢ Eq (↑S.unop) (Set.preimage MulOpposite.op ↑S)","decl":"/-- Pull an opposite subring back to a subring along `MulOpposite.op` -/\n@[simps! coe toSubsemiring]\nprotected def unop (S : Subring Rᵐᵒᵖ) : Subring R where\n  toSubsemiring := S.toSubsemiring.unop\n  neg_mem' {x} hx := neg_mem (show MulOpposite.op x ∈ S from hx)\n\n"}
{"name":"Subring.unop_toSubsemiring","module":"Mathlib.Algebra.Ring.Subring.MulOpposite","initialProofState":"R : Type u_2\ninst✝ : Ring R\nS : Subring (MulOpposite R)\n⊢ Eq S.unop.toSubsemiring S.unop","decl":"/-- Pull an opposite subring back to a subring along `MulOpposite.op` -/\n@[simps! coe toSubsemiring]\nprotected def unop (S : Subring Rᵐᵒᵖ) : Subring R where\n  toSubsemiring := S.toSubsemiring.unop\n  neg_mem' {x} hx := neg_mem (show MulOpposite.op x ∈ S from hx)\n\n"}
{"name":"Subring.mem_unop","module":"Mathlib.Algebra.Ring.Subring.MulOpposite","initialProofState":"R : Type u_2\ninst✝ : Ring R\nx : R\nS : Subring (MulOpposite R)\n⊢ Iff (Membership.mem S.unop x) (Membership.mem S (MulOpposite.op x))","decl":"@[simp]\ntheorem mem_unop {x : R} {S : Subring Rᵐᵒᵖ} : x ∈ S.unop ↔ MulOpposite.op x ∈ S := Iff.rfl\n\n"}
{"name":"Subring.unop_op","module":"Mathlib.Algebra.Ring.Subring.MulOpposite","initialProofState":"R : Type u_2\ninst✝ : Ring R\nS : Subring R\n⊢ Eq S.op.unop S","decl":"@[simp]\ntheorem unop_op (S : Subring R) : S.op.unop = S := rfl\n\n"}
{"name":"Subring.op_unop","module":"Mathlib.Algebra.Ring.Subring.MulOpposite","initialProofState":"R : Type u_2\ninst✝ : Ring R\nS : Subring (MulOpposite R)\n⊢ Eq S.unop.op S","decl":"@[simp]\ntheorem op_unop (S : Subring Rᵐᵒᵖ) : S.unop.op = S := rfl\n\n"}
{"name":"Subring.op_le_iff","module":"Mathlib.Algebra.Ring.Subring.MulOpposite","initialProofState":"R : Type u_2\ninst✝ : Ring R\nS₁ : Subring R\nS₂ : Subring (MulOpposite R)\n⊢ Iff (LE.le S₁.op S₂) (LE.le S₁ S₂.unop)","decl":"theorem op_le_iff {S₁ : Subring R} {S₂ : Subring Rᵐᵒᵖ} : S₁.op ≤ S₂ ↔ S₁ ≤ S₂.unop :=\n  MulOpposite.op_surjective.forall\n\n"}
{"name":"Subring.le_op_iff","module":"Mathlib.Algebra.Ring.Subring.MulOpposite","initialProofState":"R : Type u_2\ninst✝ : Ring R\nS₁ : Subring (MulOpposite R)\nS₂ : Subring R\n⊢ Iff (LE.le S₁ S₂.op) (LE.le S₁.unop S₂)","decl":"theorem le_op_iff {S₁ : Subring Rᵐᵒᵖ} {S₂ : Subring R} : S₁ ≤ S₂.op ↔ S₁.unop ≤ S₂ :=\n  MulOpposite.op_surjective.forall\n\n"}
{"name":"Subring.op_le_op_iff","module":"Mathlib.Algebra.Ring.Subring.MulOpposite","initialProofState":"R : Type u_2\ninst✝ : Ring R\nS₁ S₂ : Subring R\n⊢ Iff (LE.le S₁.op S₂.op) (LE.le S₁ S₂)","decl":"@[simp]\ntheorem op_le_op_iff {S₁ S₂ : Subring R} : S₁.op ≤ S₂.op ↔ S₁ ≤ S₂ :=\n  MulOpposite.op_surjective.forall\n\n"}
{"name":"Subring.unop_le_unop_iff","module":"Mathlib.Algebra.Ring.Subring.MulOpposite","initialProofState":"R : Type u_2\ninst✝ : Ring R\nS₁ S₂ : Subring (MulOpposite R)\n⊢ Iff (LE.le S₁.unop S₂.unop) (LE.le S₁ S₂)","decl":"@[simp]\ntheorem unop_le_unop_iff {S₁ S₂ : Subring Rᵐᵒᵖ} : S₁.unop ≤ S₂.unop ↔ S₁ ≤ S₂ :=\n  MulOpposite.unop_surjective.forall\n\n"}
{"name":"Subring.opEquiv_symm_apply","module":"Mathlib.Algebra.Ring.Subring.MulOpposite","initialProofState":"R : Type u_2\ninst✝ : Ring R\nS : Subring (MulOpposite R)\n⊢ Eq ((RelIso.symm Subring.opEquiv) S) S.unop","decl":"/-- A subring `S` of `R` determines a subring `S.op` of the opposite ring `Rᵐᵒᵖ`. -/\n@[simps]\ndef opEquiv : Subring R ≃o Subring Rᵐᵒᵖ where\n  toFun := Subring.op\n  invFun := Subring.unop\n  left_inv := unop_op\n  right_inv := op_unop\n  map_rel_iff' := op_le_op_iff\n\n"}
{"name":"Subring.opEquiv_apply","module":"Mathlib.Algebra.Ring.Subring.MulOpposite","initialProofState":"R : Type u_2\ninst✝ : Ring R\nS : Subring R\n⊢ Eq (Subring.opEquiv S) S.op","decl":"/-- A subring `S` of `R` determines a subring `S.op` of the opposite ring `Rᵐᵒᵖ`. -/\n@[simps]\ndef opEquiv : Subring R ≃o Subring Rᵐᵒᵖ where\n  toFun := Subring.op\n  invFun := Subring.unop\n  left_inv := unop_op\n  right_inv := op_unop\n  map_rel_iff' := op_le_op_iff\n\n"}
{"name":"Subring.op_injective","module":"Mathlib.Algebra.Ring.Subring.MulOpposite","initialProofState":"R : Type u_2\ninst✝ : Ring R\n⊢ Function.Injective Subring.op","decl":"theorem op_injective : (@Subring.op R _).Injective := opEquiv.injective\n"}
{"name":"Subring.unop_injective","module":"Mathlib.Algebra.Ring.Subring.MulOpposite","initialProofState":"R : Type u_2\ninst✝ : Ring R\n⊢ Function.Injective Subring.unop","decl":"theorem unop_injective : (@Subring.unop R _).Injective := opEquiv.symm.injective\n"}
{"name":"Subring.op_inj","module":"Mathlib.Algebra.Ring.Subring.MulOpposite","initialProofState":"R : Type u_2\ninst✝ : Ring R\nS T : Subring R\n⊢ Iff (Eq S.op T.op) (Eq S T)","decl":"@[simp] theorem op_inj {S T : Subring R} : S.op = T.op ↔ S = T := opEquiv.eq_iff_eq\n"}
{"name":"Subring.unop_inj","module":"Mathlib.Algebra.Ring.Subring.MulOpposite","initialProofState":"R : Type u_2\ninst✝ : Ring R\nS T : Subring (MulOpposite R)\n⊢ Iff (Eq S.unop T.unop) (Eq S T)","decl":"@[simp] theorem unop_inj {S T : Subring Rᵐᵒᵖ} : S.unop = T.unop ↔ S = T := opEquiv.symm.eq_iff_eq\n\n"}
{"name":"Subring.op_bot","module":"Mathlib.Algebra.Ring.Subring.MulOpposite","initialProofState":"R : Type u_2\ninst✝ : Ring R\n⊢ Eq Bot.bot.op Bot.bot","decl":"@[simp]\ntheorem op_bot : (⊥ : Subring R).op = ⊥ := opEquiv.map_bot\n\n"}
{"name":"Subring.op_eq_bot","module":"Mathlib.Algebra.Ring.Subring.MulOpposite","initialProofState":"R : Type u_2\ninst✝ : Ring R\nS : Subring R\n⊢ Iff (Eq S.op Bot.bot) (Eq S Bot.bot)","decl":"@[simp]\ntheorem op_eq_bot {S : Subring R} : S.op = ⊥ ↔ S = ⊥ := op_injective.eq_iff' op_bot\n\n"}
{"name":"Subring.unop_bot","module":"Mathlib.Algebra.Ring.Subring.MulOpposite","initialProofState":"R : Type u_2\ninst✝ : Ring R\n⊢ Eq Bot.bot.unop Bot.bot","decl":"@[simp]\ntheorem unop_bot : (⊥ : Subring Rᵐᵒᵖ).unop = ⊥ := opEquiv.symm.map_bot\n\n"}
{"name":"Subring.unop_eq_bot","module":"Mathlib.Algebra.Ring.Subring.MulOpposite","initialProofState":"R : Type u_2\ninst✝ : Ring R\nS : Subring (MulOpposite R)\n⊢ Iff (Eq S.unop Bot.bot) (Eq S Bot.bot)","decl":"@[simp]\ntheorem unop_eq_bot {S : Subring Rᵐᵒᵖ} : S.unop = ⊥ ↔ S = ⊥ := unop_injective.eq_iff' unop_bot\n\n"}
{"name":"Subring.op_top","module":"Mathlib.Algebra.Ring.Subring.MulOpposite","initialProofState":"R : Type u_2\ninst✝ : Ring R\n⊢ Eq Top.top.op Top.top","decl":"@[simp]\ntheorem op_top : (⊤ : Subring R).op = ⊤ := rfl\n\n"}
{"name":"Subring.op_eq_top","module":"Mathlib.Algebra.Ring.Subring.MulOpposite","initialProofState":"R : Type u_2\ninst✝ : Ring R\nS : Subring R\n⊢ Iff (Eq S.op Top.top) (Eq S Top.top)","decl":"@[simp]\ntheorem op_eq_top {S : Subring R} : S.op = ⊤ ↔ S = ⊤ := op_injective.eq_iff' op_top\n\n"}
{"name":"Subring.unop_top","module":"Mathlib.Algebra.Ring.Subring.MulOpposite","initialProofState":"R : Type u_2\ninst✝ : Ring R\n⊢ Eq Top.top.unop Top.top","decl":"@[simp]\ntheorem unop_top : (⊤ : Subring Rᵐᵒᵖ).unop = ⊤ := rfl\n\n"}
{"name":"Subring.unop_eq_top","module":"Mathlib.Algebra.Ring.Subring.MulOpposite","initialProofState":"R : Type u_2\ninst✝ : Ring R\nS : Subring (MulOpposite R)\n⊢ Iff (Eq S.unop Top.top) (Eq S Top.top)","decl":"@[simp]\ntheorem unop_eq_top {S : Subring Rᵐᵒᵖ} : S.unop = ⊤ ↔ S = ⊤ := unop_injective.eq_iff' unop_top\n\n"}
{"name":"Subring.op_sup","module":"Mathlib.Algebra.Ring.Subring.MulOpposite","initialProofState":"R : Type u_2\ninst✝ : Ring R\nS₁ S₂ : Subring R\n⊢ Eq (Max.max S₁ S₂).op (Max.max S₁.op S₂.op)","decl":"theorem op_sup (S₁ S₂ : Subring R) : (S₁ ⊔ S₂).op = S₁.op ⊔ S₂.op :=\n  opEquiv.map_sup _ _\n\n"}
{"name":"Subring.unop_sup","module":"Mathlib.Algebra.Ring.Subring.MulOpposite","initialProofState":"R : Type u_2\ninst✝ : Ring R\nS₁ S₂ : Subring (MulOpposite R)\n⊢ Eq (Max.max S₁ S₂).unop (Max.max S₁.unop S₂.unop)","decl":"theorem unop_sup (S₁ S₂ : Subring Rᵐᵒᵖ) : (S₁ ⊔ S₂).unop = S₁.unop ⊔ S₂.unop :=\n  opEquiv.symm.map_sup _ _\n\n"}
{"name":"Subring.op_inf","module":"Mathlib.Algebra.Ring.Subring.MulOpposite","initialProofState":"R : Type u_2\ninst✝ : Ring R\nS₁ S₂ : Subring R\n⊢ Eq (Min.min S₁ S₂).op (Min.min S₁.op S₂.op)","decl":"theorem op_inf (S₁ S₂ : Subring R) : (S₁ ⊓ S₂).op = S₁.op ⊓ S₂.op := rfl\n\n"}
{"name":"Subring.unop_inf","module":"Mathlib.Algebra.Ring.Subring.MulOpposite","initialProofState":"R : Type u_2\ninst✝ : Ring R\nS₁ S₂ : Subring (MulOpposite R)\n⊢ Eq (Min.min S₁ S₂).unop (Min.min S₁.unop S₂.unop)","decl":"theorem unop_inf (S₁ S₂ : Subring Rᵐᵒᵖ) : (S₁ ⊓ S₂).unop = S₁.unop ⊓ S₂.unop := rfl\n\n"}
{"name":"Subring.op_sSup","module":"Mathlib.Algebra.Ring.Subring.MulOpposite","initialProofState":"R : Type u_2\ninst✝ : Ring R\nS : Set (Subring R)\n⊢ Eq (SupSet.sSup S).op (SupSet.sSup (Set.preimage Subring.unop S))","decl":"theorem op_sSup (S : Set (Subring R)) : (sSup S).op = sSup (.unop ⁻¹' S) :=\n  opEquiv.map_sSup_eq_sSup_symm_preimage _\n\n"}
{"name":"Subring.unop_sSup","module":"Mathlib.Algebra.Ring.Subring.MulOpposite","initialProofState":"R : Type u_2\ninst✝ : Ring R\nS : Set (Subring (MulOpposite R))\n⊢ Eq (SupSet.sSup S).unop (SupSet.sSup (Set.preimage Subring.op S))","decl":"theorem unop_sSup (S : Set (Subring Rᵐᵒᵖ)) : (sSup S).unop = sSup (.op ⁻¹' S) :=\n  opEquiv.symm.map_sSup_eq_sSup_symm_preimage _\n\n"}
{"name":"Subring.op_sInf","module":"Mathlib.Algebra.Ring.Subring.MulOpposite","initialProofState":"R : Type u_2\ninst✝ : Ring R\nS : Set (Subring R)\n⊢ Eq (InfSet.sInf S).op (InfSet.sInf (Set.preimage Subring.unop S))","decl":"theorem op_sInf (S : Set (Subring R)) : (sInf S).op = sInf (.unop ⁻¹' S) :=\n  opEquiv.map_sInf_eq_sInf_symm_preimage _\n\n"}
{"name":"Subring.unop_sInf","module":"Mathlib.Algebra.Ring.Subring.MulOpposite","initialProofState":"R : Type u_2\ninst✝ : Ring R\nS : Set (Subring (MulOpposite R))\n⊢ Eq (InfSet.sInf S).unop (InfSet.sInf (Set.preimage Subring.op S))","decl":"theorem unop_sInf (S : Set (Subring Rᵐᵒᵖ)) : (sInf S).unop = sInf (.op ⁻¹' S) :=\n  opEquiv.symm.map_sInf_eq_sInf_symm_preimage _\n\n"}
{"name":"Subring.op_iSup","module":"Mathlib.Algebra.Ring.Subring.MulOpposite","initialProofState":"ι : Sort u_1\nR : Type u_2\ninst✝ : Ring R\nS : ι → Subring R\n⊢ Eq (iSup S).op (iSup fun i => (S i).op)","decl":"theorem op_iSup (S : ι → Subring R) : (iSup S).op = ⨆ i, (S i).op := opEquiv.map_iSup _\n\n"}
{"name":"Subring.unop_iSup","module":"Mathlib.Algebra.Ring.Subring.MulOpposite","initialProofState":"ι : Sort u_1\nR : Type u_2\ninst✝ : Ring R\nS : ι → Subring (MulOpposite R)\n⊢ Eq (iSup S).unop (iSup fun i => (S i).unop)","decl":"theorem unop_iSup (S : ι → Subring Rᵐᵒᵖ) : (iSup S).unop = ⨆ i, (S i).unop :=\n  opEquiv.symm.map_iSup _\n\n"}
{"name":"Subring.op_iInf","module":"Mathlib.Algebra.Ring.Subring.MulOpposite","initialProofState":"ι : Sort u_1\nR : Type u_2\ninst✝ : Ring R\nS : ι → Subring R\n⊢ Eq (iInf S).op (iInf fun i => (S i).op)","decl":"theorem op_iInf (S : ι → Subring R) : (iInf S).op = ⨅ i, (S i).op := opEquiv.map_iInf _\n\n"}
{"name":"Subring.unop_iInf","module":"Mathlib.Algebra.Ring.Subring.MulOpposite","initialProofState":"ι : Sort u_1\nR : Type u_2\ninst✝ : Ring R\nS : ι → Subring (MulOpposite R)\n⊢ Eq (iInf S).unop (iInf fun i => (S i).unop)","decl":"theorem unop_iInf (S : ι → Subring Rᵐᵒᵖ) : (iInf S).unop = ⨅ i, (S i).unop :=\n  opEquiv.symm.map_iInf _\n\n"}
{"name":"Subring.op_closure","module":"Mathlib.Algebra.Ring.Subring.MulOpposite","initialProofState":"R : Type u_2\ninst✝ : Ring R\ns : Set R\n⊢ Eq (Subring.closure s).op (Subring.closure (Set.preimage MulOpposite.unop s))","decl":"theorem op_closure (s : Set R) : (closure s).op = closure (MulOpposite.unop ⁻¹' s) := by\n  simp_rw [closure, op_sInf, Set.preimage_setOf_eq, coe_unop]\n  congr with a\n  exact MulOpposite.unop_surjective.forall\n\n"}
{"name":"Subring.unop_closure","module":"Mathlib.Algebra.Ring.Subring.MulOpposite","initialProofState":"R : Type u_2\ninst✝ : Ring R\ns : Set (MulOpposite R)\n⊢ Eq (Subring.closure s).unop (Subring.closure (Set.preimage MulOpposite.op s))","decl":"theorem unop_closure (s : Set Rᵐᵒᵖ) : (closure s).unop = closure (MulOpposite.op ⁻¹' s) := by\n  rw [← op_inj, op_unop, op_closure]\n  simp_rw [Set.preimage_preimage, MulOpposite.op_unop, Set.preimage_id']\n\n"}
{"name":"Subring.addEquivOp_apply_coe","module":"Mathlib.Algebra.Ring.Subring.MulOpposite","initialProofState":"R : Type u_2\ninst✝ : Ring R\nS : Subring R\na : Subtype fun a => Membership.mem S.toSubmonoid a\n⊢ Eq (↑(S.addEquivOp a)) (MulOpposite.op ↑a)","decl":"/-- Bijection between a subring `S` and its opposite. -/\n@[simps!]\ndef addEquivOp (S : Subring R) : S ≃+ S.op := S.toSubsemiring.addEquivOp\n\n"}
{"name":"Subring.addEquivOp_symm_apply_coe","module":"Mathlib.Algebra.Ring.Subring.MulOpposite","initialProofState":"R : Type u_2\ninst✝ : Ring R\nS : Subring R\nb : Subtype fun b => Membership.mem S.op b\n⊢ Eq (↑(S.addEquivOp.symm b)) (MulOpposite.unop ↑b)","decl":"/-- Bijection between a subring `S` and its opposite. -/\n@[simps!]\ndef addEquivOp (S : Subring R) : S ≃+ S.op := S.toSubsemiring.addEquivOp\n\n"}
{"name":"Subring.ringEquivOpMop_apply","module":"Mathlib.Algebra.Ring.Subring.MulOpposite","initialProofState":"R : Type u_2\ninst✝ : Ring R\nS : Subring R\na✝ : Subtype fun x => Membership.mem S.toSubsemiring x\n⊢ Eq (S.ringEquivOpMop a✝) (MulOpposite.op (S.addEquivOp a✝))","decl":"/-- Bijection between a subring `S` and `MulOpposite` of its opposite. -/\n@[simps!]\ndef ringEquivOpMop (S : Subring R) : S ≃+* (S.op)ᵐᵒᵖ := S.toSubsemiring.ringEquivOpMop\n\n"}
{"name":"Subring.ringEquivOpMop_symm_apply_coe","module":"Mathlib.Algebra.Ring.Subring.MulOpposite","initialProofState":"R : Type u_2\ninst✝ : Ring R\nS : Subring R\na✝ : MulOpposite (Subtype fun x => Membership.mem S.op x)\n⊢ Eq (↑(S.ringEquivOpMop.symm a✝)) (MulOpposite.unop ↑(MulOpposite.unop a✝))","decl":"/-- Bijection between a subring `S` and `MulOpposite` of its opposite. -/\n@[simps!]\ndef ringEquivOpMop (S : Subring R) : S ≃+* (S.op)ᵐᵒᵖ := S.toSubsemiring.ringEquivOpMop\n\n"}
{"name":"Subring.mopRingEquivOp_symm_apply","module":"Mathlib.Algebra.Ring.Subring.MulOpposite","initialProofState":"R : Type u_2\ninst✝ : Ring R\nS : Subring R\na✝ : Subtype fun x => Membership.mem S.op x\n⊢ Eq (S.mopRingEquivOp.symm a✝) (MulOpposite.op (S.addEquivOp.symm a✝))","decl":"/-- Bijection between `MulOpposite` of a subring `S` and its opposite. -/\n@[simps!]\ndef mopRingEquivOp (S : Subring R) : Sᵐᵒᵖ ≃+* S.op := S.toSubsemiring.mopRingEquivOp\n\n"}
{"name":"Subring.mopRingEquivOp_apply_coe","module":"Mathlib.Algebra.Ring.Subring.MulOpposite","initialProofState":"R : Type u_2\ninst✝ : Ring R\nS : Subring R\na✝ : MulOpposite (Subtype fun x => Membership.mem S.toSubsemiring x)\n⊢ Eq (↑(S.mopRingEquivOp a✝)) (MulOpposite.op ↑(MulOpposite.unop a✝))","decl":"/-- Bijection between `MulOpposite` of a subring `S` and its opposite. -/\n@[simps!]\ndef mopRingEquivOp (S : Subring R) : Sᵐᵒᵖ ≃+* S.op := S.toSubsemiring.mopRingEquivOp\n\n"}
