{"name":"Finset.dedup_eq_self","module":"Mathlib.Data.Finset.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\n⊢ Eq s.val.dedup s.val","decl":"@[simp]\ntheorem dedup_eq_self [DecidableEq α] (s : Finset α) : dedup s.1 = s.1 :=\n  s.2.dedup\n\n"}
{"name":"Multiset.toFinset_val","module":"Mathlib.Data.Finset.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Multiset α\n⊢ Eq s.toFinset.val s.dedup","decl":"@[simp]\ntheorem toFinset_val (s : Multiset α) : s.toFinset.1 = s.dedup :=\n  rfl\n\n"}
{"name":"Multiset.toFinset_eq","module":"Mathlib.Data.Finset.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Multiset α\nn : s.Nodup\n⊢ Eq { val := s, nodup := n } s.toFinset","decl":"theorem toFinset_eq {s : Multiset α} (n : Nodup s) : Finset.mk s n = s.toFinset :=\n  Finset.val_inj.1 n.dedup.symm\n\n"}
{"name":"Multiset.Nodup.toFinset_inj","module":"Mathlib.Data.Finset.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl l' : Multiset α\nhl : l.Nodup\nhl' : l'.Nodup\nh : Eq l.toFinset l'.toFinset\n⊢ Eq l l'","decl":"theorem Nodup.toFinset_inj {l l' : Multiset α} (hl : Nodup l) (hl' : Nodup l')\n    (h : l.toFinset = l'.toFinset) : l = l' := by\n  simpa [← toFinset_eq hl, ← toFinset_eq hl'] using h\n\n"}
{"name":"Multiset.mem_toFinset","module":"Mathlib.Data.Finset.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Multiset α\n⊢ Iff (Membership.mem s.toFinset a) (Membership.mem s a)","decl":"@[simp]\ntheorem mem_toFinset {a : α} {s : Multiset α} : a ∈ s.toFinset ↔ a ∈ s :=\n  mem_dedup\n\n"}
{"name":"Multiset.toFinset_subset","module":"Mathlib.Data.Finset.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\n⊢ Iff (HasSubset.Subset s.toFinset t.toFinset) (HasSubset.Subset s t)","decl":"@[simp]\ntheorem toFinset_subset : s.toFinset ⊆ t.toFinset ↔ s ⊆ t := by\n  simp only [Finset.subset_iff, Multiset.subset_iff, Multiset.mem_toFinset]\n\n"}
{"name":"Multiset.toFinset_ssubset","module":"Mathlib.Data.Finset.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\n⊢ Iff (HasSSubset.SSubset s.toFinset t.toFinset) (HasSSubset.SSubset s t)","decl":"@[simp]\ntheorem toFinset_ssubset : s.toFinset ⊂ t.toFinset ↔ s ⊂ t := by\n  simp_rw [Finset.ssubset_def, toFinset_subset]\n  rfl\n\n"}
{"name":"Multiset.toFinset_dedup","module":"Mathlib.Data.Finset.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nm : Multiset α\n⊢ Eq m.dedup.toFinset m.toFinset","decl":"@[simp]\ntheorem toFinset_dedup (m : Multiset α) : m.dedup.toFinset = m.toFinset := by\n  simp_rw [toFinset, dedup_idem]\n\n"}
{"name":"Multiset.isWellFounded_ssubset","module":"Mathlib.Data.Finset.Dedup","initialProofState":"β : Type u_2\n⊢ IsWellFounded (Multiset β) fun x1 x2 => HasSSubset.SSubset x1 x2","decl":"instance isWellFounded_ssubset : IsWellFounded (Multiset β) (· ⊂ ·) := by\n  classical\n  exact Subrelation.isWellFounded (InvImage _ toFinset) toFinset_ssubset.2\n\n"}
{"name":"Finset.val_toFinset","module":"Mathlib.Data.Finset.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\n⊢ Eq s.val.toFinset s","decl":"@[simp]\ntheorem val_toFinset [DecidableEq α] (s : Finset α) : s.val.toFinset = s := by\n  ext\n  rw [Multiset.mem_toFinset, ← mem_def]\n\n"}
{"name":"Finset.val_le_iff_val_subset","module":"Mathlib.Data.Finset.Dedup","initialProofState":"α : Type u_1\na : Finset α\nb : Multiset α\n⊢ Iff (LE.le a.val b) (HasSubset.Subset a.val b)","decl":"theorem val_le_iff_val_subset {a : Finset α} {b : Multiset α} : a.val ≤ b ↔ a.val ⊆ b :=\n  Multiset.le_iff_subset a.nodup\n\n"}
{"name":"List.toFinset_val","module":"Mathlib.Data.Finset.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\n⊢ Eq l.toFinset.val ↑l.dedup","decl":"@[simp]\ntheorem toFinset_val (l : List α) : l.toFinset.1 = (l.dedup : Multiset α) :=\n  rfl\n\n"}
{"name":"List.toFinset_coe","module":"Mathlib.Data.Finset.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\n⊢ Eq (↑l).toFinset l.toFinset","decl":"@[simp]\ntheorem toFinset_coe (l : List α) : (l : Multiset α).toFinset = l.toFinset :=\n  rfl\n\n"}
{"name":"List.toFinset_eq","module":"Mathlib.Data.Finset.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\nn : l.Nodup\n⊢ Eq { val := ↑l, nodup := n } l.toFinset","decl":"theorem toFinset_eq (n : Nodup l) : @Finset.mk α l n = l.toFinset :=\n  Multiset.toFinset_eq <| by rwa [Multiset.coe_nodup]\n\n"}
{"name":"List.mem_toFinset","module":"Mathlib.Data.Finset.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\na : α\n⊢ Iff (Membership.mem l.toFinset a) (Membership.mem l a)","decl":"@[simp]\ntheorem mem_toFinset : a ∈ l.toFinset ↔ a ∈ l :=\n  mem_dedup\n\n"}
{"name":"List.coe_toFinset","module":"Mathlib.Data.Finset.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\n⊢ Eq (↑l.toFinset) (setOf fun a => Membership.mem l a)","decl":"@[simp, norm_cast]\ntheorem coe_toFinset (l : List α) : (l.toFinset : Set α) = { a | a ∈ l } :=\n  Set.ext fun _ => List.mem_toFinset\n\n"}
{"name":"List.toFinset_surj_on","module":"Mathlib.Data.Finset.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n⊢ Set.SurjOn List.toFinset (setOf fun l => l.Nodup) Set.univ","decl":"theorem toFinset_surj_on : Set.SurjOn toFinset { l : List α | l.Nodup } Set.univ := by\n  rintro ⟨⟨l⟩, hl⟩ _\n  exact ⟨l, hl, (toFinset_eq hl).symm⟩\n\n"}
{"name":"List.toFinset_surjective","module":"Mathlib.Data.Finset.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n⊢ Function.Surjective List.toFinset","decl":"theorem toFinset_surjective : Surjective (toFinset : List α → Finset α) := fun s =>\n  let ⟨l, _, hls⟩ := toFinset_surj_on (Set.mem_univ s)\n  ⟨l, hls⟩\n\n"}
{"name":"List.toFinset_eq_iff_perm_dedup","module":"Mathlib.Data.Finset.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl l' : List α\n⊢ Iff (Eq l.toFinset l'.toFinset) (l.dedup.Perm l'.dedup)","decl":"theorem toFinset_eq_iff_perm_dedup : l.toFinset = l'.toFinset ↔ l.dedup ~ l'.dedup := by\n  simp [Finset.ext_iff, perm_ext_iff_of_nodup (nodup_dedup _) (nodup_dedup _)]\n\n"}
{"name":"List.toFinset.ext_iff","module":"Mathlib.Data.Finset.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na b : List α\n⊢ Iff (Eq a.toFinset b.toFinset) (∀ (x : α), Iff (Membership.mem a x) (Membership.mem b x))","decl":"theorem toFinset.ext_iff {a b : List α} : a.toFinset = b.toFinset ↔ ∀ x, x ∈ a ↔ x ∈ b := by\n  simp only [Finset.ext_iff, mem_toFinset]\n\n"}
{"name":"List.toFinset.ext","module":"Mathlib.Data.Finset.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl l' : List α\na✝ : ∀ (x : α), Iff (Membership.mem l x) (Membership.mem l' x)\n⊢ Eq l.toFinset l'.toFinset","decl":"theorem toFinset.ext : (∀ x, x ∈ l ↔ x ∈ l') → l.toFinset = l'.toFinset :=\n  toFinset.ext_iff.mpr\n\n"}
{"name":"List.toFinset_eq_of_perm","module":"Mathlib.Data.Finset.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl l' : List α\nh : l.Perm l'\n⊢ Eq l.toFinset l'.toFinset","decl":"theorem toFinset_eq_of_perm (l l' : List α) (h : l ~ l') : l.toFinset = l'.toFinset :=\n  toFinset_eq_iff_perm_dedup.mpr h.dedup\n\n"}
{"name":"List.perm_of_nodup_nodup_toFinset_eq","module":"Mathlib.Data.Finset.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl l' : List α\nhl : l.Nodup\nhl' : l'.Nodup\nh : Eq l.toFinset l'.toFinset\n⊢ l.Perm l'","decl":"theorem perm_of_nodup_nodup_toFinset_eq (hl : Nodup l) (hl' : Nodup l')\n    (h : l.toFinset = l'.toFinset) : l ~ l' := by\n  rw [← Multiset.coe_eq_coe]\n  exact Multiset.Nodup.toFinset_inj hl hl' h\n\n"}
{"name":"List.toFinset_reverse","module":"Mathlib.Data.Finset.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\n⊢ Eq l.reverse.toFinset l.toFinset","decl":"@[simp]\ntheorem toFinset_reverse {l : List α} : toFinset l.reverse = l.toFinset :=\n  toFinset_eq_of_perm _ _ (reverse_perm l)\n\n"}
{"name":"Finset.nodup_toList","module":"Mathlib.Data.Finset.Dedup","initialProofState":"α : Type u_1\ns : Finset α\n⊢ s.toList.Nodup","decl":"theorem nodup_toList (s : Finset α) : s.toList.Nodup := by\n  rw [toList, ← Multiset.coe_nodup, Multiset.coe_toList]\n  exact s.nodup\n\n"}
{"name":"Finset.mem_toList","module":"Mathlib.Data.Finset.Dedup","initialProofState":"α : Type u_1\na : α\ns : Finset α\n⊢ Iff (Membership.mem s.toList a) (Membership.mem s a)","decl":"@[simp]\ntheorem mem_toList {a : α} {s : Finset α} : a ∈ s.toList ↔ a ∈ s :=\n  Multiset.mem_toList\n\n"}
{"name":"Finset.coe_toList","module":"Mathlib.Data.Finset.Dedup","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Eq (↑s.toList) s.val","decl":"@[simp, norm_cast]\ntheorem coe_toList (s : Finset α) : (s.toList : Multiset α) = s.val :=\n  s.val.coe_toList\n\n"}
{"name":"Finset.toList_toFinset","module":"Mathlib.Data.Finset.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\n⊢ Eq s.toList.toFinset s","decl":"@[simp]\ntheorem toList_toFinset [DecidableEq α] (s : Finset α) : s.toList.toFinset = s := by\n  ext\n  simp\n\n"}
{"name":"List.toFinset_toList","module":"Mathlib.Data.Finset.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : List α\nhs : s.Nodup\n⊢ s.toFinset.toList.Perm s","decl":"theorem _root_.List.toFinset_toList [DecidableEq α] {s : List α} (hs : s.Nodup) :\n    s.toFinset.toList.Perm s := by\n  apply List.perm_of_nodup_nodup_toFinset_eq (nodup_toList _) hs\n  rw [toList_toFinset]\n\n"}
{"name":"Finset.exists_list_nodup_eq","module":"Mathlib.Data.Finset.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\n⊢ Exists fun l => And l.Nodup (Eq l.toFinset s)","decl":"theorem exists_list_nodup_eq [DecidableEq α] (s : Finset α) :\n    ∃ l : List α, l.Nodup ∧ l.toFinset = s :=\n  ⟨s.toList, s.nodup_toList, s.toList_toFinset⟩\n\n"}
