{"name":"MeasureTheory.GridLines.T_univ","module":"Mathlib.Analysis.FunctionalSpaces.SobolevInequality","initialProofState":"ι : Type u_1\nA : ι → Type u_2\ninst✝³ : (i : ι) → MeasurableSpace (A i)\nμ : (i : ι) → MeasureTheory.Measure (A i)\ninst✝² : DecidableEq ι\np : Real\ninst✝¹ : Fintype ι\ninst✝ : ∀ (i : ι), MeasureTheory.SigmaFinite (μ i)\nf : ((i : ι) → A i) → ENNReal\nx : (i : ι) → A i\n⊢ Eq (MeasureTheory.GridLines.T μ p f Finset.univ x) (MeasureTheory.lintegral (MeasureTheory.Measure.pi μ) fun x => HMul.hMul (HPow.hPow (f x) (HSub.hSub 1 (HMul.hMul (HSub.hSub (↑(Fintype.card ι)) 1) p))) (Finset.univ.prod fun i => HPow.hPow (MeasureTheory.lintegral (μ i) fun t => f (Function.update x i t)) p))","decl":"@[simp] lemma T_univ [Fintype ι] [∀ i, SigmaFinite (μ i)] (f : (∀ i, A i) → ℝ≥0∞) (x : ∀ i, A i) :\n    T μ p f univ x =\n    ∫⁻ (x : ∀ i, A i), (f x ^ (1 - (#ι - 1 : ℝ) * p)\n    * ∏ i : ι, (∫⁻ t : A i, f (update x i t) ∂(μ i)) ^ p) ∂(.pi μ) := by\n  simp [T, lmarginal_univ, lmarginal_singleton, card_univ]\n\n"}
{"name":"MeasureTheory.GridLines.T_empty","module":"Mathlib.Analysis.FunctionalSpaces.SobolevInequality","initialProofState":"ι : Type u_1\nA : ι → Type u_2\ninst✝¹ : (i : ι) → MeasurableSpace (A i)\nμ : (i : ι) → MeasureTheory.Measure (A i)\ninst✝ : DecidableEq ι\np : Real\nf : ((i : ι) → A i) → ENNReal\nx : (i : ι) → A i\n⊢ Eq (MeasureTheory.GridLines.T μ p f EmptyCollection.emptyCollection x) (HPow.hPow (f x) (HAdd.hAdd 1 p))","decl":"@[simp] lemma T_empty (f : (∀ i, A i) → ℝ≥0∞) (x : ∀ i, A i) :\n    T μ p f ∅ x = f x ^ (1 + p) := by\n  simp [T]\n\n"}
{"name":"MeasureTheory.GridLines.T_insert_le_T_lmarginal_singleton","module":"Mathlib.Analysis.FunctionalSpaces.SobolevInequality","initialProofState":"ι : Type u_1\nA : ι → Type u_2\ninst✝² : (i : ι) → MeasurableSpace (A i)\nμ : (i : ι) → MeasureTheory.Measure (A i)\ninst✝¹ : DecidableEq ι\np : Real\ninst✝ : ∀ (i : ι), MeasureTheory.SigmaFinite (μ i)\nhp₀ : LE.le 0 p\ns : Finset ι\nhp : LE.le (HMul.hMul (↑s.card) p) 1\ni : ι\nhi : Not (Membership.mem s i)\nf : ((i : ι) → A i) → ENNReal\nhf : Measurable f\n⊢ LE.le (MeasureTheory.GridLines.T μ p f (Insert.insert i s)) (MeasureTheory.GridLines.T μ p (MeasureTheory.lmarginal μ (Singleton.singleton i) f) s)","decl":"/-- The main inductive step in the grid-lines lemma for the Gagliardo-Nirenberg-Sobolev inequality.\n\nThe grid-lines operation `GridLines.T` on a nonnegative function on a finitary product type is\nless than or equal to the grid-lines operation of its partial integral in one co-ordinate\n(the latter intuitively considered as a function on a space \"one dimension down\"). -/\ntheorem T_insert_le_T_lmarginal_singleton [∀ i, SigmaFinite (μ i)] (hp₀ : 0 ≤ p) (s : Finset ι)\n    (hp : (s.card : ℝ) * p ≤ 1)\n    (i : ι) (hi : i ∉ s) {f : (∀ i, A i) → ℝ≥0∞} (hf : Measurable f) :\n    T μ p f (insert i s) ≤ T μ p (∫⋯∫⁻_{i}, f ∂μ) s := by\n  /- The proof is a tricky computation that relies on Hölder's inequality at its heart.\n  The left-hand-side is an `|s|+1`-times iterated integral. Let `xᵢ` denote the `i`-th variable.\n  We first push the integral over the `i`-th variable as the\n  innermost integral. This is done in a single step with `MeasureTheory.lmarginal_insert'`,\n  but in fact hides a repeated application of Fubini's theorem.\n  The integrand is a product of `|s|+2` factors, in `|s|+1` of them we integrate over one\n  additional variable. We split of the factor that integrates over `xᵢ`,\n  and apply Hölder's inequality to the remaining factors (whose powers sum exactly to 1).\n  After reordering factors, and combining two factors into one we obtain the right-hand side. -/\n  calc T μ p f (insert i s)\n      = ∫⋯∫⁻_insert i s,\n            f ^ (1 - (s.card : ℝ) * p) * ∏ j ∈ insert i s, (∫⋯∫⁻_{j}, f ∂μ) ^ p ∂μ := by\n          -- unfold `T` and reformulate the exponents\n          simp_rw [T, card_insert_of_not_mem hi]\n          congr!\n          push_cast\n          ring\n    _ = ∫⋯∫⁻_s, (fun x ↦ ∫⁻ (t : A i),\n            (f (update x i t) ^ (1 - (s.card : ℝ) * p)\n            * ∏ j ∈ insert i s, (∫⋯∫⁻_{j}, f ∂μ) (update x i t) ^ p)  ∂ (μ i)) ∂μ := by\n          -- pull out the integral over `xᵢ`\n          rw [lmarginal_insert' _ _ hi]\n          · congr! with x t\n            simp only [Pi.mul_apply, Pi.pow_apply, Finset.prod_apply]\n          · change Measurable (fun x ↦ _)\n            simp only [Pi.mul_apply, Pi.pow_apply, Finset.prod_apply]\n            refine (hf.pow_const _).mul <| Finset.measurable_prod _ ?_\n            exact fun _ _ ↦ hf.lmarginal μ |>.pow_const _\n    _ ≤ T μ p (∫⋯∫⁻_{i}, f ∂μ) s := lmarginal_mono (s := s) (fun x ↦ ?_)\n  -- The remainder of the computation happens within an `|s|`-fold iterated integral\n  simp only [Pi.mul_apply, Pi.pow_apply, Finset.prod_apply]\n  set X := update x i\n  have hF₁ : ∀ {j : ι}, Measurable fun t ↦ (∫⋯∫⁻_{j}, f ∂μ) (X t) :=\n    fun {_} ↦ hf.lmarginal μ |>.comp <| measurable_update _\n  have hF₀ : Measurable fun t ↦ f (X t) := hf.comp <| measurable_update _\n  let k : ℝ := s.card\n  have hk' : 0 ≤ 1 - k * p := by linarith only [hp]\n  calc ∫⁻ t, f (X t) ^ (1 - k * p)\n          * ∏ j ∈ insert i s, (∫⋯∫⁻_{j}, f ∂μ) (X t) ^ p ∂ (μ i)\n      = ∫⁻ t, (∫⋯∫⁻_{i}, f ∂μ) (X t) ^ p * (f (X t) ^ (1 - k * p)\n          * ∏ j ∈ s, ((∫⋯∫⁻_{j}, f ∂μ) (X t) ^ p)) ∂(μ i) := by\n              -- rewrite integrand so that `(∫⋯∫⁻_insert i s, f ∂μ) ^ p` comes first\n              clear_value X\n              congr! 2 with t\n              simp_rw [prod_insert hi]\n              ring_nf\n    _ = (∫⋯∫⁻_{i}, f ∂μ) x ^ p *\n          ∫⁻ t, f (X t) ^ (1 - k * p) * ∏ j ∈ s, ((∫⋯∫⁻_{j}, f ∂μ) (X t)) ^ p ∂(μ i) := by\n              -- pull out this constant factor\n              have : ∀ t, (∫⋯∫⁻_{i}, f ∂μ) (X t) = (∫⋯∫⁻_{i}, f ∂μ) x := by\n                intro t\n                rw [lmarginal_update_of_mem]\n                exact Iff.mpr Finset.mem_singleton rfl\n              simp_rw [this]\n              rw [lintegral_const_mul]\n              exact (hF₀.pow_const _).mul <| Finset.measurable_prod _ fun _ _ ↦ hF₁.pow_const _\n    _ ≤ (∫⋯∫⁻_{i}, f ∂μ) x ^ p *\n          ((∫⁻ t, f (X t) ∂μ i) ^ (1 - k * p)\n          * ∏ j ∈ s, (∫⁻ t, (∫⋯∫⁻_{j}, f ∂μ) (X t) ∂μ i) ^ p) := by\n              -- apply Hölder's inequality\n              gcongr\n              apply ENNReal.lintegral_mul_prod_norm_pow_le\n              · exact hF₀.aemeasurable\n              · intros\n                exact hF₁.aemeasurable\n              · simp only [sum_const, nsmul_eq_mul]\n                ring\n              · exact hk'\n              · exact fun _ _ ↦ hp₀\n    _ = (∫⋯∫⁻_{i}, f ∂μ) x ^ p *\n          ((∫⋯∫⁻_{i}, f ∂μ) x ^ (1 - k * p) * ∏ j ∈ s, (∫⋯∫⁻_{i, j}, f ∂μ) x ^ p) := by\n              -- absorb the newly-created integrals into `∫⋯∫`\n              congr! 2\n              · rw [lmarginal_singleton]\n              refine prod_congr rfl fun j hj => ?_\n              have hi' : i ∉ ({j} : Finset ι) := by\n                simp only [Finset.mem_singleton, Finset.mem_insert, Finset.mem_compl] at hj ⊢\n                exact fun h ↦ hi (h ▸ hj)\n              rw [lmarginal_insert _ hf hi']\n    _ = (∫⋯∫⁻_{i}, f ∂μ) x ^ (p + (1 - k * p)) *  ∏ j ∈ s, (∫⋯∫⁻_{i, j}, f ∂μ) x ^ p := by\n              -- combine two `(∫⋯∫⁻_insert i s, f ∂μ) x` terms\n              rw [ENNReal.rpow_add_of_nonneg]\n              · ring\n              · exact hp₀\n              · exact hk'\n    _ ≤ (∫⋯∫⁻_{i}, f ∂μ) x ^ (1 - (s.card - 1 : ℝ) * p) *\n          ∏ j ∈ s, (∫⋯∫⁻_{j}, (∫⋯∫⁻_{i}, f ∂μ) ∂μ) x ^ p := by\n              -- identify the result with the RHS integrand\n              congr! 2 with j hj\n              · ring_nf\n              · congr! 1\n                rw [← lmarginal_union μ f hf]\n                · congr\n                  rw [Finset.union_comm]\n                  rfl\n                · rw [Finset.disjoint_singleton]\n                  simp only [Finset.mem_insert, Finset.mem_compl] at hj\n                  exact fun h ↦ hi (h ▸ hj)\n\n"}
{"name":"MeasureTheory.GridLines.T_lmarginal_antitone","module":"Mathlib.Analysis.FunctionalSpaces.SobolevInequality","initialProofState":"ι : Type u_1\nA : ι → Type u_2\ninst✝³ : (i : ι) → MeasurableSpace (A i)\nμ : (i : ι) → MeasureTheory.Measure (A i)\ninst✝² : DecidableEq ι\np : Real\ninst✝¹ : Fintype ι\ninst✝ : ∀ (i : ι), MeasureTheory.SigmaFinite (μ i)\nhp₀ : LE.le 0 p\nhp : LE.le (HMul.hMul (HSub.hSub (↑(Fintype.card ι)) 1) p) 1\nf : ((i : ι) → A i) → ENNReal\nhf : Measurable f\n⊢ Antitone fun s => MeasureTheory.GridLines.T μ p (MeasureTheory.lmarginal μ (HasCompl.compl s) f) s","decl":"/-- Auxiliary result for the grid-lines lemma.  Given a nonnegative function on a finitary product\ntype indexed by `ι`, and a set `s` in `ι`, consider partially integrating over the variables in\n`sᶜ` and performing the \"grid-lines operation\" (see `GridLines.T`) to the resulting function in the\nvariables `s`.  This theorem states that this operation decreases as the number of grid-lines taken\nincreases. -/\ntheorem T_lmarginal_antitone [Fintype ι] [∀ i, SigmaFinite (μ i)]\n    (hp₀ : 0 ≤ p) (hp : (#ι - 1 : ℝ) * p ≤ 1) {f : (∀ i, A i) → ℝ≥0∞} (hf : Measurable f) :\n    Antitone (fun s ↦ T μ p (∫⋯∫⁻_sᶜ, f ∂μ) s) := by\n  -- Reformulate (by induction): a function is decreasing on `Finset ι` if it decreases under the\n  -- insertion of any element to any set.\n  rw [Finset.antitone_iff_forall_insert_le]\n  intro s i hi\n  -- apply the lemma designed to encapsulate the inductive step\n  convert T_insert_le_T_lmarginal_singleton μ hp₀ s ?_ i hi (hf.lmarginal μ) using 2\n  · rw [← lmarginal_union μ f hf]\n    · rw [← insert_compl_insert hi]\n      rfl\n    rw [Finset.disjoint_singleton_left, not_mem_compl]\n    exact mem_insert_self i s\n  · -- the main nontrivial point is to check that an exponent `p` satisfying `0 ≤ p` and\n    -- `(#ι - 1) * p ≤ 1` is in the valid range for the inductive-step lemma\n    refine le_trans ?_ hp\n    gcongr\n    suffices (s.card : ℝ) + 1 ≤ #ι by linarith\n    rw [← card_add_card_compl s]\n    norm_cast\n    gcongr\n    have hi' : sᶜ.Nonempty := ⟨i, by rwa [Finset.mem_compl]⟩\n    rwa [← card_pos] at hi'\n\n"}
{"name":"MeasureTheory.lintegral_mul_prod_lintegral_pow_le","module":"Mathlib.Analysis.FunctionalSpaces.SobolevInequality","initialProofState":"ι : Type u_1\nA : ι → Type u_2\ninst✝³ : (i : ι) → MeasurableSpace (A i)\nμ : (i : ι) → MeasureTheory.Measure (A i)\ninst✝² : DecidableEq ι\ninst✝¹ : Fintype ι\ninst✝ : ∀ (i : ι), MeasureTheory.SigmaFinite (μ i)\np : Real\nhp₀ : LE.le 0 p\nhp : LE.le (HMul.hMul (HSub.hSub (↑(Fintype.card ι)) 1) p) 1\nf : ((i : ι) → A i) → ENNReal\nhf : Measurable f\n⊢ LE.le (MeasureTheory.lintegral (MeasureTheory.Measure.pi μ) fun x => HMul.hMul (HPow.hPow (f x) (HSub.hSub 1 (HMul.hMul (HSub.hSub (↑(Fintype.card ι)) 1) p))) (Finset.univ.prod fun i => HPow.hPow (MeasureTheory.lintegral (μ i) fun xᵢ => f (Function.update x i xᵢ)) p)) (HPow.hPow (MeasureTheory.lintegral (MeasureTheory.Measure.pi μ) fun x => f x) (HAdd.hAdd 1 p))","decl":"/-- The \"grid-lines lemma\" (not a standard name), stated with a general parameter `p` as the\nexponent.  Compare with `lintegral_prod_lintegral_pow_le`.\n\nFor any finite dependent product `Π i : ι, A i` of sigma-finite measure spaces, for any\nnonnegative real number `p` such that `(#ι - 1) * p ≤ 1`, for any function `f` from `Π i, A i` into\nthe extended nonnegative reals, we consider an associated \"grid-lines quantity\", the integral of an\nassociated function from `Π i, A i` into the extended nonnegative reals.  The value of this function\nat `x : Π i, A i` is obtained by multiplying a certain power of `f` with the product, for each\nco-ordinate `i`, of a certain power of the integral of `f` along the \"grid line\" in the `i`\ndirection through `x`.\n\nThis lemma bounds the Lebesgue integral of the grid-lines quantity by a power of the Lebesgue\nintegral of `f`. -/\ntheorem lintegral_mul_prod_lintegral_pow_le\n    [Fintype ι] [∀ i, SigmaFinite (μ i)] {p : ℝ} (hp₀ : 0 ≤ p)\n    (hp : (#ι - 1 : ℝ) * p ≤ 1) {f : (∀ i : ι, A i) → ℝ≥0∞} (hf : Measurable f) :\n    ∫⁻ x, f x ^ (1 - (#ι - 1 : ℝ) * p) * ∏ i, (∫⁻ xᵢ, f (update x i xᵢ) ∂μ i) ^ p ∂.pi μ\n    ≤ (∫⁻ x, f x ∂.pi μ) ^ (1 + p) := by\n  cases isEmpty_or_nonempty (∀ i, A i)\n  · simp_rw [lintegral_of_isEmpty]; refine zero_le _\n  inhabit ∀ i, A i\n  have H : (∅ : Finset ι) ≤ Finset.univ := Finset.empty_subset _\n  simpa [lmarginal_univ] using GridLines.T_lmarginal_antitone μ hp₀ hp hf H default\n\n"}
{"name":"MeasureTheory.lintegral_prod_lintegral_pow_le","module":"Mathlib.Analysis.FunctionalSpaces.SobolevInequality","initialProofState":"ι : Type u_1\nA : ι → Type u_2\ninst✝³ : (i : ι) → MeasurableSpace (A i)\nμ : (i : ι) → MeasureTheory.Measure (A i)\ninst✝² : DecidableEq ι\ninst✝¹ : Fintype ι\ninst✝ : ∀ (i : ι), MeasureTheory.SigmaFinite (μ i)\np : Real\nhp : (↑(Fintype.card ι)).IsConjExponent p\nf : ((a : ι) → A a) → ENNReal\nhf : Measurable f\n⊢ LE.le (MeasureTheory.lintegral (MeasureTheory.Measure.pi μ) fun x => Finset.univ.prod fun i => HPow.hPow (MeasureTheory.lintegral (μ i) fun xᵢ => f (Function.update x i xᵢ)) (HDiv.hDiv 1 (HSub.hSub (↑(Fintype.card ι)) 1))) (HPow.hPow (MeasureTheory.lintegral (MeasureTheory.Measure.pi μ) fun x => f x) p)","decl":"/-- Special case of the grid-lines lemma `lintegral_mul_prod_lintegral_pow_le`, taking the extremal\nexponent `p = (#ι - 1)⁻¹`. -/\ntheorem lintegral_prod_lintegral_pow_le [Fintype ι] [∀ i, SigmaFinite (μ i)]\n    {p : ℝ} (hp : Real.IsConjExponent #ι p)\n    {f} (hf : Measurable f) :\n    ∫⁻ x, ∏ i, (∫⁻ xᵢ, f (update x i xᵢ) ∂μ i) ^ ((1 : ℝ) / (#ι - 1 : ℝ)) ∂.pi μ\n    ≤ (∫⁻ x, f x ∂.pi μ) ^ p := by\n  have : Nontrivial ι :=\n    Fintype.one_lt_card_iff_nontrivial.mp (by exact_mod_cast hp.one_lt)\n  have h0 : (1 : ℝ) < #ι := by norm_cast; exact Fintype.one_lt_card\n  have h1 : (0 : ℝ) < #ι - 1 := by linarith\n  have h2 : 0 ≤ ((1 : ℝ) / (#ι - 1 : ℝ)) := by positivity\n  have h3 : (#ι - 1 : ℝ) * ((1 : ℝ) / (#ι - 1 : ℝ)) ≤ 1 := by field_simp\n  have h4 : p = 1 + 1 / (↑#ι - 1) := by field_simp; rw [mul_comm, hp.sub_one_mul_conj]\n  rw [h4]\n  convert lintegral_mul_prod_lintegral_pow_le μ h2 h3 hf using 2\n  field_simp\n\n"}
{"name":"MeasureTheory.lintegral_pow_le_pow_lintegral_fderiv_aux","module":"Mathlib.Analysis.FunctionalSpaces.SobolevInequality","initialProofState":"ι : Type u_1\nF : Type u_3\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Real F\ninst✝ : Fintype ι\np : Real\nhp : (↑(Fintype.card ι)).IsConjExponent p\nu : (ι → Real) → F\nhu : ContDiff Real 1 u\nh2u : HasCompactSupport u\n⊢ LE.le (MeasureTheory.lintegral MeasureTheory.MeasureSpace.volume fun x => HPow.hPow (ENorm.enorm (u x)) p) (HPow.hPow (MeasureTheory.lintegral MeasureTheory.MeasureSpace.volume fun x => ENorm.enorm (fderiv Real u x)) p)","decl":"/-- The **Gagliardo-Nirenberg-Sobolev inequality**.  Let `u` be a continuously differentiable\ncompactly-supported function `u` on `ℝⁿ`, for `n ≥ 2`.  (More literally we encode `ℝⁿ` as\n`ι → ℝ` where `n := #ι` is finite and at least 2.)  Then the Lebesgue integral of the pointwise\nexpression `|u x| ^ (n / (n - 1))` is bounded above by the `n / (n - 1)`-th power of the Lebesgue\nintegral of the Fréchet derivative of `u`.\n\nFor a basis-free version, see `lintegral_pow_le_pow_lintegral_fderiv`. -/\ntheorem lintegral_pow_le_pow_lintegral_fderiv_aux [Fintype ι]\n    {p : ℝ} (hp : Real.IsConjExponent #ι p)\n    {u : (ι → ℝ) → F} (hu : ContDiff ℝ 1 u)\n    (h2u : HasCompactSupport u) :\n    ∫⁻ x, ‖u x‖ₑ ^ p ≤ (∫⁻ x, ‖fderiv ℝ u x‖ₑ) ^ p := by\n  classical\n  /- For a function `f` in one variable and `t ∈ ℝ` we have\n  `|f(t)| = `|∫_{-∞}^t Df(s)∂s| ≤ ∫_ℝ |Df(s)| ∂s` where we use the fundamental theorem of calculus.\n  For each `x ∈ ℝⁿ` we let `u` vary in one of the `n` coordinates and apply the inequality above.\n  By taking the product over these `n` factors, raising them to the power `(n-1)⁻¹` and integrating,\n  we get the inequality `∫ |u| ^ (n/(n-1)) ≤ ∫ x, ∏ i, (∫ xᵢ, |Du(update x i xᵢ)|)^(n-1)⁻¹`.\n  The result then follows from the grid-lines lemma. -/\n  have : (1 : ℝ) ≤ ↑#ι - 1 := by\n    have hι : (2 : ℝ) ≤ #ι := by exact_mod_cast hp.one_lt\n    linarith\n  calc ∫⁻ x, ‖u x‖ₑ ^ p\n      = ∫⁻ x, (‖u x‖ₑ ^ (1 / (#ι - 1 : ℝ))) ^ (#ι : ℝ) := by\n        -- a little algebraic manipulation of the exponent\n        congr! 2 with x\n        rw [← ENNReal.rpow_mul, hp.conj_eq]\n        field_simp\n    _ = ∫⁻ x, ∏ _i : ι, ‖u x‖ₑ ^ (1 / (#ι - 1 : ℝ)) := by\n        -- express the left-hand integrand as a product of identical factors\n        congr! 2 with x\n        simp_rw [prod_const, card_univ]\n        norm_cast\n    _ ≤ ∫⁻ x, ∏ i, (∫⁻ xᵢ, ‖fderiv ℝ u (update x i xᵢ)‖ₑ) ^ ((1 : ℝ) / (#ι - 1 : ℝ)) := ?_\n    _ ≤ (∫⁻ x, ‖fderiv ℝ u x‖ₑ) ^ p := by\n        -- apply the grid-lines lemma\n        apply lintegral_prod_lintegral_pow_le _ hp\n        have : Continuous (fderiv ℝ u) := hu.continuous_fderiv le_rfl\n        fun_prop\n  -- we estimate |u x| using the fundamental theorem of calculus.\n  gcongr with x i\n  calc ‖u x‖ₑ\n    _ ≤ ∫⁻ xᵢ in Iic (x i), ‖deriv (u ∘ update x i) xᵢ‖ₑ := by\n        apply le_trans (by simp) (HasCompactSupport.enorm_le_lintegral_Ici_deriv _ _ _)\n        · exact hu.comp (by convert contDiff_update 1 x i)\n        · exact h2u.comp_isClosedEmbedding (isClosedEmbedding_update x i)\n    _ ≤ ∫⁻ xᵢ, ‖fderiv ℝ u (update x i xᵢ)‖ₑ := ?_\n  gcongr\n  · exact Measure.restrict_le_self\n  intro y\n  dsimp\n  -- bound the derivative which appears\n  calc ‖deriv (u ∘ update x i) y‖ₑ = ‖fderiv ℝ u (update x i y) (deriv (update x i) y)‖ₑ := by\n        rw [fderiv_comp_deriv _ (hu.differentiable le_rfl).differentiableAt\n          (hasDerivAt_update x i y).differentiableAt]\n    _ ≤ ‖fderiv ℝ u (update x i y)‖ₑ * ‖deriv (update x i) y‖ₑ := ContinuousLinearMap.le_opENorm _ _\n    _ ≤ ‖fderiv ℝ u (update x i y)‖ₑ := by simp [deriv_update, Pi.enorm_single]\n\n"}
{"name":"MeasureTheory.lintegralPowLePowLIntegralFDerivConst_def","module":"Mathlib.Analysis.FunctionalSpaces.SobolevInequality","initialProofState":"E : Type u_5\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace Real E\ninst✝³ : MeasurableSpace E\ninst✝² : BorelSpace E\ninst✝¹ : FiniteDimensional Real E\nμ : MeasureTheory.Measure E\ninst✝ : μ.IsAddHaarMeasure\np : Real\n⊢ Eq (MeasureTheory.lintegralPowLePowLIntegralFDerivConst μ p)\n    (let ι := Fin (Module.finrank Real E);\n    letFun ⋯ fun this =>\n      let e := ContinuousLinearEquiv.ofFinrankEq this;\n      let c := μ.addHaarScalarFactor (MeasureTheory.Measure.map (⇑e.symm) MeasureTheory.MeasureSpace.volume);\n      HMul.hMul (HMul.hMul c (HPow.hPow (NNNorm.nnnorm ↑e.symm) p)) (Inv.inv (HPow.hPow c p)))","decl":"/-- The constant factor occurring in the conclusion of `lintegral_pow_le_pow_lintegral_fderiv`.\nIt only depends on `E`, `μ` and `p`.\nIt is determined by the ratio of the measures on `E` and `ℝⁿ` and\nthe operator norm of a chosen equivalence `E ≃ ℝⁿ` (raised to suitable powers involving `p`).-/\nirreducible_def lintegralPowLePowLIntegralFDerivConst (p : ℝ) : ℝ≥0 := by\n  let ι := Fin (finrank ℝ E)\n  have : finrank ℝ E = finrank ℝ (ι → ℝ) := by\n    rw [finrank_fintype_fun_eq_card, Fintype.card_fin (finrank ℝ E)]\n  let e : E ≃L[ℝ] ι → ℝ := ContinuousLinearEquiv.ofFinrankEq this\n  let c := addHaarScalarFactor μ ((volume : Measure (ι → ℝ)).map e.symm)\n  exact (c * ‖(e.symm : (ι → ℝ) →L[ℝ] E)‖₊ ^ p) * (c ^ p)⁻¹\n\n"}
{"name":"MeasureTheory.lintegral_pow_le_pow_lintegral_fderiv","module":"Mathlib.Analysis.FunctionalSpaces.SobolevInequality","initialProofState":"F : Type u_3\ninst✝⁷ : NormedAddCommGroup F\ninst✝⁶ : NormedSpace Real F\nE : Type u_4\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace Real E\ninst✝³ : MeasurableSpace E\ninst✝² : BorelSpace E\ninst✝¹ : FiniteDimensional Real E\nμ : MeasureTheory.Measure E\ninst✝ : μ.IsAddHaarMeasure\nu : E → F\nhu : ContDiff Real 1 u\nh2u : HasCompactSupport u\np : Real\nhp : (↑(Module.finrank Real E)).IsConjExponent p\n⊢ LE.le (MeasureTheory.lintegral μ fun x => HPow.hPow (ENorm.enorm (u x)) p) (HMul.hMul (↑(MeasureTheory.lintegralPowLePowLIntegralFDerivConst μ p)) (HPow.hPow (MeasureTheory.lintegral μ fun x => ENorm.enorm (fderiv Real u x)) p))","decl":"/-- The **Gagliardo-Nirenberg-Sobolev inequality**.  Let `u` be a continuously differentiable\ncompactly-supported function `u` on a normed space `E` of finite dimension `n ≥ 2`, equipped\nwith Haar measure. Then the Lebesgue integral of the pointwise expression\n`|u x| ^ (n / (n - 1))` is bounded above by a constant times the `n / (n - 1)`-th power of the\nLebesgue integral of the Fréchet derivative of `u`. -/\ntheorem lintegral_pow_le_pow_lintegral_fderiv {u : E → F}\n    (hu : ContDiff ℝ 1 u) (h2u : HasCompactSupport u)\n    {p : ℝ} (hp : Real.IsConjExponent (finrank ℝ E) p) :\n    ∫⁻ x, ‖u x‖ₑ ^ p ∂μ ≤\n      lintegralPowLePowLIntegralFDerivConst μ p * (∫⁻ x, ‖fderiv ℝ u x‖ₑ ∂μ) ^ p := by\n  /- We reduce to the case where `E` is `ℝⁿ`, for which we have already proved the result using\n  an explicit basis in `MeasureTheory.lintegral_pow_le_pow_lintegral_fderiv_aux`.\n  This proof is not too hard, but takes quite some steps, reasoning about the equivalence\n  `e : E ≃ ℝⁿ`, relating the measures on each sides of the equivalence,\n  and estimating the derivative using the chain rule. -/\n  set C := lintegralPowLePowLIntegralFDerivConst μ p\n  let ι := Fin (finrank ℝ E)\n  have hιcard : #ι = finrank ℝ E := Fintype.card_fin (finrank ℝ E)\n  have : finrank ℝ E = finrank ℝ (ι → ℝ) := by simp [hιcard]\n  let e : E ≃L[ℝ] ι → ℝ := ContinuousLinearEquiv.ofFinrankEq this\n  have : IsAddHaarMeasure ((volume : Measure (ι → ℝ)).map e.symm) :=\n    (e.symm : (ι → ℝ) ≃+ E).isAddHaarMeasure_map _ e.symm.continuous e.symm.symm.continuous\n  have hp : Real.IsConjExponent #ι p := by rwa [hιcard]\n  have h0p : 0 ≤ p := hp.symm.nonneg\n  let c := addHaarScalarFactor μ ((volume : Measure (ι → ℝ)).map e.symm)\n  have hc : 0 < c := addHaarScalarFactor_pos_of_isAddHaarMeasure ..\n  have h2c : μ = c • ((volume : Measure (ι → ℝ)).map e.symm) := isAddLeftInvariant_eq_smul ..\n  have h3c : (c : ℝ≥0∞) ≠ 0 := by simp_rw [ne_eq, ENNReal.coe_eq_zero, hc.ne', not_false_eq_true]\n  have h0C : C = (c * ‖(e.symm : (ι → ℝ) →L[ℝ] E)‖₊ ^ p) * (c ^ p)⁻¹ := by\n    simp_rw [c, ι, C, e, lintegralPowLePowLIntegralFDerivConst]\n  have hC : C * c ^ p = c * ‖(e.symm : (ι → ℝ) →L[ℝ] E)‖₊ ^ p := by\n    rw [h0C, inv_mul_cancel_right₀ (NNReal.rpow_pos hc).ne']\n  rw [h2c, ENNReal.smul_def, lintegral_smul_measure, lintegral_smul_measure]\n  let v : (ι → ℝ) → F := u ∘ e.symm\n  have hv : ContDiff ℝ 1 v := hu.comp e.symm.contDiff\n  have h2v : HasCompactSupport v := h2u.comp_homeomorph e.symm.toHomeomorph\n  have :=\n  calc ∫⁻ x, ‖u x‖ₑ ^ p ∂(volume : Measure (ι → ℝ)).map e.symm\n      = ∫⁻ y, ‖v y‖ₑ ^ p := by\n        refine lintegral_map ?_ e.symm.continuous.measurable\n        borelize F\n        exact hu.continuous.measurable.nnnorm.coe_nnreal_ennreal.pow_const _\n    _ ≤ (∫⁻ y, ‖fderiv ℝ v y‖ₑ) ^ p := lintegral_pow_le_pow_lintegral_fderiv_aux hp hv h2v\n    _ = (∫⁻ y, ‖(fderiv ℝ u (e.symm y)).comp (fderiv ℝ e.symm y)‖ₑ) ^ p := by\n        congr! with y\n        apply fderiv_comp _ (hu.differentiable le_rfl _)\n        exact e.symm.differentiableAt\n    _ ≤ (∫⁻ y, ‖fderiv ℝ u (e.symm y)‖ₑ * ‖(e.symm : (ι → ℝ) →L[ℝ] E)‖ₑ) ^ p := by\n        gcongr with y\n        rw [e.symm.fderiv]\n        apply ContinuousLinearMap.opENorm_comp_le\n    _ = (‖(e.symm : (ι → ℝ) →L[ℝ] E)‖ₑ * ∫⁻ y, ‖fderiv ℝ u (e.symm y)‖ₑ) ^ p := by\n        rw [lintegral_mul_const, mul_comm]\n        refine (Continuous.nnnorm ?_).measurable.coe_nnreal_ennreal\n        exact (hu.continuous_fderiv le_rfl).comp e.symm.continuous\n    _ = (‖(e.symm : (ι → ℝ) →L[ℝ] E)‖₊ ^ p : ℝ≥0) * (∫⁻ y, ‖fderiv ℝ u (e.symm y)‖ₑ) ^ p := by\n        rw [ENNReal.mul_rpow_of_nonneg _ _ h0p, enorm_eq_nnnorm, ← ENNReal.coe_rpow_of_nonneg _ h0p]\n    _ = (‖(e.symm : (ι → ℝ) →L[ℝ] E)‖₊ ^ p : ℝ≥0)\n        * (∫⁻ x, ‖fderiv ℝ u x‖ₑ ∂(volume : Measure (ι → ℝ)).map e.symm) ^ p := by\n        congr\n        rw [lintegral_map _ e.symm.continuous.measurable]\n        have : Continuous (fderiv ℝ u) := hu.continuous_fderiv le_rfl\n        fun_prop\n  rw [← ENNReal.mul_le_mul_left h3c ENNReal.coe_ne_top, ← mul_assoc, ← ENNReal.coe_mul, ← hC,\n    ENNReal.coe_mul] at this\n  rw [ENNReal.mul_rpow_of_nonneg _ _ h0p, ← mul_assoc, ← ENNReal.coe_rpow_of_ne_zero hc.ne']\n  exact this\n\n"}
{"name":"MeasureTheory.eLpNormLESNormFDerivOneConst_def","module":"Mathlib.Analysis.FunctionalSpaces.SobolevInequality","initialProofState":"E : Type u_5\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace Real E\ninst✝³ : MeasurableSpace E\ninst✝² : BorelSpace E\ninst✝¹ : FiniteDimensional Real E\nμ : MeasureTheory.Measure E\ninst✝ : μ.IsAddHaarMeasure\np : Real\n⊢ Eq (MeasureTheory.eLpNormLESNormFDerivOneConst μ p) (HPow.hPow (MeasureTheory.lintegralPowLePowLIntegralFDerivConst μ p) (Inv.inv p))","decl":"/-- The constant factor occurring in the conclusion of `eLpNorm_le_eLpNorm_fderiv_one`.\nIt only depends on `E`, `μ` and `p`. -/\nirreducible_def eLpNormLESNormFDerivOneConst (p : ℝ) : ℝ≥0 :=\n  lintegralPowLePowLIntegralFDerivConst μ p ^ p⁻¹\n\n"}
{"name":"MeasureTheory.eLpNorm_le_eLpNorm_fderiv_one","module":"Mathlib.Analysis.FunctionalSpaces.SobolevInequality","initialProofState":"F : Type u_3\ninst✝⁷ : NormedAddCommGroup F\ninst✝⁶ : NormedSpace Real F\nE : Type u_4\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace Real E\ninst✝³ : MeasurableSpace E\ninst✝² : BorelSpace E\ninst✝¹ : FiniteDimensional Real E\nμ : MeasureTheory.Measure E\ninst✝ : μ.IsAddHaarMeasure\nu : E → F\nhu : ContDiff Real 1 u\nh2u : HasCompactSupport u\np : NNReal\nhp : (↑(Module.finrank Real E)).IsConjExponent p\n⊢ LE.le (MeasureTheory.eLpNorm u (↑p) μ) (HMul.hMul (↑(MeasureTheory.eLpNormLESNormFDerivOneConst μ ↑p)) (MeasureTheory.eLpNorm (fderiv Real u) 1 μ))","decl":"/-- The **Gagliardo-Nirenberg-Sobolev inequality**.  Let `u` be a continuously differentiable\ncompactly-supported function `u` on a normed space `E` of finite dimension `n ≥ 2`, equipped\nwith Haar measure. Then the `Lᵖ` norm of `u`, where `p := n / (n - 1)`, is bounded above by\na constant times the `L¹` norm of the Fréchet derivative of `u`. -/\ntheorem eLpNorm_le_eLpNorm_fderiv_one  {u : E → F} (hu : ContDiff ℝ 1 u) (h2u : HasCompactSupport u)\n    {p : ℝ≥0} (hp : NNReal.IsConjExponent (finrank ℝ E) p) :\n    eLpNorm u p μ ≤ eLpNormLESNormFDerivOneConst μ p * eLpNorm (fderiv ℝ u) 1 μ := by\n  have h0p : 0 < (p : ℝ) := hp.coe.symm.pos\n  rw [eLpNorm_one_eq_lintegral_enorm,\n    ← ENNReal.rpow_le_rpow_iff h0p, ENNReal.mul_rpow_of_nonneg _ _ h0p.le,\n    ← ENNReal.coe_rpow_of_nonneg _ h0p.le, eLpNormLESNormFDerivOneConst, ← NNReal.rpow_mul,\n    eLpNorm_nnreal_pow_eq_lintegral hp.symm.pos.ne',\n    inv_mul_cancel₀ h0p.ne', NNReal.rpow_one]\n  exact lintegral_pow_le_pow_lintegral_fderiv μ hu h2u hp.coe\n\n"}
{"name":"MeasureTheory.eLpNorm_le_eLpNorm_fderiv_of_eq_inner","module":"Mathlib.Analysis.FunctionalSpaces.SobolevInequality","initialProofState":"E : Type u_4\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : NormedSpace Real E\ninst✝⁶ : MeasurableSpace E\ninst✝⁵ : BorelSpace E\ninst✝⁴ : FiniteDimensional Real E\nμ : MeasureTheory.Measure E\ninst✝³ : μ.IsAddHaarMeasure\nF' : Type u_5\ninst✝² : NormedAddCommGroup F'\ninst✝¹ : InnerProductSpace Real F'\ninst✝ : CompleteSpace F'\nu : E → F'\nhu : ContDiff Real 1 u\nh2u : HasCompactSupport u\np p' : NNReal\nhp : LE.le 1 p\nhn : LT.lt 0 (Module.finrank Real E)\nhp' : Eq (Inv.inv ↑p') (HSub.hSub (↑(Inv.inv p)) (Inv.inv ↑(Module.finrank Real E)))\n⊢ LE.le (MeasureTheory.eLpNorm u (↑p') μ) (HMul.hMul (↑(MeasureTheory.eLpNormLESNormFDerivOfEqInnerConst μ ↑p)) (MeasureTheory.eLpNorm (fderiv Real u) (↑p) μ))","decl":"/-- The **Gagliardo-Nirenberg-Sobolev inequality**.  Let `u` be a continuously differentiable\ncompactly-supported function `u` on a normed space `E` of finite dimension `n`, equipped\nwith Haar measure, let `1 ≤ p < n` and let `p'⁻¹ := p⁻¹ - n⁻¹`.\nThen the `Lᵖ'` norm of `u` is bounded above by a constant times the `Lᵖ` norm of\nthe Fréchet derivative of `u`.\n\nNote: The codomain of `u` needs to be a Hilbert space.\n-/\ntheorem eLpNorm_le_eLpNorm_fderiv_of_eq_inner  {u : E → F'}\n    (hu : ContDiff ℝ 1 u) (h2u : HasCompactSupport u)\n    {p p' : ℝ≥0} (hp : 1 ≤ p) (hn : 0 < finrank ℝ E)\n    (hp' : (p' : ℝ)⁻¹ = p⁻¹ - (finrank ℝ E : ℝ)⁻¹) :\n    eLpNorm u p' μ ≤ eLpNormLESNormFDerivOfEqInnerConst μ p * eLpNorm (fderiv ℝ u) p μ := by\n  /- Here we derive the GNS-inequality for `p ≥ 1` from the version with `p = 1`.\n  For `p > 1` we apply the previous version to the function `|u|^γ` for a suitably chosen `γ`.\n  The proof requires that `x ↦ |x|^p` is smooth in the codomain, so we require that it is a\n  Hilbert space. -/\n  by_cases hp'0 : p' = 0\n  · simp [hp'0]\n  set n := finrank ℝ E\n  let n' := NNReal.conjExponent n\n  have h2p : (p : ℝ) < n := by\n    have : 0 < p⁻¹ - (n : ℝ)⁻¹ :=\n      NNReal.coe_lt_coe.mpr (pos_iff_ne_zero.mpr (inv_ne_zero hp'0)) |>.trans_eq hp'\n    rwa [NNReal.coe_inv, sub_pos,\n      inv_lt_inv₀ _ (zero_lt_one.trans_le (NNReal.coe_le_coe.mpr hp))] at this\n    exact_mod_cast hn\n  have h0n : 2 ≤ n := Nat.succ_le_of_lt <| Nat.one_lt_cast.mp <| hp.trans_lt h2p\n  have hn : NNReal.IsConjExponent n n' := .conjExponent (by norm_cast)\n  have h1n : 1 ≤ (n : ℝ≥0) := hn.one_le\n  have h2n : (0 : ℝ) < n - 1 := by simp_rw [sub_pos]; exact hn.coe.one_lt\n  have hnp : (0 : ℝ) < n - p := by simp_rw [sub_pos]; exact h2p\n  rcases hp.eq_or_lt with rfl|hp\n  -- the case `p = 1`\n  · convert eLpNorm_le_eLpNorm_fderiv_one μ hu h2u hn using 2\n    · suffices (p' : ℝ) = n' by simpa using this\n      rw [← inv_inj, hp']\n      field_simp [n', NNReal.conjExponent]\n    · norm_cast\n      simp_rw [n', n, eLpNormLESNormFDerivOfEqInnerConst]\n      field_simp\n  -- the case `p > 1`\n  let q := Real.conjExponent p\n  have hq : Real.IsConjExponent p q := .conjExponent hp\n  have h0p : p ≠ 0 := zero_lt_one.trans hp |>.ne'\n  have h1p : (p : ℝ) ≠ 1 := hq.one_lt.ne'\n  have h3p : (p : ℝ) - 1 ≠ 0 := sub_ne_zero_of_ne h1p\n  have h0p' : p' ≠ 0 := by\n    suffices 0 < (p' : ℝ) from (show 0 < p' from this) |>.ne'\n    rw [← inv_pos, hp', sub_pos]\n    exact inv_strictAnti₀ hq.pos h2p\n  have h2q : 1 / n' - 1 / q = 1 / p' := by\n    simp_rw (config := {zeta := false}) [one_div, hp']\n    rw [← hq.one_sub_inv, ← hn.coe.one_sub_inv, sub_sub_sub_cancel_left]\n    simp only [NNReal.coe_natCast, NNReal.coe_inv]\n  let γ : ℝ≥0 := ⟨p * (n - 1) / (n - p), by positivity⟩\n  have h0γ : (γ : ℝ) = p * (n - 1) / (n - p) := rfl\n  have h1γ : 1 < (γ : ℝ) := by\n    rwa [h0γ, one_lt_div hnp, mul_sub, mul_one, sub_lt_sub_iff_right, lt_mul_iff_one_lt_left]\n    exact hn.coe.pos\n  have h2γ : γ * n' = p' := by\n    rw [← NNReal.coe_inj, ← inv_inj, hp', NNReal.coe_mul, h0γ, hn.coe.conj_eq]\n    field_simp; ring\n  have h3γ : (γ - 1) * q = p' := by\n    rw [← inv_inj, hp', h0γ, hq.conj_eq]\n    have : (p : ℝ) * (n - 1) - (n - p) = n * (p - 1) := by ring\n    field_simp [this]; ring\n  have h4γ : (γ : ℝ) ≠ 0 := (zero_lt_one.trans h1γ).ne'\n  by_cases h3u : ∫⁻ x, ‖u x‖ₑ ^ (p' : ℝ) ∂μ = 0\n  · rw [eLpNorm_nnreal_eq_lintegral h0p', h3u, ENNReal.zero_rpow_of_pos] <;> positivity\n  have h4u : ∫⁻ x, ‖u x‖ₑ ^ (p' : ℝ) ∂μ ≠ ∞ := by\n    refine lintegral_rpow_enorm_lt_top_of_eLpNorm'_lt_top\n      ((NNReal.coe_pos.trans pos_iff_ne_zero).mpr h0p') ?_ |>.ne\n    rw [← eLpNorm_nnreal_eq_eLpNorm' h0p']\n    exact hu.continuous.memℒp_of_hasCompactSupport (μ := μ) h2u |>.eLpNorm_lt_top\n  have h5u : (∫⁻ x, ‖u x‖ₑ ^ (p' : ℝ) ∂μ) ^ (1 / q) ≠ 0 :=\n    ENNReal.rpow_pos (pos_iff_ne_zero.mpr h3u) h4u |>.ne'\n  have h6u : (∫⁻ x, ‖u x‖ₑ ^ (p' : ℝ) ∂μ) ^ (1 / q) ≠ ∞ :=\n    ENNReal.rpow_ne_top_of_nonneg (div_nonneg zero_le_one hq.symm.nonneg) h4u\n  have h7u := hu.continuous -- for fun_prop\n  have h8u := (hu.fderiv_right (m := 0) le_rfl).continuous -- for fun_prop\n  let v : E → ℝ := fun x ↦ ‖u x‖ ^ (γ : ℝ)\n  have hv : ContDiff ℝ 1 v := hu.norm_rpow h1γ\n  have h2v : HasCompactSupport v := h2u.norm.rpow_const h4γ\n  set C := eLpNormLESNormFDerivOneConst μ n'\n  have :=\n  calc (∫⁻ x, ‖u x‖ₑ ^ (p' : ℝ) ∂μ) ^ (1 / (n' : ℝ)) = eLpNorm v n' μ := by\n        rw [← h2γ, eLpNorm_nnreal_eq_lintegral hn.symm.pos.ne']\n        simp (discharger := positivity) [v, Real.enorm_rpow_of_nonneg, ENNReal.rpow_mul,\n          ← ENNReal.coe_rpow_of_nonneg]\n    _ ≤ C * eLpNorm (fderiv ℝ v) 1 μ := eLpNorm_le_eLpNorm_fderiv_one μ hv h2v hn\n    _ = C * ∫⁻ x, ‖fderiv ℝ v x‖ₑ ∂μ := by rw [eLpNorm_one_eq_lintegral_enorm]\n    _ ≤ C * γ * ∫⁻ x, ‖u x‖ₑ ^ ((γ : ℝ) - 1) * ‖fderiv ℝ u x‖ₑ ∂μ := by\n      rw [mul_assoc, ← lintegral_const_mul γ]\n      gcongr\n      simp_rw [← mul_assoc]\n      exact enorm_fderiv_norm_rpow_le (hu.differentiable le_rfl) h1γ\n      dsimp [enorm]\n      fun_prop\n    _ ≤ C * γ * ((∫⁻ x, ‖u x‖ₑ ^ (p' : ℝ) ∂μ) ^ (1 / q) *\n        (∫⁻ x, ‖fderiv ℝ u x‖ₑ ^ (p : ℝ) ∂μ) ^ (1 / (p : ℝ))) := by\n        gcongr\n        convert ENNReal.lintegral_mul_le_Lp_mul_Lq μ\n          (.symm <| .conjExponent <| show 1 < (p : ℝ) from hp) ?_ ?_ using 5\n        · simp [γ, n, q, ← ENNReal.rpow_mul, ← h3γ]\n        · borelize F'\n          fun_prop\n        · fun_prop\n    _ = C * γ * (∫⁻ x, ‖fderiv ℝ u x‖ₑ ^ (p : ℝ) ∂μ) ^ (1 / (p : ℝ)) *\n      (∫⁻ x, ‖u x‖ₑ ^ (p' : ℝ) ∂μ) ^ (1 / q) := by ring\n  calc\n    eLpNorm u p' μ\n      = (∫⁻ x, ‖u x‖ₑ ^ (p' : ℝ) ∂μ) ^ (1 / (p' : ℝ)) := eLpNorm_nnreal_eq_lintegral h0p'\n    _ ≤ C * γ * (∫⁻ x, ‖fderiv ℝ u x‖ₑ ^ (p : ℝ) ∂μ) ^ (1 / (p : ℝ)) := by\n      rwa [← h2q, ENNReal.rpow_sub _ _ h3u h4u, ENNReal.div_le_iff h5u h6u]\n    _ = eLpNormLESNormFDerivOfEqInnerConst μ p *  eLpNorm (fderiv ℝ u) (↑p) μ := by\n      suffices (C : ℝ) * γ = eLpNormLESNormFDerivOfEqInnerConst μ p by\n        rw [eLpNorm_nnreal_eq_lintegral h0p]\n        congr\n        norm_cast at this ⊢\n      simp_rw [eLpNormLESNormFDerivOfEqInnerConst, γ]\n      refold_let n n' C\n      rw [NNReal.coe_mul, NNReal.coe_mk, Real.coe_toNNReal', mul_eq_mul_left_iff, eq_comm,\n        max_eq_left_iff]\n      left\n      positivity\n\n"}
{"name":"MeasureTheory.SNormLESNormFDerivOfEqConst_def","module":"Mathlib.Analysis.FunctionalSpaces.SobolevInequality","initialProofState":"F : Type u_6\ninst✝⁸ : NormedAddCommGroup F\ninst✝⁷ : NormedSpace Real F\nE : Type u_7\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : NormedSpace Real E\ninst✝⁴ : MeasurableSpace E\ninst✝³ : BorelSpace E\ninst✝² : FiniteDimensional Real E\nμ : MeasureTheory.Measure E\ninst✝¹ : μ.IsAddHaarMeasure\ninst✝ : FiniteDimensional Real F\np : Real\n⊢ Eq (MeasureTheory.SNormLESNormFDerivOfEqConst F μ p)\n    (let F' := EuclideanSpace Real (Fin (Module.finrank Real F));\n    let e := toEuclidean;\n    HMul.hMul (HMul.hMul (NNNorm.nnnorm ↑e.symm) (MeasureTheory.eLpNormLESNormFDerivOfEqInnerConst μ p)) (NNNorm.nnnorm ↑e))","decl":"variable (F) in\n/-- The constant factor occurring in the conclusion of `eLpNorm_le_eLpNorm_fderiv_of_eq`.\nIt only depends on `E`, `F`, `μ` and `p`. -/\nirreducible_def SNormLESNormFDerivOfEqConst [FiniteDimensional ℝ F] (p : ℝ) : ℝ≥0 :=\n  let F' := EuclideanSpace ℝ <| Fin <| finrank ℝ F\n  let e : F ≃L[ℝ] F' := toEuclidean\n  ‖(e.symm : F' →L[ℝ] F)‖₊ * eLpNormLESNormFDerivOfEqInnerConst μ p * ‖(e : F →L[ℝ] F')‖₊\n\n"}
{"name":"MeasureTheory.eLpNorm_le_eLpNorm_fderiv_of_eq","module":"Mathlib.Analysis.FunctionalSpaces.SobolevInequality","initialProofState":"F : Type u_3\ninst✝⁸ : NormedAddCommGroup F\ninst✝⁷ : NormedSpace Real F\nE : Type u_4\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : NormedSpace Real E\ninst✝⁴ : MeasurableSpace E\ninst✝³ : BorelSpace E\ninst✝² : FiniteDimensional Real E\nμ : MeasureTheory.Measure E\ninst✝¹ : μ.IsAddHaarMeasure\ninst✝ : FiniteDimensional Real F\nu : E → F\nhu : ContDiff Real 1 u\nh2u : HasCompactSupport u\np p' : NNReal\nhp : LE.le 1 p\nhn : LT.lt 0 (Module.finrank Real E)\nhp' : Eq (Inv.inv ↑p') (HSub.hSub (↑(Inv.inv p)) (Inv.inv ↑(Module.finrank Real E)))\n⊢ LE.le (MeasureTheory.eLpNorm u (↑p') μ) (HMul.hMul (↑(MeasureTheory.SNormLESNormFDerivOfEqConst F μ ↑p)) (MeasureTheory.eLpNorm (fderiv Real u) (↑p) μ))","decl":"/-- The **Gagliardo-Nirenberg-Sobolev inequality**.  Let `u` be a continuously differentiable\ncompactly-supported function `u` on a normed space `E` of finite dimension `n`, equipped\nwith Haar measure, let `1 < p < n` and let `p'⁻¹ := p⁻¹ - n⁻¹`.\nThen the `Lᵖ'` norm of `u` is bounded above by a constant times the `Lᵖ` norm of\nthe Fréchet derivative of `u`.\n\nThis is the version where the codomain of `u` is a finite dimensional normed space.\n-/\ntheorem eLpNorm_le_eLpNorm_fderiv_of_eq [FiniteDimensional ℝ F]\n    {u : E → F} (hu : ContDiff ℝ 1 u) (h2u : HasCompactSupport u)\n    {p p' : ℝ≥0} (hp : 1 ≤ p) (hn : 0 < finrank ℝ E)\n    (hp' : (p' : ℝ)⁻¹ = p⁻¹ - (finrank ℝ E : ℝ)⁻¹) :\n    eLpNorm u p' μ ≤ SNormLESNormFDerivOfEqConst F μ p * eLpNorm (fderiv ℝ u) p μ := by\n  /- Here we reduce the GNS-inequality with a Hilbert space as codomain to the case with a\n  finite-dimensional normed space as codomain, by transferring the result along the equivalence\n  `F ≃ ℝᵐ`. -/\n  let F' := EuclideanSpace ℝ <| Fin <| finrank ℝ F\n  let e : F ≃L[ℝ] F' := toEuclidean\n  let C₁ : ℝ≥0 := ‖(e.symm : F' →L[ℝ] F)‖₊\n  let C : ℝ≥0 := eLpNormLESNormFDerivOfEqInnerConst μ p\n  let C₂ : ℝ≥0 := ‖(e : F →L[ℝ] F')‖₊\n  let v := e ∘ u\n  have hv : ContDiff ℝ 1 v := e.contDiff.comp hu\n  have h2v : HasCompactSupport v := h2u.comp_left e.map_zero\n  have := eLpNorm_le_eLpNorm_fderiv_of_eq_inner μ hv h2v hp hn hp'\n  have h4v : ∀ x, ‖fderiv ℝ v x‖ ≤ C₂ * ‖fderiv ℝ u x‖ := fun x ↦ calc\n    ‖fderiv ℝ v x‖\n      = ‖(fderiv ℝ e (u x)).comp (fderiv ℝ u x)‖ := by\n      rw [fderiv_comp x e.differentiableAt (hu.differentiable le_rfl x)]\n    _ ≤ ‖fderiv ℝ e (u x)‖ * ‖fderiv ℝ u x‖ :=\n      (fderiv ℝ e (u x)).opNorm_comp_le (fderiv ℝ u x)\n    _ = C₂ * ‖fderiv ℝ u x‖ := by simp_rw [e.fderiv, C₂, coe_nnnorm]\n  calc eLpNorm u p' μ\n      = eLpNorm (e.symm ∘ v) p' μ := by simp_rw [v, Function.comp_def, e.symm_apply_apply]\n    _ ≤ C₁ • eLpNorm v p' μ := by\n      apply eLpNorm_le_nnreal_smul_eLpNorm_of_ae_le_mul\n      exact Eventually.of_forall (fun x ↦ (e.symm : F' →L[ℝ] F).le_opNNNorm _)\n    _ = C₁ * eLpNorm v p' μ := rfl\n    _ ≤ C₁ * C * eLpNorm (fderiv ℝ v) p μ := by rw [mul_assoc]; gcongr\n    _ ≤ C₁ * C * (C₂ * eLpNorm (fderiv ℝ u) p μ) := by\n      gcongr; exact eLpNorm_le_nnreal_smul_eLpNorm_of_ae_le_mul (Eventually.of_forall h4v) p\n    _ = SNormLESNormFDerivOfEqConst F μ p * eLpNorm (fderiv ℝ u) p μ := by\n      simp_rw [C₂, C₁, C, e, SNormLESNormFDerivOfEqConst]\n      push_cast\n      simp_rw [mul_assoc]\n\n\n"}
{"name":"MeasureTheory.eLpNormLESNormFDerivOfLeConst_def","module":"Mathlib.Analysis.FunctionalSpaces.SobolevInequality","initialProofState":"F : Type u_6\ninst✝⁸ : NormedAddCommGroup F\ninst✝⁷ : NormedSpace Real F\nE : Type u_7\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : NormedSpace Real E\ninst✝⁴ : MeasurableSpace E\ninst✝³ : BorelSpace E\ninst✝² : FiniteDimensional Real E\nμ : MeasureTheory.Measure E\ninst✝¹ : μ.IsAddHaarMeasure\ninst✝ : FiniteDimensional Real F\ns : Set E\np q : NNReal\n⊢ Eq (MeasureTheory.eLpNormLESNormFDerivOfLeConst F μ s p q)\n    (let p' := Inv.inv (HSub.hSub (Inv.inv p) (Inv.inv ↑(Module.finrank Real E)));\n    HMul.hMul (HPow.hPow (μ s).toNNReal (HSub.hSub (HDiv.hDiv 1 ↑q) (HDiv.hDiv 1 ↑p'))) (MeasureTheory.SNormLESNormFDerivOfEqConst F μ ↑p))","decl":"variable (F) in\n/-- The constant factor occurring in the conclusion of `eLpNorm_le_eLpNorm_fderiv_of_le`.\nIt only depends on `F`, `μ`, `s`, `p` and `q`. -/\nirreducible_def eLpNormLESNormFDerivOfLeConst [FiniteDimensional ℝ F] (s : Set E) (p q : ℝ≥0) :\n    ℝ≥0 :=\n  let p' : ℝ≥0 := (p⁻¹ - (finrank ℝ E : ℝ≥0)⁻¹)⁻¹\n  (μ s).toNNReal ^ (1 / q - 1 / p' : ℝ) * SNormLESNormFDerivOfEqConst F μ p\n\n\n"}
{"name":"MeasureTheory.eLpNorm_le_eLpNorm_fderiv_of_le","module":"Mathlib.Analysis.FunctionalSpaces.SobolevInequality","initialProofState":"F : Type u_3\ninst✝⁸ : NormedAddCommGroup F\ninst✝⁷ : NormedSpace Real F\nE : Type u_4\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : NormedSpace Real E\ninst✝⁴ : MeasurableSpace E\ninst✝³ : BorelSpace E\ninst✝² : FiniteDimensional Real E\nμ : MeasureTheory.Measure E\ninst✝¹ : μ.IsAddHaarMeasure\ninst✝ : FiniteDimensional Real F\nu : E → F\ns : Set E\nhu : ContDiff Real 1 u\nh2u : HasSubset.Subset (Function.support u) s\np q : NNReal\nhp : LE.le 1 p\nh2p : LT.lt p ↑(Module.finrank Real E)\nhpq : LE.le (HSub.hSub (↑(Inv.inv p)) (Inv.inv ↑(Module.finrank Real E))) (Inv.inv ↑q)\nhs : Bornology.IsBounded s\n⊢ LE.le (MeasureTheory.eLpNorm u (↑q) μ) (HMul.hMul (↑(MeasureTheory.eLpNormLESNormFDerivOfLeConst F μ s p q)) (MeasureTheory.eLpNorm (fderiv Real u) (↑p) μ))","decl":"/-- The **Gagliardo-Nirenberg-Sobolev inequality**.  Let `u` be a continuously differentiable\nfunction `u` supported in a bounded set `s` in a normed space `E` of finite dimension\n`n`, equipped with Haar measure, and let `1 < p < n` and `0 < q ≤ (p⁻¹ - (finrank ℝ E : ℝ)⁻¹)⁻¹`.\nThen the `L^q` norm of `u` is bounded above by a constant times the `Lᵖ` norm of\nthe Fréchet derivative of `u`.\n\nNote: The codomain of `u` needs to be a finite dimensional normed space.\n-/\ntheorem eLpNorm_le_eLpNorm_fderiv_of_le [FiniteDimensional ℝ F]\n    {u : E → F} {s : Set E} (hu : ContDiff ℝ 1 u) (h2u : u.support ⊆ s)\n    {p q : ℝ≥0} (hp : 1 ≤ p) (h2p : p < finrank ℝ E)\n    (hpq : p⁻¹ - (finrank ℝ E : ℝ)⁻¹ ≤ (q : ℝ)⁻¹)\n    (hs : Bornology.IsBounded s) :\n    eLpNorm u q μ ≤ eLpNormLESNormFDerivOfLeConst F μ s p q * eLpNorm (fderiv ℝ u) p μ := by\n  by_cases hq0 : q = 0\n  · simp [hq0]\n  let p' : ℝ≥0 := (p⁻¹ - (finrank ℝ E : ℝ≥0)⁻¹)⁻¹\n  have hp' : p'⁻¹ = p⁻¹ - (finrank ℝ E : ℝ)⁻¹ := by\n    rw [inv_inv, NNReal.coe_sub]\n    · simp\n    · #adaptation_note /-- nightly-2024-11-20\n      This should just be `gcongr`, but this is not working as of nightly-2024-11-20.\n      Possibly related to #19262 (since this proof fails at `with_reducible_and_instances`). -/\n      exact inv_anti₀ (by positivity) h2p.le\n  have : (q : ℝ≥0∞) ≤ p' := by\n    have H : (p' : ℝ)⁻¹ ≤ (↑q)⁻¹ := trans hp' hpq\n    norm_cast at H ⊢\n    rwa [inv_le_inv₀] at H\n    · dsimp\n      have : 0 < p⁻¹ - (finrank ℝ E : ℝ≥0)⁻¹ := by\n        simp only [tsub_pos_iff_lt]\n        #adaptation_note /-- nightly-2024-11-20\n        This should just be `gcongr`, but this is not working as of nightly-2024-11-20.\n        Possibly related to #19262 (since this proof fails at `with_reducible_and_instances`). -/\n        exact inv_strictAnti₀ (by positivity) h2p\n      positivity\n    · positivity\n  set t := (μ s).toNNReal ^ (1 / q - 1 / p' : ℝ)\n  let C := SNormLESNormFDerivOfEqConst F μ p\n  calc eLpNorm u q μ\n      = eLpNorm u q (μ.restrict s) := by rw [eLpNorm_restrict_eq_of_support_subset h2u]\n    _ ≤ eLpNorm u p' (μ.restrict s) * t := by\n        convert eLpNorm_le_eLpNorm_mul_rpow_measure_univ this hu.continuous.aestronglyMeasurable\n        rw [ENNReal.coe_rpow_of_nonneg]\n        · simp [ENNReal.coe_toNNReal hs.measure_lt_top.ne]\n        · rw [one_div, one_div]\n          norm_cast\n          rw [hp']\n          simpa using hpq\n    _ = eLpNorm u p' μ * t := by rw [eLpNorm_restrict_eq_of_support_subset h2u]\n    _ ≤ (C * eLpNorm (fderiv ℝ u) p μ) * t := by\n        have h2u' : HasCompactSupport u := by\n          apply HasCompactSupport.of_support_subset_isCompact hs.isCompact_closure\n          exact h2u.trans subset_closure\n        rel [eLpNorm_le_eLpNorm_fderiv_of_eq μ hu h2u' hp (mod_cast (zero_le p).trans_lt h2p) hp']\n    _ = eLpNormLESNormFDerivOfLeConst F μ s p q * eLpNorm (fderiv ℝ u) p μ := by\n      simp_rw [eLpNormLESNormFDerivOfLeConst, ENNReal.coe_mul]; ring\n\n"}
{"name":"MeasureTheory.eLpNorm_le_eLpNorm_fderiv","module":"Mathlib.Analysis.FunctionalSpaces.SobolevInequality","initialProofState":"F : Type u_3\ninst✝⁸ : NormedAddCommGroup F\ninst✝⁷ : NormedSpace Real F\nE : Type u_4\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : NormedSpace Real E\ninst✝⁴ : MeasurableSpace E\ninst✝³ : BorelSpace E\ninst✝² : FiniteDimensional Real E\nμ : MeasureTheory.Measure E\ninst✝¹ : μ.IsAddHaarMeasure\ninst✝ : FiniteDimensional Real F\nu : E → F\ns : Set E\nhu : ContDiff Real 1 u\nh2u : HasSubset.Subset (Function.support u) s\np : NNReal\nhp : LE.le 1 p\nh2p : LT.lt p ↑(Module.finrank Real E)\nhs : Bornology.IsBounded s\n⊢ LE.le (MeasureTheory.eLpNorm u (↑p) μ) (HMul.hMul (↑(MeasureTheory.eLpNormLESNormFDerivOfLeConst F μ s p p)) (MeasureTheory.eLpNorm (fderiv Real u) (↑p) μ))","decl":"/-- The **Gagliardo-Nirenberg-Sobolev inequality**.  Let `u` be a continuously differentiable\nfunction `u` supported in a bounded set `s` in a normed space `E` of finite dimension\n`n`, equipped with Haar measure, and let `1 < p < n`.\nThen the `Lᵖ` norm of `u` is bounded above by a constant times the `Lᵖ` norm of\nthe Fréchet derivative of `u`.\n\nNote: The codomain of `u` needs to be a finite dimensional normed space.\n-/\ntheorem eLpNorm_le_eLpNorm_fderiv [FiniteDimensional ℝ F]\n    {u : E → F} {s : Set E} (hu : ContDiff ℝ 1 u) (h2u : u.support ⊆ s)\n    {p : ℝ≥0} (hp : 1 ≤ p) (h2p : p < finrank ℝ E) (hs : Bornology.IsBounded s) :\n    eLpNorm u p μ ≤ eLpNormLESNormFDerivOfLeConst F μ s p p * eLpNorm (fderiv ℝ u) p μ := by\n  refine eLpNorm_le_eLpNorm_fderiv_of_le μ hu h2u hp h2p ?_ hs\n  norm_cast\n  simp only [tsub_le_iff_right, le_add_iff_nonneg_right]\n  positivity\n\n"}
