{"name":"SchwartzMap.mk.injEq","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"E : Type u_4\nF : Type u_5\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\ntoFun‚úù : E ‚Üí F\nsmooth'‚úù : ContDiff Real (‚ÜëTop.top) toFun‚úù\ndecay'‚úù : ‚àÄ (k n : Nat), Exists fun C => ‚àÄ (x : E), LE.le (HMul.hMul (HPow.hPow (Norm.norm x) k) (Norm.norm (iteratedFDeriv Real n toFun‚úù x))) C\ntoFun : E ‚Üí F\nsmooth' : ContDiff Real (‚ÜëTop.top) toFun\ndecay' : ‚àÄ (k n : Nat), Exists fun C => ‚àÄ (x : E), LE.le (HMul.hMul (HPow.hPow (Norm.norm x) k) (Norm.norm (iteratedFDeriv Real n toFun x))) C\n‚ä¢ Eq (Eq { toFun := toFun‚úù, smooth' := smooth'‚úù, decay' := decay'‚úù } { toFun := toFun, smooth' := smooth', decay' := decay' }) (Eq toFun‚úù toFun)","decl":"/-- A function is a Schwartz function if it is smooth and all derivatives decay faster than\n  any power of `‚Äñx‚Äñ`. -/\nstructure SchwartzMap where\n  toFun : E ‚Üí F\n  smooth' : ContDiff ‚Ñù ‚àû toFun\n  decay' : ‚àÄ k n : ‚Ñï, ‚àÉ C : ‚Ñù, ‚àÄ x, ‚Äñx‚Äñ ^ k * ‚ÄñiteratedFDeriv ‚Ñù n toFun x‚Äñ ‚â§ C\n\n"}
{"name":"SchwartzMap.mk.sizeOf_spec","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"E : Type u_4\nF : Type u_5\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedSpace Real E\ninst‚úù¬≥ : NormedAddCommGroup F\ninst‚úù¬≤ : NormedSpace Real F\ninst‚úù¬π : SizeOf E\ninst‚úù : SizeOf F\ntoFun : E ‚Üí F\nsmooth' : ContDiff Real (‚ÜëTop.top) toFun\ndecay' : ‚àÄ (k n : Nat), Exists fun C => ‚àÄ (x : E), LE.le (HMul.hMul (HPow.hPow (Norm.norm x) k) (Norm.norm (iteratedFDeriv Real n toFun x))) C\n‚ä¢ Eq (SizeOf.sizeOf { toFun := toFun, smooth' := smooth', decay' := decay' }) (HAdd.hAdd 1 (SizeOf.sizeOf smooth'))","decl":"/-- A function is a Schwartz function if it is smooth and all derivatives decay faster than\n  any power of `‚Äñx‚Äñ`. -/\nstructure SchwartzMap where\n  toFun : E ‚Üí F\n  smooth' : ContDiff ‚Ñù ‚àû toFun\n  decay' : ‚àÄ k n : ‚Ñï, ‚àÉ C : ‚Ñù, ‚àÄ x, ‚Äñx‚Äñ ^ k * ‚ÄñiteratedFDeriv ‚Ñù n toFun x‚Äñ ‚â§ C\n\n"}
{"name":"SchwartzMap.decay'","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"E : Type u_4\nF : Type u_5\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nself : SchwartzMap E F\nk n : Nat\n‚ä¢ Exists fun C => ‚àÄ (x : E), LE.le (HMul.hMul (HPow.hPow (Norm.norm x) k) (Norm.norm (iteratedFDeriv Real n self.toFun x))) C","decl":"/-- A function is a Schwartz function if it is smooth and all derivatives decay faster than\n  any power of `‚Äñx‚Äñ`. -/\nstructure SchwartzMap where\n  toFun : E ‚Üí F\n  smooth' : ContDiff ‚Ñù ‚àû toFun\n  decay' : ‚àÄ k n : ‚Ñï, ‚àÉ C : ‚Ñù, ‚àÄ x, ‚Äñx‚Äñ ^ k * ‚ÄñiteratedFDeriv ‚Ñù n toFun x‚Äñ ‚â§ C\n\n"}
{"name":"SchwartzMap.smooth'","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"E : Type u_4\nF : Type u_5\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nself : SchwartzMap E F\n‚ä¢ ContDiff Real (‚ÜëTop.top) self.toFun","decl":"/-- A function is a Schwartz function if it is smooth and all derivatives decay faster than\n  any power of `‚Äñx‚Äñ`. -/\nstructure SchwartzMap where\n  toFun : E ‚Üí F\n  smooth' : ContDiff ‚Ñù ‚àû toFun\n  decay' : ‚àÄ k n : ‚Ñï, ‚àÉ C : ‚Ñù, ‚àÄ x, ‚Äñx‚Äñ ^ k * ‚ÄñiteratedFDeriv ‚Ñù n toFun x‚Äñ ‚â§ C\n\n"}
{"name":"SchwartzMap.mk.inj","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"E : Type u_4\nF : Type u_5\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\ntoFun‚úù : E ‚Üí F\nsmooth'‚úù : ContDiff Real (‚ÜëTop.top) toFun‚úù\ndecay'‚úù : ‚àÄ (k n : Nat), Exists fun C => ‚àÄ (x : E), LE.le (HMul.hMul (HPow.hPow (Norm.norm x) k) (Norm.norm (iteratedFDeriv Real n toFun‚úù x))) C\ntoFun : E ‚Üí F\nsmooth' : ContDiff Real (‚ÜëTop.top) toFun\ndecay' : ‚àÄ (k n : Nat), Exists fun C => ‚àÄ (x : E), LE.le (HMul.hMul (HPow.hPow (Norm.norm x) k) (Norm.norm (iteratedFDeriv Real n toFun x))) C\nx‚úù : Eq { toFun := toFun‚úù, smooth' := smooth'‚úù, decay' := decay'‚úù } { toFun := toFun, smooth' := smooth', decay' := decay' }\n‚ä¢ Eq toFun‚úù toFun","decl":"/-- A function is a Schwartz function if it is smooth and all derivatives decay faster than\n  any power of `‚Äñx‚Äñ`. -/\nstructure SchwartzMap where\n  toFun : E ‚Üí F\n  smooth' : ContDiff ‚Ñù ‚àû toFun\n  decay' : ‚àÄ k n : ‚Ñï, ‚àÉ C : ‚Ñù, ‚àÄ x, ‚Äñx‚Äñ ^ k * ‚ÄñiteratedFDeriv ‚Ñù n toFun x‚Äñ ‚â§ C\n\n"}
{"name":"SchwartzMap.decay","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"E : Type u_4\nF : Type u_5\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nf : SchwartzMap E F\nk n : Nat\n‚ä¢ Exists fun C => And (LT.lt 0 C) (‚àÄ (x : E), LE.le (HMul.hMul (HPow.hPow (Norm.norm x) k) (Norm.norm (iteratedFDeriv Real n (‚áëf) x))) C)","decl":"/-- All derivatives of a Schwartz function are rapidly decaying. -/\ntheorem decay (f : ùì¢(E, F)) (k n : ‚Ñï) :\n    ‚àÉ C : ‚Ñù, 0 < C ‚àß ‚àÄ x, ‚Äñx‚Äñ ^ k * ‚ÄñiteratedFDeriv ‚Ñù n f x‚Äñ ‚â§ C := by\n  rcases f.decay' k n with ‚ü®C, hC‚ü©\n  exact ‚ü®max C 1, by positivity, fun x => (hC x).trans (le_max_left _ _)‚ü©\n\n"}
{"name":"SchwartzMap.smooth","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"E : Type u_4\nF : Type u_5\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nf : SchwartzMap E F\nn : ENat\n‚ä¢ ContDiff Real ‚Üën ‚áëf","decl":"/-- Every Schwartz function is smooth. -/\ntheorem smooth (f : ùì¢(E, F)) (n : ‚Ñï‚àû) : ContDiff ‚Ñù n f :=\n  f.smooth'.of_le (mod_cast le_top)\n\n"}
{"name":"SchwartzMap.continuous","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"E : Type u_4\nF : Type u_5\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nf : SchwartzMap E F\n‚ä¢ Continuous ‚áëf","decl":"/-- Every Schwartz function is continuous. -/\n@[continuity]\nprotected theorem continuous (f : ùì¢(E, F)) : Continuous f :=\n  (f.smooth 0).continuous\n\n"}
{"name":"SchwartzMap.instContinuousMapClass","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"E : Type u_4\nF : Type u_5\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\n‚ä¢ ContinuousMapClass (SchwartzMap E F) E F","decl":"instance instContinuousMapClass : ContinuousMapClass ùì¢(E, F) E F where\n  map_continuous := SchwartzMap.continuous\n\n"}
{"name":"SchwartzMap.differentiable","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"E : Type u_4\nF : Type u_5\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nf : SchwartzMap E F\n‚ä¢ Differentiable Real ‚áëf","decl":"/-- Every Schwartz function is differentiable. -/\nprotected theorem differentiable (f : ùì¢(E, F)) : Differentiable ‚Ñù f :=\n  (f.smooth 1).differentiable rfl.le\n\n"}
{"name":"SchwartzMap.differentiableAt","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"E : Type u_4\nF : Type u_5\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nf : SchwartzMap E F\nx : E\n‚ä¢ DifferentiableAt Real (‚áëf) x","decl":"/-- Every Schwartz function is differentiable at any point. -/\nprotected theorem differentiableAt (f : ùì¢(E, F)) {x : E} : DifferentiableAt ‚Ñù f x :=\n  f.differentiable.differentiableAt\n\n"}
{"name":"SchwartzMap.ext_iff","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"E : Type u_4\nF : Type u_5\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nf g : SchwartzMap E F\n‚ä¢ Iff (Eq f g) (‚àÄ (x : E), Eq (f x) (g x))","decl":"@[ext]\ntheorem ext {f g : ùì¢(E, F)} (h : ‚àÄ x, (f : E ‚Üí F) x = g x) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"SchwartzMap.ext","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"E : Type u_4\nF : Type u_5\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nf g : SchwartzMap E F\nh : ‚àÄ (x : E), Eq (f x) (g x)\n‚ä¢ Eq f g","decl":"@[ext]\ntheorem ext {f g : ùì¢(E, F)} (h : ‚àÄ x, (f : E ‚Üí F) x = g x) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"SchwartzMap.isBigO_cocompact_zpow_neg_nat","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"E : Type u_4\nF : Type u_5\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nf : SchwartzMap E F\nk : Nat\n‚ä¢ Asymptotics.IsBigO (Filter.cocompact E) ‚áëf fun x => HPow.hPow (Norm.norm x) (Neg.neg ‚Üëk)","decl":"/-- Auxiliary lemma, used in proving the more general result `isBigO_cocompact_rpow`. -/\ntheorem isBigO_cocompact_zpow_neg_nat (k : ‚Ñï) :\n    f =O[cocompact E] fun x => ‚Äñx‚Äñ ^ (-k : ‚Ñ§) := by\n  obtain ‚ü®d, _, hd'‚ü© := f.decay k 0\n  simp only [norm_iteratedFDeriv_zero] at hd'\n  simp_rw [Asymptotics.IsBigO, Asymptotics.IsBigOWith]\n  refine ‚ü®d, Filter.Eventually.filter_mono Filter.cocompact_le_cofinite ?_‚ü©\n  refine (Filter.eventually_cofinite_ne 0).mono fun x hx => ?_\n  rw [Real.norm_of_nonneg (zpow_nonneg (norm_nonneg _) _), zpow_neg, ‚Üê div_eq_mul_inv, le_div_iff‚ÇÄ']\n  exacts [hd' x, zpow_pos (norm_pos_iff.mpr hx) _]\n\n"}
{"name":"SchwartzMap.isBigO_cocompact_rpow","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"E : Type u_4\nF : Type u_5\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\nf : SchwartzMap E F\ninst‚úù : ProperSpace E\ns : Real\n‚ä¢ Asymptotics.IsBigO (Filter.cocompact E) ‚áëf fun x => HPow.hPow (Norm.norm x) s","decl":"theorem isBigO_cocompact_rpow [ProperSpace E] (s : ‚Ñù) :\n    f =O[cocompact E] fun x => ‚Äñx‚Äñ ^ s := by\n  let k := ‚åà-s‚åâ‚Çä\n  have hk : -(k : ‚Ñù) ‚â§ s := neg_le.mp (Nat.le_ceil (-s))\n  refine (isBigO_cocompact_zpow_neg_nat f k).trans ?_\n  suffices (fun x : ‚Ñù => x ^ (-k : ‚Ñ§)) =O[atTop] fun x : ‚Ñù => x ^ s\n    from this.comp_tendsto tendsto_norm_cocompact_atTop\n  simp_rw [Asymptotics.IsBigO, Asymptotics.IsBigOWith]\n  refine ‚ü®1, (Filter.eventually_ge_atTop 1).mono fun x hx => ?_‚ü©\n  rw [one_mul, Real.norm_of_nonneg (Real.rpow_nonneg (zero_le_one.trans hx) _),\n    Real.norm_of_nonneg (zpow_nonneg (zero_le_one.trans hx) _), ‚Üê Real.rpow_intCast, Int.cast_neg,\n    Int.cast_natCast]\n  exact Real.rpow_le_rpow_of_exponent_le hx hk\n\n"}
{"name":"SchwartzMap.isBigO_cocompact_zpow","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"E : Type u_4\nF : Type u_5\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\nf : SchwartzMap E F\ninst‚úù : ProperSpace E\nk : Int\n‚ä¢ Asymptotics.IsBigO (Filter.cocompact E) ‚áëf fun x => HPow.hPow (Norm.norm x) k","decl":"theorem isBigO_cocompact_zpow [ProperSpace E] (k : ‚Ñ§) :\n    f =O[cocompact E] fun x => ‚Äñx‚Äñ ^ k := by\n  simpa only [Real.rpow_intCast] using isBigO_cocompact_rpow f k\n\n"}
{"name":"SchwartzMap.bounds_nonempty","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"E : Type u_4\nF : Type u_5\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nk n : Nat\nf : SchwartzMap E F\n‚ä¢ Exists fun c => Membership.mem (setOf fun c => And (LE.le 0 c) (‚àÄ (x : E), LE.le (HMul.hMul (HPow.hPow (Norm.norm x) k) (Norm.norm (iteratedFDeriv Real n (‚áëf) x))) c)) c","decl":"theorem bounds_nonempty (k n : ‚Ñï) (f : ùì¢(E, F)) :\n    ‚àÉ c : ‚Ñù, c ‚àà { c : ‚Ñù | 0 ‚â§ c ‚àß ‚àÄ x : E, ‚Äñx‚Äñ ^ k * ‚ÄñiteratedFDeriv ‚Ñù n f x‚Äñ ‚â§ c } :=\n  let ‚ü®M, hMp, hMb‚ü© := f.decay k n\n  ‚ü®M, le_of_lt hMp, hMb‚ü©\n\n"}
{"name":"SchwartzMap.bounds_bddBelow","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"E : Type u_4\nF : Type u_5\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nk n : Nat\nf : SchwartzMap E F\n‚ä¢ BddBelow (setOf fun c => And (LE.le 0 c) (‚àÄ (x : E), LE.le (HMul.hMul (HPow.hPow (Norm.norm x) k) (Norm.norm (iteratedFDeriv Real n (‚áëf) x))) c))","decl":"theorem bounds_bddBelow (k n : ‚Ñï) (f : ùì¢(E, F)) :\n    BddBelow { c | 0 ‚â§ c ‚àß ‚àÄ x, ‚Äñx‚Äñ ^ k * ‚ÄñiteratedFDeriv ‚Ñù n f x‚Äñ ‚â§ c } :=\n  ‚ü®0, fun _ ‚ü®hn, _‚ü© => hn‚ü©\n\n"}
{"name":"SchwartzMap.decay_add_le_aux","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"E : Type u_4\nF : Type u_5\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nk n : Nat\nf g : SchwartzMap E F\nx : E\n‚ä¢ LE.le (HMul.hMul (HPow.hPow (Norm.norm x) k) (Norm.norm (iteratedFDeriv Real n (HAdd.hAdd ‚áëf ‚áëg) x))) (HAdd.hAdd (HMul.hMul (HPow.hPow (Norm.norm x) k) (Norm.norm (iteratedFDeriv Real n (‚áëf) x))) (HMul.hMul (HPow.hPow (Norm.norm x) k) (Norm.norm (iteratedFDeriv Real n (‚áëg) x))))","decl":"theorem decay_add_le_aux (k n : ‚Ñï) (f g : ùì¢(E, F)) (x : E) :\n    ‚Äñx‚Äñ ^ k * ‚ÄñiteratedFDeriv ‚Ñù n ((f : E ‚Üí F) + (g : E ‚Üí F)) x‚Äñ ‚â§\n      ‚Äñx‚Äñ ^ k * ‚ÄñiteratedFDeriv ‚Ñù n f x‚Äñ + ‚Äñx‚Äñ ^ k * ‚ÄñiteratedFDeriv ‚Ñù n g x‚Äñ := by\n  rw [‚Üê mul_add]\n  refine mul_le_mul_of_nonneg_left ?_ (by positivity)\n  rw [iteratedFDeriv_add_apply (f.smooth _) (g.smooth _)]\n  exact norm_add_le _ _\n\n"}
{"name":"SchwartzMap.decay_neg_aux","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"E : Type u_4\nF : Type u_5\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nk n : Nat\nf : SchwartzMap E F\nx : E\n‚ä¢ Eq (HMul.hMul (HPow.hPow (Norm.norm x) k) (Norm.norm (iteratedFDeriv Real n (Neg.neg ‚áëf) x))) (HMul.hMul (HPow.hPow (Norm.norm x) k) (Norm.norm (iteratedFDeriv Real n (‚áëf) x)))","decl":"theorem decay_neg_aux (k n : ‚Ñï) (f : ùì¢(E, F)) (x : E) :\n    ‚Äñx‚Äñ ^ k * ‚ÄñiteratedFDeriv ‚Ñù n (-f : E ‚Üí F) x‚Äñ = ‚Äñx‚Äñ ^ k * ‚ÄñiteratedFDeriv ‚Ñù n f x‚Äñ := by\n  rw [iteratedFDeriv_neg_apply, norm_neg]\n\n"}
{"name":"SchwartzMap.decay_smul_aux","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"ùïú : Type u_1\nE : Type u_4\nF : Type u_5\ninst‚úù‚Å∂ : NormedAddCommGroup E\ninst‚úù‚Åµ : NormedSpace Real E\ninst‚úù‚Å¥ : NormedAddCommGroup F\ninst‚úù¬≥ : NormedSpace Real F\ninst‚úù¬≤ : NormedField ùïú\ninst‚úù¬π : NormedSpace ùïú F\ninst‚úù : SMulCommClass Real ùïú F\nk n : Nat\nf : SchwartzMap E F\nc : ùïú\nx : E\n‚ä¢ Eq (HMul.hMul (HPow.hPow (Norm.norm x) k) (Norm.norm (iteratedFDeriv Real n (HSMul.hSMul c ‚áëf) x))) (HMul.hMul (HMul.hMul (Norm.norm c) (HPow.hPow (Norm.norm x) k)) (Norm.norm (iteratedFDeriv Real n (‚áëf) x)))","decl":"theorem decay_smul_aux (k n : ‚Ñï) (f : ùì¢(E, F)) (c : ùïú) (x : E) :\n    ‚Äñx‚Äñ ^ k * ‚ÄñiteratedFDeriv ‚Ñù n (c ‚Ä¢ (f : E ‚Üí F)) x‚Äñ =\n      ‚Äñc‚Äñ * ‚Äñx‚Äñ ^ k * ‚ÄñiteratedFDeriv ‚Ñù n f x‚Äñ := by\n  rw [mul_comm ‚Äñc‚Äñ, mul_assoc, iteratedFDeriv_const_smul_apply (f.smooth _).contDiffAt,\n    norm_smul c (iteratedFDeriv ‚Ñù n (‚áëf) x)]\n\n"}
{"name":"SchwartzMap.seminormAux_nonneg","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"E : Type u_4\nF : Type u_5\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nk n : Nat\nf : SchwartzMap E F\n‚ä¢ LE.le 0 (SchwartzMap.seminormAux k n f)","decl":"theorem seminormAux_nonneg (k n : ‚Ñï) (f : ùì¢(E, F)) : 0 ‚â§ f.seminormAux k n :=\n  le_csInf (bounds_nonempty k n f) fun _ ‚ü®hx, _‚ü© => hx\n\n"}
{"name":"SchwartzMap.le_seminormAux","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"E : Type u_4\nF : Type u_5\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nk n : Nat\nf : SchwartzMap E F\nx : E\n‚ä¢ LE.le (HMul.hMul (HPow.hPow (Norm.norm x) k) (Norm.norm (iteratedFDeriv Real n (‚áëf) x))) (SchwartzMap.seminormAux k n f)","decl":"theorem le_seminormAux (k n : ‚Ñï) (f : ùì¢(E, F)) (x : E) :\n    ‚Äñx‚Äñ ^ k * ‚ÄñiteratedFDeriv ‚Ñù n (‚áëf) x‚Äñ ‚â§ f.seminormAux k n :=\n  le_csInf (bounds_nonempty k n f) fun _ ‚ü®_, h‚ü© => h x\n\n"}
{"name":"SchwartzMap.seminormAux_le_bound","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"E : Type u_4\nF : Type u_5\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nk n : Nat\nf : SchwartzMap E F\nM : Real\nhMp : LE.le 0 M\nhM : ‚àÄ (x : E), LE.le (HMul.hMul (HPow.hPow (Norm.norm x) k) (Norm.norm (iteratedFDeriv Real n (‚áëf) x))) M\n‚ä¢ LE.le (SchwartzMap.seminormAux k n f) M","decl":"/-- If one controls the norm of every `A x`, then one controls the norm of `A`. -/\ntheorem seminormAux_le_bound (k n : ‚Ñï) (f : ùì¢(E, F)) {M : ‚Ñù} (hMp : 0 ‚â§ M)\n    (hM : ‚àÄ x, ‚Äñx‚Äñ ^ k * ‚ÄñiteratedFDeriv ‚Ñù n f x‚Äñ ‚â§ M) : f.seminormAux k n ‚â§ M :=\n  csInf_le (bounds_bddBelow k n f) ‚ü®hMp, hM‚ü©\n\n"}
{"name":"SchwartzMap.smul_apply","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"ùïú : Type u_1\nE : Type u_4\nF : Type u_5\ninst‚úù‚Å∂ : NormedAddCommGroup E\ninst‚úù‚Åµ : NormedSpace Real E\ninst‚úù‚Å¥ : NormedAddCommGroup F\ninst‚úù¬≥ : NormedSpace Real F\ninst‚úù¬≤ : NormedField ùïú\ninst‚úù¬π : NormedSpace ùïú F\ninst‚úù : SMulCommClass Real ùïú F\nf : SchwartzMap E F\nc : ùïú\nx : E\n‚ä¢ Eq ((HSMul.hSMul c f) x) (HSMul.hSMul c (f x))","decl":"@[simp]\ntheorem smul_apply {f : ùì¢(E, F)} {c : ùïú} {x : E} : (c ‚Ä¢ f) x = c ‚Ä¢ f x :=\n  rfl\n\n"}
{"name":"SchwartzMap.instIsScalarTower","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"ùïú : Type u_1\nùïú' : Type u_2\nE : Type u_4\nF : Type u_5\ninst‚úù¬π¬π : NormedAddCommGroup E\ninst‚úù¬π‚Å∞ : NormedSpace Real E\ninst‚úù‚Åπ : NormedAddCommGroup F\ninst‚úù‚Å∏ : NormedSpace Real F\ninst‚úù‚Å∑ : NormedField ùïú\ninst‚úù‚Å∂ : NormedSpace ùïú F\ninst‚úù‚Åµ : SMulCommClass Real ùïú F\ninst‚úù‚Å¥ : NormedField ùïú'\ninst‚úù¬≥ : NormedSpace ùïú' F\ninst‚úù¬≤ : SMulCommClass Real ùïú' F\ninst‚úù¬π : SMul ùïú ùïú'\ninst‚úù : IsScalarTower ùïú ùïú' F\n‚ä¢ IsScalarTower ùïú ùïú' (SchwartzMap E F)","decl":"instance instIsScalarTower [SMul ùïú ùïú'] [IsScalarTower ùïú ùïú' F] : IsScalarTower ùïú ùïú' ùì¢(E, F) :=\n  ‚ü®fun a b f => ext fun x => smul_assoc a b (f x)‚ü©\n\n"}
{"name":"SchwartzMap.instSMulCommClass","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"ùïú : Type u_1\nùïú' : Type u_2\nE : Type u_4\nF : Type u_5\ninst‚úù¬π‚Å∞ : NormedAddCommGroup E\ninst‚úù‚Åπ : NormedSpace Real E\ninst‚úù‚Å∏ : NormedAddCommGroup F\ninst‚úù‚Å∑ : NormedSpace Real F\ninst‚úù‚Å∂ : NormedField ùïú\ninst‚úù‚Åµ : NormedSpace ùïú F\ninst‚úù‚Å¥ : SMulCommClass Real ùïú F\ninst‚úù¬≥ : NormedField ùïú'\ninst‚úù¬≤ : NormedSpace ùïú' F\ninst‚úù¬π : SMulCommClass Real ùïú' F\ninst‚úù : SMulCommClass ùïú ùïú' F\n‚ä¢ SMulCommClass ùïú ùïú' (SchwartzMap E F)","decl":"instance instSMulCommClass [SMulCommClass ùïú ùïú' F] : SMulCommClass ùïú ùïú' ùì¢(E, F) :=\n  ‚ü®fun a b f => ext fun x => smul_comm a b (f x)‚ü©\n\n"}
{"name":"SchwartzMap.seminormAux_smul_le","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"ùïú : Type u_1\nE : Type u_4\nF : Type u_5\ninst‚úù‚Å∂ : NormedAddCommGroup E\ninst‚úù‚Åµ : NormedSpace Real E\ninst‚úù‚Å¥ : NormedAddCommGroup F\ninst‚úù¬≥ : NormedSpace Real F\ninst‚úù¬≤ : NormedField ùïú\ninst‚úù¬π : NormedSpace ùïú F\ninst‚úù : SMulCommClass Real ùïú F\nk n : Nat\nc : ùïú\nf : SchwartzMap E F\n‚ä¢ LE.le (SchwartzMap.seminormAux k n (HSMul.hSMul c f)) (HMul.hMul (Norm.norm c) (SchwartzMap.seminormAux k n f))","decl":"theorem seminormAux_smul_le (k n : ‚Ñï) (c : ùïú) (f : ùì¢(E, F)) :\n    (c ‚Ä¢ f).seminormAux k n ‚â§ ‚Äñc‚Äñ * f.seminormAux k n := by\n  refine\n    (c ‚Ä¢ f).seminormAux_le_bound k n (mul_nonneg (norm_nonneg _) (seminormAux_nonneg _ _ _))\n      fun x => (decay_smul_aux k n f c x).le.trans ?_\n  rw [mul_assoc]\n  exact mul_le_mul_of_nonneg_left (f.le_seminormAux k n x) (norm_nonneg _)\n\n"}
{"name":"SchwartzMap.coe_zero","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"E : Type u_4\nF : Type u_5\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\n‚ä¢ Eq (‚áë0) 0","decl":"theorem coe_zero : DFunLike.coe (0 : ùì¢(E, F)) = (0 : E ‚Üí F) :=\n  rfl\n\n"}
{"name":"SchwartzMap.coeFn_zero","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"E : Type u_4\nF : Type u_5\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\n‚ä¢ Eq (‚áë0) 0","decl":"@[simp]\ntheorem coeFn_zero : ‚áë(0 : ùì¢(E, F)) = (0 : E ‚Üí F) :=\n  rfl\n\n"}
{"name":"SchwartzMap.zero_apply","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"E : Type u_4\nF : Type u_5\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nx : E\n‚ä¢ Eq (0 x) 0","decl":"@[simp]\ntheorem zero_apply {x : E} : (0 : ùì¢(E, F)) x = 0 :=\n  rfl\n\n"}
{"name":"SchwartzMap.seminormAux_zero","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"E : Type u_4\nF : Type u_5\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nk n : Nat\n‚ä¢ Eq (SchwartzMap.seminormAux k n 0) 0","decl":"theorem seminormAux_zero (k n : ‚Ñï) : (0 : ùì¢(E, F)).seminormAux k n = 0 :=\n  le_antisymm (seminormAux_le_bound k n _ rfl.le fun _ => by simp [Pi.zero_def])\n    (seminormAux_nonneg _ _ _)\n\n"}
{"name":"SchwartzMap.add_apply","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"E : Type u_4\nF : Type u_5\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nf g : SchwartzMap E F\nx : E\n‚ä¢ Eq ((HAdd.hAdd f g) x) (HAdd.hAdd (f x) (g x))","decl":"@[simp]\ntheorem add_apply {f g : ùì¢(E, F)} {x : E} : (f + g) x = f x + g x :=\n  rfl\n\n"}
{"name":"SchwartzMap.seminormAux_add_le","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"E : Type u_4\nF : Type u_5\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nk n : Nat\nf g : SchwartzMap E F\n‚ä¢ LE.le (SchwartzMap.seminormAux k n (HAdd.hAdd f g)) (HAdd.hAdd (SchwartzMap.seminormAux k n f) (SchwartzMap.seminormAux k n g))","decl":"theorem seminormAux_add_le (k n : ‚Ñï) (f g : ùì¢(E, F)) :\n    (f + g).seminormAux k n ‚â§ f.seminormAux k n + g.seminormAux k n :=\n  (f + g).seminormAux_le_bound k n\n    (add_nonneg (seminormAux_nonneg _ _ _) (seminormAux_nonneg _ _ _)) fun x =>\n    (decay_add_le_aux k n f g x).trans <|\n      add_le_add (f.le_seminormAux k n x) (g.le_seminormAux k n x)\n\n"}
{"name":"SchwartzMap.sub_apply","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"E : Type u_4\nF : Type u_5\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nf g : SchwartzMap E F\nx : E\n‚ä¢ Eq ((HSub.hSub f g) x) (HSub.hSub (f x) (g x))","decl":"@[simp]\ntheorem sub_apply {f g : ùì¢(E, F)} {x : E} : (f - g) x = f x - g x :=\n  rfl\n\n"}
{"name":"SchwartzMap.coe_coeHom","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"E : Type u_4\nF : Type u_5\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\n‚ä¢ Eq (‚áë(SchwartzMap.coeHom E F)) DFunLike.coe","decl":"theorem coe_coeHom : (coeHom E F : ùì¢(E, F) ‚Üí E ‚Üí F) = DFunLike.coe :=\n  rfl\n\n"}
{"name":"SchwartzMap.coeHom_injective","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"E : Type u_4\nF : Type u_5\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\n‚ä¢ Function.Injective ‚áë(SchwartzMap.coeHom E F)","decl":"theorem coeHom_injective : Function.Injective (coeHom E F) := by\n  rw [coe_coeHom]\n  exact DFunLike.coe_injective\n\n"}
{"name":"SchwartzMap.seminorm_le_bound","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"ùïú : Type u_1\nE : Type u_4\nF : Type u_5\ninst‚úù‚Å∂ : NormedAddCommGroup E\ninst‚úù‚Åµ : NormedSpace Real E\ninst‚úù‚Å¥ : NormedAddCommGroup F\ninst‚úù¬≥ : NormedSpace Real F\ninst‚úù¬≤ : NormedField ùïú\ninst‚úù¬π : NormedSpace ùïú F\ninst‚úù : SMulCommClass Real ùïú F\nk n : Nat\nf : SchwartzMap E F\nM : Real\nhMp : LE.le 0 M\nhM : ‚àÄ (x : E), LE.le (HMul.hMul (HPow.hPow (Norm.norm x) k) (Norm.norm (iteratedFDeriv Real n (‚áëf) x))) M\n‚ä¢ LE.le ((SchwartzMap.seminorm ùïú k n) f) M","decl":"/-- If one controls the seminorm for every `x`, then one controls the seminorm. -/\ntheorem seminorm_le_bound (k n : ‚Ñï) (f : ùì¢(E, F)) {M : ‚Ñù} (hMp : 0 ‚â§ M)\n    (hM : ‚àÄ x, ‚Äñx‚Äñ ^ k * ‚ÄñiteratedFDeriv ‚Ñù n f x‚Äñ ‚â§ M) : SchwartzMap.seminorm ùïú k n f ‚â§ M :=\n  f.seminormAux_le_bound k n hMp hM\n\n"}
{"name":"SchwartzMap.seminorm_le_bound'","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"ùïú : Type u_1\nF : Type u_5\ninst‚úù‚Å¥ : NormedAddCommGroup F\ninst‚úù¬≥ : NormedSpace Real F\ninst‚úù¬≤ : NormedField ùïú\ninst‚úù¬π : NormedSpace ùïú F\ninst‚úù : SMulCommClass Real ùïú F\nk n : Nat\nf : SchwartzMap Real F\nM : Real\nhMp : LE.le 0 M\nhM : ‚àÄ (x : Real), LE.le (HMul.hMul (HPow.hPow (abs x) k) (Norm.norm (iteratedDeriv n (‚áëf) x))) M\n‚ä¢ LE.le ((SchwartzMap.seminorm ùïú k n) f) M","decl":"/-- If one controls the seminorm for every `x`, then one controls the seminorm.\n\nVariant for functions `ùì¢(‚Ñù, F)`. -/\ntheorem seminorm_le_bound' (k n : ‚Ñï) (f : ùì¢(‚Ñù, F)) {M : ‚Ñù} (hMp : 0 ‚â§ M)\n    (hM : ‚àÄ x, |x| ^ k * ‚ÄñiteratedDeriv n f x‚Äñ ‚â§ M) : SchwartzMap.seminorm ùïú k n f ‚â§ M := by\n  refine seminorm_le_bound ùïú k n f hMp ?_\n  simpa only [Real.norm_eq_abs, norm_iteratedFDeriv_eq_norm_iteratedDeriv]\n\n"}
{"name":"SchwartzMap.le_seminorm","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"ùïú : Type u_1\nE : Type u_4\nF : Type u_5\ninst‚úù‚Å∂ : NormedAddCommGroup E\ninst‚úù‚Åµ : NormedSpace Real E\ninst‚úù‚Å¥ : NormedAddCommGroup F\ninst‚úù¬≥ : NormedSpace Real F\ninst‚úù¬≤ : NormedField ùïú\ninst‚úù¬π : NormedSpace ùïú F\ninst‚úù : SMulCommClass Real ùïú F\nk n : Nat\nf : SchwartzMap E F\nx : E\n‚ä¢ LE.le (HMul.hMul (HPow.hPow (Norm.norm x) k) (Norm.norm (iteratedFDeriv Real n (‚áëf) x))) ((SchwartzMap.seminorm ùïú k n) f)","decl":"/-- The seminorm controls the Schwartz estimate for any fixed `x`. -/\ntheorem le_seminorm (k n : ‚Ñï) (f : ùì¢(E, F)) (x : E) :\n    ‚Äñx‚Äñ ^ k * ‚ÄñiteratedFDeriv ‚Ñù n f x‚Äñ ‚â§ SchwartzMap.seminorm ùïú k n f :=\n  f.le_seminormAux k n x\n\n"}
{"name":"SchwartzMap.le_seminorm'","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"ùïú : Type u_1\nF : Type u_5\ninst‚úù‚Å¥ : NormedAddCommGroup F\ninst‚úù¬≥ : NormedSpace Real F\ninst‚úù¬≤ : NormedField ùïú\ninst‚úù¬π : NormedSpace ùïú F\ninst‚úù : SMulCommClass Real ùïú F\nk n : Nat\nf : SchwartzMap Real F\nx : Real\n‚ä¢ LE.le (HMul.hMul (HPow.hPow (abs x) k) (Norm.norm (iteratedDeriv n (‚áëf) x))) ((SchwartzMap.seminorm ùïú k n) f)","decl":"/-- The seminorm controls the Schwartz estimate for any fixed `x`.\n\nVariant for functions `ùì¢(‚Ñù, F)`. -/\ntheorem le_seminorm' (k n : ‚Ñï) (f : ùì¢(‚Ñù, F)) (x : ‚Ñù) :\n    |x| ^ k * ‚ÄñiteratedDeriv n f x‚Äñ ‚â§ SchwartzMap.seminorm ùïú k n f := by\n  have := le_seminorm ùïú k n f x\n  rwa [‚Üê Real.norm_eq_abs, ‚Üê norm_iteratedFDeriv_eq_norm_iteratedDeriv]\n\n"}
{"name":"SchwartzMap.norm_iteratedFDeriv_le_seminorm","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"ùïú : Type u_1\nE : Type u_4\nF : Type u_5\ninst‚úù‚Å∂ : NormedAddCommGroup E\ninst‚úù‚Åµ : NormedSpace Real E\ninst‚úù‚Å¥ : NormedAddCommGroup F\ninst‚úù¬≥ : NormedSpace Real F\ninst‚úù¬≤ : NormedField ùïú\ninst‚úù¬π : NormedSpace ùïú F\ninst‚úù : SMulCommClass Real ùïú F\nf : SchwartzMap E F\nn : Nat\nx‚ÇÄ : E\n‚ä¢ LE.le (Norm.norm (iteratedFDeriv Real n (‚áëf) x‚ÇÄ)) ((SchwartzMap.seminorm ùïú 0 n) f)","decl":"theorem norm_iteratedFDeriv_le_seminorm (f : ùì¢(E, F)) (n : ‚Ñï) (x‚ÇÄ : E) :\n    ‚ÄñiteratedFDeriv ‚Ñù n f x‚ÇÄ‚Äñ ‚â§ (SchwartzMap.seminorm ùïú 0 n) f := by\n  have := SchwartzMap.le_seminorm ùïú 0 n f x‚ÇÄ\n  rwa [pow_zero, one_mul] at this\n\n"}
{"name":"SchwartzMap.norm_pow_mul_le_seminorm","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"ùïú : Type u_1\nE : Type u_4\nF : Type u_5\ninst‚úù‚Å∂ : NormedAddCommGroup E\ninst‚úù‚Åµ : NormedSpace Real E\ninst‚úù‚Å¥ : NormedAddCommGroup F\ninst‚úù¬≥ : NormedSpace Real F\ninst‚úù¬≤ : NormedField ùïú\ninst‚úù¬π : NormedSpace ùïú F\ninst‚úù : SMulCommClass Real ùïú F\nf : SchwartzMap E F\nk : Nat\nx‚ÇÄ : E\n‚ä¢ LE.le (HMul.hMul (HPow.hPow (Norm.norm x‚ÇÄ) k) (Norm.norm (f x‚ÇÄ))) ((SchwartzMap.seminorm ùïú k 0) f)","decl":"theorem norm_pow_mul_le_seminorm (f : ùì¢(E, F)) (k : ‚Ñï) (x‚ÇÄ : E) :\n    ‚Äñx‚ÇÄ‚Äñ ^ k * ‚Äñf x‚ÇÄ‚Äñ ‚â§ (SchwartzMap.seminorm ùïú k 0) f := by\n  have := SchwartzMap.le_seminorm ùïú k 0 f x‚ÇÄ\n  rwa [norm_iteratedFDeriv_zero] at this\n\n"}
{"name":"SchwartzMap.norm_le_seminorm","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"ùïú : Type u_1\nE : Type u_4\nF : Type u_5\ninst‚úù‚Å∂ : NormedAddCommGroup E\ninst‚úù‚Åµ : NormedSpace Real E\ninst‚úù‚Å¥ : NormedAddCommGroup F\ninst‚úù¬≥ : NormedSpace Real F\ninst‚úù¬≤ : NormedField ùïú\ninst‚úù¬π : NormedSpace ùïú F\ninst‚úù : SMulCommClass Real ùïú F\nf : SchwartzMap E F\nx‚ÇÄ : E\n‚ä¢ LE.le (Norm.norm (f x‚ÇÄ)) ((SchwartzMap.seminorm ùïú 0 0) f)","decl":"theorem norm_le_seminorm (f : ùì¢(E, F)) (x‚ÇÄ : E) : ‚Äñf x‚ÇÄ‚Äñ ‚â§ (SchwartzMap.seminorm ùïú 0 0) f := by\n  have := norm_pow_mul_le_seminorm ùïú f 0 x‚ÇÄ\n  rwa [pow_zero, one_mul] at this\n\n"}
{"name":"SchwartzMap.schwartzSeminormFamily_apply","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"ùïú : Type u_1\nE : Type u_4\nF : Type u_5\ninst‚úù‚Å∂ : NormedAddCommGroup E\ninst‚úù‚Åµ : NormedSpace Real E\ninst‚úù‚Å¥ : NormedAddCommGroup F\ninst‚úù¬≥ : NormedSpace Real F\ninst‚úù¬≤ : NormedField ùïú\ninst‚úù¬π : NormedSpace ùïú F\ninst‚úù : SMulCommClass Real ùïú F\nn k : Nat\n‚ä¢ Eq (schwartzSeminormFamily ùïú E F { fst := n, snd := k }) (SchwartzMap.seminorm ùïú n k)","decl":"@[simp]\ntheorem schwartzSeminormFamily_apply (n k : ‚Ñï) :\n    schwartzSeminormFamily ùïú E F (n, k) = SchwartzMap.seminorm ùïú n k :=\n  rfl\n\n"}
{"name":"SchwartzMap.schwartzSeminormFamily_apply_zero","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"ùïú : Type u_1\nE : Type u_4\nF : Type u_5\ninst‚úù‚Å∂ : NormedAddCommGroup E\ninst‚úù‚Åµ : NormedSpace Real E\ninst‚úù‚Å¥ : NormedAddCommGroup F\ninst‚úù¬≥ : NormedSpace Real F\ninst‚úù¬≤ : NormedField ùïú\ninst‚úù¬π : NormedSpace ùïú F\ninst‚úù : SMulCommClass Real ùïú F\n‚ä¢ Eq (schwartzSeminormFamily ùïú E F 0) (SchwartzMap.seminorm ùïú 0 0)","decl":"@[simp]\ntheorem schwartzSeminormFamily_apply_zero :\n    schwartzSeminormFamily ùïú E F 0 = SchwartzMap.seminorm ùïú 0 0 :=\n  rfl\n\n"}
{"name":"SchwartzMap.one_add_le_sup_seminorm_apply","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"ùïú : Type u_1\nE : Type u_4\nF : Type u_5\ninst‚úù‚Å∂ : NormedAddCommGroup E\ninst‚úù‚Åµ : NormedSpace Real E\ninst‚úù‚Å¥ : NormedAddCommGroup F\ninst‚úù¬≥ : NormedSpace Real F\ninst‚úù¬≤ : NormedField ùïú\ninst‚úù¬π : NormedSpace ùïú F\ninst‚úù : SMulCommClass Real ùïú F\nm : Prod Nat Nat\nk n : Nat\nhk : LE.le k m.1\nhn : LE.le n m.2\nf : SchwartzMap E F\nx : E\n‚ä¢ LE.le (HMul.hMul (HPow.hPow (HAdd.hAdd 1 (Norm.norm x)) k) (Norm.norm (iteratedFDeriv Real n (‚áëf) x))) (HMul.hMul (HPow.hPow 2 m.1) (((Finset.Iic m).sup fun m => SchwartzMap.seminorm ùïú m.1 m.2) f))","decl":"/-- A more convenient version of `le_sup_seminorm_apply`.\n\nThe set `Finset.Iic m` is the set of all pairs `(k', n')` with `k' ‚â§ m.1` and `n' ‚â§ m.2`.\nNote that the constant is far from optimal. -/\ntheorem one_add_le_sup_seminorm_apply {m : ‚Ñï √ó ‚Ñï} {k n : ‚Ñï} (hk : k ‚â§ m.1) (hn : n ‚â§ m.2)\n    (f : ùì¢(E, F)) (x : E) :\n    (1 + ‚Äñx‚Äñ) ^ k * ‚ÄñiteratedFDeriv ‚Ñù n f x‚Äñ ‚â§\n      2 ^ m.1 * (Finset.Iic m).sup (fun m => SchwartzMap.seminorm ùïú m.1 m.2) f := by\n  rw [add_comm, add_pow]\n  simp only [one_pow, mul_one, Finset.sum_congr, Finset.sum_mul]\n  norm_cast\n  rw [‚Üê Nat.sum_range_choose m.1]\n  push_cast\n  rw [Finset.sum_mul]\n  have hk' : Finset.range (k + 1) ‚äÜ Finset.range (m.1 + 1) := by\n    rwa [Finset.range_subset, add_le_add_iff_right]\n  refine le_trans (Finset.sum_le_sum_of_subset_of_nonneg hk' fun _ _ _ => by positivity) ?_\n  gcongr ‚àë _i ‚àà Finset.range (m.1 + 1), ?_ with i hi\n  move_mul [(Nat.choose k i : ‚Ñù), (Nat.choose m.1 i : ‚Ñù)]\n  gcongr\n  ¬∑ apply (le_seminorm ùïú i n f x).trans\n    apply Seminorm.le_def.1\n    exact Finset.le_sup_of_le (Finset.mem_Iic.2 <|\n      Prod.mk_le_mk.2 ‚ü®Finset.mem_range_succ_iff.mp hi, hn‚ü©) le_rfl\n  ¬∑ exact mod_cast Nat.choose_le_choose i hk\n\n"}
{"name":"schwartz_withSeminorms","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"ùïú : Type u_1\nE : Type u_4\nF : Type u_5\ninst‚úù‚Å∂ : NormedAddCommGroup E\ninst‚úù‚Åµ : NormedSpace Real E\ninst‚úù‚Å¥ : NormedAddCommGroup F\ninst‚úù¬≥ : NormedSpace Real F\ninst‚úù¬≤ : NormedField ùïú\ninst‚úù¬π : NormedSpace ùïú F\ninst‚úù : SMulCommClass Real ùïú F\n‚ä¢ WithSeminorms (schwartzSeminormFamily ùïú E F)","decl":"theorem _root_.schwartz_withSeminorms : WithSeminorms (schwartzSeminormFamily ùïú E F) := by\n  have A : WithSeminorms (schwartzSeminormFamily ‚Ñù E F) := ‚ü®rfl‚ü©\n  rw [SeminormFamily.withSeminorms_iff_nhds_eq_iInf] at A ‚ä¢\n  rw [A]\n  rfl\n\n"}
{"name":"SchwartzMap.instContinuousSMul","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"ùïú : Type u_1\nE : Type u_4\nF : Type u_5\ninst‚úù‚Å∂ : NormedAddCommGroup E\ninst‚úù‚Åµ : NormedSpace Real E\ninst‚úù‚Å¥ : NormedAddCommGroup F\ninst‚úù¬≥ : NormedSpace Real F\ninst‚úù¬≤ : NormedField ùïú\ninst‚úù¬π : NormedSpace ùïú F\ninst‚úù : SMulCommClass Real ùïú F\n‚ä¢ ContinuousSMul ùïú (SchwartzMap E F)","decl":"instance instContinuousSMul : ContinuousSMul ùïú ùì¢(E, F) := by\n  rw [(schwartz_withSeminorms ùïú E F).withSeminorms_eq]\n  exact (schwartzSeminormFamily ùïú E F).moduleFilterBasis.continuousSMul\n\n"}
{"name":"SchwartzMap.instTopologicalAddGroup","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"E : Type u_4\nF : Type u_5\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\n‚ä¢ TopologicalAddGroup (SchwartzMap E F)","decl":"instance instTopologicalAddGroup : TopologicalAddGroup ùì¢(E, F) :=\n  (schwartzSeminormFamily ‚Ñù E F).addGroupFilterBasis.isTopologicalAddGroup\n\n"}
{"name":"SchwartzMap.instUniformAddGroup","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"E : Type u_4\nF : Type u_5\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\n‚ä¢ UniformAddGroup (SchwartzMap E F)","decl":"instance instUniformAddGroup : UniformAddGroup ùì¢(E, F) :=\n  (schwartzSeminormFamily ‚Ñù E F).addGroupFilterBasis.uniformAddGroup\n\n"}
{"name":"SchwartzMap.instLocallyConvexSpace","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"E : Type u_4\nF : Type u_5\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\n‚ä¢ LocallyConvexSpace Real (SchwartzMap E F)","decl":"instance instLocallyConvexSpace : LocallyConvexSpace ‚Ñù ùì¢(E, F) :=\n  (schwartz_withSeminorms ‚Ñù E F).toLocallyConvexSpace\n\n"}
{"name":"SchwartzMap.instFirstCountableTopology","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"E : Type u_4\nF : Type u_5\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\n‚ä¢ FirstCountableTopology (SchwartzMap E F)","decl":"instance instFirstCountableTopology : FirstCountableTopology ùì¢(E, F) :=\n  (schwartz_withSeminorms ‚Ñù E F).firstCountableTopology\n\n"}
{"name":"Function.HasTemperateGrowth.norm_iteratedFDeriv_le_uniform_aux","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"E : Type u_4\nF : Type u_5\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nf : E ‚Üí F\nhf_temperate : Function.HasTemperateGrowth f\nn : Nat\n‚ä¢ Exists fun k => Exists fun C => And (LE.le 0 C) (‚àÄ (N : Nat), LE.le N n ‚Üí ‚àÄ (x : E), LE.le (Norm.norm (iteratedFDeriv Real N f x)) (HMul.hMul C (HPow.hPow (HAdd.hAdd 1 (Norm.norm x)) k)))","decl":"theorem _root_.Function.HasTemperateGrowth.norm_iteratedFDeriv_le_uniform_aux {f : E ‚Üí F}\n    (hf_temperate : f.HasTemperateGrowth) (n : ‚Ñï) :\n    ‚àÉ (k : ‚Ñï) (C : ‚Ñù), 0 ‚â§ C ‚àß ‚àÄ N ‚â§ n, ‚àÄ x : E, ‚ÄñiteratedFDeriv ‚Ñù N f x‚Äñ ‚â§ C * (1 + ‚Äñx‚Äñ) ^ k := by\n  choose k C f using hf_temperate.2\n  use (Finset.range (n + 1)).sup k\n  let C' := max (0 : ‚Ñù) ((Finset.range (n + 1)).sup' (by simp) C)\n  have hC' : 0 ‚â§ C' := by simp only [C', le_refl, Finset.le_sup'_iff, true_or, le_max_iff]\n  use C', hC'\n  intro N hN x\n  rw [‚Üê Finset.mem_range_succ_iff] at hN\n  refine le_trans (f N x) (mul_le_mul ?_ ?_ (by positivity) hC')\n  ¬∑ simp only [C', Finset.le_sup'_iff, le_max_iff]\n    right\n    exact ‚ü®N, hN, rfl.le‚ü©\n  gcongr\n  ¬∑ simp\n  exact Finset.le_sup hN\n\n"}
{"name":"Function.HasTemperateGrowth.of_fderiv","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"E : Type u_4\nF : Type u_5\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nf : E ‚Üí F\nh'f : Function.HasTemperateGrowth (fderiv Real f)\nhf : Differentiable Real f\nk : Nat\nC : Real\nh : ‚àÄ (x : E), LE.le (Norm.norm (f x)) (HMul.hMul C (HPow.hPow (HAdd.hAdd 1 (Norm.norm x)) k))\n‚ä¢ Function.HasTemperateGrowth f","decl":"lemma _root_.Function.HasTemperateGrowth.of_fderiv {f : E ‚Üí F}\n    (h'f : Function.HasTemperateGrowth (fderiv ‚Ñù f)) (hf : Differentiable ‚Ñù f) {k : ‚Ñï} {C : ‚Ñù}\n    (h : ‚àÄ x, ‚Äñf x‚Äñ ‚â§ C * (1 + ‚Äñx‚Äñ) ^ k) :\n    Function.HasTemperateGrowth f := by\n  refine ‚ü®contDiff_succ_iff_fderiv.2 ‚ü®hf, by simp, h'f.1‚ü© , fun n ‚Ü¶ ?_‚ü©\n  rcases n with rfl|m\n  ¬∑ exact ‚ü®k, C, fun x ‚Ü¶ by simpa using h x‚ü©\n  ¬∑ rcases h'f.2 m with ‚ü®k', C', h'‚ü©\n    refine ‚ü®k', C', ?_‚ü©\n    simpa [iteratedFDeriv_succ_eq_comp_right] using h'\n\n"}
{"name":"Function.HasTemperateGrowth.zero","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"E : Type u_4\nF : Type u_5\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\n‚ä¢ Function.HasTemperateGrowth fun x => 0","decl":"lemma _root_.Function.HasTemperateGrowth.zero :\n    Function.HasTemperateGrowth (fun _ : E ‚Ü¶ (0 : F)) := by\n  refine ‚ü®contDiff_const, fun n ‚Ü¶ ‚ü®0, 0, fun x ‚Ü¶ ?_‚ü©‚ü©\n  simp only [iteratedFDeriv_zero_fun, Pi.zero_apply, norm_zero, forall_const]\n  positivity\n\n"}
{"name":"Function.HasTemperateGrowth.const","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"E : Type u_4\nF : Type u_5\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nc : F\n‚ä¢ Function.HasTemperateGrowth fun x => c","decl":"lemma _root_.Function.HasTemperateGrowth.const (c : F) :\n    Function.HasTemperateGrowth (fun _ : E ‚Ü¶ c) :=\n  .of_fderiv (by simpa using .zero) (differentiable_const c) (k := 0) (C := ‚Äñc‚Äñ) (fun x ‚Ü¶ by simp)\n\n"}
{"name":"ContinuousLinearMap.hasTemperateGrowth","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"E : Type u_4\nF : Type u_5\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nf : ContinuousLinearMap (RingHom.id Real) E F\n‚ä¢ Function.HasTemperateGrowth ‚áëf","decl":"lemma _root_.ContinuousLinearMap.hasTemperateGrowth (f : E ‚ÜíL[‚Ñù] F) :\n    Function.HasTemperateGrowth f := by\n  apply Function.HasTemperateGrowth.of_fderiv ?_ f.differentiable (k := 1) (C := ‚Äñf‚Äñ) (fun x ‚Ü¶ ?_)\n  ¬∑ have : fderiv ‚Ñù f = fun _ ‚Ü¶ f := by ext1 v; simp only [ContinuousLinearMap.fderiv]\n    simpa [this] using .const _\n  ¬∑ exact (f.le_opNorm x).trans (by simp [mul_add])\n\n"}
{"name":"MeasureTheory.Measure.HasTemperateGrowth.exists_integrable","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"D : Type u_3\ninst‚úù¬π : NormedAddCommGroup D\ninst‚úù : MeasurableSpace D\nŒº : MeasureTheory.Measure D\nself : Œº.HasTemperateGrowth\n‚ä¢ Exists fun n => MeasureTheory.Integrable (fun x => HPow.hPow (HAdd.hAdd 1 (Norm.norm x)) (Neg.neg ‚Üën)) Œº","decl":"/-- A measure `Œº` has temperate growth if there is an `n : ‚Ñï` such that `(1 + ‚Äñx‚Äñ) ^ (- n)` is\n`Œº`-integrable. -/\nclass _root_.MeasureTheory.Measure.HasTemperateGrowth (Œº : Measure D) : Prop where\n  exists_integrable : ‚àÉ (n : ‚Ñï), Integrable (fun x ‚Ü¶ (1 + ‚Äñx‚Äñ) ^ (- (n : ‚Ñù))) Œº\n\n"}
{"name":"SchwartzMap.integrable_pow_neg_integrablePower","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"D : Type u_3\ninst‚úù¬π : NormedAddCommGroup D\ninst‚úù : MeasurableSpace D\nŒº : MeasureTheory.Measure D\nh : Œº.HasTemperateGrowth\n‚ä¢ MeasureTheory.Integrable (fun x => HPow.hPow (HAdd.hAdd 1 (Norm.norm x)) (Neg.neg ‚ÜëŒº.integrablePower)) Œº","decl":"lemma integrable_pow_neg_integrablePower\n    (Œº : Measure D) [h : Œº.HasTemperateGrowth] :\n    Integrable (fun x ‚Ü¶ (1 + ‚Äñx‚Äñ) ^ (- (Œº.integrablePower : ‚Ñù))) Œº := by\n  simpa [Measure.integrablePower, h] using h.exists_integrable.choose_spec\n\n"}
{"name":"MeasureTheory.Measure.IsFiniteMeasure.instHasTemperateGrowth","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"D : Type u_3\ninst‚úù¬π : NormedAddCommGroup D\ninst‚úù : MeasurableSpace D\nŒº : MeasureTheory.Measure D\nh : MeasureTheory.IsFiniteMeasure Œº\n‚ä¢ Œº.HasTemperateGrowth","decl":"instance _root_.MeasureTheory.Measure.IsFiniteMeasure.instHasTemperateGrowth {Œº : Measure D}\n    [h : IsFiniteMeasure Œº] : Œº.HasTemperateGrowth := ‚ü®‚ü®0, by simp‚ü©‚ü©\n\n"}
{"name":"MeasureTheory.Measure.IsAddHaarMeasure.instHasTemperateGrowth","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"D : Type u_3\ninst‚úù¬≤ : NormedAddCommGroup D\ninst‚úù¬π : MeasurableSpace D\ninst‚úù : NormedSpace Real D\nŒº : MeasureTheory.Measure D\nh : Œº.IsAddHaarMeasure\n‚ä¢ Œº.HasTemperateGrowth","decl":"variable [NormedSpace ‚Ñù D] [FiniteDimensional ‚Ñù D] [BorelSpace D] in\ninstance _root_.MeasureTheory.Measure.IsAddHaarMeasure.instHasTemperateGrowth {Œº : Measure D}\n    [h : Œº.IsAddHaarMeasure] : Œº.HasTemperateGrowth :=\n  ‚ü®‚ü®finrank ‚Ñù D + 1, by apply integrable_one_add_norm; norm_num‚ü©‚ü©\n\n"}
{"name":"SchwartzMap.pow_mul_le_of_le_of_pow_mul_le","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"C‚ÇÅ C‚ÇÇ : Real\nk l : Nat\nx f : Real\nhx : LE.le 0 x\nhf : LE.le 0 f\nh‚ÇÅ : LE.le f C‚ÇÅ\nh‚ÇÇ : LE.le (HMul.hMul (HPow.hPow x (HAdd.hAdd k l)) f) C‚ÇÇ\n‚ä¢ LE.le (HMul.hMul (HPow.hPow x k) f) (HMul.hMul (HMul.hMul (HPow.hPow 2 l) (HAdd.hAdd C‚ÇÅ C‚ÇÇ)) (HPow.hPow (HAdd.hAdd 1 x) (Neg.neg ‚Üël)))","decl":"/-- Pointwise inequality to control `x ^ k * f` in terms of `1 / (1 + x) ^ l` if one controls both\n`f` (with a bound `C‚ÇÅ`) and `x ^ (k + l) * f` (with a bound `C‚ÇÇ`). This will be used to check\nintegrability of `x ^ k * f x` when `f` is a Schwartz function, and to control explicitly its\nintegral in terms of suitable seminorms of `f`. -/\nlemma pow_mul_le_of_le_of_pow_mul_le {C‚ÇÅ C‚ÇÇ : ‚Ñù} {k l : ‚Ñï} {x f : ‚Ñù} (hx : 0 ‚â§ x) (hf : 0 ‚â§ f)\n    (h‚ÇÅ : f ‚â§ C‚ÇÅ) (h‚ÇÇ : x ^ (k + l) * f ‚â§ C‚ÇÇ) :\n    x ^ k * f ‚â§ 2 ^ l * (C‚ÇÅ + C‚ÇÇ) * (1 + x) ^ (- (l : ‚Ñù)) := by\n  have : 0 ‚â§ C‚ÇÇ := le_trans (by positivity) h‚ÇÇ\n  have : 2 ^ l * (C‚ÇÅ + C‚ÇÇ) * (1 + x) ^ (- (l : ‚Ñù)) = ((1 + x) / 2) ^ (-(l : ‚Ñù)) * (C‚ÇÅ + C‚ÇÇ) := by\n    rw [Real.div_rpow (by linarith) zero_le_two]\n    simp [div_eq_inv_mul, ‚Üê Real.rpow_neg_one, ‚Üê Real.rpow_mul]\n    ring\n  rw [this]\n  rcases le_total x 1 with h'x|h'x\n  ¬∑ gcongr\n    ¬∑ apply (pow_le_one‚ÇÄ hx h'x).trans\n      apply Real.one_le_rpow_of_pos_of_le_one_of_nonpos\n      ¬∑ linarith\n      ¬∑ linarith\n      ¬∑ simp\n    ¬∑ linarith\n  ¬∑ calc\n    x ^ k * f = x ^ (-(l : ‚Ñù)) * (x ^ (k + l) * f) := by\n      rw [‚Üê Real.rpow_natCast, ‚Üê Real.rpow_natCast, ‚Üê mul_assoc, ‚Üê Real.rpow_add (by linarith)]\n      simp\n    _ ‚â§ ((1 + x) / 2) ^ (-(l : ‚Ñù)) * (C‚ÇÅ + C‚ÇÇ) := by\n      apply mul_le_mul _ _ (by positivity) (by positivity)\n      ¬∑ exact Real.rpow_le_rpow_of_nonpos (by linarith) (by linarith) (by simp)\n      ¬∑ exact h‚ÇÇ.trans (by linarith)\n\n"}
{"name":"SchwartzMap.integrable_of_le_of_pow_mul_le","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"D : Type u_3\ninst‚úù‚Åµ : NormedAddCommGroup D\ninst‚úù‚Å¥ : MeasurableSpace D\ninst‚úù¬≥ : BorelSpace D\ninst‚úù¬≤ : SecondCountableTopology D\nE : Type u_8\ninst‚úù¬π : NormedAddCommGroup E\nŒº : MeasureTheory.Measure D\ninst‚úù : Œº.HasTemperateGrowth\nf : D ‚Üí E\nC‚ÇÅ C‚ÇÇ : Real\nk : Nat\nhf : ‚àÄ (x : D), LE.le (Norm.norm (f x)) C‚ÇÅ\nh'f : ‚àÄ (x : D), LE.le (HMul.hMul (HPow.hPow (Norm.norm x) (HAdd.hAdd k Œº.integrablePower)) (Norm.norm (f x))) C‚ÇÇ\nh''f : MeasureTheory.AEStronglyMeasurable f Œº\n‚ä¢ MeasureTheory.Integrable (fun x => HMul.hMul (HPow.hPow (Norm.norm x) k) (Norm.norm (f x))) Œº","decl":"variable [BorelSpace D] [SecondCountableTopology D] in\n/-- Given a function such that `f` and `x ^ (k + l) * f` are bounded for a suitable `l`, then\n`x ^ k * f` is integrable. The bounds are not relevant for the integrability conclusion, but they\nare relevant for bounding the integral in `integral_pow_mul_le_of_le_of_pow_mul_le`. We formulate\nthe two lemmas with the same set of assumptions for ease of applications. -/\n-- We redeclare `E` here to avoid the `NormedSpace ‚Ñù E` typeclass available throughout this file.\nlemma integrable_of_le_of_pow_mul_le\n    {E : Type*} [NormedAddCommGroup E]\n    {Œº : Measure D} [Œº.HasTemperateGrowth] {f : D ‚Üí E} {C‚ÇÅ C‚ÇÇ : ‚Ñù} {k : ‚Ñï}\n    (hf : ‚àÄ x, ‚Äñf x‚Äñ ‚â§ C‚ÇÅ) (h'f : ‚àÄ x, ‚Äñx‚Äñ ^ (k + Œº.integrablePower) * ‚Äñf x‚Äñ ‚â§ C‚ÇÇ)\n    (h''f : AEStronglyMeasurable f Œº) :\n    Integrable (fun x ‚Ü¶ ‚Äñx‚Äñ ^ k * ‚Äñf x‚Äñ) Œº := by\n  apply ((integrable_pow_neg_integrablePower Œº).const_mul (2 ^ Œº.integrablePower * (C‚ÇÅ + C‚ÇÇ))).mono'\n  ¬∑ exact AEStronglyMeasurable.mul (aestronglyMeasurable_id.norm.pow _) h''f.norm\n  ¬∑ filter_upwards with v\n    simp only [norm_mul, norm_pow, norm_norm]\n    apply pow_mul_le_of_le_of_pow_mul_le (norm_nonneg _) (norm_nonneg _) (hf v) (h'f v)\n\n"}
{"name":"SchwartzMap.integral_pow_mul_le_of_le_of_pow_mul_le","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"D : Type u_3\ninst‚úù¬≥ : NormedAddCommGroup D\ninst‚úù¬≤ : MeasurableSpace D\nE : Type u_8\ninst‚úù¬π : NormedAddCommGroup E\nŒº : MeasureTheory.Measure D\ninst‚úù : Œº.HasTemperateGrowth\nf : D ‚Üí E\nC‚ÇÅ C‚ÇÇ : Real\nk : Nat\nhf : ‚àÄ (x : D), LE.le (Norm.norm (f x)) C‚ÇÅ\nh'f : ‚àÄ (x : D), LE.le (HMul.hMul (HPow.hPow (Norm.norm x) (HAdd.hAdd k Œº.integrablePower)) (Norm.norm (f x))) C‚ÇÇ\n‚ä¢ LE.le (MeasureTheory.integral Œº fun x => HMul.hMul (HPow.hPow (Norm.norm x) k) (Norm.norm (f x))) (HMul.hMul (HMul.hMul (HPow.hPow 2 Œº.integrablePower) (MeasureTheory.integral Œº fun x => HPow.hPow (HAdd.hAdd 1 (Norm.norm x)) (Neg.neg ‚ÜëŒº.integrablePower))) (HAdd.hAdd C‚ÇÅ C‚ÇÇ))","decl":"/-- Given a function such that `f` and `x ^ (k + l) * f` are bounded for a suitable `l`, then\none can bound explicitly the integral of `x ^ k * f`. -/\n-- We redeclare `E` here to avoid the `NormedSpace ‚Ñù E` typeclass available throughout this file.\nlemma integral_pow_mul_le_of_le_of_pow_mul_le\n    {E : Type*} [NormedAddCommGroup E]\n    {Œº : Measure D} [Œº.HasTemperateGrowth] {f : D ‚Üí E} {C‚ÇÅ C‚ÇÇ : ‚Ñù} {k : ‚Ñï}\n    (hf : ‚àÄ x, ‚Äñf x‚Äñ ‚â§ C‚ÇÅ) (h'f : ‚àÄ x, ‚Äñx‚Äñ ^ (k + Œº.integrablePower) * ‚Äñf x‚Äñ ‚â§ C‚ÇÇ) :\n    ‚à´ x, ‚Äñx‚Äñ ^ k * ‚Äñf x‚Äñ ‚àÇŒº ‚â§ 2 ^ Œº.integrablePower *\n      (‚à´ x, (1 + ‚Äñx‚Äñ) ^ (- (Œº.integrablePower : ‚Ñù)) ‚àÇŒº) * (C‚ÇÅ + C‚ÇÇ) := by\n  rw [‚Üê integral_mul_left, ‚Üê integral_mul_right]\n  apply integral_mono_of_nonneg\n  ¬∑ filter_upwards with v using by positivity\n  ¬∑ exact ((integrable_pow_neg_integrablePower Œº).const_mul _).mul_const _\n  filter_upwards with v\n  exact (pow_mul_le_of_le_of_pow_mul_le (norm_nonneg _) (norm_nonneg _) (hf v) (h'f v)).trans\n    (le_of_eq (by ring))\n\n"}
{"name":"MeasureTheory.Measure.HasTemperateGrowth.exists_eLpNorm_lt_top","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"D : Type u_3\ninst‚úù¬π : NormedAddCommGroup D\ninst‚úù : MeasurableSpace D\np : ENNReal\nŒº : MeasureTheory.Measure D\nhŒº : Œº.HasTemperateGrowth\n‚ä¢ Exists fun k => LT.lt (MeasureTheory.eLpNorm (fun x => HPow.hPow (HAdd.hAdd 1 (Norm.norm x)) (Neg.neg ‚Üëk)) p Œº) Top.top","decl":"/-- For any `HasTemperateGrowth` measure and `p`, there exists an integer power `k` such that\n`(1 + ‚Äñx‚Äñ) ^ (-k)` is in `L^p`. -/\ntheorem _root_.MeasureTheory.Measure.HasTemperateGrowth.exists_eLpNorm_lt_top (p : ‚Ñù‚â•0‚àû)\n    {Œº : Measure D} (hŒº : Œº.HasTemperateGrowth) :\n    ‚àÉ k : ‚Ñï, eLpNorm (fun x ‚Ü¶ (1 + ‚Äñx‚Äñ) ^ (-k : ‚Ñù)) p Œº < ‚ä§ := by\n  cases p with\n  | top => exact ‚ü®0, eLpNormEssSup_lt_top_of_ae_bound (C := 1) (by simp)‚ü©\n  | coe p =>\n    cases eq_or_ne (p : ‚Ñù‚â•0‚àû) 0 with\n    | inl hp => exact ‚ü®0, by simp [hp]‚ü©\n    | inr hp =>\n      have h_one_add (x : D) : 0 < 1 + ‚Äñx‚Äñ := lt_add_of_pos_of_le zero_lt_one (norm_nonneg x)\n      have hp_pos : 0 < (p : ‚Ñù) := by simpa [zero_lt_iff] using hp\n      rcases hŒº.exists_integrable with ‚ü®l, hl‚ü©\n      let k := ‚åà(l / p : ‚Ñù)‚åâ‚Çä\n      have hlk : l ‚â§ k * (p : ‚Ñù) := by simpa [div_le_iff‚ÇÄ hp_pos] using Nat.le_ceil (l / p : ‚Ñù)\n      use k\n      suffices HasFiniteIntegral (fun x ‚Ü¶ ((1 + ‚Äñx‚Äñ) ^ (-(k * p) : ‚Ñù))) Œº by\n        rw [hasFiniteIntegral_iff_enorm] at this\n        rw [eLpNorm_lt_top_iff_lintegral_rpow_nnnorm_lt_top hp ENNReal.coe_ne_top]\n        simp only [ENNReal.coe_toReal]\n        refine Eq.subst (motive := (‚à´‚Åª x, ¬∑ x ‚àÇŒº < ‚ä§)) (funext fun x ‚Ü¶ ?_) this\n        rw [‚Üê neg_mul, Real.rpow_mul (h_one_add x).le]\n        exact Real.enorm_rpow_of_nonneg (Real.rpow_nonneg (h_one_add x).le _) NNReal.zero_le_coe\n      refine hl.hasFiniteIntegral.mono' (ae_of_all Œº fun x ‚Ü¶ ?_)\n      rw [Real.norm_of_nonneg (Real.rpow_nonneg (h_one_add x).le _)]\n      gcongr\n      simp\n\n"}
{"name":"SchwartzMap.compCLM_apply","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"ùïú : Type u_1\nD : Type u_3\nE : Type u_4\nF : Type u_5\ninst‚úù‚Å∏ : NormedAddCommGroup E\ninst‚úù‚Å∑ : NormedSpace Real E\ninst‚úù‚Å∂ : NormedAddCommGroup F\ninst‚úù‚Åµ : NormedSpace Real F\ninst‚úù‚Å¥ : RCLike ùïú\ninst‚úù¬≥ : NormedAddCommGroup D\ninst‚úù¬≤ : NormedSpace Real D\ninst‚úù¬π : NormedSpace ùïú F\ninst‚úù : SMulCommClass Real ùïú F\ng : D ‚Üí E\nhg : Function.HasTemperateGrowth g\nhg_upper : Exists fun k => Exists fun C => ‚àÄ (x : D), LE.le (Norm.norm x) (HMul.hMul C (HPow.hPow (HAdd.hAdd 1 (Norm.norm (g x))) k))\nf : SchwartzMap E F\n‚ä¢ Eq (‚áë((SchwartzMap.compCLM ùïú hg hg_upper) f)) (Function.comp (‚áëf) g)","decl":"@[simp] lemma compCLM_apply {g : D ‚Üí E} (hg : g.HasTemperateGrowth)\n    (hg_upper : ‚àÉ (k : ‚Ñï) (C : ‚Ñù), ‚àÄ x, ‚Äñx‚Äñ ‚â§ C * (1 + ‚Äñg x‚Äñ) ^ k) (f : ùì¢(E, F)) :\n    compCLM ùïú hg hg_upper f = f ‚àò g := rfl\n\n"}
{"name":"SchwartzMap.compCLMOfAntilipschitz_apply","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"ùïú : Type u_1\nD : Type u_3\nE : Type u_4\nF : Type u_5\ninst‚úù‚Å∏ : NormedAddCommGroup E\ninst‚úù‚Å∑ : NormedSpace Real E\ninst‚úù‚Å∂ : NormedAddCommGroup F\ninst‚úù‚Åµ : NormedSpace Real F\ninst‚úù‚Å¥ : RCLike ùïú\ninst‚úù¬≥ : NormedAddCommGroup D\ninst‚úù¬≤ : NormedSpace Real D\ninst‚úù¬π : NormedSpace ùïú F\ninst‚úù : SMulCommClass Real ùïú F\nK : NNReal\ng : D ‚Üí E\nhg : Function.HasTemperateGrowth g\nh'g : AntilipschitzWith K g\nf : SchwartzMap E F\n‚ä¢ Eq (‚áë((SchwartzMap.compCLMOfAntilipschitz ùïú hg h'g) f)) (Function.comp (‚áëf) g)","decl":"@[simp] lemma compCLMOfAntilipschitz_apply {K : ‚Ñù‚â•0} {g : D ‚Üí E} (hg : g.HasTemperateGrowth)\n    (h'g : AntilipschitzWith K g) (f : ùì¢(E, F)) :\n    compCLMOfAntilipschitz ùïú hg h'g f = f ‚àò g := rfl\n\n"}
{"name":"SchwartzMap.compCLMOfContinuousLinearEquiv_apply","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"ùïú : Type u_1\nD : Type u_3\nE : Type u_4\nF : Type u_5\ninst‚úù‚Å∏ : NormedAddCommGroup E\ninst‚úù‚Å∑ : NormedSpace Real E\ninst‚úù‚Å∂ : NormedAddCommGroup F\ninst‚úù‚Åµ : NormedSpace Real F\ninst‚úù‚Å¥ : RCLike ùïú\ninst‚úù¬≥ : NormedAddCommGroup D\ninst‚úù¬≤ : NormedSpace Real D\ninst‚úù¬π : NormedSpace ùïú F\ninst‚úù : SMulCommClass Real ùïú F\ng : ContinuousLinearEquiv (RingHom.id Real) D E\nf : SchwartzMap E F\n‚ä¢ Eq (‚áë((SchwartzMap.compCLMOfContinuousLinearEquiv ùïú g) f)) (Function.comp ‚áëf ‚áëg)","decl":"@[simp] lemma compCLMOfContinuousLinearEquiv_apply (g : D ‚âÉL[‚Ñù] E) (f : ùì¢(E, F)) :\n    compCLMOfContinuousLinearEquiv ùïú g f = f ‚àò g := rfl\n\n"}
{"name":"SchwartzMap.fderivCLM_apply","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"ùïú : Type u_1\nE : Type u_4\nF : Type u_5\ninst‚úù‚Å∂ : NormedAddCommGroup E\ninst‚úù‚Åµ : NormedSpace Real E\ninst‚úù‚Å¥ : NormedAddCommGroup F\ninst‚úù¬≥ : NormedSpace Real F\ninst‚úù¬≤ : RCLike ùïú\ninst‚úù¬π : NormedSpace ùïú F\ninst‚úù : SMulCommClass Real ùïú F\nf : SchwartzMap E F\nx : E\n‚ä¢ Eq (((SchwartzMap.fderivCLM ùïú) f) x) (fderiv Real (‚áëf) x)","decl":"@[simp]\ntheorem fderivCLM_apply (f : ùì¢(E, F)) (x : E) : fderivCLM ùïú f x = fderiv ‚Ñù f x :=\n  rfl\n\n"}
{"name":"SchwartzMap.derivCLM_apply","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"ùïú : Type u_1\nF : Type u_5\ninst‚úù‚Å¥ : NormedAddCommGroup F\ninst‚úù¬≥ : NormedSpace Real F\ninst‚úù¬≤ : RCLike ùïú\ninst‚úù¬π : NormedSpace ùïú F\ninst‚úù : SMulCommClass Real ùïú F\nf : SchwartzMap Real F\nx : Real\n‚ä¢ Eq (((SchwartzMap.derivCLM ùïú) f) x) (deriv (‚áëf) x)","decl":"@[simp]\ntheorem derivCLM_apply (f : ùì¢(‚Ñù, F)) (x : ‚Ñù) : derivCLM ùïú f x = deriv f x :=\n  rfl\n\n"}
{"name":"SchwartzMap.pderivCLM_apply","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"ùïú : Type u_1\nE : Type u_4\nF : Type u_5\ninst‚úù‚Å∂ : NormedAddCommGroup E\ninst‚úù‚Åµ : NormedSpace Real E\ninst‚úù‚Å¥ : NormedAddCommGroup F\ninst‚úù¬≥ : NormedSpace Real F\ninst‚úù¬≤ : RCLike ùïú\ninst‚úù¬π : NormedSpace ùïú F\ninst‚úù : SMulCommClass Real ùïú F\nm : E\nf : SchwartzMap E F\nx : E\n‚ä¢ Eq (((SchwartzMap.pderivCLM ùïú m) f) x) ((fderiv Real (‚áëf) x) m)","decl":"@[simp]\ntheorem pderivCLM_apply (m : E) (f : ùì¢(E, F)) (x : E) : pderivCLM ùïú m f x = fderiv ‚Ñù f x m :=\n  rfl\n\n"}
{"name":"SchwartzMap.pderivCLM_eq_lineDeriv","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"ùïú : Type u_1\nE : Type u_4\nF : Type u_5\ninst‚úù‚Å∂ : NormedAddCommGroup E\ninst‚úù‚Åµ : NormedSpace Real E\ninst‚úù‚Å¥ : NormedAddCommGroup F\ninst‚úù¬≥ : NormedSpace Real F\ninst‚úù¬≤ : RCLike ùïú\ninst‚úù¬π : NormedSpace ùïú F\ninst‚úù : SMulCommClass Real ùïú F\nm : E\nf : SchwartzMap E F\nx : E\n‚ä¢ Eq (((SchwartzMap.pderivCLM ùïú m) f) x) (lineDeriv Real (‚áëf) x m)","decl":"theorem pderivCLM_eq_lineDeriv (m : E) (f : ùì¢(E, F)) (x : E) :\n    pderivCLM ùïú m f x = lineDeriv ‚Ñù f x m := by\n  simp only [pderivCLM_apply, f.differentiableAt.lineDeriv_eq_fderiv]\n\n"}
{"name":"SchwartzMap.iteratedPDeriv_zero","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"ùïú : Type u_1\nE : Type u_4\nF : Type u_5\ninst‚úù‚Å∂ : NormedAddCommGroup E\ninst‚úù‚Åµ : NormedSpace Real E\ninst‚úù‚Å¥ : NormedAddCommGroup F\ninst‚úù¬≥ : NormedSpace Real F\ninst‚úù¬≤ : RCLike ùïú\ninst‚úù¬π : NormedSpace ùïú F\ninst‚úù : SMulCommClass Real ùïú F\nm : Fin 0 ‚Üí E\nf : SchwartzMap E F\n‚ä¢ Eq ((SchwartzMap.iteratedPDeriv ùïú m) f) f","decl":"@[simp]\ntheorem iteratedPDeriv_zero (m : Fin 0 ‚Üí E) (f : ùì¢(E, F)) : iteratedPDeriv ùïú m f = f :=\n  rfl\n\n"}
{"name":"SchwartzMap.iteratedPDeriv_one","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"ùïú : Type u_1\nE : Type u_4\nF : Type u_5\ninst‚úù‚Å∂ : NormedAddCommGroup E\ninst‚úù‚Åµ : NormedSpace Real E\ninst‚úù‚Å¥ : NormedAddCommGroup F\ninst‚úù¬≥ : NormedSpace Real F\ninst‚úù¬≤ : RCLike ùïú\ninst‚úù¬π : NormedSpace ùïú F\ninst‚úù : SMulCommClass Real ùïú F\nm : Fin 1 ‚Üí E\nf : SchwartzMap E F\n‚ä¢ Eq ((SchwartzMap.iteratedPDeriv ùïú m) f) ((SchwartzMap.pderivCLM ùïú (m 0)) f)","decl":"@[simp]\ntheorem iteratedPDeriv_one (m : Fin 1 ‚Üí E) (f : ùì¢(E, F)) :\n    iteratedPDeriv ùïú m f = pderivCLM ùïú (m 0) f :=\n  rfl\n\n"}
{"name":"SchwartzMap.iteratedPDeriv_succ_left","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"ùïú : Type u_1\nE : Type u_4\nF : Type u_5\ninst‚úù‚Å∂ : NormedAddCommGroup E\ninst‚úù‚Åµ : NormedSpace Real E\ninst‚úù‚Å¥ : NormedAddCommGroup F\ninst‚úù¬≥ : NormedSpace Real F\ninst‚úù¬≤ : RCLike ùïú\ninst‚úù¬π : NormedSpace ùïú F\ninst‚úù : SMulCommClass Real ùïú F\nn : Nat\nm : Fin (HAdd.hAdd n 1) ‚Üí E\nf : SchwartzMap E F\n‚ä¢ Eq ((SchwartzMap.iteratedPDeriv ùïú m) f) ((SchwartzMap.pderivCLM ùïú (m 0)) ((SchwartzMap.iteratedPDeriv ùïú (Fin.tail m)) f))","decl":"theorem iteratedPDeriv_succ_left {n : ‚Ñï} (m : Fin (n + 1) ‚Üí E) (f : ùì¢(E, F)) :\n    iteratedPDeriv ùïú m f = pderivCLM ùïú (m 0) (iteratedPDeriv ùïú (Fin.tail m) f) :=\n  rfl\n\n"}
{"name":"SchwartzMap.iteratedPDeriv_succ_right","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"ùïú : Type u_1\nE : Type u_4\nF : Type u_5\ninst‚úù‚Å∂ : NormedAddCommGroup E\ninst‚úù‚Åµ : NormedSpace Real E\ninst‚úù‚Å¥ : NormedAddCommGroup F\ninst‚úù¬≥ : NormedSpace Real F\ninst‚úù¬≤ : RCLike ùïú\ninst‚úù¬π : NormedSpace ùïú F\ninst‚úù : SMulCommClass Real ùïú F\nn : Nat\nm : Fin (HAdd.hAdd n 1) ‚Üí E\nf : SchwartzMap E F\n‚ä¢ Eq ((SchwartzMap.iteratedPDeriv ùïú m) f) ((SchwartzMap.iteratedPDeriv ùïú (Fin.init m)) ((SchwartzMap.pderivCLM ùïú (m (Fin.last n))) f))","decl":"theorem iteratedPDeriv_succ_right {n : ‚Ñï} (m : Fin (n + 1) ‚Üí E) (f : ùì¢(E, F)) :\n    iteratedPDeriv ùïú m f = iteratedPDeriv ùïú (Fin.init m) (pderivCLM ùïú (m (Fin.last n)) f) := by\n  induction n with\n  | zero =>\n    rw [iteratedPDeriv_zero, iteratedPDeriv_one]\n    rfl\n  -- The proof is `‚àÇ^{n + 2} = ‚àÇ ‚àÇ^{n + 1} = ‚àÇ ‚àÇ^n ‚àÇ = ‚àÇ^{n+1} ‚àÇ`\n  | succ n IH =>\n    have hmzero : Fin.init m 0 = m 0 := by simp only [Fin.init_def, Fin.castSucc_zero]\n    have hmtail : Fin.tail m (Fin.last n) = m (Fin.last n.succ) := by\n      simp only [Fin.tail_def, Fin.succ_last]\n    calc\n      _ = pderivCLM ùïú (m 0) (iteratedPDeriv ùïú _ f) := iteratedPDeriv_succ_left _ _ _\n      _ = pderivCLM ùïú (m 0) ((iteratedPDeriv ùïú _) ((pderivCLM ùïú _) f)) := by\n        congr 1\n        exact IH _\n      _ = _ := by\n        simp only [hmtail, iteratedPDeriv_succ_left, hmzero, Fin.tail_init_eq_init_tail]\n\n"}
{"name":"SchwartzMap.iteratedPDeriv_eq_iteratedFDeriv","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"ùïú : Type u_1\nE : Type u_4\nF : Type u_5\ninst‚úù‚Å∂ : NormedAddCommGroup E\ninst‚úù‚Åµ : NormedSpace Real E\ninst‚úù‚Å¥ : NormedAddCommGroup F\ninst‚úù¬≥ : NormedSpace Real F\ninst‚úù¬≤ : RCLike ùïú\ninst‚úù¬π : NormedSpace ùïú F\ninst‚úù : SMulCommClass Real ùïú F\nn : Nat\nm : Fin n ‚Üí E\nf : SchwartzMap E F\nx : E\n‚ä¢ Eq (((SchwartzMap.iteratedPDeriv ùïú m) f) x) ((iteratedFDeriv Real n (‚áëf) x) m)","decl":"theorem iteratedPDeriv_eq_iteratedFDeriv {n : ‚Ñï} {m : Fin n ‚Üí E} {f : ùì¢(E, F)} {x : E} :\n    iteratedPDeriv ùïú m f x = iteratedFDeriv ‚Ñù n f x m := by\n  induction n generalizing x with\n  | zero => simp\n  | succ n ih =>\n    simp only [iteratedPDeriv_succ_left, iteratedFDeriv_succ_apply_left]\n    rw [‚Üê fderiv_continuousMultilinear_apply_const_apply]\n    ¬∑ simp [‚Üê ih]\n    ¬∑ exact f.smooth'.differentiable_iteratedFDeriv (mod_cast ENat.coe_lt_top n) x\n\n\n"}
{"name":"SchwartzMap.integral_pow_mul_iteratedFDeriv_le","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"ùïú : Type u_1\nD : Type u_3\nV : Type u_7\ninst‚úù‚Å∂ : RCLike ùïú\ninst‚úù‚Åµ : NormedAddCommGroup D\ninst‚úù‚Å¥ : NormedSpace Real D\ninst‚úù¬≥ : NormedAddCommGroup V\ninst‚úù¬≤ : NormedSpace Real V\ninst‚úù¬π : NormedSpace ùïú V\ninst‚úù : MeasurableSpace D\nŒº : MeasureTheory.Measure D\nhŒº : Œº.HasTemperateGrowth\nf : SchwartzMap D V\nk n : Nat\n‚ä¢ LE.le (MeasureTheory.integral Œº fun x => HMul.hMul (HPow.hPow (Norm.norm x) k) (Norm.norm (iteratedFDeriv Real n (‚áëf) x))) (HMul.hMul (HMul.hMul (HPow.hPow 2 Œº.integrablePower) (MeasureTheory.integral Œº fun x => HPow.hPow (HAdd.hAdd 1 (Norm.norm x)) (Neg.neg ‚ÜëŒº.integrablePower))) (HAdd.hAdd ((SchwartzMap.seminorm ùïú 0 n) f) ((SchwartzMap.seminorm ùïú (HAdd.hAdd k Œº.integrablePower) n) f)))","decl":"variable (ùïú Œº) in\nlemma integral_pow_mul_iteratedFDeriv_le (f : ùì¢(D, V)) (k n : ‚Ñï) :\n    ‚à´ x, ‚Äñx‚Äñ ^ k * ‚ÄñiteratedFDeriv ‚Ñù n f x‚Äñ ‚àÇŒº ‚â§ 2 ^ Œº.integrablePower *\n      (‚à´ x, (1 + ‚Äñx‚Äñ) ^ (- (Œº.integrablePower : ‚Ñù)) ‚àÇŒº) *\n        (SchwartzMap.seminorm ùïú 0 n f + SchwartzMap.seminorm ùïú (k + Œº.integrablePower) n f) :=\n  integral_pow_mul_le_of_le_of_pow_mul_le (norm_iteratedFDeriv_le_seminorm ‚Ñù _ _)\n    (le_seminorm ‚Ñù _ _ _)\n\n"}
{"name":"SchwartzMap.integrable_pow_mul_iteratedFDeriv","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"D : Type u_3\nV : Type u_7\ninst‚úù‚Å∂ : NormedAddCommGroup D\ninst‚úù‚Åµ : NormedSpace Real D\ninst‚úù‚Å¥ : NormedAddCommGroup V\ninst‚úù¬≥ : NormedSpace Real V\ninst‚úù¬≤ : MeasurableSpace D\nŒº : MeasureTheory.Measure D\nhŒº : Œº.HasTemperateGrowth\ninst‚úù¬π : BorelSpace D\ninst‚úù : SecondCountableTopology D\nf : SchwartzMap D V\nk n : Nat\n‚ä¢ MeasureTheory.Integrable (fun x => HMul.hMul (HPow.hPow (Norm.norm x) k) (Norm.norm (iteratedFDeriv Real n (‚áëf) x))) Œº","decl":"variable (Œº) in\nlemma integrable_pow_mul_iteratedFDeriv\n    (f : ùì¢(D, V))\n    (k n : ‚Ñï) : Integrable (fun x ‚Ü¶ ‚Äñx‚Äñ ^ k * ‚ÄñiteratedFDeriv ‚Ñù n f x‚Äñ) Œº :=\n  integrable_of_le_of_pow_mul_le (norm_iteratedFDeriv_le_seminorm ‚Ñù _ _) (le_seminorm ‚Ñù _ _ _)\n    ((f.smooth ‚ä§).continuous_iteratedFDeriv (mod_cast le_top)).aestronglyMeasurable\n\n"}
{"name":"SchwartzMap.integrable_pow_mul","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"D : Type u_3\nV : Type u_7\ninst‚úù‚Å∂ : NormedAddCommGroup D\ninst‚úù‚Åµ : NormedSpace Real D\ninst‚úù‚Å¥ : NormedAddCommGroup V\ninst‚úù¬≥ : NormedSpace Real V\ninst‚úù¬≤ : MeasurableSpace D\nŒº : MeasureTheory.Measure D\nhŒº : Œº.HasTemperateGrowth\ninst‚úù¬π : BorelSpace D\ninst‚úù : SecondCountableTopology D\nf : SchwartzMap D V\nk : Nat\n‚ä¢ MeasureTheory.Integrable (fun x => HMul.hMul (HPow.hPow (Norm.norm x) k) (Norm.norm (f x))) Œº","decl":"variable (Œº) in\nlemma integrable_pow_mul (f : ùì¢(D, V))\n    (k : ‚Ñï) : Integrable (fun x ‚Ü¶ ‚Äñx‚Äñ ^ k * ‚Äñf x‚Äñ) Œº := by\n  convert integrable_pow_mul_iteratedFDeriv Œº f k 0 with x\n  simp\n\n"}
{"name":"SchwartzMap.integrable","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"D : Type u_3\nV : Type u_7\ninst‚úù‚Å∂ : NormedAddCommGroup D\ninst‚úù‚Åµ : NormedSpace Real D\ninst‚úù‚Å¥ : NormedAddCommGroup V\ninst‚úù¬≥ : NormedSpace Real V\ninst‚úù¬≤ : MeasurableSpace D\nŒº : MeasureTheory.Measure D\nhŒº : Œº.HasTemperateGrowth\ninst‚úù¬π : BorelSpace D\ninst‚úù : SecondCountableTopology D\nf : SchwartzMap D V\n‚ä¢ MeasureTheory.Integrable (‚áëf) Œº","decl":"lemma integrable (f : ùì¢(D, V)) : Integrable f Œº :=\n  (f.integrable_pow_mul Œº 0).mono f.continuous.aestronglyMeasurable\n    (Eventually.of_forall (fun _ ‚Ü¶ by simp))\n\n"}
{"name":"SchwartzMap.integralCLM_apply","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"ùïú : Type u_1\nD : Type u_3\nV : Type u_7\ninst‚úù‚Å∏ : RCLike ùïú\ninst‚úù‚Å∑ : NormedAddCommGroup D\ninst‚úù‚Å∂ : NormedSpace Real D\ninst‚úù‚Åµ : NormedAddCommGroup V\ninst‚úù‚Å¥ : NormedSpace Real V\ninst‚úù¬≥ : NormedSpace ùïú V\ninst‚úù¬≤ : MeasurableSpace D\nŒº : MeasureTheory.Measure D\nhŒº : Œº.HasTemperateGrowth\ninst‚úù¬π : BorelSpace D\ninst‚úù : SecondCountableTopology D\nf : SchwartzMap D V\n‚ä¢ Eq ((SchwartzMap.integralCLM ùïú Œº) f) (MeasureTheory.integral Œº fun x => f x)","decl":"variable (ùïú) in\n@[simp]\nlemma integralCLM_apply (f : ùì¢(D, V)) : integralCLM ùïú Œº f = ‚à´ x, f x ‚àÇŒº := by rfl\n\n"}
{"name":"SchwartzMap.instBoundedContinuousMapClass","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"E : Type u_4\nF : Type u_5\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\n‚ä¢ BoundedContinuousMapClass (SchwartzMap E F) E F","decl":"instance instBoundedContinuousMapClass : BoundedContinuousMapClass ùì¢(E, F) E F where\n  __ := instContinuousMapClass\n  map_bounded := fun f ‚Ü¶ ‚ü®2 * (SchwartzMap.seminorm ‚Ñù 0 0) f,\n    (BoundedContinuousFunction.dist_le_two_norm' (norm_le_seminorm ‚Ñù f))‚ü©\n\n"}
{"name":"SchwartzMap.toBoundedContinuousFunction_apply","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"E : Type u_4\nF : Type u_5\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nf : SchwartzMap E F\nx : E\n‚ä¢ Eq (f.toBoundedContinuousFunction x) (f x)","decl":"@[simp]\ntheorem toBoundedContinuousFunction_apply (f : ùì¢(E, F)) (x : E) :\n    f.toBoundedContinuousFunction x = f x :=\n  rfl\n\n"}
{"name":"SchwartzMap.toBoundedContinuousFunctionCLM_apply","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"ùïú : Type u_1\nE : Type u_4\nF : Type u_5\ninst‚úù‚Å∂ : NormedAddCommGroup E\ninst‚úù‚Åµ : NormedSpace Real E\ninst‚úù‚Å¥ : NormedAddCommGroup F\ninst‚úù¬≥ : NormedSpace Real F\ninst‚úù¬≤ : RCLike ùïú\ninst‚úù¬π : NormedSpace ùïú F\ninst‚úù : SMulCommClass Real ùïú F\nf : SchwartzMap E F\nx : E\n‚ä¢ Eq (((SchwartzMap.toBoundedContinuousFunctionCLM ùïú E F) f) x) (f x)","decl":"@[simp]\ntheorem toBoundedContinuousFunctionCLM_apply (f : ùì¢(E, F)) (x : E) :\n    toBoundedContinuousFunctionCLM ùïú E F f x = f x :=\n  rfl\n\n"}
{"name":"SchwartzMap.delta_apply","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"ùïú : Type u_1\nE : Type u_4\nF : Type u_5\ninst‚úù‚Å∂ : NormedAddCommGroup E\ninst‚úù‚Åµ : NormedSpace Real E\ninst‚úù‚Å¥ : NormedAddCommGroup F\ninst‚úù¬≥ : NormedSpace Real F\ninst‚úù¬≤ : RCLike ùïú\ninst‚úù¬π : NormedSpace ùïú F\ninst‚úù : SMulCommClass Real ùïú F\nx‚ÇÄ : E\nf : SchwartzMap E F\n‚ä¢ Eq ((SchwartzMap.delta ùïú F x‚ÇÄ) f) (f x‚ÇÄ)","decl":"@[simp]\ntheorem delta_apply (x‚ÇÄ : E) (f : ùì¢(E, F)) : delta ùïú F x‚ÇÄ f = f x‚ÇÄ :=\n  rfl\n\n"}
{"name":"SchwartzMap.integralCLM_dirac_eq_delta","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"ùïú : Type u_1\nE : Type u_4\nF : Type u_5\ninst‚úù¬π‚Å∞ : NormedAddCommGroup E\ninst‚úù‚Åπ : NormedSpace Real E\ninst‚úù‚Å∏ : NormedAddCommGroup F\ninst‚úù‚Å∑ : NormedSpace Real F\ninst‚úù‚Å∂ : RCLike ùïú\ninst‚úù‚Åµ : NormedSpace ùïú F\ninst‚úù‚Å¥ : SMulCommClass Real ùïú F\ninst‚úù¬≥ : MeasurableSpace E\ninst‚úù¬≤ : BorelSpace E\ninst‚úù¬π : SecondCountableTopology E\ninst‚úù : CompleteSpace F\nx : E\n‚ä¢ Eq (SchwartzMap.integralCLM ùïú (MeasureTheory.Measure.dirac x)) (SchwartzMap.delta ùïú F x)","decl":"/-- Integrating against the Dirac measure is equal to the delta distribution. -/\n@[simp]\ntheorem integralCLM_dirac_eq_delta (x : E) : integralCLM ùïú (dirac x) = delta ùïú F x := by aesop\n\n"}
{"name":"SchwartzMap.instZeroAtInftyContinuousMapClass","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"E : Type u_4\nF : Type u_5\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\n‚ä¢ ZeroAtInftyContinuousMapClass (SchwartzMap E F) E F","decl":"instance instZeroAtInftyContinuousMapClass : ZeroAtInftyContinuousMapClass ùì¢(E, F) E F where\n  __ := instContinuousMapClass\n  zero_at_infty := by\n    intro f\n    apply zero_at_infty_of_norm_le\n    intro Œµ hŒµ\n    use (SchwartzMap.seminorm ‚Ñù 1 0) f / Œµ\n    intro x hx\n    rw [div_lt_iff‚ÇÄ hŒµ] at hx\n    have hxpos : 0 < ‚Äñx‚Äñ := by\n      rw [norm_pos_iff]\n      intro hxzero\n      simp only [hxzero, norm_zero, zero_mul, ‚Üê not_le] at hx\n      exact hx (apply_nonneg (SchwartzMap.seminorm ‚Ñù 1 0) f)\n    have := norm_pow_mul_le_seminorm ‚Ñù f 1 x\n    rw [pow_one, ‚Üê le_div_iff‚ÇÄ' hxpos] at this\n    apply lt_of_le_of_lt this\n    rwa [div_lt_iff‚ÇÄ' hxpos]\n\n"}
{"name":"SchwartzMap.toZeroAtInfty_apply","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"E : Type u_4\nF : Type u_5\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\ninst‚úù : ProperSpace E\nf : SchwartzMap E F\nx : E\n‚ä¢ Eq (f.toZeroAtInfty x) (f x)","decl":"@[simp] theorem toZeroAtInfty_apply (f : ùì¢(E, F)) (x : E) : f.toZeroAtInfty x = f x :=\n  rfl\n\n"}
{"name":"SchwartzMap.toZeroAtInfty_toBCF","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"E : Type u_4\nF : Type u_5\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\ninst‚úù : ProperSpace E\nf : SchwartzMap E F\n‚ä¢ Eq f.toZeroAtInfty.toBCF f.toBoundedContinuousFunction","decl":"@[simp] theorem toZeroAtInfty_toBCF (f : ùì¢(E, F)) :\n    f.toZeroAtInfty.toBCF = f.toBoundedContinuousFunction :=\n  rfl\n\n"}
{"name":"SchwartzMap.toZeroAtInftyCLM_apply","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"ùïú : Type u_1\nE : Type u_4\nF : Type u_5\ninst‚úù‚Å∑ : NormedAddCommGroup E\ninst‚úù‚Å∂ : NormedSpace Real E\ninst‚úù‚Åµ : NormedAddCommGroup F\ninst‚úù‚Å¥ : NormedSpace Real F\ninst‚úù¬≥ : ProperSpace E\ninst‚úù¬≤ : RCLike ùïú\ninst‚úù¬π : NormedSpace ùïú F\ninst‚úù : SMulCommClass Real ùïú F\nf : SchwartzMap E F\nx : E\n‚ä¢ Eq (((SchwartzMap.toZeroAtInftyCLM ùïú E F) f) x) (f x)","decl":"@[simp] theorem toZeroAtInftyCLM_apply (f : ùì¢(E, F)) (x : E) : toZeroAtInftyCLM ùïú E F f x = f x :=\n  rfl\n\n"}
{"name":"SchwartzMap.eLpNorm_le_seminorm","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"ùïú : Type u_1\nE : Type u_4\nF : Type u_5\ninst‚úù‚Å∏ : NormedAddCommGroup E\ninst‚úù‚Å∑ : NormedSpace Real E\ninst‚úù‚Å∂ : NormedAddCommGroup F\ninst‚úù‚Åµ : NormedSpace Real F\ninst‚úù‚Å¥ : MeasurableSpace E\ninst‚úù¬≥ : OpensMeasurableSpace E\ninst‚úù¬≤ : NormedField ùïú\ninst‚úù¬π : NormedSpace ùïú F\ninst‚úù : SMulCommClass Real ùïú F\np : ENNReal\nŒº : autoParam (MeasureTheory.Measure E) _auto‚úù\nhŒº : MeasureTheory.Measure.HasTemperateGrowth Œº\n‚ä¢ Exists fun k => Exists fun C => ‚àÄ (f : SchwartzMap E F), LE.le (MeasureTheory.eLpNorm (‚áëf) p Œº) (HMul.hMul (‚ÜëC) (ENNReal.ofReal (((Finset.Iic { fst := k, snd := 0 }).sup (schwartzSeminormFamily ùïú E F)) f)))","decl":"variable (ùïú F) in\n/-- The `L^p` norm of a Schwartz function is controlled by a finite family of Schwartz seminorms.\n\nThe maximum index `k` and the constant `C` depend on `p` and `Œº`.\n-/\ntheorem eLpNorm_le_seminorm (p : ‚Ñù‚â•0‚àû) (Œº : Measure E := by volume_tac)\n    [hŒº : Œº.HasTemperateGrowth] :\n    ‚àÉ (k : ‚Ñï) (C : ‚Ñù‚â•0), ‚àÄ (f : ùì¢(E, F)), eLpNorm f p Œº ‚â§\n      C * ENNReal.ofReal ((Finset.Iic (k, 0)).sup (schwartzSeminormFamily ùïú E F) f) := by\n  -- Apply H√∂lder's inequality `‚Äñf‚Äñ_p ‚â§ ‚Äñf‚ÇÅ‚Äñ_p * ‚Äñf‚ÇÇ‚Äñ_‚àû` to obtain the `L^p` norm of `f = f‚ÇÅ ‚Ä¢ f‚ÇÇ`\n  -- using `f‚ÇÅ = (1 + ‚Äñx‚Äñ) ^ (-k)` and `f‚ÇÇ = (1 + ‚Äñx‚Äñ) ^ k ‚Ä¢ f x`.\n  rcases hŒº.exists_eLpNorm_lt_top p with ‚ü®k, hk‚ü©\n  refine ‚ü®k, (eLpNorm (fun x ‚Ü¶ (1 + ‚Äñx‚Äñ) ^ (-k : ‚Ñù)) p Œº).toNNReal * 2 ^ k, fun f ‚Ü¶ ?_‚ü©\n  have h_one_add (x : E) : 0 < 1 + ‚Äñx‚Äñ := lt_add_of_pos_of_le zero_lt_one (norm_nonneg x)\n  calc eLpNorm (‚áëf) p Œº\n  _ = eLpNorm ((fun x : E ‚Ü¶ (1 + ‚Äñx‚Äñ) ^ (-k : ‚Ñù)) ‚Ä¢ fun x ‚Ü¶ (1 + ‚Äñx‚Äñ) ^ k ‚Ä¢ f x) p Œº := by\n    refine congrArg (eLpNorm ¬∑ p Œº) (funext fun x ‚Ü¶ ?_)\n    simp [Real.rpow_neg (h_one_add x).le, (h_one_add x).ne']\n  _ ‚â§ eLpNorm (fun x ‚Ü¶ (1 + ‚Äñx‚Äñ) ^ (-k : ‚Ñù)) p Œº * eLpNorm (fun x ‚Ü¶ (1 + ‚Äñx‚Äñ) ^ k ‚Ä¢ f x) ‚ä§ Œº := by\n    refine eLpNorm_smul_le_eLpNorm_mul_eLpNorm_top p _ ?_\n    refine Continuous.aestronglyMeasurable ?_\n    exact .rpow_const (.add continuous_const continuous_norm) fun x ‚Ü¶ .inl (h_one_add x).ne'\n  _ ‚â§ eLpNorm (fun x ‚Ü¶ (1 + ‚Äñx‚Äñ) ^ (-k : ‚Ñù)) p Œº *\n      (2 ^ k * ENNReal.ofReal (((Finset.Iic (k, 0)).sup (schwartzSeminormFamily ùïú E F)) f)) := by\n    gcongr\n    refine eLpNormEssSup_le_of_ae_nnnorm_bound (ae_of_all Œº fun x ‚Ü¶ ?_)\n    rw [‚Üê norm_toNNReal, Real.toNNReal_le_iff_le_coe]\n    simpa [norm_smul, abs_of_nonneg (h_one_add x).le] using\n      one_add_le_sup_seminorm_apply (m := (k, 0)) (le_refl k) (le_refl 0) f x\n  _ = _ := by\n    rw [ENNReal.coe_mul, ENNReal.coe_toNNReal hk.ne]\n    simp only [ENNReal.coe_pow, ENNReal.coe_ofNat]\n    ring\n\n"}
{"name":"SchwartzMap.eLpNorm_lt_top","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"E : Type u_4\nF : Type u_5\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedSpace Real E\ninst‚úù¬≥ : NormedAddCommGroup F\ninst‚úù¬≤ : NormedSpace Real F\ninst‚úù¬π : MeasurableSpace E\ninst‚úù : OpensMeasurableSpace E\nf : SchwartzMap E F\np : ENNReal\nŒº : autoParam (MeasureTheory.Measure E) _auto‚úù\nhŒº : MeasureTheory.Measure.HasTemperateGrowth Œº\n‚ä¢ LT.lt (MeasureTheory.eLpNorm (‚áëf) p Œº) Top.top","decl":"/-- The `L^p` norm of a Schwartz function is finite. -/\ntheorem eLpNorm_lt_top (f : ùì¢(E, F)) (p : ‚Ñù‚â•0‚àû) (Œº : Measure E := by volume_tac)\n    [hŒº : Œº.HasTemperateGrowth] : eLpNorm f p Œº < ‚ä§ := by\n  rcases eLpNorm_le_seminorm ‚Ñù F p Œº with ‚ü®k, C, hC‚ü©\n  exact lt_of_le_of_lt (hC f) (ENNReal.mul_lt_top ENNReal.coe_lt_top ENNReal.ofReal_lt_top)\n\n"}
{"name":"SchwartzMap.mem‚Ñíp_top","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"E : Type u_4\nF : Type u_5\ninst‚úù‚Å∂ : NormedAddCommGroup E\ninst‚úù‚Åµ : NormedSpace Real E\ninst‚úù‚Å¥ : NormedAddCommGroup F\ninst‚úù¬≥ : NormedSpace Real F\ninst‚úù¬≤ : MeasurableSpace E\ninst‚úù¬π : OpensMeasurableSpace E\ninst‚úù : SecondCountableTopologyEither E F\nf : SchwartzMap E F\nŒº : autoParam (MeasureTheory.Measure E) _auto‚úù\n‚ä¢ MeasureTheory.Mem‚Ñíp (‚áëf) Top.top Œº","decl":"/-- Schwartz functions are in `L^‚àû`; does not require `hŒº.HasTemperateGrowth`. -/\ntheorem mem‚Ñíp_top (f : ùì¢(E, F)) (Œº : Measure E := by volume_tac) : Mem‚Ñíp f ‚ä§ Œº := by\n  rcases f.decay 0 0 with ‚ü®C, _, hC‚ü©\n  refine mem‚Ñíp_top_of_bound f.continuous.aestronglyMeasurable C (ae_of_all Œº fun x ‚Ü¶ ?_)\n  simpa using hC x\n\n"}
{"name":"SchwartzMap.mem‚Ñíp","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"E : Type u_4\nF : Type u_5\ninst‚úù‚Å∂ : NormedAddCommGroup E\ninst‚úù‚Åµ : NormedSpace Real E\ninst‚úù‚Å¥ : NormedAddCommGroup F\ninst‚úù¬≥ : NormedSpace Real F\ninst‚úù¬≤ : MeasurableSpace E\ninst‚úù¬π : OpensMeasurableSpace E\ninst‚úù : SecondCountableTopologyEither E F\nf : SchwartzMap E F\np : ENNReal\nŒº : autoParam (MeasureTheory.Measure E) _auto‚úù\nhŒº : MeasureTheory.Measure.HasTemperateGrowth Œº\n‚ä¢ MeasureTheory.Mem‚Ñíp (‚áëf) p Œº","decl":"/-- Schwartz functions are in `L^p` for any `p`. -/\ntheorem mem‚Ñíp (f : ùì¢(E, F)) (p : ‚Ñù‚â•0‚àû) (Œº : Measure E := by volume_tac)\n    [hŒº : Œº.HasTemperateGrowth] : Mem‚Ñíp f p Œº :=\n  ‚ü®f.continuous.aestronglyMeasurable, f.eLpNorm_lt_top p Œº‚ü©\n\n"}
{"name":"SchwartzMap.coeFn_toLp","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"E : Type u_4\nF : Type u_5\ninst‚úù‚Å∂ : NormedAddCommGroup E\ninst‚úù‚Åµ : NormedSpace Real E\ninst‚úù‚Å¥ : NormedAddCommGroup F\ninst‚úù¬≥ : NormedSpace Real F\ninst‚úù¬≤ : MeasurableSpace E\ninst‚úù¬π : OpensMeasurableSpace E\ninst‚úù : SecondCountableTopologyEither E F\nf : SchwartzMap E F\np : ENNReal\nŒº : autoParam (MeasureTheory.Measure E) _auto‚úù\nhŒº : MeasureTheory.Measure.HasTemperateGrowth Œº\n‚ä¢ (MeasureTheory.ae Œº).EventuallyEq ‚Üë‚Üë(f.toLp p Œº) ‚áëf","decl":"theorem coeFn_toLp (f : ùì¢(E, F)) (p : ‚Ñù‚â•0‚àû) (Œº : Measure E := by volume_tac)\n    [hŒº : Œº.HasTemperateGrowth] : f.toLp p Œº =·µê[Œº] f := (f.mem‚Ñíp p Œº).coeFn_toLp\n\n"}
{"name":"SchwartzMap.norm_toLp","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"E : Type u_4\nF : Type u_5\ninst‚úù‚Å∂ : NormedAddCommGroup E\ninst‚úù‚Åµ : NormedSpace Real E\ninst‚úù‚Å¥ : NormedAddCommGroup F\ninst‚úù¬≥ : NormedSpace Real F\ninst‚úù¬≤ : MeasurableSpace E\ninst‚úù¬π : OpensMeasurableSpace E\ninst‚úù : SecondCountableTopologyEither E F\nf : SchwartzMap E F\np : ENNReal\nŒº : MeasureTheory.Measure E\nhŒº : Œº.HasTemperateGrowth\n‚ä¢ Eq (Norm.norm (f.toLp p Œº)) (MeasureTheory.eLpNorm (‚áëf) p Œº).toReal","decl":"theorem norm_toLp {f : ùì¢(E, F)} {p : ‚Ñù‚â•0‚àû} {Œº : Measure E} [hŒº : Œº.HasTemperateGrowth] :\n    ‚Äñf.toLp p Œº‚Äñ = ENNReal.toReal (eLpNorm f p Œº) := by\n  rw [Lp.norm_def, eLpNorm_congr_ae (coeFn_toLp f p Œº)]\n\n"}
{"name":"SchwartzMap.injective_toLp","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"E : Type u_4\nF : Type u_5\ninst‚úù‚Å∑ : NormedAddCommGroup E\ninst‚úù‚Å∂ : NormedSpace Real E\ninst‚úù‚Åµ : NormedAddCommGroup F\ninst‚úù‚Å¥ : NormedSpace Real F\ninst‚úù¬≥ : MeasurableSpace E\ninst‚úù¬≤ : OpensMeasurableSpace E\ninst‚úù¬π : SecondCountableTopologyEither E F\np : ENNReal\nŒº : autoParam (MeasureTheory.Measure E) _auto‚úù\nhŒº : MeasureTheory.Measure.HasTemperateGrowth Œº\ninst‚úù : MeasureTheory.Measure.IsOpenPosMeasure Œº\n‚ä¢ Function.Injective fun f => f.toLp p Œº","decl":"theorem injective_toLp (p : ‚Ñù‚â•0‚àû) (Œº : Measure E := by volume_tac) [hŒº : Œº.HasTemperateGrowth]\n    [Œº.IsOpenPosMeasure] : Function.Injective (fun f : ùì¢(E, F) ‚Ü¶ f.toLp p Œº) :=\n  fun f g ‚Ü¶ by simpa [toLp] using (Continuous.ae_eq_iff_eq Œº f.continuous g.continuous).mp\n\n"}
{"name":"SchwartzMap.norm_toLp_le_seminorm","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"ùïú : Type u_1\nE : Type u_4\nF : Type u_5\ninst‚úù‚Åπ : NormedAddCommGroup E\ninst‚úù‚Å∏ : NormedSpace Real E\ninst‚úù‚Å∑ : NormedAddCommGroup F\ninst‚úù‚Å∂ : NormedSpace Real F\ninst‚úù‚Åµ : MeasurableSpace E\ninst‚úù‚Å¥ : OpensMeasurableSpace E\ninst‚úù¬≥ : NormedField ùïú\ninst‚úù¬≤ : NormedSpace ùïú F\ninst‚úù¬π : SMulCommClass Real ùïú F\ninst‚úù : SecondCountableTopologyEither E F\np : ENNReal\nŒº : autoParam (MeasureTheory.Measure E) _auto‚úù\nhŒº : MeasureTheory.Measure.HasTemperateGrowth Œº\n‚ä¢ Exists fun k => Exists fun C => And (LE.le 0 C) (‚àÄ (f : SchwartzMap E F), LE.le (Norm.norm (f.toLp p Œº)) (HMul.hMul C (((Finset.Iic { fst := k, snd := 0 }).sup (schwartzSeminormFamily ùïú E F)) f)))","decl":"variable (ùïú F) in\ntheorem norm_toLp_le_seminorm (p : ‚Ñù‚â•0‚àû) (Œº : Measure E := by volume_tac)\n    [hŒº : Œº.HasTemperateGrowth] :\n    ‚àÉ k C, 0 ‚â§ C ‚àß ‚àÄ (f : ùì¢(E, F)), ‚Äñf.toLp p Œº‚Äñ ‚â§\n      C * (Finset.Iic (k, 0)).sup (schwartzSeminormFamily ùïú E F) f := by\n  rcases eLpNorm_le_seminorm ùïú F p Œº with ‚ü®k, C, hC‚ü©\n  refine ‚ü®k, C, C.coe_nonneg, fun f ‚Ü¶ ?_‚ü©\n  rw [norm_toLp]\n  refine ENNReal.toReal_le_of_le_ofReal (by simp [mul_nonneg]) ?_\n  rw [ENNReal.ofReal_mul NNReal.zero_le_coe]\n  simpa using hC f\n\n"}
{"name":"SchwartzMap.toLpCLM_apply","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"ùïú : Type u_1\nE : Type u_4\nF : Type u_5\ninst‚úù¬π‚Å∞ : NormedAddCommGroup E\ninst‚úù‚Åπ : NormedSpace Real E\ninst‚úù‚Å∏ : NormedAddCommGroup F\ninst‚úù‚Å∑ : NormedSpace Real F\ninst‚úù‚Å∂ : MeasurableSpace E\ninst‚úù‚Åµ : OpensMeasurableSpace E\ninst‚úù‚Å¥ : NormedField ùïú\ninst‚úù¬≥ : NormedSpace ùïú F\ninst‚úù¬≤ : SMulCommClass Real ùïú F\ninst‚úù¬π : SecondCountableTopologyEither E F\np : ENNReal\ninst‚úù : Fact (LE.le 1 p)\nŒº : MeasureTheory.Measure E\nhŒº : Œº.HasTemperateGrowth\nf : SchwartzMap E F\n‚ä¢ Eq ((SchwartzMap.toLpCLM ùïú F p Œº) f) (f.toLp p Œº)","decl":"@[simp] theorem toLpCLM_apply {p : ‚Ñù‚â•0‚àû} [Fact (1 ‚â§ p)] {Œº : Measure E} [hŒº : Œº.HasTemperateGrowth]\n    {f : ùì¢(E, F)} : toLpCLM ùïú F p Œº f = f.toLp p Œº := rfl\n\n"}
{"name":"SchwartzMap.continuous_toLp","module":"Mathlib.Analysis.Distribution.SchwartzSpace","initialProofState":"E : Type u_4\nF : Type u_5\ninst‚úù‚Å∑ : NormedAddCommGroup E\ninst‚úù‚Å∂ : NormedSpace Real E\ninst‚úù‚Åµ : NormedAddCommGroup F\ninst‚úù‚Å¥ : NormedSpace Real F\ninst‚úù¬≥ : MeasurableSpace E\ninst‚úù¬≤ : OpensMeasurableSpace E\ninst‚úù¬π : SecondCountableTopologyEither E F\np : ENNReal\ninst‚úù : Fact (LE.le 1 p)\nŒº : MeasureTheory.Measure E\nhŒº : Œº.HasTemperateGrowth\n‚ä¢ Continuous fun f => f.toLp p Œº","decl":"@[fun_prop]\ntheorem continuous_toLp {p : ‚Ñù‚â•0‚àû} [Fact (1 ‚â§ p)] {Œº : Measure E} [hŒº : Œº.HasTemperateGrowth] :\n    Continuous (fun f : ùì¢(E, F) ‚Ü¶ f.toLp p Œº) := (toLpCLM ‚Ñù F p Œº).continuous\n\n"}
