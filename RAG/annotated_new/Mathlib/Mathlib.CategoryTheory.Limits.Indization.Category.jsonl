{"name":"CategoryTheory.instFullIndFunctorOppositeTypeInclusion","module":"Mathlib.CategoryTheory.Limits.Indization.Category","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\n⊢ (CategoryTheory.Ind.inclusion C).Full","decl":"instance : (Ind.inclusion C).Full :=\n  inferInstanceAs <| ((Ind.equivalence C).functor ⋙ fullSubcategoryInclusion _).Full\n\n"}
{"name":"CategoryTheory.instFaithfulIndFunctorOppositeTypeInclusion","module":"Mathlib.CategoryTheory.Limits.Indization.Category","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\n⊢ (CategoryTheory.Ind.inclusion C).Faithful","decl":"instance : (Ind.inclusion C).Faithful :=\n  inferInstanceAs <| ((Ind.equivalence C).functor ⋙ fullSubcategoryInclusion _).Faithful\n\n"}
{"name":"CategoryTheory.instFullIndYoneda","module":"Mathlib.CategoryTheory.Limits.Indization.Category","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\n⊢ CategoryTheory.Ind.yoneda.Full","decl":"instance : (Ind.yoneda (C := C)).Full :=\n  inferInstanceAs <| Functor.Full <|\n    FullSubcategory.lift _ CategoryTheory.yoneda isIndObject_yoneda ⋙ (Ind.equivalence C).inverse\n\n"}
{"name":"CategoryTheory.instFaithfulIndYoneda","module":"Mathlib.CategoryTheory.Limits.Indization.Category","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\n⊢ CategoryTheory.Ind.yoneda.Faithful","decl":"instance : (Ind.yoneda (C := C)).Faithful :=\n  inferInstanceAs <| Functor.Faithful <|\n    FullSubcategory.lift _ CategoryTheory.yoneda isIndObject_yoneda ⋙ (Ind.equivalence C).inverse\n\n"}
{"name":"CategoryTheory.instHasFilteredColimitsInd","module":"Mathlib.CategoryTheory.Limits.Indization.Category","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\n⊢ CategoryTheory.Limits.HasFilteredColimits (CategoryTheory.Ind C)","decl":"instance : HasFilteredColimits (Ind C) where\n  HasColimitsOfShape _ _ _ :=\n    hasColimitsOfShape_of_hasColimitsOfShape_createsColimitsOfShape (Ind.inclusion C)\n\n"}
{"name":"CategoryTheory.instHasLimitsOfShapeDiscreteInd","module":"Mathlib.CategoryTheory.Limits.Indization.Category","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nJ : Type v\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Discrete J) C\n⊢ CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Discrete J) (CategoryTheory.Ind C)","decl":"instance {J : Type v} [HasLimitsOfShape (Discrete J) C] :\n    HasLimitsOfShape (Discrete J) (Ind C) :=\n  hasLimitsOfShape_of_hasLimitsOfShape_createsLimitsOfShape (Ind.inclusion C)\n\n"}
{"name":"CategoryTheory.instPreservesLimitsIndYoneda","module":"Mathlib.CategoryTheory.Limits.Indization.Category","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\n⊢ CategoryTheory.Limits.PreservesLimits CategoryTheory.Ind.yoneda","decl":"instance : PreservesLimits (Ind.yoneda (C := C)) :=\n  letI _ : PreservesLimitsOfSize.{v, v} (Ind.yoneda ⋙ Ind.inclusion C) :=\n    preservesLimits_of_natIso Ind.yonedaCompInclusion.symm\n  preservesLimits_of_reflects_of_preserves Ind.yoneda (Ind.inclusion C)\n\n"}
{"name":"CategoryTheory.Ind.isIndObject_inclusion_obj","module":"Mathlib.CategoryTheory.Limits.Indization.Category","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.Ind C\n⊢ CategoryTheory.Limits.IsIndObject ((CategoryTheory.Ind.inclusion C).obj X)","decl":"theorem Ind.isIndObject_inclusion_obj (X : Ind C) : IsIndObject ((Ind.inclusion C).obj X) :=\n  X.2\n\n"}
{"name":"CategoryTheory.instRepresentablyCoflatIndYoneda","module":"Mathlib.CategoryTheory.Limits.Indization.Category","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\n⊢ CategoryTheory.RepresentablyCoflat CategoryTheory.Ind.yoneda","decl":"instance : RepresentablyCoflat (Ind.yoneda (C := C)) := by\n  refine ⟨fun X => ?_⟩\n  suffices IsFiltered (CostructuredArrow yoneda ((Ind.inclusion C).obj X)) from\n    IsFiltered.of_equivalence\n      ((CostructuredArrow.post Ind.yoneda (Ind.inclusion C) X).asEquivalence.trans\n      (CostructuredArrow.mapNatIso Ind.yonedaCompInclusion)).symm\n  exact ((isIndObject_iff _).1 (Ind.isIndObject_inclusion_obj X)).1\n\n"}
{"name":"CategoryTheory.instPreservesFiniteColimitsIndYoneda","module":"Mathlib.CategoryTheory.Limits.Indization.Category","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\n⊢ CategoryTheory.Limits.PreservesFiniteColimits CategoryTheory.Ind.yoneda","decl":"noncomputable instance : PreservesFiniteColimits (Ind.yoneda (C := C)) :=\n  preservesFiniteColimits_of_coflat _\n\n"}
{"name":"CategoryTheory.instPreservesLimitsOfShapeFunctorIndLimOfFinCategoryOfHasLimitsOfShape","module":"Mathlib.CategoryTheory.Limits.Indization.Category","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nα : Type w\ninst✝⁴ : CategoryTheory.SmallCategory α\ninst✝³ : CategoryTheory.FinCategory α\ninst✝² : CategoryTheory.Limits.HasLimitsOfShape α C\nI : Type v\ninst✝¹ : CategoryTheory.SmallCategory I\ninst✝ : CategoryTheory.IsFiltered I\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape α (CategoryTheory.Ind.lim I)","decl":"instance {α : Type w} [SmallCategory α] [FinCategory α] [HasLimitsOfShape α C] {I : Type v}\n    [SmallCategory I] [IsFiltered I] :\n    PreservesLimitsOfShape α (Ind.lim I : (I ⥤ C) ⥤ _) :=\n  haveI : PreservesLimitsOfShape α (Ind.lim I ⋙ Ind.inclusion C) :=\n    preservesLimitsOfShape_of_natIso Ind.limCompInclusion.symm\n  preservesLimitsOfShape_of_reflects_of_preserves _ (Ind.inclusion C)\n\n"}
{"name":"CategoryTheory.instPreservesColimitsOfShapeFunctorIndLimOfFinCategoryOfHasColimitsOfShape","module":"Mathlib.CategoryTheory.Limits.Indization.Category","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nα : Type w\ninst✝⁴ : CategoryTheory.SmallCategory α\ninst✝³ : CategoryTheory.FinCategory α\ninst✝² : CategoryTheory.Limits.HasColimitsOfShape α C\nI : Type v\ninst✝¹ : CategoryTheory.SmallCategory I\ninst✝ : CategoryTheory.IsFiltered I\n⊢ CategoryTheory.Limits.PreservesColimitsOfShape α (CategoryTheory.Ind.lim I)","decl":"instance {α : Type w} [SmallCategory α] [FinCategory α] [HasColimitsOfShape α C] {I : Type v}\n    [SmallCategory I] [IsFiltered I] :\n    PreservesColimitsOfShape α (Ind.lim I : (I ⥤ C) ⥤ _) :=\n  inferInstanceAs (PreservesColimitsOfShape α (_ ⋙ colim))\n\n"}
{"name":"CategoryTheory.instHasColimitsOfShapeDiscreteIndOfFinite","module":"Mathlib.CategoryTheory.Limits.Indization.Category","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nα : Type v\ninst✝¹ : Finite α\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete α) C\n⊢ CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete α) (CategoryTheory.Ind C)","decl":"instance {α : Type v} [Finite α] [HasColimitsOfShape (Discrete α) C] :\n    HasColimitsOfShape (Discrete α) (Ind C) := by\n  refine ⟨fun F => ?_⟩\n  let I : α → Type v := fun s => (F.obj ⟨s⟩).presentation.I\n  let G : ∀ s, I s ⥤ C := fun s => (F.obj ⟨s⟩).presentation.F\n  let iso : Discrete.functor (fun s => Pi.eval I s ⋙ G s) ⋙\n      (whiskeringRight _ _ _).obj Ind.yoneda ⋙ colim ≅ F := by\n    refine Discrete.natIso (fun s => ?_)\n    refine (Functor.Final.colimitIso (Pi.eval I s.as) (G s.as ⋙ Ind.yoneda)) ≪≫ ?_\n    exact Ind.colimitPresentationCompYoneda _\n  -- The actual proof happens during typeclass resolution in the following line, which deduces\n  -- ```\n  -- HasColimit Discrete.functor (fun s => Pi.eval I s ⋙ G s) ⋙\n  --    (whiskeringRight _ _ _).obj Ind.yoneda ⋙ colim\n  -- ```\n  -- from the fact that finite limits commute with filtered colimits and from the fact that\n  -- `Ind.yoneda` preserves finite colimits.\n  exact hasColimitOfIso iso.symm\n\n"}
{"name":"CategoryTheory.instHasCoproductsIndOfHasFiniteCoproducts","module":"Mathlib.CategoryTheory.Limits.Indization.Category","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasFiniteCoproducts C\n⊢ CategoryTheory.Limits.HasCoproducts (CategoryTheory.Ind C)","decl":"instance [HasFiniteCoproducts C] : HasCoproducts.{v} (Ind C) :=\n  have : HasFiniteCoproducts (Ind C) :=\n    ⟨fun _ => hasColimitsOfShape_of_equivalence (Discrete.equivalence Equiv.ulift)⟩\n  hasCoproducts_of_finite_and_filtered\n\n"}
{"name":"CategoryTheory.instHasColimitsOfShapeWalkingParallelPairInd","module":"Mathlib.CategoryTheory.Limits.Indization.Category","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape CategoryTheory.Limits.WalkingParallelPair C\n⊢ CategoryTheory.Limits.HasColimitsOfShape CategoryTheory.Limits.WalkingParallelPair (CategoryTheory.Ind C)","decl":"instance [HasColimitsOfShape WalkingParallelPair C] :\n    HasColimitsOfShape WalkingParallelPair (Ind C) := by\n  refine ⟨fun F => ?_⟩\n  obtain ⟨P⟩ := nonempty_indParallelPairPresentation (F.obj WalkingParallelPair.zero).2\n    (F.obj WalkingParallelPair.one).2 (Ind.inclusion _ |>.map <| F.map WalkingParallelPairHom.left)\n    (Ind.inclusion _ |>.map <| F.map WalkingParallelPairHom.right)\n  exact hasColimitOfIso (diagramIsoParallelPair _ ≪≫ P.parallelPairIsoParallelPairCompIndYoneda)\n\n"}
{"name":"CategoryTheory.Ind.exists_nonempty_arrow_mk_iso_ind_lim","module":"Mathlib.CategoryTheory.Limits.Indization.Category","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA B : CategoryTheory.Ind C\nf : Quiver.Hom A B\n⊢ Exists fun I => Exists fun x => Exists fun x_1 => Exists fun F => Exists fun G => Exists fun φ => Nonempty (CategoryTheory.Iso (CategoryTheory.Arrow.mk f) (CategoryTheory.Arrow.mk ((CategoryTheory.Ind.lim I).map φ)))","decl":"/-- A way to understand morphisms in `Ind C`: every morphism is induced by a natural transformation\nof diagrams. -/\ntheorem Ind.exists_nonempty_arrow_mk_iso_ind_lim {A B : Ind C} {f : A ⟶ B} :\n    ∃ (I : Type v) (_ : SmallCategory I) (_ : IsFiltered I) (F G : I ⥤ C) (φ : F ⟶ G),\n      Nonempty (Arrow.mk f ≅ Arrow.mk ((Ind.lim _).map φ)) := by\n  obtain ⟨P⟩ := nonempty_indParallelPairPresentation A.2 B.2\n    (Ind.inclusion _ |>.map f) (Ind.inclusion _ |>.map f)\n  refine ⟨P.I, inferInstance, inferInstance, P.F₁, P.F₂, P.φ, ⟨Arrow.isoMk ?_ ?_ ?_⟩⟩\n  · exact P.parallelPairIsoParallelPairCompIndYoneda.app WalkingParallelPair.zero\n  · exact P.parallelPairIsoParallelPairCompIndYoneda.app WalkingParallelPair.one\n  · simpa using\n      (P.parallelPairIsoParallelPairCompIndYoneda.hom.naturality WalkingParallelPairHom.left).symm\n\n"}
