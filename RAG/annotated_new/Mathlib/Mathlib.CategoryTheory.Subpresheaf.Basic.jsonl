{"name":"CategoryTheory.Subpresheaf.mk.injEq","module":"Mathlib.CategoryTheory.Subpresheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Opposite C) (Type w)\nobj✝ : (U : Opposite C) → Set (F.obj U)\nmap✝ : ∀ {U V : Opposite C} (i : Quiver.Hom U V), HasSubset.Subset (obj✝ U) (Set.preimage (F.map i) (obj✝ V))\nobj : (U : Opposite C) → Set (F.obj U)\nmap : ∀ {U V : Opposite C} (i : Quiver.Hom U V), HasSubset.Subset (obj U) (Set.preimage (F.map i) (obj V))\n⊢ Eq (Eq { obj := obj✝, map := map✝ } { obj := obj, map := map }) (Eq obj✝ obj)","decl":"/-- A subpresheaf of a presheaf consists of a subset of `F.obj U` for every `U`,\ncompatible with the restriction maps `F.map i`. -/\n@[ext]\nstructure Subpresheaf (F : Cᵒᵖ ⥤ Type w) where\n  /-- If `G` is a sub-presheaf of `F`, then the sections of `G` on `U` forms a subset of sections of\n    `F` on `U`. -/\n  obj : ∀ U, Set (F.obj U)\n  /-- If `G` is a sub-presheaf of `F` and `i : U ⟶ V`, then for each `G`-sections on `U` `x`,\n    `F i x` is in `F(V)`. -/\n  map : ∀ {U V : Cᵒᵖ} (i : U ⟶ V), obj U ⊆ F.map i ⁻¹' obj V\n\n"}
{"name":"CategoryTheory.Subpresheaf.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Subpresheaf.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Opposite C) (Type w)\ninst✝ : SizeOf C\nobj : (U : Opposite C) → Set (F.obj U)\nmap : ∀ {U V : Opposite C} (i : Quiver.Hom U V), HasSubset.Subset (obj U) (Set.preimage (F.map i) (obj V))\n⊢ Eq (SizeOf.sizeOf { obj := obj, map := map }) 1","decl":"/-- A subpresheaf of a presheaf consists of a subset of `F.obj U` for every `U`,\ncompatible with the restriction maps `F.map i`. -/\n@[ext]\nstructure Subpresheaf (F : Cᵒᵖ ⥤ Type w) where\n  /-- If `G` is a sub-presheaf of `F`, then the sections of `G` on `U` forms a subset of sections of\n    `F` on `U`. -/\n  obj : ∀ U, Set (F.obj U)\n  /-- If `G` is a sub-presheaf of `F` and `i : U ⟶ V`, then for each `G`-sections on `U` `x`,\n    `F i x` is in `F(V)`. -/\n  map : ∀ {U V : Cᵒᵖ} (i : U ⟶ V), obj U ⊆ F.map i ⁻¹' obj V\n\n"}
{"name":"CategoryTheory.Subpresheaf.mk.inj","module":"Mathlib.CategoryTheory.Subpresheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Opposite C) (Type w)\nobj✝ : (U : Opposite C) → Set (F.obj U)\nmap✝ : ∀ {U V : Opposite C} (i : Quiver.Hom U V), HasSubset.Subset (obj✝ U) (Set.preimage (F.map i) (obj✝ V))\nobj : (U : Opposite C) → Set (F.obj U)\nmap : ∀ {U V : Opposite C} (i : Quiver.Hom U V), HasSubset.Subset (obj U) (Set.preimage (F.map i) (obj V))\nx✝ : Eq { obj := obj✝, map := map✝ } { obj := obj, map := map }\n⊢ Eq obj✝ obj","decl":"/-- A subpresheaf of a presheaf consists of a subset of `F.obj U` for every `U`,\ncompatible with the restriction maps `F.map i`. -/\n@[ext]\nstructure Subpresheaf (F : Cᵒᵖ ⥤ Type w) where\n  /-- If `G` is a sub-presheaf of `F`, then the sections of `G` on `U` forms a subset of sections of\n    `F` on `U`. -/\n  obj : ∀ U, Set (F.obj U)\n  /-- If `G` is a sub-presheaf of `F` and `i : U ⟶ V`, then for each `G`-sections on `U` `x`,\n    `F i x` is in `F(V)`. -/\n  map : ∀ {U V : Cᵒᵖ} (i : U ⟶ V), obj U ⊆ F.map i ⁻¹' obj V\n\n"}
{"name":"CategoryTheory.Subpresheaf.ext","module":"Mathlib.CategoryTheory.Subpresheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Opposite C) (Type w)\nx y : CategoryTheory.Subpresheaf F\nobj : Eq x.obj y.obj\n⊢ Eq x y","decl":"/-- A subpresheaf of a presheaf consists of a subset of `F.obj U` for every `U`,\ncompatible with the restriction maps `F.map i`. -/\n@[ext]\nstructure Subpresheaf (F : Cᵒᵖ ⥤ Type w) where\n  /-- If `G` is a sub-presheaf of `F`, then the sections of `G` on `U` forms a subset of sections of\n    `F` on `U`. -/\n  obj : ∀ U, Set (F.obj U)\n  /-- If `G` is a sub-presheaf of `F` and `i : U ⟶ V`, then for each `G`-sections on `U` `x`,\n    `F i x` is in `F(V)`. -/\n  map : ∀ {U V : Cᵒᵖ} (i : U ⟶ V), obj U ⊆ F.map i ⁻¹' obj V\n\n"}
{"name":"CategoryTheory.Subpresheaf.ext_iff","module":"Mathlib.CategoryTheory.Subpresheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Opposite C) (Type w)\nx y : CategoryTheory.Subpresheaf F\n⊢ Iff (Eq x y) (Eq x.obj y.obj)","decl":"/-- A subpresheaf of a presheaf consists of a subset of `F.obj U` for every `U`,\ncompatible with the restriction maps `F.map i`. -/\n@[ext]\nstructure Subpresheaf (F : Cᵒᵖ ⥤ Type w) where\n  /-- If `G` is a sub-presheaf of `F`, then the sections of `G` on `U` forms a subset of sections of\n    `F` on `U`. -/\n  obj : ∀ U, Set (F.obj U)\n  /-- If `G` is a sub-presheaf of `F` and `i : U ⟶ V`, then for each `G`-sections on `U` `x`,\n    `F i x` is in `F(V)`. -/\n  map : ∀ {U V : Cᵒᵖ} (i : U ⟶ V), obj U ⊆ F.map i ⁻¹' obj V\n\n"}
{"name":"CategoryTheory.Subpresheaf.map","module":"Mathlib.CategoryTheory.Subpresheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Opposite C) (Type w)\nself : CategoryTheory.Subpresheaf F\nU V : Opposite C\ni : Quiver.Hom U V\n⊢ HasSubset.Subset (self.obj U) (Set.preimage (F.map i) (self.obj V))","decl":"/-- A subpresheaf of a presheaf consists of a subset of `F.obj U` for every `U`,\ncompatible with the restriction maps `F.map i`. -/\n@[ext]\nstructure Subpresheaf (F : Cᵒᵖ ⥤ Type w) where\n  /-- If `G` is a sub-presheaf of `F`, then the sections of `G` on `U` forms a subset of sections of\n    `F` on `U`. -/\n  obj : ∀ U, Set (F.obj U)\n  /-- If `G` is a sub-presheaf of `F` and `i : U ⟶ V`, then for each `G`-sections on `U` `x`,\n    `F i x` is in `F(V)`. -/\n  map : ∀ {U V : Cᵒᵖ} (i : U ⟶ V), obj U ⊆ F.map i ⁻¹' obj V\n\n"}
{"name":"CategoryTheory.Subpresheaf.le_def","module":"Mathlib.CategoryTheory.Subpresheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Opposite C) (Type w)\nS T : CategoryTheory.Subpresheaf F\n⊢ Iff (LE.le S T) (∀ (U : Opposite C), LE.le (S.obj U) (T.obj U))","decl":"lemma le_def (S T : Subpresheaf F) : S ≤ T ↔ ∀ U, S.obj U ≤ T.obj U := Iff.rfl\n\n"}
{"name":"CategoryTheory.Subpresheaf.top_obj","module":"Mathlib.CategoryTheory.Subpresheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Opposite C) (Type w)\ni : Opposite C\n⊢ Eq (Top.top.obj i) Top.top","decl":"@[simp] lemma top_obj (i : Cᵒᵖ) : (⊤ : Subpresheaf F).obj i = ⊤ := rfl\n"}
{"name":"CategoryTheory.Subpresheaf.bot_obj","module":"Mathlib.CategoryTheory.Subpresheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Opposite C) (Type w)\ni : Opposite C\n⊢ Eq (Bot.bot.obj i) Bot.bot","decl":"@[simp] lemma bot_obj (i : Cᵒᵖ) : (⊥ : Subpresheaf F).obj i = ⊥ := rfl\n\n"}
{"name":"CategoryTheory.Subpresheaf.sSup_obj","module":"Mathlib.CategoryTheory.Subpresheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Opposite C) (Type w)\nS : Set (CategoryTheory.Subpresheaf F)\nU : Opposite C\n⊢ Eq ((SupSet.sSup S).obj U) (SupSet.sSup (Set.image (fun T => T.obj U) S))","decl":"lemma sSup_obj (S : Set (Subpresheaf F)) (U : Cᵒᵖ) :\n    (sSup S).obj U = sSup (Set.image (fun T ↦ T.obj U) S) := rfl\n\n"}
{"name":"CategoryTheory.Subpresheaf.sInf_obj","module":"Mathlib.CategoryTheory.Subpresheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Opposite C) (Type w)\nS : Set (CategoryTheory.Subpresheaf F)\nU : Opposite C\n⊢ Eq ((InfSet.sInf S).obj U) (InfSet.sInf (Set.image (fun T => T.obj U) S))","decl":"lemma sInf_obj (S : Set (Subpresheaf F)) (U : Cᵒᵖ) :\n    (sInf S).obj U = sInf (Set.image (fun T ↦ T.obj U) S) := rfl\n\n"}
{"name":"CategoryTheory.Subpresheaf.iSup_obj","module":"Mathlib.CategoryTheory.Subpresheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Opposite C) (Type w)\nι : Type u_1\nS : ι → CategoryTheory.Subpresheaf F\nU : Opposite C\n⊢ Eq ((iSup fun i => S i).obj U) (Set.iUnion fun i => (S i).obj U)","decl":"@[simp]\nlemma iSup_obj {ι : Type*} (S : ι → Subpresheaf F) (U : Cᵒᵖ) :\n    (⨆ i, S i).obj U = ⋃ i, (S i).obj U := by\n  simp [iSup, sSup_obj]\n\n"}
{"name":"CategoryTheory.Subpresheaf.iInf_obj","module":"Mathlib.CategoryTheory.Subpresheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Opposite C) (Type w)\nι : Type u_1\nS : ι → CategoryTheory.Subpresheaf F\nU : Opposite C\n⊢ Eq ((iInf fun i => S i).obj U) (Set.iInter fun i => (S i).obj U)","decl":"@[simp]\nlemma iInf_obj {ι : Type*} (S : ι → Subpresheaf F) (U : Cᵒᵖ) :\n    (⨅ i, S i).obj U = ⋂ i, (S i).obj U := by\n  simp [iInf, sInf_obj]\n\n"}
{"name":"CategoryTheory.Subpresheaf.max_obj","module":"Mathlib.CategoryTheory.Subpresheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Opposite C) (Type w)\nS T : CategoryTheory.Subpresheaf F\ni : Opposite C\n⊢ Eq ((Max.max S T).obj i) (Union.union (S.obj i) (T.obj i))","decl":"@[simp]\nlemma max_obj (S T : Subpresheaf F) (i : Cᵒᵖ) :\n    (S ⊔ T).obj i = S.obj i ∪ T.obj i := rfl\n\n"}
{"name":"CategoryTheory.Subpresheaf.min_obj","module":"Mathlib.CategoryTheory.Subpresheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Opposite C) (Type w)\nS T : CategoryTheory.Subpresheaf F\ni : Opposite C\n⊢ Eq ((Min.min S T).obj i) (Inter.inter (S.obj i) (T.obj i))","decl":"@[simp]\nlemma min_obj (S T : Subpresheaf F) (i : Cᵒᵖ) :\n    (S ⊓ T).obj i = S.obj i ∩ T.obj i := rfl\n\n"}
{"name":"CategoryTheory.Subpresheaf.max_min","module":"Mathlib.CategoryTheory.Subpresheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Opposite C) (Type w)\nS₁ S₂ T : CategoryTheory.Subpresheaf F\n⊢ Eq (Min.min (Max.max S₁ S₂) T) (Max.max (Min.min S₁ T) (Min.min S₂ T))","decl":"lemma max_min (S₁ S₂ T : Subpresheaf F) :\n    (S₁ ⊔ S₂) ⊓ T = (S₁ ⊓ T) ⊔ (S₂ ⊓ T) := by\n  aesop\n\n"}
{"name":"CategoryTheory.Subpresheaf.iSup_min","module":"Mathlib.CategoryTheory.Subpresheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Opposite C) (Type w)\nι : Type u_1\nS : ι → CategoryTheory.Subpresheaf F\nT : CategoryTheory.Subpresheaf F\n⊢ Eq (Min.min (iSup fun i => S i) T) (iSup fun i => Min.min (S i) T)","decl":"lemma iSup_min {ι : Type*} (S : ι → Subpresheaf F) (T : Subpresheaf F) :\n    (⨆ i, S i) ⊓ T = ⨆ i, S i ⊓ T := by\n  aesop\n\n"}
{"name":"CategoryTheory.Subpresheaf.instNonempty","module":"Mathlib.CategoryTheory.Subpresheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Opposite C) (Type w)\n⊢ Nonempty (CategoryTheory.Subpresheaf F)","decl":"instance : Nonempty (Subpresheaf F) :=\n  inferInstance\n\n"}
{"name":"CategoryTheory.Subpresheaf.toPresheaf_obj","module":"Mathlib.CategoryTheory.Subpresheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Opposite C) (Type w)\nG : CategoryTheory.Subpresheaf F\nU : Opposite C\n⊢ Eq (G.toPresheaf.obj U) ↑(G.obj U)","decl":"/-- The subpresheaf as a presheaf. -/\n@[simps!]\ndef toPresheaf : Cᵒᵖ ⥤ Type w where\n  obj U := G.obj U\n  map := @fun _ _ i x => ⟨F.map i x, G.map i x.prop⟩\n  map_id X := by\n    ext ⟨x, _⟩\n    dsimp\n    simp only [FunctorToTypes.map_id_apply]\n  map_comp := @fun X Y Z i j => by\n    ext ⟨x, _⟩\n    dsimp\n    simp only [FunctorToTypes.map_comp_apply]\n\n"}
{"name":"CategoryTheory.Subpresheaf.toPresheaf_map_coe","module":"Mathlib.CategoryTheory.Subpresheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Opposite C) (Type w)\nG : CategoryTheory.Subpresheaf F\nx✝¹ x✝ : Opposite C\ni : Quiver.Hom x✝¹ x✝\nx : ↑(G.obj x✝¹)\n⊢ Eq (↑(G.toPresheaf.map i x)) (F.map i ↑x)","decl":"/-- The subpresheaf as a presheaf. -/\n@[simps!]\ndef toPresheaf : Cᵒᵖ ⥤ Type w where\n  obj U := G.obj U\n  map := @fun _ _ i x => ⟨F.map i x, G.map i x.prop⟩\n  map_id X := by\n    ext ⟨x, _⟩\n    dsimp\n    simp only [FunctorToTypes.map_id_apply]\n  map_comp := @fun X Y Z i j => by\n    ext ⟨x, _⟩\n    dsimp\n    simp only [FunctorToTypes.map_comp_apply]\n\n"}
{"name":"CategoryTheory.Subpresheaf.ι_app","module":"Mathlib.CategoryTheory.Subpresheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Opposite C) (Type w)\nG : CategoryTheory.Subpresheaf F\nx✝ : Opposite C\nx : G.toPresheaf.obj x✝\n⊢ Eq (G.ι.app x✝ x) ↑x","decl":"/-- The inclusion of a subpresheaf to the original presheaf. -/\n@[simps]\ndef ι : G.toPresheaf ⟶ F where app _ x := x\n\n"}
{"name":"CategoryTheory.Subpresheaf.instMonoFunctorOppositeTypeι","module":"Mathlib.CategoryTheory.Subpresheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Opposite C) (Type w)\nG : CategoryTheory.Subpresheaf F\n⊢ CategoryTheory.Mono G.ι","decl":"instance : Mono G.ι :=\n  ⟨@fun _ _ _ e =>\n    NatTrans.ext <|\n      funext fun U => funext fun x => Subtype.ext <| congr_fun (congr_app e U) x⟩\n\n"}
{"name":"CategoryTheory.Subpresheaf.homOfLe_app_coe","module":"Mathlib.CategoryTheory.Subpresheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Opposite C) (Type w)\nG G' : CategoryTheory.Subpresheaf F\nh : LE.le G G'\nU : Opposite C\nx : G.toPresheaf.obj U\n⊢ Eq ↑((CategoryTheory.Subpresheaf.homOfLe h).app U x) ↑x","decl":"/-- The inclusion of a subpresheaf to a larger subpresheaf -/\n@[simps]\ndef homOfLe {G G' : Subpresheaf F} (h : G ≤ G') : G.toPresheaf ⟶ G'.toPresheaf where\n  app U x := ⟨x, h U x.prop⟩\n\n"}
{"name":"CategoryTheory.Subpresheaf.instMonoFunctorOppositeTypeHomOfLe","module":"Mathlib.CategoryTheory.Subpresheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Opposite C) (Type w)\nG G' : CategoryTheory.Subpresheaf F\nh : LE.le G G'\n⊢ CategoryTheory.Mono (CategoryTheory.Subpresheaf.homOfLe h)","decl":"instance {G G' : Subpresheaf F} (h : G ≤ G') : Mono (Subpresheaf.homOfLe h) :=\n  ⟨fun _ _ e =>\n    NatTrans.ext <|\n      funext fun U =>\n        funext fun x =>\n          Subtype.ext <| (congr_arg Subtype.val <| (congr_fun (congr_app e U) x :) :)⟩\n\n"}
{"name":"CategoryTheory.Subpresheaf.homOfLe_ι_assoc","module":"Mathlib.CategoryTheory.Subpresheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Opposite C) (Type w)\nG G' : CategoryTheory.Subpresheaf F\nh✝ : LE.le G G'\nZ : CategoryTheory.Functor (Opposite C) (Type w)\nh : Quiver.Hom F Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subpresheaf.homOfLe h✝) (CategoryTheory.CategoryStruct.comp G'.ι h)) (CategoryTheory.CategoryStruct.comp G.ι h)","decl":"@[reassoc (attr := simp)]\ntheorem homOfLe_ι {G G' : Subpresheaf F} (h : G ≤ G') :\n    Subpresheaf.homOfLe h ≫ G'.ι = G.ι := by\n  ext\n  rfl\n\n"}
{"name":"CategoryTheory.Subpresheaf.homOfLe_ι","module":"Mathlib.CategoryTheory.Subpresheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Opposite C) (Type w)\nG G' : CategoryTheory.Subpresheaf F\nh : LE.le G G'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subpresheaf.homOfLe h) G'.ι) G.ι","decl":"@[reassoc (attr := simp)]\ntheorem homOfLe_ι {G G' : Subpresheaf F} (h : G ≤ G') :\n    Subpresheaf.homOfLe h ≫ G'.ι = G.ι := by\n  ext\n  rfl\n\n"}
{"name":"CategoryTheory.Subpresheaf.instIsIsoFunctorOppositeTypeιTop","module":"Mathlib.CategoryTheory.Subpresheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Opposite C) (Type w)\n⊢ CategoryTheory.IsIso Top.top.ι","decl":"instance : IsIso (Subpresheaf.ι (⊤ : Subpresheaf F)) := by\n  refine @NatIso.isIso_of_isIso_app _ _ _ _ _ _ _ ?_\n  intro X\n  rw [isIso_iff_bijective]\n  exact ⟨Subtype.coe_injective, fun x => ⟨⟨x, _root_.trivial⟩, rfl⟩⟩\n\n"}
{"name":"CategoryTheory.Subpresheaf.eq_top_iff_isIso","module":"Mathlib.CategoryTheory.Subpresheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Opposite C) (Type w)\nG : CategoryTheory.Subpresheaf F\n⊢ Iff (Eq G Top.top) (CategoryTheory.IsIso G.ι)","decl":"theorem eq_top_iff_isIso : G = ⊤ ↔ IsIso G.ι := by\n  constructor\n  · rintro rfl\n    infer_instance\n  · intro H\n    ext U x\n    apply (iff_of_eq (iff_true _)).mpr\n    rw [← IsIso.inv_hom_id_apply (G.ι.app U) x]\n    exact ((inv (G.ι.app U)) x).2\n\n"}
{"name":"CategoryTheory.Subpresheaf.nat_trans_naturality","module":"Mathlib.CategoryTheory.Subpresheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF F' : CategoryTheory.Functor (Opposite C) (Type w)\nG : CategoryTheory.Subpresheaf F\nf : Quiver.Hom F' G.toPresheaf\nU V : Opposite C\ni : Quiver.Hom U V\nx : F'.obj U\n⊢ Eq (↑(f.app V (F'.map i x))) (F.map i ↑(f.app U x))","decl":"theorem nat_trans_naturality (f : F' ⟶ G.toPresheaf) {U V : Cᵒᵖ} (i : U ⟶ V)\n    (x : F'.obj U) : (f.app V (F'.map i x)).1 = F.map i (f.app U x).1 :=\n  congr_arg Subtype.val (FunctorToTypes.naturality _ _ f i x)\n\n"}
{"name":"CategoryTheory.top_subpresheaf_obj","module":"Mathlib.CategoryTheory.Subpresheaf.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Opposite C) (Type w)\ni : Opposite C\n⊢ Eq (Top.top.obj i) Top.top","decl":"@[deprecated (since := \"2025-01-23\")] alias top_subpresheaf_obj := Subpresheaf.top_obj\n\n"}
