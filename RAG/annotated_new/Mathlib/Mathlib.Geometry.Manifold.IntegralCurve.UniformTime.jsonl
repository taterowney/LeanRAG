{"name":"eqOn_of_isIntegralCurveOn_Ioo","module":"Mathlib.Geometry.Manifold.IntegralCurve.UniformTime","initialProofState":"E : Type u_1\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace Real E\nH : Type u_2\ninst✝⁵ : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type u_3\ninst✝⁴ : TopologicalSpace M\ninst✝³ : ChartedSpace H M\ninst✝² : IsManifold I 1 M\ninst✝¹ : T2Space M\nv : (x : M) → TangentSpace I x\ninst✝ : BoundarylessManifold I M\nhv : ContMDiff I I.tangent 1 fun x => { proj := x, snd := v x }\nx : M\nγ : Real → Real → M\nhγx : ∀ (a : Real), Eq (γ a 0) x\nhγ : ∀ (a : Real), GT.gt a 0 → IsIntegralCurveOn (γ a) v (Set.Ioo (Neg.neg a) a)\na a' : Real\nhpos : LT.lt 0 a'\nhle : LE.le a' a\n⊢ Set.EqOn (γ a') (γ a) (Set.Ioo (Neg.neg a') a')","decl":"/-- This is the uniqueness theorem of integral curves applied to a real-indexed family of integral\n  curves with the same starting point. -/\nlemma eqOn_of_isIntegralCurveOn_Ioo [BoundarylessManifold I M]\n    (hv : ContMDiff I I.tangent 1 (fun x ↦ (⟨x, v x⟩ : TangentBundle I M))) {x : M}\n    (γ : ℝ → ℝ → M) (hγx : ∀ a, γ a 0 = x) (hγ : ∀ a > 0, IsIntegralCurveOn (γ a) v (Ioo (-a) a))\n    {a a' : ℝ} (hpos : 0 < a') (hle : a' ≤ a) :\n    EqOn (γ a') (γ a) (Ioo (-a') a') := by\n  apply isIntegralCurveOn_Ioo_eqOn_of_contMDiff_boundaryless _ hv\n    (hγ a' (by positivity)) ((hγ a (gt_of_ge_of_gt hle hpos)).mono _)\n    (by rw [hγx a, hγx a'])\n  · rw [mem_Ioo]\n    exact ⟨neg_lt_zero.mpr hpos, by positivity⟩\n  · apply Ioo_subset_Ioo <;> linarith\n\n"}
{"name":"eqOn_abs_add_one_of_isIntegralCurveOn_Ioo","module":"Mathlib.Geometry.Manifold.IntegralCurve.UniformTime","initialProofState":"E : Type u_1\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace Real E\nH : Type u_2\ninst✝⁵ : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type u_3\ninst✝⁴ : TopologicalSpace M\ninst✝³ : ChartedSpace H M\ninst✝² : IsManifold I 1 M\ninst✝¹ : T2Space M\nv : (x : M) → TangentSpace I x\ninst✝ : BoundarylessManifold I M\nhv : ContMDiff I I.tangent 1 fun x => { proj := x, snd := v x }\nx : M\nγ : Real → Real → M\nhγx : ∀ (a : Real), Eq (γ a 0) x\nhγ : ∀ (a : Real), GT.gt a 0 → IsIntegralCurveOn (γ a) v (Set.Ioo (Neg.neg a) a)\na : Real\n⊢ Set.EqOn (fun t => γ (HAdd.hAdd (abs t) 1) t) (γ a) (Set.Ioo (Neg.neg a) a)","decl":"/-- For a family of integral curves `γ : ℝ → ℝ → M` with the same starting point `γ 0 = x` such that\n  each `γ a` is defined on `Ioo (-a) a`, the global curve `γ_ext := fun t ↦ γ (|t| + 1) t` agrees\n  with each `γ a` on `Ioo (-a) a`. This will help us show that `γ_ext` is a global integral\n  curve. -/\nlemma eqOn_abs_add_one_of_isIntegralCurveOn_Ioo [BoundarylessManifold I M]\n    (hv : ContMDiff I I.tangent 1 (fun x ↦ (⟨x, v x⟩ : TangentBundle I M))) {x : M}\n    (γ : ℝ → ℝ → M) (hγx : ∀ a, γ a 0 = x) (hγ : ∀ a > 0, IsIntegralCurveOn (γ a) v (Ioo (-a) a))\n    {a : ℝ} : EqOn (fun t ↦ γ (|t| + 1) t) (γ a) (Ioo (-a) a) := by\n  intros t ht\n  by_cases hlt : |t| + 1 < a\n  · exact eqOn_of_isIntegralCurveOn_Ioo hv γ hγx hγ\n      (by positivity) hlt.le (abs_lt.mp <| lt_add_one _)\n  · exact eqOn_of_isIntegralCurveOn_Ioo hv γ hγx hγ\n      (neg_lt_self_iff.mp <| lt_trans ht.1 ht.2) (not_lt.mp hlt) ht |>.symm\n\n"}
{"name":"isIntegralCurve_abs_add_one_of_isIntegralCurveOn_Ioo","module":"Mathlib.Geometry.Manifold.IntegralCurve.UniformTime","initialProofState":"E : Type u_1\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace Real E\nH : Type u_2\ninst✝⁵ : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type u_3\ninst✝⁴ : TopologicalSpace M\ninst✝³ : ChartedSpace H M\ninst✝² : IsManifold I 1 M\ninst✝¹ : T2Space M\nv : (x : M) → TangentSpace I x\ninst✝ : BoundarylessManifold I M\nhv : ContMDiff I I.tangent 1 fun x => { proj := x, snd := v x }\nx : M\nγ : Real → Real → M\nhγx : ∀ (a : Real), Eq (γ a 0) x\nhγ : ∀ (a : Real), GT.gt a 0 → IsIntegralCurveOn (γ a) v (Set.Ioo (Neg.neg a) a)\n⊢ IsIntegralCurve (fun t => γ (HAdd.hAdd (abs t) 1) t) v","decl":"/-- For a family of integral curves `γ : ℝ → ℝ → M` with the same starting point `γ 0 = x` such that\n  each `γ a` is defined on `Ioo (-a) a`, the function `γ_ext := fun t ↦ γ (|t| + 1) t` is a global\n  integral curve. -/\nlemma isIntegralCurve_abs_add_one_of_isIntegralCurveOn_Ioo [BoundarylessManifold I M]\n    (hv : ContMDiff I I.tangent 1 (fun x ↦ (⟨x, v x⟩ : TangentBundle I M))) {x : M}\n    (γ : ℝ → ℝ → M) (hγx : ∀ a, γ a 0 = x) (hγ : ∀ a > 0, IsIntegralCurveOn (γ a) v (Ioo (-a) a)) :\n    IsIntegralCurve (fun t ↦ γ (|t| + 1) t) v := by\n  intro t\n  apply HasMFDerivAt.congr_of_eventuallyEq (f := γ (|t| + 1))\n  · apply hγ (|t| + 1) (by positivity)\n    rw [mem_Ioo, ← abs_lt]\n    exact lt_add_one _\n  · rw [Filter.eventuallyEq_iff_exists_mem]\n    refine ⟨Ioo (-(|t| + 1)) (|t| + 1), ?_,\n      eqOn_abs_add_one_of_isIntegralCurveOn_Ioo hv γ hγx hγ⟩\n    have : |t| < |t| + 1 := lt_add_of_pos_right |t| zero_lt_one\n    rw [abs_lt] at this\n    exact Ioo_mem_nhds this.1 this.2\n\n"}
{"name":"exists_isIntegralCurve_iff_exists_isIntegralCurveOn_Ioo","module":"Mathlib.Geometry.Manifold.IntegralCurve.UniformTime","initialProofState":"E : Type u_1\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace Real E\nH : Type u_2\ninst✝⁵ : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type u_3\ninst✝⁴ : TopologicalSpace M\ninst✝³ : ChartedSpace H M\ninst✝² : IsManifold I 1 M\ninst✝¹ : T2Space M\nv : (x : M) → TangentSpace I x\ninst✝ : BoundarylessManifold I M\nhv : ContMDiff I I.tangent 1 fun x => { proj := x, snd := v x }\nx : M\n⊢ Iff (Exists fun γ => And (Eq (γ 0) x) (IsIntegralCurve γ v)) (∀ (a : Real), Exists fun γ => And (Eq (γ 0) x) (IsIntegralCurveOn γ v (Set.Ioo (Neg.neg a) a)))","decl":"/-- The existence of a global integral curve is equivalent to the existence of a family of local\n  integral curves `γ : ℝ → ℝ → M` with the same starting point `γ 0 = x` such that each `γ a` is\n  defined on `Ioo (-a) a`. -/\nlemma exists_isIntegralCurve_iff_exists_isIntegralCurveOn_Ioo [BoundarylessManifold I M]\n    (hv : ContMDiff I I.tangent 1 (fun x ↦ (⟨x, v x⟩ : TangentBundle I M))) (x : M) :\n    (∃ γ, γ 0 = x ∧ IsIntegralCurve γ v) ↔\n      ∀ a, ∃ γ, γ 0 = x ∧ IsIntegralCurveOn γ v (Ioo (-a) a) := by\n  refine ⟨fun ⟨γ, h1, h2⟩ _ ↦ ⟨γ, h1, h2.isIntegralCurveOn _⟩, fun h ↦ ?_⟩\n  choose γ hγx hγ using h\n  exact ⟨fun t ↦ γ (|t| + 1) t, hγx (|0| + 1),\n    isIntegralCurve_abs_add_one_of_isIntegralCurveOn_Ioo hv γ hγx (fun a _ ↦  hγ a)⟩\n\n"}
{"name":"eqOn_piecewise_of_isIntegralCurveOn_Ioo","module":"Mathlib.Geometry.Manifold.IntegralCurve.UniformTime","initialProofState":"E : Type u_1\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace Real E\nH : Type u_2\ninst✝⁵ : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type u_3\ninst✝⁴ : TopologicalSpace M\ninst✝³ : ChartedSpace H M\ninst✝² : IsManifold I 1 M\ninst✝¹ : T2Space M\nγ γ' : Real → M\nv : (x : M) → TangentSpace I x\nt₀ : Real\ninst✝ : BoundarylessManifold I M\nhv : ContMDiff I I.tangent 1 fun x => { proj := x, snd := v x }\na b a' b' : Real\nhγ : IsIntegralCurveOn γ v (Set.Ioo a b)\nhγ' : IsIntegralCurveOn γ' v (Set.Ioo a' b')\nht₀ : Membership.mem (Inter.inter (Set.Ioo a b) (Set.Ioo a' b')) t₀\nh : Eq (γ t₀) (γ' t₀)\n⊢ Set.EqOn ((Set.Ioo a b).piecewise γ γ') γ' (Set.Ioo a' b')","decl":"/-- Let `γ` and `γ'` be integral curves defined on `Ioo a b` and `Ioo a' b'`, respectively. Then,\n  `piecewise (Ioo a b) γ γ'` is equal to `γ` and `γ'` in their respective domains.\n  `Set.piecewise_eqOn` shows the equality for `γ` by definition, while this lemma shows the equality\n  for `γ'` by the uniqueness of integral curves. -/\nlemma eqOn_piecewise_of_isIntegralCurveOn_Ioo [BoundarylessManifold I M]\n    (hv : ContMDiff I I.tangent 1 (fun x ↦ (⟨x, v x⟩ : TangentBundle I M)))\n    {a b a' b' : ℝ} (hγ : IsIntegralCurveOn γ v (Ioo a b))\n    (hγ' : IsIntegralCurveOn γ' v (Ioo a' b'))\n    (ht₀ : t₀ ∈ Ioo a b ∩ Ioo a' b') (h : γ t₀ = γ' t₀) :\n    EqOn (piecewise (Ioo a b) γ γ') γ' (Ioo a' b') := by\n  intros t ht\n  suffices H : EqOn γ γ' (Ioo (max a a') (min b b')) by\n    by_cases hmem : t ∈ Ioo a b\n    · rw [piecewise, if_pos hmem]\n      apply H\n      simp [ht.1, ht.2, hmem.1, hmem.2]\n    · rw [piecewise, if_neg hmem]\n  apply isIntegralCurveOn_Ioo_eqOn_of_contMDiff_boundaryless _ hv\n    (hγ.mono (Ioo_subset_Ioo (le_max_left ..) (min_le_left ..)))\n    (hγ'.mono (Ioo_subset_Ioo (le_max_right ..) (min_le_right ..))) h\n  exact ⟨max_lt ht₀.1.1 ht₀.2.1, lt_min ht₀.1.2 ht₀.2.2⟩\n\n"}
{"name":"isIntegralCurveOn_piecewise","module":"Mathlib.Geometry.Manifold.IntegralCurve.UniformTime","initialProofState":"E : Type u_1\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace Real E\nH : Type u_2\ninst✝⁵ : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type u_3\ninst✝⁴ : TopologicalSpace M\ninst✝³ : ChartedSpace H M\ninst✝² : IsManifold I 1 M\ninst✝¹ : T2Space M\nγ γ' : Real → M\nv : (x : M) → TangentSpace I x\ninst✝ : BoundarylessManifold I M\nhv : ContMDiff I I.tangent 1 fun x => { proj := x, snd := v x }\na b a' b' : Real\nhγ : IsIntegralCurveOn γ v (Set.Ioo a b)\nhγ' : IsIntegralCurveOn γ' v (Set.Ioo a' b')\nt₀ : Real\nht₀ : Membership.mem (Inter.inter (Set.Ioo a b) (Set.Ioo a' b')) t₀\nh : Eq (γ t₀) (γ' t₀)\n⊢ IsIntegralCurveOn ((Set.Ioo a b).piecewise γ γ') v (Union.union (Set.Ioo a b) (Set.Ioo a' b'))","decl":"/-- The extension of an integral curve by another integral curve is an integral curve.\n\n  If two integral curves are defined on overlapping open intervals, and they agree at a point in\n  their common domain, then they can be patched together to form a longer integral curve.\n\n  This is stated for manifolds without boundary for simplicity. We actually only need to assume that\n  the images of `γ` and `γ'` lie in the interior of the manifold. TODO: Generalise to manifolds with\n  boundary. -/\nlemma isIntegralCurveOn_piecewise [BoundarylessManifold I M]\n    (hv : ContMDiff I I.tangent 1 (fun x ↦ (⟨x, v x⟩ : TangentBundle I M)))\n    {a b a' b' : ℝ} (hγ : IsIntegralCurveOn γ v (Ioo a b))\n    (hγ' : IsIntegralCurveOn γ' v (Ioo a' b')) {t₀ : ℝ}\n    (ht₀ : t₀ ∈ Ioo a b ∩ Ioo a' b') (h : γ t₀ = γ' t₀) :\n    IsIntegralCurveOn (piecewise (Ioo a b) γ γ') v (Ioo a b ∪ Ioo a' b') := by\n  intros t ht\n  by_cases hmem : t ∈ Ioo a b\n  · rw [piecewise, if_pos hmem]\n    apply (hγ t hmem).congr_of_eventuallyEq\n    rw [Filter.eventuallyEq_iff_exists_mem]\n    refine ⟨Ioo a b, isOpen_Ioo.mem_nhds hmem, ?_⟩\n    intros t' ht'\n    rw [piecewise, if_pos ht']\n  · rw [mem_union, or_iff_not_imp_left] at ht\n    rw [piecewise, if_neg hmem]\n    apply (hγ' t <| ht hmem).congr_of_eventuallyEq\n    rw [Filter.eventuallyEq_iff_exists_mem]\n    exact ⟨Ioo a' b', isOpen_Ioo.mem_nhds <| ht hmem,\n      eqOn_piecewise_of_isIntegralCurveOn_Ioo hv hγ hγ' ht₀ h⟩\n\n"}
{"name":"exists_isIntegralCurve_of_isIntegralCurveOn","module":"Mathlib.Geometry.Manifold.IntegralCurve.UniformTime","initialProofState":"E : Type u_1\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace Real E\nH : Type u_2\ninst✝⁵ : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type u_3\ninst✝⁴ : TopologicalSpace M\ninst✝³ : ChartedSpace H M\ninst✝² : IsManifold I 1 M\ninst✝¹ : T2Space M\ninst✝ : BoundarylessManifold I M\nv : (x : M) → TangentSpace I x\nhv : ContMDiff I I.tangent 1 fun x => { proj := x, snd := v x }\nε : Real\nhε : LT.lt 0 ε\nh : ∀ (x : M), Exists fun γ => And (Eq (γ 0) x) (IsIntegralCurveOn γ v (Set.Ioo (Neg.neg ε) ε))\nx : M\n⊢ Exists fun γ => And (Eq (γ 0) x) (IsIntegralCurve γ v)","decl":"/-- If there exists `ε > 0` such that the local integral curve at each point `x : M` is defined at\n  least on an open interval `Ioo (-ε) ε`, then every point on `M` has a global integral\n  curve passing through it.\n\n  See Lemma 9.15, [J.M. Lee (2012)][lee2012]. -/\nlemma exists_isIntegralCurve_of_isIntegralCurveOn [BoundarylessManifold I M]\n    {v : (x : M) → TangentSpace I x}\n    (hv : ContMDiff I I.tangent 1 (fun x ↦ (⟨x, v x⟩ : TangentBundle I M)))\n    {ε : ℝ} (hε : 0 < ε) (h : ∀ x : M, ∃ γ : ℝ → M, γ 0 = x ∧ IsIntegralCurveOn γ v (Ioo (-ε) ε))\n    (x : M) : ∃ γ : ℝ → M, γ 0 = x ∧ IsIntegralCurve γ v := by\n  let s := { a | ∃ γ, γ 0 = x ∧ IsIntegralCurveOn γ v (Ioo (-a) a) }\n  suffices hbdd : ¬BddAbove s by\n    rw [not_bddAbove_iff] at hbdd\n    rw [exists_isIntegralCurve_iff_exists_isIntegralCurveOn_Ioo hv]\n    intro a\n    obtain ⟨y, ⟨γ, hγ1, hγ2⟩, hlt⟩ := hbdd a\n    exact ⟨γ, hγ1, hγ2.mono <| Ioo_subset_Ioo (neg_le_neg hlt.le) hlt.le⟩\n  intro hbdd\n  set asup := sSup s with hasup\n  -- we will obtain two integral curves, one centred at some `t₀ > 0` with\n  -- `0 ≤ asup - ε < t₀ < asup`; let `t₀ = asup - ε / 2`\n  -- another centred at 0 with domain up to `a ∈ S` with `t₀ < a < asup`\n  obtain ⟨a, ha, hlt⟩ := Real.add_neg_lt_sSup (⟨ε, h x⟩ : Set.Nonempty s) (ε := - (ε / 2))\n    (by rw [neg_lt, neg_zero]; exact half_pos hε)\n  rw [mem_setOf] at ha\n  rw [← hasup, ← sub_eq_add_neg] at hlt\n\n  -- integral curve defined on `Ioo (-a) a`\n  obtain ⟨γ, h0, hγ⟩ := ha\n  -- integral curve starting at `-(asup - ε / 2)` with radius `ε`\n  obtain ⟨γ1_aux, h1_aux, hγ1⟩ := h (γ (-(asup - ε / 2)))\n  rw [isIntegralCurveOn_comp_add (dt := asup - ε / 2)] at hγ1\n  set γ1 := γ1_aux ∘ (· + (asup - ε / 2)) with γ1_def\n  have heq1 : γ1 (-(asup - ε / 2)) = γ (-(asup - ε / 2)) := by simp [γ1_def, h1_aux]\n  -- integral curve starting at `asup - ε / 2` with radius `ε`\n  obtain ⟨γ2_aux, h2_aux, hγ2⟩ := h (γ (asup - ε / 2))\n  rw [isIntegralCurveOn_comp_sub (dt := asup - ε / 2)] at hγ2\n  set γ2 := γ2_aux ∘ (· - (asup - ε / 2)) with γ2_def\n  have heq2 : γ2 (asup - ε / 2) = γ (asup - ε / 2) := by simp [γ2_def, h2_aux]\n\n  -- rewrite shifted Ioo as Ioo\n  rw [neg_sub] at hγ1\n  rw [Real.Ioo_eq_ball, neg_add_cancel, zero_div, sub_neg_eq_add, add_self_div_two,\n    Metric.vadd_ball, vadd_eq_add, add_zero, Real.ball_eq_Ioo] at hγ1 hγ2\n\n  -- to help `linarith`\n  have hεle : ε ≤ asup := le_csSup hbdd (h x)\n\n  -- extend `γ` on the left by `γ1` and on the right by `γ2`\n  set γ_ext : ℝ → M := piecewise (Ioo (-(asup + ε / 2)) a)\n    (piecewise (Ioo (-a) a) γ γ1) γ2 with γ_ext_def\n  have heq_ext : γ_ext 0 = x := by\n    rw [γ_ext_def, piecewise, if_pos ⟨by linarith, by linarith⟩, piecewise,\n      if_pos ⟨by linarith, by linarith⟩, h0]\n  -- `asup + ε / 2` is an element of `s` greater than `asup`, a contradiction\n  suffices hext : IsIntegralCurveOn γ_ext v (Ioo (-(asup + ε / 2)) (asup + ε / 2)) from\n    (not_lt.mpr <| le_csSup hbdd ⟨γ_ext, heq_ext, hext⟩) <| lt_add_of_pos_right asup (half_pos hε)\n  apply (isIntegralCurveOn_piecewise (t₀ := asup - ε / 2) hv _ hγ2\n      ⟨⟨by linarith, hlt⟩, ⟨by linarith, by linarith⟩⟩\n      (by rw [piecewise, if_pos ⟨by linarith, hlt⟩, ← heq2])).mono\n    (Ioo_subset_Ioo_union_Ioo le_rfl (by linarith) (by linarith))\n  exact (isIntegralCurveOn_piecewise (t₀ := -(asup - ε / 2)) hv hγ hγ1\n      ⟨⟨neg_lt_neg hlt, by linarith⟩, ⟨by linarith, by linarith⟩⟩ heq1.symm).mono\n    (union_comm _ _ ▸ Ioo_subset_Ioo_union_Ioo (by linarith) (by linarith) le_rfl)\n"}
