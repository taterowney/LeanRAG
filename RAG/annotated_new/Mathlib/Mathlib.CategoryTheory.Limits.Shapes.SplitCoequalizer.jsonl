{"name":"CategoryTheory.IsSplitCoequalizer.rightSection_π","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitCoequalizer","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nZ : C\nπ : Quiver.Hom Y Z\nself : CategoryTheory.IsSplitCoequalizer f g π\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.rightSection π) (CategoryTheory.CategoryStruct.id Z)","decl":"/-- A split coequalizer diagram consists of morphisms\n\n      f   π\n    X ⇉ Y → Z\n      g\n\nsatisfying `f ≫ π = g ≫ π` together with morphisms\n\n      t   s\n    X ← Y ← Z\n\nsatisfying `s ≫ π = 𝟙 Z`, `t ≫ g = 𝟙 Y` and `t ≫ f = π ≫ s`.\n\nThe name \"coequalizer\" is appropriate, since any split coequalizer is a coequalizer, see\n`CategoryTheory.IsSplitCoequalizer.isCoequalizer`.\nSplit coequalizers are also absolute, since a functor preserves all the structure above.\n-/\nstructure IsSplitCoequalizer {Z : C} (π : Y ⟶ Z) where\n  /-- A map from the coequalizer to `Y` -/\n  rightSection : Z ⟶ Y\n  /-- A map in the opposite direction to `f` and `g` -/\n  leftSection : Y ⟶ X\n  /-- Composition of `π` with `f` and with `g` agree -/\n  condition : f ≫ π = g ≫ π := by aesop_cat\n  /-- `rightSection` splits `π` -/\n  rightSection_π : rightSection ≫ π = 𝟙 Z := by aesop_cat\n  /-- `leftSection` splits `g` -/\n  leftSection_bottom : leftSection ≫ g = 𝟙 Y := by aesop_cat\n  /-- `leftSection` composed with `f` is `pi` composed with `rightSection` -/\n  leftSection_top : leftSection ≫ f = π ≫ rightSection := by aesop_cat\n\n"}
{"name":"CategoryTheory.IsSplitCoequalizer.mk.injEq","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitCoequalizer","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nZ : C\nπ : Quiver.Hom Y Z\nrightSection✝ : Quiver.Hom Z Y\nleftSection✝ : Quiver.Hom Y X\ncondition✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp f π) (CategoryTheory.CategoryStruct.comp g π)) _auto✝\nrightSection_π✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp rightSection✝ π) (CategoryTheory.CategoryStruct.id Z)) _auto✝\nleftSection_bottom✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp leftSection✝ g) (CategoryTheory.CategoryStruct.id Y)) _auto✝\nleftSection_top✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp leftSection✝ f) (CategoryTheory.CategoryStruct.comp π rightSection✝)) _auto✝\nrightSection : Quiver.Hom Z Y\nleftSection : Quiver.Hom Y X\ncondition : autoParam (Eq (CategoryTheory.CategoryStruct.comp f π) (CategoryTheory.CategoryStruct.comp g π)) _auto✝\nrightSection_π : autoParam (Eq (CategoryTheory.CategoryStruct.comp rightSection π) (CategoryTheory.CategoryStruct.id Z)) _auto✝\nleftSection_bottom : autoParam (Eq (CategoryTheory.CategoryStruct.comp leftSection g) (CategoryTheory.CategoryStruct.id Y)) _auto✝\nleftSection_top : autoParam (Eq (CategoryTheory.CategoryStruct.comp leftSection f) (CategoryTheory.CategoryStruct.comp π rightSection)) _auto✝\n⊢ Eq (Eq { rightSection := rightSection✝, leftSection := leftSection✝, condition := condition✝, rightSection_π := rightSection_π✝, leftSection_bottom := leftSection_bottom✝, leftSection_top := leftSection_top✝ } { rightSection := rightSection, leftSection := leftSection, condition := condition, rightSection_π := rightSection_π, leftSection_bottom := leftSection_bottom, leftSection_top := leftSection_top }) (And (Eq rightSection✝ rightSection) (Eq leftSection✝ leftSection))","decl":"/-- A split coequalizer diagram consists of morphisms\n\n      f   π\n    X ⇉ Y → Z\n      g\n\nsatisfying `f ≫ π = g ≫ π` together with morphisms\n\n      t   s\n    X ← Y ← Z\n\nsatisfying `s ≫ π = 𝟙 Z`, `t ≫ g = 𝟙 Y` and `t ≫ f = π ≫ s`.\n\nThe name \"coequalizer\" is appropriate, since any split coequalizer is a coequalizer, see\n`CategoryTheory.IsSplitCoequalizer.isCoequalizer`.\nSplit coequalizers are also absolute, since a functor preserves all the structure above.\n-/\nstructure IsSplitCoequalizer {Z : C} (π : Y ⟶ Z) where\n  /-- A map from the coequalizer to `Y` -/\n  rightSection : Z ⟶ Y\n  /-- A map in the opposite direction to `f` and `g` -/\n  leftSection : Y ⟶ X\n  /-- Composition of `π` with `f` and with `g` agree -/\n  condition : f ≫ π = g ≫ π := by aesop_cat\n  /-- `rightSection` splits `π` -/\n  rightSection_π : rightSection ≫ π = 𝟙 Z := by aesop_cat\n  /-- `leftSection` splits `g` -/\n  leftSection_bottom : leftSection ≫ g = 𝟙 Y := by aesop_cat\n  /-- `leftSection` composed with `f` is `pi` composed with `rightSection` -/\n  leftSection_top : leftSection ≫ f = π ≫ rightSection := by aesop_cat\n\n"}
{"name":"CategoryTheory.IsSplitCoequalizer.leftSection_bottom","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitCoequalizer","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nZ : C\nπ : Quiver.Hom Y Z\nself : CategoryTheory.IsSplitCoequalizer f g π\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.leftSection g) (CategoryTheory.CategoryStruct.id Y)","decl":"/-- A split coequalizer diagram consists of morphisms\n\n      f   π\n    X ⇉ Y → Z\n      g\n\nsatisfying `f ≫ π = g ≫ π` together with morphisms\n\n      t   s\n    X ← Y ← Z\n\nsatisfying `s ≫ π = 𝟙 Z`, `t ≫ g = 𝟙 Y` and `t ≫ f = π ≫ s`.\n\nThe name \"coequalizer\" is appropriate, since any split coequalizer is a coequalizer, see\n`CategoryTheory.IsSplitCoequalizer.isCoequalizer`.\nSplit coequalizers are also absolute, since a functor preserves all the structure above.\n-/\nstructure IsSplitCoequalizer {Z : C} (π : Y ⟶ Z) where\n  /-- A map from the coequalizer to `Y` -/\n  rightSection : Z ⟶ Y\n  /-- A map in the opposite direction to `f` and `g` -/\n  leftSection : Y ⟶ X\n  /-- Composition of `π` with `f` and with `g` agree -/\n  condition : f ≫ π = g ≫ π := by aesop_cat\n  /-- `rightSection` splits `π` -/\n  rightSection_π : rightSection ≫ π = 𝟙 Z := by aesop_cat\n  /-- `leftSection` splits `g` -/\n  leftSection_bottom : leftSection ≫ g = 𝟙 Y := by aesop_cat\n  /-- `leftSection` composed with `f` is `pi` composed with `rightSection` -/\n  leftSection_top : leftSection ≫ f = π ≫ rightSection := by aesop_cat\n\n"}
{"name":"CategoryTheory.IsSplitCoequalizer.leftSection_top","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitCoequalizer","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nZ : C\nπ : Quiver.Hom Y Z\nself : CategoryTheory.IsSplitCoequalizer f g π\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.leftSection f) (CategoryTheory.CategoryStruct.comp π self.rightSection)","decl":"/-- A split coequalizer diagram consists of morphisms\n\n      f   π\n    X ⇉ Y → Z\n      g\n\nsatisfying `f ≫ π = g ≫ π` together with morphisms\n\n      t   s\n    X ← Y ← Z\n\nsatisfying `s ≫ π = 𝟙 Z`, `t ≫ g = 𝟙 Y` and `t ≫ f = π ≫ s`.\n\nThe name \"coequalizer\" is appropriate, since any split coequalizer is a coequalizer, see\n`CategoryTheory.IsSplitCoequalizer.isCoequalizer`.\nSplit coequalizers are also absolute, since a functor preserves all the structure above.\n-/\nstructure IsSplitCoequalizer {Z : C} (π : Y ⟶ Z) where\n  /-- A map from the coequalizer to `Y` -/\n  rightSection : Z ⟶ Y\n  /-- A map in the opposite direction to `f` and `g` -/\n  leftSection : Y ⟶ X\n  /-- Composition of `π` with `f` and with `g` agree -/\n  condition : f ≫ π = g ≫ π := by aesop_cat\n  /-- `rightSection` splits `π` -/\n  rightSection_π : rightSection ≫ π = 𝟙 Z := by aesop_cat\n  /-- `leftSection` splits `g` -/\n  leftSection_bottom : leftSection ≫ g = 𝟙 Y := by aesop_cat\n  /-- `leftSection` composed with `f` is `pi` composed with `rightSection` -/\n  leftSection_top : leftSection ≫ f = π ≫ rightSection := by aesop_cat\n\n"}
{"name":"CategoryTheory.IsSplitCoequalizer.mk.inj","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitCoequalizer","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nZ : C\nπ : Quiver.Hom Y Z\nrightSection✝ : Quiver.Hom Z Y\nleftSection✝ : Quiver.Hom Y X\ncondition✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp f π) (CategoryTheory.CategoryStruct.comp g π)) _auto✝\nrightSection_π✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp rightSection✝ π) (CategoryTheory.CategoryStruct.id Z)) _auto✝\nleftSection_bottom✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp leftSection✝ g) (CategoryTheory.CategoryStruct.id Y)) _auto✝\nleftSection_top✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp leftSection✝ f) (CategoryTheory.CategoryStruct.comp π rightSection✝)) _auto✝\nrightSection : Quiver.Hom Z Y\nleftSection : Quiver.Hom Y X\ncondition : autoParam (Eq (CategoryTheory.CategoryStruct.comp f π) (CategoryTheory.CategoryStruct.comp g π)) _auto✝\nrightSection_π : autoParam (Eq (CategoryTheory.CategoryStruct.comp rightSection π) (CategoryTheory.CategoryStruct.id Z)) _auto✝\nleftSection_bottom : autoParam (Eq (CategoryTheory.CategoryStruct.comp leftSection g) (CategoryTheory.CategoryStruct.id Y)) _auto✝\nleftSection_top : autoParam (Eq (CategoryTheory.CategoryStruct.comp leftSection f) (CategoryTheory.CategoryStruct.comp π rightSection)) _auto✝\nx✝ : Eq { rightSection := rightSection✝, leftSection := leftSection✝, condition := condition✝, rightSection_π := rightSection_π✝, leftSection_bottom := leftSection_bottom✝, leftSection_top := leftSection_top✝ } { rightSection := rightSection, leftSection := leftSection, condition := condition, rightSection_π := rightSection_π, leftSection_bottom := leftSection_bottom, leftSection_top := leftSection_top }\n⊢ And (Eq rightSection✝ rightSection) (Eq leftSection✝ leftSection)","decl":"/-- A split coequalizer diagram consists of morphisms\n\n      f   π\n    X ⇉ Y → Z\n      g\n\nsatisfying `f ≫ π = g ≫ π` together with morphisms\n\n      t   s\n    X ← Y ← Z\n\nsatisfying `s ≫ π = 𝟙 Z`, `t ≫ g = 𝟙 Y` and `t ≫ f = π ≫ s`.\n\nThe name \"coequalizer\" is appropriate, since any split coequalizer is a coequalizer, see\n`CategoryTheory.IsSplitCoequalizer.isCoequalizer`.\nSplit coequalizers are also absolute, since a functor preserves all the structure above.\n-/\nstructure IsSplitCoequalizer {Z : C} (π : Y ⟶ Z) where\n  /-- A map from the coequalizer to `Y` -/\n  rightSection : Z ⟶ Y\n  /-- A map in the opposite direction to `f` and `g` -/\n  leftSection : Y ⟶ X\n  /-- Composition of `π` with `f` and with `g` agree -/\n  condition : f ≫ π = g ≫ π := by aesop_cat\n  /-- `rightSection` splits `π` -/\n  rightSection_π : rightSection ≫ π = 𝟙 Z := by aesop_cat\n  /-- `leftSection` splits `g` -/\n  leftSection_bottom : leftSection ≫ g = 𝟙 Y := by aesop_cat\n  /-- `leftSection` composed with `f` is `pi` composed with `rightSection` -/\n  leftSection_top : leftSection ≫ f = π ≫ rightSection := by aesop_cat\n\n"}
{"name":"CategoryTheory.IsSplitCoequalizer.condition","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitCoequalizer","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nZ : C\nπ : Quiver.Hom Y Z\nself : CategoryTheory.IsSplitCoequalizer f g π\n⊢ Eq (CategoryTheory.CategoryStruct.comp f π) (CategoryTheory.CategoryStruct.comp g π)","decl":"/-- A split coequalizer diagram consists of morphisms\n\n      f   π\n    X ⇉ Y → Z\n      g\n\nsatisfying `f ≫ π = g ≫ π` together with morphisms\n\n      t   s\n    X ← Y ← Z\n\nsatisfying `s ≫ π = 𝟙 Z`, `t ≫ g = 𝟙 Y` and `t ≫ f = π ≫ s`.\n\nThe name \"coequalizer\" is appropriate, since any split coequalizer is a coequalizer, see\n`CategoryTheory.IsSplitCoequalizer.isCoequalizer`.\nSplit coequalizers are also absolute, since a functor preserves all the structure above.\n-/\nstructure IsSplitCoequalizer {Z : C} (π : Y ⟶ Z) where\n  /-- A map from the coequalizer to `Y` -/\n  rightSection : Z ⟶ Y\n  /-- A map in the opposite direction to `f` and `g` -/\n  leftSection : Y ⟶ X\n  /-- Composition of `π` with `f` and with `g` agree -/\n  condition : f ≫ π = g ≫ π := by aesop_cat\n  /-- `rightSection` splits `π` -/\n  rightSection_π : rightSection ≫ π = 𝟙 Z := by aesop_cat\n  /-- `leftSection` splits `g` -/\n  leftSection_bottom : leftSection ≫ g = 𝟙 Y := by aesop_cat\n  /-- `leftSection` composed with `f` is `pi` composed with `rightSection` -/\n  leftSection_top : leftSection ≫ f = π ≫ rightSection := by aesop_cat\n\n"}
{"name":"CategoryTheory.IsSplitCoequalizer.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitCoequalizer","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nZ : C\nπ : Quiver.Hom Y Z\ninst✝ : SizeOf C\nrightSection : Quiver.Hom Z Y\nleftSection : Quiver.Hom Y X\ncondition : autoParam (Eq (CategoryTheory.CategoryStruct.comp f π) (CategoryTheory.CategoryStruct.comp g π)) _auto✝\nrightSection_π : autoParam (Eq (CategoryTheory.CategoryStruct.comp rightSection π) (CategoryTheory.CategoryStruct.id Z)) _auto✝\nleftSection_bottom : autoParam (Eq (CategoryTheory.CategoryStruct.comp leftSection g) (CategoryTheory.CategoryStruct.id Y)) _auto✝\nleftSection_top : autoParam (Eq (CategoryTheory.CategoryStruct.comp leftSection f) (CategoryTheory.CategoryStruct.comp π rightSection)) _auto✝\n⊢ Eq (SizeOf.sizeOf { rightSection := rightSection, leftSection := leftSection, condition := condition, rightSection_π := rightSection_π, leftSection_bottom := leftSection_bottom, leftSection_top := leftSection_top }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf rightSection)) (SizeOf.sizeOf leftSection)) (SizeOf.sizeOf condition)) (SizeOf.sizeOf rightSection_π)) (SizeOf.sizeOf leftSection_bottom)) (SizeOf.sizeOf leftSection_top))","decl":"/-- A split coequalizer diagram consists of morphisms\n\n      f   π\n    X ⇉ Y → Z\n      g\n\nsatisfying `f ≫ π = g ≫ π` together with morphisms\n\n      t   s\n    X ← Y ← Z\n\nsatisfying `s ≫ π = 𝟙 Z`, `t ≫ g = 𝟙 Y` and `t ≫ f = π ≫ s`.\n\nThe name \"coequalizer\" is appropriate, since any split coequalizer is a coequalizer, see\n`CategoryTheory.IsSplitCoequalizer.isCoequalizer`.\nSplit coequalizers are also absolute, since a functor preserves all the structure above.\n-/\nstructure IsSplitCoequalizer {Z : C} (π : Y ⟶ Z) where\n  /-- A map from the coequalizer to `Y` -/\n  rightSection : Z ⟶ Y\n  /-- A map in the opposite direction to `f` and `g` -/\n  leftSection : Y ⟶ X\n  /-- Composition of `π` with `f` and with `g` agree -/\n  condition : f ≫ π = g ≫ π := by aesop_cat\n  /-- `rightSection` splits `π` -/\n  rightSection_π : rightSection ≫ π = 𝟙 Z := by aesop_cat\n  /-- `leftSection` splits `g` -/\n  leftSection_bottom : leftSection ≫ g = 𝟙 Y := by aesop_cat\n  /-- `leftSection` composed with `f` is `pi` composed with `rightSection` -/\n  leftSection_top : leftSection ≫ f = π ≫ rightSection := by aesop_cat\n\n"}
{"name":"CategoryTheory.IsSplitCoequalizer.condition_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitCoequalizer","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nZ✝ : C\nπ : Quiver.Hom Y Z✝\nself : CategoryTheory.IsSplitCoequalizer f g π\nZ : C\nh : Quiver.Hom Z✝ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp π h)) (CategoryTheory.CategoryStruct.comp g (CategoryTheory.CategoryStruct.comp π h))","decl":"attribute [reassoc] condition\n\n"}
{"name":"CategoryTheory.IsSplitCoequalizer.leftSection_bottom_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitCoequalizer","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nZ✝ : C\nπ : Quiver.Hom Y Z✝\nself : CategoryTheory.IsSplitCoequalizer f g π\nZ : C\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.leftSection (CategoryTheory.CategoryStruct.comp g h)) h","decl":"attribute [reassoc (attr := simp)] rightSection_π leftSection_bottom leftSection_top\n\n"}
{"name":"CategoryTheory.IsSplitCoequalizer.leftSection_top_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitCoequalizer","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nZ✝ : C\nπ : Quiver.Hom Y Z✝\nself : CategoryTheory.IsSplitCoequalizer f g π\nZ : C\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.leftSection (CategoryTheory.CategoryStruct.comp f h)) (CategoryTheory.CategoryStruct.comp π (CategoryTheory.CategoryStruct.comp self.rightSection h))","decl":"attribute [reassoc (attr := simp)] rightSection_π leftSection_bottom leftSection_top\n\n"}
{"name":"CategoryTheory.IsSplitCoequalizer.rightSection_π_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitCoequalizer","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nZ✝ : C\nπ : Quiver.Hom Y Z✝\nself : CategoryTheory.IsSplitCoequalizer f g π\nZ : C\nh : Quiver.Hom Z✝ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.rightSection (CategoryTheory.CategoryStruct.comp π h)) h","decl":"attribute [reassoc (attr := simp)] rightSection_π leftSection_bottom leftSection_top\n\n"}
{"name":"CategoryTheory.IsSplitCoequalizer.map_rightSection","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitCoequalizer","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nX Y : C\nf g : Quiver.Hom X Y\nZ : C\nπ : Quiver.Hom Y Z\nq : CategoryTheory.IsSplitCoequalizer f g π\nF : CategoryTheory.Functor C D\n⊢ Eq (q.map F).rightSection (F.map q.rightSection)","decl":"/-- Split coequalizers are absolute: they are preserved by any functor. -/\n@[simps]\ndef IsSplitCoequalizer.map {Z : C} {π : Y ⟶ Z} (q : IsSplitCoequalizer f g π) (F : C ⥤ D) :\n    IsSplitCoequalizer (F.map f) (F.map g) (F.map π) where\n  rightSection := F.map q.rightSection\n  leftSection := F.map q.leftSection\n  condition := by rw [← F.map_comp, q.condition, F.map_comp]\n  rightSection_π := by rw [← F.map_comp, q.rightSection_π, F.map_id]\n  leftSection_bottom := by rw [← F.map_comp, q.leftSection_bottom, F.map_id]\n  leftSection_top := by rw [← F.map_comp, q.leftSection_top, F.map_comp]\n\n"}
{"name":"CategoryTheory.IsSplitCoequalizer.map_leftSection","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitCoequalizer","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nX Y : C\nf g : Quiver.Hom X Y\nZ : C\nπ : Quiver.Hom Y Z\nq : CategoryTheory.IsSplitCoequalizer f g π\nF : CategoryTheory.Functor C D\n⊢ Eq (q.map F).leftSection (F.map q.leftSection)","decl":"/-- Split coequalizers are absolute: they are preserved by any functor. -/\n@[simps]\ndef IsSplitCoequalizer.map {Z : C} {π : Y ⟶ Z} (q : IsSplitCoequalizer f g π) (F : C ⥤ D) :\n    IsSplitCoequalizer (F.map f) (F.map g) (F.map π) where\n  rightSection := F.map q.rightSection\n  leftSection := F.map q.leftSection\n  condition := by rw [← F.map_comp, q.condition, F.map_comp]\n  rightSection_π := by rw [← F.map_comp, q.rightSection_π, F.map_id]\n  leftSection_bottom := by rw [← F.map_comp, q.leftSection_bottom, F.map_id]\n  leftSection_top := by rw [← F.map_comp, q.leftSection_top, F.map_comp]\n\n"}
{"name":"CategoryTheory.IsSplitCoequalizer.asCofork_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitCoequalizer","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nZ : C\nh : Quiver.Hom Y Z\nt : CategoryTheory.IsSplitCoequalizer f g h\n⊢ Eq t.asCofork.pt Z","decl":"/-- A split coequalizer clearly induces a cofork. -/\n@[simps! pt]\ndef IsSplitCoequalizer.asCofork {Z : C} {h : Y ⟶ Z} (t : IsSplitCoequalizer f g h) :\n    Cofork f g := Cofork.ofπ h t.condition\n\n"}
{"name":"CategoryTheory.IsSplitCoequalizer.asCofork_π","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitCoequalizer","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nZ : C\nh : Quiver.Hom Y Z\nt : CategoryTheory.IsSplitCoequalizer f g h\n⊢ Eq t.asCofork.π h","decl":"@[simp]\ntheorem IsSplitCoequalizer.asCofork_π {Z : C} {h : Y ⟶ Z} (t : IsSplitCoequalizer f g h) :\n    t.asCofork.π = h := rfl\n\n"}
{"name":"CategoryTheory.HasSplitCoequalizer.splittable","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitCoequalizer","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nself : CategoryTheory.HasSplitCoequalizer f g\n⊢ Exists fun Z => Exists fun h => Nonempty (CategoryTheory.IsSplitCoequalizer f g h)","decl":"/--\nThe pair `f,g` is a split pair if there is an `h : Y ⟶ Z` so that `f, g, h` forms a split\ncoequalizer in `C`.\n-/\nclass HasSplitCoequalizer : Prop where\n  /-- There is some split coequalizer -/\n  splittable : ∃ (Z : C) (h : Y ⟶ Z), Nonempty (IsSplitCoequalizer f g h)\n\n"}
{"name":"CategoryTheory.map_is_split_pair","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitCoequalizer","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nX Y : C\nf g : Quiver.Hom X Y\ninst✝ : CategoryTheory.HasSplitCoequalizer f g\n⊢ CategoryTheory.HasSplitCoequalizer (G.map f) (G.map g)","decl":"/-- If `f, g` is split, then `G f, G g` is split. -/\ninstance map_is_split_pair [HasSplitCoequalizer f g] : HasSplitCoequalizer (G.map f) (G.map g) where\n  splittable :=\n    ⟨_, _, ⟨IsSplitCoequalizer.map (HasSplitCoequalizer.isSplitCoequalizer f g) _⟩⟩\n\n"}
{"name":"CategoryTheory.Limits.hasCoequalizer_of_hasSplitCoequalizer","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitCoequalizer","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ninst✝ : CategoryTheory.HasSplitCoequalizer f g\n⊢ CategoryTheory.Limits.HasCoequalizer f g","decl":"/-- If a pair has a split coequalizer, it has a coequalizer. -/\ninstance (priority := 1) hasCoequalizer_of_hasSplitCoequalizer [HasSplitCoequalizer f g] :\n    HasCoequalizer f g :=\n  HasColimit.mk ⟨_, (HasSplitCoequalizer.isSplitCoequalizer f g).isCoequalizer⟩\n\n"}
