{"name":"CategoryTheory.IsSplitCoequalizer.rightSection_œÄ","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitCoequalizer","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nZ : C\nœÄ : Quiver.Hom Y Z\nself : CategoryTheory.IsSplitCoequalizer f g œÄ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp self.rightSection œÄ) (CategoryTheory.CategoryStruct.id Z)","decl":"/-- A split coequalizer diagram consists of morphisms\n\n      f   œÄ\n    X ‚áâ Y ‚Üí Z\n      g\n\nsatisfying `f ‚â´ œÄ = g ‚â´ œÄ` together with morphisms\n\n      t   s\n    X ‚Üê Y ‚Üê Z\n\nsatisfying `s ‚â´ œÄ = ùüô Z`, `t ‚â´ g = ùüô Y` and `t ‚â´ f = œÄ ‚â´ s`.\n\nThe name \"coequalizer\" is appropriate, since any split coequalizer is a coequalizer, see\n`CategoryTheory.IsSplitCoequalizer.isCoequalizer`.\nSplit coequalizers are also absolute, since a functor preserves all the structure above.\n-/\nstructure IsSplitCoequalizer {Z : C} (œÄ : Y ‚ü∂ Z) where\n  /-- A map from the coequalizer to `Y` -/\n  rightSection : Z ‚ü∂ Y\n  /-- A map in the opposite direction to `f` and `g` -/\n  leftSection : Y ‚ü∂ X\n  /-- Composition of `œÄ` with `f` and with `g` agree -/\n  condition : f ‚â´ œÄ = g ‚â´ œÄ := by aesop_cat\n  /-- `rightSection` splits `œÄ` -/\n  rightSection_œÄ : rightSection ‚â´ œÄ = ùüô Z := by aesop_cat\n  /-- `leftSection` splits `g` -/\n  leftSection_bottom : leftSection ‚â´ g = ùüô Y := by aesop_cat\n  /-- `leftSection` composed with `f` is `pi` composed with `rightSection` -/\n  leftSection_top : leftSection ‚â´ f = œÄ ‚â´ rightSection := by aesop_cat\n\n"}
{"name":"CategoryTheory.IsSplitCoequalizer.mk.injEq","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitCoequalizer","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nZ : C\nœÄ : Quiver.Hom Y Z\nrightSection‚úù : Quiver.Hom Z Y\nleftSection‚úù : Quiver.Hom Y X\ncondition‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp f œÄ) (CategoryTheory.CategoryStruct.comp g œÄ)) _auto‚úù\nrightSection_œÄ‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp rightSection‚úù œÄ) (CategoryTheory.CategoryStruct.id Z)) _auto‚úù\nleftSection_bottom‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp leftSection‚úù g) (CategoryTheory.CategoryStruct.id Y)) _auto‚úù\nleftSection_top‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp leftSection‚úù f) (CategoryTheory.CategoryStruct.comp œÄ rightSection‚úù)) _auto‚úù\nrightSection : Quiver.Hom Z Y\nleftSection : Quiver.Hom Y X\ncondition : autoParam (Eq (CategoryTheory.CategoryStruct.comp f œÄ) (CategoryTheory.CategoryStruct.comp g œÄ)) _auto‚úù\nrightSection_œÄ : autoParam (Eq (CategoryTheory.CategoryStruct.comp rightSection œÄ) (CategoryTheory.CategoryStruct.id Z)) _auto‚úù\nleftSection_bottom : autoParam (Eq (CategoryTheory.CategoryStruct.comp leftSection g) (CategoryTheory.CategoryStruct.id Y)) _auto‚úù\nleftSection_top : autoParam (Eq (CategoryTheory.CategoryStruct.comp leftSection f) (CategoryTheory.CategoryStruct.comp œÄ rightSection)) _auto‚úù\n‚ä¢ Eq (Eq { rightSection := rightSection‚úù, leftSection := leftSection‚úù, condition := condition‚úù, rightSection_œÄ := rightSection_œÄ‚úù, leftSection_bottom := leftSection_bottom‚úù, leftSection_top := leftSection_top‚úù } { rightSection := rightSection, leftSection := leftSection, condition := condition, rightSection_œÄ := rightSection_œÄ, leftSection_bottom := leftSection_bottom, leftSection_top := leftSection_top }) (And (Eq rightSection‚úù rightSection) (Eq leftSection‚úù leftSection))","decl":"/-- A split coequalizer diagram consists of morphisms\n\n      f   œÄ\n    X ‚áâ Y ‚Üí Z\n      g\n\nsatisfying `f ‚â´ œÄ = g ‚â´ œÄ` together with morphisms\n\n      t   s\n    X ‚Üê Y ‚Üê Z\n\nsatisfying `s ‚â´ œÄ = ùüô Z`, `t ‚â´ g = ùüô Y` and `t ‚â´ f = œÄ ‚â´ s`.\n\nThe name \"coequalizer\" is appropriate, since any split coequalizer is a coequalizer, see\n`CategoryTheory.IsSplitCoequalizer.isCoequalizer`.\nSplit coequalizers are also absolute, since a functor preserves all the structure above.\n-/\nstructure IsSplitCoequalizer {Z : C} (œÄ : Y ‚ü∂ Z) where\n  /-- A map from the coequalizer to `Y` -/\n  rightSection : Z ‚ü∂ Y\n  /-- A map in the opposite direction to `f` and `g` -/\n  leftSection : Y ‚ü∂ X\n  /-- Composition of `œÄ` with `f` and with `g` agree -/\n  condition : f ‚â´ œÄ = g ‚â´ œÄ := by aesop_cat\n  /-- `rightSection` splits `œÄ` -/\n  rightSection_œÄ : rightSection ‚â´ œÄ = ùüô Z := by aesop_cat\n  /-- `leftSection` splits `g` -/\n  leftSection_bottom : leftSection ‚â´ g = ùüô Y := by aesop_cat\n  /-- `leftSection` composed with `f` is `pi` composed with `rightSection` -/\n  leftSection_top : leftSection ‚â´ f = œÄ ‚â´ rightSection := by aesop_cat\n\n"}
{"name":"CategoryTheory.IsSplitCoequalizer.leftSection_bottom","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitCoequalizer","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nZ : C\nœÄ : Quiver.Hom Y Z\nself : CategoryTheory.IsSplitCoequalizer f g œÄ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp self.leftSection g) (CategoryTheory.CategoryStruct.id Y)","decl":"/-- A split coequalizer diagram consists of morphisms\n\n      f   œÄ\n    X ‚áâ Y ‚Üí Z\n      g\n\nsatisfying `f ‚â´ œÄ = g ‚â´ œÄ` together with morphisms\n\n      t   s\n    X ‚Üê Y ‚Üê Z\n\nsatisfying `s ‚â´ œÄ = ùüô Z`, `t ‚â´ g = ùüô Y` and `t ‚â´ f = œÄ ‚â´ s`.\n\nThe name \"coequalizer\" is appropriate, since any split coequalizer is a coequalizer, see\n`CategoryTheory.IsSplitCoequalizer.isCoequalizer`.\nSplit coequalizers are also absolute, since a functor preserves all the structure above.\n-/\nstructure IsSplitCoequalizer {Z : C} (œÄ : Y ‚ü∂ Z) where\n  /-- A map from the coequalizer to `Y` -/\n  rightSection : Z ‚ü∂ Y\n  /-- A map in the opposite direction to `f` and `g` -/\n  leftSection : Y ‚ü∂ X\n  /-- Composition of `œÄ` with `f` and with `g` agree -/\n  condition : f ‚â´ œÄ = g ‚â´ œÄ := by aesop_cat\n  /-- `rightSection` splits `œÄ` -/\n  rightSection_œÄ : rightSection ‚â´ œÄ = ùüô Z := by aesop_cat\n  /-- `leftSection` splits `g` -/\n  leftSection_bottom : leftSection ‚â´ g = ùüô Y := by aesop_cat\n  /-- `leftSection` composed with `f` is `pi` composed with `rightSection` -/\n  leftSection_top : leftSection ‚â´ f = œÄ ‚â´ rightSection := by aesop_cat\n\n"}
{"name":"CategoryTheory.IsSplitCoequalizer.leftSection_top","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitCoequalizer","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nZ : C\nœÄ : Quiver.Hom Y Z\nself : CategoryTheory.IsSplitCoequalizer f g œÄ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp self.leftSection f) (CategoryTheory.CategoryStruct.comp œÄ self.rightSection)","decl":"/-- A split coequalizer diagram consists of morphisms\n\n      f   œÄ\n    X ‚áâ Y ‚Üí Z\n      g\n\nsatisfying `f ‚â´ œÄ = g ‚â´ œÄ` together with morphisms\n\n      t   s\n    X ‚Üê Y ‚Üê Z\n\nsatisfying `s ‚â´ œÄ = ùüô Z`, `t ‚â´ g = ùüô Y` and `t ‚â´ f = œÄ ‚â´ s`.\n\nThe name \"coequalizer\" is appropriate, since any split coequalizer is a coequalizer, see\n`CategoryTheory.IsSplitCoequalizer.isCoequalizer`.\nSplit coequalizers are also absolute, since a functor preserves all the structure above.\n-/\nstructure IsSplitCoequalizer {Z : C} (œÄ : Y ‚ü∂ Z) where\n  /-- A map from the coequalizer to `Y` -/\n  rightSection : Z ‚ü∂ Y\n  /-- A map in the opposite direction to `f` and `g` -/\n  leftSection : Y ‚ü∂ X\n  /-- Composition of `œÄ` with `f` and with `g` agree -/\n  condition : f ‚â´ œÄ = g ‚â´ œÄ := by aesop_cat\n  /-- `rightSection` splits `œÄ` -/\n  rightSection_œÄ : rightSection ‚â´ œÄ = ùüô Z := by aesop_cat\n  /-- `leftSection` splits `g` -/\n  leftSection_bottom : leftSection ‚â´ g = ùüô Y := by aesop_cat\n  /-- `leftSection` composed with `f` is `pi` composed with `rightSection` -/\n  leftSection_top : leftSection ‚â´ f = œÄ ‚â´ rightSection := by aesop_cat\n\n"}
{"name":"CategoryTheory.IsSplitCoequalizer.mk.inj","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitCoequalizer","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nZ : C\nœÄ : Quiver.Hom Y Z\nrightSection‚úù : Quiver.Hom Z Y\nleftSection‚úù : Quiver.Hom Y X\ncondition‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp f œÄ) (CategoryTheory.CategoryStruct.comp g œÄ)) _auto‚úù\nrightSection_œÄ‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp rightSection‚úù œÄ) (CategoryTheory.CategoryStruct.id Z)) _auto‚úù\nleftSection_bottom‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp leftSection‚úù g) (CategoryTheory.CategoryStruct.id Y)) _auto‚úù\nleftSection_top‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp leftSection‚úù f) (CategoryTheory.CategoryStruct.comp œÄ rightSection‚úù)) _auto‚úù\nrightSection : Quiver.Hom Z Y\nleftSection : Quiver.Hom Y X\ncondition : autoParam (Eq (CategoryTheory.CategoryStruct.comp f œÄ) (CategoryTheory.CategoryStruct.comp g œÄ)) _auto‚úù\nrightSection_œÄ : autoParam (Eq (CategoryTheory.CategoryStruct.comp rightSection œÄ) (CategoryTheory.CategoryStruct.id Z)) _auto‚úù\nleftSection_bottom : autoParam (Eq (CategoryTheory.CategoryStruct.comp leftSection g) (CategoryTheory.CategoryStruct.id Y)) _auto‚úù\nleftSection_top : autoParam (Eq (CategoryTheory.CategoryStruct.comp leftSection f) (CategoryTheory.CategoryStruct.comp œÄ rightSection)) _auto‚úù\nx‚úù : Eq { rightSection := rightSection‚úù, leftSection := leftSection‚úù, condition := condition‚úù, rightSection_œÄ := rightSection_œÄ‚úù, leftSection_bottom := leftSection_bottom‚úù, leftSection_top := leftSection_top‚úù } { rightSection := rightSection, leftSection := leftSection, condition := condition, rightSection_œÄ := rightSection_œÄ, leftSection_bottom := leftSection_bottom, leftSection_top := leftSection_top }\n‚ä¢ And (Eq rightSection‚úù rightSection) (Eq leftSection‚úù leftSection)","decl":"/-- A split coequalizer diagram consists of morphisms\n\n      f   œÄ\n    X ‚áâ Y ‚Üí Z\n      g\n\nsatisfying `f ‚â´ œÄ = g ‚â´ œÄ` together with morphisms\n\n      t   s\n    X ‚Üê Y ‚Üê Z\n\nsatisfying `s ‚â´ œÄ = ùüô Z`, `t ‚â´ g = ùüô Y` and `t ‚â´ f = œÄ ‚â´ s`.\n\nThe name \"coequalizer\" is appropriate, since any split coequalizer is a coequalizer, see\n`CategoryTheory.IsSplitCoequalizer.isCoequalizer`.\nSplit coequalizers are also absolute, since a functor preserves all the structure above.\n-/\nstructure IsSplitCoequalizer {Z : C} (œÄ : Y ‚ü∂ Z) where\n  /-- A map from the coequalizer to `Y` -/\n  rightSection : Z ‚ü∂ Y\n  /-- A map in the opposite direction to `f` and `g` -/\n  leftSection : Y ‚ü∂ X\n  /-- Composition of `œÄ` with `f` and with `g` agree -/\n  condition : f ‚â´ œÄ = g ‚â´ œÄ := by aesop_cat\n  /-- `rightSection` splits `œÄ` -/\n  rightSection_œÄ : rightSection ‚â´ œÄ = ùüô Z := by aesop_cat\n  /-- `leftSection` splits `g` -/\n  leftSection_bottom : leftSection ‚â´ g = ùüô Y := by aesop_cat\n  /-- `leftSection` composed with `f` is `pi` composed with `rightSection` -/\n  leftSection_top : leftSection ‚â´ f = œÄ ‚â´ rightSection := by aesop_cat\n\n"}
{"name":"CategoryTheory.IsSplitCoequalizer.condition","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitCoequalizer","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nZ : C\nœÄ : Quiver.Hom Y Z\nself : CategoryTheory.IsSplitCoequalizer f g œÄ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f œÄ) (CategoryTheory.CategoryStruct.comp g œÄ)","decl":"/-- A split coequalizer diagram consists of morphisms\n\n      f   œÄ\n    X ‚áâ Y ‚Üí Z\n      g\n\nsatisfying `f ‚â´ œÄ = g ‚â´ œÄ` together with morphisms\n\n      t   s\n    X ‚Üê Y ‚Üê Z\n\nsatisfying `s ‚â´ œÄ = ùüô Z`, `t ‚â´ g = ùüô Y` and `t ‚â´ f = œÄ ‚â´ s`.\n\nThe name \"coequalizer\" is appropriate, since any split coequalizer is a coequalizer, see\n`CategoryTheory.IsSplitCoequalizer.isCoequalizer`.\nSplit coequalizers are also absolute, since a functor preserves all the structure above.\n-/\nstructure IsSplitCoequalizer {Z : C} (œÄ : Y ‚ü∂ Z) where\n  /-- A map from the coequalizer to `Y` -/\n  rightSection : Z ‚ü∂ Y\n  /-- A map in the opposite direction to `f` and `g` -/\n  leftSection : Y ‚ü∂ X\n  /-- Composition of `œÄ` with `f` and with `g` agree -/\n  condition : f ‚â´ œÄ = g ‚â´ œÄ := by aesop_cat\n  /-- `rightSection` splits `œÄ` -/\n  rightSection_œÄ : rightSection ‚â´ œÄ = ùüô Z := by aesop_cat\n  /-- `leftSection` splits `g` -/\n  leftSection_bottom : leftSection ‚â´ g = ùüô Y := by aesop_cat\n  /-- `leftSection` composed with `f` is `pi` composed with `rightSection` -/\n  leftSection_top : leftSection ‚â´ f = œÄ ‚â´ rightSection := by aesop_cat\n\n"}
{"name":"CategoryTheory.IsSplitCoequalizer.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitCoequalizer","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nZ : C\nœÄ : Quiver.Hom Y Z\ninst‚úù : SizeOf C\nrightSection : Quiver.Hom Z Y\nleftSection : Quiver.Hom Y X\ncondition : autoParam (Eq (CategoryTheory.CategoryStruct.comp f œÄ) (CategoryTheory.CategoryStruct.comp g œÄ)) _auto‚úù\nrightSection_œÄ : autoParam (Eq (CategoryTheory.CategoryStruct.comp rightSection œÄ) (CategoryTheory.CategoryStruct.id Z)) _auto‚úù\nleftSection_bottom : autoParam (Eq (CategoryTheory.CategoryStruct.comp leftSection g) (CategoryTheory.CategoryStruct.id Y)) _auto‚úù\nleftSection_top : autoParam (Eq (CategoryTheory.CategoryStruct.comp leftSection f) (CategoryTheory.CategoryStruct.comp œÄ rightSection)) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf { rightSection := rightSection, leftSection := leftSection, condition := condition, rightSection_œÄ := rightSection_œÄ, leftSection_bottom := leftSection_bottom, leftSection_top := leftSection_top }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf rightSection)) (SizeOf.sizeOf leftSection)) (SizeOf.sizeOf condition)) (SizeOf.sizeOf rightSection_œÄ)) (SizeOf.sizeOf leftSection_bottom)) (SizeOf.sizeOf leftSection_top))","decl":"/-- A split coequalizer diagram consists of morphisms\n\n      f   œÄ\n    X ‚áâ Y ‚Üí Z\n      g\n\nsatisfying `f ‚â´ œÄ = g ‚â´ œÄ` together with morphisms\n\n      t   s\n    X ‚Üê Y ‚Üê Z\n\nsatisfying `s ‚â´ œÄ = ùüô Z`, `t ‚â´ g = ùüô Y` and `t ‚â´ f = œÄ ‚â´ s`.\n\nThe name \"coequalizer\" is appropriate, since any split coequalizer is a coequalizer, see\n`CategoryTheory.IsSplitCoequalizer.isCoequalizer`.\nSplit coequalizers are also absolute, since a functor preserves all the structure above.\n-/\nstructure IsSplitCoequalizer {Z : C} (œÄ : Y ‚ü∂ Z) where\n  /-- A map from the coequalizer to `Y` -/\n  rightSection : Z ‚ü∂ Y\n  /-- A map in the opposite direction to `f` and `g` -/\n  leftSection : Y ‚ü∂ X\n  /-- Composition of `œÄ` with `f` and with `g` agree -/\n  condition : f ‚â´ œÄ = g ‚â´ œÄ := by aesop_cat\n  /-- `rightSection` splits `œÄ` -/\n  rightSection_œÄ : rightSection ‚â´ œÄ = ùüô Z := by aesop_cat\n  /-- `leftSection` splits `g` -/\n  leftSection_bottom : leftSection ‚â´ g = ùüô Y := by aesop_cat\n  /-- `leftSection` composed with `f` is `pi` composed with `rightSection` -/\n  leftSection_top : leftSection ‚â´ f = œÄ ‚â´ rightSection := by aesop_cat\n\n"}
{"name":"CategoryTheory.IsSplitCoequalizer.condition_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitCoequalizer","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nZ‚úù : C\nœÄ : Quiver.Hom Y Z‚úù\nself : CategoryTheory.IsSplitCoequalizer f g œÄ\nZ : C\nh : Quiver.Hom Z‚úù Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp œÄ h)) (CategoryTheory.CategoryStruct.comp g (CategoryTheory.CategoryStruct.comp œÄ h))","decl":"attribute [reassoc] condition\n\n"}
{"name":"CategoryTheory.IsSplitCoequalizer.leftSection_bottom_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitCoequalizer","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nZ‚úù : C\nœÄ : Quiver.Hom Y Z‚úù\nself : CategoryTheory.IsSplitCoequalizer f g œÄ\nZ : C\nh : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp self.leftSection (CategoryTheory.CategoryStruct.comp g h)) h","decl":"attribute [reassoc (attr := simp)] rightSection_œÄ leftSection_bottom leftSection_top\n\n"}
{"name":"CategoryTheory.IsSplitCoequalizer.leftSection_top_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitCoequalizer","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nZ‚úù : C\nœÄ : Quiver.Hom Y Z‚úù\nself : CategoryTheory.IsSplitCoequalizer f g œÄ\nZ : C\nh : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp self.leftSection (CategoryTheory.CategoryStruct.comp f h)) (CategoryTheory.CategoryStruct.comp œÄ (CategoryTheory.CategoryStruct.comp self.rightSection h))","decl":"attribute [reassoc (attr := simp)] rightSection_œÄ leftSection_bottom leftSection_top\n\n"}
{"name":"CategoryTheory.IsSplitCoequalizer.rightSection_œÄ_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitCoequalizer","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nZ‚úù : C\nœÄ : Quiver.Hom Y Z‚úù\nself : CategoryTheory.IsSplitCoequalizer f g œÄ\nZ : C\nh : Quiver.Hom Z‚úù Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp self.rightSection (CategoryTheory.CategoryStruct.comp œÄ h)) h","decl":"attribute [reassoc (attr := simp)] rightSection_œÄ leftSection_bottom leftSection_top\n\n"}
{"name":"CategoryTheory.IsSplitCoequalizer.map_rightSection","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitCoequalizer","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX Y : C\nf g : Quiver.Hom X Y\nZ : C\nœÄ : Quiver.Hom Y Z\nq : CategoryTheory.IsSplitCoequalizer f g œÄ\nF : CategoryTheory.Functor C D\n‚ä¢ Eq (q.map F).rightSection (F.map q.rightSection)","decl":"/-- Split coequalizers are absolute: they are preserved by any functor. -/\n@[simps]\ndef IsSplitCoequalizer.map {Z : C} {œÄ : Y ‚ü∂ Z} (q : IsSplitCoequalizer f g œÄ) (F : C ‚•§ D) :\n    IsSplitCoequalizer (F.map f) (F.map g) (F.map œÄ) where\n  rightSection := F.map q.rightSection\n  leftSection := F.map q.leftSection\n  condition := by rw [‚Üê F.map_comp, q.condition, F.map_comp]\n  rightSection_œÄ := by rw [‚Üê F.map_comp, q.rightSection_œÄ, F.map_id]\n  leftSection_bottom := by rw [‚Üê F.map_comp, q.leftSection_bottom, F.map_id]\n  leftSection_top := by rw [‚Üê F.map_comp, q.leftSection_top, F.map_comp]\n\n"}
{"name":"CategoryTheory.IsSplitCoequalizer.map_leftSection","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitCoequalizer","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX Y : C\nf g : Quiver.Hom X Y\nZ : C\nœÄ : Quiver.Hom Y Z\nq : CategoryTheory.IsSplitCoequalizer f g œÄ\nF : CategoryTheory.Functor C D\n‚ä¢ Eq (q.map F).leftSection (F.map q.leftSection)","decl":"/-- Split coequalizers are absolute: they are preserved by any functor. -/\n@[simps]\ndef IsSplitCoequalizer.map {Z : C} {œÄ : Y ‚ü∂ Z} (q : IsSplitCoequalizer f g œÄ) (F : C ‚•§ D) :\n    IsSplitCoequalizer (F.map f) (F.map g) (F.map œÄ) where\n  rightSection := F.map q.rightSection\n  leftSection := F.map q.leftSection\n  condition := by rw [‚Üê F.map_comp, q.condition, F.map_comp]\n  rightSection_œÄ := by rw [‚Üê F.map_comp, q.rightSection_œÄ, F.map_id]\n  leftSection_bottom := by rw [‚Üê F.map_comp, q.leftSection_bottom, F.map_id]\n  leftSection_top := by rw [‚Üê F.map_comp, q.leftSection_top, F.map_comp]\n\n"}
{"name":"CategoryTheory.IsSplitCoequalizer.asCofork_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitCoequalizer","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nZ : C\nh : Quiver.Hom Y Z\nt : CategoryTheory.IsSplitCoequalizer f g h\n‚ä¢ Eq t.asCofork.pt Z","decl":"/-- A split coequalizer clearly induces a cofork. -/\n@[simps! pt]\ndef IsSplitCoequalizer.asCofork {Z : C} {h : Y ‚ü∂ Z} (t : IsSplitCoequalizer f g h) :\n    Cofork f g := Cofork.ofœÄ h t.condition\n\n"}
{"name":"CategoryTheory.IsSplitCoequalizer.asCofork_œÄ","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitCoequalizer","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nZ : C\nh : Quiver.Hom Y Z\nt : CategoryTheory.IsSplitCoequalizer f g h\n‚ä¢ Eq t.asCofork.œÄ h","decl":"@[simp]\ntheorem IsSplitCoequalizer.asCofork_œÄ {Z : C} {h : Y ‚ü∂ Z} (t : IsSplitCoequalizer f g h) :\n    t.asCofork.œÄ = h := rfl\n\n"}
{"name":"CategoryTheory.HasSplitCoequalizer.splittable","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitCoequalizer","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nself : CategoryTheory.HasSplitCoequalizer f g\n‚ä¢ Exists fun Z => Exists fun h => Nonempty (CategoryTheory.IsSplitCoequalizer f g h)","decl":"/--\nThe pair `f,g` is a split pair if there is an `h : Y ‚ü∂ Z` so that `f, g, h` forms a split\ncoequalizer in `C`.\n-/\nclass HasSplitCoequalizer : Prop where\n  /-- There is some split coequalizer -/\n  splittable : ‚àÉ (Z : C) (h : Y ‚ü∂ Z), Nonempty (IsSplitCoequalizer f g h)\n\n"}
{"name":"CategoryTheory.map_is_split_pair","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitCoequalizer","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nG : CategoryTheory.Functor C D\nX Y : C\nf g : Quiver.Hom X Y\ninst‚úù : CategoryTheory.HasSplitCoequalizer f g\n‚ä¢ CategoryTheory.HasSplitCoequalizer (G.map f) (G.map g)","decl":"/-- If `f, g` is split, then `G f, G g` is split. -/\ninstance map_is_split_pair [HasSplitCoequalizer f g] : HasSplitCoequalizer (G.map f) (G.map g) where\n  splittable :=\n    ‚ü®_, _, ‚ü®IsSplitCoequalizer.map (HasSplitCoequalizer.isSplitCoequalizer f g) _‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Limits.hasCoequalizer_of_hasSplitCoequalizer","module":"Mathlib.CategoryTheory.Limits.Shapes.SplitCoequalizer","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ninst‚úù : CategoryTheory.HasSplitCoequalizer f g\n‚ä¢ CategoryTheory.Limits.HasCoequalizer f g","decl":"/-- If a pair has a split coequalizer, it has a coequalizer. -/\ninstance (priority := 1) hasCoequalizer_of_hasSplitCoequalizer [HasSplitCoequalizer f g] :\n    HasCoequalizer f g :=\n  HasColimit.mk ‚ü®_, (HasSplitCoequalizer.isSplitCoequalizer f g).isCoequalizer‚ü©\n\n"}
