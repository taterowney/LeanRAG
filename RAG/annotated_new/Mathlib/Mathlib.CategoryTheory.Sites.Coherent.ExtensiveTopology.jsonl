{"name":"CategoryTheory.extensiveTopology.mem_sieves_iff_contains_colimit_cofan","module":"Mathlib.CategoryTheory.Sites.Coherent.ExtensiveTopology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.FinitaryPreExtensive C\nX : C\nS : CategoryTheory.Sieve X\n⊢ Iff (Membership.mem ((CategoryTheory.extensiveTopology C) X) S) (Exists fun α => Exists fun x => Exists fun Y => Exists fun π => And (Nonempty (CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.Cofan.mk X π))) (∀ (a : α), S.arrows (π a)))","decl":"lemma extensiveTopology.mem_sieves_iff_contains_colimit_cofan {X : C} (S : Sieve X) :\n    S ∈ (extensiveTopology C) X ↔\n      (∃ (α : Type) (_ : Finite α) (Y : α → C) (π : (a : α) → (Y a ⟶ X)),\n        Nonempty (IsColimit (Cofan.mk X π)) ∧ (∀ a : α, (S.arrows) (π a))) := by\n  constructor\n  · intro h\n    induction h with\n    | of X S hS =>\n      obtain ⟨α, _, Y, π, h, h'⟩ := hS\n      refine ⟨α, inferInstance, Y, π, ?_, fun a ↦ ?_⟩\n      · have : IsIso (Sigma.desc (Cofan.mk X π).inj) := by simpa using h'\n        exact ⟨Cofan.isColimitOfIsIsoSigmaDesc (Cofan.mk X π)⟩\n      · obtain ⟨rfl, _⟩ := h\n        exact ⟨Y a, 𝟙 Y a, π a, Presieve.ofArrows.mk a, by simp⟩\n    | top X =>\n      refine ⟨Unit, inferInstance, fun _ => X, fun _ => (𝟙 X), ⟨?_⟩, by simp⟩\n      have : IsIso (Sigma.desc (Cofan.mk X fun (_ : Unit) ↦ 𝟙 X).inj) := by\n        have : IsIso (coproductUniqueIso (fun () => X)).hom := inferInstance\n        exact this\n      exact Cofan.isColimitOfIsIsoSigmaDesc (Cofan.mk X _)\n    | transitive X R S _ _ a b =>\n      obtain ⟨α, w, Y₁, π, h, h'⟩ := a\n      choose β _ Y_n π_n H using fun a => b (h' a)\n      exact ⟨(Σ a, β a), inferInstance, fun ⟨a,b⟩ => Y_n a b, fun ⟨a, b⟩ => (π_n a b) ≫ (π a),\n        ⟨Limits.Cofan.isColimitTrans _ h.some _ (fun a ↦ (H a).1.some)⟩,\n        fun c => (H c.fst).2 c.snd⟩\n  · intro ⟨α, _, Y, π, h, h'⟩\n    apply (extensiveCoverage C).mem_toGrothendieck_sieves_of_superset (R := Presieve.ofArrows Y π)\n    · exact fun _ _ hh ↦ by cases hh; exact h' _\n    · refine ⟨α, inferInstance, Y, π, rfl, ?_⟩\n      rw [show IsIso (Sigma.desc π) ↔ _ from\n        Limits.Cofan.isColimit_iff_isIso_sigmaDesc (c := Cofan.mk X π)]\n      exact h\n\n"}
