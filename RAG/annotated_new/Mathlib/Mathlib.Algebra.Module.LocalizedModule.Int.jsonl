{"name":"IsLocalizedModule.isInteger_zero","module":"Mathlib.Algebra.Module.LocalizedModule.Int","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nM' : Type u_3\ninst✝¹ : AddCommMonoid M'\ninst✝ : Module R M'\nf : LinearMap (RingHom.id R) M M'\n⊢ IsLocalizedModule.IsInteger f 0","decl":"lemma isInteger_zero : IsInteger f (0 : M') :=\n  Submodule.zero_mem _\n\n"}
{"name":"IsLocalizedModule.isInteger_add","module":"Mathlib.Algebra.Module.LocalizedModule.Int","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nM' : Type u_3\ninst✝¹ : AddCommMonoid M'\ninst✝ : Module R M'\nf : LinearMap (RingHom.id R) M M'\nx y : M'\nhx : IsLocalizedModule.IsInteger f x\nhy : IsLocalizedModule.IsInteger f y\n⊢ IsLocalizedModule.IsInteger f (HAdd.hAdd x y)","decl":"theorem isInteger_add {x y : M'} (hx : IsInteger f x) (hy : IsInteger f y) : IsInteger f (x + y) :=\n  Submodule.add_mem _ hx hy\n\n"}
{"name":"IsLocalizedModule.isInteger_smul","module":"Mathlib.Algebra.Module.LocalizedModule.Int","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nM' : Type u_3\ninst✝¹ : AddCommMonoid M'\ninst✝ : Module R M'\nf : LinearMap (RingHom.id R) M M'\na : R\nx : M'\nhx : IsLocalizedModule.IsInteger f x\n⊢ IsLocalizedModule.IsInteger f (HSMul.hSMul a x)","decl":"theorem isInteger_smul {a : R} {x : M'} (hx : IsInteger f x) : IsInteger f (a • x) := by\n  rcases hx with ⟨x', hx⟩\n  use a • x'\n  rw [← hx, LinearMapClass.map_smul]\n\n"}
{"name":"IsLocalizedModule.exists_integer_multiple","module":"Mathlib.Algebra.Module.LocalizedModule.Int","initialProofState":"R : Type u_1\ninst✝⁵ : CommSemiring R\nS : Submonoid R\nM : Type u_2\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nM' : Type u_3\ninst✝² : AddCommMonoid M'\ninst✝¹ : Module R M'\nf : LinearMap (RingHom.id R) M M'\ninst✝ : IsLocalizedModule S f\nx : M'\n⊢ Exists fun a => IsLocalizedModule.IsInteger f (HSMul.hSMul (↑a) x)","decl":"/-- Each element `x : M'` has an `S`-multiple which is an integer. -/\ntheorem exists_integer_multiple (x : M') : ∃ a : S, IsInteger f (a.val • x) :=\n  let ⟨⟨Num, denom⟩, h⟩ := IsLocalizedModule.surj S f x\n  ⟨denom, Set.mem_range.mpr ⟨Num, h.symm⟩⟩\n\n"}
{"name":"IsLocalizedModule.exist_integer_multiples","module":"Mathlib.Algebra.Module.LocalizedModule.Int","initialProofState":"R : Type u_1\ninst✝⁵ : CommSemiring R\nS : Submonoid R\nM : Type u_2\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nM' : Type u_3\ninst✝² : AddCommMonoid M'\ninst✝¹ : Module R M'\nf : LinearMap (RingHom.id R) M M'\ninst✝ : IsLocalizedModule S f\nι : Type u_4\ns : Finset ι\ng : ι → M'\n⊢ Exists fun b => ∀ (i : ι), Membership.mem s i → IsLocalizedModule.IsInteger f (HSMul.hSMul (↑b) (g i))","decl":"/-- We can clear the denominators of a `Finset`-indexed family of fractions. -/\ntheorem exist_integer_multiples {ι : Type*} (s : Finset ι) (g : ι → M') :\n    ∃ b : S, ∀ i ∈ s, IsInteger f (b.val • g i) := by\n  classical\n  choose sec hsec using (fun i ↦ IsLocalizedModule.surj S f (g i))\n  refine ⟨∏ i ∈ s, (sec i).2, fun i hi => ⟨?_, ?_⟩⟩\n  · exact (∏ j ∈ s.erase i, (sec j).2) • (sec i).1\n  · simp only [LinearMap.map_smul_of_tower, Submonoid.coe_finset_prod]\n    rw [← hsec, ← mul_smul, Submonoid.smul_def]\n    congr\n    simp only [Submonoid.coe_mul, Submonoid.coe_finset_prod, mul_comm]\n    rw [← Finset.prod_insert (f := fun i ↦ ((sec i).snd).val) (s.not_mem_erase i),\n      Finset.insert_erase hi]\n\n"}
{"name":"IsLocalizedModule.exist_integer_multiples_of_finite","module":"Mathlib.Algebra.Module.LocalizedModule.Int","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nS : Submonoid R\nM : Type u_2\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\nM' : Type u_3\ninst✝³ : AddCommMonoid M'\ninst✝² : Module R M'\nf : LinearMap (RingHom.id R) M M'\ninst✝¹ : IsLocalizedModule S f\nι : Type u_4\ninst✝ : Finite ι\ng : ι → M'\n⊢ Exists fun b => ∀ (i : ι), IsLocalizedModule.IsInteger f (HSMul.hSMul (↑b) (g i))","decl":"/-- We can clear the denominators of a finite indexed family of fractions. -/\ntheorem exist_integer_multiples_of_finite {ι : Type*} [Finite ι] (g : ι → M') :\n    ∃ b : S, ∀ i, IsInteger f ((b : R) • g i) := by\n  cases nonempty_fintype ι\n  obtain ⟨b, hb⟩ := exist_integer_multiples S f Finset.univ g\n  exact ⟨b, fun i => hb i (Finset.mem_univ _)⟩\n\n"}
{"name":"IsLocalizedModule.exist_integer_multiples_of_finset","module":"Mathlib.Algebra.Module.LocalizedModule.Int","initialProofState":"R : Type u_1\ninst✝⁵ : CommSemiring R\nS : Submonoid R\nM : Type u_2\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nM' : Type u_3\ninst✝² : AddCommMonoid M'\ninst✝¹ : Module R M'\nf : LinearMap (RingHom.id R) M M'\ninst✝ : IsLocalizedModule S f\ns : Finset M'\n⊢ Exists fun b => ∀ (a : M'), Membership.mem s a → IsLocalizedModule.IsInteger f (HSMul.hSMul (↑b) a)","decl":"/-- We can clear the denominators of a finite set of fractions. -/\ntheorem exist_integer_multiples_of_finset (s : Finset M') :\n    ∃ b : S, ∀ a ∈ s, IsInteger f ((b : R) • a) :=\n  exist_integer_multiples S f s id\n\n"}
{"name":"IsLocalizedModule.map_integerMultiple","module":"Mathlib.Algebra.Module.LocalizedModule.Int","initialProofState":"R : Type u_1\ninst✝⁵ : CommSemiring R\nS : Submonoid R\nM : Type u_2\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nM' : Type u_3\ninst✝² : AddCommMonoid M'\ninst✝¹ : Module R M'\nf : LinearMap (RingHom.id R) M M'\ninst✝ : IsLocalizedModule S f\nι : Type u_4\ns : Finset ι\ng : ι → M'\ni : Subtype fun x => Membership.mem s x\n⊢ Eq (f (IsLocalizedModule.integerMultiple S f s g i)) (HSMul.hSMul (IsLocalizedModule.commonDenom S f s g) (g ↑i))","decl":"@[simp]\ntheorem map_integerMultiple {ι : Type*} (s : Finset ι) (g : ι → M') (i : s) :\n    f (integerMultiple S f s g i) = commonDenom S f s g • g i :=\n  ((exist_integer_multiples S f s g).choose_spec _ i.prop).choose_spec\n\n"}
{"name":"IsLocalizedModule.finsetIntegerMultiple_image","module":"Mathlib.Algebra.Module.LocalizedModule.Int","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nS : Submonoid R\nM : Type u_2\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\nM' : Type u_3\ninst✝³ : AddCommMonoid M'\ninst✝² : Module R M'\nf : LinearMap (RingHom.id R) M M'\ninst✝¹ : IsLocalizedModule S f\ninst✝ : DecidableEq M\ns : Finset M'\n⊢ Eq (Set.image ⇑f ↑(IsLocalizedModule.finsetIntegerMultiple S f s)) (HSMul.hSMul (IsLocalizedModule.commonDenomOfFinset S f s) ↑s)","decl":"theorem finsetIntegerMultiple_image [DecidableEq M] (s : Finset M') :\n    f '' finsetIntegerMultiple S f s = commonDenomOfFinset S f s • (s : Set M') := by\n  delta finsetIntegerMultiple commonDenom\n  rw [Finset.coe_image]\n  ext\n  constructor\n  · rintro ⟨_, ⟨x, -, rfl⟩, rfl⟩\n    rw [map_integerMultiple]\n    exact Set.mem_image_of_mem _ x.prop\n  · rintro ⟨x, hx, rfl⟩\n    exact ⟨_, ⟨⟨x, hx⟩, s.mem_attach _, rfl⟩, map_integerMultiple S f s id _⟩\n\n"}
{"name":"IsLocalizedModule.smul_mem_finsetIntegerMultiple_span","module":"Mathlib.Algebra.Module.LocalizedModule.Int","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nS : Submonoid R\nM : Type u_2\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\nM' : Type u_3\ninst✝³ : AddCommMonoid M'\ninst✝² : Module R M'\nf : LinearMap (RingHom.id R) M M'\ninst✝¹ : IsLocalizedModule S f\ninst✝ : DecidableEq M\nx : M\ns : Finset M'\nhx : Membership.mem (Submodule.span R ↑s) (f x)\n⊢ Exists fun m => Membership.mem (Submodule.span R ↑(IsLocalizedModule.finsetIntegerMultiple S f s)) (HSMul.hSMul m x)","decl":"theorem smul_mem_finsetIntegerMultiple_span [DecidableEq M] (x : M) (s : Finset M')\n    (hx : f x ∈ Submodule.span R s) :\n    ∃ (m : S), m • x ∈ Submodule.span R (IsLocalizedModule.finsetIntegerMultiple S f s) := by\n  let y : S := IsLocalizedModule.commonDenomOfFinset S f s\n  have hx₁ : (y : R) • (s : Set M') = f '' _ :=\n    (IsLocalizedModule.finsetIntegerMultiple_image S f s).symm\n  apply congrArg (Submodule.span R) at hx₁\n  rw [Submodule.span_smul] at hx₁\n  replace hx : _ ∈ y • Submodule.span R (s : Set M') := Set.smul_mem_smul_set hx\n  erw [hx₁, ← f.map_smul, ← Submodule.map_span f] at hx\n  obtain ⟨x', hx', hx''⟩ := hx\n  obtain ⟨a, ha⟩ := (IsLocalizedModule.eq_iff_exists S f).mp hx''\n  use a * y\n  convert (Submodule.span R\n    (IsLocalizedModule.finsetIntegerMultiple S f s : Set M)).smul_mem\n      a hx' using 1\n  convert ha.symm using 1\n  simp only [Submonoid.coe_subtype, Submonoid.smul_def]\n  erw [← smul_smul]\n\n"}
