{"name":"CategoryTheory.solutionSetCondition_of_isRightAdjoint","module":"Mathlib.CategoryTheory.Adjunction.AdjointFunctorTheorems","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nD : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} D\nG : CategoryTheory.Functor D C\ninst✝ : G.IsRightAdjoint\n⊢ CategoryTheory.SolutionSetCondition G","decl":"/-- If `G : D ⥤ C` is a right adjoint it satisfies the solution set condition. -/\ntheorem solutionSetCondition_of_isRightAdjoint [G.IsRightAdjoint] : SolutionSetCondition G := by\n  intro A\n  refine\n    ⟨PUnit, fun _ => G.leftAdjoint.obj A, fun _ => (Adjunction.ofIsRightAdjoint G).unit.app A, ?_⟩\n  intro B h\n  refine ⟨PUnit.unit, ((Adjunction.ofIsRightAdjoint G).homEquiv _ _).symm h, ?_⟩\n  rw [← Adjunction.homEquiv_unit, Equiv.apply_symm_apply]\n\n"}
{"name":"CategoryTheory.isRightAdjoint_of_preservesLimits_of_solutionSetCondition","module":"Mathlib.CategoryTheory.Adjunction.AdjointFunctorTheorems","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nD : Type u\ninst✝² : CategoryTheory.Category.{v, u} D\nG : CategoryTheory.Functor D C\ninst✝¹ : CategoryTheory.Limits.HasLimits D\ninst✝ : CategoryTheory.Limits.PreservesLimits G\nhG : CategoryTheory.SolutionSetCondition G\n⊢ G.IsRightAdjoint","decl":"/-- The general adjoint functor theorem says that if `G : D ⥤ C` preserves limits and `D` has them,\nif `G` satisfies the solution set condition then `G` is a right adjoint.\n-/\nlemma isRightAdjoint_of_preservesLimits_of_solutionSetCondition [HasLimits D]\n    [PreservesLimits G] (hG : SolutionSetCondition G) : G.IsRightAdjoint := by\n  refine @isRightAdjointOfStructuredArrowInitials _ _ _ _ G ?_\n  intro A\n  specialize hG A\n  choose ι B f g using hG\n  let B' : ι → StructuredArrow A G := fun i => StructuredArrow.mk (f i)\n  have hB' : ∀ A' : StructuredArrow A G, ∃ i, Nonempty (B' i ⟶ A') := by\n    intro A'\n    obtain ⟨i, _, t⟩ := g _ A'.hom\n    exact ⟨i, ⟨StructuredArrow.homMk _ t⟩⟩\n  obtain ⟨T, hT⟩ := has_weakly_initial_of_weakly_initial_set_and_hasProducts hB'\n  apply hasInitial_of_weakly_initial_and_hasWideEqualizers hT\n\n"}
{"name":"CategoryTheory.isRightAdjoint_of_preservesLimits_of_isCoseparating","module":"Mathlib.CategoryTheory.Adjunction.AdjointFunctorTheorems","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝⁴ : CategoryTheory.Category.{v, u'} D\ninst✝³ : CategoryTheory.Limits.HasLimits D\ninst✝² : CategoryTheory.WellPowered.{v, v, u'} D\n𝒢 : Set D\ninst✝¹ : Small.{v, u'} ↑𝒢\nh𝒢 : CategoryTheory.IsCoseparating 𝒢\nG : CategoryTheory.Functor D C\ninst✝ : CategoryTheory.Limits.PreservesLimits G\n⊢ G.IsRightAdjoint","decl":"/-- The special adjoint functor theorem: if `G : D ⥤ C` preserves limits and `D` is complete,\nwell-powered and has a small coseparating set, then `G` has a left adjoint.\n-/\nlemma isRightAdjoint_of_preservesLimits_of_isCoseparating [HasLimits D] [WellPowered.{v} D]\n    {𝒢 : Set D} [Small.{v} 𝒢] (h𝒢 : IsCoseparating 𝒢) (G : D ⥤ C) [PreservesLimits G] :\n    G.IsRightAdjoint :=\n  have : ∀ A, HasInitial (StructuredArrow A G) := fun A =>\n    hasInitial_of_isCoseparating (StructuredArrow.isCoseparating_proj_preimage A G h𝒢)\n  isRightAdjointOfStructuredArrowInitials _\n\n"}
{"name":"CategoryTheory.isLeftAdjoint_of_preservesColimits_of_isSeparating","module":"Mathlib.CategoryTheory.Adjunction.AdjointFunctorTheorems","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝⁴ : CategoryTheory.Category.{v, u'} D\ninst✝³ : CategoryTheory.Limits.HasColimits C\ninst✝² : CategoryTheory.WellPowered.{v, v, u} (Opposite C)\n𝒢 : Set C\ninst✝¹ : Small.{v, u} ↑𝒢\nh𝒢 : CategoryTheory.IsSeparating 𝒢\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.PreservesColimits F\n⊢ F.IsLeftAdjoint","decl":"/-- The special adjoint functor theorem: if `F : C ⥤ D` preserves colimits and `C` is cocomplete,\nwell-copowered and has a small separating set, then `F` has a right adjoint.\n-/\nlemma isLeftAdjoint_of_preservesColimits_of_isSeparating [HasColimits C] [WellPowered.{v} Cᵒᵖ]\n    {𝒢 : Set C} [Small.{v} 𝒢] (h𝒢 : IsSeparating 𝒢) (F : C ⥤ D) [PreservesColimits F] :\n    F.IsLeftAdjoint :=\n  have : ∀ A, HasTerminal (CostructuredArrow F A) := fun A =>\n    hasTerminal_of_isSeparating (CostructuredArrow.isSeparating_proj_preimage F A h𝒢)\n  isLeftAdjoint_of_costructuredArrowTerminals _\n\n"}
{"name":"CategoryTheory.Limits.hasColimits_of_hasLimits_of_isCoseparating","module":"Mathlib.CategoryTheory.Adjunction.AdjointFunctorTheorems","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasLimits C\ninst✝¹ : CategoryTheory.WellPowered.{v, v, u} C\n𝒢 : Set C\ninst✝ : Small.{v, u} ↑𝒢\nh𝒢 : CategoryTheory.IsCoseparating 𝒢\n⊢ CategoryTheory.Limits.HasColimits C","decl":"/-- A consequence of the special adjoint functor theorem: if `C` is complete, well-powered and\n    has a small coseparating set, then it is cocomplete. -/\ntheorem hasColimits_of_hasLimits_of_isCoseparating [HasLimits C] [WellPowered.{v} C] {𝒢 : Set C}\n    [Small.{v} 𝒢] (h𝒢 : IsCoseparating 𝒢) : HasColimits C :=\n  { has_colimits_of_shape := fun _ _ =>\n      hasColimitsOfShape_iff_isRightAdjoint_const.2\n        (isRightAdjoint_of_preservesLimits_of_isCoseparating h𝒢 _) }\n\n"}
{"name":"CategoryTheory.Limits.hasLimits_of_hasColimits_of_isSeparating","module":"Mathlib.CategoryTheory.Adjunction.AdjointFunctorTheorems","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasColimits C\ninst✝¹ : CategoryTheory.WellPowered.{v, v, u} (Opposite C)\n𝒢 : Set C\ninst✝ : Small.{v, u} ↑𝒢\nh𝒢 : CategoryTheory.IsSeparating 𝒢\n⊢ CategoryTheory.Limits.HasLimits C","decl":"/-- A consequence of the special adjoint functor theorem: if `C` is cocomplete, well-copowered and\n    has a small separating set, then it is complete. -/\ntheorem hasLimits_of_hasColimits_of_isSeparating [HasColimits C] [WellPowered.{v} Cᵒᵖ] {𝒢 : Set C}\n    [Small.{v} 𝒢] (h𝒢 : IsSeparating 𝒢) : HasLimits C :=\n  { has_limits_of_shape := fun _ _ =>\n      hasLimitsOfShape_iff_isLeftAdjoint_const.2\n        (isLeftAdjoint_of_preservesColimits_of_isSeparating h𝒢 _) }\n\n"}
{"name":"CategoryTheory.Limits.hasLimits_of_hasColimits_of_hasSeparator","module":"Mathlib.CategoryTheory.Adjunction.AdjointFunctorTheorems","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasColimits C\ninst✝¹ : CategoryTheory.HasSeparator C\ninst✝ : CategoryTheory.WellPowered.{v, v, u} (Opposite C)\n⊢ CategoryTheory.Limits.HasLimits C","decl":"/-- A consequence of the special adjoint functor theorem: if `C` is complete, well-powered and\n    has a separator, then it is complete. -/\ntheorem hasLimits_of_hasColimits_of_hasSeparator [HasColimits C] [HasSeparator C]\n    [WellPowered.{v} Cᵒᵖ] : HasLimits C :=\n  hasLimits_of_hasColimits_of_isSeparating <| isSeparator_separator C\n\n"}
{"name":"CategoryTheory.Limits.hasColimits_of_hasLimits_of_hasCoseparator","module":"Mathlib.CategoryTheory.Adjunction.AdjointFunctorTheorems","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasLimits C\ninst✝¹ : CategoryTheory.HasCoseparator C\ninst✝ : CategoryTheory.WellPowered.{v, v, u} C\n⊢ CategoryTheory.Limits.HasColimits C","decl":"/-- A consequence of the special adjoint functor theorem: if `C` is complete, well-powered and\n    has a coseparator, then it is cocomplete. -/\ntheorem hasColimits_of_hasLimits_of_hasCoseparator [HasLimits C] [HasCoseparator C]\n    [WellPowered.{v} C] : HasColimits C :=\n  hasColimits_of_hasLimits_of_isCoseparating <| isCoseparator_coseparator C\n\n"}
