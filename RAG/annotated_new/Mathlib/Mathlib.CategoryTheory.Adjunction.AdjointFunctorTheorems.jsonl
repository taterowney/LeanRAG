{"name":"CategoryTheory.solutionSetCondition_of_isRightAdjoint","module":"Mathlib.CategoryTheory.Adjunction.AdjointFunctorTheorems","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nD : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} D\nG : CategoryTheory.Functor D C\ninstâœ : G.IsRightAdjoint\nâŠ¢ CategoryTheory.SolutionSetCondition G","decl":"/-- If `G : D â¥¤ C` is a right adjoint it satisfies the solution set condition. -/\ntheorem solutionSetCondition_of_isRightAdjoint [G.IsRightAdjoint] : SolutionSetCondition G := by\n  intro A\n  refine\n    âŸ¨PUnit, fun _ => G.leftAdjoint.obj A, fun _ => (Adjunction.ofIsRightAdjoint G).unit.app A, ?_âŸ©\n  intro B h\n  refine âŸ¨PUnit.unit, ((Adjunction.ofIsRightAdjoint G).homEquiv _ _).symm h, ?_âŸ©\n  rw [â† Adjunction.homEquiv_unit, Equiv.apply_symm_apply]\n\n"}
{"name":"CategoryTheory.isRightAdjoint_of_preservesLimits_of_solutionSetCondition","module":"Mathlib.CategoryTheory.Adjunction.AdjointFunctorTheorems","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\nD : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} D\nG : CategoryTheory.Functor D C\ninstâœÂ¹ : CategoryTheory.Limits.HasLimits D\ninstâœ : CategoryTheory.Limits.PreservesLimits G\nhG : CategoryTheory.SolutionSetCondition G\nâŠ¢ G.IsRightAdjoint","decl":"/-- The general adjoint functor theorem says that if `G : D â¥¤ C` preserves limits and `D` has them,\nif `G` satisfies the solution set condition then `G` is a right adjoint.\n-/\nlemma isRightAdjoint_of_preservesLimits_of_solutionSetCondition [HasLimits D]\n    [PreservesLimits G] (hG : SolutionSetCondition G) : G.IsRightAdjoint := by\n  refine @isRightAdjointOfStructuredArrowInitials _ _ _ _ G ?_\n  intro A\n  specialize hG A\n  choose Î¹ B f g using hG\n  let B' : Î¹ â†’ StructuredArrow A G := fun i => StructuredArrow.mk (f i)\n  have hB' : âˆ€ A' : StructuredArrow A G, âˆƒ i, Nonempty (B' i âŸ¶ A') := by\n    intro A'\n    obtain âŸ¨i, _, tâŸ© := g _ A'.hom\n    exact âŸ¨i, âŸ¨StructuredArrow.homMk _ tâŸ©âŸ©\n  obtain âŸ¨T, hTâŸ© := has_weakly_initial_of_weakly_initial_set_and_hasProducts hB'\n  apply hasInitial_of_weakly_initial_and_hasWideEqualizers hT\n\n"}
{"name":"CategoryTheory.isRightAdjoint_of_preservesLimits_of_isCoseparating","module":"Mathlib.CategoryTheory.Adjunction.AdjointFunctorTheorems","initialProofState":"C : Type u\ninstâœâµ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninstâœâ´ : CategoryTheory.Category.{v, u'} D\ninstâœÂ³ : CategoryTheory.Limits.HasLimits D\ninstâœÂ² : CategoryTheory.WellPowered.{v, v, u'} D\nğ’¢ : Set D\ninstâœÂ¹ : Small.{v, u'} â†‘ğ’¢\nhğ’¢ : CategoryTheory.IsCoseparating ğ’¢\nG : CategoryTheory.Functor D C\ninstâœ : CategoryTheory.Limits.PreservesLimits G\nâŠ¢ G.IsRightAdjoint","decl":"/-- The special adjoint functor theorem: if `G : D â¥¤ C` preserves limits and `D` is complete,\nwell-powered and has a small coseparating set, then `G` has a left adjoint.\n-/\nlemma isRightAdjoint_of_preservesLimits_of_isCoseparating [HasLimits D] [WellPowered.{v} D]\n    {ğ’¢ : Set D} [Small.{v} ğ’¢] (hğ’¢ : IsCoseparating ğ’¢) (G : D â¥¤ C) [PreservesLimits G] :\n    G.IsRightAdjoint :=\n  have : âˆ€ A, HasInitial (StructuredArrow A G) := fun A =>\n    hasInitial_of_isCoseparating (StructuredArrow.isCoseparating_proj_preimage A G hğ’¢)\n  isRightAdjointOfStructuredArrowInitials _\n\n"}
{"name":"CategoryTheory.isLeftAdjoint_of_preservesColimits_of_isSeparating","module":"Mathlib.CategoryTheory.Adjunction.AdjointFunctorTheorems","initialProofState":"C : Type u\ninstâœâµ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninstâœâ´ : CategoryTheory.Category.{v, u'} D\ninstâœÂ³ : CategoryTheory.Limits.HasColimits C\ninstâœÂ² : CategoryTheory.WellPowered.{v, v, u} (Opposite C)\nğ’¢ : Set C\ninstâœÂ¹ : Small.{v, u} â†‘ğ’¢\nhğ’¢ : CategoryTheory.IsSeparating ğ’¢\nF : CategoryTheory.Functor C D\ninstâœ : CategoryTheory.Limits.PreservesColimits F\nâŠ¢ F.IsLeftAdjoint","decl":"/-- The special adjoint functor theorem: if `F : C â¥¤ D` preserves colimits and `C` is cocomplete,\nwell-copowered and has a small separating set, then `F` has a right adjoint.\n-/\nlemma isLeftAdjoint_of_preservesColimits_of_isSeparating [HasColimits C] [WellPowered.{v} Cáµ’áµ–]\n    {ğ’¢ : Set C} [Small.{v} ğ’¢] (hğ’¢ : IsSeparating ğ’¢) (F : C â¥¤ D) [PreservesColimits F] :\n    F.IsLeftAdjoint :=\n  have : âˆ€ A, HasTerminal (CostructuredArrow F A) := fun A =>\n    hasTerminal_of_isSeparating (CostructuredArrow.isSeparating_proj_preimage F A hğ’¢)\n  isLeftAdjoint_of_costructuredArrowTerminals _\n\n"}
{"name":"CategoryTheory.Limits.hasColimits_of_hasLimits_of_isCoseparating","module":"Mathlib.CategoryTheory.Adjunction.AdjointFunctorTheorems","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasLimits C\ninstâœÂ¹ : CategoryTheory.WellPowered.{v, v, u} C\nğ’¢ : Set C\ninstâœ : Small.{v, u} â†‘ğ’¢\nhğ’¢ : CategoryTheory.IsCoseparating ğ’¢\nâŠ¢ CategoryTheory.Limits.HasColimits C","decl":"/-- A consequence of the special adjoint functor theorem: if `C` is complete, well-powered and\n    has a small coseparating set, then it is cocomplete. -/\ntheorem hasColimits_of_hasLimits_of_isCoseparating [HasLimits C] [WellPowered.{v} C] {ğ’¢ : Set C}\n    [Small.{v} ğ’¢] (hğ’¢ : IsCoseparating ğ’¢) : HasColimits C :=\n  { has_colimits_of_shape := fun _ _ =>\n      hasColimitsOfShape_iff_isRightAdjoint_const.2\n        (isRightAdjoint_of_preservesLimits_of_isCoseparating hğ’¢ _) }\n\n"}
{"name":"CategoryTheory.Limits.hasLimits_of_hasColimits_of_isSeparating","module":"Mathlib.CategoryTheory.Adjunction.AdjointFunctorTheorems","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasColimits C\ninstâœÂ¹ : CategoryTheory.WellPowered.{v, v, u} (Opposite C)\nğ’¢ : Set C\ninstâœ : Small.{v, u} â†‘ğ’¢\nhğ’¢ : CategoryTheory.IsSeparating ğ’¢\nâŠ¢ CategoryTheory.Limits.HasLimits C","decl":"/-- A consequence of the special adjoint functor theorem: if `C` is cocomplete, well-copowered and\n    has a small separating set, then it is complete. -/\ntheorem hasLimits_of_hasColimits_of_isSeparating [HasColimits C] [WellPowered.{v} Cáµ’áµ–] {ğ’¢ : Set C}\n    [Small.{v} ğ’¢] (hğ’¢ : IsSeparating ğ’¢) : HasLimits C :=\n  { has_limits_of_shape := fun _ _ =>\n      hasLimitsOfShape_iff_isLeftAdjoint_const.2\n        (isLeftAdjoint_of_preservesColimits_of_isSeparating hğ’¢ _) }\n\n"}
{"name":"CategoryTheory.Limits.hasLimits_of_hasColimits_of_hasSeparator","module":"Mathlib.CategoryTheory.Adjunction.AdjointFunctorTheorems","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasColimits C\ninstâœÂ¹ : CategoryTheory.HasSeparator C\ninstâœ : CategoryTheory.WellPowered.{v, v, u} (Opposite C)\nâŠ¢ CategoryTheory.Limits.HasLimits C","decl":"/-- A consequence of the special adjoint functor theorem: if `C` is complete, well-powered and\n    has a separator, then it is complete. -/\ntheorem hasLimits_of_hasColimits_of_hasSeparator [HasColimits C] [HasSeparator C]\n    [WellPowered.{v} Cáµ’áµ–] : HasLimits C :=\n  hasLimits_of_hasColimits_of_isSeparating <| isSeparator_separator C\n\n"}
{"name":"CategoryTheory.Limits.hasColimits_of_hasLimits_of_hasCoseparator","module":"Mathlib.CategoryTheory.Adjunction.AdjointFunctorTheorems","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasLimits C\ninstâœÂ¹ : CategoryTheory.HasCoseparator C\ninstâœ : CategoryTheory.WellPowered.{v, v, u} C\nâŠ¢ CategoryTheory.Limits.HasColimits C","decl":"/-- A consequence of the special adjoint functor theorem: if `C` is complete, well-powered and\n    has a coseparator, then it is cocomplete. -/\ntheorem hasColimits_of_hasLimits_of_hasCoseparator [HasLimits C] [HasCoseparator C]\n    [WellPowered.{v} C] : HasColimits C :=\n  hasColimits_of_hasLimits_of_isCoseparating <| isCoseparator_coseparator C\n\n"}
