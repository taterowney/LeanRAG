{"name":"IsPrimitiveRoot.prod_one_sub_pow_eq_order","module":"Mathlib.RingTheory.RootsOfUnity.Lemmas","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nn : Nat\nμ : R\nhμ : IsPrimitiveRoot μ (HAdd.hAdd n 1)\n⊢ Eq ((Finset.range n).prod fun k => HSub.hSub 1 (HPow.hPow μ (HAdd.hAdd k 1))) (HAdd.hAdd (↑n) 1)","decl":"/-- If `μ` is a primitive `n`th root of unity in `R`, then `∏(1≤k<n) (1-μ^k) = n`.\n(Stated with `n+1` in place of `n` to avoid the condition `n ≠ 0`.) -/\nlemma prod_one_sub_pow_eq_order {n : ℕ} {μ : R} (hμ : IsPrimitiveRoot μ (n + 1)) :\n    ∏ k ∈ range n, (1 - μ ^ (k + 1)) = n + 1 := by\n  have := X_pow_sub_C_eq_prod hμ n.zero_lt_succ (one_pow (n + 1))\n  rw [C_1, ← mul_geom_sum, prod_range_succ', pow_zero, mul_one, mul_comm, eq_comm] at this\n  replace this := mul_right_cancel₀ (Polynomial.X_sub_C_ne_zero 1) this\n  apply_fun Polynomial.eval 1 at this\n  simpa only [mul_one, map_pow, eval_prod, eval_sub, eval_X, eval_pow, eval_C, eval_geom_sum,\n    one_pow, sum_const, card_range, nsmul_eq_mul, Nat.cast_add, Nat.cast_one] using this\n\n"}
{"name":"IsPrimitiveRoot.prod_pow_sub_one_eq_order","module":"Mathlib.RingTheory.RootsOfUnity.Lemmas","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nn : Nat\nμ : R\nhμ : IsPrimitiveRoot μ (HAdd.hAdd n 1)\n⊢ Eq (HMul.hMul (HPow.hPow (-1) n) ((Finset.range n).prod fun k => HSub.hSub (HPow.hPow μ (HAdd.hAdd k 1)) 1)) (HAdd.hAdd (↑n) 1)","decl":"/-- If `μ` is a primitive `n`th root of unity in `R`, then `(-1)^(n-1) * ∏(1≤k<n) (μ^k-1) = n`.\n(Stated with `n+1` in place of `n` to avoid the condition `n ≠ 0`.) -/\nlemma prod_pow_sub_one_eq_order {n : ℕ} {μ : R} (hμ : IsPrimitiveRoot μ (n + 1)) :\n    (-1) ^ n * ∏ k ∈ range n, (μ ^ (k + 1) - 1) = n + 1 := by\n  have : (-1 : R) ^ n = ∏ k ∈ range n, -1 := by rw [prod_const, card_range]\n  simp only [this, ← prod_mul_distrib, neg_one_mul, neg_sub, ← prod_one_sub_pow_eq_order hμ]\n\n"}
{"name":"IsPrimitiveRoot.self_sub_one_pow_dvd_order","module":"Mathlib.RingTheory.RootsOfUnity.Lemmas","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nk n : Nat\nhn : LT.lt k n\nμ : R\nhμ : IsPrimitiveRoot μ n\n⊢ Exists fun z => And (Membership.mem (Algebra.adjoin Int (Singleton.singleton μ)) z) (Eq (↑n) (HMul.hMul z (HPow.hPow (HSub.hSub μ 1) k)))","decl":"open Algebra in\n/-- If `μ` is a primitive `n`th root of unity in `R` and `k < n`, then `n` is divisible\nby `(μ-1)^k` in `ℤ[μ] ⊆ R`. -/\nlemma self_sub_one_pow_dvd_order {k n : ℕ} (hn : k < n) {μ : R} (hμ : IsPrimitiveRoot μ n) :\n    ∃ z ∈ adjoin ℤ {μ}, n = z * (μ - 1) ^ k := by\n  let n' + 1 := n\n  obtain ⟨m, rfl⟩ := Nat.exists_eq_add_of_le' (Nat.le_of_lt_succ hn)\n  have hdvd k : ∃ z ∈ adjoin ℤ {μ}, μ ^ k - 1 = z * (μ - 1) := by\n    refine ⟨(Finset.range k).sum (μ ^ ·), ?_, (geom_sum_mul μ k).symm⟩\n    exact Subalgebra.sum_mem _ fun m _ ↦ Subalgebra.pow_mem _ (self_mem_adjoin_singleton _ μ) _\n  let Z k := Classical.choose <| hdvd k\n  have Zdef k : Z k ∈ adjoin ℤ {μ} ∧ μ ^ k - 1 = Z k * (μ - 1) :=\n    Classical.choose_spec <| hdvd k\n  refine ⟨(-1) ^ (m + k) * (∏ j ∈ range k, Z (j + 1)) * ∏ j ∈ Ico k (m + k), (μ ^ (j + 1) - 1),\n    ?_, ?_⟩\n  · apply Subalgebra.mul_mem\n    · apply Subalgebra.mul_mem\n      · exact Subalgebra.pow_mem _ (Subalgebra.neg_mem _ <| Subalgebra.one_mem _) _\n      · exact Subalgebra.prod_mem _ fun _ _ ↦ (Zdef _).1\n    · refine Subalgebra.prod_mem _ fun _ _ ↦ ?_\n      apply Subalgebra.sub_mem\n      · exact Subalgebra.pow_mem _ (self_mem_adjoin_singleton ℤ μ) _\n      · exact Subalgebra.one_mem _\n  · push_cast\n    have := Nat.cast_add (R := R) m k ▸ hμ.prod_pow_sub_one_eq_order\n    rw [← this, mul_assoc, mul_assoc]\n    congr 1\n    conv => enter [2, 2, 2]; rw [← card_range k]\n    rw [← prod_range_mul_prod_Ico _ (Nat.le_add_left k m), mul_comm _ (_ ^ #_), ← mul_assoc,\n      prod_mul_pow_card]\n    conv => enter [2, 1, 2, j]; rw [← (Zdef _).2]\n\n"}
