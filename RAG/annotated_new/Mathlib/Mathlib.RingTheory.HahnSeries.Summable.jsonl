{"name":"HahnSeries.SummableFamily.mk.inj","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_8\nR : Type u_9\ninst✝¹ : PartialOrder Γ\ninst✝ : AddCommMonoid R\nα : Type u_7\ntoFun✝ : α → HahnSeries Γ R\nisPWO_iUnion_support'✝ : (Set.iUnion fun a => (toFun✝ a).support).IsPWO\nfinite_co_support'✝ : ∀ (g : Γ), (setOf fun a => Ne ((toFun✝ a).coeff g) 0).Finite\ntoFun : α → HahnSeries Γ R\nisPWO_iUnion_support' : (Set.iUnion fun a => (toFun a).support).IsPWO\nfinite_co_support' : ∀ (g : Γ), (setOf fun a => Ne ((toFun a).coeff g) 0).Finite\nx✝ : Eq { toFun := toFun✝, isPWO_iUnion_support' := isPWO_iUnion_support'✝, finite_co_support' := finite_co_support'✝ } { toFun := toFun, isPWO_iUnion_support' := isPWO_iUnion_support', finite_co_support' := finite_co_support' }\n⊢ Eq toFun✝ toFun","decl":"/-- A family of Hahn series whose formal coefficient-wise sum is a Hahn series.  For each\ncoefficient of the sum to be well-defined, we require that only finitely many series are nonzero at\nany given coefficient.  For the formal sum to be a Hahn series, we require that the union of the\nsupports of the constituent series is partially well-ordered. -/\nstructure SummableFamily (Γ) (R) [PartialOrder Γ] [AddCommMonoid R] (α : Type*) where\n  /-- A parametrized family of Hahn series. -/\n  toFun : α → HahnSeries Γ R\n  isPWO_iUnion_support' : Set.IsPWO (⋃ a : α, (toFun a).support)\n  finite_co_support' : ∀ g : Γ, { a | (toFun a).coeff g ≠ 0 }.Finite\n\n"}
{"name":"HahnSeries.SummableFamily.mk.injEq","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_8\nR : Type u_9\ninst✝¹ : PartialOrder Γ\ninst✝ : AddCommMonoid R\nα : Type u_7\ntoFun✝ : α → HahnSeries Γ R\nisPWO_iUnion_support'✝ : (Set.iUnion fun a => (toFun✝ a).support).IsPWO\nfinite_co_support'✝ : ∀ (g : Γ), (setOf fun a => Ne ((toFun✝ a).coeff g) 0).Finite\ntoFun : α → HahnSeries Γ R\nisPWO_iUnion_support' : (Set.iUnion fun a => (toFun a).support).IsPWO\nfinite_co_support' : ∀ (g : Γ), (setOf fun a => Ne ((toFun a).coeff g) 0).Finite\n⊢ Eq (Eq { toFun := toFun✝, isPWO_iUnion_support' := isPWO_iUnion_support'✝, finite_co_support' := finite_co_support'✝ } { toFun := toFun, isPWO_iUnion_support' := isPWO_iUnion_support', finite_co_support' := finite_co_support' }) (Eq toFun✝ toFun)","decl":"/-- A family of Hahn series whose formal coefficient-wise sum is a Hahn series.  For each\ncoefficient of the sum to be well-defined, we require that only finitely many series are nonzero at\nany given coefficient.  For the formal sum to be a Hahn series, we require that the union of the\nsupports of the constituent series is partially well-ordered. -/\nstructure SummableFamily (Γ) (R) [PartialOrder Γ] [AddCommMonoid R] (α : Type*) where\n  /-- A parametrized family of Hahn series. -/\n  toFun : α → HahnSeries Γ R\n  isPWO_iUnion_support' : Set.IsPWO (⋃ a : α, (toFun a).support)\n  finite_co_support' : ∀ g : Γ, { a | (toFun a).coeff g ≠ 0 }.Finite\n\n"}
{"name":"HahnSeries.SummableFamily.mk.sizeOf_spec","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_8\nR : Type u_9\ninst✝⁴ : PartialOrder Γ\ninst✝³ : AddCommMonoid R\nα : Type u_7\ninst✝² : SizeOf Γ\ninst✝¹ : SizeOf R\ninst✝ : SizeOf α\ntoFun : α → HahnSeries Γ R\nisPWO_iUnion_support' : (Set.iUnion fun a => (toFun a).support).IsPWO\nfinite_co_support' : ∀ (g : Γ), (setOf fun a => Ne ((toFun a).coeff g) 0).Finite\n⊢ Eq (SizeOf.sizeOf { toFun := toFun, isPWO_iUnion_support' := isPWO_iUnion_support', finite_co_support' := finite_co_support' }) 1","decl":"/-- A family of Hahn series whose formal coefficient-wise sum is a Hahn series.  For each\ncoefficient of the sum to be well-defined, we require that only finitely many series are nonzero at\nany given coefficient.  For the formal sum to be a Hahn series, we require that the union of the\nsupports of the constituent series is partially well-ordered. -/\nstructure SummableFamily (Γ) (R) [PartialOrder Γ] [AddCommMonoid R] (α : Type*) where\n  /-- A parametrized family of Hahn series. -/\n  toFun : α → HahnSeries Γ R\n  isPWO_iUnion_support' : Set.IsPWO (⋃ a : α, (toFun a).support)\n  finite_co_support' : ∀ g : Γ, { a | (toFun a).coeff g ≠ 0 }.Finite\n\n"}
{"name":"HahnSeries.SummableFamily.finite_co_support'","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_8\nR : Type u_9\ninst✝¹ : PartialOrder Γ\ninst✝ : AddCommMonoid R\nα : Type u_7\nself : HahnSeries.SummableFamily Γ R α\ng : Γ\n⊢ (setOf fun a => Ne ((self.toFun a).coeff g) 0).Finite","decl":"/-- A family of Hahn series whose formal coefficient-wise sum is a Hahn series.  For each\ncoefficient of the sum to be well-defined, we require that only finitely many series are nonzero at\nany given coefficient.  For the formal sum to be a Hahn series, we require that the union of the\nsupports of the constituent series is partially well-ordered. -/\nstructure SummableFamily (Γ) (R) [PartialOrder Γ] [AddCommMonoid R] (α : Type*) where\n  /-- A parametrized family of Hahn series. -/\n  toFun : α → HahnSeries Γ R\n  isPWO_iUnion_support' : Set.IsPWO (⋃ a : α, (toFun a).support)\n  finite_co_support' : ∀ g : Γ, { a | (toFun a).coeff g ≠ 0 }.Finite\n\n"}
{"name":"HahnSeries.SummableFamily.isPWO_iUnion_support'","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_8\nR : Type u_9\ninst✝¹ : PartialOrder Γ\ninst✝ : AddCommMonoid R\nα : Type u_7\nself : HahnSeries.SummableFamily Γ R α\n⊢ (Set.iUnion fun a => (self.toFun a).support).IsPWO","decl":"/-- A family of Hahn series whose formal coefficient-wise sum is a Hahn series.  For each\ncoefficient of the sum to be well-defined, we require that only finitely many series are nonzero at\nany given coefficient.  For the formal sum to be a Hahn series, we require that the union of the\nsupports of the constituent series is partially well-ordered. -/\nstructure SummableFamily (Γ) (R) [PartialOrder Γ] [AddCommMonoid R] (α : Type*) where\n  /-- A parametrized family of Hahn series. -/\n  toFun : α → HahnSeries Γ R\n  isPWO_iUnion_support' : Set.IsPWO (⋃ a : α, (toFun a).support)\n  finite_co_support' : ∀ g : Γ, { a | (toFun a).coeff g ≠ 0 }.Finite\n\n"}
{"name":"HahnSeries.SummableFamily.isPWO_iUnion_support","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nR : Type u_3\nα : Type u_5\ninst✝¹ : PartialOrder Γ\ninst✝ : AddCommMonoid R\ns : HahnSeries.SummableFamily Γ R α\n⊢ (Set.iUnion fun a => (s a).support).IsPWO","decl":"theorem isPWO_iUnion_support (s : SummableFamily Γ R α) : Set.IsPWO (⋃ a : α, (s a).support) :=\n  s.isPWO_iUnion_support'\n\n"}
{"name":"HahnSeries.SummableFamily.finite_co_support","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nR : Type u_3\nα : Type u_5\ninst✝¹ : PartialOrder Γ\ninst✝ : AddCommMonoid R\ns : HahnSeries.SummableFamily Γ R α\ng : Γ\n⊢ (Function.support fun a => (s a).coeff g).Finite","decl":"theorem finite_co_support (s : SummableFamily Γ R α) (g : Γ) :\n    (Function.support fun a => (s a).coeff g).Finite :=\n  s.finite_co_support' g\n\n"}
{"name":"HahnSeries.SummableFamily.coe_injective","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nR : Type u_3\nα : Type u_5\ninst✝¹ : PartialOrder Γ\ninst✝ : AddCommMonoid R\n⊢ Function.Injective DFunLike.coe","decl":"theorem coe_injective : @Function.Injective (SummableFamily Γ R α) (α → HahnSeries Γ R) (⇑) :=\n  DFunLike.coe_injective\n\n"}
{"name":"HahnSeries.SummableFamily.ext","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nR : Type u_3\nα : Type u_5\ninst✝¹ : PartialOrder Γ\ninst✝ : AddCommMonoid R\ns t : HahnSeries.SummableFamily Γ R α\nh : ∀ (a : α), Eq (s a) (t a)\n⊢ Eq s t","decl":"@[ext]\ntheorem ext {s t : SummableFamily Γ R α} (h : ∀ a : α, s a = t a) : s = t :=\n  DFunLike.ext s t h\n\n"}
{"name":"HahnSeries.SummableFamily.ext_iff","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nR : Type u_3\nα : Type u_5\ninst✝¹ : PartialOrder Γ\ninst✝ : AddCommMonoid R\ns t : HahnSeries.SummableFamily Γ R α\n⊢ Iff (Eq s t) (∀ (a : α), Eq (s a) (t a))","decl":"@[ext]\ntheorem ext {s t : SummableFamily Γ R α} (h : ∀ a : α, s a = t a) : s = t :=\n  DFunLike.ext s t h\n\n"}
{"name":"HahnSeries.SummableFamily.coe_add","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nR : Type u_3\nα : Type u_5\ninst✝¹ : PartialOrder Γ\ninst✝ : AddCommMonoid R\ns t : HahnSeries.SummableFamily Γ R α\n⊢ Eq (⇑(HAdd.hAdd s t)) (HAdd.hAdd ⇑s ⇑t)","decl":"@[simp]\ntheorem coe_add {s t : SummableFamily Γ R α} : ⇑(s + t) = s + t :=\n  rfl\n\n"}
{"name":"HahnSeries.SummableFamily.add_apply","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nR : Type u_3\nα : Type u_5\ninst✝¹ : PartialOrder Γ\ninst✝ : AddCommMonoid R\ns t : HahnSeries.SummableFamily Γ R α\na : α\n⊢ Eq ((HAdd.hAdd s t) a) (HAdd.hAdd (s a) (t a))","decl":"theorem add_apply {s t : SummableFamily Γ R α} {a : α} : (s + t) a = s a + t a :=\n  rfl\n\n"}
{"name":"HahnSeries.SummableFamily.coe_zero","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nR : Type u_3\nα : Type u_5\ninst✝¹ : PartialOrder Γ\ninst✝ : AddCommMonoid R\n⊢ Eq (⇑0) 0","decl":"@[simp]\ntheorem coe_zero : ((0 : SummableFamily Γ R α) : α → HahnSeries Γ R) = 0 :=\n  rfl\n\n"}
{"name":"HahnSeries.SummableFamily.zero_apply","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nR : Type u_3\nα : Type u_5\ninst✝¹ : PartialOrder Γ\ninst✝ : AddCommMonoid R\na : α\n⊢ Eq (0 a) 0","decl":"theorem zero_apply {a : α} : (0 : SummableFamily Γ R α) a = 0 :=\n  rfl\n\n"}
{"name":"HahnSeries.SummableFamily.coeff_toFun","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nR : Type u_3\nα : Type u_5\ninst✝¹ : PartialOrder Γ\ninst✝ : AddCommMonoid R\ns : HahnSeries.SummableFamily Γ R α\ng : Γ\na : α\n⊢ Eq ((s.coeff g) a) ((s a).coeff g)","decl":"/-- The coefficient function of a summable family, as a finsupp on the parameter type. -/\n@[simps]\ndef coeff (s : SummableFamily Γ R α) (g : Γ) : α →₀ R where\n  support := (s.finite_co_support g).toFinset\n  toFun a := (s a).coeff g\n  mem_support_toFun a := by simp\n\n"}
{"name":"HahnSeries.SummableFamily.coeff_support","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nR : Type u_3\nα : Type u_5\ninst✝¹ : PartialOrder Γ\ninst✝ : AddCommMonoid R\ns : HahnSeries.SummableFamily Γ R α\ng : Γ\n⊢ Eq (s.coeff g).support ⋯.toFinset","decl":"/-- The coefficient function of a summable family, as a finsupp on the parameter type. -/\n@[simps]\ndef coeff (s : SummableFamily Γ R α) (g : Γ) : α →₀ R where\n  support := (s.finite_co_support g).toFinset\n  toFun a := (s a).coeff g\n  mem_support_toFun a := by simp\n\n"}
{"name":"HahnSeries.SummableFamily.coeff_def","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nR : Type u_3\nα : Type u_5\ninst✝¹ : PartialOrder Γ\ninst✝ : AddCommMonoid R\ns : HahnSeries.SummableFamily Γ R α\na : α\ng : Γ\n⊢ Eq ((s.coeff g) a) ((s a).coeff g)","decl":"@[simp]\ntheorem coeff_def (s : SummableFamily Γ R α) (a : α) (g : Γ) : s.coeff g a = (s a).coeff g :=\n  rfl\n\n"}
{"name":"HahnSeries.SummableFamily.coeff_hsum","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nR : Type u_3\nα : Type u_5\ninst✝¹ : PartialOrder Γ\ninst✝ : AddCommMonoid R\ns : HahnSeries.SummableFamily Γ R α\ng : Γ\n⊢ Eq (s.hsum.coeff g) (finsum fun i => (s i).coeff g)","decl":"@[simp]\ntheorem coeff_hsum {s : SummableFamily Γ R α} {g : Γ} : s.hsum.coeff g = ∑ᶠ i, (s i).coeff g :=\n  rfl\n\n"}
{"name":"HahnSeries.SummableFamily.hsum_coeff","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nR : Type u_3\nα : Type u_5\ninst✝¹ : PartialOrder Γ\ninst✝ : AddCommMonoid R\ns : HahnSeries.SummableFamily Γ R α\ng : Γ\n⊢ Eq (s.hsum.coeff g) (finsum fun i => (s i).coeff g)","decl":"@[deprecated (since := \"2025-01-31\")] alias hsum_coeff := coeff_hsum\n\n"}
{"name":"HahnSeries.SummableFamily.support_hsum_subset","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nR : Type u_3\nα : Type u_5\ninst✝¹ : PartialOrder Γ\ninst✝ : AddCommMonoid R\ns : HahnSeries.SummableFamily Γ R α\n⊢ HasSubset.Subset s.hsum.support (Set.iUnion fun a => (s a).support)","decl":"theorem support_hsum_subset {s : SummableFamily Γ R α} : s.hsum.support ⊆ ⋃ a : α, (s a).support :=\n  fun g hg => by\n  rw [mem_support, coeff_hsum, finsum_eq_sum _ (s.finite_co_support _)] at hg\n  obtain ⟨a, _, h2⟩ := exists_ne_zero_of_sum_ne_zero hg\n  rw [Set.mem_iUnion]\n  exact ⟨a, h2⟩\n\n"}
{"name":"HahnSeries.SummableFamily.hsum_add","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nR : Type u_3\nα : Type u_5\ninst✝¹ : PartialOrder Γ\ninst✝ : AddCommMonoid R\ns t : HahnSeries.SummableFamily Γ R α\n⊢ Eq (HAdd.hAdd s t).hsum (HAdd.hAdd s.hsum t.hsum)","decl":"@[simp]\ntheorem hsum_add {s t : SummableFamily Γ R α} : (s + t).hsum = s.hsum + t.hsum := by\n  ext g\n  simp only [coeff_hsum, coeff_add, add_apply]\n  exact finsum_add_distrib (s.finite_co_support _) (t.finite_co_support _)\n\n"}
{"name":"HahnSeries.SummableFamily.coeff_hsum_eq_sum_of_subset","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nR : Type u_3\nα : Type u_5\ninst✝¹ : PartialOrder Γ\ninst✝ : AddCommMonoid R\ns : HahnSeries.SummableFamily Γ R α\ng : Γ\nt : Finset α\nh : HasSubset.Subset (setOf fun a => Ne ((s a).coeff g) 0) ↑t\n⊢ Eq (s.hsum.coeff g) (t.sum fun i => (s i).coeff g)","decl":"theorem coeff_hsum_eq_sum_of_subset {s : SummableFamily Γ R α} {g : Γ} {t : Finset α}\n    (h : { a | (s a).coeff g ≠ 0 } ⊆ t) : s.hsum.coeff g = ∑ i ∈ t, (s i).coeff g := by\n  simp only [coeff_hsum, finsum_eq_sum _ (s.finite_co_support _)]\n  exact sum_subset (Set.Finite.toFinset_subset.mpr h) (by simp)\n\n"}
{"name":"HahnSeries.SummableFamily.hsum_coeff_eq_sum_of_subset","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nR : Type u_3\nα : Type u_5\ninst✝¹ : PartialOrder Γ\ninst✝ : AddCommMonoid R\ns : HahnSeries.SummableFamily Γ R α\ng : Γ\nt : Finset α\nh : HasSubset.Subset (setOf fun a => Ne ((s a).coeff g) 0) ↑t\n⊢ Eq (s.hsum.coeff g) (t.sum fun i => (s i).coeff g)","decl":"@[deprecated (since := \"2025-01-31\")] alias hsum_coeff_eq_sum_of_subset :=\n  coeff_hsum_eq_sum_of_subset\n\n"}
{"name":"HahnSeries.SummableFamily.coeff_hsum_eq_sum","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nR : Type u_3\nα : Type u_5\ninst✝¹ : PartialOrder Γ\ninst✝ : AddCommMonoid R\ns : HahnSeries.SummableFamily Γ R α\ng : Γ\n⊢ Eq (s.hsum.coeff g) ((s.coeff g).support.sum fun i => (s i).coeff g)","decl":"theorem coeff_hsum_eq_sum {s : SummableFamily Γ R α} {g : Γ} :\n    s.hsum.coeff g = ∑ i ∈ (s.coeff g).support, (s i).coeff g := by\n  simp only [coeff_hsum, finsum_eq_sum _ (s.finite_co_support _), coeff_support]\n\n"}
{"name":"HahnSeries.SummableFamily.hsum_coeff_eq_sum","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nR : Type u_3\nα : Type u_5\ninst✝¹ : PartialOrder Γ\ninst✝ : AddCommMonoid R\ns : HahnSeries.SummableFamily Γ R α\ng : Γ\n⊢ Eq (s.hsum.coeff g) ((s.coeff g).support.sum fun i => (s i).coeff g)","decl":"@[deprecated (since := \"2025-01-31\")] alias hsum_coeff_eq_sum := coeff_hsum_eq_sum\n\n"}
{"name":"HahnSeries.SummableFamily.single_toFun","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : AddCommMonoid R\nx : HahnSeries Γ R\nx✝ : Unit\n⊢ Eq ((HahnSeries.SummableFamily.single x) x✝) x","decl":"/-- The summable family made of a single Hahn series. -/\n@[simps]\ndef single (x : HahnSeries Γ R) : SummableFamily Γ R Unit where\n  toFun _ := x\n  isPWO_iUnion_support' :=\n    Eq.mpr (congrArg (fun s ↦ s.IsPWO) (Set.iUnion_const x.support)) x.isPWO_support\n  finite_co_support' g := Set.toFinite {a | ((fun _ ↦ x) a).coeff g ≠ 0}\n\n"}
{"name":"HahnSeries.SummableFamily.hsum_single","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : AddCommMonoid R\nx : HahnSeries Γ R\n⊢ Eq (HahnSeries.SummableFamily.single x).hsum x","decl":"@[simp]\ntheorem hsum_single (x : HahnSeries Γ R) : (single x).hsum = x := by\n  ext g\n  simp only [coeff_hsum, single_toFun, finsum_unique]\n\n"}
{"name":"HahnSeries.SummableFamily.Equiv_toFun","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nR : Type u_3\nα : Type u_5\nβ : Type u_6\ninst✝¹ : PartialOrder Γ\ninst✝ : AddCommMonoid R\ne : Equiv α β\ns : HahnSeries.SummableFamily Γ R α\nb : β\n⊢ Eq ((HahnSeries.SummableFamily.Equiv e s) b) (s (e.symm b))","decl":"/-- A summable family induced by an equivalence of the parametrizing type. -/\n@[simps]\ndef Equiv (e : α ≃ β) (s : SummableFamily Γ R α) : SummableFamily Γ R β where\n  toFun b := s (e.symm b)\n  isPWO_iUnion_support' := by\n    refine Set.IsPWO.mono s.isPWO_iUnion_support fun g => ?_\n    simp only [Set.mem_iUnion, mem_support, ne_eq, forall_exists_index]\n    exact fun b hg => Exists.intro (e.symm b) hg\n  finite_co_support' g :=\n    (Equiv.set_finite_iff e.subtypeEquivOfSubtype').mp <| s.finite_co_support' g\n\n"}
{"name":"HahnSeries.SummableFamily.hsum_equiv","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nR : Type u_3\nα : Type u_5\nβ : Type u_6\ninst✝¹ : PartialOrder Γ\ninst✝ : AddCommMonoid R\ne : Equiv α β\ns : HahnSeries.SummableFamily Γ R α\n⊢ Eq (HahnSeries.SummableFamily.Equiv e s).hsum s.hsum","decl":"@[simp]\ntheorem hsum_equiv (e : α ≃ β) (s : SummableFamily Γ R α) : (Equiv e s).hsum = s.hsum := by\n  ext g\n  simp only [coeff_hsum, Equiv_toFun]\n  exact finsum_eq_of_bijective e.symm (Equiv.bijective e.symm) fun x => rfl\n\n"}
{"name":"HahnSeries.SummableFamily.smulFamily_toFun","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nR : Type u_3\nV : Type u_4\nα : Type u_5\ninst✝³ : PartialOrder Γ\ninst✝² : AddCommMonoid R\ninst✝¹ : AddCommMonoid V\ninst✝ : SMulWithZero R V\nf : α → R\ns : HahnSeries.SummableFamily Γ V α\na : α\n⊢ Eq ((HahnSeries.SummableFamily.smulFamily f s) a) (HSMul.hSMul (f a) (s a))","decl":"/-- The summable family given by multiplying every series in a summable family by a scalar. -/\n@[simps]\ndef smulFamily [AddCommMonoid V] [SMulWithZero R V] (f : α → R) (s : SummableFamily Γ V α) :\n    SummableFamily Γ V α where\n  toFun a := (f a) • s a\n  isPWO_iUnion_support' := by\n    refine Set.IsPWO.mono s.isPWO_iUnion_support fun g hg => ?_\n    simp_all only [Set.mem_iUnion, mem_support, coeff_smul, ne_eq]\n    obtain ⟨i, hi⟩ := hg\n    exact Exists.intro i <| right_ne_zero_of_smul hi\n  finite_co_support' g := by\n    refine Set.Finite.subset (s.finite_co_support g) fun i hi => ?_\n    simp_all only [coeff_smul, ne_eq, Set.mem_setOf_eq, Function.mem_support]\n    exact right_ne_zero_of_smul hi\n\n"}
{"name":"HahnSeries.SummableFamily.hsum_smulFamily","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nR : Type u_3\nV : Type u_4\nα : Type u_5\ninst✝³ : PartialOrder Γ\ninst✝² : AddCommMonoid R\ninst✝¹ : AddCommMonoid V\ninst✝ : SMulWithZero R V\nf : α → R\ns : HahnSeries.SummableFamily Γ V α\ng : Γ\n⊢ Eq ((HahnSeries.SummableFamily.smulFamily f s).hsum.coeff g) (finsum fun i => HSMul.hSMul (f i) ((s i).coeff g))","decl":"theorem hsum_smulFamily [AddCommMonoid V] [SMulWithZero R V] (f : α → R)\n    (s : SummableFamily Γ V α) (g : Γ) :\n    (smulFamily f s).hsum.coeff g = ∑ᶠ i, (f i) • ((s i).coeff g) :=\n  rfl\n\n"}
{"name":"HahnSeries.SummableFamily.coe_neg","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nR : Type u_3\nα : Type u_5\ninst✝¹ : PartialOrder Γ\ninst✝ : AddCommGroup R\ns : HahnSeries.SummableFamily Γ R α\n⊢ Eq (⇑(Neg.neg s)) (Neg.neg ⇑s)","decl":"@[simp]\ntheorem coe_neg : ⇑(-s) = -s :=\n  rfl\n\n"}
{"name":"HahnSeries.SummableFamily.neg_apply","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nR : Type u_3\nα : Type u_5\ninst✝¹ : PartialOrder Γ\ninst✝ : AddCommGroup R\ns : HahnSeries.SummableFamily Γ R α\na : α\n⊢ Eq ((Neg.neg s) a) (Neg.neg (s a))","decl":"theorem neg_apply : (-s) a = -s a :=\n  rfl\n\n"}
{"name":"HahnSeries.SummableFamily.coe_sub","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nR : Type u_3\nα : Type u_5\ninst✝¹ : PartialOrder Γ\ninst✝ : AddCommGroup R\ns t : HahnSeries.SummableFamily Γ R α\n⊢ Eq (⇑(HSub.hSub s t)) (HSub.hSub ⇑s ⇑t)","decl":"@[simp]\ntheorem coe_sub : ⇑(s - t) = s - t :=\n  rfl\n\n"}
{"name":"HahnSeries.SummableFamily.sub_apply","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nR : Type u_3\nα : Type u_5\ninst✝¹ : PartialOrder Γ\ninst✝ : AddCommGroup R\ns t : HahnSeries.SummableFamily Γ R α\na : α\n⊢ Eq ((HSub.hSub s t) a) (HSub.hSub (s a) (t a))","decl":"theorem sub_apply : (s - t) a = s a - t a :=\n  rfl\n\n"}
{"name":"HahnSeries.SummableFamily.smul_support_subset_prod","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nΓ' : Type u_2\nR : Type u_3\nV : Type u_4\nα : Type u_5\nβ : Type u_6\ninst✝⁴ : PartialOrder Γ\ninst✝³ : PartialOrder Γ'\ninst✝² : AddCommMonoid V\ninst✝¹ : AddCommMonoid R\ninst✝ : SMulWithZero R V\ns : HahnSeries.SummableFamily Γ R α\nt : HahnSeries.SummableFamily Γ' V β\ngh : Prod Γ Γ'\n⊢ HasSubset.Subset (Function.support fun i => HSMul.hSMul ((s i.1).coeff gh.1) ((t i.2).coeff gh.2)) ↑⋯.toFinset","decl":"theorem smul_support_subset_prod (s : SummableFamily Γ R α)\n    (t : SummableFamily Γ' V β) (gh : Γ × Γ') :\n    (Function.support fun (i : α × β) ↦ (s i.1).coeff gh.1 • (t i.2).coeff gh.2) ⊆\n    ((s.finite_co_support' gh.1).prod (t.finite_co_support' gh.2)).toFinset := by\n  intro _ hab\n  simp_all only [Function.mem_support, ne_eq, Set.Finite.coe_toFinset, Set.mem_prod,\n    Set.mem_setOf_eq]\n  exact ⟨left_ne_zero_of_smul hab, right_ne_zero_of_smul hab⟩\n\n"}
{"name":"HahnSeries.SummableFamily.smul_support_finite","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nΓ' : Type u_2\nR : Type u_3\nV : Type u_4\nα : Type u_5\nβ : Type u_6\ninst✝⁴ : PartialOrder Γ\ninst✝³ : PartialOrder Γ'\ninst✝² : AddCommMonoid V\ninst✝¹ : AddCommMonoid R\ninst✝ : SMulWithZero R V\ns : HahnSeries.SummableFamily Γ R α\nt : HahnSeries.SummableFamily Γ' V β\ngh : Prod Γ Γ'\n⊢ (Function.support fun i => HSMul.hSMul ((s i.1).coeff gh.1) ((t i.2).coeff gh.2)).Finite","decl":"theorem smul_support_finite (s : SummableFamily Γ R α)\n    (t : SummableFamily Γ' V β) (gh : Γ × Γ') :\n    (Function.support fun (i : α × β) ↦ (s i.1).coeff gh.1 • (t i.2).coeff gh.2).Finite :=\n  Set.Finite.subset (Set.toFinite ((s.finite_co_support' gh.1).prod\n    (t.finite_co_support' gh.2)).toFinset) (smul_support_subset_prod s t gh)\n\n"}
{"name":"HahnSeries.SummableFamily.isPWO_iUnion_support_prod_smul","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nΓ' : Type u_2\nR : Type u_3\nV : Type u_4\nα : Type u_5\nβ : Type u_6\ninst✝⁶ : PartialOrder Γ\ninst✝⁵ : PartialOrder Γ'\ninst✝⁴ : AddCommMonoid V\ninst✝³ : AddCommMonoid R\ninst✝² : SMulWithZero R V\ninst✝¹ : VAdd Γ Γ'\ninst✝ : IsOrderedCancelVAdd Γ Γ'\ns : α → HahnSeries Γ R\nt : β → HahnSeries Γ' V\nhs : (Set.iUnion fun a => (s a).support).IsPWO\nht : (Set.iUnion fun b => (t b).support).IsPWO\n⊢ (Set.iUnion fun a => ((fun a => (HahnModule.of R).symm (HSMul.hSMul (s a.1) ((HahnModule.of R) (t a.2)))) a).support).IsPWO","decl":"theorem isPWO_iUnion_support_prod_smul {s : α → HahnSeries Γ R} {t : β → HahnSeries Γ' V}\n    (hs : (⋃ a, (s a).support).IsPWO) (ht : (⋃ b, (t b).support).IsPWO) :\n    (⋃ (a : α × β), ((fun a ↦ (of R).symm\n      ((s a.1) • (of R) (t a.2))) a).support).IsPWO := by\n  apply (hs.vadd ht).mono\n  have hsupp : ∀ ab : α × β, support ((fun ab ↦ (of R).symm (s ab.1 • (of R) (t ab.2))) ab) ⊆\n      (s ab.1).support +ᵥ (t ab.2).support := by\n    intro ab\n    refine Set.Subset.trans (fun x hx => ?_) (support_vaddAntidiagonal_subset_vadd\n      (hs := (s ab.1).isPWO_support) (ht := (t ab.2).isPWO_support))\n    contrapose! hx\n    simp only [Set.mem_setOf_eq, not_nonempty_iff_eq_empty] at hx\n    rw [mem_support, not_not, HahnModule.coeff_smul, hx, sum_empty]\n  refine Set.Subset.trans (Set.iUnion_mono fun a => (hsupp a)) ?_\n  simp_all only [Set.iUnion_subset_iff, Prod.forall]\n  exact fun a b => Set.vadd_subset_vadd (Set.subset_iUnion_of_subset a fun x y ↦ y)\n    (Set.subset_iUnion_of_subset b fun x y ↦ y)\n\n"}
{"name":"HahnSeries.SummableFamily.finite_co_support_prod_smul","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nΓ' : Type u_2\nR : Type u_3\nV : Type u_4\nα : Type u_5\nβ : Type u_6\ninst✝⁶ : PartialOrder Γ\ninst✝⁵ : PartialOrder Γ'\ninst✝⁴ : AddCommMonoid V\ninst✝³ : AddCommMonoid R\ninst✝² : SMulWithZero R V\ninst✝¹ : VAdd Γ Γ'\ninst✝ : IsOrderedCancelVAdd Γ Γ'\ns : HahnSeries.SummableFamily Γ R α\nt : HahnSeries.SummableFamily Γ' V β\ng : Γ'\n⊢ Finite ↑(setOf fun x => HahnSeries.SummableFamily.finite_co_support_prod_smul.match_1 (fun x => Prop) x fun ab => Ne (((fun ab => (HahnModule.of R).symm (HSMul.hSMul (s ab.1) ((HahnModule.of R) (t ab.2)))) ab).coeff g) 0)","decl":"theorem finite_co_support_prod_smul (s : SummableFamily Γ R α)\n    (t : SummableFamily Γ' V β) (g : Γ') :\n    Finite {(ab : α × β) |\n      ((fun (ab : α × β) ↦ (of R).symm (s ab.1 • (of R) (t ab.2))) ab).coeff g ≠ 0} := by\n  apply ((VAddAntidiagonal s.isPWO_iUnion_support t.isPWO_iUnion_support g).finite_toSet.biUnion'\n    (fun gh _ => smul_support_finite s t gh)).subset _\n  exact fun ab hab => by\n    simp only [coeff_smul, ne_eq, Set.mem_setOf_eq] at hab\n    obtain ⟨ij, hij⟩ := Finset.exists_ne_zero_of_sum_ne_zero hab\n    simp only [mem_coe, mem_vaddAntidiagonal, Set.mem_iUnion, mem_support, ne_eq,\n      Function.mem_support, exists_prop, Prod.exists]\n    exact ⟨ij.1, ij.2, ⟨⟨ab.1, left_ne_zero_of_smul hij.2⟩, ⟨ab.2, right_ne_zero_of_smul hij.2⟩,\n      ((mem_vaddAntidiagonal _ _ _).mp hij.1).2.2⟩, hij.2⟩\n\n"}
{"name":"HahnSeries.SummableFamily.smul_toFun","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nΓ' : Type u_2\nR : Type u_3\nV : Type u_4\nα : Type u_5\nβ : Type u_6\ninst✝⁶ : PartialOrder Γ\ninst✝⁵ : PartialOrder Γ'\ninst✝⁴ : AddCommMonoid V\ninst✝³ : AddCommMonoid R\ninst✝² : SMulWithZero R V\ninst✝¹ : VAdd Γ Γ'\ninst✝ : IsOrderedCancelVAdd Γ Γ'\ns : HahnSeries.SummableFamily Γ R α\nt : HahnSeries.SummableFamily Γ' V β\nab : Prod α β\n⊢ Eq ((s.smul t) ab) ((HahnModule.of R).symm (HSMul.hSMul (s ab.1) ((HahnModule.of R) (t ab.2))))","decl":"/-- An elementwise scalar multiplication of one summable family on another. -/\n@[simps]\ndef smul (s : SummableFamily Γ R α) (t : SummableFamily Γ' V β) :\n    (SummableFamily Γ' V (α × β)) where\n  toFun ab := (of R).symm (s (ab.1) • ((of R) (t (ab.2))))\n  isPWO_iUnion_support' :=\n    isPWO_iUnion_support_prod_smul s.isPWO_iUnion_support t.isPWO_iUnion_support\n  finite_co_support' g := finite_co_support_prod_smul s t g\n\n"}
{"name":"HahnSeries.SummableFamily.sum_vAddAntidiagonal_eq","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nΓ' : Type u_2\nR : Type u_3\nV : Type u_4\nα : Type u_5\nβ : Type u_6\ninst✝⁶ : PartialOrder Γ\ninst✝⁵ : PartialOrder Γ'\ninst✝⁴ : AddCommMonoid V\ninst✝³ : AddCommMonoid R\ninst✝² : SMulWithZero R V\ninst✝¹ : VAdd Γ Γ'\ninst✝ : IsOrderedCancelVAdd Γ Γ'\ns : HahnSeries.SummableFamily Γ R α\nt : HahnSeries.SummableFamily Γ' V β\ng : Γ'\na : Prod α β\n⊢ Eq ((Finset.VAddAntidiagonal ⋯ ⋯ g).sum fun x => HSMul.hSMul ((s a.1).coeff x.1) ((t a.2).coeff x.2)) ((Finset.VAddAntidiagonal ⋯ ⋯ g).sum fun x => HSMul.hSMul ((s a.1).coeff x.1) ((t a.2).coeff x.2))","decl":"theorem sum_vAddAntidiagonal_eq (s : SummableFamily Γ R α) (t : SummableFamily Γ' V β) (g : Γ')\n    (a : α × β) :\n    ∑ x ∈ VAddAntidiagonal (s a.1).isPWO_support' (t a.2).isPWO_support' g, (s a.1).coeff x.1 •\n      (t a.2).coeff x.2 = ∑ x ∈ VAddAntidiagonal s.isPWO_iUnion_support' t.isPWO_iUnion_support' g,\n      (s a.1).coeff x.1 • (t a.2).coeff x.2 := by\n  refine sum_subset (fun gh hgh => ?_) fun gh hgh h => ?_\n  · simp_all only [mem_vaddAntidiagonal, Function.mem_support, Set.mem_iUnion, mem_support]\n    exact ⟨Exists.intro a.1 hgh.1, Exists.intro a.2 hgh.2.1, trivial⟩\n  · by_cases hs : (s a.1).coeff gh.1 = 0\n    · exact smul_eq_zero_of_left hs ((t a.2).coeff gh.2)\n    · simp_all\n\n"}
{"name":"HahnSeries.SummableFamily.coeff_smul","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nΓ' : Type u_2\nα : Type u_5\nβ : Type u_6\ninst✝⁶ : PartialOrder Γ\ninst✝⁵ : PartialOrder Γ'\ninst✝⁴ : VAdd Γ Γ'\ninst✝³ : IsOrderedCancelVAdd Γ Γ'\nR : Type u_7\nV : Type u_8\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid V\ninst✝ : Module R V\ns : HahnSeries.SummableFamily Γ R α\nt : HahnSeries.SummableFamily Γ' V β\ng : Γ'\n⊢ Eq ((s.smul t).hsum.coeff g) ((Finset.VAddAntidiagonal ⋯ ⋯ g).sum fun gh => HSMul.hSMul (s.hsum.coeff gh.1) (t.hsum.coeff gh.2))","decl":"theorem coeff_smul {R} {V} [Semiring R] [AddCommMonoid V] [Module R V]\n    (s : SummableFamily Γ R α) (t : SummableFamily Γ' V β) (g : Γ') :\n    (smul s t).hsum.coeff g = ∑ gh ∈ VAddAntidiagonal s.isPWO_iUnion_support\n      t.isPWO_iUnion_support g, (s.hsum.coeff gh.1) • (t.hsum.coeff gh.2) := by\n  rw [coeff_hsum]\n  simp only [coeff_hsum_eq_sum, smul_toFun, HahnModule.coeff_smul, Equiv.symm_apply_apply]\n  simp_rw [sum_vAddAntidiagonal_eq, Finset.smul_sum, Finset.sum_smul]\n  rw [← sum_finsum_comm _ _ <| fun gh _ => smul_support_finite s t gh]\n  refine sum_congr rfl fun gh _ => ?_\n  rw [finsum_eq_sum _ (smul_support_finite s t gh), ← sum_product_right']\n  refine sum_subset (fun ab hab => ?_) (fun ab _ hab => by simp_all)\n  have hsupp := smul_support_subset_prod s t gh\n  simp_all only [mem_vaddAntidiagonal, Set.mem_iUnion, mem_support, ne_eq, Set.Finite.mem_toFinset,\n    Function.mem_support, Set.Finite.coe_toFinset, support_subset_iff, Set.mem_prod,\n    Set.mem_setOf_eq, Prod.forall, coeff_support, mem_product]\n  exact hsupp ab.1 ab.2 hab\n\n"}
{"name":"HahnSeries.SummableFamily.family_smul_coeff","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nΓ' : Type u_2\nα : Type u_5\nβ : Type u_6\ninst✝⁶ : PartialOrder Γ\ninst✝⁵ : PartialOrder Γ'\ninst✝⁴ : VAdd Γ Γ'\ninst✝³ : IsOrderedCancelVAdd Γ Γ'\nR : Type u_7\nV : Type u_8\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid V\ninst✝ : Module R V\ns : HahnSeries.SummableFamily Γ R α\nt : HahnSeries.SummableFamily Γ' V β\ng : Γ'\n⊢ Eq ((s.smul t).hsum.coeff g) ((Finset.VAddAntidiagonal ⋯ ⋯ g).sum fun gh => HSMul.hSMul (s.hsum.coeff gh.1) (t.hsum.coeff gh.2))","decl":"@[deprecated (since := \"2024-11-17\")] alias family_smul_coeff := coeff_smul\n\n"}
{"name":"HahnSeries.SummableFamily.smul_hsum","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nΓ' : Type u_2\nα : Type u_5\nβ : Type u_6\ninst✝⁶ : PartialOrder Γ\ninst✝⁵ : PartialOrder Γ'\ninst✝⁴ : VAdd Γ Γ'\ninst✝³ : IsOrderedCancelVAdd Γ Γ'\nR : Type u_7\nV : Type u_8\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid V\ninst✝ : Module R V\ns : HahnSeries.SummableFamily Γ R α\nt : HahnSeries.SummableFamily Γ' V β\n⊢ Eq (s.smul t).hsum ((HahnModule.of R).symm (HSMul.hSMul s.hsum ((HahnModule.of R) t.hsum)))","decl":"theorem smul_hsum {R} {V} [Semiring R] [AddCommMonoid V] [Module R V]\n    (s : SummableFamily Γ R α) (t : SummableFamily Γ' V β) :\n    (smul s t).hsum = (of R).symm (s.hsum • (of R) (t.hsum)) := by\n  ext g\n  rw [coeff_smul s t g, HahnModule.coeff_smul, Equiv.symm_apply_apply]\n  refine Eq.symm (sum_of_injOn (fun a ↦ a) (fun _ _ _ _ h ↦ h) (fun _ hgh => ?_)\n    (fun gh _ hgh => ?_) fun _ _ => by simp)\n  · simp_all only [mem_coe, mem_vaddAntidiagonal, mem_support, ne_eq, Set.mem_iUnion, and_true]\n    constructor\n    · rw [coeff_hsum_eq_sum] at hgh\n      have h' := Finset.exists_ne_zero_of_sum_ne_zero hgh.1\n      simpa using h'\n    · by_contra hi\n      simp_all\n  · simp only [Set.image_id', mem_coe, mem_vaddAntidiagonal, mem_support, ne_eq, not_and] at hgh\n    by_cases h : s.hsum.coeff gh.1 = 0\n    · exact smul_eq_zero_of_left h (t.hsum.coeff gh.2)\n    · simp_all\n\n"}
{"name":"HahnSeries.SummableFamily.hsum_family_smul","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nΓ' : Type u_2\nα : Type u_5\nβ : Type u_6\ninst✝⁶ : PartialOrder Γ\ninst✝⁵ : PartialOrder Γ'\ninst✝⁴ : VAdd Γ Γ'\ninst✝³ : IsOrderedCancelVAdd Γ Γ'\nR : Type u_7\nV : Type u_8\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid V\ninst✝ : Module R V\ns : HahnSeries.SummableFamily Γ R α\nt : HahnSeries.SummableFamily Γ' V β\n⊢ Eq (s.smul t).hsum ((HahnModule.of R).symm (HSMul.hSMul s.hsum ((HahnModule.of R) t.hsum)))","decl":"@[deprecated (since := \"2024-11-17\")] alias hsum_family_smul := smul_hsum\n\n"}
{"name":"HahnSeries.SummableFamily.smul_eq","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nΓ' : Type u_2\nR : Type u_3\nV : Type u_4\nβ : Type u_6\ninst✝⁶ : PartialOrder Γ\ninst✝⁵ : PartialOrder Γ'\ninst✝⁴ : AddCommMonoid V\ninst✝³ : AddCommMonoid R\ninst✝² : SMulWithZero R V\ninst✝¹ : VAdd Γ Γ'\ninst✝ : IsOrderedCancelVAdd Γ Γ'\nx : HahnSeries Γ R\nt : HahnSeries.SummableFamily Γ' V β\n⊢ Eq (HSMul.hSMul x t) (HahnSeries.SummableFamily.Equiv (Equiv.punitProd β) ((HahnSeries.SummableFamily.single x).smul t))","decl":"theorem smul_eq {x : HahnSeries Γ R} {t : SummableFamily Γ' V β} :\n    x • t = Equiv (Equiv.punitProd β) (smul (single x) t) :=\n  rfl\n\n"}
{"name":"HahnSeries.SummableFamily.smul_apply","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nΓ' : Type u_2\nR : Type u_3\nV : Type u_4\nα : Type u_5\ninst✝⁶ : PartialOrder Γ\ninst✝⁵ : PartialOrder Γ'\ninst✝⁴ : AddCommMonoid V\ninst✝³ : AddCommMonoid R\ninst✝² : SMulWithZero R V\ninst✝¹ : VAdd Γ Γ'\ninst✝ : IsOrderedCancelVAdd Γ Γ'\nx : HahnSeries Γ R\ns : HahnSeries.SummableFamily Γ' V α\na : α\n⊢ Eq ((HSMul.hSMul x s) a) ((HahnModule.of R).symm (HSMul.hSMul x ((HahnModule.of R) (s a))))","decl":"@[simp]\ntheorem smul_apply {x : HahnSeries Γ R} {s : SummableFamily Γ' V α} {a : α} :\n    (x • s) a = (of R).symm (x • of R (s a)) :=\n  rfl\n\n"}
{"name":"HahnSeries.SummableFamily.hsum_smul_module","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nΓ' : Type u_2\nα : Type u_5\ninst✝⁶ : PartialOrder Γ\ninst✝⁵ : PartialOrder Γ'\ninst✝⁴ : VAdd Γ Γ'\ninst✝³ : IsOrderedCancelVAdd Γ Γ'\nR : Type u_7\nV : Type u_8\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid V\ninst✝ : Module R V\nx : HahnSeries Γ R\ns : HahnSeries.SummableFamily Γ' V α\n⊢ Eq (HSMul.hSMul x s).hsum ((HahnModule.of R).symm (HSMul.hSMul x ((HahnModule.of R) s.hsum)))","decl":"@[simp]\ntheorem hsum_smul_module {R} {V} [Semiring R] [AddCommMonoid V] [Module R V] {x : HahnSeries Γ R}\n    {s : SummableFamily Γ' V α} :\n    (x • s).hsum = (of R).symm (x • of R s.hsum) := by\n  rw [smul_eq, hsum_equiv, smul_hsum, hsum_single]\n\n"}
{"name":"HahnSeries.SummableFamily.hsum_smul","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nR : Type u_3\nα : Type u_5\ninst✝¹ : OrderedCancelAddCommMonoid Γ\ninst✝ : Semiring R\nx : HahnSeries Γ R\ns : HahnSeries.SummableFamily Γ R α\n⊢ Eq (HSMul.hSMul x s).hsum (HMul.hMul x s.hsum)","decl":"theorem hsum_smul {x : HahnSeries Γ R} {s : SummableFamily Γ R α} :\n    (x • s).hsum = x * s.hsum := by\n  rw [hsum_smul_module, of_symm_smul_of_eq_mul]\n\n"}
{"name":"HahnSeries.SummableFamily.lsum_apply","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nR : Type u_3\nα : Type u_5\ninst✝¹ : OrderedCancelAddCommMonoid Γ\ninst✝ : Semiring R\ns : HahnSeries.SummableFamily Γ R α\n⊢ Eq (HahnSeries.SummableFamily.lsum s) s.hsum","decl":"/-- The summation of a `summable_family` as a `LinearMap`. -/\n@[simps]\ndef lsum : SummableFamily Γ R α →ₗ[HahnSeries Γ R] HahnSeries Γ R where\n  toFun := hsum\n  map_add' _ _ := hsum_add\n  map_smul' _ _ := hsum_smul\n\n"}
{"name":"HahnSeries.SummableFamily.hsum_sub","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nα : Type u_5\ninst✝¹ : OrderedCancelAddCommMonoid Γ\nR : Type u_7\ninst✝ : Ring R\ns t : HahnSeries.SummableFamily Γ R α\n⊢ Eq (HSub.hSub s t).hsum (HSub.hSub s.hsum t.hsum)","decl":"@[simp]\ntheorem hsum_sub {R : Type*} [Ring R] {s t : SummableFamily Γ R α} :\n    (s - t).hsum = s.hsum - t.hsum := by\n  rw [← lsum_apply, LinearMap.map_sub, lsum_apply, lsum_apply]\n\n"}
{"name":"HahnSeries.SummableFamily.isPWO_iUnion_support_prod_mul","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nR : Type u_3\nα : Type u_5\nβ : Type u_6\ninst✝¹ : OrderedCancelAddCommMonoid Γ\ninst✝ : Semiring R\ns : α → HahnSeries Γ R\nt : β → HahnSeries Γ R\nhs : (Set.iUnion fun a => (s a).support).IsPWO\nht : (Set.iUnion fun b => (t b).support).IsPWO\n⊢ (Set.iUnion fun a => ((fun a => HMul.hMul (s a.1) (t a.2)) a).support).IsPWO","decl":"theorem isPWO_iUnion_support_prod_mul {s : α → HahnSeries Γ R} {t : β → HahnSeries Γ R}\n    (hs : (⋃ a, (s a).support).IsPWO) (ht : (⋃ b, (t b).support).IsPWO) :\n    (⋃ (a : α × β), ((fun a ↦ ((s a.1) * (t a.2))) a).support).IsPWO :=\n  isPWO_iUnion_support_prod_smul hs ht\n\n"}
{"name":"HahnSeries.SummableFamily.finite_co_support_prod_mul","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nR : Type u_3\nα : Type u_5\nβ : Type u_6\ninst✝¹ : OrderedCancelAddCommMonoid Γ\ninst✝ : Semiring R\ns : HahnSeries.SummableFamily Γ R α\nt : HahnSeries.SummableFamily Γ R β\ng : Γ\n⊢ Finite ↑(setOf fun x => HahnSeries.SummableFamily.finite_co_support_prod_smul.match_1 (fun x => Prop) x fun a => Ne (((fun a => HMul.hMul (s a.1) (t a.2)) a).coeff g) 0)","decl":"theorem finite_co_support_prod_mul (s : SummableFamily Γ R α)\n    (t : SummableFamily Γ R β) (g : Γ) :\n    Finite {(a : α × β) | ((fun (a : α × β) ↦ (s a.1 * t a.2)) a).coeff g ≠ 0} :=\n  finite_co_support_prod_smul s t g\n\n"}
{"name":"HahnSeries.SummableFamily.mul_toFun","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nR : Type u_3\nα : Type u_5\nβ : Type u_6\ninst✝¹ : OrderedCancelAddCommMonoid Γ\ninst✝ : Semiring R\ns : HahnSeries.SummableFamily Γ R α\nt : HahnSeries.SummableFamily Γ R β\na : Prod α β\n⊢ Eq ((s.mul t) a) (HMul.hMul (s a.1) (t a.2))","decl":"/-- A summable family given by pointwise multiplication of a pair of summable families. -/\n@[simps]\ndef mul (s : SummableFamily Γ R α) (t : SummableFamily Γ R β) :\n    (SummableFamily Γ R (α × β)) where\n  toFun a := s (a.1) * t (a.2)\n  isPWO_iUnion_support' :=\n    isPWO_iUnion_support_prod_mul s.isPWO_iUnion_support t.isPWO_iUnion_support\n  finite_co_support' g := finite_co_support_prod_mul s t g\n\n"}
{"name":"HahnSeries.SummableFamily.mul_eq_smul","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nR : Type u_3\nα : Type u_5\ninst✝¹ : OrderedCancelAddCommMonoid Γ\ninst✝ : Semiring R\nβ : Type u_7\ns : HahnSeries.SummableFamily Γ R α\nt : HahnSeries.SummableFamily Γ R β\n⊢ Eq (s.mul t) (s.smul t)","decl":"theorem mul_eq_smul {β : Type*} (s : SummableFamily Γ R α) (t : SummableFamily Γ R β) :\n    mul s t = smul s t :=\n  rfl\n\n"}
{"name":"HahnSeries.SummableFamily.coeff_hsum_mul","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nR : Type u_3\nα : Type u_5\ninst✝¹ : OrderedCancelAddCommMonoid Γ\ninst✝ : Semiring R\nβ : Type u_7\ns : HahnSeries.SummableFamily Γ R α\nt : HahnSeries.SummableFamily Γ R β\ng : Γ\n⊢ Eq ((s.mul t).hsum.coeff g) ((Finset.addAntidiagonal ⋯ ⋯ g).sum fun gh => HMul.hMul (s.hsum.coeff gh.1) (t.hsum.coeff gh.2))","decl":"theorem coeff_hsum_mul {β : Type*} (s : SummableFamily Γ R α) (t : SummableFamily Γ R β) (g : Γ) :\n    (mul s t).hsum.coeff g = ∑ gh ∈ addAntidiagonal s.isPWO_iUnion_support\n      t.isPWO_iUnion_support g, (s.hsum.coeff gh.1) * (t.hsum.coeff gh.2) := by\n  simp_rw [← smul_eq_mul, mul_eq_smul]\n  exact coeff_smul s t g\n\n"}
{"name":"HahnSeries.SummableFamily.mul_coeff","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nR : Type u_3\nα : Type u_5\ninst✝¹ : OrderedCancelAddCommMonoid Γ\ninst✝ : Semiring R\nβ : Type u_7\ns : HahnSeries.SummableFamily Γ R α\nt : HahnSeries.SummableFamily Γ R β\ng : Γ\n⊢ Eq ((s.mul t).hsum.coeff g) ((Finset.addAntidiagonal ⋯ ⋯ g).sum fun gh => HMul.hMul (s.hsum.coeff gh.1) (t.hsum.coeff gh.2))","decl":"@[deprecated (since := \"2025-01-31\")] alias mul_coeff := coeff_hsum_mul\n\n"}
{"name":"HahnSeries.SummableFamily.hsum_mul","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nR : Type u_3\nα : Type u_5\ninst✝¹ : OrderedCancelAddCommMonoid Γ\ninst✝ : Semiring R\nβ : Type u_7\ns : HahnSeries.SummableFamily Γ R α\nt : HahnSeries.SummableFamily Γ R β\n⊢ Eq (s.mul t).hsum (HMul.hMul s.hsum t.hsum)","decl":"theorem hsum_mul {β : Type*} (s : SummableFamily Γ R α) (t : SummableFamily Γ R β) :\n    (mul s t).hsum = s.hsum * t.hsum := by\n  rw [← smul_eq_mul, mul_eq_smul]\n  exact smul_hsum s t\n\n"}
{"name":"HahnSeries.SummableFamily.coe_ofFinsupp","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : AddCommMonoid R\nα : Type u_7\nf : Finsupp α (HahnSeries Γ R)\n⊢ Eq ⇑(HahnSeries.SummableFamily.ofFinsupp f) ⇑f","decl":"@[simp]\ntheorem coe_ofFinsupp {f : α →₀ HahnSeries Γ R} : ⇑(SummableFamily.ofFinsupp f) = f :=\n  rfl\n\n"}
{"name":"HahnSeries.SummableFamily.hsum_ofFinsupp","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : AddCommMonoid R\nα : Type u_7\nf : Finsupp α (HahnSeries Γ R)\n⊢ Eq (HahnSeries.SummableFamily.ofFinsupp f).hsum (f.sum fun x => id)","decl":"@[simp]\ntheorem hsum_ofFinsupp {f : α →₀ HahnSeries Γ R} : (ofFinsupp f).hsum = f.sum fun _ => id := by\n  ext g\n  simp only [coeff_hsum, coe_ofFinsupp, Finsupp.sum, Ne]\n  simp_rw [← coeff.addMonoidHom_apply, id]\n  rw [map_sum, finsum_eq_sum_of_support_subset]\n  intro x h\n  simp only [coeff.addMonoidHom_apply, mem_coe, Finsupp.mem_support_iff, Ne]\n  contrapose! h\n  simp [h]\n\n"}
{"name":"HahnSeries.SummableFamily.embDomain_apply","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : AddCommMonoid R\nα : Type u_7\nβ : Type u_8\ns : HahnSeries.SummableFamily Γ R α\nf : Function.Embedding α β\nb : β\n⊢ Eq ((s.embDomain f) b) (dite (Membership.mem (Set.range ⇑f) b) (fun h => s (Classical.choose h)) fun h => 0)","decl":"open Classical in\ntheorem embDomain_apply :\n    s.embDomain f b = if h : b ∈ Set.range f then s (Classical.choose h) else 0 :=\n  rfl\n\n"}
{"name":"HahnSeries.SummableFamily.embDomain_image","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : AddCommMonoid R\nα : Type u_7\nβ : Type u_8\ns : HahnSeries.SummableFamily Γ R α\nf : Function.Embedding α β\na : α\n⊢ Eq ((s.embDomain f) (f a)) (s a)","decl":"@[simp]\ntheorem embDomain_image : s.embDomain f (f a) = s a := by\n  rw [embDomain_apply, dif_pos (Set.mem_range_self a)]\n  exact congr rfl (f.injective (Classical.choose_spec (Set.mem_range_self a)))\n\n"}
{"name":"HahnSeries.SummableFamily.embDomain_notin_range","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : AddCommMonoid R\nα : Type u_7\nβ : Type u_8\ns : HahnSeries.SummableFamily Γ R α\nf : Function.Embedding α β\nb : β\nh : Not (Membership.mem (Set.range ⇑f) b)\n⊢ Eq ((s.embDomain f) b) 0","decl":"@[simp]\ntheorem embDomain_notin_range (h : b ∉ Set.range f) : s.embDomain f b = 0 := by\n  rw [embDomain_apply, dif_neg h]\n\n"}
{"name":"HahnSeries.SummableFamily.hsum_embDomain","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : AddCommMonoid R\nα : Type u_7\nβ : Type u_8\ns : HahnSeries.SummableFamily Γ R α\nf : Function.Embedding α β\n⊢ Eq (s.embDomain f).hsum s.hsum","decl":"@[simp]\ntheorem hsum_embDomain : (s.embDomain f).hsum = s.hsum := by\n  classical\n  ext g\n  simp only [coeff_hsum, embDomain_apply, apply_dite HahnSeries.coeff, dite_apply, coeff_zero]\n  exact finsum_emb_domain f fun a => (s a).coeff g\n\n"}
{"name":"HahnSeries.SummableFamily.support_pow_subset_closure","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : OrderedCancelAddCommMonoid Γ\ninst✝ : Semiring R\nx : HahnSeries Γ R\nn : Nat\n⊢ HasSubset.Subset (HPow.hPow x n).support ↑(AddSubmonoid.closure x.support)","decl":"theorem support_pow_subset_closure [OrderedCancelAddCommMonoid Γ] [Semiring R] (x : HahnSeries Γ R)\n    (n : ℕ) : support (x ^ n) ⊆ AddSubmonoid.closure (support x) := by\n  induction' n with n ih <;> intro g hn\n  · simp only [pow_zero, mem_support, coeff_one, ne_eq, ite_eq_right_iff, Classical.not_imp] at hn\n    simp only [hn, SetLike.mem_coe]\n    exact AddSubmonoid.zero_mem _\n  · obtain ⟨i, hi, j, hj, rfl⟩ := support_mul_subset_add_support hn\n    exact SetLike.mem_coe.2 (AddSubmonoid.add_mem _ (ih hi) (AddSubmonoid.subset_closure hj))\n\n"}
{"name":"HahnSeries.SummableFamily.isPWO_iUnion_support_powers","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : LinearOrderedCancelAddCommMonoid Γ\ninst✝ : Semiring R\nx : HahnSeries Γ R\nhx : LE.le 0 x.order\n⊢ (Set.iUnion fun n => (HPow.hPow x n).support).IsPWO","decl":"theorem isPWO_iUnion_support_powers [LinearOrderedCancelAddCommMonoid Γ] [Semiring R]\n    {x : HahnSeries Γ R} (hx : 0 ≤ x.order) :\n    (⋃ n : ℕ, (x ^ n).support).IsPWO :=\n  (x.isPWO_support'.addSubmonoid_closure\n    fun _ hg => le_trans hx (order_le_of_coeff_ne_zero (Function.mem_support.mp hg))).mono\n    (Set.iUnion_subset fun n => support_pow_subset_closure x n)\n\n"}
{"name":"HahnSeries.SummableFamily.co_support_zero","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : OrderedCancelAddCommMonoid Γ\ninst✝ : Semiring R\ng : Γ\n⊢ HasSubset.Subset (setOf fun a => Not (Eq ((HPow.hPow 0 a).coeff g) 0)) (Singleton.singleton 0)","decl":"theorem co_support_zero [OrderedCancelAddCommMonoid Γ] [Semiring R] (g : Γ) :\n    {a | ¬((0 : HahnSeries Γ R) ^ a).coeff g = 0} ⊆ {0} := by\n  simp only [Set.subset_singleton_iff, Set.mem_setOf_eq]\n  intro n hn\n  by_contra h'\n  simp_all only [ne_eq, not_false_eq_true, zero_pow, coeff_zero, not_true_eq_false]\n\n"}
{"name":"HahnSeries.SummableFamily.pow_finite_co_support","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : LinearOrderedCancelAddCommMonoid Γ\ninst✝ : CommRing R\nx : HahnSeries Γ R\nhx : LT.lt 0 x.orderTop\ng : Γ\n⊢ (setOf fun a => Ne (((fun n => HPow.hPow x n) a).coeff g) 0).Finite","decl":"theorem pow_finite_co_support {x : HahnSeries Γ R} (hx : 0 < x.orderTop) (g : Γ) :\n    Set.Finite {a | ((fun n ↦ x ^ n) a).coeff g ≠ 0} := by\n  have hpwo : Set.IsPWO (⋃ n, support (x ^ n)) :=\n    isPWO_iUnion_support_powers (zero_le_orderTop_iff.mp <| le_of_lt hx)\n  by_cases h0 : x = 0; · exact h0 ▸ Set.Finite.subset (Set.finite_singleton 0) (co_support_zero g)\n  by_cases hg : g ∈ ⋃ n : ℕ, { g | (x ^ n).coeff g ≠ 0 }\n  swap; · exact Set.finite_empty.subset fun n hn => hg (Set.mem_iUnion.2 ⟨n, hn⟩)\n  apply hpwo.isWF.induction hg\n  intro y ys hy\n  refine ((((addAntidiagonal x.isPWO_support hpwo y).finite_toSet.biUnion\n    fun ij hij => hy ij.snd (mem_addAntidiagonal.1 (mem_coe.1 hij)).2.1 ?_).image Nat.succ).union\n      (Set.finite_singleton 0)).subset ?_\n  · obtain ⟨hi, _, rfl⟩ := mem_addAntidiagonal.1 (mem_coe.1 hij)\n    exact lt_add_of_pos_left ij.2 <| lt_of_lt_of_le ((zero_lt_orderTop_iff h0).mp hx) <|\n      order_le_of_coeff_ne_zero <| Function.mem_support.mp hi\n  · rintro (_ | n) hn\n    · exact Set.mem_union_right _ (Set.mem_singleton 0)\n    · obtain ⟨i, hi, j, hj, rfl⟩ := support_mul_subset_add_support hn\n      refine Set.mem_union_left _ ⟨n, Set.mem_iUnion.2 ⟨⟨j, i⟩, Set.mem_iUnion.2 ⟨?_, hi⟩⟩, rfl⟩\n      simp only [mem_coe, mem_addAntidiagonal, mem_support, ne_eq, Set.mem_iUnion]\n      exact ⟨hj, ⟨n, hi⟩, add_comm j i⟩\n\n"}
{"name":"HahnSeries.SummableFamily.powers_toFun","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : LinearOrderedCancelAddCommMonoid Γ\ninst✝ : CommRing R\nx : HahnSeries Γ R\nhx : LT.lt 0 x.orderTop\nn : Nat\n⊢ Eq ((HahnSeries.SummableFamily.powers x hx) n) (HPow.hPow x n)","decl":"/-- The powers of an element of positive valuation form a summable family. -/\n@[simps]\ndef powers (x : HahnSeries Γ R) (hx : 0 < x.orderTop) : SummableFamily Γ R ℕ where\n  toFun n := x ^ n\n  isPWO_iUnion_support' := isPWO_iUnion_support_powers (zero_le_orderTop_iff.mp <| le_of_lt hx)\n  finite_co_support' g := pow_finite_co_support hx g\n\n"}
{"name":"HahnSeries.SummableFamily.coe_powers","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : LinearOrderedCancelAddCommMonoid Γ\ninst✝ : CommRing R\nx : HahnSeries Γ R\nhx : LT.lt 0 x.orderTop\n⊢ Eq (⇑(HahnSeries.SummableFamily.powers x hx)) (HPow.hPow x)","decl":"@[simp]\ntheorem coe_powers : ⇑(powers x hx) = HPow.hPow x :=\n  rfl\n\n"}
{"name":"HahnSeries.SummableFamily.embDomain_succ_smul_powers","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : LinearOrderedCancelAddCommMonoid Γ\ninst✝ : CommRing R\nx : HahnSeries Γ R\nhx : LT.lt 0 x.orderTop\n⊢ Eq ((HSMul.hSMul x (HahnSeries.SummableFamily.powers x hx)).embDomain { toFun := Nat.succ, inj' := Nat.succ_injective }) (HSub.hSub (HahnSeries.SummableFamily.powers x hx) (HahnSeries.SummableFamily.ofFinsupp (Finsupp.single 0 1)))","decl":"theorem embDomain_succ_smul_powers :\n    (x • powers x hx).embDomain ⟨Nat.succ, Nat.succ_injective⟩ =\n      powers x hx - ofFinsupp (Finsupp.single 0 1) := by\n  apply SummableFamily.ext\n  rintro (_ | n)\n  · rw [embDomain_notin_range, sub_apply, coe_powers, pow_zero, coe_ofFinsupp,\n      Finsupp.single_eq_same, sub_self]\n    rw [Set.mem_range, not_exists]\n    exact Nat.succ_ne_zero\n  · refine Eq.trans (embDomain_image _ ⟨Nat.succ, Nat.succ_injective⟩) ?_\n    rw [smul_apply, powers_toFun, coe_sub, coe_powers, Pi.sub_apply, coe_ofFinsupp, pow_succ',\n      Finsupp.single_eq_of_ne (Nat.zero_ne_add_one n), sub_zero, of_symm_smul_of_eq_mul]\n\n"}
{"name":"HahnSeries.SummableFamily.one_sub_self_mul_hsum_powers","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : LinearOrderedCancelAddCommMonoid Γ\ninst✝ : CommRing R\nx : HahnSeries Γ R\nhx : LT.lt 0 x.orderTop\n⊢ Eq (HMul.hMul (HSub.hSub 1 x) (HahnSeries.SummableFamily.powers x hx).hsum) 1","decl":"theorem one_sub_self_mul_hsum_powers : (1 - x) * (powers x hx).hsum = 1 := by\n  rw [← hsum_smul, sub_smul 1 x (powers x hx), one_smul, hsum_sub, ←\n    hsum_embDomain (x • powers x hx) ⟨Nat.succ, Nat.succ_injective⟩, embDomain_succ_smul_powers]\n  simp\n\n"}
{"name":"HahnSeries.unit_aux","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝² : LinearOrderedAddCommGroup Γ\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nx : HahnSeries Γ R\nr : R\nhr : Eq (HMul.hMul r x.leadingCoeff) 1\n⊢ LT.lt 0 (HSub.hSub 1 (HMul.hMul ((HahnSeries.single (Neg.neg x.order)) r) x)).orderTop","decl":"theorem unit_aux (x : HahnSeries Γ R) {r : R} (hr : r * x.leadingCoeff = 1) :\n    0 < (1 - single (-x.order) r * x).orderTop := by\n  by_cases hx : x = 0; · simp_all [hx]\n  have hrz : r ≠ 0 := by\n    intro h\n    rw [h, zero_mul] at hr\n    exact (zero_ne_one' R) hr\n  refine lt_of_le_of_ne (le_trans ?_ min_orderTop_le_orderTop_sub) fun h => ?_\n  · refine le_min (by rw [orderTop_one]) ?_\n    refine le_trans ?_ orderTop_add_orderTop_le_orderTop_mul\n    by_cases h : x = 0; · simp [h]\n    rw [← order_eq_orderTop_of_ne h, orderTop_single\n      (fun _ => by simp_all only [zero_mul, zero_ne_one]), ← @WithTop.coe_add,\n      WithTop.coe_nonneg, neg_add_cancel]\n  · apply coeff_orderTop_ne h.symm\n    simp only [C_apply, single_mul_single, zero_add, mul_one, coeff_sub', Pi.sub_apply, coeff_one,\n      ↓reduceIte]\n    have hrc := coeff_mul_order_add_order ((single (-x.order)) r) x\n    rw [order_single hrz, leadingCoeff_of_single, neg_add_cancel, hr] at hrc\n    rw [hrc, sub_self]\n\n"}
{"name":"HahnSeries.isUnit_iff","module":"Mathlib.RingTheory.HahnSeries.Summable","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝² : LinearOrderedAddCommGroup Γ\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nx : HahnSeries Γ R\n⊢ Iff (IsUnit x) (IsUnit x.leadingCoeff)","decl":"theorem isUnit_iff {x : HahnSeries Γ R} : IsUnit x ↔ IsUnit (x.leadingCoeff) := by\n  constructor\n  · rintro ⟨⟨u, i, ui, iu⟩, rfl⟩\n    refine\n      isUnit_of_mul_eq_one (u.leadingCoeff) (i.leadingCoeff)\n        ((coeff_mul_order_add_order u i).symm.trans ?_)\n    rw [ui, coeff_one, if_pos]\n    rw [← order_mul (left_ne_zero_of_mul_eq_one ui) (right_ne_zero_of_mul_eq_one ui), ui, order_one]\n  · rintro ⟨⟨u, i, ui, iu⟩, h⟩\n    rw [Units.val_mk] at h\n    rw [h] at iu\n    have h := SummableFamily.one_sub_self_mul_hsum_powers (unit_aux x iu)\n    rw [sub_sub_cancel] at h\n    exact isUnit_of_mul_isUnit_right (isUnit_of_mul_eq_one _ _ h)\n\n"}
