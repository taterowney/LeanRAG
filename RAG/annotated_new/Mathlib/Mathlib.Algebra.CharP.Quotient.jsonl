{"name":"CharP.quotient","module":"Mathlib.Algebra.CharP.Quotient","initialProofState":"R : Type u\ninst✝ : CommRing R\np : Nat\nhp1 : Fact (Nat.Prime p)\nhp2 : Membership.mem (nonunits R) ↑p\n⊢ CharP (HasQuotient.Quotient R (Ideal.span (Singleton.singleton ↑p))) p","decl":"theorem quotient (R : Type u) [CommRing R] (p : ℕ) [hp1 : Fact p.Prime] (hp2 : ↑p ∈ nonunits R) :\n    CharP (R ⧸ (Ideal.span ({(p : R)} : Set R) : Ideal R)) p :=\n  have hp0 : (p : R ⧸ (Ideal.span {(p : R)} : Ideal R)) = 0 :=\n    map_natCast (Ideal.Quotient.mk (Ideal.span {(p : R)} : Ideal R)) p ▸\n      Ideal.Quotient.eq_zero_iff_mem.2 (Ideal.subset_span <| Set.mem_singleton _)\n  ringChar.of_eq <|\n    Or.resolve_left ((Nat.dvd_prime hp1.1).1 <| ringChar.dvd hp0) fun h1 =>\n      hp2 <|\n        isUnit_iff_dvd_one.2 <|\n          Ideal.mem_span_singleton.1 <|\n            Ideal.Quotient.eq_zero_iff_mem.1 <|\n              @Subsingleton.elim _ (@CharOne.subsingleton _ _ (ringChar.of_eq h1)) _ _\n\n"}
{"name":"CharP.quotient'","module":"Mathlib.Algebra.CharP.Quotient","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\np : Nat\ninst✝ : CharP R p\nI : Ideal R\nh : ∀ (x : Nat), Membership.mem I ↑x → Eq (↑x) 0\n⊢ CharP (HasQuotient.Quotient R I) p","decl":"/-- If an ideal does not contain any coercions of natural numbers other than zero, then its quotient\ninherits the characteristic of the underlying ring. -/\ntheorem quotient' {R : Type*} [CommRing R] (p : ℕ) [CharP R p] (I : Ideal R)\n    (h : ∀ x : ℕ, (x : R) ∈ I → (x : R) = 0) : CharP (R ⧸ I) p :=\n  ⟨fun x => by\n    rw [← cast_eq_zero_iff R p x, ← map_natCast (Ideal.Quotient.mk I)]\n    refine Ideal.Quotient.eq.trans (?_ : ↑x - 0 ∈ I ↔ _)\n    rw [sub_zero]\n    exact ⟨h x, fun h' => h'.symm ▸ I.zero_mem⟩⟩\n\n"}
{"name":"CharP.quotient_iff","module":"Mathlib.Algebra.CharP.Quotient","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\nn : Nat\ninst✝ : CharP R n\nI : Ideal R\n⊢ Iff (CharP (HasQuotient.Quotient R I) n) (∀ (x : Nat), Membership.mem I ↑x → Eq (↑x) 0)","decl":"/-- `CharP.quotient'` as an `Iff`. -/\ntheorem quotient_iff {R : Type*} [CommRing R] (n : ℕ) [CharP R n] (I : Ideal R) :\n    CharP (R ⧸ I) n ↔ ∀ x : ℕ, ↑x ∈ I → (x : R) = 0 := by\n  refine ⟨fun _ x hx => ?_, CharP.quotient' n I⟩\n  rw [CharP.cast_eq_zero_iff R n, ← CharP.cast_eq_zero_iff (R ⧸ I) n _]\n  exact (Submodule.Quotient.mk_eq_zero I).mpr hx\n\n"}
{"name":"CharP.quotient_iff_le_ker_natCast","module":"Mathlib.Algebra.CharP.Quotient","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\nn : Nat\ninst✝ : CharP R n\nI : Ideal R\n⊢ Iff (CharP (HasQuotient.Quotient R I) n) (LE.le (Ideal.comap (Nat.castRingHom R) I) (RingHom.ker (Nat.castRingHom R)))","decl":"/-- `CharP.quotient_iff`, but stated in terms of inclusions of ideals. -/\ntheorem quotient_iff_le_ker_natCast {R : Type*} [CommRing R] (n : ℕ) [CharP R n] (I : Ideal R) :\n    CharP (R ⧸ I) n ↔ I.comap (Nat.castRingHom R) ≤ RingHom.ker (Nat.castRingHom R) := by\n  rw [CharP.quotient_iff, RingHom.ker_eq_comap_bot]; rfl\n\n"}
{"name":"Ideal.Quotient.index_eq_zero","module":"Mathlib.Algebra.CharP.Quotient","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nI : Ideal R\n⊢ Eq (↑(Submodule.toAddSubgroup I).index) 0","decl":"theorem Ideal.Quotient.index_eq_zero {R : Type*} [CommRing R] (I : Ideal R) :\n    (↑I.toAddSubgroup.index : R ⧸ I) = 0 := by\n  rw [AddSubgroup.index, Nat.card_eq]\n  split_ifs with hq; swap\n  · simp\n  letI : Fintype (R ⧸ I) := @Fintype.ofFinite _ hq\n  exact Nat.cast_card_eq_zero (R ⧸ I)\n"}
