{"name":"isArtinian_iff","module":"Mathlib.RingTheory.Artinian.Module","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Iff (IsArtinian R M) (WellFounded fun x1 x2 => LT.lt x1 x2)","decl":"theorem isArtinian_iff (R M) [Semiring R] [AddCommMonoid M] [Module R M] : IsArtinian R M ↔\n    WellFounded (· < · : Submodule R M → Submodule R M → Prop) :=\n  isWellFounded_iff _ _\n\n"}
{"name":"isArtinian_of_injective","module":"Mathlib.RingTheory.Artinian.Module","initialProofState":"R : Type u_1\nM : Type u_2\nP : Type u_3\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R P\nf : LinearMap (RingHom.id R) M P\nh : Function.Injective ⇑f\ninst✝ : IsArtinian R P\n⊢ IsArtinian R M","decl":"theorem isArtinian_of_injective (f : M →ₗ[R] P) (h : Function.Injective f) [IsArtinian R P] :\n    IsArtinian R M :=\n  ⟨Subrelation.wf\n    (fun {A B} hAB => show A.map f < B.map f from Submodule.map_strictMono_of_injective h hAB)\n    (InvImage.wf (Submodule.map f) IsWellFounded.wf)⟩\n\n"}
{"name":"isArtinian_submodule'","module":"Mathlib.RingTheory.Artinian.Module","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : IsArtinian R M\nN : Submodule R M\n⊢ IsArtinian R (Subtype fun x => Membership.mem N x)","decl":"instance isArtinian_submodule' [IsArtinian R M] (N : Submodule R M) : IsArtinian R N :=\n  isArtinian_of_injective N.subtype Subtype.val_injective\n\n"}
{"name":"isArtinian_of_le","module":"Mathlib.RingTheory.Artinian.Module","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ns t : Submodule R M\ninst✝ : IsArtinian R (Subtype fun x => Membership.mem t x)\nh : LE.le s t\n⊢ IsArtinian R (Subtype fun x => Membership.mem s x)","decl":"theorem isArtinian_of_le {s t : Submodule R M} [IsArtinian R t] (h : s ≤ t) : IsArtinian R s :=\n  isArtinian_of_injective (Submodule.inclusion h) (Submodule.inclusion_injective h)\n\n"}
{"name":"isArtinian_of_surjective","module":"Mathlib.RingTheory.Artinian.Module","initialProofState":"R : Type u_1\nM : Type u_2\nP : Type u_3\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R P\nf : LinearMap (RingHom.id R) M P\nhf : Function.Surjective ⇑f\ninst✝ : IsArtinian R M\n⊢ IsArtinian R P","decl":"theorem isArtinian_of_surjective (f : M →ₗ[R] P) (hf : Function.Surjective f) [IsArtinian R M] :\n    IsArtinian R P :=\n  ⟨Subrelation.wf\n    (fun {A B} hAB =>\n      show A.comap f < B.comap f from Submodule.comap_strictMono_of_surjective hf hAB)\n    (InvImage.wf (Submodule.comap f) IsWellFounded.wf)⟩\n\n"}
{"name":"isArtinian_range","module":"Mathlib.RingTheory.Artinian.Module","initialProofState":"R : Type u_1\nM : Type u_2\nP : Type u_3\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R P\nf : LinearMap (RingHom.id R) M P\ninst✝ : IsArtinian R M\n⊢ IsArtinian R (Subtype fun x => Membership.mem (LinearMap.range f) x)","decl":"instance isArtinian_range (f : M →ₗ[R] P) [IsArtinian R M] : IsArtinian R (LinearMap.range f) :=\n  isArtinian_of_surjective _ _ f.surjective_rangeRestrict\n\n"}
{"name":"isArtinian_of_linearEquiv","module":"Mathlib.RingTheory.Artinian.Module","initialProofState":"R : Type u_1\nM : Type u_2\nP : Type u_3\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R P\nf : LinearEquiv (RingHom.id R) M P\ninst✝ : IsArtinian R M\n⊢ IsArtinian R P","decl":"theorem isArtinian_of_linearEquiv (f : M ≃ₗ[R] P) [IsArtinian R M] : IsArtinian R P :=\n  isArtinian_of_surjective _ f.toLinearMap f.toEquiv.surjective\n\n"}
{"name":"LinearEquiv.isArtinian_iff","module":"Mathlib.RingTheory.Artinian.Module","initialProofState":"R : Type u_1\nM : Type u_2\nP : Type u_3\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid P\ninst✝¹ : Module R M\ninst✝ : Module R P\nf : LinearEquiv (RingHom.id R) M P\n⊢ Iff (IsArtinian R M) (IsArtinian R P)","decl":"theorem LinearEquiv.isArtinian_iff (f : M ≃ₗ[R] P) : IsArtinian R M ↔ IsArtinian R P :=\n  ⟨fun _ ↦ isArtinian_of_linearEquiv f, fun _ ↦ isArtinian_of_linearEquiv f.symm⟩\n\n"}
{"name":"isArtinian_of_finite","module":"Mathlib.RingTheory.Artinian.Module","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Finite M\n⊢ IsArtinian R M","decl":"instance (priority := 100) isArtinian_of_finite [Finite M] : IsArtinian R M :=\n  ⟨Finite.wellFounded_of_trans_of_irrefl _⟩\n\n-- Porting note: elab_as_elim can only be global and cannot be changed on an imported decl\n-- attribute [local elab_as_elim] Finite.induction_empty_option\n\n"}
{"name":"IsArtinian.finite_of_linearIndependent","module":"Mathlib.RingTheory.Artinian.Module","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Nontrivial R\nh : IsArtinian R M\ns : Set M\nhs : LinearIndependent R Subtype.val\n⊢ s.Finite","decl":"theorem IsArtinian.finite_of_linearIndependent [Nontrivial R] [h : IsArtinian R M] {s : Set M}\n    (hs : LinearIndependent R ((↑) : s → M)) : s.Finite := by\n  refine by_contradiction fun hf ↦ (RelEmbedding.wellFounded_iff_no_descending_seq.1 h.wf).elim' ?_\n  have f : ℕ ↪ s := Set.Infinite.natEmbedding s hf\n  have : ∀ n, (↑) ∘ f '' { m | n ≤ m } ⊆ s := by\n    rintro n x ⟨y, _, rfl⟩\n    exact (f y).2\n  have : ∀ a b : ℕ, a ≤ b ↔\n      span R (Subtype.val ∘ f '' { m | b ≤ m }) ≤ span R (Subtype.val ∘ f '' { m | a ≤ m }) := by\n    intro a b\n    rw [span_le_span_iff hs (this b) (this a),\n      Set.image_subset_image_iff (Subtype.coe_injective.comp f.injective), Set.subset_def]\n    simp only [Set.mem_setOf_eq]\n    exact ⟨fun hab x ↦ hab.trans, (· _ le_rfl)⟩\n  exact ⟨⟨fun n ↦ span R (Subtype.val ∘ f '' { m | n ≤ m }), fun x y ↦ by\n    rw [le_antisymm_iff, ← this y x, ← this x y]\n    exact fun ⟨h₁, h₂⟩ ↦ le_antisymm_iff.2 ⟨h₂, h₁⟩⟩, by\n    intro a b\n    conv_rhs => rw [GT.gt, lt_iff_le_not_le, this, this, ← lt_iff_le_not_le]\n    rfl⟩\n\n"}
{"name":"set_has_minimal_iff_artinian","module":"Mathlib.RingTheory.Artinian.Module","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Iff (∀ (a : Set (Submodule R M)), a.Nonempty → Exists fun M' => And (Membership.mem a M') (∀ (I : Submodule R M), Membership.mem a I → Not (LT.lt I M'))) (IsArtinian R M)","decl":"/-- A module is Artinian iff every nonempty set of submodules has a minimal submodule among them. -/\ntheorem set_has_minimal_iff_artinian :\n    (∀ a : Set <| Submodule R M, a.Nonempty → ∃ M' ∈ a, ∀ I ∈ a, ¬I < M') ↔ IsArtinian R M := by\n  rw [isArtinian_iff, WellFounded.wellFounded_iff_has_min]\n\n"}
{"name":"IsArtinian.set_has_minimal","module":"Mathlib.RingTheory.Artinian.Module","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : IsArtinian R M\na : Set (Submodule R M)\nha : a.Nonempty\n⊢ Exists fun M' => And (Membership.mem a M') (∀ (I : Submodule R M), Membership.mem a I → Not (LT.lt I M'))","decl":"theorem IsArtinian.set_has_minimal [IsArtinian R M] (a : Set <| Submodule R M) (ha : a.Nonempty) :\n    ∃ M' ∈ a, ∀ I ∈ a, ¬I < M' :=\n  set_has_minimal_iff_artinian.mpr ‹_› a ha\n\n"}
{"name":"monotone_stabilizes_iff_artinian","module":"Mathlib.RingTheory.Artinian.Module","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Iff (∀ (f : OrderHom Nat (OrderDual (Submodule R M))), Exists fun n => ∀ (m : Nat), LE.le n m → Eq (f n) (f m)) (IsArtinian R M)","decl":"/-- A module is Artinian iff every decreasing chain of submodules stabilizes. -/\ntheorem monotone_stabilizes_iff_artinian :\n    (∀ f : ℕ →o (Submodule R M)ᵒᵈ, ∃ n, ∀ m, n ≤ m → f n = f m) ↔ IsArtinian R M := by\n  rw [isArtinian_iff]\n  exact WellFounded.monotone_chain_condition.symm\n\n"}
{"name":"IsArtinian.monotone_stabilizes","module":"Mathlib.RingTheory.Artinian.Module","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : IsArtinian R M\nf : OrderHom Nat (OrderDual (Submodule R M))\n⊢ Exists fun n => ∀ (m : Nat), LE.le n m → Eq (f n) (f m)","decl":"theorem monotone_stabilizes (f : ℕ →o (Submodule R M)ᵒᵈ) : ∃ n, ∀ m, n ≤ m → f n = f m :=\n  monotone_stabilizes_iff_artinian.mpr ‹_› f\n\n"}
{"name":"IsArtinian.eventuallyConst_of_isArtinian","module":"Mathlib.RingTheory.Artinian.Module","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : IsArtinian R M\nf : OrderHom Nat (OrderDual (Submodule R M))\n⊢ Filter.EventuallyConst (⇑f) Filter.atTop","decl":"theorem eventuallyConst_of_isArtinian (f : ℕ →o (Submodule R M)ᵒᵈ) :\n    atTop.EventuallyConst f := by\n  simp_rw [eventuallyConst_atTop, eq_comm]\n  exact monotone_stabilizes f\n\n"}
{"name":"IsArtinian.induction","module":"Mathlib.RingTheory.Artinian.Module","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : IsArtinian R M\nP : Submodule R M → Prop\nhgt : ∀ (I : Submodule R M), (∀ (J : Submodule R M), LT.lt J I → P J) → P I\nI : Submodule R M\n⊢ P I","decl":"/-- If `∀ I > J, P I` implies `P J`, then `P` holds for all submodules. -/\ntheorem induction {P : Submodule R M → Prop} (hgt : ∀ I, (∀ J < I, P J) → P I) (I : Submodule R M) :\n    P I :=\n  WellFoundedLT.induction I hgt\n\n"}
{"name":"IsArtinian.surjective_of_injective_endomorphism","module":"Mathlib.RingTheory.Artinian.Module","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : IsArtinian R M\nf : LinearMap (RingHom.id R) M M\ns : Function.Injective ⇑f\n⊢ Function.Surjective ⇑f","decl":"/-- Any injective endomorphism of an Artinian module is surjective. -/\ntheorem surjective_of_injective_endomorphism (f : M →ₗ[R] M) (s : Injective f) : Surjective f := by\n  have h := ‹IsArtinian R M›; contrapose! h\n  rw [IsArtinian, WellFoundedLT, isWellFounded_iff]\n  refine (RelEmbedding.natGT (LinearMap.range <| f ^ ·) ?_).not_wellFounded_of_decreasing_seq\n  intro n\n  simp_rw [pow_succ, LinearMap.mul_eq_comp, LinearMap.range_comp, ← Submodule.map_top (f ^ n)]\n  refine Submodule.map_strictMono_of_injective (LinearMap.iterate_injective s n) (Ne.lt_top ?_)\n  rwa [Ne, LinearMap.range_eq_top]\n\n"}
{"name":"IsArtinian.bijective_of_injective_endomorphism","module":"Mathlib.RingTheory.Artinian.Module","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : IsArtinian R M\nf : LinearMap (RingHom.id R) M M\ns : Function.Injective ⇑f\n⊢ Function.Bijective ⇑f","decl":"/-- Any injective endomorphism of an Artinian module is bijective. -/\ntheorem bijective_of_injective_endomorphism (f : M →ₗ[R] M) (s : Injective f) : Bijective f :=\n  ⟨s, surjective_of_injective_endomorphism f s⟩\n\n"}
{"name":"IsArtinian.disjoint_partial_infs_eventually_top","module":"Mathlib.RingTheory.Artinian.Module","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : IsArtinian R M\nf : Nat → Submodule R M\nh : ∀ (n : Nat), Disjoint ((partialSups (Function.comp (⇑OrderDual.toDual) f)) n) (OrderDual.toDual (f (HAdd.hAdd n 1)))\n⊢ Exists fun n => ∀ (m : Nat), LE.le n m → Eq (f m) Top.top","decl":"/-- A sequence `f` of submodules of an artinian module,\nwith the supremum `f (n+1)` and the infimum of `f 0`, ..., `f n` being ⊤,\nis eventually ⊤. -/\ntheorem disjoint_partial_infs_eventually_top (f : ℕ → Submodule R M)\n    (h : ∀ n, Disjoint (partialSups (OrderDual.toDual ∘ f) n) (OrderDual.toDual (f (n + 1)))) :\n    ∃ n : ℕ, ∀ m, n ≤ m → f m = ⊤ := by\n  -- A little off-by-one cleanup first:\n  rsuffices ⟨n, w⟩ : ∃ n : ℕ, ∀ m, n ≤ m → OrderDual.toDual f (m + 1) = ⊤\n  · use n + 1\n    rintro (_ | m) p\n    · cases p\n    · apply w\n      exact Nat.succ_le_succ_iff.mp p\n  obtain ⟨n, w⟩ := monotone_stabilizes (partialSups (OrderDual.toDual ∘ f))\n  refine ⟨n, fun m p ↦ (h m).eq_bot_of_ge <| sup_eq_left.mp ?_⟩\n  simpa only [partialSups_add_one] using (w (m + 1) <| le_add_right p).symm.trans <| w m p\n\n"}
{"name":"LinearMap.eventually_iInf_range_pow_eq","module":"Mathlib.RingTheory.Artinian.Module","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : IsArtinian R M\nf : Module.End R M\n⊢ Filter.Eventually (fun n => Eq (iInf fun m => LinearMap.range (HPow.hPow f m)) (LinearMap.range (HPow.hPow f n))) Filter.atTop","decl":"lemma eventually_iInf_range_pow_eq (f : Module.End R M) :\n    ∀ᶠ n in atTop, ⨅ m, LinearMap.range (f ^ m) = LinearMap.range (f ^ n) := by\n  obtain ⟨n, hn : ∀ m, n ≤ m → LinearMap.range (f ^ n) = LinearMap.range (f ^ m)⟩ :=\n    IsArtinian.monotone_stabilizes f.iterateRange\n  refine eventually_atTop.mpr ⟨n, fun l hl ↦ le_antisymm (iInf_le _ _) (le_iInf fun m ↦ ?_)⟩\n  rcases le_or_lt l m with h | h\n  · rw [← hn _ (hl.trans h), hn _ hl]\n  · exact f.iterateRange.monotone h.le\n\n"}
{"name":"isArtinian_of_quotient_of_artinian","module":"Mathlib.RingTheory.Artinian.Module","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : Ring R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\nN : Submodule R M\ninst✝ : IsArtinian R M\n⊢ IsArtinian R (HasQuotient.Quotient M N)","decl":"instance isArtinian_of_quotient_of_artinian\n    (N : Submodule R M) [IsArtinian R M] : IsArtinian R (M ⧸ N) :=\n  isArtinian_of_surjective M (Submodule.mkQ N) (Submodule.Quotient.mk_surjective N)\n\n"}
{"name":"isArtinian_of_range_eq_ker","module":"Mathlib.RingTheory.Artinian.Module","initialProofState":"R : Type u_1\nM : Type u_2\nP : Type u_3\nN : Type u_4\ninst✝⁸ : Ring R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : AddCommGroup P\ninst✝⁵ : AddCommGroup N\ninst✝⁴ : Module R M\ninst✝³ : Module R P\ninst✝² : Module R N\ninst✝¹ : IsArtinian R M\ninst✝ : IsArtinian R P\nf : LinearMap (RingHom.id R) M N\ng : LinearMap (RingHom.id R) N P\nh : Eq (LinearMap.range f) (LinearMap.ker g)\n⊢ IsArtinian R N","decl":"theorem isArtinian_of_range_eq_ker [IsArtinian R M] [IsArtinian R P] (f : M →ₗ[R] N) (g : N →ₗ[R] P)\n    (h : LinearMap.range f = LinearMap.ker g) : IsArtinian R N :=\n  wellFounded_lt_exact_sequence (LinearMap.range f) (Submodule.map (f.ker.liftQ f le_rfl))\n    (Submodule.comap (f.ker.liftQ f le_rfl))\n    (Submodule.comap g.rangeRestrict) (Submodule.map g.rangeRestrict)\n    (Submodule.gciMapComap <| LinearMap.ker_eq_bot.mp <| Submodule.ker_liftQ_eq_bot _ _ _ le_rfl)\n    (Submodule.giMapComap g.surjective_rangeRestrict)\n    (by simp [Submodule.map_comap_eq, inf_comm, Submodule.range_liftQ])\n    (by simp [Submodule.comap_map_eq, h])\n\n"}
{"name":"isArtinian_iff_submodule_quotient","module":"Mathlib.RingTheory.Artinian.Module","initialProofState":"R : Type u_1\nP : Type u_3\ninst✝² : Ring R\ninst✝¹ : AddCommGroup P\ninst✝ : Module R P\nS : Submodule R P\n⊢ Iff (IsArtinian R P) (And (IsArtinian R (Subtype fun x => Membership.mem S x)) (IsArtinian R (HasQuotient.Quotient P S)))","decl":"theorem isArtinian_iff_submodule_quotient (S : Submodule R P) :\n    IsArtinian R P ↔ IsArtinian R S ∧ IsArtinian R (P ⧸ S) := by\n  refine ⟨fun h ↦ ⟨inferInstance, inferInstance⟩, fun ⟨_, _⟩ ↦ ?_⟩\n  apply isArtinian_of_range_eq_ker S.subtype S.mkQ\n  rw [Submodule.ker_mkQ, Submodule.range_subtype]\n\n"}
{"name":"isArtinian_prod","module":"Mathlib.RingTheory.Artinian.Module","initialProofState":"R : Type u_1\nM : Type u_2\nP : Type u_3\ninst✝⁶ : Ring R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup P\ninst✝³ : Module R M\ninst✝² : Module R P\ninst✝¹ : IsArtinian R M\ninst✝ : IsArtinian R P\n⊢ IsArtinian R (Prod M P)","decl":"instance isArtinian_prod [IsArtinian R M] [IsArtinian R P] : IsArtinian R (M × P) :=\n  isArtinian_of_range_eq_ker (LinearMap.inl R M P) (LinearMap.snd R M P) (LinearMap.range_inl R M P)\n\n"}
{"name":"isArtinian_sup","module":"Mathlib.RingTheory.Artinian.Module","initialProofState":"R : Type u_1\nP : Type u_3\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup P\ninst✝² : Module R P\nM₁ M₂ : Submodule R P\ninst✝¹ : IsArtinian R (Subtype fun x => Membership.mem M₁ x)\ninst✝ : IsArtinian R (Subtype fun x => Membership.mem M₂ x)\n⊢ IsArtinian R (Subtype fun x => Membership.mem (Max.max M₁ M₂) x)","decl":"instance isArtinian_sup (M₁ M₂ : Submodule R P) [IsArtinian R M₁] [IsArtinian R M₂] :\n    IsArtinian R ↥(M₁ ⊔ M₂) := by\n  have := isArtinian_range (M₁.subtype.coprod M₂.subtype)\n  rwa [LinearMap.range_coprod, Submodule.range_subtype, Submodule.range_subtype] at this\n\n"}
{"name":"isArtinian_pi","module":"Mathlib.RingTheory.Artinian.Module","initialProofState":"R : Type u_1\ninst✝³ : Ring R\nι : Type u_5\nM : ι → Type u_6\ninst✝² : (i : ι) → AddCommGroup (M i)\ninst✝¹ : (i : ι) → Module R (M i)\ninst✝ : ∀ (i : ι), IsArtinian R (M i)\n⊢ IsArtinian R ((i : ι) → M i)","decl":"instance isArtinian_pi :\n    ∀ {M : ι → Type*} [Π i, AddCommGroup (M i)]\n      [Π i, Module R (M i)] [∀ i, IsArtinian R (M i)], IsArtinian R (Π i, M i) := by\n  apply Finite.induction_empty_option _ _ _ ι\n  · exact fun e h ↦ isArtinian_of_linearEquiv (LinearEquiv.piCongrLeft R _ e)\n  · infer_instance\n  · exact fun ih ↦ isArtinian_of_linearEquiv (LinearEquiv.piOptionEquivProd R).symm\n\n"}
{"name":"isArtinian_pi'","module":"Mathlib.RingTheory.Artinian.Module","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : Ring R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\nι : Type u_5\ninst✝ : IsArtinian R M\n⊢ IsArtinian R (ι → M)","decl":"/-- A version of `isArtinian_pi` for non-dependent functions. We need this instance because\nsometimes Lean fails to apply the dependent version in non-dependent settings (e.g., it fails to\nprove that `ι → ℝ` is finite dimensional over `ℝ`). -/\ninstance isArtinian_pi' [IsArtinian R M] : IsArtinian R (ι → M) :=\n  isArtinian_pi\n\n--Porting note (https://github.com/leanprover-community/mathlib4/issues/10754): new instance\n"}
{"name":"isArtinian_finsupp","module":"Mathlib.RingTheory.Artinian.Module","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nι : Type u_5\ninst✝¹ : Finite ι\ninst✝ : IsArtinian R M\n⊢ IsArtinian R (Finsupp ι M)","decl":"instance isArtinian_finsupp [IsArtinian R M] : IsArtinian R (ι →₀ M) :=\n  isArtinian_of_linearEquiv (Finsupp.linearEquivFunOnFinite _ _ _).symm\n\n"}
{"name":"isArtinian_iSup","module":"Mathlib.RingTheory.Artinian.Module","initialProofState":"R : Type u_1\nP : Type u_3\ninst✝³ : Ring R\ninst✝² : AddCommGroup P\ninst✝¹ : Module R P\nι : Type u_5\nM : ι → Submodule R P\ninst✝ : ∀ (i : ι), IsArtinian R (Subtype fun x => Membership.mem (M i) x)\n⊢ IsArtinian R (Subtype fun x => Membership.mem (iSup fun i => M i) x)","decl":"instance isArtinian_iSup :\n    ∀ {M : ι → Submodule R P} [∀ i, IsArtinian R (M i)], IsArtinian R ↥(⨆ i, M i) := by\n  apply Finite.induction_empty_option _ _ _ ι\n  · intro _ _ e h _ _; rw [← e.iSup_comp]; apply h\n  · intros; rw [iSup_of_empty]; infer_instance\n  · intro _ _ ih _ _; rw [iSup_option]; infer_instance\n\n"}
{"name":"LinearMap.eventually_codisjoint_ker_pow_range_pow","module":"Mathlib.RingTheory.Artinian.Module","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : Ring R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : IsArtinian R M\nf : LinearMap (RingHom.id R) M M\n⊢ Filter.Eventually (fun n => Codisjoint (LinearMap.ker (HPow.hPow f n)) (LinearMap.range (HPow.hPow f n))) Filter.atTop","decl":"/-- For any endomorphism of an Artinian module, any sufficiently high iterate has codisjoint kernel\nand range. -/\ntheorem eventually_codisjoint_ker_pow_range_pow (f : M →ₗ[R] M) :\n    ∀ᶠ n in atTop, Codisjoint (LinearMap.ker (f ^ n)) (LinearMap.range (f ^ n)) := by\n  obtain ⟨n, hn : ∀ m, n ≤ m → LinearMap.range (f ^ n) = LinearMap.range (f ^ m)⟩ :=\n    IsArtinian.monotone_stabilizes f.iterateRange\n  refine eventually_atTop.mpr ⟨n, fun m hm ↦ codisjoint_iff.mpr ?_⟩\n  simp_rw [← hn _ hm, Submodule.eq_top_iff', Submodule.mem_sup]\n  intro x\n  rsuffices ⟨y, hy⟩ : ∃ y, (f ^ m) ((f ^ n) y) = (f ^ m) x\n  · exact ⟨x - (f ^ n) y, by simp [hy], (f ^ n) y, by simp⟩\n  -- Note: https://github.com/leanprover-community/mathlib4/pull/8386 had to change `mem_range` into `mem_range (f := _)`\n  simp_rw [f.pow_apply n, f.pow_apply m, ← iterate_add_apply, ← f.pow_apply (m + n),\n    ← f.pow_apply m, ← mem_range (f := _), ← hn _ (n.le_add_left m), hn _ hm]\n  exact LinearMap.mem_range_self (f ^ m) x\n\n"}
{"name":"LinearMap.eventually_isCompl_ker_pow_range_pow","module":"Mathlib.RingTheory.Artinian.Module","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : IsArtinian R M\ninst✝ : IsNoetherian R M\nf : LinearMap (RingHom.id R) M M\n⊢ Filter.Eventually (fun n => IsCompl (LinearMap.ker (HPow.hPow f n)) (LinearMap.range (HPow.hPow f n))) Filter.atTop","decl":"/-- This is the Fitting decomposition of the module `M` with respect to the endomorphism `f`.\n\nSee also `LinearMap.isCompl_iSup_ker_pow_iInf_range_pow` for an alternative spelling. -/\ntheorem eventually_isCompl_ker_pow_range_pow [IsNoetherian R M] (f : M →ₗ[R] M) :\n    ∀ᶠ n in atTop, IsCompl (LinearMap.ker (f ^ n)) (LinearMap.range (f ^ n)) := by\n  filter_upwards [f.eventually_disjoint_ker_pow_range_pow.and\n    f.eventually_codisjoint_ker_pow_range_pow] with n hn\n  simpa only [isCompl_iff]\n\n"}
{"name":"LinearMap.isCompl_iSup_ker_pow_iInf_range_pow","module":"Mathlib.RingTheory.Artinian.Module","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : IsArtinian R M\ninst✝ : IsNoetherian R M\nf : LinearMap (RingHom.id R) M M\n⊢ IsCompl (iSup fun n => LinearMap.ker (HPow.hPow f n)) (iInf fun n => LinearMap.range (HPow.hPow f n))","decl":"/-- This is the Fitting decomposition of the module `M` with respect to the endomorphism `f`.\n\nSee also `LinearMap.eventually_isCompl_ker_pow_range_pow` for an alternative spelling. -/\ntheorem isCompl_iSup_ker_pow_iInf_range_pow [IsNoetherian R M] (f : M →ₗ[R] M) :\n    IsCompl (⨆ n, LinearMap.ker (f ^ n)) (⨅ n, LinearMap.range (f ^ n)) := by\n  obtain ⟨k, hk⟩ := eventually_atTop.mp <| f.eventually_isCompl_ker_pow_range_pow.and <|\n    f.eventually_iInf_range_pow_eq.and f.eventually_iSup_ker_pow_eq\n  obtain ⟨h₁, h₂, h₃⟩ := hk k (le_refl k)\n  rwa [h₂, h₃]\n\n"}
{"name":"IsArtinian.range_smul_pow_stabilizes","module":"Mathlib.RingTheory.Artinian.Module","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : CommSemiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : IsArtinian R M\nr : R\n⊢ Exists fun n => ∀ (m : Nat), LE.le n m → Eq (LinearMap.range (HSMul.hSMul (HPow.hPow r n) LinearMap.id)) (LinearMap.range (HSMul.hSMul (HPow.hPow r m) LinearMap.id))","decl":"theorem range_smul_pow_stabilizes (r : R) :\n    ∃ n : ℕ, ∀ m, n ≤ m →\n      LinearMap.range (r ^ n • LinearMap.id : M →ₗ[R] M) =\n      LinearMap.range (r ^ m • LinearMap.id : M →ₗ[R] M) :=\n  monotone_stabilizes\n    ⟨fun n => LinearMap.range (r ^ n • LinearMap.id : M →ₗ[R] M), fun n m h x ⟨y, hy⟩ =>\n      ⟨r ^ (m - n) • y, by\n        dsimp at hy ⊢\n        rw [← smul_assoc, smul_eq_mul, ← pow_add, ← hy, add_tsub_cancel_of_le h]⟩⟩\n\n"}
{"name":"IsArtinian.exists_pow_succ_smul_dvd","module":"Mathlib.RingTheory.Artinian.Module","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : CommSemiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : IsArtinian R M\nr : R\nx : M\n⊢ Exists fun n => Exists fun y => Eq (HSMul.hSMul (HPow.hPow r n.succ) y) (HSMul.hSMul (HPow.hPow r n) x)","decl":"theorem exists_pow_succ_smul_dvd (r : R) (x : M) :\n    ∃ (n : ℕ) (y : M), r ^ n.succ • y = r ^ n • x := by\n  obtain ⟨n, hn⟩ := IsArtinian.range_smul_pow_stabilizes M r\n  simp_rw [SetLike.ext_iff] at hn\n  exact ⟨n, by simpa using hn n.succ n.le_succ (r ^ n • x)⟩\n\n"}
{"name":"isArtinian_of_submodule_of_artinian","module":"Mathlib.RingTheory.Artinian.Module","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nN : Submodule R M\nx✝ : IsArtinian R M\n⊢ IsArtinian R (Subtype fun x => Membership.mem N x)","decl":"theorem isArtinian_of_submodule_of_artinian (R M) [Semiring R] [AddCommMonoid M] [Module R M]\n    (N : Submodule R M) (_ : IsArtinian R M) : IsArtinian R N := inferInstance\n\n"}
{"name":"isArtinian_of_tower","module":"Mathlib.RingTheory.Artinian.Module","initialProofState":"R : Type u_1\nS : Type u_2\nM : Type u_3\ninst✝⁶ : Semiring R\ninst✝⁵ : Semiring S\ninst✝⁴ : AddCommMonoid M\ninst✝³ : SMul R S\ninst✝² : Module S M\ninst✝¹ : Module R M\ninst✝ : IsScalarTower R S M\nh : IsArtinian R M\n⊢ IsArtinian S M","decl":"/-- If `M / S / R` is a scalar tower, and `M / R` is Artinian, then `M / S` is also Artinian. -/\ntheorem isArtinian_of_tower (R) {S M} [Semiring R] [Semiring S] [AddCommMonoid M] [SMul R S]\n    [Module S M] [Module R M] [IsScalarTower R S M] (h : IsArtinian R M) : IsArtinian S M :=\n  ⟨(Submodule.restrictScalarsEmbedding R S M).wellFounded h.wf⟩\n\n-- See `Mathlib.RingTheory.Artinian.Ring`\n"}
{"name":"isArtinianRing_iff","module":"Mathlib.RingTheory.Artinian.Module","initialProofState":"R : Type u_1\ninst✝ : Semiring R\n⊢ Iff (IsArtinianRing R) (IsArtinian R R)","decl":"theorem isArtinianRing_iff {R} [Semiring R] : IsArtinianRing R ↔ IsArtinian R R := Iff.rfl\n\n"}
{"name":"DivisionSemiring.instIsArtinianRing","module":"Mathlib.RingTheory.Artinian.Module","initialProofState":"K : Type u_1\ninst✝ : DivisionSemiring K\n⊢ IsArtinianRing K","decl":"instance DivisionSemiring.instIsArtinianRing {K : Type*} [DivisionSemiring K] : IsArtinianRing K :=\n  ⟨Finite.wellFounded_of_trans_of_irrefl _⟩\n\n"}
{"name":"DivisionRing.instIsArtinianRing","module":"Mathlib.RingTheory.Artinian.Module","initialProofState":"K : Type u_1\ninst✝ : DivisionRing K\n⊢ IsArtinianRing K","decl":"instance DivisionRing.instIsArtinianRing {K : Type*} [DivisionRing K] : IsArtinianRing K :=\n  inferInstance\n\n"}
{"name":"Ring.isArtinian_of_zero_eq_one","module":"Mathlib.RingTheory.Artinian.Module","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nh01 : Eq 0 1\n⊢ IsArtinianRing R","decl":"theorem Ring.isArtinian_of_zero_eq_one {R} [Semiring R] (h01 : (0 : R) = 1) : IsArtinianRing R :=\n  have := subsingleton_of_zero_eq_one h01\n  inferInstance\n\n"}
{"name":"instIsArtinianRingQuotientIdeal","module":"Mathlib.RingTheory.Artinian.Module","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsArtinianRing R\nI : Ideal R\n⊢ IsArtinianRing (HasQuotient.Quotient R I)","decl":"instance (R) [CommRing R] [IsArtinianRing R] (I : Ideal R) : IsArtinianRing (R ⧸ I) :=\n  isArtinian_of_tower R inferInstance\n\n"}
{"name":"isArtinian_of_fg_of_artinian","module":"Mathlib.RingTheory.Artinian.Module","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : Ring R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\nN : Submodule R M\ninst✝ : IsArtinianRing R\nhN : N.FG\n⊢ IsArtinian R (Subtype fun x => Membership.mem N x)","decl":"theorem isArtinian_of_fg_of_artinian {R M} [Ring R] [AddCommGroup M] [Module R M]\n    (N : Submodule R M) [IsArtinianRing R] (hN : N.FG) : IsArtinian R N := by\n  let ⟨s, hs⟩ := hN\n  haveI := Classical.decEq M\n  haveI := Classical.decEq R\n  have : ∀ x ∈ s, x ∈ N := fun x hx => hs ▸ Submodule.subset_span hx\n  refine @isArtinian_of_surjective _ ((↑s : Set M) →₀ R) N _ _ _ _ _ ?_ ?_ isArtinian_finsupp\n  · exact Finsupp.linearCombination R (fun i => ⟨i, hs ▸ subset_span i.2⟩)\n  · rw [← LinearMap.range_eq_top, eq_top_iff,\n       ← map_le_map_iff_of_injective (show Injective (Submodule.subtype N)\n         from Subtype.val_injective), Submodule.map_top, range_subtype,\n         ← Submodule.map_top, ← Submodule.map_comp, Submodule.map_top]\n    subst N\n    refine span_le.2 (fun i hi => ?_)\n    use Finsupp.single ⟨i, hi⟩ 1\n    simp\n\n"}
{"name":"isArtinian_of_fg_of_artinian'","module":"Mathlib.RingTheory.Artinian.Module","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : IsArtinianRing R\ninst✝ : Module.Finite R M\n⊢ IsArtinian R M","decl":"instance isArtinian_of_fg_of_artinian' {R M} [Ring R] [AddCommGroup M] [Module R M]\n    [IsArtinianRing R] [Module.Finite R M] : IsArtinian R M :=\n  have : IsArtinian R (⊤ : Submodule R M) := isArtinian_of_fg_of_artinian _ Module.Finite.fg_top\n  isArtinian_of_linearEquiv (LinearEquiv.ofTop (⊤ : Submodule R M) rfl)\n\n"}
{"name":"IsArtinianRing.of_finite","module":"Mathlib.RingTheory.Artinian.Module","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : Ring S\ninst✝² : Algebra R S\ninst✝¹ : IsArtinianRing R\ninst✝ : Module.Finite R S\n⊢ IsArtinianRing S","decl":"theorem IsArtinianRing.of_finite (R S) [CommRing R] [Ring S] [Algebra R S]\n    [IsArtinianRing R] [Module.Finite R S] : IsArtinianRing S :=\n  isArtinian_of_tower R isArtinian_of_fg_of_artinian'\n\n"}
{"name":"isArtinian_span_of_finite","module":"Mathlib.RingTheory.Artinian.Module","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : Ring R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : IsArtinianRing R\nA : Set M\nhA : A.Finite\n⊢ IsArtinian R (Subtype fun x => Membership.mem (Submodule.span R A) x)","decl":"/-- In a module over an artinian ring, the submodule generated by finitely many vectors is\nartinian. -/\ntheorem isArtinian_span_of_finite (R) {M} [Ring R] [AddCommGroup M] [Module R M] [IsArtinianRing R]\n    {A : Set M} (hA : A.Finite) : IsArtinian R (Submodule.span R A) :=\n  isArtinian_of_fg_of_artinian _ (Submodule.fg_def.mpr ⟨A, hA, rfl⟩)\n\n"}
{"name":"Function.Surjective.isArtinianRing","module":"Mathlib.RingTheory.Artinian.Module","initialProofState":"R : Type u_1\ninst✝³ : Semiring R\nS : Type u_2\ninst✝² : Semiring S\nF : Type u_3\ninst✝¹ : FunLike F R S\ninst✝ : RingHomClass F R S\nf : F\nhf : Function.Surjective ⇑f\nH : IsArtinianRing R\n⊢ IsArtinianRing S","decl":"theorem Function.Surjective.isArtinianRing {R} [Semiring R] {S} [Semiring S] {F}\n    [FunLike F R S] [RingHomClass F R S]\n    {f : F} (hf : Function.Surjective f) [H : IsArtinianRing R] : IsArtinianRing S := by\n  rw [isArtinianRing_iff] at H ⊢\n  exact ⟨(Ideal.orderEmbeddingOfSurjective f hf).wellFounded H.wf⟩\n\n"}
{"name":"isArtinianRing_rangeS","module":"Mathlib.RingTheory.Artinian.Module","initialProofState":"R : Type u_1\ninst✝² : Semiring R\nS : Type u_2\ninst✝¹ : Semiring S\nf : RingHom R S\ninst✝ : IsArtinianRing R\n⊢ IsArtinianRing (Subtype fun x => Membership.mem f.rangeS x)","decl":"instance isArtinianRing_rangeS {R} [Semiring R] {S} [Semiring S] (f : R →+* S) [IsArtinianRing R] :\n    IsArtinianRing f.rangeS :=\n  f.rangeSRestrict_surjective.isArtinianRing\n\n"}
{"name":"isArtinianRing_range","module":"Mathlib.RingTheory.Artinian.Module","initialProofState":"R : Type u_1\ninst✝² : Ring R\nS : Type u_2\ninst✝¹ : Ring S\nf : RingHom R S\ninst✝ : IsArtinianRing R\n⊢ IsArtinianRing (Subtype fun x => Membership.mem f.range x)","decl":"instance isArtinianRing_range {R} [Ring R] {S} [Ring S] (f : R →+* S) [IsArtinianRing R] :\n    IsArtinianRing f.range :=\n  isArtinianRing_rangeS f\n\n"}
{"name":"RingEquiv.isArtinianRing","module":"Mathlib.RingTheory.Artinian.Module","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : Semiring R\ninst✝¹ : Semiring S\nf : RingEquiv R S\ninst✝ : IsArtinianRing R\n⊢ IsArtinianRing S","decl":"theorem RingEquiv.isArtinianRing {R S} [Semiring R] [Semiring S] (f : R ≃+* S)\n    [IsArtinianRing R] : IsArtinianRing S :=\n  f.surjective.isArtinianRing\n\n"}
{"name":"instIsArtinianRingProd","module":"Mathlib.RingTheory.Artinian.Module","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : IsArtinianRing R\ninst✝ : IsArtinianRing S\n⊢ IsArtinianRing (Prod R S)","decl":"instance {R S} [Semiring R] [Semiring S] [IsArtinianRing R] [IsArtinianRing S] :\n    IsArtinianRing (R × S) :=\n  Ideal.idealProdEquiv.toOrderEmbedding.wellFoundedLT\n\n"}
{"name":"instIsArtinianRingForallOfFinite","module":"Mathlib.RingTheory.Artinian.Module","initialProofState":"ι : Type u_2\ninst✝² : Finite ι\nR : ι → Type u_1\ninst✝¹ : (i : ι) → Semiring (R i)\ninst✝ : ∀ (i : ι), IsArtinianRing (R i)\n⊢ IsArtinianRing ((i : ι) → R i)","decl":"instance {ι} [Finite ι] : ∀ {R : ι → Type*} [Π i, Semiring (R i)] [∀ i, IsArtinianRing (R i)],\n    IsArtinianRing (Π i, R i) := by\n  apply Finite.induction_empty_option _ _ _ ι\n  · exact fun e h ↦ RingEquiv.isArtinianRing (.piCongrLeft _ e)\n  · infer_instance\n  · exact fun ih ↦ RingEquiv.isArtinianRing (.symm .piOptionEquivProd)\n\n"}
{"name":"IsArtinianRing.setOf_isMaximal_finite","module":"Mathlib.RingTheory.Artinian.Module","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : IsArtinianRing R\n⊢ (setOf fun I => I.IsMaximal).Finite","decl":"@[stacks 00J7]\nlemma setOf_isMaximal_finite : {I : Ideal R | I.IsMaximal}.Finite := by\n  set Spec := {I : Ideal R | I.IsMaximal}\n  obtain ⟨_, ⟨s, rfl⟩, H⟩ := IsArtinian.set_has_minimal\n    (range (Finset.inf · Subtype.val : Finset Spec → Ideal R)) ⟨⊤, ∅, by simp⟩\n  refine Set.finite_def.2 ⟨s, fun p ↦ ?_⟩\n  classical\n  obtain ⟨q, hq1, hq2⟩ := p.2.isPrime.inf_le'.mp <| inf_eq_right.mp <|\n    inf_le_right.eq_of_not_lt (H (p ⊓ s.inf Subtype.val) ⟨insert p s, by simp⟩)\n  rwa [← Subtype.ext <| q.2.eq_of_le p.2.ne_top hq2]\n\n"}
{"name":"IsArtinianRing.instFiniteMaximalSpectrum","module":"Mathlib.RingTheory.Artinian.Module","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : IsArtinianRing R\n⊢ Finite (MaximalSpectrum R)","decl":"instance : Finite (MaximalSpectrum R) :=\n  haveI : Finite {I : Ideal R // I.IsMaximal} := (setOf_isMaximal_finite R).to_subtype\n  .of_equiv _ (MaximalSpectrum.equivSubtype _).symm\n\n"}
{"name":"IsArtinianRing.isField_of_isDomain","module":"Mathlib.RingTheory.Artinian.Module","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsArtinianRing R\ninst✝ : IsDomain R\n⊢ IsField R","decl":"variable (R) in\nlemma isField_of_isDomain [IsDomain R] : IsField R := by\n  refine ⟨Nontrivial.exists_pair_ne, mul_comm, fun {x} hx ↦ ?_⟩\n  obtain ⟨n, y, hy⟩ := IsArtinian.exists_pow_succ_smul_dvd x (1 : R)\n  replace hy : x ^ n * (x * y - 1) = 0 := by\n    rw [mul_sub, sub_eq_zero]\n    convert hy using 1\n    simp [Nat.succ_eq_add_one, pow_add, mul_assoc]\n  rw [mul_eq_zero, sub_eq_zero] at hy\n  exact ⟨_, hy.resolve_left <| pow_ne_zero _ hx⟩\n\n/- Does not hold in a commutative semiring:\nconsider {0, 0.5, 1} with ⊔ as + and ⊓ as *, then both {0} and {0, 0.5} are prime ideals. -/\n"}
{"name":"IsArtinianRing.isMaximal_of_isPrime","module":"Mathlib.RingTheory.Artinian.Module","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsArtinianRing R\np : Ideal R\ninst✝ : p.IsPrime\n⊢ p.IsMaximal","decl":"instance isMaximal_of_isPrime (p : Ideal R) [p.IsPrime] : p.IsMaximal :=\n  Ideal.Quotient.maximal_of_isField _ (isField_of_isDomain _)\n\n"}
{"name":"IsArtinianRing.isPrime_iff_isMaximal","module":"Mathlib.RingTheory.Artinian.Module","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsArtinianRing R\np : Ideal R\n⊢ Iff p.IsPrime p.IsMaximal","decl":"lemma isPrime_iff_isMaximal (p : Ideal R) : p.IsPrime ↔ p.IsMaximal :=\n  ⟨fun _ ↦ isMaximal_of_isPrime p, fun h ↦ h.isPrime⟩\n\n"}
{"name":"IsArtinianRing.primeSpectrumEquivMaximalSpectrum_apply_asIdeal","module":"Mathlib.RingTheory.Artinian.Module","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsArtinianRing R\nI : PrimeSpectrum R\n⊢ Eq (IsArtinianRing.primeSpectrumEquivMaximalSpectrum I).asIdeal I.asIdeal","decl":"/-- The prime spectrum is in bijection with the maximal spectrum. -/\n@[simps]\ndef primeSpectrumEquivMaximalSpectrum : PrimeSpectrum R ≃ MaximalSpectrum R where\n  toFun I := ⟨I.asIdeal, isPrime_iff_isMaximal I.asIdeal |>.mp I.isPrime⟩\n  invFun I := ⟨I.asIdeal, isPrime_iff_isMaximal I.asIdeal |>.mpr I.isMaximal⟩\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"IsArtinianRing.primeSpectrumEquivMaximalSpectrum_symm_apply_asIdeal","module":"Mathlib.RingTheory.Artinian.Module","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsArtinianRing R\nI : MaximalSpectrum R\n⊢ Eq (IsArtinianRing.primeSpectrumEquivMaximalSpectrum.symm I).asIdeal I.asIdeal","decl":"/-- The prime spectrum is in bijection with the maximal spectrum. -/\n@[simps]\ndef primeSpectrumEquivMaximalSpectrum : PrimeSpectrum R ≃ MaximalSpectrum R where\n  toFun I := ⟨I.asIdeal, isPrime_iff_isMaximal I.asIdeal |>.mp I.isPrime⟩\n  invFun I := ⟨I.asIdeal, isPrime_iff_isMaximal I.asIdeal |>.mpr I.isMaximal⟩\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"IsArtinianRing.primeSpectrumEquivMaximalSpectrum_comp_asIdeal","module":"Mathlib.RingTheory.Artinian.Module","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsArtinianRing R\n⊢ Eq (Function.comp MaximalSpectrum.asIdeal ⇑IsArtinianRing.primeSpectrumEquivMaximalSpectrum) PrimeSpectrum.asIdeal","decl":"lemma primeSpectrumEquivMaximalSpectrum_comp_asIdeal :\n    MaximalSpectrum.asIdeal ∘ primeSpectrumEquivMaximalSpectrum =\n      PrimeSpectrum.asIdeal (R := R) := rfl\n\n"}
{"name":"IsArtinianRing.primeSpectrumEquivMaximalSpectrum_symm_comp_asIdeal","module":"Mathlib.RingTheory.Artinian.Module","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsArtinianRing R\n⊢ Eq (Function.comp PrimeSpectrum.asIdeal ⇑IsArtinianRing.primeSpectrumEquivMaximalSpectrum.symm) MaximalSpectrum.asIdeal","decl":"lemma primeSpectrumEquivMaximalSpectrum_symm_comp_asIdeal :\n    PrimeSpectrum.asIdeal ∘ primeSpectrumEquivMaximalSpectrum.symm =\n      MaximalSpectrum.asIdeal (R := R) := rfl\n\n"}
{"name":"IsArtinianRing.primeSpectrum_asIdeal_range_eq","module":"Mathlib.RingTheory.Artinian.Module","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsArtinianRing R\n⊢ Eq (Set.range PrimeSpectrum.asIdeal) (Set.range MaximalSpectrum.asIdeal)","decl":"lemma primeSpectrum_asIdeal_range_eq :\n    range PrimeSpectrum.asIdeal = (range <| MaximalSpectrum.asIdeal (R := R)) := by\n  simp only [PrimeSpectrum.range_asIdeal, MaximalSpectrum.range_asIdeal,\n    isPrime_iff_isMaximal]\n\n"}
{"name":"IsArtinianRing.setOf_isPrime_finite","module":"Mathlib.RingTheory.Artinian.Module","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsArtinianRing R\n⊢ (setOf fun I => I.IsPrime).Finite","decl":"lemma setOf_isPrime_finite : {I : Ideal R | I.IsPrime}.Finite := by\n  simpa only [isPrime_iff_isMaximal] using setOf_isMaximal_finite R\n\n"}
{"name":"IsArtinianRing.instFinitePrimeSpectrum","module":"Mathlib.RingTheory.Artinian.Module","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsArtinianRing R\n⊢ Finite (PrimeSpectrum R)","decl":"instance : Finite (PrimeSpectrum R) :=\n  haveI : Finite {I : Ideal R // I.IsPrime} := (setOf_isPrime_finite R).to_subtype\n  .of_equiv _ (PrimeSpectrum.equivSubtype _).symm\n\n"}
