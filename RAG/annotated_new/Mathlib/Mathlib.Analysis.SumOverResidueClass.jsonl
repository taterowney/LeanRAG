{"name":"Finset.sum_indicator_mod","module":"Mathlib.Analysis.SumOverResidueClass","initialProofState":"R : Type u_1\ninst✝¹ : AddCommMonoid R\nm : Nat\ninst✝ : NeZero m\nf : Nat → R\n⊢ Eq f (Finset.univ.sum fun a => (setOf fun n => Eq (↑n) a).indicator f)","decl":"lemma Finset.sum_indicator_mod {R : Type*} [AddCommMonoid R] (m : ℕ) [NeZero m] (f : ℕ → R) :\n    f = ∑ a : ZMod m, {n : ℕ | (n : ZMod m) = a}.indicator f := by\n  ext n\n  simp only [Finset.sum_apply, Set.indicator_apply, Set.mem_setOf_eq, Finset.sum_ite_eq,\n    Finset.mem_univ, ↓reduceIte]\n\n"}
{"name":"summable_indicator_mod_iff_summable","module":"Mathlib.Analysis.SumOverResidueClass","initialProofState":"R : Type u_1\ninst✝² : AddCommGroup R\ninst✝¹ : TopologicalSpace R\ninst✝ : TopologicalAddGroup R\nm : Nat\nhm : NeZero m\nk : Nat\nf : Nat → R\n⊢ Iff (Summable ((setOf fun n => Eq ↑n ↑k).indicator f)) (Summable fun n => f (HAdd.hAdd (HMul.hMul m n) k))","decl":"open Set in\n/-- A sequence `f` with values in an additive topological group `R` is summable on the\nresidue class of `k` mod `m` if and only if `f (m*n + k)` is summable. -/\nlemma summable_indicator_mod_iff_summable {R : Type*} [AddCommGroup R] [TopologicalSpace R]\n    [TopologicalAddGroup R] (m : ℕ) [hm : NeZero m] (k : ℕ) (f : ℕ → R) :\n    Summable ({n : ℕ | (n : ZMod m) = k}.indicator f) ↔ Summable fun n ↦ f (m * n + k) := by\n  trans Summable ({n : ℕ | (n : ZMod m) = k ∧ k ≤ n}.indicator f)\n  · rw [← (finite_lt_nat k).summable_compl_iff (f := {n : ℕ | (n : ZMod m) = k}.indicator f)]\n    simp only [summable_subtype_iff_indicator, indicator_indicator, inter_comm, setOf_and,\n      compl_setOf, not_lt]\n  · let g : ℕ → ℕ := fun n ↦ m * n + k\n    have hg : Function.Injective g := fun m n hmn ↦ by simpa [g, hm.ne] using hmn\n    have hg' : ∀ n ∉ range g, {n : ℕ | (n : ZMod m) = k ∧ k ≤ n}.indicator f n = 0 := by\n      intro n hn\n      contrapose! hn\n      exact (Nat.range_mul_add m k).symm ▸ mem_of_indicator_ne_zero hn\n    convert (Function.Injective.summable_iff hg hg').symm using 3\n    simp only [Function.comp_apply, mem_setOf_eq, Nat.cast_add, Nat.cast_mul, CharP.cast_eq_zero,\n      zero_mul, zero_add, le_add_iff_nonneg_left, zero_le, and_self, indicator_of_mem, g]\n\n"}
{"name":"not_summable_of_antitone_of_neg","module":"Mathlib.Analysis.SumOverResidueClass","initialProofState":"f : Nat → Real\nhf : Antitone f\nn : Nat\nhn : LT.lt (f n) 0\n⊢ Not (Summable f)","decl":"/-- If `f : ℕ → ℝ` is decreasing and has a negative term, then `f` is not summable. -/\nlemma not_summable_of_antitone_of_neg {f : ℕ → ℝ} (hf : Antitone f) {n : ℕ} (hn : f n < 0) :\n    ¬ Summable f := by\n  intro hs\n  have := hs.tendsto_atTop_zero\n  simp only [Metric.tendsto_atTop, dist_zero_right, Real.norm_eq_abs] at this\n  obtain ⟨N, hN⟩ := this (|f n|) (abs_pos_of_neg hn)\n  specialize hN (max n N) (n.le_max_right N)\n  contrapose! hN; clear hN\n  have H : f (max n N) ≤ f n := hf (n.le_max_left N)\n  rwa [abs_of_neg hn, abs_of_neg (H.trans_lt hn), neg_le_neg_iff]\n\n"}
{"name":"not_summable_indicator_mod_of_antitone_of_neg","module":"Mathlib.Analysis.SumOverResidueClass","initialProofState":"m : Nat\nhm : NeZero m\nf : Nat → Real\nhf : Antitone f\nn : Nat\nhn : LT.lt (f n) 0\nk : ZMod m\n⊢ Not (Summable ((setOf fun n => Eq (↑n) k).indicator f))","decl":"/-- If `f : ℕ → ℝ` is decreasing and has a negative term, then `f` restricted to a residue\nclass is not summable. -/\nlemma not_summable_indicator_mod_of_antitone_of_neg {m : ℕ} [hm : NeZero m] {f : ℕ → ℝ}\n    (hf : Antitone f) {n : ℕ} (hn : f n < 0) (k : ZMod m) :\n    ¬ Summable ({n : ℕ | (n : ZMod m) = k}.indicator f) := by\n  rw [← ZMod.natCast_zmod_val k, summable_indicator_mod_iff_summable]\n  exact not_summable_of_antitone_of_neg\n    (hf.comp_monotone <| (Covariant.monotone_of_const m).add_const k.val) <|\n    (hf <| (Nat.le_mul_of_pos_left n Fin.pos').trans <| Nat.le_add_right ..).trans_lt hn\n\n"}
{"name":"summable_indicator_mod_iff_summable_indicator_mod","module":"Mathlib.Analysis.SumOverResidueClass","initialProofState":"m : Nat\ninst✝ : NeZero m\nf : Nat → Real\nhf : Antitone f\nk l : ZMod m\nhs : Summable ((setOf fun n => Eq (↑n) k).indicator f)\n⊢ Summable ((setOf fun n => Eq (↑n) l).indicator f)","decl":"/-- If a decreasing sequence of real numbers is summable on one residue class\nmodulo `m`, then it is also summable on every other residue class mod `m`. -/\nlemma summable_indicator_mod_iff_summable_indicator_mod {m : ℕ} [NeZero m] {f : ℕ → ℝ}\n    (hf : Antitone f) {k : ZMod m} (l : ZMod m)\n    (hs : Summable ({n : ℕ | (n : ZMod m) = k}.indicator f)) :\n    Summable ({n : ℕ | (n : ZMod m) = l}.indicator f) := by\n  by_cases hf₀ : ∀ n, 0 ≤ f n -- the interesting case\n  · rw [← ZMod.natCast_zmod_val k, summable_indicator_mod_iff_summable] at hs\n    have hl : (l.val + m : ZMod m) = l := by\n      simp only [ZMod.natCast_val, ZMod.cast_id', id_eq, CharP.cast_eq_zero, add_zero]\n    rw [← hl, ← Nat.cast_add, summable_indicator_mod_iff_summable]\n    exact hs.of_nonneg_of_le (fun _ ↦ hf₀ _)\n      fun _ ↦ hf <| Nat.add_le_add Nat.le.refl (k.val_lt.trans_le <| m.le_add_left l.val).le\n  · push_neg at hf₀\n    obtain ⟨n, hn⟩ := hf₀\n    exact (not_summable_indicator_mod_of_antitone_of_neg hf hn k hs).elim\n\n"}
{"name":"summable_indicator_mod_iff","module":"Mathlib.Analysis.SumOverResidueClass","initialProofState":"m : Nat\ninst✝ : NeZero m\nf : Nat → Real\nhf : Antitone f\nk : ZMod m\n⊢ Iff (Summable ((setOf fun n => Eq (↑n) k).indicator f)) (Summable f)","decl":"/-- A decreasing sequence of real numbers is summable on a residue class\nif and only if it is summable. -/\nlemma summable_indicator_mod_iff {m : ℕ} [NeZero m] {f : ℕ → ℝ} (hf : Antitone f) (k : ZMod m) :\n    Summable ({n : ℕ | (n : ZMod m) = k}.indicator f) ↔ Summable f := by\n  refine ⟨fun H ↦ ?_, fun H ↦ Summable.indicator H _⟩\n  rw [Finset.sum_indicator_mod m f]\n  convert summable_sum (s := Finset.univ)\n    fun a _ ↦ summable_indicator_mod_iff_summable_indicator_mod hf a H\n  simp only [Finset.sum_apply]\n\n"}
{"name":"Nat.sumByResidueClasses","module":"Mathlib.Analysis.SumOverResidueClass","initialProofState":"R : Type u_1\ninst✝⁵ : AddCommGroup R\ninst✝⁴ : UniformSpace R\ninst✝³ : UniformAddGroup R\ninst✝² : CompleteSpace R\ninst✝¹ : T0Space R\nf : Nat → R\nhf : Summable f\nN : Nat\ninst✝ : NeZero N\n⊢ Eq (tsum fun n => f n) (Finset.univ.sum fun j => tsum fun m => f (HAdd.hAdd j.val (HMul.hMul N m)))","decl":"/-- If `f` is a summable function on `ℕ`, and `0 < N`, then we may compute `∑' n : ℕ, f n` by\nsumming each residue class mod `N` separately. -/\nlemma Nat.sumByResidueClasses {R : Type*} [AddCommGroup R] [UniformSpace R] [UniformAddGroup R]\n    [CompleteSpace R] [T0Space R] {f : ℕ → R} (hf : Summable f) (N : ℕ) [NeZero N] :\n    ∑' n, f n = ∑ j : ZMod N, ∑' m, f (j.val + N * m) := by\n  rw [← (residueClassesEquiv N).symm.tsum_eq f, tsum_prod, tsum_fintype, residueClassesEquiv,\n    Equiv.coe_fn_symm_mk]\n  exact hf.comp_injective (residueClassesEquiv N).symm.injective\n"}
