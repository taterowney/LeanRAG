{"name":"Submodule.coe_span_smul","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R' : Type u_1\nM' : Type u_2\ninst✝² : CommSemiring R'\ninst✝¹ : AddCommMonoid M'\ninst✝ : Module R' M'\ns : Set R'\nN : Submodule R' M'\n⊢ Eq (HSMul.hSMul (↑(Ideal.span s)) N) (HSMul.hSMul s N)","decl":"lemma coe_span_smul {R' M' : Type*} [CommSemiring R'] [AddCommMonoid M'] [Module R' M']\n    (s : Set R') (N : Submodule R' M') :\n    (Ideal.span s : Set R') • N = s • N :=\n  set_smul_eq_of_le _ _ _\n    (by rintro r n hr hn\n        induction hr using Submodule.span_induction with\n        | mem _ h => exact mem_set_smul_of_mem_mem h hn\n        | zero => rw [zero_smul]; exact Submodule.zero_mem _\n        | add _ _ _ _ ihr ihs => rw [add_smul]; exact Submodule.add_mem _ ihr ihs\n        | smul _ _ hr =>\n          rw [mem_span_set] at hr\n          obtain ⟨c, hc, rfl⟩ := hr\n          rw [Finsupp.sum, Finset.smul_sum, Finset.sum_smul]\n          refine Submodule.sum_mem _ fun i hi => ?_\n          rw [← mul_smul, smul_eq_mul, mul_comm, mul_smul]\n          exact mem_set_smul_of_mem_mem (hc hi) <| Submodule.smul_mem _ _ hn) <|\n    set_smul_mono_left _ Submodule.subset_span\n\n"}
{"name":"Submodule.span_singleton_toAddSubgroup_eq_zmultiples","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"a : Int\n⊢ Eq (Submodule.span Int (Singleton.singleton a)).toAddSubgroup (AddSubgroup.zmultiples a)","decl":"lemma span_singleton_toAddSubgroup_eq_zmultiples (a : ℤ) :\n    (span ℤ {a}).toAddSubgroup = AddSubgroup.zmultiples a := by\n  ext i\n  simp [Ideal.mem_span_singleton', AddSubgroup.mem_zmultiples_iff]\n\n"}
{"name":"Ideal.span_singleton_toAddSubgroup_eq_zmultiples","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"a : Int\n⊢ Eq (Submodule.toAddSubgroup (Ideal.span (Singleton.singleton a))) (AddSubgroup.zmultiples a)","decl":"@[simp] lemma _root_.Ideal.span_singleton_toAddSubgroup_eq_zmultiples (a : ℤ) :\n   (Ideal.span {a}).toAddSubgroup = AddSubgroup.zmultiples a :=\n  Submodule.span_singleton_toAddSubgroup_eq_zmultiples _\n\n"}
{"name":"Ideal.smul_eq_mul","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : Semiring R\nI J : Ideal R\n⊢ Eq (HSMul.hSMul I J) (HMul.hMul I J)","decl":"/-- This duplicates the global `smul_eq_mul`, but doesn't have to unfold anywhere near as much to\napply. -/\nprotected theorem _root_.Ideal.smul_eq_mul (I J : Ideal R) : I • J = I * J :=\n  rfl\n\n"}
{"name":"Submodule.smul_le_right","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\nM : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nI : Ideal R\nN : Submodule R M\n⊢ LE.le (HSMul.hSMul I N) N","decl":"theorem smul_le_right : I • N ≤ N :=\n  smul_le.2 fun r _ _ ↦ N.smul_mem r\n\n"}
{"name":"Submodule.map_le_smul_top","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\nM : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nI : Ideal R\nf : LinearMap (RingHom.id R) R M\n⊢ LE.le (Submodule.map f I) (HSMul.hSMul I Top.top)","decl":"theorem map_le_smul_top (I : Ideal R) (f : R →ₗ[R] M) :\n    Submodule.map f I ≤ I • (⊤ : Submodule R M) := by\n  rintro _ ⟨y, hy, rfl⟩\n  rw [← mul_one y, ← smul_eq_mul, f.map_smul]\n  exact smul_mem_smul hy mem_top\n\n"}
{"name":"Submodule.top_smul","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\nM : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nN : Submodule R M\n⊢ Eq (HSMul.hSMul Top.top N) N","decl":"@[simp]\ntheorem top_smul : (⊤ : Ideal R) • N = N :=\n  le_antisymm smul_le_right fun r hri => one_smul R r ▸ smul_mem_smul mem_top hri\n\n"}
{"name":"Submodule.mem_of_span_top_of_smul_mem","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\nM : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nM' : Submodule R M\ns : Set R\nhs : Eq (Ideal.span s) Top.top\nx : M\nH : ∀ (r : ↑s), Membership.mem M' (HSMul.hSMul (↑r) x)\n⊢ Membership.mem M' x","decl":"theorem mem_of_span_top_of_smul_mem (M' : Submodule R M) (s : Set R) (hs : Ideal.span s = ⊤) (x : M)\n    (H : ∀ r : s, (r : R) • x ∈ M') : x ∈ M' := by\n  suffices LinearMap.range (LinearMap.toSpanSingleton R M x) ≤ M' by\n    rw [← LinearMap.toSpanSingleton_one R M x]\n    exact this (LinearMap.mem_range_self _ 1)\n  rw [LinearMap.range_eq_map, ← hs, map_le_iff_le_comap, Ideal.span, span_le]\n  exact fun r hr ↦ H ⟨r, hr⟩\n\n"}
{"name":"Submodule.map_smul''","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nI : Ideal R\nN : Submodule R M\nM' : Type w\ninst✝¹ : AddCommMonoid M'\ninst✝ : Module R M'\nf : LinearMap (RingHom.id R) M M'\n⊢ Eq (Submodule.map f (HSMul.hSMul I N)) (HSMul.hSMul I (Submodule.map f N))","decl":"@[simp]\ntheorem map_smul'' (f : M →ₗ[R] M') : (I • N).map f = I • N.map f :=\n  le_antisymm\n    (map_le_iff_le_comap.2 <|\n      smul_le.2 fun r hr n hn =>\n        show f (r • n) ∈ I • N.map f from\n          (f.map_smul r n).symm ▸ smul_mem_smul hr (mem_map_of_mem hn)) <|\n    smul_le.2 fun r hr _ hn =>\n      let ⟨p, hp, hfp⟩ := mem_map.1 hn\n      hfp ▸ f.map_smul r p ▸ mem_map_of_mem (smul_mem_smul hr hp)\n\n"}
{"name":"Submodule.mem_smul_top_iff","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\nM : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nI : Ideal R\nN : Submodule R M\nx : Subtype fun x => Membership.mem N x\n⊢ Iff (Membership.mem (HSMul.hSMul I Top.top) x) (Membership.mem (HSMul.hSMul I N) ↑x)","decl":"theorem mem_smul_top_iff (N : Submodule R M) (x : N) :\n    x ∈ I • (⊤ : Submodule R N) ↔ (x : M) ∈ I • N := by\n  change _ ↔ N.subtype x ∈ I • N\n  have : Submodule.map N.subtype (I • ⊤) = I • N := by\n    rw [Submodule.map_smul'', Submodule.map_top, Submodule.range_subtype]\n  rw [← this]\n  exact (Function.Injective.mem_set_image N.injective_subtype).symm\n\n"}
{"name":"Submodule.smul_comap_le_comap_smul","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nM' : Type w\ninst✝¹ : AddCommMonoid M'\ninst✝ : Module R M'\nf : LinearMap (RingHom.id R) M M'\nS : Submodule R M'\nI : Ideal R\n⊢ LE.le (HSMul.hSMul I (Submodule.comap f S)) (Submodule.comap f (HSMul.hSMul I S))","decl":"@[simp]\ntheorem smul_comap_le_comap_smul (f : M →ₗ[R] M') (S : Submodule R M') (I : Ideal R) :\n    I • S.comap f ≤ (I • S).comap f := by\n  refine Submodule.smul_le.mpr fun r hr x hx => ?_\n  rw [Submodule.mem_comap] at hx ⊢\n  rw [f.map_smul]\n  exact Submodule.smul_mem_smul hr hx\n\n"}
{"name":"Submodule.mem_smul_span_singleton","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\nM : Type v\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nI : Ideal R\nm x : M\n⊢ Iff (Membership.mem (HSMul.hSMul I (Submodule.span R (Singleton.singleton m))) x) (Exists fun y => And (Membership.mem I y) (Eq (HSMul.hSMul y m) x))","decl":"theorem mem_smul_span_singleton {I : Ideal R} {m : M} {x : M} :\n    x ∈ I • span R ({m} : Set M) ↔ ∃ y ∈ I, y • m = x :=\n  ⟨fun hx =>\n    smul_induction_on hx\n      (fun r hri _ hnm =>\n        let ⟨s, hs⟩ := mem_span_singleton.1 hnm\n        ⟨r * s, I.mul_mem_right _ hri, hs ▸ mul_smul r s m⟩)\n      fun m1 m2 ⟨y1, hyi1, hy1⟩ ⟨y2, hyi2, hy2⟩ =>\n      ⟨y1 + y2, I.add_mem hyi1 hyi2, by rw [add_smul, hy1, hy2]⟩,\n    fun ⟨_, hyi, hy⟩ => hy ▸ smul_mem_smul hyi (subset_span <| Set.mem_singleton m)⟩\n\n"}
{"name":"Submodule.smul_eq_map₂","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\nM : Type v\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nI : Ideal R\nN : Submodule R M\n⊢ Eq (HSMul.hSMul I N) (Submodule.map₂ (LinearMap.lsmul R M) I N)","decl":"theorem smul_eq_map₂ : I • N = Submodule.map₂ (LinearMap.lsmul R M) I N :=\n  le_antisymm (smul_le.mpr fun _m hm _n ↦ Submodule.apply_mem_map₂ _ hm)\n    (map₂_le.mpr fun _m hm _n ↦ smul_mem_smul hm)\n\n"}
{"name":"Submodule.span_smul_span","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\nM : Type v\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nS : Set R\nT : Set M\n⊢ Eq (HSMul.hSMul (Ideal.span S) (Submodule.span R T)) (Submodule.span R (Set.iUnion fun s => Set.iUnion fun h => Set.iUnion fun t => Set.iUnion fun h => Singleton.singleton (HSMul.hSMul s t)))","decl":"theorem span_smul_span : Ideal.span S • span R T = span R (⋃ (s ∈ S) (t ∈ T), {s • t}) := by\n  rw [smul_eq_map₂]\n  exact (map₂_span_span _ _ _ _).trans <| congr_arg _ <| Set.image2_eq_iUnion _ _ _\n\n"}
{"name":"Submodule.ideal_span_singleton_smul","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\nM : Type v\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nr : R\nN : Submodule R M\n⊢ Eq (HSMul.hSMul (Ideal.span (Singleton.singleton r)) N) (HSMul.hSMul r N)","decl":"theorem ideal_span_singleton_smul (r : R) (N : Submodule R M) :\n    (Ideal.span {r} : Ideal R) • N = r • N := by\n  have : span R (⋃ (t : M) (_ : t ∈ N), {r • t}) = r • N := by\n    convert span_eq (r • N)\n    exact (Set.image_eq_iUnion _ (N : Set M)).symm\n  conv_lhs => rw [← span_eq N, span_smul_span]\n  simpa\n\n"}
{"name":"Submodule.mem_of_span_eq_top_of_smul_pow_mem","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\nM : Type v\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nM' : Submodule R M\ns : Set R\nhs : Eq (Ideal.span s) Top.top\nx : M\nH : ∀ (r : ↑s), Exists fun n => Membership.mem M' (HSMul.hSMul (HPow.hPow (↑r) n) x)\n⊢ Membership.mem M' x","decl":"/-- Given `s`, a generating set of `R`, to check that an `x : M` falls in a\nsubmodule `M'` of `x`, we only need to show that `r ^ n • x ∈ M'` for some `n` for each `r : s`. -/\ntheorem mem_of_span_eq_top_of_smul_pow_mem (M' : Submodule R M) (s : Set R) (hs : Ideal.span s = ⊤)\n    (x : M) (H : ∀ r : s, ∃ n : ℕ, ((r : R) ^ n : R) • x ∈ M') : x ∈ M' := by\n  choose f hf using H\n  apply M'.mem_of_span_top_of_smul_mem _ (Ideal.span_range_pow_eq_top s hs f)\n  rintro ⟨_, r, hr, rfl⟩\n  exact hf r\n\n"}
{"name":"Submodule.map_pointwise_smul","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\nM : Type v\nM' : Type u_1\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid M'\ninst✝ : Module R M'\nr : R\nN : Submodule R M\nf : LinearMap (RingHom.id R) M M'\n⊢ Eq (Submodule.map f (HSMul.hSMul r N)) (HSMul.hSMul r (Submodule.map f N))","decl":"open Pointwise in\n@[simp]\ntheorem map_pointwise_smul (r : R) (N : Submodule R M) (f : M →ₗ[R] M') :\n    (r • N).map f = r • N.map f := by\n  simp_rw [← ideal_span_singleton_smul, map_smul'']\n\n"}
{"name":"Submodule.mem_smul_span","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\nM : Type v\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nI : Ideal R\ns : Set M\nx : M\n⊢ Iff (Membership.mem (HSMul.hSMul I (Submodule.span R s)) x) (Membership.mem (Submodule.span R (Set.iUnion fun a => Set.iUnion fun h => Set.iUnion fun b => Set.iUnion fun h => Singleton.singleton (HSMul.hSMul a b))) x)","decl":"theorem mem_smul_span {s : Set M} {x : M} :\n    x ∈ I • Submodule.span R s ↔ x ∈ Submodule.span R (⋃ (a ∈ I) (b ∈ s), ({a • b} : Set M)) := by\n  rw [← I.span_eq, Submodule.span_smul_span, I.span_eq]\n  rfl\n\n"}
{"name":"Submodule.mem_ideal_smul_span_iff_exists_sum","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\nM : Type v\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nI : Ideal R\nι : Type u_4\nf : ι → M\nx : M\n⊢ Iff (Membership.mem (HSMul.hSMul I (Submodule.span R (Set.range f))) x) (Exists fun a => Exists fun x_1 => Eq (a.sum fun i c => HSMul.hSMul c (f i)) x)","decl":"/-- If `x` is an `I`-multiple of the submodule spanned by `f '' s`,\nthen we can write `x` as an `I`-linear combination of the elements of `f '' s`. -/\ntheorem mem_ideal_smul_span_iff_exists_sum {ι : Type*} (f : ι → M) (x : M) :\n    x ∈ I • span R (Set.range f) ↔\n      ∃ (a : ι →₀ R) (_ : ∀ i, a i ∈ I), (a.sum fun i c => c • f i) = x := by\n  constructor; swap\n  · rintro ⟨a, ha, rfl⟩\n    exact Submodule.sum_mem _ fun c _ => smul_mem_smul (ha c) <| subset_span <| Set.mem_range_self _\n  refine fun hx => span_induction ?_ ?_ ?_ ?_ (mem_smul_span.mp hx)\n  · simp only [Set.mem_iUnion, Set.mem_range, Set.mem_singleton_iff]\n    rintro x ⟨y, hy, x, ⟨i, rfl⟩, rfl⟩\n    refine ⟨Finsupp.single i y, fun j => ?_, ?_⟩\n    · letI := Classical.decEq ι\n      rw [Finsupp.single_apply]\n      split_ifs\n      · assumption\n      · exact I.zero_mem\n    refine @Finsupp.sum_single_index ι R M _ _ i _ (fun i y => y • f i) ?_\n    simp\n  · exact ⟨0, fun _ => I.zero_mem, Finsupp.sum_zero_index⟩\n  · rintro x y - - ⟨ax, hax, rfl⟩ ⟨ay, hay, rfl⟩\n    refine ⟨ax + ay, fun i => I.add_mem (hax i) (hay i), Finsupp.sum_add_index' ?_ ?_⟩ <;>\n      intros <;> simp only [zero_smul, add_smul]\n  · rintro c x - ⟨a, ha, rfl⟩\n    refine ⟨c • a, fun i => I.mul_mem_left c (ha i), ?_⟩\n    rw [Finsupp.sum_smul_index, Finsupp.smul_sum] <;> intros <;> simp only [zero_smul, mul_smul]\n\n"}
{"name":"Submodule.mem_ideal_smul_span_iff_exists_sum'","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\nM : Type v\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nI : Ideal R\nι : Type u_4\ns : Set ι\nf : ι → M\nx : M\n⊢ Iff (Membership.mem (HSMul.hSMul I (Submodule.span R (Set.image f s))) x) (Exists fun a => Exists fun x_1 => Eq (a.sum fun i c => HSMul.hSMul c (f ↑i)) x)","decl":"theorem mem_ideal_smul_span_iff_exists_sum' {ι : Type*} (s : Set ι) (f : ι → M) (x : M) :\n    x ∈ I • span R (f '' s) ↔\n    ∃ (a : s →₀ R) (_ : ∀ i, a i ∈ I), (a.sum fun i c => c • f i) = x := by\n  rw [← Submodule.mem_ideal_smul_span_iff_exists_sum, ← Set.image_eq_range]\n\n"}
{"name":"Ideal.add_eq_sup","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : Semiring R\nI J : Ideal R\n⊢ Eq (HAdd.hAdd I J) (Max.max I J)","decl":"@[simp]\ntheorem add_eq_sup {I J : Ideal R} : I + J = I ⊔ J :=\n  rfl\n\n"}
{"name":"Ideal.zero_eq_bot","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : Semiring R\n⊢ Eq 0 Bot.bot","decl":"@[simp]\ntheorem zero_eq_bot : (0 : Ideal R) = ⊥ :=\n  rfl\n\n"}
{"name":"Ideal.sum_eq_sup","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : Semiring R\nι : Type u_1\ns : Finset ι\nf : ι → Ideal R\n⊢ Eq (s.sum f) (s.sup f)","decl":"@[simp]\ntheorem sum_eq_sup {ι : Type*} (s : Finset ι) (f : ι → Ideal R) : s.sum f = s.sup f :=\n  rfl\n\n"}
{"name":"Ideal.one_eq_top","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : Semiring R\n⊢ Eq 1 Top.top","decl":"@[simp]\ntheorem one_eq_top : (1 : Ideal R) = ⊤ := by\n  rw [Submodule.one_eq_span, ← Ideal.span, Ideal.span_singleton_one]\n\n"}
{"name":"Ideal.add_eq_one_iff","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : Semiring R\nI J : Ideal R\n⊢ Iff (Eq (HAdd.hAdd I J) 1) (Exists fun i => And (Membership.mem I i) (Exists fun j => And (Membership.mem J j) (Eq (HAdd.hAdd i j) 1)))","decl":"theorem add_eq_one_iff : I + J = 1 ↔ ∃ i ∈ I, ∃ j ∈ J, i + j = 1 := by\n  rw [one_eq_top, eq_top_iff_one, add_eq_sup, Submodule.mem_sup]\n\n"}
{"name":"Ideal.mul_mem_mul","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : Semiring R\nI J : Ideal R\nr s : R\nhr : Membership.mem I r\nhs : Membership.mem J s\n⊢ Membership.mem (HMul.hMul I J) (HMul.hMul r s)","decl":"theorem mul_mem_mul {r s} (hr : r ∈ I) (hs : s ∈ J) : r * s ∈ I * J :=\n  Submodule.smul_mem_smul hr hs\n\n"}
{"name":"Ideal.pow_mem_pow","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : Semiring R\nI : Ideal R\nx : R\nhx : Membership.mem I x\nn : Nat\n⊢ Membership.mem (HPow.hPow I n) (HPow.hPow x n)","decl":"theorem pow_mem_pow {x : R} (hx : x ∈ I) (n : ℕ) : x ^ n ∈ I ^ n :=\n  Submodule.pow_mem_pow _ hx _\n\n"}
{"name":"Ideal.mul_le","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : Semiring R\nI J K : Ideal R\n⊢ Iff (LE.le (HMul.hMul I J) K) (∀ (r : R), Membership.mem I r → ∀ (s : R), Membership.mem J s → Membership.mem K (HMul.hMul r s))","decl":"theorem mul_le : I * J ≤ K ↔ ∀ r ∈ I, ∀ s ∈ J, r * s ∈ K :=\n  Submodule.smul_le\n\n"}
{"name":"Ideal.mul_le_left","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : Semiring R\nI J : Ideal R\n⊢ LE.le (HMul.hMul I J) J","decl":"theorem mul_le_left : I * J ≤ J :=\n  Ideal.mul_le.2 fun _ _ _ => J.mul_mem_left _\n\n"}
{"name":"Ideal.sup_mul_left_self","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : Semiring R\nI J : Ideal R\n⊢ Eq (Max.max I (HMul.hMul J I)) I","decl":"@[simp]\ntheorem sup_mul_left_self : I ⊔ J * I = I :=\n  sup_eq_left.2 Ideal.mul_le_left\n\n"}
{"name":"Ideal.mul_left_self_sup","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : Semiring R\nI J : Ideal R\n⊢ Eq (Max.max (HMul.hMul J I) I) I","decl":"@[simp]\ntheorem mul_left_self_sup : J * I ⊔ I = I :=\n  sup_eq_right.2 Ideal.mul_le_left\n\n"}
{"name":"Ideal.mul_assoc","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : Semiring R\nI J K : Ideal R\n⊢ Eq (HMul.hMul (HMul.hMul I J) K) (HMul.hMul I (HMul.hMul J K))","decl":"protected theorem mul_assoc : I * J * K = I * (J * K) :=\n  Submodule.smul_assoc I J K\n\n"}
{"name":"Ideal.mul_bot","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : Semiring R\nI : Ideal R\n⊢ Eq (HMul.hMul I Bot.bot) Bot.bot","decl":"theorem mul_bot : I * ⊥ = ⊥ := by simp\n\n"}
{"name":"Ideal.bot_mul","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : Semiring R\nI : Ideal R\n⊢ Eq (HMul.hMul Bot.bot I) Bot.bot","decl":"theorem bot_mul : ⊥ * I = ⊥ := by simp\n\n"}
{"name":"Ideal.top_mul","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : Semiring R\nI : Ideal R\n⊢ Eq (HMul.hMul Top.top I) I","decl":"@[simp]\ntheorem top_mul : ⊤ * I = I :=\n  Submodule.top_smul I\n\n"}
{"name":"Ideal.mul_mono","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : Semiring R\nI J K L : Ideal R\nhik : LE.le I K\nhjl : LE.le J L\n⊢ LE.le (HMul.hMul I J) (HMul.hMul K L)","decl":"theorem mul_mono (hik : I ≤ K) (hjl : J ≤ L) : I * J ≤ K * L :=\n  Submodule.smul_mono hik hjl\n\n"}
{"name":"Ideal.mul_mono_left","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : Semiring R\nI J K : Ideal R\nh : LE.le I J\n⊢ LE.le (HMul.hMul I K) (HMul.hMul J K)","decl":"theorem mul_mono_left (h : I ≤ J) : I * K ≤ J * K :=\n  Submodule.smul_mono_left h\n\n"}
{"name":"Ideal.mul_mono_right","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : Semiring R\nI J K : Ideal R\nh : LE.le J K\n⊢ LE.le (HMul.hMul I J) (HMul.hMul I K)","decl":"theorem mul_mono_right (h : J ≤ K) : I * J ≤ I * K :=\n  smul_mono_right I h\n\n"}
{"name":"Ideal.mul_sup","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : Semiring R\nI J K : Ideal R\n⊢ Eq (HMul.hMul I (Max.max J K)) (Max.max (HMul.hMul I J) (HMul.hMul I K))","decl":"theorem mul_sup : I * (J ⊔ K) = I * J ⊔ I * K :=\n  Submodule.smul_sup I J K\n\n"}
{"name":"Ideal.sup_mul","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : Semiring R\nI J K : Ideal R\n⊢ Eq (HMul.hMul (Max.max I J) K) (Max.max (HMul.hMul I K) (HMul.hMul J K))","decl":"theorem sup_mul : (I ⊔ J) * K = I * K ⊔ J * K :=\n  Submodule.sup_smul I J K\n\n"}
{"name":"Ideal.pow_le_pow_right","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : Semiring R\nI : Ideal R\nm n : Nat\nh : LE.le m n\n⊢ LE.le (HPow.hPow I n) (HPow.hPow I m)","decl":"theorem pow_le_pow_right {m n : ℕ} (h : m ≤ n) : I ^ n ≤ I ^ m := by\n  obtain _ | m := m\n  · rw [Submodule.pow_zero, one_eq_top]; exact le_top\n  obtain ⟨n, rfl⟩ := Nat.exists_eq_add_of_le h\n  simp_rw [add_comm, (· ^ ·), Pow.pow, npowRec_add _ _ m.succ_ne_zero _ I.one_mul]\n  exact mul_le_left\n\n"}
{"name":"Ideal.pow_le_self","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : Semiring R\nI : Ideal R\nn : Nat\nhn : Ne n 0\n⊢ LE.le (HPow.hPow I n) I","decl":"theorem pow_le_self {n : ℕ} (hn : n ≠ 0) : I ^ n ≤ I :=\n  calc\n    I ^ n ≤ I ^ 1 := pow_le_pow_right (Nat.pos_of_ne_zero hn)\n    _ = I := Submodule.pow_one _\n\n"}
{"name":"Ideal.pow_right_mono","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : Semiring R\nI J : Ideal R\ne : LE.le I J\nn : Nat\n⊢ LE.le (HPow.hPow I n) (HPow.hPow J n)","decl":"theorem pow_right_mono (e : I ≤ J) (n : ℕ) : I ^ n ≤ J ^ n := by\n  induction' n with _ hn\n  · rw [Submodule.pow_zero, Submodule.pow_zero]\n  · rw [Submodule.pow_succ, Submodule.pow_succ]\n    exact Ideal.mul_mono hn e\n\n"}
{"name":"Ideal.mul_eq_bot","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝¹ : Semiring R\nI J : Ideal R\ninst✝ : NoZeroDivisors R\n⊢ Iff (Eq (HMul.hMul I J) Bot.bot) (Or (Eq I Bot.bot) (Eq J Bot.bot))","decl":"@[simp]\ntheorem mul_eq_bot [NoZeroDivisors R] : I * J = ⊥ ↔ I = ⊥ ∨ J = ⊥ :=\n  ⟨fun hij =>\n    or_iff_not_imp_left.mpr fun I_ne_bot =>\n      J.eq_bot_iff.mpr fun j hj =>\n        let ⟨i, hi, ne0⟩ := I.ne_bot_iff.mp I_ne_bot\n        Or.resolve_left (mul_eq_zero.mp ((I * J).eq_bot_iff.mp hij _ (mul_mem_mul hi hj))) ne0,\n    fun h => by obtain rfl | rfl := h; exacts [bot_mul _, mul_bot _]⟩\n\n"}
{"name":"Ideal.instNoZeroDivisors","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝¹ : Semiring R\ninst✝ : NoZeroDivisors R\n⊢ NoZeroDivisors (Ideal R)","decl":"instance [NoZeroDivisors R] : NoZeroDivisors (Ideal R) where\n  eq_zero_or_eq_zero_of_mul_eq_zero := mul_eq_bot.1\n\n"}
{"name":"Ideal.instNoZeroSMulDivisorsSubtypeMemSubmodule","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝⁷ : Semiring R\nS : Type u_1\nA : Type u_2\ninst✝⁶ : Semiring S\ninst✝⁵ : SMul R S\ninst✝⁴ : AddCommMonoid A\ninst✝³ : Module R A\ninst✝² : Module S A\ninst✝¹ : IsScalarTower R S A\ninst✝ : NoZeroSMulDivisors R A\nI : Submodule S A\n⊢ NoZeroSMulDivisors R (Subtype fun x => Membership.mem I x)","decl":"instance {S A : Type*} [Semiring S] [SMul R S] [AddCommMonoid A] [Module R A] [Module S A]\n    [IsScalarTower R S A] [NoZeroSMulDivisors R A] {I : Submodule S A} : NoZeroSMulDivisors R I :=\n  Submodule.noZeroSMulDivisors (Submodule.restrictScalars R I)\n\n"}
{"name":"Ideal.mul_mem_mul_rev","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI J : Ideal R\nr s : R\nhr : Membership.mem I r\nhs : Membership.mem J s\n⊢ Membership.mem (HMul.hMul I J) (HMul.hMul s r)","decl":"theorem mul_mem_mul_rev {r s} (hr : r ∈ I) (hs : s ∈ J) : s * r ∈ I * J :=\n  mul_comm r s ▸ mul_mem_mul hr hs\n\n"}
{"name":"Ideal.prod_mem_prod","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nι : Type u_2\ns : Finset ι\nI : ι → Ideal R\nx : ι → R\na✝ : ∀ (i : ι), Membership.mem s i → Membership.mem (I i) (x i)\n⊢ Membership.mem (s.prod fun i => I i) (s.prod fun i => x i)","decl":"theorem prod_mem_prod {ι : Type*} {s : Finset ι} {I : ι → Ideal R} {x : ι → R} :\n    (∀ i ∈ s, x i ∈ I i) → (∏ i ∈ s, x i) ∈ ∏ i ∈ s, I i := by\n  classical\n    refine Finset.induction_on s ?_ ?_\n    · intro\n      rw [Finset.prod_empty, Finset.prod_empty, one_eq_top]\n      exact Submodule.mem_top\n    · intro a s ha IH h\n      rw [Finset.prod_insert ha, Finset.prod_insert ha]\n      exact\n        mul_mem_mul (h a <| Finset.mem_insert_self a s)\n          (IH fun i hi => h i <| Finset.mem_insert_of_mem hi)\n\n"}
{"name":"Ideal.mul_le_right","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI J : Ideal R\n⊢ LE.le (HMul.hMul I J) I","decl":"theorem mul_le_right : I * J ≤ I :=\n  Ideal.mul_le.2 fun _ hr _ _ => I.mul_mem_right _ hr\n\n"}
{"name":"Ideal.sup_mul_right_self","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI J : Ideal R\n⊢ Eq (Max.max I (HMul.hMul I J)) I","decl":"@[simp, nolint simpNF]\ntheorem sup_mul_right_self : I ⊔ I * J = I :=\n  sup_eq_left.2 Ideal.mul_le_right\n\n"}
{"name":"Ideal.mul_right_self_sup","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI J : Ideal R\n⊢ Eq (Max.max (HMul.hMul I J) I) I","decl":"@[simp, nolint simpNF]\ntheorem mul_right_self_sup : I * J ⊔ I = I :=\n  sup_eq_right.2 Ideal.mul_le_right\n\n"}
{"name":"Ideal.sup_pow_add_le_pow_sup_pow","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI J : Ideal R\nn m : Nat\n⊢ LE.le (HPow.hPow (Max.max I J) (HAdd.hAdd n m)) (Max.max (HPow.hPow I n) (HPow.hPow J m))","decl":"lemma sup_pow_add_le_pow_sup_pow {n m : ℕ} : (I ⊔ J) ^ (n + m) ≤ I ^ n ⊔ J ^ m := by\n  rw [← Ideal.add_eq_sup, ← Ideal.add_eq_sup, add_pow, Ideal.sum_eq_sup]\n  apply Finset.sup_le\n  intros i hi\n  by_cases hn : n ≤ i\n  · exact (Ideal.mul_le_right.trans (Ideal.mul_le_right.trans\n      ((Ideal.pow_le_pow_right hn).trans le_sup_left)))\n  · refine (Ideal.mul_le_right.trans (Ideal.mul_le_left.trans\n      ((Ideal.pow_le_pow_right ?_).trans le_sup_right)))\n    omega\n\n"}
{"name":"Ideal.mul_comm","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI J : Ideal R\n⊢ Eq (HMul.hMul I J) (HMul.hMul J I)","decl":"protected theorem mul_comm : I * J = J * I :=\n  le_antisymm (mul_le.2 fun _ hrI _ hsJ => mul_mem_mul_rev hsJ hrI)\n    (mul_le.2 fun _ hrJ _ hsI => mul_mem_mul_rev hsI hrJ)\n\n"}
{"name":"Ideal.span_mul_span","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nS T : Set R\n⊢ Eq (HMul.hMul (Ideal.span S) (Ideal.span T)) (Ideal.span (Set.iUnion fun s => Set.iUnion fun h => Set.iUnion fun t => Set.iUnion fun h => Singleton.singleton (HMul.hMul s t)))","decl":"theorem span_mul_span (S T : Set R) : span S * span T = span (⋃ (s ∈ S) (t ∈ T), {s * t}) :=\n  Submodule.span_smul_span S T\n\n"}
{"name":"Ideal.span_mul_span'","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nS T : Set R\n⊢ Eq (HMul.hMul (Ideal.span S) (Ideal.span T)) (Ideal.span (HMul.hMul S T))","decl":"theorem span_mul_span' (S T : Set R) : span S * span T = span (S * T) := by\n  unfold span\n  rw [Submodule.span_mul_span]\n\n"}
{"name":"Ideal.span_singleton_mul_span_singleton","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nr s : R\n⊢ Eq (HMul.hMul (Ideal.span (Singleton.singleton r)) (Ideal.span (Singleton.singleton s))) (Ideal.span (Singleton.singleton (HMul.hMul r s)))","decl":"theorem span_singleton_mul_span_singleton (r s : R) :\n    span {r} * span {s} = (span {r * s} : Ideal R) := by\n  unfold span\n  rw [Submodule.span_mul_span, Set.singleton_mul_singleton]\n\n"}
{"name":"Ideal.span_singleton_pow","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\ns : R\nn : Nat\n⊢ Eq (HPow.hPow (Ideal.span (Singleton.singleton s)) n) (Ideal.span (Singleton.singleton (HPow.hPow s n)))","decl":"theorem span_singleton_pow (s : R) (n : ℕ) : span {s} ^ n = (span {s ^ n} : Ideal R) := by\n  induction' n with n ih; · simp [Set.singleton_one]\n  simp only [pow_succ, ih, span_singleton_mul_span_singleton]\n\n"}
{"name":"Ideal.mem_mul_span_singleton","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx y : R\nI : Ideal R\n⊢ Iff (Membership.mem (HMul.hMul I (Ideal.span (Singleton.singleton y))) x) (Exists fun z => And (Membership.mem I z) (Eq (HMul.hMul z y) x))","decl":"theorem mem_mul_span_singleton {x y : R} {I : Ideal R} : x ∈ I * span {y} ↔ ∃ z ∈ I, z * y = x :=\n  Submodule.mem_smul_span_singleton\n\n"}
{"name":"Ideal.mem_span_singleton_mul","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx y : R\nI : Ideal R\n⊢ Iff (Membership.mem (HMul.hMul (Ideal.span (Singleton.singleton y)) I) x) (Exists fun z => And (Membership.mem I z) (Eq (HMul.hMul y z) x))","decl":"theorem mem_span_singleton_mul {x y : R} {I : Ideal R} : x ∈ span {y} * I ↔ ∃ z ∈ I, y * z = x := by\n  simp only [mul_comm, mem_mul_span_singleton]\n\n"}
{"name":"Ideal.le_span_singleton_mul_iff","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx : R\nI J : Ideal R\n⊢ Iff (LE.le I (HMul.hMul (Ideal.span (Singleton.singleton x)) J)) (∀ (zI : R), Membership.mem I zI → Exists fun zJ => And (Membership.mem J zJ) (Eq (HMul.hMul x zJ) zI))","decl":"theorem le_span_singleton_mul_iff {x : R} {I J : Ideal R} :\n    I ≤ span {x} * J ↔ ∀ zI ∈ I, ∃ zJ ∈ J, x * zJ = zI :=\n  show (∀ {zI} (_ : zI ∈ I), zI ∈ span {x} * J) ↔ ∀ zI ∈ I, ∃ zJ ∈ J, x * zJ = zI by\n    simp only [mem_span_singleton_mul]\n\n"}
{"name":"Ideal.span_singleton_mul_le_iff","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx : R\nI J : Ideal R\n⊢ Iff (LE.le (HMul.hMul (Ideal.span (Singleton.singleton x)) I) J) (∀ (z : R), Membership.mem I z → Membership.mem J (HMul.hMul x z))","decl":"theorem span_singleton_mul_le_iff {x : R} {I J : Ideal R} :\n    span {x} * I ≤ J ↔ ∀ z ∈ I, x * z ∈ J := by\n  simp only [mul_le, mem_span_singleton_mul, mem_span_singleton]\n  constructor\n  · intro h zI hzI\n    exact h x (dvd_refl x) zI hzI\n  · rintro h _ ⟨z, rfl⟩ zI hzI\n    rw [mul_comm x z, mul_assoc]\n    exact J.mul_mem_left _ (h zI hzI)\n\n"}
{"name":"Ideal.span_singleton_mul_le_span_singleton_mul","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx y : R\nI J : Ideal R\n⊢ Iff (LE.le (HMul.hMul (Ideal.span (Singleton.singleton x)) I) (HMul.hMul (Ideal.span (Singleton.singleton y)) J)) (∀ (zI : R), Membership.mem I zI → Exists fun zJ => And (Membership.mem J zJ) (Eq (HMul.hMul x zI) (HMul.hMul y zJ)))","decl":"theorem span_singleton_mul_le_span_singleton_mul {x y : R} {I J : Ideal R} :\n    span {x} * I ≤ span {y} * J ↔ ∀ zI ∈ I, ∃ zJ ∈ J, x * zI = y * zJ := by\n  simp only [span_singleton_mul_le_iff, mem_span_singleton_mul, eq_comm]\n\n"}
{"name":"Ideal.span_singleton_mul_right_mono","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝¹ : CommSemiring R\nI J : Ideal R\ninst✝ : IsDomain R\nx : R\nhx : Ne x 0\n⊢ Iff (LE.le (HMul.hMul (Ideal.span (Singleton.singleton x)) I) (HMul.hMul (Ideal.span (Singleton.singleton x)) J)) (LE.le I J)","decl":"theorem span_singleton_mul_right_mono [IsDomain R] {x : R} (hx : x ≠ 0) :\n    span {x} * I ≤ span {x} * J ↔ I ≤ J := by\n  simp_rw [span_singleton_mul_le_span_singleton_mul, mul_right_inj' hx,\n    exists_eq_right', SetLike.le_def]\n\n"}
{"name":"Ideal.span_singleton_mul_left_mono","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝¹ : CommSemiring R\nI J : Ideal R\ninst✝ : IsDomain R\nx : R\nhx : Ne x 0\n⊢ Iff (LE.le (HMul.hMul I (Ideal.span (Singleton.singleton x))) (HMul.hMul J (Ideal.span (Singleton.singleton x)))) (LE.le I J)","decl":"theorem span_singleton_mul_left_mono [IsDomain R] {x : R} (hx : x ≠ 0) :\n    I * span {x} ≤ J * span {x} ↔ I ≤ J := by\n  simpa only [mul_comm I, mul_comm J] using span_singleton_mul_right_mono hx\n\n"}
{"name":"Ideal.span_singleton_mul_right_inj","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝¹ : CommSemiring R\nI J : Ideal R\ninst✝ : IsDomain R\nx : R\nhx : Ne x 0\n⊢ Iff (Eq (HMul.hMul (Ideal.span (Singleton.singleton x)) I) (HMul.hMul (Ideal.span (Singleton.singleton x)) J)) (Eq I J)","decl":"theorem span_singleton_mul_right_inj [IsDomain R] {x : R} (hx : x ≠ 0) :\n    span {x} * I = span {x} * J ↔ I = J := by\n  simp only [le_antisymm_iff, span_singleton_mul_right_mono hx]\n\n"}
{"name":"Ideal.span_singleton_mul_left_inj","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝¹ : CommSemiring R\nI J : Ideal R\ninst✝ : IsDomain R\nx : R\nhx : Ne x 0\n⊢ Iff (Eq (HMul.hMul I (Ideal.span (Singleton.singleton x))) (HMul.hMul J (Ideal.span (Singleton.singleton x)))) (Eq I J)","decl":"theorem span_singleton_mul_left_inj [IsDomain R] {x : R} (hx : x ≠ 0) :\n    I * span {x} = J * span {x} ↔ I = J := by\n  simp only [le_antisymm_iff, span_singleton_mul_left_mono hx]\n\n"}
{"name":"Ideal.span_singleton_mul_right_injective","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝¹ : CommSemiring R\ninst✝ : IsDomain R\nx : R\nhx : Ne x 0\n⊢ Function.Injective fun x_1 => HMul.hMul (Ideal.span (Singleton.singleton x)) x_1","decl":"theorem span_singleton_mul_right_injective [IsDomain R] {x : R} (hx : x ≠ 0) :\n    Function.Injective ((span {x} : Ideal R) * ·) := fun _ _ =>\n  (span_singleton_mul_right_inj hx).mp\n\n"}
{"name":"Ideal.span_singleton_mul_left_injective","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝¹ : CommSemiring R\ninst✝ : IsDomain R\nx : R\nhx : Ne x 0\n⊢ Function.Injective fun I => HMul.hMul I (Ideal.span (Singleton.singleton x))","decl":"theorem span_singleton_mul_left_injective [IsDomain R] {x : R} (hx : x ≠ 0) :\n    Function.Injective fun I : Ideal R => I * span {x} := fun _ _ =>\n  (span_singleton_mul_left_inj hx).mp\n\n"}
{"name":"Ideal.eq_span_singleton_mul","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx : R\nI J : Ideal R\n⊢ Iff (Eq I (HMul.hMul (Ideal.span (Singleton.singleton x)) J)) (And (∀ (zI : R), Membership.mem I zI → Exists fun zJ => And (Membership.mem J zJ) (Eq (HMul.hMul x zJ) zI)) (∀ (z : R), Membership.mem J z → Membership.mem I (HMul.hMul x z)))","decl":"theorem eq_span_singleton_mul {x : R} (I J : Ideal R) :\n    I = span {x} * J ↔ (∀ zI ∈ I, ∃ zJ ∈ J, x * zJ = zI) ∧ ∀ z ∈ J, x * z ∈ I := by\n  simp only [le_antisymm_iff, le_span_singleton_mul_iff, span_singleton_mul_le_iff]\n\n"}
{"name":"Ideal.span_singleton_mul_eq_span_singleton_mul","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx y : R\nI J : Ideal R\n⊢ Iff (Eq (HMul.hMul (Ideal.span (Singleton.singleton x)) I) (HMul.hMul (Ideal.span (Singleton.singleton y)) J)) (And (∀ (zI : R), Membership.mem I zI → Exists fun zJ => And (Membership.mem J zJ) (Eq (HMul.hMul x zI) (HMul.hMul y zJ))) (∀ (zJ : R), Membership.mem J zJ → Exists fun zI => And (Membership.mem I zI) (Eq (HMul.hMul x zI) (HMul.hMul y zJ))))","decl":"theorem span_singleton_mul_eq_span_singleton_mul {x y : R} (I J : Ideal R) :\n    span {x} * I = span {y} * J ↔\n      (∀ zI ∈ I, ∃ zJ ∈ J, x * zI = y * zJ) ∧ ∀ zJ ∈ J, ∃ zI ∈ I, x * zI = y * zJ := by\n  simp only [le_antisymm_iff, span_singleton_mul_le_span_singleton_mul, eq_comm]\n\n"}
{"name":"Ideal.prod_span","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nι : Type u_2\ns : Finset ι\nI : ι → Set R\n⊢ Eq (s.prod fun i => Ideal.span (I i)) (Ideal.span (s.prod fun i => I i))","decl":"theorem prod_span {ι : Type*} (s : Finset ι) (I : ι → Set R) :\n    (∏ i ∈ s, Ideal.span (I i)) = Ideal.span (∏ i ∈ s, I i) :=\n  Submodule.prod_span s I\n\n"}
{"name":"Ideal.prod_span_singleton","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nι : Type u_2\ns : Finset ι\nI : ι → R\n⊢ Eq (s.prod fun i => Ideal.span (Singleton.singleton (I i))) (Ideal.span (Singleton.singleton (s.prod fun i => I i)))","decl":"theorem prod_span_singleton {ι : Type*} (s : Finset ι) (I : ι → R) :\n    (∏ i ∈ s, Ideal.span ({I i} : Set R)) = Ideal.span {∏ i ∈ s, I i} :=\n  Submodule.prod_span_singleton s I\n\n"}
{"name":"Ideal.multiset_prod_span_singleton","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nm : Multiset R\n⊢ Eq (Multiset.map (fun x => Ideal.span (Singleton.singleton x)) m).prod (Ideal.span (Singleton.singleton m.prod))","decl":"@[simp]\ntheorem multiset_prod_span_singleton (m : Multiset R) :\n    (m.map fun x => Ideal.span {x}).prod = Ideal.span ({Multiset.prod m} : Set R) :=\n  Multiset.induction_on m (by simp) fun a m ih => by\n    simp only [Multiset.map_cons, Multiset.prod_cons, ih, ← Ideal.span_singleton_mul_span_singleton]\n\n"}
{"name":"Ideal.finset_inf_span_singleton","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nι : Type u_2\ns : Finset ι\nI : ι → R\nhI : (↑s).Pairwise (Function.onFun IsCoprime I)\n⊢ Eq (s.inf fun i => Ideal.span (Singleton.singleton (I i))) (Ideal.span (Singleton.singleton (s.prod fun i => I i)))","decl":"open scoped Function in -- required for scoped `on` notation\ntheorem finset_inf_span_singleton {ι : Type*} (s : Finset ι) (I : ι → R)\n    (hI : Set.Pairwise (↑s) (IsCoprime on I)) :\n    (s.inf fun i => Ideal.span ({I i} : Set R)) = Ideal.span {∏ i ∈ s, I i} := by\n  ext x\n  simp only [Submodule.mem_finset_inf, Ideal.mem_span_singleton]\n  exact ⟨Finset.prod_dvd_of_coprime hI, fun h i hi => (Finset.dvd_prod_of_mem _ hi).trans h⟩\n\n"}
{"name":"Ideal.iInf_span_singleton","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝¹ : CommSemiring R\nι : Type u_2\ninst✝ : Fintype ι\nI : ι → R\nhI : ∀ (i j : ι), Ne i j → IsCoprime (I i) (I j)\n⊢ Eq (iInf fun i => Ideal.span (Singleton.singleton (I i))) (Ideal.span (Singleton.singleton (Finset.univ.prod fun i => I i)))","decl":"theorem iInf_span_singleton {ι : Type*} [Fintype ι] {I : ι → R}\n    (hI : ∀ (i j) (_ : i ≠ j), IsCoprime (I i) (I j)) :\n    ⨅ i, span ({I i} : Set R) = span {∏ i, I i} := by\n  rw [← Finset.inf_univ_eq_iInf, finset_inf_span_singleton]\n  rwa [Finset.coe_univ, Set.pairwise_univ]\n\n"}
{"name":"Ideal.iInf_span_singleton_natCast","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u_2\ninst✝¹ : CommRing R\nι : Type u_3\ninst✝ : Fintype ι\nI : ι → Nat\nhI : Pairwise fun i j => (I i).Coprime (I j)\n⊢ Eq (iInf fun i => Ideal.span (Singleton.singleton ↑(I i))) (Ideal.span (Singleton.singleton ↑(Finset.univ.prod fun i => I i)))","decl":"theorem iInf_span_singleton_natCast {R : Type*} [CommRing R] {ι : Type*} [Fintype ι]\n    {I : ι → ℕ} (hI : Pairwise fun i j => (I i).Coprime (I j)) :\n    ⨅ (i : ι), span {(I i : R)} = span {((∏ i : ι, I i : ℕ) : R)} := by\n  rw [iInf_span_singleton, Nat.cast_prod]\n  exact fun i j h ↦ (hI h).cast\n\n"}
{"name":"Ideal.sup_eq_top_iff_isCoprime","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u_2\ninst✝ : CommSemiring R\nx y : R\n⊢ Iff (Eq (Max.max (Ideal.span (Singleton.singleton x)) (Ideal.span (Singleton.singleton y))) Top.top) (IsCoprime x y)","decl":"theorem sup_eq_top_iff_isCoprime {R : Type*} [CommSemiring R] (x y : R) :\n    span ({x} : Set R) ⊔ span {y} = ⊤ ↔ IsCoprime x y := by\n  rw [eq_top_iff_one, Submodule.mem_sup]\n  constructor\n  · rintro ⟨u, hu, v, hv, h1⟩\n    rw [mem_span_singleton'] at hu hv\n    rw [← hu.choose_spec, ← hv.choose_spec] at h1\n    exact ⟨_, _, h1⟩\n  · exact fun ⟨u, v, h1⟩ =>\n      ⟨_, mem_span_singleton'.mpr ⟨_, rfl⟩, _, mem_span_singleton'.mpr ⟨_, rfl⟩, h1⟩\n\n"}
{"name":"Ideal.mul_le_inf","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI J : Ideal R\n⊢ LE.le (HMul.hMul I J) (Min.min I J)","decl":"theorem mul_le_inf : I * J ≤ I ⊓ J :=\n  mul_le.2 fun r hri s hsj => ⟨I.mul_mem_right s hri, J.mul_mem_left r hsj⟩\n\n"}
{"name":"Ideal.multiset_prod_le_inf","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\ns : Multiset (Ideal R)\n⊢ LE.le s.prod s.inf","decl":"theorem multiset_prod_le_inf {s : Multiset (Ideal R)} : s.prod ≤ s.inf := by\n  classical\n    refine s.induction_on ?_ ?_\n    · rw [Multiset.inf_zero]\n      exact le_top\n    intro a s ih\n    rw [Multiset.prod_cons, Multiset.inf_cons]\n    exact le_trans mul_le_inf (inf_le_inf le_rfl ih)\n\n"}
{"name":"Ideal.prod_le_inf","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\nι : Type u_1\ninst✝ : CommSemiring R\ns : Finset ι\nf : ι → Ideal R\n⊢ LE.le (s.prod f) (s.inf f)","decl":"theorem prod_le_inf {s : Finset ι} {f : ι → Ideal R} : s.prod f ≤ s.inf f :=\n  multiset_prod_le_inf\n\n"}
{"name":"Ideal.mul_eq_inf_of_coprime","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI J : Ideal R\nh : Eq (Max.max I J) Top.top\n⊢ Eq (HMul.hMul I J) (Min.min I J)","decl":"theorem mul_eq_inf_of_coprime (h : I ⊔ J = ⊤) : I * J = I ⊓ J :=\n  le_antisymm mul_le_inf fun r ⟨hri, hrj⟩ =>\n    let ⟨s, hsi, t, htj, hst⟩ := Submodule.mem_sup.1 ((eq_top_iff_one _).1 h)\n    mul_one r ▸\n      hst ▸\n        (mul_add r s t).symm ▸ Ideal.add_mem (I * J) (mul_mem_mul_rev hsi hrj) (mul_mem_mul hri htj)\n\n"}
{"name":"Ideal.sup_mul_eq_of_coprime_left","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI J K : Ideal R\nh : Eq (Max.max I J) Top.top\n⊢ Eq (Max.max I (HMul.hMul J K)) (Max.max I K)","decl":"theorem sup_mul_eq_of_coprime_left (h : I ⊔ J = ⊤) : I ⊔ J * K = I ⊔ K :=\n  le_antisymm (sup_le_sup_left mul_le_left _) fun i hi => by\n    rw [eq_top_iff_one] at h; rw [Submodule.mem_sup] at h hi ⊢\n    obtain ⟨i1, hi1, j, hj, h⟩ := h; obtain ⟨i', hi', k, hk, hi⟩ := hi\n    refine ⟨_, add_mem hi' (mul_mem_right k _ hi1), _, mul_mem_mul hj hk, ?_⟩\n    rw [add_assoc, ← add_mul, h, one_mul, hi]\n\n"}
{"name":"Ideal.sup_mul_eq_of_coprime_right","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI J K : Ideal R\nh : Eq (Max.max I K) Top.top\n⊢ Eq (Max.max I (HMul.hMul J K)) (Max.max I J)","decl":"theorem sup_mul_eq_of_coprime_right (h : I ⊔ K = ⊤) : I ⊔ J * K = I ⊔ J := by\n  rw [mul_comm]\n  exact sup_mul_eq_of_coprime_left h\n\n"}
{"name":"Ideal.mul_sup_eq_of_coprime_left","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI J K : Ideal R\nh : Eq (Max.max I J) Top.top\n⊢ Eq (Max.max (HMul.hMul I K) J) (Max.max K J)","decl":"theorem mul_sup_eq_of_coprime_left (h : I ⊔ J = ⊤) : I * K ⊔ J = K ⊔ J := by\n  rw [sup_comm] at h\n  rw [sup_comm, sup_mul_eq_of_coprime_left h, sup_comm]\n\n"}
{"name":"Ideal.mul_sup_eq_of_coprime_right","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI J K : Ideal R\nh : Eq (Max.max K J) Top.top\n⊢ Eq (Max.max (HMul.hMul I K) J) (Max.max I J)","decl":"theorem mul_sup_eq_of_coprime_right (h : K ⊔ J = ⊤) : I * K ⊔ J = I ⊔ J := by\n  rw [sup_comm] at h\n  rw [sup_comm, sup_mul_eq_of_coprime_right h, sup_comm]\n\n"}
{"name":"Ideal.sup_prod_eq_top","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\nι : Type u_1\ninst✝ : CommSemiring R\nI : Ideal R\ns : Finset ι\nJ : ι → Ideal R\nh : ∀ (i : ι), Membership.mem s i → Eq (Max.max I (J i)) Top.top\n⊢ Eq (Max.max I (s.prod fun i => J i)) Top.top","decl":"theorem sup_prod_eq_top {s : Finset ι} {J : ι → Ideal R} (h : ∀ i, i ∈ s → I ⊔ J i = ⊤) :\n    (I ⊔ ∏ i ∈ s, J i) = ⊤ :=\n  Finset.prod_induction _ (fun J => I ⊔ J = ⊤)\n    (fun _ _ hJ hK => (sup_mul_eq_of_coprime_left hJ).trans hK)\n    (by simp_rw [one_eq_top, sup_top_eq]) h\n\n"}
{"name":"Ideal.sup_multiset_prod_eq_top","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI : Ideal R\ns : Multiset (Ideal R)\nh : ∀ (p : Ideal R), Membership.mem s p → Eq (Max.max I p) Top.top\n⊢ Eq (Max.max I s.prod) Top.top","decl":"theorem sup_multiset_prod_eq_top {s : Multiset (Ideal R)} (h : ∀  p ∈ s, I ⊔ p = ⊤) :\n    I ⊔ Multiset.prod s = ⊤ :=\n  Multiset.prod_induction (I ⊔ · = ⊤) s (fun _ _ hp hq ↦ (sup_mul_eq_of_coprime_left hp).trans hq)\n    (by simp only [one_eq_top, ge_iff_le, top_le_iff, le_top, sup_of_le_right]) h\n\n"}
{"name":"Ideal.sup_iInf_eq_top","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\nι : Type u_1\ninst✝ : CommSemiring R\nI : Ideal R\ns : Finset ι\nJ : ι → Ideal R\nh : ∀ (i : ι), Membership.mem s i → Eq (Max.max I (J i)) Top.top\n⊢ Eq (Max.max I (iInf fun i => iInf fun h => J i)) Top.top","decl":"theorem sup_iInf_eq_top {s : Finset ι} {J : ι → Ideal R} (h : ∀ i, i ∈ s → I ⊔ J i = ⊤) :\n    (I ⊔ ⨅ i ∈ s, J i) = ⊤ :=\n  eq_top_iff.mpr <|\n    le_of_eq_of_le (sup_prod_eq_top h).symm <|\n      sup_le_sup_left (le_of_le_of_eq prod_le_inf <| Finset.inf_eq_iInf _ _) _\n\n"}
{"name":"Ideal.prod_sup_eq_top","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\nι : Type u_1\ninst✝ : CommSemiring R\nI : Ideal R\ns : Finset ι\nJ : ι → Ideal R\nh : ∀ (i : ι), Membership.mem s i → Eq (Max.max (J i) I) Top.top\n⊢ Eq (Max.max (s.prod fun i => J i) I) Top.top","decl":"theorem prod_sup_eq_top {s : Finset ι} {J : ι → Ideal R} (h : ∀ i, i ∈ s → J i ⊔ I = ⊤) :\n    (∏ i ∈ s, J i) ⊔ I = ⊤ := by rw [sup_comm, sup_prod_eq_top]; intro i hi; rw [sup_comm, h i hi]\n\n"}
{"name":"Ideal.iInf_sup_eq_top","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\nι : Type u_1\ninst✝ : CommSemiring R\nI : Ideal R\ns : Finset ι\nJ : ι → Ideal R\nh : ∀ (i : ι), Membership.mem s i → Eq (Max.max (J i) I) Top.top\n⊢ Eq (Max.max (iInf fun i => iInf fun h => J i) I) Top.top","decl":"theorem iInf_sup_eq_top {s : Finset ι} {J : ι → Ideal R} (h : ∀ i, i ∈ s → J i ⊔ I = ⊤) :\n    (⨅ i ∈ s, J i) ⊔ I = ⊤ := by rw [sup_comm, sup_iInf_eq_top]; intro i hi; rw [sup_comm, h i hi]\n\n"}
{"name":"Ideal.sup_pow_eq_top","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI J : Ideal R\nn : Nat\nh : Eq (Max.max I J) Top.top\n⊢ Eq (Max.max I (HPow.hPow J n)) Top.top","decl":"theorem sup_pow_eq_top {n : ℕ} (h : I ⊔ J = ⊤) : I ⊔ J ^ n = ⊤ := by\n  rw [← Finset.card_range n, ← Finset.prod_const]\n  exact sup_prod_eq_top fun _ _ => h\n\n"}
{"name":"Ideal.pow_sup_eq_top","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI J : Ideal R\nn : Nat\nh : Eq (Max.max I J) Top.top\n⊢ Eq (Max.max (HPow.hPow I n) J) Top.top","decl":"theorem pow_sup_eq_top {n : ℕ} (h : I ⊔ J = ⊤) : I ^ n ⊔ J = ⊤ := by\n  rw [← Finset.card_range n, ← Finset.prod_const]\n  exact prod_sup_eq_top fun _ _ => h\n\n"}
{"name":"Ideal.pow_sup_pow_eq_top","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI J : Ideal R\nm n : Nat\nh : Eq (Max.max I J) Top.top\n⊢ Eq (Max.max (HPow.hPow I m) (HPow.hPow J n)) Top.top","decl":"theorem pow_sup_pow_eq_top {m n : ℕ} (h : I ⊔ J = ⊤) : I ^ m ⊔ J ^ n = ⊤ :=\n  sup_pow_eq_top (pow_sup_eq_top h)\n\n"}
{"name":"Ideal.mul_top","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI : Ideal R\n⊢ Eq (HMul.hMul I Top.top) I","decl":"variable (I) in\n@[simp]\ntheorem mul_top : I * ⊤ = I :=\n  Ideal.mul_comm ⊤ I ▸ Submodule.top_smul I\n\n"}
{"name":"Ideal.multiset_prod_eq_bot","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u_2\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\ns : Multiset (Ideal R)\n⊢ Iff (Eq s.prod Bot.bot) (Membership.mem s Bot.bot)","decl":"/-- A product of ideals in an integral domain is zero if and only if one of the terms is zero. -/\n@[simp]\nlemma multiset_prod_eq_bot {R : Type*} [CommRing R] [IsDomain R] {s : Multiset (Ideal R)} :\n    s.prod = ⊥ ↔ ⊥ ∈ s :=\n  Multiset.prod_eq_zero_iff\n\n"}
{"name":"Ideal.span_pair_mul_span_pair","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nw x y z : R\n⊢ Eq (HMul.hMul (Ideal.span (Insert.insert w (Singleton.singleton x))) (Ideal.span (Insert.insert y (Singleton.singleton z)))) (Ideal.span (Insert.insert (HMul.hMul w y) (Insert.insert (HMul.hMul w z) (Insert.insert (HMul.hMul x y) (Singleton.singleton (HMul.hMul x z))))))","decl":"theorem span_pair_mul_span_pair (w x y z : R) :\n    (span {w, x} : Ideal R) * span {y, z} = span {w * y, w * z, x * y, x * z} := by\n  simp_rw [span_insert, sup_mul, mul_sup, span_singleton_mul_span_singleton, sup_assoc]\n\n"}
{"name":"Ideal.isCoprime_iff_codisjoint","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI J : Ideal R\n⊢ Iff (IsCoprime I J) (Codisjoint I J)","decl":"theorem isCoprime_iff_codisjoint : IsCoprime I J ↔ Codisjoint I J := by\n  rw [IsCoprime, codisjoint_iff]\n  constructor\n  · rintro ⟨x, y, hxy⟩\n    rw [eq_top_iff_one]\n    apply (show x * I + y * J ≤ I ⊔ J from\n      sup_le (mul_le_left.trans le_sup_left) (mul_le_left.trans le_sup_right))\n    rw [hxy]\n    simp only [one_eq_top, Submodule.mem_top]\n  · intro h\n    refine ⟨1, 1, ?_⟩\n    simpa only [one_eq_top, top_mul, Submodule.add_eq_sup]\n\n"}
{"name":"Ideal.isCoprime_iff_add","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI J : Ideal R\n⊢ Iff (IsCoprime I J) (Eq (HAdd.hAdd I J) 1)","decl":"theorem isCoprime_iff_add : IsCoprime I J ↔ I + J = 1 := by\n  rw [isCoprime_iff_codisjoint, codisjoint_iff, add_eq_sup, one_eq_top]\n\n"}
{"name":"Ideal.isCoprime_iff_exists","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI J : Ideal R\n⊢ Iff (IsCoprime I J) (Exists fun i => And (Membership.mem I i) (Exists fun j => And (Membership.mem J j) (Eq (HAdd.hAdd i j) 1)))","decl":"theorem isCoprime_iff_exists : IsCoprime I J ↔ ∃ i ∈ I, ∃ j ∈ J, i + j = 1 := by\n  rw [← add_eq_one_iff, isCoprime_iff_add]\n\n"}
{"name":"Ideal.isCoprime_iff_sup_eq","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI J : Ideal R\n⊢ Iff (IsCoprime I J) (Eq (Max.max I J) Top.top)","decl":"theorem isCoprime_iff_sup_eq : IsCoprime I J ↔ I ⊔ J = ⊤ := by\n  rw [isCoprime_iff_codisjoint, codisjoint_iff]\n\n"}
{"name":"Ideal.isCoprime_tfae","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI J : Ideal R\n⊢ (List.cons (IsCoprime I J) (List.cons (Codisjoint I J) (List.cons (Eq (HAdd.hAdd I J) 1) (List.cons (Exists fun i => And (Membership.mem I i) (Exists fun j => And (Membership.mem J j) (Eq (HAdd.hAdd i j) 1))) (List.cons (Eq (Max.max I J) Top.top) List.nil))))).TFAE","decl":"open List in\ntheorem isCoprime_tfae : TFAE [IsCoprime I J, Codisjoint I J, I + J = 1,\n    ∃ i ∈ I, ∃ j ∈ J, i + j = 1, I ⊔ J = ⊤] := by\n  rw [← isCoprime_iff_codisjoint, ← isCoprime_iff_add, ← isCoprime_iff_exists,\n      ← isCoprime_iff_sup_eq]\n  simp\n\n"}
{"name":"IsCoprime.codisjoint","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI J : Ideal R\nh : IsCoprime I J\n⊢ Codisjoint I J","decl":"theorem _root_.IsCoprime.codisjoint (h : IsCoprime I J) : Codisjoint I J :=\n  isCoprime_iff_codisjoint.mp h\n\n"}
{"name":"IsCoprime.add_eq","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI J : Ideal R\nh : IsCoprime I J\n⊢ Eq (HAdd.hAdd I J) 1","decl":"theorem _root_.IsCoprime.add_eq (h : IsCoprime I J) : I + J = 1 := isCoprime_iff_add.mp h\n\n"}
{"name":"IsCoprime.exists","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI J : Ideal R\nh : IsCoprime I J\n⊢ Exists fun i => And (Membership.mem I i) (Exists fun j => And (Membership.mem J j) (Eq (HAdd.hAdd i j) 1))","decl":"theorem _root_.IsCoprime.exists (h : IsCoprime I J) : ∃ i ∈ I, ∃ j ∈ J, i + j = 1 :=\n  isCoprime_iff_exists.mp h\n\n"}
{"name":"IsCoprime.sup_eq","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI J : Ideal R\nh : IsCoprime I J\n⊢ Eq (Max.max I J) Top.top","decl":"theorem _root_.IsCoprime.sup_eq (h : IsCoprime I J) : I ⊔ J = ⊤ := isCoprime_iff_sup_eq.mp h\n\n"}
{"name":"Ideal.inf_eq_mul_of_isCoprime","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI J : Ideal R\ncoprime : IsCoprime I J\n⊢ Eq (Min.min I J) (HMul.hMul I J)","decl":"theorem inf_eq_mul_of_isCoprime (coprime : IsCoprime I J) : I ⊓ J = I * J :=\n  (Ideal.mul_eq_inf_of_coprime coprime.sup_eq).symm\n\n"}
{"name":"Ideal.isCoprime_span_singleton_iff","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx y : R\n⊢ Iff (IsCoprime (Ideal.span (Singleton.singleton x)) (Ideal.span (Singleton.singleton y))) (IsCoprime x y)","decl":"theorem isCoprime_span_singleton_iff (x y : R) :\n    IsCoprime (span <| singleton x) (span <| singleton y) ↔ IsCoprime x y := by\n  simp_rw [isCoprime_iff_codisjoint, codisjoint_iff, eq_top_iff_one, mem_span_singleton_sup,\n    mem_span_singleton]\n  constructor\n  · rintro ⟨a, _, ⟨b, rfl⟩, e⟩; exact ⟨a, b, mul_comm b y ▸ e⟩\n  · rintro ⟨a, b, e⟩; exact ⟨a, _, ⟨b, rfl⟩, mul_comm y b ▸ e⟩\n\n"}
{"name":"Ideal.isCoprime_biInf","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\nι : Type u_1\ninst✝ : CommSemiring R\nI : Ideal R\nJ : ι → Ideal R\ns : Finset ι\nhf : ∀ (j : ι), Membership.mem s j → IsCoprime I (J j)\n⊢ IsCoprime I (iInf fun j => iInf fun h => J j)","decl":"theorem isCoprime_biInf {J : ι → Ideal R} {s : Finset ι}\n    (hf : ∀ j ∈ s, IsCoprime I (J j)) : IsCoprime I (⨅ j ∈ s, J j) := by\n  classical\n  simp_rw [isCoprime_iff_add] at *\n  induction s using Finset.induction with\n  | empty =>\n      simp\n  | @insert i s _ hs =>\n      rw [Finset.iInf_insert, inf_comm, one_eq_top, eq_top_iff, ← one_eq_top]\n      set K := ⨅ j ∈ s, J j\n      calc\n        1 = I + K            := (hs fun j hj ↦ hf j (Finset.mem_insert_of_mem hj)).symm\n        _ = I + K*(I + J i)  := by rw [hf i (Finset.mem_insert_self i s), mul_one]\n        _ = (1+K)*I + K*J i  := by ring\n        _ ≤ I + K ⊓ J i      := add_le_add mul_le_left mul_le_inf\n\n"}
{"name":"Ideal.mem_radical_iff","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI : Ideal R\nr : R\n⊢ Iff (Membership.mem I.radical r) (Exists fun n => Membership.mem I (HPow.hPow r n))","decl":"theorem mem_radical_iff {r : R} : r ∈ I.radical ↔ ∃ n : ℕ, r ^ n ∈ I := Iff.rfl\n\n"}
{"name":"Ideal.le_radical","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI : Ideal R\n⊢ LE.le I I.radical","decl":"theorem le_radical : I ≤ radical I := fun r hri => ⟨1, (pow_one r).symm ▸ hri⟩\n\n"}
{"name":"Ideal.radical_eq_iff","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI : Ideal R\n⊢ Iff (Eq I.radical I) I.IsRadical","decl":"/-- An ideal is radical iff it is equal to its radical. -/\ntheorem radical_eq_iff : I.radical = I ↔ I.IsRadical := by\n  rw [le_antisymm_iff, and_iff_left le_radical, IsRadical]\n\n"}
{"name":"Ideal.IsRadical.radical","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI : Ideal R\na✝ : I.IsRadical\n⊢ Eq I.radical I","decl":"alias ⟨_, IsRadical.radical⟩ := radical_eq_iff\n\n"}
{"name":"Ideal.isRadical_iff_pow_one_lt","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI : Ideal R\nk : Nat\nhk : LT.lt 1 k\n⊢ Iff I.IsRadical (∀ (r : R), Membership.mem I (HPow.hPow r k) → Membership.mem I r)","decl":"theorem isRadical_iff_pow_one_lt (k : ℕ) (hk : 1 < k) : I.IsRadical ↔ ∀ r, r ^ k ∈ I → r ∈ I :=\n  ⟨fun h _r hr ↦ h ⟨k, hr⟩, fun h x ⟨n, hx⟩ ↦\n    k.pow_imp_self_of_one_lt hk _ (fun _ _ ↦ .inr ∘ I.smul_mem _) h n x hx⟩\n\n"}
{"name":"Ideal.radical_top","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\n⊢ Eq Top.top.radical Top.top","decl":"theorem radical_top : (radical ⊤ : Ideal R) = ⊤ :=\n  (eq_top_iff_one _).2 ⟨0, Submodule.mem_top⟩\n\n"}
{"name":"Ideal.radical_mono","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI J : Ideal R\nH : LE.le I J\n⊢ LE.le I.radical J.radical","decl":"theorem radical_mono (H : I ≤ J) : radical I ≤ radical J := fun _ ⟨n, hrni⟩ => ⟨n, H hrni⟩\n\n"}
{"name":"Ideal.radical_isRadical","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI : Ideal R\n⊢ I.radical.IsRadical","decl":"theorem radical_isRadical : (radical I).IsRadical := fun r ⟨n, k, hrnki⟩ =>\n  ⟨n * k, (pow_mul r n k).symm ▸ hrnki⟩\n\n"}
{"name":"Ideal.radical_idem","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI : Ideal R\n⊢ Eq I.radical.radical I.radical","decl":"@[simp]\ntheorem radical_idem : radical (radical I) = radical I :=\n  (radical_isRadical I).radical\n\n"}
{"name":"Ideal.IsRadical.radical_le_iff","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI J : Ideal R\nhJ : J.IsRadical\n⊢ Iff (LE.le I.radical J) (LE.le I J)","decl":"theorem IsRadical.radical_le_iff (hJ : J.IsRadical) : I.radical ≤ J ↔ I ≤ J :=\n  ⟨le_trans le_radical, fun h => hJ.radical ▸ radical_mono h⟩\n\n"}
{"name":"Ideal.radical_le_radical_iff","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI J : Ideal R\n⊢ Iff (LE.le I.radical J.radical) (LE.le I J.radical)","decl":"theorem radical_le_radical_iff : radical I ≤ radical J ↔ I ≤ radical J :=\n  (radical_isRadical J).radical_le_iff\n\n"}
{"name":"Ideal.radical_eq_top","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI : Ideal R\n⊢ Iff (Eq I.radical Top.top) (Eq I Top.top)","decl":"theorem radical_eq_top : radical I = ⊤ ↔ I = ⊤ :=\n  ⟨fun h =>\n    (eq_top_iff_one _).2 <|\n      let ⟨n, hn⟩ := (eq_top_iff_one _).1 h\n      @one_pow R _ n ▸ hn,\n    fun h => h.symm ▸ radical_top R⟩\n\n"}
{"name":"Ideal.IsPrime.isRadical","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI : Ideal R\nH : I.IsPrime\n⊢ I.IsRadical","decl":"theorem IsPrime.isRadical (H : IsPrime I) : I.IsRadical := fun _ ⟨n, hrni⟩ =>\n  H.mem_of_pow_mem n hrni\n\n"}
{"name":"Ideal.IsPrime.radical","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI : Ideal R\nH : I.IsPrime\n⊢ Eq I.radical I","decl":"theorem IsPrime.radical (H : IsPrime I) : radical I = I :=\n  IsRadical.radical H.isRadical\n\n"}
{"name":"Ideal.mem_radical_of_pow_mem","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI : Ideal R\nx : R\nm : Nat\nhx : Membership.mem I.radical (HPow.hPow x m)\n⊢ Membership.mem I.radical x","decl":"theorem mem_radical_of_pow_mem {I : Ideal R} {x : R} {m : ℕ} (hx : x ^ m ∈ radical I) :\n    x ∈ radical I :=\n  radical_idem I ▸ ⟨m, hx⟩\n\n"}
{"name":"Ideal.disjoint_powers_iff_not_mem","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI : Ideal R\ny : R\nhI : I.IsRadical\n⊢ Iff (Disjoint ↑(Submonoid.powers y) ↑I) (Not (Membership.mem I.toAddSubmonoid y))","decl":"theorem disjoint_powers_iff_not_mem (y : R) (hI : I.IsRadical) :\n    Disjoint (Submonoid.powers y : Set R) ↑I ↔ y ∉ I.1 := by\n  refine ⟨fun h => Set.disjoint_left.1 h (Submonoid.mem_powers _),\n      fun h => disjoint_iff.mpr (eq_bot_iff.mpr ?_)⟩\n  rintro x ⟨⟨n, rfl⟩, hx'⟩\n  exact h (hI <| mem_radical_of_pow_mem <| le_radical hx')\n\n"}
{"name":"Ideal.radical_sup","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI J : Ideal R\n⊢ Eq (Max.max I J).radical (Max.max I.radical J.radical).radical","decl":"theorem radical_sup : radical (I ⊔ J) = radical (radical I ⊔ radical J) :=\n  le_antisymm (radical_mono <| sup_le_sup le_radical le_radical) <|\n    radical_le_radical_iff.2 <| sup_le (radical_mono le_sup_left) (radical_mono le_sup_right)\n\n"}
{"name":"Ideal.radical_inf","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI J : Ideal R\n⊢ Eq (Min.min I J).radical (Min.min I.radical J.radical)","decl":"theorem radical_inf : radical (I ⊓ J) = radical I ⊓ radical J :=\n  le_antisymm (le_inf (radical_mono inf_le_left) (radical_mono inf_le_right))\n    fun r ⟨⟨m, hrm⟩, ⟨n, hrn⟩⟩ =>\n    ⟨m + n, (pow_add r m n).symm ▸ I.mul_mem_right _ hrm,\n      (pow_add r m n).symm ▸ J.mul_mem_left _ hrn⟩\n\n"}
{"name":"Ideal.IsRadical.inf","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI J : Ideal R\nhI : I.IsRadical\nhJ : J.IsRadical\n⊢ (Min.min I J).IsRadical","decl":"variable {I J} in\ntheorem IsRadical.inf (hI : IsRadical I) (hJ : IsRadical J) : IsRadical (I ⊓ J) := by\n  rw [IsRadical, radical_inf]; exact inf_le_inf hI hJ\n\n"}
{"name":"Ideal.radicalInfTopHom_apply","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI : Ideal R\n⊢ Eq (Ideal.radicalInfTopHom I) I.radical","decl":"@[simp]\nlemma radicalInfTopHom_apply (I : Ideal R) : radicalInfTopHom I = radical I := rfl\n\n"}
{"name":"Ideal.radical_finset_inf","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nι : Type u_2\ns : Finset ι\nf : ι → Ideal R\ni : ι\nhi : Membership.mem s i\nhs : ∀ ⦃y : ι⦄, Membership.mem s y → Eq (f y).radical (f i).radical\n⊢ Eq (s.inf f).radical (f i).radical","decl":"open Finset in\nlemma radical_finset_inf {ι} {s : Finset ι} {f : ι → Ideal R} {i : ι} (hi : i ∈ s)\n    (hs : ∀ ⦃y⦄, y ∈ s → (f y).radical = (f i).radical) :\n    (s.inf f).radical = (f i).radical := by\n  rw [← radicalInfTopHom_apply, map_finset_inf, ← Finset.inf'_eq_inf ⟨_, hi⟩]\n  exact Finset.inf'_eq_of_forall _ _ hs\n\n"}
{"name":"Ideal.radical_iInf_le","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nι : Sort u_2\nI : ι → Ideal R\n⊢ LE.le (iInf fun i => I i).radical (iInf fun i => (I i).radical)","decl":"/-- The reverse inclusion does not hold for e.g. `I := fun n : ℕ ↦ Ideal.span {(2 ^ n : ℤ)}`. -/\ntheorem radical_iInf_le {ι} (I : ι → Ideal R) : radical (⨅ i, I i) ≤ ⨅ i, radical (I i) :=\n  le_iInf fun _ ↦ radical_mono (iInf_le _ _)\n\n"}
{"name":"Ideal.isRadical_iInf","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nι : Sort u_2\nI : ι → Ideal R\nhI : ∀ (i : ι), (I i).IsRadical\n⊢ (iInf fun i => I i).IsRadical","decl":"theorem isRadical_iInf {ι} (I : ι → Ideal R) (hI : ∀ i, IsRadical (I i)) : IsRadical (⨅ i, I i) :=\n  (radical_iInf_le I).trans (iInf_mono hI)\n\n"}
{"name":"Ideal.radical_mul","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI J : Ideal R\n⊢ Eq (HMul.hMul I J).radical (Min.min I.radical J.radical)","decl":"theorem radical_mul : radical (I * J) = radical I ⊓ radical J := by\n  refine le_antisymm ?_ fun r ⟨⟨m, hrm⟩, ⟨n, hrn⟩⟩ =>\n    ⟨m + n, (pow_add r m n).symm ▸ mul_mem_mul hrm hrn⟩\n  have := radical_mono <| @mul_le_inf _ _ I J\n  simp_rw [radical_inf I J] at this\n  assumption\n\n"}
{"name":"Ideal.IsPrime.radical_le_iff","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI J : Ideal R\nhJ : J.IsPrime\n⊢ Iff (LE.le I.radical J) (LE.le I J)","decl":"theorem IsPrime.radical_le_iff (hJ : IsPrime J) : I.radical ≤ J ↔ I ≤ J :=\n  IsRadical.radical_le_iff hJ.isRadical\n\n"}
{"name":"Ideal.radical_eq_sInf","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI : Ideal R\n⊢ Eq I.radical (InfSet.sInf (setOf fun J => And (LE.le I J) J.IsPrime))","decl":"theorem radical_eq_sInf (I : Ideal R) : radical I = sInf { J : Ideal R | I ≤ J ∧ IsPrime J } :=\n  le_antisymm (le_sInf fun _ hJ ↦ hJ.2.radical_le_iff.2 hJ.1) fun r hr ↦\n    by_contradiction fun hri ↦\n      let ⟨m, hIm, hm⟩ :=\n        zorn_le_nonempty₀ { K : Ideal R | r ∉ radical K }\n          (fun c hc hcc y hyc =>\n            ⟨sSup c, fun ⟨n, hrnc⟩ =>\n              let ⟨_, hyc, hrny⟩ := (Submodule.mem_sSup_of_directed ⟨y, hyc⟩ hcc.directedOn).1 hrnc\n              hc hyc ⟨n, hrny⟩,\n              fun _ => le_sSup⟩)\n          I hri\n      have hrm : r ∉ radical m := hm.prop\n      have : ∀ x ∉ m, r ∈ radical (m ⊔ span {x}) := fun x hxm =>\n        by_contradiction fun hrmx => hxm <| by\n          rw [hm.eq_of_le hrmx le_sup_left]\n          exact Submodule.mem_sup_right <| mem_span_singleton_self x\n      have : IsPrime m :=\n        ⟨by rintro rfl; rw [radical_top] at hrm; exact hrm trivial, fun {x y} hxym =>\n          or_iff_not_imp_left.2 fun hxm =>\n            by_contradiction fun hym =>\n              let ⟨n, hrn⟩ := this _ hxm\n              let ⟨p, hpm, q, hq, hpqrn⟩ := Submodule.mem_sup.1 hrn\n              let ⟨c, hcxq⟩ := mem_span_singleton'.1 hq\n              let ⟨k, hrk⟩ := this _ hym\n              let ⟨f, hfm, g, hg, hfgrk⟩ := Submodule.mem_sup.1 hrk\n              let ⟨d, hdyg⟩ := mem_span_singleton'.1 hg\n              hrm\n                ⟨n + k, by\n                  rw [pow_add, ← hpqrn, ← hcxq, ← hfgrk, ← hdyg, add_mul, mul_add (c * x),\n                      mul_assoc c x (d * y), mul_left_comm x, ← mul_assoc]\n                  refine\n                    m.add_mem (m.mul_mem_right _ hpm)\n                    (m.add_mem (m.mul_mem_left _ hfm) (m.mul_mem_left _ hxym))⟩⟩\n    hrm <|\n      this.radical.symm ▸ (sInf_le ⟨hIm, this⟩ : sInf { J : Ideal R | I ≤ J ∧ IsPrime J } ≤ m) hr\n\n"}
{"name":"Ideal.isRadical_bot_of_noZeroDivisors","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u_2\ninst✝¹ : CommSemiring R\ninst✝ : NoZeroDivisors R\n⊢ Bot.bot.IsRadical","decl":"theorem isRadical_bot_of_noZeroDivisors {R} [CommSemiring R] [NoZeroDivisors R] :\n    (⊥ : Ideal R).IsRadical := fun _ hx => hx.recOn fun _ hn => pow_eq_zero hn\n\n"}
{"name":"Ideal.radical_bot_of_noZeroDivisors","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝¹ : CommSemiring R\ninst✝ : NoZeroDivisors R\n⊢ Eq Bot.bot.radical Bot.bot","decl":"@[simp]\ntheorem radical_bot_of_noZeroDivisors {R : Type u} [CommSemiring R] [NoZeroDivisors R] :\n    radical (⊥ : Ideal R) = ⊥ :=\n  eq_bot_iff.2 isRadical_bot_of_noZeroDivisors\n\n"}
{"name":"Ideal.top_pow","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nn : Nat\n⊢ Eq (HPow.hPow Top.top n) Top.top","decl":"variable (R) in\ntheorem top_pow (n : ℕ) : (⊤ ^ n : Ideal R) = ⊤ :=\n  Nat.recOn n one_eq_top fun n ih => by rw [pow_succ, ih, top_mul]\n\n"}
{"name":"Ideal.natCast_eq_top","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nn : Nat\nhn : Ne n 0\n⊢ Eq (↑n) Top.top","decl":"theorem natCast_eq_top {n : ℕ} (hn : n ≠ 0) : (n : Ideal R) = ⊤ :=\n  natCast_eq_one hn |>.trans one_eq_top\n\n"}
{"name":"Ideal.ofNat_eq_top","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝¹ : CommSemiring R\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (OfNat.ofNat n) Top.top","decl":"/-- `3 : Ideal R` is *not* the ideal generated by 3 (which would be spelt\n    `Ideal.span {3}`), it is simply `1 + 1 + 1 = ⊤`. -/\ntheorem ofNat_eq_top {n : ℕ} [n.AtLeastTwo] : (ofNat(n) : Ideal R) = ⊤ :=\n  ofNat_eq_one.trans one_eq_top\n\n"}
{"name":"Ideal.radical_pow","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI : Ideal R\nn : Nat\na✝ : Ne n 0\n⊢ Eq (HPow.hPow I n).radical I.radical","decl":"lemma radical_pow : ∀ {n}, n ≠ 0 → radical (I ^ n) = radical I\n  | 1, _ => by simp\n  | n + 2, _ => by rw [pow_succ, radical_mul, radical_pow n.succ_ne_zero, inf_idem]\n\n"}
{"name":"Ideal.IsPrime.mul_le","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI J P : Ideal R\nhp : P.IsPrime\n⊢ Iff (LE.le (HMul.hMul I J) P) (Or (LE.le I P) (LE.le J P))","decl":"theorem IsPrime.mul_le {I J P : Ideal R} (hp : IsPrime P) : I * J ≤ P ↔ I ≤ P ∨ J ≤ P := by\n  rw [or_comm, Ideal.mul_le]\n  simp_rw [hp.mul_mem_iff_mem_or_mem, SetLike.le_def, ← forall_or_left, or_comm, forall_or_left]\n\n"}
{"name":"Ideal.IsPrime.inf_le","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI J P : Ideal R\nhp : P.IsPrime\n⊢ Iff (LE.le (Min.min I J) P) (Or (LE.le I P) (LE.le J P))","decl":"theorem IsPrime.inf_le {I J P : Ideal R} (hp : IsPrime P) : I ⊓ J ≤ P ↔ I ≤ P ∨ J ≤ P :=\n  ⟨fun h ↦ hp.mul_le.1 <| mul_le_inf.trans h, fun h ↦ h.elim inf_le_left.trans inf_le_right.trans⟩\n\n"}
{"name":"Ideal.IsPrime.multiset_prod_le","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\ns : Multiset (Ideal R)\nP : Ideal R\nhp : P.IsPrime\n⊢ Iff (LE.le s.prod P) (Exists fun I => And (Membership.mem s I) (LE.le I P))","decl":"theorem IsPrime.multiset_prod_le {s : Multiset (Ideal R)} {P : Ideal R} (hp : IsPrime P) :\n    s.prod ≤ P ↔ ∃ I ∈ s, I ≤ P :=\n  s.induction_on (by simp [hp.ne_top]) fun I s ih ↦ by simp [hp.mul_le, ih]\n\n"}
{"name":"Ideal.IsPrime.multiset_prod_map_le","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\nι : Type u_1\ninst✝ : CommSemiring R\ns : Multiset ι\nf : ι → Ideal R\nP : Ideal R\nhp : P.IsPrime\n⊢ Iff (LE.le (Multiset.map f s).prod P) (Exists fun i => And (Membership.mem s i) (LE.le (f i) P))","decl":"theorem IsPrime.multiset_prod_map_le {s : Multiset ι} (f : ι → Ideal R) {P : Ideal R}\n    (hp : IsPrime P) : (s.map f).prod ≤ P ↔ ∃ i ∈ s, f i ≤ P := by\n  simp_rw [hp.multiset_prod_le, Multiset.mem_map, exists_exists_and_eq_and]\n\n"}
{"name":"Ideal.IsPrime.multiset_prod_mem_iff_exists_mem","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI : Ideal R\nhI : I.IsPrime\ns : Multiset R\n⊢ Iff (Membership.mem I s.prod) (Exists fun p => And (Membership.mem s p) (Membership.mem I p))","decl":"theorem IsPrime.multiset_prod_mem_iff_exists_mem {I : Ideal R} (hI : I.IsPrime) (s : Multiset R) :\n    s.prod ∈ I ↔ ∃ p ∈ s, p ∈ I := by\n  simpa [span_singleton_le_iff_mem] using (hI.multiset_prod_map_le (span {·}))\n\n"}
{"name":"Ideal.IsPrime.pow_le_iff","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI P : Ideal R\nhP : P.IsPrime\nn : Nat\nhn : Ne n 0\n⊢ Iff (LE.le (HPow.hPow I n) P) (LE.le I P)","decl":"theorem IsPrime.pow_le_iff {I P : Ideal R} [hP : P.IsPrime] {n : ℕ} (hn : n ≠ 0) :\n    I ^ n ≤ P ↔ I ≤ P := by\n  have h : (Multiset.replicate n I).prod ≤ P ↔ _ := hP.multiset_prod_le\n  simp_rw [Multiset.prod_replicate, Multiset.mem_replicate, ne_eq, hn, not_false_eq_true,\n    true_and, exists_eq_left] at h\n  exact h\n\n"}
{"name":"Ideal.pow_le_prime_iff","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI P : Ideal R\nhP : P.IsPrime\nn : Nat\nhn : Ne n 0\n⊢ Iff (LE.le (HPow.hPow I n) P) (LE.le I P)","decl":"@[deprecated (since := \"2024-10-06\")] alias pow_le_prime_iff := IsPrime.pow_le_iff\n\n"}
{"name":"Ideal.IsPrime.le_of_pow_le","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI P : Ideal R\nhP : P.IsPrime\nn : Nat\nh : LE.le (HPow.hPow I n) P\n⊢ LE.le I P","decl":"theorem IsPrime.le_of_pow_le {I P : Ideal R} [hP : P.IsPrime] {n : ℕ} (h : I ^ n ≤ P) :\n    I ≤ P := by\n  by_cases hn : n = 0\n  · rw [hn, pow_zero, one_eq_top] at h\n    exact fun ⦃_⦄ _ ↦ h Submodule.mem_top\n  · exact (pow_le_iff hn).mp h\n\n"}
{"name":"Ideal.le_of_pow_le_prime","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI P : Ideal R\nhP : P.IsPrime\nn : Nat\nh : LE.le (HPow.hPow I n) P\n⊢ LE.le I P","decl":"@[deprecated (since := \"2024-10-06\")] alias le_of_pow_le_prime := IsPrime.le_of_pow_le\n\n"}
{"name":"Ideal.IsPrime.prod_le","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\nι : Type u_1\ninst✝ : CommSemiring R\ns : Finset ι\nf : ι → Ideal R\nP : Ideal R\nhp : P.IsPrime\n⊢ Iff (LE.le (s.prod f) P) (Exists fun i => And (Membership.mem s i) (LE.le (f i) P))","decl":"theorem IsPrime.prod_le {s : Finset ι} {f : ι → Ideal R} {P : Ideal R} (hp : IsPrime P) :\n    s.prod f ≤ P ↔ ∃ i ∈ s, f i ≤ P :=\n  hp.multiset_prod_map_le f\n\n"}
{"name":"Ideal.prod_le_prime","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\nι : Type u_1\ninst✝ : CommSemiring R\ns : Finset ι\nf : ι → Ideal R\nP : Ideal R\nhp : P.IsPrime\n⊢ Iff (LE.le (s.prod f) P) (Exists fun i => And (Membership.mem s i) (LE.le (f i) P))","decl":"@[deprecated (since := \"2024-10-06\")] alias prod_le_prime := IsPrime.prod_le\n\n"}
{"name":"Ideal.IsPrime.prod_mem_iff","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\nι : Type u_1\ninst✝ : CommSemiring R\ns : Finset ι\nx : ι → R\np : Ideal R\nhp : p.IsPrime\n⊢ Iff (Membership.mem p (s.prod fun i => x i)) (Exists fun i => And (Membership.mem s i) (Membership.mem p (x i)))","decl":"/-- The product of a finite number of elements in the commutative semiring `R` lies in the\n  prime ideal `p` if and only if at least one of those elements is in `p`. -/\ntheorem IsPrime.prod_mem_iff {s : Finset ι} {x : ι → R} {p : Ideal R} [hp : p.IsPrime] :\n    ∏ i ∈ s, x i ∈ p ↔ ∃ i ∈ s, x i ∈ p := by\n  simp_rw [← span_singleton_le_iff_mem, ← prod_span_singleton]\n  exact hp.prod_le\n\n"}
{"name":"Ideal.IsPrime.prod_mem_iff_exists_mem","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI : Ideal R\nhI : I.IsPrime\ns : Finset R\n⊢ Iff (Membership.mem I (s.prod fun x => x)) (Exists fun p => And (Membership.mem s p) (Membership.mem I p))","decl":"theorem IsPrime.prod_mem_iff_exists_mem {I : Ideal R} (hI : I.IsPrime) (s : Finset R) :\n    s.prod (fun x ↦ x) ∈ I ↔ ∃ p ∈ s, p ∈ I := by\n  rw [Finset.prod_eq_multiset_prod, Multiset.map_id']\n  exact hI.multiset_prod_mem_iff_exists_mem s.val\n\n"}
{"name":"Ideal.IsPrime.inf_le'","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\nι : Type u_1\ninst✝ : CommSemiring R\ns : Finset ι\nf : ι → Ideal R\nP : Ideal R\nhp : P.IsPrime\n⊢ Iff (LE.le (s.inf f) P) (Exists fun i => And (Membership.mem s i) (LE.le (f i) P))","decl":"theorem IsPrime.inf_le' {s : Finset ι} {f : ι → Ideal R} {P : Ideal R} (hp : IsPrime P) :\n    s.inf f ≤ P ↔ ∃ i ∈ s, f i ≤ P :=\n  ⟨fun h ↦ hp.prod_le.1 <| prod_le_inf.trans h, fun ⟨_, his, hip⟩ ↦ (Finset.inf_le his).trans hip⟩\n\n-- Porting note: needed to add explicit coercions (· : Set R).\n"}
{"name":"Ideal.subset_union","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : Ring R\nI J K : Ideal R\n⊢ Iff (HasSubset.Subset (↑I) (Union.union ↑J ↑K)) (Or (LE.le I J) (LE.le I K))","decl":"theorem subset_union {R : Type u} [Ring R] {I J K : Ideal R} :\n    (I : Set R) ⊆ J ∪ K ↔ I ≤ J ∨ I ≤ K :=\n  AddSubgroupClass.subset_union\n\n"}
{"name":"Ideal.subset_union_prime'","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"ι : Type u_1\nR : Type u\ninst✝ : CommRing R\ns : Finset ι\nf : ι → Ideal R\na b : ι\nhp : ∀ (i : ι), Membership.mem s i → (f i).IsPrime\nI : Ideal R\n⊢ Iff (HasSubset.Subset (↑I) (Union.union (Union.union ↑(f a) ↑(f b)) (Set.iUnion fun i => Set.iUnion fun h => ↑(f i)))) (Or (LE.le I (f a)) (Or (LE.le I (f b)) (Exists fun i => And (Membership.mem s i) (LE.le I (f i)))))","decl":"theorem subset_union_prime' {R : Type u} [CommRing R] {s : Finset ι} {f : ι → Ideal R} {a b : ι}\n    (hp : ∀ i ∈ s, IsPrime (f i)) {I : Ideal R} :\n    ((I : Set R) ⊆ f a ∪ f b ∪ ⋃ i ∈ (↑s : Set ι), f i) ↔ I ≤ f a ∨ I ≤ f b ∨ ∃ i ∈ s, I ≤ f i := by\n  suffices\n    ((I : Set R) ⊆ f a ∪ f b ∪ ⋃ i ∈ (↑s : Set ι), f i) → I ≤ f a ∨ I ≤ f b ∨ ∃ i ∈ s, I ≤ f i from\n    ⟨this, fun h =>\n      Or.casesOn h\n        (fun h =>\n          Set.Subset.trans h <|\n            Set.Subset.trans Set.subset_union_left Set.subset_union_left)\n        fun h =>\n        Or.casesOn h\n          (fun h =>\n            Set.Subset.trans h <|\n              Set.Subset.trans Set.subset_union_right Set.subset_union_left)\n          fun ⟨i, his, hi⟩ => by\n          refine Set.Subset.trans hi <| Set.Subset.trans ?_ Set.subset_union_right\n          exact Set.subset_biUnion_of_mem (u := fun x ↦ (f x : Set R)) (Finset.mem_coe.2 his)⟩\n  generalize hn : s.card = n; intro h\n  induction' n with n ih generalizing a b s\n  · clear hp\n    rw [Finset.card_eq_zero] at hn\n    subst hn\n    rw [Finset.coe_empty, Set.biUnion_empty, Set.union_empty, subset_union] at h\n    simpa only [exists_prop, Finset.not_mem_empty, false_and, exists_false, or_false]\n  classical\n    replace hn : ∃ (i : ι) (t : Finset ι), i ∉ t ∧ insert i t = s ∧ t.card = n :=\n      Finset.card_eq_succ.1 hn\n    rcases hn with ⟨i, t, hit, rfl, hn⟩\n    replace hp : IsPrime (f i) ∧ ∀ x ∈ t, IsPrime (f x) := (t.forall_mem_insert _ _).1 hp\n    by_cases Ht : ∃ j ∈ t, f j ≤ f i\n    · obtain ⟨j, hjt, hfji⟩ : ∃ j ∈ t, f j ≤ f i := Ht\n      obtain ⟨u, hju, rfl⟩ : ∃ u, j ∉ u ∧ insert j u = t :=\n        ⟨t.erase j, t.not_mem_erase j, Finset.insert_erase hjt⟩\n      have hp' : ∀ k ∈ insert i u, IsPrime (f k) := by\n        rw [Finset.forall_mem_insert] at hp ⊢\n        exact ⟨hp.1, hp.2.2⟩\n      have hiu : i ∉ u := mt Finset.mem_insert_of_mem hit\n      have hn' : (insert i u).card = n := by\n        rwa [Finset.card_insert_of_not_mem] at hn ⊢\n        exacts [hiu, hju]\n      have h' : (I : Set R) ⊆ f a ∪ f b ∪ ⋃ k ∈ (↑(insert i u) : Set ι), f k := by\n        rw [Finset.coe_insert] at h ⊢\n        rw [Finset.coe_insert] at h\n        simp only [Set.biUnion_insert] at h ⊢\n        rw [← Set.union_assoc (f i : Set R),\n            Set.union_eq_self_of_subset_right hfji] at h\n        exact h\n      specialize ih hp' hn' h'\n      refine ih.imp id (Or.imp id (Exists.imp fun k => ?_))\n      exact And.imp (fun hk => Finset.insert_subset_insert i (Finset.subset_insert j u) hk) id\n    by_cases Ha : f a ≤ f i\n    · have h' : (I : Set R) ⊆ f i ∪ f b ∪ ⋃ j ∈ (↑t : Set ι), f j := by\n        rw [Finset.coe_insert, Set.biUnion_insert, ← Set.union_assoc,\n          Set.union_right_comm (f a : Set R),\n          Set.union_eq_self_of_subset_left Ha] at h\n        exact h\n      specialize ih hp.2 hn h'\n      right\n      rcases ih with (ih | ih | ⟨k, hkt, ih⟩)\n      · exact Or.inr ⟨i, Finset.mem_insert_self i t, ih⟩\n      · exact Or.inl ih\n      · exact Or.inr ⟨k, Finset.mem_insert_of_mem hkt, ih⟩\n    by_cases Hb : f b ≤ f i\n    · have h' : (I : Set R) ⊆ f a ∪ f i ∪ ⋃ j ∈ (↑t : Set ι), f j := by\n        rw [Finset.coe_insert, Set.biUnion_insert, ← Set.union_assoc,\n          Set.union_assoc (f a : Set R),\n          Set.union_eq_self_of_subset_left Hb] at h\n        exact h\n      specialize ih hp.2 hn h'\n      rcases ih with (ih | ih | ⟨k, hkt, ih⟩)\n      · exact Or.inl ih\n      · exact Or.inr (Or.inr ⟨i, Finset.mem_insert_self i t, ih⟩)\n      · exact Or.inr (Or.inr ⟨k, Finset.mem_insert_of_mem hkt, ih⟩)\n    by_cases Hi : I ≤ f i\n    · exact Or.inr (Or.inr ⟨i, Finset.mem_insert_self i t, Hi⟩)\n    have : ¬I ⊓ f a ⊓ f b ⊓ t.inf f ≤ f i := by\n      simp only [hp.1.inf_le, hp.1.inf_le', not_or]\n      exact ⟨⟨⟨Hi, Ha⟩, Hb⟩, Ht⟩\n    rcases Set.not_subset.1 this with ⟨r, ⟨⟨⟨hrI, hra⟩, hrb⟩, hr⟩, hri⟩\n    by_cases HI : (I : Set R) ⊆ f a ∪ f b ∪ ⋃ j ∈ (↑t : Set ι), f j\n    · specialize ih hp.2 hn HI\n      rcases ih with (ih | ih | ⟨k, hkt, ih⟩)\n      · left\n        exact ih\n      · right\n        left\n        exact ih\n      · right\n        right\n        exact ⟨k, Finset.mem_insert_of_mem hkt, ih⟩\n    exfalso\n    rcases Set.not_subset.1 HI with ⟨s, hsI, hs⟩\n    rw [Finset.coe_insert, Set.biUnion_insert] at h\n    have hsi : s ∈ f i := ((h hsI).resolve_left (mt Or.inl hs)).resolve_right (mt Or.inr hs)\n    rcases h (I.add_mem hrI hsI) with (⟨ha | hb⟩ | hi | ht)\n    · exact hs (Or.inl <| Or.inl <| add_sub_cancel_left r s ▸ (f a).sub_mem ha hra)\n    · exact hs (Or.inl <| Or.inr <| add_sub_cancel_left r s ▸ (f b).sub_mem hb hrb)\n    · exact hri (add_sub_cancel_right r s ▸ (f i).sub_mem hi hsi)\n    · rw [Set.mem_iUnion₂] at ht\n      rcases ht with ⟨j, hjt, hj⟩\n      simp only [Finset.inf_eq_iInf, SetLike.mem_coe, Submodule.mem_iInf] at hr\n      exact hs <| Or.inr <| Set.mem_biUnion hjt <|\n        add_sub_cancel_left r s ▸ (f j).sub_mem hj <| hr j hjt\n\n"}
{"name":"Ideal.subset_union_prime","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"ι : Type u_1\nR : Type u\ninst✝ : CommRing R\ns : Finset ι\nf : ι → Ideal R\na b : ι\nhp : ∀ (i : ι), Membership.mem s i → Ne i a → Ne i b → (f i).IsPrime\nI : Ideal R\n⊢ Iff (HasSubset.Subset (↑I) (Set.iUnion fun i => Set.iUnion fun h => ↑(f i))) (Exists fun i => And (Membership.mem s i) (LE.le I (f i)))","decl":"/-- Prime avoidance. Atiyah-Macdonald 1.11, Eisenbud 3.3, Matsumura Ex.1.6. -/\n@[stacks 00DS]\ntheorem subset_union_prime {R : Type u} [CommRing R] {s : Finset ι} {f : ι → Ideal R} (a b : ι)\n    (hp : ∀ i ∈ s, i ≠ a → i ≠ b → IsPrime (f i)) {I : Ideal R} :\n    ((I : Set R) ⊆ ⋃ i ∈ (↑s : Set ι), f i) ↔ ∃ i ∈ s, I ≤ f i :=\n  suffices ((I : Set R) ⊆ ⋃ i ∈ (↑s : Set ι), f i) → ∃ i, i ∈ s ∧ I ≤ f i by\n    have aux := fun h => (bex_def.2 <| this h)\n    simp_rw [exists_prop] at aux\n    refine ⟨aux, fun ⟨i, his, hi⟩ ↦ Set.Subset.trans hi ?_⟩\n    apply Set.subset_biUnion_of_mem (show i ∈ (↑s : Set ι) from his)\n  fun h : (I : Set R) ⊆ ⋃ i ∈ (↑s : Set ι), f i => by\n  classical\n    by_cases has : a ∈ s\n    · obtain ⟨t, hat, rfl⟩ : ∃ t, a ∉ t ∧ insert a t = s :=\n        ⟨s.erase a, Finset.not_mem_erase a s, Finset.insert_erase has⟩\n      by_cases hbt : b ∈ t\n      · obtain ⟨u, hbu, rfl⟩ : ∃ u, b ∉ u ∧ insert b u = t :=\n          ⟨t.erase b, Finset.not_mem_erase b t, Finset.insert_erase hbt⟩\n        have hp' : ∀ i ∈ u, IsPrime (f i) := by\n          intro i hiu\n          refine hp i (Finset.mem_insert_of_mem (Finset.mem_insert_of_mem hiu)) ?_ ?_ <;>\n              rintro rfl <;>\n            solve_by_elim only [Finset.mem_insert_of_mem, *]\n        rw [Finset.coe_insert, Finset.coe_insert, Set.biUnion_insert, Set.biUnion_insert, ←\n          Set.union_assoc, subset_union_prime' hp'] at h\n        rwa [Finset.exists_mem_insert, Finset.exists_mem_insert]\n      · have hp' : ∀ j ∈ t, IsPrime (f j) := by\n          intro j hj\n          refine hp j (Finset.mem_insert_of_mem hj) ?_ ?_ <;> rintro rfl <;>\n            solve_by_elim only [Finset.mem_insert_of_mem, *]\n        rw [Finset.coe_insert, Set.biUnion_insert, ← Set.union_self (f a : Set R),\n          subset_union_prime' hp', ← or_assoc, or_self_iff] at h\n        rwa [Finset.exists_mem_insert]\n    · by_cases hbs : b ∈ s\n      · obtain ⟨t, hbt, rfl⟩ : ∃ t, b ∉ t ∧ insert b t = s :=\n          ⟨s.erase b, Finset.not_mem_erase b s, Finset.insert_erase hbs⟩\n        have hp' : ∀ j ∈ t, IsPrime (f j) := by\n          intro j hj\n          refine hp j (Finset.mem_insert_of_mem hj) ?_ ?_ <;> rintro rfl <;>\n            solve_by_elim only [Finset.mem_insert_of_mem, *]\n        rw [Finset.coe_insert, Set.biUnion_insert, ← Set.union_self (f b : Set R),\n          subset_union_prime' hp', ← or_assoc, or_self_iff] at h\n        rwa [Finset.exists_mem_insert]\n      rcases s.eq_empty_or_nonempty with hse | hsne\n      · subst hse\n        rw [Finset.coe_empty, Set.biUnion_empty, Set.subset_empty_iff] at h\n        have : (I : Set R) ≠ ∅ := Set.Nonempty.ne_empty (Set.nonempty_of_mem I.zero_mem)\n        exact absurd h this\n      · cases' hsne with i his\n        obtain ⟨t, _, rfl⟩ : ∃ t, i ∉ t ∧ insert i t = s :=\n          ⟨s.erase i, Finset.not_mem_erase i s, Finset.insert_erase his⟩\n        have hp' : ∀ j ∈ t, IsPrime (f j) := by\n          intro j hj\n          refine hp j (Finset.mem_insert_of_mem hj) ?_ ?_ <;> rintro rfl <;>\n            solve_by_elim only [Finset.mem_insert_of_mem, *]\n        rw [Finset.coe_insert, Set.biUnion_insert, ← Set.union_self (f i : Set R),\n          subset_union_prime' hp', ← or_assoc, or_self_iff] at h\n        rwa [Finset.exists_mem_insert]\n\n"}
{"name":"Ideal.le_of_dvd","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI J : Ideal R\na✝ : Dvd.dvd I J\n⊢ LE.le J I","decl":"/-- If `I` divides `J`, then `I` contains `J`.\n\nIn a Dedekind domain, to divide and contain are equivalent, see `Ideal.dvd_iff_le`.\n-/\ntheorem le_of_dvd {I J : Ideal R} : I ∣ J → J ≤ I\n  | ⟨_, h⟩ => h.symm ▸ le_trans mul_le_inf inf_le_left\n\n"}
{"name":"Ideal.isUnit_iff","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI : Ideal R\n⊢ Iff (IsUnit I) (Eq I Top.top)","decl":"@[simp]\ntheorem isUnit_iff {I : Ideal R} : IsUnit I ↔ I = ⊤ :=\n  isUnit_iff_dvd_one.trans\n    ((@one_eq_top R _).symm ▸\n      ⟨fun h => eq_top_iff.mpr (Ideal.le_of_dvd h), fun h => ⟨⊤, by rw [mul_top, h]⟩⟩)\n\n"}
{"name":"Ideal.finsuppTotal_apply","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"ι : Type u_1\nM : Type u_2\ninst✝² : AddCommGroup M\nR : Type u_3\ninst✝¹ : CommRing R\ninst✝ : Module R M\nI : Ideal R\nv : ι → M\nf : Finsupp ι (Subtype fun x => Membership.mem I x)\n⊢ Eq ((Ideal.finsuppTotal ι M I v) f) (f.sum fun i x => HSMul.hSMul (↑x) (v i))","decl":"theorem finsuppTotal_apply (f : ι →₀ I) :\n    finsuppTotal ι M I v f = f.sum fun i x => (x : R) • v i := by\n  dsimp [finsuppTotal]\n  rw [Finsupp.linearCombination_apply, Finsupp.sum_mapRange_index]\n  exact fun _ => zero_smul _ _\n\n"}
{"name":"Ideal.finsuppTotal_apply_eq_of_fintype","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"ι : Type u_1\nM : Type u_2\ninst✝³ : AddCommGroup M\nR : Type u_3\ninst✝² : CommRing R\ninst✝¹ : Module R M\nI : Ideal R\nv : ι → M\ninst✝ : Fintype ι\nf : Finsupp ι (Subtype fun x => Membership.mem I x)\n⊢ Eq ((Ideal.finsuppTotal ι M I v) f) (Finset.univ.sum fun i => HSMul.hSMul (↑(f i)) (v i))","decl":"theorem finsuppTotal_apply_eq_of_fintype [Fintype ι] (f : ι →₀ I) :\n    finsuppTotal ι M I v f = ∑ i, (f i : R) • v i := by\n  rw [finsuppTotal_apply, Finsupp.sum_fintype]\n  exact fun _ => zero_smul _ _\n\n"}
{"name":"Ideal.range_finsuppTotal","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"ι : Type u_1\nM : Type u_2\ninst✝² : AddCommGroup M\nR : Type u_3\ninst✝¹ : CommRing R\ninst✝ : Module R M\nI : Ideal R\nv : ι → M\n⊢ Eq (LinearMap.range (Ideal.finsuppTotal ι M I v)) (HSMul.hSMul I (Submodule.span R (Set.range v)))","decl":"theorem range_finsuppTotal :\n    LinearMap.range (finsuppTotal ι M I v) = I • Submodule.span R (Set.range v) := by\n  ext\n  rw [Submodule.mem_ideal_smul_span_iff_exists_sum]\n  refine ⟨fun ⟨f, h⟩ => ⟨Finsupp.mapRange.linearMap I.subtype f, fun i => (f i).2, h⟩, ?_⟩\n  rintro ⟨a, ha, rfl⟩\n  classical\n    refine ⟨a.mapRange (fun r => if h : r ∈ I then ⟨r, h⟩ else 0)\n      (by simp only [Submodule.zero_mem, ↓reduceDIte]; rfl), ?_⟩\n    rw [finsuppTotal_apply, Finsupp.sum_mapRange_index]\n    · apply Finsupp.sum_congr\n      intro i _\n      rw [dif_pos (ha i)]\n    · exact fun _ => zero_smul _ _\n\n"}
{"name":"Finsupp.mem_ideal_span_range_iff_exists_finsupp","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"α : Type u_1\nR : Type u_2\ninst✝ : Semiring R\nx : R\nv : α → R\n⊢ Iff (Membership.mem (Ideal.span (Set.range v)) x) (Exists fun c => Eq (c.sum fun i a => HMul.hMul a (v i)) x)","decl":"theorem Finsupp.mem_ideal_span_range_iff_exists_finsupp {x : R} {v : α → R} :\n    x ∈ Ideal.span (Set.range v) ↔ ∃ c : α →₀ R, (c.sum fun i a => a * v i) = x :=\n  Finsupp.mem_span_range_iff_exists_finsupp\n\n"}
{"name":"mem_ideal_span_range_iff_exists_fun","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"α : Type u_1\nR : Type u_2\ninst✝¹ : Semiring R\ninst✝ : Fintype α\nx : R\nv : α → R\n⊢ Iff (Membership.mem (Ideal.span (Set.range v)) x) (Exists fun c => Eq (Finset.univ.sum fun i => HMul.hMul (c i) (v i)) x)","decl":"/-- An element `x` lies in the span of `v` iff it can be written as sum `∑ cᵢ • vᵢ = x`.\n-/\ntheorem mem_ideal_span_range_iff_exists_fun [Fintype α] {x : R} {v : α → R} :\n    x ∈ Ideal.span (Set.range v) ↔ ∃ c : α → R, ∑ i, c i * v i = x :=\n  mem_span_range_iff_exists_fun _\n\n"}
{"name":"Associates.mk_ne_zero'","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nr : R\n⊢ Iff (Ne (Associates.mk (Ideal.span (Singleton.singleton r))) 0) (Ne r 0)","decl":"theorem Associates.mk_ne_zero' {R : Type*} [CommSemiring R] {r : R} :\n    Associates.mk (Ideal.span {r} : Ideal R) ≠ 0 ↔ r ≠ 0 := by\n  rw [Associates.mk_ne_zero, Ideal.zero_eq_bot, Ne, Ideal.span_singleton_eq_bot]\n\n"}
{"name":"Ideal.span_singleton_nonZeroDivisors","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : NoZeroDivisors R\nr : R\n⊢ Iff (Membership.mem (nonZeroDivisors (Ideal R)) (Ideal.span (Singleton.singleton r))) (Membership.mem (nonZeroDivisors R) r)","decl":"open scoped nonZeroDivisors in\ntheorem Ideal.span_singleton_nonZeroDivisors {R : Type*} [CommSemiring R] [NoZeroDivisors R]\n    {r : R} : span {r} ∈ (Ideal R)⁰ ↔ r ∈ R⁰ := by\n  cases subsingleton_or_nontrivial R\n  · exact ⟨fun _ _ _ ↦ Subsingleton.eq_zero _, fun _ _ _ ↦ Subsingleton.eq_zero _⟩\n  · rw [mem_nonZeroDivisors_iff_ne_zero, mem_nonZeroDivisors_iff_ne_zero, ne_eq, zero_eq_bot,\n      span_singleton_eq_bot]\n\n"}
{"name":"Submodule.span_smul_eq","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\nM : Type v\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Set R\nN : Submodule R M\n⊢ Eq (HSMul.hSMul (Ideal.span s) N) (HSMul.hSMul s N)","decl":"lemma span_smul_eq\n    (s : Set R) (N : Submodule R M) :\n    Ideal.span s • N = s • N := by\n  rw [← coe_set_smul, coe_span_smul]\n\n"}
{"name":"Submodule.set_smul_top_eq_span","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝ : CommSemiring R\ns : Set R\n⊢ Eq (HSMul.hSMul s Top.top) (Ideal.span s)","decl":"@[simp]\ntheorem set_smul_top_eq_span (s : Set R) :\n    s • ⊤ = Ideal.span s :=\n  (span_smul_eq s ⊤).symm.trans (Ideal.span s).mul_top\n\n"}
{"name":"Submodule.coe_mapAlgHom_apply","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝⁴ : CommSemiring R\nA : Type u_1\nB : Type u_2\ninst✝³ : Semiring A\ninst✝² : Semiring B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nf : AlgHom R A B\np : Submodule R A\n⊢ Eq (↑((Submodule.mapAlgHom f) p)) (Set.image (fun a => f a) ↑p)","decl":"/-- `Submonoid.map` as an `AlgHom`, when applied to an `AlgHom`. -/\n@[simps!] def mapAlgHom (f : A →ₐ[R] B) : Submodule R A →ₐ[Ideal R] Submodule R B where\n  __ := mapHom f\n  commutes' I := (map_comp _ _ I).symm.trans (congr_arg (map · I) <| LinearMap.ext f.commutes)\n\n"}
{"name":"Submodule.coe_mapAlgEquiv_symm_apply","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝⁴ : CommSemiring R\nA : Type u_1\nB : Type u_2\ninst✝³ : Semiring A\ninst✝² : Semiring B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nf : AlgEquiv R A B\na : Submodule R B\n⊢ Eq (↑((Submodule.mapAlgEquiv f).symm a)) (Set.image (fun a => f.symm a) ↑a)","decl":"/-- `Submonoid.map` as an `AlgEquiv`, when applied to an `AlgEquiv`. -/\n-- TODO: when A, B noncommutative, still has `MulEquiv`.\n@[simps!] def mapAlgEquiv (f : A ≃ₐ[R] B) : Submodule R A ≃ₐ[Ideal R] Submodule R B where\n  __ := mapAlgHom f\n  invFun := mapAlgHom f.symm\n  left_inv I := (map_comp _ _ I).symm.trans <|\n    (congr_arg (map · I) <| LinearMap.ext (f.left_inv ·)).trans (map_id I)\n  right_inv I := (map_comp _ _ I).symm.trans <|\n    (congr_arg (map · I) <| LinearMap.ext (f.right_inv ·)).trans (map_id I)\n\n"}
{"name":"Submodule.coe_mapAlgEquiv_apply","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u\ninst✝⁴ : CommSemiring R\nA : Type u_1\nB : Type u_2\ninst✝³ : Semiring A\ninst✝² : Semiring B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nf : AlgEquiv R A B\na✝ : Submodule R A\n⊢ Eq (↑((Submodule.mapAlgEquiv f) a✝)) (Set.image (fun a => f a) ↑a✝)","decl":"/-- `Submonoid.map` as an `AlgEquiv`, when applied to an `AlgEquiv`. -/\n-- TODO: when A, B noncommutative, still has `MulEquiv`.\n@[simps!] def mapAlgEquiv (f : A ≃ₐ[R] B) : Submodule R A ≃ₐ[Ideal R] Submodule R B where\n  __ := mapAlgHom f\n  invFun := mapAlgHom f.symm\n  left_inv I := (map_comp _ _ I).symm.trans <|\n    (congr_arg (map · I) <| LinearMap.ext (f.left_inv ·)).trans (map_id I)\n  right_inv I := (map_comp _ _ I).symm.trans <|\n    (congr_arg (map · I) <| LinearMap.ext (f.right_inv ·)).trans (map_id I)\n\n"}
{"name":"instNonUnitalSubsemiringClassIdeal","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u_1\ninst✝ : Semiring R\n⊢ NonUnitalSubsemiringClass (Ideal R) R","decl":"instance {R} [Semiring R] : NonUnitalSubsemiringClass (Ideal R) R where\n  mul_mem _ hb := Ideal.mul_mem_left _ _ hb\n"}
{"name":"instNonUnitalSubringClassIdeal","module":"Mathlib.RingTheory.Ideal.Operations","initialProofState":"R : Type u_1\ninst✝ : Ring R\n⊢ NonUnitalSubringClass (Ideal R) R","decl":"instance {R} [Ring R] : NonUnitalSubringClass (Ideal R) R where\n"}
