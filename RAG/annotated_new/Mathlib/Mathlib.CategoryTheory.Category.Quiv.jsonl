{"name":"CategoryTheory.Quiv.forget_obj","module":"Mathlib.CategoryTheory.Category.Quiv","initialProofState":"C : CategoryTheory.Cat\n‚ä¢ Eq (CategoryTheory.Quiv.forget.obj C) (CategoryTheory.Quiv.of ‚ÜëC)","decl":"/-- The forgetful functor from categories to quivers. -/\n@[simps]\ndef forget : Cat.{v, u} ‚•§ Quiv.{v, u} where\n  obj C := Quiv.of C\n  map F := F.toPrefunctor\n\n"}
{"name":"CategoryTheory.Quiv.forget_map","module":"Mathlib.CategoryTheory.Category.Quiv","initialProofState":"X‚úù Y‚úù : CategoryTheory.Cat\nF : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (CategoryTheory.Quiv.forget.map F) F.toPrefunctor","decl":"/-- The forgetful functor from categories to quivers. -/\n@[simps]\ndef forget : Cat.{v, u} ‚•§ Quiv.{v, u} where\n  obj C := Quiv.of C\n  map F := F.toPrefunctor\n\n"}
{"name":"CategoryTheory.Quiv.id_eq_id","module":"Mathlib.CategoryTheory.Category.Quiv","initialProofState":"X : CategoryTheory.Quiv\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id X) (Prefunctor.id ‚ÜëX)","decl":"/-- The identity in the category of quivers equals the identity prefunctor.-/\ntheorem id_eq_id (X : Quiv) : ùüô X = ùü≠q X := rfl\n\n"}
{"name":"CategoryTheory.Quiv.comp_eq_comp","module":"Mathlib.CategoryTheory.Category.Quiv","initialProofState":"X Y Z : CategoryTheory.Quiv\nF : Quiver.Hom X Y\nG : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp F G) (Prefunctor.comp F G)","decl":"/-- Composition in the category of quivers equals prefunctor composition.-/\ntheorem comp_eq_comp {X Y Z : Quiv} (F : X ‚ü∂ Y) (G : Y ‚ü∂ Z) : F ‚â´ G = F ‚ãôq G := rfl\n\n"}
{"name":"CategoryTheory.Cat.free_map_map","module":"Mathlib.CategoryTheory.Category.Quiv","initialProofState":"X‚úù¬π Y‚úù¬π : CategoryTheory.Quiv\nF : Quiver.Hom X‚úù¬π Y‚úù¬π\nX‚úù Y‚úù : ‚Üë((fun V => CategoryTheory.Cat.of (CategoryTheory.Paths ‚ÜëV)) X‚úù¬π)\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Cat.free.map F).map f) (Prefunctor.mapPath F f)","decl":"/-- The functor sending each quiver to its path category. -/\n@[simps]\ndef free : Quiv.{v, u} ‚•§ Cat.{max u v, u} where\n  obj V := Cat.of (Paths V)\n  map F :=\n    { obj := fun X => F.obj X\n      map := fun f => F.mapPath f\n      map_comp := fun f g => F.mapPath_comp f g }\n  map_id V := by\n    change (show Paths V ‚•§ _ from _) = _\n    ext\n    ¬∑ rfl\n    ¬∑ exact eq_conj_eqToHom _\n  map_comp {U _ _} F G := by\n    change (show Paths U ‚•§ _ from _) = _\n    ext\n    ¬∑ rfl\n    ¬∑ exact eq_conj_eqToHom _\n\n"}
{"name":"CategoryTheory.Cat.free_map_obj","module":"Mathlib.CategoryTheory.Category.Quiv","initialProofState":"X‚úù Y‚úù : CategoryTheory.Quiv\nF : Quiver.Hom X‚úù Y‚úù\nX : ‚Üë((fun V => CategoryTheory.Cat.of (CategoryTheory.Paths ‚ÜëV)) X‚úù)\n‚ä¢ Eq ((CategoryTheory.Cat.free.map F).obj X) (F.obj X)","decl":"/-- The functor sending each quiver to its path category. -/\n@[simps]\ndef free : Quiv.{v, u} ‚•§ Cat.{max u v, u} where\n  obj V := Cat.of (Paths V)\n  map F :=\n    { obj := fun X => F.obj X\n      map := fun f => F.mapPath f\n      map_comp := fun f g => F.mapPath_comp f g }\n  map_id V := by\n    change (show Paths V ‚•§ _ from _) = _\n    ext\n    ¬∑ rfl\n    ¬∑ exact eq_conj_eqToHom _\n  map_comp {U _ _} F G := by\n    change (show Paths U ‚•§ _ from _) = _\n    ext\n    ¬∑ rfl\n    ¬∑ exact eq_conj_eqToHom _\n\n"}
{"name":"CategoryTheory.Cat.free_obj","module":"Mathlib.CategoryTheory.Category.Quiv","initialProofState":"V : CategoryTheory.Quiv\n‚ä¢ Eq (CategoryTheory.Cat.free.obj V) (CategoryTheory.Cat.of (CategoryTheory.Paths ‚ÜëV))","decl":"/-- The functor sending each quiver to its path category. -/\n@[simps]\ndef free : Quiv.{v, u} ‚•§ Cat.{max u v, u} where\n  obj V := Cat.of (Paths V)\n  map F :=\n    { obj := fun X => F.obj X\n      map := fun f => F.mapPath f\n      map_comp := fun f g => F.mapPath_comp f g }\n  map_id V := by\n    change (show Paths V ‚•§ _ from _) = _\n    ext\n    ¬∑ rfl\n    ¬∑ exact eq_conj_eqToHom _\n  map_comp {U _ _} F G := by\n    change (show Paths U ‚•§ _ from _) = _\n    ext\n    ¬∑ rfl\n    ¬∑ exact eq_conj_eqToHom _\n\n"}
{"name":"CategoryTheory.Quiv.equivOfIso_apply","module":"Mathlib.CategoryTheory.Category.Quiv","initialProofState":"V W : CategoryTheory.Quiv\ne : CategoryTheory.Iso V W\na‚úù : ‚ÜëV\n‚ä¢ Eq ((CategoryTheory.Quiv.equivOfIso e) a‚úù) (e.hom.obj a‚úù)","decl":"/-- An isomorphism of quivers defines an equivalence on carrier types. -/\n@[simps]\ndef equivOfIso : V ‚âÉ W where\n  toFun := e.hom.obj\n  invFun := e.inv.obj\n  left_inv := Prefunctor.congr_obj e.hom_inv_id\n  right_inv := Prefunctor.congr_obj e.inv_hom_id\n\n"}
{"name":"CategoryTheory.Quiv.equivOfIso_symm_apply","module":"Mathlib.CategoryTheory.Category.Quiv","initialProofState":"V W : CategoryTheory.Quiv\ne : CategoryTheory.Iso V W\na‚úù : ‚ÜëW\n‚ä¢ Eq ((CategoryTheory.Quiv.equivOfIso e).symm a‚úù) (e.inv.obj a‚úù)","decl":"/-- An isomorphism of quivers defines an equivalence on carrier types. -/\n@[simps]\ndef equivOfIso : V ‚âÉ W where\n  toFun := e.hom.obj\n  invFun := e.inv.obj\n  left_inv := Prefunctor.congr_obj e.hom_inv_id\n  right_inv := Prefunctor.congr_obj e.inv_hom_id\n\n"}
{"name":"CategoryTheory.Quiv.inv_obj_hom_obj_of_iso","module":"Mathlib.CategoryTheory.Category.Quiv","initialProofState":"V W : CategoryTheory.Quiv\ne : CategoryTheory.Iso V W\nX : ‚ÜëV\n‚ä¢ Eq (e.inv.obj (e.hom.obj X)) X","decl":"@[simp]\nlemma inv_obj_hom_obj_of_iso (X : V) : e.inv.obj (e.hom.obj X) = X := (equivOfIso e).left_inv X\n\n"}
{"name":"CategoryTheory.Quiv.hom_obj_inv_obj_of_iso","module":"Mathlib.CategoryTheory.Category.Quiv","initialProofState":"V W : CategoryTheory.Quiv\ne : CategoryTheory.Iso V W\nY : ‚ÜëW\n‚ä¢ Eq (e.hom.obj (e.inv.obj Y)) Y","decl":"@[simp]\nlemma hom_obj_inv_obj_of_iso (Y : W) : e.hom.obj (e.inv.obj Y) = Y := (equivOfIso e).right_inv Y\n\n"}
{"name":"CategoryTheory.Quiv.hom_map_inv_map_of_iso","module":"Mathlib.CategoryTheory.Category.Quiv","initialProofState":"V W : CategoryTheory.Quiv\ne : CategoryTheory.Iso V W\nX Y : ‚ÜëW\nf : Quiver.Hom X Y\n‚ä¢ Eq (e.hom.map (e.inv.map f)) (Quiver.homOfEq f ‚ãØ ‚ãØ)","decl":"lemma hom_map_inv_map_of_iso {V W : Quiv} (e : V ‚âÖ W) {X Y : W} (f : X ‚ü∂ Y) :\n    e.hom.map (e.inv.map f) = Quiver.homOfEq f (by simp) (by simp) := by\n  rw [‚Üê Prefunctor.comp_map]\n  exact (Prefunctor.congr_hom e.inv_hom_id.symm f).symm\n\n"}
{"name":"CategoryTheory.Quiv.inv_map_hom_map_of_iso","module":"Mathlib.CategoryTheory.Category.Quiv","initialProofState":"V W : CategoryTheory.Quiv\ne : CategoryTheory.Iso V W\nX Y : ‚ÜëV\nf : Quiver.Hom X Y\n‚ä¢ Eq (e.inv.map (e.hom.map f)) (Quiver.homOfEq f ‚ãØ ‚ãØ)","decl":"lemma inv_map_hom_map_of_iso {V W : Quiv} (e : V ‚âÖ W) {X Y : V} (f : X ‚ü∂ Y) :\n    e.inv.map (e.hom.map f) = Quiver.homOfEq f (by simp) (by simp) :=\n  hom_map_inv_map_of_iso e.symm f\n\n"}
{"name":"CategoryTheory.Quiv.homEquivOfIso_apply","module":"Mathlib.CategoryTheory.Category.Quiv","initialProofState":"V W : CategoryTheory.Quiv\ne : CategoryTheory.Iso V W\nX Y : ‚ÜëV\nf : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.Quiv.homEquivOfIso e) f) (e.hom.map f)","decl":"/-- An isomorphism of quivers defines an equivalence on hom types. -/\n@[simps]\ndef homEquivOfIso {V W : Quiv} (e : V ‚âÖ W) {X Y : V} :\n    (X ‚ü∂ Y) ‚âÉ (e.hom.obj X ‚ü∂ e.hom.obj Y) where\n  toFun f := e.hom.map f\n  invFun g := Quiver.homOfEq (e.inv.map g) (by simp) (by simp)\n  left_inv f := by simp [inv_map_hom_map_of_iso]\n  right_inv g := by simp [hom_map_inv_map_of_iso]\n\n"}
{"name":"CategoryTheory.Quiv.homEquivOfIso_symm_apply","module":"Mathlib.CategoryTheory.Category.Quiv","initialProofState":"V W : CategoryTheory.Quiv\ne : CategoryTheory.Iso V W\nX Y : ‚ÜëV\ng : Quiver.Hom (e.hom.obj X) (e.hom.obj Y)\n‚ä¢ Eq ((CategoryTheory.Quiv.homEquivOfIso e).symm g) (Quiver.homOfEq (e.inv.map g) ‚ãØ ‚ãØ)","decl":"/-- An isomorphism of quivers defines an equivalence on hom types. -/\n@[simps]\ndef homEquivOfIso {V W : Quiv} (e : V ‚âÖ W) {X Y : V} :\n    (X ‚ü∂ Y) ‚âÉ (e.hom.obj X ‚ü∂ e.hom.obj Y) where\n  toFun f := e.hom.map f\n  invFun g := Quiver.homOfEq (e.inv.map g) (by simp) (by simp)\n  left_inv f := by simp [inv_map_hom_map_of_iso]\n  right_inv g := by simp [hom_map_inv_map_of_iso]\n\n"}
{"name":"CategoryTheory.Quiv.homOfEq_map_homOfEq","module":"Mathlib.CategoryTheory.Category.Quiv","initialProofState":"V W : Type u\ninst‚úù¬π : Quiver V\ninst‚úù : Quiver W\ne : Equiv V W\nhe : (X Y : V) ‚Üí Equiv (Quiver.Hom X Y) (Quiver.Hom (e X) (e Y))\nX Y : V\nf : Quiver.Hom X Y\nX' Y' : V\nhX : Eq X X'\nhY : Eq Y Y'\nX'' Y'' : W\nhX' : Eq (e X') X''\nhY' : Eq (e Y') Y''\n‚ä¢ Eq (Quiver.homOfEq ((he X' Y') (Quiver.homOfEq f hX hY)) hX' hY') (Quiver.homOfEq ((he X Y) f) ‚ãØ ‚ãØ)","decl":"include he in\n@[simp]\nlemma homOfEq_map_homOfEq {X Y : V} (f : X ‚ü∂ Y) {X' Y' : V} (hX : X = X') (hY : Y = Y')\n    {X'' Y'' : W} (hX' : e X' = X'') (hY' : e Y' = Y'') :\n    Quiver.homOfEq (he _ _ (Quiver.homOfEq f hX hY)) hX' hY' =\n      Quiver.homOfEq (he _ _ f) (by rw [hX, hX']) (by rw [hY, hY']) := by\n  subst hX hY hX' hY'\n  rfl\n\n"}
{"name":"CategoryTheory.Quiv.lift_obj","module":"Mathlib.CategoryTheory.Category.Quiv","initialProofState":"V : Type u\ninst‚úù¬π : Quiver V\nC : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nF : Prefunctor V C\nX : CategoryTheory.Paths V\n‚ä¢ Eq ((CategoryTheory.Quiv.lift F).obj X) (F.obj X)","decl":"/-- Any prefunctor into a category lifts to a functor from the path category. -/\n@[simps]\ndef lift {V : Type u} [Quiver.{v + 1} V] {C : Type*} [Category C] (F : Prefunctor V C) :\n    Paths V ‚•§ C where\n  obj X := F.obj X\n  map f := composePath (F.mapPath f)\n\n-- We might construct `of_lift_iso_self : Paths.of ‚ãô lift F ‚âÖ F`\n-- (and then show that `lift F` is initial amongst such functors)\n-- but it would require lifting quite a bit of machinery to quivers!\n"}
{"name":"CategoryTheory.Quiv.lift_map","module":"Mathlib.CategoryTheory.Category.Quiv","initialProofState":"V : Type u\ninst‚úù¬π : Quiver V\nC : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nF : Prefunctor V C\nX‚úù Y‚úù : CategoryTheory.Paths V\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Quiv.lift F).map f) (CategoryTheory.composePath (F.mapPath f))","decl":"/-- Any prefunctor into a category lifts to a functor from the path category. -/\n@[simps]\ndef lift {V : Type u} [Quiver.{v + 1} V] {C : Type*} [Category C] (F : Prefunctor V C) :\n    Paths V ‚•§ C where\n  obj X := F.obj X\n  map f := composePath (F.mapPath f)\n\n-- We might construct `of_lift_iso_self : Paths.of ‚ãô lift F ‚âÖ F`\n-- (and then show that `lift F` is initial amongst such functors)\n-- but it would require lifting quite a bit of machinery to quivers!\n"}
