{"name":"LinearMap.fst_apply","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\nx : Prod M M₂\n⊢ Eq ((LinearMap.fst R M M₂) x) x.1","decl":"@[simp]\ntheorem fst_apply (x : M × M₂) : fst R M M₂ x = x.1 :=\n  rfl\n\n"}
{"name":"LinearMap.snd_apply","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\nx : Prod M M₂\n⊢ Eq ((LinearMap.snd R M M₂) x) x.2","decl":"@[simp]\ntheorem snd_apply (x : M × M₂) : snd R M M₂ x = x.2 :=\n  rfl\n\n"}
{"name":"LinearMap.coe_fst","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\n⊢ Eq (⇑(LinearMap.fst R M M₂)) Prod.fst","decl":"@[simp, norm_cast] lemma coe_fst : ⇑(fst R M M₂) = Prod.fst := rfl\n\n"}
{"name":"LinearMap.coe_snd","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\n⊢ Eq (⇑(LinearMap.snd R M M₂)) Prod.snd","decl":"@[simp, norm_cast] lemma coe_snd : ⇑(snd R M M₂) = Prod.snd := rfl\n\n"}
{"name":"LinearMap.fst_surjective","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\n⊢ Function.Surjective ⇑(LinearMap.fst R M M₂)","decl":"theorem fst_surjective : Function.Surjective (fst R M M₂) := fun x => ⟨(x, 0), rfl⟩\n\n"}
{"name":"LinearMap.snd_surjective","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\n⊢ Function.Surjective ⇑(LinearMap.snd R M M₂)","decl":"theorem snd_surjective : Function.Surjective (snd R M M₂) := fun x => ⟨(0, x), rfl⟩\n\n"}
{"name":"LinearMap.prod_apply","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\nM₃ : Type y\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid M₃\ninst✝² : Module R M\ninst✝¹ : Module R M₂\ninst✝ : Module R M₃\nf : LinearMap (RingHom.id R) M M₂\ng : LinearMap (RingHom.id R) M M₃\ni : M\n⊢ Eq ((f.prod g) i) (Pi.prod (⇑f) (⇑g) i)","decl":"/-- The prod of two linear maps is a linear map. -/\n@[simps]\ndef prod (f : M →ₗ[R] M₂) (g : M →ₗ[R] M₃) : M →ₗ[R] M₂ × M₃ where\n  toFun := Pi.prod f g\n  map_add' x y := by simp only [Pi.prod, Prod.mk_add_mk, map_add]\n  map_smul' c x := by simp only [Pi.prod, Prod.smul_mk, map_smul, RingHom.id_apply]\n\n"}
{"name":"LinearMap.coe_prod","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\nM₃ : Type y\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid M₃\ninst✝² : Module R M\ninst✝¹ : Module R M₂\ninst✝ : Module R M₃\nf : LinearMap (RingHom.id R) M M₂\ng : LinearMap (RingHom.id R) M M₃\n⊢ Eq (⇑(f.prod g)) (Pi.prod ⇑f ⇑g)","decl":"theorem coe_prod (f : M →ₗ[R] M₂) (g : M →ₗ[R] M₃) : ⇑(f.prod g) = Pi.prod f g :=\n  rfl\n\n"}
{"name":"LinearMap.fst_prod","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\nM₃ : Type y\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid M₃\ninst✝² : Module R M\ninst✝¹ : Module R M₂\ninst✝ : Module R M₃\nf : LinearMap (RingHom.id R) M M₂\ng : LinearMap (RingHom.id R) M M₃\n⊢ Eq ((LinearMap.fst R M₂ M₃).comp (f.prod g)) f","decl":"@[simp]\ntheorem fst_prod (f : M →ₗ[R] M₂) (g : M →ₗ[R] M₃) : (fst R M₂ M₃).comp (prod f g) = f := rfl\n\n"}
{"name":"LinearMap.snd_prod","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\nM₃ : Type y\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid M₃\ninst✝² : Module R M\ninst✝¹ : Module R M₂\ninst✝ : Module R M₃\nf : LinearMap (RingHom.id R) M M₂\ng : LinearMap (RingHom.id R) M M₃\n⊢ Eq ((LinearMap.snd R M₂ M₃).comp (f.prod g)) g","decl":"@[simp]\ntheorem snd_prod (f : M →ₗ[R] M₂) (g : M →ₗ[R] M₃) : (snd R M₂ M₃).comp (prod f g) = g := rfl\n\n"}
{"name":"LinearMap.pair_fst_snd","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\n⊢ Eq ((LinearMap.fst R M M₂).prod (LinearMap.snd R M M₂)) LinearMap.id","decl":"@[simp]\ntheorem pair_fst_snd : prod (fst R M M₂) (snd R M M₂) = LinearMap.id := rfl\n\n"}
{"name":"LinearMap.prod_comp","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\nM₃ : Type y\nM₄ : Type z\ninst✝⁸ : Semiring R\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid M₂\ninst✝⁵ : AddCommMonoid M₃\ninst✝⁴ : AddCommMonoid M₄\ninst✝³ : Module R M\ninst✝² : Module R M₂\ninst✝¹ : Module R M₃\ninst✝ : Module R M₄\nf : LinearMap (RingHom.id R) M₂ M₃\ng : LinearMap (RingHom.id R) M₂ M₄\nh : LinearMap (RingHom.id R) M M₂\n⊢ Eq ((f.prod g).comp h) ((f.comp h).prod (g.comp h))","decl":"theorem prod_comp (f : M₂ →ₗ[R] M₃) (g : M₂ →ₗ[R] M₄)\n    (h : M →ₗ[R] M₂) : (f.prod g).comp h = (f.comp h).prod (g.comp h) :=\n  rfl\n\n"}
{"name":"LinearMap.prodEquiv_apply","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\nM₃ : Type y\nS : Type u_3\ninst✝¹¹ : Semiring R\ninst✝¹⁰ : Semiring S\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : AddCommMonoid M₂\ninst✝⁷ : AddCommMonoid M₃\ninst✝⁶ : Module R M\ninst✝⁵ : Module R M₂\ninst✝⁴ : Module R M₃\ninst✝³ : Module S M₂\ninst✝² : Module S M₃\ninst✝¹ : SMulCommClass R S M₂\ninst✝ : SMulCommClass R S M₃\nf : Prod (LinearMap (RingHom.id R) M M₂) (LinearMap (RingHom.id R) M M₃)\n⊢ Eq ((LinearMap.prodEquiv S) f) (f.1.prod f.2)","decl":"/-- Taking the product of two maps with the same domain is equivalent to taking the product of\ntheir codomains.\n\nSee note [bundled maps over different rings] for why separate `R` and `S` semirings are used. -/\n@[simps]\ndef prodEquiv [Module S M₂] [Module S M₃] [SMulCommClass R S M₂] [SMulCommClass R S M₃] :\n    ((M →ₗ[R] M₂) × (M →ₗ[R] M₃)) ≃ₗ[S] M →ₗ[R] M₂ × M₃ where\n  toFun f := f.1.prod f.2\n  invFun f := ((fst _ _ _).comp f, (snd _ _ _).comp f)\n  left_inv f := by ext <;> rfl\n  right_inv f := by ext <;> rfl\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl\n\n"}
{"name":"LinearMap.prodEquiv_symm_apply","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\nM₃ : Type y\nS : Type u_3\ninst✝¹¹ : Semiring R\ninst✝¹⁰ : Semiring S\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : AddCommMonoid M₂\ninst✝⁷ : AddCommMonoid M₃\ninst✝⁶ : Module R M\ninst✝⁵ : Module R M₂\ninst✝⁴ : Module R M₃\ninst✝³ : Module S M₂\ninst✝² : Module S M₃\ninst✝¹ : SMulCommClass R S M₂\ninst✝ : SMulCommClass R S M₃\nf : LinearMap (RingHom.id R) M (Prod M₂ M₃)\n⊢ Eq ((LinearMap.prodEquiv S).symm f) { fst := (LinearMap.fst R M₂ M₃).comp f, snd := (LinearMap.snd R M₂ M₃).comp f }","decl":"/-- Taking the product of two maps with the same domain is equivalent to taking the product of\ntheir codomains.\n\nSee note [bundled maps over different rings] for why separate `R` and `S` semirings are used. -/\n@[simps]\ndef prodEquiv [Module S M₂] [Module S M₃] [SMulCommClass R S M₂] [SMulCommClass R S M₃] :\n    ((M →ₗ[R] M₂) × (M →ₗ[R] M₃)) ≃ₗ[S] M →ₗ[R] M₂ × M₃ where\n  toFun f := f.1.prod f.2\n  invFun f := ((fst _ _ _).comp f, (snd _ _ _).comp f)\n  left_inv f := by ext <;> rfl\n  right_inv f := by ext <;> rfl\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl\n\n"}
{"name":"LinearMap.range_inl","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\n⊢ Eq (LinearMap.range (LinearMap.inl R M M₂)) (LinearMap.ker (LinearMap.snd R M M₂))","decl":"theorem range_inl : range (inl R M M₂) = ker (snd R M M₂) := by\n  ext x\n  simp only [mem_ker, mem_range]\n  constructor\n  · rintro ⟨y, rfl⟩\n    rfl\n  · intro h\n    exact ⟨x.fst, Prod.ext rfl h.symm⟩\n\n"}
{"name":"LinearMap.ker_snd","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\n⊢ Eq (LinearMap.ker (LinearMap.snd R M M₂)) (LinearMap.range (LinearMap.inl R M M₂))","decl":"theorem ker_snd : ker (snd R M M₂) = range (inl R M M₂) :=\n  Eq.symm <| range_inl R M M₂\n\n"}
{"name":"LinearMap.range_inr","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\n⊢ Eq (LinearMap.range (LinearMap.inr R M M₂)) (LinearMap.ker (LinearMap.fst R M M₂))","decl":"theorem range_inr : range (inr R M M₂) = ker (fst R M M₂) := by\n  ext x\n  simp only [mem_ker, mem_range]\n  constructor\n  · rintro ⟨y, rfl⟩\n    rfl\n  · intro h\n    exact ⟨x.snd, Prod.ext h.symm rfl⟩\n\n"}
{"name":"LinearMap.ker_fst","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\n⊢ Eq (LinearMap.ker (LinearMap.fst R M M₂)) (LinearMap.range (LinearMap.inr R M M₂))","decl":"theorem ker_fst : ker (fst R M M₂) = range (inr R M M₂) :=\n  Eq.symm <| range_inr R M M₂\n\n"}
{"name":"LinearMap.fst_comp_inl","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\n⊢ Eq ((LinearMap.fst R M M₂).comp (LinearMap.inl R M M₂)) LinearMap.id","decl":"@[simp] theorem fst_comp_inl : fst R M M₂ ∘ₗ inl R M M₂ = id := rfl\n\n"}
{"name":"LinearMap.snd_comp_inl","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\n⊢ Eq ((LinearMap.snd R M M₂).comp (LinearMap.inl R M M₂)) 0","decl":"@[simp] theorem snd_comp_inl : snd R M M₂ ∘ₗ inl R M M₂ = 0 := rfl\n\n"}
{"name":"LinearMap.fst_comp_inr","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\n⊢ Eq ((LinearMap.fst R M M₂).comp (LinearMap.inr R M M₂)) 0","decl":"@[simp] theorem fst_comp_inr : fst R M M₂ ∘ₗ inr R M M₂ = 0 := rfl\n\n"}
{"name":"LinearMap.snd_comp_inr","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\n⊢ Eq ((LinearMap.snd R M M₂).comp (LinearMap.inr R M M₂)) LinearMap.id","decl":"@[simp] theorem snd_comp_inr : snd R M M₂ ∘ₗ inr R M M₂ = id := rfl\n\n"}
{"name":"LinearMap.coe_inl","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\n⊢ Eq ⇑(LinearMap.inl R M M₂) fun x => { fst := x, snd := 0 }","decl":"@[simp]\ntheorem coe_inl : (inl R M M₂ : M → M × M₂) = fun x => (x, 0) :=\n  rfl\n\n"}
{"name":"LinearMap.inl_apply","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\nx : M\n⊢ Eq ((LinearMap.inl R M M₂) x) { fst := x, snd := 0 }","decl":"theorem inl_apply (x : M) : inl R M M₂ x = (x, 0) :=\n  rfl\n\n"}
{"name":"LinearMap.coe_inr","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\n⊢ Eq (⇑(LinearMap.inr R M M₂)) (Prod.mk 0)","decl":"@[simp]\ntheorem coe_inr : (inr R M M₂ : M₂ → M × M₂) = Prod.mk 0 :=\n  rfl\n\n"}
{"name":"LinearMap.inr_apply","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\nx : M₂\n⊢ Eq ((LinearMap.inr R M M₂) x) { fst := 0, snd := x }","decl":"theorem inr_apply (x : M₂) : inr R M M₂ x = (0, x) :=\n  rfl\n\n"}
{"name":"LinearMap.inl_eq_prod","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\n⊢ Eq (LinearMap.inl R M M₂) (LinearMap.id.prod 0)","decl":"theorem inl_eq_prod : inl R M M₂ = prod LinearMap.id 0 :=\n  rfl\n\n"}
{"name":"LinearMap.inr_eq_prod","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\n⊢ Eq (LinearMap.inr R M M₂) (LinearMap.prod 0 LinearMap.id)","decl":"theorem inr_eq_prod : inr R M M₂ = prod 0 LinearMap.id :=\n  rfl\n\n"}
{"name":"LinearMap.inl_injective","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\n⊢ Function.Injective ⇑(LinearMap.inl R M M₂)","decl":"theorem inl_injective : Function.Injective (inl R M M₂) := fun _ => by simp\n\n"}
{"name":"LinearMap.inr_injective","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\n⊢ Function.Injective ⇑(LinearMap.inr R M M₂)","decl":"theorem inr_injective : Function.Injective (inr R M M₂) := fun _ => by simp\n\n"}
{"name":"LinearMap.coprod_apply","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\nM₃ : Type y\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid M₃\ninst✝² : Module R M\ninst✝¹ : Module R M₂\ninst✝ : Module R M₃\nf : LinearMap (RingHom.id R) M M₃\ng : LinearMap (RingHom.id R) M₂ M₃\nx : Prod M M₂\n⊢ Eq ((f.coprod g) x) (HAdd.hAdd (f x.1) (g x.2))","decl":"@[simp]\ntheorem coprod_apply (f : M →ₗ[R] M₃) (g : M₂ →ₗ[R] M₃) (x : M × M₂) :\n    coprod f g x = f x.1 + g x.2 :=\n  rfl\n\n"}
{"name":"LinearMap.coprod_inl","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\nM₃ : Type y\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid M₃\ninst✝² : Module R M\ninst✝¹ : Module R M₂\ninst✝ : Module R M₃\nf : LinearMap (RingHom.id R) M M₃\ng : LinearMap (RingHom.id R) M₂ M₃\n⊢ Eq ((f.coprod g).comp (LinearMap.inl R M M₂)) f","decl":"@[simp]\ntheorem coprod_inl (f : M →ₗ[R] M₃) (g : M₂ →ₗ[R] M₃) : (coprod f g).comp (inl R M M₂) = f := by\n  ext; simp only [map_zero, add_zero, coprod_apply, inl_apply, comp_apply]\n\n"}
{"name":"LinearMap.coprod_inr","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\nM₃ : Type y\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid M₃\ninst✝² : Module R M\ninst✝¹ : Module R M₂\ninst✝ : Module R M₃\nf : LinearMap (RingHom.id R) M M₃\ng : LinearMap (RingHom.id R) M₂ M₃\n⊢ Eq ((f.coprod g).comp (LinearMap.inr R M M₂)) g","decl":"@[simp]\ntheorem coprod_inr (f : M →ₗ[R] M₃) (g : M₂ →ₗ[R] M₃) : (coprod f g).comp (inr R M M₂) = g := by\n  ext; simp only [map_zero, coprod_apply, inr_apply, zero_add, comp_apply]\n\n"}
{"name":"LinearMap.coprod_inl_inr","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\n⊢ Eq ((LinearMap.inl R M M₂).coprod (LinearMap.inr R M M₂)) LinearMap.id","decl":"@[simp]\ntheorem coprod_inl_inr : coprod (inl R M M₂) (inr R M M₂) = LinearMap.id := by\n  ext <;>\n    simp only [Prod.mk_add_mk, add_zero, id_apply, coprod_apply, inl_apply, inr_apply, zero_add]\n\n"}
{"name":"LinearMap.coprod_zero_left","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\nM₃ : Type y\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid M₃\ninst✝² : Module R M\ninst✝¹ : Module R M₂\ninst✝ : Module R M₃\ng : LinearMap (RingHom.id R) M₂ M₃\n⊢ Eq (LinearMap.coprod 0 g) (g.comp (LinearMap.snd R M M₂))","decl":"theorem coprod_zero_left (g : M₂ →ₗ[R] M₃) : (0 : M →ₗ[R] M₃).coprod g = g.comp (snd R M M₂) :=\n  zero_add _\n\n"}
{"name":"LinearMap.coprod_zero_right","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\nM₃ : Type y\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid M₃\ninst✝² : Module R M\ninst✝¹ : Module R M₂\ninst✝ : Module R M₃\nf : LinearMap (RingHom.id R) M M₃\n⊢ Eq (f.coprod 0) (f.comp (LinearMap.fst R M M₂))","decl":"theorem coprod_zero_right (f : M →ₗ[R] M₃) : f.coprod (0 : M₂ →ₗ[R] M₃) = f.comp (fst R M M₂) :=\n  add_zero _\n\n"}
{"name":"LinearMap.comp_coprod","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\nM₃ : Type y\nM₄ : Type z\ninst✝⁸ : Semiring R\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid M₂\ninst✝⁵ : AddCommMonoid M₃\ninst✝⁴ : AddCommMonoid M₄\ninst✝³ : Module R M\ninst✝² : Module R M₂\ninst✝¹ : Module R M₃\ninst✝ : Module R M₄\nf : LinearMap (RingHom.id R) M₃ M₄\ng₁ : LinearMap (RingHom.id R) M M₃\ng₂ : LinearMap (RingHom.id R) M₂ M₃\n⊢ Eq (f.comp (g₁.coprod g₂)) ((f.comp g₁).coprod (f.comp g₂))","decl":"theorem comp_coprod (f : M₃ →ₗ[R] M₄) (g₁ : M →ₗ[R] M₃) (g₂ : M₂ →ₗ[R] M₃) :\n    f.comp (g₁.coprod g₂) = (f.comp g₁).coprod (f.comp g₂) :=\n  ext fun x => f.map_add (g₁ x.1) (g₂ x.2)\n\n"}
{"name":"LinearMap.fst_eq_coprod","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\n⊢ Eq (LinearMap.fst R M M₂) (LinearMap.id.coprod 0)","decl":"theorem fst_eq_coprod : fst R M M₂ = coprod LinearMap.id 0 := by ext; simp\n\n"}
{"name":"LinearMap.snd_eq_coprod","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\n⊢ Eq (LinearMap.snd R M M₂) (LinearMap.coprod 0 LinearMap.id)","decl":"theorem snd_eq_coprod : snd R M M₂ = coprod 0 LinearMap.id := by ext; simp\n\n"}
{"name":"LinearMap.coprod_comp_prod","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\nM₃ : Type y\nM₄ : Type z\ninst✝⁸ : Semiring R\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid M₂\ninst✝⁵ : AddCommMonoid M₃\ninst✝⁴ : AddCommMonoid M₄\ninst✝³ : Module R M\ninst✝² : Module R M₂\ninst✝¹ : Module R M₃\ninst✝ : Module R M₄\nf : LinearMap (RingHom.id R) M₂ M₄\ng : LinearMap (RingHom.id R) M₃ M₄\nf' : LinearMap (RingHom.id R) M M₂\ng' : LinearMap (RingHom.id R) M M₃\n⊢ Eq ((f.coprod g).comp (f'.prod g')) (HAdd.hAdd (f.comp f') (g.comp g'))","decl":"@[simp]\ntheorem coprod_comp_prod (f : M₂ →ₗ[R] M₄) (g : M₃ →ₗ[R] M₄) (f' : M →ₗ[R] M₂) (g' : M →ₗ[R] M₃) :\n    (f.coprod g).comp (f'.prod g') = f.comp f' + g.comp g' :=\n  rfl\n\n"}
{"name":"LinearMap.coprod_map_prod","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\nM₃ : Type y\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid M₃\ninst✝² : Module R M\ninst✝¹ : Module R M₂\ninst✝ : Module R M₃\nf : LinearMap (RingHom.id R) M M₃\ng : LinearMap (RingHom.id R) M₂ M₃\nS : Submodule R M\nS' : Submodule R M₂\n⊢ Eq (Submodule.map (f.coprod g) (S.prod S')) (Max.max (Submodule.map f S) (Submodule.map g S'))","decl":"@[simp]\ntheorem coprod_map_prod (f : M →ₗ[R] M₃) (g : M₂ →ₗ[R] M₃) (S : Submodule R M)\n    (S' : Submodule R M₂) : (Submodule.prod S S').map (LinearMap.coprod f g) = S.map f ⊔ S'.map g :=\n  SetLike.coe_injective <| by\n    simp only [LinearMap.coprod_apply, Submodule.coe_sup, Submodule.map_coe]\n    rw [← Set.image2_add, Set.image2_image_left, Set.image2_image_right]\n    exact Set.image_prod fun m m₂ => f m + g m₂\n\n"}
{"name":"LinearMap.coprodEquiv_symm_apply","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\nM₃ : Type y\nS : Type u_3\ninst✝⁹ : Semiring R\ninst✝⁸ : Semiring S\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid M₂\ninst✝⁵ : AddCommMonoid M₃\ninst✝⁴ : Module R M\ninst✝³ : Module R M₂\ninst✝² : Module R M₃\ninst✝¹ : Module S M₃\ninst✝ : SMulCommClass R S M₃\nf : LinearMap (RingHom.id R) (Prod M M₂) M₃\n⊢ Eq ((LinearMap.coprodEquiv S).symm f) { fst := f.comp (LinearMap.inl R M M₂), snd := f.comp (LinearMap.inr R M M₂) }","decl":"/-- Taking the product of two maps with the same codomain is equivalent to taking the product of\ntheir domains.\n\nSee note [bundled maps over different rings] for why separate `R` and `S` semirings are used. -/\n@[simps]\ndef coprodEquiv [Module S M₃] [SMulCommClass R S M₃] :\n    ((M →ₗ[R] M₃) × (M₂ →ₗ[R] M₃)) ≃ₗ[S] M × M₂ →ₗ[R] M₃ where\n  toFun f := f.1.coprod f.2\n  invFun f := (f.comp (inl _ _ _), f.comp (inr _ _ _))\n  left_inv f := by simp only [coprod_inl, coprod_inr]\n  right_inv f := by simp only [← comp_coprod, comp_id, coprod_inl_inr]\n  map_add' a b := by\n    ext\n    simp only [Prod.snd_add, add_apply, coprod_apply, Prod.fst_add, add_add_add_comm]\n  map_smul' r a := by\n    dsimp\n    ext\n    simp only [smul_add, smul_apply, Prod.smul_snd, Prod.smul_fst, coprod_apply]\n\n"}
{"name":"LinearMap.coprodEquiv_apply","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\nM₃ : Type y\nS : Type u_3\ninst✝⁹ : Semiring R\ninst✝⁸ : Semiring S\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid M₂\ninst✝⁵ : AddCommMonoid M₃\ninst✝⁴ : Module R M\ninst✝³ : Module R M₂\ninst✝² : Module R M₃\ninst✝¹ : Module S M₃\ninst✝ : SMulCommClass R S M₃\nf : Prod (LinearMap (RingHom.id R) M M₃) (LinearMap (RingHom.id R) M₂ M₃)\n⊢ Eq ((LinearMap.coprodEquiv S) f) (f.1.coprod f.2)","decl":"/-- Taking the product of two maps with the same codomain is equivalent to taking the product of\ntheir domains.\n\nSee note [bundled maps over different rings] for why separate `R` and `S` semirings are used. -/\n@[simps]\ndef coprodEquiv [Module S M₃] [SMulCommClass R S M₃] :\n    ((M →ₗ[R] M₃) × (M₂ →ₗ[R] M₃)) ≃ₗ[S] M × M₂ →ₗ[R] M₃ where\n  toFun f := f.1.coprod f.2\n  invFun f := (f.comp (inl _ _ _), f.comp (inr _ _ _))\n  left_inv f := by simp only [coprod_inl, coprod_inr]\n  right_inv f := by simp only [← comp_coprod, comp_id, coprod_inl_inr]\n  map_add' a b := by\n    ext\n    simp only [Prod.snd_add, add_apply, coprod_apply, Prod.fst_add, add_add_add_comm]\n  map_smul' r a := by\n    dsimp\n    ext\n    simp only [smul_add, smul_apply, Prod.smul_snd, Prod.smul_fst, coprod_apply]\n\n"}
{"name":"LinearMap.prod_ext_iff","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\nM₃ : Type y\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid M₃\ninst✝² : Module R M\ninst✝¹ : Module R M₂\ninst✝ : Module R M₃\nf g : LinearMap (RingHom.id R) (Prod M M₂) M₃\n⊢ Iff (Eq f g) (And (Eq (f.comp (LinearMap.inl R M M₂)) (g.comp (LinearMap.inl R M M₂))) (Eq (f.comp (LinearMap.inr R M M₂)) (g.comp (LinearMap.inr R M M₂))))","decl":"theorem prod_ext_iff {f g : M × M₂ →ₗ[R] M₃} :\n    f = g ↔ f.comp (inl _ _ _) = g.comp (inl _ _ _) ∧ f.comp (inr _ _ _) = g.comp (inr _ _ _) :=\n  (coprodEquiv ℕ).symm.injective.eq_iff.symm.trans Prod.ext_iff\n\n"}
{"name":"LinearMap.prod_ext","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\nM₃ : Type y\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid M₃\ninst✝² : Module R M\ninst✝¹ : Module R M₂\ninst✝ : Module R M₃\nf g : LinearMap (RingHom.id R) (Prod M M₂) M₃\nhl : Eq (f.comp (LinearMap.inl R M M₂)) (g.comp (LinearMap.inl R M M₂))\nhr : Eq (f.comp (LinearMap.inr R M M₂)) (g.comp (LinearMap.inr R M M₂))\n⊢ Eq f g","decl":"/--\nSplit equality of linear maps from a product into linear maps over each component, to allow `ext`\nto apply lemmas specific to `M →ₗ M₃` and `M₂ →ₗ M₃`.\n\nSee note [partially-applied ext lemmas]. -/\n@[ext 1100]\ntheorem prod_ext {f g : M × M₂ →ₗ[R] M₃} (hl : f.comp (inl _ _ _) = g.comp (inl _ _ _))\n    (hr : f.comp (inr _ _ _) = g.comp (inr _ _ _)) : f = g :=\n  prod_ext_iff.2 ⟨hl, hr⟩\n\n"}
{"name":"LinearMap.coe_prodMap","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\nM₃ : Type y\nM₄ : Type z\ninst✝⁸ : Semiring R\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid M₂\ninst✝⁵ : AddCommMonoid M₃\ninst✝⁴ : AddCommMonoid M₄\ninst✝³ : Module R M\ninst✝² : Module R M₂\ninst✝¹ : Module R M₃\ninst✝ : Module R M₄\nf : LinearMap (RingHom.id R) M M₃\ng : LinearMap (RingHom.id R) M₂ M₄\n⊢ Eq (⇑(f.prodMap g)) (Prod.map ⇑f ⇑g)","decl":"theorem coe_prodMap (f : M →ₗ[R] M₃) (g : M₂ →ₗ[R] M₄) : ⇑(f.prodMap g) = Prod.map f g :=\n  rfl\n\n"}
{"name":"LinearMap.prodMap_apply","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\nM₃ : Type y\nM₄ : Type z\ninst✝⁸ : Semiring R\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid M₂\ninst✝⁵ : AddCommMonoid M₃\ninst✝⁴ : AddCommMonoid M₄\ninst✝³ : Module R M\ninst✝² : Module R M₂\ninst✝¹ : Module R M₃\ninst✝ : Module R M₄\nf : LinearMap (RingHom.id R) M M₃\ng : LinearMap (RingHom.id R) M₂ M₄\nx : Prod M M₂\n⊢ Eq ((f.prodMap g) x) { fst := f x.1, snd := g x.2 }","decl":"@[simp]\ntheorem prodMap_apply (f : M →ₗ[R] M₃) (g : M₂ →ₗ[R] M₄) (x) : f.prodMap g x = (f x.1, g x.2) :=\n  rfl\n\n"}
{"name":"LinearMap.prodMap_comap_prod","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\nM₃ : Type y\nM₄ : Type z\ninst✝⁸ : Semiring R\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid M₂\ninst✝⁵ : AddCommMonoid M₃\ninst✝⁴ : AddCommMonoid M₄\ninst✝³ : Module R M\ninst✝² : Module R M₂\ninst✝¹ : Module R M₃\ninst✝ : Module R M₄\nf : LinearMap (RingHom.id R) M M₂\ng : LinearMap (RingHom.id R) M₃ M₄\nS : Submodule R M₂\nS' : Submodule R M₄\n⊢ Eq (Submodule.comap (f.prodMap g) (S.prod S')) ((Submodule.comap f S).prod (Submodule.comap g S'))","decl":"theorem prodMap_comap_prod (f : M →ₗ[R] M₂) (g : M₃ →ₗ[R] M₄) (S : Submodule R M₂)\n    (S' : Submodule R M₄) :\n    (Submodule.prod S S').comap (LinearMap.prodMap f g) = (S.comap f).prod (S'.comap g) :=\n  SetLike.coe_injective <| Set.preimage_prod_map_prod f g _ _\n\n"}
{"name":"LinearMap.ker_prodMap","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\nM₃ : Type y\nM₄ : Type z\ninst✝⁸ : Semiring R\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid M₂\ninst✝⁵ : AddCommMonoid M₃\ninst✝⁴ : AddCommMonoid M₄\ninst✝³ : Module R M\ninst✝² : Module R M₂\ninst✝¹ : Module R M₃\ninst✝ : Module R M₄\nf : LinearMap (RingHom.id R) M M₂\ng : LinearMap (RingHom.id R) M₃ M₄\n⊢ Eq (LinearMap.ker (f.prodMap g)) ((LinearMap.ker f).prod (LinearMap.ker g))","decl":"theorem ker_prodMap (f : M →ₗ[R] M₂) (g : M₃ →ₗ[R] M₄) :\n    ker (LinearMap.prodMap f g) = Submodule.prod (ker f) (ker g) := by\n  dsimp only [ker]\n  rw [← prodMap_comap_prod, Submodule.prod_bot]\n\n"}
{"name":"LinearMap.prodMap_id","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\n⊢ Eq (LinearMap.id.prodMap LinearMap.id) LinearMap.id","decl":"@[simp]\ntheorem prodMap_id : (id : M →ₗ[R] M).prodMap (id : M₂ →ₗ[R] M₂) = id :=\n  rfl\n\n"}
{"name":"LinearMap.prodMap_one","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\n⊢ Eq (LinearMap.prodMap 1 1) 1","decl":"@[simp]\ntheorem prodMap_one : (1 : M →ₗ[R] M).prodMap (1 : M₂ →ₗ[R] M₂) = 1 :=\n  rfl\n\n"}
{"name":"LinearMap.prodMap_comp","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\nM₃ : Type y\nM₄ : Type z\nM₅ : Type u_1\nM₆ : Type u_2\ninst✝¹² : Semiring R\ninst✝¹¹ : AddCommMonoid M\ninst✝¹⁰ : AddCommMonoid M₂\ninst✝⁹ : AddCommMonoid M₃\ninst✝⁸ : AddCommMonoid M₄\ninst✝⁷ : AddCommMonoid M₅\ninst✝⁶ : AddCommMonoid M₆\ninst✝⁵ : Module R M\ninst✝⁴ : Module R M₂\ninst✝³ : Module R M₃\ninst✝² : Module R M₄\ninst✝¹ : Module R M₅\ninst✝ : Module R M₆\nf₁₂ : LinearMap (RingHom.id R) M M₂\nf₂₃ : LinearMap (RingHom.id R) M₂ M₃\ng₁₂ : LinearMap (RingHom.id R) M₄ M₅\ng₂₃ : LinearMap (RingHom.id R) M₅ M₆\n⊢ Eq ((f₂₃.prodMap g₂₃).comp (f₁₂.prodMap g₁₂)) ((f₂₃.comp f₁₂).prodMap (g₂₃.comp g₁₂))","decl":"theorem prodMap_comp (f₁₂ : M →ₗ[R] M₂) (f₂₃ : M₂ →ₗ[R] M₃) (g₁₂ : M₄ →ₗ[R] M₅)\n    (g₂₃ : M₅ →ₗ[R] M₆) :\n    f₂₃.prodMap g₂₃ ∘ₗ f₁₂.prodMap g₁₂ = (f₂₃ ∘ₗ f₁₂).prodMap (g₂₃ ∘ₗ g₁₂) :=\n  rfl\n\n"}
{"name":"LinearMap.prodMap_mul","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\nf₁₂ f₂₃ : LinearMap (RingHom.id R) M M\ng₁₂ g₂₃ : LinearMap (RingHom.id R) M₂ M₂\n⊢ Eq (HMul.hMul (f₂₃.prodMap g₂₃) (f₁₂.prodMap g₁₂)) ((HMul.hMul f₂₃ f₁₂).prodMap (HMul.hMul g₂₃ g₁₂))","decl":"theorem prodMap_mul (f₁₂ : M →ₗ[R] M) (f₂₃ : M →ₗ[R] M) (g₁₂ : M₂ →ₗ[R] M₂) (g₂₃ : M₂ →ₗ[R] M₂) :\n    f₂₃.prodMap g₂₃ * f₁₂.prodMap g₁₂ = (f₂₃ * f₁₂).prodMap (g₂₃ * g₁₂) :=\n  rfl\n\n"}
{"name":"LinearMap.prodMap_add","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\nM₃ : Type y\nM₄ : Type z\ninst✝⁸ : Semiring R\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid M₂\ninst✝⁵ : AddCommMonoid M₃\ninst✝⁴ : AddCommMonoid M₄\ninst✝³ : Module R M\ninst✝² : Module R M₂\ninst✝¹ : Module R M₃\ninst✝ : Module R M₄\nf₁ f₂ : LinearMap (RingHom.id R) M M₃\ng₁ g₂ : LinearMap (RingHom.id R) M₂ M₄\n⊢ Eq ((HAdd.hAdd f₁ f₂).prodMap (HAdd.hAdd g₁ g₂)) (HAdd.hAdd (f₁.prodMap g₁) (f₂.prodMap g₂))","decl":"theorem prodMap_add (f₁ : M →ₗ[R] M₃) (f₂ : M →ₗ[R] M₃) (g₁ : M₂ →ₗ[R] M₄) (g₂ : M₂ →ₗ[R] M₄) :\n    (f₁ + f₂).prodMap (g₁ + g₂) = f₁.prodMap g₁ + f₂.prodMap g₂ :=\n  rfl\n\n"}
{"name":"LinearMap.prodMap_zero","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\nM₃ : Type y\nM₄ : Type z\ninst✝⁸ : Semiring R\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid M₂\ninst✝⁵ : AddCommMonoid M₃\ninst✝⁴ : AddCommMonoid M₄\ninst✝³ : Module R M\ninst✝² : Module R M₂\ninst✝¹ : Module R M₃\ninst✝ : Module R M₄\n⊢ Eq (LinearMap.prodMap 0 0) 0","decl":"@[simp]\ntheorem prodMap_zero : (0 : M →ₗ[R] M₂).prodMap (0 : M₃ →ₗ[R] M₄) = 0 :=\n  rfl\n\n"}
{"name":"LinearMap.prodMap_smul","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\nM₃ : Type y\nM₄ : Type z\nS : Type u_3\ninst✝¹³ : Semiring R\ninst✝¹² : Semiring S\ninst✝¹¹ : AddCommMonoid M\ninst✝¹⁰ : AddCommMonoid M₂\ninst✝⁹ : AddCommMonoid M₃\ninst✝⁸ : AddCommMonoid M₄\ninst✝⁷ : Module R M\ninst✝⁶ : Module R M₂\ninst✝⁵ : Module R M₃\ninst✝⁴ : Module R M₄\ninst✝³ : Module S M₃\ninst✝² : Module S M₄\ninst✝¹ : SMulCommClass R S M₃\ninst✝ : SMulCommClass R S M₄\ns : S\nf : LinearMap (RingHom.id R) M M₃\ng : LinearMap (RingHom.id R) M₂ M₄\n⊢ Eq ((HSMul.hSMul s f).prodMap (HSMul.hSMul s g)) (HSMul.hSMul s (f.prodMap g))","decl":"@[simp]\ntheorem prodMap_smul [Module S M₃] [Module S M₄] [SMulCommClass R S M₃] [SMulCommClass R S M₄]\n    (s : S) (f : M →ₗ[R] M₃) (g : M₂ →ₗ[R] M₄) : prodMap (s • f) (s • g) = s • prodMap f g :=\n  rfl\n\n"}
{"name":"LinearMap.prodMapLinear_apply","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\nM₃ : Type y\nM₄ : Type z\nS : Type u_3\ninst✝¹³ : Semiring R\ninst✝¹² : Semiring S\ninst✝¹¹ : AddCommMonoid M\ninst✝¹⁰ : AddCommMonoid M₂\ninst✝⁹ : AddCommMonoid M₃\ninst✝⁸ : AddCommMonoid M₄\ninst✝⁷ : Module R M\ninst✝⁶ : Module R M₂\ninst✝⁵ : Module R M₃\ninst✝⁴ : Module R M₄\ninst✝³ : Module S M₃\ninst✝² : Module S M₄\ninst✝¹ : SMulCommClass R S M₃\ninst✝ : SMulCommClass R S M₄\nf : Prod (LinearMap (RingHom.id R) M M₃) (LinearMap (RingHom.id R) M₂ M₄)\n⊢ Eq ((LinearMap.prodMapLinear R M M₂ M₃ M₄ S) f) (f.1.prodMap f.2)","decl":"/-- `LinearMap.prodMap` as a `LinearMap` -/\n@[simps]\ndef prodMapLinear [Module S M₃] [Module S M₄] [SMulCommClass R S M₃] [SMulCommClass R S M₄] :\n    (M →ₗ[R] M₃) × (M₂ →ₗ[R] M₄) →ₗ[S] M × M₂ →ₗ[R] M₃ × M₄ where\n  toFun f := prodMap f.1 f.2\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl\n\n"}
{"name":"LinearMap.prodMapRingHom_apply","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\nf : Prod (LinearMap (RingHom.id R) M M) (LinearMap (RingHom.id R) M₂ M₂)\n⊢ Eq ((LinearMap.prodMapRingHom R M M₂) f) (f.1.prodMap f.2)","decl":"/-- `LinearMap.prodMap` as a `RingHom` -/\n@[simps]\ndef prodMapRingHom : (M →ₗ[R] M) × (M₂ →ₗ[R] M₂) →+* M × M₂ →ₗ[R] M × M₂ where\n  toFun f := prodMap f.1 f.2\n  map_one' := prodMap_one\n  map_zero' := rfl\n  map_add' _ _ := rfl\n  map_mul' _ _ := rfl\n\n"}
{"name":"LinearMap.inl_map_mul","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\ninst✝⁴ : Semiring R\nA : Type u_4\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : Module R A\nB : Type u_5\ninst✝¹ : NonUnitalNonAssocSemiring B\ninst✝ : Module R B\na₁ a₂ : A\n⊢ Eq ((LinearMap.inl R A B) (HMul.hMul a₁ a₂)) (HMul.hMul ((LinearMap.inl R A B) a₁) ((LinearMap.inl R A B) a₂))","decl":"theorem inl_map_mul (a₁ a₂ : A) :\n    LinearMap.inl R A B (a₁ * a₂) = LinearMap.inl R A B a₁ * LinearMap.inl R A B a₂ :=\n  Prod.ext rfl (by simp)\n\n"}
{"name":"LinearMap.inr_map_mul","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\ninst✝⁴ : Semiring R\nA : Type u_4\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : Module R A\nB : Type u_5\ninst✝¹ : NonUnitalNonAssocSemiring B\ninst✝ : Module R B\nb₁ b₂ : B\n⊢ Eq ((LinearMap.inr R A B) (HMul.hMul b₁ b₂)) (HMul.hMul ((LinearMap.inr R A B) b₁) ((LinearMap.inr R A B) b₂))","decl":"theorem inr_map_mul (b₁ b₂ : B) :\n    LinearMap.inr R A B (b₁ * b₂) = LinearMap.inr R A B b₁ * LinearMap.inr R A B b₂ :=\n  Prod.ext (by simp) rfl\n\n"}
{"name":"LinearMap.prodMapAlgHom_apply_apply","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\nf : Prod (LinearMap (RingHom.id R) M M) (LinearMap (RingHom.id R) M₂ M₂)\ni : Prod M M₂\n⊢ Eq (((LinearMap.prodMapAlgHom R M M₂) f) i) { fst := f.1 i.1, snd := f.2 i.2 }","decl":"/-- `LinearMap.prodMap` as an `AlgHom` -/\n@[simps!]\ndef prodMapAlgHom : Module.End R M × Module.End R M₂ →ₐ[R] Module.End R (M × M₂) :=\n  { prodMapRingHom R M M₂ with commutes' := fun _ => rfl }\n\n"}
{"name":"LinearMap.range_coprod","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\nM₃ : Type y\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid M₃\ninst✝² : Module R M\ninst✝¹ : Module R M₂\ninst✝ : Module R M₃\nf : LinearMap (RingHom.id R) M M₃\ng : LinearMap (RingHom.id R) M₂ M₃\n⊢ Eq (LinearMap.range (f.coprod g)) (Max.max (LinearMap.range f) (LinearMap.range g))","decl":"theorem range_coprod (f : M →ₗ[R] M₃) (g : M₂ →ₗ[R] M₃) : range (f.coprod g) = range f ⊔ range g :=\n  Submodule.ext fun x => by simp [mem_sup]\n\n"}
{"name":"LinearMap.isCompl_range_inl_inr","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\n⊢ IsCompl (LinearMap.range (LinearMap.inl R M M₂)) (LinearMap.range (LinearMap.inr R M M₂))","decl":"theorem isCompl_range_inl_inr : IsCompl (range <| inl R M M₂) (range <| inr R M M₂) := by\n  constructor\n  · rw [disjoint_def]\n    rintro ⟨_, _⟩ ⟨x, hx⟩ ⟨y, hy⟩\n    simp only [Prod.ext_iff, inl_apply, inr_apply, mem_bot] at hx hy ⊢\n    exact ⟨hy.1.symm, hx.2.symm⟩\n  · rw [codisjoint_iff_le_sup]\n    rintro ⟨x, y⟩ -\n    simp only [mem_sup, mem_range, exists_prop]\n    refine ⟨(x, 0), ⟨x, rfl⟩, (0, y), ⟨y, rfl⟩, ?_⟩\n    simp\n\n"}
{"name":"LinearMap.sup_range_inl_inr","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\n⊢ Eq (Max.max (LinearMap.range (LinearMap.inl R M M₂)) (LinearMap.range (LinearMap.inr R M M₂))) Top.top","decl":"theorem sup_range_inl_inr : (range <| inl R M M₂) ⊔ (range <| inr R M M₂) = ⊤ :=\n  IsCompl.sup_eq_top isCompl_range_inl_inr\n\n"}
{"name":"LinearMap.disjoint_inl_inr","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\n⊢ Disjoint (LinearMap.range (LinearMap.inl R M M₂)) (LinearMap.range (LinearMap.inr R M M₂))","decl":"theorem disjoint_inl_inr : Disjoint (range <| inl R M M₂) (range <| inr R M M₂) := by\n  simp +contextual [disjoint_def, @eq_comm M 0, @eq_comm M₂ 0]\n\n"}
{"name":"LinearMap.map_coprod_prod","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\nM₃ : Type y\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid M₃\ninst✝² : Module R M\ninst✝¹ : Module R M₂\ninst✝ : Module R M₃\nf : LinearMap (RingHom.id R) M M₃\ng : LinearMap (RingHom.id R) M₂ M₃\np : Submodule R M\nq : Submodule R M₂\n⊢ Eq (Submodule.map (f.coprod g) (p.prod q)) (Max.max (Submodule.map f p) (Submodule.map g q))","decl":"theorem map_coprod_prod (f : M →ₗ[R] M₃) (g : M₂ →ₗ[R] M₃) (p : Submodule R M)\n    (q : Submodule R M₂) : map (coprod f g) (p.prod q) = map f p ⊔ map g q := by\n  refine le_antisymm ?_ (sup_le (map_le_iff_le_comap.2 ?_) (map_le_iff_le_comap.2 ?_))\n  · rw [SetLike.le_def]\n    rintro _ ⟨x, ⟨h₁, h₂⟩, rfl⟩\n    exact mem_sup.2 ⟨_, ⟨_, h₁, rfl⟩, _, ⟨_, h₂, rfl⟩, rfl⟩\n  · exact fun x hx => ⟨(x, 0), by simp [hx]⟩\n  · exact fun x hx => ⟨(0, x), by simp [hx]⟩\n\n"}
{"name":"LinearMap.comap_prod_prod","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\nM₃ : Type y\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid M₃\ninst✝² : Module R M\ninst✝¹ : Module R M₂\ninst✝ : Module R M₃\nf : LinearMap (RingHom.id R) M M₂\ng : LinearMap (RingHom.id R) M M₃\np : Submodule R M₂\nq : Submodule R M₃\n⊢ Eq (Submodule.comap (f.prod g) (p.prod q)) (Min.min (Submodule.comap f p) (Submodule.comap g q))","decl":"theorem comap_prod_prod (f : M →ₗ[R] M₂) (g : M →ₗ[R] M₃) (p : Submodule R M₂)\n    (q : Submodule R M₃) : comap (prod f g) (p.prod q) = comap f p ⊓ comap g q :=\n  Submodule.ext fun _x => Iff.rfl\n\n"}
{"name":"LinearMap.prod_eq_inf_comap","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\np : Submodule R M\nq : Submodule R M₂\n⊢ Eq (p.prod q) (Min.min (Submodule.comap (LinearMap.fst R M M₂) p) (Submodule.comap (LinearMap.snd R M M₂) q))","decl":"theorem prod_eq_inf_comap (p : Submodule R M) (q : Submodule R M₂) :\n    p.prod q = p.comap (LinearMap.fst R M M₂) ⊓ q.comap (LinearMap.snd R M M₂) :=\n  Submodule.ext fun _x => Iff.rfl\n\n"}
{"name":"LinearMap.prod_eq_sup_map","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\np : Submodule R M\nq : Submodule R M₂\n⊢ Eq (p.prod q) (Max.max (Submodule.map (LinearMap.inl R M M₂) p) (Submodule.map (LinearMap.inr R M M₂) q))","decl":"theorem prod_eq_sup_map (p : Submodule R M) (q : Submodule R M₂) :\n    p.prod q = p.map (LinearMap.inl R M M₂) ⊔ q.map (LinearMap.inr R M M₂) := by\n  rw [← map_coprod_prod, coprod_inl_inr, map_id]\n\n"}
{"name":"LinearMap.span_inl_union_inr","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\ns : Set M\nt : Set M₂\n⊢ Eq (Submodule.span R (Union.union (Set.image (⇑(LinearMap.inl R M M₂)) s) (Set.image (⇑(LinearMap.inr R M M₂)) t))) ((Submodule.span R s).prod (Submodule.span R t))","decl":"theorem span_inl_union_inr {s : Set M} {t : Set M₂} :\n    span R (inl R M M₂ '' s ∪ inr R M M₂ '' t) = (span R s).prod (span R t) := by\n  rw [span_union, prod_eq_sup_map, ← span_image, ← span_image]\n\n"}
{"name":"LinearMap.ker_prod","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\nM₃ : Type y\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid M₃\ninst✝² : Module R M\ninst✝¹ : Module R M₂\ninst✝ : Module R M₃\nf : LinearMap (RingHom.id R) M M₂\ng : LinearMap (RingHom.id R) M M₃\n⊢ Eq (LinearMap.ker (f.prod g)) (Min.min (LinearMap.ker f) (LinearMap.ker g))","decl":"@[simp]\ntheorem ker_prod (f : M →ₗ[R] M₂) (g : M →ₗ[R] M₃) : ker (prod f g) = ker f ⊓ ker g := by\n  rw [ker, ← prod_bot, comap_prod_prod]; rfl\n\n"}
{"name":"LinearMap.range_prod_le","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\nM₃ : Type y\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid M₃\ninst✝² : Module R M\ninst✝¹ : Module R M₂\ninst✝ : Module R M₃\nf : LinearMap (RingHom.id R) M M₂\ng : LinearMap (RingHom.id R) M M₃\n⊢ LE.le (LinearMap.range (f.prod g)) ((LinearMap.range f).prod (LinearMap.range g))","decl":"theorem range_prod_le (f : M →ₗ[R] M₂) (g : M →ₗ[R] M₃) :\n    range (prod f g) ≤ (range f).prod (range g) := by\n  simp only [SetLike.le_def, prod_apply, mem_range, SetLike.mem_coe, mem_prod, exists_imp]\n  rintro _ x rfl\n  exact ⟨⟨x, rfl⟩, ⟨x, rfl⟩⟩\n\n"}
{"name":"LinearMap.ker_prod_ker_le_ker_coprod","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\nM₂ : Type u_3\ninst✝³ : AddCommMonoid M₂\ninst✝² : Module R M₂\nM₃ : Type u_4\ninst✝¹ : AddCommMonoid M₃\ninst✝ : Module R M₃\nf : LinearMap (RingHom.id R) M M₃\ng : LinearMap (RingHom.id R) M₂ M₃\n⊢ LE.le ((LinearMap.ker f).prod (LinearMap.ker g)) (LinearMap.ker (f.coprod g))","decl":"theorem ker_prod_ker_le_ker_coprod {M₂ : Type*} [AddCommMonoid M₂] [Module R M₂] {M₃ : Type*}\n    [AddCommMonoid M₃] [Module R M₃] (f : M →ₗ[R] M₃) (g : M₂ →ₗ[R] M₃) :\n    (ker f).prod (ker g) ≤ ker (f.coprod g) := by\n  rintro ⟨y, z⟩\n  simp +contextual\n\n"}
{"name":"LinearMap.ker_coprod_of_disjoint_range","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\nM₂ : Type u_3\ninst✝³ : AddCommGroup M₂\ninst✝² : Module R M₂\nM₃ : Type u_4\ninst✝¹ : AddCommGroup M₃\ninst✝ : Module R M₃\nf : LinearMap (RingHom.id R) M M₃\ng : LinearMap (RingHom.id R) M₂ M₃\nhd : Disjoint (LinearMap.range f) (LinearMap.range g)\n⊢ Eq (LinearMap.ker (f.coprod g)) ((LinearMap.ker f).prod (LinearMap.ker g))","decl":"theorem ker_coprod_of_disjoint_range {M₂ : Type*} [AddCommGroup M₂] [Module R M₂] {M₃ : Type*}\n    [AddCommGroup M₃] [Module R M₃] (f : M →ₗ[R] M₃) (g : M₂ →ₗ[R] M₃)\n    (hd : Disjoint (range f) (range g)) : ker (f.coprod g) = (ker f).prod (ker g) := by\n  apply le_antisymm _ (ker_prod_ker_le_ker_coprod f g)\n  rintro ⟨y, z⟩ h\n  simp only [mem_ker, mem_prod, coprod_apply] at h ⊢\n  have : f y ∈ (range f) ⊓ (range g) := by\n    simp only [true_and, mem_range, mem_inf, exists_apply_eq_apply]\n    use -z\n    rwa [eq_comm, map_neg, ← sub_eq_zero, sub_neg_eq_add]\n  rw [hd.eq_bot, mem_bot] at this\n  rw [this] at h\n  simpa [this] using h\n\n"}
{"name":"Submodule.sup_eq_range","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np q : Submodule R M\n⊢ Eq (Max.max p q) (LinearMap.range (p.subtype.coprod q.subtype))","decl":"theorem sup_eq_range (p q : Submodule R M) : p ⊔ q = range (p.subtype.coprod q.subtype) :=\n  Submodule.ext fun x => by simp [Submodule.mem_sup, SetLike.exists]\n\n"}
{"name":"Submodule.map_inl","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\np : Submodule R M\n⊢ Eq (Submodule.map (LinearMap.inl R M M₂) p) (p.prod Bot.bot)","decl":"@[simp]\ntheorem map_inl : p.map (inl R M M₂) = prod p ⊥ := by\n  ext ⟨x, y⟩\n  simp only [and_left_comm, eq_comm, mem_map, Prod.mk.inj_iff, inl_apply, mem_bot, exists_eq_left',\n    mem_prod]\n\n"}
{"name":"Submodule.map_inr","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\nq : Submodule R M₂\n⊢ Eq (Submodule.map (LinearMap.inr R M M₂) q) (Bot.bot.prod q)","decl":"@[simp]\ntheorem map_inr : q.map (inr R M M₂) = prod ⊥ q := by\n  ext ⟨x, y⟩; simp [and_left_comm, eq_comm, and_comm]\n\n"}
{"name":"Submodule.comap_fst","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\np : Submodule R M\n⊢ Eq (Submodule.comap (LinearMap.fst R M M₂) p) (p.prod Top.top)","decl":"@[simp]\ntheorem comap_fst : p.comap (fst R M M₂) = prod p ⊤ := by ext ⟨x, y⟩; simp\n\n"}
{"name":"Submodule.comap_snd","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\nq : Submodule R M₂\n⊢ Eq (Submodule.comap (LinearMap.snd R M M₂) q) (Top.top.prod q)","decl":"@[simp]\ntheorem comap_snd : q.comap (snd R M M₂) = prod ⊤ q := by ext ⟨x, y⟩; simp\n\n"}
{"name":"Submodule.prod_comap_inl","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\np : Submodule R M\nq : Submodule R M₂\n⊢ Eq (Submodule.comap (LinearMap.inl R M M₂) (p.prod q)) p","decl":"@[simp]\ntheorem prod_comap_inl : (prod p q).comap (inl R M M₂) = p := by ext; simp\n\n"}
{"name":"Submodule.prod_comap_inr","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\np : Submodule R M\nq : Submodule R M₂\n⊢ Eq (Submodule.comap (LinearMap.inr R M M₂) (p.prod q)) q","decl":"@[simp]\ntheorem prod_comap_inr : (prod p q).comap (inr R M M₂) = q := by ext; simp\n\n"}
{"name":"Submodule.prod_map_fst","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\np : Submodule R M\nq : Submodule R M₂\n⊢ Eq (Submodule.map (LinearMap.fst R M M₂) (p.prod q)) p","decl":"@[simp]\ntheorem prod_map_fst : (prod p q).map (fst R M M₂) = p := by\n  ext x; simp [(⟨0, zero_mem _⟩ : ∃ x, x ∈ q)]\n\n"}
{"name":"Submodule.prod_map_snd","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\np : Submodule R M\nq : Submodule R M₂\n⊢ Eq (Submodule.map (LinearMap.snd R M M₂) (p.prod q)) q","decl":"@[simp]\ntheorem prod_map_snd : (prod p q).map (snd R M M₂) = q := by\n  ext x; simp [(⟨0, zero_mem _⟩ : ∃ x, x ∈ p)]\n\n"}
{"name":"Submodule.ker_inl","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\n⊢ Eq (LinearMap.ker (LinearMap.inl R M M₂)) Bot.bot","decl":"@[simp]\ntheorem ker_inl : ker (inl R M M₂) = ⊥ := by rw [ker, ← prod_bot, prod_comap_inl]\n\n"}
{"name":"Submodule.ker_inr","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\n⊢ Eq (LinearMap.ker (LinearMap.inr R M M₂)) Bot.bot","decl":"@[simp]\ntheorem ker_inr : ker (inr R M M₂) = ⊥ := by rw [ker, ← prod_bot, prod_comap_inr]\n\n"}
{"name":"Submodule.range_fst","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\n⊢ Eq (LinearMap.range (LinearMap.fst R M M₂)) Top.top","decl":"@[simp]\ntheorem range_fst : range (fst R M M₂) = ⊤ := by rw [range_eq_map, ← prod_top, prod_map_fst]\n\n"}
{"name":"Submodule.range_snd","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\n⊢ Eq (LinearMap.range (LinearMap.snd R M M₂)) Top.top","decl":"@[simp]\ntheorem range_snd : range (snd R M M₂) = ⊤ := by rw [range_eq_map, ← prod_top, prod_map_snd]\n\n"}
{"name":"Submodule.fstEquiv_apply","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\nx : Subtype fun x => Membership.mem (Submodule.fst R M M₂) x\n⊢ Eq ((Submodule.fstEquiv R M M₂) x) (↑x).1","decl":"/-- `M` as a submodule of `M × N` is isomorphic to `M`. -/\n@[simps]\ndef fstEquiv : Submodule.fst R M M₂ ≃ₗ[R] M where\n  -- Porting note: proofs were `tidy` or `simp`\n  toFun x := x.1.1\n  invFun m := ⟨⟨m, 0⟩, by simp only [fst, comap_bot, mem_ker, snd_apply]⟩\n  map_add' := by simp only [coe_add, Prod.fst_add, implies_true]\n  map_smul' := by simp only [SetLike.val_smul, Prod.smul_fst, RingHom.id_apply, Subtype.forall,\n    implies_true]\n  left_inv := by\n    rintro ⟨⟨x, y⟩, hy⟩\n    simp only [fst, comap_bot, mem_ker, snd_apply] at hy\n    simpa only [Subtype.mk.injEq, Prod.mk.injEq, true_and] using hy.symm\n  right_inv := by rintro x; rfl\n\n"}
{"name":"Submodule.fstEquiv_symm_apply_coe","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\nm : M\n⊢ Eq ↑((Submodule.fstEquiv R M M₂).symm m) { fst := m, snd := 0 }","decl":"/-- `M` as a submodule of `M × N` is isomorphic to `M`. -/\n@[simps]\ndef fstEquiv : Submodule.fst R M M₂ ≃ₗ[R] M where\n  -- Porting note: proofs were `tidy` or `simp`\n  toFun x := x.1.1\n  invFun m := ⟨⟨m, 0⟩, by simp only [fst, comap_bot, mem_ker, snd_apply]⟩\n  map_add' := by simp only [coe_add, Prod.fst_add, implies_true]\n  map_smul' := by simp only [SetLike.val_smul, Prod.smul_fst, RingHom.id_apply, Subtype.forall,\n    implies_true]\n  left_inv := by\n    rintro ⟨⟨x, y⟩, hy⟩\n    simp only [fst, comap_bot, mem_ker, snd_apply] at hy\n    simpa only [Subtype.mk.injEq, Prod.mk.injEq, true_and] using hy.symm\n  right_inv := by rintro x; rfl\n\n"}
{"name":"Submodule.fst_map_fst","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\n⊢ Eq (Submodule.map (LinearMap.fst R M M₂) (Submodule.fst R M M₂)) Top.top","decl":"theorem fst_map_fst : (Submodule.fst R M M₂).map (LinearMap.fst R M M₂) = ⊤ := by\n  -- Porting note (https://github.com/leanprover-community/mathlib4/issues/10936): was `tidy`\n  rw [eq_top_iff]; rintro x -\n  simp only [fst, comap_bot, mem_map, mem_ker, snd_apply, fst_apply,\n    Prod.exists, exists_eq_left, exists_eq]\n\n"}
{"name":"Submodule.fst_map_snd","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\n⊢ Eq (Submodule.map (LinearMap.snd R M M₂) (Submodule.fst R M M₂)) Bot.bot","decl":"theorem fst_map_snd : (Submodule.fst R M M₂).map (LinearMap.snd R M M₂) = ⊥ := by\n  -- Porting note (https://github.com/leanprover-community/mathlib4/issues/10936): was `tidy`\n  rw [eq_bot_iff]; intro x\n  simp only [fst, comap_bot, mem_map, mem_ker, snd_apply, eq_comm, Prod.exists, exists_eq_left,\n    exists_const, mem_bot, imp_self]\n\n"}
{"name":"Submodule.sndEquiv_symm_apply_coe","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\nn : M₂\n⊢ Eq ↑((Submodule.sndEquiv R M M₂).symm n) { fst := 0, snd := n }","decl":"/-- `N` as a submodule of `M × N` is isomorphic to `N`. -/\n@[simps]\ndef sndEquiv : Submodule.snd R M M₂ ≃ₗ[R] M₂ where\n  -- Porting note: proofs were `tidy` or `simp`\n  toFun x := x.1.2\n  invFun n := ⟨⟨0, n⟩, by simp only [snd, comap_bot, mem_ker, fst_apply]⟩\n  map_add' := by simp only [coe_add, Prod.snd_add, implies_true]\n  map_smul' := by simp only [SetLike.val_smul, Prod.smul_snd, RingHom.id_apply, Subtype.forall,\n    implies_true]\n  left_inv := by\n    rintro ⟨⟨x, y⟩, hx⟩\n    simp only [snd, comap_bot, mem_ker, fst_apply] at hx\n    simpa only [Subtype.mk.injEq, Prod.mk.injEq, and_true] using hx.symm\n  right_inv := by rintro x; rfl\n\n"}
{"name":"Submodule.sndEquiv_apply","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\nx : Subtype fun x => Membership.mem (Submodule.snd R M M₂) x\n⊢ Eq ((Submodule.sndEquiv R M M₂) x) (↑x).2","decl":"/-- `N` as a submodule of `M × N` is isomorphic to `N`. -/\n@[simps]\ndef sndEquiv : Submodule.snd R M M₂ ≃ₗ[R] M₂ where\n  -- Porting note: proofs were `tidy` or `simp`\n  toFun x := x.1.2\n  invFun n := ⟨⟨0, n⟩, by simp only [snd, comap_bot, mem_ker, fst_apply]⟩\n  map_add' := by simp only [coe_add, Prod.snd_add, implies_true]\n  map_smul' := by simp only [SetLike.val_smul, Prod.smul_snd, RingHom.id_apply, Subtype.forall,\n    implies_true]\n  left_inv := by\n    rintro ⟨⟨x, y⟩, hx⟩\n    simp only [snd, comap_bot, mem_ker, fst_apply] at hx\n    simpa only [Subtype.mk.injEq, Prod.mk.injEq, and_true] using hx.symm\n  right_inv := by rintro x; rfl\n\n"}
{"name":"Submodule.snd_map_fst","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\n⊢ Eq (Submodule.map (LinearMap.fst R M M₂) (Submodule.snd R M M₂)) Bot.bot","decl":"theorem snd_map_fst : (Submodule.snd R M M₂).map (LinearMap.fst R M M₂) = ⊥ := by\n  -- Porting note (https://github.com/leanprover-community/mathlib4/issues/10936): was `tidy`\n  rw [eq_bot_iff]; intro x\n  simp only [snd, comap_bot, mem_map, mem_ker, fst_apply, eq_comm, Prod.exists, exists_eq_left,\n    exists_const, mem_bot, imp_self]\n\n"}
{"name":"Submodule.snd_map_snd","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\n⊢ Eq (Submodule.map (LinearMap.snd R M M₂) (Submodule.snd R M M₂)) Top.top","decl":"theorem snd_map_snd : (Submodule.snd R M M₂).map (LinearMap.snd R M M₂) = ⊤ := by\n  -- Porting note (https://github.com/leanprover-community/mathlib4/issues/10936): was `tidy`\n  rw [eq_top_iff]; rintro x -\n  simp only [snd, comap_bot, mem_map, mem_ker, snd_apply, fst_apply,\n    Prod.exists, exists_eq_right, exists_eq]\n\n"}
{"name":"Submodule.fst_sup_snd","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\n⊢ Eq (Max.max (Submodule.fst R M M₂) (Submodule.snd R M M₂)) Top.top","decl":"theorem fst_sup_snd : Submodule.fst R M M₂ ⊔ Submodule.snd R M M₂ = ⊤ := by\n  rw [eq_top_iff]\n  rintro ⟨m, n⟩ -\n  rw [show (m, n) = (m, 0) + (0, n) by simp]\n  apply Submodule.add_mem (Submodule.fst R M M₂ ⊔ Submodule.snd R M M₂)\n  · exact Submodule.mem_sup_left (Submodule.mem_comap.mpr (by simp))\n  · exact Submodule.mem_sup_right (Submodule.mem_comap.mpr (by simp))\n\n"}
{"name":"Submodule.fst_inf_snd","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\n⊢ Eq (Min.min (Submodule.fst R M M₂) (Submodule.snd R M M₂)) Bot.bot","decl":"theorem fst_inf_snd : Submodule.fst R M M₂ ⊓ Submodule.snd R M M₂ = ⊥ := by\n  -- Porting note (https://github.com/leanprover-community/mathlib4/issues/10936): was `tidy`\n  rw [eq_bot_iff]; rintro ⟨x, y⟩\n  simp only [fst, comap_bot, snd, mem_inf, mem_ker, snd_apply, fst_apply, mem_bot,\n    Prod.mk_eq_zero, and_comm, imp_self]\n\n"}
{"name":"Submodule.le_prod_iff","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\np₁ : Submodule R M\np₂ : Submodule R M₂\nq : Submodule R (Prod M M₂)\n⊢ Iff (LE.le q (p₁.prod p₂)) (And (LE.le (Submodule.map (LinearMap.fst R M M₂) q) p₁) (LE.le (Submodule.map (LinearMap.snd R M M₂) q) p₂))","decl":"theorem le_prod_iff {p₁ : Submodule R M} {p₂ : Submodule R M₂} {q : Submodule R (M × M₂)} :\n    q ≤ p₁.prod p₂ ↔ map (LinearMap.fst R M M₂) q ≤ p₁ ∧ map (LinearMap.snd R M M₂) q ≤ p₂ := by\n  constructor\n  · intro h\n    constructor\n    · rintro x ⟨⟨y1, y2⟩, ⟨hy1, rfl⟩⟩\n      exact (h hy1).1\n    · rintro x ⟨⟨y1, y2⟩, ⟨hy1, rfl⟩⟩\n      exact (h hy1).2\n  · rintro ⟨hH, hK⟩ ⟨x1, x2⟩ h\n    exact ⟨hH ⟨_, h, rfl⟩, hK ⟨_, h, rfl⟩⟩\n\n"}
{"name":"Submodule.prod_le_iff","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\np₁ : Submodule R M\np₂ : Submodule R M₂\nq : Submodule R (Prod M M₂)\n⊢ Iff (LE.le (p₁.prod p₂) q) (And (LE.le (Submodule.map (LinearMap.inl R M M₂) p₁) q) (LE.le (Submodule.map (LinearMap.inr R M M₂) p₂) q))","decl":"theorem prod_le_iff {p₁ : Submodule R M} {p₂ : Submodule R M₂} {q : Submodule R (M × M₂)} :\n    p₁.prod p₂ ≤ q ↔ map (LinearMap.inl R M M₂) p₁ ≤ q ∧ map (LinearMap.inr R M M₂) p₂ ≤ q := by\n  constructor\n  · intro h\n    constructor\n    · rintro _ ⟨x, hx, rfl⟩\n      apply h\n      exact ⟨hx, zero_mem p₂⟩\n    · rintro _ ⟨x, hx, rfl⟩\n      apply h\n      exact ⟨zero_mem p₁, hx⟩\n  · rintro ⟨hH, hK⟩ ⟨x1, x2⟩ ⟨h1, h2⟩\n    have h1' : (LinearMap.inl R _ _) x1 ∈ q := by\n      apply hH\n      simpa using h1\n    have h2' : (LinearMap.inr R _ _) x2 ∈ q := by\n      apply hK\n      simpa using h2\n    simpa using add_mem h1' h2'\n\n"}
{"name":"Submodule.prod_eq_bot_iff","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\np₁ : Submodule R M\np₂ : Submodule R M₂\n⊢ Iff (Eq (p₁.prod p₂) Bot.bot) (And (Eq p₁ Bot.bot) (Eq p₂ Bot.bot))","decl":"theorem prod_eq_bot_iff {p₁ : Submodule R M} {p₂ : Submodule R M₂} :\n    p₁.prod p₂ = ⊥ ↔ p₁ = ⊥ ∧ p₂ = ⊥ := by\n  simp only [eq_bot_iff, prod_le_iff, (gc_map_comap _).le_iff_le, comap_bot, ker_inl, ker_inr]\n\n"}
{"name":"Submodule.prod_eq_top_iff","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\np₁ : Submodule R M\np₂ : Submodule R M₂\n⊢ Iff (Eq (p₁.prod p₂) Top.top) (And (Eq p₁ Top.top) (Eq p₂ Top.top))","decl":"theorem prod_eq_top_iff {p₁ : Submodule R M} {p₂ : Submodule R M₂} :\n    p₁.prod p₂ = ⊤ ↔ p₁ = ⊤ ∧ p₂ = ⊤ := by\n  simp only [eq_top_iff, le_prod_iff, ← (gc_map_comap _).le_iff_le, map_top, range_fst, range_snd]\n\n"}
{"name":"LinearEquiv.prodComm_apply","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\na✝ : Prod M N\n⊢ Eq ((LinearEquiv.prodComm R M N) a✝) a✝.swap","decl":"/-- Product of modules is commutative up to linear isomorphism. -/\n@[simps apply]\ndef prodComm (R M N : Type*) [Semiring R] [AddCommMonoid M] [AddCommMonoid N] [Module R M]\n    [Module R N] : (M × N) ≃ₗ[R] N × M :=\n  { AddEquiv.prodComm with\n    toFun := Prod.swap\n    map_smul' := fun _r ⟨_m, _n⟩ => rfl }\n\n"}
{"name":"LinearEquiv.fst_comp_prodComm","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\n⊢ Eq ((LinearMap.fst R M₂ M).comp ↑(LinearEquiv.prodComm R M M₂)) (LinearMap.snd R M M₂)","decl":"theorem fst_comp_prodComm :\n    (LinearMap.fst R M₂ M).comp (prodComm R M M₂).toLinearMap = (LinearMap.snd R M M₂) := by\n  ext <;> simp\n\n"}
{"name":"LinearEquiv.snd_comp_prodComm","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\n⊢ Eq ((LinearMap.snd R M₂ M).comp ↑(LinearEquiv.prodComm R M M₂)) (LinearMap.fst R M M₂)","decl":"theorem snd_comp_prodComm :\n    (LinearMap.snd R M₂ M).comp (prodComm R M M₂).toLinearMap = (LinearMap.fst R M M₂) := by\n  ext <;> simp\n\n"}
{"name":"LinearEquiv.prodAssoc_apply","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u_3\nM₁ : Type u_4\nM₂ : Type u_5\nM₃ : Type u_6\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M₁\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid M₃\ninst✝² : Module R M₁\ninst✝¹ : Module R M₂\ninst✝ : Module R M₃\na✝ : Prod (Prod M₁ M₂) M₃\n⊢ Eq ((LinearEquiv.prodAssoc R M₁ M₂ M₃) a✝) (AddEquiv.prodAssoc.toFun a✝)","decl":"/-- Product of modules is associative up to linear isomorphism. -/\n@[simps apply]\ndef prodAssoc (R M₁ M₂ M₃ : Type*) [Semiring R]\n    [AddCommMonoid M₁] [AddCommMonoid M₂] [AddCommMonoid M₃]\n    [Module R M₁] [Module R M₂] [Module R M₃] : ((M₁ × M₂) × M₃) ≃ₗ[R] (M₁ × (M₂ × M₃)) :=\n  { AddEquiv.prodAssoc with\n    map_smul' := fun _r ⟨_m, _n⟩ => rfl }\n\n"}
{"name":"LinearEquiv.fst_comp_prodAssoc","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM₂ : Type w\nM₃ : Type y\nM₁ : Type u_3\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M₁\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid M₃\ninst✝² : Module R M₁\ninst✝¹ : Module R M₂\ninst✝ : Module R M₃\n⊢ Eq ((LinearMap.fst R M₁ (Prod M₂ M₃)).comp ↑(LinearEquiv.prodAssoc R M₁ M₂ M₃)) ((LinearMap.fst R M₁ M₂).comp (LinearMap.fst R (Prod M₁ M₂) M₃))","decl":"theorem fst_comp_prodAssoc :\n    (LinearMap.fst R M₁ (M₂ × M₃)).comp (prodAssoc R M₁ M₂ M₃).toLinearMap =\n    (LinearMap.fst R M₁ M₂).comp (LinearMap.fst R (M₁ × M₂) M₃) := by\n  ext <;> simp\n\n"}
{"name":"LinearEquiv.snd_comp_prodAssoc","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM₂ : Type w\nM₃ : Type y\nM₁ : Type u_3\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M₁\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid M₃\ninst✝² : Module R M₁\ninst✝¹ : Module R M₂\ninst✝ : Module R M₃\n⊢ Eq ((LinearMap.snd R M₁ (Prod M₂ M₃)).comp ↑(LinearEquiv.prodAssoc R M₁ M₂ M₃)) ((LinearMap.snd R M₁ M₂).prodMap LinearMap.id)","decl":"theorem snd_comp_prodAssoc :\n    (LinearMap.snd R M₁ (M₂ × M₃)).comp (prodAssoc R M₁ M₂ M₃).toLinearMap =\n    (LinearMap.snd R M₁ M₂).prodMap (LinearMap.id : M₃ →ₗ[R] M₃):= by\n  ext <;> simp\n\n"}
{"name":"LinearEquiv.prodProdProdComm_apply","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\nM₃ : Type y\nM₄ : Type z\ninst✝⁸ : Semiring R\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid M₂\ninst✝⁵ : AddCommMonoid M₃\ninst✝⁴ : AddCommMonoid M₄\ninst✝³ : Module R M\ninst✝² : Module R M₂\ninst✝¹ : Module R M₃\ninst✝ : Module R M₄\nmnmn : Prod (Prod M M₂) (Prod M₃ M₄)\n⊢ Eq ((LinearEquiv.prodProdProdComm R M M₂ M₃ M₄) mnmn) { fst := { fst := mnmn.1.1, snd := mnmn.2.1 }, snd := { fst := mnmn.1.2, snd := mnmn.2.2 } }","decl":"/-- Four-way commutativity of `prod`. The name matches `mul_mul_mul_comm`. -/\n@[simps apply]\ndef prodProdProdComm : ((M × M₂) × M₃ × M₄) ≃ₗ[R] (M × M₃) × M₂ × M₄ :=\n  { AddEquiv.prodProdProdComm M M₂ M₃ M₄ with\n    toFun := fun mnmn => ((mnmn.1.1, mnmn.2.1), (mnmn.1.2, mnmn.2.2))\n    invFun := fun mmnn => ((mmnn.1.1, mmnn.2.1), (mmnn.1.2, mmnn.2.2))\n    map_smul' := fun _c _mnmn => rfl }\n\n"}
{"name":"LinearEquiv.prodProdProdComm_symm","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\nM₃ : Type y\nM₄ : Type z\ninst✝⁸ : Semiring R\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid M₂\ninst✝⁵ : AddCommMonoid M₃\ninst✝⁴ : AddCommMonoid M₄\ninst✝³ : Module R M\ninst✝² : Module R M₂\ninst✝¹ : Module R M₃\ninst✝ : Module R M₄\n⊢ Eq (LinearEquiv.prodProdProdComm R M M₂ M₃ M₄).symm (LinearEquiv.prodProdProdComm R M M₃ M₂ M₄)","decl":"@[simp]\ntheorem prodProdProdComm_symm :\n    (prodProdProdComm R M M₂ M₃ M₄).symm = prodProdProdComm R M M₃ M₂ M₄ :=\n  rfl\n\n"}
{"name":"LinearEquiv.prodProdProdComm_toAddEquiv","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\nM₃ : Type y\nM₄ : Type z\ninst✝⁸ : Semiring R\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid M₂\ninst✝⁵ : AddCommMonoid M₃\ninst✝⁴ : AddCommMonoid M₄\ninst✝³ : Module R M\ninst✝² : Module R M₂\ninst✝¹ : Module R M₃\ninst✝ : Module R M₄\n⊢ Eq (↑(LinearEquiv.prodProdProdComm R M M₂ M₃ M₄)) (AddEquiv.prodProdProdComm M M₂ M₃ M₄)","decl":"@[simp]\ntheorem prodProdProdComm_toAddEquiv :\n    (prodProdProdComm R M M₂ M₃ M₄ : _ ≃+ _) = AddEquiv.prodProdProdComm M M₂ M₃ M₄ :=\n  rfl\n\n"}
{"name":"LinearEquiv.prod_symm","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\nM₃ : Type y\nM₄ : Type z\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : AddCommMonoid M₃\ninst✝ : AddCommMonoid M₄\nmodule_M : Module R M\nmodule_M₂ : Module R M₂\nmodule_M₃ : Module R M₃\nmodule_M₄ : Module R M₄\ne₁ : LinearEquiv (RingHom.id R) M M₂\ne₂ : LinearEquiv (RingHom.id R) M₃ M₄\n⊢ Eq (e₁.prod e₂).symm (e₁.symm.prod e₂.symm)","decl":"theorem prod_symm : (e₁.prod e₂).symm = e₁.symm.prod e₂.symm :=\n  rfl\n\n"}
{"name":"LinearEquiv.prod_apply","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\nM₃ : Type y\nM₄ : Type z\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : AddCommMonoid M₃\ninst✝ : AddCommMonoid M₄\nmodule_M : Module R M\nmodule_M₂ : Module R M₂\nmodule_M₃ : Module R M₃\nmodule_M₄ : Module R M₄\ne₁ : LinearEquiv (RingHom.id R) M M₂\ne₂ : LinearEquiv (RingHom.id R) M₃ M₄\np : Prod M M₃\n⊢ Eq ((e₁.prod e₂) p) { fst := e₁ p.1, snd := e₂ p.2 }","decl":"@[simp]\ntheorem prod_apply (p) : e₁.prod e₂ p = (e₁ p.1, e₂ p.2) :=\n  rfl\n\n"}
{"name":"LinearEquiv.coe_prod","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\nM₃ : Type y\nM₄ : Type z\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : AddCommMonoid M₃\ninst✝ : AddCommMonoid M₄\nmodule_M : Module R M\nmodule_M₂ : Module R M₂\nmodule_M₃ : Module R M₃\nmodule_M₄ : Module R M₄\ne₁ : LinearEquiv (RingHom.id R) M M₂\ne₂ : LinearEquiv (RingHom.id R) M₃ M₄\n⊢ Eq (↑(e₁.prod e₂)) ((↑e₁).prodMap ↑e₂)","decl":"@[simp, norm_cast]\ntheorem coe_prod :\n    (e₁.prod e₂ : M × M₃ →ₗ[R] M₂ × M₄) = (e₁ : M →ₗ[R] M₂).prodMap (e₂ : M₃ →ₗ[R] M₄) :=\n  rfl\n\n"}
{"name":"LinearEquiv.skewProd_apply","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\nM₃ : Type y\nM₄ : Type z\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : AddCommMonoid M₃\ninst✝ : AddCommGroup M₄\nmodule_M : Module R M\nmodule_M₂ : Module R M₂\nmodule_M₃ : Module R M₃\nmodule_M₄ : Module R M₄\ne₁ : LinearEquiv (RingHom.id R) M M₂\ne₂ : LinearEquiv (RingHom.id R) M₃ M₄\nf : LinearMap (RingHom.id R) M M₄\nx : Prod M M₃\n⊢ Eq ((e₁.skewProd e₂ f) x) { fst := e₁ x.1, snd := HAdd.hAdd (e₂ x.2) (f x.1) }","decl":"@[simp]\ntheorem skewProd_apply (f : M →ₗ[R] M₄) (x) : e₁.skewProd e₂ f x = (e₁ x.1, e₂ x.2 + f x.1) :=\n  rfl\n\n"}
{"name":"LinearEquiv.skewProd_symm_apply","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\nM₃ : Type y\nM₄ : Type z\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : AddCommMonoid M₃\ninst✝ : AddCommGroup M₄\nmodule_M : Module R M\nmodule_M₂ : Module R M₂\nmodule_M₃ : Module R M₃\nmodule_M₄ : Module R M₄\ne₁ : LinearEquiv (RingHom.id R) M M₂\ne₂ : LinearEquiv (RingHom.id R) M₃ M₄\nf : LinearMap (RingHom.id R) M M₄\nx : Prod M₂ M₄\n⊢ Eq ((e₁.skewProd e₂ f).symm x) { fst := e₁.symm x.1, snd := e₂.symm (HSub.hSub x.2 (f (e₁.symm x.1))) }","decl":"@[simp]\ntheorem skewProd_symm_apply (f : M →ₗ[R] M₄) (x) :\n    (e₁.skewProd e₂ f).symm x = (e₁.symm x.1, e₂.symm (x.2 - f (e₁.symm x.1))) :=\n  rfl\n\n"}
{"name":"LinearMap.range_prod_eq","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\nM₃ : Type y\ninst✝⁶ : Ring R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup M₂\ninst✝³ : AddCommGroup M₃\ninst✝² : Module R M\ninst✝¹ : Module R M₂\ninst✝ : Module R M₃\nf : LinearMap (RingHom.id R) M M₂\ng : LinearMap (RingHom.id R) M M₃\nh : Eq (Max.max (LinearMap.ker f) (LinearMap.ker g)) Top.top\n⊢ Eq (LinearMap.range (f.prod g)) ((LinearMap.range f).prod (LinearMap.range g))","decl":"/-- If the union of the kernels `ker f` and `ker g` spans the domain, then the range of\n`Prod f g` is equal to the product of `range f` and `range g`. -/\ntheorem range_prod_eq {f : M →ₗ[R] M₂} {g : M →ₗ[R] M₃} (h : ker f ⊔ ker g = ⊤) :\n    range (prod f g) = (range f).prod (range g) := by\n  refine le_antisymm (f.range_prod_le g) ?_\n  simp only [SetLike.le_def, prod_apply, mem_range, SetLike.mem_coe, mem_prod, exists_imp, and_imp,\n    Prod.forall, Pi.prod]\n  rintro _ _ x rfl y rfl\n  -- Note: https://github.com/leanprover-community/mathlib4/pull/8386 had to specify `(f := f)`\n  simp only [Prod.mk.inj_iff, ← sub_mem_ker_iff (f := f)]\n  have : y - x ∈ ker f ⊔ ker g := by simp only [h, mem_top]\n  rcases mem_sup.1 this with ⟨x', hx', y', hy', H⟩\n  refine ⟨x' + x, ?_, ?_⟩\n  · rwa [add_sub_cancel_right]\n  · simp [← eq_sub_iff_add_eq.1 H, map_add, add_left_inj, self_eq_add_right, mem_ker.mp hy']\n\n"}
{"name":"LinearMap.mem_graph_iff","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\nf : LinearMap (RingHom.id R) M M₂\nx : Prod M M₂\n⊢ Iff (Membership.mem f.graph x) (Eq x.2 (f x.1))","decl":"@[simp]\ntheorem mem_graph_iff (x : M × M₂) : x ∈ f.graph ↔ x.2 = f x.1 :=\n  Iff.rfl\n\n"}
{"name":"LinearMap.graph_eq_ker_coprod","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM₃ : Type y\nM₄ : Type z\ninst✝⁴ : Semiring R\ninst✝³ : AddCommGroup M₃\ninst✝² : AddCommGroup M₄\ninst✝¹ : Module R M₃\ninst✝ : Module R M₄\ng : LinearMap (RingHom.id R) M₃ M₄\n⊢ Eq g.graph (LinearMap.ker ((Neg.neg g).coprod LinearMap.id))","decl":"theorem graph_eq_ker_coprod : g.graph = ker ((-g).coprod LinearMap.id) := by\n  ext x\n  change _ = _ ↔ -g x.1 + x.2 = _\n  rw [add_comm, add_neg_eq_zero]\n\n"}
{"name":"LinearMap.graph_eq_range_prod","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\nf : LinearMap (RingHom.id R) M M₂\n⊢ Eq f.graph (LinearMap.range (LinearMap.id.prod f))","decl":"theorem graph_eq_range_prod : f.graph = range (LinearMap.id.prod f) := by\n  ext x\n  exact ⟨fun hx => ⟨x.1, Prod.ext rfl hx.symm⟩, fun ⟨u, hu⟩ => hu ▸ rfl⟩\n\n"}
{"name":"LinearMap.exists_range_eq_graph","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u_3\nS : Type u_4\nG : Type u_5\nH : Type u_6\nI : Type u_7\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring S\nσ : RingHom R S\ninst✝⁶ : RingHomSurjective σ\ninst✝⁵ : AddCommMonoid G\ninst✝⁴ : Module R G\ninst✝³ : AddCommMonoid H\ninst✝² : Module S H\ninst✝¹ : AddCommMonoid I\ninst✝ : Module S I\nf : LinearMap σ G (Prod H I)\nhf₁ : Function.Surjective (Function.comp Prod.fst ⇑f)\nhf : ∀ (g₁ g₂ : G), Eq (f g₁).1 (f g₂).1 → Eq (f g₁).2 (f g₂).2\n⊢ Exists fun f' => Eq (LinearMap.range f) f'.graph","decl":"/-- **Vertical line test** for linear maps.\n\nLet `f : G → H × I` be a linear (or semilinear) map to a product. Assume that `f` is surjective on\nthe first factor and that the image of `f` intersects every \"vertical line\" `{(h, i) | i : I}` at\nmost once. Then the image of `f` is the graph of some linear map `f' : H → I`. -/\nlemma LinearMap.exists_range_eq_graph {f : G →ₛₗ[σ] H × I} (hf₁ : Surjective (Prod.fst ∘ f))\n    (hf : ∀ g₁ g₂, (f g₁).1 = (f g₂).1 → (f g₁).2 = (f g₂).2) :\n    ∃ f' : H →ₗ[S] I, LinearMap.range f = LinearMap.graph f' := by\n  obtain ⟨f', hf'⟩ :=\n    AddMonoidHom.exists_mrange_eq_mgraph (G := G) (H := H) (I := I) (f := f) hf₁ hf\n  simp only [SetLike.ext_iff, AddMonoidHom.mem_mrange, AddMonoidHom.coe_coe,\n    AddMonoidHom.mem_mgraph] at hf'\n  use\n  { toFun := f'.toFun\n    map_add' := f'.map_add'\n    map_smul' := by\n      intro s h\n      simp only [ZeroHom.toFun_eq_coe, AddMonoidHom.toZeroHom_coe, RingHom.id_apply]\n      refine (hf' (s • h, _)).mp ?_\n      rw [← Prod.smul_mk, ← LinearMap.mem_range]\n      apply Submodule.smul_mem\n      rw [LinearMap.mem_range, hf'] }\n  ext x\n  simpa only [mem_range, Eq.comm, ZeroHom.toFun_eq_coe, AddMonoidHom.toZeroHom_coe, mem_graph_iff,\n    coe_mk, AddHom.coe_mk, AddMonoidHom.coe_coe, Set.mem_range] using hf' x\n\n"}
{"name":"Submodule.exists_eq_graph","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"S : Type u_4\nH : Type u_6\nI : Type u_7\ninst✝⁴ : Semiring S\ninst✝³ : AddCommMonoid H\ninst✝² : Module S H\ninst✝¹ : AddCommMonoid I\ninst✝ : Module S I\nG : Submodule S (Prod H I)\nhf₁ : Function.Bijective (Function.comp Prod.fst ⇑G.subtype)\n⊢ Exists fun f => Eq G f.graph","decl":"/-- **Vertical line test** for linear maps.\n\nLet `G ≤ H × I` be a submodule of a product of modules. Assume that `G` maps bijectively to the\nfirst factor. Then `G` is the graph of some linear map `f : H →ₗ[R] I`. -/\nlemma Submodule.exists_eq_graph {G : Submodule S (H × I)} (hf₁ : Bijective (Prod.fst ∘ G.subtype)) :\n    ∃ f : H →ₗ[S] I, G = LinearMap.graph f := by\n  simpa only [range_subtype] using LinearMap.exists_range_eq_graph hf₁.surjective\n      (fun a b h ↦ congr_arg (Prod.snd ∘ G.subtype) (hf₁.injective h))\n\n"}
{"name":"LinearMap.exists_linearEquiv_eq_graph","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"R : Type u_3\nS : Type u_4\nG : Type u_5\nH : Type u_6\nI : Type u_7\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring S\nσ : RingHom R S\ninst✝⁶ : RingHomSurjective σ\ninst✝⁵ : AddCommMonoid G\ninst✝⁴ : Module R G\ninst✝³ : AddCommMonoid H\ninst✝² : Module S H\ninst✝¹ : AddCommMonoid I\ninst✝ : Module S I\nf : LinearMap σ G (Prod H I)\nhf₁ : Function.Surjective (Function.comp Prod.fst ⇑f)\nhf₂ : Function.Surjective (Function.comp Prod.snd ⇑f)\nhf : ∀ (g₁ g₂ : G), Iff (Eq (f g₁).1 (f g₂).1) (Eq (f g₁).2 (f g₂).2)\n⊢ Exists fun e => Eq (LinearMap.range f) (↑e).graph","decl":"/-- **Line test** for module isomorphisms.\n\nLet `f : G → H × I` be a linear (or semilinear) map to a product of modules. Assume that `f` is\nsurjective onto both factors and that the image of `f` intersects every \"vertical line\"\n`{(h, i) | i : I}` and every \"horizontal line\" `{(h, i) | h : H}` at most once. Then the image of\n`f` is the graph of some module isomorphism `f' : H ≃ I`. -/\nlemma LinearMap.exists_linearEquiv_eq_graph {f : G →ₛₗ[σ] H × I} (hf₁ : Surjective (Prod.fst ∘ f))\n    (hf₂ : Surjective (Prod.snd ∘ f)) (hf : ∀ g₁ g₂, (f g₁).1 = (f g₂).1 ↔ (f g₁).2 = (f g₂).2) :\n    ∃ e : H ≃ₗ[S] I, range f = e.toLinearMap.graph := by\n  obtain ⟨e₁, he₁⟩ := f.exists_range_eq_graph hf₁ fun _ _ ↦ (hf _ _).1\n  obtain ⟨e₂, he₂⟩ := ((LinearEquiv.prodComm _ _ _).toLinearMap.comp f).exists_range_eq_graph\n    (by simpa) <| by simp [hf]\n  have he₁₂ h i : e₁ h = i ↔ e₂ i = h := by\n    simp only [SetLike.ext_iff, LinearMap.mem_graph_iff] at he₁ he₂\n    rw [Eq.comm, ← he₁ (h, i), Eq.comm, ← he₂ (i, h)]\n    simp only [mem_range, coe_comp, LinearEquiv.coe_coe, Function.comp_apply,\n      LinearEquiv.prodComm_apply, Prod.swap_eq_iff_eq_swap, Prod.swap_prod_mk]\n  exact ⟨\n  { toFun := e₁\n    map_smul' := e₁.map_smul'\n    map_add' := e₁.map_add'\n    invFun := e₂\n    left_inv := fun h ↦ by rw [← he₁₂]\n    right_inv := fun i ↦ by rw [he₁₂] }, he₁⟩\n\n"}
{"name":"Submodule.exists_equiv_eq_graph","module":"Mathlib.LinearAlgebra.Prod","initialProofState":"S : Type u_4\nH : Type u_6\nI : Type u_7\ninst✝⁴ : Semiring S\ninst✝³ : AddCommMonoid H\ninst✝² : Module S H\ninst✝¹ : AddCommMonoid I\ninst✝ : Module S I\nG : Submodule S (Prod H I)\nhG₁ : Function.Bijective (Function.comp Prod.fst ⇑G.subtype)\nhG₂ : Function.Bijective (Function.comp Prod.snd ⇑G.subtype)\n⊢ Exists fun e => Eq G (↑e).graph","decl":"/-- **Goursat's lemma** for module isomorphisms.\n\nLet `G ≤ H × I` be a submodule of a product of modules. Assume that the natural maps from `G` to\nboth factors are bijective. Then `G` is the graph of some module isomorphism `f : H ≃ I`. -/\nlemma Submodule.exists_equiv_eq_graph {G : Submodule S (H × I)}\n    (hG₁ : Bijective (Prod.fst ∘ G.subtype)) (hG₂ : Bijective (Prod.snd ∘ G.subtype)) :\n    ∃ e : H ≃ₗ[S] I, G = e.toLinearMap.graph := by\n  simpa only [range_subtype] using LinearMap.exists_linearEquiv_eq_graph\n    hG₁.surjective hG₂.surjective fun _ _ ↦ hG₁.injective.eq_iff.trans hG₂.injective.eq_iff.symm\n\n"}
