{"name":"Complex.stolzSet_empty","module":"Mathlib.Analysis.Complex.AbelLimit","initialProofState":"M : Real\nhM : LE.le M 1\n‚ä¢ Eq (Complex.stolzSet M) EmptyCollection.emptyCollection","decl":"theorem stolzSet_empty {M : ‚Ñù} (hM : M ‚â§ 1) : stolzSet M = ‚àÖ := by\n  ext z\n  rw [stolzSet, Set.mem_setOf, Set.mem_empty_iff_false, iff_false, not_and, not_lt, ‚Üê sub_pos]\n  intro zn\n  calc\n    _ ‚â§ 1 * (1 - ‚Äñz‚Äñ) := mul_le_mul_of_nonneg_right hM zn.le\n    _ = ‚Äñ(1 : ‚ÑÇ)‚Äñ - ‚Äñz‚Äñ := by rw [one_mul, norm_one]\n    _ ‚â§ _ := norm_sub_norm_le _ _\n\n"}
{"name":"Complex.nhdsWithin_lt_le_nhdsWithin_stolzSet","module":"Mathlib.Analysis.Complex.AbelLimit","initialProofState":"M : Real\nhM : LT.lt 1 M\n‚ä¢ LE.le (Filter.map Complex.ofReal (nhdsWithin 1 (Set.Iio 1))) (nhdsWithin 1 (Complex.stolzSet M))","decl":"theorem nhdsWithin_lt_le_nhdsWithin_stolzSet {M : ‚Ñù} (hM : 1 < M) :\n    (ùìù[<] 1).map ofReal ‚â§ ùìù[stolzSet M] 1 := by\n  rw [‚Üê tendsto_id']\n  refine tendsto_map' <| tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within ofReal\n    (tendsto_nhdsWithin_of_tendsto_nhds <| ofRealCLM.continuous.tendsto' 1 1 rfl) ?_\n  simp only [eventually_iff, norm_eq_abs, abs_ofReal, abs_lt, mem_nhdsWithin]\n  refine ‚ü®Set.Ioo 0 2, isOpen_Ioo, by norm_num, fun x hx ‚Ü¶ ?_‚ü©\n  simp only [Set.mem_inter_iff, Set.mem_Ioo, Set.mem_Iio] at hx\n  simp only [Set.mem_setOf_eq, stolzSet, ‚Üê ofReal_one, ‚Üê ofReal_sub, norm_eq_abs, abs_ofReal,\n    abs_of_pos hx.1.1, abs_of_pos <| sub_pos.mpr hx.2]\n  exact ‚ü®hx.2, lt_mul_left (sub_pos.mpr hx.2) hM‚ü©\n\n-- An ugly technical lemma\n"}
{"name":"Complex.stolzCone_subset_stolzSet_aux","module":"Mathlib.Analysis.Complex.AbelLimit","initialProofState":"s : Real\nhs : LT.lt 0 s\n‚ä¢ Exists fun M => Exists fun Œµ => And (LT.lt 0 M) (And (LT.lt 0 Œµ) (HasSubset.Subset (Inter.inter (setOf fun z => LT.lt (HSub.hSub 1 Œµ) z.re) (Complex.stolzCone s)) (Complex.stolzSet M)))","decl":"lemma stolzCone_subset_stolzSet_aux {s : ‚Ñù} (hs : 0 < s) :\n    ‚àÉ M Œµ, 0 < M ‚àß 0 < Œµ ‚àß {z : ‚ÑÇ | 1 - Œµ < z.re} ‚à© stolzCone s ‚äÜ stolzSet M := by\n  peel stolzCone_subset_stolzSet_aux' s with M Œµ hM hŒµ H\n  rintro z ‚ü®hzl, hzr‚ü©\n  rw [Set.mem_setOf_eq, sub_lt_comm, ‚Üê one_re, ‚Üê sub_re] at hzl\n  rw [stolzCone, Set.mem_setOf_eq, ‚Üê one_re, ‚Üê sub_re] at hzr\n  replace H :=\n    H (1 - z).re z.im ((mul_pos_iff_of_pos_left hs).mp <| (abs_nonneg z.im).trans_lt hzr) hzl hzr\n  have h : z.im ^ 2 = (1 - z).im ^ 2 := by\n    simp only [sub_im, one_im, zero_sub, even_two, neg_sq]\n  rw [h, ‚Üê abs_eq_sqrt_sq_add_sq, ‚Üê norm_eq_abs, ‚Üê h, sub_re, one_re, sub_sub_cancel,\n    ‚Üê abs_eq_sqrt_sq_add_sq, ‚Üê norm_eq_abs] at H\n  exact ‚ü®sub_pos.mp <| (mul_pos_iff_of_pos_left hM).mp <| (norm_nonneg _).trans_lt H, H‚ü©\n\n"}
{"name":"Complex.nhdsWithin_stolzCone_le_nhdsWithin_stolzSet","module":"Mathlib.Analysis.Complex.AbelLimit","initialProofState":"s : Real\nhs : LT.lt 0 s\n‚ä¢ Exists fun M => LE.le (nhdsWithin 1 (Complex.stolzCone s)) (nhdsWithin 1 (Complex.stolzSet M))","decl":"lemma nhdsWithin_stolzCone_le_nhdsWithin_stolzSet {s : ‚Ñù} (hs : 0 < s) :\n    ‚àÉ M, ùìù[stolzCone s] 1 ‚â§ ùìù[stolzSet M] 1 := by\n  obtain ‚ü®M, Œµ, _, hŒµ, H‚ü© := stolzCone_subset_stolzSet_aux hs\n  use M\n  rw [nhdsWithin_le_iff, mem_nhdsWithin]\n  refine ‚ü®{w | 1 - Œµ < w.re}, isOpen_lt continuous_const continuous_re, ?_, H‚ü©\n  simp only [Set.mem_setOf_eq, one_re, sub_lt_self_iff, hŒµ]\n\n"}
{"name":"Complex.abel_aux","module":"Mathlib.Analysis.Complex.AbelLimit","initialProofState":"f : Nat ‚Üí Complex\nl : Complex\nh : Filter.Tendsto (fun n => (Finset.range n).sum fun i => f i) Filter.atTop (nhds l)\nz : Complex\nhz : LT.lt (Norm.norm z) 1\n‚ä¢ Filter.Tendsto (fun n => HMul.hMul (HSub.hSub 1 z) ((Finset.range n).sum fun i => HMul.hMul (HSub.hSub l ((Finset.range (HAdd.hAdd i 1)).sum fun j => f j)) (HPow.hPow z i))) Filter.atTop (nhds (HSub.hSub l (tsum fun n => HMul.hMul (f n) (HPow.hPow z n))))","decl":"/-- Auxiliary lemma for Abel's limit theorem. The difference between the sum `l` at 1 and the\npower series's value at a point `z` away from 1 can be rewritten as `1 - z` times a power series\nwhose coefficients are tail sums of `l`. -/\nlemma abel_aux (h : Tendsto (fun n ‚Ü¶ ‚àë i ‚àà range n, f i) atTop (ùìù l)) {z : ‚ÑÇ} (hz : ‚Äñz‚Äñ < 1) :\n    Tendsto (fun n ‚Ü¶ (1 - z) * ‚àë i ‚àà range n, (l - ‚àë j ‚àà range (i + 1), f j) * z ^ i)\n      atTop (ùìù (l - ‚àë' n, f n * z ^ n)) := by\n  let s := fun n ‚Ü¶ ‚àë i ‚àà range n, f i\n  have k := h.sub (summable_powerSeries_of_norm_lt_one h.cauchySeq hz).hasSum.tendsto_sum_nat\n  simp_rw [‚Üê sum_sub_distrib, ‚Üê mul_one_sub, ‚Üê geom_sum_mul_neg, ‚Üê mul_assoc, ‚Üê sum_mul,\n    mul_comm, mul_sum _ _ (f _), range_eq_Ico, ‚Üê sum_Ico_Ico_comm', ‚Üê range_eq_Ico,\n    ‚Üê sum_mul] at k\n  conv at k =>\n    enter [1, n]\n    rw [sum_congr (g := fun j ‚Ü¶ (‚àë k ‚àà range n, f k - ‚àë k ‚àà range (j + 1), f k) * z ^ j)\n      rfl (fun j hj ‚Ü¶ by congr 1; exact sum_Ico_eq_sub _ (mem_range.mp hj))]\n  suffices Tendsto (fun n ‚Ü¶ (l - s n) * ‚àë i ‚àà range n, z ^ i) atTop (ùìù 0) by\n    simp_rw [mul_sum] at this\n    replace this := (this.const_mul (1 - z)).add k\n    conv at this =>\n      enter [1, n]\n      rw [‚Üê mul_add, ‚Üê sum_add_distrib]\n      enter [2, 2, i]\n      rw [‚Üê add_mul, sub_add_sub_cancel]\n    rwa [mul_zero, zero_add] at this\n  rw [‚Üê zero_mul (-1 / (z - 1))]\n  apply Tendsto.mul\n  ¬∑ simpa only [neg_zero, neg_sub] using (tendsto_sub_nhds_zero_iff.mpr h).neg\n  ¬∑ conv =>\n      enter [1, n]\n      rw [geom_sum_eq (by contrapose! hz; simp [hz]), sub_div, sub_eq_add_neg, ‚Üê neg_div]\n    rw [‚Üê zero_add (-1 / (z - 1)), ‚Üê zero_div (z - 1)]\n    apply Tendsto.add (Tendsto.div_const (tendsto_pow_atTop_nhds_zero_of_norm_lt_one hz) (z - 1))\n    simp only [zero_div, zero_add, tendsto_const_nhds_iff]\n\n"}
{"name":"Complex.tendsto_tsum_powerSeries_nhdsWithin_stolzSet","module":"Mathlib.Analysis.Complex.AbelLimit","initialProofState":"f : Nat ‚Üí Complex\nl : Complex\nh : Filter.Tendsto (fun n => (Finset.range n).sum fun i => f i) Filter.atTop (nhds l)\nM : Real\n‚ä¢ Filter.Tendsto (fun z => tsum fun n => HMul.hMul (f n) (HPow.hPow z n)) (nhdsWithin 1 (Complex.stolzSet M)) (nhds l)","decl":"/-- **Abel's limit theorem**. Given a power series converging at 1, the corresponding function\nis continuous at 1 when approaching 1 within a fixed Stolz set. -/\ntheorem tendsto_tsum_powerSeries_nhdsWithin_stolzSet\n    (h : Tendsto (fun n ‚Ü¶ ‚àë i ‚àà range n, f i) atTop (ùìù l)) {M : ‚Ñù} :\n    Tendsto (fun z ‚Ü¶ ‚àë' n, f n * z ^ n) (ùìù[stolzSet M] 1) (ùìù l) := by\n  -- If `M ‚â§ 1` the Stolz set is empty and the statement is trivial\n  cases' le_or_lt M 1 with hM hM\n  ¬∑ simp_rw [stolzSet_empty hM, nhdsWithin_empty, tendsto_bot]\n  -- Abbreviations\n  let s := fun n ‚Ü¶ ‚àë i ‚àà range n, f i\n  let g := fun z ‚Ü¶ ‚àë' n, f n * z ^ n\n  have hm := Metric.tendsto_atTop.mp h\n  rw [Metric.tendsto_nhdsWithin_nhds]\n  simp only [dist_eq_norm] at hm ‚ä¢\n  -- Introduce the \"challenge\" `Œµ`\n  intro Œµ Œµpos\n  -- First bound, handles the tail\n  obtain ‚ü®B‚ÇÅ, hB‚ÇÅ‚ü© := hm (Œµ / 4 / M) (by positivity)\n  -- Second bound, handles the head\n  let F := ‚àë i ‚àà range B‚ÇÅ, ‚Äñl - s (i + 1)‚Äñ\n  use Œµ / 4 / (F + 1), by positivity\n  intro z ‚ü®zn, zm‚ü© zd\n  have p := abel_aux h zn\n  simp_rw [Metric.tendsto_atTop, dist_eq_norm, norm_sub_rev] at p\n  -- Third bound, regarding the distance between `l - g z` and the rearranged sum\n  obtain ‚ü®B‚ÇÇ, hB‚ÇÇ‚ü© := p (Œµ / 2) (by positivity)\n  clear hm p\n  replace hB‚ÇÇ := hB‚ÇÇ (max B‚ÇÅ B‚ÇÇ) (by simp)\n  suffices ‚Äñ(1 - z) * ‚àë i ‚àà range (max B‚ÇÅ B‚ÇÇ), (l - s (i + 1)) * z ^ i‚Äñ < Œµ / 2 by\n    calc\n      _ = ‚Äñl - g z‚Äñ := by rw [norm_sub_rev]\n      _ = ‚Äñl - g z - (1 - z) * ‚àë i ‚àà range (max B‚ÇÅ B‚ÇÇ), (l - s (i + 1)) * z ^ i +\n          (1 - z) * ‚àë i ‚àà range (max B‚ÇÅ B‚ÇÇ), (l - s (i + 1)) * z ^ i‚Äñ := by rw [sub_add_cancel _]\n      _ ‚â§ ‚Äñl - g z - (1 - z) * ‚àë i ‚àà range (max B‚ÇÅ B‚ÇÇ), (l - s (i + 1)) * z ^ i‚Äñ +\n          ‚Äñ(1 - z) * ‚àë i ‚àà range (max B‚ÇÅ B‚ÇÇ), (l - s (i + 1)) * z ^ i‚Äñ := norm_add_le _ _\n      _ < Œµ / 2 + Œµ / 2 := add_lt_add hB‚ÇÇ this\n      _ = _ := add_halves Œµ\n  -- We break the rearranged sum along `B‚ÇÅ`\n  calc\n    _ = ‚Äñ(1 - z) * ‚àë i ‚àà range B‚ÇÅ, (l - s (i + 1)) * z ^ i +\n        (1 - z) * ‚àë i ‚àà Ico B‚ÇÅ (max B‚ÇÅ B‚ÇÇ), (l - s (i + 1)) * z ^ i‚Äñ := by\n      rw [‚Üê mul_add, sum_range_add_sum_Ico _ (le_max_left B‚ÇÅ B‚ÇÇ)]\n    _ ‚â§ ‚Äñ(1 - z) * ‚àë i ‚àà range B‚ÇÅ, (l - s (i + 1)) * z ^ i‚Äñ +\n        ‚Äñ(1 - z) * ‚àë i ‚àà Ico B‚ÇÅ (max B‚ÇÅ B‚ÇÇ), (l - s (i + 1)) * z ^ i‚Äñ := norm_add_le _ _\n    _ = ‚Äñ1 - z‚Äñ * ‚Äñ‚àë i ‚àà range B‚ÇÅ, (l - s (i + 1)) * z ^ i‚Äñ +\n        ‚Äñ1 - z‚Äñ * ‚Äñ‚àë i ‚àà Ico B‚ÇÅ (max B‚ÇÅ B‚ÇÇ), (l - s (i + 1)) * z ^ i‚Äñ := by\n      rw [norm_mul, norm_mul]\n    _ ‚â§ ‚Äñ1 - z‚Äñ * ‚àë i ‚àà range B‚ÇÅ, ‚Äñl - s (i + 1)‚Äñ * ‚Äñz‚Äñ ^ i +\n        ‚Äñ1 - z‚Äñ * ‚àë i ‚àà Ico B‚ÇÅ (max B‚ÇÅ B‚ÇÇ), ‚Äñl - s (i + 1)‚Äñ * ‚Äñz‚Äñ ^ i := by\n      gcongr <;> simp_rw [‚Üê norm_pow, ‚Üê norm_mul, norm_sum_le]\n  -- then prove that the two pieces are each less than `Œµ / 4`\n  have S‚ÇÅ : ‚Äñ1 - z‚Äñ * ‚àë i ‚àà range B‚ÇÅ, ‚Äñl - s (i + 1)‚Äñ * ‚Äñz‚Äñ ^ i < Œµ / 4 :=\n    calc\n      _ ‚â§ ‚Äñ1 - z‚Äñ * ‚àë i ‚àà range B‚ÇÅ, ‚Äñl - s (i + 1)‚Äñ := by\n        gcongr; nth_rw 3 [‚Üê mul_one ‚Äñ_‚Äñ]\n        gcongr; exact pow_le_one‚ÇÄ (norm_nonneg _) zn.le\n      _ ‚â§ ‚Äñ1 - z‚Äñ * (F + 1) := by gcongr; linarith only\n      _ < _ := by rwa [norm_sub_rev, lt_div_iff‚ÇÄ (by positivity)] at zd\n  have S‚ÇÇ : ‚Äñ1 - z‚Äñ * ‚àë i ‚àà Ico B‚ÇÅ (max B‚ÇÅ B‚ÇÇ), ‚Äñl - s (i + 1)‚Äñ * ‚Äñz‚Äñ ^ i < Œµ / 4 :=\n    calc\n      _ ‚â§ ‚Äñ1 - z‚Äñ * ‚àë i ‚àà Ico B‚ÇÅ (max B‚ÇÅ B‚ÇÇ), Œµ / 4 / M * ‚Äñz‚Äñ ^ i := by\n        gcongr with i hi\n        have := hB‚ÇÅ (i + 1) (by linarith only [(mem_Ico.mp hi).1])\n        rw [norm_sub_rev] at this\n        exact this.le\n      _ = ‚Äñ1 - z‚Äñ * (Œµ / 4 / M) * ‚àë i ‚àà Ico B‚ÇÅ (max B‚ÇÅ B‚ÇÇ), ‚Äñz‚Äñ ^ i := by\n        rw [‚Üê mul_sum, ‚Üê mul_assoc]\n      _ ‚â§ ‚Äñ1 - z‚Äñ * (Œµ / 4 / M) * ‚àë' i, ‚Äñz‚Äñ ^ i := by\n        gcongr\n        exact sum_le_tsum _ (fun _ _ ‚Ü¶ by positivity)\n          (summable_geometric_of_lt_one (by positivity) zn)\n      _ = ‚Äñ1 - z‚Äñ * (Œµ / 4 / M) / (1 - ‚Äñz‚Äñ) := by\n        rw [tsum_geometric_of_lt_one (by positivity) zn, ‚Üê div_eq_mul_inv]\n      _ < M * (1 - ‚Äñz‚Äñ) * (Œµ / 4 / M) / (1 - ‚Äñz‚Äñ) := by gcongr; linarith only [zn]\n      _ = _ := by\n        rw [‚Üê mul_rotate, mul_div_cancel_right‚ÇÄ _ (by linarith only [zn]),\n          div_mul_cancel‚ÇÄ _ (by linarith only [hM])]\n  convert add_lt_add S‚ÇÅ S‚ÇÇ using 1\n  linarith only\n\n"}
{"name":"Complex.tendsto_tsum_powerSeries_nhdsWithin_stolzCone","module":"Mathlib.Analysis.Complex.AbelLimit","initialProofState":"f : Nat ‚Üí Complex\nl : Complex\nh : Filter.Tendsto (fun n => (Finset.range n).sum fun i => f i) Filter.atTop (nhds l)\ns : Real\nhs : LT.lt 0 s\n‚ä¢ Filter.Tendsto (fun z => tsum fun n => HMul.hMul (f n) (HPow.hPow z n)) (nhdsWithin 1 (Complex.stolzCone s)) (nhds l)","decl":"/-- **Abel's limit theorem**. Given a power series converging at 1, the corresponding function\nis continuous at 1 when approaching 1 within any fixed Stolz cone. -/\ntheorem tendsto_tsum_powerSeries_nhdsWithin_stolzCone\n    (h : Tendsto (fun n ‚Ü¶ ‚àë i ‚àà range n, f i) atTop (ùìù l)) {s : ‚Ñù} (hs : 0 < s) :\n    Tendsto (fun z ‚Ü¶ ‚àë' n, f n * z ^ n) (ùìù[stolzCone s] 1) (ùìù l) :=\n  (tendsto_tsum_powerSeries_nhdsWithin_stolzSet h).mono_left\n    (nhdsWithin_stolzCone_le_nhdsWithin_stolzSet hs).choose_spec\n\n"}
{"name":"Complex.tendsto_tsum_powerSeries_nhdsWithin_lt","module":"Mathlib.Analysis.Complex.AbelLimit","initialProofState":"f : Nat ‚Üí Complex\nl : Complex\nh : Filter.Tendsto (fun n => (Finset.range n).sum fun i => f i) Filter.atTop (nhds l)\n‚ä¢ Filter.Tendsto (fun z => tsum fun n => HMul.hMul (f n) (HPow.hPow z n)) (Filter.map Complex.ofReal (nhdsWithin 1 (Set.Iio 1))) (nhds l)","decl":"theorem tendsto_tsum_powerSeries_nhdsWithin_lt\n    (h : Tendsto (fun n ‚Ü¶ ‚àë i ‚àà range n, f i) atTop (ùìù l)) :\n    Tendsto (fun z ‚Ü¶ ‚àë' n, f n * z ^ n) ((ùìù[<] 1).map ofReal) (ùìù l) :=\n  (tendsto_tsum_powerSeries_nhdsWithin_stolzSet (M := 2) h).mono_left\n    (nhdsWithin_lt_le_nhdsWithin_stolzSet one_lt_two)\n\n"}
{"name":"Real.tendsto_tsum_powerSeries_nhdsWithin_lt","module":"Mathlib.Analysis.Complex.AbelLimit","initialProofState":"f : Nat ‚Üí Real\nl : Real\nh : Filter.Tendsto (fun n => (Finset.range n).sum fun i => f i) Filter.atTop (nhds l)\n‚ä¢ Filter.Tendsto (fun x => tsum fun n => HMul.hMul (f n) (HPow.hPow x n)) (nhdsWithin 1 (Set.Iio 1)) (nhds l)","decl":"/-- **Abel's limit theorem**. Given a real power series converging at 1, the corresponding function\nis continuous at 1 when approaching 1 from the left. -/\ntheorem tendsto_tsum_powerSeries_nhdsWithin_lt\n    (h : Tendsto (fun n ‚Ü¶ ‚àë i ‚àà range n, f i) atTop (ùìù l)) :\n    Tendsto (fun x ‚Ü¶ ‚àë' n, f n * x ^ n) (ùìù[<] 1) (ùìù l) := by\n  have m : (ùìù l).map ofReal ‚â§ ùìù ‚Üël := ofRealCLM.continuous.tendsto l\n  replace h := (tendsto_map.comp h).mono_right m\n  rw [Function.comp_def] at h\n  push_cast at h\n  replace h := Complex.tendsto_tsum_powerSeries_nhdsWithin_lt h\n  rw [tendsto_map'_iff] at h\n  rw [Metric.tendsto_nhdsWithin_nhds] at h ‚ä¢\n  convert h\n  simp_rw [Function.comp_apply, dist_eq_norm]\n  norm_cast\n\n"}
