{"name":"SetTheory.PGame.Short.mk.injEq","module":"Mathlib.SetTheory.Game.Short","initialProofState":"α β : Type u\nL : α → SetTheory.PGame\nR : β → SetTheory.PGame\nx✝³ : (i : α) → (L i).Short\nx✝² : (j : β) → (R j).Short\ninst✝³ : Fintype α\ninst✝² : Fintype β\nx✝¹ : (i : α) → (L i).Short\nx✝ : (j : β) → (R j).Short\ninst✝¹ : Fintype α\ninst✝ : Fintype β\n⊢ Eq (Eq (SetTheory.PGame.Short.mk x✝³ x✝²) (SetTheory.PGame.Short.mk x✝¹ x✝)) (And (Eq x✝³ x✝¹) (And (Eq x✝² x✝) (And (Eq inst✝³ inst✝¹) (Eq inst✝² inst✝))))","decl":"/-- A short game is a game with a finite set of moves at every turn. -/\ninductive Short : PGame.{u} → Type (u + 1)\n  | mk :\n    ∀ {α β : Type u} {L : α → PGame.{u}} {R : β → PGame.{u}} (_ : ∀ i : α, Short (L i))\n      (_ : ∀ j : β, Short (R j)) [Fintype α] [Fintype β], Short ⟨α, β, L, R⟩\n\n"}
{"name":"SetTheory.PGame.Short.mk.sizeOf_spec","module":"Mathlib.SetTheory.Game.Short","initialProofState":"α β : Type u\nL : α → SetTheory.PGame\nR : β → SetTheory.PGame\nx✝¹ : (i : α) → (L i).Short\nx✝ : (j : β) → (R j).Short\ninst✝¹ : Fintype α\ninst✝ : Fintype β\n⊢ Eq (SizeOf.sizeOf (SetTheory.PGame.Short.mk x✝¹ x✝)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf α)) (SizeOf.sizeOf β)) (SizeOf.sizeOf inst✝¹)) (SizeOf.sizeOf inst✝))","decl":"/-- A short game is a game with a finite set of moves at every turn. -/\ninductive Short : PGame.{u} → Type (u + 1)\n  | mk :\n    ∀ {α β : Type u} {L : α → PGame.{u}} {R : β → PGame.{u}} (_ : ∀ i : α, Short (L i))\n      (_ : ∀ j : β, Short (R j)) [Fintype α] [Fintype β], Short ⟨α, β, L, R⟩\n\n"}
{"name":"SetTheory.PGame.Short.mk.inj","module":"Mathlib.SetTheory.Game.Short","initialProofState":"α β : Type u\nL : α → SetTheory.PGame\nR : β → SetTheory.PGame\nx✝⁴ : (i : α) → (L i).Short\nx✝³ : (j : β) → (R j).Short\ninst✝³ : Fintype α\ninst✝² : Fintype β\nx✝² : (i : α) → (L i).Short\nx✝¹ : (j : β) → (R j).Short\ninst✝¹ : Fintype α\ninst✝ : Fintype β\nx✝ : Eq (SetTheory.PGame.Short.mk x✝⁴ x✝³) (SetTheory.PGame.Short.mk x✝² x✝¹)\n⊢ And (Eq x✝⁴ x✝²) (And (Eq x✝³ x✝¹) (And (Eq inst✝³ inst✝¹) (Eq inst✝² inst✝)))","decl":"/-- A short game is a game with a finite set of moves at every turn. -/\ninductive Short : PGame.{u} → Type (u + 1)\n  | mk :\n    ∀ {α β : Type u} {L : α → PGame.{u}} {R : β → PGame.{u}} (_ : ∀ i : α, Short (L i))\n      (_ : ∀ j : β, Short (R j)) [Fintype α] [Fintype β], Short ⟨α, β, L, R⟩\n\n"}
{"name":"SetTheory.PGame.subsingleton_short","module":"Mathlib.SetTheory.Game.Short","initialProofState":"x : SetTheory.PGame\n⊢ Subsingleton x.Short","decl":"instance subsingleton_short (x : PGame) : Subsingleton (Short x) := by\n  induction x with\n  | mk xl xr xL xR =>\n    constructor\n    intro a b\n    cases a; cases b\n    congr!\n\n-- Porting note: We use `induction` to prove `subsingleton_short` instead of recursion.\n-- A proof using recursion generates a harder `decreasing_by` goal than in Lean 3 for some reason:\n"}
{"name":"SetTheory.PGame.subsingleton_short_example","module":"Mathlib.SetTheory.Game.Short","initialProofState":"x : SetTheory.PGame\n⊢ Subsingleton x.Short","decl":"attribute [-instance] subsingleton_short in\ntheorem subsingleton_short_example : ∀ x : PGame, Subsingleton (Short x)\n  | mk xl xr xL xR =>\n    ⟨fun a b => by\n      cases a; cases b\n      congr!\n      · funext x\n        apply @Subsingleton.elim _ (subsingleton_short_example (xL x))\n        -- Decreasing goal in Lean 4 is `Subsequent (xL x) (mk α β L R)`\n        -- where `α`, `β`, `L`, and `R` are fresh hypotheses only propositionally\n        -- equal to `xl`, `xr`, `xL`, and `xR`.\n        -- (In Lean 3 it was `(mk xl xr xL xR)` instead.)\n      · funext x\n        apply @Subsingleton.elim _ (subsingleton_short_example (xR x))⟩\ntermination_by x => x\n-- We need to unify a bunch of hypotheses before `pgame_wf_tac` can work.\ndecreasing_by all_goals {\n  subst_vars\n  simp only [mk.injEq, heq_eq_eq, true_and] at *\n  casesm* _ ∧ _\n  subst_vars\n  pgame_wf_tac\n}\n\n"}
{"name":"SetTheory.PGame.short_birthday","module":"Mathlib.SetTheory.Game.Short","initialProofState":"x : SetTheory.PGame\ninst✝ : x.Short\n⊢ LT.lt x.birthday Ordinal.omega0","decl":"theorem short_birthday (x : PGame.{u}) : [Short x] → x.birthday < Ordinal.omega0 := by\n  -- Porting note: Again `induction` is used instead of `pgame_wf_tac`\n  induction x with\n  | mk xl xr xL xR ihl ihr =>\n    intro hs\n    rcases hs with ⟨sL, sR⟩\n    rw [birthday, max_lt_iff]\n    constructor\n    all_goals\n      rw [← Cardinal.ord_aleph0]\n      refine\n        Cardinal.lsub_lt_ord_of_isRegular.{u, u} Cardinal.isRegular_aleph0\n          (Cardinal.lt_aleph0_of_finite _) fun i => ?_\n      rw [Cardinal.ord_aleph0]\n    · apply ihl\n    · apply ihr\n\n"}
