{"name":"MvPolynomial.weightedTotalDegree_one","module":"Mathlib.RingTheory.MvPolynomial.Homogeneous","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝ : CommSemiring R\nφ : MvPolynomial σ R\n⊢ Eq (MvPolynomial.weightedTotalDegree 1 φ) φ.totalDegree","decl":"theorem weightedTotalDegree_one (φ : MvPolynomial σ R) :\n    weightedTotalDegree (1 : σ → ℕ) φ = φ.totalDegree := by\n  simp only [totalDegree, weightedTotalDegree, weight, LinearMap.toAddMonoidHom_coe,\n    linearCombination, Pi.one_apply, Finsupp.coe_lsum, LinearMap.coe_smulRight, LinearMap.id_coe,\n    id, Algebra.id.smul_eq_mul, mul_one]\n\n"}
{"name":"MvPolynomial.weightedHomogeneousSubmodule_one","module":"Mathlib.RingTheory.MvPolynomial.Homogeneous","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝ : CommSemiring R\nn : Nat\n⊢ Eq (MvPolynomial.weightedHomogeneousSubmodule R 1 n) (MvPolynomial.homogeneousSubmodule σ R n)","decl":"@[simp]\nlemma weightedHomogeneousSubmodule_one (n : ℕ) :\n    weightedHomogeneousSubmodule R 1 n = homogeneousSubmodule σ R n := rfl\n\n"}
{"name":"MvPolynomial.mem_homogeneousSubmodule","module":"Mathlib.RingTheory.MvPolynomial.Homogeneous","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝ : CommSemiring R\nn : Nat\np : MvPolynomial σ R\n⊢ Iff (Membership.mem (MvPolynomial.homogeneousSubmodule σ R n) p) (p.IsHomogeneous n)","decl":"@[simp]\ntheorem mem_homogeneousSubmodule (n : ℕ) (p : MvPolynomial σ R) :\n    p ∈ homogeneousSubmodule σ R n ↔ p.IsHomogeneous n := Iff.rfl\n\n"}
{"name":"MvPolynomial.homogeneousSubmodule_eq_finsupp_supported","module":"Mathlib.RingTheory.MvPolynomial.Homogeneous","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝ : CommSemiring R\nn : Nat\n⊢ Eq (MvPolynomial.homogeneousSubmodule σ R n) (Finsupp.supported R R (setOf fun d => Eq d.degree n))","decl":"/-- While equal, the former has a convenient definitional reduction. -/\ntheorem homogeneousSubmodule_eq_finsupp_supported (n : ℕ) :\n    homogeneousSubmodule σ R n = Finsupp.supported _ R { d | d.degree = n } := by\n  simp_rw [degree_eq_weight_one]\n  exact weightedHomogeneousSubmodule_eq_finsupp_supported R 1 n\n\n"}
{"name":"MvPolynomial.homogeneousSubmodule_mul","module":"Mathlib.RingTheory.MvPolynomial.Homogeneous","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝ : CommSemiring R\nm n : Nat\n⊢ LE.le (HMul.hMul (MvPolynomial.homogeneousSubmodule σ R m) (MvPolynomial.homogeneousSubmodule σ R n)) (MvPolynomial.homogeneousSubmodule σ R (HAdd.hAdd m n))","decl":"theorem homogeneousSubmodule_mul (m n : ℕ) :\n    homogeneousSubmodule σ R m * homogeneousSubmodule σ R n ≤ homogeneousSubmodule σ R (m + n) :=\n  weightedHomogeneousSubmodule_mul 1 m n\n\n"}
{"name":"MvPolynomial.isHomogeneous_monomial","module":"Mathlib.RingTheory.MvPolynomial.Homogeneous","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝ : CommSemiring R\nd : Finsupp σ Nat\nr : R\nn : Nat\nhn : Eq d.degree n\n⊢ ((MvPolynomial.monomial d) r).IsHomogeneous n","decl":"theorem isHomogeneous_monomial {d : σ →₀ ℕ} (r : R) {n : ℕ} (hn : d.degree = n) :\n    IsHomogeneous (monomial d r) n := by\n  rw [degree_eq_weight_one] at hn\n  exact isWeightedHomogeneous_monomial 1 d r hn\n\n"}
{"name":"MvPolynomial.totalDegree_eq_zero_iff","module":"Mathlib.RingTheory.MvPolynomial.Homogeneous","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝ : CommSemiring R\np : MvPolynomial σ R\n⊢ Iff (Eq p.totalDegree 0) (∀ (m : Finsupp σ Nat), Membership.mem p.support m → ∀ (x : σ), Eq (m x) 0)","decl":"theorem totalDegree_eq_zero_iff (p : MvPolynomial σ R) :\n    p.totalDegree = 0 ↔ ∀ (m : σ →₀ ℕ) (_ : m ∈ p.support) (x : σ), m x = 0 := by\n  rw [← weightedTotalDegree_one, weightedTotalDegree_eq_zero_iff _ p]\n  exact nonTorsionWeight_of (Function.const σ one_ne_zero)\n\n"}
{"name":"MvPolynomial.totalDegree_zero_iff_isHomogeneous","module":"Mathlib.RingTheory.MvPolynomial.Homogeneous","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝ : CommSemiring R\np : MvPolynomial σ R\n⊢ Iff (Eq p.totalDegree 0) (p.IsHomogeneous 0)","decl":"theorem totalDegree_zero_iff_isHomogeneous {p : MvPolynomial σ R} :\n    p.totalDegree = 0 ↔ IsHomogeneous p 0 := by\n  rw [← weightedTotalDegree_one,\n    ← isWeightedHomogeneous_zero_iff_weightedTotalDegree_eq_zero, IsHomogeneous]\n\n"}
{"name":"MvPolynomial.isHomogeneous_of_totalDegree_zero","module":"Mathlib.RingTheory.MvPolynomial.Homogeneous","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝ : CommSemiring R\np : MvPolynomial σ R\na✝ : Eq p.totalDegree 0\n⊢ p.IsHomogeneous 0","decl":"alias ⟨isHomogeneous_of_totalDegree_zero, _⟩ := totalDegree_zero_iff_isHomogeneous\n\n"}
{"name":"MvPolynomial.isHomogeneous_C","module":"Mathlib.RingTheory.MvPolynomial.Homogeneous","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝ : CommSemiring R\nr : R\n⊢ (MvPolynomial.C r).IsHomogeneous 0","decl":"theorem isHomogeneous_C (r : R) : IsHomogeneous (C r : MvPolynomial σ R) 0 := by\n  apply isHomogeneous_monomial\n  simp only [Finsupp.degree, Finsupp.zero_apply, Finset.sum_const_zero]\n\n"}
{"name":"MvPolynomial.isHomogeneous_zero","module":"Mathlib.RingTheory.MvPolynomial.Homogeneous","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝ : CommSemiring R\nn : Nat\n⊢ MvPolynomial.IsHomogeneous 0 n","decl":"theorem isHomogeneous_zero (n : ℕ) : IsHomogeneous (0 : MvPolynomial σ R) n :=\n  (homogeneousSubmodule σ R n).zero_mem\n\n"}
{"name":"MvPolynomial.isHomogeneous_one","module":"Mathlib.RingTheory.MvPolynomial.Homogeneous","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝ : CommSemiring R\n⊢ MvPolynomial.IsHomogeneous 1 0","decl":"theorem isHomogeneous_one : IsHomogeneous (1 : MvPolynomial σ R) 0 :=\n  isHomogeneous_C _ _\n\n"}
{"name":"MvPolynomial.isHomogeneous_X","module":"Mathlib.RingTheory.MvPolynomial.Homogeneous","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝ : CommSemiring R\ni : σ\n⊢ (MvPolynomial.X i).IsHomogeneous 1","decl":"theorem isHomogeneous_X (i : σ) : IsHomogeneous (X i : MvPolynomial σ R) 1 := by\n  apply isHomogeneous_monomial\n  rw [Finsupp.degree, Finsupp.support_single_ne_zero _ one_ne_zero, Finset.sum_singleton]\n  exact Finsupp.single_eq_same\n\n"}
{"name":"MvPolynomial.IsHomogeneous.coeff_eq_zero","module":"Mathlib.RingTheory.MvPolynomial.Homogeneous","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝ : CommSemiring R\nφ : MvPolynomial σ R\nn : Nat\nhφ : φ.IsHomogeneous n\nd : Finsupp σ Nat\nhd : Ne d.degree n\n⊢ Eq (MvPolynomial.coeff d φ) 0","decl":"theorem coeff_eq_zero (hφ : IsHomogeneous φ n) {d : σ →₀ ℕ} (hd : d.degree ≠ n) :\n    coeff d φ = 0 := by\n  rw [degree_eq_weight_one] at hd\n  exact IsWeightedHomogeneous.coeff_eq_zero hφ d hd\n\n"}
{"name":"MvPolynomial.IsHomogeneous.inj_right","module":"Mathlib.RingTheory.MvPolynomial.Homogeneous","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝ : CommSemiring R\nφ : MvPolynomial σ R\nm n : Nat\nhm : φ.IsHomogeneous m\nhn : φ.IsHomogeneous n\nhφ : Ne φ 0\n⊢ Eq m n","decl":"theorem inj_right (hm : IsHomogeneous φ m) (hn : IsHomogeneous φ n) (hφ : φ ≠ 0) : m = n := by\n  obtain ⟨d, hd⟩ : ∃ d, coeff d φ ≠ 0 := exists_coeff_ne_zero hφ\n  rw [← hm hd, ← hn hd]\n\n"}
{"name":"MvPolynomial.IsHomogeneous.add","module":"Mathlib.RingTheory.MvPolynomial.Homogeneous","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝ : CommSemiring R\nφ ψ : MvPolynomial σ R\nn : Nat\nhφ : φ.IsHomogeneous n\nhψ : ψ.IsHomogeneous n\n⊢ (HAdd.hAdd φ ψ).IsHomogeneous n","decl":"theorem add (hφ : IsHomogeneous φ n) (hψ : IsHomogeneous ψ n) : IsHomogeneous (φ + ψ) n :=\n  (homogeneousSubmodule σ R n).add_mem hφ hψ\n\n"}
{"name":"MvPolynomial.IsHomogeneous.sum","module":"Mathlib.RingTheory.MvPolynomial.Homogeneous","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝ : CommSemiring R\nι : Type u_5\ns : Finset ι\nφ : ι → MvPolynomial σ R\nn : Nat\nh : ∀ (i : ι), Membership.mem s i → (φ i).IsHomogeneous n\n⊢ (s.sum fun i => φ i).IsHomogeneous n","decl":"theorem sum {ι : Type*} (s : Finset ι) (φ : ι → MvPolynomial σ R) (n : ℕ)\n    (h : ∀ i ∈ s, IsHomogeneous (φ i) n) : IsHomogeneous (∑ i ∈ s, φ i) n :=\n  (homogeneousSubmodule σ R n).sum_mem h\n\n"}
{"name":"MvPolynomial.IsHomogeneous.mul","module":"Mathlib.RingTheory.MvPolynomial.Homogeneous","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝ : CommSemiring R\nφ ψ : MvPolynomial σ R\nm n : Nat\nhφ : φ.IsHomogeneous m\nhψ : ψ.IsHomogeneous n\n⊢ (HMul.hMul φ ψ).IsHomogeneous (HAdd.hAdd m n)","decl":"theorem mul (hφ : IsHomogeneous φ m) (hψ : IsHomogeneous ψ n) : IsHomogeneous (φ * ψ) (m + n) :=\n  homogeneousSubmodule_mul m n <| Submodule.mul_mem_mul hφ hψ\n\n"}
{"name":"MvPolynomial.IsHomogeneous.prod","module":"Mathlib.RingTheory.MvPolynomial.Homogeneous","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝ : CommSemiring R\nι : Type u_5\ns : Finset ι\nφ : ι → MvPolynomial σ R\nn : ι → Nat\nh : ∀ (i : ι), Membership.mem s i → (φ i).IsHomogeneous (n i)\n⊢ (s.prod fun i => φ i).IsHomogeneous (s.sum fun i => n i)","decl":"theorem prod {ι : Type*} (s : Finset ι) (φ : ι → MvPolynomial σ R) (n : ι → ℕ)\n    (h : ∀ i ∈ s, IsHomogeneous (φ i) (n i)) : IsHomogeneous (∏ i ∈ s, φ i) (∑ i ∈ s, n i) := by\n  classical\n  revert h\n  refine Finset.induction_on s ?_ ?_\n  · intro\n    simp only [isHomogeneous_one, Finset.sum_empty, Finset.prod_empty]\n  · intro i s his IH h\n    simp only [his, Finset.prod_insert, Finset.sum_insert, not_false_iff]\n    apply (h i (Finset.mem_insert_self _ _)).mul (IH _)\n    intro j hjs\n    exact h j (Finset.mem_insert_of_mem hjs)\n\n"}
{"name":"MvPolynomial.IsHomogeneous.C_mul","module":"Mathlib.RingTheory.MvPolynomial.Homogeneous","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝ : CommSemiring R\nφ : MvPolynomial σ R\nm : Nat\nhφ : φ.IsHomogeneous m\nr : R\n⊢ (HMul.hMul (MvPolynomial.C r) φ).IsHomogeneous m","decl":"lemma C_mul (hφ : φ.IsHomogeneous m) (r : R) :\n    (C r * φ).IsHomogeneous m := by\n  simpa only [zero_add] using (isHomogeneous_C _ _).mul hφ\n\n"}
{"name":"MvPolynomial.isHomogeneous_C_mul_X","module":"Mathlib.RingTheory.MvPolynomial.Homogeneous","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝ : CommSemiring R\nr : R\ni : σ\n⊢ (HMul.hMul (MvPolynomial.C r) (MvPolynomial.X i)).IsHomogeneous 1","decl":"lemma _root_.MvPolynomial.isHomogeneous_C_mul_X (r : R) (i : σ) :\n    (C r * X i).IsHomogeneous 1 :=\n  (isHomogeneous_X _ _).C_mul _\n\n"}
{"name":"MvPolynomial.IsHomogeneous.pow","module":"Mathlib.RingTheory.MvPolynomial.Homogeneous","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝ : CommSemiring R\nφ : MvPolynomial σ R\nm : Nat\nhφ : φ.IsHomogeneous m\nn : Nat\n⊢ (HPow.hPow φ n).IsHomogeneous (HMul.hMul m n)","decl":"lemma pow (hφ : φ.IsHomogeneous m) (n : ℕ) : (φ ^ n).IsHomogeneous (m * n) := by\n  rw [show φ ^ n = ∏ _i ∈ Finset.range n, φ by simp]\n  rw [show m * n = ∑ _i ∈ Finset.range n, m by simp [mul_comm]]\n  apply IsHomogeneous.prod _ _ _ (fun _ _ ↦ hφ)\n\n"}
{"name":"MvPolynomial.isHomogeneous_X_pow","module":"Mathlib.RingTheory.MvPolynomial.Homogeneous","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝ : CommSemiring R\ni : σ\nn : Nat\n⊢ (HPow.hPow (MvPolynomial.X i) n).IsHomogeneous n","decl":"lemma _root_.MvPolynomial.isHomogeneous_X_pow (i : σ) (n : ℕ) :\n    (X (R := R) i ^ n).IsHomogeneous n := by\n  simpa only [one_mul] using (isHomogeneous_X _ _).pow n\n\n"}
{"name":"MvPolynomial.isHomogeneous_C_mul_X_pow","module":"Mathlib.RingTheory.MvPolynomial.Homogeneous","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝ : CommSemiring R\nr : R\ni : σ\nn : Nat\n⊢ (HMul.hMul (MvPolynomial.C r) (HPow.hPow (MvPolynomial.X i) n)).IsHomogeneous n","decl":"lemma _root_.MvPolynomial.isHomogeneous_C_mul_X_pow (r : R) (i : σ) (n : ℕ) :\n    (C r * X i ^ n).IsHomogeneous n :=\n  (isHomogeneous_X_pow _ _).C_mul _\n\n"}
{"name":"MvPolynomial.IsHomogeneous.eval₂","module":"Mathlib.RingTheory.MvPolynomial.Homogeneous","initialProofState":"σ : Type u_1\nτ : Type u_2\nR : Type u_3\nS : Type u_4\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S\nφ : MvPolynomial σ R\nm n : Nat\nhφ : φ.IsHomogeneous m\nf : RingHom R (MvPolynomial τ S)\ng : σ → MvPolynomial τ S\nhf : ∀ (r : R), (f r).IsHomogeneous 0\nhg : ∀ (i : σ), (g i).IsHomogeneous n\n⊢ (MvPolynomial.eval₂ f g φ).IsHomogeneous (HMul.hMul n m)","decl":"lemma eval₂ (hφ : φ.IsHomogeneous m) (f : R →+* MvPolynomial τ S) (g : σ → MvPolynomial τ S)\n    (hf : ∀ r, (f r).IsHomogeneous 0) (hg : ∀ i, (g i).IsHomogeneous n) :\n    (eval₂ f g φ).IsHomogeneous (n * m) := by\n  apply IsHomogeneous.sum\n  intro i hi\n  rw [← zero_add (n * m)]\n  apply IsHomogeneous.mul (hf _) _\n  convert IsHomogeneous.prod _ _ (fun k ↦ n * i k) _\n  · rw [Finsupp.mem_support_iff] at hi\n    rw [← Finset.mul_sum, ← hφ hi, weight_apply]\n    simp_rw [smul_eq_mul, Finsupp.sum, Pi.one_apply, mul_one]\n  · rintro k -\n    apply (hg k).pow\n\n"}
{"name":"MvPolynomial.IsHomogeneous.map","module":"Mathlib.RingTheory.MvPolynomial.Homogeneous","initialProofState":"σ : Type u_1\nR : Type u_3\nS : Type u_4\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S\nφ : MvPolynomial σ R\nn : Nat\nhφ : φ.IsHomogeneous n\nf : RingHom R S\n⊢ ((MvPolynomial.map f) φ).IsHomogeneous n","decl":"lemma map (hφ : φ.IsHomogeneous n) (f : R →+* S) : (map f φ).IsHomogeneous n := by\n  simpa only [one_mul] using hφ.eval₂ _ _ (fun r ↦ isHomogeneous_C _ (f r)) (isHomogeneous_X _)\n\n"}
{"name":"MvPolynomial.IsHomogeneous.aeval","module":"Mathlib.RingTheory.MvPolynomial.Homogeneous","initialProofState":"σ : Type u_1\nτ : Type u_2\nR : Type u_3\nS : Type u_4\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S\nφ : MvPolynomial σ R\nm n : Nat\ninst✝ : Algebra R S\nhφ : φ.IsHomogeneous m\ng : σ → MvPolynomial τ S\nhg : ∀ (i : σ), (g i).IsHomogeneous n\n⊢ ((MvPolynomial.aeval g) φ).IsHomogeneous (HMul.hMul n m)","decl":"lemma aeval [Algebra R S] (hφ : φ.IsHomogeneous m)\n    (g : σ → MvPolynomial τ S) (hg : ∀ i, (g i).IsHomogeneous n) :\n    (aeval g φ).IsHomogeneous (n * m) :=\n  hφ.eval₂ _ _ (fun _ ↦ isHomogeneous_C _ _) hg\n\n"}
{"name":"MvPolynomial.IsHomogeneous.neg","module":"Mathlib.RingTheory.MvPolynomial.Homogeneous","initialProofState":"R : Type u_5\nσ : Type u_6\ninst✝ : CommRing R\nφ : MvPolynomial σ R\nn : Nat\nhφ : φ.IsHomogeneous n\n⊢ (Neg.neg φ).IsHomogeneous n","decl":"theorem neg (hφ : IsHomogeneous φ n) : IsHomogeneous (-φ) n :=\n  (homogeneousSubmodule σ R n).neg_mem hφ\n\n"}
{"name":"MvPolynomial.IsHomogeneous.sub","module":"Mathlib.RingTheory.MvPolynomial.Homogeneous","initialProofState":"R : Type u_5\nσ : Type u_6\ninst✝ : CommRing R\nφ ψ : MvPolynomial σ R\nn : Nat\nhφ : φ.IsHomogeneous n\nhψ : ψ.IsHomogeneous n\n⊢ (HSub.hSub φ ψ).IsHomogeneous n","decl":"theorem sub (hφ : IsHomogeneous φ n) (hψ : IsHomogeneous ψ n) : IsHomogeneous (φ - ψ) n :=\n  (homogeneousSubmodule σ R n).sub_mem hφ hψ\n\n"}
{"name":"MvPolynomial.IsHomogeneous.totalDegree_le","module":"Mathlib.RingTheory.MvPolynomial.Homogeneous","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝ : CommSemiring R\nφ : MvPolynomial σ R\nn : Nat\nhφ : φ.IsHomogeneous n\n⊢ LE.le φ.totalDegree n","decl":"/-- The homogeneous degree bounds the total degree.\n\nSee also `MvPolynomial.IsHomogeneous.totalDegree` when `φ` is non-zero. -/\nlemma totalDegree_le (hφ : IsHomogeneous φ n) : φ.totalDegree ≤ n := by\n  apply Finset.sup_le\n  intro d hd\n  rw [mem_support_iff] at hd\n  simp_rw [Finsupp.sum, ← hφ hd, weight_apply, Pi.one_apply, smul_eq_mul, mul_one, Finsupp.sum,\n    le_rfl]\n\n"}
{"name":"MvPolynomial.IsHomogeneous.totalDegree","module":"Mathlib.RingTheory.MvPolynomial.Homogeneous","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝ : CommSemiring R\nφ : MvPolynomial σ R\nn : Nat\nhφ : φ.IsHomogeneous n\nh : Ne φ 0\n⊢ Eq φ.totalDegree n","decl":"theorem totalDegree (hφ : IsHomogeneous φ n) (h : φ ≠ 0) : totalDegree φ = n := by\n  apply le_antisymm hφ.totalDegree_le\n  obtain ⟨d, hd⟩ : ∃ d, coeff d φ ≠ 0 := exists_coeff_ne_zero h\n  simp only [← hφ hd, MvPolynomial.totalDegree, Finsupp.sum]\n  replace hd := Finsupp.mem_support_iff.mpr hd\n  simp only [weight_apply, Pi.one_apply, smul_eq_mul, mul_one]\n  -- Porting note: Original proof did not define `f`\n  exact Finset.le_sup (f := fun s ↦ ∑ x ∈ s.support, s x) hd\n\n"}
{"name":"MvPolynomial.IsHomogeneous.rename_isHomogeneous","module":"Mathlib.RingTheory.MvPolynomial.Homogeneous","initialProofState":"σ : Type u_1\nτ : Type u_2\nR : Type u_3\ninst✝ : CommSemiring R\nφ : MvPolynomial σ R\nn : Nat\nf : σ → τ\nh : φ.IsHomogeneous n\n⊢ ((MvPolynomial.rename f) φ).IsHomogeneous n","decl":"theorem rename_isHomogeneous {f : σ → τ} (h : φ.IsHomogeneous n) :\n    (rename f φ).IsHomogeneous n := by\n  rw [← φ.support_sum_monomial_coeff, map_sum]; simp_rw [rename_monomial]\n  apply IsHomogeneous.sum _ _ _ fun d hd ↦ isHomogeneous_monomial _ _\n  intro d hd\n  apply (Finsupp.sum_mapDomain_index_addMonoidHom fun _ ↦ .id ℕ).trans\n  convert h (mem_support_iff.mp hd)\n  simp only [weight_apply, AddMonoidHom.id_apply, Pi.one_apply, smul_eq_mul, mul_one]\n\n"}
{"name":"MvPolynomial.IsHomogeneous.rename_isHomogeneous_iff","module":"Mathlib.RingTheory.MvPolynomial.Homogeneous","initialProofState":"σ : Type u_1\nτ : Type u_2\nR : Type u_3\ninst✝ : CommSemiring R\nφ : MvPolynomial σ R\nn : Nat\nf : σ → τ\nhf : Function.Injective f\n⊢ Iff (((MvPolynomial.rename f) φ).IsHomogeneous n) (φ.IsHomogeneous n)","decl":"theorem rename_isHomogeneous_iff {f : σ → τ} (hf : f.Injective) :\n    (rename f φ).IsHomogeneous n ↔ φ.IsHomogeneous n := by\n  refine ⟨fun h d hd ↦ ?_, rename_isHomogeneous⟩\n  convert ← @h (d.mapDomain f) _\n  · simp only [weight_apply, Pi.one_apply, smul_eq_mul, mul_one]\n    exact Finsupp.sum_mapDomain_index_inj (h := fun _ ↦ id) hf\n  · rwa [coeff_rename_mapDomain f hf]\n\n"}
{"name":"MvPolynomial.IsHomogeneous.finSuccEquiv_coeff_isHomogeneous","module":"Mathlib.RingTheory.MvPolynomial.Homogeneous","initialProofState":"R : Type u_3\ninst✝ : CommSemiring R\nN : Nat\nφ : MvPolynomial (Fin (HAdd.hAdd N 1)) R\nn : Nat\nhφ : φ.IsHomogeneous n\ni j : Nat\nh : Eq (HAdd.hAdd i j) n\n⊢ (((MvPolynomial.finSuccEquiv R N) φ).coeff i).IsHomogeneous j","decl":"lemma finSuccEquiv_coeff_isHomogeneous {N : ℕ} {φ : MvPolynomial (Fin (N+1)) R} {n : ℕ}\n    (hφ : φ.IsHomogeneous n) (i j : ℕ) (h : i + j = n) :\n    ((finSuccEquiv _ _ φ).coeff i).IsHomogeneous j := by\n  intro d hd\n  rw [finSuccEquiv_coeff_coeff] at hd\n  have h' : (weight 1) (Finsupp.cons i d) = i + j := by\n    simpa [Finset.sum_subset_zero_on_sdiff (g := d.cons i)\n     (d.cons_support (y := i)) (by simp) (fun _ _ ↦ rfl), ← h] using hφ hd\n  simp only [weight_apply, Pi.one_apply, smul_eq_mul, mul_one, Finsupp.sum_cons,\n    add_right_inj] at h' ⊢\n  exact h'\n\n-- TODO: develop API for `optionEquivLeft` and get rid of the `[Fintype σ]` assumption\n"}
{"name":"MvPolynomial.IsHomogeneous.coeff_isHomogeneous_of_optionEquivLeft_symm","module":"Mathlib.RingTheory.MvPolynomial.Homogeneous","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝ : CommSemiring R\nn : Nat\nhσ : Finite σ\np : Polynomial (MvPolynomial σ R)\nhp : ((MvPolynomial.optionEquivLeft R σ).symm p).IsHomogeneous n\ni j : Nat\nh : Eq (HAdd.hAdd i j) n\n⊢ (p.coeff i).IsHomogeneous j","decl":"lemma coeff_isHomogeneous_of_optionEquivLeft_symm\n    [hσ : Finite σ] {p : Polynomial (MvPolynomial σ R)}\n    (hp : ((optionEquivLeft R σ).symm p).IsHomogeneous n) (i j : ℕ) (h : i + j = n) :\n    (p.coeff i).IsHomogeneous j := by\n  obtain ⟨k, ⟨e⟩⟩ := Finite.exists_equiv_fin σ\n  let e' := e.optionCongr.trans (_root_.finSuccEquiv _).symm\n  let F := renameEquiv R e\n  let F' := renameEquiv R e'\n  let φ := F' ((optionEquivLeft R σ).symm p)\n  have hφ : φ.IsHomogeneous n := hp.rename_isHomogeneous\n  suffices IsHomogeneous (F (p.coeff i)) j by\n    rwa [← (IsHomogeneous.rename_isHomogeneous_iff e.injective)]\n  convert hφ.finSuccEquiv_coeff_isHomogeneous i j h using 1\n  dsimp only [φ, F', F, renameEquiv_apply]\n  rw [finSuccEquiv_rename_finSuccEquiv, AlgEquiv.apply_symm_apply]\n  simp\n\n"}
{"name":"MvPolynomial.IsHomogeneous.eq_zero_of_forall_eval_eq_zero_of_le_card","module":"Mathlib.RingTheory.MvPolynomial.Homogeneous","initialProofState":"R : Type u_5\nσ : Type u_6\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nF : MvPolynomial σ R\nn : Nat\nhF : F.IsHomogeneous n\nh : ∀ (r : σ → R), Eq ((MvPolynomial.eval r) F) 0\nhnR : LE.le (↑n) (Cardinal.mk R)\n⊢ Eq F 0","decl":"/-- See `MvPolynomial.IsHomogeneous.eq_zero_of_forall_eval_eq_zero`\nfor a version that assumes `Infinite R`. -/\nlemma eq_zero_of_forall_eval_eq_zero_of_le_card\n    (hF : F.IsHomogeneous n) (h : ∀ r : σ → R, eval r F = 0) (hnR : n ≤ #R) :\n    F = 0 := by\n  contrapose! h\n  -- reduce to the case where σ is finite\n  obtain ⟨k, f, hf, F, rfl⟩ := exists_fin_rename F\n  have hF₀ : F ≠ 0 := by rintro rfl; simp at h\n  have hF : F.IsHomogeneous n := by rwa [rename_isHomogeneous_iff hf] at hF\n  obtain ⟨r, hr⟩ := exists_eval_ne_zero_of_totalDegree_le_card_aux hF hF₀ hnR\n  obtain ⟨r, rfl⟩ := (Function.factorsThrough_iff _).mp <| (hf.factorsThrough r)\n  use r\n  rwa [eval_rename]\n\n"}
{"name":"MvPolynomial.IsHomogeneous.funext_of_le_card","module":"Mathlib.RingTheory.MvPolynomial.Homogeneous","initialProofState":"R : Type u_5\nσ : Type u_6\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nF G : MvPolynomial σ R\nn : Nat\nhF : F.IsHomogeneous n\nhG : G.IsHomogeneous n\nh : ∀ (r : σ → R), Eq ((MvPolynomial.eval r) F) ((MvPolynomial.eval r) G)\nhnR : LE.le (↑n) (Cardinal.mk R)\n⊢ Eq F G","decl":"/-- See `MvPolynomial.IsHomogeneous.funext`\nfor a version that assumes `Infinite R`. -/\nlemma funext_of_le_card (hF : F.IsHomogeneous n) (hG : G.IsHomogeneous n)\n    (h : ∀ r : σ → R, eval r F = eval r G) (hnR : n ≤ #R) :\n    F = G := by\n  rw [← sub_eq_zero]\n  apply eq_zero_of_forall_eval_eq_zero_of_le_card (hF.sub hG) _ hnR\n  simpa [sub_eq_zero] using h\n\n"}
{"name":"MvPolynomial.IsHomogeneous.eq_zero_of_forall_eval_eq_zero","module":"Mathlib.RingTheory.MvPolynomial.Homogeneous","initialProofState":"R : Type u_5\nσ : Type u_6\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : Infinite R\nF : MvPolynomial σ R\nn : Nat\nhF : F.IsHomogeneous n\nh : ∀ (r : σ → R), Eq ((MvPolynomial.eval r) F) 0\n⊢ Eq F 0","decl":"/-- See `MvPolynomial.IsHomogeneous.eq_zero_of_forall_eval_eq_zero_of_le_card`\nfor a version that assumes `n ≤ #R`. -/\nlemma eq_zero_of_forall_eval_eq_zero [Infinite R] {F : MvPolynomial σ R} {n : ℕ}\n    (hF : F.IsHomogeneous n) (h : ∀ r : σ → R, eval r F = 0) : F = 0 := by\n  apply eq_zero_of_forall_eval_eq_zero_of_le_card hF h\n  exact (Cardinal.nat_lt_aleph0 _).le.trans <| Cardinal.infinite_iff.mp ‹Infinite R›\n\n"}
{"name":"MvPolynomial.IsHomogeneous.funext","module":"Mathlib.RingTheory.MvPolynomial.Homogeneous","initialProofState":"R : Type u_5\nσ : Type u_6\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : Infinite R\nF G : MvPolynomial σ R\nn : Nat\nhF : F.IsHomogeneous n\nhG : G.IsHomogeneous n\nh : ∀ (r : σ → R), Eq ((MvPolynomial.eval r) F) ((MvPolynomial.eval r) G)\n⊢ Eq F G","decl":"/-- See `MvPolynomial.IsHomogeneous.funext_of_le_card`\nfor a version that assumes `n ≤ #R`. -/\nlemma funext [Infinite R] {F G : MvPolynomial σ R} {n : ℕ}\n    (hF : F.IsHomogeneous n) (hG : G.IsHomogeneous n)\n    (h : ∀ r : σ → R, eval r F = eval r G) : F = G := by\n  apply funext_of_le_card hF hG h\n  exact (Cardinal.nat_lt_aleph0 _).le.trans <| Cardinal.infinite_iff.mp ‹Infinite R›\n\n"}
{"name":"MvPolynomial.IsHomogeneous.HomogeneousSubmodule.gcommSemiring","module":"Mathlib.RingTheory.MvPolynomial.Homogeneous","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝ : CommSemiring R\n⊢ SetLike.GradedMonoid (MvPolynomial.homogeneousSubmodule σ R)","decl":"/-- The homogeneous submodules form a graded ring. This instance is used by `DirectSum.commSemiring`\nand `DirectSum.algebra`. -/\ninstance HomogeneousSubmodule.gcommSemiring : SetLike.GradedMonoid (homogeneousSubmodule σ R) where\n  one_mem := isHomogeneous_one σ R\n  mul_mem _ _ _ _ := IsHomogeneous.mul\n\n"}
{"name":"MvPolynomial.homogeneousComponent_mem","module":"Mathlib.RingTheory.MvPolynomial.Homogeneous","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝ : CommSemiring R\nn : Nat\nφ : MvPolynomial σ R\n⊢ Membership.mem (MvPolynomial.homogeneousSubmodule σ R n) ((MvPolynomial.homogeneousComponent n) φ)","decl":"theorem homogeneousComponent_mem  :\n    homogeneousComponent n φ ∈ homogeneousSubmodule σ R n :=\n  weightedHomogeneousComponent_mem _ φ n\n\n"}
{"name":"MvPolynomial.coeff_homogeneousComponent","module":"Mathlib.RingTheory.MvPolynomial.Homogeneous","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝ : CommSemiring R\nn : Nat\nφ : MvPolynomial σ R\nd : Finsupp σ Nat\n⊢ Eq (MvPolynomial.coeff d ((MvPolynomial.homogeneousComponent n) φ)) (ite (Eq d.degree n) (MvPolynomial.coeff d φ) 0)","decl":"theorem coeff_homogeneousComponent (d : σ →₀ ℕ) :\n    coeff d (homogeneousComponent n φ) = if d.degree = n then coeff d φ else 0 := by\n  rw [degree_eq_weight_one]\n  convert coeff_weightedHomogeneousComponent n φ d\n\n"}
{"name":"MvPolynomial.homogeneousComponent_apply","module":"Mathlib.RingTheory.MvPolynomial.Homogeneous","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝ : CommSemiring R\nn : Nat\nφ : MvPolynomial σ R\n⊢ Eq ((MvPolynomial.homogeneousComponent n) φ) ((Finset.filter (fun d => Eq d.degree n) φ.support).sum fun d => (MvPolynomial.monomial d) (MvPolynomial.coeff d φ))","decl":"theorem homogeneousComponent_apply :\n    homogeneousComponent n φ = ∑ d ∈ φ.support with d.degree = n, monomial d (coeff d φ) := by\n  simp_rw [degree_eq_weight_one]\n  convert weightedHomogeneousComponent_apply n φ\n\n"}
{"name":"MvPolynomial.homogeneousComponent_isHomogeneous","module":"Mathlib.RingTheory.MvPolynomial.Homogeneous","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝ : CommSemiring R\nn : Nat\nφ : MvPolynomial σ R\n⊢ ((MvPolynomial.homogeneousComponent n) φ).IsHomogeneous n","decl":"theorem homogeneousComponent_isHomogeneous : (homogeneousComponent n φ).IsHomogeneous n :=\n  weightedHomogeneousComponent_isWeightedHomogeneous n φ\n\n"}
{"name":"MvPolynomial.homogeneousComponent_zero","module":"Mathlib.RingTheory.MvPolynomial.Homogeneous","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝ : CommSemiring R\nφ : MvPolynomial σ R\n⊢ Eq ((MvPolynomial.homogeneousComponent 0) φ) (MvPolynomial.C (MvPolynomial.coeff 0 φ))","decl":"@[simp]\ntheorem homogeneousComponent_zero : homogeneousComponent 0 φ = C (coeff 0 φ) :=\n  weightedHomogeneousComponent_zero φ (fun _ => Nat.succ_ne_zero Nat.zero)\n\n"}
{"name":"MvPolynomial.homogeneousComponent_C_mul","module":"Mathlib.RingTheory.MvPolynomial.Homogeneous","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝ : CommSemiring R\nφ : MvPolynomial σ R\nn : Nat\nr : R\n⊢ Eq ((MvPolynomial.homogeneousComponent n) (HMul.hMul (MvPolynomial.C r) φ)) (HMul.hMul (MvPolynomial.C r) ((MvPolynomial.homogeneousComponent n) φ))","decl":"@[simp]\ntheorem homogeneousComponent_C_mul (n : ℕ) (r : R) :\n    homogeneousComponent n (C r * φ) = C r * homogeneousComponent n φ :=\n  weightedHomogeneousComponent_C_mul φ n r\n\n"}
{"name":"MvPolynomial.homogeneousComponent_eq_zero'","module":"Mathlib.RingTheory.MvPolynomial.Homogeneous","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝ : CommSemiring R\nn : Nat\nφ : MvPolynomial σ R\nh : ∀ (d : Finsupp σ Nat), Membership.mem φ.support d → Ne d.degree n\n⊢ Eq ((MvPolynomial.homogeneousComponent n) φ) 0","decl":"theorem homogeneousComponent_eq_zero'\n    (h : ∀ d : σ →₀ ℕ, d ∈ φ.support → d.degree ≠ n) :\n    homogeneousComponent n φ = 0 := by\n  simp_rw [degree_eq_weight_one] at h\n  exact weightedHomogeneousComponent_eq_zero' n φ h\n\n"}
{"name":"MvPolynomial.homogeneousComponent_eq_zero","module":"Mathlib.RingTheory.MvPolynomial.Homogeneous","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝ : CommSemiring R\nn : Nat\nφ : MvPolynomial σ R\nh : LT.lt φ.totalDegree n\n⊢ Eq ((MvPolynomial.homogeneousComponent n) φ) 0","decl":"theorem homogeneousComponent_eq_zero (h : φ.totalDegree < n) : homogeneousComponent n φ = 0 := by\n  apply homogeneousComponent_eq_zero'\n  rw [totalDegree, Finset.sup_lt_iff (lt_of_le_of_lt (Nat.zero_le _) h)] at h\n  intro d hd; exact ne_of_lt (h d hd)\n\n"}
{"name":"MvPolynomial.sum_homogeneousComponent","module":"Mathlib.RingTheory.MvPolynomial.Homogeneous","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝ : CommSemiring R\nφ : MvPolynomial σ R\n⊢ Eq ((Finset.range (HAdd.hAdd φ.totalDegree 1)).sum fun i => (MvPolynomial.homogeneousComponent i) φ) φ","decl":"theorem sum_homogeneousComponent :\n    (∑ i ∈ range (φ.totalDegree + 1), homogeneousComponent i φ) = φ := by\n  ext1 d\n  suffices φ.totalDegree < d.support.sum d → 0 = coeff d φ by\n    simpa [coeff_sum, coeff_homogeneousComponent]\n  exact fun h => (coeff_eq_zero_of_totalDegree_lt h).symm\n\n"}
{"name":"MvPolynomial.homogeneousComponent_of_mem","module":"Mathlib.RingTheory.MvPolynomial.Homogeneous","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝ : CommSemiring R\nm n : Nat\np : MvPolynomial σ R\nh : Membership.mem (MvPolynomial.homogeneousSubmodule σ R n) p\n⊢ Eq ((MvPolynomial.homogeneousComponent m) p) (ite (Eq m n) p 0)","decl":"theorem homogeneousComponent_of_mem {m n : ℕ} {p : MvPolynomial σ R}\n    (h : p ∈ homogeneousSubmodule σ R n) :\n    homogeneousComponent m p = if m = n then p else 0 :=\n  weightedHomogeneousComponent_of_mem h\n\n"}
{"name":"MvPolynomial.HomogeneousSubmodule.gradedMonoid","module":"Mathlib.RingTheory.MvPolynomial.Homogeneous","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝ : CommSemiring R\n⊢ SetLike.GradedMonoid (MvPolynomial.homogeneousSubmodule σ R)","decl":"/-- The homogeneous submodules form a graded ring.\nThis instance is used by `DirectSum.commSemiring` and `DirectSum.algebra`. -/\nlemma HomogeneousSubmodule.gradedMonoid :\n    SetLike.GradedMonoid (homogeneousSubmodule σ R) :=\n  WeightedHomogeneousSubmodule.gradedMonoid\n\n"}
{"name":"MvPolynomial.decomposition.decompose'_apply","module":"Mathlib.RingTheory.MvPolynomial.Homogeneous","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝ : CommSemiring R\nφ : MvPolynomial σ R\ni : Nat\n⊢ Eq (↑((DirectSum.Decomposition.decompose' φ) i)) ((MvPolynomial.homogeneousComponent i) φ)","decl":"theorem decomposition.decompose'_apply (φ : MvPolynomial σ R) (i : ℕ) :\n    (decomposition.decompose' φ i : MvPolynomial σ R) = homogeneousComponent i φ :=\n  weightedDecomposition.decompose'_apply R _ φ i\n\n"}
{"name":"MvPolynomial.decomposition.decompose'_eq","module":"Mathlib.RingTheory.MvPolynomial.Homogeneous","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝ : CommSemiring R\n⊢ Eq DirectSum.Decomposition.decompose' fun φ => (DirectSum.mk (fun i => Subtype fun x => Membership.mem (MvPolynomial.homogeneousSubmodule σ R i) x) (Finset.image Finsupp.degree φ.support)) fun m => ⟨(MvPolynomial.homogeneousComponent ↑m) φ, ⋯⟩","decl":"theorem decomposition.decompose'_eq :\n    decomposition.decompose' = fun φ : MvPolynomial σ R =>\n      DirectSum.mk (fun i : ℕ => ↥(homogeneousSubmodule σ R i)) (φ.support.image Finsupp.degree)\n        fun m => ⟨homogeneousComponent m φ, homogeneousComponent_mem m φ⟩ := by\n  rw [degree_eq_weight_one]\n  rfl\n\n"}
