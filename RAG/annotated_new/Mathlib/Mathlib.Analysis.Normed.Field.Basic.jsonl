{"name":"NonUnitalSeminormedRing.norm_mul","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_5\nself : NonUnitalSeminormedRing Œ±\na b : Œ±\n‚ä¢ LE.le (Norm.norm (HMul.hMul a b)) (HMul.hMul (Norm.norm a) (Norm.norm b))","decl":"/-- A non-unital seminormed ring is a not-necessarily-unital ring\nendowed with a seminorm which satisfies the inequality `‚Äñx y‚Äñ ‚â§ ‚Äñx‚Äñ ‚Äñy‚Äñ`. -/\nclass NonUnitalSeminormedRing (Œ± : Type*) extends Norm Œ±, NonUnitalRing Œ±,\n  PseudoMetricSpace Œ± where\n  /-- The distance is induced by the norm. -/\n  dist_eq : ‚àÄ x y, dist x y = norm (x - y)\n  /-- The norm is submultiplicative. -/\n  norm_mul : ‚àÄ a b, norm (a * b) ‚â§ norm a * norm b\n\n"}
{"name":"NonUnitalSeminormedRing.dist_eq","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_5\nself : NonUnitalSeminormedRing Œ±\nx y : Œ±\n‚ä¢ Eq (Dist.dist x y) (Norm.norm (HSub.hSub x y))","decl":"/-- A non-unital seminormed ring is a not-necessarily-unital ring\nendowed with a seminorm which satisfies the inequality `‚Äñx y‚Äñ ‚â§ ‚Äñx‚Äñ ‚Äñy‚Äñ`. -/\nclass NonUnitalSeminormedRing (Œ± : Type*) extends Norm Œ±, NonUnitalRing Œ±,\n  PseudoMetricSpace Œ± where\n  /-- The distance is induced by the norm. -/\n  dist_eq : ‚àÄ x y, dist x y = norm (x - y)\n  /-- The norm is submultiplicative. -/\n  norm_mul : ‚àÄ a b, norm (a * b) ‚â§ norm a * norm b\n\n"}
{"name":"SeminormedRing.dist_eq","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_5\nself : SeminormedRing Œ±\nx y : Œ±\n‚ä¢ Eq (Dist.dist x y) (Norm.norm (HSub.hSub x y))","decl":"/-- A seminormed ring is a ring endowed with a seminorm which satisfies the inequality\n`‚Äñx y‚Äñ ‚â§ ‚Äñx‚Äñ ‚Äñy‚Äñ`. -/\nclass SeminormedRing (Œ± : Type*) extends Norm Œ±, Ring Œ±, PseudoMetricSpace Œ± where\n  /-- The distance is induced by the norm. -/\n  dist_eq : ‚àÄ x y, dist x y = norm (x - y)\n  /-- The norm is submultiplicative. -/\n  norm_mul : ‚àÄ a b, norm (a * b) ‚â§ norm a * norm b\n\n-- see Note [lower instance priority]\n"}
{"name":"SeminormedRing.norm_mul","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_5\nself : SeminormedRing Œ±\na b : Œ±\n‚ä¢ LE.le (Norm.norm (HMul.hMul a b)) (HMul.hMul (Norm.norm a) (Norm.norm b))","decl":"/-- A seminormed ring is a ring endowed with a seminorm which satisfies the inequality\n`‚Äñx y‚Äñ ‚â§ ‚Äñx‚Äñ ‚Äñy‚Äñ`. -/\nclass SeminormedRing (Œ± : Type*) extends Norm Œ±, Ring Œ±, PseudoMetricSpace Œ± where\n  /-- The distance is induced by the norm. -/\n  dist_eq : ‚àÄ x y, dist x y = norm (x - y)\n  /-- The norm is submultiplicative. -/\n  norm_mul : ‚àÄ a b, norm (a * b) ‚â§ norm a * norm b\n\n-- see Note [lower instance priority]\n"}
{"name":"NonUnitalNormedRing.norm_mul","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_5\nself : NonUnitalNormedRing Œ±\na b : Œ±\n‚ä¢ LE.le (Norm.norm (HMul.hMul a b)) (HMul.hMul (Norm.norm a) (Norm.norm b))","decl":"/-- A non-unital normed ring is a not-necessarily-unital ring\nendowed with a norm which satisfies the inequality `‚Äñx y‚Äñ ‚â§ ‚Äñx‚Äñ ‚Äñy‚Äñ`. -/\nclass NonUnitalNormedRing (Œ± : Type*) extends Norm Œ±, NonUnitalRing Œ±, MetricSpace Œ± where\n  /-- The distance is induced by the norm. -/\n  dist_eq : ‚àÄ x y, dist x y = norm (x - y)\n  /-- The norm is submultiplicative. -/\n  norm_mul : ‚àÄ a b, norm (a * b) ‚â§ norm a * norm b\n\n-- see Note [lower instance priority]\n"}
{"name":"NonUnitalNormedRing.dist_eq","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_5\nself : NonUnitalNormedRing Œ±\nx y : Œ±\n‚ä¢ Eq (Dist.dist x y) (Norm.norm (HSub.hSub x y))","decl":"/-- A non-unital normed ring is a not-necessarily-unital ring\nendowed with a norm which satisfies the inequality `‚Äñx y‚Äñ ‚â§ ‚Äñx‚Äñ ‚Äñy‚Äñ`. -/\nclass NonUnitalNormedRing (Œ± : Type*) extends Norm Œ±, NonUnitalRing Œ±, MetricSpace Œ± where\n  /-- The distance is induced by the norm. -/\n  dist_eq : ‚àÄ x y, dist x y = norm (x - y)\n  /-- The norm is submultiplicative. -/\n  norm_mul : ‚àÄ a b, norm (a * b) ‚â§ norm a * norm b\n\n-- see Note [lower instance priority]\n"}
{"name":"NormedRing.dist_eq","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_5\nself : NormedRing Œ±\nx y : Œ±\n‚ä¢ Eq (Dist.dist x y) (Norm.norm (HSub.hSub x y))","decl":"/-- A normed ring is a ring endowed with a norm which satisfies the inequality `‚Äñx y‚Äñ ‚â§ ‚Äñx‚Äñ ‚Äñy‚Äñ`. -/\nclass NormedRing (Œ± : Type*) extends Norm Œ±, Ring Œ±, MetricSpace Œ± where\n  /-- The distance is induced by the norm. -/\n  dist_eq : ‚àÄ x y, dist x y = norm (x - y)\n  /-- The norm is submultiplicative. -/\n  norm_mul : ‚àÄ a b, norm (a * b) ‚â§ norm a * norm b\n\n"}
{"name":"NormedRing.norm_mul","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_5\nself : NormedRing Œ±\na b : Œ±\n‚ä¢ LE.le (Norm.norm (HMul.hMul a b)) (HMul.hMul (Norm.norm a) (Norm.norm b))","decl":"/-- A normed ring is a ring endowed with a norm which satisfies the inequality `‚Äñx y‚Äñ ‚â§ ‚Äñx‚Äñ ‚Äñy‚Äñ`. -/\nclass NormedRing (Œ± : Type*) extends Norm Œ±, Ring Œ±, MetricSpace Œ± where\n  /-- The distance is induced by the norm. -/\n  dist_eq : ‚àÄ x y, dist x y = norm (x - y)\n  /-- The norm is submultiplicative. -/\n  norm_mul : ‚àÄ a b, norm (a * b) ‚â§ norm a * norm b\n\n"}
{"name":"NormedDivisionRing.dist_eq","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_5\nself : NormedDivisionRing Œ±\nx y : Œ±\n‚ä¢ Eq (Dist.dist x y) (Norm.norm (HSub.hSub x y))","decl":"/-- A normed division ring is a division ring endowed with a seminorm which satisfies the equality\n`‚Äñx y‚Äñ = ‚Äñx‚Äñ ‚Äñy‚Äñ`. -/\nclass NormedDivisionRing (Œ± : Type*) extends Norm Œ±, DivisionRing Œ±, MetricSpace Œ± where\n  /-- The distance is induced by the norm. -/\n  dist_eq : ‚àÄ x y, dist x y = norm (x - y)\n  /-- The norm is multiplicative. -/\n  norm_mul' : ‚àÄ a b, norm (a * b) = norm a * norm b\n\n-- see Note [lower instance priority]\n"}
{"name":"NormedDivisionRing.norm_mul'","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_5\nself : NormedDivisionRing Œ±\na b : Œ±\n‚ä¢ Eq (Norm.norm (HMul.hMul a b)) (HMul.hMul (Norm.norm a) (Norm.norm b))","decl":"/-- A normed division ring is a division ring endowed with a seminorm which satisfies the equality\n`‚Äñx y‚Äñ = ‚Äñx‚Äñ ‚Äñy‚Äñ`. -/\nclass NormedDivisionRing (Œ± : Type*) extends Norm Œ±, DivisionRing Œ±, MetricSpace Œ± where\n  /-- The distance is induced by the norm. -/\n  dist_eq : ‚àÄ x y, dist x y = norm (x - y)\n  /-- The norm is multiplicative. -/\n  norm_mul' : ‚àÄ a b, norm (a * b) = norm a * norm b\n\n-- see Note [lower instance priority]\n"}
{"name":"NonUnitalSeminormedCommRing.mul_comm","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_5\nself : NonUnitalSeminormedCommRing Œ±\nx y : Œ±\n‚ä¢ Eq (HMul.hMul x y) (HMul.hMul y x)","decl":"/-- A non-unital seminormed commutative ring is a non-unital commutative ring endowed with a\nseminorm which satisfies the inequality `‚Äñx y‚Äñ ‚â§ ‚Äñx‚Äñ ‚Äñy‚Äñ`. -/\nclass NonUnitalSeminormedCommRing (Œ± : Type*) extends NonUnitalSeminormedRing Œ± where\n  /-- Multiplication is commutative. -/\n  mul_comm : ‚àÄ x y : Œ±, x * y = y * x\n\n"}
{"name":"NonUnitalNormedCommRing.mul_comm","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_5\nself : NonUnitalNormedCommRing Œ±\nx y : Œ±\n‚ä¢ Eq (HMul.hMul x y) (HMul.hMul y x)","decl":"/-- A non-unital normed commutative ring is a non-unital commutative ring endowed with a\nnorm which satisfies the inequality `‚Äñx y‚Äñ ‚â§ ‚Äñx‚Äñ ‚Äñy‚Äñ`. -/\nclass NonUnitalNormedCommRing (Œ± : Type*) extends NonUnitalNormedRing Œ± where\n  /-- Multiplication is commutative. -/\n  mul_comm : ‚àÄ x y : Œ±, x * y = y * x\n\n-- see Note [lower instance priority]\n"}
{"name":"SeminormedCommRing.mul_comm","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_5\nself : SeminormedCommRing Œ±\nx y : Œ±\n‚ä¢ Eq (HMul.hMul x y) (HMul.hMul y x)","decl":"/-- A seminormed commutative ring is a commutative ring endowed with a seminorm which satisfies\nthe inequality `‚Äñx y‚Äñ ‚â§ ‚Äñx‚Äñ ‚Äñy‚Äñ`. -/\nclass SeminormedCommRing (Œ± : Type*) extends SeminormedRing Œ± where\n  /-- Multiplication is commutative. -/\n  mul_comm : ‚àÄ x y : Œ±, x * y = y * x\n\n"}
{"name":"NormedCommRing.mul_comm","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_5\nself : NormedCommRing Œ±\nx y : Œ±\n‚ä¢ Eq (HMul.hMul x y) (HMul.hMul y x)","decl":"/-- A normed commutative ring is a commutative ring endowed with a norm which satisfies\nthe inequality `‚Äñx y‚Äñ ‚â§ ‚Äñx‚Äñ ‚Äñy‚Äñ`. -/\nclass NormedCommRing (Œ± : Type*) extends NormedRing Œ± where\n  /-- Multiplication is commutative. -/\n  mul_comm : ‚àÄ x y : Œ±, x * y = y * x\n\n-- see Note [lower instance priority]\n"}
{"name":"NormOneClass.norm_one","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_5\ninst‚úù¬π : Norm Œ±\ninst‚úù : One Œ±\nself : NormOneClass Œ±\n‚ä¢ Eq (Norm.norm 1) 1","decl":"/-- A mixin class with the axiom `‚Äñ1‚Äñ = 1`. Many `NormedRing`s and all `NormedField`s satisfy this\naxiom. -/\nclass NormOneClass (Œ± : Type*) [Norm Œ±] [One Œ±] : Prop where\n  /-- The norm of the multiplicative identity is 1. -/\n  norm_one : ‚Äñ(1 : Œ±)‚Äñ = 1\n\n"}
{"name":"nnnorm_one","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"G : Type u_1\ninst‚úù¬≤ : SeminormedAddCommGroup G\ninst‚úù¬π : One G\ninst‚úù : NormOneClass G\n‚ä¢ Eq (NNNorm.nnnorm 1) 1","decl":"@[simp] lemma nnnorm_one : ‚Äñ(1 : G)‚Äñ‚Çä = 1 := NNReal.eq norm_one\n"}
{"name":"enorm_one","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"G : Type u_1\ninst‚úù¬≤ : SeminormedAddCommGroup G\ninst‚úù¬π : One G\ninst‚úù : NormOneClass G\n‚ä¢ Eq (ENorm.enorm 1) 1","decl":"@[simp] lemma enorm_one : ‚Äñ(1 : G)‚Äñ‚Çë = 1 := by simp [enorm]\n\n"}
{"name":"NormOneClass.nontrivial","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"G : Type u_1\ninst‚úù¬≤ : SeminormedAddCommGroup G\ninst‚úù¬π : One G\ninst‚úù : NormOneClass G\n‚ä¢ Nontrivial G","decl":"theorem NormOneClass.nontrivial : Nontrivial G :=\n  nontrivial_of_ne 0 1 <| ne_of_apply_ne norm <| by simp\n\n"}
{"name":"ULift.normOneClass","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\ninst‚úù¬≤ : SeminormedAddCommGroup Œ±\ninst‚úù¬π : One Œ±\ninst‚úù : NormOneClass Œ±\n‚ä¢ NormOneClass (ULift.{u_5, u_2} Œ±)","decl":"instance ULift.normOneClass [SeminormedAddCommGroup Œ±] [One Œ±] [NormOneClass Œ±] :\n    NormOneClass (ULift Œ±) :=\n  ‚ü®by simp [ULift.norm_def]‚ü©\n\n"}
{"name":"Prod.normOneClass","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\ninst‚úù‚Åµ : SeminormedAddCommGroup Œ±\ninst‚úù‚Å¥ : One Œ±\ninst‚úù¬≥ : NormOneClass Œ±\ninst‚úù¬≤ : SeminormedAddCommGroup Œ≤\ninst‚úù¬π : One Œ≤\ninst‚úù : NormOneClass Œ≤\n‚ä¢ NormOneClass (Prod Œ± Œ≤)","decl":"instance Prod.normOneClass [SeminormedAddCommGroup Œ±] [One Œ±] [NormOneClass Œ±]\n    [SeminormedAddCommGroup Œ≤] [One Œ≤] [NormOneClass Œ≤] : NormOneClass (Œ± √ó Œ≤) :=\n  ‚ü®by simp [Prod.norm_def]‚ü©\n\n"}
{"name":"Pi.normOneClass","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œπ : Type u_5\nŒ± : Œπ ‚Üí Type u_6\ninst‚úù‚Å¥ : Nonempty Œπ\ninst‚úù¬≥ : Fintype Œπ\ninst‚úù¬≤ : (i : Œπ) ‚Üí SeminormedAddCommGroup (Œ± i)\ninst‚úù¬π : (i : Œπ) ‚Üí One (Œ± i)\ninst‚úù : ‚àÄ (i : Œπ), NormOneClass (Œ± i)\n‚ä¢ NormOneClass ((i : Œπ) ‚Üí Œ± i)","decl":"instance Pi.normOneClass {Œπ : Type*} {Œ± : Œπ ‚Üí Type*} [Nonempty Œπ] [Fintype Œπ]\n    [‚àÄ i, SeminormedAddCommGroup (Œ± i)] [‚àÄ i, One (Œ± i)] [‚àÄ i, NormOneClass (Œ± i)] :\n    NormOneClass (‚àÄ i, Œ± i) :=\n  ‚ü®by simpa [Pi.norm_def] using Finset.sup_const Finset.univ_nonempty 1‚ü©\n\n"}
{"name":"MulOpposite.normOneClass","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\ninst‚úù¬≤ : SeminormedAddCommGroup Œ±\ninst‚úù¬π : One Œ±\ninst‚úù : NormOneClass Œ±\n‚ä¢ NormOneClass (MulOpposite Œ±)","decl":"instance MulOpposite.normOneClass [SeminormedAddCommGroup Œ±] [One Œ±] [NormOneClass Œ±] :\n    NormOneClass Œ±·µê·µí·µñ :=\n  ‚ü®@norm_one Œ± _ _ _‚ü©\n\n"}
{"name":"norm_mul_le","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\ninst‚úù : NonUnitalSeminormedRing Œ±\na b : Œ±\n‚ä¢ LE.le (Norm.norm (HMul.hMul a b)) (HMul.hMul (Norm.norm a) (Norm.norm b))","decl":"theorem norm_mul_le (a b : Œ±) : ‚Äña * b‚Äñ ‚â§ ‚Äña‚Äñ * ‚Äñb‚Äñ :=\n  NonUnitalSeminormedRing.norm_mul _ _\n\n"}
{"name":"nnnorm_mul_le","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\ninst‚úù : NonUnitalSeminormedRing Œ±\na b : Œ±\n‚ä¢ LE.le (NNNorm.nnnorm (HMul.hMul a b)) (HMul.hMul (NNNorm.nnnorm a) (NNNorm.nnnorm b))","decl":"theorem nnnorm_mul_le (a b : Œ±) : ‚Äña * b‚Äñ‚Çä ‚â§ ‚Äña‚Äñ‚Çä * ‚Äñb‚Äñ‚Çä := by\n  simpa only [‚Üê norm_toNNReal, ‚Üê Real.toNNReal_mul (norm_nonneg _)] using\n    Real.toNNReal_mono (norm_mul_le _ _)\n\n"}
{"name":"norm_mul_le_of_le","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\ninst‚úù : NonUnitalSeminormedRing Œ±\na‚ÇÅ a‚ÇÇ : Œ±\nr‚ÇÅ r‚ÇÇ : Real\nh‚ÇÅ : LE.le (Norm.norm a‚ÇÅ) r‚ÇÅ\nh‚ÇÇ : LE.le (Norm.norm a‚ÇÇ) r‚ÇÇ\n‚ä¢ LE.le (Norm.norm (HMul.hMul a‚ÇÅ a‚ÇÇ)) (HMul.hMul r‚ÇÅ r‚ÇÇ)","decl":"lemma norm_mul_le_of_le {r‚ÇÅ r‚ÇÇ : ‚Ñù} (h‚ÇÅ : ‚Äña‚ÇÅ‚Äñ ‚â§ r‚ÇÅ) (h‚ÇÇ : ‚Äña‚ÇÇ‚Äñ ‚â§ r‚ÇÇ) : ‚Äña‚ÇÅ * a‚ÇÇ‚Äñ ‚â§ r‚ÇÅ * r‚ÇÇ :=\n  (norm_mul_le ..).trans <| mul_le_mul h‚ÇÅ h‚ÇÇ (norm_nonneg _) ((norm_nonneg _).trans h‚ÇÅ)\n\n"}
{"name":"nnnorm_mul_le_of_le","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\ninst‚úù : NonUnitalSeminormedRing Œ±\na‚ÇÅ a‚ÇÇ : Œ±\nr‚ÇÅ r‚ÇÇ : NNReal\nh‚ÇÅ : LE.le (NNNorm.nnnorm a‚ÇÅ) r‚ÇÅ\nh‚ÇÇ : LE.le (NNNorm.nnnorm a‚ÇÇ) r‚ÇÇ\n‚ä¢ LE.le (NNNorm.nnnorm (HMul.hMul a‚ÇÅ a‚ÇÇ)) (HMul.hMul r‚ÇÅ r‚ÇÇ)","decl":"lemma nnnorm_mul_le_of_le {r‚ÇÅ r‚ÇÇ : ‚Ñù‚â•0} (h‚ÇÅ : ‚Äña‚ÇÅ‚Äñ‚Çä ‚â§ r‚ÇÅ) (h‚ÇÇ : ‚Äña‚ÇÇ‚Äñ‚Çä ‚â§ r‚ÇÇ) :\n    ‚Äña‚ÇÅ * a‚ÇÇ‚Äñ‚Çä ‚â§ r‚ÇÅ * r‚ÇÇ := (nnnorm_mul_le ..).trans <| mul_le_mul' h‚ÇÅ h‚ÇÇ\n\n"}
{"name":"norm_mul‚ÇÉ_le","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\ninst‚úù : NonUnitalSeminormedRing Œ±\na b c : Œ±\n‚ä¢ LE.le (Norm.norm (HMul.hMul (HMul.hMul a b) c)) (HMul.hMul (HMul.hMul (Norm.norm a) (Norm.norm b)) (Norm.norm c))","decl":"lemma norm_mul‚ÇÉ_le : ‚Äña * b * c‚Äñ ‚â§ ‚Äña‚Äñ * ‚Äñb‚Äñ * ‚Äñc‚Äñ := norm_mul_le_of_le (norm_mul_le ..) le_rfl\n\n"}
{"name":"nnnorm_mul‚ÇÉ_le","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\ninst‚úù : NonUnitalSeminormedRing Œ±\na b c : Œ±\n‚ä¢ LE.le (NNNorm.nnnorm (HMul.hMul (HMul.hMul a b) c)) (HMul.hMul (HMul.hMul (NNNorm.nnnorm a) (NNNorm.nnnorm b)) (NNNorm.nnnorm c))","decl":"lemma nnnorm_mul‚ÇÉ_le : ‚Äña * b * c‚Äñ‚Çä ‚â§ ‚Äña‚Äñ‚Çä * ‚Äñb‚Äñ‚Çä * ‚Äñc‚Äñ‚Çä :=\n  nnnorm_mul_le_of_le (norm_mul_le ..) le_rfl\n\n"}
{"name":"one_le_norm_one","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ≤ : Type u_5\ninst‚úù¬π : NormedRing Œ≤\ninst‚úù : Nontrivial Œ≤\n‚ä¢ LE.le 1 (Norm.norm 1)","decl":"theorem one_le_norm_one (Œ≤) [NormedRing Œ≤] [Nontrivial Œ≤] : 1 ‚â§ ‚Äñ(1 : Œ≤)‚Äñ :=\n  (le_mul_iff_one_le_left <| norm_pos_iff.mpr (one_ne_zero : (1 : Œ≤) ‚â† 0)).mp\n    (by simpa only [mul_one] using norm_mul_le (1 : Œ≤) 1)\n\n"}
{"name":"one_le_nnnorm_one","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ≤ : Type u_5\ninst‚úù¬π : NormedRing Œ≤\ninst‚úù : Nontrivial Œ≤\n‚ä¢ LE.le 1 (NNNorm.nnnorm 1)","decl":"theorem one_le_nnnorm_one (Œ≤) [NormedRing Œ≤] [Nontrivial Œ≤] : 1 ‚â§ ‚Äñ(1 : Œ≤)‚Äñ‚Çä :=\n  one_le_norm_one Œ≤\n\n"}
{"name":"mulLeft_bound","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\ninst‚úù : NonUnitalSeminormedRing Œ±\nx y : Œ±\n‚ä¢ LE.le (Norm.norm ((AddMonoidHom.mulLeft x) y)) (HMul.hMul (Norm.norm x) (Norm.norm y))","decl":"/-- In a seminormed ring, the left-multiplication `AddMonoidHom` is bounded. -/\ntheorem mulLeft_bound (x : Œ±) : ‚àÄ y : Œ±, ‚ÄñAddMonoidHom.mulLeft x y‚Äñ ‚â§ ‚Äñx‚Äñ * ‚Äñy‚Äñ :=\n  norm_mul_le x\n\n"}
{"name":"mulRight_bound","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\ninst‚úù : NonUnitalSeminormedRing Œ±\nx y : Œ±\n‚ä¢ LE.le (Norm.norm ((AddMonoidHom.mulRight x) y)) (HMul.hMul (Norm.norm x) (Norm.norm y))","decl":"/-- In a seminormed ring, the right-multiplication `AddMonoidHom` is bounded. -/\ntheorem mulRight_bound (x : Œ±) : ‚àÄ y : Œ±, ‚ÄñAddMonoidHom.mulRight x y‚Äñ ‚â§ ‚Äñx‚Äñ * ‚Äñy‚Äñ := fun y => by\n  rw [mul_comm]\n  exact norm_mul_le y x\n\n"}
{"name":"Nat.norm_cast_le","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\ninst‚úù : SeminormedRing Œ±\nn : Nat\n‚ä¢ LE.le (Norm.norm ‚Üën) (HMul.hMul (‚Üën) (Norm.norm 1))","decl":"theorem Nat.norm_cast_le : ‚àÄ n : ‚Ñï, ‚Äñ(n : Œ±)‚Äñ ‚â§ n * ‚Äñ(1 : Œ±)‚Äñ\n  | 0 => by simp\n  | n + 1 => by\n    rw [n.cast_succ, n.cast_succ, add_mul, one_mul]\n    exact norm_add_le_of_le (Nat.norm_cast_le n) le_rfl\n\n"}
{"name":"List.norm_prod_le'","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\ninst‚úù : SeminormedRing Œ±\nl : List Œ±\na‚úù : Ne l List.nil\n‚ä¢ LE.le (Norm.norm l.prod) (List.map Norm.norm l).prod","decl":"theorem List.norm_prod_le' : ‚àÄ {l : List Œ±}, l ‚â† [] ‚Üí ‚Äñl.prod‚Äñ ‚â§ (l.map norm).prod\n  | [], h => (h rfl).elim\n  | [a], _ => by simp\n  | a::b::l, _ => by\n    rw [List.map_cons, List.prod_cons, List.prod_cons (a := ‚Äña‚Äñ)]\n    refine le_trans (norm_mul_le _ _) (mul_le_mul_of_nonneg_left ?_ (norm_nonneg _))\n    exact List.norm_prod_le' (List.cons_ne_nil b l)\n\n"}
{"name":"List.nnnorm_prod_le'","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\ninst‚úù : SeminormedRing Œ±\nl : List Œ±\nhl : Ne l List.nil\n‚ä¢ LE.le (NNNorm.nnnorm l.prod) (List.map NNNorm.nnnorm l).prod","decl":"theorem List.nnnorm_prod_le' {l : List Œ±} (hl : l ‚â† []) : ‚Äñl.prod‚Äñ‚Çä ‚â§ (l.map nnnorm).prod :=\n  (List.norm_prod_le' hl).trans_eq <| by simp [NNReal.coe_list_prod, List.map_map]\n\n"}
{"name":"List.norm_prod_le","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\ninst‚úù¬π : SeminormedRing Œ±\ninst‚úù : NormOneClass Œ±\nl : List Œ±\n‚ä¢ LE.le (Norm.norm l.prod) (List.map Norm.norm l).prod","decl":"theorem List.norm_prod_le [NormOneClass Œ±] : ‚àÄ l : List Œ±, ‚Äñl.prod‚Äñ ‚â§ (l.map norm).prod\n  | [] => by simp\n  | a::l => List.norm_prod_le' (List.cons_ne_nil a l)\n\n"}
{"name":"List.nnnorm_prod_le","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\ninst‚úù¬π : SeminormedRing Œ±\ninst‚úù : NormOneClass Œ±\nl : List Œ±\n‚ä¢ LE.le (NNNorm.nnnorm l.prod) (List.map NNNorm.nnnorm l).prod","decl":"theorem List.nnnorm_prod_le [NormOneClass Œ±] (l : List Œ±) : ‚Äñl.prod‚Äñ‚Çä ‚â§ (l.map nnnorm).prod :=\n  l.norm_prod_le.trans_eq <| by simp [NNReal.coe_list_prod, List.map_map]\n\n"}
{"name":"Finset.norm_prod_le'","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œπ : Type u_4\nŒ± : Type u_5\ninst‚úù : NormedCommRing Œ±\ns : Finset Œπ\nhs : s.Nonempty\nf : Œπ ‚Üí Œ±\n‚ä¢ LE.le (Norm.norm (s.prod fun i => f i)) (s.prod fun i => Norm.norm (f i))","decl":"theorem Finset.norm_prod_le' {Œ± : Type*} [NormedCommRing Œ±] (s : Finset Œπ) (hs : s.Nonempty)\n    (f : Œπ ‚Üí Œ±) : ‚Äñ‚àè i ‚àà s, f i‚Äñ ‚â§ ‚àè i ‚àà s, ‚Äñf i‚Äñ := by\n  rcases s with ‚ü®‚ü®l‚ü©, hl‚ü©\n  have : l.map f ‚â† [] := by simpa using hs\n  simpa using List.norm_prod_le' this\n\n"}
{"name":"Finset.nnnorm_prod_le'","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œπ : Type u_4\nŒ± : Type u_5\ninst‚úù : NormedCommRing Œ±\ns : Finset Œπ\nhs : s.Nonempty\nf : Œπ ‚Üí Œ±\n‚ä¢ LE.le (NNNorm.nnnorm (s.prod fun i => f i)) (s.prod fun i => NNNorm.nnnorm (f i))","decl":"theorem Finset.nnnorm_prod_le' {Œ± : Type*} [NormedCommRing Œ±] (s : Finset Œπ) (hs : s.Nonempty)\n    (f : Œπ ‚Üí Œ±) : ‚Äñ‚àè i ‚àà s, f i‚Äñ‚Çä ‚â§ ‚àè i ‚àà s, ‚Äñf i‚Äñ‚Çä :=\n  (s.norm_prod_le' hs f).trans_eq <| by simp [NNReal.coe_prod]\n\n"}
{"name":"Finset.norm_prod_le","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œπ : Type u_4\nŒ± : Type u_5\ninst‚úù¬π : NormedCommRing Œ±\ninst‚úù : NormOneClass Œ±\ns : Finset Œπ\nf : Œπ ‚Üí Œ±\n‚ä¢ LE.le (Norm.norm (s.prod fun i => f i)) (s.prod fun i => Norm.norm (f i))","decl":"theorem Finset.norm_prod_le {Œ± : Type*} [NormedCommRing Œ±] [NormOneClass Œ±] (s : Finset Œπ)\n    (f : Œπ ‚Üí Œ±) : ‚Äñ‚àè i ‚àà s, f i‚Äñ ‚â§ ‚àè i ‚àà s, ‚Äñf i‚Äñ := by\n  rcases s with ‚ü®‚ü®l‚ü©, hl‚ü©\n  simpa using (l.map f).norm_prod_le\n\n"}
{"name":"Finset.nnnorm_prod_le","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œπ : Type u_4\nŒ± : Type u_5\ninst‚úù¬π : NormedCommRing Œ±\ninst‚úù : NormOneClass Œ±\ns : Finset Œπ\nf : Œπ ‚Üí Œ±\n‚ä¢ LE.le (NNNorm.nnnorm (s.prod fun i => f i)) (s.prod fun i => NNNorm.nnnorm (f i))","decl":"theorem Finset.nnnorm_prod_le {Œ± : Type*} [NormedCommRing Œ±] [NormOneClass Œ±] (s : Finset Œπ)\n    (f : Œπ ‚Üí Œ±) : ‚Äñ‚àè i ‚àà s, f i‚Äñ‚Çä ‚â§ ‚àè i ‚àà s, ‚Äñf i‚Äñ‚Çä :=\n  (s.norm_prod_le f).trans_eq <| by simp [NNReal.coe_prod]\n\n"}
{"name":"nnnorm_pow_le'","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\ninst‚úù : SeminormedRing Œ±\na : Œ±\nn : Nat\na‚úù : LT.lt 0 n\n‚ä¢ LE.le (NNNorm.nnnorm (HPow.hPow a n)) (HPow.hPow (NNNorm.nnnorm a) n)","decl":"/-- If `Œ±` is a seminormed ring, then `‚Äña ^ n‚Äñ‚Çä ‚â§ ‚Äña‚Äñ‚Çä ^ n` for `n > 0`.\nSee also `nnnorm_pow_le`. -/\ntheorem nnnorm_pow_le' (a : Œ±) : ‚àÄ {n : ‚Ñï}, 0 < n ‚Üí ‚Äña ^ n‚Äñ‚Çä ‚â§ ‚Äña‚Äñ‚Çä ^ n\n  | 1, _ => by simp only [pow_one, le_rfl]\n  | n + 2, _ => by\n    simpa only [pow_succ' _ (n + 1)] using\n      le_trans (nnnorm_mul_le _ _) (mul_le_mul_left' (nnnorm_pow_le' a n.succ_pos) _)\n\n"}
{"name":"nnnorm_pow_le","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\ninst‚úù¬π : SeminormedRing Œ±\ninst‚úù : NormOneClass Œ±\na : Œ±\nn : Nat\n‚ä¢ LE.le (NNNorm.nnnorm (HPow.hPow a n)) (HPow.hPow (NNNorm.nnnorm a) n)","decl":"/-- If `Œ±` is a seminormed ring with `‚Äñ1‚Äñ‚Çä = 1`, then `‚Äña ^ n‚Äñ‚Çä ‚â§ ‚Äña‚Äñ‚Çä ^ n`.\nSee also `nnnorm_pow_le'`. -/\ntheorem nnnorm_pow_le [NormOneClass Œ±] (a : Œ±) (n : ‚Ñï) : ‚Äña ^ n‚Äñ‚Çä ‚â§ ‚Äña‚Äñ‚Çä ^ n :=\n  Nat.recOn n (by simp only [pow_zero, nnnorm_one, le_rfl])\n    fun k _hk => nnnorm_pow_le' a k.succ_pos\n\n"}
{"name":"norm_pow_le'","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\ninst‚úù : SeminormedRing Œ±\na : Œ±\nn : Nat\nh : LT.lt 0 n\n‚ä¢ LE.le (Norm.norm (HPow.hPow a n)) (HPow.hPow (Norm.norm a) n)","decl":"/-- If `Œ±` is a seminormed ring, then `‚Äña ^ n‚Äñ ‚â§ ‚Äña‚Äñ ^ n` for `n > 0`. See also `norm_pow_le`. -/\ntheorem norm_pow_le' (a : Œ±) {n : ‚Ñï} (h : 0 < n) : ‚Äña ^ n‚Äñ ‚â§ ‚Äña‚Äñ ^ n := by\n  simpa only [NNReal.coe_pow, coe_nnnorm] using NNReal.coe_mono (nnnorm_pow_le' a h)\n\n"}
{"name":"norm_pow_le","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\ninst‚úù¬π : SeminormedRing Œ±\ninst‚úù : NormOneClass Œ±\na : Œ±\nn : Nat\n‚ä¢ LE.le (Norm.norm (HPow.hPow a n)) (HPow.hPow (Norm.norm a) n)","decl":"/-- If `Œ±` is a seminormed ring with `‚Äñ1‚Äñ = 1`, then `‚Äña ^ n‚Äñ ‚â§ ‚Äña‚Äñ ^ n`.\nSee also `norm_pow_le'`. -/\ntheorem norm_pow_le [NormOneClass Œ±] (a : Œ±) (n : ‚Ñï) : ‚Äña ^ n‚Äñ ‚â§ ‚Äña‚Äñ ^ n :=\n  Nat.recOn n (by simp only [pow_zero, norm_one, le_rfl])\n    fun n _hn => norm_pow_le' a n.succ_pos\n\n"}
{"name":"eventually_norm_pow_le","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\ninst‚úù : SeminormedRing Œ±\na : Œ±\n‚ä¢ Filter.Eventually (fun n => LE.le (Norm.norm (HPow.hPow a n)) (HPow.hPow (Norm.norm a) n)) Filter.atTop","decl":"theorem eventually_norm_pow_le (a : Œ±) : ‚àÄ·∂† n : ‚Ñï in atTop, ‚Äña ^ n‚Äñ ‚â§ ‚Äña‚Äñ ^ n :=\n  eventually_atTop.mpr ‚ü®1, fun _b h => norm_pow_le' a (Nat.succ_le_iff.mp h)‚ü©\n\n"}
{"name":"norm_sub_mul_le","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\ninst‚úù : SeminormedRing Œ±\na b c : Œ±\nha : LE.le (Norm.norm a) 1\n‚ä¢ LE.le (Norm.norm (HSub.hSub c (HMul.hMul a b))) (HAdd.hAdd (Norm.norm (HSub.hSub c a)) (Norm.norm (HSub.hSub 1 b)))","decl":"/-- This inequality is particularly useful when `c = 1` and `‚Äña‚Äñ = ‚Äñb‚Äñ = 1` as it then shows that\nchord length is a metric on the unit complex numbers. -/\nlemma norm_sub_mul_le (ha : ‚Äña‚Äñ ‚â§ 1) : ‚Äñc - a * b‚Äñ ‚â§ ‚Äñc - a‚Äñ + ‚Äñ1 - b‚Äñ :=\n  calc\n    _ ‚â§ ‚Äñc - a‚Äñ + ‚Äña * (1 - b)‚Äñ := by\n        simpa [mul_one_sub] using norm_sub_le_norm_sub_add_norm_sub c a (a * b)\n    _ ‚â§ ‚Äñc - a‚Äñ + ‚Äña‚Äñ * ‚Äñ1 - b‚Äñ := by gcongr; exact norm_mul_le ..\n    _ ‚â§ ‚Äñc - a‚Äñ + 1 * ‚Äñ1 - b‚Äñ := by gcongr\n    _ = ‚Äñc - a‚Äñ + ‚Äñ1 - b‚Äñ := by simp\n\n"}
{"name":"norm_sub_mul_le'","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\ninst‚úù : SeminormedRing Œ±\na b c : Œ±\nhb : LE.le (Norm.norm b) 1\n‚ä¢ LE.le (Norm.norm (HSub.hSub c (HMul.hMul a b))) (HAdd.hAdd (Norm.norm (HSub.hSub 1 a)) (Norm.norm (HSub.hSub c b)))","decl":"/-- This inequality is particularly useful when `c = 1` and `‚Äña‚Äñ = ‚Äñb‚Äñ = 1` as it then shows that\nchord length is a metric on the unit complex numbers. -/\nlemma norm_sub_mul_le' (hb : ‚Äñb‚Äñ ‚â§ 1) : ‚Äñc - a * b‚Äñ ‚â§ ‚Äñ1 - a‚Äñ + ‚Äñc - b‚Äñ := by\n  rw [add_comm]; exact norm_sub_mul_le (Œ± := Œ±·µê·µí·µñ) hb\n\n"}
{"name":"nnnorm_sub_mul_le","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\ninst‚úù : SeminormedRing Œ±\na b c : Œ±\nha : LE.le (NNNorm.nnnorm a) 1\n‚ä¢ LE.le (NNNorm.nnnorm (HSub.hSub c (HMul.hMul a b))) (HAdd.hAdd (NNNorm.nnnorm (HSub.hSub c a)) (NNNorm.nnnorm (HSub.hSub 1 b)))","decl":"/-- This inequality is particularly useful when `c = 1` and `‚Äña‚Äñ = ‚Äñb‚Äñ = 1` as it then shows that\nchord length is a metric on the unit complex numbers. -/\nlemma nnnorm_sub_mul_le (ha : ‚Äña‚Äñ‚Çä ‚â§ 1) : ‚Äñc - a * b‚Äñ‚Çä ‚â§ ‚Äñc - a‚Äñ‚Çä + ‚Äñ1 - b‚Äñ‚Çä := norm_sub_mul_le ha\n\n"}
{"name":"nnnorm_sub_mul_le'","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\ninst‚úù : SeminormedRing Œ±\na b c : Œ±\nhb : LE.le (NNNorm.nnnorm b) 1\n‚ä¢ LE.le (NNNorm.nnnorm (HSub.hSub c (HMul.hMul a b))) (HAdd.hAdd (NNNorm.nnnorm (HSub.hSub 1 a)) (NNNorm.nnnorm (HSub.hSub c b)))","decl":"/-- This inequality is particularly useful when `c = 1` and `‚Äña‚Äñ = ‚Äñb‚Äñ = 1` as it then shows that\nchord length is a metric on the unit complex numbers. -/\nlemma nnnorm_sub_mul_le' (hb : ‚Äñb‚Äñ‚Çä ‚â§ 1) : ‚Äñc - a * b‚Äñ‚Çä ‚â§ ‚Äñ1 - a‚Äñ‚Çä + ‚Äñc - b‚Äñ‚Çä := norm_sub_mul_le' hb\n\n"}
{"name":"norm_commutator_units_sub_one_le","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\ninst‚úù : SeminormedRing Œ±\na b : Units Œ±\n‚ä¢ LE.le (Norm.norm (HSub.hSub (‚Üë(HMul.hMul (HMul.hMul (HMul.hMul a b) (Inv.inv a)) (Inv.inv b))) 1)) (HMul.hMul (HMul.hMul (HMul.hMul (HMul.hMul 2 (Norm.norm ‚Üë(Inv.inv a))) (Norm.norm ‚Üë(Inv.inv b))) (Norm.norm (HSub.hSub (‚Üëa) 1))) (Norm.norm (HSub.hSub (‚Üëb) 1)))","decl":"lemma norm_commutator_units_sub_one_le (a b : Œ±À£) :\n    ‚Äñ(a * b * a‚Åª¬π * b‚Åª¬π).val - 1‚Äñ ‚â§ 2 * ‚Äña‚Åª¬π.val‚Äñ * ‚Äñb‚Åª¬π.val‚Äñ * ‚Äña.val - 1‚Äñ * ‚Äñb.val - 1‚Äñ :=\n  calc\n    ‚Äñ(a * b * a‚Åª¬π * b‚Åª¬π).val - 1‚Äñ = ‚Äñ(a * b - b * a) * a‚Åª¬π.val * b‚Åª¬π.val‚Äñ := by simp [sub_mul, *]\n    _ ‚â§ ‚Äñ(a * b - b * a : Œ±)‚Äñ * ‚Äña‚Åª¬π.val‚Äñ * ‚Äñb‚Åª¬π.val‚Äñ := norm_mul‚ÇÉ_le\n    _ = ‚Äñ(a - 1 : Œ±) * (b - 1) - (b - 1) * (a - 1)‚Äñ * ‚Äña‚Åª¬π.val‚Äñ * ‚Äñb‚Åª¬π.val‚Äñ := by\n      simp_rw [sub_one_mul, mul_sub_one]; abel_nf\n    _ ‚â§ (‚Äñ(a - 1 : Œ±) * (b - 1)‚Äñ + ‚Äñ(b - 1 : Œ±) * (a - 1)‚Äñ) * ‚Äña‚Åª¬π.val‚Äñ * ‚Äñb‚Åª¬π.val‚Äñ := by\n      gcongr; exact norm_sub_le ..\n    _ ‚â§ (‚Äña.val - 1‚Äñ * ‚Äñb.val - 1‚Äñ + ‚Äñb.val - 1‚Äñ * ‚Äña.val - 1‚Äñ) * ‚Äña‚Åª¬π.val‚Äñ * ‚Äñb‚Åª¬π.val‚Äñ := by\n      gcongr <;> exact norm_mul_le ..\n    _ = 2 * ‚Äña‚Åª¬π.val‚Äñ * ‚Äñb‚Åª¬π.val‚Äñ * ‚Äña.val - 1‚Äñ * ‚Äñb.val - 1‚Äñ := by ring\n\n"}
{"name":"nnnorm_commutator_units_sub_one_le","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\ninst‚úù : SeminormedRing Œ±\na b : Units Œ±\n‚ä¢ LE.le (NNNorm.nnnorm (HSub.hSub (‚Üë(HMul.hMul (HMul.hMul (HMul.hMul a b) (Inv.inv a)) (Inv.inv b))) 1)) (HMul.hMul (HMul.hMul (HMul.hMul (HMul.hMul 2 (NNNorm.nnnorm ‚Üë(Inv.inv a))) (NNNorm.nnnorm ‚Üë(Inv.inv b))) (NNNorm.nnnorm (HSub.hSub (‚Üëa) 1))) (NNNorm.nnnorm (HSub.hSub (‚Üëb) 1)))","decl":"lemma nnnorm_commutator_units_sub_one_le (a b : Œ±À£) :\n    ‚Äñ(a * b * a‚Åª¬π * b‚Åª¬π).val - 1‚Äñ‚Çä ‚â§ 2 * ‚Äña‚Åª¬π.val‚Äñ‚Çä * ‚Äñb‚Åª¬π.val‚Äñ‚Çä * ‚Äña.val - 1‚Äñ‚Çä * ‚Äñb.val - 1‚Äñ‚Çä := by\n  simpa using norm_commutator_units_sub_one_le a b\n\n"}
{"name":"Units.norm_pos","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\ninst‚úù¬π : NormedRing Œ±\ninst‚úù : Nontrivial Œ±\nx : Units Œ±\n‚ä¢ LT.lt 0 (Norm.norm ‚Üëx)","decl":"theorem Units.norm_pos [Nontrivial Œ±] (x : Œ±À£) : 0 < ‚Äñ(x : Œ±)‚Äñ :=\n  norm_pos_iff.mpr (Units.ne_zero x)\n\n"}
{"name":"Units.nnnorm_pos","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\ninst‚úù¬π : NormedRing Œ±\ninst‚úù : Nontrivial Œ±\nx : Units Œ±\n‚ä¢ LT.lt 0 (NNNorm.nnnorm ‚Üëx)","decl":"theorem Units.nnnorm_pos [Nontrivial Œ±] (x : Œ±À£) : 0 < ‚Äñ(x : Œ±)‚Äñ‚Çä :=\n  x.norm_pos\n\n"}
{"name":"IsPowMul.restriction","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"R : Type u_5\nS : Type u_6\ninst‚úù¬≤ : NormedCommRing R\ninst‚úù¬π : CommRing S\ninst‚úù : Algebra R S\nA : Subalgebra R S\nf : S ‚Üí Real\nhf_pm : IsPowMul f\n‚ä¢ IsPowMul fun x => f ‚Üëx","decl":"/-- The restriction of a power-multiplicative function to a subalgebra is power-multiplicative. -/\ntheorem IsPowMul.restriction {R S : Type*} [NormedCommRing R] [CommRing S] [Algebra R S]\n    (A : Subalgebra R S) {f : S ‚Üí ‚Ñù} (hf_pm : IsPowMul f) :\n    IsPowMul fun x : A => f x.val := fun x n hn => by\n  simpa [SubsemiringClass.coe_pow] using hf_pm (‚Üëx) hn\n\n"}
{"name":"norm_mul","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\ninst‚úù : NormedDivisionRing Œ±\na b : Œ±\n‚ä¢ Eq (Norm.norm (HMul.hMul a b)) (HMul.hMul (Norm.norm a) (Norm.norm b))","decl":"@[simp]\ntheorem norm_mul (a b : Œ±) : ‚Äña * b‚Äñ = ‚Äña‚Äñ * ‚Äñb‚Äñ :=\n  NormedDivisionRing.norm_mul' a b\n\n"}
{"name":"NormedDivisionRing.to_normOneClass","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\ninst‚úù : NormedDivisionRing Œ±\n‚ä¢ NormOneClass Œ±","decl":"instance (priority := 900) NormedDivisionRing.to_normOneClass : NormOneClass Œ± :=\n  ‚ü®mul_left_cancel‚ÇÄ (mt norm_eq_zero.1 (one_ne_zero' Œ±)) <| by rw [‚Üê norm_mul, mul_one, mul_one]‚ü©\n\n"}
{"name":"isAbsoluteValue_norm","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\ninst‚úù : NormedDivisionRing Œ±\n‚ä¢ IsAbsoluteValue Norm.norm","decl":"instance isAbsoluteValue_norm : IsAbsoluteValue (norm : Œ± ‚Üí ‚Ñù) where\n  abv_nonneg' := norm_nonneg\n  abv_eq_zero' := norm_eq_zero\n  abv_add' := norm_add_le\n  abv_mul' := norm_mul\n\n"}
{"name":"nnnorm_mul","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\ninst‚úù : NormedDivisionRing Œ±\na b : Œ±\n‚ä¢ Eq (NNNorm.nnnorm (HMul.hMul a b)) (HMul.hMul (NNNorm.nnnorm a) (NNNorm.nnnorm b))","decl":"@[simp] lemma nnnorm_mul (a b : Œ±) : ‚Äña * b‚Äñ‚Çä = ‚Äña‚Äñ‚Çä * ‚Äñb‚Äñ‚Çä := NNReal.eq <| norm_mul a b\n"}
{"name":"enorm_mul","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\ninst‚úù : NormedDivisionRing Œ±\na b : Œ±\n‚ä¢ Eq (ENorm.enorm (HMul.hMul a b)) (HMul.hMul (ENorm.enorm a) (ENorm.enorm b))","decl":"@[simp] lemma enorm_mul (a b : Œ±) : ‚Äña * b‚Äñ‚Çë = ‚Äña‚Äñ‚Çë * ‚Äñb‚Äñ‚Çë := by simp [enorm]\n\n"}
{"name":"normHom_apply","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\ninst‚úù : NormedDivisionRing Œ±\nx‚úù : Œ±\n‚ä¢ Eq (normHom x‚úù) (Norm.norm x‚úù)","decl":"/-- `norm` as a `MonoidWithZeroHom`. -/\n@[simps]\ndef normHom : Œ± ‚Üí*‚ÇÄ ‚Ñù where\n  toFun := (‚Äñ¬∑‚Äñ)\n  map_zero' := norm_zero\n  map_one' := norm_one\n  map_mul' := norm_mul\n\n"}
{"name":"nnnormHom_apply","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\ninst‚úù : NormedDivisionRing Œ±\nx‚úù : Œ±\n‚ä¢ Eq (nnnormHom x‚úù) (NNNorm.nnnorm x‚úù)","decl":"/-- `nnnorm` as a `MonoidWithZeroHom`. -/\n@[simps]\ndef nnnormHom : Œ± ‚Üí*‚ÇÄ ‚Ñù‚â•0 where\n  toFun := (‚Äñ¬∑‚Äñ‚Çä)\n  map_zero' := nnnorm_zero\n  map_one' := nnnorm_one\n  map_mul' := nnnorm_mul\n\n"}
{"name":"norm_pow","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\ninst‚úù : NormedDivisionRing Œ±\na : Œ±\nn : Nat\n‚ä¢ Eq (Norm.norm (HPow.hPow a n)) (HPow.hPow (Norm.norm a) n)","decl":"@[simp]\ntheorem norm_pow (a : Œ±) : ‚àÄ n : ‚Ñï, ‚Äña ^ n‚Äñ = ‚Äña‚Äñ ^ n :=\n  (normHom.toMonoidHom : Œ± ‚Üí* ‚Ñù).map_pow a\n\n"}
{"name":"nnnorm_pow","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\ninst‚úù : NormedDivisionRing Œ±\na : Œ±\nn : Nat\n‚ä¢ Eq (NNNorm.nnnorm (HPow.hPow a n)) (HPow.hPow (NNNorm.nnnorm a) n)","decl":"@[simp]\ntheorem nnnorm_pow (a : Œ±) (n : ‚Ñï) : ‚Äña ^ n‚Äñ‚Çä = ‚Äña‚Äñ‚Çä ^ n :=\n  (nnnormHom.toMonoidHom : Œ± ‚Üí* ‚Ñù‚â•0).map_pow a n\n\n"}
{"name":"enorm_pow","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\ninst‚úù : NormedDivisionRing Œ±\na : Œ±\nn : Nat\n‚ä¢ Eq (ENorm.enorm (HPow.hPow a n)) (HPow.hPow (ENorm.enorm a) n)","decl":"@[simp] lemma enorm_pow (a : Œ±) (n : ‚Ñï) : ‚Äña ^ n‚Äñ‚Çë = ‚Äña‚Äñ‚Çë ^ n := by simp [enorm]\n\n"}
{"name":"List.norm_prod","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\ninst‚úù : NormedDivisionRing Œ±\nl : List Œ±\n‚ä¢ Eq (Norm.norm l.prod) (List.map Norm.norm l).prod","decl":"protected theorem List.norm_prod (l : List Œ±) : ‚Äñl.prod‚Äñ = (l.map norm).prod :=\n  map_list_prod (normHom.toMonoidHom : Œ± ‚Üí* ‚Ñù) _\n\n"}
{"name":"List.nnnorm_prod","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\ninst‚úù : NormedDivisionRing Œ±\nl : List Œ±\n‚ä¢ Eq (NNNorm.nnnorm l.prod) (List.map NNNorm.nnnorm l).prod","decl":"protected theorem List.nnnorm_prod (l : List Œ±) : ‚Äñl.prod‚Äñ‚Çä = (l.map nnnorm).prod :=\n  map_list_prod (nnnormHom.toMonoidHom : Œ± ‚Üí* ‚Ñù‚â•0) _\n\n"}
{"name":"norm_div","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\ninst‚úù : NormedDivisionRing Œ±\na b : Œ±\n‚ä¢ Eq (Norm.norm (HDiv.hDiv a b)) (HDiv.hDiv (Norm.norm a) (Norm.norm b))","decl":"@[simp]\ntheorem norm_div (a b : Œ±) : ‚Äña / b‚Äñ = ‚Äña‚Äñ / ‚Äñb‚Äñ :=\n  map_div‚ÇÄ (normHom : Œ± ‚Üí*‚ÇÄ ‚Ñù) a b\n\n"}
{"name":"nnnorm_div","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\ninst‚úù : NormedDivisionRing Œ±\na b : Œ±\n‚ä¢ Eq (NNNorm.nnnorm (HDiv.hDiv a b)) (HDiv.hDiv (NNNorm.nnnorm a) (NNNorm.nnnorm b))","decl":"@[simp]\ntheorem nnnorm_div (a b : Œ±) : ‚Äña / b‚Äñ‚Çä = ‚Äña‚Äñ‚Çä / ‚Äñb‚Äñ‚Çä :=\n  map_div‚ÇÄ (nnnormHom : Œ± ‚Üí*‚ÇÄ ‚Ñù‚â•0) a b\n\n"}
{"name":"norm_inv","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\ninst‚úù : NormedDivisionRing Œ±\na : Œ±\n‚ä¢ Eq (Norm.norm (Inv.inv a)) (Inv.inv (Norm.norm a))","decl":"@[simp]\ntheorem norm_inv (a : Œ±) : ‚Äña‚Åª¬π‚Äñ = ‚Äña‚Äñ‚Åª¬π :=\n  map_inv‚ÇÄ (normHom : Œ± ‚Üí*‚ÇÄ ‚Ñù) a\n\n"}
{"name":"nnnorm_inv","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\ninst‚úù : NormedDivisionRing Œ±\na : Œ±\n‚ä¢ Eq (NNNorm.nnnorm (Inv.inv a)) (Inv.inv (NNNorm.nnnorm a))","decl":"@[simp]\ntheorem nnnorm_inv (a : Œ±) : ‚Äña‚Åª¬π‚Äñ‚Çä = ‚Äña‚Äñ‚Çä‚Åª¬π :=\n  NNReal.eq <| by simp\n\n"}
{"name":"enorm_inv","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\ninst‚úù : NormedDivisionRing Œ±\na : Œ±\nha : Ne a 0\n‚ä¢ Eq (ENorm.enorm (Inv.inv a)) (Inv.inv (ENorm.enorm a))","decl":"@[simp]\nlemma enorm_inv {a : Œ±} (ha : a ‚â† 0) : ‚Äña‚Åª¬π‚Äñ‚Çë = ‚Äña‚Äñ‚Çë‚Åª¬π := by simp [enorm, ENNReal.coe_inv, ha]\n\n"}
{"name":"norm_zpow","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\ninst‚úù : NormedDivisionRing Œ±\na : Œ±\nn : Int\n‚ä¢ Eq (Norm.norm (HPow.hPow a n)) (HPow.hPow (Norm.norm a) n)","decl":"@[simp]\ntheorem norm_zpow : ‚àÄ (a : Œ±) (n : ‚Ñ§), ‚Äña ^ n‚Äñ = ‚Äña‚Äñ ^ n :=\n  map_zpow‚ÇÄ (normHom : Œ± ‚Üí*‚ÇÄ ‚Ñù)\n\n"}
{"name":"nnnorm_zpow","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\ninst‚úù : NormedDivisionRing Œ±\na : Œ±\nn : Int\n‚ä¢ Eq (NNNorm.nnnorm (HPow.hPow a n)) (HPow.hPow (NNNorm.nnnorm a) n)","decl":"@[simp]\ntheorem nnnorm_zpow : ‚àÄ (a : Œ±) (n : ‚Ñ§), ‚Äña ^ n‚Äñ‚Çä = ‚Äña‚Äñ‚Çä ^ n :=\n  map_zpow‚ÇÄ (nnnormHom : Œ± ‚Üí*‚ÇÄ ‚Ñù‚â•0)\n\n"}
{"name":"dist_inv_inv‚ÇÄ","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\ninst‚úù : NormedDivisionRing Œ±\nz w : Œ±\nhz : Ne z 0\nhw : Ne w 0\n‚ä¢ Eq (Dist.dist (Inv.inv z) (Inv.inv w)) (HDiv.hDiv (Dist.dist z w) (HMul.hMul (Norm.norm z) (Norm.norm w)))","decl":"theorem dist_inv_inv‚ÇÄ {z w : Œ±} (hz : z ‚â† 0) (hw : w ‚â† 0) :\n    dist z‚Åª¬π w‚Åª¬π = dist z w / (‚Äñz‚Äñ * ‚Äñw‚Äñ) := by\n  rw [dist_eq_norm, inv_sub_inv' hz hw, norm_mul, norm_mul, norm_inv, norm_inv, mul_comm ‚Äñz‚Äñ‚Åª¬π,\n    mul_assoc, dist_eq_norm', div_eq_mul_inv, mul_inv]\n\n"}
{"name":"nndist_inv_inv‚ÇÄ","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\ninst‚úù : NormedDivisionRing Œ±\nz w : Œ±\nhz : Ne z 0\nhw : Ne w 0\n‚ä¢ Eq (NNDist.nndist (Inv.inv z) (Inv.inv w)) (HDiv.hDiv (NNDist.nndist z w) (HMul.hMul (NNNorm.nnnorm z) (NNNorm.nnnorm w)))","decl":"theorem nndist_inv_inv‚ÇÄ {z w : Œ±} (hz : z ‚â† 0) (hw : w ‚â† 0) :\n    nndist z‚Åª¬π w‚Åª¬π = nndist z w / (‚Äñz‚Äñ‚Çä * ‚Äñw‚Äñ‚Çä) :=\n  NNReal.eq <| dist_inv_inv‚ÇÄ hz hw\n\n"}
{"name":"norm_commutator_sub_one_le","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\ninst‚úù : NormedDivisionRing Œ±\na b : Œ±\nha : Ne a 0\nhb : Ne b 0\n‚ä¢ LE.le (Norm.norm (HSub.hSub (HMul.hMul (HMul.hMul (HMul.hMul a b) (Inv.inv a)) (Inv.inv b)) 1)) (HMul.hMul (HMul.hMul (HMul.hMul (HMul.hMul 2 (Inv.inv (Norm.norm a))) (Inv.inv (Norm.norm b))) (Norm.norm (HSub.hSub a 1))) (Norm.norm (HSub.hSub b 1)))","decl":"lemma norm_commutator_sub_one_le (ha : a ‚â† 0) (hb : b ‚â† 0) :\n    ‚Äña * b * a‚Åª¬π * b‚Åª¬π - 1‚Äñ ‚â§ 2 * ‚Äña‚Äñ‚Åª¬π * ‚Äñb‚Äñ‚Åª¬π * ‚Äña - 1‚Äñ * ‚Äñb - 1‚Äñ := by\n  simpa using norm_commutator_units_sub_one_le (.mk0 a ha) (.mk0 b hb)\n\n"}
{"name":"nnnorm_commutator_sub_one_le","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\ninst‚úù : NormedDivisionRing Œ±\na b : Œ±\nha : Ne a 0\nhb : Ne b 0\n‚ä¢ LE.le (NNNorm.nnnorm (HSub.hSub (HMul.hMul (HMul.hMul (HMul.hMul a b) (Inv.inv a)) (Inv.inv b)) 1)) (HMul.hMul (HMul.hMul (HMul.hMul (HMul.hMul 2 (Inv.inv (NNNorm.nnnorm a))) (Inv.inv (NNNorm.nnnorm b))) (NNNorm.nnnorm (HSub.hSub a 1))) (NNNorm.nnnorm (HSub.hSub b 1)))","decl":"lemma nnnorm_commutator_sub_one_le (ha : a ‚â† 0) (hb : b ‚â† 0) :\n    ‚Äña * b * a‚Åª¬π * b‚Åª¬π - 1‚Äñ‚Çä ‚â§ 2 * ‚Äña‚Äñ‚Çä‚Åª¬π * ‚Äñb‚Äñ‚Çä‚Åª¬π * ‚Äña - 1‚Äñ‚Çä * ‚Äñb - 1‚Äñ‚Çä := by\n  simpa using nnnorm_commutator_units_sub_one_le (.mk0 a ha) (.mk0 b hb)\n\n"}
{"name":"NormedDivisionRing.norm_eq_one_iff_ne_zero_of_discrete","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"ùïú : Type u_5\ninst‚úù¬π : NormedDivisionRing ùïú\ninst‚úù : DiscreteTopology ùïú\nx : ùïú\n‚ä¢ Iff (Eq (Norm.norm x) 1) (Ne x 0)","decl":"lemma norm_eq_one_iff_ne_zero_of_discrete {x : ùïú} : ‚Äñx‚Äñ = 1 ‚Üî x ‚â† 0 := by\n  constructor <;> intro hx\n  ¬∑ contrapose! hx\n    simp [hx]\n  ¬∑ have : IsOpen {(0 : ùïú)} := isOpen_discrete {0}\n    simp_rw [Metric.isOpen_singleton_iff, dist_eq_norm, sub_zero] at this\n    obtain ‚ü®Œµ, Œµpos, h'‚ü© := this\n    wlog h : ‚Äñx‚Äñ < 1 generalizing ùïú with H\n    ¬∑ push_neg at h\n      rcases h.eq_or_lt with h|h\n      ¬∑ rw [h]\n      replace h := norm_inv x ‚ñ∏ inv_lt_one_of_one_lt‚ÇÄ h\n      rw [‚Üê inv_inj, inv_one, ‚Üê norm_inv]\n      exact H (by simpa) h' h\n    obtain ‚ü®k, hk‚ü© : ‚àÉ k : ‚Ñï, ‚Äñx‚Äñ ^ k < Œµ := exists_pow_lt_of_lt_one Œµpos h\n    rw [‚Üê norm_pow] at hk\n    specialize h' _ hk\n    simp [hx] at h'\n\n"}
{"name":"NormedDivisionRing.norm_le_one_of_discrete","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"ùïú : Type u_5\ninst‚úù¬π : NormedDivisionRing ùïú\ninst‚úù : DiscreteTopology ùïú\nx : ùïú\n‚ä¢ LE.le (Norm.norm x) 1","decl":"@[simp]\nlemma norm_le_one_of_discrete\n    (x : ùïú) : ‚Äñx‚Äñ ‚â§ 1 := by\n  rcases eq_or_ne x 0 with rfl|hx\n  ¬∑ simp\n  ¬∑ simp [norm_eq_one_iff_ne_zero_of_discrete.mpr hx]\n\n"}
{"name":"NormedDivisionRing.unitClosedBall_eq_univ_of_discrete","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"ùïú : Type u_5\ninst‚úù¬π : NormedDivisionRing ùïú\ninst‚úù : DiscreteTopology ùïú\n‚ä¢ Eq (Metric.closedBall 0 1) Set.univ","decl":"lemma unitClosedBall_eq_univ_of_discrete : (Metric.closedBall 0 1 : Set ùïú) = Set.univ := by\n  ext\n  simp\n\n"}
{"name":"NormedDivisionRing.discreteTopology_unit_closedBall_eq_univ","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"ùïú : Type u_5\ninst‚úù¬π : NormedDivisionRing ùïú\ninst‚úù : DiscreteTopology ùïú\n‚ä¢ Eq (Metric.closedBall 0 1) Set.univ","decl":"@[deprecated (since := \"2024-12-01\")]\nalias discreteTopology_unit_closedBall_eq_univ := unitClosedBall_eq_univ_of_discrete\n\n"}
{"name":"NormedField.norm_mul'","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_5\nself : NormedField Œ±\na b : Œ±\n‚ä¢ Eq (Norm.norm (HMul.hMul a b)) (HMul.hMul (Norm.norm a) (Norm.norm b))","decl":"/-- A normed field is a field with a norm satisfying ‚Äñx y‚Äñ = ‚Äñx‚Äñ ‚Äñy‚Äñ. -/\nclass NormedField (Œ± : Type*) extends Norm Œ±, Field Œ±, MetricSpace Œ± where\n  /-- The distance is induced by the norm. -/\n  dist_eq : ‚àÄ x y, dist x y = norm (x - y)\n  /-- The norm is multiplicative. -/\n  norm_mul' : ‚àÄ a b, norm (a * b) = norm a * norm b\n\n"}
{"name":"NormedField.dist_eq","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_5\nself : NormedField Œ±\nx y : Œ±\n‚ä¢ Eq (Dist.dist x y) (Norm.norm (HSub.hSub x y))","decl":"/-- A normed field is a field with a norm satisfying ‚Äñx y‚Äñ = ‚Äñx‚Äñ ‚Äñy‚Äñ. -/\nclass NormedField (Œ± : Type*) extends Norm Œ±, Field Œ±, MetricSpace Œ± where\n  /-- The distance is induced by the norm. -/\n  dist_eq : ‚àÄ x y, dist x y = norm (x - y)\n  /-- The norm is multiplicative. -/\n  norm_mul' : ‚àÄ a b, norm (a * b) = norm a * norm b\n\n"}
{"name":"NontriviallyNormedField.non_trivial","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_5\nself : NontriviallyNormedField Œ±\n‚ä¢ Exists fun x => LT.lt 1 (Norm.norm x)","decl":"/-- A nontrivially normed field is a normed field in which there is an element of norm different\nfrom `0` and `1`. This makes it possible to bring any element arbitrarily close to `0` by\nmultiplication by the powers of any element, and thus to relate algebra and topology. -/\nclass NontriviallyNormedField (Œ± : Type*) extends NormedField Œ± where\n  /-- The norm attains a value exceeding 1. -/\n  non_trivial : ‚àÉ x : Œ±, 1 < ‚Äñx‚Äñ\n\n"}
{"name":"DenselyNormedField.lt_norm_lt","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_5\nself : DenselyNormedField Œ±\nx y : Real\na‚úù¬π : LE.le 0 x\na‚úù : LT.lt x y\n‚ä¢ Exists fun a => And (LT.lt x (Norm.norm a)) (LT.lt (Norm.norm a) y)","decl":"/-- A densely normed field is a normed field for which the image of the norm is dense in `‚Ñù‚â•0`,\nwhich means it is also nontrivially normed. However, not all nontrivally normed fields are densely\nnormed; in particular, the `Padic`s exhibit this fact. -/\nclass DenselyNormedField (Œ± : Type*) extends NormedField Œ± where\n  /-- The range of the norm is dense in the collection of nonnegative real numbers. -/\n  lt_norm_lt : ‚àÄ x y : ‚Ñù, 0 ‚â§ x ‚Üí x < y ‚Üí ‚àÉ a : Œ±, x < ‚Äña‚Äñ ‚àß ‚Äña‚Äñ < y\n\n"}
{"name":"norm_prod","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\ninst‚úù : NormedField Œ±\ns : Finset Œ≤\nf : Œ≤ ‚Üí Œ±\n‚ä¢ Eq (Norm.norm (s.prod fun b => f b)) (s.prod fun b => Norm.norm (f b))","decl":"@[simp]\ntheorem norm_prod (s : Finset Œ≤) (f : Œ≤ ‚Üí Œ±) : ‚Äñ‚àè b ‚àà s, f b‚Äñ = ‚àè b ‚àà s, ‚Äñf b‚Äñ :=\n  map_prod normHom.toMonoidHom f s\n\n"}
{"name":"nnnorm_prod","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\ninst‚úù : NormedField Œ±\ns : Finset Œ≤\nf : Œ≤ ‚Üí Œ±\n‚ä¢ Eq (NNNorm.nnnorm (s.prod fun b => f b)) (s.prod fun b => NNNorm.nnnorm (f b))","decl":"@[simp]\ntheorem nnnorm_prod (s : Finset Œ≤) (f : Œ≤ ‚Üí Œ±) : ‚Äñ‚àè b ‚àà s, f b‚Äñ‚Çä = ‚àè b ‚àà s, ‚Äñf b‚Äñ‚Çä :=\n  map_prod nnnormHom.toMonoidHom f s\n\n"}
{"name":"NormedField.exists_one_lt_norm","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\ninst‚úù : NontriviallyNormedField Œ±\n‚ä¢ Exists fun x => LT.lt 1 (Norm.norm x)","decl":"theorem exists_one_lt_norm : ‚àÉ x : Œ±, 1 < ‚Äñx‚Äñ :=\n  ‚ÄπNontriviallyNormedField Œ±‚Ä∫.non_trivial\n\n"}
{"name":"NormedField.exists_lt_norm","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\ninst‚úù : NontriviallyNormedField Œ±\nr : Real\n‚ä¢ Exists fun x => LT.lt r (Norm.norm x)","decl":"theorem exists_lt_norm (r : ‚Ñù) : ‚àÉ x : Œ±, r < ‚Äñx‚Äñ :=\n  let ‚ü®w, hw‚ü© := exists_one_lt_norm Œ±\n  let ‚ü®n, hn‚ü© := pow_unbounded_of_one_lt r hw\n  ‚ü®w ^ n, by rwa [norm_pow]‚ü©\n\n"}
{"name":"NormedField.exists_norm_lt","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\ninst‚úù : NontriviallyNormedField Œ±\nr : Real\nhr : LT.lt 0 r\n‚ä¢ Exists fun x => And (LT.lt 0 (Norm.norm x)) (LT.lt (Norm.norm x) r)","decl":"theorem exists_norm_lt {r : ‚Ñù} (hr : 0 < r) : ‚àÉ x : Œ±, 0 < ‚Äñx‚Äñ ‚àß ‚Äñx‚Äñ < r :=\n  let ‚ü®w, hw‚ü© := exists_lt_norm Œ± r‚Åª¬π\n  ‚ü®w‚Åª¬π, by rwa [‚Üê Set.mem_Ioo, norm_inv, ‚Üê Set.mem_inv, Set.inv_Ioo_0_left hr]‚ü©\n\n"}
{"name":"NormedField.exists_norm_lt_one","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\ninst‚úù : NontriviallyNormedField Œ±\n‚ä¢ Exists fun x => And (LT.lt 0 (Norm.norm x)) (LT.lt (Norm.norm x) 1)","decl":"theorem exists_norm_lt_one : ‚àÉ x : Œ±, 0 < ‚Äñx‚Äñ ‚àß ‚Äñx‚Äñ < 1 :=\n  exists_norm_lt Œ± one_pos\n\n"}
{"name":"NormedField.punctured_nhds_neBot","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\ninst‚úù : NontriviallyNormedField Œ±\nx : Œ±\n‚ä¢ (nhdsWithin x (HasCompl.compl (Singleton.singleton x))).NeBot","decl":"@[instance]\ntheorem punctured_nhds_neBot (x : Œ±) : NeBot (ùìù[‚â†] x) := by\n  rw [‚Üê mem_closure_iff_nhdsWithin_neBot, Metric.mem_closure_iff]\n  rintro Œµ Œµ0\n  rcases exists_norm_lt Œ± Œµ0 with ‚ü®b, hb0, hbŒµ‚ü©\n  refine ‚ü®x + b, mt (Set.mem_singleton_iff.trans add_right_eq_self).1 <| norm_pos_iff.1 hb0, ?_‚ü©\n  rwa [dist_comm, dist_eq_norm, add_sub_cancel_left]\n\n"}
{"name":"NormedField.nhdsWithin_isUnit_neBot","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\ninst‚úù : NontriviallyNormedField Œ±\n‚ä¢ (nhdsWithin 0 (setOf fun x => IsUnit x)).NeBot","decl":"@[instance]\ntheorem nhdsWithin_isUnit_neBot : NeBot (ùìù[{ x : Œ± | IsUnit x }] 0) := by\n  simpa only [isUnit_iff_ne_zero] using punctured_nhds_neBot (0 : Œ±)\n\n"}
{"name":"NormedField.exists_lt_norm_lt","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\ninst‚úù : DenselyNormedField Œ±\nr‚ÇÅ r‚ÇÇ : Real\nh‚ÇÄ : LE.le 0 r‚ÇÅ\nh : LT.lt r‚ÇÅ r‚ÇÇ\n‚ä¢ Exists fun x => And (LT.lt r‚ÇÅ (Norm.norm x)) (LT.lt (Norm.norm x) r‚ÇÇ)","decl":"theorem exists_lt_norm_lt {r‚ÇÅ r‚ÇÇ : ‚Ñù} (h‚ÇÄ : 0 ‚â§ r‚ÇÅ) (h : r‚ÇÅ < r‚ÇÇ) : ‚àÉ x : Œ±, r‚ÇÅ < ‚Äñx‚Äñ ‚àß ‚Äñx‚Äñ < r‚ÇÇ :=\n  DenselyNormedField.lt_norm_lt r‚ÇÅ r‚ÇÇ h‚ÇÄ h\n\n"}
{"name":"NormedField.exists_lt_nnnorm_lt","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\ninst‚úù : DenselyNormedField Œ±\nr‚ÇÅ r‚ÇÇ : NNReal\nh : LT.lt r‚ÇÅ r‚ÇÇ\n‚ä¢ Exists fun x => And (LT.lt r‚ÇÅ (NNNorm.nnnorm x)) (LT.lt (NNNorm.nnnorm x) r‚ÇÇ)","decl":"theorem exists_lt_nnnorm_lt {r‚ÇÅ r‚ÇÇ : ‚Ñù‚â•0} (h : r‚ÇÅ < r‚ÇÇ) : ‚àÉ x : Œ±, r‚ÇÅ < ‚Äñx‚Äñ‚Çä ‚àß ‚Äñx‚Äñ‚Çä < r‚ÇÇ :=\n  mod_cast exists_lt_norm_lt Œ± r‚ÇÅ.prop h\n\n"}
{"name":"NormedField.denselyOrdered_range_norm","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\ninst‚úù : DenselyNormedField Œ±\n‚ä¢ DenselyOrdered ‚Üë(Set.range Norm.norm)","decl":"instance denselyOrdered_range_norm : DenselyOrdered (Set.range (norm : Œ± ‚Üí ‚Ñù)) where\n  dense := by\n    rintro ‚ü®-, x, rfl‚ü© ‚ü®-, y, rfl‚ü© hxy\n    let ‚ü®z, h‚ü© := exists_lt_norm_lt Œ± (norm_nonneg _) hxy\n    exact ‚ü®‚ü®‚Äñz‚Äñ, z, rfl‚ü©, h‚ü©\n\n"}
{"name":"NormedField.denselyOrdered_range_nnnorm","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\ninst‚úù : DenselyNormedField Œ±\n‚ä¢ DenselyOrdered ‚Üë(Set.range NNNorm.nnnorm)","decl":"instance denselyOrdered_range_nnnorm : DenselyOrdered (Set.range (nnnorm : Œ± ‚Üí ‚Ñù‚â•0)) where\n  dense := by\n    rintro ‚ü®-, x, rfl‚ü© ‚ü®-, y, rfl‚ü© hxy\n    let ‚ü®z, h‚ü© := exists_lt_nnnorm_lt Œ± hxy\n    exact ‚ü®‚ü®‚Äñz‚Äñ‚Çä, z, rfl‚ü©, h‚ü©\n\n"}
{"name":"Real.toNNReal_mul_nnnorm","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"x y : Real\nhx : LE.le 0 x\n‚ä¢ Eq (HMul.hMul x.toNNReal (NNNorm.nnnorm y)) (NNNorm.nnnorm (HMul.hMul x y))","decl":"theorem toNNReal_mul_nnnorm {x : ‚Ñù} (y : ‚Ñù) (hx : 0 ‚â§ x) : x.toNNReal * ‚Äñy‚Äñ‚Çä = ‚Äñx * y‚Äñ‚Çä := by\n  ext\n  simp only [NNReal.coe_mul, nnnorm_mul, coe_nnnorm, Real.toNNReal_of_nonneg, norm_of_nonneg, hx,\n    NNReal.coe_mk]\n\n"}
{"name":"Real.nnnorm_mul_toNNReal","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"x y : Real\nhy : LE.le 0 y\n‚ä¢ Eq (HMul.hMul (NNNorm.nnnorm x) y.toNNReal) (NNNorm.nnnorm (HMul.hMul x y))","decl":"theorem nnnorm_mul_toNNReal (x : ‚Ñù) {y : ‚Ñù} (hy : 0 ‚â§ y) : ‚Äñx‚Äñ‚Çä * y.toNNReal = ‚Äñx * y‚Äñ‚Çä := by\n  rw [mul_comm, mul_comm x, toNNReal_mul_nnnorm x hy]\n\n"}
{"name":"NNReal.norm_eq","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"x : NNReal\n‚ä¢ Eq (Norm.norm ‚Üëx) ‚Üëx","decl":"theorem norm_eq (x : ‚Ñù‚â•0) : ‚Äñ(x : ‚Ñù)‚Äñ = x := by rw [Real.norm_eq_abs, x.abs_eq]\n\n"}
{"name":"NNReal.nnnorm_eq","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"x : NNReal\n‚ä¢ Eq (NNNorm.nnnorm ‚Üëx) x","decl":"@[simp] lemma nnnorm_eq (x : ‚Ñù‚â•0) : ‚Äñ(x : ‚Ñù)‚Äñ‚Çä = x := by ext; simp [nnnorm]\n"}
{"name":"NNReal.enorm_eq","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"x : NNReal\n‚ä¢ Eq (ENorm.enorm ‚Üëx) ‚Üëx","decl":"@[simp] lemma enorm_eq (x : ‚Ñù‚â•0) : ‚Äñ(x : ‚Ñù)‚Äñ‚Çë = x := by simp [enorm]\n\n"}
{"name":"NormedAddCommGroup.tendsto_atTop","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\ninst‚úù¬≥ : Nonempty Œ±\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : IsDirected Œ± fun x1 x2 => LE.le x1 x2\nŒ≤ : Type u_5\ninst‚úù : SeminormedAddCommGroup Œ≤\nf : Œ± ‚Üí Œ≤\nb : Œ≤\n‚ä¢ Iff (Filter.Tendsto f Filter.atTop (nhds b)) (‚àÄ (Œµ : Real), LT.lt 0 Œµ ‚Üí Exists fun N => ‚àÄ (n : Œ±), LE.le N n ‚Üí LT.lt (Norm.norm (HSub.hSub (f n) b)) Œµ)","decl":"/-- A restatement of `MetricSpace.tendsto_atTop` in terms of the norm. -/\ntheorem NormedAddCommGroup.tendsto_atTop [Nonempty Œ±] [Preorder Œ±] [IsDirected Œ± (¬∑ ‚â§ ¬∑)]\n    {Œ≤ : Type*} [SeminormedAddCommGroup Œ≤] {f : Œ± ‚Üí Œ≤} {b : Œ≤} :\n    Tendsto f atTop (ùìù b) ‚Üî ‚àÄ Œµ, 0 < Œµ ‚Üí ‚àÉ N, ‚àÄ n, N ‚â§ n ‚Üí ‚Äñf n - b‚Äñ < Œµ :=\n  (atTop_basis.tendsto_iff Metric.nhds_basis_ball).trans (by simp [dist_eq_norm])\n\n"}
{"name":"NormedAddCommGroup.tendsto_atTop'","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"Œ± : Type u_2\ninst‚úù‚Å¥ : Nonempty Œ±\ninst‚úù¬≥ : Preorder Œ±\ninst‚úù¬≤ : IsDirected Œ± fun x1 x2 => LE.le x1 x2\ninst‚úù¬π : NoMaxOrder Œ±\nŒ≤ : Type u_5\ninst‚úù : SeminormedAddCommGroup Œ≤\nf : Œ± ‚Üí Œ≤\nb : Œ≤\n‚ä¢ Iff (Filter.Tendsto f Filter.atTop (nhds b)) (‚àÄ (Œµ : Real), LT.lt 0 Œµ ‚Üí Exists fun N => ‚àÄ (n : Œ±), LT.lt N n ‚Üí LT.lt (Norm.norm (HSub.hSub (f n) b)) Œµ)","decl":"/-- A variant of `NormedAddCommGroup.tendsto_atTop` that\nuses `‚àÉ N, ‚àÄ n > N, ...` rather than `‚àÉ N, ‚àÄ n ‚â• N, ...`\n-/\ntheorem NormedAddCommGroup.tendsto_atTop' [Nonempty Œ±] [Preorder Œ±] [IsDirected Œ± (¬∑ ‚â§ ¬∑)]\n    [NoMaxOrder Œ±] {Œ≤ : Type*} [SeminormedAddCommGroup Œ≤] {f : Œ± ‚Üí Œ≤} {b : Œ≤} :\n    Tendsto f atTop (ùìù b) ‚Üî ‚àÄ Œµ, 0 < Œµ ‚Üí ‚àÉ N, ‚àÄ n, N < n ‚Üí ‚Äñf n - b‚Äñ < Œµ :=\n  (atTop_basis_Ioi.tendsto_iff Metric.nhds_basis_ball).trans (by simp [dist_eq_norm])\n\n"}
{"name":"RingHomIsometric.is_iso","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"R‚ÇÅ : Type u_5\nR‚ÇÇ : Type u_6\ninst‚úù¬≥ : Semiring R‚ÇÅ\ninst‚úù¬≤ : Semiring R‚ÇÇ\ninst‚úù¬π : Norm R‚ÇÅ\ninst‚úù : Norm R‚ÇÇ\nœÉ : RingHom R‚ÇÅ R‚ÇÇ\nself : RingHomIsometric œÉ\nx : R‚ÇÅ\n‚ä¢ Eq (Norm.norm (œÉ x)) (Norm.norm x)","decl":"/-- This class states that a ring homomorphism is isometric. This is a sufficient assumption\nfor a continuous semilinear map to be bounded and this is the main use for this typeclass. -/\nclass RingHomIsometric [Semiring R‚ÇÅ] [Semiring R‚ÇÇ] [Norm R‚ÇÅ] [Norm R‚ÇÇ] (œÉ : R‚ÇÅ ‚Üí+* R‚ÇÇ) : Prop where\n  /-- The ring homomorphism is an isometry. -/\n  is_iso : ‚àÄ {x : R‚ÇÅ}, ‚ÄñœÉ x‚Äñ = ‚Äñx‚Äñ\n\n"}
{"name":"RingHomIsometric.ids","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"R‚ÇÅ : Type u_5\ninst‚úù : SeminormedRing R‚ÇÅ\n‚ä¢ RingHomIsometric (RingHom.id R‚ÇÅ)","decl":"instance RingHomIsometric.ids : RingHomIsometric (RingHom.id R‚ÇÅ) :=\n  ‚ü®rfl‚ü©\n\n"}
{"name":"NormOneClass.induced","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"F : Type u_8\nR : Type u_9\nS : Type u_10\ninst‚úù‚Å¥ : Ring R\ninst‚úù¬≥ : SeminormedRing S\ninst‚úù¬≤ : NormOneClass S\ninst‚úù¬π : FunLike F R S\ninst‚úù : RingHomClass F R S\nf : F\n‚ä¢ NormOneClass R","decl":"/-- A ring homomorphism from a `Ring R` to a `SeminormedRing S` which induces the norm structure\n`SeminormedRing.induced` makes `R` satisfy `‚Äñ(1 : R)‚Äñ = 1` whenever `‚Äñ(1 : S)‚Äñ = 1`. -/\ntheorem NormOneClass.induced {F : Type*} (R S : Type*) [Ring R] [SeminormedRing S]\n    [NormOneClass S] [FunLike F R S] [RingHomClass F R S] (f : F) :\n    @NormOneClass R (SeminormedRing.induced R S f).toNorm _ :=\n  -- Porting note: is this `let` a bad idea somehow?\n  let _ : SeminormedRing R := SeminormedRing.induced R S f\n  { norm_one := (congr_arg norm (map_one f)).trans norm_one }\n\n"}
{"name":"SubringClass.toNormOneClass","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"S : Type u_5\nR : Type u_6\ninst‚úù¬≥ : SetLike S R\ninst‚úù¬≤ : SeminormedRing R\ninst‚úù¬π : NormOneClass R\ninst‚úù : SubringClass S R\ns : S\n‚ä¢ NormOneClass (Subtype fun x => Membership.mem s x)","decl":"instance toNormOneClass [SeminormedRing R] [NormOneClass R] [SubringClass S R] (s : S) :\n    NormOneClass s :=\n  .induced s R <| SubringClass.subtype _\n\n"}
