{"name":"NonUnitalSeminormedRing.norm_mul","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_5\nself : NonUnitalSeminormedRing α\na b : α\n⊢ LE.le (Norm.norm (HMul.hMul a b)) (HMul.hMul (Norm.norm a) (Norm.norm b))","decl":"/-- A non-unital seminormed ring is a not-necessarily-unital ring\nendowed with a seminorm which satisfies the inequality `‖x y‖ ≤ ‖x‖ ‖y‖`. -/\nclass NonUnitalSeminormedRing (α : Type*) extends Norm α, NonUnitalRing α,\n  PseudoMetricSpace α where\n  /-- The distance is induced by the norm. -/\n  dist_eq : ∀ x y, dist x y = norm (x - y)\n  /-- The norm is submultiplicative. -/\n  norm_mul : ∀ a b, norm (a * b) ≤ norm a * norm b\n\n"}
{"name":"NonUnitalSeminormedRing.dist_eq","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_5\nself : NonUnitalSeminormedRing α\nx y : α\n⊢ Eq (Dist.dist x y) (Norm.norm (HSub.hSub x y))","decl":"/-- A non-unital seminormed ring is a not-necessarily-unital ring\nendowed with a seminorm which satisfies the inequality `‖x y‖ ≤ ‖x‖ ‖y‖`. -/\nclass NonUnitalSeminormedRing (α : Type*) extends Norm α, NonUnitalRing α,\n  PseudoMetricSpace α where\n  /-- The distance is induced by the norm. -/\n  dist_eq : ∀ x y, dist x y = norm (x - y)\n  /-- The norm is submultiplicative. -/\n  norm_mul : ∀ a b, norm (a * b) ≤ norm a * norm b\n\n"}
{"name":"SeminormedRing.dist_eq","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_5\nself : SeminormedRing α\nx y : α\n⊢ Eq (Dist.dist x y) (Norm.norm (HSub.hSub x y))","decl":"/-- A seminormed ring is a ring endowed with a seminorm which satisfies the inequality\n`‖x y‖ ≤ ‖x‖ ‖y‖`. -/\nclass SeminormedRing (α : Type*) extends Norm α, Ring α, PseudoMetricSpace α where\n  /-- The distance is induced by the norm. -/\n  dist_eq : ∀ x y, dist x y = norm (x - y)\n  /-- The norm is submultiplicative. -/\n  norm_mul : ∀ a b, norm (a * b) ≤ norm a * norm b\n\n-- see Note [lower instance priority]\n"}
{"name":"SeminormedRing.norm_mul","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_5\nself : SeminormedRing α\na b : α\n⊢ LE.le (Norm.norm (HMul.hMul a b)) (HMul.hMul (Norm.norm a) (Norm.norm b))","decl":"/-- A seminormed ring is a ring endowed with a seminorm which satisfies the inequality\n`‖x y‖ ≤ ‖x‖ ‖y‖`. -/\nclass SeminormedRing (α : Type*) extends Norm α, Ring α, PseudoMetricSpace α where\n  /-- The distance is induced by the norm. -/\n  dist_eq : ∀ x y, dist x y = norm (x - y)\n  /-- The norm is submultiplicative. -/\n  norm_mul : ∀ a b, norm (a * b) ≤ norm a * norm b\n\n-- see Note [lower instance priority]\n"}
{"name":"NonUnitalNormedRing.norm_mul","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_5\nself : NonUnitalNormedRing α\na b : α\n⊢ LE.le (Norm.norm (HMul.hMul a b)) (HMul.hMul (Norm.norm a) (Norm.norm b))","decl":"/-- A non-unital normed ring is a not-necessarily-unital ring\nendowed with a norm which satisfies the inequality `‖x y‖ ≤ ‖x‖ ‖y‖`. -/\nclass NonUnitalNormedRing (α : Type*) extends Norm α, NonUnitalRing α, MetricSpace α where\n  /-- The distance is induced by the norm. -/\n  dist_eq : ∀ x y, dist x y = norm (x - y)\n  /-- The norm is submultiplicative. -/\n  norm_mul : ∀ a b, norm (a * b) ≤ norm a * norm b\n\n-- see Note [lower instance priority]\n"}
{"name":"NonUnitalNormedRing.dist_eq","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_5\nself : NonUnitalNormedRing α\nx y : α\n⊢ Eq (Dist.dist x y) (Norm.norm (HSub.hSub x y))","decl":"/-- A non-unital normed ring is a not-necessarily-unital ring\nendowed with a norm which satisfies the inequality `‖x y‖ ≤ ‖x‖ ‖y‖`. -/\nclass NonUnitalNormedRing (α : Type*) extends Norm α, NonUnitalRing α, MetricSpace α where\n  /-- The distance is induced by the norm. -/\n  dist_eq : ∀ x y, dist x y = norm (x - y)\n  /-- The norm is submultiplicative. -/\n  norm_mul : ∀ a b, norm (a * b) ≤ norm a * norm b\n\n-- see Note [lower instance priority]\n"}
{"name":"NormedRing.dist_eq","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_5\nself : NormedRing α\nx y : α\n⊢ Eq (Dist.dist x y) (Norm.norm (HSub.hSub x y))","decl":"/-- A normed ring is a ring endowed with a norm which satisfies the inequality `‖x y‖ ≤ ‖x‖ ‖y‖`. -/\nclass NormedRing (α : Type*) extends Norm α, Ring α, MetricSpace α where\n  /-- The distance is induced by the norm. -/\n  dist_eq : ∀ x y, dist x y = norm (x - y)\n  /-- The norm is submultiplicative. -/\n  norm_mul : ∀ a b, norm (a * b) ≤ norm a * norm b\n\n"}
{"name":"NormedRing.norm_mul","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_5\nself : NormedRing α\na b : α\n⊢ LE.le (Norm.norm (HMul.hMul a b)) (HMul.hMul (Norm.norm a) (Norm.norm b))","decl":"/-- A normed ring is a ring endowed with a norm which satisfies the inequality `‖x y‖ ≤ ‖x‖ ‖y‖`. -/\nclass NormedRing (α : Type*) extends Norm α, Ring α, MetricSpace α where\n  /-- The distance is induced by the norm. -/\n  dist_eq : ∀ x y, dist x y = norm (x - y)\n  /-- The norm is submultiplicative. -/\n  norm_mul : ∀ a b, norm (a * b) ≤ norm a * norm b\n\n"}
{"name":"NormedDivisionRing.dist_eq","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_5\nself : NormedDivisionRing α\nx y : α\n⊢ Eq (Dist.dist x y) (Norm.norm (HSub.hSub x y))","decl":"/-- A normed division ring is a division ring endowed with a seminorm which satisfies the equality\n`‖x y‖ = ‖x‖ ‖y‖`. -/\nclass NormedDivisionRing (α : Type*) extends Norm α, DivisionRing α, MetricSpace α where\n  /-- The distance is induced by the norm. -/\n  dist_eq : ∀ x y, dist x y = norm (x - y)\n  /-- The norm is multiplicative. -/\n  norm_mul' : ∀ a b, norm (a * b) = norm a * norm b\n\n-- see Note [lower instance priority]\n"}
{"name":"NormedDivisionRing.norm_mul'","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_5\nself : NormedDivisionRing α\na b : α\n⊢ Eq (Norm.norm (HMul.hMul a b)) (HMul.hMul (Norm.norm a) (Norm.norm b))","decl":"/-- A normed division ring is a division ring endowed with a seminorm which satisfies the equality\n`‖x y‖ = ‖x‖ ‖y‖`. -/\nclass NormedDivisionRing (α : Type*) extends Norm α, DivisionRing α, MetricSpace α where\n  /-- The distance is induced by the norm. -/\n  dist_eq : ∀ x y, dist x y = norm (x - y)\n  /-- The norm is multiplicative. -/\n  norm_mul' : ∀ a b, norm (a * b) = norm a * norm b\n\n-- see Note [lower instance priority]\n"}
{"name":"NonUnitalSeminormedCommRing.mul_comm","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_5\nself : NonUnitalSeminormedCommRing α\nx y : α\n⊢ Eq (HMul.hMul x y) (HMul.hMul y x)","decl":"/-- A non-unital seminormed commutative ring is a non-unital commutative ring endowed with a\nseminorm which satisfies the inequality `‖x y‖ ≤ ‖x‖ ‖y‖`. -/\nclass NonUnitalSeminormedCommRing (α : Type*) extends NonUnitalSeminormedRing α where\n  /-- Multiplication is commutative. -/\n  mul_comm : ∀ x y : α, x * y = y * x\n\n"}
{"name":"NonUnitalNormedCommRing.mul_comm","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_5\nself : NonUnitalNormedCommRing α\nx y : α\n⊢ Eq (HMul.hMul x y) (HMul.hMul y x)","decl":"/-- A non-unital normed commutative ring is a non-unital commutative ring endowed with a\nnorm which satisfies the inequality `‖x y‖ ≤ ‖x‖ ‖y‖`. -/\nclass NonUnitalNormedCommRing (α : Type*) extends NonUnitalNormedRing α where\n  /-- Multiplication is commutative. -/\n  mul_comm : ∀ x y : α, x * y = y * x\n\n-- see Note [lower instance priority]\n"}
{"name":"SeminormedCommRing.mul_comm","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_5\nself : SeminormedCommRing α\nx y : α\n⊢ Eq (HMul.hMul x y) (HMul.hMul y x)","decl":"/-- A seminormed commutative ring is a commutative ring endowed with a seminorm which satisfies\nthe inequality `‖x y‖ ≤ ‖x‖ ‖y‖`. -/\nclass SeminormedCommRing (α : Type*) extends SeminormedRing α where\n  /-- Multiplication is commutative. -/\n  mul_comm : ∀ x y : α, x * y = y * x\n\n"}
{"name":"NormedCommRing.mul_comm","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_5\nself : NormedCommRing α\nx y : α\n⊢ Eq (HMul.hMul x y) (HMul.hMul y x)","decl":"/-- A normed commutative ring is a commutative ring endowed with a norm which satisfies\nthe inequality `‖x y‖ ≤ ‖x‖ ‖y‖`. -/\nclass NormedCommRing (α : Type*) extends NormedRing α where\n  /-- Multiplication is commutative. -/\n  mul_comm : ∀ x y : α, x * y = y * x\n\n-- see Note [lower instance priority]\n"}
{"name":"NormOneClass.norm_one","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_5\ninst✝¹ : Norm α\ninst✝ : One α\nself : NormOneClass α\n⊢ Eq (Norm.norm 1) 1","decl":"/-- A mixin class with the axiom `‖1‖ = 1`. Many `NormedRing`s and all `NormedField`s satisfy this\naxiom. -/\nclass NormOneClass (α : Type*) [Norm α] [One α] : Prop where\n  /-- The norm of the multiplicative identity is 1. -/\n  norm_one : ‖(1 : α)‖ = 1\n\n"}
{"name":"nnnorm_one","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"G : Type u_1\ninst✝² : SeminormedAddCommGroup G\ninst✝¹ : One G\ninst✝ : NormOneClass G\n⊢ Eq (NNNorm.nnnorm 1) 1","decl":"@[simp] lemma nnnorm_one : ‖(1 : G)‖₊ = 1 := NNReal.eq norm_one\n"}
{"name":"enorm_one","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"G : Type u_1\ninst✝² : SeminormedAddCommGroup G\ninst✝¹ : One G\ninst✝ : NormOneClass G\n⊢ Eq (ENorm.enorm 1) 1","decl":"@[simp] lemma enorm_one : ‖(1 : G)‖ₑ = 1 := by simp [enorm]\n\n"}
{"name":"NormOneClass.nontrivial","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"G : Type u_1\ninst✝² : SeminormedAddCommGroup G\ninst✝¹ : One G\ninst✝ : NormOneClass G\n⊢ Nontrivial G","decl":"theorem NormOneClass.nontrivial : Nontrivial G :=\n  nontrivial_of_ne 0 1 <| ne_of_apply_ne norm <| by simp\n\n"}
{"name":"ULift.normOneClass","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\ninst✝² : SeminormedAddCommGroup α\ninst✝¹ : One α\ninst✝ : NormOneClass α\n⊢ NormOneClass (ULift.{u_5, u_2} α)","decl":"instance ULift.normOneClass [SeminormedAddCommGroup α] [One α] [NormOneClass α] :\n    NormOneClass (ULift α) :=\n  ⟨by simp [ULift.norm_def]⟩\n\n"}
{"name":"Prod.normOneClass","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝⁵ : SeminormedAddCommGroup α\ninst✝⁴ : One α\ninst✝³ : NormOneClass α\ninst✝² : SeminormedAddCommGroup β\ninst✝¹ : One β\ninst✝ : NormOneClass β\n⊢ NormOneClass (Prod α β)","decl":"instance Prod.normOneClass [SeminormedAddCommGroup α] [One α] [NormOneClass α]\n    [SeminormedAddCommGroup β] [One β] [NormOneClass β] : NormOneClass (α × β) :=\n  ⟨by simp [Prod.norm_def]⟩\n\n"}
{"name":"Pi.normOneClass","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"ι : Type u_5\nα : ι → Type u_6\ninst✝⁴ : Nonempty ι\ninst✝³ : Fintype ι\ninst✝² : (i : ι) → SeminormedAddCommGroup (α i)\ninst✝¹ : (i : ι) → One (α i)\ninst✝ : ∀ (i : ι), NormOneClass (α i)\n⊢ NormOneClass ((i : ι) → α i)","decl":"instance Pi.normOneClass {ι : Type*} {α : ι → Type*} [Nonempty ι] [Fintype ι]\n    [∀ i, SeminormedAddCommGroup (α i)] [∀ i, One (α i)] [∀ i, NormOneClass (α i)] :\n    NormOneClass (∀ i, α i) :=\n  ⟨by simpa [Pi.norm_def] using Finset.sup_const Finset.univ_nonempty 1⟩\n\n"}
{"name":"MulOpposite.normOneClass","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\ninst✝² : SeminormedAddCommGroup α\ninst✝¹ : One α\ninst✝ : NormOneClass α\n⊢ NormOneClass (MulOpposite α)","decl":"instance MulOpposite.normOneClass [SeminormedAddCommGroup α] [One α] [NormOneClass α] :\n    NormOneClass αᵐᵒᵖ :=\n  ⟨@norm_one α _ _ _⟩\n\n"}
{"name":"norm_mul_le","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\ninst✝ : NonUnitalSeminormedRing α\na b : α\n⊢ LE.le (Norm.norm (HMul.hMul a b)) (HMul.hMul (Norm.norm a) (Norm.norm b))","decl":"theorem norm_mul_le (a b : α) : ‖a * b‖ ≤ ‖a‖ * ‖b‖ :=\n  NonUnitalSeminormedRing.norm_mul _ _\n\n"}
{"name":"nnnorm_mul_le","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\ninst✝ : NonUnitalSeminormedRing α\na b : α\n⊢ LE.le (NNNorm.nnnorm (HMul.hMul a b)) (HMul.hMul (NNNorm.nnnorm a) (NNNorm.nnnorm b))","decl":"theorem nnnorm_mul_le (a b : α) : ‖a * b‖₊ ≤ ‖a‖₊ * ‖b‖₊ := by\n  simpa only [← norm_toNNReal, ← Real.toNNReal_mul (norm_nonneg _)] using\n    Real.toNNReal_mono (norm_mul_le _ _)\n\n"}
{"name":"norm_mul_le_of_le","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\ninst✝ : NonUnitalSeminormedRing α\na₁ a₂ : α\nr₁ r₂ : Real\nh₁ : LE.le (Norm.norm a₁) r₁\nh₂ : LE.le (Norm.norm a₂) r₂\n⊢ LE.le (Norm.norm (HMul.hMul a₁ a₂)) (HMul.hMul r₁ r₂)","decl":"lemma norm_mul_le_of_le {r₁ r₂ : ℝ} (h₁ : ‖a₁‖ ≤ r₁) (h₂ : ‖a₂‖ ≤ r₂) : ‖a₁ * a₂‖ ≤ r₁ * r₂ :=\n  (norm_mul_le ..).trans <| mul_le_mul h₁ h₂ (norm_nonneg _) ((norm_nonneg _).trans h₁)\n\n"}
{"name":"nnnorm_mul_le_of_le","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\ninst✝ : NonUnitalSeminormedRing α\na₁ a₂ : α\nr₁ r₂ : NNReal\nh₁ : LE.le (NNNorm.nnnorm a₁) r₁\nh₂ : LE.le (NNNorm.nnnorm a₂) r₂\n⊢ LE.le (NNNorm.nnnorm (HMul.hMul a₁ a₂)) (HMul.hMul r₁ r₂)","decl":"lemma nnnorm_mul_le_of_le {r₁ r₂ : ℝ≥0} (h₁ : ‖a₁‖₊ ≤ r₁) (h₂ : ‖a₂‖₊ ≤ r₂) :\n    ‖a₁ * a₂‖₊ ≤ r₁ * r₂ := (nnnorm_mul_le ..).trans <| mul_le_mul' h₁ h₂\n\n"}
{"name":"norm_mul₃_le","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\ninst✝ : NonUnitalSeminormedRing α\na b c : α\n⊢ LE.le (Norm.norm (HMul.hMul (HMul.hMul a b) c)) (HMul.hMul (HMul.hMul (Norm.norm a) (Norm.norm b)) (Norm.norm c))","decl":"lemma norm_mul₃_le : ‖a * b * c‖ ≤ ‖a‖ * ‖b‖ * ‖c‖ := norm_mul_le_of_le (norm_mul_le ..) le_rfl\n\n"}
{"name":"nnnorm_mul₃_le","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\ninst✝ : NonUnitalSeminormedRing α\na b c : α\n⊢ LE.le (NNNorm.nnnorm (HMul.hMul (HMul.hMul a b) c)) (HMul.hMul (HMul.hMul (NNNorm.nnnorm a) (NNNorm.nnnorm b)) (NNNorm.nnnorm c))","decl":"lemma nnnorm_mul₃_le : ‖a * b * c‖₊ ≤ ‖a‖₊ * ‖b‖₊ * ‖c‖₊ :=\n  nnnorm_mul_le_of_le (norm_mul_le ..) le_rfl\n\n"}
{"name":"one_le_norm_one","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"β : Type u_5\ninst✝¹ : NormedRing β\ninst✝ : Nontrivial β\n⊢ LE.le 1 (Norm.norm 1)","decl":"theorem one_le_norm_one (β) [NormedRing β] [Nontrivial β] : 1 ≤ ‖(1 : β)‖ :=\n  (le_mul_iff_one_le_left <| norm_pos_iff.mpr (one_ne_zero : (1 : β) ≠ 0)).mp\n    (by simpa only [mul_one] using norm_mul_le (1 : β) 1)\n\n"}
{"name":"one_le_nnnorm_one","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"β : Type u_5\ninst✝¹ : NormedRing β\ninst✝ : Nontrivial β\n⊢ LE.le 1 (NNNorm.nnnorm 1)","decl":"theorem one_le_nnnorm_one (β) [NormedRing β] [Nontrivial β] : 1 ≤ ‖(1 : β)‖₊ :=\n  one_le_norm_one β\n\n"}
{"name":"mulLeft_bound","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\ninst✝ : NonUnitalSeminormedRing α\nx y : α\n⊢ LE.le (Norm.norm ((AddMonoidHom.mulLeft x) y)) (HMul.hMul (Norm.norm x) (Norm.norm y))","decl":"/-- In a seminormed ring, the left-multiplication `AddMonoidHom` is bounded. -/\ntheorem mulLeft_bound (x : α) : ∀ y : α, ‖AddMonoidHom.mulLeft x y‖ ≤ ‖x‖ * ‖y‖ :=\n  norm_mul_le x\n\n"}
{"name":"mulRight_bound","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\ninst✝ : NonUnitalSeminormedRing α\nx y : α\n⊢ LE.le (Norm.norm ((AddMonoidHom.mulRight x) y)) (HMul.hMul (Norm.norm x) (Norm.norm y))","decl":"/-- In a seminormed ring, the right-multiplication `AddMonoidHom` is bounded. -/\ntheorem mulRight_bound (x : α) : ∀ y : α, ‖AddMonoidHom.mulRight x y‖ ≤ ‖x‖ * ‖y‖ := fun y => by\n  rw [mul_comm]\n  exact norm_mul_le y x\n\n"}
{"name":"Nat.norm_cast_le","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\ninst✝ : SeminormedRing α\nn : Nat\n⊢ LE.le (Norm.norm ↑n) (HMul.hMul (↑n) (Norm.norm 1))","decl":"theorem Nat.norm_cast_le : ∀ n : ℕ, ‖(n : α)‖ ≤ n * ‖(1 : α)‖\n  | 0 => by simp\n  | n + 1 => by\n    rw [n.cast_succ, n.cast_succ, add_mul, one_mul]\n    exact norm_add_le_of_le (Nat.norm_cast_le n) le_rfl\n\n"}
{"name":"List.norm_prod_le'","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\ninst✝ : SeminormedRing α\nl : List α\na✝ : Ne l List.nil\n⊢ LE.le (Norm.norm l.prod) (List.map Norm.norm l).prod","decl":"theorem List.norm_prod_le' : ∀ {l : List α}, l ≠ [] → ‖l.prod‖ ≤ (l.map norm).prod\n  | [], h => (h rfl).elim\n  | [a], _ => by simp\n  | a::b::l, _ => by\n    rw [List.map_cons, List.prod_cons, List.prod_cons (a := ‖a‖)]\n    refine le_trans (norm_mul_le _ _) (mul_le_mul_of_nonneg_left ?_ (norm_nonneg _))\n    exact List.norm_prod_le' (List.cons_ne_nil b l)\n\n"}
{"name":"List.nnnorm_prod_le'","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\ninst✝ : SeminormedRing α\nl : List α\nhl : Ne l List.nil\n⊢ LE.le (NNNorm.nnnorm l.prod) (List.map NNNorm.nnnorm l).prod","decl":"theorem List.nnnorm_prod_le' {l : List α} (hl : l ≠ []) : ‖l.prod‖₊ ≤ (l.map nnnorm).prod :=\n  (List.norm_prod_le' hl).trans_eq <| by simp [NNReal.coe_list_prod, List.map_map]\n\n"}
{"name":"List.norm_prod_le","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\ninst✝¹ : SeminormedRing α\ninst✝ : NormOneClass α\nl : List α\n⊢ LE.le (Norm.norm l.prod) (List.map Norm.norm l).prod","decl":"theorem List.norm_prod_le [NormOneClass α] : ∀ l : List α, ‖l.prod‖ ≤ (l.map norm).prod\n  | [] => by simp\n  | a::l => List.norm_prod_le' (List.cons_ne_nil a l)\n\n"}
{"name":"List.nnnorm_prod_le","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\ninst✝¹ : SeminormedRing α\ninst✝ : NormOneClass α\nl : List α\n⊢ LE.le (NNNorm.nnnorm l.prod) (List.map NNNorm.nnnorm l).prod","decl":"theorem List.nnnorm_prod_le [NormOneClass α] (l : List α) : ‖l.prod‖₊ ≤ (l.map nnnorm).prod :=\n  l.norm_prod_le.trans_eq <| by simp [NNReal.coe_list_prod, List.map_map]\n\n"}
{"name":"Finset.norm_prod_le'","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"ι : Type u_4\nα : Type u_5\ninst✝ : NormedCommRing α\ns : Finset ι\nhs : s.Nonempty\nf : ι → α\n⊢ LE.le (Norm.norm (s.prod fun i => f i)) (s.prod fun i => Norm.norm (f i))","decl":"theorem Finset.norm_prod_le' {α : Type*} [NormedCommRing α] (s : Finset ι) (hs : s.Nonempty)\n    (f : ι → α) : ‖∏ i ∈ s, f i‖ ≤ ∏ i ∈ s, ‖f i‖ := by\n  rcases s with ⟨⟨l⟩, hl⟩\n  have : l.map f ≠ [] := by simpa using hs\n  simpa using List.norm_prod_le' this\n\n"}
{"name":"Finset.nnnorm_prod_le'","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"ι : Type u_4\nα : Type u_5\ninst✝ : NormedCommRing α\ns : Finset ι\nhs : s.Nonempty\nf : ι → α\n⊢ LE.le (NNNorm.nnnorm (s.prod fun i => f i)) (s.prod fun i => NNNorm.nnnorm (f i))","decl":"theorem Finset.nnnorm_prod_le' {α : Type*} [NormedCommRing α] (s : Finset ι) (hs : s.Nonempty)\n    (f : ι → α) : ‖∏ i ∈ s, f i‖₊ ≤ ∏ i ∈ s, ‖f i‖₊ :=\n  (s.norm_prod_le' hs f).trans_eq <| by simp [NNReal.coe_prod]\n\n"}
{"name":"Finset.norm_prod_le","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"ι : Type u_4\nα : Type u_5\ninst✝¹ : NormedCommRing α\ninst✝ : NormOneClass α\ns : Finset ι\nf : ι → α\n⊢ LE.le (Norm.norm (s.prod fun i => f i)) (s.prod fun i => Norm.norm (f i))","decl":"theorem Finset.norm_prod_le {α : Type*} [NormedCommRing α] [NormOneClass α] (s : Finset ι)\n    (f : ι → α) : ‖∏ i ∈ s, f i‖ ≤ ∏ i ∈ s, ‖f i‖ := by\n  rcases s with ⟨⟨l⟩, hl⟩\n  simpa using (l.map f).norm_prod_le\n\n"}
{"name":"Finset.nnnorm_prod_le","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"ι : Type u_4\nα : Type u_5\ninst✝¹ : NormedCommRing α\ninst✝ : NormOneClass α\ns : Finset ι\nf : ι → α\n⊢ LE.le (NNNorm.nnnorm (s.prod fun i => f i)) (s.prod fun i => NNNorm.nnnorm (f i))","decl":"theorem Finset.nnnorm_prod_le {α : Type*} [NormedCommRing α] [NormOneClass α] (s : Finset ι)\n    (f : ι → α) : ‖∏ i ∈ s, f i‖₊ ≤ ∏ i ∈ s, ‖f i‖₊ :=\n  (s.norm_prod_le f).trans_eq <| by simp [NNReal.coe_prod]\n\n"}
{"name":"nnnorm_pow_le'","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\ninst✝ : SeminormedRing α\na : α\nn : Nat\na✝ : LT.lt 0 n\n⊢ LE.le (NNNorm.nnnorm (HPow.hPow a n)) (HPow.hPow (NNNorm.nnnorm a) n)","decl":"/-- If `α` is a seminormed ring, then `‖a ^ n‖₊ ≤ ‖a‖₊ ^ n` for `n > 0`.\nSee also `nnnorm_pow_le`. -/\ntheorem nnnorm_pow_le' (a : α) : ∀ {n : ℕ}, 0 < n → ‖a ^ n‖₊ ≤ ‖a‖₊ ^ n\n  | 1, _ => by simp only [pow_one, le_rfl]\n  | n + 2, _ => by\n    simpa only [pow_succ' _ (n + 1)] using\n      le_trans (nnnorm_mul_le _ _) (mul_le_mul_left' (nnnorm_pow_le' a n.succ_pos) _)\n\n"}
{"name":"nnnorm_pow_le","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\ninst✝¹ : SeminormedRing α\ninst✝ : NormOneClass α\na : α\nn : Nat\n⊢ LE.le (NNNorm.nnnorm (HPow.hPow a n)) (HPow.hPow (NNNorm.nnnorm a) n)","decl":"/-- If `α` is a seminormed ring with `‖1‖₊ = 1`, then `‖a ^ n‖₊ ≤ ‖a‖₊ ^ n`.\nSee also `nnnorm_pow_le'`. -/\ntheorem nnnorm_pow_le [NormOneClass α] (a : α) (n : ℕ) : ‖a ^ n‖₊ ≤ ‖a‖₊ ^ n :=\n  Nat.recOn n (by simp only [pow_zero, nnnorm_one, le_rfl])\n    fun k _hk => nnnorm_pow_le' a k.succ_pos\n\n"}
{"name":"norm_pow_le'","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\ninst✝ : SeminormedRing α\na : α\nn : Nat\nh : LT.lt 0 n\n⊢ LE.le (Norm.norm (HPow.hPow a n)) (HPow.hPow (Norm.norm a) n)","decl":"/-- If `α` is a seminormed ring, then `‖a ^ n‖ ≤ ‖a‖ ^ n` for `n > 0`. See also `norm_pow_le`. -/\ntheorem norm_pow_le' (a : α) {n : ℕ} (h : 0 < n) : ‖a ^ n‖ ≤ ‖a‖ ^ n := by\n  simpa only [NNReal.coe_pow, coe_nnnorm] using NNReal.coe_mono (nnnorm_pow_le' a h)\n\n"}
{"name":"norm_pow_le","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\ninst✝¹ : SeminormedRing α\ninst✝ : NormOneClass α\na : α\nn : Nat\n⊢ LE.le (Norm.norm (HPow.hPow a n)) (HPow.hPow (Norm.norm a) n)","decl":"/-- If `α` is a seminormed ring with `‖1‖ = 1`, then `‖a ^ n‖ ≤ ‖a‖ ^ n`.\nSee also `norm_pow_le'`. -/\ntheorem norm_pow_le [NormOneClass α] (a : α) (n : ℕ) : ‖a ^ n‖ ≤ ‖a‖ ^ n :=\n  Nat.recOn n (by simp only [pow_zero, norm_one, le_rfl])\n    fun n _hn => norm_pow_le' a n.succ_pos\n\n"}
{"name":"eventually_norm_pow_le","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\ninst✝ : SeminormedRing α\na : α\n⊢ Filter.Eventually (fun n => LE.le (Norm.norm (HPow.hPow a n)) (HPow.hPow (Norm.norm a) n)) Filter.atTop","decl":"theorem eventually_norm_pow_le (a : α) : ∀ᶠ n : ℕ in atTop, ‖a ^ n‖ ≤ ‖a‖ ^ n :=\n  eventually_atTop.mpr ⟨1, fun _b h => norm_pow_le' a (Nat.succ_le_iff.mp h)⟩\n\n"}
{"name":"norm_sub_mul_le","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\ninst✝ : SeminormedRing α\na b c : α\nha : LE.le (Norm.norm a) 1\n⊢ LE.le (Norm.norm (HSub.hSub c (HMul.hMul a b))) (HAdd.hAdd (Norm.norm (HSub.hSub c a)) (Norm.norm (HSub.hSub 1 b)))","decl":"/-- This inequality is particularly useful when `c = 1` and `‖a‖ = ‖b‖ = 1` as it then shows that\nchord length is a metric on the unit complex numbers. -/\nlemma norm_sub_mul_le (ha : ‖a‖ ≤ 1) : ‖c - a * b‖ ≤ ‖c - a‖ + ‖1 - b‖ :=\n  calc\n    _ ≤ ‖c - a‖ + ‖a * (1 - b)‖ := by\n        simpa [mul_one_sub] using norm_sub_le_norm_sub_add_norm_sub c a (a * b)\n    _ ≤ ‖c - a‖ + ‖a‖ * ‖1 - b‖ := by gcongr; exact norm_mul_le ..\n    _ ≤ ‖c - a‖ + 1 * ‖1 - b‖ := by gcongr\n    _ = ‖c - a‖ + ‖1 - b‖ := by simp\n\n"}
{"name":"norm_sub_mul_le'","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\ninst✝ : SeminormedRing α\na b c : α\nhb : LE.le (Norm.norm b) 1\n⊢ LE.le (Norm.norm (HSub.hSub c (HMul.hMul a b))) (HAdd.hAdd (Norm.norm (HSub.hSub 1 a)) (Norm.norm (HSub.hSub c b)))","decl":"/-- This inequality is particularly useful when `c = 1` and `‖a‖ = ‖b‖ = 1` as it then shows that\nchord length is a metric on the unit complex numbers. -/\nlemma norm_sub_mul_le' (hb : ‖b‖ ≤ 1) : ‖c - a * b‖ ≤ ‖1 - a‖ + ‖c - b‖ := by\n  rw [add_comm]; exact norm_sub_mul_le (α := αᵐᵒᵖ) hb\n\n"}
{"name":"nnnorm_sub_mul_le","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\ninst✝ : SeminormedRing α\na b c : α\nha : LE.le (NNNorm.nnnorm a) 1\n⊢ LE.le (NNNorm.nnnorm (HSub.hSub c (HMul.hMul a b))) (HAdd.hAdd (NNNorm.nnnorm (HSub.hSub c a)) (NNNorm.nnnorm (HSub.hSub 1 b)))","decl":"/-- This inequality is particularly useful when `c = 1` and `‖a‖ = ‖b‖ = 1` as it then shows that\nchord length is a metric on the unit complex numbers. -/\nlemma nnnorm_sub_mul_le (ha : ‖a‖₊ ≤ 1) : ‖c - a * b‖₊ ≤ ‖c - a‖₊ + ‖1 - b‖₊ := norm_sub_mul_le ha\n\n"}
{"name":"nnnorm_sub_mul_le'","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\ninst✝ : SeminormedRing α\na b c : α\nhb : LE.le (NNNorm.nnnorm b) 1\n⊢ LE.le (NNNorm.nnnorm (HSub.hSub c (HMul.hMul a b))) (HAdd.hAdd (NNNorm.nnnorm (HSub.hSub 1 a)) (NNNorm.nnnorm (HSub.hSub c b)))","decl":"/-- This inequality is particularly useful when `c = 1` and `‖a‖ = ‖b‖ = 1` as it then shows that\nchord length is a metric on the unit complex numbers. -/\nlemma nnnorm_sub_mul_le' (hb : ‖b‖₊ ≤ 1) : ‖c - a * b‖₊ ≤ ‖1 - a‖₊ + ‖c - b‖₊ := norm_sub_mul_le' hb\n\n"}
{"name":"norm_commutator_units_sub_one_le","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\ninst✝ : SeminormedRing α\na b : Units α\n⊢ LE.le (Norm.norm (HSub.hSub (↑(HMul.hMul (HMul.hMul (HMul.hMul a b) (Inv.inv a)) (Inv.inv b))) 1)) (HMul.hMul (HMul.hMul (HMul.hMul (HMul.hMul 2 (Norm.norm ↑(Inv.inv a))) (Norm.norm ↑(Inv.inv b))) (Norm.norm (HSub.hSub (↑a) 1))) (Norm.norm (HSub.hSub (↑b) 1)))","decl":"lemma norm_commutator_units_sub_one_le (a b : αˣ) :\n    ‖(a * b * a⁻¹ * b⁻¹).val - 1‖ ≤ 2 * ‖a⁻¹.val‖ * ‖b⁻¹.val‖ * ‖a.val - 1‖ * ‖b.val - 1‖ :=\n  calc\n    ‖(a * b * a⁻¹ * b⁻¹).val - 1‖ = ‖(a * b - b * a) * a⁻¹.val * b⁻¹.val‖ := by simp [sub_mul, *]\n    _ ≤ ‖(a * b - b * a : α)‖ * ‖a⁻¹.val‖ * ‖b⁻¹.val‖ := norm_mul₃_le\n    _ = ‖(a - 1 : α) * (b - 1) - (b - 1) * (a - 1)‖ * ‖a⁻¹.val‖ * ‖b⁻¹.val‖ := by\n      simp_rw [sub_one_mul, mul_sub_one]; abel_nf\n    _ ≤ (‖(a - 1 : α) * (b - 1)‖ + ‖(b - 1 : α) * (a - 1)‖) * ‖a⁻¹.val‖ * ‖b⁻¹.val‖ := by\n      gcongr; exact norm_sub_le ..\n    _ ≤ (‖a.val - 1‖ * ‖b.val - 1‖ + ‖b.val - 1‖ * ‖a.val - 1‖) * ‖a⁻¹.val‖ * ‖b⁻¹.val‖ := by\n      gcongr <;> exact norm_mul_le ..\n    _ = 2 * ‖a⁻¹.val‖ * ‖b⁻¹.val‖ * ‖a.val - 1‖ * ‖b.val - 1‖ := by ring\n\n"}
{"name":"nnnorm_commutator_units_sub_one_le","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\ninst✝ : SeminormedRing α\na b : Units α\n⊢ LE.le (NNNorm.nnnorm (HSub.hSub (↑(HMul.hMul (HMul.hMul (HMul.hMul a b) (Inv.inv a)) (Inv.inv b))) 1)) (HMul.hMul (HMul.hMul (HMul.hMul (HMul.hMul 2 (NNNorm.nnnorm ↑(Inv.inv a))) (NNNorm.nnnorm ↑(Inv.inv b))) (NNNorm.nnnorm (HSub.hSub (↑a) 1))) (NNNorm.nnnorm (HSub.hSub (↑b) 1)))","decl":"lemma nnnorm_commutator_units_sub_one_le (a b : αˣ) :\n    ‖(a * b * a⁻¹ * b⁻¹).val - 1‖₊ ≤ 2 * ‖a⁻¹.val‖₊ * ‖b⁻¹.val‖₊ * ‖a.val - 1‖₊ * ‖b.val - 1‖₊ := by\n  simpa using norm_commutator_units_sub_one_le a b\n\n"}
{"name":"Units.norm_pos","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\ninst✝¹ : NormedRing α\ninst✝ : Nontrivial α\nx : Units α\n⊢ LT.lt 0 (Norm.norm ↑x)","decl":"theorem Units.norm_pos [Nontrivial α] (x : αˣ) : 0 < ‖(x : α)‖ :=\n  norm_pos_iff.mpr (Units.ne_zero x)\n\n"}
{"name":"Units.nnnorm_pos","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\ninst✝¹ : NormedRing α\ninst✝ : Nontrivial α\nx : Units α\n⊢ LT.lt 0 (NNNorm.nnnorm ↑x)","decl":"theorem Units.nnnorm_pos [Nontrivial α] (x : αˣ) : 0 < ‖(x : α)‖₊ :=\n  x.norm_pos\n\n"}
{"name":"IsPowMul.restriction","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"R : Type u_5\nS : Type u_6\ninst✝² : NormedCommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nA : Subalgebra R S\nf : S → Real\nhf_pm : IsPowMul f\n⊢ IsPowMul fun x => f ↑x","decl":"/-- The restriction of a power-multiplicative function to a subalgebra is power-multiplicative. -/\ntheorem IsPowMul.restriction {R S : Type*} [NormedCommRing R] [CommRing S] [Algebra R S]\n    (A : Subalgebra R S) {f : S → ℝ} (hf_pm : IsPowMul f) :\n    IsPowMul fun x : A => f x.val := fun x n hn => by\n  simpa [SubsemiringClass.coe_pow] using hf_pm (↑x) hn\n\n"}
{"name":"norm_mul","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\ninst✝ : NormedDivisionRing α\na b : α\n⊢ Eq (Norm.norm (HMul.hMul a b)) (HMul.hMul (Norm.norm a) (Norm.norm b))","decl":"@[simp]\ntheorem norm_mul (a b : α) : ‖a * b‖ = ‖a‖ * ‖b‖ :=\n  NormedDivisionRing.norm_mul' a b\n\n"}
{"name":"NormedDivisionRing.to_normOneClass","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\ninst✝ : NormedDivisionRing α\n⊢ NormOneClass α","decl":"instance (priority := 900) NormedDivisionRing.to_normOneClass : NormOneClass α :=\n  ⟨mul_left_cancel₀ (mt norm_eq_zero.1 (one_ne_zero' α)) <| by rw [← norm_mul, mul_one, mul_one]⟩\n\n"}
{"name":"isAbsoluteValue_norm","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\ninst✝ : NormedDivisionRing α\n⊢ IsAbsoluteValue Norm.norm","decl":"instance isAbsoluteValue_norm : IsAbsoluteValue (norm : α → ℝ) where\n  abv_nonneg' := norm_nonneg\n  abv_eq_zero' := norm_eq_zero\n  abv_add' := norm_add_le\n  abv_mul' := norm_mul\n\n"}
{"name":"nnnorm_mul","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\ninst✝ : NormedDivisionRing α\na b : α\n⊢ Eq (NNNorm.nnnorm (HMul.hMul a b)) (HMul.hMul (NNNorm.nnnorm a) (NNNorm.nnnorm b))","decl":"@[simp] lemma nnnorm_mul (a b : α) : ‖a * b‖₊ = ‖a‖₊ * ‖b‖₊ := NNReal.eq <| norm_mul a b\n"}
{"name":"enorm_mul","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\ninst✝ : NormedDivisionRing α\na b : α\n⊢ Eq (ENorm.enorm (HMul.hMul a b)) (HMul.hMul (ENorm.enorm a) (ENorm.enorm b))","decl":"@[simp] lemma enorm_mul (a b : α) : ‖a * b‖ₑ = ‖a‖ₑ * ‖b‖ₑ := by simp [enorm]\n\n"}
{"name":"normHom_apply","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\ninst✝ : NormedDivisionRing α\nx✝ : α\n⊢ Eq (normHom x✝) (Norm.norm x✝)","decl":"/-- `norm` as a `MonoidWithZeroHom`. -/\n@[simps]\ndef normHom : α →*₀ ℝ where\n  toFun := (‖·‖)\n  map_zero' := norm_zero\n  map_one' := norm_one\n  map_mul' := norm_mul\n\n"}
{"name":"nnnormHom_apply","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\ninst✝ : NormedDivisionRing α\nx✝ : α\n⊢ Eq (nnnormHom x✝) (NNNorm.nnnorm x✝)","decl":"/-- `nnnorm` as a `MonoidWithZeroHom`. -/\n@[simps]\ndef nnnormHom : α →*₀ ℝ≥0 where\n  toFun := (‖·‖₊)\n  map_zero' := nnnorm_zero\n  map_one' := nnnorm_one\n  map_mul' := nnnorm_mul\n\n"}
{"name":"norm_pow","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\ninst✝ : NormedDivisionRing α\na : α\nn : Nat\n⊢ Eq (Norm.norm (HPow.hPow a n)) (HPow.hPow (Norm.norm a) n)","decl":"@[simp]\ntheorem norm_pow (a : α) : ∀ n : ℕ, ‖a ^ n‖ = ‖a‖ ^ n :=\n  (normHom.toMonoidHom : α →* ℝ).map_pow a\n\n"}
{"name":"nnnorm_pow","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\ninst✝ : NormedDivisionRing α\na : α\nn : Nat\n⊢ Eq (NNNorm.nnnorm (HPow.hPow a n)) (HPow.hPow (NNNorm.nnnorm a) n)","decl":"@[simp]\ntheorem nnnorm_pow (a : α) (n : ℕ) : ‖a ^ n‖₊ = ‖a‖₊ ^ n :=\n  (nnnormHom.toMonoidHom : α →* ℝ≥0).map_pow a n\n\n"}
{"name":"enorm_pow","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\ninst✝ : NormedDivisionRing α\na : α\nn : Nat\n⊢ Eq (ENorm.enorm (HPow.hPow a n)) (HPow.hPow (ENorm.enorm a) n)","decl":"@[simp] lemma enorm_pow (a : α) (n : ℕ) : ‖a ^ n‖ₑ = ‖a‖ₑ ^ n := by simp [enorm]\n\n"}
{"name":"List.norm_prod","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\ninst✝ : NormedDivisionRing α\nl : List α\n⊢ Eq (Norm.norm l.prod) (List.map Norm.norm l).prod","decl":"protected theorem List.norm_prod (l : List α) : ‖l.prod‖ = (l.map norm).prod :=\n  map_list_prod (normHom.toMonoidHom : α →* ℝ) _\n\n"}
{"name":"List.nnnorm_prod","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\ninst✝ : NormedDivisionRing α\nl : List α\n⊢ Eq (NNNorm.nnnorm l.prod) (List.map NNNorm.nnnorm l).prod","decl":"protected theorem List.nnnorm_prod (l : List α) : ‖l.prod‖₊ = (l.map nnnorm).prod :=\n  map_list_prod (nnnormHom.toMonoidHom : α →* ℝ≥0) _\n\n"}
{"name":"norm_div","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\ninst✝ : NormedDivisionRing α\na b : α\n⊢ Eq (Norm.norm (HDiv.hDiv a b)) (HDiv.hDiv (Norm.norm a) (Norm.norm b))","decl":"@[simp]\ntheorem norm_div (a b : α) : ‖a / b‖ = ‖a‖ / ‖b‖ :=\n  map_div₀ (normHom : α →*₀ ℝ) a b\n\n"}
{"name":"nnnorm_div","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\ninst✝ : NormedDivisionRing α\na b : α\n⊢ Eq (NNNorm.nnnorm (HDiv.hDiv a b)) (HDiv.hDiv (NNNorm.nnnorm a) (NNNorm.nnnorm b))","decl":"@[simp]\ntheorem nnnorm_div (a b : α) : ‖a / b‖₊ = ‖a‖₊ / ‖b‖₊ :=\n  map_div₀ (nnnormHom : α →*₀ ℝ≥0) a b\n\n"}
{"name":"norm_inv","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\ninst✝ : NormedDivisionRing α\na : α\n⊢ Eq (Norm.norm (Inv.inv a)) (Inv.inv (Norm.norm a))","decl":"@[simp]\ntheorem norm_inv (a : α) : ‖a⁻¹‖ = ‖a‖⁻¹ :=\n  map_inv₀ (normHom : α →*₀ ℝ) a\n\n"}
{"name":"nnnorm_inv","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\ninst✝ : NormedDivisionRing α\na : α\n⊢ Eq (NNNorm.nnnorm (Inv.inv a)) (Inv.inv (NNNorm.nnnorm a))","decl":"@[simp]\ntheorem nnnorm_inv (a : α) : ‖a⁻¹‖₊ = ‖a‖₊⁻¹ :=\n  NNReal.eq <| by simp\n\n"}
{"name":"enorm_inv","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\ninst✝ : NormedDivisionRing α\na : α\nha : Ne a 0\n⊢ Eq (ENorm.enorm (Inv.inv a)) (Inv.inv (ENorm.enorm a))","decl":"@[simp]\nlemma enorm_inv {a : α} (ha : a ≠ 0) : ‖a⁻¹‖ₑ = ‖a‖ₑ⁻¹ := by simp [enorm, ENNReal.coe_inv, ha]\n\n"}
{"name":"norm_zpow","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\ninst✝ : NormedDivisionRing α\na : α\nn : Int\n⊢ Eq (Norm.norm (HPow.hPow a n)) (HPow.hPow (Norm.norm a) n)","decl":"@[simp]\ntheorem norm_zpow : ∀ (a : α) (n : ℤ), ‖a ^ n‖ = ‖a‖ ^ n :=\n  map_zpow₀ (normHom : α →*₀ ℝ)\n\n"}
{"name":"nnnorm_zpow","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\ninst✝ : NormedDivisionRing α\na : α\nn : Int\n⊢ Eq (NNNorm.nnnorm (HPow.hPow a n)) (HPow.hPow (NNNorm.nnnorm a) n)","decl":"@[simp]\ntheorem nnnorm_zpow : ∀ (a : α) (n : ℤ), ‖a ^ n‖₊ = ‖a‖₊ ^ n :=\n  map_zpow₀ (nnnormHom : α →*₀ ℝ≥0)\n\n"}
{"name":"dist_inv_inv₀","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\ninst✝ : NormedDivisionRing α\nz w : α\nhz : Ne z 0\nhw : Ne w 0\n⊢ Eq (Dist.dist (Inv.inv z) (Inv.inv w)) (HDiv.hDiv (Dist.dist z w) (HMul.hMul (Norm.norm z) (Norm.norm w)))","decl":"theorem dist_inv_inv₀ {z w : α} (hz : z ≠ 0) (hw : w ≠ 0) :\n    dist z⁻¹ w⁻¹ = dist z w / (‖z‖ * ‖w‖) := by\n  rw [dist_eq_norm, inv_sub_inv' hz hw, norm_mul, norm_mul, norm_inv, norm_inv, mul_comm ‖z‖⁻¹,\n    mul_assoc, dist_eq_norm', div_eq_mul_inv, mul_inv]\n\n"}
{"name":"nndist_inv_inv₀","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\ninst✝ : NormedDivisionRing α\nz w : α\nhz : Ne z 0\nhw : Ne w 0\n⊢ Eq (NNDist.nndist (Inv.inv z) (Inv.inv w)) (HDiv.hDiv (NNDist.nndist z w) (HMul.hMul (NNNorm.nnnorm z) (NNNorm.nnnorm w)))","decl":"theorem nndist_inv_inv₀ {z w : α} (hz : z ≠ 0) (hw : w ≠ 0) :\n    nndist z⁻¹ w⁻¹ = nndist z w / (‖z‖₊ * ‖w‖₊) :=\n  NNReal.eq <| dist_inv_inv₀ hz hw\n\n"}
{"name":"norm_commutator_sub_one_le","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\ninst✝ : NormedDivisionRing α\na b : α\nha : Ne a 0\nhb : Ne b 0\n⊢ LE.le (Norm.norm (HSub.hSub (HMul.hMul (HMul.hMul (HMul.hMul a b) (Inv.inv a)) (Inv.inv b)) 1)) (HMul.hMul (HMul.hMul (HMul.hMul (HMul.hMul 2 (Inv.inv (Norm.norm a))) (Inv.inv (Norm.norm b))) (Norm.norm (HSub.hSub a 1))) (Norm.norm (HSub.hSub b 1)))","decl":"lemma norm_commutator_sub_one_le (ha : a ≠ 0) (hb : b ≠ 0) :\n    ‖a * b * a⁻¹ * b⁻¹ - 1‖ ≤ 2 * ‖a‖⁻¹ * ‖b‖⁻¹ * ‖a - 1‖ * ‖b - 1‖ := by\n  simpa using norm_commutator_units_sub_one_le (.mk0 a ha) (.mk0 b hb)\n\n"}
{"name":"nnnorm_commutator_sub_one_le","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\ninst✝ : NormedDivisionRing α\na b : α\nha : Ne a 0\nhb : Ne b 0\n⊢ LE.le (NNNorm.nnnorm (HSub.hSub (HMul.hMul (HMul.hMul (HMul.hMul a b) (Inv.inv a)) (Inv.inv b)) 1)) (HMul.hMul (HMul.hMul (HMul.hMul (HMul.hMul 2 (Inv.inv (NNNorm.nnnorm a))) (Inv.inv (NNNorm.nnnorm b))) (NNNorm.nnnorm (HSub.hSub a 1))) (NNNorm.nnnorm (HSub.hSub b 1)))","decl":"lemma nnnorm_commutator_sub_one_le (ha : a ≠ 0) (hb : b ≠ 0) :\n    ‖a * b * a⁻¹ * b⁻¹ - 1‖₊ ≤ 2 * ‖a‖₊⁻¹ * ‖b‖₊⁻¹ * ‖a - 1‖₊ * ‖b - 1‖₊ := by\n  simpa using nnnorm_commutator_units_sub_one_le (.mk0 a ha) (.mk0 b hb)\n\n"}
{"name":"NormedDivisionRing.norm_eq_one_iff_ne_zero_of_discrete","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"𝕜 : Type u_5\ninst✝¹ : NormedDivisionRing 𝕜\ninst✝ : DiscreteTopology 𝕜\nx : 𝕜\n⊢ Iff (Eq (Norm.norm x) 1) (Ne x 0)","decl":"lemma norm_eq_one_iff_ne_zero_of_discrete {x : 𝕜} : ‖x‖ = 1 ↔ x ≠ 0 := by\n  constructor <;> intro hx\n  · contrapose! hx\n    simp [hx]\n  · have : IsOpen {(0 : 𝕜)} := isOpen_discrete {0}\n    simp_rw [Metric.isOpen_singleton_iff, dist_eq_norm, sub_zero] at this\n    obtain ⟨ε, εpos, h'⟩ := this\n    wlog h : ‖x‖ < 1 generalizing 𝕜 with H\n    · push_neg at h\n      rcases h.eq_or_lt with h|h\n      · rw [h]\n      replace h := norm_inv x ▸ inv_lt_one_of_one_lt₀ h\n      rw [← inv_inj, inv_one, ← norm_inv]\n      exact H (by simpa) h' h\n    obtain ⟨k, hk⟩ : ∃ k : ℕ, ‖x‖ ^ k < ε := exists_pow_lt_of_lt_one εpos h\n    rw [← norm_pow] at hk\n    specialize h' _ hk\n    simp [hx] at h'\n\n"}
{"name":"NormedDivisionRing.norm_le_one_of_discrete","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"𝕜 : Type u_5\ninst✝¹ : NormedDivisionRing 𝕜\ninst✝ : DiscreteTopology 𝕜\nx : 𝕜\n⊢ LE.le (Norm.norm x) 1","decl":"@[simp]\nlemma norm_le_one_of_discrete\n    (x : 𝕜) : ‖x‖ ≤ 1 := by\n  rcases eq_or_ne x 0 with rfl|hx\n  · simp\n  · simp [norm_eq_one_iff_ne_zero_of_discrete.mpr hx]\n\n"}
{"name":"NormedDivisionRing.unitClosedBall_eq_univ_of_discrete","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"𝕜 : Type u_5\ninst✝¹ : NormedDivisionRing 𝕜\ninst✝ : DiscreteTopology 𝕜\n⊢ Eq (Metric.closedBall 0 1) Set.univ","decl":"lemma unitClosedBall_eq_univ_of_discrete : (Metric.closedBall 0 1 : Set 𝕜) = Set.univ := by\n  ext\n  simp\n\n"}
{"name":"NormedDivisionRing.discreteTopology_unit_closedBall_eq_univ","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"𝕜 : Type u_5\ninst✝¹ : NormedDivisionRing 𝕜\ninst✝ : DiscreteTopology 𝕜\n⊢ Eq (Metric.closedBall 0 1) Set.univ","decl":"@[deprecated (since := \"2024-12-01\")]\nalias discreteTopology_unit_closedBall_eq_univ := unitClosedBall_eq_univ_of_discrete\n\n"}
{"name":"NormedField.norm_mul'","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_5\nself : NormedField α\na b : α\n⊢ Eq (Norm.norm (HMul.hMul a b)) (HMul.hMul (Norm.norm a) (Norm.norm b))","decl":"/-- A normed field is a field with a norm satisfying ‖x y‖ = ‖x‖ ‖y‖. -/\nclass NormedField (α : Type*) extends Norm α, Field α, MetricSpace α where\n  /-- The distance is induced by the norm. -/\n  dist_eq : ∀ x y, dist x y = norm (x - y)\n  /-- The norm is multiplicative. -/\n  norm_mul' : ∀ a b, norm (a * b) = norm a * norm b\n\n"}
{"name":"NormedField.dist_eq","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_5\nself : NormedField α\nx y : α\n⊢ Eq (Dist.dist x y) (Norm.norm (HSub.hSub x y))","decl":"/-- A normed field is a field with a norm satisfying ‖x y‖ = ‖x‖ ‖y‖. -/\nclass NormedField (α : Type*) extends Norm α, Field α, MetricSpace α where\n  /-- The distance is induced by the norm. -/\n  dist_eq : ∀ x y, dist x y = norm (x - y)\n  /-- The norm is multiplicative. -/\n  norm_mul' : ∀ a b, norm (a * b) = norm a * norm b\n\n"}
{"name":"NontriviallyNormedField.non_trivial","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_5\nself : NontriviallyNormedField α\n⊢ Exists fun x => LT.lt 1 (Norm.norm x)","decl":"/-- A nontrivially normed field is a normed field in which there is an element of norm different\nfrom `0` and `1`. This makes it possible to bring any element arbitrarily close to `0` by\nmultiplication by the powers of any element, and thus to relate algebra and topology. -/\nclass NontriviallyNormedField (α : Type*) extends NormedField α where\n  /-- The norm attains a value exceeding 1. -/\n  non_trivial : ∃ x : α, 1 < ‖x‖\n\n"}
{"name":"DenselyNormedField.lt_norm_lt","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_5\nself : DenselyNormedField α\nx y : Real\na✝¹ : LE.le 0 x\na✝ : LT.lt x y\n⊢ Exists fun a => And (LT.lt x (Norm.norm a)) (LT.lt (Norm.norm a) y)","decl":"/-- A densely normed field is a normed field for which the image of the norm is dense in `ℝ≥0`,\nwhich means it is also nontrivially normed. However, not all nontrivally normed fields are densely\nnormed; in particular, the `Padic`s exhibit this fact. -/\nclass DenselyNormedField (α : Type*) extends NormedField α where\n  /-- The range of the norm is dense in the collection of nonnegative real numbers. -/\n  lt_norm_lt : ∀ x y : ℝ, 0 ≤ x → x < y → ∃ a : α, x < ‖a‖ ∧ ‖a‖ < y\n\n"}
{"name":"norm_prod","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : NormedField α\ns : Finset β\nf : β → α\n⊢ Eq (Norm.norm (s.prod fun b => f b)) (s.prod fun b => Norm.norm (f b))","decl":"@[simp]\ntheorem norm_prod (s : Finset β) (f : β → α) : ‖∏ b ∈ s, f b‖ = ∏ b ∈ s, ‖f b‖ :=\n  map_prod normHom.toMonoidHom f s\n\n"}
{"name":"nnnorm_prod","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : NormedField α\ns : Finset β\nf : β → α\n⊢ Eq (NNNorm.nnnorm (s.prod fun b => f b)) (s.prod fun b => NNNorm.nnnorm (f b))","decl":"@[simp]\ntheorem nnnorm_prod (s : Finset β) (f : β → α) : ‖∏ b ∈ s, f b‖₊ = ∏ b ∈ s, ‖f b‖₊ :=\n  map_prod nnnormHom.toMonoidHom f s\n\n"}
{"name":"NormedField.exists_one_lt_norm","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\ninst✝ : NontriviallyNormedField α\n⊢ Exists fun x => LT.lt 1 (Norm.norm x)","decl":"theorem exists_one_lt_norm : ∃ x : α, 1 < ‖x‖ :=\n  ‹NontriviallyNormedField α›.non_trivial\n\n"}
{"name":"NormedField.exists_lt_norm","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\ninst✝ : NontriviallyNormedField α\nr : Real\n⊢ Exists fun x => LT.lt r (Norm.norm x)","decl":"theorem exists_lt_norm (r : ℝ) : ∃ x : α, r < ‖x‖ :=\n  let ⟨w, hw⟩ := exists_one_lt_norm α\n  let ⟨n, hn⟩ := pow_unbounded_of_one_lt r hw\n  ⟨w ^ n, by rwa [norm_pow]⟩\n\n"}
{"name":"NormedField.exists_norm_lt","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\ninst✝ : NontriviallyNormedField α\nr : Real\nhr : LT.lt 0 r\n⊢ Exists fun x => And (LT.lt 0 (Norm.norm x)) (LT.lt (Norm.norm x) r)","decl":"theorem exists_norm_lt {r : ℝ} (hr : 0 < r) : ∃ x : α, 0 < ‖x‖ ∧ ‖x‖ < r :=\n  let ⟨w, hw⟩ := exists_lt_norm α r⁻¹\n  ⟨w⁻¹, by rwa [← Set.mem_Ioo, norm_inv, ← Set.mem_inv, Set.inv_Ioo_0_left hr]⟩\n\n"}
{"name":"NormedField.exists_norm_lt_one","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\ninst✝ : NontriviallyNormedField α\n⊢ Exists fun x => And (LT.lt 0 (Norm.norm x)) (LT.lt (Norm.norm x) 1)","decl":"theorem exists_norm_lt_one : ∃ x : α, 0 < ‖x‖ ∧ ‖x‖ < 1 :=\n  exists_norm_lt α one_pos\n\n"}
{"name":"NormedField.punctured_nhds_neBot","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\ninst✝ : NontriviallyNormedField α\nx : α\n⊢ (nhdsWithin x (HasCompl.compl (Singleton.singleton x))).NeBot","decl":"@[instance]\ntheorem punctured_nhds_neBot (x : α) : NeBot (𝓝[≠] x) := by\n  rw [← mem_closure_iff_nhdsWithin_neBot, Metric.mem_closure_iff]\n  rintro ε ε0\n  rcases exists_norm_lt α ε0 with ⟨b, hb0, hbε⟩\n  refine ⟨x + b, mt (Set.mem_singleton_iff.trans add_right_eq_self).1 <| norm_pos_iff.1 hb0, ?_⟩\n  rwa [dist_comm, dist_eq_norm, add_sub_cancel_left]\n\n"}
{"name":"NormedField.nhdsWithin_isUnit_neBot","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\ninst✝ : NontriviallyNormedField α\n⊢ (nhdsWithin 0 (setOf fun x => IsUnit x)).NeBot","decl":"@[instance]\ntheorem nhdsWithin_isUnit_neBot : NeBot (𝓝[{ x : α | IsUnit x }] 0) := by\n  simpa only [isUnit_iff_ne_zero] using punctured_nhds_neBot (0 : α)\n\n"}
{"name":"NormedField.exists_lt_norm_lt","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\ninst✝ : DenselyNormedField α\nr₁ r₂ : Real\nh₀ : LE.le 0 r₁\nh : LT.lt r₁ r₂\n⊢ Exists fun x => And (LT.lt r₁ (Norm.norm x)) (LT.lt (Norm.norm x) r₂)","decl":"theorem exists_lt_norm_lt {r₁ r₂ : ℝ} (h₀ : 0 ≤ r₁) (h : r₁ < r₂) : ∃ x : α, r₁ < ‖x‖ ∧ ‖x‖ < r₂ :=\n  DenselyNormedField.lt_norm_lt r₁ r₂ h₀ h\n\n"}
{"name":"NormedField.exists_lt_nnnorm_lt","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\ninst✝ : DenselyNormedField α\nr₁ r₂ : NNReal\nh : LT.lt r₁ r₂\n⊢ Exists fun x => And (LT.lt r₁ (NNNorm.nnnorm x)) (LT.lt (NNNorm.nnnorm x) r₂)","decl":"theorem exists_lt_nnnorm_lt {r₁ r₂ : ℝ≥0} (h : r₁ < r₂) : ∃ x : α, r₁ < ‖x‖₊ ∧ ‖x‖₊ < r₂ :=\n  mod_cast exists_lt_norm_lt α r₁.prop h\n\n"}
{"name":"NormedField.denselyOrdered_range_norm","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\ninst✝ : DenselyNormedField α\n⊢ DenselyOrdered ↑(Set.range Norm.norm)","decl":"instance denselyOrdered_range_norm : DenselyOrdered (Set.range (norm : α → ℝ)) where\n  dense := by\n    rintro ⟨-, x, rfl⟩ ⟨-, y, rfl⟩ hxy\n    let ⟨z, h⟩ := exists_lt_norm_lt α (norm_nonneg _) hxy\n    exact ⟨⟨‖z‖, z, rfl⟩, h⟩\n\n"}
{"name":"NormedField.denselyOrdered_range_nnnorm","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\ninst✝ : DenselyNormedField α\n⊢ DenselyOrdered ↑(Set.range NNNorm.nnnorm)","decl":"instance denselyOrdered_range_nnnorm : DenselyOrdered (Set.range (nnnorm : α → ℝ≥0)) where\n  dense := by\n    rintro ⟨-, x, rfl⟩ ⟨-, y, rfl⟩ hxy\n    let ⟨z, h⟩ := exists_lt_nnnorm_lt α hxy\n    exact ⟨⟨‖z‖₊, z, rfl⟩, h⟩\n\n"}
{"name":"Real.toNNReal_mul_nnnorm","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"x y : Real\nhx : LE.le 0 x\n⊢ Eq (HMul.hMul x.toNNReal (NNNorm.nnnorm y)) (NNNorm.nnnorm (HMul.hMul x y))","decl":"theorem toNNReal_mul_nnnorm {x : ℝ} (y : ℝ) (hx : 0 ≤ x) : x.toNNReal * ‖y‖₊ = ‖x * y‖₊ := by\n  ext\n  simp only [NNReal.coe_mul, nnnorm_mul, coe_nnnorm, Real.toNNReal_of_nonneg, norm_of_nonneg, hx,\n    NNReal.coe_mk]\n\n"}
{"name":"Real.nnnorm_mul_toNNReal","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"x y : Real\nhy : LE.le 0 y\n⊢ Eq (HMul.hMul (NNNorm.nnnorm x) y.toNNReal) (NNNorm.nnnorm (HMul.hMul x y))","decl":"theorem nnnorm_mul_toNNReal (x : ℝ) {y : ℝ} (hy : 0 ≤ y) : ‖x‖₊ * y.toNNReal = ‖x * y‖₊ := by\n  rw [mul_comm, mul_comm x, toNNReal_mul_nnnorm x hy]\n\n"}
{"name":"NNReal.norm_eq","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"x : NNReal\n⊢ Eq (Norm.norm ↑x) ↑x","decl":"theorem norm_eq (x : ℝ≥0) : ‖(x : ℝ)‖ = x := by rw [Real.norm_eq_abs, x.abs_eq]\n\n"}
{"name":"NNReal.nnnorm_eq","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"x : NNReal\n⊢ Eq (NNNorm.nnnorm ↑x) x","decl":"@[simp] lemma nnnorm_eq (x : ℝ≥0) : ‖(x : ℝ)‖₊ = x := by ext; simp [nnnorm]\n"}
{"name":"NNReal.enorm_eq","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"x : NNReal\n⊢ Eq (ENorm.enorm ↑x) ↑x","decl":"@[simp] lemma enorm_eq (x : ℝ≥0) : ‖(x : ℝ)‖ₑ = x := by simp [enorm]\n\n"}
{"name":"NormedAddCommGroup.tendsto_atTop","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\ninst✝³ : Nonempty α\ninst✝² : Preorder α\ninst✝¹ : IsDirected α fun x1 x2 => LE.le x1 x2\nβ : Type u_5\ninst✝ : SeminormedAddCommGroup β\nf : α → β\nb : β\n⊢ Iff (Filter.Tendsto f Filter.atTop (nhds b)) (∀ (ε : Real), LT.lt 0 ε → Exists fun N => ∀ (n : α), LE.le N n → LT.lt (Norm.norm (HSub.hSub (f n) b)) ε)","decl":"/-- A restatement of `MetricSpace.tendsto_atTop` in terms of the norm. -/\ntheorem NormedAddCommGroup.tendsto_atTop [Nonempty α] [Preorder α] [IsDirected α (· ≤ ·)]\n    {β : Type*} [SeminormedAddCommGroup β] {f : α → β} {b : β} :\n    Tendsto f atTop (𝓝 b) ↔ ∀ ε, 0 < ε → ∃ N, ∀ n, N ≤ n → ‖f n - b‖ < ε :=\n  (atTop_basis.tendsto_iff Metric.nhds_basis_ball).trans (by simp [dist_eq_norm])\n\n"}
{"name":"NormedAddCommGroup.tendsto_atTop'","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"α : Type u_2\ninst✝⁴ : Nonempty α\ninst✝³ : Preorder α\ninst✝² : IsDirected α fun x1 x2 => LE.le x1 x2\ninst✝¹ : NoMaxOrder α\nβ : Type u_5\ninst✝ : SeminormedAddCommGroup β\nf : α → β\nb : β\n⊢ Iff (Filter.Tendsto f Filter.atTop (nhds b)) (∀ (ε : Real), LT.lt 0 ε → Exists fun N => ∀ (n : α), LT.lt N n → LT.lt (Norm.norm (HSub.hSub (f n) b)) ε)","decl":"/-- A variant of `NormedAddCommGroup.tendsto_atTop` that\nuses `∃ N, ∀ n > N, ...` rather than `∃ N, ∀ n ≥ N, ...`\n-/\ntheorem NormedAddCommGroup.tendsto_atTop' [Nonempty α] [Preorder α] [IsDirected α (· ≤ ·)]\n    [NoMaxOrder α] {β : Type*} [SeminormedAddCommGroup β] {f : α → β} {b : β} :\n    Tendsto f atTop (𝓝 b) ↔ ∀ ε, 0 < ε → ∃ N, ∀ n, N < n → ‖f n - b‖ < ε :=\n  (atTop_basis_Ioi.tendsto_iff Metric.nhds_basis_ball).trans (by simp [dist_eq_norm])\n\n"}
{"name":"RingHomIsometric.is_iso","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"R₁ : Type u_5\nR₂ : Type u_6\ninst✝³ : Semiring R₁\ninst✝² : Semiring R₂\ninst✝¹ : Norm R₁\ninst✝ : Norm R₂\nσ : RingHom R₁ R₂\nself : RingHomIsometric σ\nx : R₁\n⊢ Eq (Norm.norm (σ x)) (Norm.norm x)","decl":"/-- This class states that a ring homomorphism is isometric. This is a sufficient assumption\nfor a continuous semilinear map to be bounded and this is the main use for this typeclass. -/\nclass RingHomIsometric [Semiring R₁] [Semiring R₂] [Norm R₁] [Norm R₂] (σ : R₁ →+* R₂) : Prop where\n  /-- The ring homomorphism is an isometry. -/\n  is_iso : ∀ {x : R₁}, ‖σ x‖ = ‖x‖\n\n"}
{"name":"RingHomIsometric.ids","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"R₁ : Type u_5\ninst✝ : SeminormedRing R₁\n⊢ RingHomIsometric (RingHom.id R₁)","decl":"instance RingHomIsometric.ids : RingHomIsometric (RingHom.id R₁) :=\n  ⟨rfl⟩\n\n"}
{"name":"NormOneClass.induced","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"F : Type u_8\nR : Type u_9\nS : Type u_10\ninst✝⁴ : Ring R\ninst✝³ : SeminormedRing S\ninst✝² : NormOneClass S\ninst✝¹ : FunLike F R S\ninst✝ : RingHomClass F R S\nf : F\n⊢ NormOneClass R","decl":"/-- A ring homomorphism from a `Ring R` to a `SeminormedRing S` which induces the norm structure\n`SeminormedRing.induced` makes `R` satisfy `‖(1 : R)‖ = 1` whenever `‖(1 : S)‖ = 1`. -/\ntheorem NormOneClass.induced {F : Type*} (R S : Type*) [Ring R] [SeminormedRing S]\n    [NormOneClass S] [FunLike F R S] [RingHomClass F R S] (f : F) :\n    @NormOneClass R (SeminormedRing.induced R S f).toNorm _ :=\n  -- Porting note: is this `let` a bad idea somehow?\n  let _ : SeminormedRing R := SeminormedRing.induced R S f\n  { norm_one := (congr_arg norm (map_one f)).trans norm_one }\n\n"}
{"name":"SubringClass.toNormOneClass","module":"Mathlib.Analysis.Normed.Field.Basic","initialProofState":"S : Type u_5\nR : Type u_6\ninst✝³ : SetLike S R\ninst✝² : SeminormedRing R\ninst✝¹ : NormOneClass R\ninst✝ : SubringClass S R\ns : S\n⊢ NormOneClass (Subtype fun x => Membership.mem s x)","decl":"instance toNormOneClass [SeminormedRing R] [NormOneClass R] [SubringClass S R] (s : S) :\n    NormOneClass s :=\n  .induced s R <| SubringClass.subtype _\n\n"}
