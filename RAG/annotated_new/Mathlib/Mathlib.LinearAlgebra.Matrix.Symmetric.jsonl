{"name":"Matrix.IsSymm.eq","module":"Mathlib.LinearAlgebra.Matrix.Symmetric","initialProofState":"α : Type u_1\nn : Type u_3\nA : Matrix n n α\nh : A.IsSymm\n⊢ Eq A.transpose A","decl":"theorem IsSymm.eq {A : Matrix n n α} (h : A.IsSymm) : Aᵀ = A :=\n  h\n\n"}
{"name":"Matrix.IsSymm.ext_iff","module":"Mathlib.LinearAlgebra.Matrix.Symmetric","initialProofState":"α : Type u_1\nn : Type u_3\nA : Matrix n n α\n⊢ Iff A.IsSymm (∀ (i j : n), Eq (A j i) (A i j))","decl":"/-- A version of `Matrix.ext_iff` that unfolds the `Matrix.transpose`. -/\ntheorem IsSymm.ext_iff {A : Matrix n n α} : A.IsSymm ↔ ∀ i j, A j i = A i j :=\n  Matrix.ext_iff.symm\n\n"}
{"name":"Matrix.IsSymm.ext","module":"Mathlib.LinearAlgebra.Matrix.Symmetric","initialProofState":"α : Type u_1\nn : Type u_3\nA : Matrix n n α\na✝ : ∀ (i j : n), Eq (A j i) (A i j)\n⊢ A.IsSymm","decl":"/-- A version of `Matrix.ext` that unfolds the `Matrix.transpose`. -/\n-- @[ext] -- Porting note: removed attribute\ntheorem IsSymm.ext {A : Matrix n n α} : (∀ i j, A j i = A i j) → A.IsSymm :=\n  Matrix.ext\n\n"}
{"name":"Matrix.IsSymm.apply","module":"Mathlib.LinearAlgebra.Matrix.Symmetric","initialProofState":"α : Type u_1\nn : Type u_3\nA : Matrix n n α\nh : A.IsSymm\ni j : n\n⊢ Eq (A j i) (A i j)","decl":"theorem IsSymm.apply {A : Matrix n n α} (h : A.IsSymm) (i j : n) : A j i = A i j :=\n  IsSymm.ext_iff.1 h i j\n\n"}
{"name":"Matrix.isSymm_mul_transpose_self","module":"Mathlib.LinearAlgebra.Matrix.Symmetric","initialProofState":"α : Type u_1\nn : Type u_3\ninst✝¹ : Fintype n\ninst✝ : CommSemiring α\nA : Matrix n n α\n⊢ (HMul.hMul A A.transpose).IsSymm","decl":"theorem isSymm_mul_transpose_self [Fintype n] [CommSemiring α] (A : Matrix n n α) :\n    (A * Aᵀ).IsSymm :=\n  transpose_mul _ _\n\n"}
{"name":"Matrix.isSymm_transpose_mul_self","module":"Mathlib.LinearAlgebra.Matrix.Symmetric","initialProofState":"α : Type u_1\nn : Type u_3\ninst✝¹ : Fintype n\ninst✝ : CommSemiring α\nA : Matrix n n α\n⊢ (HMul.hMul A.transpose A).IsSymm","decl":"theorem isSymm_transpose_mul_self [Fintype n] [CommSemiring α] (A : Matrix n n α) :\n    (Aᵀ * A).IsSymm :=\n  transpose_mul _ _\n\n"}
{"name":"Matrix.isSymm_add_transpose_self","module":"Mathlib.LinearAlgebra.Matrix.Symmetric","initialProofState":"α : Type u_1\nn : Type u_3\ninst✝ : AddCommSemigroup α\nA : Matrix n n α\n⊢ (HAdd.hAdd A A.transpose).IsSymm","decl":"theorem isSymm_add_transpose_self [AddCommSemigroup α] (A : Matrix n n α) : (A + Aᵀ).IsSymm :=\n  add_comm _ _\n\n"}
{"name":"Matrix.isSymm_transpose_add_self","module":"Mathlib.LinearAlgebra.Matrix.Symmetric","initialProofState":"α : Type u_1\nn : Type u_3\ninst✝ : AddCommSemigroup α\nA : Matrix n n α\n⊢ (HAdd.hAdd A.transpose A).IsSymm","decl":"theorem isSymm_transpose_add_self [AddCommSemigroup α] (A : Matrix n n α) : (Aᵀ + A).IsSymm :=\n  add_comm _ _\n\n"}
{"name":"Matrix.isSymm_zero","module":"Mathlib.LinearAlgebra.Matrix.Symmetric","initialProofState":"α : Type u_1\nn : Type u_3\ninst✝ : Zero α\n⊢ Matrix.IsSymm 0","decl":"@[simp]\ntheorem isSymm_zero [Zero α] : (0 : Matrix n n α).IsSymm :=\n  transpose_zero\n\n"}
{"name":"Matrix.isSymm_one","module":"Mathlib.LinearAlgebra.Matrix.Symmetric","initialProofState":"α : Type u_1\nn : Type u_3\ninst✝² : DecidableEq n\ninst✝¹ : Zero α\ninst✝ : One α\n⊢ Matrix.IsSymm 1","decl":"@[simp]\ntheorem isSymm_one [DecidableEq n] [Zero α] [One α] : (1 : Matrix n n α).IsSymm :=\n  transpose_one\n\n"}
{"name":"Matrix.IsSymm.pow","module":"Mathlib.LinearAlgebra.Matrix.Symmetric","initialProofState":"α : Type u_1\nn : Type u_3\ninst✝² : CommSemiring α\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nA : Matrix n n α\nh : A.IsSymm\nk : Nat\n⊢ (HPow.hPow A k).IsSymm","decl":"theorem IsSymm.pow [CommSemiring α] [Fintype n] [DecidableEq n] {A : Matrix n n α} (h : A.IsSymm)\n    (k : ℕ) :\n    (A ^ k).IsSymm := by\n  rw [IsSymm, transpose_pow, h]\n\n"}
{"name":"Matrix.IsSymm.map","module":"Mathlib.LinearAlgebra.Matrix.Symmetric","initialProofState":"α : Type u_1\nβ : Type u_2\nn : Type u_3\nA : Matrix n n α\nh : A.IsSymm\nf : α → β\n⊢ (A.map f).IsSymm","decl":"@[simp]\ntheorem IsSymm.map {A : Matrix n n α} (h : A.IsSymm) (f : α → β) : (A.map f).IsSymm :=\n  transpose_map.symm.trans (h.symm ▸ rfl)\n\n"}
{"name":"Matrix.IsSymm.transpose","module":"Mathlib.LinearAlgebra.Matrix.Symmetric","initialProofState":"α : Type u_1\nn : Type u_3\nA : Matrix n n α\nh : A.IsSymm\n⊢ A.transpose.IsSymm","decl":"@[simp]\ntheorem IsSymm.transpose {A : Matrix n n α} (h : A.IsSymm) : Aᵀ.IsSymm :=\n  congr_arg _ h\n\n"}
{"name":"Matrix.IsSymm.conjTranspose","module":"Mathlib.LinearAlgebra.Matrix.Symmetric","initialProofState":"α : Type u_1\nn : Type u_3\ninst✝ : Star α\nA : Matrix n n α\nh : A.IsSymm\n⊢ A.conjTranspose.IsSymm","decl":"@[simp]\ntheorem IsSymm.conjTranspose [Star α] {A : Matrix n n α} (h : A.IsSymm) : Aᴴ.IsSymm :=\n  h.transpose.map _\n\n"}
{"name":"Matrix.IsSymm.neg","module":"Mathlib.LinearAlgebra.Matrix.Symmetric","initialProofState":"α : Type u_1\nn : Type u_3\ninst✝ : Neg α\nA : Matrix n n α\nh : A.IsSymm\n⊢ (Neg.neg A).IsSymm","decl":"@[simp]\ntheorem IsSymm.neg [Neg α] {A : Matrix n n α} (h : A.IsSymm) : (-A).IsSymm :=\n  (transpose_neg _).trans (congr_arg _ h)\n\n"}
{"name":"Matrix.IsSymm.add","module":"Mathlib.LinearAlgebra.Matrix.Symmetric","initialProofState":"α : Type u_1\nn : Type u_3\nA B : Matrix n n α\ninst✝ : Add α\nhA : A.IsSymm\nhB : B.IsSymm\n⊢ (HAdd.hAdd A B).IsSymm","decl":"@[simp]\ntheorem IsSymm.add {A B : Matrix n n α} [Add α] (hA : A.IsSymm) (hB : B.IsSymm) : (A + B).IsSymm :=\n  (transpose_add _ _).trans (hA.symm ▸ hB.symm ▸ rfl)\n\n"}
{"name":"Matrix.IsSymm.sub","module":"Mathlib.LinearAlgebra.Matrix.Symmetric","initialProofState":"α : Type u_1\nn : Type u_3\nA B : Matrix n n α\ninst✝ : Sub α\nhA : A.IsSymm\nhB : B.IsSymm\n⊢ (HSub.hSub A B).IsSymm","decl":"@[simp]\ntheorem IsSymm.sub {A B : Matrix n n α} [Sub α] (hA : A.IsSymm) (hB : B.IsSymm) : (A - B).IsSymm :=\n  (transpose_sub _ _).trans (hA.symm ▸ hB.symm ▸ rfl)\n\n"}
{"name":"Matrix.IsSymm.smul","module":"Mathlib.LinearAlgebra.Matrix.Symmetric","initialProofState":"α : Type u_1\nn : Type u_3\nR : Type u_5\ninst✝ : SMul R α\nA : Matrix n n α\nh : A.IsSymm\nk : R\n⊢ (HSMul.hSMul k A).IsSymm","decl":"@[simp]\ntheorem IsSymm.smul [SMul R α] {A : Matrix n n α} (h : A.IsSymm) (k : R) : (k • A).IsSymm :=\n  (transpose_smul _ _).trans (congr_arg _ h)\n\n"}
{"name":"Matrix.IsSymm.submatrix","module":"Mathlib.LinearAlgebra.Matrix.Symmetric","initialProofState":"α : Type u_1\nn : Type u_3\nm : Type u_4\nA : Matrix n n α\nh : A.IsSymm\nf : m → n\n⊢ (A.submatrix f f).IsSymm","decl":"@[simp]\ntheorem IsSymm.submatrix {A : Matrix n n α} (h : A.IsSymm) (f : m → n) : (A.submatrix f f).IsSymm :=\n  (transpose_submatrix _ _ _).trans (h.symm ▸ rfl)\n\n"}
{"name":"Matrix.isSymm_diagonal","module":"Mathlib.LinearAlgebra.Matrix.Symmetric","initialProofState":"α : Type u_1\nn : Type u_3\ninst✝¹ : DecidableEq n\ninst✝ : Zero α\nv : n → α\n⊢ (Matrix.diagonal v).IsSymm","decl":"/-- The diagonal matrix `diagonal v` is symmetric. -/\n@[simp]\ntheorem isSymm_diagonal [DecidableEq n] [Zero α] (v : n → α) : (diagonal v).IsSymm :=\n  diagonal_transpose _\n\n"}
{"name":"Matrix.IsSymm.fromBlocks","module":"Mathlib.LinearAlgebra.Matrix.Symmetric","initialProofState":"α : Type u_1\nn : Type u_3\nm : Type u_4\nA : Matrix m m α\nB : Matrix m n α\nC : Matrix n m α\nD : Matrix n n α\nhA : A.IsSymm\nhBC : Eq B.transpose C\nhD : D.IsSymm\n⊢ (Matrix.fromBlocks A B C D).IsSymm","decl":"/-- A block matrix `A.fromBlocks B C D` is symmetric,\n    if `A` and `D` are symmetric and `Bᵀ = C`. -/\ntheorem IsSymm.fromBlocks {A : Matrix m m α} {B : Matrix m n α} {C : Matrix n m α}\n    {D : Matrix n n α} (hA : A.IsSymm) (hBC : Bᵀ = C) (hD : D.IsSymm) :\n    (A.fromBlocks B C D).IsSymm := by\n  have hCB : Cᵀ = B := by\n    rw [← hBC]\n    simp\n  unfold Matrix.IsSymm\n  rw [fromBlocks_transpose, hA, hCB, hBC, hD]\n\n"}
{"name":"Matrix.isSymm_fromBlocks_iff","module":"Mathlib.LinearAlgebra.Matrix.Symmetric","initialProofState":"α : Type u_1\nn : Type u_3\nm : Type u_4\nA : Matrix m m α\nB : Matrix m n α\nC : Matrix n m α\nD : Matrix n n α\n⊢ Iff (Matrix.fromBlocks A B C D).IsSymm (And A.IsSymm (And (Eq B.transpose C) (And (Eq C.transpose B) D.IsSymm)))","decl":"/-- This is the `iff` version of `Matrix.isSymm.fromBlocks`. -/\ntheorem isSymm_fromBlocks_iff {A : Matrix m m α} {B : Matrix m n α} {C : Matrix n m α}\n    {D : Matrix n n α} : (A.fromBlocks B C D).IsSymm ↔ A.IsSymm ∧ Bᵀ = C ∧ Cᵀ = B ∧ D.IsSymm :=\n  ⟨fun h =>\n    ⟨(congr_arg toBlocks₁₁ h :), (congr_arg toBlocks₂₁ h :), (congr_arg toBlocks₁₂ h :),\n      (congr_arg toBlocks₂₂ h :)⟩,\n    fun ⟨hA, hBC, _, hD⟩ => IsSymm.fromBlocks hA hBC hD⟩\n\n"}
