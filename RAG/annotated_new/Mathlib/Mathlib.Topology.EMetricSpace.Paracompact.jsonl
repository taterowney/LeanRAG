{"name":"EMetric.instParacompactSpace","module":"Mathlib.Topology.EMetricSpace.Paracompact","initialProofState":"Œ± : Type u_1\ninst‚úù : PseudoEMetricSpace Œ±\n‚ä¢ ParacompactSpace Œ±","decl":"/-- A `PseudoEMetricSpace` is always a paracompact space.\nFormalization is based on [MR0236876]. -/\ninstance (priority := 100) instParacompactSpace [PseudoEMetricSpace Œ±] : ParacompactSpace Œ± := by\n  /- We start with trivial observations about `1 / 2 ^ k`. Here and below we use `1 / 2 ^ k` in\n    the comments and `2‚Åª¬π ^ k` in the code. -/\n  have pow_pos : ‚àÄ k : ‚Ñï, (0 : ‚Ñù‚â•0‚àû) < 2‚Åª¬π ^ k := fun k =>\n    ENNReal.pow_pos (ENNReal.inv_pos.2 ENNReal.ofNat_ne_top) _\n  have hpow_le : ‚àÄ {m n : ‚Ñï}, m ‚â§ n ‚Üí (2‚Åª¬π : ‚Ñù‚â•0‚àû) ^ n ‚â§ 2‚Åª¬π ^ m := @fun m n h =>\n    pow_le_pow_right_of_le_one' (ENNReal.inv_le_one.2 ENNReal.one_lt_two.le) h\n  have h2pow : ‚àÄ n : ‚Ñï, 2 * (2‚Åª¬π : ‚Ñù‚â•0‚àû) ^ (n + 1) = 2‚Åª¬π ^ n := fun n => by\n    simp [pow_succ', ‚Üê mul_assoc, ENNReal.mul_inv_cancel two_ne_zero ofNat_ne_top]\n  -- Consider an open covering `S : Set (Set Œ±)`\n  refine ‚ü®fun Œπ s ho hcov => ?_‚ü©\n  simp only [iUnion_eq_univ_iff] at hcov\n  -- choose a well founded order on `S`\n  obtain ‚ü®_, wf‚ü© := exists_wellOrder Œπ\n  -- Let `ind x` be the minimal index `s : S` such that `x ‚àà s`.\n  let ind (x : Œ±) : Œπ := wellFounded_lt.min { i : Œπ | x ‚àà s i } (hcov x)\n  have mem_ind (x) : x ‚àà s (ind x) := wellFounded_lt.min_mem _ (hcov x)\n  have nmem_of_lt_ind {x i} (hlt : i < ind x) (hxi : x ‚àà s i) : False :=\n    wellFounded_lt.not_lt_min _ (hcov x) hxi hlt\n  /- The refinement `D : ‚Ñï ‚Üí Œπ ‚Üí Set Œ±` is defined recursively. For each `n` and `i`, `D n i`\n    is the union of balls `ball x (1 / 2 ^ n)` over all points `x` such that\n\n    * `ind x = i`;\n    * `x` does not belong to any `D m j`, `m < n`;\n    * `ball x (3 / 2 ^ n) ‚äÜ s i`;\n\n    We define this sequence using `Nat.strongRecOn'`, then restate it as `Dn` and `memD`.\n  -/\n  set D : ‚Ñï ‚Üí Œπ ‚Üí Set Œ± := fun n =>\n    Nat.strongRecOn' n fun n D' i =>\n      ‚ãÉ (x : Œ±) (hxs : ind x = i) (hb : ball x (3 * 2‚Åª¬π ^ n) ‚äÜ s i) (hlt :\n        ‚àÄ (m : ‚Ñï) (H : m < n), ‚àÄ (j : Œπ), x ‚àâ D' m H j), ball x (2‚Åª¬π ^ n) with hD\n  have Dn (n i) : D n i = ‚ãÉ (x : Œ±) (hxs : ind x = i) (hb : ball x (3 * 2‚Åª¬π ^ n) ‚äÜ s i)\n      (hlt : ‚àÄ m < n, ‚àÄ (j : Œπ), x ‚àâ D m j), ball x (2‚Åª¬π ^ n) := by\n    simp only [hD]\n    rw [Nat.strongRecOn'_beta]\n  have memD {n i y} :\n      y ‚àà D n i ‚Üî ‚àÉ x : Œ±, ind x = i ‚àß ball x (3 * 2‚Åª¬π ^ n) ‚äÜ s i ‚àß\n        (‚àÄ m < n, ‚àÄ (j : Œπ), x ‚àâ D m j) ‚àß edist y x < 2‚Åª¬π ^ n := by\n    rw [Dn n i]\n    simp only [mem_iUnion, mem_ball, exists_prop]\n  -- The sets `D n i` cover the whole space. Indeed, for each `x` we can choose `n` such that\n  -- `ball x (3 / 2 ^ n) ‚äÜ s (ind x)`, then either `x ‚àà D n i`, or `x ‚àà D m i` for some `m < n`.\n  have Dcov (x) : ‚àÉ n i, x ‚àà D n i := by\n    obtain ‚ü®n, hn‚ü© : ‚àÉ n : ‚Ñï, ball x (3 * 2‚Åª¬π ^ n) ‚äÜ s (ind x) := by\n      -- This proof takes 5 lines because we can't import `specific_limits` here\n      rcases isOpen_iff.1 (ho <| ind x) x (mem_ind x) with ‚ü®Œµ, Œµ0, hŒµ‚ü©\n      have : 0 < Œµ / 3 := ENNReal.div_pos_iff.2 ‚ü®Œµ0.lt.ne', ENNReal.coe_ne_top‚ü©\n      rcases ENNReal.exists_inv_two_pow_lt this.ne' with ‚ü®n, hn‚ü©\n      refine ‚ü®n, Subset.trans (ball_subset_ball ?_) hŒµ‚ü©\n      simpa only [div_eq_mul_inv, mul_comm] using (ENNReal.mul_lt_of_lt_div hn).le\n    by_contra! h\n    apply h n (ind x)\n    exact memD.2 ‚ü®x, rfl, hn, fun _ _ _ => h _ _, mem_ball_self (pow_pos _)‚ü©\n  -- Each `D n i` is a union of open balls, hence it is an open set\n  have Dopen (n i) : IsOpen (D n i) := by\n    rw [Dn]\n    iterate 4 refine isOpen_iUnion fun _ => ?_\n    exact isOpen_ball\n  -- the covering `D n i` is a refinement of the original covering: `D n i ‚äÜ s i`\n  have HDS (n i) : D n i ‚äÜ s i := fun x => by\n    rw [memD]\n    rintro ‚ü®y, rfl, hsub, -, hyx‚ü©\n    refine hsub (hyx.trans_le <| le_mul_of_one_le_left' ?_)\n    norm_num1\n  -- Let us show the rest of the properties. Since the definition expects a family indexed\n  -- by a single parameter, we use `‚Ñï √ó Œπ` as the domain.\n  refine ‚ü®‚Ñï √ó Œπ, fun ni => D ni.1 ni.2, fun _ => Dopen _ _, ?_, ?_, fun ni => ‚ü®ni.2, HDS _ _‚ü©‚ü©\n  -- The sets `D n i` cover the whole space as we proved earlier\n  ¬∑ refine iUnion_eq_univ_iff.2 fun x ‚Ü¶ ?_\n    rcases Dcov x with ‚ü®n, i, h‚ü©\n    exact ‚ü®‚ü®n, i‚ü©, h‚ü©\n  /- Let us prove that the covering `D n i` is locally finite. Take a point `x` and choose\n    `n`, `i` so that `x ‚àà D n i`. Since `D n i` is an open set, we can choose `k` so that\n    `B = ball x (1 / 2 ^ (n + k + 1)) ‚äÜ D n i`. -/\n  ¬∑ intro x\n    rcases Dcov x with ‚ü®n, i, hn‚ü©\n    have : D n i ‚àà ùìù x := IsOpen.mem_nhds (Dopen _ _) hn\n    rcases (nhds_basis_uniformity uniformity_basis_edist_inv_two_pow).mem_iff.1 this with\n      ‚ü®k, -, hsub : ball x (2‚Åª¬π ^ k) ‚äÜ D n i‚ü©\n    set B := ball x (2‚Åª¬π ^ (n + k + 1))\n    refine ‚ü®B, ball_mem_nhds _ (pow_pos _), ?_‚ü©\n    -- The sets `D m i`, `m > n + k`, are disjoint with `B`\n    have Hgt (m) (hm : n + k + 1 ‚â§ m) (i : Œπ) : Disjoint (D m i) B := by\n      rw [disjoint_iff_inf_le]\n      rintro y ‚ü®hym, hyx‚ü©\n      rcases memD.1 hym with ‚ü®z, rfl, _hzi, H, hz‚ü©\n      have : z ‚àâ ball x (2‚Åª¬π ^ k) := fun hz' => H n (by omega) i (hsub hz')\n      apply this\n      calc\n        edist z x ‚â§ edist y z + edist y x := edist_triangle_left _ _ _\n        _ < 2‚Åª¬π ^ m + 2‚Åª¬π ^ (n + k + 1) := ENNReal.add_lt_add hz hyx\n        _ ‚â§ 2‚Åª¬π ^ (k + 1) + 2‚Åª¬π ^ (k + 1) :=\n          (add_le_add (hpow_le <| by omega) (hpow_le <| by omega))\n        _ = 2‚Åª¬π ^ k := by rw [‚Üê two_mul, h2pow]\n    -- For each `m ‚â§ n + k` there is at most one `j` such that `D m j ‚à© B` is nonempty.\n    have Hle (m) (hm : m ‚â§ n + k) : Set.Subsingleton { j | (D m j ‚à© B).Nonempty } := by\n      rintro j‚ÇÅ ‚ü®y, hyD, hyB‚ü© j‚ÇÇ ‚ü®z, hzD, hzB‚ü©\n      by_contra! h' : j‚ÇÅ ‚â† j‚ÇÇ\n      wlog h : j‚ÇÅ < j‚ÇÇ generalizing j‚ÇÅ j‚ÇÇ y z\n      ¬∑ exact this z hzD hzB y hyD hyB h'.symm (h'.lt_or_lt.resolve_left h)\n      rcases memD.1 hyD with ‚ü®y', rfl, hsuby, -, hdisty‚ü©\n      rcases memD.1 hzD with ‚ü®z', rfl, -, -, hdistz‚ü©\n      suffices edist z' y' < 3 * 2‚Åª¬π ^ m from nmem_of_lt_ind h (hsuby this)\n      calc\n        edist z' y' ‚â§ edist z' x + edist x y' := edist_triangle _ _ _\n        _ ‚â§ edist z z' + edist z x + (edist y x + edist y y') :=\n          (add_le_add (edist_triangle_left _ _ _) (edist_triangle_left _ _ _))\n        _ < 2‚Åª¬π ^ m + 2‚Åª¬π ^ (n + k + 1) + (2‚Åª¬π ^ (n + k + 1) + 2‚Åª¬π ^ m) := by\n          apply_rules [ENNReal.add_lt_add]\n        _ = 2 * (2‚Åª¬π ^ m + 2‚Åª¬π ^ (n + k + 1)) := by simp only [two_mul, add_comm]\n        _ ‚â§ 2 * (2‚Åª¬π ^ m + 2‚Åª¬π ^ (m + 1)) := by\n          gcongr 2 * (_ + ?_); exact hpow_le (add_le_add hm le_rfl)\n        _ = 3 * 2‚Åª¬π ^ m := by\n          rw [mul_add, h2pow, ‚Üê two_add_one_eq_three, add_mul, one_mul]\n    -- Finally, we glue `Hgt` and `Hle`\n    have : (‚ãÉ (m ‚â§ n + k) (i ‚àà { i : Œπ | (D m i ‚à© B).Nonempty }), {(m, i)}).Finite :=\n      (finite_le_nat _).biUnion' fun i hi =>\n        (Hle i hi).finite.biUnion' fun _ _ => finite_singleton _\n    refine this.subset fun I hI => ?_\n    simp only [mem_iUnion]\n    refine ‚ü®I.1, ?_, I.2, hI, rfl‚ü©\n    exact not_lt.1 fun hlt => (Hgt I.1 hlt I.2).le_bot hI.choose_spec\n\n-- Porting note: no longer an instance because `inferInstance` can find it\n"}
{"name":"EMetric.t4Space","module":"Mathlib.Topology.EMetricSpace.Paracompact","initialProofState":"Œ± : Type u_1\ninst‚úù : EMetricSpace Œ±\n‚ä¢ T4Space Œ±","decl":"theorem t4Space [EMetricSpace Œ±] : T4Space Œ± := inferInstance\n\n"}
