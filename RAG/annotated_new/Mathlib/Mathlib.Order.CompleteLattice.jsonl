{"name":"iSup_ulift","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Type u_8\ninst✝ : SupSet α\nf : ULift.{u_9, u_8} ι → α\n⊢ Eq (iSup fun i => f i) (iSup fun i => f { down := i })","decl":"@[simp] lemma iSup_ulift {ι : Type*} [SupSet α] (f : ULift ι → α) :\n    ⨆ i : ULift ι, f i = ⨆ i, f (.up i) := by simp [iSup]; congr with x; simp\n\n"}
{"name":"iInf_ulift","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Type u_8\ninst✝ : InfSet α\nf : ULift.{u_9, u_8} ι → α\n⊢ Eq (iInf fun i => f i) (iInf fun i => f { down := i })","decl":"@[simp] lemma iInf_ulift {ι : Type*} [InfSet α] (f : ULift ι → α) :\n    ⨅ i : ULift ι, f i = ⨅ i, f (.up i) := by simp [iInf]; congr with x; simp\n\n"}
{"name":"CompleteSemilatticeSup.le_sSup","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_8\nself : CompleteSemilatticeSup α\ns : Set α\na : α\na✝ : Membership.mem s a\n⊢ LE.le a (SupSet.sSup s)","decl":"/-- Note that we rarely use `CompleteSemilatticeSup`\n(in fact, any such object is always a `CompleteLattice`, so it's usually best to start there).\n\nNevertheless it is sometimes a useful intermediate step in constructions.\n-/\nclass CompleteSemilatticeSup (α : Type*) extends PartialOrder α, SupSet α where\n  /-- Any element of a set is less than the set supremum. -/\n  le_sSup : ∀ s, ∀ a ∈ s, a ≤ sSup s\n  /-- Any upper bound is more than the set supremum. -/\n  sSup_le : ∀ s a, (∀ b ∈ s, b ≤ a) → sSup s ≤ a\n\n"}
{"name":"CompleteSemilatticeSup.sSup_le","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_8\nself : CompleteSemilatticeSup α\ns : Set α\na : α\na✝ : ∀ (b : α), Membership.mem s b → LE.le b a\n⊢ LE.le (SupSet.sSup s) a","decl":"/-- Note that we rarely use `CompleteSemilatticeSup`\n(in fact, any such object is always a `CompleteLattice`, so it's usually best to start there).\n\nNevertheless it is sometimes a useful intermediate step in constructions.\n-/\nclass CompleteSemilatticeSup (α : Type*) extends PartialOrder α, SupSet α where\n  /-- Any element of a set is less than the set supremum. -/\n  le_sSup : ∀ s, ∀ a ∈ s, a ≤ sSup s\n  /-- Any upper bound is more than the set supremum. -/\n  sSup_le : ∀ s a, (∀ b ∈ s, b ≤ a) → sSup s ≤ a\n\n"}
{"name":"le_sSup","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteSemilatticeSup α\ns : Set α\na : α\na✝ : Membership.mem s a\n⊢ LE.le a (SupSet.sSup s)","decl":"theorem le_sSup : a ∈ s → a ≤ sSup s :=\n  CompleteSemilatticeSup.le_sSup s a\n\n"}
{"name":"sSup_le","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteSemilatticeSup α\ns : Set α\na : α\na✝ : ∀ (b : α), Membership.mem s b → LE.le b a\n⊢ LE.le (SupSet.sSup s) a","decl":"theorem sSup_le : (∀ b ∈ s, b ≤ a) → sSup s ≤ a :=\n  CompleteSemilatticeSup.sSup_le s a\n\n"}
{"name":"isLUB_sSup","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteSemilatticeSup α\ns : Set α\n⊢ IsLUB s (SupSet.sSup s)","decl":"theorem isLUB_sSup (s : Set α) : IsLUB s (sSup s) :=\n  ⟨fun _ ↦ le_sSup, fun _ ↦ sSup_le⟩\n\n"}
{"name":"isLUB_iff_sSup_eq","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteSemilatticeSup α\ns : Set α\na : α\n⊢ Iff (IsLUB s a) (Eq (SupSet.sSup s) a)","decl":"lemma isLUB_iff_sSup_eq : IsLUB s a ↔ sSup s = a :=\n  ⟨(isLUB_sSup s).unique, by rintro rfl; exact isLUB_sSup _⟩\n\n"}
{"name":"IsLUB.sSup_eq","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteSemilatticeSup α\ns : Set α\na : α\na✝ : IsLUB s a\n⊢ Eq (SupSet.sSup s) a","decl":"alias ⟨IsLUB.sSup_eq, _⟩ := isLUB_iff_sSup_eq\n\n"}
{"name":"le_sSup_of_le","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteSemilatticeSup α\ns : Set α\na b : α\nhb : Membership.mem s b\nh : LE.le a b\n⊢ LE.le a (SupSet.sSup s)","decl":"theorem le_sSup_of_le (hb : b ∈ s) (h : a ≤ b) : a ≤ sSup s :=\n  le_trans h (le_sSup hb)\n\n"}
{"name":"sSup_le_sSup","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteSemilatticeSup α\ns t : Set α\nh : HasSubset.Subset s t\n⊢ LE.le (SupSet.sSup s) (SupSet.sSup t)","decl":"@[gcongr]\ntheorem sSup_le_sSup (h : s ⊆ t) : sSup s ≤ sSup t :=\n  (isLUB_sSup s).mono (isLUB_sSup t) h\n\n"}
{"name":"sSup_le_iff","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteSemilatticeSup α\ns : Set α\na : α\n⊢ Iff (LE.le (SupSet.sSup s) a) (∀ (b : α), Membership.mem s b → LE.le b a)","decl":"@[simp]\ntheorem sSup_le_iff : sSup s ≤ a ↔ ∀ b ∈ s, b ≤ a :=\n  isLUB_le_iff (isLUB_sSup s)\n\n"}
{"name":"le_sSup_iff","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteSemilatticeSup α\ns : Set α\na : α\n⊢ Iff (LE.le a (SupSet.sSup s)) (∀ (b : α), Membership.mem (upperBounds s) b → LE.le a b)","decl":"theorem le_sSup_iff : a ≤ sSup s ↔ ∀ b ∈ upperBounds s, a ≤ b :=\n  ⟨fun h _ hb => le_trans h (sSup_le hb), fun hb => hb _ fun _ => le_sSup⟩\n\n"}
{"name":"le_iSup_iff","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : CompleteSemilatticeSup α\na : α\ns : ι → α\n⊢ Iff (LE.le a (iSup s)) (∀ (b : α), (∀ (i : ι), LE.le (s i) b) → LE.le a b)","decl":"theorem le_iSup_iff {s : ι → α} : a ≤ iSup s ↔ ∀ b, (∀ i, s i ≤ b) → a ≤ b := by\n  simp [iSup, le_sSup_iff, upperBounds]\n\n"}
{"name":"sSup_le_sSup_of_forall_exists_le","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteSemilatticeSup α\ns t : Set α\nh : ∀ (x : α), Membership.mem s x → Exists fun y => And (Membership.mem t y) (LE.le x y)\n⊢ LE.le (SupSet.sSup s) (SupSet.sSup t)","decl":"theorem sSup_le_sSup_of_forall_exists_le (h : ∀ x ∈ s, ∃ y ∈ t, x ≤ y) : sSup s ≤ sSup t :=\n  le_sSup_iff.2 fun _ hb =>\n    sSup_le fun a ha =>\n      let ⟨_, hct, hac⟩ := h a ha\n      hac.trans (hb hct)\n\n-- We will generalize this to conditionally complete lattices in `csSup_singleton`.\n"}
{"name":"sSup_singleton","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteSemilatticeSup α\na : α\n⊢ Eq (SupSet.sSup (Singleton.singleton a)) a","decl":"@[simp]\ntheorem sSup_singleton {a : α} : sSup {a} = a :=\n  isLUB_singleton.sSup_eq\n\n"}
{"name":"CompleteSemilatticeInf.le_sInf","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_8\nself : CompleteSemilatticeInf α\ns : Set α\na : α\na✝ : ∀ (b : α), Membership.mem s b → LE.le a b\n⊢ LE.le a (InfSet.sInf s)","decl":"/-- Note that we rarely use `CompleteSemilatticeInf`\n(in fact, any such object is always a `CompleteLattice`, so it's usually best to start there).\n\nNevertheless it is sometimes a useful intermediate step in constructions.\n-/\nclass CompleteSemilatticeInf (α : Type*) extends PartialOrder α, InfSet α where\n  /-- Any element of a set is more than the set infimum. -/\n  sInf_le : ∀ s, ∀ a ∈ s, sInf s ≤ a\n  /-- Any lower bound is less than the set infimum. -/\n  le_sInf : ∀ s a, (∀ b ∈ s, a ≤ b) → a ≤ sInf s\n\n"}
{"name":"CompleteSemilatticeInf.sInf_le","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_8\nself : CompleteSemilatticeInf α\ns : Set α\na : α\na✝ : Membership.mem s a\n⊢ LE.le (InfSet.sInf s) a","decl":"/-- Note that we rarely use `CompleteSemilatticeInf`\n(in fact, any such object is always a `CompleteLattice`, so it's usually best to start there).\n\nNevertheless it is sometimes a useful intermediate step in constructions.\n-/\nclass CompleteSemilatticeInf (α : Type*) extends PartialOrder α, InfSet α where\n  /-- Any element of a set is more than the set infimum. -/\n  sInf_le : ∀ s, ∀ a ∈ s, sInf s ≤ a\n  /-- Any lower bound is less than the set infimum. -/\n  le_sInf : ∀ s a, (∀ b ∈ s, a ≤ b) → a ≤ sInf s\n\n"}
{"name":"sInf_le","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteSemilatticeInf α\ns : Set α\na : α\na✝ : Membership.mem s a\n⊢ LE.le (InfSet.sInf s) a","decl":"theorem sInf_le : a ∈ s → sInf s ≤ a :=\n  CompleteSemilatticeInf.sInf_le s a\n\n"}
{"name":"le_sInf","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteSemilatticeInf α\ns : Set α\na : α\na✝ : ∀ (b : α), Membership.mem s b → LE.le a b\n⊢ LE.le a (InfSet.sInf s)","decl":"theorem le_sInf : (∀ b ∈ s, a ≤ b) → a ≤ sInf s :=\n  CompleteSemilatticeInf.le_sInf s a\n\n"}
{"name":"isGLB_sInf","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteSemilatticeInf α\ns : Set α\n⊢ IsGLB s (InfSet.sInf s)","decl":"theorem isGLB_sInf (s : Set α) : IsGLB s (sInf s) :=\n  ⟨fun _ => sInf_le, fun _ => le_sInf⟩\n\n"}
{"name":"isGLB_iff_sInf_eq","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteSemilatticeInf α\ns : Set α\na : α\n⊢ Iff (IsGLB s a) (Eq (InfSet.sInf s) a)","decl":"lemma isGLB_iff_sInf_eq : IsGLB s a ↔ sInf s = a :=\n  ⟨(isGLB_sInf s).unique, by rintro rfl; exact isGLB_sInf _⟩\n\n"}
{"name":"IsGLB.sInf_eq","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteSemilatticeInf α\ns : Set α\na : α\na✝ : IsGLB s a\n⊢ Eq (InfSet.sInf s) a","decl":"alias ⟨IsGLB.sInf_eq, _⟩ := isGLB_iff_sInf_eq\n\n"}
{"name":"sInf_le_of_le","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteSemilatticeInf α\ns : Set α\na b : α\nhb : Membership.mem s b\nh : LE.le b a\n⊢ LE.le (InfSet.sInf s) a","decl":"theorem sInf_le_of_le (hb : b ∈ s) (h : b ≤ a) : sInf s ≤ a :=\n  le_trans (sInf_le hb) h\n\n"}
{"name":"sInf_le_sInf","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteSemilatticeInf α\ns t : Set α\nh : HasSubset.Subset s t\n⊢ LE.le (InfSet.sInf t) (InfSet.sInf s)","decl":"@[gcongr]\ntheorem sInf_le_sInf (h : s ⊆ t) : sInf t ≤ sInf s :=\n  (isGLB_sInf s).mono (isGLB_sInf t) h\n\n"}
{"name":"le_sInf_iff","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteSemilatticeInf α\ns : Set α\na : α\n⊢ Iff (LE.le a (InfSet.sInf s)) (∀ (b : α), Membership.mem s b → LE.le a b)","decl":"@[simp]\ntheorem le_sInf_iff : a ≤ sInf s ↔ ∀ b ∈ s, a ≤ b :=\n  le_isGLB_iff (isGLB_sInf s)\n\n"}
{"name":"sInf_le_iff","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteSemilatticeInf α\ns : Set α\na : α\n⊢ Iff (LE.le (InfSet.sInf s) a) (∀ (b : α), Membership.mem (lowerBounds s) b → LE.le b a)","decl":"theorem sInf_le_iff : sInf s ≤ a ↔ ∀ b ∈ lowerBounds s, b ≤ a :=\n  ⟨fun h _ hb => le_trans (le_sInf hb) h, fun hb => hb _ fun _ => sInf_le⟩\n\n"}
{"name":"iInf_le_iff","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : CompleteSemilatticeInf α\na : α\ns : ι → α\n⊢ Iff (LE.le (iInf s) a) (∀ (b : α), (∀ (i : ι), LE.le b (s i)) → LE.le b a)","decl":"theorem iInf_le_iff {s : ι → α} : iInf s ≤ a ↔ ∀ b, (∀ i, b ≤ s i) → b ≤ a := by\n  simp [iInf, sInf_le_iff, lowerBounds]\n\n"}
{"name":"sInf_le_sInf_of_forall_exists_le","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteSemilatticeInf α\ns t : Set α\nh : ∀ (x : α), Membership.mem s x → Exists fun y => And (Membership.mem t y) (LE.le y x)\n⊢ LE.le (InfSet.sInf t) (InfSet.sInf s)","decl":"theorem sInf_le_sInf_of_forall_exists_le (h : ∀ x ∈ s, ∃ y ∈ t, y ≤ x) : sInf t ≤ sInf s :=\n  le_sInf fun x hx ↦ let ⟨_y, hyt, hyx⟩ := h x hx; sInf_le_of_le hyt hyx\n\n-- We will generalize this to conditionally complete lattices in `csInf_singleton`.\n"}
{"name":"sInf_singleton","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteSemilatticeInf α\na : α\n⊢ Eq (InfSet.sInf (Singleton.singleton a)) a","decl":"@[simp]\ntheorem sInf_singleton {a : α} : sInf {a} = a :=\n  isGLB_singleton.sInf_eq\n\n"}
{"name":"CompleteLattice.sSup_le","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_8\nself : CompleteLattice α\ns : Set α\na : α\na✝ : ∀ (b : α), Membership.mem s b → LE.le b a\n⊢ LE.le (SupSet.sSup s) a","decl":"/-- A complete lattice is a bounded lattice which has suprema and infima for every subset. -/\nclass CompleteLattice (α : Type*) extends Lattice α, CompleteSemilatticeSup α,\n  CompleteSemilatticeInf α, Top α, Bot α where\n  /-- Any element is less than the top one. -/\n  protected le_top : ∀ x : α, x ≤ ⊤\n  /-- Any element is more than the bottom one. -/\n  protected bot_le : ∀ x : α, ⊥ ≤ x\n\n-- see Note [lower instance priority]\n"}
{"name":"CompleteLattice.sInf_le","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_8\nself : CompleteLattice α\ns : Set α\na : α\na✝ : Membership.mem s a\n⊢ LE.le (InfSet.sInf s) a","decl":"/-- A complete lattice is a bounded lattice which has suprema and infima for every subset. -/\nclass CompleteLattice (α : Type*) extends Lattice α, CompleteSemilatticeSup α,\n  CompleteSemilatticeInf α, Top α, Bot α where\n  /-- Any element is less than the top one. -/\n  protected le_top : ∀ x : α, x ≤ ⊤\n  /-- Any element is more than the bottom one. -/\n  protected bot_le : ∀ x : α, ⊥ ≤ x\n\n-- see Note [lower instance priority]\n"}
{"name":"CompleteLattice.bot_le","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_8\nself : CompleteLattice α\nx : α\n⊢ LE.le Bot.bot x","decl":"/-- A complete lattice is a bounded lattice which has suprema and infima for every subset. -/\nclass CompleteLattice (α : Type*) extends Lattice α, CompleteSemilatticeSup α,\n  CompleteSemilatticeInf α, Top α, Bot α where\n  /-- Any element is less than the top one. -/\n  protected le_top : ∀ x : α, x ≤ ⊤\n  /-- Any element is more than the bottom one. -/\n  protected bot_le : ∀ x : α, ⊥ ≤ x\n\n-- see Note [lower instance priority]\n"}
{"name":"CompleteLattice.le_sSup","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_8\nself : CompleteLattice α\ns : Set α\na : α\na✝ : Membership.mem s a\n⊢ LE.le a (SupSet.sSup s)","decl":"/-- A complete lattice is a bounded lattice which has suprema and infima for every subset. -/\nclass CompleteLattice (α : Type*) extends Lattice α, CompleteSemilatticeSup α,\n  CompleteSemilatticeInf α, Top α, Bot α where\n  /-- Any element is less than the top one. -/\n  protected le_top : ∀ x : α, x ≤ ⊤\n  /-- Any element is more than the bottom one. -/\n  protected bot_le : ∀ x : α, ⊥ ≤ x\n\n-- see Note [lower instance priority]\n"}
{"name":"CompleteLattice.le_top","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_8\nself : CompleteLattice α\nx : α\n⊢ LE.le x Top.top","decl":"/-- A complete lattice is a bounded lattice which has suprema and infima for every subset. -/\nclass CompleteLattice (α : Type*) extends Lattice α, CompleteSemilatticeSup α,\n  CompleteSemilatticeInf α, Top α, Bot α where\n  /-- Any element is less than the top one. -/\n  protected le_top : ∀ x : α, x ≤ ⊤\n  /-- Any element is more than the bottom one. -/\n  protected bot_le : ∀ x : α, ⊥ ≤ x\n\n-- see Note [lower instance priority]\n"}
{"name":"CompleteLattice.le_sInf","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_8\nself : CompleteLattice α\ns : Set α\na : α\na✝ : ∀ (b : α), Membership.mem s b → LE.le a b\n⊢ LE.le a (InfSet.sInf s)","decl":"/-- A complete lattice is a bounded lattice which has suprema and infima for every subset. -/\nclass CompleteLattice (α : Type*) extends Lattice α, CompleteSemilatticeSup α,\n  CompleteSemilatticeInf α, Top α, Bot α where\n  /-- Any element is less than the top one. -/\n  protected le_top : ∀ x : α, x ≤ ⊤\n  /-- Any element is more than the bottom one. -/\n  protected bot_le : ∀ x : α, ⊥ ≤ x\n\n-- see Note [lower instance priority]\n"}
{"name":"CompleteLinearOrder.sdiff_le_iff","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_8\nself : CompleteLinearOrder α\na b c : α\n⊢ Iff (LE.le (SDiff.sdiff a b) c) (LE.le a (Max.max b c))","decl":"/-- A complete linear order is a linear order whose lattice structure is complete. -/\nclass CompleteLinearOrder (α : Type*) extends CompleteLattice α, BiheytingAlgebra α where\n  /-- A linear order is total. -/\n  le_total (a b : α) : a ≤ b ∨ b ≤ a\n  /-- In a linearly ordered type, we assume the order relations are all decidable. -/\n  decidableLE : DecidableRel (· ≤ · : α → α → Prop)\n  /-- In a linearly ordered type, we assume the order relations are all decidable. -/\n  decidableEq : DecidableEq α := @decidableEqOfDecidableLE _ _ decidableLE\n  /-- In a linearly ordered type, we assume the order relations are all decidable. -/\n  decidableLT : DecidableRel (· < · : α → α → Prop) :=\n    @decidableLTOfDecidableLE _ _ decidableLE\n\n"}
{"name":"CompleteLinearOrder.top_sdiff","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_8\nself : CompleteLinearOrder α\na : α\n⊢ Eq (SDiff.sdiff Top.top a) (HNot.hnot a)","decl":"/-- A complete linear order is a linear order whose lattice structure is complete. -/\nclass CompleteLinearOrder (α : Type*) extends CompleteLattice α, BiheytingAlgebra α where\n  /-- A linear order is total. -/\n  le_total (a b : α) : a ≤ b ∨ b ≤ a\n  /-- In a linearly ordered type, we assume the order relations are all decidable. -/\n  decidableLE : DecidableRel (· ≤ · : α → α → Prop)\n  /-- In a linearly ordered type, we assume the order relations are all decidable. -/\n  decidableEq : DecidableEq α := @decidableEqOfDecidableLE _ _ decidableLE\n  /-- In a linearly ordered type, we assume the order relations are all decidable. -/\n  decidableLT : DecidableRel (· < · : α → α → Prop) :=\n    @decidableLTOfDecidableLE _ _ decidableLE\n\n"}
{"name":"CompleteLinearOrder.himp_bot","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_8\nself : CompleteLinearOrder α\na : α\n⊢ Eq (HImp.himp a Bot.bot) (HasCompl.compl a)","decl":"/-- A complete linear order is a linear order whose lattice structure is complete. -/\nclass CompleteLinearOrder (α : Type*) extends CompleteLattice α, BiheytingAlgebra α where\n  /-- A linear order is total. -/\n  le_total (a b : α) : a ≤ b ∨ b ≤ a\n  /-- In a linearly ordered type, we assume the order relations are all decidable. -/\n  decidableLE : DecidableRel (· ≤ · : α → α → Prop)\n  /-- In a linearly ordered type, we assume the order relations are all decidable. -/\n  decidableEq : DecidableEq α := @decidableEqOfDecidableLE _ _ decidableLE\n  /-- In a linearly ordered type, we assume the order relations are all decidable. -/\n  decidableLT : DecidableRel (· < · : α → α → Prop) :=\n    @decidableLTOfDecidableLE _ _ decidableLE\n\n"}
{"name":"CompleteLinearOrder.le_total","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_8\nself : CompleteLinearOrder α\na b : α\n⊢ Or (LE.le a b) (LE.le b a)","decl":"/-- A complete linear order is a linear order whose lattice structure is complete. -/\nclass CompleteLinearOrder (α : Type*) extends CompleteLattice α, BiheytingAlgebra α where\n  /-- A linear order is total. -/\n  le_total (a b : α) : a ≤ b ∨ b ≤ a\n  /-- In a linearly ordered type, we assume the order relations are all decidable. -/\n  decidableLE : DecidableRel (· ≤ · : α → α → Prop)\n  /-- In a linearly ordered type, we assume the order relations are all decidable. -/\n  decidableEq : DecidableEq α := @decidableEqOfDecidableLE _ _ decidableLE\n  /-- In a linearly ordered type, we assume the order relations are all decidable. -/\n  decidableLT : DecidableRel (· < · : α → α → Prop) :=\n    @decidableLTOfDecidableLE _ _ decidableLE\n\n"}
{"name":"CompleteLinearOrder.le_himp_iff","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_8\nself : CompleteLinearOrder α\na b c : α\n⊢ Iff (LE.le a (HImp.himp b c)) (LE.le (Min.min a b) c)","decl":"/-- A complete linear order is a linear order whose lattice structure is complete. -/\nclass CompleteLinearOrder (α : Type*) extends CompleteLattice α, BiheytingAlgebra α where\n  /-- A linear order is total. -/\n  le_total (a b : α) : a ≤ b ∨ b ≤ a\n  /-- In a linearly ordered type, we assume the order relations are all decidable. -/\n  decidableLE : DecidableRel (· ≤ · : α → α → Prop)\n  /-- In a linearly ordered type, we assume the order relations are all decidable. -/\n  decidableEq : DecidableEq α := @decidableEqOfDecidableLE _ _ decidableLE\n  /-- In a linearly ordered type, we assume the order relations are all decidable. -/\n  decidableLT : DecidableRel (· < · : α → α → Prop) :=\n    @decidableLTOfDecidableLE _ _ decidableLE\n\n"}
{"name":"toDual_sSup","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : SupSet α\ns : Set α\n⊢ Eq (OrderDual.toDual (SupSet.sSup s)) (InfSet.sInf (Set.preimage (⇑OrderDual.ofDual) s))","decl":"@[simp]\ntheorem toDual_sSup [SupSet α] (s : Set α) : toDual (sSup s) = sInf (ofDual ⁻¹' s) :=\n  rfl\n\n"}
{"name":"toDual_sInf","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : InfSet α\ns : Set α\n⊢ Eq (OrderDual.toDual (InfSet.sInf s)) (SupSet.sSup (Set.preimage (⇑OrderDual.ofDual) s))","decl":"@[simp]\ntheorem toDual_sInf [InfSet α] (s : Set α) : toDual (sInf s) = sSup (ofDual ⁻¹' s) :=\n  rfl\n\n"}
{"name":"ofDual_sSup","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : InfSet α\ns : Set (OrderDual α)\n⊢ Eq (OrderDual.ofDual (SupSet.sSup s)) (InfSet.sInf (Set.preimage (⇑OrderDual.toDual) s))","decl":"@[simp]\ntheorem ofDual_sSup [InfSet α] (s : Set αᵒᵈ) : ofDual (sSup s) = sInf (toDual ⁻¹' s) :=\n  rfl\n\n"}
{"name":"ofDual_sInf","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : SupSet α\ns : Set (OrderDual α)\n⊢ Eq (OrderDual.ofDual (InfSet.sInf s)) (SupSet.sSup (Set.preimage (⇑OrderDual.toDual) s))","decl":"@[simp]\ntheorem ofDual_sInf [SupSet α] (s : Set αᵒᵈ) : ofDual (sInf s) = sSup (toDual ⁻¹' s) :=\n  rfl\n\n"}
{"name":"toDual_iSup","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : SupSet α\nf : ι → α\n⊢ Eq (OrderDual.toDual (iSup fun i => f i)) (iInf fun i => OrderDual.toDual (f i))","decl":"@[simp]\ntheorem toDual_iSup [SupSet α] (f : ι → α) : toDual (⨆ i, f i) = ⨅ i, toDual (f i) :=\n  rfl\n\n"}
{"name":"toDual_iInf","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : InfSet α\nf : ι → α\n⊢ Eq (OrderDual.toDual (iInf fun i => f i)) (iSup fun i => OrderDual.toDual (f i))","decl":"@[simp]\ntheorem toDual_iInf [InfSet α] (f : ι → α) : toDual (⨅ i, f i) = ⨆ i, toDual (f i) :=\n  rfl\n\n"}
{"name":"ofDual_iSup","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : InfSet α\nf : ι → OrderDual α\n⊢ Eq (OrderDual.ofDual (iSup fun i => f i)) (iInf fun i => OrderDual.ofDual (f i))","decl":"@[simp]\ntheorem ofDual_iSup [InfSet α] (f : ι → αᵒᵈ) : ofDual (⨆ i, f i) = ⨅ i, ofDual (f i) :=\n  rfl\n\n"}
{"name":"ofDual_iInf","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : SupSet α\nf : ι → OrderDual α\n⊢ Eq (OrderDual.ofDual (iInf fun i => f i)) (iSup fun i => OrderDual.ofDual (f i))","decl":"@[simp]\ntheorem ofDual_iInf [SupSet α] (f : ι → αᵒᵈ) : ofDual (⨅ i, f i) = ⨆ i, ofDual (f i) :=\n  rfl\n\n"}
{"name":"sInf_le_sSup","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\ns : Set α\nhs : s.Nonempty\n⊢ LE.le (InfSet.sInf s) (SupSet.sSup s)","decl":"theorem sInf_le_sSup (hs : s.Nonempty) : sInf s ≤ sSup s :=\n  isGLB_le_isLUB (isGLB_sInf s) (isLUB_sSup s) hs\n\n"}
{"name":"sSup_union","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\ns t : Set α\n⊢ Eq (SupSet.sSup (Union.union s t)) (Max.max (SupSet.sSup s) (SupSet.sSup t))","decl":"theorem sSup_union {s t : Set α} : sSup (s ∪ t) = sSup s ⊔ sSup t :=\n  ((isLUB_sSup s).union (isLUB_sSup t)).sSup_eq\n\n"}
{"name":"sInf_union","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\ns t : Set α\n⊢ Eq (InfSet.sInf (Union.union s t)) (Min.min (InfSet.sInf s) (InfSet.sInf t))","decl":"theorem sInf_union {s t : Set α} : sInf (s ∪ t) = sInf s ⊓ sInf t :=\n  ((isGLB_sInf s).union (isGLB_sInf t)).sInf_eq\n\n"}
{"name":"sSup_inter_le","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\ns t : Set α\n⊢ LE.le (SupSet.sSup (Inter.inter s t)) (Min.min (SupSet.sSup s) (SupSet.sSup t))","decl":"theorem sSup_inter_le {s t : Set α} : sSup (s ∩ t) ≤ sSup s ⊓ sSup t :=\n  sSup_le fun _ hb => le_inf (le_sSup hb.1) (le_sSup hb.2)\n\n"}
{"name":"le_sInf_inter","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\ns t : Set α\n⊢ LE.le (Max.max (InfSet.sInf s) (InfSet.sInf t)) (InfSet.sInf (Inter.inter s t))","decl":"theorem le_sInf_inter {s t : Set α} : sInf s ⊔ sInf t ≤ sInf (s ∩ t) :=\n  @sSup_inter_le αᵒᵈ _ _ _\n\n"}
{"name":"sSup_empty","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\n⊢ Eq (SupSet.sSup EmptyCollection.emptyCollection) Bot.bot","decl":"@[simp]\ntheorem sSup_empty : sSup ∅ = (⊥ : α) :=\n  (@isLUB_empty α _ _).sSup_eq\n\n"}
{"name":"sInf_empty","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\n⊢ Eq (InfSet.sInf EmptyCollection.emptyCollection) Top.top","decl":"@[simp]\ntheorem sInf_empty : sInf ∅ = (⊤ : α) :=\n  (@isGLB_empty α _ _).sInf_eq\n\n"}
{"name":"sSup_univ","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\n⊢ Eq (SupSet.sSup Set.univ) Top.top","decl":"@[simp]\ntheorem sSup_univ : sSup univ = (⊤ : α) :=\n  (@isLUB_univ α _ _).sSup_eq\n\n"}
{"name":"sInf_univ","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\n⊢ Eq (InfSet.sInf Set.univ) Bot.bot","decl":"@[simp]\ntheorem sInf_univ : sInf univ = (⊥ : α) :=\n  (@isGLB_univ α _ _).sInf_eq\n\n-- TODO(Jeremy): get this automatically\n"}
{"name":"sSup_insert","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\na : α\ns : Set α\n⊢ Eq (SupSet.sSup (Insert.insert a s)) (Max.max a (SupSet.sSup s))","decl":"@[simp]\ntheorem sSup_insert {a : α} {s : Set α} : sSup (insert a s) = a ⊔ sSup s :=\n  ((isLUB_sSup s).insert a).sSup_eq\n\n"}
{"name":"sInf_insert","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\na : α\ns : Set α\n⊢ Eq (InfSet.sInf (Insert.insert a s)) (Min.min a (InfSet.sInf s))","decl":"@[simp]\ntheorem sInf_insert {a : α} {s : Set α} : sInf (insert a s) = a ⊓ sInf s :=\n  ((isGLB_sInf s).insert a).sInf_eq\n\n"}
{"name":"sSup_le_sSup_of_subset_insert_bot","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\ns t : Set α\nh : HasSubset.Subset s (Insert.insert Bot.bot t)\n⊢ LE.le (SupSet.sSup s) (SupSet.sSup t)","decl":"theorem sSup_le_sSup_of_subset_insert_bot (h : s ⊆ insert ⊥ t) : sSup s ≤ sSup t :=\n  (sSup_le_sSup h).trans_eq (sSup_insert.trans (bot_sup_eq _))\n\n"}
{"name":"sInf_le_sInf_of_subset_insert_top","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\ns t : Set α\nh : HasSubset.Subset s (Insert.insert Top.top t)\n⊢ LE.le (InfSet.sInf t) (InfSet.sInf s)","decl":"theorem sInf_le_sInf_of_subset_insert_top (h : s ⊆ insert ⊤ t) : sInf t ≤ sInf s :=\n  (sInf_le_sInf h).trans_eq' (sInf_insert.trans (top_inf_eq _)).symm\n\n"}
{"name":"sSup_diff_singleton_bot","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\ns : Set α\n⊢ Eq (SupSet.sSup (SDiff.sdiff s (Singleton.singleton Bot.bot))) (SupSet.sSup s)","decl":"@[simp]\ntheorem sSup_diff_singleton_bot (s : Set α) : sSup (s \\ {⊥}) = sSup s :=\n  (sSup_le_sSup diff_subset).antisymm <|\n    sSup_le_sSup_of_subset_insert_bot <| subset_insert_diff_singleton _ _\n\n"}
{"name":"sInf_diff_singleton_top","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\ns : Set α\n⊢ Eq (InfSet.sInf (SDiff.sdiff s (Singleton.singleton Top.top))) (InfSet.sInf s)","decl":"@[simp]\ntheorem sInf_diff_singleton_top (s : Set α) : sInf (s \\ {⊤}) = sInf s :=\n  @sSup_diff_singleton_bot αᵒᵈ _ s\n\n"}
{"name":"sSup_pair","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\na b : α\n⊢ Eq (SupSet.sSup (Insert.insert a (Singleton.singleton b))) (Max.max a b)","decl":"theorem sSup_pair {a b : α} : sSup {a, b} = a ⊔ b :=\n  (@isLUB_pair α _ a b).sSup_eq\n\n"}
{"name":"sInf_pair","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\na b : α\n⊢ Eq (InfSet.sInf (Insert.insert a (Singleton.singleton b))) (Min.min a b)","decl":"theorem sInf_pair {a b : α} : sInf {a, b} = a ⊓ b :=\n  (@isGLB_pair α _ a b).sInf_eq\n\n"}
{"name":"sSup_eq_bot","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\ns : Set α\n⊢ Iff (Eq (SupSet.sSup s) Bot.bot) (∀ (a : α), Membership.mem s a → Eq a Bot.bot)","decl":"@[simp]\ntheorem sSup_eq_bot : sSup s = ⊥ ↔ ∀ a ∈ s, a = ⊥ :=\n  ⟨fun h _ ha => bot_unique <| h ▸ le_sSup ha, fun h =>\n    bot_unique <| sSup_le fun a ha => le_bot_iff.2 <| h a ha⟩\n\n"}
{"name":"sInf_eq_top","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\ns : Set α\n⊢ Iff (Eq (InfSet.sInf s) Top.top) (∀ (a : α), Membership.mem s a → Eq a Top.top)","decl":"@[simp]\ntheorem sInf_eq_top : sInf s = ⊤ ↔ ∀ a ∈ s, a = ⊤ :=\n  @sSup_eq_bot αᵒᵈ _ _\n\n"}
{"name":"sSup_eq_bot'","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\ns : Set α\n⊢ Iff (Eq (SupSet.sSup s) Bot.bot) (Or (Eq s EmptyCollection.emptyCollection) (Eq s (Singleton.singleton Bot.bot)))","decl":"lemma sSup_eq_bot' {s : Set α} : sSup s = ⊥ ↔ s = ∅ ∨ s = {⊥} := by\n  rw [sSup_eq_bot, ← subset_singleton_iff_eq, subset_singleton_iff]\n\n"}
{"name":"eq_singleton_bot_of_sSup_eq_bot_of_nonempty","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\ns : Set α\nh_sup : Eq (SupSet.sSup s) Bot.bot\nhne : s.Nonempty\n⊢ Eq s (Singleton.singleton Bot.bot)","decl":"theorem eq_singleton_bot_of_sSup_eq_bot_of_nonempty {s : Set α} (h_sup : sSup s = ⊥)\n    (hne : s.Nonempty) : s = {⊥} := by\n  rw [Set.eq_singleton_iff_nonempty_unique_mem]\n  rw [sSup_eq_bot] at h_sup\n  exact ⟨hne, h_sup⟩\n\n"}
{"name":"eq_singleton_top_of_sInf_eq_top_of_nonempty","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\ns : Set α\na✝¹ : Eq (InfSet.sInf s) Top.top\na✝ : s.Nonempty\n⊢ Eq s (Singleton.singleton Top.top)","decl":"theorem eq_singleton_top_of_sInf_eq_top_of_nonempty : sInf s = ⊤ → s.Nonempty → s = {⊤} :=\n  @eq_singleton_bot_of_sSup_eq_bot_of_nonempty αᵒᵈ _ _\n\n"}
{"name":"sSup_eq_of_forall_le_of_forall_lt_exists_gt","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\ns : Set α\nb : α\nh₁ : ∀ (a : α), Membership.mem s a → LE.le a b\nh₂ : ∀ (w : α), LT.lt w b → Exists fun a => And (Membership.mem s a) (LT.lt w a)\n⊢ Eq (SupSet.sSup s) b","decl":"/-- Introduction rule to prove that `b` is the supremum of `s`: it suffices to check that `b`\nis larger than all elements of `s`, and that this is not the case of any `w < b`.\nSee `csSup_eq_of_forall_le_of_forall_lt_exists_gt` for a version in conditionally complete\nlattices. -/\ntheorem sSup_eq_of_forall_le_of_forall_lt_exists_gt (h₁ : ∀ a ∈ s, a ≤ b)\n    (h₂ : ∀ w, w < b → ∃ a ∈ s, w < a) : sSup s = b :=\n  (sSup_le h₁).eq_of_not_lt fun h =>\n    let ⟨_, ha, ha'⟩ := h₂ _ h\n    ((le_sSup ha).trans_lt ha').false\n\n"}
{"name":"sInf_eq_of_forall_ge_of_forall_gt_exists_lt","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\ns : Set α\nb : α\na✝¹ : ∀ (a : α), Membership.mem s a → LE.le b a\na✝ : ∀ (w : α), LT.lt b w → Exists fun a => And (Membership.mem s a) (LT.lt a w)\n⊢ Eq (InfSet.sInf s) b","decl":"/-- Introduction rule to prove that `b` is the infimum of `s`: it suffices to check that `b`\nis smaller than all elements of `s`, and that this is not the case of any `w > b`.\nSee `csInf_eq_of_forall_ge_of_forall_gt_exists_lt` for a version in conditionally complete\nlattices. -/\ntheorem sInf_eq_of_forall_ge_of_forall_gt_exists_lt :\n    (∀ a ∈ s, b ≤ a) → (∀ w, b < w → ∃ a ∈ s, a < w) → sInf s = b :=\n  @sSup_eq_of_forall_le_of_forall_lt_exists_gt αᵒᵈ _ _ _\n\n"}
{"name":"lt_sSup_iff","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLinearOrder α\ns : Set α\nb : α\n⊢ Iff (LT.lt b (SupSet.sSup s)) (Exists fun a => And (Membership.mem s a) (LT.lt b a))","decl":"theorem lt_sSup_iff : b < sSup s ↔ ∃ a ∈ s, b < a :=\n  lt_isLUB_iff <| isLUB_sSup s\n\n"}
{"name":"sInf_lt_iff","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLinearOrder α\ns : Set α\nb : α\n⊢ Iff (LT.lt (InfSet.sInf s) b) (Exists fun a => And (Membership.mem s a) (LT.lt a b))","decl":"theorem sInf_lt_iff : sInf s < b ↔ ∃ a ∈ s, a < b :=\n  isGLB_lt_iff <| isGLB_sInf s\n\n"}
{"name":"sSup_eq_top","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLinearOrder α\ns : Set α\n⊢ Iff (Eq (SupSet.sSup s) Top.top) (∀ (b : α), LT.lt b Top.top → Exists fun a => And (Membership.mem s a) (LT.lt b a))","decl":"theorem sSup_eq_top : sSup s = ⊤ ↔ ∀ b < ⊤, ∃ a ∈ s, b < a :=\n  ⟨fun h _ hb => lt_sSup_iff.1 <| hb.trans_eq h.symm, fun h =>\n    top_unique <|\n      le_of_not_gt fun h' =>\n        let ⟨_, ha, h⟩ := h _ h'\n        (h.trans_le <| le_sSup ha).false⟩\n\n"}
{"name":"sInf_eq_bot","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLinearOrder α\ns : Set α\n⊢ Iff (Eq (InfSet.sInf s) Bot.bot) (∀ (b : α), GT.gt b Bot.bot → Exists fun a => And (Membership.mem s a) (LT.lt a b))","decl":"theorem sInf_eq_bot : sInf s = ⊥ ↔ ∀ b > ⊥, ∃ a ∈ s, a < b :=\n  @sSup_eq_top αᵒᵈ _ _\n\n"}
{"name":"lt_iSup_iff","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : CompleteLinearOrder α\na : α\nf : ι → α\n⊢ Iff (LT.lt a (iSup f)) (Exists fun i => LT.lt a (f i))","decl":"theorem lt_iSup_iff {f : ι → α} : a < iSup f ↔ ∃ i, a < f i :=\n  lt_sSup_iff.trans exists_range_iff\n\n"}
{"name":"iInf_lt_iff","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : CompleteLinearOrder α\na : α\nf : ι → α\n⊢ Iff (LT.lt (iInf f) a) (Exists fun i => LT.lt (f i) a)","decl":"theorem iInf_lt_iff {f : ι → α} : iInf f < a ↔ ∃ i, f i < a :=\n  sInf_lt_iff.trans exists_range_iff\n\n"}
{"name":"sSup_range","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : SupSet α\nf : ι → α\n⊢ Eq (SupSet.sSup (Set.range f)) (iSup f)","decl":"theorem sSup_range : sSup (range f) = iSup f :=\n  rfl\n\n"}
{"name":"sSup_eq_iSup'","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : SupSet α\ns : Set α\n⊢ Eq (SupSet.sSup s) (iSup fun a => ↑a)","decl":"theorem sSup_eq_iSup' (s : Set α) : sSup s = ⨆ a : s, (a : α) := by rw [iSup, Subtype.range_coe]\n\n"}
{"name":"iSup_congr","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : SupSet α\nf g : ι → α\nh : ∀ (i : ι), Eq (f i) (g i)\n⊢ Eq (iSup fun i => f i) (iSup fun i => g i)","decl":"theorem iSup_congr (h : ∀ i, f i = g i) : ⨆ i, f i = ⨆ i, g i :=\n  congr_arg _ <| funext h\n\n"}
{"name":"biSup_congr","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : SupSet α\nf g : ι → α\np : ι → Prop\nh : ∀ (i : ι), p i → Eq (f i) (g i)\n⊢ Eq (iSup fun i => iSup fun x => f i) (iSup fun i => iSup fun x => g i)","decl":"theorem biSup_congr {p : ι → Prop} (h : ∀ i, p i → f i = g i) :\n    ⨆ (i) (_ : p i), f i = ⨆ (i) (_ : p i), g i :=\n  iSup_congr fun i ↦ iSup_congr (h i)\n\n"}
{"name":"biSup_congr'","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : SupSet α\np : ι → Prop\nf g : (i : ι) → p i → α\nh : ∀ (i : ι) (hi : p i), Eq (f i hi) (g i hi)\n⊢ Eq (iSup fun i => iSup fun hi => f i hi) (iSup fun i => iSup fun hi => g i hi)","decl":"theorem biSup_congr' {p : ι → Prop} {f g : (i : ι) → p i → α}\n    (h : ∀ i (hi : p i), f i hi = g i hi) :\n    ⨆ i, ⨆ (hi : p i), f i hi = ⨆ i, ⨆ (hi : p i), g i hi := by\n  congr; ext i; congr; ext hi; exact h i hi\n\n"}
{"name":"Function.Surjective.iSup_comp","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\nι' : Sort u_5\ninst✝ : SupSet α\nf : ι → ι'\nhf : Function.Surjective f\ng : ι' → α\n⊢ Eq (iSup fun x => g (f x)) (iSup fun y => g y)","decl":"theorem Function.Surjective.iSup_comp {f : ι → ι'} (hf : Surjective f) (g : ι' → α) :\n    ⨆ x, g (f x) = ⨆ y, g y := by\n  simp only [iSup.eq_1]\n  congr\n  exact hf.range_comp g\n\n"}
{"name":"Equiv.iSup_comp","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\nι' : Sort u_5\ninst✝ : SupSet α\ng : ι' → α\ne : Equiv ι ι'\n⊢ Eq (iSup fun x => g (e x)) (iSup fun y => g y)","decl":"theorem Equiv.iSup_comp {g : ι' → α} (e : ι ≃ ι') : ⨆ x, g (e x) = ⨆ y, g y :=\n  e.surjective.iSup_comp _\n\n"}
{"name":"Function.Surjective.iSup_congr","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\nι' : Sort u_5\ninst✝ : SupSet α\nf : ι → α\ng : ι' → α\nh : ι → ι'\nh1 : Function.Surjective h\nh2 : ∀ (x : ι), Eq (g (h x)) (f x)\n⊢ Eq (iSup fun x => f x) (iSup fun y => g y)","decl":"protected theorem Function.Surjective.iSup_congr {g : ι' → α} (h : ι → ι') (h1 : Surjective h)\n    (h2 : ∀ x, g (h x) = f x) : ⨆ x, f x = ⨆ y, g y := by\n  convert h1.iSup_comp g\n  exact (h2 _).symm\n\n"}
{"name":"Equiv.iSup_congr","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\nι' : Sort u_5\ninst✝ : SupSet α\nf : ι → α\ng : ι' → α\ne : Equiv ι ι'\nh : ∀ (x : ι), Eq (g (e x)) (f x)\n⊢ Eq (iSup fun x => f x) (iSup fun y => g y)","decl":"protected theorem Equiv.iSup_congr {g : ι' → α} (e : ι ≃ ι') (h : ∀ x, g (e x) = f x) :\n    ⨆ x, f x = ⨆ y, g y :=\n  e.surjective.iSup_congr _ h\n\n"}
{"name":"iSup_congr_Prop","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : SupSet α\np q : Prop\nf₁ : p → α\nf₂ : q → α\npq : Iff p q\nf : ∀ (x : q), Eq (f₁ ⋯) (f₂ x)\n⊢ Eq (iSup f₁) (iSup f₂)","decl":"@[congr]\ntheorem iSup_congr_Prop {p q : Prop} {f₁ : p → α} {f₂ : q → α} (pq : p ↔ q)\n    (f : ∀ x, f₁ (pq.mpr x) = f₂ x) : iSup f₁ = iSup f₂ := by\n  obtain rfl := propext pq\n  congr with x\n  apply f\n\n"}
{"name":"iSup_plift_up","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : SupSet α\nf : PLift ι → α\n⊢ Eq (iSup fun i => f { down := i }) (iSup fun i => f i)","decl":"theorem iSup_plift_up (f : PLift ι → α) : ⨆ i, f (PLift.up i) = ⨆ i, f i :=\n  (PLift.up_surjective.iSup_congr _) fun _ => rfl\n\n"}
{"name":"iSup_plift_down","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : SupSet α\nf : ι → α\n⊢ Eq (iSup fun i => f i.down) (iSup fun i => f i)","decl":"theorem iSup_plift_down (f : ι → α) : ⨆ i, f (PLift.down i) = ⨆ i, f i :=\n  (PLift.down_surjective.iSup_congr _) fun _ => rfl\n\n"}
{"name":"iSup_range'","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_4\ninst✝ : SupSet α\ng : β → α\nf : ι → β\n⊢ Eq (iSup fun b => g ↑b) (iSup fun i => g (f i))","decl":"theorem iSup_range' (g : β → α) (f : ι → β) : ⨆ b : range f, g b = ⨆ i, g (f i) := by\n  rw [iSup, iSup, ← image_eq_range, ← range_comp]\n  rfl\n\n"}
{"name":"sSup_image'","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : SupSet α\ns : Set β\nf : β → α\n⊢ Eq (SupSet.sSup (Set.image f s)) (iSup fun a => f ↑a)","decl":"theorem sSup_image' {s : Set β} {f : β → α} : sSup (f '' s) = ⨆ a : s, f a := by\n  rw [iSup, image_eq_range]\n\n"}
{"name":"sInf_range","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : InfSet α\nf : ι → α\n⊢ Eq (InfSet.sInf (Set.range f)) (iInf f)","decl":"theorem sInf_range : sInf (range f) = iInf f :=\n  rfl\n\n"}
{"name":"sInf_eq_iInf'","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : InfSet α\ns : Set α\n⊢ Eq (InfSet.sInf s) (iInf fun a => ↑a)","decl":"theorem sInf_eq_iInf' (s : Set α) : sInf s = ⨅ a : s, (a : α) :=\n  @sSup_eq_iSup' αᵒᵈ _ _\n\n"}
{"name":"iInf_congr","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : InfSet α\nf g : ι → α\nh : ∀ (i : ι), Eq (f i) (g i)\n⊢ Eq (iInf fun i => f i) (iInf fun i => g i)","decl":"theorem iInf_congr (h : ∀ i, f i = g i) : ⨅ i, f i = ⨅ i, g i :=\n  congr_arg _ <| funext h\n\n"}
{"name":"biInf_congr","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : InfSet α\nf g : ι → α\np : ι → Prop\nh : ∀ (i : ι), p i → Eq (f i) (g i)\n⊢ Eq (iInf fun i => iInf fun x => f i) (iInf fun i => iInf fun x => g i)","decl":"theorem biInf_congr {p : ι → Prop} (h : ∀ i, p i → f i = g i) :\n    ⨅ (i) (_ : p i), f i = ⨅ (i) (_ : p i), g i :=\n  biSup_congr (α := αᵒᵈ) h\n\n"}
{"name":"biInf_congr'","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : InfSet α\np : ι → Prop\nf g : (i : ι) → p i → α\nh : ∀ (i : ι) (hi : p i), Eq (f i hi) (g i hi)\n⊢ Eq (iInf fun i => iInf fun hi => f i hi) (iInf fun i => iInf fun hi => g i hi)","decl":"theorem biInf_congr' {p : ι → Prop} {f g : (i : ι) → p i → α}\n    (h : ∀ i (hi : p i), f i hi = g i hi) :\n    ⨅ i, ⨅ (hi : p i), f i hi = ⨅ i, ⨅ (hi : p i), g i hi := by\n  congr; ext i; congr; ext hi; exact h i hi\n\n"}
{"name":"Function.Surjective.iInf_comp","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\nι' : Sort u_5\ninst✝ : InfSet α\nf : ι → ι'\nhf : Function.Surjective f\ng : ι' → α\n⊢ Eq (iInf fun x => g (f x)) (iInf fun y => g y)","decl":"theorem Function.Surjective.iInf_comp {f : ι → ι'} (hf : Surjective f) (g : ι' → α) :\n    ⨅ x, g (f x) = ⨅ y, g y :=\n  @Function.Surjective.iSup_comp αᵒᵈ _ _ _ f hf g\n\n"}
{"name":"Equiv.iInf_comp","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\nι' : Sort u_5\ninst✝ : InfSet α\ng : ι' → α\ne : Equiv ι ι'\n⊢ Eq (iInf fun x => g (e x)) (iInf fun y => g y)","decl":"theorem Equiv.iInf_comp {g : ι' → α} (e : ι ≃ ι') : ⨅ x, g (e x) = ⨅ y, g y :=\n  @Equiv.iSup_comp αᵒᵈ _ _ _ _ e\n\n"}
{"name":"Function.Surjective.iInf_congr","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\nι' : Sort u_5\ninst✝ : InfSet α\nf : ι → α\ng : ι' → α\nh : ι → ι'\nh1 : Function.Surjective h\nh2 : ∀ (x : ι), Eq (g (h x)) (f x)\n⊢ Eq (iInf fun x => f x) (iInf fun y => g y)","decl":"protected theorem Function.Surjective.iInf_congr {g : ι' → α} (h : ι → ι') (h1 : Surjective h)\n    (h2 : ∀ x, g (h x) = f x) : ⨅ x, f x = ⨅ y, g y :=\n  @Function.Surjective.iSup_congr αᵒᵈ _ _ _ _ _ h h1 h2\n\n"}
{"name":"Equiv.iInf_congr","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\nι' : Sort u_5\ninst✝ : InfSet α\nf : ι → α\ng : ι' → α\ne : Equiv ι ι'\nh : ∀ (x : ι), Eq (g (e x)) (f x)\n⊢ Eq (iInf fun x => f x) (iInf fun y => g y)","decl":"protected theorem Equiv.iInf_congr {g : ι' → α} (e : ι ≃ ι') (h : ∀ x, g (e x) = f x) :\n    ⨅ x, f x = ⨅ y, g y :=\n  @Equiv.iSup_congr αᵒᵈ _ _ _ _ _ e h\n\n"}
{"name":"iInf_congr_Prop","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : InfSet α\np q : Prop\nf₁ : p → α\nf₂ : q → α\npq : Iff p q\nf : ∀ (x : q), Eq (f₁ ⋯) (f₂ x)\n⊢ Eq (iInf f₁) (iInf f₂)","decl":"@[congr]\ntheorem iInf_congr_Prop {p q : Prop} {f₁ : p → α} {f₂ : q → α} (pq : p ↔ q)\n    (f : ∀ x, f₁ (pq.mpr x) = f₂ x) : iInf f₁ = iInf f₂ :=\n  @iSup_congr_Prop αᵒᵈ _ p q f₁ f₂ pq f\n\n"}
{"name":"iInf_plift_up","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : InfSet α\nf : PLift ι → α\n⊢ Eq (iInf fun i => f { down := i }) (iInf fun i => f i)","decl":"theorem iInf_plift_up (f : PLift ι → α) : ⨅ i, f (PLift.up i) = ⨅ i, f i :=\n  (PLift.up_surjective.iInf_congr _) fun _ => rfl\n\n"}
{"name":"iInf_plift_down","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : InfSet α\nf : ι → α\n⊢ Eq (iInf fun i => f i.down) (iInf fun i => f i)","decl":"theorem iInf_plift_down (f : ι → α) : ⨅ i, f (PLift.down i) = ⨅ i, f i :=\n  (PLift.down_surjective.iInf_congr _) fun _ => rfl\n\n"}
{"name":"iInf_range'","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_4\ninst✝ : InfSet α\ng : β → α\nf : ι → β\n⊢ Eq (iInf fun b => g ↑b) (iInf fun i => g (f i))","decl":"theorem iInf_range' (g : β → α) (f : ι → β) : ⨅ b : range f, g b = ⨅ i, g (f i) :=\n  @iSup_range' αᵒᵈ _ _ _ _ _\n\n"}
{"name":"sInf_image'","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : InfSet α\ns : Set β\nf : β → α\n⊢ Eq (InfSet.sInf (Set.image f s)) (iInf fun a => f ↑a)","decl":"theorem sInf_image' {s : Set β} {f : β → α} : sInf (f '' s) = ⨅ a : s, f a :=\n  @sSup_image' αᵒᵈ _ _ _ _\n\n"}
{"name":"le_iSup","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : CompleteLattice α\nf : ι → α\ni : ι\n⊢ LE.le (f i) (iSup f)","decl":"theorem le_iSup (f : ι → α) (i : ι) : f i ≤ iSup f :=\n  le_sSup ⟨i, rfl⟩\n\n"}
{"name":"iInf_le","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : CompleteLattice α\nf : ι → α\ni : ι\n⊢ LE.le (iInf f) (f i)","decl":"theorem iInf_le (f : ι → α) (i : ι) : iInf f ≤ f i :=\n  sInf_le ⟨i, rfl⟩\n\n"}
{"name":"iInf_le_iSup","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝¹ : CompleteLattice α\nf : ι → α\ninst✝ : Nonempty ι\n⊢ LE.le (iInf fun i => f i) (iSup fun i => f i)","decl":"lemma iInf_le_iSup [Nonempty ι] : ⨅ i, f i ≤ ⨆ i, f i :=\n  (iInf_le _ (Classical.arbitrary _)).trans <| le_iSup _ (Classical.arbitrary _)\n\n"}
{"name":"le_iSup'","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : CompleteLattice α\nf : ι → α\ni : ι\n⊢ LE.le (f i) (iSup f)","decl":"@[deprecated le_iSup (since := \"2024-12-13\")]\ntheorem le_iSup' (f : ι → α) (i : ι) : f i ≤ iSup f := le_iSup f i\n\n"}
{"name":"iInf_le'","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : CompleteLattice α\nf : ι → α\ni : ι\n⊢ LE.le (iInf f) (f i)","decl":"@[deprecated iInf_le (since := \"2024-12-13\")]\ntheorem iInf_le' (f : ι → α) (i : ι) : iInf f ≤ f i := iInf_le f i\n\n"}
{"name":"isLUB_iSup","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : CompleteLattice α\nf : ι → α\n⊢ IsLUB (Set.range f) (iSup fun j => f j)","decl":"theorem isLUB_iSup : IsLUB (range f) (⨆ j, f j) :=\n  isLUB_sSup _\n\n"}
{"name":"isGLB_iInf","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : CompleteLattice α\nf : ι → α\n⊢ IsGLB (Set.range f) (iInf fun j => f j)","decl":"theorem isGLB_iInf : IsGLB (range f) (⨅ j, f j) :=\n  isGLB_sInf _\n\n"}
{"name":"IsLUB.iSup_eq","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : CompleteLattice α\nf : ι → α\na : α\nh : IsLUB (Set.range f) a\n⊢ Eq (iSup fun j => f j) a","decl":"theorem IsLUB.iSup_eq (h : IsLUB (range f) a) : ⨆ j, f j = a :=\n  h.sSup_eq\n\n"}
{"name":"IsGLB.iInf_eq","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : CompleteLattice α\nf : ι → α\na : α\nh : IsGLB (Set.range f) a\n⊢ Eq (iInf fun j => f j) a","decl":"theorem IsGLB.iInf_eq (h : IsGLB (range f) a) : ⨅ j, f j = a :=\n  h.sInf_eq\n\n"}
{"name":"le_iSup_of_le","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : CompleteLattice α\nf : ι → α\na : α\ni : ι\nh : LE.le a (f i)\n⊢ LE.le a (iSup f)","decl":"theorem le_iSup_of_le (i : ι) (h : a ≤ f i) : a ≤ iSup f :=\n  h.trans <| le_iSup _ i\n\n"}
{"name":"iInf_le_of_le","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : CompleteLattice α\nf : ι → α\na : α\ni : ι\nh : LE.le (f i) a\n⊢ LE.le (iInf f) a","decl":"theorem iInf_le_of_le (i : ι) (h : f i ≤ a) : iInf f ≤ a :=\n  (iInf_le _ i).trans h\n\n"}
{"name":"le_iSup₂","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\nκ : ι → Sort u_6\ninst✝ : CompleteLattice α\nf : (i : ι) → κ i → α\ni : ι\nj : κ i\n⊢ LE.le (f i j) (iSup fun i => iSup fun j => f i j)","decl":"theorem le_iSup₂ {f : ∀ i, κ i → α} (i : ι) (j : κ i) : f i j ≤ ⨆ (i) (j), f i j :=\n  le_iSup_of_le i <| le_iSup (f i) j\n\n"}
{"name":"iInf₂_le","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\nκ : ι → Sort u_6\ninst✝ : CompleteLattice α\nf : (i : ι) → κ i → α\ni : ι\nj : κ i\n⊢ LE.le (iInf fun i => iInf fun j => f i j) (f i j)","decl":"theorem iInf₂_le {f : ∀ i, κ i → α} (i : ι) (j : κ i) : ⨅ (i) (j), f i j ≤ f i j :=\n  iInf_le_of_le i <| iInf_le (f i) j\n\n"}
{"name":"le_iSup₂_of_le","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\nκ : ι → Sort u_6\ninst✝ : CompleteLattice α\na : α\nf : (i : ι) → κ i → α\ni : ι\nj : κ i\nh : LE.le a (f i j)\n⊢ LE.le a (iSup fun i => iSup fun j => f i j)","decl":"theorem le_iSup₂_of_le {f : ∀ i, κ i → α} (i : ι) (j : κ i) (h : a ≤ f i j) :\n    a ≤ ⨆ (i) (j), f i j :=\n  h.trans <| le_iSup₂ i j\n\n"}
{"name":"iInf₂_le_of_le","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\nκ : ι → Sort u_6\ninst✝ : CompleteLattice α\na : α\nf : (i : ι) → κ i → α\ni : ι\nj : κ i\nh : LE.le (f i j) a\n⊢ LE.le (iInf fun i => iInf fun j => f i j) a","decl":"theorem iInf₂_le_of_le {f : ∀ i, κ i → α} (i : ι) (j : κ i) (h : f i j ≤ a) :\n    ⨅ (i) (j), f i j ≤ a :=\n  (iInf₂_le i j).trans h\n\n"}
{"name":"iSup_le","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : CompleteLattice α\nf : ι → α\na : α\nh : ∀ (i : ι), LE.le (f i) a\n⊢ LE.le (iSup f) a","decl":"theorem iSup_le (h : ∀ i, f i ≤ a) : iSup f ≤ a :=\n  sSup_le fun _ ⟨i, Eq⟩ => Eq ▸ h i\n\n"}
{"name":"le_iInf","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : CompleteLattice α\nf : ι → α\na : α\nh : ∀ (i : ι), LE.le a (f i)\n⊢ LE.le a (iInf f)","decl":"theorem le_iInf (h : ∀ i, a ≤ f i) : a ≤ iInf f :=\n  le_sInf fun _ ⟨i, Eq⟩ => Eq ▸ h i\n\n"}
{"name":"iSup₂_le","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\nκ : ι → Sort u_6\ninst✝ : CompleteLattice α\na : α\nf : (i : ι) → κ i → α\nh : ∀ (i : ι) (j : κ i), LE.le (f i j) a\n⊢ LE.le (iSup fun i => iSup fun j => f i j) a","decl":"theorem iSup₂_le {f : ∀ i, κ i → α} (h : ∀ i j, f i j ≤ a) : ⨆ (i) (j), f i j ≤ a :=\n  iSup_le fun i => iSup_le <| h i\n\n"}
{"name":"le_iInf₂","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\nκ : ι → Sort u_6\ninst✝ : CompleteLattice α\na : α\nf : (i : ι) → κ i → α\nh : ∀ (i : ι) (j : κ i), LE.le a (f i j)\n⊢ LE.le a (iInf fun i => iInf fun j => f i j)","decl":"theorem le_iInf₂ {f : ∀ i, κ i → α} (h : ∀ i j, a ≤ f i j) : a ≤ ⨅ (i) (j), f i j :=\n  le_iInf fun i => le_iInf <| h i\n\n"}
{"name":"iSup₂_le_iSup","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : CompleteLattice α\nκ : ι → Sort u_8\nf : ι → α\n⊢ LE.le (iSup fun i => iSup fun x => f i) (iSup fun i => f i)","decl":"theorem iSup₂_le_iSup (κ : ι → Sort*) (f : ι → α) : ⨆ (i) (_ : κ i), f i ≤ ⨆ i, f i :=\n  iSup₂_le fun i _ => le_iSup f i\n\n"}
{"name":"iInf_le_iInf₂","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : CompleteLattice α\nκ : ι → Sort u_8\nf : ι → α\n⊢ LE.le (iInf fun i => f i) (iInf fun i => iInf fun x => f i)","decl":"theorem iInf_le_iInf₂ (κ : ι → Sort*) (f : ι → α) : ⨅ i, f i ≤ ⨅ (i) (_ : κ i), f i :=\n  le_iInf₂ fun i _ => iInf_le f i\n\n"}
{"name":"iSup_mono","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : CompleteLattice α\nf g : ι → α\nh : ∀ (i : ι), LE.le (f i) (g i)\n⊢ LE.le (iSup f) (iSup g)","decl":"@[gcongr]\ntheorem iSup_mono (h : ∀ i, f i ≤ g i) : iSup f ≤ iSup g :=\n  iSup_le fun i => le_iSup_of_le i <| h i\n\n"}
{"name":"iInf_mono","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : CompleteLattice α\nf g : ι → α\nh : ∀ (i : ι), LE.le (f i) (g i)\n⊢ LE.le (iInf f) (iInf g)","decl":"@[gcongr]\ntheorem iInf_mono (h : ∀ i, f i ≤ g i) : iInf f ≤ iInf g :=\n  le_iInf fun i => iInf_le_of_le i <| h i\n\n"}
{"name":"iSup₂_mono","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\nκ : ι → Sort u_6\ninst✝ : CompleteLattice α\nf g : (i : ι) → κ i → α\nh : ∀ (i : ι) (j : κ i), LE.le (f i j) (g i j)\n⊢ LE.le (iSup fun i => iSup fun j => f i j) (iSup fun i => iSup fun j => g i j)","decl":"theorem iSup₂_mono {f g : ∀ i, κ i → α} (h : ∀ i j, f i j ≤ g i j) :\n    ⨆ (i) (j), f i j ≤ ⨆ (i) (j), g i j :=\n  iSup_mono fun i => iSup_mono <| h i\n\n"}
{"name":"iInf₂_mono","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\nκ : ι → Sort u_6\ninst✝ : CompleteLattice α\nf g : (i : ι) → κ i → α\nh : ∀ (i : ι) (j : κ i), LE.le (f i j) (g i j)\n⊢ LE.le (iInf fun i => iInf fun j => f i j) (iInf fun i => iInf fun j => g i j)","decl":"theorem iInf₂_mono {f g : ∀ i, κ i → α} (h : ∀ i j, f i j ≤ g i j) :\n    ⨅ (i) (j), f i j ≤ ⨅ (i) (j), g i j :=\n  iInf_mono fun i => iInf_mono <| h i\n\n"}
{"name":"iSup_mono'","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\nι' : Sort u_5\ninst✝ : CompleteLattice α\nf : ι → α\ng : ι' → α\nh : ∀ (i : ι), Exists fun i' => LE.le (f i) (g i')\n⊢ LE.le (iSup f) (iSup g)","decl":"theorem iSup_mono' {g : ι' → α} (h : ∀ i, ∃ i', f i ≤ g i') : iSup f ≤ iSup g :=\n  iSup_le fun i => Exists.elim (h i) le_iSup_of_le\n\n"}
{"name":"iInf_mono'","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\nι' : Sort u_5\ninst✝ : CompleteLattice α\nf : ι → α\ng : ι' → α\nh : ∀ (i' : ι'), Exists fun i => LE.le (f i) (g i')\n⊢ LE.le (iInf f) (iInf g)","decl":"theorem iInf_mono' {g : ι' → α} (h : ∀ i', ∃ i, f i ≤ g i') : iInf f ≤ iInf g :=\n  le_iInf fun i' => Exists.elim (h i') iInf_le_of_le\n\n"}
{"name":"iSup₂_mono'","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\nι' : Sort u_5\nκ : ι → Sort u_6\nκ' : ι' → Sort u_7\ninst✝ : CompleteLattice α\nf : (i : ι) → κ i → α\ng : (i' : ι') → κ' i' → α\nh : ∀ (i : ι) (j : κ i), Exists fun i' => Exists fun j' => LE.le (f i j) (g i' j')\n⊢ LE.le (iSup fun i => iSup fun j => f i j) (iSup fun i => iSup fun j => g i j)","decl":"theorem iSup₂_mono' {f : ∀ i, κ i → α} {g : ∀ i', κ' i' → α} (h : ∀ i j, ∃ i' j', f i j ≤ g i' j') :\n    ⨆ (i) (j), f i j ≤ ⨆ (i) (j), g i j :=\n  iSup₂_le fun i j =>\n    let ⟨i', j', h⟩ := h i j\n    le_iSup₂_of_le i' j' h\n\n"}
{"name":"iInf₂_mono'","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\nι' : Sort u_5\nκ : ι → Sort u_6\nκ' : ι' → Sort u_7\ninst✝ : CompleteLattice α\nf : (i : ι) → κ i → α\ng : (i' : ι') → κ' i' → α\nh : ∀ (i : ι') (j : κ' i), Exists fun i' => Exists fun j' => LE.le (f i' j') (g i j)\n⊢ LE.le (iInf fun i => iInf fun j => f i j) (iInf fun i => iInf fun j => g i j)","decl":"theorem iInf₂_mono' {f : ∀ i, κ i → α} {g : ∀ i', κ' i' → α} (h : ∀ i j, ∃ i' j', f i' j' ≤ g i j) :\n    ⨅ (i) (j), f i j ≤ ⨅ (i) (j), g i j :=\n  le_iInf₂ fun i j =>\n    let ⟨i', j', h⟩ := h i j\n    iInf₂_le_of_le i' j' h\n\n"}
{"name":"iSup_const_mono","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\nι' : Sort u_5\ninst✝ : CompleteLattice α\na : α\nh : ι → ι'\n⊢ LE.le (iSup fun x => a) (iSup fun x => a)","decl":"theorem iSup_const_mono (h : ι → ι') : ⨆ _ : ι, a ≤ ⨆ _ : ι', a :=\n  iSup_le <| le_iSup _ ∘ h\n\n"}
{"name":"iInf_const_mono","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\nι' : Sort u_5\ninst✝ : CompleteLattice α\na : α\nh : ι' → ι\n⊢ LE.le (iInf fun x => a) (iInf fun x => a)","decl":"theorem iInf_const_mono (h : ι' → ι) : ⨅ _ : ι, a ≤ ⨅ _ : ι', a :=\n  le_iInf <| iInf_le _ ∘ h\n\n"}
{"name":"iSup_iInf_le_iInf_iSup","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\nι' : Sort u_5\ninst✝ : CompleteLattice α\nf : ι → ι' → α\n⊢ LE.le (iSup fun i => iInf fun j => f i j) (iInf fun j => iSup fun i => f i j)","decl":"theorem iSup_iInf_le_iInf_iSup (f : ι → ι' → α) : ⨆ i, ⨅ j, f i j ≤ ⨅ j, ⨆ i, f i j :=\n  iSup_le fun i => iInf_mono fun j => le_iSup (fun i => f i j) i\n\n"}
{"name":"biSup_mono","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : CompleteLattice α\nf : ι → α\np q : ι → Prop\nhpq : ∀ (i : ι), p i → q i\n⊢ LE.le (iSup fun i => iSup fun x => f i) (iSup fun i => iSup fun x => f i)","decl":"theorem biSup_mono {p q : ι → Prop} (hpq : ∀ i, p i → q i) :\n    ⨆ (i) (_ : p i), f i ≤ ⨆ (i) (_ : q i), f i :=\n  iSup_mono fun i => iSup_const_mono (hpq i)\n\n"}
{"name":"biInf_mono","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : CompleteLattice α\nf : ι → α\np q : ι → Prop\nhpq : ∀ (i : ι), p i → q i\n⊢ LE.le (iInf fun i => iInf fun x => f i) (iInf fun i => iInf fun x => f i)","decl":"theorem biInf_mono {p q : ι → Prop} (hpq : ∀ i, p i → q i) :\n    ⨅ (i) (_ : q i), f i ≤ ⨅ (i) (_ : p i), f i :=\n  iInf_mono fun i => iInf_const_mono (hpq i)\n\n"}
{"name":"iSup_le_iff","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : CompleteLattice α\nf : ι → α\na : α\n⊢ Iff (LE.le (iSup f) a) (∀ (i : ι), LE.le (f i) a)","decl":"@[simp]\ntheorem iSup_le_iff : iSup f ≤ a ↔ ∀ i, f i ≤ a :=\n  (isLUB_le_iff isLUB_iSup).trans forall_mem_range\n\n"}
{"name":"le_iInf_iff","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : CompleteLattice α\nf : ι → α\na : α\n⊢ Iff (LE.le a (iInf f)) (∀ (i : ι), LE.le a (f i))","decl":"@[simp]\ntheorem le_iInf_iff : a ≤ iInf f ↔ ∀ i, a ≤ f i :=\n  (le_isGLB_iff isGLB_iInf).trans forall_mem_range\n\n"}
{"name":"iSup₂_le_iff","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\nκ : ι → Sort u_6\ninst✝ : CompleteLattice α\na : α\nf : (i : ι) → κ i → α\n⊢ Iff (LE.le (iSup fun i => iSup fun j => f i j) a) (∀ (i : ι) (j : κ i), LE.le (f i j) a)","decl":"theorem iSup₂_le_iff {f : ∀ i, κ i → α} : ⨆ (i) (j), f i j ≤ a ↔ ∀ i j, f i j ≤ a := by\n  simp_rw [iSup_le_iff]\n\n"}
{"name":"le_iInf₂_iff","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\nκ : ι → Sort u_6\ninst✝ : CompleteLattice α\na : α\nf : (i : ι) → κ i → α\n⊢ Iff (LE.le a (iInf fun i => iInf fun j => f i j)) (∀ (i : ι) (j : κ i), LE.le a (f i j))","decl":"theorem le_iInf₂_iff {f : ∀ i, κ i → α} : (a ≤ ⨅ (i) (j), f i j) ↔ ∀ i j, a ≤ f i j := by\n  simp_rw [le_iInf_iff]\n\n"}
{"name":"iSup_lt_iff","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : CompleteLattice α\nf : ι → α\na : α\n⊢ Iff (LT.lt (iSup f) a) (Exists fun b => And (LT.lt b a) (∀ (i : ι), LE.le (f i) b))","decl":"theorem iSup_lt_iff : iSup f < a ↔ ∃ b, b < a ∧ ∀ i, f i ≤ b :=\n  ⟨fun h => ⟨iSup f, h, le_iSup f⟩, fun ⟨_, h, hb⟩ => (iSup_le hb).trans_lt h⟩\n\n"}
{"name":"lt_iInf_iff","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : CompleteLattice α\nf : ι → α\na : α\n⊢ Iff (LT.lt a (iInf f)) (Exists fun b => And (LT.lt a b) (∀ (i : ι), LE.le b (f i)))","decl":"theorem lt_iInf_iff : a < iInf f ↔ ∃ b, a < b ∧ ∀ i, b ≤ f i :=\n  ⟨fun h => ⟨iInf f, h, iInf_le f⟩, fun ⟨_, h, hb⟩ => h.trans_le <| le_iInf hb⟩\n\n"}
{"name":"sSup_eq_iSup","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\ns : Set α\n⊢ Eq (SupSet.sSup s) (iSup fun a => iSup fun h => a)","decl":"theorem sSup_eq_iSup {s : Set α} : sSup s = ⨆ a ∈ s, a :=\n  le_antisymm (sSup_le le_iSup₂) (iSup₂_le fun _ => le_sSup)\n\n"}
{"name":"sInf_eq_iInf","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\ns : Set α\n⊢ Eq (InfSet.sInf s) (iInf fun a => iInf fun h => a)","decl":"theorem sInf_eq_iInf {s : Set α} : sInf s = ⨅ a ∈ s, a :=\n  @sSup_eq_iSup αᵒᵈ _ _\n\n"}
{"name":"sSup_lowerBounds_eq_sInf","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\ns : Set α\n⊢ Eq (SupSet.sSup (lowerBounds s)) (InfSet.sInf s)","decl":"lemma sSup_lowerBounds_eq_sInf (s : Set α) : sSup (lowerBounds s) = sInf s :=\n  (isLUB_sSup _).unique (isGLB_sInf _).isLUB\n\n"}
{"name":"sInf_upperBounds_eq_csSup","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\ns : Set α\n⊢ Eq (InfSet.sInf (upperBounds s)) (SupSet.sSup s)","decl":"lemma sInf_upperBounds_eq_csSup (s : Set α) : sInf (upperBounds s) = sSup s :=\n  (isGLB_sInf _).unique (isLUB_sSup _).isGLB\n\n"}
{"name":"Monotone.le_map_iSup","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_4\ninst✝¹ : CompleteLattice α\ns : ι → α\ninst✝ : CompleteLattice β\nf : α → β\nhf : Monotone f\n⊢ LE.le (iSup fun i => f (s i)) (f (iSup s))","decl":"theorem Monotone.le_map_iSup [CompleteLattice β] {f : α → β} (hf : Monotone f) :\n    ⨆ i, f (s i) ≤ f (iSup s) :=\n  iSup_le fun _ => hf <| le_iSup _ _\n\n"}
{"name":"Antitone.le_map_iInf","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_4\ninst✝¹ : CompleteLattice α\ns : ι → α\ninst✝ : CompleteLattice β\nf : α → β\nhf : Antitone f\n⊢ LE.le (iSup fun i => f (s i)) (f (iInf s))","decl":"theorem Antitone.le_map_iInf [CompleteLattice β] {f : α → β} (hf : Antitone f) :\n    ⨆ i, f (s i) ≤ f (iInf s) :=\n  hf.dual_left.le_map_iSup\n\n"}
{"name":"Monotone.le_map_iSup₂","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_4\nκ : ι → Sort u_6\ninst✝¹ : CompleteLattice α\ninst✝ : CompleteLattice β\nf : α → β\nhf : Monotone f\ns : (i : ι) → κ i → α\n⊢ LE.le (iSup fun i => iSup fun j => f (s i j)) (f (iSup fun i => iSup fun j => s i j))","decl":"theorem Monotone.le_map_iSup₂ [CompleteLattice β] {f : α → β} (hf : Monotone f) (s : ∀ i, κ i → α) :\n    ⨆ (i) (j), f (s i j) ≤ f (⨆ (i) (j), s i j) :=\n  iSup₂_le fun _ _ => hf <| le_iSup₂ _ _\n\n"}
{"name":"Antitone.le_map_iInf₂","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_4\nκ : ι → Sort u_6\ninst✝¹ : CompleteLattice α\ninst✝ : CompleteLattice β\nf : α → β\nhf : Antitone f\ns : (i : ι) → κ i → α\n⊢ LE.le (iSup fun i => iSup fun j => f (s i j)) (f (iInf fun i => iInf fun j => s i j))","decl":"theorem Antitone.le_map_iInf₂ [CompleteLattice β] {f : α → β} (hf : Antitone f) (s : ∀ i, κ i → α) :\n    ⨆ (i) (j), f (s i j) ≤ f (⨅ (i) (j), s i j) :=\n  hf.dual_left.le_map_iSup₂ _\n\n"}
{"name":"Monotone.le_map_sSup","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CompleteLattice α\ninst✝ : CompleteLattice β\ns : Set α\nf : α → β\nhf : Monotone f\n⊢ LE.le (iSup fun a => iSup fun h => f a) (f (SupSet.sSup s))","decl":"theorem Monotone.le_map_sSup [CompleteLattice β] {s : Set α} {f : α → β} (hf : Monotone f) :\n    ⨆ a ∈ s, f a ≤ f (sSup s) := by rw [sSup_eq_iSup]; exact hf.le_map_iSup₂ _\n\n"}
{"name":"Antitone.le_map_sInf","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CompleteLattice α\ninst✝ : CompleteLattice β\ns : Set α\nf : α → β\nhf : Antitone f\n⊢ LE.le (iSup fun a => iSup fun h => f a) (f (InfSet.sInf s))","decl":"theorem Antitone.le_map_sInf [CompleteLattice β] {s : Set α} {f : α → β} (hf : Antitone f) :\n    ⨆ a ∈ s, f a ≤ f (sInf s) :=\n  hf.dual_left.le_map_sSup\n\n"}
{"name":"OrderIso.map_iSup","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_4\ninst✝¹ : CompleteLattice α\ninst✝ : CompleteLattice β\nf : OrderIso α β\nx : ι → α\n⊢ Eq (f (iSup fun i => x i)) (iSup fun i => f (x i))","decl":"theorem OrderIso.map_iSup [CompleteLattice β] (f : α ≃o β) (x : ι → α) :\n    f (⨆ i, x i) = ⨆ i, f (x i) :=\n  eq_of_forall_ge_iff <| f.surjective.forall.2\n  fun x => by simp only [f.le_iff_le, iSup_le_iff]\n\n"}
{"name":"OrderIso.map_iInf","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_4\ninst✝¹ : CompleteLattice α\ninst✝ : CompleteLattice β\nf : OrderIso α β\nx : ι → α\n⊢ Eq (f (iInf fun i => x i)) (iInf fun i => f (x i))","decl":"theorem OrderIso.map_iInf [CompleteLattice β] (f : α ≃o β) (x : ι → α) :\n    f (⨅ i, x i) = ⨅ i, f (x i) :=\n  OrderIso.map_iSup f.dual _\n\n"}
{"name":"OrderIso.map_sSup","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CompleteLattice α\ninst✝ : CompleteLattice β\nf : OrderIso α β\ns : Set α\n⊢ Eq (f (SupSet.sSup s)) (iSup fun a => iSup fun h => f a)","decl":"theorem OrderIso.map_sSup [CompleteLattice β] (f : α ≃o β) (s : Set α) :\n    f (sSup s) = ⨆ a ∈ s, f a := by\n  simp only [sSup_eq_iSup, OrderIso.map_iSup]\n\n"}
{"name":"OrderIso.map_sInf","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CompleteLattice α\ninst✝ : CompleteLattice β\nf : OrderIso α β\ns : Set α\n⊢ Eq (f (InfSet.sInf s)) (iInf fun a => iInf fun h => f a)","decl":"theorem OrderIso.map_sInf [CompleteLattice β] (f : α ≃o β) (s : Set α) :\n    f (sInf s) = ⨅ a ∈ s, f a :=\n  OrderIso.map_sSup f.dual _\n\n"}
{"name":"iSup_comp_le","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : CompleteLattice α\nι' : Sort u_8\nf : ι' → α\ng : ι → ι'\n⊢ LE.le (iSup fun x => f (g x)) (iSup fun y => f y)","decl":"theorem iSup_comp_le {ι' : Sort*} (f : ι' → α) (g : ι → ι') : ⨆ x, f (g x) ≤ ⨆ y, f y :=\n  iSup_mono' fun _ => ⟨_, le_rfl⟩\n\n"}
{"name":"le_iInf_comp","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : CompleteLattice α\nι' : Sort u_8\nf : ι' → α\ng : ι → ι'\n⊢ LE.le (iInf fun y => f y) (iInf fun x => f (g x))","decl":"theorem le_iInf_comp {ι' : Sort*} (f : ι' → α) (g : ι → ι') : ⨅ y, f y ≤ ⨅ x, f (g x) :=\n  iInf_mono' fun _ => ⟨_, le_rfl⟩\n\n"}
{"name":"Monotone.iSup_comp_eq","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_4\ninst✝¹ : CompleteLattice α\ninst✝ : Preorder β\nf : β → α\nhf : Monotone f\ns : ι → β\nhs : ∀ (x : β), Exists fun i => LE.le x (s i)\n⊢ Eq (iSup fun x => f (s x)) (iSup fun y => f y)","decl":"theorem Monotone.iSup_comp_eq [Preorder β] {f : β → α} (hf : Monotone f) {s : ι → β}\n    (hs : ∀ x, ∃ i, x ≤ s i) : ⨆ x, f (s x) = ⨆ y, f y :=\n  le_antisymm (iSup_comp_le _ _) (iSup_mono' fun x => (hs x).imp fun _ hi => hf hi)\n\n"}
{"name":"Monotone.iInf_comp_eq","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_4\ninst✝¹ : CompleteLattice α\ninst✝ : Preorder β\nf : β → α\nhf : Monotone f\ns : ι → β\nhs : ∀ (x : β), Exists fun i => LE.le (s i) x\n⊢ Eq (iInf fun x => f (s x)) (iInf fun y => f y)","decl":"theorem Monotone.iInf_comp_eq [Preorder β] {f : β → α} (hf : Monotone f) {s : ι → β}\n    (hs : ∀ x, ∃ i, s i ≤ x) : ⨅ x, f (s x) = ⨅ y, f y :=\n  le_antisymm (iInf_mono' fun x => (hs x).imp fun _ hi => hf hi) (le_iInf_comp _ _)\n\n"}
{"name":"Antitone.map_iSup_le","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_4\ninst✝¹ : CompleteLattice α\ns : ι → α\ninst✝ : CompleteLattice β\nf : α → β\nhf : Antitone f\n⊢ LE.le (f (iSup s)) (iInf fun i => f (s i))","decl":"theorem Antitone.map_iSup_le [CompleteLattice β] {f : α → β} (hf : Antitone f) :\n    f (iSup s) ≤ ⨅ i, f (s i) :=\n  le_iInf fun _ => hf <| le_iSup _ _\n\n"}
{"name":"Monotone.map_iInf_le","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_4\ninst✝¹ : CompleteLattice α\ns : ι → α\ninst✝ : CompleteLattice β\nf : α → β\nhf : Monotone f\n⊢ LE.le (f (iInf s)) (iInf fun i => f (s i))","decl":"theorem Monotone.map_iInf_le [CompleteLattice β] {f : α → β} (hf : Monotone f) :\n    f (iInf s) ≤ ⨅ i, f (s i) :=\n  hf.dual_left.map_iSup_le\n\n"}
{"name":"Antitone.map_iSup₂_le","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_4\nκ : ι → Sort u_6\ninst✝¹ : CompleteLattice α\ninst✝ : CompleteLattice β\nf : α → β\nhf : Antitone f\ns : (i : ι) → κ i → α\n⊢ LE.le (f (iSup fun i => iSup fun j => s i j)) (iInf fun i => iInf fun j => f (s i j))","decl":"theorem Antitone.map_iSup₂_le [CompleteLattice β] {f : α → β} (hf : Antitone f) (s : ∀ i, κ i → α) :\n    f (⨆ (i) (j), s i j) ≤ ⨅ (i) (j), f (s i j) :=\n  hf.dual.le_map_iInf₂ _\n\n"}
{"name":"Monotone.map_iInf₂_le","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_4\nκ : ι → Sort u_6\ninst✝¹ : CompleteLattice α\ninst✝ : CompleteLattice β\nf : α → β\nhf : Monotone f\ns : (i : ι) → κ i → α\n⊢ LE.le (f (iInf fun i => iInf fun j => s i j)) (iInf fun i => iInf fun j => f (s i j))","decl":"theorem Monotone.map_iInf₂_le [CompleteLattice β] {f : α → β} (hf : Monotone f) (s : ∀ i, κ i → α) :\n    f (⨅ (i) (j), s i j) ≤ ⨅ (i) (j), f (s i j) :=\n  hf.dual.le_map_iSup₂ _\n\n"}
{"name":"Antitone.map_sSup_le","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CompleteLattice α\ninst✝ : CompleteLattice β\ns : Set α\nf : α → β\nhf : Antitone f\n⊢ LE.le (f (SupSet.sSup s)) (iInf fun a => iInf fun h => f a)","decl":"theorem Antitone.map_sSup_le [CompleteLattice β] {s : Set α} {f : α → β} (hf : Antitone f) :\n    f (sSup s) ≤ ⨅ a ∈ s, f a := by\n  rw [sSup_eq_iSup]\n  exact hf.map_iSup₂_le _\n\n"}
{"name":"Monotone.map_sInf_le","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CompleteLattice α\ninst✝ : CompleteLattice β\ns : Set α\nf : α → β\nhf : Monotone f\n⊢ LE.le (f (InfSet.sInf s)) (iInf fun a => iInf fun h => f a)","decl":"theorem Monotone.map_sInf_le [CompleteLattice β] {s : Set α} {f : α → β} (hf : Monotone f) :\n    f (sInf s) ≤ ⨅ a ∈ s, f a :=\n  hf.dual_left.map_sSup_le\n\n"}
{"name":"iSup_const_le","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : CompleteLattice α\na : α\n⊢ LE.le (iSup fun x => a) a","decl":"theorem iSup_const_le : ⨆ _ : ι, a ≤ a :=\n  iSup_le fun _ => le_rfl\n\n"}
{"name":"le_iInf_const","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : CompleteLattice α\na : α\n⊢ LE.le a (iInf fun x => a)","decl":"theorem le_iInf_const : a ≤ ⨅ _ : ι, a :=\n  le_iInf fun _ => le_rfl\n\n-- We generalize this to conditionally complete lattices in `ciSup_const` and `ciInf_const`.\n"}
{"name":"iSup_const","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝¹ : CompleteLattice α\na : α\ninst✝ : Nonempty ι\n⊢ Eq (iSup fun x => a) a","decl":"theorem iSup_const [Nonempty ι] : ⨆ _ : ι, a = a := by rw [iSup, range_const, sSup_singleton]\n\n"}
{"name":"iInf_const","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝¹ : CompleteLattice α\na : α\ninst✝ : Nonempty ι\n⊢ Eq (iInf fun x => a) a","decl":"theorem iInf_const [Nonempty ι] : ⨅ _ : ι, a = a :=\n  @iSup_const αᵒᵈ _ _ a _\n\n"}
{"name":"iSup_unique","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝¹ : CompleteLattice α\ninst✝ : Unique ι\nf : ι → α\n⊢ Eq (iSup fun i => f i) (f Inhabited.default)","decl":"lemma iSup_unique [Unique ι] (f : ι → α) : ⨆ i, f i = f default := by\n  simp only [congr_arg f (Unique.eq_default _), iSup_const]\n\n"}
{"name":"iInf_unique","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝¹ : CompleteLattice α\ninst✝ : Unique ι\nf : ι → α\n⊢ Eq (iInf fun i => f i) (f Inhabited.default)","decl":"lemma iInf_unique [Unique ι] (f : ι → α) : ⨅ i, f i = f default := by\n  simp only [congr_arg f (Unique.eq_default _), iInf_const]\n\n"}
{"name":"iSup_bot","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : CompleteLattice α\n⊢ Eq (iSup fun x => Bot.bot) Bot.bot","decl":"@[simp]\ntheorem iSup_bot : (⨆ _ : ι, ⊥ : α) = ⊥ :=\n  bot_unique iSup_const_le\n\n"}
{"name":"iInf_top","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : CompleteLattice α\n⊢ Eq (iInf fun x => Top.top) Top.top","decl":"@[simp]\ntheorem iInf_top : (⨅ _ : ι, ⊤ : α) = ⊤ :=\n  top_unique le_iInf_const\n\n"}
{"name":"iSup_eq_bot","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : CompleteLattice α\ns : ι → α\n⊢ Iff (Eq (iSup s) Bot.bot) (∀ (i : ι), Eq (s i) Bot.bot)","decl":"@[simp]\ntheorem iSup_eq_bot : iSup s = ⊥ ↔ ∀ i, s i = ⊥ :=\n  sSup_eq_bot.trans forall_mem_range\n\n"}
{"name":"iInf_eq_top","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : CompleteLattice α\ns : ι → α\n⊢ Iff (Eq (iInf s) Top.top) (∀ (i : ι), Eq (s i) Top.top)","decl":"@[simp]\ntheorem iInf_eq_top : iInf s = ⊤ ↔ ∀ i, s i = ⊤ :=\n  sInf_eq_top.trans forall_mem_range\n\n"}
{"name":"bot_lt_iSup","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : CompleteLattice α\ns : ι → α\n⊢ Iff (LT.lt Bot.bot (iSup fun i => s i)) (Exists fun i => LT.lt Bot.bot (s i))","decl":"@[simp] lemma bot_lt_iSup : ⊥ < ⨆ i, s i ↔ ∃ i, ⊥ < s i := by simp [bot_lt_iff_ne_bot]\n"}
{"name":"iInf_lt_top","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : CompleteLattice α\ns : ι → α\n⊢ Iff (LT.lt (iInf fun i => s i) Top.top) (Exists fun i => LT.lt (s i) Top.top)","decl":"@[simp] lemma iInf_lt_top : ⨅ i, s i < ⊤ ↔ ∃ i, s i < ⊤ := by simp [lt_top_iff_ne_top]\n\n"}
{"name":"iSup₂_eq_bot","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\nκ : ι → Sort u_6\ninst✝ : CompleteLattice α\nf : (i : ι) → κ i → α\n⊢ Iff (Eq (iSup fun i => iSup fun j => f i j) Bot.bot) (∀ (i : ι) (j : κ i), Eq (f i j) Bot.bot)","decl":"theorem iSup₂_eq_bot {f : ∀ i, κ i → α} : ⨆ (i) (j), f i j = ⊥ ↔ ∀ i j, f i j = ⊥ := by\n  simp\n\n"}
{"name":"iInf₂_eq_top","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\nκ : ι → Sort u_6\ninst✝ : CompleteLattice α\nf : (i : ι) → κ i → α\n⊢ Iff (Eq (iInf fun i => iInf fun j => f i j) Top.top) (∀ (i : ι) (j : κ i), Eq (f i j) Top.top)","decl":"theorem iInf₂_eq_top {f : ∀ i, κ i → α} : ⨅ (i) (j), f i j = ⊤ ↔ ∀ i j, f i j = ⊤ := by\n  simp\n\n"}
{"name":"iSup_pos","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\np : Prop\nf : p → α\nhp : p\n⊢ Eq (iSup fun h => f h) (f hp)","decl":"@[simp]\ntheorem iSup_pos {p : Prop} {f : p → α} (hp : p) : ⨆ h : p, f h = f hp :=\n  le_antisymm (iSup_le fun _ => le_rfl) (le_iSup _ _)\n\n"}
{"name":"iInf_pos","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\np : Prop\nf : p → α\nhp : p\n⊢ Eq (iInf fun h => f h) (f hp)","decl":"@[simp]\ntheorem iInf_pos {p : Prop} {f : p → α} (hp : p) : ⨅ h : p, f h = f hp :=\n  le_antisymm (iInf_le _ _) (le_iInf fun _ => le_rfl)\n\n"}
{"name":"iSup_neg","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\np : Prop\nf : p → α\nhp : Not p\n⊢ Eq (iSup fun h => f h) Bot.bot","decl":"@[simp]\ntheorem iSup_neg {p : Prop} {f : p → α} (hp : ¬p) : ⨆ h : p, f h = ⊥ :=\n  le_antisymm (iSup_le fun h => (hp h).elim) bot_le\n\n"}
{"name":"iInf_neg","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\np : Prop\nf : p → α\nhp : Not p\n⊢ Eq (iInf fun h => f h) Top.top","decl":"@[simp]\ntheorem iInf_neg {p : Prop} {f : p → α} (hp : ¬p) : ⨅ h : p, f h = ⊤ :=\n  le_antisymm le_top <| le_iInf fun h => (hp h).elim\n\n"}
{"name":"iSup_eq_of_forall_le_of_forall_lt_exists_gt","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : CompleteLattice α\nb : α\nf : ι → α\nh₁ : ∀ (i : ι), LE.le (f i) b\nh₂ : ∀ (w : α), LT.lt w b → Exists fun i => LT.lt w (f i)\n⊢ Eq (iSup fun i => f i) b","decl":"/-- Introduction rule to prove that `b` is the supremum of `f`: it suffices to check that `b`\nis larger than `f i` for all `i`, and that this is not the case of any `w<b`.\nSee `ciSup_eq_of_forall_le_of_forall_lt_exists_gt` for a version in conditionally complete\nlattices. -/\ntheorem iSup_eq_of_forall_le_of_forall_lt_exists_gt {f : ι → α} (h₁ : ∀ i, f i ≤ b)\n    (h₂ : ∀ w, w < b → ∃ i, w < f i) : ⨆ i : ι, f i = b :=\n  sSup_eq_of_forall_le_of_forall_lt_exists_gt (forall_mem_range.mpr h₁) fun w hw =>\n    exists_range_iff.mpr <| h₂ w hw\n\n"}
{"name":"iInf_eq_of_forall_ge_of_forall_gt_exists_lt","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : CompleteLattice α\nf : ι → α\nb : α\na✝¹ : ∀ (i : ι), LE.le b (f i)\na✝ : ∀ (w : α), LT.lt b w → Exists fun i => LT.lt (f i) w\n⊢ Eq (iInf fun i => f i) b","decl":"/-- Introduction rule to prove that `b` is the infimum of `f`: it suffices to check that `b`\nis smaller than `f i` for all `i`, and that this is not the case of any `w>b`.\nSee `ciInf_eq_of_forall_ge_of_forall_gt_exists_lt` for a version in conditionally complete\nlattices. -/\ntheorem iInf_eq_of_forall_ge_of_forall_gt_exists_lt :\n    (∀ i, b ≤ f i) → (∀ w, b < w → ∃ i, f i < w) → ⨅ i, f i = b :=\n  @iSup_eq_of_forall_le_of_forall_lt_exists_gt αᵒᵈ _ _ _ _\n\n"}
{"name":"iSup_eq_dif","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝¹ : CompleteLattice α\np : Prop\ninst✝ : Decidable p\na : p → α\n⊢ Eq (iSup fun h => a h) (dite p (fun h => a h) fun h => Bot.bot)","decl":"theorem iSup_eq_dif {p : Prop} [Decidable p] (a : p → α) :\n    ⨆ h : p, a h = if h : p then a h else ⊥ := by by_cases h : p <;> simp [h]\n\n"}
{"name":"iSup_eq_if","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝¹ : CompleteLattice α\np : Prop\ninst✝ : Decidable p\na : α\n⊢ Eq (iSup fun x => a) (ite p a Bot.bot)","decl":"theorem iSup_eq_if {p : Prop} [Decidable p] (a : α) : ⨆ _ : p, a = if p then a else ⊥ :=\n  iSup_eq_dif fun _ => a\n\n"}
{"name":"iInf_eq_dif","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝¹ : CompleteLattice α\np : Prop\ninst✝ : Decidable p\na : p → α\n⊢ Eq (iInf fun h => a h) (dite p (fun h => a h) fun h => Top.top)","decl":"theorem iInf_eq_dif {p : Prop} [Decidable p] (a : p → α) :\n    ⨅ h : p, a h = if h : p then a h else ⊤ :=\n  @iSup_eq_dif αᵒᵈ _ _ _ _\n\n"}
{"name":"iInf_eq_if","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝¹ : CompleteLattice α\np : Prop\ninst✝ : Decidable p\na : α\n⊢ Eq (iInf fun x => a) (ite p a Top.top)","decl":"theorem iInf_eq_if {p : Prop} [Decidable p] (a : α) : ⨅ _ : p, a = if p then a else ⊤ :=\n  iInf_eq_dif fun _ => a\n\n"}
{"name":"iSup_comm","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\nι' : Sort u_5\ninst✝ : CompleteLattice α\nf : ι → ι' → α\n⊢ Eq (iSup fun i => iSup fun j => f i j) (iSup fun j => iSup fun i => f i j)","decl":"theorem iSup_comm {f : ι → ι' → α} : ⨆ (i) (j), f i j = ⨆ (j) (i), f i j :=\n  le_antisymm (iSup_le fun i => iSup_mono fun j => le_iSup (fun i => f i j) i)\n    (iSup_le fun _ => iSup_mono fun _ => le_iSup _ _)\n\n"}
{"name":"iInf_comm","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\nι' : Sort u_5\ninst✝ : CompleteLattice α\nf : ι → ι' → α\n⊢ Eq (iInf fun i => iInf fun j => f i j) (iInf fun j => iInf fun i => f i j)","decl":"theorem iInf_comm {f : ι → ι' → α} : ⨅ (i) (j), f i j = ⨅ (j) (i), f i j :=\n  @iSup_comm αᵒᵈ _ _ _ _\n\n"}
{"name":"iSup₂_comm","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nι₁ : Sort u_8\nι₂ : Sort u_9\nκ₁ : ι₁ → Sort u_10\nκ₂ : ι₂ → Sort u_11\nf : (i₁ : ι₁) → κ₁ i₁ → (i₂ : ι₂) → κ₂ i₂ → α\n⊢ Eq (iSup fun i₁ => iSup fun j₁ => iSup fun i₂ => iSup fun j₂ => f i₁ j₁ i₂ j₂) (iSup fun i₂ => iSup fun j₂ => iSup fun i₁ => iSup fun j₁ => f i₁ j₁ i₂ j₂)","decl":"theorem iSup₂_comm {ι₁ ι₂ : Sort*} {κ₁ : ι₁ → Sort*} {κ₂ : ι₂ → Sort*}\n    (f : ∀ i₁, κ₁ i₁ → ∀ i₂, κ₂ i₂ → α) :\n    ⨆ (i₁) (j₁) (i₂) (j₂), f i₁ j₁ i₂ j₂ = ⨆ (i₂) (j₂) (i₁) (j₁), f i₁ j₁ i₂ j₂ := by\n  simp only [@iSup_comm _ (κ₁ _), @iSup_comm _ ι₁]\n\n"}
{"name":"iInf₂_comm","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nι₁ : Sort u_8\nι₂ : Sort u_9\nκ₁ : ι₁ → Sort u_10\nκ₂ : ι₂ → Sort u_11\nf : (i₁ : ι₁) → κ₁ i₁ → (i₂ : ι₂) → κ₂ i₂ → α\n⊢ Eq (iInf fun i₁ => iInf fun j₁ => iInf fun i₂ => iInf fun j₂ => f i₁ j₁ i₂ j₂) (iInf fun i₂ => iInf fun j₂ => iInf fun i₁ => iInf fun j₁ => f i₁ j₁ i₂ j₂)","decl":"theorem iInf₂_comm {ι₁ ι₂ : Sort*} {κ₁ : ι₁ → Sort*} {κ₂ : ι₂ → Sort*}\n    (f : ∀ i₁, κ₁ i₁ → ∀ i₂, κ₂ i₂ → α) :\n    ⨅ (i₁) (j₁) (i₂) (j₂), f i₁ j₁ i₂ j₂ = ⨅ (i₂) (j₂) (i₁) (j₁), f i₁ j₁ i₂ j₂ := by\n  simp only [@iInf_comm _ (κ₁ _), @iInf_comm _ ι₁]\n\n/- TODO: this is strange. In the proof below, we get exactly the desired\n   among the equalities, but close does not get it.\nbegin\n  apply @le_antisymm,\n    simp, intros,\n    begin [smt]\n      ematch, ematch, ematch, trace_state, have := le_refl (f i_1 i),\n      trace_state, close\n    end\nend\n-/\n"}
{"name":"iSup_iSup_eq_left","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nb : β\nf : (x : β) → Eq x b → α\n⊢ Eq (iSup fun x => iSup fun h => f x h) (f b ⋯)","decl":"@[simp]\ntheorem iSup_iSup_eq_left {b : β} {f : ∀ x : β, x = b → α} : ⨆ x, ⨆ h : x = b, f x h = f b rfl :=\n  (@le_iSup₂ _ _ _ _ f b rfl).antisymm'\n    (iSup_le fun c =>\n      iSup_le <| by\n        rintro rfl\n        rfl)\n\n"}
{"name":"iInf_iInf_eq_left","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nb : β\nf : (x : β) → Eq x b → α\n⊢ Eq (iInf fun x => iInf fun h => f x h) (f b ⋯)","decl":"@[simp]\ntheorem iInf_iInf_eq_left {b : β} {f : ∀ x : β, x = b → α} : ⨅ x, ⨅ h : x = b, f x h = f b rfl :=\n  @iSup_iSup_eq_left αᵒᵈ _ _ _ _\n\n"}
{"name":"iSup_iSup_eq_right","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nb : β\nf : (x : β) → Eq b x → α\n⊢ Eq (iSup fun x => iSup fun h => f x h) (f b ⋯)","decl":"@[simp]\ntheorem iSup_iSup_eq_right {b : β} {f : ∀ x : β, b = x → α} : ⨆ x, ⨆ h : b = x, f x h = f b rfl :=\n  (le_iSup₂ b rfl).antisymm'\n    (iSup₂_le fun c => by\n      rintro rfl\n      rfl)\n\n"}
{"name":"iInf_iInf_eq_right","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nb : β\nf : (x : β) → Eq b x → α\n⊢ Eq (iInf fun x => iInf fun h => f x h) (f b ⋯)","decl":"@[simp]\ntheorem iInf_iInf_eq_right {b : β} {f : ∀ x : β, b = x → α} : ⨅ x, ⨅ h : b = x, f x h = f b rfl :=\n  @iSup_iSup_eq_right αᵒᵈ _ _ _ _\n\n"}
{"name":"iSup_subtype","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : CompleteLattice α\np : ι → Prop\nf : Subtype p → α\n⊢ Eq (iSup f) (iSup fun i => iSup fun h => f ⟨i, h⟩)","decl":"theorem iSup_subtype {p : ι → Prop} {f : Subtype p → α} : iSup f = ⨆ (i) (h : p i), f ⟨i, h⟩ :=\n  le_antisymm (iSup_le fun ⟨i, h⟩ => @le_iSup₂ _ _ p _ (fun i h => f ⟨i, h⟩) i h)\n    (iSup₂_le fun _ _ => le_iSup _ _)\n\n"}
{"name":"iInf_subtype","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : CompleteLattice α\np : ι → Prop\nf : Subtype p → α\n⊢ Eq (iInf f) (iInf fun i => iInf fun h => f ⟨i, h⟩)","decl":"theorem iInf_subtype : ∀ {p : ι → Prop} {f : Subtype p → α}, iInf f = ⨅ (i) (h : p i), f ⟨i, h⟩ :=\n  @iSup_subtype αᵒᵈ _ _\n\n"}
{"name":"iSup_subtype'","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : CompleteLattice α\np : ι → Prop\nf : (i : ι) → p i → α\n⊢ Eq (iSup fun i => iSup fun h => f i h) (iSup fun x => f ↑x ⋯)","decl":"theorem iSup_subtype' {p : ι → Prop} {f : ∀ i, p i → α} :\n    ⨆ (i) (h), f i h = ⨆ x : Subtype p, f x x.property :=\n  (@iSup_subtype _ _ _ p fun x => f x.val x.property).symm\n\n"}
{"name":"iInf_subtype'","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : CompleteLattice α\np : ι → Prop\nf : (i : ι) → p i → α\n⊢ Eq (iInf fun i => iInf fun h => f i h) (iInf fun x => f ↑x ⋯)","decl":"theorem iInf_subtype' {p : ι → Prop} {f : ∀ i, p i → α} :\n    ⨅ (i) (h : p i), f i h = ⨅ x : Subtype p, f x x.property :=\n  (@iInf_subtype _ _ _ p fun x => f x.val x.property).symm\n\n"}
{"name":"iSup_subtype''","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nι : Type u_8\ns : Set ι\nf : ι → α\n⊢ Eq (iSup fun i => f ↑i) (iSup fun t => iSup fun x => f t)","decl":"theorem iSup_subtype'' {ι} (s : Set ι) (f : ι → α) : ⨆ i : s, f i = ⨆ (t : ι) (_ : t ∈ s), f t :=\n  iSup_subtype\n\n"}
{"name":"iInf_subtype''","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nι : Type u_8\ns : Set ι\nf : ι → α\n⊢ Eq (iInf fun i => f ↑i) (iInf fun t => iInf fun x => f t)","decl":"theorem iInf_subtype'' {ι} (s : Set ι) (f : ι → α) : ⨅ i : s, f i = ⨅ (t : ι) (_ : t ∈ s), f t :=\n  iInf_subtype\n\n"}
{"name":"biSup_const","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\na : α\ns : Set β\nhs : s.Nonempty\n⊢ Eq (iSup fun i => iSup fun h => a) a","decl":"theorem biSup_const {a : α} {s : Set β} (hs : s.Nonempty) : ⨆ i ∈ s, a = a := by\n  haveI : Nonempty s := Set.nonempty_coe_sort.mpr hs\n  rw [← iSup_subtype'', iSup_const]\n\n"}
{"name":"biInf_const","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\na : α\ns : Set β\nhs : s.Nonempty\n⊢ Eq (iInf fun i => iInf fun h => a) a","decl":"theorem biInf_const {a : α} {s : Set β} (hs : s.Nonempty) : ⨅ i ∈ s, a = a :=\n  biSup_const (α := αᵒᵈ) hs\n\n"}
{"name":"iSup_sup_eq","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : CompleteLattice α\nf g : ι → α\n⊢ Eq (iSup fun x => Max.max (f x) (g x)) (Max.max (iSup fun x => f x) (iSup fun x => g x))","decl":"theorem iSup_sup_eq : ⨆ x, f x ⊔ g x = (⨆ x, f x) ⊔ ⨆ x, g x :=\n  le_antisymm (iSup_le fun _ => sup_le_sup (le_iSup _ _) <| le_iSup _ _)\n    (sup_le (iSup_mono fun _ => le_sup_left) <| iSup_mono fun _ => le_sup_right)\n\n"}
{"name":"iInf_inf_eq","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : CompleteLattice α\nf g : ι → α\n⊢ Eq (iInf fun x => Min.min (f x) (g x)) (Min.min (iInf fun x => f x) (iInf fun x => g x))","decl":"theorem iInf_inf_eq : ⨅ x, f x ⊓ g x = (⨅ x, f x) ⊓ ⨅ x, g x :=\n  @iSup_sup_eq αᵒᵈ _ _ _ _\n\n"}
{"name":"Equiv.biSup_comp","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nι : Type u_8\nι' : Type u_9\ng : ι' → α\ne : Equiv ι ι'\ns : Set ι'\n⊢ Eq (iSup fun i => iSup fun h => g (e i)) (iSup fun i => iSup fun h => g i)","decl":"lemma Equiv.biSup_comp {ι ι' : Type*} {g : ι' → α} (e : ι ≃ ι') (s : Set ι') :\n    ⨆ i ∈ e.symm '' s, g (e i) = ⨆ i ∈ s, g i := by\n  simpa only [iSup_subtype'] using (image e.symm s).symm.iSup_comp (g := g ∘ (↑))\n\n"}
{"name":"Equiv.biInf_comp","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nι : Type u_8\nι' : Type u_9\ng : ι' → α\ne : Equiv ι ι'\ns : Set ι'\n⊢ Eq (iInf fun i => iInf fun h => g (e i)) (iInf fun i => iInf fun h => g i)","decl":"lemma Equiv.biInf_comp {ι ι' : Type*} {g : ι' → α} (e : ι ≃ ι') (s : Set ι') :\n    ⨅ i ∈ e.symm '' s, g (e i) = ⨅ i ∈ s, g i :=\n  e.biSup_comp s (α := αᵒᵈ)\n\n"}
{"name":"biInf_le","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nι : Type u_8\ns : Set ι\nf : ι → α\ni : ι\nhi : Membership.mem s i\n⊢ LE.le (iInf fun i => iInf fun h => f i) (f i)","decl":"lemma biInf_le {ι : Type*} {s : Set ι} (f : ι → α) {i : ι} (hi : i ∈ s) : ⨅ i ∈ s, f i ≤ f i :=\n  iInf₂_le i hi\n\n"}
{"name":"le_biSup","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nι : Type u_8\ns : Set ι\nf : ι → α\ni : ι\nhi : Membership.mem s i\n⊢ LE.le (f i) (iSup fun i => iSup fun h => f i)","decl":"lemma le_biSup {ι : Type*} {s : Set ι} (f : ι → α) {i : ι} (hi : i ∈ s) : f i ≤ ⨆ i ∈ s, f i :=\n  biInf_le (α := αᵒᵈ) f hi\n\n"}
{"name":"biInf_le_biSup","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nι : Type u_8\ns : Set ι\nhs : s.Nonempty\nf : ι → α\n⊢ LE.le (iInf fun i => iInf fun h => f i) (iSup fun i => iSup fun h => f i)","decl":"lemma biInf_le_biSup {ι : Type*} {s : Set ι} (hs : s.Nonempty) {f : ι → α} :\n    ⨅ i ∈ s, f i ≤ ⨆ i ∈ s, f i :=\n  (biInf_le _ hs.choose_spec).trans <| le_biSup _ hs.choose_spec\n\n/- TODO: here is another example where more flexible pattern matching\n   might help.\n\nbegin\n  apply @le_antisymm,\n  safe, pose h := f a ⊓ g a, begin [smt] ematch, ematch end\nend\n-/\n"}
{"name":"iSup_sup","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝¹ : CompleteLattice α\ninst✝ : Nonempty ι\nf : ι → α\na : α\n⊢ Eq (Max.max (iSup fun x => f x) a) (iSup fun x => Max.max (f x) a)","decl":"theorem iSup_sup [Nonempty ι] {f : ι → α} {a : α} : (⨆ x, f x) ⊔ a = ⨆ x, f x ⊔ a := by\n  rw [iSup_sup_eq, iSup_const]\n\n"}
{"name":"iInf_inf","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝¹ : CompleteLattice α\ninst✝ : Nonempty ι\nf : ι → α\na : α\n⊢ Eq (Min.min (iInf fun x => f x) a) (iInf fun x => Min.min (f x) a)","decl":"theorem iInf_inf [Nonempty ι] {f : ι → α} {a : α} : (⨅ x, f x) ⊓ a = ⨅ x, f x ⊓ a := by\n  rw [iInf_inf_eq, iInf_const]\n\n"}
{"name":"sup_iSup","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝¹ : CompleteLattice α\ninst✝ : Nonempty ι\nf : ι → α\na : α\n⊢ Eq (Max.max a (iSup fun x => f x)) (iSup fun x => Max.max a (f x))","decl":"theorem sup_iSup [Nonempty ι] {f : ι → α} {a : α} : (a ⊔ ⨆ x, f x) = ⨆ x, a ⊔ f x := by\n  rw [iSup_sup_eq, iSup_const]\n\n"}
{"name":"inf_iInf","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝¹ : CompleteLattice α\ninst✝ : Nonempty ι\nf : ι → α\na : α\n⊢ Eq (Min.min a (iInf fun x => f x)) (iInf fun x => Min.min a (f x))","decl":"theorem inf_iInf [Nonempty ι] {f : ι → α} {a : α} : (a ⊓ ⨅ x, f x) = ⨅ x, a ⊓ f x := by\n  rw [iInf_inf_eq, iInf_const]\n\n"}
{"name":"biSup_sup","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : CompleteLattice α\np : ι → Prop\nf : (i : ι) → p i → α\na : α\nh : Exists fun i => p i\n⊢ Eq (Max.max (iSup fun i => iSup fun h => f i h) a) (iSup fun i => iSup fun h => Max.max (f i h) a)","decl":"theorem biSup_sup {p : ι → Prop} {f : ∀ i, p i → α} {a : α} (h : ∃ i, p i) :\n    (⨆ (i) (h : p i), f i h) ⊔ a = ⨆ (i) (h : p i), f i h ⊔ a := by\n  haveI : Nonempty { i // p i } :=\n    let ⟨i, hi⟩ := h\n    ⟨⟨i, hi⟩⟩\n  rw [iSup_subtype', iSup_subtype', iSup_sup]\n\n"}
{"name":"sup_biSup","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : CompleteLattice α\np : ι → Prop\nf : (i : ι) → p i → α\na : α\nh : Exists fun i => p i\n⊢ Eq (Max.max a (iSup fun i => iSup fun h => f i h)) (iSup fun i => iSup fun h => Max.max a (f i h))","decl":"theorem sup_biSup {p : ι → Prop} {f : ∀ i, p i → α} {a : α} (h : ∃ i, p i) :\n    (a ⊔ ⨆ (i) (h : p i), f i h) = ⨆ (i) (h : p i), a ⊔ f i h := by\n  simpa only [sup_comm] using @biSup_sup α _ _ p _ _ h\n\n"}
{"name":"biInf_inf","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : CompleteLattice α\np : ι → Prop\nf : (i : ι) → p i → α\na : α\nh : Exists fun i => p i\n⊢ Eq (Min.min (iInf fun i => iInf fun h => f i h) a) (iInf fun i => iInf fun h => Min.min (f i h) a)","decl":"theorem biInf_inf {p : ι → Prop} {f : ∀ i, p i → α} {a : α} (h : ∃ i, p i) :\n    (⨅ (i) (h : p i), f i h) ⊓ a = ⨅ (i) (h : p i), f i h ⊓ a :=\n  @biSup_sup αᵒᵈ ι _ p f _ h\n\n"}
{"name":"inf_biInf","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : CompleteLattice α\np : ι → Prop\nf : (i : ι) → p i → α\na : α\nh : Exists fun i => p i\n⊢ Eq (Min.min a (iInf fun i => iInf fun h => f i h)) (iInf fun i => iInf fun h => Min.min a (f i h))","decl":"theorem inf_biInf {p : ι → Prop} {f : ∀ i, p i → α} {a : α} (h : ∃ i, p i) :\n    (a ⊓ ⨅ (i) (h : p i), f i h) = ⨅ (i) (h : p i), a ⊓ f i h :=\n  @sup_biSup αᵒᵈ ι _ p f _ h\n\n"}
{"name":"biSup_lt_eq_iSup","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝² : CompleteLattice α\nι : Type u_8\ninst✝¹ : LT ι\ninst✝ : NoMaxOrder ι\nf : ι → α\n⊢ Eq (iSup fun i => iSup fun j => iSup fun h => f j) (iSup fun i => f i)","decl":"lemma biSup_lt_eq_iSup {ι : Type*} [LT ι] [NoMaxOrder ι] {f : ι → α} :\n    ⨆ (i) (j < i), f j = ⨆ i, f i := by\n  apply le_antisymm\n  · exact iSup_le fun _ ↦ iSup₂_le fun _ _ ↦ le_iSup _ _\n  · refine iSup_le fun j ↦ ?_\n    obtain ⟨i, jlt⟩ := exists_gt j\n    exact le_iSup_of_le i (le_iSup₂_of_le j jlt le_rfl)\n\n"}
{"name":"biSup_le_eq_iSup","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝¹ : CompleteLattice α\nι : Type u_8\ninst✝ : Preorder ι\nf : ι → α\n⊢ Eq (iSup fun i => iSup fun j => iSup fun h => f j) (iSup fun i => f i)","decl":"lemma biSup_le_eq_iSup {ι : Type*} [Preorder ι] {f : ι → α} :\n    ⨆ (i) (j ≤ i), f j = ⨆ i, f i := by\n  apply le_antisymm\n  · exact iSup_le fun _ ↦ iSup₂_le fun _ _ ↦ le_iSup _ _\n  · exact iSup_le fun j ↦ le_iSup_of_le j (le_iSup₂_of_le j le_rfl le_rfl)\n\n"}
{"name":"biInf_lt_eq_iInf","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝² : CompleteLattice α\nι : Type u_8\ninst✝¹ : LT ι\ninst✝ : NoMaxOrder ι\nf : ι → α\n⊢ Eq (iInf fun i => iInf fun j => iInf fun h => f j) (iInf fun i => f i)","decl":"lemma biInf_lt_eq_iInf {ι : Type*} [LT ι] [NoMaxOrder ι] {f : ι → α} :\n    ⨅ (i) (j < i), f j = ⨅ i, f i :=\n  biSup_lt_eq_iSup (α := αᵒᵈ)\n\n"}
{"name":"biInf_le_eq_iInf","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝¹ : CompleteLattice α\nι : Type u_8\ninst✝ : Preorder ι\nf : ι → α\n⊢ Eq (iInf fun i => iInf fun j => iInf fun h => f j) (iInf fun i => f i)","decl":"lemma biInf_le_eq_iInf {ι : Type*} [Preorder ι] {f : ι → α} : ⨅ (i) (j ≤ i), f j = ⨅ i, f i :=\n  biSup_le_eq_iSup (α := αᵒᵈ)\n\n"}
{"name":"biSup_gt_eq_iSup","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝² : CompleteLattice α\nι : Type u_8\ninst✝¹ : LT ι\ninst✝ : NoMinOrder ι\nf : ι → α\n⊢ Eq (iSup fun i => iSup fun j => iSup fun h => f j) (iSup fun i => f i)","decl":"lemma biSup_gt_eq_iSup {ι : Type*} [LT ι] [NoMinOrder ι] {f : ι → α} :\n    ⨆ (i) (j > i), f j = ⨆ i, f i :=\n  biSup_lt_eq_iSup (ι := ιᵒᵈ)\n\n"}
{"name":"biSup_ge_eq_iSup","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝¹ : CompleteLattice α\nι : Type u_8\ninst✝ : Preorder ι\nf : ι → α\n⊢ Eq (iSup fun i => iSup fun j => iSup fun h => f j) (iSup fun i => f i)","decl":"lemma biSup_ge_eq_iSup {ι : Type*} [Preorder ι] {f : ι → α} : ⨆ (i) (j ≥ i), f j = ⨆ i, f i :=\n  biSup_le_eq_iSup (ι := ιᵒᵈ)\n\n"}
{"name":"biInf_gt_eq_iInf","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝² : CompleteLattice α\nι : Type u_8\ninst✝¹ : LT ι\ninst✝ : NoMinOrder ι\nf : ι → α\n⊢ Eq (iInf fun i => iInf fun j => iInf fun h => f j) (iInf fun i => f i)","decl":"lemma biInf_gt_eq_iInf {ι : Type*} [LT ι] [NoMinOrder ι] {f : ι → α} :\n    ⨅ (i) (j > i), f j = ⨅ i, f i :=\n  biInf_lt_eq_iInf (ι := ιᵒᵈ)\n\n"}
{"name":"biInf_ge_eq_iInf","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝¹ : CompleteLattice α\nι : Type u_8\ninst✝ : Preorder ι\nf : ι → α\n⊢ Eq (iInf fun i => iInf fun j => iInf fun h => f j) (iInf fun i => f i)","decl":"lemma biInf_ge_eq_iInf {ι : Type*} [Preorder ι] {f : ι → α} : ⨅ (i) (j ≥ i), f j = ⨅ i, f i :=\n  biInf_le_eq_iInf (ι := ιᵒᵈ)\n\n"}
{"name":"iSup_false","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\ns : False → α\n⊢ Eq (iSup s) Bot.bot","decl":"theorem iSup_false {s : False → α} : iSup s = ⊥ := by simp\n\n"}
{"name":"iInf_false","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\ns : False → α\n⊢ Eq (iInf s) Top.top","decl":"theorem iInf_false {s : False → α} : iInf s = ⊤ := by simp\n\n"}
{"name":"iSup_true","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\ns : True → α\n⊢ Eq (iSup s) (s trivial)","decl":"theorem iSup_true {s : True → α} : iSup s = s trivial :=\n  iSup_pos trivial\n\n"}
{"name":"iInf_true","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\ns : True → α\n⊢ Eq (iInf s) (s trivial)","decl":"theorem iInf_true {s : True → α} : iInf s = s trivial :=\n  iInf_pos trivial\n\n"}
{"name":"iSup_exists","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : CompleteLattice α\np : ι → Prop\nf : Exists p → α\n⊢ Eq (iSup fun x => f x) (iSup fun i => iSup fun h => f ⋯)","decl":"@[simp]\ntheorem iSup_exists {p : ι → Prop} {f : Exists p → α} : ⨆ x, f x = ⨆ (i) (h), f ⟨i, h⟩ :=\n  le_antisymm (iSup_le fun ⟨i, h⟩ => @le_iSup₂ _ _ _ _ (fun _ _ => _) i h)\n    (iSup₂_le fun _ _ => le_iSup _ _)\n\n"}
{"name":"iInf_exists","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : CompleteLattice α\np : ι → Prop\nf : Exists p → α\n⊢ Eq (iInf fun x => f x) (iInf fun i => iInf fun h => f ⋯)","decl":"@[simp]\ntheorem iInf_exists {p : ι → Prop} {f : Exists p → α} : ⨅ x, f x = ⨅ (i) (h), f ⟨i, h⟩ :=\n  @iSup_exists αᵒᵈ _ _ _ _\n\n"}
{"name":"iSup_and","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\np q : Prop\ns : And p q → α\n⊢ Eq (iSup s) (iSup fun h₁ => iSup fun h₂ => s ⋯)","decl":"theorem iSup_and {p q : Prop} {s : p ∧ q → α} : iSup s = ⨆ (h₁) (h₂), s ⟨h₁, h₂⟩ :=\n  le_antisymm (iSup_le fun ⟨i, h⟩ => @le_iSup₂ _ _ _ _ (fun _ _ => _) i h)\n    (iSup₂_le fun _ _ => le_iSup _ _)\n\n"}
{"name":"iInf_and","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\np q : Prop\ns : And p q → α\n⊢ Eq (iInf s) (iInf fun h₁ => iInf fun h₂ => s ⋯)","decl":"theorem iInf_and {p q : Prop} {s : p ∧ q → α} : iInf s = ⨅ (h₁) (h₂), s ⟨h₁, h₂⟩ :=\n  @iSup_and αᵒᵈ _ _ _ _\n\n"}
{"name":"iSup_and'","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\np q : Prop\ns : p → q → α\n⊢ Eq (iSup fun h₁ => iSup fun h₂ => s h₁ h₂) (iSup fun h => s ⋯ ⋯)","decl":"/-- The symmetric case of `iSup_and`, useful for rewriting into a supremum over a conjunction -/\ntheorem iSup_and' {p q : Prop} {s : p → q → α} :\n    ⨆ (h₁ : p) (h₂ : q), s h₁ h₂ = ⨆ h : p ∧ q, s h.1 h.2 :=\n  Eq.symm iSup_and\n\n"}
{"name":"iInf_and'","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\np q : Prop\ns : p → q → α\n⊢ Eq (iInf fun h₁ => iInf fun h₂ => s h₁ h₂) (iInf fun h => s ⋯ ⋯)","decl":"/-- The symmetric case of `iInf_and`, useful for rewriting into an infimum over a conjunction -/\ntheorem iInf_and' {p q : Prop} {s : p → q → α} :\n    ⨅ (h₁ : p) (h₂ : q), s h₁ h₂ = ⨅ h : p ∧ q, s h.1 h.2 :=\n  Eq.symm iInf_and\n\n"}
{"name":"iSup_or","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\np q : Prop\ns : Or p q → α\n⊢ Eq (iSup fun x => s x) (Max.max (iSup fun i => s ⋯) (iSup fun j => s ⋯))","decl":"theorem iSup_or {p q : Prop} {s : p ∨ q → α} :\n    ⨆ x, s x = (⨆ i, s (Or.inl i)) ⊔ ⨆ j, s (Or.inr j) :=\n  le_antisymm\n    (iSup_le fun i =>\n      match i with\n      | Or.inl _ => le_sup_of_le_left <| le_iSup (fun _ => s _) _\n      | Or.inr _ => le_sup_of_le_right <| le_iSup (fun _ => s _) _)\n    (sup_le (iSup_comp_le _ _) (iSup_comp_le _ _))\n\n"}
{"name":"iInf_or","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\np q : Prop\ns : Or p q → α\n⊢ Eq (iInf fun x => s x) (Min.min (iInf fun i => s ⋯) (iInf fun j => s ⋯))","decl":"theorem iInf_or {p q : Prop} {s : p ∨ q → α} :\n    ⨅ x, s x = (⨅ i, s (Or.inl i)) ⊓ ⨅ j, s (Or.inr j) :=\n  @iSup_or αᵒᵈ _ _ _ _\n\n"}
{"name":"iSup_dite","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝¹ : CompleteLattice α\np : ι → Prop\ninst✝ : DecidablePred p\nf : (i : ι) → p i → α\ng : (i : ι) → Not (p i) → α\n⊢ Eq (iSup fun i => dite (p i) (fun h => f i h) fun h => g i h) (Max.max (iSup fun i => iSup fun h => f i h) (iSup fun i => iSup fun h => g i h))","decl":"theorem iSup_dite (f : ∀ i, p i → α) (g : ∀ i, ¬p i → α) :\n    ⨆ i, (if h : p i then f i h else g i h) = (⨆ (i) (h : p i), f i h) ⊔ ⨆ (i) (h : ¬p i),\n    g i h := by\n  rw [← iSup_sup_eq]\n  congr 1 with i\n  split_ifs with h <;> simp [h]\n\n"}
{"name":"iInf_dite","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝¹ : CompleteLattice α\np : ι → Prop\ninst✝ : DecidablePred p\nf : (i : ι) → p i → α\ng : (i : ι) → Not (p i) → α\n⊢ Eq (iInf fun i => dite (p i) (fun h => f i h) fun h => g i h) (Min.min (iInf fun i => iInf fun h => f i h) (iInf fun i => iInf fun h => g i h))","decl":"theorem iInf_dite (f : ∀ i, p i → α) (g : ∀ i, ¬p i → α) :\n    ⨅ i, (if h : p i then f i h else g i h) = (⨅ (i) (h : p i), f i h) ⊓ ⨅ (i) (h : ¬p i), g i h :=\n  iSup_dite p (show ∀ i, p i → αᵒᵈ from f) g\n\n"}
{"name":"iSup_ite","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝¹ : CompleteLattice α\np : ι → Prop\ninst✝ : DecidablePred p\nf g : ι → α\n⊢ Eq (iSup fun i => ite (p i) (f i) (g i)) (Max.max (iSup fun i => iSup fun x => f i) (iSup fun i => iSup fun x => g i))","decl":"theorem iSup_ite (f g : ι → α) :\n    ⨆ i, (if p i then f i else g i) = (⨆ (i) (_ : p i), f i) ⊔ ⨆ (i) (_ : ¬p i), g i :=\n  iSup_dite _ _ _\n\n"}
{"name":"iInf_ite","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝¹ : CompleteLattice α\np : ι → Prop\ninst✝ : DecidablePred p\nf g : ι → α\n⊢ Eq (iInf fun i => ite (p i) (f i) (g i)) (Min.min (iInf fun i => iInf fun x => f i) (iInf fun i => iInf fun x => g i))","decl":"theorem iInf_ite (f g : ι → α) :\n    ⨅ i, (if p i then f i else g i) = (⨅ (i) (_ : p i), f i) ⊓ ⨅ (i) (_ : ¬p i), g i :=\n  iInf_dite _ _ _\n\n"}
{"name":"iSup_range","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_4\ninst✝ : CompleteLattice α\ng : β → α\nf : ι → β\n⊢ Eq (iSup fun b => iSup fun h => g b) (iSup fun i => g (f i))","decl":"theorem iSup_range {g : β → α} {f : ι → β} : ⨆ b ∈ range f, g b = ⨆ i, g (f i) := by\n  rw [← iSup_subtype'', iSup_range']\n\n"}
{"name":"iInf_range","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_4\ninst✝ : CompleteLattice α\ng : β → α\nf : ι → β\n⊢ Eq (iInf fun b => iInf fun h => g b) (iInf fun i => g (f i))","decl":"theorem iInf_range : ∀ {g : β → α} {f : ι → β}, ⨅ b ∈ range f, g b = ⨅ i, g (f i) :=\n  @iSup_range αᵒᵈ _ _ _\n\n"}
{"name":"sSup_image","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\ns : Set β\nf : β → α\n⊢ Eq (SupSet.sSup (Set.image f s)) (iSup fun a => iSup fun h => f a)","decl":"theorem sSup_image {s : Set β} {f : β → α} : sSup (f '' s) = ⨆ a ∈ s, f a := by\n  rw [← iSup_subtype'', sSup_image']\n\n"}
{"name":"sInf_image","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\ns : Set β\nf : β → α\n⊢ Eq (InfSet.sInf (Set.image f s)) (iInf fun a => iInf fun h => f a)","decl":"theorem sInf_image {s : Set β} {f : β → α} : sInf (f '' s) = ⨅ a ∈ s, f a :=\n  @sSup_image αᵒᵈ _ _ _ _\n\n"}
{"name":"OrderIso.map_sSup_eq_sSup_symm_preimage","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CompleteLattice α\ninst✝ : CompleteLattice β\nf : OrderIso α β\ns : Set α\n⊢ Eq (f (SupSet.sSup s)) (SupSet.sSup (Set.preimage (⇑f.symm) s))","decl":"theorem OrderIso.map_sSup_eq_sSup_symm_preimage [CompleteLattice β] (f : α ≃o β) (s : Set α) :\n    f (sSup s) = sSup (f.symm ⁻¹' s) := by\n  rw [map_sSup, ← sSup_image, f.image_eq_preimage]\n\n"}
{"name":"OrderIso.map_sInf_eq_sInf_symm_preimage","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CompleteLattice α\ninst✝ : CompleteLattice β\nf : OrderIso α β\ns : Set α\n⊢ Eq (f (InfSet.sInf s)) (InfSet.sInf (Set.preimage (⇑f.symm) s))","decl":"theorem OrderIso.map_sInf_eq_sInf_symm_preimage [CompleteLattice β] (f : α ≃o β) (s : Set α) :\n    f (sInf s) = sInf (f.symm ⁻¹' s) := by\n  rw [map_sInf, ← sInf_image, f.image_eq_preimage]\n\n/-\n### iSup and iInf under set constructions\n-/\n"}
{"name":"iSup_emptyset","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nf : β → α\n⊢ Eq (iSup fun x => iSup fun h => f x) Bot.bot","decl":"theorem iSup_emptyset {f : β → α} : ⨆ x ∈ (∅ : Set β), f x = ⊥ := by simp\n\n"}
{"name":"iInf_emptyset","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nf : β → α\n⊢ Eq (iInf fun x => iInf fun h => f x) Top.top","decl":"theorem iInf_emptyset {f : β → α} : ⨅ x ∈ (∅ : Set β), f x = ⊤ := by simp\n\n"}
{"name":"iSup_univ","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nf : β → α\n⊢ Eq (iSup fun x => iSup fun h => f x) (iSup fun x => f x)","decl":"theorem iSup_univ {f : β → α} : ⨆ x ∈ (univ : Set β), f x = ⨆ x, f x := by simp\n\n"}
{"name":"iInf_univ","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nf : β → α\n⊢ Eq (iInf fun x => iInf fun h => f x) (iInf fun x => f x)","decl":"theorem iInf_univ {f : β → α} : ⨅ x ∈ (univ : Set β), f x = ⨅ x, f x := by simp\n\n"}
{"name":"iSup_union","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nf : β → α\ns t : Set β\n⊢ Eq (iSup fun x => iSup fun h => f x) (Max.max (iSup fun x => iSup fun h => f x) (iSup fun x => iSup fun h => f x))","decl":"theorem iSup_union {f : β → α} {s t : Set β} :\n    ⨆ x ∈ s ∪ t, f x = (⨆ x ∈ s, f x) ⊔ ⨆ x ∈ t, f x := by\n  simp_rw [mem_union, iSup_or, iSup_sup_eq]\n\n"}
{"name":"iInf_union","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nf : β → α\ns t : Set β\n⊢ Eq (iInf fun x => iInf fun h => f x) (Min.min (iInf fun x => iInf fun h => f x) (iInf fun x => iInf fun h => f x))","decl":"theorem iInf_union {f : β → α} {s t : Set β} : ⨅ x ∈ s ∪ t, f x = (⨅ x ∈ s, f x) ⊓ ⨅ x ∈ t, f x :=\n  @iSup_union αᵒᵈ _ _ _ _ _\n\n"}
{"name":"iSup_split","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nf : β → α\np : β → Prop\n⊢ Eq (iSup fun i => f i) (Max.max (iSup fun i => iSup fun x => f i) (iSup fun i => iSup fun x => f i))","decl":"theorem iSup_split (f : β → α) (p : β → Prop) :\n    ⨆ i, f i = (⨆ (i) (_ : p i), f i) ⊔ ⨆ (i) (_ : ¬p i), f i := by\n  simpa [Classical.em] using @iSup_union _ _ _ f { i | p i } { i | ¬p i }\n\n"}
{"name":"iInf_split","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nf : β → α\np : β → Prop\n⊢ Eq (iInf fun i => f i) (Min.min (iInf fun i => iInf fun x => f i) (iInf fun i => iInf fun x => f i))","decl":"theorem iInf_split :\n    ∀ (f : β → α) (p : β → Prop), ⨅ i, f i = (⨅ (i) (_ : p i), f i) ⊓ ⨅ (i) (_ : ¬p i), f i :=\n  @iSup_split αᵒᵈ _ _\n\n"}
{"name":"iSup_split_single","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nf : β → α\ni₀ : β\n⊢ Eq (iSup fun i => f i) (Max.max (f i₀) (iSup fun i => iSup fun x => f i))","decl":"theorem iSup_split_single (f : β → α) (i₀ : β) : ⨆ i, f i = f i₀ ⊔ ⨆ (i) (_ : i ≠ i₀), f i := by\n  convert iSup_split f (fun i => i = i₀)\n  simp\n\n"}
{"name":"iInf_split_single","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nf : β → α\ni₀ : β\n⊢ Eq (iInf fun i => f i) (Min.min (f i₀) (iInf fun i => iInf fun x => f i))","decl":"theorem iInf_split_single (f : β → α) (i₀ : β) : ⨅ i, f i = f i₀ ⊓ ⨅ (i) (_ : i ≠ i₀), f i :=\n  @iSup_split_single αᵒᵈ _ _ _ _\n\n"}
{"name":"iSup_le_iSup_of_subset","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nf : β → α\ns t : Set β\na✝ : HasSubset.Subset s t\n⊢ LE.le (iSup fun x => iSup fun h => f x) (iSup fun x => iSup fun h => f x)","decl":"theorem iSup_le_iSup_of_subset {f : β → α} {s t : Set β} : s ⊆ t → ⨆ x ∈ s, f x ≤ ⨆ x ∈ t, f x :=\n  biSup_mono\n\n"}
{"name":"iInf_le_iInf_of_subset","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nf : β → α\ns t : Set β\na✝ : HasSubset.Subset s t\n⊢ LE.le (iInf fun x => iInf fun h => f x) (iInf fun x => iInf fun h => f x)","decl":"theorem iInf_le_iInf_of_subset {f : β → α} {s t : Set β} : s ⊆ t → ⨅ x ∈ t, f x ≤ ⨅ x ∈ s, f x :=\n  biInf_mono\n\n"}
{"name":"iSup_insert","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nf : β → α\ns : Set β\nb : β\n⊢ Eq (iSup fun x => iSup fun h => f x) (Max.max (f b) (iSup fun x => iSup fun h => f x))","decl":"theorem iSup_insert {f : β → α} {s : Set β} {b : β} :\n    ⨆ x ∈ insert b s, f x = f b ⊔ ⨆ x ∈ s, f x :=\n  Eq.trans iSup_union <| congr_arg (fun x => x ⊔ ⨆ x ∈ s, f x) iSup_iSup_eq_left\n\n"}
{"name":"iInf_insert","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nf : β → α\ns : Set β\nb : β\n⊢ Eq (iInf fun x => iInf fun h => f x) (Min.min (f b) (iInf fun x => iInf fun h => f x))","decl":"theorem iInf_insert {f : β → α} {s : Set β} {b : β} :\n    ⨅ x ∈ insert b s, f x = f b ⊓ ⨅ x ∈ s, f x :=\n  Eq.trans iInf_union <| congr_arg (fun x => x ⊓ ⨅ x ∈ s, f x) iInf_iInf_eq_left\n\n"}
{"name":"iSup_singleton","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nf : β → α\nb : β\n⊢ Eq (iSup fun x => iSup fun h => f x) (f b)","decl":"theorem iSup_singleton {f : β → α} {b : β} : ⨆ x ∈ (singleton b : Set β), f x = f b := by simp\n\n"}
{"name":"iInf_singleton","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nf : β → α\nb : β\n⊢ Eq (iInf fun x => iInf fun h => f x) (f b)","decl":"theorem iInf_singleton {f : β → α} {b : β} : ⨅ x ∈ (singleton b : Set β), f x = f b := by simp\n\n"}
{"name":"iSup_pair","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nf : β → α\na b : β\n⊢ Eq (iSup fun x => iSup fun h => f x) (Max.max (f a) (f b))","decl":"theorem iSup_pair {f : β → α} {a b : β} : ⨆ x ∈ ({a, b} : Set β), f x = f a ⊔ f b := by\n  rw [iSup_insert, iSup_singleton]\n\n"}
{"name":"iInf_pair","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nf : β → α\na b : β\n⊢ Eq (iInf fun x => iInf fun h => f x) (Min.min (f a) (f b))","decl":"theorem iInf_pair {f : β → α} {a b : β} : ⨅ x ∈ ({a, b} : Set β), f x = f a ⊓ f b := by\n  rw [iInf_insert, iInf_singleton]\n\n"}
{"name":"iSup_image","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nγ : Type u_8\nf : β → γ\ng : γ → α\nt : Set β\n⊢ Eq (iSup fun c => iSup fun h => g c) (iSup fun b => iSup fun h => g (f b))","decl":"theorem iSup_image {γ} {f : β → γ} {g : γ → α} {t : Set β} :\n    ⨆ c ∈ f '' t, g c = ⨆ b ∈ t, g (f b) := by\n  rw [← sSup_image, ← sSup_image, ← image_comp, comp_def]\n\n"}
{"name":"iInf_image","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nγ : Type u_8\nf : β → γ\ng : γ → α\nt : Set β\n⊢ Eq (iInf fun c => iInf fun h => g c) (iInf fun b => iInf fun h => g (f b))","decl":"theorem iInf_image :\n    ∀ {γ} {f : β → γ} {g : γ → α} {t : Set β}, ⨅ c ∈ f '' t, g c = ⨅ b ∈ t, g (f b) :=\n  @iSup_image αᵒᵈ _ _\n\n"}
{"name":"iSup_extend_bot","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_4\ninst✝ : CompleteLattice α\ne : ι → β\nhe : Function.Injective e\nf : ι → α\n⊢ Eq (iSup fun j => Function.extend e f Bot.bot j) (iSup fun i => f i)","decl":"theorem iSup_extend_bot {e : ι → β} (he : Injective e) (f : ι → α) :\n    ⨆ j, extend e f ⊥ j = ⨆ i, f i := by\n  rw [iSup_split _ fun j => ∃ i, e i = j]\n  simp +contextual [he.extend_apply, extend_apply', @iSup_comm _ β ι]\n\n"}
{"name":"iInf_extend_top","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_4\ninst✝ : CompleteLattice α\ne : ι → β\nhe : Function.Injective e\nf : ι → α\n⊢ Eq (iInf fun j => Function.extend e f Top.top j) (iInf f)","decl":"theorem iInf_extend_top {e : ι → β} (he : Injective e) (f : ι → α) :\n    ⨅ j, extend e f ⊤ j = iInf f :=\n  @iSup_extend_bot αᵒᵈ _ _ _ _ he _\n\n"}
{"name":"iSup_of_empty'","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_8\nι : Sort u_9\ninst✝¹ : SupSet α\ninst✝ : IsEmpty ι\nf : ι → α\n⊢ Eq (iSup f) (SupSet.sSup EmptyCollection.emptyCollection)","decl":"theorem iSup_of_empty' {α ι} [SupSet α] [IsEmpty ι] (f : ι → α) : iSup f = sSup (∅ : Set α) :=\n  congr_arg sSup (range_eq_empty f)\n\n"}
{"name":"iInf_of_isEmpty","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_8\nι : Sort u_9\ninst✝¹ : InfSet α\ninst✝ : IsEmpty ι\nf : ι → α\n⊢ Eq (iInf f) (InfSet.sInf EmptyCollection.emptyCollection)","decl":"theorem iInf_of_isEmpty {α ι} [InfSet α] [IsEmpty ι] (f : ι → α) : iInf f = sInf (∅ : Set α) :=\n  congr_arg sInf (range_eq_empty f)\n\n"}
{"name":"iSup_of_empty","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝¹ : CompleteLattice α\ninst✝ : IsEmpty ι\nf : ι → α\n⊢ Eq (iSup f) Bot.bot","decl":"theorem iSup_of_empty [IsEmpty ι] (f : ι → α) : iSup f = ⊥ :=\n  (iSup_of_empty' f).trans sSup_empty\n\n"}
{"name":"iInf_of_empty","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝¹ : CompleteLattice α\ninst✝ : IsEmpty ι\nf : ι → α\n⊢ Eq (iInf f) Top.top","decl":"theorem iInf_of_empty [IsEmpty ι] (f : ι → α) : iInf f = ⊤ :=\n  @iSup_of_empty αᵒᵈ _ _ _ f\n\n"}
{"name":"iSup_bool_eq","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nf : Bool → α\n⊢ Eq (iSup fun b => f b) (Max.max (f Bool.true) (f Bool.false))","decl":"theorem iSup_bool_eq {f : Bool → α} : ⨆ b : Bool, f b = f true ⊔ f false := by\n  rw [iSup, Bool.range_eq, sSup_pair, sup_comm]\n\n"}
{"name":"iInf_bool_eq","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nf : Bool → α\n⊢ Eq (iInf fun b => f b) (Min.min (f Bool.true) (f Bool.false))","decl":"theorem iInf_bool_eq {f : Bool → α} : ⨅ b : Bool, f b = f true ⊓ f false :=\n  @iSup_bool_eq αᵒᵈ _ _\n\n"}
{"name":"sup_eq_iSup","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nx y : α\n⊢ Eq (Max.max x y) (iSup fun b => cond b x y)","decl":"theorem sup_eq_iSup (x y : α) : x ⊔ y = ⨆ b : Bool, cond b x y := by\n  rw [iSup_bool_eq, Bool.cond_true, Bool.cond_false]\n\n"}
{"name":"inf_eq_iInf","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nx y : α\n⊢ Eq (Min.min x y) (iInf fun b => cond b x y)","decl":"theorem inf_eq_iInf (x y : α) : x ⊓ y = ⨅ b : Bool, cond b x y :=\n  @sup_eq_iSup αᵒᵈ _ _ _\n\n"}
{"name":"isGLB_biInf","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\ns : Set β\nf : β → α\n⊢ IsGLB (Set.image f s) (iInf fun x => iInf fun h => f x)","decl":"theorem isGLB_biInf {s : Set β} {f : β → α} : IsGLB (f '' s) (⨅ x ∈ s, f x) := by\n  simpa only [range_comp, Subtype.range_coe, iInf_subtype'] using\n    @isGLB_iInf α s _ (f ∘ fun x => (x : β))\n\n"}
{"name":"isLUB_biSup","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\ns : Set β\nf : β → α\n⊢ IsLUB (Set.image f s) (iSup fun x => iSup fun h => f x)","decl":"theorem isLUB_biSup {s : Set β} {f : β → α} : IsLUB (f '' s) (⨆ x ∈ s, f x) := by\n  simpa only [range_comp, Subtype.range_coe, iSup_subtype'] using\n    @isLUB_iSup α s _ (f ∘ fun x => (x : β))\n\n"}
{"name":"iSup_sigma","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\np : β → Type u_8\nf : Sigma p → α\n⊢ Eq (iSup fun x => f x) (iSup fun i => iSup fun j => f ⟨i, j⟩)","decl":"theorem iSup_sigma {p : β → Type*} {f : Sigma p → α} : ⨆ x, f x = ⨆ (i) (j), f ⟨i, j⟩ :=\n  eq_of_forall_ge_iff fun c => by simp only [iSup_le_iff, Sigma.forall]\n\n"}
{"name":"iInf_sigma","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\np : β → Type u_8\nf : Sigma p → α\n⊢ Eq (iInf fun x => f x) (iInf fun i => iInf fun j => f ⟨i, j⟩)","decl":"theorem iInf_sigma {p : β → Type*} {f : Sigma p → α} : ⨅ x, f x = ⨅ (i) (j), f ⟨i, j⟩ :=\n  @iSup_sigma αᵒᵈ _ _ _ _\n\n"}
{"name":"iSup_sigma'","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nκ : β → Type u_8\nf : (i : β) → κ i → α\n⊢ Eq (iSup fun i => iSup fun j => f i j) (iSup fun x => f x.fst x.snd)","decl":"lemma iSup_sigma' {κ : β → Type*} (f : ∀ i, κ i → α) :\n    (⨆ i, ⨆ j, f i j) = ⨆ x : Σ i, κ i, f x.1 x.2 := (iSup_sigma (f := fun x ↦ f x.1 x.2)).symm\n\n"}
{"name":"iInf_sigma'","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nκ : β → Type u_8\nf : (i : β) → κ i → α\n⊢ Eq (iInf fun i => iInf fun j => f i j) (iInf fun x => f x.fst x.snd)","decl":"lemma iInf_sigma' {κ : β → Type*} (f : ∀ i, κ i → α) :\n    (⨅ i, ⨅ j, f i j) = ⨅ x : Σ i, κ i, f x.1 x.2 := (iInf_sigma (f := fun x ↦ f x.1 x.2)).symm\n\n"}
{"name":"iSup_psigma","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nι : Sort u_8\nκ : ι → Sort u_9\nf : (PSigma fun i => κ i) → α\n⊢ Eq (iSup fun ij => f ij) (iSup fun i => iSup fun j => f ⟨i, j⟩)","decl":"lemma iSup_psigma {ι : Sort*} {κ : ι → Sort*} (f : (Σ' i, κ i) → α) :\n    ⨆ ij, f ij = ⨆ i, ⨆ j, f ⟨i, j⟩ :=\n  eq_of_forall_ge_iff fun c ↦ by simp only [iSup_le_iff, PSigma.forall]\n\n"}
{"name":"iInf_psigma","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nι : Sort u_8\nκ : ι → Sort u_9\nf : (PSigma fun i => κ i) → α\n⊢ Eq (iInf fun ij => f ij) (iInf fun i => iInf fun j => f ⟨i, j⟩)","decl":"lemma iInf_psigma {ι : Sort*} {κ : ι → Sort*} (f : (Σ' i, κ i) → α) :\n    ⨅ ij, f ij = ⨅ i, ⨅ j, f ⟨i, j⟩ :=\n  eq_of_forall_le_iff fun c ↦ by simp only [le_iInf_iff, PSigma.forall]\n\n"}
{"name":"iSup_psigma'","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nι : Sort u_8\nκ : ι → Sort u_9\nf : (i : ι) → κ i → α\n⊢ Eq (iSup fun i => iSup fun j => f i j) (iSup fun ij => f ij.fst ij.snd)","decl":"lemma iSup_psigma' {ι : Sort*} {κ : ι → Sort*} (f : ∀ i, κ i → α) :\n    (⨆ i, ⨆ j, f i j) = ⨆ ij : Σ' i, κ i, f ij.1 ij.2 := (iSup_psigma fun x ↦ f x.1 x.2).symm\n\n"}
{"name":"iInf_psigma'","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nι : Sort u_8\nκ : ι → Sort u_9\nf : (i : ι) → κ i → α\n⊢ Eq (iInf fun i => iInf fun j => f i j) (iInf fun ij => f ij.fst ij.snd)","decl":"lemma iInf_psigma' {ι : Sort*} {κ : ι → Sort*} (f : ∀ i, κ i → α) :\n    (⨅ i, ⨅ j, f i j) = ⨅ ij : Σ' i, κ i, f ij.1 ij.2 := (iInf_psigma fun x ↦ f x.1 x.2).symm\n\n"}
{"name":"iSup_prod","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : CompleteLattice α\nf : Prod β γ → α\n⊢ Eq (iSup fun x => f x) (iSup fun i => iSup fun j => f { fst := i, snd := j })","decl":"theorem iSup_prod {f : β × γ → α} : ⨆ x, f x = ⨆ (i) (j), f (i, j) :=\n  eq_of_forall_ge_iff fun c => by simp only [iSup_le_iff, Prod.forall]\n\n"}
{"name":"iInf_prod","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : CompleteLattice α\nf : Prod β γ → α\n⊢ Eq (iInf fun x => f x) (iInf fun i => iInf fun j => f { fst := i, snd := j })","decl":"theorem iInf_prod {f : β × γ → α} : ⨅ x, f x = ⨅ (i) (j), f (i, j) :=\n  @iSup_prod αᵒᵈ _ _ _ _\n\n"}
{"name":"iSup_prod'","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : CompleteLattice α\nf : β → γ → α\n⊢ Eq (iSup fun i => iSup fun j => f i j) (iSup fun x => f x.1 x.2)","decl":"lemma iSup_prod' (f : β → γ → α) : (⨆ i, ⨆ j, f i j) = ⨆ x : β × γ, f x.1 x.2 :=\n(iSup_prod (f := fun x ↦ f x.1 x.2)).symm\n\n"}
{"name":"iInf_prod'","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : CompleteLattice α\nf : β → γ → α\n⊢ Eq (iInf fun i => iInf fun j => f i j) (iInf fun x => f x.1 x.2)","decl":"lemma iInf_prod' (f : β → γ → α) : (⨅ i, ⨅ j, f i j) = ⨅ x : β × γ, f x.1 x.2 :=\n(iInf_prod (f := fun x ↦ f x.1 x.2)).symm\n\n"}
{"name":"biSup_prod","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : CompleteLattice α\nf : Prod β γ → α\ns : Set β\nt : Set γ\n⊢ Eq (iSup fun x => iSup fun h => f x) (iSup fun a => iSup fun h => iSup fun b => iSup fun h => f { fst := a, snd := b })","decl":"theorem biSup_prod {f : β × γ → α} {s : Set β} {t : Set γ} :\n    ⨆ x ∈ s ×ˢ t, f x = ⨆ (a ∈ s) (b ∈ t), f (a, b) := by\n  simp_rw [iSup_prod, mem_prod, iSup_and]\n  exact iSup_congr fun _ => iSup_comm\n\n"}
{"name":"biInf_prod","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : CompleteLattice α\nf : Prod β γ → α\ns : Set β\nt : Set γ\n⊢ Eq (iInf fun x => iInf fun h => f x) (iInf fun a => iInf fun h => iInf fun b => iInf fun h => f { fst := a, snd := b })","decl":"theorem biInf_prod {f : β × γ → α} {s : Set β} {t : Set γ} :\n    ⨅ x ∈ s ×ˢ t, f x = ⨅ (a ∈ s) (b ∈ t), f (a, b) :=\n  @biSup_prod αᵒᵈ _ _ _ _ _ _\n\n"}
{"name":"iSup_image2","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nγ : Type u_8\nδ : Type u_9\nf : β → γ → δ\ns : Set β\nt : Set γ\ng : δ → α\n⊢ Eq (iSup fun d => iSup fun h => g d) (iSup fun b => iSup fun h => iSup fun c => iSup fun h => g (f b c))","decl":"theorem iSup_image2 {γ δ} (f : β → γ → δ) (s : Set β) (t : Set γ) (g : δ → α) :\n    ⨆ d ∈ image2 f s t, g d = ⨆ b ∈ s, ⨆ c ∈ t, g (f b c) := by\n  rw [← image_prod, iSup_image, biSup_prod]\n\n"}
{"name":"iInf_image2","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nγ : Type u_8\nδ : Type u_9\nf : β → γ → δ\ns : Set β\nt : Set γ\ng : δ → α\n⊢ Eq (iInf fun d => iInf fun h => g d) (iInf fun b => iInf fun h => iInf fun c => iInf fun h => g (f b c))","decl":"theorem iInf_image2 {γ δ} (f : β → γ → δ) (s : Set β) (t : Set γ) (g : δ → α) :\n    ⨅ d ∈ image2 f s t, g d = ⨅ b ∈ s, ⨅ c ∈ t, g (f b c) :=\n  iSup_image2 f s t (toDual ∘ g)\n\n"}
{"name":"iSup_sum","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : CompleteLattice α\nf : Sum β γ → α\n⊢ Eq (iSup fun x => f x) (Max.max (iSup fun i => f (Sum.inl i)) (iSup fun j => f (Sum.inr j)))","decl":"theorem iSup_sum {f : β ⊕ γ → α} : ⨆ x, f x = (⨆ i, f (Sum.inl i)) ⊔ ⨆ j, f (Sum.inr j) :=\n  eq_of_forall_ge_iff fun c => by simp only [sup_le_iff, iSup_le_iff, Sum.forall]\n\n"}
{"name":"iInf_sum","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : CompleteLattice α\nf : Sum β γ → α\n⊢ Eq (iInf fun x => f x) (Min.min (iInf fun i => f (Sum.inl i)) (iInf fun j => f (Sum.inr j)))","decl":"theorem iInf_sum {f : β ⊕ γ → α} : ⨅ x, f x = (⨅ i, f (Sum.inl i)) ⊓ ⨅ j, f (Sum.inr j) :=\n  @iSup_sum αᵒᵈ _ _ _ _\n\n"}
{"name":"iSup_option","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nf : Option β → α\n⊢ Eq (iSup fun o => f o) (Max.max (f Option.none) (iSup fun b => f (Option.some b)))","decl":"theorem iSup_option (f : Option β → α) : ⨆ o, f o = f none ⊔ ⨆ b, f (Option.some b) :=\n  eq_of_forall_ge_iff fun c => by simp only [iSup_le_iff, sup_le_iff, Option.forall]\n\n"}
{"name":"iInf_option","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nf : Option β → α\n⊢ Eq (iInf fun o => f o) (Min.min (f Option.none) (iInf fun b => f (Option.some b)))","decl":"theorem iInf_option (f : Option β → α) : ⨅ o, f o = f none ⊓ ⨅ b, f (Option.some b) :=\n  @iSup_option αᵒᵈ _ _ _\n\n"}
{"name":"iSup_option_elim","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\na : α\nf : β → α\n⊢ Eq (iSup fun o => o.elim a f) (Max.max a (iSup fun b => f b))","decl":"/-- A version of `iSup_option` useful for rewriting right-to-left. -/\ntheorem iSup_option_elim (a : α) (f : β → α) : ⨆ o : Option β, o.elim a f = a ⊔ ⨆ b, f b := by\n  simp [iSup_option]\n\n"}
{"name":"iInf_option_elim","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\na : α\nf : β → α\n⊢ Eq (iInf fun o => o.elim a f) (Min.min a (iInf fun b => f b))","decl":"/-- A version of `iInf_option` useful for rewriting right-to-left. -/\ntheorem iInf_option_elim (a : α) (f : β → α) : ⨅ o : Option β, o.elim a f = a ⊓ ⨅ b, f b :=\n  @iSup_option_elim αᵒᵈ _ _ _ _\n\n"}
{"name":"iSup_ne_bot_subtype","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : CompleteLattice α\nf : ι → α\n⊢ Eq (iSup fun i => f ↑i) (iSup fun i => f i)","decl":"/-- When taking the supremum of `f : ι → α`, the elements of `ι` on which `f` gives `⊥` can be\ndropped, without changing the result. -/\n@[simp]\ntheorem iSup_ne_bot_subtype (f : ι → α) : ⨆ i : { i // f i ≠ ⊥ }, f i = ⨆ i, f i := by\n  by_cases htriv : ∀ i, f i = ⊥\n  · simp only [iSup_bot, (funext htriv : f = _)]\n  refine (iSup_comp_le f _).antisymm (iSup_mono' fun i => ?_)\n  by_cases hi : f i = ⊥\n  · rw [hi]\n    obtain ⟨i₀, hi₀⟩ := not_forall.mp htriv\n    exact ⟨⟨i₀, hi₀⟩, bot_le⟩\n  · exact ⟨⟨i, hi⟩, rfl.le⟩\n\n"}
{"name":"iInf_ne_top_subtype","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : CompleteLattice α\nf : ι → α\n⊢ Eq (iInf fun i => f ↑i) (iInf fun i => f i)","decl":"/-- When taking the infimum of `f : ι → α`, the elements of `ι` on which `f` gives `⊤` can be\ndropped, without changing the result. -/\ntheorem iInf_ne_top_subtype (f : ι → α) : ⨅ i : { i // f i ≠ ⊤ }, f i = ⨅ i, f i :=\n  @iSup_ne_bot_subtype αᵒᵈ ι _ f\n\n"}
{"name":"sSup_image2","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : CompleteLattice α\nf : β → γ → α\ns : Set β\nt : Set γ\n⊢ Eq (SupSet.sSup (Set.image2 f s t)) (iSup fun a => iSup fun h => iSup fun b => iSup fun h => f a b)","decl":"theorem sSup_image2 {f : β → γ → α} {s : Set β} {t : Set γ} :\n    sSup (image2 f s t) = ⨆ (a ∈ s) (b ∈ t), f a b := by rw [← image_prod, sSup_image, biSup_prod]\n\n"}
{"name":"sInf_image2","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : CompleteLattice α\nf : β → γ → α\ns : Set β\nt : Set γ\n⊢ Eq (InfSet.sInf (Set.image2 f s t)) (iInf fun a => iInf fun h => iInf fun b => iInf fun h => f a b)","decl":"theorem sInf_image2 {f : β → γ → α} {s : Set β} {t : Set γ} :\n    sInf (image2 f s t) = ⨅ (a ∈ s) (b ∈ t), f a b := by rw [← image_prod, sInf_image, biInf_prod]\n\n"}
{"name":"iSup_ge_eq_iSup_nat_add","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nu : Nat → α\nn : Nat\n⊢ Eq (iSup fun i => iSup fun h => u i) (iSup fun i => u (HAdd.hAdd i n))","decl":"theorem iSup_ge_eq_iSup_nat_add (u : ℕ → α) (n : ℕ) : ⨆ i ≥ n, u i = ⨆ i, u (i + n) := by\n  apply le_antisymm <;> simp only [iSup_le_iff]\n  · refine fun i hi => le_sSup ⟨i - n, ?_⟩\n    dsimp only\n    rw [Nat.sub_add_cancel hi]\n  · exact fun i => le_sSup ⟨i + n, iSup_pos (Nat.le_add_left _ _)⟩\n\n"}
{"name":"iInf_ge_eq_iInf_nat_add","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nu : Nat → α\nn : Nat\n⊢ Eq (iInf fun i => iInf fun h => u i) (iInf fun i => u (HAdd.hAdd i n))","decl":"theorem iInf_ge_eq_iInf_nat_add (u : ℕ → α) (n : ℕ) : ⨅ i ≥ n, u i = ⨅ i, u (i + n) :=\n  @iSup_ge_eq_iSup_nat_add αᵒᵈ _ _ _\n\n"}
{"name":"Monotone.iSup_nat_add","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nf : Nat → α\nhf : Monotone f\nk : Nat\n⊢ Eq (iSup fun n => f (HAdd.hAdd n k)) (iSup fun n => f n)","decl":"theorem Monotone.iSup_nat_add {f : ℕ → α} (hf : Monotone f) (k : ℕ) : ⨆ n, f (n + k) = ⨆ n, f n :=\n  le_antisymm (iSup_le fun i => le_iSup _ (i + k)) <| iSup_mono fun i => hf <| Nat.le_add_right i k\n\n"}
{"name":"Antitone.iInf_nat_add","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nf : Nat → α\nhf : Antitone f\nk : Nat\n⊢ Eq (iInf fun n => f (HAdd.hAdd n k)) (iInf fun n => f n)","decl":"theorem Antitone.iInf_nat_add {f : ℕ → α} (hf : Antitone f) (k : ℕ) : ⨅ n, f (n + k) = ⨅ n, f n :=\n  hf.dual_right.iSup_nat_add k\n\n-- Porting note: the linter doesn't like this being marked as `@[simp]`,\n-- saying that it doesn't work when called on its LHS.\n-- Mysteriously, it *does* work. Nevertheless, per\n-- https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/complete_lattice.20and.20has_sup/near/316497982\n-- \"the subterm ?f (i + ?k) produces an ugly higher-order unification problem.\"\n-- @[simp]\n"}
{"name":"iSup_iInf_ge_nat_add","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nf : Nat → α\nk : Nat\n⊢ Eq (iSup fun n => iInf fun i => iInf fun h => f (HAdd.hAdd i k)) (iSup fun n => iInf fun i => iInf fun h => f i)","decl":"theorem iSup_iInf_ge_nat_add (f : ℕ → α) (k : ℕ) :\n    ⨆ n, ⨅ i ≥ n, f (i + k) = ⨆ n, ⨅ i ≥ n, f i := by\n  have hf : Monotone fun n => ⨅ i ≥ n, f i := fun n m h => biInf_mono fun i => h.trans\n  rw [← Monotone.iSup_nat_add hf k]\n  · simp_rw [iInf_ge_eq_iInf_nat_add, ← Nat.add_assoc]\n\n-- Porting note: removing `@[simp]`, see discussion on `iSup_iInf_ge_nat_add`.\n-- @[simp]\n"}
{"name":"iInf_iSup_ge_nat_add","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nf : Nat → α\nk : Nat\n⊢ Eq (iInf fun n => iSup fun i => iSup fun h => f (HAdd.hAdd i k)) (iInf fun n => iSup fun i => iSup fun h => f i)","decl":"theorem iInf_iSup_ge_nat_add :\n    ∀ (f : ℕ → α) (k : ℕ), ⨅ n, ⨆ i ≥ n, f (i + k) = ⨅ n, ⨆ i ≥ n, f i :=\n  @iSup_iInf_ge_nat_add αᵒᵈ _\n\n"}
{"name":"sup_iSup_nat_succ","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nu : Nat → α\n⊢ Eq (Max.max (u 0) (iSup fun i => u (HAdd.hAdd i 1))) (iSup fun i => u i)","decl":"theorem sup_iSup_nat_succ (u : ℕ → α) : (u 0 ⊔ ⨆ i, u (i + 1)) = ⨆ i, u i :=\n  calc\n    (u 0 ⊔ ⨆ i, u (i + 1)) = ⨆ x ∈ {0} ∪ range Nat.succ, u x := by\n      { rw [iSup_union, iSup_singleton, iSup_range] }\n    _ = ⨆ i, u i := by rw [Nat.zero_union_range_succ, iSup_univ]\n\n"}
{"name":"inf_iInf_nat_succ","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nu : Nat → α\n⊢ Eq (Min.min (u 0) (iInf fun i => u (HAdd.hAdd i 1))) (iInf fun i => u i)","decl":"theorem inf_iInf_nat_succ (u : ℕ → α) : (u 0 ⊓ ⨅ i, u (i + 1)) = ⨅ i, u i :=\n  @sup_iSup_nat_succ αᵒᵈ _ u\n\n"}
{"name":"iInf_nat_gt_zero_eq","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nf : Nat → α\n⊢ Eq (iInf fun i => iInf fun h => f i) (iInf fun i => f (HAdd.hAdd i 1))","decl":"theorem iInf_nat_gt_zero_eq (f : ℕ → α) : ⨅ i > 0, f i = ⨅ i, f (i + 1) := by\n  rw [← iInf_range, Nat.range_succ]\n  simp\n\n"}
{"name":"iSup_nat_gt_zero_eq","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nf : Nat → α\n⊢ Eq (iSup fun i => iSup fun h => f i) (iSup fun i => f (HAdd.hAdd i 1))","decl":"theorem iSup_nat_gt_zero_eq (f : ℕ → α) : ⨆ i > 0, f i = ⨆ i, f (i + 1) :=\n  @iInf_nat_gt_zero_eq αᵒᵈ _ f\n\n"}
{"name":"iSup_eq_top","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : CompleteLinearOrder α\nf : ι → α\n⊢ Iff (Eq (iSup f) Top.top) (∀ (b : α), LT.lt b Top.top → Exists fun i => LT.lt b (f i))","decl":"theorem iSup_eq_top (f : ι → α) : iSup f = ⊤ ↔ ∀ b < ⊤, ∃ i, b < f i := by\n  simp only [← sSup_range, sSup_eq_top, Set.exists_range_iff]\n\n"}
{"name":"iInf_eq_bot","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : CompleteLinearOrder α\nf : ι → α\n⊢ Iff (Eq (iInf f) Bot.bot) (∀ (b : α), GT.gt b Bot.bot → Exists fun i => LT.lt (f i) b)","decl":"theorem iInf_eq_bot (f : ι → α) : iInf f = ⊥ ↔ ∀ b > ⊥, ∃ i, f i < b := by\n  simp only [← sInf_range, sInf_eq_bot, Set.exists_range_iff]\n\n"}
{"name":"iSup₂_eq_top","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\nκ : ι → Sort u_6\ninst✝ : CompleteLinearOrder α\nf : (i : ι) → κ i → α\n⊢ Iff (Eq (iSup fun i => iSup fun j => f i j) Top.top) (∀ (b : α), LT.lt b Top.top → Exists fun i => Exists fun j => LT.lt b (f i j))","decl":"lemma iSup₂_eq_top (f : ∀ i, κ i → α) : ⨆ i, ⨆ j, f i j = ⊤ ↔ ∀ b < ⊤, ∃ i j, b < f i j := by\n  simp_rw [iSup_psigma', iSup_eq_top, PSigma.exists]\n\n"}
{"name":"iInf₂_eq_bot","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\nκ : ι → Sort u_6\ninst✝ : CompleteLinearOrder α\nf : (i : ι) → κ i → α\n⊢ Iff (Eq (iInf fun i => iInf fun j => f i j) Bot.bot) (∀ (b : α), GT.gt b Bot.bot → Exists fun i => Exists fun j => LT.lt (f i j) b)","decl":"lemma iInf₂_eq_bot (f : ∀ i, κ i → α) : ⨅ i, ⨅ j, f i j = ⊥ ↔ ∀ b > ⊥, ∃ i j, f i j < b := by\n  simp_rw [iInf_psigma', iInf_eq_bot, PSigma.exists]\n\n"}
{"name":"sSup_Prop_eq","module":"Mathlib.Order.CompleteLattice","initialProofState":"s : Set Prop\n⊢ Eq (SupSet.sSup s) (Exists fun p => And (Membership.mem s p) p)","decl":"@[simp]\ntheorem sSup_Prop_eq {s : Set Prop} : sSup s = ∃ p ∈ s, p :=\n  rfl\n\n"}
{"name":"sInf_Prop_eq","module":"Mathlib.Order.CompleteLattice","initialProofState":"s : Set Prop\n⊢ Eq (InfSet.sInf s) (∀ (p : Prop), Membership.mem s p → p)","decl":"@[simp]\ntheorem sInf_Prop_eq {s : Set Prop} : sInf s = ∀ p ∈ s, p :=\n  rfl\n\n"}
{"name":"iSup_Prop_eq","module":"Mathlib.Order.CompleteLattice","initialProofState":"ι : Sort u_4\np : ι → Prop\n⊢ Eq (iSup fun i => p i) (Exists fun i => p i)","decl":"@[simp]\ntheorem iSup_Prop_eq {p : ι → Prop} : ⨆ i, p i = ∃ i, p i :=\n  le_antisymm (fun ⟨_, ⟨i, (eq : p i = _)⟩, hq⟩ => ⟨i, eq.symm ▸ hq⟩) fun ⟨i, hi⟩ =>\n    ⟨p i, ⟨i, rfl⟩, hi⟩\n\n"}
{"name":"iInf_Prop_eq","module":"Mathlib.Order.CompleteLattice","initialProofState":"ι : Sort u_4\np : ι → Prop\n⊢ Eq (iInf fun i => p i) (∀ (i : ι), p i)","decl":"@[simp]\ntheorem iInf_Prop_eq {p : ι → Prop} : ⨅ i, p i = ∀ i, p i :=\n  le_antisymm (fun h i => h _ ⟨i, rfl⟩) fun h _ ⟨i, Eq⟩ => Eq ▸ h i\n\n"}
{"name":"sSup_apply","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_8\nβ : α → Type u_9\ninst✝ : (i : α) → SupSet (β i)\ns : Set ((a : α) → β a)\na : α\n⊢ Eq (SupSet.sSup s a) (iSup fun f => ↑f a)","decl":"@[simp]\ntheorem sSup_apply {α : Type*} {β : α → Type*} [∀ i, SupSet (β i)] {s : Set (∀ a, β a)} {a : α} :\n    (sSup s) a = ⨆ f : s, (f : ∀ a, β a) a :=\n  rfl\n\n"}
{"name":"sInf_apply","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_8\nβ : α → Type u_9\ninst✝ : (i : α) → InfSet (β i)\ns : Set ((a : α) → β a)\na : α\n⊢ Eq (InfSet.sInf s a) (iInf fun f => ↑f a)","decl":"@[simp]\ntheorem sInf_apply {α : Type*} {β : α → Type*} [∀ i, InfSet (β i)] {s : Set (∀ a, β a)} {a : α} :\n    sInf s a = ⨅ f : s, (f : ∀ a, β a) a :=\n  rfl\n\n"}
{"name":"iSup_apply","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_8\nβ : α → Type u_9\nι : Sort u_10\ninst✝ : (i : α) → SupSet (β i)\nf : ι → (a : α) → β a\na : α\n⊢ Eq (iSup (fun i => f i) a) (iSup fun i => f i a)","decl":"@[simp]\ntheorem iSup_apply {α : Type*} {β : α → Type*} {ι : Sort*} [∀ i, SupSet (β i)] {f : ι → ∀ a, β a}\n    {a : α} : (⨆ i, f i) a = ⨆ i, f i a := by\n  rw [iSup, sSup_apply, iSup, iSup, ← image_eq_range (fun f : ∀ i, β i => f a) (range f), ←\n    range_comp]; rfl\n\n"}
{"name":"iInf_apply","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_8\nβ : α → Type u_9\nι : Sort u_10\ninst✝ : (i : α) → InfSet (β i)\nf : ι → (a : α) → β a\na : α\n⊢ Eq (iInf (fun i => f i) a) (iInf fun i => f i a)","decl":"@[simp]\ntheorem iInf_apply {α : Type*} {β : α → Type*} {ι : Sort*} [∀ i, InfSet (β i)] {f : ι → ∀ a, β a}\n    {a : α} : (⨅ i, f i) a = ⨅ i, f i a :=\n  @iSup_apply α (fun i => (β i)ᵒᵈ) _ _ _ _\n\n"}
{"name":"unary_relation_sSup_iff","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_8\ns : Set (α → Prop)\na : α\n⊢ Iff (SupSet.sSup s a) (Exists fun r => And (Membership.mem s r) (r a))","decl":"theorem unary_relation_sSup_iff {α : Type*} (s : Set (α → Prop)) {a : α} :\n    sSup s a ↔ ∃ r : α → Prop, r ∈ s ∧ r a := by\n  rw [sSup_apply]\n  simp [← eq_iff_iff]\n\n"}
{"name":"unary_relation_sInf_iff","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_8\ns : Set (α → Prop)\na : α\n⊢ Iff (InfSet.sInf s a) (∀ (r : α → Prop), Membership.mem s r → r a)","decl":"theorem unary_relation_sInf_iff {α : Type*} (s : Set (α → Prop)) {a : α} :\n    sInf s a ↔ ∀ r : α → Prop, r ∈ s → r a := by\n  rw [sInf_apply]\n  simp [← eq_iff_iff]\n\n"}
{"name":"binary_relation_sSup_iff","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_8\nβ : Type u_9\ns : Set (α → β → Prop)\na : α\nb : β\n⊢ Iff (SupSet.sSup s a b) (Exists fun r => And (Membership.mem s r) (r a b))","decl":"theorem binary_relation_sSup_iff {α β : Type*} (s : Set (α → β → Prop)) {a : α} {b : β} :\n    sSup s a b ↔ ∃ r : α → β → Prop, r ∈ s ∧ r a b := by\n  rw [sSup_apply]\n  simp [← eq_iff_iff]\n\n"}
{"name":"binary_relation_sInf_iff","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_8\nβ : Type u_9\ns : Set (α → β → Prop)\na : α\nb : β\n⊢ Iff (InfSet.sInf s a b) (∀ (r : α → β → Prop), Membership.mem s r → r a b)","decl":"theorem binary_relation_sInf_iff {α β : Type*} (s : Set (α → β → Prop)) {a : α} {b : β} :\n    sInf s a b ↔ ∀ r : α → β → Prop, r ∈ s → r a b := by\n  rw [sInf_apply]\n  simp [← eq_iff_iff]\n\n"}
{"name":"Monotone.sSup","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : CompleteLattice β\ns : Set (α → β)\nhs : ∀ (f : α → β), Membership.mem s f → Monotone f\n⊢ Monotone (SupSet.sSup s)","decl":"protected lemma Monotone.sSup (hs : ∀ f ∈ s, Monotone f) : Monotone (sSup s) :=\n  fun _ _ h ↦ iSup_mono fun f ↦ hs f f.2 h\n\n"}
{"name":"Monotone.sInf","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : CompleteLattice β\ns : Set (α → β)\nhs : ∀ (f : α → β), Membership.mem s f → Monotone f\n⊢ Monotone (InfSet.sInf s)","decl":"protected lemma Monotone.sInf (hs : ∀ f ∈ s, Monotone f) : Monotone (sInf s) :=\n  fun _ _ h ↦ iInf_mono fun f ↦ hs f f.2 h\n\n"}
{"name":"Antitone.sSup","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : CompleteLattice β\ns : Set (α → β)\nhs : ∀ (f : α → β), Membership.mem s f → Antitone f\n⊢ Antitone (SupSet.sSup s)","decl":"protected lemma Antitone.sSup (hs : ∀ f ∈ s, Antitone f) : Antitone (sSup s) :=\n  fun _ _ h ↦ iSup_mono fun f ↦ hs f f.2 h\n\n"}
{"name":"Antitone.sInf","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : CompleteLattice β\ns : Set (α → β)\nhs : ∀ (f : α → β), Membership.mem s f → Antitone f\n⊢ Antitone (InfSet.sInf s)","decl":"protected lemma Antitone.sInf (hs : ∀ f ∈ s, Antitone f) : Antitone (sInf s) :=\n  fun _ _ h ↦ iInf_mono fun f ↦ hs f f.2 h\n\n"}
{"name":"Monotone.iSup","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_4\ninst✝¹ : Preorder α\ninst✝ : CompleteLattice β\nf : ι → α → β\nhf : ∀ (i : ι), Monotone (f i)\n⊢ Monotone (iSup fun i => f i)","decl":"protected lemma Monotone.iSup (hf : ∀ i, Monotone (f i)) : Monotone (⨆ i, f i) :=\n  Monotone.sSup (by simpa)\n"}
{"name":"Monotone.iInf","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_4\ninst✝¹ : Preorder α\ninst✝ : CompleteLattice β\nf : ι → α → β\nhf : ∀ (i : ι), Monotone (f i)\n⊢ Monotone (iInf fun i => f i)","decl":"protected lemma Monotone.iInf (hf : ∀ i, Monotone (f i)) : Monotone (⨅ i, f i) :=\n  Monotone.sInf (by simpa)\n"}
{"name":"Antitone.iSup","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_4\ninst✝¹ : Preorder α\ninst✝ : CompleteLattice β\nf : ι → α → β\nhf : ∀ (i : ι), Antitone (f i)\n⊢ Antitone (iSup fun i => f i)","decl":"protected lemma Antitone.iSup (hf : ∀ i, Antitone (f i)) : Antitone (⨆ i, f i) :=\n  Antitone.sSup (by simpa)\n"}
{"name":"Antitone.iInf","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_4\ninst✝¹ : Preorder α\ninst✝ : CompleteLattice β\nf : ι → α → β\nhf : ∀ (i : ι), Antitone (f i)\n⊢ Antitone (iInf fun i => f i)","decl":"protected lemma Antitone.iInf (hf : ∀ i, Antitone (f i)) : Antitone (⨅ i, f i) :=\n  Antitone.sInf (by simpa)\n\n"}
{"name":"Prod.fst_sInf","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : InfSet α\ninst✝ : InfSet β\ns : Set (Prod α β)\n⊢ Eq (InfSet.sInf s).1 (InfSet.sInf (Set.image Prod.fst s))","decl":"theorem fst_sInf [InfSet α] [InfSet β] (s : Set (α × β)) : (sInf s).fst = sInf (Prod.fst '' s) :=\n  rfl\n\n"}
{"name":"Prod.snd_sInf","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : InfSet α\ninst✝ : InfSet β\ns : Set (Prod α β)\n⊢ Eq (InfSet.sInf s).2 (InfSet.sInf (Set.image Prod.snd s))","decl":"theorem snd_sInf [InfSet α] [InfSet β] (s : Set (α × β)) : (sInf s).snd = sInf (Prod.snd '' s) :=\n  rfl\n\n"}
{"name":"Prod.swap_sInf","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : InfSet α\ninst✝ : InfSet β\ns : Set (Prod α β)\n⊢ Eq (InfSet.sInf s).swap (InfSet.sInf (Set.image Prod.swap s))","decl":"theorem swap_sInf [InfSet α] [InfSet β] (s : Set (α × β)) : (sInf s).swap = sInf (Prod.swap '' s) :=\n  Prod.ext (congr_arg sInf <| image_comp Prod.fst swap s)\n    (congr_arg sInf <| image_comp Prod.snd swap s)\n\n"}
{"name":"Prod.fst_sSup","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : SupSet α\ninst✝ : SupSet β\ns : Set (Prod α β)\n⊢ Eq (SupSet.sSup s).1 (SupSet.sSup (Set.image Prod.fst s))","decl":"theorem fst_sSup [SupSet α] [SupSet β] (s : Set (α × β)) : (sSup s).fst = sSup (Prod.fst '' s) :=\n  rfl\n\n"}
{"name":"Prod.snd_sSup","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : SupSet α\ninst✝ : SupSet β\ns : Set (Prod α β)\n⊢ Eq (SupSet.sSup s).2 (SupSet.sSup (Set.image Prod.snd s))","decl":"theorem snd_sSup [SupSet α] [SupSet β] (s : Set (α × β)) : (sSup s).snd = sSup (Prod.snd '' s) :=\n  rfl\n\n"}
{"name":"Prod.swap_sSup","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : SupSet α\ninst✝ : SupSet β\ns : Set (Prod α β)\n⊢ Eq (SupSet.sSup s).swap (SupSet.sSup (Set.image Prod.swap s))","decl":"theorem swap_sSup [SupSet α] [SupSet β] (s : Set (α × β)) : (sSup s).swap = sSup (Prod.swap '' s) :=\n  Prod.ext (congr_arg sSup <| image_comp Prod.fst swap s)\n    (congr_arg sSup <| image_comp Prod.snd swap s)\n\n"}
{"name":"Prod.fst_iInf","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_4\ninst✝¹ : InfSet α\ninst✝ : InfSet β\nf : ι → Prod α β\n⊢ Eq (iInf f).1 (iInf fun i => (f i).1)","decl":"theorem fst_iInf [InfSet α] [InfSet β] (f : ι → α × β) : (iInf f).fst = ⨅ i, (f i).fst :=\n  congr_arg sInf (range_comp _ _).symm\n\n"}
{"name":"Prod.snd_iInf","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_4\ninst✝¹ : InfSet α\ninst✝ : InfSet β\nf : ι → Prod α β\n⊢ Eq (iInf f).2 (iInf fun i => (f i).2)","decl":"theorem snd_iInf [InfSet α] [InfSet β] (f : ι → α × β) : (iInf f).snd = ⨅ i, (f i).snd :=\n  congr_arg sInf (range_comp _ _).symm\n\n"}
{"name":"Prod.swap_iInf","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_4\ninst✝¹ : InfSet α\ninst✝ : InfSet β\nf : ι → Prod α β\n⊢ Eq (iInf f).swap (iInf fun i => (f i).swap)","decl":"theorem swap_iInf [InfSet α] [InfSet β] (f : ι → α × β) : (iInf f).swap = ⨅ i, (f i).swap := by\n  simp_rw [iInf, swap_sInf, ← range_comp, comp_def]  -- Porting note: need to unfold `∘`\n\n"}
{"name":"Prod.iInf_mk","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_4\ninst✝¹ : InfSet α\ninst✝ : InfSet β\nf : ι → α\ng : ι → β\n⊢ Eq (iInf fun i => { fst := f i, snd := g i }) { fst := iInf fun i => f i, snd := iInf fun i => g i }","decl":"theorem iInf_mk [InfSet α] [InfSet β] (f : ι → α) (g : ι → β) :\n    ⨅ i, (f i, g i) = (⨅ i, f i, ⨅ i, g i) :=\n  congr_arg₂ Prod.mk (fst_iInf _) (snd_iInf _)\n\n"}
{"name":"Prod.fst_iSup","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_4\ninst✝¹ : SupSet α\ninst✝ : SupSet β\nf : ι → Prod α β\n⊢ Eq (iSup f).1 (iSup fun i => (f i).1)","decl":"theorem fst_iSup [SupSet α] [SupSet β] (f : ι → α × β) : (iSup f).fst = ⨆ i, (f i).fst :=\n  congr_arg sSup (range_comp _ _).symm\n\n"}
{"name":"Prod.snd_iSup","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_4\ninst✝¹ : SupSet α\ninst✝ : SupSet β\nf : ι → Prod α β\n⊢ Eq (iSup f).2 (iSup fun i => (f i).2)","decl":"theorem snd_iSup [SupSet α] [SupSet β] (f : ι → α × β) : (iSup f).snd = ⨆ i, (f i).snd :=\n  congr_arg sSup (range_comp _ _).symm\n\n"}
{"name":"Prod.swap_iSup","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_4\ninst✝¹ : SupSet α\ninst✝ : SupSet β\nf : ι → Prod α β\n⊢ Eq (iSup f).swap (iSup fun i => (f i).swap)","decl":"theorem swap_iSup [SupSet α] [SupSet β] (f : ι → α × β) : (iSup f).swap = ⨆ i, (f i).swap := by\n  simp_rw [iSup, swap_sSup, ← range_comp, comp_def]  -- Porting note: need to unfold `∘`\n\n"}
{"name":"Prod.iSup_mk","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_4\ninst✝¹ : SupSet α\ninst✝ : SupSet β\nf : ι → α\ng : ι → β\n⊢ Eq (iSup fun i => { fst := f i, snd := g i }) { fst := iSup fun i => f i, snd := iSup fun i => g i }","decl":"theorem iSup_mk [SupSet α] [SupSet β] (f : ι → α) (g : ι → β) :\n    ⨆ i, (f i, g i) = (⨆ i, f i, ⨆ i, g i) :=\n  congr_arg₂ Prod.mk (fst_iSup _) (snd_iSup _)\n\n"}
{"name":"sInf_prod","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : InfSet α\ninst✝ : InfSet β\ns : Set α\nt : Set β\nhs : s.Nonempty\nht : t.Nonempty\n⊢ Eq (InfSet.sInf (SProd.sprod s t)) { fst := InfSet.sInf s, snd := InfSet.sInf t }","decl":"lemma sInf_prod [InfSet α] [InfSet β] {s : Set α} {t : Set β} (hs : s.Nonempty) (ht : t.Nonempty) :\n    sInf (s ×ˢ t) = (sInf s, sInf t) :=\ncongr_arg₂ Prod.mk (congr_arg sInf <| fst_image_prod _ ht) (congr_arg sInf <| snd_image_prod hs _)\n\n"}
{"name":"sSup_prod","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : SupSet α\ninst✝ : SupSet β\ns : Set α\nt : Set β\nhs : s.Nonempty\nht : t.Nonempty\n⊢ Eq (SupSet.sSup (SProd.sprod s t)) { fst := SupSet.sSup s, snd := SupSet.sSup t }","decl":"lemma sSup_prod [SupSet α] [SupSet β] {s : Set α} {t : Set β} (hs : s.Nonempty) (ht : t.Nonempty) :\n    sSup (s ×ˢ t) = (sSup s, sSup t) :=\ncongr_arg₂ Prod.mk (congr_arg sSup <| fst_image_prod _ ht) (congr_arg sSup <| snd_image_prod hs _)\n\n"}
{"name":"sup_sInf_le_iInf_sup","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\na : α\ns : Set α\n⊢ LE.le (Max.max a (InfSet.sInf s)) (iInf fun b => iInf fun h => Max.max a b)","decl":"/-- This is a weaker version of `sup_sInf_eq` -/\ntheorem sup_sInf_le_iInf_sup : a ⊔ sInf s ≤ ⨅ b ∈ s, a ⊔ b :=\n  le_iInf₂ fun _ h => sup_le_sup_left (sInf_le h) _\n\n"}
{"name":"iSup_inf_le_inf_sSup","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\na : α\ns : Set α\n⊢ LE.le (iSup fun b => iSup fun h => Min.min a b) (Min.min a (SupSet.sSup s))","decl":"/-- This is a weaker version of `inf_sSup_eq` -/\ntheorem iSup_inf_le_inf_sSup : ⨆ b ∈ s, a ⊓ b ≤ a ⊓ sSup s :=\n  @sup_sInf_le_iInf_sup αᵒᵈ _ _ _\n\n"}
{"name":"sInf_sup_le_iInf_sup","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\na : α\ns : Set α\n⊢ LE.le (Max.max (InfSet.sInf s) a) (iInf fun b => iInf fun h => Max.max b a)","decl":"/-- This is a weaker version of `sInf_sup_eq` -/\ntheorem sInf_sup_le_iInf_sup : sInf s ⊔ a ≤ ⨅ b ∈ s, b ⊔ a :=\n  le_iInf₂ fun _ h => sup_le_sup_right (sInf_le h) _\n\n"}
{"name":"iSup_inf_le_sSup_inf","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\na : α\ns : Set α\n⊢ LE.le (iSup fun b => iSup fun h => Min.min b a) (Min.min (SupSet.sSup s) a)","decl":"/-- This is a weaker version of `sSup_inf_eq` -/\ntheorem iSup_inf_le_sSup_inf : ⨆ b ∈ s, b ⊓ a ≤ sSup s ⊓ a :=\n  @sInf_sup_le_iInf_sup αᵒᵈ _ _ _\n\n"}
{"name":"le_iSup_inf_iSup","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : CompleteLattice α\nf g : ι → α\n⊢ LE.le (iSup fun i => Min.min (f i) (g i)) (Min.min (iSup fun i => f i) (iSup fun i => g i))","decl":"theorem le_iSup_inf_iSup (f g : ι → α) : ⨆ i, f i ⊓ g i ≤ (⨆ i, f i) ⊓ ⨆ i, g i :=\n  le_inf (iSup_mono fun _ => inf_le_left) (iSup_mono fun _ => inf_le_right)\n\n"}
{"name":"iInf_sup_iInf_le","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : CompleteLattice α\nf g : ι → α\n⊢ LE.le (Max.max (iInf fun i => f i) (iInf fun i => g i)) (iInf fun i => Max.max (f i) (g i))","decl":"theorem iInf_sup_iInf_le (f g : ι → α) : (⨅ i, f i) ⊔ ⨅ i, g i ≤ ⨅ i, f i ⊔ g i :=\n  @le_iSup_inf_iSup αᵒᵈ ι _ f g\n\n"}
{"name":"disjoint_sSup_left","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\na : Set α\nb : α\nd : Disjoint (SupSet.sSup a) b\ni : α\nhi : Membership.mem a i\n⊢ Disjoint i b","decl":"theorem disjoint_sSup_left {a : Set α} {b : α} (d : Disjoint (sSup a) b) {i} (hi : i ∈ a) :\n    Disjoint i b :=\n  disjoint_iff_inf_le.mpr (iSup₂_le_iff.1 (iSup_inf_le_sSup_inf.trans d.le_bot) i hi :)\n\n"}
{"name":"disjoint_sSup_right","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\na : Set α\nb : α\nd : Disjoint b (SupSet.sSup a)\ni : α\nhi : Membership.mem a i\n⊢ Disjoint b i","decl":"theorem disjoint_sSup_right {a : Set α} {b : α} (d : Disjoint b (sSup a)) {i} (hi : i ∈ a) :\n    Disjoint b i :=\n  disjoint_iff_inf_le.mpr (iSup₂_le_iff.mp (iSup_inf_le_inf_sSup.trans d.le_bot) i hi :)\n\n"}
{"name":"disjoint_of_sSup_disjoint_of_le_of_le","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\na b : α\nc d : Set α\nhs : ∀ (e : α), Membership.mem c e → LE.le e a\nht : ∀ (e : α), Membership.mem d e → LE.le e b\nhd : Disjoint a b\nhe : Or (Not (Membership.mem c Bot.bot)) (Not (Membership.mem d Bot.bot))\n⊢ Disjoint c d","decl":"lemma disjoint_of_sSup_disjoint_of_le_of_le {a b : α} {c d : Set α} (hs : ∀ e ∈ c, e ≤ a)\n    (ht : ∀ e ∈ d, e ≤ b) (hd : Disjoint a b) (he : ⊥ ∉ c ∨ ⊥ ∉ d) : Disjoint c d := by\n  rw [disjoint_iff_forall_ne]\n  intros x hx y hy\n  rw [Disjoint.ne_iff]\n  · aesop\n  · exact Disjoint.mono (hs x hx) (ht y hy) hd\n\n"}
{"name":"disjoint_of_sSup_disjoint","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\na b : Set α\nhd : Disjoint (SupSet.sSup a) (SupSet.sSup b)\nhe : Or (Not (Membership.mem a Bot.bot)) (Not (Membership.mem b Bot.bot))\n⊢ Disjoint a b","decl":"lemma disjoint_of_sSup_disjoint {a b : Set α} (hd : Disjoint (sSup a) (sSup b))\n    (he : ⊥ ∉ a ∨ ⊥ ∉ b) : Disjoint a b :=\n  disjoint_of_sSup_disjoint_of_le_of_le (fun _ hc ↦ le_sSup hc) (fun _ hc ↦ le_sSup hc) hd he\n\n"}
{"name":"ULift.down_sSup","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : SupSet α\ns : Set (ULift.{v, u_1} α)\n⊢ Eq (SupSet.sSup s).down (SupSet.sSup (Set.preimage ULift.up s))","decl":"theorem down_sSup [SupSet α] (s : Set (ULift.{v} α)) : (sSup s).down = sSup (ULift.up ⁻¹' s) := rfl\n"}
{"name":"ULift.up_sSup","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : SupSet α\ns : Set α\n⊢ Eq { down := SupSet.sSup s } (SupSet.sSup (Set.preimage ULift.down s))","decl":"theorem up_sSup [SupSet α] (s : Set α) : up (sSup s) = sSup (ULift.down ⁻¹' s) := rfl\n\n"}
{"name":"ULift.down_sInf","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : InfSet α\ns : Set (ULift.{v, u_1} α)\n⊢ Eq (InfSet.sInf s).down (InfSet.sInf (Set.preimage ULift.up s))","decl":"theorem down_sInf [InfSet α] (s : Set (ULift.{v} α)) : (sInf s).down = sInf (ULift.up ⁻¹' s) := rfl\n"}
{"name":"ULift.up_sInf","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\ninst✝ : InfSet α\ns : Set α\n⊢ Eq { down := InfSet.sInf s } (InfSet.sInf (Set.preimage ULift.down s))","decl":"theorem up_sInf [InfSet α] (s : Set α) : up (sInf s) = sInf (ULift.down ⁻¹' s) := rfl\n\n"}
{"name":"ULift.down_iSup","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : SupSet α\nf : ι → ULift.{v, u_1} α\n⊢ Eq (iSup fun i => f i).down (iSup fun i => (f i).down)","decl":"theorem down_iSup [SupSet α] (f : ι → ULift.{v} α) : (⨆ i, f i).down = ⨆ i, (f i).down :=\n  congr_arg sSup <| (preimage_eq_iff_eq_image ULift.up_bijective).mpr <|\n    Eq.symm (range_comp _ _).symm\n"}
{"name":"ULift.up_iSup","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : SupSet α\nf : ι → α\n⊢ Eq { down := iSup fun i => f i } (iSup fun i => { down := f i })","decl":"theorem up_iSup [SupSet α] (f : ι → α) : up (⨆ i, f i) = ⨆ i, up (f i) :=\n  congr_arg ULift.up <| (down_iSup _).symm\n\n"}
{"name":"ULift.down_iInf","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : InfSet α\nf : ι → ULift.{v, u_1} α\n⊢ Eq (iInf fun i => f i).down (iInf fun i => (f i).down)","decl":"theorem down_iInf [InfSet α] (f : ι → ULift.{v} α) : (⨅ i, f i).down = ⨅ i, (f i).down :=\n  congr_arg sInf <| (preimage_eq_iff_eq_image ULift.up_bijective).mpr <|\n    Eq.symm (range_comp _ _).symm\n"}
{"name":"ULift.up_iInf","module":"Mathlib.Order.CompleteLattice","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : InfSet α\nf : ι → α\n⊢ Eq { down := iInf fun i => f i } (iInf fun i => { down := f i })","decl":"theorem up_iInf [InfSet α] (f : ι → α) : up (⨅ i, f i) = ⨅ i, up (f i) :=\n  congr_arg ULift.up <| (down_iInf _).symm\n\n"}
