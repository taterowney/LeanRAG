{"name":"Ultrafilter.finite_sUnion_mem_iff","module":"Mathlib.Order.Filter.Ultrafilter.Basic","initialProofState":"α : Type u\nf : Ultrafilter α\ns : Set (Set α)\nhs : s.Finite\n⊢ Iff (Membership.mem f s.sUnion) (Exists fun t => And (Membership.mem s t) (Membership.mem f t))","decl":"theorem finite_sUnion_mem_iff {s : Set (Set α)} (hs : s.Finite) : ⋃₀ s ∈ f ↔ ∃ t ∈ s, t ∈ f :=\n  Finite.induction_on _ hs (by simp) fun _ _ his => by\n    simp [union_mem_iff, his, or_and_right, exists_or]\n\n"}
{"name":"Ultrafilter.finite_biUnion_mem_iff","module":"Mathlib.Order.Filter.Ultrafilter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : Ultrafilter α\nis : Set β\ns : β → Set α\nhis : is.Finite\n⊢ Iff (Membership.mem f (Set.iUnion fun i => Set.iUnion fun h => s i)) (Exists fun i => And (Membership.mem is i) (Membership.mem f (s i)))","decl":"theorem finite_biUnion_mem_iff {is : Set β} {s : β → Set α} (his : is.Finite) :\n    (⋃ i ∈ is, s i) ∈ f ↔ ∃ i ∈ is, s i ∈ f := by\n  simp only [← sUnion_image, finite_sUnion_mem_iff (his.image s), exists_mem_image]\n\n"}
{"name":"Ultrafilter.eventually_exists_mem_iff","module":"Mathlib.Order.Filter.Ultrafilter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : Ultrafilter α\nis : Set β\nP : β → α → Prop\nhis : is.Finite\n⊢ Iff (Filter.Eventually (fun i => Exists fun a => And (Membership.mem is a) (P a i)) ↑f) (Exists fun a => And (Membership.mem is a) (Filter.Eventually (fun i => P a i) ↑f))","decl":"lemma eventually_exists_mem_iff {is : Set β} {P : β → α → Prop} (his : is.Finite) :\n    (∀ᶠ i in f, ∃ a ∈ is, P a i) ↔ ∃ a ∈ is, ∀ᶠ i in f, P a i := by\n  simp only [Filter.Eventually, Ultrafilter.mem_coe]\n  convert f.finite_biUnion_mem_iff his (s := P) with i\n  aesop\n\n"}
{"name":"Ultrafilter.eventually_exists_iff","module":"Mathlib.Order.Filter.Ultrafilter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : Ultrafilter α\ninst✝ : Finite β\nP : β → α → Prop\n⊢ Iff (Filter.Eventually (fun i => Exists fun a => P a i) ↑f) (Exists fun a => Filter.Eventually (fun i => P a i) ↑f)","decl":"lemma eventually_exists_iff [Finite β] {P : β → α → Prop} :\n    (∀ᶠ i in f, ∃ a, P a i) ↔ ∃ a, ∀ᶠ i in f, P a i := by\n  simpa using eventually_exists_mem_iff (f := f) (P := P) Set.finite_univ\n\n"}
{"name":"Ultrafilter.eq_pure_of_finite_mem","module":"Mathlib.Order.Filter.Ultrafilter.Basic","initialProofState":"α : Type u\nf : Ultrafilter α\ns : Set α\nh : s.Finite\nh' : Membership.mem f s\n⊢ Exists fun x => And (Membership.mem s x) (Eq f (Pure.pure x))","decl":"theorem eq_pure_of_finite_mem (h : s.Finite) (h' : s ∈ f) : ∃ x ∈ s, f = pure x := by\n  rw [← biUnion_of_singleton s] at h'\n  rcases (Ultrafilter.finite_biUnion_mem_iff h).mp h' with ⟨a, has, haf⟩\n  exact ⟨a, has, eq_of_le (Filter.le_pure_iff.2 haf)⟩\n\n"}
{"name":"Ultrafilter.eq_pure_of_finite","module":"Mathlib.Order.Filter.Ultrafilter.Basic","initialProofState":"α : Type u\ninst✝ : Finite α\nf : Ultrafilter α\n⊢ Exists fun a => Eq f (Pure.pure a)","decl":"theorem eq_pure_of_finite [Finite α] (f : Ultrafilter α) : ∃ a, f = pure a :=\n  (eq_pure_of_finite_mem finite_univ univ_mem).imp fun _ ⟨_, ha⟩ => ha\n\n"}
{"name":"Ultrafilter.le_cofinite_or_eq_pure","module":"Mathlib.Order.Filter.Ultrafilter.Basic","initialProofState":"α : Type u\nf : Ultrafilter α\n⊢ Or (LE.le (↑f) Filter.cofinite) (Exists fun a => Eq f (Pure.pure a))","decl":"theorem le_cofinite_or_eq_pure (f : Ultrafilter α) : (f : Filter α) ≤ cofinite ∨ ∃ a, f = pure a :=\n  or_iff_not_imp_left.2 fun h =>\n    let ⟨_, hs, hfin⟩ := Filter.disjoint_cofinite_right.1 (disjoint_iff_not_le.2 h)\n    let ⟨a, _, hf⟩ := eq_pure_of_finite_mem hfin hs\n    ⟨a, hf⟩\n\n"}
{"name":"Ultrafilter.exists_ultrafilter_of_finite_inter_nonempty","module":"Mathlib.Order.Filter.Ultrafilter.Basic","initialProofState":"α : Type u\nS : Set (Set α)\ncond : ∀ (T : Finset (Set α)), HasSubset.Subset (↑T) S → (↑T).sInter.Nonempty\n⊢ Exists fun F => HasSubset.Subset S (↑F).sets","decl":"theorem exists_ultrafilter_of_finite_inter_nonempty (S : Set (Set α))\n    (cond : ∀ T : Finset (Set α), (↑T : Set (Set α)) ⊆ S → (⋂₀ (↑T : Set (Set α))).Nonempty) :\n    ∃ F : Ultrafilter α, S ⊆ F.sets :=\n  haveI : NeBot (generate S) :=\n    generate_neBot_iff.2 fun _ hts ht =>\n      ht.coe_toFinset ▸ cond ht.toFinset (ht.coe_toFinset.symm ▸ hts)\n  ⟨of (generate S), fun _ ht => (of_le <| generate S) <| GenerateSets.basic ht⟩\n\n"}
{"name":"Filter.atTop_eq_pure_of_isTop","module":"Mathlib.Order.Filter.Ultrafilter.Basic","initialProofState":"α : Type u\ninst✝ : LinearOrder α\nx : α\nhx : IsTop x\n⊢ Eq Filter.atTop (Pure.pure x)","decl":"lemma atTop_eq_pure_of_isTop [LinearOrder α] {x : α} (hx : IsTop x) :\n    (atTop : Filter α) = pure x := by\n  have : Nonempty α := ⟨x⟩\n  apply atTop_neBot.eq_pure_iff.2\n  convert Ici_mem_atTop x using 1\n  exact (Ici_eq_singleton_iff_isTop.2 hx).symm\n\n"}
{"name":"Filter.atBot_eq_pure_of_isBot","module":"Mathlib.Order.Filter.Ultrafilter.Basic","initialProofState":"α : Type u\ninst✝ : LinearOrder α\nx : α\nhx : IsBot x\n⊢ Eq Filter.atBot (Pure.pure x)","decl":"lemma atBot_eq_pure_of_isBot [LinearOrder α] {x : α} (hx : IsBot x) :\n    (atBot : Filter α) = pure x :=\n  @atTop_eq_pure_of_isTop αᵒᵈ _ _ hx\n\n"}
{"name":"Filter.tendsto_iff_ultrafilter","module":"Mathlib.Order.Filter.Ultrafilter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nl₁ : Filter α\nl₂ : Filter β\n⊢ Iff (Filter.Tendsto f l₁ l₂) (∀ (g : Ultrafilter α), LE.le (↑g) l₁ → Filter.Tendsto f (↑g) l₂)","decl":"/-- The `tendsto` relation can be checked on ultrafilters. -/\ntheorem tendsto_iff_ultrafilter (f : α → β) (l₁ : Filter α) (l₂ : Filter β) :\n    Tendsto f l₁ l₂ ↔ ∀ g : Ultrafilter α, ↑g ≤ l₁ → Tendsto f g l₂ := by\n  simpa only [tendsto_iff_comap] using le_iff_ultrafilter\n\n"}
{"name":"Filter.hyperfilter_le_cofinite","module":"Mathlib.Order.Filter.Ultrafilter.Basic","initialProofState":"α : Type u\ninst✝ : Infinite α\n⊢ LE.le (↑(Filter.hyperfilter α)) Filter.cofinite","decl":"theorem hyperfilter_le_cofinite : ↑(hyperfilter α) ≤ @cofinite α :=\n  Ultrafilter.of_le cofinite\n\n"}
{"name":"Nat.hyperfilter_le_atTop","module":"Mathlib.Order.Filter.Ultrafilter.Basic","initialProofState":"⊢ LE.le (↑(Filter.hyperfilter Nat)) Filter.atTop","decl":"theorem _root_.Nat.hyperfilter_le_atTop : (hyperfilter ℕ).toFilter ≤ atTop :=\n  hyperfilter_le_cofinite.trans_eq Nat.cofinite_eq_atTop\n\n"}
{"name":"Filter.bot_ne_hyperfilter","module":"Mathlib.Order.Filter.Ultrafilter.Basic","initialProofState":"α : Type u\ninst✝ : Infinite α\n⊢ Ne Bot.bot ↑(Filter.hyperfilter α)","decl":"@[simp]\ntheorem bot_ne_hyperfilter : (⊥ : Filter α) ≠ hyperfilter α :=\n  (NeBot.ne inferInstance).symm\n\n"}
{"name":"Filter.nmem_hyperfilter_of_finite","module":"Mathlib.Order.Filter.Ultrafilter.Basic","initialProofState":"α : Type u\ninst✝ : Infinite α\ns : Set α\nhf : s.Finite\n⊢ Not (Membership.mem (Filter.hyperfilter α) s)","decl":"theorem nmem_hyperfilter_of_finite {s : Set α} (hf : s.Finite) : s ∉ hyperfilter α := fun hy =>\n  compl_not_mem hy <| hyperfilter_le_cofinite hf.compl_mem_cofinite\n\n"}
{"name":"Set.Finite.nmem_hyperfilter","module":"Mathlib.Order.Filter.Ultrafilter.Basic","initialProofState":"α : Type u\ninst✝ : Infinite α\ns : Set α\nhf : s.Finite\n⊢ Not (Membership.mem (Filter.hyperfilter α) s)","decl":"alias _root_.Set.Finite.nmem_hyperfilter := nmem_hyperfilter_of_finite\n\n"}
{"name":"Filter.compl_mem_hyperfilter_of_finite","module":"Mathlib.Order.Filter.Ultrafilter.Basic","initialProofState":"α : Type u\ninst✝ : Infinite α\ns : Set α\nhf : s.Finite\n⊢ Membership.mem (Filter.hyperfilter α) (HasCompl.compl s)","decl":"theorem compl_mem_hyperfilter_of_finite {s : Set α} (hf : Set.Finite s) : sᶜ ∈ hyperfilter α :=\n  compl_mem_iff_not_mem.2 hf.nmem_hyperfilter\n\n"}
{"name":"Set.Finite.compl_mem_hyperfilter","module":"Mathlib.Order.Filter.Ultrafilter.Basic","initialProofState":"α : Type u\ninst✝ : Infinite α\ns : Set α\nhf : s.Finite\n⊢ Membership.mem (Filter.hyperfilter α) (HasCompl.compl s)","decl":"alias _root_.Set.Finite.compl_mem_hyperfilter := compl_mem_hyperfilter_of_finite\n\n"}
{"name":"Filter.mem_hyperfilter_of_finite_compl","module":"Mathlib.Order.Filter.Ultrafilter.Basic","initialProofState":"α : Type u\ninst✝ : Infinite α\ns : Set α\nhf : (HasCompl.compl s).Finite\n⊢ Membership.mem (Filter.hyperfilter α) s","decl":"theorem mem_hyperfilter_of_finite_compl {s : Set α} (hf : Set.Finite sᶜ) : s ∈ hyperfilter α :=\n  compl_compl s ▸ hf.compl_mem_hyperfilter\n\n"}
