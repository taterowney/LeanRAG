{"name":"Projectivization.orthogonal_mk","module":"Mathlib.LinearAlgebra.Projectivization.Constructions","initialProofState":"F : Type u_1\ninst✝¹ : Field F\nm : Type u_2\ninst✝ : Fintype m\nv w : m → F\nhv : Ne v 0\nhw : Ne w 0\n⊢ Iff ((Projectivization.mk F v hv).orthogonal (Projectivization.mk F w hw)) (Eq (dotProduct v w) 0)","decl":"lemma orthogonal_mk {v w : m → F} (hv : v ≠ 0) (hw : w ≠ 0) :\n    orthogonal (mk F v hv) (mk F w hw) ↔ dotProduct v w = 0 :=\n  Iff.rfl\n\n"}
{"name":"Projectivization.orthogonal_comm","module":"Mathlib.LinearAlgebra.Projectivization.Constructions","initialProofState":"F : Type u_1\ninst✝¹ : Field F\nm : Type u_2\ninst✝ : Fintype m\nv w : Projectivization F (m → F)\n⊢ Iff (v.orthogonal w) (w.orthogonal v)","decl":"lemma orthogonal_comm {v w : ℙ F (m → F)} : orthogonal v w ↔ orthogonal w v := by\n  induction' v with v hv\n  induction' w with w hw\n  rw [orthogonal_mk hv hw, orthogonal_mk hw hv, dotProduct_comm]\n\n"}
{"name":"Projectivization.exists_not_self_orthogonal","module":"Mathlib.LinearAlgebra.Projectivization.Constructions","initialProofState":"F : Type u_1\ninst✝¹ : Field F\nm : Type u_2\ninst✝ : Fintype m\nv : Projectivization F (m → F)\n⊢ Exists fun w => Not (v.orthogonal w)","decl":"lemma exists_not_self_orthogonal (v : ℙ F (m → F)) : ∃ w, ¬ orthogonal v w := by\n  induction' v with v hv\n  rw [ne_eq, ← dotProduct_eq_zero_iff, not_forall] at hv\n  obtain ⟨w, hw⟩ := hv\n  exact ⟨mk F w fun h ↦ hw (by rw [h, dotProduct_zero]), hw⟩\n\n"}
{"name":"Projectivization.exists_not_orthogonal_self","module":"Mathlib.LinearAlgebra.Projectivization.Constructions","initialProofState":"F : Type u_1\ninst✝¹ : Field F\nm : Type u_2\ninst✝ : Fintype m\nv : Projectivization F (m → F)\n⊢ Exists fun w => Not (w.orthogonal v)","decl":"lemma exists_not_orthogonal_self (v : ℙ F (m → F)) : ∃ w, ¬ orthogonal w v := by\n  simp only [orthogonal_comm]\n  exact exists_not_self_orthogonal v\n\n"}
{"name":"Projectivization.mk_eq_mk_iff_crossProduct_eq_zero","module":"Mathlib.LinearAlgebra.Projectivization.Constructions","initialProofState":"F : Type u_1\ninst✝ : Field F\nv w : Fin 3 → F\nhv : Ne v 0\nhw : Ne w 0\n⊢ Iff (Eq (Projectivization.mk F v hv) (Projectivization.mk F w hw)) (Eq ((crossProduct v) w) 0)","decl":"lemma mk_eq_mk_iff_crossProduct_eq_zero {v w : Fin 3 → F} (hv : v ≠ 0) (hw : w ≠ 0) :\n    mk F v hv = mk F w hw ↔ crossProduct v w = 0 := by\n  rw [← not_iff_not, mk_eq_mk_iff', not_exists, ← LinearIndependent.pair_iff' hw,\n    ← crossProduct_ne_zero_iff_linearIndependent, ← cross_anticomm, neg_ne_zero]\n\n"}
{"name":"Projectivization.cross_mk","module":"Mathlib.LinearAlgebra.Projectivization.Constructions","initialProofState":"F : Type u_1\ninst✝¹ : Field F\ninst✝ : DecidableEq F\nv w : Fin 3 → F\nhv : Ne v 0\nhw : Ne w 0\n⊢ Eq ((Projectivization.mk F v hv).cross (Projectivization.mk F w hw)) (dite (Eq ((crossProduct v) w) 0) (fun h => Projectivization.mk F v hv) fun h => Projectivization.mk F ((crossProduct v) w) h)","decl":"lemma cross_mk {v w : Fin 3 → F} (hv : v ≠ 0) (hw : w ≠ 0) :\n    cross (mk F v hv) (mk F w hw) =\n      if h : crossProduct v w = 0 then mk F v hv else mk F (crossProduct v w) h := by\n  change Quotient.mk'' _ = _\n  split_ifs with h <;> simp only [h] <;> rfl\n\n"}
{"name":"Projectivization.cross_mk_of_cross_eq_zero","module":"Mathlib.LinearAlgebra.Projectivization.Constructions","initialProofState":"F : Type u_1\ninst✝¹ : Field F\ninst✝ : DecidableEq F\nv w : Fin 3 → F\nhv : Ne v 0\nhw : Ne w 0\nh : Eq ((crossProduct v) w) 0\n⊢ Eq ((Projectivization.mk F v hv).cross (Projectivization.mk F w hw)) (Projectivization.mk F v hv)","decl":"lemma cross_mk_of_cross_eq_zero {v w : Fin 3 → F} (hv : v ≠ 0) (hw : w ≠ 0)\n    (h : crossProduct v w = 0) :\n    cross (mk F v hv) (mk F w hw) = mk F v hv := by\n  rw [cross_mk, dif_pos h]\n\n"}
{"name":"Projectivization.cross_mk_of_cross_ne_zero","module":"Mathlib.LinearAlgebra.Projectivization.Constructions","initialProofState":"F : Type u_1\ninst✝¹ : Field F\ninst✝ : DecidableEq F\nv w : Fin 3 → F\nhv : Ne v 0\nhw : Ne w 0\nh : Ne ((crossProduct v) w) 0\n⊢ Eq ((Projectivization.mk F v hv).cross (Projectivization.mk F w hw)) (Projectivization.mk F ((crossProduct v) w) h)","decl":"lemma cross_mk_of_cross_ne_zero {v w : Fin 3 → F} (hv : v ≠ 0) (hw : w ≠ 0)\n    (h : crossProduct v w ≠ 0) :\n    cross (mk F v hv) (mk F w hw) = mk F (crossProduct v w) h := by\n  rw [cross_mk, dif_neg h]\n\n"}
{"name":"Projectivization.cross_self","module":"Mathlib.LinearAlgebra.Projectivization.Constructions","initialProofState":"F : Type u_1\ninst✝¹ : Field F\ninst✝ : DecidableEq F\nv : Projectivization F (Fin 3 → F)\n⊢ Eq (v.cross v) v","decl":"lemma cross_self (v : ℙ F (Fin 3 → F)) : cross v v = v := by\n  induction' v with v hv\n  rw [cross_mk_of_cross_eq_zero]\n  rw [← mk_eq_mk_iff_crossProduct_eq_zero hv]\n\n"}
{"name":"Projectivization.cross_mk_of_ne","module":"Mathlib.LinearAlgebra.Projectivization.Constructions","initialProofState":"F : Type u_1\ninst✝¹ : Field F\ninst✝ : DecidableEq F\nv w : Fin 3 → F\nhv : Ne v 0\nhw : Ne w 0\nh : Ne (Projectivization.mk F v hv) (Projectivization.mk F w hw)\n⊢ Eq ((Projectivization.mk F v hv).cross (Projectivization.mk F w hw)) (Projectivization.mk F ((crossProduct v) w) ⋯)","decl":"lemma cross_mk_of_ne {v w : Fin 3 → F} (hv : v ≠ 0) (hw : w ≠ 0) (h : mk F v hv ≠ mk F w hw) :\n    cross (mk F v hv) (mk F w hw) = mk F (crossProduct v w)\n      (mt (mk_eq_mk_iff_crossProduct_eq_zero hv hw).mpr h) := by\n  rw [cross_mk_of_cross_ne_zero]\n\n"}
{"name":"Projectivization.cross_comm","module":"Mathlib.LinearAlgebra.Projectivization.Constructions","initialProofState":"F : Type u_1\ninst✝¹ : Field F\ninst✝ : DecidableEq F\nv w : Projectivization F (Fin 3 → F)\n⊢ Eq (v.cross w) (w.cross v)","decl":"lemma cross_comm (v w : ℙ F (Fin 3 → F)) : cross v w = cross w v := by\n  rcases eq_or_ne v w with rfl | h\n  · rfl\n  · induction' v with v hv\n    induction' w with w hw\n    rw [cross_mk_of_ne hv hw h, cross_mk_of_ne hw hv h.symm, mk_eq_mk_iff_crossProduct_eq_zero,\n      ← cross_anticomm v w, map_neg, _root_.cross_self, neg_zero]\n\n"}
{"name":"Projectivization.cross_orthogonal_left","module":"Mathlib.LinearAlgebra.Projectivization.Constructions","initialProofState":"F : Type u_1\ninst✝¹ : Field F\ninst✝ : DecidableEq F\nv w : Projectivization F (Fin 3 → F)\nh : Ne v w\n⊢ (v.cross w).orthogonal v","decl":"theorem cross_orthogonal_left {v w : ℙ F (Fin 3 → F)} (h : v ≠ w) :\n    (cross v w).orthogonal v := by\n  induction' v with v hv\n  induction' w with w hw\n  rw [cross_mk_of_ne hv hw h, orthogonal_mk, dotProduct_comm, dot_self_cross]\n\n"}
{"name":"Projectivization.cross_orthogonal_right","module":"Mathlib.LinearAlgebra.Projectivization.Constructions","initialProofState":"F : Type u_1\ninst✝¹ : Field F\ninst✝ : DecidableEq F\nv w : Projectivization F (Fin 3 → F)\nh : Ne v w\n⊢ (v.cross w).orthogonal w","decl":"theorem cross_orthogonal_right {v w : ℙ F (Fin 3 → F)} (h : v ≠ w) :\n    (cross v w).orthogonal w := by\n  rw [cross_comm]\n  exact cross_orthogonal_left h.symm\n\n"}
{"name":"Projectivization.orthogonal_cross_left","module":"Mathlib.LinearAlgebra.Projectivization.Constructions","initialProofState":"F : Type u_1\ninst✝¹ : Field F\ninst✝ : DecidableEq F\nv w : Projectivization F (Fin 3 → F)\nh : Ne v w\n⊢ v.orthogonal (v.cross w)","decl":"theorem orthogonal_cross_left {v w : ℙ F (Fin 3 → F)} (h : v ≠ w) :\n    v.orthogonal (cross v w) := by\n  rw [orthogonal_comm]\n  exact cross_orthogonal_left h\n\n"}
{"name":"Projectivization.orthogonal_cross_right","module":"Mathlib.LinearAlgebra.Projectivization.Constructions","initialProofState":"F : Type u_1\ninst✝¹ : Field F\ninst✝ : DecidableEq F\nv w : Projectivization F (Fin 3 → F)\nh : Ne v w\n⊢ w.orthogonal (v.cross w)","decl":"lemma orthogonal_cross_right {v w : ℙ F (Fin 3 → F)} (h : v ≠ w) :\n    w.orthogonal (cross v w) := by\n  rw [orthogonal_comm]\n  exact cross_orthogonal_right h\n\n"}
