{"name":"TotalComplexShape.rel₂","module":"Mathlib.Algebra.Homology.ComplexShapeSigns","initialProofState":"I₁ : Type u_1\nI₂ : Type u_2\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nc₁₂ : ComplexShape I₁₂\nself : TotalComplexShape c₁ c₂ c₁₂\ni₁ : I₁\ni₂ i₂' : I₂\nh : c₂.Rel i₂ i₂'\n⊢ c₁₂.Rel (TotalComplexShape.π c₁ c₂ c₁₂ { fst := i₁, snd := i₂ }) (TotalComplexShape.π c₁ c₂ c₁₂ { fst := i₁, snd := i₂' })","decl":"/-- A total complex shape for three complexes shapes `c₁`, `c₂`, `c₁₂` on three types\n`I₁`, `I₂` and `I₁₂` consists of the data and properties that will allow the construction\nof a total complex functor `HomologicalComplex₂ C c₁ c₂ ⥤ HomologicalComplex C c₁₂` which\nsends `K` to a complex which in degree `i₁₂ : I₁₂` consists of the coproduct\nof the `(K.X i₁).X i₂` such that `π ⟨i₁, i₂⟩ = i₁₂`. -/\nclass TotalComplexShape where\n  /-- a map on indices -/\n  π : I₁ × I₂ → I₁₂\n  /-- the sign of the horizontal differential in the total complex -/\n  ε₁ : I₁ × I₂ → ℤˣ\n  /-- the sign of the vertical differential in the total complex -/\n  ε₂ : I₁ × I₂ → ℤˣ\n  rel₁ {i₁ i₁' : I₁} (h : c₁.Rel i₁ i₁') (i₂ : I₂) : c₁₂.Rel (π ⟨i₁, i₂⟩) (π ⟨i₁', i₂⟩)\n  rel₂ (i₁ : I₁) {i₂ i₂' : I₂} (h : c₂.Rel i₂ i₂') : c₁₂.Rel (π ⟨i₁, i₂⟩) (π ⟨i₁, i₂'⟩)\n  ε₂_ε₁ {i₁ i₁' : I₁} {i₂ i₂' : I₂} (h₁ : c₁.Rel i₁ i₁') (h₂ : c₂.Rel i₂ i₂') :\n    ε₂ ⟨i₁, i₂⟩ * ε₁ ⟨i₁, i₂'⟩ = - ε₁ ⟨i₁, i₂⟩ * ε₂ ⟨i₁', i₂⟩\n\n"}
{"name":"TotalComplexShape.rel₁","module":"Mathlib.Algebra.Homology.ComplexShapeSigns","initialProofState":"I₁ : Type u_1\nI₂ : Type u_2\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nc₁₂ : ComplexShape I₁₂\nself : TotalComplexShape c₁ c₂ c₁₂\ni₁ i₁' : I₁\nh : c₁.Rel i₁ i₁'\ni₂ : I₂\n⊢ c₁₂.Rel (TotalComplexShape.π c₁ c₂ c₁₂ { fst := i₁, snd := i₂ }) (TotalComplexShape.π c₁ c₂ c₁₂ { fst := i₁', snd := i₂ })","decl":"/-- A total complex shape for three complexes shapes `c₁`, `c₂`, `c₁₂` on three types\n`I₁`, `I₂` and `I₁₂` consists of the data and properties that will allow the construction\nof a total complex functor `HomologicalComplex₂ C c₁ c₂ ⥤ HomologicalComplex C c₁₂` which\nsends `K` to a complex which in degree `i₁₂ : I₁₂` consists of the coproduct\nof the `(K.X i₁).X i₂` such that `π ⟨i₁, i₂⟩ = i₁₂`. -/\nclass TotalComplexShape where\n  /-- a map on indices -/\n  π : I₁ × I₂ → I₁₂\n  /-- the sign of the horizontal differential in the total complex -/\n  ε₁ : I₁ × I₂ → ℤˣ\n  /-- the sign of the vertical differential in the total complex -/\n  ε₂ : I₁ × I₂ → ℤˣ\n  rel₁ {i₁ i₁' : I₁} (h : c₁.Rel i₁ i₁') (i₂ : I₂) : c₁₂.Rel (π ⟨i₁, i₂⟩) (π ⟨i₁', i₂⟩)\n  rel₂ (i₁ : I₁) {i₂ i₂' : I₂} (h : c₂.Rel i₂ i₂') : c₁₂.Rel (π ⟨i₁, i₂⟩) (π ⟨i₁, i₂'⟩)\n  ε₂_ε₁ {i₁ i₁' : I₁} {i₂ i₂' : I₂} (h₁ : c₁.Rel i₁ i₁') (h₂ : c₂.Rel i₂ i₂') :\n    ε₂ ⟨i₁, i₂⟩ * ε₁ ⟨i₁, i₂'⟩ = - ε₁ ⟨i₁, i₂⟩ * ε₂ ⟨i₁', i₂⟩\n\n"}
{"name":"TotalComplexShape.ε₂_ε₁","module":"Mathlib.Algebra.Homology.ComplexShapeSigns","initialProofState":"I₁ : Type u_1\nI₂ : Type u_2\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nc₁₂ : ComplexShape I₁₂\nself : TotalComplexShape c₁ c₂ c₁₂\ni₁ i₁' : I₁\ni₂ i₂' : I₂\nh₁ : c₁.Rel i₁ i₁'\nh₂ : c₂.Rel i₂ i₂'\n⊢ Eq (HMul.hMul (TotalComplexShape.ε₂ c₁ c₂ c₁₂ { fst := i₁, snd := i₂ }) (TotalComplexShape.ε₁ c₁ c₂ c₁₂ { fst := i₁, snd := i₂' })) (HMul.hMul (Neg.neg (TotalComplexShape.ε₁ c₁ c₂ c₁₂ { fst := i₁, snd := i₂ })) (TotalComplexShape.ε₂ c₁ c₂ c₁₂ { fst := i₁', snd := i₂ }))","decl":"/-- A total complex shape for three complexes shapes `c₁`, `c₂`, `c₁₂` on three types\n`I₁`, `I₂` and `I₁₂` consists of the data and properties that will allow the construction\nof a total complex functor `HomologicalComplex₂ C c₁ c₂ ⥤ HomologicalComplex C c₁₂` which\nsends `K` to a complex which in degree `i₁₂ : I₁₂` consists of the coproduct\nof the `(K.X i₁).X i₂` such that `π ⟨i₁, i₂⟩ = i₁₂`. -/\nclass TotalComplexShape where\n  /-- a map on indices -/\n  π : I₁ × I₂ → I₁₂\n  /-- the sign of the horizontal differential in the total complex -/\n  ε₁ : I₁ × I₂ → ℤˣ\n  /-- the sign of the vertical differential in the total complex -/\n  ε₂ : I₁ × I₂ → ℤˣ\n  rel₁ {i₁ i₁' : I₁} (h : c₁.Rel i₁ i₁') (i₂ : I₂) : c₁₂.Rel (π ⟨i₁, i₂⟩) (π ⟨i₁', i₂⟩)\n  rel₂ (i₁ : I₁) {i₂ i₂' : I₂} (h : c₂.Rel i₂ i₂') : c₁₂.Rel (π ⟨i₁, i₂⟩) (π ⟨i₁, i₂'⟩)\n  ε₂_ε₁ {i₁ i₁' : I₁} {i₂ i₂' : I₂} (h₁ : c₁.Rel i₁ i₁') (h₂ : c₂.Rel i₂ i₂') :\n    ε₂ ⟨i₁, i₂⟩ * ε₁ ⟨i₁, i₂'⟩ = - ε₁ ⟨i₁, i₂⟩ * ε₂ ⟨i₁', i₂⟩\n\n"}
{"name":"ComplexShape.rel_π₁","module":"Mathlib.Algebra.Homology.ComplexShapeSigns","initialProofState":"I₁ : Type u_1\nI₂ : Type u_2\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nc₁₂ : ComplexShape I₁₂\ninst✝ : TotalComplexShape c₁ c₂ c₁₂\ni₁ i₁' : I₁\nh : c₁.Rel i₁ i₁'\ni₂ : I₂\n⊢ c₁₂.Rel (c₁.π c₂ c₁₂ { fst := i₁, snd := i₂ }) (c₁.π c₂ c₁₂ { fst := i₁', snd := i₂ })","decl":"lemma rel_π₁ {i₁ i₁' : I₁} (h : c₁.Rel i₁ i₁') (i₂ : I₂) :\n    c₁₂.Rel (π c₁ c₂ c₁₂ ⟨i₁, i₂⟩) (π c₁ c₂ c₁₂ ⟨i₁', i₂⟩) :=\n  TotalComplexShape.rel₁ h i₂\n\n"}
{"name":"ComplexShape.next_π₁","module":"Mathlib.Algebra.Homology.ComplexShapeSigns","initialProofState":"I₁ : Type u_1\nI₂ : Type u_2\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nc₁₂ : ComplexShape I₁₂\ninst✝ : TotalComplexShape c₁ c₂ c₁₂\ni₁ i₁' : I₁\nh : c₁.Rel i₁ i₁'\ni₂ : I₂\n⊢ Eq (c₁₂.next (c₁.π c₂ c₁₂ { fst := i₁, snd := i₂ })) (c₁.π c₂ c₁₂ { fst := i₁', snd := i₂ })","decl":"lemma next_π₁ {i₁ i₁' : I₁} (h : c₁.Rel i₁ i₁') (i₂ : I₂) :\n    c₁₂.next (π c₁ c₂ c₁₂ ⟨i₁, i₂⟩) = π c₁ c₂ c₁₂ ⟨i₁', i₂⟩ :=\n  c₁₂.next_eq' (rel_π₁ c₂ c₁₂ h i₂)\n\n"}
{"name":"ComplexShape.prev_π₁","module":"Mathlib.Algebra.Homology.ComplexShapeSigns","initialProofState":"I₁ : Type u_1\nI₂ : Type u_2\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nc₁₂ : ComplexShape I₁₂\ninst✝ : TotalComplexShape c₁ c₂ c₁₂\ni₁ i₁' : I₁\nh : c₁.Rel i₁ i₁'\ni₂ : I₂\n⊢ Eq (c₁₂.prev (c₁.π c₂ c₁₂ { fst := i₁', snd := i₂ })) (c₁.π c₂ c₁₂ { fst := i₁, snd := i₂ })","decl":"lemma prev_π₁ {i₁ i₁' : I₁} (h : c₁.Rel i₁ i₁') (i₂ : I₂) :\n    c₁₂.prev (π c₁ c₂ c₁₂ ⟨i₁', i₂⟩) = π c₁ c₂ c₁₂ ⟨i₁, i₂⟩ :=\n  c₁₂.prev_eq' (rel_π₁ c₂ c₁₂ h i₂)\n\n"}
{"name":"ComplexShape.rel_π₂","module":"Mathlib.Algebra.Homology.ComplexShapeSigns","initialProofState":"I₁ : Type u_1\nI₂ : Type u_2\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nc₁₂ : ComplexShape I₁₂\ninst✝ : TotalComplexShape c₁ c₂ c₁₂\ni₁ : I₁\ni₂ i₂' : I₂\nh : c₂.Rel i₂ i₂'\n⊢ c₁₂.Rel (c₁.π c₂ c₁₂ { fst := i₁, snd := i₂ }) (c₁.π c₂ c₁₂ { fst := i₁, snd := i₂' })","decl":"lemma rel_π₂ (i₁ : I₁) {i₂ i₂' : I₂} (h : c₂.Rel i₂ i₂') :\n    c₁₂.Rel (π c₁ c₂ c₁₂ ⟨i₁, i₂⟩) (π c₁ c₂ c₁₂ ⟨i₁, i₂'⟩) :=\n  TotalComplexShape.rel₂ i₁ h\n\n"}
{"name":"ComplexShape.next_π₂","module":"Mathlib.Algebra.Homology.ComplexShapeSigns","initialProofState":"I₁ : Type u_1\nI₂ : Type u_2\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nc₁₂ : ComplexShape I₁₂\ninst✝ : TotalComplexShape c₁ c₂ c₁₂\ni₁ : I₁\ni₂ i₂' : I₂\nh : c₂.Rel i₂ i₂'\n⊢ Eq (c₁₂.next (c₁.π c₂ c₁₂ { fst := i₁, snd := i₂ })) (c₁.π c₂ c₁₂ { fst := i₁, snd := i₂' })","decl":"lemma next_π₂ (i₁ : I₁) {i₂ i₂' : I₂} (h : c₂.Rel i₂ i₂') :\n    c₁₂.next (π c₁ c₂ c₁₂ ⟨i₁, i₂⟩) = π c₁ c₂ c₁₂ ⟨i₁, i₂'⟩ :=\n  c₁₂.next_eq' (rel_π₂ c₁ c₁₂ i₁ h)\n\n"}
{"name":"ComplexShape.prev_π₂","module":"Mathlib.Algebra.Homology.ComplexShapeSigns","initialProofState":"I₁ : Type u_1\nI₂ : Type u_2\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nc₁₂ : ComplexShape I₁₂\ninst✝ : TotalComplexShape c₁ c₂ c₁₂\ni₁ : I₁\ni₂ i₂' : I₂\nh : c₂.Rel i₂ i₂'\n⊢ Eq (c₁₂.prev (c₁.π c₂ c₁₂ { fst := i₁, snd := i₂' })) (c₁.π c₂ c₁₂ { fst := i₁, snd := i₂ })","decl":"lemma prev_π₂ (i₁ : I₁) {i₂ i₂' : I₂} (h : c₂.Rel i₂ i₂') :\n    c₁₂.prev (π c₁ c₂ c₁₂ ⟨i₁, i₂'⟩) = π c₁ c₂ c₁₂ ⟨i₁, i₂⟩ :=\n  c₁₂.prev_eq' (rel_π₂ c₁ c₁₂ i₁ h)\n\n"}
{"name":"ComplexShape.ε₂_ε₁","module":"Mathlib.Algebra.Homology.ComplexShapeSigns","initialProofState":"I₁ : Type u_1\nI₂ : Type u_2\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nc₁₂ : ComplexShape I₁₂\ninst✝ : TotalComplexShape c₁ c₂ c₁₂\ni₁ i₁' : I₁\ni₂ i₂' : I₂\nh₁ : c₁.Rel i₁ i₁'\nh₂ : c₂.Rel i₂ i₂'\n⊢ Eq (HMul.hMul (c₁.ε₂ c₂ c₁₂ { fst := i₁, snd := i₂ }) (c₁.ε₁ c₂ c₁₂ { fst := i₁, snd := i₂' })) (HMul.hMul (Neg.neg (c₁.ε₁ c₂ c₁₂ { fst := i₁, snd := i₂ })) (c₁.ε₂ c₂ c₁₂ { fst := i₁', snd := i₂ }))","decl":"lemma ε₂_ε₁ {i₁ i₁' : I₁} {i₂ i₂' : I₂} (h₁ : c₁.Rel i₁ i₁') (h₂ : c₂.Rel i₂ i₂') :\n    ε₂ c₁ c₂ c₁₂ ⟨i₁, i₂⟩ * ε₁ c₁ c₂ c₁₂ ⟨i₁, i₂'⟩ =\n      - ε₁ c₁ c₂ c₁₂ ⟨i₁, i₂⟩ * ε₂ c₁ c₂ c₁₂ ⟨i₁', i₂⟩ :=\n  TotalComplexShape.ε₂_ε₁ h₁ h₂\n\n"}
{"name":"ComplexShape.ε₁_ε₂","module":"Mathlib.Algebra.Homology.ComplexShapeSigns","initialProofState":"I₁ : Type u_1\nI₂ : Type u_2\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nc₁₂ : ComplexShape I₁₂\ninst✝ : TotalComplexShape c₁ c₂ c₁₂\ni₁ i₁' : I₁\ni₂ i₂' : I₂\nh₁ : c₁.Rel i₁ i₁'\nh₂ : c₂.Rel i₂ i₂'\n⊢ Eq (HMul.hMul (c₁.ε₁ c₂ c₁₂ { fst := i₁, snd := i₂ }) (c₁.ε₂ c₂ c₁₂ { fst := i₁, snd := i₂ })) (HMul.hMul (Neg.neg (c₁.ε₂ c₂ c₁₂ { fst := i₁', snd := i₂ })) (c₁.ε₁ c₂ c₁₂ { fst := i₁, snd := i₂' }))","decl":"lemma ε₁_ε₂ {i₁ i₁' : I₁} {i₂ i₂' : I₂} (h₁ : c₁.Rel i₁ i₁') (h₂ : c₂.Rel i₂ i₂') :\n    ε₁ c₁ c₂ c₁₂ ⟨i₁, i₂⟩ * ε₂ c₁ c₂ c₁₂ ⟨i₁, i₂⟩ =\n      - ε₂ c₁ c₂ c₁₂ ⟨i₁', i₂⟩ * ε₁ c₁ c₂ c₁₂ ⟨i₁, i₂'⟩ :=\n  Eq.trans (mul_one _).symm (by\n    rw [← Int.units_mul_self (ComplexShape.ε₁ c₁ c₂ c₁₂ (i₁, i₂')), mul_assoc]\n    conv_lhs =>\n      arg 2\n      rw [← mul_assoc, ε₂_ε₁ c₁₂ h₁ h₂]\n    rw [neg_mul, neg_mul, neg_mul, mul_neg, neg_inj, ← mul_assoc, ← mul_assoc,\n      Int.units_mul_self, one_mul])\n\n"}
{"name":"ComplexShape.TensorSigns.rel_add","module":"Mathlib.Algebra.Homology.ComplexShapeSigns","initialProofState":"I : Type u_7\ninst✝ : AddMonoid I\nc : ComplexShape I\nself : c.TensorSigns\np q r : I\nhpq : c.Rel p q\n⊢ c.Rel (HAdd.hAdd p r) (HAdd.hAdd q r)","decl":"/-- If `I` is an additive monoid and `c : ComplexShape I`, `c.TensorSigns` contains the data of\nmap `ε : I → ℤˣ` and properties which allows the construction of a `TotalComplexShape c c c`. -/\nclass TensorSigns where\n  /-- the signs which appear in the vertical differential of the total complex -/\n  ε' : Multiplicative I →* ℤˣ\n  rel_add (p q r : I) (hpq : c.Rel p q) : c.Rel (p + r) (q + r)\n  add_rel (p q r : I) (hpq : c.Rel p q) : c.Rel (r + p) (r + q)\n  ε'_succ (p q : I) (hpq : c.Rel p q) : ε' q = - ε' p\n\n"}
{"name":"ComplexShape.TensorSigns.ε'_succ","module":"Mathlib.Algebra.Homology.ComplexShapeSigns","initialProofState":"I : Type u_7\ninst✝ : AddMonoid I\nc : ComplexShape I\nself : c.TensorSigns\np q : I\nhpq : c.Rel p q\n⊢ Eq ((ComplexShape.TensorSigns.ε' c) q) (Neg.neg ((ComplexShape.TensorSigns.ε' c) p))","decl":"/-- If `I` is an additive monoid and `c : ComplexShape I`, `c.TensorSigns` contains the data of\nmap `ε : I → ℤˣ` and properties which allows the construction of a `TotalComplexShape c c c`. -/\nclass TensorSigns where\n  /-- the signs which appear in the vertical differential of the total complex -/\n  ε' : Multiplicative I →* ℤˣ\n  rel_add (p q r : I) (hpq : c.Rel p q) : c.Rel (p + r) (q + r)\n  add_rel (p q r : I) (hpq : c.Rel p q) : c.Rel (r + p) (r + q)\n  ε'_succ (p q : I) (hpq : c.Rel p q) : ε' q = - ε' p\n\n"}
{"name":"ComplexShape.TensorSigns.add_rel","module":"Mathlib.Algebra.Homology.ComplexShapeSigns","initialProofState":"I : Type u_7\ninst✝ : AddMonoid I\nc : ComplexShape I\nself : c.TensorSigns\np q r : I\nhpq : c.Rel p q\n⊢ c.Rel (HAdd.hAdd r p) (HAdd.hAdd r q)","decl":"/-- If `I` is an additive monoid and `c : ComplexShape I`, `c.TensorSigns` contains the data of\nmap `ε : I → ℤˣ` and properties which allows the construction of a `TotalComplexShape c c c`. -/\nclass TensorSigns where\n  /-- the signs which appear in the vertical differential of the total complex -/\n  ε' : Multiplicative I →* ℤˣ\n  rel_add (p q r : I) (hpq : c.Rel p q) : c.Rel (p + r) (q + r)\n  add_rel (p q r : I) (hpq : c.Rel p q) : c.Rel (r + p) (r + q)\n  ε'_succ (p q : I) (hpq : c.Rel p q) : ε' q = - ε' p\n\n"}
{"name":"ComplexShape.rel_add","module":"Mathlib.Algebra.Homology.ComplexShapeSigns","initialProofState":"I : Type u_7\ninst✝¹ : AddMonoid I\nc : ComplexShape I\ninst✝ : c.TensorSigns\np q : I\nhpq : c.Rel p q\nr : I\n⊢ c.Rel (HAdd.hAdd p r) (HAdd.hAdd q r)","decl":"lemma rel_add {p q : I} (hpq : c.Rel p q) (r : I) : c.Rel (p + r) (q + r) :=\n  TensorSigns.rel_add _ _ _ hpq\n\n"}
{"name":"ComplexShape.add_rel","module":"Mathlib.Algebra.Homology.ComplexShapeSigns","initialProofState":"I : Type u_7\ninst✝¹ : AddMonoid I\nc : ComplexShape I\ninst✝ : c.TensorSigns\nr p q : I\nhpq : c.Rel p q\n⊢ c.Rel (HAdd.hAdd r p) (HAdd.hAdd r q)","decl":"lemma add_rel (r : I) {p q : I} (hpq : c.Rel p q) : c.Rel (r + p) (r + q) :=\n  TensorSigns.add_rel _ _ _ hpq\n\n"}
{"name":"ComplexShape.ε_zero","module":"Mathlib.Algebra.Homology.ComplexShapeSigns","initialProofState":"I : Type u_7\ninst✝¹ : AddMonoid I\nc : ComplexShape I\ninst✝ : c.TensorSigns\n⊢ Eq (c.ε 0) 1","decl":"@[simp]\nlemma ε_zero : c.ε 0 = 1 := by\n  apply MonoidHom.map_one\n\n"}
{"name":"ComplexShape.ε_succ","module":"Mathlib.Algebra.Homology.ComplexShapeSigns","initialProofState":"I : Type u_7\ninst✝¹ : AddMonoid I\nc : ComplexShape I\ninst✝ : c.TensorSigns\np q : I\nhpq : c.Rel p q\n⊢ Eq (c.ε q) (Neg.neg (c.ε p))","decl":"lemma ε_succ {p q : I} (hpq : c.Rel p q) : c.ε q = - c.ε p :=\n  TensorSigns.ε'_succ p q hpq\n\n"}
{"name":"ComplexShape.ε_add","module":"Mathlib.Algebra.Homology.ComplexShapeSigns","initialProofState":"I : Type u_7\ninst✝¹ : AddMonoid I\nc : ComplexShape I\ninst✝ : c.TensorSigns\np q : I\n⊢ Eq (c.ε (HAdd.hAdd p q)) (HMul.hMul (c.ε p) (c.ε q))","decl":"lemma ε_add (p q : I) : c.ε (p + q) = c.ε p * c.ε q := by\n  apply MonoidHom.map_mul\n\n"}
{"name":"ComplexShape.next_add","module":"Mathlib.Algebra.Homology.ComplexShapeSigns","initialProofState":"I : Type u_7\ninst✝¹ : AddMonoid I\nc : ComplexShape I\ninst✝ : c.TensorSigns\np q : I\nhp : c.Rel p (c.next p)\n⊢ Eq (c.next (HAdd.hAdd p q)) (HAdd.hAdd (c.next p) q)","decl":"lemma next_add (p q : I) (hp : c.Rel p (c.next p)) :\n    c.next (p + q) = c.next p + q :=\n  c.next_eq' (c.rel_add hp q)\n\n"}
{"name":"ComplexShape.next_add'","module":"Mathlib.Algebra.Homology.ComplexShapeSigns","initialProofState":"I : Type u_7\ninst✝¹ : AddMonoid I\nc : ComplexShape I\ninst✝ : c.TensorSigns\np q : I\nhq : c.Rel q (c.next q)\n⊢ Eq (c.next (HAdd.hAdd p q)) (HAdd.hAdd p (c.next q))","decl":"lemma next_add' (p q : I) (hq : c.Rel q (c.next q)) :\n    c.next (p + q) = p + c.next q :=\n  c.next_eq' (c.add_rel p hq)\n\n"}
{"name":"ComplexShape.instTotalComplexShape_π","module":"Mathlib.Algebra.Homology.ComplexShapeSigns","initialProofState":"I : Type u_7\ninst✝¹ : AddMonoid I\nc : ComplexShape I\ninst✝ : c.TensorSigns\nx✝ : Prod I I\n⊢ Eq (TotalComplexShape.π c c c x✝) (ComplexShape.instTotalComplexShape.match_1 (fun x => I) x✝ fun p q => HAdd.hAdd p q)","decl":"@[simps]\ninstance : TotalComplexShape c c c where\n  π := fun ⟨p, q⟩ => p + q\n  ε₁ := fun _ => 1\n  ε₂ := fun ⟨p, _⟩ => c.ε p\n  rel₁ h q := c.rel_add h q\n  rel₂ p _ _ h := c.add_rel p h\n  ε₂_ε₁ h _ := by\n    dsimp\n    rw [neg_mul, one_mul, mul_one, c.ε_succ h, neg_neg]\n\n"}
{"name":"ComplexShape.instTotalComplexShape_ε₂","module":"Mathlib.Algebra.Homology.ComplexShapeSigns","initialProofState":"I : Type u_7\ninst✝¹ : AddMonoid I\nc : ComplexShape I\ninst✝ : c.TensorSigns\nx✝ : Prod I I\n⊢ Eq (TotalComplexShape.ε₂ c c c x✝) (ComplexShape.instTotalComplexShape.match_1 (fun x => Units Int) x✝ fun p snd => c.ε p)","decl":"@[simps]\ninstance : TotalComplexShape c c c where\n  π := fun ⟨p, q⟩ => p + q\n  ε₁ := fun _ => 1\n  ε₂ := fun ⟨p, _⟩ => c.ε p\n  rel₁ h q := c.rel_add h q\n  rel₂ p _ _ h := c.add_rel p h\n  ε₂_ε₁ h _ := by\n    dsimp\n    rw [neg_mul, one_mul, mul_one, c.ε_succ h, neg_neg]\n\n"}
{"name":"ComplexShape.instTotalComplexShape_ε₁","module":"Mathlib.Algebra.Homology.ComplexShapeSigns","initialProofState":"I : Type u_7\ninst✝¹ : AddMonoid I\nc : ComplexShape I\ninst✝ : c.TensorSigns\nx✝ : Prod I I\n⊢ Eq (TotalComplexShape.ε₁ c c c x✝) 1","decl":"@[simps]\ninstance : TotalComplexShape c c c where\n  π := fun ⟨p, q⟩ => p + q\n  ε₁ := fun _ => 1\n  ε₂ := fun ⟨p, _⟩ => c.ε p\n  rel₁ h q := c.rel_add h q\n  rel₂ p _ _ h := c.add_rel p h\n  ε₂_ε₁ h _ := by\n    dsimp\n    rw [neg_mul, one_mul, mul_one, c.ε_succ h, neg_neg]\n\n"}
{"name":"ComplexShape.ε_down_ℕ","module":"Mathlib.Algebra.Homology.ComplexShapeSigns","initialProofState":"n : Nat\n⊢ Eq ((ComplexShape.down Nat).ε n) (HPow.hPow (-1) n)","decl":"@[simp]\nlemma ε_down_ℕ (n : ℕ) : (ComplexShape.down ℕ).ε n = (-1 : ℤˣ) ^ n := rfl\n\n"}
{"name":"ComplexShape.ε_up_ℤ","module":"Mathlib.Algebra.Homology.ComplexShapeSigns","initialProofState":"n : Int\n⊢ Eq ((ComplexShape.up Int).ε n) n.negOnePow","decl":"@[simp]\nlemma ε_up_ℤ (n : ℤ) : (ComplexShape.up ℤ).ε n = n.negOnePow := rfl\n\n"}
{"name":"ComplexShape.Associative.ε₂_ε₁","module":"Mathlib.Algebra.Homology.ComplexShapeSigns","initialProofState":"I₁ : Type u_1\nI₂ : Type u_2\nI₃ : Type u_3\nI₁₂ : Type u_4\nI₂₃ : Type u_5\nJ : Type u_6\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nc₃ : ComplexShape I₃\nc₁₂ : ComplexShape I₁₂\nc₂₃ : ComplexShape I₂₃\nc : ComplexShape J\ninst✝³ : TotalComplexShape c₁ c₂ c₁₂\ninst✝² : TotalComplexShape c₁₂ c₃ c\ninst✝¹ : TotalComplexShape c₂ c₃ c₂₃\ninst✝ : TotalComplexShape c₁ c₂₃ c\nself : c₁.Associative c₂ c₃ c₁₂ c₂₃ c\ni₁ : I₁\ni₂ : I₂\ni₃ : I₃\n⊢ Eq (HMul.hMul (c₁.ε₂ c₂₃ c { fst := i₁, snd := c₂.π c₃ c₂₃ { fst := i₂, snd := i₃ } }) (c₂.ε₁ c₃ c₂₃ { fst := i₂, snd := i₃ })) (HMul.hMul (c₁₂.ε₁ c₃ c { fst := c₁.π c₂ c₁₂ { fst := i₁, snd := i₂ }, snd := i₃ }) (c₁.ε₂ c₂ c₁₂ { fst := i₁, snd := i₂ }))","decl":"/-- When we have six complex shapes `c₁`, `c₂`, `c₃`, `c₁₂`, `c₂₃`, `c`, and total functors\n`HomologicalComplex₂ C c₁ c₂ ⥤ HomologicalComplex C c₁₂`,\n`HomologicalComplex₂ C c₁₂ c₃ ⥤ HomologicalComplex C c`,\n`HomologicalComplex₂ C c₂ c₃ ⥤ HomologicalComplex C c₂₃`,\n`HomologicalComplex₂ C c₁ c₂₂₃ ⥤ HomologicalComplex C c`, we get two ways to\ncompute the total complex of a triple complex in `HomologicalComplex₃ C c₁ c₂ c₃`, then\nunder this assumption `[Associative c₁ c₂ c₃ c₁₂ c₂₃ c]`, these two complexes\ncanonically identify (without introducing signs). -/\nclass Associative : Prop where\n  assoc (i₁ : I₁) (i₂ : I₂) (i₃ : I₃) :\n    π c₁₂ c₃ c ⟨π c₁ c₂ c₁₂ ⟨i₁, i₂⟩, i₃⟩ = π c₁ c₂₃ c ⟨i₁, π c₂ c₃ c₂₃ ⟨i₂, i₃⟩⟩\n  ε₁_eq_mul (i₁ : I₁) (i₂ : I₂) (i₃ : I₃) :\n    ε₁ c₁ c₂₃ c (i₁, π c₂ c₃ c₂₃ (i₂, i₃)) =\n      ε₁ c₁₂ c₃ c (π c₁ c₂ c₁₂ (i₁, i₂), i₃) * ε₁ c₁ c₂ c₁₂ (i₁, i₂)\n  ε₂_ε₁ (i₁ : I₁) (i₂ : I₂) (i₃ : I₃) :\n    ε₂ c₁ c₂₃ c (i₁, π c₂ c₃ c₂₃ (i₂, i₃)) * ε₁ c₂ c₃ c₂₃ (i₂, i₃) =\n      ε₁ c₁₂ c₃ c (π c₁ c₂ c₁₂ (i₁, i₂), i₃) * ε₂ c₁ c₂ c₁₂ (i₁, i₂)\n  ε₂_eq_mul (i₁ : I₁) (i₂ : I₂) (i₃ : I₃) :\n    ε₂ c₁₂ c₃ c (π c₁ c₂ c₁₂ (i₁, i₂), i₃) =\n      (ε₂ c₁ c₂₃ c (i₁, π c₂ c₃ c₂₃ (i₂, i₃)) * ε₂ c₂ c₃ c₂₃ (i₂, i₃))\n\n"}
{"name":"ComplexShape.Associative.ε₂_eq_mul","module":"Mathlib.Algebra.Homology.ComplexShapeSigns","initialProofState":"I₁ : Type u_1\nI₂ : Type u_2\nI₃ : Type u_3\nI₁₂ : Type u_4\nI₂₃ : Type u_5\nJ : Type u_6\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nc₃ : ComplexShape I₃\nc₁₂ : ComplexShape I₁₂\nc₂₃ : ComplexShape I₂₃\nc : ComplexShape J\ninst✝³ : TotalComplexShape c₁ c₂ c₁₂\ninst✝² : TotalComplexShape c₁₂ c₃ c\ninst✝¹ : TotalComplexShape c₂ c₃ c₂₃\ninst✝ : TotalComplexShape c₁ c₂₃ c\nself : c₁.Associative c₂ c₃ c₁₂ c₂₃ c\ni₁ : I₁\ni₂ : I₂\ni₃ : I₃\n⊢ Eq (c₁₂.ε₂ c₃ c { fst := c₁.π c₂ c₁₂ { fst := i₁, snd := i₂ }, snd := i₃ }) (HMul.hMul (c₁.ε₂ c₂₃ c { fst := i₁, snd := c₂.π c₃ c₂₃ { fst := i₂, snd := i₃ } }) (c₂.ε₂ c₃ c₂₃ { fst := i₂, snd := i₃ }))","decl":"/-- When we have six complex shapes `c₁`, `c₂`, `c₃`, `c₁₂`, `c₂₃`, `c`, and total functors\n`HomologicalComplex₂ C c₁ c₂ ⥤ HomologicalComplex C c₁₂`,\n`HomologicalComplex₂ C c₁₂ c₃ ⥤ HomologicalComplex C c`,\n`HomologicalComplex₂ C c₂ c₃ ⥤ HomologicalComplex C c₂₃`,\n`HomologicalComplex₂ C c₁ c₂₂₃ ⥤ HomologicalComplex C c`, we get two ways to\ncompute the total complex of a triple complex in `HomologicalComplex₃ C c₁ c₂ c₃`, then\nunder this assumption `[Associative c₁ c₂ c₃ c₁₂ c₂₃ c]`, these two complexes\ncanonically identify (without introducing signs). -/\nclass Associative : Prop where\n  assoc (i₁ : I₁) (i₂ : I₂) (i₃ : I₃) :\n    π c₁₂ c₃ c ⟨π c₁ c₂ c₁₂ ⟨i₁, i₂⟩, i₃⟩ = π c₁ c₂₃ c ⟨i₁, π c₂ c₃ c₂₃ ⟨i₂, i₃⟩⟩\n  ε₁_eq_mul (i₁ : I₁) (i₂ : I₂) (i₃ : I₃) :\n    ε₁ c₁ c₂₃ c (i₁, π c₂ c₃ c₂₃ (i₂, i₃)) =\n      ε₁ c₁₂ c₃ c (π c₁ c₂ c₁₂ (i₁, i₂), i₃) * ε₁ c₁ c₂ c₁₂ (i₁, i₂)\n  ε₂_ε₁ (i₁ : I₁) (i₂ : I₂) (i₃ : I₃) :\n    ε₂ c₁ c₂₃ c (i₁, π c₂ c₃ c₂₃ (i₂, i₃)) * ε₁ c₂ c₃ c₂₃ (i₂, i₃) =\n      ε₁ c₁₂ c₃ c (π c₁ c₂ c₁₂ (i₁, i₂), i₃) * ε₂ c₁ c₂ c₁₂ (i₁, i₂)\n  ε₂_eq_mul (i₁ : I₁) (i₂ : I₂) (i₃ : I₃) :\n    ε₂ c₁₂ c₃ c (π c₁ c₂ c₁₂ (i₁, i₂), i₃) =\n      (ε₂ c₁ c₂₃ c (i₁, π c₂ c₃ c₂₃ (i₂, i₃)) * ε₂ c₂ c₃ c₂₃ (i₂, i₃))\n\n"}
{"name":"ComplexShape.Associative.ε₁_eq_mul","module":"Mathlib.Algebra.Homology.ComplexShapeSigns","initialProofState":"I₁ : Type u_1\nI₂ : Type u_2\nI₃ : Type u_3\nI₁₂ : Type u_4\nI₂₃ : Type u_5\nJ : Type u_6\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nc₃ : ComplexShape I₃\nc₁₂ : ComplexShape I₁₂\nc₂₃ : ComplexShape I₂₃\nc : ComplexShape J\ninst✝³ : TotalComplexShape c₁ c₂ c₁₂\ninst✝² : TotalComplexShape c₁₂ c₃ c\ninst✝¹ : TotalComplexShape c₂ c₃ c₂₃\ninst✝ : TotalComplexShape c₁ c₂₃ c\nself : c₁.Associative c₂ c₃ c₁₂ c₂₃ c\ni₁ : I₁\ni₂ : I₂\ni₃ : I₃\n⊢ Eq (c₁.ε₁ c₂₃ c { fst := i₁, snd := c₂.π c₃ c₂₃ { fst := i₂, snd := i₃ } }) (HMul.hMul (c₁₂.ε₁ c₃ c { fst := c₁.π c₂ c₁₂ { fst := i₁, snd := i₂ }, snd := i₃ }) (c₁.ε₁ c₂ c₁₂ { fst := i₁, snd := i₂ }))","decl":"/-- When we have six complex shapes `c₁`, `c₂`, `c₃`, `c₁₂`, `c₂₃`, `c`, and total functors\n`HomologicalComplex₂ C c₁ c₂ ⥤ HomologicalComplex C c₁₂`,\n`HomologicalComplex₂ C c₁₂ c₃ ⥤ HomologicalComplex C c`,\n`HomologicalComplex₂ C c₂ c₃ ⥤ HomologicalComplex C c₂₃`,\n`HomologicalComplex₂ C c₁ c₂₂₃ ⥤ HomologicalComplex C c`, we get two ways to\ncompute the total complex of a triple complex in `HomologicalComplex₃ C c₁ c₂ c₃`, then\nunder this assumption `[Associative c₁ c₂ c₃ c₁₂ c₂₃ c]`, these two complexes\ncanonically identify (without introducing signs). -/\nclass Associative : Prop where\n  assoc (i₁ : I₁) (i₂ : I₂) (i₃ : I₃) :\n    π c₁₂ c₃ c ⟨π c₁ c₂ c₁₂ ⟨i₁, i₂⟩, i₃⟩ = π c₁ c₂₃ c ⟨i₁, π c₂ c₃ c₂₃ ⟨i₂, i₃⟩⟩\n  ε₁_eq_mul (i₁ : I₁) (i₂ : I₂) (i₃ : I₃) :\n    ε₁ c₁ c₂₃ c (i₁, π c₂ c₃ c₂₃ (i₂, i₃)) =\n      ε₁ c₁₂ c₃ c (π c₁ c₂ c₁₂ (i₁, i₂), i₃) * ε₁ c₁ c₂ c₁₂ (i₁, i₂)\n  ε₂_ε₁ (i₁ : I₁) (i₂ : I₂) (i₃ : I₃) :\n    ε₂ c₁ c₂₃ c (i₁, π c₂ c₃ c₂₃ (i₂, i₃)) * ε₁ c₂ c₃ c₂₃ (i₂, i₃) =\n      ε₁ c₁₂ c₃ c (π c₁ c₂ c₁₂ (i₁, i₂), i₃) * ε₂ c₁ c₂ c₁₂ (i₁, i₂)\n  ε₂_eq_mul (i₁ : I₁) (i₂ : I₂) (i₃ : I₃) :\n    ε₂ c₁₂ c₃ c (π c₁ c₂ c₁₂ (i₁, i₂), i₃) =\n      (ε₂ c₁ c₂₃ c (i₁, π c₂ c₃ c₂₃ (i₂, i₃)) * ε₂ c₂ c₃ c₂₃ (i₂, i₃))\n\n"}
{"name":"ComplexShape.Associative.assoc","module":"Mathlib.Algebra.Homology.ComplexShapeSigns","initialProofState":"I₁ : Type u_1\nI₂ : Type u_2\nI₃ : Type u_3\nI₁₂ : Type u_4\nI₂₃ : Type u_5\nJ : Type u_6\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nc₃ : ComplexShape I₃\nc₁₂ : ComplexShape I₁₂\nc₂₃ : ComplexShape I₂₃\nc : ComplexShape J\ninst✝³ : TotalComplexShape c₁ c₂ c₁₂\ninst✝² : TotalComplexShape c₁₂ c₃ c\ninst✝¹ : TotalComplexShape c₂ c₃ c₂₃\ninst✝ : TotalComplexShape c₁ c₂₃ c\nself : c₁.Associative c₂ c₃ c₁₂ c₂₃ c\ni₁ : I₁\ni₂ : I₂\ni₃ : I₃\n⊢ Eq (c₁₂.π c₃ c { fst := c₁.π c₂ c₁₂ { fst := i₁, snd := i₂ }, snd := i₃ }) (c₁.π c₂₃ c { fst := i₁, snd := c₂.π c₃ c₂₃ { fst := i₂, snd := i₃ } })","decl":"/-- When we have six complex shapes `c₁`, `c₂`, `c₃`, `c₁₂`, `c₂₃`, `c`, and total functors\n`HomologicalComplex₂ C c₁ c₂ ⥤ HomologicalComplex C c₁₂`,\n`HomologicalComplex₂ C c₁₂ c₃ ⥤ HomologicalComplex C c`,\n`HomologicalComplex₂ C c₂ c₃ ⥤ HomologicalComplex C c₂₃`,\n`HomologicalComplex₂ C c₁ c₂₂₃ ⥤ HomologicalComplex C c`, we get two ways to\ncompute the total complex of a triple complex in `HomologicalComplex₃ C c₁ c₂ c₃`, then\nunder this assumption `[Associative c₁ c₂ c₃ c₁₂ c₂₃ c]`, these two complexes\ncanonically identify (without introducing signs). -/\nclass Associative : Prop where\n  assoc (i₁ : I₁) (i₂ : I₂) (i₃ : I₃) :\n    π c₁₂ c₃ c ⟨π c₁ c₂ c₁₂ ⟨i₁, i₂⟩, i₃⟩ = π c₁ c₂₃ c ⟨i₁, π c₂ c₃ c₂₃ ⟨i₂, i₃⟩⟩\n  ε₁_eq_mul (i₁ : I₁) (i₂ : I₂) (i₃ : I₃) :\n    ε₁ c₁ c₂₃ c (i₁, π c₂ c₃ c₂₃ (i₂, i₃)) =\n      ε₁ c₁₂ c₃ c (π c₁ c₂ c₁₂ (i₁, i₂), i₃) * ε₁ c₁ c₂ c₁₂ (i₁, i₂)\n  ε₂_ε₁ (i₁ : I₁) (i₂ : I₂) (i₃ : I₃) :\n    ε₂ c₁ c₂₃ c (i₁, π c₂ c₃ c₂₃ (i₂, i₃)) * ε₁ c₂ c₃ c₂₃ (i₂, i₃) =\n      ε₁ c₁₂ c₃ c (π c₁ c₂ c₁₂ (i₁, i₂), i₃) * ε₂ c₁ c₂ c₁₂ (i₁, i₂)\n  ε₂_eq_mul (i₁ : I₁) (i₂ : I₂) (i₃ : I₃) :\n    ε₂ c₁₂ c₃ c (π c₁ c₂ c₁₂ (i₁, i₂), i₃) =\n      (ε₂ c₁ c₂₃ c (i₁, π c₂ c₃ c₂₃ (i₂, i₃)) * ε₂ c₂ c₃ c₂₃ (i₂, i₃))\n\n"}
{"name":"ComplexShape.assoc","module":"Mathlib.Algebra.Homology.ComplexShapeSigns","initialProofState":"I₁ : Type u_1\nI₂ : Type u_2\nI₃ : Type u_3\nI₁₂ : Type u_4\nI₂₃ : Type u_5\nJ : Type u_6\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nc₃ : ComplexShape I₃\nc₁₂ : ComplexShape I₁₂\nc₂₃ : ComplexShape I₂₃\nc : ComplexShape J\ninst✝⁴ : TotalComplexShape c₁ c₂ c₁₂\ninst✝³ : TotalComplexShape c₁₂ c₃ c\ninst✝² : TotalComplexShape c₂ c₃ c₂₃\ninst✝¹ : TotalComplexShape c₁ c₂₃ c\ninst✝ : c₁.Associative c₂ c₃ c₁₂ c₂₃ c\ni₁ : I₁\ni₂ : I₂\ni₃ : I₃\n⊢ Eq (c₁₂.π c₃ c { fst := c₁.π c₂ c₁₂ { fst := i₁, snd := i₂ }, snd := i₃ }) (c₁.π c₂₃ c { fst := i₁, snd := c₂.π c₃ c₂₃ { fst := i₂, snd := i₃ } })","decl":"lemma assoc (i₁ : I₁) (i₂ : I₂) (i₃ : I₃) :\n    π c₁₂ c₃ c ⟨π c₁ c₂ c₁₂ ⟨i₁, i₂⟩, i₃⟩ = π c₁ c₂₃ c ⟨i₁, π c₂ c₃ c₂₃ ⟨i₂, i₃⟩⟩ := by\n  apply Associative.assoc\n\n"}
{"name":"ComplexShape.associative_ε₁_eq_mul","module":"Mathlib.Algebra.Homology.ComplexShapeSigns","initialProofState":"I₁ : Type u_1\nI₂ : Type u_2\nI₃ : Type u_3\nI₁₂ : Type u_4\nI₂₃ : Type u_5\nJ : Type u_6\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nc₃ : ComplexShape I₃\nc₁₂ : ComplexShape I₁₂\nc₂₃ : ComplexShape I₂₃\nc : ComplexShape J\ninst✝⁴ : TotalComplexShape c₁ c₂ c₁₂\ninst✝³ : TotalComplexShape c₁₂ c₃ c\ninst✝² : TotalComplexShape c₂ c₃ c₂₃\ninst✝¹ : TotalComplexShape c₁ c₂₃ c\ninst✝ : c₁.Associative c₂ c₃ c₁₂ c₂₃ c\ni₁ : I₁\ni₂ : I₂\ni₃ : I₃\n⊢ Eq (c₁.ε₁ c₂₃ c { fst := i₁, snd := c₂.π c₃ c₂₃ { fst := i₂, snd := i₃ } }) (HMul.hMul (c₁₂.ε₁ c₃ c { fst := c₁.π c₂ c₁₂ { fst := i₁, snd := i₂ }, snd := i₃ }) (c₁.ε₁ c₂ c₁₂ { fst := i₁, snd := i₂ }))","decl":"lemma associative_ε₁_eq_mul (i₁ : I₁) (i₂ : I₂) (i₃ : I₃) :\n    ε₁ c₁ c₂₃ c (i₁, π c₂ c₃ c₂₃ (i₂, i₃)) =\n      ε₁ c₁₂ c₃ c (π c₁ c₂ c₁₂ (i₁, i₂), i₃) * ε₁ c₁ c₂ c₁₂ (i₁, i₂) := by\n  apply Associative.ε₁_eq_mul\n\n"}
{"name":"ComplexShape.associative_ε₂_ε₁","module":"Mathlib.Algebra.Homology.ComplexShapeSigns","initialProofState":"I₁ : Type u_1\nI₂ : Type u_2\nI₃ : Type u_3\nI₁₂ : Type u_4\nI₂₃ : Type u_5\nJ : Type u_6\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nc₃ : ComplexShape I₃\nc₁₂ : ComplexShape I₁₂\nc₂₃ : ComplexShape I₂₃\nc : ComplexShape J\ninst✝⁴ : TotalComplexShape c₁ c₂ c₁₂\ninst✝³ : TotalComplexShape c₁₂ c₃ c\ninst✝² : TotalComplexShape c₂ c₃ c₂₃\ninst✝¹ : TotalComplexShape c₁ c₂₃ c\ninst✝ : c₁.Associative c₂ c₃ c₁₂ c₂₃ c\ni₁ : I₁\ni₂ : I₂\ni₃ : I₃\n⊢ Eq (HMul.hMul (c₁.ε₂ c₂₃ c { fst := i₁, snd := c₂.π c₃ c₂₃ { fst := i₂, snd := i₃ } }) (c₂.ε₁ c₃ c₂₃ { fst := i₂, snd := i₃ })) (HMul.hMul (c₁₂.ε₁ c₃ c { fst := c₁.π c₂ c₁₂ { fst := i₁, snd := i₂ }, snd := i₃ }) (c₁.ε₂ c₂ c₁₂ { fst := i₁, snd := i₂ }))","decl":"lemma associative_ε₂_ε₁ (i₁ : I₁) (i₂ : I₂) (i₃ : I₃) :\n    ε₂ c₁ c₂₃ c (i₁, π c₂ c₃ c₂₃ (i₂, i₃)) * ε₁ c₂ c₃ c₂₃ (i₂, i₃) =\n      ε₁ c₁₂ c₃ c (π c₁ c₂ c₁₂ (i₁, i₂), i₃) * ε₂ c₁ c₂ c₁₂ (i₁, i₂) := by\n  apply Associative.ε₂_ε₁\n\n"}
{"name":"ComplexShape.associative_ε₂_eq_mul","module":"Mathlib.Algebra.Homology.ComplexShapeSigns","initialProofState":"I₁ : Type u_1\nI₂ : Type u_2\nI₃ : Type u_3\nI₁₂ : Type u_4\nI₂₃ : Type u_5\nJ : Type u_6\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nc₃ : ComplexShape I₃\nc₁₂ : ComplexShape I₁₂\nc₂₃ : ComplexShape I₂₃\nc : ComplexShape J\ninst✝⁴ : TotalComplexShape c₁ c₂ c₁₂\ninst✝³ : TotalComplexShape c₁₂ c₃ c\ninst✝² : TotalComplexShape c₂ c₃ c₂₃\ninst✝¹ : TotalComplexShape c₁ c₂₃ c\ninst✝ : c₁.Associative c₂ c₃ c₁₂ c₂₃ c\ni₁ : I₁\ni₂ : I₂\ni₃ : I₃\n⊢ Eq (c₁₂.ε₂ c₃ c { fst := c₁.π c₂ c₁₂ { fst := i₁, snd := i₂ }, snd := i₃ }) (HMul.hMul (c₁.ε₂ c₂₃ c { fst := i₁, snd := c₂.π c₃ c₂₃ { fst := i₂, snd := i₃ } }) (c₂.ε₂ c₃ c₂₃ { fst := i₂, snd := i₃ }))","decl":"lemma associative_ε₂_eq_mul (i₁ : I₁) (i₂ : I₂) (i₃ : I₃) :\n    ε₂ c₁₂ c₃ c (π c₁ c₂ c₁₂ (i₁, i₂), i₃) =\n      (ε₂ c₁ c₂₃ c (i₁, π c₂ c₃ c₂₃ (i₂, i₃)) * ε₂ c₂ c₃ c₂₃ (i₂, i₃)) := by\n  apply Associative.ε₂_eq_mul\n\n"}
{"name":"ComplexShape.instAssociative","module":"Mathlib.Algebra.Homology.ComplexShapeSigns","initialProofState":"I : Type u_7\ninst✝¹ : AddMonoid I\nc : ComplexShape I\ninst✝ : c.TensorSigns\n⊢ c.Associative c c c c c","decl":"instance {I : Type*} [AddMonoid I] (c : ComplexShape I) [c.TensorSigns] :\n    Associative c c c c c c where\n  assoc := add_assoc\n  ε₁_eq_mul _ _ _ := by dsimp; rw [one_mul]\n  ε₂_ε₁ _ _ _ := by dsimp; rw [one_mul, mul_one]\n  ε₂_eq_mul _ _ _ := by dsimp; rw [ε_add]\n\n"}
{"name":"TotalComplexShapeSymmetry.symm","module":"Mathlib.Algebra.Homology.ComplexShapeSigns","initialProofState":"I₁ : Type u_1\nI₂ : Type u_2\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nc₁₂ : ComplexShape I₁₂\ninst✝¹ : TotalComplexShape c₁ c₂ c₁₂\ninst✝ : TotalComplexShape c₂ c₁ c₁₂\nself : TotalComplexShapeSymmetry c₁ c₂ c₁₂\ni₁ : I₁\ni₂ : I₂\n⊢ Eq (c₂.π c₁ c₁₂ { fst := i₂, snd := i₁ }) (c₁.π c₂ c₁₂ { fst := i₁, snd := i₂ })","decl":"/-- A total complex shape symmetry contains the data and properties which allow the\nidentification of the two total complex functors\n`HomologicalComplex₂ C c₁ c₂ ⥤ HomologicalComplex C c₁₂`\nand `HomologicalComplex₂ C c₂ c₁ ⥤ HomologicalComplex C c₁₂` via the flip. -/\nclass TotalComplexShapeSymmetry [TotalComplexShape c₁ c₂ c₁₂] [TotalComplexShape c₂ c₁ c₁₂] where\n  symm (i₁ : I₁) (i₂ : I₂) : ComplexShape.π c₂ c₁ c₁₂ ⟨i₂, i₁⟩ = ComplexShape.π c₁ c₂ c₁₂ ⟨i₁, i₂⟩\n  /-- the signs involved in the symmetry isomorphism of the total complex -/\n  σ (i₁ : I₁) (i₂ : I₂) : ℤˣ\n  σ_ε₁ {i₁ i₁' : I₁} (h₁ : c₁.Rel i₁ i₁') (i₂ : I₂) :\n    σ i₁ i₂ * ComplexShape.ε₁ c₁ c₂ c₁₂ ⟨i₁, i₂⟩ = ComplexShape.ε₂ c₂ c₁ c₁₂ ⟨i₂, i₁⟩ * σ i₁' i₂\n  σ_ε₂ (i₁ : I₁) {i₂ i₂' : I₂} (h₂ : c₂.Rel i₂ i₂') :\n    σ i₁ i₂ * ComplexShape.ε₂ c₁ c₂ c₁₂ ⟨i₁, i₂⟩ = ComplexShape.ε₁ c₂ c₁ c₁₂ ⟨i₂, i₁⟩ * σ i₁ i₂'\n\n"}
{"name":"TotalComplexShapeSymmetry.σ_ε₂","module":"Mathlib.Algebra.Homology.ComplexShapeSigns","initialProofState":"I₁ : Type u_1\nI₂ : Type u_2\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nc₁₂ : ComplexShape I₁₂\ninst✝¹ : TotalComplexShape c₁ c₂ c₁₂\ninst✝ : TotalComplexShape c₂ c₁ c₁₂\nself : TotalComplexShapeSymmetry c₁ c₂ c₁₂\ni₁ : I₁\ni₂ i₂' : I₂\nh₂ : c₂.Rel i₂ i₂'\n⊢ Eq (HMul.hMul (TotalComplexShapeSymmetry.σ c₁ c₂ c₁₂ i₁ i₂) (c₁.ε₂ c₂ c₁₂ { fst := i₁, snd := i₂ })) (HMul.hMul (c₂.ε₁ c₁ c₁₂ { fst := i₂, snd := i₁ }) (TotalComplexShapeSymmetry.σ c₁ c₂ c₁₂ i₁ i₂'))","decl":"/-- A total complex shape symmetry contains the data and properties which allow the\nidentification of the two total complex functors\n`HomologicalComplex₂ C c₁ c₂ ⥤ HomologicalComplex C c₁₂`\nand `HomologicalComplex₂ C c₂ c₁ ⥤ HomologicalComplex C c₁₂` via the flip. -/\nclass TotalComplexShapeSymmetry [TotalComplexShape c₁ c₂ c₁₂] [TotalComplexShape c₂ c₁ c₁₂] where\n  symm (i₁ : I₁) (i₂ : I₂) : ComplexShape.π c₂ c₁ c₁₂ ⟨i₂, i₁⟩ = ComplexShape.π c₁ c₂ c₁₂ ⟨i₁, i₂⟩\n  /-- the signs involved in the symmetry isomorphism of the total complex -/\n  σ (i₁ : I₁) (i₂ : I₂) : ℤˣ\n  σ_ε₁ {i₁ i₁' : I₁} (h₁ : c₁.Rel i₁ i₁') (i₂ : I₂) :\n    σ i₁ i₂ * ComplexShape.ε₁ c₁ c₂ c₁₂ ⟨i₁, i₂⟩ = ComplexShape.ε₂ c₂ c₁ c₁₂ ⟨i₂, i₁⟩ * σ i₁' i₂\n  σ_ε₂ (i₁ : I₁) {i₂ i₂' : I₂} (h₂ : c₂.Rel i₂ i₂') :\n    σ i₁ i₂ * ComplexShape.ε₂ c₁ c₂ c₁₂ ⟨i₁, i₂⟩ = ComplexShape.ε₁ c₂ c₁ c₁₂ ⟨i₂, i₁⟩ * σ i₁ i₂'\n\n"}
{"name":"TotalComplexShapeSymmetry.σ_ε₁","module":"Mathlib.Algebra.Homology.ComplexShapeSigns","initialProofState":"I₁ : Type u_1\nI₂ : Type u_2\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nc₁₂ : ComplexShape I₁₂\ninst✝¹ : TotalComplexShape c₁ c₂ c₁₂\ninst✝ : TotalComplexShape c₂ c₁ c₁₂\nself : TotalComplexShapeSymmetry c₁ c₂ c₁₂\ni₁ i₁' : I₁\nh₁ : c₁.Rel i₁ i₁'\ni₂ : I₂\n⊢ Eq (HMul.hMul (TotalComplexShapeSymmetry.σ c₁ c₂ c₁₂ i₁ i₂) (c₁.ε₁ c₂ c₁₂ { fst := i₁, snd := i₂ })) (HMul.hMul (c₂.ε₂ c₁ c₁₂ { fst := i₂, snd := i₁ }) (TotalComplexShapeSymmetry.σ c₁ c₂ c₁₂ i₁' i₂))","decl":"/-- A total complex shape symmetry contains the data and properties which allow the\nidentification of the two total complex functors\n`HomologicalComplex₂ C c₁ c₂ ⥤ HomologicalComplex C c₁₂`\nand `HomologicalComplex₂ C c₂ c₁ ⥤ HomologicalComplex C c₁₂` via the flip. -/\nclass TotalComplexShapeSymmetry [TotalComplexShape c₁ c₂ c₁₂] [TotalComplexShape c₂ c₁ c₁₂] where\n  symm (i₁ : I₁) (i₂ : I₂) : ComplexShape.π c₂ c₁ c₁₂ ⟨i₂, i₁⟩ = ComplexShape.π c₁ c₂ c₁₂ ⟨i₁, i₂⟩\n  /-- the signs involved in the symmetry isomorphism of the total complex -/\n  σ (i₁ : I₁) (i₂ : I₂) : ℤˣ\n  σ_ε₁ {i₁ i₁' : I₁} (h₁ : c₁.Rel i₁ i₁') (i₂ : I₂) :\n    σ i₁ i₂ * ComplexShape.ε₁ c₁ c₂ c₁₂ ⟨i₁, i₂⟩ = ComplexShape.ε₂ c₂ c₁ c₁₂ ⟨i₂, i₁⟩ * σ i₁' i₂\n  σ_ε₂ (i₁ : I₁) {i₂ i₂' : I₂} (h₂ : c₂.Rel i₂ i₂') :\n    σ i₁ i₂ * ComplexShape.ε₂ c₁ c₂ c₁₂ ⟨i₁, i₂⟩ = ComplexShape.ε₁ c₂ c₁ c₁₂ ⟨i₂, i₁⟩ * σ i₁ i₂'\n\n"}
{"name":"ComplexShape.π_symm","module":"Mathlib.Algebra.Homology.ComplexShapeSigns","initialProofState":"I₁ : Type u_1\nI₂ : Type u_2\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nc₁₂ : ComplexShape I₁₂\ninst✝² : TotalComplexShape c₁ c₂ c₁₂\ninst✝¹ : TotalComplexShape c₂ c₁ c₁₂\ninst✝ : TotalComplexShapeSymmetry c₁ c₂ c₁₂\ni₁ : I₁\ni₂ : I₂\n⊢ Eq (c₂.π c₁ c₁₂ { fst := i₂, snd := i₁ }) (c₁.π c₂ c₁₂ { fst := i₁, snd := i₂ })","decl":"lemma π_symm (i₁ : I₁) (i₂ : I₂) :\n    π c₂ c₁ c₁₂ ⟨i₂, i₁⟩ = π c₁ c₂ c₁₂ ⟨i₁, i₂⟩ := by\n  apply TotalComplexShapeSymmetry.symm\n\n"}
{"name":"ComplexShape.symmetryEquiv_symm_apply_coe","module":"Mathlib.Algebra.Homology.ComplexShapeSigns","initialProofState":"I₁ : Type u_1\nI₂ : Type u_2\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nc₁₂ : ComplexShape I₁₂\ninst✝¹ : TotalComplexShape c₁ c₂ c₁₂\ninst✝ : TotalComplexShape c₂ c₁ c₁₂\nj : I₁₂\nx✝ : ↑(Set.preimage (c₁.π c₂ c₁₂) (Singleton.singleton j))\n⊢ Eq ↑((c₁.symmetryEquiv c₂ c₁₂ j).symm x✝) { fst := x✝.1.2, snd := x✝.1.1 }","decl":"/-- The symmetry bijection `(π c₂ c₁ c₁₂ ⁻¹' {j}) ≃ (π c₁ c₂ c₁₂ ⁻¹' {j})`. -/\n@[simps]\ndef symmetryEquiv (j : I₁₂) :\n    (π c₂ c₁ c₁₂ ⁻¹' {j}) ≃ (π c₁ c₂ c₁₂ ⁻¹' {j}) where\n  toFun := fun ⟨⟨i₂, i₁⟩, h⟩ => ⟨⟨i₁, i₂⟩, by simpa [π_symm] using h⟩\n  invFun := fun ⟨⟨i₁, i₂⟩, h⟩ => ⟨⟨i₂, i₁⟩, by simpa [π_symm] using h⟩\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"ComplexShape.symmetryEquiv_apply_coe","module":"Mathlib.Algebra.Homology.ComplexShapeSigns","initialProofState":"I₁ : Type u_1\nI₂ : Type u_2\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nc₁₂ : ComplexShape I₁₂\ninst✝¹ : TotalComplexShape c₁ c₂ c₁₂\ninst✝ : TotalComplexShape c₂ c₁ c₁₂\nj : I₁₂\nx✝ : ↑(Set.preimage (c₂.π c₁ c₁₂) (Singleton.singleton j))\n⊢ Eq ↑((c₁.symmetryEquiv c₂ c₁₂ j) x✝) { fst := x✝.1.2, snd := x✝.1.1 }","decl":"/-- The symmetry bijection `(π c₂ c₁ c₁₂ ⁻¹' {j}) ≃ (π c₁ c₂ c₁₂ ⁻¹' {j})`. -/\n@[simps]\ndef symmetryEquiv (j : I₁₂) :\n    (π c₂ c₁ c₁₂ ⁻¹' {j}) ≃ (π c₁ c₂ c₁₂ ⁻¹' {j}) where\n  toFun := fun ⟨⟨i₂, i₁⟩, h⟩ => ⟨⟨i₁, i₂⟩, by simpa [π_symm] using h⟩\n  invFun := fun ⟨⟨i₁, i₂⟩, h⟩ => ⟨⟨i₂, i₁⟩, by simpa [π_symm] using h⟩\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"ComplexShape.σ_ε₁","module":"Mathlib.Algebra.Homology.ComplexShapeSigns","initialProofState":"I₁ : Type u_1\nI₂ : Type u_2\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nc₁₂ : ComplexShape I₁₂\ninst✝² : TotalComplexShape c₁ c₂ c₁₂\ninst✝¹ : TotalComplexShape c₂ c₁ c₁₂\ninst✝ : TotalComplexShapeSymmetry c₁ c₂ c₁₂\ni₁ i₁' : I₁\nh₁ : c₁.Rel i₁ i₁'\ni₂ : I₂\n⊢ Eq (HMul.hMul (c₁.σ c₂ c₁₂ i₁ i₂) (c₁.ε₁ c₂ c₁₂ { fst := i₁, snd := i₂ })) (HMul.hMul (c₂.ε₂ c₁ c₁₂ { fst := i₂, snd := i₁ }) (c₁.σ c₂ c₁₂ i₁' i₂))","decl":"lemma σ_ε₁ {i₁ i₁' : I₁} (h₁ : c₁.Rel i₁ i₁') (i₂ : I₂) :\n    σ c₁ c₂ c₁₂ i₁ i₂ * ε₁ c₁ c₂ c₁₂ ⟨i₁, i₂⟩ = ε₂ c₂ c₁ c₁₂ ⟨i₂, i₁⟩ * σ c₁ c₂ c₁₂ i₁' i₂ :=\n  TotalComplexShapeSymmetry.σ_ε₁ h₁ i₂\n\n"}
{"name":"ComplexShape.σ_ε₂","module":"Mathlib.Algebra.Homology.ComplexShapeSigns","initialProofState":"I₁ : Type u_1\nI₂ : Type u_2\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nc₁₂ : ComplexShape I₁₂\ninst✝² : TotalComplexShape c₁ c₂ c₁₂\ninst✝¹ : TotalComplexShape c₂ c₁ c₁₂\ninst✝ : TotalComplexShapeSymmetry c₁ c₂ c₁₂\ni₁ : I₁\ni₂ i₂' : I₂\nh₂ : c₂.Rel i₂ i₂'\n⊢ Eq (HMul.hMul (c₁.σ c₂ c₁₂ i₁ i₂) (c₁.ε₂ c₂ c₁₂ { fst := i₁, snd := i₂ })) (HMul.hMul (c₂.ε₁ c₁ c₁₂ { fst := i₂, snd := i₁ }) (c₁.σ c₂ c₁₂ i₁ i₂'))","decl":"lemma σ_ε₂ (i₁ : I₁) {i₂ i₂' : I₂} (h₂ : c₂.Rel i₂ i₂') :\n    σ c₁ c₂ c₁₂ i₁ i₂ * ε₂ c₁ c₂ c₁₂ ⟨i₁, i₂⟩ = ε₁ c₂ c₁ c₁₂ ⟨i₂, i₁⟩ * σ c₁ c₂ c₁₂ i₁ i₂' :=\n  TotalComplexShapeSymmetry.σ_ε₂ i₁ h₂\n\n"}
{"name":"ComplexShape.instTotalComplexShapeSymmetryIntUp_σ","module":"Mathlib.Algebra.Homology.ComplexShapeSigns","initialProofState":"p q : Int\n⊢ Eq (TotalComplexShapeSymmetry.σ (ComplexShape.up Int) (ComplexShape.up Int) (ComplexShape.up Int) p q) (HMul.hMul p q).negOnePow","decl":"@[simps]\ninstance : TotalComplexShapeSymmetry (up ℤ) (up ℤ) (up ℤ) where\n  symm p q := add_comm q p\n  σ p q := (p * q).negOnePow\n  σ_ε₁ := by\n    rintro p _ rfl q\n    dsimp\n    rw [mul_one, ← Int.negOnePow_add, add_comm q, add_mul, one_mul, Int.negOnePow_add,\n      Int.negOnePow_add, mul_assoc, Int.units_mul_self, mul_one]\n  σ_ε₂ := by\n    rintro p q _ rfl\n    dsimp\n    rw [one_mul, ← Int.negOnePow_add, mul_add, mul_one]\n\n"}
{"name":"TotalComplexShapeSymmetrySymmetry.σ_symm","module":"Mathlib.Algebra.Homology.ComplexShapeSigns","initialProofState":"I₁ : Type u_1\nI₂ : Type u_2\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nc₁₂ : ComplexShape I₁₂\ninst✝³ : TotalComplexShape c₁ c₂ c₁₂\ninst✝² : TotalComplexShape c₂ c₁ c₁₂\ninst✝¹ : TotalComplexShapeSymmetry c₁ c₂ c₁₂\ninst✝ : TotalComplexShapeSymmetry c₂ c₁ c₁₂\nself : TotalComplexShapeSymmetrySymmetry c₁ c₂ c₁₂\ni₁ : I₁\ni₂ : I₂\n⊢ Eq (c₂.σ c₁ c₁₂ i₂ i₁) (c₁.σ c₂ c₁₂ i₁ i₂)","decl":"/-- This typeclass expresses that the signs given by `[TotalComplexShapeSymmetry c₁ c₂ c₁₂]`\nand by `[TotalComplexShapeSymmetry c₂ c₁ c₁₂]` are compatible. -/\nclass TotalComplexShapeSymmetrySymmetry [TotalComplexShape c₁ c₂ c₁₂]\n    [TotalComplexShape c₂ c₁ c₁₂] [TotalComplexShapeSymmetry c₁ c₂ c₁₂]\n    [TotalComplexShapeSymmetry c₂ c₁ c₁₂] : Prop where\n  σ_symm i₁ i₂ : ComplexShape.σ c₂ c₁ c₁₂ i₂ i₁ = ComplexShape.σ c₁ c₂ c₁₂ i₁ i₂\n\n"}
{"name":"ComplexShape.σ_symm","module":"Mathlib.Algebra.Homology.ComplexShapeSigns","initialProofState":"I₁ : Type u_1\nI₂ : Type u_2\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nc₁₂ : ComplexShape I₁₂\ninst✝⁴ : TotalComplexShape c₁ c₂ c₁₂\ninst✝³ : TotalComplexShape c₂ c₁ c₁₂\ninst✝² : TotalComplexShapeSymmetry c₁ c₂ c₁₂\ninst✝¹ : TotalComplexShapeSymmetry c₂ c₁ c₁₂\ninst✝ : TotalComplexShapeSymmetrySymmetry c₁ c₂ c₁₂\ni₁ : I₁\ni₂ : I₂\n⊢ Eq (c₂.σ c₁ c₁₂ i₂ i₁) (c₁.σ c₂ c₁₂ i₁ i₂)","decl":"lemma σ_symm (i₁ : I₁) (i₂ : I₂) :\n    σ c₂ c₁ c₁₂ i₂ i₁ = σ c₁ c₂ c₁₂ i₁ i₂ := by\n  apply TotalComplexShapeSymmetrySymmetry.σ_symm\n\n"}
