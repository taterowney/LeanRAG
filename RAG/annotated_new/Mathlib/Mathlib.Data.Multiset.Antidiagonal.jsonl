{"name":"Multiset.antidiagonal_coe","module":"Mathlib.Data.Multiset.Antidiagonal","initialProofState":"α : Type u_1\nl : List α\n⊢ Eq (↑l).antidiagonal ↑(Multiset.powersetAux l).revzip","decl":"theorem antidiagonal_coe (l : List α) : @antidiagonal α l = revzip (powersetAux l) :=\n  rfl\n\n"}
{"name":"Multiset.antidiagonal_coe'","module":"Mathlib.Data.Multiset.Antidiagonal","initialProofState":"α : Type u_1\nl : List α\n⊢ Eq (↑l).antidiagonal ↑(Multiset.powersetAux' l).revzip","decl":"@[simp]\ntheorem antidiagonal_coe' (l : List α) : @antidiagonal α l = revzip (powersetAux' l) :=\n  Quot.sound revzip_powersetAux_perm_aux'\n\n/- Porting note: `simp` seemed to be applying `antidiagonal_coe'` instead of `antidiagonal_coe`\nin what used to be `simp [antidiagonal_coe]`. -/\n"}
{"name":"Multiset.mem_antidiagonal","module":"Mathlib.Data.Multiset.Antidiagonal","initialProofState":"α : Type u_1\ns : Multiset α\nx : Prod (Multiset α) (Multiset α)\n⊢ Iff (Membership.mem s.antidiagonal x) (Eq (HAdd.hAdd x.1 x.2) s)","decl":"/-- A pair `(t₁, t₂)` of multisets is contained in `antidiagonal s`\n    if and only if `t₁ + t₂ = s`. -/\n@[simp]\ntheorem mem_antidiagonal {s : Multiset α} {x : Multiset α × Multiset α} :\n    x ∈ antidiagonal s ↔ x.1 + x.2 = s :=\n  Quotient.inductionOn s fun l ↦ by\n    dsimp only [quot_mk_to_coe, antidiagonal_coe]\n    refine ⟨fun h => revzip_powersetAux h, fun h ↦ ?_⟩\n    haveI := Classical.decEq α\n    simp only [revzip_powersetAux_lemma l revzip_powersetAux, h.symm, mem_coe,\n      List.mem_map, mem_powersetAux]\n    cases' x with x₁ x₂\n    exact ⟨x₁, le_add_right _ _, by rw [add_tsub_cancel_left x₁ x₂]⟩\n\n"}
{"name":"Multiset.antidiagonal_map_fst","module":"Mathlib.Data.Multiset.Antidiagonal","initialProofState":"α : Type u_1\ns : Multiset α\n⊢ Eq (Multiset.map Prod.fst s.antidiagonal) s.powerset","decl":"@[simp]\ntheorem antidiagonal_map_fst (s : Multiset α) : (antidiagonal s).map Prod.fst = powerset s :=\n  Quotient.inductionOn s fun l ↦ by simp [powersetAux']\n\n"}
{"name":"Multiset.antidiagonal_map_snd","module":"Mathlib.Data.Multiset.Antidiagonal","initialProofState":"α : Type u_1\ns : Multiset α\n⊢ Eq (Multiset.map Prod.snd s.antidiagonal) s.powerset","decl":"@[simp]\ntheorem antidiagonal_map_snd (s : Multiset α) : (antidiagonal s).map Prod.snd = powerset s :=\n  Quotient.inductionOn s fun l ↦ by simp [powersetAux']\n\n"}
{"name":"Multiset.antidiagonal_zero","module":"Mathlib.Data.Multiset.Antidiagonal","initialProofState":"α : Type u_1\n⊢ Eq (Multiset.antidiagonal 0) (Singleton.singleton { fst := 0, snd := 0 })","decl":"@[simp]\ntheorem antidiagonal_zero : @antidiagonal α 0 = {(0, 0)} :=\n  rfl\n\n"}
{"name":"Multiset.antidiagonal_cons","module":"Mathlib.Data.Multiset.Antidiagonal","initialProofState":"α : Type u_1\na : α\ns : Multiset α\n⊢ Eq (Multiset.cons a s).antidiagonal (HAdd.hAdd (Multiset.map (Prod.map id (Multiset.cons a)) s.antidiagonal) (Multiset.map (Prod.map (Multiset.cons a) id) s.antidiagonal))","decl":"@[simp]\ntheorem antidiagonal_cons (a : α) (s) :\n    antidiagonal (a ::ₘ s) =\n      map (Prod.map id (cons a)) (antidiagonal s) + map (Prod.map (cons a) id) (antidiagonal s) :=\n  Quotient.inductionOn s fun l ↦ by\n    simp only [revzip, reverse_append, quot_mk_to_coe, coe_eq_coe, powersetAux'_cons, cons_coe,\n      map_coe, antidiagonal_coe', coe_add]\n    rw [← zip_map, ← zip_map, zip_append, (_ : _ ++ _ = _)]\n    · congr\n      · simp only [List.map_id]\n      · rw [map_reverse]\n      · simp\n    · simp\n\n"}
{"name":"Multiset.antidiagonal_eq_map_powerset","module":"Mathlib.Data.Multiset.Antidiagonal","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Multiset α\n⊢ Eq s.antidiagonal (Multiset.map (fun t => { fst := HSub.hSub s t, snd := t }) s.powerset)","decl":"theorem antidiagonal_eq_map_powerset [DecidableEq α] (s : Multiset α) :\n    s.antidiagonal = s.powerset.map fun t ↦ (s - t, t) := by\n  induction' s using Multiset.induction_on with a s hs\n  · simp only [antidiagonal_zero, powerset_zero, Multiset.zero_sub, map_singleton]\n  · simp_rw [antidiagonal_cons, powerset_cons, map_add, hs, map_map, Function.comp, Prod.map_apply,\n      id, sub_cons, erase_cons_head]\n    rw [add_comm]\n    congr 1\n    refine Multiset.map_congr rfl fun x hx ↦ ?_\n    rw [cons_sub_of_le _ (mem_powerset.mp hx)]\n\n"}
{"name":"Multiset.card_antidiagonal","module":"Mathlib.Data.Multiset.Antidiagonal","initialProofState":"α : Type u_1\ns : Multiset α\n⊢ Eq s.antidiagonal.card (HPow.hPow 2 s.card)","decl":"@[simp]\ntheorem card_antidiagonal (s : Multiset α) : card (antidiagonal s) = 2 ^ card s := by\n  have := card_powerset s\n  rwa [← antidiagonal_map_fst, card_map] at this\n\n"}
