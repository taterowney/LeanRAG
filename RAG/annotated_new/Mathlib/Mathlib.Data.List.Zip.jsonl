{"name":"List.zip_swap","module":"Mathlib.Data.List.Zip","initialProofState":"α : Type u\nβ : Type u_1\nl₁ : List α\nl₂ : List β\n⊢ Eq (List.map Prod.swap (l₁.zip l₂)) (l₂.zip l₁)","decl":"@[simp]\ntheorem zip_swap : ∀ (l₁ : List α) (l₂ : List β), (zip l₁ l₂).map Prod.swap = zip l₂ l₁\n  | [], _ => zip_nil_right.symm\n  | l₁, [] => by rw [zip_nil_right]; rfl\n  | a :: l₁, b :: l₂ => by\n    simp only [zip_cons_cons, map_cons, zip_swap l₁ l₂, Prod.swap_prod_mk]\n\n"}
{"name":"List.forall_zipWith","module":"Mathlib.Data.List.Zip","initialProofState":"α : Type u\nβ : Type u_1\nγ : Type u_2\nf : α → β → γ\np : γ → Prop\nl₁ : List α\nl₂ : List β\na✝ : Eq l₁.length l₂.length\n⊢ Iff (List.Forall p (List.zipWith f l₁ l₂)) (List.Forall₂ (fun x y => p (f x y)) l₁ l₂)","decl":"theorem forall_zipWith {f : α → β → γ} {p : γ → Prop} :\n    ∀ {l₁ : List α} {l₂ : List β}, length l₁ = length l₂ →\n      (Forall p (zipWith f l₁ l₂) ↔ Forall₂ (fun x y => p (f x y)) l₁ l₂)\n  | [], [], _ => by simp\n  | a :: l₁, b :: l₂, h => by\n    simp only [length_cons, succ_inj'] at h\n    simp [forall_zipWith h]\n\n"}
{"name":"List.unzip_swap","module":"Mathlib.Data.List.Zip","initialProofState":"α : Type u\nβ : Type u_1\nl : List (Prod α β)\n⊢ Eq (List.map Prod.swap l).unzip l.unzip.swap","decl":"theorem unzip_swap (l : List (α × β)) : unzip (l.map Prod.swap) = (unzip l).swap := by\n  simp only [unzip_eq_map, map_map]\n  rfl\n\n"}
{"name":"List.zipWith_congr","module":"Mathlib.Data.List.Zip","initialProofState":"α : Type u\nβ : Type u_1\nγ : Type u_2\nf g : α → β → γ\nla : List α\nlb : List β\nh : List.Forall₂ (fun a b => Eq (f a b) (g a b)) la lb\n⊢ Eq (List.zipWith f la lb) (List.zipWith g la lb)","decl":"@[congr]\ntheorem zipWith_congr (f g : α → β → γ) (la : List α) (lb : List β)\n    (h : List.Forall₂ (fun a b => f a b = g a b) la lb) : zipWith f la lb = zipWith g la lb := by\n  induction' h with a b as bs hfg _ ih\n  · rfl\n  · exact congr_arg₂ _ hfg ih\n\n"}
{"name":"List.zipWith_zipWith_left","module":"Mathlib.Data.List.Zip","initialProofState":"α : Type u\nβ : Type u_1\nγ : Type u_2\nδ : Type u_3\nε : Type u_4\nf : δ → γ → ε\ng : α → β → δ\nla : List α\nlb : List β\nlc : List γ\n⊢ Eq (List.zipWith f (List.zipWith g la lb) lc) (List.zipWith3 (fun a b c => f (g a b) c) la lb lc)","decl":"theorem zipWith_zipWith_left (f : δ → γ → ε) (g : α → β → δ) :\n    ∀ (la : List α) (lb : List β) (lc : List γ),\n      zipWith f (zipWith g la lb) lc = zipWith3 (fun a b c => f (g a b) c) la lb lc\n  | [], _, _ => rfl\n  | _ :: _, [], _ => rfl\n  | _ :: _, _ :: _, [] => rfl\n  | _ :: as, _ :: bs, _ :: cs => congr_arg (cons _) <| zipWith_zipWith_left f g as bs cs\n\n"}
{"name":"List.zipWith_zipWith_right","module":"Mathlib.Data.List.Zip","initialProofState":"α : Type u\nβ : Type u_1\nγ : Type u_2\nδ : Type u_3\nε : Type u_4\nf : α → δ → ε\ng : β → γ → δ\nla : List α\nlb : List β\nlc : List γ\n⊢ Eq (List.zipWith f la (List.zipWith g lb lc)) (List.zipWith3 (fun a b c => f a (g b c)) la lb lc)","decl":"theorem zipWith_zipWith_right (f : α → δ → ε) (g : β → γ → δ) :\n    ∀ (la : List α) (lb : List β) (lc : List γ),\n      zipWith f la (zipWith g lb lc) = zipWith3 (fun a b c => f a (g b c)) la lb lc\n  | [], _, _ => rfl\n  | _ :: _, [], _ => rfl\n  | _ :: _, _ :: _, [] => rfl\n  | _ :: as, _ :: bs, _ :: cs => congr_arg (cons _) <| zipWith_zipWith_right f g as bs cs\n\n"}
{"name":"List.zipWith3_same_left","module":"Mathlib.Data.List.Zip","initialProofState":"α : Type u\nβ : Type u_1\nγ : Type u_2\nf : α → α → β → γ\nla : List α\nlb : List β\n⊢ Eq (List.zipWith3 f la la lb) (List.zipWith (fun a b => f a a b) la lb)","decl":"@[simp]\ntheorem zipWith3_same_left (f : α → α → β → γ) :\n    ∀ (la : List α) (lb : List β), zipWith3 f la la lb = zipWith (fun a b => f a a b) la lb\n  | [], _ => rfl\n  | _ :: _, [] => rfl\n  | _ :: as, _ :: bs => congr_arg (cons _) <| zipWith3_same_left f as bs\n\n"}
{"name":"List.zipWith3_same_mid","module":"Mathlib.Data.List.Zip","initialProofState":"α : Type u\nβ : Type u_1\nγ : Type u_2\nf : α → β → α → γ\nla : List α\nlb : List β\n⊢ Eq (List.zipWith3 f la lb la) (List.zipWith (fun a b => f a b a) la lb)","decl":"@[simp]\ntheorem zipWith3_same_mid (f : α → β → α → γ) :\n    ∀ (la : List α) (lb : List β), zipWith3 f la lb la = zipWith (fun a b => f a b a) la lb\n  | [], _ => rfl\n  | _ :: _, [] => rfl\n  | _ :: as, _ :: bs => congr_arg (cons _) <| zipWith3_same_mid f as bs\n\n"}
{"name":"List.zipWith3_same_right","module":"Mathlib.Data.List.Zip","initialProofState":"α : Type u\nβ : Type u_1\nγ : Type u_2\nf : α → β → β → γ\nla : List α\nlb : List β\n⊢ Eq (List.zipWith3 f la lb lb) (List.zipWith (fun a b => f a b b) la lb)","decl":"@[simp]\ntheorem zipWith3_same_right (f : α → β → β → γ) :\n    ∀ (la : List α) (lb : List β), zipWith3 f la lb lb = zipWith (fun a b => f a b b) la lb\n  | [], _ => rfl\n  | _ :: _, [] => rfl\n  | _ :: as, _ :: bs => congr_arg (cons _) <| zipWith3_same_right f as bs\n\n"}
{"name":"List.instIsSymmOpZipWith","module":"Mathlib.Data.List.Zip","initialProofState":"α : Type u\nβ : Type u_1\nf : α → α → β\ninst✝ : IsSymmOp f\n⊢ IsSymmOp (List.zipWith f)","decl":"instance (f : α → α → β) [IsSymmOp f] : IsSymmOp (zipWith f) :=\n  ⟨zipWith_comm_of_comm f IsSymmOp.symm_op⟩\n\n"}
{"name":"List.length_revzip","module":"Mathlib.Data.List.Zip","initialProofState":"α : Type u\nl : List α\n⊢ Eq l.revzip.length l.length","decl":"@[simp]\ntheorem length_revzip (l : List α) : length (revzip l) = length l := by\n  simp only [revzip, length_zip, length_reverse, min_self]\n\n"}
{"name":"List.unzip_revzip","module":"Mathlib.Data.List.Zip","initialProofState":"α : Type u\nl : List α\n⊢ Eq l.revzip.unzip { fst := l, snd := l.reverse }","decl":"@[simp]\ntheorem unzip_revzip (l : List α) : (revzip l).unzip = (l, l.reverse) :=\n  unzip_zip (length_reverse l).symm\n\n"}
{"name":"List.revzip_map_fst","module":"Mathlib.Data.List.Zip","initialProofState":"α : Type u\nl : List α\n⊢ Eq (List.map Prod.fst l.revzip) l","decl":"@[simp]\ntheorem revzip_map_fst (l : List α) : (revzip l).map Prod.fst = l := by\n  rw [← unzip_fst, unzip_revzip]\n\n"}
{"name":"List.revzip_map_snd","module":"Mathlib.Data.List.Zip","initialProofState":"α : Type u\nl : List α\n⊢ Eq (List.map Prod.snd l.revzip) l.reverse","decl":"@[simp]\ntheorem revzip_map_snd (l : List α) : (revzip l).map Prod.snd = l.reverse := by\n  rw [← unzip_snd, unzip_revzip]\n\n"}
{"name":"List.reverse_revzip","module":"Mathlib.Data.List.Zip","initialProofState":"α : Type u\nl : List α\n⊢ Eq l.revzip.reverse l.reverse.revzip","decl":"theorem reverse_revzip (l : List α) : reverse l.revzip = revzip l.reverse := by\n  rw [← zip_unzip (revzip l).reverse]\n  simp [unzip_eq_map, revzip, map_reverse, map_fst_zip, map_snd_zip]\n\n"}
{"name":"List.revzip_swap","module":"Mathlib.Data.List.Zip","initialProofState":"α : Type u\nl : List α\n⊢ Eq (List.map Prod.swap l.revzip) l.reverse.revzip","decl":"theorem revzip_swap (l : List α) : (revzip l).map Prod.swap = revzip l.reverse := by simp [revzip]\n\n"}
{"name":"List.get?_zipWith'","module":"Mathlib.Data.List.Zip","initialProofState":"α : Type u\nβ : Type u_1\nγ : Type u_2\nf : α → β → γ\nl₁ : List α\nl₂ : List β\ni : Nat\n⊢ Eq ((List.zipWith f l₁ l₂).get? i) ((Option.map f (l₁.get? i)).bind fun g => Option.map g (l₂.get? i))","decl":"theorem get?_zipWith' (f : α → β → γ) (l₁ : List α) (l₂ : List β) (i : ℕ) :\n    (zipWith f l₁ l₂).get? i = ((l₁.get? i).map f).bind fun g => (l₂.get? i).map g := by\n  simp [getElem?_zipWith']\n\n"}
{"name":"List.get?_zipWith_eq_some","module":"Mathlib.Data.List.Zip","initialProofState":"α : Type u\nβ : Type u_1\nγ : Type u_2\nf : α → β → γ\nl₁ : List α\nl₂ : List β\nz : γ\ni : Nat\n⊢ Iff (Eq ((List.zipWith f l₁ l₂).get? i) (Option.some z)) (Exists fun x => Exists fun y => And (Eq (l₁.get? i) (Option.some x)) (And (Eq (l₂.get? i) (Option.some y)) (Eq (f x y) z)))","decl":"theorem get?_zipWith_eq_some (f : α → β → γ) (l₁ : List α) (l₂ : List β) (z : γ) (i : ℕ) :\n    (zipWith f l₁ l₂).get? i = some z ↔\n      ∃ x y, l₁.get? i = some x ∧ l₂.get? i = some y ∧ f x y = z := by\n  simp [getElem?_zipWith_eq_some]\n\n"}
{"name":"List.get?_zip_eq_some","module":"Mathlib.Data.List.Zip","initialProofState":"α : Type u\nβ : Type u_1\nl₁ : List α\nl₂ : List β\nz : Prod α β\ni : Nat\n⊢ Iff (Eq ((l₁.zip l₂).get? i) (Option.some z)) (And (Eq (l₁.get? i) (Option.some z.fst)) (Eq (l₂.get? i) (Option.some z.snd)))","decl":"theorem get?_zip_eq_some (l₁ : List α) (l₂ : List β) (z : α × β) (i : ℕ) :\n    (zip l₁ l₂).get? i = some z ↔ l₁.get? i = some z.1 ∧ l₂.get? i = some z.2 := by\n  simp [getElem?_zip_eq_some]\n\n"}
{"name":"List.mem_zip_inits_tails","module":"Mathlib.Data.List.Zip","initialProofState":"α : Type u\nl init tail : List α\n⊢ Iff (Membership.mem (l.inits.zip l.tails) { fst := init, snd := tail }) (Eq (HAppend.hAppend init tail) l)","decl":"theorem mem_zip_inits_tails {l : List α} {init tail : List α} :\n    (init, tail) ∈ zip l.inits l.tails ↔ init ++ tail = l := by\n  induction' l with hd tl ih generalizing init tail <;> simp_rw [tails, inits, zip_cons_cons]\n  · simp\n  · constructor <;> rw [mem_cons, zip_map_left, mem_map, Prod.exists]\n    · rintro (⟨rfl, rfl⟩ | ⟨_, _, h, rfl, rfl⟩)\n      · simp\n      · simp [ih.mp h]\n    · cases' init with hd' tl'\n      · rintro rfl\n        simp\n      · intro h\n        right\n        use tl', tail\n        simp_all\n\n"}
