{"name":"CategoryTheory.Adjunction.unit_mono_of_L_faithful","module":"Mathlib.CategoryTheory.Adjunction.FullyFaithful","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nh : CategoryTheory.Adjunction L R\ninst✝ : L.Faithful\nX : C\n⊢ CategoryTheory.Mono (h.unit.app X)","decl":"/-- If the left adjoint is faithful, then each component of the unit is an monomorphism. -/\ninstance unit_mono_of_L_faithful [L.Faithful] (X : C) : Mono (h.unit.app X) where\n  right_cancellation {Y} f g hfg :=\n    L.map_injective <| (h.homEquiv Y (L.obj X)).injective <| by simpa using hfg\n\n"}
{"name":"CategoryTheory.Adjunction.unit_isSplitEpi_of_L_full","module":"Mathlib.CategoryTheory.Adjunction.FullyFaithful","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nh : CategoryTheory.Adjunction L R\ninst✝ : L.Full\nX : C\n⊢ CategoryTheory.IsSplitEpi (h.unit.app X)","decl":"/-- If the right adjoint is full, then each component of the counit is a split monomorphism. -/\ninstance unit_isSplitEpi_of_L_full [L.Full] (X : C) : IsSplitEpi (h.unit.app X) :=\n  ⟨⟨h.unitSplitEpiOfLFull X⟩⟩\n\n"}
{"name":"CategoryTheory.Adjunction.instIsIsoAppUnitOfFullOfFaithful","module":"Mathlib.CategoryTheory.Adjunction.FullyFaithful","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nh : CategoryTheory.Adjunction L R\ninst✝¹ : L.Full\ninst✝ : L.Faithful\nX : C\n⊢ CategoryTheory.IsIso (h.unit.app X)","decl":"instance [L.Full] [L.Faithful] (X : C) : IsIso (h.unit.app X) :=\n  isIso_of_mono_of_isSplitEpi _\n\n"}
{"name":"CategoryTheory.Adjunction.unit_isIso_of_L_fully_faithful","module":"Mathlib.CategoryTheory.Adjunction.FullyFaithful","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nh : CategoryTheory.Adjunction L R\ninst✝¹ : L.Full\ninst✝ : L.Faithful\n⊢ CategoryTheory.IsIso h.unit","decl":"/-- If the left adjoint is fully faithful, then the unit is an isomorphism. -/\ninstance unit_isIso_of_L_fully_faithful [L.Full] [L.Faithful] : IsIso (Adjunction.unit h) :=\n  NatIso.isIso_of_isIso_app _\n\n"}
{"name":"CategoryTheory.Adjunction.counit_epi_of_R_faithful","module":"Mathlib.CategoryTheory.Adjunction.FullyFaithful","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nh : CategoryTheory.Adjunction L R\ninst✝ : R.Faithful\nX : D\n⊢ CategoryTheory.Epi (h.counit.app X)","decl":"/-- If the right adjoint is faithful, then each component of the counit is an epimorphism.-/\ninstance counit_epi_of_R_faithful [R.Faithful] (X : D) : Epi (h.counit.app X) where\n  left_cancellation {Y} f g hfg :=\n    R.map_injective <| (h.homEquiv (R.obj X) Y).symm.injective <| by simpa using hfg\n\n"}
{"name":"CategoryTheory.Adjunction.counit_isSplitMono_of_R_full","module":"Mathlib.CategoryTheory.Adjunction.FullyFaithful","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nh : CategoryTheory.Adjunction L R\ninst✝ : R.Full\nX : D\n⊢ CategoryTheory.IsSplitMono (h.counit.app X)","decl":"/-- If the right adjoint is full, then each component of the counit is a split monomorphism. -/\ninstance counit_isSplitMono_of_R_full [R.Full] (X : D) : IsSplitMono (h.counit.app X) :=\n  ⟨⟨h.counitSplitMonoOfRFull X⟩⟩\n\n"}
{"name":"CategoryTheory.Adjunction.instIsIsoAppCounitOfFullOfFaithful","module":"Mathlib.CategoryTheory.Adjunction.FullyFaithful","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nh : CategoryTheory.Adjunction L R\ninst✝¹ : R.Full\ninst✝ : R.Faithful\nX : D\n⊢ CategoryTheory.IsIso (h.counit.app X)","decl":"instance [R.Full] [R.Faithful] (X : D) : IsIso (h.counit.app X) :=\n  isIso_of_epi_of_isSplitMono _\n\n"}
{"name":"CategoryTheory.Adjunction.counit_isIso_of_R_fully_faithful","module":"Mathlib.CategoryTheory.Adjunction.FullyFaithful","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nh : CategoryTheory.Adjunction L R\ninst✝¹ : R.Full\ninst✝ : R.Faithful\n⊢ CategoryTheory.IsIso h.counit","decl":"/-- If the right adjoint is fully faithful, then the counit is an isomorphism. -/\ninstance counit_isIso_of_R_fully_faithful [R.Full] [R.Faithful] : IsIso (Adjunction.counit h) :=\n  NatIso.isIso_of_isIso_app _\n\n"}
{"name":"CategoryTheory.Adjunction.inv_map_unit","module":"Mathlib.CategoryTheory.Adjunction.FullyFaithful","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nh : CategoryTheory.Adjunction L R\nX : C\ninst✝ : CategoryTheory.IsIso (h.unit.app X)\n⊢ Eq (CategoryTheory.inv (L.map (h.unit.app X))) (h.counit.app (L.obj X))","decl":"/-- If the unit of an adjunction is an isomorphism, then its inverse on the image of L is given\nby L whiskered with the counit. -/\n@[simp]\ntheorem inv_map_unit {X : C} [IsIso (h.unit.app X)] :\n    inv (L.map (h.unit.app X)) = h.counit.app (L.obj X) :=\n  IsIso.inv_eq_of_hom_inv_id (h.left_triangle_components X)\n\n"}
{"name":"CategoryTheory.Adjunction.whiskerLeftLCounitIsoOfIsIsoUnit_inv_app","module":"Mathlib.CategoryTheory.Adjunction.FullyFaithful","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nh : CategoryTheory.Adjunction L R\ninst✝ : CategoryTheory.IsIso h.unit\nX : C\n⊢ Eq (h.whiskerLeftLCounitIsoOfIsIsoUnit.inv.app X) (L.map (h.unit.app X))","decl":"/-- If the unit is an isomorphism, bundle one has an isomorphism `L ⋙ R ⋙ L ≅ L`. -/\n@[simps!]\nnoncomputable def whiskerLeftLCounitIsoOfIsIsoUnit [IsIso h.unit] : L ⋙ R ⋙ L ≅ L :=\n  (L.associator R L).symm ≪≫ isoWhiskerRight (asIso h.unit).symm L ≪≫ Functor.leftUnitor _\n\n"}
{"name":"CategoryTheory.Adjunction.whiskerLeftLCounitIsoOfIsIsoUnit_hom_app","module":"Mathlib.CategoryTheory.Adjunction.FullyFaithful","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nh : CategoryTheory.Adjunction L R\ninst✝ : CategoryTheory.IsIso h.unit\nX : C\n⊢ Eq (h.whiskerLeftLCounitIsoOfIsIsoUnit.hom.app X) (h.counit.app (L.obj X))","decl":"/-- If the unit is an isomorphism, bundle one has an isomorphism `L ⋙ R ⋙ L ≅ L`. -/\n@[simps!]\nnoncomputable def whiskerLeftLCounitIsoOfIsIsoUnit [IsIso h.unit] : L ⋙ R ⋙ L ≅ L :=\n  (L.associator R L).symm ≪≫ isoWhiskerRight (asIso h.unit).symm L ≪≫ Functor.leftUnitor _\n\n"}
{"name":"CategoryTheory.Adjunction.inv_counit_map","module":"Mathlib.CategoryTheory.Adjunction.FullyFaithful","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nh : CategoryTheory.Adjunction L R\nX : D\ninst✝ : CategoryTheory.IsIso (h.counit.app X)\n⊢ Eq (CategoryTheory.inv (R.map (h.counit.app X))) (h.unit.app (R.obj X))","decl":"/-- If the counit of an adjunction is an isomorphism, then its inverse on the image of R is given\nby R whiskered with the unit. -/\n@[simp]\ntheorem inv_counit_map {X : D} [IsIso (h.counit.app X)] :\n    inv (R.map (h.counit.app X)) = h.unit.app (R.obj X) :=\n  IsIso.inv_eq_of_inv_hom_id (h.right_triangle_components X)\n\n"}
{"name":"CategoryTheory.Adjunction.whiskerLeftRUnitIsoOfIsIsoCounit_hom_app","module":"Mathlib.CategoryTheory.Adjunction.FullyFaithful","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nh : CategoryTheory.Adjunction L R\ninst✝ : CategoryTheory.IsIso h.counit\nX : D\n⊢ Eq (h.whiskerLeftRUnitIsoOfIsIsoCounit.hom.app X) (R.map (h.counit.app X))","decl":"/-- If the counit of an is an isomorphism, one has an isomorphism `(R ⋙ L ⋙ R) ≅ R`. -/\n@[simps!]\nnoncomputable def whiskerLeftRUnitIsoOfIsIsoCounit [IsIso h.counit] : R ⋙ L ⋙ R ≅ R :=\n  (R.associator L R).symm ≪≫ isoWhiskerRight (asIso h.counit) R ≪≫ Functor.leftUnitor _\n\n"}
{"name":"CategoryTheory.Adjunction.whiskerLeftRUnitIsoOfIsIsoCounit_inv_app","module":"Mathlib.CategoryTheory.Adjunction.FullyFaithful","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nh : CategoryTheory.Adjunction L R\ninst✝ : CategoryTheory.IsIso h.counit\nX : D\n⊢ Eq (h.whiskerLeftRUnitIsoOfIsIsoCounit.inv.app X) (h.unit.app (R.obj X))","decl":"/-- If the counit of an is an isomorphism, one has an isomorphism `(R ⋙ L ⋙ R) ≅ R`. -/\n@[simps!]\nnoncomputable def whiskerLeftRUnitIsoOfIsIsoCounit [IsIso h.counit] : R ⋙ L ⋙ R ≅ R :=\n  (R.associator L R).symm ≪≫ isoWhiskerRight (asIso h.counit) R ≪≫ Functor.leftUnitor _\n\n"}
{"name":"CategoryTheory.Adjunction.faithful_L_of_mono_unit_app","module":"Mathlib.CategoryTheory.Adjunction.FullyFaithful","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nh : CategoryTheory.Adjunction L R\ninst✝ : ∀ (X : C), CategoryTheory.Mono (h.unit.app X)\n⊢ L.Faithful","decl":"/-- If each component of the unit is a monomorphism, then the left adjoint is faithful. -/\nlemma faithful_L_of_mono_unit_app [∀ X, Mono (h.unit.app X)] : L.Faithful where\n  map_injective {X Y f g} hfg := by\n    apply Mono.right_cancellation (f := h.unit.app Y)\n    apply (h.homEquiv X (L.obj Y)).symm.injective\n    simpa using hfg\n\n"}
{"name":"CategoryTheory.Adjunction.full_L_of_isSplitEpi_unit_app","module":"Mathlib.CategoryTheory.Adjunction.FullyFaithful","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nh : CategoryTheory.Adjunction L R\ninst✝ : ∀ (X : C), CategoryTheory.IsSplitEpi (h.unit.app X)\n⊢ L.Full","decl":"/-- If each component of the unit is a split epimorphism, then the left adjoint is full. -/\nlemma full_L_of_isSplitEpi_unit_app [∀ X, IsSplitEpi (h.unit.app X)] : L.Full where\n  map_surjective {X Y} f := by\n    use ((h.homEquiv X (L.obj Y)) f ≫ section_ (h.unit.app Y))\n    suffices L.map (section_ (h.unit.app Y)) = h.counit.app (L.obj Y) by simp [this]\n    rw [← comp_id (L.map (section_ (h.unit.app Y)))]\n    simp only [Functor.comp_obj, Functor.id_obj, comp_id, ← h.left_triangle_components Y,\n      ← assoc, ← Functor.map_comp, IsSplitEpi.id, Functor.map_id, id_comp]\n\n"}
{"name":"CategoryTheory.Adjunction.faithful_R_of_epi_counit_app","module":"Mathlib.CategoryTheory.Adjunction.FullyFaithful","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nh : CategoryTheory.Adjunction L R\ninst✝ : ∀ (X : D), CategoryTheory.Epi (h.counit.app X)\n⊢ R.Faithful","decl":"/-- If each component of the counit is an epimorphism, then the right adjoint is faithful. -/\nlemma faithful_R_of_epi_counit_app [∀ X, Epi (h.counit.app X)] : R.Faithful where\n  map_injective {X Y f g} hfg := by\n    apply Epi.left_cancellation (f := h.counit.app X)\n    apply (h.homEquiv (R.obj X) Y).injective\n    simpa using hfg\n\n"}
{"name":"CategoryTheory.Adjunction.full_R_of_isSplitMono_counit_app","module":"Mathlib.CategoryTheory.Adjunction.FullyFaithful","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nh : CategoryTheory.Adjunction L R\ninst✝ : ∀ (X : D), CategoryTheory.IsSplitMono (h.counit.app X)\n⊢ R.Full","decl":"/-- If each component of the counit is a split monomorphism, then the right adjoint is full. -/\nlemma full_R_of_isSplitMono_counit_app [∀ X, IsSplitMono (h.counit.app X)] : R.Full where\n  map_surjective {X Y} f := by\n    use (retraction (h.counit.app X) ≫ (h.homEquiv (R.obj X) Y).symm f)\n    suffices R.map (retraction (h.counit.app X)) = h.unit.app (R.obj X) by simp [this]\n    rw [← id_comp (R.map (retraction (h.counit.app X)))]\n    simp only [Functor.id_obj, Functor.comp_obj, id_comp, ← h.right_triangle_components X,\n      assoc, ← Functor.map_comp, IsSplitMono.id, Functor.map_id, comp_id]\n\n"}
{"name":"CategoryTheory.Adjunction.whiskerLeft_counit_iso_of_L_fully_faithful","module":"Mathlib.CategoryTheory.Adjunction.FullyFaithful","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nh : CategoryTheory.Adjunction L R\ninst✝¹ : L.Full\ninst✝ : L.Faithful\n⊢ CategoryTheory.IsIso (CategoryTheory.whiskerLeft L h.counit)","decl":"instance whiskerLeft_counit_iso_of_L_fully_faithful [L.Full] [L.Faithful] :\n    IsIso (whiskerLeft L h.counit) := by\n  have := h.left_triangle\n  rw [← IsIso.eq_inv_comp] at this\n  rw [this]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Adjunction.whiskerRight_counit_iso_of_L_fully_faithful","module":"Mathlib.CategoryTheory.Adjunction.FullyFaithful","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nh : CategoryTheory.Adjunction L R\ninst✝¹ : L.Full\ninst✝ : L.Faithful\n⊢ CategoryTheory.IsIso (CategoryTheory.whiskerRight h.counit R)","decl":"instance whiskerRight_counit_iso_of_L_fully_faithful [L.Full] [L.Faithful] :\n    IsIso (whiskerRight h.counit R) := by\n  have := h.right_triangle\n  rw [← IsIso.eq_inv_comp] at this\n  rw [this]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Adjunction.whiskerLeft_unit_iso_of_R_fully_faithful","module":"Mathlib.CategoryTheory.Adjunction.FullyFaithful","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nh : CategoryTheory.Adjunction L R\ninst✝¹ : R.Full\ninst✝ : R.Faithful\n⊢ CategoryTheory.IsIso (CategoryTheory.whiskerLeft R h.unit)","decl":"instance whiskerLeft_unit_iso_of_R_fully_faithful [R.Full] [R.Faithful] :\n    IsIso (whiskerLeft R h.unit) := by\n  have := h.right_triangle\n  rw [← IsIso.eq_comp_inv] at this\n  rw [this]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Adjunction.whiskerRight_unit_iso_of_R_fully_faithful","module":"Mathlib.CategoryTheory.Adjunction.FullyFaithful","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nh : CategoryTheory.Adjunction L R\ninst✝¹ : R.Full\ninst✝ : R.Faithful\n⊢ CategoryTheory.IsIso (CategoryTheory.whiskerRight h.unit L)","decl":"instance whiskerRight_unit_iso_of_R_fully_faithful [R.Full] [R.Faithful] :\n    IsIso (whiskerRight h.unit L) := by\n  have := h.left_triangle\n  rw [← IsIso.eq_comp_inv] at this\n  rw [this]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Adjunction.instIsIsoAppCounitObjOfFaithfulOfFull","module":"Mathlib.CategoryTheory.Adjunction.FullyFaithful","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nh : CategoryTheory.Adjunction L R\ninst✝¹ : L.Faithful\ninst✝ : L.Full\nY : C\n⊢ CategoryTheory.IsIso (h.counit.app (L.obj Y))","decl":"instance [L.Faithful] [L.Full] {Y : C} : IsIso (h.counit.app (L.obj Y)) :=\n  isIso_of_hom_comp_eq_id _ (h.left_triangle_components Y)\n\n"}
{"name":"CategoryTheory.Adjunction.instIsIsoMapAppCounitOfFaithfulOfFull","module":"Mathlib.CategoryTheory.Adjunction.FullyFaithful","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nh : CategoryTheory.Adjunction L R\ninst✝¹ : L.Faithful\ninst✝ : L.Full\nY : D\n⊢ CategoryTheory.IsIso (R.map (h.counit.app Y))","decl":"instance [L.Faithful] [L.Full] {Y : D} : IsIso (R.map (h.counit.app Y)) :=\n  isIso_of_hom_comp_eq_id _ (h.right_triangle_components Y)\n\n"}
{"name":"CategoryTheory.Adjunction.isIso_counit_app_iff_mem_essImage","module":"Mathlib.CategoryTheory.Adjunction.FullyFaithful","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nh : CategoryTheory.Adjunction L R\ninst✝¹ : L.Faithful\ninst✝ : L.Full\nX : D\n⊢ Iff (CategoryTheory.IsIso (h.counit.app X)) (Membership.mem L.essImage X)","decl":"lemma isIso_counit_app_iff_mem_essImage [L.Faithful] [L.Full] {X : D} :\n    IsIso (h.counit.app X) ↔ X ∈ L.essImage := by\n  constructor\n  · intro\n    exact ⟨R.obj X, ⟨asIso (h.counit.app X)⟩⟩\n  · rintro ⟨_, ⟨i⟩⟩\n    rw [NatTrans.isIso_app_iff_of_iso _ i.symm]\n    infer_instance\n\n"}
{"name":"CategoryTheory.Adjunction.mem_essImage_of_counit_isIso","module":"Mathlib.CategoryTheory.Adjunction.FullyFaithful","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nh : CategoryTheory.Adjunction L R\nA : D\ninst✝ : CategoryTheory.IsIso (h.counit.app A)\n⊢ Membership.mem L.essImage A","decl":"lemma mem_essImage_of_counit_isIso (A : D)\n    [IsIso (h.counit.app A)] : A ∈ L.essImage :=\n  ⟨R.obj A, ⟨asIso (h.counit.app A)⟩⟩\n\n"}
{"name":"CategoryTheory.Adjunction.isIso_counit_app_of_iso","module":"Mathlib.CategoryTheory.Adjunction.FullyFaithful","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nh : CategoryTheory.Adjunction L R\ninst✝¹ : L.Faithful\ninst✝ : L.Full\nX : D\nY : C\ne : CategoryTheory.Iso X (L.obj Y)\n⊢ CategoryTheory.IsIso (h.counit.app X)","decl":"lemma isIso_counit_app_of_iso [L.Faithful] [L.Full] {X : D} {Y : C} (e : X ≅ L.obj Y) :\n    IsIso (h.counit.app X) :=\n  (isIso_counit_app_iff_mem_essImage h).mpr ⟨Y, ⟨e.symm⟩⟩\n\n"}
{"name":"CategoryTheory.Adjunction.instIsIsoAppUnitObjOfFaithfulOfFull","module":"Mathlib.CategoryTheory.Adjunction.FullyFaithful","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nh : CategoryTheory.Adjunction L R\ninst✝¹ : R.Faithful\ninst✝ : R.Full\nY : D\n⊢ CategoryTheory.IsIso (h.unit.app (R.obj Y))","decl":"instance [R.Faithful] [R.Full] {Y : D} : IsIso (h.unit.app (R.obj Y)) :=\n  isIso_of_comp_hom_eq_id _ (h.right_triangle_components Y)\n\n"}
{"name":"CategoryTheory.Adjunction.instIsIsoMapAppUnitOfFaithfulOfFull","module":"Mathlib.CategoryTheory.Adjunction.FullyFaithful","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nh : CategoryTheory.Adjunction L R\ninst✝¹ : R.Faithful\ninst✝ : R.Full\nX : C\n⊢ CategoryTheory.IsIso (L.map (h.unit.app X))","decl":"instance [R.Faithful] [R.Full] {X : C} : IsIso (L.map (h.unit.app X)) :=\n  isIso_of_comp_hom_eq_id _ (h.left_triangle_components X)\n\n"}
{"name":"CategoryTheory.Adjunction.isIso_unit_app_iff_mem_essImage","module":"Mathlib.CategoryTheory.Adjunction.FullyFaithful","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nh : CategoryTheory.Adjunction L R\ninst✝¹ : R.Faithful\ninst✝ : R.Full\nY : C\n⊢ Iff (CategoryTheory.IsIso (h.unit.app Y)) (Membership.mem R.essImage Y)","decl":"lemma isIso_unit_app_iff_mem_essImage [R.Faithful] [R.Full] {Y : C} :\n    IsIso (h.unit.app Y) ↔ Y ∈ R.essImage := by\n  constructor\n  · intro\n    exact ⟨L.obj Y, ⟨(asIso (h.unit.app Y)).symm⟩⟩\n  · rintro ⟨_, ⟨i⟩⟩\n    rw [NatTrans.isIso_app_iff_of_iso _ i.symm]\n    infer_instance\n\n"}
{"name":"CategoryTheory.Adjunction.mem_essImage_of_unit_isIso","module":"Mathlib.CategoryTheory.Adjunction.FullyFaithful","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nh : CategoryTheory.Adjunction L R\nA : C\ninst✝ : CategoryTheory.IsIso (h.unit.app A)\n⊢ Membership.mem R.essImage A","decl":"/-- If `η_A` is an isomorphism, then `A` is in the essential image of `i`. -/\ntheorem mem_essImage_of_unit_isIso (A : C)\n    [IsIso (h.unit.app A)] : A ∈ R.essImage :=\n  ⟨L.obj A, ⟨(asIso (h.unit.app A)).symm⟩⟩\n\n"}
{"name":"CategoryTheory.Adjunction.isIso_unit_app_of_iso","module":"Mathlib.CategoryTheory.Adjunction.FullyFaithful","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nh : CategoryTheory.Adjunction L R\ninst✝¹ : R.Faithful\ninst✝ : R.Full\nX : D\nY : C\ne : CategoryTheory.Iso Y (R.obj X)\n⊢ CategoryTheory.IsIso (h.unit.app Y)","decl":"lemma isIso_unit_app_of_iso [R.Faithful] [R.Full] {X : D} {Y : C} (e : Y ≅ R.obj X) :\n    IsIso (h.unit.app Y) :=\n  (isIso_unit_app_iff_mem_essImage h).mpr ⟨X, ⟨e.symm⟩⟩\n\n"}
{"name":"CategoryTheory.Adjunction.instIsIsoFunctorUnitOfIsEquivalence","module":"Mathlib.CategoryTheory.Adjunction.FullyFaithful","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nh : CategoryTheory.Adjunction L R\ninst✝ : R.IsEquivalence\n⊢ CategoryTheory.IsIso h.unit","decl":"instance [R.IsEquivalence] : IsIso h.unit := by\n  have := fun Y => isIso_unit_app_of_iso h (R.objObjPreimageIso Y).symm\n  apply NatIso.isIso_of_isIso_app\n\n"}
{"name":"CategoryTheory.Adjunction.instIsIsoFunctorCounitOfIsEquivalence","module":"Mathlib.CategoryTheory.Adjunction.FullyFaithful","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nh : CategoryTheory.Adjunction L R\ninst✝ : L.IsEquivalence\n⊢ CategoryTheory.IsIso h.counit","decl":"instance [L.IsEquivalence] : IsIso h.counit := by\n  have := fun X => isIso_counit_app_of_iso h (L.objObjPreimageIso X).symm\n  apply NatIso.isIso_of_isIso_app\n\n"}
{"name":"CategoryTheory.Adjunction.isEquivalence_left_of_isEquivalence_right","module":"Mathlib.CategoryTheory.Adjunction.FullyFaithful","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nh : CategoryTheory.Adjunction L R\ninst✝ : R.IsEquivalence\n⊢ L.IsEquivalence","decl":"lemma isEquivalence_left_of_isEquivalence_right (h : L ⊣ R) [R.IsEquivalence] : L.IsEquivalence :=\n  h.toEquivalence.isEquivalence_functor\n\n"}
{"name":"CategoryTheory.Adjunction.isEquivalence_right_of_isEquivalence_left","module":"Mathlib.CategoryTheory.Adjunction.FullyFaithful","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nh : CategoryTheory.Adjunction L R\ninst✝ : L.IsEquivalence\n⊢ R.IsEquivalence","decl":"lemma isEquivalence_right_of_isEquivalence_left (h : L ⊣ R) [L.IsEquivalence] : R.IsEquivalence :=\n  h.toEquivalence.isEquivalence_inverse\n\n"}
{"name":"CategoryTheory.Adjunction.instIsIsoFunctorUnitOfIsEquivalence_1","module":"Mathlib.CategoryTheory.Adjunction.FullyFaithful","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nh : CategoryTheory.Adjunction L R\ninst✝ : L.IsEquivalence\n⊢ CategoryTheory.IsIso h.unit","decl":"instance [L.IsEquivalence] : IsIso h.unit := by\n  have := h.isEquivalence_right_of_isEquivalence_left\n  infer_instance\n\n"}
{"name":"CategoryTheory.Adjunction.instIsIsoFunctorCounitOfIsEquivalence_1","module":"Mathlib.CategoryTheory.Adjunction.FullyFaithful","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nh : CategoryTheory.Adjunction L R\ninst✝ : R.IsEquivalence\n⊢ CategoryTheory.IsIso h.counit","decl":"instance [R.IsEquivalence] : IsIso h.counit := by\n  have := h.isEquivalence_left_of_isEquivalence_right\n  infer_instance\n\n"}
