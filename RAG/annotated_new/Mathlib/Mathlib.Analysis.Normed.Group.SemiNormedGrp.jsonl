{"name":"SemiNormedGrp.toAddMonoidHomClass","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp","initialProofState":"V W : SemiNormedGrp\n⊢ AddMonoidHomClass (Quiver.Hom V W) ↑V ↑W","decl":"instance toAddMonoidHomClass {V W : SemiNormedGrp} : AddMonoidHomClass (V ⟶ W) V W where\n  map_add f := f.map_add'\n  map_zero f := (AddMonoidHom.mk' f.toFun f.map_add').map_zero\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/10688): added to ease automation\n"}
{"name":"SemiNormedGrp.ext","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp","initialProofState":"M N : SemiNormedGrp\nf₁ f₂ : Quiver.Hom M N\nh : ∀ (x : ↑M), Eq (f₁ x) (f₂ x)\n⊢ Eq f₁ f₂","decl":"@[ext]\nlemma ext {M N : SemiNormedGrp} {f₁ f₂ : M ⟶ N} (h : ∀ (x : M), f₁ x = f₂ x) : f₁ = f₂ :=\n  DFunLike.ext _ _ h\n\n"}
{"name":"SemiNormedGrp.ext_iff","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp","initialProofState":"M N : SemiNormedGrp\nf₁ f₂ : Quiver.Hom M N\n⊢ Iff (Eq f₁ f₂) (∀ (x : ↑M), Eq (f₁ x) (f₂ x))","decl":"@[ext]\nlemma ext {M N : SemiNormedGrp} {f₁ f₂ : M ⟶ N} (h : ∀ (x : M), f₁ x = f₂ x) : f₁ = f₂ :=\n  DFunLike.ext _ _ h\n\n"}
{"name":"SemiNormedGrp.coe_of","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp","initialProofState":"V : Type u\ninst✝ : SeminormedAddCommGroup V\n⊢ Eq (↑(SemiNormedGrp.of V)) V","decl":"@[simp]\ntheorem coe_of (V : Type u) [SeminormedAddCommGroup V] : (SemiNormedGrp.of V : Type u) = V :=\n  rfl\n\n-- Porting note: marked with high priority to short circuit simplifier's path\n"}
{"name":"SemiNormedGrp.coe_id","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp","initialProofState":"V : SemiNormedGrp\n⊢ Eq (⇑(CategoryTheory.CategoryStruct.id V)) id","decl":"@[simp (high)]\ntheorem coe_id (V : SemiNormedGrp) : (𝟙 V : V → V) = id :=\n  rfl\n\n-- Porting note: marked with high priority to short circuit simplifier's path\n"}
{"name":"SemiNormedGrp.coe_comp","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp","initialProofState":"M N K : SemiNormedGrp\nf : Quiver.Hom M N\ng : Quiver.Hom N K\n⊢ Eq (⇑(CategoryTheory.CategoryStruct.comp f g)) (Function.comp ⇑g ⇑f)","decl":"@[simp (high)]\ntheorem coe_comp {M N K : SemiNormedGrp} (f : M ⟶ N) (g : N ⟶ K) :\n    (f ≫ g : M → K) = g ∘ f :=\n  rfl\n\n"}
{"name":"SemiNormedGrp.zero_apply","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp","initialProofState":"V W : SemiNormedGrp\nx : ↑V\n⊢ Eq (0 x) 0","decl":"@[simp]\ntheorem zero_apply {V W : SemiNormedGrp} (x : V) : (0 : V ⟶ W) x = 0 :=\n  rfl\n\n"}
{"name":"SemiNormedGrp.isZero_of_subsingleton","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp","initialProofState":"V : SemiNormedGrp\ninst✝ : Subsingleton ↑V\n⊢ CategoryTheory.Limits.IsZero V","decl":"theorem isZero_of_subsingleton (V : SemiNormedGrp) [Subsingleton V] : Limits.IsZero V := by\n  refine ⟨fun X => ⟨⟨⟨0⟩, fun f => ?_⟩⟩, fun X => ⟨⟨⟨0⟩, fun f => ?_⟩⟩⟩\n  · ext x; have : x = 0 := Subsingleton.elim _ _; simp only [this, map_zero]\n  · ext; apply Subsingleton.elim\n\n"}
{"name":"SemiNormedGrp.hasZeroObject","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp","initialProofState":"⊢ CategoryTheory.Limits.HasZeroObject SemiNormedGrp","decl":"instance hasZeroObject : Limits.HasZeroObject SemiNormedGrp.{u} :=\n  ⟨⟨of PUnit, isZero_of_subsingleton _⟩⟩\n\n"}
{"name":"SemiNormedGrp.iso_isometry_of_normNoninc","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp","initialProofState":"V W : SemiNormedGrp\ni : CategoryTheory.Iso V W\nh1 : NormedAddGroupHom.NormNoninc i.hom\nh2 : NormedAddGroupHom.NormNoninc i.inv\n⊢ Isometry ⇑i.hom","decl":"theorem iso_isometry_of_normNoninc {V W : SemiNormedGrp} (i : V ≅ W) (h1 : i.hom.NormNoninc)\n    (h2 : i.inv.NormNoninc) : Isometry i.hom := by\n  apply AddMonoidHomClass.isometry_of_norm\n  intro v\n  apply le_antisymm (h1 v)\n  calc\n    ‖v‖ = ‖i.inv (i.hom v)‖ := by rw [Iso.hom_inv_id_apply]\n    _ ≤ ‖i.hom v‖ := h2 _\n\n"}
{"name":"SemiNormedGrp₁.hom_ext","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp","initialProofState":"M N : SemiNormedGrp₁\nf g : Quiver.Hom M N\nw : Eq ⇑f ⇑g\n⊢ Eq f g","decl":"@[ext]\ntheorem hom_ext {M N : SemiNormedGrp₁} (f g : M ⟶ N) (w : (f : M → N) = (g : M → N)) :\n    f = g :=\n  Subtype.eq (NormedAddGroupHom.ext (congr_fun w))\n\n"}
{"name":"SemiNormedGrp₁.hom_ext_iff","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp","initialProofState":"M N : SemiNormedGrp₁\nf g : Quiver.Hom M N\n⊢ Iff (Eq f g) (Eq ⇑f ⇑g)","decl":"@[ext]\ntheorem hom_ext {M N : SemiNormedGrp₁} (f g : M ⟶ N) (w : (f : M → N) = (g : M → N)) :\n    f = g :=\n  Subtype.eq (NormedAddGroupHom.ext (congr_fun w))\n\n"}
{"name":"SemiNormedGrp₁.toAddMonoidHomClass","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp","initialProofState":"V W : SemiNormedGrp₁\n⊢ AddMonoidHomClass (Quiver.Hom V W) ↑V ↑W","decl":"instance toAddMonoidHomClass {V W : SemiNormedGrp₁} : AddMonoidHomClass (V ⟶ W) V W where\n  map_add f := f.1.map_add'\n  map_zero f := (AddMonoidHom.mk' f.1 f.1.map_add').map_zero\n\n"}
{"name":"SemiNormedGrp₁.mkHom_apply","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp","initialProofState":"M N : SemiNormedGrp\nf : Quiver.Hom M N\ni : NormedAddGroupHom.NormNoninc f\nx : ↑(SemiNormedGrp₁.of ↑M)\n⊢ Eq ((SemiNormedGrp₁.mkHom f i) x) (f x)","decl":"theorem mkHom_apply {M N : SemiNormedGrp} (f : M ⟶ N) (i : f.NormNoninc) (x) :\n    mkHom f i x = f x :=\n  rfl\n\n"}
{"name":"SemiNormedGrp₁.mkIso_hom","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp","initialProofState":"M N : SemiNormedGrp\nf : CategoryTheory.Iso M N\ni : NormedAddGroupHom.NormNoninc f.hom\ni' : NormedAddGroupHom.NormNoninc f.inv\n⊢ Eq (SemiNormedGrp₁.mkIso f i i').hom (SemiNormedGrp₁.mkHom f.hom i)","decl":"/-- Promote an isomorphism in `SemiNormedGrp` to an isomorphism in `SemiNormedGrp₁`. -/\n@[simps]\ndef mkIso {M N : SemiNormedGrp} (f : M ≅ N) (i : f.hom.NormNoninc) (i' : f.inv.NormNoninc) :\n    SemiNormedGrp₁.of M ≅ SemiNormedGrp₁.of N where\n  hom := mkHom f.hom i\n  inv := mkHom f.inv i'\n  hom_inv_id := by apply Subtype.eq; exact f.hom_inv_id\n  inv_hom_id := by apply Subtype.eq; exact f.inv_hom_id\n\n"}
{"name":"SemiNormedGrp₁.mkIso_inv","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp","initialProofState":"M N : SemiNormedGrp\nf : CategoryTheory.Iso M N\ni : NormedAddGroupHom.NormNoninc f.hom\ni' : NormedAddGroupHom.NormNoninc f.inv\n⊢ Eq (SemiNormedGrp₁.mkIso f i i').inv (SemiNormedGrp₁.mkHom f.inv i')","decl":"/-- Promote an isomorphism in `SemiNormedGrp` to an isomorphism in `SemiNormedGrp₁`. -/\n@[simps]\ndef mkIso {M N : SemiNormedGrp} (f : M ≅ N) (i : f.hom.NormNoninc) (i' : f.inv.NormNoninc) :\n    SemiNormedGrp₁.of M ≅ SemiNormedGrp₁.of N where\n  hom := mkHom f.hom i\n  inv := mkHom f.inv i'\n  hom_inv_id := by apply Subtype.eq; exact f.hom_inv_id\n  inv_hom_id := by apply Subtype.eq; exact f.inv_hom_id\n\n"}
{"name":"SemiNormedGrp₁.coe_of","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp","initialProofState":"V : Type u\ninst✝ : SeminormedAddCommGroup V\n⊢ Eq (↑(SemiNormedGrp₁.of V)) V","decl":"@[simp]\ntheorem coe_of (V : Type u) [SeminormedAddCommGroup V] : (SemiNormedGrp₁.of V : Type u) = V :=\n  rfl\n\n-- Porting note: marked with high priority to short circuit simplifier's path\n"}
{"name":"SemiNormedGrp₁.coe_id","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp","initialProofState":"V : SemiNormedGrp₁\n⊢ Eq (⇑(CategoryTheory.CategoryStruct.id V)) id","decl":"@[simp (high)]\ntheorem coe_id (V : SemiNormedGrp₁) : ⇑(𝟙 V) = id :=\n  rfl\n\n-- Porting note: marked with high priority to short circuit simplifier's path\n"}
{"name":"SemiNormedGrp₁.coe_comp","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp","initialProofState":"M N K : SemiNormedGrp₁\nf : Quiver.Hom M N\ng : Quiver.Hom N K\n⊢ Eq (⇑(CategoryTheory.CategoryStruct.comp f g)) (Function.comp ⇑g ⇑f)","decl":"@[simp (high)]\ntheorem coe_comp {M N K : SemiNormedGrp₁} (f : M ⟶ N) (g : N ⟶ K) :\n    (f ≫ g : M → K) = g ∘ f :=\n  rfl\n\n-- Porting note: deleted `coe_comp'`, as we no longer have the relevant coercion.\n\n"}
{"name":"SemiNormedGrp₁.zero_apply","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp","initialProofState":"V W : SemiNormedGrp₁\nx : ↑V\n⊢ Eq (0 x) 0","decl":"@[simp]\ntheorem zero_apply {V W : SemiNormedGrp₁} (x : V) : (0 : V ⟶ W) x = 0 :=\n  rfl\n\n"}
{"name":"SemiNormedGrp₁.isZero_of_subsingleton","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp","initialProofState":"V : SemiNormedGrp₁\ninst✝ : Subsingleton ↑V\n⊢ CategoryTheory.Limits.IsZero V","decl":"theorem isZero_of_subsingleton (V : SemiNormedGrp₁) [Subsingleton V] : Limits.IsZero V := by\n  refine ⟨fun X => ⟨⟨⟨0⟩, fun f => ?_⟩⟩, fun X => ⟨⟨⟨0⟩, fun f => ?_⟩⟩⟩\n  · ext x; have : x = 0 := Subsingleton.elim _ _; simp only [this, map_zero]\n  · ext; apply Subsingleton.elim\n\n"}
{"name":"SemiNormedGrp₁.hasZeroObject","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp","initialProofState":"⊢ CategoryTheory.Limits.HasZeroObject SemiNormedGrp₁","decl":"instance hasZeroObject : Limits.HasZeroObject SemiNormedGrp₁.{u} :=\n  ⟨⟨of PUnit, isZero_of_subsingleton _⟩⟩\n\n"}
{"name":"SemiNormedGrp₁.iso_isometry","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp","initialProofState":"V W : SemiNormedGrp₁\ni : CategoryTheory.Iso V W\n⊢ Isometry ⇑i.hom","decl":"theorem iso_isometry {V W : SemiNormedGrp₁} (i : V ≅ W) : Isometry i.hom := by\n  change Isometry (⟨⟨i.hom, map_zero _⟩, fun _ _ => map_add _ _ _⟩ : V →+ W)\n  refine AddMonoidHomClass.isometry_of_norm _ ?_\n  intro v\n  apply le_antisymm (i.hom.2 v)\n  calc\n    -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n    ‖v‖ = ‖i.inv (i.hom v)‖ := by erw [Iso.hom_inv_id_apply]\n    _ ≤ ‖i.hom v‖ := i.inv.2 _\n\n"}
