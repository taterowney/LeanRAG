{"name":"SemiNormedGrp.toAddMonoidHomClass","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp","initialProofState":"V W : SemiNormedGrp\nâŠ¢ AddMonoidHomClass (Quiver.Hom V W) â†‘V â†‘W","decl":"instance toAddMonoidHomClass {V W : SemiNormedGrp} : AddMonoidHomClass (V âŸ¶ W) V W where\n  map_add f := f.map_add'\n  map_zero f := (AddMonoidHom.mk' f.toFun f.map_add').map_zero\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/10688): added to ease automation\n"}
{"name":"SemiNormedGrp.ext","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp","initialProofState":"M N : SemiNormedGrp\nfâ‚ fâ‚‚ : Quiver.Hom M N\nh : âˆ€ (x : â†‘M), Eq (fâ‚ x) (fâ‚‚ x)\nâŠ¢ Eq fâ‚ fâ‚‚","decl":"@[ext]\nlemma ext {M N : SemiNormedGrp} {fâ‚ fâ‚‚ : M âŸ¶ N} (h : âˆ€ (x : M), fâ‚ x = fâ‚‚ x) : fâ‚ = fâ‚‚ :=\n  DFunLike.ext _ _ h\n\n"}
{"name":"SemiNormedGrp.ext_iff","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp","initialProofState":"M N : SemiNormedGrp\nfâ‚ fâ‚‚ : Quiver.Hom M N\nâŠ¢ Iff (Eq fâ‚ fâ‚‚) (âˆ€ (x : â†‘M), Eq (fâ‚ x) (fâ‚‚ x))","decl":"@[ext]\nlemma ext {M N : SemiNormedGrp} {fâ‚ fâ‚‚ : M âŸ¶ N} (h : âˆ€ (x : M), fâ‚ x = fâ‚‚ x) : fâ‚ = fâ‚‚ :=\n  DFunLike.ext _ _ h\n\n"}
{"name":"SemiNormedGrp.coe_of","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp","initialProofState":"V : Type u\ninstâœ : SeminormedAddCommGroup V\nâŠ¢ Eq (â†‘(SemiNormedGrp.of V)) V","decl":"@[simp]\ntheorem coe_of (V : Type u) [SeminormedAddCommGroup V] : (SemiNormedGrp.of V : Type u) = V :=\n  rfl\n\n-- Porting note: marked with high priority to short circuit simplifier's path\n"}
{"name":"SemiNormedGrp.coe_id","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp","initialProofState":"V : SemiNormedGrp\nâŠ¢ Eq (â‡‘(CategoryTheory.CategoryStruct.id V)) id","decl":"@[simp (high)]\ntheorem coe_id (V : SemiNormedGrp) : (ðŸ™ V : V â†’ V) = id :=\n  rfl\n\n-- Porting note: marked with high priority to short circuit simplifier's path\n"}
{"name":"SemiNormedGrp.coe_comp","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp","initialProofState":"M N K : SemiNormedGrp\nf : Quiver.Hom M N\ng : Quiver.Hom N K\nâŠ¢ Eq (â‡‘(CategoryTheory.CategoryStruct.comp f g)) (Function.comp â‡‘g â‡‘f)","decl":"@[simp (high)]\ntheorem coe_comp {M N K : SemiNormedGrp} (f : M âŸ¶ N) (g : N âŸ¶ K) :\n    (f â‰« g : M â†’ K) = g âˆ˜ f :=\n  rfl\n\n"}
{"name":"SemiNormedGrp.zero_apply","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp","initialProofState":"V W : SemiNormedGrp\nx : â†‘V\nâŠ¢ Eq (0 x) 0","decl":"@[simp]\ntheorem zero_apply {V W : SemiNormedGrp} (x : V) : (0 : V âŸ¶ W) x = 0 :=\n  rfl\n\n"}
{"name":"SemiNormedGrp.isZero_of_subsingleton","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp","initialProofState":"V : SemiNormedGrp\ninstâœ : Subsingleton â†‘V\nâŠ¢ CategoryTheory.Limits.IsZero V","decl":"theorem isZero_of_subsingleton (V : SemiNormedGrp) [Subsingleton V] : Limits.IsZero V := by\n  refine âŸ¨fun X => âŸ¨âŸ¨âŸ¨0âŸ©, fun f => ?_âŸ©âŸ©, fun X => âŸ¨âŸ¨âŸ¨0âŸ©, fun f => ?_âŸ©âŸ©âŸ©\n  Â· ext x; have : x = 0 := Subsingleton.elim _ _; simp only [this, map_zero]\n  Â· ext; apply Subsingleton.elim\n\n"}
{"name":"SemiNormedGrp.hasZeroObject","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp","initialProofState":"âŠ¢ CategoryTheory.Limits.HasZeroObject SemiNormedGrp","decl":"instance hasZeroObject : Limits.HasZeroObject SemiNormedGrp.{u} :=\n  âŸ¨âŸ¨of PUnit, isZero_of_subsingleton _âŸ©âŸ©\n\n"}
{"name":"SemiNormedGrp.iso_isometry_of_normNoninc","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp","initialProofState":"V W : SemiNormedGrp\ni : CategoryTheory.Iso V W\nh1 : NormedAddGroupHom.NormNoninc i.hom\nh2 : NormedAddGroupHom.NormNoninc i.inv\nâŠ¢ Isometry â‡‘i.hom","decl":"theorem iso_isometry_of_normNoninc {V W : SemiNormedGrp} (i : V â‰… W) (h1 : i.hom.NormNoninc)\n    (h2 : i.inv.NormNoninc) : Isometry i.hom := by\n  apply AddMonoidHomClass.isometry_of_norm\n  intro v\n  apply le_antisymm (h1 v)\n  calc\n    â€–vâ€– = â€–i.inv (i.hom v)â€– := by rw [Iso.hom_inv_id_apply]\n    _ â‰¤ â€–i.hom vâ€– := h2 _\n\n"}
{"name":"SemiNormedGrpâ‚.hom_ext","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp","initialProofState":"M N : SemiNormedGrpâ‚\nf g : Quiver.Hom M N\nw : Eq â‡‘f â‡‘g\nâŠ¢ Eq f g","decl":"@[ext]\ntheorem hom_ext {M N : SemiNormedGrpâ‚} (f g : M âŸ¶ N) (w : (f : M â†’ N) = (g : M â†’ N)) :\n    f = g :=\n  Subtype.eq (NormedAddGroupHom.ext (congr_fun w))\n\n"}
{"name":"SemiNormedGrpâ‚.hom_ext_iff","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp","initialProofState":"M N : SemiNormedGrpâ‚\nf g : Quiver.Hom M N\nâŠ¢ Iff (Eq f g) (Eq â‡‘f â‡‘g)","decl":"@[ext]\ntheorem hom_ext {M N : SemiNormedGrpâ‚} (f g : M âŸ¶ N) (w : (f : M â†’ N) = (g : M â†’ N)) :\n    f = g :=\n  Subtype.eq (NormedAddGroupHom.ext (congr_fun w))\n\n"}
{"name":"SemiNormedGrpâ‚.toAddMonoidHomClass","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp","initialProofState":"V W : SemiNormedGrpâ‚\nâŠ¢ AddMonoidHomClass (Quiver.Hom V W) â†‘V â†‘W","decl":"instance toAddMonoidHomClass {V W : SemiNormedGrpâ‚} : AddMonoidHomClass (V âŸ¶ W) V W where\n  map_add f := f.1.map_add'\n  map_zero f := (AddMonoidHom.mk' f.1 f.1.map_add').map_zero\n\n"}
{"name":"SemiNormedGrpâ‚.mkHom_apply","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp","initialProofState":"M N : SemiNormedGrp\nf : Quiver.Hom M N\ni : NormedAddGroupHom.NormNoninc f\nx : â†‘(SemiNormedGrpâ‚.of â†‘M)\nâŠ¢ Eq ((SemiNormedGrpâ‚.mkHom f i) x) (f x)","decl":"theorem mkHom_apply {M N : SemiNormedGrp} (f : M âŸ¶ N) (i : f.NormNoninc) (x) :\n    mkHom f i x = f x :=\n  rfl\n\n"}
{"name":"SemiNormedGrpâ‚.mkIso_hom","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp","initialProofState":"M N : SemiNormedGrp\nf : CategoryTheory.Iso M N\ni : NormedAddGroupHom.NormNoninc f.hom\ni' : NormedAddGroupHom.NormNoninc f.inv\nâŠ¢ Eq (SemiNormedGrpâ‚.mkIso f i i').hom (SemiNormedGrpâ‚.mkHom f.hom i)","decl":"/-- Promote an isomorphism in `SemiNormedGrp` to an isomorphism in `SemiNormedGrpâ‚`. -/\n@[simps]\ndef mkIso {M N : SemiNormedGrp} (f : M â‰… N) (i : f.hom.NormNoninc) (i' : f.inv.NormNoninc) :\n    SemiNormedGrpâ‚.of M â‰… SemiNormedGrpâ‚.of N where\n  hom := mkHom f.hom i\n  inv := mkHom f.inv i'\n  hom_inv_id := by apply Subtype.eq; exact f.hom_inv_id\n  inv_hom_id := by apply Subtype.eq; exact f.inv_hom_id\n\n"}
{"name":"SemiNormedGrpâ‚.mkIso_inv","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp","initialProofState":"M N : SemiNormedGrp\nf : CategoryTheory.Iso M N\ni : NormedAddGroupHom.NormNoninc f.hom\ni' : NormedAddGroupHom.NormNoninc f.inv\nâŠ¢ Eq (SemiNormedGrpâ‚.mkIso f i i').inv (SemiNormedGrpâ‚.mkHom f.inv i')","decl":"/-- Promote an isomorphism in `SemiNormedGrp` to an isomorphism in `SemiNormedGrpâ‚`. -/\n@[simps]\ndef mkIso {M N : SemiNormedGrp} (f : M â‰… N) (i : f.hom.NormNoninc) (i' : f.inv.NormNoninc) :\n    SemiNormedGrpâ‚.of M â‰… SemiNormedGrpâ‚.of N where\n  hom := mkHom f.hom i\n  inv := mkHom f.inv i'\n  hom_inv_id := by apply Subtype.eq; exact f.hom_inv_id\n  inv_hom_id := by apply Subtype.eq; exact f.inv_hom_id\n\n"}
{"name":"SemiNormedGrpâ‚.coe_of","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp","initialProofState":"V : Type u\ninstâœ : SeminormedAddCommGroup V\nâŠ¢ Eq (â†‘(SemiNormedGrpâ‚.of V)) V","decl":"@[simp]\ntheorem coe_of (V : Type u) [SeminormedAddCommGroup V] : (SemiNormedGrpâ‚.of V : Type u) = V :=\n  rfl\n\n-- Porting note: marked with high priority to short circuit simplifier's path\n"}
{"name":"SemiNormedGrpâ‚.coe_id","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp","initialProofState":"V : SemiNormedGrpâ‚\nâŠ¢ Eq (â‡‘(CategoryTheory.CategoryStruct.id V)) id","decl":"@[simp (high)]\ntheorem coe_id (V : SemiNormedGrpâ‚) : â‡‘(ðŸ™ V) = id :=\n  rfl\n\n-- Porting note: marked with high priority to short circuit simplifier's path\n"}
{"name":"SemiNormedGrpâ‚.coe_comp","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp","initialProofState":"M N K : SemiNormedGrpâ‚\nf : Quiver.Hom M N\ng : Quiver.Hom N K\nâŠ¢ Eq (â‡‘(CategoryTheory.CategoryStruct.comp f g)) (Function.comp â‡‘g â‡‘f)","decl":"@[simp (high)]\ntheorem coe_comp {M N K : SemiNormedGrpâ‚} (f : M âŸ¶ N) (g : N âŸ¶ K) :\n    (f â‰« g : M â†’ K) = g âˆ˜ f :=\n  rfl\n\n-- Porting note: deleted `coe_comp'`, as we no longer have the relevant coercion.\n\n"}
{"name":"SemiNormedGrpâ‚.zero_apply","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp","initialProofState":"V W : SemiNormedGrpâ‚\nx : â†‘V\nâŠ¢ Eq (0 x) 0","decl":"@[simp]\ntheorem zero_apply {V W : SemiNormedGrpâ‚} (x : V) : (0 : V âŸ¶ W) x = 0 :=\n  rfl\n\n"}
{"name":"SemiNormedGrpâ‚.isZero_of_subsingleton","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp","initialProofState":"V : SemiNormedGrpâ‚\ninstâœ : Subsingleton â†‘V\nâŠ¢ CategoryTheory.Limits.IsZero V","decl":"theorem isZero_of_subsingleton (V : SemiNormedGrpâ‚) [Subsingleton V] : Limits.IsZero V := by\n  refine âŸ¨fun X => âŸ¨âŸ¨âŸ¨0âŸ©, fun f => ?_âŸ©âŸ©, fun X => âŸ¨âŸ¨âŸ¨0âŸ©, fun f => ?_âŸ©âŸ©âŸ©\n  Â· ext x; have : x = 0 := Subsingleton.elim _ _; simp only [this, map_zero]\n  Â· ext; apply Subsingleton.elim\n\n"}
{"name":"SemiNormedGrpâ‚.hasZeroObject","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp","initialProofState":"âŠ¢ CategoryTheory.Limits.HasZeroObject SemiNormedGrpâ‚","decl":"instance hasZeroObject : Limits.HasZeroObject SemiNormedGrpâ‚.{u} :=\n  âŸ¨âŸ¨of PUnit, isZero_of_subsingleton _âŸ©âŸ©\n\n"}
{"name":"SemiNormedGrpâ‚.iso_isometry","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp","initialProofState":"V W : SemiNormedGrpâ‚\ni : CategoryTheory.Iso V W\nâŠ¢ Isometry â‡‘i.hom","decl":"theorem iso_isometry {V W : SemiNormedGrpâ‚} (i : V â‰… W) : Isometry i.hom := by\n  change Isometry (âŸ¨âŸ¨i.hom, map_zero _âŸ©, fun _ _ => map_add _ _ _âŸ© : V â†’+ W)\n  refine AddMonoidHomClass.isometry_of_norm _ ?_\n  intro v\n  apply le_antisymm (i.hom.2 v)\n  calc\n    -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n    â€–vâ€– = â€–i.inv (i.hom v)â€– := by erw [Iso.hom_inv_id_apply]\n    _ â‰¤ â€–i.hom vâ€– := i.inv.2 _\n\n"}
