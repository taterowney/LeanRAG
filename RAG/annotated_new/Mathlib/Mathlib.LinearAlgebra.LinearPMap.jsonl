{"name":"LinearPMap.mk.injEq","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u\ninst✝⁴ : Ring R\nE : Type v\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type w\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\ndomain✝ : Submodule R E\ntoFun✝ : LinearMap (RingHom.id R) (Subtype fun x => Membership.mem domain✝ x) F\ndomain : Submodule R E\ntoFun : LinearMap (RingHom.id R) (Subtype fun x => Membership.mem domain x) F\n⊢ Eq (Eq { domain := domain✝, toFun := toFun✝ } { domain := domain, toFun := toFun }) (And (Eq domain✝ domain) (HEq toFun✝ toFun))","decl":"/-- A `LinearPMap R E F` or `E →ₗ.[R] F` is a linear map from a submodule of `E` to `F`. -/\nstructure LinearPMap (R : Type u) [Ring R] (E : Type v) [AddCommGroup E] [Module R E] (F : Type w)\n  [AddCommGroup F] [Module R F] where\n  domain : Submodule R E\n  toFun : domain →ₗ[R] F\n\n"}
{"name":"LinearPMap.mk.inj","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u\ninst✝⁴ : Ring R\nE : Type v\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type w\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\ndomain✝ : Submodule R E\ntoFun✝ : LinearMap (RingHom.id R) (Subtype fun x => Membership.mem domain✝ x) F\ndomain : Submodule R E\ntoFun : LinearMap (RingHom.id R) (Subtype fun x => Membership.mem domain x) F\nx✝ : Eq { domain := domain✝, toFun := toFun✝ } { domain := domain, toFun := toFun }\n⊢ And (Eq domain✝ domain) (HEq toFun✝ toFun)","decl":"/-- A `LinearPMap R E F` or `E →ₗ.[R] F` is a linear map from a submodule of `E` to `F`. -/\nstructure LinearPMap (R : Type u) [Ring R] (E : Type v) [AddCommGroup E] [Module R E] (F : Type w)\n  [AddCommGroup F] [Module R F] where\n  domain : Submodule R E\n  toFun : domain →ₗ[R] F\n\n"}
{"name":"LinearPMap.mk.sizeOf_spec","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u\ninst✝⁷ : Ring R\nE : Type v\ninst✝⁶ : AddCommGroup E\ninst✝⁵ : Module R E\nF : Type w\ninst✝⁴ : AddCommGroup F\ninst✝³ : Module R F\ninst✝² : SizeOf R\ninst✝¹ : SizeOf E\ninst✝ : SizeOf F\ndomain : Submodule R E\ntoFun : LinearMap (RingHom.id R) (Subtype fun x => Membership.mem domain x) F\n⊢ Eq (SizeOf.sizeOf { domain := domain, toFun := toFun }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf domain)) (SizeOf.sizeOf toFun))","decl":"/-- A `LinearPMap R E F` or `E →ₗ.[R] F` is a linear map from a submodule of `E` to `F`. -/\nstructure LinearPMap (R : Type u) [Ring R] (E : Type v) [AddCommGroup E] [Module R E] (F : Type w)\n  [AddCommGroup F] [Module R F] where\n  domain : Submodule R E\n  toFun : domain →ₗ[R] F\n\n"}
{"name":"LinearPMap.toFun_eq_coe","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\nf : LinearPMap R E F\nx : Subtype fun x => Membership.mem f.domain x\n⊢ Eq (f.toFun x) (↑f x)","decl":"@[simp]\ntheorem toFun_eq_coe (f : E →ₗ.[R] F) (x : f.domain) : f.toFun x = f x :=\n  rfl\n\n"}
{"name":"LinearPMap.ext","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\nf g : LinearPMap R E F\nh : Eq f.domain g.domain\nh' : ∀ ⦃x : Subtype fun x => Membership.mem f.domain x⦄ ⦃y : Subtype fun x => Membership.mem g.domain x⦄, Eq ↑x ↑y → Eq (↑f x) (↑g y)\n⊢ Eq f g","decl":"@[ext (iff := false)]\ntheorem ext {f g : E →ₗ.[R] F} (h : f.domain = g.domain)\n    (h' : ∀ ⦃x : f.domain⦄ ⦃y : g.domain⦄ (_h : (x : E) = y), f x = g y) : f = g := by\n  rcases f with ⟨f_dom, f⟩\n  rcases g with ⟨g_dom, g⟩\n  obtain rfl : f_dom = g_dom := h\n  obtain rfl : f = g := LinearMap.ext fun x => h' rfl\n  rfl\n\n"}
{"name":"LinearPMap.map_zero","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\nf : LinearPMap R E F\n⊢ Eq (↑f 0) 0","decl":"@[simp]\ntheorem map_zero (f : E →ₗ.[R] F) : f 0 = 0 :=\n  f.toFun.map_zero\n\n"}
{"name":"LinearPMap.ext_iff","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\nf g : LinearPMap R E F\n⊢ Iff (Eq f g) (Exists fun _domain_eq => ∀ ⦃x : Subtype fun x => Membership.mem f.domain x⦄ ⦃y : Subtype fun x => Membership.mem g.domain x⦄, Eq ↑x ↑y → Eq (↑f x) (↑g y))","decl":"theorem ext_iff {f g : E →ₗ.[R] F} :\n    f = g ↔\n      ∃ _domain_eq : f.domain = g.domain,\n        ∀ ⦃x : f.domain⦄ ⦃y : g.domain⦄ (_h : (x : E) = y), f x = g y :=\n  ⟨fun EQ =>\n    EQ ▸\n      ⟨rfl, fun x y h => by\n        congr\n        exact mod_cast h⟩,\n    fun ⟨deq, feq⟩ => ext deq feq⟩\n\n"}
{"name":"LinearPMap.ext'","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\ns : Submodule R E\nf g : LinearMap (RingHom.id R) (Subtype fun x => Membership.mem s x) F\nh : Eq f g\n⊢ Eq { domain := s, toFun := f } { domain := s, toFun := g }","decl":"theorem ext' {s : Submodule R E} {f g : s →ₗ[R] F} (h : f = g) : mk s f = mk s g :=\n  h ▸ rfl\n\n"}
{"name":"LinearPMap.map_add","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\nf : LinearPMap R E F\nx y : Subtype fun x => Membership.mem f.domain x\n⊢ Eq (↑f (HAdd.hAdd x y)) (HAdd.hAdd (↑f x) (↑f y))","decl":"theorem map_add (f : E →ₗ.[R] F) (x y : f.domain) : f (x + y) = f x + f y :=\n  f.toFun.map_add x y\n\n"}
{"name":"LinearPMap.map_neg","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\nf : LinearPMap R E F\nx : Subtype fun x => Membership.mem f.domain x\n⊢ Eq (↑f (Neg.neg x)) (Neg.neg (↑f x))","decl":"theorem map_neg (f : E →ₗ.[R] F) (x : f.domain) : f (-x) = -f x :=\n  f.toFun.map_neg x\n\n"}
{"name":"LinearPMap.map_sub","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\nf : LinearPMap R E F\nx y : Subtype fun x => Membership.mem f.domain x\n⊢ Eq (↑f (HSub.hSub x y)) (HSub.hSub (↑f x) (↑f y))","decl":"theorem map_sub (f : E →ₗ.[R] F) (x y : f.domain) : f (x - y) = f x - f y :=\n  f.toFun.map_sub x y\n\n"}
{"name":"LinearPMap.map_smul","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\nf : LinearPMap R E F\nc : R\nx : Subtype fun x => Membership.mem f.domain x\n⊢ Eq (↑f (HSMul.hSMul c x)) (HSMul.hSMul c (↑f x))","decl":"theorem map_smul (f : E →ₗ.[R] F) (c : R) (x : f.domain) : f (c • x) = c • f x :=\n  f.toFun.map_smul c x\n\n"}
{"name":"LinearPMap.mk_apply","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\np : Submodule R E\nf : LinearMap (RingHom.id R) (Subtype fun x => Membership.mem p x) F\nx : Subtype fun x => Membership.mem p x\n⊢ Eq (↑{ domain := p, toFun := f } x) (f x)","decl":"@[simp]\ntheorem mk_apply (p : Submodule R E) (f : p →ₗ[R] F) (x : p) : mk p f x = f x :=\n  rfl\n\n"}
{"name":"LinearPMap.domain_mkSpanSingleton","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\nx : E\ny : F\nH : ∀ (c : R), Eq (HSMul.hSMul c x) 0 → Eq (HSMul.hSMul c y) 0\n⊢ Eq (LinearPMap.mkSpanSingleton' x y H).domain (Submodule.span R (Singleton.singleton x))","decl":"@[simp]\ntheorem domain_mkSpanSingleton (x : E) (y : F) (H : ∀ c : R, c • x = 0 → c • y = 0) :\n    (mkSpanSingleton' x y H).domain = R ∙ x :=\n  rfl\n\n"}
{"name":"LinearPMap.mkSpanSingleton'_apply","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\nx : E\ny : F\nH : ∀ (c : R), Eq (HSMul.hSMul c x) 0 → Eq (HSMul.hSMul c y) 0\nc : R\nh : Membership.mem (LinearPMap.mkSpanSingleton' x y H).domain (HSMul.hSMul c x)\n⊢ Eq (↑(LinearPMap.mkSpanSingleton' x y H) ⟨HSMul.hSMul c x, h⟩) (HSMul.hSMul c y)","decl":"@[simp]\ntheorem mkSpanSingleton'_apply (x : E) (y : F) (H : ∀ c : R, c • x = 0 → c • y = 0) (c : R) (h) :\n    mkSpanSingleton' x y H ⟨c • x, h⟩ = c • y := by\n  dsimp [mkSpanSingleton']\n  rw [← sub_eq_zero, ← sub_smul]\n  apply H\n  simp only [sub_smul, one_smul, sub_eq_zero]\n  apply Classical.choose_spec (mem_span_singleton.1 h)\n\n"}
{"name":"LinearPMap.mkSpanSingleton'_apply_self","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\nx : E\ny : F\nH : ∀ (c : R), Eq (HSMul.hSMul c x) 0 → Eq (HSMul.hSMul c y) 0\nh : Membership.mem (LinearPMap.mkSpanSingleton' x y H).domain x\n⊢ Eq (↑(LinearPMap.mkSpanSingleton' x y H) ⟨x, h⟩) y","decl":"@[simp]\ntheorem mkSpanSingleton'_apply_self (x : E) (y : F) (H : ∀ c : R, c • x = 0 → c • y = 0) (h) :\n    mkSpanSingleton' x y H ⟨x, h⟩ = y := by\n  -- Porting note: A placeholder should be specified before `convert`.\n  have := by refine mkSpanSingleton'_apply x y H 1 ?_; rwa [one_smul]\n  convert this <;> rw [one_smul]\n\n"}
{"name":"LinearPMap.mkSpanSingleton_apply","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"K : Type u_5\nE : Type u_6\nF : Type u_7\ninst✝⁴ : DivisionRing K\ninst✝³ : AddCommGroup E\ninst✝² : Module K E\ninst✝¹ : AddCommGroup F\ninst✝ : Module K F\nx : E\nhx : Ne x 0\ny : F\n⊢ Eq (↑(LinearPMap.mkSpanSingleton x y hx) ⟨x, ⋯⟩) y","decl":"theorem mkSpanSingleton_apply (K : Type*) {E F : Type*} [DivisionRing K] [AddCommGroup E]\n    [Module K E] [AddCommGroup F] [Module K F] {x : E} (hx : x ≠ 0) (y : F) :\n    mkSpanSingleton x y hx ⟨x, (Submodule.mem_span_singleton_self x : x ∈ Submodule.span K {x})⟩ =\n      y :=\n  LinearPMap.mkSpanSingleton'_apply_self _ _ _ _\n\n"}
{"name":"LinearPMap.fst_apply","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\np : Submodule R E\np' : Submodule R F\nx : Subtype fun x => Membership.mem (p.prod p') x\n⊢ Eq (↑(LinearPMap.fst p p') x) (↑x).1","decl":"@[simp]\ntheorem fst_apply (p : Submodule R E) (p' : Submodule R F) (x : p.prod p') :\n    LinearPMap.fst p p' x = (x : E × F).1 :=\n  rfl\n\n"}
{"name":"LinearPMap.snd_apply","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\np : Submodule R E\np' : Submodule R F\nx : Subtype fun x => Membership.mem (p.prod p') x\n⊢ Eq (↑(LinearPMap.snd p p') x) (↑x).2","decl":"@[simp]\ntheorem snd_apply (p : Submodule R E) (p' : Submodule R F) (x : p.prod p') :\n    LinearPMap.snd p p' x = (x : E × F).2 :=\n  rfl\n\n"}
{"name":"LinearPMap.apply_comp_inclusion","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\nT S : LinearPMap R E F\nh : LE.le T S\nx : Subtype fun x => Membership.mem T.domain x\n⊢ Eq (↑T x) (↑S ((Submodule.inclusion ⋯) x))","decl":"theorem apply_comp_inclusion {T S : E →ₗ.[R] F} (h : T ≤ S) (x : T.domain) :\n    T x = S (Submodule.inclusion h.1 x) :=\n  h.2 rfl\n\n"}
{"name":"LinearPMap.exists_of_le","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\nT S : LinearPMap R E F\nh : LE.le T S\nx : Subtype fun x => Membership.mem T.domain x\n⊢ Exists fun y => And (Eq ↑x ↑y) (Eq (↑T x) (↑S y))","decl":"theorem exists_of_le {T S : E →ₗ.[R] F} (h : T ≤ S) (x : T.domain) :\n    ∃ y : S.domain, (x : E) = y ∧ T x = S y :=\n  ⟨⟨x.1, h.1 x.2⟩, ⟨rfl, h.2 rfl⟩⟩\n\n"}
{"name":"LinearPMap.eq_of_le_of_domain_eq","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\nf g : LinearPMap R E F\nhle : LE.le f g\nheq : Eq f.domain g.domain\n⊢ Eq f g","decl":"theorem eq_of_le_of_domain_eq {f g : E →ₗ.[R] F} (hle : f ≤ g) (heq : f.domain = g.domain) :\n    f = g :=\n  ext heq hle.2\n\n"}
{"name":"LinearPMap.le_of_eqLocus_ge","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\nf g : LinearPMap R E F\nH : LE.le f.domain (f.eqLocus g)\n⊢ LE.le f g","decl":"theorem le_of_eqLocus_ge {f g : E →ₗ.[R] F} (H : f.domain ≤ f.eqLocus g) : f ≤ g :=\n  suffices f ≤ f ⊓ g from le_trans this inf_le_right\n  ⟨H, fun _x _y hxy => ((inf_le_left : f ⊓ g ≤ f).2 hxy.symm).symm⟩\n\n"}
{"name":"LinearPMap.domain_mono","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\n⊢ StrictMono LinearPMap.domain","decl":"theorem domain_mono : StrictMono (@domain R _ E _ _ F _ _) := fun _f _g hlt =>\n  lt_of_le_of_ne hlt.1.1 fun heq => ne_of_lt hlt <| eq_of_le_of_domain_eq (le_of_lt hlt) heq\n\n"}
{"name":"LinearPMap.domain_sup","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\nf g : LinearPMap R E F\nh : ∀ (x : Subtype fun x => Membership.mem f.domain x) (y : Subtype fun x => Membership.mem g.domain x), Eq ↑x ↑y → Eq (↑f x) (↑g y)\n⊢ Eq (f.sup g h).domain (Max.max f.domain g.domain)","decl":"@[simp]\ntheorem domain_sup (f g : E →ₗ.[R] F)\n    (h : ∀ (x : f.domain) (y : g.domain), (x : E) = y → f x = g y) :\n    (f.sup g h).domain = f.domain ⊔ g.domain :=\n  rfl\n\n"}
{"name":"LinearPMap.sup_apply","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\nf g : LinearPMap R E F\nH : ∀ (x : Subtype fun x => Membership.mem f.domain x) (y : Subtype fun x => Membership.mem g.domain x), Eq ↑x ↑y → Eq (↑f x) (↑g y)\nx : Subtype fun x => Membership.mem f.domain x\ny : Subtype fun x => Membership.mem g.domain x\nz : Subtype fun x => Membership.mem (Max.max f.domain g.domain) x\nhz : Eq (HAdd.hAdd ↑x ↑y) ↑z\n⊢ Eq (↑(f.sup g H) z) (HAdd.hAdd (↑f x) (↑g y))","decl":"theorem sup_apply {f g : E →ₗ.[R] F} (H : ∀ (x : f.domain) (y : g.domain), (x : E) = y → f x = g y)\n    (x : f.domain) (y : g.domain) (z : ↥(f.domain ⊔ g.domain)) (hz : (↑x : E) + ↑y = ↑z) :\n    f.sup g H z = f x + g y :=\n  Classical.choose_spec (sup_aux f g H) x y z hz\n\n"}
{"name":"LinearPMap.left_le_sup","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\nf g : LinearPMap R E F\nh : ∀ (x : Subtype fun x => Membership.mem f.domain x) (y : Subtype fun x => Membership.mem g.domain x), Eq ↑x ↑y → Eq (↑f x) (↑g y)\n⊢ LE.le f (f.sup g h)","decl":"protected theorem left_le_sup (f g : E →ₗ.[R] F)\n    (h : ∀ (x : f.domain) (y : g.domain), (x : E) = y → f x = g y) : f ≤ f.sup g h := by\n  refine ⟨le_sup_left, fun z₁ z₂ hz => ?_⟩\n  rw [← add_zero (f _), ← g.map_zero]\n  refine (sup_apply h _ _ _ ?_).symm\n  simpa\n\n"}
{"name":"LinearPMap.right_le_sup","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\nf g : LinearPMap R E F\nh : ∀ (x : Subtype fun x => Membership.mem f.domain x) (y : Subtype fun x => Membership.mem g.domain x), Eq ↑x ↑y → Eq (↑f x) (↑g y)\n⊢ LE.le g (f.sup g h)","decl":"protected theorem right_le_sup (f g : E →ₗ.[R] F)\n    (h : ∀ (x : f.domain) (y : g.domain), (x : E) = y → f x = g y) : g ≤ f.sup g h := by\n  refine ⟨le_sup_right, fun z₁ z₂ hz => ?_⟩\n  rw [← zero_add (g _), ← f.map_zero]\n  refine (sup_apply h _ _ _ ?_).symm\n  simpa\n\n"}
{"name":"LinearPMap.sup_le","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\nf g h : LinearPMap R E F\nH : ∀ (x : Subtype fun x => Membership.mem f.domain x) (y : Subtype fun x => Membership.mem g.domain x), Eq ↑x ↑y → Eq (↑f x) (↑g y)\nfh : LE.le f h\ngh : LE.le g h\n⊢ LE.le (f.sup g H) h","decl":"protected theorem sup_le {f g h : E →ₗ.[R] F}\n    (H : ∀ (x : f.domain) (y : g.domain), (x : E) = y → f x = g y) (fh : f ≤ h) (gh : g ≤ h) :\n    f.sup g H ≤ h :=\n  have Hf : f ≤ f.sup g H ⊓ h := le_inf (f.left_le_sup g H) fh\n  have Hg : g ≤ f.sup g H ⊓ h := le_inf (f.right_le_sup g H) gh\n  le_of_eqLocus_ge <| sup_le Hf.1 Hg.1\n\n"}
{"name":"LinearPMap.sup_h_of_disjoint","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\nf g : LinearPMap R E F\nh : Disjoint f.domain g.domain\nx : Subtype fun x => Membership.mem f.domain x\ny : Subtype fun x => Membership.mem g.domain x\nhxy : Eq ↑x ↑y\n⊢ Eq (↑f x) (↑g y)","decl":"/-- Hypothesis for `LinearPMap.sup` holds, if `f.domain` is disjoint with `g.domain`. -/\ntheorem sup_h_of_disjoint (f g : E →ₗ.[R] F) (h : Disjoint f.domain g.domain) (x : f.domain)\n    (y : g.domain) (hxy : (x : E) = y) : f x = g y := by\n  rw [disjoint_def] at h\n  have hy : y = 0 := Subtype.eq (h y (hxy ▸ x.2) y.2)\n  have hx : x = 0 := Subtype.eq (hxy.trans <| congr_arg _ hy)\n  simp [*]\n\n"}
{"name":"LinearPMap.zero_domain","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\n⊢ Eq (LinearPMap.domain 0) Top.top","decl":"@[simp]\ntheorem zero_domain : (0 : E →ₗ.[R] F).domain = ⊤ := rfl\n\n"}
{"name":"LinearPMap.zero_apply","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\nx : Subtype fun x => Membership.mem Top.top x\n⊢ Eq (↑0 x) 0","decl":"@[simp]\ntheorem zero_apply (x : (⊤ : Submodule R E)) : (0 : E →ₗ.[R] F) x = 0 := rfl\n\n"}
{"name":"LinearPMap.smul_domain","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁷ : Ring R\nE : Type u_2\ninst✝⁶ : AddCommGroup E\ninst✝⁵ : Module R E\nF : Type u_3\ninst✝⁴ : AddCommGroup F\ninst✝³ : Module R F\nM : Type u_5\ninst✝² : Monoid M\ninst✝¹ : DistribMulAction M F\ninst✝ : SMulCommClass R M F\na : M\nf : LinearPMap R E F\n⊢ Eq (HSMul.hSMul a f).domain f.domain","decl":"@[simp]\ntheorem smul_domain (a : M) (f : E →ₗ.[R] F) : (a • f).domain = f.domain :=\n  rfl\n\n"}
{"name":"LinearPMap.smul_apply","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁷ : Ring R\nE : Type u_2\ninst✝⁶ : AddCommGroup E\ninst✝⁵ : Module R E\nF : Type u_3\ninst✝⁴ : AddCommGroup F\ninst✝³ : Module R F\nM : Type u_5\ninst✝² : Monoid M\ninst✝¹ : DistribMulAction M F\ninst✝ : SMulCommClass R M F\na : M\nf : LinearPMap R E F\nx : Subtype fun x => Membership.mem (HSMul.hSMul a f).domain x\n⊢ Eq (↑(HSMul.hSMul a f) x) (HSMul.hSMul a (↑f x))","decl":"theorem smul_apply (a : M) (f : E →ₗ.[R] F) (x : (a • f).domain) : (a • f) x = a • f x :=\n  rfl\n\n"}
{"name":"LinearPMap.coe_smul","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁷ : Ring R\nE : Type u_2\ninst✝⁶ : AddCommGroup E\ninst✝⁵ : Module R E\nF : Type u_3\ninst✝⁴ : AddCommGroup F\ninst✝³ : Module R F\nM : Type u_5\ninst✝² : Monoid M\ninst✝¹ : DistribMulAction M F\ninst✝ : SMulCommClass R M F\na : M\nf : LinearPMap R E F\n⊢ Eq (↑(HSMul.hSMul a f)) (HSMul.hSMul a ↑f)","decl":"@[simp]\ntheorem coe_smul (a : M) (f : E →ₗ.[R] F) : ⇑(a • f) = a • ⇑f :=\n  rfl\n\n"}
{"name":"LinearPMap.instSMulCommClass","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝¹¹ : Ring R\nE : Type u_2\ninst✝¹⁰ : AddCommGroup E\ninst✝⁹ : Module R E\nF : Type u_3\ninst✝⁸ : AddCommGroup F\ninst✝⁷ : Module R F\nM : Type u_5\nN : Type u_6\ninst✝⁶ : Monoid M\ninst✝⁵ : DistribMulAction M F\ninst✝⁴ : SMulCommClass R M F\ninst✝³ : Monoid N\ninst✝² : DistribMulAction N F\ninst✝¹ : SMulCommClass R N F\ninst✝ : SMulCommClass M N F\n⊢ SMulCommClass M N (LinearPMap R E F)","decl":"instance instSMulCommClass [SMulCommClass M N F] : SMulCommClass M N (E →ₗ.[R] F) :=\n  ⟨fun a b f => ext' <| smul_comm a b f.toFun⟩\n\n"}
{"name":"LinearPMap.instIsScalarTower","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝¹² : Ring R\nE : Type u_2\ninst✝¹¹ : AddCommGroup E\ninst✝¹⁰ : Module R E\nF : Type u_3\ninst✝⁹ : AddCommGroup F\ninst✝⁸ : Module R F\nM : Type u_5\nN : Type u_6\ninst✝⁷ : Monoid M\ninst✝⁶ : DistribMulAction M F\ninst✝⁵ : SMulCommClass R M F\ninst✝⁴ : Monoid N\ninst✝³ : DistribMulAction N F\ninst✝² : SMulCommClass R N F\ninst✝¹ : SMul M N\ninst✝ : IsScalarTower M N F\n⊢ IsScalarTower M N (LinearPMap R E F)","decl":"instance instIsScalarTower [SMul M N] [IsScalarTower M N F] : IsScalarTower M N (E →ₗ.[R] F) :=\n  ⟨fun a b f => ext' <| smul_assoc a b f.toFun⟩\n\n"}
{"name":"LinearPMap.neg_domain","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\nf : LinearPMap R E F\n⊢ Eq (Neg.neg f).domain f.domain","decl":"@[simp]\ntheorem neg_domain (f : E →ₗ.[R] F) : (-f).domain = f.domain := rfl\n\n"}
{"name":"LinearPMap.neg_apply","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\nf : LinearPMap R E F\nx : Subtype fun x => Membership.mem (Neg.neg f).domain x\n⊢ Eq (↑(Neg.neg f) x) (Neg.neg (↑f x))","decl":"@[simp]\ntheorem neg_apply (f : E →ₗ.[R] F) (x) : (-f) x = -f x :=\n  rfl\n\n"}
{"name":"LinearPMap.add_domain","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\nf g : LinearPMap R E F\n⊢ Eq (HAdd.hAdd f g).domain (Min.min f.domain g.domain)","decl":"theorem add_domain (f g : E →ₗ.[R] F) : (f + g).domain = f.domain ⊓ g.domain := rfl\n\n"}
{"name":"LinearPMap.add_apply","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\nf g : LinearPMap R E F\nx : Subtype fun x => Membership.mem (Min.min f.domain g.domain) x\n⊢ Eq (↑(HAdd.hAdd f g) x) (HAdd.hAdd (↑f ⟨↑x, ⋯⟩) (↑g ⟨↑x, ⋯⟩))","decl":"theorem add_apply (f g : E →ₗ.[R] F) (x : (f.domain ⊓ g.domain : Submodule R E)) :\n    (f + g) x = f ⟨x, x.prop.1⟩ + g ⟨x, x.prop.2⟩ := rfl\n\n"}
{"name":"LinearPMap.vadd_domain","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\nf : LinearMap (RingHom.id R) E F\ng : LinearPMap R E F\n⊢ Eq (HVAdd.hVAdd f g).domain g.domain","decl":"@[simp]\ntheorem vadd_domain (f : E →ₗ[R] F) (g : E →ₗ.[R] F) : (f +ᵥ g).domain = g.domain :=\n  rfl\n\n"}
{"name":"LinearPMap.vadd_apply","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\nf : LinearMap (RingHom.id R) E F\ng : LinearPMap R E F\nx : Subtype fun x => Membership.mem (HVAdd.hVAdd f g).domain x\n⊢ Eq (↑(HVAdd.hVAdd f g) x) (HAdd.hAdd (f ↑x) (↑g x))","decl":"theorem vadd_apply (f : E →ₗ[R] F) (g : E →ₗ.[R] F) (x : (f +ᵥ g).domain) :\n    (f +ᵥ g) x = f x + g x :=\n  rfl\n\n"}
{"name":"LinearPMap.coe_vadd","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\nf : LinearMap (RingHom.id R) E F\ng : LinearPMap R E F\n⊢ Eq (↑(HVAdd.hVAdd f g)) (HAdd.hAdd ⇑(f.comp g.domain.subtype) ↑g)","decl":"@[simp]\ntheorem coe_vadd (f : E →ₗ[R] F) (g : E →ₗ.[R] F) : ⇑(f +ᵥ g) = ⇑(f.comp g.domain.subtype) + ⇑g :=\n  rfl\n\n"}
{"name":"LinearPMap.sub_domain","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\nf g : LinearPMap R E F\n⊢ Eq (HSub.hSub f g).domain (Min.min f.domain g.domain)","decl":"theorem sub_domain (f g : E →ₗ.[R] F) : (f - g).domain = f.domain ⊓ g.domain := rfl\n\n"}
{"name":"LinearPMap.sub_apply","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\nf g : LinearPMap R E F\nx : Subtype fun x => Membership.mem (Min.min f.domain g.domain) x\n⊢ Eq (↑(HSub.hSub f g) x) (HSub.hSub (↑f ⟨↑x, ⋯⟩) (↑g ⟨↑x, ⋯⟩))","decl":"theorem sub_apply (f g : E →ₗ.[R] F) (x : (f.domain ⊓ g.domain : Submodule R E)) :\n    (f - g) x = f ⟨x, x.prop.1⟩ - g ⟨x, x.prop.2⟩ := rfl\n\n"}
{"name":"LinearPMap.domain_supSpanSingleton","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"E : Type u_2\ninst✝⁴ : AddCommGroup E\nF : Type u_3\ninst✝³ : AddCommGroup F\nK : Type u_5\ninst✝² : DivisionRing K\ninst✝¹ : Module K E\ninst✝ : Module K F\nf : LinearPMap K E F\nx : E\ny : F\nhx : Not (Membership.mem f.domain x)\n⊢ Eq (f.supSpanSingleton x y hx).domain (Max.max f.domain (Submodule.span K (Singleton.singleton x)))","decl":"@[simp]\ntheorem domain_supSpanSingleton (f : E →ₗ.[K] F) (x : E) (y : F) (hx : x ∉ f.domain) :\n    (f.supSpanSingleton x y hx).domain = f.domain ⊔ K ∙ x :=\n  rfl\n\n"}
{"name":"LinearPMap.supSpanSingleton_apply_mk","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"E : Type u_2\ninst✝⁴ : AddCommGroup E\nF : Type u_3\ninst✝³ : AddCommGroup F\nK : Type u_5\ninst✝² : DivisionRing K\ninst✝¹ : Module K E\ninst✝ : Module K F\nf : LinearPMap K E F\nx : E\ny : F\nhx : Not (Membership.mem f.domain x)\nx' : E\nhx' : Membership.mem f.domain x'\nc : K\n⊢ Eq (↑(f.supSpanSingleton x y hx) ⟨HAdd.hAdd x' (HSMul.hSMul c x), ⋯⟩) (HAdd.hAdd (↑f ⟨x', hx'⟩) (HSMul.hSMul c y))","decl":"@[simp]\ntheorem supSpanSingleton_apply_mk (f : E →ₗ.[K] F) (x : E) (y : F) (hx : x ∉ f.domain) (x' : E)\n    (hx' : x' ∈ f.domain) (c : K) :\n    f.supSpanSingleton x y hx\n        ⟨x' + c • x, mem_sup.2 ⟨x', hx', _, mem_span_singleton.2 ⟨c, rfl⟩, rfl⟩⟩ =\n      f ⟨x', hx'⟩ + c • y := by\n  -- Porting note: `erw [..]; rfl; exact ..` → `erw [..]; exact ..; rfl`\n  -- That is, the order of the side goals generated by `erw` changed.\n  erw [sup_apply _ ⟨x', hx'⟩ ⟨c • x, _⟩, mkSpanSingleton'_apply]\n  · exact mem_span_singleton.2 ⟨c, rfl⟩\n  · rfl\n\n"}
{"name":"LinearPMap.le_sSup","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\nc : Set (LinearPMap R E F)\nhc : DirectedOn (fun x1 x2 => LE.le x1 x2) c\nf : LinearPMap R E F\nhf : Membership.mem c f\n⊢ LE.le f (LinearPMap.sSup c hc)","decl":"protected theorem le_sSup {c : Set (E →ₗ.[R] F)} (hc : DirectedOn (· ≤ ·) c) {f : E →ₗ.[R] F}\n    (hf : f ∈ c) : f ≤ LinearPMap.sSup c hc :=\n  Classical.choose_spec (sSup_aux c hc) hf\n\n"}
{"name":"LinearPMap.sSup_le","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\nc : Set (LinearPMap R E F)\nhc : DirectedOn (fun x1 x2 => LE.le x1 x2) c\ng : LinearPMap R E F\nhg : ∀ (f : LinearPMap R E F), Membership.mem c f → LE.le f g\n⊢ LE.le (LinearPMap.sSup c hc) g","decl":"protected theorem sSup_le {c : Set (E →ₗ.[R] F)} (hc : DirectedOn (· ≤ ·) c) {g : E →ₗ.[R] F}\n    (hg : ∀ f ∈ c, f ≤ g) : LinearPMap.sSup c hc ≤ g :=\n  le_of_eqLocus_ge <|\n    sSup_le fun _ ⟨f, hf, Eq⟩ =>\n      Eq ▸\n        have : f ≤ LinearPMap.sSup c hc ⊓ g := le_inf (LinearPMap.le_sSup _ hf) (hg f hf)\n        this.1\n\n"}
{"name":"LinearPMap.sSup_apply","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\nc : Set (LinearPMap R E F)\nhc : DirectedOn (fun x1 x2 => LE.le x1 x2) c\nl : LinearPMap R E F\nhl : Membership.mem c l\nx : Subtype fun x => Membership.mem l.domain x\n⊢ Eq (↑(LinearPMap.sSup c hc) ⟨↑x, ⋯⟩) (↑l x)","decl":"protected theorem sSup_apply {c : Set (E →ₗ.[R] F)} (hc : DirectedOn (· ≤ ·) c) {l : E →ₗ.[R] F}\n    (hl : l ∈ c) (x : l.domain) :\n    (LinearPMap.sSup c hc) ⟨x, (LinearPMap.le_sSup hc hl).1 x.2⟩ = l x := by\n  symm\n  apply (Classical.choose_spec (sSup_aux c hc) hl).2\n  rfl\n\n"}
{"name":"LinearMap.toPMap_apply","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\nf : LinearMap (RingHom.id R) E F\np : Submodule R E\nx : Subtype fun x => Membership.mem p x\n⊢ Eq (↑(f.toPMap p) x) (f ↑x)","decl":"@[simp]\ntheorem toPMap_apply (f : E →ₗ[R] F) (p : Submodule R E) (x : p) : f.toPMap p x = f x :=\n  rfl\n\n"}
{"name":"LinearMap.toPMap_domain","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\nf : LinearMap (RingHom.id R) E F\np : Submodule R E\n⊢ Eq (f.toPMap p).domain p","decl":"@[simp]\ntheorem toPMap_domain (f : E →ₗ[R] F) (p : Submodule R E) : (f.toPMap p).domain = p :=\n  rfl\n\n"}
{"name":"LinearMap.compPMap_apply","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁶ : Ring R\nE : Type u_2\ninst✝⁵ : AddCommGroup E\ninst✝⁴ : Module R E\nF : Type u_3\ninst✝³ : AddCommGroup F\ninst✝² : Module R F\nG : Type u_4\ninst✝¹ : AddCommGroup G\ninst✝ : Module R G\ng : LinearMap (RingHom.id R) F G\nf : LinearPMap R E F\nx : Subtype fun x => Membership.mem (g.compPMap f).domain x\n⊢ Eq (↑(g.compPMap f) x) (g (↑f x))","decl":"@[simp]\ntheorem compPMap_apply (g : F →ₗ[R] G) (f : E →ₗ.[R] F) (x) : g.compPMap f x = g (f x) :=\n  rfl\n\n"}
{"name":"LinearPMap.coprod_apply","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁶ : Ring R\nE : Type u_2\ninst✝⁵ : AddCommGroup E\ninst✝⁴ : Module R E\nF : Type u_3\ninst✝³ : AddCommGroup F\ninst✝² : Module R F\nG : Type u_4\ninst✝¹ : AddCommGroup G\ninst✝ : Module R G\nf : LinearPMap R E G\ng : LinearPMap R F G\nx : Subtype fun x => Membership.mem (f.coprod g).domain x\n⊢ Eq (↑(f.coprod g) x) (HAdd.hAdd (↑f ⟨(↑x).1, ⋯⟩) (↑g ⟨(↑x).2, ⋯⟩))","decl":"@[simp]\ntheorem coprod_apply (f : E →ₗ.[R] G) (g : F →ₗ.[R] G) (x) :\n    f.coprod g x = f ⟨(x : E × F).1, x.2.1⟩ + g ⟨(x : E × F).2, x.2.2⟩ :=\n  rfl\n\n"}
{"name":"LinearPMap.domRestrict_domain","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\nf : LinearPMap R E F\nS : Submodule R E\n⊢ Eq (f.domRestrict S).domain (Min.min S f.domain)","decl":"@[simp]\ntheorem domRestrict_domain (f : E →ₗ.[R] F) {S : Submodule R E} :\n    (f.domRestrict S).domain = S ⊓ f.domain :=\n  rfl\n\n"}
{"name":"LinearPMap.domRestrict_apply","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\nf : LinearPMap R E F\nS : Submodule R E\nx : Subtype fun x => Membership.mem (Min.min S f.domain) x\ny : Subtype fun x => Membership.mem f.domain x\nh : Eq ↑x ↑y\n⊢ Eq (↑(f.domRestrict S) x) (↑f y)","decl":"theorem domRestrict_apply {f : E →ₗ.[R] F} {S : Submodule R E} ⦃x : ↥(S ⊓ f.domain)⦄ ⦃y : f.domain⦄\n    (h : (x : E) = y) : f.domRestrict S x = f y := by\n  have : Submodule.inclusion (by simp) x = y := by\n    ext\n    simp [h]\n  rw [← this]\n  exact LinearPMap.mk_apply _ _ _\n\n"}
{"name":"LinearPMap.domRestrict_le","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\nf : LinearPMap R E F\nS : Submodule R E\n⊢ LE.le (f.domRestrict S) f","decl":"theorem domRestrict_le {f : E →ₗ.[R] F} {S : Submodule R E} : f.domRestrict S ≤ f :=\n  ⟨by simp, fun _ _ hxy => domRestrict_apply hxy⟩\n\n"}
{"name":"LinearPMap.mem_graph_iff'","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\nf : LinearPMap R E F\nx : Prod E F\n⊢ Iff (Membership.mem f.graph x) (Exists fun y => Eq { fst := ↑y, snd := ↑f y } x)","decl":"theorem mem_graph_iff' (f : E →ₗ.[R] F) {x : E × F} :\n    x ∈ f.graph ↔ ∃ y : f.domain, (↑y, f y) = x := by simp [graph]\n\n"}
{"name":"LinearPMap.mem_graph_iff","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\nf : LinearPMap R E F\nx : Prod E F\n⊢ Iff (Membership.mem f.graph x) (Exists fun y => And (Eq (↑y) x.1) (Eq (↑f y) x.2))","decl":"@[simp]\ntheorem mem_graph_iff (f : E →ₗ.[R] F) {x : E × F} :\n    x ∈ f.graph ↔ ∃ y : f.domain, (↑y : E) = x.1 ∧ f y = x.2 := by\n  cases x\n  simp_rw [mem_graph_iff', Prod.mk.inj_iff]\n\n"}
{"name":"LinearPMap.mem_graph","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\nf : LinearPMap R E F\nx : Subtype fun x => Membership.mem f.domain x\n⊢ Membership.mem f.graph { fst := ↑x, snd := ↑f x }","decl":"/-- The tuple `(x, f x)` is contained in the graph of `f`. -/\ntheorem mem_graph (f : E →ₗ.[R] F) (x : domain f) : ((x : E), f x) ∈ f.graph := by simp\n\n"}
{"name":"LinearPMap.graph_map_fst_eq_domain","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\nf : LinearPMap R E F\n⊢ Eq (Submodule.map (LinearMap.fst R E F) f.graph) f.domain","decl":"theorem graph_map_fst_eq_domain (f : E →ₗ.[R] F) :\n    f.graph.map (LinearMap.fst R E F) = f.domain := by\n  ext x\n  simp only [Submodule.mem_map, mem_graph_iff, Subtype.exists, exists_and_left, exists_eq_left,\n    LinearMap.fst_apply, Prod.exists, exists_and_right, exists_eq_right]\n  constructor <;> intro h\n  · rcases h with ⟨x, hx, _⟩\n    exact hx\n  · use f ⟨x, h⟩\n    simp only [h, exists_const]\n\n"}
{"name":"LinearPMap.graph_map_snd_eq_range","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\nf : LinearPMap R E F\n⊢ Eq (Submodule.map (LinearMap.snd R E F) f.graph) (LinearMap.range f.toFun)","decl":"theorem graph_map_snd_eq_range (f : E →ₗ.[R] F) :\n    f.graph.map (LinearMap.snd R E F) = LinearMap.range f.toFun := by ext; simp\n\n"}
{"name":"LinearPMap.smul_graph","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁷ : Ring R\nE : Type u_2\ninst✝⁶ : AddCommGroup E\ninst✝⁵ : Module R E\nF : Type u_3\ninst✝⁴ : AddCommGroup F\ninst✝³ : Module R F\nM : Type u_5\ninst✝² : Monoid M\ninst✝¹ : DistribMulAction M F\ninst✝ : SMulCommClass R M F\nf : LinearPMap R E F\nz : M\n⊢ Eq (HSMul.hSMul z f).graph (Submodule.map (LinearMap.id.prodMap (HSMul.hSMul z LinearMap.id)) f.graph)","decl":"/-- The graph of `z • f` as a pushforward. -/\ntheorem smul_graph (f : E →ₗ.[R] F) (z : M) :\n    (z • f).graph =\n      f.graph.map ((LinearMap.id : E →ₗ[R] E).prodMap (z • (LinearMap.id : F →ₗ[R] F))) := by\n  ext x; cases' x with x_fst x_snd\n  constructor <;> intro h\n  · rw [mem_graph_iff] at h\n    rcases h with ⟨y, hy, h⟩\n    rw [LinearPMap.smul_apply] at h\n    rw [Submodule.mem_map]\n    simp only [mem_graph_iff, LinearMap.prodMap_apply, LinearMap.id_coe, id,\n      LinearMap.smul_apply, Prod.mk.inj_iff, Prod.exists, exists_exists_and_eq_and]\n    use x_fst, y, hy\n  rw [Submodule.mem_map] at h\n  rcases h with ⟨x', hx', h⟩\n  cases x'\n  simp only [LinearMap.prodMap_apply, LinearMap.id_coe, id, LinearMap.smul_apply,\n    Prod.mk.inj_iff] at h\n  rw [mem_graph_iff] at hx' ⊢\n  rcases hx' with ⟨y, hy, hx'⟩\n  use y\n  rw [← h.1, ← h.2]\n  simp [hy, hx']\n\n"}
{"name":"LinearPMap.neg_graph","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\nf : LinearPMap R E F\n⊢ Eq (Neg.neg f).graph (Submodule.map (LinearMap.id.prodMap (Neg.neg LinearMap.id)) f.graph)","decl":"/-- The graph of `-f` as a pushforward. -/\ntheorem neg_graph (f : E →ₗ.[R] F) :\n    (-f).graph =\n    f.graph.map ((LinearMap.id : E →ₗ[R] E).prodMap (-(LinearMap.id : F →ₗ[R] F))) := by\n  ext x; cases' x with x_fst x_snd\n  constructor <;> intro h\n  · rw [mem_graph_iff] at h\n    rcases h with ⟨y, hy, h⟩\n    rw [LinearPMap.neg_apply] at h\n    rw [Submodule.mem_map]\n    simp only [mem_graph_iff, LinearMap.prodMap_apply, LinearMap.id_coe, id,\n      LinearMap.neg_apply, Prod.mk.inj_iff, Prod.exists, exists_exists_and_eq_and]\n    use x_fst, y, hy\n  rw [Submodule.mem_map] at h\n  rcases h with ⟨x', hx', h⟩\n  cases x'\n  simp only [LinearMap.prodMap_apply, LinearMap.id_coe, id, LinearMap.neg_apply,\n    Prod.mk.inj_iff] at h\n  rw [mem_graph_iff] at hx' ⊢\n  rcases hx' with ⟨y, hy, hx'⟩\n  use y\n  rw [← h.1, ← h.2]\n  simp [hy, hx']\n\n"}
{"name":"LinearPMap.mem_graph_snd_inj","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\nf : LinearPMap R E F\nx y : E\nx' y' : F\nhx : Membership.mem f.graph { fst := x, snd := x' }\nhy : Membership.mem f.graph { fst := y, snd := y' }\nhxy : Eq x y\n⊢ Eq x' y'","decl":"theorem mem_graph_snd_inj (f : E →ₗ.[R] F) {x y : E} {x' y' : F} (hx : (x, x') ∈ f.graph)\n    (hy : (y, y') ∈ f.graph) (hxy : x = y) : x' = y' := by\n  rw [mem_graph_iff] at hx hy\n  rcases hx with ⟨x'', hx1, hx2⟩\n  rcases hy with ⟨y'', hy1, hy2⟩\n  simp only at hx1 hx2 hy1 hy2\n  rw [← hx1, ← hy1, SetLike.coe_eq_coe] at hxy\n  rw [← hx2, ← hy2, hxy]\n\n"}
{"name":"LinearPMap.mem_graph_snd_inj'","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\nf : LinearPMap R E F\nx y : Prod E F\nhx : Membership.mem f.graph x\nhy : Membership.mem f.graph y\nhxy : Eq x.1 y.1\n⊢ Eq x.2 y.2","decl":"theorem mem_graph_snd_inj' (f : E →ₗ.[R] F) {x y : E × F} (hx : x ∈ f.graph) (hy : y ∈ f.graph)\n    (hxy : x.1 = y.1) : x.2 = y.2 := by\n  cases x\n  cases y\n  exact f.mem_graph_snd_inj hx hy hxy\n\n"}
{"name":"LinearPMap.graph_fst_eq_zero_snd","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\nf : LinearPMap R E F\nx : E\nx' : F\nh : Membership.mem f.graph { fst := x, snd := x' }\nhx : Eq x 0\n⊢ Eq x' 0","decl":"/-- The property that `f 0 = 0` in terms of the graph. -/\ntheorem graph_fst_eq_zero_snd (f : E →ₗ.[R] F) {x : E} {x' : F} (h : (x, x') ∈ f.graph)\n    (hx : x = 0) : x' = 0 :=\n  f.mem_graph_snd_inj h f.graph.zero_mem hx\n\n"}
{"name":"LinearPMap.mem_domain_iff","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\nf : LinearPMap R E F\nx : E\n⊢ Iff (Membership.mem f.domain x) (Exists fun y => Membership.mem f.graph { fst := x, snd := y })","decl":"theorem mem_domain_iff {f : E →ₗ.[R] F} {x : E} : x ∈ f.domain ↔ ∃ y : F, (x, y) ∈ f.graph := by\n  constructor <;> intro h\n  · use f ⟨x, h⟩\n    exact f.mem_graph ⟨x, h⟩\n  cases' h with y h\n  rw [mem_graph_iff] at h\n  cases' h with x' h\n  simp only at h\n  rw [← h.1]\n  simp\n\n"}
{"name":"LinearPMap.mem_domain_of_mem_graph","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\nf : LinearPMap R E F\nx : E\ny : F\nh : Membership.mem f.graph { fst := x, snd := y }\n⊢ Membership.mem f.domain x","decl":"theorem mem_domain_of_mem_graph {f : E →ₗ.[R] F} {x : E} {y : F} (h : (x, y) ∈ f.graph) :\n    x ∈ f.domain := by\n  rw [mem_domain_iff]\n  exact ⟨y, h⟩\n\n"}
{"name":"LinearPMap.image_iff","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\nf : LinearPMap R E F\nx : E\ny : F\nhx : Membership.mem f.domain x\n⊢ Iff (Eq y (↑f ⟨x, hx⟩)) (Membership.mem f.graph { fst := x, snd := y })","decl":"theorem image_iff {f : E →ₗ.[R] F} {x : E} {y : F} (hx : x ∈ f.domain) :\n    y = f ⟨x, hx⟩ ↔ (x, y) ∈ f.graph := by\n  rw [mem_graph_iff]\n  constructor <;> intro h\n  · use ⟨x, hx⟩\n    simp [h]\n  rcases h with ⟨⟨x', hx'⟩, ⟨h1, h2⟩⟩\n  simp only [Submodule.coe_mk] at h1 h2\n  simp only [← h2, h1]\n\n"}
{"name":"LinearPMap.mem_range_iff","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\nf : LinearPMap R E F\ny : F\n⊢ Iff (Membership.mem (Set.range ↑f) y) (Exists fun x => Membership.mem f.graph { fst := x, snd := y })","decl":"theorem mem_range_iff {f : E →ₗ.[R] F} {y : F} : y ∈ Set.range f ↔ ∃ x : E, (x, y) ∈ f.graph := by\n  constructor <;> intro h\n  · rw [Set.mem_range] at h\n    rcases h with ⟨⟨x, hx⟩, h⟩\n    use x\n    rw [← h]\n    exact f.mem_graph ⟨x, hx⟩\n  cases' h with x h\n  rw [mem_graph_iff] at h\n  cases' h with x h\n  rw [Set.mem_range]\n  use x\n  simp only at h\n  rw [h.2]\n\n"}
{"name":"LinearPMap.mem_domain_iff_of_eq_graph","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\nf g : LinearPMap R E F\nh : Eq f.graph g.graph\nx : E\n⊢ Iff (Membership.mem f.domain x) (Membership.mem g.domain x)","decl":"theorem mem_domain_iff_of_eq_graph {f g : E →ₗ.[R] F} (h : f.graph = g.graph) {x : E} :\n    x ∈ f.domain ↔ x ∈ g.domain := by simp_rw [mem_domain_iff, h]\n\n"}
{"name":"LinearPMap.le_of_le_graph","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\nf g : LinearPMap R E F\nh : LE.le f.graph g.graph\n⊢ LE.le f g","decl":"theorem le_of_le_graph {f g : E →ₗ.[R] F} (h : f.graph ≤ g.graph) : f ≤ g := by\n  constructor\n  · intro x hx\n    rw [mem_domain_iff] at hx ⊢\n    cases' hx with y hx\n    use y\n    exact h hx\n  rintro ⟨x, hx⟩ ⟨y, hy⟩ hxy\n  rw [image_iff]\n  refine h ?_\n  simp only [Submodule.coe_mk] at hxy\n  rw [hxy] at hx\n  rw [← image_iff hx]\n  simp [hxy]\n\n"}
{"name":"LinearPMap.le_graph_of_le","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\nf g : LinearPMap R E F\nh : LE.le f g\n⊢ LE.le f.graph g.graph","decl":"theorem le_graph_of_le {f g : E →ₗ.[R] F} (h : f ≤ g) : f.graph ≤ g.graph := by\n  intro x hx\n  rw [mem_graph_iff] at hx ⊢\n  cases' hx with y hx\n  use ⟨y, h.1 y.2⟩\n  simp only [hx, Submodule.coe_mk, eq_self_iff_true, true_and]\n  convert hx.2 using 1\n  refine (h.2 ?_).symm\n  simp only [hx.1, Submodule.coe_mk]\n\n"}
{"name":"LinearPMap.le_graph_iff","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\nf g : LinearPMap R E F\n⊢ Iff (LE.le f.graph g.graph) (LE.le f g)","decl":"theorem le_graph_iff {f g : E →ₗ.[R] F} : f.graph ≤ g.graph ↔ f ≤ g :=\n  ⟨le_of_le_graph, le_graph_of_le⟩\n\n"}
{"name":"LinearPMap.eq_of_eq_graph","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\nf g : LinearPMap R E F\nh : Eq f.graph g.graph\n⊢ Eq f g","decl":"theorem eq_of_eq_graph {f g : E →ₗ.[R] F} (h : f.graph = g.graph) : f = g := by\n  ext\n  · exact mem_domain_iff_of_eq_graph h\n  · apply (le_of_le_graph h.le).2\n    assumption\n\n"}
{"name":"Submodule.existsUnique_from_graph","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\ng : Submodule R (Prod E F)\nhg : ∀ {x : Prod E F}, Membership.mem g x → Eq x.1 0 → Eq x.2 0\na : E\nha : Membership.mem (Submodule.map (LinearMap.fst R E F) g) a\n⊢ ExistsUnique fun b => Membership.mem g { fst := a, snd := b }","decl":"theorem existsUnique_from_graph {g : Submodule R (E × F)}\n    (hg : ∀ {x : E × F} (_hx : x ∈ g) (_hx' : x.fst = 0), x.snd = 0) {a : E}\n    (ha : a ∈ g.map (LinearMap.fst R E F)) : ∃! b : F, (a, b) ∈ g := by\n  refine existsUnique_of_exists_of_unique ?_ ?_\n  · convert ha\n    simp\n  intro y₁ y₂ hy₁ hy₂\n  have hy : ((0 : E), y₁ - y₂) ∈ g := by\n    convert g.sub_mem hy₁ hy₂\n    exact (sub_self _).symm\n  exact sub_eq_zero.mp (hg hy (by simp))\n\n"}
{"name":"Submodule.valFromGraph_mem","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\ng : Submodule R (Prod E F)\nhg : ∀ (x : Prod E F), Membership.mem g x → Eq x.1 0 → Eq x.2 0\na : E\nha : Membership.mem (Submodule.map (LinearMap.fst R E F) g) a\n⊢ Membership.mem g { fst := a, snd := Submodule.valFromGraph hg ha }","decl":"theorem valFromGraph_mem {g : Submodule R (E × F)}\n    (hg : ∀ (x : E × F) (_hx : x ∈ g) (_hx' : x.fst = 0), x.snd = 0) {a : E}\n    (ha : a ∈ g.map (LinearMap.fst R E F)) : (a, valFromGraph hg ha) ∈ g :=\n  (ExistsUnique.exists (existsUnique_from_graph @hg ha)).choose_spec\n\n"}
{"name":"Submodule.toLinearPMap_domain","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\ng : Submodule R (Prod E F)\n⊢ Eq g.toLinearPMap.domain (Submodule.map (LinearMap.fst R E F) g)","decl":"theorem toLinearPMap_domain (g : Submodule R (E × F)) :\n    g.toLinearPMap.domain = g.map (LinearMap.fst R E F) := rfl\n\n"}
{"name":"Submodule.toLinearPMap_apply_aux","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\ng : Submodule R (Prod E F)\nhg : ∀ (x : Prod E F), Membership.mem g x → Eq x.1 0 → Eq x.2 0\nx : Subtype fun x => Membership.mem (Submodule.map (LinearMap.fst R E F) g) x\n⊢ Eq (↑g.toLinearPMap x) (Submodule.valFromGraph hg ⋯)","decl":"theorem toLinearPMap_apply_aux {g : Submodule R (E × F)}\n    (hg : ∀ (x : E × F) (_hx : x ∈ g) (_hx' : x.fst = 0), x.snd = 0)\n    (x : g.map (LinearMap.fst R E F)) :\n    g.toLinearPMap x = valFromGraph hg x.2 := by\n  classical\n  change (if hg : _ then g.toLinearPMapAux hg else 0) x = _\n  rw [dif_pos]\n  · rfl\n  · exact hg\n\n"}
{"name":"Submodule.mem_graph_toLinearPMap","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\ng : Submodule R (Prod E F)\nhg : ∀ (x : Prod E F), Membership.mem g x → Eq x.1 0 → Eq x.2 0\nx : Subtype fun x => Membership.mem (Submodule.map (LinearMap.fst R E F) g) x\n⊢ Membership.mem g { fst := ↑x, snd := ↑g.toLinearPMap x }","decl":"theorem mem_graph_toLinearPMap {g : Submodule R (E × F)}\n    (hg : ∀ (x : E × F) (_hx : x ∈ g) (_hx' : x.fst = 0), x.snd = 0)\n    (x : g.map (LinearMap.fst R E F)) : (x.val, g.toLinearPMap x) ∈ g := by\n  rw [toLinearPMap_apply_aux hg]\n  exact valFromGraph_mem hg x.2\n\n"}
{"name":"Submodule.toLinearPMap_graph_eq","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\ng : Submodule R (Prod E F)\nhg : ∀ (x : Prod E F), Membership.mem g x → Eq x.1 0 → Eq x.2 0\n⊢ Eq g.toLinearPMap.graph g","decl":"@[simp]\ntheorem toLinearPMap_graph_eq (g : Submodule R (E × F))\n    (hg : ∀ (x : E × F) (_hx : x ∈ g) (_hx' : x.fst = 0), x.snd = 0) :\n    g.toLinearPMap.graph = g := by\n  ext x\n  constructor <;> intro hx\n  · rw [LinearPMap.mem_graph_iff] at hx\n    rcases hx with ⟨y, hx1, hx2⟩\n    convert g.mem_graph_toLinearPMap hg y using 1\n    exact Prod.ext hx1.symm hx2.symm\n  rw [LinearPMap.mem_graph_iff]\n  cases' x with x_fst x_snd\n  have hx_fst : x_fst ∈ g.map (LinearMap.fst R E F) := by\n    simp only [mem_map, LinearMap.fst_apply, Prod.exists, exists_and_right, exists_eq_right]\n    exact ⟨x_snd, hx⟩\n  refine ⟨⟨x_fst, hx_fst⟩, Subtype.coe_mk x_fst hx_fst, ?_⟩\n  rw [toLinearPMap_apply_aux hg]\n  exact (existsUnique_from_graph @hg hx_fst).unique (valFromGraph_mem hg hx_fst) hx\n\n"}
{"name":"Submodule.toLinearPMap_range","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\ng : Submodule R (Prod E F)\nhg : ∀ (x : Prod E F), Membership.mem g x → Eq x.1 0 → Eq x.2 0\n⊢ Eq (LinearMap.range g.toLinearPMap.toFun) (Submodule.map (LinearMap.snd R E F) g)","decl":"theorem toLinearPMap_range (g : Submodule R (E × F))\n    (hg : ∀ (x : E × F) (_hx : x ∈ g) (_hx' : x.fst = 0), x.snd = 0) :\n    LinearMap.range g.toLinearPMap.toFun = g.map (LinearMap.snd R E F) := by\n  rwa [← LinearPMap.graph_map_snd_eq_range, toLinearPMap_graph_eq]\n\n"}
{"name":"LinearPMap.inverse_domain","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\nf : LinearPMap R E F\n⊢ Eq f.inverse.domain (LinearMap.range f.toFun)","decl":"theorem inverse_domain : (inverse f).domain = LinearMap.range f.toFun := by\n  rw [inverse, Submodule.toLinearPMap_domain, ← graph_map_snd_eq_range,\n    ← LinearEquiv.fst_comp_prodComm, Submodule.map_comp]\n  rfl\n\n"}
{"name":"LinearPMap.mem_inverse_graph_snd_eq_zero","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\nf : LinearPMap R E F\nhf : Eq (LinearMap.ker f.toFun) Bot.bot\nx : Prod F E\nhv : Membership.mem (Submodule.map (LinearEquiv.prodComm R E F) f.graph) x\nhv' : Eq x.1 0\n⊢ Eq x.2 0","decl":"/-- The graph of the inverse generates a `LinearPMap`. -/\ntheorem mem_inverse_graph_snd_eq_zero (x : F × E)\n    (hv : x ∈ (graph f).map (LinearEquiv.prodComm R E F))\n    (hv' : x.fst = 0) : x.snd = 0 := by\n  simp only [Submodule.mem_map, mem_graph_iff, Subtype.exists, exists_and_left, exists_eq_left,\n    LinearEquiv.prodComm_apply, Prod.exists, Prod.swap_prod_mk] at hv\n  rcases hv with ⟨a, b, ⟨ha, h1⟩, ⟨h2, h3⟩⟩\n  simp only at hv' ⊢\n  rw [hv'] at h1\n  rw [LinearMap.ker_eq_bot'] at hf\n  specialize hf ⟨a, ha⟩ h1\n  simp only [Submodule.mk_eq_zero] at hf\n  exact hf\n\n"}
{"name":"LinearPMap.inverse_graph","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\nf : LinearPMap R E F\nhf : Eq (LinearMap.ker f.toFun) Bot.bot\n⊢ Eq f.inverse.graph (Submodule.map (LinearEquiv.prodComm R E F) f.graph)","decl":"theorem inverse_graph : (inverse f).graph = f.graph.map (LinearEquiv.prodComm R E F) := by\n  rw [inverse, Submodule.toLinearPMap_graph_eq _ (mem_inverse_graph_snd_eq_zero hf)]\n\n"}
{"name":"LinearPMap.inverse_range","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\nf : LinearPMap R E F\nhf : Eq (LinearMap.ker f.toFun) Bot.bot\n⊢ Eq (LinearMap.range f.inverse.toFun) f.domain","decl":"theorem inverse_range : LinearMap.range (inverse f).toFun = f.domain := by\n  rw [inverse, Submodule.toLinearPMap_range _ (mem_inverse_graph_snd_eq_zero hf),\n    ← graph_map_fst_eq_domain, ← LinearEquiv.snd_comp_prodComm, Submodule.map_comp]\n  rfl\n\n"}
{"name":"LinearPMap.mem_inverse_graph","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\nf : LinearPMap R E F\nhf : Eq (LinearMap.ker f.toFun) Bot.bot\nx : Subtype fun x => Membership.mem f.domain x\n⊢ Membership.mem f.inverse.graph { fst := ↑f x, snd := ↑x }","decl":"theorem mem_inverse_graph (x : f.domain) : (f x, (x : E)) ∈ (inverse f).graph := by\n  simp only [inverse_graph hf, Submodule.mem_map, mem_graph_iff, Subtype.exists, exists_and_left,\n    exists_eq_left, LinearEquiv.prodComm_apply, Prod.exists, Prod.swap_prod_mk, Prod.mk.injEq]\n  exact ⟨(x : E), f x, ⟨x.2, Eq.refl _⟩, Eq.refl _, Eq.refl _⟩\n\n"}
{"name":"LinearPMap.inverse_apply_eq","module":"Mathlib.LinearAlgebra.LinearPMap","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nE : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module R E\nF : Type u_3\ninst✝¹ : AddCommGroup F\ninst✝ : Module R F\nf : LinearPMap R E F\nhf : Eq (LinearMap.ker f.toFun) Bot.bot\ny : Subtype fun x => Membership.mem f.inverse.domain x\nx : Subtype fun x => Membership.mem f.domain x\nhxy : Eq (↑f x) ↑y\n⊢ Eq (↑f.inverse y) ↑x","decl":"theorem inverse_apply_eq {y : (inverse f).domain} {x : f.domain} (hxy : f x = y) :\n    (inverse f) y = x := by\n  have := mem_inverse_graph hf x\n  simp only [mem_graph_iff, Subtype.exists, exists_and_left, exists_eq_left] at this\n  rcases this with ⟨hx, h⟩\n  rw [← h]\n  congr\n  simp only [hxy, Subtype.coe_eta]\n\n"}
