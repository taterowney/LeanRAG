{"name":"AlgebraicGeometry.IsAffine.affine","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nself : AlgebraicGeometry.IsAffine X\n‚ä¢ CategoryTheory.IsIso X.toSpecŒì","decl":"/-- A Scheme is affine if the canonical map `X ‚ü∂ Spec Œì(X)` is an isomorphism. -/\nclass IsAffine (X : Scheme) : Prop where\n  affine : IsIso X.toSpecŒì\n\n"}
{"name":"AlgebraicGeometry.instIsIsoSchemeAppUnitOppositeCommRingCatAdjunctionOfIsAffine","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\ninst‚úù : AlgebraicGeometry.IsAffine X\n‚ä¢ CategoryTheory.IsIso (AlgebraicGeometry.ŒìSpec.adjunction.unit.app X)","decl":"instance (X : Scheme.{u}) [IsAffine X] : IsIso (ŒìSpec.adjunction.unit.app X) := @IsAffine.affine X _\n\n"}
{"name":"AlgebraicGeometry.Scheme.isoSpec_hom","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\ninst‚úù : AlgebraicGeometry.IsAffine X\n‚ä¢ Eq X.isoSpec.hom X.toSpecŒì","decl":"/-- The canonical isomorphism `X ‚âÖ Spec Œì(X)` for an affine scheme. -/\n@[simps! (config := .lemmasOnly) hom]\ndef Scheme.isoSpec (X : Scheme) [IsAffine X] : X ‚âÖ Spec Œì(X, ‚ä§) :=\n  asIso X.toSpecŒì\n\n"}
{"name":"AlgebraicGeometry.Scheme.isoSpec_hom_naturality","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\ninst‚úù¬π : AlgebraicGeometry.IsAffine X\ninst‚úù : AlgebraicGeometry.IsAffine Y\nf : Quiver.Hom X Y\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp X.isoSpec.hom (AlgebraicGeometry.Spec.map (AlgebraicGeometry.Scheme.Hom.appTop f))) (CategoryTheory.CategoryStruct.comp f Y.isoSpec.hom)","decl":"@[reassoc]\ntheorem Scheme.isoSpec_hom_naturality {X Y : Scheme} [IsAffine X] [IsAffine Y] (f : X ‚ü∂ Y) :\n    X.isoSpec.hom ‚â´ Spec.map (f.appTop) = f ‚â´ Y.isoSpec.hom := by\n  simp only [isoSpec, asIso_hom, Scheme.toSpecŒì_naturality]\n\n"}
{"name":"AlgebraicGeometry.Scheme.isoSpec_hom_naturality_assoc","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\ninst‚úù¬π : AlgebraicGeometry.IsAffine X\ninst‚úù : AlgebraicGeometry.IsAffine Y\nf : Quiver.Hom X Y\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (AlgebraicGeometry.Spec (Y.presheaf.obj { unop := Top.top })) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp X.isoSpec.hom (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map (AlgebraicGeometry.Scheme.Hom.appTop f)) h)) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp Y.isoSpec.hom h))","decl":"@[reassoc]\ntheorem Scheme.isoSpec_hom_naturality {X Y : Scheme} [IsAffine X] [IsAffine Y] (f : X ‚ü∂ Y) :\n    X.isoSpec.hom ‚â´ Spec.map (f.appTop) = f ‚â´ Y.isoSpec.hom := by\n  simp only [isoSpec, asIso_hom, Scheme.toSpecŒì_naturality]\n\n"}
{"name":"AlgebraicGeometry.Scheme.isoSpec_inv_naturality","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\ninst‚úù¬π : AlgebraicGeometry.IsAffine X\ninst‚úù : AlgebraicGeometry.IsAffine Y\nf : Quiver.Hom X Y\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map (AlgebraicGeometry.Scheme.Hom.appTop f)) Y.isoSpec.inv) (CategoryTheory.CategoryStruct.comp X.isoSpec.inv f)","decl":"@[reassoc]\ntheorem Scheme.isoSpec_inv_naturality {X Y : Scheme} [IsAffine X] [IsAffine Y] (f : X ‚ü∂ Y) :\n    Spec.map (f.appTop) ‚â´ Y.isoSpec.inv = X.isoSpec.inv ‚â´ f := by\n  rw [Iso.eq_inv_comp, isoSpec, asIso_hom, ‚Üê Scheme.toSpecŒì_naturality_assoc, isoSpec,\n    asIso_inv, IsIso.hom_inv_id, Category.comp_id]\n\n"}
{"name":"AlgebraicGeometry.Scheme.isoSpec_inv_naturality_assoc","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\ninst‚úù¬π : AlgebraicGeometry.IsAffine X\ninst‚úù : AlgebraicGeometry.IsAffine Y\nf : Quiver.Hom X Y\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map (AlgebraicGeometry.Scheme.Hom.appTop f)) (CategoryTheory.CategoryStruct.comp Y.isoSpec.inv h)) (CategoryTheory.CategoryStruct.comp X.isoSpec.inv (CategoryTheory.CategoryStruct.comp f h))","decl":"@[reassoc]\ntheorem Scheme.isoSpec_inv_naturality {X Y : Scheme} [IsAffine X] [IsAffine Y] (f : X ‚ü∂ Y) :\n    Spec.map (f.appTop) ‚â´ Y.isoSpec.inv = X.isoSpec.inv ‚â´ f := by\n  rw [Iso.eq_inv_comp, isoSpec, asIso_hom, ‚Üê Scheme.toSpecŒì_naturality_assoc, isoSpec,\n    asIso_inv, IsIso.hom_inv_id, Category.comp_id]\n\n"}
{"name":"AlgebraicGeometry.Scheme.toSpecŒì_isoSpec_inv_assoc","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\ninst‚úù : AlgebraicGeometry.IsAffine X\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp X.toSpecŒì (CategoryTheory.CategoryStruct.comp X.isoSpec.inv h)) h","decl":"@[reassoc (attr := simp)]\nlemma Scheme.toSpecŒì_isoSpec_inv (X : Scheme.{u}) [IsAffine X] :\n    X.toSpecŒì ‚â´ X.isoSpec.inv  = ùüô _ :=\n  X.isoSpec.hom_inv_id\n\n"}
{"name":"AlgebraicGeometry.Scheme.toSpecŒì_isoSpec_inv","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\ninst‚úù : AlgebraicGeometry.IsAffine X\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp X.toSpecŒì X.isoSpec.inv) (CategoryTheory.CategoryStruct.id X)","decl":"@[reassoc (attr := simp)]\nlemma Scheme.toSpecŒì_isoSpec_inv (X : Scheme.{u}) [IsAffine X] :\n    X.toSpecŒì ‚â´ X.isoSpec.inv  = ùüô _ :=\n  X.isoSpec.hom_inv_id\n\n"}
{"name":"AlgebraicGeometry.Scheme.isoSpec_inv_toSpecŒì_assoc","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\ninst‚úù : AlgebraicGeometry.IsAffine X\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (AlgebraicGeometry.Spec (X.presheaf.obj { unop := Top.top })) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp X.isoSpec.inv (CategoryTheory.CategoryStruct.comp X.toSpecŒì h)) h","decl":"@[reassoc (attr := simp)]\nlemma Scheme.isoSpec_inv_toSpecŒì (X : Scheme.{u}) [IsAffine X] :\n    X.isoSpec.inv ‚â´ X.toSpecŒì = ùüô _ :=\n  X.isoSpec.inv_hom_id\n\n"}
{"name":"AlgebraicGeometry.Scheme.isoSpec_inv_toSpecŒì","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\ninst‚úù : AlgebraicGeometry.IsAffine X\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp X.isoSpec.inv X.toSpecŒì) (CategoryTheory.CategoryStruct.id (AlgebraicGeometry.Spec (X.presheaf.obj { unop := Top.top })))","decl":"@[reassoc (attr := simp)]\nlemma Scheme.isoSpec_inv_toSpecŒì (X : Scheme.{u}) [IsAffine X] :\n    X.isoSpec.inv ‚â´ X.toSpecŒì = ùüô _ :=\n  X.isoSpec.inv_hom_id\n\n"}
{"name":"AlgebraicGeometry.AffineScheme.mk_obj","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nx‚úù : AlgebraicGeometry.IsAffine X\n‚ä¢ Eq (AlgebraicGeometry.AffineScheme.mk X x‚úù).obj X","decl":"/-- Construct an affine scheme from a scheme and the information that it is affine.\nAlso see `AffineScheme.of` for a typeclass version. -/\n@[simps]\ndef AffineScheme.mk (X : Scheme) (_ : IsAffine X) : AffineScheme :=\n  ‚ü®X, ŒìSpec.adjunction.mem_essImage_of_unit_isIso _‚ü©\n\n"}
{"name":"AlgebraicGeometry.mem_Spec_essImage","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\n‚ä¢ Iff (Membership.mem AlgebraicGeometry.Scheme.Spec.essImage X) (AlgebraicGeometry.IsAffine X)","decl":"theorem mem_Spec_essImage (X : Scheme) : X ‚àà Scheme.Spec.essImage ‚Üî IsAffine X :=\n  ‚ü®fun h => ‚ü®Functor.essImage.unit_isIso h‚ü©,\n    fun _ => ŒìSpec.adjunction.mem_essImage_of_unit_isIso _‚ü©\n\n"}
{"name":"AlgebraicGeometry.isAffine_affineScheme","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.AffineScheme\n‚ä¢ AlgebraicGeometry.IsAffine X.obj","decl":"instance isAffine_affineScheme (X : AffineScheme.{u}) : IsAffine X.obj :=\n  ‚ü®Functor.essImage.unit_isIso X.property‚ü©\n\n"}
{"name":"AlgebraicGeometry.instIsAffineObjOppositeCommRingCatSchemeSpec","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"R : Opposite CommRingCat\n‚ä¢ AlgebraicGeometry.IsAffine (AlgebraicGeometry.Scheme.Spec.obj R)","decl":"instance (R : CommRingCat·µí·µñ) : IsAffine (Scheme.Spec.obj R) :=\n  AlgebraicGeometry.isAffine_affineScheme ‚ü®_, Scheme.Spec.obj_mem_essImage R‚ü©\n\n"}
{"name":"AlgebraicGeometry.isAffine_Spec","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"R : CommRingCat\n‚ä¢ AlgebraicGeometry.IsAffine (AlgebraicGeometry.Spec R)","decl":"instance isAffine_Spec (R : CommRingCat) : IsAffine (Spec R) :=\n  AlgebraicGeometry.isAffine_affineScheme ‚ü®_, Scheme.Spec.obj_mem_essImage (op R)‚ü©\n\n"}
{"name":"AlgebraicGeometry.isAffine_of_isIso","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.IsIso f\nh : AlgebraicGeometry.IsAffine Y\n‚ä¢ AlgebraicGeometry.IsAffine X","decl":"theorem isAffine_of_isIso {X Y : Scheme} (f : X ‚ü∂ Y) [IsIso f] [h : IsAffine Y] : IsAffine X := by\n  rw [‚Üê mem_Spec_essImage] at h ‚ä¢; exact Functor.essImage.ofIso (asIso f).symm h\n\n"}
{"name":"AlgebraicGeometry.Scheme.isoSpec_Spec","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"R : CommRingCat\n‚ä¢ Eq (AlgebraicGeometry.Spec R).isoSpec (AlgebraicGeometry.Scheme.Spec.mapIso (AlgebraicGeometry.Scheme.ŒìSpecIso R).op)","decl":"theorem Scheme.isoSpec_Spec (R : CommRingCat.{u}) :\n    (Spec R).isoSpec = Scheme.Spec.mapIso (Scheme.ŒìSpecIso R).op :=\n  Iso.ext (SpecMap_ŒìSpecIso_hom R).symm\n\n"}
{"name":"AlgebraicGeometry.Scheme.isoSpec_Spec_hom","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"R : CommRingCat\n‚ä¢ Eq (AlgebraicGeometry.Spec R).isoSpec.hom (AlgebraicGeometry.Spec.map (AlgebraicGeometry.Scheme.ŒìSpecIso R).hom)","decl":"@[simp] theorem Scheme.isoSpec_Spec_hom (R : CommRingCat.{u}) :\n    (Spec R).isoSpec.hom = Spec.map (Scheme.ŒìSpecIso R).hom :=\n  (SpecMap_ŒìSpecIso_hom R).symm\n\n"}
{"name":"AlgebraicGeometry.Scheme.isoSpec_Spec_inv","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"R : CommRingCat\n‚ä¢ Eq (AlgebraicGeometry.Spec R).isoSpec.inv (AlgebraicGeometry.Spec.map (AlgebraicGeometry.Scheme.ŒìSpecIso R).inv)","decl":"@[simp] theorem Scheme.isoSpec_Spec_inv (R : CommRingCat.{u}) :\n    (Spec R).isoSpec.inv = Spec.map (Scheme.ŒìSpecIso R).inv :=\n  congr($(isoSpec_Spec R).inv)\n\n"}
{"name":"AlgebraicGeometry.ext_of_isAffine","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\ninst‚úù : AlgebraicGeometry.IsAffine Y\nf g : Quiver.Hom X Y\ne : Eq (AlgebraicGeometry.Scheme.Hom.appTop f) (AlgebraicGeometry.Scheme.Hom.appTop g)\n‚ä¢ Eq f g","decl":"lemma ext_of_isAffine {X Y : Scheme} [IsAffine Y] {f g : X ‚ü∂ Y} (e : f.appTop = g.appTop) :\n    f = g := by\n  rw [‚Üê cancel_mono Y.toSpecŒì, Scheme.toSpecŒì_naturality, Scheme.toSpecŒì_naturality, e]\n\n"}
{"name":"AlgebraicGeometry.AffineScheme.Spec_full","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"‚ä¢ AlgebraicGeometry.AffineScheme.Spec.Full","decl":"instance Spec_full : Spec.Full := Functor.Full.toEssImage _\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11081): cannot automatically derive\n"}
{"name":"AlgebraicGeometry.AffineScheme.Spec_faithful","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"‚ä¢ AlgebraicGeometry.AffineScheme.Spec.Faithful","decl":"instance Spec_faithful : Spec.Faithful := Functor.Faithful.toEssImage _\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11081): cannot automatically derive\n"}
{"name":"AlgebraicGeometry.AffineScheme.Spec_essSurj","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"‚ä¢ AlgebraicGeometry.AffineScheme.Spec.EssSurj","decl":"instance Spec_essSurj : Spec.EssSurj := Functor.EssSurj.toEssImage (F := _)\n\n"}
{"name":"AlgebraicGeometry.AffineScheme.forgetToScheme_map","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X‚úù Y‚úù : CategoryTheory.InducedCategory AlgebraicGeometry.Scheme CategoryTheory.FullSubcategory.obj\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (AlgebraicGeometry.AffineScheme.forgetToScheme.map f) f","decl":"/-- The forgetful functor `AffineScheme ‚•§ Scheme`. -/\n@[simps!]\ndef forgetToScheme : AffineScheme ‚•§ Scheme :=\n  Scheme.Spec.essImageInclusion\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11081): cannot automatically derive\n"}
{"name":"AlgebraicGeometry.AffineScheme.forgetToScheme_obj","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"self : CategoryTheory.FullSubcategory AlgebraicGeometry.Scheme.Spec.essImage\n‚ä¢ Eq (AlgebraicGeometry.AffineScheme.forgetToScheme.obj self) self.obj","decl":"/-- The forgetful functor `AffineScheme ‚•§ Scheme`. -/\n@[simps!]\ndef forgetToScheme : AffineScheme ‚•§ Scheme :=\n  Scheme.Spec.essImageInclusion\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11081): cannot automatically derive\n"}
{"name":"AlgebraicGeometry.AffineScheme.forgetToScheme_full","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"‚ä¢ AlgebraicGeometry.AffineScheme.forgetToScheme.Full","decl":"instance forgetToScheme_full : forgetToScheme.Full :=\nshow (Scheme.Spec.essImageInclusion).Full from inferInstance\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11081): cannot automatically derive\n"}
{"name":"AlgebraicGeometry.AffineScheme.forgetToScheme_faithful","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"‚ä¢ AlgebraicGeometry.AffineScheme.forgetToScheme.Faithful","decl":"instance forgetToScheme_faithful : forgetToScheme.Faithful :=\nshow (Scheme.Spec.essImageInclusion).Faithful from inferInstance\n\n"}
{"name":"AlgebraicGeometry.AffineScheme.instIsEquivalenceOppositeCommRingCatRightOpŒì","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"‚ä¢ AlgebraicGeometry.AffineScheme.Œì.rightOp.IsEquivalence","decl":"instance : Œì.{u}.rightOp.IsEquivalence := equivCommRingCat.isEquivalence_functor\n\n"}
{"name":"AlgebraicGeometry.AffineScheme.instIsEquivalenceOppositeCommRingCatOpRightOpŒì","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"‚ä¢ AlgebraicGeometry.AffineScheme.Œì.rightOp.op.IsEquivalence","decl":"instance : Œì.{u}.rightOp.op.IsEquivalence := equivCommRingCat.op.isEquivalence_functor\n\n"}
{"name":"AlgebraicGeometry.AffineScheme.ŒìIsEquiv","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"‚ä¢ AlgebraicGeometry.AffineScheme.Œì.IsEquivalence","decl":"instance ŒìIsEquiv : Œì.{u}.IsEquivalence :=\n  inferInstanceAs (Œì.{u}.rightOp.op ‚ãô (opOpEquivalence _).functor).IsEquivalence\n\n"}
{"name":"AlgebraicGeometry.AffineScheme.hasColimits","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"‚ä¢ CategoryTheory.Limits.HasColimits AlgebraicGeometry.AffineScheme","decl":"instance hasColimits : HasColimits AffineScheme.{u} :=\n  haveI := Adjunction.has_limits_of_equivalence.{u} Œì.{u}\n  Adjunction.has_colimits_of_equivalence.{u} (opOpEquivalence AffineScheme.{u}).inverse\n\n"}
{"name":"AlgebraicGeometry.AffineScheme.hasLimits","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"‚ä¢ CategoryTheory.Limits.HasLimits AlgebraicGeometry.AffineScheme","decl":"instance hasLimits : HasLimits AffineScheme.{u} := by\n  haveI := Adjunction.has_colimits_of_equivalence Œì.{u}\n  haveI : HasLimits AffineScheme.{u}·µí·µñ·µí·µñ := Limits.hasLimits_op_of_hasColimits\n  exact Adjunction.has_limits_of_equivalence (opOpEquivalence AffineScheme.{u}).inverse\n\n"}
{"name":"AlgebraicGeometry.AffineScheme.Œì_preservesLimits","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"‚ä¢ CategoryTheory.Limits.PreservesLimits AlgebraicGeometry.AffineScheme.Œì.rightOp","decl":"noncomputable instance Œì_preservesLimits : PreservesLimits Œì.{u}.rightOp := inferInstance\n\n"}
{"name":"AlgebraicGeometry.AffineScheme.forgetToScheme_preservesLimits","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"‚ä¢ CategoryTheory.Limits.PreservesLimits AlgebraicGeometry.AffineScheme.forgetToScheme","decl":"noncomputable instance forgetToScheme_preservesLimits : PreservesLimits forgetToScheme := by\n  apply (config := { allowSynthFailures := true })\n    @preservesLimits_of_natIso _ _ _ _ _ _\n      (isoWhiskerRight equivCommRingCat.unitIso forgetToScheme).symm\n  change PreservesLimits (equivCommRingCat.functor ‚ãô Scheme.Spec)\n  infer_instance\n\n"}
{"name":"AlgebraicGeometry.instIsAffineToSchemeValOpensMemSetAffineOpens","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"Y : AlgebraicGeometry.Scheme\nU : ‚ÜëY.affineOpens\n‚ä¢ AlgebraicGeometry.IsAffine ‚Üë‚ÜëU","decl":"instance {Y : Scheme.{u}} (U : Y.affineOpens) : IsAffine U :=\n  U.property\n\n"}
{"name":"AlgebraicGeometry.isAffineOpen_opensRange","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\ninst‚úù : AlgebraicGeometry.IsAffine X\nf : Quiver.Hom X Y\nH : AlgebraicGeometry.IsOpenImmersion f\n‚ä¢ AlgebraicGeometry.IsAffineOpen (AlgebraicGeometry.Scheme.Hom.opensRange f)","decl":"theorem isAffineOpen_opensRange {X Y : Scheme} [IsAffine X] (f : X ‚ü∂ Y)\n    [H : IsOpenImmersion f] : IsAffineOpen (Scheme.Hom.opensRange f) := by\n  refine isAffine_of_isIso (IsOpenImmersion.isoOfRangeEq f (Y.ofRestrict _) ?_).inv\n  exact Subtype.range_val.symm\n\n"}
{"name":"AlgebraicGeometry.isAffineOpen_top","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\ninst‚úù : AlgebraicGeometry.IsAffine X\n‚ä¢ AlgebraicGeometry.IsAffineOpen Top.top","decl":"theorem isAffineOpen_top (X : Scheme) [IsAffine X] : IsAffineOpen (‚ä§ : X.Opens) := by\n  convert isAffineOpen_opensRange (ùüô X)\n  ext1\n  exact Set.range_id.symm\n\n"}
{"name":"AlgebraicGeometry.Scheme.isAffine_affineCover","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\ni : X.affineCover.J\n‚ä¢ AlgebraicGeometry.IsAffine (X.affineCover.obj i)","decl":"instance Scheme.isAffine_affineCover (X : Scheme) (i : X.affineCover.J) :\n    IsAffine (X.affineCover.obj i) :=\n  isAffine_Spec _\n\n"}
{"name":"AlgebraicGeometry.Scheme.isAffine_affineBasisCover","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\ni : X.affineBasisCover.J\n‚ä¢ AlgebraicGeometry.IsAffine (X.affineBasisCover.obj i)","decl":"instance Scheme.isAffine_affineBasisCover (X : Scheme) (i : X.affineBasisCover.J) :\n    IsAffine (X.affineBasisCover.obj i) :=\n  isAffine_Spec _\n\n"}
{"name":"AlgebraicGeometry.Scheme.isAffine_affineOpenCover","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nùí∞ : X.AffineOpenCover\ni : ùí∞.J\n‚ä¢ AlgebraicGeometry.IsAffine (ùí∞.openCover.obj i)","decl":"instance Scheme.isAffine_affineOpenCover (X : Scheme) (ùí∞ : X.AffineOpenCover) (i : ùí∞.J) :\n    IsAffine (ùí∞.openCover.obj i) :=\n  inferInstanceAs (IsAffine (Spec (ùí∞.obj i)))\n\n"}
{"name":"AlgebraicGeometry.instIsAffineObjIsOpenImmersionCoverOfIsIsoIdScheme","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\ninst‚úù : AlgebraicGeometry.IsAffine X\ni : (AlgebraicGeometry.Scheme.coverOfIsIso (CategoryTheory.CategoryStruct.id X)).J\n‚ä¢ AlgebraicGeometry.IsAffine ((AlgebraicGeometry.Scheme.coverOfIsIso (CategoryTheory.CategoryStruct.id X)).obj i)","decl":"instance {X} [IsAffine X] (i) :\n    IsAffine ((Scheme.coverOfIsIso (P := @IsOpenImmersion) (ùüô X)).obj i) := by\n  dsimp; infer_instance\n\n"}
{"name":"AlgebraicGeometry.isBasis_affine_open","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\n‚ä¢ TopologicalSpace.Opens.IsBasis X.affineOpens","decl":"theorem isBasis_affine_open (X : Scheme) : Opens.IsBasis X.affineOpens := by\n  rw [Opens.isBasis_iff_nbhd]\n  rintro U x (hU : x ‚àà (U : Set X))\n  obtain ‚ü®S, hS, hxS, hSU‚ü© := X.affineBasisCover_is_basis.exists_subset_of_mem_open hU U.isOpen\n  refine ‚ü®‚ü®S, X.affineBasisCover_is_basis.isOpen hS‚ü©, ?_, hxS, hSU‚ü©\n  rcases hS with ‚ü®i, rfl‚ü©\n  exact isAffineOpen_opensRange _\n\n"}
{"name":"AlgebraicGeometry.iSup_affineOpens_eq_top","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\n‚ä¢ Eq (iSup fun i => ‚Üëi) Top.top","decl":"theorem iSup_affineOpens_eq_top (X : Scheme) : ‚®Ü i : X.affineOpens, (i : X.Opens) = ‚ä§ := by\n  apply Opens.ext\n  rw [Opens.coe_iSup]\n  apply IsTopologicalBasis.sUnion_eq\n  rw [‚Üê Set.image_eq_range]\n  exact isBasis_affine_open X\n\n"}
{"name":"AlgebraicGeometry.Scheme.map_PrimeSpectrum_basicOpen_of_affine","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\ninst‚úù : AlgebraicGeometry.IsAffine X\nf : ‚Üë(X.presheaf.obj { unop := Top.top })\n‚ä¢ Eq ((TopologicalSpace.Opens.map X.isoSpec.hom.base).obj (PrimeSpectrum.basicOpen f)) (X.basicOpen f)","decl":"theorem Scheme.map_PrimeSpectrum_basicOpen_of_affine\n    (X : Scheme) [IsAffine X] (f : Œì(X, ‚ä§)) :\n    X.isoSpec.hom ‚Åª¬π·µÅ PrimeSpectrum.basicOpen f = X.basicOpen f :=\n  Scheme.toSpecŒì_preimage_basicOpen _ _\n\n"}
{"name":"AlgebraicGeometry.isBasis_basicOpen","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\ninst‚úù : AlgebraicGeometry.IsAffine X\n‚ä¢ TopologicalSpace.Opens.IsBasis (Set.range X.basicOpen)","decl":"theorem isBasis_basicOpen (X : Scheme) [IsAffine X] :\n    Opens.IsBasis (Set.range (X.basicOpen : Œì(X, ‚ä§) ‚Üí X.Opens)) := by\n  delta Opens.IsBasis\n  convert PrimeSpectrum.isBasis_basic_opens.isInducing\n    (TopCat.homeoOfIso (Scheme.forgetToTop.mapIso X.isoSpec)).isInducing using 1\n  ext\n  simp only [Set.mem_image, exists_exists_eq_and]\n  constructor\n  ¬∑ rintro ‚ü®_, ‚ü®x, rfl‚ü©, rfl‚ü©\n    refine ‚ü®_, ‚ü®_, ‚ü®x, rfl‚ü©, rfl‚ü©, ?_‚ü©\n    exact congr_arg Opens.carrier (Scheme.toSpecŒì_preimage_basicOpen _ _)\n  ¬∑ rintro ‚ü®_, ‚ü®_, ‚ü®x, rfl‚ü©, rfl‚ü©, rfl‚ü©\n    refine ‚ü®_, ‚ü®x, rfl‚ü©, ?_‚ü©\n    exact congr_arg Opens.carrier (Scheme.toSpecŒì_preimage_basicOpen _ _).symm\n\n"}
{"name":"AlgebraicGeometry.Scheme.Opens.toSpecŒì_SpecMap_map_assoc","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU V : X.Opens\nh‚úù : LE.le U V\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (AlgebraicGeometry.Spec (X.presheaf.obj { unop := V })) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp U.toSpecŒì (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map (X.presheaf.map (CategoryTheory.homOfLE h‚úù).op)) h)) (CategoryTheory.CategoryStruct.comp (X.homOfLE h‚úù) (CategoryTheory.CategoryStruct.comp V.toSpecŒì h))","decl":"@[reassoc (attr := simp)]\nlemma Scheme.Opens.toSpecŒì_SpecMap_map {X : Scheme} (U V : X.Opens) (h : U ‚â§ V) :\n    U.toSpecŒì ‚â´ Spec.map (X.presheaf.map (homOfLE h).op) = X.homOfLE h ‚â´ V.toSpecŒì := by\n  delta Scheme.Opens.toSpecŒì\n  simp [‚Üê Spec.map_comp, ‚Üê X.presheaf.map_comp, toSpecŒì_naturality_assoc]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Opens.toSpecŒì_SpecMap_map","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU V : X.Opens\nh : LE.le U V\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp U.toSpecŒì (AlgebraicGeometry.Spec.map (X.presheaf.map (CategoryTheory.homOfLE h).op))) (CategoryTheory.CategoryStruct.comp (X.homOfLE h) V.toSpecŒì)","decl":"@[reassoc (attr := simp)]\nlemma Scheme.Opens.toSpecŒì_SpecMap_map {X : Scheme} (U V : X.Opens) (h : U ‚â§ V) :\n    U.toSpecŒì ‚â´ Spec.map (X.presheaf.map (homOfLE h).op) = X.homOfLE h ‚â´ V.toSpecŒì := by\n  delta Scheme.Opens.toSpecŒì\n  simp [‚Üê Spec.map_comp, ‚Üê X.presheaf.map_comp, toSpecŒì_naturality_assoc]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Opens.toSpecŒì_top","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\n‚ä¢ Eq Top.top.toSpecŒì (CategoryTheory.CategoryStruct.comp Top.top.Œπ X.toSpecŒì)","decl":"@[simp]\nlemma Scheme.Opens.toSpecŒì_top {X : Scheme} :\n    (‚ä§ : X.Opens).toSpecŒì = (‚ä§ : X.Opens).Œπ ‚â´ X.toSpecŒì := by\n  simp [Scheme.Opens.toSpecŒì, toSpecŒì_naturality]; rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.Opens.toSpecŒì_appTop","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\n‚ä¢ Eq (AlgebraicGeometry.Scheme.Hom.appTop U.toSpecŒì) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.ŒìSpecIso (X.presheaf.obj { unop := U })).hom U.topIso.inv)","decl":"@[reassoc]\nlemma Scheme.Opens.toSpecŒì_appTop {X : Scheme.{u}} (U : X.Opens) :\n    U.toSpecŒì.appTop = (Scheme.ŒìSpecIso Œì(X, U)).hom ‚â´ U.topIso.inv := by\n  simp [Scheme.Opens.toSpecŒì]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Opens.toSpecŒì_appTop_assoc","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nZ : CommRingCat\nh : Quiver.Hom ((‚ÜëU).presheaf.obj { unop := Top.top }) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.appTop U.toSpecŒì) h) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.ŒìSpecIso (X.presheaf.obj { unop := U })).hom (CategoryTheory.CategoryStruct.comp U.topIso.inv h))","decl":"@[reassoc]\nlemma Scheme.Opens.toSpecŒì_appTop {X : Scheme.{u}} (U : X.Opens) :\n    U.toSpecŒì.appTop = (Scheme.ŒìSpecIso Œì(X, U)).hom ‚â´ U.topIso.inv := by\n  simp [Scheme.Opens.toSpecŒì]\n\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.isoSpec_inv","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\n‚ä¢ Eq hU.isoSpec.inv (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map (X.presheaf.map (CategoryTheory.eqToHom ‚ãØ).op)) (‚ÜëU).isoSpec.inv)","decl":"attribute [-simp] eqToHom_op in\n/-- The isomorphism `U ‚âÖ Spec Œì(X, U)` for an affine `U`. -/\n@[simps! (config := .lemmasOnly) inv]\ndef isoSpec :\n    ‚ÜëU ‚âÖ Spec Œì(X, U) :=\n  haveI : IsAffine U := hU\n  U.toScheme.isoSpec ‚â™‚â´ Scheme.Spec.mapIso U.topIso.symm.op\n\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.isoSpec_hom","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\n‚ä¢ Eq hU.isoSpec.hom U.toSpecŒì","decl":"lemma isoSpec_hom : hU.isoSpec.hom = U.toSpecŒì := rfl\n\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.toSpecŒì_isoSpec_inv","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp U.toSpecŒì hU.isoSpec.inv) (CategoryTheory.CategoryStruct.id ‚ÜëU)","decl":"@[reassoc (attr := simp)]\nlemma toSpecŒì_isoSpec_inv : U.toSpecŒì ‚â´ hU.isoSpec.inv = ùüô _ := hU.isoSpec.hom_inv_id\n\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.toSpecŒì_isoSpec_inv_assoc","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (‚ÜëU) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp U.toSpecŒì (CategoryTheory.CategoryStruct.comp hU.isoSpec.inv h)) h","decl":"@[reassoc (attr := simp)]\nlemma toSpecŒì_isoSpec_inv : U.toSpecŒì ‚â´ hU.isoSpec.inv = ùüô _ := hU.isoSpec.hom_inv_id\n\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.isoSpec_inv_toSpecŒì_assoc","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (AlgebraicGeometry.Spec (X.presheaf.obj { unop := U })) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp hU.isoSpec.inv (CategoryTheory.CategoryStruct.comp U.toSpecŒì h)) h","decl":"@[reassoc (attr := simp)]\nlemma isoSpec_inv_toSpecŒì :  hU.isoSpec.inv ‚â´ U.toSpecŒì = ùüô _ := hU.isoSpec.inv_hom_id\n\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.isoSpec_inv_toSpecŒì","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp hU.isoSpec.inv U.toSpecŒì) (CategoryTheory.CategoryStruct.id (AlgebraicGeometry.Spec (X.presheaf.obj { unop := U })))","decl":"@[reassoc (attr := simp)]\nlemma isoSpec_inv_toSpecŒì :  hU.isoSpec.inv ‚â´ U.toSpecŒì = ùüô _ := hU.isoSpec.inv_hom_id\n\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.isoSpec_hom_base_apply","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\nx : Subtype fun x => Membership.mem U x\n‚ä¢ Eq (hU.isoSpec.hom.base x) ((AlgebraicGeometry.Spec.map (X.presheaf.germ U ‚Üëx ‚ãØ)).base (IsLocalRing.closedPoint ‚Üë(X.presheaf.stalk ‚Üëx)))","decl":"open IsLocalRing in\nlemma isoSpec_hom_base_apply (x : U) :\n    hU.isoSpec.hom.base x = (Spec.map (X.presheaf.germ U x x.2)).base (closedPoint _) := by\n  dsimp [IsAffineOpen.isoSpec_hom, Scheme.isoSpec_hom, Scheme.toSpecŒì_base, Scheme.Opens.toSpecŒì]\n  rw [‚Üê Scheme.comp_base_apply, ‚Üê Spec.map_comp,\n    (Iso.eq_comp_inv _).mpr (Scheme.Opens.germ_stalkIso_hom U (V := ‚ä§) x trivial),\n    X.presheaf.germ_res_assoc, Spec.map_comp, Scheme.comp_base_apply]\n  congr 1\n  exact IsLocalRing.comap_closedPoint (U.stalkIso x).inv.hom\n\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.isoSpec_inv_appTop","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\n‚ä¢ Eq (AlgebraicGeometry.Scheme.Hom.appTop hU.isoSpec.inv) (CategoryTheory.CategoryStruct.comp U.topIso.hom (AlgebraicGeometry.Scheme.ŒìSpecIso (X.presheaf.obj { unop := U })).inv)","decl":"lemma isoSpec_inv_appTop :\n    hU.isoSpec.inv.appTop = U.topIso.hom ‚â´ (Scheme.ŒìSpecIso Œì(X, U)).inv := by\n  simp only [Scheme.Opens.toScheme_presheaf_obj, isoSpec_inv, Scheme.isoSpec, asIso_inv,\n    Scheme.comp_coeBase, Opens.map_comp_obj, Opens.map_top, Scheme.comp_app, Scheme.inv_appTop,\n    Scheme.Opens.topIso_hom, Scheme.ŒìSpecIso_inv_naturality, IsIso.inv_comp_eq]\n  rw [Scheme.toSpecŒì_appTop]\n  erw [Iso.hom_inv_id_assoc]\n\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.isoSpec_hom_appTop","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\n‚ä¢ Eq (AlgebraicGeometry.Scheme.Hom.appTop hU.isoSpec.hom) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.ŒìSpecIso (X.presheaf.obj { unop := U })).hom U.topIso.inv)","decl":"lemma isoSpec_hom_appTop :\n    hU.isoSpec.hom.appTop = (Scheme.ŒìSpecIso Œì(X, U)).hom ‚â´ U.topIso.inv := by\n  have := congr(inv $hU.isoSpec_inv_appTop)\n  rw [IsIso.inv_comp, IsIso.Iso.inv_inv, IsIso.Iso.inv_hom] at this\n  have := (Scheme.Œì.map_inv hU.isoSpec.inv.op).trans this\n  rwa [‚Üê op_inv, IsIso.Iso.inv_inv] at this\n\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.isoSpec_inv_app_top","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\n‚ä¢ Eq (AlgebraicGeometry.Scheme.Hom.appTop hU.isoSpec.inv) (CategoryTheory.CategoryStruct.comp U.topIso.hom (AlgebraicGeometry.Scheme.ŒìSpecIso (X.presheaf.obj { unop := U })).inv)","decl":"@[deprecated (since := \"2024-11-16\")] alias isoSpec_inv_app_top := isoSpec_inv_appTop\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.isoSpec_hom_app_top","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\n‚ä¢ Eq (AlgebraicGeometry.Scheme.Hom.appTop hU.isoSpec.hom) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.ŒìSpecIso (X.presheaf.obj { unop := U })).hom U.topIso.inv)","decl":"@[deprecated (since := \"2024-11-16\")] alias isoSpec_hom_app_top := isoSpec_hom_appTop\n\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.isOpenImmersion_fromSpec","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\n‚ä¢ AlgebraicGeometry.IsOpenImmersion hU.fromSpec","decl":"instance isOpenImmersion_fromSpec :\n    IsOpenImmersion hU.fromSpec := by\n  delta fromSpec\n  infer_instance\n\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.isoSpec_inv_Œπ","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp hU.isoSpec.inv U.Œπ) hU.fromSpec","decl":"@[reassoc (attr := simp)]\nlemma isoSpec_inv_Œπ : hU.isoSpec.inv ‚â´ U.Œπ = hU.fromSpec := rfl\n\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.isoSpec_inv_Œπ_assoc","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp hU.isoSpec.inv (CategoryTheory.CategoryStruct.comp U.Œπ h)) (CategoryTheory.CategoryStruct.comp hU.fromSpec h)","decl":"@[reassoc (attr := simp)]\nlemma isoSpec_inv_Œπ : hU.isoSpec.inv ‚â´ U.Œπ = hU.fromSpec := rfl\n\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.toSpecŒì_fromSpec","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp U.toSpecŒì hU.fromSpec) U.Œπ","decl":"@[reassoc (attr := simp)]\nlemma toSpecŒì_fromSpec : U.toSpecŒì ‚â´ hU.fromSpec = U.Œπ := toSpecŒì_isoSpec_inv_assoc _ _\n\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.toSpecŒì_fromSpec_assoc","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp U.toSpecŒì (CategoryTheory.CategoryStruct.comp hU.fromSpec h)) (CategoryTheory.CategoryStruct.comp U.Œπ h)","decl":"@[reassoc (attr := simp)]\nlemma toSpecŒì_fromSpec : U.toSpecŒì ‚â´ hU.fromSpec = U.Œπ := toSpecŒì_isoSpec_inv_assoc _ _\n\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.range_fromSpec","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\n‚ä¢ Eq (Set.range ‚áëhU.fromSpec.base) ‚ÜëU","decl":"@[simp]\ntheorem range_fromSpec :\n    Set.range hU.fromSpec.base = (U : Set X) := by\n  delta IsAffineOpen.fromSpec; dsimp [IsAffineOpen.isoSpec_inv]\n  rw [Set.range_comp, Set.range_eq_univ.mpr, Set.image_univ]\n  ¬∑ exact Subtype.range_coe\n  rw [‚Üê coe_comp, ‚Üê TopCat.epi_iff_surjective]\n  infer_instance\n\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.opensRange_fromSpec","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\n‚ä¢ Eq (AlgebraicGeometry.Scheme.Hom.opensRange hU.fromSpec) U","decl":"@[simp]\ntheorem opensRange_fromSpec : hU.fromSpec.opensRange = U := Opens.ext (range_fromSpec hU)\n\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.map_fromSpec","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\nV : X.Opens\nhV : AlgebraicGeometry.IsAffineOpen V\nf : Quiver.Hom { unop := U } { unop := V }\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map (X.presheaf.map f)) hU.fromSpec) hV.fromSpec","decl":"@[reassoc (attr := simp)]\ntheorem map_fromSpec {V : X.Opens} (hV : IsAffineOpen V) (f : op U ‚ü∂ op V) :\n    Spec.map (X.presheaf.map f) ‚â´ hU.fromSpec = hV.fromSpec := by\n  have : IsAffine U := hU\n  haveI : IsAffine _ := hV\n  conv_rhs =>\n    rw [fromSpec, ‚Üê X.homOfLE_Œπ (V := U) f.unop.le, isoSpec_inv, Category.assoc,\n      ‚Üê Scheme.isoSpec_inv_naturality_assoc,\n      ‚Üê Spec.map_comp_assoc, Scheme.homOfLE_appTop, ‚Üê Functor.map_comp]\n  rw [fromSpec, isoSpec_inv, Category.assoc, ‚Üê Spec.map_comp_assoc, ‚Üê Functor.map_comp]\n  rfl\n\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.map_fromSpec_assoc","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\nV : X.Opens\nhV : AlgebraicGeometry.IsAffineOpen V\nf : Quiver.Hom { unop := U } { unop := V }\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map (X.presheaf.map f)) (CategoryTheory.CategoryStruct.comp hU.fromSpec h)) (CategoryTheory.CategoryStruct.comp hV.fromSpec h)","decl":"@[reassoc (attr := simp)]\ntheorem map_fromSpec {V : X.Opens} (hV : IsAffineOpen V) (f : op U ‚ü∂ op V) :\n    Spec.map (X.presheaf.map f) ‚â´ hU.fromSpec = hV.fromSpec := by\n  have : IsAffine U := hU\n  haveI : IsAffine _ := hV\n  conv_rhs =>\n    rw [fromSpec, ‚Üê X.homOfLE_Œπ (V := U) f.unop.le, isoSpec_inv, Category.assoc,\n      ‚Üê Scheme.isoSpec_inv_naturality_assoc,\n      ‚Üê Spec.map_comp_assoc, Scheme.homOfLE_appTop, ‚Üê Functor.map_comp]\n  rw [fromSpec, isoSpec_inv, Category.assoc, ‚Üê Spec.map_comp_assoc, ‚Üê Functor.map_comp]\n  rfl\n\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.Spec_map_appLE_fromSpec_assoc","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nV : X.Opens\nU : Y.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\nhV : AlgebraicGeometry.IsAffineOpen V\ni : LE.le V ((TopologicalSpace.Opens.map f.base).obj U)\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map (AlgebraicGeometry.Scheme.Hom.appLE f U V i)) (CategoryTheory.CategoryStruct.comp hU.fromSpec h)) (CategoryTheory.CategoryStruct.comp hV.fromSpec (CategoryTheory.CategoryStruct.comp f h))","decl":"@[reassoc]\nlemma Spec_map_appLE_fromSpec (f : X ‚ü∂ Y) {V : X.Opens} {U : Y.Opens}\n    (hU : IsAffineOpen U) (hV : IsAffineOpen V) (i : V ‚â§ f ‚Åª¬π·µÅ U) :\n    Spec.map (f.appLE U V i) ‚â´ hU.fromSpec = hV.fromSpec ‚â´ f := by\n  have : IsAffine U := hU\n  simp only [IsAffineOpen.fromSpec, Category.assoc, isoSpec_inv]\n  simp_rw [‚Üê Scheme.homOfLE_Œπ _ i]\n  rw [Category.assoc, ‚Üê morphismRestrict_Œπ,\n    ‚Üê Category.assoc _ (f ‚à£_ U) U.Œπ, ‚Üê @Scheme.isoSpec_inv_naturality_assoc,\n    ‚Üê Spec.map_comp_assoc, ‚Üê Spec.map_comp_assoc, Scheme.comp_appTop, morphismRestrict_appTop,\n    Scheme.homOfLE_appTop, Scheme.Hom.app_eq_appLE, Scheme.Hom.appLE_map,\n    Scheme.Hom.appLE_map, Scheme.Hom.appLE_map, Scheme.Hom.map_appLE]\n\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.Spec_map_appLE_fromSpec","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nV : X.Opens\nU : Y.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\nhV : AlgebraicGeometry.IsAffineOpen V\ni : LE.le V ((TopologicalSpace.Opens.map f.base).obj U)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map (AlgebraicGeometry.Scheme.Hom.appLE f U V i)) hU.fromSpec) (CategoryTheory.CategoryStruct.comp hV.fromSpec f)","decl":"@[reassoc]\nlemma Spec_map_appLE_fromSpec (f : X ‚ü∂ Y) {V : X.Opens} {U : Y.Opens}\n    (hU : IsAffineOpen U) (hV : IsAffineOpen V) (i : V ‚â§ f ‚Åª¬π·µÅ U) :\n    Spec.map (f.appLE U V i) ‚â´ hU.fromSpec = hV.fromSpec ‚â´ f := by\n  have : IsAffine U := hU\n  simp only [IsAffineOpen.fromSpec, Category.assoc, isoSpec_inv]\n  simp_rw [‚Üê Scheme.homOfLE_Œπ _ i]\n  rw [Category.assoc, ‚Üê morphismRestrict_Œπ,\n    ‚Üê Category.assoc _ (f ‚à£_ U) U.Œπ, ‚Üê @Scheme.isoSpec_inv_naturality_assoc,\n    ‚Üê Spec.map_comp_assoc, ‚Üê Spec.map_comp_assoc, Scheme.comp_appTop, morphismRestrict_appTop,\n    Scheme.homOfLE_appTop, Scheme.Hom.app_eq_appLE, Scheme.Hom.appLE_map,\n    Scheme.Hom.appLE_map, Scheme.Hom.appLE_map, Scheme.Hom.map_appLE]\n\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.fromSpec_top","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\ninst‚úù : AlgebraicGeometry.IsAffine X\n‚ä¢ Eq ‚ãØ.fromSpec X.isoSpec.inv","decl":"lemma fromSpec_top [IsAffine X] : (isAffineOpen_top X).fromSpec = X.isoSpec.inv := by\n  rw [fromSpec, isoSpec_inv, Category.assoc, ‚Üê @Scheme.isoSpec_inv_naturality,\n    ‚Üê Spec.map_comp_assoc, Scheme.Opens.Œπ_appTop, ‚Üê X.presheaf.map_comp, ‚Üê op_comp,\n    eqToHom_comp_homOfLE, ‚Üê eqToHom_eq_homOfLE rfl, eqToHom_refl, op_id, X.presheaf.map_id,\n    Spec.map_id, Category.id_comp]\n\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.fromSpec_app_of_le","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\nV : X.Opens\nh : LE.le U V\n‚ä¢ Eq (AlgebraicGeometry.Scheme.Hom.app hU.fromSpec V) (CategoryTheory.CategoryStruct.comp (X.presheaf.map (CategoryTheory.homOfLE h).op) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.ŒìSpecIso (X.presheaf.obj { unop := U })).inv ((AlgebraicGeometry.Spec (X.presheaf.obj { unop := U })).presheaf.map (CategoryTheory.homOfLE ‚ãØ).op)))","decl":"lemma fromSpec_app_of_le (V : X.Opens) (h : U ‚â§ V) :\n    hU.fromSpec.app V = X.presheaf.map (homOfLE h).op ‚â´\n      (Scheme.ŒìSpecIso Œì(X, U)).inv ‚â´ (Spec _).presheaf.map (homOfLE le_top).op := by\n  have : U.Œπ ‚Åª¬π·µÅ V = ‚ä§ := eq_top_iff.mpr fun x _ ‚Ü¶ h x.2\n  rw [IsAffineOpen.fromSpec, Scheme.comp_app, Scheme.Opens.Œπ_app, Scheme.app_eq _ this,\n    ‚Üê Scheme.Hom.appTop, IsAffineOpen.isoSpec_inv_appTop]\n  simp only [Scheme.Opens.toScheme_presheaf_map, Scheme.Opens.topIso_hom,\n    Category.assoc, ‚Üê X.presheaf.map_comp_assoc]\n  rfl\n\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.isCompact","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\n‚ä¢ IsCompact ‚ÜëU","decl":"include hU in\nprotected theorem isCompact :\n    IsCompact (U : Set X) := by\n  convert @IsCompact.image _ _ _ _ Set.univ hU.fromSpec.base PrimeSpectrum.compactSpace.1\n    (by fun_prop)\n  convert hU.range_fromSpec.symm\n  exact Set.image_univ\n\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.image_of_isOpenImmersion","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\nf : Quiver.Hom X Y\nH : AlgebraicGeometry.IsOpenImmersion f\n‚ä¢ AlgebraicGeometry.IsAffineOpen ((AlgebraicGeometry.Scheme.Hom.opensFunctor f).obj U)","decl":"include hU in\ntheorem image_of_isOpenImmersion (f : X ‚ü∂ Y) [H : IsOpenImmersion f] :\n    IsAffineOpen (f ''·µÅ U) := by\n  have : IsAffine _ := hU\n  convert isAffineOpen_opensRange (U.Œπ ‚â´ f)\n  ext1\n  exact Set.image_eq_range _ _\n\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.preimage_of_isIso","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\nU : Y.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.IsIso f\n‚ä¢ AlgebraicGeometry.IsAffineOpen ((TopologicalSpace.Opens.map f.base).obj U)","decl":"theorem preimage_of_isIso {U : Y.Opens} (hU : IsAffineOpen U) (f : X ‚ü∂ Y) [IsIso f] :\n    IsAffineOpen (f ‚Åª¬π·µÅ U) :=\n  haveI : IsAffine _ := hU\n  isAffine_of_isIso (f ‚à£_ U)\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.isAffineOpen_iff_of_isOpenImmersion","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.Hom Y\nH : AlgebraicGeometry.IsOpenImmersion f\nU : X.Opens\n‚ä¢ Iff (AlgebraicGeometry.IsAffineOpen (f.opensFunctor.obj U)) (AlgebraicGeometry.IsAffineOpen U)","decl":"theorem _root_.AlgebraicGeometry.Scheme.Hom.isAffineOpen_iff_of_isOpenImmersion\n    (f : AlgebraicGeometry.Scheme.Hom X Y) [H : IsOpenImmersion f] {U : X.Opens} :\n    IsAffineOpen (f ''·µÅ U) ‚Üî IsAffineOpen U := by\n  refine ‚ü®fun hU => @isAffine_of_isIso _ _\n    (IsOpenImmersion.isoOfRangeEq (X.ofRestrict U.isOpenEmbedding ‚â´ f) (Y.ofRestrict _) ?_).hom\n      ?_ hU, fun hU => hU.image_of_isOpenImmersion f‚ü©\n  ¬∑ rw [Scheme.comp_base, coe_comp, Set.range_comp]\n    dsimp [Opens.coe_inclusion', Scheme.restrict]\n    erw [Subtype.range_coe, Subtype.range_coe] -- now `erw` after https://github.com/leanprover-community/mathlib4/pull/13170\n    rfl\n  ¬∑ infer_instance\n\n"}
{"name":"AlgebraicGeometry.IsOpenImmersion.affineOpensEquiv_symm_apply_coe","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nH : AlgebraicGeometry.IsOpenImmersion f\nU : Subtype fun U => LE.le (‚ÜëU) (AlgebraicGeometry.Scheme.Hom.opensRange f)\n‚ä¢ Eq (‚Üë((AlgebraicGeometry.IsOpenImmersion.affineOpensEquiv f).symm U)) ((TopologicalSpace.Opens.map f.base).obj ‚Üë‚ÜëU)","decl":"/-- The affine open sets of an open subscheme corresponds to\nthe affine open sets containing in the image. -/\n@[simps]\ndef _root_.AlgebraicGeometry.IsOpenImmersion.affineOpensEquiv (f : X ‚ü∂ Y) [H : IsOpenImmersion f] :\n    X.affineOpens ‚âÉ { U : Y.affineOpens // U ‚â§ f.opensRange } where\n  toFun U := ‚ü®‚ü®f ''·µÅ U, U.2.image_of_isOpenImmersion f‚ü©, Set.image_subset_range _ _‚ü©\n  invFun U := ‚ü®f ‚Åª¬π·µÅ U, f.isAffineOpen_iff_of_isOpenImmersion.mp (by\n    rw [show f ''·µÅ f ‚Åª¬π·µÅ U = U from Opens.ext (Set.image_preimage_eq_of_subset U.2)]; exact U.1.2)‚ü©\n  left_inv _ := Subtype.ext (Opens.ext (Set.preimage_image_eq _ H.base_open.injective))\n  right_inv U := Subtype.ext (Subtype.ext (Opens.ext (Set.image_preimage_eq_of_subset U.2)))\n\n"}
{"name":"AlgebraicGeometry.IsOpenImmersion.affineOpensEquiv_apply_coe_coe","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nH : AlgebraicGeometry.IsOpenImmersion f\nU : ‚ÜëX.affineOpens\n‚ä¢ Eq (‚Üë‚Üë((AlgebraicGeometry.IsOpenImmersion.affineOpensEquiv f) U)) ((AlgebraicGeometry.Scheme.Hom.opensFunctor f).obj ‚ÜëU)","decl":"/-- The affine open sets of an open subscheme corresponds to\nthe affine open sets containing in the image. -/\n@[simps]\ndef _root_.AlgebraicGeometry.IsOpenImmersion.affineOpensEquiv (f : X ‚ü∂ Y) [H : IsOpenImmersion f] :\n    X.affineOpens ‚âÉ { U : Y.affineOpens // U ‚â§ f.opensRange } where\n  toFun U := ‚ü®‚ü®f ''·µÅ U, U.2.image_of_isOpenImmersion f‚ü©, Set.image_subset_range _ _‚ü©\n  invFun U := ‚ü®f ‚Åª¬π·µÅ U, f.isAffineOpen_iff_of_isOpenImmersion.mp (by\n    rw [show f ''·µÅ f ‚Åª¬π·µÅ U = U from Opens.ext (Set.image_preimage_eq_of_subset U.2)]; exact U.1.2)‚ü©\n  left_inv _ := Subtype.ext (Opens.ext (Set.preimage_image_eq _ H.base_open.injective))\n  right_inv U := Subtype.ext (Subtype.ext (Opens.ext (Set.image_preimage_eq_of_subset U.2)))\n\n"}
{"name":"AlgebraicGeometry.affineOpensRestrict_apply_coe_coe","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\na‚úù : ‚Üë(‚ÜëU).affineOpens\n‚ä¢ Eq (‚Üë‚Üë((AlgebraicGeometry.affineOpensRestrict U) a‚úù)) ((AlgebraicGeometry.Scheme.Hom.opensFunctor U.Œπ).obj ‚Üëa‚úù)","decl":"/-- The affine open sets of an open subscheme\ncorresponds to the affine open sets containing in the subset. -/\n@[simps! apply_coe_coe]\ndef _root_.AlgebraicGeometry.affineOpensRestrict {X : Scheme.{u}} (U : X.Opens) :\n    U.toScheme.affineOpens ‚âÉ { V : X.affineOpens // V ‚â§ U } :=\n  (IsOpenImmersion.affineOpensEquiv U.Œπ).trans (Equiv.subtypeEquivProp (by simp))\n\n"}
{"name":"AlgebraicGeometry.affineOpensRestrict_symm_apply_coe","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nV : Subtype fun V => LE.le (‚ÜëV) U\n‚ä¢ Eq (‚Üë((AlgebraicGeometry.affineOpensRestrict U).symm V)) ((TopologicalSpace.Opens.map U.Œπ.base).obj ‚Üë‚ÜëV)","decl":"@[simp]\nlemma _root_.AlgebraicGeometry.affineOpensRestrict_symm_apply_coe\n    {X : Scheme.{u}} (U : X.Opens) (V) :\n    ((affineOpensRestrict U).symm V).1 = U.Œπ ‚Åª¬π·µÅ V := rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.compactSpace_of_isAffine","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\ninst‚úù : AlgebraicGeometry.IsAffine X\n‚ä¢ CompactSpace ‚Üë‚ÜëX.toPresheafedSpace","decl":"instance (priority := 100) _root_.AlgebraicGeometry.Scheme.compactSpace_of_isAffine\n    (X : Scheme) [IsAffine X] :\n    CompactSpace X :=\n  ‚ü®(isAffineOpen_top X).isCompact‚ü©\n\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.fromSpec_preimage_self","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\n‚ä¢ Eq ((TopologicalSpace.Opens.map hU.fromSpec.base).obj U) Top.top","decl":"@[simp]\ntheorem fromSpec_preimage_self :\n    hU.fromSpec ‚Åª¬π·µÅ U = ‚ä§ := by\n  ext1\n  rw [Opens.map_coe, Opens.coe_top, ‚Üê hU.range_fromSpec, ‚Üê Set.image_univ]\n  exact Set.preimage_image_eq _ PresheafedSpace.IsOpenImmersion.base_open.injective\n\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.ŒìSpecIso_hom_fromSpec_app","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.ŒìSpecIso (X.presheaf.obj { unop := U })).hom (AlgebraicGeometry.Scheme.Hom.app hU.fromSpec U)) ((AlgebraicGeometry.Spec (X.presheaf.obj { unop := U })).presheaf.map (CategoryTheory.eqToHom ‚ãØ).op)","decl":"theorem ŒìSpecIso_hom_fromSpec_app :\n    (Scheme.ŒìSpecIso Œì(X, U)).hom ‚â´ hU.fromSpec.app U =\n      (Spec Œì(X, U)).presheaf.map (eqToHom hU.fromSpec_preimage_self).op := by\n  simp only [fromSpec, Scheme.comp_coeBase, Opens.map_comp_obj, Scheme.comp_app,\n    Scheme.Opens.Œπ_app_self, eqToHom_op, Scheme.app_eq _ U.Œπ_preimage_self,\n    Scheme.Opens.toScheme_presheaf_map, eqToHom_unop, eqToHom_map U.Œπ.opensFunctor, Opens.map_top,\n    isoSpec_inv_appTop, Scheme.Opens.topIso_hom, Category.assoc, ‚Üê Functor.map_comp_assoc,\n    eqToHom_trans, eqToHom_refl, X.presheaf.map_id, Category.id_comp, Iso.hom_inv_id_assoc]\n\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.fromSpec_app_self","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\n‚ä¢ Eq (AlgebraicGeometry.Scheme.Hom.app hU.fromSpec U) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.ŒìSpecIso (X.presheaf.obj { unop := U })).inv ((AlgebraicGeometry.Spec (X.presheaf.obj { unop := U })).presheaf.map (CategoryTheory.eqToHom ‚ãØ).op))","decl":"@[elementwise]\ntheorem fromSpec_app_self :\n    hU.fromSpec.app U = (Scheme.ŒìSpecIso Œì(X, U)).inv ‚â´\n      (Spec Œì(X, U)).presheaf.map (eqToHom hU.fromSpec_preimage_self).op := by\n  rw [‚Üê hU.ŒìSpecIso_hom_fromSpec_app, Iso.inv_hom_id_assoc]\n\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.fromSpec_app_self_apply","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\nx : CategoryTheory.ToType (X.presheaf.obj { unop := U })\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.Scheme.Hom.app hU.fromSpec U)) x) ((CategoryTheory.ConcreteCategory.hom ((AlgebraicGeometry.Spec (X.presheaf.obj { unop := U })).presheaf.map (CategoryTheory.eqToHom ‚ãØ))) ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.Scheme.ŒìSpecIso (X.presheaf.obj { unop := U })).inv) x))","decl":"@[elementwise]\ntheorem fromSpec_app_self :\n    hU.fromSpec.app U = (Scheme.ŒìSpecIso Œì(X, U)).inv ‚â´\n      (Spec Œì(X, U)).presheaf.map (eqToHom hU.fromSpec_preimage_self).op := by\n  rw [‚Üê hU.ŒìSpecIso_hom_fromSpec_app, Iso.inv_hom_id_assoc]\n\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.fromSpec_preimage_basicOpen'","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\nf : ‚Üë(X.presheaf.obj { unop := U })\n‚ä¢ Eq ((TopologicalSpace.Opens.map hU.fromSpec.base).obj (X.basicOpen f)) ((AlgebraicGeometry.Spec (X.presheaf.obj { unop := U })).basicOpen ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.Scheme.ŒìSpecIso (X.presheaf.obj { unop := U })).inv) f))","decl":"theorem fromSpec_preimage_basicOpen' :\n    hU.fromSpec ‚Åª¬π·µÅ X.basicOpen f = (Spec Œì(X, U)).basicOpen ((Scheme.ŒìSpecIso Œì(X, U)).inv f) := by\n  rw [Scheme.preimage_basicOpen, hU.fromSpec_app_self]\n  exact Scheme.basicOpen_res_eq _ _ (eqToHom hU.fromSpec_preimage_self).op\n\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.fromSpec_preimage_basicOpen","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\nf : ‚Üë(X.presheaf.obj { unop := U })\n‚ä¢ Eq ((TopologicalSpace.Opens.map hU.fromSpec.base).obj (X.basicOpen f)) (PrimeSpectrum.basicOpen f)","decl":"theorem fromSpec_preimage_basicOpen :\n    hU.fromSpec ‚Åª¬π·µÅ X.basicOpen f = PrimeSpectrum.basicOpen f := by\n  rw [fromSpec_preimage_basicOpen', ‚Üê basicOpen_eq_of_affine]\n\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.fromSpec_image_basicOpen","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\nf : ‚Üë(X.presheaf.obj { unop := U })\n‚ä¢ Eq ((AlgebraicGeometry.Scheme.Hom.opensFunctor hU.fromSpec).obj (PrimeSpectrum.basicOpen f)) (X.basicOpen f)","decl":"theorem fromSpec_image_basicOpen :\n    hU.fromSpec ''·µÅ (PrimeSpectrum.basicOpen f) = X.basicOpen f := by\n  rw [‚Üê hU.fromSpec_preimage_basicOpen]\n  ext1\n  change hU.fromSpec.base '' (hU.fromSpec.base ‚Åª¬π' (X.basicOpen f : Set X)) = _\n  rw [Set.image_preimage_eq_inter_range, Set.inter_eq_left, hU.range_fromSpec]\n  exact Scheme.basicOpen_le _ _\n\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.basicOpen_fromSpec_app","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\nf : ‚Üë(X.presheaf.obj { unop := U })\n‚ä¢ Eq ((AlgebraicGeometry.Spec (X.presheaf.obj { unop := U })).basicOpen ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.Scheme.Hom.app hU.fromSpec U)) f)) (PrimeSpectrum.basicOpen f)","decl":"@[simp]\ntheorem basicOpen_fromSpec_app :\n    (Spec Œì(X, U)).basicOpen (hU.fromSpec.app U f) = PrimeSpectrum.basicOpen f := by\n  rw [‚Üê hU.fromSpec_preimage_basicOpen, Scheme.preimage_basicOpen]\n\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.basicOpen","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\nf : ‚Üë(X.presheaf.obj { unop := U })\n‚ä¢ AlgebraicGeometry.IsAffineOpen (X.basicOpen f)","decl":"include hU in\ntheorem basicOpen :\n    IsAffineOpen (X.basicOpen f) := by\n  rw [‚Üê hU.fromSpec_image_basicOpen, Scheme.Hom.isAffineOpen_iff_of_isOpenImmersion]\n  convert isAffineOpen_opensRange\n    (Spec.map (CommRingCat.ofHom <| algebraMap Œì(X, U) (Localization.Away f)))\n  exact Opens.ext (PrimeSpectrum.localization_away_comap_range (Localization.Away f) f).symm\n\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.Spec_basicOpen","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"R : CommRingCat\nf : ‚ÜëR\n‚ä¢ AlgebraicGeometry.IsAffineOpen (PrimeSpectrum.basicOpen f)","decl":"lemma Spec_basicOpen {R : CommRingCat} (f : R) :\n    IsAffineOpen (X := Spec R) (PrimeSpectrum.basicOpen f) :=\n  basicOpen_eq_of_affine f ‚ñ∏ (isAffineOpen_top (Spec (.of R))).basicOpen _\n\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.instIsAffineToSchemeBasicOpen","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\ninst‚úù : AlgebraicGeometry.IsAffine X\nr : ‚Üë(X.presheaf.obj { unop := Top.top })\n‚ä¢ AlgebraicGeometry.IsAffine ‚Üë(X.basicOpen r)","decl":"instance [IsAffine X] (r : Œì(X, ‚ä§)) : IsAffine (X.basicOpen r) :=\n  (isAffineOpen_top X).basicOpen _\n\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.Œπ_basicOpen_preimage","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\nr : ‚Üë(X.presheaf.obj { unop := Top.top })\n‚ä¢ AlgebraicGeometry.IsAffineOpen ((TopologicalSpace.Opens.map (X.basicOpen r).Œπ.base).obj U)","decl":"include hU in\ntheorem Œπ_basicOpen_preimage (r : Œì(X, ‚ä§)) :\n    IsAffineOpen ((X.basicOpen r).Œπ ‚Åª¬π·µÅ U) := by\n  apply (X.basicOpen r).Œπ.isAffineOpen_iff_of_isOpenImmersion.mp\n  dsimp [Scheme.Hom.opensFunctor, LocallyRingedSpace.IsOpenImmersion.opensFunctor]\n  rw [Opens.functor_obj_map_obj, Opens.isOpenEmbedding_obj_top, inf_comm,\n    ‚Üê Scheme.basicOpen_res _ _ (homOfLE le_top).op]\n  exact hU.basicOpen _\n\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.exists_basicOpen_le","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\nV : X.Opens\nx : Subtype fun x => Membership.mem V x\nh : Membership.mem U ‚Üëx\n‚ä¢ Exists fun f => And (LE.le (X.basicOpen f) V) (Membership.mem (X.basicOpen f) ‚Üëx)","decl":"include hU in\ntheorem exists_basicOpen_le {V : X.Opens} (x : V) (h : ‚Üëx ‚àà U) :\n    ‚àÉ f : Œì(X, U), X.basicOpen f ‚â§ V ‚àß ‚Üëx ‚àà X.basicOpen f := by\n  have : IsAffine _ := hU\n  obtain ‚ü®_, ‚ü®_, ‚ü®r, rfl‚ü©, rfl‚ü©, h‚ÇÅ, h‚ÇÇ‚ü© :=\n    (isBasis_basicOpen U).exists_subset_of_mem_open (x.2 : (‚ü®x, h‚ü© : U) ‚àà _)\n      ((Opens.map U.inclusion').obj V).isOpen\n  have :\n    U.Œπ ''·µÅ (U.toScheme.basicOpen r) =\n      X.basicOpen (X.presheaf.map (eqToHom U.isOpenEmbedding_obj_top.symm).op r) := by\n    refine (Scheme.image_basicOpen U.Œπ r).trans ?_\n    rw [Scheme.basicOpen_res_eq]\n    simp only [Scheme.Opens.toScheme_presheaf_obj, Scheme.Opens.Œπ_appIso, Iso.refl_inv,\n      CommRingCat.id_apply]\n  use X.presheaf.map (eqToHom U.isOpenEmbedding_obj_top.symm).op r\n  rw [‚Üê this]\n  exact ‚ü®Set.image_subset_iff.mpr h‚ÇÇ, ‚ü®_, h‚ü©, h‚ÇÅ, rfl‚ü©\n\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.algebraMap_Spec_obj","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"R : CommRingCat\nU : (AlgebraicGeometry.Spec R).Opens\n‚ä¢ Eq (algebraMap ‚ÜëR ‚Üë((AlgebraicGeometry.Spec R).presheaf.obj { unop := U })) (CommRingCat.Hom.hom (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.ŒìSpecIso R).inv ((AlgebraicGeometry.Spec R).presheaf.map (CategoryTheory.homOfLE ‚ãØ).op)))","decl":"@[simp]\nlemma algebraMap_Spec_obj {R : CommRingCat} {U} : algebraMap R Œì(Spec R, U) =\n    ((Scheme.ŒìSpecIso R).inv ‚â´ (Spec R).presheaf.map (homOfLE le_top).op).hom := rfl\n\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.instAwayCarrierObjOppositeOpensŒ±TopologicalSpaceCarrierCommRingCatSpecPresheafOpOpensBasicOpen","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"R : CommRingCat\nf : ‚ÜëR\n‚ä¢ IsLocalization.Away f ‚Üë((AlgebraicGeometry.Spec R).presheaf.obj { unop := PrimeSpectrum.basicOpen f })","decl":"instance {R : CommRingCat} {f : R} :\n    IsLocalization.Away f Œì(Spec R, PrimeSpectrum.basicOpen f) :=\n  inferInstanceAs (IsLocalization.Away f\n    ((Spec.structureSheaf R).val.obj (op <| PrimeSpectrum.basicOpen f)))\n\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.basicOpenSectionsToAffine_isIso","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\nf : ‚Üë(X.presheaf.obj { unop := U })\n‚ä¢ CategoryTheory.IsIso (hU.basicOpenSectionsToAffine f)","decl":"instance basicOpenSectionsToAffine_isIso :\n    IsIso (basicOpenSectionsToAffine hU f) := by\n  delta basicOpenSectionsToAffine\n  refine IsIso.comp_isIso' ?_ inferInstance\n  apply PresheafedSpace.IsOpenImmersion.isIso_of_subset\n  rw [hU.range_fromSpec]\n  exact RingedSpace.basicOpen_le _ _\n\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.isLocalization_basicOpen","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\nf : ‚Üë(X.presheaf.obj { unop := U })\n‚ä¢ IsLocalization.Away f ‚Üë(X.presheaf.obj { unop := X.basicOpen f })","decl":"include hU in\ntheorem isLocalization_basicOpen :\n    IsLocalization.Away f Œì(X, X.basicOpen f) := by\n  apply\n    (IsLocalization.isLocalization_iff_of_ringEquiv (Submonoid.powers f)\n      (asIso <| basicOpenSectionsToAffine hU f).commRingCatIsoToRingEquiv).mpr\n  convert StructureSheaf.IsLocalization.to_basicOpen _ f using 1\n  -- Porting note: more hand holding is required here, the next 4 lines were not necessary\n  delta StructureSheaf.openAlgebra\n  congr 1\n  rw [RingEquiv.toRingHom_eq_coe, CategoryTheory.Iso.commRingCatIsoToRingEquiv_toRingHom, asIso_hom]\n  dsimp [CommRingCat.ofHom, RingHom.algebraMap_toAlgebra]\n  change (X.presheaf.map _ ‚â´ basicOpenSectionsToAffine hU f).hom = _\n  delta basicOpenSectionsToAffine\n  rw [hU.fromSpec.naturality_assoc, hU.fromSpec_app_self]\n  simp only [Category.assoc, ‚Üê Functor.map_comp, ‚Üê op_comp]\n  exact CommRingCat.hom_ext_iff.mp (StructureSheaf.toOpen_res _ _ _ _)\n\n"}
{"name":"AlgebraicGeometry.isLocalization_away_of_isAffine","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\ninst‚úù : AlgebraicGeometry.IsAffine X\nr : ‚Üë(X.presheaf.obj { unop := Top.top })\n‚ä¢ IsLocalization.Away r ‚Üë(X.presheaf.obj { unop := X.basicOpen r })","decl":"instance _root_.AlgebraicGeometry.isLocalization_away_of_isAffine\n    [IsAffine X] (r : Œì(X, ‚ä§)) :\n    IsLocalization.Away r Œì(X, X.basicOpen r) :=\n  isLocalization_basicOpen (isAffineOpen_top X) r\n\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.appLE_eq_away_map","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nU : Y.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\nV : X.Opens\nhV : AlgebraicGeometry.IsAffineOpen V\ne : LE.le V ((TopologicalSpace.Opens.map f.base).obj U)\nr : ‚Üë(Y.presheaf.obj { unop := U })\n‚ä¢ Eq (AlgebraicGeometry.Scheme.Hom.appLE f (Y.basicOpen r) (X.basicOpen ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.Scheme.Hom.appLE f U V e)) r)) ‚ãØ) (CommRingCat.ofHom (IsLocalization.Away.map (‚Üë(Y.presheaf.toPrefunctor.1 { unop := Y.basicOpen r })) (‚Üë(X.presheaf.toPrefunctor.1 { unop := X.basicOpen ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.Scheme.Hom.appLE f U V e)) r) })) (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.Hom.appLE f U V e)) r))","decl":"lemma appLE_eq_away_map {X Y : Scheme.{u}} (f : X ‚ü∂ Y) {U : Y.Opens} (hU : IsAffineOpen U)\n    {V : X.Opens} (hV : IsAffineOpen V) (e) (r : Œì(Y, U)) :\n    letI := hU.isLocalization_basicOpen r\n    letI := hV.isLocalization_basicOpen (f.appLE U V e r)\n    f.appLE (Y.basicOpen r) (X.basicOpen (f.appLE U V e r)) (by simp [Scheme.Hom.appLE]) =\n        CommRingCat.ofHom (IsLocalization.Away.map _ _ (f.appLE U V e).hom r) := by\n  letI := hU.isLocalization_basicOpen r\n  letI := hV.isLocalization_basicOpen (f.appLE U V e r)\n  ext : 1\n  apply IsLocalization.ringHom_ext (.powers r)\n  rw [IsLocalization.Away.map, CommRingCat.hom_ofHom, IsLocalization.map_comp,\n    RingHom.algebraMap_toAlgebra, RingHom.algebraMap_toAlgebra, ‚Üê CommRingCat.hom_comp,\n    ‚Üê CommRingCat.hom_comp, Scheme.Hom.appLE_map, Scheme.Hom.map_appLE]\n\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.app_basicOpen_eq_away_map","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nU : Y.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\nh : AlgebraicGeometry.IsAffineOpen ((TopologicalSpace.Opens.map f.base).obj U)\nr : ‚Üë(Y.presheaf.obj { unop := U })\n‚ä¢ Eq (AlgebraicGeometry.Scheme.Hom.app f (Y.basicOpen r)) (CategoryTheory.CategoryStruct.comp (CommRingCat.ofHom (IsLocalization.Away.map (‚Üë(Y.presheaf.obj { unop := Y.basicOpen r })) (‚Üë(X.presheaf.obj { unop := X.basicOpen ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.Scheme.Hom.app f U)) r) })) (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.Hom.app f U)) r)) (X.presheaf.map (CategoryTheory.eqToHom ‚ãØ).op))","decl":"lemma app_basicOpen_eq_away_map {X Y : Scheme.{u}} (f : X ‚ü∂ Y) {U : Y.Opens}\n    (hU : IsAffineOpen U) (h : IsAffineOpen (f ‚Åª¬π·µÅ U)) (r : Œì(Y, U)) :\n    haveI := hU.isLocalization_basicOpen r\n    haveI := h.isLocalization_basicOpen (f.app U r)\n    f.app (Y.basicOpen r) =\n      (CommRingCat.ofHom\n        (IsLocalization.Away.map Œì(Y, Y.basicOpen r) Œì(X, X.basicOpen (f.app U r)) (f.app U).hom r)\n        ‚â´ X.presheaf.map (eqToHom (by simp)).op) := by\n  haveI := hU.isLocalization_basicOpen r\n  haveI := h.isLocalization_basicOpen (f.app U r)\n  ext : 1\n  apply IsLocalization.ringHom_ext (.powers r)\n  rw [IsLocalization.Away.map, CommRingCat.hom_comp, RingHom.comp_assoc, CommRingCat.hom_ofHom,\n    IsLocalization.map_comp, RingHom.algebraMap_toAlgebra,\n    RingHom.algebraMap_toAlgebra, ‚Üê RingHom.comp_assoc, ‚Üê CommRingCat.hom_comp,\n    ‚Üê CommRingCat.hom_comp, ‚Üê X.presheaf.map_comp]\n  simp\n\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.isLocalization_of_eq_basicOpen","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\nf : ‚Üë(X.presheaf.obj { unop := U })\nV : X.Opens\ni : Quiver.Hom V U\ne : Eq V (X.basicOpen f)\n‚ä¢ IsLocalization.Away f ‚Üë(X.presheaf.obj { unop := V })","decl":"include hU in\ntheorem isLocalization_of_eq_basicOpen {V : X.Opens} (i : V ‚ü∂ U) (e : V = X.basicOpen f) :\n    @IsLocalization.Away _ _ f Œì(X, V) _ (X.presheaf.map i.op).hom.toAlgebra := by\n  subst e; convert isLocalization_basicOpen hU f using 3\n\n"}
{"name":"AlgebraicGeometry.Œì_restrict_isLocalization","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\ninst‚úù : AlgebraicGeometry.IsAffine X\nr : ‚Üë(X.presheaf.obj { unop := Top.top })\n‚ä¢ IsLocalization.Away r ‚Üë((‚Üë(X.basicOpen r)).presheaf.obj { unop := Top.top })","decl":"instance _root_.AlgebraicGeometry.Œì_restrict_isLocalization\n    (X : Scheme.{u}) [IsAffine X] (r : Œì(X, ‚ä§)) :\n    IsLocalization.Away r Œì(X.basicOpen r, ‚ä§) :=\n  (isAffineOpen_top X).isLocalization_of_eq_basicOpen r _ (Opens.isOpenEmbedding_obj_top _)\n\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.basicOpen_basicOpen_is_basicOpen","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\nf : ‚Üë(X.presheaf.obj { unop := U })\ng : ‚Üë(X.presheaf.obj { unop := X.basicOpen f })\n‚ä¢ Exists fun f' => Eq (X.basicOpen f') (X.basicOpen g)","decl":"include hU in\ntheorem basicOpen_basicOpen_is_basicOpen (g : Œì(X, X.basicOpen f)) :\n    ‚àÉ f' : Œì(X, U), X.basicOpen f' = X.basicOpen g := by\n  have := isLocalization_basicOpen hU f\n  obtain ‚ü®x, ‚ü®_, n, rfl‚ü©, rfl‚ü© := IsLocalization.surj'' (Submonoid.powers f) g\n  use f * x\n  rw [Algebra.smul_def, Scheme.basicOpen_mul, Scheme.basicOpen_mul, RingHom.algebraMap_toAlgebra]\n  rw [Scheme.basicOpen_res]\n  refine (inf_eq_left.mpr ?_).symm\n  -- Porting note: a little help is needed here\n  convert inf_le_left (Œ± := X.Opens) using 1\n  apply Scheme.basicOpen_of_isUnit\n  apply\n    Submonoid.leftInv_le_isUnit _\n      (IsLocalization.toInvSubmonoid (Submonoid.powers f) (Œì(X, X.basicOpen f))\n        _).prop\n\n"}
{"name":"AlgebraicGeometry.exists_basicOpen_le_affine_inter","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\nV : X.Opens\nhV : AlgebraicGeometry.IsAffineOpen V\nx : ‚Üë‚ÜëX.toPresheafedSpace\nhx : Membership.mem (Min.min U V) x\n‚ä¢ Exists fun f => Exists fun g => And (Eq (X.basicOpen f) (X.basicOpen g)) (Membership.mem (X.basicOpen f) x)","decl":"include hU in\ntheorem _root_.AlgebraicGeometry.exists_basicOpen_le_affine_inter\n    {V : X.Opens} (hV : IsAffineOpen V) (x : X) (hx : x ‚àà U ‚äì V) :\n    ‚àÉ (f : Œì(X, U)) (g : Œì(X, V)), X.basicOpen f = X.basicOpen g ‚àß x ‚àà X.basicOpen f := by\n  obtain ‚ü®f, hf‚ÇÅ, hf‚ÇÇ‚ü© := hU.exists_basicOpen_le ‚ü®x, hx.2‚ü© hx.1\n  obtain ‚ü®g, hg‚ÇÅ, hg‚ÇÇ‚ü© := hV.exists_basicOpen_le ‚ü®x, hf‚ÇÇ‚ü© hx.2\n  obtain ‚ü®f', hf'‚ü© :=\n    basicOpen_basicOpen_is_basicOpen hU f (X.presheaf.map (homOfLE hf‚ÇÅ : _ ‚ü∂ V).op g)\n  replace hf' := (hf'.trans (RingedSpace.basicOpen_res _ _ _)).trans (inf_eq_right.mpr hg‚ÇÅ)\n  exact ‚ü®f', g, hf', hf'.symm ‚ñ∏ hg‚ÇÇ‚ü©\n\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.fromSpec_primeIdealOf","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\nx : Subtype fun x => Membership.mem U x\n‚ä¢ Eq (hU.fromSpec.base (hU.primeIdealOf x)) ‚Üëx","decl":"theorem fromSpec_primeIdealOf (x : U) :\n    hU.fromSpec.base (hU.primeIdealOf x) = x.1 := by\n  dsimp only [IsAffineOpen.fromSpec, Subtype.coe_mk, IsAffineOpen.primeIdealOf]\n  rw [‚Üê Scheme.comp_base_apply, Iso.hom_inv_id_assoc]\n  rfl\n\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.primeIdealOf_eq_map_closedPoint","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\nx : Subtype fun x => Membership.mem U x\n‚ä¢ Eq (hU.primeIdealOf x) ((AlgebraicGeometry.Spec.map (X.presheaf.germ U ‚Üëx ‚ãØ)).base (IsLocalRing.closedPoint ‚Üë(X.presheaf.stalk ‚Üëx)))","decl":"open IsLocalRing in\ntheorem primeIdealOf_eq_map_closedPoint (x : U) :\n    hU.primeIdealOf x = (Spec.map (X.presheaf.germ _ x x.2)).base (closedPoint _) :=\n  hU.isoSpec_hom_base_apply _\n\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.isLocalization_stalk'","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\ny : PrimeSpectrum ‚Üë(X.presheaf.obj { unop := U })\nhy : Membership.mem U (hU.fromSpec.base y)\n‚ä¢ IsLocalization.AtPrime (‚Üë(X.presheaf.stalk (hU.fromSpec.base y))) y.asIdeal","decl":"theorem isLocalization_stalk' (y : PrimeSpectrum Œì(X, U)) (hy : hU.fromSpec.base y ‚àà U) :\n    @IsLocalization.AtPrime\n      (R := Œì(X, U))\n      (S := X.presheaf.stalk <| hU.fromSpec.base y) _ _\n      ((TopCat.Presheaf.algebra_section_stalk X.presheaf _)) y.asIdeal _ := by\n  apply\n    (@IsLocalization.isLocalization_iff_of_ringEquiv (R := Œì(X, U))\n      (S := X.presheaf.stalk (hU.fromSpec.base y)) _ y.asIdeal.primeCompl _\n      (TopCat.Presheaf.algebra_section_stalk X.presheaf ‚ü®hU.fromSpec.base y, hy‚ü©) _ _\n      (asIso <| hU.fromSpec.stalkMap y).commRingCatIsoToRingEquiv).mpr\n  -- Porting note: need to know what the ring is and after convert, instead of equality\n  -- we get an `iff`.\n  convert StructureSheaf.IsLocalization.to_stalk Œì(X, U) y using 1\n  delta IsLocalization.AtPrime StructureSheaf.stalkAlgebra\n  rw [iff_iff_eq]\n  congr 2\n  rw [RingHom.algebraMap_toAlgebra, RingEquiv.toRingHom_eq_coe,\n    CategoryTheory.Iso.commRingCatIsoToRingEquiv_toRingHom, asIso_hom, ‚Üê CommRingCat.hom_comp,\n    Scheme.stalkMap_germ, IsAffineOpen.fromSpec_app_self, Category.assoc, TopCat.Presheaf.germ_res]\n  rfl\n\n-- Porting note: I have split this into two lemmas\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.isLocalization_stalk","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\nx : Subtype fun x => Membership.mem U x\n‚ä¢ IsLocalization.AtPrime (‚Üë(X.presheaf.stalk ‚Üëx)) (hU.primeIdealOf x).asIdeal","decl":"theorem isLocalization_stalk (x : U) :\n    IsLocalization.AtPrime (X.presheaf.stalk x) (hU.primeIdealOf x).asIdeal := by\n  rcases x with ‚ü®x, hx‚ü©\n  set y := hU.primeIdealOf ‚ü®x, hx‚ü© with hy\n  have : hU.fromSpec.base y = x := hy ‚ñ∏ hU.fromSpec_primeIdealOf ‚ü®x, hx‚ü©\n  clear_value y\n  subst this\n  exact hU.isLocalization_stalk' y hx\n\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.stalkMap_injective","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nU : TopologicalSpace.Opens ‚Üë‚ÜëY.toPresheafedSpace\nhU : AlgebraicGeometry.IsAffineOpen U\nx : ‚Üë‚ÜëX.toPresheafedSpace\nhx : Membership.mem U (f.base x)\nh : ‚àÄ (g : ‚Üë(Y.presheaf.obj { unop := U })), Eq ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.Scheme.Hom.stalkMap f x)) ((CategoryTheory.ConcreteCategory.hom (Y.presheaf.germ U (f.base x) hx)) g)) 0 ‚Üí Eq ((CategoryTheory.ConcreteCategory.hom (Y.presheaf.germ U (f.base x) hx)) g) 0\n‚ä¢ Function.Injective ‚áë(CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.Scheme.Hom.stalkMap f x))","decl":"lemma stalkMap_injective (f : X ‚ü∂ Y) {U : Opens Y} (hU : IsAffineOpen U) (x : X)\n    (hx : f.base x ‚àà U)\n    (h : ‚àÄ g, f.stalkMap x (Y.presheaf.germ U (f.base x) hx g) = 0 ‚Üí\n      Y.presheaf.germ U (f.base x) hx g = 0) :\n    Function.Injective (f.stalkMap x) := by\n  letI := Y.presheaf.algebra_section_stalk ‚ü®f.base x, hx‚ü©\n  apply (hU.isLocalization_stalk ‚ü®f.base x, hx‚ü©).injective_of_map_algebraMap_zero\n  exact h\n\n"}
{"name":"AlgebraicGeometry.Scheme.affineBasicOpen_coe","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : ‚ÜëX.affineOpens\nf : ‚Üë(X.presheaf.obj { unop := ‚ÜëU })\n‚ä¢ Eq (‚Üë(X.affineBasicOpen f)) (X.basicOpen f)","decl":"/-- The basic open set of a section `f` on an affine open as an `X.affineOpens`. -/\n@[simps]\ndef _root_.AlgebraicGeometry.Scheme.affineBasicOpen\n    (X : Scheme) {U : X.affineOpens} (f : Œì(X, U)) : X.affineOpens :=\n  ‚ü®X.basicOpen f, U.prop.basicOpen f‚ü©\n\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.basicOpen_union_eq_self_iff","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\ns : Set ‚Üë(X.presheaf.obj { unop := U })\n‚ä¢ Iff (Eq (iSup fun f => X.basicOpen ‚Üëf) U) (Eq (Ideal.span s) Top.top)","decl":"include hU in\n/--\nIn an affine open set `U`, a family of basic open covers `U` iff the sections span `Œì(X, U)`.\nSee `iSup_basicOpen_of_span_eq_top` for the inverse direction without the affine-ness assumption.\n-/\ntheorem basicOpen_union_eq_self_iff (s : Set Œì(X, U)) :\n    ‚®Ü f : s, X.basicOpen (f : Œì(X, U)) = U ‚Üî Ideal.span s = ‚ä§ := by\n  trans ‚ãÉ i : s, (PrimeSpectrum.basicOpen i.1).1 = Set.univ\n  ¬∑ trans\n      hU.fromSpec.base ‚Åª¬π' (‚®Ü f : s, X.basicOpen (f : Œì(X, U))).1 =\n        hU.fromSpec.base ‚Åª¬π' U.1\n    ¬∑ refine ‚ü®fun h => by rw [h], ?_‚ü©\n      intro h\n      apply_fun Set.image hU.fromSpec.base at h\n      rw [Set.image_preimage_eq_inter_range, Set.image_preimage_eq_inter_range, hU.range_fromSpec]\n        at h\n      simp only [Set.inter_self, Opens.carrier_eq_coe, Set.inter_eq_right] at h\n      ext1\n      refine Set.Subset.antisymm ?_ h\n      simp only [Set.iUnion_subset_iff, SetCoe.forall, Opens.coe_iSup]\n      intro x _\n      exact X.basicOpen_le x\n    ¬∑ simp only [Opens.iSup_def, Subtype.coe_mk, Set.preimage_iUnion]\n      congr! 1\n      ¬∑ refine congr_arg (Set.iUnion ¬∑) ?_\n        ext1 x\n        exact congr_arg Opens.carrier (hU.fromSpec_preimage_basicOpen _)\n      ¬∑ exact congr_arg Opens.carrier hU.fromSpec_preimage_self\n  ¬∑ simp only [Opens.carrier_eq_coe, PrimeSpectrum.basicOpen_eq_zeroLocus_compl]\n    rw [‚Üê Set.compl_iInter, Set.compl_univ_iff, ‚Üê PrimeSpectrum.zeroLocus_iUnion, ‚Üê\n      PrimeSpectrum.zeroLocus_empty_iff_eq_top, PrimeSpectrum.zeroLocus_span]\n    simp only [Set.iUnion_singleton_eq_range, Subtype.range_val_subtype, Set.setOf_mem_eq]\n\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.self_le_basicOpen_union_iff","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\ns : Set ‚Üë(X.presheaf.obj { unop := U })\n‚ä¢ Iff (LE.le U (iSup fun f => X.basicOpen ‚Üëf)) (Eq (Ideal.span s) Top.top)","decl":"include hU in\ntheorem self_le_basicOpen_union_iff (s : Set Œì(X, U)) :\n    (U ‚â§ ‚®Ü f : s, X.basicOpen f.1) ‚Üî Ideal.span s = ‚ä§ := by\n  rw [‚Üê hU.basicOpen_union_eq_self_iff, @comm _ Eq]\n  refine ‚ü®fun h => le_antisymm h ?_, le_of_eq‚ü©\n  simp only [iSup_le_iff, SetCoe.forall]\n  intro x _\n  exact X.basicOpen_le x\n\n"}
{"name":"AlgebraicGeometry.stalkMap_injective_of_isAffine","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst‚úù : AlgebraicGeometry.IsAffine Y\nx : ‚Üë‚ÜëX.toPresheafedSpace\nh : ‚àÄ (g : ‚Üë(Y.presheaf.obj { unop := Top.top })), Eq ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.Scheme.Hom.stalkMap f x)) ((CategoryTheory.ConcreteCategory.hom (Y.presheaf.Œìgerm (f.base x))) g)) 0 ‚Üí Eq ((CategoryTheory.ConcreteCategory.hom (Y.presheaf.Œìgerm (f.base x))) g) 0\n‚ä¢ Function.Injective ‚áë(CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.Scheme.Hom.stalkMap f x))","decl":"lemma stalkMap_injective_of_isAffine {X Y : Scheme} (f : X ‚ü∂ Y) [IsAffine Y] (x : X)\n    (h : ‚àÄ g, f.stalkMap x (Y.presheaf.Œìgerm (f.base x) g) = 0 ‚Üí\n      Y.presheaf.Œìgerm (f.base x) g = 0) :\n    Function.Injective (f.stalkMap x) :=\n  (isAffineOpen_top Y).stalkMap_injective f x trivial h\n\n"}
{"name":"AlgebraicGeometry.iSup_basicOpen_of_span_eq_top","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\ns : Set ‚Üë(X.presheaf.obj { unop := U })\nhs : Eq (Ideal.span s) Top.top\n‚ä¢ Eq (iSup fun i => iSup fun h => X.basicOpen i) U","decl":"/--\nGiven a spanning set of `Œì(X, U)`, the corresponding basic open sets cover `U`.\nSee `IsAffineOpen.basicOpen_union_eq_self_iff` for the inverse direction for affine open sets.\n-/\nlemma iSup_basicOpen_of_span_eq_top {X : Scheme} (U) (s : Set Œì(X, U))\n    (hs : Ideal.span s = ‚ä§) : (‚®Ü i ‚àà s, X.basicOpen i) = U := by\n  apply le_antisymm\n  ¬∑ rw [iSup‚ÇÇ_le_iff]\n    exact fun i _ ‚Ü¶ X.basicOpen_le i\n  ¬∑ intro x hx\n    obtain ‚ü®_, ‚ü®V, hV, rfl‚ü©, hxV, hVU‚ü© := (isBasis_affine_open X).exists_subset_of_mem_open hx U.2\n    refine SetLike.mem_of_subset ?_ hxV\n    rw [‚Üê (hV.basicOpen_union_eq_self_iff (X.presheaf.map (homOfLE hVU).op '' s)).mpr\n      (by rw [‚Üê Ideal.map_span, hs, Ideal.map_top])]\n    simp only [Opens.iSup_mk, Opens.carrier_eq_coe, Set.iUnion_coe_set, Set.mem_image,\n      Set.iUnion_exists, Set.biUnion_and', Set.iUnion_iUnion_eq_right, Scheme.basicOpen_res,\n      Opens.coe_inf, Opens.coe_mk, Set.iUnion_subset_iff]\n    exact fun i hi ‚Ü¶ (Set.inter_subset_right.trans\n      (Set.subset_iUnion‚ÇÇ (s := fun x _ ‚Ü¶ (X.basicOpen x : Set X)) i hi))\n\n"}
{"name":"AlgebraicGeometry.of_affine_open_cover","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nP : ‚ÜëX.affineOpens ‚Üí Prop\nŒπ : Sort u_2\nU : Œπ ‚Üí ‚ÜëX.affineOpens\niSup_U : Eq (iSup fun i => ‚Üë(U i)) Top.top\nV : ‚ÜëX.affineOpens\nbasicOpen : ‚àÄ (U : ‚ÜëX.affineOpens) (f : ‚Üë(X.presheaf.obj { unop := ‚ÜëU })), P U ‚Üí P (X.affineBasicOpen f)\nopenCover : ‚àÄ (U : ‚ÜëX.affineOpens) (s : Finset ‚Üë(X.presheaf.obj { unop := ‚ÜëU })), Eq (Ideal.span ‚Üës) Top.top ‚Üí (‚àÄ (f : Subtype fun x => Membership.mem s x), P (X.affineBasicOpen ‚Üëf)) ‚Üí P U\nhU : ‚àÄ (i : Œπ), P (U i)\n‚ä¢ P V","decl":"/-- Let `P` be a predicate on the affine open sets of `X` satisfying\n1. If `P` holds on `U`, then `P` holds on the basic open set of every section on `U`.\n2. If `P` holds for a family of basic open sets covering `U`, then `P` holds for `U`.\n3. There exists an affine open cover of `X` each satisfying `P`.\n\nThen `P` holds for every affine open of `X`.\n\nThis is also known as the **Affine communication lemma** in [*The rising sea*][RisingSea]. -/\n@[elab_as_elim]\ntheorem of_affine_open_cover {X : Scheme} {P : X.affineOpens ‚Üí Prop}\n    {Œπ} (U : Œπ ‚Üí X.affineOpens) (iSup_U : (‚®Ü i, U i : X.Opens) = ‚ä§)\n    (V : X.affineOpens)\n    (basicOpen : ‚àÄ (U : X.affineOpens) (f : Œì(X, U)), P U ‚Üí P (X.affineBasicOpen f))\n    (openCover :\n      ‚àÄ (U : X.affineOpens) (s : Finset (Œì(X, U)))\n        (_ : Ideal.span (s : Set (Œì(X, U))) = ‚ä§),\n        (‚àÄ f : s, P (X.affineBasicOpen f.1)) ‚Üí P U)\n    (hU : ‚àÄ i, P (U i)) : P V := by\n  classical\n  have : ‚àÄ (x : V.1), ‚àÉ f : Œì(X, V), ‚Üëx ‚àà X.basicOpen f ‚àß P (X.affineBasicOpen f) := by\n    intro x\n    obtain ‚ü®i, hi‚ü© := Opens.mem_iSup.mp (show x.1 ‚àà (‚®Ü i, U i : X.Opens) from iSup_U ‚ñ∏ trivial)\n    obtain ‚ü®f, g, e, hf‚ü© := exists_basicOpen_le_affine_inter V.prop (U i).prop x ‚ü®x.prop, hi‚ü©\n    refine ‚ü®f, hf, ?_‚ü©\n    convert basicOpen _ g (hU i) using 1\n    ext1\n    exact e\n  choose f hf‚ÇÅ hf‚ÇÇ using this\n  suffices Ideal.span (Set.range f) = ‚ä§ by\n    obtain ‚ü®t, ht‚ÇÅ, ht‚ÇÇ‚ü© := (Ideal.span_eq_top_iff_finite _).mp this\n    apply openCover V t ht‚ÇÇ\n    rintro ‚ü®i, hi‚ü©\n    obtain ‚ü®x, rfl‚ü© := ht‚ÇÅ hi\n    exact hf‚ÇÇ x\n  rw [‚Üê V.prop.self_le_basicOpen_union_iff]\n  intro x hx\n  rw [iSup_range', SetLike.mem_coe, Opens.mem_iSup]\n  exact ‚ü®_, hf‚ÇÅ ‚ü®x, hx‚ü©‚ü©\n\n"}
{"name":"AlgebraicGeometry.Scheme.toSpecŒì_preimage_zeroLocus","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\ns : Set ‚Üë(X.presheaf.obj { unop := Top.top })\n‚ä¢ Eq (Set.preimage (‚áëX.toSpecŒì.base) (PrimeSpectrum.zeroLocus s)) (X.zeroLocus s)","decl":"/-- On a scheme `X`, the preimage of the zero locus of the prime spectrum\nof `Œì(X, ‚ä§)` under `X.toSpecŒì : X ‚ü∂ Spec Œì(X, ‚ä§)` agrees with the associated zero locus on `X`. -/\nlemma toSpecŒì_preimage_zeroLocus (s : Set Œì(X, ‚ä§)) :\n    X.toSpecŒì.base ‚Åª¬π' PrimeSpectrum.zeroLocus s = X.zeroLocus s :=\n  LocallyRingedSpace.toŒìSpec_preimage_zeroLocus_eq s\n\n"}
{"name":"AlgebraicGeometry.Scheme.toŒìSpec_preimage_zeroLocus_eq","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\ns : Set ‚Üë(X.presheaf.obj { unop := Top.top })\n‚ä¢ Eq (Set.preimage (‚áëX.toSpecŒì.base) (PrimeSpectrum.zeroLocus s)) (X.zeroLocus s)","decl":"@[deprecated (since := \"2025-01-17\")] alias toŒìSpec_preimage_zeroLocus_eq :=\n  toSpecŒì_preimage_zeroLocus\n\n"}
{"name":"AlgebraicGeometry.Scheme.isoSpec_image_zeroLocus","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\ninst‚úù : AlgebraicGeometry.IsAffine X\ns : Set ‚Üë(X.presheaf.obj { unop := Top.top })\n‚ä¢ Eq (Set.image (‚áëX.isoSpec.hom.base) (X.zeroLocus s)) (PrimeSpectrum.zeroLocus s)","decl":"/-- If `X` is affine, the image of the zero locus of global sections of `X` under `X.isoSpec`\nis the zero locus in terms of the prime spectrum of `Œì(X, ‚ä§)`. -/\nlemma isoSpec_image_zeroLocus [IsAffine X]\n    (s : Set Œì(X, ‚ä§)) :\n    X.isoSpec.hom.base '' X.zeroLocus s = PrimeSpectrum.zeroLocus s := by\n  erw [‚Üê X.toSpecŒì_preimage_zeroLocus, Set.image_preimage_eq]\n  exact (bijective_of_isIso X.isoSpec.hom.base).surjective\n\n"}
{"name":"AlgebraicGeometry.Scheme.toSpecŒì_image_zeroLocus","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\ninst‚úù : AlgebraicGeometry.IsAffine X\ns : Set ‚Üë(X.presheaf.obj { unop := Top.top })\n‚ä¢ Eq (Set.image (‚áëX.toSpecŒì.base) (X.zeroLocus s)) (PrimeSpectrum.zeroLocus s)","decl":"lemma toSpecŒì_image_zeroLocus [IsAffine X] (s : Set Œì(X, ‚ä§)) :\n    X.toSpecŒì.base '' X.zeroLocus s = PrimeSpectrum.zeroLocus s :=\n  X.isoSpec_image_zeroLocus _\n\n"}
{"name":"AlgebraicGeometry.Scheme.isoSpec_inv_preimage_zeroLocus","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\ninst‚úù : AlgebraicGeometry.IsAffine X\ns : Set ‚Üë(X.presheaf.obj { unop := Top.top })\n‚ä¢ Eq (Set.preimage (‚áëX.isoSpec.inv.base) (X.zeroLocus s)) (PrimeSpectrum.zeroLocus s)","decl":"lemma isoSpec_inv_preimage_zeroLocus [IsAffine X] (s : Set Œì(X, ‚ä§)) :\n    X.isoSpec.inv.base ‚Åª¬π' X.zeroLocus s = PrimeSpectrum.zeroLocus s := by\n  rw [‚Üê toSpecŒì_preimage_zeroLocus, ‚Üê Set.preimage_comp, ‚Üê TopCat.coe_comp, ‚Üê Scheme.comp_base,\n    X.isoSpec_inv_toSpecŒì]\n  rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.isoSpec_inv_image_zeroLocus","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\ninst‚úù : AlgebraicGeometry.IsAffine X\ns : Set ‚Üë(X.presheaf.obj { unop := Top.top })\n‚ä¢ Eq (Set.image (‚áëX.isoSpec.inv.base) (PrimeSpectrum.zeroLocus s)) (X.zeroLocus s)","decl":"lemma isoSpec_inv_image_zeroLocus [IsAffine X] (s : Set Œì(X, ‚ä§)) :\n    X.isoSpec.inv.base '' PrimeSpectrum.zeroLocus s = X.zeroLocus s := by\n  rw [‚Üê isoSpec_inv_preimage_zeroLocus, Set.image_preimage_eq]\n  exact (bijective_of_isIso X.isoSpec.inv.base).surjective\n\n"}
{"name":"AlgebraicGeometry.Scheme.toŒìSpec_image_zeroLocus_eq_of_isAffine","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\ninst‚úù : AlgebraicGeometry.IsAffine X\ns : Set ‚Üë(X.presheaf.obj { unop := Top.top })\n‚ä¢ Eq (Set.image (‚áëX.isoSpec.hom.base) (X.zeroLocus s)) (PrimeSpectrum.zeroLocus s)","decl":"@[deprecated (since := \"2025-01-17\")] alias toŒìSpec_image_zeroLocus_eq_of_isAffine :=\n  Scheme.isoSpec_image_zeroLocus\n\n"}
{"name":"AlgebraicGeometry.Scheme.eq_zeroLocus_of_isClosed_of_isAffine","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\ninst‚úù : AlgebraicGeometry.IsAffine X\ns : Set ‚Üë‚ÜëX.toPresheafedSpace\n‚ä¢ Iff (IsClosed s) (Exists fun I => Eq s (X.zeroLocus ‚ÜëI))","decl":"/-- If `X` is an affine scheme, every closed set of `X` is the zero locus\nof a set of global sections. -/\nlemma eq_zeroLocus_of_isClosed_of_isAffine [IsAffine X] (s : Set X) :\n    IsClosed s ‚Üî ‚àÉ I : Ideal (Œì(X, ‚ä§)), s = X.zeroLocus (I : Set Œì(X, ‚ä§)) := by\n  refine ‚ü®fun hs ‚Ü¶ ?_, ?_‚ü©\n  ¬∑ let Z : Set (Spec <| Œì(X, ‚ä§)) := X.toŒìSpecFun '' s\n    have hZ : IsClosed Z := (X.isoSpec.hom.homeomorph).isClosedMap _ hs\n    obtain ‚ü®I, (hI : Z = _)‚ü© := (PrimeSpectrum.isClosed_iff_zeroLocus_ideal _).mp hZ\n    use I\n    simp only [‚Üê Scheme.toSpecŒì_preimage_zeroLocus, ‚Üê hI, Z]\n    erw [Set.preimage_image_eq _ (bijective_of_isIso X.isoSpec.hom.base).injective]\n  ¬∑ rintro ‚ü®I, rfl‚ü©\n    exact zeroLocus_isClosed X I.carrier\n\n"}
{"name":"AlgebraicGeometry.Scheme.Opens.toSpecŒì_preimage_zeroLocus","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\ns : Set ‚Üë(X.presheaf.obj { unop := U })\n‚ä¢ Eq (Set.preimage (‚áëU.toSpecŒì.base) (PrimeSpectrum.zeroLocus s)) (Set.preimage Subtype.val (X.zeroLocus s))","decl":"open Set.Notation in\nlemma Opens.toSpecŒì_preimage_zeroLocus {X : Scheme.{u}} (U : X.Opens)\n    (s : Set Œì(X, U)) :\n    U.toSpecŒì.base ‚Åª¬π' PrimeSpectrum.zeroLocus s = U.1 ‚Üì‚à© X.zeroLocus s := by\n  rw [toSpecŒì, Scheme.comp_base, TopCat.coe_comp, Set.preimage_comp, Spec.map_base]\n  erw [PrimeSpectrum.preimage_comap_zeroLocus]\n  rw [Scheme.toSpecŒì_preimage_zeroLocus]\n  show _ = U.Œπ.base ‚Åª¬π' (X.zeroLocus s)\n  rw [Scheme.preimage_zeroLocus, U.Œπ_app_self, ‚Üê zeroLocus_map_of_eq _ U.Œπ_preimage_self,\n    ‚Üê Set.image_comp, ‚Üê RingHom.coe_comp, ‚Üê CommRingCat.hom_comp]\n  congr!\n  simp [‚Üê Functor.map_comp]\n  rfl\n\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.fromSpec_preimage_zeroLocus","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\ns : Set ‚Üë(X.presheaf.obj { unop := U })\n‚ä¢ Eq (Set.preimage (‚áëhU.fromSpec.base) (X.zeroLocus s)) (PrimeSpectrum.zeroLocus s)","decl":"lemma IsAffineOpen.fromSpec_preimage_zeroLocus {X : Scheme.{u}} {U : X.Opens}\n    (hU : IsAffineOpen U) (s : Set Œì(X, U)) :\n    hU.fromSpec.base ‚Åª¬π' X.zeroLocus s = PrimeSpectrum.zeroLocus s := by\n  ext x\n  suffices (‚àÄ f ‚àà s, ¬¨¬¨ f ‚àà x.asIdeal) ‚Üî s ‚äÜ x.asIdeal by\n    simpa [‚Üê hU.fromSpec_image_basicOpen, -not_not] using this\n  simp_rw [not_not]\n  rfl\n\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.fromSpec_image_zeroLocus","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\ns : Set ‚Üë(X.presheaf.obj { unop := U })\n‚ä¢ Eq (Set.image (‚áëhU.fromSpec.base) (PrimeSpectrum.zeroLocus s)) (Inter.inter (X.zeroLocus s) ‚ÜëU)","decl":"lemma IsAffineOpen.fromSpec_image_zeroLocus {X : Scheme.{u}} {U : X.Opens}\n    (hU : IsAffineOpen U) (s : Set Œì(X, U)) :\n    hU.fromSpec.base '' PrimeSpectrum.zeroLocus s = X.zeroLocus s ‚à© U := by\n  rw [‚Üê hU.fromSpec_preimage_zeroLocus, Set.image_preimage_eq_inter_range, range_fromSpec]\n\n"}
{"name":"AlgebraicGeometry.Scheme.zeroLocus_inf","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nI J : Ideal ‚Üë(X.presheaf.obj { unop := U })\n‚ä¢ Eq (X.zeroLocus ‚Üë(Min.min I J)) (Union.union (X.zeroLocus ‚ÜëI) (X.zeroLocus ‚ÜëJ))","decl":"open Set.Notation in\nlemma Scheme.zeroLocus_inf (X : Scheme.{u}) {U : X.Opens} (I J : Ideal Œì(X, U)) :\n    X.zeroLocus (U := U) ‚Üë(I ‚äì J) = X.zeroLocus (U := U) I ‚à™ X.zeroLocus (U := U) J := by\n  suffices U.1 ‚Üì‚à© (X.zeroLocus (U := U) ‚Üë(I ‚äì J)) =\n      U.1 ‚Üì‚à© (X.zeroLocus (U := U) I ‚à™ X.zeroLocus (U := U) J) by\n    ext x\n    by_cases hxU : x ‚àà U\n    ¬∑ simpa [hxU] using congr(‚ü®x, hxU‚ü© ‚àà $this)\n    ¬∑ simp only [Submodule.inf_coe, Set.mem_union,\n        codisjoint_iff_compl_le_left.mp (X.codisjoint_zeroLocus (U := U) (I ‚à© J)) hxU,\n        codisjoint_iff_compl_le_left.mp (X.codisjoint_zeroLocus (U := U) I) hxU, true_or]\n  simp only [‚Üê U.toSpecŒì_preimage_zeroLocus, PrimeSpectrum.zeroLocus_inf I J,\n    Set.preimage_union]\n\n"}
{"name":"AlgebraicGeometry.Scheme.zeroLocus_biInf","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nŒπ : Type u_1\nI : Œπ ‚Üí Ideal ‚Üë(X.presheaf.obj { unop := U })\nt : Set Œπ\nht : t.Finite\n‚ä¢ Eq (X.zeroLocus ‚Üë(iInf fun i => iInf fun h => I i)) (Union.union (Set.iUnion fun i => Set.iUnion fun h => X.zeroLocus ‚Üë(I i)) (HasCompl.compl ‚ÜëU))","decl":"lemma Scheme.zeroLocus_biInf\n    {X : Scheme.{u}} {U : X.Opens} {Œπ : Type*}\n    (I : Œπ ‚Üí Ideal Œì(X, U)) {t : Set Œπ} (ht : t.Finite) :\n    X.zeroLocus (U := U) ‚Üë(‚®Ö i ‚àà t, I i) = (‚ãÉ i ‚àà t, X.zeroLocus (U := U) (I i)) ‚à™ (‚ÜëU)·∂ú := by\n  refine ht.induction_on _ (by simp) fun {i t} hit ht IH ‚Ü¶ ?_\n  simp only [Set.mem_insert_iff, Set.iUnion_iUnion_eq_or_left, ‚Üê IH, ‚Üê zeroLocus_inf,\n    Submodule.inf_coe, Set.union_assoc]\n  congr!\n  simp\n\n"}
{"name":"AlgebraicGeometry.Scheme.zeroLocus_biInf_of_nonempty","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nŒπ : Type u_1\nI : Œπ ‚Üí Ideal ‚Üë(X.presheaf.obj { unop := U })\nt : Set Œπ\nht : t.Finite\nht' : t.Nonempty\n‚ä¢ Eq (X.zeroLocus ‚Üë(iInf fun i => iInf fun h => I i)) (Set.iUnion fun i => Set.iUnion fun h => X.zeroLocus ‚Üë(I i))","decl":"lemma Scheme.zeroLocus_biInf_of_nonempty\n    {X : Scheme.{u}} {U : X.Opens} {Œπ : Type*}\n    (I : Œπ ‚Üí Ideal Œì(X, U)) {t : Set Œπ} (ht : t.Finite) (ht' : t.Nonempty) :\n    X.zeroLocus (U := U) ‚Üë(‚®Ö i ‚àà t, I i) = ‚ãÉ i ‚àà t, X.zeroLocus (U := U) (I i) := by\n  rw [zeroLocus_biInf I ht, Set.union_eq_left]\n  obtain ‚ü®i, hi‚ü© := ht'\n  exact fun x hx ‚Ü¶ Set.mem_iUnion‚ÇÇ_of_mem hi\n    (codisjoint_iff_compl_le_left.mp (X.codisjoint_zeroLocus (U := U) (I i)) hx)\n\n"}
{"name":"AlgebraicGeometry.Scheme.zeroLocus_iInf","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nŒπ : Type u_1\nI : Œπ ‚Üí Ideal ‚Üë(X.presheaf.obj { unop := U })\ninst‚úù : Finite Œπ\n‚ä¢ Eq (X.zeroLocus ‚Üë(iInf fun i => I i)) (Union.union (Set.iUnion fun i => X.zeroLocus ‚Üë(I i)) (HasCompl.compl ‚ÜëU))","decl":"lemma Scheme.zeroLocus_iInf\n    {X : Scheme.{u}} {U : X.Opens} {Œπ : Type*}\n    (I : Œπ ‚Üí Ideal Œì(X, U)) [Finite Œπ] :\n    X.zeroLocus (U := U) ‚Üë(‚®Ö i, I i) = (‚ãÉ i, X.zeroLocus (U := U) (I i)) ‚à™ (‚ÜëU)·∂ú := by\n  simpa using zeroLocus_biInf I Set.finite_univ\n\n"}
{"name":"AlgebraicGeometry.Scheme.zeroLocus_iInf_of_nonempty","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nŒπ : Type u_1\nI : Œπ ‚Üí Ideal ‚Üë(X.presheaf.obj { unop := U })\ninst‚úù¬π : Finite Œπ\ninst‚úù : Nonempty Œπ\n‚ä¢ Eq (X.zeroLocus ‚Üë(iInf fun i => I i)) (Set.iUnion fun i => X.zeroLocus ‚Üë(I i))","decl":"lemma Scheme.zeroLocus_iInf_of_nonempty\n    {X : Scheme.{u}} {U : X.Opens} {Œπ : Type*}\n    (I : Œπ ‚Üí Ideal Œì(X, U)) [Finite Œπ] [Nonempty Œπ] :\n    X.zeroLocus (U := U) ‚Üë(‚®Ö i, I i) = ‚ãÉ i, X.zeroLocus (U := U) (I i) := by\n  simpa using zeroLocus_biInf_of_nonempty I Set.finite_univ\n\n"}
{"name":"AlgebraicGeometry.specTargetImageRingHom_surjective","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nA : CommRingCat\nf : Quiver.Hom X (AlgebraicGeometry.Spec A)\n‚ä¢ Function.Surjective ‚áë(CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.specTargetImageRingHom f))","decl":"lemma specTargetImageRingHom_surjective : Function.Surjective (specTargetImageRingHom f) :=\n  Ideal.Quotient.mk_surjective\n\n"}
{"name":"AlgebraicGeometry.specTargetImageFactorization_app_injective","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nA : CommRingCat\nf : Quiver.Hom X (AlgebraicGeometry.Spec A)\n‚ä¢ Function.Injective ‚áë(CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.Scheme.Hom.appTop (AlgebraicGeometry.specTargetImageFactorization f)))","decl":"lemma specTargetImageFactorization_app_injective :\n    Function.Injective <| (specTargetImageFactorization f).appTop := by\n  let œÜ : A ‚ü∂ Œì(X, ‚ä§) := (((ŒìSpec.adjunction).homEquiv X (op A)).symm f).unop\n  let œÜ' : specTargetImage f ‚ü∂ Scheme.Œì.obj (op X) := CommRingCat.ofHom (RingHom.kerLift œÜ.hom)\n  show Function.Injective <| ((ŒìSpec.adjunction.homEquiv X _) œÜ'.op).appTop\n  rw [ŒìSpec_adjunction_homEquiv_eq]\n  apply (RingHom.kerLift_injective œÜ.hom).comp\n  exact ((ConcreteCategory.isIso_iff_bijective (Scheme.ŒìSpecIso _).hom).mp inferInstance).injective\n\n"}
{"name":"AlgebraicGeometry.specTargetImageFactorization_comp","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nA : CommRingCat\nf : Quiver.Hom X (AlgebraicGeometry.Spec A)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.specTargetImageFactorization f) (AlgebraicGeometry.Spec.map (AlgebraicGeometry.specTargetImageRingHom f))) f","decl":"@[reassoc (attr := simp)]\nlemma specTargetImageFactorization_comp :\n    specTargetImageFactorization f ‚â´ Spec.map (specTargetImageRingHom f) = f := by\n  let œÜ : A ‚ü∂ Œì(X, ‚ä§) := (((ŒìSpec.adjunction).homEquiv X (op A)).symm f).unop\n  let œÜ' : specTargetImage f ‚ü∂ Scheme.Œì.obj (op X) := CommRingCat.ofHom (RingHom.kerLift œÜ.hom)\n  apply ((ŒìSpec.adjunction).homEquiv X (op A)).symm.injective\n  apply Opposite.unop_injective\n  rw [Adjunction.homEquiv_naturality_left_symm, Adjunction.homEquiv_counit]\n  change (_ ‚â´ _) ‚â´ _ = œÜ\n  erw [‚Üê Spec_Œì_naturality]\n  rw [Category.assoc]\n  erw [ŒìSpecIso_inv_ŒìSpec_adjunction_homEquiv œÜ']\n  ext a\n  apply RingHom.kerLift_mk\n\n"}
{"name":"AlgebraicGeometry.specTargetImageFactorization_comp_assoc","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X : AlgebraicGeometry.Scheme\nA : CommRingCat\nf : Quiver.Hom X (AlgebraicGeometry.Spec A)\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (AlgebraicGeometry.Spec A) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.specTargetImageFactorization f) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map (AlgebraicGeometry.specTargetImageRingHom f)) h)) (CategoryTheory.CategoryStruct.comp f h)","decl":"@[reassoc (attr := simp)]\nlemma specTargetImageFactorization_comp :\n    specTargetImageFactorization f ‚â´ Spec.map (specTargetImageRingHom f) = f := by\n  let œÜ : A ‚ü∂ Œì(X, ‚ä§) := (((ŒìSpec.adjunction).homEquiv X (op A)).symm f).unop\n  let œÜ' : specTargetImage f ‚ü∂ Scheme.Œì.obj (op X) := CommRingCat.ofHom (RingHom.kerLift œÜ.hom)\n  apply ((ŒìSpec.adjunction).homEquiv X (op A)).symm.injective\n  apply Opposite.unop_injective\n  rw [Adjunction.homEquiv_naturality_left_symm, Adjunction.homEquiv_counit]\n  change (_ ‚â´ _) ‚â´ _ = œÜ\n  erw [‚Üê Spec_Œì_naturality]\n  rw [Category.assoc]\n  erw [ŒìSpecIso_inv_ŒìSpec_adjunction_homEquiv œÜ']\n  ext a\n  apply RingHom.kerLift_mk\n\n"}
{"name":"AlgebraicGeometry.instIsAffineAffineTargetImage","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\ninst‚úù : AlgebraicGeometry.IsAffine Y\nf : Quiver.Hom X Y\n‚ä¢ AlgebraicGeometry.IsAffine (AlgebraicGeometry.affineTargetImage f)","decl":"instance : IsAffine (affineTargetImage f) := inferInstanceAs <| IsAffine <| Spec _\n\n"}
{"name":"AlgebraicGeometry.affineTargetImageInclusion_app_surjective","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\ninst‚úù : AlgebraicGeometry.IsAffine Y\nf : Quiver.Hom X Y\n‚ä¢ Function.Surjective ‚áë(CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.Scheme.Hom.appTop (AlgebraicGeometry.affineTargetImageInclusion f)))","decl":"lemma affineTargetImageInclusion_app_surjective :\n    Function.Surjective <| (affineTargetImageInclusion f).appTop := by\n  simp only [Scheme.comp_coeBase, Opens.map_comp_obj, Opens.map_top, Scheme.comp_app,\n    CommRingCat.hom_comp, affineTargetImageInclusion, RingHom.coe_comp]\n  apply Function.Surjective.comp\n  ¬∑ haveI : (toMorphismProperty (fun f ‚Ü¶ Function.Surjective f)).RespectsIso := by\n      rw [‚Üê toMorphismProperty_respectsIso_iff]\n      exact surjective_respectsIso\n    exact (MorphismProperty.arrow_mk_iso_iff\n      (toMorphismProperty (fun f ‚Ü¶ Function.Surjective f))\n      (arrowIsoŒìSpecOfIsAffine (specTargetImageRingHom (f ‚â´ Y.isoSpec.hom))).symm).mpr <|\n        specTargetImageRingHom_surjective (f ‚â´ Y.isoSpec.hom)\n  ¬∑ apply Function.Bijective.surjective\n    exact ConcreteCategory.bijective_of_isIso (Scheme.Hom.app Y.isoSpec.inv ‚ä§)\n\n"}
{"name":"AlgebraicGeometry.affineTargetImageFactorization_app_injective","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\ninst‚úù : AlgebraicGeometry.IsAffine Y\nf : Quiver.Hom X Y\n‚ä¢ Function.Injective ‚áë(CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.Scheme.Hom.appTop (AlgebraicGeometry.affineTargetImageFactorization f)))","decl":"lemma affineTargetImageFactorization_app_injective :\n    Function.Injective <| (affineTargetImageFactorization f).appTop :=\n  specTargetImageFactorization_app_injective (f ‚â´ Y.isoSpec.hom)\n\n"}
{"name":"AlgebraicGeometry.affineTargetImageFactorization_comp","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\ninst‚úù : AlgebraicGeometry.IsAffine Y\nf : Quiver.Hom X Y\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.affineTargetImageFactorization f) (AlgebraicGeometry.affineTargetImageInclusion f)) f","decl":"@[reassoc (attr := simp)]\nlemma affineTargetImageFactorization_comp :\n    affineTargetImageFactorization f ‚â´ affineTargetImageInclusion f = f := by\n  simp [affineTargetImageFactorization, affineTargetImageInclusion]\n\n"}
{"name":"AlgebraicGeometry.affineTargetImageFactorization_comp_assoc","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\ninst‚úù : AlgebraicGeometry.IsAffine Y\nf : Quiver.Hom X Y\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.affineTargetImageFactorization f) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.affineTargetImageInclusion f) h)) (CategoryTheory.CategoryStruct.comp f h)","decl":"@[reassoc (attr := simp)]\nlemma affineTargetImageFactorization_comp :\n    affineTargetImageFactorization f ‚â´ affineTargetImageInclusion f = f := by\n  simp [affineTargetImageFactorization, affineTargetImageInclusion]\n\n"}
{"name":"AlgebraicGeometry.Scheme.localRingHom_comp_stalkIso","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"R S : CommRingCat\nf : Quiver.Hom R S\np : PrimeSpectrum ‚ÜëS\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.StructureSheaf.stalkIso (‚ÜëR) ((PrimeSpectrum.comap (CommRingCat.Hom.hom f)) p)).hom (CategoryTheory.CategoryStruct.comp (CommRingCat.ofHom (Localization.localRingHom ((PrimeSpectrum.comap (CommRingCat.Hom.hom f)) p).asIdeal p.asIdeal (CommRingCat.Hom.hom f) ‚ãØ)) (AlgebraicGeometry.StructureSheaf.stalkIso (‚ÜëS) p).inv)) (AlgebraicGeometry.Scheme.Hom.stalkMap (AlgebraicGeometry.Spec.map f) p)","decl":"/-- Variant of `AlgebraicGeometry.localRingHom_comp_stalkIso` for `Spec.map`. -/\n@[elementwise]\nlemma Scheme.localRingHom_comp_stalkIso {R S : CommRingCat.{u}} (f : R ‚ü∂ S) (p : PrimeSpectrum S) :\n    (StructureSheaf.stalkIso R (PrimeSpectrum.comap f.hom p)).hom ‚â´\n      (CommRingCat.ofHom <| Localization.localRingHom\n        (PrimeSpectrum.comap f.hom p).asIdeal p.asIdeal f.hom rfl) ‚â´\n      (StructureSheaf.stalkIso S p).inv = (Spec.map f).stalkMap p :=\n  AlgebraicGeometry.localRingHom_comp_stalkIso f p\n\n"}
{"name":"AlgebraicGeometry.Scheme.localRingHom_comp_stalkIso_apply","module":"Mathlib.AlgebraicGeometry.AffineScheme","initialProofState":"R S : CommRingCat\nf : Quiver.Hom R S\np : PrimeSpectrum ‚ÜëS\nx : CategoryTheory.ToType ((AlgebraicGeometry.Spec.structureSheaf ‚ÜëR).presheaf.stalk ((PrimeSpectrum.comap (CommRingCat.Hom.hom f)) p))\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.StructureSheaf.localizationToStalk (‚ÜëS) p)) ((Localization.localRingHom (Ideal.comap (CommRingCat.Hom.hom f) p.asIdeal) p.asIdeal (CommRingCat.Hom.hom f) ‚ãØ) ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.StructureSheaf.stalkToFiberRingHom (‚ÜëR) ((PrimeSpectrum.comap (CommRingCat.Hom.hom f)) p))) x))) ((AlgebraicGeometry.Scheme.Hom.stalkMap (AlgebraicGeometry.Spec.map f) p) x)","decl":"/-- Variant of `AlgebraicGeometry.localRingHom_comp_stalkIso` for `Spec.map`. -/\n@[elementwise]\nlemma Scheme.localRingHom_comp_stalkIso {R S : CommRingCat.{u}} (f : R ‚ü∂ S) (p : PrimeSpectrum S) :\n    (StructureSheaf.stalkIso R (PrimeSpectrum.comap f.hom p)).hom ‚â´\n      (CommRingCat.ofHom <| Localization.localRingHom\n        (PrimeSpectrum.comap f.hom p).asIdeal p.asIdeal f.hom rfl) ‚â´\n      (StructureSheaf.stalkIso S p).inv = (Spec.map f).stalkMap p :=\n  AlgebraicGeometry.localRingHom_comp_stalkIso f p\n\n"}
