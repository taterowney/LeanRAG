{"name":"CategoryTheory.Limits.WalkingParallelFamily.one.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"J : Type w\ninst‚úù : SizeOf J\n‚ä¢ Eq (SizeOf.sizeOf CategoryTheory.Limits.WalkingParallelFamily.one) 1","decl":"/-- The type of objects for the diagram indexing a wide (co)equalizer. -/\ninductive WalkingParallelFamily (J : Type w) : Type w\n  | zero : WalkingParallelFamily J\n  | one : WalkingParallelFamily J\n\n"}
{"name":"CategoryTheory.Limits.WalkingParallelFamily.zero.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"J : Type w\ninst‚úù : SizeOf J\n‚ä¢ Eq (SizeOf.sizeOf CategoryTheory.Limits.WalkingParallelFamily.zero) 1","decl":"/-- The type of objects for the diagram indexing a wide (co)equalizer. -/\ninductive WalkingParallelFamily (J : Type w) : Type w\n  | zero : WalkingParallelFamily J\n  | one : WalkingParallelFamily J\n\n"}
{"name":"CategoryTheory.Limits.WalkingParallelFamily.Hom.line.injEq","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"J : Type w\na‚úù¬π a‚úù : J\n‚ä¢ Eq (Eq (CategoryTheory.Limits.WalkingParallelFamily.Hom.line a‚úù¬π) (CategoryTheory.Limits.WalkingParallelFamily.Hom.line a‚úù)) (Eq a‚úù¬π a‚úù)","decl":"set_option genSizeOfSpec false in\n/-- The type family of morphisms for the diagram indexing a wide (co)equalizer. -/\ninductive WalkingParallelFamily.Hom (J : Type w) :\n  WalkingParallelFamily J ‚Üí WalkingParallelFamily J ‚Üí Type w\n  | id : ‚àÄ X : WalkingParallelFamily.{w} J, WalkingParallelFamily.Hom J X X\n  | line : J ‚Üí WalkingParallelFamily.Hom J zero one\n  deriving DecidableEq\n\n"}
{"name":"CategoryTheory.Limits.WalkingParallelFamily.Hom.line.inj","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"J : Type w\na‚úù¬π a‚úù : J\nx‚úù : Eq (CategoryTheory.Limits.WalkingParallelFamily.Hom.line a‚úù¬π) (CategoryTheory.Limits.WalkingParallelFamily.Hom.line a‚úù)\n‚ä¢ Eq a‚úù¬π a‚úù","decl":"set_option genSizeOfSpec false in\n/-- The type family of morphisms for the diagram indexing a wide (co)equalizer. -/\ninductive WalkingParallelFamily.Hom (J : Type w) :\n  WalkingParallelFamily J ‚Üí WalkingParallelFamily J ‚Üí Type w\n  | id : ‚àÄ X : WalkingParallelFamily.{w} J, WalkingParallelFamily.Hom J X X\n  | line : J ‚Üí WalkingParallelFamily.Hom J zero one\n  deriving DecidableEq\n\n"}
{"name":"CategoryTheory.Limits.WalkingParallelFamily.hom_id","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"J : Type w\nX : CategoryTheory.Limits.WalkingParallelFamily J\n‚ä¢ Eq (CategoryTheory.Limits.WalkingParallelFamily.Hom.id X) (CategoryTheory.CategoryStruct.id X)","decl":"@[simp]\ntheorem WalkingParallelFamily.hom_id (X : WalkingParallelFamily J) :\n    WalkingParallelFamily.Hom.id X = ùüô X :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.parallelFamily_obj_zero","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"J : Type w\nC : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : J ‚Üí Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.Limits.parallelFamily f).obj CategoryTheory.Limits.WalkingParallelFamily.zero) X","decl":"@[simp]\ntheorem parallelFamily_obj_zero : (parallelFamily f).obj zero = X :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.parallelFamily_obj_one","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"J : Type w\nC : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : J ‚Üí Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.Limits.parallelFamily f).obj CategoryTheory.Limits.WalkingParallelFamily.one) Y","decl":"@[simp]\ntheorem parallelFamily_obj_one : (parallelFamily f).obj one = Y :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.parallelFamily_map_left","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"J : Type w\nC : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : J ‚Üí Quiver.Hom X Y\nj : J\n‚ä¢ Eq ((CategoryTheory.Limits.parallelFamily f).map (CategoryTheory.Limits.WalkingParallelFamily.Hom.line j)) (f j)","decl":"@[simp]\ntheorem parallelFamily_map_left {j : J} : (parallelFamily f).map (line j) = f j :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.diagramIsoParallelFamily_hom_app","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"J : Type w\nC : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (CategoryTheory.Limits.WalkingParallelFamily J) C\nX : CategoryTheory.Limits.WalkingParallelFamily J\n‚ä¢ Eq ((CategoryTheory.Limits.diagramIsoParallelFamily F).hom.app X) (CategoryTheory.eqToHom ‚ãØ)","decl":"/-- Every functor indexing a wide (co)equalizer is naturally isomorphic (actually, equal) to a\n    `parallelFamily` -/\n@[simps!]\ndef diagramIsoParallelFamily (F : WalkingParallelFamily J ‚•§ C) :\n    F ‚âÖ parallelFamily fun j => F.map (line j) :=\n  NatIso.ofComponents (fun j => eqToIso <| by cases j <;> aesop_cat) <| by\n    rintro _ _ (_|_) <;> aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.diagramIsoParallelFamily_inv_app","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"J : Type w\nC : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (CategoryTheory.Limits.WalkingParallelFamily J) C\nX : CategoryTheory.Limits.WalkingParallelFamily J\n‚ä¢ Eq ((CategoryTheory.Limits.diagramIsoParallelFamily F).inv.app X) (CategoryTheory.eqToHom ‚ãØ)","decl":"/-- Every functor indexing a wide (co)equalizer is naturally isomorphic (actually, equal) to a\n    `parallelFamily` -/\n@[simps!]\ndef diagramIsoParallelFamily (F : WalkingParallelFamily J ‚•§ C) :\n    F ‚âÖ parallelFamily fun j => F.map (line j) :=\n  NatIso.ofComponents (fun j => eqToIso <| by cases j <;> aesop_cat) <| by\n    rintro _ _ (_|_) <;> aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair_functor_map","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"x y : CategoryTheory.Limits.WalkingParallelFamily (ULift.{w, 0} Bool)\nh : Quiver.Hom x y\n‚ä¢ Eq (CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair.functor.map h) (CategoryTheory.Limits.parallelFamily.match_1 (fun x y h => Quiver.Hom (CategoryTheory.Limits.WalkingParallelFamily.rec CategoryTheory.Limits.WalkingParallelPair.zero CategoryTheory.Limits.WalkingParallelPair.one x) (CategoryTheory.Limits.WalkingParallelFamily.rec CategoryTheory.Limits.WalkingParallelPair.zero CategoryTheory.Limits.WalkingParallelPair.one y)) x y h (fun x => CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.WalkingParallelFamily.rec CategoryTheory.Limits.WalkingParallelPair.zero CategoryTheory.Limits.WalkingParallelPair.one x)) fun j => cond j.down CategoryTheory.Limits.WalkingParallelPairHom.left CategoryTheory.Limits.WalkingParallelPairHom.right)","decl":"/-- `WalkingParallelPair` as a category is equivalent to a special case of\n`WalkingParallelFamily`. -/\n@[simps!]\ndef walkingParallelFamilyEquivWalkingParallelPair :\n    WalkingParallelFamily.{w} (ULift Bool) ‚âå WalkingParallelPair where\n  functor :=\n    parallelFamily fun p => cond p.down WalkingParallelPairHom.left WalkingParallelPairHom.right\n  inverse := parallelPair (line (ULift.up true)) (line (ULift.up false))\n  unitIso := NatIso.ofComponents (fun X => eqToIso (by cases X <;> rfl)) (by\n    rintro _ _ (_|‚ü®_|_‚ü©) <;> aesop_cat)\n  counitIso := NatIso.ofComponents (fun X => eqToIso (by cases X <;> rfl)) (by\n    rintro _ _ (_|_|_) <;> aesop_cat)\n  functor_unitIso_comp := by rintro (_|_) <;> aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair_unitIso_inv_app","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"X : CategoryTheory.Limits.WalkingParallelFamily (ULift.{w, 0} Bool)\n‚ä¢ Eq (CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair.unitIso.inv.app X) (CategoryTheory.eqToHom ‚ãØ)","decl":"/-- `WalkingParallelPair` as a category is equivalent to a special case of\n`WalkingParallelFamily`. -/\n@[simps!]\ndef walkingParallelFamilyEquivWalkingParallelPair :\n    WalkingParallelFamily.{w} (ULift Bool) ‚âå WalkingParallelPair where\n  functor :=\n    parallelFamily fun p => cond p.down WalkingParallelPairHom.left WalkingParallelPairHom.right\n  inverse := parallelPair (line (ULift.up true)) (line (ULift.up false))\n  unitIso := NatIso.ofComponents (fun X => eqToIso (by cases X <;> rfl)) (by\n    rintro _ _ (_|‚ü®_|_‚ü©) <;> aesop_cat)\n  counitIso := NatIso.ofComponents (fun X => eqToIso (by cases X <;> rfl)) (by\n    rintro _ _ (_|_|_) <;> aesop_cat)\n  functor_unitIso_comp := by rintro (_|_) <;> aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair_functor_obj","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"x : CategoryTheory.Limits.WalkingParallelFamily (ULift.{w, 0} Bool)\n‚ä¢ Eq (CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair.functor.obj x) (CategoryTheory.Limits.WalkingParallelFamily.rec CategoryTheory.Limits.WalkingParallelPair.zero CategoryTheory.Limits.WalkingParallelPair.one x)","decl":"/-- `WalkingParallelPair` as a category is equivalent to a special case of\n`WalkingParallelFamily`. -/\n@[simps!]\ndef walkingParallelFamilyEquivWalkingParallelPair :\n    WalkingParallelFamily.{w} (ULift Bool) ‚âå WalkingParallelPair where\n  functor :=\n    parallelFamily fun p => cond p.down WalkingParallelPairHom.left WalkingParallelPairHom.right\n  inverse := parallelPair (line (ULift.up true)) (line (ULift.up false))\n  unitIso := NatIso.ofComponents (fun X => eqToIso (by cases X <;> rfl)) (by\n    rintro _ _ (_|‚ü®_|_‚ü©) <;> aesop_cat)\n  counitIso := NatIso.ofComponents (fun X => eqToIso (by cases X <;> rfl)) (by\n    rintro _ _ (_|_|_) <;> aesop_cat)\n  functor_unitIso_comp := by rintro (_|_) <;> aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair_inverse_obj","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"x : CategoryTheory.Limits.WalkingParallelPair\n‚ä¢ Eq (CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair.inverse.obj x) (CategoryTheory.Limits.parallelPair.match_1 (fun x => CategoryTheory.Limits.WalkingParallelFamily (ULift.{w, 0} Bool)) x (fun _ => CategoryTheory.Limits.WalkingParallelFamily.zero) fun _ => CategoryTheory.Limits.WalkingParallelFamily.one)","decl":"/-- `WalkingParallelPair` as a category is equivalent to a special case of\n`WalkingParallelFamily`. -/\n@[simps!]\ndef walkingParallelFamilyEquivWalkingParallelPair :\n    WalkingParallelFamily.{w} (ULift Bool) ‚âå WalkingParallelPair where\n  functor :=\n    parallelFamily fun p => cond p.down WalkingParallelPairHom.left WalkingParallelPairHom.right\n  inverse := parallelPair (line (ULift.up true)) (line (ULift.up false))\n  unitIso := NatIso.ofComponents (fun X => eqToIso (by cases X <;> rfl)) (by\n    rintro _ _ (_|‚ü®_|_‚ü©) <;> aesop_cat)\n  counitIso := NatIso.ofComponents (fun X => eqToIso (by cases X <;> rfl)) (by\n    rintro _ _ (_|_|_) <;> aesop_cat)\n  functor_unitIso_comp := by rintro (_|_) <;> aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair_unitIso_hom_app","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"X : CategoryTheory.Limits.WalkingParallelFamily (ULift.{w, 0} Bool)\n‚ä¢ Eq (CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair.unitIso.hom.app X) (CategoryTheory.eqToHom ‚ãØ)","decl":"/-- `WalkingParallelPair` as a category is equivalent to a special case of\n`WalkingParallelFamily`. -/\n@[simps!]\ndef walkingParallelFamilyEquivWalkingParallelPair :\n    WalkingParallelFamily.{w} (ULift Bool) ‚âå WalkingParallelPair where\n  functor :=\n    parallelFamily fun p => cond p.down WalkingParallelPairHom.left WalkingParallelPairHom.right\n  inverse := parallelPair (line (ULift.up true)) (line (ULift.up false))\n  unitIso := NatIso.ofComponents (fun X => eqToIso (by cases X <;> rfl)) (by\n    rintro _ _ (_|‚ü®_|_‚ü©) <;> aesop_cat)\n  counitIso := NatIso.ofComponents (fun X => eqToIso (by cases X <;> rfl)) (by\n    rintro _ _ (_|_|_) <;> aesop_cat)\n  functor_unitIso_comp := by rintro (_|_) <;> aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair_counitIso_inv_app","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"X : CategoryTheory.Limits.WalkingParallelPair\n‚ä¢ Eq (CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair.counitIso.inv.app X) (CategoryTheory.eqToHom ‚ãØ)","decl":"/-- `WalkingParallelPair` as a category is equivalent to a special case of\n`WalkingParallelFamily`. -/\n@[simps!]\ndef walkingParallelFamilyEquivWalkingParallelPair :\n    WalkingParallelFamily.{w} (ULift Bool) ‚âå WalkingParallelPair where\n  functor :=\n    parallelFamily fun p => cond p.down WalkingParallelPairHom.left WalkingParallelPairHom.right\n  inverse := parallelPair (line (ULift.up true)) (line (ULift.up false))\n  unitIso := NatIso.ofComponents (fun X => eqToIso (by cases X <;> rfl)) (by\n    rintro _ _ (_|‚ü®_|_‚ü©) <;> aesop_cat)\n  counitIso := NatIso.ofComponents (fun X => eqToIso (by cases X <;> rfl)) (by\n    rintro _ _ (_|_|_) <;> aesop_cat)\n  functor_unitIso_comp := by rintro (_|_) <;> aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair_counitIso_hom_app","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"X : CategoryTheory.Limits.WalkingParallelPair\n‚ä¢ Eq (CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair.counitIso.hom.app X) (CategoryTheory.eqToHom ‚ãØ)","decl":"/-- `WalkingParallelPair` as a category is equivalent to a special case of\n`WalkingParallelFamily`. -/\n@[simps!]\ndef walkingParallelFamilyEquivWalkingParallelPair :\n    WalkingParallelFamily.{w} (ULift Bool) ‚âå WalkingParallelPair where\n  functor :=\n    parallelFamily fun p => cond p.down WalkingParallelPairHom.left WalkingParallelPairHom.right\n  inverse := parallelPair (line (ULift.up true)) (line (ULift.up false))\n  unitIso := NatIso.ofComponents (fun X => eqToIso (by cases X <;> rfl)) (by\n    rintro _ _ (_|‚ü®_|_‚ü©) <;> aesop_cat)\n  counitIso := NatIso.ofComponents (fun X => eqToIso (by cases X <;> rfl)) (by\n    rintro _ _ (_|_|_) <;> aesop_cat)\n  functor_unitIso_comp := by rintro (_|_) <;> aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair_inverse_map","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"X‚úù Y‚úù : CategoryTheory.Limits.WalkingParallelPair\nh : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair.inverse.map h) (CategoryTheory.Limits.parallelPair.match_2 (fun X Y h => Quiver.Hom (CategoryTheory.Limits.parallelPair.match_1 (fun x => CategoryTheory.Limits.WalkingParallelFamily (ULift.{w, 0} Bool)) X (fun _ => CategoryTheory.Limits.WalkingParallelFamily.zero) fun _ => CategoryTheory.Limits.WalkingParallelFamily.one) (CategoryTheory.Limits.parallelPair.match_1 (fun x => CategoryTheory.Limits.WalkingParallelFamily (ULift.{w, 0} Bool)) Y (fun _ => CategoryTheory.Limits.WalkingParallelFamily.zero) fun _ => CategoryTheory.Limits.WalkingParallelFamily.one)) X‚úù Y‚úù h (fun x => CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.parallelPair.match_1 (fun x => CategoryTheory.Limits.WalkingParallelFamily (ULift.{w, 0} Bool)) x (fun _ => CategoryTheory.Limits.WalkingParallelFamily.zero) fun _ => CategoryTheory.Limits.WalkingParallelFamily.one)) (fun _ => CategoryTheory.Limits.WalkingParallelFamily.Hom.line { down := Bool.true }) fun _ => CategoryTheory.Limits.WalkingParallelFamily.Hom.line { down := Bool.false })","decl":"/-- `WalkingParallelPair` as a category is equivalent to a special case of\n`WalkingParallelFamily`. -/\n@[simps!]\ndef walkingParallelFamilyEquivWalkingParallelPair :\n    WalkingParallelFamily.{w} (ULift Bool) ‚âå WalkingParallelPair where\n  functor :=\n    parallelFamily fun p => cond p.down WalkingParallelPairHom.left WalkingParallelPairHom.right\n  inverse := parallelPair (line (ULift.up true)) (line (ULift.up false))\n  unitIso := NatIso.ofComponents (fun X => eqToIso (by cases X <;> rfl)) (by\n    rintro _ _ (_|‚ü®_|_‚ü©) <;> aesop_cat)\n  counitIso := NatIso.ofComponents (fun X => eqToIso (by cases X <;> rfl)) (by\n    rintro _ _ (_|_|_) <;> aesop_cat)\n  functor_unitIso_comp := by rintro (_|_) <;> aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.Trident.Œπ_eq_app_zero","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"J : Type w\nC : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : J ‚Üí Quiver.Hom X Y\nt : CategoryTheory.Limits.Trident f\n‚ä¢ Eq t.Œπ (t.œÄ.app CategoryTheory.Limits.WalkingParallelFamily.zero)","decl":"@[simp]\ntheorem Trident.Œπ_eq_app_zero (t : Trident f) : t.Œπ = t.œÄ.app zero :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Cotrident.œÄ_eq_app_one","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"J : Type w\nC : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : J ‚Üí Quiver.Hom X Y\nt : CategoryTheory.Limits.Cotrident f\n‚ä¢ Eq t.œÄ (t.Œπ.app CategoryTheory.Limits.WalkingParallelFamily.one)","decl":"@[simp]\ntheorem Cotrident.œÄ_eq_app_one (t : Cotrident f) : t.œÄ = t.Œπ.app one :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Trident.app_zero","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"J : Type w\nC : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : J ‚Üí Quiver.Hom X Y\ns : CategoryTheory.Limits.Trident f\nj : J\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (s.œÄ.app CategoryTheory.Limits.WalkingParallelFamily.zero) (f j)) (s.œÄ.app CategoryTheory.Limits.WalkingParallelFamily.one)","decl":"@[reassoc (attr := simp)]\ntheorem Trident.app_zero (s : Trident f) (j : J) : s.œÄ.app zero ‚â´ f j = s.œÄ.app one := by\n  rw [‚Üê s.w (line j), parallelFamily_map_left]\n\n"}
{"name":"CategoryTheory.Limits.Trident.app_zero_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"J : Type w\nC : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : J ‚Üí Quiver.Hom X Y\ns : CategoryTheory.Limits.Trident f\nj : J\nZ : C\nh : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (s.œÄ.app CategoryTheory.Limits.WalkingParallelFamily.zero) (CategoryTheory.CategoryStruct.comp (f j) h)) (CategoryTheory.CategoryStruct.comp (s.œÄ.app CategoryTheory.Limits.WalkingParallelFamily.one) h)","decl":"@[reassoc (attr := simp)]\ntheorem Trident.app_zero (s : Trident f) (j : J) : s.œÄ.app zero ‚â´ f j = s.œÄ.app one := by\n  rw [‚Üê s.w (line j), parallelFamily_map_left]\n\n"}
{"name":"CategoryTheory.Limits.Cotrident.app_one_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"J : Type w\nC : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : J ‚Üí Quiver.Hom X Y\ns : CategoryTheory.Limits.Cotrident f\nj : J\nZ : C\nh : Quiver.Hom (((CategoryTheory.Functor.const (CategoryTheory.Limits.WalkingParallelFamily J)).obj s.pt).obj CategoryTheory.Limits.WalkingParallelFamily.one) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (f j) (CategoryTheory.CategoryStruct.comp (s.Œπ.app CategoryTheory.Limits.WalkingParallelFamily.one) h)) (CategoryTheory.CategoryStruct.comp (s.Œπ.app CategoryTheory.Limits.WalkingParallelFamily.zero) h)","decl":"@[reassoc (attr := simp)]\ntheorem Cotrident.app_one (s : Cotrident f) (j : J) : f j ‚â´ s.Œπ.app one = s.Œπ.app zero := by\n  rw [‚Üê s.w (line j), parallelFamily_map_left]\n\n"}
{"name":"CategoryTheory.Limits.Cotrident.app_one","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"J : Type w\nC : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : J ‚Üí Quiver.Hom X Y\ns : CategoryTheory.Limits.Cotrident f\nj : J\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (f j) (s.Œπ.app CategoryTheory.Limits.WalkingParallelFamily.one)) (s.Œπ.app CategoryTheory.Limits.WalkingParallelFamily.zero)","decl":"@[reassoc (attr := simp)]\ntheorem Cotrident.app_one (s : Cotrident f) (j : J) : f j ‚â´ s.Œπ.app one = s.Œπ.app zero := by\n  rw [‚Üê s.w (line j), parallelFamily_map_left]\n\n"}
{"name":"CategoryTheory.Limits.Trident.ofŒπ_œÄ_app","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"J : Type w\nC : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX‚úù Y : C\nf : J ‚Üí Quiver.Hom X‚úù Y\ninst‚úù : Nonempty J\nP : C\nŒπ : Quiver.Hom P X‚úù\nw : ‚àÄ (j‚ÇÅ j‚ÇÇ : J), Eq (CategoryTheory.CategoryStruct.comp Œπ (f j‚ÇÅ)) (CategoryTheory.CategoryStruct.comp Œπ (f j‚ÇÇ))\nX : CategoryTheory.Limits.WalkingParallelFamily J\n‚ä¢ Eq ((CategoryTheory.Limits.Trident.ofŒπ Œπ w).œÄ.app X) (CategoryTheory.Limits.WalkingParallelFamily.casesOn X Œπ (CategoryTheory.CategoryStruct.comp Œπ (f (Classical.arbitrary J))))","decl":"/-- A trident on `f : J ‚Üí (X ‚ü∂ Y)` is determined by the morphism `Œπ : P ‚ü∂ X` satisfying\n`‚àÄ j‚ÇÅ j‚ÇÇ, Œπ ‚â´ f j‚ÇÅ = Œπ ‚â´ f j‚ÇÇ`.\n-/\n@[simps]\ndef Trident.ofŒπ [Nonempty J] {P : C} (Œπ : P ‚ü∂ X) (w : ‚àÄ j‚ÇÅ j‚ÇÇ, Œπ ‚â´ f j‚ÇÅ = Œπ ‚â´ f j‚ÇÇ) :\n    Trident f where\n  pt := P\n  œÄ :=\n    { app := fun X => WalkingParallelFamily.casesOn X Œπ (Œπ ‚â´ f (Classical.arbitrary J))\n      naturality := fun i j f => by\n        dsimp\n        cases' f with _ k\n        ¬∑ simp\n        ¬∑ simp [w (Classical.arbitrary J) k] }\n\n"}
{"name":"CategoryTheory.Limits.Trident.ofŒπ_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"J : Type w\nC : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : J ‚Üí Quiver.Hom X Y\ninst‚úù : Nonempty J\nP : C\nŒπ : Quiver.Hom P X\nw : ‚àÄ (j‚ÇÅ j‚ÇÇ : J), Eq (CategoryTheory.CategoryStruct.comp Œπ (f j‚ÇÅ)) (CategoryTheory.CategoryStruct.comp Œπ (f j‚ÇÇ))\n‚ä¢ Eq (CategoryTheory.Limits.Trident.ofŒπ Œπ w).pt P","decl":"/-- A trident on `f : J ‚Üí (X ‚ü∂ Y)` is determined by the morphism `Œπ : P ‚ü∂ X` satisfying\n`‚àÄ j‚ÇÅ j‚ÇÇ, Œπ ‚â´ f j‚ÇÅ = Œπ ‚â´ f j‚ÇÇ`.\n-/\n@[simps]\ndef Trident.ofŒπ [Nonempty J] {P : C} (Œπ : P ‚ü∂ X) (w : ‚àÄ j‚ÇÅ j‚ÇÇ, Œπ ‚â´ f j‚ÇÅ = Œπ ‚â´ f j‚ÇÇ) :\n    Trident f where\n  pt := P\n  œÄ :=\n    { app := fun X => WalkingParallelFamily.casesOn X Œπ (Œπ ‚â´ f (Classical.arbitrary J))\n      naturality := fun i j f => by\n        dsimp\n        cases' f with _ k\n        ¬∑ simp\n        ¬∑ simp [w (Classical.arbitrary J) k] }\n\n"}
{"name":"CategoryTheory.Limits.Cotrident.ofœÄ_Œπ_app","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"J : Type w\nC : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX‚úù Y : C\nf : J ‚Üí Quiver.Hom X‚úù Y\ninst‚úù : Nonempty J\nP : C\nœÄ : Quiver.Hom Y P\nw : ‚àÄ (j‚ÇÅ j‚ÇÇ : J), Eq (CategoryTheory.CategoryStruct.comp (f j‚ÇÅ) œÄ) (CategoryTheory.CategoryStruct.comp (f j‚ÇÇ) œÄ)\nX : CategoryTheory.Limits.WalkingParallelFamily J\n‚ä¢ Eq ((CategoryTheory.Limits.Cotrident.ofœÄ œÄ w).Œπ.app X) (CategoryTheory.Limits.WalkingParallelFamily.casesOn X (CategoryTheory.CategoryStruct.comp (f (Classical.arbitrary J)) œÄ) œÄ)","decl":"/-- A cotrident on `f : J ‚Üí (X ‚ü∂ Y)` is determined by the morphism `œÄ : Y ‚ü∂ P` satisfying\n`‚àÄ j‚ÇÅ j‚ÇÇ, f j‚ÇÅ ‚â´ œÄ = f j‚ÇÇ ‚â´ œÄ`.\n-/\n@[simps]\ndef Cotrident.ofœÄ [Nonempty J] {P : C} (œÄ : Y ‚ü∂ P) (w : ‚àÄ j‚ÇÅ j‚ÇÇ, f j‚ÇÅ ‚â´ œÄ = f j‚ÇÇ ‚â´ œÄ) :\n    Cotrident f where\n  pt := P\n  Œπ :=\n    { app := fun X => WalkingParallelFamily.casesOn X (f (Classical.arbitrary J) ‚â´ œÄ) œÄ\n      naturality := fun i j f => by\n        dsimp\n        cases' f with _ k\n        ¬∑ simp\n        ¬∑ simp [w (Classical.arbitrary J) k] }\n\n-- See note [dsimp, simp]\n"}
{"name":"CategoryTheory.Limits.Cotrident.ofœÄ_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"J : Type w\nC : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : J ‚Üí Quiver.Hom X Y\ninst‚úù : Nonempty J\nP : C\nœÄ : Quiver.Hom Y P\nw : ‚àÄ (j‚ÇÅ j‚ÇÇ : J), Eq (CategoryTheory.CategoryStruct.comp (f j‚ÇÅ) œÄ) (CategoryTheory.CategoryStruct.comp (f j‚ÇÇ) œÄ)\n‚ä¢ Eq (CategoryTheory.Limits.Cotrident.ofœÄ œÄ w).pt P","decl":"/-- A cotrident on `f : J ‚Üí (X ‚ü∂ Y)` is determined by the morphism `œÄ : Y ‚ü∂ P` satisfying\n`‚àÄ j‚ÇÅ j‚ÇÇ, f j‚ÇÅ ‚â´ œÄ = f j‚ÇÇ ‚â´ œÄ`.\n-/\n@[simps]\ndef Cotrident.ofœÄ [Nonempty J] {P : C} (œÄ : Y ‚ü∂ P) (w : ‚àÄ j‚ÇÅ j‚ÇÇ, f j‚ÇÅ ‚â´ œÄ = f j‚ÇÇ ‚â´ œÄ) :\n    Cotrident f where\n  pt := P\n  Œπ :=\n    { app := fun X => WalkingParallelFamily.casesOn X (f (Classical.arbitrary J) ‚â´ œÄ) œÄ\n      naturality := fun i j f => by\n        dsimp\n        cases' f with _ k\n        ¬∑ simp\n        ¬∑ simp [w (Classical.arbitrary J) k] }\n\n-- See note [dsimp, simp]\n"}
{"name":"CategoryTheory.Limits.Trident.Œπ_ofŒπ","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"J : Type w\nC : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : J ‚Üí Quiver.Hom X Y\ninst‚úù : Nonempty J\nP : C\nŒπ : Quiver.Hom P X\nw : ‚àÄ (j‚ÇÅ j‚ÇÇ : J), Eq (CategoryTheory.CategoryStruct.comp Œπ (f j‚ÇÅ)) (CategoryTheory.CategoryStruct.comp Œπ (f j‚ÇÇ))\n‚ä¢ Eq (CategoryTheory.Limits.Trident.ofŒπ Œπ w).Œπ Œπ","decl":"theorem Trident.Œπ_ofŒπ [Nonempty J] {P : C} (Œπ : P ‚ü∂ X) (w : ‚àÄ j‚ÇÅ j‚ÇÇ, Œπ ‚â´ f j‚ÇÅ = Œπ ‚â´ f j‚ÇÇ) :\n    (Trident.ofŒπ Œπ w).Œπ = Œπ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Cotrident.œÄ_ofœÄ","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"J : Type w\nC : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : J ‚Üí Quiver.Hom X Y\ninst‚úù : Nonempty J\nP : C\nœÄ : Quiver.Hom Y P\nw : ‚àÄ (j‚ÇÅ j‚ÇÇ : J), Eq (CategoryTheory.CategoryStruct.comp (f j‚ÇÅ) œÄ) (CategoryTheory.CategoryStruct.comp (f j‚ÇÇ) œÄ)\n‚ä¢ Eq (CategoryTheory.Limits.Cotrident.ofœÄ œÄ w).œÄ œÄ","decl":"theorem Cotrident.œÄ_ofœÄ [Nonempty J] {P : C} (œÄ : Y ‚ü∂ P) (w : ‚àÄ j‚ÇÅ j‚ÇÇ, f j‚ÇÅ ‚â´ œÄ = f j‚ÇÇ ‚â´ œÄ) :\n    (Cotrident.ofœÄ œÄ w).œÄ = œÄ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Trident.condition_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"J : Type w\nC : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : J ‚Üí Quiver.Hom X Y\nj‚ÇÅ j‚ÇÇ : J\nt : CategoryTheory.Limits.Trident f\nZ : C\nh : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp t.Œπ (CategoryTheory.CategoryStruct.comp (f j‚ÇÅ) h)) (CategoryTheory.CategoryStruct.comp t.Œπ (CategoryTheory.CategoryStruct.comp (f j‚ÇÇ) h))","decl":"@[reassoc]\ntheorem Trident.condition (j‚ÇÅ j‚ÇÇ : J) (t : Trident f) : t.Œπ ‚â´ f j‚ÇÅ = t.Œπ ‚â´ f j‚ÇÇ := by\n  rw [t.app_zero, t.app_zero]\n\n"}
{"name":"CategoryTheory.Limits.Trident.condition","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"J : Type w\nC : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : J ‚Üí Quiver.Hom X Y\nj‚ÇÅ j‚ÇÇ : J\nt : CategoryTheory.Limits.Trident f\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp t.Œπ (f j‚ÇÅ)) (CategoryTheory.CategoryStruct.comp t.Œπ (f j‚ÇÇ))","decl":"@[reassoc]\ntheorem Trident.condition (j‚ÇÅ j‚ÇÇ : J) (t : Trident f) : t.Œπ ‚â´ f j‚ÇÅ = t.Œπ ‚â´ f j‚ÇÇ := by\n  rw [t.app_zero, t.app_zero]\n\n"}
{"name":"CategoryTheory.Limits.Cotrident.condition","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"J : Type w\nC : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : J ‚Üí Quiver.Hom X Y\nj‚ÇÅ j‚ÇÇ : J\nt : CategoryTheory.Limits.Cotrident f\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (f j‚ÇÅ) t.œÄ) (CategoryTheory.CategoryStruct.comp (f j‚ÇÇ) t.œÄ)","decl":"@[reassoc]\ntheorem Cotrident.condition (j‚ÇÅ j‚ÇÇ : J) (t : Cotrident f) : f j‚ÇÅ ‚â´ t.œÄ = f j‚ÇÇ ‚â´ t.œÄ := by\n  rw [t.app_one, t.app_one]\n\n"}
{"name":"CategoryTheory.Limits.Cotrident.condition_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"J : Type w\nC : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : J ‚Üí Quiver.Hom X Y\nj‚ÇÅ j‚ÇÇ : J\nt : CategoryTheory.Limits.Cotrident f\nZ : C\nh : Quiver.Hom (((CategoryTheory.Functor.const (CategoryTheory.Limits.WalkingParallelFamily J)).obj t.pt).obj CategoryTheory.Limits.WalkingParallelFamily.one) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (f j‚ÇÅ) (CategoryTheory.CategoryStruct.comp t.œÄ h)) (CategoryTheory.CategoryStruct.comp (f j‚ÇÇ) (CategoryTheory.CategoryStruct.comp t.œÄ h))","decl":"@[reassoc]\ntheorem Cotrident.condition (j‚ÇÅ j‚ÇÇ : J) (t : Cotrident f) : f j‚ÇÅ ‚â´ t.œÄ = f j‚ÇÇ ‚â´ t.œÄ := by\n  rw [t.app_one, t.app_one]\n\n"}
{"name":"CategoryTheory.Limits.Trident.equalizer_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"J : Type w\nC : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : J ‚Üí Quiver.Hom X Y\ninst‚úù : Nonempty J\ns : CategoryTheory.Limits.Trident f\nW : C\nk l : Quiver.Hom W s.pt\nh : Eq (CategoryTheory.CategoryStruct.comp k s.Œπ) (CategoryTheory.CategoryStruct.comp l s.Œπ)\nj : CategoryTheory.Limits.WalkingParallelFamily J\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp k (s.œÄ.app j)) (CategoryTheory.CategoryStruct.comp l (s.œÄ.app j))","decl":"/-- To check whether two maps are equalized by both maps of a trident, it suffices to check it for\nthe first map -/\ntheorem Trident.equalizer_ext [Nonempty J] (s : Trident f) {W : C} {k l : W ‚ü∂ s.pt}\n    (h : k ‚â´ s.Œπ = l ‚â´ s.Œπ) : ‚àÄ j : WalkingParallelFamily J, k ‚â´ s.œÄ.app j = l ‚â´ s.œÄ.app j\n  | zero => h\n  | one => by rw [‚Üê s.app_zero (Classical.arbitrary J), reassoc_of% h]\n\n"}
{"name":"CategoryTheory.Limits.Cotrident.coequalizer_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"J : Type w\nC : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : J ‚Üí Quiver.Hom X Y\ninst‚úù : Nonempty J\ns : CategoryTheory.Limits.Cotrident f\nW : C\nk l : Quiver.Hom s.pt W\nh : Eq (CategoryTheory.CategoryStruct.comp s.œÄ k) (CategoryTheory.CategoryStruct.comp s.œÄ l)\nj : CategoryTheory.Limits.WalkingParallelFamily J\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (s.Œπ.app j) k) (CategoryTheory.CategoryStruct.comp (s.Œπ.app j) l)","decl":"/-- To check whether two maps are coequalized by both maps of a cotrident, it suffices to check it\nfor the second map -/\ntheorem Cotrident.coequalizer_ext [Nonempty J] (s : Cotrident f) {W : C} {k l : s.pt ‚ü∂ W}\n    (h : s.œÄ ‚â´ k = s.œÄ ‚â´ l) : ‚àÄ j : WalkingParallelFamily J, s.Œπ.app j ‚â´ k = s.Œπ.app j ‚â´ l\n  | zero => by rw [‚Üê s.app_one (Classical.arbitrary J), Category.assoc, Category.assoc, h]\n  | one => h\n\n"}
{"name":"CategoryTheory.Limits.Trident.IsLimit.hom_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"J : Type w\nC : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : J ‚Üí Quiver.Hom X Y\ninst‚úù : Nonempty J\ns : CategoryTheory.Limits.Trident f\nhs : CategoryTheory.Limits.IsLimit s\nW : C\nk l : Quiver.Hom W s.pt\nh : Eq (CategoryTheory.CategoryStruct.comp k s.Œπ) (CategoryTheory.CategoryStruct.comp l s.Œπ)\n‚ä¢ Eq k l","decl":"theorem Trident.IsLimit.hom_ext [Nonempty J] {s : Trident f} (hs : IsLimit s) {W : C}\n    {k l : W ‚ü∂ s.pt} (h : k ‚â´ s.Œπ = l ‚â´ s.Œπ) : k = l :=\n  hs.hom_ext <| Trident.equalizer_ext _ h\n\n"}
{"name":"CategoryTheory.Limits.Cotrident.IsColimit.hom_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"J : Type w\nC : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : J ‚Üí Quiver.Hom X Y\ninst‚úù : Nonempty J\ns : CategoryTheory.Limits.Cotrident f\nhs : CategoryTheory.Limits.IsColimit s\nW : C\nk l : Quiver.Hom s.pt W\nh : Eq (CategoryTheory.CategoryStruct.comp s.œÄ k) (CategoryTheory.CategoryStruct.comp s.œÄ l)\n‚ä¢ Eq k l","decl":"theorem Cotrident.IsColimit.hom_ext [Nonempty J] {s : Cotrident f} (hs : IsColimit s) {W : C}\n    {k l : s.pt ‚ü∂ W} (h : s.œÄ ‚â´ k = s.œÄ ‚â´ l) : k = l :=\n  hs.hom_ext <| Cotrident.coequalizer_ext _ h\n\n"}
{"name":"CategoryTheory.Limits.Trident.IsLimit.homIso_apply_coe","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"J : Type w\nC : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : J ‚Üí Quiver.Hom X Y\ninst‚úù : Nonempty J\nt : CategoryTheory.Limits.Trident f\nht : CategoryTheory.Limits.IsLimit t\nZ : C\nk : Quiver.Hom Z t.pt\n‚ä¢ Eq (‚Üë((CategoryTheory.Limits.Trident.IsLimit.homIso ht Z) k)) (CategoryTheory.CategoryStruct.comp k t.Œπ)","decl":"/--\nGiven a limit cone for the family `f : J ‚Üí (X ‚ü∂ Y)`, for any `Z`, morphisms from `Z` to its point\nare in bijection with morphisms `h : Z ‚ü∂ X` such that `‚àÄ j‚ÇÅ j‚ÇÇ, h ‚â´ f j‚ÇÅ = h ‚â´ f j‚ÇÇ`.\nFurther, this bijection is natural in `Z`: see `Trident.Limits.homIso_natural`.\n-/\n@[simps]\ndef Trident.IsLimit.homIso [Nonempty J] {t : Trident f} (ht : IsLimit t) (Z : C) :\n    (Z ‚ü∂ t.pt) ‚âÉ { h : Z ‚ü∂ X // ‚àÄ j‚ÇÅ j‚ÇÇ, h ‚â´ f j‚ÇÅ = h ‚â´ f j‚ÇÇ } where\n  toFun k := ‚ü®k ‚â´ t.Œπ, by simp‚ü©\n  invFun h := (Trident.IsLimit.lift' ht _ h.prop).1\n  left_inv _ := Trident.IsLimit.hom_ext ht (Trident.IsLimit.lift' _ _ _).prop\n  right_inv _ := Subtype.ext (Trident.IsLimit.lift' ht _ _).prop\n\n"}
{"name":"CategoryTheory.Limits.Trident.IsLimit.homIso_symm_apply","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"J : Type w\nC : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : J ‚Üí Quiver.Hom X Y\ninst‚úù : Nonempty J\nt : CategoryTheory.Limits.Trident f\nht : CategoryTheory.Limits.IsLimit t\nZ : C\nh : Subtype fun h => ‚àÄ (j‚ÇÅ j‚ÇÇ : J), Eq (CategoryTheory.CategoryStruct.comp h (f j‚ÇÅ)) (CategoryTheory.CategoryStruct.comp h (f j‚ÇÇ))\n‚ä¢ Eq ((CategoryTheory.Limits.Trident.IsLimit.homIso ht Z).symm h) ‚Üë(CategoryTheory.Limits.Trident.IsLimit.lift' ht ‚Üëh ‚ãØ)","decl":"/--\nGiven a limit cone for the family `f : J ‚Üí (X ‚ü∂ Y)`, for any `Z`, morphisms from `Z` to its point\nare in bijection with morphisms `h : Z ‚ü∂ X` such that `‚àÄ j‚ÇÅ j‚ÇÇ, h ‚â´ f j‚ÇÅ = h ‚â´ f j‚ÇÇ`.\nFurther, this bijection is natural in `Z`: see `Trident.Limits.homIso_natural`.\n-/\n@[simps]\ndef Trident.IsLimit.homIso [Nonempty J] {t : Trident f} (ht : IsLimit t) (Z : C) :\n    (Z ‚ü∂ t.pt) ‚âÉ { h : Z ‚ü∂ X // ‚àÄ j‚ÇÅ j‚ÇÇ, h ‚â´ f j‚ÇÅ = h ‚â´ f j‚ÇÇ } where\n  toFun k := ‚ü®k ‚â´ t.Œπ, by simp‚ü©\n  invFun h := (Trident.IsLimit.lift' ht _ h.prop).1\n  left_inv _ := Trident.IsLimit.hom_ext ht (Trident.IsLimit.lift' _ _ _).prop\n  right_inv _ := Subtype.ext (Trident.IsLimit.lift' ht _ _).prop\n\n"}
{"name":"CategoryTheory.Limits.Trident.IsLimit.homIso_natural","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"J : Type w\nC : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : J ‚Üí Quiver.Hom X Y\ninst‚úù : Nonempty J\nt : CategoryTheory.Limits.Trident f\nht : CategoryTheory.Limits.IsLimit t\nZ Z' : C\nq : Quiver.Hom Z' Z\nk : Quiver.Hom Z t.pt\n‚ä¢ Eq (‚Üë((CategoryTheory.Limits.Trident.IsLimit.homIso ht Z') (CategoryTheory.CategoryStruct.comp q k))) (CategoryTheory.CategoryStruct.comp q ‚Üë((CategoryTheory.Limits.Trident.IsLimit.homIso ht Z) k))","decl":"/-- The bijection of `Trident.IsLimit.homIso` is natural in `Z`. -/\ntheorem Trident.IsLimit.homIso_natural [Nonempty J] {t : Trident f} (ht : IsLimit t) {Z Z' : C}\n    (q : Z' ‚ü∂ Z) (k : Z ‚ü∂ t.pt) :\n    (Trident.IsLimit.homIso ht _ (q ‚â´ k) : Z' ‚ü∂ X) =\n      q ‚â´ (Trident.IsLimit.homIso ht _ k : Z ‚ü∂ X) :=\n  Category.assoc _ _ _\n\n"}
{"name":"CategoryTheory.Limits.Cotrident.IsColimit.homIso_apply_coe","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"J : Type w\nC : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : J ‚Üí Quiver.Hom X Y\ninst‚úù : Nonempty J\nt : CategoryTheory.Limits.Cotrident f\nht : CategoryTheory.Limits.IsColimit t\nZ : C\nk : Quiver.Hom t.pt Z\n‚ä¢ Eq (‚Üë((CategoryTheory.Limits.Cotrident.IsColimit.homIso ht Z) k)) (CategoryTheory.CategoryStruct.comp t.œÄ k)","decl":"/-- Given a colimit cocone for the family `f : J ‚Üí (X ‚ü∂ Y)`, for any `Z`, morphisms from the cocone\npoint to `Z` are in bijection with morphisms `h : Z ‚ü∂ X` such that\n`‚àÄ j‚ÇÅ j‚ÇÇ, f j‚ÇÅ ‚â´ h = f j‚ÇÇ ‚â´ h`.  Further, this bijection is natural in `Z`: see\n`Cotrident.IsColimit.homIso_natural`.\n-/\n@[simps]\ndef Cotrident.IsColimit.homIso [Nonempty J] {t : Cotrident f} (ht : IsColimit t) (Z : C) :\n    (t.pt ‚ü∂ Z) ‚âÉ { h : Y ‚ü∂ Z // ‚àÄ j‚ÇÅ j‚ÇÇ, f j‚ÇÅ ‚â´ h = f j‚ÇÇ ‚â´ h } where\n  toFun k := ‚ü®t.œÄ ‚â´ k, by simp‚ü©\n  invFun h := (Cotrident.IsColimit.desc' ht _ h.prop).1\n  left_inv _ := Cotrident.IsColimit.hom_ext ht (Cotrident.IsColimit.desc' _ _ _).prop\n  right_inv _ := Subtype.ext (Cotrident.IsColimit.desc' ht _ _).prop\n\n"}
{"name":"CategoryTheory.Limits.Cotrident.IsColimit.homIso_symm_apply","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"J : Type w\nC : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : J ‚Üí Quiver.Hom X Y\ninst‚úù : Nonempty J\nt : CategoryTheory.Limits.Cotrident f\nht : CategoryTheory.Limits.IsColimit t\nZ : C\nh : Subtype fun h => ‚àÄ (j‚ÇÅ j‚ÇÇ : J), Eq (CategoryTheory.CategoryStruct.comp (f j‚ÇÅ) h) (CategoryTheory.CategoryStruct.comp (f j‚ÇÇ) h)\n‚ä¢ Eq ((CategoryTheory.Limits.Cotrident.IsColimit.homIso ht Z).symm h) ‚Üë(CategoryTheory.Limits.Cotrident.IsColimit.desc' ht ‚Üëh ‚ãØ)","decl":"/-- Given a colimit cocone for the family `f : J ‚Üí (X ‚ü∂ Y)`, for any `Z`, morphisms from the cocone\npoint to `Z` are in bijection with morphisms `h : Z ‚ü∂ X` such that\n`‚àÄ j‚ÇÅ j‚ÇÇ, f j‚ÇÅ ‚â´ h = f j‚ÇÇ ‚â´ h`.  Further, this bijection is natural in `Z`: see\n`Cotrident.IsColimit.homIso_natural`.\n-/\n@[simps]\ndef Cotrident.IsColimit.homIso [Nonempty J] {t : Cotrident f} (ht : IsColimit t) (Z : C) :\n    (t.pt ‚ü∂ Z) ‚âÉ { h : Y ‚ü∂ Z // ‚àÄ j‚ÇÅ j‚ÇÇ, f j‚ÇÅ ‚â´ h = f j‚ÇÇ ‚â´ h } where\n  toFun k := ‚ü®t.œÄ ‚â´ k, by simp‚ü©\n  invFun h := (Cotrident.IsColimit.desc' ht _ h.prop).1\n  left_inv _ := Cotrident.IsColimit.hom_ext ht (Cotrident.IsColimit.desc' _ _ _).prop\n  right_inv _ := Subtype.ext (Cotrident.IsColimit.desc' ht _ _).prop\n\n"}
{"name":"CategoryTheory.Limits.Cotrident.IsColimit.homIso_natural","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"J : Type w\nC : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : J ‚Üí Quiver.Hom X Y\ninst‚úù : Nonempty J\nt : CategoryTheory.Limits.Cotrident f\nZ Z' : C\nq : Quiver.Hom Z Z'\nht : CategoryTheory.Limits.IsColimit t\nk : Quiver.Hom t.pt Z\n‚ä¢ Eq (‚Üë((CategoryTheory.Limits.Cotrident.IsColimit.homIso ht Z') (CategoryTheory.CategoryStruct.comp k q))) (CategoryTheory.CategoryStruct.comp (‚Üë((CategoryTheory.Limits.Cotrident.IsColimit.homIso ht Z) k)) q)","decl":"/-- The bijection of `Cotrident.IsColimit.homIso` is natural in `Z`. -/\ntheorem Cotrident.IsColimit.homIso_natural [Nonempty J] {t : Cotrident f} {Z Z' : C} (q : Z ‚ü∂ Z')\n    (ht : IsColimit t) (k : t.pt ‚ü∂ Z) :\n    (Cotrident.IsColimit.homIso ht _ (k ‚â´ q) : Y ‚ü∂ Z') =\n      (Cotrident.IsColimit.homIso ht _ k : Y ‚ü∂ Z) ‚â´ q :=\n  (Category.assoc _ _ _).symm\n\n"}
{"name":"CategoryTheory.Limits.Cone.ofTrident_œÄ","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"J : Type w\nC : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (CategoryTheory.Limits.WalkingParallelFamily J) C\nt : CategoryTheory.Limits.Trident fun j => F.map (CategoryTheory.Limits.WalkingParallelFamily.Hom.line j)\nj : CategoryTheory.Limits.WalkingParallelFamily J\n‚ä¢ Eq ((CategoryTheory.Limits.Cone.ofTrident t).œÄ.app j) (CategoryTheory.CategoryStruct.comp (t.œÄ.app j) (CategoryTheory.eqToHom ‚ãØ))","decl":"@[simp]\ntheorem Cone.ofTrident_œÄ {F : WalkingParallelFamily J ‚•§ C} (t : Trident fun j => F.map (line j))\n    (j) : (Cone.ofTrident t).œÄ.app j = t.œÄ.app j ‚â´ eqToHom (by cases j <;> aesop_cat) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Cocone.ofCotrident_Œπ","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"J : Type w\nC : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (CategoryTheory.Limits.WalkingParallelFamily J) C\nt : CategoryTheory.Limits.Cotrident fun j => F.map (CategoryTheory.Limits.WalkingParallelFamily.Hom.line j)\nj : CategoryTheory.Limits.WalkingParallelFamily J\n‚ä¢ Eq ((CategoryTheory.Limits.Cocone.ofCotrident t).Œπ.app j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) (t.Œπ.app j))","decl":"@[simp]\ntheorem Cocone.ofCotrident_Œπ {F : WalkingParallelFamily J ‚•§ C}\n    (t : Cotrident fun j => F.map (line j)) (j) :\n    (Cocone.ofCotrident t).Œπ.app j = eqToHom (by cases j <;> aesop_cat) ‚â´ t.Œπ.app j :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Trident.ofCone_œÄ","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"J : Type w\nC : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (CategoryTheory.Limits.WalkingParallelFamily J) C\nt : CategoryTheory.Limits.Cone F\nj : CategoryTheory.Limits.WalkingParallelFamily J\n‚ä¢ Eq ((CategoryTheory.Limits.Trident.ofCone t).œÄ.app j) (CategoryTheory.CategoryStruct.comp (t.œÄ.app j) (CategoryTheory.eqToHom ‚ãØ))","decl":"@[simp]\ntheorem Trident.ofCone_œÄ {F : WalkingParallelFamily J ‚•§ C} (t : Cone F) (j) :\n    (Trident.ofCone t).œÄ.app j = t.œÄ.app j ‚â´ eqToHom (by cases j <;> aesop_cat) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Cotrident.ofCocone_Œπ","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"J : Type w\nC : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (CategoryTheory.Limits.WalkingParallelFamily J) C\nt : CategoryTheory.Limits.Cocone F\nj : CategoryTheory.Limits.WalkingParallelFamily J\n‚ä¢ Eq ((CategoryTheory.Limits.Cotrident.ofCocone t).Œπ.app j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) (t.Œπ.app j))","decl":"@[simp]\ntheorem Cotrident.ofCocone_Œπ {F : WalkingParallelFamily J ‚•§ C} (t : Cocone F) (j) :\n    (Cotrident.ofCocone t).Œπ.app j = eqToHom (by cases j <;> aesop_cat) ‚â´ t.Œπ.app j :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Trident.mkHom_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"J : Type w\nC : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : J ‚Üí Quiver.Hom X Y\ninst‚úù : Nonempty J\ns t : CategoryTheory.Limits.Trident f\nk : Quiver.Hom s.pt t.pt\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp k t.Œπ) s.Œπ) _auto‚úù\n‚ä¢ Eq (CategoryTheory.Limits.Trident.mkHom k w).hom k","decl":"/-- Helper function for constructing morphisms between wide equalizer tridents.\n-/\n@[simps]\ndef Trident.mkHom [Nonempty J] {s t : Trident f} (k : s.pt ‚ü∂ t.pt)\n    (w : k ‚â´ t.Œπ = s.Œπ := by aesop_cat) : s ‚ü∂ t where\n  hom := k\n  w := by\n    rintro ‚ü®_ | _‚ü©\n    ¬∑ exact w\n    ¬∑ simpa using w =‚â´ f (Classical.arbitrary J)\n\n"}
{"name":"CategoryTheory.Limits.Trident.ext_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"J : Type w\nC : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : J ‚Üí Quiver.Hom X Y\ninst‚úù : Nonempty J\ns t : CategoryTheory.Limits.Trident f\ni : CategoryTheory.Iso s.pt t.pt\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp i.hom t.Œπ) s.Œπ) _auto‚úù\n‚ä¢ Eq (CategoryTheory.Limits.Trident.ext i w).inv (CategoryTheory.Limits.Trident.mkHom i.inv ‚ãØ)","decl":"/-- To construct an isomorphism between tridents,\nit suffices to give an isomorphism between the cone points\nand check that it commutes with the `Œπ` morphisms.\n-/\n@[simps]\ndef Trident.ext [Nonempty J] {s t : Trident f} (i : s.pt ‚âÖ t.pt)\n    (w : i.hom ‚â´ t.Œπ = s.Œπ := by aesop_cat) : s ‚âÖ t where\n  hom := Trident.mkHom i.hom w\n  inv := Trident.mkHom i.inv (by rw [‚Üê w, Iso.inv_hom_id_assoc])\n\n"}
{"name":"CategoryTheory.Limits.Trident.ext_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"J : Type w\nC : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : J ‚Üí Quiver.Hom X Y\ninst‚úù : Nonempty J\ns t : CategoryTheory.Limits.Trident f\ni : CategoryTheory.Iso s.pt t.pt\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp i.hom t.Œπ) s.Œπ) _auto‚úù\n‚ä¢ Eq (CategoryTheory.Limits.Trident.ext i w).hom (CategoryTheory.Limits.Trident.mkHom i.hom w)","decl":"/-- To construct an isomorphism between tridents,\nit suffices to give an isomorphism between the cone points\nand check that it commutes with the `Œπ` morphisms.\n-/\n@[simps]\ndef Trident.ext [Nonempty J] {s t : Trident f} (i : s.pt ‚âÖ t.pt)\n    (w : i.hom ‚â´ t.Œπ = s.Œπ := by aesop_cat) : s ‚âÖ t where\n  hom := Trident.mkHom i.hom w\n  inv := Trident.mkHom i.inv (by rw [‚Üê w, Iso.inv_hom_id_assoc])\n\n"}
{"name":"CategoryTheory.Limits.Cotrident.mkHom_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"J : Type w\nC : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : J ‚Üí Quiver.Hom X Y\ninst‚úù : Nonempty J\ns t : CategoryTheory.Limits.Cotrident f\nk : Quiver.Hom s.pt t.pt\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp s.œÄ k) t.œÄ) _auto‚úù\n‚ä¢ Eq (CategoryTheory.Limits.Cotrident.mkHom k w).hom k","decl":"/-- Helper function for constructing morphisms between coequalizer cotridents.\n-/\n@[simps]\ndef Cotrident.mkHom [Nonempty J] {s t : Cotrident f} (k : s.pt ‚ü∂ t.pt)\n    (w : s.œÄ ‚â´ k = t.œÄ := by aesop_cat) : s ‚ü∂ t where\n  hom := k\n  w := by\n    rintro ‚ü®_ | _‚ü©\n    ¬∑ simpa using f (Classical.arbitrary J) ‚â´= w\n    ¬∑ exact w\n\n"}
{"name":"CategoryTheory.Limits.wideEqualizer.trident_Œπ","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"J : Type w\nC : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : J ‚Üí Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasWideEqualizer f\n‚ä¢ Eq (CategoryTheory.Limits.wideEqualizer.trident f).Œπ (CategoryTheory.Limits.wideEqualizer.Œπ f)","decl":"theorem wideEqualizer.trident_Œπ : (wideEqualizer.trident f).Œπ = wideEqualizer.Œπ f :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.wideEqualizer.trident_œÄ_app_zero","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"J : Type w\nC : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : J ‚Üí Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasWideEqualizer f\n‚ä¢ Eq ((CategoryTheory.Limits.wideEqualizer.trident f).œÄ.app CategoryTheory.Limits.WalkingParallelFamily.zero) (CategoryTheory.Limits.wideEqualizer.Œπ f)","decl":"theorem wideEqualizer.trident_œÄ_app_zero :\n    (wideEqualizer.trident f).œÄ.app zero = wideEqualizer.Œπ f :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.wideEqualizer.condition","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"J : Type w\nC : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : J ‚Üí Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasWideEqualizer f\nj‚ÇÅ j‚ÇÇ : J\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.wideEqualizer.Œπ f) (f j‚ÇÅ)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.wideEqualizer.Œπ f) (f j‚ÇÇ))","decl":"@[reassoc]\ntheorem wideEqualizer.condition (j‚ÇÅ j‚ÇÇ : J) : wideEqualizer.Œπ f ‚â´ f j‚ÇÅ = wideEqualizer.Œπ f ‚â´ f j‚ÇÇ :=\n  Trident.condition j‚ÇÅ j‚ÇÇ <| limit.cone <| parallelFamily f\n\n"}
{"name":"CategoryTheory.Limits.wideEqualizer.condition_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"J : Type w\nC : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : J ‚Üí Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasWideEqualizer f\nj‚ÇÅ j‚ÇÇ : J\nZ : C\nh : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.wideEqualizer.Œπ f) (CategoryTheory.CategoryStruct.comp (f j‚ÇÅ) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.wideEqualizer.Œπ f) (CategoryTheory.CategoryStruct.comp (f j‚ÇÇ) h))","decl":"@[reassoc]\ntheorem wideEqualizer.condition (j‚ÇÅ j‚ÇÇ : J) : wideEqualizer.Œπ f ‚â´ f j‚ÇÅ = wideEqualizer.Œπ f ‚â´ f j‚ÇÇ :=\n  Trident.condition j‚ÇÅ j‚ÇÇ <| limit.cone <| parallelFamily f\n\n"}
{"name":"CategoryTheory.Limits.wideEqualizer.lift_Œπ_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"J : Type w\nC : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : J ‚Üí Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasWideEqualizer f\ninst‚úù : Nonempty J\nW : C\nk : Quiver.Hom W X\nh‚úù : ‚àÄ (j‚ÇÅ j‚ÇÇ : J), Eq (CategoryTheory.CategoryStruct.comp k (f j‚ÇÅ)) (CategoryTheory.CategoryStruct.comp k (f j‚ÇÇ))\nZ : C\nh : Quiver.Hom X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.wideEqualizer.lift k h‚úù) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.wideEqualizer.Œπ f) h)) (CategoryTheory.CategoryStruct.comp k h)","decl":"@[reassoc]\ntheorem wideEqualizer.lift_Œπ [Nonempty J] {W : C} (k : W ‚ü∂ X)\n    (h : ‚àÄ j‚ÇÅ j‚ÇÇ, k ‚â´ f j‚ÇÅ = k ‚â´ f j‚ÇÇ) :\n    wideEqualizer.lift k h ‚â´ wideEqualizer.Œπ f = k := by\n  simp\n\n"}
{"name":"CategoryTheory.Limits.wideEqualizer.lift_Œπ","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"J : Type w\nC : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : J ‚Üí Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasWideEqualizer f\ninst‚úù : Nonempty J\nW : C\nk : Quiver.Hom W X\nh : ‚àÄ (j‚ÇÅ j‚ÇÇ : J), Eq (CategoryTheory.CategoryStruct.comp k (f j‚ÇÅ)) (CategoryTheory.CategoryStruct.comp k (f j‚ÇÇ))\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.wideEqualizer.lift k h) (CategoryTheory.Limits.wideEqualizer.Œπ f)) k","decl":"@[reassoc]\ntheorem wideEqualizer.lift_Œπ [Nonempty J] {W : C} (k : W ‚ü∂ X)\n    (h : ‚àÄ j‚ÇÅ j‚ÇÇ, k ‚â´ f j‚ÇÅ = k ‚â´ f j‚ÇÇ) :\n    wideEqualizer.lift k h ‚â´ wideEqualizer.Œπ f = k := by\n  simp\n\n"}
{"name":"CategoryTheory.Limits.wideEqualizer.hom_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"J : Type w\nC : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : J ‚Üí Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasWideEqualizer f\ninst‚úù : Nonempty J\nW : C\nk l : Quiver.Hom W (CategoryTheory.Limits.wideEqualizer f)\nh : Eq (CategoryTheory.CategoryStruct.comp k (CategoryTheory.Limits.wideEqualizer.Œπ f)) (CategoryTheory.CategoryStruct.comp l (CategoryTheory.Limits.wideEqualizer.Œπ f))\n‚ä¢ Eq k l","decl":"/-- Two maps into a wide equalizer are equal if they are equal when composed with the wide\n    equalizer map. -/\n@[ext]\ntheorem wideEqualizer.hom_ext [Nonempty J] {W : C} {k l : W ‚ü∂ wideEqualizer f}\n    (h : k ‚â´ wideEqualizer.Œπ f = l ‚â´ wideEqualizer.Œπ f) : k = l :=\n  Trident.IsLimit.hom_ext (limit.isLimit _) h\n\n"}
{"name":"CategoryTheory.Limits.wideEqualizer.hom_ext_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"J : Type w\nC : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : J ‚Üí Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasWideEqualizer f\ninst‚úù : Nonempty J\nW : C\nk l : Quiver.Hom W (CategoryTheory.Limits.wideEqualizer f)\n‚ä¢ Iff (Eq k l) (Eq (CategoryTheory.CategoryStruct.comp k (CategoryTheory.Limits.wideEqualizer.Œπ f)) (CategoryTheory.CategoryStruct.comp l (CategoryTheory.Limits.wideEqualizer.Œπ f)))","decl":"/-- Two maps into a wide equalizer are equal if they are equal when composed with the wide\n    equalizer map. -/\n@[ext]\ntheorem wideEqualizer.hom_ext [Nonempty J] {W : C} {k l : W ‚ü∂ wideEqualizer f}\n    (h : k ‚â´ wideEqualizer.Œπ f = l ‚â´ wideEqualizer.Œπ f) : k = l :=\n  Trident.IsLimit.hom_ext (limit.isLimit _) h\n\n"}
{"name":"CategoryTheory.Limits.wideEqualizer.Œπ_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"J : Type w\nC : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : J ‚Üí Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasWideEqualizer f\ninst‚úù : Nonempty J\n‚ä¢ CategoryTheory.Mono (CategoryTheory.Limits.wideEqualizer.Œπ f)","decl":"/-- A wide equalizer morphism is a monomorphism -/\ninstance wideEqualizer.Œπ_mono [Nonempty J] : Mono (wideEqualizer.Œπ f) where\n  right_cancellation _ _ w := wideEqualizer.hom_ext w\n\n"}
{"name":"CategoryTheory.Limits.mono_of_isLimit_parallelFamily","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"J : Type w\nC : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : J ‚Üí Quiver.Hom X Y\ninst‚úù : Nonempty J\nc : CategoryTheory.Limits.Cone (CategoryTheory.Limits.parallelFamily f)\ni : CategoryTheory.Limits.IsLimit c\n‚ä¢ CategoryTheory.Mono (CategoryTheory.Limits.Trident.Œπ c)","decl":"/-- The wide equalizer morphism in any limit cone is a monomorphism. -/\ntheorem mono_of_isLimit_parallelFamily [Nonempty J] {c : Cone (parallelFamily f)} (i : IsLimit c) :\n    Mono (Trident.Œπ c) where\n  right_cancellation _ _ w := Trident.IsLimit.hom_ext i w\n\n"}
{"name":"CategoryTheory.Limits.wideCoequalizer.cotrident_œÄ","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"J : Type w\nC : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : J ‚Üí Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasWideCoequalizer f\n‚ä¢ Eq (CategoryTheory.Limits.wideCoequalizer.cotrident f).œÄ (CategoryTheory.Limits.wideCoequalizer.œÄ f)","decl":"theorem wideCoequalizer.cotrident_œÄ : (wideCoequalizer.cotrident f).œÄ = wideCoequalizer.œÄ f :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.wideCoequalizer.cotrident_Œπ_app_one","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"J : Type w\nC : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : J ‚Üí Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasWideCoequalizer f\n‚ä¢ Eq ((CategoryTheory.Limits.wideCoequalizer.cotrident f).Œπ.app CategoryTheory.Limits.WalkingParallelFamily.one) (CategoryTheory.Limits.wideCoequalizer.œÄ f)","decl":"theorem wideCoequalizer.cotrident_Œπ_app_one :\n    (wideCoequalizer.cotrident f).Œπ.app one = wideCoequalizer.œÄ f :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.wideCoequalizer.condition","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"J : Type w\nC : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : J ‚Üí Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasWideCoequalizer f\nj‚ÇÅ j‚ÇÇ : J\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (f j‚ÇÅ) (CategoryTheory.Limits.wideCoequalizer.œÄ f)) (CategoryTheory.CategoryStruct.comp (f j‚ÇÇ) (CategoryTheory.Limits.wideCoequalizer.œÄ f))","decl":"@[reassoc]\ntheorem wideCoequalizer.condition (j‚ÇÅ j‚ÇÇ : J) :\n    f j‚ÇÅ ‚â´ wideCoequalizer.œÄ f = f j‚ÇÇ ‚â´ wideCoequalizer.œÄ f :=\n  Cotrident.condition j‚ÇÅ j‚ÇÇ <| colimit.cocone <| parallelFamily f\n\n"}
{"name":"CategoryTheory.Limits.wideCoequalizer.condition_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"J : Type w\nC : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : J ‚Üí Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasWideCoequalizer f\nj‚ÇÅ j‚ÇÇ : J\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.wideCoequalizer f) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (f j‚ÇÅ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.wideCoequalizer.œÄ f) h)) (CategoryTheory.CategoryStruct.comp (f j‚ÇÇ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.wideCoequalizer.œÄ f) h))","decl":"@[reassoc]\ntheorem wideCoequalizer.condition (j‚ÇÅ j‚ÇÇ : J) :\n    f j‚ÇÅ ‚â´ wideCoequalizer.œÄ f = f j‚ÇÇ ‚â´ wideCoequalizer.œÄ f :=\n  Cotrident.condition j‚ÇÅ j‚ÇÇ <| colimit.cocone <| parallelFamily f\n\n"}
{"name":"CategoryTheory.Limits.wideCoequalizer.œÄ_desc_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"J : Type w\nC : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : J ‚Üí Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasWideCoequalizer f\ninst‚úù : Nonempty J\nW : C\nk : Quiver.Hom Y W\nh‚úù : ‚àÄ (j‚ÇÅ j‚ÇÇ : J), Eq (CategoryTheory.CategoryStruct.comp (f j‚ÇÅ) k) (CategoryTheory.CategoryStruct.comp (f j‚ÇÇ) k)\nZ : C\nh : Quiver.Hom W Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.wideCoequalizer.œÄ f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.wideCoequalizer.desc k h‚úù) h)) (CategoryTheory.CategoryStruct.comp k h)","decl":"@[reassoc]\ntheorem wideCoequalizer.œÄ_desc [Nonempty J] {W : C} (k : Y ‚ü∂ W)\n    (h : ‚àÄ j‚ÇÅ j‚ÇÇ, f j‚ÇÅ ‚â´ k = f j‚ÇÇ ‚â´ k) :\n    wideCoequalizer.œÄ f ‚â´ wideCoequalizer.desc k h = k := by\n  simp\n\n"}
{"name":"CategoryTheory.Limits.wideCoequalizer.œÄ_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"J : Type w\nC : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : J ‚Üí Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasWideCoequalizer f\ninst‚úù : Nonempty J\nW : C\nk : Quiver.Hom Y W\nh : ‚àÄ (j‚ÇÅ j‚ÇÇ : J), Eq (CategoryTheory.CategoryStruct.comp (f j‚ÇÅ) k) (CategoryTheory.CategoryStruct.comp (f j‚ÇÇ) k)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.wideCoequalizer.œÄ f) (CategoryTheory.Limits.wideCoequalizer.desc k h)) k","decl":"@[reassoc]\ntheorem wideCoequalizer.œÄ_desc [Nonempty J] {W : C} (k : Y ‚ü∂ W)\n    (h : ‚àÄ j‚ÇÅ j‚ÇÇ, f j‚ÇÅ ‚â´ k = f j‚ÇÇ ‚â´ k) :\n    wideCoequalizer.œÄ f ‚â´ wideCoequalizer.desc k h = k := by\n  simp\n\n"}
{"name":"CategoryTheory.Limits.wideCoequalizer.hom_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"J : Type w\nC : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : J ‚Üí Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasWideCoequalizer f\ninst‚úù : Nonempty J\nW : C\nk l : Quiver.Hom (CategoryTheory.Limits.wideCoequalizer f) W\nh : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.wideCoequalizer.œÄ f) k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.wideCoequalizer.œÄ f) l)\n‚ä¢ Eq k l","decl":"/-- Two maps from a wide coequalizer are equal if they are equal when composed with the wide\n    coequalizer map -/\n@[ext]\ntheorem wideCoequalizer.hom_ext [Nonempty J] {W : C} {k l : wideCoequalizer f ‚ü∂ W}\n    (h : wideCoequalizer.œÄ f ‚â´ k = wideCoequalizer.œÄ f ‚â´ l) : k = l :=\n  Cotrident.IsColimit.hom_ext (colimit.isColimit _) h\n\n"}
{"name":"CategoryTheory.Limits.wideCoequalizer.hom_ext_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"J : Type w\nC : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : J ‚Üí Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasWideCoequalizer f\ninst‚úù : Nonempty J\nW : C\nk l : Quiver.Hom (CategoryTheory.Limits.wideCoequalizer f) W\n‚ä¢ Iff (Eq k l) (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.wideCoequalizer.œÄ f) k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.wideCoequalizer.œÄ f) l))","decl":"/-- Two maps from a wide coequalizer are equal if they are equal when composed with the wide\n    coequalizer map -/\n@[ext]\ntheorem wideCoequalizer.hom_ext [Nonempty J] {W : C} {k l : wideCoequalizer f ‚ü∂ W}\n    (h : wideCoequalizer.œÄ f ‚â´ k = wideCoequalizer.œÄ f ‚â´ l) : k = l :=\n  Cotrident.IsColimit.hom_ext (colimit.isColimit _) h\n\n"}
{"name":"CategoryTheory.Limits.wideCoequalizer.œÄ_epi","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"J : Type w\nC : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : J ‚Üí Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasWideCoequalizer f\ninst‚úù : Nonempty J\n‚ä¢ CategoryTheory.Epi (CategoryTheory.Limits.wideCoequalizer.œÄ f)","decl":"/-- A wide coequalizer morphism is an epimorphism -/\ninstance wideCoequalizer.œÄ_epi [Nonempty J] : Epi (wideCoequalizer.œÄ f) where\n  left_cancellation _ _ w := wideCoequalizer.hom_ext w\n\n"}
{"name":"CategoryTheory.Limits.epi_of_isColimit_parallelFamily","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"J : Type w\nC : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : J ‚Üí Quiver.Hom X Y\ninst‚úù : Nonempty J\nc : CategoryTheory.Limits.Cocone (CategoryTheory.Limits.parallelFamily f)\ni : CategoryTheory.Limits.IsColimit c\n‚ä¢ CategoryTheory.Epi (c.Œπ.app CategoryTheory.Limits.WalkingParallelFamily.one)","decl":"/-- The wide coequalizer morphism in any colimit cocone is an epimorphism. -/\ntheorem epi_of_isColimit_parallelFamily [Nonempty J] {c : Cocone (parallelFamily f)}\n    (i : IsColimit c) : Epi (c.Œπ.app one) where\n  left_cancellation _ _ w := Cotrident.IsColimit.hom_ext i w\n\n"}
{"name":"CategoryTheory.Limits.hasWideEqualizers_of_hasLimit_parallelFamily","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : ‚àÄ {J : Type w} {X Y : C} {f : J ‚Üí Quiver.Hom X Y}, CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.parallelFamily f)\n‚ä¢ CategoryTheory.Limits.HasWideEqualizers C","decl":"/-- If `C` has all limits of diagrams `parallelFamily f`, then it has all wide equalizers -/\ntheorem hasWideEqualizers_of_hasLimit_parallelFamily\n    [‚àÄ {J : Type w} {X Y : C} {f : J ‚Üí (X ‚ü∂ Y)}, HasLimit (parallelFamily f)] :\n    HasWideEqualizers.{w} C := fun _ =>\n  { has_limit := fun F => hasLimitOfIso (diagramIsoParallelFamily F).symm }\n\n"}
{"name":"CategoryTheory.Limits.hasWideCoequalizers_of_hasColimit_parallelFamily","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : ‚àÄ {J : Type w} {X Y : C} {f : J ‚Üí Quiver.Hom X Y}, CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.parallelFamily f)\n‚ä¢ CategoryTheory.Limits.HasWideCoequalizers C","decl":"/-- If `C` has all colimits of diagrams `parallelFamily f`, then it has all wide coequalizers -/\ntheorem hasWideCoequalizers_of_hasColimit_parallelFamily\n    [‚àÄ {J : Type w} {X Y : C} {f : J ‚Üí (X ‚ü∂ Y)}, HasColimit (parallelFamily f)] :\n    HasWideCoequalizers.{w} C := fun _ =>\n  { has_colimit := fun F => hasColimitOfIso (diagramIsoParallelFamily F) }\n\n"}
{"name":"CategoryTheory.Limits.hasEqualizers_of_hasWideEqualizers","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasWideEqualizers C\n‚ä¢ CategoryTheory.Limits.HasEqualizers C","decl":"instance (priority := 10) hasEqualizers_of_hasWideEqualizers [HasWideEqualizers.{w} C] :\n    HasEqualizers C :=\n  hasLimitsOfShape_of_equivalence.{w} walkingParallelFamilyEquivWalkingParallelPair\n\n"}
{"name":"CategoryTheory.Limits.hasCoequalizers_of_hasWideCoequalizers","module":"Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasWideCoequalizers C\n‚ä¢ CategoryTheory.Limits.HasCoequalizers C","decl":"instance (priority := 10) hasCoequalizers_of_hasWideCoequalizers [HasWideCoequalizers.{w} C] :\n    HasCoequalizers C :=\n  hasColimitsOfShape_of_equivalence.{w} walkingParallelFamilyEquivWalkingParallelPair\n\n"}
