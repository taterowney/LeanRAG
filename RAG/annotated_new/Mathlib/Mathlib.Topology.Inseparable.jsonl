{"name":"specializes_TFAE","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\n‚ä¢ (List.cons (Specializes x y) (List.cons (LE.le (Pure.pure x) (nhds y)) (List.cons (‚àÄ (s : Set X), IsOpen s ‚Üí Membership.mem s y ‚Üí Membership.mem s x) (List.cons (‚àÄ (s : Set X), IsClosed s ‚Üí Membership.mem s x ‚Üí Membership.mem s y) (List.cons (Membership.mem (closure (Singleton.singleton x)) y) (List.cons (HasSubset.Subset (closure (Singleton.singleton y)) (closure (Singleton.singleton x))) (List.cons (ClusterPt y (Pure.pure x)) List.nil))))))).TFAE","decl":"/-- A collection of equivalent definitions of `x ‚§≥ y`. The public API is given by `iff` lemmas\nbelow. -/\ntheorem specializes_TFAE (x y : X) :\n    TFAE [x ‚§≥ y,\n      pure x ‚â§ ùìù y,\n      ‚àÄ s : Set X , IsOpen s ‚Üí y ‚àà s ‚Üí x ‚àà s,\n      ‚àÄ s : Set X , IsClosed s ‚Üí x ‚àà s ‚Üí y ‚àà s,\n      y ‚àà closure ({ x } : Set X),\n      closure ({ y } : Set X) ‚äÜ closure { x },\n      ClusterPt y (pure x)] := by\n  tfae_have 1 ‚Üí 2 := (pure_le_nhds _).trans\n  tfae_have 2 ‚Üí 3 := fun h s hso hy => h (hso.mem_nhds hy)\n  tfae_have 3 ‚Üí 4 := fun h s hsc hx => of_not_not fun hy => h s·∂ú hsc.isOpen_compl hy hx\n  tfae_have 4 ‚Üí 5 := fun h => h _ isClosed_closure (subset_closure <| mem_singleton _)\n  tfae_have 6 ‚Üî 5 := isClosed_closure.closure_subset_iff.trans singleton_subset_iff\n  tfae_have 5 ‚Üî 7 := by\n    rw [mem_closure_iff_clusterPt, principal_singleton]\n  tfae_have 5 ‚Üí 1 := by\n    refine fun h => (nhds_basis_opens _).ge_iff.2 ?_\n    rintro s ‚ü®hy, ho‚ü©\n    rcases mem_closure_iff.1 h s ho hy with ‚ü®z, hxs, rfl : z = x‚ü©\n    exact ho.mem_nhds hxs\n  tfae_finish\n\n"}
{"name":"specializes_iff_nhds","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\n‚ä¢ Iff (Specializes x y) (LE.le (nhds x) (nhds y))","decl":"theorem specializes_iff_nhds : x ‚§≥ y ‚Üî ùìù x ‚â§ ùìù y :=\n  Iff.rfl\n\n"}
{"name":"Specializes.not_disjoint","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\nh : Specializes x y\n‚ä¢ Not (Disjoint (nhds x) (nhds y))","decl":"theorem Specializes.not_disjoint (h : x ‚§≥ y) : ¬¨Disjoint (ùìù x) (ùìù y) := fun hd ‚Ü¶\n  absurd (hd.mono_right h) <| by simp [NeBot.ne']\n\n"}
{"name":"specializes_iff_pure","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\n‚ä¢ Iff (Specializes x y) (LE.le (Pure.pure x) (nhds y))","decl":"theorem specializes_iff_pure : x ‚§≥ y ‚Üî pure x ‚â§ ùìù y :=\n  (specializes_TFAE x y).out 0 1\n\n"}
{"name":"Specializes.nhds_le_nhds","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\na‚úù : Specializes x y\n‚ä¢ LE.le (nhds x) (nhds y)","decl":"alias ‚ü®Specializes.nhds_le_nhds, _‚ü© := specializes_iff_nhds\n\n"}
{"name":"Specializes.pure_le_nhds","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\na‚úù : Specializes x y\n‚ä¢ LE.le (Pure.pure x) (nhds y)","decl":"alias ‚ü®Specializes.pure_le_nhds, _‚ü© := specializes_iff_pure\n\n"}
{"name":"ker_nhds_eq_specializes","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx : X\n‚ä¢ Eq (nhds x).ker (setOf fun y => Specializes y x)","decl":"theorem ker_nhds_eq_specializes : (ùìù x).ker = {y | y ‚§≥ x} := by\n  ext; simp [specializes_iff_pure, le_def]\n\n"}
{"name":"specializes_iff_forall_open","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\n‚ä¢ Iff (Specializes x y) (‚àÄ (s : Set X), IsOpen s ‚Üí Membership.mem s y ‚Üí Membership.mem s x)","decl":"theorem specializes_iff_forall_open : x ‚§≥ y ‚Üî ‚àÄ s : Set X, IsOpen s ‚Üí y ‚àà s ‚Üí x ‚àà s :=\n  (specializes_TFAE x y).out 0 2\n\n"}
{"name":"Specializes.mem_open","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\ns : Set X\nh : Specializes x y\nhs : IsOpen s\nhy : Membership.mem s y\n‚ä¢ Membership.mem s x","decl":"theorem Specializes.mem_open (h : x ‚§≥ y) (hs : IsOpen s) (hy : y ‚àà s) : x ‚àà s :=\n  specializes_iff_forall_open.1 h s hs hy\n\n"}
{"name":"IsOpen.not_specializes","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\ns : Set X\nhs : IsOpen s\nhx : Not (Membership.mem s x)\nhy : Membership.mem s y\n‚ä¢ Not (Specializes x y)","decl":"theorem IsOpen.not_specializes (hs : IsOpen s) (hx : x ‚àâ s) (hy : y ‚àà s) : ¬¨x ‚§≥ y := fun h =>\n  hx <| h.mem_open hs hy\n\n"}
{"name":"specializes_iff_forall_closed","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\n‚ä¢ Iff (Specializes x y) (‚àÄ (s : Set X), IsClosed s ‚Üí Membership.mem s x ‚Üí Membership.mem s y)","decl":"theorem specializes_iff_forall_closed : x ‚§≥ y ‚Üî ‚àÄ s : Set X, IsClosed s ‚Üí x ‚àà s ‚Üí y ‚àà s :=\n  (specializes_TFAE x y).out 0 3\n\n"}
{"name":"Specializes.mem_closed","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\ns : Set X\nh : Specializes x y\nhs : IsClosed s\nhx : Membership.mem s x\n‚ä¢ Membership.mem s y","decl":"theorem Specializes.mem_closed (h : x ‚§≥ y) (hs : IsClosed s) (hx : x ‚àà s) : y ‚àà s :=\n  specializes_iff_forall_closed.1 h s hs hx\n\n"}
{"name":"IsClosed.not_specializes","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\ns : Set X\nhs : IsClosed s\nhx : Membership.mem s x\nhy : Not (Membership.mem s y)\n‚ä¢ Not (Specializes x y)","decl":"theorem IsClosed.not_specializes (hs : IsClosed s) (hx : x ‚àà s) (hy : y ‚àâ s) : ¬¨x ‚§≥ y := fun h =>\n  hy <| h.mem_closed hs hx\n\n"}
{"name":"specializes_iff_mem_closure","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\n‚ä¢ Iff (Specializes x y) (Membership.mem (closure (Singleton.singleton x)) y)","decl":"theorem specializes_iff_mem_closure : x ‚§≥ y ‚Üî y ‚àà closure ({x} : Set X) :=\n  (specializes_TFAE x y).out 0 4\n\n"}
{"name":"Specializes.mem_closure","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\na‚úù : Specializes x y\n‚ä¢ Membership.mem (closure (Singleton.singleton x)) y","decl":"alias ‚ü®Specializes.mem_closure, _‚ü© := specializes_iff_mem_closure\n\n"}
{"name":"specializes_iff_closure_subset","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\n‚ä¢ Iff (Specializes x y) (HasSubset.Subset (closure (Singleton.singleton y)) (closure (Singleton.singleton x)))","decl":"theorem specializes_iff_closure_subset : x ‚§≥ y ‚Üî closure ({y} : Set X) ‚äÜ closure {x} :=\n  (specializes_TFAE x y).out 0 5\n\n"}
{"name":"Specializes.closure_subset","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\na‚úù : Specializes x y\n‚ä¢ HasSubset.Subset (closure (Singleton.singleton y)) (closure (Singleton.singleton x))","decl":"alias ‚ü®Specializes.closure_subset, _‚ü© := specializes_iff_closure_subset\n\n"}
{"name":"specializes_iff_clusterPt","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\n‚ä¢ Iff (Specializes x y) (ClusterPt y (Pure.pure x))","decl":"theorem specializes_iff_clusterPt : x ‚§≥ y ‚Üî ClusterPt y (pure x) :=\n  (specializes_TFAE x y).out 0 6\n\n"}
{"name":"Filter.HasBasis.specializes_iff","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\nŒπ : Sort u_7\np : Œπ ‚Üí Prop\ns : Œπ ‚Üí Set X\nh : (nhds y).HasBasis p s\n‚ä¢ Iff (Specializes x y) (‚àÄ (i : Œπ), p i ‚Üí Membership.mem (s i) x)","decl":"theorem Filter.HasBasis.specializes_iff {Œπ} {p : Œπ ‚Üí Prop} {s : Œπ ‚Üí Set X}\n    (h : (ùìù y).HasBasis p s) : x ‚§≥ y ‚Üî ‚àÄ i, p i ‚Üí x ‚àà s i :=\n  specializes_iff_pure.trans h.ge_iff\n\n"}
{"name":"specializes_rfl","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx : X\n‚ä¢ Specializes x x","decl":"theorem specializes_rfl : x ‚§≥ x := le_rfl\n\n"}
{"name":"specializes_refl","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx : X\n‚ä¢ Specializes x x","decl":"@[refl]\ntheorem specializes_refl (x : X) : x ‚§≥ x :=\n  specializes_rfl\n\n"}
{"name":"Specializes.trans","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y z : X\na‚úù¬π : Specializes x y\na‚úù : Specializes y z\n‚ä¢ Specializes x z","decl":"@[trans]\ntheorem Specializes.trans : x ‚§≥ y ‚Üí y ‚§≥ z ‚Üí x ‚§≥ z :=\n  le_trans\n\n"}
{"name":"specializes_of_eq","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\ne : Eq x y\n‚ä¢ Specializes x y","decl":"theorem specializes_of_eq (e : x = y) : x ‚§≥ y :=\n  e ‚ñ∏ specializes_refl x\n\n"}
{"name":"Specializes.of_eq","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\ne : Eq x y\n‚ä¢ Specializes x y","decl":"alias Specializes.of_eq := specializes_of_eq\n\n"}
{"name":"specializes_of_nhdsWithin","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\ns : Set X\nh‚ÇÅ : LE.le (nhdsWithin x s) (nhdsWithin y s)\nh‚ÇÇ : Membership.mem s x\n‚ä¢ Specializes x y","decl":"theorem specializes_of_nhdsWithin (h‚ÇÅ : ùìù[s] x ‚â§ ùìù[s] y) (h‚ÇÇ : x ‚àà s) : x ‚§≥ y :=\n  specializes_iff_pure.2 <|\n    calc\n      pure x ‚â§ ùìù[s] x := le_inf (pure_le_nhds _) (le_principal_iff.2 h‚ÇÇ)\n      _ ‚â§ ùìù[s] y := h‚ÇÅ\n      _ ‚â§ ùìù y := inf_le_left\n\n"}
{"name":"Specializes.map_of_continuousAt","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nx y : X\nf : X ‚Üí Y\nh : Specializes x y\nhy : ContinuousAt f y\n‚ä¢ Specializes (f x) (f y)","decl":"theorem Specializes.map_of_continuousAt (h : x ‚§≥ y) (hy : ContinuousAt f y) : f x ‚§≥ f y :=\n  specializes_iff_pure.2 fun _s hs =>\n    mem_pure.2 <| mem_preimage.1 <| mem_of_mem_nhds <| hy.mono_left h hs\n\n"}
{"name":"Specializes.map","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nx y : X\nf : X ‚Üí Y\nh : Specializes x y\nhf : Continuous f\n‚ä¢ Specializes (f x) (f y)","decl":"theorem Specializes.map (h : x ‚§≥ y) (hf : Continuous f) : f x ‚§≥ f y :=\n  h.map_of_continuousAt hf.continuousAt\n\n"}
{"name":"Topology.IsInducing.specializes_iff","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nx y : X\nf : X ‚Üí Y\nhf : Topology.IsInducing f\n‚ä¢ Iff (Specializes (f x) (f y)) (Specializes x y)","decl":"theorem Topology.IsInducing.specializes_iff (hf : IsInducing f) : f x ‚§≥ f y ‚Üî x ‚§≥ y := by\n  simp only [specializes_iff_mem_closure, hf.closure_eq_preimage_closure_image, image_singleton,\n    mem_preimage]\n\n"}
{"name":"Inducing.specializes_iff","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nx y : X\nf : X ‚Üí Y\nhf : Topology.IsInducing f\n‚ä¢ Iff (Specializes (f x) (f y)) (Specializes x y)","decl":"@[deprecated (since := \"2024-10-28\")] alias Inducing.specializes_iff := IsInducing.specializes_iff\n\n"}
{"name":"subtype_specializes_iff","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\np : X ‚Üí Prop\nx y : Subtype p\n‚ä¢ Iff (Specializes x y) (Specializes ‚Üëx ‚Üëy)","decl":"theorem subtype_specializes_iff {p : X ‚Üí Prop} (x y : Subtype p) : x ‚§≥ y ‚Üî (x : X) ‚§≥ y :=\n  IsInducing.subtypeVal.specializes_iff.symm\n\n"}
{"name":"specializes_prod","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nx‚ÇÅ x‚ÇÇ : X\ny‚ÇÅ y‚ÇÇ : Y\n‚ä¢ Iff (Specializes { fst := x‚ÇÅ, snd := y‚ÇÅ } { fst := x‚ÇÇ, snd := y‚ÇÇ }) (And (Specializes x‚ÇÅ x‚ÇÇ) (Specializes y‚ÇÅ y‚ÇÇ))","decl":"@[simp]\ntheorem specializes_prod {x‚ÇÅ x‚ÇÇ : X} {y‚ÇÅ y‚ÇÇ : Y} : (x‚ÇÅ, y‚ÇÅ) ‚§≥ (x‚ÇÇ, y‚ÇÇ) ‚Üî x‚ÇÅ ‚§≥ x‚ÇÇ ‚àß y‚ÇÅ ‚§≥ y‚ÇÇ := by\n  simp only [Specializes, nhds_prod_eq, prod_le_prod]\n\n"}
{"name":"Specializes.prod","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nx‚ÇÅ x‚ÇÇ : X\ny‚ÇÅ y‚ÇÇ : Y\nhx : Specializes x‚ÇÅ x‚ÇÇ\nhy : Specializes y‚ÇÅ y‚ÇÇ\n‚ä¢ Specializes { fst := x‚ÇÅ, snd := y‚ÇÅ } { fst := x‚ÇÇ, snd := y‚ÇÇ }","decl":"theorem Specializes.prod {x‚ÇÅ x‚ÇÇ : X} {y‚ÇÅ y‚ÇÇ : Y} (hx : x‚ÇÅ ‚§≥ x‚ÇÇ) (hy : y‚ÇÅ ‚§≥ y‚ÇÇ) :\n    (x‚ÇÅ, y‚ÇÅ) ‚§≥ (x‚ÇÇ, y‚ÇÇ) :=\n  specializes_prod.2 ‚ü®hx, hy‚ü©\n\n"}
{"name":"Specializes.fst","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\na b : Prod X Y\nh : Specializes a b\n‚ä¢ Specializes a.1 b.1","decl":"theorem Specializes.fst {a b : X √ó Y} (h : a ‚§≥ b) : a.1 ‚§≥ b.1 := (specializes_prod.1 h).1\n"}
{"name":"Specializes.snd","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\na b : Prod X Y\nh : Specializes a b\n‚ä¢ Specializes a.2 b.2","decl":"theorem Specializes.snd {a b : X √ó Y} (h : a ‚§≥ b) : a.2 ‚§≥ b.2 := (specializes_prod.1 h).2\n\n"}
{"name":"specializes_pi","module":"Mathlib.Topology.Inseparable","initialProofState":"Œπ : Type u_5\nœÄ : Œπ ‚Üí Type u_6\ninst‚úù : (i : Œπ) ‚Üí TopologicalSpace (œÄ i)\nf g : (i : Œπ) ‚Üí œÄ i\n‚ä¢ Iff (Specializes f g) (‚àÄ (i : Œπ), Specializes (f i) (g i))","decl":"@[simp]\ntheorem specializes_pi {f g : ‚àÄ i, œÄ i} : f ‚§≥ g ‚Üî ‚àÄ i, f i ‚§≥ g i := by\n  simp only [Specializes, nhds_pi, pi_le_pi]\n\n"}
{"name":"not_specializes_iff_exists_open","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\n‚ä¢ Iff (Not (Specializes x y)) (Exists fun S => And (IsOpen S) (And (Membership.mem S y) (Not (Membership.mem S x))))","decl":"theorem not_specializes_iff_exists_open : ¬¨x ‚§≥ y ‚Üî ‚àÉ S : Set X, IsOpen S ‚àß y ‚àà S ‚àß x ‚àâ S := by\n  rw [specializes_iff_forall_open]\n  push_neg\n  rfl\n\n"}
{"name":"not_specializes_iff_exists_closed","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\n‚ä¢ Iff (Not (Specializes x y)) (Exists fun S => And (IsClosed S) (And (Membership.mem S x) (Not (Membership.mem S y))))","decl":"theorem not_specializes_iff_exists_closed : ¬¨x ‚§≥ y ‚Üî ‚àÉ S : Set X, IsClosed S ‚àß x ‚àà S ‚àß y ‚àâ S := by\n  rw [specializes_iff_forall_closed]\n  push_neg\n  rfl\n\n"}
{"name":"IsOpen.continuous_piecewise_of_specializes","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ns : Set X\nf g : X ‚Üí Y\ninst‚úù : DecidablePred fun x => Membership.mem s x\nhs : IsOpen s\nhf : Continuous f\nhg : Continuous g\nhspec : ‚àÄ (x : X), Specializes (f x) (g x)\n‚ä¢ Continuous (s.piecewise f g)","decl":"theorem IsOpen.continuous_piecewise_of_specializes [DecidablePred (¬∑ ‚àà s)] (hs : IsOpen s)\n    (hf : Continuous f) (hg : Continuous g) (hspec : ‚àÄ x, f x ‚§≥ g x) :\n    Continuous (s.piecewise f g) := by\n  have : ‚àÄ U, IsOpen U ‚Üí g ‚Åª¬π' U ‚äÜ f ‚Åª¬π' U := fun U hU x hx ‚Ü¶ (hspec x).mem_open hU hx\n  rw [continuous_def]\n  intro U hU\n  rw [piecewise_preimage, ite_eq_of_subset_right _ (this U hU)]\n  exact hU.preimage hf |>.inter hs |>.union (hU.preimage hg)\n\n"}
{"name":"IsClosed.continuous_piecewise_of_specializes","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ns : Set X\nf g : X ‚Üí Y\ninst‚úù : DecidablePred fun x => Membership.mem s x\nhs : IsClosed s\nhf : Continuous f\nhg : Continuous g\nhspec : ‚àÄ (x : X), Specializes (g x) (f x)\n‚ä¢ Continuous (s.piecewise f g)","decl":"theorem IsClosed.continuous_piecewise_of_specializes [DecidablePred (¬∑ ‚àà s)] (hs : IsClosed s)\n    (hf : Continuous f) (hg : Continuous g) (hspec : ‚àÄ x, g x ‚§≥ f x) :\n    Continuous (s.piecewise f g) := by\n  simpa only [piecewise_compl] using hs.isOpen_compl.continuous_piecewise_of_specializes hg hf hspec\n\n"}
{"name":"Continuous.specialization_monotone","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\nhf : Continuous f\n‚ä¢ Monotone f","decl":"/-- A continuous function is monotone with respect to the specialization preorders on the domain and\nthe codomain. -/\ntheorem Continuous.specialization_monotone (hf : Continuous f) : Monotone f :=\n  fun _ _ h => h.map hf\n\n"}
{"name":"closure_singleton_eq_Iic","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx : X\n‚ä¢ Eq (closure (Singleton.singleton x)) (Set.Iic x)","decl":"lemma closure_singleton_eq_Iic (x : X) : closure {x} = Iic x :=\n  Set.ext fun _ ‚Ü¶ specializes_iff_mem_closure.symm\n\n"}
{"name":"IsClosed.stableUnderSpecialization","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\ns : Set X\nhs : IsClosed s\n‚ä¢ StableUnderSpecialization s","decl":"lemma IsClosed.stableUnderSpecialization {s : Set X} (hs : IsClosed s) :\n    StableUnderSpecialization s :=\n  fun _ _ e ‚Ü¶ e.mem_closed hs\n\n"}
{"name":"IsOpen.stableUnderGeneralization","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\ns : Set X\nhs : IsOpen s\n‚ä¢ StableUnderGeneralization s","decl":"lemma IsOpen.stableUnderGeneralization {s : Set X} (hs : IsOpen s) :\n    StableUnderGeneralization s :=\n  fun _ _ e ‚Ü¶ e.mem_open hs\n\n"}
{"name":"stableUnderSpecialization_compl_iff","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\ns : Set X\n‚ä¢ Iff (StableUnderSpecialization (HasCompl.compl s)) (StableUnderGeneralization s)","decl":"@[simp]\nlemma stableUnderSpecialization_compl_iff {s : Set X} :\n    StableUnderSpecialization s·∂ú ‚Üî StableUnderGeneralization s :=\n  isLowerSet_compl\n\n"}
{"name":"stableUnderGeneralization_compl_iff","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\ns : Set X\n‚ä¢ Iff (StableUnderGeneralization (HasCompl.compl s)) (StableUnderSpecialization s)","decl":"@[simp]\nlemma stableUnderGeneralization_compl_iff {s : Set X} :\n    StableUnderGeneralization s·∂ú ‚Üî StableUnderSpecialization s :=\n  isUpperSet_compl\n\n"}
{"name":"StableUnderGeneralization.compl","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\ns : Set X\na‚úù : StableUnderGeneralization s\n‚ä¢ StableUnderSpecialization (HasCompl.compl s)","decl":"alias ‚ü®_, StableUnderGeneralization.compl‚ü© := stableUnderSpecialization_compl_iff\n"}
{"name":"StableUnderSpecialization.compl","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\ns : Set X\na‚úù : StableUnderSpecialization s\n‚ä¢ StableUnderGeneralization (HasCompl.compl s)","decl":"alias ‚ü®_, StableUnderSpecialization.compl‚ü© := stableUnderGeneralization_compl_iff\n\n"}
{"name":"stableUnderSpecialization_univ","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\n‚ä¢ StableUnderSpecialization Set.univ","decl":"lemma stableUnderSpecialization_univ : StableUnderSpecialization (univ : Set X) := isLowerSet_univ\n"}
{"name":"stableUnderSpecialization_empty","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\n‚ä¢ StableUnderSpecialization EmptyCollection.emptyCollection","decl":"lemma stableUnderSpecialization_empty : StableUnderSpecialization (‚àÖ : Set X) := isLowerSet_empty\n"}
{"name":"stableUnderGeneralization_univ","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\n‚ä¢ StableUnderGeneralization Set.univ","decl":"lemma stableUnderGeneralization_univ : StableUnderGeneralization (univ : Set X) := isUpperSet_univ\n"}
{"name":"stableUnderGeneralization_empty","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\n‚ä¢ StableUnderGeneralization EmptyCollection.emptyCollection","decl":"lemma stableUnderGeneralization_empty : StableUnderGeneralization (‚àÖ : Set X) := isUpperSet_empty\n\n"}
{"name":"stableUnderSpecialization_sUnion","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nS : Set (Set X)\nH : ‚àÄ (s : Set X), Membership.mem S s ‚Üí StableUnderSpecialization s\n‚ä¢ StableUnderSpecialization S.sUnion","decl":"lemma stableUnderSpecialization_sUnion (S : Set (Set X))\n    (H : ‚àÄ s ‚àà S, StableUnderSpecialization s) : StableUnderSpecialization (‚ãÉ‚ÇÄ S) :=\n  isLowerSet_sUnion H\n\n"}
{"name":"stableUnderSpecialization_sInter","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nS : Set (Set X)\nH : ‚àÄ (s : Set X), Membership.mem S s ‚Üí StableUnderSpecialization s\n‚ä¢ StableUnderSpecialization S.sInter","decl":"lemma stableUnderSpecialization_sInter (S : Set (Set X))\n    (H : ‚àÄ s ‚àà S, StableUnderSpecialization s) : StableUnderSpecialization (‚ãÇ‚ÇÄ S) :=\n  isLowerSet_sInter H\n\n"}
{"name":"stableUnderGeneralization_sUnion","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nS : Set (Set X)\nH : ‚àÄ (s : Set X), Membership.mem S s ‚Üí StableUnderGeneralization s\n‚ä¢ StableUnderGeneralization S.sUnion","decl":"lemma stableUnderGeneralization_sUnion (S : Set (Set X))\n    (H : ‚àÄ s ‚àà S, StableUnderGeneralization s) : StableUnderGeneralization (‚ãÉ‚ÇÄ S) :=\n  isUpperSet_sUnion H\n\n"}
{"name":"stableUnderGeneralization_sInter","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nS : Set (Set X)\nH : ‚àÄ (s : Set X), Membership.mem S s ‚Üí StableUnderGeneralization s\n‚ä¢ StableUnderGeneralization S.sInter","decl":"lemma stableUnderGeneralization_sInter (S : Set (Set X))\n    (H : ‚àÄ s ‚àà S, StableUnderGeneralization s) : StableUnderGeneralization (‚ãÇ‚ÇÄ S) :=\n  isUpperSet_sInter H\n\n"}
{"name":"stableUnderSpecialization_iUnion","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nŒπ : Sort u_7\nS : Œπ ‚Üí Set X\nH : ‚àÄ (i : Œπ), StableUnderSpecialization (S i)\n‚ä¢ StableUnderSpecialization (Set.iUnion fun i => S i)","decl":"lemma stableUnderSpecialization_iUnion {Œπ : Sort*} (S : Œπ ‚Üí Set X)\n    (H : ‚àÄ i, StableUnderSpecialization (S i)) : StableUnderSpecialization (‚ãÉ i, S i) :=\n  isLowerSet_iUnion H\n\n"}
{"name":"stableUnderSpecialization_iInter","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nŒπ : Sort u_7\nS : Œπ ‚Üí Set X\nH : ‚àÄ (i : Œπ), StableUnderSpecialization (S i)\n‚ä¢ StableUnderSpecialization (Set.iInter fun i => S i)","decl":"lemma stableUnderSpecialization_iInter {Œπ : Sort*} (S : Œπ ‚Üí Set X)\n    (H : ‚àÄ i, StableUnderSpecialization (S i)) : StableUnderSpecialization (‚ãÇ i, S i) :=\n  isLowerSet_iInter H\n\n"}
{"name":"stableUnderGeneralization_iUnion","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nŒπ : Sort u_7\nS : Œπ ‚Üí Set X\nH : ‚àÄ (i : Œπ), StableUnderGeneralization (S i)\n‚ä¢ StableUnderGeneralization (Set.iUnion fun i => S i)","decl":"lemma stableUnderGeneralization_iUnion {Œπ : Sort*} (S : Œπ ‚Üí Set X)\n    (H : ‚àÄ i, StableUnderGeneralization (S i)) : StableUnderGeneralization (‚ãÉ i, S i) :=\n  isUpperSet_iUnion H\n\n"}
{"name":"stableUnderGeneralization_iInter","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nŒπ : Sort u_7\nS : Œπ ‚Üí Set X\nH : ‚àÄ (i : Œπ), StableUnderGeneralization (S i)\n‚ä¢ StableUnderGeneralization (Set.iInter fun i => S i)","decl":"lemma stableUnderGeneralization_iInter {Œπ : Sort*} (S : Œπ ‚Üí Set X)\n    (H : ‚àÄ i, StableUnderGeneralization (S i)) : StableUnderGeneralization (‚ãÇ i, S i) :=\n  isUpperSet_iInter H\n\n"}
{"name":"Union_closure_singleton_eq_iff","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\ns : Set X\n‚ä¢ Iff (Eq (Set.iUnion fun x => Set.iUnion fun h => closure (Singleton.singleton x)) s) (StableUnderSpecialization s)","decl":"lemma Union_closure_singleton_eq_iff {s : Set X} :\n    (‚ãÉ x ‚àà s, closure {x}) = s ‚Üî StableUnderSpecialization s :=\n  show _ ‚Üî IsLowerSet s by simp only [closure_singleton_eq_Iic, ‚Üê lowerClosure_eq, coe_lowerClosure]\n\n"}
{"name":"stableUnderSpecialization_iff_Union_eq","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\ns : Set X\n‚ä¢ Iff (StableUnderSpecialization s) (Eq (Set.iUnion fun x => Set.iUnion fun h => closure (Singleton.singleton x)) s)","decl":"lemma stableUnderSpecialization_iff_Union_eq {s : Set X} :\n    StableUnderSpecialization s ‚Üî (‚ãÉ x ‚àà s, closure {x}) = s :=\n  Union_closure_singleton_eq_iff.symm\n\n"}
{"name":"StableUnderSpecialization.Union_eq","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\ns : Set X\na‚úù : StableUnderSpecialization s\n‚ä¢ Eq (Set.iUnion fun x => Set.iUnion fun h => closure (Singleton.singleton x)) s","decl":"alias ‚ü®StableUnderSpecialization.Union_eq, _‚ü© := stableUnderSpecialization_iff_Union_eq\n\n"}
{"name":"stableUnderSpecialization_iff_exists_sUnion_eq","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\ns : Set X\n‚ä¢ Iff (StableUnderSpecialization s) (Exists fun S => And (‚àÄ (s : Set X), Membership.mem S s ‚Üí IsClosed s) (Eq S.sUnion s))","decl":"/-- A set is stable under specialization iff it is a union of closed sets. -/\nlemma stableUnderSpecialization_iff_exists_sUnion_eq {s : Set X} :\n    StableUnderSpecialization s ‚Üî ‚àÉ (S : Set (Set X)), (‚àÄ s ‚àà S, IsClosed s) ‚àß ‚ãÉ‚ÇÄ S = s := by\n  refine ‚ü®fun H ‚Ü¶ ‚ü®(fun x : X ‚Ü¶ closure {x}) '' s, ?_, ?_‚ü©, fun ‚ü®S, hS, e‚ü© ‚Ü¶ e ‚ñ∏\n    stableUnderSpecialization_sUnion S (fun x hx ‚Ü¶ (hS x hx).stableUnderSpecialization)‚ü©\n  ¬∑ rintro _ ‚ü®_, _, rfl‚ü©; exact isClosed_closure\n  ¬∑ conv_rhs => rw [‚Üê H.Union_eq]\n    simp\n\n"}
{"name":"stableUnderGeneralization_iff_exists_sInter_eq","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\ns : Set X\n‚ä¢ Iff (StableUnderGeneralization s) (Exists fun S => And (‚àÄ (s : Set X), Membership.mem S s ‚Üí IsOpen s) (Eq S.sInter s))","decl":"/-- A set is stable under generalization iff it is an intersection of open sets. -/\nlemma stableUnderGeneralization_iff_exists_sInter_eq {s : Set X} :\n    StableUnderGeneralization s ‚Üî ‚àÉ (S : Set (Set X)), (‚àÄ s ‚àà S, IsOpen s) ‚àß ‚ãÇ‚ÇÄ S = s := by\n  refine ‚ü®?_, fun ‚ü®S, hS, e‚ü© ‚Ü¶ e ‚ñ∏\n    stableUnderGeneralization_sInter S (fun x hx ‚Ü¶ (hS x hx).stableUnderGeneralization)‚ü©\n  rw [‚Üê stableUnderSpecialization_compl_iff, stableUnderSpecialization_iff_exists_sUnion_eq]\n  exact fun ‚ü®S, h‚ÇÅ, h‚ÇÇ‚ü© ‚Ü¶ ‚ü®(¬∑·∂ú) '' S, fun s ‚ü®t, ht, e‚ü© ‚Ü¶ e ‚ñ∏ (h‚ÇÅ t ht).isOpen_compl,\n    compl_injective ((sUnion_eq_compl_sInter_compl S).symm.trans h‚ÇÇ)‚ü©\n\n"}
{"name":"StableUnderSpecialization.preimage","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\ns : Set Y\nhs : StableUnderSpecialization s\nhf : Continuous f\n‚ä¢ StableUnderSpecialization (Set.preimage f s)","decl":"lemma StableUnderSpecialization.preimage {s : Set Y}\n    (hs : StableUnderSpecialization s) (hf : Continuous f) :\n    StableUnderSpecialization (f ‚Åª¬π' s) :=\n  IsLowerSet.preimage hs hf.specialization_monotone\n\n"}
{"name":"StableUnderGeneralization.preimage","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\ns : Set Y\nhs : StableUnderGeneralization s\nhf : Continuous f\n‚ä¢ StableUnderGeneralization (Set.preimage f s)","decl":"lemma StableUnderGeneralization.preimage {s : Set Y}\n    (hs : StableUnderGeneralization s) (hf : Continuous f) :\n    StableUnderGeneralization (f ‚Åª¬π' s) :=\n  IsUpperSet.preimage hs hf.specialization_monotone\n\n"}
{"name":"specializingMap_iff_closure_singleton_subset","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\n‚ä¢ Iff (SpecializingMap f) (‚àÄ (x : X), HasSubset.Subset (closure (Singleton.singleton (f x))) (Set.image f (closure (Singleton.singleton x))))","decl":"lemma specializingMap_iff_closure_singleton_subset :\n    SpecializingMap f ‚Üî ‚àÄ x, closure {f x} ‚äÜ f '' closure {x} := by\n  simp only [SpecializingMap, Relation.Fibration, flip, specializes_iff_mem_closure]; rfl\n\n"}
{"name":"SpecializingMap.closure_singleton_subset","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\na‚úù : SpecializingMap f\nx : X\n‚ä¢ HasSubset.Subset (closure (Singleton.singleton (f x))) (Set.image f (closure (Singleton.singleton x)))","decl":"alias ‚ü®SpecializingMap.closure_singleton_subset, _‚ü© := specializingMap_iff_closure_singleton_subset\n\n"}
{"name":"SpecializingMap.stableUnderSpecialization_image","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\nhf : SpecializingMap f\ns : Set X\nhs : StableUnderSpecialization s\n‚ä¢ StableUnderSpecialization (Set.image f s)","decl":"lemma SpecializingMap.stableUnderSpecialization_image (hf : SpecializingMap f)\n    {s : Set X} (hs : StableUnderSpecialization s) : StableUnderSpecialization (f '' s) :=\n  IsLowerSet.image_fibration hf hs\n\n"}
{"name":"StableUnderSpecialization.image","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\nhf : SpecializingMap f\ns : Set X\nhs : StableUnderSpecialization s\n‚ä¢ StableUnderSpecialization (Set.image f s)","decl":"alias StableUnderSpecialization.image := SpecializingMap.stableUnderSpecialization_image\n\n"}
{"name":"specializingMap_iff_stableUnderSpecialization_image_singleton","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\n‚ä¢ Iff (SpecializingMap f) (‚àÄ (x : X), StableUnderSpecialization (Set.image f (closure (Singleton.singleton x))))","decl":"lemma specializingMap_iff_stableUnderSpecialization_image_singleton :\n    SpecializingMap f ‚Üî ‚àÄ x, StableUnderSpecialization (f '' closure {x}) := by\n  simpa only [closure_singleton_eq_Iic] using Relation.fibration_iff_isLowerSet_image_Iic\n\n"}
{"name":"specializingMap_iff_stableUnderSpecialization_image","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\n‚ä¢ Iff (SpecializingMap f) (‚àÄ (s : Set X), StableUnderSpecialization s ‚Üí StableUnderSpecialization (Set.image f s))","decl":"lemma specializingMap_iff_stableUnderSpecialization_image :\n    SpecializingMap f ‚Üî ‚àÄ s, StableUnderSpecialization s ‚Üí StableUnderSpecialization (f '' s) :=\n  Relation.fibration_iff_isLowerSet_image\n\n"}
{"name":"specializingMap_iff_closure_singleton","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\nhf : Continuous f\n‚ä¢ Iff (SpecializingMap f) (‚àÄ (x : X), Eq (Set.image f (closure (Singleton.singleton x))) (closure (Singleton.singleton (f x))))","decl":"lemma specializingMap_iff_closure_singleton (hf : Continuous f) :\n    SpecializingMap f ‚Üî ‚àÄ x, f '' closure {x} = closure {f x} := by\n  simpa only [closure_singleton_eq_Iic] using\n    Relation.fibration_iff_image_Iic hf.specialization_monotone\n\n"}
{"name":"specializingMap_iff_isClosed_image_closure_singleton","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\nhf : Continuous f\n‚ä¢ Iff (SpecializingMap f) (‚àÄ (x : X), IsClosed (Set.image f (closure (Singleton.singleton x))))","decl":"lemma specializingMap_iff_isClosed_image_closure_singleton (hf : Continuous f) :\n    SpecializingMap f ‚Üî ‚àÄ x, IsClosed (f '' closure {x}) := by\n  refine ‚ü®fun h x ‚Ü¶ ?_, fun h ‚Ü¶ specializingMap_iff_stableUnderSpecialization_image_singleton.mpr\n    (fun x ‚Ü¶ (h x).stableUnderSpecialization)‚ü©\n  rw [(specializingMap_iff_closure_singleton hf).mp h x]\n  exact isClosed_closure\n\n"}
{"name":"SpecializingMap.comp","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\nf : X ‚Üí Y\ng : Y ‚Üí Z\nhf : SpecializingMap f\nhg : SpecializingMap g\n‚ä¢ SpecializingMap (Function.comp g f)","decl":"lemma SpecializingMap.comp {f : X ‚Üí Y} {g : Y ‚Üí Z}\n    (hf : SpecializingMap f) (hg : SpecializingMap g) :\n    SpecializingMap (g ‚àò f) := by\n  simp only [specializingMap_iff_stableUnderSpecialization_image, Set.image_comp] at *\n  exact fun s h ‚Ü¶ hg _ (hf  _ h)\n\n"}
{"name":"IsClosedMap.specializingMap","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\nhf : IsClosedMap f\n‚ä¢ SpecializingMap f","decl":"lemma IsClosedMap.specializingMap (hf : IsClosedMap f) : SpecializingMap f :=\n  specializingMap_iff_stableUnderSpecialization_image_singleton.mpr <|\n    fun _ ‚Ü¶ (hf _ isClosed_closure).stableUnderSpecialization\n\n"}
{"name":"Topology.IsInducing.specializingMap","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\nhf : Topology.IsInducing f\nh : StableUnderSpecialization (Set.range f)\n‚ä¢ SpecializingMap f","decl":"lemma Topology.IsInducing.specializingMap (hf : IsInducing f)\n    (h : StableUnderSpecialization (range f)) : SpecializingMap f := by\n  intros x y e\n  obtain ‚ü®y, rfl‚ü© := h e ‚ü®x, rfl‚ü©\n  exact ‚ü®_, hf.specializes_iff.mp e, rfl‚ü©\n\n"}
{"name":"Inducing.specializingMap","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\nhf : Topology.IsInducing f\nh : StableUnderSpecialization (Set.range f)\n‚ä¢ SpecializingMap f","decl":"@[deprecated (since := \"2024-10-28\")] alias Inducing.specializingMap := IsInducing.specializingMap\n\n"}
{"name":"Topology.IsInducing.generalizingMap","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\nhf : Topology.IsInducing f\nh : StableUnderGeneralization (Set.range f)\n‚ä¢ GeneralizingMap f","decl":"lemma Topology.IsInducing.generalizingMap (hf : IsInducing f)\n    (h : StableUnderGeneralization (range f)) : GeneralizingMap f := by\n  intros x y e\n  obtain ‚ü®y, rfl‚ü© := h e ‚ü®x, rfl‚ü©\n  exact ‚ü®_, hf.specializes_iff.mp e, rfl‚ü©\n\n"}
{"name":"Inducing.generalizingMap","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\nhf : Topology.IsInducing f\nh : StableUnderGeneralization (Set.range f)\n‚ä¢ GeneralizingMap f","decl":"@[deprecated (since := \"2024-10-28\")] alias Inducing.generalizingMap := IsInducing.generalizingMap\n\n"}
{"name":"IsOpenEmbedding.generalizingMap","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\nhf : Topology.IsOpenEmbedding f\n‚ä¢ GeneralizingMap f","decl":"lemma IsOpenEmbedding.generalizingMap (hf : IsOpenEmbedding f) : GeneralizingMap f :=\n  hf.isInducing.generalizingMap hf.isOpen_range.stableUnderGeneralization\n\n"}
{"name":"OpenEmbedding.generalizingMap","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\nhf : Topology.IsOpenEmbedding f\n‚ä¢ GeneralizingMap f","decl":"@[deprecated (since := \"2024-10-18\")]\nalias OpenEmbedding.generalizingMap := IsOpenEmbedding.generalizingMap\n\n"}
{"name":"SpecializingMap.stableUnderSpecialization_range","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\nh : SpecializingMap f\n‚ä¢ StableUnderSpecialization (Set.range f)","decl":"lemma SpecializingMap.stableUnderSpecialization_range (h : SpecializingMap f) :\n    StableUnderSpecialization (range f) :=\n  @image_univ _ _ f ‚ñ∏ stableUnderSpecialization_univ.image h\n\n"}
{"name":"GeneralizingMap.stableUnderGeneralization_image","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\nhf : GeneralizingMap f\ns : Set X\nhs : StableUnderGeneralization s\n‚ä¢ StableUnderGeneralization (Set.image f s)","decl":"lemma GeneralizingMap.stableUnderGeneralization_image (hf : GeneralizingMap f) {s : Set X}\n    (hs : StableUnderGeneralization s) : StableUnderGeneralization (f '' s) :=\n  IsUpperSet.image_fibration hf hs\n\n"}
{"name":"GeneralizingMap_iff_stableUnderGeneralization_image","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\n‚ä¢ Iff (GeneralizingMap f) (‚àÄ (s : Set X), StableUnderGeneralization s ‚Üí StableUnderGeneralization (Set.image f s))","decl":"lemma GeneralizingMap_iff_stableUnderGeneralization_image :\n    GeneralizingMap f ‚Üî ‚àÄ s, StableUnderGeneralization s ‚Üí StableUnderGeneralization (f '' s) :=\n  Relation.fibration_iff_isUpperSet_image\n\n"}
{"name":"StableUnderGeneralization.image","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\nhf : GeneralizingMap f\ns : Set X\nhs : StableUnderGeneralization s\n‚ä¢ StableUnderGeneralization (Set.image f s)","decl":"alias StableUnderGeneralization.image := GeneralizingMap.stableUnderGeneralization_image\n\n"}
{"name":"GeneralizingMap.stableUnderGeneralization_range","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\nh : GeneralizingMap f\n‚ä¢ StableUnderGeneralization (Set.range f)","decl":"lemma GeneralizingMap.stableUnderGeneralization_range (h : GeneralizingMap f) :\n    StableUnderGeneralization (range f) :=\n  @image_univ _ _ f ‚ñ∏ stableUnderGeneralization_univ.image h\n\n"}
{"name":"GeneralizingMap.comp","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\nf : X ‚Üí Y\ng : Y ‚Üí Z\nhf : GeneralizingMap f\nhg : GeneralizingMap g\n‚ä¢ GeneralizingMap (Function.comp g f)","decl":"lemma GeneralizingMap.comp {f : X ‚Üí Y} {g : Y ‚Üí Z}\n    (hf : GeneralizingMap f) (hg : GeneralizingMap g) :\n    GeneralizingMap (g ‚àò f) := by\n  simp only [GeneralizingMap_iff_stableUnderGeneralization_image, Set.image_comp] at *\n  exact fun s h ‚Ü¶ hg _ (hf  _ h)\n\n"}
{"name":"inseparable_def","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\n‚ä¢ Iff (Inseparable x y) (Eq (nhds x) (nhds y))","decl":"theorem inseparable_def : (x ~·µ¢ y) ‚Üî ùìù x = ùìù y :=\n  Iff.rfl\n\n"}
{"name":"inseparable_iff_specializes_and","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\n‚ä¢ Iff (Inseparable x y) (And (Specializes x y) (Specializes y x))","decl":"theorem inseparable_iff_specializes_and : (x ~·µ¢ y) ‚Üî x ‚§≥ y ‚àß y ‚§≥ x :=\n  le_antisymm_iff\n\n"}
{"name":"Inseparable.specializes","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\nh : Inseparable x y\n‚ä¢ Specializes x y","decl":"theorem Inseparable.specializes (h : x ~·µ¢ y) : x ‚§≥ y := h.le\n\n"}
{"name":"Inseparable.specializes'","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\nh : Inseparable x y\n‚ä¢ Specializes y x","decl":"theorem Inseparable.specializes' (h : x ~·µ¢ y) : y ‚§≥ x := h.ge\n\n"}
{"name":"Specializes.antisymm","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\nh‚ÇÅ : Specializes x y\nh‚ÇÇ : Specializes y x\n‚ä¢ Inseparable x y","decl":"theorem Specializes.antisymm (h‚ÇÅ : x ‚§≥ y) (h‚ÇÇ : y ‚§≥ x) : x ~·µ¢ y :=\n  le_antisymm h‚ÇÅ h‚ÇÇ\n\n"}
{"name":"inseparable_iff_forall_isOpen","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\n‚ä¢ Iff (Inseparable x y) (‚àÄ (s : Set X), IsOpen s ‚Üí Iff (Membership.mem s x) (Membership.mem s y))","decl":"theorem inseparable_iff_forall_isOpen : (x ~·µ¢ y) ‚Üî ‚àÄ s : Set X, IsOpen s ‚Üí (x ‚àà s ‚Üî y ‚àà s) := by\n  simp only [inseparable_iff_specializes_and, specializes_iff_forall_open, ‚Üê forall_and, ‚Üê iff_def,\n    Iff.comm]\n\n"}
{"name":"inseparable_iff_forall_open","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\n‚ä¢ Iff (Inseparable x y) (‚àÄ (s : Set X), IsOpen s ‚Üí Iff (Membership.mem s x) (Membership.mem s y))","decl":"@[deprecated (since := \"2024-11-18\")] alias\ninseparable_iff_forall_open := inseparable_iff_forall_isOpen\n\n"}
{"name":"not_inseparable_iff_exists_open","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\n‚ä¢ Iff (Not (Inseparable x y)) (Exists fun s => And (IsOpen s) (Xor' (Membership.mem s x) (Membership.mem s y)))","decl":"theorem not_inseparable_iff_exists_open :\n    ¬¨(x ~·µ¢ y) ‚Üî ‚àÉ s : Set X, IsOpen s ‚àß Xor' (x ‚àà s) (y ‚àà s) := by\n  simp [inseparable_iff_forall_isOpen, ‚Üê xor_iff_not_iff]\n\n"}
{"name":"inseparable_iff_forall_isClosed","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\n‚ä¢ Iff (Inseparable x y) (‚àÄ (s : Set X), IsClosed s ‚Üí Iff (Membership.mem s x) (Membership.mem s y))","decl":"theorem inseparable_iff_forall_isClosed : (x ~·µ¢ y) ‚Üî ‚àÄ s : Set X, IsClosed s ‚Üí (x ‚àà s ‚Üî y ‚àà s) := by\n  simp only [inseparable_iff_specializes_and, specializes_iff_forall_closed, ‚Üê forall_and, ‚Üê\n    iff_def]\n"}
{"name":"inseparable_iff_forall_closed","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\n‚ä¢ Iff (Inseparable x y) (‚àÄ (s : Set X), IsClosed s ‚Üí Iff (Membership.mem s x) (Membership.mem s y))","decl":"@[deprecated (since := \"2024-11-18\")] alias\ninseparable_iff_forall_closed := inseparable_iff_forall_isClosed\n\n"}
{"name":"inseparable_iff_mem_closure","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\n‚ä¢ Iff (Inseparable x y) (And (Membership.mem (closure (Singleton.singleton y)) x) (Membership.mem (closure (Singleton.singleton x)) y))","decl":"theorem inseparable_iff_mem_closure :\n    (x ~·µ¢ y) ‚Üî x ‚àà closure ({y} : Set X) ‚àß y ‚àà closure ({x} : Set X) :=\n  inseparable_iff_specializes_and.trans <| by simp only [specializes_iff_mem_closure, and_comm]\n\n"}
{"name":"inseparable_iff_closure_eq","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\n‚ä¢ Iff (Inseparable x y) (Eq (closure (Singleton.singleton x)) (closure (Singleton.singleton y)))","decl":"theorem inseparable_iff_closure_eq : (x ~·µ¢ y) ‚Üî closure ({x} : Set X) = closure {y} := by\n  simp only [inseparable_iff_specializes_and, specializes_iff_closure_subset, ‚Üê subset_antisymm_iff,\n    eq_comm]\n\n"}
{"name":"inseparable_of_nhdsWithin_eq","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\ns : Set X\nhx : Membership.mem s x\nhy : Membership.mem s y\nh : Eq (nhdsWithin x s) (nhdsWithin y s)\n‚ä¢ Inseparable x y","decl":"theorem inseparable_of_nhdsWithin_eq (hx : x ‚àà s) (hy : y ‚àà s) (h : ùìù[s] x = ùìù[s] y) : x ~·µ¢ y :=\n  (specializes_of_nhdsWithin h.le hx).antisymm (specializes_of_nhdsWithin h.ge hy)\n\n"}
{"name":"Topology.IsInducing.inseparable_iff","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nx y : X\nf : X ‚Üí Y\nhf : Topology.IsInducing f\n‚ä¢ Iff (Inseparable (f x) (f y)) (Inseparable x y)","decl":"theorem Topology.IsInducing.inseparable_iff (hf : IsInducing f) : (f x ~·µ¢ f y) ‚Üî (x ~·µ¢ y) := by\n  simp only [inseparable_iff_specializes_and, hf.specializes_iff]\n\n"}
{"name":"Inducing.inseparable_iff","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nx y : X\nf : X ‚Üí Y\nhf : Topology.IsInducing f\n‚ä¢ Iff (Inseparable (f x) (f y)) (Inseparable x y)","decl":"@[deprecated (since := \"2024-10-28\")] alias Inducing.inseparable_iff := IsInducing.inseparable_iff\n\n"}
{"name":"subtype_inseparable_iff","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\np : X ‚Üí Prop\nx y : Subtype p\n‚ä¢ Iff (Inseparable x y) (Inseparable ‚Üëx ‚Üëy)","decl":"theorem subtype_inseparable_iff {p : X ‚Üí Prop} (x y : Subtype p) : (x ~·µ¢ y) ‚Üî ((x : X) ~·µ¢ y) :=\n  IsInducing.subtypeVal.inseparable_iff.symm\n\n"}
{"name":"inseparable_prod","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nx‚ÇÅ x‚ÇÇ : X\ny‚ÇÅ y‚ÇÇ : Y\n‚ä¢ Iff (Inseparable { fst := x‚ÇÅ, snd := y‚ÇÅ } { fst := x‚ÇÇ, snd := y‚ÇÇ }) (And (Inseparable x‚ÇÅ x‚ÇÇ) (Inseparable y‚ÇÅ y‚ÇÇ))","decl":"@[simp] theorem inseparable_prod {x‚ÇÅ x‚ÇÇ : X} {y‚ÇÅ y‚ÇÇ : Y} :\n    ((x‚ÇÅ, y‚ÇÅ) ~·µ¢ (x‚ÇÇ, y‚ÇÇ)) ‚Üî (x‚ÇÅ ~·µ¢ x‚ÇÇ) ‚àß (y‚ÇÅ ~·µ¢ y‚ÇÇ) := by\n  simp only [Inseparable, nhds_prod_eq, prod_inj]\n\n"}
{"name":"Inseparable.prod","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nx‚ÇÅ x‚ÇÇ : X\ny‚ÇÅ y‚ÇÇ : Y\nhx : Inseparable x‚ÇÅ x‚ÇÇ\nhy : Inseparable y‚ÇÅ y‚ÇÇ\n‚ä¢ Inseparable { fst := x‚ÇÅ, snd := y‚ÇÅ } { fst := x‚ÇÇ, snd := y‚ÇÇ }","decl":"theorem Inseparable.prod {x‚ÇÅ x‚ÇÇ : X} {y‚ÇÅ y‚ÇÇ : Y} (hx : x‚ÇÅ ~·µ¢ x‚ÇÇ) (hy : y‚ÇÅ ~·µ¢ y‚ÇÇ) :\n    (x‚ÇÅ, y‚ÇÅ) ~·µ¢ (x‚ÇÇ, y‚ÇÇ) :=\n  inseparable_prod.2 ‚ü®hx, hy‚ü©\n\n"}
{"name":"inseparable_pi","module":"Mathlib.Topology.Inseparable","initialProofState":"Œπ : Type u_5\nœÄ : Œπ ‚Üí Type u_6\ninst‚úù : (i : Œπ) ‚Üí TopologicalSpace (œÄ i)\nf g : (i : Œπ) ‚Üí œÄ i\n‚ä¢ Iff (Inseparable f g) (‚àÄ (i : Œπ), Inseparable (f i) (g i))","decl":"@[simp]\ntheorem inseparable_pi {f g : ‚àÄ i, œÄ i} : (f ~·µ¢ g) ‚Üî ‚àÄ i, f i ~·µ¢ g i := by\n  simp only [Inseparable, nhds_pi, funext_iff, pi_inj]\n\n"}
{"name":"Inseparable.refl","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx : X\n‚ä¢ Inseparable x x","decl":"@[refl]\ntheorem refl (x : X) : x ~·µ¢ x :=\n  Eq.refl (ùìù x)\n\n"}
{"name":"Inseparable.rfl","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx : X\n‚ä¢ Inseparable x x","decl":"theorem rfl : x ~·µ¢ x :=\n  refl x\n\n"}
{"name":"Inseparable.of_eq","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\ne : Eq x y\n‚ä¢ Inseparable x y","decl":"theorem of_eq (e : x = y) : Inseparable x y :=\n  e ‚ñ∏ refl x\n\n"}
{"name":"Inseparable.symm","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\nh : Inseparable x y\n‚ä¢ Inseparable y x","decl":"@[symm]\nnonrec theorem symm (h : x ~·µ¢ y) : y ~·µ¢ x := h.symm\n\n"}
{"name":"Inseparable.trans","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y z : X\nh‚ÇÅ : Inseparable x y\nh‚ÇÇ : Inseparable y z\n‚ä¢ Inseparable x z","decl":"@[trans]\nnonrec theorem trans (h‚ÇÅ : x ~·µ¢ y) (h‚ÇÇ : y ~·µ¢ z) : x ~·µ¢ z := h‚ÇÅ.trans h‚ÇÇ\n\n"}
{"name":"Inseparable.nhds_eq","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\nh : Inseparable x y\n‚ä¢ Eq (nhds x) (nhds y)","decl":"theorem nhds_eq (h : x ~·µ¢ y) : ùìù x = ùìù y := h\n\n"}
{"name":"Inseparable.mem_open_iff","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\ns : Set X\nh : Inseparable x y\nhs : IsOpen s\n‚ä¢ Iff (Membership.mem s x) (Membership.mem s y)","decl":"theorem mem_open_iff (h : x ~·µ¢ y) (hs : IsOpen s) : x ‚àà s ‚Üî y ‚àà s :=\n  inseparable_iff_forall_isOpen.1 h s hs\n\n"}
{"name":"Inseparable.mem_closed_iff","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\ns : Set X\nh : Inseparable x y\nhs : IsClosed s\n‚ä¢ Iff (Membership.mem s x) (Membership.mem s y)","decl":"theorem mem_closed_iff (h : x ~·µ¢ y) (hs : IsClosed s) : x ‚àà s ‚Üî y ‚àà s :=\n  inseparable_iff_forall_isClosed.1 h s hs\n\n"}
{"name":"Inseparable.map_of_continuousAt","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nx y : X\nf : X ‚Üí Y\nh : Inseparable x y\nhx : ContinuousAt f x\nhy : ContinuousAt f y\n‚ä¢ Inseparable (f x) (f y)","decl":"theorem map_of_continuousAt (h : x ~·µ¢ y) (hx : ContinuousAt f x) (hy : ContinuousAt f y) :\n    f x ~·µ¢ f y :=\n  (h.specializes.map_of_continuousAt hy).antisymm (h.specializes'.map_of_continuousAt hx)\n\n"}
{"name":"Inseparable.map","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nx y : X\nf : X ‚Üí Y\nh : Inseparable x y\nhf : Continuous f\n‚ä¢ Inseparable (f x) (f y)","decl":"theorem map (h : x ~·µ¢ y) (hf : Continuous f) : f x ~·µ¢ f y :=\n  h.map_of_continuousAt hf.continuousAt hf.continuousAt\n\n"}
{"name":"IsClosed.not_inseparable","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\ns : Set X\nhs : IsClosed s\nhx : Membership.mem s x\nhy : Not (Membership.mem s y)\n‚ä¢ Not (Inseparable x y)","decl":"theorem IsClosed.not_inseparable (hs : IsClosed s) (hx : x ‚àà s) (hy : y ‚àâ s) : ¬¨(x ~·µ¢ y) := fun h =>\n  hy <| (h.mem_closed_iff hs).1 hx\n\n"}
{"name":"IsOpen.not_inseparable","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\ns : Set X\nhs : IsOpen s\nhx : Membership.mem s x\nhy : Not (Membership.mem s y)\n‚ä¢ Not (Inseparable x y)","decl":"theorem IsOpen.not_inseparable (hs : IsOpen s) (hx : x ‚àà s) (hy : y ‚àâ s) : ¬¨(x ~·µ¢ y) := fun h =>\n  hy <| (h.mem_open_iff hs).1 hx\n\n"}
{"name":"SeparationQuotient.isQuotientMap_mk","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\n‚ä¢ Topology.IsQuotientMap SeparationQuotient.mk","decl":"theorem isQuotientMap_mk : IsQuotientMap (mk : X ‚Üí SeparationQuotient X) :=\n  isQuotientMap_quot_mk\n\n"}
{"name":"SeparationQuotient.quotientMap_mk","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\n‚ä¢ Topology.IsQuotientMap SeparationQuotient.mk","decl":"@[deprecated (since := \"2024-10-22\")]\nalias quotientMap_mk := isQuotientMap_mk\n\n"}
{"name":"SeparationQuotient.continuous_mk","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\n‚ä¢ Continuous SeparationQuotient.mk","decl":"@[fun_prop, continuity]\ntheorem continuous_mk : Continuous (mk : X ‚Üí SeparationQuotient X) :=\n  continuous_quot_mk\n\n"}
{"name":"SeparationQuotient.mk_eq_mk","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\n‚ä¢ Iff (Eq (SeparationQuotient.mk x) (SeparationQuotient.mk y)) (Inseparable x y)","decl":"@[simp]\ntheorem mk_eq_mk : mk x = mk y ‚Üî (x ~·µ¢ y) :=\n  Quotient.eq''\n\n"}
{"name":"SeparationQuotient.surjective_mk","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\n‚ä¢ Function.Surjective SeparationQuotient.mk","decl":"theorem surjective_mk : Surjective (mk : X ‚Üí SeparationQuotient X) :=\n  Quot.mk_surjective\n\n"}
{"name":"SeparationQuotient.range_mk","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\n‚ä¢ Eq (Set.range SeparationQuotient.mk) Set.univ","decl":"@[simp]\ntheorem range_mk : range (mk : X ‚Üí SeparationQuotient X) = univ :=\n  surjective_mk.range_eq\n\n"}
{"name":"SeparationQuotient.instNonempty","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : Nonempty X\n‚ä¢ Nonempty (SeparationQuotient X)","decl":"instance [Nonempty X] : Nonempty (SeparationQuotient X) :=\n  Nonempty.map mk ‚Äπ_‚Ä∫\n\n"}
{"name":"SeparationQuotient.instSubsingleton","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : Subsingleton X\n‚ä¢ Subsingleton (SeparationQuotient X)","decl":"instance [Subsingleton X] : Subsingleton (SeparationQuotient X) :=\n  surjective_mk.subsingleton\n\n"}
{"name":"SeparationQuotient.mk_zero","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : Zero X\n‚ä¢ Eq (SeparationQuotient.mk 0) 0","decl":"@[to_additive (attr := simp)] theorem mk_one [One X] : mk (1 : X) = 1 := rfl\n\n"}
{"name":"SeparationQuotient.mk_one","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : One X\n‚ä¢ Eq (SeparationQuotient.mk 1) 1","decl":"@[to_additive (attr := simp)] theorem mk_one [One X] : mk (1 : X) = 1 := rfl\n\n"}
{"name":"SeparationQuotient.preimage_image_mk_open","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\ns : Set X\nhs : IsOpen s\n‚ä¢ Eq (Set.preimage SeparationQuotient.mk (Set.image SeparationQuotient.mk s)) s","decl":"theorem preimage_image_mk_open (hs : IsOpen s) : mk ‚Åª¬π' (mk '' s) = s := by\n  refine Subset.antisymm ?_ (subset_preimage_image _ _)\n  rintro x ‚ü®y, hys, hxy‚ü©\n  exact ((mk_eq_mk.1 hxy).mem_open_iff hs).1 hys\n\n"}
{"name":"SeparationQuotient.isOpenMap_mk","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\n‚ä¢ IsOpenMap SeparationQuotient.mk","decl":"theorem isOpenMap_mk : IsOpenMap (mk : X ‚Üí SeparationQuotient X) := fun s hs =>\n  isQuotientMap_mk.isOpen_preimage.1 <| by rwa [preimage_image_mk_open hs]\n\n"}
{"name":"SeparationQuotient.isOpenQuotientMap_mk","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\n‚ä¢ IsOpenQuotientMap SeparationQuotient.mk","decl":"theorem isOpenQuotientMap_mk : IsOpenQuotientMap (mk : X ‚Üí SeparationQuotient X) :=\n  ‚ü®surjective_mk, continuous_mk, isOpenMap_mk‚ü©\n\n"}
{"name":"SeparationQuotient.preimage_image_mk_closed","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\ns : Set X\nhs : IsClosed s\n‚ä¢ Eq (Set.preimage SeparationQuotient.mk (Set.image SeparationQuotient.mk s)) s","decl":"theorem preimage_image_mk_closed (hs : IsClosed s) : mk ‚Åª¬π' (mk '' s) = s := by\n  refine Subset.antisymm ?_ (subset_preimage_image _ _)\n  rintro x ‚ü®y, hys, hxy‚ü©\n  exact ((mk_eq_mk.1 hxy).mem_closed_iff hs).1 hys\n\n"}
{"name":"SeparationQuotient.isInducing_mk","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\n‚ä¢ Topology.IsInducing SeparationQuotient.mk","decl":"theorem isInducing_mk : IsInducing (mk : X ‚Üí SeparationQuotient X) :=\n  ‚ü®le_antisymm (continuous_iff_le_induced.1 continuous_mk) fun s hs =>\n      ‚ü®mk '' s, isOpenMap_mk s hs, preimage_image_mk_open hs‚ü©‚ü©\n\n"}
{"name":"SeparationQuotient.inducing_mk","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\n‚ä¢ Topology.IsInducing SeparationQuotient.mk","decl":"@[deprecated (since := \"2024-10-28\")] alias inducing_mk := isInducing_mk\n\n"}
{"name":"SeparationQuotient.isClosedMap_mk","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\n‚ä¢ IsClosedMap SeparationQuotient.mk","decl":"theorem isClosedMap_mk : IsClosedMap (mk : X ‚Üí SeparationQuotient X) :=\n  isInducing_mk.isClosedMap <| by rw [range_mk]; exact isClosed_univ\n\n"}
{"name":"SeparationQuotient.comap_mk_nhds_mk","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx : X\n‚ä¢ Eq (Filter.comap SeparationQuotient.mk (nhds (SeparationQuotient.mk x))) (nhds x)","decl":"@[simp]\ntheorem comap_mk_nhds_mk : comap mk (ùìù (mk x)) = ùìù x :=\n  (isInducing_mk.nhds_eq_comap _).symm\n\n"}
{"name":"SeparationQuotient.comap_mk_nhdsSet_image","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\ns : Set X\n‚ä¢ Eq (Filter.comap SeparationQuotient.mk (nhdsSet (Set.image SeparationQuotient.mk s))) (nhdsSet s)","decl":"@[simp]\ntheorem comap_mk_nhdsSet_image : comap mk (ùìùÀ¢ (mk '' s)) = ùìùÀ¢ s :=\n  (isInducing_mk.nhdsSet_eq_comap _).symm\n\n"}
{"name":"SeparationQuotient.map_mk_nhds","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx : X\n‚ä¢ Eq (Filter.map SeparationQuotient.mk (nhds x)) (nhds (SeparationQuotient.mk x))","decl":"theorem map_mk_nhds : map mk (ùìù x) = ùìù (mk x) := by\n  rw [‚Üê comap_mk_nhds_mk, map_comap_of_surjective surjective_mk]\n\n"}
{"name":"SeparationQuotient.map_mk_nhdsSet","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\ns : Set X\n‚ä¢ Eq (Filter.map SeparationQuotient.mk (nhdsSet s)) (nhdsSet (Set.image SeparationQuotient.mk s))","decl":"theorem map_mk_nhdsSet : map mk (ùìùÀ¢ s) = ùìùÀ¢ (mk '' s) := by\n  rw [‚Üê comap_mk_nhdsSet_image, map_comap_of_surjective surjective_mk]\n\n"}
{"name":"SeparationQuotient.comap_mk_nhdsSet","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nt : Set (SeparationQuotient X)\n‚ä¢ Eq (Filter.comap SeparationQuotient.mk (nhdsSet t)) (nhdsSet (Set.preimage SeparationQuotient.mk t))","decl":"theorem comap_mk_nhdsSet : comap mk (ùìùÀ¢ t) = ùìùÀ¢ (mk ‚Åª¬π' t) := by\n  conv_lhs => rw [‚Üê image_preimage_eq t surjective_mk, comap_mk_nhdsSet_image]\n\n"}
{"name":"SeparationQuotient.preimage_mk_closure","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nt : Set (SeparationQuotient X)\n‚ä¢ Eq (Set.preimage SeparationQuotient.mk (closure t)) (closure (Set.preimage SeparationQuotient.mk t))","decl":"theorem preimage_mk_closure : mk ‚Åª¬π' closure t = closure (mk ‚Åª¬π' t) :=\n  isOpenMap_mk.preimage_closure_eq_closure_preimage continuous_mk t\n\n"}
{"name":"SeparationQuotient.preimage_mk_interior","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nt : Set (SeparationQuotient X)\n‚ä¢ Eq (Set.preimage SeparationQuotient.mk (interior t)) (interior (Set.preimage SeparationQuotient.mk t))","decl":"theorem preimage_mk_interior : mk ‚Åª¬π' interior t = interior (mk ‚Åª¬π' t) :=\n  isOpenMap_mk.preimage_interior_eq_interior_preimage continuous_mk t\n\n"}
{"name":"SeparationQuotient.preimage_mk_frontier","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nt : Set (SeparationQuotient X)\n‚ä¢ Eq (Set.preimage SeparationQuotient.mk (frontier t)) (frontier (Set.preimage SeparationQuotient.mk t))","decl":"theorem preimage_mk_frontier : mk ‚Åª¬π' frontier t = frontier (mk ‚Åª¬π' t) :=\n  isOpenMap_mk.preimage_frontier_eq_frontier_preimage continuous_mk t\n\n"}
{"name":"SeparationQuotient.image_mk_closure","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\ns : Set X\n‚ä¢ Eq (Set.image SeparationQuotient.mk (closure s)) (closure (Set.image SeparationQuotient.mk s))","decl":"theorem image_mk_closure : mk '' closure s = closure (mk '' s) :=\n  (image_closure_subset_closure_image continuous_mk).antisymm <|\n    isClosedMap_mk.closure_image_subset _\n\n"}
{"name":"SeparationQuotient.map_prod_map_mk_nhds","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nx : X\ny : Y\n‚ä¢ Eq (Filter.map (Prod.map SeparationQuotient.mk SeparationQuotient.mk) (nhds { fst := x, snd := y })) (nhds { fst := SeparationQuotient.mk x, snd := SeparationQuotient.mk y })","decl":"theorem map_prod_map_mk_nhds (x : X) (y : Y) :\n    map (Prod.map mk mk) (ùìù (x, y)) = ùìù (mk x, mk y) := by\n  rw [nhds_prod_eq, ‚Üê prod_map_map_eq', map_mk_nhds, map_mk_nhds, nhds_prod_eq]\n\n"}
{"name":"SeparationQuotient.map_mk_nhdsWithin_preimage","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\ns : Set (SeparationQuotient X)\nx : X\n‚ä¢ Eq (Filter.map SeparationQuotient.mk (nhdsWithin x (Set.preimage SeparationQuotient.mk s))) (nhdsWithin (SeparationQuotient.mk x) s)","decl":"theorem map_mk_nhdsWithin_preimage (s : Set (SeparationQuotient X)) (x : X) :\n    map mk (ùìù[mk ‚Åª¬π' s] x) = ùìù[s] mk x := by\n  rw [nhdsWithin, ‚Üê comap_principal, Filter.push_pull, nhdsWithin, map_mk_nhds]\n\n"}
{"name":"SeparationQuotient.isQuotientMap_prodMap_mk","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\n‚ä¢ Topology.IsQuotientMap (Prod.map SeparationQuotient.mk SeparationQuotient.mk)","decl":"/-- The map `(x, y) ‚Ü¶ (mk x, mk y)` is a quotient map. -/\ntheorem isQuotientMap_prodMap_mk : IsQuotientMap (Prod.map mk mk : X √ó Y ‚Üí _) :=\n  (isOpenQuotientMap_mk.prodMap isOpenQuotientMap_mk).isQuotientMap\n\n"}
{"name":"SeparationQuotient.quotientMap_prodMap_mk","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\n‚ä¢ Topology.IsQuotientMap (Prod.map SeparationQuotient.mk SeparationQuotient.mk)","decl":"@[deprecated (since := \"2024-10-22\")]\nalias quotientMap_prodMap_mk := isQuotientMap_prodMap_mk\n\n"}
{"name":"SeparationQuotient.lift_mk","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nŒ± : Type u_4\ninst‚úù : TopologicalSpace X\nf : X ‚Üí Œ±\nhf : ‚àÄ (x y : X), Inseparable x y ‚Üí Eq (f x) (f y)\nx : X\n‚ä¢ Eq (SeparationQuotient.lift f hf (SeparationQuotient.mk x)) (f x)","decl":"@[simp]\ntheorem lift_mk {f : X ‚Üí Œ±} (hf : ‚àÄ x y, (x ~·µ¢ y) ‚Üí f x = f y) (x : X) : lift f hf (mk x) = f x :=\n  rfl\n\n"}
{"name":"SeparationQuotient.lift_comp_mk","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nŒ± : Type u_4\ninst‚úù : TopologicalSpace X\nf : X ‚Üí Œ±\nhf : ‚àÄ (x y : X), Inseparable x y ‚Üí Eq (f x) (f y)\n‚ä¢ Eq (Function.comp (SeparationQuotient.lift f hf) SeparationQuotient.mk) f","decl":"@[simp]\ntheorem lift_comp_mk {f : X ‚Üí Œ±} (hf : ‚àÄ x y, (x ~·µ¢ y) ‚Üí f x = f y) : lift f hf ‚àò mk = f :=\n  rfl\n\n"}
{"name":"SeparationQuotient.tendsto_lift_nhds_mk","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nŒ± : Type u_4\ninst‚úù : TopologicalSpace X\nx : X\nf : X ‚Üí Œ±\nhf : ‚àÄ (x y : X), Inseparable x y ‚Üí Eq (f x) (f y)\nl : Filter Œ±\n‚ä¢ Iff (Filter.Tendsto (SeparationQuotient.lift f hf) (nhds (SeparationQuotient.mk x)) l) (Filter.Tendsto f (nhds x) l)","decl":"@[simp]\ntheorem tendsto_lift_nhds_mk {f : X ‚Üí Œ±} {hf : ‚àÄ x y, (x ~·µ¢ y) ‚Üí f x = f y} {l : Filter Œ±} :\n    Tendsto (lift f hf) (ùìù <| mk x) l ‚Üî Tendsto f (ùìù x) l := by\n  simp only [‚Üê map_mk_nhds, tendsto_map'_iff, lift_comp_mk]\n\n"}
{"name":"SeparationQuotient.tendsto_lift_nhdsWithin_mk","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nŒ± : Type u_4\ninst‚úù : TopologicalSpace X\nx : X\nf : X ‚Üí Œ±\nhf : ‚àÄ (x y : X), Inseparable x y ‚Üí Eq (f x) (f y)\ns : Set (SeparationQuotient X)\nl : Filter Œ±\n‚ä¢ Iff (Filter.Tendsto (SeparationQuotient.lift f hf) (nhdsWithin (SeparationQuotient.mk x) s) l) (Filter.Tendsto f (nhdsWithin x (Set.preimage SeparationQuotient.mk s)) l)","decl":"@[simp]\ntheorem tendsto_lift_nhdsWithin_mk {f : X ‚Üí Œ±} {hf : ‚àÄ x y, (x ~·µ¢ y) ‚Üí f x = f y}\n    {s : Set (SeparationQuotient X)} {l : Filter Œ±} :\n    Tendsto (lift f hf) (ùìù[s] mk x) l ‚Üî Tendsto f (ùìù[mk ‚Åª¬π' s] x) l := by\n  simp only [‚Üê map_mk_nhdsWithin_preimage, tendsto_map'_iff, lift_comp_mk]\n\n"}
{"name":"SeparationQuotient.continuousAt_lift","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nx : X\nf : X ‚Üí Y\nhf : ‚àÄ (x y : X), Inseparable x y ‚Üí Eq (f x) (f y)\n‚ä¢ Iff (ContinuousAt (SeparationQuotient.lift f hf) (SeparationQuotient.mk x)) (ContinuousAt f x)","decl":"@[simp]\ntheorem continuousAt_lift {hf : ‚àÄ x y, (x ~·µ¢ y) ‚Üí f x = f y} :\n    ContinuousAt (lift f hf) (mk x) ‚Üî ContinuousAt f x :=\n  tendsto_lift_nhds_mk\n\n"}
{"name":"SeparationQuotient.continuousWithinAt_lift","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nx : X\nf : X ‚Üí Y\nhf : ‚àÄ (x y : X), Inseparable x y ‚Üí Eq (f x) (f y)\ns : Set (SeparationQuotient X)\n‚ä¢ Iff (ContinuousWithinAt (SeparationQuotient.lift f hf) s (SeparationQuotient.mk x)) (ContinuousWithinAt f (Set.preimage SeparationQuotient.mk s) x)","decl":"@[simp]\ntheorem continuousWithinAt_lift {hf : ‚àÄ x y, (x ~·µ¢ y) ‚Üí f x = f y}\n    {s : Set (SeparationQuotient X)} :\n    ContinuousWithinAt (lift f hf) s (mk x) ‚Üî ContinuousWithinAt f (mk ‚Åª¬π' s) x :=\n  tendsto_lift_nhdsWithin_mk\n\n"}
{"name":"SeparationQuotient.continuousOn_lift","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\nhf : ‚àÄ (x y : X), Inseparable x y ‚Üí Eq (f x) (f y)\ns : Set (SeparationQuotient X)\n‚ä¢ Iff (ContinuousOn (SeparationQuotient.lift f hf) s) (ContinuousOn f (Set.preimage SeparationQuotient.mk s))","decl":"@[simp]\ntheorem continuousOn_lift {hf : ‚àÄ x y, (x ~·µ¢ y) ‚Üí f x = f y} {s : Set (SeparationQuotient X)} :\n    ContinuousOn (lift f hf) s ‚Üî ContinuousOn f (mk ‚Åª¬π' s) := by\n  simp only [ContinuousOn, surjective_mk.forall, continuousWithinAt_lift, mem_preimage]\n\n"}
{"name":"SeparationQuotient.continuous_lift","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\nhf : ‚àÄ (x y : X), Inseparable x y ‚Üí Eq (f x) (f y)\n‚ä¢ Iff (Continuous (SeparationQuotient.lift f hf)) (Continuous f)","decl":"@[simp]\ntheorem continuous_lift {hf : ‚àÄ x y, (x ~·µ¢ y) ‚Üí f x = f y} :\n    Continuous (lift f hf) ‚Üî Continuous f := by\n  simp only [continuous_iff_continuousOn_univ, continuousOn_lift, preimage_univ]\n\n"}
{"name":"SeparationQuotient.lift‚ÇÇ_mk","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\nŒ± : Type u_4\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y ‚Üí Œ±\nhf : ‚àÄ (a : X) (b : Y) (c : X) (d : Y), Inseparable a c ‚Üí Inseparable b d ‚Üí Eq (f a b) (f c d)\nx : X\ny : Y\n‚ä¢ Eq (SeparationQuotient.lift‚ÇÇ f hf (SeparationQuotient.mk x) (SeparationQuotient.mk y)) (f x y)","decl":"@[simp]\ntheorem lift‚ÇÇ_mk {f : X ‚Üí Y ‚Üí Œ±} (hf : ‚àÄ a b c d, (a ~·µ¢ c) ‚Üí (b ~·µ¢ d) ‚Üí f a b = f c d) (x : X)\n    (y : Y) : lift‚ÇÇ f hf (mk x) (mk y) = f x y :=\n  rfl\n\n"}
{"name":"SeparationQuotient.tendsto_lift‚ÇÇ_nhds","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\nŒ± : Type u_4\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y ‚Üí Œ±\nhf : ‚àÄ (a : X) (b : Y) (c : X) (d : Y), Inseparable a c ‚Üí Inseparable b d ‚Üí Eq (f a b) (f c d)\nx : X\ny : Y\nl : Filter Œ±\n‚ä¢ Iff (Filter.Tendsto (Function.uncurry (SeparationQuotient.lift‚ÇÇ f hf)) (nhds { fst := SeparationQuotient.mk x, snd := SeparationQuotient.mk y }) l) (Filter.Tendsto (Function.uncurry f) (nhds { fst := x, snd := y }) l)","decl":"@[simp]\ntheorem tendsto_lift‚ÇÇ_nhds {f : X ‚Üí Y ‚Üí Œ±} {hf : ‚àÄ a b c d, (a ~·µ¢ c) ‚Üí (b ~·µ¢ d) ‚Üí f a b = f c d}\n    {x : X} {y : Y} {l : Filter Œ±} :\n    Tendsto (uncurry <| lift‚ÇÇ f hf) (ùìù (mk x, mk y)) l ‚Üî Tendsto (uncurry f) (ùìù (x, y)) l := by\n  rw [‚Üê map_prod_map_mk_nhds, tendsto_map'_iff]\n  rfl\n\n"}
{"name":"SeparationQuotient.tendsto_lift‚ÇÇ_nhdsWithin","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\nŒ± : Type u_4\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y ‚Üí Œ±\nhf : ‚àÄ (a : X) (b : Y) (c : X) (d : Y), Inseparable a c ‚Üí Inseparable b d ‚Üí Eq (f a b) (f c d)\nx : X\ny : Y\ns : Set (Prod (SeparationQuotient X) (SeparationQuotient Y))\nl : Filter Œ±\n‚ä¢ Iff (Filter.Tendsto (Function.uncurry (SeparationQuotient.lift‚ÇÇ f hf)) (nhdsWithin { fst := SeparationQuotient.mk x, snd := SeparationQuotient.mk y } s) l) (Filter.Tendsto (Function.uncurry f) (nhdsWithin { fst := x, snd := y } (Set.preimage (Prod.map SeparationQuotient.mk SeparationQuotient.mk) s)) l)","decl":"@[simp] theorem tendsto_lift‚ÇÇ_nhdsWithin {f : X ‚Üí Y ‚Üí Œ±}\n    {hf : ‚àÄ a b c d, (a ~·µ¢ c) ‚Üí (b ~·µ¢ d) ‚Üí f a b = f c d} {x : X} {y : Y}\n    {s : Set (SeparationQuotient X √ó SeparationQuotient Y)} {l : Filter Œ±} :\n    Tendsto (uncurry <| lift‚ÇÇ f hf) (ùìù[s] (mk x, mk y)) l ‚Üî\n      Tendsto (uncurry f) (ùìù[Prod.map mk mk ‚Åª¬π' s] (x, y)) l := by\n  rw [nhdsWithin, ‚Üê map_prod_map_mk_nhds, ‚Üê Filter.push_pull, comap_principal]\n  rfl\n\n"}
{"name":"SeparationQuotient.continuousAt_lift‚ÇÇ","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\nf : X ‚Üí Y ‚Üí Z\nhf : ‚àÄ (a : X) (b : Y) (c : X) (d : Y), Inseparable a c ‚Üí Inseparable b d ‚Üí Eq (f a b) (f c d)\nx : X\ny : Y\n‚ä¢ Iff (ContinuousAt (Function.uncurry (SeparationQuotient.lift‚ÇÇ f hf)) { fst := SeparationQuotient.mk x, snd := SeparationQuotient.mk y }) (ContinuousAt (Function.uncurry f) { fst := x, snd := y })","decl":"@[simp]\ntheorem continuousAt_lift‚ÇÇ {f : X ‚Üí Y ‚Üí Z} {hf : ‚àÄ a b c d, (a ~·µ¢ c) ‚Üí (b ~·µ¢ d) ‚Üí f a b = f c d}\n    {x : X} {y : Y} :\n    ContinuousAt (uncurry <| lift‚ÇÇ f hf) (mk x, mk y) ‚Üî ContinuousAt (uncurry f) (x, y) :=\n  tendsto_lift‚ÇÇ_nhds\n\n"}
{"name":"SeparationQuotient.continuousWithinAt_lift‚ÇÇ","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\nf : X ‚Üí Y ‚Üí Z\nhf : ‚àÄ (a : X) (b : Y) (c : X) (d : Y), Inseparable a c ‚Üí Inseparable b d ‚Üí Eq (f a b) (f c d)\ns : Set (Prod (SeparationQuotient X) (SeparationQuotient Y))\nx : X\ny : Y\n‚ä¢ Iff (ContinuousWithinAt (Function.uncurry (SeparationQuotient.lift‚ÇÇ f hf)) s { fst := SeparationQuotient.mk x, snd := SeparationQuotient.mk y }) (ContinuousWithinAt (Function.uncurry f) (Set.preimage (Prod.map SeparationQuotient.mk SeparationQuotient.mk) s) { fst := x, snd := y })","decl":"@[simp] theorem continuousWithinAt_lift‚ÇÇ {f : X ‚Üí Y ‚Üí Z}\n    {hf : ‚àÄ a b c d, (a ~·µ¢ c) ‚Üí (b ~·µ¢ d) ‚Üí f a b = f c d}\n    {s : Set (SeparationQuotient X √ó SeparationQuotient Y)} {x : X} {y : Y} :\n    ContinuousWithinAt (uncurry <| lift‚ÇÇ f hf) s (mk x, mk y) ‚Üî\n      ContinuousWithinAt (uncurry f) (Prod.map mk mk ‚Åª¬π' s) (x, y) :=\n  tendsto_lift‚ÇÇ_nhdsWithin\n\n"}
{"name":"SeparationQuotient.continuousOn_lift‚ÇÇ","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\nf : X ‚Üí Y ‚Üí Z\nhf : ‚àÄ (a : X) (b : Y) (c : X) (d : Y), Inseparable a c ‚Üí Inseparable b d ‚Üí Eq (f a b) (f c d)\ns : Set (Prod (SeparationQuotient X) (SeparationQuotient Y))\n‚ä¢ Iff (ContinuousOn (Function.uncurry (SeparationQuotient.lift‚ÇÇ f hf)) s) (ContinuousOn (Function.uncurry f) (Set.preimage (Prod.map SeparationQuotient.mk SeparationQuotient.mk) s))","decl":"@[simp]\ntheorem continuousOn_lift‚ÇÇ {f : X ‚Üí Y ‚Üí Z} {hf : ‚àÄ a b c d, (a ~·µ¢ c) ‚Üí (b ~·µ¢ d) ‚Üí f a b = f c d}\n    {s : Set (SeparationQuotient X √ó SeparationQuotient Y)} :\n    ContinuousOn (uncurry <| lift‚ÇÇ f hf) s ‚Üî ContinuousOn (uncurry f) (Prod.map mk mk ‚Åª¬π' s) := by\n  simp_rw [ContinuousOn, (surjective_mk.prodMap surjective_mk).forall, Prod.forall, Prod.map,\n    continuousWithinAt_lift‚ÇÇ]\n  rfl\n\n"}
{"name":"SeparationQuotient.continuous_lift‚ÇÇ","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\nf : X ‚Üí Y ‚Üí Z\nhf : ‚àÄ (a : X) (b : Y) (c : X) (d : Y), Inseparable a c ‚Üí Inseparable b d ‚Üí Eq (f a b) (f c d)\n‚ä¢ Iff (Continuous (Function.uncurry (SeparationQuotient.lift‚ÇÇ f hf))) (Continuous (Function.uncurry f))","decl":"@[simp]\ntheorem continuous_lift‚ÇÇ {f : X ‚Üí Y ‚Üí Z} {hf : ‚àÄ a b c d, (a ~·µ¢ c) ‚Üí (b ~·µ¢ d) ‚Üí f a b = f c d} :\n    Continuous (uncurry <| lift‚ÇÇ f hf) ‚Üî Continuous (uncurry f) := by\n  simp only [continuous_iff_continuousOn_univ, continuousOn_lift‚ÇÇ, preimage_univ]\n\n"}
{"name":"continuous_congr_of_inseparable","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf g : X ‚Üí Y\nh : ‚àÄ (x : X), Inseparable (f x) (g x)\n‚ä¢ Iff (Continuous f) (Continuous g)","decl":"theorem continuous_congr_of_inseparable (h : ‚àÄ x, f x ~·µ¢ g x) :\n    Continuous f ‚Üî Continuous g := by\n  simp_rw [SeparationQuotient.isInducing_mk.continuous_iff (Y := Y)]\n  exact continuous_congr fun x ‚Ü¶ SeparationQuotient.mk_eq_mk.mpr (h x)\n"}
