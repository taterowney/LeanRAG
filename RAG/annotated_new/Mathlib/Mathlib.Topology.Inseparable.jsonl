{"name":"specializes_TFAE","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\n⊢ (List.cons (Specializes x y) (List.cons (LE.le (Pure.pure x) (nhds y)) (List.cons (∀ (s : Set X), IsOpen s → Membership.mem s y → Membership.mem s x) (List.cons (∀ (s : Set X), IsClosed s → Membership.mem s x → Membership.mem s y) (List.cons (Membership.mem (closure (Singleton.singleton x)) y) (List.cons (HasSubset.Subset (closure (Singleton.singleton y)) (closure (Singleton.singleton x))) (List.cons (ClusterPt y (Pure.pure x)) List.nil))))))).TFAE","decl":"/-- A collection of equivalent definitions of `x ⤳ y`. The public API is given by `iff` lemmas\nbelow. -/\ntheorem specializes_TFAE (x y : X) :\n    TFAE [x ⤳ y,\n      pure x ≤ 𝓝 y,\n      ∀ s : Set X , IsOpen s → y ∈ s → x ∈ s,\n      ∀ s : Set X , IsClosed s → x ∈ s → y ∈ s,\n      y ∈ closure ({ x } : Set X),\n      closure ({ y } : Set X) ⊆ closure { x },\n      ClusterPt y (pure x)] := by\n  tfae_have 1 → 2 := (pure_le_nhds _).trans\n  tfae_have 2 → 3 := fun h s hso hy => h (hso.mem_nhds hy)\n  tfae_have 3 → 4 := fun h s hsc hx => of_not_not fun hy => h sᶜ hsc.isOpen_compl hy hx\n  tfae_have 4 → 5 := fun h => h _ isClosed_closure (subset_closure <| mem_singleton _)\n  tfae_have 6 ↔ 5 := isClosed_closure.closure_subset_iff.trans singleton_subset_iff\n  tfae_have 5 ↔ 7 := by\n    rw [mem_closure_iff_clusterPt, principal_singleton]\n  tfae_have 5 → 1 := by\n    refine fun h => (nhds_basis_opens _).ge_iff.2 ?_\n    rintro s ⟨hy, ho⟩\n    rcases mem_closure_iff.1 h s ho hy with ⟨z, hxs, rfl : z = x⟩\n    exact ho.mem_nhds hxs\n  tfae_finish\n\n"}
{"name":"specializes_iff_nhds","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\n⊢ Iff (Specializes x y) (LE.le (nhds x) (nhds y))","decl":"theorem specializes_iff_nhds : x ⤳ y ↔ 𝓝 x ≤ 𝓝 y :=\n  Iff.rfl\n\n"}
{"name":"Specializes.not_disjoint","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\nh : Specializes x y\n⊢ Not (Disjoint (nhds x) (nhds y))","decl":"theorem Specializes.not_disjoint (h : x ⤳ y) : ¬Disjoint (𝓝 x) (𝓝 y) := fun hd ↦\n  absurd (hd.mono_right h) <| by simp [NeBot.ne']\n\n"}
{"name":"specializes_iff_pure","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\n⊢ Iff (Specializes x y) (LE.le (Pure.pure x) (nhds y))","decl":"theorem specializes_iff_pure : x ⤳ y ↔ pure x ≤ 𝓝 y :=\n  (specializes_TFAE x y).out 0 1\n\n"}
{"name":"Specializes.nhds_le_nhds","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\na✝ : Specializes x y\n⊢ LE.le (nhds x) (nhds y)","decl":"alias ⟨Specializes.nhds_le_nhds, _⟩ := specializes_iff_nhds\n\n"}
{"name":"Specializes.pure_le_nhds","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\na✝ : Specializes x y\n⊢ LE.le (Pure.pure x) (nhds y)","decl":"alias ⟨Specializes.pure_le_nhds, _⟩ := specializes_iff_pure\n\n"}
{"name":"ker_nhds_eq_specializes","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx : X\n⊢ Eq (nhds x).ker (setOf fun y => Specializes y x)","decl":"theorem ker_nhds_eq_specializes : (𝓝 x).ker = {y | y ⤳ x} := by\n  ext; simp [specializes_iff_pure, le_def]\n\n"}
{"name":"specializes_iff_forall_open","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\n⊢ Iff (Specializes x y) (∀ (s : Set X), IsOpen s → Membership.mem s y → Membership.mem s x)","decl":"theorem specializes_iff_forall_open : x ⤳ y ↔ ∀ s : Set X, IsOpen s → y ∈ s → x ∈ s :=\n  (specializes_TFAE x y).out 0 2\n\n"}
{"name":"Specializes.mem_open","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\ns : Set X\nh : Specializes x y\nhs : IsOpen s\nhy : Membership.mem s y\n⊢ Membership.mem s x","decl":"theorem Specializes.mem_open (h : x ⤳ y) (hs : IsOpen s) (hy : y ∈ s) : x ∈ s :=\n  specializes_iff_forall_open.1 h s hs hy\n\n"}
{"name":"IsOpen.not_specializes","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\ns : Set X\nhs : IsOpen s\nhx : Not (Membership.mem s x)\nhy : Membership.mem s y\n⊢ Not (Specializes x y)","decl":"theorem IsOpen.not_specializes (hs : IsOpen s) (hx : x ∉ s) (hy : y ∈ s) : ¬x ⤳ y := fun h =>\n  hx <| h.mem_open hs hy\n\n"}
{"name":"specializes_iff_forall_closed","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\n⊢ Iff (Specializes x y) (∀ (s : Set X), IsClosed s → Membership.mem s x → Membership.mem s y)","decl":"theorem specializes_iff_forall_closed : x ⤳ y ↔ ∀ s : Set X, IsClosed s → x ∈ s → y ∈ s :=\n  (specializes_TFAE x y).out 0 3\n\n"}
{"name":"Specializes.mem_closed","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\ns : Set X\nh : Specializes x y\nhs : IsClosed s\nhx : Membership.mem s x\n⊢ Membership.mem s y","decl":"theorem Specializes.mem_closed (h : x ⤳ y) (hs : IsClosed s) (hx : x ∈ s) : y ∈ s :=\n  specializes_iff_forall_closed.1 h s hs hx\n\n"}
{"name":"IsClosed.not_specializes","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\ns : Set X\nhs : IsClosed s\nhx : Membership.mem s x\nhy : Not (Membership.mem s y)\n⊢ Not (Specializes x y)","decl":"theorem IsClosed.not_specializes (hs : IsClosed s) (hx : x ∈ s) (hy : y ∉ s) : ¬x ⤳ y := fun h =>\n  hy <| h.mem_closed hs hx\n\n"}
{"name":"specializes_iff_mem_closure","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\n⊢ Iff (Specializes x y) (Membership.mem (closure (Singleton.singleton x)) y)","decl":"theorem specializes_iff_mem_closure : x ⤳ y ↔ y ∈ closure ({x} : Set X) :=\n  (specializes_TFAE x y).out 0 4\n\n"}
{"name":"Specializes.mem_closure","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\na✝ : Specializes x y\n⊢ Membership.mem (closure (Singleton.singleton x)) y","decl":"alias ⟨Specializes.mem_closure, _⟩ := specializes_iff_mem_closure\n\n"}
{"name":"specializes_iff_closure_subset","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\n⊢ Iff (Specializes x y) (HasSubset.Subset (closure (Singleton.singleton y)) (closure (Singleton.singleton x)))","decl":"theorem specializes_iff_closure_subset : x ⤳ y ↔ closure ({y} : Set X) ⊆ closure {x} :=\n  (specializes_TFAE x y).out 0 5\n\n"}
{"name":"Specializes.closure_subset","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\na✝ : Specializes x y\n⊢ HasSubset.Subset (closure (Singleton.singleton y)) (closure (Singleton.singleton x))","decl":"alias ⟨Specializes.closure_subset, _⟩ := specializes_iff_closure_subset\n\n"}
{"name":"specializes_iff_clusterPt","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\n⊢ Iff (Specializes x y) (ClusterPt y (Pure.pure x))","decl":"theorem specializes_iff_clusterPt : x ⤳ y ↔ ClusterPt y (pure x) :=\n  (specializes_TFAE x y).out 0 6\n\n"}
{"name":"Filter.HasBasis.specializes_iff","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\nι : Sort u_7\np : ι → Prop\ns : ι → Set X\nh : (nhds y).HasBasis p s\n⊢ Iff (Specializes x y) (∀ (i : ι), p i → Membership.mem (s i) x)","decl":"theorem Filter.HasBasis.specializes_iff {ι} {p : ι → Prop} {s : ι → Set X}\n    (h : (𝓝 y).HasBasis p s) : x ⤳ y ↔ ∀ i, p i → x ∈ s i :=\n  specializes_iff_pure.trans h.ge_iff\n\n"}
{"name":"specializes_rfl","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx : X\n⊢ Specializes x x","decl":"theorem specializes_rfl : x ⤳ x := le_rfl\n\n"}
{"name":"specializes_refl","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx : X\n⊢ Specializes x x","decl":"@[refl]\ntheorem specializes_refl (x : X) : x ⤳ x :=\n  specializes_rfl\n\n"}
{"name":"Specializes.trans","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y z : X\na✝¹ : Specializes x y\na✝ : Specializes y z\n⊢ Specializes x z","decl":"@[trans]\ntheorem Specializes.trans : x ⤳ y → y ⤳ z → x ⤳ z :=\n  le_trans\n\n"}
{"name":"specializes_of_eq","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\ne : Eq x y\n⊢ Specializes x y","decl":"theorem specializes_of_eq (e : x = y) : x ⤳ y :=\n  e ▸ specializes_refl x\n\n"}
{"name":"Specializes.of_eq","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\ne : Eq x y\n⊢ Specializes x y","decl":"alias Specializes.of_eq := specializes_of_eq\n\n"}
{"name":"specializes_of_nhdsWithin","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\ns : Set X\nh₁ : LE.le (nhdsWithin x s) (nhdsWithin y s)\nh₂ : Membership.mem s x\n⊢ Specializes x y","decl":"theorem specializes_of_nhdsWithin (h₁ : 𝓝[s] x ≤ 𝓝[s] y) (h₂ : x ∈ s) : x ⤳ y :=\n  specializes_iff_pure.2 <|\n    calc\n      pure x ≤ 𝓝[s] x := le_inf (pure_le_nhds _) (le_principal_iff.2 h₂)\n      _ ≤ 𝓝[s] y := h₁\n      _ ≤ 𝓝 y := inf_le_left\n\n"}
{"name":"Specializes.map_of_continuousAt","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nx y : X\nf : X → Y\nh : Specializes x y\nhy : ContinuousAt f y\n⊢ Specializes (f x) (f y)","decl":"theorem Specializes.map_of_continuousAt (h : x ⤳ y) (hy : ContinuousAt f y) : f x ⤳ f y :=\n  specializes_iff_pure.2 fun _s hs =>\n    mem_pure.2 <| mem_preimage.1 <| mem_of_mem_nhds <| hy.mono_left h hs\n\n"}
{"name":"Specializes.map","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nx y : X\nf : X → Y\nh : Specializes x y\nhf : Continuous f\n⊢ Specializes (f x) (f y)","decl":"theorem Specializes.map (h : x ⤳ y) (hf : Continuous f) : f x ⤳ f y :=\n  h.map_of_continuousAt hf.continuousAt\n\n"}
{"name":"Topology.IsInducing.specializes_iff","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nx y : X\nf : X → Y\nhf : Topology.IsInducing f\n⊢ Iff (Specializes (f x) (f y)) (Specializes x y)","decl":"theorem Topology.IsInducing.specializes_iff (hf : IsInducing f) : f x ⤳ f y ↔ x ⤳ y := by\n  simp only [specializes_iff_mem_closure, hf.closure_eq_preimage_closure_image, image_singleton,\n    mem_preimage]\n\n"}
{"name":"Inducing.specializes_iff","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nx y : X\nf : X → Y\nhf : Topology.IsInducing f\n⊢ Iff (Specializes (f x) (f y)) (Specializes x y)","decl":"@[deprecated (since := \"2024-10-28\")] alias Inducing.specializes_iff := IsInducing.specializes_iff\n\n"}
{"name":"subtype_specializes_iff","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\np : X → Prop\nx y : Subtype p\n⊢ Iff (Specializes x y) (Specializes ↑x ↑y)","decl":"theorem subtype_specializes_iff {p : X → Prop} (x y : Subtype p) : x ⤳ y ↔ (x : X) ⤳ y :=\n  IsInducing.subtypeVal.specializes_iff.symm\n\n"}
{"name":"specializes_prod","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nx₁ x₂ : X\ny₁ y₂ : Y\n⊢ Iff (Specializes { fst := x₁, snd := y₁ } { fst := x₂, snd := y₂ }) (And (Specializes x₁ x₂) (Specializes y₁ y₂))","decl":"@[simp]\ntheorem specializes_prod {x₁ x₂ : X} {y₁ y₂ : Y} : (x₁, y₁) ⤳ (x₂, y₂) ↔ x₁ ⤳ x₂ ∧ y₁ ⤳ y₂ := by\n  simp only [Specializes, nhds_prod_eq, prod_le_prod]\n\n"}
{"name":"Specializes.prod","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nx₁ x₂ : X\ny₁ y₂ : Y\nhx : Specializes x₁ x₂\nhy : Specializes y₁ y₂\n⊢ Specializes { fst := x₁, snd := y₁ } { fst := x₂, snd := y₂ }","decl":"theorem Specializes.prod {x₁ x₂ : X} {y₁ y₂ : Y} (hx : x₁ ⤳ x₂) (hy : y₁ ⤳ y₂) :\n    (x₁, y₁) ⤳ (x₂, y₂) :=\n  specializes_prod.2 ⟨hx, hy⟩\n\n"}
{"name":"Specializes.fst","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\na b : Prod X Y\nh : Specializes a b\n⊢ Specializes a.1 b.1","decl":"theorem Specializes.fst {a b : X × Y} (h : a ⤳ b) : a.1 ⤳ b.1 := (specializes_prod.1 h).1\n"}
{"name":"Specializes.snd","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\na b : Prod X Y\nh : Specializes a b\n⊢ Specializes a.2 b.2","decl":"theorem Specializes.snd {a b : X × Y} (h : a ⤳ b) : a.2 ⤳ b.2 := (specializes_prod.1 h).2\n\n"}
{"name":"specializes_pi","module":"Mathlib.Topology.Inseparable","initialProofState":"ι : Type u_5\nπ : ι → Type u_6\ninst✝ : (i : ι) → TopologicalSpace (π i)\nf g : (i : ι) → π i\n⊢ Iff (Specializes f g) (∀ (i : ι), Specializes (f i) (g i))","decl":"@[simp]\ntheorem specializes_pi {f g : ∀ i, π i} : f ⤳ g ↔ ∀ i, f i ⤳ g i := by\n  simp only [Specializes, nhds_pi, pi_le_pi]\n\n"}
{"name":"not_specializes_iff_exists_open","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\n⊢ Iff (Not (Specializes x y)) (Exists fun S => And (IsOpen S) (And (Membership.mem S y) (Not (Membership.mem S x))))","decl":"theorem not_specializes_iff_exists_open : ¬x ⤳ y ↔ ∃ S : Set X, IsOpen S ∧ y ∈ S ∧ x ∉ S := by\n  rw [specializes_iff_forall_open]\n  push_neg\n  rfl\n\n"}
{"name":"not_specializes_iff_exists_closed","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\n⊢ Iff (Not (Specializes x y)) (Exists fun S => And (IsClosed S) (And (Membership.mem S x) (Not (Membership.mem S y))))","decl":"theorem not_specializes_iff_exists_closed : ¬x ⤳ y ↔ ∃ S : Set X, IsClosed S ∧ x ∈ S ∧ y ∉ S := by\n  rw [specializes_iff_forall_closed]\n  push_neg\n  rfl\n\n"}
{"name":"IsOpen.continuous_piecewise_of_specializes","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ns : Set X\nf g : X → Y\ninst✝ : DecidablePred fun x => Membership.mem s x\nhs : IsOpen s\nhf : Continuous f\nhg : Continuous g\nhspec : ∀ (x : X), Specializes (f x) (g x)\n⊢ Continuous (s.piecewise f g)","decl":"theorem IsOpen.continuous_piecewise_of_specializes [DecidablePred (· ∈ s)] (hs : IsOpen s)\n    (hf : Continuous f) (hg : Continuous g) (hspec : ∀ x, f x ⤳ g x) :\n    Continuous (s.piecewise f g) := by\n  have : ∀ U, IsOpen U → g ⁻¹' U ⊆ f ⁻¹' U := fun U hU x hx ↦ (hspec x).mem_open hU hx\n  rw [continuous_def]\n  intro U hU\n  rw [piecewise_preimage, ite_eq_of_subset_right _ (this U hU)]\n  exact hU.preimage hf |>.inter hs |>.union (hU.preimage hg)\n\n"}
{"name":"IsClosed.continuous_piecewise_of_specializes","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ns : Set X\nf g : X → Y\ninst✝ : DecidablePred fun x => Membership.mem s x\nhs : IsClosed s\nhf : Continuous f\nhg : Continuous g\nhspec : ∀ (x : X), Specializes (g x) (f x)\n⊢ Continuous (s.piecewise f g)","decl":"theorem IsClosed.continuous_piecewise_of_specializes [DecidablePred (· ∈ s)] (hs : IsClosed s)\n    (hf : Continuous f) (hg : Continuous g) (hspec : ∀ x, g x ⤳ f x) :\n    Continuous (s.piecewise f g) := by\n  simpa only [piecewise_compl] using hs.isOpen_compl.continuous_piecewise_of_specializes hg hf hspec\n\n"}
{"name":"Continuous.specialization_monotone","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nhf : Continuous f\n⊢ Monotone f","decl":"/-- A continuous function is monotone with respect to the specialization preorders on the domain and\nthe codomain. -/\ntheorem Continuous.specialization_monotone (hf : Continuous f) : Monotone f :=\n  fun _ _ h => h.map hf\n\n"}
{"name":"closure_singleton_eq_Iic","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx : X\n⊢ Eq (closure (Singleton.singleton x)) (Set.Iic x)","decl":"lemma closure_singleton_eq_Iic (x : X) : closure {x} = Iic x :=\n  Set.ext fun _ ↦ specializes_iff_mem_closure.symm\n\n"}
{"name":"IsClosed.stableUnderSpecialization","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set X\nhs : IsClosed s\n⊢ StableUnderSpecialization s","decl":"lemma IsClosed.stableUnderSpecialization {s : Set X} (hs : IsClosed s) :\n    StableUnderSpecialization s :=\n  fun _ _ e ↦ e.mem_closed hs\n\n"}
{"name":"IsOpen.stableUnderGeneralization","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set X\nhs : IsOpen s\n⊢ StableUnderGeneralization s","decl":"lemma IsOpen.stableUnderGeneralization {s : Set X} (hs : IsOpen s) :\n    StableUnderGeneralization s :=\n  fun _ _ e ↦ e.mem_open hs\n\n"}
{"name":"stableUnderSpecialization_compl_iff","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ Iff (StableUnderSpecialization (HasCompl.compl s)) (StableUnderGeneralization s)","decl":"@[simp]\nlemma stableUnderSpecialization_compl_iff {s : Set X} :\n    StableUnderSpecialization sᶜ ↔ StableUnderGeneralization s :=\n  isLowerSet_compl\n\n"}
{"name":"stableUnderGeneralization_compl_iff","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ Iff (StableUnderGeneralization (HasCompl.compl s)) (StableUnderSpecialization s)","decl":"@[simp]\nlemma stableUnderGeneralization_compl_iff {s : Set X} :\n    StableUnderGeneralization sᶜ ↔ StableUnderSpecialization s :=\n  isUpperSet_compl\n\n"}
{"name":"StableUnderGeneralization.compl","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set X\na✝ : StableUnderGeneralization s\n⊢ StableUnderSpecialization (HasCompl.compl s)","decl":"alias ⟨_, StableUnderGeneralization.compl⟩ := stableUnderSpecialization_compl_iff\n"}
{"name":"StableUnderSpecialization.compl","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set X\na✝ : StableUnderSpecialization s\n⊢ StableUnderGeneralization (HasCompl.compl s)","decl":"alias ⟨_, StableUnderSpecialization.compl⟩ := stableUnderGeneralization_compl_iff\n\n"}
{"name":"stableUnderSpecialization_univ","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\n⊢ StableUnderSpecialization Set.univ","decl":"lemma stableUnderSpecialization_univ : StableUnderSpecialization (univ : Set X) := isLowerSet_univ\n"}
{"name":"stableUnderSpecialization_empty","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\n⊢ StableUnderSpecialization EmptyCollection.emptyCollection","decl":"lemma stableUnderSpecialization_empty : StableUnderSpecialization (∅ : Set X) := isLowerSet_empty\n"}
{"name":"stableUnderGeneralization_univ","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\n⊢ StableUnderGeneralization Set.univ","decl":"lemma stableUnderGeneralization_univ : StableUnderGeneralization (univ : Set X) := isUpperSet_univ\n"}
{"name":"stableUnderGeneralization_empty","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\n⊢ StableUnderGeneralization EmptyCollection.emptyCollection","decl":"lemma stableUnderGeneralization_empty : StableUnderGeneralization (∅ : Set X) := isUpperSet_empty\n\n"}
{"name":"stableUnderSpecialization_sUnion","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nS : Set (Set X)\nH : ∀ (s : Set X), Membership.mem S s → StableUnderSpecialization s\n⊢ StableUnderSpecialization S.sUnion","decl":"lemma stableUnderSpecialization_sUnion (S : Set (Set X))\n    (H : ∀ s ∈ S, StableUnderSpecialization s) : StableUnderSpecialization (⋃₀ S) :=\n  isLowerSet_sUnion H\n\n"}
{"name":"stableUnderSpecialization_sInter","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nS : Set (Set X)\nH : ∀ (s : Set X), Membership.mem S s → StableUnderSpecialization s\n⊢ StableUnderSpecialization S.sInter","decl":"lemma stableUnderSpecialization_sInter (S : Set (Set X))\n    (H : ∀ s ∈ S, StableUnderSpecialization s) : StableUnderSpecialization (⋂₀ S) :=\n  isLowerSet_sInter H\n\n"}
{"name":"stableUnderGeneralization_sUnion","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nS : Set (Set X)\nH : ∀ (s : Set X), Membership.mem S s → StableUnderGeneralization s\n⊢ StableUnderGeneralization S.sUnion","decl":"lemma stableUnderGeneralization_sUnion (S : Set (Set X))\n    (H : ∀ s ∈ S, StableUnderGeneralization s) : StableUnderGeneralization (⋃₀ S) :=\n  isUpperSet_sUnion H\n\n"}
{"name":"stableUnderGeneralization_sInter","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nS : Set (Set X)\nH : ∀ (s : Set X), Membership.mem S s → StableUnderGeneralization s\n⊢ StableUnderGeneralization S.sInter","decl":"lemma stableUnderGeneralization_sInter (S : Set (Set X))\n    (H : ∀ s ∈ S, StableUnderGeneralization s) : StableUnderGeneralization (⋂₀ S) :=\n  isUpperSet_sInter H\n\n"}
{"name":"stableUnderSpecialization_iUnion","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nι : Sort u_7\nS : ι → Set X\nH : ∀ (i : ι), StableUnderSpecialization (S i)\n⊢ StableUnderSpecialization (Set.iUnion fun i => S i)","decl":"lemma stableUnderSpecialization_iUnion {ι : Sort*} (S : ι → Set X)\n    (H : ∀ i, StableUnderSpecialization (S i)) : StableUnderSpecialization (⋃ i, S i) :=\n  isLowerSet_iUnion H\n\n"}
{"name":"stableUnderSpecialization_iInter","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nι : Sort u_7\nS : ι → Set X\nH : ∀ (i : ι), StableUnderSpecialization (S i)\n⊢ StableUnderSpecialization (Set.iInter fun i => S i)","decl":"lemma stableUnderSpecialization_iInter {ι : Sort*} (S : ι → Set X)\n    (H : ∀ i, StableUnderSpecialization (S i)) : StableUnderSpecialization (⋂ i, S i) :=\n  isLowerSet_iInter H\n\n"}
{"name":"stableUnderGeneralization_iUnion","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nι : Sort u_7\nS : ι → Set X\nH : ∀ (i : ι), StableUnderGeneralization (S i)\n⊢ StableUnderGeneralization (Set.iUnion fun i => S i)","decl":"lemma stableUnderGeneralization_iUnion {ι : Sort*} (S : ι → Set X)\n    (H : ∀ i, StableUnderGeneralization (S i)) : StableUnderGeneralization (⋃ i, S i) :=\n  isUpperSet_iUnion H\n\n"}
{"name":"stableUnderGeneralization_iInter","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nι : Sort u_7\nS : ι → Set X\nH : ∀ (i : ι), StableUnderGeneralization (S i)\n⊢ StableUnderGeneralization (Set.iInter fun i => S i)","decl":"lemma stableUnderGeneralization_iInter {ι : Sort*} (S : ι → Set X)\n    (H : ∀ i, StableUnderGeneralization (S i)) : StableUnderGeneralization (⋂ i, S i) :=\n  isUpperSet_iInter H\n\n"}
{"name":"Union_closure_singleton_eq_iff","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ Iff (Eq (Set.iUnion fun x => Set.iUnion fun h => closure (Singleton.singleton x)) s) (StableUnderSpecialization s)","decl":"lemma Union_closure_singleton_eq_iff {s : Set X} :\n    (⋃ x ∈ s, closure {x}) = s ↔ StableUnderSpecialization s :=\n  show _ ↔ IsLowerSet s by simp only [closure_singleton_eq_Iic, ← lowerClosure_eq, coe_lowerClosure]\n\n"}
{"name":"stableUnderSpecialization_iff_Union_eq","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ Iff (StableUnderSpecialization s) (Eq (Set.iUnion fun x => Set.iUnion fun h => closure (Singleton.singleton x)) s)","decl":"lemma stableUnderSpecialization_iff_Union_eq {s : Set X} :\n    StableUnderSpecialization s ↔ (⋃ x ∈ s, closure {x}) = s :=\n  Union_closure_singleton_eq_iff.symm\n\n"}
{"name":"StableUnderSpecialization.Union_eq","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set X\na✝ : StableUnderSpecialization s\n⊢ Eq (Set.iUnion fun x => Set.iUnion fun h => closure (Singleton.singleton x)) s","decl":"alias ⟨StableUnderSpecialization.Union_eq, _⟩ := stableUnderSpecialization_iff_Union_eq\n\n"}
{"name":"stableUnderSpecialization_iff_exists_sUnion_eq","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ Iff (StableUnderSpecialization s) (Exists fun S => And (∀ (s : Set X), Membership.mem S s → IsClosed s) (Eq S.sUnion s))","decl":"/-- A set is stable under specialization iff it is a union of closed sets. -/\nlemma stableUnderSpecialization_iff_exists_sUnion_eq {s : Set X} :\n    StableUnderSpecialization s ↔ ∃ (S : Set (Set X)), (∀ s ∈ S, IsClosed s) ∧ ⋃₀ S = s := by\n  refine ⟨fun H ↦ ⟨(fun x : X ↦ closure {x}) '' s, ?_, ?_⟩, fun ⟨S, hS, e⟩ ↦ e ▸\n    stableUnderSpecialization_sUnion S (fun x hx ↦ (hS x hx).stableUnderSpecialization)⟩\n  · rintro _ ⟨_, _, rfl⟩; exact isClosed_closure\n  · conv_rhs => rw [← H.Union_eq]\n    simp\n\n"}
{"name":"stableUnderGeneralization_iff_exists_sInter_eq","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ Iff (StableUnderGeneralization s) (Exists fun S => And (∀ (s : Set X), Membership.mem S s → IsOpen s) (Eq S.sInter s))","decl":"/-- A set is stable under generalization iff it is an intersection of open sets. -/\nlemma stableUnderGeneralization_iff_exists_sInter_eq {s : Set X} :\n    StableUnderGeneralization s ↔ ∃ (S : Set (Set X)), (∀ s ∈ S, IsOpen s) ∧ ⋂₀ S = s := by\n  refine ⟨?_, fun ⟨S, hS, e⟩ ↦ e ▸\n    stableUnderGeneralization_sInter S (fun x hx ↦ (hS x hx).stableUnderGeneralization)⟩\n  rw [← stableUnderSpecialization_compl_iff, stableUnderSpecialization_iff_exists_sUnion_eq]\n  exact fun ⟨S, h₁, h₂⟩ ↦ ⟨(·ᶜ) '' S, fun s ⟨t, ht, e⟩ ↦ e ▸ (h₁ t ht).isOpen_compl,\n    compl_injective ((sUnion_eq_compl_sInter_compl S).symm.trans h₂)⟩\n\n"}
{"name":"StableUnderSpecialization.preimage","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\ns : Set Y\nhs : StableUnderSpecialization s\nhf : Continuous f\n⊢ StableUnderSpecialization (Set.preimage f s)","decl":"lemma StableUnderSpecialization.preimage {s : Set Y}\n    (hs : StableUnderSpecialization s) (hf : Continuous f) :\n    StableUnderSpecialization (f ⁻¹' s) :=\n  IsLowerSet.preimage hs hf.specialization_monotone\n\n"}
{"name":"StableUnderGeneralization.preimage","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\ns : Set Y\nhs : StableUnderGeneralization s\nhf : Continuous f\n⊢ StableUnderGeneralization (Set.preimage f s)","decl":"lemma StableUnderGeneralization.preimage {s : Set Y}\n    (hs : StableUnderGeneralization s) (hf : Continuous f) :\n    StableUnderGeneralization (f ⁻¹' s) :=\n  IsUpperSet.preimage hs hf.specialization_monotone\n\n"}
{"name":"specializingMap_iff_closure_singleton_subset","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\n⊢ Iff (SpecializingMap f) (∀ (x : X), HasSubset.Subset (closure (Singleton.singleton (f x))) (Set.image f (closure (Singleton.singleton x))))","decl":"lemma specializingMap_iff_closure_singleton_subset :\n    SpecializingMap f ↔ ∀ x, closure {f x} ⊆ f '' closure {x} := by\n  simp only [SpecializingMap, Relation.Fibration, flip, specializes_iff_mem_closure]; rfl\n\n"}
{"name":"SpecializingMap.closure_singleton_subset","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\na✝ : SpecializingMap f\nx : X\n⊢ HasSubset.Subset (closure (Singleton.singleton (f x))) (Set.image f (closure (Singleton.singleton x)))","decl":"alias ⟨SpecializingMap.closure_singleton_subset, _⟩ := specializingMap_iff_closure_singleton_subset\n\n"}
{"name":"SpecializingMap.stableUnderSpecialization_image","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nhf : SpecializingMap f\ns : Set X\nhs : StableUnderSpecialization s\n⊢ StableUnderSpecialization (Set.image f s)","decl":"lemma SpecializingMap.stableUnderSpecialization_image (hf : SpecializingMap f)\n    {s : Set X} (hs : StableUnderSpecialization s) : StableUnderSpecialization (f '' s) :=\n  IsLowerSet.image_fibration hf hs\n\n"}
{"name":"StableUnderSpecialization.image","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nhf : SpecializingMap f\ns : Set X\nhs : StableUnderSpecialization s\n⊢ StableUnderSpecialization (Set.image f s)","decl":"alias StableUnderSpecialization.image := SpecializingMap.stableUnderSpecialization_image\n\n"}
{"name":"specializingMap_iff_stableUnderSpecialization_image_singleton","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\n⊢ Iff (SpecializingMap f) (∀ (x : X), StableUnderSpecialization (Set.image f (closure (Singleton.singleton x))))","decl":"lemma specializingMap_iff_stableUnderSpecialization_image_singleton :\n    SpecializingMap f ↔ ∀ x, StableUnderSpecialization (f '' closure {x}) := by\n  simpa only [closure_singleton_eq_Iic] using Relation.fibration_iff_isLowerSet_image_Iic\n\n"}
{"name":"specializingMap_iff_stableUnderSpecialization_image","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\n⊢ Iff (SpecializingMap f) (∀ (s : Set X), StableUnderSpecialization s → StableUnderSpecialization (Set.image f s))","decl":"lemma specializingMap_iff_stableUnderSpecialization_image :\n    SpecializingMap f ↔ ∀ s, StableUnderSpecialization s → StableUnderSpecialization (f '' s) :=\n  Relation.fibration_iff_isLowerSet_image\n\n"}
{"name":"specializingMap_iff_closure_singleton","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nhf : Continuous f\n⊢ Iff (SpecializingMap f) (∀ (x : X), Eq (Set.image f (closure (Singleton.singleton x))) (closure (Singleton.singleton (f x))))","decl":"lemma specializingMap_iff_closure_singleton (hf : Continuous f) :\n    SpecializingMap f ↔ ∀ x, f '' closure {x} = closure {f x} := by\n  simpa only [closure_singleton_eq_Iic] using\n    Relation.fibration_iff_image_Iic hf.specialization_monotone\n\n"}
{"name":"specializingMap_iff_isClosed_image_closure_singleton","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nhf : Continuous f\n⊢ Iff (SpecializingMap f) (∀ (x : X), IsClosed (Set.image f (closure (Singleton.singleton x))))","decl":"lemma specializingMap_iff_isClosed_image_closure_singleton (hf : Continuous f) :\n    SpecializingMap f ↔ ∀ x, IsClosed (f '' closure {x}) := by\n  refine ⟨fun h x ↦ ?_, fun h ↦ specializingMap_iff_stableUnderSpecialization_image_singleton.mpr\n    (fun x ↦ (h x).stableUnderSpecialization)⟩\n  rw [(specializingMap_iff_closure_singleton hf).mp h x]\n  exact isClosed_closure\n\n"}
{"name":"SpecializingMap.comp","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\nf : X → Y\ng : Y → Z\nhf : SpecializingMap f\nhg : SpecializingMap g\n⊢ SpecializingMap (Function.comp g f)","decl":"lemma SpecializingMap.comp {f : X → Y} {g : Y → Z}\n    (hf : SpecializingMap f) (hg : SpecializingMap g) :\n    SpecializingMap (g ∘ f) := by\n  simp only [specializingMap_iff_stableUnderSpecialization_image, Set.image_comp] at *\n  exact fun s h ↦ hg _ (hf  _ h)\n\n"}
{"name":"IsClosedMap.specializingMap","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nhf : IsClosedMap f\n⊢ SpecializingMap f","decl":"lemma IsClosedMap.specializingMap (hf : IsClosedMap f) : SpecializingMap f :=\n  specializingMap_iff_stableUnderSpecialization_image_singleton.mpr <|\n    fun _ ↦ (hf _ isClosed_closure).stableUnderSpecialization\n\n"}
{"name":"Topology.IsInducing.specializingMap","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nhf : Topology.IsInducing f\nh : StableUnderSpecialization (Set.range f)\n⊢ SpecializingMap f","decl":"lemma Topology.IsInducing.specializingMap (hf : IsInducing f)\n    (h : StableUnderSpecialization (range f)) : SpecializingMap f := by\n  intros x y e\n  obtain ⟨y, rfl⟩ := h e ⟨x, rfl⟩\n  exact ⟨_, hf.specializes_iff.mp e, rfl⟩\n\n"}
{"name":"Inducing.specializingMap","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nhf : Topology.IsInducing f\nh : StableUnderSpecialization (Set.range f)\n⊢ SpecializingMap f","decl":"@[deprecated (since := \"2024-10-28\")] alias Inducing.specializingMap := IsInducing.specializingMap\n\n"}
{"name":"Topology.IsInducing.generalizingMap","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nhf : Topology.IsInducing f\nh : StableUnderGeneralization (Set.range f)\n⊢ GeneralizingMap f","decl":"lemma Topology.IsInducing.generalizingMap (hf : IsInducing f)\n    (h : StableUnderGeneralization (range f)) : GeneralizingMap f := by\n  intros x y e\n  obtain ⟨y, rfl⟩ := h e ⟨x, rfl⟩\n  exact ⟨_, hf.specializes_iff.mp e, rfl⟩\n\n"}
{"name":"Inducing.generalizingMap","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nhf : Topology.IsInducing f\nh : StableUnderGeneralization (Set.range f)\n⊢ GeneralizingMap f","decl":"@[deprecated (since := \"2024-10-28\")] alias Inducing.generalizingMap := IsInducing.generalizingMap\n\n"}
{"name":"IsOpenEmbedding.generalizingMap","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nhf : Topology.IsOpenEmbedding f\n⊢ GeneralizingMap f","decl":"lemma IsOpenEmbedding.generalizingMap (hf : IsOpenEmbedding f) : GeneralizingMap f :=\n  hf.isInducing.generalizingMap hf.isOpen_range.stableUnderGeneralization\n\n"}
{"name":"OpenEmbedding.generalizingMap","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nhf : Topology.IsOpenEmbedding f\n⊢ GeneralizingMap f","decl":"@[deprecated (since := \"2024-10-18\")]\nalias OpenEmbedding.generalizingMap := IsOpenEmbedding.generalizingMap\n\n"}
{"name":"SpecializingMap.stableUnderSpecialization_range","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nh : SpecializingMap f\n⊢ StableUnderSpecialization (Set.range f)","decl":"lemma SpecializingMap.stableUnderSpecialization_range (h : SpecializingMap f) :\n    StableUnderSpecialization (range f) :=\n  @image_univ _ _ f ▸ stableUnderSpecialization_univ.image h\n\n"}
{"name":"GeneralizingMap.stableUnderGeneralization_image","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nhf : GeneralizingMap f\ns : Set X\nhs : StableUnderGeneralization s\n⊢ StableUnderGeneralization (Set.image f s)","decl":"lemma GeneralizingMap.stableUnderGeneralization_image (hf : GeneralizingMap f) {s : Set X}\n    (hs : StableUnderGeneralization s) : StableUnderGeneralization (f '' s) :=\n  IsUpperSet.image_fibration hf hs\n\n"}
{"name":"GeneralizingMap_iff_stableUnderGeneralization_image","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\n⊢ Iff (GeneralizingMap f) (∀ (s : Set X), StableUnderGeneralization s → StableUnderGeneralization (Set.image f s))","decl":"lemma GeneralizingMap_iff_stableUnderGeneralization_image :\n    GeneralizingMap f ↔ ∀ s, StableUnderGeneralization s → StableUnderGeneralization (f '' s) :=\n  Relation.fibration_iff_isUpperSet_image\n\n"}
{"name":"StableUnderGeneralization.image","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nhf : GeneralizingMap f\ns : Set X\nhs : StableUnderGeneralization s\n⊢ StableUnderGeneralization (Set.image f s)","decl":"alias StableUnderGeneralization.image := GeneralizingMap.stableUnderGeneralization_image\n\n"}
{"name":"GeneralizingMap.stableUnderGeneralization_range","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nh : GeneralizingMap f\n⊢ StableUnderGeneralization (Set.range f)","decl":"lemma GeneralizingMap.stableUnderGeneralization_range (h : GeneralizingMap f) :\n    StableUnderGeneralization (range f) :=\n  @image_univ _ _ f ▸ stableUnderGeneralization_univ.image h\n\n"}
{"name":"GeneralizingMap.comp","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\nf : X → Y\ng : Y → Z\nhf : GeneralizingMap f\nhg : GeneralizingMap g\n⊢ GeneralizingMap (Function.comp g f)","decl":"lemma GeneralizingMap.comp {f : X → Y} {g : Y → Z}\n    (hf : GeneralizingMap f) (hg : GeneralizingMap g) :\n    GeneralizingMap (g ∘ f) := by\n  simp only [GeneralizingMap_iff_stableUnderGeneralization_image, Set.image_comp] at *\n  exact fun s h ↦ hg _ (hf  _ h)\n\n"}
{"name":"inseparable_def","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\n⊢ Iff (Inseparable x y) (Eq (nhds x) (nhds y))","decl":"theorem inseparable_def : (x ~ᵢ y) ↔ 𝓝 x = 𝓝 y :=\n  Iff.rfl\n\n"}
{"name":"inseparable_iff_specializes_and","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\n⊢ Iff (Inseparable x y) (And (Specializes x y) (Specializes y x))","decl":"theorem inseparable_iff_specializes_and : (x ~ᵢ y) ↔ x ⤳ y ∧ y ⤳ x :=\n  le_antisymm_iff\n\n"}
{"name":"Inseparable.specializes","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\nh : Inseparable x y\n⊢ Specializes x y","decl":"theorem Inseparable.specializes (h : x ~ᵢ y) : x ⤳ y := h.le\n\n"}
{"name":"Inseparable.specializes'","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\nh : Inseparable x y\n⊢ Specializes y x","decl":"theorem Inseparable.specializes' (h : x ~ᵢ y) : y ⤳ x := h.ge\n\n"}
{"name":"Specializes.antisymm","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\nh₁ : Specializes x y\nh₂ : Specializes y x\n⊢ Inseparable x y","decl":"theorem Specializes.antisymm (h₁ : x ⤳ y) (h₂ : y ⤳ x) : x ~ᵢ y :=\n  le_antisymm h₁ h₂\n\n"}
{"name":"inseparable_iff_forall_isOpen","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\n⊢ Iff (Inseparable x y) (∀ (s : Set X), IsOpen s → Iff (Membership.mem s x) (Membership.mem s y))","decl":"theorem inseparable_iff_forall_isOpen : (x ~ᵢ y) ↔ ∀ s : Set X, IsOpen s → (x ∈ s ↔ y ∈ s) := by\n  simp only [inseparable_iff_specializes_and, specializes_iff_forall_open, ← forall_and, ← iff_def,\n    Iff.comm]\n\n"}
{"name":"inseparable_iff_forall_open","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\n⊢ Iff (Inseparable x y) (∀ (s : Set X), IsOpen s → Iff (Membership.mem s x) (Membership.mem s y))","decl":"@[deprecated (since := \"2024-11-18\")] alias\ninseparable_iff_forall_open := inseparable_iff_forall_isOpen\n\n"}
{"name":"not_inseparable_iff_exists_open","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\n⊢ Iff (Not (Inseparable x y)) (Exists fun s => And (IsOpen s) (Xor' (Membership.mem s x) (Membership.mem s y)))","decl":"theorem not_inseparable_iff_exists_open :\n    ¬(x ~ᵢ y) ↔ ∃ s : Set X, IsOpen s ∧ Xor' (x ∈ s) (y ∈ s) := by\n  simp [inseparable_iff_forall_isOpen, ← xor_iff_not_iff]\n\n"}
{"name":"inseparable_iff_forall_isClosed","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\n⊢ Iff (Inseparable x y) (∀ (s : Set X), IsClosed s → Iff (Membership.mem s x) (Membership.mem s y))","decl":"theorem inseparable_iff_forall_isClosed : (x ~ᵢ y) ↔ ∀ s : Set X, IsClosed s → (x ∈ s ↔ y ∈ s) := by\n  simp only [inseparable_iff_specializes_and, specializes_iff_forall_closed, ← forall_and, ←\n    iff_def]\n"}
{"name":"inseparable_iff_forall_closed","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\n⊢ Iff (Inseparable x y) (∀ (s : Set X), IsClosed s → Iff (Membership.mem s x) (Membership.mem s y))","decl":"@[deprecated (since := \"2024-11-18\")] alias\ninseparable_iff_forall_closed := inseparable_iff_forall_isClosed\n\n"}
{"name":"inseparable_iff_mem_closure","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\n⊢ Iff (Inseparable x y) (And (Membership.mem (closure (Singleton.singleton y)) x) (Membership.mem (closure (Singleton.singleton x)) y))","decl":"theorem inseparable_iff_mem_closure :\n    (x ~ᵢ y) ↔ x ∈ closure ({y} : Set X) ∧ y ∈ closure ({x} : Set X) :=\n  inseparable_iff_specializes_and.trans <| by simp only [specializes_iff_mem_closure, and_comm]\n\n"}
{"name":"inseparable_iff_closure_eq","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\n⊢ Iff (Inseparable x y) (Eq (closure (Singleton.singleton x)) (closure (Singleton.singleton y)))","decl":"theorem inseparable_iff_closure_eq : (x ~ᵢ y) ↔ closure ({x} : Set X) = closure {y} := by\n  simp only [inseparable_iff_specializes_and, specializes_iff_closure_subset, ← subset_antisymm_iff,\n    eq_comm]\n\n"}
{"name":"inseparable_of_nhdsWithin_eq","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\ns : Set X\nhx : Membership.mem s x\nhy : Membership.mem s y\nh : Eq (nhdsWithin x s) (nhdsWithin y s)\n⊢ Inseparable x y","decl":"theorem inseparable_of_nhdsWithin_eq (hx : x ∈ s) (hy : y ∈ s) (h : 𝓝[s] x = 𝓝[s] y) : x ~ᵢ y :=\n  (specializes_of_nhdsWithin h.le hx).antisymm (specializes_of_nhdsWithin h.ge hy)\n\n"}
{"name":"Topology.IsInducing.inseparable_iff","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nx y : X\nf : X → Y\nhf : Topology.IsInducing f\n⊢ Iff (Inseparable (f x) (f y)) (Inseparable x y)","decl":"theorem Topology.IsInducing.inseparable_iff (hf : IsInducing f) : (f x ~ᵢ f y) ↔ (x ~ᵢ y) := by\n  simp only [inseparable_iff_specializes_and, hf.specializes_iff]\n\n"}
{"name":"Inducing.inseparable_iff","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nx y : X\nf : X → Y\nhf : Topology.IsInducing f\n⊢ Iff (Inseparable (f x) (f y)) (Inseparable x y)","decl":"@[deprecated (since := \"2024-10-28\")] alias Inducing.inseparable_iff := IsInducing.inseparable_iff\n\n"}
{"name":"subtype_inseparable_iff","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\np : X → Prop\nx y : Subtype p\n⊢ Iff (Inseparable x y) (Inseparable ↑x ↑y)","decl":"theorem subtype_inseparable_iff {p : X → Prop} (x y : Subtype p) : (x ~ᵢ y) ↔ ((x : X) ~ᵢ y) :=\n  IsInducing.subtypeVal.inseparable_iff.symm\n\n"}
{"name":"inseparable_prod","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nx₁ x₂ : X\ny₁ y₂ : Y\n⊢ Iff (Inseparable { fst := x₁, snd := y₁ } { fst := x₂, snd := y₂ }) (And (Inseparable x₁ x₂) (Inseparable y₁ y₂))","decl":"@[simp] theorem inseparable_prod {x₁ x₂ : X} {y₁ y₂ : Y} :\n    ((x₁, y₁) ~ᵢ (x₂, y₂)) ↔ (x₁ ~ᵢ x₂) ∧ (y₁ ~ᵢ y₂) := by\n  simp only [Inseparable, nhds_prod_eq, prod_inj]\n\n"}
{"name":"Inseparable.prod","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nx₁ x₂ : X\ny₁ y₂ : Y\nhx : Inseparable x₁ x₂\nhy : Inseparable y₁ y₂\n⊢ Inseparable { fst := x₁, snd := y₁ } { fst := x₂, snd := y₂ }","decl":"theorem Inseparable.prod {x₁ x₂ : X} {y₁ y₂ : Y} (hx : x₁ ~ᵢ x₂) (hy : y₁ ~ᵢ y₂) :\n    (x₁, y₁) ~ᵢ (x₂, y₂) :=\n  inseparable_prod.2 ⟨hx, hy⟩\n\n"}
{"name":"inseparable_pi","module":"Mathlib.Topology.Inseparable","initialProofState":"ι : Type u_5\nπ : ι → Type u_6\ninst✝ : (i : ι) → TopologicalSpace (π i)\nf g : (i : ι) → π i\n⊢ Iff (Inseparable f g) (∀ (i : ι), Inseparable (f i) (g i))","decl":"@[simp]\ntheorem inseparable_pi {f g : ∀ i, π i} : (f ~ᵢ g) ↔ ∀ i, f i ~ᵢ g i := by\n  simp only [Inseparable, nhds_pi, funext_iff, pi_inj]\n\n"}
{"name":"Inseparable.refl","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx : X\n⊢ Inseparable x x","decl":"@[refl]\ntheorem refl (x : X) : x ~ᵢ x :=\n  Eq.refl (𝓝 x)\n\n"}
{"name":"Inseparable.rfl","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx : X\n⊢ Inseparable x x","decl":"theorem rfl : x ~ᵢ x :=\n  refl x\n\n"}
{"name":"Inseparable.of_eq","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\ne : Eq x y\n⊢ Inseparable x y","decl":"theorem of_eq (e : x = y) : Inseparable x y :=\n  e ▸ refl x\n\n"}
{"name":"Inseparable.symm","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\nh : Inseparable x y\n⊢ Inseparable y x","decl":"@[symm]\nnonrec theorem symm (h : x ~ᵢ y) : y ~ᵢ x := h.symm\n\n"}
{"name":"Inseparable.trans","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y z : X\nh₁ : Inseparable x y\nh₂ : Inseparable y z\n⊢ Inseparable x z","decl":"@[trans]\nnonrec theorem trans (h₁ : x ~ᵢ y) (h₂ : y ~ᵢ z) : x ~ᵢ z := h₁.trans h₂\n\n"}
{"name":"Inseparable.nhds_eq","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\nh : Inseparable x y\n⊢ Eq (nhds x) (nhds y)","decl":"theorem nhds_eq (h : x ~ᵢ y) : 𝓝 x = 𝓝 y := h\n\n"}
{"name":"Inseparable.mem_open_iff","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\ns : Set X\nh : Inseparable x y\nhs : IsOpen s\n⊢ Iff (Membership.mem s x) (Membership.mem s y)","decl":"theorem mem_open_iff (h : x ~ᵢ y) (hs : IsOpen s) : x ∈ s ↔ y ∈ s :=\n  inseparable_iff_forall_isOpen.1 h s hs\n\n"}
{"name":"Inseparable.mem_closed_iff","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\ns : Set X\nh : Inseparable x y\nhs : IsClosed s\n⊢ Iff (Membership.mem s x) (Membership.mem s y)","decl":"theorem mem_closed_iff (h : x ~ᵢ y) (hs : IsClosed s) : x ∈ s ↔ y ∈ s :=\n  inseparable_iff_forall_isClosed.1 h s hs\n\n"}
{"name":"Inseparable.map_of_continuousAt","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nx y : X\nf : X → Y\nh : Inseparable x y\nhx : ContinuousAt f x\nhy : ContinuousAt f y\n⊢ Inseparable (f x) (f y)","decl":"theorem map_of_continuousAt (h : x ~ᵢ y) (hx : ContinuousAt f x) (hy : ContinuousAt f y) :\n    f x ~ᵢ f y :=\n  (h.specializes.map_of_continuousAt hy).antisymm (h.specializes'.map_of_continuousAt hx)\n\n"}
{"name":"Inseparable.map","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nx y : X\nf : X → Y\nh : Inseparable x y\nhf : Continuous f\n⊢ Inseparable (f x) (f y)","decl":"theorem map (h : x ~ᵢ y) (hf : Continuous f) : f x ~ᵢ f y :=\n  h.map_of_continuousAt hf.continuousAt hf.continuousAt\n\n"}
{"name":"IsClosed.not_inseparable","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\ns : Set X\nhs : IsClosed s\nhx : Membership.mem s x\nhy : Not (Membership.mem s y)\n⊢ Not (Inseparable x y)","decl":"theorem IsClosed.not_inseparable (hs : IsClosed s) (hx : x ∈ s) (hy : y ∉ s) : ¬(x ~ᵢ y) := fun h =>\n  hy <| (h.mem_closed_iff hs).1 hx\n\n"}
{"name":"IsOpen.not_inseparable","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\ns : Set X\nhs : IsOpen s\nhx : Membership.mem s x\nhy : Not (Membership.mem s y)\n⊢ Not (Inseparable x y)","decl":"theorem IsOpen.not_inseparable (hs : IsOpen s) (hx : x ∈ s) (hy : y ∉ s) : ¬(x ~ᵢ y) := fun h =>\n  hy <| (h.mem_open_iff hs).1 hx\n\n"}
{"name":"SeparationQuotient.isQuotientMap_mk","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\n⊢ Topology.IsQuotientMap SeparationQuotient.mk","decl":"theorem isQuotientMap_mk : IsQuotientMap (mk : X → SeparationQuotient X) :=\n  isQuotientMap_quot_mk\n\n"}
{"name":"SeparationQuotient.quotientMap_mk","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\n⊢ Topology.IsQuotientMap SeparationQuotient.mk","decl":"@[deprecated (since := \"2024-10-22\")]\nalias quotientMap_mk := isQuotientMap_mk\n\n"}
{"name":"SeparationQuotient.continuous_mk","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\n⊢ Continuous SeparationQuotient.mk","decl":"@[fun_prop, continuity]\ntheorem continuous_mk : Continuous (mk : X → SeparationQuotient X) :=\n  continuous_quot_mk\n\n"}
{"name":"SeparationQuotient.mk_eq_mk","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\n⊢ Iff (Eq (SeparationQuotient.mk x) (SeparationQuotient.mk y)) (Inseparable x y)","decl":"@[simp]\ntheorem mk_eq_mk : mk x = mk y ↔ (x ~ᵢ y) :=\n  Quotient.eq''\n\n"}
{"name":"SeparationQuotient.surjective_mk","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\n⊢ Function.Surjective SeparationQuotient.mk","decl":"theorem surjective_mk : Surjective (mk : X → SeparationQuotient X) :=\n  Quot.mk_surjective\n\n"}
{"name":"SeparationQuotient.range_mk","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\n⊢ Eq (Set.range SeparationQuotient.mk) Set.univ","decl":"@[simp]\ntheorem range_mk : range (mk : X → SeparationQuotient X) = univ :=\n  surjective_mk.range_eq\n\n"}
{"name":"SeparationQuotient.instNonempty","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : Nonempty X\n⊢ Nonempty (SeparationQuotient X)","decl":"instance [Nonempty X] : Nonempty (SeparationQuotient X) :=\n  Nonempty.map mk ‹_›\n\n"}
{"name":"SeparationQuotient.instSubsingleton","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : Subsingleton X\n⊢ Subsingleton (SeparationQuotient X)","decl":"instance [Subsingleton X] : Subsingleton (SeparationQuotient X) :=\n  surjective_mk.subsingleton\n\n"}
{"name":"SeparationQuotient.mk_zero","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : Zero X\n⊢ Eq (SeparationQuotient.mk 0) 0","decl":"@[to_additive (attr := simp)] theorem mk_one [One X] : mk (1 : X) = 1 := rfl\n\n"}
{"name":"SeparationQuotient.mk_one","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : One X\n⊢ Eq (SeparationQuotient.mk 1) 1","decl":"@[to_additive (attr := simp)] theorem mk_one [One X] : mk (1 : X) = 1 := rfl\n\n"}
{"name":"SeparationQuotient.preimage_image_mk_open","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set X\nhs : IsOpen s\n⊢ Eq (Set.preimage SeparationQuotient.mk (Set.image SeparationQuotient.mk s)) s","decl":"theorem preimage_image_mk_open (hs : IsOpen s) : mk ⁻¹' (mk '' s) = s := by\n  refine Subset.antisymm ?_ (subset_preimage_image _ _)\n  rintro x ⟨y, hys, hxy⟩\n  exact ((mk_eq_mk.1 hxy).mem_open_iff hs).1 hys\n\n"}
{"name":"SeparationQuotient.isOpenMap_mk","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\n⊢ IsOpenMap SeparationQuotient.mk","decl":"theorem isOpenMap_mk : IsOpenMap (mk : X → SeparationQuotient X) := fun s hs =>\n  isQuotientMap_mk.isOpen_preimage.1 <| by rwa [preimage_image_mk_open hs]\n\n"}
{"name":"SeparationQuotient.isOpenQuotientMap_mk","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\n⊢ IsOpenQuotientMap SeparationQuotient.mk","decl":"theorem isOpenQuotientMap_mk : IsOpenQuotientMap (mk : X → SeparationQuotient X) :=\n  ⟨surjective_mk, continuous_mk, isOpenMap_mk⟩\n\n"}
{"name":"SeparationQuotient.preimage_image_mk_closed","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set X\nhs : IsClosed s\n⊢ Eq (Set.preimage SeparationQuotient.mk (Set.image SeparationQuotient.mk s)) s","decl":"theorem preimage_image_mk_closed (hs : IsClosed s) : mk ⁻¹' (mk '' s) = s := by\n  refine Subset.antisymm ?_ (subset_preimage_image _ _)\n  rintro x ⟨y, hys, hxy⟩\n  exact ((mk_eq_mk.1 hxy).mem_closed_iff hs).1 hys\n\n"}
{"name":"SeparationQuotient.isInducing_mk","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\n⊢ Topology.IsInducing SeparationQuotient.mk","decl":"theorem isInducing_mk : IsInducing (mk : X → SeparationQuotient X) :=\n  ⟨le_antisymm (continuous_iff_le_induced.1 continuous_mk) fun s hs =>\n      ⟨mk '' s, isOpenMap_mk s hs, preimage_image_mk_open hs⟩⟩\n\n"}
{"name":"SeparationQuotient.inducing_mk","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\n⊢ Topology.IsInducing SeparationQuotient.mk","decl":"@[deprecated (since := \"2024-10-28\")] alias inducing_mk := isInducing_mk\n\n"}
{"name":"SeparationQuotient.isClosedMap_mk","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\n⊢ IsClosedMap SeparationQuotient.mk","decl":"theorem isClosedMap_mk : IsClosedMap (mk : X → SeparationQuotient X) :=\n  isInducing_mk.isClosedMap <| by rw [range_mk]; exact isClosed_univ\n\n"}
{"name":"SeparationQuotient.comap_mk_nhds_mk","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx : X\n⊢ Eq (Filter.comap SeparationQuotient.mk (nhds (SeparationQuotient.mk x))) (nhds x)","decl":"@[simp]\ntheorem comap_mk_nhds_mk : comap mk (𝓝 (mk x)) = 𝓝 x :=\n  (isInducing_mk.nhds_eq_comap _).symm\n\n"}
{"name":"SeparationQuotient.comap_mk_nhdsSet_image","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ Eq (Filter.comap SeparationQuotient.mk (nhdsSet (Set.image SeparationQuotient.mk s))) (nhdsSet s)","decl":"@[simp]\ntheorem comap_mk_nhdsSet_image : comap mk (𝓝ˢ (mk '' s)) = 𝓝ˢ s :=\n  (isInducing_mk.nhdsSet_eq_comap _).symm\n\n"}
{"name":"SeparationQuotient.map_mk_nhds","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx : X\n⊢ Eq (Filter.map SeparationQuotient.mk (nhds x)) (nhds (SeparationQuotient.mk x))","decl":"theorem map_mk_nhds : map mk (𝓝 x) = 𝓝 (mk x) := by\n  rw [← comap_mk_nhds_mk, map_comap_of_surjective surjective_mk]\n\n"}
{"name":"SeparationQuotient.map_mk_nhdsSet","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ Eq (Filter.map SeparationQuotient.mk (nhdsSet s)) (nhdsSet (Set.image SeparationQuotient.mk s))","decl":"theorem map_mk_nhdsSet : map mk (𝓝ˢ s) = 𝓝ˢ (mk '' s) := by\n  rw [← comap_mk_nhdsSet_image, map_comap_of_surjective surjective_mk]\n\n"}
{"name":"SeparationQuotient.comap_mk_nhdsSet","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nt : Set (SeparationQuotient X)\n⊢ Eq (Filter.comap SeparationQuotient.mk (nhdsSet t)) (nhdsSet (Set.preimage SeparationQuotient.mk t))","decl":"theorem comap_mk_nhdsSet : comap mk (𝓝ˢ t) = 𝓝ˢ (mk ⁻¹' t) := by\n  conv_lhs => rw [← image_preimage_eq t surjective_mk, comap_mk_nhdsSet_image]\n\n"}
{"name":"SeparationQuotient.preimage_mk_closure","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nt : Set (SeparationQuotient X)\n⊢ Eq (Set.preimage SeparationQuotient.mk (closure t)) (closure (Set.preimage SeparationQuotient.mk t))","decl":"theorem preimage_mk_closure : mk ⁻¹' closure t = closure (mk ⁻¹' t) :=\n  isOpenMap_mk.preimage_closure_eq_closure_preimage continuous_mk t\n\n"}
{"name":"SeparationQuotient.preimage_mk_interior","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nt : Set (SeparationQuotient X)\n⊢ Eq (Set.preimage SeparationQuotient.mk (interior t)) (interior (Set.preimage SeparationQuotient.mk t))","decl":"theorem preimage_mk_interior : mk ⁻¹' interior t = interior (mk ⁻¹' t) :=\n  isOpenMap_mk.preimage_interior_eq_interior_preimage continuous_mk t\n\n"}
{"name":"SeparationQuotient.preimage_mk_frontier","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nt : Set (SeparationQuotient X)\n⊢ Eq (Set.preimage SeparationQuotient.mk (frontier t)) (frontier (Set.preimage SeparationQuotient.mk t))","decl":"theorem preimage_mk_frontier : mk ⁻¹' frontier t = frontier (mk ⁻¹' t) :=\n  isOpenMap_mk.preimage_frontier_eq_frontier_preimage continuous_mk t\n\n"}
{"name":"SeparationQuotient.image_mk_closure","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ Eq (Set.image SeparationQuotient.mk (closure s)) (closure (Set.image SeparationQuotient.mk s))","decl":"theorem image_mk_closure : mk '' closure s = closure (mk '' s) :=\n  (image_closure_subset_closure_image continuous_mk).antisymm <|\n    isClosedMap_mk.closure_image_subset _\n\n"}
{"name":"SeparationQuotient.map_prod_map_mk_nhds","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nx : X\ny : Y\n⊢ Eq (Filter.map (Prod.map SeparationQuotient.mk SeparationQuotient.mk) (nhds { fst := x, snd := y })) (nhds { fst := SeparationQuotient.mk x, snd := SeparationQuotient.mk y })","decl":"theorem map_prod_map_mk_nhds (x : X) (y : Y) :\n    map (Prod.map mk mk) (𝓝 (x, y)) = 𝓝 (mk x, mk y) := by\n  rw [nhds_prod_eq, ← prod_map_map_eq', map_mk_nhds, map_mk_nhds, nhds_prod_eq]\n\n"}
{"name":"SeparationQuotient.map_mk_nhdsWithin_preimage","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set (SeparationQuotient X)\nx : X\n⊢ Eq (Filter.map SeparationQuotient.mk (nhdsWithin x (Set.preimage SeparationQuotient.mk s))) (nhdsWithin (SeparationQuotient.mk x) s)","decl":"theorem map_mk_nhdsWithin_preimage (s : Set (SeparationQuotient X)) (x : X) :\n    map mk (𝓝[mk ⁻¹' s] x) = 𝓝[s] mk x := by\n  rw [nhdsWithin, ← comap_principal, Filter.push_pull, nhdsWithin, map_mk_nhds]\n\n"}
{"name":"SeparationQuotient.isQuotientMap_prodMap_mk","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\n⊢ Topology.IsQuotientMap (Prod.map SeparationQuotient.mk SeparationQuotient.mk)","decl":"/-- The map `(x, y) ↦ (mk x, mk y)` is a quotient map. -/\ntheorem isQuotientMap_prodMap_mk : IsQuotientMap (Prod.map mk mk : X × Y → _) :=\n  (isOpenQuotientMap_mk.prodMap isOpenQuotientMap_mk).isQuotientMap\n\n"}
{"name":"SeparationQuotient.quotientMap_prodMap_mk","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\n⊢ Topology.IsQuotientMap (Prod.map SeparationQuotient.mk SeparationQuotient.mk)","decl":"@[deprecated (since := \"2024-10-22\")]\nalias quotientMap_prodMap_mk := isQuotientMap_prodMap_mk\n\n"}
{"name":"SeparationQuotient.lift_mk","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nα : Type u_4\ninst✝ : TopologicalSpace X\nf : X → α\nhf : ∀ (x y : X), Inseparable x y → Eq (f x) (f y)\nx : X\n⊢ Eq (SeparationQuotient.lift f hf (SeparationQuotient.mk x)) (f x)","decl":"@[simp]\ntheorem lift_mk {f : X → α} (hf : ∀ x y, (x ~ᵢ y) → f x = f y) (x : X) : lift f hf (mk x) = f x :=\n  rfl\n\n"}
{"name":"SeparationQuotient.lift_comp_mk","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nα : Type u_4\ninst✝ : TopologicalSpace X\nf : X → α\nhf : ∀ (x y : X), Inseparable x y → Eq (f x) (f y)\n⊢ Eq (Function.comp (SeparationQuotient.lift f hf) SeparationQuotient.mk) f","decl":"@[simp]\ntheorem lift_comp_mk {f : X → α} (hf : ∀ x y, (x ~ᵢ y) → f x = f y) : lift f hf ∘ mk = f :=\n  rfl\n\n"}
{"name":"SeparationQuotient.tendsto_lift_nhds_mk","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nα : Type u_4\ninst✝ : TopologicalSpace X\nx : X\nf : X → α\nhf : ∀ (x y : X), Inseparable x y → Eq (f x) (f y)\nl : Filter α\n⊢ Iff (Filter.Tendsto (SeparationQuotient.lift f hf) (nhds (SeparationQuotient.mk x)) l) (Filter.Tendsto f (nhds x) l)","decl":"@[simp]\ntheorem tendsto_lift_nhds_mk {f : X → α} {hf : ∀ x y, (x ~ᵢ y) → f x = f y} {l : Filter α} :\n    Tendsto (lift f hf) (𝓝 <| mk x) l ↔ Tendsto f (𝓝 x) l := by\n  simp only [← map_mk_nhds, tendsto_map'_iff, lift_comp_mk]\n\n"}
{"name":"SeparationQuotient.tendsto_lift_nhdsWithin_mk","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nα : Type u_4\ninst✝ : TopologicalSpace X\nx : X\nf : X → α\nhf : ∀ (x y : X), Inseparable x y → Eq (f x) (f y)\ns : Set (SeparationQuotient X)\nl : Filter α\n⊢ Iff (Filter.Tendsto (SeparationQuotient.lift f hf) (nhdsWithin (SeparationQuotient.mk x) s) l) (Filter.Tendsto f (nhdsWithin x (Set.preimage SeparationQuotient.mk s)) l)","decl":"@[simp]\ntheorem tendsto_lift_nhdsWithin_mk {f : X → α} {hf : ∀ x y, (x ~ᵢ y) → f x = f y}\n    {s : Set (SeparationQuotient X)} {l : Filter α} :\n    Tendsto (lift f hf) (𝓝[s] mk x) l ↔ Tendsto f (𝓝[mk ⁻¹' s] x) l := by\n  simp only [← map_mk_nhdsWithin_preimage, tendsto_map'_iff, lift_comp_mk]\n\n"}
{"name":"SeparationQuotient.continuousAt_lift","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nx : X\nf : X → Y\nhf : ∀ (x y : X), Inseparable x y → Eq (f x) (f y)\n⊢ Iff (ContinuousAt (SeparationQuotient.lift f hf) (SeparationQuotient.mk x)) (ContinuousAt f x)","decl":"@[simp]\ntheorem continuousAt_lift {hf : ∀ x y, (x ~ᵢ y) → f x = f y} :\n    ContinuousAt (lift f hf) (mk x) ↔ ContinuousAt f x :=\n  tendsto_lift_nhds_mk\n\n"}
{"name":"SeparationQuotient.continuousWithinAt_lift","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nx : X\nf : X → Y\nhf : ∀ (x y : X), Inseparable x y → Eq (f x) (f y)\ns : Set (SeparationQuotient X)\n⊢ Iff (ContinuousWithinAt (SeparationQuotient.lift f hf) s (SeparationQuotient.mk x)) (ContinuousWithinAt f (Set.preimage SeparationQuotient.mk s) x)","decl":"@[simp]\ntheorem continuousWithinAt_lift {hf : ∀ x y, (x ~ᵢ y) → f x = f y}\n    {s : Set (SeparationQuotient X)} :\n    ContinuousWithinAt (lift f hf) s (mk x) ↔ ContinuousWithinAt f (mk ⁻¹' s) x :=\n  tendsto_lift_nhdsWithin_mk\n\n"}
{"name":"SeparationQuotient.continuousOn_lift","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nhf : ∀ (x y : X), Inseparable x y → Eq (f x) (f y)\ns : Set (SeparationQuotient X)\n⊢ Iff (ContinuousOn (SeparationQuotient.lift f hf) s) (ContinuousOn f (Set.preimage SeparationQuotient.mk s))","decl":"@[simp]\ntheorem continuousOn_lift {hf : ∀ x y, (x ~ᵢ y) → f x = f y} {s : Set (SeparationQuotient X)} :\n    ContinuousOn (lift f hf) s ↔ ContinuousOn f (mk ⁻¹' s) := by\n  simp only [ContinuousOn, surjective_mk.forall, continuousWithinAt_lift, mem_preimage]\n\n"}
{"name":"SeparationQuotient.continuous_lift","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nhf : ∀ (x y : X), Inseparable x y → Eq (f x) (f y)\n⊢ Iff (Continuous (SeparationQuotient.lift f hf)) (Continuous f)","decl":"@[simp]\ntheorem continuous_lift {hf : ∀ x y, (x ~ᵢ y) → f x = f y} :\n    Continuous (lift f hf) ↔ Continuous f := by\n  simp only [continuous_iff_continuousOn_univ, continuousOn_lift, preimage_univ]\n\n"}
{"name":"SeparationQuotient.lift₂_mk","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\nα : Type u_4\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y → α\nhf : ∀ (a : X) (b : Y) (c : X) (d : Y), Inseparable a c → Inseparable b d → Eq (f a b) (f c d)\nx : X\ny : Y\n⊢ Eq (SeparationQuotient.lift₂ f hf (SeparationQuotient.mk x) (SeparationQuotient.mk y)) (f x y)","decl":"@[simp]\ntheorem lift₂_mk {f : X → Y → α} (hf : ∀ a b c d, (a ~ᵢ c) → (b ~ᵢ d) → f a b = f c d) (x : X)\n    (y : Y) : lift₂ f hf (mk x) (mk y) = f x y :=\n  rfl\n\n"}
{"name":"SeparationQuotient.tendsto_lift₂_nhds","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\nα : Type u_4\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y → α\nhf : ∀ (a : X) (b : Y) (c : X) (d : Y), Inseparable a c → Inseparable b d → Eq (f a b) (f c d)\nx : X\ny : Y\nl : Filter α\n⊢ Iff (Filter.Tendsto (Function.uncurry (SeparationQuotient.lift₂ f hf)) (nhds { fst := SeparationQuotient.mk x, snd := SeparationQuotient.mk y }) l) (Filter.Tendsto (Function.uncurry f) (nhds { fst := x, snd := y }) l)","decl":"@[simp]\ntheorem tendsto_lift₂_nhds {f : X → Y → α} {hf : ∀ a b c d, (a ~ᵢ c) → (b ~ᵢ d) → f a b = f c d}\n    {x : X} {y : Y} {l : Filter α} :\n    Tendsto (uncurry <| lift₂ f hf) (𝓝 (mk x, mk y)) l ↔ Tendsto (uncurry f) (𝓝 (x, y)) l := by\n  rw [← map_prod_map_mk_nhds, tendsto_map'_iff]\n  rfl\n\n"}
{"name":"SeparationQuotient.tendsto_lift₂_nhdsWithin","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\nα : Type u_4\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y → α\nhf : ∀ (a : X) (b : Y) (c : X) (d : Y), Inseparable a c → Inseparable b d → Eq (f a b) (f c d)\nx : X\ny : Y\ns : Set (Prod (SeparationQuotient X) (SeparationQuotient Y))\nl : Filter α\n⊢ Iff (Filter.Tendsto (Function.uncurry (SeparationQuotient.lift₂ f hf)) (nhdsWithin { fst := SeparationQuotient.mk x, snd := SeparationQuotient.mk y } s) l) (Filter.Tendsto (Function.uncurry f) (nhdsWithin { fst := x, snd := y } (Set.preimage (Prod.map SeparationQuotient.mk SeparationQuotient.mk) s)) l)","decl":"@[simp] theorem tendsto_lift₂_nhdsWithin {f : X → Y → α}\n    {hf : ∀ a b c d, (a ~ᵢ c) → (b ~ᵢ d) → f a b = f c d} {x : X} {y : Y}\n    {s : Set (SeparationQuotient X × SeparationQuotient Y)} {l : Filter α} :\n    Tendsto (uncurry <| lift₂ f hf) (𝓝[s] (mk x, mk y)) l ↔\n      Tendsto (uncurry f) (𝓝[Prod.map mk mk ⁻¹' s] (x, y)) l := by\n  rw [nhdsWithin, ← map_prod_map_mk_nhds, ← Filter.push_pull, comap_principal]\n  rfl\n\n"}
{"name":"SeparationQuotient.continuousAt_lift₂","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\nf : X → Y → Z\nhf : ∀ (a : X) (b : Y) (c : X) (d : Y), Inseparable a c → Inseparable b d → Eq (f a b) (f c d)\nx : X\ny : Y\n⊢ Iff (ContinuousAt (Function.uncurry (SeparationQuotient.lift₂ f hf)) { fst := SeparationQuotient.mk x, snd := SeparationQuotient.mk y }) (ContinuousAt (Function.uncurry f) { fst := x, snd := y })","decl":"@[simp]\ntheorem continuousAt_lift₂ {f : X → Y → Z} {hf : ∀ a b c d, (a ~ᵢ c) → (b ~ᵢ d) → f a b = f c d}\n    {x : X} {y : Y} :\n    ContinuousAt (uncurry <| lift₂ f hf) (mk x, mk y) ↔ ContinuousAt (uncurry f) (x, y) :=\n  tendsto_lift₂_nhds\n\n"}
{"name":"SeparationQuotient.continuousWithinAt_lift₂","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\nf : X → Y → Z\nhf : ∀ (a : X) (b : Y) (c : X) (d : Y), Inseparable a c → Inseparable b d → Eq (f a b) (f c d)\ns : Set (Prod (SeparationQuotient X) (SeparationQuotient Y))\nx : X\ny : Y\n⊢ Iff (ContinuousWithinAt (Function.uncurry (SeparationQuotient.lift₂ f hf)) s { fst := SeparationQuotient.mk x, snd := SeparationQuotient.mk y }) (ContinuousWithinAt (Function.uncurry f) (Set.preimage (Prod.map SeparationQuotient.mk SeparationQuotient.mk) s) { fst := x, snd := y })","decl":"@[simp] theorem continuousWithinAt_lift₂ {f : X → Y → Z}\n    {hf : ∀ a b c d, (a ~ᵢ c) → (b ~ᵢ d) → f a b = f c d}\n    {s : Set (SeparationQuotient X × SeparationQuotient Y)} {x : X} {y : Y} :\n    ContinuousWithinAt (uncurry <| lift₂ f hf) s (mk x, mk y) ↔\n      ContinuousWithinAt (uncurry f) (Prod.map mk mk ⁻¹' s) (x, y) :=\n  tendsto_lift₂_nhdsWithin\n\n"}
{"name":"SeparationQuotient.continuousOn_lift₂","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\nf : X → Y → Z\nhf : ∀ (a : X) (b : Y) (c : X) (d : Y), Inseparable a c → Inseparable b d → Eq (f a b) (f c d)\ns : Set (Prod (SeparationQuotient X) (SeparationQuotient Y))\n⊢ Iff (ContinuousOn (Function.uncurry (SeparationQuotient.lift₂ f hf)) s) (ContinuousOn (Function.uncurry f) (Set.preimage (Prod.map SeparationQuotient.mk SeparationQuotient.mk) s))","decl":"@[simp]\ntheorem continuousOn_lift₂ {f : X → Y → Z} {hf : ∀ a b c d, (a ~ᵢ c) → (b ~ᵢ d) → f a b = f c d}\n    {s : Set (SeparationQuotient X × SeparationQuotient Y)} :\n    ContinuousOn (uncurry <| lift₂ f hf) s ↔ ContinuousOn (uncurry f) (Prod.map mk mk ⁻¹' s) := by\n  simp_rw [ContinuousOn, (surjective_mk.prodMap surjective_mk).forall, Prod.forall, Prod.map,\n    continuousWithinAt_lift₂]\n  rfl\n\n"}
{"name":"SeparationQuotient.continuous_lift₂","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\nf : X → Y → Z\nhf : ∀ (a : X) (b : Y) (c : X) (d : Y), Inseparable a c → Inseparable b d → Eq (f a b) (f c d)\n⊢ Iff (Continuous (Function.uncurry (SeparationQuotient.lift₂ f hf))) (Continuous (Function.uncurry f))","decl":"@[simp]\ntheorem continuous_lift₂ {f : X → Y → Z} {hf : ∀ a b c d, (a ~ᵢ c) → (b ~ᵢ d) → f a b = f c d} :\n    Continuous (uncurry <| lift₂ f hf) ↔ Continuous (uncurry f) := by\n  simp only [continuous_iff_continuousOn_univ, continuousOn_lift₂, preimage_univ]\n\n"}
{"name":"continuous_congr_of_inseparable","module":"Mathlib.Topology.Inseparable","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf g : X → Y\nh : ∀ (x : X), Inseparable (f x) (g x)\n⊢ Iff (Continuous f) (Continuous g)","decl":"theorem continuous_congr_of_inseparable (h : ∀ x, f x ~ᵢ g x) :\n    Continuous f ↔ Continuous g := by\n  simp_rw [SeparationQuotient.isInducing_mk.continuous_iff (Y := Y)]\n  exact continuous_congr fun x ↦ SeparationQuotient.mk_eq_mk.mpr (h x)\n"}
