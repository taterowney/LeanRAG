{"name":"IsAddRegular.right","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_2\ninst✝ : Add R\nc : R\nself : IsAddRegular c\n⊢ IsAddRightRegular c","decl":"/-- An add-regular element is an element `c` such that addition by `c` both on the left and\non the right is injective. -/\nstructure IsAddRegular {R : Type*} [Add R] (c : R) : Prop where\n  /-- An add-regular element `c` is left-regular -/\n  left : IsAddLeftRegular c -- Porting note: It seems like to_additive is misbehaving\n  /-- An add-regular element `c` is right-regular -/\n  right : IsAddRightRegular c\n\n"}
{"name":"IsAddRegular.left","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_2\ninst✝ : Add R\nc : R\nself : IsAddRegular c\n⊢ IsAddLeftRegular c","decl":"/-- An add-regular element is an element `c` such that addition by `c` both on the left and\non the right is injective. -/\nstructure IsAddRegular {R : Type*} [Add R] (c : R) : Prop where\n  /-- An add-regular element `c` is left-regular -/\n  left : IsAddLeftRegular c -- Porting note: It seems like to_additive is misbehaving\n  /-- An add-regular element `c` is right-regular -/\n  right : IsAddRightRegular c\n\n"}
{"name":"IsRegular.right","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_1\ninst✝ : Mul R\nc : R\nself : IsRegular c\n⊢ IsRightRegular c","decl":"/-- A regular element is an element `c` such that multiplication by `c` both on the left and\non the right is injective. -/\nstructure IsRegular (c : R) : Prop where\n  /-- A regular element `c` is left-regular -/\n  left : IsLeftRegular c\n  /-- A regular element `c` is right-regular -/\n  right : IsRightRegular c\n\n"}
{"name":"IsRegular.left","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_1\ninst✝ : Mul R\nc : R\nself : IsRegular c\n⊢ IsLeftRegular c","decl":"/-- A regular element is an element `c` such that multiplication by `c` both on the left and\non the right is injective. -/\nstructure IsRegular (c : R) : Prop where\n  /-- A regular element `c` is left-regular -/\n  left : IsLeftRegular c\n  /-- A regular element `c` is right-regular -/\n  right : IsRightRegular c\n\n"}
{"name":"isAddRegular_iff","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_1\ninst✝ : Add R\nc : R\n⊢ Iff (IsAddRegular c) (And (IsAddLeftRegular c) (IsAddRightRegular c))","decl":"@[to_additive]\ntheorem isRegular_iff {c : R} : IsRegular c ↔ IsLeftRegular c ∧ IsRightRegular c :=\n  ⟨fun ⟨h1, h2⟩ => ⟨h1, h2⟩, fun ⟨h1, h2⟩ => ⟨h1, h2⟩⟩\n\n"}
{"name":"isRegular_iff","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_1\ninst✝ : Mul R\nc : R\n⊢ Iff (IsRegular c) (And (IsLeftRegular c) (IsRightRegular c))","decl":"@[to_additive]\ntheorem isRegular_iff {c : R} : IsRegular c ↔ IsLeftRegular c ∧ IsRightRegular c :=\n  ⟨fun ⟨h1, h2⟩ => ⟨h1, h2⟩, fun ⟨h1, h2⟩ => ⟨h1, h2⟩⟩\n\n"}
{"name":"MulLECancellable.isLeftRegular","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_1\ninst✝¹ : Mul R\ninst✝ : PartialOrder R\na : R\nha : MulLECancellable a\n⊢ IsLeftRegular a","decl":"@[to_additive]\nprotected theorem MulLECancellable.isLeftRegular [PartialOrder R] {a : R}\n    (ha : MulLECancellable a) : IsLeftRegular a :=\n  ha.Injective\n\n"}
{"name":"AddLECancellable.isAddLeftRegular","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_1\ninst✝¹ : Add R\ninst✝ : PartialOrder R\na : R\nha : AddLECancellable a\n⊢ IsAddLeftRegular a","decl":"@[to_additive]\nprotected theorem MulLECancellable.isLeftRegular [PartialOrder R] {a : R}\n    (ha : MulLECancellable a) : IsLeftRegular a :=\n  ha.Injective\n\n"}
{"name":"IsLeftRegular.right_of_commute","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_1\ninst✝ : Mul R\na : R\nca : ∀ (b : R), Commute a b\nh : IsLeftRegular a\n⊢ IsRightRegular a","decl":"theorem IsLeftRegular.right_of_commute {a : R}\n    (ca : ∀ b, Commute a b) (h : IsLeftRegular a) : IsRightRegular a :=\n  fun x y xy => h <| (ca x).trans <| xy.trans <| (ca y).symm\n\n"}
{"name":"IsRightRegular.left_of_commute","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_1\ninst✝ : Mul R\na : R\nca : ∀ (b : R), Commute a b\nh : IsRightRegular a\n⊢ IsLeftRegular a","decl":"theorem IsRightRegular.left_of_commute {a : R}\n    (ca : ∀ b, Commute a b) (h : IsRightRegular a) : IsLeftRegular a := by\n  simp_rw [@Commute.symm_iff R _ a] at ca\n  exact fun x y xy => h <| (ca x).trans <| xy.trans <| (ca y).symm\n\n"}
{"name":"Commute.isRightRegular_iff","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_1\ninst✝ : Mul R\na : R\nca : ∀ (b : R), Commute a b\n⊢ Iff (IsRightRegular a) (IsLeftRegular a)","decl":"theorem Commute.isRightRegular_iff {a : R} (ca : ∀ b, Commute a b) :\n    IsRightRegular a ↔ IsLeftRegular a :=\n  ⟨IsRightRegular.left_of_commute ca, IsLeftRegular.right_of_commute ca⟩\n\n"}
{"name":"Commute.isRegular_iff","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_1\ninst✝ : Mul R\na : R\nca : ∀ (b : R), Commute a b\n⊢ Iff (IsRegular a) (IsLeftRegular a)","decl":"theorem Commute.isRegular_iff {a : R} (ca : ∀ b, Commute a b) : IsRegular a ↔ IsLeftRegular a :=\n  ⟨fun h => h.left, fun h => ⟨h, h.right_of_commute ca⟩⟩\n\n"}
{"name":"IsLeftRegular.mul","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_1\ninst✝ : Semigroup R\na b : R\nlra : IsLeftRegular a\nlrb : IsLeftRegular b\n⊢ IsLeftRegular (HMul.hMul a b)","decl":"/-- In a semigroup, the product of left-regular elements is left-regular. -/\n@[to_additive \"In an additive semigroup, the sum of add-left-regular elements is add-left.regular.\"]\ntheorem IsLeftRegular.mul (lra : IsLeftRegular a) (lrb : IsLeftRegular b) : IsLeftRegular (a * b) :=\n  show Function.Injective (((a * b) * ·)) from comp_mul_left a b ▸ lra.comp lrb\n\n"}
{"name":"IsAddLeftRegular.add","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_1\ninst✝ : AddSemigroup R\na b : R\nlra : IsAddLeftRegular a\nlrb : IsAddLeftRegular b\n⊢ IsAddLeftRegular (HAdd.hAdd a b)","decl":"/-- In a semigroup, the product of left-regular elements is left-regular. -/\n@[to_additive \"In an additive semigroup, the sum of add-left-regular elements is add-left.regular.\"]\ntheorem IsLeftRegular.mul (lra : IsLeftRegular a) (lrb : IsLeftRegular b) : IsLeftRegular (a * b) :=\n  show Function.Injective (((a * b) * ·)) from comp_mul_left a b ▸ lra.comp lrb\n\n"}
{"name":"IsRightRegular.mul","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_1\ninst✝ : Semigroup R\na b : R\nrra : IsRightRegular a\nrrb : IsRightRegular b\n⊢ IsRightRegular (HMul.hMul a b)","decl":"/-- In a semigroup, the product of right-regular elements is right-regular. -/\n@[to_additive \"In an additive semigroup, the sum of add-right-regular elements is\nadd-right-regular.\"]\ntheorem IsRightRegular.mul (rra : IsRightRegular a) (rrb : IsRightRegular b) :\n    IsRightRegular (a * b) :=\n  show Function.Injective (· * (a * b)) from comp_mul_right b a ▸ rrb.comp rra\n\n"}
{"name":"IsAddRightRegular.add","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_1\ninst✝ : AddSemigroup R\na b : R\nrra : IsAddRightRegular a\nrrb : IsAddRightRegular b\n⊢ IsAddRightRegular (HAdd.hAdd a b)","decl":"/-- In a semigroup, the product of right-regular elements is right-regular. -/\n@[to_additive \"In an additive semigroup, the sum of add-right-regular elements is\nadd-right-regular.\"]\ntheorem IsRightRegular.mul (rra : IsRightRegular a) (rrb : IsRightRegular b) :\n    IsRightRegular (a * b) :=\n  show Function.Injective (· * (a * b)) from comp_mul_right b a ▸ rrb.comp rra\n\n"}
{"name":"IsAddRegular.add","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_1\ninst✝ : AddSemigroup R\na b : R\nrra : IsAddRegular a\nrrb : IsAddRegular b\n⊢ IsAddRegular (HAdd.hAdd a b)","decl":"/-- In a semigroup, the product of regular elements is regular. -/\n@[to_additive \"In an additive semigroup, the sum of add-regular elements is add-regular.\"]\ntheorem IsRegular.mul (rra : IsRegular a) (rrb : IsRegular b) :\n    IsRegular (a * b) :=\n  ⟨rra.left.mul rrb.left, rra.right.mul rrb.right⟩\n\n"}
{"name":"IsRegular.mul","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_1\ninst✝ : Semigroup R\na b : R\nrra : IsRegular a\nrrb : IsRegular b\n⊢ IsRegular (HMul.hMul a b)","decl":"/-- In a semigroup, the product of regular elements is regular. -/\n@[to_additive \"In an additive semigroup, the sum of add-regular elements is add-regular.\"]\ntheorem IsRegular.mul (rra : IsRegular a) (rrb : IsRegular b) :\n    IsRegular (a * b) :=\n  ⟨rra.left.mul rrb.left, rra.right.mul rrb.right⟩\n\n"}
{"name":"IsAddLeftRegular.of_add","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_1\ninst✝ : AddSemigroup R\na b : R\nab : IsAddLeftRegular (HAdd.hAdd a b)\n⊢ IsAddLeftRegular b","decl":"/-- If an element `b` becomes left-regular after multiplying it on the left by a left-regular\nelement, then `b` is left-regular. -/\n@[to_additive \"If an element `b` becomes add-left-regular after adding to it on the left\nan add-left-regular element, then `b` is add-left-regular.\"]\ntheorem IsLeftRegular.of_mul (ab : IsLeftRegular (a * b)) : IsLeftRegular b :=\n  Function.Injective.of_comp (f := (a * ·)) (by rwa [comp_mul_left a b])\n\n"}
{"name":"IsLeftRegular.of_mul","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_1\ninst✝ : Semigroup R\na b : R\nab : IsLeftRegular (HMul.hMul a b)\n⊢ IsLeftRegular b","decl":"/-- If an element `b` becomes left-regular after multiplying it on the left by a left-regular\nelement, then `b` is left-regular. -/\n@[to_additive \"If an element `b` becomes add-left-regular after adding to it on the left\nan add-left-regular element, then `b` is add-left-regular.\"]\ntheorem IsLeftRegular.of_mul (ab : IsLeftRegular (a * b)) : IsLeftRegular b :=\n  Function.Injective.of_comp (f := (a * ·)) (by rwa [comp_mul_left a b])\n\n"}
{"name":"add_isAddLeftRegular_iff","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_1\ninst✝ : AddSemigroup R\na b : R\nha : IsAddLeftRegular a\n⊢ Iff (IsAddLeftRegular (HAdd.hAdd a b)) (IsAddLeftRegular b)","decl":"/-- An element is left-regular if and only if multiplying it on the left by a left-regular element\nis left-regular. -/\n@[to_additive (attr := simp) \"An element is add-left-regular if and only if adding to it on the left\nan add-left-regular element is add-left-regular.\"]\ntheorem mul_isLeftRegular_iff (b : R) (ha : IsLeftRegular a) :\n    IsLeftRegular (a * b) ↔ IsLeftRegular b :=\n  ⟨fun ab => IsLeftRegular.of_mul ab, fun ab => IsLeftRegular.mul ha ab⟩\n\n"}
{"name":"mul_isLeftRegular_iff","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_1\ninst✝ : Semigroup R\na b : R\nha : IsLeftRegular a\n⊢ Iff (IsLeftRegular (HMul.hMul a b)) (IsLeftRegular b)","decl":"/-- An element is left-regular if and only if multiplying it on the left by a left-regular element\nis left-regular. -/\n@[to_additive (attr := simp) \"An element is add-left-regular if and only if adding to it on the left\nan add-left-regular element is add-left-regular.\"]\ntheorem mul_isLeftRegular_iff (b : R) (ha : IsLeftRegular a) :\n    IsLeftRegular (a * b) ↔ IsLeftRegular b :=\n  ⟨fun ab => IsLeftRegular.of_mul ab, fun ab => IsLeftRegular.mul ha ab⟩\n\n"}
{"name":"IsAddRightRegular.of_add","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_1\ninst✝ : AddSemigroup R\na b : R\nab : IsAddRightRegular (HAdd.hAdd b a)\n⊢ IsAddRightRegular b","decl":"/-- If an element `b` becomes right-regular after multiplying it on the right by a right-regular\nelement, then `b` is right-regular. -/\n@[to_additive \"If an element `b` becomes add-right-regular after adding to it on the right\nan add-right-regular element, then `b` is add-right-regular.\"]\ntheorem IsRightRegular.of_mul (ab : IsRightRegular (b * a)) : IsRightRegular b := by\n  refine fun x y xy => ab (?_ : x * (b * a) = y * (b * a))\n  rw [← mul_assoc, ← mul_assoc]\n  exact congr_arg (· * a) xy\n\n"}
{"name":"IsRightRegular.of_mul","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_1\ninst✝ : Semigroup R\na b : R\nab : IsRightRegular (HMul.hMul b a)\n⊢ IsRightRegular b","decl":"/-- If an element `b` becomes right-regular after multiplying it on the right by a right-regular\nelement, then `b` is right-regular. -/\n@[to_additive \"If an element `b` becomes add-right-regular after adding to it on the right\nan add-right-regular element, then `b` is add-right-regular.\"]\ntheorem IsRightRegular.of_mul (ab : IsRightRegular (b * a)) : IsRightRegular b := by\n  refine fun x y xy => ab (?_ : x * (b * a) = y * (b * a))\n  rw [← mul_assoc, ← mul_assoc]\n  exact congr_arg (· * a) xy\n\n"}
{"name":"mul_isRightRegular_iff","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_1\ninst✝ : Semigroup R\na b : R\nha : IsRightRegular a\n⊢ Iff (IsRightRegular (HMul.hMul b a)) (IsRightRegular b)","decl":"/-- An element is right-regular if and only if multiplying it on the right with a right-regular\nelement is right-regular. -/\n@[to_additive (attr := simp)\n\"An element is add-right-regular if and only if adding it on the right to\nan add-right-regular element is add-right-regular.\"]\ntheorem mul_isRightRegular_iff (b : R) (ha : IsRightRegular a) :\n    IsRightRegular (b * a) ↔ IsRightRegular b :=\n  ⟨fun ab => IsRightRegular.of_mul ab, fun ab => IsRightRegular.mul ab ha⟩\n\n"}
{"name":"add_isAddRightRegular_iff","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_1\ninst✝ : AddSemigroup R\na b : R\nha : IsAddRightRegular a\n⊢ Iff (IsAddRightRegular (HAdd.hAdd b a)) (IsAddRightRegular b)","decl":"/-- An element is right-regular if and only if multiplying it on the right with a right-regular\nelement is right-regular. -/\n@[to_additive (attr := simp)\n\"An element is add-right-regular if and only if adding it on the right to\nan add-right-regular element is add-right-regular.\"]\ntheorem mul_isRightRegular_iff (b : R) (ha : IsRightRegular a) :\n    IsRightRegular (b * a) ↔ IsRightRegular b :=\n  ⟨fun ab => IsRightRegular.of_mul ab, fun ab => IsRightRegular.mul ab ha⟩\n\n"}
{"name":"isAddRegular_add_and_add_iff","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_1\ninst✝ : AddSemigroup R\na b : R\n⊢ Iff (And (IsAddRegular (HAdd.hAdd a b)) (IsAddRegular (HAdd.hAdd b a))) (And (IsAddRegular a) (IsAddRegular b))","decl":"/-- Two elements `a` and `b` are regular if and only if both products `a * b` and `b * a`\nare regular. -/\n@[to_additive \"Two elements `a` and `b` are add-regular if and only if both sums `a + b` and\n`b + a` are add-regular.\"]\ntheorem isRegular_mul_and_mul_iff :\n    IsRegular (a * b) ∧ IsRegular (b * a) ↔ IsRegular a ∧ IsRegular b := by\n  refine ⟨?_, ?_⟩\n  · rintro ⟨ab, ba⟩\n    exact\n      ⟨⟨IsLeftRegular.of_mul ba.left, IsRightRegular.of_mul ab.right⟩,\n        ⟨IsLeftRegular.of_mul ab.left, IsRightRegular.of_mul ba.right⟩⟩\n  · rintro ⟨ha, hb⟩\n    exact ⟨ha.mul hb, hb.mul ha⟩\n\n"}
{"name":"isRegular_mul_and_mul_iff","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_1\ninst✝ : Semigroup R\na b : R\n⊢ Iff (And (IsRegular (HMul.hMul a b)) (IsRegular (HMul.hMul b a))) (And (IsRegular a) (IsRegular b))","decl":"/-- Two elements `a` and `b` are regular if and only if both products `a * b` and `b * a`\nare regular. -/\n@[to_additive \"Two elements `a` and `b` are add-regular if and only if both sums `a + b` and\n`b + a` are add-regular.\"]\ntheorem isRegular_mul_and_mul_iff :\n    IsRegular (a * b) ∧ IsRegular (b * a) ↔ IsRegular a ∧ IsRegular b := by\n  refine ⟨?_, ?_⟩\n  · rintro ⟨ab, ba⟩\n    exact\n      ⟨⟨IsLeftRegular.of_mul ba.left, IsRightRegular.of_mul ab.right⟩,\n        ⟨IsLeftRegular.of_mul ab.left, IsRightRegular.of_mul ba.right⟩⟩\n  · rintro ⟨ha, hb⟩\n    exact ⟨ha.mul hb, hb.mul ha⟩\n\n"}
{"name":"IsAddRegular.and_of_add_of_add","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_1\ninst✝ : AddSemigroup R\na b : R\nab : IsAddRegular (HAdd.hAdd a b)\nba : IsAddRegular (HAdd.hAdd b a)\n⊢ And (IsAddRegular a) (IsAddRegular b)","decl":"/-- The \"most used\" implication of `mul_and_mul_iff`, with split hypotheses, instead of `∧`. -/\n@[to_additive \"The \\\"most used\\\" implication of `add_and_add_iff`, with split\nhypotheses, instead of `∧`.\"]\ntheorem IsRegular.and_of_mul_of_mul (ab : IsRegular (a * b)) (ba : IsRegular (b * a)) :\n    IsRegular a ∧ IsRegular b :=\n  isRegular_mul_and_mul_iff.mp ⟨ab, ba⟩\n\n"}
{"name":"IsRegular.and_of_mul_of_mul","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_1\ninst✝ : Semigroup R\na b : R\nab : IsRegular (HMul.hMul a b)\nba : IsRegular (HMul.hMul b a)\n⊢ And (IsRegular a) (IsRegular b)","decl":"/-- The \"most used\" implication of `mul_and_mul_iff`, with split hypotheses, instead of `∧`. -/\n@[to_additive \"The \\\"most used\\\" implication of `add_and_add_iff`, with split\nhypotheses, instead of `∧`.\"]\ntheorem IsRegular.and_of_mul_of_mul (ab : IsRegular (a * b)) (ba : IsRegular (b * a)) :\n    IsRegular a ∧ IsRegular b :=\n  isRegular_mul_and_mul_iff.mp ⟨ab, ba⟩\n\n"}
{"name":"IsLeftRegular.subsingleton","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_1\ninst✝ : MulZeroClass R\nh : IsLeftRegular 0\n⊢ Subsingleton R","decl":"/-- The element `0` is left-regular if and only if `R` is trivial. -/\ntheorem IsLeftRegular.subsingleton (h : IsLeftRegular (0 : R)) : Subsingleton R :=\n  ⟨fun a b => h <| Eq.trans (zero_mul a) (zero_mul b).symm⟩\n\n"}
{"name":"IsRightRegular.subsingleton","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_1\ninst✝ : MulZeroClass R\nh : IsRightRegular 0\n⊢ Subsingleton R","decl":"/-- The element `0` is right-regular if and only if `R` is trivial. -/\ntheorem IsRightRegular.subsingleton (h : IsRightRegular (0 : R)) : Subsingleton R :=\n  ⟨fun a b => h <| Eq.trans (mul_zero a) (mul_zero b).symm⟩\n\n"}
{"name":"IsRegular.subsingleton","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_1\ninst✝ : MulZeroClass R\nh : IsRegular 0\n⊢ Subsingleton R","decl":"/-- The element `0` is regular if and only if `R` is trivial. -/\ntheorem IsRegular.subsingleton (h : IsRegular (0 : R)) : Subsingleton R :=\n  h.left.subsingleton\n\n"}
{"name":"isLeftRegular_zero_iff_subsingleton","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_1\ninst✝ : MulZeroClass R\n⊢ Iff (IsLeftRegular 0) (Subsingleton R)","decl":"/-- The element `0` is left-regular if and only if `R` is trivial. -/\ntheorem isLeftRegular_zero_iff_subsingleton : IsLeftRegular (0 : R) ↔ Subsingleton R :=\n  ⟨fun h => h.subsingleton, fun H a b _ => @Subsingleton.elim _ H a b⟩\n\n"}
{"name":"not_isLeftRegular_zero_iff","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_1\ninst✝ : MulZeroClass R\n⊢ Iff (Not (IsLeftRegular 0)) (Nontrivial R)","decl":"/-- In a non-trivial `MulZeroClass`, the `0` element is not left-regular. -/\ntheorem not_isLeftRegular_zero_iff : ¬IsLeftRegular (0 : R) ↔ Nontrivial R := by\n  rw [nontrivial_iff, not_iff_comm, isLeftRegular_zero_iff_subsingleton, subsingleton_iff]\n  push_neg\n  exact Iff.rfl\n\n"}
{"name":"isRightRegular_zero_iff_subsingleton","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_1\ninst✝ : MulZeroClass R\n⊢ Iff (IsRightRegular 0) (Subsingleton R)","decl":"/-- The element `0` is right-regular if and only if `R` is trivial. -/\ntheorem isRightRegular_zero_iff_subsingleton : IsRightRegular (0 : R) ↔ Subsingleton R :=\n  ⟨fun h => h.subsingleton, fun H a b _ => @Subsingleton.elim _ H a b⟩\n\n"}
{"name":"not_isRightRegular_zero_iff","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_1\ninst✝ : MulZeroClass R\n⊢ Iff (Not (IsRightRegular 0)) (Nontrivial R)","decl":"/-- In a non-trivial `MulZeroClass`, the `0` element is not right-regular. -/\ntheorem not_isRightRegular_zero_iff : ¬IsRightRegular (0 : R) ↔ Nontrivial R := by\n  rw [nontrivial_iff, not_iff_comm, isRightRegular_zero_iff_subsingleton, subsingleton_iff]\n  push_neg\n  exact Iff.rfl\n\n"}
{"name":"isRegular_iff_subsingleton","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_1\ninst✝ : MulZeroClass R\n⊢ Iff (IsRegular 0) (Subsingleton R)","decl":"/-- The element `0` is regular if and only if `R` is trivial. -/\ntheorem isRegular_iff_subsingleton : IsRegular (0 : R) ↔ Subsingleton R :=\n  ⟨fun h => h.left.subsingleton, fun h =>\n    ⟨isLeftRegular_zero_iff_subsingleton.mpr h, isRightRegular_zero_iff_subsingleton.mpr h⟩⟩\n\n"}
{"name":"IsLeftRegular.ne_zero","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_1\ninst✝¹ : MulZeroClass R\na : R\ninst✝ : Nontrivial R\nla : IsLeftRegular a\n⊢ Ne a 0","decl":"/-- A left-regular element of a `Nontrivial` `MulZeroClass` is non-zero. -/\ntheorem IsLeftRegular.ne_zero [Nontrivial R] (la : IsLeftRegular a) : a ≠ 0 := by\n  rintro rfl\n  rcases exists_pair_ne R with ⟨x, y, xy⟩\n  refine xy (la (?_ : 0 * x = 0 * y)) -- Porting note: lean4 seems to need the type signature\n  rw [zero_mul, zero_mul]\n\n"}
{"name":"IsRightRegular.ne_zero","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_1\ninst✝¹ : MulZeroClass R\na : R\ninst✝ : Nontrivial R\nra : IsRightRegular a\n⊢ Ne a 0","decl":"/-- A right-regular element of a `Nontrivial` `MulZeroClass` is non-zero. -/\ntheorem IsRightRegular.ne_zero [Nontrivial R] (ra : IsRightRegular a) : a ≠ 0 := by\n  rintro rfl\n  rcases exists_pair_ne R with ⟨x, y, xy⟩\n  refine xy (ra (?_ : x * 0 = y * 0))\n  rw [mul_zero, mul_zero]\n\n"}
{"name":"IsRegular.ne_zero","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_1\ninst✝¹ : MulZeroClass R\na : R\ninst✝ : Nontrivial R\nla : IsRegular a\n⊢ Ne a 0","decl":"/-- A regular element of a `Nontrivial` `MulZeroClass` is non-zero. -/\ntheorem IsRegular.ne_zero [Nontrivial R] (la : IsRegular a) : a ≠ 0 :=\n  la.left.ne_zero\n\n"}
{"name":"not_isLeftRegular_zero","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_1\ninst✝ : MulZeroClass R\nnR : Nontrivial R\n⊢ Not (IsLeftRegular 0)","decl":"/-- In a non-trivial ring, the element `0` is not left-regular -- with typeclasses. -/\ntheorem not_isLeftRegular_zero [nR : Nontrivial R] : ¬IsLeftRegular (0 : R) :=\n  not_isLeftRegular_zero_iff.mpr nR\n\n"}
{"name":"not_isRightRegular_zero","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_1\ninst✝ : MulZeroClass R\nnR : Nontrivial R\n⊢ Not (IsRightRegular 0)","decl":"/-- In a non-trivial ring, the element `0` is not right-regular -- with typeclasses. -/\ntheorem not_isRightRegular_zero [nR : Nontrivial R] : ¬IsRightRegular (0 : R) :=\n  not_isRightRegular_zero_iff.mpr nR\n\n"}
{"name":"not_isRegular_zero","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_1\ninst✝¹ : MulZeroClass R\ninst✝ : Nontrivial R\n⊢ Not (IsRegular 0)","decl":"/-- In a non-trivial ring, the element `0` is not regular -- with typeclasses. -/\ntheorem not_isRegular_zero [Nontrivial R] : ¬IsRegular (0 : R) := fun h => IsRegular.ne_zero h rfl\n\n"}
{"name":"IsLeftRegular.mul_left_eq_zero_iff","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_1\ninst✝ : MulZeroClass R\na b : R\nhb : IsLeftRegular b\n⊢ Iff (Eq (HMul.hMul b a) 0) (Eq a 0)","decl":"@[simp] lemma IsLeftRegular.mul_left_eq_zero_iff (hb : IsLeftRegular b) : b * a = 0 ↔ a = 0 := by\n  nth_rw 1 [← mul_zero b]\n  exact ⟨fun h ↦ hb h, fun ha ↦ by rw [ha]⟩\n\n"}
{"name":"IsRightRegular.mul_right_eq_zero_iff","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_1\ninst✝ : MulZeroClass R\na b : R\nhb : IsRightRegular b\n⊢ Iff (Eq (HMul.hMul a b) 0) (Eq a 0)","decl":"@[simp] lemma IsRightRegular.mul_right_eq_zero_iff (hb : IsRightRegular b) : a * b = 0 ↔ a = 0 := by\n  nth_rw 1 [← zero_mul b]\n  exact ⟨fun h ↦ hb h, fun ha ↦ by rw [ha]⟩\n\n"}
{"name":"isRegular_one","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_1\ninst✝ : MulOneClass R\n⊢ IsRegular 1","decl":"/-- If multiplying by `1` on either side is the identity, `1` is regular. -/\n@[to_additive \"If adding `0` on either side is the identity, `0` is regular.\"]\ntheorem isRegular_one : IsRegular (1 : R) :=\n  ⟨fun a b ab => (one_mul a).symm.trans (Eq.trans ab (one_mul b)), fun a b ab =>\n    (mul_one a).symm.trans (Eq.trans ab (mul_one b))⟩\n\n"}
{"name":"isAddRegular_zero","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_1\ninst✝ : AddZeroClass R\n⊢ IsAddRegular 0","decl":"/-- If multiplying by `1` on either side is the identity, `1` is regular. -/\n@[to_additive \"If adding `0` on either side is the identity, `0` is regular.\"]\ntheorem isRegular_one : IsRegular (1 : R) :=\n  ⟨fun a b ab => (one_mul a).symm.trans (Eq.trans ab (one_mul b)), fun a b ab =>\n    (mul_one a).symm.trans (Eq.trans ab (mul_one b))⟩\n\n"}
{"name":"isAddRegular_add_iff","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_1\ninst✝ : AddCommSemigroup R\na b : R\n⊢ Iff (IsAddRegular (HAdd.hAdd a b)) (And (IsAddRegular a) (IsAddRegular b))","decl":"/-- A product is regular if and only if the factors are. -/\n@[to_additive \"A sum is add-regular if and only if the summands are.\"]\ntheorem isRegular_mul_iff : IsRegular (a * b) ↔ IsRegular a ∧ IsRegular b := by\n  refine Iff.trans ?_ isRegular_mul_and_mul_iff\n  exact ⟨fun ab => ⟨ab, by rwa [mul_comm]⟩, fun rab => rab.1⟩\n\n"}
{"name":"isRegular_mul_iff","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_1\ninst✝ : CommSemigroup R\na b : R\n⊢ Iff (IsRegular (HMul.hMul a b)) (And (IsRegular a) (IsRegular b))","decl":"/-- A product is regular if and only if the factors are. -/\n@[to_additive \"A sum is add-regular if and only if the summands are.\"]\ntheorem isRegular_mul_iff : IsRegular (a * b) ↔ IsRegular a ∧ IsRegular b := by\n  refine Iff.trans ?_ isRegular_mul_and_mul_iff\n  exact ⟨fun ab => ⟨ab, by rwa [mul_comm]⟩, fun rab => rab.1⟩\n\n"}
{"name":"isAddLeftRegular_of_add_eq_zero","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_1\ninst✝ : AddMonoid R\na b : R\nh : Eq (HAdd.hAdd b a) 0\n⊢ IsAddLeftRegular a","decl":"/-- An element admitting a left inverse is left-regular. -/\n@[to_additive \"An element admitting a left additive opposite is add-left-regular.\"]\ntheorem isLeftRegular_of_mul_eq_one (h : b * a = 1) : IsLeftRegular a :=\n  IsLeftRegular.of_mul (a := b) (by rw [h]; exact isRegular_one.left)\n\n"}
{"name":"isLeftRegular_of_mul_eq_one","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_1\ninst✝ : Monoid R\na b : R\nh : Eq (HMul.hMul b a) 1\n⊢ IsLeftRegular a","decl":"/-- An element admitting a left inverse is left-regular. -/\n@[to_additive \"An element admitting a left additive opposite is add-left-regular.\"]\ntheorem isLeftRegular_of_mul_eq_one (h : b * a = 1) : IsLeftRegular a :=\n  IsLeftRegular.of_mul (a := b) (by rw [h]; exact isRegular_one.left)\n\n"}
{"name":"isRightRegular_of_mul_eq_one","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_1\ninst✝ : Monoid R\na b : R\nh : Eq (HMul.hMul a b) 1\n⊢ IsRightRegular a","decl":"/-- An element admitting a right inverse is right-regular. -/\n@[to_additive \"An element admitting a right additive opposite is add-right-regular.\"]\ntheorem isRightRegular_of_mul_eq_one (h : a * b = 1) : IsRightRegular a :=\n  IsRightRegular.of_mul (a := b) (by rw [h]; exact isRegular_one.right)\n\n"}
{"name":"isAddRightRegular_of_add_eq_zero","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_1\ninst✝ : AddMonoid R\na b : R\nh : Eq (HAdd.hAdd a b) 0\n⊢ IsAddRightRegular a","decl":"/-- An element admitting a right inverse is right-regular. -/\n@[to_additive \"An element admitting a right additive opposite is add-right-regular.\"]\ntheorem isRightRegular_of_mul_eq_one (h : a * b = 1) : IsRightRegular a :=\n  IsRightRegular.of_mul (a := b) (by rw [h]; exact isRegular_one.right)\n\n"}
{"name":"Units.isRegular","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_1\ninst✝ : Monoid R\na : Units R\n⊢ IsRegular ↑a","decl":"/-- If `R` is a monoid, an element in `Rˣ` is regular. -/\n@[to_additive \"If `R` is an additive monoid, an element in `add_units R` is add-regular.\"]\ntheorem Units.isRegular (a : Rˣ) : IsRegular (a : R) :=\n  ⟨isLeftRegular_of_mul_eq_one a.inv_mul, isRightRegular_of_mul_eq_one a.mul_inv⟩\n\n"}
{"name":"AddUnits.isAddRegular","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_1\ninst✝ : AddMonoid R\na : AddUnits R\n⊢ IsAddRegular ↑a","decl":"/-- If `R` is a monoid, an element in `Rˣ` is regular. -/\n@[to_additive \"If `R` is an additive monoid, an element in `add_units R` is add-regular.\"]\ntheorem Units.isRegular (a : Rˣ) : IsRegular (a : R) :=\n  ⟨isLeftRegular_of_mul_eq_one a.inv_mul, isRightRegular_of_mul_eq_one a.mul_inv⟩\n\n"}
{"name":"IsUnit.isRegular","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_1\ninst✝ : Monoid R\na : R\nua : IsUnit a\n⊢ IsRegular a","decl":"/-- A unit in a monoid is regular. -/\n@[to_additive \"An additive unit in an additive monoid is add-regular.\"]\ntheorem IsUnit.isRegular (ua : IsUnit a) : IsRegular a := by\n  rcases ua with ⟨a, rfl⟩\n  exact Units.isRegular a\n\n"}
{"name":"IsAddUnit.isAddRegular","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_1\ninst✝ : AddMonoid R\na : R\nua : IsAddUnit a\n⊢ IsAddRegular a","decl":"/-- A unit in a monoid is regular. -/\n@[to_additive \"An additive unit in an additive monoid is add-regular.\"]\ntheorem IsUnit.isRegular (ua : IsUnit a) : IsRegular a := by\n  rcases ua with ⟨a, rfl⟩\n  exact Units.isRegular a\n\n"}
{"name":"IsAddLeftRegular.all","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_1\ninst✝¹ : Add R\ninst✝ : IsLeftCancelAdd R\ng : R\n⊢ IsAddLeftRegular g","decl":"/-- If all multiplications cancel on the left then every element is left-regular. -/\n@[to_additive \"If all additions cancel on the left then every element is add-left-regular.\"]\ntheorem IsLeftRegular.all [Mul R] [IsLeftCancelMul R] (g : R) : IsLeftRegular g :=\n  mul_right_injective g\n\n"}
{"name":"IsLeftRegular.all","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_1\ninst✝¹ : Mul R\ninst✝ : IsLeftCancelMul R\ng : R\n⊢ IsLeftRegular g","decl":"/-- If all multiplications cancel on the left then every element is left-regular. -/\n@[to_additive \"If all additions cancel on the left then every element is add-left-regular.\"]\ntheorem IsLeftRegular.all [Mul R] [IsLeftCancelMul R] (g : R) : IsLeftRegular g :=\n  mul_right_injective g\n\n"}
{"name":"IsAddRightRegular.all","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_1\ninst✝¹ : Add R\ninst✝ : IsRightCancelAdd R\ng : R\n⊢ IsAddRightRegular g","decl":"/-- If all multiplications cancel on the right then every element is right-regular. -/\n@[to_additive \"If all additions cancel on the right then every element is add-right-regular.\"]\ntheorem IsRightRegular.all [Mul R] [IsRightCancelMul R] (g : R) : IsRightRegular g :=\n  mul_left_injective g\n\n"}
{"name":"IsRightRegular.all","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_1\ninst✝¹ : Mul R\ninst✝ : IsRightCancelMul R\ng : R\n⊢ IsRightRegular g","decl":"/-- If all multiplications cancel on the right then every element is right-regular. -/\n@[to_additive \"If all additions cancel on the right then every element is add-right-regular.\"]\ntheorem IsRightRegular.all [Mul R] [IsRightCancelMul R] (g : R) : IsRightRegular g :=\n  mul_left_injective g\n\n"}
{"name":"IsRegular.all","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_1\ninst✝¹ : Mul R\ninst✝ : IsCancelMul R\ng : R\n⊢ IsRegular g","decl":"/-- If all multiplications cancel then every element is regular. -/\n@[to_additive \"If all additions cancel then every element is add-regular.\"]\ntheorem IsRegular.all [Mul R] [IsCancelMul R] (g : R) : IsRegular g :=\n  ⟨mul_right_injective g, mul_left_injective g⟩\n\n"}
{"name":"IsAddRegular.all","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_1\ninst✝¹ : Add R\ninst✝ : IsCancelAdd R\ng : R\n⊢ IsAddRegular g","decl":"/-- If all multiplications cancel then every element is regular. -/\n@[to_additive \"If all additions cancel then every element is add-regular.\"]\ntheorem IsRegular.all [Mul R] [IsCancelMul R] (g : R) : IsRegular g :=\n  ⟨mul_right_injective g, mul_left_injective g⟩\n\n"}
{"name":"isRegular_of_ne_zero","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_1\ninst✝¹ : MulZeroClass R\ninst✝ : IsCancelMulZero R\na : R\na0 : Ne a 0\n⊢ IsRegular a","decl":"/-- Non-zero elements of an integral domain are regular. -/\ntheorem isRegular_of_ne_zero (a0 : a ≠ 0) : IsRegular a :=\n  ⟨fun _ _ => mul_left_cancel₀ a0, fun _ _ => mul_right_cancel₀ a0⟩\n\n"}
{"name":"isRegular_iff_ne_zero","module":"Mathlib.Algebra.Regular.Basic","initialProofState":"R : Type u_1\ninst✝² : MulZeroClass R\ninst✝¹ : IsCancelMulZero R\na : R\ninst✝ : Nontrivial R\n⊢ Iff (IsRegular a) (Ne a 0)","decl":"/-- In a non-trivial integral domain, an element is regular iff it is non-zero. -/\ntheorem isRegular_iff_ne_zero [Nontrivial R] : IsRegular a ↔ a ≠ 0 :=\n  ⟨IsRegular.ne_zero, isRegular_of_ne_zero⟩\n\n"}
