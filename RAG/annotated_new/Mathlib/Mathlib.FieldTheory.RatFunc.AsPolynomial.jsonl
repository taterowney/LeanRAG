{"name":"RatFunc.algebraMap_eq_C","module":"Mathlib.FieldTheory.RatFunc.AsPolynomial","initialProofState":"K : Type u\ninst✝¹ : CommRing K\ninst✝ : IsDomain K\n⊢ Eq (algebraMap K (RatFunc K)) RatFunc.C","decl":"@[simp]\ntheorem algebraMap_eq_C : algebraMap K (RatFunc K) = C :=\n  rfl\n\n"}
{"name":"RatFunc.algebraMap_C","module":"Mathlib.FieldTheory.RatFunc.AsPolynomial","initialProofState":"K : Type u\ninst✝¹ : CommRing K\ninst✝ : IsDomain K\na : K\n⊢ Eq ((algebraMap (Polynomial K) (RatFunc K)) (Polynomial.C a)) (RatFunc.C a)","decl":"@[simp]\ntheorem algebraMap_C (a : K) : algebraMap K[X] (RatFunc K) (Polynomial.C a) = C a :=\n  rfl\n\n"}
{"name":"RatFunc.algebraMap_comp_C","module":"Mathlib.FieldTheory.RatFunc.AsPolynomial","initialProofState":"K : Type u\ninst✝¹ : CommRing K\ninst✝ : IsDomain K\n⊢ Eq ((algebraMap (Polynomial K) (RatFunc K)).comp Polynomial.C) RatFunc.C","decl":"@[simp]\ntheorem algebraMap_comp_C : (algebraMap K[X] (RatFunc K)).comp Polynomial.C = C :=\n  rfl\n\n"}
{"name":"RatFunc.smul_eq_C_mul","module":"Mathlib.FieldTheory.RatFunc.AsPolynomial","initialProofState":"K : Type u\ninst✝¹ : CommRing K\ninst✝ : IsDomain K\nr : K\nx : RatFunc K\n⊢ Eq (HSMul.hSMul r x) (HMul.hMul (RatFunc.C r) x)","decl":"theorem smul_eq_C_mul (r : K) (x : RatFunc K) : r • x = C r * x := by\n  rw [Algebra.smul_def, algebraMap_eq_C]\n\n"}
{"name":"RatFunc.algebraMap_X","module":"Mathlib.FieldTheory.RatFunc.AsPolynomial","initialProofState":"K : Type u\ninst✝¹ : CommRing K\ninst✝ : IsDomain K\n⊢ Eq ((algebraMap (Polynomial K) (RatFunc K)) Polynomial.X) RatFunc.X","decl":"@[simp]\ntheorem algebraMap_X : algebraMap K[X] (RatFunc K) Polynomial.X = X :=\n  rfl\n\n"}
{"name":"RatFunc.num_C","module":"Mathlib.FieldTheory.RatFunc.AsPolynomial","initialProofState":"K : Type u\ninst✝ : Field K\nc : K\n⊢ Eq (RatFunc.C c).num (Polynomial.C c)","decl":"@[simp]\ntheorem num_C (c : K) : num (C c) = Polynomial.C c :=\n  num_algebraMap _\n\n"}
{"name":"RatFunc.denom_C","module":"Mathlib.FieldTheory.RatFunc.AsPolynomial","initialProofState":"K : Type u\ninst✝ : Field K\nc : K\n⊢ Eq (RatFunc.C c).denom 1","decl":"@[simp]\ntheorem denom_C (c : K) : denom (C c) = 1 :=\n  denom_algebraMap _\n\n"}
{"name":"RatFunc.num_X","module":"Mathlib.FieldTheory.RatFunc.AsPolynomial","initialProofState":"K : Type u\ninst✝ : Field K\n⊢ Eq RatFunc.X.num Polynomial.X","decl":"@[simp]\ntheorem num_X : num (X : RatFunc K) = Polynomial.X :=\n  num_algebraMap _\n\n"}
{"name":"RatFunc.denom_X","module":"Mathlib.FieldTheory.RatFunc.AsPolynomial","initialProofState":"K : Type u\ninst✝ : Field K\n⊢ Eq RatFunc.X.denom 1","decl":"@[simp]\ntheorem denom_X : denom (X : RatFunc K) = 1 :=\n  denom_algebraMap _\n\n"}
{"name":"RatFunc.X_ne_zero","module":"Mathlib.FieldTheory.RatFunc.AsPolynomial","initialProofState":"K : Type u\ninst✝ : Field K\n⊢ Ne RatFunc.X 0","decl":"theorem X_ne_zero : (X : RatFunc K) ≠ 0 :=\n  RatFunc.algebraMap_ne_zero Polynomial.X_ne_zero\n\n"}
{"name":"RatFunc.eval_eq_zero_of_eval₂_denom_eq_zero","module":"Mathlib.FieldTheory.RatFunc.AsPolynomial","initialProofState":"K : Type u\ninst✝¹ : Field K\nL : Type u\ninst✝ : Field L\nf : RingHom K L\na : L\nx : RatFunc K\nh : Eq (Polynomial.eval₂ f a x.denom) 0\n⊢ Eq (RatFunc.eval f a x) 0","decl":"theorem eval_eq_zero_of_eval₂_denom_eq_zero {x : RatFunc K}\n    (h : Polynomial.eval₂ f a (denom x) = 0) : eval f a x = 0 := by rw [eval, h, div_zero]\n\n"}
{"name":"RatFunc.eval₂_denom_ne_zero","module":"Mathlib.FieldTheory.RatFunc.AsPolynomial","initialProofState":"K : Type u\ninst✝¹ : Field K\nL : Type u\ninst✝ : Field L\nf : RingHom K L\na : L\nx : RatFunc K\nh : Ne (RatFunc.eval f a x) 0\n⊢ Ne (Polynomial.eval₂ f a x.denom) 0","decl":"theorem eval₂_denom_ne_zero {x : RatFunc K} (h : eval f a x ≠ 0) :\n    Polynomial.eval₂ f a (denom x) ≠ 0 :=\n  mt eval_eq_zero_of_eval₂_denom_eq_zero h\n\n"}
{"name":"RatFunc.eval_C","module":"Mathlib.FieldTheory.RatFunc.AsPolynomial","initialProofState":"K : Type u\ninst✝¹ : Field K\nL : Type u\ninst✝ : Field L\nf : RingHom K L\na : L\nc : K\n⊢ Eq (RatFunc.eval f a (RatFunc.C c)) (f c)","decl":"@[simp]\ntheorem eval_C {c : K} : eval f a (C c) = f c := by simp [eval]\n\n"}
{"name":"RatFunc.eval_X","module":"Mathlib.FieldTheory.RatFunc.AsPolynomial","initialProofState":"K : Type u\ninst✝¹ : Field K\nL : Type u\ninst✝ : Field L\nf : RingHom K L\na : L\n⊢ Eq (RatFunc.eval f a RatFunc.X) a","decl":"@[simp]\ntheorem eval_X : eval f a X = a := by simp [eval]\n\n"}
{"name":"RatFunc.eval_zero","module":"Mathlib.FieldTheory.RatFunc.AsPolynomial","initialProofState":"K : Type u\ninst✝¹ : Field K\nL : Type u\ninst✝ : Field L\nf : RingHom K L\na : L\n⊢ Eq (RatFunc.eval f a 0) 0","decl":"@[simp]\ntheorem eval_zero : eval f a 0 = 0 := by simp [eval]\n\n"}
{"name":"RatFunc.eval_one","module":"Mathlib.FieldTheory.RatFunc.AsPolynomial","initialProofState":"K : Type u\ninst✝¹ : Field K\nL : Type u\ninst✝ : Field L\nf : RingHom K L\na : L\n⊢ Eq (RatFunc.eval f a 1) 1","decl":"@[simp]\ntheorem eval_one : eval f a 1 = 1 := by simp [eval]\n\n"}
{"name":"RatFunc.eval_algebraMap","module":"Mathlib.FieldTheory.RatFunc.AsPolynomial","initialProofState":"K : Type u\ninst✝³ : Field K\nL : Type u\ninst✝² : Field L\nf : RingHom K L\na : L\nS : Type u_1\ninst✝¹ : CommSemiring S\ninst✝ : Algebra S (Polynomial K)\np : S\n⊢ Eq (RatFunc.eval f a ((algebraMap S (RatFunc K)) p)) (Polynomial.eval₂ f a ((algebraMap S (Polynomial K)) p))","decl":"@[simp]\ntheorem eval_algebraMap {S : Type*} [CommSemiring S] [Algebra S K[X]] (p : S) :\n    eval f a (algebraMap _ _ p) = (algebraMap _ K[X] p).eval₂ f a := by\n  simp [eval, IsScalarTower.algebraMap_apply S K[X] (RatFunc K)]\n\n"}
{"name":"RatFunc.eval_add","module":"Mathlib.FieldTheory.RatFunc.AsPolynomial","initialProofState":"K : Type u\ninst✝¹ : Field K\nL : Type u\ninst✝ : Field L\nf : RingHom K L\na : L\nx y : RatFunc K\nhx : Ne (Polynomial.eval₂ f a x.denom) 0\nhy : Ne (Polynomial.eval₂ f a y.denom) 0\n⊢ Eq (RatFunc.eval f a (HAdd.hAdd x y)) (HAdd.hAdd (RatFunc.eval f a x) (RatFunc.eval f a y))","decl":"/-- `eval` is an additive homomorphism except when a denominator evaluates to `0`.\n\nCounterexample: `eval _ 1 (X / (X-1)) + eval _ 1 (-1 / (X-1)) = 0`\n`... ≠ 1 = eval _ 1 ((X-1) / (X-1))`.\n\nSee also `RatFunc.eval₂_denom_ne_zero` to make the hypotheses simpler but less general.\n-/\ntheorem eval_add {x y : RatFunc K} (hx : Polynomial.eval₂ f a (denom x) ≠ 0)\n    (hy : Polynomial.eval₂ f a (denom y) ≠ 0) : eval f a (x + y) = eval f a x + eval f a y := by\n  unfold eval\n  by_cases hxy : Polynomial.eval₂ f a (denom (x + y)) = 0\n  · have := Polynomial.eval₂_eq_zero_of_dvd_of_eval₂_eq_zero f a (denom_add_dvd x y) hxy\n    rw [Polynomial.eval₂_mul] at this\n    cases mul_eq_zero.mp this <;> contradiction\n  rw [div_add_div _ _ hx hy, eq_div_iff (mul_ne_zero hx hy), div_eq_mul_inv, mul_right_comm, ←\n    div_eq_mul_inv, div_eq_iff hxy]\n  simp only [← Polynomial.eval₂_mul, ← Polynomial.eval₂_add]\n  congr 1\n  apply num_denom_add\n\n"}
{"name":"RatFunc.eval_mul","module":"Mathlib.FieldTheory.RatFunc.AsPolynomial","initialProofState":"K : Type u\ninst✝¹ : Field K\nL : Type u\ninst✝ : Field L\nf : RingHom K L\na : L\nx y : RatFunc K\nhx : Ne (Polynomial.eval₂ f a x.denom) 0\nhy : Ne (Polynomial.eval₂ f a y.denom) 0\n⊢ Eq (RatFunc.eval f a (HMul.hMul x y)) (HMul.hMul (RatFunc.eval f a x) (RatFunc.eval f a y))","decl":"/-- `eval` is a multiplicative homomorphism except when a denominator evaluates to `0`.\n\nCounterexample: `eval _ 0 X * eval _ 0 (1/X) = 0 ≠ 1 = eval _ 0 1 = eval _ 0 (X * 1/X)`.\n\nSee also `RatFunc.eval₂_denom_ne_zero` to make the hypotheses simpler but less general.\n-/\ntheorem eval_mul {x y : RatFunc K} (hx : Polynomial.eval₂ f a (denom x) ≠ 0)\n    (hy : Polynomial.eval₂ f a (denom y) ≠ 0) : eval f a (x * y) = eval f a x * eval f a y := by\n  unfold eval\n  by_cases hxy : Polynomial.eval₂ f a (denom (x * y)) = 0\n  · have := Polynomial.eval₂_eq_zero_of_dvd_of_eval₂_eq_zero f a (denom_mul_dvd x y) hxy\n    rw [Polynomial.eval₂_mul] at this\n    cases mul_eq_zero.mp this <;> contradiction\n  rw [div_mul_div_comm, eq_div_iff (mul_ne_zero hx hy), div_eq_mul_inv, mul_right_comm, ←\n    div_eq_mul_inv, div_eq_iff hxy]\n  repeat' rw [← Polynomial.eval₂_mul]\n  congr 1\n  apply num_denom_mul\n\n"}
{"name":"Polynomial.idealX_span","module":"Mathlib.FieldTheory.RatFunc.AsPolynomial","initialProofState":"K : Type u_1\ninst✝ : Field K\n⊢ Eq (Polynomial.idealX K).asIdeal (Ideal.span (Singleton.singleton Polynomial.X))","decl":"@[simp]\ntheorem idealX_span : (idealX K).asIdeal = Ideal.span {X} := rfl\n\n"}
{"name":"Polynomial.valuation_X_eq_neg_one","module":"Mathlib.FieldTheory.RatFunc.AsPolynomial","initialProofState":"K : Type u_1\ninst✝ : Field K\n⊢ Eq ((Polynomial.idealX K).valuation RatFunc.X) ↑(Multiplicative.ofAdd (-1))","decl":"@[simp]\ntheorem valuation_X_eq_neg_one :\n    (idealX K).valuation (RatFunc.X : RatFunc K) = Multiplicative.ofAdd (-1 : ℤ) := by\n  rw [← RatFunc.algebraMap_X, valuation_of_algebraMap, intValuation_singleton]\n  · exact Polynomial.X_ne_zero\n  · exact idealX_span K\n\n"}
{"name":"Polynomial.valuation_of_mk","module":"Mathlib.FieldTheory.RatFunc.AsPolynomial","initialProofState":"K : Type u_1\ninst✝ : Field K\nf g : Polynomial K\nhg : Ne g 0\n⊢ Eq ((Polynomial.idealX K).valuation (RatFunc.mk f g)) (HDiv.hDiv ((Polynomial.idealX K).intValuation f) ((Polynomial.idealX K).intValuation g))","decl":"theorem valuation_of_mk (f : Polynomial K) {g : Polynomial K} (hg : g ≠ 0) :\n    (Polynomial.idealX K).valuation (RatFunc.mk f g) =\n      (Polynomial.idealX K).intValuation f / (Polynomial.idealX K).intValuation g := by\n  simp only [RatFunc.mk_eq_mk' _ hg, valuation_of_mk']\n\n"}
{"name":"RatFunc.WithZero.valued_def","module":"Mathlib.FieldTheory.RatFunc.AsPolynomial","initialProofState":"K : Type u_1\ninst✝ : Field K\nx : RatFunc K\n⊢ Eq (Valued.v x) ((Polynomial.idealX K).valuation x)","decl":"@[simp]\ntheorem WithZero.valued_def {x : RatFunc K} :\n    @Valued.v (RatFunc K) _ _ _ _ x = (idealX K).valuation x := rfl\n\n"}
