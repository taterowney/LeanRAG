{"name":"abs_zsmul","module":"Mathlib.Algebra.Order.Ring.Abs","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedAddCommGroup α\nn : Int\na : α\n⊢ Eq (abs (HSMul.hSMul n a)) (HSMul.hSMul (abs n) (abs a))","decl":"@[to_additive] lemma mabs_zpow (n : ℤ) (a : α) : |a ^ n|ₘ = |a|ₘ ^ |n| := by\n  obtain n0 | n0 := le_total 0 n\n  · obtain ⟨n, rfl⟩ := Int.eq_ofNat_of_zero_le n0\n    simp only [mabs_pow, zpow_natCast, Nat.abs_cast]\n  · obtain ⟨m, h⟩ := Int.eq_ofNat_of_zero_le (neg_nonneg.2 n0)\n    rw [← mabs_inv, ← zpow_neg, ← abs_neg, h, zpow_natCast, Nat.abs_cast, zpow_natCast]\n    exact mabs_pow m _\n\n"}
{"name":"mabs_zpow","module":"Mathlib.Algebra.Order.Ring.Abs","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedCommGroup α\nn : Int\na : α\n⊢ Eq (mabs (HPow.hPow a n)) (HPow.hPow (mabs a) (abs n))","decl":"@[to_additive] lemma mabs_zpow (n : ℤ) (a : α) : |a ^ n|ₘ = |a|ₘ ^ |n| := by\n  obtain n0 | n0 := le_total 0 n\n  · obtain ⟨n, rfl⟩ := Int.eq_ofNat_of_zero_le n0\n    simp only [mabs_pow, zpow_natCast, Nat.abs_cast]\n  · obtain ⟨m, h⟩ := Int.eq_ofNat_of_zero_le (neg_nonneg.2 n0)\n    rw [← mabs_inv, ← zpow_neg, ← abs_neg, h, zpow_natCast, Nat.abs_cast, zpow_natCast]\n    exact mabs_pow m _\n\n"}
{"name":"odd_abs","module":"Mathlib.Algebra.Order.Ring.Abs","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\ninst✝ : Ring α\na : α\n⊢ Iff (Odd (abs a)) (Odd a)","decl":"lemma odd_abs [LinearOrder α] [Ring α] {a : α} : Odd (abs a) ↔ Odd a := by\n  cases' abs_choice a with h h <;> simp only [h, odd_neg]\n\n"}
{"name":"abs_one","module":"Mathlib.Algebra.Order.Ring.Abs","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedRing α\n⊢ Eq (abs 1) 1","decl":"@[simp] lemma abs_one : |(1 : α)| = 1 := abs_of_pos zero_lt_one\n\n"}
{"name":"abs_two","module":"Mathlib.Algebra.Order.Ring.Abs","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedRing α\n⊢ Eq (abs 2) 2","decl":"lemma abs_two : |(2 : α)| = 2 := abs_of_pos zero_lt_two\n\n"}
{"name":"abs_mul","module":"Mathlib.Algebra.Order.Ring.Abs","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedRing α\na b : α\n⊢ Eq (abs (HMul.hMul a b)) (HMul.hMul (abs a) (abs b))","decl":"lemma abs_mul (a b : α) : |a * b| = |a| * |b| := by\n  rw [abs_eq (mul_nonneg (abs_nonneg a) (abs_nonneg b))]\n  rcases le_total a 0 with ha | ha <;> rcases le_total b 0 with hb | hb <;>\n    simp only [abs_of_nonpos, abs_of_nonneg, true_or, or_true, eq_self_iff_true, neg_mul,\n      mul_neg, neg_neg, *]\n\n"}
{"name":"abs_pow","module":"Mathlib.Algebra.Order.Ring.Abs","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedRing α\na : α\nn : Nat\n⊢ Eq (abs (HPow.hPow a n)) (HPow.hPow (abs a) n)","decl":"@[simp]\nlemma abs_pow (a : α) (n : ℕ) : |a ^ n| = |a| ^ n := (absHom.toMonoidHom : α →* α).map_pow _ _\n\n"}
{"name":"pow_abs","module":"Mathlib.Algebra.Order.Ring.Abs","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedRing α\na : α\nn : Nat\n⊢ Eq (HPow.hPow (abs a) n) (abs (HPow.hPow a n))","decl":"lemma pow_abs (a : α) (n : ℕ) : |a| ^ n = |a ^ n| := (abs_pow a n).symm\n\n"}
{"name":"Even.pow_abs","module":"Mathlib.Algebra.Order.Ring.Abs","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedRing α\nn : Nat\nhn : Even n\na : α\n⊢ Eq (HPow.hPow (abs a) n) (HPow.hPow a n)","decl":"lemma Even.pow_abs (hn : Even n) (a : α) : |a| ^ n = a ^ n := by\n  rw [← abs_pow, abs_eq_self]; exact hn.pow_nonneg _\n\n"}
{"name":"abs_neg_one_pow","module":"Mathlib.Algebra.Order.Ring.Abs","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedRing α\nn : Nat\n⊢ Eq (abs (HPow.hPow (-1) n)) 1","decl":"lemma abs_neg_one_pow (n : ℕ) : |(-1 : α) ^ n| = 1 := by rw [← pow_abs, abs_neg, abs_one, one_pow]\n\n"}
{"name":"abs_pow_eq_one","module":"Mathlib.Algebra.Order.Ring.Abs","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedRing α\nn : Nat\na : α\nh : Ne n 0\n⊢ Iff (Eq (abs (HPow.hPow a n)) 1) (Eq (abs a) 1)","decl":"lemma abs_pow_eq_one (a : α) (h : n ≠ 0) : |a ^ n| = 1 ↔ |a| = 1 := by\n  convert pow_left_inj₀ (abs_nonneg a) zero_le_one h\n  exacts [(pow_abs _ _).symm, (one_pow _).symm]\n\n"}
{"name":"abs_mul_abs_self","module":"Mathlib.Algebra.Order.Ring.Abs","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedRing α\na : α\n⊢ Eq (HMul.hMul (abs a) (abs a)) (HMul.hMul a a)","decl":"@[simp] lemma abs_mul_abs_self (a : α) : |a| * |a| = a * a :=\n  abs_by_cases (fun x => x * x = a * a) rfl (neg_mul_neg a a)\n\n"}
{"name":"abs_mul_self","module":"Mathlib.Algebra.Order.Ring.Abs","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedRing α\na : α\n⊢ Eq (abs (HMul.hMul a a)) (HMul.hMul a a)","decl":"@[simp]\nlemma abs_mul_self (a : α) : |a * a| = a * a := by rw [abs_mul, abs_mul_abs_self]\n\n"}
{"name":"abs_eq_iff_mul_self_eq","module":"Mathlib.Algebra.Order.Ring.Abs","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedRing α\na b : α\n⊢ Iff (Eq (abs a) (abs b)) (Eq (HMul.hMul a a) (HMul.hMul b b))","decl":"lemma abs_eq_iff_mul_self_eq : |a| = |b| ↔ a * a = b * b := by\n  rw [← abs_mul_abs_self, ← abs_mul_abs_self b]\n  exact (mul_self_inj (abs_nonneg a) (abs_nonneg b)).symm\n\n"}
{"name":"abs_lt_iff_mul_self_lt","module":"Mathlib.Algebra.Order.Ring.Abs","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedRing α\na b : α\n⊢ Iff (LT.lt (abs a) (abs b)) (LT.lt (HMul.hMul a a) (HMul.hMul b b))","decl":"lemma abs_lt_iff_mul_self_lt : |a| < |b| ↔ a * a < b * b := by\n  rw [← abs_mul_abs_self, ← abs_mul_abs_self b]\n  exact mul_self_lt_mul_self_iff (abs_nonneg a) (abs_nonneg b)\n\n"}
{"name":"abs_le_iff_mul_self_le","module":"Mathlib.Algebra.Order.Ring.Abs","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedRing α\na b : α\n⊢ Iff (LE.le (abs a) (abs b)) (LE.le (HMul.hMul a a) (HMul.hMul b b))","decl":"lemma abs_le_iff_mul_self_le : |a| ≤ |b| ↔ a * a ≤ b * b := by\n  rw [← abs_mul_abs_self, ← abs_mul_abs_self b]\n  exact mul_self_le_mul_self_iff (abs_nonneg a) (abs_nonneg b)\n\n"}
{"name":"abs_le_one_iff_mul_self_le_one","module":"Mathlib.Algebra.Order.Ring.Abs","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedRing α\na : α\n⊢ Iff (LE.le (abs a) 1) (LE.le (HMul.hMul a a) 1)","decl":"lemma abs_le_one_iff_mul_self_le_one : |a| ≤ 1 ↔ a * a ≤ 1 := by\n  simpa only [abs_one, one_mul] using @abs_le_iff_mul_self_le α _ a 1\n\n-- Porting note: added `simp` to replace `pow_bit0_abs`\n"}
{"name":"sq_abs","module":"Mathlib.Algebra.Order.Ring.Abs","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedRing α\na : α\n⊢ Eq (HPow.hPow (abs a) 2) (HPow.hPow a 2)","decl":"@[simp] lemma sq_abs (a : α) : |a| ^ 2 = a ^ 2 := by simpa only [sq] using abs_mul_abs_self a\n\n"}
{"name":"abs_sq","module":"Mathlib.Algebra.Order.Ring.Abs","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedRing α\nx : α\n⊢ Eq (abs (HPow.hPow x 2)) (HPow.hPow x 2)","decl":"lemma abs_sq (x : α) : |x ^ 2| = x ^ 2 := by simpa only [sq] using abs_mul_self x\n\n"}
{"name":"sq_lt_sq","module":"Mathlib.Algebra.Order.Ring.Abs","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedRing α\na b : α\n⊢ Iff (LT.lt (HPow.hPow a 2) (HPow.hPow b 2)) (LT.lt (abs a) (abs b))","decl":"lemma sq_lt_sq : a ^ 2 < b ^ 2 ↔ |a| < |b| := by\n  simpa only [sq_abs] using sq_lt_sq₀ (abs_nonneg a) (abs_nonneg b)\n\n"}
{"name":"sq_lt_sq'","module":"Mathlib.Algebra.Order.Ring.Abs","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedRing α\na b : α\nh1 : LT.lt (Neg.neg b) a\nh2 : LT.lt a b\n⊢ LT.lt (HPow.hPow a 2) (HPow.hPow b 2)","decl":"lemma sq_lt_sq' (h1 : -b < a) (h2 : a < b) : a ^ 2 < b ^ 2 :=\n  sq_lt_sq.2 (lt_of_lt_of_le (abs_lt.2 ⟨h1, h2⟩) (le_abs_self _))\n\n"}
{"name":"sq_le_sq","module":"Mathlib.Algebra.Order.Ring.Abs","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedRing α\na b : α\n⊢ Iff (LE.le (HPow.hPow a 2) (HPow.hPow b 2)) (LE.le (abs a) (abs b))","decl":"lemma sq_le_sq : a ^ 2 ≤ b ^ 2 ↔ |a| ≤ |b| := by\n  simpa only [sq_abs] using sq_le_sq₀ (abs_nonneg a) (abs_nonneg b)\n\n"}
{"name":"sq_le_sq'","module":"Mathlib.Algebra.Order.Ring.Abs","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedRing α\na b : α\nh1 : LE.le (Neg.neg b) a\nh2 : LE.le a b\n⊢ LE.le (HPow.hPow a 2) (HPow.hPow b 2)","decl":"lemma sq_le_sq' (h1 : -b ≤ a) (h2 : a ≤ b) : a ^ 2 ≤ b ^ 2 :=\n  sq_le_sq.2 (le_trans (abs_le.mpr ⟨h1, h2⟩) (le_abs_self _))\n\n"}
{"name":"abs_lt_of_sq_lt_sq","module":"Mathlib.Algebra.Order.Ring.Abs","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedRing α\na b : α\nh : LT.lt (HPow.hPow a 2) (HPow.hPow b 2)\nhb : LE.le 0 b\n⊢ LT.lt (abs a) b","decl":"lemma abs_lt_of_sq_lt_sq (h : a ^ 2 < b ^ 2) (hb : 0 ≤ b) : |a| < b := by\n  rwa [← abs_of_nonneg hb, ← sq_lt_sq]\n\n"}
{"name":"abs_lt_of_sq_lt_sq'","module":"Mathlib.Algebra.Order.Ring.Abs","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedRing α\na b : α\nh : LT.lt (HPow.hPow a 2) (HPow.hPow b 2)\nhb : LE.le 0 b\n⊢ And (LT.lt (Neg.neg b) a) (LT.lt a b)","decl":"lemma abs_lt_of_sq_lt_sq' (h : a ^ 2 < b ^ 2) (hb : 0 ≤ b) : -b < a ∧ a < b :=\n  abs_lt.1 <| abs_lt_of_sq_lt_sq h hb\n\n"}
{"name":"abs_le_of_sq_le_sq","module":"Mathlib.Algebra.Order.Ring.Abs","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedRing α\na b : α\nh : LE.le (HPow.hPow a 2) (HPow.hPow b 2)\nhb : LE.le 0 b\n⊢ LE.le (abs a) b","decl":"lemma abs_le_of_sq_le_sq (h : a ^ 2 ≤ b ^ 2) (hb : 0 ≤ b) : |a| ≤ b := by\n  rwa [← abs_of_nonneg hb, ← sq_le_sq]\n\n"}
{"name":"le_of_sq_le_sq","module":"Mathlib.Algebra.Order.Ring.Abs","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedRing α\na b : α\nh : LE.le (HPow.hPow a 2) (HPow.hPow b 2)\nhb : LE.le 0 b\n⊢ LE.le a b","decl":"theorem le_of_sq_le_sq (h : a ^ 2 ≤ b ^ 2) (hb : 0 ≤ b) : a ≤ b :=\n  le_abs_self a |>.trans <| abs_le_of_sq_le_sq h hb\n\n"}
{"name":"abs_le_of_sq_le_sq'","module":"Mathlib.Algebra.Order.Ring.Abs","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedRing α\na b : α\nh : LE.le (HPow.hPow a 2) (HPow.hPow b 2)\nhb : LE.le 0 b\n⊢ And (LE.le (Neg.neg b) a) (LE.le a b)","decl":"lemma abs_le_of_sq_le_sq' (h : a ^ 2 ≤ b ^ 2) (hb : 0 ≤ b) : -b ≤ a ∧ a ≤ b :=\n  abs_le.1 <| abs_le_of_sq_le_sq h hb\n\n"}
{"name":"sq_eq_sq_iff_abs_eq_abs","module":"Mathlib.Algebra.Order.Ring.Abs","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedRing α\na b : α\n⊢ Iff (Eq (HPow.hPow a 2) (HPow.hPow b 2)) (Eq (abs a) (abs b))","decl":"lemma sq_eq_sq_iff_abs_eq_abs (a b : α) : a ^ 2 = b ^ 2 ↔ |a| = |b| := by\n  simp only [le_antisymm_iff, sq_le_sq]\n\n"}
{"name":"sq_le_one_iff_abs_le_one","module":"Mathlib.Algebra.Order.Ring.Abs","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedRing α\na : α\n⊢ Iff (LE.le (HPow.hPow a 2) 1) (LE.le (abs a) 1)","decl":"@[simp] lemma sq_le_one_iff_abs_le_one (a : α) : a ^ 2 ≤ 1 ↔ |a| ≤ 1 := by\n  simpa only [one_pow, abs_one] using @sq_le_sq _ _ a 1\n\n"}
{"name":"sq_lt_one_iff_abs_lt_one","module":"Mathlib.Algebra.Order.Ring.Abs","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedRing α\na : α\n⊢ Iff (LT.lt (HPow.hPow a 2) 1) (LT.lt (abs a) 1)","decl":"@[simp] lemma sq_lt_one_iff_abs_lt_one (a : α) : a ^ 2 < 1 ↔ |a| < 1 := by\n  simpa only [one_pow, abs_one] using @sq_lt_sq _ _ a 1\n\n"}
{"name":"one_le_sq_iff_one_le_abs","module":"Mathlib.Algebra.Order.Ring.Abs","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedRing α\na : α\n⊢ Iff (LE.le 1 (HPow.hPow a 2)) (LE.le 1 (abs a))","decl":"@[simp] lemma one_le_sq_iff_one_le_abs (a : α) : 1 ≤ a ^ 2 ↔ 1 ≤ |a| := by\n  simpa only [one_pow, abs_one] using @sq_le_sq _ _ 1 a\n\n"}
{"name":"one_lt_sq_iff_one_lt_abs","module":"Mathlib.Algebra.Order.Ring.Abs","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedRing α\na : α\n⊢ Iff (LT.lt 1 (HPow.hPow a 2)) (LT.lt 1 (abs a))","decl":"@[simp] lemma one_lt_sq_iff_one_lt_abs (a : α) : 1 < a ^ 2 ↔ 1 < |a| := by\n  simpa only [one_pow, abs_one] using @sq_lt_sq _ _ 1 a\n\n"}
{"name":"exists_abs_lt","module":"Mathlib.Algebra.Order.Ring.Abs","initialProofState":"α : Type u_2\ninst✝ : LinearOrderedRing α\na : α\n⊢ Exists fun b => And (GT.gt b 0) (LT.lt (abs a) b)","decl":"lemma exists_abs_lt {α : Type*} [LinearOrderedRing α] (a : α) : ∃ b > 0, |a| < b :=\n  ⟨|a| + 1, lt_of_lt_of_le zero_lt_one <| by simp, lt_add_one |a|⟩\n\n"}
{"name":"abs_sub_sq","module":"Mathlib.Algebra.Order.Ring.Abs","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedCommRing α\na b : α\n⊢ Eq (HMul.hMul (abs (HSub.hSub a b)) (abs (HSub.hSub a b))) (HSub.hSub (HAdd.hAdd (HMul.hMul a a) (HMul.hMul b b)) (HMul.hMul (HMul.hMul (HAdd.hAdd 1 1) a) b))","decl":"theorem abs_sub_sq (a b : α) : |a - b| * |a - b| = a * a + b * b - (1 + 1) * a * b := by\n  rw [abs_mul_abs_self]\n  simp only [mul_add, add_comm, add_left_comm, mul_comm, sub_eq_add_neg, mul_one, mul_neg,\n    neg_add_rev, neg_neg, add_assoc]\n\n"}
{"name":"abs_unit_intCast","module":"Mathlib.Algebra.Order.Ring.Abs","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedCommRing α\na : Units Int\n⊢ Eq (abs ↑↑a) 1","decl":"lemma abs_unit_intCast (a : ℤˣ) : |((a : ℤ) : α)| = 1 := by\n  cases Int.units_eq_one_or a <;> simp_all\n\n"}
{"name":"abs_pow_sub_pow_le","module":"Mathlib.Algebra.Order.Ring.Abs","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedCommRing α\na b : α\nn : Nat\n⊢ LE.le (abs (HSub.hSub (HPow.hPow a n) (HPow.hPow b n))) (HMul.hMul (HMul.hMul (abs (HSub.hSub a b)) ↑n) (HPow.hPow (Max.max (abs a) (abs b)) (HSub.hSub n 1)))","decl":"theorem abs_pow_sub_pow_le : |a ^ n - b ^ n| ≤ |a - b| * n * max |a| |b| ^ (n - 1) := by\n  obtain _ | n := n; · simp\n  rw [Nat.add_sub_cancel, pow_sub_pow_eq_sub_mul_geomSum, abs_mul, mul_assoc, Nat.cast_succ]\n  exact mul_le_mul_of_nonneg_left (abs_geomSum_le ..) (abs_nonneg _)\n\n"}
{"name":"abs_dvd","module":"Mathlib.Algebra.Order.Ring.Abs","initialProofState":"α : Type u_1\ninst✝¹ : Ring α\ninst✝ : LinearOrder α\na b : α\n⊢ Iff (Dvd.dvd (abs a) b) (Dvd.dvd a b)","decl":"@[simp]\ntheorem abs_dvd (a b : α) : |a| ∣ b ↔ a ∣ b := by\n  cases' abs_choice a with h h <;> simp only [h, neg_dvd]\n\n"}
{"name":"abs_dvd_self","module":"Mathlib.Algebra.Order.Ring.Abs","initialProofState":"α : Type u_1\ninst✝¹ : Ring α\ninst✝ : LinearOrder α\na : α\n⊢ Dvd.dvd (abs a) a","decl":"theorem abs_dvd_self (a : α) : |a| ∣ a :=\n  (abs_dvd a a).mpr (dvd_refl a)\n\n"}
{"name":"dvd_abs","module":"Mathlib.Algebra.Order.Ring.Abs","initialProofState":"α : Type u_1\ninst✝¹ : Ring α\ninst✝ : LinearOrder α\na b : α\n⊢ Iff (Dvd.dvd a (abs b)) (Dvd.dvd a b)","decl":"@[simp]\ntheorem dvd_abs (a b : α) : a ∣ |b| ↔ a ∣ b := by\n  cases' abs_choice b with h h <;> simp only [h, dvd_neg]\n\n"}
{"name":"self_dvd_abs","module":"Mathlib.Algebra.Order.Ring.Abs","initialProofState":"α : Type u_1\ninst✝¹ : Ring α\ninst✝ : LinearOrder α\na : α\n⊢ Dvd.dvd a (abs a)","decl":"theorem self_dvd_abs (a : α) : a ∣ |a| :=\n  (dvd_abs a a).mpr (dvd_refl a)\n\n"}
{"name":"abs_dvd_abs","module":"Mathlib.Algebra.Order.Ring.Abs","initialProofState":"α : Type u_1\ninst✝¹ : Ring α\ninst✝ : LinearOrder α\na b : α\n⊢ Iff (Dvd.dvd (abs a) (abs b)) (Dvd.dvd a b)","decl":"theorem abs_dvd_abs (a b : α) : |a| ∣ |b| ↔ a ∣ b :=\n  (abs_dvd _ _).trans (dvd_abs _ _)\n\n"}
{"name":"pow_eq_pow_iff_of_ne_zero","module":"Mathlib.Algebra.Order.Ring.Abs","initialProofState":"R : Type u_2\ninst✝ : LinearOrderedRing R\na b : R\nn : Nat\nhn : Ne n 0\n⊢ Iff (Eq (HPow.hPow a n) (HPow.hPow b n)) (Or (Eq a b) (And (Eq a (Neg.neg b)) (Even n)))","decl":"lemma pow_eq_pow_iff_of_ne_zero (hn : n ≠ 0) : a ^ n = b ^ n ↔ a = b ∨ a = -b ∧ Even n :=\n  match n.even_xor_odd with\n  | .inl hne => by simp only [*, and_true, ← abs_eq_abs,\n    ← pow_left_inj₀ (abs_nonneg a) (abs_nonneg b) hn, hne.1.pow_abs]\n  | .inr hn => by simp [hn, (hn.1.strictMono_pow (R := R)).injective.eq_iff]\n\n"}
{"name":"pow_eq_pow_iff_cases","module":"Mathlib.Algebra.Order.Ring.Abs","initialProofState":"R : Type u_2\ninst✝ : LinearOrderedRing R\na b : R\nn : Nat\n⊢ Iff (Eq (HPow.hPow a n) (HPow.hPow b n)) (Or (Eq n 0) (Or (Eq a b) (And (Eq a (Neg.neg b)) (Even n))))","decl":"lemma pow_eq_pow_iff_cases : a ^ n = b ^ n ↔ n = 0 ∨ a = b ∨ a = -b ∧ Even n := by\n  rcases eq_or_ne n 0 with rfl | hn <;> simp [pow_eq_pow_iff_of_ne_zero, *]\n\n"}
{"name":"pow_eq_one_iff_of_ne_zero","module":"Mathlib.Algebra.Order.Ring.Abs","initialProofState":"R : Type u_2\ninst✝ : LinearOrderedRing R\na : R\nn : Nat\nhn : Ne n 0\n⊢ Iff (Eq (HPow.hPow a n) 1) (Or (Eq a 1) (And (Eq a (-1)) (Even n)))","decl":"lemma pow_eq_one_iff_of_ne_zero (hn : n ≠ 0) : a ^ n = 1 ↔ a = 1 ∨ a = -1 ∧ Even n := by\n  simp [← pow_eq_pow_iff_of_ne_zero hn]\n\n"}
{"name":"pow_eq_one_iff_cases","module":"Mathlib.Algebra.Order.Ring.Abs","initialProofState":"R : Type u_2\ninst✝ : LinearOrderedRing R\na : R\nn : Nat\n⊢ Iff (Eq (HPow.hPow a n) 1) (Or (Eq n 0) (Or (Eq a 1) (And (Eq a (-1)) (Even n))))","decl":"lemma pow_eq_one_iff_cases : a ^ n = 1 ↔ n = 0 ∨ a = 1 ∨ a = -1 ∧ Even n := by\n  simp [← pow_eq_pow_iff_cases]\n\n"}
{"name":"pow_eq_neg_pow_iff","module":"Mathlib.Algebra.Order.Ring.Abs","initialProofState":"R : Type u_2\ninst✝ : LinearOrderedRing R\na b : R\nn : Nat\nhb : Ne b 0\n⊢ Iff (Eq (HPow.hPow a n) (Neg.neg (HPow.hPow b n))) (And (Eq a (Neg.neg b)) (Odd n))","decl":"lemma pow_eq_neg_pow_iff (hb : b ≠ 0) : a ^ n = -b ^ n ↔ a = -b ∧ Odd n :=\n  match n.even_or_odd with\n  | .inl he =>\n    suffices a ^ n > -b ^ n by simpa [he, not_odd_iff_even.2 he] using this.ne'\n    lt_of_lt_of_le (by simp [he.pow_pos hb]) (he.pow_nonneg _)\n  | .inr ho => by\n    simp only [ho, and_true, ← ho.neg_pow, (ho.strictMono_pow (R := R)).injective.eq_iff]\n\n"}
{"name":"pow_eq_neg_one_iff","module":"Mathlib.Algebra.Order.Ring.Abs","initialProofState":"R : Type u_2\ninst✝ : LinearOrderedRing R\na : R\nn : Nat\n⊢ Iff (Eq (HPow.hPow a n) (-1)) (And (Eq a (-1)) (Odd n))","decl":"lemma pow_eq_neg_one_iff : a ^ n = -1 ↔ a = -1 ∧ Odd n := by\n  simpa using pow_eq_neg_pow_iff (R := R) one_ne_zero\n\n"}
{"name":"Odd.mod_even_iff","module":"Mathlib.Algebra.Order.Ring.Abs","initialProofState":"n a : Nat\nha : Even a\n⊢ Iff (Odd (HMod.hMod n a)) (Odd n)","decl":"/-- If `a` is even, then `n` is odd iff `n % a` is odd. -/\nlemma Odd.mod_even_iff (ha : Even a) : Odd (n % a) ↔ Odd n :=\n  ((even_sub' <| mod_le n a).mp <|\n      even_iff_two_dvd.mpr <| (even_iff_two_dvd.mp ha).trans <| dvd_sub_mod n).symm\n\n"}
{"name":"Even.mod_even_iff","module":"Mathlib.Algebra.Order.Ring.Abs","initialProofState":"n a : Nat\nha : Even a\n⊢ Iff (Even (HMod.hMod n a)) (Even n)","decl":"/-- If `a` is even, then `n` is even iff `n % a` is even. -/\nlemma Even.mod_even_iff (ha : Even a) : Even (n % a) ↔ Even n :=\n  ((even_sub <| mod_le n a).mp <|\n      even_iff_two_dvd.mpr <| (even_iff_two_dvd.mp ha).trans <| dvd_sub_mod n).symm\n\n"}
{"name":"Odd.mod_even","module":"Mathlib.Algebra.Order.Ring.Abs","initialProofState":"n a : Nat\nhn : Odd n\nha : Even a\n⊢ Odd (HMod.hMod n a)","decl":"/-- If `n` is odd and `a` is even, then `n % a` is odd. -/\nlemma Odd.mod_even (hn : Odd n) (ha : Even a) : Odd (n % a) := (Odd.mod_even_iff ha).mpr hn\n\n"}
{"name":"Even.mod_even","module":"Mathlib.Algebra.Order.Ring.Abs","initialProofState":"n a : Nat\nhn : Even n\nha : Even a\n⊢ Even (HMod.hMod n a)","decl":"/-- If `n` is even and `a` is even, then `n % a` is even. -/\nlemma Even.mod_even (hn : Even n) (ha : Even a) : Even (n % a) :=\n  (Even.mod_even_iff ha).mpr hn\n\n"}
{"name":"Odd.of_dvd_nat","module":"Mathlib.Algebra.Order.Ring.Abs","initialProofState":"m n : Nat\nhn : Odd n\nhm : Dvd.dvd m n\n⊢ Odd m","decl":"lemma Odd.of_dvd_nat (hn : Odd n) (hm : m ∣ n) : Odd m :=\n  not_even_iff_odd.1 <| mt hm.even (not_even_iff_odd.2 hn)\n\n"}
{"name":"Odd.ne_two_of_dvd_nat","module":"Mathlib.Algebra.Order.Ring.Abs","initialProofState":"m n : Nat\nhn : Odd n\nhm : Dvd.dvd m n\n⊢ Ne m 2","decl":"/-- `2` is not a factor of an odd natural number. -/\nlemma Odd.ne_two_of_dvd_nat {m n : ℕ} (hn : Odd n) (hm : m ∣ n) : m ≠ 2 := by\n  rintro rfl\n  exact absurd (hn.of_dvd_nat hm) (by decide)\n"}
