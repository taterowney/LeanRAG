{"name":"IsNilpotent.mk","module":"Mathlib.RingTheory.Nilpotent.Defs","initialProofState":"R : Type u_1\ninst✝¹ : Zero R\ninst✝ : Pow R Nat\nx : R\nn : Nat\ne : Eq (HPow.hPow x n) 0\n⊢ IsNilpotent x","decl":"theorem IsNilpotent.mk [Zero R] [Pow R ℕ] (x : R) (n : ℕ) (e : x ^ n = 0) : IsNilpotent x :=\n  ⟨n, e⟩\n\n"}
{"name":"isNilpotent_of_subsingleton","module":"Mathlib.RingTheory.Nilpotent.Defs","initialProofState":"R : Type u_1\nx : R\ninst✝² : Zero R\ninst✝¹ : Pow R Nat\ninst✝ : Subsingleton R\n⊢ IsNilpotent x","decl":"@[simp] lemma isNilpotent_of_subsingleton [Zero R] [Pow R ℕ] [Subsingleton R] : IsNilpotent x :=\n  ⟨0, Subsingleton.elim _ _⟩\n\n"}
{"name":"IsNilpotent.zero","module":"Mathlib.RingTheory.Nilpotent.Defs","initialProofState":"R : Type u_1\ninst✝ : MonoidWithZero R\n⊢ IsNilpotent 0","decl":"@[simp] theorem IsNilpotent.zero [MonoidWithZero R] : IsNilpotent (0 : R) :=\n  ⟨1, pow_one 0⟩\n\n"}
{"name":"not_isNilpotent_one","module":"Mathlib.RingTheory.Nilpotent.Defs","initialProofState":"R : Type u_1\ninst✝¹ : MonoidWithZero R\ninst✝ : Nontrivial R\n⊢ Not (IsNilpotent 1)","decl":"theorem not_isNilpotent_one [MonoidWithZero R] [Nontrivial R] :\n    ¬ IsNilpotent (1 : R) := fun ⟨_, H⟩ ↦ zero_ne_one (H.symm.trans (one_pow _))\n\n"}
{"name":"IsNilpotent.pow_succ","module":"Mathlib.RingTheory.Nilpotent.Defs","initialProofState":"n : Nat\nS : Type u_3\ninst✝ : MonoidWithZero S\nx : S\nhx : IsNilpotent x\n⊢ IsNilpotent (HPow.hPow x n.succ)","decl":"lemma IsNilpotent.pow_succ (n : ℕ) {S : Type*} [MonoidWithZero S] {x : S}\n    (hx : IsNilpotent x) : IsNilpotent (x ^ n.succ) := by\n  obtain ⟨N, hN⟩ := hx\n  use N\n  rw [← pow_mul, Nat.succ_mul, pow_add, hN, mul_zero]\n\n"}
{"name":"IsNilpotent.of_pow","module":"Mathlib.RingTheory.Nilpotent.Defs","initialProofState":"R : Type u_1\ninst✝ : MonoidWithZero R\nx : R\nm : Nat\nh : IsNilpotent (HPow.hPow x m)\n⊢ IsNilpotent x","decl":"theorem IsNilpotent.of_pow [MonoidWithZero R] {x : R} {m : ℕ}\n    (h : IsNilpotent (x ^ m)) : IsNilpotent x := by\n  obtain ⟨n, h⟩ := h\n  use m * n\n  rw [← h, pow_mul x m n]\n\n"}
{"name":"IsNilpotent.pow_of_pos","module":"Mathlib.RingTheory.Nilpotent.Defs","initialProofState":"n : Nat\nS : Type u_3\ninst✝ : MonoidWithZero S\nx : S\nhx : IsNilpotent x\nhn : Ne n 0\n⊢ IsNilpotent (HPow.hPow x n)","decl":"lemma IsNilpotent.pow_of_pos {n} {S : Type*} [MonoidWithZero S] {x : S}\n    (hx : IsNilpotent x) (hn : n ≠ 0) : IsNilpotent (x ^ n) := by\n  cases n with\n  | zero => contradiction\n  | succ => exact IsNilpotent.pow_succ _ hx\n\n"}
{"name":"IsNilpotent.pow_iff_pos","module":"Mathlib.RingTheory.Nilpotent.Defs","initialProofState":"n : Nat\nS : Type u_3\ninst✝ : MonoidWithZero S\nx : S\nhn : Ne n 0\n⊢ Iff (IsNilpotent (HPow.hPow x n)) (IsNilpotent x)","decl":"@[simp]\nlemma IsNilpotent.pow_iff_pos {n} {S : Type*} [MonoidWithZero S] {x : S} (hn : n ≠ 0) :\n    IsNilpotent (x ^ n) ↔ IsNilpotent x :=\n  ⟨of_pow, (pow_of_pos · hn)⟩\n\n"}
{"name":"IsNilpotent.map","module":"Mathlib.RingTheory.Nilpotent.Defs","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝³ : MonoidWithZero R\ninst✝² : MonoidWithZero S\nr : R\nF : Type u_3\ninst✝¹ : FunLike F R S\ninst✝ : MonoidWithZeroHomClass F R S\nhr : IsNilpotent r\nf : F\n⊢ IsNilpotent (f r)","decl":"theorem IsNilpotent.map [MonoidWithZero R] [MonoidWithZero S] {r : R} {F : Type*}\n    [FunLike F R S] [MonoidWithZeroHomClass F R S] (hr : IsNilpotent r) (f : F) :\n    IsNilpotent (f r) := by\n  use hr.choose\n  rw [← map_pow, hr.choose_spec, map_zero]\n\n"}
{"name":"IsNilpotent.map_iff","module":"Mathlib.RingTheory.Nilpotent.Defs","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝³ : MonoidWithZero R\ninst✝² : MonoidWithZero S\nr : R\nF : Type u_3\ninst✝¹ : FunLike F R S\ninst✝ : MonoidWithZeroHomClass F R S\nf : F\nhf : Function.Injective ⇑f\n⊢ Iff (IsNilpotent (f r)) (IsNilpotent r)","decl":"lemma IsNilpotent.map_iff [MonoidWithZero R] [MonoidWithZero S] {r : R} {F : Type*}\n    [FunLike F R S] [MonoidWithZeroHomClass F R S] {f : F} (hf : Function.Injective f) :\n    IsNilpotent (f r) ↔ IsNilpotent r :=\n  ⟨fun ⟨k, hk⟩ ↦ ⟨k, (map_eq_zero_iff f hf).mp <| by rwa [map_pow]⟩, fun h ↦ h.map f⟩\n\n"}
{"name":"IsUnit.isNilpotent_mul_unit_of_commute_iff","module":"Mathlib.RingTheory.Nilpotent.Defs","initialProofState":"R : Type u_1\ninst✝ : MonoidWithZero R\nr u : R\nhu : IsUnit u\nh_comm : Commute r u\n⊢ Iff (IsNilpotent (HMul.hMul r u)) (IsNilpotent r)","decl":"theorem IsUnit.isNilpotent_mul_unit_of_commute_iff [MonoidWithZero R] {r u : R}\n    (hu : IsUnit u) (h_comm : Commute r u) :\n    IsNilpotent (r * u) ↔ IsNilpotent r :=\n  exists_congr fun n ↦ by rw [h_comm.mul_pow, (hu.pow n).mul_left_eq_zero]\n\n"}
{"name":"IsUnit.isNilpotent_unit_mul_of_commute_iff","module":"Mathlib.RingTheory.Nilpotent.Defs","initialProofState":"R : Type u_1\ninst✝ : MonoidWithZero R\nr u : R\nhu : IsUnit u\nh_comm : Commute r u\n⊢ Iff (IsNilpotent (HMul.hMul u r)) (IsNilpotent r)","decl":"theorem IsUnit.isNilpotent_unit_mul_of_commute_iff [MonoidWithZero R] {r u : R}\n    (hu : IsUnit u) (h_comm : Commute r u) :\n    IsNilpotent (u * r) ↔ IsNilpotent r :=\n  h_comm ▸ hu.isNilpotent_mul_unit_of_commute_iff h_comm\n\n"}
{"name":"nilpotencyClass_eq_zero_of_subsingleton","module":"Mathlib.RingTheory.Nilpotent.Defs","initialProofState":"R : Type u_1\nx : R\ninst✝² : Zero R\ninst✝¹ : Pow R Nat\ninst✝ : Subsingleton R\n⊢ Eq (nilpotencyClass x) 0","decl":"@[simp] lemma nilpotencyClass_eq_zero_of_subsingleton [Subsingleton R] :\n    nilpotencyClass x = 0 := by\n  let s : Set ℕ := {k | x ^ k = 0}\n  suffices s = univ by change sInf _ = 0; simp [s] at this; simp [this]\n  exact eq_univ_iff_forall.mpr fun k ↦ Subsingleton.elim _ _\n\n"}
{"name":"isNilpotent_of_pos_nilpotencyClass","module":"Mathlib.RingTheory.Nilpotent.Defs","initialProofState":"R : Type u_1\nx : R\ninst✝¹ : Zero R\ninst✝ : Pow R Nat\nhx : LT.lt 0 (nilpotencyClass x)\n⊢ IsNilpotent x","decl":"lemma isNilpotent_of_pos_nilpotencyClass (hx : 0 < nilpotencyClass x) :\n    IsNilpotent x := by\n  let s : Set ℕ := {k | x ^ k = 0}\n  change s.Nonempty\n  change 0 < sInf s at hx\n  by_contra contra\n  simp [not_nonempty_iff_eq_empty.mp contra] at hx\n\n"}
{"name":"pow_nilpotencyClass","module":"Mathlib.RingTheory.Nilpotent.Defs","initialProofState":"R : Type u_1\nx : R\ninst✝¹ : Zero R\ninst✝ : Pow R Nat\nhx : IsNilpotent x\n⊢ Eq (HPow.hPow x (nilpotencyClass x)) 0","decl":"lemma pow_nilpotencyClass (hx : IsNilpotent x) : x ^ (nilpotencyClass x) = 0 :=\n  Nat.sInf_mem hx\n\n"}
{"name":"nilpotencyClass_eq_succ_iff","module":"Mathlib.RingTheory.Nilpotent.Defs","initialProofState":"R : Type u_1\nx : R\ninst✝ : MonoidWithZero R\nk : Nat\n⊢ Iff (Eq (nilpotencyClass x) (HAdd.hAdd k 1)) (And (Eq (HPow.hPow x (HAdd.hAdd k 1)) 0) (Ne (HPow.hPow x k) 0))","decl":"lemma nilpotencyClass_eq_succ_iff {k : ℕ} :\n    nilpotencyClass x = k + 1 ↔ x ^ (k + 1) = 0 ∧ x ^ k ≠ 0 := by\n  let s : Set ℕ := {k | x ^ k = 0}\n  have : ∀ k₁ k₂ : ℕ, k₁ ≤ k₂ → k₁ ∈ s → k₂ ∈ s := fun k₁ k₂ h_le hk₁ ↦ pow_eq_zero_of_le h_le hk₁\n  simp [s, nilpotencyClass, Nat.sInf_upward_closed_eq_succ_iff this]\n\n"}
{"name":"nilpotencyClass_zero","module":"Mathlib.RingTheory.Nilpotent.Defs","initialProofState":"R : Type u_1\ninst✝¹ : MonoidWithZero R\ninst✝ : Nontrivial R\n⊢ Eq (nilpotencyClass 0) 1","decl":"@[simp] lemma nilpotencyClass_zero [Nontrivial R] :\n    nilpotencyClass (0 : R) = 1 :=\n  nilpotencyClass_eq_succ_iff.mpr <| by constructor <;> simp\n\n"}
{"name":"pos_nilpotencyClass_iff","module":"Mathlib.RingTheory.Nilpotent.Defs","initialProofState":"R : Type u_1\nx : R\ninst✝¹ : MonoidWithZero R\ninst✝ : Nontrivial R\n⊢ Iff (LT.lt 0 (nilpotencyClass x)) (IsNilpotent x)","decl":"@[simp] lemma pos_nilpotencyClass_iff [Nontrivial R] :\n    0 < nilpotencyClass x ↔ IsNilpotent x := by\n  refine ⟨isNilpotent_of_pos_nilpotencyClass, fun hx ↦ Nat.pos_of_ne_zero fun hx' ↦ ?_⟩\n  replace hx := pow_nilpotencyClass hx\n  rw [hx', pow_zero] at hx\n  exact one_ne_zero hx\n\n"}
{"name":"pow_pred_nilpotencyClass","module":"Mathlib.RingTheory.Nilpotent.Defs","initialProofState":"R : Type u_1\nx : R\ninst✝¹ : MonoidWithZero R\ninst✝ : Nontrivial R\nhx : IsNilpotent x\n⊢ Ne (HPow.hPow x (HSub.hSub (nilpotencyClass x) 1)) 0","decl":"lemma pow_pred_nilpotencyClass [Nontrivial R] (hx : IsNilpotent x) :\n    x ^ (nilpotencyClass x - 1) ≠ 0 :=\n  (nilpotencyClass_eq_succ_iff.mp <| Nat.eq_add_of_sub_eq (pos_nilpotencyClass_iff.mpr hx) rfl).2\n\n"}
{"name":"eq_zero_of_nilpotencyClass_eq_one","module":"Mathlib.RingTheory.Nilpotent.Defs","initialProofState":"R : Type u_1\nx : R\ninst✝ : MonoidWithZero R\nhx : Eq (nilpotencyClass x) 1\n⊢ Eq x 0","decl":"lemma eq_zero_of_nilpotencyClass_eq_one (hx : nilpotencyClass x = 1) :\n    x = 0 := by\n  have : IsNilpotent x := isNilpotent_of_pos_nilpotencyClass (hx ▸ Nat.one_pos)\n  rw [← pow_nilpotencyClass this, hx, pow_one]\n\n"}
{"name":"nilpotencyClass_eq_one","module":"Mathlib.RingTheory.Nilpotent.Defs","initialProofState":"R : Type u_1\nx : R\ninst✝¹ : MonoidWithZero R\ninst✝ : Nontrivial R\n⊢ Iff (Eq (nilpotencyClass x) 1) (Eq x 0)","decl":"@[simp] lemma nilpotencyClass_eq_one [Nontrivial R] :\n    nilpotencyClass x = 1 ↔ x = 0 :=\n  ⟨eq_zero_of_nilpotencyClass_eq_one, fun hx ↦ hx ▸ nilpotencyClass_zero⟩\n\n"}
{"name":"IsReduced.eq_zero","module":"Mathlib.RingTheory.Nilpotent.Defs","initialProofState":"R : Type u_3\ninst✝¹ : Zero R\ninst✝ : Pow R Nat\nself : IsReduced R\nx : R\na✝ : IsNilpotent x\n⊢ Eq x 0","decl":"/-- A structure that has zero and pow is reduced if it has no nonzero nilpotent elements. -/\n@[mk_iff]\nclass IsReduced (R : Type*) [Zero R] [Pow R ℕ] : Prop where\n  /-- A reduced structure has no nonzero nilpotent elements. -/\n  eq_zero : ∀ x : R, IsNilpotent x → x = 0\n\n"}
{"name":"isReduced_iff","module":"Mathlib.RingTheory.Nilpotent.Defs","initialProofState":"R : Type u_3\ninst✝¹ : Zero R\ninst✝ : Pow R Nat\n⊢ Iff (IsReduced R) (∀ (x : R), IsNilpotent x → Eq x 0)","decl":"/-- A structure that has zero and pow is reduced if it has no nonzero nilpotent elements. -/\n@[mk_iff]\nclass IsReduced (R : Type*) [Zero R] [Pow R ℕ] : Prop where\n  /-- A reduced structure has no nonzero nilpotent elements. -/\n  eq_zero : ∀ x : R, IsNilpotent x → x = 0\n\n"}
{"name":"IsReduced.pow_eq_zero","module":"Mathlib.RingTheory.Nilpotent.Defs","initialProofState":"R : Type u_1\nx : R\ninst✝² : Zero R\ninst✝¹ : Pow R Nat\ninst✝ : IsReduced R\nn : Nat\nh : Eq (HPow.hPow x n) 0\n⊢ Eq x 0","decl":"theorem pow_eq_zero [Zero R] [Pow R ℕ] [IsReduced R] {n : ℕ} (h : x ^ n = 0) :\n    x = 0 := IsReduced.eq_zero x ⟨n, h⟩\n\n"}
{"name":"IsReduced.pow_eq_zero_iff","module":"Mathlib.RingTheory.Nilpotent.Defs","initialProofState":"R : Type u_1\nx : R\ninst✝¹ : MonoidWithZero R\ninst✝ : IsReduced R\nn : Nat\nhn : Ne n 0\n⊢ Iff (Eq (HPow.hPow x n) 0) (Eq x 0)","decl":"@[simp]\ntheorem pow_eq_zero_iff [MonoidWithZero R] [IsReduced R] {n : ℕ} (hn : n ≠ 0) :\n    x ^ n = 0 ↔ x = 0 := ⟨pow_eq_zero, fun h ↦ h.symm ▸ zero_pow hn⟩\n\n"}
{"name":"IsReduced.pow_ne_zero_iff","module":"Mathlib.RingTheory.Nilpotent.Defs","initialProofState":"R : Type u_1\nx : R\ninst✝¹ : MonoidWithZero R\ninst✝ : IsReduced R\nn : Nat\nhn : Ne n 0\n⊢ Iff (Ne (HPow.hPow x n) 0) (Ne x 0)","decl":"theorem pow_ne_zero_iff [MonoidWithZero R] [IsReduced R] {n : ℕ} (hn : n ≠ 0) :\n    x ^ n ≠ 0 ↔ x ≠ 0 := not_congr (pow_eq_zero_iff hn)\n\n"}
{"name":"IsReduced.pow_ne_zero","module":"Mathlib.RingTheory.Nilpotent.Defs","initialProofState":"R : Type u_1\nx : R\ninst✝² : Zero R\ninst✝¹ : Pow R Nat\ninst✝ : IsReduced R\nn : Nat\nh : Ne x 0\n⊢ Ne (HPow.hPow x n) 0","decl":"theorem pow_ne_zero [Zero R] [Pow R ℕ] [IsReduced R] (n : ℕ) (h : x ≠ 0) :\n    x ^ n ≠ 0 := fun H ↦ h (pow_eq_zero H)\n\n"}
{"name":"IsReduced.pow_eq_zero_iff'","module":"Mathlib.RingTheory.Nilpotent.Defs","initialProofState":"R : Type u_1\nx : R\ninst✝² : MonoidWithZero R\ninst✝¹ : IsReduced R\ninst✝ : Nontrivial R\nn : Nat\n⊢ Iff (Eq (HPow.hPow x n) 0) (And (Eq x 0) (Ne n 0))","decl":"/-- A variant of `IsReduced.pow_eq_zero_iff` assuming `R` is not trivial. -/\n@[simp]\ntheorem pow_eq_zero_iff' [MonoidWithZero R] [IsReduced R] [Nontrivial R] {n : ℕ} :\n    x ^ n = 0 ↔ x = 0 ∧ n ≠ 0 := by\n  cases n <;> simp\n\n"}
{"name":"isReduced_of_noZeroDivisors","module":"Mathlib.RingTheory.Nilpotent.Defs","initialProofState":"R : Type u_1\ninst✝¹ : MonoidWithZero R\ninst✝ : NoZeroDivisors R\n⊢ IsReduced R","decl":"instance (priority := 900) isReduced_of_noZeroDivisors [MonoidWithZero R] [NoZeroDivisors R] :\n    IsReduced R :=\n  ⟨fun _ ⟨_, hn⟩ => pow_eq_zero hn⟩\n\n"}
{"name":"isReduced_of_subsingleton","module":"Mathlib.RingTheory.Nilpotent.Defs","initialProofState":"R : Type u_1\ninst✝² : Zero R\ninst✝¹ : Pow R Nat\ninst✝ : Subsingleton R\n⊢ IsReduced R","decl":"instance (priority := 900) isReduced_of_subsingleton [Zero R] [Pow R ℕ] [Subsingleton R] :\n    IsReduced R :=\n  ⟨fun _ _ => Subsingleton.elim _ _⟩\n\n"}
{"name":"IsNilpotent.eq_zero","module":"Mathlib.RingTheory.Nilpotent.Defs","initialProofState":"R : Type u_1\nx : R\ninst✝² : Zero R\ninst✝¹ : Pow R Nat\ninst✝ : IsReduced R\nh : IsNilpotent x\n⊢ Eq x 0","decl":"theorem IsNilpotent.eq_zero [Zero R] [Pow R ℕ] [IsReduced R] (h : IsNilpotent x) : x = 0 :=\n  IsReduced.eq_zero x h\n\n"}
{"name":"isNilpotent_iff_eq_zero","module":"Mathlib.RingTheory.Nilpotent.Defs","initialProofState":"R : Type u_1\nx : R\ninst✝¹ : MonoidWithZero R\ninst✝ : IsReduced R\n⊢ Iff (IsNilpotent x) (Eq x 0)","decl":"@[simp]\ntheorem isNilpotent_iff_eq_zero [MonoidWithZero R] [IsReduced R] : IsNilpotent x ↔ x = 0 :=\n  ⟨fun h => h.eq_zero, fun h => h.symm ▸ IsNilpotent.zero⟩\n\n"}
{"name":"isReduced_of_injective","module":"Mathlib.RingTheory.Nilpotent.Defs","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁴ : MonoidWithZero R\ninst✝³ : MonoidWithZero S\nF : Type u_3\ninst✝² : FunLike F R S\ninst✝¹ : MonoidWithZeroHomClass F R S\nf : F\nhf : Function.Injective ⇑f\ninst✝ : IsReduced S\n⊢ IsReduced R","decl":"theorem isReduced_of_injective [MonoidWithZero R] [MonoidWithZero S] {F : Type*}\n    [FunLike F R S] [MonoidWithZeroHomClass F R S]\n    (f : F) (hf : Function.Injective f) [IsReduced S] :\n    IsReduced R := by\n  constructor\n  intro x hx\n  apply hf\n  rw [map_zero]\n  exact (hx.map f).eq_zero\n\n"}
{"name":"instIsReducedForall","module":"Mathlib.RingTheory.Nilpotent.Defs","initialProofState":"ι : Type u_4\nR : ι → Type u_3\ninst✝² : (i : ι) → Zero (R i)\ninst✝¹ : (i : ι) → Pow (R i) Nat\ninst✝ : ∀ (i : ι), IsReduced (R i)\n⊢ IsReduced ((i : ι) → R i)","decl":"instance (ι) (R : ι → Type*) [∀ i, Zero (R i)] [∀ i, Pow (R i) ℕ]\n    [∀ i, IsReduced (R i)] : IsReduced (∀ i, R i) where\n  eq_zero _ := fun ⟨n, hn⟩ ↦ funext fun i ↦ IsReduced.eq_zero _ ⟨n, congr_fun hn i⟩\n\n"}
{"name":"isRadical_iff_pow_one_lt","module":"Mathlib.RingTheory.Nilpotent.Defs","initialProofState":"R : Type u_1\ny : R\ninst✝ : MonoidWithZero R\nk : Nat\nhk : LT.lt 1 k\n⊢ Iff (IsRadical y) (∀ (x : R), Dvd.dvd y (HPow.hPow x k) → Dvd.dvd y x)","decl":"theorem isRadical_iff_pow_one_lt [MonoidWithZero R] (k : ℕ) (hk : 1 < k) :\n    IsRadical y ↔ ∀ x, y ∣ x ^ k → y ∣ x :=\n  ⟨(· k), k.pow_imp_self_of_one_lt hk _ fun _ _ h ↦ .inl (dvd_mul_of_dvd_left h _)⟩\n\n"}
{"name":"Commute.isNilpotent_mul_left","module":"Mathlib.RingTheory.Nilpotent.Defs","initialProofState":"R : Type u_1\nx y : R\ninst✝ : Semiring R\nh_comm : Commute x y\nh : IsNilpotent x\n⊢ IsNilpotent (HMul.hMul x y)","decl":"theorem isNilpotent_mul_left (h_comm : Commute x y) (h : IsNilpotent x) : IsNilpotent (x * y) := by\n  obtain ⟨n, hn⟩ := h\n  use n\n  rw [h_comm.mul_pow, hn, zero_mul]\n\n"}
{"name":"Commute.isNilpotent_mul_right","module":"Mathlib.RingTheory.Nilpotent.Defs","initialProofState":"R : Type u_1\nx y : R\ninst✝ : Semiring R\nh_comm : Commute x y\nh : IsNilpotent y\n⊢ IsNilpotent (HMul.hMul x y)","decl":"theorem isNilpotent_mul_right (h_comm : Commute x y) (h : IsNilpotent y) : IsNilpotent (x * y) := by\n  rw [h_comm.eq]\n  exact h_comm.symm.isNilpotent_mul_left h\n\n"}
