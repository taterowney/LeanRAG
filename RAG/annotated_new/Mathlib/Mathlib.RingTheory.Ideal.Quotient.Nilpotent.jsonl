{"name":"Ideal.isRadical_iff_quotient_reduced","module":"Mathlib.RingTheory.Ideal.Quotient.Nilpotent","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nI : Ideal R\n⊢ Iff I.IsRadical (IsReduced (HasQuotient.Quotient R I))","decl":"theorem Ideal.isRadical_iff_quotient_reduced {R : Type*} [CommRing R] (I : Ideal R) :\n    I.IsRadical ↔ IsReduced (R ⧸ I) := by\n  conv_lhs => rw [← @Ideal.mk_ker R _ I]\n  exact RingHom.ker_isRadical_iff_reduced_of_surjective (@Ideal.Quotient.mk_surjective R _ I)\n\n"}
{"name":"Ideal.IsNilpotent.induction_on","module":"Mathlib.RingTheory.Ideal.Quotient.Nilpotent","initialProofState":"S : Type u_1\ninst✝ : CommRing S\nI : Ideal S\nhI : IsNilpotent I\nP : ⦃S : Type u_1⦄ → [inst : CommRing S] → Ideal S → Prop\nh₁ : ∀ ⦃S : Type u_1⦄ [inst : CommRing S] (I : Ideal S), Eq (HPow.hPow I 2) Bot.bot → P I\nh₂ : ∀ ⦃S : Type u_1⦄ [inst : CommRing S] (I J : Ideal S), LE.le I J → P I → P (Ideal.map (Ideal.Quotient.mk I) J) → P J\n⊢ P I","decl":"/-- Let `P` be a property on ideals. If `P` holds for square-zero ideals, and if\n  `P I → P (J ⧸ I) → P J`, then `P` holds for all nilpotent ideals. -/\ntheorem Ideal.IsNilpotent.induction_on (hI : IsNilpotent I)\n    {P : ∀ ⦃S : Type _⦄ [CommRing S], Ideal S → Prop}\n    (h₁ : ∀ ⦃S : Type _⦄ [CommRing S], ∀ I : Ideal S, I ^ 2 = ⊥ → P I)\n    (h₂ : ∀ ⦃S : Type _⦄ [CommRing S], ∀ I J : Ideal S, I ≤ J → P I →\n      P (J.map (Ideal.Quotient.mk I)) → P J) :\n    P I := by\n  obtain ⟨n, hI : I ^ n = ⊥⟩ := hI\n  induction' n using Nat.strong_induction_on with n H generalizing S\n  by_cases hI' : I = ⊥\n  · subst hI'\n    apply h₁\n    rw [← Ideal.zero_eq_bot, zero_pow two_ne_zero]\n  cases' n with n\n  · rw [pow_zero, Ideal.one_eq_top] at hI\n    haveI := subsingleton_of_bot_eq_top hI.symm\n    exact (hI' (Subsingleton.elim _ _)).elim\n  cases' n with n\n  · rw [pow_one] at hI\n    exact (hI' hI).elim\n  apply h₂ (I ^ 2) _ (Ideal.pow_le_self two_ne_zero)\n  · apply H n.succ _ (I ^ 2)\n    · rw [← pow_mul, eq_bot_iff, ← hI, Nat.succ_eq_add_one]\n      apply Ideal.pow_le_pow_right (by omega)\n    · exact n.succ.lt_succ_self\n  · apply h₁\n    rw [← Ideal.map_pow, Ideal.map_quotient_self]\n\n"}
{"name":"IsNilpotent.isUnit_quotient_mk_iff","module":"Mathlib.RingTheory.Ideal.Quotient.Nilpotent","initialProofState":"R : Type u_2\ninst✝ : CommRing R\nI : Ideal R\nhI : IsNilpotent I\nx : R\n⊢ Iff (IsUnit ((Ideal.Quotient.mk I) x)) (IsUnit x)","decl":"theorem IsNilpotent.isUnit_quotient_mk_iff {R : Type*} [CommRing R] {I : Ideal R}\n    (hI : IsNilpotent I) {x : R} : IsUnit (Ideal.Quotient.mk I x) ↔ IsUnit x := by\n  refine ⟨?_, fun h => h.map <| Ideal.Quotient.mk I⟩\n  revert x\n  apply Ideal.IsNilpotent.induction_on (S := R) I hI <;> clear hI I\n  swap\n  · introv e h₁ h₂ h₃\n    apply h₁\n    apply h₂\n    exact\n      h₃.map\n        ((DoubleQuot.quotQuotEquivQuotSup I J).trans\n              (Ideal.quotEquivOfEq (sup_eq_right.mpr e))).symm.toRingHom\n  · introv e H\n    obtain ⟨y, hy⟩ := Ideal.Quotient.mk_surjective (↑H.unit⁻¹ : S ⧸ I)\n    have : Ideal.Quotient.mk I (x * y) = Ideal.Quotient.mk I 1 := by\n      rw [map_one, _root_.map_mul, hy, IsUnit.mul_val_inv]\n    rw [Ideal.Quotient.eq] at this\n    have : (x * y - 1) ^ 2 = 0 := by\n      rw [← Ideal.mem_bot, ← e]\n      exact Ideal.pow_mem_pow this _\n    have : x * (y * (2 - x * y)) = 1 := by\n      rw [eq_comm, ← sub_eq_zero, ← this]\n      ring\n    exact isUnit_of_mul_eq_one _ _ this\n"}
