{"name":"CategoryTheory.Cat.HasLimits.homDiagram_map","module":"Mathlib.CategoryTheory.Category.Cat.Limit","initialProofState":"J : Type v\ninstâœ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J CategoryTheory.Cat\nX Y : CategoryTheory.Limits.limit (F.comp CategoryTheory.Cat.objects)\nXâœ Yâœ : J\nf : Quiver.Hom Xâœ Yâœ\ng : Quiver.Hom (CategoryTheory.Limits.limit.Ï€ (F.comp CategoryTheory.Cat.objects) Xâœ X) (CategoryTheory.Limits.limit.Ï€ (F.comp CategoryTheory.Cat.objects) Xâœ Y)\nâŠ¢ Eq ((CategoryTheory.Cat.HasLimits.homDiagram X Y).map f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom â‹¯) (CategoryTheory.CategoryStruct.comp ((F.map f).map g) (CategoryTheory.eqToHom â‹¯)))","decl":"/-- Auxiliary definition:\nthe diagram whose limit gives the morphism space between two objects of the limit category. -/\n@[simps]\ndef homDiagram {F : J â¥¤ Cat.{v, v}} (X Y : limit (F â‹™ Cat.objects.{v, v})) : J â¥¤ Type v where\n  obj j := limit.Ï€ (F â‹™ Cat.objects) j X âŸ¶ limit.Ï€ (F â‹™ Cat.objects) j Y\n  map f g := by\n    refine eqToHom ?_ â‰« (F.map f).map g â‰« eqToHom ?_\n    Â· exact (congr_fun (limit.w (F â‹™ Cat.objects) f) X).symm\n    Â· exact congr_fun (limit.w (F â‹™ Cat.objects) f) Y\n  map_id X := by\n    funext f\n    letI : Category (objects.obj (F.obj X)) := (inferInstance : Category (F.obj X))\n    simp [Functor.congr_hom (F.map_id X) f]\n  map_comp {_ _ Z} f g := by\n    funext h\n    letI : Category (objects.obj (F.obj Z)) := (inferInstance : Category (F.obj Z))\n    simp [Functor.congr_hom (F.map_comp f g) h, eqToHom_map]\n\n"}
{"name":"CategoryTheory.Cat.HasLimits.homDiagram_obj","module":"Mathlib.CategoryTheory.Category.Cat.Limit","initialProofState":"J : Type v\ninstâœ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J CategoryTheory.Cat\nX Y : CategoryTheory.Limits.limit (F.comp CategoryTheory.Cat.objects)\nj : J\nâŠ¢ Eq ((CategoryTheory.Cat.HasLimits.homDiagram X Y).obj j) (Quiver.Hom (CategoryTheory.Limits.limit.Ï€ (F.comp CategoryTheory.Cat.objects) j X) (CategoryTheory.Limits.limit.Ï€ (F.comp CategoryTheory.Cat.objects) j Y))","decl":"/-- Auxiliary definition:\nthe diagram whose limit gives the morphism space between two objects of the limit category. -/\n@[simps]\ndef homDiagram {F : J â¥¤ Cat.{v, v}} (X Y : limit (F â‹™ Cat.objects.{v, v})) : J â¥¤ Type v where\n  obj j := limit.Ï€ (F â‹™ Cat.objects) j X âŸ¶ limit.Ï€ (F â‹™ Cat.objects) j Y\n  map f g := by\n    refine eqToHom ?_ â‰« (F.map f).map g â‰« eqToHom ?_\n    Â· exact (congr_fun (limit.w (F â‹™ Cat.objects) f) X).symm\n    Â· exact congr_fun (limit.w (F â‹™ Cat.objects) f) Y\n  map_id X := by\n    funext f\n    letI : Category (objects.obj (F.obj X)) := (inferInstance : Category (F.obj X))\n    simp [Functor.congr_hom (F.map_id X) f]\n  map_comp {_ _ Z} f g := by\n    funext h\n    letI : Category (objects.obj (F.obj Z)) := (inferInstance : Category (F.obj Z))\n    simp [Functor.congr_hom (F.map_comp f g) h, eqToHom_map]\n\n"}
{"name":"CategoryTheory.Cat.HasLimits.instCategoryLimitCompObjects_comp","module":"Mathlib.CategoryTheory.Category.Cat.Limit","initialProofState":"J : Type v\ninstâœ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J CategoryTheory.Cat\nX Y Z : CategoryTheory.Limits.limit (F.comp CategoryTheory.Cat.objects)\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.Limits.Types.Limit.mk (CategoryTheory.Cat.HasLimits.homDiagram X Z) (fun j => CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ (CategoryTheory.Cat.HasLimits.homDiagram X Y) j f) (CategoryTheory.Limits.limit.Ï€ (CategoryTheory.Cat.HasLimits.homDiagram Y Z) j g)) â‹¯)","decl":"@[simps]\ninstance (F : J â¥¤ Cat.{v, v}) : Category (limit (F â‹™ Cat.objects)) where\n  Hom X Y := limit (homDiagram X Y)\n  id X := Types.Limit.mk.{v, v} (homDiagram X X) (fun _ => ðŸ™ _) fun j j' f => by simp\n  comp {X Y Z} f g :=\n    Types.Limit.mk.{v, v} (homDiagram X Z)\n      (fun j => limit.Ï€ (homDiagram X Y) j f â‰« limit.Ï€ (homDiagram Y Z) j g) fun j j' h => by\n      simp [â† congr_fun (limit.w (homDiagram X Y) h) f,\n        â† congr_fun (limit.w (homDiagram Y Z) h) g]\n  id_comp _ := by\n    apply Types.limit_ext.{v, v}\n    simp\n  comp_id _ := by\n    apply Types.limit_ext.{v, v}\n    simp\n\n"}
{"name":"CategoryTheory.Cat.HasLimits.instCategoryLimitCompObjects_id","module":"Mathlib.CategoryTheory.Category.Cat.Limit","initialProofState":"J : Type v\ninstâœ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J CategoryTheory.Cat\nX : CategoryTheory.Limits.limit (F.comp CategoryTheory.Cat.objects)\nâŠ¢ Eq (CategoryTheory.CategoryStruct.id X) (CategoryTheory.Limits.Types.Limit.mk (CategoryTheory.Cat.HasLimits.homDiagram X X) (fun x => CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.limit.Ï€ (F.comp CategoryTheory.Cat.objects) x X)) â‹¯)","decl":"@[simps]\ninstance (F : J â¥¤ Cat.{v, v}) : Category (limit (F â‹™ Cat.objects)) where\n  Hom X Y := limit (homDiagram X Y)\n  id X := Types.Limit.mk.{v, v} (homDiagram X X) (fun _ => ðŸ™ _) fun j j' f => by simp\n  comp {X Y Z} f g :=\n    Types.Limit.mk.{v, v} (homDiagram X Z)\n      (fun j => limit.Ï€ (homDiagram X Y) j f â‰« limit.Ï€ (homDiagram Y Z) j g) fun j j' h => by\n      simp [â† congr_fun (limit.w (homDiagram X Y) h) f,\n        â† congr_fun (limit.w (homDiagram Y Z) h) g]\n  id_comp _ := by\n    apply Types.limit_ext.{v, v}\n    simp\n  comp_id _ := by\n    apply Types.limit_ext.{v, v}\n    simp\n\n"}
{"name":"CategoryTheory.Cat.HasLimits.limitConeX_Î±","module":"Mathlib.CategoryTheory.Category.Cat.Limit","initialProofState":"J : Type v\ninstâœ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J CategoryTheory.Cat\nâŠ¢ Eq (â†‘(CategoryTheory.Cat.HasLimits.limitConeX F)) (CategoryTheory.Limits.limit (F.comp CategoryTheory.Cat.objects))","decl":"/-- Auxiliary definition: the limit category. -/\n@[simps]\ndef limitConeX (F : J â¥¤ Cat.{v, v}) : Cat.{v, v} where Î± := limit (F â‹™ Cat.objects)\n\n"}
{"name":"CategoryTheory.Cat.HasLimits.limitConeX_str","module":"Mathlib.CategoryTheory.Category.Cat.Limit","initialProofState":"J : Type v\ninstâœ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J CategoryTheory.Cat\nâŠ¢ Eq (CategoryTheory.Cat.HasLimits.limitConeX F).str inferInstance","decl":"/-- Auxiliary definition: the limit category. -/\n@[simps]\ndef limitConeX (F : J â¥¤ Cat.{v, v}) : Cat.{v, v} where Î± := limit (F â‹™ Cat.objects)\n\n"}
{"name":"CategoryTheory.Cat.HasLimits.limitCone_Ï€_app_map","module":"Mathlib.CategoryTheory.Category.Cat.Limit","initialProofState":"J : Type v\ninstâœ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J CategoryTheory.Cat\nj : J\nXâœ Yâœ : â†‘(((CategoryTheory.Functor.const J).obj (CategoryTheory.Cat.HasLimits.limitConeX F)).obj j)\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq (((CategoryTheory.Cat.HasLimits.limitCone F).Ï€.app j).map f) (CategoryTheory.Limits.limit.Ï€ (CategoryTheory.Cat.HasLimits.homDiagram Xâœ Yâœ) j f)","decl":"/-- Auxiliary definition: the cone over the limit category. -/\n@[simps]\ndef limitCone (F : J â¥¤ Cat.{v, v}) : Cone F where\n  pt := limitConeX F\n  Ï€ :=\n    { app := fun j =>\n        { obj := limit.Ï€ (F â‹™ Cat.objects) j\n          map := fun f => limit.Ï€ (homDiagram _ _) j f }\n      naturality := fun _ _ f =>\n        CategoryTheory.Functor.ext (fun X => (congr_fun (limit.w (F â‹™ Cat.objects) f) X).symm)\n          fun X Y h => (congr_fun (limit.w (homDiagram X Y) f) h).symm }\n\n"}
{"name":"CategoryTheory.Cat.HasLimits.limitCone_Ï€_app_obj","module":"Mathlib.CategoryTheory.Category.Cat.Limit","initialProofState":"J : Type v\ninstâœ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J CategoryTheory.Cat\nj : J\naâœ : CategoryTheory.Limits.limit (F.comp CategoryTheory.Cat.objects)\nâŠ¢ Eq (((CategoryTheory.Cat.HasLimits.limitCone F).Ï€.app j).obj aâœ) (CategoryTheory.Limits.limit.Ï€ (F.comp CategoryTheory.Cat.objects) j aâœ)","decl":"/-- Auxiliary definition: the cone over the limit category. -/\n@[simps]\ndef limitCone (F : J â¥¤ Cat.{v, v}) : Cone F where\n  pt := limitConeX F\n  Ï€ :=\n    { app := fun j =>\n        { obj := limit.Ï€ (F â‹™ Cat.objects) j\n          map := fun f => limit.Ï€ (homDiagram _ _) j f }\n      naturality := fun _ _ f =>\n        CategoryTheory.Functor.ext (fun X => (congr_fun (limit.w (F â‹™ Cat.objects) f) X).symm)\n          fun X Y h => (congr_fun (limit.w (homDiagram X Y) f) h).symm }\n\n"}
{"name":"CategoryTheory.Cat.HasLimits.limitCone_pt","module":"Mathlib.CategoryTheory.Category.Cat.Limit","initialProofState":"J : Type v\ninstâœ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J CategoryTheory.Cat\nâŠ¢ Eq (CategoryTheory.Cat.HasLimits.limitCone F).pt (CategoryTheory.Cat.HasLimits.limitConeX F)","decl":"/-- Auxiliary definition: the cone over the limit category. -/\n@[simps]\ndef limitCone (F : J â¥¤ Cat.{v, v}) : Cone F where\n  pt := limitConeX F\n  Ï€ :=\n    { app := fun j =>\n        { obj := limit.Ï€ (F â‹™ Cat.objects) j\n          map := fun f => limit.Ï€ (homDiagram _ _) j f }\n      naturality := fun _ _ f =>\n        CategoryTheory.Functor.ext (fun X => (congr_fun (limit.w (F â‹™ Cat.objects) f) X).symm)\n          fun X Y h => (congr_fun (limit.w (homDiagram X Y) f) h).symm }\n\n"}
{"name":"CategoryTheory.Cat.HasLimits.limitConeLift_obj","module":"Mathlib.CategoryTheory.Category.Cat.Limit","initialProofState":"J : Type v\ninstâœ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J CategoryTheory.Cat\ns : CategoryTheory.Limits.Cone F\naâœ : { pt := â†‘s.pt, Ï€ := { app := fun j => (s.Ï€.app j).obj, naturality := â‹¯ } }.pt\nâŠ¢ Eq ((CategoryTheory.Cat.HasLimits.limitConeLift F s).obj aâœ) (CategoryTheory.Limits.limit.lift (F.comp CategoryTheory.Cat.objects) { pt := â†‘s.pt, Ï€ := { app := fun j => (s.Ï€.app j).obj, naturality := â‹¯ } } aâœ)","decl":"/-- Auxiliary definition: the universal morphism to the proposed limit cone. -/\n@[simps]\ndef limitConeLift (F : J â¥¤ Cat.{v, v}) (s : Cone F) : s.pt âŸ¶ limitConeX F where\n  obj :=\n    limit.lift (F â‹™ Cat.objects)\n      { pt := s.pt\n        Ï€ :=\n          { app := fun j => (s.Ï€.app j).obj\n            naturality := fun _ _ f => objects.congr_map (s.Ï€.naturality f) } }\n  map f := by\n    fapply Types.Limit.mk.{v, v}\n    Â· intro j\n      refine eqToHom ?_ â‰« (s.Ï€.app j).map f â‰« eqToHom ?_ <;> simp\n    Â· intro j j' h\n      dsimp\n      simp only [Category.assoc, Functor.map_comp, eqToHom_map, eqToHom_trans,\n        eqToHom_trans_assoc, â† Functor.comp_map]\n      have := (s.Ï€.naturality h).symm\n      dsimp at this\n      rw [Category.id_comp] at this\n      erw [Functor.congr_hom this f]\n      simp\n\n"}
{"name":"CategoryTheory.Cat.HasLimits.limitConeLift_map","module":"Mathlib.CategoryTheory.Category.Cat.Limit","initialProofState":"J : Type v\ninstâœ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J CategoryTheory.Cat\ns : CategoryTheory.Limits.Cone F\nXâœ Yâœ : â†‘s.pt\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq ((CategoryTheory.Cat.HasLimits.limitConeLift F s).map f) (CategoryTheory.Limits.Types.Limit.mk (CategoryTheory.Cat.HasLimits.homDiagram (CategoryTheory.Limits.limit.lift (F.comp CategoryTheory.Cat.objects) { pt := â†‘s.pt, Ï€ := { app := fun j => (s.Ï€.app j).obj, naturality := â‹¯ } } Xâœ) (CategoryTheory.Limits.limit.lift (F.comp CategoryTheory.Cat.objects) { pt := â†‘s.pt, Ï€ := { app := fun j => (s.Ï€.app j).obj, naturality := â‹¯ } } Yâœ)) (fun j => CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom â‹¯) (CategoryTheory.CategoryStruct.comp ((s.Ï€.app j).map f) (CategoryTheory.eqToHom â‹¯))) â‹¯)","decl":"/-- Auxiliary definition: the universal morphism to the proposed limit cone. -/\n@[simps]\ndef limitConeLift (F : J â¥¤ Cat.{v, v}) (s : Cone F) : s.pt âŸ¶ limitConeX F where\n  obj :=\n    limit.lift (F â‹™ Cat.objects)\n      { pt := s.pt\n        Ï€ :=\n          { app := fun j => (s.Ï€.app j).obj\n            naturality := fun _ _ f => objects.congr_map (s.Ï€.naturality f) } }\n  map f := by\n    fapply Types.Limit.mk.{v, v}\n    Â· intro j\n      refine eqToHom ?_ â‰« (s.Ï€.app j).map f â‰« eqToHom ?_ <;> simp\n    Â· intro j j' h\n      dsimp\n      simp only [Category.assoc, Functor.map_comp, eqToHom_map, eqToHom_trans,\n        eqToHom_trans_assoc, â† Functor.comp_map]\n      have := (s.Ï€.naturality h).symm\n      dsimp at this\n      rw [Category.id_comp] at this\n      erw [Functor.congr_hom this f]\n      simp\n\n"}
{"name":"CategoryTheory.Cat.HasLimits.limit_Ï€_homDiagram_eqToHom","module":"Mathlib.CategoryTheory.Category.Cat.Limit","initialProofState":"J : Type v\ninstâœ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J CategoryTheory.Cat\nX Y : CategoryTheory.Limits.limit (F.comp CategoryTheory.Cat.objects)\nj : J\nh : Eq X Y\nâŠ¢ Eq (CategoryTheory.Limits.limit.Ï€ (CategoryTheory.Cat.HasLimits.homDiagram X Y) j (CategoryTheory.eqToHom h)) (CategoryTheory.eqToHom â‹¯)","decl":"@[simp]\ntheorem limit_Ï€_homDiagram_eqToHom {F : J â¥¤ Cat.{v, v}} (X Y : limit (F â‹™ Cat.objects.{v, v}))\n    (j : J) (h : X = Y) :\n    limit.Ï€ (homDiagram X Y) j (eqToHom h) =\n      eqToHom (congr_arg (limit.Ï€ (F â‹™ Cat.objects.{v, v}) j) h) := by\n  subst h\n  simp\n\n"}
{"name":"CategoryTheory.Cat.instHasLimits","module":"Mathlib.CategoryTheory.Category.Cat.Limit","initialProofState":"âŠ¢ CategoryTheory.Limits.HasLimits CategoryTheory.Cat","decl":"/-- The category of small categories has all small limits. -/\ninstance : HasLimits Cat.{v, v} where\n  has_limits_of_shape _ :=\n    { has_limit := fun F => âŸ¨âŸ¨âŸ¨HasLimits.limitCone F, HasLimits.limitConeIsLimit FâŸ©âŸ©âŸ© }\n\n"}
{"name":"CategoryTheory.Cat.instPreservesLimitsObjects","module":"Mathlib.CategoryTheory.Category.Cat.Limit","initialProofState":"âŠ¢ CategoryTheory.Limits.PreservesLimits CategoryTheory.Cat.objects","decl":"instance : PreservesLimits Cat.objects.{v, v} where\n  preservesLimitsOfShape :=\n    { preservesLimit := fun {F} =>\n        preservesLimit_of_preserves_limit_cone (HasLimits.limitConeIsLimit F)\n          (Limits.IsLimit.ofIsoLimit (limit.isLimit (F â‹™ Cat.objects))\n            (Cones.ext (by rfl) (by aesop_cat))) }\n\n"}
