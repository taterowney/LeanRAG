{"name":"CategoryTheory.pi.hasLimit_of_hasLimit_comp_eval","module":"Mathlib.CategoryTheory.Limits.Pi","initialProofState":"I : Type v₁\nC : I → Type u₁\ninst✝² : (i : I) → CategoryTheory.Category.{v₁, u₁} (C i)\nJ : Type v₁\ninst✝¹ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J ((i : I) → C i)\ninst✝ : ∀ (i : I), CategoryTheory.Limits.HasLimit (F.comp (CategoryTheory.Pi.eval C i))\n⊢ CategoryTheory.Limits.HasLimit F","decl":"/-- If we have a functor `F : J ⥤ Π i, C i` into a category of indexed families,\nand we have limits for each of the `F ⋙ Pi.eval C i`,\nthen `F` has a limit.\n-/\ntheorem hasLimit_of_hasLimit_comp_eval : HasLimit F :=\n  HasLimit.mk\n    { cone := coneOfConeCompEval fun _ => limit.cone _\n      isLimit := coneOfConeEvalIsLimit fun _ => limit.isLimit _ }\n\n"}
{"name":"CategoryTheory.pi.hasColimit_of_hasColimit_comp_eval","module":"Mathlib.CategoryTheory.Limits.Pi","initialProofState":"I : Type v₁\nC : I → Type u₁\ninst✝² : (i : I) → CategoryTheory.Category.{v₁, u₁} (C i)\nJ : Type v₁\ninst✝¹ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J ((i : I) → C i)\ninst✝ : ∀ (i : I), CategoryTheory.Limits.HasColimit (F.comp (CategoryTheory.Pi.eval C i))\n⊢ CategoryTheory.Limits.HasColimit F","decl":"/-- If we have a functor `F : J ⥤ Π i, C i` into a category of indexed families,\nand colimits exist for each of the `F ⋙ Pi.eval C i`,\nthere is a colimit for `F`.\n-/\ntheorem hasColimit_of_hasColimit_comp_eval : HasColimit F :=\n  HasColimit.mk\n    { cocone := coconeOfCoconeCompEval fun _ => colimit.cocone _\n      isColimit := coconeOfCoconeEvalIsColimit fun _ => colimit.isColimit _ }\n\n"}
