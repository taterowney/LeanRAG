{"name":"IndepMatroid.indep_subset","module":"Mathlib.Data.Matroid.IndepAxioms","initialProofState":"α : Type u_2\nself : IndepMatroid α\nI J : Set α\na✝¹ : self.Indep J\na✝ : HasSubset.Subset I J\n⊢ self.Indep I","decl":"/-- A matroid as defined by the independence axioms. This is the same thing as a `Matroid`,\n  and so does not need its own API; it exists to make it easier to construct a matroid from its\n  independent sets. The constructed `IndepMatroid` can then be converted into a matroid\n  with `IndepMatroid.matroid`. -/\nstructure IndepMatroid (α : Type*) where\n  /-- The ground set -/\n  (E : Set α)\n  /-- The independence predicate -/\n  (Indep : Set α → Prop)\n  (indep_empty : Indep ∅)\n  (indep_subset : ∀ ⦃I J⦄, Indep J → I ⊆ J → Indep I)\n  (indep_aug : ∀ ⦃I B⦄, Indep I → ¬ Maximal Indep I →\n    Maximal Indep B → ∃ x ∈ B \\ I, Indep (insert x I))\n  (indep_maximal : ∀ X, X ⊆ E → ExistsMaximalSubsetProperty Indep X)\n  (subset_ground : ∀ I, Indep I → I ⊆ E)\n\n"}
{"name":"IndepMatroid.mk.sizeOf_spec","module":"Mathlib.Data.Matroid.IndepAxioms","initialProofState":"α : Type u_2\ninst✝ : SizeOf α\nE : Set α\nIndep : Set α → Prop\nindep_empty : Indep EmptyCollection.emptyCollection\nindep_subset : ∀ ⦃I J : Set α⦄, Indep J → HasSubset.Subset I J → Indep I\nindep_aug : ∀ ⦃I B : Set α⦄, Indep I → Not (Maximal Indep I) → Maximal Indep B → Exists fun x => And (Membership.mem (SDiff.sdiff B I) x) (Indep (Insert.insert x I))\nindep_maximal : ∀ (X : Set α), HasSubset.Subset X E → Matroid.ExistsMaximalSubsetProperty Indep X\nsubset_ground : ∀ (I : Set α), Indep I → HasSubset.Subset I E\n⊢ Eq (SizeOf.sizeOf { E := E, Indep := Indep, indep_empty := indep_empty, indep_subset := indep_subset, indep_aug := indep_aug, indep_maximal := indep_maximal, subset_ground := subset_ground }) (HAdd.hAdd 1 (SizeOf.sizeOf indep_empty))","decl":"/-- A matroid as defined by the independence axioms. This is the same thing as a `Matroid`,\n  and so does not need its own API; it exists to make it easier to construct a matroid from its\n  independent sets. The constructed `IndepMatroid` can then be converted into a matroid\n  with `IndepMatroid.matroid`. -/\nstructure IndepMatroid (α : Type*) where\n  /-- The ground set -/\n  (E : Set α)\n  /-- The independence predicate -/\n  (Indep : Set α → Prop)\n  (indep_empty : Indep ∅)\n  (indep_subset : ∀ ⦃I J⦄, Indep J → I ⊆ J → Indep I)\n  (indep_aug : ∀ ⦃I B⦄, Indep I → ¬ Maximal Indep I →\n    Maximal Indep B → ∃ x ∈ B \\ I, Indep (insert x I))\n  (indep_maximal : ∀ X, X ⊆ E → ExistsMaximalSubsetProperty Indep X)\n  (subset_ground : ∀ I, Indep I → I ⊆ E)\n\n"}
{"name":"IndepMatroid.indep_empty","module":"Mathlib.Data.Matroid.IndepAxioms","initialProofState":"α : Type u_2\nself : IndepMatroid α\n⊢ self.Indep EmptyCollection.emptyCollection","decl":"/-- A matroid as defined by the independence axioms. This is the same thing as a `Matroid`,\n  and so does not need its own API; it exists to make it easier to construct a matroid from its\n  independent sets. The constructed `IndepMatroid` can then be converted into a matroid\n  with `IndepMatroid.matroid`. -/\nstructure IndepMatroid (α : Type*) where\n  /-- The ground set -/\n  (E : Set α)\n  /-- The independence predicate -/\n  (Indep : Set α → Prop)\n  (indep_empty : Indep ∅)\n  (indep_subset : ∀ ⦃I J⦄, Indep J → I ⊆ J → Indep I)\n  (indep_aug : ∀ ⦃I B⦄, Indep I → ¬ Maximal Indep I →\n    Maximal Indep B → ∃ x ∈ B \\ I, Indep (insert x I))\n  (indep_maximal : ∀ X, X ⊆ E → ExistsMaximalSubsetProperty Indep X)\n  (subset_ground : ∀ I, Indep I → I ⊆ E)\n\n"}
{"name":"IndepMatroid.mk.inj","module":"Mathlib.Data.Matroid.IndepAxioms","initialProofState":"α : Type u_2\nE✝ : Set α\nIndep✝ : Set α → Prop\nindep_empty✝ : Indep✝ EmptyCollection.emptyCollection\nindep_subset✝ : ∀ ⦃I J : Set α⦄, Indep✝ J → HasSubset.Subset I J → Indep✝ I\nindep_aug✝ : ∀ ⦃I B : Set α⦄, Indep✝ I → Not (Maximal Indep✝ I) → Maximal Indep✝ B → Exists fun x => And (Membership.mem (SDiff.sdiff B I) x) (Indep✝ (Insert.insert x I))\nindep_maximal✝ : ∀ (X : Set α), HasSubset.Subset X E✝ → Matroid.ExistsMaximalSubsetProperty Indep✝ X\nsubset_ground✝ : ∀ (I : Set α), Indep✝ I → HasSubset.Subset I E✝\nE : Set α\nIndep : Set α → Prop\nindep_empty : Indep EmptyCollection.emptyCollection\nindep_subset : ∀ ⦃I J : Set α⦄, Indep J → HasSubset.Subset I J → Indep I\nindep_aug : ∀ ⦃I B : Set α⦄, Indep I → Not (Maximal Indep I) → Maximal Indep B → Exists fun x => And (Membership.mem (SDiff.sdiff B I) x) (Indep (Insert.insert x I))\nindep_maximal : ∀ (X : Set α), HasSubset.Subset X E → Matroid.ExistsMaximalSubsetProperty Indep X\nsubset_ground : ∀ (I : Set α), Indep I → HasSubset.Subset I E\nx✝ : Eq { E := E✝, Indep := Indep✝, indep_empty := indep_empty✝, indep_subset := indep_subset✝, indep_aug := indep_aug✝, indep_maximal := indep_maximal✝, subset_ground := subset_ground✝ } { E := E, Indep := Indep, indep_empty := indep_empty, indep_subset := indep_subset, indep_aug := indep_aug, indep_maximal := indep_maximal, subset_ground := subset_ground }\n⊢ And (Eq E✝ E) (Eq Indep✝ Indep)","decl":"/-- A matroid as defined by the independence axioms. This is the same thing as a `Matroid`,\n  and so does not need its own API; it exists to make it easier to construct a matroid from its\n  independent sets. The constructed `IndepMatroid` can then be converted into a matroid\n  with `IndepMatroid.matroid`. -/\nstructure IndepMatroid (α : Type*) where\n  /-- The ground set -/\n  (E : Set α)\n  /-- The independence predicate -/\n  (Indep : Set α → Prop)\n  (indep_empty : Indep ∅)\n  (indep_subset : ∀ ⦃I J⦄, Indep J → I ⊆ J → Indep I)\n  (indep_aug : ∀ ⦃I B⦄, Indep I → ¬ Maximal Indep I →\n    Maximal Indep B → ∃ x ∈ B \\ I, Indep (insert x I))\n  (indep_maximal : ∀ X, X ⊆ E → ExistsMaximalSubsetProperty Indep X)\n  (subset_ground : ∀ I, Indep I → I ⊆ E)\n\n"}
{"name":"IndepMatroid.subset_ground","module":"Mathlib.Data.Matroid.IndepAxioms","initialProofState":"α : Type u_2\nself : IndepMatroid α\nI : Set α\na✝ : self.Indep I\n⊢ HasSubset.Subset I self.E","decl":"/-- A matroid as defined by the independence axioms. This is the same thing as a `Matroid`,\n  and so does not need its own API; it exists to make it easier to construct a matroid from its\n  independent sets. The constructed `IndepMatroid` can then be converted into a matroid\n  with `IndepMatroid.matroid`. -/\nstructure IndepMatroid (α : Type*) where\n  /-- The ground set -/\n  (E : Set α)\n  /-- The independence predicate -/\n  (Indep : Set α → Prop)\n  (indep_empty : Indep ∅)\n  (indep_subset : ∀ ⦃I J⦄, Indep J → I ⊆ J → Indep I)\n  (indep_aug : ∀ ⦃I B⦄, Indep I → ¬ Maximal Indep I →\n    Maximal Indep B → ∃ x ∈ B \\ I, Indep (insert x I))\n  (indep_maximal : ∀ X, X ⊆ E → ExistsMaximalSubsetProperty Indep X)\n  (subset_ground : ∀ I, Indep I → I ⊆ E)\n\n"}
{"name":"IndepMatroid.indep_maximal","module":"Mathlib.Data.Matroid.IndepAxioms","initialProofState":"α : Type u_2\nself : IndepMatroid α\nX : Set α\na✝ : HasSubset.Subset X self.E\n⊢ Matroid.ExistsMaximalSubsetProperty self.Indep X","decl":"/-- A matroid as defined by the independence axioms. This is the same thing as a `Matroid`,\n  and so does not need its own API; it exists to make it easier to construct a matroid from its\n  independent sets. The constructed `IndepMatroid` can then be converted into a matroid\n  with `IndepMatroid.matroid`. -/\nstructure IndepMatroid (α : Type*) where\n  /-- The ground set -/\n  (E : Set α)\n  /-- The independence predicate -/\n  (Indep : Set α → Prop)\n  (indep_empty : Indep ∅)\n  (indep_subset : ∀ ⦃I J⦄, Indep J → I ⊆ J → Indep I)\n  (indep_aug : ∀ ⦃I B⦄, Indep I → ¬ Maximal Indep I →\n    Maximal Indep B → ∃ x ∈ B \\ I, Indep (insert x I))\n  (indep_maximal : ∀ X, X ⊆ E → ExistsMaximalSubsetProperty Indep X)\n  (subset_ground : ∀ I, Indep I → I ⊆ E)\n\n"}
{"name":"IndepMatroid.mk.injEq","module":"Mathlib.Data.Matroid.IndepAxioms","initialProofState":"α : Type u_2\nE✝ : Set α\nIndep✝ : Set α → Prop\nindep_empty✝ : Indep✝ EmptyCollection.emptyCollection\nindep_subset✝ : ∀ ⦃I J : Set α⦄, Indep✝ J → HasSubset.Subset I J → Indep✝ I\nindep_aug✝ : ∀ ⦃I B : Set α⦄, Indep✝ I → Not (Maximal Indep✝ I) → Maximal Indep✝ B → Exists fun x => And (Membership.mem (SDiff.sdiff B I) x) (Indep✝ (Insert.insert x I))\nindep_maximal✝ : ∀ (X : Set α), HasSubset.Subset X E✝ → Matroid.ExistsMaximalSubsetProperty Indep✝ X\nsubset_ground✝ : ∀ (I : Set α), Indep✝ I → HasSubset.Subset I E✝\nE : Set α\nIndep : Set α → Prop\nindep_empty : Indep EmptyCollection.emptyCollection\nindep_subset : ∀ ⦃I J : Set α⦄, Indep J → HasSubset.Subset I J → Indep I\nindep_aug : ∀ ⦃I B : Set α⦄, Indep I → Not (Maximal Indep I) → Maximal Indep B → Exists fun x => And (Membership.mem (SDiff.sdiff B I) x) (Indep (Insert.insert x I))\nindep_maximal : ∀ (X : Set α), HasSubset.Subset X E → Matroid.ExistsMaximalSubsetProperty Indep X\nsubset_ground : ∀ (I : Set α), Indep I → HasSubset.Subset I E\n⊢ Eq (Eq { E := E✝, Indep := Indep✝, indep_empty := indep_empty✝, indep_subset := indep_subset✝, indep_aug := indep_aug✝, indep_maximal := indep_maximal✝, subset_ground := subset_ground✝ } { E := E, Indep := Indep, indep_empty := indep_empty, indep_subset := indep_subset, indep_aug := indep_aug, indep_maximal := indep_maximal, subset_ground := subset_ground }) (And (Eq E✝ E) (Eq Indep✝ Indep))","decl":"/-- A matroid as defined by the independence axioms. This is the same thing as a `Matroid`,\n  and so does not need its own API; it exists to make it easier to construct a matroid from its\n  independent sets. The constructed `IndepMatroid` can then be converted into a matroid\n  with `IndepMatroid.matroid`. -/\nstructure IndepMatroid (α : Type*) where\n  /-- The ground set -/\n  (E : Set α)\n  /-- The independence predicate -/\n  (Indep : Set α → Prop)\n  (indep_empty : Indep ∅)\n  (indep_subset : ∀ ⦃I J⦄, Indep J → I ⊆ J → Indep I)\n  (indep_aug : ∀ ⦃I B⦄, Indep I → ¬ Maximal Indep I →\n    Maximal Indep B → ∃ x ∈ B \\ I, Indep (insert x I))\n  (indep_maximal : ∀ X, X ⊆ E → ExistsMaximalSubsetProperty Indep X)\n  (subset_ground : ∀ I, Indep I → I ⊆ E)\n\n"}
{"name":"IndepMatroid.indep_aug","module":"Mathlib.Data.Matroid.IndepAxioms","initialProofState":"α : Type u_2\nself : IndepMatroid α\nI B : Set α\na✝² : self.Indep I\na✝¹ : Not (Maximal self.Indep I)\na✝ : Maximal self.Indep B\n⊢ Exists fun x => And (Membership.mem (SDiff.sdiff B I) x) (self.Indep (Insert.insert x I))","decl":"/-- A matroid as defined by the independence axioms. This is the same thing as a `Matroid`,\n  and so does not need its own API; it exists to make it easier to construct a matroid from its\n  independent sets. The constructed `IndepMatroid` can then be converted into a matroid\n  with `IndepMatroid.matroid`. -/\nstructure IndepMatroid (α : Type*) where\n  /-- The ground set -/\n  (E : Set α)\n  /-- The independence predicate -/\n  (Indep : Set α → Prop)\n  (indep_empty : Indep ∅)\n  (indep_subset : ∀ ⦃I J⦄, Indep J → I ⊆ J → Indep I)\n  (indep_aug : ∀ ⦃I B⦄, Indep I → ¬ Maximal Indep I →\n    Maximal Indep B → ∃ x ∈ B \\ I, Indep (insert x I))\n  (indep_maximal : ∀ X, X ⊆ E → ExistsMaximalSubsetProperty Indep X)\n  (subset_ground : ∀ I, Indep I → I ⊆ E)\n\n"}
{"name":"IndepMatroid.matroid_Base","module":"Mathlib.Data.Matroid.IndepAxioms","initialProofState":"α : Type u_1\nM : IndepMatroid α\nx : Set α\n⊢ Eq (M.matroid.Base x) (Maximal M.Indep x)","decl":"/-- An `M : IndepMatroid α` gives a `Matroid α` whose bases are the maximal `M`-independent sets. -/\n@[simps] protected def matroid (M : IndepMatroid α) : Matroid α where\n  E := M.E\n  Base := Maximal M.Indep\n  Indep := M.Indep\n  indep_iff' := by\n    refine fun I ↦ ⟨fun h ↦ ?_, fun ⟨B, ⟨h, _⟩, hIB'⟩ ↦ M.indep_subset h hIB'⟩\n    obtain ⟨J, hIJ, hmax⟩ := M.indep_maximal M.E rfl.subset I h (M.subset_ground I h)\n    rw [maximal_and_iff_right_of_imp M.subset_ground] at hmax\n    exact ⟨J, hmax.1, hIJ⟩\n  exists_base := by\n    obtain ⟨B, -, hB⟩ := M.indep_maximal M.E rfl.subset ∅ M.indep_empty <| empty_subset _\n    rw [maximal_and_iff_right_of_imp M.subset_ground] at hB\n    exact ⟨B, hB.1⟩\n  base_exchange B B' hB hB' e he := by\n    have hnotmax : ¬ Maximal M.Indep (B \\ {e}) :=\n      fun h ↦ h.not_prop_of_ssuperset (diff_singleton_sSubset.2 he.1) hB.prop\n    obtain ⟨f, hf, hfB⟩ := M.indep_aug (M.indep_subset hB.prop diff_subset) hnotmax hB'\n    replace hf := show f ∈ B' \\ B by simpa [show f ≠ e by rintro rfl; exact he.2 hf.1] using hf\n    refine ⟨f, hf, by_contra fun hnot ↦ ?_⟩\n    obtain ⟨x, hxB, hind⟩ := M.indep_aug hfB hnot hB\n    obtain ⟨-, rfl⟩ : _ ∧ x = e := by simpa [hxB.1] using hxB\n    refine hB.not_prop_of_ssuperset ?_ hind\n    rw [insert_comm, insert_diff_singleton, insert_eq_of_mem he.1]\n    exact ssubset_insert hf.2\n  maximality := M.indep_maximal\n  subset_ground B hB := M.subset_ground B hB.1\n\n"}
{"name":"IndepMatroid.matroid_Indep","module":"Mathlib.Data.Matroid.IndepAxioms","initialProofState":"α : Type u_1\nM : IndepMatroid α\na✝ : Set α\n⊢ Eq (M.matroid.Indep a✝) (M.Indep a✝)","decl":"/-- An `M : IndepMatroid α` gives a `Matroid α` whose bases are the maximal `M`-independent sets. -/\n@[simps] protected def matroid (M : IndepMatroid α) : Matroid α where\n  E := M.E\n  Base := Maximal M.Indep\n  Indep := M.Indep\n  indep_iff' := by\n    refine fun I ↦ ⟨fun h ↦ ?_, fun ⟨B, ⟨h, _⟩, hIB'⟩ ↦ M.indep_subset h hIB'⟩\n    obtain ⟨J, hIJ, hmax⟩ := M.indep_maximal M.E rfl.subset I h (M.subset_ground I h)\n    rw [maximal_and_iff_right_of_imp M.subset_ground] at hmax\n    exact ⟨J, hmax.1, hIJ⟩\n  exists_base := by\n    obtain ⟨B, -, hB⟩ := M.indep_maximal M.E rfl.subset ∅ M.indep_empty <| empty_subset _\n    rw [maximal_and_iff_right_of_imp M.subset_ground] at hB\n    exact ⟨B, hB.1⟩\n  base_exchange B B' hB hB' e he := by\n    have hnotmax : ¬ Maximal M.Indep (B \\ {e}) :=\n      fun h ↦ h.not_prop_of_ssuperset (diff_singleton_sSubset.2 he.1) hB.prop\n    obtain ⟨f, hf, hfB⟩ := M.indep_aug (M.indep_subset hB.prop diff_subset) hnotmax hB'\n    replace hf := show f ∈ B' \\ B by simpa [show f ≠ e by rintro rfl; exact he.2 hf.1] using hf\n    refine ⟨f, hf, by_contra fun hnot ↦ ?_⟩\n    obtain ⟨x, hxB, hind⟩ := M.indep_aug hfB hnot hB\n    obtain ⟨-, rfl⟩ : _ ∧ x = e := by simpa [hxB.1] using hxB\n    refine hB.not_prop_of_ssuperset ?_ hind\n    rw [insert_comm, insert_diff_singleton, insert_eq_of_mem he.1]\n    exact ssubset_insert hf.2\n  maximality := M.indep_maximal\n  subset_ground B hB := M.subset_ground B hB.1\n\n"}
{"name":"IndepMatroid.matroid_E","module":"Mathlib.Data.Matroid.IndepAxioms","initialProofState":"α : Type u_1\nM : IndepMatroid α\n⊢ Eq M.matroid.E M.E","decl":"/-- An `M : IndepMatroid α` gives a `Matroid α` whose bases are the maximal `M`-independent sets. -/\n@[simps] protected def matroid (M : IndepMatroid α) : Matroid α where\n  E := M.E\n  Base := Maximal M.Indep\n  Indep := M.Indep\n  indep_iff' := by\n    refine fun I ↦ ⟨fun h ↦ ?_, fun ⟨B, ⟨h, _⟩, hIB'⟩ ↦ M.indep_subset h hIB'⟩\n    obtain ⟨J, hIJ, hmax⟩ := M.indep_maximal M.E rfl.subset I h (M.subset_ground I h)\n    rw [maximal_and_iff_right_of_imp M.subset_ground] at hmax\n    exact ⟨J, hmax.1, hIJ⟩\n  exists_base := by\n    obtain ⟨B, -, hB⟩ := M.indep_maximal M.E rfl.subset ∅ M.indep_empty <| empty_subset _\n    rw [maximal_and_iff_right_of_imp M.subset_ground] at hB\n    exact ⟨B, hB.1⟩\n  base_exchange B B' hB hB' e he := by\n    have hnotmax : ¬ Maximal M.Indep (B \\ {e}) :=\n      fun h ↦ h.not_prop_of_ssuperset (diff_singleton_sSubset.2 he.1) hB.prop\n    obtain ⟨f, hf, hfB⟩ := M.indep_aug (M.indep_subset hB.prop diff_subset) hnotmax hB'\n    replace hf := show f ∈ B' \\ B by simpa [show f ≠ e by rintro rfl; exact he.2 hf.1] using hf\n    refine ⟨f, hf, by_contra fun hnot ↦ ?_⟩\n    obtain ⟨x, hxB, hind⟩ := M.indep_aug hfB hnot hB\n    obtain ⟨-, rfl⟩ : _ ∧ x = e := by simpa [hxB.1] using hxB\n    refine hB.not_prop_of_ssuperset ?_ hind\n    rw [insert_comm, insert_diff_singleton, insert_eq_of_mem he.1]\n    exact ssubset_insert hf.2\n  maximality := M.indep_maximal\n  subset_ground B hB := M.subset_ground B hB.1\n\n"}
{"name":"IndepMatroid.matroid_indep_iff","module":"Mathlib.Data.Matroid.IndepAxioms","initialProofState":"α : Type u_1\nM : IndepMatroid α\nI : Set α\n⊢ Iff (M.matroid.Indep I) (M.Indep I)","decl":"@[simp] theorem matroid_indep_iff {M : IndepMatroid α} {I : Set α} :\n    M.matroid.Indep I ↔ M.Indep I := Iff.rfl\n\n"}
{"name":"IndepMatroid.ofFinitary_E","module":"Mathlib.Data.Matroid.IndepAxioms","initialProofState":"α : Type u_1\nE : Set α\nIndep : Set α → Prop\nindep_empty : Indep EmptyCollection.emptyCollection\nindep_subset : ∀ ⦃I J : Set α⦄, Indep J → HasSubset.Subset I J → Indep I\nindep_aug : ∀ ⦃I B : Set α⦄, Indep I → Not (Maximal Indep I) → Maximal Indep B → Exists fun x => And (Membership.mem (SDiff.sdiff B I) x) (Indep (Insert.insert x I))\nindep_compact : ∀ (I : Set α), (∀ (J : Set α), HasSubset.Subset J I → J.Finite → Indep J) → Indep I\nsubset_ground : ∀ (I : Set α), Indep I → HasSubset.Subset I E\n⊢ Eq (IndepMatroid.ofFinitary E Indep indep_empty indep_subset indep_aug indep_compact subset_ground).E E","decl":"/-- If `Indep` has the 'compactness' property that each set `I` satisfies `Indep I` if and only if\n`Indep J` for every finite subset `J` of `I`,\nthen an `IndepMatroid` can be constructed without proving the maximality axiom.\nThis needs choice, since it can be used to prove that every vector space has a basis. -/\n@[simps E] protected def ofFinitary (E : Set α) (Indep : Set α → Prop)\n    (indep_empty : Indep ∅)\n    (indep_subset : ∀ ⦃I J⦄, Indep J → I ⊆ J → Indep I)\n    (indep_aug : ∀ ⦃I B⦄, Indep I → ¬ Maximal Indep I → Maximal Indep B →\n      ∃ x ∈ B \\ I, Indep (insert x I))\n    (indep_compact : ∀ I, (∀ J, J ⊆ I → J.Finite → Indep J) → Indep I)\n    (subset_ground : ∀ I, Indep I → I ⊆ E) : IndepMatroid α where\n  E := E\n  Indep := Indep\n  indep_empty := indep_empty\n  indep_subset := indep_subset\n  indep_aug := indep_aug\n  indep_maximal := by\n    refine fun X _ I hI hIX ↦ zorn_subset_nonempty {Y | Indep Y ∧ Y ⊆ X} ?_ I ⟨hI, hIX⟩\n    refine fun Is hIs hchain _ ↦\n      ⟨⋃₀ Is, ⟨?_, sUnion_subset fun Y hY ↦ (hIs hY).2⟩, fun _ ↦ subset_sUnion_of_mem⟩\n    refine indep_compact _ fun J hJ hJfin ↦ ?_\n    have hchoose : ∀ e, e ∈ J → ∃ I, I ∈ Is ∧ (e : α) ∈ I := fun _ he ↦ mem_sUnion.1 <| hJ he\n    choose! f hf using hchoose\n    refine J.eq_empty_or_nonempty.elim (fun hJ ↦ hJ ▸ indep_empty) (fun hne ↦ ?_)\n    obtain ⟨x, hxJ, hxmax⟩ := Finite.exists_maximal_wrt f _ hJfin hne\n    refine indep_subset (hIs (hf x hxJ).1).1 fun y hyJ ↦ ?_\n    obtain (hle | hle) := hchain.total (hf _ hxJ).1 (hf _ hyJ).1\n    · rw [hxmax _ hyJ hle]; exact (hf _ hyJ).2\n    exact hle (hf _ hyJ).2\n  subset_ground := subset_ground\n\n"}
{"name":"IndepMatroid.ofFinitary_indep","module":"Mathlib.Data.Matroid.IndepAxioms","initialProofState":"α : Type u_1\nE : Set α\nIndep : Set α → Prop\nindep_empty : Indep EmptyCollection.emptyCollection\nindep_subset : ∀ ⦃I J : Set α⦄, Indep J → HasSubset.Subset I J → Indep I\nindep_aug : ∀ ⦃I B : Set α⦄, Indep I → Not (Maximal Indep I) → Maximal Indep B → Exists fun x => And (Membership.mem (SDiff.sdiff B I) x) (Indep (Insert.insert x I))\nindep_compact : ∀ (I : Set α), (∀ (J : Set α), HasSubset.Subset J I → J.Finite → Indep J) → Indep I\nsubset_ground : ∀ (I : Set α), Indep I → HasSubset.Subset I E\n⊢ Eq (IndepMatroid.ofFinitary E Indep indep_empty indep_subset indep_aug indep_compact subset_ground).Indep Indep","decl":"@[simp] theorem ofFinitary_indep (E : Set α) (Indep : Set α → Prop)\n    indep_empty indep_subset indep_aug indep_compact subset_ground :\n    (IndepMatroid.ofFinitary\n      E Indep indep_empty indep_subset indep_aug indep_compact subset_ground).Indep = Indep := rfl\n\n"}
{"name":"IndepMatroid.ofFinitary_finitary","module":"Mathlib.Data.Matroid.IndepAxioms","initialProofState":"α : Type u_1\nE : Set α\nIndep : Set α → Prop\nindep_empty : Indep EmptyCollection.emptyCollection\nindep_subset : ∀ ⦃I J : Set α⦄, Indep J → HasSubset.Subset I J → Indep I\nindep_aug : ∀ ⦃I B : Set α⦄, Indep I → Not (Maximal Indep I) → Maximal Indep B → Exists fun x => And (Membership.mem (SDiff.sdiff B I) x) (Indep (Insert.insert x I))\nindep_compact : ∀ (I : Set α), (∀ (J : Set α), HasSubset.Subset J I → J.Finite → Indep J) → Indep I\nsubset_ground : ∀ (I : Set α), Indep I → HasSubset.Subset I E\n⊢ (IndepMatroid.ofFinitary E Indep indep_empty indep_subset indep_aug indep_compact subset_ground).matroid.Finitary","decl":"instance ofFinitary_finitary (E : Set α) (Indep : Set α → Prop)\n    indep_empty indep_subset indep_aug indep_compact subset_ground : Finitary\n    (IndepMatroid.ofFinitary\n      E Indep indep_empty indep_subset indep_aug indep_compact subset_ground).matroid :=\n  ⟨by simpa⟩\n\n"}
{"name":"IndepMatroid.ofFinitaryCardAugment_E","module":"Mathlib.Data.Matroid.IndepAxioms","initialProofState":"α : Type u_1\nE : Set α\nIndep : Set α → Prop\nindep_empty : Indep EmptyCollection.emptyCollection\nindep_subset : ∀ ⦃I J : Set α⦄, Indep J → HasSubset.Subset I J → Indep I\nindep_aug : ∀ ⦃I J : Set α⦄, Indep I → I.Finite → Indep J → J.Finite → LT.lt I.ncard J.ncard → Exists fun e => And (Membership.mem J e) (And (Not (Membership.mem I e)) (Indep (Insert.insert e I)))\nindep_compact : ∀ (I : Set α), (∀ (J : Set α), HasSubset.Subset J I → J.Finite → Indep J) → Indep I\nsubset_ground : ∀ (I : Set α), Indep I → HasSubset.Subset I E\n⊢ Eq (IndepMatroid.ofFinitaryCardAugment E Indep indep_empty indep_subset indep_aug indep_compact subset_ground).E E","decl":"/-- An independence predicate satisfying the finite matroid axioms determines a matroid,\nprovided independence is determined by its behaviour on finite sets. -/\n@[simps! E] protected def ofFinitaryCardAugment (E : Set α) (Indep : Set α → Prop)\n    (indep_empty : Indep ∅)\n    (indep_subset : ∀ ⦃I J⦄, Indep J → I ⊆ J → Indep I)\n    (indep_aug : ∀ ⦃I J⦄, Indep I → I.Finite → Indep J → J.Finite → I.ncard < J.ncard →\n      ∃ e ∈ J, e ∉ I ∧ Indep (insert e I))\n    (indep_compact : ∀ I, (∀ J, J ⊆ I → J.Finite → Indep J) → Indep I)\n    (subset_ground : ∀ I, Indep I → I ⊆ E) : IndepMatroid α :=\n  IndepMatroid.ofFinitary\n    (E := E)\n    (Indep := Indep)\n    (indep_empty := indep_empty)\n    (indep_subset := indep_subset)\n    (indep_compact := indep_compact)\n    (indep_aug := by\n      have htofin : ∀ I e, Indep I → ¬ Indep (insert e I) →\n        ∃ I₀, I₀ ⊆ I ∧ I₀.Finite ∧ ¬ Indep (insert e I₀) := by\n        by_contra h; push_neg at h\n        obtain ⟨I, e, -, hIe, h⟩ := h\n        refine hIe <| indep_compact _ fun J hJss hJfin ↦ ?_\n        exact indep_subset (h (J \\ {e}) (by rwa [diff_subset_iff]) hJfin.diff) (by simp)\n\n      intro I B hI hImax hBmax\n      obtain ⟨e, heI, hins⟩ := exists_insert_of_not_maximal indep_subset hI hImax\n      by_cases heB : e ∈ B\n      · exact ⟨e, ⟨heB, heI⟩, hins⟩\n      by_contra hcon; push_neg at hcon\n\n      have heBdep := hBmax.not_prop_of_ssuperset (ssubset_insert heB)\n\n      -- There is a finite subset `B₀` of `B` so that `B₀ + e` is dependent\n      obtain ⟨B₀, hB₀B, hB₀fin, hB₀e⟩ := htofin B e hBmax.1 heBdep\n      have hB₀ := indep_subset hBmax.1 hB₀B\n\n      -- `I` has a finite subset `I₀` that doesn't extend into `B₀`\n      have hexI₀ : ∃ I₀, I₀ ⊆ I ∧ I₀.Finite ∧ ∀ x, x ∈ B₀ \\ I₀ → ¬Indep (insert x I₀) := by\n        have hch : ∀ (b : ↑(B₀ \\ I)), ∃ Ib, Ib ⊆ I ∧ Ib.Finite ∧ ¬Indep (insert (b : α) Ib) := by\n          rintro ⟨b, hb⟩; exact htofin I b hI (hcon b ⟨hB₀B hb.1, hb.2⟩)\n        choose! f hf using hch\n        have : Finite ↑(B₀ \\ I) := hB₀fin.diff.to_subtype\n        refine ⟨iUnion f ∪ (B₀ ∩ I),\n          union_subset (iUnion_subset (fun i ↦ (hf i).1)) inter_subset_right,\n          (finite_iUnion fun i ↦ (hf i).2.1).union (hB₀fin.subset inter_subset_left),\n          fun x ⟨hxB₀, hxn⟩ hi ↦ ?_⟩\n        have hxI : x ∉ I := fun hxI ↦ hxn <| Or.inr ⟨hxB₀, hxI⟩\n        refine (hf ⟨x, ⟨hxB₀, hxI⟩⟩).2.2 (indep_subset hi <| insert_subset_insert ?_)\n        apply subset_union_of_subset_left\n        apply subset_iUnion\n\n      obtain ⟨I₀, hI₀I, hI₀fin, hI₀⟩ := hexI₀\n\n      set E₀ := insert e (I₀ ∪ B₀)\n      have hE₀fin : E₀.Finite := (hI₀fin.union hB₀fin).insert e\n\n      -- Extend `B₀` to a maximal independent subset of `I₀ ∪ B₀ + e`\n      obtain ⟨J, ⟨hB₀J, hJ, hJss⟩, hJmax⟩ := Finite.exists_maximal_wrt (f := id)\n        (s := {J | B₀ ⊆ J ∧ Indep J ∧ J ⊆ E₀})\n        (hE₀fin.finite_subsets.subset (by simp))\n        ⟨B₀, Subset.rfl, hB₀, subset_union_right.trans (subset_insert _ _)⟩\n\n      have heI₀ : e ∉ I₀ := not_mem_subset hI₀I heI\n      have heI₀i : Indep (insert e I₀) := indep_subset hins (insert_subset_insert hI₀I)\n\n      have heJ : e ∉ J := fun heJ ↦ hB₀e (indep_subset hJ <| insert_subset heJ hB₀J)\n\n      have hJfin := hE₀fin.subset hJss\n\n      -- We have `|I₀ + e| ≤ |J|`, since otherwise we could extend the maximal set `J`\n      have hcard : (insert e I₀).ncard ≤ J.ncard := by\n        refine not_lt.1 fun hlt ↦ ?_\n        obtain ⟨f, hfI, hfJ, hfi⟩ := indep_aug hJ hJfin heI₀i (hI₀fin.insert e) hlt\n        have hfE₀ : f ∈ E₀ := mem_of_mem_of_subset hfI (insert_subset_insert subset_union_left)\n        refine hfJ (insert_eq_self.1 <| Eq.symm (hJmax _\n          ⟨hB₀J.trans <| subset_insert _ _,hfi,insert_subset hfE₀ hJss⟩ (subset_insert _ _)))\n\n      -- But this means `|I₀| < |J|`, and extending `I₀` into `J` gives a contradiction\n      rw [ncard_insert_of_not_mem heI₀ hI₀fin, ← Nat.lt_iff_add_one_le] at hcard\n\n      obtain ⟨f, hfJ, hfI₀, hfi⟩ := indep_aug (indep_subset hI hI₀I) hI₀fin hJ hJfin hcard\n      exact hI₀ f ⟨Or.elim (hJss hfJ) (fun hfe ↦ (heJ <| hfe ▸ hfJ).elim) (by aesop), hfI₀⟩ hfi )\n  (subset_ground := subset_ground)\n\n"}
{"name":"IndepMatroid.ofFinitaryCardAugment_indep","module":"Mathlib.Data.Matroid.IndepAxioms","initialProofState":"α : Type u_1\nE : Set α\nIndep : Set α → Prop\nindep_empty : Indep EmptyCollection.emptyCollection\nindep_subset : ∀ ⦃I J : Set α⦄, Indep J → HasSubset.Subset I J → Indep I\nindep_aug : ∀ ⦃I J : Set α⦄, Indep I → I.Finite → Indep J → J.Finite → LT.lt I.ncard J.ncard → Exists fun e => And (Membership.mem J e) (And (Not (Membership.mem I e)) (Indep (Insert.insert e I)))\nindep_compact : ∀ (I : Set α), (∀ (J : Set α), HasSubset.Subset J I → J.Finite → Indep J) → Indep I\nsubset_ground : ∀ (I : Set α), Indep I → HasSubset.Subset I E\n⊢ Eq (IndepMatroid.ofFinitaryCardAugment E Indep indep_empty indep_subset indep_aug indep_compact subset_ground).Indep Indep","decl":"@[simp] theorem ofFinitaryCardAugment_indep (E : Set α) (Indep : Set α → Prop)\n    indep_empty indep_subset indep_aug indep_compact subset_ground :\n    (IndepMatroid.ofFinitaryCardAugment\n      E Indep indep_empty indep_subset indep_aug indep_compact subset_ground).Indep = Indep := rfl\n\n"}
{"name":"IndepMatroid.ofFinitaryCardAugment_finitary","module":"Mathlib.Data.Matroid.IndepAxioms","initialProofState":"α : Type u_1\nE : Set α\nIndep : Set α → Prop\nindep_empty : Indep EmptyCollection.emptyCollection\nindep_subset : ∀ ⦃I J : Set α⦄, Indep J → HasSubset.Subset I J → Indep I\nindep_aug : ∀ ⦃I J : Set α⦄, Indep I → I.Finite → Indep J → J.Finite → LT.lt I.ncard J.ncard → Exists fun e => And (Membership.mem J e) (And (Not (Membership.mem I e)) (Indep (Insert.insert e I)))\nindep_compact : ∀ (I : Set α), (∀ (J : Set α), HasSubset.Subset J I → J.Finite → Indep J) → Indep I\nsubset_ground : ∀ (I : Set α), Indep I → HasSubset.Subset I E\n⊢ (IndepMatroid.ofFinitaryCardAugment E Indep indep_empty indep_subset indep_aug indep_compact subset_ground).matroid.Finitary","decl":"instance ofFinitaryCardAugment_finitary (E : Set α) (Indep : Set α → Prop)\n    indep_empty indep_subset indep_aug indep_compact subset_ground : Finitary\n    (IndepMatroid.ofFinitaryCardAugment\n      E Indep indep_empty indep_subset indep_aug indep_compact subset_ground).matroid :=\n  ⟨by simpa⟩\n\n"}
{"name":"Matroid.existsMaximalSubsetProperty_of_bdd","module":"Mathlib.Data.Matroid.IndepAxioms","initialProofState":"α : Type u_1\nP : Set α → Prop\nhP : Exists fun n => ∀ (Y : Set α), P Y → LE.le Y.encard ↑n\nX : Set α\n⊢ Matroid.ExistsMaximalSubsetProperty P X","decl":"/-- If there is an absolute upper bound on the size of a set satisfying `P`, then the\n  maximal subset property always holds. -/\ntheorem _root_.Matroid.existsMaximalSubsetProperty_of_bdd {P : Set α → Prop}\n    (hP : ∃ (n : ℕ), ∀ Y, P Y → Y.encard ≤ n) (X : Set α) : ExistsMaximalSubsetProperty P X := by\n  obtain ⟨n, hP⟩ := hP\n  rintro I hI hIX\n  have hfin : Set.Finite (ncard '' {Y | P Y ∧ I ⊆ Y ∧ Y ⊆ X}) := by\n    rw [finite_iff_bddAbove, bddAbove_def]\n    simp_rw [ENat.le_coe_iff] at hP\n    use n\n    rintro x ⟨Y, ⟨hY,-,-⟩, rfl⟩\n    obtain ⟨n₀, heq, hle⟩ := hP Y hY\n    rwa [ncard_def, heq, ENat.toNat_coe]\n  obtain ⟨Y, ⟨hY, hIY, hYX⟩, hY'⟩ :=\n    Finite.exists_maximal_wrt' ncard _ hfin ⟨I, hI, rfl.subset, hIX⟩\n\n  refine ⟨Y, hIY, ⟨hY, hYX⟩, fun K ⟨hPK, hKX⟩ hYK ↦ ?_⟩\n  have hKfin : K.Finite := finite_of_encard_le_coe (hP K hPK)\n\n  refine (eq_of_subset_of_ncard_le hYK ?_ hKfin).symm.subset\n  rw [hY' K ⟨hPK, hIY.trans hYK, hKX⟩ (ncard_le_ncard hYK hKfin)]\n\n"}
{"name":"IndepMatroid.ofBdd_E","module":"Mathlib.Data.Matroid.IndepAxioms","initialProofState":"α : Type u_1\nE : Set α\nIndep : Set α → Prop\nindep_empty : Indep EmptyCollection.emptyCollection\nindep_subset : ∀ ⦃I J : Set α⦄, Indep J → HasSubset.Subset I J → Indep I\nindep_aug : ∀ ⦃I B : Set α⦄, Indep I → Not (Maximal Indep I) → Maximal Indep B → Exists fun x => And (Membership.mem (SDiff.sdiff B I) x) (Indep (Insert.insert x I))\nsubset_ground : ∀ (I : Set α), Indep I → HasSubset.Subset I E\nindep_bdd : Exists fun n => ∀ (I : Set α), Indep I → LE.le I.encard ↑n\n⊢ Eq (IndepMatroid.ofBdd E Indep indep_empty indep_subset indep_aug subset_ground indep_bdd).E E","decl":"/-- If there is an absolute upper bound on the size of an independent set, then the maximality axiom\n  isn't needed to define a matroid by independent sets. -/\n@[simps E] protected def ofBdd (E : Set α) (Indep : Set α → Prop)\n    (indep_empty : Indep ∅)\n    (indep_subset : ∀ ⦃I J⦄, Indep J → I ⊆ J → Indep I)\n    (indep_aug : ∀⦃I B⦄, Indep I → ¬ Maximal Indep I → Maximal Indep B →\n      ∃ x ∈ B \\ I, Indep (insert x I))\n    (subset_ground : ∀ I, Indep I → I ⊆ E)\n    (indep_bdd : ∃ (n : ℕ), ∀ I, Indep I → I.encard ≤ n ) : IndepMatroid α where\n  E := E\n  Indep := Indep\n  indep_empty := indep_empty\n  indep_subset := indep_subset\n  indep_aug := indep_aug\n  indep_maximal X _ := Matroid.existsMaximalSubsetProperty_of_bdd indep_bdd X\n  subset_ground := subset_ground\n\n"}
{"name":"IndepMatroid.ofBdd_indep","module":"Mathlib.Data.Matroid.IndepAxioms","initialProofState":"α : Type u_1\nE : Set α\nIndep : Set α → Prop\nindep_empty : Indep EmptyCollection.emptyCollection\nindep_subset : ∀ ⦃I J : Set α⦄, Indep J → HasSubset.Subset I J → Indep I\nindep_aug : ∀ ⦃I B : Set α⦄, Indep I → Not (Maximal Indep I) → Maximal Indep B → Exists fun x => And (Membership.mem (SDiff.sdiff B I) x) (Indep (Insert.insert x I))\nsubset_ground : ∀ (I : Set α), Indep I → HasSubset.Subset I E\nh_bdd : Exists fun n => ∀ (I : Set α), Indep I → LE.le I.encard ↑n\n⊢ Eq (IndepMatroid.ofBdd E Indep indep_empty indep_subset indep_aug subset_ground h_bdd).Indep Indep","decl":"@[simp] theorem ofBdd_indep (E : Set α) Indep indep_empty indep_subset indep_aug\n    subset_ground h_bdd : (IndepMatroid.ofBdd\n      E Indep indep_empty indep_subset indep_aug subset_ground h_bdd).Indep = Indep := rfl\n\n"}
{"name":"IndepMatroid.instFiniteRkMatroidOfBdd","module":"Mathlib.Data.Matroid.IndepAxioms","initialProofState":"α : Type u_1\nE : Set α\nIndep : Set α → Prop\nindep_empty : Indep EmptyCollection.emptyCollection\nindep_subset : ∀ ⦃I J : Set α⦄, Indep J → HasSubset.Subset I J → Indep I\nindep_aug : ∀ ⦃I B : Set α⦄, Indep I → Not (Maximal Indep I) → Maximal Indep B → Exists fun x => And (Membership.mem (SDiff.sdiff B I) x) (Indep (Insert.insert x I))\nsubset_ground : ∀ (I : Set α), Indep I → HasSubset.Subset I E\nh_bdd : Exists fun n => ∀ (I : Set α), Indep I → LE.le I.encard ↑n\n⊢ (IndepMatroid.ofBdd E Indep indep_empty indep_subset indep_aug subset_ground h_bdd).matroid.FiniteRk","decl":"/-- `IndepMatroid.ofBdd` constructs a `FiniteRk` matroid. -/\ninstance (E : Set α) (Indep : Set α → Prop) indep_empty indep_subset indep_aug subset_ground h_bdd :\n    FiniteRk (IndepMatroid.ofBdd\n      E Indep indep_empty indep_subset indep_aug subset_ground h_bdd).matroid := by\n  obtain ⟨B, hB⟩ := (IndepMatroid.ofBdd E Indep _ _ _ _ _).matroid.exists_base\n  refine hB.finiteRk_of_finite ?_\n  obtain ⟨n, hn⟩ := h_bdd\n  exact finite_of_encard_le_coe <| hn B (by simpa using hB.indep)\n\n"}
{"name":"IndepMatroid.ofBddAugment_E","module":"Mathlib.Data.Matroid.IndepAxioms","initialProofState":"α : Type u_1\nE : Set α\nIndep : Set α → Prop\nindep_empty : Indep EmptyCollection.emptyCollection\nindep_subset : ∀ ⦃I J : Set α⦄, Indep J → HasSubset.Subset I J → Indep I\nindep_aug : ∀ ⦃I J : Set α⦄, Indep I → Indep J → LT.lt I.encard J.encard → Exists fun e => And (Membership.mem J e) (And (Not (Membership.mem I e)) (Indep (Insert.insert e I)))\nindep_bdd : Exists fun n => ∀ (I : Set α), Indep I → LE.le I.encard ↑n\nsubset_ground : ∀ (I : Set α), Indep I → HasSubset.Subset I E\n⊢ Eq (IndepMatroid.ofBddAugment E Indep indep_empty indep_subset indep_aug indep_bdd subset_ground).E E","decl":"@[simp] theorem ofBddAugment_E (E : Set α) Indep indep_empty indep_subset indep_aug\n    indep_bdd subset_ground : (IndepMatroid.ofBddAugment\n      E Indep indep_empty indep_subset indep_aug indep_bdd subset_ground).E = E := rfl\n\n"}
{"name":"IndepMatroid.ofBddAugment_indep","module":"Mathlib.Data.Matroid.IndepAxioms","initialProofState":"α : Type u_1\nE : Set α\nIndep : Set α → Prop\nindep_empty : Indep EmptyCollection.emptyCollection\nindep_subset : ∀ ⦃I J : Set α⦄, Indep J → HasSubset.Subset I J → Indep I\nindep_aug : ∀ ⦃I J : Set α⦄, Indep I → Indep J → LT.lt I.encard J.encard → Exists fun e => And (Membership.mem J e) (And (Not (Membership.mem I e)) (Indep (Insert.insert e I)))\nindep_bdd : Exists fun n => ∀ (I : Set α), Indep I → LE.le I.encard ↑n\nsubset_ground : ∀ (I : Set α), Indep I → HasSubset.Subset I E\n⊢ Eq (IndepMatroid.ofBddAugment E Indep indep_empty indep_subset indep_aug indep_bdd subset_ground).Indep Indep","decl":"@[simp] theorem ofBddAugment_indep (E : Set α) Indep indep_empty indep_subset indep_aug\n    indep_bdd subset_ground : (IndepMatroid.ofBddAugment\n      E Indep indep_empty indep_subset indep_aug indep_bdd subset_ground).Indep = Indep := rfl\n\n"}
{"name":"IndepMatroid.ofBddAugment_finiteRk","module":"Mathlib.Data.Matroid.IndepAxioms","initialProofState":"α : Type u_1\nE : Set α\nIndep : Set α → Prop\nindep_empty : Indep EmptyCollection.emptyCollection\nindep_subset : ∀ ⦃I J : Set α⦄, Indep J → HasSubset.Subset I J → Indep I\nindep_aug : ∀ ⦃I J : Set α⦄, Indep I → Indep J → LT.lt I.encard J.encard → Exists fun e => And (Membership.mem J e) (And (Not (Membership.mem I e)) (Indep (Insert.insert e I)))\nindep_bdd : Exists fun n => ∀ (I : Set α), Indep I → LE.le I.encard ↑n\nsubset_ground : ∀ (I : Set α), Indep I → HasSubset.Subset I E\n⊢ (IndepMatroid.ofBddAugment E Indep indep_empty indep_subset indep_aug indep_bdd subset_ground).matroid.FiniteRk","decl":"instance ofBddAugment_finiteRk (E : Set α) Indep indep_empty indep_subset indep_aug\n    indep_bdd subset_ground : FiniteRk (IndepMatroid.ofBddAugment\n      E Indep indep_empty indep_subset indep_aug indep_bdd subset_ground).matroid := by\n  rw [IndepMatroid.ofBddAugment]\n  infer_instance\n\n"}
{"name":"IndepMatroid.ofFinite_E","module":"Mathlib.Data.Matroid.IndepAxioms","initialProofState":"α : Type u_1\nE : Set α\nhE : E.Finite\nIndep : Set α → Prop\nindep_empty : Indep EmptyCollection.emptyCollection\nindep_subset : ∀ ⦃I J : Set α⦄, Indep J → HasSubset.Subset I J → Indep I\nindep_aug : ∀ ⦃I J : Set α⦄, Indep I → Indep J → LT.lt I.ncard J.ncard → Exists fun e => And (Membership.mem J e) (And (Not (Membership.mem I e)) (Indep (Insert.insert e I)))\nsubset_ground : ∀ ⦃I : Set α⦄, Indep I → HasSubset.Subset I E\n⊢ Eq (IndepMatroid.ofFinite hE Indep indep_empty indep_subset indep_aug subset_ground).E E","decl":"@[simp] theorem ofFinite_E {E : Set α} hE Indep indep_empty indep_subset indep_aug subset_ground :\n    (IndepMatroid.ofFinite\n      (hE : E.Finite) Indep indep_empty indep_subset indep_aug subset_ground).E = E := rfl\n\n"}
{"name":"IndepMatroid.ofFinite_indep","module":"Mathlib.Data.Matroid.IndepAxioms","initialProofState":"α : Type u_1\nE : Set α\nhE : E.Finite\nIndep : Set α → Prop\nindep_empty : Indep EmptyCollection.emptyCollection\nindep_subset : ∀ ⦃I J : Set α⦄, Indep J → HasSubset.Subset I J → Indep I\nindep_aug : ∀ ⦃I J : Set α⦄, Indep I → Indep J → LT.lt I.ncard J.ncard → Exists fun e => And (Membership.mem J e) (And (Not (Membership.mem I e)) (Indep (Insert.insert e I)))\nsubset_ground : ∀ ⦃I : Set α⦄, Indep I → HasSubset.Subset I E\n⊢ Eq (IndepMatroid.ofFinite hE Indep indep_empty indep_subset indep_aug subset_ground).Indep Indep","decl":"@[simp] theorem ofFinite_indep {E : Set α} hE Indep indep_empty indep_subset indep_aug\n    subset_ground : (IndepMatroid.ofFinite\n      (hE : E.Finite) Indep indep_empty indep_subset indep_aug subset_ground).Indep = Indep := rfl\n\n"}
{"name":"IndepMatroid.ofFinite_finite","module":"Mathlib.Data.Matroid.IndepAxioms","initialProofState":"α : Type u_1\nE : Set α\nhE : E.Finite\nIndep : Set α → Prop\nindep_empty : Indep EmptyCollection.emptyCollection\nindep_subset : ∀ ⦃I J : Set α⦄, Indep J → HasSubset.Subset I J → Indep I\nindep_aug : ∀ ⦃I J : Set α⦄, Indep I → Indep J → LT.lt I.ncard J.ncard → Exists fun e => And (Membership.mem J e) (And (Not (Membership.mem I e)) (Indep (Insert.insert e I)))\nsubset_ground : ∀ ⦃I : Set α⦄, Indep I → HasSubset.Subset I E\n⊢ (IndepMatroid.ofFinite hE Indep indep_empty indep_subset indep_aug subset_ground).matroid.Finite","decl":"instance ofFinite_finite {E : Set α} hE Indep indep_empty indep_subset indep_aug subset_ground :\n    (IndepMatroid.ofFinite\n      (hE : E.Finite) Indep indep_empty indep_subset indep_aug subset_ground).matroid.Finite :=\n  ⟨hE⟩\n\n"}
{"name":"IndepMatroid.ofFinset_E","module":"Mathlib.Data.Matroid.IndepAxioms","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nE : Set α\nIndep : Finset α → Prop\nindep_empty : Indep EmptyCollection.emptyCollection\nindep_subset : ∀ ⦃I J : Finset α⦄, Indep J → HasSubset.Subset I J → Indep I\nindep_aug : ∀ ⦃I J : Finset α⦄, Indep I → Indep J → LT.lt I.card J.card → Exists fun e => And (Membership.mem J e) (And (Not (Membership.mem I e)) (Indep (Insert.insert e I)))\nsubset_ground : ∀ ⦃I : Finset α⦄, Indep I → HasSubset.Subset (↑I) E\n⊢ Eq (IndepMatroid.ofFinset E Indep indep_empty indep_subset indep_aug subset_ground).E E","decl":"@[simp] theorem ofFinset_E [DecidableEq α] (E : Set α) Indep indep_empty indep_subset indep_aug\n    subset_ground : (IndepMatroid.ofFinset\n      E Indep indep_empty indep_subset indep_aug subset_ground).E = E := rfl\n\n"}
{"name":"IndepMatroid.ofFinset_indep","module":"Mathlib.Data.Matroid.IndepAxioms","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nE : Set α\nIndep : Finset α → Prop\nindep_empty : Indep EmptyCollection.emptyCollection\nindep_subset : ∀ ⦃I J : Finset α⦄, Indep J → HasSubset.Subset I J → Indep I\nindep_aug : ∀ ⦃I J : Finset α⦄, Indep I → Indep J → LT.lt I.card J.card → Exists fun e => And (Membership.mem J e) (And (Not (Membership.mem I e)) (Indep (Insert.insert e I)))\nsubset_ground : ∀ ⦃I : Finset α⦄, Indep I → HasSubset.Subset (↑I) E\nI : Finset α\n⊢ Iff ((IndepMatroid.ofFinset E Indep indep_empty indep_subset indep_aug subset_ground).Indep ↑I) (Indep I)","decl":"@[simp] theorem ofFinset_indep [DecidableEq α] (E : Set α) Indep indep_empty indep_subset indep_aug\n    subset_ground {I : Finset α} : (IndepMatroid.ofFinset\n      E Indep indep_empty indep_subset indep_aug subset_ground).Indep I ↔ Indep I := by\n  simp only [IndepMatroid.ofFinset, ofFinitaryCardAugment_indep, Finset.coe_subset]\n  exact ⟨fun h ↦ h _ Subset.rfl, fun h J hJI ↦ indep_subset h hJI⟩\n\n"}
{"name":"IndepMatroid.ofFinset_indep'","module":"Mathlib.Data.Matroid.IndepAxioms","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nE : Set α\nIndep : Finset α → Prop\nindep_empty : Indep EmptyCollection.emptyCollection\nindep_subset : ∀ ⦃I J : Finset α⦄, Indep J → HasSubset.Subset I J → Indep I\nindep_aug : ∀ ⦃I J : Finset α⦄, Indep I → Indep J → LT.lt I.card J.card → Exists fun e => And (Membership.mem J e) (And (Not (Membership.mem I e)) (Indep (Insert.insert e I)))\nsubset_ground : ∀ ⦃I : Finset α⦄, Indep I → HasSubset.Subset (↑I) E\nI : Set α\n⊢ Iff ((IndepMatroid.ofFinset E Indep indep_empty indep_subset indep_aug subset_ground).Indep I) (∀ (J : Finset α), HasSubset.Subset (↑J) I → Indep J)","decl":"/-- This can't be `@[simp]`, because it would cause the more useful\n  `Matroid.ofIndepFinset_apply` not to be in simp normal form. -/\ntheorem ofFinset_indep' [DecidableEq α] (E : Set α) Indep indep_empty indep_subset indep_aug\n    subset_ground {I : Set α} : (IndepMatroid.ofFinset\n      E Indep indep_empty indep_subset indep_aug subset_ground).Indep I ↔\n        ∀ (J : Finset α), (J : Set α) ⊆ I → Indep J := by\n  simp only [IndepMatroid.ofFinset, ofFinitaryCardAugment_indep]\n\n"}
{"name":"Matroid.ofExistsMatroid_E","module":"Mathlib.Data.Matroid.IndepAxioms","initialProofState":"α : Type u_1\nE : Set α\nIndep : Set α → Prop\nhM : Exists fun M => And (Eq E M.E) (∀ (I : Set α), Iff (M.Indep I) (Indep I))\n⊢ Eq (Matroid.ofExistsMatroid E Indep hM).E E","decl":"/-- Construct an `Matroid` from an independence predicate that agrees with that of some matroid `M`.\n  This is computable even if `M` is only known existentially, or when `M` exists for different\n  reasons in different cases. This can also be used to change the independence predicate to a\n  more useful definitional form. -/\n@[simps! E] protected def ofExistsMatroid (E : Set α) (Indep : Set α → Prop)\n    (hM : ∃ (M : Matroid α), E = M.E ∧ ∀ I, M.Indep I ↔ Indep I) : Matroid α :=\n  IndepMatroid.matroid <|\n  have hex : ∃ (M : Matroid α), E = M.E ∧ M.Indep = Indep := by\n    obtain ⟨M, rfl, h⟩ := hM; refine ⟨_, rfl, funext (by simp [h])⟩\n  IndepMatroid.mk (E := E) (Indep := Indep)\n  (indep_empty := by obtain ⟨M, -, rfl⟩ := hex; exact M.empty_indep)\n  (indep_subset := by obtain ⟨M, -, rfl⟩ := hex; exact fun I J hJ hIJ ↦ hJ.subset hIJ)\n  (indep_aug := by obtain ⟨M, -, rfl⟩ := hex; exact Indep.exists_insert_of_not_maximal M)\n  (indep_maximal := by obtain ⟨M, rfl, rfl⟩ := hex; exact M.existsMaximalSubsetProperty_indep)\n  (subset_ground := by obtain ⟨M, rfl, rfl⟩ := hex; exact fun I ↦ Indep.subset_ground)\n\n"}
{"name":"Matroid.ofBase_E","module":"Mathlib.Data.Matroid.IndepAxioms","initialProofState":"α : Type u_1\nE : Set α\nBase : Set α → Prop\nexists_base : Exists fun B => Base B\nbase_exchange : Matroid.ExchangeProperty Base\nmaximality : ∀ (X : Set α), HasSubset.Subset X E → Matroid.ExistsMaximalSubsetProperty (fun x => Exists fun B => And (Base B) (HasSubset.Subset x B)) X\nsubset_ground : ∀ (B : Set α), Base B → HasSubset.Subset B E\n⊢ Eq (Matroid.ofBase E Base exists_base base_exchange maximality subset_ground).E E","decl":"/-- A matroid defined purely in terms of its bases. -/\n@[simps E] protected def ofBase (E : Set α) (Base : Set α → Prop) (exists_base : ∃ B, Base B)\n    (base_exchange : ExchangeProperty Base)\n    (maximality : ∀ X, X ⊆ E → Matroid.ExistsMaximalSubsetProperty (∃ B, Base B ∧ · ⊆ B) X)\n    (subset_ground : ∀ B, Base B → B ⊆ E) : Matroid α where\n  E := E\n  Base := Base\n  Indep I := (∃ B, Base B ∧ I ⊆ B)\n  indep_iff' _ := Iff.rfl\n  exists_base := exists_base\n  base_exchange := base_exchange\n  maximality := maximality\n  subset_ground := subset_ground\n\n"}
{"name":"Matroid.ofExistsFiniteBase_E","module":"Mathlib.Data.Matroid.IndepAxioms","initialProofState":"α : Type u_1\nE : Set α\nBase : Set α → Prop\nexists_finite_base : Exists fun B => And (Base B) B.Finite\nbase_exchange : Matroid.ExchangeProperty Base\nsubset_ground : ∀ (B : Set α), Base B → HasSubset.Subset B E\n⊢ Eq (Matroid.ofExistsFiniteBase E Base exists_finite_base base_exchange subset_ground).E E","decl":"/-- A collection of bases with the exchange property and at least one finite member is a matroid -/\n@[simps! E] protected def ofExistsFiniteBase (E : Set α) (Base : Set α → Prop)\n    (exists_finite_base : ∃ B, Base B ∧ B.Finite) (base_exchange : ExchangeProperty Base)\n    (subset_ground : ∀ B, Base B → B ⊆ E) : Matroid α := Matroid.ofBase\n  (E := E)\n  (Base := Base)\n  (exists_base := by obtain ⟨B,h⟩ := exists_finite_base; exact ⟨B, h.1⟩)\n  (base_exchange := base_exchange)\n  (maximality := by\n    obtain ⟨B, hB, hfin⟩ := exists_finite_base\n    refine fun X _ ↦ Matroid.existsMaximalSubsetProperty_of_bdd\n      ⟨B.ncard, fun Y ⟨B', hB', hYB'⟩ ↦ ?_⟩ X\n    rw [hfin.cast_ncard_eq, base_exchange.encard_base_eq hB hB']\n    exact encard_mono hYB')\n  (subset_ground := subset_ground)\n\n"}
{"name":"Matroid.ofExistsFiniteBase_base","module":"Mathlib.Data.Matroid.IndepAxioms","initialProofState":"α : Type u_1\nE : Set α\nBase : Set α → Prop\nexists_finite_base : Exists fun B => And (Base B) B.Finite\nbase_exchange : Matroid.ExchangeProperty Base\nsubset_ground : ∀ (B : Set α), Base B → HasSubset.Subset B E\n⊢ Eq (Matroid.ofExistsFiniteBase E Base exists_finite_base base_exchange subset_ground).Base Base","decl":"@[simp] theorem ofExistsFiniteBase_base (E : Set α) Base exists_finite_base\n    base_exchange subset_ground : (Matroid.ofExistsFiniteBase\n      E Base exists_finite_base base_exchange subset_ground).Base = Base := rfl\n\n"}
{"name":"Matroid.ofExistsFiniteBase_finiteRk","module":"Mathlib.Data.Matroid.IndepAxioms","initialProofState":"α : Type u_1\nE : Set α\nBase : Set α → Prop\nexists_finite_base : Exists fun B => And (Base B) B.Finite\nbase_exchange : Matroid.ExchangeProperty Base\nsubset_ground : ∀ (B : Set α), Base B → HasSubset.Subset B E\n⊢ (Matroid.ofExistsFiniteBase E Base exists_finite_base base_exchange subset_ground).FiniteRk","decl":"instance ofExistsFiniteBase_finiteRk (E : Set α) Base exists_finite_base\n    base_exchange subset_ground : FiniteRk (Matroid.ofExistsFiniteBase\n      E Base exists_finite_base base_exchange subset_ground) := by\n  obtain ⟨B, hB, hfin⟩ := exists_finite_base\n  exact Matroid.Base.finiteRk_of_finite (by simpa) hfin\n\n"}
{"name":"Matroid.ofBaseOfFinite_E","module":"Mathlib.Data.Matroid.IndepAxioms","initialProofState":"α : Type u_1\nE : Set α\nhE : E.Finite\nBase : Set α → Prop\nexists_base : Exists fun B => Base B\nbase_exchange : Matroid.ExchangeProperty Base\nsubset_ground : ∀ (B : Set α), Base B → HasSubset.Subset B E\n⊢ Eq (Matroid.ofBaseOfFinite hE Base exists_base base_exchange subset_ground).E E","decl":"@[simp] theorem ofBaseOfFinite_E {E : Set α} (hE : E.Finite) Base exists_base base_exchange\n    subset_ground : (Matroid.ofBaseOfFinite\n      hE Base exists_base base_exchange subset_ground).E = E := rfl\n\n"}
{"name":"Matroid.ofBaseOfFinite_base","module":"Mathlib.Data.Matroid.IndepAxioms","initialProofState":"α : Type u_1\nE : Set α\nhE : E.Finite\nBase : Set α → Prop\nexists_base : Exists fun B => Base B\nbase_exchange : Matroid.ExchangeProperty Base\nsubset_ground : ∀ (B : Set α), Base B → HasSubset.Subset B E\n⊢ Eq (Matroid.ofBaseOfFinite hE Base exists_base base_exchange subset_ground).Base Base","decl":"@[simp] theorem ofBaseOfFinite_base {E : Set α} (hE : E.Finite) Base exists_base\n    base_exchange subset_ground : (Matroid.ofBaseOfFinite\n      hE Base exists_base base_exchange subset_ground).Base = Base := rfl\n\n"}
{"name":"Matroid.ofBaseOfFinite_finite","module":"Mathlib.Data.Matroid.IndepAxioms","initialProofState":"α : Type u_1\nE : Set α\nhE : E.Finite\nBase : Set α → Prop\nexists_base : Exists fun B => Base B\nbase_exchange : Matroid.ExchangeProperty Base\nsubset_ground : ∀ (B : Set α), Base B → HasSubset.Subset B E\n⊢ (Matroid.ofBaseOfFinite hE Base exists_base base_exchange subset_ground).Finite","decl":"instance ofBaseOfFinite_finite {E : Set α} (hE : E.Finite) Base exists_base\n    base_exchange subset_ground : (Matroid.ofBaseOfFinite\n      hE Base exists_base base_exchange subset_ground).Finite :=\n  ⟨hE⟩\n\n"}
