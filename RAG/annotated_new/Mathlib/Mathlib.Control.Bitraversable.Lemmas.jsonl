{"name":"Bitraversable.id_tfst","module":"Mathlib.Control.Bitraversable.Lemmas","initialProofState":"t : Type u → Type u → Type u\ninst✝¹ : Bitraversable t\ninst✝ : LawfulBitraversable t\nα β : Type u\nx : t α β\n⊢ Eq (Bitraversable.tfst Pure.pure x) (Pure.pure x)","decl":"@[higher_order tfst_id]\ntheorem id_tfst : ∀ {α β} (x : t α β), tfst (F := Id) pure x = pure x :=\n  id_bitraverse\n\n"}
{"name":"Bitraversable.tfst_id","module":"Mathlib.Control.Bitraversable.Lemmas","initialProofState":"t : Type u → Type u → Type u\ninst✝¹ : Bitraversable t\ninst✝ : LawfulBitraversable t\nα β : Type u\n⊢ Eq (Bitraversable.tfst Pure.pure) Pure.pure","decl":"@[higher_order tfst_id]\ntheorem id_tfst : ∀ {α β} (x : t α β), tfst (F := Id) pure x = pure x :=\n  id_bitraverse\n\n"}
{"name":"Bitraversable.tsnd_id","module":"Mathlib.Control.Bitraversable.Lemmas","initialProofState":"t : Type u → Type u → Type u\ninst✝¹ : Bitraversable t\ninst✝ : LawfulBitraversable t\nα β : Type u\n⊢ Eq (Bitraversable.tsnd Pure.pure) Pure.pure","decl":"@[higher_order tsnd_id]\ntheorem id_tsnd : ∀ {α β} (x : t α β), tsnd (F := Id) pure x = pure x :=\n  id_bitraverse\n\n"}
{"name":"Bitraversable.id_tsnd","module":"Mathlib.Control.Bitraversable.Lemmas","initialProofState":"t : Type u → Type u → Type u\ninst✝¹ : Bitraversable t\ninst✝ : LawfulBitraversable t\nα β : Type u\nx : t α β\n⊢ Eq (Bitraversable.tsnd Pure.pure x) (Pure.pure x)","decl":"@[higher_order tsnd_id]\ntheorem id_tsnd : ∀ {α β} (x : t α β), tsnd (F := Id) pure x = pure x :=\n  id_bitraverse\n\n"}
{"name":"Bitraversable.tfst_comp_tfst","module":"Mathlib.Control.Bitraversable.Lemmas","initialProofState":"t : Type u → Type u → Type u\ninst✝⁵ : Bitraversable t\nF G : Type u → Type u\ninst✝⁴ : Applicative F\ninst✝³ : Applicative G\ninst✝² : LawfulBitraversable t\ninst✝¹ : LawfulApplicative F\ninst✝ : LawfulApplicative G\nα₀ α₁ α₂ β : Type u\nf : α₀ → F α₁\nf' : α₁ → G α₂\n⊢ Eq (Function.comp Functor.Comp.mk (Function.comp (Functor.map (Bitraversable.tfst f')) (Bitraversable.tfst f))) (Bitraversable.tfst (Function.comp Functor.Comp.mk (Function.comp (Functor.map f') f)))","decl":"@[higher_order tfst_comp_tfst]\ntheorem comp_tfst {α₀ α₁ α₂ β} (f : α₀ → F α₁) (f' : α₁ → G α₂) (x : t α₀ β) :\n    Comp.mk (tfst f' <$> tfst f x) = tfst (Comp.mk ∘ map f' ∘ f) x := by\n  rw [← comp_bitraverse]\n  simp only [Function.comp_def, tfst, map_pure, Pure.pure]\n\n"}
{"name":"Bitraversable.comp_tfst","module":"Mathlib.Control.Bitraversable.Lemmas","initialProofState":"t : Type u → Type u → Type u\ninst✝⁵ : Bitraversable t\nF G : Type u → Type u\ninst✝⁴ : Applicative F\ninst✝³ : Applicative G\ninst✝² : LawfulBitraversable t\ninst✝¹ : LawfulApplicative F\ninst✝ : LawfulApplicative G\nα₀ α₁ α₂ β : Type u\nf : α₀ → F α₁\nf' : α₁ → G α₂\nx : t α₀ β\n⊢ Eq (Functor.Comp.mk (Functor.map (Bitraversable.tfst f') (Bitraversable.tfst f x))) (Bitraversable.tfst (Function.comp Functor.Comp.mk (Function.comp (Functor.map f') f)) x)","decl":"@[higher_order tfst_comp_tfst]\ntheorem comp_tfst {α₀ α₁ α₂ β} (f : α₀ → F α₁) (f' : α₁ → G α₂) (x : t α₀ β) :\n    Comp.mk (tfst f' <$> tfst f x) = tfst (Comp.mk ∘ map f' ∘ f) x := by\n  rw [← comp_bitraverse]\n  simp only [Function.comp_def, tfst, map_pure, Pure.pure]\n\n"}
{"name":"Bitraversable.tfst_comp_tsnd","module":"Mathlib.Control.Bitraversable.Lemmas","initialProofState":"t : Type u → Type u → Type u\ninst✝⁵ : Bitraversable t\nF G : Type u → Type u\ninst✝⁴ : Applicative F\ninst✝³ : Applicative G\ninst✝² : LawfulBitraversable t\ninst✝¹ : LawfulApplicative F\ninst✝ : LawfulApplicative G\nα₀ α₁ β₀ β₁ : Type u\nf : α₀ → F α₁\nf' : β₀ → G β₁\n⊢ Eq (Function.comp Functor.Comp.mk (Function.comp (Functor.map (Bitraversable.tfst f)) (Bitraversable.tsnd f'))) (Bitraversable.bitraverse (Function.comp Functor.Comp.mk (Function.comp Pure.pure f)) (Function.comp Functor.Comp.mk (Function.comp (Functor.map Pure.pure) f')))","decl":"@[higher_order tfst_comp_tsnd]\ntheorem tfst_tsnd {α₀ α₁ β₀ β₁} (f : α₀ → F α₁) (f' : β₀ → G β₁) (x : t α₀ β₀) :\n    Comp.mk (tfst f <$> tsnd f' x)\n      = bitraverse (Comp.mk ∘ pure ∘ f) (Comp.mk ∘ map pure ∘ f') x := by\n  rw [← comp_bitraverse]\n  simp only [Function.comp_def, map_pure]\n\n"}
{"name":"Bitraversable.tfst_tsnd","module":"Mathlib.Control.Bitraversable.Lemmas","initialProofState":"t : Type u → Type u → Type u\ninst✝⁵ : Bitraversable t\nF G : Type u → Type u\ninst✝⁴ : Applicative F\ninst✝³ : Applicative G\ninst✝² : LawfulBitraversable t\ninst✝¹ : LawfulApplicative F\ninst✝ : LawfulApplicative G\nα₀ α₁ β₀ β₁ : Type u\nf : α₀ → F α₁\nf' : β₀ → G β₁\nx : t α₀ β₀\n⊢ Eq (Functor.Comp.mk (Functor.map (Bitraversable.tfst f) (Bitraversable.tsnd f' x))) (Bitraversable.bitraverse (Function.comp Functor.Comp.mk (Function.comp Pure.pure f)) (Function.comp Functor.Comp.mk (Function.comp (Functor.map Pure.pure) f')) x)","decl":"@[higher_order tfst_comp_tsnd]\ntheorem tfst_tsnd {α₀ α₁ β₀ β₁} (f : α₀ → F α₁) (f' : β₀ → G β₁) (x : t α₀ β₀) :\n    Comp.mk (tfst f <$> tsnd f' x)\n      = bitraverse (Comp.mk ∘ pure ∘ f) (Comp.mk ∘ map pure ∘ f') x := by\n  rw [← comp_bitraverse]\n  simp only [Function.comp_def, map_pure]\n\n"}
{"name":"Bitraversable.tsnd_comp_tfst","module":"Mathlib.Control.Bitraversable.Lemmas","initialProofState":"t : Type u → Type u → Type u\ninst✝⁵ : Bitraversable t\nF G : Type u → Type u\ninst✝⁴ : Applicative F\ninst✝³ : Applicative G\ninst✝² : LawfulBitraversable t\ninst✝¹ : LawfulApplicative F\ninst✝ : LawfulApplicative G\nα₀ α₁ β₀ β₁ : Type u\nf : α₀ → F α₁\nf' : β₀ → G β₁\n⊢ Eq (Function.comp Functor.Comp.mk (Function.comp (Functor.map (Bitraversable.tsnd f')) (Bitraversable.tfst f))) (Bitraversable.bitraverse (Function.comp Functor.Comp.mk (Function.comp (Functor.map Pure.pure) f)) (Function.comp Functor.Comp.mk (Function.comp Pure.pure f')))","decl":"@[higher_order tsnd_comp_tfst]\ntheorem tsnd_tfst {α₀ α₁ β₀ β₁} (f : α₀ → F α₁) (f' : β₀ → G β₁) (x : t α₀ β₀) :\n    Comp.mk (tsnd f' <$> tfst f x)\n      = bitraverse (Comp.mk ∘ map pure ∘ f) (Comp.mk ∘ pure ∘ f') x := by\n  rw [← comp_bitraverse]\n  simp only [Function.comp_def, map_pure]\n\n"}
{"name":"Bitraversable.tsnd_tfst","module":"Mathlib.Control.Bitraversable.Lemmas","initialProofState":"t : Type u → Type u → Type u\ninst✝⁵ : Bitraversable t\nF G : Type u → Type u\ninst✝⁴ : Applicative F\ninst✝³ : Applicative G\ninst✝² : LawfulBitraversable t\ninst✝¹ : LawfulApplicative F\ninst✝ : LawfulApplicative G\nα₀ α₁ β₀ β₁ : Type u\nf : α₀ → F α₁\nf' : β₀ → G β₁\nx : t α₀ β₀\n⊢ Eq (Functor.Comp.mk (Functor.map (Bitraversable.tsnd f') (Bitraversable.tfst f x))) (Bitraversable.bitraverse (Function.comp Functor.Comp.mk (Function.comp (Functor.map Pure.pure) f)) (Function.comp Functor.Comp.mk (Function.comp Pure.pure f')) x)","decl":"@[higher_order tsnd_comp_tfst]\ntheorem tsnd_tfst {α₀ α₁ β₀ β₁} (f : α₀ → F α₁) (f' : β₀ → G β₁) (x : t α₀ β₀) :\n    Comp.mk (tsnd f' <$> tfst f x)\n      = bitraverse (Comp.mk ∘ map pure ∘ f) (Comp.mk ∘ pure ∘ f') x := by\n  rw [← comp_bitraverse]\n  simp only [Function.comp_def, map_pure]\n\n"}
{"name":"Bitraversable.comp_tsnd","module":"Mathlib.Control.Bitraversable.Lemmas","initialProofState":"t : Type u → Type u → Type u\ninst✝⁵ : Bitraversable t\nF G : Type u → Type u\ninst✝⁴ : Applicative F\ninst✝³ : Applicative G\ninst✝² : LawfulBitraversable t\ninst✝¹ : LawfulApplicative F\ninst✝ : LawfulApplicative G\nα β₀ β₁ β₂ : Type u\ng : β₀ → F β₁\ng' : β₁ → G β₂\nx : t α β₀\n⊢ Eq (Functor.Comp.mk (Functor.map (Bitraversable.tsnd g') (Bitraversable.tsnd g x))) (Bitraversable.tsnd (Function.comp Functor.Comp.mk (Function.comp (Functor.map g') g)) x)","decl":"@[higher_order tsnd_comp_tsnd]\ntheorem comp_tsnd {α β₀ β₁ β₂} (g : β₀ → F β₁) (g' : β₁ → G β₂) (x : t α β₀) :\n    Comp.mk (tsnd g' <$> tsnd g x) = tsnd (Comp.mk ∘ map g' ∘ g) x := by\n  rw [← comp_bitraverse]\n  simp only [Function.comp_def, map_pure]\n  rfl\n\n"}
{"name":"Bitraversable.tsnd_comp_tsnd","module":"Mathlib.Control.Bitraversable.Lemmas","initialProofState":"t : Type u → Type u → Type u\ninst✝⁵ : Bitraversable t\nF G : Type u → Type u\ninst✝⁴ : Applicative F\ninst✝³ : Applicative G\ninst✝² : LawfulBitraversable t\ninst✝¹ : LawfulApplicative F\ninst✝ : LawfulApplicative G\nα β₀ β₁ β₂ : Type u\ng : β₀ → F β₁\ng' : β₁ → G β₂\n⊢ Eq (Function.comp Functor.Comp.mk (Function.comp (Functor.map (Bitraversable.tsnd g')) (Bitraversable.tsnd g))) (Bitraversable.tsnd (Function.comp Functor.Comp.mk (Function.comp (Functor.map g') g)))","decl":"@[higher_order tsnd_comp_tsnd]\ntheorem comp_tsnd {α β₀ β₁ β₂} (g : β₀ → F β₁) (g' : β₁ → G β₂) (x : t α β₀) :\n    Comp.mk (tsnd g' <$> tsnd g x) = tsnd (Comp.mk ∘ map g' ∘ g) x := by\n  rw [← comp_bitraverse]\n  simp only [Function.comp_def, map_pure]\n  rfl\n\n"}
{"name":"Bitraversable.tfst_eq_fst_id","module":"Mathlib.Control.Bitraversable.Lemmas","initialProofState":"t : Type u → Type u → Type u\ninst✝¹ : Bitraversable t\ninst✝ : LawfulBitraversable t\nα α' β : Type u\nf : α → α'\nx : t α β\n⊢ Eq (Bitraversable.tfst (Function.comp Pure.pure f) x) (Pure.pure (Bifunctor.fst f x))","decl":"@[higher_order]\ntheorem tfst_eq_fst_id {α α' β} (f : α → α') (x : t α β) :\n    tfst (F := Id) (pure ∘ f) x = pure (fst f x) := by\n  apply bitraverse_eq_bimap_id\n\n"}
{"name":"Bitraversable.tfst_eq_fst_id'","module":"Mathlib.Control.Bitraversable.Lemmas","initialProofState":"t : Type u → Type u → Type u\ninst✝¹ : Bitraversable t\ninst✝ : LawfulBitraversable t\nα α' β : Type u\nf : α → α'\n⊢ Eq (Bitraversable.tfst (Function.comp Pure.pure f)) (Function.comp Pure.pure (Bifunctor.fst f))","decl":"@[higher_order]\ntheorem tfst_eq_fst_id {α α' β} (f : α → α') (x : t α β) :\n    tfst (F := Id) (pure ∘ f) x = pure (fst f x) := by\n  apply bitraverse_eq_bimap_id\n\n"}
{"name":"Bitraversable.tsnd_eq_snd_id","module":"Mathlib.Control.Bitraversable.Lemmas","initialProofState":"t : Type u → Type u → Type u\ninst✝¹ : Bitraversable t\ninst✝ : LawfulBitraversable t\nα β β' : Type u\nf : β → β'\nx : t α β\n⊢ Eq (Bitraversable.tsnd (Function.comp Pure.pure f) x) (Pure.pure (Bifunctor.snd f x))","decl":"@[higher_order]\ntheorem tsnd_eq_snd_id {α β β'} (f : β → β') (x : t α β) :\n    tsnd (F := Id) (pure ∘ f) x = pure (snd f x) := by\n  apply bitraverse_eq_bimap_id\n\n"}
{"name":"Bitraversable.tsnd_eq_snd_id'","module":"Mathlib.Control.Bitraversable.Lemmas","initialProofState":"t : Type u → Type u → Type u\ninst✝¹ : Bitraversable t\ninst✝ : LawfulBitraversable t\nα β β' : Type u\nf : β → β'\n⊢ Eq (Bitraversable.tsnd (Function.comp Pure.pure f)) (Function.comp Pure.pure (Bifunctor.snd f))","decl":"@[higher_order]\ntheorem tsnd_eq_snd_id {α β β'} (f : β → β') (x : t α β) :\n    tsnd (F := Id) (pure ∘ f) x = pure (snd f x) := by\n  apply bitraverse_eq_bimap_id\n\n"}
