{"name":"Ultrafilter.eventually_add","module":"Mathlib.Combinatorics.Hindman","initialProofState":"M : Type u_1\ninst✝ : Add M\nU V : Ultrafilter M\np : M → Prop\n⊢ Iff (Filter.Eventually (fun m => p m) ↑(HAdd.hAdd U V)) (Filter.Eventually (fun m => Filter.Eventually (fun m' => p (HAdd.hAdd m m')) ↑V) ↑U)","decl":"@[to_additive]\ntheorem Ultrafilter.eventually_mul {M} [Mul M] (U V : Ultrafilter M) (p : M → Prop) :\n    (∀ᶠ m in ↑(U * V), p m) ↔ ∀ᶠ m in U, ∀ᶠ m' in V, p (m * m') :=\n  Iff.rfl\n\n"}
{"name":"Ultrafilter.eventually_mul","module":"Mathlib.Combinatorics.Hindman","initialProofState":"M : Type u_1\ninst✝ : Mul M\nU V : Ultrafilter M\np : M → Prop\n⊢ Iff (Filter.Eventually (fun m => p m) ↑(HMul.hMul U V)) (Filter.Eventually (fun m => Filter.Eventually (fun m' => p (HMul.hMul m m')) ↑V) ↑U)","decl":"@[to_additive]\ntheorem Ultrafilter.eventually_mul {M} [Mul M] (U V : Ultrafilter M) (p : M → Prop) :\n    (∀ᶠ m in ↑(U * V), p m) ↔ ∀ᶠ m in U, ∀ᶠ m' in V, p (m * m') :=\n  Iff.rfl\n\n"}
{"name":"Ultrafilter.continuous_add_left","module":"Mathlib.Combinatorics.Hindman","initialProofState":"M : Type u_1\ninst✝ : AddSemigroup M\nV : Ultrafilter M\n⊢ Continuous fun x => HAdd.hAdd x V","decl":"@[to_additive]\ntheorem Ultrafilter.continuous_mul_left {M} [Semigroup M] (V : Ultrafilter M) :\n    Continuous (· * V) :=\n  ultrafilterBasis_is_basis.continuous_iff.2 <| Set.forall_mem_range.mpr fun s ↦\n    ultrafilter_isOpen_basic { m : M | ∀ᶠ m' in V, m * m' ∈ s }\n\n"}
{"name":"Ultrafilter.continuous_mul_left","module":"Mathlib.Combinatorics.Hindman","initialProofState":"M : Type u_1\ninst✝ : Semigroup M\nV : Ultrafilter M\n⊢ Continuous fun x => HMul.hMul x V","decl":"@[to_additive]\ntheorem Ultrafilter.continuous_mul_left {M} [Semigroup M] (V : Ultrafilter M) :\n    Continuous (· * V) :=\n  ultrafilterBasis_is_basis.continuous_iff.2 <| Set.forall_mem_range.mpr fun s ↦\n    ultrafilter_isOpen_basic { m : M | ∀ᶠ m' in V, m * m' ∈ s }\n\n"}
{"name":"Hindman.FS.brecOn","module":"Mathlib.Combinatorics.Hindman","initialProofState":"M : Type u_1\ninst✝ : AddSemigroup M\nmotive✝ : (a : Stream' M) → (a_1 : M) → Hindman.FS a a_1 → Prop\na✝¹ : Stream' M\na✝ : M\nx✝ : Hindman.FS a✝¹ a✝\nih✝ : ∀ (a : Stream' M) (a_1 : M) (x : Hindman.FS a a_1), x.below → motive✝ a a_1 x\n⊢ motive✝ a✝¹ a✝ x✝","decl":"/-- `FS a` is the set of finite sums in `a`, i.e. `m ∈ FS a` if `m` is the sum of a nonempty\nsubsequence of `a`. We give a direct inductive definition instead of talking about subsequences. -/\ninductive FS {M} [AddSemigroup M] : Stream' M → Set M\n  | head (a : Stream' M) : FS a a.head\n  | tail (a : Stream' M) (m : M) (h : FS a.tail m) : FS a m\n  | cons (a : Stream' M) (m : M) (h : FS a.tail m) : FS a (a.head + m)\n\n"}
{"name":"Hindman.FP.brecOn","module":"Mathlib.Combinatorics.Hindman","initialProofState":"M : Type u_1\ninst✝ : Semigroup M\nmotive✝ : (a : Stream' M) → (a_1 : M) → Hindman.FP a a_1 → Prop\na✝¹ : Stream' M\na✝ : M\nx✝ : Hindman.FP a✝¹ a✝\nih✝ : ∀ (a : Stream' M) (a_1 : M) (x : Hindman.FP a a_1), x.below → motive✝ a a_1 x\n⊢ motive✝ a✝¹ a✝ x✝","decl":"/-- `FP a` is the set of finite products in `a`, i.e. `m ∈ FP a` if `m` is the product of a nonempty\nsubsequence of `a`. We give a direct inductive definition instead of talking about subsequences. -/\n@[to_additive FS]\ninductive FP {M} [Semigroup M] : Stream' M → Set M\n  | head (a : Stream' M) : FP a a.head\n  | tail (a : Stream' M) (m : M) (h : FP a.tail m) : FP a m\n  | cons (a : Stream' M) (m : M) (h : FP a.tail m) : FP a (a.head * m)\n\n"}
{"name":"Hindman.FS.add","module":"Mathlib.Combinatorics.Hindman","initialProofState":"M : Type u_1\ninst✝ : AddSemigroup M\na : Stream' M\nm : M\nhm : Membership.mem (Hindman.FS a) m\n⊢ Exists fun n => ∀ (m' : M), Membership.mem (Hindman.FS (Stream'.drop n a)) m' → Membership.mem (Hindman.FS a) (HAdd.hAdd m m')","decl":"/-- If `m` and `m'` are finite products in `M`, then so is `m * m'`, provided that `m'` is obtained\nfrom a subsequence of `M` starting sufficiently late. -/\n@[to_additive\n      \"If `m` and `m'` are finite sums in `M`, then so is `m + m'`, provided that `m'`\n      is obtained from a subsequence of `M` starting sufficiently late.\"]\ntheorem FP.mul {M} [Semigroup M] {a : Stream' M} {m : M} (hm : m ∈ FP a) :\n    ∃ n, ∀ m' ∈ FP (a.drop n), m * m' ∈ FP a := by\n  induction' hm with a a m hm ih a m hm ih\n  · exact ⟨1, fun m hm => FP.cons a m hm⟩\n  · cases' ih with n hn\n    use n + 1\n    intro m' hm'\n    exact FP.tail _ _ (hn _ hm')\n  · cases' ih with n hn\n    use n + 1\n    intro m' hm'\n    rw [mul_assoc]\n    exact FP.cons _ _ (hn _ hm')\n\n"}
{"name":"Hindman.FP.mul","module":"Mathlib.Combinatorics.Hindman","initialProofState":"M : Type u_1\ninst✝ : Semigroup M\na : Stream' M\nm : M\nhm : Membership.mem (Hindman.FP a) m\n⊢ Exists fun n => ∀ (m' : M), Membership.mem (Hindman.FP (Stream'.drop n a)) m' → Membership.mem (Hindman.FP a) (HMul.hMul m m')","decl":"/-- If `m` and `m'` are finite products in `M`, then so is `m * m'`, provided that `m'` is obtained\nfrom a subsequence of `M` starting sufficiently late. -/\n@[to_additive\n      \"If `m` and `m'` are finite sums in `M`, then so is `m + m'`, provided that `m'`\n      is obtained from a subsequence of `M` starting sufficiently late.\"]\ntheorem FP.mul {M} [Semigroup M] {a : Stream' M} {m : M} (hm : m ∈ FP a) :\n    ∃ n, ∀ m' ∈ FP (a.drop n), m * m' ∈ FP a := by\n  induction' hm with a a m hm ih a m hm ih\n  · exact ⟨1, fun m hm => FP.cons a m hm⟩\n  · cases' ih with n hn\n    use n + 1\n    intro m' hm'\n    exact FP.tail _ _ (hn _ hm')\n  · cases' ih with n hn\n    use n + 1\n    intro m' hm'\n    rw [mul_assoc]\n    exact FP.cons _ _ (hn _ hm')\n\n"}
{"name":"Hindman.exists_idempotent_ultrafilter_le_FS","module":"Mathlib.Combinatorics.Hindman","initialProofState":"M : Type u_1\ninst✝ : AddSemigroup M\na : Stream' M\n⊢ Exists fun U => And (Eq (HAdd.hAdd U U) U) (Filter.Eventually (fun m => Membership.mem (Hindman.FS a) m) ↑U)","decl":"@[to_additive exists_idempotent_ultrafilter_le_FS]\ntheorem exists_idempotent_ultrafilter_le_FP {M} [Semigroup M] (a : Stream' M) :\n    ∃ U : Ultrafilter M, U * U = U ∧ ∀ᶠ m in U, m ∈ FP a := by\n  let S : Set (Ultrafilter M) := ⋂ n, { U | ∀ᶠ m in U, m ∈ FP (a.drop n) }\n  have h := exists_idempotent_in_compact_subsemigroup ?_ S ?_ ?_ ?_\n  · rcases h with ⟨U, hU, U_idem⟩\n    refine ⟨U, U_idem, ?_⟩\n    convert Set.mem_iInter.mp hU 0\n  · exact Ultrafilter.continuous_mul_left\n  · apply IsCompact.nonempty_iInter_of_sequence_nonempty_isCompact_isClosed\n    · intro n U hU\n      filter_upwards [hU]\n      rw [← Stream'.drop_drop, ← Stream'.tail_eq_drop]\n      exact FP.tail _\n    · intro n\n      exact ⟨pure _, mem_pure.mpr <| FP.head _⟩\n    · exact (ultrafilter_isClosed_basic _).isCompact\n    · intro n\n      apply ultrafilter_isClosed_basic\n  · exact IsClosed.isCompact (isClosed_iInter fun i => ultrafilter_isClosed_basic _)\n  · intro U hU V hV\n    rw [Set.mem_iInter] at *\n    intro n\n    rw [Set.mem_setOf_eq, Ultrafilter.eventually_mul]\n    filter_upwards [hU n] with m hm\n    obtain ⟨n', hn⟩ := FP.mul hm\n    filter_upwards [hV (n' + n)] with m' hm'\n    apply hn\n    simpa only [Stream'.drop_drop, add_comm] using hm'\n\n"}
{"name":"Hindman.exists_idempotent_ultrafilter_le_FP","module":"Mathlib.Combinatorics.Hindman","initialProofState":"M : Type u_1\ninst✝ : Semigroup M\na : Stream' M\n⊢ Exists fun U => And (Eq (HMul.hMul U U) U) (Filter.Eventually (fun m => Membership.mem (Hindman.FP a) m) ↑U)","decl":"@[to_additive exists_idempotent_ultrafilter_le_FS]\ntheorem exists_idempotent_ultrafilter_le_FP {M} [Semigroup M] (a : Stream' M) :\n    ∃ U : Ultrafilter M, U * U = U ∧ ∀ᶠ m in U, m ∈ FP a := by\n  let S : Set (Ultrafilter M) := ⋂ n, { U | ∀ᶠ m in U, m ∈ FP (a.drop n) }\n  have h := exists_idempotent_in_compact_subsemigroup ?_ S ?_ ?_ ?_\n  · rcases h with ⟨U, hU, U_idem⟩\n    refine ⟨U, U_idem, ?_⟩\n    convert Set.mem_iInter.mp hU 0\n  · exact Ultrafilter.continuous_mul_left\n  · apply IsCompact.nonempty_iInter_of_sequence_nonempty_isCompact_isClosed\n    · intro n U hU\n      filter_upwards [hU]\n      rw [← Stream'.drop_drop, ← Stream'.tail_eq_drop]\n      exact FP.tail _\n    · intro n\n      exact ⟨pure _, mem_pure.mpr <| FP.head _⟩\n    · exact (ultrafilter_isClosed_basic _).isCompact\n    · intro n\n      apply ultrafilter_isClosed_basic\n  · exact IsClosed.isCompact (isClosed_iInter fun i => ultrafilter_isClosed_basic _)\n  · intro U hU V hV\n    rw [Set.mem_iInter] at *\n    intro n\n    rw [Set.mem_setOf_eq, Ultrafilter.eventually_mul]\n    filter_upwards [hU n] with m hm\n    obtain ⟨n', hn⟩ := FP.mul hm\n    filter_upwards [hV (n' + n)] with m' hm'\n    apply hn\n    simpa only [Stream'.drop_drop, add_comm] using hm'\n\n"}
{"name":"Hindman.exists_FS_of_large","module":"Mathlib.Combinatorics.Hindman","initialProofState":"M : Type u_1\ninst✝ : AddSemigroup M\nU : Ultrafilter M\nU_idem : Eq (HAdd.hAdd U U) U\ns₀ : Set M\nsU : Membership.mem U s₀\n⊢ Exists fun a => HasSubset.Subset (Hindman.FS a) s₀","decl":"@[to_additive exists_FS_of_large]\ntheorem exists_FP_of_large {M} [Semigroup M] (U : Ultrafilter M) (U_idem : U * U = U) (s₀ : Set M)\n    (sU : s₀ ∈ U) : ∃ a, FP a ⊆ s₀ := by\n  /- Informally: given a `U`-large set `s₀`, the set `s₀ ∩ { m | ∀ᶠ m' in U, m * m' ∈ s₀ }` is also\n  `U`-large (since `U` is idempotent). Thus in particular there is an `a₀` in this intersection. Now\n  let `s₁` be the intersection `s₀ ∩ { m | a₀ * m ∈ s₀ }`. By choice of `a₀`, this is again\n  `U`-large, so we can repeat the argument starting from `s₁`, obtaining `a₁`, `s₂`, etc.\n  This gives the desired infinite sequence. -/\n  have exists_elem : ∀ {s : Set M} (_hs : s ∈ U), (s ∩ { m | ∀ᶠ m' in U, m * m' ∈ s }).Nonempty :=\n    fun {s} hs => Ultrafilter.nonempty_of_mem (inter_mem hs <| by rwa [← U_idem] at hs)\n  let elem : { s // s ∈ U } → M := fun p => (exists_elem p.property).some\n  let succ : {s // s ∈ U} → {s // s ∈ U} := fun (p : {s // s ∈ U}) =>\n        ⟨p.val ∩ {m : M | elem p * m ∈ p.val},\n         inter_mem p.property\n           (show (exists_elem p.property).some ∈ {m : M | ∀ᶠ (m' : M) in ↑U, m * m' ∈ p.val} from\n              p.val.inter_subset_right (exists_elem p.property).some_mem)⟩\n  use Stream'.corec elem succ (Subtype.mk s₀ sU)\n  suffices ∀ (a : Stream' M), ∀ m ∈ FP a, ∀ p, a = Stream'.corec elem succ p → m ∈ p.val by\n    intro m hm\n    exact this _ m hm ⟨s₀, sU⟩ rfl\n  clear sU s₀\n  intro a m h\n  induction' h with b b n h ih b n h ih\n  · rintro p rfl\n    rw [Stream'.corec_eq, Stream'.head_cons]\n    exact Set.inter_subset_left (Set.Nonempty.some_mem _)\n  · rintro p rfl\n    refine Set.inter_subset_left (ih (succ p) ?_)\n    rw [Stream'.corec_eq, Stream'.tail_cons]\n  · rintro p rfl\n    have := Set.inter_subset_right (ih (succ p) ?_)\n    · simpa only using this\n    rw [Stream'.corec_eq, Stream'.tail_cons]\n\n"}
{"name":"Hindman.exists_FP_of_large","module":"Mathlib.Combinatorics.Hindman","initialProofState":"M : Type u_1\ninst✝ : Semigroup M\nU : Ultrafilter M\nU_idem : Eq (HMul.hMul U U) U\ns₀ : Set M\nsU : Membership.mem U s₀\n⊢ Exists fun a => HasSubset.Subset (Hindman.FP a) s₀","decl":"@[to_additive exists_FS_of_large]\ntheorem exists_FP_of_large {M} [Semigroup M] (U : Ultrafilter M) (U_idem : U * U = U) (s₀ : Set M)\n    (sU : s₀ ∈ U) : ∃ a, FP a ⊆ s₀ := by\n  /- Informally: given a `U`-large set `s₀`, the set `s₀ ∩ { m | ∀ᶠ m' in U, m * m' ∈ s₀ }` is also\n  `U`-large (since `U` is idempotent). Thus in particular there is an `a₀` in this intersection. Now\n  let `s₁` be the intersection `s₀ ∩ { m | a₀ * m ∈ s₀ }`. By choice of `a₀`, this is again\n  `U`-large, so we can repeat the argument starting from `s₁`, obtaining `a₁`, `s₂`, etc.\n  This gives the desired infinite sequence. -/\n  have exists_elem : ∀ {s : Set M} (_hs : s ∈ U), (s ∩ { m | ∀ᶠ m' in U, m * m' ∈ s }).Nonempty :=\n    fun {s} hs => Ultrafilter.nonempty_of_mem (inter_mem hs <| by rwa [← U_idem] at hs)\n  let elem : { s // s ∈ U } → M := fun p => (exists_elem p.property).some\n  let succ : {s // s ∈ U} → {s // s ∈ U} := fun (p : {s // s ∈ U}) =>\n        ⟨p.val ∩ {m : M | elem p * m ∈ p.val},\n         inter_mem p.property\n           (show (exists_elem p.property).some ∈ {m : M | ∀ᶠ (m' : M) in ↑U, m * m' ∈ p.val} from\n              p.val.inter_subset_right (exists_elem p.property).some_mem)⟩\n  use Stream'.corec elem succ (Subtype.mk s₀ sU)\n  suffices ∀ (a : Stream' M), ∀ m ∈ FP a, ∀ p, a = Stream'.corec elem succ p → m ∈ p.val by\n    intro m hm\n    exact this _ m hm ⟨s₀, sU⟩ rfl\n  clear sU s₀\n  intro a m h\n  induction' h with b b n h ih b n h ih\n  · rintro p rfl\n    rw [Stream'.corec_eq, Stream'.head_cons]\n    exact Set.inter_subset_left (Set.Nonempty.some_mem _)\n  · rintro p rfl\n    refine Set.inter_subset_left (ih (succ p) ?_)\n    rw [Stream'.corec_eq, Stream'.tail_cons]\n  · rintro p rfl\n    have := Set.inter_subset_right (ih (succ p) ?_)\n    · simpa only using this\n    rw [Stream'.corec_eq, Stream'.tail_cons]\n\n"}
{"name":"Hindman.FP_partition_regular","module":"Mathlib.Combinatorics.Hindman","initialProofState":"M : Type u_1\ninst✝ : Semigroup M\na : Stream' M\ns : Set (Set M)\nsfin : s.Finite\nscov : HasSubset.Subset (Hindman.FP a) s.sUnion\n⊢ Exists fun c => And (Membership.mem s c) (Exists fun b => HasSubset.Subset (Hindman.FP b) c)","decl":"/-- The strong form of **Hindman's theorem**: in any finite cover of an FP-set, one the parts\ncontains an FP-set. -/\n@[to_additive FS_partition_regular\n      \"The strong form of **Hindman's theorem**: in any finite cover of\n      an FS-set, one the parts contains an FS-set.\"]\ntheorem FP_partition_regular {M} [Semigroup M] (a : Stream' M) (s : Set (Set M)) (sfin : s.Finite)\n    (scov : FP a ⊆ ⋃₀ s) : ∃ c ∈ s, ∃ b : Stream' M, FP b ⊆ c :=\n  let ⟨U, idem, aU⟩ := exists_idempotent_ultrafilter_le_FP a\n  let ⟨c, cs, hc⟩ := (Ultrafilter.finite_sUnion_mem_iff sfin).mp (mem_of_superset aU scov)\n  ⟨c, cs, exists_FP_of_large U idem c hc⟩\n\n"}
{"name":"Hindman.FS_partition_regular","module":"Mathlib.Combinatorics.Hindman","initialProofState":"M : Type u_1\ninst✝ : AddSemigroup M\na : Stream' M\ns : Set (Set M)\nsfin : s.Finite\nscov : HasSubset.Subset (Hindman.FS a) s.sUnion\n⊢ Exists fun c => And (Membership.mem s c) (Exists fun b => HasSubset.Subset (Hindman.FS b) c)","decl":"/-- The strong form of **Hindman's theorem**: in any finite cover of an FP-set, one the parts\ncontains an FP-set. -/\n@[to_additive FS_partition_regular\n      \"The strong form of **Hindman's theorem**: in any finite cover of\n      an FS-set, one the parts contains an FS-set.\"]\ntheorem FP_partition_regular {M} [Semigroup M] (a : Stream' M) (s : Set (Set M)) (sfin : s.Finite)\n    (scov : FP a ⊆ ⋃₀ s) : ∃ c ∈ s, ∃ b : Stream' M, FP b ⊆ c :=\n  let ⟨U, idem, aU⟩ := exists_idempotent_ultrafilter_le_FP a\n  let ⟨c, cs, hc⟩ := (Ultrafilter.finite_sUnion_mem_iff sfin).mp (mem_of_superset aU scov)\n  ⟨c, cs, exists_FP_of_large U idem c hc⟩\n\n"}
{"name":"Hindman.exists_FP_of_finite_cover","module":"Mathlib.Combinatorics.Hindman","initialProofState":"M : Type u_1\ninst✝¹ : Semigroup M\ninst✝ : Nonempty M\ns : Set (Set M)\nsfin : s.Finite\nscov : HasSubset.Subset Top.top s.sUnion\n⊢ Exists fun c => And (Membership.mem s c) (Exists fun a => HasSubset.Subset (Hindman.FP a) c)","decl":"/-- The weak form of **Hindman's theorem**: in any finite cover of a nonempty semigroup, one of the\nparts contains an FP-set. -/\n@[to_additive exists_FS_of_finite_cover\n      \"The weak form of **Hindman's theorem**: in any finite cover\n      of a nonempty additive semigroup, one of the parts contains an FS-set.\"]\ntheorem exists_FP_of_finite_cover {M} [Semigroup M] [Nonempty M] (s : Set (Set M)) (sfin : s.Finite)\n    (scov : ⊤ ⊆ ⋃₀ s) : ∃ c ∈ s, ∃ a : Stream' M, FP a ⊆ c :=\n  let ⟨U, hU⟩ :=\n    exists_idempotent_of_compact_t2_of_continuous_mul_left (@Ultrafilter.continuous_mul_left M _)\n  let ⟨c, c_s, hc⟩ := (Ultrafilter.finite_sUnion_mem_iff sfin).mp (mem_of_superset univ_mem scov)\n  ⟨c, c_s, exists_FP_of_large U hU c hc⟩\n\n"}
{"name":"Hindman.exists_FS_of_finite_cover","module":"Mathlib.Combinatorics.Hindman","initialProofState":"M : Type u_1\ninst✝¹ : AddSemigroup M\ninst✝ : Nonempty M\ns : Set (Set M)\nsfin : s.Finite\nscov : HasSubset.Subset Top.top s.sUnion\n⊢ Exists fun c => And (Membership.mem s c) (Exists fun a => HasSubset.Subset (Hindman.FS a) c)","decl":"/-- The weak form of **Hindman's theorem**: in any finite cover of a nonempty semigroup, one of the\nparts contains an FP-set. -/\n@[to_additive exists_FS_of_finite_cover\n      \"The weak form of **Hindman's theorem**: in any finite cover\n      of a nonempty additive semigroup, one of the parts contains an FS-set.\"]\ntheorem exists_FP_of_finite_cover {M} [Semigroup M] [Nonempty M] (s : Set (Set M)) (sfin : s.Finite)\n    (scov : ⊤ ⊆ ⋃₀ s) : ∃ c ∈ s, ∃ a : Stream' M, FP a ⊆ c :=\n  let ⟨U, hU⟩ :=\n    exists_idempotent_of_compact_t2_of_continuous_mul_left (@Ultrafilter.continuous_mul_left M _)\n  let ⟨c, c_s, hc⟩ := (Ultrafilter.finite_sUnion_mem_iff sfin).mp (mem_of_superset univ_mem scov)\n  ⟨c, c_s, exists_FP_of_large U hU c hc⟩\n\n"}
{"name":"Hindman.FP_drop_subset_FP","module":"Mathlib.Combinatorics.Hindman","initialProofState":"M : Type u_1\ninst✝ : Semigroup M\na : Stream' M\nn : Nat\n⊢ HasSubset.Subset (Hindman.FP (Stream'.drop n a)) (Hindman.FP a)","decl":"@[to_additive FS_iter_tail_sub_FS]\ntheorem FP_drop_subset_FP {M} [Semigroup M] (a : Stream' M) (n : ℕ) : FP (a.drop n) ⊆ FP a := by\n  induction n with\n  | zero => rfl\n  | succ n ih =>\n    rw [← Stream'.drop_drop]\n    exact _root_.trans (FP.tail _) ih\n\n"}
{"name":"Hindman.FS_iter_tail_sub_FS","module":"Mathlib.Combinatorics.Hindman","initialProofState":"M : Type u_1\ninst✝ : AddSemigroup M\na : Stream' M\nn : Nat\n⊢ HasSubset.Subset (Hindman.FS (Stream'.drop n a)) (Hindman.FS a)","decl":"@[to_additive FS_iter_tail_sub_FS]\ntheorem FP_drop_subset_FP {M} [Semigroup M] (a : Stream' M) (n : ℕ) : FP (a.drop n) ⊆ FP a := by\n  induction n with\n  | zero => rfl\n  | succ n ih =>\n    rw [← Stream'.drop_drop]\n    exact _root_.trans (FP.tail _) ih\n\n"}
{"name":"Hindman.FP.singleton","module":"Mathlib.Combinatorics.Hindman","initialProofState":"M : Type u_1\ninst✝ : Semigroup M\na : Stream' M\ni : Nat\n⊢ Membership.mem (Hindman.FP a) (a.get i)","decl":"@[to_additive]\ntheorem FP.singleton {M} [Semigroup M] (a : Stream' M) (i : ℕ) : a.get i ∈ FP a := by\n  induction i generalizing a with\n  | zero => exact FP.head _\n  | succ i ih => exact FP.tail _ _ (ih _)\n\n"}
{"name":"Hindman.FS.singleton","module":"Mathlib.Combinatorics.Hindman","initialProofState":"M : Type u_1\ninst✝ : AddSemigroup M\na : Stream' M\ni : Nat\n⊢ Membership.mem (Hindman.FS a) (a.get i)","decl":"@[to_additive]\ntheorem FP.singleton {M} [Semigroup M] (a : Stream' M) (i : ℕ) : a.get i ∈ FP a := by\n  induction i generalizing a with\n  | zero => exact FP.head _\n  | succ i ih => exact FP.tail _ _ (ih _)\n\n"}
{"name":"Hindman.FP.mul_two","module":"Mathlib.Combinatorics.Hindman","initialProofState":"M : Type u_1\ninst✝ : Semigroup M\na : Stream' M\ni j : Nat\nij : LT.lt i j\n⊢ Membership.mem (Hindman.FP a) (HMul.hMul (a.get i) (a.get j))","decl":"@[to_additive]\ntheorem FP.mul_two {M} [Semigroup M] (a : Stream' M) (i j : ℕ) (ij : i < j) :\n    a.get i * a.get j ∈ FP a := by\n  refine FP_drop_subset_FP _ i ?_\n  rw [← Stream'.head_drop]\n  apply FP.cons\n  rcases Nat.exists_eq_add_of_le (Nat.succ_le_of_lt ij) with ⟨d, hd⟩\n  -- Porting note: need to fix breakage of Set notation\n  change _ ∈ FP _\n  have := FP.singleton (a.drop i).tail d\n  rw [Stream'.tail_eq_drop, Stream'.get_drop, Stream'.get_drop] at this\n  convert this\n  omega\n\n"}
{"name":"Hindman.FS.add_two","module":"Mathlib.Combinatorics.Hindman","initialProofState":"M : Type u_1\ninst✝ : AddSemigroup M\na : Stream' M\ni j : Nat\nij : LT.lt i j\n⊢ Membership.mem (Hindman.FS a) (HAdd.hAdd (a.get i) (a.get j))","decl":"@[to_additive]\ntheorem FP.mul_two {M} [Semigroup M] (a : Stream' M) (i j : ℕ) (ij : i < j) :\n    a.get i * a.get j ∈ FP a := by\n  refine FP_drop_subset_FP _ i ?_\n  rw [← Stream'.head_drop]\n  apply FP.cons\n  rcases Nat.exists_eq_add_of_le (Nat.succ_le_of_lt ij) with ⟨d, hd⟩\n  -- Porting note: need to fix breakage of Set notation\n  change _ ∈ FP _\n  have := FP.singleton (a.drop i).tail d\n  rw [Stream'.tail_eq_drop, Stream'.get_drop, Stream'.get_drop] at this\n  convert this\n  omega\n\n"}
{"name":"Hindman.FP.finset_prod","module":"Mathlib.Combinatorics.Hindman","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\na : Stream' M\ns : Finset Nat\nhs : s.Nonempty\n⊢ Membership.mem (Hindman.FP a) (s.prod fun i => a.get i)","decl":"@[to_additive]\ntheorem FP.finset_prod {M} [CommMonoid M] (a : Stream' M) (s : Finset ℕ) (hs : s.Nonempty) :\n    (s.prod fun i => a.get i) ∈ FP a := by\n  refine FP_drop_subset_FP _ (s.min' hs) ?_\n  induction' s using Finset.strongInduction with s ih\n  rw [← Finset.mul_prod_erase _ _ (s.min'_mem hs), ← Stream'.head_drop]\n  rcases (s.erase (s.min' hs)).eq_empty_or_nonempty with h | h\n  · rw [h, Finset.prod_empty, mul_one]\n    exact FP.head _\n  · apply FP.cons\n    rw [Stream'.tail_eq_drop, Stream'.drop_drop, add_comm]\n    refine Set.mem_of_subset_of_mem ?_ (ih _ (Finset.erase_ssubset <| s.min'_mem hs) h)\n    have : s.min' hs + 1 ≤ (s.erase (s.min' hs)).min' h :=\n      Nat.succ_le_of_lt (Finset.min'_lt_of_mem_erase_min' _ _ <| Finset.min'_mem _ _)\n    cases' Nat.exists_eq_add_of_le this with d hd\n    rw [hd, ← Stream'.drop_drop, add_comm]\n    apply FP_drop_subset_FP\n\n"}
{"name":"Hindman.FS.finset_sum","module":"Mathlib.Combinatorics.Hindman","initialProofState":"M : Type u_1\ninst✝ : AddCommMonoid M\na : Stream' M\ns : Finset Nat\nhs : s.Nonempty\n⊢ Membership.mem (Hindman.FS a) (s.sum fun i => a.get i)","decl":"@[to_additive]\ntheorem FP.finset_prod {M} [CommMonoid M] (a : Stream' M) (s : Finset ℕ) (hs : s.Nonempty) :\n    (s.prod fun i => a.get i) ∈ FP a := by\n  refine FP_drop_subset_FP _ (s.min' hs) ?_\n  induction' s using Finset.strongInduction with s ih\n  rw [← Finset.mul_prod_erase _ _ (s.min'_mem hs), ← Stream'.head_drop]\n  rcases (s.erase (s.min' hs)).eq_empty_or_nonempty with h | h\n  · rw [h, Finset.prod_empty, mul_one]\n    exact FP.head _\n  · apply FP.cons\n    rw [Stream'.tail_eq_drop, Stream'.drop_drop, add_comm]\n    refine Set.mem_of_subset_of_mem ?_ (ih _ (Finset.erase_ssubset <| s.min'_mem hs) h)\n    have : s.min' hs + 1 ≤ (s.erase (s.min' hs)).min' h :=\n      Nat.succ_le_of_lt (Finset.min'_lt_of_mem_erase_min' _ _ <| Finset.min'_mem _ _)\n    cases' Nat.exists_eq_add_of_le this with d hd\n    rw [hd, ← Stream'.drop_drop, add_comm]\n    apply FP_drop_subset_FP\n\n"}
