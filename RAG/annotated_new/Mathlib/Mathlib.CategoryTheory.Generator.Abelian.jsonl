{"name":"CategoryTheory.Abelian.has_injective_coseparator","module":"Mathlib.CategoryTheory.Generator.Abelian","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Abelian C\ninst✝¹ : CategoryTheory.Limits.HasLimits C\ninst✝ : CategoryTheory.EnoughInjectives C\nG : C\nhG : CategoryTheory.IsSeparator G\n⊢ Exists fun G => And (CategoryTheory.Injective G) (CategoryTheory.IsCoseparator G)","decl":"theorem has_injective_coseparator [HasLimits C] [EnoughInjectives C] (G : C) (hG : IsSeparator G) :\n    ∃ G : C, Injective G ∧ IsCoseparator G := by\n  haveI : WellPowered.{v} C := wellPowered_of_isDetector G hG.isDetector\n  haveI : HasProductsOfShape (Subobject (op G)) C := hasProductsOfShape_of_small _ _\n  let T : C := Injective.under (piObj fun P : Subobject (op G) => unop P)\n  refine ⟨T, inferInstance, (Preadditive.isCoseparator_iff _).2 fun X Y f hf => ?_⟩\n  refine (Preadditive.isSeparator_iff _).1 hG _ fun h => ?_\n  suffices hh : factorThruImage (h ≫ f) = 0 by\n    rw [← Limits.image.fac (h ≫ f), hh, zero_comp]\n  let R := Subobject.mk (factorThruImage (h ≫ f)).op\n  let q₁ : image (h ≫ f) ⟶ unop R :=\n    (Subobject.underlyingIso (factorThruImage (h ≫ f)).op).unop.hom\n  let q₂ : unop (R : Cᵒᵖ) ⟶ piObj fun P : Subobject (op G) => unop P :=\n    section_ (Pi.π (fun P : Subobject (op G) => (unop P : C)) R)\n  let q : image (h ≫ f) ⟶ T := q₁ ≫ q₂ ≫ Injective.ι _\n  exact zero_of_comp_mono q\n    (by rw [← Injective.comp_factorThru q (Limits.image.ι (h ≫ f)), Limits.image.fac_assoc,\n      Category.assoc, hf, comp_zero])\n\n"}
{"name":"CategoryTheory.Abelian.has_projective_separator","module":"Mathlib.CategoryTheory.Generator.Abelian","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Abelian C\ninst✝¹ : CategoryTheory.Limits.HasColimits C\ninst✝ : CategoryTheory.EnoughProjectives C\nG : C\nhG : CategoryTheory.IsCoseparator G\n⊢ Exists fun G => And (CategoryTheory.Projective G) (CategoryTheory.IsSeparator G)","decl":"theorem has_projective_separator [HasColimits C] [EnoughProjectives C] (G : C)\n    (hG : IsCoseparator G) : ∃ G : C, Projective G ∧ IsSeparator G := by\n  obtain ⟨T, hT₁, hT₂⟩ := has_injective_coseparator (op G) ((isSeparator_op_iff _).2 hG)\n  exact ⟨unop T, inferInstance, (isSeparator_unop_iff _).2 hT₂⟩\n\n"}
