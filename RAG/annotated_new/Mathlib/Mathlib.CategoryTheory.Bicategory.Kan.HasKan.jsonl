{"name":"CategoryTheory.Bicategory.HasLeftKanExtension.hasInitial","module":"Mathlib.CategoryTheory.Bicategory.Kan.HasKan","initialProofState":"B : Type u\ninst✝ : CategoryTheory.Bicategory B\na b c : B\nf : Quiver.Hom a b\ng : Quiver.Hom a c\nself : CategoryTheory.Bicategory.HasLeftKanExtension f g\n⊢ CategoryTheory.Limits.HasInitial (CategoryTheory.Bicategory.LeftExtension f g)","decl":"/-- The existence of a left Kan extension of `g` along `f`. -/\nclass HasLeftKanExtension (f : a ⟶ b) (g : a ⟶ c) : Prop where\n  hasInitial : HasInitial <| LeftExtension f g\n\n"}
{"name":"CategoryTheory.Bicategory.LeftExtension.IsKan.hasLeftKanExtension","module":"Mathlib.CategoryTheory.Bicategory.Kan.HasKan","initialProofState":"B : Type u\ninst✝ : CategoryTheory.Bicategory B\na b c : B\nf : Quiver.Hom a b\ng : Quiver.Hom a c\nt : CategoryTheory.Bicategory.LeftExtension f g\nH : t.IsKan\n⊢ CategoryTheory.Bicategory.HasLeftKanExtension f g","decl":"theorem LeftExtension.IsKan.hasLeftKanExtension {t : LeftExtension f g} (H : IsKan t) :\n    HasLeftKanExtension f g :=\n  ⟨IsInitial.hasInitial H⟩\n\n"}
{"name":"CategoryTheory.Bicategory.instHasInitialLeftExtensionOfHasLeftKanExtension","module":"Mathlib.CategoryTheory.Bicategory.Kan.HasKan","initialProofState":"B : Type u\ninst✝¹ : CategoryTheory.Bicategory B\na b c : B\nf : Quiver.Hom a b\ng : Quiver.Hom a c\ninst✝ : CategoryTheory.Bicategory.HasLeftKanExtension f g\n⊢ CategoryTheory.Limits.HasInitial (CategoryTheory.Bicategory.LeftExtension f g)","decl":"instance [HasLeftKanExtension f g] : HasInitial <| LeftExtension f g :=\n  HasLeftKanExtension.hasInitial\n\n"}
{"name":"CategoryTheory.Bicategory.lanLeftExtension_extension","module":"Mathlib.CategoryTheory.Bicategory.Kan.HasKan","initialProofState":"B : Type u\ninst✝¹ : CategoryTheory.Bicategory B\na b c : B\nf : Quiver.Hom a b\ng : Quiver.Hom a c\ninst✝ : CategoryTheory.Bicategory.HasLeftKanExtension f g\n⊢ Eq (CategoryTheory.Bicategory.lanLeftExtension f g).extension (CategoryTheory.Bicategory.lan f g)","decl":"@[simp]\ntheorem lanLeftExtension_extension (f : a ⟶ b) (g : a ⟶ c) [HasLeftKanExtension f g] :\n    (lanLeftExtension f g).extension = f⁺ g := rfl\n\n"}
{"name":"CategoryTheory.Bicategory.lanLeftExtension_unit","module":"Mathlib.CategoryTheory.Bicategory.Kan.HasKan","initialProofState":"B : Type u\ninst✝¹ : CategoryTheory.Bicategory B\na b c : B\nf : Quiver.Hom a b\ng : Quiver.Hom a c\ninst✝ : CategoryTheory.Bicategory.HasLeftKanExtension f g\n⊢ Eq (CategoryTheory.Bicategory.lanLeftExtension f g).unit (CategoryTheory.Bicategory.lanUnit f g)","decl":"@[simp]\ntheorem lanLeftExtension_unit (f : a ⟶ b) (g : a ⟶ c) [HasLeftKanExtension f g] :\n    (lanLeftExtension f g).unit = lanUnit f g := rfl\n\n"}
{"name":"CategoryTheory.Bicategory.lanUnit_desc","module":"Mathlib.CategoryTheory.Bicategory.Kan.HasKan","initialProofState":"B : Type u\ninst✝¹ : CategoryTheory.Bicategory B\na b c : B\nf : Quiver.Hom a b\ng : Quiver.Hom a c\ninst✝ : CategoryTheory.Bicategory.HasLeftKanExtension f g\ns : CategoryTheory.Bicategory.LeftExtension f g\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.lanUnit f g) (CategoryTheory.Bicategory.whiskerLeft f (CategoryTheory.Bicategory.lanDesc s))) s.unit","decl":"@[reassoc (attr := simp)]\ntheorem lanUnit_desc [HasLeftKanExtension f g] (s : LeftExtension f g) :\n    lanUnit f g ≫ f ◁ lanDesc s = s.unit :=\n  (lanIsKan f g).fac s\n\n"}
{"name":"CategoryTheory.Bicategory.lanUnit_desc_assoc","module":"Mathlib.CategoryTheory.Bicategory.Kan.HasKan","initialProofState":"B : Type u\ninst✝¹ : CategoryTheory.Bicategory B\na b c : B\nf : Quiver.Hom a b\ng : Quiver.Hom a c\ninst✝ : CategoryTheory.Bicategory.HasLeftKanExtension f g\ns : CategoryTheory.Bicategory.LeftExtension f g\nZ : Quiver.Hom a c\nh : Quiver.Hom (CategoryTheory.CategoryStruct.comp f s.extension) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.lanUnit f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f (CategoryTheory.Bicategory.lanDesc s)) h)) (CategoryTheory.CategoryStruct.comp s.unit h)","decl":"@[reassoc (attr := simp)]\ntheorem lanUnit_desc [HasLeftKanExtension f g] (s : LeftExtension f g) :\n    lanUnit f g ≫ f ◁ lanDesc s = s.unit :=\n  (lanIsKan f g).fac s\n\n"}
{"name":"CategoryTheory.Bicategory.lanIsKan_desc","module":"Mathlib.CategoryTheory.Bicategory.Kan.HasKan","initialProofState":"B : Type u\ninst✝¹ : CategoryTheory.Bicategory B\na b c : B\nf : Quiver.Hom a b\ng : Quiver.Hom a c\ninst✝ : CategoryTheory.Bicategory.HasLeftKanExtension f g\ns : CategoryTheory.Bicategory.LeftExtension f g\n⊢ Eq ((CategoryTheory.Bicategory.lanIsKan f g).desc s) (CategoryTheory.Bicategory.lanDesc s)","decl":"@[simp]\ntheorem lanIsKan_desc [HasLeftKanExtension f g] (s : LeftExtension f g) :\n    (lanIsKan f g).desc s = lanDesc s :=\n  rfl\n\n"}
{"name":"CategoryTheory.Bicategory.Lan.existsUnique","module":"Mathlib.CategoryTheory.Bicategory.Kan.HasKan","initialProofState":"B : Type u\ninst✝¹ : CategoryTheory.Bicategory B\na b c : B\nf : Quiver.Hom a b\ng : Quiver.Hom a c\ninst✝ : CategoryTheory.Bicategory.HasLeftKanExtension f g\ns : CategoryTheory.Bicategory.LeftExtension f g\n⊢ ExistsUnique fun τ => Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.lanUnit f g) (CategoryTheory.Bicategory.whiskerLeft f τ)) s.unit","decl":"theorem Lan.existsUnique [HasLeftKanExtension f g] (s : LeftExtension f g) :\n    ∃! τ, lanUnit f g ≫ f ◁ τ = s.unit :=\n  (lanIsKan f g).existsUnique _\n\n"}
{"name":"CategoryTheory.Bicategory.Lan.CommuteWith.commute","module":"Mathlib.CategoryTheory.Bicategory.Kan.HasKan","initialProofState":"B : Type u\ninst✝¹ : CategoryTheory.Bicategory B\na b c : B\nf : Quiver.Hom a b\ng : Quiver.Hom a c\ninst✝ : CategoryTheory.Bicategory.HasLeftKanExtension f g\nx : B\nh : Quiver.Hom c x\nself : CategoryTheory.Bicategory.Lan.CommuteWith f g h\n⊢ Nonempty ((CategoryTheory.Bicategory.lanLeftExtension f g).whisker h).IsKan","decl":"/-- We say that a 1-morphism `h` commutes with the left Kan extension `f⁺ g` if the whiskered\nleft extension for `f⁺ g` by `h` is a Kan extension of `g ≫ h` along `f`. -/\nclass Lan.CommuteWith\n    (f : a ⟶ b) (g : a ⟶ c) [HasLeftKanExtension f g] {x : B} (h : c ⟶ x) : Prop where\n  commute : Nonempty <| IsKan <| (lanLeftExtension f g).whisker h\n\n"}
{"name":"CategoryTheory.Bicategory.Lan.CommuteWith.of_isKan_whisker","module":"Mathlib.CategoryTheory.Bicategory.Kan.HasKan","initialProofState":"B : Type u\ninst✝¹ : CategoryTheory.Bicategory B\na b c : B\nf : Quiver.Hom a b\ng : Quiver.Hom a c\ninst✝ : CategoryTheory.Bicategory.HasLeftKanExtension f g\nt : CategoryTheory.Bicategory.LeftExtension f g\nx : B\nh : Quiver.Hom c x\nH : (t.whisker h).IsKan\ni : CategoryTheory.Iso (t.whisker h) ((CategoryTheory.Bicategory.lanLeftExtension f g).whisker h)\n⊢ CategoryTheory.Bicategory.Lan.CommuteWith f g h","decl":"theorem of_isKan_whisker [HasLeftKanExtension f g] (t : LeftExtension f g) {x : B} (h : c ⟶ x)\n    (H : IsKan (t.whisker h)) (i : t.whisker h ≅ (lanLeftExtension f g).whisker h) :\n    Lan.CommuteWith f g h :=\n  ⟨⟨IsKan.ofIsoKan H i⟩⟩\n\n"}
{"name":"CategoryTheory.Bicategory.Lan.CommuteWith.of_lan_comp_iso","module":"Mathlib.CategoryTheory.Bicategory.Kan.HasKan","initialProofState":"B : Type u\ninst✝² : CategoryTheory.Bicategory B\na b c : B\nf : Quiver.Hom a b\ng : Quiver.Hom a c\ninst✝¹ : CategoryTheory.Bicategory.HasLeftKanExtension f g\nx : B\nh : Quiver.Hom c x\ninst✝ : CategoryTheory.Bicategory.HasLeftKanExtension f (CategoryTheory.CategoryStruct.comp g h)\ni : CategoryTheory.Iso (CategoryTheory.Bicategory.lan f (CategoryTheory.CategoryStruct.comp g h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.lan f g) h)\nw : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.lanUnit f (CategoryTheory.CategoryStruct.comp g h)) (CategoryTheory.Bicategory.whiskerLeft f i.hom)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (CategoryTheory.Bicategory.lanUnit f g) h) (CategoryTheory.Bicategory.associator f (CategoryTheory.Bicategory.lan f g) h).hom)\n⊢ CategoryTheory.Bicategory.Lan.CommuteWith f g h","decl":"theorem of_lan_comp_iso [HasLeftKanExtension f g]\n    {x : B} {h : c ⟶ x} [HasLeftKanExtension f (g ≫ h)]\n    (i : f⁺ (g ≫ h) ≅ f⁺ g ≫ h)\n    (w : lanUnit f (g ≫ h) ≫ f ◁ i.hom = lanUnit f g ▷ h ≫ (α_ _ _ _).hom) :\n    Lan.CommuteWith f g h :=\n  ⟨⟨(lanIsKan f (g ≫ h)).ofIsoKan <| StructuredArrow.isoMk i⟩⟩\n\n"}
{"name":"CategoryTheory.Bicategory.Lan.CommuteWith.instHasLeftKanExtensionComp","module":"Mathlib.CategoryTheory.Bicategory.Kan.HasKan","initialProofState":"B : Type u\ninst✝² : CategoryTheory.Bicategory B\na b c : B\nf : Quiver.Hom a b\ng : Quiver.Hom a c\ninst✝¹ : CategoryTheory.Bicategory.HasLeftKanExtension f g\nx : B\nh : Quiver.Hom c x\ninst✝ : CategoryTheory.Bicategory.Lan.CommuteWith f g h\n⊢ CategoryTheory.Bicategory.HasLeftKanExtension f (CategoryTheory.CategoryStruct.comp g h)","decl":"instance : HasLeftKanExtension f (g ≫ h) := (Lan.CommuteWith.isKan f g h).hasLeftKanExtension\n\n"}
{"name":"CategoryTheory.Bicategory.Lan.CommuteWith.lanCompIsoWhisker_hom_right","module":"Mathlib.CategoryTheory.Bicategory.Kan.HasKan","initialProofState":"B : Type u\ninst✝² : CategoryTheory.Bicategory B\na b c : B\nf : Quiver.Hom a b\ng : Quiver.Hom a c\ninst✝¹ : CategoryTheory.Bicategory.HasLeftKanExtension f g\nx : B\nh : Quiver.Hom c x\ninst✝ : CategoryTheory.Bicategory.Lan.CommuteWith f g h\n⊢ Eq (CategoryTheory.Bicategory.Lan.CommuteWith.lanCompIsoWhisker f g h).hom.right (CategoryTheory.Bicategory.lanDesc ((CategoryTheory.Bicategory.lanLeftExtension f g).whisker h))","decl":"@[simp]\ntheorem lanCompIsoWhisker_hom_right :\n    (lanCompIsoWhisker f g h).hom.right = lanDesc ((lanLeftExtension f g).whisker h) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Bicategory.Lan.CommuteWith.lanCompIsoWhisker_inv_right","module":"Mathlib.CategoryTheory.Bicategory.Kan.HasKan","initialProofState":"B : Type u\ninst✝² : CategoryTheory.Bicategory B\na b c : B\nf : Quiver.Hom a b\ng : Quiver.Hom a c\ninst✝¹ : CategoryTheory.Bicategory.HasLeftKanExtension f g\nx : B\nh : Quiver.Hom c x\ninst✝ : CategoryTheory.Bicategory.Lan.CommuteWith f g h\n⊢ Eq (CategoryTheory.Bicategory.Lan.CommuteWith.lanCompIsoWhisker f g h).inv.right ((CategoryTheory.Bicategory.Lan.CommuteWith.isKan f g h).desc (CategoryTheory.Bicategory.lanLeftExtension f (CategoryTheory.CategoryStruct.comp g h)))","decl":"@[simp]\ntheorem lanCompIsoWhisker_inv_right :\n    (lanCompIsoWhisker f g h).inv.right = (isKan f g h).desc (lanLeftExtension f (g ≫ h)) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Bicategory.Lan.CommuteWith.lanCompIso_hom","module":"Mathlib.CategoryTheory.Bicategory.Kan.HasKan","initialProofState":"B : Type u\ninst✝² : CategoryTheory.Bicategory B\na b c : B\nf : Quiver.Hom a b\ng : Quiver.Hom a c\ninst✝¹ : CategoryTheory.Bicategory.HasLeftKanExtension f g\nx : B\nh : Quiver.Hom c x\ninst✝ : CategoryTheory.Bicategory.Lan.CommuteWith f g h\n⊢ Eq (CategoryTheory.Bicategory.Lan.CommuteWith.lanCompIso f g h).hom (CategoryTheory.Bicategory.lanDesc ((CategoryTheory.Bicategory.lanLeftExtension f g).whisker h))","decl":"/-- The 1-morphism `h` commutes with the left Kan extension `f⁺ g`. -/\n@[simps!]\ndef lanCompIso : f⁺ (g ≫ h) ≅ f⁺ g ≫ h := Comma.rightIso <| lanCompIsoWhisker f g h\n\n"}
{"name":"CategoryTheory.Bicategory.Lan.CommuteWith.lanCompIso_inv","module":"Mathlib.CategoryTheory.Bicategory.Kan.HasKan","initialProofState":"B : Type u\ninst✝² : CategoryTheory.Bicategory B\na b c : B\nf : Quiver.Hom a b\ng : Quiver.Hom a c\ninst✝¹ : CategoryTheory.Bicategory.HasLeftKanExtension f g\nx : B\nh : Quiver.Hom c x\ninst✝ : CategoryTheory.Bicategory.Lan.CommuteWith f g h\n⊢ Eq (CategoryTheory.Bicategory.Lan.CommuteWith.lanCompIso f g h).inv ((CategoryTheory.Bicategory.Lan.CommuteWith.isKan f g h).desc (CategoryTheory.Bicategory.lanLeftExtension f (CategoryTheory.CategoryStruct.comp g h)))","decl":"/-- The 1-morphism `h` commutes with the left Kan extension `f⁺ g`. -/\n@[simps!]\ndef lanCompIso : f⁺ (g ≫ h) ≅ f⁺ g ≫ h := Comma.rightIso <| lanCompIsoWhisker f g h\n\n"}
{"name":"CategoryTheory.Bicategory.HasAbsLeftKanExtension.toHasLeftKanExtension","module":"Mathlib.CategoryTheory.Bicategory.Kan.HasKan","initialProofState":"B : Type u\ninst✝ : CategoryTheory.Bicategory B\na b c : B\nf : Quiver.Hom a b\ng : Quiver.Hom a c\nself : CategoryTheory.Bicategory.HasAbsLeftKanExtension f g\n⊢ CategoryTheory.Bicategory.HasLeftKanExtension f g","decl":"/-- We say that there exists an absolute left Kan extension of `g` along `f` if any 1-morphism `h`\ncommutes with the left Kan extension `f⁺ g`. -/\nclass HasAbsLeftKanExtension (f : a ⟶ b) (g : a ⟶ c) extends HasLeftKanExtension f g : Prop where\n  commute {x : B} (h : c ⟶ x) : Lan.CommuteWith f g h\n\n"}
{"name":"CategoryTheory.Bicategory.HasAbsLeftKanExtension.commute","module":"Mathlib.CategoryTheory.Bicategory.Kan.HasKan","initialProofState":"B : Type u\ninst✝ : CategoryTheory.Bicategory B\na b c : B\nf : Quiver.Hom a b\ng : Quiver.Hom a c\nself : CategoryTheory.Bicategory.HasAbsLeftKanExtension f g\nx : B\nh : Quiver.Hom c x\n⊢ CategoryTheory.Bicategory.Lan.CommuteWith f g h","decl":"/-- We say that there exists an absolute left Kan extension of `g` along `f` if any 1-morphism `h`\ncommutes with the left Kan extension `f⁺ g`. -/\nclass HasAbsLeftKanExtension (f : a ⟶ b) (g : a ⟶ c) extends HasLeftKanExtension f g : Prop where\n  commute {x : B} (h : c ⟶ x) : Lan.CommuteWith f g h\n\n"}
{"name":"CategoryTheory.Bicategory.instCommuteWith","module":"Mathlib.CategoryTheory.Bicategory.Kan.HasKan","initialProofState":"B : Type u\ninst✝¹ : CategoryTheory.Bicategory B\na b c : B\nf : Quiver.Hom a b\ng : Quiver.Hom a c\ninst✝ : CategoryTheory.Bicategory.HasAbsLeftKanExtension f g\nx : B\nh : Quiver.Hom c x\n⊢ CategoryTheory.Bicategory.Lan.CommuteWith f g h","decl":"instance [HasAbsLeftKanExtension f g] {x : B} (h : c ⟶ x) : Lan.CommuteWith f g h :=\n  HasAbsLeftKanExtension.commute h\n\n"}
{"name":"CategoryTheory.Bicategory.LeftExtension.IsAbsKan.hasAbsLeftKanExtension","module":"Mathlib.CategoryTheory.Bicategory.Kan.HasKan","initialProofState":"B : Type u\ninst✝ : CategoryTheory.Bicategory B\na b c : B\nf : Quiver.Hom a b\ng : Quiver.Hom a c\nt : CategoryTheory.Bicategory.LeftExtension f g\nH : t.IsAbsKan\n⊢ CategoryTheory.Bicategory.HasAbsLeftKanExtension f g","decl":"theorem LeftExtension.IsAbsKan.hasAbsLeftKanExtension {t : LeftExtension f g} (H : IsAbsKan t) :\n    HasAbsLeftKanExtension f g :=\n  have : HasLeftKanExtension f g := H.isKan.hasLeftKanExtension\n  ⟨fun h ↦ ⟨⟨H.ofIsoAbsKan (IsKan.uniqueUpToIso H.isKan (lanIsKan f g)) h⟩⟩⟩\n\n"}
{"name":"CategoryTheory.Bicategory.HasLeftKanLift.hasInitial","module":"Mathlib.CategoryTheory.Bicategory.Kan.HasKan","initialProofState":"B : Type u\ninst✝ : CategoryTheory.Bicategory B\na b c : B\nf : Quiver.Hom b a\ng : Quiver.Hom c a\nself : CategoryTheory.Bicategory.HasLeftKanLift f g\n⊢ CategoryTheory.Limits.HasInitial (CategoryTheory.Bicategory.LeftLift f g)","decl":"/-- The existence of a left kan lift of `g` along `f`. -/\nclass HasLeftKanLift (f : b ⟶ a) (g : c ⟶ a) : Prop where mk' ::\n  hasInitial : HasInitial <| LeftLift f g\n\n"}
{"name":"CategoryTheory.Bicategory.LeftLift.IsKan.hasLeftKanLift","module":"Mathlib.CategoryTheory.Bicategory.Kan.HasKan","initialProofState":"B : Type u\ninst✝ : CategoryTheory.Bicategory B\na b c : B\nf : Quiver.Hom b a\ng : Quiver.Hom c a\nt : CategoryTheory.Bicategory.LeftLift f g\nH : t.IsKan\n⊢ CategoryTheory.Bicategory.HasLeftKanLift f g","decl":"theorem LeftLift.IsKan.hasLeftKanLift {t : LeftLift f g} (H : IsKan t) : HasLeftKanLift f g :=\n  ⟨IsInitial.hasInitial H⟩\n\n"}
{"name":"CategoryTheory.Bicategory.instHasInitialLeftLiftOfHasLeftKanLift","module":"Mathlib.CategoryTheory.Bicategory.Kan.HasKan","initialProofState":"B : Type u\ninst✝¹ : CategoryTheory.Bicategory B\na b c : B\nf : Quiver.Hom b a\ng : Quiver.Hom c a\ninst✝ : CategoryTheory.Bicategory.HasLeftKanLift f g\n⊢ CategoryTheory.Limits.HasInitial (CategoryTheory.Bicategory.LeftLift f g)","decl":"instance [HasLeftKanLift f g] : HasInitial <| LeftLift f g := HasLeftKanLift.hasInitial\n\n"}
{"name":"CategoryTheory.Bicategory.lanLiftLeftLift_lift","module":"Mathlib.CategoryTheory.Bicategory.Kan.HasKan","initialProofState":"B : Type u\ninst✝¹ : CategoryTheory.Bicategory B\na b c : B\nf : Quiver.Hom b a\ng : Quiver.Hom c a\ninst✝ : CategoryTheory.Bicategory.HasLeftKanLift f g\n⊢ Eq (CategoryTheory.Bicategory.lanLiftLeftLift f g).lift (CategoryTheory.Bicategory.lanLift f g)","decl":"@[simp]\ntheorem lanLiftLeftLift_lift (f : b ⟶ a) (g : c ⟶ a) [HasLeftKanLift f g] :\n    (lanLiftLeftLift f g).lift = f₊ g := rfl\n\n"}
{"name":"CategoryTheory.Bicategory.lanLiftLeftLift_unit","module":"Mathlib.CategoryTheory.Bicategory.Kan.HasKan","initialProofState":"B : Type u\ninst✝¹ : CategoryTheory.Bicategory B\na b c : B\nf : Quiver.Hom b a\ng : Quiver.Hom c a\ninst✝ : CategoryTheory.Bicategory.HasLeftKanLift f g\n⊢ Eq (CategoryTheory.Bicategory.lanLiftLeftLift f g).unit (CategoryTheory.Bicategory.lanLiftUnit f g)","decl":"@[simp]\ntheorem lanLiftLeftLift_unit (f : b ⟶ a) (g : c ⟶ a) [HasLeftKanLift f g] :\n    (lanLiftLeftLift f g).unit = lanLiftUnit f g := rfl\n\n"}
{"name":"CategoryTheory.Bicategory.lanLiftUnit_desc","module":"Mathlib.CategoryTheory.Bicategory.Kan.HasKan","initialProofState":"B : Type u\ninst✝¹ : CategoryTheory.Bicategory B\na b c : B\nf : Quiver.Hom b a\ng : Quiver.Hom c a\ninst✝ : CategoryTheory.Bicategory.HasLeftKanLift f g\ns : CategoryTheory.Bicategory.LeftLift f g\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.lanLiftUnit f g) (CategoryTheory.Bicategory.whiskerRight (CategoryTheory.Bicategory.lanLiftDesc s) f)) s.unit","decl":"@[reassoc (attr := simp)]\ntheorem lanLiftUnit_desc [HasLeftKanLift f g] (s : LeftLift f g) :\n    lanLiftUnit f g ≫ lanLiftDesc s ▷ f = s.unit :=\n  (lanLiftIsKan f g).fac s\n\n"}
{"name":"CategoryTheory.Bicategory.lanLiftUnit_desc_assoc","module":"Mathlib.CategoryTheory.Bicategory.Kan.HasKan","initialProofState":"B : Type u\ninst✝¹ : CategoryTheory.Bicategory B\na b c : B\nf : Quiver.Hom b a\ng : Quiver.Hom c a\ninst✝ : CategoryTheory.Bicategory.HasLeftKanLift f g\ns : CategoryTheory.Bicategory.LeftLift f g\nZ : Quiver.Hom c a\nh : Quiver.Hom (CategoryTheory.CategoryStruct.comp s.lift f) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.lanLiftUnit f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (CategoryTheory.Bicategory.lanLiftDesc s) f) h)) (CategoryTheory.CategoryStruct.comp s.unit h)","decl":"@[reassoc (attr := simp)]\ntheorem lanLiftUnit_desc [HasLeftKanLift f g] (s : LeftLift f g) :\n    lanLiftUnit f g ≫ lanLiftDesc s ▷ f = s.unit :=\n  (lanLiftIsKan f g).fac s\n\n"}
{"name":"CategoryTheory.Bicategory.lanLiftIsKan_desc","module":"Mathlib.CategoryTheory.Bicategory.Kan.HasKan","initialProofState":"B : Type u\ninst✝¹ : CategoryTheory.Bicategory B\na b c : B\nf : Quiver.Hom b a\ng : Quiver.Hom c a\ninst✝ : CategoryTheory.Bicategory.HasLeftKanLift f g\ns : CategoryTheory.Bicategory.LeftLift f g\n⊢ Eq ((CategoryTheory.Bicategory.lanLiftIsKan f g).desc s) (CategoryTheory.Bicategory.lanLiftDesc s)","decl":"@[simp]\ntheorem lanLiftIsKan_desc [HasLeftKanLift f g] (s : LeftLift f g) :\n    (lanLiftIsKan f g).desc s = lanLiftDesc s :=\n  rfl\n\n"}
{"name":"CategoryTheory.Bicategory.LanLift.existsUnique","module":"Mathlib.CategoryTheory.Bicategory.Kan.HasKan","initialProofState":"B : Type u\ninst✝¹ : CategoryTheory.Bicategory B\na b c : B\nf : Quiver.Hom b a\ng : Quiver.Hom c a\ninst✝ : CategoryTheory.Bicategory.HasLeftKanLift f g\ns : CategoryTheory.Bicategory.LeftLift f g\n⊢ ExistsUnique fun τ => Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.lanLiftUnit f g) (CategoryTheory.Bicategory.whiskerRight τ f)) s.unit","decl":"theorem LanLift.existsUnique [HasLeftKanLift f g] (s : LeftLift f g) :\n    ∃! τ, lanLiftUnit f g ≫ τ ▷ f = s.unit :=\n  (lanLiftIsKan f g).existsUnique _\n\n"}
{"name":"CategoryTheory.Bicategory.LanLift.CommuteWith.commute","module":"Mathlib.CategoryTheory.Bicategory.Kan.HasKan","initialProofState":"B : Type u\ninst✝¹ : CategoryTheory.Bicategory B\na b c : B\nf : Quiver.Hom b a\ng : Quiver.Hom c a\ninst✝ : CategoryTheory.Bicategory.HasLeftKanLift f g\nx : B\nh : Quiver.Hom x c\nself : CategoryTheory.Bicategory.LanLift.CommuteWith f g h\n⊢ Nonempty ((CategoryTheory.Bicategory.lanLiftLeftLift f g).whisker h).IsKan","decl":"/-- We say that a 1-morphism `h` commutes with the left Kan lift `f₊ g` if the whiskered left lift\nfor `f₊ g` by `h` is a Kan lift of `h ≫ g` along `f`. -/\nclass LanLift.CommuteWith\n    (f : b ⟶ a) (g : c ⟶ a) [HasLeftKanLift f g] {x : B} (h : x ⟶ c) : Prop where\n  commute : Nonempty <| IsKan <| (lanLiftLeftLift f g).whisker h\n\n"}
{"name":"CategoryTheory.Bicategory.LanLift.CommuteWith.of_isKan_whisker","module":"Mathlib.CategoryTheory.Bicategory.Kan.HasKan","initialProofState":"B : Type u\ninst✝¹ : CategoryTheory.Bicategory B\na b c : B\nf : Quiver.Hom b a\ng : Quiver.Hom c a\ninst✝ : CategoryTheory.Bicategory.HasLeftKanLift f g\nt : CategoryTheory.Bicategory.LeftLift f g\nx : B\nh : Quiver.Hom x c\nH : (t.whisker h).IsKan\ni : CategoryTheory.Iso (t.whisker h) ((CategoryTheory.Bicategory.lanLiftLeftLift f g).whisker h)\n⊢ CategoryTheory.Bicategory.LanLift.CommuteWith f g h","decl":"theorem of_isKan_whisker [HasLeftKanLift f g] (t : LeftLift f g) {x : B} (h : x ⟶ c)\n    (H : IsKan (t.whisker h)) (i : t.whisker h ≅ (lanLiftLeftLift f g).whisker h) :\n    LanLift.CommuteWith f g h :=\n  ⟨⟨IsKan.ofIsoKan H i⟩⟩\n\n"}
{"name":"CategoryTheory.Bicategory.LanLift.CommuteWith.of_lanLift_comp_iso","module":"Mathlib.CategoryTheory.Bicategory.Kan.HasKan","initialProofState":"B : Type u\ninst✝² : CategoryTheory.Bicategory B\na b c : B\nf : Quiver.Hom b a\ng : Quiver.Hom c a\ninst✝¹ : CategoryTheory.Bicategory.HasLeftKanLift f g\nx : B\nh : Quiver.Hom x c\ninst✝ : CategoryTheory.Bicategory.HasLeftKanLift f (CategoryTheory.CategoryStruct.comp h g)\ni : CategoryTheory.Iso (CategoryTheory.Bicategory.lanLift f (CategoryTheory.CategoryStruct.comp h g)) (CategoryTheory.CategoryStruct.comp h (CategoryTheory.Bicategory.lanLift f g))\nw : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.lanLiftUnit f (CategoryTheory.CategoryStruct.comp h g)) (CategoryTheory.Bicategory.whiskerRight i.hom f)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft h (CategoryTheory.Bicategory.lanLiftUnit f g)) (CategoryTheory.Bicategory.associator h (CategoryTheory.Bicategory.lanLift f g) f).inv)\n⊢ CategoryTheory.Bicategory.LanLift.CommuteWith f g h","decl":"theorem of_lanLift_comp_iso [HasLeftKanLift f g]\n    {x : B} {h : x ⟶ c} [HasLeftKanLift f (h ≫ g)]\n    (i : f₊ (h ≫ g) ≅ h ≫ f₊ g)\n    (w : lanLiftUnit f (h ≫ g) ≫ i.hom ▷ f = h ◁ lanLiftUnit f g ≫ (α_ _ _ _).inv) :\n    LanLift.CommuteWith f g h :=\n  ⟨⟨(lanLiftIsKan f (h ≫ g)).ofIsoKan <| StructuredArrow.isoMk i⟩⟩\n\n"}
{"name":"CategoryTheory.Bicategory.LanLift.CommuteWith.instHasLeftKanLiftComp","module":"Mathlib.CategoryTheory.Bicategory.Kan.HasKan","initialProofState":"B : Type u\ninst✝² : CategoryTheory.Bicategory B\na b c : B\nf : Quiver.Hom b a\ng : Quiver.Hom c a\ninst✝¹ : CategoryTheory.Bicategory.HasLeftKanLift f g\nx : B\nh : Quiver.Hom x c\ninst✝ : CategoryTheory.Bicategory.LanLift.CommuteWith f g h\n⊢ CategoryTheory.Bicategory.HasLeftKanLift f (CategoryTheory.CategoryStruct.comp h g)","decl":"instance : HasLeftKanLift f (h ≫ g) := (LanLift.CommuteWith.isKan f g h).hasLeftKanLift\n\n"}
{"name":"CategoryTheory.Bicategory.LanLift.CommuteWith.lanLiftCompIsoWhisker_hom_right","module":"Mathlib.CategoryTheory.Bicategory.Kan.HasKan","initialProofState":"B : Type u\ninst✝² : CategoryTheory.Bicategory B\na b c : B\nf : Quiver.Hom b a\ng : Quiver.Hom c a\ninst✝¹ : CategoryTheory.Bicategory.HasLeftKanLift f g\nx : B\nh : Quiver.Hom x c\ninst✝ : CategoryTheory.Bicategory.LanLift.CommuteWith f g h\n⊢ Eq (CategoryTheory.Bicategory.LanLift.CommuteWith.lanLiftCompIsoWhisker f g h).hom.right (CategoryTheory.Bicategory.lanLiftDesc ((CategoryTheory.Bicategory.lanLiftLeftLift f g).whisker h))","decl":"@[simp]\ntheorem lanLiftCompIsoWhisker_hom_right :\n    (lanLiftCompIsoWhisker f g h).hom.right = lanLiftDesc ((lanLiftLeftLift f g).whisker h) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Bicategory.LanLift.CommuteWith.lanLiftCompIsoWhisker_inv_right","module":"Mathlib.CategoryTheory.Bicategory.Kan.HasKan","initialProofState":"B : Type u\ninst✝² : CategoryTheory.Bicategory B\na b c : B\nf : Quiver.Hom b a\ng : Quiver.Hom c a\ninst✝¹ : CategoryTheory.Bicategory.HasLeftKanLift f g\nx : B\nh : Quiver.Hom x c\ninst✝ : CategoryTheory.Bicategory.LanLift.CommuteWith f g h\n⊢ Eq (CategoryTheory.Bicategory.LanLift.CommuteWith.lanLiftCompIsoWhisker f g h).inv.right ((CategoryTheory.Bicategory.LanLift.CommuteWith.isKan f g h).desc (CategoryTheory.Bicategory.lanLiftLeftLift f (CategoryTheory.CategoryStruct.comp h g)))","decl":"@[simp]\ntheorem lanLiftCompIsoWhisker_inv_right :\n    (lanLiftCompIsoWhisker f g h).inv.right = (isKan f g h).desc (lanLiftLeftLift f (h ≫ g)) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Bicategory.LanLift.CommuteWith.lanLiftCompIso_hom","module":"Mathlib.CategoryTheory.Bicategory.Kan.HasKan","initialProofState":"B : Type u\ninst✝² : CategoryTheory.Bicategory B\na b c : B\nf : Quiver.Hom b a\ng : Quiver.Hom c a\ninst✝¹ : CategoryTheory.Bicategory.HasLeftKanLift f g\nx : B\nh : Quiver.Hom x c\ninst✝ : CategoryTheory.Bicategory.LanLift.CommuteWith f g h\n⊢ Eq (CategoryTheory.Bicategory.LanLift.CommuteWith.lanLiftCompIso f g h).hom (CategoryTheory.Bicategory.lanLiftDesc ((CategoryTheory.Bicategory.lanLiftLeftLift f g).whisker h))","decl":"/-- The 1-morphism `h` commutes with the left Kan lift `f₊ g`. -/\n@[simps!]\ndef lanLiftCompIso : f₊ (h ≫ g) ≅ h ≫ f₊ g := Comma.rightIso <| lanLiftCompIsoWhisker f g h\n\n"}
{"name":"CategoryTheory.Bicategory.LanLift.CommuteWith.lanLiftCompIso_inv","module":"Mathlib.CategoryTheory.Bicategory.Kan.HasKan","initialProofState":"B : Type u\ninst✝² : CategoryTheory.Bicategory B\na b c : B\nf : Quiver.Hom b a\ng : Quiver.Hom c a\ninst✝¹ : CategoryTheory.Bicategory.HasLeftKanLift f g\nx : B\nh : Quiver.Hom x c\ninst✝ : CategoryTheory.Bicategory.LanLift.CommuteWith f g h\n⊢ Eq (CategoryTheory.Bicategory.LanLift.CommuteWith.lanLiftCompIso f g h).inv ((CategoryTheory.Bicategory.LanLift.CommuteWith.isKan f g h).desc (CategoryTheory.Bicategory.lanLiftLeftLift f (CategoryTheory.CategoryStruct.comp h g)))","decl":"/-- The 1-morphism `h` commutes with the left Kan lift `f₊ g`. -/\n@[simps!]\ndef lanLiftCompIso : f₊ (h ≫ g) ≅ h ≫ f₊ g := Comma.rightIso <| lanLiftCompIsoWhisker f g h\n\n"}
{"name":"CategoryTheory.Bicategory.HasAbsLeftKanLift.toHasLeftKanLift","module":"Mathlib.CategoryTheory.Bicategory.Kan.HasKan","initialProofState":"B : Type u\ninst✝ : CategoryTheory.Bicategory B\na b c : B\nf : Quiver.Hom b a\ng : Quiver.Hom c a\nself : CategoryTheory.Bicategory.HasAbsLeftKanLift f g\n⊢ CategoryTheory.Bicategory.HasLeftKanLift f g","decl":"/-- We say that there exists an absolute left Kan lift of `g` along `f` if any 1-morphism `h`\ncommutes with the left Kan lift `f₊ g`. -/\nclass HasAbsLeftKanLift (f : b ⟶ a) (g : c ⟶ a) extends HasLeftKanLift f g : Prop where\n  commute : ∀ {x : B} (h : x ⟶ c), LanLift.CommuteWith f g h\n\n"}
{"name":"CategoryTheory.Bicategory.HasAbsLeftKanLift.commute","module":"Mathlib.CategoryTheory.Bicategory.Kan.HasKan","initialProofState":"B : Type u\ninst✝ : CategoryTheory.Bicategory B\na b c : B\nf : Quiver.Hom b a\ng : Quiver.Hom c a\nself : CategoryTheory.Bicategory.HasAbsLeftKanLift f g\nx : B\nh : Quiver.Hom x c\n⊢ CategoryTheory.Bicategory.LanLift.CommuteWith f g h","decl":"/-- We say that there exists an absolute left Kan lift of `g` along `f` if any 1-morphism `h`\ncommutes with the left Kan lift `f₊ g`. -/\nclass HasAbsLeftKanLift (f : b ⟶ a) (g : c ⟶ a) extends HasLeftKanLift f g : Prop where\n  commute : ∀ {x : B} (h : x ⟶ c), LanLift.CommuteWith f g h\n\n"}
{"name":"CategoryTheory.Bicategory.instCommuteWith_1","module":"Mathlib.CategoryTheory.Bicategory.Kan.HasKan","initialProofState":"B : Type u\ninst✝¹ : CategoryTheory.Bicategory B\na b c : B\nf : Quiver.Hom b a\ng : Quiver.Hom c a\ninst✝ : CategoryTheory.Bicategory.HasAbsLeftKanLift f g\nx : B\nh : Quiver.Hom x c\n⊢ CategoryTheory.Bicategory.LanLift.CommuteWith f g h","decl":"instance [HasAbsLeftKanLift f g] {x : B} (h : x ⟶ c) : LanLift.CommuteWith f g h :=\n  HasAbsLeftKanLift.commute h\n\n"}
{"name":"CategoryTheory.Bicategory.LeftLift.IsAbsKan.hasAbsLeftKanLift","module":"Mathlib.CategoryTheory.Bicategory.Kan.HasKan","initialProofState":"B : Type u\ninst✝ : CategoryTheory.Bicategory B\na b c : B\nf : Quiver.Hom b a\ng : Quiver.Hom c a\nt : CategoryTheory.Bicategory.LeftLift f g\nH : t.IsAbsKan\n⊢ CategoryTheory.Bicategory.HasAbsLeftKanLift f g","decl":"theorem LeftLift.IsAbsKan.hasAbsLeftKanLift {t : LeftLift f g} (H : IsAbsKan t) :\n    HasAbsLeftKanLift f g :=\n  have : HasLeftKanLift f g := H.isKan.hasLeftKanLift\n  ⟨fun h ↦ ⟨⟨H.ofIsoAbsKan (IsKan.uniqueUpToIso H.isKan (lanLiftIsKan f g)) h⟩⟩⟩\n\n"}
