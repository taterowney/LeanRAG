{"name":"HNNExtension.t_mul_of","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B : Subgroup G\nφ : MulEquiv (Subtype fun x => Membership.mem A x) (Subtype fun x => Membership.mem B x)\na : Subtype fun x => Membership.mem A x\n⊢ Eq (HMul.hMul HNNExtension.t (HNNExtension.of ↑a)) (HMul.hMul (HNNExtension.of ↑(φ a)) HNNExtension.t)","decl":"theorem t_mul_of (a : A) :\n    t * (of (a : G) : HNNExtension G A B φ) = of (φ a : G) * t :=\n  (Con.eq _).2 <| ConGen.Rel.of _ _ <| ⟨a, by simp⟩\n\n"}
{"name":"HNNExtension.of_mul_t","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B : Subgroup G\nφ : MulEquiv (Subtype fun x => Membership.mem A x) (Subtype fun x => Membership.mem B x)\nb : Subtype fun x => Membership.mem B x\n⊢ Eq (HMul.hMul (HNNExtension.of ↑b) HNNExtension.t) (HMul.hMul HNNExtension.t (HNNExtension.of ↑(φ.symm b)))","decl":"theorem of_mul_t (b : B) :\n    (of (b : G) : HNNExtension G A B φ) * t = t * of (φ.symm b : G) := by\n  rw [t_mul_of]; simp\n\n"}
{"name":"HNNExtension.equiv_eq_conj","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B : Subgroup G\nφ : MulEquiv (Subtype fun x => Membership.mem A x) (Subtype fun x => Membership.mem B x)\na : Subtype fun x => Membership.mem A x\n⊢ Eq (HNNExtension.of ↑(φ a)) (HMul.hMul (HMul.hMul HNNExtension.t (HNNExtension.of ↑a)) (Inv.inv HNNExtension.t))","decl":"theorem equiv_eq_conj (a : A) :\n    (of (φ a : G) : HNNExtension G A B φ) = t * of (a : G) * t⁻¹ := by\n  rw [t_mul_of]; simp\n\n"}
{"name":"HNNExtension.equiv_symm_eq_conj","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B : Subgroup G\nφ : MulEquiv (Subtype fun x => Membership.mem A x) (Subtype fun x => Membership.mem B x)\nb : Subtype fun x => Membership.mem B x\n⊢ Eq (HNNExtension.of ↑(φ.symm b)) (HMul.hMul (HMul.hMul (Inv.inv HNNExtension.t) (HNNExtension.of ↑b)) HNNExtension.t)","decl":"theorem equiv_symm_eq_conj (b : B) :\n    (of (φ.symm b : G) : HNNExtension G A B φ) = t⁻¹ * of (b : G) * t := by\n  rw [mul_assoc, of_mul_t]; simp\n\n"}
{"name":"HNNExtension.inv_t_mul_of","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B : Subgroup G\nφ : MulEquiv (Subtype fun x => Membership.mem A x) (Subtype fun x => Membership.mem B x)\nb : Subtype fun x => Membership.mem B x\n⊢ Eq (HMul.hMul (Inv.inv HNNExtension.t) (HNNExtension.of ↑b)) (HMul.hMul (HNNExtension.of ↑(φ.symm b)) (Inv.inv HNNExtension.t))","decl":"theorem inv_t_mul_of (b : B) :\n    t⁻¹ * (of (b : G) : HNNExtension G A B φ) = of (φ.symm b : G) * t⁻¹ := by\n  rw [equiv_symm_eq_conj]; simp\n\n"}
{"name":"HNNExtension.of_mul_inv_t","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B : Subgroup G\nφ : MulEquiv (Subtype fun x => Membership.mem A x) (Subtype fun x => Membership.mem B x)\na : Subtype fun x => Membership.mem A x\n⊢ Eq (HMul.hMul (HNNExtension.of ↑a) (Inv.inv HNNExtension.t)) (HMul.hMul (Inv.inv HNNExtension.t) (HNNExtension.of ↑(φ a)))","decl":"theorem of_mul_inv_t (a : A) :\n    (of (a : G) : HNNExtension G A B φ) * t⁻¹ = t⁻¹ * of (φ a : G) := by\n  rw [equiv_eq_conj]; simp [mul_assoc]\n\n"}
{"name":"HNNExtension.lift_t","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nA B : Subgroup G\nφ : MulEquiv (Subtype fun x => Membership.mem A x) (Subtype fun x => Membership.mem B x)\nH : Type u_2\ninst✝ : Group H\nf : MonoidHom G H\nx : H\nhx : ∀ (a : Subtype fun x => Membership.mem A x), Eq (HMul.hMul x (f ↑a)) (HMul.hMul (f ↑(φ a)) x)\n⊢ Eq ((HNNExtension.lift f x hx) HNNExtension.t) x","decl":"@[simp]\ntheorem lift_t (f : G →* H) (x : H) (hx : ∀ a : A, x * f ↑a = f (φ a : G) * x) :\n    lift f x hx t = x := by\n  delta HNNExtension; simp [lift, t]\n\n"}
{"name":"HNNExtension.lift_of","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nA B : Subgroup G\nφ : MulEquiv (Subtype fun x => Membership.mem A x) (Subtype fun x => Membership.mem B x)\nH : Type u_2\ninst✝ : Group H\nf : MonoidHom G H\nx : H\nhx : ∀ (a : Subtype fun x => Membership.mem A x), Eq (HMul.hMul x (f ↑a)) (HMul.hMul (f ↑(φ a)) x)\ng : G\n⊢ Eq ((HNNExtension.lift f x hx) (HNNExtension.of g)) (f g)","decl":"@[simp]\ntheorem lift_of (f : G →* H) (x : H) (hx : ∀ a : A, x * f ↑a = f (φ a : G) * x) (g : G) :\n    lift f x hx (of g) = f g := by\n  delta HNNExtension; simp [lift, of]\n\n"}
{"name":"HNNExtension.hom_ext_iff","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nA B : Subgroup G\nφ : MulEquiv (Subtype fun x => Membership.mem A x) (Subtype fun x => Membership.mem B x)\nM : Type u_3\ninst✝ : Monoid M\nf g : MonoidHom (HNNExtension G A B φ) M\n⊢ Iff (Eq f g) (And (Eq (f.comp HNNExtension.of) (g.comp HNNExtension.of)) (Eq (f HNNExtension.t) (g HNNExtension.t)))","decl":"@[ext high]\ntheorem hom_ext {f g : HNNExtension G A B φ →* M}\n    (hg : f.comp of = g.comp of) (ht : f t = g t) : f = g :=\n  (MonoidHom.cancel_right Con.mk'_surjective).mp <|\n    Coprod.hom_ext hg (MonoidHom.ext_mint ht)\n\n"}
{"name":"HNNExtension.hom_ext","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nA B : Subgroup G\nφ : MulEquiv (Subtype fun x => Membership.mem A x) (Subtype fun x => Membership.mem B x)\nM : Type u_3\ninst✝ : Monoid M\nf g : MonoidHom (HNNExtension G A B φ) M\nhg : Eq (f.comp HNNExtension.of) (g.comp HNNExtension.of)\nht : Eq (f HNNExtension.t) (g HNNExtension.t)\n⊢ Eq f g","decl":"@[ext high]\ntheorem hom_ext {f g : HNNExtension G A B φ →* M}\n    (hg : f.comp of = g.comp of) (ht : f t = g t) : f = g :=\n  (MonoidHom.cancel_right Con.mk'_surjective).mp <|\n    Coprod.hom_ext hg (MonoidHom.ext_mint ht)\n\n"}
{"name":"HNNExtension.induction_on","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B : Subgroup G\nφ : MulEquiv (Subtype fun x => Membership.mem A x) (Subtype fun x => Membership.mem B x)\nmotive : HNNExtension G A B φ → Prop\nx : HNNExtension G A B φ\nof : ∀ (g : G), motive (HNNExtension.of g)\nt : motive HNNExtension.t\nmul : ∀ (x y : HNNExtension G A B φ), motive x → motive y → motive (HMul.hMul x y)\ninv : ∀ (x : HNNExtension G A B φ), motive x → motive (Inv.inv x)\n⊢ motive x","decl":"@[elab_as_elim]\ntheorem induction_on {motive : HNNExtension G A B φ → Prop}\n    (x : HNNExtension G A B φ) (of : ∀ g, motive (of g))\n    (t : motive t) (mul : ∀ x y, motive x → motive y → motive (x * y))\n    (inv : ∀ x, motive x → motive x⁻¹) : motive x := by\n  let S : Subgroup (HNNExtension G A B φ) :=\n    { carrier := setOf motive\n      one_mem' := by simpa using of 1\n      mul_mem' := mul _ _\n      inv_mem' := inv _ }\n  let f : HNNExtension G A B φ →* S :=\n    lift (HNNExtension.of.codRestrict S of)\n      ⟨HNNExtension.t, t⟩ (by intro a; ext; simp [equiv_eq_conj, mul_assoc])\n  have hf : S.subtype.comp f = MonoidHom.id _ :=\n    hom_ext (by ext; simp [f]) (by simp [f])\n  show motive (MonoidHom.id _ x)\n  rw [← hf]\n  exact (f x).2\n\n"}
{"name":"HNNExtension.toSubgroup_one","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B : Subgroup G\n⊢ Eq (HNNExtension.toSubgroup A B 1) A","decl":"@[simp]\ntheorem toSubgroup_one : toSubgroup A B 1 = A := rfl\n\n"}
{"name":"HNNExtension.toSubgroup_neg_one","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B : Subgroup G\n⊢ Eq (HNNExtension.toSubgroup A B (-1)) B","decl":"@[simp]\ntheorem toSubgroup_neg_one : toSubgroup A B (-1) = B := rfl\n\n"}
{"name":"HNNExtension.toSubgroupEquiv_one","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B : Subgroup G\nφ : MulEquiv (Subtype fun x => Membership.mem A x) (Subtype fun x => Membership.mem B x)\n⊢ Eq (HNNExtension.toSubgroupEquiv φ 1) φ","decl":"@[simp]\ntheorem toSubgroupEquiv_one : toSubgroupEquiv φ 1 = φ := rfl\n\n"}
{"name":"HNNExtension.toSubgroupEquiv_neg_one","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B : Subgroup G\nφ : MulEquiv (Subtype fun x => Membership.mem A x) (Subtype fun x => Membership.mem B x)\n⊢ Eq (HNNExtension.toSubgroupEquiv φ (-1)) φ.symm","decl":"@[simp]\ntheorem toSubgroupEquiv_neg_one : toSubgroupEquiv φ (-1) = φ.symm := rfl\n\n"}
{"name":"HNNExtension.toSubgroupEquiv_neg_apply","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B : Subgroup G\nφ : MulEquiv (Subtype fun x => Membership.mem A x) (Subtype fun x => Membership.mem B x)\nu : Units Int\na : Subtype fun x => Membership.mem (HNNExtension.toSubgroup A B u) x\n⊢ Eq ↑((HNNExtension.toSubgroupEquiv φ (Neg.neg u)) ((HNNExtension.toSubgroupEquiv φ u) a)) ↑a","decl":"@[simp]\ntheorem toSubgroupEquiv_neg_apply (u : ℤˣ) (a : toSubgroup A B u) :\n    (toSubgroupEquiv φ (-u) (toSubgroupEquiv φ u a) : G) = a := by\n  rcases Int.units_eq_one_or u with rfl | rfl\n  · -- This used to be `simp` before https://github.com/leanprover/lean4/pull/2644\n    simp; erw [MulEquiv.symm_apply_apply]\n  · simp only [toSubgroup_neg_one, toSubgroupEquiv_neg_one, SetLike.coe_eq_coe]\n    exact φ.apply_symm_apply a\n\n"}
{"name":"HNNExtension.NormalWord.TransversalPair.compl","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B : Subgroup G\nself : HNNExtension.NormalWord.TransversalPair G A B\nu : Units Int\n⊢ Subgroup.IsComplement (↑(HNNExtension.toSubgroup A B u)) (self.set u)","decl":"/-- To put word in the HNN Extension into a normal form, we must choose an element of each right\ncoset of both `A` and `B`, such that the chosen element of the subgroup itself is `1`. -/\nstructure TransversalPair : Type _ where\n  /-- The transversal of each subgroup -/\n  set : ℤˣ → Set G\n  /-- We have exactly one element of each coset of the subgroup -/\n  compl : ∀ u, IsComplement (toSubgroup A B u : Subgroup G) (set u)\n\n"}
{"name":"HNNExtension.NormalWord.TransversalPair.mk.injEq","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B : Subgroup G\nset✝ : Units Int → Set G\ncompl✝ : ∀ (u : Units Int), Subgroup.IsComplement (↑(HNNExtension.toSubgroup A B u)) (set✝ u)\nset : Units Int → Set G\ncompl : ∀ (u : Units Int), Subgroup.IsComplement (↑(HNNExtension.toSubgroup A B u)) (set u)\n⊢ Eq (Eq { set := set✝, compl := compl✝ } { set := set, compl := compl }) (Eq set✝ set)","decl":"/-- To put word in the HNN Extension into a normal form, we must choose an element of each right\ncoset of both `A` and `B`, such that the chosen element of the subgroup itself is `1`. -/\nstructure TransversalPair : Type _ where\n  /-- The transversal of each subgroup -/\n  set : ℤˣ → Set G\n  /-- We have exactly one element of each coset of the subgroup -/\n  compl : ∀ u, IsComplement (toSubgroup A B u : Subgroup G) (set u)\n\n"}
{"name":"HNNExtension.NormalWord.TransversalPair.mk.sizeOf_spec","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nA B : Subgroup G\ninst✝ : SizeOf G\nset : Units Int → Set G\ncompl : ∀ (u : Units Int), Subgroup.IsComplement (↑(HNNExtension.toSubgroup A B u)) (set u)\n⊢ Eq (SizeOf.sizeOf { set := set, compl := compl }) 1","decl":"/-- To put word in the HNN Extension into a normal form, we must choose an element of each right\ncoset of both `A` and `B`, such that the chosen element of the subgroup itself is `1`. -/\nstructure TransversalPair : Type _ where\n  /-- The transversal of each subgroup -/\n  set : ℤˣ → Set G\n  /-- We have exactly one element of each coset of the subgroup -/\n  compl : ∀ u, IsComplement (toSubgroup A B u : Subgroup G) (set u)\n\n"}
{"name":"HNNExtension.NormalWord.TransversalPair.mk.inj","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B : Subgroup G\nset✝ : Units Int → Set G\ncompl✝ : ∀ (u : Units Int), Subgroup.IsComplement (↑(HNNExtension.toSubgroup A B u)) (set✝ u)\nset : Units Int → Set G\ncompl : ∀ (u : Units Int), Subgroup.IsComplement (↑(HNNExtension.toSubgroup A B u)) (set u)\nx✝ : Eq { set := set✝, compl := compl✝ } { set := set, compl := compl }\n⊢ Eq set✝ set","decl":"/-- To put word in the HNN Extension into a normal form, we must choose an element of each right\ncoset of both `A` and `B`, such that the chosen element of the subgroup itself is `1`. -/\nstructure TransversalPair : Type _ where\n  /-- The transversal of each subgroup -/\n  set : ℤˣ → Set G\n  /-- We have exactly one element of each coset of the subgroup -/\n  compl : ∀ u, IsComplement (toSubgroup A B u : Subgroup G) (set u)\n\n"}
{"name":"HNNExtension.NormalWord.TransversalPair.nonempty","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B : Subgroup G\n⊢ Nonempty (HNNExtension.NormalWord.TransversalPair G A B)","decl":"instance TransversalPair.nonempty : Nonempty (TransversalPair G A B) := by\n  choose t ht using fun u ↦ (toSubgroup A B u).exists_isComplement_right 1\n  exact ⟨⟨t, fun i ↦ (ht i).1⟩⟩\n\n"}
{"name":"HNNExtension.NormalWord.ReducedWord.mk.sizeOf_spec","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nA B : Subgroup G\ninst✝ : SizeOf G\nhead : G\ntoList : List (Prod (Units Int) G)\nchain : List.Chain' (fun a b => Membership.mem (HNNExtension.toSubgroup A B a.1) a.2 → Eq a.1 b.1) toList\n⊢ Eq (SizeOf.sizeOf { head := head, toList := toList, chain := chain }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf head)) (SizeOf.sizeOf toList)) (SizeOf.sizeOf chain))","decl":"/-- A reduced word is a `head`, which is an element of `G`, followed by the product list of pairs.\nThere should also be no sequences of the form `t^u * g * t^-u`, where `g` is in\n`toSubgroup A B u` This is a less strict condition than required for `NormalWord`. -/\nstructure ReducedWord : Type _ where\n  /-- Every `ReducedWord` is the product of an element of the group and a word made up\n  of letters each of which is in the transversal. `head` is that element of the base group. -/\n  head : G\n  /-- The list of pairs `(ℤˣ × G)`, where each pair `(u, g)` represents the element `t^u * g` of\n  `HNNExtension G A B φ` -/\n  toList : List (ℤˣ × G)\n  /-- There are no sequences of the form `t^u * g * t^-u` where `g ∈ toSubgroup A B u` -/\n  chain : toList.Chain' (fun a b => a.2 ∈ toSubgroup A B a.1 → a.1 = b.1)\n\n"}
{"name":"HNNExtension.NormalWord.ReducedWord.mk.injEq","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B : Subgroup G\nhead✝ : G\ntoList✝ : List (Prod (Units Int) G)\nchain✝ : List.Chain' (fun a b => Membership.mem (HNNExtension.toSubgroup A B a.1) a.2 → Eq a.1 b.1) toList✝\nhead : G\ntoList : List (Prod (Units Int) G)\nchain : List.Chain' (fun a b => Membership.mem (HNNExtension.toSubgroup A B a.1) a.2 → Eq a.1 b.1) toList\n⊢ Eq (Eq { head := head✝, toList := toList✝, chain := chain✝ } { head := head, toList := toList, chain := chain }) (And (Eq head✝ head) (Eq toList✝ toList))","decl":"/-- A reduced word is a `head`, which is an element of `G`, followed by the product list of pairs.\nThere should also be no sequences of the form `t^u * g * t^-u`, where `g` is in\n`toSubgroup A B u` This is a less strict condition than required for `NormalWord`. -/\nstructure ReducedWord : Type _ where\n  /-- Every `ReducedWord` is the product of an element of the group and a word made up\n  of letters each of which is in the transversal. `head` is that element of the base group. -/\n  head : G\n  /-- The list of pairs `(ℤˣ × G)`, where each pair `(u, g)` represents the element `t^u * g` of\n  `HNNExtension G A B φ` -/\n  toList : List (ℤˣ × G)\n  /-- There are no sequences of the form `t^u * g * t^-u` where `g ∈ toSubgroup A B u` -/\n  chain : toList.Chain' (fun a b => a.2 ∈ toSubgroup A B a.1 → a.1 = b.1)\n\n"}
{"name":"HNNExtension.NormalWord.ReducedWord.chain","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B : Subgroup G\nself : HNNExtension.NormalWord.ReducedWord G A B\n⊢ List.Chain' (fun a b => Membership.mem (HNNExtension.toSubgroup A B a.1) a.2 → Eq a.1 b.1) self.toList","decl":"/-- A reduced word is a `head`, which is an element of `G`, followed by the product list of pairs.\nThere should also be no sequences of the form `t^u * g * t^-u`, where `g` is in\n`toSubgroup A B u` This is a less strict condition than required for `NormalWord`. -/\nstructure ReducedWord : Type _ where\n  /-- Every `ReducedWord` is the product of an element of the group and a word made up\n  of letters each of which is in the transversal. `head` is that element of the base group. -/\n  head : G\n  /-- The list of pairs `(ℤˣ × G)`, where each pair `(u, g)` represents the element `t^u * g` of\n  `HNNExtension G A B φ` -/\n  toList : List (ℤˣ × G)\n  /-- There are no sequences of the form `t^u * g * t^-u` where `g ∈ toSubgroup A B u` -/\n  chain : toList.Chain' (fun a b => a.2 ∈ toSubgroup A B a.1 → a.1 = b.1)\n\n"}
{"name":"HNNExtension.NormalWord.ReducedWord.mk.inj","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B : Subgroup G\nhead✝ : G\ntoList✝ : List (Prod (Units Int) G)\nchain✝ : List.Chain' (fun a b => Membership.mem (HNNExtension.toSubgroup A B a.1) a.2 → Eq a.1 b.1) toList✝\nhead : G\ntoList : List (Prod (Units Int) G)\nchain : List.Chain' (fun a b => Membership.mem (HNNExtension.toSubgroup A B a.1) a.2 → Eq a.1 b.1) toList\nx✝ : Eq { head := head✝, toList := toList✝, chain := chain✝ } { head := head, toList := toList, chain := chain }\n⊢ And (Eq head✝ head) (Eq toList✝ toList)","decl":"/-- A reduced word is a `head`, which is an element of `G`, followed by the product list of pairs.\nThere should also be no sequences of the form `t^u * g * t^-u`, where `g` is in\n`toSubgroup A B u` This is a less strict condition than required for `NormalWord`. -/\nstructure ReducedWord : Type _ where\n  /-- Every `ReducedWord` is the product of an element of the group and a word made up\n  of letters each of which is in the transversal. `head` is that element of the base group. -/\n  head : G\n  /-- The list of pairs `(ℤˣ × G)`, where each pair `(u, g)` represents the element `t^u * g` of\n  `HNNExtension G A B φ` -/\n  toList : List (ℤˣ × G)\n  /-- There are no sequences of the form `t^u * g * t^-u` where `g ∈ toSubgroup A B u` -/\n  chain : toList.Chain' (fun a b => a.2 ∈ toSubgroup A B a.1 → a.1 = b.1)\n\n"}
{"name":"HNNExtension.NormalWord.ReducedWord.empty_head","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B : Subgroup G\n⊢ Eq (HNNExtension.NormalWord.ReducedWord.empty G A B).head 1","decl":"/-- The empty reduced word. -/\n@[simps]\ndef ReducedWord.empty : ReducedWord G A B :=\n  { head := 1\n    toList := []\n    chain := List.chain'_nil }\n\n"}
{"name":"HNNExtension.NormalWord.ReducedWord.empty_toList","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B : Subgroup G\n⊢ Eq (HNNExtension.NormalWord.ReducedWord.empty G A B).toList List.nil","decl":"/-- The empty reduced word. -/\n@[simps]\ndef ReducedWord.empty : ReducedWord G A B :=\n  { head := 1\n    toList := []\n    chain := List.chain'_nil }\n\n"}
{"name":"HNNExtension.NormalWord.mk.sizeOf_spec","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nA B : Subgroup G\nd : HNNExtension.NormalWord.TransversalPair G A B\ninst✝ : SizeOf G\ntoReducedWord : HNNExtension.NormalWord.ReducedWord G A B\nmem_set : ∀ (u : Units Int) (g : G), Membership.mem toReducedWord.toList { fst := u, snd := g } → Membership.mem (d.set u) g\n⊢ Eq (SizeOf.sizeOf { toReducedWord := toReducedWord, mem_set := mem_set }) (HAdd.hAdd 1 (SizeOf.sizeOf toReducedWord))","decl":"/-- Given a `TransversalPair`, we can make a normal form for words in the `HNNExtension G A B φ`.\nThe normal form is a `head`, which is an element of `G`, followed by the product list of pairs,\n`t ^ u * g`, where `u` is `1` or `-1` and `g` is the chosen element of its right coset of\n`toSubgroup A B u`. There should also be no sequences of the form `t^u * g * t^-u`\nwhere `g ∈ toSubgroup A B u` -/\nstructure _root_.HNNExtension.NormalWord (d : TransversalPair G A B)\n    extends ReducedWord G A B : Type _ where\n  /-- Every element `g : G` in the list is the chosen element of its coset -/\n  mem_set : ∀ (u : ℤˣ) (g : G), (u, g) ∈ toList → g ∈ d.set u\n\n"}
{"name":"HNNExtension.NormalWord.mem_set","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B : Subgroup G\nd : HNNExtension.NormalWord.TransversalPair G A B\nself : HNNExtension.NormalWord d\nu : Units Int\ng : G\na✝ : Membership.mem self.toList { fst := u, snd := g }\n⊢ Membership.mem (d.set u) g","decl":"/-- Given a `TransversalPair`, we can make a normal form for words in the `HNNExtension G A B φ`.\nThe normal form is a `head`, which is an element of `G`, followed by the product list of pairs,\n`t ^ u * g`, where `u` is `1` or `-1` and `g` is the chosen element of its right coset of\n`toSubgroup A B u`. There should also be no sequences of the form `t^u * g * t^-u`\nwhere `g ∈ toSubgroup A B u` -/\nstructure _root_.HNNExtension.NormalWord (d : TransversalPair G A B)\n    extends ReducedWord G A B : Type _ where\n  /-- Every element `g : G` in the list is the chosen element of its coset -/\n  mem_set : ∀ (u : ℤˣ) (g : G), (u, g) ∈ toList → g ∈ d.set u\n\n"}
{"name":"HNNExtension.NormalWord.mk.inj","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B : Subgroup G\nd : HNNExtension.NormalWord.TransversalPair G A B\ntoReducedWord✝ : HNNExtension.NormalWord.ReducedWord G A B\nmem_set✝ : ∀ (u : Units Int) (g : G), Membership.mem toReducedWord✝.toList { fst := u, snd := g } → Membership.mem (d.set u) g\ntoReducedWord : HNNExtension.NormalWord.ReducedWord G A B\nmem_set : ∀ (u : Units Int) (g : G), Membership.mem toReducedWord.toList { fst := u, snd := g } → Membership.mem (d.set u) g\nx✝ : Eq { toReducedWord := toReducedWord✝, mem_set := mem_set✝ } { toReducedWord := toReducedWord, mem_set := mem_set }\n⊢ Eq toReducedWord✝ toReducedWord","decl":"/-- Given a `TransversalPair`, we can make a normal form for words in the `HNNExtension G A B φ`.\nThe normal form is a `head`, which is an element of `G`, followed by the product list of pairs,\n`t ^ u * g`, where `u` is `1` or `-1` and `g` is the chosen element of its right coset of\n`toSubgroup A B u`. There should also be no sequences of the form `t^u * g * t^-u`\nwhere `g ∈ toSubgroup A B u` -/\nstructure _root_.HNNExtension.NormalWord (d : TransversalPair G A B)\n    extends ReducedWord G A B : Type _ where\n  /-- Every element `g : G` in the list is the chosen element of its coset -/\n  mem_set : ∀ (u : ℤˣ) (g : G), (u, g) ∈ toList → g ∈ d.set u\n\n"}
{"name":"HNNExtension.NormalWord.mk.injEq","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B : Subgroup G\nd : HNNExtension.NormalWord.TransversalPair G A B\ntoReducedWord✝ : HNNExtension.NormalWord.ReducedWord G A B\nmem_set✝ : ∀ (u : Units Int) (g : G), Membership.mem toReducedWord✝.toList { fst := u, snd := g } → Membership.mem (d.set u) g\ntoReducedWord : HNNExtension.NormalWord.ReducedWord G A B\nmem_set : ∀ (u : Units Int) (g : G), Membership.mem toReducedWord.toList { fst := u, snd := g } → Membership.mem (d.set u) g\n⊢ Eq (Eq { toReducedWord := toReducedWord✝, mem_set := mem_set✝ } { toReducedWord := toReducedWord, mem_set := mem_set }) (Eq toReducedWord✝ toReducedWord)","decl":"/-- Given a `TransversalPair`, we can make a normal form for words in the `HNNExtension G A B φ`.\nThe normal form is a `head`, which is an element of `G`, followed by the product list of pairs,\n`t ^ u * g`, where `u` is `1` or `-1` and `g` is the chosen element of its right coset of\n`toSubgroup A B u`. There should also be no sequences of the form `t^u * g * t^-u`\nwhere `g ∈ toSubgroup A B u` -/\nstructure _root_.HNNExtension.NormalWord (d : TransversalPair G A B)\n    extends ReducedWord G A B : Type _ where\n  /-- Every element `g : G` in the list is the chosen element of its coset -/\n  mem_set : ∀ (u : ℤˣ) (g : G), (u, g) ∈ toList → g ∈ d.set u\n\n"}
{"name":"HNNExtension.NormalWord.ext_iff","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B : Subgroup G\nd : HNNExtension.NormalWord.TransversalPair G A B\nw w' : HNNExtension.NormalWord d\n⊢ Iff (Eq w w') (And (Eq w.head w'.head) (Eq w.toList w'.toList))","decl":"@[ext]\ntheorem ext {w w' : NormalWord d}\n    (h1 : w.head = w'.head) (h2 : w.toList = w'.toList) : w = w' := by\n  rcases w with ⟨⟨⟩, _⟩; cases w'; simp_all\n\n"}
{"name":"HNNExtension.NormalWord.ext","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B : Subgroup G\nd : HNNExtension.NormalWord.TransversalPair G A B\nw w' : HNNExtension.NormalWord d\nh1 : Eq w.head w'.head\nh2 : Eq w.toList w'.toList\n⊢ Eq w w'","decl":"@[ext]\ntheorem ext {w w' : NormalWord d}\n    (h1 : w.head = w'.head) (h2 : w.toList = w'.toList) : w = w' := by\n  rcases w with ⟨⟨⟩, _⟩; cases w'; simp_all\n\n"}
{"name":"HNNExtension.NormalWord.empty_head","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B : Subgroup G\nd : HNNExtension.NormalWord.TransversalPair G A B\n⊢ Eq HNNExtension.NormalWord.empty.head 1","decl":"/-- The empty word -/\n@[simps]\ndef empty : NormalWord d :=\n  { head := 1\n    toList := []\n    mem_set := by simp\n    chain := List.chain'_nil }\n\n"}
{"name":"HNNExtension.NormalWord.empty_toList","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B : Subgroup G\nd : HNNExtension.NormalWord.TransversalPair G A B\n⊢ Eq HNNExtension.NormalWord.empty.toList List.nil","decl":"/-- The empty word -/\n@[simps]\ndef empty : NormalWord d :=\n  { head := 1\n    toList := []\n    mem_set := by simp\n    chain := List.chain'_nil }\n\n"}
{"name":"HNNExtension.NormalWord.ofGroup_toList","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B : Subgroup G\nd : HNNExtension.NormalWord.TransversalPair G A B\ng : G\n⊢ Eq (HNNExtension.NormalWord.ofGroup g).toList List.nil","decl":"/-- The `NormalWord` representing an element `g` of the group `G`, which is just the element `g`\nitself. -/\n@[simps]\ndef ofGroup (g : G) : NormalWord d :=\n  { head := g\n    toList := []\n    mem_set := by simp\n    chain := List.chain'_nil }\n\n"}
{"name":"HNNExtension.NormalWord.ofGroup_head","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B : Subgroup G\nd : HNNExtension.NormalWord.TransversalPair G A B\ng : G\n⊢ Eq (HNNExtension.NormalWord.ofGroup g).head g","decl":"/-- The `NormalWord` representing an element `g` of the group `G`, which is just the element `g`\nitself. -/\n@[simps]\ndef ofGroup (g : G) : NormalWord d :=\n  { head := g\n    toList := []\n    mem_set := by simp\n    chain := List.chain'_nil }\n\n"}
{"name":"HNNExtension.NormalWord.group_smul_def","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B : Subgroup G\nd : HNNExtension.NormalWord.TransversalPair G A B\ng : G\nw : HNNExtension.NormalWord d\n⊢ Eq (HSMul.hSMul g w) { head := HMul.hMul g w.head, toList := w.toList, chain := ⋯, mem_set := ⋯ }","decl":"theorem group_smul_def (g : G) (w : NormalWord d) :\n    g • w = { w with head := g * w.head } := rfl\n\n"}
{"name":"HNNExtension.NormalWord.group_smul_head","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B : Subgroup G\nd : HNNExtension.NormalWord.TransversalPair G A B\ng : G\nw : HNNExtension.NormalWord d\n⊢ Eq (HSMul.hSMul g w).head (HMul.hMul g w.head)","decl":"@[simp]\ntheorem group_smul_head (g : G) (w : NormalWord d) : (g • w).head = g * w.head := rfl\n\n"}
{"name":"HNNExtension.NormalWord.group_smul_toList","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B : Subgroup G\nd : HNNExtension.NormalWord.TransversalPair G A B\ng : G\nw : HNNExtension.NormalWord d\n⊢ Eq (HSMul.hSMul g w).toList w.toList","decl":"@[simp]\ntheorem group_smul_toList (g : G) (w : NormalWord d) : (g • w).toList = w.toList := rfl\n\n"}
{"name":"HNNExtension.NormalWord.instFaithfulSMul","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B : Subgroup G\nd : HNNExtension.NormalWord.TransversalPair G A B\n⊢ FaithfulSMul G (HNNExtension.NormalWord d)","decl":"instance : FaithfulSMul G (NormalWord d) := ⟨by simp [group_smul_def]⟩\n\n"}
{"name":"HNNExtension.NormalWord.cons_toList","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B : Subgroup G\nd : HNNExtension.NormalWord.TransversalPair G A B\ng : G\nu : Units Int\nw : HNNExtension.NormalWord d\nh1 : Membership.mem (d.set u) w.head\nh2 : ∀ (u' : Units Int), Membership.mem (Option.map Prod.fst w.toList.head?) u' → Membership.mem (HNNExtension.toSubgroup A B u) w.head → Eq u u'\n⊢ Eq (HNNExtension.NormalWord.cons g u w h1 h2).toList (List.cons { fst := u, snd := w.head } w.toList)","decl":"/-- A constructor to append an element `g` of `G` and `u : ℤˣ` to a word `w` with sufficient\nhypotheses that no normalization or cancellation need take place for the result to be in normal form\n-/\n@[simps]\ndef cons (g : G) (u : ℤˣ) (w : NormalWord d) (h1 : w.head ∈ d.set u)\n    (h2 : ∀ u' ∈ Option.map Prod.fst w.toList.head?, w.head ∈ toSubgroup A B u → u = u') :\n    NormalWord d :=\n  { head := g,\n    toList := (u, w.head) :: w.toList,\n    mem_set := by\n      intro u' g' h'\n      simp only [List.mem_cons, Prod.mk.injEq] at h'\n      rcases h' with ⟨rfl, rfl⟩ | h'\n      · exact h1\n      · exact w.mem_set _ _ h'\n    chain := by\n      refine List.chain'_cons'.2 ⟨?_, w.chain⟩\n      rintro ⟨u', g'⟩ hu' hw1\n      exact h2 _ (by simp_all) hw1 }\n\n"}
{"name":"HNNExtension.NormalWord.cons_head","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B : Subgroup G\nd : HNNExtension.NormalWord.TransversalPair G A B\ng : G\nu : Units Int\nw : HNNExtension.NormalWord d\nh1 : Membership.mem (d.set u) w.head\nh2 : ∀ (u' : Units Int), Membership.mem (Option.map Prod.fst w.toList.head?) u' → Membership.mem (HNNExtension.toSubgroup A B u) w.head → Eq u u'\n⊢ Eq (HNNExtension.NormalWord.cons g u w h1 h2).head g","decl":"/-- A constructor to append an element `g` of `G` and `u : ℤˣ` to a word `w` with sufficient\nhypotheses that no normalization or cancellation need take place for the result to be in normal form\n-/\n@[simps]\ndef cons (g : G) (u : ℤˣ) (w : NormalWord d) (h1 : w.head ∈ d.set u)\n    (h2 : ∀ u' ∈ Option.map Prod.fst w.toList.head?, w.head ∈ toSubgroup A B u → u = u') :\n    NormalWord d :=\n  { head := g,\n    toList := (u, w.head) :: w.toList,\n    mem_set := by\n      intro u' g' h'\n      simp only [List.mem_cons, Prod.mk.injEq] at h'\n      rcases h' with ⟨rfl, rfl⟩ | h'\n      · exact h1\n      · exact w.mem_set _ _ h'\n    chain := by\n      refine List.chain'_cons'.2 ⟨?_, w.chain⟩\n      rintro ⟨u', g'⟩ hu' hw1\n      exact h2 _ (by simp_all) hw1 }\n\n"}
{"name":"HNNExtension.NormalWord.consRecOn_ofGroup","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B : Subgroup G\nd : HNNExtension.NormalWord.TransversalPair G A B\nmotive : HNNExtension.NormalWord d → Sort u_4\ng : G\nofGroup : (g : G) → motive (HNNExtension.NormalWord.ofGroup g)\ncons : (g : G) → (u : Units Int) → (w : HNNExtension.NormalWord d) → (h1 : Membership.mem (d.set u) w.head) → (h2 : ∀ (u' : Units Int), Membership.mem (Option.map Prod.fst w.toList.head?) u' → Membership.mem (HNNExtension.toSubgroup A B u) w.head → Eq u u') → motive w → motive (HNNExtension.NormalWord.cons g u w h1 h2)\n⊢ Eq (HNNExtension.NormalWord.consRecOn (HNNExtension.NormalWord.ofGroup g) ofGroup cons) (ofGroup g)","decl":"@[simp]\ntheorem consRecOn_ofGroup {motive : NormalWord d → Sort*}\n    (g : G) (ofGroup : ∀g, motive (ofGroup g))\n    (cons : ∀ (g : G) (u : ℤˣ) (w : NormalWord d) (h1 : w.head ∈ d.set u)\n      (h2 : ∀ u' ∈ Option.map Prod.fst w.toList.head?, w.head\n        ∈ toSubgroup A B u → u = u'),\n      motive w → motive (cons g u w h1 h2)) :\n    consRecOn (.ofGroup g) ofGroup cons = ofGroup g := rfl\n\n"}
{"name":"HNNExtension.NormalWord.consRecOn_cons","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B : Subgroup G\nd : HNNExtension.NormalWord.TransversalPair G A B\nmotive : HNNExtension.NormalWord d → Sort u_4\ng : G\nu : Units Int\nw : HNNExtension.NormalWord d\nh1 : Membership.mem (d.set u) w.head\nh2 : ∀ (u' : Units Int), Membership.mem (Option.map Prod.fst w.toList.head?) u' → Membership.mem (HNNExtension.toSubgroup A B u) w.head → Eq u u'\nofGroup : (g : G) → motive (HNNExtension.NormalWord.ofGroup g)\ncons : (g : G) → (u : Units Int) → (w : HNNExtension.NormalWord d) → (h1 : Membership.mem (d.set u) w.head) → (h2 : ∀ (u' : Units Int), Membership.mem (Option.map Prod.fst w.toList.head?) u' → Membership.mem (HNNExtension.toSubgroup A B u) w.head → Eq u u') → motive w → motive (HNNExtension.NormalWord.cons g u w h1 h2)\n⊢ Eq (HNNExtension.NormalWord.consRecOn (HNNExtension.NormalWord.cons g u w h1 h2) ofGroup cons) (cons g u w h1 h2 (HNNExtension.NormalWord.consRecOn w ofGroup cons))","decl":"@[simp]\ntheorem consRecOn_cons {motive : NormalWord d → Sort*}\n    (g : G) (u : ℤˣ) (w : NormalWord d) (h1 : w.head ∈ d.set u)\n    (h2 : ∀ u' ∈ Option.map Prod.fst w.toList.head?, w.head ∈ toSubgroup A B u → u = u')\n    (ofGroup : ∀g, motive (ofGroup g))\n    (cons : ∀ (g : G) (u : ℤˣ) (w : NormalWord d) (h1 : w.head ∈ d.set u)\n      (h2 : ∀ u' ∈ Option.map Prod.fst w.toList.head?,\n        w.head ∈ toSubgroup A B u → u = u'),\n      motive w → motive (cons g u w h1 h2)) :\n    consRecOn (.cons g u w h1 h2) ofGroup cons = cons g u w h1 h2\n      (consRecOn w ofGroup cons) := rfl\n\n"}
{"name":"HNNExtension.NormalWord.smul_cons","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B : Subgroup G\nd : HNNExtension.NormalWord.TransversalPair G A B\ng₁ g₂ : G\nu : Units Int\nw : HNNExtension.NormalWord d\nh1 : Membership.mem (d.set u) w.head\nh2 : ∀ (u' : Units Int), Membership.mem (Option.map Prod.fst w.toList.head?) u' → Membership.mem (HNNExtension.toSubgroup A B u) w.head → Eq u u'\n⊢ Eq (HSMul.hSMul g₁ (HNNExtension.NormalWord.cons g₂ u w h1 h2)) (HNNExtension.NormalWord.cons (HMul.hMul g₁ g₂) u w h1 h2)","decl":"@[simp]\ntheorem smul_cons (g₁ g₂ : G) (u : ℤˣ) (w : NormalWord d) (h1 : w.head ∈ d.set u)\n    (h2 : ∀ u' ∈ Option.map Prod.fst w.toList.head?, w.head ∈ toSubgroup A B u → u = u') :\n    g₁ • cons g₂ u w h1 h2 = cons (g₁ * g₂) u w h1 h2 :=\n  rfl\n\n"}
{"name":"HNNExtension.NormalWord.smul_ofGroup","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B : Subgroup G\nd : HNNExtension.NormalWord.TransversalPair G A B\ng₁ g₂ : G\n⊢ Eq (HSMul.hSMul g₁ (HNNExtension.NormalWord.ofGroup g₂)) (HNNExtension.NormalWord.ofGroup (HMul.hMul g₁ g₂))","decl":"@[simp]\ntheorem smul_ofGroup (g₁ g₂ : G) :\n    g₁ • (ofGroup g₂ : NormalWord d) = ofGroup (g₁ * g₂) := rfl\n\n"}
{"name":"HNNExtension.NormalWord.unitsSMulGroup_snd","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B : Subgroup G\nφ : MulEquiv (Subtype fun x => Membership.mem A x) (Subtype fun x => Membership.mem B x)\nd : HNNExtension.NormalWord.TransversalPair G A B\nu : Units Int\ng : G\n⊢ Eq (HNNExtension.NormalWord.unitsSMulGroup φ d u g).2 (⋯.equiv g).2","decl":"theorem unitsSMulGroup_snd (u : ℤˣ) (g : G) :\n    (unitsSMulGroup φ d u g).2 = ((d.compl u).equiv g).2 := by\n  rcases Int.units_eq_one_or u with rfl | rfl <;> rfl\n\n"}
{"name":"HNNExtension.NormalWord.not_cancels_of_cons_hyp","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B : Subgroup G\nd : HNNExtension.NormalWord.TransversalPair G A B\nu : Units Int\nw : HNNExtension.NormalWord d\nh2 : ∀ (u' : Units Int), Membership.mem (Option.map Prod.fst w.toList.head?) u' → Membership.mem (HNNExtension.toSubgroup A B u) w.head → Eq u u'\n⊢ Not (HNNExtension.NormalWord.Cancels u w)","decl":"/-- A condition for not cancelling whose hypothese are the same as those of the `cons` function. -/\ntheorem not_cancels_of_cons_hyp (u : ℤˣ) (w : NormalWord d)\n    (h2 : ∀ u' ∈ Option.map Prod.fst w.toList.head?,\n      w.head ∈ toSubgroup A B u → u = u') :\n    ¬ Cancels u w := by\n  simp only [Cancels, Option.map_eq_some', Prod.exists,\n    exists_and_right, exists_eq_right, not_and, not_exists]\n  intro hw x hx\n  rw [hx] at h2\n  simpa using h2 (-u) rfl hw\n\n"}
{"name":"HNNExtension.NormalWord.unitsSMul_cancels_iff","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B : Subgroup G\nφ : MulEquiv (Subtype fun x => Membership.mem A x) (Subtype fun x => Membership.mem B x)\nd : HNNExtension.NormalWord.TransversalPair G A B\nu : Units Int\nw : HNNExtension.NormalWord d\n⊢ Iff (HNNExtension.NormalWord.Cancels (Neg.neg u) (HNNExtension.NormalWord.unitsSMul φ u w)) (Not (HNNExtension.NormalWord.Cancels u w))","decl":"theorem unitsSMul_cancels_iff (u : ℤˣ) (w : NormalWord d) :\n    Cancels (-u) (unitsSMul φ u w) ↔ ¬ Cancels u w := by\n  by_cases h : Cancels u w\n  · simp only [unitsSMul, h, dite_true, not_true_eq_false, iff_false]\n    induction w using consRecOn with\n    | ofGroup => simp [Cancels, unitsSMulWithCancel]\n    | cons g u' w h1 h2 _ =>\n      intro hc\n      apply not_cancels_of_cons_hyp _ _ h2\n      simp only [Cancels, cons_head, cons_toList, List.head?_cons,\n        Option.map_some', Option.some.injEq] at h\n      cases h.2\n      simpa [Cancels, unitsSMulWithCancel,\n        Subgroup.mul_mem_cancel_left] using hc\n  · simp only [unitsSMul, dif_neg h]\n    simpa [Cancels] using h\n\n"}
{"name":"HNNExtension.NormalWord.unitsSMul_neg","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B : Subgroup G\nφ : MulEquiv (Subtype fun x => Membership.mem A x) (Subtype fun x => Membership.mem B x)\nd : HNNExtension.NormalWord.TransversalPair G A B\nu : Units Int\nw : HNNExtension.NormalWord d\n⊢ Eq (HNNExtension.NormalWord.unitsSMul φ (Neg.neg u) (HNNExtension.NormalWord.unitsSMul φ u w)) w","decl":"theorem unitsSMul_neg (u : ℤˣ) (w : NormalWord d) :\n    unitsSMul φ (-u) (unitsSMul φ u w) = w := by\n  rw [unitsSMul]\n  split_ifs with hcan\n  · have hncan : ¬ Cancels u w := (unitsSMul_cancels_iff _ _ _).1 hcan\n    unfold unitsSMul\n    simp only [dif_neg hncan]\n    simp [unitsSMulWithCancel, unitsSMulGroup, (d.compl u).equiv_snd_eq_inv_mul]\n    -- This used to be the end of the proof before https://github.com/leanprover/lean4/pull/2644\n    erw [(d.compl u).equiv_snd_eq_inv_mul]\n    simp\n  · have hcan2 : Cancels u w := not_not.1 (mt (unitsSMul_cancels_iff _ _ _).2 hcan)\n    unfold unitsSMul at hcan ⊢\n    simp only [dif_pos hcan2] at hcan ⊢\n    cases w using consRecOn with\n    | ofGroup => simp [Cancels] at hcan2\n    | cons g u' w h1 h2 ih =>\n      clear ih\n      simp only [unitsSMulGroup, SetLike.coe_sort_coe, unitsSMulWithCancel, id_eq, consRecOn_cons,\n        group_smul_head, IsComplement.equiv_mul_left, map_mul, Submonoid.coe_mul, coe_toSubmonoid,\n        toSubgroupEquiv_neg_apply, mul_inv_rev]\n      cases hcan2.2\n      have : ((d.compl (-u)).equiv w.head).1 = 1 :=\n        (d.compl (-u)).equiv_fst_eq_one_of_mem_of_one_mem _ h1\n      apply NormalWord.ext\n      · -- This used to `simp [this]` before https://github.com/leanprover/lean4/pull/2644\n        dsimp\n        conv_lhs => erw [IsComplement.equiv_mul_left]\n        rw [map_mul, Submonoid.coe_mul, toSubgroupEquiv_neg_apply, this]\n        simp\n      · -- The next two lines were not needed before https://github.com/leanprover/lean4/pull/2644\n        dsimp\n        conv_lhs => erw [IsComplement.equiv_mul_left]\n        simp [mul_assoc, Units.ext_iff, (d.compl (-u)).equiv_snd_eq_inv_mul, this]\n        -- The next two lines were not needed before https://github.com/leanprover/lean4/pull/2644\n        erw [(d.compl (-u)).equiv_snd_eq_inv_mul, this]\n        simp\n\n"}
{"name":"HNNExtension.NormalWord.unitsSMulEquiv_symm_apply","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B : Subgroup G\nφ : MulEquiv (Subtype fun x => Membership.mem A x) (Subtype fun x => Membership.mem B x)\nd : HNNExtension.NormalWord.TransversalPair G A B\nw : HNNExtension.NormalWord d\n⊢ Eq ((HNNExtension.NormalWord.unitsSMulEquiv φ).symm w) (HNNExtension.NormalWord.unitsSMul φ (-1) w)","decl":"/-- the equivalence given by multiplication on the left by `t`  -/\n@[simps]\nnoncomputable def unitsSMulEquiv : NormalWord d ≃ NormalWord d :=\n  { toFun := unitsSMul φ 1\n    invFun := unitsSMul φ (-1),\n    left_inv := fun _ => by rw [unitsSMul_neg]\n    right_inv := fun w => by convert unitsSMul_neg _ _ w; simp }\n\n"}
{"name":"HNNExtension.NormalWord.unitsSMulEquiv_apply","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B : Subgroup G\nφ : MulEquiv (Subtype fun x => Membership.mem A x) (Subtype fun x => Membership.mem B x)\nd : HNNExtension.NormalWord.TransversalPair G A B\nw : HNNExtension.NormalWord d\n⊢ Eq ((HNNExtension.NormalWord.unitsSMulEquiv φ) w) (HNNExtension.NormalWord.unitsSMul φ 1 w)","decl":"/-- the equivalence given by multiplication on the left by `t`  -/\n@[simps]\nnoncomputable def unitsSMulEquiv : NormalWord d ≃ NormalWord d :=\n  { toFun := unitsSMul φ 1\n    invFun := unitsSMul φ (-1),\n    left_inv := fun _ => by rw [unitsSMul_neg]\n    right_inv := fun w => by convert unitsSMul_neg _ _ w; simp }\n\n"}
{"name":"HNNExtension.NormalWord.unitsSMul_one_group_smul","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B : Subgroup G\nφ : MulEquiv (Subtype fun x => Membership.mem A x) (Subtype fun x => Membership.mem B x)\nd : HNNExtension.NormalWord.TransversalPair G A B\ng : Subtype fun x => Membership.mem A x\nw : HNNExtension.NormalWord d\n⊢ Eq (HNNExtension.NormalWord.unitsSMul φ 1 (HSMul.hSMul (↑g) w)) (HSMul.hSMul (↑(φ g)) (HNNExtension.NormalWord.unitsSMul φ 1 w))","decl":"theorem unitsSMul_one_group_smul (g : A) (w : NormalWord d) :\n    unitsSMul φ 1 ((g : G) • w) = (φ g : G) • (unitsSMul φ 1 w) := by\n  unfold unitsSMul\n  have : Cancels 1 ((g : G) • w) ↔ Cancels 1 w := by\n    simp [Cancels, Subgroup.mul_mem_cancel_left]\n  by_cases hcan : Cancels 1 w\n  · simp [unitsSMulWithCancel, dif_pos (this.2 hcan), dif_pos hcan]\n    cases w using consRecOn\n    · simp [Cancels] at hcan\n    · simp only [smul_cons, consRecOn_cons, mul_smul]\n      rw [← mul_smul, ← Subgroup.coe_mul, ← map_mul φ]\n      rfl\n  · rw [dif_neg (mt this.1 hcan), dif_neg hcan]\n    simp [← mul_smul, mul_assoc, unitsSMulGroup]\n    -- This used to be the end of the proof before https://github.com/leanprover/lean4/pull/2644\n    dsimp\n    congr 1\n    · conv_lhs => erw [IsComplement.equiv_mul_left]\n      simp_rw [toSubgroup_one]\n      simp only [SetLike.coe_sort_coe, map_mul, Subgroup.coe_mul]\n    conv_lhs => erw [IsComplement.equiv_mul_left]\n    rfl\n\n"}
{"name":"HNNExtension.NormalWord.prod_group_smul","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B : Subgroup G\nφ : MulEquiv (Subtype fun x => Membership.mem A x) (Subtype fun x => Membership.mem B x)\nd : HNNExtension.NormalWord.TransversalPair G A B\ng : G\nw : HNNExtension.NormalWord d\n⊢ Eq (HNNExtension.NormalWord.ReducedWord.prod φ (HSMul.hSMul g w).toReducedWord) (HMul.hMul (HNNExtension.of g) (HNNExtension.NormalWord.ReducedWord.prod φ w.toReducedWord))","decl":"@[simp]\ntheorem prod_group_smul (g : G) (w : NormalWord d) :\n    (g • w).prod φ = of g * (w.prod φ) := by\n  simp [ReducedWord.prod, smul_def, mul_assoc]\n\n"}
{"name":"HNNExtension.NormalWord.of_smul_eq_smul","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B : Subgroup G\nφ : MulEquiv (Subtype fun x => Membership.mem A x) (Subtype fun x => Membership.mem B x)\nd : HNNExtension.NormalWord.TransversalPair G A B\ng : G\nw : HNNExtension.NormalWord d\n⊢ Eq (HSMul.hSMul (HNNExtension.of g) w) (HSMul.hSMul g w)","decl":"theorem of_smul_eq_smul (g : G) (w : NormalWord d) :\n    (of g : HNNExtension G A B φ) • w = g • w := by\n  simp [instHSMul, SMul.smul, MulAction.toEndHom]\n\n"}
{"name":"HNNExtension.NormalWord.t_smul_eq_unitsSMul","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B : Subgroup G\nφ : MulEquiv (Subtype fun x => Membership.mem A x) (Subtype fun x => Membership.mem B x)\nd : HNNExtension.NormalWord.TransversalPair G A B\nw : HNNExtension.NormalWord d\n⊢ Eq (HSMul.hSMul HNNExtension.t w) (HNNExtension.NormalWord.unitsSMul φ 1 w)","decl":"theorem t_smul_eq_unitsSMul (w : NormalWord d) :\n    (t : HNNExtension G A B φ) • w = unitsSMul φ 1 w := by\n  simp [instHSMul, SMul.smul, MulAction.toEndHom]\n\n"}
{"name":"HNNExtension.NormalWord.t_pow_smul_eq_unitsSMul","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B : Subgroup G\nφ : MulEquiv (Subtype fun x => Membership.mem A x) (Subtype fun x => Membership.mem B x)\nd : HNNExtension.NormalWord.TransversalPair G A B\nu : Units Int\nw : HNNExtension.NormalWord d\n⊢ Eq (HSMul.hSMul (HPow.hPow HNNExtension.t ↑u) w) (HNNExtension.NormalWord.unitsSMul φ u w)","decl":"theorem t_pow_smul_eq_unitsSMul (u : ℤˣ) (w : NormalWord d) :\n    (t ^ (u : ℤ) : HNNExtension G A B φ) • w = unitsSMul φ u w := by\n  rcases Int.units_eq_one_or u with (rfl | rfl) <;>\n    simp [instHSMul, SMul.smul, MulAction.toEndHom, Equiv.Perm.inv_def]\n\n"}
{"name":"HNNExtension.NormalWord.prod_cons","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B : Subgroup G\nφ : MulEquiv (Subtype fun x => Membership.mem A x) (Subtype fun x => Membership.mem B x)\nd : HNNExtension.NormalWord.TransversalPair G A B\ng : G\nu : Units Int\nw : HNNExtension.NormalWord d\nh1 : Membership.mem (d.set u) w.head\nh2 : ∀ (u' : Units Int), Membership.mem (Option.map Prod.fst w.toList.head?) u' → Membership.mem (HNNExtension.toSubgroup A B u) w.head → Eq u u'\n⊢ Eq (HNNExtension.NormalWord.ReducedWord.prod φ (HNNExtension.NormalWord.cons g u w h1 h2).toReducedWord) (HMul.hMul (HNNExtension.of g) (HMul.hMul (HPow.hPow HNNExtension.t ↑u) (HNNExtension.NormalWord.ReducedWord.prod φ w.toReducedWord)))","decl":"@[simp]\ntheorem prod_cons (g : G) (u : ℤˣ) (w : NormalWord d) (h1 : w.head ∈ d.set u)\n    (h2 : ∀ u' ∈ Option.map Prod.fst w.toList.head?,\n      w.head ∈ toSubgroup A B u → u = u') :\n    (cons g u w h1 h2).prod φ = of g * (t ^ (u : ℤ) * w.prod φ) := by\n  simp [ReducedWord.prod, cons, smul_def, mul_assoc]\n\n"}
{"name":"HNNExtension.NormalWord.prod_unitsSMul","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B : Subgroup G\nφ : MulEquiv (Subtype fun x => Membership.mem A x) (Subtype fun x => Membership.mem B x)\nd : HNNExtension.NormalWord.TransversalPair G A B\nu : Units Int\nw : HNNExtension.NormalWord d\n⊢ Eq (HNNExtension.NormalWord.ReducedWord.prod φ (HNNExtension.NormalWord.unitsSMul φ u w).toReducedWord) (HMul.hMul (HPow.hPow HNNExtension.t ↑u) (HNNExtension.NormalWord.ReducedWord.prod φ w.toReducedWord))","decl":"theorem prod_unitsSMul (u : ℤˣ) (w : NormalWord d) :\n    (unitsSMul φ u w).prod φ = (t^(u : ℤ) * w.prod φ : HNNExtension G A B φ) := by\n  rw [unitsSMul]\n  split_ifs with hcan\n  · cases w using consRecOn\n    · simp [Cancels] at hcan\n    · cases hcan.2\n      simp [unitsSMulWithCancel]\n      rcases Int.units_eq_one_or u with (rfl | rfl)\n      · simp [equiv_eq_conj, mul_assoc]\n      · simp [equiv_symm_eq_conj, mul_assoc]\n        -- This used to be the end of the proof before https://github.com/leanprover/lean4/pull/2644\n        erw [equiv_symm_eq_conj]\n        simp [equiv_symm_eq_conj, mul_assoc]\n  · simp [unitsSMulGroup]\n    rcases Int.units_eq_one_or u with (rfl | rfl)\n    · simp [equiv_eq_conj, mul_assoc, (d.compl _).equiv_snd_eq_inv_mul]\n      -- This used to be the end of the proof before https://github.com/leanprover/lean4/pull/2644\n      erw [(d.compl 1).equiv_snd_eq_inv_mul]\n      simp [equiv_eq_conj, mul_assoc, (d.compl _).equiv_snd_eq_inv_mul]\n    · simp [equiv_symm_eq_conj, mul_assoc, (d.compl _).equiv_snd_eq_inv_mul]\n      -- This used to be the end of the proof before https://github.com/leanprover/lean4/pull/2644\n      erw [equiv_symm_eq_conj, (d.compl (-1)).equiv_snd_eq_inv_mul]\n      simp [equiv_symm_eq_conj, mul_assoc, (d.compl _).equiv_snd_eq_inv_mul]\n\n"}
{"name":"HNNExtension.NormalWord.prod_empty","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B : Subgroup G\nφ : MulEquiv (Subtype fun x => Membership.mem A x) (Subtype fun x => Membership.mem B x)\nd : HNNExtension.NormalWord.TransversalPair G A B\n⊢ Eq (HNNExtension.NormalWord.ReducedWord.prod φ HNNExtension.NormalWord.empty.toReducedWord) 1","decl":"@[simp]\ntheorem prod_empty : (empty : NormalWord d).prod φ = 1 := by\n  simp [ReducedWord.prod]\n\n"}
{"name":"HNNExtension.NormalWord.prod_smul","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B : Subgroup G\nφ : MulEquiv (Subtype fun x => Membership.mem A x) (Subtype fun x => Membership.mem B x)\nd : HNNExtension.NormalWord.TransversalPair G A B\ng : HNNExtension G A B φ\nw : HNNExtension.NormalWord d\n⊢ Eq (HNNExtension.NormalWord.ReducedWord.prod φ (HSMul.hSMul g w).toReducedWord) (HMul.hMul g (HNNExtension.NormalWord.ReducedWord.prod φ w.toReducedWord))","decl":"@[simp]\ntheorem prod_smul (g : HNNExtension G A B φ) (w : NormalWord d) :\n    (g • w).prod φ = g * w.prod φ := by\n  induction g using induction_on generalizing w with\n  | of => simp [of_smul_eq_smul]\n  | t => simp [t_smul_eq_unitsSMul, prod_unitsSMul, mul_assoc]\n  | mul => simp_all [mul_smul, mul_assoc]\n  | inv x ih =>\n    rw [← mul_right_inj x, ← ih]\n    simp\n\n"}
{"name":"HNNExtension.NormalWord.prod_smul_empty","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B : Subgroup G\nφ : MulEquiv (Subtype fun x => Membership.mem A x) (Subtype fun x => Membership.mem B x)\nd : HNNExtension.NormalWord.TransversalPair G A B\nw : HNNExtension.NormalWord d\n⊢ Eq (HSMul.hSMul (HNNExtension.NormalWord.ReducedWord.prod φ w.toReducedWord) HNNExtension.NormalWord.empty) w","decl":"@[simp]\ntheorem prod_smul_empty (w : NormalWord d) :\n    (w.prod φ) • empty = w := by\n  induction w using consRecOn with\n  | ofGroup => simp [ofGroup, ReducedWord.prod, of_smul_eq_smul, group_smul_def]\n  | cons g u w h1 h2 ih =>\n    rw [prod_cons, ← mul_assoc, mul_smul, ih, mul_smul, t_pow_smul_eq_unitsSMul,\n      of_smul_eq_smul, unitsSMul]\n    rw [dif_neg (not_cancels_of_cons_hyp u w h2)]\n    -- The next 3 lines were a single `simp [...]` before https://github.com/leanprover/lean4/pull/2644\n    simp only [unitsSMulGroup]\n    simp_rw [SetLike.coe_sort_coe]\n    erw [(d.compl _).equiv_fst_eq_one_of_mem_of_one_mem (one_mem _) h1]\n    ext <;> simp\n    -- The next 4 were not needed before https://github.com/leanprover/lean4/pull/2644\n    erw [(d.compl _).equiv_snd_eq_inv_mul]\n    simp_rw [SetLike.coe_sort_coe]\n    erw [(d.compl _).equiv_fst_eq_one_of_mem_of_one_mem (one_mem _) h1]\n    simp\n\n"}
{"name":"HNNExtension.NormalWord.prod_injective","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B : Subgroup G\nφ : MulEquiv (Subtype fun x => Membership.mem A x) (Subtype fun x => Membership.mem B x)\nd : HNNExtension.NormalWord.TransversalPair G A B\n⊢ Function.Injective fun w => HNNExtension.NormalWord.ReducedWord.prod φ w.toReducedWord","decl":"theorem prod_injective : Injective\n    (fun w => w.prod φ : NormalWord d → HNNExtension G A B φ) :=\n  (equiv φ d).symm.injective\n\n"}
{"name":"HNNExtension.NormalWord.instFaithfulSMul_1","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B : Subgroup G\nφ : MulEquiv (Subtype fun x => Membership.mem A x) (Subtype fun x => Membership.mem B x)\nd : HNNExtension.NormalWord.TransversalPair G A B\n⊢ FaithfulSMul (HNNExtension G A B φ) (HNNExtension.NormalWord d)","decl":"instance : FaithfulSMul (HNNExtension G A B φ) (NormalWord d) :=\n  ⟨fun h => by simpa using congr_arg (fun w => w.prod φ) (h empty)⟩\n\n"}
{"name":"HNNExtension.of_injective","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B : Subgroup G\nφ : MulEquiv (Subtype fun x => Membership.mem A x) (Subtype fun x => Membership.mem B x)\n⊢ Function.Injective ⇑HNNExtension.of","decl":"theorem of_injective : Function.Injective (of : G → HNNExtension G A B φ) := by\n  rcases TransversalPair.nonempty G A B with ⟨d⟩\n  refine Function.Injective.of_comp\n    (f := ((· • ·) : HNNExtension G A B φ → NormalWord d → NormalWord d)) ?_\n  intros _ _ h\n  exact eq_of_smul_eq_smul (fun w : NormalWord d =>\n    by simp_all [funext_iff, of_smul_eq_smul])\n\n"}
{"name":"HNNExtension.ReducedWord.exists_normalWord_prod_eq","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B : Subgroup G\nφ : MulEquiv (Subtype fun x => Membership.mem A x) (Subtype fun x => Membership.mem B x)\nd : HNNExtension.NormalWord.TransversalPair G A B\nw : HNNExtension.NormalWord.ReducedWord G A B\n⊢ Exists fun w' => And (Eq (HNNExtension.NormalWord.ReducedWord.prod φ w'.toReducedWord) (HNNExtension.NormalWord.ReducedWord.prod φ w)) (And (Eq (List.map Prod.fst w'.toList) (List.map Prod.fst w.toList)) (∀ (u : Units Int), Membership.mem (Option.map Prod.fst w.toList.head?) u → Membership.mem (HNNExtension.toSubgroup A B (Neg.neg u)) (HMul.hMul (Inv.inv w'.head) w.head)))","decl":"theorem exists_normalWord_prod_eq\n    (d : TransversalPair G A B) (w : ReducedWord G A B) :\n    ∃ w' : NormalWord d, w'.prod φ = w.prod φ ∧\n      w'.toList.map Prod.fst = w.toList.map Prod.fst ∧\n      ∀ u ∈ w.toList.head?.map Prod.fst,\n      w'.head⁻¹ * w.head ∈ toSubgroup A B (-u) := by\n  suffices ∀ w : ReducedWord G A B,\n      w.head = 1 → ∃ w' : NormalWord d, w'.prod φ = w.prod φ ∧\n      w'.toList.map Prod.fst = w.toList.map Prod.fst ∧\n      ∀ u ∈ w.toList.head?.map Prod.fst,\n      w'.head ∈ toSubgroup A B (-u) by\n    by_cases hw1 : w.head = 1\n    · simp only [hw1, inv_mem_iff, mul_one]\n      exact this w hw1\n    · rcases this ⟨1, w.toList, w.chain⟩ rfl with ⟨w', hw'⟩\n      exact ⟨w.head • w', by\n        simpa [ReducedWord.prod, mul_assoc] using hw'⟩\n  intro w hw1\n  rcases w with ⟨g, l, chain⟩\n  dsimp at hw1; subst hw1\n  induction l with\n  | nil =>\n    exact\n      ⟨{ head := 1\n         toList := []\n         mem_set := by simp\n         chain := List.chain'_nil }, by simp [prod]⟩\n  | cons a l ih =>\n    rcases ih (List.chain'_cons'.1 chain).2 with ⟨w', hw'1, hw'2, hw'3⟩\n    clear ih\n    refine ⟨(t^(a.1 : ℤ) * of a.2 : HNNExtension G A B φ) • w', ?_, ?_⟩\n    · rw [prod_smul, hw'1]\n      simp [ReducedWord.prod]\n    · have : ¬ Cancels a.1 (a.2 • w') := by\n        simp only [Cancels, group_smul_head, group_smul_toList, Option.map_eq_some',\n          Prod.exists, exists_and_right, exists_eq_right, not_and, not_exists]\n        intro hS x hx\n        have hx' := congr_arg (Option.map Prod.fst) hx\n        rw [← List.head?_map, hw'2, List.head?_map, Option.map_some'] at hx'\n        have : w'.head ∈ toSubgroup A B a.fst := by\n          simpa using hw'3 _ hx'\n        rw [mul_mem_cancel_right this] at hS\n        have : a.fst = -a.fst := by\n          have hl : l ≠ [] := by rintro rfl; simp_all\n          have : a.fst = (l.head hl).fst := (List.chain'_cons'.1 chain).1 (l.head hl)\n            (List.head?_eq_head _) hS\n          rwa [List.head?_eq_head hl, Option.map_some', ← this, Option.some_inj] at hx'\n        simp at this\n      erw [List.map_cons, mul_smul, of_smul_eq_smul, NormalWord.group_smul_def,\n        t_pow_smul_eq_unitsSMul, unitsSMul, dif_neg this, ← hw'2]\n      simp [mul_assoc, unitsSMulGroup, (d.compl _).coe_equiv_snd_eq_one_iff_mem]\n\n"}
{"name":"HNNExtension.ReducedWord.map_fst_eq_and_of_prod_eq","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B : Subgroup G\nφ : MulEquiv (Subtype fun x => Membership.mem A x) (Subtype fun x => Membership.mem B x)\nw₁ w₂ : HNNExtension.NormalWord.ReducedWord G A B\nhprod : Eq (HNNExtension.NormalWord.ReducedWord.prod φ w₁) (HNNExtension.NormalWord.ReducedWord.prod φ w₂)\n⊢ And (Eq (List.map Prod.fst w₁.toList) (List.map Prod.fst w₂.toList)) (∀ (u : Units Int), Membership.mem (Option.map Prod.fst w₁.toList.head?) u → Membership.mem (HNNExtension.toSubgroup A B (Neg.neg u)) (HMul.hMul (Inv.inv w₁.head) w₂.head))","decl":"/-- Two reduced words representing the same element of the `HNNExtension G A B φ` have the same\nlength corresponding list, with the same pattern of occurrences of `t^1` and `t^(-1)`,\nand also the `head` is in the same left coset of `toSubgroup A B (-u)`, where `u : ℤˣ`\nis the exponent of the first occurrence of `t` in the word. -/\ntheorem map_fst_eq_and_of_prod_eq {w₁ w₂ : ReducedWord G A B}\n    (hprod : w₁.prod φ = w₂.prod φ) :\n    w₁.toList.map Prod.fst = w₂.toList.map Prod.fst ∧\n     ∀ u ∈ w₁.toList.head?.map Prod.fst,\n      w₁.head⁻¹ * w₂.head ∈ toSubgroup A B (-u) := by\n  rcases TransversalPair.nonempty G A B with ⟨d⟩\n  rcases exists_normalWord_prod_eq φ d w₁ with ⟨w₁', hw₁'1, hw₁'2, hw₁'3⟩\n  rcases exists_normalWord_prod_eq φ d w₂ with ⟨w₂', hw₂'1, hw₂'2, hw₂'3⟩\n  have : w₁' = w₂' :=\n    NormalWord.prod_injective φ d (by dsimp only; rw [hw₁'1, hw₂'1, hprod])\n  subst this\n  refine ⟨by rw [← hw₁'2, hw₂'2], ?_⟩\n  simp only [← leftCoset_eq_iff] at *\n  intro u hu\n  rw [← hw₁'3 _ hu, ← hw₂'3 _]\n  rwa [← List.head?_map, ← hw₂'2, hw₁'2, List.head?_map]\n\n"}
{"name":"HNNExtension.ReducedWord.toList_eq_nil_of_mem_of_range","module":"Mathlib.GroupTheory.HNNExtension","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B : Subgroup G\nφ : MulEquiv (Subtype fun x => Membership.mem A x) (Subtype fun x => Membership.mem B x)\nw : HNNExtension.NormalWord.ReducedWord G A B\nhw : Membership.mem HNNExtension.of.range (HNNExtension.NormalWord.ReducedWord.prod φ w)\n⊢ Eq w.toList List.nil","decl":"/-- **Britton's Lemma**. Any reduced word whose product is an element of `G`, has no\noccurrences of `t`. -/\ntheorem toList_eq_nil_of_mem_of_range (w : ReducedWord G A B)\n    (hw : w.prod φ ∈ (of.range : Subgroup (HNNExtension G A B φ))) :\n    w.toList = [] := by\n  rcases hw with ⟨g, hg⟩\n  let w' : ReducedWord G A B := { ReducedWord.empty G A B with head := g }\n  have : w.prod φ = w'.prod φ := by simp [w', ReducedWord.prod, hg]\n  simpa [w'] using (map_fst_eq_and_of_prod_eq φ this).1\n\n"}
