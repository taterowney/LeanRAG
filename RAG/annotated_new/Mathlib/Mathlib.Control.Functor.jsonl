{"name":"Functor.map_id","module":"Mathlib.Control.Functor","initialProofState":"F : Type u → Type v\nα : Type u\ninst✝¹ : Functor F\ninst✝ : LawfulFunctor F\n⊢ Eq (fun x => Functor.map id x) id","decl":"theorem Functor.map_id : (id <$> ·) = (id : F α → F α) := funext id_map\n\n"}
{"name":"Functor.map_comp_map","module":"Mathlib.Control.Functor","initialProofState":"F : Type u → Type v\nα β γ : Type u\ninst✝¹ : Functor F\ninst✝ : LawfulFunctor F\nf : α → β\ng : β → γ\n⊢ Eq (Function.comp (fun x => Functor.map g x) fun x => Functor.map f x) fun x => Functor.map (Function.comp g f) x","decl":"theorem Functor.map_comp_map (f : α → β) (g : β → γ) :\n    ((g <$> ·) ∘ (f <$> ·) : F α → F γ) = ((g ∘ f) <$> ·) :=\n  funext fun _ => (comp_map _ _ _).symm\n  -- Porting note: was `apply funext <;> intro <;> rw [comp_map]` but `rw` failed?\n\n"}
{"name":"Functor.ext","module":"Mathlib.Control.Functor","initialProofState":"F : Type u_1 → Type u_2\nF1 F2 : Functor F\ninst✝¹ : LawfulFunctor F\ninst✝ : LawfulFunctor F\na✝ : ∀ (α β : Type u_1) (f : α → β) (x : F α), Eq (Functor.map f x) (Functor.map f x)\n⊢ Eq F1 F2","decl":"theorem Functor.ext {F} :\n    ∀ {F1 : Functor F} {F2 : Functor F} [@LawfulFunctor F F1] [@LawfulFunctor F F2],\n    (∀ (α β) (f : α → β) (x : F α), @Functor.map _ F1 _ _ f x = @Functor.map _ F2 _ _ f x) →\n    F1 = F2\n  | ⟨m, mc⟩, ⟨m', mc'⟩, H1, H2, H => by\n    cases show @m = @m' by funext α β f x; apply H\n    congr\n    funext α β\n    have E1 := @map_const _ ⟨@m, @mc⟩ H1\n    have E2 := @map_const _ ⟨@m, @mc'⟩ H2\n    exact E1.trans E2.symm\n\n"}
{"name":"Functor.Const.ext","module":"Mathlib.Control.Functor","initialProofState":"α : Type u_1\nβ : Type u_2\nx y : Functor.Const α β\nh : Eq x.run y.run\n⊢ Eq x y","decl":"protected theorem ext {α β} {x y : Const α β} (h : x.run = y.run) : x = y :=\n  h\n\n"}
{"name":"Functor.Const.lawfulFunctor","module":"Mathlib.Control.Functor","initialProofState":"γ : Type u_1\n⊢ LawfulFunctor (Functor.Const γ)","decl":"instance lawfulFunctor {γ} : LawfulFunctor (Const γ) := by constructor <;> intros <;> rfl\n\n"}
{"name":"Functor.AddConst.lawfulFunctor","module":"Mathlib.Control.Functor","initialProofState":"γ : Type u_1\n⊢ LawfulFunctor (Functor.AddConst γ)","decl":"instance AddConst.lawfulFunctor {γ} : LawfulFunctor (AddConst γ) :=\n  @Const.lawfulFunctor γ\n\n"}
{"name":"Functor.Comp.ext","module":"Mathlib.Control.Functor","initialProofState":"F : Type u → Type w\nG : Type v → Type u\nα : Type v\nx y : Functor.Comp F G α\na✝ : Eq x.run y.run\n⊢ Eq x y","decl":"protected theorem ext {α} {x y : Comp F G α} : x.run = y.run → x = y :=\n  id\n\n"}
{"name":"Functor.Comp.map_mk","module":"Mathlib.Control.Functor","initialProofState":"F : Type u → Type w\nG : Type v → Type u\ninst✝¹ : Functor F\ninst✝ : Functor G\nα β : Type v\nh : α → β\nx : F (G α)\n⊢ Eq (Functor.map h (Functor.Comp.mk x)) (Functor.Comp.mk (Functor.map (fun x => Functor.map h x) x))","decl":"@[functor_norm]\ntheorem map_mk {α β} (h : α → β) (x : F (G α)) : h <$> Comp.mk x = Comp.mk ((h <$> ·) <$> x) :=\n  rfl\n\n"}
{"name":"Functor.Comp.run_map","module":"Mathlib.Control.Functor","initialProofState":"F : Type u → Type w\nG : Type v → Type u\ninst✝¹ : Functor F\ninst✝ : Functor G\nα β : Type v\nh : α → β\nx : Functor.Comp F G α\n⊢ Eq (Functor.map h x).run (Functor.map (fun x => Functor.map h x) x.run)","decl":"@[simp]\nprotected theorem run_map {α β} (h : α → β) (x : Comp F G α) :\n    (h <$> x).run = (h <$> ·) <$> x.run :=\n  rfl\n\n"}
{"name":"Functor.Comp.id_map","module":"Mathlib.Control.Functor","initialProofState":"F : Type u → Type w\nG : Type v → Type u\ninst✝³ : Functor F\ninst✝² : Functor G\ninst✝¹ : LawfulFunctor F\ninst✝ : LawfulFunctor G\nα : Type v\nx : Functor.Comp F G α\n⊢ Eq (Functor.Comp.map id x) x","decl":"protected theorem id_map : ∀ x : Comp F G α, Comp.map id x = x\n  | Comp.mk x => by simp only [Comp.map, id_map, id_map']; rfl\n  -- Porting note: `rfl` wasn't needed in mathlib3\n\n"}
{"name":"Functor.Comp.comp_map","module":"Mathlib.Control.Functor","initialProofState":"F : Type u → Type w\nG : Type v → Type u\ninst✝³ : Functor F\ninst✝² : Functor G\ninst✝¹ : LawfulFunctor F\ninst✝ : LawfulFunctor G\nα β γ : Type v\ng' : α → β\nh : β → γ\nx : Functor.Comp F G α\n⊢ Eq (Functor.Comp.map (Function.comp h g') x) (Functor.Comp.map h (Functor.Comp.map g' x))","decl":"protected theorem comp_map (g' : α → β) (h : β → γ) :\n    ∀ x : Comp F G α, Comp.map (h ∘ g') x = Comp.map h (Comp.map g' x)\n  | Comp.mk x => by simp [Comp.map, Comp.mk, Functor.map_comp_map, functor_norm, Function.comp_def]\n  -- Porting note: `Comp.mk` wasn't needed in mathlib3\n\n"}
{"name":"Functor.Comp.lawfulFunctor","module":"Mathlib.Control.Functor","initialProofState":"F : Type u → Type w\nG : Type v → Type u\ninst✝³ : Functor F\ninst✝² : Functor G\ninst✝¹ : LawfulFunctor F\ninst✝ : LawfulFunctor G\n⊢ LawfulFunctor (Functor.Comp F G)","decl":"instance lawfulFunctor : LawfulFunctor (Comp F G) where\n  map_const := rfl\n  id_map := Comp.id_map\n  comp_map := Comp.comp_map\n\n-- Porting note: had to use switch to `Id` from `id` because this has the `Functor` instance.\n"}
{"name":"Functor.Comp.functor_comp_id","module":"Mathlib.Control.Functor","initialProofState":"F : Type u_1 → Type u_2\nAF : Functor F\ninst✝ : LawfulFunctor F\n⊢ Eq Functor.Comp.functor AF","decl":"theorem functor_comp_id {F} [AF : Functor F] [LawfulFunctor F] :\n    @Comp.functor F Id _ _ = AF :=\n  @Functor.ext F _ AF (Comp.lawfulFunctor (G := Id)) _ fun _ _ _ _ => rfl\n\n-- Porting note: had to use switch to `Id` from `id` because this has the `Functor` instance.\n"}
{"name":"Functor.Comp.functor_id_comp","module":"Mathlib.Control.Functor","initialProofState":"F : Type u_1 → Type u_2\nAF : Functor F\ninst✝ : LawfulFunctor F\n⊢ Eq Functor.Comp.functor AF","decl":"theorem functor_id_comp {F} [AF : Functor F] [LawfulFunctor F] : @Comp.functor Id F _ _ = AF :=\n  @Functor.ext F _ AF (Comp.lawfulFunctor (F := Id)) _ fun _ _ _ _ => rfl\n\n"}
{"name":"Functor.Comp.run_pure","module":"Mathlib.Control.Functor","initialProofState":"F : Type u → Type w\nG : Type v → Type u\ninst✝¹ : Applicative F\ninst✝ : Applicative G\nα : Type v\nx : α\n⊢ Eq (Pure.pure x).run (Pure.pure (Pure.pure x))","decl":"@[simp]\nprotected theorem run_pure {α : Type v} : ∀ x : α, (pure x : Comp F G α).run = pure (pure x)\n  | _ => rfl\n\n"}
{"name":"Functor.Comp.run_seq","module":"Mathlib.Control.Functor","initialProofState":"F : Type u → Type w\nG : Type v → Type u\ninst✝¹ : Applicative F\ninst✝ : Applicative G\nα β : Type v\nf : Functor.Comp F G (α → β)\nx : Functor.Comp F G α\n⊢ Eq (Seq.seq f fun x_1 => x).run (Seq.seq (Functor.map (fun x1 x2 => Seq.seq x1 fun x => x2) f.run) fun x_1 => x.run)","decl":"@[simp]\nprotected theorem run_seq {α β : Type v} (f : Comp F G (α → β)) (x : Comp F G α) :\n    (f <*> x).run = (· <*> ·) <$> f.run <*> x.run :=\n  rfl\n\n"}
{"name":"Functor.of_mem_supp","module":"Mathlib.Control.Functor","initialProofState":"F : Type u → Type u\ninst✝ : Functor F\nα : Type u\nx : F α\np : α → Prop\nh : Functor.Liftp p x\ny : α\na✝ : Membership.mem (Functor.supp x) y\n⊢ p y","decl":"theorem of_mem_supp {α : Type u} {x : F α} {p : α → Prop} (h : Liftp p x) : ∀ y ∈ supp x, p y :=\n  fun _ hy => hy h\n\n"}
