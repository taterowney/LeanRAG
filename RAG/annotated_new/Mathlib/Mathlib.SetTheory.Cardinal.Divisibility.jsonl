{"name":"Cardinal.isUnit_iff","module":"Mathlib.SetTheory.Cardinal.Divisibility","initialProofState":"a : Cardinal.{u}\n⊢ Iff (IsUnit a) (Eq a 1)","decl":"@[simp]\ntheorem isUnit_iff : IsUnit a ↔ a = 1 := by\n  refine\n    ⟨fun h => ?_, by\n      rintro rfl\n      exact isUnit_one⟩\n  rcases eq_or_ne a 0 with (rfl | ha)\n  · exact (not_isUnit_zero h).elim\n  rw [isUnit_iff_forall_dvd] at h\n  cases' h 1 with t ht\n  rw [eq_comm, mul_eq_one_iff_of_one_le] at ht\n  · exact ht.1\n  · exact one_le_iff_ne_zero.mpr ha\n  · apply one_le_iff_ne_zero.mpr\n    intro h\n    rw [h, mul_zero] at ht\n    exact zero_ne_one ht\n\n"}
{"name":"Cardinal.le_of_dvd","module":"Mathlib.SetTheory.Cardinal.Divisibility","initialProofState":"a b : Cardinal.{u_1}\na✝¹ : Ne b 0\na✝ : Dvd.dvd a b\n⊢ LE.le a b","decl":"theorem le_of_dvd : ∀ {a b : Cardinal}, b ≠ 0 → a ∣ b → a ≤ b\n  | a, x, b0, ⟨b, hab⟩ => by\n    simpa only [hab, mul_one] using\n      mul_le_mul_left' (one_le_iff_ne_zero.2 fun h : b = 0 => b0 (by rwa [h, mul_zero] at hab)) a\n\n"}
{"name":"Cardinal.dvd_of_le_of_aleph0_le","module":"Mathlib.SetTheory.Cardinal.Divisibility","initialProofState":"a b : Cardinal.{u}\nha : Ne a 0\nh : LE.le a b\nhb : LE.le Cardinal.aleph0 b\n⊢ Dvd.dvd a b","decl":"theorem dvd_of_le_of_aleph0_le (ha : a ≠ 0) (h : a ≤ b) (hb : ℵ₀ ≤ b) : a ∣ b :=\n  ⟨b, (mul_eq_right hb h ha).symm⟩\n\n"}
{"name":"Cardinal.prime_of_aleph0_le","module":"Mathlib.SetTheory.Cardinal.Divisibility","initialProofState":"a : Cardinal.{u}\nha : LE.le Cardinal.aleph0 a\n⊢ Prime a","decl":"@[simp]\ntheorem prime_of_aleph0_le (ha : ℵ₀ ≤ a) : Prime a := by\n  refine ⟨(aleph0_pos.trans_le ha).ne', ?_, fun b c hbc => ?_⟩\n  · rw [isUnit_iff]\n    exact (one_lt_aleph0.trans_le ha).ne'\n  rcases eq_or_ne (b * c) 0 with hz | hz\n  · rcases mul_eq_zero.mp hz with (rfl | rfl) <;> simp\n  wlog h : c ≤ b\n  · cases le_total c b <;> [solve_by_elim; rw [or_comm]]\n    apply_assumption\n    assumption'\n    all_goals rwa [mul_comm]\n  left\n  have habc := le_of_dvd hz hbc\n  rwa [mul_eq_max' <| ha.trans <| habc, max_def', if_pos h] at hbc\n\n"}
{"name":"Cardinal.not_irreducible_of_aleph0_le","module":"Mathlib.SetTheory.Cardinal.Divisibility","initialProofState":"a : Cardinal.{u}\nha : LE.le Cardinal.aleph0 a\n⊢ Not (Irreducible a)","decl":"theorem not_irreducible_of_aleph0_le (ha : ℵ₀ ≤ a) : ¬Irreducible a := by\n  rw [irreducible_iff, not_and_or]\n  refine Or.inr fun h => ?_\n  simpa [mul_aleph0_eq ha, isUnit_iff, (one_lt_aleph0.trans_le ha).ne', one_lt_aleph0.ne'] using\n    h a ℵ₀\n\n"}
{"name":"Cardinal.nat_coe_dvd_iff","module":"Mathlib.SetTheory.Cardinal.Divisibility","initialProofState":"n m : Nat\n⊢ Iff (Dvd.dvd ↑n ↑m) (Dvd.dvd n m)","decl":"@[simp, norm_cast]\ntheorem nat_coe_dvd_iff : (n : Cardinal) ∣ m ↔ n ∣ m := by\n  refine ⟨?_, fun ⟨h, ht⟩ => ⟨h, mod_cast ht⟩⟩\n  rintro ⟨k, hk⟩\n  have : ↑m < ℵ₀ := nat_lt_aleph0 m\n  rw [hk, mul_lt_aleph0_iff] at this\n  rcases this with (h | h | ⟨-, hk'⟩)\n  iterate 2 simp only [h, mul_zero, zero_mul, Nat.cast_eq_zero] at hk; simp [hk]\n  lift k to ℕ using hk'\n  exact ⟨k, mod_cast hk⟩\n\n"}
{"name":"Cardinal.nat_is_prime_iff","module":"Mathlib.SetTheory.Cardinal.Divisibility","initialProofState":"n : Nat\n⊢ Iff (Prime ↑n) (Nat.Prime n)","decl":"@[simp]\ntheorem nat_is_prime_iff : Prime (n : Cardinal) ↔ n.Prime := by\n  simp only [Prime, Nat.prime_iff]\n  refine and_congr (by simp) (and_congr ?_ ⟨fun h b c hbc => ?_, fun h b c hbc => ?_⟩)\n  · simp only [isUnit_iff, Nat.isUnit_iff]\n    exact mod_cast Iff.rfl\n  · exact mod_cast h b c (mod_cast hbc)\n  cases' lt_or_le (b * c) ℵ₀ with h' h'\n  · rcases mul_lt_aleph0_iff.mp h' with (rfl | rfl | ⟨hb, hc⟩)\n    · simp\n    · simp\n    lift b to ℕ using hb\n    lift c to ℕ using hc\n    exact mod_cast h b c (mod_cast hbc)\n  rcases aleph0_le_mul_iff.mp h' with ⟨hb, hc, hℵ₀⟩\n  have hn : (n : Cardinal) ≠ 0 := by\n    intro h\n    rw [h, zero_dvd_iff, mul_eq_zero] at hbc\n    cases hbc <;> contradiction\n  wlog hℵ₀b : ℵ₀ ≤ b\n  apply (this h c b _ _ hc hb hℵ₀.symm hn (hℵ₀.resolve_left hℵ₀b)).symm <;> try assumption\n  · rwa [mul_comm] at hbc\n  · rwa [mul_comm] at h'\n  · exact Or.inl (dvd_of_le_of_aleph0_le hn ((nat_lt_aleph0 n).le.trans hℵ₀b) hℵ₀b)\n\n"}
{"name":"Cardinal.is_prime_iff","module":"Mathlib.SetTheory.Cardinal.Divisibility","initialProofState":"a : Cardinal.{u_1}\n⊢ Iff (Prime a) (Or (LE.le Cardinal.aleph0 a) (Exists fun p => And (Eq a ↑p) (Nat.Prime p)))","decl":"theorem is_prime_iff {a : Cardinal} : Prime a ↔ ℵ₀ ≤ a ∨ ∃ p : ℕ, a = p ∧ p.Prime := by\n  rcases le_or_lt ℵ₀ a with h | h\n  · simp [h]\n  lift a to ℕ using id h\n  simp [not_le.mpr h]\n\n"}
{"name":"Cardinal.isPrimePow_iff","module":"Mathlib.SetTheory.Cardinal.Divisibility","initialProofState":"a : Cardinal.{u_1}\n⊢ Iff (IsPrimePow a) (Or (LE.le Cardinal.aleph0 a) (Exists fun n => And (Eq a ↑n) (IsPrimePow n)))","decl":"theorem isPrimePow_iff {a : Cardinal} : IsPrimePow a ↔ ℵ₀ ≤ a ∨ ∃ n : ℕ, a = n ∧ IsPrimePow n := by\n  by_cases h : ℵ₀ ≤ a\n  · simp [h, (prime_of_aleph0_le h).isPrimePow]\n  simp only [h, Nat.cast_inj, exists_eq_left', false_or, isPrimePow_nat_iff]\n  lift a to ℕ using not_le.mp h\n  rw [isPrimePow_def]\n  refine\n    ⟨?_, fun ⟨n, han, p, k, hp, hk, h⟩ =>\n          ⟨p, k, nat_is_prime_iff.2 hp, hk, by rw [han]; exact mod_cast h⟩⟩\n  rintro ⟨p, k, hp, hk, hpk⟩\n  have key : p ^ (1 : Cardinal) ≤ ↑a := by\n    rw [← hpk]; apply power_le_power_left hp.ne_zero; exact mod_cast hk\n  rw [power_one] at key\n  lift p to ℕ using key.trans_lt (nat_lt_aleph0 a)\n  exact ⟨a, rfl, p, k, nat_is_prime_iff.mp hp, hk, mod_cast hpk⟩\n\n"}
