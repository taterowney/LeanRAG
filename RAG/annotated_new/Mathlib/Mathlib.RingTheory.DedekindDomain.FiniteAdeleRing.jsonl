{"name":"DedekindDomain.instTopologicalRingSubtypeAdicCompletionMemValuationSubringAdicCompletionIntegers","module":"Mathlib.RingTheory.DedekindDomain.FiniteAdeleRing","initialProofState":"R : Type u_1\nK : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nv : IsDedekindDomain.HeightOneSpectrum R\n⊢ TopologicalRing (Subtype fun x => Membership.mem (IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers K v) x)","decl":"instance (v : HeightOneSpectrum R) : TopologicalRing (v.adicCompletionIntegers K) :=\n  Subring.instTopologicalRing ..\n\n"}
{"name":"DedekindDomain.instTopologicalRingFiniteIntegralAdeles","module":"Mathlib.RingTheory.DedekindDomain.FiniteAdeleRing","initialProofState":"R : Type u_1\nK : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\n⊢ TopologicalRing (DedekindDomain.FiniteIntegralAdeles R K)","decl":"instance : TopologicalRing (FiniteIntegralAdeles R K) :=\n  inferInstanceAs (TopologicalRing (∀ v : HeightOneSpectrum R, v.adicCompletionIntegers K))\n\n"}
{"name":"DedekindDomain.instTopologicalRingProdAdicCompletions","module":"Mathlib.RingTheory.DedekindDomain.FiniteAdeleRing","initialProofState":"R : Type u_1\nK : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\n⊢ TopologicalRing (DedekindDomain.ProdAdicCompletions R K)","decl":"instance : TopologicalRing (ProdAdicCompletions R K) :=\n  inferInstanceAs (TopologicalRing (∀ v : HeightOneSpectrum R, v.adicCompletion K))\n\n"}
{"name":"DedekindDomain.FiniteIntegralAdeles.coe_apply","module":"Mathlib.RingTheory.DedekindDomain.FiniteAdeleRing","initialProofState":"R : Type u_1\nK : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nx : DedekindDomain.FiniteIntegralAdeles R K\nv : IsDedekindDomain.HeightOneSpectrum R\n⊢ Eq ((fun v => ↑(x v)) v) ↑(x v)","decl":"theorem coe_apply (x : R_hat R K) (v : HeightOneSpectrum R) : (x : K_hat R K) v = ↑(x v) :=\n  rfl\n\n"}
{"name":"DedekindDomain.FiniteIntegralAdeles.Coe.addMonoidHom_apply","module":"Mathlib.RingTheory.DedekindDomain.FiniteAdeleRing","initialProofState":"R : Type u_1\nK : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nx : DedekindDomain.FiniteIntegralAdeles R K\nv : IsDedekindDomain.HeightOneSpectrum R\n⊢ Eq ((DedekindDomain.FiniteIntegralAdeles.Coe.addMonoidHom R K) x v) ↑(x v)","decl":"/-- The inclusion of `R_hat` in `K_hat` as a homomorphism of additive monoids. -/\n@[simps]\ndef Coe.addMonoidHom : AddMonoidHom (R_hat R K) (K_hat R K) where\n  toFun := (↑)\n  map_zero' := rfl\n  map_add' x y := by\n    -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): was `ext v`\n    refine funext fun v => ?_\n    simp only [coe_apply, Pi.add_apply, Subring.coe_add]\n    -- Porting note: added\n    rw [Pi.add_apply, Pi.add_apply, Subring.coe_add]\n\n"}
{"name":"DedekindDomain.FiniteIntegralAdeles.Coe.ringHom_apply","module":"Mathlib.RingTheory.DedekindDomain.FiniteAdeleRing","initialProofState":"R : Type u_1\nK : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nx : DedekindDomain.FiniteIntegralAdeles R K\nv : IsDedekindDomain.HeightOneSpectrum R\n⊢ Eq ((DedekindDomain.FiniteIntegralAdeles.Coe.ringHom R K) x v) ↑(x v)","decl":"/-- The inclusion of `R_hat` in `K_hat` as a ring homomorphism. -/\n@[simps]\ndef Coe.ringHom : RingHom (R_hat R K) (K_hat R K) :=\n  { Coe.addMonoidHom R K with\n    toFun := (↑)\n    map_one' := rfl\n    map_mul' := fun x y => by\n      -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): was `ext p`\n      refine funext fun p => ?_\n      simp only [Pi.mul_apply, Subring.coe_mul]\n      -- Porting note: added\n      rw [Pi.mul_apply, Pi.mul_apply, Subring.coe_mul] }\n\n"}
{"name":"DedekindDomain.ProdAdicCompletions.algebraMap_apply'","module":"Mathlib.RingTheory.DedekindDomain.FiniteAdeleRing","initialProofState":"R : Type u_1\nK : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nv : IsDedekindDomain.HeightOneSpectrum R\nk : K\n⊢ Eq ((algebraMap K (DedekindDomain.ProdAdicCompletions R K)) k v) ↑k","decl":"@[simp]\nlemma ProdAdicCompletions.algebraMap_apply' (k : K) :\n    algebraMap K (K_hat R K) k v = (k : v.adicCompletion K) := rfl\n\n"}
{"name":"DedekindDomain.ProdAdicCompletions.algebraMap_apply","module":"Mathlib.RingTheory.DedekindDomain.FiniteAdeleRing","initialProofState":"R : Type u_1\nK : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nv : IsDedekindDomain.HeightOneSpectrum R\nr : R\n⊢ Eq ((algebraMap R (DedekindDomain.ProdAdicCompletions R K)) r v) ↑((algebraMap R K) r)","decl":"@[simp]\nlemma ProdAdicCompletions.algebraMap_apply (r : R) :\n    algebraMap R (K_hat R K) r v = (algebraMap R K r : v.adicCompletion K) := rfl\n\n"}
{"name":"DedekindDomain.instIsScalarTowerProdAdicCompletions","module":"Mathlib.RingTheory.DedekindDomain.FiniteAdeleRing","initialProofState":"R : Type u_1\nK : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\n⊢ IsScalarTower R K (DedekindDomain.ProdAdicCompletions R K)","decl":"instance : IsScalarTower R K (K_hat R K) :=\n  (by infer_instance : IsScalarTower R K <| ∀ v : HeightOneSpectrum R, v.adicCompletion K)\n\n"}
{"name":"DedekindDomain.ProdAdicCompletions.isScalarTower_completions","module":"Mathlib.RingTheory.DedekindDomain.FiniteAdeleRing","initialProofState":"R : Type u_1\nK : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\n⊢ IsScalarTower R (DedekindDomain.FiniteIntegralAdeles R K) (DedekindDomain.ProdAdicCompletions R K)","decl":"instance ProdAdicCompletions.isScalarTower_completions : IsScalarTower R (R_hat R K) (K_hat R K) :=\n  (by infer_instance :\n    IsScalarTower R (∀ v : HeightOneSpectrum R, v.adicCompletionIntegers K) <|\n      ∀ v : HeightOneSpectrum R, v.adicCompletion K)\n\n"}
{"name":"DedekindDomain.FiniteIntegralAdeles.Coe.algHom_apply","module":"Mathlib.RingTheory.DedekindDomain.FiniteAdeleRing","initialProofState":"R : Type u_1\nK : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nx : DedekindDomain.FiniteIntegralAdeles R K\nv : IsDedekindDomain.HeightOneSpectrum R\n⊢ Eq ((DedekindDomain.FiniteIntegralAdeles.Coe.algHom R K) x v) ↑(x v)","decl":"theorem Coe.algHom_apply (x : R_hat R K) (v : HeightOneSpectrum R) : (Coe.algHom R K) x v = x v :=\n  rfl\n\n"}
{"name":"DedekindDomain.ProdAdicCompletions.isFiniteAdele_iff","module":"Mathlib.RingTheory.DedekindDomain.FiniteAdeleRing","initialProofState":"R : Type u_1\nK : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nx : DedekindDomain.ProdAdicCompletions R K\n⊢ Iff x.IsFiniteAdele (setOf fun v => Not (Membership.mem (IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers K v) (x v))).Finite","decl":"@[simp]\nlemma isFiniteAdele_iff (x : K_hat R K) :\n    x.IsFiniteAdele ↔ {v | x v ∉ adicCompletionIntegers K v}.Finite := Iff.rfl\n\n"}
{"name":"DedekindDomain.ProdAdicCompletions.IsFiniteAdele.add","module":"Mathlib.RingTheory.DedekindDomain.FiniteAdeleRing","initialProofState":"R : Type u_1\nK : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nx y : DedekindDomain.ProdAdicCompletions R K\nhx : x.IsFiniteAdele\nhy : y.IsFiniteAdele\n⊢ (HAdd.hAdd x y).IsFiniteAdele","decl":"/-- The sum of two finite adèles is a finite adèle. -/\ntheorem add {x y : K_hat R K} (hx : x.IsFiniteAdele) (hy : y.IsFiniteAdele) :\n    (x + y).IsFiniteAdele := by\n  rw [IsFiniteAdele, Filter.eventually_cofinite] at hx hy ⊢\n  have h_subset :\n    {v : HeightOneSpectrum R | ¬(x + y) v ∈ v.adicCompletionIntegers K} ⊆\n      {v : HeightOneSpectrum R | ¬x v ∈ v.adicCompletionIntegers K} ∪\n        {v : HeightOneSpectrum R | ¬y v ∈ v.adicCompletionIntegers K} := by\n    intro v hv\n    rw [mem_union, mem_setOf, mem_setOf]\n    rw [mem_setOf] at hv\n    contrapose! hv\n    rw [mem_adicCompletionIntegers, mem_adicCompletionIntegers, ← max_le_iff] at hv\n    rw [mem_adicCompletionIntegers, Pi.add_apply]\n    exact le_trans (Valued.v.map_add_le_max' (x v) (y v)) hv\n  exact (hx.union hy).subset h_subset\n\n"}
{"name":"DedekindDomain.ProdAdicCompletions.IsFiniteAdele.zero","module":"Mathlib.RingTheory.DedekindDomain.FiniteAdeleRing","initialProofState":"R : Type u_1\nK : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\n⊢ DedekindDomain.ProdAdicCompletions.IsFiniteAdele 0","decl":"/-- The tuple `(0)_v` is a finite adèle. -/\ntheorem zero : (0 : K_hat R K).IsFiniteAdele := by\n  rw [IsFiniteAdele, Filter.eventually_cofinite]\n  have h_empty :\n    {v : HeightOneSpectrum R | ¬(0 : v.adicCompletion K) ∈ v.adicCompletionIntegers K} = ∅ := by\n    ext v; rw [mem_empty_iff_false, iff_false]; intro hv\n    rw [mem_setOf] at hv; apply hv; rw [mem_adicCompletionIntegers]\n    have h_zero : (Valued.v (0 : v.adicCompletion K) : WithZero (Multiplicative ℤ)) = 0 :=\n      Valued.v.map_zero'\n    rw [h_zero]; exact zero_le_one' _\n  -- Porting note: was `exact`, but `OfNat` got in the way.\n  convert finite_empty\n\n"}
{"name":"DedekindDomain.ProdAdicCompletions.IsFiniteAdele.neg","module":"Mathlib.RingTheory.DedekindDomain.FiniteAdeleRing","initialProofState":"R : Type u_1\nK : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nx : DedekindDomain.ProdAdicCompletions R K\nhx : x.IsFiniteAdele\n⊢ (Neg.neg x).IsFiniteAdele","decl":"/-- The negative of a finite adèle is a finite adèle. -/\ntheorem neg {x : K_hat R K} (hx : x.IsFiniteAdele) : (-x).IsFiniteAdele := by\n  rw [IsFiniteAdele] at hx ⊢\n  have h :\n    ∀ v : HeightOneSpectrum R,\n      -x v ∈ v.adicCompletionIntegers K ↔ x v ∈ v.adicCompletionIntegers K := by\n    intro v\n    rw [mem_adicCompletionIntegers, mem_adicCompletionIntegers, Valuation.map_neg]\n  -- Porting note: was `simpa only [Pi.neg_apply, h] using hx` but `Pi.neg_apply` no longer works\n  convert hx using 2 with v\n  convert h v\n\n"}
{"name":"DedekindDomain.ProdAdicCompletions.IsFiniteAdele.mul","module":"Mathlib.RingTheory.DedekindDomain.FiniteAdeleRing","initialProofState":"R : Type u_1\nK : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nx y : DedekindDomain.ProdAdicCompletions R K\nhx : x.IsFiniteAdele\nhy : y.IsFiniteAdele\n⊢ (HMul.hMul x y).IsFiniteAdele","decl":"/-- The product of two finite adèles is a finite adèle. -/\ntheorem mul {x y : K_hat R K} (hx : x.IsFiniteAdele) (hy : y.IsFiniteAdele) :\n    (x * y).IsFiniteAdele := by\n  rw [IsFiniteAdele, Filter.eventually_cofinite] at hx hy ⊢\n  have h_subset :\n    {v : HeightOneSpectrum R | ¬(x * y) v ∈ v.adicCompletionIntegers K} ⊆\n      {v : HeightOneSpectrum R | ¬x v ∈ v.adicCompletionIntegers K} ∪\n        {v : HeightOneSpectrum R | ¬y v ∈ v.adicCompletionIntegers K} := by\n    intro v hv\n    rw [mem_union, mem_setOf, mem_setOf]\n    rw [mem_setOf] at hv\n    contrapose! hv\n    rw [mem_adicCompletionIntegers, mem_adicCompletionIntegers] at hv\n    have h_mul : Valued.v (x v * y v) = Valued.v (x v) * Valued.v (y v) :=\n      Valued.v.map_mul' (x v) (y v)\n    rw [mem_adicCompletionIntegers, Pi.mul_apply, h_mul]\n    exact mul_le_one' hv.left hv.right\n  exact (hx.union hy).subset h_subset\n\n"}
{"name":"DedekindDomain.ProdAdicCompletions.IsFiniteAdele.one","module":"Mathlib.RingTheory.DedekindDomain.FiniteAdeleRing","initialProofState":"R : Type u_1\nK : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\n⊢ DedekindDomain.ProdAdicCompletions.IsFiniteAdele 1","decl":"/-- The tuple `(1)_v` is a finite adèle. -/\ntheorem one : (1 : K_hat R K).IsFiniteAdele := by\n  rw [IsFiniteAdele, Filter.eventually_cofinite]\n  have h_empty :\n    {v : HeightOneSpectrum R | ¬(1 : v.adicCompletion K) ∈ v.adicCompletionIntegers K} = ∅ := by\n    ext v; rw [mem_empty_iff_false, iff_false]; intro hv\n    rw [mem_setOf] at hv; apply hv; rw [mem_adicCompletionIntegers]\n    exact le_of_eq Valued.v.map_one'\n  -- Porting note: was `exact`, but `OfNat` got in the way.\n  convert finite_empty\n\n"}
{"name":"DedekindDomain.ProdAdicCompletions.IsFiniteAdele.algebraMap'","module":"Mathlib.RingTheory.DedekindDomain.FiniteAdeleRing","initialProofState":"R : Type u_1\nK : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nk : K\n⊢ ((algebraMap K (DedekindDomain.ProdAdicCompletions R K)) k).IsFiniteAdele","decl":"theorem algebraMap' (k : K) : (_root_.algebraMap K (K_hat R K) k).IsFiniteAdele := by\n  rw [IsFiniteAdele, Filter.eventually_cofinite]\n  simp_rw [mem_adicCompletionIntegers, ProdAdicCompletions.algebraMap_apply',\n    adicCompletion, Valued.valuedCompletion_apply, not_le]\n  change {v : HeightOneSpectrum R | 1 < v.valuation k}.Finite\n  -- The goal currently: if k ∈ K = field of fractions of a Dedekind domain R,\n  -- then v(k)>1 for only finitely many v.\n  -- We now write k=n/d and go via R to solve this goal. Do we need to do this?\n  obtain ⟨⟨n, ⟨d, hd⟩⟩, hk⟩ := IsLocalization.surj (nonZeroDivisors R) k\n  have hd' : d ≠ 0 := nonZeroDivisors.ne_zero hd\n  suffices {v : HeightOneSpectrum R | v.valuation (_root_.algebraMap R K d : K) < 1}.Finite by\n    apply Finite.subset this\n    intro v hv\n    apply_fun v.valuation at hk\n    simp only [Valuation.map_mul, valuation_of_algebraMap] at hk\n    rw [mem_setOf_eq, valuation_of_algebraMap]\n    have := intValuation_le_one v n\n    contrapose! this\n    change 1 < v.intValuation n\n    rw [← hk, mul_comm]\n    exact lt_mul_of_le_of_one_lt' this hv (by simp) (by simp)\n  simp_rw [valuation_of_algebraMap]\n  change {v : HeightOneSpectrum R | v.intValuationDef d < 1}.Finite\n  simp_rw [intValuation_lt_one_iff_dvd]\n  apply Ideal.finite_factors\n  simpa only [Submodule.zero_eq_bot, ne_eq, Ideal.span_singleton_eq_bot]\n\n"}
{"name":"DedekindDomain.FiniteAdeleRing.instIsScalarTower","module":"Mathlib.RingTheory.DedekindDomain.FiniteAdeleRing","initialProofState":"R : Type u_1\nK : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\n⊢ IsScalarTower R K (DedekindDomain.FiniteAdeleRing R K)","decl":"instance : IsScalarTower R K (FiniteAdeleRing R K) :=\n  IsScalarTower.of_algebraMap_eq' rfl\n\n"}
{"name":"DedekindDomain.FiniteAdeleRing.coe_one","module":"Mathlib.RingTheory.DedekindDomain.FiniteAdeleRing","initialProofState":"R : Type u_1\nK : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\n⊢ Eq (↑1) 1","decl":"@[simp, norm_cast]\ntheorem coe_one : (1 : FiniteAdeleRing R K) = (1 : K_hat R K) := rfl\n\n"}
{"name":"DedekindDomain.FiniteAdeleRing.coe_zero","module":"Mathlib.RingTheory.DedekindDomain.FiniteAdeleRing","initialProofState":"R : Type u_1\nK : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\n⊢ Eq (↑0) 0","decl":"@[simp, norm_cast]\ntheorem coe_zero: (0 : FiniteAdeleRing R K) = (0 : K_hat R K) := rfl\n\n"}
{"name":"DedekindDomain.FiniteAdeleRing.coe_add","module":"Mathlib.RingTheory.DedekindDomain.FiniteAdeleRing","initialProofState":"R : Type u_1\nK : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nx y : DedekindDomain.FiniteAdeleRing R K\n⊢ Eq (↑(HAdd.hAdd x y)) (HAdd.hAdd ↑x ↑y)","decl":"@[simp, norm_cast]\ntheorem coe_add (x y : FiniteAdeleRing R K) : (x + y : FiniteAdeleRing R K) =\n  (x : K_hat R K) + (y : K_hat R K) := rfl\n\n"}
{"name":"DedekindDomain.FiniteAdeleRing.coe_mul","module":"Mathlib.RingTheory.DedekindDomain.FiniteAdeleRing","initialProofState":"R : Type u_1\nK : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nx y : DedekindDomain.FiniteAdeleRing R K\n⊢ Eq (↑(HMul.hMul x y)) (HMul.hMul ↑x ↑y)","decl":"@[simp, norm_cast]\ntheorem coe_mul (x y : FiniteAdeleRing R K) : (x * y : FiniteAdeleRing R K) =\n  (x : K_hat R K) * (y : K_hat R K) := rfl\n\n"}
{"name":"DedekindDomain.FiniteAdeleRing.coe_algebraMap","module":"Mathlib.RingTheory.DedekindDomain.FiniteAdeleRing","initialProofState":"R : Type u_1\nK : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nx : K\n⊢ Eq (↑((algebraMap K (DedekindDomain.FiniteAdeleRing R K)) x)) ((algebraMap K (DedekindDomain.ProdAdicCompletions R K)) x)","decl":"@[simp, norm_cast]\ntheorem coe_algebraMap (x : K) : (((algebraMap K (FiniteAdeleRing R K)) x) : K_hat R K) =\n      (algebraMap K (ProdAdicCompletions R K)) x := rfl\n\n"}
{"name":"DedekindDomain.FiniteAdeleRing.ext_iff","module":"Mathlib.RingTheory.DedekindDomain.FiniteAdeleRing","initialProofState":"R : Type u_1\nK : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\na₁ a₂ : DedekindDomain.FiniteAdeleRing R K\n⊢ Iff (Eq a₁ a₂) (Eq ↑a₁ ↑a₂)","decl":"@[ext]\nlemma ext {a₁ a₂ : FiniteAdeleRing R K} (h : (a₁ : K_hat R K) = a₂) : a₁ = a₂ :=\n  Subtype.ext h\n\n"}
{"name":"DedekindDomain.FiniteAdeleRing.ext","module":"Mathlib.RingTheory.DedekindDomain.FiniteAdeleRing","initialProofState":"R : Type u_1\nK : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\na₁ a₂ : DedekindDomain.FiniteAdeleRing R K\nh : Eq ↑a₁ ↑a₂\n⊢ Eq a₁ a₂","decl":"@[ext]\nlemma ext {a₁ a₂ : FiniteAdeleRing R K} (h : (a₁ : K_hat R K) = a₂) : a₁ = a₂ :=\n  Subtype.ext h\n\n"}
{"name":"DedekindDomain.FiniteAdeleRing.exists_finiteIntegralAdele_iff","module":"Mathlib.RingTheory.DedekindDomain.FiniteAdeleRing","initialProofState":"R : Type u_1\nK : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\na : DedekindDomain.FiniteAdeleRing R K\n⊢ Iff (Exists fun c => Eq a ↑c) (∀ (v : IsDedekindDomain.HeightOneSpectrum R), Membership.mem (IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers K v) ((fun v => ↑a v) v))","decl":"variable {R K} in\nlemma exists_finiteIntegralAdele_iff (a : FiniteAdeleRing R K) : (∃ c : R_hat R K,\n    a = c) ↔ ∀ (v : HeightOneSpectrum R), a v ∈ adicCompletionIntegers K v :=\n  ⟨by rintro ⟨c, rfl⟩ v; exact (c v).2, fun h ↦ ⟨fun v ↦ ⟨a v, h v⟩, rfl⟩⟩\n\n"}
{"name":"DedekindDomain.FiniteAdeleRing.mul_nonZeroDivisor_mem_finiteIntegralAdeles","module":"Mathlib.RingTheory.DedekindDomain.FiniteAdeleRing","initialProofState":"R : Type u_1\nK : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\na : DedekindDomain.FiniteAdeleRing R K\n⊢ Exists fun b => Exists fun c => Eq (HMul.hMul a ↑↑b) ↑c","decl":"variable {R K} in\nlemma mul_nonZeroDivisor_mem_finiteIntegralAdeles (a : FiniteAdeleRing R K) :\n    ∃ (b : R⁰) (c : R_hat R K), a * ((b : R) : FiniteAdeleRing R K) = c := by\n  let S := {v | a v ∉ adicCompletionIntegers K v}\n  choose b hb h using adicCompletion.mul_nonZeroDivisor_mem_adicCompletionIntegers (R := R) (K := K)\n  let p := ∏ᶠ v ∈ S, b v (a v)\n  have hp : p ∈ R⁰ := finprod_mem_induction (· ∈ R⁰) (one_mem _) (fun _ _ => mul_mem) <|\n    fun _ _ ↦ hb _ _\n  use ⟨p, hp⟩\n  rw [exists_finiteIntegralAdele_iff]\n  intro v\n  by_cases hv : a v ∈ adicCompletionIntegers K v\n  · exact mul_mem hv <| coe_mem_adicCompletionIntegers _ _\n  · dsimp only\n    have pprod : p = b v (a v) * ∏ᶠ w ∈ S \\ {v}, b w (a w) := by\n      rw [← finprod_mem_singleton (a := v) (f := fun v ↦ b v (a v)),\n        finprod_mem_mul_diff (singleton_subset_iff.2 ‹v ∈ S›) a.2]\n    rw [pprod]\n    push_cast\n    rw [← mul_assoc]\n    exact mul_mem (h v (a v)) <| coe_mem_adicCompletionIntegers _ _\n\n"}
{"name":"DedekindDomain.FiniteAdeleRing.submodulesRingBasis","module":"Mathlib.RingTheory.DedekindDomain.FiniteAdeleRing","initialProofState":"R : Type u_1\nK : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\n⊢ SubmodulesRingBasis fun r => Submodule.span (DedekindDomain.FiniteIntegralAdeles R K) (Singleton.singleton ↑↑r)","decl":"theorem submodulesRingBasis : SubmodulesRingBasis\n    (fun (r : R⁰) ↦ Submodule.span (R_hat R K) {((r : R) : FiniteAdeleRing R K)}) where\n  inter i j := ⟨i * j, by\n    push_cast\n    simp only [le_inf_iff, Submodule.span_singleton_le_iff_mem, Submodule.mem_span_singleton]\n    exact ⟨⟨((j : R) : R_hat R K), by rw [mul_comm]; rfl⟩, ⟨((i : R) : R_hat R K), rfl⟩⟩⟩\n  leftMul a r := by\n    rcases mul_nonZeroDivisor_mem_finiteIntegralAdeles a with ⟨b, c, h⟩\n    use r * b\n    rintro x ⟨m, hm, rfl⟩\n    simp only [Submonoid.coe_mul, SetLike.mem_coe] at hm\n    rw [Submodule.mem_span_singleton] at hm ⊢\n    rcases hm with ⟨n, rfl⟩\n    simp only [LinearMapClass.map_smul, DistribMulAction.toLinearMap_apply, smul_eq_mul]\n    use n * c\n    push_cast\n    rw [mul_left_comm, h, mul_comm _ (c : FiniteAdeleRing R K),\n      Algebra.smul_def', Algebra.smul_def', ← mul_assoc]\n    rfl\n  mul r := ⟨r, by\n    intro x hx\n    rw [mem_mul] at hx\n    rcases hx with ⟨a, ha, b, hb, rfl⟩\n    simp only [SetLike.mem_coe, Submodule.mem_span_singleton] at ha hb ⊢\n    rcases ha with ⟨m, rfl⟩\n    rcases hb with ⟨n, rfl⟩\n    use m * n * (r : R)\n    simp only [Algebra.smul_def', map_mul]\n    rw [mul_mul_mul_comm, mul_assoc]\n    rfl⟩\n\n"}
