{"name":"ContinuousLinearMap.hasDerivWithinAt_of_bilinear","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nE : Type w\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nG : Type u_1\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nx : ğ•œ\ns : Set ğ•œ\nB : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) F G)\nu : ğ•œ â†’ E\nv : ğ•œ â†’ F\nu' : E\nv' : F\nhu : HasDerivWithinAt u u' s x\nhv : HasDerivWithinAt v v' s x\nâŠ¢ HasDerivWithinAt (fun x => (B (u x)) (v x)) (HAdd.hAdd ((B (u x)) v') ((B u') (v x))) s x","decl":"theorem hasDerivWithinAt_of_bilinear\n    (hu : HasDerivWithinAt u u' s x) (hv : HasDerivWithinAt v v' s x) :\n    HasDerivWithinAt (fun x â†¦ B (u x) (v x)) (B (u x) v' + B u' (v x)) s x := by\n  simpa using (B.hasFDerivWithinAt_of_bilinear\n    hu.hasFDerivWithinAt hv.hasFDerivWithinAt).hasDerivWithinAt\n\n"}
{"name":"ContinuousLinearMap.hasDerivAt_of_bilinear","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nE : Type w\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nG : Type u_1\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nx : ğ•œ\nB : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) F G)\nu : ğ•œ â†’ E\nv : ğ•œ â†’ F\nu' : E\nv' : F\nhu : HasDerivAt u u' x\nhv : HasDerivAt v v' x\nâŠ¢ HasDerivAt (fun x => (B (u x)) (v x)) (HAdd.hAdd ((B (u x)) v') ((B u') (v x))) x","decl":"theorem hasDerivAt_of_bilinear (hu : HasDerivAt u u' x) (hv : HasDerivAt v v' x) :\n    HasDerivAt (fun x â†¦ B (u x) (v x)) (B (u x) v' + B u' (v x)) x := by\n  simpa using (B.hasFDerivAt_of_bilinear hu.hasFDerivAt hv.hasFDerivAt).hasDerivAt\n\n"}
{"name":"ContinuousLinearMap.hasStrictDerivAt_of_bilinear","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nE : Type w\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nG : Type u_1\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nx : ğ•œ\nB : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) F G)\nu : ğ•œ â†’ E\nv : ğ•œ â†’ F\nu' : E\nv' : F\nhu : HasStrictDerivAt u u' x\nhv : HasStrictDerivAt v v' x\nâŠ¢ HasStrictDerivAt (fun x => (B (u x)) (v x)) (HAdd.hAdd ((B (u x)) v') ((B u') (v x))) x","decl":"theorem hasStrictDerivAt_of_bilinear (hu : HasStrictDerivAt u u' x) (hv : HasStrictDerivAt v v' x) :\n    HasStrictDerivAt (fun x â†¦ B (u x) (v x)) (B (u x) v' + B u' (v x)) x := by\n  simpa using\n    (B.hasStrictFDerivAt_of_bilinear hu.hasStrictFDerivAt hv.hasStrictFDerivAt).hasStrictDerivAt\n\n"}
{"name":"ContinuousLinearMap.derivWithin_of_bilinear","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nE : Type w\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nG : Type u_1\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nx : ğ•œ\ns : Set ğ•œ\nB : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) F G)\nu : ğ•œ â†’ E\nv : ğ•œ â†’ F\nhu : DifferentiableWithinAt ğ•œ u s x\nhv : DifferentiableWithinAt ğ•œ v s x\nâŠ¢ Eq (derivWithin (fun y => (B (u y)) (v y)) s x) (HAdd.hAdd ((B (u x)) (derivWithin v s x)) ((B (derivWithin u s x)) (v x)))","decl":"theorem derivWithin_of_bilinear\n    (hu : DifferentiableWithinAt ğ•œ u s x) (hv : DifferentiableWithinAt ğ•œ v s x) :\n    derivWithin (fun y => B (u y) (v y)) s x =\n      B (u x) (derivWithin v s x) + B (derivWithin u s x) (v x) := by\n  rcases uniqueDiffWithinAt_or_nhdsWithin_eq_bot s x with hxs | hxs\n  Â· exact (B.hasDerivWithinAt_of_bilinear hu.hasDerivWithinAt hv.hasDerivWithinAt).derivWithin hxs\n  Â· simp [derivWithin_zero_of_isolated hxs]\n\n"}
{"name":"ContinuousLinearMap.deriv_of_bilinear","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nE : Type w\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nG : Type u_1\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nx : ğ•œ\nB : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) F G)\nu : ğ•œ â†’ E\nv : ğ•œ â†’ F\nhu : DifferentiableAt ğ•œ u x\nhv : DifferentiableAt ğ•œ v x\nâŠ¢ Eq (deriv (fun y => (B (u y)) (v y)) x) (HAdd.hAdd ((B (u x)) (deriv v x)) ((B (deriv u x)) (v x)))","decl":"theorem deriv_of_bilinear (hu : DifferentiableAt ğ•œ u x) (hv : DifferentiableAt ğ•œ v x) :\n    deriv (fun y => B (u y) (v y)) x = B (u x) (deriv v x) + B (deriv u x) (v x) :=\n  (B.hasDerivAt_of_bilinear hu.hasDerivAt hv.hasDerivAt).deriv\n\n"}
{"name":"HasDerivWithinAt.smul","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nf : ğ•œ â†’ F\nf' : F\nx : ğ•œ\ns : Set ğ•œ\nğ•œ' : Type u_2\ninstâœÂ³ : NontriviallyNormedField ğ•œ'\ninstâœÂ² : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ¹ : NormedSpace ğ•œ' F\ninstâœ : IsScalarTower ğ•œ ğ•œ' F\nc : ğ•œ â†’ ğ•œ'\nc' : ğ•œ'\nhc : HasDerivWithinAt c c' s x\nhf : HasDerivWithinAt f f' s x\nâŠ¢ HasDerivWithinAt (fun y => HSMul.hSMul (c y) (f y)) (HAdd.hAdd (HSMul.hSMul (c x) f') (HSMul.hSMul c' (f x))) s x","decl":"theorem HasDerivWithinAt.smul (hc : HasDerivWithinAt c c' s x) (hf : HasDerivWithinAt f f' s x) :\n    HasDerivWithinAt (fun y => c y â€¢ f y) (c x â€¢ f' + c' â€¢ f x) s x := by\n  simpa using (HasFDerivWithinAt.smul hc hf).hasDerivWithinAt\n\n"}
{"name":"HasDerivAt.smul","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nf : ğ•œ â†’ F\nf' : F\nx : ğ•œ\nğ•œ' : Type u_2\ninstâœÂ³ : NontriviallyNormedField ğ•œ'\ninstâœÂ² : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ¹ : NormedSpace ğ•œ' F\ninstâœ : IsScalarTower ğ•œ ğ•œ' F\nc : ğ•œ â†’ ğ•œ'\nc' : ğ•œ'\nhc : HasDerivAt c c' x\nhf : HasDerivAt f f' x\nâŠ¢ HasDerivAt (fun y => HSMul.hSMul (c y) (f y)) (HAdd.hAdd (HSMul.hSMul (c x) f') (HSMul.hSMul c' (f x))) x","decl":"theorem HasDerivAt.smul (hc : HasDerivAt c c' x) (hf : HasDerivAt f f' x) :\n    HasDerivAt (fun y => c y â€¢ f y) (c x â€¢ f' + c' â€¢ f x) x := by\n  rw [â† hasDerivWithinAt_univ] at *\n  exact hc.smul hf\n\n"}
{"name":"HasStrictDerivAt.smul","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nf : ğ•œ â†’ F\nf' : F\nx : ğ•œ\nğ•œ' : Type u_2\ninstâœÂ³ : NontriviallyNormedField ğ•œ'\ninstâœÂ² : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ¹ : NormedSpace ğ•œ' F\ninstâœ : IsScalarTower ğ•œ ğ•œ' F\nc : ğ•œ â†’ ğ•œ'\nc' : ğ•œ'\nhc : HasStrictDerivAt c c' x\nhf : HasStrictDerivAt f f' x\nâŠ¢ HasStrictDerivAt (fun y => HSMul.hSMul (c y) (f y)) (HAdd.hAdd (HSMul.hSMul (c x) f') (HSMul.hSMul c' (f x))) x","decl":"nonrec theorem HasStrictDerivAt.smul (hc : HasStrictDerivAt c c' x) (hf : HasStrictDerivAt f f' x) :\n    HasStrictDerivAt (fun y => c y â€¢ f y) (c x â€¢ f' + c' â€¢ f x) x := by\n  simpa using (hc.smul hf).hasStrictDerivAt\n\n"}
{"name":"derivWithin_smul","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nf : ğ•œ â†’ F\nx : ğ•œ\ns : Set ğ•œ\nğ•œ' : Type u_2\ninstâœÂ³ : NontriviallyNormedField ğ•œ'\ninstâœÂ² : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ¹ : NormedSpace ğ•œ' F\ninstâœ : IsScalarTower ğ•œ ğ•œ' F\nc : ğ•œ â†’ ğ•œ'\nhc : DifferentiableWithinAt ğ•œ c s x\nhf : DifferentiableWithinAt ğ•œ f s x\nâŠ¢ Eq (derivWithin (fun y => HSMul.hSMul (c y) (f y)) s x) (HAdd.hAdd (HSMul.hSMul (c x) (derivWithin f s x)) (HSMul.hSMul (derivWithin c s x) (f x)))","decl":"theorem derivWithin_smul (hc : DifferentiableWithinAt ğ•œ c s x)\n    (hf : DifferentiableWithinAt ğ•œ f s x) :\n    derivWithin (fun y => c y â€¢ f y) s x = c x â€¢ derivWithin f s x + derivWithin c s x â€¢ f x := by\n  rcases uniqueDiffWithinAt_or_nhdsWithin_eq_bot s x with hxs | hxs\n  Â· exact (hc.hasDerivWithinAt.smul hf.hasDerivWithinAt).derivWithin hxs\n  Â· simp [derivWithin_zero_of_isolated hxs]\n\n"}
{"name":"deriv_smul","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nf : ğ•œ â†’ F\nx : ğ•œ\nğ•œ' : Type u_2\ninstâœÂ³ : NontriviallyNormedField ğ•œ'\ninstâœÂ² : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ¹ : NormedSpace ğ•œ' F\ninstâœ : IsScalarTower ğ•œ ğ•œ' F\nc : ğ•œ â†’ ğ•œ'\nhc : DifferentiableAt ğ•œ c x\nhf : DifferentiableAt ğ•œ f x\nâŠ¢ Eq (deriv (fun y => HSMul.hSMul (c y) (f y)) x) (HAdd.hAdd (HSMul.hSMul (c x) (deriv f x)) (HSMul.hSMul (deriv c x) (f x)))","decl":"theorem deriv_smul (hc : DifferentiableAt ğ•œ c x) (hf : DifferentiableAt ğ•œ f x) :\n    deriv (fun y => c y â€¢ f y) x = c x â€¢ deriv f x + deriv c x â€¢ f x :=\n  (hc.hasDerivAt.smul hf.hasDerivAt).deriv\n\n"}
{"name":"HasStrictDerivAt.smul_const","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nx : ğ•œ\nğ•œ' : Type u_2\ninstâœÂ³ : NontriviallyNormedField ğ•œ'\ninstâœÂ² : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ¹ : NormedSpace ğ•œ' F\ninstâœ : IsScalarTower ğ•œ ğ•œ' F\nc : ğ•œ â†’ ğ•œ'\nc' : ğ•œ'\nhc : HasStrictDerivAt c c' x\nf : F\nâŠ¢ HasStrictDerivAt (fun y => HSMul.hSMul (c y) f) (HSMul.hSMul c' f) x","decl":"theorem HasStrictDerivAt.smul_const (hc : HasStrictDerivAt c c' x) (f : F) :\n    HasStrictDerivAt (fun y => c y â€¢ f) (c' â€¢ f) x := by\n  have := hc.smul (hasStrictDerivAt_const x f)\n  rwa [smul_zero, zero_add] at this\n\n"}
{"name":"HasDerivWithinAt.smul_const","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nx : ğ•œ\ns : Set ğ•œ\nğ•œ' : Type u_2\ninstâœÂ³ : NontriviallyNormedField ğ•œ'\ninstâœÂ² : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ¹ : NormedSpace ğ•œ' F\ninstâœ : IsScalarTower ğ•œ ğ•œ' F\nc : ğ•œ â†’ ğ•œ'\nc' : ğ•œ'\nhc : HasDerivWithinAt c c' s x\nf : F\nâŠ¢ HasDerivWithinAt (fun y => HSMul.hSMul (c y) f) (HSMul.hSMul c' f) s x","decl":"theorem HasDerivWithinAt.smul_const (hc : HasDerivWithinAt c c' s x) (f : F) :\n    HasDerivWithinAt (fun y => c y â€¢ f) (c' â€¢ f) s x := by\n  have := hc.smul (hasDerivWithinAt_const x s f)\n  rwa [smul_zero, zero_add] at this\n\n"}
{"name":"HasDerivAt.smul_const","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nx : ğ•œ\nğ•œ' : Type u_2\ninstâœÂ³ : NontriviallyNormedField ğ•œ'\ninstâœÂ² : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ¹ : NormedSpace ğ•œ' F\ninstâœ : IsScalarTower ğ•œ ğ•œ' F\nc : ğ•œ â†’ ğ•œ'\nc' : ğ•œ'\nhc : HasDerivAt c c' x\nf : F\nâŠ¢ HasDerivAt (fun y => HSMul.hSMul (c y) f) (HSMul.hSMul c' f) x","decl":"theorem HasDerivAt.smul_const (hc : HasDerivAt c c' x) (f : F) :\n    HasDerivAt (fun y => c y â€¢ f) (c' â€¢ f) x := by\n  rw [â† hasDerivWithinAt_univ] at *\n  exact hc.smul_const f\n\n"}
{"name":"derivWithin_smul_const","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nx : ğ•œ\ns : Set ğ•œ\nğ•œ' : Type u_2\ninstâœÂ³ : NontriviallyNormedField ğ•œ'\ninstâœÂ² : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ¹ : NormedSpace ğ•œ' F\ninstâœ : IsScalarTower ğ•œ ğ•œ' F\nc : ğ•œ â†’ ğ•œ'\nhc : DifferentiableWithinAt ğ•œ c s x\nf : F\nâŠ¢ Eq (derivWithin (fun y => HSMul.hSMul (c y) f) s x) (HSMul.hSMul (derivWithin c s x) f)","decl":"theorem derivWithin_smul_const (hc : DifferentiableWithinAt ğ•œ c s x) (f : F) :\n    derivWithin (fun y => c y â€¢ f) s x = derivWithin c s x â€¢ f := by\n  rcases uniqueDiffWithinAt_or_nhdsWithin_eq_bot s x with hxs | hxs\n  Â· exact (hc.hasDerivWithinAt.smul_const f).derivWithin hxs\n  Â· simp [derivWithin_zero_of_isolated hxs]\n\n"}
{"name":"deriv_smul_const","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nx : ğ•œ\nğ•œ' : Type u_2\ninstâœÂ³ : NontriviallyNormedField ğ•œ'\ninstâœÂ² : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ¹ : NormedSpace ğ•œ' F\ninstâœ : IsScalarTower ğ•œ ğ•œ' F\nc : ğ•œ â†’ ğ•œ'\nhc : DifferentiableAt ğ•œ c x\nf : F\nâŠ¢ Eq (deriv (fun y => HSMul.hSMul (c y) f) x) (HSMul.hSMul (deriv c x) f)","decl":"theorem deriv_smul_const (hc : DifferentiableAt ğ•œ c x) (f : F) :\n    deriv (fun y => c y â€¢ f) x = deriv c x â€¢ f :=\n  (hc.hasDerivAt.smul_const f).deriv\n\n"}
{"name":"HasStrictDerivAt.const_smul","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nf : ğ•œ â†’ F\nf' : F\nx : ğ•œ\nR : Type u_2\ninstâœÂ³ : Semiring R\ninstâœÂ² : Module R F\ninstâœÂ¹ : SMulCommClass ğ•œ R F\ninstâœ : ContinuousConstSMul R F\nc : R\nhf : HasStrictDerivAt f f' x\nâŠ¢ HasStrictDerivAt (fun y => HSMul.hSMul c (f y)) (HSMul.hSMul c f') x","decl":"nonrec theorem HasStrictDerivAt.const_smul (c : R) (hf : HasStrictDerivAt f f' x) :\n    HasStrictDerivAt (fun y => c â€¢ f y) (c â€¢ f') x := by\n  simpa using (hf.const_smul c).hasStrictDerivAt\n\n"}
{"name":"HasDerivAtFilter.const_smul","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nf : ğ•œ â†’ F\nf' : F\nx : ğ•œ\nL : Filter ğ•œ\nR : Type u_2\ninstâœÂ³ : Semiring R\ninstâœÂ² : Module R F\ninstâœÂ¹ : SMulCommClass ğ•œ R F\ninstâœ : ContinuousConstSMul R F\nc : R\nhf : HasDerivAtFilter f f' x L\nâŠ¢ HasDerivAtFilter (fun y => HSMul.hSMul c (f y)) (HSMul.hSMul c f') x L","decl":"nonrec theorem HasDerivAtFilter.const_smul (c : R) (hf : HasDerivAtFilter f f' x L) :\n    HasDerivAtFilter (fun y => c â€¢ f y) (c â€¢ f') x L := by\n  simpa using (hf.const_smul c).hasDerivAtFilter\n\n"}
{"name":"HasDerivWithinAt.const_smul","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nf : ğ•œ â†’ F\nf' : F\nx : ğ•œ\ns : Set ğ•œ\nR : Type u_2\ninstâœÂ³ : Semiring R\ninstâœÂ² : Module R F\ninstâœÂ¹ : SMulCommClass ğ•œ R F\ninstâœ : ContinuousConstSMul R F\nc : R\nhf : HasDerivWithinAt f f' s x\nâŠ¢ HasDerivWithinAt (fun y => HSMul.hSMul c (f y)) (HSMul.hSMul c f') s x","decl":"nonrec theorem HasDerivWithinAt.const_smul (c : R) (hf : HasDerivWithinAt f f' s x) :\n    HasDerivWithinAt (fun y => c â€¢ f y) (c â€¢ f') s x :=\n  hf.const_smul c\n\n"}
{"name":"HasDerivAt.const_smul","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nf : ğ•œ â†’ F\nf' : F\nx : ğ•œ\nR : Type u_2\ninstâœÂ³ : Semiring R\ninstâœÂ² : Module R F\ninstâœÂ¹ : SMulCommClass ğ•œ R F\ninstâœ : ContinuousConstSMul R F\nc : R\nhf : HasDerivAt f f' x\nâŠ¢ HasDerivAt (fun y => HSMul.hSMul c (f y)) (HSMul.hSMul c f') x","decl":"nonrec theorem HasDerivAt.const_smul (c : R) (hf : HasDerivAt f f' x) :\n    HasDerivAt (fun y => c â€¢ f y) (c â€¢ f') x :=\n  hf.const_smul c\n\n"}
{"name":"derivWithin_const_smul","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nf : ğ•œ â†’ F\nx : ğ•œ\ns : Set ğ•œ\nR : Type u_2\ninstâœÂ³ : Semiring R\ninstâœÂ² : Module R F\ninstâœÂ¹ : SMulCommClass ğ•œ R F\ninstâœ : ContinuousConstSMul R F\nc : R\nhf : DifferentiableWithinAt ğ•œ f s x\nâŠ¢ Eq (derivWithin (fun y => HSMul.hSMul c (f y)) s x) (HSMul.hSMul c (derivWithin f s x))","decl":"theorem derivWithin_const_smul (c : R) (hf : DifferentiableWithinAt ğ•œ f s x) :\n    derivWithin (fun y => c â€¢ f y) s x = c â€¢ derivWithin f s x := by\n  rcases uniqueDiffWithinAt_or_nhdsWithin_eq_bot s x with hxs | hxs\n  Â· exact (hf.hasDerivWithinAt.const_smul c).derivWithin hxs\n  Â· simp [derivWithin_zero_of_isolated hxs]\n\n"}
{"name":"deriv_const_smul","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nf : ğ•œ â†’ F\nx : ğ•œ\nR : Type u_2\ninstâœÂ³ : Semiring R\ninstâœÂ² : Module R F\ninstâœÂ¹ : SMulCommClass ğ•œ R F\ninstâœ : ContinuousConstSMul R F\nc : R\nhf : DifferentiableAt ğ•œ f x\nâŠ¢ Eq (deriv (fun y => HSMul.hSMul c (f y)) x) (HSMul.hSMul c (deriv f x))","decl":"theorem deriv_const_smul (c : R) (hf : DifferentiableAt ğ•œ f x) :\n    deriv (fun y => c â€¢ f y) x = c â€¢ deriv f x :=\n  (hf.hasDerivAt.const_smul c).deriv\n\n"}
{"name":"deriv_const_smul'","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nf : ğ•œ â†’ F\nx : ğ•œ\nR : Type u_3\ninstâœÂ³ : Field R\ninstâœÂ² : Module R F\ninstâœÂ¹ : SMulCommClass ğ•œ R F\ninstâœ : ContinuousConstSMul R F\nc : R\nâŠ¢ Eq (deriv (fun y => HSMul.hSMul c (f y)) x) (HSMul.hSMul c (deriv f x))","decl":"/-- A variant of `deriv_const_smul` without differentiability assumption when the scalar\nmultiplication is by field elements. -/\nlemma deriv_const_smul' {f : ğ•œ â†’ F} {x : ğ•œ} {R : Type*} [Field R] [Module R F] [SMulCommClass ğ•œ R F]\n    [ContinuousConstSMul R F] (c : R) :\n    deriv (fun y â†¦ c â€¢ f y) x = c â€¢ deriv f x := by\n  by_cases hf : DifferentiableAt ğ•œ f x\n  Â· exact deriv_const_smul c hf\n  Â· rcases eq_or_ne c 0 with rfl | hc\n    Â· simp only [zero_smul, deriv_const']\n    Â· have H : Â¬DifferentiableAt ğ•œ (fun y â†¦ c â€¢ f y) x := by\n        contrapose! hf\n        conv => enter [2, y]; rw [â† inv_smul_smulâ‚€ hc (f y)]\n        exact DifferentiableAt.const_smul hf câ»Â¹\n      rw [deriv_zero_of_not_differentiableAt hf, deriv_zero_of_not_differentiableAt H, smul_zero]\n\n"}
{"name":"HasDerivWithinAt.mul","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nx : ğ•œ\ns : Set ğ•œ\nğ”¸ : Type u_3\ninstâœÂ¹ : NormedRing ğ”¸\ninstâœ : NormedAlgebra ğ•œ ğ”¸\nc d : ğ•œ â†’ ğ”¸\nc' d' : ğ”¸\nhc : HasDerivWithinAt c c' s x\nhd : HasDerivWithinAt d d' s x\nâŠ¢ HasDerivWithinAt (fun y => HMul.hMul (c y) (d y)) (HAdd.hAdd (HMul.hMul c' (d x)) (HMul.hMul (c x) d')) s x","decl":"theorem HasDerivWithinAt.mul (hc : HasDerivWithinAt c c' s x) (hd : HasDerivWithinAt d d' s x) :\n    HasDerivWithinAt (fun y => c y * d y) (c' * d x + c x * d') s x := by\n  have := (HasFDerivWithinAt.mul' hc hd).hasDerivWithinAt\n  rwa [ContinuousLinearMap.add_apply, ContinuousLinearMap.smul_apply,\n    ContinuousLinearMap.smulRight_apply, ContinuousLinearMap.smulRight_apply,\n    ContinuousLinearMap.smulRight_apply, ContinuousLinearMap.one_apply, one_smul, one_smul,\n    add_comm] at this\n\n"}
{"name":"HasDerivAt.mul","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nx : ğ•œ\nğ”¸ : Type u_3\ninstâœÂ¹ : NormedRing ğ”¸\ninstâœ : NormedAlgebra ğ•œ ğ”¸\nc d : ğ•œ â†’ ğ”¸\nc' d' : ğ”¸\nhc : HasDerivAt c c' x\nhd : HasDerivAt d d' x\nâŠ¢ HasDerivAt (fun y => HMul.hMul (c y) (d y)) (HAdd.hAdd (HMul.hMul c' (d x)) (HMul.hMul (c x) d')) x","decl":"theorem HasDerivAt.mul (hc : HasDerivAt c c' x) (hd : HasDerivAt d d' x) :\n    HasDerivAt (fun y => c y * d y) (c' * d x + c x * d') x := by\n  rw [â† hasDerivWithinAt_univ] at *\n  exact hc.mul hd\n\n"}
{"name":"HasStrictDerivAt.mul","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nx : ğ•œ\nğ”¸ : Type u_3\ninstâœÂ¹ : NormedRing ğ”¸\ninstâœ : NormedAlgebra ğ•œ ğ”¸\nc d : ğ•œ â†’ ğ”¸\nc' d' : ğ”¸\nhc : HasStrictDerivAt c c' x\nhd : HasStrictDerivAt d d' x\nâŠ¢ HasStrictDerivAt (fun y => HMul.hMul (c y) (d y)) (HAdd.hAdd (HMul.hMul c' (d x)) (HMul.hMul (c x) d')) x","decl":"theorem HasStrictDerivAt.mul (hc : HasStrictDerivAt c c' x) (hd : HasStrictDerivAt d d' x) :\n    HasStrictDerivAt (fun y => c y * d y) (c' * d x + c x * d') x := by\n  have := (HasStrictFDerivAt.mul' hc hd).hasStrictDerivAt\n  rwa [ContinuousLinearMap.add_apply, ContinuousLinearMap.smul_apply,\n    ContinuousLinearMap.smulRight_apply, ContinuousLinearMap.smulRight_apply,\n    ContinuousLinearMap.smulRight_apply, ContinuousLinearMap.one_apply, one_smul, one_smul,\n    add_comm] at this\n\n"}
{"name":"derivWithin_mul","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nx : ğ•œ\ns : Set ğ•œ\nğ”¸ : Type u_3\ninstâœÂ¹ : NormedRing ğ”¸\ninstâœ : NormedAlgebra ğ•œ ğ”¸\nc d : ğ•œ â†’ ğ”¸\nhc : DifferentiableWithinAt ğ•œ c s x\nhd : DifferentiableWithinAt ğ•œ d s x\nâŠ¢ Eq (derivWithin (fun y => HMul.hMul (c y) (d y)) s x) (HAdd.hAdd (HMul.hMul (derivWithin c s x) (d x)) (HMul.hMul (c x) (derivWithin d s x)))","decl":"theorem derivWithin_mul (hc : DifferentiableWithinAt ğ•œ c s x)\n    (hd : DifferentiableWithinAt ğ•œ d s x) :\n    derivWithin (fun y => c y * d y) s x = derivWithin c s x * d x + c x * derivWithin d s x := by\n  rcases uniqueDiffWithinAt_or_nhdsWithin_eq_bot s x with hxs | hxs\n  Â· exact (hc.hasDerivWithinAt.mul hd.hasDerivWithinAt).derivWithin hxs\n  Â· simp [derivWithin_zero_of_isolated hxs]\n\n"}
{"name":"deriv_mul","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nx : ğ•œ\nğ”¸ : Type u_3\ninstâœÂ¹ : NormedRing ğ”¸\ninstâœ : NormedAlgebra ğ•œ ğ”¸\nc d : ğ•œ â†’ ğ”¸\nhc : DifferentiableAt ğ•œ c x\nhd : DifferentiableAt ğ•œ d x\nâŠ¢ Eq (deriv (fun y => HMul.hMul (c y) (d y)) x) (HAdd.hAdd (HMul.hMul (deriv c x) (d x)) (HMul.hMul (c x) (deriv d x)))","decl":"@[simp]\ntheorem deriv_mul (hc : DifferentiableAt ğ•œ c x) (hd : DifferentiableAt ğ•œ d x) :\n    deriv (fun y => c y * d y) x = deriv c x * d x + c x * deriv d x :=\n  (hc.hasDerivAt.mul hd.hasDerivAt).deriv\n\n"}
{"name":"HasDerivWithinAt.mul_const","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nx : ğ•œ\ns : Set ğ•œ\nğ”¸ : Type u_3\ninstâœÂ¹ : NormedRing ğ”¸\ninstâœ : NormedAlgebra ğ•œ ğ”¸\nc : ğ•œ â†’ ğ”¸\nc' : ğ”¸\nhc : HasDerivWithinAt c c' s x\nd : ğ”¸\nâŠ¢ HasDerivWithinAt (fun y => HMul.hMul (c y) d) (HMul.hMul c' d) s x","decl":"theorem HasDerivWithinAt.mul_const (hc : HasDerivWithinAt c c' s x) (d : ğ”¸) :\n    HasDerivWithinAt (fun y => c y * d) (c' * d) s x := by\n  convert hc.mul (hasDerivWithinAt_const x s d) using 1\n  rw [mul_zero, add_zero]\n\n"}
{"name":"HasDerivAt.mul_const","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nx : ğ•œ\nğ”¸ : Type u_3\ninstâœÂ¹ : NormedRing ğ”¸\ninstâœ : NormedAlgebra ğ•œ ğ”¸\nc : ğ•œ â†’ ğ”¸\nc' : ğ”¸\nhc : HasDerivAt c c' x\nd : ğ”¸\nâŠ¢ HasDerivAt (fun y => HMul.hMul (c y) d) (HMul.hMul c' d) x","decl":"theorem HasDerivAt.mul_const (hc : HasDerivAt c c' x) (d : ğ”¸) :\n    HasDerivAt (fun y => c y * d) (c' * d) x := by\n  rw [â† hasDerivWithinAt_univ] at *\n  exact hc.mul_const d\n\n"}
{"name":"hasDerivAt_mul_const","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœ : NontriviallyNormedField ğ•œ\nx c : ğ•œ\nâŠ¢ HasDerivAt (fun x => HMul.hMul x c) c x","decl":"theorem hasDerivAt_mul_const (c : ğ•œ) : HasDerivAt (fun x => x * c) c x := by\n  simpa only [one_mul] using (hasDerivAt_id' x).mul_const c\n\n"}
{"name":"HasStrictDerivAt.mul_const","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nx : ğ•œ\nğ”¸ : Type u_3\ninstâœÂ¹ : NormedRing ğ”¸\ninstâœ : NormedAlgebra ğ•œ ğ”¸\nc : ğ•œ â†’ ğ”¸\nc' : ğ”¸\nhc : HasStrictDerivAt c c' x\nd : ğ”¸\nâŠ¢ HasStrictDerivAt (fun y => HMul.hMul (c y) d) (HMul.hMul c' d) x","decl":"theorem HasStrictDerivAt.mul_const (hc : HasStrictDerivAt c c' x) (d : ğ”¸) :\n    HasStrictDerivAt (fun y => c y * d) (c' * d) x := by\n  convert hc.mul (hasStrictDerivAt_const x d) using 1\n  rw [mul_zero, add_zero]\n\n"}
{"name":"derivWithin_mul_const","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nx : ğ•œ\ns : Set ğ•œ\nğ”¸ : Type u_3\ninstâœÂ¹ : NormedRing ğ”¸\ninstâœ : NormedAlgebra ğ•œ ğ”¸\nc : ğ•œ â†’ ğ”¸\nhc : DifferentiableWithinAt ğ•œ c s x\nd : ğ”¸\nâŠ¢ Eq (derivWithin (fun y => HMul.hMul (c y) d) s x) (HMul.hMul (derivWithin c s x) d)","decl":"theorem derivWithin_mul_const (hc : DifferentiableWithinAt ğ•œ c s x) (d : ğ”¸) :\n    derivWithin (fun y => c y * d) s x = derivWithin c s x * d := by\n  rcases uniqueDiffWithinAt_or_nhdsWithin_eq_bot s x with hxs | hxs\n  Â· exact (hc.hasDerivWithinAt.mul_const d).derivWithin hxs\n  Â· simp [derivWithin_zero_of_isolated hxs]\n\n"}
{"name":"derivWithin_mul_const_field","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nx : ğ•œ\ns : Set ğ•œ\nğ•œ' : Type u_2\ninstâœÂ¹ : NormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nv : ğ•œ â†’ ğ•œ'\nu : ğ•œ'\nâŠ¢ Eq (derivWithin (fun y => HMul.hMul (v y) u) s x) (HMul.hMul (derivWithin v s x) u)","decl":"lemma derivWithin_mul_const_field (u : ğ•œ') :\n    derivWithin (fun y => v y * u) s x = derivWithin v s x * u := by\n  by_cases hv : DifferentiableWithinAt ğ•œ v s x\n  Â· rw [derivWithin_mul_const hv u]\n  by_cases hu : u = 0\n  Â· simp [hu]\n  rw [derivWithin_zero_of_not_differentiableWithinAt hv, zero_mul,\n      derivWithin_zero_of_not_differentiableWithinAt]\n  have : v = fun x â†¦ (v x * u) * uâ»Â¹ := by ext; simp [hu]\n  exact fun h_diff â†¦ hv <| this â–¸ h_diff.mul_const _\n\n"}
{"name":"deriv_mul_const","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nx : ğ•œ\nğ”¸ : Type u_3\ninstâœÂ¹ : NormedRing ğ”¸\ninstâœ : NormedAlgebra ğ•œ ğ”¸\nc : ğ•œ â†’ ğ”¸\nhc : DifferentiableAt ğ•œ c x\nd : ğ”¸\nâŠ¢ Eq (deriv (fun y => HMul.hMul (c y) d) x) (HMul.hMul (deriv c x) d)","decl":"theorem deriv_mul_const (hc : DifferentiableAt ğ•œ c x) (d : ğ”¸) :\n    deriv (fun y => c y * d) x = deriv c x * d :=\n  (hc.hasDerivAt.mul_const d).deriv\n\n"}
{"name":"deriv_mul_const_field","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nx : ğ•œ\nğ•œ' : Type u_2\ninstâœÂ¹ : NormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nu : ğ•œ â†’ ğ•œ'\nv : ğ•œ'\nâŠ¢ Eq (deriv (fun y => HMul.hMul (u y) v) x) (HMul.hMul (deriv u x) v)","decl":"theorem deriv_mul_const_field (v : ğ•œ') : deriv (fun y => u y * v) x = deriv u x * v := by\n  by_cases hu : DifferentiableAt ğ•œ u x\n  Â· exact deriv_mul_const hu v\n  Â· rw [deriv_zero_of_not_differentiableAt hu, zero_mul]\n    rcases eq_or_ne v 0 with (rfl | hd)\n    Â· simp only [mul_zero, deriv_const]\n    Â· refine deriv_zero_of_not_differentiableAt (mt (fun H => ?_) hu)\n      simpa only [mul_inv_cancel_rightâ‚€ hd] using H.mul_const vâ»Â¹\n\n"}
{"name":"deriv_mul_const_field'","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nğ•œ' : Type u_2\ninstâœÂ¹ : NormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nu : ğ•œ â†’ ğ•œ'\nv : ğ•œ'\nâŠ¢ Eq (deriv fun x => HMul.hMul (u x) v) fun x => HMul.hMul (deriv u x) v","decl":"@[simp]\ntheorem deriv_mul_const_field' (v : ğ•œ') : (deriv fun x => u x * v) = fun x => deriv u x * v :=\n  funext fun _ => deriv_mul_const_field v\n\n"}
{"name":"HasDerivWithinAt.const_mul","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nx : ğ•œ\ns : Set ğ•œ\nğ”¸ : Type u_3\ninstâœÂ¹ : NormedRing ğ”¸\ninstâœ : NormedAlgebra ğ•œ ğ”¸\nd : ğ•œ â†’ ğ”¸\nd' c : ğ”¸\nhd : HasDerivWithinAt d d' s x\nâŠ¢ HasDerivWithinAt (fun y => HMul.hMul c (d y)) (HMul.hMul c d') s x","decl":"theorem HasDerivWithinAt.const_mul (c : ğ”¸) (hd : HasDerivWithinAt d d' s x) :\n    HasDerivWithinAt (fun y => c * d y) (c * d') s x := by\n  convert (hasDerivWithinAt_const x s c).mul hd using 1\n  rw [zero_mul, zero_add]\n\n"}
{"name":"HasDerivAt.const_mul","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nx : ğ•œ\nğ”¸ : Type u_3\ninstâœÂ¹ : NormedRing ğ”¸\ninstâœ : NormedAlgebra ğ•œ ğ”¸\nd : ğ•œ â†’ ğ”¸\nd' c : ğ”¸\nhd : HasDerivAt d d' x\nâŠ¢ HasDerivAt (fun y => HMul.hMul c (d y)) (HMul.hMul c d') x","decl":"theorem HasDerivAt.const_mul (c : ğ”¸) (hd : HasDerivAt d d' x) :\n    HasDerivAt (fun y => c * d y) (c * d') x := by\n  rw [â† hasDerivWithinAt_univ] at *\n  exact hd.const_mul c\n\n"}
{"name":"HasStrictDerivAt.const_mul","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nx : ğ•œ\nğ”¸ : Type u_3\ninstâœÂ¹ : NormedRing ğ”¸\ninstâœ : NormedAlgebra ğ•œ ğ”¸\nd : ğ•œ â†’ ğ”¸\nd' c : ğ”¸\nhd : HasStrictDerivAt d d' x\nâŠ¢ HasStrictDerivAt (fun y => HMul.hMul c (d y)) (HMul.hMul c d') x","decl":"theorem HasStrictDerivAt.const_mul (c : ğ”¸) (hd : HasStrictDerivAt d d' x) :\n    HasStrictDerivAt (fun y => c * d y) (c * d') x := by\n  convert (hasStrictDerivAt_const _ _).mul hd using 1\n  rw [zero_mul, zero_add]\n\n"}
{"name":"derivWithin_const_mul","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nx : ğ•œ\ns : Set ğ•œ\nğ”¸ : Type u_3\ninstâœÂ¹ : NormedRing ğ”¸\ninstâœ : NormedAlgebra ğ•œ ğ”¸\nd : ğ•œ â†’ ğ”¸\nc : ğ”¸\nhd : DifferentiableWithinAt ğ•œ d s x\nâŠ¢ Eq (derivWithin (fun y => HMul.hMul c (d y)) s x) (HMul.hMul c (derivWithin d s x))","decl":"theorem derivWithin_const_mul (c : ğ”¸) (hd : DifferentiableWithinAt ğ•œ d s x) :\n    derivWithin (fun y => c * d y) s x = c * derivWithin d s x := by\n  rcases uniqueDiffWithinAt_or_nhdsWithin_eq_bot s x with hxs | hxs\n  Â· exact (hd.hasDerivWithinAt.const_mul c).derivWithin hxs\n  Â· simp [derivWithin_zero_of_isolated hxs]\n\n"}
{"name":"derivWithin_const_mul_field","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nx : ğ•œ\ns : Set ğ•œ\nğ•œ' : Type u_2\ninstâœÂ¹ : NormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nv : ğ•œ â†’ ğ•œ'\nu : ğ•œ'\nâŠ¢ Eq (derivWithin (fun y => HMul.hMul u (v y)) s x) (HMul.hMul u (derivWithin v s x))","decl":"lemma derivWithin_const_mul_field (u : ğ•œ') :\n    derivWithin (fun y => u * v y) s x = u * derivWithin v s x := by\n  simp_rw [mul_comm u]\n  exact derivWithin_mul_const_field u\n\n"}
{"name":"deriv_const_mul","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nx : ğ•œ\nğ”¸ : Type u_3\ninstâœÂ¹ : NormedRing ğ”¸\ninstâœ : NormedAlgebra ğ•œ ğ”¸\nd : ğ•œ â†’ ğ”¸\nc : ğ”¸\nhd : DifferentiableAt ğ•œ d x\nâŠ¢ Eq (deriv (fun y => HMul.hMul c (d y)) x) (HMul.hMul c (deriv d x))","decl":"theorem deriv_const_mul (c : ğ”¸) (hd : DifferentiableAt ğ•œ d x) :\n    deriv (fun y => c * d y) x = c * deriv d x :=\n  (hd.hasDerivAt.const_mul c).deriv\n\n"}
{"name":"deriv_const_mul_field","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nx : ğ•œ\nğ•œ' : Type u_2\ninstâœÂ¹ : NormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nv : ğ•œ â†’ ğ•œ'\nu : ğ•œ'\nâŠ¢ Eq (deriv (fun y => HMul.hMul u (v y)) x) (HMul.hMul u (deriv v x))","decl":"theorem deriv_const_mul_field (u : ğ•œ') : deriv (fun y => u * v y) x = u * deriv v x := by\n  simp only [mul_comm u, deriv_mul_const_field]\n\n"}
{"name":"deriv_const_mul_field'","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nğ•œ' : Type u_2\ninstâœÂ¹ : NormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nv : ğ•œ â†’ ğ•œ'\nu : ğ•œ'\nâŠ¢ Eq (deriv fun x => HMul.hMul u (v x)) fun x => HMul.hMul u (deriv v x)","decl":"@[simp]\ntheorem deriv_const_mul_field' (u : ğ•œ') : (deriv fun x => u * v x) = fun x => u * deriv v x :=\n  funext fun _ => deriv_const_mul_field u\n\n"}
{"name":"HasDerivAt.finset_prod","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nx : ğ•œ\nÎ¹ : Type u_2\ninstâœÂ² : DecidableEq Î¹\nğ”¸' : Type u_3\ninstâœÂ¹ : NormedCommRing ğ”¸'\ninstâœ : NormedAlgebra ğ•œ ğ”¸'\nu : Finset Î¹\nf : Î¹ â†’ ğ•œ â†’ ğ”¸'\nf' : Î¹ â†’ ğ”¸'\nhf : âˆ€ (i : Î¹), Membership.mem u i â†’ HasDerivAt (f i) (f' i) x\nâŠ¢ HasDerivAt (fun x => u.prod fun i => f i x) (u.sum fun i => HSMul.hSMul ((u.erase i).prod fun j => f j x) (f' i)) x","decl":"theorem HasDerivAt.finset_prod (hf : âˆ€ i âˆˆ u, HasDerivAt (f i) (f' i) x) :\n    HasDerivAt (âˆ i âˆˆ u, f i Â·) (âˆ‘ i âˆˆ u, (âˆ j âˆˆ u.erase i, f j x) â€¢ f' i) x := by\n  simpa [ContinuousLinearMap.sum_apply, ContinuousLinearMap.smul_apply] using\n    (HasFDerivAt.finset_prod (fun i hi â†¦ (hf i hi).hasFDerivAt)).hasDerivAt\n\n"}
{"name":"HasDerivWithinAt.finset_prod","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nx : ğ•œ\ns : Set ğ•œ\nÎ¹ : Type u_2\ninstâœÂ² : DecidableEq Î¹\nğ”¸' : Type u_3\ninstâœÂ¹ : NormedCommRing ğ”¸'\ninstâœ : NormedAlgebra ğ•œ ğ”¸'\nu : Finset Î¹\nf : Î¹ â†’ ğ•œ â†’ ğ”¸'\nf' : Î¹ â†’ ğ”¸'\nhf : âˆ€ (i : Î¹), Membership.mem u i â†’ HasDerivWithinAt (f i) (f' i) s x\nâŠ¢ HasDerivWithinAt (fun x => u.prod fun i => f i x) (u.sum fun i => HSMul.hSMul ((u.erase i).prod fun j => f j x) (f' i)) s x","decl":"theorem HasDerivWithinAt.finset_prod (hf : âˆ€ i âˆˆ u, HasDerivWithinAt (f i) (f' i) s x) :\n    HasDerivWithinAt (âˆ i âˆˆ u, f i Â·) (âˆ‘ i âˆˆ u, (âˆ j âˆˆ u.erase i, f j x) â€¢ f' i) s x := by\n  simpa [ContinuousLinearMap.sum_apply, ContinuousLinearMap.smul_apply] using\n    (HasFDerivWithinAt.finset_prod (fun i hi â†¦ (hf i hi).hasFDerivWithinAt)).hasDerivWithinAt\n\n"}
{"name":"HasStrictDerivAt.finset_prod","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nx : ğ•œ\nÎ¹ : Type u_2\ninstâœÂ² : DecidableEq Î¹\nğ”¸' : Type u_3\ninstâœÂ¹ : NormedCommRing ğ”¸'\ninstâœ : NormedAlgebra ğ•œ ğ”¸'\nu : Finset Î¹\nf : Î¹ â†’ ğ•œ â†’ ğ”¸'\nf' : Î¹ â†’ ğ”¸'\nhf : âˆ€ (i : Î¹), Membership.mem u i â†’ HasStrictDerivAt (f i) (f' i) x\nâŠ¢ HasStrictDerivAt (fun x => u.prod fun i => f i x) (u.sum fun i => HSMul.hSMul ((u.erase i).prod fun j => f j x) (f' i)) x","decl":"theorem HasStrictDerivAt.finset_prod (hf : âˆ€ i âˆˆ u, HasStrictDerivAt (f i) (f' i) x) :\n    HasStrictDerivAt (âˆ i âˆˆ u, f i Â·) (âˆ‘ i âˆˆ u, (âˆ j âˆˆ u.erase i, f j x) â€¢ f' i) x := by\n  simpa [ContinuousLinearMap.sum_apply, ContinuousLinearMap.smul_apply] using\n    (HasStrictFDerivAt.finset_prod (fun i hi â†¦ (hf i hi).hasStrictFDerivAt)).hasStrictDerivAt\n\n"}
{"name":"deriv_finset_prod","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nx : ğ•œ\nÎ¹ : Type u_2\ninstâœÂ² : DecidableEq Î¹\nğ”¸' : Type u_3\ninstâœÂ¹ : NormedCommRing ğ”¸'\ninstâœ : NormedAlgebra ğ•œ ğ”¸'\nu : Finset Î¹\nf : Î¹ â†’ ğ•œ â†’ ğ”¸'\nhf : âˆ€ (i : Î¹), Membership.mem u i â†’ DifferentiableAt ğ•œ (f i) x\nâŠ¢ Eq (deriv (fun x => u.prod fun i => f i x) x) (u.sum fun i => HSMul.hSMul ((u.erase i).prod fun j => f j x) (deriv (f i) x))","decl":"theorem deriv_finset_prod (hf : âˆ€ i âˆˆ u, DifferentiableAt ğ•œ (f i) x) :\n    deriv (âˆ i âˆˆ u, f i Â·) x = âˆ‘ i âˆˆ u, (âˆ j âˆˆ u.erase i, f j x) â€¢ deriv (f i) x :=\n  (HasDerivAt.finset_prod fun i hi â†¦ (hf i hi).hasDerivAt).deriv\n\n"}
{"name":"derivWithin_finset_prod","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nx : ğ•œ\ns : Set ğ•œ\nÎ¹ : Type u_2\ninstâœÂ² : DecidableEq Î¹\nğ”¸' : Type u_3\ninstâœÂ¹ : NormedCommRing ğ”¸'\ninstâœ : NormedAlgebra ğ•œ ğ”¸'\nu : Finset Î¹\nf : Î¹ â†’ ğ•œ â†’ ğ”¸'\nhf : âˆ€ (i : Î¹), Membership.mem u i â†’ DifferentiableWithinAt ğ•œ (f i) s x\nâŠ¢ Eq (derivWithin (fun x => u.prod fun i => f i x) s x) (u.sum fun i => HSMul.hSMul ((u.erase i).prod fun j => f j x) (derivWithin (f i) s x))","decl":"theorem derivWithin_finset_prod\n    (hf : âˆ€ i âˆˆ u, DifferentiableWithinAt ğ•œ (f i) s x) :\n    derivWithin (âˆ i âˆˆ u, f i Â·) s x =\n      âˆ‘ i âˆˆ u, (âˆ j âˆˆ u.erase i, f j x) â€¢ derivWithin (f i) s x := by\n  rcases uniqueDiffWithinAt_or_nhdsWithin_eq_bot s x with hxs | hxs\n  Â· exact (HasDerivWithinAt.finset_prod fun i hi â†¦ (hf i hi).hasDerivWithinAt).derivWithin hxs\n  Â· simp [derivWithin_zero_of_isolated hxs]\n\n"}
{"name":"DifferentiableAt.finset_prod","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nx : ğ•œ\nÎ¹ : Type u_2\nğ”¸' : Type u_3\ninstâœÂ¹ : NormedCommRing ğ”¸'\ninstâœ : NormedAlgebra ğ•œ ğ”¸'\nu : Finset Î¹\nf : Î¹ â†’ ğ•œ â†’ ğ”¸'\nhd : âˆ€ (i : Î¹), Membership.mem u i â†’ DifferentiableAt ğ•œ (f i) x\nâŠ¢ DifferentiableAt ğ•œ (fun x => u.prod fun i => f i x) x","decl":"@[fun_prop]\ntheorem DifferentiableAt.finset_prod (hd : âˆ€ i âˆˆ u, DifferentiableAt ğ•œ (f i) x) :\n    DifferentiableAt ğ•œ (âˆ i âˆˆ u, f i Â·) x := by\n  classical\n  exact\n    (HasDerivAt.finset_prod (fun i hi â†¦ DifferentiableAt.hasDerivAt (hd i hi))).differentiableAt\n\n"}
{"name":"DifferentiableWithinAt.finset_prod","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nx : ğ•œ\ns : Set ğ•œ\nÎ¹ : Type u_2\nğ”¸' : Type u_3\ninstâœÂ¹ : NormedCommRing ğ”¸'\ninstâœ : NormedAlgebra ğ•œ ğ”¸'\nu : Finset Î¹\nf : Î¹ â†’ ğ•œ â†’ ğ”¸'\nhd : âˆ€ (i : Î¹), Membership.mem u i â†’ DifferentiableWithinAt ğ•œ (f i) s x\nâŠ¢ DifferentiableWithinAt ğ•œ (fun x => u.prod fun i => f i x) s x","decl":"@[fun_prop]\ntheorem DifferentiableWithinAt.finset_prod (hd : âˆ€ i âˆˆ u, DifferentiableWithinAt ğ•œ (f i) s x) :\n    DifferentiableWithinAt ğ•œ (âˆ i âˆˆ u, f i Â·) s x := by\n  classical\n  exact (HasDerivWithinAt.finset_prod (fun i hi â†¦\n    DifferentiableWithinAt.hasDerivWithinAt (hd i hi))).differentiableWithinAt\n\n"}
{"name":"DifferentiableOn.finset_prod","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\ns : Set ğ•œ\nÎ¹ : Type u_2\nğ”¸' : Type u_3\ninstâœÂ¹ : NormedCommRing ğ”¸'\ninstâœ : NormedAlgebra ğ•œ ğ”¸'\nu : Finset Î¹\nf : Î¹ â†’ ğ•œ â†’ ğ”¸'\nhd : âˆ€ (i : Î¹), Membership.mem u i â†’ DifferentiableOn ğ•œ (f i) s\nâŠ¢ DifferentiableOn ğ•œ (fun x => u.prod fun i => f i x) s","decl":"@[fun_prop]\ntheorem DifferentiableOn.finset_prod (hd : âˆ€ i âˆˆ u, DifferentiableOn ğ•œ (f i) s) :\n    DifferentiableOn ğ•œ (âˆ i âˆˆ u, f i Â·) s :=\n  fun x hx â†¦ .finset_prod (fun i hi â†¦ hd i hi x hx)\n\n"}
{"name":"Differentiable.finset_prod","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nÎ¹ : Type u_2\nğ”¸' : Type u_3\ninstâœÂ¹ : NormedCommRing ğ”¸'\ninstâœ : NormedAlgebra ğ•œ ğ”¸'\nu : Finset Î¹\nf : Î¹ â†’ ğ•œ â†’ ğ”¸'\nhd : âˆ€ (i : Î¹), Membership.mem u i â†’ Differentiable ğ•œ (f i)\nâŠ¢ Differentiable ğ•œ fun x => u.prod fun i => f i x","decl":"@[fun_prop]\ntheorem Differentiable.finset_prod (hd : âˆ€ i âˆˆ u, Differentiable ğ•œ (f i)) :\n    Differentiable ğ•œ (âˆ i âˆˆ u, f i Â·) :=\n  fun x â†¦ .finset_prod (fun i hi â†¦ hd i hi x)\n\n"}
{"name":"HasDerivAt.div_const","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nx : ğ•œ\nğ•œ' : Type u_2\ninstâœÂ¹ : NontriviallyNormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nc : ğ•œ â†’ ğ•œ'\nc' : ğ•œ'\nhc : HasDerivAt c c' x\nd : ğ•œ'\nâŠ¢ HasDerivAt (fun x => HDiv.hDiv (c x) d) (HDiv.hDiv c' d) x","decl":"theorem HasDerivAt.div_const (hc : HasDerivAt c c' x) (d : ğ•œ') :\n    HasDerivAt (fun x => c x / d) (c' / d) x := by\n  simpa only [div_eq_mul_inv] using hc.mul_const dâ»Â¹\n\n"}
{"name":"HasDerivWithinAt.div_const","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nx : ğ•œ\ns : Set ğ•œ\nğ•œ' : Type u_2\ninstâœÂ¹ : NontriviallyNormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nc : ğ•œ â†’ ğ•œ'\nc' : ğ•œ'\nhc : HasDerivWithinAt c c' s x\nd : ğ•œ'\nâŠ¢ HasDerivWithinAt (fun x => HDiv.hDiv (c x) d) (HDiv.hDiv c' d) s x","decl":"theorem HasDerivWithinAt.div_const (hc : HasDerivWithinAt c c' s x) (d : ğ•œ') :\n    HasDerivWithinAt (fun x => c x / d) (c' / d) s x := by\n  simpa only [div_eq_mul_inv] using hc.mul_const dâ»Â¹\n\n"}
{"name":"HasStrictDerivAt.div_const","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nx : ğ•œ\nğ•œ' : Type u_2\ninstâœÂ¹ : NontriviallyNormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nc : ğ•œ â†’ ğ•œ'\nc' : ğ•œ'\nhc : HasStrictDerivAt c c' x\nd : ğ•œ'\nâŠ¢ HasStrictDerivAt (fun x => HDiv.hDiv (c x) d) (HDiv.hDiv c' d) x","decl":"theorem HasStrictDerivAt.div_const (hc : HasStrictDerivAt c c' x) (d : ğ•œ') :\n    HasStrictDerivAt (fun x => c x / d) (c' / d) x := by\n  simpa only [div_eq_mul_inv] using hc.mul_const dâ»Â¹\n\n"}
{"name":"DifferentiableWithinAt.div_const","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nx : ğ•œ\ns : Set ğ•œ\nğ•œ' : Type u_2\ninstâœÂ¹ : NontriviallyNormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nc : ğ•œ â†’ ğ•œ'\nhc : DifferentiableWithinAt ğ•œ c s x\nd : ğ•œ'\nâŠ¢ DifferentiableWithinAt ğ•œ (fun x => HDiv.hDiv (c x) d) s x","decl":"@[fun_prop]\ntheorem DifferentiableWithinAt.div_const (hc : DifferentiableWithinAt ğ•œ c s x) (d : ğ•œ') :\n    DifferentiableWithinAt ğ•œ (fun x => c x / d) s x :=\n  (hc.hasDerivWithinAt.div_const _).differentiableWithinAt\n\n"}
{"name":"DifferentiableAt.div_const","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nx : ğ•œ\nğ•œ' : Type u_2\ninstâœÂ¹ : NontriviallyNormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nc : ğ•œ â†’ ğ•œ'\nhc : DifferentiableAt ğ•œ c x\nd : ğ•œ'\nâŠ¢ DifferentiableAt ğ•œ (fun x => HDiv.hDiv (c x) d) x","decl":"@[simp, fun_prop]\ntheorem DifferentiableAt.div_const (hc : DifferentiableAt ğ•œ c x) (d : ğ•œ') :\n    DifferentiableAt ğ•œ (fun x => c x / d) x :=\n  (hc.hasDerivAt.div_const _).differentiableAt\n\n"}
{"name":"DifferentiableOn.div_const","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\ns : Set ğ•œ\nğ•œ' : Type u_2\ninstâœÂ¹ : NontriviallyNormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nc : ğ•œ â†’ ğ•œ'\nhc : DifferentiableOn ğ•œ c s\nd : ğ•œ'\nâŠ¢ DifferentiableOn ğ•œ (fun x => HDiv.hDiv (c x) d) s","decl":"@[fun_prop]\ntheorem DifferentiableOn.div_const (hc : DifferentiableOn ğ•œ c s) (d : ğ•œ') :\n    DifferentiableOn ğ•œ (fun x => c x / d) s := fun x hx => (hc x hx).div_const d\n\n"}
{"name":"Differentiable.div_const","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nğ•œ' : Type u_2\ninstâœÂ¹ : NontriviallyNormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nc : ğ•œ â†’ ğ•œ'\nhc : Differentiable ğ•œ c\nd : ğ•œ'\nâŠ¢ Differentiable ğ•œ fun x => HDiv.hDiv (c x) d","decl":"@[simp, fun_prop]\ntheorem Differentiable.div_const (hc : Differentiable ğ•œ c) (d : ğ•œ') :\n    Differentiable ğ•œ fun x => c x / d := fun x => (hc x).div_const d\n\n"}
{"name":"derivWithin_div_const","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nx : ğ•œ\ns : Set ğ•œ\nğ•œ' : Type u_2\ninstâœÂ¹ : NontriviallyNormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nc : ğ•œ â†’ ğ•œ'\nhc : DifferentiableWithinAt ğ•œ c s x\nd : ğ•œ'\nâŠ¢ Eq (derivWithin (fun x => HDiv.hDiv (c x) d) s x) (HDiv.hDiv (derivWithin c s x) d)","decl":"theorem derivWithin_div_const (hc : DifferentiableWithinAt ğ•œ c s x) (d : ğ•œ') :\n    derivWithin (fun x => c x / d) s x = derivWithin c s x / d := by\n  simp [div_eq_inv_mul, derivWithin_const_mul, hc]\n\n"}
{"name":"deriv_div_const","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nx : ğ•œ\nğ•œ' : Type u_2\ninstâœÂ¹ : NontriviallyNormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nc : ğ•œ â†’ ğ•œ'\nd : ğ•œ'\nâŠ¢ Eq (deriv (fun x => HDiv.hDiv (c x) d) x) (HDiv.hDiv (deriv c x) d)","decl":"@[simp]\ntheorem deriv_div_const (d : ğ•œ') : deriv (fun x => c x / d) x = deriv c x / d := by\n  simp only [div_eq_mul_inv, deriv_mul_const_field]\n\n"}
{"name":"HasStrictDerivAt.clm_comp","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nE : Type w\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nx : ğ•œ\nG : Type u_2\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nc : ğ•œ â†’ ContinuousLinearMap (RingHom.id ğ•œ) F G\nc' : ContinuousLinearMap (RingHom.id ğ•œ) F G\nd : ğ•œ â†’ ContinuousLinearMap (RingHom.id ğ•œ) E F\nd' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nhc : HasStrictDerivAt c c' x\nhd : HasStrictDerivAt d d' x\nâŠ¢ HasStrictDerivAt (fun y => (c y).comp (d y)) (HAdd.hAdd (c'.comp (d x)) ((c x).comp d')) x","decl":"theorem HasStrictDerivAt.clm_comp (hc : HasStrictDerivAt c c' x) (hd : HasStrictDerivAt d d' x) :\n    HasStrictDerivAt (fun y => (c y).comp (d y)) (c'.comp (d x) + (c x).comp d') x := by\n  have := (hc.hasStrictFDerivAt.clm_comp hd.hasStrictFDerivAt).hasStrictDerivAt\n  rwa [add_apply, comp_apply, comp_apply, smulRight_apply, smulRight_apply, one_apply, one_smul,\n    one_smul, add_comm] at this\n\n"}
{"name":"HasDerivWithinAt.clm_comp","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nE : Type w\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nx : ğ•œ\ns : Set ğ•œ\nG : Type u_2\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nc : ğ•œ â†’ ContinuousLinearMap (RingHom.id ğ•œ) F G\nc' : ContinuousLinearMap (RingHom.id ğ•œ) F G\nd : ğ•œ â†’ ContinuousLinearMap (RingHom.id ğ•œ) E F\nd' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nhc : HasDerivWithinAt c c' s x\nhd : HasDerivWithinAt d d' s x\nâŠ¢ HasDerivWithinAt (fun y => (c y).comp (d y)) (HAdd.hAdd (c'.comp (d x)) ((c x).comp d')) s x","decl":"theorem HasDerivWithinAt.clm_comp (hc : HasDerivWithinAt c c' s x)\n    (hd : HasDerivWithinAt d d' s x) :\n    HasDerivWithinAt (fun y => (c y).comp (d y)) (c'.comp (d x) + (c x).comp d') s x := by\n  have := (hc.hasFDerivWithinAt.clm_comp hd.hasFDerivWithinAt).hasDerivWithinAt\n  rwa [add_apply, comp_apply, comp_apply, smulRight_apply, smulRight_apply, one_apply, one_smul,\n    one_smul, add_comm] at this\n\n"}
{"name":"HasDerivAt.clm_comp","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nE : Type w\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nx : ğ•œ\nG : Type u_2\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nc : ğ•œ â†’ ContinuousLinearMap (RingHom.id ğ•œ) F G\nc' : ContinuousLinearMap (RingHom.id ğ•œ) F G\nd : ğ•œ â†’ ContinuousLinearMap (RingHom.id ğ•œ) E F\nd' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nhc : HasDerivAt c c' x\nhd : HasDerivAt d d' x\nâŠ¢ HasDerivAt (fun y => (c y).comp (d y)) (HAdd.hAdd (c'.comp (d x)) ((c x).comp d')) x","decl":"theorem HasDerivAt.clm_comp (hc : HasDerivAt c c' x) (hd : HasDerivAt d d' x) :\n    HasDerivAt (fun y => (c y).comp (d y)) (c'.comp (d x) + (c x).comp d') x := by\n  rw [â† hasDerivWithinAt_univ] at *\n  exact hc.clm_comp hd\n\n"}
{"name":"derivWithin_clm_comp","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nE : Type w\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nx : ğ•œ\ns : Set ğ•œ\nG : Type u_2\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nc : ğ•œ â†’ ContinuousLinearMap (RingHom.id ğ•œ) F G\nd : ğ•œ â†’ ContinuousLinearMap (RingHom.id ğ•œ) E F\nhc : DifferentiableWithinAt ğ•œ c s x\nhd : DifferentiableWithinAt ğ•œ d s x\nâŠ¢ Eq (derivWithin (fun y => (c y).comp (d y)) s x) (HAdd.hAdd ((derivWithin c s x).comp (d x)) ((c x).comp (derivWithin d s x)))","decl":"theorem derivWithin_clm_comp (hc : DifferentiableWithinAt ğ•œ c s x)\n    (hd : DifferentiableWithinAt ğ•œ d s x) :\n    derivWithin (fun y => (c y).comp (d y)) s x =\n      (derivWithin c s x).comp (d x) + (c x).comp (derivWithin d s x) := by\n  rcases uniqueDiffWithinAt_or_nhdsWithin_eq_bot s x with hxs | hxs\n  Â· exact (hc.hasDerivWithinAt.clm_comp hd.hasDerivWithinAt).derivWithin hxs\n  Â· simp [derivWithin_zero_of_isolated hxs]\n\n"}
{"name":"deriv_clm_comp","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nE : Type w\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nx : ğ•œ\nG : Type u_2\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nc : ğ•œ â†’ ContinuousLinearMap (RingHom.id ğ•œ) F G\nd : ğ•œ â†’ ContinuousLinearMap (RingHom.id ğ•œ) E F\nhc : DifferentiableAt ğ•œ c x\nhd : DifferentiableAt ğ•œ d x\nâŠ¢ Eq (deriv (fun y => (c y).comp (d y)) x) (HAdd.hAdd ((deriv c x).comp (d x)) ((c x).comp (deriv d x)))","decl":"theorem deriv_clm_comp (hc : DifferentiableAt ğ•œ c x) (hd : DifferentiableAt ğ•œ d x) :\n    deriv (fun y => (c y).comp (d y)) x = (deriv c x).comp (d x) + (c x).comp (deriv d x) :=\n  (hc.hasDerivAt.clm_comp hd.hasDerivAt).deriv\n\n"}
{"name":"HasStrictDerivAt.clm_apply","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nx : ğ•œ\nG : Type u_2\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nc : ğ•œ â†’ ContinuousLinearMap (RingHom.id ğ•œ) F G\nc' : ContinuousLinearMap (RingHom.id ğ•œ) F G\nu : ğ•œ â†’ F\nu' : F\nhc : HasStrictDerivAt c c' x\nhu : HasStrictDerivAt u u' x\nâŠ¢ HasStrictDerivAt (fun y => (c y) (u y)) (HAdd.hAdd (c' (u x)) ((c x) u')) x","decl":"theorem HasStrictDerivAt.clm_apply (hc : HasStrictDerivAt c c' x) (hu : HasStrictDerivAt u u' x) :\n    HasStrictDerivAt (fun y => (c y) (u y)) (c' (u x) + c x u') x := by\n  have := (hc.hasStrictFDerivAt.clm_apply hu.hasStrictFDerivAt).hasStrictDerivAt\n  rwa [add_apply, comp_apply, flip_apply, smulRight_apply, smulRight_apply, one_apply, one_smul,\n    one_smul, add_comm] at this\n\n"}
{"name":"HasDerivWithinAt.clm_apply","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nx : ğ•œ\ns : Set ğ•œ\nG : Type u_2\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nc : ğ•œ â†’ ContinuousLinearMap (RingHom.id ğ•œ) F G\nc' : ContinuousLinearMap (RingHom.id ğ•œ) F G\nu : ğ•œ â†’ F\nu' : F\nhc : HasDerivWithinAt c c' s x\nhu : HasDerivWithinAt u u' s x\nâŠ¢ HasDerivWithinAt (fun y => (c y) (u y)) (HAdd.hAdd (c' (u x)) ((c x) u')) s x","decl":"theorem HasDerivWithinAt.clm_apply (hc : HasDerivWithinAt c c' s x)\n    (hu : HasDerivWithinAt u u' s x) :\n    HasDerivWithinAt (fun y => (c y) (u y)) (c' (u x) + c x u') s x := by\n  have := (hc.hasFDerivWithinAt.clm_apply hu.hasFDerivWithinAt).hasDerivWithinAt\n  rwa [add_apply, comp_apply, flip_apply, smulRight_apply, smulRight_apply, one_apply, one_smul,\n    one_smul, add_comm] at this\n\n"}
{"name":"HasDerivAt.clm_apply","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nx : ğ•œ\nG : Type u_2\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nc : ğ•œ â†’ ContinuousLinearMap (RingHom.id ğ•œ) F G\nc' : ContinuousLinearMap (RingHom.id ğ•œ) F G\nu : ğ•œ â†’ F\nu' : F\nhc : HasDerivAt c c' x\nhu : HasDerivAt u u' x\nâŠ¢ HasDerivAt (fun y => (c y) (u y)) (HAdd.hAdd (c' (u x)) ((c x) u')) x","decl":"theorem HasDerivAt.clm_apply (hc : HasDerivAt c c' x) (hu : HasDerivAt u u' x) :\n    HasDerivAt (fun y => (c y) (u y)) (c' (u x) + c x u') x := by\n  have := (hc.hasFDerivAt.clm_apply hu.hasFDerivAt).hasDerivAt\n  rwa [add_apply, comp_apply, flip_apply, smulRight_apply, smulRight_apply, one_apply, one_smul,\n    one_smul, add_comm] at this\n\n"}
{"name":"derivWithin_clm_apply","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nx : ğ•œ\ns : Set ğ•œ\nG : Type u_2\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nc : ğ•œ â†’ ContinuousLinearMap (RingHom.id ğ•œ) F G\nu : ğ•œ â†’ F\nhc : DifferentiableWithinAt ğ•œ c s x\nhu : DifferentiableWithinAt ğ•œ u s x\nâŠ¢ Eq (derivWithin (fun y => (c y) (u y)) s x) (HAdd.hAdd ((derivWithin c s x) (u x)) ((c x) (derivWithin u s x)))","decl":"theorem derivWithin_clm_apply (hc : DifferentiableWithinAt ğ•œ c s x)\n    (hu : DifferentiableWithinAt ğ•œ u s x) :\n    derivWithin (fun y => (c y) (u y)) s x = derivWithin c s x (u x) + c x (derivWithin u s x) := by\n  rcases uniqueDiffWithinAt_or_nhdsWithin_eq_bot s x with hxs | hxs\n  Â· exact (hc.hasDerivWithinAt.clm_apply hu.hasDerivWithinAt).derivWithin hxs\n  Â· simp [derivWithin_zero_of_isolated hxs]\n\n"}
{"name":"deriv_clm_apply","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nx : ğ•œ\nG : Type u_2\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nc : ğ•œ â†’ ContinuousLinearMap (RingHom.id ğ•œ) F G\nu : ğ•œ â†’ F\nhc : DifferentiableAt ğ•œ c x\nhu : DifferentiableAt ğ•œ u x\nâŠ¢ Eq (deriv (fun y => (c y) (u y)) x) (HAdd.hAdd ((deriv c x) (u x)) ((c x) (deriv u x)))","decl":"theorem deriv_clm_apply (hc : DifferentiableAt ğ•œ c x) (hu : DifferentiableAt ğ•œ u x) :\n    deriv (fun y => (c y) (u y)) x = deriv c x (u x) + c x (deriv u x) :=\n  (hc.hasDerivAt.clm_apply hu.hasDerivAt).deriv\n\n"}
