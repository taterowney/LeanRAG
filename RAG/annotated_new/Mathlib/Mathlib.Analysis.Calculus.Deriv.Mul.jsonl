{"name":"ContinuousLinearMap.hasDerivWithinAt_of_bilinear","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝⁶ : NontriviallyNormedField 𝕜\nF : Type v\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nE : Type w\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nG : Type u_1\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nx : 𝕜\ns : Set 𝕜\nB : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) F G)\nu : 𝕜 → E\nv : 𝕜 → F\nu' : E\nv' : F\nhu : HasDerivWithinAt u u' s x\nhv : HasDerivWithinAt v v' s x\n⊢ HasDerivWithinAt (fun x => (B (u x)) (v x)) (HAdd.hAdd ((B (u x)) v') ((B u') (v x))) s x","decl":"theorem hasDerivWithinAt_of_bilinear\n    (hu : HasDerivWithinAt u u' s x) (hv : HasDerivWithinAt v v' s x) :\n    HasDerivWithinAt (fun x ↦ B (u x) (v x)) (B (u x) v' + B u' (v x)) s x := by\n  simpa using (B.hasFDerivWithinAt_of_bilinear\n    hu.hasFDerivWithinAt hv.hasFDerivWithinAt).hasDerivWithinAt\n\n"}
{"name":"ContinuousLinearMap.hasDerivAt_of_bilinear","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝⁶ : NontriviallyNormedField 𝕜\nF : Type v\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nE : Type w\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nG : Type u_1\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nx : 𝕜\nB : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) F G)\nu : 𝕜 → E\nv : 𝕜 → F\nu' : E\nv' : F\nhu : HasDerivAt u u' x\nhv : HasDerivAt v v' x\n⊢ HasDerivAt (fun x => (B (u x)) (v x)) (HAdd.hAdd ((B (u x)) v') ((B u') (v x))) x","decl":"theorem hasDerivAt_of_bilinear (hu : HasDerivAt u u' x) (hv : HasDerivAt v v' x) :\n    HasDerivAt (fun x ↦ B (u x) (v x)) (B (u x) v' + B u' (v x)) x := by\n  simpa using (B.hasFDerivAt_of_bilinear hu.hasFDerivAt hv.hasFDerivAt).hasDerivAt\n\n"}
{"name":"ContinuousLinearMap.hasStrictDerivAt_of_bilinear","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝⁶ : NontriviallyNormedField 𝕜\nF : Type v\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nE : Type w\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nG : Type u_1\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nx : 𝕜\nB : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) F G)\nu : 𝕜 → E\nv : 𝕜 → F\nu' : E\nv' : F\nhu : HasStrictDerivAt u u' x\nhv : HasStrictDerivAt v v' x\n⊢ HasStrictDerivAt (fun x => (B (u x)) (v x)) (HAdd.hAdd ((B (u x)) v') ((B u') (v x))) x","decl":"theorem hasStrictDerivAt_of_bilinear (hu : HasStrictDerivAt u u' x) (hv : HasStrictDerivAt v v' x) :\n    HasStrictDerivAt (fun x ↦ B (u x) (v x)) (B (u x) v' + B u' (v x)) x := by\n  simpa using\n    (B.hasStrictFDerivAt_of_bilinear hu.hasStrictFDerivAt hv.hasStrictFDerivAt).hasStrictDerivAt\n\n"}
{"name":"ContinuousLinearMap.derivWithin_of_bilinear","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝⁶ : NontriviallyNormedField 𝕜\nF : Type v\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nE : Type w\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nG : Type u_1\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nx : 𝕜\ns : Set 𝕜\nB : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) F G)\nu : 𝕜 → E\nv : 𝕜 → F\nhu : DifferentiableWithinAt 𝕜 u s x\nhv : DifferentiableWithinAt 𝕜 v s x\n⊢ Eq (derivWithin (fun y => (B (u y)) (v y)) s x) (HAdd.hAdd ((B (u x)) (derivWithin v s x)) ((B (derivWithin u s x)) (v x)))","decl":"theorem derivWithin_of_bilinear\n    (hu : DifferentiableWithinAt 𝕜 u s x) (hv : DifferentiableWithinAt 𝕜 v s x) :\n    derivWithin (fun y => B (u y) (v y)) s x =\n      B (u x) (derivWithin v s x) + B (derivWithin u s x) (v x) := by\n  rcases uniqueDiffWithinAt_or_nhdsWithin_eq_bot s x with hxs | hxs\n  · exact (B.hasDerivWithinAt_of_bilinear hu.hasDerivWithinAt hv.hasDerivWithinAt).derivWithin hxs\n  · simp [derivWithin_zero_of_isolated hxs]\n\n"}
{"name":"ContinuousLinearMap.deriv_of_bilinear","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝⁶ : NontriviallyNormedField 𝕜\nF : Type v\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nE : Type w\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nG : Type u_1\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nx : 𝕜\nB : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) F G)\nu : 𝕜 → E\nv : 𝕜 → F\nhu : DifferentiableAt 𝕜 u x\nhv : DifferentiableAt 𝕜 v x\n⊢ Eq (deriv (fun y => (B (u y)) (v y)) x) (HAdd.hAdd ((B (u x)) (deriv v x)) ((B (deriv u x)) (v x)))","decl":"theorem deriv_of_bilinear (hu : DifferentiableAt 𝕜 u x) (hv : DifferentiableAt 𝕜 v x) :\n    deriv (fun y => B (u y) (v y)) x = B (u x) (deriv v x) + B (deriv u x) (v x) :=\n  (B.hasDerivAt_of_bilinear hu.hasDerivAt hv.hasDerivAt).deriv\n\n"}
{"name":"HasDerivWithinAt.smul","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝⁶ : NontriviallyNormedField 𝕜\nF : Type v\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nf : 𝕜 → F\nf' : F\nx : 𝕜\ns : Set 𝕜\n𝕜' : Type u_2\ninst✝³ : NontriviallyNormedField 𝕜'\ninst✝² : NormedAlgebra 𝕜 𝕜'\ninst✝¹ : NormedSpace 𝕜' F\ninst✝ : IsScalarTower 𝕜 𝕜' F\nc : 𝕜 → 𝕜'\nc' : 𝕜'\nhc : HasDerivWithinAt c c' s x\nhf : HasDerivWithinAt f f' s x\n⊢ HasDerivWithinAt (fun y => HSMul.hSMul (c y) (f y)) (HAdd.hAdd (HSMul.hSMul (c x) f') (HSMul.hSMul c' (f x))) s x","decl":"theorem HasDerivWithinAt.smul (hc : HasDerivWithinAt c c' s x) (hf : HasDerivWithinAt f f' s x) :\n    HasDerivWithinAt (fun y => c y • f y) (c x • f' + c' • f x) s x := by\n  simpa using (HasFDerivWithinAt.smul hc hf).hasDerivWithinAt\n\n"}
{"name":"HasDerivAt.smul","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝⁶ : NontriviallyNormedField 𝕜\nF : Type v\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nf : 𝕜 → F\nf' : F\nx : 𝕜\n𝕜' : Type u_2\ninst✝³ : NontriviallyNormedField 𝕜'\ninst✝² : NormedAlgebra 𝕜 𝕜'\ninst✝¹ : NormedSpace 𝕜' F\ninst✝ : IsScalarTower 𝕜 𝕜' F\nc : 𝕜 → 𝕜'\nc' : 𝕜'\nhc : HasDerivAt c c' x\nhf : HasDerivAt f f' x\n⊢ HasDerivAt (fun y => HSMul.hSMul (c y) (f y)) (HAdd.hAdd (HSMul.hSMul (c x) f') (HSMul.hSMul c' (f x))) x","decl":"theorem HasDerivAt.smul (hc : HasDerivAt c c' x) (hf : HasDerivAt f f' x) :\n    HasDerivAt (fun y => c y • f y) (c x • f' + c' • f x) x := by\n  rw [← hasDerivWithinAt_univ] at *\n  exact hc.smul hf\n\n"}
{"name":"HasStrictDerivAt.smul","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝⁶ : NontriviallyNormedField 𝕜\nF : Type v\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nf : 𝕜 → F\nf' : F\nx : 𝕜\n𝕜' : Type u_2\ninst✝³ : NontriviallyNormedField 𝕜'\ninst✝² : NormedAlgebra 𝕜 𝕜'\ninst✝¹ : NormedSpace 𝕜' F\ninst✝ : IsScalarTower 𝕜 𝕜' F\nc : 𝕜 → 𝕜'\nc' : 𝕜'\nhc : HasStrictDerivAt c c' x\nhf : HasStrictDerivAt f f' x\n⊢ HasStrictDerivAt (fun y => HSMul.hSMul (c y) (f y)) (HAdd.hAdd (HSMul.hSMul (c x) f') (HSMul.hSMul c' (f x))) x","decl":"nonrec theorem HasStrictDerivAt.smul (hc : HasStrictDerivAt c c' x) (hf : HasStrictDerivAt f f' x) :\n    HasStrictDerivAt (fun y => c y • f y) (c x • f' + c' • f x) x := by\n  simpa using (hc.smul hf).hasStrictDerivAt\n\n"}
{"name":"derivWithin_smul","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝⁶ : NontriviallyNormedField 𝕜\nF : Type v\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nf : 𝕜 → F\nx : 𝕜\ns : Set 𝕜\n𝕜' : Type u_2\ninst✝³ : NontriviallyNormedField 𝕜'\ninst✝² : NormedAlgebra 𝕜 𝕜'\ninst✝¹ : NormedSpace 𝕜' F\ninst✝ : IsScalarTower 𝕜 𝕜' F\nc : 𝕜 → 𝕜'\nhc : DifferentiableWithinAt 𝕜 c s x\nhf : DifferentiableWithinAt 𝕜 f s x\n⊢ Eq (derivWithin (fun y => HSMul.hSMul (c y) (f y)) s x) (HAdd.hAdd (HSMul.hSMul (c x) (derivWithin f s x)) (HSMul.hSMul (derivWithin c s x) (f x)))","decl":"theorem derivWithin_smul (hc : DifferentiableWithinAt 𝕜 c s x)\n    (hf : DifferentiableWithinAt 𝕜 f s x) :\n    derivWithin (fun y => c y • f y) s x = c x • derivWithin f s x + derivWithin c s x • f x := by\n  rcases uniqueDiffWithinAt_or_nhdsWithin_eq_bot s x with hxs | hxs\n  · exact (hc.hasDerivWithinAt.smul hf.hasDerivWithinAt).derivWithin hxs\n  · simp [derivWithin_zero_of_isolated hxs]\n\n"}
{"name":"deriv_smul","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝⁶ : NontriviallyNormedField 𝕜\nF : Type v\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nf : 𝕜 → F\nx : 𝕜\n𝕜' : Type u_2\ninst✝³ : NontriviallyNormedField 𝕜'\ninst✝² : NormedAlgebra 𝕜 𝕜'\ninst✝¹ : NormedSpace 𝕜' F\ninst✝ : IsScalarTower 𝕜 𝕜' F\nc : 𝕜 → 𝕜'\nhc : DifferentiableAt 𝕜 c x\nhf : DifferentiableAt 𝕜 f x\n⊢ Eq (deriv (fun y => HSMul.hSMul (c y) (f y)) x) (HAdd.hAdd (HSMul.hSMul (c x) (deriv f x)) (HSMul.hSMul (deriv c x) (f x)))","decl":"theorem deriv_smul (hc : DifferentiableAt 𝕜 c x) (hf : DifferentiableAt 𝕜 f x) :\n    deriv (fun y => c y • f y) x = c x • deriv f x + deriv c x • f x :=\n  (hc.hasDerivAt.smul hf.hasDerivAt).deriv\n\n"}
{"name":"HasStrictDerivAt.smul_const","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝⁶ : NontriviallyNormedField 𝕜\nF : Type v\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nx : 𝕜\n𝕜' : Type u_2\ninst✝³ : NontriviallyNormedField 𝕜'\ninst✝² : NormedAlgebra 𝕜 𝕜'\ninst✝¹ : NormedSpace 𝕜' F\ninst✝ : IsScalarTower 𝕜 𝕜' F\nc : 𝕜 → 𝕜'\nc' : 𝕜'\nhc : HasStrictDerivAt c c' x\nf : F\n⊢ HasStrictDerivAt (fun y => HSMul.hSMul (c y) f) (HSMul.hSMul c' f) x","decl":"theorem HasStrictDerivAt.smul_const (hc : HasStrictDerivAt c c' x) (f : F) :\n    HasStrictDerivAt (fun y => c y • f) (c' • f) x := by\n  have := hc.smul (hasStrictDerivAt_const x f)\n  rwa [smul_zero, zero_add] at this\n\n"}
{"name":"HasDerivWithinAt.smul_const","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝⁶ : NontriviallyNormedField 𝕜\nF : Type v\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nx : 𝕜\ns : Set 𝕜\n𝕜' : Type u_2\ninst✝³ : NontriviallyNormedField 𝕜'\ninst✝² : NormedAlgebra 𝕜 𝕜'\ninst✝¹ : NormedSpace 𝕜' F\ninst✝ : IsScalarTower 𝕜 𝕜' F\nc : 𝕜 → 𝕜'\nc' : 𝕜'\nhc : HasDerivWithinAt c c' s x\nf : F\n⊢ HasDerivWithinAt (fun y => HSMul.hSMul (c y) f) (HSMul.hSMul c' f) s x","decl":"theorem HasDerivWithinAt.smul_const (hc : HasDerivWithinAt c c' s x) (f : F) :\n    HasDerivWithinAt (fun y => c y • f) (c' • f) s x := by\n  have := hc.smul (hasDerivWithinAt_const x s f)\n  rwa [smul_zero, zero_add] at this\n\n"}
{"name":"HasDerivAt.smul_const","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝⁶ : NontriviallyNormedField 𝕜\nF : Type v\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nx : 𝕜\n𝕜' : Type u_2\ninst✝³ : NontriviallyNormedField 𝕜'\ninst✝² : NormedAlgebra 𝕜 𝕜'\ninst✝¹ : NormedSpace 𝕜' F\ninst✝ : IsScalarTower 𝕜 𝕜' F\nc : 𝕜 → 𝕜'\nc' : 𝕜'\nhc : HasDerivAt c c' x\nf : F\n⊢ HasDerivAt (fun y => HSMul.hSMul (c y) f) (HSMul.hSMul c' f) x","decl":"theorem HasDerivAt.smul_const (hc : HasDerivAt c c' x) (f : F) :\n    HasDerivAt (fun y => c y • f) (c' • f) x := by\n  rw [← hasDerivWithinAt_univ] at *\n  exact hc.smul_const f\n\n"}
{"name":"derivWithin_smul_const","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝⁶ : NontriviallyNormedField 𝕜\nF : Type v\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nx : 𝕜\ns : Set 𝕜\n𝕜' : Type u_2\ninst✝³ : NontriviallyNormedField 𝕜'\ninst✝² : NormedAlgebra 𝕜 𝕜'\ninst✝¹ : NormedSpace 𝕜' F\ninst✝ : IsScalarTower 𝕜 𝕜' F\nc : 𝕜 → 𝕜'\nhc : DifferentiableWithinAt 𝕜 c s x\nf : F\n⊢ Eq (derivWithin (fun y => HSMul.hSMul (c y) f) s x) (HSMul.hSMul (derivWithin c s x) f)","decl":"theorem derivWithin_smul_const (hc : DifferentiableWithinAt 𝕜 c s x) (f : F) :\n    derivWithin (fun y => c y • f) s x = derivWithin c s x • f := by\n  rcases uniqueDiffWithinAt_or_nhdsWithin_eq_bot s x with hxs | hxs\n  · exact (hc.hasDerivWithinAt.smul_const f).derivWithin hxs\n  · simp [derivWithin_zero_of_isolated hxs]\n\n"}
{"name":"deriv_smul_const","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝⁶ : NontriviallyNormedField 𝕜\nF : Type v\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nx : 𝕜\n𝕜' : Type u_2\ninst✝³ : NontriviallyNormedField 𝕜'\ninst✝² : NormedAlgebra 𝕜 𝕜'\ninst✝¹ : NormedSpace 𝕜' F\ninst✝ : IsScalarTower 𝕜 𝕜' F\nc : 𝕜 → 𝕜'\nhc : DifferentiableAt 𝕜 c x\nf : F\n⊢ Eq (deriv (fun y => HSMul.hSMul (c y) f) x) (HSMul.hSMul (deriv c x) f)","decl":"theorem deriv_smul_const (hc : DifferentiableAt 𝕜 c x) (f : F) :\n    deriv (fun y => c y • f) x = deriv c x • f :=\n  (hc.hasDerivAt.smul_const f).deriv\n\n"}
{"name":"HasStrictDerivAt.const_smul","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝⁶ : NontriviallyNormedField 𝕜\nF : Type v\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nf : 𝕜 → F\nf' : F\nx : 𝕜\nR : Type u_2\ninst✝³ : Semiring R\ninst✝² : Module R F\ninst✝¹ : SMulCommClass 𝕜 R F\ninst✝ : ContinuousConstSMul R F\nc : R\nhf : HasStrictDerivAt f f' x\n⊢ HasStrictDerivAt (fun y => HSMul.hSMul c (f y)) (HSMul.hSMul c f') x","decl":"nonrec theorem HasStrictDerivAt.const_smul (c : R) (hf : HasStrictDerivAt f f' x) :\n    HasStrictDerivAt (fun y => c • f y) (c • f') x := by\n  simpa using (hf.const_smul c).hasStrictDerivAt\n\n"}
{"name":"HasDerivAtFilter.const_smul","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝⁶ : NontriviallyNormedField 𝕜\nF : Type v\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nf : 𝕜 → F\nf' : F\nx : 𝕜\nL : Filter 𝕜\nR : Type u_2\ninst✝³ : Semiring R\ninst✝² : Module R F\ninst✝¹ : SMulCommClass 𝕜 R F\ninst✝ : ContinuousConstSMul R F\nc : R\nhf : HasDerivAtFilter f f' x L\n⊢ HasDerivAtFilter (fun y => HSMul.hSMul c (f y)) (HSMul.hSMul c f') x L","decl":"nonrec theorem HasDerivAtFilter.const_smul (c : R) (hf : HasDerivAtFilter f f' x L) :\n    HasDerivAtFilter (fun y => c • f y) (c • f') x L := by\n  simpa using (hf.const_smul c).hasDerivAtFilter\n\n"}
{"name":"HasDerivWithinAt.const_smul","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝⁶ : NontriviallyNormedField 𝕜\nF : Type v\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nf : 𝕜 → F\nf' : F\nx : 𝕜\ns : Set 𝕜\nR : Type u_2\ninst✝³ : Semiring R\ninst✝² : Module R F\ninst✝¹ : SMulCommClass 𝕜 R F\ninst✝ : ContinuousConstSMul R F\nc : R\nhf : HasDerivWithinAt f f' s x\n⊢ HasDerivWithinAt (fun y => HSMul.hSMul c (f y)) (HSMul.hSMul c f') s x","decl":"nonrec theorem HasDerivWithinAt.const_smul (c : R) (hf : HasDerivWithinAt f f' s x) :\n    HasDerivWithinAt (fun y => c • f y) (c • f') s x :=\n  hf.const_smul c\n\n"}
{"name":"HasDerivAt.const_smul","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝⁶ : NontriviallyNormedField 𝕜\nF : Type v\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nf : 𝕜 → F\nf' : F\nx : 𝕜\nR : Type u_2\ninst✝³ : Semiring R\ninst✝² : Module R F\ninst✝¹ : SMulCommClass 𝕜 R F\ninst✝ : ContinuousConstSMul R F\nc : R\nhf : HasDerivAt f f' x\n⊢ HasDerivAt (fun y => HSMul.hSMul c (f y)) (HSMul.hSMul c f') x","decl":"nonrec theorem HasDerivAt.const_smul (c : R) (hf : HasDerivAt f f' x) :\n    HasDerivAt (fun y => c • f y) (c • f') x :=\n  hf.const_smul c\n\n"}
{"name":"derivWithin_const_smul","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝⁶ : NontriviallyNormedField 𝕜\nF : Type v\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nf : 𝕜 → F\nx : 𝕜\ns : Set 𝕜\nR : Type u_2\ninst✝³ : Semiring R\ninst✝² : Module R F\ninst✝¹ : SMulCommClass 𝕜 R F\ninst✝ : ContinuousConstSMul R F\nc : R\nhf : DifferentiableWithinAt 𝕜 f s x\n⊢ Eq (derivWithin (fun y => HSMul.hSMul c (f y)) s x) (HSMul.hSMul c (derivWithin f s x))","decl":"theorem derivWithin_const_smul (c : R) (hf : DifferentiableWithinAt 𝕜 f s x) :\n    derivWithin (fun y => c • f y) s x = c • derivWithin f s x := by\n  rcases uniqueDiffWithinAt_or_nhdsWithin_eq_bot s x with hxs | hxs\n  · exact (hf.hasDerivWithinAt.const_smul c).derivWithin hxs\n  · simp [derivWithin_zero_of_isolated hxs]\n\n"}
{"name":"deriv_const_smul","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝⁶ : NontriviallyNormedField 𝕜\nF : Type v\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nf : 𝕜 → F\nx : 𝕜\nR : Type u_2\ninst✝³ : Semiring R\ninst✝² : Module R F\ninst✝¹ : SMulCommClass 𝕜 R F\ninst✝ : ContinuousConstSMul R F\nc : R\nhf : DifferentiableAt 𝕜 f x\n⊢ Eq (deriv (fun y => HSMul.hSMul c (f y)) x) (HSMul.hSMul c (deriv f x))","decl":"theorem deriv_const_smul (c : R) (hf : DifferentiableAt 𝕜 f x) :\n    deriv (fun y => c • f y) x = c • deriv f x :=\n  (hf.hasDerivAt.const_smul c).deriv\n\n"}
{"name":"deriv_const_smul'","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝⁶ : NontriviallyNormedField 𝕜\nF : Type v\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nf : 𝕜 → F\nx : 𝕜\nR : Type u_3\ninst✝³ : Field R\ninst✝² : Module R F\ninst✝¹ : SMulCommClass 𝕜 R F\ninst✝ : ContinuousConstSMul R F\nc : R\n⊢ Eq (deriv (fun y => HSMul.hSMul c (f y)) x) (HSMul.hSMul c (deriv f x))","decl":"/-- A variant of `deriv_const_smul` without differentiability assumption when the scalar\nmultiplication is by field elements. -/\nlemma deriv_const_smul' {f : 𝕜 → F} {x : 𝕜} {R : Type*} [Field R] [Module R F] [SMulCommClass 𝕜 R F]\n    [ContinuousConstSMul R F] (c : R) :\n    deriv (fun y ↦ c • f y) x = c • deriv f x := by\n  by_cases hf : DifferentiableAt 𝕜 f x\n  · exact deriv_const_smul c hf\n  · rcases eq_or_ne c 0 with rfl | hc\n    · simp only [zero_smul, deriv_const']\n    · have H : ¬DifferentiableAt 𝕜 (fun y ↦ c • f y) x := by\n        contrapose! hf\n        conv => enter [2, y]; rw [← inv_smul_smul₀ hc (f y)]\n        exact DifferentiableAt.const_smul hf c⁻¹\n      rw [deriv_zero_of_not_differentiableAt hf, deriv_zero_of_not_differentiableAt H, smul_zero]\n\n"}
{"name":"HasDerivWithinAt.mul","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nx : 𝕜\ns : Set 𝕜\n𝔸 : Type u_3\ninst✝¹ : NormedRing 𝔸\ninst✝ : NormedAlgebra 𝕜 𝔸\nc d : 𝕜 → 𝔸\nc' d' : 𝔸\nhc : HasDerivWithinAt c c' s x\nhd : HasDerivWithinAt d d' s x\n⊢ HasDerivWithinAt (fun y => HMul.hMul (c y) (d y)) (HAdd.hAdd (HMul.hMul c' (d x)) (HMul.hMul (c x) d')) s x","decl":"theorem HasDerivWithinAt.mul (hc : HasDerivWithinAt c c' s x) (hd : HasDerivWithinAt d d' s x) :\n    HasDerivWithinAt (fun y => c y * d y) (c' * d x + c x * d') s x := by\n  have := (HasFDerivWithinAt.mul' hc hd).hasDerivWithinAt\n  rwa [ContinuousLinearMap.add_apply, ContinuousLinearMap.smul_apply,\n    ContinuousLinearMap.smulRight_apply, ContinuousLinearMap.smulRight_apply,\n    ContinuousLinearMap.smulRight_apply, ContinuousLinearMap.one_apply, one_smul, one_smul,\n    add_comm] at this\n\n"}
{"name":"HasDerivAt.mul","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nx : 𝕜\n𝔸 : Type u_3\ninst✝¹ : NormedRing 𝔸\ninst✝ : NormedAlgebra 𝕜 𝔸\nc d : 𝕜 → 𝔸\nc' d' : 𝔸\nhc : HasDerivAt c c' x\nhd : HasDerivAt d d' x\n⊢ HasDerivAt (fun y => HMul.hMul (c y) (d y)) (HAdd.hAdd (HMul.hMul c' (d x)) (HMul.hMul (c x) d')) x","decl":"theorem HasDerivAt.mul (hc : HasDerivAt c c' x) (hd : HasDerivAt d d' x) :\n    HasDerivAt (fun y => c y * d y) (c' * d x + c x * d') x := by\n  rw [← hasDerivWithinAt_univ] at *\n  exact hc.mul hd\n\n"}
{"name":"HasStrictDerivAt.mul","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nx : 𝕜\n𝔸 : Type u_3\ninst✝¹ : NormedRing 𝔸\ninst✝ : NormedAlgebra 𝕜 𝔸\nc d : 𝕜 → 𝔸\nc' d' : 𝔸\nhc : HasStrictDerivAt c c' x\nhd : HasStrictDerivAt d d' x\n⊢ HasStrictDerivAt (fun y => HMul.hMul (c y) (d y)) (HAdd.hAdd (HMul.hMul c' (d x)) (HMul.hMul (c x) d')) x","decl":"theorem HasStrictDerivAt.mul (hc : HasStrictDerivAt c c' x) (hd : HasStrictDerivAt d d' x) :\n    HasStrictDerivAt (fun y => c y * d y) (c' * d x + c x * d') x := by\n  have := (HasStrictFDerivAt.mul' hc hd).hasStrictDerivAt\n  rwa [ContinuousLinearMap.add_apply, ContinuousLinearMap.smul_apply,\n    ContinuousLinearMap.smulRight_apply, ContinuousLinearMap.smulRight_apply,\n    ContinuousLinearMap.smulRight_apply, ContinuousLinearMap.one_apply, one_smul, one_smul,\n    add_comm] at this\n\n"}
{"name":"derivWithin_mul","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nx : 𝕜\ns : Set 𝕜\n𝔸 : Type u_3\ninst✝¹ : NormedRing 𝔸\ninst✝ : NormedAlgebra 𝕜 𝔸\nc d : 𝕜 → 𝔸\nhc : DifferentiableWithinAt 𝕜 c s x\nhd : DifferentiableWithinAt 𝕜 d s x\n⊢ Eq (derivWithin (fun y => HMul.hMul (c y) (d y)) s x) (HAdd.hAdd (HMul.hMul (derivWithin c s x) (d x)) (HMul.hMul (c x) (derivWithin d s x)))","decl":"theorem derivWithin_mul (hc : DifferentiableWithinAt 𝕜 c s x)\n    (hd : DifferentiableWithinAt 𝕜 d s x) :\n    derivWithin (fun y => c y * d y) s x = derivWithin c s x * d x + c x * derivWithin d s x := by\n  rcases uniqueDiffWithinAt_or_nhdsWithin_eq_bot s x with hxs | hxs\n  · exact (hc.hasDerivWithinAt.mul hd.hasDerivWithinAt).derivWithin hxs\n  · simp [derivWithin_zero_of_isolated hxs]\n\n"}
{"name":"deriv_mul","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nx : 𝕜\n𝔸 : Type u_3\ninst✝¹ : NormedRing 𝔸\ninst✝ : NormedAlgebra 𝕜 𝔸\nc d : 𝕜 → 𝔸\nhc : DifferentiableAt 𝕜 c x\nhd : DifferentiableAt 𝕜 d x\n⊢ Eq (deriv (fun y => HMul.hMul (c y) (d y)) x) (HAdd.hAdd (HMul.hMul (deriv c x) (d x)) (HMul.hMul (c x) (deriv d x)))","decl":"@[simp]\ntheorem deriv_mul (hc : DifferentiableAt 𝕜 c x) (hd : DifferentiableAt 𝕜 d x) :\n    deriv (fun y => c y * d y) x = deriv c x * d x + c x * deriv d x :=\n  (hc.hasDerivAt.mul hd.hasDerivAt).deriv\n\n"}
{"name":"HasDerivWithinAt.mul_const","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nx : 𝕜\ns : Set 𝕜\n𝔸 : Type u_3\ninst✝¹ : NormedRing 𝔸\ninst✝ : NormedAlgebra 𝕜 𝔸\nc : 𝕜 → 𝔸\nc' : 𝔸\nhc : HasDerivWithinAt c c' s x\nd : 𝔸\n⊢ HasDerivWithinAt (fun y => HMul.hMul (c y) d) (HMul.hMul c' d) s x","decl":"theorem HasDerivWithinAt.mul_const (hc : HasDerivWithinAt c c' s x) (d : 𝔸) :\n    HasDerivWithinAt (fun y => c y * d) (c' * d) s x := by\n  convert hc.mul (hasDerivWithinAt_const x s d) using 1\n  rw [mul_zero, add_zero]\n\n"}
{"name":"HasDerivAt.mul_const","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nx : 𝕜\n𝔸 : Type u_3\ninst✝¹ : NormedRing 𝔸\ninst✝ : NormedAlgebra 𝕜 𝔸\nc : 𝕜 → 𝔸\nc' : 𝔸\nhc : HasDerivAt c c' x\nd : 𝔸\n⊢ HasDerivAt (fun y => HMul.hMul (c y) d) (HMul.hMul c' d) x","decl":"theorem HasDerivAt.mul_const (hc : HasDerivAt c c' x) (d : 𝔸) :\n    HasDerivAt (fun y => c y * d) (c' * d) x := by\n  rw [← hasDerivWithinAt_univ] at *\n  exact hc.mul_const d\n\n"}
{"name":"hasDerivAt_mul_const","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝ : NontriviallyNormedField 𝕜\nx c : 𝕜\n⊢ HasDerivAt (fun x => HMul.hMul x c) c x","decl":"theorem hasDerivAt_mul_const (c : 𝕜) : HasDerivAt (fun x => x * c) c x := by\n  simpa only [one_mul] using (hasDerivAt_id' x).mul_const c\n\n"}
{"name":"HasStrictDerivAt.mul_const","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nx : 𝕜\n𝔸 : Type u_3\ninst✝¹ : NormedRing 𝔸\ninst✝ : NormedAlgebra 𝕜 𝔸\nc : 𝕜 → 𝔸\nc' : 𝔸\nhc : HasStrictDerivAt c c' x\nd : 𝔸\n⊢ HasStrictDerivAt (fun y => HMul.hMul (c y) d) (HMul.hMul c' d) x","decl":"theorem HasStrictDerivAt.mul_const (hc : HasStrictDerivAt c c' x) (d : 𝔸) :\n    HasStrictDerivAt (fun y => c y * d) (c' * d) x := by\n  convert hc.mul (hasStrictDerivAt_const x d) using 1\n  rw [mul_zero, add_zero]\n\n"}
{"name":"derivWithin_mul_const","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nx : 𝕜\ns : Set 𝕜\n𝔸 : Type u_3\ninst✝¹ : NormedRing 𝔸\ninst✝ : NormedAlgebra 𝕜 𝔸\nc : 𝕜 → 𝔸\nhc : DifferentiableWithinAt 𝕜 c s x\nd : 𝔸\n⊢ Eq (derivWithin (fun y => HMul.hMul (c y) d) s x) (HMul.hMul (derivWithin c s x) d)","decl":"theorem derivWithin_mul_const (hc : DifferentiableWithinAt 𝕜 c s x) (d : 𝔸) :\n    derivWithin (fun y => c y * d) s x = derivWithin c s x * d := by\n  rcases uniqueDiffWithinAt_or_nhdsWithin_eq_bot s x with hxs | hxs\n  · exact (hc.hasDerivWithinAt.mul_const d).derivWithin hxs\n  · simp [derivWithin_zero_of_isolated hxs]\n\n"}
{"name":"derivWithin_mul_const_field","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nx : 𝕜\ns : Set 𝕜\n𝕜' : Type u_2\ninst✝¹ : NormedField 𝕜'\ninst✝ : NormedAlgebra 𝕜 𝕜'\nv : 𝕜 → 𝕜'\nu : 𝕜'\n⊢ Eq (derivWithin (fun y => HMul.hMul (v y) u) s x) (HMul.hMul (derivWithin v s x) u)","decl":"lemma derivWithin_mul_const_field (u : 𝕜') :\n    derivWithin (fun y => v y * u) s x = derivWithin v s x * u := by\n  by_cases hv : DifferentiableWithinAt 𝕜 v s x\n  · rw [derivWithin_mul_const hv u]\n  by_cases hu : u = 0\n  · simp [hu]\n  rw [derivWithin_zero_of_not_differentiableWithinAt hv, zero_mul,\n      derivWithin_zero_of_not_differentiableWithinAt]\n  have : v = fun x ↦ (v x * u) * u⁻¹ := by ext; simp [hu]\n  exact fun h_diff ↦ hv <| this ▸ h_diff.mul_const _\n\n"}
{"name":"deriv_mul_const","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nx : 𝕜\n𝔸 : Type u_3\ninst✝¹ : NormedRing 𝔸\ninst✝ : NormedAlgebra 𝕜 𝔸\nc : 𝕜 → 𝔸\nhc : DifferentiableAt 𝕜 c x\nd : 𝔸\n⊢ Eq (deriv (fun y => HMul.hMul (c y) d) x) (HMul.hMul (deriv c x) d)","decl":"theorem deriv_mul_const (hc : DifferentiableAt 𝕜 c x) (d : 𝔸) :\n    deriv (fun y => c y * d) x = deriv c x * d :=\n  (hc.hasDerivAt.mul_const d).deriv\n\n"}
{"name":"deriv_mul_const_field","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nx : 𝕜\n𝕜' : Type u_2\ninst✝¹ : NormedField 𝕜'\ninst✝ : NormedAlgebra 𝕜 𝕜'\nu : 𝕜 → 𝕜'\nv : 𝕜'\n⊢ Eq (deriv (fun y => HMul.hMul (u y) v) x) (HMul.hMul (deriv u x) v)","decl":"theorem deriv_mul_const_field (v : 𝕜') : deriv (fun y => u y * v) x = deriv u x * v := by\n  by_cases hu : DifferentiableAt 𝕜 u x\n  · exact deriv_mul_const hu v\n  · rw [deriv_zero_of_not_differentiableAt hu, zero_mul]\n    rcases eq_or_ne v 0 with (rfl | hd)\n    · simp only [mul_zero, deriv_const]\n    · refine deriv_zero_of_not_differentiableAt (mt (fun H => ?_) hu)\n      simpa only [mul_inv_cancel_right₀ hd] using H.mul_const v⁻¹\n\n"}
{"name":"deriv_mul_const_field'","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\n𝕜' : Type u_2\ninst✝¹ : NormedField 𝕜'\ninst✝ : NormedAlgebra 𝕜 𝕜'\nu : 𝕜 → 𝕜'\nv : 𝕜'\n⊢ Eq (deriv fun x => HMul.hMul (u x) v) fun x => HMul.hMul (deriv u x) v","decl":"@[simp]\ntheorem deriv_mul_const_field' (v : 𝕜') : (deriv fun x => u x * v) = fun x => deriv u x * v :=\n  funext fun _ => deriv_mul_const_field v\n\n"}
{"name":"HasDerivWithinAt.const_mul","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nx : 𝕜\ns : Set 𝕜\n𝔸 : Type u_3\ninst✝¹ : NormedRing 𝔸\ninst✝ : NormedAlgebra 𝕜 𝔸\nd : 𝕜 → 𝔸\nd' c : 𝔸\nhd : HasDerivWithinAt d d' s x\n⊢ HasDerivWithinAt (fun y => HMul.hMul c (d y)) (HMul.hMul c d') s x","decl":"theorem HasDerivWithinAt.const_mul (c : 𝔸) (hd : HasDerivWithinAt d d' s x) :\n    HasDerivWithinAt (fun y => c * d y) (c * d') s x := by\n  convert (hasDerivWithinAt_const x s c).mul hd using 1\n  rw [zero_mul, zero_add]\n\n"}
{"name":"HasDerivAt.const_mul","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nx : 𝕜\n𝔸 : Type u_3\ninst✝¹ : NormedRing 𝔸\ninst✝ : NormedAlgebra 𝕜 𝔸\nd : 𝕜 → 𝔸\nd' c : 𝔸\nhd : HasDerivAt d d' x\n⊢ HasDerivAt (fun y => HMul.hMul c (d y)) (HMul.hMul c d') x","decl":"theorem HasDerivAt.const_mul (c : 𝔸) (hd : HasDerivAt d d' x) :\n    HasDerivAt (fun y => c * d y) (c * d') x := by\n  rw [← hasDerivWithinAt_univ] at *\n  exact hd.const_mul c\n\n"}
{"name":"HasStrictDerivAt.const_mul","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nx : 𝕜\n𝔸 : Type u_3\ninst✝¹ : NormedRing 𝔸\ninst✝ : NormedAlgebra 𝕜 𝔸\nd : 𝕜 → 𝔸\nd' c : 𝔸\nhd : HasStrictDerivAt d d' x\n⊢ HasStrictDerivAt (fun y => HMul.hMul c (d y)) (HMul.hMul c d') x","decl":"theorem HasStrictDerivAt.const_mul (c : 𝔸) (hd : HasStrictDerivAt d d' x) :\n    HasStrictDerivAt (fun y => c * d y) (c * d') x := by\n  convert (hasStrictDerivAt_const _ _).mul hd using 1\n  rw [zero_mul, zero_add]\n\n"}
{"name":"derivWithin_const_mul","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nx : 𝕜\ns : Set 𝕜\n𝔸 : Type u_3\ninst✝¹ : NormedRing 𝔸\ninst✝ : NormedAlgebra 𝕜 𝔸\nd : 𝕜 → 𝔸\nc : 𝔸\nhd : DifferentiableWithinAt 𝕜 d s x\n⊢ Eq (derivWithin (fun y => HMul.hMul c (d y)) s x) (HMul.hMul c (derivWithin d s x))","decl":"theorem derivWithin_const_mul (c : 𝔸) (hd : DifferentiableWithinAt 𝕜 d s x) :\n    derivWithin (fun y => c * d y) s x = c * derivWithin d s x := by\n  rcases uniqueDiffWithinAt_or_nhdsWithin_eq_bot s x with hxs | hxs\n  · exact (hd.hasDerivWithinAt.const_mul c).derivWithin hxs\n  · simp [derivWithin_zero_of_isolated hxs]\n\n"}
{"name":"derivWithin_const_mul_field","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nx : 𝕜\ns : Set 𝕜\n𝕜' : Type u_2\ninst✝¹ : NormedField 𝕜'\ninst✝ : NormedAlgebra 𝕜 𝕜'\nv : 𝕜 → 𝕜'\nu : 𝕜'\n⊢ Eq (derivWithin (fun y => HMul.hMul u (v y)) s x) (HMul.hMul u (derivWithin v s x))","decl":"lemma derivWithin_const_mul_field (u : 𝕜') :\n    derivWithin (fun y => u * v y) s x = u * derivWithin v s x := by\n  simp_rw [mul_comm u]\n  exact derivWithin_mul_const_field u\n\n"}
{"name":"deriv_const_mul","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nx : 𝕜\n𝔸 : Type u_3\ninst✝¹ : NormedRing 𝔸\ninst✝ : NormedAlgebra 𝕜 𝔸\nd : 𝕜 → 𝔸\nc : 𝔸\nhd : DifferentiableAt 𝕜 d x\n⊢ Eq (deriv (fun y => HMul.hMul c (d y)) x) (HMul.hMul c (deriv d x))","decl":"theorem deriv_const_mul (c : 𝔸) (hd : DifferentiableAt 𝕜 d x) :\n    deriv (fun y => c * d y) x = c * deriv d x :=\n  (hd.hasDerivAt.const_mul c).deriv\n\n"}
{"name":"deriv_const_mul_field","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nx : 𝕜\n𝕜' : Type u_2\ninst✝¹ : NormedField 𝕜'\ninst✝ : NormedAlgebra 𝕜 𝕜'\nv : 𝕜 → 𝕜'\nu : 𝕜'\n⊢ Eq (deriv (fun y => HMul.hMul u (v y)) x) (HMul.hMul u (deriv v x))","decl":"theorem deriv_const_mul_field (u : 𝕜') : deriv (fun y => u * v y) x = u * deriv v x := by\n  simp only [mul_comm u, deriv_mul_const_field]\n\n"}
{"name":"deriv_const_mul_field'","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\n𝕜' : Type u_2\ninst✝¹ : NormedField 𝕜'\ninst✝ : NormedAlgebra 𝕜 𝕜'\nv : 𝕜 → 𝕜'\nu : 𝕜'\n⊢ Eq (deriv fun x => HMul.hMul u (v x)) fun x => HMul.hMul u (deriv v x)","decl":"@[simp]\ntheorem deriv_const_mul_field' (u : 𝕜') : (deriv fun x => u * v x) = fun x => u * deriv v x :=\n  funext fun _ => deriv_const_mul_field u\n\n"}
{"name":"HasDerivAt.finset_prod","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝³ : NontriviallyNormedField 𝕜\nx : 𝕜\nι : Type u_2\ninst✝² : DecidableEq ι\n𝔸' : Type u_3\ninst✝¹ : NormedCommRing 𝔸'\ninst✝ : NormedAlgebra 𝕜 𝔸'\nu : Finset ι\nf : ι → 𝕜 → 𝔸'\nf' : ι → 𝔸'\nhf : ∀ (i : ι), Membership.mem u i → HasDerivAt (f i) (f' i) x\n⊢ HasDerivAt (fun x => u.prod fun i => f i x) (u.sum fun i => HSMul.hSMul ((u.erase i).prod fun j => f j x) (f' i)) x","decl":"theorem HasDerivAt.finset_prod (hf : ∀ i ∈ u, HasDerivAt (f i) (f' i) x) :\n    HasDerivAt (∏ i ∈ u, f i ·) (∑ i ∈ u, (∏ j ∈ u.erase i, f j x) • f' i) x := by\n  simpa [ContinuousLinearMap.sum_apply, ContinuousLinearMap.smul_apply] using\n    (HasFDerivAt.finset_prod (fun i hi ↦ (hf i hi).hasFDerivAt)).hasDerivAt\n\n"}
{"name":"HasDerivWithinAt.finset_prod","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝³ : NontriviallyNormedField 𝕜\nx : 𝕜\ns : Set 𝕜\nι : Type u_2\ninst✝² : DecidableEq ι\n𝔸' : Type u_3\ninst✝¹ : NormedCommRing 𝔸'\ninst✝ : NormedAlgebra 𝕜 𝔸'\nu : Finset ι\nf : ι → 𝕜 → 𝔸'\nf' : ι → 𝔸'\nhf : ∀ (i : ι), Membership.mem u i → HasDerivWithinAt (f i) (f' i) s x\n⊢ HasDerivWithinAt (fun x => u.prod fun i => f i x) (u.sum fun i => HSMul.hSMul ((u.erase i).prod fun j => f j x) (f' i)) s x","decl":"theorem HasDerivWithinAt.finset_prod (hf : ∀ i ∈ u, HasDerivWithinAt (f i) (f' i) s x) :\n    HasDerivWithinAt (∏ i ∈ u, f i ·) (∑ i ∈ u, (∏ j ∈ u.erase i, f j x) • f' i) s x := by\n  simpa [ContinuousLinearMap.sum_apply, ContinuousLinearMap.smul_apply] using\n    (HasFDerivWithinAt.finset_prod (fun i hi ↦ (hf i hi).hasFDerivWithinAt)).hasDerivWithinAt\n\n"}
{"name":"HasStrictDerivAt.finset_prod","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝³ : NontriviallyNormedField 𝕜\nx : 𝕜\nι : Type u_2\ninst✝² : DecidableEq ι\n𝔸' : Type u_3\ninst✝¹ : NormedCommRing 𝔸'\ninst✝ : NormedAlgebra 𝕜 𝔸'\nu : Finset ι\nf : ι → 𝕜 → 𝔸'\nf' : ι → 𝔸'\nhf : ∀ (i : ι), Membership.mem u i → HasStrictDerivAt (f i) (f' i) x\n⊢ HasStrictDerivAt (fun x => u.prod fun i => f i x) (u.sum fun i => HSMul.hSMul ((u.erase i).prod fun j => f j x) (f' i)) x","decl":"theorem HasStrictDerivAt.finset_prod (hf : ∀ i ∈ u, HasStrictDerivAt (f i) (f' i) x) :\n    HasStrictDerivAt (∏ i ∈ u, f i ·) (∑ i ∈ u, (∏ j ∈ u.erase i, f j x) • f' i) x := by\n  simpa [ContinuousLinearMap.sum_apply, ContinuousLinearMap.smul_apply] using\n    (HasStrictFDerivAt.finset_prod (fun i hi ↦ (hf i hi).hasStrictFDerivAt)).hasStrictDerivAt\n\n"}
{"name":"deriv_finset_prod","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝³ : NontriviallyNormedField 𝕜\nx : 𝕜\nι : Type u_2\ninst✝² : DecidableEq ι\n𝔸' : Type u_3\ninst✝¹ : NormedCommRing 𝔸'\ninst✝ : NormedAlgebra 𝕜 𝔸'\nu : Finset ι\nf : ι → 𝕜 → 𝔸'\nhf : ∀ (i : ι), Membership.mem u i → DifferentiableAt 𝕜 (f i) x\n⊢ Eq (deriv (fun x => u.prod fun i => f i x) x) (u.sum fun i => HSMul.hSMul ((u.erase i).prod fun j => f j x) (deriv (f i) x))","decl":"theorem deriv_finset_prod (hf : ∀ i ∈ u, DifferentiableAt 𝕜 (f i) x) :\n    deriv (∏ i ∈ u, f i ·) x = ∑ i ∈ u, (∏ j ∈ u.erase i, f j x) • deriv (f i) x :=\n  (HasDerivAt.finset_prod fun i hi ↦ (hf i hi).hasDerivAt).deriv\n\n"}
{"name":"derivWithin_finset_prod","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝³ : NontriviallyNormedField 𝕜\nx : 𝕜\ns : Set 𝕜\nι : Type u_2\ninst✝² : DecidableEq ι\n𝔸' : Type u_3\ninst✝¹ : NormedCommRing 𝔸'\ninst✝ : NormedAlgebra 𝕜 𝔸'\nu : Finset ι\nf : ι → 𝕜 → 𝔸'\nhf : ∀ (i : ι), Membership.mem u i → DifferentiableWithinAt 𝕜 (f i) s x\n⊢ Eq (derivWithin (fun x => u.prod fun i => f i x) s x) (u.sum fun i => HSMul.hSMul ((u.erase i).prod fun j => f j x) (derivWithin (f i) s x))","decl":"theorem derivWithin_finset_prod\n    (hf : ∀ i ∈ u, DifferentiableWithinAt 𝕜 (f i) s x) :\n    derivWithin (∏ i ∈ u, f i ·) s x =\n      ∑ i ∈ u, (∏ j ∈ u.erase i, f j x) • derivWithin (f i) s x := by\n  rcases uniqueDiffWithinAt_or_nhdsWithin_eq_bot s x with hxs | hxs\n  · exact (HasDerivWithinAt.finset_prod fun i hi ↦ (hf i hi).hasDerivWithinAt).derivWithin hxs\n  · simp [derivWithin_zero_of_isolated hxs]\n\n"}
{"name":"DifferentiableAt.finset_prod","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nx : 𝕜\nι : Type u_2\n𝔸' : Type u_3\ninst✝¹ : NormedCommRing 𝔸'\ninst✝ : NormedAlgebra 𝕜 𝔸'\nu : Finset ι\nf : ι → 𝕜 → 𝔸'\nhd : ∀ (i : ι), Membership.mem u i → DifferentiableAt 𝕜 (f i) x\n⊢ DifferentiableAt 𝕜 (fun x => u.prod fun i => f i x) x","decl":"@[fun_prop]\ntheorem DifferentiableAt.finset_prod (hd : ∀ i ∈ u, DifferentiableAt 𝕜 (f i) x) :\n    DifferentiableAt 𝕜 (∏ i ∈ u, f i ·) x := by\n  classical\n  exact\n    (HasDerivAt.finset_prod (fun i hi ↦ DifferentiableAt.hasDerivAt (hd i hi))).differentiableAt\n\n"}
{"name":"DifferentiableWithinAt.finset_prod","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nx : 𝕜\ns : Set 𝕜\nι : Type u_2\n𝔸' : Type u_3\ninst✝¹ : NormedCommRing 𝔸'\ninst✝ : NormedAlgebra 𝕜 𝔸'\nu : Finset ι\nf : ι → 𝕜 → 𝔸'\nhd : ∀ (i : ι), Membership.mem u i → DifferentiableWithinAt 𝕜 (f i) s x\n⊢ DifferentiableWithinAt 𝕜 (fun x => u.prod fun i => f i x) s x","decl":"@[fun_prop]\ntheorem DifferentiableWithinAt.finset_prod (hd : ∀ i ∈ u, DifferentiableWithinAt 𝕜 (f i) s x) :\n    DifferentiableWithinAt 𝕜 (∏ i ∈ u, f i ·) s x := by\n  classical\n  exact (HasDerivWithinAt.finset_prod (fun i hi ↦\n    DifferentiableWithinAt.hasDerivWithinAt (hd i hi))).differentiableWithinAt\n\n"}
{"name":"DifferentiableOn.finset_prod","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\ns : Set 𝕜\nι : Type u_2\n𝔸' : Type u_3\ninst✝¹ : NormedCommRing 𝔸'\ninst✝ : NormedAlgebra 𝕜 𝔸'\nu : Finset ι\nf : ι → 𝕜 → 𝔸'\nhd : ∀ (i : ι), Membership.mem u i → DifferentiableOn 𝕜 (f i) s\n⊢ DifferentiableOn 𝕜 (fun x => u.prod fun i => f i x) s","decl":"@[fun_prop]\ntheorem DifferentiableOn.finset_prod (hd : ∀ i ∈ u, DifferentiableOn 𝕜 (f i) s) :\n    DifferentiableOn 𝕜 (∏ i ∈ u, f i ·) s :=\n  fun x hx ↦ .finset_prod (fun i hi ↦ hd i hi x hx)\n\n"}
{"name":"Differentiable.finset_prod","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nι : Type u_2\n𝔸' : Type u_3\ninst✝¹ : NormedCommRing 𝔸'\ninst✝ : NormedAlgebra 𝕜 𝔸'\nu : Finset ι\nf : ι → 𝕜 → 𝔸'\nhd : ∀ (i : ι), Membership.mem u i → Differentiable 𝕜 (f i)\n⊢ Differentiable 𝕜 fun x => u.prod fun i => f i x","decl":"@[fun_prop]\ntheorem Differentiable.finset_prod (hd : ∀ i ∈ u, Differentiable 𝕜 (f i)) :\n    Differentiable 𝕜 (∏ i ∈ u, f i ·) :=\n  fun x ↦ .finset_prod (fun i hi ↦ hd i hi x)\n\n"}
{"name":"HasDerivAt.div_const","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nx : 𝕜\n𝕜' : Type u_2\ninst✝¹ : NontriviallyNormedField 𝕜'\ninst✝ : NormedAlgebra 𝕜 𝕜'\nc : 𝕜 → 𝕜'\nc' : 𝕜'\nhc : HasDerivAt c c' x\nd : 𝕜'\n⊢ HasDerivAt (fun x => HDiv.hDiv (c x) d) (HDiv.hDiv c' d) x","decl":"theorem HasDerivAt.div_const (hc : HasDerivAt c c' x) (d : 𝕜') :\n    HasDerivAt (fun x => c x / d) (c' / d) x := by\n  simpa only [div_eq_mul_inv] using hc.mul_const d⁻¹\n\n"}
{"name":"HasDerivWithinAt.div_const","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nx : 𝕜\ns : Set 𝕜\n𝕜' : Type u_2\ninst✝¹ : NontriviallyNormedField 𝕜'\ninst✝ : NormedAlgebra 𝕜 𝕜'\nc : 𝕜 → 𝕜'\nc' : 𝕜'\nhc : HasDerivWithinAt c c' s x\nd : 𝕜'\n⊢ HasDerivWithinAt (fun x => HDiv.hDiv (c x) d) (HDiv.hDiv c' d) s x","decl":"theorem HasDerivWithinAt.div_const (hc : HasDerivWithinAt c c' s x) (d : 𝕜') :\n    HasDerivWithinAt (fun x => c x / d) (c' / d) s x := by\n  simpa only [div_eq_mul_inv] using hc.mul_const d⁻¹\n\n"}
{"name":"HasStrictDerivAt.div_const","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nx : 𝕜\n𝕜' : Type u_2\ninst✝¹ : NontriviallyNormedField 𝕜'\ninst✝ : NormedAlgebra 𝕜 𝕜'\nc : 𝕜 → 𝕜'\nc' : 𝕜'\nhc : HasStrictDerivAt c c' x\nd : 𝕜'\n⊢ HasStrictDerivAt (fun x => HDiv.hDiv (c x) d) (HDiv.hDiv c' d) x","decl":"theorem HasStrictDerivAt.div_const (hc : HasStrictDerivAt c c' x) (d : 𝕜') :\n    HasStrictDerivAt (fun x => c x / d) (c' / d) x := by\n  simpa only [div_eq_mul_inv] using hc.mul_const d⁻¹\n\n"}
{"name":"DifferentiableWithinAt.div_const","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nx : 𝕜\ns : Set 𝕜\n𝕜' : Type u_2\ninst✝¹ : NontriviallyNormedField 𝕜'\ninst✝ : NormedAlgebra 𝕜 𝕜'\nc : 𝕜 → 𝕜'\nhc : DifferentiableWithinAt 𝕜 c s x\nd : 𝕜'\n⊢ DifferentiableWithinAt 𝕜 (fun x => HDiv.hDiv (c x) d) s x","decl":"@[fun_prop]\ntheorem DifferentiableWithinAt.div_const (hc : DifferentiableWithinAt 𝕜 c s x) (d : 𝕜') :\n    DifferentiableWithinAt 𝕜 (fun x => c x / d) s x :=\n  (hc.hasDerivWithinAt.div_const _).differentiableWithinAt\n\n"}
{"name":"DifferentiableAt.div_const","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nx : 𝕜\n𝕜' : Type u_2\ninst✝¹ : NontriviallyNormedField 𝕜'\ninst✝ : NormedAlgebra 𝕜 𝕜'\nc : 𝕜 → 𝕜'\nhc : DifferentiableAt 𝕜 c x\nd : 𝕜'\n⊢ DifferentiableAt 𝕜 (fun x => HDiv.hDiv (c x) d) x","decl":"@[simp, fun_prop]\ntheorem DifferentiableAt.div_const (hc : DifferentiableAt 𝕜 c x) (d : 𝕜') :\n    DifferentiableAt 𝕜 (fun x => c x / d) x :=\n  (hc.hasDerivAt.div_const _).differentiableAt\n\n"}
{"name":"DifferentiableOn.div_const","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\ns : Set 𝕜\n𝕜' : Type u_2\ninst✝¹ : NontriviallyNormedField 𝕜'\ninst✝ : NormedAlgebra 𝕜 𝕜'\nc : 𝕜 → 𝕜'\nhc : DifferentiableOn 𝕜 c s\nd : 𝕜'\n⊢ DifferentiableOn 𝕜 (fun x => HDiv.hDiv (c x) d) s","decl":"@[fun_prop]\ntheorem DifferentiableOn.div_const (hc : DifferentiableOn 𝕜 c s) (d : 𝕜') :\n    DifferentiableOn 𝕜 (fun x => c x / d) s := fun x hx => (hc x hx).div_const d\n\n"}
{"name":"Differentiable.div_const","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\n𝕜' : Type u_2\ninst✝¹ : NontriviallyNormedField 𝕜'\ninst✝ : NormedAlgebra 𝕜 𝕜'\nc : 𝕜 → 𝕜'\nhc : Differentiable 𝕜 c\nd : 𝕜'\n⊢ Differentiable 𝕜 fun x => HDiv.hDiv (c x) d","decl":"@[simp, fun_prop]\ntheorem Differentiable.div_const (hc : Differentiable 𝕜 c) (d : 𝕜') :\n    Differentiable 𝕜 fun x => c x / d := fun x => (hc x).div_const d\n\n"}
{"name":"derivWithin_div_const","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nx : 𝕜\ns : Set 𝕜\n𝕜' : Type u_2\ninst✝¹ : NontriviallyNormedField 𝕜'\ninst✝ : NormedAlgebra 𝕜 𝕜'\nc : 𝕜 → 𝕜'\nhc : DifferentiableWithinAt 𝕜 c s x\nd : 𝕜'\n⊢ Eq (derivWithin (fun x => HDiv.hDiv (c x) d) s x) (HDiv.hDiv (derivWithin c s x) d)","decl":"theorem derivWithin_div_const (hc : DifferentiableWithinAt 𝕜 c s x) (d : 𝕜') :\n    derivWithin (fun x => c x / d) s x = derivWithin c s x / d := by\n  simp [div_eq_inv_mul, derivWithin_const_mul, hc]\n\n"}
{"name":"deriv_div_const","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nx : 𝕜\n𝕜' : Type u_2\ninst✝¹ : NontriviallyNormedField 𝕜'\ninst✝ : NormedAlgebra 𝕜 𝕜'\nc : 𝕜 → 𝕜'\nd : 𝕜'\n⊢ Eq (deriv (fun x => HDiv.hDiv (c x) d) x) (HDiv.hDiv (deriv c x) d)","decl":"@[simp]\ntheorem deriv_div_const (d : 𝕜') : deriv (fun x => c x / d) x = deriv c x / d := by\n  simp only [div_eq_mul_inv, deriv_mul_const_field]\n\n"}
{"name":"HasStrictDerivAt.clm_comp","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝⁶ : NontriviallyNormedField 𝕜\nF : Type v\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nE : Type w\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nx : 𝕜\nG : Type u_2\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nc : 𝕜 → ContinuousLinearMap (RingHom.id 𝕜) F G\nc' : ContinuousLinearMap (RingHom.id 𝕜) F G\nd : 𝕜 → ContinuousLinearMap (RingHom.id 𝕜) E F\nd' : ContinuousLinearMap (RingHom.id 𝕜) E F\nhc : HasStrictDerivAt c c' x\nhd : HasStrictDerivAt d d' x\n⊢ HasStrictDerivAt (fun y => (c y).comp (d y)) (HAdd.hAdd (c'.comp (d x)) ((c x).comp d')) x","decl":"theorem HasStrictDerivAt.clm_comp (hc : HasStrictDerivAt c c' x) (hd : HasStrictDerivAt d d' x) :\n    HasStrictDerivAt (fun y => (c y).comp (d y)) (c'.comp (d x) + (c x).comp d') x := by\n  have := (hc.hasStrictFDerivAt.clm_comp hd.hasStrictFDerivAt).hasStrictDerivAt\n  rwa [add_apply, comp_apply, comp_apply, smulRight_apply, smulRight_apply, one_apply, one_smul,\n    one_smul, add_comm] at this\n\n"}
{"name":"HasDerivWithinAt.clm_comp","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝⁶ : NontriviallyNormedField 𝕜\nF : Type v\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nE : Type w\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nx : 𝕜\ns : Set 𝕜\nG : Type u_2\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nc : 𝕜 → ContinuousLinearMap (RingHom.id 𝕜) F G\nc' : ContinuousLinearMap (RingHom.id 𝕜) F G\nd : 𝕜 → ContinuousLinearMap (RingHom.id 𝕜) E F\nd' : ContinuousLinearMap (RingHom.id 𝕜) E F\nhc : HasDerivWithinAt c c' s x\nhd : HasDerivWithinAt d d' s x\n⊢ HasDerivWithinAt (fun y => (c y).comp (d y)) (HAdd.hAdd (c'.comp (d x)) ((c x).comp d')) s x","decl":"theorem HasDerivWithinAt.clm_comp (hc : HasDerivWithinAt c c' s x)\n    (hd : HasDerivWithinAt d d' s x) :\n    HasDerivWithinAt (fun y => (c y).comp (d y)) (c'.comp (d x) + (c x).comp d') s x := by\n  have := (hc.hasFDerivWithinAt.clm_comp hd.hasFDerivWithinAt).hasDerivWithinAt\n  rwa [add_apply, comp_apply, comp_apply, smulRight_apply, smulRight_apply, one_apply, one_smul,\n    one_smul, add_comm] at this\n\n"}
{"name":"HasDerivAt.clm_comp","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝⁶ : NontriviallyNormedField 𝕜\nF : Type v\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nE : Type w\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nx : 𝕜\nG : Type u_2\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nc : 𝕜 → ContinuousLinearMap (RingHom.id 𝕜) F G\nc' : ContinuousLinearMap (RingHom.id 𝕜) F G\nd : 𝕜 → ContinuousLinearMap (RingHom.id 𝕜) E F\nd' : ContinuousLinearMap (RingHom.id 𝕜) E F\nhc : HasDerivAt c c' x\nhd : HasDerivAt d d' x\n⊢ HasDerivAt (fun y => (c y).comp (d y)) (HAdd.hAdd (c'.comp (d x)) ((c x).comp d')) x","decl":"theorem HasDerivAt.clm_comp (hc : HasDerivAt c c' x) (hd : HasDerivAt d d' x) :\n    HasDerivAt (fun y => (c y).comp (d y)) (c'.comp (d x) + (c x).comp d') x := by\n  rw [← hasDerivWithinAt_univ] at *\n  exact hc.clm_comp hd\n\n"}
{"name":"derivWithin_clm_comp","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝⁶ : NontriviallyNormedField 𝕜\nF : Type v\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nE : Type w\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nx : 𝕜\ns : Set 𝕜\nG : Type u_2\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nc : 𝕜 → ContinuousLinearMap (RingHom.id 𝕜) F G\nd : 𝕜 → ContinuousLinearMap (RingHom.id 𝕜) E F\nhc : DifferentiableWithinAt 𝕜 c s x\nhd : DifferentiableWithinAt 𝕜 d s x\n⊢ Eq (derivWithin (fun y => (c y).comp (d y)) s x) (HAdd.hAdd ((derivWithin c s x).comp (d x)) ((c x).comp (derivWithin d s x)))","decl":"theorem derivWithin_clm_comp (hc : DifferentiableWithinAt 𝕜 c s x)\n    (hd : DifferentiableWithinAt 𝕜 d s x) :\n    derivWithin (fun y => (c y).comp (d y)) s x =\n      (derivWithin c s x).comp (d x) + (c x).comp (derivWithin d s x) := by\n  rcases uniqueDiffWithinAt_or_nhdsWithin_eq_bot s x with hxs | hxs\n  · exact (hc.hasDerivWithinAt.clm_comp hd.hasDerivWithinAt).derivWithin hxs\n  · simp [derivWithin_zero_of_isolated hxs]\n\n"}
{"name":"deriv_clm_comp","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝⁶ : NontriviallyNormedField 𝕜\nF : Type v\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nE : Type w\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nx : 𝕜\nG : Type u_2\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nc : 𝕜 → ContinuousLinearMap (RingHom.id 𝕜) F G\nd : 𝕜 → ContinuousLinearMap (RingHom.id 𝕜) E F\nhc : DifferentiableAt 𝕜 c x\nhd : DifferentiableAt 𝕜 d x\n⊢ Eq (deriv (fun y => (c y).comp (d y)) x) (HAdd.hAdd ((deriv c x).comp (d x)) ((c x).comp (deriv d x)))","decl":"theorem deriv_clm_comp (hc : DifferentiableAt 𝕜 c x) (hd : DifferentiableAt 𝕜 d x) :\n    deriv (fun y => (c y).comp (d y)) x = (deriv c x).comp (d x) + (c x).comp (deriv d x) :=\n  (hc.hasDerivAt.clm_comp hd.hasDerivAt).deriv\n\n"}
{"name":"HasStrictDerivAt.clm_apply","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nF : Type v\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nx : 𝕜\nG : Type u_2\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nc : 𝕜 → ContinuousLinearMap (RingHom.id 𝕜) F G\nc' : ContinuousLinearMap (RingHom.id 𝕜) F G\nu : 𝕜 → F\nu' : F\nhc : HasStrictDerivAt c c' x\nhu : HasStrictDerivAt u u' x\n⊢ HasStrictDerivAt (fun y => (c y) (u y)) (HAdd.hAdd (c' (u x)) ((c x) u')) x","decl":"theorem HasStrictDerivAt.clm_apply (hc : HasStrictDerivAt c c' x) (hu : HasStrictDerivAt u u' x) :\n    HasStrictDerivAt (fun y => (c y) (u y)) (c' (u x) + c x u') x := by\n  have := (hc.hasStrictFDerivAt.clm_apply hu.hasStrictFDerivAt).hasStrictDerivAt\n  rwa [add_apply, comp_apply, flip_apply, smulRight_apply, smulRight_apply, one_apply, one_smul,\n    one_smul, add_comm] at this\n\n"}
{"name":"HasDerivWithinAt.clm_apply","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nF : Type v\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nx : 𝕜\ns : Set 𝕜\nG : Type u_2\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nc : 𝕜 → ContinuousLinearMap (RingHom.id 𝕜) F G\nc' : ContinuousLinearMap (RingHom.id 𝕜) F G\nu : 𝕜 → F\nu' : F\nhc : HasDerivWithinAt c c' s x\nhu : HasDerivWithinAt u u' s x\n⊢ HasDerivWithinAt (fun y => (c y) (u y)) (HAdd.hAdd (c' (u x)) ((c x) u')) s x","decl":"theorem HasDerivWithinAt.clm_apply (hc : HasDerivWithinAt c c' s x)\n    (hu : HasDerivWithinAt u u' s x) :\n    HasDerivWithinAt (fun y => (c y) (u y)) (c' (u x) + c x u') s x := by\n  have := (hc.hasFDerivWithinAt.clm_apply hu.hasFDerivWithinAt).hasDerivWithinAt\n  rwa [add_apply, comp_apply, flip_apply, smulRight_apply, smulRight_apply, one_apply, one_smul,\n    one_smul, add_comm] at this\n\n"}
{"name":"HasDerivAt.clm_apply","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nF : Type v\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nx : 𝕜\nG : Type u_2\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nc : 𝕜 → ContinuousLinearMap (RingHom.id 𝕜) F G\nc' : ContinuousLinearMap (RingHom.id 𝕜) F G\nu : 𝕜 → F\nu' : F\nhc : HasDerivAt c c' x\nhu : HasDerivAt u u' x\n⊢ HasDerivAt (fun y => (c y) (u y)) (HAdd.hAdd (c' (u x)) ((c x) u')) x","decl":"theorem HasDerivAt.clm_apply (hc : HasDerivAt c c' x) (hu : HasDerivAt u u' x) :\n    HasDerivAt (fun y => (c y) (u y)) (c' (u x) + c x u') x := by\n  have := (hc.hasFDerivAt.clm_apply hu.hasFDerivAt).hasDerivAt\n  rwa [add_apply, comp_apply, flip_apply, smulRight_apply, smulRight_apply, one_apply, one_smul,\n    one_smul, add_comm] at this\n\n"}
{"name":"derivWithin_clm_apply","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nF : Type v\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nx : 𝕜\ns : Set 𝕜\nG : Type u_2\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nc : 𝕜 → ContinuousLinearMap (RingHom.id 𝕜) F G\nu : 𝕜 → F\nhc : DifferentiableWithinAt 𝕜 c s x\nhu : DifferentiableWithinAt 𝕜 u s x\n⊢ Eq (derivWithin (fun y => (c y) (u y)) s x) (HAdd.hAdd ((derivWithin c s x) (u x)) ((c x) (derivWithin u s x)))","decl":"theorem derivWithin_clm_apply (hc : DifferentiableWithinAt 𝕜 c s x)\n    (hu : DifferentiableWithinAt 𝕜 u s x) :\n    derivWithin (fun y => (c y) (u y)) s x = derivWithin c s x (u x) + c x (derivWithin u s x) := by\n  rcases uniqueDiffWithinAt_or_nhdsWithin_eq_bot s x with hxs | hxs\n  · exact (hc.hasDerivWithinAt.clm_apply hu.hasDerivWithinAt).derivWithin hxs\n  · simp [derivWithin_zero_of_isolated hxs]\n\n"}
{"name":"deriv_clm_apply","module":"Mathlib.Analysis.Calculus.Deriv.Mul","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nF : Type v\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nx : 𝕜\nG : Type u_2\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nc : 𝕜 → ContinuousLinearMap (RingHom.id 𝕜) F G\nu : 𝕜 → F\nhc : DifferentiableAt 𝕜 c x\nhu : DifferentiableAt 𝕜 u x\n⊢ Eq (deriv (fun y => (c y) (u y)) x) (HAdd.hAdd ((deriv c x) (u x)) ((c x) (deriv u x)))","decl":"theorem deriv_clm_apply (hc : DifferentiableAt 𝕜 c x) (hu : DifferentiableAt 𝕜 u x) :\n    deriv (fun y => (c y) (u y)) x = deriv c x (u x) + c x (deriv u x) :=\n  (hc.hasDerivAt.clm_apply hu.hasDerivAt).deriv\n\n"}
