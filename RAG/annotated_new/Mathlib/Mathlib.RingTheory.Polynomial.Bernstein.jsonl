{"name":"bernsteinPolynomial.eq_zero_of_lt","module":"Mathlib.RingTheory.Polynomial.Bernstein","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn ν : Nat\nh : LT.lt n ν\n⊢ Eq (bernsteinPolynomial R n ν) 0","decl":"theorem eq_zero_of_lt {n ν : ℕ} (h : n < ν) : bernsteinPolynomial R n ν = 0 := by\n  simp [bernsteinPolynomial, Nat.choose_eq_zero_of_lt h]\n\n"}
{"name":"bernsteinPolynomial.map","module":"Mathlib.RingTheory.Polynomial.Bernstein","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\nS : Type u_2\ninst✝ : CommRing S\nf : RingHom R S\nn ν : Nat\n⊢ Eq (Polynomial.map f (bernsteinPolynomial R n ν)) (bernsteinPolynomial S n ν)","decl":"@[simp]\ntheorem map (f : R →+* S) (n ν : ℕ) :\n    (bernsteinPolynomial R n ν).map f = bernsteinPolynomial S n ν := by simp [bernsteinPolynomial]\n\n"}
{"name":"bernsteinPolynomial.flip","module":"Mathlib.RingTheory.Polynomial.Bernstein","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn ν : Nat\nh : LE.le ν n\n⊢ Eq ((bernsteinPolynomial R n ν).comp (HSub.hSub 1 Polynomial.X)) (bernsteinPolynomial R n (HSub.hSub n ν))","decl":"theorem flip (n ν : ℕ) (h : ν ≤ n) :\n    (bernsteinPolynomial R n ν).comp (1 - X) = bernsteinPolynomial R n (n - ν) := by\n  simp [bernsteinPolynomial, h, tsub_tsub_assoc, mul_right_comm]\n\n"}
{"name":"bernsteinPolynomial.flip'","module":"Mathlib.RingTheory.Polynomial.Bernstein","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn ν : Nat\nh : LE.le ν n\n⊢ Eq (bernsteinPolynomial R n ν) ((bernsteinPolynomial R n (HSub.hSub n ν)).comp (HSub.hSub 1 Polynomial.X))","decl":"theorem flip' (n ν : ℕ) (h : ν ≤ n) :\n    bernsteinPolynomial R n ν = (bernsteinPolynomial R n (n - ν)).comp (1 - X) := by\n  simp [← flip _ _ _ h, Polynomial.comp_assoc]\n\n"}
{"name":"bernsteinPolynomial.eval_at_0","module":"Mathlib.RingTheory.Polynomial.Bernstein","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn ν : Nat\n⊢ Eq (Polynomial.eval 0 (bernsteinPolynomial R n ν)) (ite (Eq ν 0) 1 0)","decl":"theorem eval_at_0 (n ν : ℕ) : (bernsteinPolynomial R n ν).eval 0 = if ν = 0 then 1 else 0 := by\n  rw [bernsteinPolynomial]\n  split_ifs with h\n  · subst h; simp\n  · simp [zero_pow h]\n\n"}
{"name":"bernsteinPolynomial.eval_at_1","module":"Mathlib.RingTheory.Polynomial.Bernstein","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn ν : Nat\n⊢ Eq (Polynomial.eval 1 (bernsteinPolynomial R n ν)) (ite (Eq ν n) 1 0)","decl":"theorem eval_at_1 (n ν : ℕ) : (bernsteinPolynomial R n ν).eval 1 = if ν = n then 1 else 0 := by\n  rw [bernsteinPolynomial]\n  split_ifs with h\n  · subst h; simp\n  · obtain hνn | hnν := Ne.lt_or_lt h\n    · simp [zero_pow <| Nat.sub_ne_zero_of_lt hνn]\n    · simp [Nat.choose_eq_zero_of_lt hnν]\n\n"}
{"name":"bernsteinPolynomial.derivative_succ_aux","module":"Mathlib.RingTheory.Polynomial.Bernstein","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn ν : Nat\n⊢ Eq (Polynomial.derivative (bernsteinPolynomial R (HAdd.hAdd n 1) (HAdd.hAdd ν 1))) (HMul.hMul (HAdd.hAdd (↑n) 1) (HSub.hSub (bernsteinPolynomial R n ν) (bernsteinPolynomial R n (HAdd.hAdd ν 1))))","decl":"theorem derivative_succ_aux (n ν : ℕ) :\n    Polynomial.derivative (bernsteinPolynomial R (n + 1) (ν + 1)) =\n      (n + 1) * (bernsteinPolynomial R n ν - bernsteinPolynomial R n (ν + 1)) := by\n  rw [bernsteinPolynomial]\n  suffices ((n + 1).choose (ν + 1) : R[X]) * ((↑(ν + 1 : ℕ) : R[X]) * X ^ ν) * (1 - X) ^ (n - ν) -\n      ((n + 1).choose (ν + 1) : R[X]) * X ^ (ν + 1) * ((↑(n - ν) : R[X]) * (1 - X) ^ (n - ν - 1)) =\n      (↑(n + 1) : R[X]) * ((n.choose ν : R[X]) * X ^ ν * (1 - X) ^ (n - ν) -\n        (n.choose (ν + 1) : R[X]) * X ^ (ν + 1) * (1 - X) ^ (n - (ν + 1))) by\n    simpa [Polynomial.derivative_pow, ← sub_eq_add_neg, Nat.succ_sub_succ_eq_sub,\n      Polynomial.derivative_mul, Polynomial.derivative_natCast, zero_mul,\n      Nat.cast_add, algebraMap.coe_one, Polynomial.derivative_X, mul_one, zero_add,\n      Polynomial.derivative_sub, Polynomial.derivative_one, zero_sub, mul_neg, Nat.sub_zero,\n      bernsteinPolynomial, map_add, map_natCast, Nat.cast_one]\n  conv_rhs => rw [mul_sub]\n  -- We'll prove the two terms match up separately.\n  refine congr (congr_arg Sub.sub ?_) ?_\n  · simp only [← mul_assoc]\n    apply congr (congr_arg (· * ·) (congr (congr_arg (· * ·) _) rfl)) rfl\n    -- Now it's just about binomial coefficients\n    exact mod_cast congr_arg (fun m : ℕ => (m : R[X])) (Nat.succ_mul_choose_eq n ν).symm\n  · rw [← tsub_add_eq_tsub_tsub, ← mul_assoc, ← mul_assoc]; congr 1\n    rw [mul_comm, ← mul_assoc, ← mul_assoc]; congr 1\n    norm_cast\n    congr 1\n    convert (Nat.choose_mul_succ_eq n (ν + 1)).symm using 1\n    · -- Porting note: was\n      -- convert mul_comm _ _ using 2\n      -- simp\n      rw [mul_comm, Nat.succ_sub_succ_eq_sub]\n    · apply mul_comm\n\n"}
{"name":"bernsteinPolynomial.derivative_succ","module":"Mathlib.RingTheory.Polynomial.Bernstein","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn ν : Nat\n⊢ Eq (Polynomial.derivative (bernsteinPolynomial R n (HAdd.hAdd ν 1))) (HMul.hMul (↑n) (HSub.hSub (bernsteinPolynomial R (HSub.hSub n 1) ν) (bernsteinPolynomial R (HSub.hSub n 1) (HAdd.hAdd ν 1))))","decl":"theorem derivative_succ (n ν : ℕ) : Polynomial.derivative (bernsteinPolynomial R n (ν + 1)) =\n    n * (bernsteinPolynomial R (n - 1) ν - bernsteinPolynomial R (n - 1) (ν + 1)) := by\n  cases n\n  · simp [bernsteinPolynomial]\n  · rw [Nat.cast_succ]; apply derivative_succ_aux\n\n"}
{"name":"bernsteinPolynomial.derivative_zero","module":"Mathlib.RingTheory.Polynomial.Bernstein","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Nat\n⊢ Eq (Polynomial.derivative (bernsteinPolynomial R n 0)) (HMul.hMul (Neg.neg ↑n) (bernsteinPolynomial R (HSub.hSub n 1) 0))","decl":"theorem derivative_zero (n : ℕ) :\n    Polynomial.derivative (bernsteinPolynomial R n 0) = -n * bernsteinPolynomial R (n - 1) 0 := by\n  simp [bernsteinPolynomial, Polynomial.derivative_pow]\n\n"}
{"name":"bernsteinPolynomial.iterate_derivative_at_0_eq_zero_of_lt","module":"Mathlib.RingTheory.Polynomial.Bernstein","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn ν k : Nat\na✝ : LT.lt k ν\n⊢ Eq (Polynomial.eval 0 (Nat.iterate (⇑Polynomial.derivative) k (bernsteinPolynomial R n ν))) 0","decl":"theorem iterate_derivative_at_0_eq_zero_of_lt (n : ℕ) {ν k : ℕ} :\n    k < ν → (Polynomial.derivative^[k] (bernsteinPolynomial R n ν)).eval 0 = 0 := by\n  cases' ν with ν\n  · rintro ⟨⟩\n  · rw [Nat.lt_succ_iff]\n    induction' k with k ih generalizing n ν\n    · simp [eval_at_0]\n    · simp only [derivative_succ, Int.natCast_eq_zero, mul_eq_zero, Function.comp_apply,\n        Function.iterate_succ, Polynomial.iterate_derivative_sub,\n        Polynomial.iterate_derivative_natCast_mul, Polynomial.eval_mul, Polynomial.eval_natCast,\n        Polynomial.eval_sub]\n      intro h\n      apply mul_eq_zero_of_right\n      rw [ih _ _ (Nat.le_of_succ_le h), sub_zero]\n      convert ih _ _ (Nat.pred_le_pred h)\n      exact (Nat.succ_pred_eq_of_pos (k.succ_pos.trans_le h)).symm\n\n"}
{"name":"bernsteinPolynomial.iterate_derivative_succ_at_0_eq_zero","module":"Mathlib.RingTheory.Polynomial.Bernstein","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn ν : Nat\n⊢ Eq (Polynomial.eval 0 (Nat.iterate (⇑Polynomial.derivative) ν (bernsteinPolynomial R n (HAdd.hAdd ν 1)))) 0","decl":"@[simp]\ntheorem iterate_derivative_succ_at_0_eq_zero (n ν : ℕ) :\n    (Polynomial.derivative^[ν] (bernsteinPolynomial R n (ν + 1))).eval 0 = 0 :=\n  iterate_derivative_at_0_eq_zero_of_lt R n (lt_add_one ν)\n\n"}
{"name":"bernsteinPolynomial.iterate_derivative_at_0","module":"Mathlib.RingTheory.Polynomial.Bernstein","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn ν : Nat\n⊢ Eq (Polynomial.eval 0 (Nat.iterate (⇑Polynomial.derivative) ν (bernsteinPolynomial R n ν))) (Polynomial.eval (↑(HSub.hSub n (HSub.hSub ν 1))) (ascPochhammer R ν))","decl":"@[simp]\ntheorem iterate_derivative_at_0 (n ν : ℕ) :\n    (Polynomial.derivative^[ν] (bernsteinPolynomial R n ν)).eval 0 =\n      (ascPochhammer R ν).eval ((n - (ν - 1) : ℕ) : R) := by\n  by_cases h : ν ≤ n\n  · induction' ν with ν ih generalizing n\n    · simp [eval_at_0]\n    · have h' : ν ≤ n - 1 := le_tsub_of_add_le_right h\n      simp only [derivative_succ, ih (n - 1) h', iterate_derivative_succ_at_0_eq_zero,\n        Nat.succ_sub_succ_eq_sub, tsub_zero, sub_zero, iterate_derivative_sub,\n        iterate_derivative_natCast_mul, eval_one, eval_mul, eval_add, eval_sub, eval_X, eval_comp,\n        eval_natCast, Function.comp_apply, Function.iterate_succ, ascPochhammer_succ_left]\n      obtain rfl | h'' := ν.eq_zero_or_pos\n      · simp\n      · have : n - 1 - (ν - 1) = n - ν := by omega\n        rw [this, ascPochhammer_eval_succ]\n        rw_mod_cast [tsub_add_cancel_of_le (h'.trans n.pred_le)]\n  · simp only [not_le] at h\n    rw [tsub_eq_zero_iff_le.mpr (Nat.le_sub_one_of_lt h), eq_zero_of_lt R h]\n    simp [pos_iff_ne_zero.mp (pos_of_gt h)]\n\n"}
{"name":"bernsteinPolynomial.iterate_derivative_at_0_ne_zero","module":"Mathlib.RingTheory.Polynomial.Bernstein","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : CharZero R\nn ν : Nat\nh : LE.le ν n\n⊢ Ne (Polynomial.eval 0 (Nat.iterate (⇑Polynomial.derivative) ν (bernsteinPolynomial R n ν))) 0","decl":"theorem iterate_derivative_at_0_ne_zero [CharZero R] (n ν : ℕ) (h : ν ≤ n) :\n    (Polynomial.derivative^[ν] (bernsteinPolynomial R n ν)).eval 0 ≠ 0 := by\n  simp only [Int.natCast_eq_zero, bernsteinPolynomial.iterate_derivative_at_0, Ne, Nat.cast_eq_zero]\n  simp only [← ascPochhammer_eval_cast]\n  norm_cast\n  apply ne_of_gt\n  obtain rfl | h' := Nat.eq_zero_or_pos ν\n  · simp\n  · rw [← Nat.succ_pred_eq_of_pos h'] at h\n    exact ascPochhammer_pos _ _ (tsub_pos_of_lt (Nat.lt_of_succ_le h))\n\n"}
{"name":"bernsteinPolynomial.iterate_derivative_at_1_eq_zero_of_lt","module":"Mathlib.RingTheory.Polynomial.Bernstein","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn ν k : Nat\na✝ : LT.lt k (HSub.hSub n ν)\n⊢ Eq (Polynomial.eval 1 (Nat.iterate (⇑Polynomial.derivative) k (bernsteinPolynomial R n ν))) 0","decl":"theorem iterate_derivative_at_1_eq_zero_of_lt (n : ℕ) {ν k : ℕ} :\n    k < n - ν → (Polynomial.derivative^[k] (bernsteinPolynomial R n ν)).eval 1 = 0 := by\n  intro w\n  rw [flip' _ _ _ (tsub_pos_iff_lt.mp (pos_of_gt w)).le]\n  simp [Polynomial.eval_comp, iterate_derivative_at_0_eq_zero_of_lt R n w]\n\n"}
{"name":"bernsteinPolynomial.iterate_derivative_at_1","module":"Mathlib.RingTheory.Polynomial.Bernstein","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn ν : Nat\nh : LE.le ν n\n⊢ Eq (Polynomial.eval 1 (Nat.iterate (⇑Polynomial.derivative) (HSub.hSub n ν) (bernsteinPolynomial R n ν))) (HMul.hMul (HPow.hPow (-1) (HSub.hSub n ν)) (Polynomial.eval (HAdd.hAdd (↑ν) 1) (ascPochhammer R (HSub.hSub n ν))))","decl":"@[simp]\ntheorem iterate_derivative_at_1 (n ν : ℕ) (h : ν ≤ n) :\n    (Polynomial.derivative^[n - ν] (bernsteinPolynomial R n ν)).eval 1 =\n      (-1) ^ (n - ν) * (ascPochhammer R (n - ν)).eval (ν + 1 : R) := by\n  rw [flip' _ _ _ h]\n  simp [Polynomial.eval_comp, h]\n  obtain rfl | h' := h.eq_or_lt\n  · simp\n  · norm_cast\n    congr\n    omega\n\n"}
{"name":"bernsteinPolynomial.iterate_derivative_at_1_ne_zero","module":"Mathlib.RingTheory.Polynomial.Bernstein","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : CharZero R\nn ν : Nat\nh : LE.le ν n\n⊢ Ne (Polynomial.eval 1 (Nat.iterate (⇑Polynomial.derivative) (HSub.hSub n ν) (bernsteinPolynomial R n ν))) 0","decl":"theorem iterate_derivative_at_1_ne_zero [CharZero R] (n ν : ℕ) (h : ν ≤ n) :\n    (Polynomial.derivative^[n - ν] (bernsteinPolynomial R n ν)).eval 1 ≠ 0 := by\n  rw [bernsteinPolynomial.iterate_derivative_at_1 _ _ _ h, Ne, neg_one_pow_mul_eq_zero_iff, ←\n    Nat.cast_succ, ← ascPochhammer_eval_cast, ← Nat.cast_zero, Nat.cast_inj]\n  exact (ascPochhammer_pos _ _ (Nat.succ_pos ν)).ne'\n\n"}
{"name":"bernsteinPolynomial.linearIndependent_aux","module":"Mathlib.RingTheory.Polynomial.Bernstein","initialProofState":"n k : Nat\nh : LE.le k (HAdd.hAdd n 1)\n⊢ LinearIndependent Rat fun ν => bernsteinPolynomial Rat n ↑ν","decl":"theorem linearIndependent_aux (n k : ℕ) (h : k ≤ n + 1) :\n    LinearIndependent ℚ fun ν : Fin k => bernsteinPolynomial ℚ n ν := by\n  induction' k with k ih\n  · apply linearIndependent_empty_type\n  · apply linearIndependent_fin_succ'.mpr\n    fconstructor\n    · exact ih (le_of_lt h)\n    · -- The actual work!\n      -- We show that the (n-k)-th derivative at 1 doesn't vanish,\n      -- but vanishes for everything in the span.\n      clear ih\n      simp only [Nat.succ_eq_add_one, add_le_add_iff_right] at h\n      simp only [Fin.val_last, Fin.init_def]\n      dsimp\n      apply not_mem_span_of_apply_not_mem_span_image (@Polynomial.derivative ℚ _ ^ (n - k))\n      -- Note: https://github.com/leanprover-community/mathlib4/pull/8386 had to change `span_image` into `span_image _`\n      simp only [not_exists, not_and, Submodule.mem_map, Submodule.span_image _]\n      intro p m\n      apply_fun Polynomial.eval (1 : ℚ)\n      simp only [LinearMap.pow_apply]\n      -- The right hand side is nonzero,\n      -- so it will suffice to show the left hand side is always zero.\n      suffices (Polynomial.derivative^[n - k] p).eval 1 = 0 by\n        rw [this]\n        exact (iterate_derivative_at_1_ne_zero ℚ n k h).symm\n      refine span_induction ?_ ?_ ?_ ?_ m\n      · simp only [Set.mem_range, forall_exists_index, forall_apply_eq_imp_iff]\n        rintro ⟨a, w⟩; simp only [Fin.val_mk]\n        rw [iterate_derivative_at_1_eq_zero_of_lt ℚ n ((tsub_lt_tsub_iff_left_of_le h).mpr w)]\n      · simp\n      · intro x y _ _ hx hy; simp [hx, hy]\n      · intro a x _ h; simp [h]\n\n"}
{"name":"bernsteinPolynomial.linearIndependent","module":"Mathlib.RingTheory.Polynomial.Bernstein","initialProofState":"n : Nat\n⊢ LinearIndependent Rat fun ν => bernsteinPolynomial Rat n ↑ν","decl":"/-- The Bernstein polynomials are linearly independent.\n\nWe prove by induction that the collection of `bernsteinPolynomial n ν` for `ν = 0, ..., k`\nare linearly independent.\nThe inductive step relies on the observation that the `(n-k)`-th derivative, evaluated at 1,\nannihilates `bernsteinPolynomial n ν` for `ν < k`, but has a nonzero value at `ν = k`.\n-/\ntheorem linearIndependent (n : ℕ) :\n    LinearIndependent ℚ fun ν : Fin (n + 1) => bernsteinPolynomial ℚ n ν :=\n  linearIndependent_aux n (n + 1) le_rfl\n\n"}
{"name":"bernsteinPolynomial.sum","module":"Mathlib.RingTheory.Polynomial.Bernstein","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Nat\n⊢ Eq ((Finset.range (HAdd.hAdd n 1)).sum fun ν => bernsteinPolynomial R n ν) 1","decl":"theorem sum (n : ℕ) : (∑ ν ∈ Finset.range (n + 1), bernsteinPolynomial R n ν) = 1 :=\n  calc\n    (∑ ν ∈ Finset.range (n + 1), bernsteinPolynomial R n ν) = (X + (1 - X)) ^ n := by\n      rw [add_pow]\n      simp only [bernsteinPolynomial, mul_comm, mul_assoc, mul_left_comm]\n    _ = 1 := by simp\n\n"}
{"name":"bernsteinPolynomial.sum_smul","module":"Mathlib.RingTheory.Polynomial.Bernstein","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Nat\n⊢ Eq ((Finset.range (HAdd.hAdd n 1)).sum fun ν => HSMul.hSMul ν (bernsteinPolynomial R n ν)) (HSMul.hSMul n Polynomial.X)","decl":"theorem sum_smul (n : ℕ) :\n    (∑ ν ∈ Finset.range (n + 1), ν • bernsteinPolynomial R n ν) = n • X := by\n  -- We calculate the `x`-derivative of `(x+y)^n`, evaluated at `y=(1-x)`,\n  -- either directly or by using the binomial theorem.\n  -- We'll work in `MvPolynomial Bool R`.\n  let x : MvPolynomial Bool R := MvPolynomial.X true\n  let y : MvPolynomial Bool R := MvPolynomial.X false\n  have pderiv_true_x : pderiv true x = 1 := by rw [pderiv_X]; rfl\n  have pderiv_true_y : pderiv true y = 0 := by rw [pderiv_X]; rfl\n  let e : Bool → R[X] := fun i => cond i X (1 - X)\n  -- Start with `(x+y)^n = (x+y)^n`,\n  -- take the `x`-derivative, evaluate at `x=X, y=1-X`, and multiply by `X`:\n  trans MvPolynomial.aeval e (pderiv true ((x + y) ^ n)) * X\n  -- On the left hand side we'll use the binomial theorem, then simplify.\n  · -- We first prepare a tedious rewrite:\n    have w : ∀ k : ℕ, k • bernsteinPolynomial R n k =\n        (k : R[X]) * Polynomial.X ^ (k - 1) * (1 - Polynomial.X) ^ (n - k) * (n.choose k : R[X]) *\n          Polynomial.X := by\n      rintro (_ | k)\n      · simp\n      · rw [bernsteinPolynomial]\n        simp only [← natCast_mul, Nat.succ_eq_add_one, Nat.add_succ_sub_one, add_zero, pow_succ]\n        push_cast\n        ring\n    rw [add_pow, map_sum (pderiv true), map_sum (MvPolynomial.aeval e), Finset.sum_mul]\n    -- Step inside the sum:\n    refine Finset.sum_congr rfl fun k _ => (w k).trans ?_\n    simp only [x, y, e, pderiv_true_x, pderiv_true_y, Algebra.id.smul_eq_mul, nsmul_eq_mul,\n      Bool.cond_true, Bool.cond_false, add_zero, mul_one, mul_zero, smul_zero, MvPolynomial.aeval_X,\n      MvPolynomial.pderiv_mul, Derivation.leibniz_pow, Derivation.map_natCast, map_natCast, map_pow,\n      map_mul]\n  · rw [(pderiv true).leibniz_pow, (pderiv true).map_add, pderiv_true_x, pderiv_true_y]\n    simp only [x, y, e, Algebra.id.smul_eq_mul, nsmul_eq_mul, map_natCast, map_pow, map_add,\n      map_mul, Bool.cond_true, Bool.cond_false, MvPolynomial.aeval_X, add_sub_cancel,\n      one_pow, add_zero, mul_one]\n\n"}
{"name":"bernsteinPolynomial.sum_mul_smul","module":"Mathlib.RingTheory.Polynomial.Bernstein","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Nat\n⊢ Eq ((Finset.range (HAdd.hAdd n 1)).sum fun ν => HSMul.hSMul (HMul.hMul ν (HSub.hSub ν 1)) (bernsteinPolynomial R n ν)) (HSMul.hSMul (HMul.hMul n (HSub.hSub n 1)) (HPow.hPow Polynomial.X 2))","decl":"theorem sum_mul_smul (n : ℕ) :\n    (∑ ν ∈ Finset.range (n + 1), (ν * (ν - 1)) • bernsteinPolynomial R n ν) =\n      (n * (n - 1)) • X ^ 2 := by\n  -- We calculate the second `x`-derivative of `(x+y)^n`, evaluated at `y=(1-x)`,\n  -- either directly or by using the binomial theorem.\n  -- We'll work in `MvPolynomial Bool R`.\n  let x : MvPolynomial Bool R := MvPolynomial.X true\n  let y : MvPolynomial Bool R := MvPolynomial.X false\n  have pderiv_true_x : pderiv true x = 1 := by rw [pderiv_X]; rfl\n  have pderiv_true_y : pderiv true y = 0 := by rw [pderiv_X]; rfl\n  let e : Bool → R[X] := fun i => cond i X (1 - X)\n  -- Start with `(x+y)^n = (x+y)^n`,\n  -- take the second `x`-derivative, evaluate at `x=X, y=1-X`, and multiply by `X`:\n  trans MvPolynomial.aeval e (pderiv true (pderiv true ((x + y) ^ n))) * X ^ 2\n  -- On the left hand side we'll use the binomial theorem, then simplify.\n  · -- We first prepare a tedious rewrite:\n    have w : ∀ k : ℕ, (k * (k - 1)) • bernsteinPolynomial R n k =\n        (n.choose k : R[X]) * ((1 - Polynomial.X) ^ (n - k) *\n          ((k : R[X]) * ((↑(k - 1) : R[X]) * Polynomial.X ^ (k - 1 - 1)))) * Polynomial.X ^ 2 := by\n      rintro (_ | _ | k)\n      · simp\n      · simp\n      · rw [bernsteinPolynomial]\n        simp only [← natCast_mul, Nat.succ_eq_add_one, Nat.add_succ_sub_one, add_zero, pow_succ]\n        push_cast\n        ring\n    rw [add_pow, map_sum (pderiv true), map_sum (pderiv true), map_sum (MvPolynomial.aeval e),\n      Finset.sum_mul]\n    -- Step inside the sum:\n    refine Finset.sum_congr rfl fun k _ => (w k).trans ?_\n    simp only [x, y, e, pderiv_true_x, pderiv_true_y, Algebra.id.smul_eq_mul, nsmul_eq_mul,\n      Bool.cond_true, Bool.cond_false, add_zero, zero_add, mul_zero, smul_zero, mul_one,\n      MvPolynomial.aeval_X, MvPolynomial.pderiv_X_self, MvPolynomial.pderiv_X_of_ne,\n      Derivation.leibniz_pow, Derivation.leibniz, Derivation.map_natCast, map_natCast, map_pow,\n      map_mul, map_add]\n  -- On the right hand side, we'll just simplify.\n  · simp only [x, y, e, pderiv_one, pderiv_mul, (pderiv _).leibniz_pow, (pderiv _).map_natCast,\n      (pderiv true).map_add, pderiv_true_x, pderiv_true_y, Algebra.id.smul_eq_mul, add_zero,\n      mul_one, Derivation.map_smul_of_tower, map_nsmul, map_pow, map_add, Bool.cond_true,\n      Bool.cond_false, MvPolynomial.aeval_X, add_sub_cancel, one_pow, smul_smul,\n      smul_one_mul]\n\n"}
{"name":"bernsteinPolynomial.variance","module":"Mathlib.RingTheory.Polynomial.Bernstein","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Nat\n⊢ Eq ((Finset.range (HAdd.hAdd n 1)).sum fun ν => HMul.hMul (HPow.hPow (HSub.hSub (HSMul.hSMul n Polynomial.X) ↑ν) 2) (bernsteinPolynomial R n ν)) (HMul.hMul (HSMul.hSMul n Polynomial.X) (HSub.hSub 1 Polynomial.X))","decl":"/-- A certain linear combination of the previous three identities,\nwhich we'll want later.\n-/\ntheorem variance (n : ℕ) :\n    (∑ ν ∈ Finset.range (n + 1), (n • Polynomial.X - (ν : R[X])) ^ 2 * bernsteinPolynomial R n ν) =\n      n • Polynomial.X * ((1 : R[X]) - Polynomial.X) := by\n  have p : ((((Finset.range (n + 1)).sum fun ν => (ν * (ν - 1)) • bernsteinPolynomial R n ν) +\n      (1 - (2 * n) • Polynomial.X) * (Finset.range (n + 1)).sum fun ν =>\n        ν • bernsteinPolynomial R n ν) + n ^ 2 • X ^ 2 *\n          (Finset.range (n + 1)).sum fun ν => bernsteinPolynomial R n ν) = _ :=\n    rfl\n  conv at p =>\n    lhs\n    rw [Finset.mul_sum, Finset.mul_sum, ← Finset.sum_add_distrib, ← Finset.sum_add_distrib]\n    simp only [← natCast_mul]\n    simp only [← mul_assoc]\n    simp only [← add_mul]\n  conv at p =>\n    rhs\n    rw [sum, sum_smul, sum_mul_smul, ← natCast_mul]\n  calc\n    _ = _ := Finset.sum_congr rfl fun k m => ?_\n    _ = _ := p\n    _ = _ := ?_\n  · congr 1; simp only [← natCast_mul, push_cast]\n    cases k <;> · simp; ring\n  · simp only [← natCast_mul, push_cast]\n    cases n\n    · simp\n    · simp; ring\n\n"}
