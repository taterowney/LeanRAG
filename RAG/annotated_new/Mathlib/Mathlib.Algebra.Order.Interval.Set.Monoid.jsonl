{"name":"Set.Ici_add_bij","module":"Mathlib.Algebra.Order.Interval.Set.Monoid","initialProofState":"M : Type u_1\ninst✝¹ : OrderedCancelAddCommMonoid M\ninst✝ : ExistsAddOfLE M\na d : M\n⊢ Set.BijOn (fun x => HAdd.hAdd x d) (Set.Ici a) (Set.Ici (HAdd.hAdd a d))","decl":"theorem Ici_add_bij : BijOn (· + d) (Ici a) (Ici (a + d)) := by\n  refine\n    ⟨fun x h => add_le_add_right (mem_Ici.mp h) _, (add_left_injective d).injOn, fun _ h => ?_⟩\n  obtain ⟨c, rfl⟩ := exists_add_of_le (mem_Ici.mp h)\n  rw [mem_Ici, add_right_comm, add_le_add_iff_right] at h\n  exact ⟨a + c, h, by rw [add_right_comm]⟩\n\n"}
{"name":"Set.Ioi_add_bij","module":"Mathlib.Algebra.Order.Interval.Set.Monoid","initialProofState":"M : Type u_1\ninst✝¹ : OrderedCancelAddCommMonoid M\ninst✝ : ExistsAddOfLE M\na d : M\n⊢ Set.BijOn (fun x => HAdd.hAdd x d) (Set.Ioi a) (Set.Ioi (HAdd.hAdd a d))","decl":"theorem Ioi_add_bij : BijOn (· + d) (Ioi a) (Ioi (a + d)) := by\n  refine\n    ⟨fun x h => add_lt_add_right (mem_Ioi.mp h) _, fun _ _ _ _ h => add_right_cancel h, fun _ h =>\n      ?_⟩\n  obtain ⟨c, rfl⟩ := exists_add_of_le (mem_Ioi.mp h).le\n  rw [mem_Ioi, add_right_comm, add_lt_add_iff_right] at h\n  exact ⟨a + c, h, by rw [add_right_comm]⟩\n\n"}
{"name":"Set.Icc_add_bij","module":"Mathlib.Algebra.Order.Interval.Set.Monoid","initialProofState":"M : Type u_1\ninst✝¹ : OrderedCancelAddCommMonoid M\ninst✝ : ExistsAddOfLE M\na b d : M\n⊢ Set.BijOn (fun x => HAdd.hAdd x d) (Set.Icc a b) (Set.Icc (HAdd.hAdd a d) (HAdd.hAdd b d))","decl":"theorem Icc_add_bij : BijOn (· + d) (Icc a b) (Icc (a + d) (b + d)) := by\n  rw [← Ici_inter_Iic, ← Ici_inter_Iic]\n  exact\n    (Ici_add_bij a d).inter_mapsTo (fun x hx => add_le_add_right hx _) fun x hx =>\n      le_of_add_le_add_right hx.2\n\n"}
{"name":"Set.Ioo_add_bij","module":"Mathlib.Algebra.Order.Interval.Set.Monoid","initialProofState":"M : Type u_1\ninst✝¹ : OrderedCancelAddCommMonoid M\ninst✝ : ExistsAddOfLE M\na b d : M\n⊢ Set.BijOn (fun x => HAdd.hAdd x d) (Set.Ioo a b) (Set.Ioo (HAdd.hAdd a d) (HAdd.hAdd b d))","decl":"theorem Ioo_add_bij : BijOn (· + d) (Ioo a b) (Ioo (a + d) (b + d)) := by\n  rw [← Ioi_inter_Iio, ← Ioi_inter_Iio]\n  exact\n    (Ioi_add_bij a d).inter_mapsTo (fun x hx => add_lt_add_right hx _) fun x hx =>\n      lt_of_add_lt_add_right hx.2\n\n"}
{"name":"Set.Ioc_add_bij","module":"Mathlib.Algebra.Order.Interval.Set.Monoid","initialProofState":"M : Type u_1\ninst✝¹ : OrderedCancelAddCommMonoid M\ninst✝ : ExistsAddOfLE M\na b d : M\n⊢ Set.BijOn (fun x => HAdd.hAdd x d) (Set.Ioc a b) (Set.Ioc (HAdd.hAdd a d) (HAdd.hAdd b d))","decl":"theorem Ioc_add_bij : BijOn (· + d) (Ioc a b) (Ioc (a + d) (b + d)) := by\n  rw [← Ioi_inter_Iic, ← Ioi_inter_Iic]\n  exact\n    (Ioi_add_bij a d).inter_mapsTo (fun x hx => add_le_add_right hx _) fun x hx =>\n      le_of_add_le_add_right hx.2\n\n"}
{"name":"Set.Ico_add_bij","module":"Mathlib.Algebra.Order.Interval.Set.Monoid","initialProofState":"M : Type u_1\ninst✝¹ : OrderedCancelAddCommMonoid M\ninst✝ : ExistsAddOfLE M\na b d : M\n⊢ Set.BijOn (fun x => HAdd.hAdd x d) (Set.Ico a b) (Set.Ico (HAdd.hAdd a d) (HAdd.hAdd b d))","decl":"theorem Ico_add_bij : BijOn (· + d) (Ico a b) (Ico (a + d) (b + d)) := by\n  rw [← Ici_inter_Iio, ← Ici_inter_Iio]\n  exact\n    (Ici_add_bij a d).inter_mapsTo (fun x hx => add_lt_add_right hx _) fun x hx =>\n      lt_of_add_lt_add_right hx.2\n\n"}
{"name":"Set.image_add_const_Ici","module":"Mathlib.Algebra.Order.Interval.Set.Monoid","initialProofState":"M : Type u_1\ninst✝¹ : OrderedCancelAddCommMonoid M\ninst✝ : ExistsAddOfLE M\na b : M\n⊢ Eq (Set.image (fun x => HAdd.hAdd x a) (Set.Ici b)) (Set.Ici (HAdd.hAdd b a))","decl":"@[simp]\ntheorem image_add_const_Ici : (fun x => x + a) '' Ici b = Ici (b + a) :=\n  (Ici_add_bij _ _).image_eq\n\n"}
{"name":"Set.image_add_const_Ioi","module":"Mathlib.Algebra.Order.Interval.Set.Monoid","initialProofState":"M : Type u_1\ninst✝¹ : OrderedCancelAddCommMonoid M\ninst✝ : ExistsAddOfLE M\na b : M\n⊢ Eq (Set.image (fun x => HAdd.hAdd x a) (Set.Ioi b)) (Set.Ioi (HAdd.hAdd b a))","decl":"@[simp]\ntheorem image_add_const_Ioi : (fun x => x + a) '' Ioi b = Ioi (b + a) :=\n  (Ioi_add_bij _ _).image_eq\n\n"}
{"name":"Set.image_add_const_Icc","module":"Mathlib.Algebra.Order.Interval.Set.Monoid","initialProofState":"M : Type u_1\ninst✝¹ : OrderedCancelAddCommMonoid M\ninst✝ : ExistsAddOfLE M\na b c : M\n⊢ Eq (Set.image (fun x => HAdd.hAdd x a) (Set.Icc b c)) (Set.Icc (HAdd.hAdd b a) (HAdd.hAdd c a))","decl":"@[simp]\ntheorem image_add_const_Icc : (fun x => x + a) '' Icc b c = Icc (b + a) (c + a) :=\n  (Icc_add_bij _ _ _).image_eq\n\n"}
{"name":"Set.image_add_const_Ico","module":"Mathlib.Algebra.Order.Interval.Set.Monoid","initialProofState":"M : Type u_1\ninst✝¹ : OrderedCancelAddCommMonoid M\ninst✝ : ExistsAddOfLE M\na b c : M\n⊢ Eq (Set.image (fun x => HAdd.hAdd x a) (Set.Ico b c)) (Set.Ico (HAdd.hAdd b a) (HAdd.hAdd c a))","decl":"@[simp]\ntheorem image_add_const_Ico : (fun x => x + a) '' Ico b c = Ico (b + a) (c + a) :=\n  (Ico_add_bij _ _ _).image_eq\n\n"}
{"name":"Set.image_add_const_Ioc","module":"Mathlib.Algebra.Order.Interval.Set.Monoid","initialProofState":"M : Type u_1\ninst✝¹ : OrderedCancelAddCommMonoid M\ninst✝ : ExistsAddOfLE M\na b c : M\n⊢ Eq (Set.image (fun x => HAdd.hAdd x a) (Set.Ioc b c)) (Set.Ioc (HAdd.hAdd b a) (HAdd.hAdd c a))","decl":"@[simp]\ntheorem image_add_const_Ioc : (fun x => x + a) '' Ioc b c = Ioc (b + a) (c + a) :=\n  (Ioc_add_bij _ _ _).image_eq\n\n"}
{"name":"Set.image_add_const_Ioo","module":"Mathlib.Algebra.Order.Interval.Set.Monoid","initialProofState":"M : Type u_1\ninst✝¹ : OrderedCancelAddCommMonoid M\ninst✝ : ExistsAddOfLE M\na b c : M\n⊢ Eq (Set.image (fun x => HAdd.hAdd x a) (Set.Ioo b c)) (Set.Ioo (HAdd.hAdd b a) (HAdd.hAdd c a))","decl":"@[simp]\ntheorem image_add_const_Ioo : (fun x => x + a) '' Ioo b c = Ioo (b + a) (c + a) :=\n  (Ioo_add_bij _ _ _).image_eq\n\n"}
{"name":"Set.image_const_add_Ici","module":"Mathlib.Algebra.Order.Interval.Set.Monoid","initialProofState":"M : Type u_1\ninst✝¹ : OrderedCancelAddCommMonoid M\ninst✝ : ExistsAddOfLE M\na b : M\n⊢ Eq (Set.image (fun x => HAdd.hAdd a x) (Set.Ici b)) (Set.Ici (HAdd.hAdd a b))","decl":"@[simp]\ntheorem image_const_add_Ici : (fun x => a + x) '' Ici b = Ici (a + b) := by\n  simp only [add_comm a, image_add_const_Ici]\n\n"}
{"name":"Set.image_const_add_Ioi","module":"Mathlib.Algebra.Order.Interval.Set.Monoid","initialProofState":"M : Type u_1\ninst✝¹ : OrderedCancelAddCommMonoid M\ninst✝ : ExistsAddOfLE M\na b : M\n⊢ Eq (Set.image (fun x => HAdd.hAdd a x) (Set.Ioi b)) (Set.Ioi (HAdd.hAdd a b))","decl":"@[simp]\ntheorem image_const_add_Ioi : (fun x => a + x) '' Ioi b = Ioi (a + b) := by\n  simp only [add_comm a, image_add_const_Ioi]\n\n"}
{"name":"Set.image_const_add_Icc","module":"Mathlib.Algebra.Order.Interval.Set.Monoid","initialProofState":"M : Type u_1\ninst✝¹ : OrderedCancelAddCommMonoid M\ninst✝ : ExistsAddOfLE M\na b c : M\n⊢ Eq (Set.image (fun x => HAdd.hAdd a x) (Set.Icc b c)) (Set.Icc (HAdd.hAdd a b) (HAdd.hAdd a c))","decl":"@[simp]\ntheorem image_const_add_Icc : (fun x => a + x) '' Icc b c = Icc (a + b) (a + c) := by\n  simp only [add_comm a, image_add_const_Icc]\n\n"}
{"name":"Set.image_const_add_Ico","module":"Mathlib.Algebra.Order.Interval.Set.Monoid","initialProofState":"M : Type u_1\ninst✝¹ : OrderedCancelAddCommMonoid M\ninst✝ : ExistsAddOfLE M\na b c : M\n⊢ Eq (Set.image (fun x => HAdd.hAdd a x) (Set.Ico b c)) (Set.Ico (HAdd.hAdd a b) (HAdd.hAdd a c))","decl":"@[simp]\ntheorem image_const_add_Ico : (fun x => a + x) '' Ico b c = Ico (a + b) (a + c) := by\n  simp only [add_comm a, image_add_const_Ico]\n\n"}
{"name":"Set.image_const_add_Ioc","module":"Mathlib.Algebra.Order.Interval.Set.Monoid","initialProofState":"M : Type u_1\ninst✝¹ : OrderedCancelAddCommMonoid M\ninst✝ : ExistsAddOfLE M\na b c : M\n⊢ Eq (Set.image (fun x => HAdd.hAdd a x) (Set.Ioc b c)) (Set.Ioc (HAdd.hAdd a b) (HAdd.hAdd a c))","decl":"@[simp]\ntheorem image_const_add_Ioc : (fun x => a + x) '' Ioc b c = Ioc (a + b) (a + c) := by\n  simp only [add_comm a, image_add_const_Ioc]\n\n"}
{"name":"Set.image_const_add_Ioo","module":"Mathlib.Algebra.Order.Interval.Set.Monoid","initialProofState":"M : Type u_1\ninst✝¹ : OrderedCancelAddCommMonoid M\ninst✝ : ExistsAddOfLE M\na b c : M\n⊢ Eq (Set.image (fun x => HAdd.hAdd a x) (Set.Ioo b c)) (Set.Ioo (HAdd.hAdd a b) (HAdd.hAdd a c))","decl":"@[simp]\ntheorem image_const_add_Ioo : (fun x => a + x) '' Ioo b c = Ioo (a + b) (a + c) := by\n  simp only [add_comm a, image_add_const_Ioo]\n\n"}
