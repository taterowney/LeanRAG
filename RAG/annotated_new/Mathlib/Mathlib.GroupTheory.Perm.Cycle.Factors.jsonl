{"name":"Equiv.Perm.cycleOf_apply","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\nf : Equiv.Perm α\ninst✝ : DecidableRel f.SameCycle\nx y : α\n⊢ Eq ((f.cycleOf x) y) (ite (f.SameCycle x y) (f y) y)","decl":"theorem cycleOf_apply (f : Perm α) [DecidableRel f.SameCycle] (x y : α) :\n    cycleOf f x y = if SameCycle f x y then f y else y := by\n  dsimp only [cycleOf]\n  split_ifs with h\n  · apply ofSubtype_apply_of_mem\n    exact h\n  · apply ofSubtype_apply_of_not_mem\n    exact h\n\n"}
{"name":"Equiv.Perm.cycleOf_inv","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\nf : Equiv.Perm α\ninst✝ : DecidableRel f.SameCycle\nx : α\n⊢ Eq (Inv.inv (f.cycleOf x)) ((Inv.inv f).cycleOf x)","decl":"theorem cycleOf_inv (f : Perm α) [DecidableRel f.SameCycle] (x : α) :\n    (cycleOf f x)⁻¹ = cycleOf f⁻¹ x :=\n  Equiv.ext fun y => by\n    rw [inv_eq_iff_eq, cycleOf_apply, cycleOf_apply]\n    split_ifs <;> simp_all [sameCycle_inv, sameCycle_inv_apply_right]\n\n"}
{"name":"Equiv.Perm.cycleOf_pow_apply_self","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\nf : Equiv.Perm α\ninst✝ : DecidableRel f.SameCycle\nx : α\nn : Nat\n⊢ Eq ((HPow.hPow (f.cycleOf x) n) x) ((HPow.hPow f n) x)","decl":"@[simp]\ntheorem cycleOf_pow_apply_self (f : Perm α) [DecidableRel f.SameCycle] (x : α) :\n    ∀ n : ℕ, (cycleOf f x ^ n) x = (f ^ n) x := by\n  intro n\n  induction n with\n  | zero => rfl\n  | succ n hn =>\n    rw [pow_succ', mul_apply, cycleOf_apply, hn, if_pos, pow_succ', mul_apply]\n    exact ⟨n, rfl⟩\n\n"}
{"name":"Equiv.Perm.cycleOf_zpow_apply_self","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\nf : Equiv.Perm α\ninst✝ : DecidableRel f.SameCycle\nx : α\nn : Int\n⊢ Eq ((HPow.hPow (f.cycleOf x) n) x) ((HPow.hPow f n) x)","decl":"@[simp]\ntheorem cycleOf_zpow_apply_self (f : Perm α) [DecidableRel f.SameCycle] (x : α) :\n    ∀ n : ℤ, (cycleOf f x ^ n) x = (f ^ n) x := by\n  intro z\n  induction' z with z hz\n  · exact cycleOf_pow_apply_self f x z\n  · rw [zpow_negSucc, ← inv_pow, cycleOf_inv, zpow_negSucc, ← inv_pow, cycleOf_pow_apply_self]\n\n"}
{"name":"Equiv.Perm.SameCycle.cycleOf_apply","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\nf : Equiv.Perm α\nx y : α\ninst✝ : DecidableRel f.SameCycle\na✝ : f.SameCycle x y\n⊢ Eq ((f.cycleOf x) y) (f y)","decl":"theorem SameCycle.cycleOf_apply [DecidableRel f.SameCycle] :\n    SameCycle f x y → cycleOf f x y = f y :=\n  ofSubtype_apply_of_mem _\n\n"}
{"name":"Equiv.Perm.cycleOf_apply_of_not_sameCycle","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\nf : Equiv.Perm α\nx y : α\ninst✝ : DecidableRel f.SameCycle\na✝ : Not (f.SameCycle x y)\n⊢ Eq ((f.cycleOf x) y) y","decl":"theorem cycleOf_apply_of_not_sameCycle [DecidableRel f.SameCycle] :\n    ¬SameCycle f x y → cycleOf f x y = y :=\n  ofSubtype_apply_of_not_mem _\n\n"}
{"name":"Equiv.Perm.SameCycle.cycleOf_eq","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\nf : Equiv.Perm α\nx y : α\ninst✝ : DecidableRel f.SameCycle\nh : f.SameCycle x y\n⊢ Eq (f.cycleOf x) (f.cycleOf y)","decl":"theorem SameCycle.cycleOf_eq [DecidableRel f.SameCycle] (h : SameCycle f x y) :\n    cycleOf f x = cycleOf f y := by\n  ext z\n  rw [Equiv.Perm.cycleOf_apply]\n  split_ifs with hz\n  · exact (h.symm.trans hz).cycleOf_apply.symm\n  · exact (cycleOf_apply_of_not_sameCycle (mt h.trans hz)).symm\n\n"}
{"name":"Equiv.Perm.cycleOf_apply_apply_zpow_self","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\nf : Equiv.Perm α\ninst✝ : DecidableRel f.SameCycle\nx : α\nk : Int\n⊢ Eq ((f.cycleOf x) ((HPow.hPow f k) x)) ((HPow.hPow f (HAdd.hAdd k 1)) x)","decl":"@[simp]\ntheorem cycleOf_apply_apply_zpow_self (f : Perm α) [DecidableRel f.SameCycle] (x : α) (k : ℤ) :\n    cycleOf f x ((f ^ k) x) = (f ^ (k + 1) : Perm α) x := by\n  rw [SameCycle.cycleOf_apply]\n  · rw [add_comm, zpow_add, zpow_one, mul_apply]\n  · exact ⟨k, rfl⟩\n\n"}
{"name":"Equiv.Perm.cycleOf_apply_apply_pow_self","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\nf : Equiv.Perm α\ninst✝ : DecidableRel f.SameCycle\nx : α\nk : Nat\n⊢ Eq ((f.cycleOf x) ((HPow.hPow f k) x)) ((HPow.hPow f (HAdd.hAdd k 1)) x)","decl":"@[simp]\ntheorem cycleOf_apply_apply_pow_self (f : Perm α) [DecidableRel f.SameCycle] (x : α) (k : ℕ) :\n    cycleOf f x ((f ^ k) x) = (f ^ (k + 1) : Perm α) x := by\n  convert cycleOf_apply_apply_zpow_self f x k using 1\n\n"}
{"name":"Equiv.Perm.cycleOf_apply_apply_self","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\nf : Equiv.Perm α\ninst✝ : DecidableRel f.SameCycle\nx : α\n⊢ Eq ((f.cycleOf x) (f x)) (f (f x))","decl":"@[simp]\ntheorem cycleOf_apply_apply_self (f : Perm α) [DecidableRel f.SameCycle] (x : α) :\n    cycleOf f x (f x) = f (f x) := by\n  convert cycleOf_apply_apply_pow_self f x 1 using 1\n\n"}
{"name":"Equiv.Perm.cycleOf_apply_self","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\nf : Equiv.Perm α\ninst✝ : DecidableRel f.SameCycle\nx : α\n⊢ Eq ((f.cycleOf x) x) (f x)","decl":"@[simp]\ntheorem cycleOf_apply_self (f : Perm α) [DecidableRel f.SameCycle] (x : α) : cycleOf f x x = f x :=\n  SameCycle.rfl.cycleOf_apply\n\n"}
{"name":"Equiv.Perm.IsCycle.cycleOf_eq","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\nf : Equiv.Perm α\nx : α\ninst✝ : DecidableRel f.SameCycle\nhf : f.IsCycle\nhx : Ne (f x) x\n⊢ Eq (f.cycleOf x) f","decl":"theorem IsCycle.cycleOf_eq [DecidableRel f.SameCycle]\n    (hf : IsCycle f) (hx : f x ≠ x) : cycleOf f x = f :=\n  Equiv.ext fun y =>\n    if h : SameCycle f x y then by rw [h.cycleOf_apply]\n    else by\n      rw [cycleOf_apply_of_not_sameCycle h,\n        Classical.not_not.1 (mt ((isCycle_iff_sameCycle hx).1 hf).2 h)]\n\n"}
{"name":"Equiv.Perm.cycleOf_eq_one_iff","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\nx : α\nf : Equiv.Perm α\ninst✝ : DecidableRel f.SameCycle\n⊢ Iff (Eq (f.cycleOf x) 1) (Eq (f x) x)","decl":"@[simp]\ntheorem cycleOf_eq_one_iff (f : Perm α) [DecidableRel f.SameCycle] : cycleOf f x = 1 ↔ f x = x := by\n  simp_rw [Perm.ext_iff, cycleOf_apply, one_apply]\n  refine ⟨fun h => (if_pos (SameCycle.refl f x)).symm.trans (h x), fun h y => ?_⟩\n  by_cases hy : f y = y\n  · rw [hy, ite_self]\n  · exact if_neg (mt SameCycle.apply_eq_self_iff (by tauto))\n\n"}
{"name":"Equiv.Perm.cycleOf_self_apply","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\nf : Equiv.Perm α\ninst✝ : DecidableRel f.SameCycle\nx : α\n⊢ Eq (f.cycleOf (f x)) (f.cycleOf x)","decl":"@[simp]\ntheorem cycleOf_self_apply (f : Perm α) [DecidableRel f.SameCycle] (x : α) :\n    cycleOf f (f x) = cycleOf f x :=\n  (sameCycle_apply_right.2 SameCycle.rfl).symm.cycleOf_eq\n\n"}
{"name":"Equiv.Perm.cycleOf_self_apply_pow","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\nf : Equiv.Perm α\ninst✝ : DecidableRel f.SameCycle\nn : Nat\nx : α\n⊢ Eq (f.cycleOf ((HPow.hPow f n) x)) (f.cycleOf x)","decl":"@[simp]\ntheorem cycleOf_self_apply_pow (f : Perm α) [DecidableRel f.SameCycle] (n : ℕ) (x : α) :\n    cycleOf f ((f ^ n) x) = cycleOf f x :=\n  SameCycle.rfl.pow_left.cycleOf_eq\n\n"}
{"name":"Equiv.Perm.cycleOf_self_apply_zpow","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\nf : Equiv.Perm α\ninst✝ : DecidableRel f.SameCycle\nn : Int\nx : α\n⊢ Eq (f.cycleOf ((HPow.hPow f n) x)) (f.cycleOf x)","decl":"@[simp]\ntheorem cycleOf_self_apply_zpow (f : Perm α) [DecidableRel f.SameCycle] (n : ℤ) (x : α) :\n    cycleOf f ((f ^ n) x) = cycleOf f x :=\n  SameCycle.rfl.zpow_left.cycleOf_eq\n\n"}
{"name":"Equiv.Perm.IsCycle.cycleOf","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\nf : Equiv.Perm α\nx : α\ninst✝¹ : DecidableRel f.SameCycle\ninst✝ : DecidableEq α\nhf : f.IsCycle\n⊢ Eq (f.cycleOf x) (ite (Eq (f x) x) 1 f)","decl":"protected theorem IsCycle.cycleOf [DecidableRel f.SameCycle] [DecidableEq α]\n    (hf : IsCycle f) : cycleOf f x = if f x = x then 1 else f := by\n  by_cases hx : f x = x\n  · rwa [if_pos hx, cycleOf_eq_one_iff]\n  · rwa [if_neg hx, hf.cycleOf_eq]\n\n"}
{"name":"Equiv.Perm.cycleOf_one","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\ninst✝ : DecidableRel (Equiv.Perm.SameCycle 1)\nx : α\n⊢ Eq (Equiv.Perm.cycleOf 1 x) 1","decl":"theorem cycleOf_one [DecidableRel (1 : Perm α).SameCycle] (x : α) :\n    cycleOf 1 x = 1 := (cycleOf_eq_one_iff 1).mpr rfl\n\n"}
{"name":"Equiv.Perm.isCycle_cycleOf","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\nx : α\nf : Equiv.Perm α\ninst✝ : DecidableRel f.SameCycle\nhx : Ne (f x) x\n⊢ (f.cycleOf x).IsCycle","decl":"theorem isCycle_cycleOf (f : Perm α) [DecidableRel f.SameCycle] (hx : f x ≠ x) :\n    IsCycle (cycleOf f x) :=\n  have : cycleOf f x x ≠ x := by rwa [SameCycle.rfl.cycleOf_apply]\n  (isCycle_iff_sameCycle this).2 @fun y =>\n    ⟨fun h => mt h.apply_eq_self_iff.2 this, fun h =>\n      if hxy : SameCycle f x y then\n        let ⟨i, hi⟩ := hxy\n        ⟨i, by rw [cycleOf_zpow_apply_self, hi]⟩\n      else by\n        rw [cycleOf_apply_of_not_sameCycle hxy] at h\n        exact (h rfl).elim⟩\n\n"}
{"name":"Equiv.Perm.pow_mod_orderOf_cycleOf_apply","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\nf : Equiv.Perm α\ninst✝ : DecidableRel f.SameCycle\nn : Nat\nx : α\n⊢ Eq ((HPow.hPow f (HMod.hMod n (orderOf (f.cycleOf x)))) x) ((HPow.hPow f n) x)","decl":"theorem pow_mod_orderOf_cycleOf_apply (f : Perm α) [DecidableRel f.SameCycle] (n : ℕ) (x : α) :\n    (f ^ (n % orderOf (cycleOf f x))) x = (f ^ n) x := by\n  rw [← cycleOf_pow_apply_self f, ← cycleOf_pow_apply_self f, pow_mod_orderOf]\n\n"}
{"name":"Equiv.Perm.cycleOf_mul_of_apply_right_eq_self","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\nf g : Equiv.Perm α\ninst✝¹ : DecidableRel f.SameCycle\ninst✝ : DecidableRel (HMul.hMul f g).SameCycle\nh : Commute f g\nx : α\nhx : Eq (g x) x\n⊢ Eq ((HMul.hMul f g).cycleOf x) (f.cycleOf x)","decl":"theorem cycleOf_mul_of_apply_right_eq_self [DecidableRel f.SameCycle]\n    [DecidableRel (f * g).SameCycle]\n    (h : Commute f g) (x : α) (hx : g x = x) : (f * g).cycleOf x = f.cycleOf x := by\n  ext y\n  by_cases hxy : (f * g).SameCycle x y\n  · obtain ⟨z, rfl⟩ := hxy\n    rw [cycleOf_apply_apply_zpow_self]\n    simp [h.mul_zpow, zpow_apply_eq_self_of_apply_eq_self hx]\n  · rw [cycleOf_apply_of_not_sameCycle hxy, cycleOf_apply_of_not_sameCycle]\n    contrapose! hxy\n    obtain ⟨z, rfl⟩ := hxy\n    refine ⟨z, ?_⟩\n    simp [h.mul_zpow, zpow_apply_eq_self_of_apply_eq_self hx]\n\n"}
{"name":"Equiv.Perm.Disjoint.cycleOf_mul_distrib","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\nf g : Equiv.Perm α\ninst✝³ : DecidableRel f.SameCycle\ninst✝² : DecidableRel g.SameCycle\ninst✝¹ : DecidableRel (HMul.hMul f g).SameCycle\ninst✝ : DecidableRel (HMul.hMul g f).SameCycle\nh : f.Disjoint g\nx : α\n⊢ Eq ((HMul.hMul f g).cycleOf x) (HMul.hMul (f.cycleOf x) (g.cycleOf x))","decl":"theorem Disjoint.cycleOf_mul_distrib [DecidableRel f.SameCycle] [DecidableRel g.SameCycle]\n    [DecidableRel (f * g).SameCycle] [DecidableRel (g * f).SameCycle] (h : f.Disjoint g) (x : α) :\n    (f * g).cycleOf x = f.cycleOf x * g.cycleOf x := by\n  cases' (disjoint_iff_eq_or_eq.mp h) x with hfx hgx\n  · simp [h.commute.eq, cycleOf_mul_of_apply_right_eq_self h.symm.commute, hfx]\n  · simp [cycleOf_mul_of_apply_right_eq_self h.commute, hgx]\n\n"}
{"name":"Equiv.Perm.isCycle_cycleOf_iff","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\nx : α\nf : Equiv.Perm α\ninst✝ : DecidableRel f.SameCycle\n⊢ Iff (f.cycleOf x).IsCycle (Ne (f x) x)","decl":"/-- `x` is in the support of `f` iff `Equiv.Perm.cycle_of f x` is a cycle. -/\ntheorem isCycle_cycleOf_iff (f : Perm α) [DecidableRel f.SameCycle] :\n    IsCycle (cycleOf f x) ↔ f x ≠ x := by\n  refine ⟨fun hx => ?_, f.isCycle_cycleOf⟩\n  rw [Ne, ← cycleOf_eq_one_iff f]\n  exact hx.ne_one\n\n"}
{"name":"Equiv.Perm.two_le_card_support_cycleOf_iff","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\nf : Equiv.Perm α\nx : α\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\n⊢ Iff (LE.le 2 (f.cycleOf x).support.card) (Ne (f x) x)","decl":"@[simp]\ntheorem two_le_card_support_cycleOf_iff [DecidableEq α] [Fintype α] :\n    2 ≤ #(cycleOf f x).support ↔ f x ≠ x := by\n  refine ⟨fun h => ?_, fun h => by simpa using (isCycle_cycleOf _ h).two_le_card_support⟩\n  contrapose! h\n  rw [← cycleOf_eq_one_iff] at h\n  simp [h]\n\n"}
{"name":"Equiv.Perm.support_cycleOf_nonempty","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\nf : Equiv.Perm α\nx : α\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\n⊢ Iff (f.cycleOf x).support.Nonempty (Ne (f x) x)","decl":"@[simp] lemma support_cycleOf_nonempty [DecidableEq α] [Fintype α] :\n    (cycleOf f x).support.Nonempty ↔ f x ≠ x := by\n  rw [← two_le_card_support_cycleOf_iff, ← card_pos, ← Nat.succ_le_iff]\n  exact ⟨fun h => Or.resolve_left h.eq_or_lt (card_support_ne_one _).symm, zero_lt_two.trans_le⟩\n\n"}
{"name":"Equiv.Perm.mem_support_cycleOf_iff","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\nf : Equiv.Perm α\nx y : α\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\n⊢ Iff (Membership.mem (f.cycleOf x).support y) (And (f.SameCycle x y) (Membership.mem f.support x))","decl":"theorem mem_support_cycleOf_iff [DecidableEq α] [Fintype α] :\n    y ∈ support (f.cycleOf x) ↔ SameCycle f x y ∧ x ∈ support f :=\n  mem_support_cycleOf_iff_aux\n\n"}
{"name":"Equiv.Perm.mem_support_cycleOf_iff'","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\nf : Equiv.Perm α\nx y : α\nhx : Ne (f x) x\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\n⊢ Iff (Membership.mem (f.cycleOf x).support y) (f.SameCycle x y)","decl":"theorem mem_support_cycleOf_iff' (hx : f x ≠ x) [DecidableEq α] [Fintype α] :\n    y ∈ support (f.cycleOf x) ↔ SameCycle f x y :=\n  mem_support_cycleOf_iff'_aux hx\n\n"}
{"name":"Equiv.Perm.support_cycleOf_eq_nil_iff","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\nf : Equiv.Perm α\nx : α\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\n⊢ Iff (Eq (f.cycleOf x).support EmptyCollection.emptyCollection) (Not (Membership.mem f.support x))","decl":"theorem support_cycleOf_eq_nil_iff [DecidableEq α] [Fintype α] :\n    (f.cycleOf x).support = ∅ ↔ x ∉ f.support := by simp\n\n"}
{"name":"Equiv.Perm.isCycleOn_support_cycleOf","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nf : Equiv.Perm α\nx : α\n⊢ f.IsCycleOn ↑(f.cycleOf x).support","decl":"theorem isCycleOn_support_cycleOf [DecidableEq α] [Fintype α] (f : Perm α) (x : α) :\n    f.IsCycleOn (f.cycleOf x).support :=\n  isCycleOn_support_cycleOf_aux f x\n\n"}
{"name":"Equiv.Perm.SameCycle.exists_pow_eq_of_mem_support","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\nx y : α\nf : Equiv.Perm α\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nh : f.SameCycle x y\nhx : Membership.mem f.support x\n⊢ Exists fun i => And (LT.lt i (f.cycleOf x).support.card) (Eq ((HPow.hPow f i) x) y)","decl":"theorem SameCycle.exists_pow_eq_of_mem_support {f} [DecidableEq α] [Fintype α] (h : SameCycle f x y)\n    (hx : x ∈ f.support) : ∃ i < #(f.cycleOf x).support, (f ^ i) x = y :=\n  h.exists_pow_eq_of_mem_support_aux hx\n\n"}
{"name":"Equiv.Perm.support_cycleOf_le","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nf : Equiv.Perm α\nx : α\n⊢ LE.le (f.cycleOf x).support f.support","decl":"theorem support_cycleOf_le [DecidableEq α] [Fintype α] (f : Perm α) (x : α) :\n    support (f.cycleOf x) ≤ support f := by\n  intro y hy\n  rw [mem_support, cycleOf_apply] at hy\n  split_ifs at hy\n  · exact mem_support.mpr hy\n  · exact absurd rfl hy\n\n"}
{"name":"Equiv.Perm.SameCycle.mem_support_iff","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\nx y : α\nf : Equiv.Perm α\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nh : f.SameCycle x y\n⊢ Iff (Membership.mem f.support x) (Membership.mem f.support y)","decl":"theorem SameCycle.mem_support_iff {f} [DecidableEq α] [Fintype α] (h : SameCycle f x y) :\n    x ∈ support f ↔ y ∈ support f :=\n  ⟨fun hx => support_cycleOf_le f x (mem_support_cycleOf_iff.mpr ⟨h, hx⟩), fun hy =>\n    support_cycleOf_le f y (mem_support_cycleOf_iff.mpr ⟨h.symm, hy⟩)⟩\n\n"}
{"name":"Equiv.Perm.pow_mod_card_support_cycleOf_self_apply","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nf : Equiv.Perm α\nn : Nat\nx : α\n⊢ Eq ((HPow.hPow f (HMod.hMod n (f.cycleOf x).support.card)) x) ((HPow.hPow f n) x)","decl":"theorem pow_mod_card_support_cycleOf_self_apply [DecidableEq α] [Fintype α]\n    (f : Perm α) (n : ℕ) (x : α) : (f ^ (n % #(f.cycleOf x).support)) x = (f ^ n) x := by\n  by_cases hx : f x = x\n  · rw [pow_apply_eq_self_of_apply_eq_self hx, pow_apply_eq_self_of_apply_eq_self hx]\n  · rw [← cycleOf_pow_apply_self, ← cycleOf_pow_apply_self f, ← (isCycle_cycleOf f hx).orderOf,\n      pow_mod_orderOf]\n\n"}
{"name":"Equiv.Perm.SameCycle.exists_pow_eq","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\nx y : α\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nf : Equiv.Perm α\nh : f.SameCycle x y\n⊢ Exists fun i => And (LT.lt 0 i) (And (LE.le i (HAdd.hAdd (f.cycleOf x).support.card 1)) (Eq ((HPow.hPow f i) x) y))","decl":"theorem SameCycle.exists_pow_eq [DecidableEq α] [Fintype α] (f : Perm α) (h : SameCycle f x y) :\n    ∃ i : ℕ, 0 < i ∧ i ≤ #(f.cycleOf x).support + 1 ∧ (f ^ i) x = y := by\n  by_cases hx : x ∈ f.support\n  · obtain ⟨k, hk, hk'⟩ := h.exists_pow_eq_of_mem_support hx\n    cases' k with k\n    · refine ⟨#(f.cycleOf x).support, ?_, self_le_add_right _ _, ?_⟩\n      · refine zero_lt_one.trans (one_lt_card_support_of_ne_one ?_)\n        simpa using hx\n      · simp only [pow_zero, coe_one, id_eq] at hk'\n        subst hk'\n        rw [← (isCycle_cycleOf _ <| mem_support.1 hx).orderOf, ← cycleOf_pow_apply_self,\n          pow_orderOf_eq_one, one_apply]\n    · exact ⟨k + 1, by simp, Nat.le_succ_of_le hk.le, hk'⟩\n  · refine ⟨1, zero_lt_one, by simp, ?_⟩\n    obtain ⟨k, rfl⟩ := h\n    rw [not_mem_support] at hx\n    rw [pow_apply_eq_self_of_apply_eq_self hx, zpow_apply_eq_self_of_apply_eq_self hx]\n\n"}
{"name":"Equiv.Perm.zpow_eq_zpow_on_iff","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ng : Equiv.Perm α\nm n : Int\nx : α\nhx : Ne (g x) x\n⊢ Iff (Eq ((HPow.hPow g m) x) ((HPow.hPow g n) x)) (Eq (HMod.hMod m ↑(g.cycleOf x).support.card) (HMod.hMod n ↑(g.cycleOf x).support.card))","decl":"theorem zpow_eq_zpow_on_iff [DecidableEq α] [Fintype α]\n    (g : Perm α) {m n : ℤ} {x : α} (hx : g x ≠ x) :\n    (g ^ m) x = (g ^ n) x ↔ m % #(g.cycleOf x).support = n % #(g.cycleOf x).support := by\n  rw [Int.emod_eq_emod_iff_emod_sub_eq_zero]\n  conv_lhs => rw [← Int.sub_add_cancel m n, Int.add_comm, zpow_add]\n  simp only [coe_mul, Function.comp_apply, EmbeddingLike.apply_eq_iff_eq]\n  rw [← Int.dvd_iff_emod_eq_zero]\n  rw [← cycleOf_zpow_apply_self g x, cycle_zpow_mem_support_iff]\n  · rw [← Int.dvd_iff_emod_eq_zero]\n  · exact isCycle_cycleOf g hx\n  · simp only [mem_support, cycleOf_apply_self]; exact hx\n\n"}
{"name":"Equiv.Perm.mem_list_cycles_iff","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_4\ninst✝ : Finite α\nl : List (Equiv.Perm α)\nh1 : ∀ (σ : Equiv.Perm α), Membership.mem l σ → σ.IsCycle\nh2 : List.Pairwise Equiv.Perm.Disjoint l\nσ : Equiv.Perm α\n⊢ Iff (Membership.mem l σ) (And σ.IsCycle (∀ (a : α), Ne (σ a) a → Eq (σ a) (l.prod a)))","decl":"theorem mem_list_cycles_iff {α : Type*} [Finite α] {l : List (Perm α)}\n    (h1 : ∀ σ : Perm α, σ ∈ l → σ.IsCycle) (h2 : l.Pairwise Disjoint) {σ : Perm α} :\n    σ ∈ l ↔ σ.IsCycle ∧ ∀ a, σ a ≠ a → σ a = l.prod a := by\n  suffices σ.IsCycle → (σ ∈ l ↔ ∀ a, σ a ≠ a → σ a = l.prod a) by\n    exact ⟨fun hσ => ⟨h1 σ hσ, (this (h1 σ hσ)).mp hσ⟩, fun hσ => (this hσ.1).mpr hσ.2⟩\n  intro h3\n  classical\n    cases nonempty_fintype α\n    constructor\n    · intro h a ha\n      exact eq_on_support_mem_disjoint h h2 _ (mem_support.mpr ha)\n    · intro h\n      have hσl : σ.support ⊆ l.prod.support := by\n        intro x hx\n        rw [mem_support] at hx\n        rwa [mem_support, ← h _ hx]\n      obtain ⟨a, ha, -⟩ := id h3\n      rw [← mem_support] at ha\n      obtain ⟨τ, hτ, hτa⟩ := exists_mem_support_of_mem_support_prod (hσl ha)\n      have hτl : ∀ x ∈ τ.support, τ x = l.prod x := eq_on_support_mem_disjoint hτ h2\n      have key : ∀ x ∈ σ.support ∩ τ.support, σ x = τ x := by\n        intro x hx\n        rw [h x (mem_support.mp (mem_of_mem_inter_left hx)), hτl x (mem_of_mem_inter_right hx)]\n      convert hτ\n      refine h3.eq_on_support_inter_nonempty_congr (h1 _ hτ) key ?_ ha\n      exact key a (mem_inter_of_mem ha hτa)\n\n"}
{"name":"Equiv.Perm.list_cycles_perm_list_cycles","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_4\ninst✝ : Finite α\nl₁ l₂ : List (Equiv.Perm α)\nh₀ : Eq l₁.prod l₂.prod\nh₁l₁ : ∀ (σ : Equiv.Perm α), Membership.mem l₁ σ → σ.IsCycle\nh₁l₂ : ∀ (σ : Equiv.Perm α), Membership.mem l₂ σ → σ.IsCycle\nh₂l₁ : List.Pairwise Equiv.Perm.Disjoint l₁\nh₂l₂ : List.Pairwise Equiv.Perm.Disjoint l₂\n⊢ l₁.Perm l₂","decl":"open scoped List in\ntheorem list_cycles_perm_list_cycles {α : Type*} [Finite α] {l₁ l₂ : List (Perm α)}\n    (h₀ : l₁.prod = l₂.prod) (h₁l₁ : ∀ σ : Perm α, σ ∈ l₁ → σ.IsCycle)\n    (h₁l₂ : ∀ σ : Perm α, σ ∈ l₂ → σ.IsCycle) (h₂l₁ : l₁.Pairwise Disjoint)\n    (h₂l₂ : l₂.Pairwise Disjoint) : l₁ ~ l₂ := by\n  classical\n    refine\n      (List.perm_ext_iff_of_nodup (nodup_of_pairwise_disjoint_cycles h₁l₁ h₂l₁)\n            (nodup_of_pairwise_disjoint_cycles h₁l₂ h₂l₂)).mpr\n        fun σ => ?_\n    by_cases hσ : σ.IsCycle\n    · obtain _ := not_forall.mp (mt ext hσ.ne_one)\n      rw [mem_list_cycles_iff h₁l₁ h₂l₁, mem_list_cycles_iff h₁l₂ h₂l₂, h₀]\n    · exact iff_of_false (mt (h₁l₁ σ) hσ) (mt (h₁l₂ σ) hσ)\n\n"}
{"name":"Equiv.Perm.cycleFactorsFinset_eq_list_toFinset","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nσ : Equiv.Perm α\nl : List (Equiv.Perm α)\nhn : l.Nodup\n⊢ Iff (Eq σ.cycleFactorsFinset l.toFinset) (And (∀ (f : Equiv.Perm α), Membership.mem l f → f.IsCycle) (And (List.Pairwise Equiv.Perm.Disjoint l) (Eq l.prod σ)))","decl":"open scoped List in\ntheorem cycleFactorsFinset_eq_list_toFinset {σ : Perm α} {l : List (Perm α)} (hn : l.Nodup) :\n    σ.cycleFactorsFinset = l.toFinset ↔\n      (∀ f : Perm α, f ∈ l → f.IsCycle) ∧ l.Pairwise Disjoint ∧ l.prod = σ := by\n  obtain ⟨⟨l', hp', hc', hd'⟩, hl⟩ := Trunc.exists_rep σ.truncCycleFactors\n  have ht : cycleFactorsFinset σ = l'.toFinset := by\n    rw [cycleFactorsFinset, ← hl, Trunc.lift_mk]\n  rw [ht]\n  constructor\n  · intro h\n    have hn' : l'.Nodup := nodup_of_pairwise_disjoint_cycles hc' hd'\n    have hperm : l ~ l' := List.perm_of_nodup_nodup_toFinset_eq hn hn' h.symm\n    refine ⟨?_, ?_, ?_⟩\n    · exact fun _ h => hc' _ (hperm.subset h)\n    · have := List.Perm.pairwise_iff (@Disjoint.symmetric _) hperm\n      rwa [this]\n    · rw [← hp', hperm.symm.prod_eq']\n      refine hd'.imp ?_\n      exact Disjoint.commute\n  · rintro ⟨hc, hd, hp⟩\n    refine List.toFinset_eq_of_perm _ _ ?_\n    refine list_cycles_perm_list_cycles ?_ hc' hc hd' hd\n    rw [hp, hp']\n\n"}
{"name":"Equiv.Perm.cycleFactorsFinset_eq_finset","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nσ : Equiv.Perm α\ns : Finset (Equiv.Perm α)\n⊢ Iff (Eq σ.cycleFactorsFinset s) (And (∀ (f : Equiv.Perm α), Membership.mem s f → f.IsCycle) (Exists fun h => Eq (s.noncommProd id ⋯) σ))","decl":"theorem cycleFactorsFinset_eq_finset {σ : Perm α} {s : Finset (Perm α)} :\n    σ.cycleFactorsFinset = s ↔\n      (∀ f : Perm α, f ∈ s → f.IsCycle) ∧\n        ∃ h : (s : Set (Perm α)).Pairwise Disjoint,\n          s.noncommProd id (h.mono' fun _ _ => Disjoint.commute) = σ := by\n  obtain ⟨l, hl, rfl⟩ := s.exists_list_nodup_eq\n  simp [cycleFactorsFinset_eq_list_toFinset, hl]\n\n"}
{"name":"Equiv.Perm.cycleFactorsFinset_pairwise_disjoint","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nf : Equiv.Perm α\n⊢ (↑f.cycleFactorsFinset).Pairwise Equiv.Perm.Disjoint","decl":"theorem cycleFactorsFinset_pairwise_disjoint :\n    (cycleFactorsFinset f : Set (Perm α)).Pairwise Disjoint :=\n  (cycleFactorsFinset_eq_finset.mp rfl).2.choose\n\n"}
{"name":"Equiv.Perm.cycleFactorsFinset_mem_commute","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nf : Equiv.Perm α\n⊢ (↑f.cycleFactorsFinset).Pairwise Commute","decl":"/-- Two cycles of a permutation commute. -/\ntheorem cycleFactorsFinset_mem_commute : (cycleFactorsFinset f : Set (Perm α)).Pairwise Commute :=\n  (cycleFactorsFinset_pairwise_disjoint _).mono' fun _ _ => Disjoint.commute\n\n"}
{"name":"Equiv.Perm.cycleFactorsFinset_mem_commute'","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nf g1 g2 : Equiv.Perm α\nh1 : Membership.mem f.cycleFactorsFinset g1\nh2 : Membership.mem f.cycleFactorsFinset g2\n⊢ Commute g1 g2","decl":"/-- Two cycles of a permutation commute. -/\ntheorem cycleFactorsFinset_mem_commute' {g1 g2 : Perm α}\n    (h1 : g1 ∈ f.cycleFactorsFinset) (h2 : g2 ∈ f.cycleFactorsFinset) :\n    Commute g1 g2 := by\n  rcases eq_or_ne g1 g2 with rfl | h\n  · apply Commute.refl\n  · exact Equiv.Perm.cycleFactorsFinset_mem_commute f h1 h2 h\n\n"}
{"name":"Equiv.Perm.cycleFactorsFinset_noncommProd","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nf : Equiv.Perm α\ncomm : optParam ((↑f.cycleFactorsFinset).Pairwise Commute) ⋯\n⊢ Eq (f.cycleFactorsFinset.noncommProd id comm) f","decl":"/-- The product of cycle factors is equal to the original `f : perm α`. -/\ntheorem cycleFactorsFinset_noncommProd\n    (comm : (cycleFactorsFinset f : Set (Perm α)).Pairwise Commute :=\n      cycleFactorsFinset_mem_commute f) :\n    f.cycleFactorsFinset.noncommProd id comm = f :=\n  (cycleFactorsFinset_eq_finset.mp rfl).2.choose_spec\n\n"}
{"name":"Equiv.Perm.mem_cycleFactorsFinset_iff","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nf p : Equiv.Perm α\n⊢ Iff (Membership.mem f.cycleFactorsFinset p) (And p.IsCycle (∀ (a : α), Membership.mem p.support a → Eq (p a) (f a)))","decl":"theorem mem_cycleFactorsFinset_iff {f p : Perm α} :\n    p ∈ cycleFactorsFinset f ↔ p.IsCycle ∧ ∀ a ∈ p.support, p a = f a := by\n  obtain ⟨l, hl, hl'⟩ := f.cycleFactorsFinset.exists_list_nodup_eq\n  rw [← hl']\n  rw [eq_comm, cycleFactorsFinset_eq_list_toFinset hl] at hl'\n  simpa [List.mem_toFinset, Ne, ← hl'.right.right] using\n    mem_list_cycles_iff hl'.left hl'.right.left\n\n"}
{"name":"Equiv.Perm.cycleOf_mem_cycleFactorsFinset_iff","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nf : Equiv.Perm α\nx : α\n⊢ Iff (Membership.mem f.cycleFactorsFinset (f.cycleOf x)) (Membership.mem f.support x)","decl":"theorem cycleOf_mem_cycleFactorsFinset_iff {f : Perm α} {x : α} :\n    cycleOf f x ∈ cycleFactorsFinset f ↔ x ∈ f.support := by\n  rw [mem_cycleFactorsFinset_iff]\n  constructor\n  · rintro ⟨hc, _⟩\n    contrapose! hc\n    rw [not_mem_support, ← cycleOf_eq_one_iff] at hc\n    simp [hc]\n  · intro hx\n    refine ⟨isCycle_cycleOf _ (mem_support.mp hx), ?_⟩\n    intro y hy\n    rw [mem_support] at hy\n    rw [cycleOf_apply]\n    split_ifs with H\n    · rfl\n    · rw [cycleOf_apply_of_not_sameCycle H] at hy\n      contradiction\n\n"}
{"name":"Equiv.Perm.cycleOf_ne_one_iff_mem_cycleFactorsFinset","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ng : Equiv.Perm α\nx : α\n⊢ Iff (Ne (g.cycleOf x) 1) (Membership.mem g.cycleFactorsFinset (g.cycleOf x))","decl":"lemma cycleOf_ne_one_iff_mem_cycleFactorsFinset {g : Equiv.Perm α} {x : α} :\n    g.cycleOf x ≠ 1 ↔ g.cycleOf x ∈ g.cycleFactorsFinset := by\n  rw [cycleOf_mem_cycleFactorsFinset_iff, mem_support, ne_eq, cycleOf_eq_one_iff]\n\n"}
{"name":"Equiv.Perm.mem_cycleFactorsFinset_support_le","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\np f : Equiv.Perm α\nh : Membership.mem f.cycleFactorsFinset p\n⊢ LE.le p.support f.support","decl":"theorem mem_cycleFactorsFinset_support_le {p f : Perm α} (h : p ∈ cycleFactorsFinset f) :\n    p.support ≤ f.support := by\n  rw [mem_cycleFactorsFinset_iff] at h\n  intro x hx\n  rwa [mem_support, ← h.right x hx, ← mem_support]\n\n"}
{"name":"Equiv.Perm.support_zpowers_of_mem_cycleFactorsFinset_le","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ng : Equiv.Perm α\nc : Subtype fun x => Membership.mem g.cycleFactorsFinset x\nv : Subtype fun x => Membership.mem (Subgroup.zpowers ↑c) x\n⊢ LE.le (↑v).support g.support","decl":"lemma support_zpowers_of_mem_cycleFactorsFinset_le {g : Perm α}\n    {c : g.cycleFactorsFinset} (v : Subgroup.zpowers (c : Perm α)) :\n    (v : Perm α).support ≤ g.support := by\n  obtain ⟨m, hm⟩ := v.prop\n  simp only [← hm]\n  exact le_trans (support_zpow_le _ _) (mem_cycleFactorsFinset_support_le c.prop)\n\n"}
{"name":"Equiv.Perm.pairwise_disjoint_of_mem_zpowers","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nf : Equiv.Perm α\n⊢ Pairwise fun i j => ∀ (x y : Equiv.Perm α), Membership.mem (Subgroup.zpowers ↑i) x → Membership.mem (Subgroup.zpowers ↑j) y → x.Disjoint y","decl":"theorem pairwise_disjoint_of_mem_zpowers :\n    Pairwise fun (i j : f.cycleFactorsFinset) ↦\n      ∀ (x y : Perm α), x ∈ Subgroup.zpowers ↑i → y ∈ Subgroup.zpowers ↑j → Disjoint x y :=\n  fun c d  hcd ↦ fun x y hx hy ↦ by\n  obtain ⟨m, hm⟩ := hx; obtain ⟨n, hn⟩ := hy\n  simp only [← hm, ← hn]\n  apply Disjoint.zpow_disjoint_zpow\n  exact f.cycleFactorsFinset_pairwise_disjoint c.prop d.prop (Subtype.coe_ne_coe.mpr hcd)\n\n"}
{"name":"Equiv.Perm.pairwise_commute_of_mem_zpowers","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nf : Equiv.Perm α\n⊢ Pairwise fun i j => ∀ (x y : Equiv.Perm α), Membership.mem (Subgroup.zpowers ↑i) x → Membership.mem (Subgroup.zpowers ↑j) y → Commute x y","decl":"lemma pairwise_commute_of_mem_zpowers :\n    Pairwise fun (i j : f.cycleFactorsFinset) ↦\n      ∀ (x y : Perm α), x ∈ Subgroup.zpowers ↑i → y ∈ Subgroup.zpowers ↑j → Commute x y :=\n  f.pairwise_disjoint_of_mem_zpowers.mono\n    (fun _ _ ↦ forall₂_imp (fun _ _ h hx hy ↦ (h hx hy).commute))\n\n"}
{"name":"Equiv.Perm.disjoint_ofSubtype_noncommPiCoprod","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nf : Equiv.Perm α\nu : Equiv.Perm ↑(Function.fixedPoints ⇑f)\nv : (c : Subtype fun x => Membership.mem f.cycleFactorsFinset x) → Subtype fun x => Membership.mem (Subgroup.zpowers ↑c) x\n⊢ (Equiv.Perm.ofSubtype u).Disjoint ((Subgroup.noncommPiCoprod ⋯) v)","decl":"lemma disjoint_ofSubtype_noncommPiCoprod (u : Perm (Function.fixedPoints f))\n    (v : (c : { x // x ∈ f.cycleFactorsFinset }) → (Subgroup.zpowers (c : Perm α))) :\n    Disjoint (ofSubtype u) ((Subgroup.noncommPiCoprod f.pairwise_commute_of_mem_zpowers) v) := by\n  apply Finset.noncommProd_induction\n  · intro a _ b _ h\n    apply f.pairwise_commute_of_mem_zpowers h <;> simp only [Subgroup.coeSubtype, SetLike.coe_mem]\n  · intro x y\n    exact Disjoint.mul_right\n  · exact disjoint_one_right _\n  · intro c _\n    simp only [Subgroup.coeSubtype]\n    exact Disjoint.mono (disjoint_ofSubtype_of_memFixedPoints_self u)\n      le_rfl (support_zpowers_of_mem_cycleFactorsFinset_le (v c))\n\n"}
{"name":"Equiv.Perm.commute_ofSubtype_noncommPiCoprod","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nf : Equiv.Perm α\nu : Equiv.Perm ↑(Function.fixedPoints ⇑f)\nv : (c : Subtype fun x => Membership.mem f.cycleFactorsFinset x) → Subtype fun x => Membership.mem (Subgroup.zpowers ↑c) x\n⊢ Commute (Equiv.Perm.ofSubtype u) ((Subgroup.noncommPiCoprod ⋯) v)","decl":"lemma commute_ofSubtype_noncommPiCoprod (u : Perm (Function.fixedPoints f))\n    (v : (c : { x // x ∈ f.cycleFactorsFinset }) → (Subgroup.zpowers (c : Perm α))) :\n    Commute (ofSubtype u) ((Subgroup.noncommPiCoprod f.pairwise_commute_of_mem_zpowers) v) :=\n  Disjoint.commute (f.disjoint_ofSubtype_noncommPiCoprod u v)\n\n"}
{"name":"Equiv.Perm.mem_support_iff_mem_support_of_mem_cycleFactorsFinset","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ng : Equiv.Perm α\nx : α\n⊢ Iff (Membership.mem g.support x) (Exists fun c => And (Membership.mem g.cycleFactorsFinset c) (Membership.mem c.support x))","decl":"theorem mem_support_iff_mem_support_of_mem_cycleFactorsFinset {g : Equiv.Perm α} {x : α} :\n    x ∈ g.support ↔ ∃ c ∈ g.cycleFactorsFinset, x ∈ c.support := by\n  constructor\n  · intro h\n    use g.cycleOf x, cycleOf_mem_cycleFactorsFinset_iff.mpr h\n    rw [mem_support_cycleOf_iff]\n    exact ⟨SameCycle.refl g x, h⟩\n  · rintro ⟨c, hc, hx⟩\n    exact mem_cycleFactorsFinset_support_le hc hx\n\n"}
{"name":"Equiv.Perm.cycleFactorsFinset_eq_empty_iff","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nf : Equiv.Perm α\n⊢ Iff (Eq f.cycleFactorsFinset EmptyCollection.emptyCollection) (Eq f 1)","decl":"theorem cycleFactorsFinset_eq_empty_iff {f : Perm α} : cycleFactorsFinset f = ∅ ↔ f = 1 := by\n  simpa [cycleFactorsFinset_eq_finset] using eq_comm\n\n"}
{"name":"Equiv.Perm.cycleFactorsFinset_one","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\n⊢ Eq (Equiv.Perm.cycleFactorsFinset 1) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem cycleFactorsFinset_one : cycleFactorsFinset (1 : Perm α) = ∅ := by\n  simp [cycleFactorsFinset_eq_empty_iff]\n\n"}
{"name":"Equiv.Perm.cycleFactorsFinset_eq_singleton_self_iff","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nf : Equiv.Perm α\n⊢ Iff (Eq f.cycleFactorsFinset (Singleton.singleton f)) f.IsCycle","decl":"@[simp]\ntheorem cycleFactorsFinset_eq_singleton_self_iff {f : Perm α} :\n    f.cycleFactorsFinset = {f} ↔ f.IsCycle := by simp [cycleFactorsFinset_eq_finset]\n\n"}
{"name":"Equiv.Perm.IsCycle.cycleFactorsFinset_eq_singleton","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nf : Equiv.Perm α\nhf : f.IsCycle\n⊢ Eq f.cycleFactorsFinset (Singleton.singleton f)","decl":"theorem IsCycle.cycleFactorsFinset_eq_singleton {f : Perm α} (hf : IsCycle f) :\n    f.cycleFactorsFinset = {f} :=\n  cycleFactorsFinset_eq_singleton_self_iff.mpr hf\n\n"}
{"name":"Equiv.Perm.cycleFactorsFinset_eq_singleton_iff","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nf g : Equiv.Perm α\n⊢ Iff (Eq f.cycleFactorsFinset (Singleton.singleton g)) (And f.IsCycle (Eq f g))","decl":"theorem cycleFactorsFinset_eq_singleton_iff {f g : Perm α} :\n    f.cycleFactorsFinset = {g} ↔ f.IsCycle ∧ f = g := by\n  suffices f = g → (g.IsCycle ↔ f.IsCycle) by\n    rw [cycleFactorsFinset_eq_finset]\n    simpa [eq_comm]\n  rintro rfl\n  exact Iff.rfl\n\n"}
{"name":"Equiv.Perm.cycleFactorsFinset_injective","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\n⊢ Function.Injective Equiv.Perm.cycleFactorsFinset","decl":"/-- Two permutations `f g : Perm α` have the same cycle factors iff they are the same. -/\ntheorem cycleFactorsFinset_injective : Function.Injective (@cycleFactorsFinset α _ _) := by\n  intro f g h\n  rw [← cycleFactorsFinset_noncommProd f]\n  simpa [h] using cycleFactorsFinset_noncommProd g\n\n"}
{"name":"Equiv.Perm.Disjoint.disjoint_cycleFactorsFinset","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nf g : Equiv.Perm α\nh : f.Disjoint g\n⊢ Disjoint f.cycleFactorsFinset g.cycleFactorsFinset","decl":"theorem Disjoint.disjoint_cycleFactorsFinset {f g : Perm α} (h : Disjoint f g) :\n    _root_.Disjoint (cycleFactorsFinset f) (cycleFactorsFinset g) := by\n  rw [disjoint_iff_disjoint_support] at h\n  rw [Finset.disjoint_left]\n  intro x hx hy\n  simp only [mem_cycleFactorsFinset_iff, mem_support] at hx hy\n  obtain ⟨⟨⟨a, ha, -⟩, hf⟩, -, hg⟩ := hx, hy\n  have := h.le_bot (by simp [ha, ← hf a ha, ← hg a ha] : a ∈ f.support ∩ g.support)\n  tauto\n\n"}
{"name":"Equiv.Perm.Disjoint.cycleFactorsFinset_mul_eq_union","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nf g : Equiv.Perm α\nh : f.Disjoint g\n⊢ Eq (HMul.hMul f g).cycleFactorsFinset (Union.union f.cycleFactorsFinset g.cycleFactorsFinset)","decl":"theorem Disjoint.cycleFactorsFinset_mul_eq_union {f g : Perm α} (h : Disjoint f g) :\n    cycleFactorsFinset (f * g) = cycleFactorsFinset f ∪ cycleFactorsFinset g := by\n  rw [cycleFactorsFinset_eq_finset]\n  refine ⟨?_, ?_, ?_⟩\n  · simp [or_imp, mem_cycleFactorsFinset_iff, forall_swap]\n  · rw [coe_union, Set.pairwise_union_of_symmetric Disjoint.symmetric]\n    exact\n      ⟨cycleFactorsFinset_pairwise_disjoint _, cycleFactorsFinset_pairwise_disjoint _,\n        fun x hx y hy _ =>\n        h.mono (mem_cycleFactorsFinset_support_le hx) (mem_cycleFactorsFinset_support_le hy)⟩\n  · rw [noncommProd_union_of_disjoint h.disjoint_cycleFactorsFinset]\n    rw [cycleFactorsFinset_noncommProd, cycleFactorsFinset_noncommProd]\n\n"}
{"name":"Equiv.Perm.disjoint_mul_inv_of_mem_cycleFactorsFinset","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nf g : Equiv.Perm α\nh : Membership.mem g.cycleFactorsFinset f\n⊢ (HMul.hMul g (Inv.inv f)).Disjoint f","decl":"theorem disjoint_mul_inv_of_mem_cycleFactorsFinset {f g : Perm α} (h : f ∈ cycleFactorsFinset g) :\n    Disjoint (g * f⁻¹) f := by\n  rw [mem_cycleFactorsFinset_iff] at h\n  intro x\n  by_cases hx : f x = x\n  · exact Or.inr hx\n  · refine Or.inl ?_\n    rw [mul_apply, ← h.right, apply_inv_self]\n    rwa [← support_inv, apply_mem_support, support_inv, mem_support]\n\n"}
{"name":"Equiv.Perm.cycle_is_cycleOf","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nf c : Equiv.Perm α\na : α\nha : Membership.mem c.support a\nhc : Membership.mem f.cycleFactorsFinset c\n⊢ Eq c (f.cycleOf a)","decl":"/-- If c is a cycle, a ∈ c.support and c is a cycle of f, then `c = f.cycleOf a` -/\ntheorem cycle_is_cycleOf {f c : Equiv.Perm α} {a : α} (ha : a ∈ c.support)\n    (hc : c ∈ f.cycleFactorsFinset) : c = f.cycleOf a := by\n  suffices f.cycleOf a = c.cycleOf a by\n    rw [this]\n    apply symm\n    exact\n      Equiv.Perm.IsCycle.cycleOf_eq (Equiv.Perm.mem_cycleFactorsFinset_iff.mp hc).left\n        (Equiv.Perm.mem_support.mp ha)\n  let hfc := (Equiv.Perm.disjoint_mul_inv_of_mem_cycleFactorsFinset hc).symm\n  let hfc2 := Perm.Disjoint.commute hfc\n  rw [← Equiv.Perm.cycleOf_mul_of_apply_right_eq_self hfc2]\n  · simp only [hfc2.eq, inv_mul_cancel_right]\n  -- `a` is in the support of `c`, hence it is not in the support of `g c⁻¹`\n  exact\n    Equiv.Perm.not_mem_support.mp\n      (Finset.disjoint_left.mp (Equiv.Perm.Disjoint.disjoint_support hfc) ha)\n\n"}
{"name":"Equiv.Perm.isCycleOn_support_of_mem_cycleFactorsFinset","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ng c : Equiv.Perm α\nhc : Membership.mem g.cycleFactorsFinset c\n⊢ g.IsCycleOn ↑c.support","decl":"theorem isCycleOn_support_of_mem_cycleFactorsFinset {g c : Equiv.Perm α}\n    (hc : c ∈ g.cycleFactorsFinset) :\n    IsCycleOn g c.support := by\n  obtain ⟨x, hx⟩ := IsCycle.nonempty_support (mem_cycleFactorsFinset_iff.mp hc).1\n  rw [cycle_is_cycleOf hx hc]\n  exact isCycleOn_support_cycleOf g x\n\n"}
{"name":"Equiv.Perm.eq_cycleOf_of_mem_cycleFactorsFinset_iff","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ng c : Equiv.Perm α\nhc : Membership.mem g.cycleFactorsFinset c\nx : α\n⊢ Iff (Eq c (g.cycleOf x)) (Membership.mem c.support x)","decl":"theorem eq_cycleOf_of_mem_cycleFactorsFinset_iff\n    (g c : Perm α) (hc : c ∈ g.cycleFactorsFinset) (x : α) :\n    c = g.cycleOf x ↔ x ∈ c.support := by\n  refine ⟨?_, (cycle_is_cycleOf · hc)⟩\n  rintro rfl\n  rw [mem_support, cycleOf_apply_self, ne_eq, ← cycleOf_eq_one_iff]\n  exact (mem_cycleFactorsFinset_iff.mp hc).left.ne_one\n\n"}
{"name":"Equiv.Perm.zpow_apply_mem_support_of_mem_cycleFactorsFinset_iff","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ng : Equiv.Perm α\nx : α\nm : Int\nc : Subtype fun x => Membership.mem g.cycleFactorsFinset x\n⊢ Iff (Membership.mem (↑c).support ((HPow.hPow g m) x)) (Membership.mem (↑c).support x)","decl":"theorem zpow_apply_mem_support_of_mem_cycleFactorsFinset_iff {g : Perm α}\n    {x :α} {m : ℤ} {c : g.cycleFactorsFinset} :\n    (g ^ m) x ∈ (c : Perm α).support ↔ x ∈ (c : Perm α).support := by\n  rw [← g.eq_cycleOf_of_mem_cycleFactorsFinset_iff _ c.prop, cycleOf_self_apply_zpow,\n    eq_cycleOf_of_mem_cycleFactorsFinset_iff _ _ c.prop]\n\n"}
{"name":"Equiv.Perm.mem_cycleFactorsFinset_conj","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ng k c : Equiv.Perm α\n⊢ Iff (Membership.mem (HMul.hMul (HMul.hMul k g) (Inv.inv k)).cycleFactorsFinset (HMul.hMul (HMul.hMul k c) (Inv.inv k))) (Membership.mem g.cycleFactorsFinset c)","decl":"/-- A permutation `c` is a cycle of `g` iff `k * c * k⁻¹` is a cycle of `k * g * k⁻¹` -/\ntheorem mem_cycleFactorsFinset_conj (g k c : Perm α) :\n    k * c * k⁻¹ ∈ (k * g * k⁻¹).cycleFactorsFinset ↔ c ∈ g.cycleFactorsFinset := by\n  suffices imp_lemma : ∀ {g k c : Perm α},\n      c ∈ g.cycleFactorsFinset → k * c * k⁻¹ ∈ (k * g * k⁻¹).cycleFactorsFinset by\n    refine ⟨fun h ↦ ?_, imp_lemma⟩\n    have aux : ∀ h : Perm α, h = k⁻¹ * (k * h * k⁻¹) * k := fun _ ↦ by group\n    rw [aux g, aux c]\n    exact imp_lemma h\n  intro g k c\n  simp only [mem_cycleFactorsFinset_iff]\n  apply And.imp IsCycle.conj\n  intro hc a ha\n  simp only [coe_mul, Function.comp_apply, EmbeddingLike.apply_eq_iff_eq]\n  apply hc\n  rw [mem_support] at ha ⊢\n  contrapose! ha\n  simp only [mul_smul, ← Perm.smul_def] at ha ⊢\n  rw [ha]\n  simp only [Perm.smul_def, apply_inv_self]\n\n"}
{"name":"Equiv.Perm.commute_of_mem_cycleFactorsFinset_commute","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nk g : Equiv.Perm α\nhk : ∀ (c : Equiv.Perm α), Membership.mem g.cycleFactorsFinset c → Commute k c\n⊢ Commute k g","decl":"/-- If a permutation commutes with every cycle of `g`, then it commutes with `g`\n\nNB. The converse is false. Commuting with every cycle of `g` means that we belong\nto the kernel of the action of `Equiv.Perm α` on `g.cycleFactorsFinset` -/\ntheorem commute_of_mem_cycleFactorsFinset_commute (k g : Perm α)\n    (hk : ∀ c ∈ g.cycleFactorsFinset, Commute k c) :\n    Commute k g := by\n  rw [← cycleFactorsFinset_noncommProd g (cycleFactorsFinset_mem_commute g)]\n  apply Finset.noncommProd_commute\n  simpa only [id_eq] using hk\n\n"}
{"name":"Equiv.Perm.self_mem_cycle_factors_commute","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ng c : Equiv.Perm α\nhc : Membership.mem g.cycleFactorsFinset c\n⊢ Commute c g","decl":"/-- The cycles of a permutation commute with it -/\ntheorem self_mem_cycle_factors_commute {g c : Perm α}\n    (hc : c ∈ g.cycleFactorsFinset) : Commute c g := by\n  apply commute_of_mem_cycleFactorsFinset_commute\n  intro c' hc'\n  by_cases hcc' : c = c'\n  · rw [hcc']\n  · apply g.cycleFactorsFinset_mem_commute hc hc'; exact hcc'\n\n"}
{"name":"Equiv.Perm.mem_support_cycle_of_cycle","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ng d c : Equiv.Perm α\nhc : Membership.mem g.cycleFactorsFinset c\nhd : Membership.mem g.cycleFactorsFinset d\nx : α\n⊢ Iff (Membership.mem c.support x) (Membership.mem c.support (d x))","decl":"/-- If `c` and `d` are cycles of `g`, then `d` stabilizes the support of `c` -/\ntheorem mem_support_cycle_of_cycle {g d c : Perm α}\n    (hc : c ∈ g.cycleFactorsFinset) (hd : d ∈ g.cycleFactorsFinset) :\n    ∀ x : α, x ∈ c.support ↔ d x ∈ c.support := by\n  intro x\n  simp only [mem_support, not_iff_not]\n  by_cases h : c = d\n  · rw [← h, EmbeddingLike.apply_eq_iff_eq]\n  · rw [← Perm.mul_apply,\n      Commute.eq (cycleFactorsFinset_mem_commute g hc hd h),\n      mul_apply, EmbeddingLike.apply_eq_iff_eq]\n\n"}
{"name":"Equiv.Perm.mem_cycleFactorsFinset_support","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ng c : Equiv.Perm α\nhc : Membership.mem g.cycleFactorsFinset c\na : α\n⊢ Iff (Membership.mem c.support a) (Membership.mem c.support (g a))","decl":"/-- If a permutation is a cycle of `g`, then its support is invariant under `g`-/\ntheorem mem_cycleFactorsFinset_support {g c : Perm α} (hc : c ∈ g.cycleFactorsFinset) (a : α) :\n    a ∈ c.support ↔ g a ∈ c.support :=\n  mem_support_iff_of_commute (self_mem_cycle_factors_commute hc).symm a\n\n"}
{"name":"Equiv.Perm.cycle_induction_on","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"β : Type u_3\ninst✝ : Finite β\nP : Equiv.Perm β → Prop\nσ : Equiv.Perm β\nbase_one : P 1\nbase_cycles : ∀ (σ : Equiv.Perm β), σ.IsCycle → P σ\ninduction_disjoint : ∀ (σ τ : Equiv.Perm β), σ.Disjoint τ → σ.IsCycle → P σ → P τ → P (HMul.hMul σ τ)\n⊢ P σ","decl":"@[elab_as_elim]\ntheorem cycle_induction_on [Finite β] (P : Perm β → Prop) (σ : Perm β) (base_one : P 1)\n    (base_cycles : ∀ σ : Perm β, σ.IsCycle → P σ)\n    (induction_disjoint : ∀ σ τ : Perm β,\n      Disjoint σ τ → IsCycle σ → P σ → P τ → P (σ * τ)) : P σ := by\n  cases nonempty_fintype β\n  suffices ∀ l : List (Perm β),\n      (∀ τ : Perm β, τ ∈ l → τ.IsCycle) → l.Pairwise Disjoint → P l.prod by\n    classical\n      let x := σ.truncCycleFactors.out\n      exact (congr_arg P x.2.1).mp (this x.1 x.2.2.1 x.2.2.2)\n  intro l\n  induction' l with σ l ih\n  · exact fun _ _ => base_one\n  · intro h1 h2\n    rw [List.prod_cons]\n    exact\n      induction_disjoint σ l.prod (disjoint_prod_right _ (List.pairwise_cons.mp h2).1)\n        (h1 _ (List.mem_cons_self _ _)) (base_cycles σ (h1 σ (l.mem_cons_self σ)))\n        (ih (fun τ hτ => h1 τ (List.mem_cons_of_mem σ hτ)) h2.of_cons)\n\n"}
{"name":"Equiv.Perm.cycleFactorsFinset_mul_inv_mem_eq_sdiff","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nf g : Equiv.Perm α\nh : Membership.mem g.cycleFactorsFinset f\n⊢ Eq (HMul.hMul g (Inv.inv f)).cycleFactorsFinset (SDiff.sdiff g.cycleFactorsFinset (Singleton.singleton f))","decl":"theorem cycleFactorsFinset_mul_inv_mem_eq_sdiff [DecidableEq α] [Fintype α] {f g : Perm α}\n    (h : f ∈ cycleFactorsFinset g) : cycleFactorsFinset (g * f⁻¹) = cycleFactorsFinset g \\ {f} := by\n  revert f\n  refine\n    cycle_induction_on (P := fun {g : Perm α} ↦\n      ∀ {f}, (f ∈ cycleFactorsFinset g)\n        → cycleFactorsFinset (g * f⁻¹) = cycleFactorsFinset g \\ {f}) _ ?_ ?_ ?_\n  · simp\n  · intro σ hσ f hf\n    simp only [cycleFactorsFinset_eq_singleton_self_iff.mpr hσ, mem_singleton] at hf ⊢\n    simp [hf]\n  · intro σ τ hd _ hσ hτ f\n    simp_rw [hd.cycleFactorsFinset_mul_eq_union, mem_union]\n    -- if only `wlog` could work here...\n    rintro (hf | hf)\n    · rw [hd.commute.eq, union_comm, union_sdiff_distrib, sdiff_singleton_eq_erase,\n        erase_eq_of_not_mem, mul_assoc, Disjoint.cycleFactorsFinset_mul_eq_union, hσ hf]\n      · rw [mem_cycleFactorsFinset_iff] at hf\n        intro x\n        cases' hd.symm x with hx hx\n        · exact Or.inl hx\n        · refine Or.inr ?_\n          by_cases hfx : f x = x\n          · rw [← hfx]\n            simpa [hx] using hfx.symm\n          · rw [mul_apply]\n            rw [← hf.right _ (mem_support.mpr hfx)] at hx\n            contradiction\n      · exact fun H =>\n        not_mem_empty _ (hd.disjoint_cycleFactorsFinset.le_bot (mem_inter_of_mem hf H))\n    · rw [union_sdiff_distrib, sdiff_singleton_eq_erase, erase_eq_of_not_mem, mul_assoc,\n        Disjoint.cycleFactorsFinset_mul_eq_union, hτ hf]\n      · rw [mem_cycleFactorsFinset_iff] at hf\n        intro x\n        cases' hd x with hx hx\n        · exact Or.inl hx\n        · refine Or.inr ?_\n          by_cases hfx : f x = x\n          · rw [← hfx]\n            simpa [hx] using hfx.symm\n          · rw [mul_apply]\n            rw [← hf.right _ (mem_support.mpr hfx)] at hx\n            contradiction\n      · exact fun H =>\n        not_mem_empty _ (hd.disjoint_cycleFactorsFinset.le_bot (mem_inter_of_mem H hf))\n\n"}
{"name":"Equiv.Perm.IsCycle.forall_commute_iff","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ng z : Equiv.Perm α\n⊢ Iff (∀ (c : Equiv.Perm α), Membership.mem g.cycleFactorsFinset c → Commute z c) (∀ (c : Equiv.Perm α), Membership.mem g.cycleFactorsFinset c → Exists fun hc => Membership.mem (Subgroup.zpowers c) (Equiv.Perm.ofSubtype (z.subtypePerm hc)))","decl":"theorem IsCycle.forall_commute_iff [DecidableEq α] [Fintype α] (g z : Perm α) :\n    (∀ c ∈ g.cycleFactorsFinset, Commute z c) ↔\n      ∀ c ∈ g.cycleFactorsFinset,\n      ∃ (hc : ∀ x : α, x ∈ c.support ↔ z x ∈ c.support),\n        ofSubtype (subtypePerm z hc) ∈ Subgroup.zpowers c := by\n  apply forall_congr'\n  intro c\n  apply imp_congr_right\n  intro hc\n  exact IsCycle.commute_iff (mem_cycleFactorsFinset_iff.mp hc).1\n\n"}
{"name":"Equiv.Perm.subtypePerm_on_cycleFactorsFinset","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ng c : Equiv.Perm α\nhc : Membership.mem g.cycleFactorsFinset c\n⊢ Eq (g.subtypePerm ⋯) c.subtypePermOfSupport","decl":"/-- A permutation restricted to the support of a cycle factor is that cycle factor -/\ntheorem subtypePerm_on_cycleFactorsFinset [DecidableEq α] [Fintype α]\n    {g c : Perm α} (hc : c ∈ g.cycleFactorsFinset) :\n    g.subtypePerm (mem_cycleFactorsFinset_support hc) = c.subtypePermOfSupport := by\n  ext ⟨x, hx⟩\n  simp only [subtypePerm_apply, Subtype.coe_mk, subtypePermOfSupport]\n  exact ((mem_cycleFactorsFinset_iff.mp hc).2 x hx).symm\n\n"}
{"name":"Equiv.Perm.commute_iff_of_mem_cycleFactorsFinset","module":"Mathlib.GroupTheory.Perm.Cycle.Factors","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ng k c : Equiv.Perm α\nhc : Membership.mem g.cycleFactorsFinset c\n⊢ Iff (Commute k c) (Exists fun hc' => Membership.mem (Subgroup.zpowers (g.subtypePerm ⋯)) (k.subtypePerm hc'))","decl":"theorem commute_iff_of_mem_cycleFactorsFinset [DecidableEq α] [Fintype α]{g k c : Equiv.Perm α}\n    (hc : c ∈ g.cycleFactorsFinset) :\n    Commute k c ↔\n      ∃ hc' : ∀ x : α, x ∈ c.support ↔ k x ∈ c.support,\n        k.subtypePerm hc' ∈ Subgroup.zpowers\n          (g.subtypePerm (mem_cycleFactorsFinset_support hc)) := by\n  rw [IsCycle.commute_iff' (mem_cycleFactorsFinset_iff.mp hc).1]\n  apply exists_congr\n  intro hc'\n  simp only [Subgroup.mem_zpowers_iff]\n  apply exists_congr\n  intro n\n  rw [Equiv.Perm.subtypePerm_on_cycleFactorsFinset hc]\n\n"}
