{"name":"Commute.add_pow","module":"Mathlib.Data.Nat.Choose.Sum","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nx y : R\nh : Commute x y\nn : Nat\n⊢ Eq (HPow.hPow (HAdd.hAdd x y) n) ((Finset.range (HAdd.hAdd n 1)).sum fun m => HMul.hMul (HMul.hMul (HPow.hPow x m) (HPow.hPow y (HSub.hSub n m))) ↑(n.choose m))","decl":"/-- A version of the **binomial theorem** for commuting elements in noncommutative semirings. -/\ntheorem add_pow (h : Commute x y) (n : ℕ) :\n    (x + y) ^ n = ∑ m ∈ range (n + 1), x ^ m * y ^ (n - m) * n.choose m := by\n  let t : ℕ → ℕ → R := fun n m ↦ x ^ m * y ^ (n - m) * n.choose m\n  change (x + y) ^ n = ∑ m ∈ range (n + 1), t n m\n  have h_first : ∀ n, t n 0 = y ^ n := fun n ↦ by\n    simp only [t, choose_zero_right, pow_zero, cast_one, mul_one, one_mul, tsub_zero]\n  have h_last : ∀ n, t n n.succ = 0 := fun n ↦ by\n    simp only [t, choose_succ_self, cast_zero, mul_zero]\n  have h_middle :\n      ∀ n i : ℕ, i ∈ range n.succ → (t n.succ i.succ) = x * t n i + y * t n i.succ := by\n    intro n i h_mem\n    have h_le : i ≤ n := le_of_lt_succ (mem_range.mp h_mem)\n    dsimp only [t]\n    rw [choose_succ_succ, cast_add, mul_add]\n    congr 1\n    · rw [pow_succ' x, succ_sub_succ, mul_assoc, mul_assoc, mul_assoc]\n    · rw [← mul_assoc y, ← mul_assoc y, (h.symm.pow_right i.succ).eq]\n      by_cases h_eq : i = n\n      · rw [h_eq, choose_succ_self, cast_zero, mul_zero, mul_zero]\n      · rw [succ_sub (lt_of_le_of_ne h_le h_eq)]\n        rw [pow_succ' y, mul_assoc, mul_assoc, mul_assoc, mul_assoc]\n  induction n with\n  | zero =>\n    rw [pow_zero, sum_range_succ, range_zero, sum_empty, zero_add]\n    dsimp only [t]\n    rw [pow_zero, pow_zero, choose_self, cast_one, mul_one, mul_one]\n  | succ n ih =>\n    rw [sum_range_succ', h_first, sum_congr rfl (h_middle n), sum_add_distrib, add_assoc,\n      pow_succ' (x + y), ih, add_mul, mul_sum, mul_sum]\n    congr 1\n    rw [sum_range_succ', sum_range_succ, h_first, h_last, mul_zero, add_zero, _root_.pow_succ']\n\n"}
{"name":"Commute.add_pow'","module":"Mathlib.Data.Nat.Choose.Sum","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nx y : R\nh : Commute x y\nn : Nat\n⊢ Eq (HPow.hPow (HAdd.hAdd x y) n) ((Finset.HasAntidiagonal.antidiagonal n).sum fun m => HSMul.hSMul (n.choose m.1) (HMul.hMul (HPow.hPow x m.1) (HPow.hPow y m.2)))","decl":"/-- A version of `Commute.add_pow` that avoids ℕ-subtraction by summing over the antidiagonal and\nalso with the binomial coefficient applied via scalar action of ℕ. -/\ntheorem add_pow' (h : Commute x y) (n : ℕ) :\n    (x + y) ^ n = ∑ m ∈ antidiagonal n, n.choose m.1 • (x ^ m.1 * y ^ m.2) := by\n  simp_rw [Nat.sum_antidiagonal_eq_sum_range_succ fun m p ↦ n.choose m • (x ^ m * y ^ p),\n    nsmul_eq_mul, cast_comm, h.add_pow]\n\n"}
{"name":"add_pow","module":"Mathlib.Data.Nat.Choose.Sum","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nx y : R\nn : Nat\n⊢ Eq (HPow.hPow (HAdd.hAdd x y) n) ((Finset.range (HAdd.hAdd n 1)).sum fun m => HMul.hMul (HMul.hMul (HPow.hPow x m) (HPow.hPow y (HSub.hSub n m))) ↑(n.choose m))","decl":"/-- The **binomial theorem** -/\ntheorem add_pow [CommSemiring R] (x y : R) (n : ℕ) :\n    (x + y) ^ n = ∑ m ∈ range (n + 1), x ^ m * y ^ (n - m) * n.choose m :=\n  (Commute.all x y).add_pow n\n\n"}
{"name":"sub_pow","module":"Mathlib.Data.Nat.Choose.Sum","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nx y : R\nn : Nat\n⊢ Eq (HPow.hPow (HSub.hSub x y) n) ((Finset.range (HAdd.hAdd n 1)).sum fun m => HMul.hMul (HMul.hMul (HMul.hMul (HPow.hPow (-1) (HAdd.hAdd m n)) (HPow.hPow x m)) (HPow.hPow y (HSub.hSub n m))) ↑(n.choose m))","decl":"/-- A special case of the **binomial theorem** -/\ntheorem sub_pow [CommRing R] (x y : R) (n : ℕ) :\n    (x - y) ^ n = ∑ m ∈ range (n + 1), (-1) ^ (m + n) * x ^ m * y ^ (n - m) * n.choose m := by\n  rw [sub_eq_add_neg, add_pow]\n  congr! 1 with m hm\n  have : (-1 : R) ^ (n - m) = (-1) ^ (n + m) := by\n    rw [mem_range] at hm\n    simp [show n + m = n - m + 2 * m by omega, pow_add]\n  rw [neg_pow, this]\n  ring\n\n"}
{"name":"Nat.sum_range_choose","module":"Mathlib.Data.Nat.Choose.Sum","initialProofState":"n : Nat\n⊢ Eq ((Finset.range (HAdd.hAdd n 1)).sum fun m => n.choose m) (HPow.hPow 2 n)","decl":"/-- The sum of entries in a row of Pascal's triangle -/\ntheorem sum_range_choose (n : ℕ) : (∑ m ∈ range (n + 1), n.choose m) = 2 ^ n := by\n  have := (add_pow 1 1 n).symm\n  simpa [one_add_one_eq_two] using this\n\n"}
{"name":"Nat.sum_range_choose_halfway","module":"Mathlib.Data.Nat.Choose.Sum","initialProofState":"m : Nat\n⊢ Eq ((Finset.range (HAdd.hAdd m 1)).sum fun i => (HAdd.hAdd (HMul.hMul 2 m) 1).choose i) (HPow.hPow 4 m)","decl":"theorem sum_range_choose_halfway (m : ℕ) : (∑ i ∈ range (m + 1), (2 * m + 1).choose i) = 4 ^ m :=\n  have : (∑ i ∈ range (m + 1), (2 * m + 1).choose (2 * m + 1 - i)) =\n      ∑ i ∈ range (m + 1), (2 * m + 1).choose i :=\n    sum_congr rfl fun i hi ↦ choose_symm <| by linarith [mem_range.1 hi]\n  mul_right_injective₀ two_ne_zero <|\n    calc\n      (2 * ∑ i ∈ range (m + 1), (2 * m + 1).choose i) =\n          (∑ i ∈ range (m + 1), (2 * m + 1).choose i) +\n            ∑ i ∈ range (m + 1), (2 * m + 1).choose (2 * m + 1 - i) := by rw [two_mul, this]\n      _ = (∑ i ∈ range (m + 1), (2 * m + 1).choose i) +\n            ∑ i ∈ Ico (m + 1) (2 * m + 2), (2 * m + 1).choose i := by\n        rw [range_eq_Ico, sum_Ico_reflect _ _ (by omega)]\n        congr\n        omega\n      _ = ∑ i ∈ range (2 * m + 2), (2 * m + 1).choose i := sum_range_add_sum_Ico _ (by omega)\n      _ = 2 ^ (2 * m + 1) := sum_range_choose (2 * m + 1)\n      _ = 2 * 4 ^ m := by rw [pow_succ, pow_mul, mul_comm]; rfl\n\n"}
{"name":"Nat.choose_middle_le_pow","module":"Mathlib.Data.Nat.Choose.Sum","initialProofState":"n : Nat\n⊢ LE.le ((HAdd.hAdd (HMul.hMul 2 n) 1).choose n) (HPow.hPow 4 n)","decl":"theorem choose_middle_le_pow (n : ℕ) : (2 * n + 1).choose n ≤ 4 ^ n := by\n  have t : (2 * n + 1).choose n ≤ ∑ i ∈ range (n + 1), (2 * n + 1).choose i :=\n    single_le_sum (fun x _ ↦ by omega) (self_mem_range_succ n)\n  simpa [sum_range_choose_halfway n] using t\n\n"}
{"name":"Nat.four_pow_le_two_mul_add_one_mul_central_binom","module":"Mathlib.Data.Nat.Choose.Sum","initialProofState":"n : Nat\n⊢ LE.le (HPow.hPow 4 n) (HMul.hMul (HAdd.hAdd (HMul.hMul 2 n) 1) ((HMul.hMul 2 n).choose n))","decl":"theorem four_pow_le_two_mul_add_one_mul_central_binom (n : ℕ) :\n    4 ^ n ≤ (2 * n + 1) * (2 * n).choose n :=\n  calc\n    4 ^ n = (1 + 1) ^ (2 * n) := by norm_num [pow_mul]\n    _ = ∑ m ∈ range (2 * n + 1), (2 * n).choose m := by set_option simprocs false in simp [add_pow]\n    _ ≤ ∑ _ ∈ range (2 * n + 1), (2 * n).choose (2 * n / 2) := by gcongr; apply choose_le_middle\n    _ = (2 * n + 1) * choose (2 * n) n := by simp\n\n"}
{"name":"Nat.sum_Icc_choose","module":"Mathlib.Data.Nat.Choose.Sum","initialProofState":"n k : Nat\n⊢ Eq ((Finset.Icc k n).sum fun m => m.choose k) ((HAdd.hAdd n 1).choose (HAdd.hAdd k 1))","decl":"/-- **Zhu Shijie's identity** aka hockey-stick identity, version with `Icc`. -/\ntheorem sum_Icc_choose (n k : ℕ) : ∑ m ∈ Icc k n, m.choose k = (n + 1).choose (k + 1) := by\n  rcases lt_or_le n k with h | h\n  · rw [choose_eq_zero_of_lt (by omega), Icc_eq_empty_of_lt h, sum_empty]\n  · induction n, h using le_induction with\n    | base => simp\n    | succ n _ ih =>\n      rw [← Ico_insert_right (by omega), sum_insert (by simp), Ico_succ_right, ih,\n        choose_succ_succ' (n + 1)]\n\n"}
{"name":"Nat.sum_range_add_choose","module":"Mathlib.Data.Nat.Choose.Sum","initialProofState":"n k : Nat\n⊢ Eq ((Finset.range (HAdd.hAdd n 1)).sum fun i => (HAdd.hAdd i k).choose k) ((HAdd.hAdd (HAdd.hAdd n k) 1).choose (HAdd.hAdd k 1))","decl":"/-- **Zhu Shijie's identity** aka hockey-stick identity, version with `range`.\nSumming `(i + k).choose k` for `i ∈ [0, n]` gives `(n + k + 1).choose (k + 1)`.\n\nCombinatorial interpretation: `(i + k).choose k` is the number of decompositions of `[0, i)` in\n`k + 1` (possibly empty) intervals (this follows from a stars and bars description). In particular,\n`(n + k + 1).choose (k + 1)` corresponds to decomposing `[0, n)` into `k + 2` intervals.\nBy putting away the last interval (of some length `n - i`),\nwe have to decompose the remaining interval `[0, i)` into `k + 1` intervals, hence the sum. -/\nlemma sum_range_add_choose (n k : ℕ) :\n    ∑ i ∈ Finset.range (n + 1), (i + k).choose k = (n + k + 1).choose (k + 1) := by\n  rw [← sum_Icc_choose, range_eq_Ico]\n  convert (sum_map _ (addRightEmbedding k) (·.choose k)).symm using 2\n  rw [map_add_right_Ico, zero_add, add_right_comm, Nat.Ico_succ_right]\n\n"}
{"name":"Int.alternating_sum_range_choose","module":"Mathlib.Data.Nat.Choose.Sum","initialProofState":"n : Nat\n⊢ Eq ((Finset.range (HAdd.hAdd n 1)).sum fun m => HMul.hMul (HPow.hPow (-1) m) ↑(n.choose m)) (ite (Eq n 0) 1 0)","decl":"theorem Int.alternating_sum_range_choose {n : ℕ} :\n    (∑ m ∈ range (n + 1), ((-1) ^ m * n.choose m : ℤ)) = if n = 0 then 1 else 0 := by\n  cases n with\n  | zero => simp\n  | succ n =>\n    have h := add_pow (-1 : ℤ) 1 n.succ\n    simp only [one_pow, mul_one, neg_add_cancel] at h\n    rw [← h, zero_pow n.succ_ne_zero, if_neg n.succ_ne_zero]\n\n"}
{"name":"Int.alternating_sum_range_choose_of_ne","module":"Mathlib.Data.Nat.Choose.Sum","initialProofState":"n : Nat\nh0 : Ne n 0\n⊢ Eq ((Finset.range (HAdd.hAdd n 1)).sum fun m => HMul.hMul (HPow.hPow (-1) m) ↑(n.choose m)) 0","decl":"theorem Int.alternating_sum_range_choose_of_ne {n : ℕ} (h0 : n ≠ 0) :\n    (∑ m ∈ range (n + 1), ((-1) ^ m * n.choose m : ℤ)) = 0 := by\n  rw [Int.alternating_sum_range_choose, if_neg h0]\n\n"}
{"name":"Finset.sum_powerset_apply_card","module":"Mathlib.Data.Nat.Choose.Sum","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : AddCommMonoid α\nf : Nat → α\nx : Finset β\n⊢ Eq (x.powerset.sum fun m => f m.card) ((Finset.range (HAdd.hAdd x.card 1)).sum fun m => HSMul.hSMul (x.card.choose m) (f m))","decl":"theorem sum_powerset_apply_card {α β : Type*} [AddCommMonoid α] (f : ℕ → α) {x : Finset β} :\n    ∑ m ∈ x.powerset, f #m = ∑ m ∈ range (#x + 1), (#x).choose m • f m := by\n  trans ∑ m ∈ range (#x + 1), ∑ j ∈ x.powerset with #j = m, f #j\n  · refine (sum_fiberwise_of_maps_to ?_ _).symm\n    intro y hy\n    rw [mem_range, Nat.lt_succ_iff]\n    rw [mem_powerset] at hy\n    exact card_le_card hy\n  · refine sum_congr rfl fun y _ ↦ ?_\n    rw [← card_powersetCard, ← sum_const]\n    refine sum_congr powersetCard_eq_filter.symm fun z hz ↦ ?_\n    rw [(mem_powersetCard.1 hz).2]\n\n"}
{"name":"Finset.sum_powerset_neg_one_pow_card","module":"Mathlib.Data.Nat.Choose.Sum","initialProofState":"α : Type u_2\ninst✝ : DecidableEq α\nx : Finset α\n⊢ Eq (x.powerset.sum fun m => HPow.hPow (-1) m.card) (ite (Eq x EmptyCollection.emptyCollection) 1 0)","decl":"theorem sum_powerset_neg_one_pow_card {α : Type*} [DecidableEq α] {x : Finset α} :\n    (∑ m ∈ x.powerset, (-1 : ℤ) ^ #m) = if x = ∅ then 1 else 0 := by\n  rw [sum_powerset_apply_card]\n  simp only [nsmul_eq_mul', ← card_eq_zero, Int.alternating_sum_range_choose]\n\n"}
{"name":"Finset.sum_powerset_neg_one_pow_card_of_nonempty","module":"Mathlib.Data.Nat.Choose.Sum","initialProofState":"α : Type u_2\nx : Finset α\nh0 : x.Nonempty\n⊢ Eq (x.powerset.sum fun m => HPow.hPow (-1) m.card) 0","decl":"theorem sum_powerset_neg_one_pow_card_of_nonempty {α : Type*} {x : Finset α} (h0 : x.Nonempty) :\n    (∑ m ∈ x.powerset, (-1 : ℤ) ^ #m) = 0 := by\n  classical\n  rw [sum_powerset_neg_one_pow_card]\n  exact if_neg (nonempty_iff_ne_empty.mp h0)\n\n"}
{"name":"Finset.sum_choose_succ_nsmul","module":"Mathlib.Data.Nat.Choose.Sum","initialProofState":"M : Type u_2\ninst✝ : AddCommMonoid M\nf : Nat → Nat → M\nn : Nat\n⊢ Eq ((Finset.range (HAdd.hAdd n 2)).sum fun i => HSMul.hSMul ((HAdd.hAdd n 1).choose i) (f i (HSub.hSub (HAdd.hAdd n 1) i))) (HAdd.hAdd ((Finset.range (HAdd.hAdd n 1)).sum fun i => HSMul.hSMul (n.choose i) (f i (HSub.hSub (HAdd.hAdd n 1) i))) ((Finset.range (HAdd.hAdd n 1)).sum fun i => HSMul.hSMul (n.choose i) (f (HAdd.hAdd i 1) (HSub.hSub n i))))","decl":"@[to_additive sum_choose_succ_nsmul]\ntheorem prod_pow_choose_succ {M : Type*} [CommMonoid M] (f : ℕ → ℕ → M) (n : ℕ) :\n    (∏ i ∈ range (n + 2), f i (n + 1 - i) ^ (n + 1).choose i) =\n      (∏ i ∈ range (n + 1), f i (n + 1 - i) ^ n.choose i) *\n        ∏ i ∈ range (n + 1), f (i + 1) (n - i) ^ n.choose i := by\n  have A : (∏ i ∈ range (n + 1), f (i + 1) (n - i) ^ (n.choose (i + 1))) * f 0 (n + 1) =\n      ∏ i ∈ range (n + 1), f i (n + 1 - i) ^ (n.choose i) := by\n    rw [prod_range_succ, prod_range_succ']; simp\n  rw [prod_range_succ']\n  simpa [choose_succ_succ, pow_add, prod_mul_distrib, A, mul_assoc] using mul_comm _ _\n\n"}
{"name":"Finset.prod_pow_choose_succ","module":"Mathlib.Data.Nat.Choose.Sum","initialProofState":"M : Type u_2\ninst✝ : CommMonoid M\nf : Nat → Nat → M\nn : Nat\n⊢ Eq ((Finset.range (HAdd.hAdd n 2)).prod fun i => HPow.hPow (f i (HSub.hSub (HAdd.hAdd n 1) i)) ((HAdd.hAdd n 1).choose i)) (HMul.hMul ((Finset.range (HAdd.hAdd n 1)).prod fun i => HPow.hPow (f i (HSub.hSub (HAdd.hAdd n 1) i)) (n.choose i)) ((Finset.range (HAdd.hAdd n 1)).prod fun i => HPow.hPow (f (HAdd.hAdd i 1) (HSub.hSub n i)) (n.choose i)))","decl":"@[to_additive sum_choose_succ_nsmul]\ntheorem prod_pow_choose_succ {M : Type*} [CommMonoid M] (f : ℕ → ℕ → M) (n : ℕ) :\n    (∏ i ∈ range (n + 2), f i (n + 1 - i) ^ (n + 1).choose i) =\n      (∏ i ∈ range (n + 1), f i (n + 1 - i) ^ n.choose i) *\n        ∏ i ∈ range (n + 1), f (i + 1) (n - i) ^ n.choose i := by\n  have A : (∏ i ∈ range (n + 1), f (i + 1) (n - i) ^ (n.choose (i + 1))) * f 0 (n + 1) =\n      ∏ i ∈ range (n + 1), f i (n + 1 - i) ^ (n.choose i) := by\n    rw [prod_range_succ, prod_range_succ']; simp\n  rw [prod_range_succ']\n  simpa [choose_succ_succ, pow_add, prod_mul_distrib, A, mul_assoc] using mul_comm _ _\n\n"}
{"name":"Finset.prod_antidiagonal_pow_choose_succ","module":"Mathlib.Data.Nat.Choose.Sum","initialProofState":"M : Type u_2\ninst✝ : CommMonoid M\nf : Nat → Nat → M\nn : Nat\n⊢ Eq ((Finset.HasAntidiagonal.antidiagonal (HAdd.hAdd n 1)).prod fun ij => HPow.hPow (f ij.1 ij.2) ((HAdd.hAdd n 1).choose ij.1)) (HMul.hMul ((Finset.HasAntidiagonal.antidiagonal n).prod fun ij => HPow.hPow (f ij.1 (HAdd.hAdd ij.2 1)) (n.choose ij.1)) ((Finset.HasAntidiagonal.antidiagonal n).prod fun ij => HPow.hPow (f (HAdd.hAdd ij.1 1) ij.2) (n.choose ij.2)))","decl":"@[to_additive sum_antidiagonal_choose_succ_nsmul]\ntheorem prod_antidiagonal_pow_choose_succ {M : Type*} [CommMonoid M] (f : ℕ → ℕ → M) (n : ℕ) :\n    (∏ ij ∈ antidiagonal (n + 1), f ij.1 ij.2 ^ (n + 1).choose ij.1) =\n      (∏ ij ∈ antidiagonal n, f ij.1 (ij.2 + 1) ^ n.choose ij.1) *\n        ∏ ij ∈ antidiagonal n, f (ij.1 + 1) ij.2 ^ n.choose ij.2 := by\n  simp only [Nat.prod_antidiagonal_eq_prod_range_succ_mk, prod_pow_choose_succ]\n  have : ∀ i ∈ range (n + 1), i ≤ n := fun i hi ↦ by simpa [Nat.lt_succ_iff] using hi\n  congr 1\n  · refine prod_congr rfl fun i hi ↦ ?_\n    rw [tsub_add_eq_add_tsub (this _ hi)]\n  · refine prod_congr rfl fun i hi ↦ ?_\n    rw [choose_symm (this _ hi)]\n\n"}
{"name":"Finset.sum_antidiagonal_choose_succ_nsmul","module":"Mathlib.Data.Nat.Choose.Sum","initialProofState":"M : Type u_2\ninst✝ : AddCommMonoid M\nf : Nat → Nat → M\nn : Nat\n⊢ Eq ((Finset.HasAntidiagonal.antidiagonal (HAdd.hAdd n 1)).sum fun ij => HSMul.hSMul ((HAdd.hAdd n 1).choose ij.1) (f ij.1 ij.2)) (HAdd.hAdd ((Finset.HasAntidiagonal.antidiagonal n).sum fun ij => HSMul.hSMul (n.choose ij.1) (f ij.1 (HAdd.hAdd ij.2 1))) ((Finset.HasAntidiagonal.antidiagonal n).sum fun ij => HSMul.hSMul (n.choose ij.2) (f (HAdd.hAdd ij.1 1) ij.2)))","decl":"@[to_additive sum_antidiagonal_choose_succ_nsmul]\ntheorem prod_antidiagonal_pow_choose_succ {M : Type*} [CommMonoid M] (f : ℕ → ℕ → M) (n : ℕ) :\n    (∏ ij ∈ antidiagonal (n + 1), f ij.1 ij.2 ^ (n + 1).choose ij.1) =\n      (∏ ij ∈ antidiagonal n, f ij.1 (ij.2 + 1) ^ n.choose ij.1) *\n        ∏ ij ∈ antidiagonal n, f (ij.1 + 1) ij.2 ^ n.choose ij.2 := by\n  simp only [Nat.prod_antidiagonal_eq_prod_range_succ_mk, prod_pow_choose_succ]\n  have : ∀ i ∈ range (n + 1), i ≤ n := fun i hi ↦ by simpa [Nat.lt_succ_iff] using hi\n  congr 1\n  · refine prod_congr rfl fun i hi ↦ ?_\n    rw [tsub_add_eq_add_tsub (this _ hi)]\n  · refine prod_congr rfl fun i hi ↦ ?_\n    rw [choose_symm (this _ hi)]\n\n"}
{"name":"Finset.sum_choose_succ_mul","module":"Mathlib.Data.Nat.Choose.Sum","initialProofState":"R : Type u_1\ninst✝ : NonAssocSemiring R\nf : Nat → Nat → R\nn : Nat\n⊢ Eq ((Finset.range (HAdd.hAdd n 2)).sum fun i => HMul.hMul (↑((HAdd.hAdd n 1).choose i)) (f i (HSub.hSub (HAdd.hAdd n 1) i))) (HAdd.hAdd ((Finset.range (HAdd.hAdd n 1)).sum fun i => HMul.hMul (↑(n.choose i)) (f i (HSub.hSub (HAdd.hAdd n 1) i))) ((Finset.range (HAdd.hAdd n 1)).sum fun i => HMul.hMul (↑(n.choose i)) (f (HAdd.hAdd i 1) (HSub.hSub n i))))","decl":"/-- The sum of `(n+1).choose i * f i (n+1-i)` can be split into two sums at rank `n`,\nrespectively of `n.choose i * f i (n+1-i)` and `n.choose i * f (i+1) (n-i)`. -/\ntheorem sum_choose_succ_mul (f : ℕ → ℕ → R) (n : ℕ) :\n    (∑ i ∈ range (n + 2), ((n + 1).choose i : R) * f i (n + 1 - i)) =\n      (∑ i ∈ range (n + 1), (n.choose i : R) * f i (n + 1 - i)) +\n        ∑ i ∈ range (n + 1), (n.choose i : R) * f (i + 1) (n - i) := by\n  simpa only [nsmul_eq_mul] using sum_choose_succ_nsmul f n\n\n"}
{"name":"Finset.sum_antidiagonal_choose_succ_mul","module":"Mathlib.Data.Nat.Choose.Sum","initialProofState":"R : Type u_1\ninst✝ : NonAssocSemiring R\nf : Nat → Nat → R\nn : Nat\n⊢ Eq ((Finset.HasAntidiagonal.antidiagonal (HAdd.hAdd n 1)).sum fun ij => HMul.hMul (↑((HAdd.hAdd n 1).choose ij.1)) (f ij.1 ij.2)) (HAdd.hAdd ((Finset.HasAntidiagonal.antidiagonal n).sum fun ij => HMul.hMul (↑(n.choose ij.1)) (f ij.1 (HAdd.hAdd ij.2 1))) ((Finset.HasAntidiagonal.antidiagonal n).sum fun ij => HMul.hMul (↑(n.choose ij.2)) (f (HAdd.hAdd ij.1 1) ij.2)))","decl":"/-- The sum along the antidiagonal of `(n+1).choose i * f i j` can be split into two sums along the\nantidiagonal at rank `n`, respectively of `n.choose i * f i (j+1)` and `n.choose j * f (i+1) j`. -/\ntheorem sum_antidiagonal_choose_succ_mul (f : ℕ → ℕ → R) (n : ℕ) :\n    (∑ ij ∈ antidiagonal (n + 1), ((n + 1).choose ij.1 : R) * f ij.1 ij.2) =\n      (∑ ij ∈ antidiagonal n, (n.choose ij.1 : R) * f ij.1 (ij.2 + 1)) +\n        ∑ ij ∈ antidiagonal n, (n.choose ij.2 : R) * f (ij.1 + 1) ij.2 := by\n  simpa only [nsmul_eq_mul] using sum_antidiagonal_choose_succ_nsmul f n\n\n"}
{"name":"Finset.sum_antidiagonal_choose_add","module":"Mathlib.Data.Nat.Choose.Sum","initialProofState":"d n : Nat\n⊢ Eq ((Finset.HasAntidiagonal.antidiagonal n).sum fun ij => (HAdd.hAdd d ij.2).choose d) ((HAdd.hAdd (HAdd.hAdd d n) 1).choose (HAdd.hAdd d 1))","decl":"theorem sum_antidiagonal_choose_add (d n : ℕ) :\n    (∑ ij ∈ antidiagonal n, (d + ij.2).choose d) = (d + n + 1).choose (d + 1) := by\n  induction n with\n  | zero => simp\n  | succ n hn => rw [Nat.sum_antidiagonal_succ, hn, Nat.choose_succ_succ (d + (n + 1)), ← add_assoc]\n\n"}
