{"name":"NNRat.cast_natCast","module":"Mathlib.Data.Rat.Cast.Defs","initialProofState":"α : Type u_3\ninst✝ : DivisionSemiring α\nn : Nat\n⊢ Eq ↑↑n ↑n","decl":"@[simp, norm_cast] lemma cast_natCast (n : ℕ) : ((n : ℚ≥0) : α) = n := by simp [cast_def]\n\n"}
{"name":"NNRat.cast_ofNat","module":"Mathlib.Data.Rat.Cast.Defs","initialProofState":"α : Type u_3\ninst✝¹ : DivisionSemiring α\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (↑(OfNat.ofNat n)) (OfNat.ofNat n)","decl":"@[simp, norm_cast] lemma cast_ofNat (n : ℕ) [n.AtLeastTwo] :\n    (ofNat(n) : ℚ≥0) = (ofNat(n) : α) := cast_natCast _\n\n"}
{"name":"NNRat.cast_zero","module":"Mathlib.Data.Rat.Cast.Defs","initialProofState":"α : Type u_3\ninst✝ : DivisionSemiring α\n⊢ Eq (↑0) 0","decl":"@[simp, norm_cast] lemma cast_zero : ((0 : ℚ≥0) : α) = 0 := (cast_natCast _).trans Nat.cast_zero\n"}
{"name":"NNRat.cast_one","module":"Mathlib.Data.Rat.Cast.Defs","initialProofState":"α : Type u_3\ninst✝ : DivisionSemiring α\n⊢ Eq (↑1) 1","decl":"@[simp, norm_cast] lemma cast_one : ((1 : ℚ≥0) : α) = 1 := (cast_natCast _).trans Nat.cast_one\n\n"}
{"name":"NNRat.cast_commute","module":"Mathlib.Data.Rat.Cast.Defs","initialProofState":"α : Type u_3\ninst✝ : DivisionSemiring α\nq : NNRat\na : α\n⊢ Commute (↑q) a","decl":"lemma cast_commute (q : ℚ≥0) (a : α) : Commute (↑q) a := by\n  simpa only [cast_def] using (q.num.cast_commute a).div_left (q.den.cast_commute a)\n\n"}
{"name":"NNRat.commute_cast","module":"Mathlib.Data.Rat.Cast.Defs","initialProofState":"α : Type u_3\ninst✝ : DivisionSemiring α\na : α\nq : NNRat\n⊢ Commute a ↑q","decl":"lemma commute_cast (a : α) (q : ℚ≥0) : Commute a q := (cast_commute ..).symm\n\n"}
{"name":"NNRat.cast_comm","module":"Mathlib.Data.Rat.Cast.Defs","initialProofState":"α : Type u_3\ninst✝ : DivisionSemiring α\nq : NNRat\na : α\n⊢ Eq (HMul.hMul (↑q) a) (HMul.hMul a ↑q)","decl":"lemma cast_comm (q : ℚ≥0) (a : α) : q * a = a * q := cast_commute _ _\n\n"}
{"name":"NNRat.cast_divNat_of_ne_zero","module":"Mathlib.Data.Rat.Cast.Defs","initialProofState":"α : Type u_3\ninst✝ : DivisionSemiring α\na b : Nat\nhb : Ne (↑b) 0\n⊢ Eq (↑(NNRat.divNat a b)) (HDiv.hDiv ↑a ↑b)","decl":"@[norm_cast] lemma cast_divNat_of_ne_zero (a : ℕ) {b : ℕ} (hb : (b : α) ≠ 0) :\n    divNat a b = (a / b : α) := by\n  rcases e : divNat a b with ⟨⟨n, d, h, c⟩, hn⟩\n  rw [← Rat.num_nonneg] at hn\n  lift n to ℕ using hn\n  have hd : (d : α) ≠ 0 := by\n    refine fun hd ↦ hb ?_\n    have : Rat.divInt a b = _ := congr_arg NNRat.cast e\n    obtain ⟨k, rfl⟩ : d ∣ b := by simpa [Int.natCast_dvd_natCast, this] using Rat.den_dvd a b\n    simp [*]\n  have hb' : b ≠ 0 := by rintro rfl; exact hb Nat.cast_zero\n  have hd' : d ≠ 0 := by rintro rfl; exact hd Nat.cast_zero\n  simp_rw [Rat.mk'_eq_divInt, mk_divInt, divNat_inj hb' hd'] at e\n  rw [cast_def]\n  dsimp\n  rw [Commute.div_eq_div_iff _ hd hb]\n  · norm_cast\n    rw [e]\n  exact b.commute_cast _\n\n"}
{"name":"NNRat.cast_add_of_ne_zero","module":"Mathlib.Data.Rat.Cast.Defs","initialProofState":"α : Type u_3\ninst✝ : DivisionSemiring α\nq r : NNRat\nhq : Ne (↑q.den) 0\nhr : Ne (↑r.den) 0\n⊢ Eq (↑(HAdd.hAdd q r)) (HAdd.hAdd ↑q ↑r)","decl":"@[norm_cast]\nlemma cast_add_of_ne_zero (hq : (q.den : α) ≠ 0) (hr : (r.den : α) ≠ 0) :\n    ↑(q + r) = (q + r : α) := by\n  rw [add_def, cast_divNat_of_ne_zero, cast_def, cast_def, mul_comm _ q.den,\n    (Nat.commute_cast _ _).div_add_div (Nat.commute_cast _ _) hq hr]\n  · push_cast\n    rfl\n  · push_cast\n    exact mul_ne_zero hq hr\n\n"}
{"name":"NNRat.cast_mul_of_ne_zero","module":"Mathlib.Data.Rat.Cast.Defs","initialProofState":"α : Type u_3\ninst✝ : DivisionSemiring α\nq r : NNRat\nhq : Ne (↑q.den) 0\nhr : Ne (↑r.den) 0\n⊢ Eq (↑(HMul.hMul q r)) (HMul.hMul ↑q ↑r)","decl":"@[norm_cast]\nlemma cast_mul_of_ne_zero (hq : (q.den : α) ≠ 0) (hr : (r.den : α) ≠ 0) :\n    ↑(q * r) = (q * r : α) := by\n  rw [mul_def, cast_divNat_of_ne_zero, cast_def, cast_def,\n    (Nat.commute_cast _ _).div_mul_div_comm (Nat.commute_cast _ _)]\n  · push_cast\n    rfl\n  · push_cast\n    exact mul_ne_zero hq hr\n\n"}
{"name":"NNRat.cast_inv_of_ne_zero","module":"Mathlib.Data.Rat.Cast.Defs","initialProofState":"α : Type u_3\ninst✝ : DivisionSemiring α\nq : NNRat\nhq : Ne (↑q.num) 0\n⊢ Eq (↑(Inv.inv q)) (Inv.inv ↑q)","decl":"@[norm_cast]\nlemma cast_inv_of_ne_zero (hq : (q.num : α) ≠ 0) : (q⁻¹ : ℚ≥0) = (q⁻¹ : α) := by\n  rw [inv_def, cast_divNat_of_ne_zero _ hq, cast_def, inv_div]\n\n"}
{"name":"NNRat.cast_div_of_ne_zero","module":"Mathlib.Data.Rat.Cast.Defs","initialProofState":"α : Type u_3\ninst✝ : DivisionSemiring α\nq r : NNRat\nhq : Ne (↑q.den) 0\nhr : Ne (↑r.num) 0\n⊢ Eq (↑(HDiv.hDiv q r)) (HDiv.hDiv ↑q ↑r)","decl":"@[norm_cast]\nlemma cast_div_of_ne_zero (hq : (q.den : α) ≠ 0) (hr : (r.num : α) ≠ 0) :\n    ↑(q / r) = (q / r : α) := by\n  rw [div_def, cast_divNat_of_ne_zero, cast_def, cast_def, div_eq_mul_inv (_ / _),\n    inv_div, (Nat.commute_cast _ _).div_mul_div_comm (Nat.commute_cast _ _)]\n  · push_cast\n    rfl\n  · push_cast\n    exact mul_ne_zero hq hr\n\n"}
{"name":"Rat.cast_intCast","module":"Mathlib.Data.Rat.Cast.Defs","initialProofState":"α : Type u_3\ninst✝ : DivisionRing α\nn : Int\n⊢ Eq ↑↑n ↑n","decl":"@[simp, norm_cast]\ntheorem cast_intCast (n : ℤ) : ((n : ℚ) : α) = n :=\n  (cast_def _).trans <| show (n / (1 : ℕ) : α) = n by rw [Nat.cast_one, div_one]\n\n"}
{"name":"Rat.cast_natCast","module":"Mathlib.Data.Rat.Cast.Defs","initialProofState":"α : Type u_3\ninst✝ : DivisionRing α\nn : Nat\n⊢ Eq ↑↑n ↑n","decl":"@[simp, norm_cast]\ntheorem cast_natCast (n : ℕ) : ((n : ℚ) : α) = n := by\n  rw [← Int.cast_natCast, cast_intCast, Int.cast_natCast]\n\n\n"}
{"name":"Rat.cast_ofNat","module":"Mathlib.Data.Rat.Cast.Defs","initialProofState":"α : Type u_3\ninst✝¹ : DivisionRing α\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (↑(OfNat.ofNat n)) (OfNat.ofNat n)","decl":"@[simp, norm_cast] lemma cast_ofNat (n : ℕ) [n.AtLeastTwo] :\n    ((ofNat(n) : ℚ) : α) = (ofNat(n) : α) := by\n  simp [cast_def]\n\n"}
{"name":"Rat.cast_zero","module":"Mathlib.Data.Rat.Cast.Defs","initialProofState":"α : Type u_3\ninst✝ : DivisionRing α\n⊢ Eq (↑0) 0","decl":"@[simp, norm_cast]\ntheorem cast_zero : ((0 : ℚ) : α) = 0 :=\n  (cast_intCast _).trans Int.cast_zero\n\n"}
{"name":"Rat.cast_one","module":"Mathlib.Data.Rat.Cast.Defs","initialProofState":"α : Type u_3\ninst✝ : DivisionRing α\n⊢ Eq (↑1) 1","decl":"@[simp, norm_cast]\ntheorem cast_one : ((1 : ℚ) : α) = 1 :=\n  (cast_intCast _).trans Int.cast_one\n\n"}
{"name":"Rat.cast_commute","module":"Mathlib.Data.Rat.Cast.Defs","initialProofState":"α : Type u_3\ninst✝ : DivisionRing α\nr : Rat\na : α\n⊢ Commute (↑r) a","decl":"theorem cast_commute (r : ℚ) (a : α) : Commute (↑r) a := by\n  simpa only [cast_def] using (r.1.cast_commute a).div_left (r.2.cast_commute a)\n\n"}
{"name":"Rat.cast_comm","module":"Mathlib.Data.Rat.Cast.Defs","initialProofState":"α : Type u_3\ninst✝ : DivisionRing α\nr : Rat\na : α\n⊢ Eq (HMul.hMul (↑r) a) (HMul.hMul a ↑r)","decl":"theorem cast_comm (r : ℚ) (a : α) : (r : α) * a = a * r :=\n  (cast_commute r a).eq\n\n"}
{"name":"Rat.commute_cast","module":"Mathlib.Data.Rat.Cast.Defs","initialProofState":"α : Type u_3\ninst✝ : DivisionRing α\na : α\nr : Rat\n⊢ Commute a ↑r","decl":"theorem commute_cast (a : α) (r : ℚ) : Commute a r :=\n  (r.cast_commute a).symm\n\n"}
{"name":"Rat.cast_divInt_of_ne_zero","module":"Mathlib.Data.Rat.Cast.Defs","initialProofState":"α : Type u_3\ninst✝ : DivisionRing α\na b : Int\nb0 : Ne (↑b) 0\n⊢ Eq (↑(Rat.divInt a b)) (HDiv.hDiv ↑a ↑b)","decl":"@[norm_cast]\nlemma cast_divInt_of_ne_zero (a : ℤ) {b : ℤ} (b0 : (b : α) ≠ 0) : (a /. b : α) = a / b := by\n  have b0' : b ≠ 0 := by\n    refine mt ?_ b0\n    simp +contextual\n  cases' e : a /. b with n d h c\n  have d0 : (d : α) ≠ 0 := by\n    intro d0\n    have dd := den_dvd a b\n    cases' show (d : ℤ) ∣ b by rwa [e] at dd with k ke\n    have : (b : α) = (d : α) * (k : α) := by rw [ke, Int.cast_mul, Int.cast_natCast]\n    rw [d0, zero_mul] at this\n    contradiction\n  rw [mk'_eq_divInt] at e\n  have := congr_arg ((↑) : ℤ → α)\n    ((divInt_eq_iff b0' <| ne_of_gt <| Int.natCast_pos.2 h.bot_lt).1 e)\n  rw [Int.cast_mul, Int.cast_mul, Int.cast_natCast] at this\n  rw [eq_comm, cast_def, div_eq_mul_inv, eq_div_iff_mul_eq d0, mul_assoc, (d.commute_cast _).eq,\n    ← mul_assoc, this, mul_assoc, mul_inv_cancel₀ b0, mul_one]\n\n"}
{"name":"Rat.cast_mkRat_of_ne_zero","module":"Mathlib.Data.Rat.Cast.Defs","initialProofState":"α : Type u_3\ninst✝ : DivisionRing α\na : Int\nb : Nat\nhb : Ne (↑b) 0\n⊢ Eq (↑(mkRat a b)) (HDiv.hDiv ↑a ↑b)","decl":"@[norm_cast]\nlemma cast_mkRat_of_ne_zero (a : ℤ) {b : ℕ} (hb : (b : α) ≠ 0) : (mkRat a b : α) = a / b := by\n  rw [Rat.mkRat_eq_divInt, cast_divInt_of_ne_zero, Int.cast_natCast]; rwa [Int.cast_natCast]\n\n"}
{"name":"Rat.cast_add_of_ne_zero","module":"Mathlib.Data.Rat.Cast.Defs","initialProofState":"α : Type u_3\ninst✝ : DivisionRing α\nq r : Rat\nhq : Ne (↑q.den) 0\nhr : Ne (↑r.den) 0\n⊢ Eq (↑(HAdd.hAdd q r)) (HAdd.hAdd ↑q ↑r)","decl":"@[norm_cast]\nlemma cast_add_of_ne_zero {q r : ℚ} (hq : (q.den : α) ≠ 0) (hr : (r.den : α) ≠ 0) :\n    (q + r : ℚ) = (q + r : α) := by\n  rw [add_def', cast_mkRat_of_ne_zero, cast_def, cast_def, mul_comm r.num,\n    (Nat.cast_commute _ _).div_add_div (Nat.commute_cast _ _) hq hr]\n  · push_cast\n    rfl\n  · push_cast\n    exact mul_ne_zero hq hr\n\n"}
{"name":"Rat.cast_neg","module":"Mathlib.Data.Rat.Cast.Defs","initialProofState":"α : Type u_3\ninst✝ : DivisionRing α\nq : Rat\n⊢ Eq (↑(Neg.neg q)) (Neg.neg ↑q)","decl":"@[simp, norm_cast] lemma cast_neg (q : ℚ) : ↑(-q) = (-q : α) := by simp [cast_def, neg_div]\n\n"}
{"name":"Rat.cast_sub_of_ne_zero","module":"Mathlib.Data.Rat.Cast.Defs","initialProofState":"α : Type u_3\ninst✝ : DivisionRing α\np q : Rat\nhp : Ne (↑p.den) 0\nhq : Ne (↑q.den) 0\n⊢ Eq (↑(HSub.hSub p q)) (HSub.hSub ↑p ↑q)","decl":"@[norm_cast] lemma cast_sub_of_ne_zero (hp : (p.den : α) ≠ 0) (hq : (q.den : α) ≠ 0) :\n    ↑(p - q) = (p - q : α) := by simp [sub_eq_add_neg, cast_add_of_ne_zero, hp, hq]\n\n"}
{"name":"Rat.cast_mul_of_ne_zero","module":"Mathlib.Data.Rat.Cast.Defs","initialProofState":"α : Type u_3\ninst✝ : DivisionRing α\np q : Rat\nhp : Ne (↑p.den) 0\nhq : Ne (↑q.den) 0\n⊢ Eq (↑(HMul.hMul p q)) (HMul.hMul ↑p ↑q)","decl":"@[norm_cast] lemma cast_mul_of_ne_zero (hp : (p.den : α) ≠ 0) (hq : (q.den : α) ≠ 0) :\n    ↑(p * q) = (p * q : α) := by\n  rw [mul_eq_mkRat, cast_mkRat_of_ne_zero, cast_def, cast_def,\n    (Nat.commute_cast _ _).div_mul_div_comm (Int.commute_cast _ _)]\n  · push_cast\n    rfl\n  · push_cast\n    exact mul_ne_zero hp hq\n\n"}
{"name":"Rat.cast_inv_of_ne_zero","module":"Mathlib.Data.Rat.Cast.Defs","initialProofState":"α : Type u_3\ninst✝ : DivisionRing α\nq : Rat\nhq : Ne (↑q.num) 0\n⊢ Eq (↑(Inv.inv q)) (Inv.inv ↑q)","decl":"@[norm_cast]\nlemma cast_inv_of_ne_zero (hq : (q.num : α) ≠ 0) : ↑(q⁻¹) = (q⁻¹ : α) := by\n  rw [inv_def', cast_divInt_of_ne_zero _ hq, cast_def, inv_div, Int.cast_natCast]\n\n"}
{"name":"Rat.cast_div_of_ne_zero","module":"Mathlib.Data.Rat.Cast.Defs","initialProofState":"α : Type u_3\ninst✝ : DivisionRing α\np q : Rat\nhp : Ne (↑p.den) 0\nhq : Ne (↑q.num) 0\n⊢ Eq (↑(HDiv.hDiv p q)) (HDiv.hDiv ↑p ↑q)","decl":"@[norm_cast] lemma cast_div_of_ne_zero (hp : (p.den : α) ≠ 0) (hq : (q.num : α) ≠ 0) :\n    ↑(p / q) = (p / q : α) := by\n  rw [div_def', cast_divInt_of_ne_zero, cast_def, cast_def, div_eq_mul_inv (_ / _), inv_div,\n    (Int.commute_cast _ _).div_mul_div_comm (Nat.commute_cast _ _)]\n  · push_cast\n    rfl\n  · push_cast\n    exact mul_ne_zero hp hq\n\n"}
{"name":"map_nnratCast","module":"Mathlib.Data.Rat.Cast.Defs","initialProofState":"F : Type u_1\nα : Type u_3\nβ : Type u_4\ninst✝³ : FunLike F α β\ninst✝² : DivisionSemiring α\ninst✝¹ : DivisionSemiring β\ninst✝ : RingHomClass F α β\nf : F\nq : NNRat\n⊢ Eq (f ↑q) ↑q","decl":"@[simp] lemma map_nnratCast [DivisionSemiring α] [DivisionSemiring β] [RingHomClass F α β] (f : F)\n    (q : ℚ≥0) : f q = q := by simp_rw [NNRat.cast_def, map_div₀, map_natCast]\n\n"}
{"name":"eq_nnratCast","module":"Mathlib.Data.Rat.Cast.Defs","initialProofState":"F : Type u_1\nα : Type u_3\ninst✝² : DivisionSemiring α\ninst✝¹ : FunLike F NNRat α\ninst✝ : RingHomClass F NNRat α\nf : F\nq : NNRat\n⊢ Eq (f q) ↑q","decl":"@[simp]\nlemma eq_nnratCast [DivisionSemiring α] [FunLike F ℚ≥0 α] [RingHomClass F ℚ≥0 α] (f : F) (q : ℚ≥0) :\n    f q = q := by rw [← map_nnratCast f, NNRat.cast_id]\n\n"}
{"name":"map_ratCast","module":"Mathlib.Data.Rat.Cast.Defs","initialProofState":"F : Type u_1\nα : Type u_3\nβ : Type u_4\ninst✝³ : FunLike F α β\ninst✝² : DivisionRing α\ninst✝¹ : DivisionRing β\ninst✝ : RingHomClass F α β\nf : F\nq : Rat\n⊢ Eq (f ↑q) ↑q","decl":"@[simp]\ntheorem map_ratCast [DivisionRing α] [DivisionRing β] [RingHomClass F α β] (f : F) (q : ℚ) :\n    f q = q := by rw [cast_def, map_div₀, map_intCast, map_natCast, cast_def]\n\n"}
{"name":"eq_ratCast","module":"Mathlib.Data.Rat.Cast.Defs","initialProofState":"F : Type u_1\nα : Type u_3\ninst✝² : DivisionRing α\ninst✝¹ : FunLike F Rat α\ninst✝ : RingHomClass F Rat α\nf : F\nq : Rat\n⊢ Eq (f q) ↑q","decl":"@[simp] lemma eq_ratCast [DivisionRing α] [FunLike F ℚ α] [RingHomClass F ℚ α] (f : F) (q : ℚ) :\n    f q = q := by rw [← map_ratCast f, Rat.cast_id]\n\n"}
{"name":"MonoidWithZeroHomClass.ext_nnrat'","module":"Mathlib.Data.Rat.Cast.Defs","initialProofState":"F : Type u_1\nM₀ : Type u_5\ninst✝² : MonoidWithZero M₀\ninst✝¹ : FunLike F NNRat M₀\ninst✝ : MonoidWithZeroHomClass F NNRat M₀\nf g : F\nh : ∀ (n : Nat), Eq (f ↑n) (g ↑n)\n⊢ Eq f g","decl":"/-- If monoid with zero homs `f` and `g` from `ℚ≥0` agree on the naturals then they are equal. -/\nlemma ext_nnrat' (h : ∀ n : ℕ, f n = g n) : f = g :=\n  (DFunLike.ext f g) fun r => by\n    rw [← r.num_div_den, div_eq_mul_inv, map_mul, map_mul, h, eq_on_inv₀ f g]\n    apply h\n\n"}
{"name":"MonoidWithZeroHomClass.ext_nnrat_iff","module":"Mathlib.Data.Rat.Cast.Defs","initialProofState":"M₀ : Type u_5\ninst✝ : MonoidWithZero M₀\nf g : MonoidWithZeroHom NNRat M₀\n⊢ Iff (Eq f g) (Eq (f.comp ↑(Nat.castRingHom NNRat)) (g.comp ↑(Nat.castRingHom NNRat)))","decl":"/-- If monoid with zero homs `f` and `g` from `ℚ≥0` agree on the naturals then they are equal.\n\nSee note [partially-applied ext lemmas] for why `comp` is used here. -/\n@[ext]\nlemma ext_nnrat {f g : ℚ≥0 →*₀ M₀}\n    (h : f.comp (Nat.castRingHom ℚ≥0 : ℕ →*₀ ℚ≥0) = g.comp (Nat.castRingHom ℚ≥0)) : f = g :=\n  ext_nnrat' <| DFunLike.congr_fun h\n\n"}
{"name":"MonoidWithZeroHomClass.ext_nnrat","module":"Mathlib.Data.Rat.Cast.Defs","initialProofState":"M₀ : Type u_5\ninst✝ : MonoidWithZero M₀\nf g : MonoidWithZeroHom NNRat M₀\nh : Eq (f.comp ↑(Nat.castRingHom NNRat)) (g.comp ↑(Nat.castRingHom NNRat))\n⊢ Eq f g","decl":"/-- If monoid with zero homs `f` and `g` from `ℚ≥0` agree on the naturals then they are equal.\n\nSee note [partially-applied ext lemmas] for why `comp` is used here. -/\n@[ext]\nlemma ext_nnrat {f g : ℚ≥0 →*₀ M₀}\n    (h : f.comp (Nat.castRingHom ℚ≥0 : ℕ →*₀ ℚ≥0) = g.comp (Nat.castRingHom ℚ≥0)) : f = g :=\n  ext_nnrat' <| DFunLike.congr_fun h\n\n"}
{"name":"MonoidWithZeroHomClass.ext_nnrat_on_pnat","module":"Mathlib.Data.Rat.Cast.Defs","initialProofState":"F : Type u_1\nM₀ : Type u_5\ninst✝² : MonoidWithZero M₀\ninst✝¹ : FunLike F NNRat M₀\ninst✝ : MonoidWithZeroHomClass F NNRat M₀\nf g : F\nsame_on_pnat : ∀ (n : Nat), LT.lt 0 n → Eq (f ↑n) (g ↑n)\n⊢ Eq f g","decl":"/-- If monoid with zero homs `f` and `g` from `ℚ≥0` agree on the positive naturals then they are\nequal. -/\nlemma ext_nnrat_on_pnat (same_on_pnat : ∀ n : ℕ, 0 < n → f n = g n) : f = g :=\n  ext_nnrat' <| DFunLike.congr_fun <| ext_nat''\n    ((f : ℚ≥0 →*₀ M₀).comp (Nat.castRingHom ℚ≥0 : ℕ →*₀ ℚ≥0))\n    ((g : ℚ≥0 →*₀ M₀).comp (Nat.castRingHom ℚ≥0 : ℕ →*₀ ℚ≥0)) (by simpa)\n\n"}
{"name":"MonoidWithZeroHomClass.ext_rat'","module":"Mathlib.Data.Rat.Cast.Defs","initialProofState":"F : Type u_1\nM₀ : Type u_5\ninst✝² : MonoidWithZero M₀\ninst✝¹ : FunLike F Rat M₀\ninst✝ : MonoidWithZeroHomClass F Rat M₀\nf g : F\nh : ∀ (m : Int), Eq (f ↑m) (g ↑m)\n⊢ Eq f g","decl":"/-- If monoid with zero homs `f` and `g` from `ℚ` agree on the integers then they are equal. -/\ntheorem ext_rat' (h : ∀ m : ℤ, f m = g m) : f = g :=\n  (DFunLike.ext f g) fun r => by\n    rw [← r.num_div_den, div_eq_mul_inv, map_mul, map_mul, h, ← Int.cast_natCast,\n      eq_on_inv₀ f g]\n    apply h\n\n"}
{"name":"MonoidWithZeroHomClass.ext_rat","module":"Mathlib.Data.Rat.Cast.Defs","initialProofState":"M₀ : Type u_5\ninst✝ : MonoidWithZero M₀\nf g : MonoidWithZeroHom Rat M₀\nh : Eq (f.comp ↑(Int.castRingHom Rat)) (g.comp ↑(Int.castRingHom Rat))\n⊢ Eq f g","decl":"/-- If monoid with zero homs `f` and `g` from `ℚ` agree on the integers then they are equal.\n\nSee note [partially-applied ext lemmas] for why `comp` is used here. -/\n@[ext]\ntheorem ext_rat {f g : ℚ →*₀ M₀}\n    (h : f.comp (Int.castRingHom ℚ : ℤ →*₀ ℚ) = g.comp (Int.castRingHom ℚ)) : f = g :=\n  ext_rat' <| DFunLike.congr_fun h\n\n"}
{"name":"MonoidWithZeroHomClass.ext_rat_iff","module":"Mathlib.Data.Rat.Cast.Defs","initialProofState":"M₀ : Type u_5\ninst✝ : MonoidWithZero M₀\nf g : MonoidWithZeroHom Rat M₀\n⊢ Iff (Eq f g) (Eq (f.comp ↑(Int.castRingHom Rat)) (g.comp ↑(Int.castRingHom Rat)))","decl":"/-- If monoid with zero homs `f` and `g` from `ℚ` agree on the integers then they are equal.\n\nSee note [partially-applied ext lemmas] for why `comp` is used here. -/\n@[ext]\ntheorem ext_rat {f g : ℚ →*₀ M₀}\n    (h : f.comp (Int.castRingHom ℚ : ℤ →*₀ ℚ) = g.comp (Int.castRingHom ℚ)) : f = g :=\n  ext_rat' <| DFunLike.congr_fun h\n\n"}
{"name":"MonoidWithZeroHomClass.ext_rat_on_pnat","module":"Mathlib.Data.Rat.Cast.Defs","initialProofState":"F : Type u_1\nM₀ : Type u_5\ninst✝² : MonoidWithZero M₀\ninst✝¹ : FunLike F Rat M₀\ninst✝ : MonoidWithZeroHomClass F Rat M₀\nf g : F\nsame_on_neg_one : Eq (f (-1)) (g (-1))\nsame_on_pnat : ∀ (n : Nat), LT.lt 0 n → Eq (f ↑n) (g ↑n)\n⊢ Eq f g","decl":"/-- If monoid with zero homs `f` and `g` from `ℚ` agree on the positive naturals and `-1` then\nthey are equal. -/\ntheorem ext_rat_on_pnat (same_on_neg_one : f (-1) = g (-1))\n    (same_on_pnat : ∀ n : ℕ, 0 < n → f n = g n) : f = g :=\n  ext_rat' <|\n    DFunLike.congr_fun <|\n      show\n        (f : ℚ →*₀ M₀).comp (Int.castRingHom ℚ : ℤ →*₀ ℚ) =\n          (g : ℚ →*₀ M₀).comp (Int.castRingHom ℚ : ℤ →*₀ ℚ)\n        from ext_int' (by simpa) (by simpa)\n\n"}
{"name":"RingHom.ext_rat","module":"Mathlib.Data.Rat.Cast.Defs","initialProofState":"F : Type u_1\nR : Type u_5\ninst✝² : Semiring R\ninst✝¹ : FunLike F Rat R\ninst✝ : RingHomClass F Rat R\nf g : F\n⊢ Eq f g","decl":"/-- Any two ring homomorphisms from `ℚ` to a semiring are equal. If the codomain is a division ring,\nthen this lemma follows from `eq_ratCast`. -/\ntheorem RingHom.ext_rat {R : Type*} [Semiring R] [FunLike F ℚ R] [RingHomClass F ℚ R] (f g : F) :\n    f = g :=\n  MonoidWithZeroHomClass.ext_rat' <|\n    RingHom.congr_fun <|\n      ((f : ℚ →+* R).comp (Int.castRingHom ℚ)).ext_int ((g : ℚ →+* R).comp (Int.castRingHom ℚ))\n\n"}
{"name":"NNRat.subsingleton_ringHom","module":"Mathlib.Data.Rat.Cast.Defs","initialProofState":"R : Type u_5\ninst✝ : Semiring R\n⊢ Subsingleton (RingHom NNRat R)","decl":"instance NNRat.subsingleton_ringHom {R : Type*} [Semiring R] : Subsingleton (ℚ≥0 →+* R) where\n  allEq f g := MonoidWithZeroHomClass.ext_nnrat' <| by simp\n\n"}
{"name":"Rat.subsingleton_ringHom","module":"Mathlib.Data.Rat.Cast.Defs","initialProofState":"R : Type u_5\ninst✝ : Semiring R\n⊢ Subsingleton (RingHom Rat R)","decl":"instance Rat.subsingleton_ringHom {R : Type*} [Semiring R] : Subsingleton (ℚ →+* R) :=\n  ⟨RingHom.ext_rat⟩\n\n"}
{"name":"NNRat.instIsScalarTowerRight","module":"Mathlib.Data.Rat.Cast.Defs","initialProofState":"α : Type u_3\ninst✝ : DivisionSemiring α\n⊢ IsScalarTower NNRat α α","decl":"instance instIsScalarTowerRight : IsScalarTower ℚ≥0 α α where\n  smul_assoc a x y := by simp only [smul_def, smul_eq_mul, mul_assoc]\n\n"}
{"name":"Rat.instIsScalarTowerRight","module":"Mathlib.Data.Rat.Cast.Defs","initialProofState":"α : Type u_3\ninst✝ : DivisionRing α\n⊢ IsScalarTower Rat α α","decl":"instance instIsScalarTowerRight : IsScalarTower ℚ α α where\n  smul_assoc a x y := by simp only [smul_def, smul_eq_mul, mul_assoc]\n\n"}
