{"name":"Subalgebra.rank_sup_eq_rank_left_mul_rank_of_free","module":"Mathlib.Algebra.Algebra.Subalgebra.Rank","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : Algebra R S\nA B : Subalgebra R S\ninst✝¹ : Module.Free R (Subtype fun x => Membership.mem A x)\ninst✝ : Module.Free (Subtype fun x => Membership.mem A x) (Subtype fun x => Membership.mem (Algebra.adjoin (Subtype fun x => Membership.mem A x) ↑B) x)\n⊢ Eq (Module.rank R (Subtype fun x => Membership.mem (Max.max A B) x)) (HMul.hMul (Module.rank R (Subtype fun x => Membership.mem A x)) (Module.rank (Subtype fun x => Membership.mem A x) (Subtype fun x => Membership.mem (Algebra.adjoin (Subtype fun x => Membership.mem A x) ↑B) x)))","decl":"theorem rank_sup_eq_rank_left_mul_rank_of_free :\n    Module.rank R ↥(A ⊔ B) = Module.rank R A * Module.rank A (Algebra.adjoin A (B : Set S)) := by\n  rcases subsingleton_or_nontrivial R with _ | _\n  · haveI := Module.subsingleton R S; simp\n  nontriviality S using rank_subsingleton'\n  letI : Algebra A (Algebra.adjoin A (B : Set S)) := Subalgebra.algebra _\n  letI : SMul A (Algebra.adjoin A (B : Set S)) := Algebra.toSMul\n  haveI : IsScalarTower R A (Algebra.adjoin A (B : Set S)) :=\n    IsScalarTower.of_algebraMap_eq (congrFun rfl)\n  rw [rank_mul_rank R A (Algebra.adjoin A (B : Set S))]\n  change _ = Module.rank R ((Algebra.adjoin A (B : Set S)).restrictScalars R)\n  rw [Algebra.restrictScalars_adjoin]; rfl\n\n"}
{"name":"Subalgebra.finrank_sup_eq_finrank_left_mul_finrank_of_free","module":"Mathlib.Algebra.Algebra.Subalgebra.Rank","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : Algebra R S\nA B : Subalgebra R S\ninst✝¹ : Module.Free R (Subtype fun x => Membership.mem A x)\ninst✝ : Module.Free (Subtype fun x => Membership.mem A x) (Subtype fun x => Membership.mem (Algebra.adjoin (Subtype fun x => Membership.mem A x) ↑B) x)\n⊢ Eq (Module.finrank R (Subtype fun x => Membership.mem (Max.max A B) x)) (HMul.hMul (Module.finrank R (Subtype fun x => Membership.mem A x)) (Module.finrank (Subtype fun x => Membership.mem A x) (Subtype fun x => Membership.mem (Algebra.adjoin (Subtype fun x => Membership.mem A x) ↑B) x)))","decl":"theorem finrank_sup_eq_finrank_left_mul_finrank_of_free :\n    finrank R ↥(A ⊔ B) = finrank R A * finrank A (Algebra.adjoin A (B : Set S)) := by\n  simpa only [map_mul] using congr(Cardinal.toNat $(rank_sup_eq_rank_left_mul_rank_of_free A B))\n\n"}
{"name":"Subalgebra.finrank_left_dvd_finrank_sup_of_free","module":"Mathlib.Algebra.Algebra.Subalgebra.Rank","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : Algebra R S\nA B : Subalgebra R S\ninst✝¹ : Module.Free R (Subtype fun x => Membership.mem A x)\ninst✝ : Module.Free (Subtype fun x => Membership.mem A x) (Subtype fun x => Membership.mem (Algebra.adjoin (Subtype fun x => Membership.mem A x) ↑B) x)\n⊢ Dvd.dvd (Module.finrank R (Subtype fun x => Membership.mem A x)) (Module.finrank R (Subtype fun x => Membership.mem (Max.max A B) x))","decl":"theorem finrank_left_dvd_finrank_sup_of_free :\n    finrank R A ∣ finrank R ↥(A ⊔ B) := ⟨_, finrank_sup_eq_finrank_left_mul_finrank_of_free A B⟩\n\n"}
{"name":"Subalgebra.rank_sup_eq_rank_right_mul_rank_of_free","module":"Mathlib.Algebra.Algebra.Subalgebra.Rank","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : Algebra R S\nA B : Subalgebra R S\ninst✝¹ : Module.Free R (Subtype fun x => Membership.mem B x)\ninst✝ : Module.Free (Subtype fun x => Membership.mem B x) (Subtype fun x => Membership.mem (Algebra.adjoin (Subtype fun x => Membership.mem B x) ↑A) x)\n⊢ Eq (Module.rank R (Subtype fun x => Membership.mem (Max.max A B) x)) (HMul.hMul (Module.rank R (Subtype fun x => Membership.mem B x)) (Module.rank (Subtype fun x => Membership.mem B x) (Subtype fun x => Membership.mem (Algebra.adjoin (Subtype fun x => Membership.mem B x) ↑A) x)))","decl":"theorem rank_sup_eq_rank_right_mul_rank_of_free :\n    Module.rank R ↥(A ⊔ B) = Module.rank R B * Module.rank B (Algebra.adjoin B (A : Set S)) := by\n  rw [sup_comm, rank_sup_eq_rank_left_mul_rank_of_free]\n\n"}
{"name":"Subalgebra.finrank_sup_eq_finrank_right_mul_finrank_of_free","module":"Mathlib.Algebra.Algebra.Subalgebra.Rank","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : Algebra R S\nA B : Subalgebra R S\ninst✝¹ : Module.Free R (Subtype fun x => Membership.mem B x)\ninst✝ : Module.Free (Subtype fun x => Membership.mem B x) (Subtype fun x => Membership.mem (Algebra.adjoin (Subtype fun x => Membership.mem B x) ↑A) x)\n⊢ Eq (Module.finrank R (Subtype fun x => Membership.mem (Max.max A B) x)) (HMul.hMul (Module.finrank R (Subtype fun x => Membership.mem B x)) (Module.finrank (Subtype fun x => Membership.mem B x) (Subtype fun x => Membership.mem (Algebra.adjoin (Subtype fun x => Membership.mem B x) ↑A) x)))","decl":"theorem finrank_sup_eq_finrank_right_mul_finrank_of_free :\n    finrank R ↥(A ⊔ B) = finrank R B * finrank B (Algebra.adjoin B (A : Set S)) := by\n  rw [sup_comm, finrank_sup_eq_finrank_left_mul_finrank_of_free]\n\n"}
{"name":"Subalgebra.finrank_right_dvd_finrank_sup_of_free","module":"Mathlib.Algebra.Algebra.Subalgebra.Rank","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : Algebra R S\nA B : Subalgebra R S\ninst✝¹ : Module.Free R (Subtype fun x => Membership.mem B x)\ninst✝ : Module.Free (Subtype fun x => Membership.mem B x) (Subtype fun x => Membership.mem (Algebra.adjoin (Subtype fun x => Membership.mem B x) ↑A) x)\n⊢ Dvd.dvd (Module.finrank R (Subtype fun x => Membership.mem B x)) (Module.finrank R (Subtype fun x => Membership.mem (Max.max A B) x))","decl":"theorem finrank_right_dvd_finrank_sup_of_free :\n    finrank R B ∣ finrank R ↥(A ⊔ B) := ⟨_, finrank_sup_eq_finrank_right_mul_finrank_of_free A B⟩\n\n"}
