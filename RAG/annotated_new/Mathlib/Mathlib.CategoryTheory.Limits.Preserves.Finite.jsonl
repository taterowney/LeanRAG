{"name":"CategoryTheory.Limits.PreservesFiniteLimits.preservesFiniteLimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Finite","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nself : CategoryTheory.Limits.PreservesFiniteLimits F\nJ : Type\ninst✝¹ : CategoryTheory.SmallCategory J\ninst✝ : CategoryTheory.FinCategory J\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape J F","decl":"/-- A functor is said to preserve finite limits, if it preserves all limits of shape `J`,\nwhere `J : Type` is a finite category.\n-/\nclass PreservesFiniteLimits (F : C ⥤ D) : Prop where\n  preservesFiniteLimits :\n    ∀ (J : Type) [SmallCategory J] [FinCategory J], PreservesLimitsOfShape J F := by infer_instance\n\n"}
{"name":"CategoryTheory.Limits.instSubsingletonPreservesFiniteLimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Finite","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\n⊢ Subsingleton (CategoryTheory.Limits.PreservesFiniteLimits F)","decl":"instance (F : C ⥤ D) : Subsingleton (PreservesFiniteLimits F) :=\n  ⟨fun ⟨a⟩ ⟨b⟩ => by congr⟩\n\n"}
{"name":"CategoryTheory.Limits.preservesLimitsOfShapeOfPreservesFiniteLimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Finite","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝² : CategoryTheory.Limits.PreservesFiniteLimits F\nJ : Type w\ninst✝¹ : CategoryTheory.SmallCategory J\ninst✝ : CategoryTheory.FinCategory J\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape J F","decl":"/-- Preserving finite limits also implies preserving limits over finite shapes in higher universes,\nthough through a noncomputable instance. -/\ninstance (priority := 100) preservesLimitsOfShapeOfPreservesFiniteLimits (F : C ⥤ D)\n    [PreservesFiniteLimits F] (J : Type w) [SmallCategory J] [FinCategory J] :\n    PreservesLimitsOfShape J F := by\n  apply preservesLimitsOfShape_of_equiv (FinCategory.equivAsType J)\n\n-- This is a dangerous instance as it has unbound universe variables.\n"}
{"name":"CategoryTheory.Limits.PreservesLimitsOfSize.preservesFiniteLimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Finite","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.PreservesLimitsOfSize.{w, w₂, v₁, v₂, u₁, u₂} F\n⊢ CategoryTheory.Limits.PreservesFiniteLimits F","decl":"/-- If we preserve limits of some arbitrary size, then we preserve all finite limits. -/\nlemma PreservesLimitsOfSize.preservesFiniteLimits (F : C ⥤ D)\n    [PreservesLimitsOfSize.{w, w₂} F] : PreservesFiniteLimits F where\n  preservesFiniteLimits J (sJ : SmallCategory J) fJ := by\n    haveI := preservesSmallestLimits_of_preservesLimits F\n    exact preservesLimitsOfShape_of_equiv (FinCategory.equivAsType J) F\n\n-- Added as a specialization of the dangerous instance above, for limits indexed in Type 0.\n"}
{"name":"CategoryTheory.Limits.PreservesLimitsOfSize0.preservesFiniteLimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Finite","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.PreservesLimitsOfSize.{0, 0, v₁, v₂, u₁, u₂} F\n⊢ CategoryTheory.Limits.PreservesFiniteLimits F","decl":"instance (priority := 120) PreservesLimitsOfSize0.preservesFiniteLimits\n    (F : C ⥤ D) [PreservesLimitsOfSize.{0, 0} F] : PreservesFiniteLimits F :=\n  PreservesLimitsOfSize.preservesFiniteLimits F\n\n-- An alternative specialization of the dangerous instance for small limits.\n"}
{"name":"CategoryTheory.Limits.PreservesLimits.preservesFiniteLimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Finite","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.PreservesLimits F\n⊢ CategoryTheory.Limits.PreservesFiniteLimits F","decl":"instance (priority := 120) PreservesLimits.preservesFiniteLimits (F : C ⥤ D)\n    [PreservesLimits F] : PreservesFiniteLimits F :=\n  PreservesLimitsOfSize.preservesFiniteLimits F\n\n"}
{"name":"CategoryTheory.Limits.preservesFiniteLimits_of_preservesFiniteLimitsOfSize","module":"Mathlib.CategoryTheory.Limits.Preserves.Finite","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nh : ∀ (J : Type w) {𝒥 : CategoryTheory.SmallCategory J}, CategoryTheory.FinCategory J → CategoryTheory.Limits.PreservesLimitsOfShape J F\n⊢ CategoryTheory.Limits.PreservesFiniteLimits F","decl":"/-- We can always derive `PreservesFiniteLimits C` by showing that we are preserving limits at an\narbitrary universe. -/\nlemma preservesFiniteLimits_of_preservesFiniteLimitsOfSize (F : C ⥤ D)\n    (h :\n      ∀ (J : Type w) {𝒥 : SmallCategory J} (_ : @FinCategory J 𝒥), PreservesLimitsOfShape J F) :\n    PreservesFiniteLimits F where\n      preservesFiniteLimits J (_ : SmallCategory J) _ := by\n        haveI := h (ULiftHom (ULift J)) CategoryTheory.finCategoryUlift\n        exact preservesLimitsOfShape_of_equiv (ULiftHomULiftCategory.equiv J).symm F\n\n"}
{"name":"CategoryTheory.Limits.comp_preservesFiniteLimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Finite","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst✝¹ : CategoryTheory.Limits.PreservesFiniteLimits F\ninst✝ : CategoryTheory.Limits.PreservesFiniteLimits G\n⊢ CategoryTheory.Limits.PreservesFiniteLimits (F.comp G)","decl":"/-- The composition of two left exact functors is left exact. -/\nlemma comp_preservesFiniteLimits (F : C ⥤ D) (G : D ⥤ E) [PreservesFiniteLimits F]\n    [PreservesFiniteLimits G] : PreservesFiniteLimits (F ⋙ G) :=\n  ⟨fun _ _ _ => inferInstance⟩\n\n"}
{"name":"CategoryTheory.Limits.preservesFiniteLimits_of_natIso","module":"Mathlib.CategoryTheory.Limits.Preserves.Finite","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF G : CategoryTheory.Functor C D\nh : CategoryTheory.Iso F G\ninst✝ : CategoryTheory.Limits.PreservesFiniteLimits F\n⊢ CategoryTheory.Limits.PreservesFiniteLimits G","decl":"/-- Transfer preservation of finite limits along a natural isomorphism in the functor. -/\nlemma preservesFiniteLimits_of_natIso {F G : C ⥤ D} (h : F ≅ G) [PreservesFiniteLimits F] :\n    PreservesFiniteLimits G where\n  preservesFiniteLimits _ _ _ := preservesLimitsOfShape_of_natIso h\n\n/- Porting note: adding this class because quantified classes don't behave well\nhttps://github.com/leanprover-community/mathlib4/pull/2764 -/\n"}
{"name":"CategoryTheory.Limits.PreservesFiniteProducts.preserves","module":"Mathlib.CategoryTheory.Limits.Preserves.Finite","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nself : CategoryTheory.Limits.PreservesFiniteProducts F\nJ : Type\ninst✝ : Fintype J\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete J) F","decl":"/-- A functor `F` preserves finite products if it preserves all from `Discrete J`\nfor `Fintype J` -/\nclass PreservesFiniteProducts (F : C ⥤ D) : Prop where\n  preserves : ∀ (J : Type) [Fintype J], PreservesLimitsOfShape (Discrete J) F\n\n"}
{"name":"CategoryTheory.Limits.instSubsingletonPreservesFiniteProducts","module":"Mathlib.CategoryTheory.Limits.Preserves.Finite","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\n⊢ Subsingleton (CategoryTheory.Limits.PreservesFiniteProducts F)","decl":"instance (F : C ⥤ D) : Subsingleton (PreservesFiniteProducts F) :=\n  ⟨fun ⟨a⟩ ⟨b⟩ => by congr⟩\n\n"}
{"name":"CategoryTheory.Limits.instPreservesLimitsOfShapeDiscreteOfFiniteOfPreservesFiniteProducts","module":"Mathlib.CategoryTheory.Limits.Preserves.Finite","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nJ : Type u\ninst✝¹ : Finite J\ninst✝ : CategoryTheory.Limits.PreservesFiniteProducts F\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete J) F","decl":"instance (priority := 100) (F : C ⥤ D) (J : Type u) [Finite J]\n    [PreservesFiniteProducts F] : PreservesLimitsOfShape (Discrete J) F := by\n  apply Nonempty.some\n  obtain ⟨n, ⟨e⟩⟩ := Finite.exists_equiv_fin J\n  exact ⟨preservesLimitsOfShape_of_equiv (Discrete.equivalence e.symm) F⟩\n\n"}
{"name":"CategoryTheory.Limits.comp_preservesFiniteProducts","module":"Mathlib.CategoryTheory.Limits.Preserves.Finite","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst✝¹ : CategoryTheory.Limits.PreservesFiniteProducts F\ninst✝ : CategoryTheory.Limits.PreservesFiniteProducts G\n⊢ CategoryTheory.Limits.PreservesFiniteProducts (F.comp G)","decl":"instance comp_preservesFiniteProducts (F : C ⥤ D) (G : D ⥤ E)\n    [PreservesFiniteProducts F] [PreservesFiniteProducts G] :\n    PreservesFiniteProducts (F ⋙ G) where\n  preserves _ _ := inferInstance\n\n"}
{"name":"CategoryTheory.Limits.instPreservesFiniteProductsOfPreservesFiniteLimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Finite","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.PreservesFiniteLimits F\n⊢ CategoryTheory.Limits.PreservesFiniteProducts F","decl":"instance (F : C ⥤ D) [PreservesFiniteLimits F] : PreservesFiniteProducts F where\n  preserves _ _ := inferInstance\n\n"}
{"name":"CategoryTheory.Limits.ReflectsFiniteLimits.reflects","module":"Mathlib.CategoryTheory.Limits.Preserves.Finite","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nself : CategoryTheory.Limits.ReflectsFiniteLimits F\nJ : Type\ninst✝¹ : CategoryTheory.SmallCategory J\ninst✝ : CategoryTheory.FinCategory J\n⊢ CategoryTheory.Limits.ReflectsLimitsOfShape J F","decl":"/--\nA functor is said to reflect finite limits, if it reflects all limits of shape `J`,\nwhere `J : Type` is a finite category.\n-/\nclass ReflectsFiniteLimits (F : C ⥤ D) : Prop where\n  reflects : ∀ (J : Type) [SmallCategory J] [FinCategory J], ReflectsLimitsOfShape J F := by\n    infer_instance\n\n"}
{"name":"CategoryTheory.Limits.instSubsingletonReflectsFiniteLimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Finite","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\n⊢ Subsingleton (CategoryTheory.Limits.ReflectsFiniteLimits F)","decl":"instance (F : C ⥤ D) : Subsingleton (ReflectsFiniteLimits F) :=\n  ⟨fun ⟨a⟩ ⟨b⟩ => by congr⟩\n\n/- Similarly to preserving finite products, quantified classes don't behave well. -/\n"}
{"name":"CategoryTheory.Limits.ReflectsFiniteProducts.reflects","module":"Mathlib.CategoryTheory.Limits.Preserves.Finite","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nself : CategoryTheory.Limits.ReflectsFiniteProducts F\nJ : Type\ninst✝ : Fintype J\n⊢ CategoryTheory.Limits.ReflectsLimitsOfShape (CategoryTheory.Discrete J) F","decl":"/--\nA functor `F` preserves finite products if it reflects limits of shape `Discrete J` for finite `J`\n-/\nclass ReflectsFiniteProducts (F : C ⥤ D) : Prop where\n  reflects : ∀ (J : Type) [Fintype J], ReflectsLimitsOfShape (Discrete J) F\n\n"}
{"name":"CategoryTheory.Limits.instSubsingletonReflectsFiniteProducts","module":"Mathlib.CategoryTheory.Limits.Preserves.Finite","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\n⊢ Subsingleton (CategoryTheory.Limits.ReflectsFiniteProducts F)","decl":"instance (F : C ⥤ D) : Subsingleton (ReflectsFiniteProducts F) :=\n  ⟨fun ⟨a⟩ ⟨b⟩ => by congr⟩\n\n-- This is a dangerous instance as it has unbound universe variables.\n"}
{"name":"CategoryTheory.Limits.ReflectsLimitsOfSize.reflectsFiniteLimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Finite","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.ReflectsLimitsOfSize.{w, w₂, v₁, v₂, u₁, u₂} F\n⊢ CategoryTheory.Limits.ReflectsFiniteLimits F","decl":"/-- If we reflect limits of some arbitrary size, then we reflect all finite limits. -/\nlemma ReflectsLimitsOfSize.reflectsFiniteLimits\n    (F : C ⥤ D) [ReflectsLimitsOfSize.{w, w₂} F] : ReflectsFiniteLimits F where\n  reflects J (sJ : SmallCategory J) fJ := by\n    haveI := reflectsSmallestLimits_of_reflectsLimits F\n    exact reflectsLimitsOfShape_of_equiv (FinCategory.equivAsType J) F\n\n-- Added as a specialization of the dangerous instance above, for colimits indexed in Type 0.\n"}
{"name":"CategoryTheory.Limits.instReflectsFiniteLimitsOfReflectsLimitsOfSize","module":"Mathlib.CategoryTheory.Limits.Preserves.Finite","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.ReflectsLimitsOfSize.{0, 0, v₁, v₂, u₁, u₂} F\n⊢ CategoryTheory.Limits.ReflectsFiniteLimits F","decl":"instance (priority := 120) (F : C ⥤ D) [ReflectsLimitsOfSize.{0, 0} F] :\n    ReflectsFiniteLimits F :=\n  ReflectsLimitsOfSize.reflectsFiniteLimits F\n\n-- An alternative specialization of the dangerous instance for small colimits.\n"}
{"name":"CategoryTheory.Limits.instReflectsFiniteLimitsOfReflectsLimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Finite","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.ReflectsLimits F\n⊢ CategoryTheory.Limits.ReflectsFiniteLimits F","decl":"instance (priority := 120) (F : C ⥤ D)\n    [ReflectsLimits F] : ReflectsFiniteLimits F :=\n  ReflectsLimitsOfSize.reflectsFiniteLimits F\n\n"}
{"name":"CategoryTheory.Limits.preservesFiniteLimits_of_reflects_of_preserves","module":"Mathlib.CategoryTheory.Limits.Preserves.Finite","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst✝¹ : CategoryTheory.Limits.PreservesFiniteLimits (F.comp G)\ninst✝ : CategoryTheory.Limits.ReflectsFiniteLimits G\n⊢ CategoryTheory.Limits.PreservesFiniteLimits F","decl":"/--\nIf `F ⋙ G` preserves finite limits and `G` reflects finite limits, then `F` preserves\nfinite limits.\n-/\nlemma preservesFiniteLimits_of_reflects_of_preserves (F : C ⥤ D) (G : D ⥤ E)\n    [PreservesFiniteLimits (F ⋙ G)] [ReflectsFiniteLimits G] : PreservesFiniteLimits F where\n  preservesFiniteLimits _ _ _ := preservesLimitsOfShape_of_reflects_of_preserves F G\n\n"}
{"name":"CategoryTheory.Limits.preservesFiniteProducts_of_reflects_of_preserves","module":"Mathlib.CategoryTheory.Limits.Preserves.Finite","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst✝¹ : CategoryTheory.Limits.PreservesFiniteProducts (F.comp G)\ninst✝ : CategoryTheory.Limits.ReflectsFiniteProducts G\n⊢ CategoryTheory.Limits.PreservesFiniteProducts F","decl":"/--\nIf `F ⋙ G` preserves finite products and `G` reflects finite products, then `F` preserves\nfinite products.\n-/\nlemma preservesFiniteProducts_of_reflects_of_preserves (F : C ⥤ D) (G : D ⥤ E)\n    [PreservesFiniteProducts (F ⋙ G)] [ReflectsFiniteProducts G] : PreservesFiniteProducts F where\n  preserves _ _ := preservesLimitsOfShape_of_reflects_of_preserves F G\n\n"}
{"name":"CategoryTheory.Limits.reflectsFiniteLimits_of_reflectsIsomorphisms","module":"Mathlib.CategoryTheory.Limits.Preserves.Finite","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝² : F.ReflectsIsomorphisms\ninst✝¹ : CategoryTheory.Limits.HasFiniteLimits C\ninst✝ : CategoryTheory.Limits.PreservesFiniteLimits F\n⊢ CategoryTheory.Limits.ReflectsFiniteLimits F","decl":"instance reflectsFiniteLimits_of_reflectsIsomorphisms (F : C ⥤ D)\n    [F.ReflectsIsomorphisms] [HasFiniteLimits C] [PreservesFiniteLimits F] :\n      ReflectsFiniteLimits F where\n  reflects _ _ _ := reflectsLimitsOfShape_of_reflectsIsomorphisms\n\n"}
{"name":"CategoryTheory.Limits.reflectsFiniteProducts_of_reflectsIsomorphisms","module":"Mathlib.CategoryTheory.Limits.Preserves.Finite","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝² : F.ReflectsIsomorphisms\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : CategoryTheory.Limits.PreservesFiniteProducts F\n⊢ CategoryTheory.Limits.ReflectsFiniteProducts F","decl":"instance reflectsFiniteProducts_of_reflectsIsomorphisms (F : C ⥤ D)\n    [F.ReflectsIsomorphisms] [HasFiniteProducts C] [PreservesFiniteProducts F] :\n      ReflectsFiniteProducts F where\n  reflects _ _ := reflectsLimitsOfShape_of_reflectsIsomorphisms\n\n"}
{"name":"CategoryTheory.Limits.comp_reflectsFiniteProducts","module":"Mathlib.CategoryTheory.Limits.Preserves.Finite","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst✝¹ : CategoryTheory.Limits.ReflectsFiniteProducts F\ninst✝ : CategoryTheory.Limits.ReflectsFiniteProducts G\n⊢ CategoryTheory.Limits.ReflectsFiniteProducts (F.comp G)","decl":"instance comp_reflectsFiniteProducts (F : C ⥤ D) (G : D ⥤ E)\n    [ReflectsFiniteProducts F] [ReflectsFiniteProducts G] :\n    ReflectsFiniteProducts (F ⋙ G) where\n  reflects _ _ := inferInstance\n\n"}
{"name":"CategoryTheory.Limits.instReflectsFiniteProductsOfReflectsFiniteLimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Finite","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.ReflectsFiniteLimits F\n⊢ CategoryTheory.Limits.ReflectsFiniteProducts F","decl":"instance (F : C ⥤ D) [ReflectsFiniteLimits F] : ReflectsFiniteProducts F where\n  reflects _ _ := inferInstance\n\n"}
{"name":"CategoryTheory.Limits.PreservesFiniteColimits.preservesFiniteColimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Finite","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nself : CategoryTheory.Limits.PreservesFiniteColimits F\nJ : Type\ninst✝¹ : CategoryTheory.SmallCategory J\ninst✝ : CategoryTheory.FinCategory J\n⊢ CategoryTheory.Limits.PreservesColimitsOfShape J F","decl":"/-- A functor is said to preserve finite colimits, if it preserves all colimits of\nshape `J`, where `J : Type` is a finite category.\n-/\nclass PreservesFiniteColimits (F : C ⥤ D) : Prop where\n  preservesFiniteColimits :\n    ∀ (J : Type) [SmallCategory J] [FinCategory J], PreservesColimitsOfShape J F := by\n      infer_instance\n\n"}
{"name":"CategoryTheory.Limits.instSubsingletonPreservesFiniteColimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Finite","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\n⊢ Subsingleton (CategoryTheory.Limits.PreservesFiniteColimits F)","decl":"instance (F : C ⥤ D) : Subsingleton (PreservesFiniteColimits F) :=\n  ⟨fun ⟨a⟩ ⟨b⟩ => by congr⟩\n\n"}
{"name":"CategoryTheory.Limits.preservesColimitsOfShapeOfPreservesFiniteColimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Finite","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝² : CategoryTheory.Limits.PreservesFiniteColimits F\nJ : Type w\ninst✝¹ : CategoryTheory.SmallCategory J\ninst✝ : CategoryTheory.FinCategory J\n⊢ CategoryTheory.Limits.PreservesColimitsOfShape J F","decl":"/--\nPreserving finite colimits also implies preserving colimits over finite shapes in higher\nuniverses.\n-/\ninstance (priority := 100) preservesColimitsOfShapeOfPreservesFiniteColimits\n    (F : C ⥤ D) [PreservesFiniteColimits F] (J : Type w) [SmallCategory J] [FinCategory J] :\n    PreservesColimitsOfShape J F := by\n  apply preservesColimitsOfShape_of_equiv (FinCategory.equivAsType J)\n\n-- This is a dangerous instance as it has unbound universe variables.\n"}
{"name":"CategoryTheory.Limits.PreservesColimitsOfSize.preservesFiniteColimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Finite","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.PreservesColimitsOfSize.{w, w₂, v₁, v₂, u₁, u₂} F\n⊢ CategoryTheory.Limits.PreservesFiniteColimits F","decl":"/-- If we preserve colimits of some arbitrary size, then we preserve all finite colimits. -/\nlemma PreservesColimitsOfSize.preservesFiniteColimits (F : C ⥤ D)\n    [PreservesColimitsOfSize.{w, w₂} F] : PreservesFiniteColimits F where\n  preservesFiniteColimits J (sJ : SmallCategory J) fJ := by\n    haveI := preservesSmallestColimits_of_preservesColimits F\n    exact preservesColimitsOfShape_of_equiv (FinCategory.equivAsType J) F\n\n-- Added as a specialization of the dangerous instance above, for colimits indexed in Type 0.\n"}
{"name":"CategoryTheory.Limits.PreservesColimitsOfSize0.preservesFiniteColimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Finite","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₂, u₁, u₂} F\n⊢ CategoryTheory.Limits.PreservesFiniteColimits F","decl":"instance (priority := 120) PreservesColimitsOfSize0.preservesFiniteColimits\n    (F : C ⥤ D) [PreservesColimitsOfSize.{0, 0} F] : PreservesFiniteColimits F :=\n  PreservesColimitsOfSize.preservesFiniteColimits F\n\n-- An alternative specialization of the dangerous instance for small colimits.\n"}
{"name":"CategoryTheory.Limits.PreservesColimits.preservesFiniteColimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Finite","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.PreservesColimits F\n⊢ CategoryTheory.Limits.PreservesFiniteColimits F","decl":"instance (priority := 120) PreservesColimits.preservesFiniteColimits (F : C ⥤ D)\n    [PreservesColimits F] : PreservesFiniteColimits F :=\n  PreservesColimitsOfSize.preservesFiniteColimits F\n\n"}
{"name":"CategoryTheory.Limits.preservesFiniteColimits_of_preservesFiniteColimitsOfSize","module":"Mathlib.CategoryTheory.Limits.Preserves.Finite","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nh : ∀ (J : Type w) {𝒥 : CategoryTheory.SmallCategory J}, CategoryTheory.FinCategory J → CategoryTheory.Limits.PreservesColimitsOfShape J F\n⊢ CategoryTheory.Limits.PreservesFiniteColimits F","decl":"/-- We can always derive `PreservesFiniteColimits C`\nby showing that we are preserving colimits at an arbitrary universe. -/\nlemma preservesFiniteColimits_of_preservesFiniteColimitsOfSize (F : C ⥤ D)\n    (h :\n      ∀ (J : Type w) {𝒥 : SmallCategory J} (_ : @FinCategory J 𝒥), PreservesColimitsOfShape J F) :\n    PreservesFiniteColimits F where\n      preservesFiniteColimits J (_ : SmallCategory J) _ := by\n        letI : Category (ULiftHom (ULift J)) := ULiftHom.category\n        haveI := h (ULiftHom (ULift J)) CategoryTheory.finCategoryUlift\n        exact preservesColimitsOfShape_of_equiv (ULiftHomULiftCategory.equiv J).symm F\n\n"}
{"name":"CategoryTheory.Limits.comp_preservesFiniteColimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Finite","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst✝¹ : CategoryTheory.Limits.PreservesFiniteColimits F\ninst✝ : CategoryTheory.Limits.PreservesFiniteColimits G\n⊢ CategoryTheory.Limits.PreservesFiniteColimits (F.comp G)","decl":"/-- The composition of two right exact functors is right exact. -/\nlemma comp_preservesFiniteColimits (F : C ⥤ D) (G : D ⥤ E) [PreservesFiniteColimits F]\n    [PreservesFiniteColimits G] : PreservesFiniteColimits (F ⋙ G) :=\n  ⟨fun _ _ _ => inferInstance⟩\n\n"}
{"name":"CategoryTheory.Limits.preservesFiniteColimits_of_natIso","module":"Mathlib.CategoryTheory.Limits.Preserves.Finite","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF G : CategoryTheory.Functor C D\nh : CategoryTheory.Iso F G\ninst✝ : CategoryTheory.Limits.PreservesFiniteColimits F\n⊢ CategoryTheory.Limits.PreservesFiniteColimits G","decl":"/-- Transfer preservation of finite colimits along a natural isomorphism in the functor. -/\nlemma preservesFiniteColimits_of_natIso {F G : C ⥤ D} (h : F ≅ G) [PreservesFiniteColimits F] :\n    PreservesFiniteColimits G where\n  preservesFiniteColimits _ _ _ := preservesColimitsOfShape_of_natIso h\n\n/- Porting note: adding this class because quantified classes don't behave well\nhttps://github.com/leanprover-community/mathlib4/pull/2764 -/\n"}
{"name":"CategoryTheory.Limits.PreservesFiniteCoproducts.preserves","module":"Mathlib.CategoryTheory.Limits.Preserves.Finite","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nself : CategoryTheory.Limits.PreservesFiniteCoproducts F\nJ : Type\ninst✝ : Fintype J\n⊢ CategoryTheory.Limits.PreservesColimitsOfShape (CategoryTheory.Discrete J) F","decl":"/-- A functor `F` preserves finite products if it preserves all from `Discrete J`\nfor `Fintype J` -/\nclass PreservesFiniteCoproducts (F : C ⥤ D) : Prop where\n  /-- preservation of colimits indexed by `Discrete J` when `[Fintype J]` -/\n  preserves : ∀ (J : Type) [Fintype J], PreservesColimitsOfShape (Discrete J) F\n\n"}
{"name":"CategoryTheory.Limits.instSubsingletonPreservesFiniteCoproducts","module":"Mathlib.CategoryTheory.Limits.Preserves.Finite","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\n⊢ Subsingleton (CategoryTheory.Limits.PreservesFiniteCoproducts F)","decl":"instance (F : C ⥤ D) : Subsingleton (PreservesFiniteCoproducts F) :=\n  ⟨fun ⟨a⟩ ⟨b⟩ => by congr⟩\n\n"}
{"name":"CategoryTheory.Limits.instPreservesColimitsOfShapeDiscreteOfFiniteOfPreservesFiniteCoproducts","module":"Mathlib.CategoryTheory.Limits.Preserves.Finite","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nJ : Type u\ninst✝¹ : Finite J\ninst✝ : CategoryTheory.Limits.PreservesFiniteCoproducts F\n⊢ CategoryTheory.Limits.PreservesColimitsOfShape (CategoryTheory.Discrete J) F","decl":"instance (priority := 100) (F : C ⥤ D) (J : Type u) [Finite J]\n    [PreservesFiniteCoproducts F] : PreservesColimitsOfShape (Discrete J) F := by\n  apply Nonempty.some\n  obtain ⟨n, ⟨e⟩⟩ := Finite.exists_equiv_fin J\n  exact ⟨preservesColimitsOfShape_of_equiv (Discrete.equivalence e.symm) F⟩\n\n"}
{"name":"CategoryTheory.Limits.comp_preservesFiniteCoproducts","module":"Mathlib.CategoryTheory.Limits.Preserves.Finite","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst✝¹ : CategoryTheory.Limits.PreservesFiniteCoproducts F\ninst✝ : CategoryTheory.Limits.PreservesFiniteCoproducts G\n⊢ CategoryTheory.Limits.PreservesFiniteCoproducts (F.comp G)","decl":"instance comp_preservesFiniteCoproducts (F : C ⥤ D) (G : D ⥤ E)\n    [PreservesFiniteCoproducts F] [PreservesFiniteCoproducts G] :\n    PreservesFiniteCoproducts (F ⋙ G) where\n  preserves _ _ := inferInstance\n\n"}
{"name":"CategoryTheory.Limits.instPreservesFiniteCoproductsOfPreservesFiniteColimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Finite","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.PreservesFiniteColimits F\n⊢ CategoryTheory.Limits.PreservesFiniteCoproducts F","decl":"instance (F : C ⥤ D) [PreservesFiniteColimits F] : PreservesFiniteCoproducts F where\n  preserves _ _ := inferInstance\n\n"}
{"name":"CategoryTheory.Limits.ReflectsFiniteColimits.reflects","module":"Mathlib.CategoryTheory.Limits.Preserves.Finite","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nself : CategoryTheory.Limits.ReflectsFiniteColimits F\nJ : Type\ninst✝¹ : CategoryTheory.SmallCategory J\ninst✝ : CategoryTheory.FinCategory J\n⊢ CategoryTheory.Limits.ReflectsColimitsOfShape J F","decl":"/--\nA functor is said to reflect finite colimits, if it reflects all colimits of shape `J`,\nwhere `J : Type` is a finite category.\n-/\nclass ReflectsFiniteColimits (F : C ⥤ D) : Prop where\n  reflects : ∀ (J : Type) [SmallCategory J] [FinCategory J], ReflectsColimitsOfShape J F := by\n    infer_instance\n\n"}
{"name":"CategoryTheory.Limits.instSubsingletonReflectsFiniteColimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Finite","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\n⊢ Subsingleton (CategoryTheory.Limits.ReflectsFiniteColimits F)","decl":"instance (F : C ⥤ D) : Subsingleton (ReflectsFiniteColimits F) :=\n  ⟨fun ⟨a⟩ ⟨b⟩ => by congr⟩\n\n-- This is a dangerous instance as it has unbound universe variables.\n"}
{"name":"CategoryTheory.Limits.ReflectsColimitsOfSize.reflectsFiniteColimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Finite","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.ReflectsColimitsOfSize.{w, w₂, v₁, v₂, u₁, u₂} F\n⊢ CategoryTheory.Limits.ReflectsFiniteColimits F","decl":"/-- If we reflect colimits of some arbitrary size, then we reflect all finite colimits. -/\nlemma ReflectsColimitsOfSize.reflectsFiniteColimits\n    (F : C ⥤ D) [ReflectsColimitsOfSize.{w, w₂} F] : ReflectsFiniteColimits F where\n  reflects J (sJ : SmallCategory J) fJ := by\n    haveI := reflectsSmallestColimits_of_reflectsColimits F\n    exact reflectsColimitsOfShape_of_equiv (FinCategory.equivAsType J) F\n\n-- Added as a specialization of the dangerous instance above, for colimits indexed in Type 0.\n"}
{"name":"CategoryTheory.Limits.instReflectsFiniteColimitsOfReflectsColimitsOfSize","module":"Mathlib.CategoryTheory.Limits.Preserves.Finite","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.ReflectsColimitsOfSize.{0, 0, v₁, v₂, u₁, u₂} F\n⊢ CategoryTheory.Limits.ReflectsFiniteColimits F","decl":"instance (priority := 120) (F : C ⥤ D) [ReflectsColimitsOfSize.{0, 0} F] :\n    ReflectsFiniteColimits F :=\n  ReflectsColimitsOfSize.reflectsFiniteColimits F\n\n-- An alternative specialization of the dangerous instance for small colimits.\n"}
{"name":"CategoryTheory.Limits.instReflectsFiniteColimitsOfReflectsColimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Finite","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.ReflectsColimits F\n⊢ CategoryTheory.Limits.ReflectsFiniteColimits F","decl":"instance (priority := 120) (F : C ⥤ D)\n    [ReflectsColimits F] : ReflectsFiniteColimits F :=\n  ReflectsColimitsOfSize.reflectsFiniteColimits F\n\n/- Similarly to preserving finite coproducts, quantified classes don't behave well. -/\n"}
{"name":"CategoryTheory.Limits.ReflectsFiniteCoproducts.reflects","module":"Mathlib.CategoryTheory.Limits.Preserves.Finite","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nself : CategoryTheory.Limits.ReflectsFiniteCoproducts F\nJ : Type\ninst✝ : Fintype J\n⊢ CategoryTheory.Limits.ReflectsColimitsOfShape (CategoryTheory.Discrete J) F","decl":"/--\nA functor `F` preserves finite coproducts if it reflects colimits of shape `Discrete J` for\nfinite `J`\n-/\nclass ReflectsFiniteCoproducts (F : C ⥤ D) : Prop where\n  reflects : ∀ (J : Type) [Fintype J], ReflectsColimitsOfShape (Discrete J) F\n\n"}
{"name":"CategoryTheory.Limits.instSubsingletonReflectsFiniteCoproducts","module":"Mathlib.CategoryTheory.Limits.Preserves.Finite","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\n⊢ Subsingleton (CategoryTheory.Limits.ReflectsFiniteCoproducts F)","decl":"instance (F : C ⥤ D) : Subsingleton (ReflectsFiniteCoproducts F) :=\n  ⟨fun ⟨a⟩ ⟨b⟩ => by congr⟩\n\n"}
{"name":"CategoryTheory.Limits.preservesFiniteColimits_of_reflects_of_preserves","module":"Mathlib.CategoryTheory.Limits.Preserves.Finite","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst✝¹ : CategoryTheory.Limits.PreservesFiniteColimits (F.comp G)\ninst✝ : CategoryTheory.Limits.ReflectsFiniteColimits G\n⊢ CategoryTheory.Limits.PreservesFiniteColimits F","decl":"/--\nIf `F ⋙ G` preserves finite colimits and `G` reflects finite colimits, then `F` preserves finite\ncolimits.\n-/\nlemma preservesFiniteColimits_of_reflects_of_preserves (F : C ⥤ D) (G : D ⥤ E)\n    [PreservesFiniteColimits (F ⋙ G)] [ReflectsFiniteColimits G] : PreservesFiniteColimits F where\n  preservesFiniteColimits _ _ _ := preservesColimitsOfShape_of_reflects_of_preserves F G\n\n"}
{"name":"CategoryTheory.Limits.preservesFiniteCoproducts_of_reflects_of_preserves","module":"Mathlib.CategoryTheory.Limits.Preserves.Finite","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst✝¹ : CategoryTheory.Limits.PreservesFiniteCoproducts (F.comp G)\ninst✝ : CategoryTheory.Limits.ReflectsFiniteCoproducts G\n⊢ CategoryTheory.Limits.PreservesFiniteCoproducts F","decl":"/--\nIf `F ⋙ G` preserves finite coproducts and `G` reflects finite coproducts, then `F` preserves\nfinite coproducts.\n-/\nlemma preservesFiniteCoproducts_of_reflects_of_preserves (F : C ⥤ D) (G : D ⥤ E)\n    [PreservesFiniteCoproducts (F ⋙ G)] [ReflectsFiniteCoproducts G] :\n    PreservesFiniteCoproducts F where\n  preserves _ _ := preservesColimitsOfShape_of_reflects_of_preserves F G\n\n"}
{"name":"CategoryTheory.Limits.reflectsFiniteColimitsOfReflectsIsomorphisms","module":"Mathlib.CategoryTheory.Limits.Preserves.Finite","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝² : F.ReflectsIsomorphisms\ninst✝¹ : CategoryTheory.Limits.HasFiniteColimits C\ninst✝ : CategoryTheory.Limits.PreservesFiniteColimits F\n⊢ CategoryTheory.Limits.ReflectsFiniteColimits F","decl":"instance reflectsFiniteColimitsOfReflectsIsomorphisms (F : C ⥤ D)\n    [F.ReflectsIsomorphisms] [HasFiniteColimits C] [PreservesFiniteColimits F] :\n      ReflectsFiniteColimits F where\n  reflects _ _ _ := reflectsColimitsOfShape_of_reflectsIsomorphisms\n\n"}
{"name":"CategoryTheory.Limits.reflectsFiniteCoproductsOfReflectsIsomorphisms","module":"Mathlib.CategoryTheory.Limits.Preserves.Finite","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝² : F.ReflectsIsomorphisms\ninst✝¹ : CategoryTheory.Limits.HasFiniteCoproducts C\ninst✝ : CategoryTheory.Limits.PreservesFiniteCoproducts F\n⊢ CategoryTheory.Limits.ReflectsFiniteCoproducts F","decl":"instance reflectsFiniteCoproductsOfReflectsIsomorphisms (F : C ⥤ D)\n    [F.ReflectsIsomorphisms] [HasFiniteCoproducts C] [PreservesFiniteCoproducts F] :\n      ReflectsFiniteCoproducts F where\n  reflects _ _ := reflectsColimitsOfShape_of_reflectsIsomorphisms\n\n"}
{"name":"CategoryTheory.Limits.comp_reflectsFiniteCoproducts","module":"Mathlib.CategoryTheory.Limits.Preserves.Finite","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst✝¹ : CategoryTheory.Limits.ReflectsFiniteCoproducts F\ninst✝ : CategoryTheory.Limits.ReflectsFiniteCoproducts G\n⊢ CategoryTheory.Limits.ReflectsFiniteCoproducts (F.comp G)","decl":"instance comp_reflectsFiniteCoproducts (F : C ⥤ D) (G : D ⥤ E)\n    [ReflectsFiniteCoproducts F] [ReflectsFiniteCoproducts G] :\n    ReflectsFiniteCoproducts (F ⋙ G) where\n  reflects _ _ := inferInstance\n\n"}
{"name":"CategoryTheory.Limits.instReflectsFiniteCoproductsOfReflectsFiniteColimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Finite","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.ReflectsFiniteColimits F\n⊢ CategoryTheory.Limits.ReflectsFiniteCoproducts F","decl":"instance (F : C ⥤ D) [ReflectsFiniteColimits F] : ReflectsFiniteCoproducts F where\n  reflects _ _ := inferInstance\n\n"}
