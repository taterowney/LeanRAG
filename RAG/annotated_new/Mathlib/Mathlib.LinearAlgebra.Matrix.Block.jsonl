{"name":"Matrix.BlockTriangular.submatrix","module":"Mathlib.LinearAlgebra.Matrix.Block","initialProofState":"α : Type u_1\nm : Type u_3\nn : Type u_4\nR : Type v\nM : Matrix m m R\nb : m → α\ninst✝¹ : LT α\ninst✝ : Zero R\nf : n → m\nh : M.BlockTriangular b\n⊢ (M.submatrix f f).BlockTriangular (Function.comp b f)","decl":"@[simp]\nprotected theorem BlockTriangular.submatrix {f : n → m} (h : M.BlockTriangular b) :\n    (M.submatrix f f).BlockTriangular (b ∘ f) := fun _ _ hij => h hij\n\n"}
{"name":"Matrix.blockTriangular_reindex_iff","module":"Mathlib.LinearAlgebra.Matrix.Block","initialProofState":"α : Type u_1\nm : Type u_3\nn : Type u_4\nR : Type v\nM : Matrix m m R\ninst✝¹ : LT α\ninst✝ : Zero R\nb : n → α\ne : Equiv m n\n⊢ Iff (((Matrix.reindex e e) M).BlockTriangular b) (M.BlockTriangular (Function.comp b ⇑e))","decl":"theorem blockTriangular_reindex_iff {b : n → α} {e : m ≃ n} :\n    (reindex e e M).BlockTriangular b ↔ M.BlockTriangular (b ∘ e) := by\n  refine ⟨fun h => ?_, fun h => ?_⟩\n  · convert h.submatrix\n    simp only [reindex_apply, submatrix_submatrix, submatrix_id_id, Equiv.symm_comp_self]\n  · convert h.submatrix\n    simp only [comp_assoc b e e.symm, Equiv.self_comp_symm, comp_id]\n\n"}
{"name":"Matrix.BlockTriangular.transpose","module":"Mathlib.LinearAlgebra.Matrix.Block","initialProofState":"α : Type u_1\nm : Type u_3\nR : Type v\nM : Matrix m m R\nb : m → α\ninst✝¹ : LT α\ninst✝ : Zero R\na✝ : M.BlockTriangular b\n⊢ M.transpose.BlockTriangular (Function.comp (⇑OrderDual.toDual) b)","decl":"protected theorem BlockTriangular.transpose :\n    M.BlockTriangular b → Mᵀ.BlockTriangular (toDual ∘ b) :=\n  swap\n\n"}
{"name":"Matrix.blockTriangular_transpose_iff","module":"Mathlib.LinearAlgebra.Matrix.Block","initialProofState":"α : Type u_1\nm : Type u_3\nR : Type v\nM : Matrix m m R\ninst✝¹ : LT α\ninst✝ : Zero R\nb : m → OrderDual α\n⊢ Iff (M.transpose.BlockTriangular b) (M.BlockTriangular (Function.comp (⇑OrderDual.ofDual) b))","decl":"@[simp]\nprotected theorem blockTriangular_transpose_iff {b : m → αᵒᵈ} :\n    Mᵀ.BlockTriangular b ↔ M.BlockTriangular (ofDual ∘ b) :=\n  forall_swap\n\n"}
{"name":"Matrix.blockTriangular_zero","module":"Mathlib.LinearAlgebra.Matrix.Block","initialProofState":"α : Type u_1\nm : Type u_3\nR : Type v\nb : m → α\ninst✝¹ : LT α\ninst✝ : Zero R\n⊢ Matrix.BlockTriangular 0 b","decl":"@[simp]\ntheorem blockTriangular_zero : BlockTriangular (0 : Matrix m m R) b := fun _ _ _ => rfl\n\n"}
{"name":"Matrix.BlockTriangular.neg","module":"Mathlib.LinearAlgebra.Matrix.Block","initialProofState":"α : Type u_1\nm : Type u_3\nR : Type v\nb : m → α\ninst✝¹ : LT α\ninst✝ : NegZeroClass R\nM : Matrix m m R\nhM : M.BlockTriangular b\n⊢ (Neg.neg M).BlockTriangular b","decl":"protected theorem BlockTriangular.neg [NegZeroClass R] {M : Matrix m m R}\n    (hM : BlockTriangular M b) : BlockTriangular (-M) b :=\n  fun _ _ h => by rw [neg_apply, hM h, neg_zero]\n\n"}
{"name":"Matrix.BlockTriangular.add","module":"Mathlib.LinearAlgebra.Matrix.Block","initialProofState":"α : Type u_1\nm : Type u_3\nR : Type v\nM N : Matrix m m R\nb : m → α\ninst✝¹ : LT α\ninst✝ : AddZeroClass R\nhM : M.BlockTriangular b\nhN : N.BlockTriangular b\n⊢ (HAdd.hAdd M N).BlockTriangular b","decl":"theorem BlockTriangular.add [AddZeroClass R] (hM : BlockTriangular M b) (hN : BlockTriangular N b) :\n    BlockTriangular (M + N) b := fun i j h => by simp_rw [Matrix.add_apply, hM h, hN h, zero_add]\n\n"}
{"name":"Matrix.BlockTriangular.sub","module":"Mathlib.LinearAlgebra.Matrix.Block","initialProofState":"α : Type u_1\nm : Type u_3\nR : Type v\nM N : Matrix m m R\nb : m → α\ninst✝¹ : LT α\ninst✝ : SubNegZeroMonoid R\nhM : M.BlockTriangular b\nhN : N.BlockTriangular b\n⊢ (HSub.hSub M N).BlockTriangular b","decl":"theorem BlockTriangular.sub [SubNegZeroMonoid R]\n    (hM : BlockTriangular M b) (hN : BlockTriangular N b) :\n    BlockTriangular (M - N) b := fun i j h => by simp_rw [Matrix.sub_apply, hM h, hN h, sub_zero]\n\n"}
{"name":"Matrix.BlockTriangular.add_iff_right","module":"Mathlib.LinearAlgebra.Matrix.Block","initialProofState":"α : Type u_1\nm : Type u_3\nR : Type v\nM N : Matrix m m R\nb : m → α\ninst✝¹ : LT α\ninst✝ : AddGroup R\nhM : M.BlockTriangular b\n⊢ Iff ((HAdd.hAdd M N).BlockTriangular b) (N.BlockTriangular b)","decl":"lemma BlockTriangular.add_iff_right [AddGroup R] (hM : BlockTriangular M b) :\n    BlockTriangular (M + N) b ↔ BlockTriangular N b := ⟨(by simpa using hM.neg.add ·), hM.add⟩\n\n"}
{"name":"Matrix.BlockTriangular.add_iff_left","module":"Mathlib.LinearAlgebra.Matrix.Block","initialProofState":"α : Type u_1\nm : Type u_3\nR : Type v\nM N : Matrix m m R\nb : m → α\ninst✝¹ : LT α\ninst✝ : AddGroup R\nhN : N.BlockTriangular b\n⊢ Iff ((HAdd.hAdd M N).BlockTriangular b) (M.BlockTriangular b)","decl":"lemma BlockTriangular.add_iff_left [AddGroup R] (hN : BlockTriangular N b) :\n    BlockTriangular (M + N) b ↔ BlockTriangular M b := ⟨(by simpa using ·.sub hN), (·.add hN)⟩\n\n"}
{"name":"Matrix.BlockTriangular.sub_iff_right","module":"Mathlib.LinearAlgebra.Matrix.Block","initialProofState":"α : Type u_1\nm : Type u_3\nR : Type v\nM N : Matrix m m R\nb : m → α\ninst✝¹ : LT α\ninst✝ : AddGroup R\nhM : M.BlockTriangular b\n⊢ Iff ((HSub.hSub M N).BlockTriangular b) (N.BlockTriangular b)","decl":"lemma BlockTriangular.sub_iff_right [AddGroup R] (hM : BlockTriangular M b) :\n    BlockTriangular (M - N) b ↔ BlockTriangular N b := ⟨(by simpa using ·.neg.add hM), hM.sub⟩\n\n"}
{"name":"Matrix.BlockTriangular.sub_iff_left","module":"Mathlib.LinearAlgebra.Matrix.Block","initialProofState":"α : Type u_1\nm : Type u_3\nR : Type v\nM N : Matrix m m R\nb : m → α\ninst✝¹ : LT α\ninst✝ : AddGroup R\nhN : N.BlockTriangular b\n⊢ Iff ((HSub.hSub M N).BlockTriangular b) (M.BlockTriangular b)","decl":"lemma BlockTriangular.sub_iff_left [AddGroup R] (hN : BlockTriangular N b) :\n    BlockTriangular (M - N) b ↔ BlockTriangular M b := ⟨(by simpa using ·.add hN), (·.sub hN)⟩\n\n"}
{"name":"Matrix.BlockTriangular.map","module":"Mathlib.LinearAlgebra.Matrix.Block","initialProofState":"α : Type u_1\nm : Type u_3\nR : Type v\nM : Matrix m m R\nb : m → α\ninst✝⁴ : LT α\nS : Type u_8\nF : Type u_9\ninst✝³ : FunLike F R S\ninst✝² : Zero R\ninst✝¹ : Zero S\ninst✝ : ZeroHomClass F R S\nf : F\nh : M.BlockTriangular b\n⊢ (M.map ⇑f).BlockTriangular b","decl":"lemma BlockTriangular.map {S F} [FunLike F R S] [Zero R] [Zero S] [ZeroHomClass F R S] (f : F)\n    (h : BlockTriangular M b) : BlockTriangular (M.map f) b :=\n  fun i j lt ↦ by simp [h lt]\n\n"}
{"name":"Matrix.BlockTriangular.comp","module":"Mathlib.LinearAlgebra.Matrix.Block","initialProofState":"α : Type u_1\nm : Type u_3\nn : Type u_4\nR : Type v\nb : m → α\ninst✝¹ : LT α\ninst✝ : Zero R\nM : Matrix m m (Matrix n n R)\nh : M.BlockTriangular b\n⊢ ((Matrix.comp m m n n R) M).BlockTriangular fun i => b i.1","decl":"lemma BlockTriangular.comp [Zero R] {M : Matrix m m (Matrix n n R)} (h : BlockTriangular M b) :\n    BlockTriangular (M.comp m m n n R) fun i ↦ b i.1 :=\n  fun i j lt ↦ by simp [h lt]\n\n"}
{"name":"Matrix.blockTriangular_diagonal","module":"Mathlib.LinearAlgebra.Matrix.Block","initialProofState":"α : Type u_1\nm : Type u_3\nR : Type v\nb : m → α\ninst✝² : Preorder α\ninst✝¹ : Zero R\ninst✝ : DecidableEq m\nd : m → R\n⊢ (Matrix.diagonal d).BlockTriangular b","decl":"theorem blockTriangular_diagonal [DecidableEq m] (d : m → R) : BlockTriangular (diagonal d) b :=\n  fun _ _ h => diagonal_apply_ne' d fun h' => ne_of_lt h (congr_arg _ h')\n\n"}
{"name":"Matrix.blockTriangular_blockDiagonal'","module":"Mathlib.LinearAlgebra.Matrix.Block","initialProofState":"α : Type u_1\nm' : α → Type u_6\nR : Type v\ninst✝² : Preorder α\ninst✝¹ : Zero R\ninst✝ : DecidableEq α\nd : (i : α) → Matrix (m' i) (m' i) R\n⊢ (Matrix.blockDiagonal' d).BlockTriangular Sigma.fst","decl":"theorem blockTriangular_blockDiagonal' [DecidableEq α] (d : ∀ i : α, Matrix (m' i) (m' i) R) :\n    BlockTriangular (blockDiagonal' d) Sigma.fst := by\n  rintro ⟨i, i'⟩ ⟨j, j'⟩ h\n  apply blockDiagonal'_apply_ne d i' j' fun h' => ne_of_lt h h'.symm\n\n"}
{"name":"Matrix.blockTriangular_blockDiagonal","module":"Mathlib.LinearAlgebra.Matrix.Block","initialProofState":"α : Type u_1\nm : Type u_3\nR : Type v\ninst✝² : Preorder α\ninst✝¹ : Zero R\ninst✝ : DecidableEq α\nd : α → Matrix m m R\n⊢ (Matrix.blockDiagonal d).BlockTriangular Prod.snd","decl":"theorem blockTriangular_blockDiagonal [DecidableEq α] (d : α → Matrix m m R) :\n    BlockTriangular (blockDiagonal d) Prod.snd := by\n  rintro ⟨i, i'⟩ ⟨j, j'⟩ h\n  rw [blockDiagonal'_eq_blockDiagonal, blockTriangular_blockDiagonal']\n  exact h\n\n"}
{"name":"Matrix.blockTriangular_one","module":"Mathlib.LinearAlgebra.Matrix.Block","initialProofState":"α : Type u_1\nm : Type u_3\nR : Type v\nb : m → α\ninst✝³ : Preorder α\ninst✝² : Zero R\ninst✝¹ : DecidableEq m\ninst✝ : One R\n⊢ Matrix.BlockTriangular 1 b","decl":"theorem blockTriangular_one [One R] : BlockTriangular (1 : Matrix m m R) b :=\n  blockTriangular_diagonal _\n\n"}
{"name":"Matrix.blockTriangular_stdBasisMatrix","module":"Mathlib.LinearAlgebra.Matrix.Block","initialProofState":"α : Type u_1\nm : Type u_3\nR : Type v\nb : m → α\ninst✝² : Preorder α\ninst✝¹ : Zero R\ninst✝ : DecidableEq m\ni j : m\nhij : LE.le (b i) (b j)\nc : R\n⊢ (Matrix.stdBasisMatrix i j c).BlockTriangular b","decl":"theorem blockTriangular_stdBasisMatrix {i j : m} (hij : b i ≤ b j) (c : R) :\n    BlockTriangular (stdBasisMatrix i j c) b := by\n  intro r s hrs\n  apply StdBasisMatrix.apply_of_ne\n  rintro ⟨rfl, rfl⟩\n  exact (hij.trans_lt hrs).false\n\n"}
{"name":"Matrix.blockTriangular_stdBasisMatrix'","module":"Mathlib.LinearAlgebra.Matrix.Block","initialProofState":"α : Type u_1\nm : Type u_3\nR : Type v\nb : m → α\ninst✝² : Preorder α\ninst✝¹ : Zero R\ninst✝ : DecidableEq m\ni j : m\nhij : LE.le (b j) (b i)\nc : R\n⊢ (Matrix.stdBasisMatrix i j c).BlockTriangular (Function.comp (⇑OrderDual.toDual) b)","decl":"theorem blockTriangular_stdBasisMatrix' {i j : m} (hij : b j ≤ b i) (c : R) :\n    BlockTriangular (stdBasisMatrix i j c) (toDual ∘ b) :=\n  blockTriangular_stdBasisMatrix (by exact toDual_le_toDual.mpr hij) _\n\n"}
{"name":"Matrix.blockTriangular_transvection","module":"Mathlib.LinearAlgebra.Matrix.Block","initialProofState":"α : Type u_1\nm : Type u_3\nR : Type v\nb : m → α\ninst✝² : Preorder α\ninst✝¹ : CommRing R\ninst✝ : DecidableEq m\ni j : m\nhij : LE.le (b i) (b j)\nc : R\n⊢ (Matrix.transvection i j c).BlockTriangular b","decl":"theorem blockTriangular_transvection {i j : m} (hij : b i ≤ b j) (c : R) :\n    BlockTriangular (transvection i j c) b :=\n  blockTriangular_one.add (blockTriangular_stdBasisMatrix hij c)\n\n"}
{"name":"Matrix.blockTriangular_transvection'","module":"Mathlib.LinearAlgebra.Matrix.Block","initialProofState":"α : Type u_1\nm : Type u_3\nR : Type v\nb : m → α\ninst✝² : Preorder α\ninst✝¹ : CommRing R\ninst✝ : DecidableEq m\ni j : m\nhij : LE.le (b j) (b i)\nc : R\n⊢ (Matrix.transvection i j c).BlockTriangular (Function.comp (⇑OrderDual.toDual) b)","decl":"theorem blockTriangular_transvection' {i j : m} (hij : b j ≤ b i) (c : R) :\n    BlockTriangular (transvection i j c) (OrderDual.toDual ∘ b) :=\n  blockTriangular_one.add (blockTriangular_stdBasisMatrix' hij c)\n\n"}
{"name":"Matrix.BlockTriangular.mul","module":"Mathlib.LinearAlgebra.Matrix.Block","initialProofState":"α : Type u_1\nm : Type u_3\nR : Type v\nb : m → α\ninst✝² : LinearOrder α\ninst✝¹ : Fintype m\ninst✝ : NonUnitalNonAssocSemiring R\nM N : Matrix m m R\nhM : M.BlockTriangular b\nhN : N.BlockTriangular b\n⊢ (HMul.hMul M N).BlockTriangular b","decl":"theorem BlockTriangular.mul [Fintype m] [NonUnitalNonAssocSemiring R]\n    {M N : Matrix m m R} (hM : BlockTriangular M b)\n    (hN : BlockTriangular N b) : BlockTriangular (M * N) b := by\n  intro i j hij\n  apply Finset.sum_eq_zero\n  intro k _\n  by_cases hki : b k < b i\n  · simp_rw [hM hki, zero_mul]\n  · simp_rw [hN (lt_of_lt_of_le hij (le_of_not_lt hki)), mul_zero]\n\n"}
{"name":"Matrix.upper_two_blockTriangular","module":"Mathlib.LinearAlgebra.Matrix.Block","initialProofState":"α : Type u_1\nm : Type u_3\nn : Type u_4\nR : Type v\ninst✝¹ : Zero R\ninst✝ : Preorder α\nA : Matrix m m R\nB : Matrix m n R\nD : Matrix n n R\na b : α\nhab : LT.lt a b\n⊢ (Matrix.fromBlocks A B 0 D).BlockTriangular (Sum.elim (fun x => a) fun x => b)","decl":"theorem upper_two_blockTriangular [Zero R] [Preorder α] (A : Matrix m m R) (B : Matrix m n R)\n    (D : Matrix n n R) {a b : α} (hab : a < b) :\n    BlockTriangular (fromBlocks A B 0 D) (Sum.elim (fun _ => a) fun _ => b) := by\n  rintro (c | c) (d | d) hcd <;> first | simp [hab.not_lt] at hcd ⊢\n\n"}
{"name":"Matrix.equiv_block_det","module":"Mathlib.LinearAlgebra.Matrix.Block","initialProofState":"m : Type u_3\nR : Type v\ninst✝⁴ : CommRing R\ninst✝³ : DecidableEq m\ninst✝² : Fintype m\nM : Matrix m m R\np q : m → Prop\ninst✝¹ : DecidablePred p\ninst✝ : DecidablePred q\ne : ∀ (x : m), Iff (q x) (p x)\n⊢ Eq (M.toSquareBlockProp p).det (M.toSquareBlockProp q).det","decl":"theorem equiv_block_det (M : Matrix m m R) {p q : m → Prop} [DecidablePred p] [DecidablePred q]\n    (e : ∀ x, q x ↔ p x) : (toSquareBlockProp M p).det = (toSquareBlockProp M q).det := by\n  convert Matrix.det_reindex_self (Equiv.subtypeEquivRight e) (toSquareBlockProp M q)\n\n-- Removed `@[simp]` attribute,\n-- as the LHS simplifies already to `M.toSquareBlock id i ⟨i, ⋯⟩ ⟨i, ⋯⟩`\n"}
{"name":"Matrix.det_toSquareBlock_id","module":"Mathlib.LinearAlgebra.Matrix.Block","initialProofState":"m : Type u_3\nR : Type v\ninst✝² : CommRing R\ninst✝¹ : DecidableEq m\ninst✝ : Fintype m\nM : Matrix m m R\ni : m\n⊢ Eq (M.toSquareBlock id i).det (M i i)","decl":"theorem det_toSquareBlock_id (M : Matrix m m R) (i : m) : (M.toSquareBlock id i).det = M i i :=\n  letI : Unique { a // id a = i } := ⟨⟨⟨i, rfl⟩⟩, fun j => Subtype.ext j.property⟩\n  (det_unique _).trans rfl\n\n"}
{"name":"Matrix.det_toBlock","module":"Mathlib.LinearAlgebra.Matrix.Block","initialProofState":"m : Type u_3\nR : Type v\ninst✝³ : CommRing R\ninst✝² : DecidableEq m\ninst✝¹ : Fintype m\nM : Matrix m m R\np : m → Prop\ninst✝ : DecidablePred p\n⊢ Eq M.det (Matrix.fromBlocks (M.toBlock p p) (M.toBlock p fun j => Not (p j)) (M.toBlock (fun j => Not (p j)) p) (M.toBlock (fun j => Not (p j)) fun j => Not (p j))).det","decl":"theorem det_toBlock (M : Matrix m m R) (p : m → Prop) [DecidablePred p] :\n    M.det =\n      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬p j) (toBlock M (fun j => ¬p j) p) <|\n          toBlock M (fun j => ¬p j) fun j => ¬p j).det := by\n  rw [← Matrix.det_reindex_self (Equiv.sumCompl p).symm M]\n  rw [det_apply', det_apply']\n  congr; ext σ; congr; ext x\n  generalize hy : σ x = y\n  cases x <;> cases y <;>\n    simp only [Matrix.reindex_apply, toBlock_apply, Equiv.symm_symm, Equiv.sumCompl_apply_inr,\n      Equiv.sumCompl_apply_inl, fromBlocks_apply₁₁, fromBlocks_apply₁₂, fromBlocks_apply₂₁,\n      fromBlocks_apply₂₂, Matrix.submatrix_apply]\n\n"}
{"name":"Matrix.twoBlockTriangular_det","module":"Mathlib.LinearAlgebra.Matrix.Block","initialProofState":"m : Type u_3\nR : Type v\ninst✝³ : CommRing R\ninst✝² : DecidableEq m\ninst✝¹ : Fintype m\nM : Matrix m m R\np : m → Prop\ninst✝ : DecidablePred p\nh : ∀ (i : m), Not (p i) → ∀ (j : m), p j → Eq (M i j) 0\n⊢ Eq M.det (HMul.hMul (M.toSquareBlockProp p).det (M.toSquareBlockProp fun i => Not (p i)).det)","decl":"theorem twoBlockTriangular_det (M : Matrix m m R) (p : m → Prop) [DecidablePred p]\n    (h : ∀ i, ¬p i → ∀ j, p j → M i j = 0) :\n    M.det = (toSquareBlockProp M p).det * (toSquareBlockProp M fun i => ¬p i).det := by\n  rw [det_toBlock M p]\n  convert det_fromBlocks_zero₂₁ (toBlock M p p) (toBlock M p fun j => ¬p j)\n      (toBlock M (fun j => ¬p j) fun j => ¬p j)\n  ext i j\n  exact h (↑i) i.2 (↑j) j.2\n\n"}
{"name":"Matrix.twoBlockTriangular_det'","module":"Mathlib.LinearAlgebra.Matrix.Block","initialProofState":"m : Type u_3\nR : Type v\ninst✝³ : CommRing R\ninst✝² : DecidableEq m\ninst✝¹ : Fintype m\nM : Matrix m m R\np : m → Prop\ninst✝ : DecidablePred p\nh : ∀ (i : m), p i → ∀ (j : m), Not (p j) → Eq (M i j) 0\n⊢ Eq M.det (HMul.hMul (M.toSquareBlockProp p).det (M.toSquareBlockProp fun i => Not (p i)).det)","decl":"theorem twoBlockTriangular_det' (M : Matrix m m R) (p : m → Prop) [DecidablePred p]\n    (h : ∀ i, p i → ∀ j, ¬p j → M i j = 0) :\n    M.det = (toSquareBlockProp M p).det * (toSquareBlockProp M fun i => ¬p i).det := by\n  rw [M.twoBlockTriangular_det fun i => ¬p i, mul_comm]\n  · congr 1\n    exact equiv_block_det _ fun _ => not_not.symm\n  · simpa only [Classical.not_not] using h\n\n"}
{"name":"Matrix.BlockTriangular.det","module":"Mathlib.LinearAlgebra.Matrix.Block","initialProofState":"α : Type u_1\nm : Type u_3\nR : Type v\nM : Matrix m m R\nb : m → α\ninst✝⁴ : CommRing R\ninst✝³ : DecidableEq m\ninst✝² : Fintype m\ninst✝¹ : DecidableEq α\ninst✝ : LinearOrder α\nhM : M.BlockTriangular b\n⊢ Eq M.det ((Finset.image b Finset.univ).prod fun a => (M.toSquareBlock b a).det)","decl":"protected theorem BlockTriangular.det [DecidableEq α] [LinearOrder α] (hM : BlockTriangular M b) :\n    M.det = ∏ a ∈ univ.image b, (M.toSquareBlock b a).det := by\n  induction' hs : univ.image b using Finset.strongInduction with s ih generalizing m\n  subst hs\n  cases isEmpty_or_nonempty m\n  · simp\n  let k := (univ.image b).max' (univ_nonempty.image _)\n  rw [twoBlockTriangular_det' M fun i => b i = k]\n  · have : univ.image b = insert k ((univ.image b).erase k) := by\n      rw [insert_erase]\n      apply max'_mem\n    rw [this, prod_insert (not_mem_erase _ _)]\n    refine congr_arg _ ?_\n    let b' := fun i : { a // b a ≠ k } => b ↑i\n    have h' : BlockTriangular (M.toSquareBlockProp fun i => b i ≠ k) b' := hM.submatrix\n    have hb' : image b' univ = (image b univ).erase k := by\n      convert image_subtype_ne_univ_eq_image_erase k b\n    rw [ih _ (erase_ssubset <| max'_mem _ _) h' hb']\n    refine Finset.prod_congr rfl fun l hl => ?_\n    let he : { a // b' a = l } ≃ { a // b a = l } :=\n      haveI hc : ∀ i, b i = l → b i ≠ k := fun i hi => ne_of_eq_of_ne hi (ne_of_mem_erase hl)\n      Equiv.subtypeSubtypeEquivSubtype @(hc)\n    simp only [toSquareBlock_def]\n    erw [← Matrix.det_reindex_self he.symm fun i j : { a // b a = l } => M ↑i ↑j]\n    rfl\n  · intro i hi j hj\n    apply hM\n    rw [hi]\n    apply lt_of_le_of_ne _ hj\n    exact Finset.le_max' (univ.image b) _ (mem_image_of_mem _ (mem_univ _))\n\n"}
{"name":"Matrix.BlockTriangular.det_fintype","module":"Mathlib.LinearAlgebra.Matrix.Block","initialProofState":"α : Type u_1\nm : Type u_3\nR : Type v\nM : Matrix m m R\nb : m → α\ninst✝⁵ : CommRing R\ninst✝⁴ : DecidableEq m\ninst✝³ : Fintype m\ninst✝² : DecidableEq α\ninst✝¹ : Fintype α\ninst✝ : LinearOrder α\nh : M.BlockTriangular b\n⊢ Eq M.det (Finset.univ.prod fun k => (M.toSquareBlock b k).det)","decl":"theorem BlockTriangular.det_fintype [DecidableEq α] [Fintype α] [LinearOrder α]\n    (h : BlockTriangular M b) : M.det = ∏ k : α, (M.toSquareBlock b k).det := by\n  refine h.det.trans (prod_subset (subset_univ _) fun a _ ha => ?_)\n  have : IsEmpty { i // b i = a } := ⟨fun i => ha <| mem_image.2 ⟨i, mem_univ _, i.2⟩⟩\n  exact det_isEmpty\n\n"}
{"name":"Matrix.det_of_upperTriangular","module":"Mathlib.LinearAlgebra.Matrix.Block","initialProofState":"m : Type u_3\nR : Type v\nM : Matrix m m R\ninst✝³ : CommRing R\ninst✝² : DecidableEq m\ninst✝¹ : Fintype m\ninst✝ : LinearOrder m\nh : M.BlockTriangular id\n⊢ Eq M.det (Finset.univ.prod fun i => M i i)","decl":"theorem det_of_upperTriangular [LinearOrder m] (h : M.BlockTriangular id) :\n    M.det = ∏ i : m, M i i := by\n  haveI : DecidableEq R := Classical.decEq _\n  simp_rw [h.det, image_id, det_toSquareBlock_id]\n\n"}
{"name":"Matrix.det_of_lowerTriangular","module":"Mathlib.LinearAlgebra.Matrix.Block","initialProofState":"m : Type u_3\nR : Type v\ninst✝³ : CommRing R\ninst✝² : DecidableEq m\ninst✝¹ : Fintype m\ninst✝ : LinearOrder m\nM : Matrix m m R\nh : M.BlockTriangular ⇑OrderDual.toDual\n⊢ Eq M.det (Finset.univ.prod fun i => M i i)","decl":"theorem det_of_lowerTriangular [LinearOrder m] (M : Matrix m m R) (h : M.BlockTriangular toDual) :\n    M.det = ∏ i : m, M i i := by\n  rw [← det_transpose]\n  exact det_of_upperTriangular h.transpose\n\n"}
{"name":"Matrix.matrixOfPolynomials_blockTriangular","module":"Mathlib.LinearAlgebra.Matrix.Block","initialProofState":"R : Type u_8\ninst✝ : Semiring R\nn : Nat\np : Fin n → Polynomial R\nh_deg : ∀ (i : Fin n), LE.le (p i).natDegree ↑i\n⊢ (Matrix.of fun i j => (p j).coeff ↑i).BlockTriangular id","decl":"theorem matrixOfPolynomials_blockTriangular {R} [Semiring R] {n : ℕ} (p : Fin n → R[X])\n    (h_deg : ∀ i, (p i).natDegree ≤ i) :\n    Matrix.BlockTriangular (Matrix.of (fun (i j : Fin n) => (p j).coeff i)) id :=\n  fun _ j h => by\n    exact coeff_eq_zero_of_natDegree_lt <| Nat.lt_of_le_of_lt (h_deg j) h\n\n"}
{"name":"Matrix.det_matrixOfPolynomials","module":"Mathlib.LinearAlgebra.Matrix.Block","initialProofState":"R : Type v\ninst✝ : CommRing R\nn : Nat\np : Fin n → Polynomial R\nh_deg : ∀ (i : Fin n), Eq (p i).natDegree ↑i\nh_monic : ∀ (i : Fin n), (p i).Monic\n⊢ Eq (Matrix.of fun i j => (p j).coeff ↑i).det 1","decl":"theorem det_matrixOfPolynomials {n : ℕ} (p : Fin n → R[X])\n    (h_deg : ∀ i, (p i).natDegree = i) (h_monic : ∀ i, Monic <| p i) :\n    (Matrix.of (fun (i j : Fin n) => (p j).coeff i)).det = 1 := by\n  rw [Matrix.det_of_upperTriangular (Matrix.matrixOfPolynomials_blockTriangular p (fun i ↦\n      Nat.le_of_eq (h_deg i)))]\n  convert prod_const_one with x _\n  rw [Matrix.of_apply, ← h_deg, coeff_natDegree, (h_monic x).leadingCoeff]\n\n"}
{"name":"Matrix.BlockTriangular.toBlock_inverse_mul_toBlock_eq_one","module":"Mathlib.LinearAlgebra.Matrix.Block","initialProofState":"α : Type u_1\nm : Type u_3\nR : Type v\nM : Matrix m m R\nb : m → α\ninst✝⁴ : CommRing R\ninst✝³ : DecidableEq m\ninst✝² : Fintype m\ninst✝¹ : LinearOrder α\ninst✝ : Invertible M\nhM : M.BlockTriangular b\nk : α\n⊢ Eq (HMul.hMul ((Inv.inv M).toBlock (fun i => LT.lt (b i) k) fun i => LT.lt (b i) k) (M.toBlock (fun i => LT.lt (b i) k) fun i => LT.lt (b i) k)) 1","decl":"theorem BlockTriangular.toBlock_inverse_mul_toBlock_eq_one [LinearOrder α] [Invertible M]\n    (hM : BlockTriangular M b) (k : α) :\n    ((M⁻¹.toBlock (fun i => b i < k) fun i => b i < k) *\n        M.toBlock (fun i => b i < k) fun i => b i < k) =\n      1 := by\n  let p i := b i < k\n  have h_sum :\n    M⁻¹.toBlock p p * M.toBlock p p +\n        (M⁻¹.toBlock p fun i => ¬p i) * M.toBlock (fun i => ¬p i) p =\n      1 := by\n    rw [← toBlock_mul_eq_add, inv_mul_of_invertible M, toBlock_one_self]\n  have h_zero : M.toBlock (fun i => ¬p i) p = 0 := by\n    ext i j\n    simpa using hM (lt_of_lt_of_le j.2 (le_of_not_lt i.2))\n  simpa [h_zero] using h_sum\n\n"}
{"name":"Matrix.BlockTriangular.inv_toBlock","module":"Mathlib.LinearAlgebra.Matrix.Block","initialProofState":"α : Type u_1\nm : Type u_3\nR : Type v\nM : Matrix m m R\nb : m → α\ninst✝⁴ : CommRing R\ninst✝³ : DecidableEq m\ninst✝² : Fintype m\ninst✝¹ : LinearOrder α\ninst✝ : Invertible M\nhM : M.BlockTriangular b\nk : α\n⊢ Eq (Inv.inv (M.toBlock (fun i => LT.lt (b i) k) fun i => LT.lt (b i) k)) ((Inv.inv M).toBlock (fun i => LT.lt (b i) k) fun i => LT.lt (b i) k)","decl":"/-- The inverse of an upper-left subblock of a block-triangular matrix `M` is the upper-left\nsubblock of `M⁻¹`. -/\ntheorem BlockTriangular.inv_toBlock [LinearOrder α] [Invertible M] (hM : BlockTriangular M b)\n    (k : α) :\n    (M.toBlock (fun i => b i < k) fun i => b i < k)⁻¹ =\n      M⁻¹.toBlock (fun i => b i < k) fun i => b i < k :=\n  inv_eq_left_inv <| hM.toBlock_inverse_mul_toBlock_eq_one k\n\n"}
{"name":"Matrix.toBlock_inverse_eq_zero","module":"Mathlib.LinearAlgebra.Matrix.Block","initialProofState":"α : Type u_1\nm : Type u_3\nR : Type v\nM : Matrix m m R\nb : m → α\ninst✝⁴ : CommRing R\ninst✝³ : DecidableEq m\ninst✝² : Fintype m\ninst✝¹ : LinearOrder α\ninst✝ : Invertible M\nhM : M.BlockTriangular b\nk : α\n⊢ Eq ((Inv.inv M).toBlock (fun i => LE.le k (b i)) fun i => LT.lt (b i) k) 0","decl":"/-- A lower-left subblock of the inverse of a block-triangular matrix is zero. This is a first step\ntowards `BlockTriangular.inv_toBlock` below. -/\ntheorem toBlock_inverse_eq_zero [LinearOrder α] [Invertible M] (hM : BlockTriangular M b) (k : α) :\n    (M⁻¹.toBlock (fun i => k ≤ b i) fun i => b i < k) = 0 := by\n  let p i := b i < k\n  let q i := ¬b i < k\n  have h_sum : M⁻¹.toBlock q p * M.toBlock p p + M⁻¹.toBlock q q * M.toBlock q p = 0 := by\n    rw [← toBlock_mul_eq_add, inv_mul_of_invertible M, toBlock_one_disjoint]\n    rw [disjoint_iff_inf_le]\n    exact fun i h => h.1 h.2\n  have h_zero : M.toBlock q p = 0 := by\n    ext i j\n    simpa using hM (lt_of_lt_of_le j.2 <| le_of_not_lt i.2)\n  have h_mul_eq_zero : M⁻¹.toBlock q p * M.toBlock p p = 0 := by simpa [h_zero] using h_sum\n  haveI : Invertible (M.toBlock p p) := hM.invertibleToBlock k\n  have : (fun i => k ≤ b i) = q := by\n    ext\n    exact not_lt.symm\n  rw [this, ← Matrix.zero_mul (M.toBlock p p)⁻¹, ← h_mul_eq_zero,\n    mul_inv_cancel_right_of_invertible]\n\n"}
{"name":"Matrix.blockTriangular_inv_of_blockTriangular","module":"Mathlib.LinearAlgebra.Matrix.Block","initialProofState":"α : Type u_1\nm : Type u_3\nR : Type v\nM : Matrix m m R\nb : m → α\ninst✝⁴ : CommRing R\ninst✝³ : DecidableEq m\ninst✝² : Fintype m\ninst✝¹ : LinearOrder α\ninst✝ : Invertible M\nhM : M.BlockTriangular b\n⊢ (Inv.inv M).BlockTriangular b","decl":"/-- The inverse of a block-triangular matrix is block-triangular. -/\ntheorem blockTriangular_inv_of_blockTriangular [LinearOrder α] [Invertible M]\n    (hM : BlockTriangular M b) : BlockTriangular M⁻¹ b := by\n  induction' hs : univ.image b using Finset.strongInduction with s ih generalizing m\n  subst hs\n  intro i j hij\n  haveI : Inhabited m := ⟨i⟩\n  let k := (univ.image b).max' (univ_nonempty.image _)\n  let b' := fun i : { a // b a < k } => b ↑i\n  let A := M.toBlock (fun i => b i < k) fun j => b j < k\n  obtain hbi | hi : b i = k ∨ _ := (le_max' _ (b i) <| mem_image_of_mem _ <| mem_univ _).eq_or_lt\n  · have : M⁻¹.toBlock (fun i => k ≤ b i) (fun i => b i < k) ⟨i, hbi.ge⟩ ⟨j, hbi ▸ hij⟩ = 0 := by\n      simp only [toBlock_inverse_eq_zero hM k, Matrix.zero_apply]\n    simp [this.symm]\n  haveI : Invertible A := hM.invertibleToBlock _\n  have hA : A.BlockTriangular b' := hM.submatrix\n  have hb' : image b' univ ⊂ image b univ := by\n    convert image_subtype_univ_ssubset_image_univ k b _ (fun a => a < k) (lt_irrefl _)\n    convert max'_mem (α := α) _ _\n  have hij' : b' ⟨j, hij.trans hi⟩ < b' ⟨i, hi⟩ := by simp_rw [b', hij]\n  simp [A, hM.inv_toBlock k, (ih (image b' univ) hb' hA rfl hij').symm]\n\n"}
