{"name":"WithZeroMulInt.toNNReal_pos_apply","module":"Mathlib.Data.Int.WithZero","initialProofState":"e : NNReal\nhe : Ne e 0\nx : WithZero (Multiplicative Int)\nhx : Eq x 0\n⊢ Eq ((WithZeroMulInt.toNNReal he) x) 0","decl":"theorem toNNReal_pos_apply {e : ℝ≥0} (he : e ≠ 0) {x : ℤₘ₀} (hx : x = 0) :\n    toNNReal he x = 0 := by\n  simp only [toNNReal, MonoidWithZeroHom.coe_mk, ZeroHom.coe_mk]\n  split_ifs; rfl\n\n"}
{"name":"WithZeroMulInt.toNNReal_neg_apply","module":"Mathlib.Data.Int.WithZero","initialProofState":"e : NNReal\nhe : Ne e 0\nx : WithZero (Multiplicative Int)\nhx : Ne x 0\n⊢ Eq ((WithZeroMulInt.toNNReal he) x) (HPow.hPow e (Multiplicative.toAdd (WithZero.unzero hx)))","decl":"theorem toNNReal_neg_apply {e : ℝ≥0} (he : e ≠ 0) {x : ℤₘ₀} (hx : x ≠ 0) :\n    toNNReal he x = e ^ (WithZero.unzero hx).toAdd := by\n  simp only [toNNReal, MonoidWithZeroHom.coe_mk, ZeroHom.coe_mk]\n  split_ifs\n  · tauto\n  · rfl\n\n"}
{"name":"WithZeroMulInt.toNNReal_ne_zero","module":"Mathlib.Data.Int.WithZero","initialProofState":"e : NNReal\nm : WithZero (Multiplicative Int)\nhe : Ne e 0\nhm : Ne m 0\n⊢ Ne ((WithZeroMulInt.toNNReal he) m) 0","decl":"/-- `toNNReal` sends nonzero elements to nonzero elements. -/\ntheorem toNNReal_ne_zero {e : ℝ≥0} {m : ℤₘ₀} (he : e ≠ 0) (hm : m ≠ 0) : toNNReal he m ≠ 0 := by\n  simp only [ne_eq, map_eq_zero, hm, not_false_eq_true]\n\n"}
{"name":"WithZeroMulInt.toNNReal_pos","module":"Mathlib.Data.Int.WithZero","initialProofState":"e : NNReal\nm : WithZero (Multiplicative Int)\nhe : Ne e 0\nhm : Ne m 0\n⊢ LT.lt 0 ((WithZeroMulInt.toNNReal he) m)","decl":"/-- `toNNReal` sends nonzero elements to positive elements. -/\ntheorem toNNReal_pos {e : ℝ≥0} {m : ℤₘ₀} (he : e ≠ 0) (hm : m ≠ 0) : 0 < toNNReal he m :=\n  lt_of_le_of_ne zero_le' (toNNReal_ne_zero he hm).symm\n\n"}
{"name":"WithZeroMulInt.toNNReal_strictMono","module":"Mathlib.Data.Int.WithZero","initialProofState":"e : NNReal\nhe : LT.lt 1 e\n⊢ StrictMono ⇑(WithZeroMulInt.toNNReal ⋯)","decl":"/-- The map `toNNReal` is strictly monotone whenever `1 < e`. -/\ntheorem toNNReal_strictMono {e : ℝ≥0} (he : 1 < e) :\n    StrictMono (toNNReal (ne_zero_of_lt he)) := by\n  intro x y hxy\n  simp only [toNNReal, MonoidWithZeroHom.coe_mk, ZeroHom.coe_mk]\n  split_ifs with hx hy hy\n  · simp only [hy, not_lt_zero'] at hxy\n  · exact zpow_pos he.bot_lt _\n  · simp only [hy, not_lt_zero'] at hxy\n  · rw [zpow_lt_zpow_iff_right₀ he, Multiplicative.toAdd_lt, ← coe_lt_coe, coe_unzero hx,\n      WithZero.coe_unzero hy]\n    exact hxy\n\n"}
{"name":"WithZeroMulInt.toNNReal_eq_one_iff","module":"Mathlib.Data.Int.WithZero","initialProofState":"e : NNReal\nm : WithZero (Multiplicative Int)\nhe0 : Ne e 0\nhe1 : Ne e 1\n⊢ Iff (Eq ((WithZeroMulInt.toNNReal he0) m) 1) (Eq m 1)","decl":"theorem toNNReal_eq_one_iff {e : ℝ≥0} (m : ℤₘ₀) (he0 : e ≠ 0) (he1 : e ≠ 1) :\n    toNNReal he0 m = 1 ↔ m = 1 := by\n  by_cases hm : m = 0\n  · simp only [hm, map_zero, zero_ne_one]\n  · refine ⟨fun h1 ↦ ?_, fun h1 ↦ h1 ▸ map_one _⟩\n    rw [toNNReal_neg_apply he0 hm, zpow_eq_one_iff_right₀ (zero_le e) he1, toAdd_eq_zero] at h1\n    rw [← WithZero.coe_unzero hm, h1, coe_one]\n\n"}
{"name":"WithZeroMulInt.toNNReal_lt_one_iff","module":"Mathlib.Data.Int.WithZero","initialProofState":"e : NNReal\nm : WithZero (Multiplicative Int)\nhe : LT.lt 1 e\n⊢ Iff (LT.lt ((WithZeroMulInt.toNNReal ⋯) m) 1) (LT.lt m 1)","decl":"theorem toNNReal_lt_one_iff {e : ℝ≥0} {m : ℤₘ₀} (he : 1 < e) :\n    toNNReal (ne_zero_of_lt he) m < 1 ↔ m < 1 := by\n  have : 1 = (toNNReal (ne_zero_of_lt he)) 1 := rfl\n  simp_rw [this]\n  exact StrictMono.lt_iff_lt (toNNReal_strictMono he)\n\n"}
{"name":"WithZeroMulInt.toNNReal_le_one_iff","module":"Mathlib.Data.Int.WithZero","initialProofState":"e : NNReal\nm : WithZero (Multiplicative Int)\nhe : LT.lt 1 e\n⊢ Iff (LE.le ((WithZeroMulInt.toNNReal ⋯) m) 1) (LE.le m 1)","decl":"theorem toNNReal_le_one_iff {e : ℝ≥0} {m : ℤₘ₀} (he : 1 < e) :\n    toNNReal (ne_zero_of_lt he) m ≤ 1 ↔ m ≤ 1 := by\n  have : 1 = (toNNReal (ne_zero_of_lt he)) 1 := rfl\n  simp_rw [this]\n  exact StrictMono.le_iff_le (toNNReal_strictMono he)\n\n"}
