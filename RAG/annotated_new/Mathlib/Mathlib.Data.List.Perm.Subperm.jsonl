{"name":"List.subperm_iff_count","module":"Mathlib.Data.List.Perm.Subperm","initialProofState":"α : Type u_1\nl₁ l₂ : List α\ninst✝ : DecidableEq α\n⊢ Iff (l₁.Subperm l₂) (∀ (a : α), LE.le (List.count a l₁) (List.count a l₂))","decl":"/-- See also `List.subperm_ext_iff`. -/\nlemma subperm_iff_count [DecidableEq α] : l₁ <+~ l₂ ↔ ∀ a, count a l₁ ≤ count a l₂ :=\n  subperm_ext_iff.trans <| forall_congr' fun a ↦ by\n    by_cases ha : a ∈ l₁ <;> simp [ha, count_eq_zero_of_not_mem]\n\n"}
{"name":"List.subperm_iff","module":"Mathlib.Data.List.Perm.Subperm","initialProofState":"α : Type u_1\nl₁ l₂ : List α\n⊢ Iff (l₁.Subperm l₂) (Exists fun l => And (l.Perm l₂) (l₁.Sublist l))","decl":"lemma subperm_iff : l₁ <+~ l₂ ↔ ∃ l, l ~ l₂ ∧ l₁ <+ l := by\n  refine ⟨?_, fun ⟨l, h₁, h₂⟩ ↦ h₂.subperm.trans h₁.subperm⟩\n  rintro ⟨l, h₁, h₂⟩\n  obtain ⟨l', h₂⟩ := h₂.exists_perm_append\n  exact ⟨l₁ ++ l', (h₂.trans (h₁.append_right _)).symm, (prefix_append _ _).sublist⟩\n\n"}
{"name":"List.subperm_singleton_iff","module":"Mathlib.Data.List.Perm.Subperm","initialProofState":"α : Type u_1\nl : List α\na : α\n⊢ Iff (l.Subperm (List.cons a List.nil)) (Or (Eq l List.nil) (Eq l (List.cons a List.nil)))","decl":"@[simp] lemma subperm_singleton_iff : l <+~ [a] ↔ l = [] ∨ l = [a] := by\n  constructor\n  · rw [subperm_iff]\n    rintro ⟨s, hla, h⟩\n    rwa [perm_singleton.mp hla, sublist_singleton] at h\n  · rintro (rfl | rfl)\n    exacts [nil_subperm, Subperm.refl _]\n\n"}
{"name":"List.subperm_cons_self","module":"Mathlib.Data.List.Perm.Subperm","initialProofState":"α : Type u_1\nl : List α\na : α\n⊢ l.Subperm (List.cons a l)","decl":"lemma subperm_cons_self : l <+~ a :: l := ⟨l, Perm.refl _, sublist_cons_self _ _⟩\n\n"}
{"name":"List.subperm.cons","module":"Mathlib.Data.List.Perm.Subperm","initialProofState":"α : Type u_1\na : α\nl₁ l₂ : List α\na✝ : l₁.Subperm l₂\n⊢ (List.cons a l₁).Subperm (List.cons a l₂)","decl":"protected alias ⟨subperm.of_cons, subperm.cons⟩ := subperm_cons\n\n"}
{"name":"List.subperm.of_cons","module":"Mathlib.Data.List.Perm.Subperm","initialProofState":"α : Type u_1\na : α\nl₁ l₂ : List α\na✝ : (List.cons a l₁).Subperm (List.cons a l₂)\n⊢ l₁.Subperm l₂","decl":"protected alias ⟨subperm.of_cons, subperm.cons⟩ := subperm_cons\n\n"}
{"name":"List.cons_subperm_of_mem","module":"Mathlib.Data.List.Perm.Subperm","initialProofState":"α : Type u_1\na : α\nl₁ l₂ : List α\nx✝ : l₁.Nodup\nh₁ : Not (Membership.mem l₁ a)\nh₂ : Membership.mem l₂ a\ns : l₁.Subperm l₂\n⊢ (List.cons a l₁).Subperm l₂","decl":"@[deprecated List.cons_subperm_of_not_mem_of_mem (since := \"2024-12-11\"), nolint unusedArguments]\ntheorem cons_subperm_of_mem {a : α} {l₁ l₂ : List α} (_ : Nodup l₁) (h₁ : a ∉ l₁) (h₂ : a ∈ l₂)\n    (s : l₁ <+~ l₂) : a :: l₁ <+~ l₂ :=\n  cons_subperm_of_not_mem_of_mem h₁ h₂ s\n\n"}
{"name":"List.Nodup.subperm","module":"Mathlib.Data.List.Perm.Subperm","initialProofState":"α : Type u_1\nl₁ l₂ : List α\nd : l₁.Nodup\nH : HasSubset.Subset l₁ l₂\n⊢ l₁.Subperm l₂","decl":"protected theorem Nodup.subperm (d : Nodup l₁) (H : l₁ ⊆ l₂) : l₁ <+~ l₂ :=\n  subperm_of_subset d H\n\n"}
