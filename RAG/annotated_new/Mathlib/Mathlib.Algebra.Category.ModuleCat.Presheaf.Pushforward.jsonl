{"name":"PresheafOfModules.pushforward_obj_obj","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Pushforward","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nR : CategoryTheory.Functor (Opposite D) RingCat\nS : CategoryTheory.Functor (Opposite C) RingCat\nφ : Quiver.Hom S (F.op.comp R)\nX✝ : PresheafOfModules R\nX : Opposite C\n⊢ Eq (((PresheafOfModules.pushforward φ).obj X✝).obj X) ((ModuleCat.restrictScalars (RingCat.Hom.hom (φ.app X))).obj (X✝.obj { unop := F.obj (Opposite.unop X) }))","decl":"attribute [local simp] pushforward₀ in\n/-- The pushforward functor `PresheafOfModules R ⥤ PresheafOfModules S` induced by\na morphism of presheaves of rings `S ⟶ F.op ⋙ R`. -/\n@[simps! obj_obj]\nnoncomputable def pushforward : PresheafOfModules.{v} R ⥤ PresheafOfModules.{v} S :=\n  pushforward₀ F R ⋙ restrictScalars φ\n\n"}
{"name":"PresheafOfModules.pushforward_obj_map_apply","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Pushforward","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nR : CategoryTheory.Functor (Opposite D) RingCat\nS : CategoryTheory.Functor (Opposite C) RingCat\nφ : Quiver.Hom S (F.op.comp R)\nM : PresheafOfModules R\nX Y : Opposite C\nf : Quiver.Hom X Y\nm : ↑((ModuleCat.restrictScalars (RingCat.Hom.hom (φ.app X))).obj (M.obj { unop := F.obj (Opposite.unop X) }))\n⊢ Eq ((ModuleCat.Hom.hom (((PresheafOfModules.pushforward φ).obj M).map f)) m) ((CategoryTheory.ConcreteCategory.hom (M.map (F.map f.unop).op)) m)","decl":"lemma pushforward_obj_map_apply (M : PresheafOfModules.{v} R) {X Y : Cᵒᵖ} (f : X ⟶ Y)\n    (m : (ModuleCat.restrictScalars (φ.app X).hom).obj (M.obj (Opposite.op (F.obj X.unop)))) :\n      (((pushforward φ).obj M).map f).hom m = M.map (F.map f.unop).op m := rfl\n\n"}
{"name":"PresheafOfModules.pushforward_obj_map_apply'","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Pushforward","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nR : CategoryTheory.Functor (Opposite D) RingCat\nS : CategoryTheory.Functor (Opposite C) RingCat\nφ : Quiver.Hom S (F.op.comp R)\nM : PresheafOfModules R\nX Y : Opposite C\nf : Quiver.Hom X Y\nm : ↑((ModuleCat.restrictScalars (RingCat.Hom.hom (φ.app X))).obj (M.obj { unop := F.obj (Opposite.unop X) }))\n⊢ Eq ((ModuleCat.Hom.hom (((PresheafOfModules.pushforward φ).obj M).map f)) m) ((CategoryTheory.ConcreteCategory.hom (M.map (F.map f.unop).op)) m)","decl":"/-- `@[simp]`-normal form of `pushforward_obj_map_apply`. -/\n@[simp]\nlemma pushforward_obj_map_apply' (M : PresheafOfModules.{v} R) {X Y : Cᵒᵖ} (f : X ⟶ Y)\n    (m : (ModuleCat.restrictScalars (φ.app X).hom).obj (M.obj (Opposite.op (F.obj X.unop)))) :\n      DFunLike.coe\n        (F := ↑((ModuleCat.restrictScalars _).obj _) →ₗ[_]\n          ↑((ModuleCat.restrictScalars (S.map f).hom).obj ((ModuleCat.restrictScalars _).obj _)))\n        (((pushforward φ).obj M).map f).hom m = M.map (F.map f.unop).op m := rfl\n\n"}
{"name":"PresheafOfModules.pushforward_map_app_apply","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Pushforward","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nR : CategoryTheory.Functor (Opposite D) RingCat\nS : CategoryTheory.Functor (Opposite C) RingCat\nφ : Quiver.Hom S (F.op.comp R)\nM N : PresheafOfModules R\nα : Quiver.Hom M N\nX : Opposite C\nm : ↑((ModuleCat.restrictScalars (RingCat.Hom.hom (φ.app X))).obj (M.obj { unop := F.obj (Opposite.unop X) }))\n⊢ Eq ((ModuleCat.Hom.hom (((PresheafOfModules.pushforward φ).map α).app X)) m) ((CategoryTheory.ConcreteCategory.hom (α.app { unop := F.obj (Opposite.unop X) })) m)","decl":"lemma pushforward_map_app_apply {M N : PresheafOfModules.{v} R} (α : M ⟶ N) (X : Cᵒᵖ)\n    (m : (ModuleCat.restrictScalars (φ.app X).hom).obj (M.obj (Opposite.op (F.obj X.unop)))) :\n    (((pushforward φ).map α).app X).hom m = α.app (Opposite.op (F.obj X.unop)) m := rfl\n\n"}
{"name":"PresheafOfModules.pushforward_map_app_apply'","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Pushforward","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nR : CategoryTheory.Functor (Opposite D) RingCat\nS : CategoryTheory.Functor (Opposite C) RingCat\nφ : Quiver.Hom S (F.op.comp R)\nM N : PresheafOfModules R\nα : Quiver.Hom M N\nX : Opposite C\nm : ↑((ModuleCat.restrictScalars (RingCat.Hom.hom (φ.app X))).obj (M.obj { unop := F.obj (Opposite.unop X) }))\n⊢ Eq ((ModuleCat.Hom.hom (((PresheafOfModules.pushforward φ).map α).app X)) m) ((CategoryTheory.ConcreteCategory.hom (α.app { unop := F.obj (Opposite.unop X) })) m)","decl":"/-- `@[simp]`-normal form of `pushforward_map_app_apply`. -/\n@[simp]\nlemma pushforward_map_app_apply' {M N : PresheafOfModules.{v} R} (α : M ⟶ N) (X : Cᵒᵖ)\n    (m : (ModuleCat.restrictScalars (φ.app X).hom).obj (M.obj (Opposite.op (F.obj X.unop)))) :\n    DFunLike.coe\n      (F := ↑((ModuleCat.restrictScalars _).obj _) →ₗ[_] ↑((ModuleCat.restrictScalars _).obj _))\n      (((pushforward φ).map α).app X).hom m = α.app (Opposite.op (F.obj X.unop)) m := rfl\n\n"}
