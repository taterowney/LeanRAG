{"name":"instErgodicSMulOfIsMulLeftInvariant","module":"Mathlib.Dynamics.Ergodic.Action.Regular","initialProofState":"G : Type u_1\ninst✝² : Group G\ninst✝¹ : MeasurableSpace G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsMulLeftInvariant\n⊢ ErgodicSMul G G μ","decl":"@[to_additive]\ninstance [μ.IsMulLeftInvariant] : ErgodicSMul G G μ := by\n  refine ⟨fun {s} hsm hs ↦ ?_⟩\n  suffices (∃ᵐ x ∂μ, x ∈ s) → ∀ᵐ x ∂μ, x ∈ s by\n    simp only [eventuallyConst_set, ← not_frequently]\n    exact or_not_of_imp this\n  intro hμs\n  obtain ⟨a, has, ha⟩ : ∃ a ∈ s, ∀ᵐ b ∂μ, (b * a ∈ s ↔ a ∈ s) := by\n    refine (hμs.and_eventually ?_).exists\n    rw [ae_ae_comm]\n    · exact ae_of_all _ fun b ↦ (hs b).mem_iff\n    · exact ((hsm.preimage <| measurable_snd.mul measurable_fst).mem.iff\n        (hsm.preimage measurable_fst).mem).setOf\n  simpa [has] using (MeasureTheory.quasiMeasurePreserving_mul_right μ a⁻¹).ae ha\n\n"}
{"name":"instErgodicVAddOfIsAddLeftInvariant","module":"Mathlib.Dynamics.Ergodic.Action.Regular","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\ninst✝¹ : MeasurableSpace G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsAddLeftInvariant\n⊢ ErgodicVAdd G G μ","decl":"@[to_additive]\ninstance [μ.IsMulLeftInvariant] : ErgodicSMul G G μ := by\n  refine ⟨fun {s} hsm hs ↦ ?_⟩\n  suffices (∃ᵐ x ∂μ, x ∈ s) → ∀ᵐ x ∂μ, x ∈ s by\n    simp only [eventuallyConst_set, ← not_frequently]\n    exact or_not_of_imp this\n  intro hμs\n  obtain ⟨a, has, ha⟩ : ∃ a ∈ s, ∀ᵐ b ∂μ, (b * a ∈ s ↔ a ∈ s) := by\n    refine (hμs.and_eventually ?_).exists\n    rw [ae_ae_comm]\n    · exact ae_of_all _ fun b ↦ (hs b).mem_iff\n    · exact ((hsm.preimage <| measurable_snd.mul measurable_fst).mem.iff\n        (hsm.preimage measurable_fst).mem).setOf\n  simpa [has] using (MeasureTheory.quasiMeasurePreserving_mul_right μ a⁻¹).ae ha\n\n"}
{"name":"instErgodicSMulMulOppositeOfIsMulRightInvariant","module":"Mathlib.Dynamics.Ergodic.Action.Regular","initialProofState":"G : Type u_1\ninst✝² : Group G\ninst✝¹ : MeasurableSpace G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsMulRightInvariant\n⊢ ErgodicSMul (MulOpposite G) G μ","decl":"@[to_additive]\ninstance [μ.IsMulRightInvariant] : ErgodicSMul Gᵐᵒᵖ G μ := by\n  refine ⟨fun {s} hsm hs ↦ ?_⟩\n  suffices (∃ᵐ x ∂μ, x ∈ s) → ∀ᵐ x ∂μ, x ∈ s by\n    simp only [eventuallyConst_set, ← not_frequently]\n    exact or_not_of_imp this\n  intro hμs\n  obtain ⟨a, has, ha⟩ : ∃ a ∈ s, ∀ᵐ b ∂μ, (a * b ∈ s ↔ a ∈ s) := by\n    refine (hμs.and_eventually ?_).exists\n    rw [ae_ae_comm]\n    · exact ae_of_all _ fun b ↦ (hs ⟨b⟩).mem_iff\n    · exact ((hsm.preimage <| measurable_fst.mul measurable_snd).mem.iff\n        (hsm.preimage measurable_fst).mem).setOf\n  simpa [has] using (quasiMeasurePreserving_mul_left μ a⁻¹).ae ha\n"}
{"name":"instErgodicVAddAddOppositeOfIsAddRightInvariant","module":"Mathlib.Dynamics.Ergodic.Action.Regular","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\ninst✝¹ : MeasurableSpace G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsAddRightInvariant\n⊢ ErgodicVAdd (AddOpposite G) G μ","decl":"@[to_additive]\ninstance [μ.IsMulRightInvariant] : ErgodicSMul Gᵐᵒᵖ G μ := by\n  refine ⟨fun {s} hsm hs ↦ ?_⟩\n  suffices (∃ᵐ x ∂μ, x ∈ s) → ∀ᵐ x ∂μ, x ∈ s by\n    simp only [eventuallyConst_set, ← not_frequently]\n    exact or_not_of_imp this\n  intro hμs\n  obtain ⟨a, has, ha⟩ : ∃ a ∈ s, ∀ᵐ b ∂μ, (a * b ∈ s ↔ a ∈ s) := by\n    refine (hμs.and_eventually ?_).exists\n    rw [ae_ae_comm]\n    · exact ae_of_all _ fun b ↦ (hs ⟨b⟩).mem_iff\n    · exact ((hsm.preimage <| measurable_fst.mul measurable_snd).mem.iff\n        (hsm.preimage measurable_fst).mem).setOf\n  simpa [has] using (quasiMeasurePreserving_mul_left μ a⁻¹).ae ha\n"}
