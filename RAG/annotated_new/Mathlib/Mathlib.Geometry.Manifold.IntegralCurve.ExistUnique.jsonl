{"name":"exists_isIntegralCurveAt_of_contMDiffAt","module":"Mathlib.Geometry.Manifold.IntegralCurve.ExistUnique","initialProofState":"E : Type u_1\ninst‚úù‚Å∂ : NormedAddCommGroup E\ninst‚úù‚Åµ : NormedSpace Real E\nH : Type u_2\ninst‚úù‚Å¥ : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type u_3\ninst‚úù¬≥ : TopologicalSpace M\ninst‚úù¬≤ : ChartedSpace H M\ninst‚úù¬π : IsManifold I 1 M\nv : (x : M) ‚Üí TangentSpace I x\nt‚ÇÄ : Real\nx‚ÇÄ : M\ninst‚úù : CompleteSpace E\nhv : ContMDiffAt I I.tangent 1 (fun x => { proj := x, snd := v x }) x‚ÇÄ\nhx : I.IsInteriorPoint x‚ÇÄ\n‚ä¢ Exists fun Œ≥ => And (Eq (Œ≥ t‚ÇÄ) x‚ÇÄ) (IsIntegralCurveAt Œ≥ v t‚ÇÄ)","decl":"/-- Existence of local integral curves for a $C^1$ vector field at interior points of a `C^1`\nmanifold. -/\ntheorem exists_isIntegralCurveAt_of_contMDiffAt [CompleteSpace E]\n    (hv : ContMDiffAt I I.tangent 1 (fun x ‚Ü¶ (‚ü®x, v x‚ü© : TangentBundle I M)) x‚ÇÄ)\n    (hx : I.IsInteriorPoint x‚ÇÄ) :\n    ‚àÉ Œ≥ : ‚Ñù ‚Üí M, Œ≥ t‚ÇÄ = x‚ÇÄ ‚àß IsIntegralCurveAt Œ≥ v t‚ÇÄ := by\n  -- express the differentiability of the vector field `v` in the local chart\n  rw [contMDiffAt_iff] at hv\n  obtain ‚ü®_, hv‚ü© := hv\n  -- use Picard-Lindel√∂f theorem to extract a solution to the ODE in the local chart\n  obtain ‚ü®f, hf1, hf2‚ü© := exists_forall_hasDerivAt_Ioo_eq_of_contDiffAt t‚ÇÄ\n    (hv.contDiffAt (range_mem_nhds_isInteriorPoint hx)).snd\n  simp_rw [‚Üê Real.ball_eq_Ioo, ‚Üê Metric.eventually_nhds_iff_ball] at hf2\n  -- use continuity of `f` so that `f t` remains inside `interior (extChartAt I x‚ÇÄ).target`\n  have ‚ü®a, ha, hf2'‚ü© := Metric.eventually_nhds_iff_ball.mp hf2\n  have hcont := (hf2' t‚ÇÄ (Metric.mem_ball_self ha)).continuousAt\n  rw [continuousAt_def, hf1] at hcont\n  have hnhds : f ‚Åª¬π' (interior (extChartAt I x‚ÇÄ).target) ‚àà ùìù t‚ÇÄ :=\n    hcont _ (isOpen_interior.mem_nhds ((I.isInteriorPoint_iff).mp hx))\n  rw [‚Üê eventually_mem_nhds_iff] at hnhds\n  -- obtain a neighbourhood `s` so that the above conditions both hold in `s`\n  obtain ‚ü®s, hs, haux‚ü© := (hf2.and hnhds).exists_mem\n  -- prove that `Œ≥ := (extChartAt I x‚ÇÄ).symm ‚àò f` is a desired integral curve\n  refine ‚ü®(extChartAt I x‚ÇÄ).symm ‚àò f,\n    Eq.symm (by rw [Function.comp_apply, hf1, PartialEquiv.left_inv _ (mem_extChartAt_source ..)]),\n    isIntegralCurveAt_iff.mpr ‚ü®s, hs, ?_‚ü©‚ü©\n  intros t ht\n  -- collect useful terms in convenient forms\n  let x‚Çú : M := (extChartAt I x‚ÇÄ).symm (f t) -- `x‚Çú := Œ≥ t`\n  have h : HasDerivAt f (x := t) <| fderivWithin ‚Ñù (extChartAt I x‚ÇÄ ‚àò (extChartAt I x‚Çú).symm)\n    (range I) (extChartAt I x‚Çú x‚Çú) (v x‚Çú) := (haux t ht).1\n  rw [‚Üê tangentCoordChange_def] at h\n  have hf3 := mem_preimage.mp <| mem_of_mem_nhds (haux t ht).2\n  have hf3' := mem_of_mem_of_subset hf3 interior_subset\n  have hft1 := mem_preimage.mp <|\n    mem_of_mem_of_subset hf3' (extChartAt I x‚ÇÄ).target_subset_preimage_source\n  have hft2 := mem_extChartAt_source (I := I) x‚Çú\n  -- express the derivative of the integral curve in the local chart\n  refine ‚ü®(continuousAt_extChartAt_symm'' hf3').comp h.continuousAt,\n    HasDerivWithinAt.hasFDerivWithinAt ?_‚ü©\n  simp only [mfld_simps, hasDerivWithinAt_univ]\n  show HasDerivAt ((extChartAt I x‚Çú ‚àò (extChartAt I x‚ÇÄ).symm) ‚àò f) (v x‚Çú) t\n  -- express `v (Œ≥ t)` as `D‚Åª¬π D (v (Œ≥ t))`, where `D` is a change of coordinates, so we can use\n  -- `HasFDerivAt.comp_hasDerivAt` on `h`\n  rw [‚Üê tangentCoordChange_self (I := I) (x := x‚Çú) (z := x‚Çú) (v := v x‚Çú) hft2,\n    ‚Üê tangentCoordChange_comp (x := x‚ÇÄ) ‚ü®‚ü®hft2, hft1‚ü©, hft2‚ü©]\n  apply HasFDerivAt.comp_hasDerivAt _ _ h\n  apply HasFDerivWithinAt.hasFDerivAt (s := range I) _ <|\n    mem_nhds_iff.mpr ‚ü®interior (extChartAt I x‚ÇÄ).target,\n      subset_trans interior_subset (extChartAt_target_subset_range ..),\n      isOpen_interior, hf3‚ü©\n  rw [‚Üê (extChartAt I x‚ÇÄ).right_inv hf3']\n  exact hasFDerivWithinAt_tangentCoordChange ‚ü®hft1, hft2‚ü©\n\n"}
{"name":"exists_isIntegralCurveAt_of_contMDiffAt_boundaryless","module":"Mathlib.Geometry.Manifold.IntegralCurve.ExistUnique","initialProofState":"E : Type u_1\ninst‚úù‚Å∑ : NormedAddCommGroup E\ninst‚úù‚Å∂ : NormedSpace Real E\nH : Type u_2\ninst‚úù‚Åµ : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type u_3\ninst‚úù‚Å¥ : TopologicalSpace M\ninst‚úù¬≥ : ChartedSpace H M\ninst‚úù¬≤ : IsManifold I 1 M\nv : (x : M) ‚Üí TangentSpace I x\nt‚ÇÄ : Real\nx‚ÇÄ : M\ninst‚úù¬π : CompleteSpace E\ninst‚úù : BoundarylessManifold I M\nhv : ContMDiffAt I I.tangent 1 (fun x => { proj := x, snd := v x }) x‚ÇÄ\n‚ä¢ Exists fun Œ≥ => And (Eq (Œ≥ t‚ÇÄ) x‚ÇÄ) (IsIntegralCurveAt Œ≥ v t‚ÇÄ)","decl":"/-- Existence of local integral curves for a $C^1$ vector field on a `C^1` manifold without\nboundary. -/\nlemma exists_isIntegralCurveAt_of_contMDiffAt_boundaryless\n    [CompleteSpace E] [BoundarylessManifold I M]\n    (hv : ContMDiffAt I I.tangent 1 (fun x ‚Ü¶ (‚ü®x, v x‚ü© : TangentBundle I M)) x‚ÇÄ) :\n    ‚àÉ Œ≥ : ‚Ñù ‚Üí M, Œ≥ t‚ÇÄ = x‚ÇÄ ‚àß IsIntegralCurveAt Œ≥ v t‚ÇÄ :=\n  exists_isIntegralCurveAt_of_contMDiffAt t‚ÇÄ hv BoundarylessManifold.isInteriorPoint\n\n"}
{"name":"isIntegralCurveAt_eventuallyEq_of_contMDiffAt","module":"Mathlib.Geometry.Manifold.IntegralCurve.ExistUnique","initialProofState":"E : Type u_1\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedSpace Real E\nH : Type u_2\ninst‚úù¬≥ : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type u_3\ninst‚úù¬≤ : TopologicalSpace M\ninst‚úù¬π : ChartedSpace H M\ninst‚úù : IsManifold I 1 M\nŒ≥ Œ≥' : Real ‚Üí M\nv : (x : M) ‚Üí TangentSpace I x\nt‚ÇÄ : Real\nhŒ≥t‚ÇÄ : I.IsInteriorPoint (Œ≥ t‚ÇÄ)\nhv : ContMDiffAt I I.tangent 1 (fun x => { proj := x, snd := v x }) (Œ≥ t‚ÇÄ)\nhŒ≥ : IsIntegralCurveAt Œ≥ v t‚ÇÄ\nhŒ≥' : IsIntegralCurveAt Œ≥' v t‚ÇÄ\nh : Eq (Œ≥ t‚ÇÄ) (Œ≥' t‚ÇÄ)\n‚ä¢ (nhds t‚ÇÄ).EventuallyEq Œ≥ Œ≥'","decl":"/-- Local integral curves are unique.\n\nIf a $C^1$ vector field `v` admits two local integral curves `Œ≥ Œ≥' : ‚Ñù ‚Üí M` at `t‚ÇÄ` with\n`Œ≥ t‚ÇÄ = Œ≥' t‚ÇÄ`, then `Œ≥` and `Œ≥'` agree on some open interval containing `t‚ÇÄ`. -/\ntheorem isIntegralCurveAt_eventuallyEq_of_contMDiffAt (hŒ≥t‚ÇÄ : I.IsInteriorPoint (Œ≥ t‚ÇÄ))\n    (hv : ContMDiffAt I I.tangent 1 (fun x ‚Ü¶ (‚ü®x, v x‚ü© : TangentBundle I M)) (Œ≥ t‚ÇÄ))\n    (hŒ≥ : IsIntegralCurveAt Œ≥ v t‚ÇÄ) (hŒ≥' : IsIntegralCurveAt Œ≥' v t‚ÇÄ) (h : Œ≥ t‚ÇÄ = Œ≥' t‚ÇÄ) :\n    Œ≥ =·∂†[ùìù t‚ÇÄ] Œ≥' := by\n  -- first define `v'` as the vector field expressed in the local chart around `Œ≥ t‚ÇÄ`\n  -- this is basically what the function looks like when `hv` is unfolded\n  set v' : E ‚Üí E := fun x ‚Ü¶\n    tangentCoordChange I ((extChartAt I (Œ≥ t‚ÇÄ)).symm x) (Œ≥ t‚ÇÄ) ((extChartAt I (Œ≥ t‚ÇÄ)).symm x)\n      (v ((extChartAt I (Œ≥ t‚ÇÄ)).symm x)) with hv'\n  -- extract a set `s` on which `v'` is Lipschitz\n  rw [contMDiffAt_iff] at hv\n  obtain ‚ü®_, hv‚ü© := hv\n  obtain ‚ü®K, s, hs, hlip‚ü© : ‚àÉ K, ‚àÉ s ‚àà ùìù _, LipschitzOnWith K v' s :=\n    (hv.contDiffAt (range_mem_nhds_isInteriorPoint hŒ≥t‚ÇÄ)).snd.exists_lipschitzOnWith\n  have hlip (t : ‚Ñù) : LipschitzOnWith K ((fun _ ‚Ü¶ v') t) ((fun _ ‚Ü¶ s) t) := hlip\n  -- internal lemmas to reduce code duplication\n  have hsrc {g} (hg : IsIntegralCurveAt g v t‚ÇÄ) :\n    ‚àÄ·∂† t in ùìù t‚ÇÄ, g ‚Åª¬π' (extChartAt I (g t‚ÇÄ)).source ‚àà ùìù t := eventually_mem_nhds_iff.mpr <|\n      continuousAt_def.mp hg.continuousAt _ <| extChartAt_source_mem_nhds (g t‚ÇÄ)\n  have hmem {g : ‚Ñù ‚Üí M} {t} (ht : g ‚Åª¬π' (extChartAt I (g t‚ÇÄ)).source ‚àà ùìù t) :\n    g t ‚àà (extChartAt I (g t‚ÇÄ)).source := mem_preimage.mp <| mem_of_mem_nhds ht\n  have hdrv {g} (hg : IsIntegralCurveAt g v t‚ÇÄ) (h' : Œ≥ t‚ÇÄ = g t‚ÇÄ) : ‚àÄ·∂† t in ùìù t‚ÇÄ,\n      HasDerivAt ((extChartAt I (g t‚ÇÄ)) ‚àò g) ((fun _ ‚Ü¶ v') t (((extChartAt I (g t‚ÇÄ)) ‚àò g) t)) t ‚àß\n      ((extChartAt I (g t‚ÇÄ)) ‚àò g) t ‚àà (fun _ ‚Ü¶ s) t := by\n    apply Filter.Eventually.and\n    ¬∑ apply (hsrc hg |>.and hg.eventually_hasDerivAt).mono\n      rintro t ‚ü®ht1, ht2‚ü©\n      rw [hv', h']\n      apply ht2.congr_deriv\n      congr <;>\n      rw [Function.comp_apply, PartialEquiv.left_inv _ (hmem ht1)]\n    ¬∑ apply ((continuousAt_extChartAt (g t‚ÇÄ)).comp hg.continuousAt).preimage_mem_nhds\n      rw [Function.comp_apply, ‚Üê h']\n      exact hs\n  have heq {g} (hg : IsIntegralCurveAt g v t‚ÇÄ) :\n    g =·∂†[ùìù t‚ÇÄ] (extChartAt I (g t‚ÇÄ)).symm ‚àò ‚Üë(extChartAt I (g t‚ÇÄ)) ‚àò g := by\n    apply (hsrc hg).mono\n    intros t ht\n    rw [Function.comp_apply, Function.comp_apply, PartialEquiv.left_inv _ (hmem ht)]\n  -- main proof\n  suffices (extChartAt I (Œ≥ t‚ÇÄ)) ‚àò Œ≥ =·∂†[ùìù t‚ÇÄ] (extChartAt I (Œ≥' t‚ÇÄ)) ‚àò Œ≥' from\n    (heq hŒ≥).trans <| (this.fun_comp (extChartAt I (Œ≥ t‚ÇÄ)).symm).trans (h ‚ñ∏ (heq hŒ≥').symm)\n  exact ODE_solution_unique_of_eventually (.of_forall hlip)\n    (hdrv hŒ≥ rfl) (hdrv hŒ≥' h) (by rw [Function.comp_apply, Function.comp_apply, h])\n\n"}
{"name":"isIntegralCurveAt_eventuallyEq_of_contMDiffAt_boundaryless","module":"Mathlib.Geometry.Manifold.IntegralCurve.ExistUnique","initialProofState":"E : Type u_1\ninst‚úù‚Å∂ : NormedAddCommGroup E\ninst‚úù‚Åµ : NormedSpace Real E\nH : Type u_2\ninst‚úù‚Å¥ : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type u_3\ninst‚úù¬≥ : TopologicalSpace M\ninst‚úù¬≤ : ChartedSpace H M\ninst‚úù¬π : IsManifold I 1 M\nŒ≥ Œ≥' : Real ‚Üí M\nv : (x : M) ‚Üí TangentSpace I x\nt‚ÇÄ : Real\ninst‚úù : BoundarylessManifold I M\nhv : ContMDiffAt I I.tangent 1 (fun x => { proj := x, snd := v x }) (Œ≥ t‚ÇÄ)\nhŒ≥ : IsIntegralCurveAt Œ≥ v t‚ÇÄ\nhŒ≥' : IsIntegralCurveAt Œ≥' v t‚ÇÄ\nh : Eq (Œ≥ t‚ÇÄ) (Œ≥' t‚ÇÄ)\n‚ä¢ (nhds t‚ÇÄ).EventuallyEq Œ≥ Œ≥'","decl":"theorem isIntegralCurveAt_eventuallyEq_of_contMDiffAt_boundaryless [BoundarylessManifold I M]\n    (hv : ContMDiffAt I I.tangent 1 (fun x ‚Ü¶ (‚ü®x, v x‚ü© : TangentBundle I M)) (Œ≥ t‚ÇÄ))\n    (hŒ≥ : IsIntegralCurveAt Œ≥ v t‚ÇÄ) (hŒ≥' : IsIntegralCurveAt Œ≥' v t‚ÇÄ) (h : Œ≥ t‚ÇÄ = Œ≥' t‚ÇÄ) :\n    Œ≥ =·∂†[ùìù t‚ÇÄ] Œ≥' :=\n  isIntegralCurveAt_eventuallyEq_of_contMDiffAt BoundarylessManifold.isInteriorPoint hv hŒ≥ hŒ≥' h\n\n"}
{"name":"isIntegralCurveOn_Ioo_eqOn_of_contMDiff","module":"Mathlib.Geometry.Manifold.IntegralCurve.ExistUnique","initialProofState":"E : Type u_1\ninst‚úù‚Å∂ : NormedAddCommGroup E\ninst‚úù‚Åµ : NormedSpace Real E\nH : Type u_2\ninst‚úù‚Å¥ : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type u_3\ninst‚úù¬≥ : TopologicalSpace M\ninst‚úù¬≤ : ChartedSpace H M\ninst‚úù¬π : IsManifold I 1 M\nŒ≥ Œ≥' : Real ‚Üí M\nv : (x : M) ‚Üí TangentSpace I x\nt‚ÇÄ : Real\ninst‚úù : T2Space M\na b : Real\nht‚ÇÄ : Membership.mem (Set.Ioo a b) t‚ÇÄ\nhŒ≥t : ‚àÄ (t : Real), Membership.mem (Set.Ioo a b) t ‚Üí I.IsInteriorPoint (Œ≥ t)\nhv : ContMDiff I I.tangent 1 fun x => { proj := x, snd := v x }\nhŒ≥ : IsIntegralCurveOn Œ≥ v (Set.Ioo a b)\nhŒ≥' : IsIntegralCurveOn Œ≥' v (Set.Ioo a b)\nh : Eq (Œ≥ t‚ÇÄ) (Œ≥' t‚ÇÄ)\n‚ä¢ Set.EqOn Œ≥ Œ≥' (Set.Ioo a b)","decl":"/-- Integral curves are unique on open intervals.\n\nIf a $C^1$ vector field `v` admits two integral curves `Œ≥ Œ≥' : ‚Ñù ‚Üí M` on some open interval\n`Ioo a b`, and `Œ≥ t‚ÇÄ = Œ≥' t‚ÇÄ` for some `t ‚àà Ioo a b`, then `Œ≥` and `Œ≥'` agree on `Ioo a b`. -/\ntheorem isIntegralCurveOn_Ioo_eqOn_of_contMDiff (ht‚ÇÄ : t‚ÇÄ ‚àà Ioo a b)\n    (hŒ≥t : ‚àÄ t ‚àà Ioo a b, I.IsInteriorPoint (Œ≥ t))\n    (hv : ContMDiff I I.tangent 1 (fun x ‚Ü¶ (‚ü®x, v x‚ü© : TangentBundle I M)))\n    (hŒ≥ : IsIntegralCurveOn Œ≥ v (Ioo a b)) (hŒ≥' : IsIntegralCurveOn Œ≥' v (Ioo a b))\n    (h : Œ≥ t‚ÇÄ = Œ≥' t‚ÇÄ) : EqOn Œ≥ Œ≥' (Ioo a b) := by\n  set s := {t | Œ≥ t = Œ≥' t} ‚à© Ioo a b with hs\n  -- since `Ioo a b` is connected, we get `s = Ioo a b` by showing that `s` is clopen in `Ioo a b`\n  -- in the subtype topology (`s` is also non-empty by assumption)\n  -- here we use a slightly weaker alternative theorem\n  suffices hsub : Ioo a b ‚äÜ s from fun t ht ‚Ü¶ mem_setOf.mp ((subset_def ‚ñ∏ hsub) t ht).1\n  apply isPreconnected_Ioo.subset_of_closure_inter_subset (s := Ioo a b) (u := s) _\n    ‚ü®t‚ÇÄ, ‚ü®ht‚ÇÄ, ‚ü®h, ht‚ÇÄ‚ü©‚ü©‚ü©\n  ¬∑ -- is this really the most convenient way to pass to subtype topology?\n    -- TODO: shorten this when better API around subtype topology exists\n    rw [hs, inter_comm, ‚Üê Subtype.image_preimage_val, inter_comm, ‚Üê Subtype.image_preimage_val,\n      image_subset_image_iff Subtype.val_injective, preimage_setOf_eq]\n    intros t ht\n    rw [mem_preimage, ‚Üê closure_subtype] at ht\n    revert ht t\n    apply IsClosed.closure_subset (isClosed_eq _ _)\n    ¬∑ rw [continuous_iff_continuousAt]\n      rintro ‚ü®_, ht‚ü©\n      apply ContinuousAt.comp _ continuousAt_subtype_val\n      rw [Subtype.coe_mk]\n      exact hŒ≥.continuousAt ht\n    ¬∑ rw [continuous_iff_continuousAt]\n      rintro ‚ü®_, ht‚ü©\n      apply ContinuousAt.comp _ continuousAt_subtype_val\n      rw [Subtype.coe_mk]\n      exact hŒ≥'.continuousAt ht\n  ¬∑ rw [isOpen_iff_mem_nhds]\n    intro t‚ÇÅ ht‚ÇÅ\n    have hmem := Ioo_mem_nhds ht‚ÇÅ.2.1 ht‚ÇÅ.2.2\n    have heq : Œ≥ =·∂†[ùìù t‚ÇÅ] Œ≥' := isIntegralCurveAt_eventuallyEq_of_contMDiffAt\n      (hŒ≥t _ ht‚ÇÅ.2) hv.contMDiffAt (hŒ≥.isIntegralCurveAt hmem) (hŒ≥'.isIntegralCurveAt hmem) ht‚ÇÅ.1\n    apply (heq.and hmem).mono\n    exact fun _ ht ‚Ü¶ ht\n\n"}
{"name":"isIntegralCurveOn_Ioo_eqOn_of_contMDiff_boundaryless","module":"Mathlib.Geometry.Manifold.IntegralCurve.ExistUnique","initialProofState":"E : Type u_1\ninst‚úù‚Å∑ : NormedAddCommGroup E\ninst‚úù‚Å∂ : NormedSpace Real E\nH : Type u_2\ninst‚úù‚Åµ : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type u_3\ninst‚úù‚Å¥ : TopologicalSpace M\ninst‚úù¬≥ : ChartedSpace H M\ninst‚úù¬≤ : IsManifold I 1 M\nŒ≥ Œ≥' : Real ‚Üí M\nv : (x : M) ‚Üí TangentSpace I x\nt‚ÇÄ : Real\ninst‚úù¬π : T2Space M\na b : Real\ninst‚úù : BoundarylessManifold I M\nht‚ÇÄ : Membership.mem (Set.Ioo a b) t‚ÇÄ\nhv : ContMDiff I I.tangent 1 fun x => { proj := x, snd := v x }\nhŒ≥ : IsIntegralCurveOn Œ≥ v (Set.Ioo a b)\nhŒ≥' : IsIntegralCurveOn Œ≥' v (Set.Ioo a b)\nh : Eq (Œ≥ t‚ÇÄ) (Œ≥' t‚ÇÄ)\n‚ä¢ Set.EqOn Œ≥ Œ≥' (Set.Ioo a b)","decl":"theorem isIntegralCurveOn_Ioo_eqOn_of_contMDiff_boundaryless [BoundarylessManifold I M]\n    (ht‚ÇÄ : t‚ÇÄ ‚àà Ioo a b)\n    (hv : ContMDiff I I.tangent 1 (fun x ‚Ü¶ (‚ü®x, v x‚ü© : TangentBundle I M)))\n    (hŒ≥ : IsIntegralCurveOn Œ≥ v (Ioo a b)) (hŒ≥' : IsIntegralCurveOn Œ≥' v (Ioo a b))\n    (h : Œ≥ t‚ÇÄ = Œ≥' t‚ÇÄ) : EqOn Œ≥ Œ≥' (Ioo a b) :=\n  isIntegralCurveOn_Ioo_eqOn_of_contMDiff\n    ht‚ÇÄ (fun _ _ ‚Ü¶ BoundarylessManifold.isInteriorPoint) hv hŒ≥ hŒ≥' h\n\n"}
{"name":"isIntegralCurve_eq_of_contMDiff","module":"Mathlib.Geometry.Manifold.IntegralCurve.ExistUnique","initialProofState":"E : Type u_1\ninst‚úù‚Å∂ : NormedAddCommGroup E\ninst‚úù‚Åµ : NormedSpace Real E\nH : Type u_2\ninst‚úù‚Å¥ : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type u_3\ninst‚úù¬≥ : TopologicalSpace M\ninst‚úù¬≤ : ChartedSpace H M\ninst‚úù¬π : IsManifold I 1 M\nŒ≥ Œ≥' : Real ‚Üí M\nv : (x : M) ‚Üí TangentSpace I x\nt‚ÇÄ : Real\ninst‚úù : T2Space M\nhŒ≥t : ‚àÄ (t : Real), I.IsInteriorPoint (Œ≥ t)\nhv : ContMDiff I I.tangent 1 fun x => { proj := x, snd := v x }\nhŒ≥ : IsIntegralCurve Œ≥ v\nhŒ≥' : IsIntegralCurve Œ≥' v\nh : Eq (Œ≥ t‚ÇÄ) (Œ≥' t‚ÇÄ)\n‚ä¢ Eq Œ≥ Œ≥'","decl":"/-- Global integral curves are unique.\n\nIf a continuously differentiable vector field `v` admits two global integral curves\n`Œ≥ Œ≥' : ‚Ñù ‚Üí M`, and `Œ≥ t‚ÇÄ = Œ≥' t‚ÇÄ` for some `t‚ÇÄ`, then `Œ≥` and `Œ≥'` are equal. -/\ntheorem isIntegralCurve_eq_of_contMDiff (hŒ≥t : ‚àÄ t, I.IsInteriorPoint (Œ≥ t))\n    (hv : ContMDiff I I.tangent 1 (fun x ‚Ü¶ (‚ü®x, v x‚ü© : TangentBundle I M)))\n    (hŒ≥ : IsIntegralCurve Œ≥ v) (hŒ≥' : IsIntegralCurve Œ≥' v) (h : Œ≥ t‚ÇÄ = Œ≥' t‚ÇÄ) : Œ≥ = Œ≥' := by\n  ext t\n  obtain ‚ü®T, ht‚ÇÄ, ht‚ü© : ‚àÉ T, t ‚àà Ioo (-T) T ‚àß t‚ÇÄ ‚àà Ioo (-T) T := by\n    obtain ‚ü®T, hT‚ÇÅ, hT‚ÇÇ‚ü© := exists_abs_lt t\n    obtain ‚ü®hT‚ÇÇ, hT‚ÇÉ‚ü© := abs_lt.mp hT‚ÇÇ\n    obtain ‚ü®S, hS‚ÇÅ, hS‚ÇÇ‚ü© := exists_abs_lt t‚ÇÄ\n    obtain ‚ü®hS‚ÇÇ, hS‚ÇÉ‚ü© := abs_lt.mp hS‚ÇÇ\n    exact ‚ü®T + S, by constructor <;> constructor <;> linarith‚ü©\n  exact isIntegralCurveOn_Ioo_eqOn_of_contMDiff ht (fun t _ ‚Ü¶ hŒ≥t t) hv\n    ((hŒ≥.isIntegralCurveOn _).mono (subset_univ _))\n    ((hŒ≥'.isIntegralCurveOn _).mono (subset_univ _)) h ht‚ÇÄ\n\n"}
{"name":"isIntegralCurve_Ioo_eq_of_contMDiff_boundaryless","module":"Mathlib.Geometry.Manifold.IntegralCurve.ExistUnique","initialProofState":"E : Type u_1\ninst‚úù‚Å∑ : NormedAddCommGroup E\ninst‚úù‚Å∂ : NormedSpace Real E\nH : Type u_2\ninst‚úù‚Åµ : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type u_3\ninst‚úù‚Å¥ : TopologicalSpace M\ninst‚úù¬≥ : ChartedSpace H M\ninst‚úù¬≤ : IsManifold I 1 M\nŒ≥ Œ≥' : Real ‚Üí M\nv : (x : M) ‚Üí TangentSpace I x\nt‚ÇÄ : Real\ninst‚úù¬π : T2Space M\ninst‚úù : BoundarylessManifold I M\nhv : ContMDiff I I.tangent 1 fun x => { proj := x, snd := v x }\nhŒ≥ : IsIntegralCurve Œ≥ v\nhŒ≥' : IsIntegralCurve Œ≥' v\nh : Eq (Œ≥ t‚ÇÄ) (Œ≥' t‚ÇÄ)\n‚ä¢ Eq Œ≥ Œ≥'","decl":"theorem isIntegralCurve_Ioo_eq_of_contMDiff_boundaryless [BoundarylessManifold I M]\n    (hv : ContMDiff I I.tangent 1 (fun x ‚Ü¶ (‚ü®x, v x‚ü© : TangentBundle I M)))\n    (hŒ≥ : IsIntegralCurve Œ≥ v) (hŒ≥' : IsIntegralCurve Œ≥' v) (h : Œ≥ t‚ÇÄ = Œ≥' t‚ÇÄ) : Œ≥ = Œ≥' :=\n  isIntegralCurve_eq_of_contMDiff (fun _ ‚Ü¶ BoundarylessManifold.isInteriorPoint) hv hŒ≥ hŒ≥' h\n\n"}
{"name":"IsIntegralCurve.periodic_of_eq","module":"Mathlib.Geometry.Manifold.IntegralCurve.ExistUnique","initialProofState":"E : Type u_1\ninst‚úù‚Å∑ : NormedAddCommGroup E\ninst‚úù‚Å∂ : NormedSpace Real E\nH : Type u_2\ninst‚úù‚Åµ : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type u_3\ninst‚úù‚Å¥ : TopologicalSpace M\ninst‚úù¬≥ : ChartedSpace H M\ninst‚úù¬≤ : IsManifold I 1 M\nŒ≥ : Real ‚Üí M\nv : (x : M) ‚Üí TangentSpace I x\ninst‚úù¬π : T2Space M\na b : Real\ninst‚úù : BoundarylessManifold I M\nhŒ≥ : IsIntegralCurve Œ≥ v\nhv : ContMDiff I I.tangent 1 fun x => { proj := x, snd := v x }\nheq : Eq (Œ≥ a) (Œ≥ b)\n‚ä¢ Function.Periodic Œ≥ (HSub.hSub a b)","decl":"/-- For a global integral curve `Œ≥`, if it crosses itself at `a b : ‚Ñù`, then it is periodic with\nperiod `a - b`. -/\nlemma IsIntegralCurve.periodic_of_eq [BoundarylessManifold I M]\n    (hŒ≥ : IsIntegralCurve Œ≥ v)\n    (hv : ContMDiff I I.tangent 1 (fun x ‚Ü¶ (‚ü®x, v x‚ü© : TangentBundle I M)))\n    (heq : Œ≥ a = Œ≥ b) : Periodic Œ≥ (a - b) := by\n  intro t\n  apply congrFun <|\n    isIntegralCurve_Ioo_eq_of_contMDiff_boundaryless (t‚ÇÄ := b) hv (hŒ≥.comp_add _) hŒ≥ _\n  rw [comp_apply, add_sub_cancel, heq]\n\n"}
{"name":"IsIntegralCurve.periodic_xor_injective","module":"Mathlib.Geometry.Manifold.IntegralCurve.ExistUnique","initialProofState":"E : Type u_1\ninst‚úù‚Å∑ : NormedAddCommGroup E\ninst‚úù‚Å∂ : NormedSpace Real E\nH : Type u_2\ninst‚úù‚Åµ : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type u_3\ninst‚úù‚Å¥ : TopologicalSpace M\ninst‚úù¬≥ : ChartedSpace H M\ninst‚úù¬≤ : IsManifold I 1 M\nŒ≥ : Real ‚Üí M\nv : (x : M) ‚Üí TangentSpace I x\ninst‚úù¬π : T2Space M\ninst‚úù : BoundarylessManifold I M\nhŒ≥ : IsIntegralCurve Œ≥ v\nhv : ContMDiff I I.tangent 1 fun x => { proj := x, snd := v x }\n‚ä¢ Xor' (Exists fun T => And (GT.gt T 0) (Function.Periodic Œ≥ T)) (Function.Injective Œ≥)","decl":"/-- A global integral curve is injective xor periodic with positive period. -/\nlemma IsIntegralCurve.periodic_xor_injective [BoundarylessManifold I M]\n    (hŒ≥ : IsIntegralCurve Œ≥ v)\n    (hv : ContMDiff I I.tangent 1 (fun x ‚Ü¶ (‚ü®x, v x‚ü© : TangentBundle I M))) :\n    Xor' (‚àÉ T > 0, Periodic Œ≥ T) (Injective Œ≥) := by\n  rw [xor_iff_iff_not]\n  refine ‚ü®fun ‚ü®T, hT, hf‚ü© ‚Ü¶ hf.not_injective (ne_of_gt hT), ?_‚ü©\n  intro h\n  rw [Injective] at h\n  push_neg at h\n  obtain ‚ü®a, b, heq, hne‚ü© := h\n  refine ‚ü®|a - b|, ?_, ?_‚ü©\n  ¬∑ rw [gt_iff_lt, abs_pos, sub_ne_zero]\n    exact hne\n  ¬∑ by_cases hab : a - b < 0\n    ¬∑ rw [abs_of_neg hab, neg_sub]\n      exact hŒ≥.periodic_of_eq hv heq.symm\n    ¬∑ rw [not_lt] at hab\n      rw [abs_of_nonneg hab]\n      exact hŒ≥.periodic_of_eq hv heq\n"}
