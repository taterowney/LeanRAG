{"name":"Cubic.mk.sizeOf_spec","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\ninst✝ : SizeOf R\na b c d : R\n⊢ Eq (SizeOf.sizeOf { a := a, b := b, c := c, d := d }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a)) (SizeOf.sizeOf b)) (SizeOf.sizeOf c)) (SizeOf.sizeOf d))","decl":"/-- The structure representing a cubic polynomial. -/\n@[ext]\nstructure Cubic (R : Type*) where\n  (a b c d : R)\n\n"}
{"name":"Cubic.ext_iff","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nx y : Cubic R\n⊢ Iff (Eq x y) (And (Eq x.a y.a) (And (Eq x.b y.b) (And (Eq x.c y.c) (Eq x.d y.d))))","decl":"/-- The structure representing a cubic polynomial. -/\n@[ext]\nstructure Cubic (R : Type*) where\n  (a b c d : R)\n\n"}
{"name":"Cubic.mk.injEq","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\na✝ b✝ c✝ d✝ a b c d : R\n⊢ Eq (Eq { a := a✝, b := b✝, c := c✝, d := d✝ } { a := a, b := b, c := c, d := d }) (And (Eq a✝ a) (And (Eq b✝ b) (And (Eq c✝ c) (Eq d✝ d))))","decl":"/-- The structure representing a cubic polynomial. -/\n@[ext]\nstructure Cubic (R : Type*) where\n  (a b c d : R)\n\n"}
{"name":"Cubic.mk.inj","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\na✝ b✝ c✝ d✝ a b c d : R\nx✝ : Eq { a := a✝, b := b✝, c := c✝, d := d✝ } { a := a, b := b, c := c, d := d }\n⊢ And (Eq a✝ a) (And (Eq b✝ b) (And (Eq c✝ c) (Eq d✝ d)))","decl":"/-- The structure representing a cubic polynomial. -/\n@[ext]\nstructure Cubic (R : Type*) where\n  (a b c d : R)\n\n"}
{"name":"Cubic.ext","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nx y : Cubic R\na : Eq x.a y.a\nb : Eq x.b y.b\nc : Eq x.c y.c\nd : Eq x.d y.d\n⊢ Eq x y","decl":"/-- The structure representing a cubic polynomial. -/\n@[ext]\nstructure Cubic (R : Type*) where\n  (a b c d : R)\n\n"}
{"name":"Cubic.C_mul_prod_X_sub_C_eq","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"S : Type u_2\ninst✝ : CommRing S\nw x y z : S\n⊢ Eq (HMul.hMul (HMul.hMul (HMul.hMul (Polynomial.C w) (HSub.hSub Polynomial.X (Polynomial.C x))) (HSub.hSub Polynomial.X (Polynomial.C y))) (HSub.hSub Polynomial.X (Polynomial.C z))) { a := w, b := HMul.hMul w (Neg.neg (HAdd.hAdd (HAdd.hAdd x y) z)), c := HMul.hMul w (HAdd.hAdd (HAdd.hAdd (HMul.hMul x y) (HMul.hMul x z)) (HMul.hMul y z)), d := HMul.hMul w (Neg.neg (HMul.hMul (HMul.hMul x y) z)) }.toPoly","decl":"theorem C_mul_prod_X_sub_C_eq [CommRing S] {w x y z : S} :\n    C w * (X - C x) * (X - C y) * (X - C z) =\n      toPoly ⟨w, w * -(x + y + z), w * (x * y + x * z + y * z), w * -(x * y * z)⟩ := by\n  simp only [toPoly, C_neg, C_add, C_mul]\n  ring1\n\n"}
{"name":"Cubic.prod_X_sub_C_eq","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"S : Type u_2\ninst✝ : CommRing S\nx y z : S\n⊢ Eq (HMul.hMul (HMul.hMul (HSub.hSub Polynomial.X (Polynomial.C x)) (HSub.hSub Polynomial.X (Polynomial.C y))) (HSub.hSub Polynomial.X (Polynomial.C z))) { a := 1, b := Neg.neg (HAdd.hAdd (HAdd.hAdd x y) z), c := HAdd.hAdd (HAdd.hAdd (HMul.hMul x y) (HMul.hMul x z)) (HMul.hMul y z), d := Neg.neg (HMul.hMul (HMul.hMul x y) z) }.toPoly","decl":"theorem prod_X_sub_C_eq [CommRing S] {x y z : S} :\n    (X - C x) * (X - C y) * (X - C z) =\n      toPoly ⟨1, -(x + y + z), x * y + x * z + y * z, -(x * y * z)⟩ := by\n  rw [← one_mul <| X - C x, ← C_1, C_mul_prod_X_sub_C_eq, one_mul, one_mul, one_mul]\n\n"}
{"name":"Cubic.coeff_eq_zero","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nP : Cubic R\ninst✝ : Semiring R\nn : Nat\nhn : LT.lt 3 n\n⊢ Eq (P.toPoly.coeff n) 0","decl":"@[simp]\ntheorem coeff_eq_zero {n : ℕ} (hn : 3 < n) : P.toPoly.coeff n = 0 :=\n  coeffs.1 n hn\n\n"}
{"name":"Cubic.coeff_eq_a","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nP : Cubic R\ninst✝ : Semiring R\n⊢ Eq (P.toPoly.coeff 3) P.a","decl":"@[simp]\ntheorem coeff_eq_a : P.toPoly.coeff 3 = P.a :=\n  coeffs.2.1\n\n"}
{"name":"Cubic.coeff_eq_b","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nP : Cubic R\ninst✝ : Semiring R\n⊢ Eq (P.toPoly.coeff 2) P.b","decl":"@[simp]\ntheorem coeff_eq_b : P.toPoly.coeff 2 = P.b :=\n  coeffs.2.2.1\n\n"}
{"name":"Cubic.coeff_eq_c","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nP : Cubic R\ninst✝ : Semiring R\n⊢ Eq (P.toPoly.coeff 1) P.c","decl":"@[simp]\ntheorem coeff_eq_c : P.toPoly.coeff 1 = P.c :=\n  coeffs.2.2.2.1\n\n"}
{"name":"Cubic.coeff_eq_d","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nP : Cubic R\ninst✝ : Semiring R\n⊢ Eq (P.toPoly.coeff 0) P.d","decl":"@[simp]\ntheorem coeff_eq_d : P.toPoly.coeff 0 = P.d :=\n  coeffs.2.2.2.2\n\n"}
{"name":"Cubic.a_of_eq","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nP Q : Cubic R\ninst✝ : Semiring R\nh : Eq P.toPoly Q.toPoly\n⊢ Eq P.a Q.a","decl":"theorem a_of_eq (h : P.toPoly = Q.toPoly) : P.a = Q.a := by rw [← coeff_eq_a, h, coeff_eq_a]\n\n"}
{"name":"Cubic.b_of_eq","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nP Q : Cubic R\ninst✝ : Semiring R\nh : Eq P.toPoly Q.toPoly\n⊢ Eq P.b Q.b","decl":"theorem b_of_eq (h : P.toPoly = Q.toPoly) : P.b = Q.b := by rw [← coeff_eq_b, h, coeff_eq_b]\n\n"}
{"name":"Cubic.c_of_eq","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nP Q : Cubic R\ninst✝ : Semiring R\nh : Eq P.toPoly Q.toPoly\n⊢ Eq P.c Q.c","decl":"theorem c_of_eq (h : P.toPoly = Q.toPoly) : P.c = Q.c := by rw [← coeff_eq_c, h, coeff_eq_c]\n\n"}
{"name":"Cubic.d_of_eq","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nP Q : Cubic R\ninst✝ : Semiring R\nh : Eq P.toPoly Q.toPoly\n⊢ Eq P.d Q.d","decl":"theorem d_of_eq (h : P.toPoly = Q.toPoly) : P.d = Q.d := by rw [← coeff_eq_d, h, coeff_eq_d]\n\n"}
{"name":"Cubic.toPoly_injective","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nP Q : Cubic R\n⊢ Iff (Eq P.toPoly Q.toPoly) (Eq P Q)","decl":"theorem toPoly_injective (P Q : Cubic R) : P.toPoly = Q.toPoly ↔ P = Q :=\n  ⟨fun h ↦ Cubic.ext (a_of_eq h) (b_of_eq h) (c_of_eq h) (d_of_eq h), congr_arg toPoly⟩\n\n"}
{"name":"Cubic.of_a_eq_zero","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nP : Cubic R\ninst✝ : Semiring R\nha : Eq P.a 0\n⊢ Eq P.toPoly (HAdd.hAdd (HAdd.hAdd (HMul.hMul (Polynomial.C P.b) (HPow.hPow Polynomial.X 2)) (HMul.hMul (Polynomial.C P.c) Polynomial.X)) (Polynomial.C P.d))","decl":"theorem of_a_eq_zero (ha : P.a = 0) : P.toPoly = C P.b * X ^ 2 + C P.c * X + C P.d := by\n  rw [toPoly, ha, C_0, zero_mul, zero_add]\n\n"}
{"name":"Cubic.of_a_eq_zero'","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nb c d : R\ninst✝ : Semiring R\n⊢ Eq { a := 0, b := b, c := c, d := d }.toPoly (HAdd.hAdd (HAdd.hAdd (HMul.hMul (Polynomial.C b) (HPow.hPow Polynomial.X 2)) (HMul.hMul (Polynomial.C c) Polynomial.X)) (Polynomial.C d))","decl":"theorem of_a_eq_zero' : toPoly ⟨0, b, c, d⟩ = C b * X ^ 2 + C c * X + C d :=\n  of_a_eq_zero rfl\n\n"}
{"name":"Cubic.of_b_eq_zero","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nP : Cubic R\ninst✝ : Semiring R\nha : Eq P.a 0\nhb : Eq P.b 0\n⊢ Eq P.toPoly (HAdd.hAdd (HMul.hMul (Polynomial.C P.c) Polynomial.X) (Polynomial.C P.d))","decl":"theorem of_b_eq_zero (ha : P.a = 0) (hb : P.b = 0) : P.toPoly = C P.c * X + C P.d := by\n  rw [of_a_eq_zero ha, hb, C_0, zero_mul, zero_add]\n\n"}
{"name":"Cubic.of_b_eq_zero'","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nc d : R\ninst✝ : Semiring R\n⊢ Eq { a := 0, b := 0, c := c, d := d }.toPoly (HAdd.hAdd (HMul.hMul (Polynomial.C c) Polynomial.X) (Polynomial.C d))","decl":"theorem of_b_eq_zero' : toPoly ⟨0, 0, c, d⟩ = C c * X + C d :=\n  of_b_eq_zero rfl rfl\n\n"}
{"name":"Cubic.of_c_eq_zero","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nP : Cubic R\ninst✝ : Semiring R\nha : Eq P.a 0\nhb : Eq P.b 0\nhc : Eq P.c 0\n⊢ Eq P.toPoly (Polynomial.C P.d)","decl":"theorem of_c_eq_zero (ha : P.a = 0) (hb : P.b = 0) (hc : P.c = 0) : P.toPoly = C P.d := by\n  rw [of_b_eq_zero ha hb, hc, C_0, zero_mul, zero_add]\n\n"}
{"name":"Cubic.of_c_eq_zero'","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nd : R\ninst✝ : Semiring R\n⊢ Eq { a := 0, b := 0, c := 0, d := d }.toPoly (Polynomial.C d)","decl":"theorem of_c_eq_zero' : toPoly ⟨0, 0, 0, d⟩ = C d :=\n  of_c_eq_zero rfl rfl rfl\n\n"}
{"name":"Cubic.of_d_eq_zero","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nP : Cubic R\ninst✝ : Semiring R\nha : Eq P.a 0\nhb : Eq P.b 0\nhc : Eq P.c 0\nhd : Eq P.d 0\n⊢ Eq P.toPoly 0","decl":"theorem of_d_eq_zero (ha : P.a = 0) (hb : P.b = 0) (hc : P.c = 0) (hd : P.d = 0) :\n    P.toPoly = 0 := by\n  rw [of_c_eq_zero ha hb hc, hd, C_0]\n\n"}
{"name":"Cubic.of_d_eq_zero'","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\ninst✝ : Semiring R\n⊢ Eq { a := 0, b := 0, c := 0, d := 0 }.toPoly 0","decl":"theorem of_d_eq_zero' : (⟨0, 0, 0, 0⟩ : Cubic R).toPoly = 0 :=\n  of_d_eq_zero rfl rfl rfl rfl\n\n"}
{"name":"Cubic.zero","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\ninst✝ : Semiring R\n⊢ Eq (Cubic.toPoly 0) 0","decl":"theorem zero : (0 : Cubic R).toPoly = 0 :=\n  of_d_eq_zero'\n\n"}
{"name":"Cubic.toPoly_eq_zero_iff","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nP : Cubic R\n⊢ Iff (Eq P.toPoly 0) (Eq P 0)","decl":"theorem toPoly_eq_zero_iff (P : Cubic R) : P.toPoly = 0 ↔ P = 0 := by\n  rw [← zero, toPoly_injective]\n\n"}
{"name":"Cubic.ne_zero_of_a_ne_zero","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nP : Cubic R\ninst✝ : Semiring R\nha : Ne P.a 0\n⊢ Ne P.toPoly 0","decl":"theorem ne_zero_of_a_ne_zero (ha : P.a ≠ 0) : P.toPoly ≠ 0 :=\n  (or_imp.mp ne_zero).1 ha\n\n"}
{"name":"Cubic.ne_zero_of_b_ne_zero","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nP : Cubic R\ninst✝ : Semiring R\nhb : Ne P.b 0\n⊢ Ne P.toPoly 0","decl":"theorem ne_zero_of_b_ne_zero (hb : P.b ≠ 0) : P.toPoly ≠ 0 :=\n  (or_imp.mp (or_imp.mp ne_zero).2).1 hb\n\n"}
{"name":"Cubic.ne_zero_of_c_ne_zero","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nP : Cubic R\ninst✝ : Semiring R\nhc : Ne P.c 0\n⊢ Ne P.toPoly 0","decl":"theorem ne_zero_of_c_ne_zero (hc : P.c ≠ 0) : P.toPoly ≠ 0 :=\n  (or_imp.mp (or_imp.mp (or_imp.mp ne_zero).2).2).1 hc\n\n"}
{"name":"Cubic.ne_zero_of_d_ne_zero","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nP : Cubic R\ninst✝ : Semiring R\nhd : Ne P.d 0\n⊢ Ne P.toPoly 0","decl":"theorem ne_zero_of_d_ne_zero (hd : P.d ≠ 0) : P.toPoly ≠ 0 :=\n  (or_imp.mp (or_imp.mp (or_imp.mp ne_zero).2).2).2 hd\n\n"}
{"name":"Cubic.leadingCoeff_of_a_ne_zero","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nP : Cubic R\ninst✝ : Semiring R\nha : Ne P.a 0\n⊢ Eq P.toPoly.leadingCoeff P.a","decl":"@[simp]\ntheorem leadingCoeff_of_a_ne_zero (ha : P.a ≠ 0) : P.toPoly.leadingCoeff = P.a :=\n  leadingCoeff_cubic ha\n\n"}
{"name":"Cubic.leadingCoeff_of_a_ne_zero'","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\na b c d : R\ninst✝ : Semiring R\nha : Ne a 0\n⊢ Eq { a := a, b := b, c := c, d := d }.toPoly.leadingCoeff a","decl":"@[simp]\ntheorem leadingCoeff_of_a_ne_zero' (ha : a ≠ 0) : (toPoly ⟨a, b, c, d⟩).leadingCoeff = a :=\n  leadingCoeff_of_a_ne_zero ha\n\n"}
{"name":"Cubic.leadingCoeff_of_b_ne_zero","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nP : Cubic R\ninst✝ : Semiring R\nha : Eq P.a 0\nhb : Ne P.b 0\n⊢ Eq P.toPoly.leadingCoeff P.b","decl":"@[simp]\ntheorem leadingCoeff_of_b_ne_zero (ha : P.a = 0) (hb : P.b ≠ 0) : P.toPoly.leadingCoeff = P.b := by\n  rw [of_a_eq_zero ha, leadingCoeff_quadratic hb]\n\n"}
{"name":"Cubic.leadingCoeff_of_b_ne_zero'","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nb c d : R\ninst✝ : Semiring R\nhb : Ne b 0\n⊢ Eq { a := 0, b := b, c := c, d := d }.toPoly.leadingCoeff b","decl":"@[simp]\ntheorem leadingCoeff_of_b_ne_zero' (hb : b ≠ 0) : (toPoly ⟨0, b, c, d⟩).leadingCoeff = b :=\n  leadingCoeff_of_b_ne_zero rfl hb\n\n"}
{"name":"Cubic.leadingCoeff_of_c_ne_zero","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nP : Cubic R\ninst✝ : Semiring R\nha : Eq P.a 0\nhb : Eq P.b 0\nhc : Ne P.c 0\n⊢ Eq P.toPoly.leadingCoeff P.c","decl":"@[simp]\ntheorem leadingCoeff_of_c_ne_zero (ha : P.a = 0) (hb : P.b = 0) (hc : P.c ≠ 0) :\n    P.toPoly.leadingCoeff = P.c := by\n  rw [of_b_eq_zero ha hb, leadingCoeff_linear hc]\n\n"}
{"name":"Cubic.leadingCoeff_of_c_ne_zero'","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nc d : R\ninst✝ : Semiring R\nhc : Ne c 0\n⊢ Eq { a := 0, b := 0, c := c, d := d }.toPoly.leadingCoeff c","decl":"@[simp]\ntheorem leadingCoeff_of_c_ne_zero' (hc : c ≠ 0) : (toPoly ⟨0, 0, c, d⟩).leadingCoeff = c :=\n  leadingCoeff_of_c_ne_zero rfl rfl hc\n\n"}
{"name":"Cubic.leadingCoeff_of_c_eq_zero","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nP : Cubic R\ninst✝ : Semiring R\nha : Eq P.a 0\nhb : Eq P.b 0\nhc : Eq P.c 0\n⊢ Eq P.toPoly.leadingCoeff P.d","decl":"@[simp]\ntheorem leadingCoeff_of_c_eq_zero (ha : P.a = 0) (hb : P.b = 0) (hc : P.c = 0) :\n    P.toPoly.leadingCoeff = P.d := by\n  rw [of_c_eq_zero ha hb hc, leadingCoeff_C]\n\n"}
{"name":"Cubic.leadingCoeff_of_c_eq_zero'","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nd : R\ninst✝ : Semiring R\n⊢ Eq { a := 0, b := 0, c := 0, d := d }.toPoly.leadingCoeff d","decl":"theorem leadingCoeff_of_c_eq_zero' : (toPoly ⟨0, 0, 0, d⟩).leadingCoeff = d :=\n  leadingCoeff_of_c_eq_zero rfl rfl rfl\n\n"}
{"name":"Cubic.monic_of_a_eq_one","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nP : Cubic R\ninst✝ : Semiring R\nha : Eq P.a 1\n⊢ P.toPoly.Monic","decl":"theorem monic_of_a_eq_one (ha : P.a = 1) : P.toPoly.Monic := by\n  nontriviality R\n  rw [Monic, leadingCoeff_of_a_ne_zero (ha ▸ one_ne_zero), ha]\n\n"}
{"name":"Cubic.monic_of_a_eq_one'","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nb c d : R\ninst✝ : Semiring R\n⊢ { a := 1, b := b, c := c, d := d }.toPoly.Monic","decl":"theorem monic_of_a_eq_one' : (toPoly ⟨1, b, c, d⟩).Monic :=\n  monic_of_a_eq_one rfl\n\n"}
{"name":"Cubic.monic_of_b_eq_one","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nP : Cubic R\ninst✝ : Semiring R\nha : Eq P.a 0\nhb : Eq P.b 1\n⊢ P.toPoly.Monic","decl":"theorem monic_of_b_eq_one (ha : P.a = 0) (hb : P.b = 1) : P.toPoly.Monic := by\n  nontriviality R\n  rw [Monic, leadingCoeff_of_b_ne_zero ha (hb ▸ one_ne_zero), hb]\n\n"}
{"name":"Cubic.monic_of_b_eq_one'","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nc d : R\ninst✝ : Semiring R\n⊢ { a := 0, b := 1, c := c, d := d }.toPoly.Monic","decl":"theorem monic_of_b_eq_one' : (toPoly ⟨0, 1, c, d⟩).Monic :=\n  monic_of_b_eq_one rfl rfl\n\n"}
{"name":"Cubic.monic_of_c_eq_one","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nP : Cubic R\ninst✝ : Semiring R\nha : Eq P.a 0\nhb : Eq P.b 0\nhc : Eq P.c 1\n⊢ P.toPoly.Monic","decl":"theorem monic_of_c_eq_one (ha : P.a = 0) (hb : P.b = 0) (hc : P.c = 1) : P.toPoly.Monic := by\n  nontriviality R\n  rw [Monic, leadingCoeff_of_c_ne_zero ha hb (hc ▸ one_ne_zero), hc]\n\n"}
{"name":"Cubic.monic_of_c_eq_one'","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nd : R\ninst✝ : Semiring R\n⊢ { a := 0, b := 0, c := 1, d := d }.toPoly.Monic","decl":"theorem monic_of_c_eq_one' : (toPoly ⟨0, 0, 1, d⟩).Monic :=\n  monic_of_c_eq_one rfl rfl rfl\n\n"}
{"name":"Cubic.monic_of_d_eq_one","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nP : Cubic R\ninst✝ : Semiring R\nha : Eq P.a 0\nhb : Eq P.b 0\nhc : Eq P.c 0\nhd : Eq P.d 1\n⊢ P.toPoly.Monic","decl":"theorem monic_of_d_eq_one (ha : P.a = 0) (hb : P.b = 0) (hc : P.c = 0) (hd : P.d = 1) :\n    P.toPoly.Monic := by\n  rw [Monic, leadingCoeff_of_c_eq_zero ha hb hc, hd]\n\n"}
{"name":"Cubic.monic_of_d_eq_one'","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"⊢ { a := 0, b := 0, c := 0, d := 1 }.toPoly.Monic","decl":"theorem monic_of_d_eq_one' : (toPoly ⟨0, 0, 0, 1⟩).Monic :=\n  monic_of_d_eq_one rfl rfl rfl rfl\n\n"}
{"name":"Cubic.equiv_symm_apply_d","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : Subtype fun p => LE.le p.degree 3\n⊢ Eq (Cubic.equiv.symm f).d ((↑f).coeff 0)","decl":"/-- The equivalence between cubic polynomials and polynomials of degree at most three. -/\n@[simps]\ndef equiv : Cubic R ≃ { p : R[X] // p.degree ≤ 3 } where\n  toFun P := ⟨P.toPoly, degree_cubic_le⟩\n  invFun f := ⟨coeff f 3, coeff f 2, coeff f 1, coeff f 0⟩\n  left_inv P := by ext <;> simp only [Subtype.coe_mk, coeffs]\n  right_inv f := by\n    -- Porting note: Added `simp only [Nat.succ_eq_add_one] <;> ring_nf`\n    -- There's probably a better way to do this.\n    ext (_ | _ | _ | _ | n) <;> simp only [Nat.succ_eq_add_one] <;> ring_nf\n      <;> try simp only [coeffs]\n    have h3 : 3 < 4 + n := by linarith only\n    rw [coeff_eq_zero h3,\n      (degree_le_iff_coeff_zero (f : R[X]) 3).mp f.2 _ <| WithBot.coe_lt_coe.mpr (by exact h3)]\n\n"}
{"name":"Cubic.equiv_apply_coe","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nP : Cubic R\n⊢ Eq (↑(Cubic.equiv P)) P.toPoly","decl":"/-- The equivalence between cubic polynomials and polynomials of degree at most three. -/\n@[simps]\ndef equiv : Cubic R ≃ { p : R[X] // p.degree ≤ 3 } where\n  toFun P := ⟨P.toPoly, degree_cubic_le⟩\n  invFun f := ⟨coeff f 3, coeff f 2, coeff f 1, coeff f 0⟩\n  left_inv P := by ext <;> simp only [Subtype.coe_mk, coeffs]\n  right_inv f := by\n    -- Porting note: Added `simp only [Nat.succ_eq_add_one] <;> ring_nf`\n    -- There's probably a better way to do this.\n    ext (_ | _ | _ | _ | n) <;> simp only [Nat.succ_eq_add_one] <;> ring_nf\n      <;> try simp only [coeffs]\n    have h3 : 3 < 4 + n := by linarith only\n    rw [coeff_eq_zero h3,\n      (degree_le_iff_coeff_zero (f : R[X]) 3).mp f.2 _ <| WithBot.coe_lt_coe.mpr (by exact h3)]\n\n"}
{"name":"Cubic.equiv_symm_apply_c","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : Subtype fun p => LE.le p.degree 3\n⊢ Eq (Cubic.equiv.symm f).c ((↑f).coeff 1)","decl":"/-- The equivalence between cubic polynomials and polynomials of degree at most three. -/\n@[simps]\ndef equiv : Cubic R ≃ { p : R[X] // p.degree ≤ 3 } where\n  toFun P := ⟨P.toPoly, degree_cubic_le⟩\n  invFun f := ⟨coeff f 3, coeff f 2, coeff f 1, coeff f 0⟩\n  left_inv P := by ext <;> simp only [Subtype.coe_mk, coeffs]\n  right_inv f := by\n    -- Porting note: Added `simp only [Nat.succ_eq_add_one] <;> ring_nf`\n    -- There's probably a better way to do this.\n    ext (_ | _ | _ | _ | n) <;> simp only [Nat.succ_eq_add_one] <;> ring_nf\n      <;> try simp only [coeffs]\n    have h3 : 3 < 4 + n := by linarith only\n    rw [coeff_eq_zero h3,\n      (degree_le_iff_coeff_zero (f : R[X]) 3).mp f.2 _ <| WithBot.coe_lt_coe.mpr (by exact h3)]\n\n"}
{"name":"Cubic.equiv_symm_apply_b","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : Subtype fun p => LE.le p.degree 3\n⊢ Eq (Cubic.equiv.symm f).b ((↑f).coeff 2)","decl":"/-- The equivalence between cubic polynomials and polynomials of degree at most three. -/\n@[simps]\ndef equiv : Cubic R ≃ { p : R[X] // p.degree ≤ 3 } where\n  toFun P := ⟨P.toPoly, degree_cubic_le⟩\n  invFun f := ⟨coeff f 3, coeff f 2, coeff f 1, coeff f 0⟩\n  left_inv P := by ext <;> simp only [Subtype.coe_mk, coeffs]\n  right_inv f := by\n    -- Porting note: Added `simp only [Nat.succ_eq_add_one] <;> ring_nf`\n    -- There's probably a better way to do this.\n    ext (_ | _ | _ | _ | n) <;> simp only [Nat.succ_eq_add_one] <;> ring_nf\n      <;> try simp only [coeffs]\n    have h3 : 3 < 4 + n := by linarith only\n    rw [coeff_eq_zero h3,\n      (degree_le_iff_coeff_zero (f : R[X]) 3).mp f.2 _ <| WithBot.coe_lt_coe.mpr (by exact h3)]\n\n"}
{"name":"Cubic.equiv_symm_apply_a","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : Subtype fun p => LE.le p.degree 3\n⊢ Eq (Cubic.equiv.symm f).a ((↑f).coeff 3)","decl":"/-- The equivalence between cubic polynomials and polynomials of degree at most three. -/\n@[simps]\ndef equiv : Cubic R ≃ { p : R[X] // p.degree ≤ 3 } where\n  toFun P := ⟨P.toPoly, degree_cubic_le⟩\n  invFun f := ⟨coeff f 3, coeff f 2, coeff f 1, coeff f 0⟩\n  left_inv P := by ext <;> simp only [Subtype.coe_mk, coeffs]\n  right_inv f := by\n    -- Porting note: Added `simp only [Nat.succ_eq_add_one] <;> ring_nf`\n    -- There's probably a better way to do this.\n    ext (_ | _ | _ | _ | n) <;> simp only [Nat.succ_eq_add_one] <;> ring_nf\n      <;> try simp only [coeffs]\n    have h3 : 3 < 4 + n := by linarith only\n    rw [coeff_eq_zero h3,\n      (degree_le_iff_coeff_zero (f : R[X]) 3).mp f.2 _ <| WithBot.coe_lt_coe.mpr (by exact h3)]\n\n"}
{"name":"Cubic.degree_of_a_ne_zero","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nP : Cubic R\ninst✝ : Semiring R\nha : Ne P.a 0\n⊢ Eq P.toPoly.degree 3","decl":"@[simp]\ntheorem degree_of_a_ne_zero (ha : P.a ≠ 0) : P.toPoly.degree = 3 :=\n  degree_cubic ha\n\n"}
{"name":"Cubic.degree_of_a_ne_zero'","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\na b c d : R\ninst✝ : Semiring R\nha : Ne a 0\n⊢ Eq { a := a, b := b, c := c, d := d }.toPoly.degree 3","decl":"@[simp]\ntheorem degree_of_a_ne_zero' (ha : a ≠ 0) : (toPoly ⟨a, b, c, d⟩).degree = 3 :=\n  degree_of_a_ne_zero ha\n\n"}
{"name":"Cubic.degree_of_a_eq_zero","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nP : Cubic R\ninst✝ : Semiring R\nha : Eq P.a 0\n⊢ LE.le P.toPoly.degree 2","decl":"theorem degree_of_a_eq_zero (ha : P.a = 0) : P.toPoly.degree ≤ 2 := by\n  simpa only [of_a_eq_zero ha] using degree_quadratic_le\n\n"}
{"name":"Cubic.degree_of_a_eq_zero'","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nb c d : R\ninst✝ : Semiring R\n⊢ LE.le { a := 0, b := b, c := c, d := d }.toPoly.degree 2","decl":"theorem degree_of_a_eq_zero' : (toPoly ⟨0, b, c, d⟩).degree ≤ 2 :=\n  degree_of_a_eq_zero rfl\n\n"}
{"name":"Cubic.degree_of_b_ne_zero","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nP : Cubic R\ninst✝ : Semiring R\nha : Eq P.a 0\nhb : Ne P.b 0\n⊢ Eq P.toPoly.degree 2","decl":"@[simp]\ntheorem degree_of_b_ne_zero (ha : P.a = 0) (hb : P.b ≠ 0) : P.toPoly.degree = 2 := by\n  rw [of_a_eq_zero ha, degree_quadratic hb]\n\n"}
{"name":"Cubic.degree_of_b_ne_zero'","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nb c d : R\ninst✝ : Semiring R\nhb : Ne b 0\n⊢ Eq { a := 0, b := b, c := c, d := d }.toPoly.degree 2","decl":"@[simp]\ntheorem degree_of_b_ne_zero' (hb : b ≠ 0) : (toPoly ⟨0, b, c, d⟩).degree = 2 :=\n  degree_of_b_ne_zero rfl hb\n\n"}
{"name":"Cubic.degree_of_b_eq_zero","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nP : Cubic R\ninst✝ : Semiring R\nha : Eq P.a 0\nhb : Eq P.b 0\n⊢ LE.le P.toPoly.degree 1","decl":"theorem degree_of_b_eq_zero (ha : P.a = 0) (hb : P.b = 0) : P.toPoly.degree ≤ 1 := by\n  simpa only [of_b_eq_zero ha hb] using degree_linear_le\n\n"}
{"name":"Cubic.degree_of_b_eq_zero'","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nc d : R\ninst✝ : Semiring R\n⊢ LE.le { a := 0, b := 0, c := c, d := d }.toPoly.degree 1","decl":"theorem degree_of_b_eq_zero' : (toPoly ⟨0, 0, c, d⟩).degree ≤ 1 :=\n  degree_of_b_eq_zero rfl rfl\n\n"}
{"name":"Cubic.degree_of_c_ne_zero","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nP : Cubic R\ninst✝ : Semiring R\nha : Eq P.a 0\nhb : Eq P.b 0\nhc : Ne P.c 0\n⊢ Eq P.toPoly.degree 1","decl":"@[simp]\ntheorem degree_of_c_ne_zero (ha : P.a = 0) (hb : P.b = 0) (hc : P.c ≠ 0) : P.toPoly.degree = 1 := by\n  rw [of_b_eq_zero ha hb, degree_linear hc]\n\n"}
{"name":"Cubic.degree_of_c_ne_zero'","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nc d : R\ninst✝ : Semiring R\nhc : Ne c 0\n⊢ Eq { a := 0, b := 0, c := c, d := d }.toPoly.degree 1","decl":"@[simp]\ntheorem degree_of_c_ne_zero' (hc : c ≠ 0) : (toPoly ⟨0, 0, c, d⟩).degree = 1 :=\n  degree_of_c_ne_zero rfl rfl hc\n\n"}
{"name":"Cubic.degree_of_c_eq_zero","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nP : Cubic R\ninst✝ : Semiring R\nha : Eq P.a 0\nhb : Eq P.b 0\nhc : Eq P.c 0\n⊢ LE.le P.toPoly.degree 0","decl":"theorem degree_of_c_eq_zero (ha : P.a = 0) (hb : P.b = 0) (hc : P.c = 0) : P.toPoly.degree ≤ 0 := by\n  simpa only [of_c_eq_zero ha hb hc] using degree_C_le\n\n"}
{"name":"Cubic.degree_of_c_eq_zero'","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nd : R\ninst✝ : Semiring R\n⊢ LE.le { a := 0, b := 0, c := 0, d := d }.toPoly.degree 0","decl":"theorem degree_of_c_eq_zero' : (toPoly ⟨0, 0, 0, d⟩).degree ≤ 0 :=\n  degree_of_c_eq_zero rfl rfl rfl\n\n"}
{"name":"Cubic.degree_of_d_ne_zero","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nP : Cubic R\ninst✝ : Semiring R\nha : Eq P.a 0\nhb : Eq P.b 0\nhc : Eq P.c 0\nhd : Ne P.d 0\n⊢ Eq P.toPoly.degree 0","decl":"@[simp]\ntheorem degree_of_d_ne_zero (ha : P.a = 0) (hb : P.b = 0) (hc : P.c = 0) (hd : P.d ≠ 0) :\n    P.toPoly.degree = 0 := by\n  rw [of_c_eq_zero ha hb hc, degree_C hd]\n\n"}
{"name":"Cubic.degree_of_d_ne_zero'","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nd : R\ninst✝ : Semiring R\nhd : Ne d 0\n⊢ Eq { a := 0, b := 0, c := 0, d := d }.toPoly.degree 0","decl":"@[simp]\ntheorem degree_of_d_ne_zero' (hd : d ≠ 0) : (toPoly ⟨0, 0, 0, d⟩).degree = 0 :=\n  degree_of_d_ne_zero rfl rfl rfl hd\n\n"}
{"name":"Cubic.degree_of_d_eq_zero","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nP : Cubic R\ninst✝ : Semiring R\nha : Eq P.a 0\nhb : Eq P.b 0\nhc : Eq P.c 0\nhd : Eq P.d 0\n⊢ Eq P.toPoly.degree Bot.bot","decl":"@[simp]\ntheorem degree_of_d_eq_zero (ha : P.a = 0) (hb : P.b = 0) (hc : P.c = 0) (hd : P.d = 0) :\n    P.toPoly.degree = ⊥ := by\n  rw [of_d_eq_zero ha hb hc hd, degree_zero]\n\n"}
{"name":"Cubic.degree_of_d_eq_zero'","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\ninst✝ : Semiring R\n⊢ Eq { a := 0, b := 0, c := 0, d := 0 }.toPoly.degree Bot.bot","decl":"theorem degree_of_d_eq_zero' : (⟨0, 0, 0, 0⟩ : Cubic R).toPoly.degree = ⊥ :=\n  degree_of_d_eq_zero rfl rfl rfl rfl\n\n"}
{"name":"Cubic.degree_of_zero","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\ninst✝ : Semiring R\n⊢ Eq (Cubic.toPoly 0).degree Bot.bot","decl":"@[simp]\ntheorem degree_of_zero : (0 : Cubic R).toPoly.degree = ⊥ :=\n  degree_of_d_eq_zero'\n\n"}
{"name":"Cubic.natDegree_of_a_ne_zero","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nP : Cubic R\ninst✝ : Semiring R\nha : Ne P.a 0\n⊢ Eq P.toPoly.natDegree 3","decl":"@[simp]\ntheorem natDegree_of_a_ne_zero (ha : P.a ≠ 0) : P.toPoly.natDegree = 3 :=\n  natDegree_cubic ha\n\n"}
{"name":"Cubic.natDegree_of_a_ne_zero'","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\na b c d : R\ninst✝ : Semiring R\nha : Ne a 0\n⊢ Eq { a := a, b := b, c := c, d := d }.toPoly.natDegree 3","decl":"@[simp]\ntheorem natDegree_of_a_ne_zero' (ha : a ≠ 0) : (toPoly ⟨a, b, c, d⟩).natDegree = 3 :=\n  natDegree_of_a_ne_zero ha\n\n"}
{"name":"Cubic.natDegree_of_a_eq_zero","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nP : Cubic R\ninst✝ : Semiring R\nha : Eq P.a 0\n⊢ LE.le P.toPoly.natDegree 2","decl":"theorem natDegree_of_a_eq_zero (ha : P.a = 0) : P.toPoly.natDegree ≤ 2 := by\n  simpa only [of_a_eq_zero ha] using natDegree_quadratic_le\n\n"}
{"name":"Cubic.natDegree_of_a_eq_zero'","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nb c d : R\ninst✝ : Semiring R\n⊢ LE.le { a := 0, b := b, c := c, d := d }.toPoly.natDegree 2","decl":"theorem natDegree_of_a_eq_zero' : (toPoly ⟨0, b, c, d⟩).natDegree ≤ 2 :=\n  natDegree_of_a_eq_zero rfl\n\n"}
{"name":"Cubic.natDegree_of_b_ne_zero","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nP : Cubic R\ninst✝ : Semiring R\nha : Eq P.a 0\nhb : Ne P.b 0\n⊢ Eq P.toPoly.natDegree 2","decl":"@[simp]\ntheorem natDegree_of_b_ne_zero (ha : P.a = 0) (hb : P.b ≠ 0) : P.toPoly.natDegree = 2 := by\n  rw [of_a_eq_zero ha, natDegree_quadratic hb]\n\n"}
{"name":"Cubic.natDegree_of_b_ne_zero'","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nb c d : R\ninst✝ : Semiring R\nhb : Ne b 0\n⊢ Eq { a := 0, b := b, c := c, d := d }.toPoly.natDegree 2","decl":"@[simp]\ntheorem natDegree_of_b_ne_zero' (hb : b ≠ 0) : (toPoly ⟨0, b, c, d⟩).natDegree = 2 :=\n  natDegree_of_b_ne_zero rfl hb\n\n"}
{"name":"Cubic.natDegree_of_b_eq_zero","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nP : Cubic R\ninst✝ : Semiring R\nha : Eq P.a 0\nhb : Eq P.b 0\n⊢ LE.le P.toPoly.natDegree 1","decl":"theorem natDegree_of_b_eq_zero (ha : P.a = 0) (hb : P.b = 0) : P.toPoly.natDegree ≤ 1 := by\n  simpa only [of_b_eq_zero ha hb] using natDegree_linear_le\n\n"}
{"name":"Cubic.natDegree_of_b_eq_zero'","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nc d : R\ninst✝ : Semiring R\n⊢ LE.le { a := 0, b := 0, c := c, d := d }.toPoly.natDegree 1","decl":"theorem natDegree_of_b_eq_zero' : (toPoly ⟨0, 0, c, d⟩).natDegree ≤ 1 :=\n  natDegree_of_b_eq_zero rfl rfl\n\n"}
{"name":"Cubic.natDegree_of_c_ne_zero","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nP : Cubic R\ninst✝ : Semiring R\nha : Eq P.a 0\nhb : Eq P.b 0\nhc : Ne P.c 0\n⊢ Eq P.toPoly.natDegree 1","decl":"@[simp]\ntheorem natDegree_of_c_ne_zero (ha : P.a = 0) (hb : P.b = 0) (hc : P.c ≠ 0) :\n    P.toPoly.natDegree = 1 := by\n  rw [of_b_eq_zero ha hb, natDegree_linear hc]\n\n"}
{"name":"Cubic.natDegree_of_c_ne_zero'","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nc d : R\ninst✝ : Semiring R\nhc : Ne c 0\n⊢ Eq { a := 0, b := 0, c := c, d := d }.toPoly.natDegree 1","decl":"@[simp]\ntheorem natDegree_of_c_ne_zero' (hc : c ≠ 0) : (toPoly ⟨0, 0, c, d⟩).natDegree = 1 :=\n  natDegree_of_c_ne_zero rfl rfl hc\n\n"}
{"name":"Cubic.natDegree_of_c_eq_zero","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nP : Cubic R\ninst✝ : Semiring R\nha : Eq P.a 0\nhb : Eq P.b 0\nhc : Eq P.c 0\n⊢ Eq P.toPoly.natDegree 0","decl":"@[simp]\ntheorem natDegree_of_c_eq_zero (ha : P.a = 0) (hb : P.b = 0) (hc : P.c = 0) :\n    P.toPoly.natDegree = 0 := by\n  rw [of_c_eq_zero ha hb hc, natDegree_C]\n\n"}
{"name":"Cubic.natDegree_of_c_eq_zero'","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nd : R\ninst✝ : Semiring R\n⊢ Eq { a := 0, b := 0, c := 0, d := d }.toPoly.natDegree 0","decl":"theorem natDegree_of_c_eq_zero' : (toPoly ⟨0, 0, 0, d⟩).natDegree = 0 :=\n  natDegree_of_c_eq_zero rfl rfl rfl\n\n"}
{"name":"Cubic.natDegree_of_zero","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\ninst✝ : Semiring R\n⊢ Eq (Cubic.toPoly 0).natDegree 0","decl":"@[simp]\ntheorem natDegree_of_zero : (0 : Cubic R).toPoly.natDegree = 0 :=\n  natDegree_of_c_eq_zero'\n\n"}
{"name":"Cubic.map_toPoly","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nS : Type u_2\nP : Cubic R\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nφ : RingHom R S\n⊢ Eq (Cubic.map φ P).toPoly (Polynomial.map φ P.toPoly)","decl":"theorem map_toPoly : (map φ P).toPoly = Polynomial.map φ P.toPoly := by\n  simp only [map, toPoly, map_C, map_X, Polynomial.map_add, Polynomial.map_mul, Polynomial.map_pow]\n\n"}
{"name":"Cubic.map_roots","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nS : Type u_2\nP : Cubic R\ninst✝² : CommRing R\ninst✝¹ : CommRing S\nφ : RingHom R S\ninst✝ : IsDomain S\n⊢ Eq (Cubic.map φ P).roots (Polynomial.map φ P.toPoly).roots","decl":"theorem map_roots [IsDomain S] : (map φ P).roots = (Polynomial.map φ P.toPoly).roots := by\n  rw [roots, map_toPoly]\n\n"}
{"name":"Cubic.mem_roots_iff","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nP : Cubic R\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nh0 : Ne P.toPoly 0\nx : R\n⊢ Iff (Membership.mem P.roots x) (Eq (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HMul.hMul P.a (HPow.hPow x 3)) (HMul.hMul P.b (HPow.hPow x 2))) (HMul.hMul P.c x)) P.d) 0)","decl":"theorem mem_roots_iff [IsDomain R] (h0 : P.toPoly ≠ 0) (x : R) :\n    x ∈ P.roots ↔ P.a * x ^ 3 + P.b * x ^ 2 + P.c * x + P.d = 0 := by\n  rw [roots, mem_roots h0, IsRoot, toPoly]\n  simp only [eval_C, eval_X, eval_add, eval_mul, eval_pow]\n\n"}
{"name":"Cubic.card_roots_le","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"R : Type u_1\nP : Cubic R\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : DecidableEq R\n⊢ LE.le P.roots.toFinset.card 3","decl":"theorem card_roots_le [IsDomain R] [DecidableEq R] : P.roots.toFinset.card ≤ 3 := by\n  apply (toFinset_card_le P.toPoly.roots).trans\n  by_cases hP : P.toPoly = 0\n  · exact (card_roots' P.toPoly).trans (by rw [hP, natDegree_zero]; exact zero_le 3)\n  · exact WithBot.coe_le_coe.1 ((card_roots hP).trans degree_cubic_le)\n\n"}
{"name":"Cubic.splits_iff_card_roots","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"F : Type u_3\nK : Type u_4\nP : Cubic F\ninst✝¹ : Field F\ninst✝ : Field K\nφ : RingHom F K\nha : Ne P.a 0\n⊢ Iff (Polynomial.Splits φ P.toPoly) (Eq (Cubic.map φ P).roots.card 3)","decl":"theorem splits_iff_card_roots (ha : P.a ≠ 0) :\n    Splits φ P.toPoly ↔ Multiset.card (map φ P).roots = 3 := by\n  replace ha : (map φ P).a ≠ 0 := (_root_.map_ne_zero φ).mpr ha\n  nth_rw 1 [← RingHom.id_comp φ]\n  rw [roots, ← splits_map_iff, ← map_toPoly, Polynomial.splits_iff_card_roots,\n    ← ((degree_eq_iff_natDegree_eq <| ne_zero_of_a_ne_zero ha).1 <| degree_of_a_ne_zero ha : _ = 3)]\n\n"}
{"name":"Cubic.splits_iff_roots_eq_three","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"F : Type u_3\nK : Type u_4\nP : Cubic F\ninst✝¹ : Field F\ninst✝ : Field K\nφ : RingHom F K\nha : Ne P.a 0\n⊢ Iff (Polynomial.Splits φ P.toPoly) (Exists fun x => Exists fun y => Exists fun z => Eq (Cubic.map φ P).roots (Insert.insert x (Insert.insert y (Singleton.singleton z))))","decl":"theorem splits_iff_roots_eq_three (ha : P.a ≠ 0) :\n    Splits φ P.toPoly ↔ ∃ x y z : K, (map φ P).roots = {x, y, z} := by\n  rw [splits_iff_card_roots ha, card_eq_three]\n\n"}
{"name":"Cubic.eq_prod_three_roots","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"F : Type u_3\nK : Type u_4\nP : Cubic F\ninst✝¹ : Field F\ninst✝ : Field K\nφ : RingHom F K\nx y z : K\nha : Ne P.a 0\nh3 : Eq (Cubic.map φ P).roots (Insert.insert x (Insert.insert y (Singleton.singleton z)))\n⊢ Eq (Cubic.map φ P).toPoly (HMul.hMul (HMul.hMul (HMul.hMul (Polynomial.C (φ P.a)) (HSub.hSub Polynomial.X (Polynomial.C x))) (HSub.hSub Polynomial.X (Polynomial.C y))) (HSub.hSub Polynomial.X (Polynomial.C z)))","decl":"theorem eq_prod_three_roots (ha : P.a ≠ 0) (h3 : (map φ P).roots = {x, y, z}) :\n    (map φ P).toPoly = C (φ P.a) * (X - C x) * (X - C y) * (X - C z) := by\n  rw [map_toPoly,\n    eq_prod_roots_of_splits <|\n      (splits_iff_roots_eq_three ha).mpr <| Exists.intro x <| Exists.intro y <| Exists.intro z h3,\n    leadingCoeff_of_a_ne_zero ha, ← map_roots, h3]\n  change C (φ P.a) * ((X - C x) ::ₘ (X - C y) ::ₘ {X - C z}).prod = _\n  rw [prod_cons, prod_cons, prod_singleton, mul_assoc, mul_assoc]\n\n"}
{"name":"Cubic.eq_sum_three_roots","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"F : Type u_3\nK : Type u_4\nP : Cubic F\ninst✝¹ : Field F\ninst✝ : Field K\nφ : RingHom F K\nx y z : K\nha : Ne P.a 0\nh3 : Eq (Cubic.map φ P).roots (Insert.insert x (Insert.insert y (Singleton.singleton z)))\n⊢ Eq (Cubic.map φ P) { a := φ P.a, b := HMul.hMul (φ P.a) (Neg.neg (HAdd.hAdd (HAdd.hAdd x y) z)), c := HMul.hMul (φ P.a) (HAdd.hAdd (HAdd.hAdd (HMul.hMul x y) (HMul.hMul x z)) (HMul.hMul y z)), d := HMul.hMul (φ P.a) (Neg.neg (HMul.hMul (HMul.hMul x y) z)) }","decl":"theorem eq_sum_three_roots (ha : P.a ≠ 0) (h3 : (map φ P).roots = {x, y, z}) :\n    map φ P =\n      ⟨φ P.a, φ P.a * -(x + y + z), φ P.a * (x * y + x * z + y * z), φ P.a * -(x * y * z)⟩ := by\n  apply_fun @toPoly _ _\n  · rw [eq_prod_three_roots ha h3, C_mul_prod_X_sub_C_eq]\n  · exact fun P Q ↦ (toPoly_injective P Q).mp\n\n"}
{"name":"Cubic.b_eq_three_roots","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"F : Type u_3\nK : Type u_4\nP : Cubic F\ninst✝¹ : Field F\ninst✝ : Field K\nφ : RingHom F K\nx y z : K\nha : Ne P.a 0\nh3 : Eq (Cubic.map φ P).roots (Insert.insert x (Insert.insert y (Singleton.singleton z)))\n⊢ Eq (φ P.b) (HMul.hMul (φ P.a) (Neg.neg (HAdd.hAdd (HAdd.hAdd x y) z)))","decl":"theorem b_eq_three_roots (ha : P.a ≠ 0) (h3 : (map φ P).roots = {x, y, z}) :\n    φ P.b = φ P.a * -(x + y + z) := by\n  injection eq_sum_three_roots ha h3\n\n"}
{"name":"Cubic.c_eq_three_roots","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"F : Type u_3\nK : Type u_4\nP : Cubic F\ninst✝¹ : Field F\ninst✝ : Field K\nφ : RingHom F K\nx y z : K\nha : Ne P.a 0\nh3 : Eq (Cubic.map φ P).roots (Insert.insert x (Insert.insert y (Singleton.singleton z)))\n⊢ Eq (φ P.c) (HMul.hMul (φ P.a) (HAdd.hAdd (HAdd.hAdd (HMul.hMul x y) (HMul.hMul x z)) (HMul.hMul y z)))","decl":"theorem c_eq_three_roots (ha : P.a ≠ 0) (h3 : (map φ P).roots = {x, y, z}) :\n    φ P.c = φ P.a * (x * y + x * z + y * z) := by\n  injection eq_sum_three_roots ha h3\n\n"}
{"name":"Cubic.d_eq_three_roots","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"F : Type u_3\nK : Type u_4\nP : Cubic F\ninst✝¹ : Field F\ninst✝ : Field K\nφ : RingHom F K\nx y z : K\nha : Ne P.a 0\nh3 : Eq (Cubic.map φ P).roots (Insert.insert x (Insert.insert y (Singleton.singleton z)))\n⊢ Eq (φ P.d) (HMul.hMul (φ P.a) (Neg.neg (HMul.hMul (HMul.hMul x y) z)))","decl":"theorem d_eq_three_roots (ha : P.a ≠ 0) (h3 : (map φ P).roots = {x, y, z}) :\n    φ P.d = φ P.a * -(x * y * z) := by\n  injection eq_sum_three_roots ha h3\n\n"}
{"name":"Cubic.disc_eq_prod_three_roots","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"F : Type u_3\nK : Type u_4\nP : Cubic F\ninst✝¹ : Field F\ninst✝ : Field K\nφ : RingHom F K\nx y z : K\nha : Ne P.a 0\nh3 : Eq (Cubic.map φ P).roots (Insert.insert x (Insert.insert y (Singleton.singleton z)))\n⊢ Eq (φ P.disc) (HPow.hPow (HMul.hMul (HMul.hMul (HMul.hMul (HMul.hMul (φ P.a) (φ P.a)) (HSub.hSub x y)) (HSub.hSub x z)) (HSub.hSub y z)) 2)","decl":"theorem disc_eq_prod_three_roots (ha : P.a ≠ 0) (h3 : (map φ P).roots = {x, y, z}) :\n    φ P.disc = (φ P.a * φ P.a * (x - y) * (x - z) * (y - z)) ^ 2 := by\n  simp only [disc, RingHom.map_add, RingHom.map_sub, RingHom.map_mul, map_pow, map_ofNat]\n  rw [b_eq_three_roots ha h3, c_eq_three_roots ha h3, d_eq_three_roots ha h3]\n  ring1\n\n"}
{"name":"Cubic.disc_ne_zero_iff_roots_ne","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"F : Type u_3\nK : Type u_4\nP : Cubic F\ninst✝¹ : Field F\ninst✝ : Field K\nφ : RingHom F K\nx y z : K\nha : Ne P.a 0\nh3 : Eq (Cubic.map φ P).roots (Insert.insert x (Insert.insert y (Singleton.singleton z)))\n⊢ Iff (Ne P.disc 0) (And (Ne x y) (And (Ne x z) (Ne y z)))","decl":"theorem disc_ne_zero_iff_roots_ne (ha : P.a ≠ 0) (h3 : (map φ P).roots = {x, y, z}) :\n    P.disc ≠ 0 ↔ x ≠ y ∧ x ≠ z ∧ y ≠ z := by\n  rw [← _root_.map_ne_zero φ, disc_eq_prod_three_roots ha h3, pow_two]\n  simp_rw [mul_ne_zero_iff, sub_ne_zero, _root_.map_ne_zero, and_self_iff, and_iff_right ha,\n    and_assoc]\n\n"}
{"name":"Cubic.disc_ne_zero_iff_roots_nodup","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"F : Type u_3\nK : Type u_4\nP : Cubic F\ninst✝¹ : Field F\ninst✝ : Field K\nφ : RingHom F K\nx y z : K\nha : Ne P.a 0\nh3 : Eq (Cubic.map φ P).roots (Insert.insert x (Insert.insert y (Singleton.singleton z)))\n⊢ Iff (Ne P.disc 0) (Cubic.map φ P).roots.Nodup","decl":"theorem disc_ne_zero_iff_roots_nodup (ha : P.a ≠ 0) (h3 : (map φ P).roots = {x, y, z}) :\n    P.disc ≠ 0 ↔ (map φ P).roots.Nodup := by\n  rw [disc_ne_zero_iff_roots_ne ha h3, h3]\n  change _ ↔ (x ::ₘ y ::ₘ {z}).Nodup\n  rw [nodup_cons, nodup_cons, mem_cons, mem_singleton, mem_singleton]\n  simp only [nodup_singleton]\n  tauto\n\n"}
{"name":"Cubic.card_roots_of_disc_ne_zero","module":"Mathlib.Algebra.CubicDiscriminant","initialProofState":"F : Type u_3\nK : Type u_4\nP : Cubic F\ninst✝² : Field F\ninst✝¹ : Field K\nφ : RingHom F K\nx y z : K\ninst✝ : DecidableEq K\nha : Ne P.a 0\nh3 : Eq (Cubic.map φ P).roots (Insert.insert x (Insert.insert y (Singleton.singleton z)))\nhd : Ne P.disc 0\n⊢ Eq (Cubic.map φ P).roots.toFinset.card 3","decl":"theorem card_roots_of_disc_ne_zero [DecidableEq K] (ha : P.a ≠ 0) (h3 : (map φ P).roots = {x, y, z})\n    (hd : P.disc ≠ 0) : (map φ P).roots.toFinset.card = 3 := by\n  rw [toFinset_card_of_nodup <| (disc_ne_zero_iff_roots_nodup ha h3).mp hd,\n    ← splits_iff_card_roots ha, splits_iff_roots_eq_three ha]\n  exact ⟨x, ⟨y, ⟨z, h3⟩⟩⟩\n\n"}
