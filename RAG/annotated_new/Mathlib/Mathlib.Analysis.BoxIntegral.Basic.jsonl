{"name":"BoxIntegral.integralSum_biUnionTagged","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"Î¹ : Type u\nE : Type v\nF : Type w\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nI : BoxIntegral.Box Î¹\nf : (Î¹ â†’ Real) â†’ E\nvol : BoxIntegral.BoxAdditiveMap Î¹ (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nÏ€ : BoxIntegral.Prepartition I\nÏ€i : (J : BoxIntegral.Box Î¹) â†’ BoxIntegral.TaggedPrepartition J\nâŠ¢ Eq (BoxIntegral.integralSum f vol (Ï€.biUnionTagged Ï€i)) (Ï€.boxes.sum fun J => BoxIntegral.integralSum f vol (Ï€i J))","decl":"theorem integralSum_biUnionTagged (f : â„â¿ â†’ E) (vol : Î¹ â†’áµ‡áµƒ E â†’L[â„] F) (Ï€ : Prepartition I)\n    (Ï€i : âˆ€ J, TaggedPrepartition J) :\n    integralSum f vol (Ï€.biUnionTagged Ï€i) = âˆ‘ J âˆˆ Ï€.boxes, integralSum f vol (Ï€i J) := by\n  refine (Ï€.sum_biUnion_boxes _ _).trans <| sum_congr rfl fun J hJ => sum_congr rfl fun J' hJ' => ?_\n  rw [Ï€.tag_biUnionTagged hJ hJ']\n\n"}
{"name":"BoxIntegral.integralSum_biUnion_partition","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"Î¹ : Type u\nE : Type v\nF : Type w\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nI : BoxIntegral.Box Î¹\nf : (Î¹ â†’ Real) â†’ E\nvol : BoxIntegral.BoxAdditiveMap Î¹ (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nÏ€ : BoxIntegral.TaggedPrepartition I\nÏ€i : (J : BoxIntegral.Box Î¹) â†’ BoxIntegral.Prepartition J\nhÏ€i : âˆ€ (J : BoxIntegral.Box Î¹), Membership.mem Ï€ J â†’ (Ï€i J).IsPartition\nâŠ¢ Eq (BoxIntegral.integralSum f vol (Ï€.biUnionPrepartition Ï€i)) (BoxIntegral.integralSum f vol Ï€)","decl":"theorem integralSum_biUnion_partition (f : â„â¿ â†’ E) (vol : Î¹ â†’áµ‡áµƒ E â†’L[â„] F)\n    (Ï€ : TaggedPrepartition I) (Ï€i : âˆ€ J, Prepartition J) (hÏ€i : âˆ€ J âˆˆ Ï€, (Ï€i J).IsPartition) :\n    integralSum f vol (Ï€.biUnionPrepartition Ï€i) = integralSum f vol Ï€ := by\n  refine (Ï€.sum_biUnion_boxes _ _).trans (sum_congr rfl fun J hJ => ?_)\n  calc\n    (âˆ‘ J' âˆˆ (Ï€i J).boxes, vol J' (f (Ï€.tag <| Ï€.toPrepartition.biUnionIndex Ï€i J'))) =\n        âˆ‘ J' âˆˆ (Ï€i J).boxes, vol J' (f (Ï€.tag J)) :=\n      sum_congr rfl fun J' hJ' => by rw [Prepartition.biUnionIndex_of_mem _ hJ hJ']\n    _ = vol J (f (Ï€.tag J)) :=\n      (vol.map âŸ¨âŸ¨fun g : E â†’L[â„] F => g (f (Ï€.tag J)), rflâŸ©, fun _ _ => rflâŸ©).sum_partition_boxes\n        le_top (hÏ€i J hJ)\n\n"}
{"name":"BoxIntegral.integralSum_inf_partition","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"Î¹ : Type u\nE : Type v\nF : Type w\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nI : BoxIntegral.Box Î¹\nf : (Î¹ â†’ Real) â†’ E\nvol : BoxIntegral.BoxAdditiveMap Î¹ (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nÏ€ : BoxIntegral.TaggedPrepartition I\nÏ€' : BoxIntegral.Prepartition I\nh : Ï€'.IsPartition\nâŠ¢ Eq (BoxIntegral.integralSum f vol (Ï€.infPrepartition Ï€')) (BoxIntegral.integralSum f vol Ï€)","decl":"theorem integralSum_inf_partition (f : â„â¿ â†’ E) (vol : Î¹ â†’áµ‡áµƒ E â†’L[â„] F) (Ï€ : TaggedPrepartition I)\n    {Ï€' : Prepartition I} (h : Ï€'.IsPartition) :\n    integralSum f vol (Ï€.infPrepartition Ï€') = integralSum f vol Ï€ :=\n  integralSum_biUnion_partition f vol Ï€ _ fun _J hJ => h.restrict (Prepartition.le_of_mem _ hJ)\n\n"}
{"name":"BoxIntegral.integralSum_fiberwise","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"Î¹ : Type u\nE : Type v\nF : Type w\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nI : BoxIntegral.Box Î¹\nÎ± : Type u_1\ng : BoxIntegral.Box Î¹ â†’ Î±\nf : (Î¹ â†’ Real) â†’ E\nvol : BoxIntegral.BoxAdditiveMap Î¹ (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nÏ€ : BoxIntegral.TaggedPrepartition I\nâŠ¢ Eq ((Finset.image g Ï€.boxes).sum fun y => BoxIntegral.integralSum f vol (Ï€.filter fun x => Eq (g x) y)) (BoxIntegral.integralSum f vol Ï€)","decl":"open Classical in\ntheorem integralSum_fiberwise {Î±} (g : Box Î¹ â†’ Î±) (f : â„â¿ â†’ E) (vol : Î¹ â†’áµ‡áµƒ E â†’L[â„] F)\n    (Ï€ : TaggedPrepartition I) :\n    (âˆ‘ y âˆˆ Ï€.boxes.image g, integralSum f vol (Ï€.filter (g Â· = y))) = integralSum f vol Ï€ :=\n  Ï€.sum_fiberwise g fun J => vol J (f <| Ï€.tag J)\n\n"}
{"name":"BoxIntegral.integralSum_sub_partitions","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"Î¹ : Type u\nE : Type v\nF : Type w\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nI : BoxIntegral.Box Î¹\nf : (Î¹ â†’ Real) â†’ E\nvol : BoxIntegral.BoxAdditiveMap Î¹ (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nÏ€â‚ Ï€â‚‚ : BoxIntegral.TaggedPrepartition I\nhâ‚ : Ï€â‚.IsPartition\nhâ‚‚ : Ï€â‚‚.IsPartition\nâŠ¢ Eq (HSub.hSub (BoxIntegral.integralSum f vol Ï€â‚) (BoxIntegral.integralSum f vol Ï€â‚‚)) ((Min.min Ï€â‚.toPrepartition Ï€â‚‚.toPrepartition).boxes.sum fun J => HSub.hSub ((vol J) (f ((Ï€â‚.infPrepartition Ï€â‚‚.toPrepartition).tag J))) ((vol J) (f ((Ï€â‚‚.infPrepartition Ï€â‚.toPrepartition).tag J))))","decl":"theorem integralSum_sub_partitions (f : â„â¿ â†’ E) (vol : Î¹ â†’áµ‡áµƒ E â†’L[â„] F)\n    {Ï€â‚ Ï€â‚‚ : TaggedPrepartition I} (hâ‚ : Ï€â‚.IsPartition) (hâ‚‚ : Ï€â‚‚.IsPartition) :\n    integralSum f vol Ï€â‚ - integralSum f vol Ï€â‚‚ =\n      âˆ‘ J âˆˆ (Ï€â‚.toPrepartition âŠ“ Ï€â‚‚.toPrepartition).boxes,\n        (vol J (f <| (Ï€â‚.infPrepartition Ï€â‚‚.toPrepartition).tag J) -\n          vol J (f <| (Ï€â‚‚.infPrepartition Ï€â‚.toPrepartition).tag J)) := by\n  rw [â† integralSum_inf_partition f vol Ï€â‚ hâ‚‚, â† integralSum_inf_partition f vol Ï€â‚‚ hâ‚,\n    integralSum, integralSum, Finset.sum_sub_distrib]\n  simp only [infPrepartition_toPrepartition, inf_comm]\n\n"}
{"name":"BoxIntegral.integralSum_disjUnion","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"Î¹ : Type u\nE : Type v\nF : Type w\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nI : BoxIntegral.Box Î¹\nf : (Î¹ â†’ Real) â†’ E\nvol : BoxIntegral.BoxAdditiveMap Î¹ (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nÏ€â‚ Ï€â‚‚ : BoxIntegral.TaggedPrepartition I\nh : Disjoint Ï€â‚.iUnion Ï€â‚‚.iUnion\nâŠ¢ Eq (BoxIntegral.integralSum f vol (Ï€â‚.disjUnion Ï€â‚‚ h)) (HAdd.hAdd (BoxIntegral.integralSum f vol Ï€â‚) (BoxIntegral.integralSum f vol Ï€â‚‚))","decl":"@[simp]\ntheorem integralSum_disjUnion (f : â„â¿ â†’ E) (vol : Î¹ â†’áµ‡áµƒ E â†’L[â„] F) {Ï€â‚ Ï€â‚‚ : TaggedPrepartition I}\n    (h : Disjoint Ï€â‚.iUnion Ï€â‚‚.iUnion) :\n    integralSum f vol (Ï€â‚.disjUnion Ï€â‚‚ h) = integralSum f vol Ï€â‚ + integralSum f vol Ï€â‚‚ := by\n  refine (Prepartition.sum_disj_union_boxes h _).trans\n      (congr_argâ‚‚ (Â· + Â·) (sum_congr rfl fun J hJ => ?_) (sum_congr rfl fun J hJ => ?_))\n  Â· rw [disjUnion_tag_of_mem_left _ hJ]\n  Â· rw [disjUnion_tag_of_mem_right _ hJ]\n\n"}
{"name":"BoxIntegral.integralSum_add","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"Î¹ : Type u\nE : Type v\nF : Type w\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nI : BoxIntegral.Box Î¹\nf g : (Î¹ â†’ Real) â†’ E\nvol : BoxIntegral.BoxAdditiveMap Î¹ (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nÏ€ : BoxIntegral.TaggedPrepartition I\nâŠ¢ Eq (BoxIntegral.integralSum (HAdd.hAdd f g) vol Ï€) (HAdd.hAdd (BoxIntegral.integralSum f vol Ï€) (BoxIntegral.integralSum g vol Ï€))","decl":"@[simp]\ntheorem integralSum_add (f g : â„â¿ â†’ E) (vol : Î¹ â†’áµ‡áµƒ E â†’L[â„] F) (Ï€ : TaggedPrepartition I) :\n    integralSum (f + g) vol Ï€ = integralSum f vol Ï€ + integralSum g vol Ï€ := by\n  simp only [integralSum, Pi.add_apply, (vol _).map_add, Finset.sum_add_distrib]\n\n"}
{"name":"BoxIntegral.integralSum_neg","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"Î¹ : Type u\nE : Type v\nF : Type w\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nI : BoxIntegral.Box Î¹\nf : (Î¹ â†’ Real) â†’ E\nvol : BoxIntegral.BoxAdditiveMap Î¹ (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nÏ€ : BoxIntegral.TaggedPrepartition I\nâŠ¢ Eq (BoxIntegral.integralSum (Neg.neg f) vol Ï€) (Neg.neg (BoxIntegral.integralSum f vol Ï€))","decl":"@[simp]\ntheorem integralSum_neg (f : â„â¿ â†’ E) (vol : Î¹ â†’áµ‡áµƒ E â†’L[â„] F) (Ï€ : TaggedPrepartition I) :\n    integralSum (-f) vol Ï€ = -integralSum f vol Ï€ := by\n  simp only [integralSum, Pi.neg_apply, (vol _).map_neg, Finset.sum_neg_distrib]\n\n"}
{"name":"BoxIntegral.integralSum_smul","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"Î¹ : Type u\nE : Type v\nF : Type w\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nI : BoxIntegral.Box Î¹\nc : Real\nf : (Î¹ â†’ Real) â†’ E\nvol : BoxIntegral.BoxAdditiveMap Î¹ (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nÏ€ : BoxIntegral.TaggedPrepartition I\nâŠ¢ Eq (BoxIntegral.integralSum (HSMul.hSMul c f) vol Ï€) (HSMul.hSMul c (BoxIntegral.integralSum f vol Ï€))","decl":"@[simp]\ntheorem integralSum_smul (c : â„) (f : â„â¿ â†’ E) (vol : Î¹ â†’áµ‡áµƒ E â†’L[â„] F) (Ï€ : TaggedPrepartition I) :\n    integralSum (c â€¢ f) vol Ï€ = c â€¢ integralSum f vol Ï€ := by\n  simp only [integralSum, Finset.smul_sum, Pi.smul_apply, ContinuousLinearMap.map_smul]\n\n"}
{"name":"BoxIntegral.HasIntegral.tendsto","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"Î¹ : Type u\nE : Type v\nF : Type w\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nI : BoxIntegral.Box Î¹\ninstâœ : Fintype Î¹\nl : BoxIntegral.IntegrationParams\nf : (Î¹ â†’ Real) â†’ E\nvol : BoxIntegral.BoxAdditiveMap Î¹ (ContinuousLinearMap (RingHom.id Real) E F) Top.top\ny : F\nh : BoxIntegral.HasIntegral I l f vol y\nâŠ¢ Filter.Tendsto (BoxIntegral.integralSum f vol) (BoxIntegral.IntegrationParams.toFilteriUnion I Top.top) (nhds y)","decl":"/-- Reinterpret `BoxIntegral.HasIntegral` as `Filter.Tendsto`, e.g., dot-notation theorems\nthat are shadowed in the `BoxIntegral.HasIntegral` namespace. -/\ntheorem HasIntegral.tendsto (h : HasIntegral I l f vol y) :\n    Tendsto (integralSum f vol) (l.toFilteriUnion I âŠ¤) (ğ“ y) :=\n  h\n\n"}
{"name":"BoxIntegral.hasIntegral_iff","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"Î¹ : Type u\nE : Type v\nF : Type w\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nI : BoxIntegral.Box Î¹\ninstâœ : Fintype Î¹\nl : BoxIntegral.IntegrationParams\nf : (Î¹ â†’ Real) â†’ E\nvol : BoxIntegral.BoxAdditiveMap Î¹ (ContinuousLinearMap (RingHom.id Real) E F) Top.top\ny : F\nâŠ¢ Iff (BoxIntegral.HasIntegral I l f vol y) (âˆ€ (Îµ : Real), GT.gt Îµ 0 â†’ Exists fun r => And (âˆ€ (c : NNReal), l.RCond (r c)) (âˆ€ (c : NNReal) (Ï€ : BoxIntegral.TaggedPrepartition I), l.MemBaseSet I c (r c) Ï€ â†’ Ï€.IsPartition â†’ LE.le (Dist.dist (BoxIntegral.integralSum f vol Ï€) y) Îµ))","decl":"/-- The `Îµ`-`Î´` definition of `BoxIntegral.HasIntegral`. -/\ntheorem hasIntegral_iff : HasIntegral I l f vol y â†”\n    âˆ€ Îµ > (0 : â„), âˆƒ r : â„â‰¥0 â†’ â„â¿ â†’ Ioi (0 : â„), (âˆ€ c, l.RCond (r c)) âˆ§\n      âˆ€ c Ï€, l.MemBaseSet I c (r c) Ï€ â†’ IsPartition Ï€ â†’ dist (integralSum f vol Ï€) y â‰¤ Îµ :=\n  ((l.hasBasis_toFilteriUnion_top I).tendsto_iff nhds_basis_closedBall).trans <| by\n    simp [@forall_swap â„â‰¥0 (TaggedPrepartition I)]\n\n"}
{"name":"BoxIntegral.HasIntegral.of_mul","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"Î¹ : Type u\nE : Type v\nF : Type w\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nI : BoxIntegral.Box Î¹\ninstâœ : Fintype Î¹\nl : BoxIntegral.IntegrationParams\nf : (Î¹ â†’ Real) â†’ E\nvol : BoxIntegral.BoxAdditiveMap Î¹ (ContinuousLinearMap (RingHom.id Real) E F) Top.top\ny : F\na : Real\nh : âˆ€ (Îµ : Real), LT.lt 0 Îµ â†’ Exists fun r => And (âˆ€ (c : NNReal), l.RCond (r c)) (âˆ€ (c : NNReal) (Ï€ : BoxIntegral.TaggedPrepartition I), l.MemBaseSet I c (r c) Ï€ â†’ Ï€.IsPartition â†’ LE.le (Dist.dist (BoxIntegral.integralSum f vol Ï€) y) (HMul.hMul a Îµ))\nâŠ¢ BoxIntegral.HasIntegral I l f vol y","decl":"/-- Quite often it is more natural to prove an estimate of the form `a * Îµ`, not `Îµ` in the RHS of\n`BoxIntegral.hasIntegral_iff`, so we provide this auxiliary lemma. -/\ntheorem HasIntegral.of_mul (a : â„)\n    (h : âˆ€ Îµ : â„, 0 < Îµ â†’ âˆƒ r : â„â‰¥0 â†’ â„â¿ â†’ Ioi (0 : â„), (âˆ€ c, l.RCond (r c)) âˆ§ âˆ€ c Ï€,\n      l.MemBaseSet I c (r c) Ï€ â†’ IsPartition Ï€ â†’ dist (integralSum f vol Ï€) y â‰¤ a * Îµ) :\n    HasIntegral I l f vol y := by\n  refine hasIntegral_iff.2 fun Îµ hÎµ => ?_\n  rcases exists_pos_mul_lt hÎµ a with âŸ¨Îµ', hÎµ', haâŸ©\n  rcases h Îµ' hÎµ' with âŸ¨r, hr, HâŸ©\n  exact âŸ¨r, hr, fun c Ï€ hÏ€ hÏ€p => (H c Ï€ hÏ€ hÏ€p).trans ha.leâŸ©\n\n"}
{"name":"BoxIntegral.integrable_iff_cauchy","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"Î¹ : Type u\nE : Type v\nF : Type w\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace Real F\nI : BoxIntegral.Box Î¹\ninstâœÂ¹ : Fintype Î¹\nl : BoxIntegral.IntegrationParams\nf : (Î¹ â†’ Real) â†’ E\nvol : BoxIntegral.BoxAdditiveMap Î¹ (ContinuousLinearMap (RingHom.id Real) E F) Top.top\ninstâœ : CompleteSpace F\nâŠ¢ Iff (BoxIntegral.Integrable I l f vol) (Cauchy (Filter.map (BoxIntegral.integralSum f vol) (BoxIntegral.IntegrationParams.toFilteriUnion I Top.top)))","decl":"theorem integrable_iff_cauchy [CompleteSpace F] :\n    Integrable I l f vol â†” Cauchy ((l.toFilteriUnion I âŠ¤).map (integralSum f vol)) :=\n  cauchy_map_iff_exists_tendsto.symm\n\n"}
{"name":"BoxIntegral.integrable_iff_cauchy_basis","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"Î¹ : Type u\nE : Type v\nF : Type w\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace Real F\nI : BoxIntegral.Box Î¹\ninstâœÂ¹ : Fintype Î¹\nl : BoxIntegral.IntegrationParams\nf : (Î¹ â†’ Real) â†’ E\nvol : BoxIntegral.BoxAdditiveMap Î¹ (ContinuousLinearMap (RingHom.id Real) E F) Top.top\ninstâœ : CompleteSpace F\nâŠ¢ Iff (BoxIntegral.Integrable I l f vol) (âˆ€ (Îµ : Real), GT.gt Îµ 0 â†’ Exists fun r => And (âˆ€ (c : NNReal), l.RCond (r c)) (âˆ€ (câ‚ câ‚‚ : NNReal) (Ï€â‚ Ï€â‚‚ : BoxIntegral.TaggedPrepartition I), l.MemBaseSet I câ‚ (r câ‚) Ï€â‚ â†’ Ï€â‚.IsPartition â†’ l.MemBaseSet I câ‚‚ (r câ‚‚) Ï€â‚‚ â†’ Ï€â‚‚.IsPartition â†’ LE.le (Dist.dist (BoxIntegral.integralSum f vol Ï€â‚) (BoxIntegral.integralSum f vol Ï€â‚‚)) Îµ))","decl":"/-- In a complete space, a function is integrable if and only if its integral sums form a Cauchy\nnet. Here we restate this fact in terms of `âˆ€ Îµ > 0, âˆƒ r, ...`. -/\ntheorem integrable_iff_cauchy_basis [CompleteSpace F] : Integrable I l f vol â†”\n    âˆ€ Îµ > (0 : â„), âˆƒ r : â„â‰¥0 â†’ â„â¿ â†’ Ioi (0 : â„), (âˆ€ c, l.RCond (r c)) âˆ§\n      âˆ€ câ‚ câ‚‚ Ï€â‚ Ï€â‚‚, l.MemBaseSet I câ‚ (r câ‚) Ï€â‚ â†’ Ï€â‚.IsPartition â†’ l.MemBaseSet I câ‚‚ (r câ‚‚) Ï€â‚‚ â†’\n        Ï€â‚‚.IsPartition â†’ dist (integralSum f vol Ï€â‚) (integralSum f vol Ï€â‚‚) â‰¤ Îµ := by\n  rw [integrable_iff_cauchy, cauchy_map_iff',\n    (l.hasBasis_toFilteriUnion_top _).prod_self.tendsto_iff uniformity_basis_dist_le]\n  refine forallâ‚‚_congr fun Îµ _ => exists_congr fun r => ?_\n  simp only [exists_prop, Prod.forall, Set.mem_iUnion, exists_imp, prod_mk_mem_set_prod_eq, and_imp,\n    mem_inter_iff, mem_setOf_eq]\n  exact\n    and_congr Iff.rfl\n      âŸ¨fun H câ‚ câ‚‚ Ï€â‚ Ï€â‚‚ hâ‚ hUâ‚ hâ‚‚ hUâ‚‚ => H Ï€â‚ Ï€â‚‚ câ‚ hâ‚ hUâ‚ câ‚‚ hâ‚‚ hUâ‚‚,\n        fun H Ï€â‚ Ï€â‚‚ câ‚ hâ‚ hUâ‚ câ‚‚ hâ‚‚ hUâ‚‚ => H câ‚ câ‚‚ Ï€â‚ Ï€â‚‚ hâ‚ hUâ‚ hâ‚‚ hUâ‚‚âŸ©\n\n"}
{"name":"BoxIntegral.HasIntegral.mono","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"Î¹ : Type u\nE : Type v\nF : Type w\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nI : BoxIntegral.Box Î¹\ninstâœ : Fintype Î¹\nf : (Î¹ â†’ Real) â†’ E\nvol : BoxIntegral.BoxAdditiveMap Î¹ (ContinuousLinearMap (RingHom.id Real) E F) Top.top\ny : F\nlâ‚ lâ‚‚ : BoxIntegral.IntegrationParams\nh : BoxIntegral.HasIntegral I lâ‚ f vol y\nhl : LE.le lâ‚‚ lâ‚\nâŠ¢ BoxIntegral.HasIntegral I lâ‚‚ f vol y","decl":"theorem HasIntegral.mono {lâ‚ lâ‚‚ : IntegrationParams} (h : HasIntegral I lâ‚ f vol y) (hl : lâ‚‚ â‰¤ lâ‚) :\n    HasIntegral I lâ‚‚ f vol y :=\n  h.mono_left <| IntegrationParams.toFilteriUnion_mono _ hl _\n\n"}
{"name":"BoxIntegral.Integrable.hasIntegral","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"Î¹ : Type u\nE : Type v\nF : Type w\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nI : BoxIntegral.Box Î¹\ninstâœ : Fintype Î¹\nl : BoxIntegral.IntegrationParams\nf : (Î¹ â†’ Real) â†’ E\nvol : BoxIntegral.BoxAdditiveMap Î¹ (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nh : BoxIntegral.Integrable I l f vol\nâŠ¢ BoxIntegral.HasIntegral I l f vol (BoxIntegral.integral I l f vol)","decl":"protected theorem Integrable.hasIntegral (h : Integrable I l f vol) :\n    HasIntegral I l f vol (integral I l f vol) := by\n  rw [integral, dif_pos h]\n  exact Classical.choose_spec h\n\n"}
{"name":"BoxIntegral.Integrable.mono","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"Î¹ : Type u\nE : Type v\nF : Type w\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nI : BoxIntegral.Box Î¹\ninstâœ : Fintype Î¹\nl : BoxIntegral.IntegrationParams\nf : (Î¹ â†’ Real) â†’ E\nvol : BoxIntegral.BoxAdditiveMap Î¹ (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nl' : BoxIntegral.IntegrationParams\nh : BoxIntegral.Integrable I l f vol\nhle : LE.le l' l\nâŠ¢ BoxIntegral.Integrable I l' f vol","decl":"theorem Integrable.mono {l'} (h : Integrable I l f vol) (hle : l' â‰¤ l) : Integrable I l' f vol :=\n  âŸ¨_, h.hasIntegral.mono hleâŸ©\n\n"}
{"name":"BoxIntegral.HasIntegral.unique","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"Î¹ : Type u\nE : Type v\nF : Type w\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nI : BoxIntegral.Box Î¹\ninstâœ : Fintype Î¹\nl : BoxIntegral.IntegrationParams\nf : (Î¹ â†’ Real) â†’ E\nvol : BoxIntegral.BoxAdditiveMap Î¹ (ContinuousLinearMap (RingHom.id Real) E F) Top.top\ny y' : F\nh : BoxIntegral.HasIntegral I l f vol y\nh' : BoxIntegral.HasIntegral I l f vol y'\nâŠ¢ Eq y y'","decl":"theorem HasIntegral.unique (h : HasIntegral I l f vol y) (h' : HasIntegral I l f vol y') : y = y' :=\n  tendsto_nhds_unique h h'\n\n"}
{"name":"BoxIntegral.HasIntegral.integrable","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"Î¹ : Type u\nE : Type v\nF : Type w\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nI : BoxIntegral.Box Î¹\ninstâœ : Fintype Î¹\nl : BoxIntegral.IntegrationParams\nf : (Î¹ â†’ Real) â†’ E\nvol : BoxIntegral.BoxAdditiveMap Î¹ (ContinuousLinearMap (RingHom.id Real) E F) Top.top\ny : F\nh : BoxIntegral.HasIntegral I l f vol y\nâŠ¢ BoxIntegral.Integrable I l f vol","decl":"theorem HasIntegral.integrable (h : HasIntegral I l f vol y) : Integrable I l f vol :=\n  âŸ¨_, hâŸ©\n\n"}
{"name":"BoxIntegral.HasIntegral.integral_eq","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"Î¹ : Type u\nE : Type v\nF : Type w\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nI : BoxIntegral.Box Î¹\ninstâœ : Fintype Î¹\nl : BoxIntegral.IntegrationParams\nf : (Î¹ â†’ Real) â†’ E\nvol : BoxIntegral.BoxAdditiveMap Î¹ (ContinuousLinearMap (RingHom.id Real) E F) Top.top\ny : F\nh : BoxIntegral.HasIntegral I l f vol y\nâŠ¢ Eq (BoxIntegral.integral I l f vol) y","decl":"theorem HasIntegral.integral_eq (h : HasIntegral I l f vol y) : integral I l f vol = y :=\n  h.integrable.hasIntegral.unique h\n\n"}
{"name":"BoxIntegral.HasIntegral.add","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"Î¹ : Type u\nE : Type v\nF : Type w\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nI : BoxIntegral.Box Î¹\ninstâœ : Fintype Î¹\nl : BoxIntegral.IntegrationParams\nf g : (Î¹ â†’ Real) â†’ E\nvol : BoxIntegral.BoxAdditiveMap Î¹ (ContinuousLinearMap (RingHom.id Real) E F) Top.top\ny y' : F\nh : BoxIntegral.HasIntegral I l f vol y\nh' : BoxIntegral.HasIntegral I l g vol y'\nâŠ¢ BoxIntegral.HasIntegral I l (HAdd.hAdd f g) vol (HAdd.hAdd y y')","decl":"nonrec theorem HasIntegral.add (h : HasIntegral I l f vol y) (h' : HasIntegral I l g vol y') :\n    HasIntegral I l (f + g) vol (y + y') := by\n  simpa only [HasIntegral, â† integralSum_add] using h.add h'\n\n"}
{"name":"BoxIntegral.Integrable.add","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"Î¹ : Type u\nE : Type v\nF : Type w\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nI : BoxIntegral.Box Î¹\ninstâœ : Fintype Î¹\nl : BoxIntegral.IntegrationParams\nf g : (Î¹ â†’ Real) â†’ E\nvol : BoxIntegral.BoxAdditiveMap Î¹ (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nhf : BoxIntegral.Integrable I l f vol\nhg : BoxIntegral.Integrable I l g vol\nâŠ¢ BoxIntegral.Integrable I l (HAdd.hAdd f g) vol","decl":"theorem Integrable.add (hf : Integrable I l f vol) (hg : Integrable I l g vol) :\n    Integrable I l (f + g) vol :=\n  (hf.hasIntegral.add hg.hasIntegral).integrable\n\n"}
{"name":"BoxIntegral.integral_add","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"Î¹ : Type u\nE : Type v\nF : Type w\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nI : BoxIntegral.Box Î¹\ninstâœ : Fintype Î¹\nl : BoxIntegral.IntegrationParams\nf g : (Î¹ â†’ Real) â†’ E\nvol : BoxIntegral.BoxAdditiveMap Î¹ (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nhf : BoxIntegral.Integrable I l f vol\nhg : BoxIntegral.Integrable I l g vol\nâŠ¢ Eq (BoxIntegral.integral I l (HAdd.hAdd f g) vol) (HAdd.hAdd (BoxIntegral.integral I l f vol) (BoxIntegral.integral I l g vol))","decl":"theorem integral_add (hf : Integrable I l f vol) (hg : Integrable I l g vol) :\n    integral I l (f + g) vol = integral I l f vol + integral I l g vol :=\n  (hf.hasIntegral.add hg.hasIntegral).integral_eq\n\n"}
{"name":"BoxIntegral.HasIntegral.neg","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"Î¹ : Type u\nE : Type v\nF : Type w\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nI : BoxIntegral.Box Î¹\ninstâœ : Fintype Î¹\nl : BoxIntegral.IntegrationParams\nf : (Î¹ â†’ Real) â†’ E\nvol : BoxIntegral.BoxAdditiveMap Î¹ (ContinuousLinearMap (RingHom.id Real) E F) Top.top\ny : F\nhf : BoxIntegral.HasIntegral I l f vol y\nâŠ¢ BoxIntegral.HasIntegral I l (Neg.neg f) vol (Neg.neg y)","decl":"nonrec theorem HasIntegral.neg (hf : HasIntegral I l f vol y) : HasIntegral I l (-f) vol (-y) := by\n  simpa only [HasIntegral, â† integralSum_neg] using hf.neg\n\n"}
{"name":"BoxIntegral.Integrable.neg","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"Î¹ : Type u\nE : Type v\nF : Type w\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nI : BoxIntegral.Box Î¹\ninstâœ : Fintype Î¹\nl : BoxIntegral.IntegrationParams\nf : (Î¹ â†’ Real) â†’ E\nvol : BoxIntegral.BoxAdditiveMap Î¹ (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nhf : BoxIntegral.Integrable I l f vol\nâŠ¢ BoxIntegral.Integrable I l (Neg.neg f) vol","decl":"theorem Integrable.neg (hf : Integrable I l f vol) : Integrable I l (-f) vol :=\n  hf.hasIntegral.neg.integrable\n\n"}
{"name":"BoxIntegral.Integrable.of_neg","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"Î¹ : Type u\nE : Type v\nF : Type w\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nI : BoxIntegral.Box Î¹\ninstâœ : Fintype Î¹\nl : BoxIntegral.IntegrationParams\nf : (Î¹ â†’ Real) â†’ E\nvol : BoxIntegral.BoxAdditiveMap Î¹ (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nhf : BoxIntegral.Integrable I l (Neg.neg f) vol\nâŠ¢ BoxIntegral.Integrable I l f vol","decl":"theorem Integrable.of_neg (hf : Integrable I l (-f) vol) : Integrable I l f vol :=\n  neg_neg f â–¸ hf.neg\n\n"}
{"name":"BoxIntegral.integrable_neg","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"Î¹ : Type u\nE : Type v\nF : Type w\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nI : BoxIntegral.Box Î¹\ninstâœ : Fintype Î¹\nl : BoxIntegral.IntegrationParams\nf : (Î¹ â†’ Real) â†’ E\nvol : BoxIntegral.BoxAdditiveMap Î¹ (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nâŠ¢ Iff (BoxIntegral.Integrable I l (Neg.neg f) vol) (BoxIntegral.Integrable I l f vol)","decl":"@[simp]\ntheorem integrable_neg : Integrable I l (-f) vol â†” Integrable I l f vol :=\n  âŸ¨fun h => h.of_neg, fun h => h.negâŸ©\n\n"}
{"name":"BoxIntegral.integral_neg","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"Î¹ : Type u\nE : Type v\nF : Type w\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nI : BoxIntegral.Box Î¹\ninstâœ : Fintype Î¹\nl : BoxIntegral.IntegrationParams\nf : (Î¹ â†’ Real) â†’ E\nvol : BoxIntegral.BoxAdditiveMap Î¹ (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nâŠ¢ Eq (BoxIntegral.integral I l (Neg.neg f) vol) (Neg.neg (BoxIntegral.integral I l f vol))","decl":"@[simp]\ntheorem integral_neg : integral I l (-f) vol = -integral I l f vol := by\n  classical\n  exact if h : Integrable I l f vol then h.hasIntegral.neg.integral_eq\n  else by rw [integral, integral, dif_neg h, dif_neg (mt Integrable.of_neg h), neg_zero]\n\n"}
{"name":"BoxIntegral.HasIntegral.sub","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"Î¹ : Type u\nE : Type v\nF : Type w\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nI : BoxIntegral.Box Î¹\ninstâœ : Fintype Î¹\nl : BoxIntegral.IntegrationParams\nf g : (Î¹ â†’ Real) â†’ E\nvol : BoxIntegral.BoxAdditiveMap Î¹ (ContinuousLinearMap (RingHom.id Real) E F) Top.top\ny y' : F\nh : BoxIntegral.HasIntegral I l f vol y\nh' : BoxIntegral.HasIntegral I l g vol y'\nâŠ¢ BoxIntegral.HasIntegral I l (HSub.hSub f g) vol (HSub.hSub y y')","decl":"theorem HasIntegral.sub (h : HasIntegral I l f vol y) (h' : HasIntegral I l g vol y') :\n    HasIntegral I l (f - g) vol (y - y') := by simpa only [sub_eq_add_neg] using h.add h'.neg\n\n"}
{"name":"BoxIntegral.Integrable.sub","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"Î¹ : Type u\nE : Type v\nF : Type w\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nI : BoxIntegral.Box Î¹\ninstâœ : Fintype Î¹\nl : BoxIntegral.IntegrationParams\nf g : (Î¹ â†’ Real) â†’ E\nvol : BoxIntegral.BoxAdditiveMap Î¹ (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nhf : BoxIntegral.Integrable I l f vol\nhg : BoxIntegral.Integrable I l g vol\nâŠ¢ BoxIntegral.Integrable I l (HSub.hSub f g) vol","decl":"theorem Integrable.sub (hf : Integrable I l f vol) (hg : Integrable I l g vol) :\n    Integrable I l (f - g) vol :=\n  (hf.hasIntegral.sub hg.hasIntegral).integrable\n\n"}
{"name":"BoxIntegral.integral_sub","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"Î¹ : Type u\nE : Type v\nF : Type w\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nI : BoxIntegral.Box Î¹\ninstâœ : Fintype Î¹\nl : BoxIntegral.IntegrationParams\nf g : (Î¹ â†’ Real) â†’ E\nvol : BoxIntegral.BoxAdditiveMap Î¹ (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nhf : BoxIntegral.Integrable I l f vol\nhg : BoxIntegral.Integrable I l g vol\nâŠ¢ Eq (BoxIntegral.integral I l (HSub.hSub f g) vol) (HSub.hSub (BoxIntegral.integral I l f vol) (BoxIntegral.integral I l g vol))","decl":"theorem integral_sub (hf : Integrable I l f vol) (hg : Integrable I l g vol) :\n    integral I l (f - g) vol = integral I l f vol - integral I l g vol :=\n  (hf.hasIntegral.sub hg.hasIntegral).integral_eq\n\n"}
{"name":"BoxIntegral.hasIntegral_const","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"Î¹ : Type u\nE : Type v\nF : Type w\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nI : BoxIntegral.Box Î¹\ninstâœ : Fintype Î¹\nl : BoxIntegral.IntegrationParams\nvol : BoxIntegral.BoxAdditiveMap Î¹ (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nc : E\nâŠ¢ BoxIntegral.HasIntegral I l (fun x => c) vol ((vol I) c)","decl":"theorem hasIntegral_const (c : E) : HasIntegral I l (fun _ => c) vol (vol I c) :=\n  tendsto_const_nhds.congr' <| (l.eventually_isPartition I).mono fun _Ï€ hÏ€ => Eq.symm <|\n    (vol.map âŸ¨âŸ¨fun g : E â†’L[â„] F â†¦ g c, rflâŸ©, fun _ _ â†¦ rflâŸ©).sum_partition_boxes le_top hÏ€\n\n"}
{"name":"BoxIntegral.integral_const","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"Î¹ : Type u\nE : Type v\nF : Type w\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nI : BoxIntegral.Box Î¹\ninstâœ : Fintype Î¹\nl : BoxIntegral.IntegrationParams\nvol : BoxIntegral.BoxAdditiveMap Î¹ (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nc : E\nâŠ¢ Eq (BoxIntegral.integral I l (fun x => c) vol) ((vol I) c)","decl":"@[simp]\ntheorem integral_const (c : E) : integral I l (fun _ => c) vol = vol I c :=\n  (hasIntegral_const c).integral_eq\n\n"}
{"name":"BoxIntegral.integrable_const","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"Î¹ : Type u\nE : Type v\nF : Type w\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nI : BoxIntegral.Box Î¹\ninstâœ : Fintype Î¹\nl : BoxIntegral.IntegrationParams\nvol : BoxIntegral.BoxAdditiveMap Î¹ (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nc : E\nâŠ¢ BoxIntegral.Integrable I l (fun x => c) vol","decl":"theorem integrable_const (c : E) : Integrable I l (fun _ => c) vol :=\n  âŸ¨_, hasIntegral_const câŸ©\n\n"}
{"name":"BoxIntegral.hasIntegral_zero","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"Î¹ : Type u\nE : Type v\nF : Type w\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nI : BoxIntegral.Box Î¹\ninstâœ : Fintype Î¹\nl : BoxIntegral.IntegrationParams\nvol : BoxIntegral.BoxAdditiveMap Î¹ (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nâŠ¢ BoxIntegral.HasIntegral I l (fun x => 0) vol 0","decl":"theorem hasIntegral_zero : HasIntegral I l (fun _ => (0 : E)) vol 0 := by\n  simpa only [â† (vol I).map_zero] using hasIntegral_const (0 : E)\n\n"}
{"name":"BoxIntegral.integrable_zero","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"Î¹ : Type u\nE : Type v\nF : Type w\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nI : BoxIntegral.Box Î¹\ninstâœ : Fintype Î¹\nl : BoxIntegral.IntegrationParams\nvol : BoxIntegral.BoxAdditiveMap Î¹ (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nâŠ¢ BoxIntegral.Integrable I l (fun x => 0) vol","decl":"theorem integrable_zero : Integrable I l (fun _ => (0 : E)) vol :=\n  âŸ¨0, hasIntegral_zeroâŸ©\n\n"}
{"name":"BoxIntegral.integral_zero","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"Î¹ : Type u\nE : Type v\nF : Type w\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nI : BoxIntegral.Box Î¹\ninstâœ : Fintype Î¹\nl : BoxIntegral.IntegrationParams\nvol : BoxIntegral.BoxAdditiveMap Î¹ (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nâŠ¢ Eq (BoxIntegral.integral I l (fun x => 0) vol) 0","decl":"theorem integral_zero : integral I l (fun _ => (0 : E)) vol = 0 :=\n  hasIntegral_zero.integral_eq\n\n"}
{"name":"BoxIntegral.HasIntegral.sum","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"Î¹ : Type u\nE : Type v\nF : Type w\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nI : BoxIntegral.Box Î¹\ninstâœ : Fintype Î¹\nl : BoxIntegral.IntegrationParams\nvol : BoxIntegral.BoxAdditiveMap Î¹ (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nÎ± : Type u_1\ns : Finset Î±\nf : Î± â†’ (Î¹ â†’ Real) â†’ E\ng : Î± â†’ F\nh : âˆ€ (i : Î±), Membership.mem s i â†’ BoxIntegral.HasIntegral I l (f i) vol (g i)\nâŠ¢ BoxIntegral.HasIntegral I l (fun x => s.sum fun i => f i x) vol (s.sum fun i => g i)","decl":"theorem HasIntegral.sum {Î± : Type*} {s : Finset Î±} {f : Î± â†’ â„â¿ â†’ E} {g : Î± â†’ F}\n    (h : âˆ€ i âˆˆ s, HasIntegral I l (f i) vol (g i)) :\n    HasIntegral I l (fun x => âˆ‘ i âˆˆ s, f i x) vol (âˆ‘ i âˆˆ s, g i) := by\n  classical\n  induction' s using Finset.induction_on with a s ha ihs; Â· simp [hasIntegral_zero]\n  simp only [Finset.sum_insert ha]; rw [Finset.forall_mem_insert] at h\n  exact h.1.add (ihs h.2)\n\n"}
{"name":"BoxIntegral.HasIntegral.smul","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"Î¹ : Type u\nE : Type v\nF : Type w\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nI : BoxIntegral.Box Î¹\ninstâœ : Fintype Î¹\nl : BoxIntegral.IntegrationParams\nf : (Î¹ â†’ Real) â†’ E\nvol : BoxIntegral.BoxAdditiveMap Î¹ (ContinuousLinearMap (RingHom.id Real) E F) Top.top\ny : F\nhf : BoxIntegral.HasIntegral I l f vol y\nc : Real\nâŠ¢ BoxIntegral.HasIntegral I l (HSMul.hSMul c f) vol (HSMul.hSMul c y)","decl":"theorem HasIntegral.smul (hf : HasIntegral I l f vol y) (c : â„) :\n    HasIntegral I l (c â€¢ f) vol (c â€¢ y) := by\n  simpa only [HasIntegral, â† integralSum_smul] using\n    (tendsto_const_nhds : Tendsto _ _ (ğ“ c)).smul hf\n\n"}
{"name":"BoxIntegral.Integrable.smul","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"Î¹ : Type u\nE : Type v\nF : Type w\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nI : BoxIntegral.Box Î¹\ninstâœ : Fintype Î¹\nl : BoxIntegral.IntegrationParams\nf : (Î¹ â†’ Real) â†’ E\nvol : BoxIntegral.BoxAdditiveMap Î¹ (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nhf : BoxIntegral.Integrable I l f vol\nc : Real\nâŠ¢ BoxIntegral.Integrable I l (HSMul.hSMul c f) vol","decl":"theorem Integrable.smul (hf : Integrable I l f vol) (c : â„) : Integrable I l (c â€¢ f) vol :=\n  (hf.hasIntegral.smul c).integrable\n\n"}
{"name":"BoxIntegral.Integrable.of_smul","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"Î¹ : Type u\nE : Type v\nF : Type w\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nI : BoxIntegral.Box Î¹\ninstâœ : Fintype Î¹\nl : BoxIntegral.IntegrationParams\nf : (Î¹ â†’ Real) â†’ E\nvol : BoxIntegral.BoxAdditiveMap Î¹ (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nc : Real\nhf : BoxIntegral.Integrable I l (HSMul.hSMul c f) vol\nhc : Ne c 0\nâŠ¢ BoxIntegral.Integrable I l f vol","decl":"theorem Integrable.of_smul {c : â„} (hf : Integrable I l (c â€¢ f) vol) (hc : c â‰  0) :\n    Integrable I l f vol := by\n  simpa [inv_smul_smulâ‚€ hc] using hf.smul câ»Â¹\n\n"}
{"name":"BoxIntegral.integral_smul","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"Î¹ : Type u\nE : Type v\nF : Type w\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nI : BoxIntegral.Box Î¹\ninstâœ : Fintype Î¹\nl : BoxIntegral.IntegrationParams\nf : (Î¹ â†’ Real) â†’ E\nvol : BoxIntegral.BoxAdditiveMap Î¹ (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nc : Real\nâŠ¢ Eq (BoxIntegral.integral I l (fun x => HSMul.hSMul c (f x)) vol) (HSMul.hSMul c (BoxIntegral.integral I l f vol))","decl":"@[simp]\ntheorem integral_smul (c : â„) : integral I l (fun x => c â€¢ f x) vol = c â€¢ integral I l f vol := by\n  rcases eq_or_ne c 0 with (rfl | hc); Â· simp only [zero_smul, integral_zero]\n  by_cases hf : Integrable I l f vol\n  Â· exact (hf.hasIntegral.smul c).integral_eq\n  Â· have : Â¬Integrable I l (fun x => c â€¢ f x) vol := mt (fun h => h.of_smul hc) hf\n    rw [integral, integral, dif_neg hf, dif_neg this, smul_zero]\n\n"}
{"name":"BoxIntegral.integral_nonneg","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"Î¹ : Type u\nI : BoxIntegral.Box Î¹\ninstâœÂ¹ : Fintype Î¹\nl : BoxIntegral.IntegrationParams\ng : (Î¹ â†’ Real) â†’ Real\nhg : âˆ€ (x : Î¹ â†’ Real), Membership.mem (BoxIntegral.Box.Icc I) x â†’ LE.le 0 (g x)\nÎ¼ : MeasureTheory.Measure (Î¹ â†’ Real)\ninstâœ : MeasureTheory.IsLocallyFiniteMeasure Î¼\nâŠ¢ LE.le 0 (BoxIntegral.integral I l g Î¼.toBoxAdditive.toSMul)","decl":"/-- The integral of a nonnegative function w.r.t. a volume generated by a locally-finite measure is\nnonnegative. -/\ntheorem integral_nonneg {g : â„â¿ â†’ â„} (hg : âˆ€ x âˆˆ Box.Icc I, 0 â‰¤ g x) (Î¼ : Measure â„â¿)\n    [IsLocallyFiniteMeasure Î¼] : 0 â‰¤ integral I l g Î¼.toBoxAdditive.toSMul := by\n  by_cases hgi : Integrable I l g Î¼.toBoxAdditive.toSMul\n  Â· refine ge_of_tendsto' hgi.hasIntegral fun Ï€ => sum_nonneg fun J _ => ?_\n    exact mul_nonneg ENNReal.toReal_nonneg (hg _ <| Ï€.tag_mem_Icc _)\n  Â· rw [integral, dif_neg hgi]\n\n"}
{"name":"BoxIntegral.norm_integral_le_of_norm_le","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"Î¹ : Type u\nE : Type v\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\nI : BoxIntegral.Box Î¹\ninstâœÂ¹ : Fintype Î¹\nl : BoxIntegral.IntegrationParams\nf : (Î¹ â†’ Real) â†’ E\ng : (Î¹ â†’ Real) â†’ Real\nhle : âˆ€ (x : Î¹ â†’ Real), Membership.mem (BoxIntegral.Box.Icc I) x â†’ LE.le (Norm.norm (f x)) (g x)\nÎ¼ : MeasureTheory.Measure (Î¹ â†’ Real)\ninstâœ : MeasureTheory.IsLocallyFiniteMeasure Î¼\nhg : BoxIntegral.Integrable I l g Î¼.toBoxAdditive.toSMul\nâŠ¢ LE.le (Norm.norm (BoxIntegral.integral I l f Î¼.toBoxAdditive.toSMul)) (BoxIntegral.integral I l g Î¼.toBoxAdditive.toSMul)","decl":"/-- If `â€–f xâ€– â‰¤ g x` on `[l, u]` and `g` is integrable, then the norm of the integral of `f` is less\nthan or equal to the integral of `g`. -/\ntheorem norm_integral_le_of_norm_le {g : â„â¿ â†’ â„} (hle : âˆ€ x âˆˆ Box.Icc I, â€–f xâ€– â‰¤ g x)\n    (Î¼ : Measure â„â¿) [IsLocallyFiniteMeasure Î¼] (hg : Integrable I l g Î¼.toBoxAdditive.toSMul) :\n    â€–(integral I l f Î¼.toBoxAdditive.toSMul : E)â€– â‰¤ integral I l g Î¼.toBoxAdditive.toSMul := by\n  by_cases hfi : Integrable.{u, v, v} I l f Î¼.toBoxAdditive.toSMul\n  Â· refine le_of_tendsto_of_tendsto' hfi.hasIntegral.norm hg.hasIntegral fun Ï€ => ?_\n    refine norm_sum_le_of_le _ fun J _ => ?_\n    simp only [BoxAdditiveMap.toSMul_apply, norm_smul, smul_eq_mul, Real.norm_eq_abs,\n      Î¼.toBoxAdditive_apply, abs_of_nonneg ENNReal.toReal_nonneg]\n    exact mul_le_mul_of_nonneg_left (hle _ <| Ï€.tag_mem_Icc _) ENNReal.toReal_nonneg\n  Â· rw [integral, dif_neg hfi, norm_zero]\n    exact integral_nonneg (fun x hx => (norm_nonneg _).trans (hle x hx)) Î¼\n\n"}
{"name":"BoxIntegral.norm_integral_le_of_le_const","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"Î¹ : Type u\nE : Type v\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\nI : BoxIntegral.Box Î¹\ninstâœÂ¹ : Fintype Î¹\nl : BoxIntegral.IntegrationParams\nf : (Î¹ â†’ Real) â†’ E\nc : Real\nhc : âˆ€ (x : Î¹ â†’ Real), Membership.mem (BoxIntegral.Box.Icc I) x â†’ LE.le (Norm.norm (f x)) c\nÎ¼ : MeasureTheory.Measure (Î¹ â†’ Real)\ninstâœ : MeasureTheory.IsLocallyFiniteMeasure Î¼\nâŠ¢ LE.le (Norm.norm (BoxIntegral.integral I l f Î¼.toBoxAdditive.toSMul)) (HMul.hMul (Î¼ â†‘I).toReal c)","decl":"theorem norm_integral_le_of_le_const {c : â„}\n    (hc : âˆ€ x âˆˆ Box.Icc I, â€–f xâ€– â‰¤ c) (Î¼ : Measure â„â¿) [IsLocallyFiniteMeasure Î¼] :\n    â€–(integral I l f Î¼.toBoxAdditive.toSMul : E)â€– â‰¤ (Î¼ I).toReal * c := by\n  simpa only [integral_const] using norm_integral_le_of_norm_le hc Î¼ (integrable_const c)\n\n"}
{"name":"BoxIntegral.Integrable.convergenceR_cond","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"Î¹ : Type u\nE : Type v\nF : Type w\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nI : BoxIntegral.Box Î¹\ninstâœ : Fintype Î¹\nl : BoxIntegral.IntegrationParams\nf : (Î¹ â†’ Real) â†’ E\nvol : BoxIntegral.BoxAdditiveMap Î¹ (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nh : BoxIntegral.Integrable I l f vol\nÎµ : Real\nc : NNReal\nâŠ¢ l.RCond (h.convergenceR Îµ c)","decl":"theorem convergenceR_cond (h : Integrable I l f vol) (Îµ : â„) (c : â„â‰¥0) :\n    l.RCond (h.convergenceR Îµ c) := by\n  rw [convergenceR]; split_ifs with hâ‚€\n  exacts [(hasIntegral_iff.1 h.hasIntegral Îµ hâ‚€).choose_spec.1 _, fun _ x => rfl]\n\n"}
{"name":"BoxIntegral.Integrable.dist_integralSum_integral_le_of_memBaseSet","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"Î¹ : Type u\nE : Type v\nF : Type w\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nI : BoxIntegral.Box Î¹\nÏ€ : BoxIntegral.TaggedPrepartition I\ninstâœ : Fintype Î¹\nl : BoxIntegral.IntegrationParams\nf : (Î¹ â†’ Real) â†’ E\nvol : BoxIntegral.BoxAdditiveMap Î¹ (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nc : NNReal\nÎµ : Real\nh : BoxIntegral.Integrable I l f vol\nhâ‚€ : LT.lt 0 Îµ\nhÏ€ : l.MemBaseSet I c (h.convergenceR Îµ c) Ï€\nhÏ€p : Ï€.IsPartition\nâŠ¢ LE.le (Dist.dist (BoxIntegral.integralSum f vol Ï€) (BoxIntegral.integral I l f vol)) Îµ","decl":"theorem dist_integralSum_integral_le_of_memBaseSet (h : Integrable I l f vol) (hâ‚€ : 0 < Îµ)\n    (hÏ€ : l.MemBaseSet I c (h.convergenceR Îµ c) Ï€) (hÏ€p : Ï€.IsPartition) :\n    dist (integralSum f vol Ï€) (integral I l f vol) â‰¤ Îµ := by\n  rw [convergenceR, dif_pos hâ‚€] at hÏ€\n  exact (hasIntegral_iff.1 h.hasIntegral Îµ hâ‚€).choose_spec.2 c _ hÏ€ hÏ€p\n\n"}
{"name":"BoxIntegral.Integrable.dist_integralSum_le_of_memBaseSet","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"Î¹ : Type u\nE : Type v\nF : Type w\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nI : BoxIntegral.Box Î¹\ninstâœ : Fintype Î¹\nl : BoxIntegral.IntegrationParams\nf : (Î¹ â†’ Real) â†’ E\nvol : BoxIntegral.BoxAdditiveMap Î¹ (ContinuousLinearMap (RingHom.id Real) E F) Top.top\ncâ‚ câ‚‚ : NNReal\nÎµâ‚ Îµâ‚‚ : Real\nÏ€â‚ Ï€â‚‚ : BoxIntegral.TaggedPrepartition I\nh : BoxIntegral.Integrable I l f vol\nhposâ‚ : LT.lt 0 Îµâ‚\nhposâ‚‚ : LT.lt 0 Îµâ‚‚\nhâ‚ : l.MemBaseSet I câ‚ (h.convergenceR Îµâ‚ câ‚) Ï€â‚\nhâ‚‚ : l.MemBaseSet I câ‚‚ (h.convergenceR Îµâ‚‚ câ‚‚) Ï€â‚‚\nHU : Eq Ï€â‚.iUnion Ï€â‚‚.iUnion\nâŠ¢ LE.le (Dist.dist (BoxIntegral.integralSum f vol Ï€â‚) (BoxIntegral.integralSum f vol Ï€â‚‚)) (HAdd.hAdd Îµâ‚ Îµâ‚‚)","decl":"/-- **Henstock-Sacks inequality**. Let `râ‚ râ‚‚ : â„â¿ â†’ (0, âˆ)` be a function such that for any tagged\n*partition* of `I` subordinate to `râ‚–`, `k=1,2`, the integral sum of `f` over this partition differs\nfrom the integral of `f` by at most `Îµâ‚–`. Then for any two tagged *prepartition* `Ï€â‚ Ï€â‚‚` subordinate\nto `râ‚` and `râ‚‚` respectively and covering the same part of `I`, the integral sums of `f` over these\nprepartitions differ from each other by at most `Îµâ‚ + Îµâ‚‚`.\n\nThe actual statement\n\n- uses `BoxIntegral.Integrable.convergenceR` instead of a predicate assumption on `r`;\n- uses `BoxIntegral.IntegrationParams.MemBaseSet` instead of â€œsubordinate to `r`â€ to\n  account for additional requirements like being a Henstock partition or having a bounded\n  distortion.\n\nSee also `BoxIntegral.Integrable.dist_integralSum_sum_integral_le_of_memBaseSet_of_iUnion_eq` and\n`BoxIntegral.Integrable.dist_integralSum_sum_integral_le_of_memBaseSet`.\n-/\ntheorem dist_integralSum_le_of_memBaseSet (h : Integrable I l f vol) (hposâ‚ : 0 < Îµâ‚)\n    (hposâ‚‚ : 0 < Îµâ‚‚) (hâ‚ : l.MemBaseSet I câ‚ (h.convergenceR Îµâ‚ câ‚) Ï€â‚)\n    (hâ‚‚ : l.MemBaseSet I câ‚‚ (h.convergenceR Îµâ‚‚ câ‚‚) Ï€â‚‚) (HU : Ï€â‚.iUnion = Ï€â‚‚.iUnion) :\n    dist (integralSum f vol Ï€â‚) (integralSum f vol Ï€â‚‚) â‰¤ Îµâ‚ + Îµâ‚‚ := by\n  rcases hâ‚.exists_common_compl hâ‚‚ HU with âŸ¨Ï€, hÏ€U, hÏ€câ‚, hÏ€câ‚‚âŸ©\n  set r : â„â¿ â†’ Ioi (0 : â„) := fun x => min (h.convergenceR Îµâ‚ câ‚ x) (h.convergenceR Îµâ‚‚ câ‚‚ x)\n  set Ï€r := Ï€.toSubordinate r\n  have Hâ‚ :\n    dist (integralSum f vol (Ï€â‚.unionComplToSubordinate Ï€ hÏ€U r)) (integral I l f vol) â‰¤ Îµâ‚ :=\n    h.dist_integralSum_integral_le_of_memBaseSet hposâ‚\n      (hâ‚.unionComplToSubordinate (fun _ _ => min_le_left _ _) hÏ€U hÏ€câ‚)\n      (isPartition_unionComplToSubordinate _ _ _ _)\n  rw [HU] at hÏ€U\n  have Hâ‚‚ :\n    dist (integralSum f vol (Ï€â‚‚.unionComplToSubordinate Ï€ hÏ€U r)) (integral I l f vol) â‰¤ Îµâ‚‚ :=\n    h.dist_integralSum_integral_le_of_memBaseSet hposâ‚‚\n      (hâ‚‚.unionComplToSubordinate (fun _ _ => min_le_right _ _) hÏ€U hÏ€câ‚‚)\n      (isPartition_unionComplToSubordinate _ _ _ _)\n  simpa [unionComplToSubordinate] using (dist_triangle_right _ _ _).trans (add_le_add Hâ‚ Hâ‚‚)\n\n"}
{"name":"BoxIntegral.Integrable.tendsto_integralSum_toFilter_prod_self_inf_iUnion_eq_uniformity","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"Î¹ : Type u\nE : Type v\nF : Type w\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nI : BoxIntegral.Box Î¹\ninstâœ : Fintype Î¹\nl : BoxIntegral.IntegrationParams\nf : (Î¹ â†’ Real) â†’ E\nvol : BoxIntegral.BoxAdditiveMap Î¹ (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nh : BoxIntegral.Integrable I l f vol\nâŠ¢ Filter.Tendsto (fun Ï€ => { fst := BoxIntegral.integralSum f vol Ï€.1, snd := BoxIntegral.integralSum f vol Ï€.2 }) (Min.min (SProd.sprod (l.toFilter I) (l.toFilter I)) (Filter.principal (setOf fun Ï€ => Eq Ï€.1.iUnion Ï€.2.iUnion))) (uniformity F)","decl":"/-- If `f` is integrable on `I` along `l`, then for two sufficiently fine tagged prepartitions\n(in the sense of the filter `BoxIntegral.IntegrationParams.toFilter l I`) such that they cover\nthe same part of `I`, the integral sums of `f` over `Ï€â‚` and `Ï€â‚‚` are very close to each other. -/\ntheorem tendsto_integralSum_toFilter_prod_self_inf_iUnion_eq_uniformity (h : Integrable I l f vol) :\n    Tendsto (fun Ï€ : TaggedPrepartition I Ã— TaggedPrepartition I =>\n      (integralSum f vol Ï€.1, integralSum f vol Ï€.2))\n        ((l.toFilter I Ã—Ë¢ l.toFilter I) âŠ“ ğ“Ÿ {Ï€ | Ï€.1.iUnion = Ï€.2.iUnion}) (ğ“¤ F) := by\n  refine (((l.hasBasis_toFilter I).prod_self.inf_principal _).tendsto_iff\n    uniformity_basis_dist_le).2 fun Îµ Îµ0 => ?_\n  replace Îµ0 := half_pos Îµ0\n  use h.convergenceR (Îµ / 2), h.convergenceR_cond (Îµ / 2); rintro âŸ¨Ï€â‚, Ï€â‚‚âŸ© âŸ¨âŸ¨hâ‚, hâ‚‚âŸ©, hUâŸ©\n  rw [â† add_halves Îµ]\n  exact h.dist_integralSum_le_of_memBaseSet Îµ0 Îµ0 hâ‚.choose_spec hâ‚‚.choose_spec hU\n\n"}
{"name":"BoxIntegral.Integrable.cauchy_map_integralSum_toFilteriUnion","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"Î¹ : Type u\nE : Type v\nF : Type w\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nI : BoxIntegral.Box Î¹\ninstâœ : Fintype Î¹\nl : BoxIntegral.IntegrationParams\nf : (Î¹ â†’ Real) â†’ E\nvol : BoxIntegral.BoxAdditiveMap Î¹ (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nh : BoxIntegral.Integrable I l f vol\nÏ€â‚€ : BoxIntegral.Prepartition I\nâŠ¢ Cauchy (Filter.map (BoxIntegral.integralSum f vol) (BoxIntegral.IntegrationParams.toFilteriUnion I Ï€â‚€))","decl":"/-- If `f` is integrable on a box `I` along `l`, then for any fixed subset `s` of `I` that can be\nrepresented as a finite union of boxes, the integral sums of `f` over tagged prepartitions that\ncover exactly `s` form a Cauchy â€œsequenceâ€ along `l`. -/\ntheorem cauchy_map_integralSum_toFilteriUnion (h : Integrable I l f vol) (Ï€â‚€ : Prepartition I) :\n    Cauchy ((l.toFilteriUnion I Ï€â‚€).map (integralSum f vol)) := by\n  refine âŸ¨inferInstance, ?_âŸ©\n  rw [prod_map_map_eq, â† toFilter_inf_iUnion_eq, â† prod_inf_prod, prod_principal_principal]\n  exact h.tendsto_integralSum_toFilter_prod_self_inf_iUnion_eq_uniformity.mono_left\n    (inf_le_inf_left _ <| principal_mono.2 fun Ï€ h => h.1.trans h.2.symm)\n\n"}
{"name":"BoxIntegral.Integrable.to_subbox_aux","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"Î¹ : Type u\nE : Type v\nF : Type w\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace Real F\nI J : BoxIntegral.Box Î¹\ninstâœÂ¹ : Fintype Î¹\nl : BoxIntegral.IntegrationParams\nf : (Î¹ â†’ Real) â†’ E\nvol : BoxIntegral.BoxAdditiveMap Î¹ (ContinuousLinearMap (RingHom.id Real) E F) Top.top\ninstâœ : CompleteSpace F\nh : BoxIntegral.Integrable I l f vol\nhJ : LE.le J I\nâŠ¢ Exists fun y => And (BoxIntegral.HasIntegral J l f vol y) (Filter.Tendsto (BoxIntegral.integralSum f vol) (BoxIntegral.IntegrationParams.toFilteriUnion I (BoxIntegral.Prepartition.single I J hJ)) (nhds y))","decl":"theorem to_subbox_aux (h : Integrable I l f vol) (hJ : J â‰¤ I) :\n    âˆƒ y : F, HasIntegral J l f vol y âˆ§\n      Tendsto (integralSum f vol) (l.toFilteriUnion I (Prepartition.single I J hJ)) (ğ“ y) := by\n  refine (cauchy_map_iff_exists_tendsto.1\n    (h.cauchy_map_integralSum_toFilteriUnion (.single I J hJ))).imp fun y hy â†¦ âŸ¨?_, hyâŸ©\n  convert hy.comp (l.tendsto_embedBox_toFilteriUnion_top hJ) -- faster than `exact` here\n\n"}
{"name":"BoxIntegral.Integrable.to_subbox","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"Î¹ : Type u\nE : Type v\nF : Type w\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace Real F\nI J : BoxIntegral.Box Î¹\ninstâœÂ¹ : Fintype Î¹\nl : BoxIntegral.IntegrationParams\nf : (Î¹ â†’ Real) â†’ E\nvol : BoxIntegral.BoxAdditiveMap Î¹ (ContinuousLinearMap (RingHom.id Real) E F) Top.top\ninstâœ : CompleteSpace F\nh : BoxIntegral.Integrable I l f vol\nhJ : LE.le J I\nâŠ¢ BoxIntegral.Integrable J l f vol","decl":"/-- If `f` is integrable on a box `I`, then it is integrable on any subbox of `I`. -/\ntheorem to_subbox (h : Integrable I l f vol) (hJ : J â‰¤ I) : Integrable J l f vol :=\n  (h.to_subbox_aux hJ).imp fun _ => And.left\n\n"}
{"name":"BoxIntegral.Integrable.tendsto_integralSum_toFilteriUnion_single","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"Î¹ : Type u\nE : Type v\nF : Type w\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace Real F\nI J : BoxIntegral.Box Î¹\ninstâœÂ¹ : Fintype Î¹\nl : BoxIntegral.IntegrationParams\nf : (Î¹ â†’ Real) â†’ E\nvol : BoxIntegral.BoxAdditiveMap Î¹ (ContinuousLinearMap (RingHom.id Real) E F) Top.top\ninstâœ : CompleteSpace F\nh : BoxIntegral.Integrable I l f vol\nhJ : LE.le J I\nâŠ¢ Filter.Tendsto (BoxIntegral.integralSum f vol) (BoxIntegral.IntegrationParams.toFilteriUnion I (BoxIntegral.Prepartition.single I J hJ)) (nhds (BoxIntegral.integral J l f vol))","decl":"/-- If `f` is integrable on a box `I`, then integral sums of `f` over tagged prepartitions\nthat cover exactly a subbox `J â‰¤ I` tend to the integral of `f` over `J` along `l`. -/\ntheorem tendsto_integralSum_toFilteriUnion_single (h : Integrable I l f vol) (hJ : J â‰¤ I) :\n    Tendsto (integralSum f vol) (l.toFilteriUnion I (Prepartition.single I J hJ))\n      (ğ“ <| integral J l f vol) :=\n  let âŸ¨_y, hâ‚, hâ‚‚âŸ© := h.to_subbox_aux hJ\n  hâ‚.integral_eq.symm â–¸ hâ‚‚\n\n"}
{"name":"BoxIntegral.Integrable.dist_integralSum_sum_integral_le_of_memBaseSet_of_iUnion_eq","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"Î¹ : Type u\nE : Type v\nF : Type w\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace Real F\nI : BoxIntegral.Box Î¹\nÏ€ : BoxIntegral.TaggedPrepartition I\ninstâœÂ¹ : Fintype Î¹\nl : BoxIntegral.IntegrationParams\nf : (Î¹ â†’ Real) â†’ E\nvol : BoxIntegral.BoxAdditiveMap Î¹ (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nc : NNReal\nÎµ : Real\ninstâœ : CompleteSpace F\nh : BoxIntegral.Integrable I l f vol\nh0 : LT.lt 0 Îµ\nhÏ€ : l.MemBaseSet I c (h.convergenceR Îµ c) Ï€\nÏ€â‚€ : BoxIntegral.Prepartition I\nhU : Eq Ï€.iUnion Ï€â‚€.iUnion\nâŠ¢ LE.le (Dist.dist (BoxIntegral.integralSum f vol Ï€) (Ï€â‚€.boxes.sum fun J => BoxIntegral.integral J l f vol)) Îµ","decl":"/-- **Henstock-Sacks inequality**. Let `r : â„â¿ â†’ (0, âˆ)` be a function such that for any tagged\n*partition* of `I` subordinate to `r`, the integral sum of `f` over this partition differs from the\nintegral of `f` by at most `Îµ`. Then for any tagged *prepartition* `Ï€` subordinate to `r`, the\nintegral sum of `f` over this prepartition differs from the integral of `f` over the part of `I`\ncovered by `Ï€` by at most `Îµ`.\n\nThe actual statement\n\n- uses `BoxIntegral.Integrable.convergenceR` instead of a predicate assumption on `r`;\n- uses `BoxIntegral.IntegrationParams.MemBaseSet` instead of â€œsubordinate to `r`â€ to\n  account for additional requirements like being a Henstock partition or having a bounded\n  distortion;\n- takes an extra argument `Ï€â‚€ : prepartition I` and an assumption `Ï€.Union = Ï€â‚€.Union` instead of\n  using `Ï€.to_prepartition`.\n-/\ntheorem dist_integralSum_sum_integral_le_of_memBaseSet_of_iUnion_eq (h : Integrable I l f vol)\n    (h0 : 0 < Îµ) (hÏ€ : l.MemBaseSet I c (h.convergenceR Îµ c) Ï€) {Ï€â‚€ : Prepartition I}\n    (hU : Ï€.iUnion = Ï€â‚€.iUnion) :\n    dist (integralSum f vol Ï€) (âˆ‘ J âˆˆ Ï€â‚€.boxes, integral J l f vol) â‰¤ Îµ := by\n  -- Let us prove that the distance is less than or equal to `Îµ + Î´` for all positive `Î´`.\n  refine le_of_forall_pos_le_add fun Î´ Î´0 => ?_\n  -- First we choose some constants.\n  set Î´' : â„ := Î´ / (#Ï€â‚€.boxes + 1)\n  have H0 : 0 < (#Ï€â‚€.boxes + 1 : â„) := Nat.cast_add_one_pos _\n  have Î´'0 : 0 < Î´' := div_pos Î´0 H0\n  set C := max Ï€â‚€.distortion Ï€â‚€.compl.distortion\n  /- Next we choose a tagged partition of each `J âˆˆ Ï€â‚€` such that the integral sum of `f` over this\n    partition is `Î´'`-close to the integral of `f` over `J`. -/\n  have : âˆ€ J âˆˆ Ï€â‚€, âˆƒ Ï€i : TaggedPrepartition J,\n      Ï€i.IsPartition âˆ§ dist (integralSum f vol Ï€i) (integral J l f vol) â‰¤ Î´' âˆ§\n        l.MemBaseSet J C (h.convergenceR Î´' C) Ï€i := by\n    intro J hJ\n    have Hle : J â‰¤ I := Ï€â‚€.le_of_mem hJ\n    have HJi : Integrable J l f vol := h.to_subbox Hle\n    set r := fun x => min (h.convergenceR Î´' C x) (HJi.convergenceR Î´' C x)\n    have hJd : J.distortion â‰¤ C := le_trans (Finset.le_sup hJ) (le_max_left _ _)\n    rcases l.exists_memBaseSet_isPartition J hJd r with âŸ¨Ï€J, hC, hpâŸ©\n    have hCâ‚ : l.MemBaseSet J C (HJi.convergenceR Î´' C) Ï€J := by\n      refine hC.mono J le_rfl le_rfl fun x _ => ?_; exact min_le_right _ _\n    have hCâ‚‚ : l.MemBaseSet J C (h.convergenceR Î´' C) Ï€J := by\n      refine hC.mono J le_rfl le_rfl fun x _ => ?_; exact min_le_left _ _\n    exact âŸ¨Ï€J, hp, HJi.dist_integralSum_integral_le_of_memBaseSet Î´'0 hCâ‚ hp, hCâ‚‚âŸ©\n  /- Now we combine these tagged partitions into a tagged prepartition of `I` that covers the\n    same part of `I` as `Ï€â‚€` and apply `BoxIntegral.dist_integralSum_le_of_memBaseSet` to\n    `Ï€` and this prepartition. -/\n  choose! Ï€i hÏ€ip hÏ€iÎ´' hÏ€iC using this\n  have : l.MemBaseSet I C (h.convergenceR Î´' C) (Ï€â‚€.biUnionTagged Ï€i) :=\n    biUnionTagged_memBaseSet hÏ€iC hÏ€ip fun _ => le_max_right _ _\n  have hU' : Ï€.iUnion = (Ï€â‚€.biUnionTagged Ï€i).iUnion :=\n    hU.trans (Prepartition.iUnion_biUnion_partition _ hÏ€ip).symm\n  have := h.dist_integralSum_le_of_memBaseSet h0 Î´'0 hÏ€ this hU'\n  rw [integralSum_biUnionTagged] at this\n  calc\n    dist (integralSum f vol Ï€) (âˆ‘ J âˆˆ Ï€â‚€.boxes, integral J l f vol) â‰¤\n        dist (integralSum f vol Ï€) (âˆ‘ J âˆˆ Ï€â‚€.boxes, integralSum f vol (Ï€i J)) +\n          dist (âˆ‘ J âˆˆ Ï€â‚€.boxes, integralSum f vol (Ï€i J)) (âˆ‘ J âˆˆ Ï€â‚€.boxes, integral J l f vol) :=\n      dist_triangle _ _ _\n    _ â‰¤ Îµ + Î´' + âˆ‘ _J âˆˆ Ï€â‚€.boxes, Î´' := add_le_add this (dist_sum_sum_le_of_le _ hÏ€iÎ´')\n    _ = Îµ + Î´ := by field_simp [Î´']; ring\n\n"}
{"name":"BoxIntegral.Integrable.dist_integralSum_sum_integral_le_of_memBaseSet","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"Î¹ : Type u\nE : Type v\nF : Type w\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace Real F\nI : BoxIntegral.Box Î¹\nÏ€ : BoxIntegral.TaggedPrepartition I\ninstâœÂ¹ : Fintype Î¹\nl : BoxIntegral.IntegrationParams\nf : (Î¹ â†’ Real) â†’ E\nvol : BoxIntegral.BoxAdditiveMap Î¹ (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nc : NNReal\nÎµ : Real\ninstâœ : CompleteSpace F\nh : BoxIntegral.Integrable I l f vol\nh0 : LT.lt 0 Îµ\nhÏ€ : l.MemBaseSet I c (h.convergenceR Îµ c) Ï€\nâŠ¢ LE.le (Dist.dist (BoxIntegral.integralSum f vol Ï€) (Ï€.boxes.sum fun J => BoxIntegral.integral J l f vol)) Îµ","decl":"/-- **Henstock-Sacks inequality**. Let `r : â„â¿ â†’ (0, âˆ)` be a function such that for any tagged\n*partition* of `I` subordinate to `r`, the integral sum of `f` over this partition differs from the\nintegral of `f` by at most `Îµ`. Then for any tagged *prepartition* `Ï€` subordinate to `r`, the\nintegral sum of `f` over this prepartition differs from the integral of `f` over the part of `I`\ncovered by `Ï€` by at most `Îµ`.\n\nThe actual statement\n\n- uses `BoxIntegral.Integrable.convergenceR` instead of a predicate assumption on `r`;\n- uses `BoxIntegral.IntegrationParams.MemBaseSet` instead of â€œsubordinate to `r`â€ to\n  account for additional requirements like being a Henstock partition or having a bounded\n  distortion;\n-/\ntheorem dist_integralSum_sum_integral_le_of_memBaseSet (h : Integrable I l f vol) (h0 : 0 < Îµ)\n    (hÏ€ : l.MemBaseSet I c (h.convergenceR Îµ c) Ï€) :\n    dist (integralSum f vol Ï€) (âˆ‘ J âˆˆ Ï€.boxes, integral J l f vol) â‰¤ Îµ :=\n  h.dist_integralSum_sum_integral_le_of_memBaseSet_of_iUnion_eq h0 hÏ€ rfl\n\n"}
{"name":"BoxIntegral.Integrable.tendsto_integralSum_sum_integral","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"Î¹ : Type u\nE : Type v\nF : Type w\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace Real F\nI : BoxIntegral.Box Î¹\ninstâœÂ¹ : Fintype Î¹\nl : BoxIntegral.IntegrationParams\nf : (Î¹ â†’ Real) â†’ E\nvol : BoxIntegral.BoxAdditiveMap Î¹ (ContinuousLinearMap (RingHom.id Real) E F) Top.top\ninstâœ : CompleteSpace F\nh : BoxIntegral.Integrable I l f vol\nÏ€â‚€ : BoxIntegral.Prepartition I\nâŠ¢ Filter.Tendsto (BoxIntegral.integralSum f vol) (BoxIntegral.IntegrationParams.toFilteriUnion I Ï€â‚€) (nhds (Ï€â‚€.boxes.sum fun J => BoxIntegral.integral J l f vol))","decl":"/-- Integral sum of `f` over a tagged prepartition `Ï€` such that `Ï€.Union = Ï€â‚€.Union` tends to the\nsum of integrals of `f` over the boxes of `Ï€â‚€`. -/\ntheorem tendsto_integralSum_sum_integral (h : Integrable I l f vol) (Ï€â‚€ : Prepartition I) :\n    Tendsto (integralSum f vol) (l.toFilteriUnion I Ï€â‚€)\n      (ğ“ <| âˆ‘ J âˆˆ Ï€â‚€.boxes, integral J l f vol) := by\n  refine ((l.hasBasis_toFilteriUnion I Ï€â‚€).tendsto_iff nhds_basis_closedBall).2 fun Îµ Îµ0 => ?_\n  refine âŸ¨h.convergenceR Îµ, h.convergenceR_cond Îµ, ?_âŸ©\n  simp only [mem_inter_iff, Set.mem_iUnion, mem_setOf_eq]\n  rintro Ï€ âŸ¨c, hc, hUâŸ©\n  exact h.dist_integralSum_sum_integral_le_of_memBaseSet_of_iUnion_eq Îµ0 hc hU\n\n"}
{"name":"BoxIntegral.Integrable.sum_integral_congr","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"Î¹ : Type u\nE : Type v\nF : Type w\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace Real F\nI : BoxIntegral.Box Î¹\ninstâœÂ¹ : Fintype Î¹\nl : BoxIntegral.IntegrationParams\nf : (Î¹ â†’ Real) â†’ E\nvol : BoxIntegral.BoxAdditiveMap Î¹ (ContinuousLinearMap (RingHom.id Real) E F) Top.top\ninstâœ : CompleteSpace F\nh : BoxIntegral.Integrable I l f vol\nÏ€â‚ Ï€â‚‚ : BoxIntegral.Prepartition I\nhU : Eq Ï€â‚.iUnion Ï€â‚‚.iUnion\nâŠ¢ Eq (Ï€â‚.boxes.sum fun J => BoxIntegral.integral J l f vol) (Ï€â‚‚.boxes.sum fun J => BoxIntegral.integral J l f vol)","decl":"/-- If `f` is integrable on `I`, then `fun J â†¦ integral J l f vol` is box-additive on subboxes of\n`I`: if `Ï€â‚`, `Ï€â‚‚` are two prepartitions of `I` covering the same part of `I`, the sum of integrals\nof `f` over the boxes of `Ï€â‚` is equal to the sum of integrals of `f` over the boxes of `Ï€â‚‚`.\n\nSee also `BoxIntegral.Integrable.toBoxAdditive` for a bundled version. -/\ntheorem sum_integral_congr (h : Integrable I l f vol) {Ï€â‚ Ï€â‚‚ : Prepartition I}\n    (hU : Ï€â‚.iUnion = Ï€â‚‚.iUnion) :\n    âˆ‘ J âˆˆ Ï€â‚.boxes, integral J l f vol = âˆ‘ J âˆˆ Ï€â‚‚.boxes, integral J l f vol := by\n  refine tendsto_nhds_unique (h.tendsto_integralSum_sum_integral Ï€â‚) ?_\n  rw [l.toFilteriUnion_congr _ hU]\n  exact h.tendsto_integralSum_sum_integral Ï€â‚‚\n\n"}
{"name":"BoxIntegral.Integrable.toBoxAdditive_apply","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"Î¹ : Type u\nE : Type v\nF : Type w\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nI : BoxIntegral.Box Î¹\ninstâœ : Fintype Î¹\nl : BoxIntegral.IntegrationParams\nf : (Î¹ â†’ Real) â†’ E\nvol : BoxIntegral.BoxAdditiveMap Î¹ (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nh : BoxIntegral.Integrable I l f vol\nJ : BoxIntegral.Box Î¹\nâŠ¢ Eq (h.toBoxAdditive J) (BoxIntegral.integral J l f vol)","decl":"/-- If `f` is integrable on `I`, then `fun J â†¦ integral J l f vol` is box-additive on subboxes of\n`I`: if `Ï€â‚`, `Ï€â‚‚` are two prepartitions of `I` covering the same part of `I`, the sum of integrals\nof `f` over the boxes of `Ï€â‚` is equal to the sum of integrals of `f` over the boxes of `Ï€â‚‚`.\n\nSee also `BoxIntegral.Integrable.sum_integral_congr` for an unbundled version. -/\n@[simps]\ndef toBoxAdditive (h : Integrable I l f vol) : Î¹ â†’áµ‡áµƒ[I] F where\n  toFun J := integral J l f vol\n  sum_partition_boxes' J hJ Ï€ hÏ€ := by\n    replace hÏ€ := hÏ€.iUnion_eq; rw [â† Prepartition.iUnion_top] at hÏ€\n    rw [(h.to_subbox (WithTop.coe_le_coe.1 hJ)).sum_integral_congr hÏ€, Prepartition.top_boxes,\n      sum_singleton]\n\n"}
{"name":"BoxIntegral.integrable_of_bounded_and_ae_continuousWithinAt","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"Î¹ : Type u\nE : Type v\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : Fintype Î¹\nl : BoxIntegral.IntegrationParams\ninstâœÂ¹ : CompleteSpace E\nI : BoxIntegral.Box Î¹\nf : (Î¹ â†’ Real) â†’ E\nhb : Exists fun C => âˆ€ (x : Î¹ â†’ Real), Membership.mem (BoxIntegral.Box.Icc I) x â†’ LE.le (Norm.norm (f x)) C\nÎ¼ : MeasureTheory.Measure (Î¹ â†’ Real)\ninstâœ : MeasureTheory.IsLocallyFiniteMeasure Î¼\nhc : Filter.Eventually (fun x => ContinuousWithinAt f (BoxIntegral.Box.Icc I) x) (MeasureTheory.ae (Î¼.restrict (BoxIntegral.Box.Icc I)))\nâŠ¢ BoxIntegral.Integrable I l f Î¼.toBoxAdditive.toSMul","decl":"/-- A function that is bounded and a.e. continuous on a box `I` is integrable on `I`. -/\ntheorem integrable_of_bounded_and_ae_continuousWithinAt [CompleteSpace E] {I : Box Î¹} {f : â„â¿ â†’ E}\n    (hb : âˆƒ C : â„, âˆ€ x âˆˆ Box.Icc I, â€–f xâ€– â‰¤ C) (Î¼ : Measure â„â¿) [IsLocallyFiniteMeasure Î¼]\n    (hc : âˆ€áµ x âˆ‚(Î¼.restrict (Box.Icc I)), ContinuousWithinAt f (Box.Icc I) x) :\n    Integrable I l f Î¼.toBoxAdditive.toSMul := by\n  /- We prove that f is integrable by proving that we can ensure that the integralSums over any\n     two tagged prepartitions Ï€â‚ and Ï€â‚‚ can be made Îµ-close by making the partitions\n     sufficiently fine.\n\n     Start by defining some constants C, Îµâ‚, Îµâ‚‚ that will be useful later. -/\n  refine integrable_iff_cauchy_basis.2 fun Îµ Îµ0 â†¦ ?_\n  rcases exists_pos_mul_lt Îµ0 (2 * Î¼.toBoxAdditive I) with âŸ¨Îµâ‚, Îµâ‚0, hÎµâ‚âŸ©\n  rcases hb with âŸ¨C, hCâŸ©\n  have C0 : 0 â‰¤ C := by\n    obtain âŸ¨x, hxâŸ© := BoxIntegral.Box.nonempty_coe I\n    exact le_trans (norm_nonneg (f x)) <| hC x (I.coe_subset_Icc hx)\n  rcases exists_pos_mul_lt Îµ0 (4 * C) with âŸ¨Îµâ‚‚, Îµâ‚‚0, hÎµâ‚‚âŸ©\n  have Îµâ‚‚0' : ENNReal.ofReal Îµâ‚‚ â‰  0 := ne_of_gt <| ofReal_pos.2 Îµâ‚‚0\n\n  -- The set of discontinuities of f is contained in an open set U with Î¼ U < Îµâ‚‚.\n  let D := { x âˆˆ Box.Icc I | Â¬ ContinuousWithinAt f (Box.Icc I) x }\n  let Î¼' := Î¼.restrict (Box.Icc I)\n  have Î¼'D : Î¼' D = 0 := by\n    rcases eventually_iff_exists_mem.1 hc with âŸ¨V, ae, hVâŸ©\n    exact eq_of_le_of_not_lt (mem_ae_iff.1 ae â–¸ (Î¼'.mono <| fun x h xV â†¦ h.2 (hV x xV))) not_lt_zero\n  obtain âŸ¨U, UD, Uopen, hUâŸ© := Set.exists_isOpen_lt_add D (show Î¼' D â‰  âŠ¤ by simp [Î¼'D]) Îµâ‚‚0'\n  rw [Î¼'D, zero_add] at hU\n\n  /- Box.Icc I \\ U is compact and avoids discontinuities of f, so there exists r > 0 such that for\n     every x âˆˆ Box.Icc I \\ U, the oscillation (within Box.Icc I) of f on the ball of radius r\n     centered at x is â‰¤ Îµâ‚ -/\n  have comp : IsCompact (Box.Icc I \\ U) :=\n    I.isCompact_Icc.of_isClosed_subset (I.isCompact_Icc.isClosed.sdiff Uopen) Set.diff_subset\n  have : âˆ€ x âˆˆ (Box.Icc I \\ U), oscillationWithin f (Box.Icc I) x < (ENNReal.ofReal Îµâ‚) := by\n    intro x hx\n    suffices oscillationWithin f (Box.Icc I) x = 0 by rw [this]; exact ofReal_pos.2 Îµâ‚0\n    simpa [OscillationWithin.eq_zero_iff_continuousWithinAt, D, hx.1] using hx.2 âˆ˜ (fun a â†¦ UD a)\n  rcases comp.uniform_oscillationWithin this with âŸ¨r, r0, hrâŸ©\n\n  /- We prove the claim for partitions Ï€â‚ and Ï€â‚‚ subordinate to r/2, by writing the difference as\n     an integralSum over Ï€â‚ âŠ“ Ï€â‚‚ and considering separately the boxes of Ï€â‚ âŠ“ Ï€â‚‚ which are/aren't\n     fully contained within U. -/\n  refine âŸ¨fun _ _ â†¦ âŸ¨r / 2, half_pos r0âŸ©, fun _ _ _ â†¦ rfl, fun câ‚ câ‚‚ Ï€â‚ Ï€â‚‚ hâ‚ hâ‚p hâ‚‚ hâ‚‚p â†¦ ?_âŸ©\n  simp only [dist_eq_norm, integralSum_sub_partitions _ _ hâ‚p hâ‚‚p, toSMul_apply, â† smul_sub]\n  have Î¼I : Î¼ I < âŠ¤ := lt_of_le_of_lt (Î¼.mono I.coe_subset_Icc) I.isCompact_Icc.measure_lt_top\n  let tâ‚ (J : Box Î¹) : â„â¿ := (Ï€â‚.infPrepartition Ï€â‚‚.toPrepartition).tag J\n  let tâ‚‚ (J : Box Î¹) : â„â¿ := (Ï€â‚‚.infPrepartition Ï€â‚.toPrepartition).tag J\n  let B := (Ï€â‚.toPrepartition âŠ“ Ï€â‚‚.toPrepartition).boxes\n  classical\n  let B' := {J âˆˆ B | J.toSet âŠ† U}\n  have hB' : B' âŠ† B := B.filter_subset (fun J â†¦ J.toSet âŠ† U)\n  have Î¼J_ne_top : âˆ€ J âˆˆ B, Î¼ J â‰  âŠ¤ :=\n    fun J hJ â†¦ lt_top_iff_ne_top.1 <| lt_of_le_of_lt (Î¼.mono (Prepartition.le_of_mem' _ J hJ)) Î¼I\n  have un : âˆ€ S âŠ† B, â‹ƒ J âˆˆ S, J.toSet âŠ† I.toSet :=\n    fun S hS â†¦ iUnion_subset_iff.2 (fun J â†¦ iUnion_subset_iff.2 fun hJ â†¦ le_of_mem' _ J (hS hJ))\n  rw [â† sum_sdiff hB', â† add_halves Îµ]\n  apply le_trans (norm_add_le _ _) (add_le_add ?_ ?_)\n\n  /- If a box J is not contained within U, then the oscillation of f on J is small, which bounds\n     the contribution of J to the overall sum. -/\n  Â· have : âˆ€ J âˆˆ B \\ B', â€–Î¼.toBoxAdditive J â€¢ (f (tâ‚ J) - f (tâ‚‚ J))â€– â‰¤ Î¼.toBoxAdditive J * Îµâ‚ := by\n      intro J hJ\n      rw [mem_sdiff, B.mem_filter, not_and] at hJ\n      rw [norm_smul, Î¼.toBoxAdditive_apply, Real.norm_of_nonneg toReal_nonneg]\n      refine mul_le_mul_of_nonneg_left ?_ toReal_nonneg\n      obtain âŸ¨x, xJ, xnUâŸ© : âˆƒ x âˆˆ J, x âˆ‰ U := Set.not_subset.1 (hJ.2 hJ.1)\n      have hx : x âˆˆ Box.Icc I \\ U := âŸ¨Box.coe_subset_Icc ((le_of_mem' _ J hJ.1) xJ), xnUâŸ©\n      have ineq : edist (f (tâ‚ J)) (f (tâ‚‚ J)) â‰¤ EMetric.diam (f '' (ball x r âˆ© (Box.Icc I))) := by\n        apply edist_le_diam_of_mem <;>\n          refine Set.mem_image_of_mem f âŸ¨?_, tag_mem_Icc _ JâŸ© <;>\n          refine closedBall_subset_ball (div_two_lt_of_pos r0) <| mem_closedBall_comm.1 ?_\n        Â· exact hâ‚.isSubordinate.infPrepartition Ï€â‚‚.toPrepartition J hJ.1 (Box.coe_subset_Icc xJ)\n        Â· exact hâ‚‚.isSubordinate.infPrepartition Ï€â‚.toPrepartition J\n            ((Ï€â‚.mem_infPrepartition_comm).1 hJ.1) (Box.coe_subset_Icc xJ)\n      rw [â† emetric_ball] at ineq\n      simpa only [edist_le_ofReal (le_of_lt Îµâ‚0), dist_eq_norm, hJ.1] using ineq.trans (hr x hx)\n    refine (norm_sum_le _ _).trans <| (sum_le_sum this).trans ?_\n    rw [â† sum_mul]\n    trans Î¼.toBoxAdditive I * Îµâ‚; swap\n    Â· linarith\n    simp_rw [mul_le_mul_right Îµâ‚0, Î¼.toBoxAdditive_apply]\n    refine le_trans ?_ <| toReal_mono (lt_top_iff_ne_top.1 Î¼I) <| Î¼.mono <| un (B \\ B') sdiff_subset\n    rw [â† toReal_sum (fun J hJ â†¦ Î¼J_ne_top J (mem_sdiff.1 hJ).1), â† Finset.tsum_subtype]\n    refine (toReal_mono <| ne_of_lt <| lt_of_le_of_lt (Î¼.mono <| un (B \\ B') sdiff_subset) Î¼I) ?_\n    refine le_of_eq (measure_biUnion (countable_toSet _) ?_ (fun J _ â†¦ J.measurableSet_coe)).symm\n    exact fun J hJ J' hJ' hJJ' â†¦ pairwiseDisjoint _ (mem_sdiff.1 hJ).1 (mem_sdiff.1 hJ').1 hJJ'\n\n  -- The contribution of the boxes contained within U is bounded because f is bounded and Î¼ U < Îµâ‚‚.\n  Â· have : âˆ€ J âˆˆ B', â€–Î¼.toBoxAdditive J â€¢ (f (tâ‚ J) - f (tâ‚‚ J))â€– â‰¤ Î¼.toBoxAdditive J * (2 * C) := by\n      intro J _\n      rw [norm_smul, Î¼.toBoxAdditive_apply, Real.norm_of_nonneg toReal_nonneg, two_mul]\n      refine mul_le_mul_of_nonneg_left (le_trans (norm_sub_le _ _) (add_le_add ?_ ?_)) (by simp) <;>\n        exact hC _ (TaggedPrepartition.tag_mem_Icc _ J)\n    apply (norm_sum_le_of_le B' this).trans\n    simp_rw [â† sum_mul, Î¼.toBoxAdditive_apply, â† toReal_sum (fun J hJ â†¦ Î¼J_ne_top J (hB' hJ))]\n    suffices (âˆ‘ J âˆˆ B', Î¼ J).toReal â‰¤ Îµâ‚‚ by\n      linarith [mul_le_mul_of_nonneg_right this <| (mul_nonneg_iff_of_pos_left two_pos).2 C0]\n    rw [â† toReal_ofReal (le_of_lt Îµâ‚‚0)]\n    refine toReal_mono ofReal_ne_top (le_trans ?_ (le_of_lt hU))\n    trans Î¼' (â‹ƒ J âˆˆ B', J)\n    Â· simp only [Î¼', Î¼.restrict_eq_self <| (un _ hB').trans I.coe_subset_Icc]\n      exact le_of_eq <| Eq.symm <| measure_biUnion_finset\n        (fun J hJ K hK hJK â†¦ pairwiseDisjoint _ (hB' hJ) (hB' hK) hJK) fun J _ â†¦ J.measurableSet_coe\n    Â· apply Î¼'.mono\n      simp_rw [iUnion_subset_iff]\n      exact fun J hJ â†¦ (mem_filter.1 hJ).2\n\n"}
{"name":"BoxIntegral.integrable_of_bounded_and_ae_continuous","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"Î¹ : Type u\nE : Type v\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : Fintype Î¹\nl : BoxIntegral.IntegrationParams\ninstâœÂ¹ : CompleteSpace E\nI : BoxIntegral.Box Î¹\nf : (Î¹ â†’ Real) â†’ E\nhb : Exists fun C => âˆ€ (x : Î¹ â†’ Real), Membership.mem (BoxIntegral.Box.Icc I) x â†’ LE.le (Norm.norm (f x)) C\nÎ¼ : MeasureTheory.Measure (Î¹ â†’ Real)\ninstâœ : MeasureTheory.IsLocallyFiniteMeasure Î¼\nhc : Filter.Eventually (fun x => ContinuousAt f x) (MeasureTheory.ae Î¼)\nâŠ¢ BoxIntegral.Integrable I l f Î¼.toBoxAdditive.toSMul","decl":"/-- A function that is bounded on a box `I` and a.e. continuous is integrable on `I`.\n\nThis is a version of `integrable_of_bounded_and_ae_continuousWithinAt` with a stronger continuity\nassumption so that the user does not need to specialize the continuity assumption to each box on\nwhich the theorem is to be applied. -/\ntheorem integrable_of_bounded_and_ae_continuous [CompleteSpace E] {I : Box Î¹} {f : â„â¿ â†’ E}\n    (hb : âˆƒ C : â„, âˆ€ x âˆˆ Box.Icc I, â€–f xâ€– â‰¤ C) (Î¼ : Measure â„â¿) [IsLocallyFiniteMeasure Î¼]\n    (hc : âˆ€áµ x âˆ‚Î¼, ContinuousAt f x) : Integrable I l f Î¼.toBoxAdditive.toSMul :=\n  integrable_of_bounded_and_ae_continuousWithinAt l hb Î¼ <|\n    Eventually.filter_mono (ae_mono Î¼.restrict_le_self) (hc.mono fun _ h â†¦ h.continuousWithinAt)\n\n\n"}
{"name":"BoxIntegral.integrable_of_continuousOn","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"Î¹ : Type u\nE : Type v\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : Fintype Î¹\nl : BoxIntegral.IntegrationParams\ninstâœÂ¹ : CompleteSpace E\nI : BoxIntegral.Box Î¹\nf : (Î¹ â†’ Real) â†’ E\nhc : ContinuousOn f (BoxIntegral.Box.Icc I)\nÎ¼ : MeasureTheory.Measure (Î¹ â†’ Real)\ninstâœ : MeasureTheory.IsLocallyFiniteMeasure Î¼\nâŠ¢ BoxIntegral.Integrable I l f Î¼.toBoxAdditive.toSMul","decl":"/-- A continuous function is box-integrable with respect to any locally finite measure.\n\nThis is true for any volume with bounded variation. -/\ntheorem integrable_of_continuousOn [CompleteSpace E] {I : Box Î¹} {f : â„â¿ â†’ E}\n    (hc : ContinuousOn f (Box.Icc I)) (Î¼ : Measure â„â¿) [IsLocallyFiniteMeasure Î¼] :\n    Integrable.{u, v, v} I l f Î¼.toBoxAdditive.toSMul := by\n  apply integrable_of_bounded_and_ae_continuousWithinAt\n  Â· obtain âŸ¨C, hCâŸ© := (NormedSpace.isBounded_iff_subset_smul_closedBall â„).1\n                        (I.isCompact_Icc.image_of_continuousOn hc).isBounded\n    use â€–Câ€–, fun x hx â†¦ by\n      simpa only [smul_unitClosedBall, mem_closedBall_zero_iff] using hC (Set.mem_image_of_mem f hx)\n  Â· refine eventually_of_mem ?_ (fun x hx â†¦ hc.continuousWithinAt hx)\n    rw [mem_ae_iff, Î¼.restrict_apply] <;> simp [MeasurableSet.compl_iff.2 I.measurableSet_Icc]\n\n"}
{"name":"BoxIntegral.HasIntegral.of_bRiemann_eq_false_of_forall_isLittleO","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"Î¹ : Type u\nE : Type v\nF : Type w\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nI : BoxIntegral.Box Î¹\ninstâœ : Fintype Î¹\nl : BoxIntegral.IntegrationParams\nf : (Î¹ â†’ Real) â†’ E\nvol : BoxIntegral.BoxAdditiveMap Î¹ (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nhl : Eq l.bRiemann Bool.false\nB : BoxIntegral.BoxAdditiveMap Î¹ Real â†‘I\nhB0 : âˆ€ (J : BoxIntegral.Box Î¹), LE.le 0 (B J)\ng : BoxIntegral.BoxAdditiveMap Î¹ F â†‘I\ns : Set (Î¹ â†’ Real)\nhs : s.Countable\nhlH : s.Nonempty â†’ Eq l.bHenstock Bool.true\nHâ‚ : âˆ€ (c : NNReal) (x : Î¹ â†’ Real), Membership.mem (Inter.inter (BoxIntegral.Box.Icc I) s) x â†’ âˆ€ (Îµ : Real), GT.gt Îµ 0 â†’ Exists fun Î´ => And (GT.gt Î´ 0) (âˆ€ (J : BoxIntegral.Box Î¹), LE.le J I â†’ HasSubset.Subset (BoxIntegral.Box.Icc J) (Metric.closedBall x Î´) â†’ Membership.mem (BoxIntegral.Box.Icc J) x â†’ (Eq l.bDistortion Bool.true â†’ LE.le J.distortion c) â†’ LE.le (Dist.dist ((vol J) (f x)) (g J)) Îµ)\nHâ‚‚ : âˆ€ (c : NNReal) (x : Î¹ â†’ Real), Membership.mem (SDiff.sdiff (BoxIntegral.Box.Icc I) s) x â†’ âˆ€ (Îµ : Real), GT.gt Îµ 0 â†’ Exists fun Î´ => And (GT.gt Î´ 0) (âˆ€ (J : BoxIntegral.Box Î¹), LE.le J I â†’ HasSubset.Subset (BoxIntegral.Box.Icc J) (Metric.closedBall x Î´) â†’ (Eq l.bHenstock Bool.true â†’ Membership.mem (BoxIntegral.Box.Icc J) x) â†’ (Eq l.bDistortion Bool.true â†’ LE.le J.distortion c) â†’ LE.le (Dist.dist ((vol J) (f x)) (g J)) (HMul.hMul Îµ (B J)))\nâŠ¢ BoxIntegral.HasIntegral I l f vol (g I)","decl":"/-- This is an auxiliary lemma used to prove two statements at once. Use one of the next two\nlemmas instead. -/\ntheorem HasIntegral.of_bRiemann_eq_false_of_forall_isLittleO (hl : l.bRiemann = false)\n    (B : Î¹ â†’áµ‡áµƒ[I] â„) (hB0 : âˆ€ J, 0 â‰¤ B J) (g : Î¹ â†’áµ‡áµƒ[I] F) (s : Set â„â¿) (hs : s.Countable)\n    (hlH : s.Nonempty â†’ l.bHenstock = true)\n    (Hâ‚ : âˆ€ (c : â„â‰¥0), âˆ€ x âˆˆ Box.Icc I âˆ© s, âˆ€ Îµ > (0 : â„),\n      âˆƒ Î´ > 0, âˆ€ J â‰¤ I, Box.Icc J âŠ† Metric.closedBall x Î´ â†’ x âˆˆ Box.Icc J â†’\n        (l.bDistortion â†’ J.distortion â‰¤ c) â†’ dist (vol J (f x)) (g J) â‰¤ Îµ)\n    (Hâ‚‚ : âˆ€ (c : â„â‰¥0), âˆ€ x âˆˆ Box.Icc I \\ s, âˆ€ Îµ > (0 : â„),\n      âˆƒ Î´ > 0, âˆ€ J â‰¤ I, Box.Icc J âŠ† Metric.closedBall x Î´ â†’ (l.bHenstock â†’ x âˆˆ Box.Icc J) â†’\n        (l.bDistortion â†’ J.distortion â‰¤ c) â†’ dist (vol J (f x)) (g J) â‰¤ Îµ * B J) :\n    HasIntegral I l f vol (g I) := by\n  /- We choose `r x` differently for `x âˆˆ s` and `x âˆ‰ s`.\n\n    For `x âˆˆ s`, we choose `Îµs` such that `âˆ‘' x : s, Îµs x < Îµ / 2 / 2 ^ #Î¹`, then choose `r x` so\n    that `dist (vol J (f x)) (g J) â‰¤ Îµs x` for `J` in the `r x`-neighborhood of `x`. This guarantees\n    that the sum of these distances over boxes `J` such that `Ï€.tag J âˆˆ s` is less than `Îµ / 2`. We\n    need an additional multiplier `2 ^ #Î¹` because different boxes can have the same tag.\n\n    For `x âˆ‰ s`, we choose `r x` so that `dist (vol (J (f x))) (g J) â‰¤ (Îµ / 2 / B I) * B J` for a\n    box `J` in the `Î´`-neighborhood of `x`. -/\n  refine ((l.hasBasis_toFilteriUnion_top _).tendsto_iff Metric.nhds_basis_closedBall).2 ?_\n  intro Îµ Îµ0\n  simp only [â† exists_prop, gt_iff_lt, Subtype.exists'] at Hâ‚ Hâ‚‚\n  choose! Î´â‚ HÎ´â‚ using Hâ‚\n  choose! Î´â‚‚ HÎ´â‚‚ using Hâ‚‚\n  have Îµ0' := half_pos Îµ0; have H0 : 0 < (2 : â„) ^ Fintype.card Î¹ := pow_pos zero_lt_two _\n  rcases hs.exists_pos_forall_sum_le (div_pos Îµ0' H0) with âŸ¨Îµs, hÎµs0, hÎµsâŸ©\n  simp only [le_div_iffâ‚€' H0, mul_sum] at hÎµs\n  rcases exists_pos_mul_lt Îµ0' (B I) with âŸ¨Îµ', Îµ'0, hÎµIâŸ©\n  classical\n  set Î´ : â„â‰¥0 â†’ â„â¿ â†’ Ioi (0 : â„) := fun c x => if x âˆˆ s then Î´â‚ c x (Îµs x) else (Î´â‚‚ c) x Îµ'\n  refine âŸ¨Î´, fun c => l.rCond_of_bRiemann_eq_false hl, ?_âŸ©\n  simp only [Set.mem_iUnion, mem_inter_iff, mem_setOf_eq]\n  rintro Ï€ âŸ¨c, hÏ€Î´, hÏ€pâŸ©\n  -- Now we split the sum into two parts based on whether `Ï€.tag J` belongs to `s` or not.\n  rw [â† g.sum_partition_boxes le_rfl hÏ€p, Metric.mem_closedBall, integralSum,\n    â† sum_filter_add_sum_filter_not Ï€.boxes fun J => Ï€.tag J âˆˆ s,\n    â† sum_filter_add_sum_filter_not Ï€.boxes fun J => Ï€.tag J âˆˆ s, â† add_halves Îµ]\n  refine dist_add_add_le_of_le ?_ ?_\n  Â· rcases s.eq_empty_or_nonempty with (rfl | hsne); Â· simp [Îµ0'.le]\n    /- For the boxes such that `Ï€.tag J âˆˆ s`, we use the fact that at most `2 ^ #Î¹` boxes have the\n        same tag. -/\n    specialize hlH hsne\n    have : âˆ€ J âˆˆ {J âˆˆ Ï€.boxes | Ï€.tag J âˆˆ s},\n        dist (vol J (f <| Ï€.tag J)) (g J) â‰¤ Îµs (Ï€.tag J) := fun J hJ â†¦ by\n      rw [Finset.mem_filter] at hJ; cases' hJ with hJ hJs\n      refine HÎ´â‚ c _ âŸ¨Ï€.tag_mem_Icc _, hJsâŸ© _ (hÎµs0 _) _ (Ï€.le_of_mem' _ hJ) ?_\n        (hÏ€Î´.2 hlH J hJ) fun hD => (Finset.le_sup hJ).trans (hÏ€Î´.3 hD)\n      convert hÏ€Î´.1 J hJ using 3; exact (if_pos hJs).symm\n    refine (dist_sum_sum_le_of_le _ this).trans ?_\n    rw [sum_comp]\n    refine (sum_le_sum ?_).trans (hÎµs _ ?_)\n    Â· rintro b -\n      rw [â† Nat.cast_two, â† Nat.cast_pow, â† nsmul_eq_mul]\n      refine nsmul_le_nsmul_left (hÎµs0 _).le ?_\n      refine (Finset.card_le_card ?_).trans ((hÏ€Î´.isHenstock hlH).card_filter_tag_eq_le b)\n      exact filter_subset_filter _ (filter_subset _ _)\n    Â· rw [Finset.coe_image, Set.image_subset_iff]\n      exact fun J hJ => (Finset.mem_filter.1 hJ).2\n  /- Now we deal with boxes such that `Ï€.tag J âˆ‰ s`.\n    In this case the estimate is straightforward. -/\n  -- Porting note: avoided strange elaboration issues by rewriting using `calc`\n  calc\n    dist (âˆ‘ J âˆˆ Ï€.boxes with Â¬tag Ï€ J âˆˆ s, vol J (f (tag Ï€ J)))\n      (âˆ‘ J âˆˆ Ï€.boxes with Â¬tag Ï€ J âˆˆ s, g J)\n      â‰¤ âˆ‘ J âˆˆ Ï€.boxes with Â¬tag Ï€ J âˆˆ s, Îµ' * B J := dist_sum_sum_le_of_le _ fun J hJ â†¦ by\n      rw [Finset.mem_filter] at hJ; cases' hJ with hJ hJs\n      refine HÎ´â‚‚ c _ âŸ¨Ï€.tag_mem_Icc _, hJsâŸ© _ Îµ'0 _ (Ï€.le_of_mem' _ hJ) ?_ (fun hH => hÏ€Î´.2 hH J hJ)\n        fun hD => (Finset.le_sup hJ).trans (hÏ€Î´.3 hD)\n      convert hÏ€Î´.1 J hJ using 3; exact (if_neg hJs).symm\n    _ â‰¤ âˆ‘ J âˆˆ Ï€.boxes, Îµ' * B J := sum_le_sum_of_subset_of_nonneg (filter_subset _ _) fun _ _ _ â†¦\n      mul_nonneg Îµ'0.le (hB0 _)\n    _ = B I * Îµ' := by rw [â† mul_sum, B.sum_partition_boxes le_rfl hÏ€p, mul_comm]\n    _ â‰¤ Îµ / 2 := hÎµI.le\n\n"}
{"name":"BoxIntegral.HasIntegral.of_le_Henstock_of_forall_isLittleO","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"Î¹ : Type u\nE : Type v\nF : Type w\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nI : BoxIntegral.Box Î¹\ninstâœ : Fintype Î¹\nl : BoxIntegral.IntegrationParams\nf : (Î¹ â†’ Real) â†’ E\nvol : BoxIntegral.BoxAdditiveMap Î¹ (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nhl : LE.le l BoxIntegral.IntegrationParams.Henstock\nB : BoxIntegral.BoxAdditiveMap Î¹ Real â†‘I\nhB0 : âˆ€ (J : BoxIntegral.Box Î¹), LE.le 0 (B J)\ng : BoxIntegral.BoxAdditiveMap Î¹ F â†‘I\ns : Set (Î¹ â†’ Real)\nhs : s.Countable\nHâ‚ : âˆ€ (c : NNReal) (x : Î¹ â†’ Real), Membership.mem (Inter.inter (BoxIntegral.Box.Icc I) s) x â†’ âˆ€ (Îµ : Real), GT.gt Îµ 0 â†’ Exists fun Î´ => And (GT.gt Î´ 0) (âˆ€ (J : BoxIntegral.Box Î¹), LE.le J I â†’ HasSubset.Subset (BoxIntegral.Box.Icc J) (Metric.closedBall x Î´) â†’ Membership.mem (BoxIntegral.Box.Icc J) x â†’ (Eq l.bDistortion Bool.true â†’ LE.le J.distortion c) â†’ LE.le (Dist.dist ((vol J) (f x)) (g J)) Îµ)\nHâ‚‚ : âˆ€ (c : NNReal) (x : Î¹ â†’ Real), Membership.mem (SDiff.sdiff (BoxIntegral.Box.Icc I) s) x â†’ âˆ€ (Îµ : Real), GT.gt Îµ 0 â†’ Exists fun Î´ => And (GT.gt Î´ 0) (âˆ€ (J : BoxIntegral.Box Î¹), LE.le J I â†’ HasSubset.Subset (BoxIntegral.Box.Icc J) (Metric.closedBall x Î´) â†’ Membership.mem (BoxIntegral.Box.Icc J) x â†’ (Eq l.bDistortion Bool.true â†’ LE.le J.distortion c) â†’ LE.le (Dist.dist ((vol J) (f x)) (g J)) (HMul.hMul Îµ (B J)))\nâŠ¢ BoxIntegral.HasIntegral I l f vol (g I)","decl":"/-- A function `f` has Henstock (or `âŠ¥`) integral over `I` is equal to the value of a box-additive\nfunction `g` on `I` provided that `vol J (f x)` is sufficiently close to `g J` for sufficiently\nsmall boxes `J âˆ‹ x`. This lemma is useful to prove, e.g., to prove the Divergence theorem for\nintegral along `âŠ¥`.\n\nLet `l` be either `BoxIntegral.IntegrationParams.Henstock` or `âŠ¥`. Let `g` a box-additive function\non subboxes of `I`. Suppose that there exists a nonnegative box-additive function `B` and a\ncountable set `s` with the following property.\n\nFor every `c : â„â‰¥0`, a point `x âˆˆ I.Icc`, and a positive `Îµ` there exists `Î´ > 0` such that for any\nbox `J â‰¤ I` such that\n\n- `x âˆˆ J.Icc âŠ† Metric.closedBall x Î´`;\n- if `l.bDistortion` (i.e., `l = âŠ¥`), then the distortion of `J` is less than or equal to `c`,\n\nthe distance between the term `vol J (f x)` of an integral sum corresponding to `J` and `g J` is\nless than or equal to `Îµ` if `x âˆˆ s` and is less than or equal to `Îµ * B J` otherwise.\n\nThen `f` is integrable on `I` along `l` with integral `g I`. -/\ntheorem HasIntegral.of_le_Henstock_of_forall_isLittleO (hl : l â‰¤ Henstock) (B : Î¹ â†’áµ‡áµƒ[I] â„)\n    (hB0 : âˆ€ J, 0 â‰¤ B J) (g : Î¹ â†’áµ‡áµƒ[I] F) (s : Set â„â¿) (hs : s.Countable)\n    (Hâ‚ : âˆ€ (c : â„â‰¥0), âˆ€ x âˆˆ Box.Icc I âˆ© s, âˆ€ Îµ > (0 : â„),\n      âˆƒ Î´ > 0, âˆ€ J â‰¤ I, Box.Icc J âŠ† Metric.closedBall x Î´ â†’ x âˆˆ Box.Icc J â†’\n        (l.bDistortion â†’ J.distortion â‰¤ c) â†’ dist (vol J (f x)) (g J) â‰¤ Îµ)\n    (Hâ‚‚ : âˆ€ (c : â„â‰¥0), âˆ€ x âˆˆ Box.Icc I \\ s, âˆ€ Îµ > (0 : â„),\n      âˆƒ Î´ > 0, âˆ€ J â‰¤ I, Box.Icc J âŠ† Metric.closedBall x Î´ â†’ x âˆˆ Box.Icc J â†’\n        (l.bDistortion â†’ J.distortion â‰¤ c) â†’ dist (vol J (f x)) (g J) â‰¤ Îµ * B J) :\n    HasIntegral I l f vol (g I) :=\n  have A : l.bHenstock := Bool.eq_true_of_true_le hl.2.1\n  HasIntegral.of_bRiemann_eq_false_of_forall_isLittleO (Bool.eq_false_of_le_false hl.1) B hB0 _ s hs\n    (fun _ => A) Hâ‚ <| by simpa only [A, true_imp_iff] using Hâ‚‚\n\n"}
{"name":"BoxIntegral.HasIntegral.mcShane_of_forall_isLittleO","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"Î¹ : Type u\nE : Type v\nF : Type w\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nI : BoxIntegral.Box Î¹\ninstâœ : Fintype Î¹\nf : (Î¹ â†’ Real) â†’ E\nvol : BoxIntegral.BoxAdditiveMap Î¹ (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nB : BoxIntegral.BoxAdditiveMap Î¹ Real â†‘I\nhB0 : âˆ€ (J : BoxIntegral.Box Î¹), LE.le 0 (B J)\ng : BoxIntegral.BoxAdditiveMap Î¹ F â†‘I\nH : NNReal â†’ âˆ€ (x : Î¹ â†’ Real), Membership.mem (BoxIntegral.Box.Icc I) x â†’ âˆ€ (Îµ : Real), GT.gt Îµ 0 â†’ Exists fun Î´ => And (GT.gt Î´ 0) (âˆ€ (J : BoxIntegral.Box Î¹), LE.le J I â†’ HasSubset.Subset (BoxIntegral.Box.Icc J) (Metric.closedBall x Î´) â†’ LE.le (Dist.dist ((vol J) (f x)) (g J)) (HMul.hMul Îµ (B J)))\nâŠ¢ BoxIntegral.HasIntegral I BoxIntegral.IntegrationParams.McShane f vol (g I)","decl":"/-- Suppose that there exists a nonnegative box-additive function `B` with the following property.\n\nFor every `c : â„â‰¥0`, a point `x âˆˆ I.Icc`, and a positive `Îµ` there exists `Î´ > 0` such that for any\nbox `J â‰¤ I` such that\n\n- `J.Icc âŠ† Metric.closedBall x Î´`;\n- if `l.bDistortion` (i.e., `l = âŠ¥`), then the distortion of `J` is less than or equal to `c`,\n\nthe distance between the term `vol J (f x)` of an integral sum corresponding to `J` and `g J` is\nless than or equal to `Îµ * B J`.\n\nThen `f` is McShane integrable on `I` with integral `g I`. -/\ntheorem HasIntegral.mcShane_of_forall_isLittleO (B : Î¹ â†’áµ‡áµƒ[I] â„) (hB0 : âˆ€ J, 0 â‰¤ B J)\n    (g : Î¹ â†’áµ‡áµƒ[I] F) (H : âˆ€ (_ : â„â‰¥0), âˆ€ x âˆˆ Box.Icc I, âˆ€ Îµ > (0 : â„), âˆƒ Î´ > 0, âˆ€ J â‰¤ I,\n      Box.Icc J âŠ† Metric.closedBall x Î´ â†’ dist (vol J (f x)) (g J) â‰¤ Îµ * B J) :\n    HasIntegral I McShane f vol (g I) :=\n  (HasIntegral.of_bRiemann_eq_false_of_forall_isLittleO (l := McShane) rfl B hB0 g âˆ… countable_empty\n      (fun âŸ¨_x, hxâŸ© => hx.elim) fun _ _ hx => hx.2.elim) <| by\n    simpa only [McShane, Bool.coe_sort_false, false_imp_iff, true_imp_iff, diff_empty] using H\n\n"}
