{"name":"BoxIntegral.integralSum_biUnionTagged","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"ι : Type u\nE : Type v\nF : Type w\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace Real F\nI : BoxIntegral.Box ι\nf : (ι → Real) → E\nvol : BoxIntegral.BoxAdditiveMap ι (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nπ : BoxIntegral.Prepartition I\nπi : (J : BoxIntegral.Box ι) → BoxIntegral.TaggedPrepartition J\n⊢ Eq (BoxIntegral.integralSum f vol (π.biUnionTagged πi)) (π.boxes.sum fun J => BoxIntegral.integralSum f vol (πi J))","decl":"theorem integralSum_biUnionTagged (f : ℝⁿ → E) (vol : ι →ᵇᵃ E →L[ℝ] F) (π : Prepartition I)\n    (πi : ∀ J, TaggedPrepartition J) :\n    integralSum f vol (π.biUnionTagged πi) = ∑ J ∈ π.boxes, integralSum f vol (πi J) := by\n  refine (π.sum_biUnion_boxes _ _).trans <| sum_congr rfl fun J hJ => sum_congr rfl fun J' hJ' => ?_\n  rw [π.tag_biUnionTagged hJ hJ']\n\n"}
{"name":"BoxIntegral.integralSum_biUnion_partition","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"ι : Type u\nE : Type v\nF : Type w\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace Real F\nI : BoxIntegral.Box ι\nf : (ι → Real) → E\nvol : BoxIntegral.BoxAdditiveMap ι (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nπ : BoxIntegral.TaggedPrepartition I\nπi : (J : BoxIntegral.Box ι) → BoxIntegral.Prepartition J\nhπi : ∀ (J : BoxIntegral.Box ι), Membership.mem π J → (πi J).IsPartition\n⊢ Eq (BoxIntegral.integralSum f vol (π.biUnionPrepartition πi)) (BoxIntegral.integralSum f vol π)","decl":"theorem integralSum_biUnion_partition (f : ℝⁿ → E) (vol : ι →ᵇᵃ E →L[ℝ] F)\n    (π : TaggedPrepartition I) (πi : ∀ J, Prepartition J) (hπi : ∀ J ∈ π, (πi J).IsPartition) :\n    integralSum f vol (π.biUnionPrepartition πi) = integralSum f vol π := by\n  refine (π.sum_biUnion_boxes _ _).trans (sum_congr rfl fun J hJ => ?_)\n  calc\n    (∑ J' ∈ (πi J).boxes, vol J' (f (π.tag <| π.toPrepartition.biUnionIndex πi J'))) =\n        ∑ J' ∈ (πi J).boxes, vol J' (f (π.tag J)) :=\n      sum_congr rfl fun J' hJ' => by rw [Prepartition.biUnionIndex_of_mem _ hJ hJ']\n    _ = vol J (f (π.tag J)) :=\n      (vol.map ⟨⟨fun g : E →L[ℝ] F => g (f (π.tag J)), rfl⟩, fun _ _ => rfl⟩).sum_partition_boxes\n        le_top (hπi J hJ)\n\n"}
{"name":"BoxIntegral.integralSum_inf_partition","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"ι : Type u\nE : Type v\nF : Type w\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace Real F\nI : BoxIntegral.Box ι\nf : (ι → Real) → E\nvol : BoxIntegral.BoxAdditiveMap ι (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nπ : BoxIntegral.TaggedPrepartition I\nπ' : BoxIntegral.Prepartition I\nh : π'.IsPartition\n⊢ Eq (BoxIntegral.integralSum f vol (π.infPrepartition π')) (BoxIntegral.integralSum f vol π)","decl":"theorem integralSum_inf_partition (f : ℝⁿ → E) (vol : ι →ᵇᵃ E →L[ℝ] F) (π : TaggedPrepartition I)\n    {π' : Prepartition I} (h : π'.IsPartition) :\n    integralSum f vol (π.infPrepartition π') = integralSum f vol π :=\n  integralSum_biUnion_partition f vol π _ fun _J hJ => h.restrict (Prepartition.le_of_mem _ hJ)\n\n"}
{"name":"BoxIntegral.integralSum_fiberwise","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"ι : Type u\nE : Type v\nF : Type w\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace Real F\nI : BoxIntegral.Box ι\nα : Type u_1\ng : BoxIntegral.Box ι → α\nf : (ι → Real) → E\nvol : BoxIntegral.BoxAdditiveMap ι (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nπ : BoxIntegral.TaggedPrepartition I\n⊢ Eq ((Finset.image g π.boxes).sum fun y => BoxIntegral.integralSum f vol (π.filter fun x => Eq (g x) y)) (BoxIntegral.integralSum f vol π)","decl":"open Classical in\ntheorem integralSum_fiberwise {α} (g : Box ι → α) (f : ℝⁿ → E) (vol : ι →ᵇᵃ E →L[ℝ] F)\n    (π : TaggedPrepartition I) :\n    (∑ y ∈ π.boxes.image g, integralSum f vol (π.filter (g · = y))) = integralSum f vol π :=\n  π.sum_fiberwise g fun J => vol J (f <| π.tag J)\n\n"}
{"name":"BoxIntegral.integralSum_sub_partitions","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"ι : Type u\nE : Type v\nF : Type w\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace Real F\nI : BoxIntegral.Box ι\nf : (ι → Real) → E\nvol : BoxIntegral.BoxAdditiveMap ι (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nπ₁ π₂ : BoxIntegral.TaggedPrepartition I\nh₁ : π₁.IsPartition\nh₂ : π₂.IsPartition\n⊢ Eq (HSub.hSub (BoxIntegral.integralSum f vol π₁) (BoxIntegral.integralSum f vol π₂)) ((Min.min π₁.toPrepartition π₂.toPrepartition).boxes.sum fun J => HSub.hSub ((vol J) (f ((π₁.infPrepartition π₂.toPrepartition).tag J))) ((vol J) (f ((π₂.infPrepartition π₁.toPrepartition).tag J))))","decl":"theorem integralSum_sub_partitions (f : ℝⁿ → E) (vol : ι →ᵇᵃ E →L[ℝ] F)\n    {π₁ π₂ : TaggedPrepartition I} (h₁ : π₁.IsPartition) (h₂ : π₂.IsPartition) :\n    integralSum f vol π₁ - integralSum f vol π₂ =\n      ∑ J ∈ (π₁.toPrepartition ⊓ π₂.toPrepartition).boxes,\n        (vol J (f <| (π₁.infPrepartition π₂.toPrepartition).tag J) -\n          vol J (f <| (π₂.infPrepartition π₁.toPrepartition).tag J)) := by\n  rw [← integralSum_inf_partition f vol π₁ h₂, ← integralSum_inf_partition f vol π₂ h₁,\n    integralSum, integralSum, Finset.sum_sub_distrib]\n  simp only [infPrepartition_toPrepartition, inf_comm]\n\n"}
{"name":"BoxIntegral.integralSum_disjUnion","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"ι : Type u\nE : Type v\nF : Type w\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace Real F\nI : BoxIntegral.Box ι\nf : (ι → Real) → E\nvol : BoxIntegral.BoxAdditiveMap ι (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nπ₁ π₂ : BoxIntegral.TaggedPrepartition I\nh : Disjoint π₁.iUnion π₂.iUnion\n⊢ Eq (BoxIntegral.integralSum f vol (π₁.disjUnion π₂ h)) (HAdd.hAdd (BoxIntegral.integralSum f vol π₁) (BoxIntegral.integralSum f vol π₂))","decl":"@[simp]\ntheorem integralSum_disjUnion (f : ℝⁿ → E) (vol : ι →ᵇᵃ E →L[ℝ] F) {π₁ π₂ : TaggedPrepartition I}\n    (h : Disjoint π₁.iUnion π₂.iUnion) :\n    integralSum f vol (π₁.disjUnion π₂ h) = integralSum f vol π₁ + integralSum f vol π₂ := by\n  refine (Prepartition.sum_disj_union_boxes h _).trans\n      (congr_arg₂ (· + ·) (sum_congr rfl fun J hJ => ?_) (sum_congr rfl fun J hJ => ?_))\n  · rw [disjUnion_tag_of_mem_left _ hJ]\n  · rw [disjUnion_tag_of_mem_right _ hJ]\n\n"}
{"name":"BoxIntegral.integralSum_add","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"ι : Type u\nE : Type v\nF : Type w\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace Real F\nI : BoxIntegral.Box ι\nf g : (ι → Real) → E\nvol : BoxIntegral.BoxAdditiveMap ι (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nπ : BoxIntegral.TaggedPrepartition I\n⊢ Eq (BoxIntegral.integralSum (HAdd.hAdd f g) vol π) (HAdd.hAdd (BoxIntegral.integralSum f vol π) (BoxIntegral.integralSum g vol π))","decl":"@[simp]\ntheorem integralSum_add (f g : ℝⁿ → E) (vol : ι →ᵇᵃ E →L[ℝ] F) (π : TaggedPrepartition I) :\n    integralSum (f + g) vol π = integralSum f vol π + integralSum g vol π := by\n  simp only [integralSum, Pi.add_apply, (vol _).map_add, Finset.sum_add_distrib]\n\n"}
{"name":"BoxIntegral.integralSum_neg","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"ι : Type u\nE : Type v\nF : Type w\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace Real F\nI : BoxIntegral.Box ι\nf : (ι → Real) → E\nvol : BoxIntegral.BoxAdditiveMap ι (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nπ : BoxIntegral.TaggedPrepartition I\n⊢ Eq (BoxIntegral.integralSum (Neg.neg f) vol π) (Neg.neg (BoxIntegral.integralSum f vol π))","decl":"@[simp]\ntheorem integralSum_neg (f : ℝⁿ → E) (vol : ι →ᵇᵃ E →L[ℝ] F) (π : TaggedPrepartition I) :\n    integralSum (-f) vol π = -integralSum f vol π := by\n  simp only [integralSum, Pi.neg_apply, (vol _).map_neg, Finset.sum_neg_distrib]\n\n"}
{"name":"BoxIntegral.integralSum_smul","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"ι : Type u\nE : Type v\nF : Type w\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace Real F\nI : BoxIntegral.Box ι\nc : Real\nf : (ι → Real) → E\nvol : BoxIntegral.BoxAdditiveMap ι (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nπ : BoxIntegral.TaggedPrepartition I\n⊢ Eq (BoxIntegral.integralSum (HSMul.hSMul c f) vol π) (HSMul.hSMul c (BoxIntegral.integralSum f vol π))","decl":"@[simp]\ntheorem integralSum_smul (c : ℝ) (f : ℝⁿ → E) (vol : ι →ᵇᵃ E →L[ℝ] F) (π : TaggedPrepartition I) :\n    integralSum (c • f) vol π = c • integralSum f vol π := by\n  simp only [integralSum, Finset.smul_sum, Pi.smul_apply, ContinuousLinearMap.map_smul]\n\n"}
{"name":"BoxIntegral.HasIntegral.tendsto","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"ι : Type u\nE : Type v\nF : Type w\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Real F\nI : BoxIntegral.Box ι\ninst✝ : Fintype ι\nl : BoxIntegral.IntegrationParams\nf : (ι → Real) → E\nvol : BoxIntegral.BoxAdditiveMap ι (ContinuousLinearMap (RingHom.id Real) E F) Top.top\ny : F\nh : BoxIntegral.HasIntegral I l f vol y\n⊢ Filter.Tendsto (BoxIntegral.integralSum f vol) (BoxIntegral.IntegrationParams.toFilteriUnion I Top.top) (nhds y)","decl":"/-- Reinterpret `BoxIntegral.HasIntegral` as `Filter.Tendsto`, e.g., dot-notation theorems\nthat are shadowed in the `BoxIntegral.HasIntegral` namespace. -/\ntheorem HasIntegral.tendsto (h : HasIntegral I l f vol y) :\n    Tendsto (integralSum f vol) (l.toFilteriUnion I ⊤) (𝓝 y) :=\n  h\n\n"}
{"name":"BoxIntegral.hasIntegral_iff","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"ι : Type u\nE : Type v\nF : Type w\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Real F\nI : BoxIntegral.Box ι\ninst✝ : Fintype ι\nl : BoxIntegral.IntegrationParams\nf : (ι → Real) → E\nvol : BoxIntegral.BoxAdditiveMap ι (ContinuousLinearMap (RingHom.id Real) E F) Top.top\ny : F\n⊢ Iff (BoxIntegral.HasIntegral I l f vol y) (∀ (ε : Real), GT.gt ε 0 → Exists fun r => And (∀ (c : NNReal), l.RCond (r c)) (∀ (c : NNReal) (π : BoxIntegral.TaggedPrepartition I), l.MemBaseSet I c (r c) π → π.IsPartition → LE.le (Dist.dist (BoxIntegral.integralSum f vol π) y) ε))","decl":"/-- The `ε`-`δ` definition of `BoxIntegral.HasIntegral`. -/\ntheorem hasIntegral_iff : HasIntegral I l f vol y ↔\n    ∀ ε > (0 : ℝ), ∃ r : ℝ≥0 → ℝⁿ → Ioi (0 : ℝ), (∀ c, l.RCond (r c)) ∧\n      ∀ c π, l.MemBaseSet I c (r c) π → IsPartition π → dist (integralSum f vol π) y ≤ ε :=\n  ((l.hasBasis_toFilteriUnion_top I).tendsto_iff nhds_basis_closedBall).trans <| by\n    simp [@forall_swap ℝ≥0 (TaggedPrepartition I)]\n\n"}
{"name":"BoxIntegral.HasIntegral.of_mul","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"ι : Type u\nE : Type v\nF : Type w\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Real F\nI : BoxIntegral.Box ι\ninst✝ : Fintype ι\nl : BoxIntegral.IntegrationParams\nf : (ι → Real) → E\nvol : BoxIntegral.BoxAdditiveMap ι (ContinuousLinearMap (RingHom.id Real) E F) Top.top\ny : F\na : Real\nh : ∀ (ε : Real), LT.lt 0 ε → Exists fun r => And (∀ (c : NNReal), l.RCond (r c)) (∀ (c : NNReal) (π : BoxIntegral.TaggedPrepartition I), l.MemBaseSet I c (r c) π → π.IsPartition → LE.le (Dist.dist (BoxIntegral.integralSum f vol π) y) (HMul.hMul a ε))\n⊢ BoxIntegral.HasIntegral I l f vol y","decl":"/-- Quite often it is more natural to prove an estimate of the form `a * ε`, not `ε` in the RHS of\n`BoxIntegral.hasIntegral_iff`, so we provide this auxiliary lemma. -/\ntheorem HasIntegral.of_mul (a : ℝ)\n    (h : ∀ ε : ℝ, 0 < ε → ∃ r : ℝ≥0 → ℝⁿ → Ioi (0 : ℝ), (∀ c, l.RCond (r c)) ∧ ∀ c π,\n      l.MemBaseSet I c (r c) π → IsPartition π → dist (integralSum f vol π) y ≤ a * ε) :\n    HasIntegral I l f vol y := by\n  refine hasIntegral_iff.2 fun ε hε => ?_\n  rcases exists_pos_mul_lt hε a with ⟨ε', hε', ha⟩\n  rcases h ε' hε' with ⟨r, hr, H⟩\n  exact ⟨r, hr, fun c π hπ hπp => (H c π hπ hπp).trans ha.le⟩\n\n"}
{"name":"BoxIntegral.integrable_iff_cauchy","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"ι : Type u\nE : Type v\nF : Type w\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace Real E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace Real F\nI : BoxIntegral.Box ι\ninst✝¹ : Fintype ι\nl : BoxIntegral.IntegrationParams\nf : (ι → Real) → E\nvol : BoxIntegral.BoxAdditiveMap ι (ContinuousLinearMap (RingHom.id Real) E F) Top.top\ninst✝ : CompleteSpace F\n⊢ Iff (BoxIntegral.Integrable I l f vol) (Cauchy (Filter.map (BoxIntegral.integralSum f vol) (BoxIntegral.IntegrationParams.toFilteriUnion I Top.top)))","decl":"theorem integrable_iff_cauchy [CompleteSpace F] :\n    Integrable I l f vol ↔ Cauchy ((l.toFilteriUnion I ⊤).map (integralSum f vol)) :=\n  cauchy_map_iff_exists_tendsto.symm\n\n"}
{"name":"BoxIntegral.integrable_iff_cauchy_basis","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"ι : Type u\nE : Type v\nF : Type w\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace Real E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace Real F\nI : BoxIntegral.Box ι\ninst✝¹ : Fintype ι\nl : BoxIntegral.IntegrationParams\nf : (ι → Real) → E\nvol : BoxIntegral.BoxAdditiveMap ι (ContinuousLinearMap (RingHom.id Real) E F) Top.top\ninst✝ : CompleteSpace F\n⊢ Iff (BoxIntegral.Integrable I l f vol) (∀ (ε : Real), GT.gt ε 0 → Exists fun r => And (∀ (c : NNReal), l.RCond (r c)) (∀ (c₁ c₂ : NNReal) (π₁ π₂ : BoxIntegral.TaggedPrepartition I), l.MemBaseSet I c₁ (r c₁) π₁ → π₁.IsPartition → l.MemBaseSet I c₂ (r c₂) π₂ → π₂.IsPartition → LE.le (Dist.dist (BoxIntegral.integralSum f vol π₁) (BoxIntegral.integralSum f vol π₂)) ε))","decl":"/-- In a complete space, a function is integrable if and only if its integral sums form a Cauchy\nnet. Here we restate this fact in terms of `∀ ε > 0, ∃ r, ...`. -/\ntheorem integrable_iff_cauchy_basis [CompleteSpace F] : Integrable I l f vol ↔\n    ∀ ε > (0 : ℝ), ∃ r : ℝ≥0 → ℝⁿ → Ioi (0 : ℝ), (∀ c, l.RCond (r c)) ∧\n      ∀ c₁ c₂ π₁ π₂, l.MemBaseSet I c₁ (r c₁) π₁ → π₁.IsPartition → l.MemBaseSet I c₂ (r c₂) π₂ →\n        π₂.IsPartition → dist (integralSum f vol π₁) (integralSum f vol π₂) ≤ ε := by\n  rw [integrable_iff_cauchy, cauchy_map_iff',\n    (l.hasBasis_toFilteriUnion_top _).prod_self.tendsto_iff uniformity_basis_dist_le]\n  refine forall₂_congr fun ε _ => exists_congr fun r => ?_\n  simp only [exists_prop, Prod.forall, Set.mem_iUnion, exists_imp, prod_mk_mem_set_prod_eq, and_imp,\n    mem_inter_iff, mem_setOf_eq]\n  exact\n    and_congr Iff.rfl\n      ⟨fun H c₁ c₂ π₁ π₂ h₁ hU₁ h₂ hU₂ => H π₁ π₂ c₁ h₁ hU₁ c₂ h₂ hU₂,\n        fun H π₁ π₂ c₁ h₁ hU₁ c₂ h₂ hU₂ => H c₁ c₂ π₁ π₂ h₁ hU₁ h₂ hU₂⟩\n\n"}
{"name":"BoxIntegral.HasIntegral.mono","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"ι : Type u\nE : Type v\nF : Type w\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Real F\nI : BoxIntegral.Box ι\ninst✝ : Fintype ι\nf : (ι → Real) → E\nvol : BoxIntegral.BoxAdditiveMap ι (ContinuousLinearMap (RingHom.id Real) E F) Top.top\ny : F\nl₁ l₂ : BoxIntegral.IntegrationParams\nh : BoxIntegral.HasIntegral I l₁ f vol y\nhl : LE.le l₂ l₁\n⊢ BoxIntegral.HasIntegral I l₂ f vol y","decl":"theorem HasIntegral.mono {l₁ l₂ : IntegrationParams} (h : HasIntegral I l₁ f vol y) (hl : l₂ ≤ l₁) :\n    HasIntegral I l₂ f vol y :=\n  h.mono_left <| IntegrationParams.toFilteriUnion_mono _ hl _\n\n"}
{"name":"BoxIntegral.Integrable.hasIntegral","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"ι : Type u\nE : Type v\nF : Type w\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Real F\nI : BoxIntegral.Box ι\ninst✝ : Fintype ι\nl : BoxIntegral.IntegrationParams\nf : (ι → Real) → E\nvol : BoxIntegral.BoxAdditiveMap ι (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nh : BoxIntegral.Integrable I l f vol\n⊢ BoxIntegral.HasIntegral I l f vol (BoxIntegral.integral I l f vol)","decl":"protected theorem Integrable.hasIntegral (h : Integrable I l f vol) :\n    HasIntegral I l f vol (integral I l f vol) := by\n  rw [integral, dif_pos h]\n  exact Classical.choose_spec h\n\n"}
{"name":"BoxIntegral.Integrable.mono","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"ι : Type u\nE : Type v\nF : Type w\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Real F\nI : BoxIntegral.Box ι\ninst✝ : Fintype ι\nl : BoxIntegral.IntegrationParams\nf : (ι → Real) → E\nvol : BoxIntegral.BoxAdditiveMap ι (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nl' : BoxIntegral.IntegrationParams\nh : BoxIntegral.Integrable I l f vol\nhle : LE.le l' l\n⊢ BoxIntegral.Integrable I l' f vol","decl":"theorem Integrable.mono {l'} (h : Integrable I l f vol) (hle : l' ≤ l) : Integrable I l' f vol :=\n  ⟨_, h.hasIntegral.mono hle⟩\n\n"}
{"name":"BoxIntegral.HasIntegral.unique","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"ι : Type u\nE : Type v\nF : Type w\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Real F\nI : BoxIntegral.Box ι\ninst✝ : Fintype ι\nl : BoxIntegral.IntegrationParams\nf : (ι → Real) → E\nvol : BoxIntegral.BoxAdditiveMap ι (ContinuousLinearMap (RingHom.id Real) E F) Top.top\ny y' : F\nh : BoxIntegral.HasIntegral I l f vol y\nh' : BoxIntegral.HasIntegral I l f vol y'\n⊢ Eq y y'","decl":"theorem HasIntegral.unique (h : HasIntegral I l f vol y) (h' : HasIntegral I l f vol y') : y = y' :=\n  tendsto_nhds_unique h h'\n\n"}
{"name":"BoxIntegral.HasIntegral.integrable","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"ι : Type u\nE : Type v\nF : Type w\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Real F\nI : BoxIntegral.Box ι\ninst✝ : Fintype ι\nl : BoxIntegral.IntegrationParams\nf : (ι → Real) → E\nvol : BoxIntegral.BoxAdditiveMap ι (ContinuousLinearMap (RingHom.id Real) E F) Top.top\ny : F\nh : BoxIntegral.HasIntegral I l f vol y\n⊢ BoxIntegral.Integrable I l f vol","decl":"theorem HasIntegral.integrable (h : HasIntegral I l f vol y) : Integrable I l f vol :=\n  ⟨_, h⟩\n\n"}
{"name":"BoxIntegral.HasIntegral.integral_eq","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"ι : Type u\nE : Type v\nF : Type w\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Real F\nI : BoxIntegral.Box ι\ninst✝ : Fintype ι\nl : BoxIntegral.IntegrationParams\nf : (ι → Real) → E\nvol : BoxIntegral.BoxAdditiveMap ι (ContinuousLinearMap (RingHom.id Real) E F) Top.top\ny : F\nh : BoxIntegral.HasIntegral I l f vol y\n⊢ Eq (BoxIntegral.integral I l f vol) y","decl":"theorem HasIntegral.integral_eq (h : HasIntegral I l f vol y) : integral I l f vol = y :=\n  h.integrable.hasIntegral.unique h\n\n"}
{"name":"BoxIntegral.HasIntegral.add","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"ι : Type u\nE : Type v\nF : Type w\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Real F\nI : BoxIntegral.Box ι\ninst✝ : Fintype ι\nl : BoxIntegral.IntegrationParams\nf g : (ι → Real) → E\nvol : BoxIntegral.BoxAdditiveMap ι (ContinuousLinearMap (RingHom.id Real) E F) Top.top\ny y' : F\nh : BoxIntegral.HasIntegral I l f vol y\nh' : BoxIntegral.HasIntegral I l g vol y'\n⊢ BoxIntegral.HasIntegral I l (HAdd.hAdd f g) vol (HAdd.hAdd y y')","decl":"nonrec theorem HasIntegral.add (h : HasIntegral I l f vol y) (h' : HasIntegral I l g vol y') :\n    HasIntegral I l (f + g) vol (y + y') := by\n  simpa only [HasIntegral, ← integralSum_add] using h.add h'\n\n"}
{"name":"BoxIntegral.Integrable.add","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"ι : Type u\nE : Type v\nF : Type w\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Real F\nI : BoxIntegral.Box ι\ninst✝ : Fintype ι\nl : BoxIntegral.IntegrationParams\nf g : (ι → Real) → E\nvol : BoxIntegral.BoxAdditiveMap ι (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nhf : BoxIntegral.Integrable I l f vol\nhg : BoxIntegral.Integrable I l g vol\n⊢ BoxIntegral.Integrable I l (HAdd.hAdd f g) vol","decl":"theorem Integrable.add (hf : Integrable I l f vol) (hg : Integrable I l g vol) :\n    Integrable I l (f + g) vol :=\n  (hf.hasIntegral.add hg.hasIntegral).integrable\n\n"}
{"name":"BoxIntegral.integral_add","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"ι : Type u\nE : Type v\nF : Type w\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Real F\nI : BoxIntegral.Box ι\ninst✝ : Fintype ι\nl : BoxIntegral.IntegrationParams\nf g : (ι → Real) → E\nvol : BoxIntegral.BoxAdditiveMap ι (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nhf : BoxIntegral.Integrable I l f vol\nhg : BoxIntegral.Integrable I l g vol\n⊢ Eq (BoxIntegral.integral I l (HAdd.hAdd f g) vol) (HAdd.hAdd (BoxIntegral.integral I l f vol) (BoxIntegral.integral I l g vol))","decl":"theorem integral_add (hf : Integrable I l f vol) (hg : Integrable I l g vol) :\n    integral I l (f + g) vol = integral I l f vol + integral I l g vol :=\n  (hf.hasIntegral.add hg.hasIntegral).integral_eq\n\n"}
{"name":"BoxIntegral.HasIntegral.neg","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"ι : Type u\nE : Type v\nF : Type w\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Real F\nI : BoxIntegral.Box ι\ninst✝ : Fintype ι\nl : BoxIntegral.IntegrationParams\nf : (ι → Real) → E\nvol : BoxIntegral.BoxAdditiveMap ι (ContinuousLinearMap (RingHom.id Real) E F) Top.top\ny : F\nhf : BoxIntegral.HasIntegral I l f vol y\n⊢ BoxIntegral.HasIntegral I l (Neg.neg f) vol (Neg.neg y)","decl":"nonrec theorem HasIntegral.neg (hf : HasIntegral I l f vol y) : HasIntegral I l (-f) vol (-y) := by\n  simpa only [HasIntegral, ← integralSum_neg] using hf.neg\n\n"}
{"name":"BoxIntegral.Integrable.neg","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"ι : Type u\nE : Type v\nF : Type w\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Real F\nI : BoxIntegral.Box ι\ninst✝ : Fintype ι\nl : BoxIntegral.IntegrationParams\nf : (ι → Real) → E\nvol : BoxIntegral.BoxAdditiveMap ι (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nhf : BoxIntegral.Integrable I l f vol\n⊢ BoxIntegral.Integrable I l (Neg.neg f) vol","decl":"theorem Integrable.neg (hf : Integrable I l f vol) : Integrable I l (-f) vol :=\n  hf.hasIntegral.neg.integrable\n\n"}
{"name":"BoxIntegral.Integrable.of_neg","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"ι : Type u\nE : Type v\nF : Type w\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Real F\nI : BoxIntegral.Box ι\ninst✝ : Fintype ι\nl : BoxIntegral.IntegrationParams\nf : (ι → Real) → E\nvol : BoxIntegral.BoxAdditiveMap ι (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nhf : BoxIntegral.Integrable I l (Neg.neg f) vol\n⊢ BoxIntegral.Integrable I l f vol","decl":"theorem Integrable.of_neg (hf : Integrable I l (-f) vol) : Integrable I l f vol :=\n  neg_neg f ▸ hf.neg\n\n"}
{"name":"BoxIntegral.integrable_neg","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"ι : Type u\nE : Type v\nF : Type w\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Real F\nI : BoxIntegral.Box ι\ninst✝ : Fintype ι\nl : BoxIntegral.IntegrationParams\nf : (ι → Real) → E\nvol : BoxIntegral.BoxAdditiveMap ι (ContinuousLinearMap (RingHom.id Real) E F) Top.top\n⊢ Iff (BoxIntegral.Integrable I l (Neg.neg f) vol) (BoxIntegral.Integrable I l f vol)","decl":"@[simp]\ntheorem integrable_neg : Integrable I l (-f) vol ↔ Integrable I l f vol :=\n  ⟨fun h => h.of_neg, fun h => h.neg⟩\n\n"}
{"name":"BoxIntegral.integral_neg","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"ι : Type u\nE : Type v\nF : Type w\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Real F\nI : BoxIntegral.Box ι\ninst✝ : Fintype ι\nl : BoxIntegral.IntegrationParams\nf : (ι → Real) → E\nvol : BoxIntegral.BoxAdditiveMap ι (ContinuousLinearMap (RingHom.id Real) E F) Top.top\n⊢ Eq (BoxIntegral.integral I l (Neg.neg f) vol) (Neg.neg (BoxIntegral.integral I l f vol))","decl":"@[simp]\ntheorem integral_neg : integral I l (-f) vol = -integral I l f vol := by\n  classical\n  exact if h : Integrable I l f vol then h.hasIntegral.neg.integral_eq\n  else by rw [integral, integral, dif_neg h, dif_neg (mt Integrable.of_neg h), neg_zero]\n\n"}
{"name":"BoxIntegral.HasIntegral.sub","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"ι : Type u\nE : Type v\nF : Type w\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Real F\nI : BoxIntegral.Box ι\ninst✝ : Fintype ι\nl : BoxIntegral.IntegrationParams\nf g : (ι → Real) → E\nvol : BoxIntegral.BoxAdditiveMap ι (ContinuousLinearMap (RingHom.id Real) E F) Top.top\ny y' : F\nh : BoxIntegral.HasIntegral I l f vol y\nh' : BoxIntegral.HasIntegral I l g vol y'\n⊢ BoxIntegral.HasIntegral I l (HSub.hSub f g) vol (HSub.hSub y y')","decl":"theorem HasIntegral.sub (h : HasIntegral I l f vol y) (h' : HasIntegral I l g vol y') :\n    HasIntegral I l (f - g) vol (y - y') := by simpa only [sub_eq_add_neg] using h.add h'.neg\n\n"}
{"name":"BoxIntegral.Integrable.sub","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"ι : Type u\nE : Type v\nF : Type w\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Real F\nI : BoxIntegral.Box ι\ninst✝ : Fintype ι\nl : BoxIntegral.IntegrationParams\nf g : (ι → Real) → E\nvol : BoxIntegral.BoxAdditiveMap ι (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nhf : BoxIntegral.Integrable I l f vol\nhg : BoxIntegral.Integrable I l g vol\n⊢ BoxIntegral.Integrable I l (HSub.hSub f g) vol","decl":"theorem Integrable.sub (hf : Integrable I l f vol) (hg : Integrable I l g vol) :\n    Integrable I l (f - g) vol :=\n  (hf.hasIntegral.sub hg.hasIntegral).integrable\n\n"}
{"name":"BoxIntegral.integral_sub","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"ι : Type u\nE : Type v\nF : Type w\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Real F\nI : BoxIntegral.Box ι\ninst✝ : Fintype ι\nl : BoxIntegral.IntegrationParams\nf g : (ι → Real) → E\nvol : BoxIntegral.BoxAdditiveMap ι (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nhf : BoxIntegral.Integrable I l f vol\nhg : BoxIntegral.Integrable I l g vol\n⊢ Eq (BoxIntegral.integral I l (HSub.hSub f g) vol) (HSub.hSub (BoxIntegral.integral I l f vol) (BoxIntegral.integral I l g vol))","decl":"theorem integral_sub (hf : Integrable I l f vol) (hg : Integrable I l g vol) :\n    integral I l (f - g) vol = integral I l f vol - integral I l g vol :=\n  (hf.hasIntegral.sub hg.hasIntegral).integral_eq\n\n"}
{"name":"BoxIntegral.hasIntegral_const","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"ι : Type u\nE : Type v\nF : Type w\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Real F\nI : BoxIntegral.Box ι\ninst✝ : Fintype ι\nl : BoxIntegral.IntegrationParams\nvol : BoxIntegral.BoxAdditiveMap ι (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nc : E\n⊢ BoxIntegral.HasIntegral I l (fun x => c) vol ((vol I) c)","decl":"theorem hasIntegral_const (c : E) : HasIntegral I l (fun _ => c) vol (vol I c) :=\n  tendsto_const_nhds.congr' <| (l.eventually_isPartition I).mono fun _π hπ => Eq.symm <|\n    (vol.map ⟨⟨fun g : E →L[ℝ] F ↦ g c, rfl⟩, fun _ _ ↦ rfl⟩).sum_partition_boxes le_top hπ\n\n"}
{"name":"BoxIntegral.integral_const","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"ι : Type u\nE : Type v\nF : Type w\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Real F\nI : BoxIntegral.Box ι\ninst✝ : Fintype ι\nl : BoxIntegral.IntegrationParams\nvol : BoxIntegral.BoxAdditiveMap ι (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nc : E\n⊢ Eq (BoxIntegral.integral I l (fun x => c) vol) ((vol I) c)","decl":"@[simp]\ntheorem integral_const (c : E) : integral I l (fun _ => c) vol = vol I c :=\n  (hasIntegral_const c).integral_eq\n\n"}
{"name":"BoxIntegral.integrable_const","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"ι : Type u\nE : Type v\nF : Type w\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Real F\nI : BoxIntegral.Box ι\ninst✝ : Fintype ι\nl : BoxIntegral.IntegrationParams\nvol : BoxIntegral.BoxAdditiveMap ι (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nc : E\n⊢ BoxIntegral.Integrable I l (fun x => c) vol","decl":"theorem integrable_const (c : E) : Integrable I l (fun _ => c) vol :=\n  ⟨_, hasIntegral_const c⟩\n\n"}
{"name":"BoxIntegral.hasIntegral_zero","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"ι : Type u\nE : Type v\nF : Type w\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Real F\nI : BoxIntegral.Box ι\ninst✝ : Fintype ι\nl : BoxIntegral.IntegrationParams\nvol : BoxIntegral.BoxAdditiveMap ι (ContinuousLinearMap (RingHom.id Real) E F) Top.top\n⊢ BoxIntegral.HasIntegral I l (fun x => 0) vol 0","decl":"theorem hasIntegral_zero : HasIntegral I l (fun _ => (0 : E)) vol 0 := by\n  simpa only [← (vol I).map_zero] using hasIntegral_const (0 : E)\n\n"}
{"name":"BoxIntegral.integrable_zero","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"ι : Type u\nE : Type v\nF : Type w\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Real F\nI : BoxIntegral.Box ι\ninst✝ : Fintype ι\nl : BoxIntegral.IntegrationParams\nvol : BoxIntegral.BoxAdditiveMap ι (ContinuousLinearMap (RingHom.id Real) E F) Top.top\n⊢ BoxIntegral.Integrable I l (fun x => 0) vol","decl":"theorem integrable_zero : Integrable I l (fun _ => (0 : E)) vol :=\n  ⟨0, hasIntegral_zero⟩\n\n"}
{"name":"BoxIntegral.integral_zero","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"ι : Type u\nE : Type v\nF : Type w\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Real F\nI : BoxIntegral.Box ι\ninst✝ : Fintype ι\nl : BoxIntegral.IntegrationParams\nvol : BoxIntegral.BoxAdditiveMap ι (ContinuousLinearMap (RingHom.id Real) E F) Top.top\n⊢ Eq (BoxIntegral.integral I l (fun x => 0) vol) 0","decl":"theorem integral_zero : integral I l (fun _ => (0 : E)) vol = 0 :=\n  hasIntegral_zero.integral_eq\n\n"}
{"name":"BoxIntegral.HasIntegral.sum","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"ι : Type u\nE : Type v\nF : Type w\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Real F\nI : BoxIntegral.Box ι\ninst✝ : Fintype ι\nl : BoxIntegral.IntegrationParams\nvol : BoxIntegral.BoxAdditiveMap ι (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nα : Type u_1\ns : Finset α\nf : α → (ι → Real) → E\ng : α → F\nh : ∀ (i : α), Membership.mem s i → BoxIntegral.HasIntegral I l (f i) vol (g i)\n⊢ BoxIntegral.HasIntegral I l (fun x => s.sum fun i => f i x) vol (s.sum fun i => g i)","decl":"theorem HasIntegral.sum {α : Type*} {s : Finset α} {f : α → ℝⁿ → E} {g : α → F}\n    (h : ∀ i ∈ s, HasIntegral I l (f i) vol (g i)) :\n    HasIntegral I l (fun x => ∑ i ∈ s, f i x) vol (∑ i ∈ s, g i) := by\n  classical\n  induction' s using Finset.induction_on with a s ha ihs; · simp [hasIntegral_zero]\n  simp only [Finset.sum_insert ha]; rw [Finset.forall_mem_insert] at h\n  exact h.1.add (ihs h.2)\n\n"}
{"name":"BoxIntegral.HasIntegral.smul","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"ι : Type u\nE : Type v\nF : Type w\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Real F\nI : BoxIntegral.Box ι\ninst✝ : Fintype ι\nl : BoxIntegral.IntegrationParams\nf : (ι → Real) → E\nvol : BoxIntegral.BoxAdditiveMap ι (ContinuousLinearMap (RingHom.id Real) E F) Top.top\ny : F\nhf : BoxIntegral.HasIntegral I l f vol y\nc : Real\n⊢ BoxIntegral.HasIntegral I l (HSMul.hSMul c f) vol (HSMul.hSMul c y)","decl":"theorem HasIntegral.smul (hf : HasIntegral I l f vol y) (c : ℝ) :\n    HasIntegral I l (c • f) vol (c • y) := by\n  simpa only [HasIntegral, ← integralSum_smul] using\n    (tendsto_const_nhds : Tendsto _ _ (𝓝 c)).smul hf\n\n"}
{"name":"BoxIntegral.Integrable.smul","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"ι : Type u\nE : Type v\nF : Type w\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Real F\nI : BoxIntegral.Box ι\ninst✝ : Fintype ι\nl : BoxIntegral.IntegrationParams\nf : (ι → Real) → E\nvol : BoxIntegral.BoxAdditiveMap ι (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nhf : BoxIntegral.Integrable I l f vol\nc : Real\n⊢ BoxIntegral.Integrable I l (HSMul.hSMul c f) vol","decl":"theorem Integrable.smul (hf : Integrable I l f vol) (c : ℝ) : Integrable I l (c • f) vol :=\n  (hf.hasIntegral.smul c).integrable\n\n"}
{"name":"BoxIntegral.Integrable.of_smul","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"ι : Type u\nE : Type v\nF : Type w\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Real F\nI : BoxIntegral.Box ι\ninst✝ : Fintype ι\nl : BoxIntegral.IntegrationParams\nf : (ι → Real) → E\nvol : BoxIntegral.BoxAdditiveMap ι (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nc : Real\nhf : BoxIntegral.Integrable I l (HSMul.hSMul c f) vol\nhc : Ne c 0\n⊢ BoxIntegral.Integrable I l f vol","decl":"theorem Integrable.of_smul {c : ℝ} (hf : Integrable I l (c • f) vol) (hc : c ≠ 0) :\n    Integrable I l f vol := by\n  simpa [inv_smul_smul₀ hc] using hf.smul c⁻¹\n\n"}
{"name":"BoxIntegral.integral_smul","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"ι : Type u\nE : Type v\nF : Type w\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Real F\nI : BoxIntegral.Box ι\ninst✝ : Fintype ι\nl : BoxIntegral.IntegrationParams\nf : (ι → Real) → E\nvol : BoxIntegral.BoxAdditiveMap ι (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nc : Real\n⊢ Eq (BoxIntegral.integral I l (fun x => HSMul.hSMul c (f x)) vol) (HSMul.hSMul c (BoxIntegral.integral I l f vol))","decl":"@[simp]\ntheorem integral_smul (c : ℝ) : integral I l (fun x => c • f x) vol = c • integral I l f vol := by\n  rcases eq_or_ne c 0 with (rfl | hc); · simp only [zero_smul, integral_zero]\n  by_cases hf : Integrable I l f vol\n  · exact (hf.hasIntegral.smul c).integral_eq\n  · have : ¬Integrable I l (fun x => c • f x) vol := mt (fun h => h.of_smul hc) hf\n    rw [integral, integral, dif_neg hf, dif_neg this, smul_zero]\n\n"}
{"name":"BoxIntegral.integral_nonneg","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"ι : Type u\nI : BoxIntegral.Box ι\ninst✝¹ : Fintype ι\nl : BoxIntegral.IntegrationParams\ng : (ι → Real) → Real\nhg : ∀ (x : ι → Real), Membership.mem (BoxIntegral.Box.Icc I) x → LE.le 0 (g x)\nμ : MeasureTheory.Measure (ι → Real)\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure μ\n⊢ LE.le 0 (BoxIntegral.integral I l g μ.toBoxAdditive.toSMul)","decl":"/-- The integral of a nonnegative function w.r.t. a volume generated by a locally-finite measure is\nnonnegative. -/\ntheorem integral_nonneg {g : ℝⁿ → ℝ} (hg : ∀ x ∈ Box.Icc I, 0 ≤ g x) (μ : Measure ℝⁿ)\n    [IsLocallyFiniteMeasure μ] : 0 ≤ integral I l g μ.toBoxAdditive.toSMul := by\n  by_cases hgi : Integrable I l g μ.toBoxAdditive.toSMul\n  · refine ge_of_tendsto' hgi.hasIntegral fun π => sum_nonneg fun J _ => ?_\n    exact mul_nonneg ENNReal.toReal_nonneg (hg _ <| π.tag_mem_Icc _)\n  · rw [integral, dif_neg hgi]\n\n"}
{"name":"BoxIntegral.norm_integral_le_of_norm_le","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"ι : Type u\nE : Type v\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\nI : BoxIntegral.Box ι\ninst✝¹ : Fintype ι\nl : BoxIntegral.IntegrationParams\nf : (ι → Real) → E\ng : (ι → Real) → Real\nhle : ∀ (x : ι → Real), Membership.mem (BoxIntegral.Box.Icc I) x → LE.le (Norm.norm (f x)) (g x)\nμ : MeasureTheory.Measure (ι → Real)\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure μ\nhg : BoxIntegral.Integrable I l g μ.toBoxAdditive.toSMul\n⊢ LE.le (Norm.norm (BoxIntegral.integral I l f μ.toBoxAdditive.toSMul)) (BoxIntegral.integral I l g μ.toBoxAdditive.toSMul)","decl":"/-- If `‖f x‖ ≤ g x` on `[l, u]` and `g` is integrable, then the norm of the integral of `f` is less\nthan or equal to the integral of `g`. -/\ntheorem norm_integral_le_of_norm_le {g : ℝⁿ → ℝ} (hle : ∀ x ∈ Box.Icc I, ‖f x‖ ≤ g x)\n    (μ : Measure ℝⁿ) [IsLocallyFiniteMeasure μ] (hg : Integrable I l g μ.toBoxAdditive.toSMul) :\n    ‖(integral I l f μ.toBoxAdditive.toSMul : E)‖ ≤ integral I l g μ.toBoxAdditive.toSMul := by\n  by_cases hfi : Integrable.{u, v, v} I l f μ.toBoxAdditive.toSMul\n  · refine le_of_tendsto_of_tendsto' hfi.hasIntegral.norm hg.hasIntegral fun π => ?_\n    refine norm_sum_le_of_le _ fun J _ => ?_\n    simp only [BoxAdditiveMap.toSMul_apply, norm_smul, smul_eq_mul, Real.norm_eq_abs,\n      μ.toBoxAdditive_apply, abs_of_nonneg ENNReal.toReal_nonneg]\n    exact mul_le_mul_of_nonneg_left (hle _ <| π.tag_mem_Icc _) ENNReal.toReal_nonneg\n  · rw [integral, dif_neg hfi, norm_zero]\n    exact integral_nonneg (fun x hx => (norm_nonneg _).trans (hle x hx)) μ\n\n"}
{"name":"BoxIntegral.norm_integral_le_of_le_const","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"ι : Type u\nE : Type v\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\nI : BoxIntegral.Box ι\ninst✝¹ : Fintype ι\nl : BoxIntegral.IntegrationParams\nf : (ι → Real) → E\nc : Real\nhc : ∀ (x : ι → Real), Membership.mem (BoxIntegral.Box.Icc I) x → LE.le (Norm.norm (f x)) c\nμ : MeasureTheory.Measure (ι → Real)\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure μ\n⊢ LE.le (Norm.norm (BoxIntegral.integral I l f μ.toBoxAdditive.toSMul)) (HMul.hMul (μ ↑I).toReal c)","decl":"theorem norm_integral_le_of_le_const {c : ℝ}\n    (hc : ∀ x ∈ Box.Icc I, ‖f x‖ ≤ c) (μ : Measure ℝⁿ) [IsLocallyFiniteMeasure μ] :\n    ‖(integral I l f μ.toBoxAdditive.toSMul : E)‖ ≤ (μ I).toReal * c := by\n  simpa only [integral_const] using norm_integral_le_of_norm_le hc μ (integrable_const c)\n\n"}
{"name":"BoxIntegral.Integrable.convergenceR_cond","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"ι : Type u\nE : Type v\nF : Type w\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Real F\nI : BoxIntegral.Box ι\ninst✝ : Fintype ι\nl : BoxIntegral.IntegrationParams\nf : (ι → Real) → E\nvol : BoxIntegral.BoxAdditiveMap ι (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nh : BoxIntegral.Integrable I l f vol\nε : Real\nc : NNReal\n⊢ l.RCond (h.convergenceR ε c)","decl":"theorem convergenceR_cond (h : Integrable I l f vol) (ε : ℝ) (c : ℝ≥0) :\n    l.RCond (h.convergenceR ε c) := by\n  rw [convergenceR]; split_ifs with h₀\n  exacts [(hasIntegral_iff.1 h.hasIntegral ε h₀).choose_spec.1 _, fun _ x => rfl]\n\n"}
{"name":"BoxIntegral.Integrable.dist_integralSum_integral_le_of_memBaseSet","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"ι : Type u\nE : Type v\nF : Type w\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Real F\nI : BoxIntegral.Box ι\nπ : BoxIntegral.TaggedPrepartition I\ninst✝ : Fintype ι\nl : BoxIntegral.IntegrationParams\nf : (ι → Real) → E\nvol : BoxIntegral.BoxAdditiveMap ι (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nc : NNReal\nε : Real\nh : BoxIntegral.Integrable I l f vol\nh₀ : LT.lt 0 ε\nhπ : l.MemBaseSet I c (h.convergenceR ε c) π\nhπp : π.IsPartition\n⊢ LE.le (Dist.dist (BoxIntegral.integralSum f vol π) (BoxIntegral.integral I l f vol)) ε","decl":"theorem dist_integralSum_integral_le_of_memBaseSet (h : Integrable I l f vol) (h₀ : 0 < ε)\n    (hπ : l.MemBaseSet I c (h.convergenceR ε c) π) (hπp : π.IsPartition) :\n    dist (integralSum f vol π) (integral I l f vol) ≤ ε := by\n  rw [convergenceR, dif_pos h₀] at hπ\n  exact (hasIntegral_iff.1 h.hasIntegral ε h₀).choose_spec.2 c _ hπ hπp\n\n"}
{"name":"BoxIntegral.Integrable.dist_integralSum_le_of_memBaseSet","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"ι : Type u\nE : Type v\nF : Type w\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Real F\nI : BoxIntegral.Box ι\ninst✝ : Fintype ι\nl : BoxIntegral.IntegrationParams\nf : (ι → Real) → E\nvol : BoxIntegral.BoxAdditiveMap ι (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nc₁ c₂ : NNReal\nε₁ ε₂ : Real\nπ₁ π₂ : BoxIntegral.TaggedPrepartition I\nh : BoxIntegral.Integrable I l f vol\nhpos₁ : LT.lt 0 ε₁\nhpos₂ : LT.lt 0 ε₂\nh₁ : l.MemBaseSet I c₁ (h.convergenceR ε₁ c₁) π₁\nh₂ : l.MemBaseSet I c₂ (h.convergenceR ε₂ c₂) π₂\nHU : Eq π₁.iUnion π₂.iUnion\n⊢ LE.le (Dist.dist (BoxIntegral.integralSum f vol π₁) (BoxIntegral.integralSum f vol π₂)) (HAdd.hAdd ε₁ ε₂)","decl":"/-- **Henstock-Sacks inequality**. Let `r₁ r₂ : ℝⁿ → (0, ∞)` be a function such that for any tagged\n*partition* of `I` subordinate to `rₖ`, `k=1,2`, the integral sum of `f` over this partition differs\nfrom the integral of `f` by at most `εₖ`. Then for any two tagged *prepartition* `π₁ π₂` subordinate\nto `r₁` and `r₂` respectively and covering the same part of `I`, the integral sums of `f` over these\nprepartitions differ from each other by at most `ε₁ + ε₂`.\n\nThe actual statement\n\n- uses `BoxIntegral.Integrable.convergenceR` instead of a predicate assumption on `r`;\n- uses `BoxIntegral.IntegrationParams.MemBaseSet` instead of “subordinate to `r`” to\n  account for additional requirements like being a Henstock partition or having a bounded\n  distortion.\n\nSee also `BoxIntegral.Integrable.dist_integralSum_sum_integral_le_of_memBaseSet_of_iUnion_eq` and\n`BoxIntegral.Integrable.dist_integralSum_sum_integral_le_of_memBaseSet`.\n-/\ntheorem dist_integralSum_le_of_memBaseSet (h : Integrable I l f vol) (hpos₁ : 0 < ε₁)\n    (hpos₂ : 0 < ε₂) (h₁ : l.MemBaseSet I c₁ (h.convergenceR ε₁ c₁) π₁)\n    (h₂ : l.MemBaseSet I c₂ (h.convergenceR ε₂ c₂) π₂) (HU : π₁.iUnion = π₂.iUnion) :\n    dist (integralSum f vol π₁) (integralSum f vol π₂) ≤ ε₁ + ε₂ := by\n  rcases h₁.exists_common_compl h₂ HU with ⟨π, hπU, hπc₁, hπc₂⟩\n  set r : ℝⁿ → Ioi (0 : ℝ) := fun x => min (h.convergenceR ε₁ c₁ x) (h.convergenceR ε₂ c₂ x)\n  set πr := π.toSubordinate r\n  have H₁ :\n    dist (integralSum f vol (π₁.unionComplToSubordinate π hπU r)) (integral I l f vol) ≤ ε₁ :=\n    h.dist_integralSum_integral_le_of_memBaseSet hpos₁\n      (h₁.unionComplToSubordinate (fun _ _ => min_le_left _ _) hπU hπc₁)\n      (isPartition_unionComplToSubordinate _ _ _ _)\n  rw [HU] at hπU\n  have H₂ :\n    dist (integralSum f vol (π₂.unionComplToSubordinate π hπU r)) (integral I l f vol) ≤ ε₂ :=\n    h.dist_integralSum_integral_le_of_memBaseSet hpos₂\n      (h₂.unionComplToSubordinate (fun _ _ => min_le_right _ _) hπU hπc₂)\n      (isPartition_unionComplToSubordinate _ _ _ _)\n  simpa [unionComplToSubordinate] using (dist_triangle_right _ _ _).trans (add_le_add H₁ H₂)\n\n"}
{"name":"BoxIntegral.Integrable.tendsto_integralSum_toFilter_prod_self_inf_iUnion_eq_uniformity","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"ι : Type u\nE : Type v\nF : Type w\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Real F\nI : BoxIntegral.Box ι\ninst✝ : Fintype ι\nl : BoxIntegral.IntegrationParams\nf : (ι → Real) → E\nvol : BoxIntegral.BoxAdditiveMap ι (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nh : BoxIntegral.Integrable I l f vol\n⊢ Filter.Tendsto (fun π => { fst := BoxIntegral.integralSum f vol π.1, snd := BoxIntegral.integralSum f vol π.2 }) (Min.min (SProd.sprod (l.toFilter I) (l.toFilter I)) (Filter.principal (setOf fun π => Eq π.1.iUnion π.2.iUnion))) (uniformity F)","decl":"/-- If `f` is integrable on `I` along `l`, then for two sufficiently fine tagged prepartitions\n(in the sense of the filter `BoxIntegral.IntegrationParams.toFilter l I`) such that they cover\nthe same part of `I`, the integral sums of `f` over `π₁` and `π₂` are very close to each other. -/\ntheorem tendsto_integralSum_toFilter_prod_self_inf_iUnion_eq_uniformity (h : Integrable I l f vol) :\n    Tendsto (fun π : TaggedPrepartition I × TaggedPrepartition I =>\n      (integralSum f vol π.1, integralSum f vol π.2))\n        ((l.toFilter I ×ˢ l.toFilter I) ⊓ 𝓟 {π | π.1.iUnion = π.2.iUnion}) (𝓤 F) := by\n  refine (((l.hasBasis_toFilter I).prod_self.inf_principal _).tendsto_iff\n    uniformity_basis_dist_le).2 fun ε ε0 => ?_\n  replace ε0 := half_pos ε0\n  use h.convergenceR (ε / 2), h.convergenceR_cond (ε / 2); rintro ⟨π₁, π₂⟩ ⟨⟨h₁, h₂⟩, hU⟩\n  rw [← add_halves ε]\n  exact h.dist_integralSum_le_of_memBaseSet ε0 ε0 h₁.choose_spec h₂.choose_spec hU\n\n"}
{"name":"BoxIntegral.Integrable.cauchy_map_integralSum_toFilteriUnion","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"ι : Type u\nE : Type v\nF : Type w\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Real F\nI : BoxIntegral.Box ι\ninst✝ : Fintype ι\nl : BoxIntegral.IntegrationParams\nf : (ι → Real) → E\nvol : BoxIntegral.BoxAdditiveMap ι (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nh : BoxIntegral.Integrable I l f vol\nπ₀ : BoxIntegral.Prepartition I\n⊢ Cauchy (Filter.map (BoxIntegral.integralSum f vol) (BoxIntegral.IntegrationParams.toFilteriUnion I π₀))","decl":"/-- If `f` is integrable on a box `I` along `l`, then for any fixed subset `s` of `I` that can be\nrepresented as a finite union of boxes, the integral sums of `f` over tagged prepartitions that\ncover exactly `s` form a Cauchy “sequence” along `l`. -/\ntheorem cauchy_map_integralSum_toFilteriUnion (h : Integrable I l f vol) (π₀ : Prepartition I) :\n    Cauchy ((l.toFilteriUnion I π₀).map (integralSum f vol)) := by\n  refine ⟨inferInstance, ?_⟩\n  rw [prod_map_map_eq, ← toFilter_inf_iUnion_eq, ← prod_inf_prod, prod_principal_principal]\n  exact h.tendsto_integralSum_toFilter_prod_self_inf_iUnion_eq_uniformity.mono_left\n    (inf_le_inf_left _ <| principal_mono.2 fun π h => h.1.trans h.2.symm)\n\n"}
{"name":"BoxIntegral.Integrable.to_subbox_aux","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"ι : Type u\nE : Type v\nF : Type w\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace Real E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace Real F\nI J : BoxIntegral.Box ι\ninst✝¹ : Fintype ι\nl : BoxIntegral.IntegrationParams\nf : (ι → Real) → E\nvol : BoxIntegral.BoxAdditiveMap ι (ContinuousLinearMap (RingHom.id Real) E F) Top.top\ninst✝ : CompleteSpace F\nh : BoxIntegral.Integrable I l f vol\nhJ : LE.le J I\n⊢ Exists fun y => And (BoxIntegral.HasIntegral J l f vol y) (Filter.Tendsto (BoxIntegral.integralSum f vol) (BoxIntegral.IntegrationParams.toFilteriUnion I (BoxIntegral.Prepartition.single I J hJ)) (nhds y))","decl":"theorem to_subbox_aux (h : Integrable I l f vol) (hJ : J ≤ I) :\n    ∃ y : F, HasIntegral J l f vol y ∧\n      Tendsto (integralSum f vol) (l.toFilteriUnion I (Prepartition.single I J hJ)) (𝓝 y) := by\n  refine (cauchy_map_iff_exists_tendsto.1\n    (h.cauchy_map_integralSum_toFilteriUnion (.single I J hJ))).imp fun y hy ↦ ⟨?_, hy⟩\n  convert hy.comp (l.tendsto_embedBox_toFilteriUnion_top hJ) -- faster than `exact` here\n\n"}
{"name":"BoxIntegral.Integrable.to_subbox","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"ι : Type u\nE : Type v\nF : Type w\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace Real E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace Real F\nI J : BoxIntegral.Box ι\ninst✝¹ : Fintype ι\nl : BoxIntegral.IntegrationParams\nf : (ι → Real) → E\nvol : BoxIntegral.BoxAdditiveMap ι (ContinuousLinearMap (RingHom.id Real) E F) Top.top\ninst✝ : CompleteSpace F\nh : BoxIntegral.Integrable I l f vol\nhJ : LE.le J I\n⊢ BoxIntegral.Integrable J l f vol","decl":"/-- If `f` is integrable on a box `I`, then it is integrable on any subbox of `I`. -/\ntheorem to_subbox (h : Integrable I l f vol) (hJ : J ≤ I) : Integrable J l f vol :=\n  (h.to_subbox_aux hJ).imp fun _ => And.left\n\n"}
{"name":"BoxIntegral.Integrable.tendsto_integralSum_toFilteriUnion_single","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"ι : Type u\nE : Type v\nF : Type w\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace Real E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace Real F\nI J : BoxIntegral.Box ι\ninst✝¹ : Fintype ι\nl : BoxIntegral.IntegrationParams\nf : (ι → Real) → E\nvol : BoxIntegral.BoxAdditiveMap ι (ContinuousLinearMap (RingHom.id Real) E F) Top.top\ninst✝ : CompleteSpace F\nh : BoxIntegral.Integrable I l f vol\nhJ : LE.le J I\n⊢ Filter.Tendsto (BoxIntegral.integralSum f vol) (BoxIntegral.IntegrationParams.toFilteriUnion I (BoxIntegral.Prepartition.single I J hJ)) (nhds (BoxIntegral.integral J l f vol))","decl":"/-- If `f` is integrable on a box `I`, then integral sums of `f` over tagged prepartitions\nthat cover exactly a subbox `J ≤ I` tend to the integral of `f` over `J` along `l`. -/\ntheorem tendsto_integralSum_toFilteriUnion_single (h : Integrable I l f vol) (hJ : J ≤ I) :\n    Tendsto (integralSum f vol) (l.toFilteriUnion I (Prepartition.single I J hJ))\n      (𝓝 <| integral J l f vol) :=\n  let ⟨_y, h₁, h₂⟩ := h.to_subbox_aux hJ\n  h₁.integral_eq.symm ▸ h₂\n\n"}
{"name":"BoxIntegral.Integrable.dist_integralSum_sum_integral_le_of_memBaseSet_of_iUnion_eq","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"ι : Type u\nE : Type v\nF : Type w\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace Real E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace Real F\nI : BoxIntegral.Box ι\nπ : BoxIntegral.TaggedPrepartition I\ninst✝¹ : Fintype ι\nl : BoxIntegral.IntegrationParams\nf : (ι → Real) → E\nvol : BoxIntegral.BoxAdditiveMap ι (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nc : NNReal\nε : Real\ninst✝ : CompleteSpace F\nh : BoxIntegral.Integrable I l f vol\nh0 : LT.lt 0 ε\nhπ : l.MemBaseSet I c (h.convergenceR ε c) π\nπ₀ : BoxIntegral.Prepartition I\nhU : Eq π.iUnion π₀.iUnion\n⊢ LE.le (Dist.dist (BoxIntegral.integralSum f vol π) (π₀.boxes.sum fun J => BoxIntegral.integral J l f vol)) ε","decl":"/-- **Henstock-Sacks inequality**. Let `r : ℝⁿ → (0, ∞)` be a function such that for any tagged\n*partition* of `I` subordinate to `r`, the integral sum of `f` over this partition differs from the\nintegral of `f` by at most `ε`. Then for any tagged *prepartition* `π` subordinate to `r`, the\nintegral sum of `f` over this prepartition differs from the integral of `f` over the part of `I`\ncovered by `π` by at most `ε`.\n\nThe actual statement\n\n- uses `BoxIntegral.Integrable.convergenceR` instead of a predicate assumption on `r`;\n- uses `BoxIntegral.IntegrationParams.MemBaseSet` instead of “subordinate to `r`” to\n  account for additional requirements like being a Henstock partition or having a bounded\n  distortion;\n- takes an extra argument `π₀ : prepartition I` and an assumption `π.Union = π₀.Union` instead of\n  using `π.to_prepartition`.\n-/\ntheorem dist_integralSum_sum_integral_le_of_memBaseSet_of_iUnion_eq (h : Integrable I l f vol)\n    (h0 : 0 < ε) (hπ : l.MemBaseSet I c (h.convergenceR ε c) π) {π₀ : Prepartition I}\n    (hU : π.iUnion = π₀.iUnion) :\n    dist (integralSum f vol π) (∑ J ∈ π₀.boxes, integral J l f vol) ≤ ε := by\n  -- Let us prove that the distance is less than or equal to `ε + δ` for all positive `δ`.\n  refine le_of_forall_pos_le_add fun δ δ0 => ?_\n  -- First we choose some constants.\n  set δ' : ℝ := δ / (#π₀.boxes + 1)\n  have H0 : 0 < (#π₀.boxes + 1 : ℝ) := Nat.cast_add_one_pos _\n  have δ'0 : 0 < δ' := div_pos δ0 H0\n  set C := max π₀.distortion π₀.compl.distortion\n  /- Next we choose a tagged partition of each `J ∈ π₀` such that the integral sum of `f` over this\n    partition is `δ'`-close to the integral of `f` over `J`. -/\n  have : ∀ J ∈ π₀, ∃ πi : TaggedPrepartition J,\n      πi.IsPartition ∧ dist (integralSum f vol πi) (integral J l f vol) ≤ δ' ∧\n        l.MemBaseSet J C (h.convergenceR δ' C) πi := by\n    intro J hJ\n    have Hle : J ≤ I := π₀.le_of_mem hJ\n    have HJi : Integrable J l f vol := h.to_subbox Hle\n    set r := fun x => min (h.convergenceR δ' C x) (HJi.convergenceR δ' C x)\n    have hJd : J.distortion ≤ C := le_trans (Finset.le_sup hJ) (le_max_left _ _)\n    rcases l.exists_memBaseSet_isPartition J hJd r with ⟨πJ, hC, hp⟩\n    have hC₁ : l.MemBaseSet J C (HJi.convergenceR δ' C) πJ := by\n      refine hC.mono J le_rfl le_rfl fun x _ => ?_; exact min_le_right _ _\n    have hC₂ : l.MemBaseSet J C (h.convergenceR δ' C) πJ := by\n      refine hC.mono J le_rfl le_rfl fun x _ => ?_; exact min_le_left _ _\n    exact ⟨πJ, hp, HJi.dist_integralSum_integral_le_of_memBaseSet δ'0 hC₁ hp, hC₂⟩\n  /- Now we combine these tagged partitions into a tagged prepartition of `I` that covers the\n    same part of `I` as `π₀` and apply `BoxIntegral.dist_integralSum_le_of_memBaseSet` to\n    `π` and this prepartition. -/\n  choose! πi hπip hπiδ' hπiC using this\n  have : l.MemBaseSet I C (h.convergenceR δ' C) (π₀.biUnionTagged πi) :=\n    biUnionTagged_memBaseSet hπiC hπip fun _ => le_max_right _ _\n  have hU' : π.iUnion = (π₀.biUnionTagged πi).iUnion :=\n    hU.trans (Prepartition.iUnion_biUnion_partition _ hπip).symm\n  have := h.dist_integralSum_le_of_memBaseSet h0 δ'0 hπ this hU'\n  rw [integralSum_biUnionTagged] at this\n  calc\n    dist (integralSum f vol π) (∑ J ∈ π₀.boxes, integral J l f vol) ≤\n        dist (integralSum f vol π) (∑ J ∈ π₀.boxes, integralSum f vol (πi J)) +\n          dist (∑ J ∈ π₀.boxes, integralSum f vol (πi J)) (∑ J ∈ π₀.boxes, integral J l f vol) :=\n      dist_triangle _ _ _\n    _ ≤ ε + δ' + ∑ _J ∈ π₀.boxes, δ' := add_le_add this (dist_sum_sum_le_of_le _ hπiδ')\n    _ = ε + δ := by field_simp [δ']; ring\n\n"}
{"name":"BoxIntegral.Integrable.dist_integralSum_sum_integral_le_of_memBaseSet","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"ι : Type u\nE : Type v\nF : Type w\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace Real E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace Real F\nI : BoxIntegral.Box ι\nπ : BoxIntegral.TaggedPrepartition I\ninst✝¹ : Fintype ι\nl : BoxIntegral.IntegrationParams\nf : (ι → Real) → E\nvol : BoxIntegral.BoxAdditiveMap ι (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nc : NNReal\nε : Real\ninst✝ : CompleteSpace F\nh : BoxIntegral.Integrable I l f vol\nh0 : LT.lt 0 ε\nhπ : l.MemBaseSet I c (h.convergenceR ε c) π\n⊢ LE.le (Dist.dist (BoxIntegral.integralSum f vol π) (π.boxes.sum fun J => BoxIntegral.integral J l f vol)) ε","decl":"/-- **Henstock-Sacks inequality**. Let `r : ℝⁿ → (0, ∞)` be a function such that for any tagged\n*partition* of `I` subordinate to `r`, the integral sum of `f` over this partition differs from the\nintegral of `f` by at most `ε`. Then for any tagged *prepartition* `π` subordinate to `r`, the\nintegral sum of `f` over this prepartition differs from the integral of `f` over the part of `I`\ncovered by `π` by at most `ε`.\n\nThe actual statement\n\n- uses `BoxIntegral.Integrable.convergenceR` instead of a predicate assumption on `r`;\n- uses `BoxIntegral.IntegrationParams.MemBaseSet` instead of “subordinate to `r`” to\n  account for additional requirements like being a Henstock partition or having a bounded\n  distortion;\n-/\ntheorem dist_integralSum_sum_integral_le_of_memBaseSet (h : Integrable I l f vol) (h0 : 0 < ε)\n    (hπ : l.MemBaseSet I c (h.convergenceR ε c) π) :\n    dist (integralSum f vol π) (∑ J ∈ π.boxes, integral J l f vol) ≤ ε :=\n  h.dist_integralSum_sum_integral_le_of_memBaseSet_of_iUnion_eq h0 hπ rfl\n\n"}
{"name":"BoxIntegral.Integrable.tendsto_integralSum_sum_integral","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"ι : Type u\nE : Type v\nF : Type w\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace Real E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace Real F\nI : BoxIntegral.Box ι\ninst✝¹ : Fintype ι\nl : BoxIntegral.IntegrationParams\nf : (ι → Real) → E\nvol : BoxIntegral.BoxAdditiveMap ι (ContinuousLinearMap (RingHom.id Real) E F) Top.top\ninst✝ : CompleteSpace F\nh : BoxIntegral.Integrable I l f vol\nπ₀ : BoxIntegral.Prepartition I\n⊢ Filter.Tendsto (BoxIntegral.integralSum f vol) (BoxIntegral.IntegrationParams.toFilteriUnion I π₀) (nhds (π₀.boxes.sum fun J => BoxIntegral.integral J l f vol))","decl":"/-- Integral sum of `f` over a tagged prepartition `π` such that `π.Union = π₀.Union` tends to the\nsum of integrals of `f` over the boxes of `π₀`. -/\ntheorem tendsto_integralSum_sum_integral (h : Integrable I l f vol) (π₀ : Prepartition I) :\n    Tendsto (integralSum f vol) (l.toFilteriUnion I π₀)\n      (𝓝 <| ∑ J ∈ π₀.boxes, integral J l f vol) := by\n  refine ((l.hasBasis_toFilteriUnion I π₀).tendsto_iff nhds_basis_closedBall).2 fun ε ε0 => ?_\n  refine ⟨h.convergenceR ε, h.convergenceR_cond ε, ?_⟩\n  simp only [mem_inter_iff, Set.mem_iUnion, mem_setOf_eq]\n  rintro π ⟨c, hc, hU⟩\n  exact h.dist_integralSum_sum_integral_le_of_memBaseSet_of_iUnion_eq ε0 hc hU\n\n"}
{"name":"BoxIntegral.Integrable.sum_integral_congr","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"ι : Type u\nE : Type v\nF : Type w\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace Real E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace Real F\nI : BoxIntegral.Box ι\ninst✝¹ : Fintype ι\nl : BoxIntegral.IntegrationParams\nf : (ι → Real) → E\nvol : BoxIntegral.BoxAdditiveMap ι (ContinuousLinearMap (RingHom.id Real) E F) Top.top\ninst✝ : CompleteSpace F\nh : BoxIntegral.Integrable I l f vol\nπ₁ π₂ : BoxIntegral.Prepartition I\nhU : Eq π₁.iUnion π₂.iUnion\n⊢ Eq (π₁.boxes.sum fun J => BoxIntegral.integral J l f vol) (π₂.boxes.sum fun J => BoxIntegral.integral J l f vol)","decl":"/-- If `f` is integrable on `I`, then `fun J ↦ integral J l f vol` is box-additive on subboxes of\n`I`: if `π₁`, `π₂` are two prepartitions of `I` covering the same part of `I`, the sum of integrals\nof `f` over the boxes of `π₁` is equal to the sum of integrals of `f` over the boxes of `π₂`.\n\nSee also `BoxIntegral.Integrable.toBoxAdditive` for a bundled version. -/\ntheorem sum_integral_congr (h : Integrable I l f vol) {π₁ π₂ : Prepartition I}\n    (hU : π₁.iUnion = π₂.iUnion) :\n    ∑ J ∈ π₁.boxes, integral J l f vol = ∑ J ∈ π₂.boxes, integral J l f vol := by\n  refine tendsto_nhds_unique (h.tendsto_integralSum_sum_integral π₁) ?_\n  rw [l.toFilteriUnion_congr _ hU]\n  exact h.tendsto_integralSum_sum_integral π₂\n\n"}
{"name":"BoxIntegral.Integrable.toBoxAdditive_apply","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"ι : Type u\nE : Type v\nF : Type w\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Real F\nI : BoxIntegral.Box ι\ninst✝ : Fintype ι\nl : BoxIntegral.IntegrationParams\nf : (ι → Real) → E\nvol : BoxIntegral.BoxAdditiveMap ι (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nh : BoxIntegral.Integrable I l f vol\nJ : BoxIntegral.Box ι\n⊢ Eq (h.toBoxAdditive J) (BoxIntegral.integral J l f vol)","decl":"/-- If `f` is integrable on `I`, then `fun J ↦ integral J l f vol` is box-additive on subboxes of\n`I`: if `π₁`, `π₂` are two prepartitions of `I` covering the same part of `I`, the sum of integrals\nof `f` over the boxes of `π₁` is equal to the sum of integrals of `f` over the boxes of `π₂`.\n\nSee also `BoxIntegral.Integrable.sum_integral_congr` for an unbundled version. -/\n@[simps]\ndef toBoxAdditive (h : Integrable I l f vol) : ι →ᵇᵃ[I] F where\n  toFun J := integral J l f vol\n  sum_partition_boxes' J hJ π hπ := by\n    replace hπ := hπ.iUnion_eq; rw [← Prepartition.iUnion_top] at hπ\n    rw [(h.to_subbox (WithTop.coe_le_coe.1 hJ)).sum_integral_congr hπ, Prepartition.top_boxes,\n      sum_singleton]\n\n"}
{"name":"BoxIntegral.integrable_of_bounded_and_ae_continuousWithinAt","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"ι : Type u\nE : Type v\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : Fintype ι\nl : BoxIntegral.IntegrationParams\ninst✝¹ : CompleteSpace E\nI : BoxIntegral.Box ι\nf : (ι → Real) → E\nhb : Exists fun C => ∀ (x : ι → Real), Membership.mem (BoxIntegral.Box.Icc I) x → LE.le (Norm.norm (f x)) C\nμ : MeasureTheory.Measure (ι → Real)\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure μ\nhc : Filter.Eventually (fun x => ContinuousWithinAt f (BoxIntegral.Box.Icc I) x) (MeasureTheory.ae (μ.restrict (BoxIntegral.Box.Icc I)))\n⊢ BoxIntegral.Integrable I l f μ.toBoxAdditive.toSMul","decl":"/-- A function that is bounded and a.e. continuous on a box `I` is integrable on `I`. -/\ntheorem integrable_of_bounded_and_ae_continuousWithinAt [CompleteSpace E] {I : Box ι} {f : ℝⁿ → E}\n    (hb : ∃ C : ℝ, ∀ x ∈ Box.Icc I, ‖f x‖ ≤ C) (μ : Measure ℝⁿ) [IsLocallyFiniteMeasure μ]\n    (hc : ∀ᵐ x ∂(μ.restrict (Box.Icc I)), ContinuousWithinAt f (Box.Icc I) x) :\n    Integrable I l f μ.toBoxAdditive.toSMul := by\n  /- We prove that f is integrable by proving that we can ensure that the integralSums over any\n     two tagged prepartitions π₁ and π₂ can be made ε-close by making the partitions\n     sufficiently fine.\n\n     Start by defining some constants C, ε₁, ε₂ that will be useful later. -/\n  refine integrable_iff_cauchy_basis.2 fun ε ε0 ↦ ?_\n  rcases exists_pos_mul_lt ε0 (2 * μ.toBoxAdditive I) with ⟨ε₁, ε₁0, hε₁⟩\n  rcases hb with ⟨C, hC⟩\n  have C0 : 0 ≤ C := by\n    obtain ⟨x, hx⟩ := BoxIntegral.Box.nonempty_coe I\n    exact le_trans (norm_nonneg (f x)) <| hC x (I.coe_subset_Icc hx)\n  rcases exists_pos_mul_lt ε0 (4 * C) with ⟨ε₂, ε₂0, hε₂⟩\n  have ε₂0' : ENNReal.ofReal ε₂ ≠ 0 := ne_of_gt <| ofReal_pos.2 ε₂0\n\n  -- The set of discontinuities of f is contained in an open set U with μ U < ε₂.\n  let D := { x ∈ Box.Icc I | ¬ ContinuousWithinAt f (Box.Icc I) x }\n  let μ' := μ.restrict (Box.Icc I)\n  have μ'D : μ' D = 0 := by\n    rcases eventually_iff_exists_mem.1 hc with ⟨V, ae, hV⟩\n    exact eq_of_le_of_not_lt (mem_ae_iff.1 ae ▸ (μ'.mono <| fun x h xV ↦ h.2 (hV x xV))) not_lt_zero\n  obtain ⟨U, UD, Uopen, hU⟩ := Set.exists_isOpen_lt_add D (show μ' D ≠ ⊤ by simp [μ'D]) ε₂0'\n  rw [μ'D, zero_add] at hU\n\n  /- Box.Icc I \\ U is compact and avoids discontinuities of f, so there exists r > 0 such that for\n     every x ∈ Box.Icc I \\ U, the oscillation (within Box.Icc I) of f on the ball of radius r\n     centered at x is ≤ ε₁ -/\n  have comp : IsCompact (Box.Icc I \\ U) :=\n    I.isCompact_Icc.of_isClosed_subset (I.isCompact_Icc.isClosed.sdiff Uopen) Set.diff_subset\n  have : ∀ x ∈ (Box.Icc I \\ U), oscillationWithin f (Box.Icc I) x < (ENNReal.ofReal ε₁) := by\n    intro x hx\n    suffices oscillationWithin f (Box.Icc I) x = 0 by rw [this]; exact ofReal_pos.2 ε₁0\n    simpa [OscillationWithin.eq_zero_iff_continuousWithinAt, D, hx.1] using hx.2 ∘ (fun a ↦ UD a)\n  rcases comp.uniform_oscillationWithin this with ⟨r, r0, hr⟩\n\n  /- We prove the claim for partitions π₁ and π₂ subordinate to r/2, by writing the difference as\n     an integralSum over π₁ ⊓ π₂ and considering separately the boxes of π₁ ⊓ π₂ which are/aren't\n     fully contained within U. -/\n  refine ⟨fun _ _ ↦ ⟨r / 2, half_pos r0⟩, fun _ _ _ ↦ rfl, fun c₁ c₂ π₁ π₂ h₁ h₁p h₂ h₂p ↦ ?_⟩\n  simp only [dist_eq_norm, integralSum_sub_partitions _ _ h₁p h₂p, toSMul_apply, ← smul_sub]\n  have μI : μ I < ⊤ := lt_of_le_of_lt (μ.mono I.coe_subset_Icc) I.isCompact_Icc.measure_lt_top\n  let t₁ (J : Box ι) : ℝⁿ := (π₁.infPrepartition π₂.toPrepartition).tag J\n  let t₂ (J : Box ι) : ℝⁿ := (π₂.infPrepartition π₁.toPrepartition).tag J\n  let B := (π₁.toPrepartition ⊓ π₂.toPrepartition).boxes\n  classical\n  let B' := {J ∈ B | J.toSet ⊆ U}\n  have hB' : B' ⊆ B := B.filter_subset (fun J ↦ J.toSet ⊆ U)\n  have μJ_ne_top : ∀ J ∈ B, μ J ≠ ⊤ :=\n    fun J hJ ↦ lt_top_iff_ne_top.1 <| lt_of_le_of_lt (μ.mono (Prepartition.le_of_mem' _ J hJ)) μI\n  have un : ∀ S ⊆ B, ⋃ J ∈ S, J.toSet ⊆ I.toSet :=\n    fun S hS ↦ iUnion_subset_iff.2 (fun J ↦ iUnion_subset_iff.2 fun hJ ↦ le_of_mem' _ J (hS hJ))\n  rw [← sum_sdiff hB', ← add_halves ε]\n  apply le_trans (norm_add_le _ _) (add_le_add ?_ ?_)\n\n  /- If a box J is not contained within U, then the oscillation of f on J is small, which bounds\n     the contribution of J to the overall sum. -/\n  · have : ∀ J ∈ B \\ B', ‖μ.toBoxAdditive J • (f (t₁ J) - f (t₂ J))‖ ≤ μ.toBoxAdditive J * ε₁ := by\n      intro J hJ\n      rw [mem_sdiff, B.mem_filter, not_and] at hJ\n      rw [norm_smul, μ.toBoxAdditive_apply, Real.norm_of_nonneg toReal_nonneg]\n      refine mul_le_mul_of_nonneg_left ?_ toReal_nonneg\n      obtain ⟨x, xJ, xnU⟩ : ∃ x ∈ J, x ∉ U := Set.not_subset.1 (hJ.2 hJ.1)\n      have hx : x ∈ Box.Icc I \\ U := ⟨Box.coe_subset_Icc ((le_of_mem' _ J hJ.1) xJ), xnU⟩\n      have ineq : edist (f (t₁ J)) (f (t₂ J)) ≤ EMetric.diam (f '' (ball x r ∩ (Box.Icc I))) := by\n        apply edist_le_diam_of_mem <;>\n          refine Set.mem_image_of_mem f ⟨?_, tag_mem_Icc _ J⟩ <;>\n          refine closedBall_subset_ball (div_two_lt_of_pos r0) <| mem_closedBall_comm.1 ?_\n        · exact h₁.isSubordinate.infPrepartition π₂.toPrepartition J hJ.1 (Box.coe_subset_Icc xJ)\n        · exact h₂.isSubordinate.infPrepartition π₁.toPrepartition J\n            ((π₁.mem_infPrepartition_comm).1 hJ.1) (Box.coe_subset_Icc xJ)\n      rw [← emetric_ball] at ineq\n      simpa only [edist_le_ofReal (le_of_lt ε₁0), dist_eq_norm, hJ.1] using ineq.trans (hr x hx)\n    refine (norm_sum_le _ _).trans <| (sum_le_sum this).trans ?_\n    rw [← sum_mul]\n    trans μ.toBoxAdditive I * ε₁; swap\n    · linarith\n    simp_rw [mul_le_mul_right ε₁0, μ.toBoxAdditive_apply]\n    refine le_trans ?_ <| toReal_mono (lt_top_iff_ne_top.1 μI) <| μ.mono <| un (B \\ B') sdiff_subset\n    rw [← toReal_sum (fun J hJ ↦ μJ_ne_top J (mem_sdiff.1 hJ).1), ← Finset.tsum_subtype]\n    refine (toReal_mono <| ne_of_lt <| lt_of_le_of_lt (μ.mono <| un (B \\ B') sdiff_subset) μI) ?_\n    refine le_of_eq (measure_biUnion (countable_toSet _) ?_ (fun J _ ↦ J.measurableSet_coe)).symm\n    exact fun J hJ J' hJ' hJJ' ↦ pairwiseDisjoint _ (mem_sdiff.1 hJ).1 (mem_sdiff.1 hJ').1 hJJ'\n\n  -- The contribution of the boxes contained within U is bounded because f is bounded and μ U < ε₂.\n  · have : ∀ J ∈ B', ‖μ.toBoxAdditive J • (f (t₁ J) - f (t₂ J))‖ ≤ μ.toBoxAdditive J * (2 * C) := by\n      intro J _\n      rw [norm_smul, μ.toBoxAdditive_apply, Real.norm_of_nonneg toReal_nonneg, two_mul]\n      refine mul_le_mul_of_nonneg_left (le_trans (norm_sub_le _ _) (add_le_add ?_ ?_)) (by simp) <;>\n        exact hC _ (TaggedPrepartition.tag_mem_Icc _ J)\n    apply (norm_sum_le_of_le B' this).trans\n    simp_rw [← sum_mul, μ.toBoxAdditive_apply, ← toReal_sum (fun J hJ ↦ μJ_ne_top J (hB' hJ))]\n    suffices (∑ J ∈ B', μ J).toReal ≤ ε₂ by\n      linarith [mul_le_mul_of_nonneg_right this <| (mul_nonneg_iff_of_pos_left two_pos).2 C0]\n    rw [← toReal_ofReal (le_of_lt ε₂0)]\n    refine toReal_mono ofReal_ne_top (le_trans ?_ (le_of_lt hU))\n    trans μ' (⋃ J ∈ B', J)\n    · simp only [μ', μ.restrict_eq_self <| (un _ hB').trans I.coe_subset_Icc]\n      exact le_of_eq <| Eq.symm <| measure_biUnion_finset\n        (fun J hJ K hK hJK ↦ pairwiseDisjoint _ (hB' hJ) (hB' hK) hJK) fun J _ ↦ J.measurableSet_coe\n    · apply μ'.mono\n      simp_rw [iUnion_subset_iff]\n      exact fun J hJ ↦ (mem_filter.1 hJ).2\n\n"}
{"name":"BoxIntegral.integrable_of_bounded_and_ae_continuous","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"ι : Type u\nE : Type v\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : Fintype ι\nl : BoxIntegral.IntegrationParams\ninst✝¹ : CompleteSpace E\nI : BoxIntegral.Box ι\nf : (ι → Real) → E\nhb : Exists fun C => ∀ (x : ι → Real), Membership.mem (BoxIntegral.Box.Icc I) x → LE.le (Norm.norm (f x)) C\nμ : MeasureTheory.Measure (ι → Real)\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure μ\nhc : Filter.Eventually (fun x => ContinuousAt f x) (MeasureTheory.ae μ)\n⊢ BoxIntegral.Integrable I l f μ.toBoxAdditive.toSMul","decl":"/-- A function that is bounded on a box `I` and a.e. continuous is integrable on `I`.\n\nThis is a version of `integrable_of_bounded_and_ae_continuousWithinAt` with a stronger continuity\nassumption so that the user does not need to specialize the continuity assumption to each box on\nwhich the theorem is to be applied. -/\ntheorem integrable_of_bounded_and_ae_continuous [CompleteSpace E] {I : Box ι} {f : ℝⁿ → E}\n    (hb : ∃ C : ℝ, ∀ x ∈ Box.Icc I, ‖f x‖ ≤ C) (μ : Measure ℝⁿ) [IsLocallyFiniteMeasure μ]\n    (hc : ∀ᵐ x ∂μ, ContinuousAt f x) : Integrable I l f μ.toBoxAdditive.toSMul :=\n  integrable_of_bounded_and_ae_continuousWithinAt l hb μ <|\n    Eventually.filter_mono (ae_mono μ.restrict_le_self) (hc.mono fun _ h ↦ h.continuousWithinAt)\n\n\n"}
{"name":"BoxIntegral.integrable_of_continuousOn","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"ι : Type u\nE : Type v\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : Fintype ι\nl : BoxIntegral.IntegrationParams\ninst✝¹ : CompleteSpace E\nI : BoxIntegral.Box ι\nf : (ι → Real) → E\nhc : ContinuousOn f (BoxIntegral.Box.Icc I)\nμ : MeasureTheory.Measure (ι → Real)\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure μ\n⊢ BoxIntegral.Integrable I l f μ.toBoxAdditive.toSMul","decl":"/-- A continuous function is box-integrable with respect to any locally finite measure.\n\nThis is true for any volume with bounded variation. -/\ntheorem integrable_of_continuousOn [CompleteSpace E] {I : Box ι} {f : ℝⁿ → E}\n    (hc : ContinuousOn f (Box.Icc I)) (μ : Measure ℝⁿ) [IsLocallyFiniteMeasure μ] :\n    Integrable.{u, v, v} I l f μ.toBoxAdditive.toSMul := by\n  apply integrable_of_bounded_and_ae_continuousWithinAt\n  · obtain ⟨C, hC⟩ := (NormedSpace.isBounded_iff_subset_smul_closedBall ℝ).1\n                        (I.isCompact_Icc.image_of_continuousOn hc).isBounded\n    use ‖C‖, fun x hx ↦ by\n      simpa only [smul_unitClosedBall, mem_closedBall_zero_iff] using hC (Set.mem_image_of_mem f hx)\n  · refine eventually_of_mem ?_ (fun x hx ↦ hc.continuousWithinAt hx)\n    rw [mem_ae_iff, μ.restrict_apply] <;> simp [MeasurableSet.compl_iff.2 I.measurableSet_Icc]\n\n"}
{"name":"BoxIntegral.HasIntegral.of_bRiemann_eq_false_of_forall_isLittleO","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"ι : Type u\nE : Type v\nF : Type w\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Real F\nI : BoxIntegral.Box ι\ninst✝ : Fintype ι\nl : BoxIntegral.IntegrationParams\nf : (ι → Real) → E\nvol : BoxIntegral.BoxAdditiveMap ι (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nhl : Eq l.bRiemann Bool.false\nB : BoxIntegral.BoxAdditiveMap ι Real ↑I\nhB0 : ∀ (J : BoxIntegral.Box ι), LE.le 0 (B J)\ng : BoxIntegral.BoxAdditiveMap ι F ↑I\ns : Set (ι → Real)\nhs : s.Countable\nhlH : s.Nonempty → Eq l.bHenstock Bool.true\nH₁ : ∀ (c : NNReal) (x : ι → Real), Membership.mem (Inter.inter (BoxIntegral.Box.Icc I) s) x → ∀ (ε : Real), GT.gt ε 0 → Exists fun δ => And (GT.gt δ 0) (∀ (J : BoxIntegral.Box ι), LE.le J I → HasSubset.Subset (BoxIntegral.Box.Icc J) (Metric.closedBall x δ) → Membership.mem (BoxIntegral.Box.Icc J) x → (Eq l.bDistortion Bool.true → LE.le J.distortion c) → LE.le (Dist.dist ((vol J) (f x)) (g J)) ε)\nH₂ : ∀ (c : NNReal) (x : ι → Real), Membership.mem (SDiff.sdiff (BoxIntegral.Box.Icc I) s) x → ∀ (ε : Real), GT.gt ε 0 → Exists fun δ => And (GT.gt δ 0) (∀ (J : BoxIntegral.Box ι), LE.le J I → HasSubset.Subset (BoxIntegral.Box.Icc J) (Metric.closedBall x δ) → (Eq l.bHenstock Bool.true → Membership.mem (BoxIntegral.Box.Icc J) x) → (Eq l.bDistortion Bool.true → LE.le J.distortion c) → LE.le (Dist.dist ((vol J) (f x)) (g J)) (HMul.hMul ε (B J)))\n⊢ BoxIntegral.HasIntegral I l f vol (g I)","decl":"/-- This is an auxiliary lemma used to prove two statements at once. Use one of the next two\nlemmas instead. -/\ntheorem HasIntegral.of_bRiemann_eq_false_of_forall_isLittleO (hl : l.bRiemann = false)\n    (B : ι →ᵇᵃ[I] ℝ) (hB0 : ∀ J, 0 ≤ B J) (g : ι →ᵇᵃ[I] F) (s : Set ℝⁿ) (hs : s.Countable)\n    (hlH : s.Nonempty → l.bHenstock = true)\n    (H₁ : ∀ (c : ℝ≥0), ∀ x ∈ Box.Icc I ∩ s, ∀ ε > (0 : ℝ),\n      ∃ δ > 0, ∀ J ≤ I, Box.Icc J ⊆ Metric.closedBall x δ → x ∈ Box.Icc J →\n        (l.bDistortion → J.distortion ≤ c) → dist (vol J (f x)) (g J) ≤ ε)\n    (H₂ : ∀ (c : ℝ≥0), ∀ x ∈ Box.Icc I \\ s, ∀ ε > (0 : ℝ),\n      ∃ δ > 0, ∀ J ≤ I, Box.Icc J ⊆ Metric.closedBall x δ → (l.bHenstock → x ∈ Box.Icc J) →\n        (l.bDistortion → J.distortion ≤ c) → dist (vol J (f x)) (g J) ≤ ε * B J) :\n    HasIntegral I l f vol (g I) := by\n  /- We choose `r x` differently for `x ∈ s` and `x ∉ s`.\n\n    For `x ∈ s`, we choose `εs` such that `∑' x : s, εs x < ε / 2 / 2 ^ #ι`, then choose `r x` so\n    that `dist (vol J (f x)) (g J) ≤ εs x` for `J` in the `r x`-neighborhood of `x`. This guarantees\n    that the sum of these distances over boxes `J` such that `π.tag J ∈ s` is less than `ε / 2`. We\n    need an additional multiplier `2 ^ #ι` because different boxes can have the same tag.\n\n    For `x ∉ s`, we choose `r x` so that `dist (vol (J (f x))) (g J) ≤ (ε / 2 / B I) * B J` for a\n    box `J` in the `δ`-neighborhood of `x`. -/\n  refine ((l.hasBasis_toFilteriUnion_top _).tendsto_iff Metric.nhds_basis_closedBall).2 ?_\n  intro ε ε0\n  simp only [← exists_prop, gt_iff_lt, Subtype.exists'] at H₁ H₂\n  choose! δ₁ Hδ₁ using H₁\n  choose! δ₂ Hδ₂ using H₂\n  have ε0' := half_pos ε0; have H0 : 0 < (2 : ℝ) ^ Fintype.card ι := pow_pos zero_lt_two _\n  rcases hs.exists_pos_forall_sum_le (div_pos ε0' H0) with ⟨εs, hεs0, hεs⟩\n  simp only [le_div_iff₀' H0, mul_sum] at hεs\n  rcases exists_pos_mul_lt ε0' (B I) with ⟨ε', ε'0, hεI⟩\n  classical\n  set δ : ℝ≥0 → ℝⁿ → Ioi (0 : ℝ) := fun c x => if x ∈ s then δ₁ c x (εs x) else (δ₂ c) x ε'\n  refine ⟨δ, fun c => l.rCond_of_bRiemann_eq_false hl, ?_⟩\n  simp only [Set.mem_iUnion, mem_inter_iff, mem_setOf_eq]\n  rintro π ⟨c, hπδ, hπp⟩\n  -- Now we split the sum into two parts based on whether `π.tag J` belongs to `s` or not.\n  rw [← g.sum_partition_boxes le_rfl hπp, Metric.mem_closedBall, integralSum,\n    ← sum_filter_add_sum_filter_not π.boxes fun J => π.tag J ∈ s,\n    ← sum_filter_add_sum_filter_not π.boxes fun J => π.tag J ∈ s, ← add_halves ε]\n  refine dist_add_add_le_of_le ?_ ?_\n  · rcases s.eq_empty_or_nonempty with (rfl | hsne); · simp [ε0'.le]\n    /- For the boxes such that `π.tag J ∈ s`, we use the fact that at most `2 ^ #ι` boxes have the\n        same tag. -/\n    specialize hlH hsne\n    have : ∀ J ∈ {J ∈ π.boxes | π.tag J ∈ s},\n        dist (vol J (f <| π.tag J)) (g J) ≤ εs (π.tag J) := fun J hJ ↦ by\n      rw [Finset.mem_filter] at hJ; cases' hJ with hJ hJs\n      refine Hδ₁ c _ ⟨π.tag_mem_Icc _, hJs⟩ _ (hεs0 _) _ (π.le_of_mem' _ hJ) ?_\n        (hπδ.2 hlH J hJ) fun hD => (Finset.le_sup hJ).trans (hπδ.3 hD)\n      convert hπδ.1 J hJ using 3; exact (if_pos hJs).symm\n    refine (dist_sum_sum_le_of_le _ this).trans ?_\n    rw [sum_comp]\n    refine (sum_le_sum ?_).trans (hεs _ ?_)\n    · rintro b -\n      rw [← Nat.cast_two, ← Nat.cast_pow, ← nsmul_eq_mul]\n      refine nsmul_le_nsmul_left (hεs0 _).le ?_\n      refine (Finset.card_le_card ?_).trans ((hπδ.isHenstock hlH).card_filter_tag_eq_le b)\n      exact filter_subset_filter _ (filter_subset _ _)\n    · rw [Finset.coe_image, Set.image_subset_iff]\n      exact fun J hJ => (Finset.mem_filter.1 hJ).2\n  /- Now we deal with boxes such that `π.tag J ∉ s`.\n    In this case the estimate is straightforward. -/\n  -- Porting note: avoided strange elaboration issues by rewriting using `calc`\n  calc\n    dist (∑ J ∈ π.boxes with ¬tag π J ∈ s, vol J (f (tag π J)))\n      (∑ J ∈ π.boxes with ¬tag π J ∈ s, g J)\n      ≤ ∑ J ∈ π.boxes with ¬tag π J ∈ s, ε' * B J := dist_sum_sum_le_of_le _ fun J hJ ↦ by\n      rw [Finset.mem_filter] at hJ; cases' hJ with hJ hJs\n      refine Hδ₂ c _ ⟨π.tag_mem_Icc _, hJs⟩ _ ε'0 _ (π.le_of_mem' _ hJ) ?_ (fun hH => hπδ.2 hH J hJ)\n        fun hD => (Finset.le_sup hJ).trans (hπδ.3 hD)\n      convert hπδ.1 J hJ using 3; exact (if_neg hJs).symm\n    _ ≤ ∑ J ∈ π.boxes, ε' * B J := sum_le_sum_of_subset_of_nonneg (filter_subset _ _) fun _ _ _ ↦\n      mul_nonneg ε'0.le (hB0 _)\n    _ = B I * ε' := by rw [← mul_sum, B.sum_partition_boxes le_rfl hπp, mul_comm]\n    _ ≤ ε / 2 := hεI.le\n\n"}
{"name":"BoxIntegral.HasIntegral.of_le_Henstock_of_forall_isLittleO","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"ι : Type u\nE : Type v\nF : Type w\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Real F\nI : BoxIntegral.Box ι\ninst✝ : Fintype ι\nl : BoxIntegral.IntegrationParams\nf : (ι → Real) → E\nvol : BoxIntegral.BoxAdditiveMap ι (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nhl : LE.le l BoxIntegral.IntegrationParams.Henstock\nB : BoxIntegral.BoxAdditiveMap ι Real ↑I\nhB0 : ∀ (J : BoxIntegral.Box ι), LE.le 0 (B J)\ng : BoxIntegral.BoxAdditiveMap ι F ↑I\ns : Set (ι → Real)\nhs : s.Countable\nH₁ : ∀ (c : NNReal) (x : ι → Real), Membership.mem (Inter.inter (BoxIntegral.Box.Icc I) s) x → ∀ (ε : Real), GT.gt ε 0 → Exists fun δ => And (GT.gt δ 0) (∀ (J : BoxIntegral.Box ι), LE.le J I → HasSubset.Subset (BoxIntegral.Box.Icc J) (Metric.closedBall x δ) → Membership.mem (BoxIntegral.Box.Icc J) x → (Eq l.bDistortion Bool.true → LE.le J.distortion c) → LE.le (Dist.dist ((vol J) (f x)) (g J)) ε)\nH₂ : ∀ (c : NNReal) (x : ι → Real), Membership.mem (SDiff.sdiff (BoxIntegral.Box.Icc I) s) x → ∀ (ε : Real), GT.gt ε 0 → Exists fun δ => And (GT.gt δ 0) (∀ (J : BoxIntegral.Box ι), LE.le J I → HasSubset.Subset (BoxIntegral.Box.Icc J) (Metric.closedBall x δ) → Membership.mem (BoxIntegral.Box.Icc J) x → (Eq l.bDistortion Bool.true → LE.le J.distortion c) → LE.le (Dist.dist ((vol J) (f x)) (g J)) (HMul.hMul ε (B J)))\n⊢ BoxIntegral.HasIntegral I l f vol (g I)","decl":"/-- A function `f` has Henstock (or `⊥`) integral over `I` is equal to the value of a box-additive\nfunction `g` on `I` provided that `vol J (f x)` is sufficiently close to `g J` for sufficiently\nsmall boxes `J ∋ x`. This lemma is useful to prove, e.g., to prove the Divergence theorem for\nintegral along `⊥`.\n\nLet `l` be either `BoxIntegral.IntegrationParams.Henstock` or `⊥`. Let `g` a box-additive function\non subboxes of `I`. Suppose that there exists a nonnegative box-additive function `B` and a\ncountable set `s` with the following property.\n\nFor every `c : ℝ≥0`, a point `x ∈ I.Icc`, and a positive `ε` there exists `δ > 0` such that for any\nbox `J ≤ I` such that\n\n- `x ∈ J.Icc ⊆ Metric.closedBall x δ`;\n- if `l.bDistortion` (i.e., `l = ⊥`), then the distortion of `J` is less than or equal to `c`,\n\nthe distance between the term `vol J (f x)` of an integral sum corresponding to `J` and `g J` is\nless than or equal to `ε` if `x ∈ s` and is less than or equal to `ε * B J` otherwise.\n\nThen `f` is integrable on `I` along `l` with integral `g I`. -/\ntheorem HasIntegral.of_le_Henstock_of_forall_isLittleO (hl : l ≤ Henstock) (B : ι →ᵇᵃ[I] ℝ)\n    (hB0 : ∀ J, 0 ≤ B J) (g : ι →ᵇᵃ[I] F) (s : Set ℝⁿ) (hs : s.Countable)\n    (H₁ : ∀ (c : ℝ≥0), ∀ x ∈ Box.Icc I ∩ s, ∀ ε > (0 : ℝ),\n      ∃ δ > 0, ∀ J ≤ I, Box.Icc J ⊆ Metric.closedBall x δ → x ∈ Box.Icc J →\n        (l.bDistortion → J.distortion ≤ c) → dist (vol J (f x)) (g J) ≤ ε)\n    (H₂ : ∀ (c : ℝ≥0), ∀ x ∈ Box.Icc I \\ s, ∀ ε > (0 : ℝ),\n      ∃ δ > 0, ∀ J ≤ I, Box.Icc J ⊆ Metric.closedBall x δ → x ∈ Box.Icc J →\n        (l.bDistortion → J.distortion ≤ c) → dist (vol J (f x)) (g J) ≤ ε * B J) :\n    HasIntegral I l f vol (g I) :=\n  have A : l.bHenstock := Bool.eq_true_of_true_le hl.2.1\n  HasIntegral.of_bRiemann_eq_false_of_forall_isLittleO (Bool.eq_false_of_le_false hl.1) B hB0 _ s hs\n    (fun _ => A) H₁ <| by simpa only [A, true_imp_iff] using H₂\n\n"}
{"name":"BoxIntegral.HasIntegral.mcShane_of_forall_isLittleO","module":"Mathlib.Analysis.BoxIntegral.Basic","initialProofState":"ι : Type u\nE : Type v\nF : Type w\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Real F\nI : BoxIntegral.Box ι\ninst✝ : Fintype ι\nf : (ι → Real) → E\nvol : BoxIntegral.BoxAdditiveMap ι (ContinuousLinearMap (RingHom.id Real) E F) Top.top\nB : BoxIntegral.BoxAdditiveMap ι Real ↑I\nhB0 : ∀ (J : BoxIntegral.Box ι), LE.le 0 (B J)\ng : BoxIntegral.BoxAdditiveMap ι F ↑I\nH : NNReal → ∀ (x : ι → Real), Membership.mem (BoxIntegral.Box.Icc I) x → ∀ (ε : Real), GT.gt ε 0 → Exists fun δ => And (GT.gt δ 0) (∀ (J : BoxIntegral.Box ι), LE.le J I → HasSubset.Subset (BoxIntegral.Box.Icc J) (Metric.closedBall x δ) → LE.le (Dist.dist ((vol J) (f x)) (g J)) (HMul.hMul ε (B J)))\n⊢ BoxIntegral.HasIntegral I BoxIntegral.IntegrationParams.McShane f vol (g I)","decl":"/-- Suppose that there exists a nonnegative box-additive function `B` with the following property.\n\nFor every `c : ℝ≥0`, a point `x ∈ I.Icc`, and a positive `ε` there exists `δ > 0` such that for any\nbox `J ≤ I` such that\n\n- `J.Icc ⊆ Metric.closedBall x δ`;\n- if `l.bDistortion` (i.e., `l = ⊥`), then the distortion of `J` is less than or equal to `c`,\n\nthe distance between the term `vol J (f x)` of an integral sum corresponding to `J` and `g J` is\nless than or equal to `ε * B J`.\n\nThen `f` is McShane integrable on `I` with integral `g I`. -/\ntheorem HasIntegral.mcShane_of_forall_isLittleO (B : ι →ᵇᵃ[I] ℝ) (hB0 : ∀ J, 0 ≤ B J)\n    (g : ι →ᵇᵃ[I] F) (H : ∀ (_ : ℝ≥0), ∀ x ∈ Box.Icc I, ∀ ε > (0 : ℝ), ∃ δ > 0, ∀ J ≤ I,\n      Box.Icc J ⊆ Metric.closedBall x δ → dist (vol J (f x)) (g J) ≤ ε * B J) :\n    HasIntegral I McShane f vol (g I) :=\n  (HasIntegral.of_bRiemann_eq_false_of_forall_isLittleO (l := McShane) rfl B hB0 g ∅ countable_empty\n      (fun ⟨_x, hx⟩ => hx.elim) fun _ _ hx => hx.2.elim) <| by\n    simpa only [McShane, Bool.coe_sort_false, false_imp_iff, true_imp_iff, diff_empty] using H\n\n"}
