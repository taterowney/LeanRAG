{"name":"CFC.monotoneOn_one_sub_one_add_inv","module":"Mathlib.Analysis.CStarAlgebra.ApproximateUnit","initialProofState":"A : Type u_1\ninst‚úù¬≤ : NonUnitalCStarAlgebra A\ninst‚úù¬π : PartialOrder A\ninst‚úù : StarOrderedRing A\n‚ä¢ MonotoneOn (cfc‚Çô fun x => HSub.hSub 1 (Inv.inv (HAdd.hAdd 1 x))) (Set.Ici 0)","decl":"lemma CFC.monotoneOn_one_sub_one_add_inv :\n    MonotoneOn (cfc‚Çô (fun x : ‚Ñù‚â•0 ‚Ü¶ 1 - (1 + x)‚Åª¬π)) (Set.Ici (0 : A)) := by\n  intro a ha b hb hab\n  simp only [Set.mem_Ici] at ha hb\n  rw [‚Üê inr_le_iff .., nnreal_cfc‚Çô_eq_cfc_inr a _, nnreal_cfc‚Çô_eq_cfc_inr b _]\n  rw [‚Üê inr_le_iff a b (.of_nonneg ha) (.of_nonneg hb)] at hab\n  rw [‚Üê inr_nonneg_iff] at ha hb\n  have h_cfc_one_sub (c : A‚Å∫¬π) (hc : 0 ‚â§ c := by cfc_tac) :\n      cfc (fun x : ‚Ñù‚â•0 ‚Ü¶ 1 - (1 + x)‚Åª¬π) c = 1 - cfc (¬∑‚Åª¬π : ‚Ñù‚â•0 ‚Üí ‚Ñù‚â•0) (1 + c) := by\n    rw [cfc_tsub _ _ _ (fun x _ ‚Ü¶ by simp) (hg := by fun_prop (disch := intro _ _; positivity)),\n      cfc_const_one ‚Ñù‚â•0 c, cfc_comp' (¬∑‚Åª¬π) (1 + ¬∑) c ?_, cfc_add .., cfc_const_one ‚Ñù‚â•0 c,\n      cfc_id' ‚Ñù‚â•0 c]\n    exact continuousOn_id.inv‚ÇÄ (Set.forall_mem_image.mpr fun x _ ‚Ü¶ by dsimp only [id]; positivity)\n  rw [h_cfc_one_sub (a : A‚Å∫¬π), h_cfc_one_sub (b : A‚Å∫¬π)]\n  gcongr\n  rw [‚Üê CFC.rpow_neg_one_eq_cfc_inv, ‚Üê CFC.rpow_neg_one_eq_cfc_inv]\n  exact rpow_neg_one_le_rpow_neg_one (add_nonneg zero_le_one ha) (by gcongr) <|\n    isUnit_of_le isUnit_one zero_le_one <| le_add_of_nonneg_right ha\n\n"}
{"name":"Set.InvOn.one_sub_one_add_inv","module":"Mathlib.Analysis.CStarAlgebra.ApproximateUnit","initialProofState":"‚ä¢ Set.InvOn (fun x => HSub.hSub 1 (Inv.inv (HAdd.hAdd 1 x))) (fun x => HMul.hMul x (Inv.inv (HSub.hSub 1 x))) (setOf fun x => LT.lt x 1) (setOf fun x => LT.lt x 1)","decl":"lemma Set.InvOn.one_sub_one_add_inv : Set.InvOn (fun x ‚Ü¶ 1 - (1 + x)‚Åª¬π) (fun x ‚Ü¶ x * (1 - x)‚Åª¬π)\n    {x : ‚Ñù‚â•0 | x < 1} {x : ‚Ñù‚â•0 | x < 1} := by\n  have : (fun x : ‚Ñù‚â•0 ‚Ü¶ x * (1 + x)‚Åª¬π) = fun x ‚Ü¶ 1 - (1 + x)‚Åª¬π := by\n    ext x : 1\n    field_simp\n    simp [tsub_mul, inv_mul_cancel‚ÇÄ]\n  rw [‚Üê this]\n  constructor <;> intro x (hx : x < 1)\n  ¬∑ have : 0 < 1 - x := tsub_pos_of_lt hx\n    field_simp [tsub_add_cancel_of_le hx.le, tsub_tsub_cancel_of_le hx.le]\n  ¬∑ field_simp [mul_tsub]\n\n"}
{"name":"norm_cfc‚Çô_one_sub_one_add_inv_lt_one","module":"Mathlib.Analysis.CStarAlgebra.ApproximateUnit","initialProofState":"A : Type u_1\ninst‚úù¬≤ : NonUnitalCStarAlgebra A\ninst‚úù¬π : PartialOrder A\ninst‚úù : StarOrderedRing A\na : A\n‚ä¢ LT.lt (Norm.norm (cfc‚Çô (fun x => HSub.hSub 1 (Inv.inv (HAdd.hAdd 1 x))) a)) 1","decl":"lemma norm_cfc‚Çô_one_sub_one_add_inv_lt_one (a : A) :\n    ‚Äñcfc‚Çô (fun x : ‚Ñù‚â•0 ‚Ü¶ 1 - (1 + x)‚Åª¬π) a‚Äñ < 1 :=\n  nnnorm_cfc‚Çô_nnreal_lt fun x _ ‚Ü¶ tsub_lt_self zero_lt_one (by positivity)\n\n-- the calls to `fun_prop` with a discharger set off the linter\n"}
{"name":"CStarAlgebra.directedOn_nonneg_ball","module":"Mathlib.Analysis.CStarAlgebra.ApproximateUnit","initialProofState":"A : Type u_1\ninst‚úù¬≤ : NonUnitalCStarAlgebra A\ninst‚úù¬π : PartialOrder A\ninst‚úù : StarOrderedRing A\n‚ä¢ DirectedOn (fun x1 x2 => LE.le x1 x2) (Inter.inter (setOf fun x => LE.le 0 x) (Metric.ball 0 1))","decl":"set_option linter.style.multiGoal false in\nlemma CStarAlgebra.directedOn_nonneg_ball :\n    DirectedOn (¬∑ ‚â§ ¬∑) ({x : A | 0 ‚â§ x} ‚à© Metric.ball 0 1) := by\n  let f : ‚Ñù‚â•0 ‚Üí ‚Ñù‚â•0 := fun x => 1 - (1 + x)‚Åª¬π\n  let g : ‚Ñù‚â•0 ‚Üí ‚Ñù‚â•0 := fun x => x * (1 - x)‚Åª¬π\n  suffices ‚àÄ a b : A, 0 ‚â§ a ‚Üí 0 ‚â§ b ‚Üí ‚Äña‚Äñ < 1 ‚Üí ‚Äñb‚Äñ < 1 ‚Üí\n      a ‚â§ cfc‚Çô f (cfc‚Çô g a + cfc‚Çô g b) by\n    rintro a ‚ü®(ha‚ÇÅ : 0 ‚â§ a), ha‚ÇÇ‚ü© b ‚ü®(hb‚ÇÅ : 0 ‚â§ b), hb‚ÇÇ‚ü©\n    simp only [Metric.mem_ball, dist_zero_right] at ha‚ÇÇ hb‚ÇÇ\n    refine ‚ü®cfc‚Çô f (cfc‚Çô g a + cfc‚Çô g b), ‚ü®by simp, ?_‚ü©, ?_, ?_‚ü©\n    ¬∑ simpa only [Metric.mem_ball, dist_zero_right] using norm_cfc‚Çô_one_sub_one_add_inv_lt_one _\n    ¬∑ exact this a b ha‚ÇÅ hb‚ÇÅ ha‚ÇÇ hb‚ÇÇ\n    ¬∑ exact add_comm (cfc‚Çô g a) (cfc‚Çô g b) ‚ñ∏ this b a hb‚ÇÅ ha‚ÇÅ hb‚ÇÇ ha‚ÇÇ\n  rintro a b ha‚ÇÅ - ha‚ÇÇ -\n  calc\n    a = cfc‚Çô (f ‚àò g) a := by\n      conv_lhs => rw [‚Üê cfc‚Çô_id ‚Ñù‚â•0 a]\n      refine cfc‚Çô_congr (Set.InvOn.one_sub_one_add_inv.1.eqOn.symm.mono fun x hx ‚Ü¶ ?_)\n      exact lt_of_le_of_lt (le_nnnorm_of_mem_quasispectrum hx) ha‚ÇÇ\n    _ = cfc‚Çô f (cfc‚Çô g a) := by\n      rw [cfc‚Çô_comp f g a ?_ (by simp [f, tsub_self]) ?_ (by simp [g]) ha‚ÇÅ]\n      ¬∑ fun_prop (disch := intro _ _; positivity)\n      ¬∑ have (x) (hx : x ‚àà œÉ‚Çô ‚Ñù‚â•0 a) :  1 - x ‚â† 0 := by\n          refine tsub_pos_of_lt ?_ |>.ne'\n          exact lt_of_le_of_lt (le_nnnorm_of_mem_quasispectrum hx) ha‚ÇÇ\n        fun_prop (disch := assumption)\n    _ ‚â§ cfc‚Çô f (cfc‚Çô g a + cfc‚Çô g b) := by\n      have hab' : cfc‚Çô g a ‚â§ cfc‚Çô g a + cfc‚Çô g b := le_add_of_nonneg_right cfc‚Çô_nonneg_of_predicate\n      exact CFC.monotoneOn_one_sub_one_add_inv cfc‚Çô_nonneg_of_predicate\n        (cfc‚Çô_nonneg_of_predicate.trans hab') hab'\n\n"}
{"name":"Filter.IsIncreasingApproximateUnit.toIsApproximateUnit","module":"Mathlib.Analysis.CStarAlgebra.ApproximateUnit","initialProofState":"A : Type u_1\ninst‚úù¬π : NonUnitalCStarAlgebra A\ninst‚úù : PartialOrder A\nl : Filter A\nself : l.IsIncreasingApproximateUnit\n‚ä¢ l.IsApproximateUnit","decl":"/-- An *increasing approximate unit* in a C‚ãÜ-algebra is an approximate unit contained in the\nclosed unit ball of nonnegative elements. -/\nstructure Filter.IsIncreasingApproximateUnit (l : Filter A) extends l.IsApproximateUnit : Prop where\n  eventually_nonneg : ‚àÄ·∂† x in l, 0 ‚â§ x\n  eventually_norm : ‚àÄ·∂† x in l, ‚Äñx‚Äñ ‚â§ 1\n\n"}
{"name":"Filter.IsIncreasingApproximateUnit.eventually_nonneg","module":"Mathlib.Analysis.CStarAlgebra.ApproximateUnit","initialProofState":"A : Type u_1\ninst‚úù¬π : NonUnitalCStarAlgebra A\ninst‚úù : PartialOrder A\nl : Filter A\nself : l.IsIncreasingApproximateUnit\n‚ä¢ Filter.Eventually (fun x => LE.le 0 x) l","decl":"/-- An *increasing approximate unit* in a C‚ãÜ-algebra is an approximate unit contained in the\nclosed unit ball of nonnegative elements. -/\nstructure Filter.IsIncreasingApproximateUnit (l : Filter A) extends l.IsApproximateUnit : Prop where\n  eventually_nonneg : ‚àÄ·∂† x in l, 0 ‚â§ x\n  eventually_norm : ‚àÄ·∂† x in l, ‚Äñx‚Äñ ‚â§ 1\n\n"}
{"name":"Filter.IsIncreasingApproximateUnit.eventually_norm","module":"Mathlib.Analysis.CStarAlgebra.ApproximateUnit","initialProofState":"A : Type u_1\ninst‚úù¬π : NonUnitalCStarAlgebra A\ninst‚úù : PartialOrder A\nl : Filter A\nself : l.IsIncreasingApproximateUnit\n‚ä¢ Filter.Eventually (fun x => LE.le (Norm.norm x) 1) l","decl":"/-- An *increasing approximate unit* in a C‚ãÜ-algebra is an approximate unit contained in the\nclosed unit ball of nonnegative elements. -/\nstructure Filter.IsIncreasingApproximateUnit (l : Filter A) extends l.IsApproximateUnit : Prop where\n  eventually_nonneg : ‚àÄ·∂† x in l, 0 ‚â§ x\n  eventually_norm : ‚àÄ·∂† x in l, ‚Äñx‚Äñ ‚â§ 1\n\n"}
{"name":"Filter.IsIncreasingApproximateUnit.eventually_nnnorm","module":"Mathlib.Analysis.CStarAlgebra.ApproximateUnit","initialProofState":"A : Type u_1\ninst‚úù¬π : NonUnitalCStarAlgebra A\ninst‚úù : PartialOrder A\nl : Filter A\nhl : l.IsIncreasingApproximateUnit\n‚ä¢ Filter.Eventually (fun x => LE.le (NNNorm.nnnorm x) 1) l","decl":"omit [StarOrderedRing A] in\nlemma eventually_nnnorm {l : Filter A} (hl : l.IsIncreasingApproximateUnit) :\n    ‚àÄ·∂† x in l, ‚Äñx‚Äñ‚Çä ‚â§ 1 :=\n  hl.eventually_norm\n\n"}
{"name":"Filter.IsIncreasingApproximateUnit.eventually_isSelfAdjoint","module":"Mathlib.Analysis.CStarAlgebra.ApproximateUnit","initialProofState":"A : Type u_1\ninst‚úù¬≤ : NonUnitalCStarAlgebra A\ninst‚úù¬π : PartialOrder A\ninst‚úù : StarOrderedRing A\nl : Filter A\nhl : l.IsIncreasingApproximateUnit\n‚ä¢ Filter.Eventually (fun x => IsSelfAdjoint x) l","decl":"lemma eventually_isSelfAdjoint {l : Filter A} (hl : l.IsIncreasingApproximateUnit) :\n    ‚àÄ·∂† x in l, IsSelfAdjoint x :=\n  hl.eventually_nonneg.mp <| .of_forall fun _ ‚Ü¶ IsSelfAdjoint.of_nonneg\n\n"}
{"name":"Filter.IsIncreasingApproximateUnit.eventually_star_eq","module":"Mathlib.Analysis.CStarAlgebra.ApproximateUnit","initialProofState":"A : Type u_1\ninst‚úù¬≤ : NonUnitalCStarAlgebra A\ninst‚úù¬π : PartialOrder A\ninst‚úù : StarOrderedRing A\nl : Filter A\nhl : l.IsIncreasingApproximateUnit\n‚ä¢ Filter.Eventually (fun x => Eq (Star.star x) x) l","decl":"lemma eventually_star_eq {l : Filter A} (hl : l.IsIncreasingApproximateUnit) :\n    ‚àÄ·∂† x in l, star x = x :=\n  hl.eventually_isSelfAdjoint.mp <| .of_forall fun _ ‚Ü¶ IsSelfAdjoint.star_eq\n\n"}
{"name":"CStarAlgebra.tendsto_mul_right_of_forall_nonneg_tendsto","module":"Mathlib.Analysis.CStarAlgebra.ApproximateUnit","initialProofState":"A : Type u_1\ninst‚úù¬≤ : NonUnitalCStarAlgebra A\ninst‚úù¬π : PartialOrder A\ninst‚úù : StarOrderedRing A\nl : Filter A\nh : ‚àÄ (m : A), LE.le 0 m ‚Üí LT.lt (Norm.norm m) 1 ‚Üí Filter.Tendsto (fun x => HMul.hMul x m) l (nhds m)\nm : A\n‚ä¢ Filter.Tendsto (fun x => HMul.hMul x m) l (nhds m)","decl":"open Submodule in\n/-- To show that `l` is a one-sided approximate unit for `A`, it suffices to verify it only for\n`m : A` with `0 ‚â§ m` and `‚Äñm‚Äñ < 1`. -/\nlemma tendsto_mul_right_of_forall_nonneg_tendsto {l : Filter A}\n    (h : ‚àÄ m, 0 ‚â§ m ‚Üí ‚Äñm‚Äñ < 1 ‚Üí Tendsto (¬∑ * m) l (ùìù m)) (m : A) :\n    Tendsto (¬∑ * m) l (ùìù m) := by\n  obtain ‚ü®n, c, x, rfl‚ü© := mem_span_set'.mp <| by\n    show m ‚àà span ‚ÑÇ ({x | 0 ‚â§ x} ‚à© ball 0 1)\n    simp [span_nonneg_inter_unitBall]\n  simp_rw [Finset.mul_sum]\n  refine tendsto_finset_sum _ fun i _ ‚Ü¶ ?_\n  simp_rw [mul_smul_comm]\n  exact tendsto_const_nhds.smul <| h (x i) (x i).2.1 <| by simpa using (x i).2.2\n\n"}
{"name":"CStarAlgebra.tendsto_mul_left_iff_tendsto_mul_right","module":"Mathlib.Analysis.CStarAlgebra.ApproximateUnit","initialProofState":"A : Type u_1\ninst‚úù : NonUnitalCStarAlgebra A\nl : Filter A\nhl : Filter.Eventually (fun x => IsSelfAdjoint x) l\n‚ä¢ Iff (‚àÄ (m : A), Filter.Tendsto (fun x => HMul.hMul m x) l (nhds m)) (‚àÄ (m : A), Filter.Tendsto (fun x => HMul.hMul x m) l (nhds m))","decl":"omit [PartialOrder A] in\n/-- Multiplication on the left by `m` tends to `ùìù m` if and only if multiplication on the right\ndoes, provided the elements are eventually selfadjoint along the filter `l`. -/\nlemma tendsto_mul_left_iff_tendsto_mul_right {l : Filter A} (hl : ‚àÄ·∂† x in l, IsSelfAdjoint x) :\n    (‚àÄ m, Tendsto (m * ¬∑) l (ùìù m)) ‚Üî (‚àÄ m, Tendsto (¬∑ * m) l (ùìù m)) := by\n  refine ‚ü®fun h m ‚Ü¶ ?_, fun h m ‚Ü¶ ?_‚ü©\n  all_goals\n    apply (star_star m ‚ñ∏ (continuous_star.tendsto _ |>.comp <| h (star m))).congr'\n    filter_upwards [hl] with x hx\n    simp [hx.star_eq]\n\n"}
{"name":"CStarAlgebra.isBasis_nonneg_sections","module":"Mathlib.Analysis.CStarAlgebra.ApproximateUnit","initialProofState":"A : Type u_1\ninst‚úù¬≤ : NonUnitalCStarAlgebra A\ninst‚úù¬π : PartialOrder A\ninst‚úù : StarOrderedRing A\n‚ä¢ Filter.IsBasis (fun x => And (LE.le 0 x) (LT.lt (Norm.norm x) 1)) fun x => setOf fun x_1 => LE.le x x_1","decl":"/-- The sections of positive strict contractions form a filter basis. -/\nlemma isBasis_nonneg_sections :\n    IsBasis (fun x : A ‚Ü¶ 0 ‚â§ x ‚àß ‚Äñx‚Äñ < 1) ({x | ¬∑ ‚â§ x}) where\n  nonempty := ‚ü®0, by simp‚ü©\n  inter {x y} hx hy := by\n    peel directedOn_nonneg_ball x (by simpa) y (by simpa) with z hz\n    exact ‚ü®by simpa using hz.1, fun a ha ‚Ü¶ ‚ü®hz.2.1.trans ha, hz.2.2.trans ha‚ü©‚ü©\n\n"}
{"name":"CStarAlgebra.hasBasis_approximateUnit","module":"Mathlib.Analysis.CStarAlgebra.ApproximateUnit","initialProofState":"A : Type u_1\ninst‚úù¬≤ : NonUnitalCStarAlgebra A\ninst‚úù¬π : PartialOrder A\ninst‚úù : StarOrderedRing A\n‚ä¢ (CStarAlgebra.approximateUnit A).HasBasis (fun x => And (LE.le 0 x) (LT.lt (Norm.norm x) 1)) fun x => Inter.inter (setOf fun x_1 => LE.le x x_1) (Metric.closedBall 0 1)","decl":"/-- The canonical approximate unit in a C‚ãÜ-algebra has a basis of sets\n`{x | a ‚â§ x} ‚à© closedBall 0 1` for `0 ‚â§ a`. -/\nlemma hasBasis_approximateUnit :\n    (approximateUnit A).HasBasis (fun x : A ‚Ü¶ 0 ‚â§ x ‚àß ‚Äñx‚Äñ < 1) ({x | ¬∑ ‚â§ x} ‚à© closedBall 0 1) :=\n  isBasis_nonneg_sections A |>.hasBasis.inf_principal (closedBall 0 1)\n\n"}
{"name":"CStarAlgebra.nnnorm_sub_mul_self_le","module":"Mathlib.Analysis.CStarAlgebra.ApproximateUnit","initialProofState":"A : Type u_2\ninst‚úù¬≤ : CStarAlgebra A\ninst‚úù¬π : PartialOrder A\ninst‚úù : StarOrderedRing A\nx y z : A\nhx‚ÇÄ : LE.le 0 x\nhy : Membership.mem (Set.Icc x 1) y\nc : NNReal\nh : LE.le (NNNorm.nnnorm (HMul.hMul (HMul.hMul (Star.star z) (HSub.hSub 1 x)) z)) (HPow.hPow c 2)\n‚ä¢ LE.le (NNNorm.nnnorm (HSub.hSub z (HMul.hMul y z))) c","decl":"/-- This is a common reasoning sequence in C‚ãÜ-algebra theory. If `0 ‚â§ x ‚â§ y ‚â§ 1`, then the norm of\n`z - y * z` is controlled by the norm of `star z * (1 - x) * z`, which is advantageous because the\nlatter is nonnegative. This is a key step in establishing the existence of an increasing approximate\nunit in general C‚ãÜ-algebras. -/\nlemma nnnorm_sub_mul_self_le {A : Type*} [CStarAlgebra A] [PartialOrder A] [StarOrderedRing A]\n    {x y : A} (z : A) (hx‚ÇÄ : 0 ‚â§ x) (hy : y ‚àà Set.Icc x 1) {c : ‚Ñù‚â•0}\n    (h : ‚Äñstar z * (1 - x) * z‚Äñ‚Çä ‚â§ c ^ 2) :\n    ‚Äñz - y * z‚Äñ‚Çä ‚â§ c := by\n  nth_rw 1 [‚Üê one_mul z]\n  rw [‚Üê sqrt_sq c, le_sqrt_iff_sq_le, ‚Üê sub_mul, sq, ‚Üê CStarRing.nnnorm_star_mul_self]\n  simp only [star_mul, star_sub, star_one]\n  have hy‚ÇÄ : y ‚àà Set.Icc 0 1 := ‚ü®hx‚ÇÄ.trans hy.1, hy.2‚ü©\n  have hy' : 1 - y ‚àà Set.Icc 0 1 := Set.sub_mem_Icc_zero_iff_right.mpr hy‚ÇÄ\n  rw [hy‚ÇÄ.1.star_eq, ‚Üê mul_assoc, mul_assoc (star _), ‚Üê sq]\n  refine nnnorm_le_nnnorm_of_nonneg_of_le (conjugate_nonneg (pow_nonneg hy'.1 2) _) ?_ |>.trans h\n  refine conjugate_le_conjugate ?_ _\n  trans (1 - y)\n  ¬∑ simpa using pow_antitone hy'.1 hy'.2 one_le_two\n  ¬∑ gcongr\n    exact hy.1\n\n"}
{"name":"CStarAlgebra.norm_sub_mul_self_le","module":"Mathlib.Analysis.CStarAlgebra.ApproximateUnit","initialProofState":"A : Type u_2\ninst‚úù¬≤ : CStarAlgebra A\ninst‚úù¬π : PartialOrder A\ninst‚úù : StarOrderedRing A\nx y z : A\nhx‚ÇÄ : LE.le 0 x\nhy : Membership.mem (Set.Icc x 1) y\nc : Real\nhc : LE.le 0 c\nh : LE.le (Norm.norm (HMul.hMul (HMul.hMul (Star.star z) (HSub.hSub 1 x)) z)) (HPow.hPow c 2)\n‚ä¢ LE.le (Norm.norm (HSub.hSub z (HMul.hMul y z))) c","decl":"/-- A variant of `nnnorm_sub_mul_self_le` which uses `‚Äñ¬∑‚Äñ` instead of `‚Äñ¬∑‚Äñ‚Çä`. -/\nlemma norm_sub_mul_self_le {A : Type*} [CStarAlgebra A] [PartialOrder A] [StarOrderedRing A]\n    {x y : A} (z : A) (hx‚ÇÄ : 0 ‚â§ x) (hy : y ‚àà Set.Icc x 1)\n    {c : ‚Ñù} (hc : 0 ‚â§ c) (h : ‚Äñstar z * (1 - x) * z‚Äñ ‚â§ c ^ 2) :\n    ‚Äñz - y * z‚Äñ ‚â§ c :=\n  nnnorm_sub_mul_self_le z hx‚ÇÄ hy h (c := ‚ü®c, hc‚ü©)\n\n"}
{"name":"CStarAlgebra.norm_sub_mul_self_le_of_inr","module":"Mathlib.Analysis.CStarAlgebra.ApproximateUnit","initialProofState":"A : Type u_1\ninst‚úù¬≤ : NonUnitalCStarAlgebra A\ninst‚úù¬π : PartialOrder A\ninst‚úù : StarOrderedRing A\nx y z : A\nhx‚ÇÄ : LE.le 0 x\nhxy : LE.le x y\nhy‚ÇÅ : LE.le (Norm.norm y) 1\nc : Real\nhc : LE.le 0 c\nh : LE.le (Norm.norm (HMul.hMul (HMul.hMul (Star.star ‚Üëz) (HSub.hSub 1 ‚Üëx)) ‚Üëz)) (HPow.hPow c 2)\n‚ä¢ LE.le (Norm.norm (HSub.hSub z (HMul.hMul y z))) c","decl":"variable {A} in\n/-- A variant of `norm_sub_mul_self_le` for non-unital algebras that passes to the unitization. -/\nlemma norm_sub_mul_self_le_of_inr {x y : A} (z : A) (hx‚ÇÄ : 0 ‚â§ x) (hxy : x ‚â§ y) (hy‚ÇÅ : ‚Äñy‚Äñ ‚â§ 1)\n    {c : ‚Ñù} (hc : 0 ‚â§ c) (h : ‚Äñstar (z : A‚Å∫¬π) * (1 - x) * z‚Äñ ‚â§ c ^ 2) :\n    ‚Äñz - y * z‚Äñ ‚â§ c := by\n  rw [‚Üê norm_inr (ùïú := ‚ÑÇ), inr_sub, inr_mul]\n  refine norm_sub_mul_self_le _ ?_ ?_ hc h\n  ¬∑ rwa [inr_nonneg_iff]\n  ¬∑ have hy := hx‚ÇÄ.trans hxy\n    rw [Set.mem_Icc, inr_le_iff _ _ hx‚ÇÄ.isSelfAdjoint hy.isSelfAdjoint,\n      ‚Üê norm_le_one_iff_of_nonneg _, norm_inr]\n    exact ‚ü®hxy, hy‚ÇÅ‚ü©\n\n"}
{"name":"CStarAlgebra.increasingApproximateUnit","module":"Mathlib.Analysis.CStarAlgebra.ApproximateUnit","initialProofState":"A : Type u_1\ninst‚úù¬≤ : NonUnitalCStarAlgebra A\ninst‚úù¬π : PartialOrder A\ninst‚úù : StarOrderedRing A\n‚ä¢ (CStarAlgebra.approximateUnit A).IsIncreasingApproximateUnit","decl":"/-- The filter `CStarAlgebra.approximateUnit` generated by the sections\n`{x | a ‚â§ x} ‚à© closedBall 0 1` for `0 ‚â§ a` forms an increasing approximate unit. -/\nlemma increasingApproximateUnit :\n    IsIncreasingApproximateUnit (approximateUnit A) where\n  tendsto_mul_left := by\n    rw [tendsto_mul_left_iff_tendsto_mul_right]\n    ¬∑ exact tendsto_mul_right_approximateUnit\n    ¬∑ rw [(hasBasis_approximateUnit A).eventually_iff]\n      peel (hasBasis_approximateUnit A).ex_mem with x hx\n      exact ‚ü®hx, fun y hy ‚Ü¶ (hx.1.trans hy.1).isSelfAdjoint‚ü©\n  tendsto_mul_right := tendsto_mul_right_approximateUnit\n  eventually_nonneg := .filter_mono inf_le_left <|\n    (isBasis_nonneg_sections A).hasBasis.eventually_iff.mpr ‚ü®0, by simp‚ü©\n  eventually_norm := .filter_mono inf_le_right <| by simp\n  neBot := hasBasis_approximateUnit A |>.neBot_iff.mpr\n    fun hx ‚Ü¶ ‚ü®_, ‚ü®le_rfl, by simpa using hx.2.le‚ü©‚ü©\n\n"}
