{"name":"PartitionOfUnity.sum_le_one'","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u_1\nX : Type u_2\ninstâœ : TopologicalSpace X\ns : optParam (Set X) Set.univ\nself : PartitionOfUnity Î¹ X s\nx : X\nâŠ¢ LE.le (finsum fun i => (self.toFun i) x) 1","decl":"/-- A continuous partition of unity on a set `s : Set X` is a collection of continuous functions\n`f i` such that\n\n* the supports of `f i` form a locally finite family of sets, i.e., for every point `x : X` there\n  exists a neighborhood `U âˆ‹ x` such that all but finitely many functions `f i` are zero on `U`;\n* the functions `f i` are nonnegative;\n* the sum `âˆ‘á¶  i, f i x` is equal to one for every `x âˆˆ s` and is less than or equal to one\n  otherwise.\n\nIf `X` is a normal paracompact space, then `PartitionOfUnity.exists_isSubordinate` guarantees\nthat for every open covering `U : Set (Set X)` of `s` there exists a partition of unity that is\nsubordinate to `U`.\n-/\nstructure PartitionOfUnity (Î¹ X : Type*) [TopologicalSpace X] (s : Set X := univ) where\n  /-- The collection of continuous functions underlying this partition of unity -/\n  toFun : Î¹ â†’ C(X, â„)\n  /-- the supports of the underlying functions are a locally finite family of sets -/\n  locallyFinite' : LocallyFinite fun i => support (toFun i)\n  /-- the functions are non-negative -/\n  nonneg' : 0 â‰¤ toFun\n  /-- the functions sum up to one on `s` -/\n  sum_eq_one' : âˆ€ x âˆˆ s, âˆ‘á¶  i, toFun i x = 1\n  /-- the functions sum up to at most one, globally -/\n  sum_le_one' : âˆ€ x, âˆ‘á¶  i, toFun i x â‰¤ 1\n\n"}
{"name":"PartitionOfUnity.nonneg'","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u_1\nX : Type u_2\ninstâœ : TopologicalSpace X\ns : optParam (Set X) Set.univ\nself : PartitionOfUnity Î¹ X s\nâŠ¢ LE.le 0 self.toFun","decl":"/-- A continuous partition of unity on a set `s : Set X` is a collection of continuous functions\n`f i` such that\n\n* the supports of `f i` form a locally finite family of sets, i.e., for every point `x : X` there\n  exists a neighborhood `U âˆ‹ x` such that all but finitely many functions `f i` are zero on `U`;\n* the functions `f i` are nonnegative;\n* the sum `âˆ‘á¶  i, f i x` is equal to one for every `x âˆˆ s` and is less than or equal to one\n  otherwise.\n\nIf `X` is a normal paracompact space, then `PartitionOfUnity.exists_isSubordinate` guarantees\nthat for every open covering `U : Set (Set X)` of `s` there exists a partition of unity that is\nsubordinate to `U`.\n-/\nstructure PartitionOfUnity (Î¹ X : Type*) [TopologicalSpace X] (s : Set X := univ) where\n  /-- The collection of continuous functions underlying this partition of unity -/\n  toFun : Î¹ â†’ C(X, â„)\n  /-- the supports of the underlying functions are a locally finite family of sets -/\n  locallyFinite' : LocallyFinite fun i => support (toFun i)\n  /-- the functions are non-negative -/\n  nonneg' : 0 â‰¤ toFun\n  /-- the functions sum up to one on `s` -/\n  sum_eq_one' : âˆ€ x âˆˆ s, âˆ‘á¶  i, toFun i x = 1\n  /-- the functions sum up to at most one, globally -/\n  sum_le_one' : âˆ€ x, âˆ‘á¶  i, toFun i x â‰¤ 1\n\n"}
{"name":"PartitionOfUnity.locallyFinite'","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u_1\nX : Type u_2\ninstâœ : TopologicalSpace X\ns : optParam (Set X) Set.univ\nself : PartitionOfUnity Î¹ X s\nâŠ¢ LocallyFinite fun i => Function.support â‡‘(self.toFun i)","decl":"/-- A continuous partition of unity on a set `s : Set X` is a collection of continuous functions\n`f i` such that\n\n* the supports of `f i` form a locally finite family of sets, i.e., for every point `x : X` there\n  exists a neighborhood `U âˆ‹ x` such that all but finitely many functions `f i` are zero on `U`;\n* the functions `f i` are nonnegative;\n* the sum `âˆ‘á¶  i, f i x` is equal to one for every `x âˆˆ s` and is less than or equal to one\n  otherwise.\n\nIf `X` is a normal paracompact space, then `PartitionOfUnity.exists_isSubordinate` guarantees\nthat for every open covering `U : Set (Set X)` of `s` there exists a partition of unity that is\nsubordinate to `U`.\n-/\nstructure PartitionOfUnity (Î¹ X : Type*) [TopologicalSpace X] (s : Set X := univ) where\n  /-- The collection of continuous functions underlying this partition of unity -/\n  toFun : Î¹ â†’ C(X, â„)\n  /-- the supports of the underlying functions are a locally finite family of sets -/\n  locallyFinite' : LocallyFinite fun i => support (toFun i)\n  /-- the functions are non-negative -/\n  nonneg' : 0 â‰¤ toFun\n  /-- the functions sum up to one on `s` -/\n  sum_eq_one' : âˆ€ x âˆˆ s, âˆ‘á¶  i, toFun i x = 1\n  /-- the functions sum up to at most one, globally -/\n  sum_le_one' : âˆ€ x, âˆ‘á¶  i, toFun i x â‰¤ 1\n\n"}
{"name":"PartitionOfUnity.sum_eq_one'","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u_1\nX : Type u_2\ninstâœ : TopologicalSpace X\ns : optParam (Set X) Set.univ\nself : PartitionOfUnity Î¹ X s\nx : X\naâœ : Membership.mem s x\nâŠ¢ Eq (finsum fun i => (self.toFun i) x) 1","decl":"/-- A continuous partition of unity on a set `s : Set X` is a collection of continuous functions\n`f i` such that\n\n* the supports of `f i` form a locally finite family of sets, i.e., for every point `x : X` there\n  exists a neighborhood `U âˆ‹ x` such that all but finitely many functions `f i` are zero on `U`;\n* the functions `f i` are nonnegative;\n* the sum `âˆ‘á¶  i, f i x` is equal to one for every `x âˆˆ s` and is less than or equal to one\n  otherwise.\n\nIf `X` is a normal paracompact space, then `PartitionOfUnity.exists_isSubordinate` guarantees\nthat for every open covering `U : Set (Set X)` of `s` there exists a partition of unity that is\nsubordinate to `U`.\n-/\nstructure PartitionOfUnity (Î¹ X : Type*) [TopologicalSpace X] (s : Set X := univ) where\n  /-- The collection of continuous functions underlying this partition of unity -/\n  toFun : Î¹ â†’ C(X, â„)\n  /-- the supports of the underlying functions are a locally finite family of sets -/\n  locallyFinite' : LocallyFinite fun i => support (toFun i)\n  /-- the functions are non-negative -/\n  nonneg' : 0 â‰¤ toFun\n  /-- the functions sum up to one on `s` -/\n  sum_eq_one' : âˆ€ x âˆˆ s, âˆ‘á¶  i, toFun i x = 1\n  /-- the functions sum up to at most one, globally -/\n  sum_le_one' : âˆ€ x, âˆ‘á¶  i, toFun i x â‰¤ 1\n\n"}
{"name":"PartitionOfUnity.mk.sizeOf_spec","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u_1\nX : Type u_2\ninstâœÂ³ : TopologicalSpace X\ns : optParam (Set X) Set.univ\ninstâœÂ² : SizeOf Î¹\ninstâœÂ¹ : SizeOf X\ninstâœ : (a : X) â†’ SizeOf (s a)\ntoFun : Î¹ â†’ ContinuousMap X Real\nlocallyFinite' : LocallyFinite fun i => Function.support â‡‘(toFun i)\nnonneg' : LE.le 0 toFun\nsum_eq_one' : âˆ€ (x : X), Membership.mem s x â†’ Eq (finsum fun i => (toFun i) x) 1\nsum_le_one' : âˆ€ (x : X), LE.le (finsum fun i => (toFun i) x) 1\nâŠ¢ Eq (SizeOf.sizeOf { toFun := toFun, locallyFinite' := locallyFinite', nonneg' := nonneg', sum_eq_one' := sum_eq_one', sum_le_one' := sum_le_one' }) 1","decl":"/-- A continuous partition of unity on a set `s : Set X` is a collection of continuous functions\n`f i` such that\n\n* the supports of `f i` form a locally finite family of sets, i.e., for every point `x : X` there\n  exists a neighborhood `U âˆ‹ x` such that all but finitely many functions `f i` are zero on `U`;\n* the functions `f i` are nonnegative;\n* the sum `âˆ‘á¶  i, f i x` is equal to one for every `x âˆˆ s` and is less than or equal to one\n  otherwise.\n\nIf `X` is a normal paracompact space, then `PartitionOfUnity.exists_isSubordinate` guarantees\nthat for every open covering `U : Set (Set X)` of `s` there exists a partition of unity that is\nsubordinate to `U`.\n-/\nstructure PartitionOfUnity (Î¹ X : Type*) [TopologicalSpace X] (s : Set X := univ) where\n  /-- The collection of continuous functions underlying this partition of unity -/\n  toFun : Î¹ â†’ C(X, â„)\n  /-- the supports of the underlying functions are a locally finite family of sets -/\n  locallyFinite' : LocallyFinite fun i => support (toFun i)\n  /-- the functions are non-negative -/\n  nonneg' : 0 â‰¤ toFun\n  /-- the functions sum up to one on `s` -/\n  sum_eq_one' : âˆ€ x âˆˆ s, âˆ‘á¶  i, toFun i x = 1\n  /-- the functions sum up to at most one, globally -/\n  sum_le_one' : âˆ€ x, âˆ‘á¶  i, toFun i x â‰¤ 1\n\n"}
{"name":"PartitionOfUnity.mk.inj","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u_1\nX : Type u_2\ninstâœ : TopologicalSpace X\ns : Set X\ntoFunâœ : Î¹ â†’ ContinuousMap X Real\nlocallyFinite'âœ : LocallyFinite fun i => Function.support â‡‘(toFunâœ i)\nnonneg'âœ : LE.le 0 toFunâœ\nsum_eq_one'âœ : âˆ€ (x : X), Membership.mem s x â†’ Eq (finsum fun i => (toFunâœ i) x) 1\nsum_le_one'âœ : âˆ€ (x : X), LE.le (finsum fun i => (toFunâœ i) x) 1\ntoFun : Î¹ â†’ ContinuousMap X Real\nlocallyFinite' : LocallyFinite fun i => Function.support â‡‘(toFun i)\nnonneg' : LE.le 0 toFun\nsum_eq_one' : âˆ€ (x : X), Membership.mem s x â†’ Eq (finsum fun i => (toFun i) x) 1\nsum_le_one' : âˆ€ (x : X), LE.le (finsum fun i => (toFun i) x) 1\nxâœ : Eq { toFun := toFunâœ, locallyFinite' := locallyFinite'âœ, nonneg' := nonneg'âœ, sum_eq_one' := sum_eq_one'âœ, sum_le_one' := sum_le_one'âœ } { toFun := toFun, locallyFinite' := locallyFinite', nonneg' := nonneg', sum_eq_one' := sum_eq_one', sum_le_one' := sum_le_one' }\nâŠ¢ Eq toFunâœ toFun","decl":"/-- A continuous partition of unity on a set `s : Set X` is a collection of continuous functions\n`f i` such that\n\n* the supports of `f i` form a locally finite family of sets, i.e., for every point `x : X` there\n  exists a neighborhood `U âˆ‹ x` such that all but finitely many functions `f i` are zero on `U`;\n* the functions `f i` are nonnegative;\n* the sum `âˆ‘á¶  i, f i x` is equal to one for every `x âˆˆ s` and is less than or equal to one\n  otherwise.\n\nIf `X` is a normal paracompact space, then `PartitionOfUnity.exists_isSubordinate` guarantees\nthat for every open covering `U : Set (Set X)` of `s` there exists a partition of unity that is\nsubordinate to `U`.\n-/\nstructure PartitionOfUnity (Î¹ X : Type*) [TopologicalSpace X] (s : Set X := univ) where\n  /-- The collection of continuous functions underlying this partition of unity -/\n  toFun : Î¹ â†’ C(X, â„)\n  /-- the supports of the underlying functions are a locally finite family of sets -/\n  locallyFinite' : LocallyFinite fun i => support (toFun i)\n  /-- the functions are non-negative -/\n  nonneg' : 0 â‰¤ toFun\n  /-- the functions sum up to one on `s` -/\n  sum_eq_one' : âˆ€ x âˆˆ s, âˆ‘á¶  i, toFun i x = 1\n  /-- the functions sum up to at most one, globally -/\n  sum_le_one' : âˆ€ x, âˆ‘á¶  i, toFun i x â‰¤ 1\n\n"}
{"name":"PartitionOfUnity.mk.injEq","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u_1\nX : Type u_2\ninstâœ : TopologicalSpace X\ns : Set X\ntoFunâœ : Î¹ â†’ ContinuousMap X Real\nlocallyFinite'âœ : LocallyFinite fun i => Function.support â‡‘(toFunâœ i)\nnonneg'âœ : LE.le 0 toFunâœ\nsum_eq_one'âœ : âˆ€ (x : X), Membership.mem s x â†’ Eq (finsum fun i => (toFunâœ i) x) 1\nsum_le_one'âœ : âˆ€ (x : X), LE.le (finsum fun i => (toFunâœ i) x) 1\ntoFun : Î¹ â†’ ContinuousMap X Real\nlocallyFinite' : LocallyFinite fun i => Function.support â‡‘(toFun i)\nnonneg' : LE.le 0 toFun\nsum_eq_one' : âˆ€ (x : X), Membership.mem s x â†’ Eq (finsum fun i => (toFun i) x) 1\nsum_le_one' : âˆ€ (x : X), LE.le (finsum fun i => (toFun i) x) 1\nâŠ¢ Eq (Eq { toFun := toFunâœ, locallyFinite' := locallyFinite'âœ, nonneg' := nonneg'âœ, sum_eq_one' := sum_eq_one'âœ, sum_le_one' := sum_le_one'âœ } { toFun := toFun, locallyFinite' := locallyFinite', nonneg' := nonneg', sum_eq_one' := sum_eq_one', sum_le_one' := sum_le_one' }) (Eq toFunâœ toFun)","decl":"/-- A continuous partition of unity on a set `s : Set X` is a collection of continuous functions\n`f i` such that\n\n* the supports of `f i` form a locally finite family of sets, i.e., for every point `x : X` there\n  exists a neighborhood `U âˆ‹ x` such that all but finitely many functions `f i` are zero on `U`;\n* the functions `f i` are nonnegative;\n* the sum `âˆ‘á¶  i, f i x` is equal to one for every `x âˆˆ s` and is less than or equal to one\n  otherwise.\n\nIf `X` is a normal paracompact space, then `PartitionOfUnity.exists_isSubordinate` guarantees\nthat for every open covering `U : Set (Set X)` of `s` there exists a partition of unity that is\nsubordinate to `U`.\n-/\nstructure PartitionOfUnity (Î¹ X : Type*) [TopologicalSpace X] (s : Set X := univ) where\n  /-- The collection of continuous functions underlying this partition of unity -/\n  toFun : Î¹ â†’ C(X, â„)\n  /-- the supports of the underlying functions are a locally finite family of sets -/\n  locallyFinite' : LocallyFinite fun i => support (toFun i)\n  /-- the functions are non-negative -/\n  nonneg' : 0 â‰¤ toFun\n  /-- the functions sum up to one on `s` -/\n  sum_eq_one' : âˆ€ x âˆˆ s, âˆ‘á¶  i, toFun i x = 1\n  /-- the functions sum up to at most one, globally -/\n  sum_le_one' : âˆ€ x, âˆ‘á¶  i, toFun i x â‰¤ 1\n\n"}
{"name":"BumpCovering.eventuallyEq_one'","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u_1\nX : Type u_2\ninstâœ : TopologicalSpace X\ns : optParam (Set X) Set.univ\nself : BumpCovering Î¹ X s\nx : X\naâœ : Membership.mem s x\nâŠ¢ Exists fun i => (nhds x).EventuallyEq (â‡‘(self.toFun i)) 1","decl":"/-- A `BumpCovering Î¹ X s` is an indexed family of functions `f i`, `i : Î¹`, such that\n\n* the supports of `f i` form a locally finite family of sets, i.e., for every point `x : X` there\n  exists a neighborhood `U âˆ‹ x` such that all but finitely many functions `f i` are zero on `U`;\n* for all `i`, `x` we have `0 â‰¤ f i x â‰¤ 1`;\n* each point `x âˆˆ s` belongs to the interior of `{x | f i x = 1}` for some `i`.\n\nOne of the main use cases for a `BumpCovering` is to define a `PartitionOfUnity`, see\n`BumpCovering.toPartitionOfUnity`, but some proofs can directly use a `BumpCovering` instead of\na `PartitionOfUnity`.\n\nIf `X` is a normal paracompact space, then `BumpCovering.exists_isSubordinate` guarantees that for\nevery open covering `U : Set (Set X)` of `s` there exists a `BumpCovering` of `s` that is\nsubordinate to `U`.\n-/\nstructure BumpCovering (Î¹ X : Type*) [TopologicalSpace X] (s : Set X := univ) where\n  /-- The collections of continuous functions underlying this bump covering -/\n  toFun : Î¹ â†’ C(X, â„)\n  /-- the supports of the underlying functions are a locally finite family of sets -/\n  locallyFinite' : LocallyFinite fun i => support (toFun i)\n  /-- the functions are non-negative -/\n  nonneg' : 0 â‰¤ toFun\n  /-- the functions are each at most one -/\n  le_one' : toFun â‰¤ 1\n  /-- Each point `x âˆˆ s` belongs to the interior of `{x | f i x = 1}` for some `i`. -/\n  eventuallyEq_one' : âˆ€ x âˆˆ s, âˆƒ i, toFun i =á¶ [ð“ x] 1\n\n"}
{"name":"BumpCovering.mk.sizeOf_spec","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u_1\nX : Type u_2\ninstâœÂ³ : TopologicalSpace X\ns : optParam (Set X) Set.univ\ninstâœÂ² : SizeOf Î¹\ninstâœÂ¹ : SizeOf X\ninstâœ : (a : X) â†’ SizeOf (s a)\ntoFun : Î¹ â†’ ContinuousMap X Real\nlocallyFinite' : LocallyFinite fun i => Function.support â‡‘(toFun i)\nnonneg' : LE.le 0 toFun\nle_one' : LE.le toFun 1\neventuallyEq_one' : âˆ€ (x : X), Membership.mem s x â†’ Exists fun i => (nhds x).EventuallyEq (â‡‘(toFun i)) 1\nâŠ¢ Eq (SizeOf.sizeOf { toFun := toFun, locallyFinite' := locallyFinite', nonneg' := nonneg', le_one' := le_one', eventuallyEq_one' := eventuallyEq_one' }) 1","decl":"/-- A `BumpCovering Î¹ X s` is an indexed family of functions `f i`, `i : Î¹`, such that\n\n* the supports of `f i` form a locally finite family of sets, i.e., for every point `x : X` there\n  exists a neighborhood `U âˆ‹ x` such that all but finitely many functions `f i` are zero on `U`;\n* for all `i`, `x` we have `0 â‰¤ f i x â‰¤ 1`;\n* each point `x âˆˆ s` belongs to the interior of `{x | f i x = 1}` for some `i`.\n\nOne of the main use cases for a `BumpCovering` is to define a `PartitionOfUnity`, see\n`BumpCovering.toPartitionOfUnity`, but some proofs can directly use a `BumpCovering` instead of\na `PartitionOfUnity`.\n\nIf `X` is a normal paracompact space, then `BumpCovering.exists_isSubordinate` guarantees that for\nevery open covering `U : Set (Set X)` of `s` there exists a `BumpCovering` of `s` that is\nsubordinate to `U`.\n-/\nstructure BumpCovering (Î¹ X : Type*) [TopologicalSpace X] (s : Set X := univ) where\n  /-- The collections of continuous functions underlying this bump covering -/\n  toFun : Î¹ â†’ C(X, â„)\n  /-- the supports of the underlying functions are a locally finite family of sets -/\n  locallyFinite' : LocallyFinite fun i => support (toFun i)\n  /-- the functions are non-negative -/\n  nonneg' : 0 â‰¤ toFun\n  /-- the functions are each at most one -/\n  le_one' : toFun â‰¤ 1\n  /-- Each point `x âˆˆ s` belongs to the interior of `{x | f i x = 1}` for some `i`. -/\n  eventuallyEq_one' : âˆ€ x âˆˆ s, âˆƒ i, toFun i =á¶ [ð“ x] 1\n\n"}
{"name":"BumpCovering.le_one'","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u_1\nX : Type u_2\ninstâœ : TopologicalSpace X\ns : optParam (Set X) Set.univ\nself : BumpCovering Î¹ X s\nâŠ¢ LE.le self.toFun 1","decl":"/-- A `BumpCovering Î¹ X s` is an indexed family of functions `f i`, `i : Î¹`, such that\n\n* the supports of `f i` form a locally finite family of sets, i.e., for every point `x : X` there\n  exists a neighborhood `U âˆ‹ x` such that all but finitely many functions `f i` are zero on `U`;\n* for all `i`, `x` we have `0 â‰¤ f i x â‰¤ 1`;\n* each point `x âˆˆ s` belongs to the interior of `{x | f i x = 1}` for some `i`.\n\nOne of the main use cases for a `BumpCovering` is to define a `PartitionOfUnity`, see\n`BumpCovering.toPartitionOfUnity`, but some proofs can directly use a `BumpCovering` instead of\na `PartitionOfUnity`.\n\nIf `X` is a normal paracompact space, then `BumpCovering.exists_isSubordinate` guarantees that for\nevery open covering `U : Set (Set X)` of `s` there exists a `BumpCovering` of `s` that is\nsubordinate to `U`.\n-/\nstructure BumpCovering (Î¹ X : Type*) [TopologicalSpace X] (s : Set X := univ) where\n  /-- The collections of continuous functions underlying this bump covering -/\n  toFun : Î¹ â†’ C(X, â„)\n  /-- the supports of the underlying functions are a locally finite family of sets -/\n  locallyFinite' : LocallyFinite fun i => support (toFun i)\n  /-- the functions are non-negative -/\n  nonneg' : 0 â‰¤ toFun\n  /-- the functions are each at most one -/\n  le_one' : toFun â‰¤ 1\n  /-- Each point `x âˆˆ s` belongs to the interior of `{x | f i x = 1}` for some `i`. -/\n  eventuallyEq_one' : âˆ€ x âˆˆ s, âˆƒ i, toFun i =á¶ [ð“ x] 1\n\n"}
{"name":"BumpCovering.mk.injEq","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u_1\nX : Type u_2\ninstâœ : TopologicalSpace X\ns : Set X\ntoFunâœ : Î¹ â†’ ContinuousMap X Real\nlocallyFinite'âœ : LocallyFinite fun i => Function.support â‡‘(toFunâœ i)\nnonneg'âœ : LE.le 0 toFunâœ\nle_one'âœ : LE.le toFunâœ 1\neventuallyEq_one'âœ : âˆ€ (x : X), Membership.mem s x â†’ Exists fun i => (nhds x).EventuallyEq (â‡‘(toFunâœ i)) 1\ntoFun : Î¹ â†’ ContinuousMap X Real\nlocallyFinite' : LocallyFinite fun i => Function.support â‡‘(toFun i)\nnonneg' : LE.le 0 toFun\nle_one' : LE.le toFun 1\neventuallyEq_one' : âˆ€ (x : X), Membership.mem s x â†’ Exists fun i => (nhds x).EventuallyEq (â‡‘(toFun i)) 1\nâŠ¢ Eq (Eq { toFun := toFunâœ, locallyFinite' := locallyFinite'âœ, nonneg' := nonneg'âœ, le_one' := le_one'âœ, eventuallyEq_one' := eventuallyEq_one'âœ } { toFun := toFun, locallyFinite' := locallyFinite', nonneg' := nonneg', le_one' := le_one', eventuallyEq_one' := eventuallyEq_one' }) (Eq toFunâœ toFun)","decl":"/-- A `BumpCovering Î¹ X s` is an indexed family of functions `f i`, `i : Î¹`, such that\n\n* the supports of `f i` form a locally finite family of sets, i.e., for every point `x : X` there\n  exists a neighborhood `U âˆ‹ x` such that all but finitely many functions `f i` are zero on `U`;\n* for all `i`, `x` we have `0 â‰¤ f i x â‰¤ 1`;\n* each point `x âˆˆ s` belongs to the interior of `{x | f i x = 1}` for some `i`.\n\nOne of the main use cases for a `BumpCovering` is to define a `PartitionOfUnity`, see\n`BumpCovering.toPartitionOfUnity`, but some proofs can directly use a `BumpCovering` instead of\na `PartitionOfUnity`.\n\nIf `X` is a normal paracompact space, then `BumpCovering.exists_isSubordinate` guarantees that for\nevery open covering `U : Set (Set X)` of `s` there exists a `BumpCovering` of `s` that is\nsubordinate to `U`.\n-/\nstructure BumpCovering (Î¹ X : Type*) [TopologicalSpace X] (s : Set X := univ) where\n  /-- The collections of continuous functions underlying this bump covering -/\n  toFun : Î¹ â†’ C(X, â„)\n  /-- the supports of the underlying functions are a locally finite family of sets -/\n  locallyFinite' : LocallyFinite fun i => support (toFun i)\n  /-- the functions are non-negative -/\n  nonneg' : 0 â‰¤ toFun\n  /-- the functions are each at most one -/\n  le_one' : toFun â‰¤ 1\n  /-- Each point `x âˆˆ s` belongs to the interior of `{x | f i x = 1}` for some `i`. -/\n  eventuallyEq_one' : âˆ€ x âˆˆ s, âˆƒ i, toFun i =á¶ [ð“ x] 1\n\n"}
{"name":"BumpCovering.nonneg'","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u_1\nX : Type u_2\ninstâœ : TopologicalSpace X\ns : optParam (Set X) Set.univ\nself : BumpCovering Î¹ X s\nâŠ¢ LE.le 0 self.toFun","decl":"/-- A `BumpCovering Î¹ X s` is an indexed family of functions `f i`, `i : Î¹`, such that\n\n* the supports of `f i` form a locally finite family of sets, i.e., for every point `x : X` there\n  exists a neighborhood `U âˆ‹ x` such that all but finitely many functions `f i` are zero on `U`;\n* for all `i`, `x` we have `0 â‰¤ f i x â‰¤ 1`;\n* each point `x âˆˆ s` belongs to the interior of `{x | f i x = 1}` for some `i`.\n\nOne of the main use cases for a `BumpCovering` is to define a `PartitionOfUnity`, see\n`BumpCovering.toPartitionOfUnity`, but some proofs can directly use a `BumpCovering` instead of\na `PartitionOfUnity`.\n\nIf `X` is a normal paracompact space, then `BumpCovering.exists_isSubordinate` guarantees that for\nevery open covering `U : Set (Set X)` of `s` there exists a `BumpCovering` of `s` that is\nsubordinate to `U`.\n-/\nstructure BumpCovering (Î¹ X : Type*) [TopologicalSpace X] (s : Set X := univ) where\n  /-- The collections of continuous functions underlying this bump covering -/\n  toFun : Î¹ â†’ C(X, â„)\n  /-- the supports of the underlying functions are a locally finite family of sets -/\n  locallyFinite' : LocallyFinite fun i => support (toFun i)\n  /-- the functions are non-negative -/\n  nonneg' : 0 â‰¤ toFun\n  /-- the functions are each at most one -/\n  le_one' : toFun â‰¤ 1\n  /-- Each point `x âˆˆ s` belongs to the interior of `{x | f i x = 1}` for some `i`. -/\n  eventuallyEq_one' : âˆ€ x âˆˆ s, âˆƒ i, toFun i =á¶ [ð“ x] 1\n\n"}
{"name":"BumpCovering.locallyFinite'","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u_1\nX : Type u_2\ninstâœ : TopologicalSpace X\ns : optParam (Set X) Set.univ\nself : BumpCovering Î¹ X s\nâŠ¢ LocallyFinite fun i => Function.support â‡‘(self.toFun i)","decl":"/-- A `BumpCovering Î¹ X s` is an indexed family of functions `f i`, `i : Î¹`, such that\n\n* the supports of `f i` form a locally finite family of sets, i.e., for every point `x : X` there\n  exists a neighborhood `U âˆ‹ x` such that all but finitely many functions `f i` are zero on `U`;\n* for all `i`, `x` we have `0 â‰¤ f i x â‰¤ 1`;\n* each point `x âˆˆ s` belongs to the interior of `{x | f i x = 1}` for some `i`.\n\nOne of the main use cases for a `BumpCovering` is to define a `PartitionOfUnity`, see\n`BumpCovering.toPartitionOfUnity`, but some proofs can directly use a `BumpCovering` instead of\na `PartitionOfUnity`.\n\nIf `X` is a normal paracompact space, then `BumpCovering.exists_isSubordinate` guarantees that for\nevery open covering `U : Set (Set X)` of `s` there exists a `BumpCovering` of `s` that is\nsubordinate to `U`.\n-/\nstructure BumpCovering (Î¹ X : Type*) [TopologicalSpace X] (s : Set X := univ) where\n  /-- The collections of continuous functions underlying this bump covering -/\n  toFun : Î¹ â†’ C(X, â„)\n  /-- the supports of the underlying functions are a locally finite family of sets -/\n  locallyFinite' : LocallyFinite fun i => support (toFun i)\n  /-- the functions are non-negative -/\n  nonneg' : 0 â‰¤ toFun\n  /-- the functions are each at most one -/\n  le_one' : toFun â‰¤ 1\n  /-- Each point `x âˆˆ s` belongs to the interior of `{x | f i x = 1}` for some `i`. -/\n  eventuallyEq_one' : âˆ€ x âˆˆ s, âˆƒ i, toFun i =á¶ [ð“ x] 1\n\n"}
{"name":"BumpCovering.mk.inj","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u_1\nX : Type u_2\ninstâœ : TopologicalSpace X\ns : Set X\ntoFunâœ : Î¹ â†’ ContinuousMap X Real\nlocallyFinite'âœ : LocallyFinite fun i => Function.support â‡‘(toFunâœ i)\nnonneg'âœ : LE.le 0 toFunâœ\nle_one'âœ : LE.le toFunâœ 1\neventuallyEq_one'âœ : âˆ€ (x : X), Membership.mem s x â†’ Exists fun i => (nhds x).EventuallyEq (â‡‘(toFunâœ i)) 1\ntoFun : Î¹ â†’ ContinuousMap X Real\nlocallyFinite' : LocallyFinite fun i => Function.support â‡‘(toFun i)\nnonneg' : LE.le 0 toFun\nle_one' : LE.le toFun 1\neventuallyEq_one' : âˆ€ (x : X), Membership.mem s x â†’ Exists fun i => (nhds x).EventuallyEq (â‡‘(toFun i)) 1\nxâœ : Eq { toFun := toFunâœ, locallyFinite' := locallyFinite'âœ, nonneg' := nonneg'âœ, le_one' := le_one'âœ, eventuallyEq_one' := eventuallyEq_one'âœ } { toFun := toFun, locallyFinite' := locallyFinite', nonneg' := nonneg', le_one' := le_one', eventuallyEq_one' := eventuallyEq_one' }\nâŠ¢ Eq toFunâœ toFun","decl":"/-- A `BumpCovering Î¹ X s` is an indexed family of functions `f i`, `i : Î¹`, such that\n\n* the supports of `f i` form a locally finite family of sets, i.e., for every point `x : X` there\n  exists a neighborhood `U âˆ‹ x` such that all but finitely many functions `f i` are zero on `U`;\n* for all `i`, `x` we have `0 â‰¤ f i x â‰¤ 1`;\n* each point `x âˆˆ s` belongs to the interior of `{x | f i x = 1}` for some `i`.\n\nOne of the main use cases for a `BumpCovering` is to define a `PartitionOfUnity`, see\n`BumpCovering.toPartitionOfUnity`, but some proofs can directly use a `BumpCovering` instead of\na `PartitionOfUnity`.\n\nIf `X` is a normal paracompact space, then `BumpCovering.exists_isSubordinate` guarantees that for\nevery open covering `U : Set (Set X)` of `s` there exists a `BumpCovering` of `s` that is\nsubordinate to `U`.\n-/\nstructure BumpCovering (Î¹ X : Type*) [TopologicalSpace X] (s : Set X := univ) where\n  /-- The collections of continuous functions underlying this bump covering -/\n  toFun : Î¹ â†’ C(X, â„)\n  /-- the supports of the underlying functions are a locally finite family of sets -/\n  locallyFinite' : LocallyFinite fun i => support (toFun i)\n  /-- the functions are non-negative -/\n  nonneg' : 0 â‰¤ toFun\n  /-- the functions are each at most one -/\n  le_one' : toFun â‰¤ 1\n  /-- Each point `x âˆˆ s` belongs to the interior of `{x | f i x = 1}` for some `i`. -/\n  eventuallyEq_one' : âˆ€ x âˆˆ s, âˆƒ i, toFun i =á¶ [ð“ x] 1\n\n"}
{"name":"PartitionOfUnity.locallyFinite","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u\nX : Type v\ninstâœ : TopologicalSpace X\ns : Set X\nf : PartitionOfUnity Î¹ X s\nâŠ¢ LocallyFinite fun i => Function.support â‡‘(f i)","decl":"protected theorem locallyFinite : LocallyFinite fun i => support (f i) :=\n  f.locallyFinite'\n\n"}
{"name":"PartitionOfUnity.locallyFinite_tsupport","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u\nX : Type v\ninstâœ : TopologicalSpace X\ns : Set X\nf : PartitionOfUnity Î¹ X s\nâŠ¢ LocallyFinite fun i => tsupport â‡‘(f i)","decl":"theorem locallyFinite_tsupport : LocallyFinite fun i => tsupport (f i) :=\n  f.locallyFinite.closure\n\n"}
{"name":"PartitionOfUnity.nonneg","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u\nX : Type v\ninstâœ : TopologicalSpace X\ns : Set X\nf : PartitionOfUnity Î¹ X s\ni : Î¹\nx : X\nâŠ¢ LE.le 0 ((f i) x)","decl":"theorem nonneg (i : Î¹) (x : X) : 0 â‰¤ f i x :=\n  f.nonneg' i x\n\n"}
{"name":"PartitionOfUnity.sum_eq_one","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u\nX : Type v\ninstâœ : TopologicalSpace X\ns : Set X\nf : PartitionOfUnity Î¹ X s\nx : X\nhx : Membership.mem s x\nâŠ¢ Eq (finsum fun i => (f i) x) 1","decl":"theorem sum_eq_one {x : X} (hx : x âˆˆ s) : âˆ‘á¶  i, f i x = 1 :=\n  f.sum_eq_one' x hx\n\n"}
{"name":"PartitionOfUnity.exists_pos","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u\nX : Type v\ninstâœ : TopologicalSpace X\ns : Set X\nf : PartitionOfUnity Î¹ X s\nx : X\nhx : Membership.mem s x\nâŠ¢ Exists fun i => LT.lt 0 ((f i) x)","decl":"/-- If `f` is a partition of unity on `s`, then for every `x âˆˆ s` there exists an index `i` such\nthat `0 < f i x`. -/\ntheorem exists_pos {x : X} (hx : x âˆˆ s) : âˆƒ i, 0 < f i x := by\n  have H := f.sum_eq_one hx\n  contrapose! H\n  simpa only [fun i => (H i).antisymm (f.nonneg i x), finsum_zero] using zero_ne_one\n\n"}
{"name":"PartitionOfUnity.sum_le_one","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u\nX : Type v\ninstâœ : TopologicalSpace X\ns : Set X\nf : PartitionOfUnity Î¹ X s\nx : X\nâŠ¢ LE.le (finsum fun i => (f i) x) 1","decl":"theorem sum_le_one (x : X) : âˆ‘á¶  i, f i x â‰¤ 1 :=\n  f.sum_le_one' x\n\n"}
{"name":"PartitionOfUnity.sum_nonneg","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u\nX : Type v\ninstâœ : TopologicalSpace X\ns : Set X\nf : PartitionOfUnity Î¹ X s\nx : X\nâŠ¢ LE.le 0 (finsum fun i => (f i) x)","decl":"theorem sum_nonneg (x : X) : 0 â‰¤ âˆ‘á¶  i, f i x :=\n  finsum_nonneg fun i => f.nonneg i x\n\n"}
{"name":"PartitionOfUnity.le_one","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u\nX : Type v\ninstâœ : TopologicalSpace X\ns : Set X\nf : PartitionOfUnity Î¹ X s\ni : Î¹\nx : X\nâŠ¢ LE.le ((f i) x) 1","decl":"theorem le_one (i : Î¹) (x : X) : f i x â‰¤ 1 :=\n  (single_le_finsum i (f.locallyFinite.point_finite x) fun j => f.nonneg j x).trans (f.sum_le_one x)\n\n"}
{"name":"PartitionOfUnity.mem_finsupport","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u\nX : Type v\ninstâœ : TopologicalSpace X\ns : Set X\nÏ : PartitionOfUnity Î¹ X s\nxâ‚€ : X\ni : Î¹\nâŠ¢ Iff (Membership.mem (Ï.finsupport xâ‚€) i) (Membership.mem (Function.support fun i => (Ï i) xâ‚€) i)","decl":"@[simp]\ntheorem mem_finsupport (xâ‚€ : X) {i} :\n    i âˆˆ Ï.finsupport xâ‚€ â†” i âˆˆ support fun i â†¦ Ï i xâ‚€ := by\n  simp only [finsupport, mem_support, Finite.mem_toFinset, mem_setOf_eq]\n\n"}
{"name":"PartitionOfUnity.coe_finsupport","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u\nX : Type v\ninstâœ : TopologicalSpace X\ns : Set X\nÏ : PartitionOfUnity Î¹ X s\nxâ‚€ : X\nâŠ¢ Eq (â†‘(Ï.finsupport xâ‚€)) (Function.support fun i => (Ï i) xâ‚€)","decl":"@[simp]\ntheorem coe_finsupport (xâ‚€ : X) :\n    (Ï.finsupport xâ‚€ : Set Î¹) = support fun i â†¦ Ï i xâ‚€ := by\n  ext\n  rw [Finset.mem_coe, mem_finsupport]\n\n"}
{"name":"PartitionOfUnity.sum_finsupport","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u\nX : Type v\ninstâœ : TopologicalSpace X\ns : Set X\nÏ : PartitionOfUnity Î¹ X s\nxâ‚€ : X\nhxâ‚€ : Membership.mem s xâ‚€\nâŠ¢ Eq ((Ï.finsupport xâ‚€).sum fun i => (Ï i) xâ‚€) 1","decl":"theorem sum_finsupport (hxâ‚€ : xâ‚€ âˆˆ s) : âˆ‘ i âˆˆ Ï.finsupport xâ‚€, Ï i xâ‚€ = 1 := by\n  rw [â† Ï.sum_eq_one hxâ‚€, finsum_eq_sum_of_support_subset _ (Ï.coe_finsupport xâ‚€).superset]\n\n"}
{"name":"PartitionOfUnity.sum_finsupport'","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u\nX : Type v\ninstâœ : TopologicalSpace X\ns : Set X\nÏ : PartitionOfUnity Î¹ X s\nxâ‚€ : X\nhxâ‚€ : Membership.mem s xâ‚€\nI : Finset Î¹\nhI : HasSubset.Subset (Ï.finsupport xâ‚€) I\nâŠ¢ Eq (I.sum fun i => (Ï i) xâ‚€) 1","decl":"theorem sum_finsupport' (hxâ‚€ : xâ‚€ âˆˆ s) {I : Finset Î¹} (hI : Ï.finsupport xâ‚€ âŠ† I) :\n    âˆ‘ i âˆˆ I, Ï i xâ‚€ = 1 := by\n  classical\n  rw [â† Finset.sum_sdiff hI, Ï.sum_finsupport hxâ‚€]\n  suffices âˆ‘ i âˆˆ I \\ Ï.finsupport xâ‚€, (Ï i) xâ‚€ = âˆ‘ i âˆˆ I \\ Ï.finsupport xâ‚€, 0 by\n    rw [this, add_left_eq_self, Finset.sum_const_zero]\n  apply Finset.sum_congr rfl\n  rintro x hx\n  simp only [Finset.mem_sdiff, Ï.mem_finsupport, mem_support, Classical.not_not] at hx\n  exact hx.2\n\n"}
{"name":"PartitionOfUnity.sum_finsupport_smul_eq_finsum","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u\nX : Type v\ninstâœÂ² : TopologicalSpace X\ns : Set X\nÏ : PartitionOfUnity Î¹ X s\nxâ‚€ : X\nM : Type u_2\ninstâœÂ¹ : AddCommGroup M\ninstâœ : Module Real M\nÏ† : Î¹ â†’ X â†’ M\nâŠ¢ Eq ((Ï.finsupport xâ‚€).sum fun i => HSMul.hSMul ((Ï i) xâ‚€) (Ï† i xâ‚€)) (finsum fun i => HSMul.hSMul ((Ï i) xâ‚€) (Ï† i xâ‚€))","decl":"theorem sum_finsupport_smul_eq_finsum {M : Type*} [AddCommGroup M] [Module â„ M] (Ï† : Î¹ â†’ X â†’ M) :\n    âˆ‘ i âˆˆ Ï.finsupport xâ‚€, Ï i xâ‚€ â€¢ Ï† i xâ‚€ = âˆ‘á¶  i, Ï i xâ‚€ â€¢ Ï† i xâ‚€ := by\n  apply (finsum_eq_sum_of_support_subset _ _).symm\n  have : (fun i â†¦ (Ï i) xâ‚€ â€¢ Ï† i xâ‚€) = (fun i â†¦ (Ï i) xâ‚€) â€¢ (fun i â†¦ Ï† i xâ‚€) :=\n    funext fun _ => (Pi.smul_apply' _ _ _).symm\n  rw [Ï.coe_finsupport xâ‚€, this, support_smul]\n  exact inter_subset_left\n\n"}
{"name":"PartitionOfUnity.finite_tsupport","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u\nX : Type v\ninstâœ : TopologicalSpace X\ns : Set X\nÏ : PartitionOfUnity Î¹ X s\nxâ‚€ : X\nâŠ¢ (setOf fun i => Membership.mem (tsupport â‡‘(Ï i)) xâ‚€).Finite","decl":"/-- The `tsupport`s of a partition of unity are locally finite. -/\ntheorem finite_tsupport : {i | xâ‚€ âˆˆ tsupport (Ï i)}.Finite := by\n  rcases Ï.locallyFinite xâ‚€ with âŸ¨t, t_in, htâŸ©\n  apply ht.subset\n  rintro i hi\n  simp only [inter_comm]\n  exact mem_closure_iff_nhds.mp hi t t_in\n\n"}
{"name":"PartitionOfUnity.mem_fintsupport_iff","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u\nX : Type v\ninstâœ : TopologicalSpace X\ns : Set X\nÏ : PartitionOfUnity Î¹ X s\nxâ‚€ : X\ni : Î¹\nâŠ¢ Iff (Membership.mem (Ï.fintsupport xâ‚€) i) (Membership.mem (tsupport â‡‘(Ï i)) xâ‚€)","decl":"theorem mem_fintsupport_iff (i : Î¹) : i âˆˆ Ï.fintsupport xâ‚€ â†” xâ‚€ âˆˆ tsupport (Ï i) :=\n  Finite.mem_toFinset _\n\n"}
{"name":"PartitionOfUnity.eventually_fintsupport_subset","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u\nX : Type v\ninstâœ : TopologicalSpace X\ns : Set X\nÏ : PartitionOfUnity Î¹ X s\nxâ‚€ : X\nâŠ¢ Filter.Eventually (fun y => HasSubset.Subset (Ï.fintsupport y) (Ï.fintsupport xâ‚€)) (nhds xâ‚€)","decl":"theorem eventually_fintsupport_subset :\n    âˆ€á¶  y in ð“ xâ‚€, Ï.fintsupport y âŠ† Ï.fintsupport xâ‚€ := by\n  apply (Ï.locallyFinite.closure.eventually_subset (fun _ â†¦ isClosed_closure) xâ‚€).mono\n  intro y hy z hz\n  rw [PartitionOfUnity.mem_fintsupport_iff] at *\n  exact hy hz\n\n"}
{"name":"PartitionOfUnity.finsupport_subset_fintsupport","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u\nX : Type v\ninstâœ : TopologicalSpace X\ns : Set X\nÏ : PartitionOfUnity Î¹ X s\nxâ‚€ : X\nâŠ¢ HasSubset.Subset (Ï.finsupport xâ‚€) (Ï.fintsupport xâ‚€)","decl":"theorem finsupport_subset_fintsupport : Ï.finsupport xâ‚€ âŠ† Ï.fintsupport xâ‚€ := fun i hi â†¦ by\n  rw [Ï.mem_fintsupport_iff]\n  apply subset_closure\n  exact (Ï.mem_finsupport xâ‚€).mp hi\n\n"}
{"name":"PartitionOfUnity.eventually_finsupport_subset","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u\nX : Type v\ninstâœ : TopologicalSpace X\ns : Set X\nÏ : PartitionOfUnity Î¹ X s\nxâ‚€ : X\nâŠ¢ Filter.Eventually (fun y => HasSubset.Subset (Ï.finsupport y) (Ï.fintsupport xâ‚€)) (nhds xâ‚€)","decl":"theorem eventually_finsupport_subset : âˆ€á¶  y in ð“ xâ‚€, Ï.finsupport y âŠ† Ï.fintsupport xâ‚€ :=\n  (Ï.eventually_fintsupport_subset xâ‚€).mono\n    fun y hy â†¦ (Ï.finsupport_subset_fintsupport y).trans hy\n\n"}
{"name":"PartitionOfUnity.continuous_smul","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u\nX : Type v\ninstâœâ´ : TopologicalSpace X\nE : Type u_1\ninstâœÂ³ : AddCommMonoid E\ninstâœÂ² : SMulWithZero Real E\ninstâœÂ¹ : TopologicalSpace E\ninstâœ : ContinuousSMul Real E\ns : Set X\nf : PartitionOfUnity Î¹ X s\ng : X â†’ E\ni : Î¹\nhg : âˆ€ (x : X), Membership.mem (tsupport â‡‘(f i)) x â†’ ContinuousAt g x\nâŠ¢ Continuous fun x => HSMul.hSMul ((f i) x) (g x)","decl":"/-- If `f` is a partition of unity on `s : Set X` and `g : X â†’ E` is continuous at every point of\nthe topological support of some `f i`, then `fun x â†¦ f i x â€¢ g x` is continuous on the whole space.\n-/\ntheorem continuous_smul {g : X â†’ E} {i : Î¹} (hg : âˆ€ x âˆˆ tsupport (f i), ContinuousAt g x) :\n    Continuous fun x => f i x â€¢ g x :=\n  continuous_of_tsupport fun x hx =>\n    ((f i).continuousAt x).smul <| hg x <| tsupport_smul_subset_left _ _ hx\n\n"}
{"name":"PartitionOfUnity.continuous_finsum_smul","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u\nX : Type v\ninstâœâµ : TopologicalSpace X\nE : Type u_1\ninstâœâ´ : AddCommMonoid E\ninstâœÂ³ : SMulWithZero Real E\ninstâœÂ² : TopologicalSpace E\ninstâœÂ¹ : ContinuousSMul Real E\ns : Set X\nf : PartitionOfUnity Î¹ X s\ninstâœ : ContinuousAdd E\ng : Î¹ â†’ X â†’ E\nhg : âˆ€ (i : Î¹) (x : X), Membership.mem (tsupport â‡‘(f i)) x â†’ ContinuousAt (g i) x\nâŠ¢ Continuous fun x => finsum fun i => HSMul.hSMul ((f i) x) (g i x)","decl":"/-- If `f` is a partition of unity on a set `s : Set X` and `g : Î¹ â†’ X â†’ E` is a family of functions\nsuch that each `g i` is continuous at every point of the topological support of `f i`, then the sum\n`fun x â†¦ âˆ‘á¶  i, f i x â€¢ g i x` is continuous on the whole space. -/\ntheorem continuous_finsum_smul [ContinuousAdd E] {g : Î¹ â†’ X â†’ E}\n    (hg : âˆ€ (i), âˆ€ x âˆˆ tsupport (f i), ContinuousAt (g i) x) :\n    Continuous fun x => âˆ‘á¶  i, f i x â€¢ g i x :=\n  (continuous_finsum fun i => f.continuous_smul (hg i)) <|\n    f.locallyFinite.subset fun _ => support_smul_subset_left _ _\n\n"}
{"name":"PartitionOfUnity.exists_finset_nhd'","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u\nX : Type v\ninstâœ : TopologicalSpace X\ns : Set X\nÏ : PartitionOfUnity Î¹ X s\nxâ‚€ : X\nâŠ¢ Exists fun I => And (Filter.Eventually (fun x => Eq (I.sum fun i => (Ï i) x) 1) (nhdsWithin xâ‚€ s)) (Filter.Eventually (fun x => HasSubset.Subset (Function.support fun x_1 => (Ï x_1) x) â†‘I) (nhds xâ‚€))","decl":"theorem exists_finset_nhd' {s : Set X} (Ï : PartitionOfUnity Î¹ X s) (xâ‚€ : X) :\n    âˆƒ I : Finset Î¹, (âˆ€á¶  x in ð“[s] xâ‚€, âˆ‘ i âˆˆ I, Ï i x = 1) âˆ§\n      âˆ€á¶  x in ð“ xâ‚€, support (Ï Â· x) âŠ† I := by\n  rcases Ï.locallyFinite.exists_finset_support xâ‚€ with âŸ¨I, hIâŸ©\n  refine âŸ¨I, eventually_nhdsWithin_iff.mpr (hI.mono fun x hx x_in â†¦ ?_), hIâŸ©\n  have : âˆ‘á¶  i : Î¹, Ï i x = âˆ‘ i âˆˆ I, Ï i x := finsum_eq_sum_of_support_subset _ hx\n  rwa [eq_comm, Ï.sum_eq_one x_in] at this\n\n"}
{"name":"PartitionOfUnity.exists_finset_nhd","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u\nX : Type v\ninstâœ : TopologicalSpace X\nÏ : PartitionOfUnity Î¹ X\nxâ‚€ : X\nâŠ¢ Exists fun I => Filter.Eventually (fun x => And (Eq (I.sum fun i => (Ï i) x) 1) (HasSubset.Subset (Function.support fun x_1 => (Ï x_1) x) â†‘I)) (nhds xâ‚€)","decl":"theorem exists_finset_nhd (Ï : PartitionOfUnity Î¹ X univ) (xâ‚€ : X) :\n    âˆƒ I : Finset Î¹, âˆ€á¶  x in ð“ xâ‚€, âˆ‘ i âˆˆ I, Ï i x = 1 âˆ§ support (Ï Â· x) âŠ† I := by\n  rcases Ï.exists_finset_nhd' xâ‚€ with âŸ¨I, HâŸ©\n  use I\n  rwa [nhdsWithin_univ, â† eventually_and] at H\n\n"}
{"name":"PartitionOfUnity.exists_finset_nhd_support_subset","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u\nX : Type v\ninstâœ : TopologicalSpace X\ns : Set X\nf : PartitionOfUnity Î¹ X s\nU : Î¹ â†’ Set X\nhso : f.IsSubordinate U\nho : âˆ€ (i : Î¹), IsOpen (U i)\nx : X\nâŠ¢ Exists fun is => Exists fun n => And (Membership.mem (nhds x) n) (And (HasSubset.Subset n (Set.iInter fun i => Set.iInter fun h => U i)) (âˆ€ (z : X), Membership.mem n z â†’ HasSubset.Subset (Function.support fun x => (f x) z) â†‘is))","decl":"theorem exists_finset_nhd_support_subset {U : Î¹ â†’ Set X} (hso : f.IsSubordinate U)\n    (ho : âˆ€ i, IsOpen (U i)) (x : X) :\n    âˆƒ is : Finset Î¹, âˆƒ n âˆˆ ð“ x, n âŠ† â‹‚ i âˆˆ is, U i âˆ§ âˆ€ z âˆˆ n, (support (f Â· z)) âŠ† is :=\n  f.locallyFinite.exists_finset_nhd_support_subset hso ho x\n\n"}
{"name":"PartitionOfUnity.IsSubordinate.continuous_finsum_smul","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u\nX : Type v\ninstâœâµ : TopologicalSpace X\nE : Type u_1\ninstâœâ´ : AddCommMonoid E\ninstâœÂ³ : SMulWithZero Real E\ninstâœÂ² : TopologicalSpace E\ninstâœÂ¹ : ContinuousSMul Real E\ns : Set X\nf : PartitionOfUnity Î¹ X s\ninstâœ : ContinuousAdd E\nU : Î¹ â†’ Set X\nho : âˆ€ (i : Î¹), IsOpen (U i)\nhf : f.IsSubordinate U\ng : Î¹ â†’ X â†’ E\nhg : âˆ€ (i : Î¹), ContinuousOn (g i) (U i)\nâŠ¢ Continuous fun x => finsum fun i => HSMul.hSMul ((f i) x) (g i x)","decl":"/-- If `f` is a partition of unity that is subordinate to a family of open sets `U i` and\n`g : Î¹ â†’ X â†’ E` is a family of functions such that each `g i` is continuous on `U i`, then the sum\n`fun x â†¦ âˆ‘á¶  i, f i x â€¢ g i x` is a continuous function. -/\ntheorem IsSubordinate.continuous_finsum_smul [ContinuousAdd E] {U : Î¹ â†’ Set X}\n    (ho : âˆ€ i, IsOpen (U i)) (hf : f.IsSubordinate U) {g : Î¹ â†’ X â†’ E}\n    (hg : âˆ€ i, ContinuousOn (g i) (U i)) : Continuous fun x => âˆ‘á¶  i, f i x â€¢ g i x :=\n  f.continuous_finsum_smul fun i _ hx => (hg i).continuousAt <| (ho i).mem_nhds <| hf i hx\n\n"}
{"name":"BumpCovering.toFun_eq_coe","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u\nX : Type v\ninstâœ : TopologicalSpace X\ns : Set X\nf : BumpCovering Î¹ X s\nâŠ¢ Eq f.toFun â‡‘f","decl":"@[simp] lemma toFun_eq_coe : f.toFun = f := rfl\n\n"}
{"name":"BumpCovering.locallyFinite","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u\nX : Type v\ninstâœ : TopologicalSpace X\ns : Set X\nf : BumpCovering Î¹ X s\nâŠ¢ LocallyFinite fun i => Function.support â‡‘(f i)","decl":"protected theorem locallyFinite : LocallyFinite fun i => support (f i) :=\n  f.locallyFinite'\n\n"}
{"name":"BumpCovering.locallyFinite_tsupport","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u\nX : Type v\ninstâœ : TopologicalSpace X\ns : Set X\nf : BumpCovering Î¹ X s\nâŠ¢ LocallyFinite fun i => tsupport â‡‘(f i)","decl":"theorem locallyFinite_tsupport : LocallyFinite fun i => tsupport (f i) :=\n  f.locallyFinite.closure\n\n"}
{"name":"BumpCovering.point_finite","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u\nX : Type v\ninstâœ : TopologicalSpace X\ns : Set X\nf : BumpCovering Î¹ X s\nx : X\nâŠ¢ (setOf fun i => Ne ((f i) x) 0).Finite","decl":"protected theorem point_finite (x : X) : { i | f i x â‰  0 }.Finite :=\n  f.locallyFinite.point_finite x\n\n"}
{"name":"BumpCovering.nonneg","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u\nX : Type v\ninstâœ : TopologicalSpace X\ns : Set X\nf : BumpCovering Î¹ X s\ni : Î¹\nx : X\nâŠ¢ LE.le 0 ((f i) x)","decl":"theorem nonneg (i : Î¹) (x : X) : 0 â‰¤ f i x :=\n  f.nonneg' i x\n\n"}
{"name":"BumpCovering.le_one","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u\nX : Type v\ninstâœ : TopologicalSpace X\ns : Set X\nf : BumpCovering Î¹ X s\ni : Î¹\nx : X\nâŠ¢ LE.le ((f i) x) 1","decl":"theorem le_one (i : Î¹) (x : X) : f i x â‰¤ 1 :=\n  f.le_one' i x\n\n"}
{"name":"BumpCovering.coe_single","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u\nX : Type v\ninstâœ : TopologicalSpace X\ni : Î¹\ns : Set X\nâŠ¢ Eq (â‡‘(BumpCovering.single i s)) (Pi.single i 1)","decl":"open Classical in\n@[simp]\ntheorem coe_single (i : Î¹) (s : Set X) : â‡‘(BumpCovering.single i s) = Pi.single i 1 := by\n  rfl\n\n"}
{"name":"BumpCovering.IsSubordinate.mono","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u\nX : Type v\ninstâœ : TopologicalSpace X\ns : Set X\nf : BumpCovering Î¹ X s\nU V : Î¹ â†’ Set X\nhU : f.IsSubordinate U\nhV : âˆ€ (i : Î¹), HasSubset.Subset (U i) (V i)\nâŠ¢ f.IsSubordinate V","decl":"theorem IsSubordinate.mono {f : BumpCovering Î¹ X s} {U V : Î¹ â†’ Set X} (hU : f.IsSubordinate U)\n    (hV : âˆ€ i, U i âŠ† V i) : f.IsSubordinate V :=\n  fun i => Subset.trans (hU i) (hV i)\n\n"}
{"name":"BumpCovering.exists_isSubordinate_of_locallyFinite_of_prop","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u\nX : Type v\ninstâœÂ¹ : TopologicalSpace X\ns : Set X\ninstâœ : NormalSpace X\np : (X â†’ Real) â†’ Prop\nh01 : âˆ€ (s t : Set X), IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ Exists fun f => And (p â‡‘f) (And (Set.EqOn (â‡‘f) 0 s) (And (Set.EqOn (â‡‘f) 1 t) (âˆ€ (x : X), Membership.mem (Set.Icc 0 1) (f x))))\nhs : IsClosed s\nU : Î¹ â†’ Set X\nho : âˆ€ (i : Î¹), IsOpen (U i)\nhf : LocallyFinite U\nhU : HasSubset.Subset s (Set.iUnion fun i => U i)\nâŠ¢ Exists fun f => And (âˆ€ (i : Î¹), p â‡‘(f i)) (f.IsSubordinate U)","decl":"/-- If `X` is a normal topological space and `U i`, `i : Î¹`, is a locally finite open covering of a\nclosed set `s`, then there exists a `BumpCovering Î¹ X s` that is subordinate to `U`. If `X` is a\nparacompact space, then the assumption `hf : LocallyFinite U` can be omitted, see\n`BumpCovering.exists_isSubordinate`. This version assumes that `p : (X â†’ â„) â†’ Prop` is a predicate\nthat satisfies Urysohn's lemma, and provides a `BumpCovering` such that each function of the\ncovering satisfies `p`. -/\ntheorem exists_isSubordinate_of_locallyFinite_of_prop [NormalSpace X] (p : (X â†’ â„) â†’ Prop)\n    (h01 : âˆ€ s t, IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’\n      âˆƒ f : C(X, â„), p f âˆ§ EqOn f 0 s âˆ§ EqOn f 1 t âˆ§ âˆ€ x, f x âˆˆ Icc (0 : â„) 1)\n    (hs : IsClosed s) (U : Î¹ â†’ Set X) (ho : âˆ€ i, IsOpen (U i)) (hf : LocallyFinite U)\n    (hU : s âŠ† â‹ƒ i, U i) : âˆƒ f : BumpCovering Î¹ X s, (âˆ€ i, p (f i)) âˆ§ f.IsSubordinate U := by\n  rcases exists_subset_iUnion_closure_subset hs ho (fun x _ => hf.point_finite x) hU with\n    âŸ¨V, hsV, hVo, hVUâŸ©\n  have hVU' : âˆ€ i, V i âŠ† U i := fun i => Subset.trans subset_closure (hVU i)\n  rcases exists_subset_iUnion_closure_subset hs hVo (fun x _ => (hf.subset hVU').point_finite x)\n      hsV with\n    âŸ¨W, hsW, hWo, hWVâŸ©\n  choose f hfp hf0 hf1 hf01 using fun i =>\n    h01 _ _ (isClosed_compl_iff.2 <| hVo i) isClosed_closure\n      (disjoint_right.2 fun x hx => Classical.not_not.2 (hWV i hx))\n  have hsupp : âˆ€ i, support (f i) âŠ† V i := fun i => support_subset_iff'.2 (hf0 i)\n  refine âŸ¨âŸ¨f, hf.subset fun i => Subset.trans (hsupp i) (hVU' i), fun i x => (hf01 i x).1,\n      fun i x => (hf01 i x).2, fun x hx => ?_âŸ©,\n    hfp, fun i => Subset.trans (closure_mono (hsupp i)) (hVU i)âŸ©\n  rcases mem_iUnion.1 (hsW hx) with âŸ¨i, hiâŸ©\n  exact âŸ¨i, ((hf1 i).mono subset_closure).eventuallyEq_of_mem ((hWo i).mem_nhds hi)âŸ©\n\n"}
{"name":"BumpCovering.exists_isSubordinate_of_locallyFinite","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u\nX : Type v\ninstâœÂ¹ : TopologicalSpace X\ns : Set X\ninstâœ : NormalSpace X\nhs : IsClosed s\nU : Î¹ â†’ Set X\nho : âˆ€ (i : Î¹), IsOpen (U i)\nhf : LocallyFinite U\nhU : HasSubset.Subset s (Set.iUnion fun i => U i)\nâŠ¢ Exists fun f => f.IsSubordinate U","decl":"/-- If `X` is a normal topological space and `U i`, `i : Î¹`, is a locally finite open covering of a\nclosed set `s`, then there exists a `BumpCovering Î¹ X s` that is subordinate to `U`. If `X` is a\nparacompact space, then the assumption `hf : LocallyFinite U` can be omitted, see\n`BumpCovering.exists_isSubordinate`. -/\ntheorem exists_isSubordinate_of_locallyFinite [NormalSpace X] (hs : IsClosed s) (U : Î¹ â†’ Set X)\n    (ho : âˆ€ i, IsOpen (U i)) (hf : LocallyFinite U) (hU : s âŠ† â‹ƒ i, U i) :\n    âˆƒ f : BumpCovering Î¹ X s, f.IsSubordinate U :=\n  let âŸ¨f, _, hfUâŸ© :=\n    exists_isSubordinate_of_locallyFinite_of_prop (fun _ => True)\n      (fun _ _ hs ht hd =>\n        (exists_continuous_zero_one_of_isClosed hs ht hd).imp fun _ hf => âŸ¨trivial, hfâŸ©)\n      hs U ho hf hU\n  âŸ¨f, hfUâŸ©\n\n"}
{"name":"BumpCovering.exists_isSubordinate_of_prop","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u\nX : Type v\ninstâœÂ² : TopologicalSpace X\ns : Set X\ninstâœÂ¹ : NormalSpace X\ninstâœ : ParacompactSpace X\np : (X â†’ Real) â†’ Prop\nh01 : âˆ€ (s t : Set X), IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ Exists fun f => And (p â‡‘f) (And (Set.EqOn (â‡‘f) 0 s) (And (Set.EqOn (â‡‘f) 1 t) (âˆ€ (x : X), Membership.mem (Set.Icc 0 1) (f x))))\nhs : IsClosed s\nU : Î¹ â†’ Set X\nho : âˆ€ (i : Î¹), IsOpen (U i)\nhU : HasSubset.Subset s (Set.iUnion fun i => U i)\nâŠ¢ Exists fun f => And (âˆ€ (i : Î¹), p â‡‘(f i)) (f.IsSubordinate U)","decl":"/-- If `X` is a paracompact normal topological space and `U` is an open covering of a closed set\n`s`, then there exists a `BumpCovering Î¹ X s` that is subordinate to `U`. This version assumes that\n`p : (X â†’ â„) â†’ Prop` is a predicate that satisfies Urysohn's lemma, and provides a\n`BumpCovering` such that each function of the covering satisfies `p`. -/\ntheorem exists_isSubordinate_of_prop [NormalSpace X] [ParacompactSpace X] (p : (X â†’ â„) â†’ Prop)\n    (h01 : âˆ€ s t, IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’\n      âˆƒ f : C(X, â„), p f âˆ§ EqOn f 0 s âˆ§ EqOn f 1 t âˆ§ âˆ€ x, f x âˆˆ Icc (0 : â„) 1)\n    (hs : IsClosed s) (U : Î¹ â†’ Set X) (ho : âˆ€ i, IsOpen (U i)) (hU : s âŠ† â‹ƒ i, U i) :\n    âˆƒ f : BumpCovering Î¹ X s, (âˆ€ i, p (f i)) âˆ§ f.IsSubordinate U := by\n  rcases precise_refinement_set hs _ ho hU with âŸ¨V, hVo, hsV, hVf, hVUâŸ©\n  rcases exists_isSubordinate_of_locallyFinite_of_prop p h01 hs V hVo hVf hsV with âŸ¨f, hfp, hfâŸ©\n  exact âŸ¨f, hfp, hf.mono hVUâŸ©\n\n"}
{"name":"BumpCovering.exists_isSubordinate","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u\nX : Type v\ninstâœÂ² : TopologicalSpace X\ns : Set X\ninstâœÂ¹ : NormalSpace X\ninstâœ : ParacompactSpace X\nhs : IsClosed s\nU : Î¹ â†’ Set X\nho : âˆ€ (i : Î¹), IsOpen (U i)\nhU : HasSubset.Subset s (Set.iUnion fun i => U i)\nâŠ¢ Exists fun f => f.IsSubordinate U","decl":"/-- If `X` is a paracompact normal topological space and `U` is an open covering of a closed set\n`s`, then there exists a `BumpCovering Î¹ X s` that is subordinate to `U`. -/\ntheorem exists_isSubordinate [NormalSpace X] [ParacompactSpace X] (hs : IsClosed s) (U : Î¹ â†’ Set X)\n    (ho : âˆ€ i, IsOpen (U i)) (hU : s âŠ† â‹ƒ i, U i) : âˆƒ f : BumpCovering Î¹ X s, f.IsSubordinate U := by\n  rcases precise_refinement_set hs _ ho hU with âŸ¨V, hVo, hsV, hVf, hVUâŸ©\n  rcases exists_isSubordinate_of_locallyFinite hs V hVo hVf hsV with âŸ¨f, hfâŸ©\n  exact âŸ¨f, hf.mono hVUâŸ©\n\n"}
{"name":"BumpCovering.exists_isSubordinate_of_locallyFinite_of_prop_t2space","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u\nX : Type v\ninstâœÂ² : TopologicalSpace X\ns : Set X\ninstâœÂ¹ : LocallyCompactSpace X\ninstâœ : T2Space X\np : (X â†’ Real) â†’ Prop\nh01 : âˆ€ (s t : Set X), IsClosed s â†’ IsCompact t â†’ Disjoint s t â†’ Exists fun f => And (p â‡‘f) (And (Set.EqOn (â‡‘f) 0 s) (And (Set.EqOn (â‡‘f) 1 t) (âˆ€ (x : X), Membership.mem (Set.Icc 0 1) (f x))))\nhs : IsCompact s\nU : Î¹ â†’ Set X\nho : âˆ€ (i : Î¹), IsOpen (U i)\nhf : LocallyFinite U\nhU : HasSubset.Subset s (Set.iUnion fun i => U i)\nâŠ¢ Exists fun f => And (âˆ€ (i : Î¹), p â‡‘(f i)) (And (f.IsSubordinate U) (âˆ€ (i : Î¹), HasCompactSupport â‡‘(f i)))","decl":"/-- If `X` is a locally compact T2 topological space and `U i`, `i : Î¹`, is a locally finite open\ncovering of a compact set `s`, then there exists a `BumpCovering Î¹ X s` that is subordinate to `U`.\nIf `X` is a paracompact space, then the assumption `hf : LocallyFinite U` can be omitted, see\n`BumpCovering.exists_isSubordinate`. This version assumes that `p : (X â†’ â„) â†’ Prop` is a predicate\nthat satisfies Urysohn's lemma, and provides a `BumpCovering` such that each function of the\ncovering satisfies `p`. -/\ntheorem exists_isSubordinate_of_locallyFinite_of_prop_t2space [LocallyCompactSpace X] [T2Space X]\n    (p : (X â†’ â„) â†’ Prop) (h01 : âˆ€ s t, IsClosed s â†’ IsCompact t â†’ Disjoint s t â†’ âˆƒ f : C(X, â„),\n    p f âˆ§ EqOn f 0 s âˆ§ EqOn f 1 t âˆ§ âˆ€ x, f x âˆˆ Icc (0 : â„) 1)\n    (hs : IsCompact s) (U : Î¹ â†’ Set X) (ho : âˆ€ i, IsOpen (U i)) (hf : LocallyFinite U)\n    (hU : s âŠ† â‹ƒ i, U i) :\n    âˆƒ f : BumpCovering Î¹ X s, (âˆ€ i, p (f i)) âˆ§ f.IsSubordinate U âˆ§\n      âˆ€ i, HasCompactSupport (f i) := by\n  rcases exists_subset_iUnion_closure_subset_t2space hs ho (fun x _ => hf.point_finite x) hU with\n    âŸ¨V, hsV, hVo, hVU, hcpâŸ©\n  have hVU' i : V i âŠ† U i := subset_closure.trans (hVU i)\n  rcases exists_subset_iUnion_closure_subset_t2space hs hVo\n    (fun x _ => (hf.subset hVU').point_finite x) hsV with âŸ¨W, hsW, hWo, hWV, hWcâŸ©\n  choose f hfp hf0 hf1 hf01 using fun i =>\n    h01 _ _ (isClosed_compl_iff.2 <| hVo i) (hWc i)\n      (disjoint_right.2 fun x hx => Classical.not_not.2 (hWV i hx))\n  have hsupp i : support (f i) âŠ† V i := support_subset_iff'.2 (hf0 i)\n  refine âŸ¨âŸ¨f, hf.subset fun i => Subset.trans (hsupp i) (hVU' i), fun i x => (hf01 i x).1,\n      fun i x => (hf01 i x).2, fun x hx => ?_âŸ©,\n    hfp, fun i => Subset.trans (closure_mono (hsupp i)) (hVU i),\n    fun i => IsCompact.of_isClosed_subset (hcp i) isClosed_closure <| closure_mono (hsupp i)âŸ©\n  rcases mem_iUnion.1 (hsW hx) with âŸ¨i, hiâŸ©\n  exact âŸ¨i, ((hf1 i).mono subset_closure).eventuallyEq_of_mem ((hWo i).mem_nhds hi)âŸ©\n\n"}
{"name":"BumpCovering.exists_isSubordinate_hasCompactSupport_of_locallyFinite_t2space","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u\nX : Type v\ninstâœÂ² : TopologicalSpace X\ns : Set X\ninstâœÂ¹ : LocallyCompactSpace X\ninstâœ : T2Space X\nhs : IsCompact s\nU : Î¹ â†’ Set X\nho : âˆ€ (i : Î¹), IsOpen (U i)\nhf : LocallyFinite U\nhU : HasSubset.Subset s (Set.iUnion fun i => U i)\nâŠ¢ Exists fun f => And (f.IsSubordinate U) (âˆ€ (i : Î¹), HasCompactSupport â‡‘(f i))","decl":"/-- If `X` is a normal topological space and `U i`, `i : Î¹`, is a locally finite open covering of a\nclosed set `s`, then there exists a `BumpCovering Î¹ X s` that is subordinate to `U`. If `X` is a\nparacompact space, then the assumption `hf : LocallyFinite U` can be omitted, see\n`BumpCovering.exists_isSubordinate`. -/\ntheorem exists_isSubordinate_hasCompactSupport_of_locallyFinite_t2space [LocallyCompactSpace X]\n    [T2Space X]\n    (hs : IsCompact s) (U : Î¹ â†’ Set X) (ho : âˆ€ i, IsOpen (U i)) (hf : LocallyFinite U)\n    (hU : s âŠ† â‹ƒ i, U i) :\n    âˆƒ f : BumpCovering Î¹ X s, f.IsSubordinate U âˆ§ âˆ€ i, HasCompactSupport (f i) := by\n  -- need to switch 0 and 1 in `exists_continuous_zero_one_of_isCompact`\n  simpa using\n    exists_isSubordinate_of_locallyFinite_of_prop_t2space (fun _ => True)\n      (fun _ _ ht hs hd =>\n        (exists_continuous_zero_one_of_isCompact' hs ht hd.symm).imp fun _ hf => âŸ¨trivial, hfâŸ©)\n      hs U ho hf hU\n\n"}
{"name":"BumpCovering.eventuallyEq_one","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u\nX : Type v\ninstâœ : TopologicalSpace X\ns : Set X\nf : BumpCovering Î¹ X s\nx : X\nhx : Membership.mem s x\nâŠ¢ (nhds x).EventuallyEq (â‡‘(f (f.ind x hx))) 1","decl":"theorem eventuallyEq_one (x : X) (hx : x âˆˆ s) : f (f.ind x hx) =á¶ [ð“ x] 1 :=\n  (f.eventuallyEq_one' x hx).choose_spec\n\n"}
{"name":"BumpCovering.ind_apply","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u\nX : Type v\ninstâœ : TopologicalSpace X\ns : Set X\nf : BumpCovering Î¹ X s\nx : X\nhx : Membership.mem s x\nâŠ¢ Eq ((f (f.ind x hx)) x) 1","decl":"theorem ind_apply (x : X) (hx : x âˆˆ s) : f (f.ind x hx) x = 1 :=\n  (f.eventuallyEq_one x hx).eq_of_nhds\n\n"}
{"name":"BumpCovering.toPOUFun_zero_of_zero","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u\nX : Type v\ninstâœ : TopologicalSpace X\ns : Set X\nf : BumpCovering Î¹ X s\ni : Î¹\nx : X\nh : Eq ((f i) x) 0\nâŠ¢ Eq (f.toPOUFun i x) 0","decl":"theorem toPOUFun_zero_of_zero {i : Î¹} {x : X} (h : f i x = 0) : f.toPOUFun i x = 0 := by\n  rw [toPOUFun, h, zero_mul]\n\n"}
{"name":"BumpCovering.support_toPOUFun_subset","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u\nX : Type v\ninstâœ : TopologicalSpace X\ns : Set X\nf : BumpCovering Î¹ X s\ni : Î¹\nâŠ¢ HasSubset.Subset (Function.support (f.toPOUFun i)) (Function.support â‡‘(f i))","decl":"theorem support_toPOUFun_subset (i : Î¹) : support (f.toPOUFun i) âŠ† support (f i) :=\n  fun _ => mt <| f.toPOUFun_zero_of_zero\n\n"}
{"name":"BumpCovering.toPOUFun_eq_mul_prod","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u\nX : Type v\ninstâœ : TopologicalSpace X\ns : Set X\nf : BumpCovering Î¹ X s\ni : Î¹\nx : X\nt : Finset Î¹\nht : âˆ€ (j : Î¹), WellOrderingRel j i â†’ Ne ((f j) x) 0 â†’ Membership.mem t j\nâŠ¢ Eq (f.toPOUFun i x) (HMul.hMul ((f i) x) ((Finset.filter (fun j => WellOrderingRel j i) t).prod fun j => HSub.hSub 1 ((f j) x)))","decl":"open Classical in\ntheorem toPOUFun_eq_mul_prod (i : Î¹) (x : X) (t : Finset Î¹)\n    (ht : âˆ€ j, WellOrderingRel j i â†’ f j x â‰  0 â†’ j âˆˆ t) :\n    f.toPOUFun i x = f i x * âˆ j âˆˆ t.filter fun j => WellOrderingRel j i, (1 - f j x) := by\n  refine congr_arg _ (finprod_cond_eq_prod_of_cond_iff _ fun {j} hj => ?_)\n  rw [Ne, sub_eq_self] at hj\n  rw [Finset.mem_filter, Iff.comm, and_iff_right_iff_imp]\n  exact flip (ht j) hj\n\n"}
{"name":"BumpCovering.sum_toPOUFun_eq","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u\nX : Type v\ninstâœ : TopologicalSpace X\ns : Set X\nf : BumpCovering Î¹ X s\nx : X\nâŠ¢ Eq (finsum fun i => f.toPOUFun i x) (HSub.hSub 1 (finprod fun i => HSub.hSub 1 ((f i) x)))","decl":"theorem sum_toPOUFun_eq (x : X) : âˆ‘á¶  i, f.toPOUFun i x = 1 - âˆá¶  i, (1 - f i x) := by\n  set s := (f.point_finite x).toFinset\n  have hs : (s : Set Î¹) = { i | f i x â‰  0 } := Finite.coe_toFinset _\n  have A : (support fun i => toPOUFun f i x) âŠ† s := by\n    rw [hs]\n    exact fun i hi => f.support_toPOUFun_subset i hi\n  have B : (mulSupport fun i => 1 - f i x) âŠ† s := by\n    rw [hs, mulSupport_one_sub]\n    exact fun i => id\n  classical\n  letI : LinearOrder Î¹ := linearOrderOfSTO WellOrderingRel\n  rw [finsum_eq_sum_of_support_subset _ A, finprod_eq_prod_of_mulSupport_subset _ B,\n    Finset.prod_one_sub_ordered, sub_sub_cancel]\n  refine Finset.sum_congr rfl fun i _ => ?_\n  convert f.toPOUFun_eq_mul_prod _ _ _ fun j _ hj => _\n  rwa [Finite.mem_toFinset]\n\n"}
{"name":"BumpCovering.exists_finset_toPOUFun_eventuallyEq","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u\nX : Type v\ninstâœ : TopologicalSpace X\ns : Set X\nf : BumpCovering Î¹ X s\ni : Î¹\nx : X\nâŠ¢ Exists fun t => (nhds x).EventuallyEq (f.toPOUFun i) (HMul.hMul â‡‘(f i) â‡‘((Finset.filter (fun j => WellOrderingRel j i) t).prod fun j => HSub.hSub 1 (f j)))","decl":"open Classical in\ntheorem exists_finset_toPOUFun_eventuallyEq (i : Î¹) (x : X) : âˆƒ t : Finset Î¹,\n    f.toPOUFun i =á¶ [ð“ x] f i * âˆ j âˆˆ t.filter fun j => WellOrderingRel j i, (1 - f j) := by\n  rcases f.locallyFinite x with âŸ¨U, hU, hfâŸ©\n  use hf.toFinset\n  filter_upwards [hU] with y hyU\n  simp only [ContinuousMap.coe_prod, Pi.mul_apply, Finset.prod_apply]\n  apply toPOUFun_eq_mul_prod\n  intro j _ hj\n  exact hf.mem_toFinset.2 âŸ¨y, âŸ¨hj, hyUâŸ©âŸ©\n\n"}
{"name":"BumpCovering.continuous_toPOUFun","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u\nX : Type v\ninstâœ : TopologicalSpace X\ns : Set X\nf : BumpCovering Î¹ X s\ni : Î¹\nâŠ¢ Continuous (f.toPOUFun i)","decl":"theorem continuous_toPOUFun (i : Î¹) : Continuous (f.toPOUFun i) := by\n  refine (f i).continuous.mul <|\n    continuous_finprod_cond (fun j _ => continuous_const.sub (f j).continuous) ?_\n  simp only [mulSupport_one_sub]\n  exact f.locallyFinite\n\n"}
{"name":"BumpCovering.toPartitionOfUnity_apply","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u\nX : Type v\ninstâœ : TopologicalSpace X\ns : Set X\nf : BumpCovering Î¹ X s\ni : Î¹\nx : X\nâŠ¢ Eq ((f.toPartitionOfUnity i) x) (HMul.hMul ((f i) x) (finprod fun j => finprod fun x_1 => HSub.hSub 1 ((f j) x)))","decl":"theorem toPartitionOfUnity_apply (i : Î¹) (x : X) :\n    f.toPartitionOfUnity i x = f i x * âˆá¶  (j) (_ : WellOrderingRel j i), (1 - f j x) := rfl\n\n"}
{"name":"BumpCovering.toPartitionOfUnity_eq_mul_prod","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u\nX : Type v\ninstâœ : TopologicalSpace X\ns : Set X\nf : BumpCovering Î¹ X s\ni : Î¹\nx : X\nt : Finset Î¹\nht : âˆ€ (j : Î¹), WellOrderingRel j i â†’ Ne ((f j) x) 0 â†’ Membership.mem t j\nâŠ¢ Eq ((f.toPartitionOfUnity i) x) (HMul.hMul ((f i) x) ((Finset.filter (fun j => WellOrderingRel j i) t).prod fun j => HSub.hSub 1 ((f j) x)))","decl":"open Classical in\ntheorem toPartitionOfUnity_eq_mul_prod (i : Î¹) (x : X) (t : Finset Î¹)\n    (ht : âˆ€ j, WellOrderingRel j i â†’ f j x â‰  0 â†’ j âˆˆ t) :\n    f.toPartitionOfUnity i x = f i x * âˆ j âˆˆ t.filter fun j => WellOrderingRel j i, (1 - f j x) :=\n  f.toPOUFun_eq_mul_prod i x t ht\n\n"}
{"name":"BumpCovering.exists_finset_toPartitionOfUnity_eventuallyEq","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u\nX : Type v\ninstâœ : TopologicalSpace X\ns : Set X\nf : BumpCovering Î¹ X s\ni : Î¹\nx : X\nâŠ¢ Exists fun t => (nhds x).EventuallyEq (â‡‘(f.toPartitionOfUnity i)) (HMul.hMul â‡‘(f i) â‡‘((Finset.filter (fun j => WellOrderingRel j i) t).prod fun j => HSub.hSub 1 (f j)))","decl":"open Classical in\ntheorem exists_finset_toPartitionOfUnity_eventuallyEq (i : Î¹) (x : X) : âˆƒ t : Finset Î¹,\n    f.toPartitionOfUnity i =á¶ [ð“ x] f i * âˆ j âˆˆ t.filter fun j => WellOrderingRel j i, (1 - f j) :=\n  f.exists_finset_toPOUFun_eventuallyEq i x\n\n"}
{"name":"BumpCovering.toPartitionOfUnity_zero_of_zero","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u\nX : Type v\ninstâœ : TopologicalSpace X\ns : Set X\nf : BumpCovering Î¹ X s\ni : Î¹\nx : X\nh : Eq ((f i) x) 0\nâŠ¢ Eq ((f.toPartitionOfUnity i) x) 0","decl":"theorem toPartitionOfUnity_zero_of_zero {i : Î¹} {x : X} (h : f i x = 0) :\n    f.toPartitionOfUnity i x = 0 :=\n  f.toPOUFun_zero_of_zero h\n\n"}
{"name":"BumpCovering.support_toPartitionOfUnity_subset","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u\nX : Type v\ninstâœ : TopologicalSpace X\ns : Set X\nf : BumpCovering Î¹ X s\ni : Î¹\nâŠ¢ HasSubset.Subset (Function.support â‡‘(f.toPartitionOfUnity i)) (Function.support â‡‘(f i))","decl":"theorem support_toPartitionOfUnity_subset (i : Î¹) :\n    support (f.toPartitionOfUnity i) âŠ† support (f i) :=\n  f.support_toPOUFun_subset i\n\n"}
{"name":"BumpCovering.sum_toPartitionOfUnity_eq","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u\nX : Type v\ninstâœ : TopologicalSpace X\ns : Set X\nf : BumpCovering Î¹ X s\nx : X\nâŠ¢ Eq (finsum fun i => (f.toPartitionOfUnity i) x) (HSub.hSub 1 (finprod fun i => HSub.hSub 1 ((f i) x)))","decl":"theorem sum_toPartitionOfUnity_eq (x : X) :\n    âˆ‘á¶  i, f.toPartitionOfUnity i x = 1 - âˆá¶  i, (1 - f i x) :=\n  f.sum_toPOUFun_eq x\n\n"}
{"name":"BumpCovering.IsSubordinate.toPartitionOfUnity","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u\nX : Type v\ninstâœ : TopologicalSpace X\ns : Set X\nf : BumpCovering Î¹ X s\nU : Î¹ â†’ Set X\nh : f.IsSubordinate U\nâŠ¢ f.toPartitionOfUnity.IsSubordinate U","decl":"theorem IsSubordinate.toPartitionOfUnity {f : BumpCovering Î¹ X s} {U : Î¹ â†’ Set X}\n    (h : f.IsSubordinate U) : f.toPartitionOfUnity.IsSubordinate U :=\n  fun i => Subset.trans (closure_mono <| f.support_toPartitionOfUnity_subset i) (h i)\n\n"}
{"name":"PartitionOfUnity.exists_isSubordinate_of_locallyFinite","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u\nX : Type v\ninstâœÂ¹ : TopologicalSpace X\ns : Set X\ninstâœ : NormalSpace X\nhs : IsClosed s\nU : Î¹ â†’ Set X\nho : âˆ€ (i : Î¹), IsOpen (U i)\nhf : LocallyFinite U\nhU : HasSubset.Subset s (Set.iUnion fun i => U i)\nâŠ¢ Exists fun f => f.IsSubordinate U","decl":"/-- If `X` is a normal topological space and `U` is a locally finite open covering of a closed set\n`s`, then there exists a `PartitionOfUnity Î¹ X s` that is subordinate to `U`. If `X` is a\nparacompact space, then the assumption `hf : LocallyFinite U` can be omitted, see\n`BumpCovering.exists_isSubordinate`. -/\ntheorem exists_isSubordinate_of_locallyFinite [NormalSpace X] (hs : IsClosed s) (U : Î¹ â†’ Set X)\n    (ho : âˆ€ i, IsOpen (U i)) (hf : LocallyFinite U) (hU : s âŠ† â‹ƒ i, U i) :\n    âˆƒ f : PartitionOfUnity Î¹ X s, f.IsSubordinate U :=\n  let âŸ¨f, hfâŸ© := BumpCovering.exists_isSubordinate_of_locallyFinite hs U ho hf hU\n  âŸ¨f.toPartitionOfUnity, hf.toPartitionOfUnityâŸ©\n\n"}
{"name":"PartitionOfUnity.exists_isSubordinate","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u\nX : Type v\ninstâœÂ² : TopologicalSpace X\ns : Set X\ninstâœÂ¹ : NormalSpace X\ninstâœ : ParacompactSpace X\nhs : IsClosed s\nU : Î¹ â†’ Set X\nho : âˆ€ (i : Î¹), IsOpen (U i)\nhU : HasSubset.Subset s (Set.iUnion fun i => U i)\nâŠ¢ Exists fun f => f.IsSubordinate U","decl":"/-- If `X` is a paracompact normal topological space and `U` is an open covering of a closed set\n`s`, then there exists a `PartitionOfUnity Î¹ X s` that is subordinate to `U`. -/\ntheorem exists_isSubordinate [NormalSpace X] [ParacompactSpace X] (hs : IsClosed s) (U : Î¹ â†’ Set X)\n    (ho : âˆ€ i, IsOpen (U i)) (hU : s âŠ† â‹ƒ i, U i) :\n    âˆƒ f : PartitionOfUnity Î¹ X s, f.IsSubordinate U :=\n  let âŸ¨f, hfâŸ© := BumpCovering.exists_isSubordinate hs U ho hU\n  âŸ¨f.toPartitionOfUnity, hf.toPartitionOfUnityâŸ©\n\n"}
{"name":"PartitionOfUnity.exists_isSubordinate_of_locallyFinite_t2space","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"Î¹ : Type u\nX : Type v\ninstâœÂ² : TopologicalSpace X\ns : Set X\ninstâœÂ¹ : LocallyCompactSpace X\ninstâœ : T2Space X\nhs : IsCompact s\nU : Î¹ â†’ Set X\nho : âˆ€ (i : Î¹), IsOpen (U i)\nhf : LocallyFinite U\nhU : HasSubset.Subset s (Set.iUnion fun i => U i)\nâŠ¢ Exists fun f => And (f.IsSubordinate U) (âˆ€ (i : Î¹), HasCompactSupport â‡‘(f i))","decl":"/-- If `X` is a locally compact T2 topological space and `U` is a locally finite open covering of a\ncompact set `s`, then there exists a `PartitionOfUnity Î¹ X s` that is subordinate to `U`. -/\ntheorem exists_isSubordinate_of_locallyFinite_t2space [LocallyCompactSpace X] [T2Space X]\n    (hs : IsCompact s) (U : Î¹ â†’ Set X) (ho : âˆ€ i, IsOpen (U i)) (hf : LocallyFinite U)\n    (hU : s âŠ† â‹ƒ i, U i) :\n    âˆƒ f : PartitionOfUnity Î¹ X s, f.IsSubordinate U âˆ§ âˆ€ i, HasCompactSupport (f i) :=\n  let âŸ¨f, hfsub, hfcpâŸ© :=\n    BumpCovering.exists_isSubordinate_hasCompactSupport_of_locallyFinite_t2space hs U ho hf hU\n  âŸ¨f.toPartitionOfUnity, hfsub.toPartitionOfUnity, fun i => IsCompact.of_isClosed_subset (hfcp i)\n    isClosed_closure <| closure_mono (f.support_toPartitionOfUnity_subset i)âŸ©\n\n"}
{"name":"exists_continuous_sum_one_of_isOpen_isCompact","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"X : Type v\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : T2Space X\ninstâœ : LocallyCompactSpace X\nn : Nat\nt : Set X\ns : Fin n â†’ Set X\nhs : âˆ€ (i : Fin n), IsOpen (s i)\nhtcp : IsCompact t\nhst : HasSubset.Subset t (Set.iUnion fun i => s i)\nâŠ¢ Exists fun f => And (âˆ€ (i : Fin n), HasSubset.Subset (tsupport â‡‘(f i)) (s i)) (And (Set.EqOn (Finset.univ.sum fun i => â‡‘(f i)) 1 t) (And (âˆ€ (i : Fin n) (x : X), Membership.mem (Set.Icc 0 1) ((f i) x)) (âˆ€ (i : Fin n), HasCompactSupport â‡‘(f i))))","decl":"/-- A variation of **Urysohn's lemma**.\n\nIn a locally compact T2 space `X`, for a compact set `t` and a finite family of open sets `{s i}_i`\nsuch that `t âŠ† â‹ƒ i, s i`, there is a family of compactly supported continuous functions `{f i}_i`\nsupported in `s i`, `âˆ‘ i, f i x = 1` on `t` and `0 â‰¤ f i x â‰¤ 1`. -/\ntheorem exists_continuous_sum_one_of_isOpen_isCompact [T2Space X] [LocallyCompactSpace X]\n    {n : â„•} {t : Set X} {s : Fin n â†’ Set X} (hs : âˆ€ (i : Fin n), IsOpen (s i)) (htcp : IsCompact t)\n    (hst : t âŠ† â‹ƒ i, s i) :\n    âˆƒ f : Fin n â†’ C(X, â„), (âˆ€ (i : Fin n), tsupport (f i) âŠ† s i) âˆ§ EqOn (âˆ‘ i, f i) 1 t\n      âˆ§ (âˆ€ (i : Fin n), âˆ€ (x : X), f i x âˆˆ Icc (0 : â„) 1)\n      âˆ§ (âˆ€ (i : Fin n), HasCompactSupport (f i)) := by\n  obtain âŸ¨f, hfsub, hfcpâŸ© := PartitionOfUnity.exists_isSubordinate_of_locallyFinite_t2space htcp s\n    hs (locallyFinite_of_finite _) hst\n  use f\n  refine âŸ¨fun i â†¦ hfsub i, ?_, ?_, fun i => hfcp iâŸ©\n  Â· intro x hx\n    simp only [Finset.sum_apply, Pi.one_apply]\n    have h := f.sum_eq_one' x hx\n    simp at h\n    rw [finsum_eq_sum (fun i => (f.toFun i) x)\n      (Finite.subset finite_univ (subset_univ (support fun i â†¦ (f.toFun i) x)))] at h\n    simp only [Finite.toFinset_setOf, ne_eq] at h\n    rw [â† h, â† Finset.sum_subset\n      (Finset.subset_univ (Finset.filter (fun (j : Fin n) â†¦ Â¬(f.toFun j) x = 0) Finset.univ))\n      (by intro j hju hj\n          simp only [Finset.mem_filter, Finset.mem_univ, true_and, Decidable.not_not] at hj\n          exact hj)]\n    rfl\n  intro i x\n  exact âŸ¨f.nonneg i x, PartitionOfUnity.le_one f i xâŸ©\n"}
