{"name":"PartitionOfUnity.sum_le_one'","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u_1\nX : Type u_2\ninst✝ : TopologicalSpace X\ns : optParam (Set X) Set.univ\nself : PartitionOfUnity ι X s\nx : X\n⊢ LE.le (finsum fun i => (self.toFun i) x) 1","decl":"/-- A continuous partition of unity on a set `s : Set X` is a collection of continuous functions\n`f i` such that\n\n* the supports of `f i` form a locally finite family of sets, i.e., for every point `x : X` there\n  exists a neighborhood `U ∋ x` such that all but finitely many functions `f i` are zero on `U`;\n* the functions `f i` are nonnegative;\n* the sum `∑ᶠ i, f i x` is equal to one for every `x ∈ s` and is less than or equal to one\n  otherwise.\n\nIf `X` is a normal paracompact space, then `PartitionOfUnity.exists_isSubordinate` guarantees\nthat for every open covering `U : Set (Set X)` of `s` there exists a partition of unity that is\nsubordinate to `U`.\n-/\nstructure PartitionOfUnity (ι X : Type*) [TopologicalSpace X] (s : Set X := univ) where\n  /-- The collection of continuous functions underlying this partition of unity -/\n  toFun : ι → C(X, ℝ)\n  /-- the supports of the underlying functions are a locally finite family of sets -/\n  locallyFinite' : LocallyFinite fun i => support (toFun i)\n  /-- the functions are non-negative -/\n  nonneg' : 0 ≤ toFun\n  /-- the functions sum up to one on `s` -/\n  sum_eq_one' : ∀ x ∈ s, ∑ᶠ i, toFun i x = 1\n  /-- the functions sum up to at most one, globally -/\n  sum_le_one' : ∀ x, ∑ᶠ i, toFun i x ≤ 1\n\n"}
{"name":"PartitionOfUnity.nonneg'","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u_1\nX : Type u_2\ninst✝ : TopologicalSpace X\ns : optParam (Set X) Set.univ\nself : PartitionOfUnity ι X s\n⊢ LE.le 0 self.toFun","decl":"/-- A continuous partition of unity on a set `s : Set X` is a collection of continuous functions\n`f i` such that\n\n* the supports of `f i` form a locally finite family of sets, i.e., for every point `x : X` there\n  exists a neighborhood `U ∋ x` such that all but finitely many functions `f i` are zero on `U`;\n* the functions `f i` are nonnegative;\n* the sum `∑ᶠ i, f i x` is equal to one for every `x ∈ s` and is less than or equal to one\n  otherwise.\n\nIf `X` is a normal paracompact space, then `PartitionOfUnity.exists_isSubordinate` guarantees\nthat for every open covering `U : Set (Set X)` of `s` there exists a partition of unity that is\nsubordinate to `U`.\n-/\nstructure PartitionOfUnity (ι X : Type*) [TopologicalSpace X] (s : Set X := univ) where\n  /-- The collection of continuous functions underlying this partition of unity -/\n  toFun : ι → C(X, ℝ)\n  /-- the supports of the underlying functions are a locally finite family of sets -/\n  locallyFinite' : LocallyFinite fun i => support (toFun i)\n  /-- the functions are non-negative -/\n  nonneg' : 0 ≤ toFun\n  /-- the functions sum up to one on `s` -/\n  sum_eq_one' : ∀ x ∈ s, ∑ᶠ i, toFun i x = 1\n  /-- the functions sum up to at most one, globally -/\n  sum_le_one' : ∀ x, ∑ᶠ i, toFun i x ≤ 1\n\n"}
{"name":"PartitionOfUnity.locallyFinite'","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u_1\nX : Type u_2\ninst✝ : TopologicalSpace X\ns : optParam (Set X) Set.univ\nself : PartitionOfUnity ι X s\n⊢ LocallyFinite fun i => Function.support ⇑(self.toFun i)","decl":"/-- A continuous partition of unity on a set `s : Set X` is a collection of continuous functions\n`f i` such that\n\n* the supports of `f i` form a locally finite family of sets, i.e., for every point `x : X` there\n  exists a neighborhood `U ∋ x` such that all but finitely many functions `f i` are zero on `U`;\n* the functions `f i` are nonnegative;\n* the sum `∑ᶠ i, f i x` is equal to one for every `x ∈ s` and is less than or equal to one\n  otherwise.\n\nIf `X` is a normal paracompact space, then `PartitionOfUnity.exists_isSubordinate` guarantees\nthat for every open covering `U : Set (Set X)` of `s` there exists a partition of unity that is\nsubordinate to `U`.\n-/\nstructure PartitionOfUnity (ι X : Type*) [TopologicalSpace X] (s : Set X := univ) where\n  /-- The collection of continuous functions underlying this partition of unity -/\n  toFun : ι → C(X, ℝ)\n  /-- the supports of the underlying functions are a locally finite family of sets -/\n  locallyFinite' : LocallyFinite fun i => support (toFun i)\n  /-- the functions are non-negative -/\n  nonneg' : 0 ≤ toFun\n  /-- the functions sum up to one on `s` -/\n  sum_eq_one' : ∀ x ∈ s, ∑ᶠ i, toFun i x = 1\n  /-- the functions sum up to at most one, globally -/\n  sum_le_one' : ∀ x, ∑ᶠ i, toFun i x ≤ 1\n\n"}
{"name":"PartitionOfUnity.sum_eq_one'","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u_1\nX : Type u_2\ninst✝ : TopologicalSpace X\ns : optParam (Set X) Set.univ\nself : PartitionOfUnity ι X s\nx : X\na✝ : Membership.mem s x\n⊢ Eq (finsum fun i => (self.toFun i) x) 1","decl":"/-- A continuous partition of unity on a set `s : Set X` is a collection of continuous functions\n`f i` such that\n\n* the supports of `f i` form a locally finite family of sets, i.e., for every point `x : X` there\n  exists a neighborhood `U ∋ x` such that all but finitely many functions `f i` are zero on `U`;\n* the functions `f i` are nonnegative;\n* the sum `∑ᶠ i, f i x` is equal to one for every `x ∈ s` and is less than or equal to one\n  otherwise.\n\nIf `X` is a normal paracompact space, then `PartitionOfUnity.exists_isSubordinate` guarantees\nthat for every open covering `U : Set (Set X)` of `s` there exists a partition of unity that is\nsubordinate to `U`.\n-/\nstructure PartitionOfUnity (ι X : Type*) [TopologicalSpace X] (s : Set X := univ) where\n  /-- The collection of continuous functions underlying this partition of unity -/\n  toFun : ι → C(X, ℝ)\n  /-- the supports of the underlying functions are a locally finite family of sets -/\n  locallyFinite' : LocallyFinite fun i => support (toFun i)\n  /-- the functions are non-negative -/\n  nonneg' : 0 ≤ toFun\n  /-- the functions sum up to one on `s` -/\n  sum_eq_one' : ∀ x ∈ s, ∑ᶠ i, toFun i x = 1\n  /-- the functions sum up to at most one, globally -/\n  sum_le_one' : ∀ x, ∑ᶠ i, toFun i x ≤ 1\n\n"}
{"name":"PartitionOfUnity.mk.sizeOf_spec","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u_1\nX : Type u_2\ninst✝³ : TopologicalSpace X\ns : optParam (Set X) Set.univ\ninst✝² : SizeOf ι\ninst✝¹ : SizeOf X\ninst✝ : (a : X) → SizeOf (s a)\ntoFun : ι → ContinuousMap X Real\nlocallyFinite' : LocallyFinite fun i => Function.support ⇑(toFun i)\nnonneg' : LE.le 0 toFun\nsum_eq_one' : ∀ (x : X), Membership.mem s x → Eq (finsum fun i => (toFun i) x) 1\nsum_le_one' : ∀ (x : X), LE.le (finsum fun i => (toFun i) x) 1\n⊢ Eq (SizeOf.sizeOf { toFun := toFun, locallyFinite' := locallyFinite', nonneg' := nonneg', sum_eq_one' := sum_eq_one', sum_le_one' := sum_le_one' }) 1","decl":"/-- A continuous partition of unity on a set `s : Set X` is a collection of continuous functions\n`f i` such that\n\n* the supports of `f i` form a locally finite family of sets, i.e., for every point `x : X` there\n  exists a neighborhood `U ∋ x` such that all but finitely many functions `f i` are zero on `U`;\n* the functions `f i` are nonnegative;\n* the sum `∑ᶠ i, f i x` is equal to one for every `x ∈ s` and is less than or equal to one\n  otherwise.\n\nIf `X` is a normal paracompact space, then `PartitionOfUnity.exists_isSubordinate` guarantees\nthat for every open covering `U : Set (Set X)` of `s` there exists a partition of unity that is\nsubordinate to `U`.\n-/\nstructure PartitionOfUnity (ι X : Type*) [TopologicalSpace X] (s : Set X := univ) where\n  /-- The collection of continuous functions underlying this partition of unity -/\n  toFun : ι → C(X, ℝ)\n  /-- the supports of the underlying functions are a locally finite family of sets -/\n  locallyFinite' : LocallyFinite fun i => support (toFun i)\n  /-- the functions are non-negative -/\n  nonneg' : 0 ≤ toFun\n  /-- the functions sum up to one on `s` -/\n  sum_eq_one' : ∀ x ∈ s, ∑ᶠ i, toFun i x = 1\n  /-- the functions sum up to at most one, globally -/\n  sum_le_one' : ∀ x, ∑ᶠ i, toFun i x ≤ 1\n\n"}
{"name":"PartitionOfUnity.mk.inj","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u_1\nX : Type u_2\ninst✝ : TopologicalSpace X\ns : Set X\ntoFun✝ : ι → ContinuousMap X Real\nlocallyFinite'✝ : LocallyFinite fun i => Function.support ⇑(toFun✝ i)\nnonneg'✝ : LE.le 0 toFun✝\nsum_eq_one'✝ : ∀ (x : X), Membership.mem s x → Eq (finsum fun i => (toFun✝ i) x) 1\nsum_le_one'✝ : ∀ (x : X), LE.le (finsum fun i => (toFun✝ i) x) 1\ntoFun : ι → ContinuousMap X Real\nlocallyFinite' : LocallyFinite fun i => Function.support ⇑(toFun i)\nnonneg' : LE.le 0 toFun\nsum_eq_one' : ∀ (x : X), Membership.mem s x → Eq (finsum fun i => (toFun i) x) 1\nsum_le_one' : ∀ (x : X), LE.le (finsum fun i => (toFun i) x) 1\nx✝ : Eq { toFun := toFun✝, locallyFinite' := locallyFinite'✝, nonneg' := nonneg'✝, sum_eq_one' := sum_eq_one'✝, sum_le_one' := sum_le_one'✝ } { toFun := toFun, locallyFinite' := locallyFinite', nonneg' := nonneg', sum_eq_one' := sum_eq_one', sum_le_one' := sum_le_one' }\n⊢ Eq toFun✝ toFun","decl":"/-- A continuous partition of unity on a set `s : Set X` is a collection of continuous functions\n`f i` such that\n\n* the supports of `f i` form a locally finite family of sets, i.e., for every point `x : X` there\n  exists a neighborhood `U ∋ x` such that all but finitely many functions `f i` are zero on `U`;\n* the functions `f i` are nonnegative;\n* the sum `∑ᶠ i, f i x` is equal to one for every `x ∈ s` and is less than or equal to one\n  otherwise.\n\nIf `X` is a normal paracompact space, then `PartitionOfUnity.exists_isSubordinate` guarantees\nthat for every open covering `U : Set (Set X)` of `s` there exists a partition of unity that is\nsubordinate to `U`.\n-/\nstructure PartitionOfUnity (ι X : Type*) [TopologicalSpace X] (s : Set X := univ) where\n  /-- The collection of continuous functions underlying this partition of unity -/\n  toFun : ι → C(X, ℝ)\n  /-- the supports of the underlying functions are a locally finite family of sets -/\n  locallyFinite' : LocallyFinite fun i => support (toFun i)\n  /-- the functions are non-negative -/\n  nonneg' : 0 ≤ toFun\n  /-- the functions sum up to one on `s` -/\n  sum_eq_one' : ∀ x ∈ s, ∑ᶠ i, toFun i x = 1\n  /-- the functions sum up to at most one, globally -/\n  sum_le_one' : ∀ x, ∑ᶠ i, toFun i x ≤ 1\n\n"}
{"name":"PartitionOfUnity.mk.injEq","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u_1\nX : Type u_2\ninst✝ : TopologicalSpace X\ns : Set X\ntoFun✝ : ι → ContinuousMap X Real\nlocallyFinite'✝ : LocallyFinite fun i => Function.support ⇑(toFun✝ i)\nnonneg'✝ : LE.le 0 toFun✝\nsum_eq_one'✝ : ∀ (x : X), Membership.mem s x → Eq (finsum fun i => (toFun✝ i) x) 1\nsum_le_one'✝ : ∀ (x : X), LE.le (finsum fun i => (toFun✝ i) x) 1\ntoFun : ι → ContinuousMap X Real\nlocallyFinite' : LocallyFinite fun i => Function.support ⇑(toFun i)\nnonneg' : LE.le 0 toFun\nsum_eq_one' : ∀ (x : X), Membership.mem s x → Eq (finsum fun i => (toFun i) x) 1\nsum_le_one' : ∀ (x : X), LE.le (finsum fun i => (toFun i) x) 1\n⊢ Eq (Eq { toFun := toFun✝, locallyFinite' := locallyFinite'✝, nonneg' := nonneg'✝, sum_eq_one' := sum_eq_one'✝, sum_le_one' := sum_le_one'✝ } { toFun := toFun, locallyFinite' := locallyFinite', nonneg' := nonneg', sum_eq_one' := sum_eq_one', sum_le_one' := sum_le_one' }) (Eq toFun✝ toFun)","decl":"/-- A continuous partition of unity on a set `s : Set X` is a collection of continuous functions\n`f i` such that\n\n* the supports of `f i` form a locally finite family of sets, i.e., for every point `x : X` there\n  exists a neighborhood `U ∋ x` such that all but finitely many functions `f i` are zero on `U`;\n* the functions `f i` are nonnegative;\n* the sum `∑ᶠ i, f i x` is equal to one for every `x ∈ s` and is less than or equal to one\n  otherwise.\n\nIf `X` is a normal paracompact space, then `PartitionOfUnity.exists_isSubordinate` guarantees\nthat for every open covering `U : Set (Set X)` of `s` there exists a partition of unity that is\nsubordinate to `U`.\n-/\nstructure PartitionOfUnity (ι X : Type*) [TopologicalSpace X] (s : Set X := univ) where\n  /-- The collection of continuous functions underlying this partition of unity -/\n  toFun : ι → C(X, ℝ)\n  /-- the supports of the underlying functions are a locally finite family of sets -/\n  locallyFinite' : LocallyFinite fun i => support (toFun i)\n  /-- the functions are non-negative -/\n  nonneg' : 0 ≤ toFun\n  /-- the functions sum up to one on `s` -/\n  sum_eq_one' : ∀ x ∈ s, ∑ᶠ i, toFun i x = 1\n  /-- the functions sum up to at most one, globally -/\n  sum_le_one' : ∀ x, ∑ᶠ i, toFun i x ≤ 1\n\n"}
{"name":"BumpCovering.eventuallyEq_one'","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u_1\nX : Type u_2\ninst✝ : TopologicalSpace X\ns : optParam (Set X) Set.univ\nself : BumpCovering ι X s\nx : X\na✝ : Membership.mem s x\n⊢ Exists fun i => (nhds x).EventuallyEq (⇑(self.toFun i)) 1","decl":"/-- A `BumpCovering ι X s` is an indexed family of functions `f i`, `i : ι`, such that\n\n* the supports of `f i` form a locally finite family of sets, i.e., for every point `x : X` there\n  exists a neighborhood `U ∋ x` such that all but finitely many functions `f i` are zero on `U`;\n* for all `i`, `x` we have `0 ≤ f i x ≤ 1`;\n* each point `x ∈ s` belongs to the interior of `{x | f i x = 1}` for some `i`.\n\nOne of the main use cases for a `BumpCovering` is to define a `PartitionOfUnity`, see\n`BumpCovering.toPartitionOfUnity`, but some proofs can directly use a `BumpCovering` instead of\na `PartitionOfUnity`.\n\nIf `X` is a normal paracompact space, then `BumpCovering.exists_isSubordinate` guarantees that for\nevery open covering `U : Set (Set X)` of `s` there exists a `BumpCovering` of `s` that is\nsubordinate to `U`.\n-/\nstructure BumpCovering (ι X : Type*) [TopologicalSpace X] (s : Set X := univ) where\n  /-- The collections of continuous functions underlying this bump covering -/\n  toFun : ι → C(X, ℝ)\n  /-- the supports of the underlying functions are a locally finite family of sets -/\n  locallyFinite' : LocallyFinite fun i => support (toFun i)\n  /-- the functions are non-negative -/\n  nonneg' : 0 ≤ toFun\n  /-- the functions are each at most one -/\n  le_one' : toFun ≤ 1\n  /-- Each point `x ∈ s` belongs to the interior of `{x | f i x = 1}` for some `i`. -/\n  eventuallyEq_one' : ∀ x ∈ s, ∃ i, toFun i =ᶠ[𝓝 x] 1\n\n"}
{"name":"BumpCovering.mk.sizeOf_spec","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u_1\nX : Type u_2\ninst✝³ : TopologicalSpace X\ns : optParam (Set X) Set.univ\ninst✝² : SizeOf ι\ninst✝¹ : SizeOf X\ninst✝ : (a : X) → SizeOf (s a)\ntoFun : ι → ContinuousMap X Real\nlocallyFinite' : LocallyFinite fun i => Function.support ⇑(toFun i)\nnonneg' : LE.le 0 toFun\nle_one' : LE.le toFun 1\neventuallyEq_one' : ∀ (x : X), Membership.mem s x → Exists fun i => (nhds x).EventuallyEq (⇑(toFun i)) 1\n⊢ Eq (SizeOf.sizeOf { toFun := toFun, locallyFinite' := locallyFinite', nonneg' := nonneg', le_one' := le_one', eventuallyEq_one' := eventuallyEq_one' }) 1","decl":"/-- A `BumpCovering ι X s` is an indexed family of functions `f i`, `i : ι`, such that\n\n* the supports of `f i` form a locally finite family of sets, i.e., for every point `x : X` there\n  exists a neighborhood `U ∋ x` such that all but finitely many functions `f i` are zero on `U`;\n* for all `i`, `x` we have `0 ≤ f i x ≤ 1`;\n* each point `x ∈ s` belongs to the interior of `{x | f i x = 1}` for some `i`.\n\nOne of the main use cases for a `BumpCovering` is to define a `PartitionOfUnity`, see\n`BumpCovering.toPartitionOfUnity`, but some proofs can directly use a `BumpCovering` instead of\na `PartitionOfUnity`.\n\nIf `X` is a normal paracompact space, then `BumpCovering.exists_isSubordinate` guarantees that for\nevery open covering `U : Set (Set X)` of `s` there exists a `BumpCovering` of `s` that is\nsubordinate to `U`.\n-/\nstructure BumpCovering (ι X : Type*) [TopologicalSpace X] (s : Set X := univ) where\n  /-- The collections of continuous functions underlying this bump covering -/\n  toFun : ι → C(X, ℝ)\n  /-- the supports of the underlying functions are a locally finite family of sets -/\n  locallyFinite' : LocallyFinite fun i => support (toFun i)\n  /-- the functions are non-negative -/\n  nonneg' : 0 ≤ toFun\n  /-- the functions are each at most one -/\n  le_one' : toFun ≤ 1\n  /-- Each point `x ∈ s` belongs to the interior of `{x | f i x = 1}` for some `i`. -/\n  eventuallyEq_one' : ∀ x ∈ s, ∃ i, toFun i =ᶠ[𝓝 x] 1\n\n"}
{"name":"BumpCovering.le_one'","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u_1\nX : Type u_2\ninst✝ : TopologicalSpace X\ns : optParam (Set X) Set.univ\nself : BumpCovering ι X s\n⊢ LE.le self.toFun 1","decl":"/-- A `BumpCovering ι X s` is an indexed family of functions `f i`, `i : ι`, such that\n\n* the supports of `f i` form a locally finite family of sets, i.e., for every point `x : X` there\n  exists a neighborhood `U ∋ x` such that all but finitely many functions `f i` are zero on `U`;\n* for all `i`, `x` we have `0 ≤ f i x ≤ 1`;\n* each point `x ∈ s` belongs to the interior of `{x | f i x = 1}` for some `i`.\n\nOne of the main use cases for a `BumpCovering` is to define a `PartitionOfUnity`, see\n`BumpCovering.toPartitionOfUnity`, but some proofs can directly use a `BumpCovering` instead of\na `PartitionOfUnity`.\n\nIf `X` is a normal paracompact space, then `BumpCovering.exists_isSubordinate` guarantees that for\nevery open covering `U : Set (Set X)` of `s` there exists a `BumpCovering` of `s` that is\nsubordinate to `U`.\n-/\nstructure BumpCovering (ι X : Type*) [TopologicalSpace X] (s : Set X := univ) where\n  /-- The collections of continuous functions underlying this bump covering -/\n  toFun : ι → C(X, ℝ)\n  /-- the supports of the underlying functions are a locally finite family of sets -/\n  locallyFinite' : LocallyFinite fun i => support (toFun i)\n  /-- the functions are non-negative -/\n  nonneg' : 0 ≤ toFun\n  /-- the functions are each at most one -/\n  le_one' : toFun ≤ 1\n  /-- Each point `x ∈ s` belongs to the interior of `{x | f i x = 1}` for some `i`. -/\n  eventuallyEq_one' : ∀ x ∈ s, ∃ i, toFun i =ᶠ[𝓝 x] 1\n\n"}
{"name":"BumpCovering.mk.injEq","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u_1\nX : Type u_2\ninst✝ : TopologicalSpace X\ns : Set X\ntoFun✝ : ι → ContinuousMap X Real\nlocallyFinite'✝ : LocallyFinite fun i => Function.support ⇑(toFun✝ i)\nnonneg'✝ : LE.le 0 toFun✝\nle_one'✝ : LE.le toFun✝ 1\neventuallyEq_one'✝ : ∀ (x : X), Membership.mem s x → Exists fun i => (nhds x).EventuallyEq (⇑(toFun✝ i)) 1\ntoFun : ι → ContinuousMap X Real\nlocallyFinite' : LocallyFinite fun i => Function.support ⇑(toFun i)\nnonneg' : LE.le 0 toFun\nle_one' : LE.le toFun 1\neventuallyEq_one' : ∀ (x : X), Membership.mem s x → Exists fun i => (nhds x).EventuallyEq (⇑(toFun i)) 1\n⊢ Eq (Eq { toFun := toFun✝, locallyFinite' := locallyFinite'✝, nonneg' := nonneg'✝, le_one' := le_one'✝, eventuallyEq_one' := eventuallyEq_one'✝ } { toFun := toFun, locallyFinite' := locallyFinite', nonneg' := nonneg', le_one' := le_one', eventuallyEq_one' := eventuallyEq_one' }) (Eq toFun✝ toFun)","decl":"/-- A `BumpCovering ι X s` is an indexed family of functions `f i`, `i : ι`, such that\n\n* the supports of `f i` form a locally finite family of sets, i.e., for every point `x : X` there\n  exists a neighborhood `U ∋ x` such that all but finitely many functions `f i` are zero on `U`;\n* for all `i`, `x` we have `0 ≤ f i x ≤ 1`;\n* each point `x ∈ s` belongs to the interior of `{x | f i x = 1}` for some `i`.\n\nOne of the main use cases for a `BumpCovering` is to define a `PartitionOfUnity`, see\n`BumpCovering.toPartitionOfUnity`, but some proofs can directly use a `BumpCovering` instead of\na `PartitionOfUnity`.\n\nIf `X` is a normal paracompact space, then `BumpCovering.exists_isSubordinate` guarantees that for\nevery open covering `U : Set (Set X)` of `s` there exists a `BumpCovering` of `s` that is\nsubordinate to `U`.\n-/\nstructure BumpCovering (ι X : Type*) [TopologicalSpace X] (s : Set X := univ) where\n  /-- The collections of continuous functions underlying this bump covering -/\n  toFun : ι → C(X, ℝ)\n  /-- the supports of the underlying functions are a locally finite family of sets -/\n  locallyFinite' : LocallyFinite fun i => support (toFun i)\n  /-- the functions are non-negative -/\n  nonneg' : 0 ≤ toFun\n  /-- the functions are each at most one -/\n  le_one' : toFun ≤ 1\n  /-- Each point `x ∈ s` belongs to the interior of `{x | f i x = 1}` for some `i`. -/\n  eventuallyEq_one' : ∀ x ∈ s, ∃ i, toFun i =ᶠ[𝓝 x] 1\n\n"}
{"name":"BumpCovering.nonneg'","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u_1\nX : Type u_2\ninst✝ : TopologicalSpace X\ns : optParam (Set X) Set.univ\nself : BumpCovering ι X s\n⊢ LE.le 0 self.toFun","decl":"/-- A `BumpCovering ι X s` is an indexed family of functions `f i`, `i : ι`, such that\n\n* the supports of `f i` form a locally finite family of sets, i.e., for every point `x : X` there\n  exists a neighborhood `U ∋ x` such that all but finitely many functions `f i` are zero on `U`;\n* for all `i`, `x` we have `0 ≤ f i x ≤ 1`;\n* each point `x ∈ s` belongs to the interior of `{x | f i x = 1}` for some `i`.\n\nOne of the main use cases for a `BumpCovering` is to define a `PartitionOfUnity`, see\n`BumpCovering.toPartitionOfUnity`, but some proofs can directly use a `BumpCovering` instead of\na `PartitionOfUnity`.\n\nIf `X` is a normal paracompact space, then `BumpCovering.exists_isSubordinate` guarantees that for\nevery open covering `U : Set (Set X)` of `s` there exists a `BumpCovering` of `s` that is\nsubordinate to `U`.\n-/\nstructure BumpCovering (ι X : Type*) [TopologicalSpace X] (s : Set X := univ) where\n  /-- The collections of continuous functions underlying this bump covering -/\n  toFun : ι → C(X, ℝ)\n  /-- the supports of the underlying functions are a locally finite family of sets -/\n  locallyFinite' : LocallyFinite fun i => support (toFun i)\n  /-- the functions are non-negative -/\n  nonneg' : 0 ≤ toFun\n  /-- the functions are each at most one -/\n  le_one' : toFun ≤ 1\n  /-- Each point `x ∈ s` belongs to the interior of `{x | f i x = 1}` for some `i`. -/\n  eventuallyEq_one' : ∀ x ∈ s, ∃ i, toFun i =ᶠ[𝓝 x] 1\n\n"}
{"name":"BumpCovering.locallyFinite'","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u_1\nX : Type u_2\ninst✝ : TopologicalSpace X\ns : optParam (Set X) Set.univ\nself : BumpCovering ι X s\n⊢ LocallyFinite fun i => Function.support ⇑(self.toFun i)","decl":"/-- A `BumpCovering ι X s` is an indexed family of functions `f i`, `i : ι`, such that\n\n* the supports of `f i` form a locally finite family of sets, i.e., for every point `x : X` there\n  exists a neighborhood `U ∋ x` such that all but finitely many functions `f i` are zero on `U`;\n* for all `i`, `x` we have `0 ≤ f i x ≤ 1`;\n* each point `x ∈ s` belongs to the interior of `{x | f i x = 1}` for some `i`.\n\nOne of the main use cases for a `BumpCovering` is to define a `PartitionOfUnity`, see\n`BumpCovering.toPartitionOfUnity`, but some proofs can directly use a `BumpCovering` instead of\na `PartitionOfUnity`.\n\nIf `X` is a normal paracompact space, then `BumpCovering.exists_isSubordinate` guarantees that for\nevery open covering `U : Set (Set X)` of `s` there exists a `BumpCovering` of `s` that is\nsubordinate to `U`.\n-/\nstructure BumpCovering (ι X : Type*) [TopologicalSpace X] (s : Set X := univ) where\n  /-- The collections of continuous functions underlying this bump covering -/\n  toFun : ι → C(X, ℝ)\n  /-- the supports of the underlying functions are a locally finite family of sets -/\n  locallyFinite' : LocallyFinite fun i => support (toFun i)\n  /-- the functions are non-negative -/\n  nonneg' : 0 ≤ toFun\n  /-- the functions are each at most one -/\n  le_one' : toFun ≤ 1\n  /-- Each point `x ∈ s` belongs to the interior of `{x | f i x = 1}` for some `i`. -/\n  eventuallyEq_one' : ∀ x ∈ s, ∃ i, toFun i =ᶠ[𝓝 x] 1\n\n"}
{"name":"BumpCovering.mk.inj","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u_1\nX : Type u_2\ninst✝ : TopologicalSpace X\ns : Set X\ntoFun✝ : ι → ContinuousMap X Real\nlocallyFinite'✝ : LocallyFinite fun i => Function.support ⇑(toFun✝ i)\nnonneg'✝ : LE.le 0 toFun✝\nle_one'✝ : LE.le toFun✝ 1\neventuallyEq_one'✝ : ∀ (x : X), Membership.mem s x → Exists fun i => (nhds x).EventuallyEq (⇑(toFun✝ i)) 1\ntoFun : ι → ContinuousMap X Real\nlocallyFinite' : LocallyFinite fun i => Function.support ⇑(toFun i)\nnonneg' : LE.le 0 toFun\nle_one' : LE.le toFun 1\neventuallyEq_one' : ∀ (x : X), Membership.mem s x → Exists fun i => (nhds x).EventuallyEq (⇑(toFun i)) 1\nx✝ : Eq { toFun := toFun✝, locallyFinite' := locallyFinite'✝, nonneg' := nonneg'✝, le_one' := le_one'✝, eventuallyEq_one' := eventuallyEq_one'✝ } { toFun := toFun, locallyFinite' := locallyFinite', nonneg' := nonneg', le_one' := le_one', eventuallyEq_one' := eventuallyEq_one' }\n⊢ Eq toFun✝ toFun","decl":"/-- A `BumpCovering ι X s` is an indexed family of functions `f i`, `i : ι`, such that\n\n* the supports of `f i` form a locally finite family of sets, i.e., for every point `x : X` there\n  exists a neighborhood `U ∋ x` such that all but finitely many functions `f i` are zero on `U`;\n* for all `i`, `x` we have `0 ≤ f i x ≤ 1`;\n* each point `x ∈ s` belongs to the interior of `{x | f i x = 1}` for some `i`.\n\nOne of the main use cases for a `BumpCovering` is to define a `PartitionOfUnity`, see\n`BumpCovering.toPartitionOfUnity`, but some proofs can directly use a `BumpCovering` instead of\na `PartitionOfUnity`.\n\nIf `X` is a normal paracompact space, then `BumpCovering.exists_isSubordinate` guarantees that for\nevery open covering `U : Set (Set X)` of `s` there exists a `BumpCovering` of `s` that is\nsubordinate to `U`.\n-/\nstructure BumpCovering (ι X : Type*) [TopologicalSpace X] (s : Set X := univ) where\n  /-- The collections of continuous functions underlying this bump covering -/\n  toFun : ι → C(X, ℝ)\n  /-- the supports of the underlying functions are a locally finite family of sets -/\n  locallyFinite' : LocallyFinite fun i => support (toFun i)\n  /-- the functions are non-negative -/\n  nonneg' : 0 ≤ toFun\n  /-- the functions are each at most one -/\n  le_one' : toFun ≤ 1\n  /-- Each point `x ∈ s` belongs to the interior of `{x | f i x = 1}` for some `i`. -/\n  eventuallyEq_one' : ∀ x ∈ s, ∃ i, toFun i =ᶠ[𝓝 x] 1\n\n"}
{"name":"PartitionOfUnity.locallyFinite","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u\nX : Type v\ninst✝ : TopologicalSpace X\ns : Set X\nf : PartitionOfUnity ι X s\n⊢ LocallyFinite fun i => Function.support ⇑(f i)","decl":"protected theorem locallyFinite : LocallyFinite fun i => support (f i) :=\n  f.locallyFinite'\n\n"}
{"name":"PartitionOfUnity.locallyFinite_tsupport","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u\nX : Type v\ninst✝ : TopologicalSpace X\ns : Set X\nf : PartitionOfUnity ι X s\n⊢ LocallyFinite fun i => tsupport ⇑(f i)","decl":"theorem locallyFinite_tsupport : LocallyFinite fun i => tsupport (f i) :=\n  f.locallyFinite.closure\n\n"}
{"name":"PartitionOfUnity.nonneg","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u\nX : Type v\ninst✝ : TopologicalSpace X\ns : Set X\nf : PartitionOfUnity ι X s\ni : ι\nx : X\n⊢ LE.le 0 ((f i) x)","decl":"theorem nonneg (i : ι) (x : X) : 0 ≤ f i x :=\n  f.nonneg' i x\n\n"}
{"name":"PartitionOfUnity.sum_eq_one","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u\nX : Type v\ninst✝ : TopologicalSpace X\ns : Set X\nf : PartitionOfUnity ι X s\nx : X\nhx : Membership.mem s x\n⊢ Eq (finsum fun i => (f i) x) 1","decl":"theorem sum_eq_one {x : X} (hx : x ∈ s) : ∑ᶠ i, f i x = 1 :=\n  f.sum_eq_one' x hx\n\n"}
{"name":"PartitionOfUnity.exists_pos","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u\nX : Type v\ninst✝ : TopologicalSpace X\ns : Set X\nf : PartitionOfUnity ι X s\nx : X\nhx : Membership.mem s x\n⊢ Exists fun i => LT.lt 0 ((f i) x)","decl":"/-- If `f` is a partition of unity on `s`, then for every `x ∈ s` there exists an index `i` such\nthat `0 < f i x`. -/\ntheorem exists_pos {x : X} (hx : x ∈ s) : ∃ i, 0 < f i x := by\n  have H := f.sum_eq_one hx\n  contrapose! H\n  simpa only [fun i => (H i).antisymm (f.nonneg i x), finsum_zero] using zero_ne_one\n\n"}
{"name":"PartitionOfUnity.sum_le_one","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u\nX : Type v\ninst✝ : TopologicalSpace X\ns : Set X\nf : PartitionOfUnity ι X s\nx : X\n⊢ LE.le (finsum fun i => (f i) x) 1","decl":"theorem sum_le_one (x : X) : ∑ᶠ i, f i x ≤ 1 :=\n  f.sum_le_one' x\n\n"}
{"name":"PartitionOfUnity.sum_nonneg","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u\nX : Type v\ninst✝ : TopologicalSpace X\ns : Set X\nf : PartitionOfUnity ι X s\nx : X\n⊢ LE.le 0 (finsum fun i => (f i) x)","decl":"theorem sum_nonneg (x : X) : 0 ≤ ∑ᶠ i, f i x :=\n  finsum_nonneg fun i => f.nonneg i x\n\n"}
{"name":"PartitionOfUnity.le_one","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u\nX : Type v\ninst✝ : TopologicalSpace X\ns : Set X\nf : PartitionOfUnity ι X s\ni : ι\nx : X\n⊢ LE.le ((f i) x) 1","decl":"theorem le_one (i : ι) (x : X) : f i x ≤ 1 :=\n  (single_le_finsum i (f.locallyFinite.point_finite x) fun j => f.nonneg j x).trans (f.sum_le_one x)\n\n"}
{"name":"PartitionOfUnity.mem_finsupport","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u\nX : Type v\ninst✝ : TopologicalSpace X\ns : Set X\nρ : PartitionOfUnity ι X s\nx₀ : X\ni : ι\n⊢ Iff (Membership.mem (ρ.finsupport x₀) i) (Membership.mem (Function.support fun i => (ρ i) x₀) i)","decl":"@[simp]\ntheorem mem_finsupport (x₀ : X) {i} :\n    i ∈ ρ.finsupport x₀ ↔ i ∈ support fun i ↦ ρ i x₀ := by\n  simp only [finsupport, mem_support, Finite.mem_toFinset, mem_setOf_eq]\n\n"}
{"name":"PartitionOfUnity.coe_finsupport","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u\nX : Type v\ninst✝ : TopologicalSpace X\ns : Set X\nρ : PartitionOfUnity ι X s\nx₀ : X\n⊢ Eq (↑(ρ.finsupport x₀)) (Function.support fun i => (ρ i) x₀)","decl":"@[simp]\ntheorem coe_finsupport (x₀ : X) :\n    (ρ.finsupport x₀ : Set ι) = support fun i ↦ ρ i x₀ := by\n  ext\n  rw [Finset.mem_coe, mem_finsupport]\n\n"}
{"name":"PartitionOfUnity.sum_finsupport","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u\nX : Type v\ninst✝ : TopologicalSpace X\ns : Set X\nρ : PartitionOfUnity ι X s\nx₀ : X\nhx₀ : Membership.mem s x₀\n⊢ Eq ((ρ.finsupport x₀).sum fun i => (ρ i) x₀) 1","decl":"theorem sum_finsupport (hx₀ : x₀ ∈ s) : ∑ i ∈ ρ.finsupport x₀, ρ i x₀ = 1 := by\n  rw [← ρ.sum_eq_one hx₀, finsum_eq_sum_of_support_subset _ (ρ.coe_finsupport x₀).superset]\n\n"}
{"name":"PartitionOfUnity.sum_finsupport'","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u\nX : Type v\ninst✝ : TopologicalSpace X\ns : Set X\nρ : PartitionOfUnity ι X s\nx₀ : X\nhx₀ : Membership.mem s x₀\nI : Finset ι\nhI : HasSubset.Subset (ρ.finsupport x₀) I\n⊢ Eq (I.sum fun i => (ρ i) x₀) 1","decl":"theorem sum_finsupport' (hx₀ : x₀ ∈ s) {I : Finset ι} (hI : ρ.finsupport x₀ ⊆ I) :\n    ∑ i ∈ I, ρ i x₀ = 1 := by\n  classical\n  rw [← Finset.sum_sdiff hI, ρ.sum_finsupport hx₀]\n  suffices ∑ i ∈ I \\ ρ.finsupport x₀, (ρ i) x₀ = ∑ i ∈ I \\ ρ.finsupport x₀, 0 by\n    rw [this, add_left_eq_self, Finset.sum_const_zero]\n  apply Finset.sum_congr rfl\n  rintro x hx\n  simp only [Finset.mem_sdiff, ρ.mem_finsupport, mem_support, Classical.not_not] at hx\n  exact hx.2\n\n"}
{"name":"PartitionOfUnity.sum_finsupport_smul_eq_finsum","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u\nX : Type v\ninst✝² : TopologicalSpace X\ns : Set X\nρ : PartitionOfUnity ι X s\nx₀ : X\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module Real M\nφ : ι → X → M\n⊢ Eq ((ρ.finsupport x₀).sum fun i => HSMul.hSMul ((ρ i) x₀) (φ i x₀)) (finsum fun i => HSMul.hSMul ((ρ i) x₀) (φ i x₀))","decl":"theorem sum_finsupport_smul_eq_finsum {M : Type*} [AddCommGroup M] [Module ℝ M] (φ : ι → X → M) :\n    ∑ i ∈ ρ.finsupport x₀, ρ i x₀ • φ i x₀ = ∑ᶠ i, ρ i x₀ • φ i x₀ := by\n  apply (finsum_eq_sum_of_support_subset _ _).symm\n  have : (fun i ↦ (ρ i) x₀ • φ i x₀) = (fun i ↦ (ρ i) x₀) • (fun i ↦ φ i x₀) :=\n    funext fun _ => (Pi.smul_apply' _ _ _).symm\n  rw [ρ.coe_finsupport x₀, this, support_smul]\n  exact inter_subset_left\n\n"}
{"name":"PartitionOfUnity.finite_tsupport","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u\nX : Type v\ninst✝ : TopologicalSpace X\ns : Set X\nρ : PartitionOfUnity ι X s\nx₀ : X\n⊢ (setOf fun i => Membership.mem (tsupport ⇑(ρ i)) x₀).Finite","decl":"/-- The `tsupport`s of a partition of unity are locally finite. -/\ntheorem finite_tsupport : {i | x₀ ∈ tsupport (ρ i)}.Finite := by\n  rcases ρ.locallyFinite x₀ with ⟨t, t_in, ht⟩\n  apply ht.subset\n  rintro i hi\n  simp only [inter_comm]\n  exact mem_closure_iff_nhds.mp hi t t_in\n\n"}
{"name":"PartitionOfUnity.mem_fintsupport_iff","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u\nX : Type v\ninst✝ : TopologicalSpace X\ns : Set X\nρ : PartitionOfUnity ι X s\nx₀ : X\ni : ι\n⊢ Iff (Membership.mem (ρ.fintsupport x₀) i) (Membership.mem (tsupport ⇑(ρ i)) x₀)","decl":"theorem mem_fintsupport_iff (i : ι) : i ∈ ρ.fintsupport x₀ ↔ x₀ ∈ tsupport (ρ i) :=\n  Finite.mem_toFinset _\n\n"}
{"name":"PartitionOfUnity.eventually_fintsupport_subset","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u\nX : Type v\ninst✝ : TopologicalSpace X\ns : Set X\nρ : PartitionOfUnity ι X s\nx₀ : X\n⊢ Filter.Eventually (fun y => HasSubset.Subset (ρ.fintsupport y) (ρ.fintsupport x₀)) (nhds x₀)","decl":"theorem eventually_fintsupport_subset :\n    ∀ᶠ y in 𝓝 x₀, ρ.fintsupport y ⊆ ρ.fintsupport x₀ := by\n  apply (ρ.locallyFinite.closure.eventually_subset (fun _ ↦ isClosed_closure) x₀).mono\n  intro y hy z hz\n  rw [PartitionOfUnity.mem_fintsupport_iff] at *\n  exact hy hz\n\n"}
{"name":"PartitionOfUnity.finsupport_subset_fintsupport","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u\nX : Type v\ninst✝ : TopologicalSpace X\ns : Set X\nρ : PartitionOfUnity ι X s\nx₀ : X\n⊢ HasSubset.Subset (ρ.finsupport x₀) (ρ.fintsupport x₀)","decl":"theorem finsupport_subset_fintsupport : ρ.finsupport x₀ ⊆ ρ.fintsupport x₀ := fun i hi ↦ by\n  rw [ρ.mem_fintsupport_iff]\n  apply subset_closure\n  exact (ρ.mem_finsupport x₀).mp hi\n\n"}
{"name":"PartitionOfUnity.eventually_finsupport_subset","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u\nX : Type v\ninst✝ : TopologicalSpace X\ns : Set X\nρ : PartitionOfUnity ι X s\nx₀ : X\n⊢ Filter.Eventually (fun y => HasSubset.Subset (ρ.finsupport y) (ρ.fintsupport x₀)) (nhds x₀)","decl":"theorem eventually_finsupport_subset : ∀ᶠ y in 𝓝 x₀, ρ.finsupport y ⊆ ρ.fintsupport x₀ :=\n  (ρ.eventually_fintsupport_subset x₀).mono\n    fun y hy ↦ (ρ.finsupport_subset_fintsupport y).trans hy\n\n"}
{"name":"PartitionOfUnity.continuous_smul","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u\nX : Type v\ninst✝⁴ : TopologicalSpace X\nE : Type u_1\ninst✝³ : AddCommMonoid E\ninst✝² : SMulWithZero Real E\ninst✝¹ : TopologicalSpace E\ninst✝ : ContinuousSMul Real E\ns : Set X\nf : PartitionOfUnity ι X s\ng : X → E\ni : ι\nhg : ∀ (x : X), Membership.mem (tsupport ⇑(f i)) x → ContinuousAt g x\n⊢ Continuous fun x => HSMul.hSMul ((f i) x) (g x)","decl":"/-- If `f` is a partition of unity on `s : Set X` and `g : X → E` is continuous at every point of\nthe topological support of some `f i`, then `fun x ↦ f i x • g x` is continuous on the whole space.\n-/\ntheorem continuous_smul {g : X → E} {i : ι} (hg : ∀ x ∈ tsupport (f i), ContinuousAt g x) :\n    Continuous fun x => f i x • g x :=\n  continuous_of_tsupport fun x hx =>\n    ((f i).continuousAt x).smul <| hg x <| tsupport_smul_subset_left _ _ hx\n\n"}
{"name":"PartitionOfUnity.continuous_finsum_smul","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u\nX : Type v\ninst✝⁵ : TopologicalSpace X\nE : Type u_1\ninst✝⁴ : AddCommMonoid E\ninst✝³ : SMulWithZero Real E\ninst✝² : TopologicalSpace E\ninst✝¹ : ContinuousSMul Real E\ns : Set X\nf : PartitionOfUnity ι X s\ninst✝ : ContinuousAdd E\ng : ι → X → E\nhg : ∀ (i : ι) (x : X), Membership.mem (tsupport ⇑(f i)) x → ContinuousAt (g i) x\n⊢ Continuous fun x => finsum fun i => HSMul.hSMul ((f i) x) (g i x)","decl":"/-- If `f` is a partition of unity on a set `s : Set X` and `g : ι → X → E` is a family of functions\nsuch that each `g i` is continuous at every point of the topological support of `f i`, then the sum\n`fun x ↦ ∑ᶠ i, f i x • g i x` is continuous on the whole space. -/\ntheorem continuous_finsum_smul [ContinuousAdd E] {g : ι → X → E}\n    (hg : ∀ (i), ∀ x ∈ tsupport (f i), ContinuousAt (g i) x) :\n    Continuous fun x => ∑ᶠ i, f i x • g i x :=\n  (continuous_finsum fun i => f.continuous_smul (hg i)) <|\n    f.locallyFinite.subset fun _ => support_smul_subset_left _ _\n\n"}
{"name":"PartitionOfUnity.exists_finset_nhd'","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u\nX : Type v\ninst✝ : TopologicalSpace X\ns : Set X\nρ : PartitionOfUnity ι X s\nx₀ : X\n⊢ Exists fun I => And (Filter.Eventually (fun x => Eq (I.sum fun i => (ρ i) x) 1) (nhdsWithin x₀ s)) (Filter.Eventually (fun x => HasSubset.Subset (Function.support fun x_1 => (ρ x_1) x) ↑I) (nhds x₀))","decl":"theorem exists_finset_nhd' {s : Set X} (ρ : PartitionOfUnity ι X s) (x₀ : X) :\n    ∃ I : Finset ι, (∀ᶠ x in 𝓝[s] x₀, ∑ i ∈ I, ρ i x = 1) ∧\n      ∀ᶠ x in 𝓝 x₀, support (ρ · x) ⊆ I := by\n  rcases ρ.locallyFinite.exists_finset_support x₀ with ⟨I, hI⟩\n  refine ⟨I, eventually_nhdsWithin_iff.mpr (hI.mono fun x hx x_in ↦ ?_), hI⟩\n  have : ∑ᶠ i : ι, ρ i x = ∑ i ∈ I, ρ i x := finsum_eq_sum_of_support_subset _ hx\n  rwa [eq_comm, ρ.sum_eq_one x_in] at this\n\n"}
{"name":"PartitionOfUnity.exists_finset_nhd","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u\nX : Type v\ninst✝ : TopologicalSpace X\nρ : PartitionOfUnity ι X\nx₀ : X\n⊢ Exists fun I => Filter.Eventually (fun x => And (Eq (I.sum fun i => (ρ i) x) 1) (HasSubset.Subset (Function.support fun x_1 => (ρ x_1) x) ↑I)) (nhds x₀)","decl":"theorem exists_finset_nhd (ρ : PartitionOfUnity ι X univ) (x₀ : X) :\n    ∃ I : Finset ι, ∀ᶠ x in 𝓝 x₀, ∑ i ∈ I, ρ i x = 1 ∧ support (ρ · x) ⊆ I := by\n  rcases ρ.exists_finset_nhd' x₀ with ⟨I, H⟩\n  use I\n  rwa [nhdsWithin_univ, ← eventually_and] at H\n\n"}
{"name":"PartitionOfUnity.exists_finset_nhd_support_subset","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u\nX : Type v\ninst✝ : TopologicalSpace X\ns : Set X\nf : PartitionOfUnity ι X s\nU : ι → Set X\nhso : f.IsSubordinate U\nho : ∀ (i : ι), IsOpen (U i)\nx : X\n⊢ Exists fun is => Exists fun n => And (Membership.mem (nhds x) n) (And (HasSubset.Subset n (Set.iInter fun i => Set.iInter fun h => U i)) (∀ (z : X), Membership.mem n z → HasSubset.Subset (Function.support fun x => (f x) z) ↑is))","decl":"theorem exists_finset_nhd_support_subset {U : ι → Set X} (hso : f.IsSubordinate U)\n    (ho : ∀ i, IsOpen (U i)) (x : X) :\n    ∃ is : Finset ι, ∃ n ∈ 𝓝 x, n ⊆ ⋂ i ∈ is, U i ∧ ∀ z ∈ n, (support (f · z)) ⊆ is :=\n  f.locallyFinite.exists_finset_nhd_support_subset hso ho x\n\n"}
{"name":"PartitionOfUnity.IsSubordinate.continuous_finsum_smul","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u\nX : Type v\ninst✝⁵ : TopologicalSpace X\nE : Type u_1\ninst✝⁴ : AddCommMonoid E\ninst✝³ : SMulWithZero Real E\ninst✝² : TopologicalSpace E\ninst✝¹ : ContinuousSMul Real E\ns : Set X\nf : PartitionOfUnity ι X s\ninst✝ : ContinuousAdd E\nU : ι → Set X\nho : ∀ (i : ι), IsOpen (U i)\nhf : f.IsSubordinate U\ng : ι → X → E\nhg : ∀ (i : ι), ContinuousOn (g i) (U i)\n⊢ Continuous fun x => finsum fun i => HSMul.hSMul ((f i) x) (g i x)","decl":"/-- If `f` is a partition of unity that is subordinate to a family of open sets `U i` and\n`g : ι → X → E` is a family of functions such that each `g i` is continuous on `U i`, then the sum\n`fun x ↦ ∑ᶠ i, f i x • g i x` is a continuous function. -/\ntheorem IsSubordinate.continuous_finsum_smul [ContinuousAdd E] {U : ι → Set X}\n    (ho : ∀ i, IsOpen (U i)) (hf : f.IsSubordinate U) {g : ι → X → E}\n    (hg : ∀ i, ContinuousOn (g i) (U i)) : Continuous fun x => ∑ᶠ i, f i x • g i x :=\n  f.continuous_finsum_smul fun i _ hx => (hg i).continuousAt <| (ho i).mem_nhds <| hf i hx\n\n"}
{"name":"BumpCovering.toFun_eq_coe","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u\nX : Type v\ninst✝ : TopologicalSpace X\ns : Set X\nf : BumpCovering ι X s\n⊢ Eq f.toFun ⇑f","decl":"@[simp] lemma toFun_eq_coe : f.toFun = f := rfl\n\n"}
{"name":"BumpCovering.locallyFinite","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u\nX : Type v\ninst✝ : TopologicalSpace X\ns : Set X\nf : BumpCovering ι X s\n⊢ LocallyFinite fun i => Function.support ⇑(f i)","decl":"protected theorem locallyFinite : LocallyFinite fun i => support (f i) :=\n  f.locallyFinite'\n\n"}
{"name":"BumpCovering.locallyFinite_tsupport","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u\nX : Type v\ninst✝ : TopologicalSpace X\ns : Set X\nf : BumpCovering ι X s\n⊢ LocallyFinite fun i => tsupport ⇑(f i)","decl":"theorem locallyFinite_tsupport : LocallyFinite fun i => tsupport (f i) :=\n  f.locallyFinite.closure\n\n"}
{"name":"BumpCovering.point_finite","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u\nX : Type v\ninst✝ : TopologicalSpace X\ns : Set X\nf : BumpCovering ι X s\nx : X\n⊢ (setOf fun i => Ne ((f i) x) 0).Finite","decl":"protected theorem point_finite (x : X) : { i | f i x ≠ 0 }.Finite :=\n  f.locallyFinite.point_finite x\n\n"}
{"name":"BumpCovering.nonneg","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u\nX : Type v\ninst✝ : TopologicalSpace X\ns : Set X\nf : BumpCovering ι X s\ni : ι\nx : X\n⊢ LE.le 0 ((f i) x)","decl":"theorem nonneg (i : ι) (x : X) : 0 ≤ f i x :=\n  f.nonneg' i x\n\n"}
{"name":"BumpCovering.le_one","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u\nX : Type v\ninst✝ : TopologicalSpace X\ns : Set X\nf : BumpCovering ι X s\ni : ι\nx : X\n⊢ LE.le ((f i) x) 1","decl":"theorem le_one (i : ι) (x : X) : f i x ≤ 1 :=\n  f.le_one' i x\n\n"}
{"name":"BumpCovering.coe_single","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u\nX : Type v\ninst✝ : TopologicalSpace X\ni : ι\ns : Set X\n⊢ Eq (⇑(BumpCovering.single i s)) (Pi.single i 1)","decl":"open Classical in\n@[simp]\ntheorem coe_single (i : ι) (s : Set X) : ⇑(BumpCovering.single i s) = Pi.single i 1 := by\n  rfl\n\n"}
{"name":"BumpCovering.IsSubordinate.mono","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u\nX : Type v\ninst✝ : TopologicalSpace X\ns : Set X\nf : BumpCovering ι X s\nU V : ι → Set X\nhU : f.IsSubordinate U\nhV : ∀ (i : ι), HasSubset.Subset (U i) (V i)\n⊢ f.IsSubordinate V","decl":"theorem IsSubordinate.mono {f : BumpCovering ι X s} {U V : ι → Set X} (hU : f.IsSubordinate U)\n    (hV : ∀ i, U i ⊆ V i) : f.IsSubordinate V :=\n  fun i => Subset.trans (hU i) (hV i)\n\n"}
{"name":"BumpCovering.exists_isSubordinate_of_locallyFinite_of_prop","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u\nX : Type v\ninst✝¹ : TopologicalSpace X\ns : Set X\ninst✝ : NormalSpace X\np : (X → Real) → Prop\nh01 : ∀ (s t : Set X), IsClosed s → IsClosed t → Disjoint s t → Exists fun f => And (p ⇑f) (And (Set.EqOn (⇑f) 0 s) (And (Set.EqOn (⇑f) 1 t) (∀ (x : X), Membership.mem (Set.Icc 0 1) (f x))))\nhs : IsClosed s\nU : ι → Set X\nho : ∀ (i : ι), IsOpen (U i)\nhf : LocallyFinite U\nhU : HasSubset.Subset s (Set.iUnion fun i => U i)\n⊢ Exists fun f => And (∀ (i : ι), p ⇑(f i)) (f.IsSubordinate U)","decl":"/-- If `X` is a normal topological space and `U i`, `i : ι`, is a locally finite open covering of a\nclosed set `s`, then there exists a `BumpCovering ι X s` that is subordinate to `U`. If `X` is a\nparacompact space, then the assumption `hf : LocallyFinite U` can be omitted, see\n`BumpCovering.exists_isSubordinate`. This version assumes that `p : (X → ℝ) → Prop` is a predicate\nthat satisfies Urysohn's lemma, and provides a `BumpCovering` such that each function of the\ncovering satisfies `p`. -/\ntheorem exists_isSubordinate_of_locallyFinite_of_prop [NormalSpace X] (p : (X → ℝ) → Prop)\n    (h01 : ∀ s t, IsClosed s → IsClosed t → Disjoint s t →\n      ∃ f : C(X, ℝ), p f ∧ EqOn f 0 s ∧ EqOn f 1 t ∧ ∀ x, f x ∈ Icc (0 : ℝ) 1)\n    (hs : IsClosed s) (U : ι → Set X) (ho : ∀ i, IsOpen (U i)) (hf : LocallyFinite U)\n    (hU : s ⊆ ⋃ i, U i) : ∃ f : BumpCovering ι X s, (∀ i, p (f i)) ∧ f.IsSubordinate U := by\n  rcases exists_subset_iUnion_closure_subset hs ho (fun x _ => hf.point_finite x) hU with\n    ⟨V, hsV, hVo, hVU⟩\n  have hVU' : ∀ i, V i ⊆ U i := fun i => Subset.trans subset_closure (hVU i)\n  rcases exists_subset_iUnion_closure_subset hs hVo (fun x _ => (hf.subset hVU').point_finite x)\n      hsV with\n    ⟨W, hsW, hWo, hWV⟩\n  choose f hfp hf0 hf1 hf01 using fun i =>\n    h01 _ _ (isClosed_compl_iff.2 <| hVo i) isClosed_closure\n      (disjoint_right.2 fun x hx => Classical.not_not.2 (hWV i hx))\n  have hsupp : ∀ i, support (f i) ⊆ V i := fun i => support_subset_iff'.2 (hf0 i)\n  refine ⟨⟨f, hf.subset fun i => Subset.trans (hsupp i) (hVU' i), fun i x => (hf01 i x).1,\n      fun i x => (hf01 i x).2, fun x hx => ?_⟩,\n    hfp, fun i => Subset.trans (closure_mono (hsupp i)) (hVU i)⟩\n  rcases mem_iUnion.1 (hsW hx) with ⟨i, hi⟩\n  exact ⟨i, ((hf1 i).mono subset_closure).eventuallyEq_of_mem ((hWo i).mem_nhds hi)⟩\n\n"}
{"name":"BumpCovering.exists_isSubordinate_of_locallyFinite","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u\nX : Type v\ninst✝¹ : TopologicalSpace X\ns : Set X\ninst✝ : NormalSpace X\nhs : IsClosed s\nU : ι → Set X\nho : ∀ (i : ι), IsOpen (U i)\nhf : LocallyFinite U\nhU : HasSubset.Subset s (Set.iUnion fun i => U i)\n⊢ Exists fun f => f.IsSubordinate U","decl":"/-- If `X` is a normal topological space and `U i`, `i : ι`, is a locally finite open covering of a\nclosed set `s`, then there exists a `BumpCovering ι X s` that is subordinate to `U`. If `X` is a\nparacompact space, then the assumption `hf : LocallyFinite U` can be omitted, see\n`BumpCovering.exists_isSubordinate`. -/\ntheorem exists_isSubordinate_of_locallyFinite [NormalSpace X] (hs : IsClosed s) (U : ι → Set X)\n    (ho : ∀ i, IsOpen (U i)) (hf : LocallyFinite U) (hU : s ⊆ ⋃ i, U i) :\n    ∃ f : BumpCovering ι X s, f.IsSubordinate U :=\n  let ⟨f, _, hfU⟩ :=\n    exists_isSubordinate_of_locallyFinite_of_prop (fun _ => True)\n      (fun _ _ hs ht hd =>\n        (exists_continuous_zero_one_of_isClosed hs ht hd).imp fun _ hf => ⟨trivial, hf⟩)\n      hs U ho hf hU\n  ⟨f, hfU⟩\n\n"}
{"name":"BumpCovering.exists_isSubordinate_of_prop","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u\nX : Type v\ninst✝² : TopologicalSpace X\ns : Set X\ninst✝¹ : NormalSpace X\ninst✝ : ParacompactSpace X\np : (X → Real) → Prop\nh01 : ∀ (s t : Set X), IsClosed s → IsClosed t → Disjoint s t → Exists fun f => And (p ⇑f) (And (Set.EqOn (⇑f) 0 s) (And (Set.EqOn (⇑f) 1 t) (∀ (x : X), Membership.mem (Set.Icc 0 1) (f x))))\nhs : IsClosed s\nU : ι → Set X\nho : ∀ (i : ι), IsOpen (U i)\nhU : HasSubset.Subset s (Set.iUnion fun i => U i)\n⊢ Exists fun f => And (∀ (i : ι), p ⇑(f i)) (f.IsSubordinate U)","decl":"/-- If `X` is a paracompact normal topological space and `U` is an open covering of a closed set\n`s`, then there exists a `BumpCovering ι X s` that is subordinate to `U`. This version assumes that\n`p : (X → ℝ) → Prop` is a predicate that satisfies Urysohn's lemma, and provides a\n`BumpCovering` such that each function of the covering satisfies `p`. -/\ntheorem exists_isSubordinate_of_prop [NormalSpace X] [ParacompactSpace X] (p : (X → ℝ) → Prop)\n    (h01 : ∀ s t, IsClosed s → IsClosed t → Disjoint s t →\n      ∃ f : C(X, ℝ), p f ∧ EqOn f 0 s ∧ EqOn f 1 t ∧ ∀ x, f x ∈ Icc (0 : ℝ) 1)\n    (hs : IsClosed s) (U : ι → Set X) (ho : ∀ i, IsOpen (U i)) (hU : s ⊆ ⋃ i, U i) :\n    ∃ f : BumpCovering ι X s, (∀ i, p (f i)) ∧ f.IsSubordinate U := by\n  rcases precise_refinement_set hs _ ho hU with ⟨V, hVo, hsV, hVf, hVU⟩\n  rcases exists_isSubordinate_of_locallyFinite_of_prop p h01 hs V hVo hVf hsV with ⟨f, hfp, hf⟩\n  exact ⟨f, hfp, hf.mono hVU⟩\n\n"}
{"name":"BumpCovering.exists_isSubordinate","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u\nX : Type v\ninst✝² : TopologicalSpace X\ns : Set X\ninst✝¹ : NormalSpace X\ninst✝ : ParacompactSpace X\nhs : IsClosed s\nU : ι → Set X\nho : ∀ (i : ι), IsOpen (U i)\nhU : HasSubset.Subset s (Set.iUnion fun i => U i)\n⊢ Exists fun f => f.IsSubordinate U","decl":"/-- If `X` is a paracompact normal topological space and `U` is an open covering of a closed set\n`s`, then there exists a `BumpCovering ι X s` that is subordinate to `U`. -/\ntheorem exists_isSubordinate [NormalSpace X] [ParacompactSpace X] (hs : IsClosed s) (U : ι → Set X)\n    (ho : ∀ i, IsOpen (U i)) (hU : s ⊆ ⋃ i, U i) : ∃ f : BumpCovering ι X s, f.IsSubordinate U := by\n  rcases precise_refinement_set hs _ ho hU with ⟨V, hVo, hsV, hVf, hVU⟩\n  rcases exists_isSubordinate_of_locallyFinite hs V hVo hVf hsV with ⟨f, hf⟩\n  exact ⟨f, hf.mono hVU⟩\n\n"}
{"name":"BumpCovering.exists_isSubordinate_of_locallyFinite_of_prop_t2space","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u\nX : Type v\ninst✝² : TopologicalSpace X\ns : Set X\ninst✝¹ : LocallyCompactSpace X\ninst✝ : T2Space X\np : (X → Real) → Prop\nh01 : ∀ (s t : Set X), IsClosed s → IsCompact t → Disjoint s t → Exists fun f => And (p ⇑f) (And (Set.EqOn (⇑f) 0 s) (And (Set.EqOn (⇑f) 1 t) (∀ (x : X), Membership.mem (Set.Icc 0 1) (f x))))\nhs : IsCompact s\nU : ι → Set X\nho : ∀ (i : ι), IsOpen (U i)\nhf : LocallyFinite U\nhU : HasSubset.Subset s (Set.iUnion fun i => U i)\n⊢ Exists fun f => And (∀ (i : ι), p ⇑(f i)) (And (f.IsSubordinate U) (∀ (i : ι), HasCompactSupport ⇑(f i)))","decl":"/-- If `X` is a locally compact T2 topological space and `U i`, `i : ι`, is a locally finite open\ncovering of a compact set `s`, then there exists a `BumpCovering ι X s` that is subordinate to `U`.\nIf `X` is a paracompact space, then the assumption `hf : LocallyFinite U` can be omitted, see\n`BumpCovering.exists_isSubordinate`. This version assumes that `p : (X → ℝ) → Prop` is a predicate\nthat satisfies Urysohn's lemma, and provides a `BumpCovering` such that each function of the\ncovering satisfies `p`. -/\ntheorem exists_isSubordinate_of_locallyFinite_of_prop_t2space [LocallyCompactSpace X] [T2Space X]\n    (p : (X → ℝ) → Prop) (h01 : ∀ s t, IsClosed s → IsCompact t → Disjoint s t → ∃ f : C(X, ℝ),\n    p f ∧ EqOn f 0 s ∧ EqOn f 1 t ∧ ∀ x, f x ∈ Icc (0 : ℝ) 1)\n    (hs : IsCompact s) (U : ι → Set X) (ho : ∀ i, IsOpen (U i)) (hf : LocallyFinite U)\n    (hU : s ⊆ ⋃ i, U i) :\n    ∃ f : BumpCovering ι X s, (∀ i, p (f i)) ∧ f.IsSubordinate U ∧\n      ∀ i, HasCompactSupport (f i) := by\n  rcases exists_subset_iUnion_closure_subset_t2space hs ho (fun x _ => hf.point_finite x) hU with\n    ⟨V, hsV, hVo, hVU, hcp⟩\n  have hVU' i : V i ⊆ U i := subset_closure.trans (hVU i)\n  rcases exists_subset_iUnion_closure_subset_t2space hs hVo\n    (fun x _ => (hf.subset hVU').point_finite x) hsV with ⟨W, hsW, hWo, hWV, hWc⟩\n  choose f hfp hf0 hf1 hf01 using fun i =>\n    h01 _ _ (isClosed_compl_iff.2 <| hVo i) (hWc i)\n      (disjoint_right.2 fun x hx => Classical.not_not.2 (hWV i hx))\n  have hsupp i : support (f i) ⊆ V i := support_subset_iff'.2 (hf0 i)\n  refine ⟨⟨f, hf.subset fun i => Subset.trans (hsupp i) (hVU' i), fun i x => (hf01 i x).1,\n      fun i x => (hf01 i x).2, fun x hx => ?_⟩,\n    hfp, fun i => Subset.trans (closure_mono (hsupp i)) (hVU i),\n    fun i => IsCompact.of_isClosed_subset (hcp i) isClosed_closure <| closure_mono (hsupp i)⟩\n  rcases mem_iUnion.1 (hsW hx) with ⟨i, hi⟩\n  exact ⟨i, ((hf1 i).mono subset_closure).eventuallyEq_of_mem ((hWo i).mem_nhds hi)⟩\n\n"}
{"name":"BumpCovering.exists_isSubordinate_hasCompactSupport_of_locallyFinite_t2space","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u\nX : Type v\ninst✝² : TopologicalSpace X\ns : Set X\ninst✝¹ : LocallyCompactSpace X\ninst✝ : T2Space X\nhs : IsCompact s\nU : ι → Set X\nho : ∀ (i : ι), IsOpen (U i)\nhf : LocallyFinite U\nhU : HasSubset.Subset s (Set.iUnion fun i => U i)\n⊢ Exists fun f => And (f.IsSubordinate U) (∀ (i : ι), HasCompactSupport ⇑(f i))","decl":"/-- If `X` is a normal topological space and `U i`, `i : ι`, is a locally finite open covering of a\nclosed set `s`, then there exists a `BumpCovering ι X s` that is subordinate to `U`. If `X` is a\nparacompact space, then the assumption `hf : LocallyFinite U` can be omitted, see\n`BumpCovering.exists_isSubordinate`. -/\ntheorem exists_isSubordinate_hasCompactSupport_of_locallyFinite_t2space [LocallyCompactSpace X]\n    [T2Space X]\n    (hs : IsCompact s) (U : ι → Set X) (ho : ∀ i, IsOpen (U i)) (hf : LocallyFinite U)\n    (hU : s ⊆ ⋃ i, U i) :\n    ∃ f : BumpCovering ι X s, f.IsSubordinate U ∧ ∀ i, HasCompactSupport (f i) := by\n  -- need to switch 0 and 1 in `exists_continuous_zero_one_of_isCompact`\n  simpa using\n    exists_isSubordinate_of_locallyFinite_of_prop_t2space (fun _ => True)\n      (fun _ _ ht hs hd =>\n        (exists_continuous_zero_one_of_isCompact' hs ht hd.symm).imp fun _ hf => ⟨trivial, hf⟩)\n      hs U ho hf hU\n\n"}
{"name":"BumpCovering.eventuallyEq_one","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u\nX : Type v\ninst✝ : TopologicalSpace X\ns : Set X\nf : BumpCovering ι X s\nx : X\nhx : Membership.mem s x\n⊢ (nhds x).EventuallyEq (⇑(f (f.ind x hx))) 1","decl":"theorem eventuallyEq_one (x : X) (hx : x ∈ s) : f (f.ind x hx) =ᶠ[𝓝 x] 1 :=\n  (f.eventuallyEq_one' x hx).choose_spec\n\n"}
{"name":"BumpCovering.ind_apply","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u\nX : Type v\ninst✝ : TopologicalSpace X\ns : Set X\nf : BumpCovering ι X s\nx : X\nhx : Membership.mem s x\n⊢ Eq ((f (f.ind x hx)) x) 1","decl":"theorem ind_apply (x : X) (hx : x ∈ s) : f (f.ind x hx) x = 1 :=\n  (f.eventuallyEq_one x hx).eq_of_nhds\n\n"}
{"name":"BumpCovering.toPOUFun_zero_of_zero","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u\nX : Type v\ninst✝ : TopologicalSpace X\ns : Set X\nf : BumpCovering ι X s\ni : ι\nx : X\nh : Eq ((f i) x) 0\n⊢ Eq (f.toPOUFun i x) 0","decl":"theorem toPOUFun_zero_of_zero {i : ι} {x : X} (h : f i x = 0) : f.toPOUFun i x = 0 := by\n  rw [toPOUFun, h, zero_mul]\n\n"}
{"name":"BumpCovering.support_toPOUFun_subset","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u\nX : Type v\ninst✝ : TopologicalSpace X\ns : Set X\nf : BumpCovering ι X s\ni : ι\n⊢ HasSubset.Subset (Function.support (f.toPOUFun i)) (Function.support ⇑(f i))","decl":"theorem support_toPOUFun_subset (i : ι) : support (f.toPOUFun i) ⊆ support (f i) :=\n  fun _ => mt <| f.toPOUFun_zero_of_zero\n\n"}
{"name":"BumpCovering.toPOUFun_eq_mul_prod","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u\nX : Type v\ninst✝ : TopologicalSpace X\ns : Set X\nf : BumpCovering ι X s\ni : ι\nx : X\nt : Finset ι\nht : ∀ (j : ι), WellOrderingRel j i → Ne ((f j) x) 0 → Membership.mem t j\n⊢ Eq (f.toPOUFun i x) (HMul.hMul ((f i) x) ((Finset.filter (fun j => WellOrderingRel j i) t).prod fun j => HSub.hSub 1 ((f j) x)))","decl":"open Classical in\ntheorem toPOUFun_eq_mul_prod (i : ι) (x : X) (t : Finset ι)\n    (ht : ∀ j, WellOrderingRel j i → f j x ≠ 0 → j ∈ t) :\n    f.toPOUFun i x = f i x * ∏ j ∈ t.filter fun j => WellOrderingRel j i, (1 - f j x) := by\n  refine congr_arg _ (finprod_cond_eq_prod_of_cond_iff _ fun {j} hj => ?_)\n  rw [Ne, sub_eq_self] at hj\n  rw [Finset.mem_filter, Iff.comm, and_iff_right_iff_imp]\n  exact flip (ht j) hj\n\n"}
{"name":"BumpCovering.sum_toPOUFun_eq","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u\nX : Type v\ninst✝ : TopologicalSpace X\ns : Set X\nf : BumpCovering ι X s\nx : X\n⊢ Eq (finsum fun i => f.toPOUFun i x) (HSub.hSub 1 (finprod fun i => HSub.hSub 1 ((f i) x)))","decl":"theorem sum_toPOUFun_eq (x : X) : ∑ᶠ i, f.toPOUFun i x = 1 - ∏ᶠ i, (1 - f i x) := by\n  set s := (f.point_finite x).toFinset\n  have hs : (s : Set ι) = { i | f i x ≠ 0 } := Finite.coe_toFinset _\n  have A : (support fun i => toPOUFun f i x) ⊆ s := by\n    rw [hs]\n    exact fun i hi => f.support_toPOUFun_subset i hi\n  have B : (mulSupport fun i => 1 - f i x) ⊆ s := by\n    rw [hs, mulSupport_one_sub]\n    exact fun i => id\n  classical\n  letI : LinearOrder ι := linearOrderOfSTO WellOrderingRel\n  rw [finsum_eq_sum_of_support_subset _ A, finprod_eq_prod_of_mulSupport_subset _ B,\n    Finset.prod_one_sub_ordered, sub_sub_cancel]\n  refine Finset.sum_congr rfl fun i _ => ?_\n  convert f.toPOUFun_eq_mul_prod _ _ _ fun j _ hj => _\n  rwa [Finite.mem_toFinset]\n\n"}
{"name":"BumpCovering.exists_finset_toPOUFun_eventuallyEq","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u\nX : Type v\ninst✝ : TopologicalSpace X\ns : Set X\nf : BumpCovering ι X s\ni : ι\nx : X\n⊢ Exists fun t => (nhds x).EventuallyEq (f.toPOUFun i) (HMul.hMul ⇑(f i) ⇑((Finset.filter (fun j => WellOrderingRel j i) t).prod fun j => HSub.hSub 1 (f j)))","decl":"open Classical in\ntheorem exists_finset_toPOUFun_eventuallyEq (i : ι) (x : X) : ∃ t : Finset ι,\n    f.toPOUFun i =ᶠ[𝓝 x] f i * ∏ j ∈ t.filter fun j => WellOrderingRel j i, (1 - f j) := by\n  rcases f.locallyFinite x with ⟨U, hU, hf⟩\n  use hf.toFinset\n  filter_upwards [hU] with y hyU\n  simp only [ContinuousMap.coe_prod, Pi.mul_apply, Finset.prod_apply]\n  apply toPOUFun_eq_mul_prod\n  intro j _ hj\n  exact hf.mem_toFinset.2 ⟨y, ⟨hj, hyU⟩⟩\n\n"}
{"name":"BumpCovering.continuous_toPOUFun","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u\nX : Type v\ninst✝ : TopologicalSpace X\ns : Set X\nf : BumpCovering ι X s\ni : ι\n⊢ Continuous (f.toPOUFun i)","decl":"theorem continuous_toPOUFun (i : ι) : Continuous (f.toPOUFun i) := by\n  refine (f i).continuous.mul <|\n    continuous_finprod_cond (fun j _ => continuous_const.sub (f j).continuous) ?_\n  simp only [mulSupport_one_sub]\n  exact f.locallyFinite\n\n"}
{"name":"BumpCovering.toPartitionOfUnity_apply","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u\nX : Type v\ninst✝ : TopologicalSpace X\ns : Set X\nf : BumpCovering ι X s\ni : ι\nx : X\n⊢ Eq ((f.toPartitionOfUnity i) x) (HMul.hMul ((f i) x) (finprod fun j => finprod fun x_1 => HSub.hSub 1 ((f j) x)))","decl":"theorem toPartitionOfUnity_apply (i : ι) (x : X) :\n    f.toPartitionOfUnity i x = f i x * ∏ᶠ (j) (_ : WellOrderingRel j i), (1 - f j x) := rfl\n\n"}
{"name":"BumpCovering.toPartitionOfUnity_eq_mul_prod","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u\nX : Type v\ninst✝ : TopologicalSpace X\ns : Set X\nf : BumpCovering ι X s\ni : ι\nx : X\nt : Finset ι\nht : ∀ (j : ι), WellOrderingRel j i → Ne ((f j) x) 0 → Membership.mem t j\n⊢ Eq ((f.toPartitionOfUnity i) x) (HMul.hMul ((f i) x) ((Finset.filter (fun j => WellOrderingRel j i) t).prod fun j => HSub.hSub 1 ((f j) x)))","decl":"open Classical in\ntheorem toPartitionOfUnity_eq_mul_prod (i : ι) (x : X) (t : Finset ι)\n    (ht : ∀ j, WellOrderingRel j i → f j x ≠ 0 → j ∈ t) :\n    f.toPartitionOfUnity i x = f i x * ∏ j ∈ t.filter fun j => WellOrderingRel j i, (1 - f j x) :=\n  f.toPOUFun_eq_mul_prod i x t ht\n\n"}
{"name":"BumpCovering.exists_finset_toPartitionOfUnity_eventuallyEq","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u\nX : Type v\ninst✝ : TopologicalSpace X\ns : Set X\nf : BumpCovering ι X s\ni : ι\nx : X\n⊢ Exists fun t => (nhds x).EventuallyEq (⇑(f.toPartitionOfUnity i)) (HMul.hMul ⇑(f i) ⇑((Finset.filter (fun j => WellOrderingRel j i) t).prod fun j => HSub.hSub 1 (f j)))","decl":"open Classical in\ntheorem exists_finset_toPartitionOfUnity_eventuallyEq (i : ι) (x : X) : ∃ t : Finset ι,\n    f.toPartitionOfUnity i =ᶠ[𝓝 x] f i * ∏ j ∈ t.filter fun j => WellOrderingRel j i, (1 - f j) :=\n  f.exists_finset_toPOUFun_eventuallyEq i x\n\n"}
{"name":"BumpCovering.toPartitionOfUnity_zero_of_zero","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u\nX : Type v\ninst✝ : TopologicalSpace X\ns : Set X\nf : BumpCovering ι X s\ni : ι\nx : X\nh : Eq ((f i) x) 0\n⊢ Eq ((f.toPartitionOfUnity i) x) 0","decl":"theorem toPartitionOfUnity_zero_of_zero {i : ι} {x : X} (h : f i x = 0) :\n    f.toPartitionOfUnity i x = 0 :=\n  f.toPOUFun_zero_of_zero h\n\n"}
{"name":"BumpCovering.support_toPartitionOfUnity_subset","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u\nX : Type v\ninst✝ : TopologicalSpace X\ns : Set X\nf : BumpCovering ι X s\ni : ι\n⊢ HasSubset.Subset (Function.support ⇑(f.toPartitionOfUnity i)) (Function.support ⇑(f i))","decl":"theorem support_toPartitionOfUnity_subset (i : ι) :\n    support (f.toPartitionOfUnity i) ⊆ support (f i) :=\n  f.support_toPOUFun_subset i\n\n"}
{"name":"BumpCovering.sum_toPartitionOfUnity_eq","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u\nX : Type v\ninst✝ : TopologicalSpace X\ns : Set X\nf : BumpCovering ι X s\nx : X\n⊢ Eq (finsum fun i => (f.toPartitionOfUnity i) x) (HSub.hSub 1 (finprod fun i => HSub.hSub 1 ((f i) x)))","decl":"theorem sum_toPartitionOfUnity_eq (x : X) :\n    ∑ᶠ i, f.toPartitionOfUnity i x = 1 - ∏ᶠ i, (1 - f i x) :=\n  f.sum_toPOUFun_eq x\n\n"}
{"name":"BumpCovering.IsSubordinate.toPartitionOfUnity","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u\nX : Type v\ninst✝ : TopologicalSpace X\ns : Set X\nf : BumpCovering ι X s\nU : ι → Set X\nh : f.IsSubordinate U\n⊢ f.toPartitionOfUnity.IsSubordinate U","decl":"theorem IsSubordinate.toPartitionOfUnity {f : BumpCovering ι X s} {U : ι → Set X}\n    (h : f.IsSubordinate U) : f.toPartitionOfUnity.IsSubordinate U :=\n  fun i => Subset.trans (closure_mono <| f.support_toPartitionOfUnity_subset i) (h i)\n\n"}
{"name":"PartitionOfUnity.exists_isSubordinate_of_locallyFinite","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u\nX : Type v\ninst✝¹ : TopologicalSpace X\ns : Set X\ninst✝ : NormalSpace X\nhs : IsClosed s\nU : ι → Set X\nho : ∀ (i : ι), IsOpen (U i)\nhf : LocallyFinite U\nhU : HasSubset.Subset s (Set.iUnion fun i => U i)\n⊢ Exists fun f => f.IsSubordinate U","decl":"/-- If `X` is a normal topological space and `U` is a locally finite open covering of a closed set\n`s`, then there exists a `PartitionOfUnity ι X s` that is subordinate to `U`. If `X` is a\nparacompact space, then the assumption `hf : LocallyFinite U` can be omitted, see\n`BumpCovering.exists_isSubordinate`. -/\ntheorem exists_isSubordinate_of_locallyFinite [NormalSpace X] (hs : IsClosed s) (U : ι → Set X)\n    (ho : ∀ i, IsOpen (U i)) (hf : LocallyFinite U) (hU : s ⊆ ⋃ i, U i) :\n    ∃ f : PartitionOfUnity ι X s, f.IsSubordinate U :=\n  let ⟨f, hf⟩ := BumpCovering.exists_isSubordinate_of_locallyFinite hs U ho hf hU\n  ⟨f.toPartitionOfUnity, hf.toPartitionOfUnity⟩\n\n"}
{"name":"PartitionOfUnity.exists_isSubordinate","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u\nX : Type v\ninst✝² : TopologicalSpace X\ns : Set X\ninst✝¹ : NormalSpace X\ninst✝ : ParacompactSpace X\nhs : IsClosed s\nU : ι → Set X\nho : ∀ (i : ι), IsOpen (U i)\nhU : HasSubset.Subset s (Set.iUnion fun i => U i)\n⊢ Exists fun f => f.IsSubordinate U","decl":"/-- If `X` is a paracompact normal topological space and `U` is an open covering of a closed set\n`s`, then there exists a `PartitionOfUnity ι X s` that is subordinate to `U`. -/\ntheorem exists_isSubordinate [NormalSpace X] [ParacompactSpace X] (hs : IsClosed s) (U : ι → Set X)\n    (ho : ∀ i, IsOpen (U i)) (hU : s ⊆ ⋃ i, U i) :\n    ∃ f : PartitionOfUnity ι X s, f.IsSubordinate U :=\n  let ⟨f, hf⟩ := BumpCovering.exists_isSubordinate hs U ho hU\n  ⟨f.toPartitionOfUnity, hf.toPartitionOfUnity⟩\n\n"}
{"name":"PartitionOfUnity.exists_isSubordinate_of_locallyFinite_t2space","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"ι : Type u\nX : Type v\ninst✝² : TopologicalSpace X\ns : Set X\ninst✝¹ : LocallyCompactSpace X\ninst✝ : T2Space X\nhs : IsCompact s\nU : ι → Set X\nho : ∀ (i : ι), IsOpen (U i)\nhf : LocallyFinite U\nhU : HasSubset.Subset s (Set.iUnion fun i => U i)\n⊢ Exists fun f => And (f.IsSubordinate U) (∀ (i : ι), HasCompactSupport ⇑(f i))","decl":"/-- If `X` is a locally compact T2 topological space and `U` is a locally finite open covering of a\ncompact set `s`, then there exists a `PartitionOfUnity ι X s` that is subordinate to `U`. -/\ntheorem exists_isSubordinate_of_locallyFinite_t2space [LocallyCompactSpace X] [T2Space X]\n    (hs : IsCompact s) (U : ι → Set X) (ho : ∀ i, IsOpen (U i)) (hf : LocallyFinite U)\n    (hU : s ⊆ ⋃ i, U i) :\n    ∃ f : PartitionOfUnity ι X s, f.IsSubordinate U ∧ ∀ i, HasCompactSupport (f i) :=\n  let ⟨f, hfsub, hfcp⟩ :=\n    BumpCovering.exists_isSubordinate_hasCompactSupport_of_locallyFinite_t2space hs U ho hf hU\n  ⟨f.toPartitionOfUnity, hfsub.toPartitionOfUnity, fun i => IsCompact.of_isClosed_subset (hfcp i)\n    isClosed_closure <| closure_mono (f.support_toPartitionOfUnity_subset i)⟩\n\n"}
{"name":"exists_continuous_sum_one_of_isOpen_isCompact","module":"Mathlib.Topology.PartitionOfUnity","initialProofState":"X : Type v\ninst✝² : TopologicalSpace X\ninst✝¹ : T2Space X\ninst✝ : LocallyCompactSpace X\nn : Nat\nt : Set X\ns : Fin n → Set X\nhs : ∀ (i : Fin n), IsOpen (s i)\nhtcp : IsCompact t\nhst : HasSubset.Subset t (Set.iUnion fun i => s i)\n⊢ Exists fun f => And (∀ (i : Fin n), HasSubset.Subset (tsupport ⇑(f i)) (s i)) (And (Set.EqOn (Finset.univ.sum fun i => ⇑(f i)) 1 t) (And (∀ (i : Fin n) (x : X), Membership.mem (Set.Icc 0 1) ((f i) x)) (∀ (i : Fin n), HasCompactSupport ⇑(f i))))","decl":"/-- A variation of **Urysohn's lemma**.\n\nIn a locally compact T2 space `X`, for a compact set `t` and a finite family of open sets `{s i}_i`\nsuch that `t ⊆ ⋃ i, s i`, there is a family of compactly supported continuous functions `{f i}_i`\nsupported in `s i`, `∑ i, f i x = 1` on `t` and `0 ≤ f i x ≤ 1`. -/\ntheorem exists_continuous_sum_one_of_isOpen_isCompact [T2Space X] [LocallyCompactSpace X]\n    {n : ℕ} {t : Set X} {s : Fin n → Set X} (hs : ∀ (i : Fin n), IsOpen (s i)) (htcp : IsCompact t)\n    (hst : t ⊆ ⋃ i, s i) :\n    ∃ f : Fin n → C(X, ℝ), (∀ (i : Fin n), tsupport (f i) ⊆ s i) ∧ EqOn (∑ i, f i) 1 t\n      ∧ (∀ (i : Fin n), ∀ (x : X), f i x ∈ Icc (0 : ℝ) 1)\n      ∧ (∀ (i : Fin n), HasCompactSupport (f i)) := by\n  obtain ⟨f, hfsub, hfcp⟩ := PartitionOfUnity.exists_isSubordinate_of_locallyFinite_t2space htcp s\n    hs (locallyFinite_of_finite _) hst\n  use f\n  refine ⟨fun i ↦ hfsub i, ?_, ?_, fun i => hfcp i⟩\n  · intro x hx\n    simp only [Finset.sum_apply, Pi.one_apply]\n    have h := f.sum_eq_one' x hx\n    simp at h\n    rw [finsum_eq_sum (fun i => (f.toFun i) x)\n      (Finite.subset finite_univ (subset_univ (support fun i ↦ (f.toFun i) x)))] at h\n    simp only [Finite.toFinset_setOf, ne_eq] at h\n    rw [← h, ← Finset.sum_subset\n      (Finset.subset_univ (Finset.filter (fun (j : Fin n) ↦ ¬(f.toFun j) x = 0) Finset.univ))\n      (by intro j hju hj\n          simp only [Finset.mem_filter, Finset.mem_univ, true_and, Decidable.not_not] at hj\n          exact hj)]\n    rfl\n  intro i x\n  exact ⟨f.nonneg i x, PartitionOfUnity.le_one f i x⟩\n"}
