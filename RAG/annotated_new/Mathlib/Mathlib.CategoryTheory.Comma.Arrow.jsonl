{"name":"CategoryTheory.Arrow.hom_ext_iff","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"T : Type u\ninst‚úù : CategoryTheory.Category.{v, u} T\nX Y : CategoryTheory.Arrow T\nf g : Quiver.Hom X Y\n‚ä¢ Iff (Eq f g) (And (Eq f.left g.left) (Eq f.right g.right))","decl":"@[ext]\nlemma hom_ext {X Y : Arrow T} (f g : X ‚ü∂ Y) (h‚ÇÅ : f.left = g.left) (h‚ÇÇ : f.right = g.right) :\n    f = g :=\n  CommaMorphism.ext h‚ÇÅ h‚ÇÇ\n\n"}
{"name":"CategoryTheory.Arrow.hom_ext","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"T : Type u\ninst‚úù : CategoryTheory.Category.{v, u} T\nX Y : CategoryTheory.Arrow T\nf g : Quiver.Hom X Y\nh‚ÇÅ : Eq f.left g.left\nh‚ÇÇ : Eq f.right g.right\n‚ä¢ Eq f g","decl":"@[ext]\nlemma hom_ext {X Y : Arrow T} (f g : X ‚ü∂ Y) (h‚ÇÅ : f.left = g.left) (h‚ÇÇ : f.right = g.right) :\n    f = g :=\n  CommaMorphism.ext h‚ÇÅ h‚ÇÇ\n\n"}
{"name":"CategoryTheory.Arrow.id_left","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"T : Type u\ninst‚úù : CategoryTheory.Category.{v, u} T\nf : CategoryTheory.Arrow T\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id f).left (CategoryTheory.CategoryStruct.id f.left)","decl":"@[simp]\ntheorem id_left (f : Arrow T) : CommaMorphism.left (ùüô f) = ùüô f.left :=\n  rfl\n\n"}
{"name":"CategoryTheory.Arrow.id_right","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"T : Type u\ninst‚úù : CategoryTheory.Category.{v, u} T\nf : CategoryTheory.Arrow T\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id f).right (CategoryTheory.CategoryStruct.id f.right)","decl":"@[simp]\ntheorem id_right (f : Arrow T) : CommaMorphism.right (ùüô f) = ùüô f.right :=\n  rfl\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/10688): added to ease automation\n"}
{"name":"CategoryTheory.Arrow.comp_left_assoc","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"T : Type u\ninst‚úù : CategoryTheory.Category.{v, u} T\nX Y Z‚úù : CategoryTheory.Arrow T\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z‚úù\nZ : T\nh : Quiver.Hom Z‚úù.left Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp f g).left h) (CategoryTheory.CategoryStruct.comp f.left (CategoryTheory.CategoryStruct.comp g.left h))","decl":"@[simp, reassoc]\ntheorem comp_left {X Y Z : Arrow T} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) :\n    (f ‚â´ g).left = f.left ‚â´ g.left := rfl\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/10688): added to ease automation\n"}
{"name":"CategoryTheory.Arrow.comp_left","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"T : Type u\ninst‚úù : CategoryTheory.Category.{v, u} T\nX Y Z : CategoryTheory.Arrow T\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f g).left (CategoryTheory.CategoryStruct.comp f.left g.left)","decl":"@[simp, reassoc]\ntheorem comp_left {X Y Z : Arrow T} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) :\n    (f ‚â´ g).left = f.left ‚â´ g.left := rfl\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/10688): added to ease automation\n"}
{"name":"CategoryTheory.Arrow.comp_right","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"T : Type u\ninst‚úù : CategoryTheory.Category.{v, u} T\nX Y Z : CategoryTheory.Arrow T\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f g).right (CategoryTheory.CategoryStruct.comp f.right g.right)","decl":"@[simp, reassoc]\ntheorem comp_right {X Y Z : Arrow T} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) :\n    (f ‚â´ g).right = f.right ‚â´ g.right := rfl\n\n"}
{"name":"CategoryTheory.Arrow.comp_right_assoc","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"T : Type u\ninst‚úù : CategoryTheory.Category.{v, u} T\nX Y Z‚úù : CategoryTheory.Arrow T\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z‚úù\nZ : T\nh : Quiver.Hom Z‚úù.right Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp f g).right h) (CategoryTheory.CategoryStruct.comp f.right (CategoryTheory.CategoryStruct.comp g.right h))","decl":"@[simp, reassoc]\ntheorem comp_right {X Y Z : Arrow T} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) :\n    (f ‚â´ g).right = f.right ‚â´ g.right := rfl\n\n"}
{"name":"CategoryTheory.Arrow.mk_left","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"T : Type u\ninst‚úù : CategoryTheory.Category.{v, u} T\nX Y : T\nf : Quiver.Hom X Y\n‚ä¢ Eq (CategoryTheory.Arrow.mk f).left X","decl":"/-- An object in the arrow category is simply a morphism in `T`. -/\n@[simps]\ndef mk {X Y : T} (f : X ‚ü∂ Y) : Arrow T where\n  left := X\n  right := Y\n  hom := f\n\n"}
{"name":"CategoryTheory.Arrow.mk_hom","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"T : Type u\ninst‚úù : CategoryTheory.Category.{v, u} T\nX Y : T\nf : Quiver.Hom X Y\n‚ä¢ Eq (CategoryTheory.Arrow.mk f).hom f","decl":"/-- An object in the arrow category is simply a morphism in `T`. -/\n@[simps]\ndef mk {X Y : T} (f : X ‚ü∂ Y) : Arrow T where\n  left := X\n  right := Y\n  hom := f\n\n"}
{"name":"CategoryTheory.Arrow.mk_right","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"T : Type u\ninst‚úù : CategoryTheory.Category.{v, u} T\nX Y : T\nf : Quiver.Hom X Y\n‚ä¢ Eq (CategoryTheory.Arrow.mk f).right Y","decl":"/-- An object in the arrow category is simply a morphism in `T`. -/\n@[simps]\ndef mk {X Y : T} (f : X ‚ü∂ Y) : Arrow T where\n  left := X\n  right := Y\n  hom := f\n\n"}
{"name":"CategoryTheory.Arrow.mk_eq","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"T : Type u\ninst‚úù : CategoryTheory.Category.{v, u} T\nf : CategoryTheory.Arrow T\n‚ä¢ Eq (CategoryTheory.Arrow.mk f.hom) f","decl":"@[simp]\ntheorem mk_eq (f : Arrow T) : Arrow.mk f.hom = f := by\n  cases f\n  rfl\n\n"}
{"name":"CategoryTheory.Arrow.mk_injective","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"T : Type u\ninst‚úù : CategoryTheory.Category.{v, u} T\nA B : T\n‚ä¢ Function.Injective CategoryTheory.Arrow.mk","decl":"theorem mk_injective (A B : T) :\n    Function.Injective (Arrow.mk : (A ‚ü∂ B) ‚Üí Arrow T) := fun f g h => by\n  cases h\n  rfl\n\n"}
{"name":"CategoryTheory.Arrow.mk_inj","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"T : Type u\ninst‚úù : CategoryTheory.Category.{v, u} T\nA B : T\nf g : Quiver.Hom A B\n‚ä¢ Iff (Eq (CategoryTheory.Arrow.mk f) (CategoryTheory.Arrow.mk g)) (Eq f g)","decl":"theorem mk_inj (A B : T) {f g : A ‚ü∂ B} : Arrow.mk f = Arrow.mk g ‚Üî f = g :=\n  (mk_injective A B).eq_iff\n\n"}
{"name":"CategoryTheory.Arrow.mk_eq_mk_iff","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"T : Type u\ninst‚úù : CategoryTheory.Category.{v, u} T\nX Y X' Y' : T\nf : Quiver.Hom X Y\nf' : Quiver.Hom X' Y'\n‚ä¢ Iff (Eq (CategoryTheory.Arrow.mk f) (CategoryTheory.Arrow.mk f')) (Exists fun hX => Exists fun hY => Eq f (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom hX) (CategoryTheory.CategoryStruct.comp f' (CategoryTheory.eqToHom ‚ãØ))))","decl":"lemma mk_eq_mk_iff {X Y X' Y' : T} (f : X ‚ü∂ Y) (f' : X' ‚ü∂ Y') :\n    Arrow.mk f = Arrow.mk f' ‚Üî\n      ‚àÉ (hX : X = X') (hY : Y = Y'), f = eqToHom hX ‚â´ f' ‚â´ eqToHom hY.symm := by\n  constructor\n  ¬∑ intro h\n    refine ‚ü®congr_arg Comma.left h, congr_arg Comma.right h, ?_‚ü©\n    have := (eqToIso h).hom.w\n    dsimp at this\n    rw [Comma.eqToHom_left, Comma.eqToHom_right] at this\n    rw [reassoc_of% this, eqToHom_trans, eqToHom_refl, Category.comp_id]\n  ¬∑ rintro ‚ü®rfl, rfl, h‚ü©\n    simp only [eqToHom_refl, Category.comp_id, Category.id_comp] at h\n    rw [h]\n\n"}
{"name":"CategoryTheory.Arrow.ext","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"T : Type u\ninst‚úù : CategoryTheory.Category.{v, u} T\nf g : CategoryTheory.Arrow T\nh‚ÇÅ : Eq f.left g.left\nh‚ÇÇ : Eq f.right g.right\nh‚ÇÉ : Eq f.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom h‚ÇÅ) (CategoryTheory.CategoryStruct.comp g.hom (CategoryTheory.eqToHom ‚ãØ)))\n‚ä¢ Eq f g","decl":"lemma ext {f g : Arrow T}\n    (h‚ÇÅ : f.left = g.left) (h‚ÇÇ : f.right = g.right)\n    (h‚ÇÉ : f.hom = eqToHom h‚ÇÅ ‚â´ g.hom ‚â´ eqToHom h‚ÇÇ.symm) : f = g :=\n  (mk_eq_mk_iff _ _).2 (by aesop)\n\n"}
{"name":"CategoryTheory.Arrow.arrow_mk_comp_eqToHom","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"T : Type u\ninst‚úù : CategoryTheory.Category.{v, u} T\nX Y Y' : T\nf : Quiver.Hom X Y\nh : Eq Y Y'\n‚ä¢ Eq (CategoryTheory.Arrow.mk (CategoryTheory.CategoryStruct.comp f (CategoryTheory.eqToHom h))) (CategoryTheory.Arrow.mk f)","decl":"@[simp]\nlemma arrow_mk_comp_eqToHom {X Y Y' : T} (f : X ‚ü∂ Y) (h : Y = Y') :\n    Arrow.mk (f ‚â´ eqToHom h) = Arrow.mk f :=\n  ext rfl h.symm (by simp)\n\n"}
{"name":"CategoryTheory.Arrow.arrow_mk_eqToHom_comp","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"T : Type u\ninst‚úù : CategoryTheory.Category.{v, u} T\nX' X Y : T\nf : Quiver.Hom X Y\nh : Eq X' X\n‚ä¢ Eq (CategoryTheory.Arrow.mk (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom h) f)) (CategoryTheory.Arrow.mk f)","decl":"@[simp]\nlemma arrow_mk_eqToHom_comp {X' X Y : T} (f : X ‚ü∂ Y) (h : X' = X) :\n    Arrow.mk (eqToHom h ‚â´ f) = Arrow.mk f :=\n  ext h rfl (by simp)\n\n"}
{"name":"CategoryTheory.Arrow.homMk_left","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"T : Type u\ninst‚úù : CategoryTheory.Category.{v, u} T\nf g : CategoryTheory.Arrow T\nu : Quiver.Hom f.left g.left\nv : Quiver.Hom f.right g.right\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp u g.hom) (CategoryTheory.CategoryStruct.comp f.hom v)) _auto‚úù\n‚ä¢ Eq (CategoryTheory.Arrow.homMk u v w).left u","decl":"/-- A morphism in the arrow category is a commutative square connecting two objects of the arrow\n    category. -/\n@[simps]\ndef homMk {f g : Arrow T} (u : f.left ‚ü∂ g.left) (v : f.right ‚ü∂ g.right)\n    (w : u ‚â´ g.hom = f.hom ‚â´ v := by aesop_cat) : f ‚ü∂ g where\n  left := u\n  right := v\n  w := w\n\n"}
{"name":"CategoryTheory.Arrow.homMk_right","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"T : Type u\ninst‚úù : CategoryTheory.Category.{v, u} T\nf g : CategoryTheory.Arrow T\nu : Quiver.Hom f.left g.left\nv : Quiver.Hom f.right g.right\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp u g.hom) (CategoryTheory.CategoryStruct.comp f.hom v)) _auto‚úù\n‚ä¢ Eq (CategoryTheory.Arrow.homMk u v w).right v","decl":"/-- A morphism in the arrow category is a commutative square connecting two objects of the arrow\n    category. -/\n@[simps]\ndef homMk {f g : Arrow T} (u : f.left ‚ü∂ g.left) (v : f.right ‚ü∂ g.right)\n    (w : u ‚â´ g.hom = f.hom ‚â´ v := by aesop_cat) : f ‚ü∂ g where\n  left := u\n  right := v\n  w := w\n\n"}
{"name":"CategoryTheory.Arrow.homMk'_right","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"T : Type u\ninst‚úù : CategoryTheory.Category.{v, u} T\nX Y : T\nf : Quiver.Hom X Y\nP Q : T\ng : Quiver.Hom P Q\nu : Quiver.Hom X P\nv : Quiver.Hom Y Q\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp u g) (CategoryTheory.CategoryStruct.comp f v)) _auto‚úù\n‚ä¢ Eq (CategoryTheory.Arrow.homMk' u v w).right v","decl":"/-- We can also build a morphism in the arrow category out of any commutative square in `T`. -/\n@[simps]\ndef homMk' {X Y : T} {f : X ‚ü∂ Y} {P Q : T} {g : P ‚ü∂ Q} (u : X ‚ü∂ P) (v : Y ‚ü∂ Q)\n    (w : u ‚â´ g = f ‚â´ v := by aesop_cat) :\n    Arrow.mk f ‚ü∂ Arrow.mk g where\n  left := u\n  right := v\n  w := w\n\n/- Porting note: was warned simp could prove reassoc'd version. Found simp could not.\nAdded nolint. -/\n"}
{"name":"CategoryTheory.Arrow.homMk'_left","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"T : Type u\ninst‚úù : CategoryTheory.Category.{v, u} T\nX Y : T\nf : Quiver.Hom X Y\nP Q : T\ng : Quiver.Hom P Q\nu : Quiver.Hom X P\nv : Quiver.Hom Y Q\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp u g) (CategoryTheory.CategoryStruct.comp f v)) _auto‚úù\n‚ä¢ Eq (CategoryTheory.Arrow.homMk' u v w).left u","decl":"/-- We can also build a morphism in the arrow category out of any commutative square in `T`. -/\n@[simps]\ndef homMk' {X Y : T} {f : X ‚ü∂ Y} {P Q : T} {g : P ‚ü∂ Q} (u : X ‚ü∂ P) (v : Y ‚ü∂ Q)\n    (w : u ‚â´ g = f ‚â´ v := by aesop_cat) :\n    Arrow.mk f ‚ü∂ Arrow.mk g where\n  left := u\n  right := v\n  w := w\n\n/- Porting note: was warned simp could prove reassoc'd version. Found simp could not.\nAdded nolint. -/\n"}
{"name":"CategoryTheory.Arrow.w","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"T : Type u\ninst‚úù : CategoryTheory.Category.{v, u} T\nf g : CategoryTheory.Arrow T\nsq : Quiver.Hom f g\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp sq.left g.hom) (CategoryTheory.CategoryStruct.comp f.hom sq.right)","decl":"@[reassoc (attr := simp, nolint simpNF)]\ntheorem w {f g : Arrow T} (sq : f ‚ü∂ g) : sq.left ‚â´ g.hom = f.hom ‚â´ sq.right :=\n  sq.w\n\n-- `w_mk_left` is not needed, as it is a consequence of `w` and `mk_hom`.\n"}
{"name":"CategoryTheory.Arrow.w_assoc","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"T : Type u\ninst‚úù : CategoryTheory.Category.{v, u} T\nf g : CategoryTheory.Arrow T\nsq : Quiver.Hom f g\nZ : T\nh : Quiver.Hom g.right Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp sq.left (CategoryTheory.CategoryStruct.comp g.hom h)) (CategoryTheory.CategoryStruct.comp f.hom (CategoryTheory.CategoryStruct.comp sq.right h))","decl":"@[reassoc (attr := simp, nolint simpNF)]\ntheorem w {f g : Arrow T} (sq : f ‚ü∂ g) : sq.left ‚â´ g.hom = f.hom ‚â´ sq.right :=\n  sq.w\n\n-- `w_mk_left` is not needed, as it is a consequence of `w` and `mk_hom`.\n"}
{"name":"CategoryTheory.Arrow.w_mk_right","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"T : Type u\ninst‚úù : CategoryTheory.Category.{v, u} T\nf : CategoryTheory.Arrow T\nX Y : T\ng : Quiver.Hom X Y\nsq : Quiver.Hom f (CategoryTheory.Arrow.mk g)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp sq.left g) (CategoryTheory.CategoryStruct.comp f.hom sq.right)","decl":"@[reassoc (attr := simp)]\ntheorem w_mk_right {f : Arrow T} {X Y : T} {g : X ‚ü∂ Y} (sq : f ‚ü∂ mk g) :\n    sq.left ‚â´ g = f.hom ‚â´ sq.right :=\n  sq.w\n\n"}
{"name":"CategoryTheory.Arrow.w_mk_right_assoc","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"T : Type u\ninst‚úù : CategoryTheory.Category.{v, u} T\nf : CategoryTheory.Arrow T\nX Y : T\ng : Quiver.Hom X Y\nsq : Quiver.Hom f (CategoryTheory.Arrow.mk g)\nZ : T\nh : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp sq.left (CategoryTheory.CategoryStruct.comp g h)) (CategoryTheory.CategoryStruct.comp f.hom (CategoryTheory.CategoryStruct.comp sq.right h))","decl":"@[reassoc (attr := simp)]\ntheorem w_mk_right {f : Arrow T} {X Y : T} {g : X ‚ü∂ Y} (sq : f ‚ü∂ mk g) :\n    sq.left ‚â´ g = f.hom ‚â´ sq.right :=\n  sq.w\n\n"}
{"name":"CategoryTheory.Arrow.isIso_of_isIso_left_of_isIso_right","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"T : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} T\nf g : CategoryTheory.Arrow T\nff : Quiver.Hom f g\ninst‚úù¬π : CategoryTheory.IsIso ff.left\ninst‚úù : CategoryTheory.IsIso ff.right\n‚ä¢ CategoryTheory.IsIso ff","decl":"theorem isIso_of_isIso_left_of_isIso_right {f g : Arrow T} (ff : f ‚ü∂ g) [IsIso ff.left]\n    [IsIso ff.right] : IsIso ff where\n  out := by\n    let inverse : g ‚ü∂ f := ‚ü®inv ff.left, inv ff.right, (by simp)‚ü©\n    apply Exists.intro inverse\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Arrow.isoMk_inv_left","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"T : Type u\ninst‚úù : CategoryTheory.Category.{v, u} T\nf g : CategoryTheory.Arrow T\nl : CategoryTheory.Iso f.left g.left\nr : CategoryTheory.Iso f.right g.right\nh : autoParam (Eq (CategoryTheory.CategoryStruct.comp l.hom g.hom) (CategoryTheory.CategoryStruct.comp f.hom r.hom)) _auto‚úù\n‚ä¢ Eq (CategoryTheory.Arrow.isoMk l r h).inv.left l.inv","decl":"/-- Create an isomorphism between arrows,\nby providing isomorphisms between the domains and codomains,\nand a proof that the square commutes. -/\n@[simps!]\ndef isoMk {f g : Arrow T} (l : f.left ‚âÖ g.left) (r : f.right ‚âÖ g.right)\n    (h : l.hom ‚â´ g.hom = f.hom ‚â´ r.hom := by aesop_cat) : f ‚âÖ g :=\n  Comma.isoMk l r h\n\n"}
{"name":"CategoryTheory.Arrow.isoMk_hom_right","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"T : Type u\ninst‚úù : CategoryTheory.Category.{v, u} T\nf g : CategoryTheory.Arrow T\nl : CategoryTheory.Iso f.left g.left\nr : CategoryTheory.Iso f.right g.right\nh : autoParam (Eq (CategoryTheory.CategoryStruct.comp l.hom g.hom) (CategoryTheory.CategoryStruct.comp f.hom r.hom)) _auto‚úù\n‚ä¢ Eq (CategoryTheory.Arrow.isoMk l r h).hom.right r.hom","decl":"/-- Create an isomorphism between arrows,\nby providing isomorphisms between the domains and codomains,\nand a proof that the square commutes. -/\n@[simps!]\ndef isoMk {f g : Arrow T} (l : f.left ‚âÖ g.left) (r : f.right ‚âÖ g.right)\n    (h : l.hom ‚â´ g.hom = f.hom ‚â´ r.hom := by aesop_cat) : f ‚âÖ g :=\n  Comma.isoMk l r h\n\n"}
{"name":"CategoryTheory.Arrow.isoMk_hom_left","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"T : Type u\ninst‚úù : CategoryTheory.Category.{v, u} T\nf g : CategoryTheory.Arrow T\nl : CategoryTheory.Iso f.left g.left\nr : CategoryTheory.Iso f.right g.right\nh : autoParam (Eq (CategoryTheory.CategoryStruct.comp l.hom g.hom) (CategoryTheory.CategoryStruct.comp f.hom r.hom)) _auto‚úù\n‚ä¢ Eq (CategoryTheory.Arrow.isoMk l r h).hom.left l.hom","decl":"/-- Create an isomorphism between arrows,\nby providing isomorphisms between the domains and codomains,\nand a proof that the square commutes. -/\n@[simps!]\ndef isoMk {f g : Arrow T} (l : f.left ‚âÖ g.left) (r : f.right ‚âÖ g.right)\n    (h : l.hom ‚â´ g.hom = f.hom ‚â´ r.hom := by aesop_cat) : f ‚âÖ g :=\n  Comma.isoMk l r h\n\n"}
{"name":"CategoryTheory.Arrow.isoMk_inv_right","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"T : Type u\ninst‚úù : CategoryTheory.Category.{v, u} T\nf g : CategoryTheory.Arrow T\nl : CategoryTheory.Iso f.left g.left\nr : CategoryTheory.Iso f.right g.right\nh : autoParam (Eq (CategoryTheory.CategoryStruct.comp l.hom g.hom) (CategoryTheory.CategoryStruct.comp f.hom r.hom)) _auto‚úù\n‚ä¢ Eq (CategoryTheory.Arrow.isoMk l r h).inv.right r.inv","decl":"/-- Create an isomorphism between arrows,\nby providing isomorphisms between the domains and codomains,\nand a proof that the square commutes. -/\n@[simps!]\ndef isoMk {f g : Arrow T} (l : f.left ‚âÖ g.left) (r : f.right ‚âÖ g.right)\n    (h : l.hom ‚â´ g.hom = f.hom ‚â´ r.hom := by aesop_cat) : f ‚âÖ g :=\n  Comma.isoMk l r h\n\n"}
{"name":"CategoryTheory.Arrow.hom.congr_left","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"T : Type u\ninst‚úù : CategoryTheory.Category.{v, u} T\nf g : CategoryTheory.Arrow T\nœÜ‚ÇÅ œÜ‚ÇÇ : Quiver.Hom f g\nh : Eq œÜ‚ÇÅ œÜ‚ÇÇ\n‚ä¢ Eq œÜ‚ÇÅ.left œÜ‚ÇÇ.left","decl":"theorem hom.congr_left {f g : Arrow T} {œÜ‚ÇÅ œÜ‚ÇÇ : f ‚ü∂ g} (h : œÜ‚ÇÅ = œÜ‚ÇÇ) : œÜ‚ÇÅ.left = œÜ‚ÇÇ.left := by\n  rw [h]\n\n"}
{"name":"CategoryTheory.Arrow.hom.congr_right","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"T : Type u\ninst‚úù : CategoryTheory.Category.{v, u} T\nf g : CategoryTheory.Arrow T\nœÜ‚ÇÅ œÜ‚ÇÇ : Quiver.Hom f g\nh : Eq œÜ‚ÇÅ œÜ‚ÇÇ\n‚ä¢ Eq œÜ‚ÇÅ.right œÜ‚ÇÇ.right","decl":"@[simp]\ntheorem hom.congr_right {f g : Arrow T} {œÜ‚ÇÅ œÜ‚ÇÇ : f ‚ü∂ g} (h : œÜ‚ÇÅ = œÜ‚ÇÇ) : œÜ‚ÇÅ.right = œÜ‚ÇÇ.right := by\n  rw [h]\n\n"}
{"name":"CategoryTheory.Arrow.iso_w","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"T : Type u\ninst‚úù : CategoryTheory.Category.{v, u} T\nf g : CategoryTheory.Arrow T\ne : CategoryTheory.Iso f g\n‚ä¢ Eq g.hom (CategoryTheory.CategoryStruct.comp e.inv.left (CategoryTheory.CategoryStruct.comp f.hom e.hom.right))","decl":"theorem iso_w {f g : Arrow T} (e : f ‚âÖ g) : g.hom = e.inv.left ‚â´ f.hom ‚â´ e.hom.right := by\n  have eq := Arrow.hom.congr_right e.inv_hom_id\n  rw [Arrow.comp_right, Arrow.id_right] at eq\n  rw [Arrow.w_assoc, eq, Category.comp_id]\n\n"}
{"name":"CategoryTheory.Arrow.iso_w'","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"T : Type u\ninst‚úù : CategoryTheory.Category.{v, u} T\nW X Y Z : T\nf : Quiver.Hom W X\ng : Quiver.Hom Y Z\ne : CategoryTheory.Iso (CategoryTheory.Arrow.mk f) (CategoryTheory.Arrow.mk g)\n‚ä¢ Eq g (CategoryTheory.CategoryStruct.comp e.inv.left (CategoryTheory.CategoryStruct.comp f e.hom.right))","decl":"theorem iso_w' {W X Y Z : T} {f : W ‚ü∂ X} {g : Y ‚ü∂ Z} (e : Arrow.mk f ‚âÖ Arrow.mk g) :\n    g = e.inv.left ‚â´ f ‚â´ e.hom.right :=\n  iso_w e\n\n"}
{"name":"CategoryTheory.Arrow.isIso_left","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"T : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} T\nf g : CategoryTheory.Arrow T\nsq : Quiver.Hom f g\ninst‚úù : CategoryTheory.IsIso sq\n‚ä¢ CategoryTheory.IsIso sq.left","decl":"instance isIso_left [IsIso sq] : IsIso sq.left where\n  out := by\n    apply Exists.intro (inv sq).left\n    simp only [‚Üê Comma.comp_left, IsIso.hom_inv_id, IsIso.inv_hom_id, Arrow.id_left,\n      eq_self_iff_true, and_self_iff]\n    simp\n\n"}
{"name":"CategoryTheory.Arrow.isIso_right","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"T : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} T\nf g : CategoryTheory.Arrow T\nsq : Quiver.Hom f g\ninst‚úù : CategoryTheory.IsIso sq\n‚ä¢ CategoryTheory.IsIso sq.right","decl":"instance isIso_right [IsIso sq] : IsIso sq.right where\n  out := by\n    apply Exists.intro (inv sq).right\n    simp only [‚Üê Comma.comp_right, IsIso.hom_inv_id, IsIso.inv_hom_id, Arrow.id_right,\n      eq_self_iff_true, and_self_iff]\n    simp\n\n"}
{"name":"CategoryTheory.Arrow.isIso_of_isIso","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"T : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} T\nX Y : T\nf : Quiver.Hom X Y\ng : CategoryTheory.Arrow T\nsq : Quiver.Hom (CategoryTheory.Arrow.mk f) g\ninst‚úù¬π : CategoryTheory.IsIso sq\ninst‚úù : CategoryTheory.IsIso f\n‚ä¢ CategoryTheory.IsIso g.hom","decl":"lemma isIso_of_isIso {X Y : T} {f : X ‚ü∂ Y} {g : Arrow T} (sq : mk f ‚ü∂ g) [IsIso sq] [IsIso f] :\n    IsIso g.hom := by\n  rw [iso_w' (asIso sq)]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Arrow.isIso_hom_iff_isIso_hom_of_isIso","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"T : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} T\nf g : CategoryTheory.Arrow T\nsq : Quiver.Hom f g\ninst‚úù : CategoryTheory.IsIso sq\n‚ä¢ Iff (CategoryTheory.IsIso f.hom) (CategoryTheory.IsIso g.hom)","decl":"lemma isIso_hom_iff_isIso_hom_of_isIso {f g : Arrow T} (sq : f ‚ü∂ g) [IsIso sq] :\n    IsIso f.hom ‚Üî IsIso g.hom :=\n  ‚ü®fun _ => isIso_of_isIso sq, fun _ => isIso_of_isIso (inv sq)‚ü©\n\n"}
{"name":"CategoryTheory.Arrow.isIso_iff_isIso_of_isIso","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"T : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} T\nW X Y Z : T\nf : Quiver.Hom W X\ng : Quiver.Hom Y Z\nsq : Quiver.Hom (CategoryTheory.Arrow.mk f) (CategoryTheory.Arrow.mk g)\ninst‚úù : CategoryTheory.IsIso sq\n‚ä¢ Iff (CategoryTheory.IsIso f) (CategoryTheory.IsIso g)","decl":"lemma isIso_iff_isIso_of_isIso {W X Y Z : T} {f : W ‚ü∂ X} {g : Y ‚ü∂ Z} (sq : mk f ‚ü∂ mk g) [IsIso sq] :\n    IsIso f ‚Üî IsIso g :=\n  isIso_hom_iff_isIso_hom_of_isIso sq\n\n"}
{"name":"CategoryTheory.Arrow.isIso_hom_iff_isIso_of_isIso","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"T : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} T\nY Z : T\nf : CategoryTheory.Arrow T\ng : Quiver.Hom Y Z\nsq : Quiver.Hom f (CategoryTheory.Arrow.mk g)\ninst‚úù : CategoryTheory.IsIso sq\n‚ä¢ Iff (CategoryTheory.IsIso f.hom) (CategoryTheory.IsIso g)","decl":"lemma isIso_hom_iff_isIso_of_isIso {Y Z : T} {f : Arrow T} {g : Y ‚ü∂ Z} (sq : f ‚ü∂ mk g) [IsIso sq] :\n    IsIso f.hom ‚Üî IsIso g :=\n  isIso_hom_iff_isIso_hom_of_isIso sq\n\n"}
{"name":"CategoryTheory.Arrow.inv_left","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"T : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} T\nf g : CategoryTheory.Arrow T\nsq : Quiver.Hom f g\ninst‚úù : CategoryTheory.IsIso sq\n‚ä¢ Eq (CategoryTheory.inv sq).left (CategoryTheory.inv sq.left)","decl":"@[simp]\ntheorem inv_left [IsIso sq] : (inv sq).left = inv sq.left :=\n  IsIso.eq_inv_of_hom_inv_id <| by rw [‚Üê Comma.comp_left, IsIso.hom_inv_id, id_left]\n\n"}
{"name":"CategoryTheory.Arrow.inv_right","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"T : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} T\nf g : CategoryTheory.Arrow T\nsq : Quiver.Hom f g\ninst‚úù : CategoryTheory.IsIso sq\n‚ä¢ Eq (CategoryTheory.inv sq).right (CategoryTheory.inv sq.right)","decl":"@[simp]\ntheorem inv_right [IsIso sq] : (inv sq).right = inv sq.right :=\n  IsIso.eq_inv_of_hom_inv_id <| by rw [‚Üê Comma.comp_right, IsIso.hom_inv_id, id_right]\n\n"}
{"name":"CategoryTheory.Arrow.left_hom_inv_right","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"T : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} T\nf g : CategoryTheory.Arrow T\nsq : Quiver.Hom f g\ninst‚úù : CategoryTheory.IsIso sq\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp sq.left (CategoryTheory.CategoryStruct.comp g.hom (CategoryTheory.inv sq.right))) f.hom","decl":"theorem left_hom_inv_right [IsIso sq] : sq.left ‚â´ g.hom ‚â´ inv sq.right = f.hom := by\n  simp only [‚Üê Category.assoc, IsIso.comp_inv_eq, w]\n\n"}
{"name":"CategoryTheory.Arrow.inv_left_hom_right","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"T : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} T\nf g : CategoryTheory.Arrow T\nsq : Quiver.Hom f g\ninst‚úù : CategoryTheory.IsIso sq\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv sq.left) (CategoryTheory.CategoryStruct.comp f.hom sq.right)) g.hom","decl":"theorem inv_left_hom_right [IsIso sq] : inv sq.left ‚â´ f.hom ‚â´ sq.right = g.hom := by\n  simp only [w, IsIso.inv_comp_eq]\n\n"}
{"name":"CategoryTheory.Arrow.mono_left","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"T : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} T\nf g : CategoryTheory.Arrow T\nsq : Quiver.Hom f g\ninst‚úù : CategoryTheory.Mono sq\n‚ä¢ CategoryTheory.Mono sq.left","decl":"instance mono_left [Mono sq] : Mono sq.left where\n  right_cancellation {Z} œÜ œà h := by\n    let aux : (Z ‚ü∂ f.left) ‚Üí (Arrow.mk (ùüô Z) ‚ü∂ f) := fun œÜ =>\n      { left := œÜ\n        right := œÜ ‚â´ f.hom }\n    have : ‚àÄ g, (aux g).right = g ‚â´ f.hom := fun g => by dsimp\n    show (aux œÜ).left = (aux œà).left\n    congr 1\n    rw [‚Üê cancel_mono sq]\n    apply CommaMorphism.ext\n    ¬∑ exact h\n    ¬∑ rw [Comma.comp_right, Comma.comp_right, this, this, Category.assoc, Category.assoc]\n      rw [‚Üê Arrow.w]\n      simp only [‚Üê Category.assoc, h]\n\n"}
{"name":"CategoryTheory.Arrow.epi_right","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"T : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} T\nf g : CategoryTheory.Arrow T\nsq : Quiver.Hom f g\ninst‚úù : CategoryTheory.Epi sq\n‚ä¢ CategoryTheory.Epi sq.right","decl":"instance epi_right [Epi sq] : Epi sq.right where\n  left_cancellation {Z} œÜ œà h := by\n    let aux : (g.right ‚ü∂ Z) ‚Üí (g ‚ü∂ Arrow.mk (ùüô Z)) := fun œÜ =>\n      { right := œÜ\n        left := g.hom ‚â´ œÜ }\n    show (aux œÜ).right = (aux œà).right\n    congr 1\n    rw [‚Üê cancel_epi sq]\n    apply CommaMorphism.ext\n    ¬∑ rw [Comma.comp_left, Comma.comp_left, Arrow.w_assoc, Arrow.w_assoc, h]\n    ¬∑ exact h\n\n"}
{"name":"CategoryTheory.Arrow.hom_inv_id_left","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"T : Type u\ninst‚úù : CategoryTheory.Category.{v, u} T\nf g : CategoryTheory.Arrow T\ne : CategoryTheory.Iso f g\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp e.hom.left e.inv.left) (CategoryTheory.CategoryStruct.id f.left)","decl":"@[reassoc (attr := simp)]\nlemma hom_inv_id_left (e : f ‚âÖ g) : e.hom.left ‚â´ e.inv.left = ùüô _ := by\n  rw [‚Üê comp_left, e.hom_inv_id, id_left]\n\n"}
{"name":"CategoryTheory.Arrow.hom_inv_id_left_assoc","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"T : Type u\ninst‚úù : CategoryTheory.Category.{v, u} T\nf g : CategoryTheory.Arrow T\ne : CategoryTheory.Iso f g\nZ : T\nh : Quiver.Hom f.left Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp e.hom.left (CategoryTheory.CategoryStruct.comp e.inv.left h)) h","decl":"@[reassoc (attr := simp)]\nlemma hom_inv_id_left (e : f ‚âÖ g) : e.hom.left ‚â´ e.inv.left = ùüô _ := by\n  rw [‚Üê comp_left, e.hom_inv_id, id_left]\n\n"}
{"name":"CategoryTheory.Arrow.inv_hom_id_left","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"T : Type u\ninst‚úù : CategoryTheory.Category.{v, u} T\nf g : CategoryTheory.Arrow T\ne : CategoryTheory.Iso f g\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp e.inv.left e.hom.left) (CategoryTheory.CategoryStruct.id g.left)","decl":"@[reassoc (attr := simp)]\nlemma inv_hom_id_left (e : f ‚âÖ g) : e.inv.left ‚â´ e.hom.left = ùüô _ := by\n  rw [‚Üê comp_left, e.inv_hom_id, id_left]\n\n"}
{"name":"CategoryTheory.Arrow.inv_hom_id_left_assoc","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"T : Type u\ninst‚úù : CategoryTheory.Category.{v, u} T\nf g : CategoryTheory.Arrow T\ne : CategoryTheory.Iso f g\nZ : T\nh : Quiver.Hom g.left Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp e.inv.left (CategoryTheory.CategoryStruct.comp e.hom.left h)) h","decl":"@[reassoc (attr := simp)]\nlemma inv_hom_id_left (e : f ‚âÖ g) : e.inv.left ‚â´ e.hom.left = ùüô _ := by\n  rw [‚Üê comp_left, e.inv_hom_id, id_left]\n\n"}
{"name":"CategoryTheory.Arrow.hom_inv_id_right","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"T : Type u\ninst‚úù : CategoryTheory.Category.{v, u} T\nf g : CategoryTheory.Arrow T\ne : CategoryTheory.Iso f g\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp e.hom.right e.inv.right) (CategoryTheory.CategoryStruct.id f.right)","decl":"@[reassoc (attr := simp)]\nlemma hom_inv_id_right (e : f ‚âÖ g) : e.hom.right ‚â´ e.inv.right = ùüô _ := by\n  rw [‚Üê comp_right, e.hom_inv_id, id_right]\n\n"}
{"name":"CategoryTheory.Arrow.hom_inv_id_right_assoc","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"T : Type u\ninst‚úù : CategoryTheory.Category.{v, u} T\nf g : CategoryTheory.Arrow T\ne : CategoryTheory.Iso f g\nZ : T\nh : Quiver.Hom f.right Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp e.hom.right (CategoryTheory.CategoryStruct.comp e.inv.right h)) h","decl":"@[reassoc (attr := simp)]\nlemma hom_inv_id_right (e : f ‚âÖ g) : e.hom.right ‚â´ e.inv.right = ùüô _ := by\n  rw [‚Üê comp_right, e.hom_inv_id, id_right]\n\n"}
{"name":"CategoryTheory.Arrow.inv_hom_id_right_assoc","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"T : Type u\ninst‚úù : CategoryTheory.Category.{v, u} T\nf g : CategoryTheory.Arrow T\ne : CategoryTheory.Iso f g\nZ : T\nh : Quiver.Hom g.right Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp e.inv.right (CategoryTheory.CategoryStruct.comp e.hom.right h)) h","decl":"@[reassoc (attr := simp)]\nlemma inv_hom_id_right (e : f ‚âÖ g) : e.inv.right ‚â´ e.hom.right = ùüô _ := by\n  rw [‚Üê comp_right, e.inv_hom_id, id_right]\n\n"}
{"name":"CategoryTheory.Arrow.inv_hom_id_right","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"T : Type u\ninst‚úù : CategoryTheory.Category.{v, u} T\nf g : CategoryTheory.Arrow T\ne : CategoryTheory.Iso f g\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp e.inv.right e.hom.right) (CategoryTheory.CategoryStruct.id g.right)","decl":"@[reassoc (attr := simp)]\nlemma inv_hom_id_right (e : f ‚âÖ g) : e.inv.right ‚â´ e.hom.right = ùüô _ := by\n  rw [‚Üê comp_right, e.inv_hom_id, id_right]\n\n"}
{"name":"CategoryTheory.Arrow.square_to_iso_invert","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"T : Type u\ninst‚úù : CategoryTheory.Category.{v, u} T\ni : CategoryTheory.Arrow T\nX Y : T\np : CategoryTheory.Iso X Y\nsq : Quiver.Hom i (CategoryTheory.Arrow.mk p.hom)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp i.hom (CategoryTheory.CategoryStruct.comp sq.right p.inv)) sq.left","decl":"/-- Given a square from an arrow `i` to an isomorphism `p`, express the source part of `sq`\nin terms of the inverse of `p`. -/\n@[simp]\ntheorem square_to_iso_invert (i : Arrow T) {X Y : T} (p : X ‚âÖ Y) (sq : i ‚ü∂ Arrow.mk p.hom) :\n    i.hom ‚â´ sq.right ‚â´ p.inv = sq.left := by\n  simpa only [Category.assoc] using (Iso.comp_inv_eq p).mpr (Arrow.w_mk_right sq).symm\n\n"}
{"name":"CategoryTheory.Arrow.square_from_iso_invert","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"T : Type u\ninst‚úù : CategoryTheory.Category.{v, u} T\nX Y : T\ni : CategoryTheory.Iso X Y\np : CategoryTheory.Arrow T\nsq : Quiver.Hom (CategoryTheory.Arrow.mk i.hom) p\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp i.inv (CategoryTheory.CategoryStruct.comp sq.left p.hom)) sq.right","decl":"/-- Given a square from an isomorphism `i` to an arrow `p`, express the target part of `sq`\nin terms of the inverse of `i`. -/\ntheorem square_from_iso_invert {X Y : T} (i : X ‚âÖ Y) (p : Arrow T) (sq : Arrow.mk i.hom ‚ü∂ p) :\n    i.inv ‚â´ sq.left ‚â´ p.hom = sq.right := by simp only [Iso.inv_hom_id_assoc, Arrow.w, Arrow.mk_hom]\n\n"}
{"name":"CategoryTheory.Arrow.squareToSnd_left","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y Z : C\ni : CategoryTheory.Arrow C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nsq : Quiver.Hom i (CategoryTheory.Arrow.mk (CategoryTheory.CategoryStruct.comp f g))\n‚ä¢ Eq (CategoryTheory.Arrow.squareToSnd sq).left (CategoryTheory.CategoryStruct.comp sq.left f)","decl":"/-- A helper construction: given a square between `i` and `f ‚â´ g`, produce a square between\n`i` and `g`, whose top leg uses `f`:\nA  ‚Üí X\n     ‚Üìf\n‚Üìi   Y             --> A ‚Üí Y\n     ‚Üìg                ‚Üìi  ‚Üìg\nB  ‚Üí Z                 B ‚Üí Z\n -/\n@[simps]\ndef squareToSnd {X Y Z : C} {i : Arrow C} {f : X ‚ü∂ Y} {g : Y ‚ü∂ Z} (sq : i ‚ü∂ Arrow.mk (f ‚â´ g)) :\n    i ‚ü∂ Arrow.mk g where\n  left := sq.left ‚â´ f\n  right := sq.right\n\n"}
{"name":"CategoryTheory.Arrow.squareToSnd_right","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y Z : C\ni : CategoryTheory.Arrow C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nsq : Quiver.Hom i (CategoryTheory.Arrow.mk (CategoryTheory.CategoryStruct.comp f g))\n‚ä¢ Eq (CategoryTheory.Arrow.squareToSnd sq).right sq.right","decl":"/-- A helper construction: given a square between `i` and `f ‚â´ g`, produce a square between\n`i` and `g`, whose top leg uses `f`:\nA  ‚Üí X\n     ‚Üìf\n‚Üìi   Y             --> A ‚Üí Y\n     ‚Üìg                ‚Üìi  ‚Üìg\nB  ‚Üí Z                 B ‚Üí Z\n -/\n@[simps]\ndef squareToSnd {X Y Z : C} {i : Arrow C} {f : X ‚ü∂ Y} {g : Y ‚ü∂ Z} (sq : i ‚ü∂ Arrow.mk (f ‚â´ g)) :\n    i ‚ü∂ Arrow.mk g where\n  left := sq.left ‚â´ f\n  right := sq.right\n\n"}
{"name":"CategoryTheory.Arrow.leftFunc_map","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù Y‚úù : CategoryTheory.Comma (CategoryTheory.Functor.id C) (CategoryTheory.Functor.id C)\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (CategoryTheory.Arrow.leftFunc.map f) f.left","decl":"/-- The functor sending an arrow to its source. -/\n@[simps!]\ndef leftFunc : Arrow C ‚•§ C :=\n  Comma.fst _ _\n\n"}
{"name":"CategoryTheory.Arrow.leftFunc_obj","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.Comma (CategoryTheory.Functor.id C) (CategoryTheory.Functor.id C)\n‚ä¢ Eq (CategoryTheory.Arrow.leftFunc.obj X) X.left","decl":"/-- The functor sending an arrow to its source. -/\n@[simps!]\ndef leftFunc : Arrow C ‚•§ C :=\n  Comma.fst _ _\n\n"}
{"name":"CategoryTheory.Arrow.rightFunc_obj","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.Comma (CategoryTheory.Functor.id C) (CategoryTheory.Functor.id C)\n‚ä¢ Eq (CategoryTheory.Arrow.rightFunc.obj X) X.right","decl":"/-- The functor sending an arrow to its target. -/\n@[simps!]\ndef rightFunc : Arrow C ‚•§ C :=\n  Comma.snd _ _\n\n"}
{"name":"CategoryTheory.Arrow.rightFunc_map","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù Y‚úù : CategoryTheory.Comma (CategoryTheory.Functor.id C) (CategoryTheory.Functor.id C)\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (CategoryTheory.Arrow.rightFunc.map f) f.right","decl":"/-- The functor sending an arrow to its target. -/\n@[simps!]\ndef rightFunc : Arrow C ‚•§ C :=\n  Comma.snd _ _\n\n"}
{"name":"CategoryTheory.Arrow.leftToRight_app","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nf : CategoryTheory.Arrow C\n‚ä¢ Eq (CategoryTheory.Arrow.leftToRight.app f) f.hom","decl":"/-- The natural transformation from `leftFunc` to `rightFunc`, given by the arrow itself. -/\n@[simps]\ndef leftToRight : (leftFunc : Arrow C ‚•§ C) ‚ü∂ rightFunc where app f := f.hom\n\n"}
{"name":"CategoryTheory.Functor.mapArrow_obj","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\na : CategoryTheory.Arrow C\n‚ä¢ Eq (F.mapArrow.obj a) (CategoryTheory.Arrow.mk (F.map a.hom))","decl":"/-- A functor `C ‚•§ D` induces a functor between the corresponding arrow categories. -/\n@[simps]\ndef mapArrow (F : C ‚•§ D) : Arrow C ‚•§ Arrow D where\n  obj a := Arrow.mk (F.map a.hom)\n  map f :=\n    { left := F.map f.left\n      right := F.map f.right\n      w := by\n        let w := f.w\n        simp only [id_map] at w\n        dsimp\n        simp only [‚Üê F.map_comp, w] }\n\n"}
{"name":"CategoryTheory.Functor.mapArrow_map_right","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX‚úù Y‚úù : CategoryTheory.Arrow C\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (F.mapArrow.map f).right (F.map f.right)","decl":"/-- A functor `C ‚•§ D` induces a functor between the corresponding arrow categories. -/\n@[simps]\ndef mapArrow (F : C ‚•§ D) : Arrow C ‚•§ Arrow D where\n  obj a := Arrow.mk (F.map a.hom)\n  map f :=\n    { left := F.map f.left\n      right := F.map f.right\n      w := by\n        let w := f.w\n        simp only [id_map] at w\n        dsimp\n        simp only [‚Üê F.map_comp, w] }\n\n"}
{"name":"CategoryTheory.Functor.mapArrow_map_left","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX‚úù Y‚úù : CategoryTheory.Arrow C\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (F.mapArrow.map f).left (F.map f.left)","decl":"/-- A functor `C ‚•§ D` induces a functor between the corresponding arrow categories. -/\n@[simps]\ndef mapArrow (F : C ‚•§ D) : Arrow C ‚•§ Arrow D where\n  obj a := Arrow.mk (F.map a.hom)\n  map f :=\n    { left := F.map f.left\n      right := F.map f.right\n      w := by\n        let w := f.w\n        simp only [id_map] at w\n        dsimp\n        simp only [‚Üê F.map_comp, w] }\n\n"}
{"name":"CategoryTheory.Functor.mapArrowFunctor_map_app_left","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX‚úù Y‚úù : CategoryTheory.Functor C D\nœÑ : Quiver.Hom X‚úù Y‚úù\nf : CategoryTheory.Arrow C\n‚ä¢ Eq (((CategoryTheory.Functor.mapArrowFunctor C D).map œÑ).app f).left (œÑ.app ((CategoryTheory.Functor.id C).obj f.left))","decl":"/-- The functor `(C ‚•§ D) ‚•§ (Arrow C ‚•§ Arrow D)` which sends\na functor `F : C ‚•§ D` to `F.mapArrow`. -/\n@[simps]\ndef mapArrowFunctor : (C ‚•§ D) ‚•§ (Arrow C ‚•§ Arrow D) where\n  obj F := F.mapArrow\n  map œÑ :=\n    { app := fun f =>\n        { left := œÑ.app _\n          right := œÑ.app _ } }\n\n"}
{"name":"CategoryTheory.Functor.mapArrowFunctor_map_app_right","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX‚úù Y‚úù : CategoryTheory.Functor C D\nœÑ : Quiver.Hom X‚úù Y‚úù\nf : CategoryTheory.Arrow C\n‚ä¢ Eq (((CategoryTheory.Functor.mapArrowFunctor C D).map œÑ).app f).right (œÑ.app ((CategoryTheory.Functor.id C).obj f.right))","decl":"/-- The functor `(C ‚•§ D) ‚•§ (Arrow C ‚•§ Arrow D)` which sends\na functor `F : C ‚•§ D` to `F.mapArrow`. -/\n@[simps]\ndef mapArrowFunctor : (C ‚•§ D) ‚•§ (Arrow C ‚•§ Arrow D) where\n  obj F := F.mapArrow\n  map œÑ :=\n    { app := fun f =>\n        { left := œÑ.app _\n          right := œÑ.app _ } }\n\n"}
{"name":"CategoryTheory.Functor.mapArrowFunctor_obj","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\n‚ä¢ Eq ((CategoryTheory.Functor.mapArrowFunctor C D).obj F) F.mapArrow","decl":"/-- The functor `(C ‚•§ D) ‚•§ (Arrow C ‚•§ Arrow D)` which sends\na functor `F : C ‚•§ D` to `F.mapArrow`. -/\n@[simps]\ndef mapArrowFunctor : (C ‚•§ D) ‚•§ (Arrow C ‚•§ Arrow D) where\n  obj F := F.mapArrow\n  map œÑ :=\n    { app := fun f =>\n        { left := œÑ.app _\n          right := œÑ.app _ } }\n\n"}
{"name":"CategoryTheory.Functor.isEquivalence_mapArrow","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\ninst‚úù : F.IsEquivalence\n‚ä¢ F.mapArrow.IsEquivalence","decl":"instance isEquivalence_mapArrow (F : C ‚•§ D) [IsEquivalence F] :\n    IsEquivalence F.mapArrow :=\n  (mapArrowEquivalence (asEquivalence F)).isEquivalence_functor\n\n"}
{"name":"CategoryTheory.Arrow.equivSigma_symm_apply_hom","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"T : Type u\ninst‚úù : CategoryTheory.Category.{v, u} T\nx : Sigma fun X => Sigma fun Y => Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.Arrow.equivSigma T).symm x).hom x.snd.snd","decl":"/-- `Arrow T` is equivalent to a sigma type. -/\n@[simps!]\ndef Arrow.equivSigma :\n    Arrow T ‚âÉ Œ£ (X Y : T), X ‚ü∂ Y where\n  toFun f := ‚ü®_, _, f.hom‚ü©\n  invFun x := Arrow.mk x.2.2\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"CategoryTheory.Arrow.equivSigma_symm_apply_right","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"T : Type u\ninst‚úù : CategoryTheory.Category.{v, u} T\nx : Sigma fun X => Sigma fun Y => Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.Arrow.equivSigma T).symm x).right x.snd.fst","decl":"/-- `Arrow T` is equivalent to a sigma type. -/\n@[simps!]\ndef Arrow.equivSigma :\n    Arrow T ‚âÉ Œ£ (X Y : T), X ‚ü∂ Y where\n  toFun f := ‚ü®_, _, f.hom‚ü©\n  invFun x := Arrow.mk x.2.2\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"CategoryTheory.Arrow.equivSigma_apply_fst","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"T : Type u\ninst‚úù : CategoryTheory.Category.{v, u} T\nf : CategoryTheory.Arrow T\n‚ä¢ Eq ((CategoryTheory.Arrow.equivSigma T) f).fst f.left","decl":"/-- `Arrow T` is equivalent to a sigma type. -/\n@[simps!]\ndef Arrow.equivSigma :\n    Arrow T ‚âÉ Œ£ (X Y : T), X ‚ü∂ Y where\n  toFun f := ‚ü®_, _, f.hom‚ü©\n  invFun x := Arrow.mk x.2.2\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"CategoryTheory.Arrow.equivSigma_apply_snd_fst","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"T : Type u\ninst‚úù : CategoryTheory.Category.{v, u} T\nf : CategoryTheory.Arrow T\n‚ä¢ Eq ((CategoryTheory.Arrow.equivSigma T) f).snd.fst f.right","decl":"/-- `Arrow T` is equivalent to a sigma type. -/\n@[simps!]\ndef Arrow.equivSigma :\n    Arrow T ‚âÉ Œ£ (X Y : T), X ‚ü∂ Y where\n  toFun f := ‚ü®_, _, f.hom‚ü©\n  invFun x := Arrow.mk x.2.2\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"CategoryTheory.Arrow.equivSigma_symm_apply_left","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"T : Type u\ninst‚úù : CategoryTheory.Category.{v, u} T\nx : Sigma fun X => Sigma fun Y => Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.Arrow.equivSigma T).symm x).left x.fst","decl":"/-- `Arrow T` is equivalent to a sigma type. -/\n@[simps!]\ndef Arrow.equivSigma :\n    Arrow T ‚âÉ Œ£ (X Y : T), X ‚ü∂ Y where\n  toFun f := ‚ü®_, _, f.hom‚ü©\n  invFun x := Arrow.mk x.2.2\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"CategoryTheory.Arrow.equivSigma_apply_snd_snd","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"T : Type u\ninst‚úù : CategoryTheory.Category.{v, u} T\nf : CategoryTheory.Arrow T\n‚ä¢ Eq ((CategoryTheory.Arrow.equivSigma T) f).snd.snd f.hom","decl":"/-- `Arrow T` is equivalent to a sigma type. -/\n@[simps!]\ndef Arrow.equivSigma :\n    Arrow T ‚âÉ Œ£ (X Y : T), X ‚ü∂ Y where\n  toFun f := ‚ü®_, _, f.hom‚ü©\n  invFun x := Arrow.mk x.2.2\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"CategoryTheory.Arrow.functor_ext","module":"Mathlib.CategoryTheory.Comma.Arrow","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù : CategoryTheory.Category.{u_4, u_2} D\nF G : CategoryTheory.Functor C D\nh : ‚àÄ ‚¶ÉX Y : C‚¶Ñ (f : Quiver.Hom X Y), Eq (F.mapArrow.obj (CategoryTheory.Arrow.mk f)) (G.mapArrow.obj (CategoryTheory.Arrow.mk f))\n‚ä¢ Eq F G","decl":"/-- Extensionality lemma for functors `C ‚•§ D` which uses as an assumption\nthat the induced maps `Arrow C ‚Üí Arrow D` coincide. -/\nlemma Arrow.functor_ext {F G : C ‚•§ D} (h : ‚àÄ ‚¶ÉX Y : C‚¶Ñ (f : X ‚ü∂ Y),\n    F.mapArrow.obj (Arrow.mk f) = G.mapArrow.obj (Arrow.mk f)) :\n    F = G :=\n  Functor.ext (fun X ‚Ü¶ congr_arg Comma.left (h (ùüô X))) (fun X Y f ‚Ü¶ by\n    have := h f\n    simp only [Functor.mapArrow_obj, mk_eq_mk_iff] at this\n    tauto)\n\n"}
