{"name":"CliffordAlgebraRing.ι_eq_zero","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Equivs","initialProofState":"R : Type u_1\ninst✝ : CommRing R\n⊢ Eq (CliffordAlgebra.ι 0) 0","decl":"@[simp]\ntheorem ι_eq_zero : ι (0 : QuadraticForm R Unit) = 0 :=\n  Subsingleton.elim _ _\n\n"}
{"name":"CliffordAlgebraRing.reverse_apply","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Equivs","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nx : CliffordAlgebra 0\n⊢ Eq (CliffordAlgebra.reverse x) x","decl":"theorem reverse_apply (x : CliffordAlgebra (0 : QuadraticForm R Unit)) :\n    reverse (R := R) x = x := by\n  induction x using CliffordAlgebra.induction with\n  | algebraMap r => exact reverse.commutes _\n  | ι x => rw [ι_eq_zero, LinearMap.zero_apply, reverse.map_zero]\n  | mul x₁ x₂ hx₁ hx₂ => rw [reverse.map_mul, mul_comm, hx₁, hx₂]\n  | add x₁ x₂ hx₁ hx₂ => rw [reverse.map_add, hx₁, hx₂]\n\n"}
{"name":"CliffordAlgebraRing.reverse_eq_id","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Equivs","initialProofState":"R : Type u_1\ninst✝ : CommRing R\n⊢ Eq CliffordAlgebra.reverse LinearMap.id","decl":"@[simp]\ntheorem reverse_eq_id :\n    (reverse : CliffordAlgebra (0 : QuadraticForm R Unit) →ₗ[R] _) = LinearMap.id :=\n  LinearMap.ext reverse_apply\n\n"}
{"name":"CliffordAlgebraRing.involute_eq_id","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Equivs","initialProofState":"R : Type u_1\ninst✝ : CommRing R\n⊢ Eq CliffordAlgebra.involute (AlgHom.id R (CliffordAlgebra 0))","decl":"@[simp]\ntheorem involute_eq_id :\n    (involute : CliffordAlgebra (0 : QuadraticForm R Unit) →ₐ[R] _) = AlgHom.id R _ := by ext; simp\n\n"}
{"name":"CliffordAlgebraComplex.Q_apply","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Equivs","initialProofState":"r : Real\n⊢ Eq (CliffordAlgebraComplex.Q r) (Neg.neg (HMul.hMul r r))","decl":"@[simp]\ntheorem Q_apply (r : ℝ) : Q r = -(r * r) :=\n  rfl\n\n"}
{"name":"CliffordAlgebraComplex.toComplex_ι","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Equivs","initialProofState":"r : Real\n⊢ Eq (CliffordAlgebraComplex.toComplex ((CliffordAlgebra.ι CliffordAlgebraComplex.Q) r)) (HSMul.hSMul r Complex.I)","decl":"@[simp]\ntheorem toComplex_ι (r : ℝ) : toComplex (ι Q r) = r • Complex.I :=\n  CliffordAlgebra.lift_ι_apply _ _ r\n\n"}
{"name":"CliffordAlgebraComplex.toComplex_involute","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Equivs","initialProofState":"c : CliffordAlgebra CliffordAlgebraComplex.Q\n⊢ Eq (CliffordAlgebraComplex.toComplex (CliffordAlgebra.involute c)) ((starRingEnd Complex) (CliffordAlgebraComplex.toComplex c))","decl":"/-- `CliffordAlgebra.involute` is analogous to `Complex.conj`. -/\n@[simp]\ntheorem toComplex_involute (c : CliffordAlgebra Q) :\n    toComplex (involute c) = conj (toComplex c) := by\n  have : toComplex (involute (ι Q 1)) = conj (toComplex (ι Q 1)) := by\n    simp only [involute_ι, toComplex_ι, map_neg, one_smul, Complex.conj_I]\n  suffices toComplex.comp involute = Complex.conjAe.toAlgHom.comp toComplex by\n    exact AlgHom.congr_fun this c\n  ext : 2\n  exact this\n\n"}
{"name":"CliffordAlgebraComplex.ofComplex_I","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Equivs","initialProofState":"⊢ Eq (CliffordAlgebraComplex.ofComplex Complex.I) ((CliffordAlgebra.ι CliffordAlgebraComplex.Q) 1)","decl":"@[simp]\ntheorem ofComplex_I : ofComplex Complex.I = ι Q 1 :=\n  Complex.liftAux_apply_I _ (by simp)\n\n"}
{"name":"CliffordAlgebraComplex.toComplex_comp_ofComplex","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Equivs","initialProofState":"⊢ Eq (CliffordAlgebraComplex.toComplex.comp CliffordAlgebraComplex.ofComplex) (AlgHom.id Real Complex)","decl":"@[simp]\ntheorem toComplex_comp_ofComplex : toComplex.comp ofComplex = AlgHom.id ℝ ℂ := by\n  ext1\n  dsimp only [AlgHom.comp_apply, Subtype.coe_mk, AlgHom.id_apply]\n  rw [ofComplex_I, toComplex_ι, one_smul]\n\n"}
{"name":"CliffordAlgebraComplex.toComplex_ofComplex","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Equivs","initialProofState":"c : Complex\n⊢ Eq (CliffordAlgebraComplex.toComplex (CliffordAlgebraComplex.ofComplex c)) c","decl":"@[simp]\ntheorem toComplex_ofComplex (c : ℂ) : toComplex (ofComplex c) = c :=\n  AlgHom.congr_fun toComplex_comp_ofComplex c\n\n"}
{"name":"CliffordAlgebraComplex.ofComplex_comp_toComplex","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Equivs","initialProofState":"⊢ Eq (CliffordAlgebraComplex.ofComplex.comp CliffordAlgebraComplex.toComplex) (AlgHom.id Real (CliffordAlgebra CliffordAlgebraComplex.Q))","decl":"@[simp]\ntheorem ofComplex_comp_toComplex : ofComplex.comp toComplex = AlgHom.id ℝ (CliffordAlgebra Q) := by\n  ext\n  dsimp only [LinearMap.comp_apply, Subtype.coe_mk, AlgHom.id_apply, AlgHom.toLinearMap_apply,\n    AlgHom.comp_apply]\n  rw [toComplex_ι, one_smul, ofComplex_I]\n\n"}
{"name":"CliffordAlgebraComplex.ofComplex_toComplex","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Equivs","initialProofState":"c : CliffordAlgebra CliffordAlgebraComplex.Q\n⊢ Eq (CliffordAlgebraComplex.ofComplex (CliffordAlgebraComplex.toComplex c)) c","decl":"@[simp]\ntheorem ofComplex_toComplex (c : CliffordAlgebra Q) : ofComplex (toComplex c) = c :=\n  AlgHom.congr_fun ofComplex_comp_toComplex c\n\n"}
{"name":"CliffordAlgebraComplex.equiv_apply","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Equivs","initialProofState":"a : CliffordAlgebra CliffordAlgebraComplex.Q\n⊢ Eq (CliffordAlgebraComplex.equiv a) (CliffordAlgebraComplex.toComplex a)","decl":"/-- The clifford algebras over `CliffordAlgebraComplex.Q` is isomorphic as an `ℝ`-algebra to `ℂ`. -/\n@[simps!]\nprotected def equiv : CliffordAlgebra Q ≃ₐ[ℝ] ℂ :=\n  AlgEquiv.ofAlgHom toComplex ofComplex toComplex_comp_ofComplex ofComplex_comp_toComplex\n\n"}
{"name":"CliffordAlgebraComplex.equiv_symm_apply","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Equivs","initialProofState":"a : Complex\n⊢ Eq (CliffordAlgebraComplex.equiv.symm a) (CliffordAlgebraComplex.ofComplex a)","decl":"/-- The clifford algebras over `CliffordAlgebraComplex.Q` is isomorphic as an `ℝ`-algebra to `ℂ`. -/\n@[simps!]\nprotected def equiv : CliffordAlgebra Q ≃ₐ[ℝ] ℂ :=\n  AlgEquiv.ofAlgHom toComplex ofComplex toComplex_comp_ofComplex ofComplex_comp_toComplex\n\n"}
{"name":"CliffordAlgebraComplex.reverse_apply","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Equivs","initialProofState":"x : CliffordAlgebra CliffordAlgebraComplex.Q\n⊢ Eq (CliffordAlgebra.reverse x) x","decl":"/-- `reverse` is a no-op over `CliffordAlgebraComplex.Q`. -/\ntheorem reverse_apply (x : CliffordAlgebra Q) : reverse (R := ℝ) x = x := by\n  induction x using CliffordAlgebra.induction with\n  | algebraMap r => exact reverse.commutes _\n  | ι x => rw [reverse_ι]\n  | mul x₁ x₂ hx₁ hx₂ => rw [reverse.map_mul, mul_comm, hx₁, hx₂]\n  | add x₁ x₂ hx₁ hx₂ => rw [reverse.map_add, hx₁, hx₂]\n\n"}
{"name":"CliffordAlgebraComplex.reverse_eq_id","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Equivs","initialProofState":"⊢ Eq CliffordAlgebra.reverse LinearMap.id","decl":"@[simp]\ntheorem reverse_eq_id : (reverse : CliffordAlgebra Q →ₗ[ℝ] _) = LinearMap.id :=\n  LinearMap.ext reverse_apply\n\n"}
{"name":"CliffordAlgebraComplex.ofComplex_conj","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Equivs","initialProofState":"c : Complex\n⊢ Eq (CliffordAlgebraComplex.ofComplex ((starRingEnd Complex) c)) (CliffordAlgebra.involute (CliffordAlgebraComplex.ofComplex c))","decl":"/-- `Complex.conj` is analogous to `CliffordAlgebra.involute`. -/\n@[simp]\ntheorem ofComplex_conj (c : ℂ) : ofComplex (conj c) = involute (ofComplex c) :=\n  CliffordAlgebraComplex.equiv.injective <| by\n    rw [equiv_apply, equiv_apply, toComplex_involute, toComplex_ofComplex, toComplex_ofComplex]\n\n-- this name is too short for us to want it visible after `open CliffordAlgebraComplex`\n--attribute [protected] Q -- Porting note: removed\n\n"}
{"name":"CliffordAlgebraQuaternion.Q_apply","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Equivs","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nc₁ c₂ : R\nv : Prod R R\n⊢ Eq ((CliffordAlgebraQuaternion.Q c₁ c₂) v) (HAdd.hAdd (HMul.hMul c₁ (HMul.hMul v.1 v.1)) (HMul.hMul c₂ (HMul.hMul v.2 v.2)))","decl":"@[simp]\ntheorem Q_apply (v : R × R) : Q c₁ c₂ v = c₁ * (v.1 * v.1) + c₂ * (v.2 * v.2) :=\n  rfl\n\n"}
{"name":"CliffordAlgebraQuaternion.quaternionBasis_i","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Equivs","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nc₁ c₂ : R\n⊢ Eq (CliffordAlgebraQuaternion.quaternionBasis c₁ c₂).i ((CliffordAlgebra.ι (CliffordAlgebraQuaternion.Q c₁ c₂)) { fst := 1, snd := 0 })","decl":"/-- The quaternion basis vectors within the algebra. -/\n@[simps i j k]\ndef quaternionBasis : QuaternionAlgebra.Basis (CliffordAlgebra (Q c₁ c₂)) c₁ 0 c₂ where\n  i := ι (Q c₁ c₂) (1, 0)\n  j := ι (Q c₁ c₂) (0, 1)\n  k := ι (Q c₁ c₂) (1, 0) * ι (Q c₁ c₂) (0, 1)\n  i_mul_i := by\n    rw [ι_sq_scalar, Q_apply, ← Algebra.algebraMap_eq_smul_one]\n    simp\n  j_mul_j := by\n    rw [ι_sq_scalar, Q_apply, ← Algebra.algebraMap_eq_smul_one]\n    simp\n  i_mul_j := rfl\n  j_mul_i := by\n    rw [zero_smul, zero_sub, eq_neg_iff_add_eq_zero, ι_mul_ι_add_swap, QuadraticMap.polar]\n    simp\n\n"}
{"name":"CliffordAlgebraQuaternion.quaternionBasis_k","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Equivs","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nc₁ c₂ : R\n⊢ Eq (CliffordAlgebraQuaternion.quaternionBasis c₁ c₂).k (HMul.hMul ((CliffordAlgebra.ι (CliffordAlgebraQuaternion.Q c₁ c₂)) { fst := 1, snd := 0 }) ((CliffordAlgebra.ι (CliffordAlgebraQuaternion.Q c₁ c₂)) { fst := 0, snd := 1 }))","decl":"/-- The quaternion basis vectors within the algebra. -/\n@[simps i j k]\ndef quaternionBasis : QuaternionAlgebra.Basis (CliffordAlgebra (Q c₁ c₂)) c₁ 0 c₂ where\n  i := ι (Q c₁ c₂) (1, 0)\n  j := ι (Q c₁ c₂) (0, 1)\n  k := ι (Q c₁ c₂) (1, 0) * ι (Q c₁ c₂) (0, 1)\n  i_mul_i := by\n    rw [ι_sq_scalar, Q_apply, ← Algebra.algebraMap_eq_smul_one]\n    simp\n  j_mul_j := by\n    rw [ι_sq_scalar, Q_apply, ← Algebra.algebraMap_eq_smul_one]\n    simp\n  i_mul_j := rfl\n  j_mul_i := by\n    rw [zero_smul, zero_sub, eq_neg_iff_add_eq_zero, ι_mul_ι_add_swap, QuadraticMap.polar]\n    simp\n\n"}
{"name":"CliffordAlgebraQuaternion.quaternionBasis_j","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Equivs","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nc₁ c₂ : R\n⊢ Eq (CliffordAlgebraQuaternion.quaternionBasis c₁ c₂).j ((CliffordAlgebra.ι (CliffordAlgebraQuaternion.Q c₁ c₂)) { fst := 0, snd := 1 })","decl":"/-- The quaternion basis vectors within the algebra. -/\n@[simps i j k]\ndef quaternionBasis : QuaternionAlgebra.Basis (CliffordAlgebra (Q c₁ c₂)) c₁ 0 c₂ where\n  i := ι (Q c₁ c₂) (1, 0)\n  j := ι (Q c₁ c₂) (0, 1)\n  k := ι (Q c₁ c₂) (1, 0) * ι (Q c₁ c₂) (0, 1)\n  i_mul_i := by\n    rw [ι_sq_scalar, Q_apply, ← Algebra.algebraMap_eq_smul_one]\n    simp\n  j_mul_j := by\n    rw [ι_sq_scalar, Q_apply, ← Algebra.algebraMap_eq_smul_one]\n    simp\n  i_mul_j := rfl\n  j_mul_i := by\n    rw [zero_smul, zero_sub, eq_neg_iff_add_eq_zero, ι_mul_ι_add_swap, QuadraticMap.polar]\n    simp\n\n"}
{"name":"CliffordAlgebraQuaternion.toQuaternion_ι","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Equivs","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nc₁ c₂ : R\nv : Prod R R\n⊢ Eq (CliffordAlgebraQuaternion.toQuaternion ((CliffordAlgebra.ι (CliffordAlgebraQuaternion.Q c₁ c₂)) v)) { re := 0, imI := v.1, imJ := v.2, imK := 0 }","decl":"@[simp]\ntheorem toQuaternion_ι (v : R × R) :\n    toQuaternion (ι (Q c₁ c₂) v) = (⟨0, v.1, v.2, 0⟩ : ℍ[R,c₁,0,c₂]) :=\n  CliffordAlgebra.lift_ι_apply _ _ v\n\n"}
{"name":"CliffordAlgebraQuaternion.toQuaternion_star","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Equivs","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nc₁ c₂ : R\nc : CliffordAlgebra (CliffordAlgebraQuaternion.Q c₁ c₂)\n⊢ Eq (CliffordAlgebraQuaternion.toQuaternion (Star.star c)) (Star.star (CliffordAlgebraQuaternion.toQuaternion c))","decl":"/-- The \"clifford conjugate\" maps to the quaternion conjugate. -/\ntheorem toQuaternion_star (c : CliffordAlgebra (Q c₁ c₂)) :\n    toQuaternion (star c) = star (toQuaternion c) := by\n  simp only [CliffordAlgebra.star_def']\n  induction c using CliffordAlgebra.induction with\n  | algebraMap r => simp\n  | ι x => simp\n  | mul x₁ x₂ hx₁ hx₂ => simp [hx₁, hx₂]\n  | add x₁ x₂ hx₁ hx₂ => simp [hx₁, hx₂]\n\n"}
{"name":"CliffordAlgebraQuaternion.ofQuaternion_mk","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Equivs","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nc₁ c₂ a₁ a₂ a₃ a₄ : R\n⊢ Eq (CliffordAlgebraQuaternion.ofQuaternion { re := a₁, imI := a₂, imJ := a₃, imK := a₄ }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd ((algebraMap R (CliffordAlgebra (CliffordAlgebraQuaternion.Q c₁ c₂))) a₁) (HSMul.hSMul a₂ ((CliffordAlgebra.ι (CliffordAlgebraQuaternion.Q c₁ c₂)) { fst := 1, snd := 0 }))) (HSMul.hSMul a₃ ((CliffordAlgebra.ι (CliffordAlgebraQuaternion.Q c₁ c₂)) { fst := 0, snd := 1 }))) (HSMul.hSMul a₄ (HMul.hMul ((CliffordAlgebra.ι (CliffordAlgebraQuaternion.Q c₁ c₂)) { fst := 1, snd := 0 }) ((CliffordAlgebra.ι (CliffordAlgebraQuaternion.Q c₁ c₂)) { fst := 0, snd := 1 }))))","decl":"@[simp]\ntheorem ofQuaternion_mk (a₁ a₂ a₃ a₄ : R) :\n    ofQuaternion (⟨a₁, a₂, a₃, a₄⟩ : ℍ[R,c₁,0,c₂]) =\n      algebraMap R _ a₁ + a₂ • ι (Q c₁ c₂) (1, 0) + a₃ • ι (Q c₁ c₂) (0, 1) +\n        a₄ • (ι (Q c₁ c₂) (1, 0) * ι (Q c₁ c₂) (0, 1)) :=\n  rfl\n\n"}
{"name":"CliffordAlgebraQuaternion.ofQuaternion_comp_toQuaternion","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Equivs","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nc₁ c₂ : R\n⊢ Eq (CliffordAlgebraQuaternion.ofQuaternion.comp CliffordAlgebraQuaternion.toQuaternion) (AlgHom.id R (CliffordAlgebra (CliffordAlgebraQuaternion.Q c₁ c₂)))","decl":"@[simp]\ntheorem ofQuaternion_comp_toQuaternion :\n    ofQuaternion.comp toQuaternion = AlgHom.id R (CliffordAlgebra (Q c₁ c₂)) := by\n  ext : 1\n  dsimp -- before we end up with two goals and have to do this twice\n  ext\n  all_goals\n    dsimp\n    rw [toQuaternion_ι]\n    dsimp\n    simp only [toQuaternion_ι, zero_smul, one_smul, zero_add, add_zero, RingHom.map_zero]\n\n"}
{"name":"CliffordAlgebraQuaternion.ofQuaternion_toQuaternion","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Equivs","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nc₁ c₂ : R\nc : CliffordAlgebra (CliffordAlgebraQuaternion.Q c₁ c₂)\n⊢ Eq (CliffordAlgebraQuaternion.ofQuaternion (CliffordAlgebraQuaternion.toQuaternion c)) c","decl":"@[simp]\ntheorem ofQuaternion_toQuaternion (c : CliffordAlgebra (Q c₁ c₂)) :\n    ofQuaternion (toQuaternion c) = c :=\n  AlgHom.congr_fun ofQuaternion_comp_toQuaternion c\n\n"}
{"name":"CliffordAlgebraQuaternion.toQuaternion_comp_ofQuaternion","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Equivs","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nc₁ c₂ : R\n⊢ Eq (CliffordAlgebraQuaternion.toQuaternion.comp CliffordAlgebraQuaternion.ofQuaternion) (AlgHom.id R (QuaternionAlgebra R c₁ 0 c₂))","decl":"@[simp]\ntheorem toQuaternion_comp_ofQuaternion :\n    toQuaternion.comp ofQuaternion = AlgHom.id R ℍ[R,c₁,0,c₂] := by\n  ext : 1 <;> simp\n\n"}
{"name":"CliffordAlgebraQuaternion.toQuaternion_ofQuaternion","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Equivs","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nc₁ c₂ : R\nq : QuaternionAlgebra R c₁ 0 c₂\n⊢ Eq (CliffordAlgebraQuaternion.toQuaternion (CliffordAlgebraQuaternion.ofQuaternion q)) q","decl":"@[simp]\ntheorem toQuaternion_ofQuaternion (q : ℍ[R,c₁,0,c₂]) : toQuaternion (ofQuaternion q) = q :=\n  AlgHom.congr_fun toQuaternion_comp_ofQuaternion q\n\n"}
{"name":"CliffordAlgebraQuaternion.equiv_symm_apply","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Equivs","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nc₁ c₂ : R\na : QuaternionAlgebra R c₁ 0 c₂\n⊢ Eq (CliffordAlgebraQuaternion.equiv.symm a) (CliffordAlgebraQuaternion.ofQuaternion a)","decl":"/-- The clifford algebra over `CliffordAlgebraQuaternion.Q c₁ c₂` is isomorphic as an `R`-algebra\nto `ℍ[R,c₁,c₂]`. -/\n@[simps!]\nprotected def equiv : CliffordAlgebra (Q c₁ c₂) ≃ₐ[R] ℍ[R,c₁,0,c₂] :=\n  AlgEquiv.ofAlgHom toQuaternion ofQuaternion toQuaternion_comp_ofQuaternion\n    ofQuaternion_comp_toQuaternion\n\n"}
{"name":"CliffordAlgebraQuaternion.equiv_apply","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Equivs","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nc₁ c₂ : R\na : CliffordAlgebra (CliffordAlgebraQuaternion.Q c₁ c₂)\n⊢ Eq (CliffordAlgebraQuaternion.equiv a) (CliffordAlgebraQuaternion.toQuaternion a)","decl":"/-- The clifford algebra over `CliffordAlgebraQuaternion.Q c₁ c₂` is isomorphic as an `R`-algebra\nto `ℍ[R,c₁,c₂]`. -/\n@[simps!]\nprotected def equiv : CliffordAlgebra (Q c₁ c₂) ≃ₐ[R] ℍ[R,c₁,0,c₂] :=\n  AlgEquiv.ofAlgHom toQuaternion ofQuaternion toQuaternion_comp_ofQuaternion\n    ofQuaternion_comp_toQuaternion\n\n"}
{"name":"CliffordAlgebraQuaternion.ofQuaternion_star","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Equivs","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nc₁ c₂ : R\nq : QuaternionAlgebra R c₁ 0 c₂\n⊢ Eq (CliffordAlgebraQuaternion.ofQuaternion (Star.star q)) (Star.star (CliffordAlgebraQuaternion.ofQuaternion q))","decl":"/-- The quaternion conjugate maps to the \"clifford conjugate\" (aka `star`). -/\n@[simp]\ntheorem ofQuaternion_star (q : ℍ[R,c₁,0,c₂]) : ofQuaternion (star q) = star (ofQuaternion q) :=\n  CliffordAlgebraQuaternion.equiv.injective <| by\n    rw [equiv_apply, equiv_apply, toQuaternion_star, toQuaternion_ofQuaternion,\n      toQuaternion_ofQuaternion]\n\n-- this name is too short for us to want it visible after `open CliffordAlgebraQuaternion`\n--attribute [protected] Q -- Porting note: removed\n\n"}
{"name":"CliffordAlgebraDualNumber.ι_mul_ι","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Equivs","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nr₁ r₂ : R\n⊢ Eq (HMul.hMul ((CliffordAlgebra.ι 0) r₁) ((CliffordAlgebra.ι 0) r₂)) 0","decl":"theorem ι_mul_ι (r₁ r₂) : ι (0 : QuadraticForm R R) r₁ * ι (0 : QuadraticForm R R) r₂ = 0 := by\n  rw [← mul_one r₁, ← mul_one r₂, ← smul_eq_mul R, ← smul_eq_mul R, LinearMap.map_smul,\n    LinearMap.map_smul, smul_mul_smul_comm, ι_sq_scalar, QuadraticMap.zero_apply, RingHom.map_zero,\n    smul_zero]\n\n"}
{"name":"CliffordAlgebraDualNumber.equiv_ι","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Equivs","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nr : R\n⊢ Eq (CliffordAlgebraDualNumber.equiv ((CliffordAlgebra.ι 0) r)) (HSMul.hSMul r DualNumber.eps)","decl":"@[simp]\ntheorem equiv_ι (r : R) : CliffordAlgebraDualNumber.equiv (ι (R := R) _ r) = r • ε :=\n  (lift_ι_apply _ _ r).trans (inr_eq_smul_eps _)\n\n"}
{"name":"CliffordAlgebraDualNumber.equiv_symm_eps","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Equivs","initialProofState":"R : Type u_1\ninst✝ : CommRing R\n⊢ Eq (CliffordAlgebraDualNumber.equiv.symm DualNumber.eps) ((CliffordAlgebra.ι 0) 1)","decl":"@[simp]\ntheorem equiv_symm_eps :\n    CliffordAlgebraDualNumber.equiv.symm (eps : R[ε]) = ι (0 : QuadraticForm R R) 1 :=\n  DualNumber.lift_apply_eps _\n\n"}
