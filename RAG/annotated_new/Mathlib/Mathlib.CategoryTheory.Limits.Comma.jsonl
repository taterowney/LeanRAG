{"name":"CategoryTheory.Comma.limitAuxiliaryCone_π_app","module":"Mathlib.CategoryTheory.Limits.Comma","initialProofState":"J : Type w\ninst✝³ : CategoryTheory.Category.{w', w} J\nA : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nF : CategoryTheory.Functor J (CategoryTheory.Comma L R)\nc₁ : CategoryTheory.Limits.Cone (F.comp (CategoryTheory.Comma.fst L R))\nX : J\n⊢ Eq ((CategoryTheory.Comma.limitAuxiliaryCone F c₁).π.app X) (CategoryTheory.CategoryStruct.comp (L.map (c₁.π.app X)) (F.obj X).hom)","decl":"/-- (Implementation). An auxiliary cone which is useful in order to construct limits\nin the comma category. -/\n@[simps!]\ndef limitAuxiliaryCone (c₁ : Cone (F ⋙ fst L R)) : Cone ((F ⋙ snd L R) ⋙ R) :=\n  (Cones.postcompose (whiskerLeft F (Comma.natTrans L R) :)).obj (L.mapCone c₁)\n\n"}
{"name":"CategoryTheory.Comma.limitAuxiliaryCone_pt","module":"Mathlib.CategoryTheory.Limits.Comma","initialProofState":"J : Type w\ninst✝³ : CategoryTheory.Category.{w', w} J\nA : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nF : CategoryTheory.Functor J (CategoryTheory.Comma L R)\nc₁ : CategoryTheory.Limits.Cone (F.comp (CategoryTheory.Comma.fst L R))\n⊢ Eq (CategoryTheory.Comma.limitAuxiliaryCone F c₁).pt (L.obj c₁.pt)","decl":"/-- (Implementation). An auxiliary cone which is useful in order to construct limits\nin the comma category. -/\n@[simps!]\ndef limitAuxiliaryCone (c₁ : Cone (F ⋙ fst L R)) : Cone ((F ⋙ snd L R) ⋙ R) :=\n  (Cones.postcompose (whiskerLeft F (Comma.natTrans L R) :)).obj (L.mapCone c₁)\n\n"}
{"name":"CategoryTheory.Comma.coneOfPreserves_π_app_right","module":"Mathlib.CategoryTheory.Limits.Comma","initialProofState":"J : Type w\ninst✝⁴ : CategoryTheory.Category.{w', w} J\nA : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nF : CategoryTheory.Functor J (CategoryTheory.Comma L R)\ninst✝ : CategoryTheory.Limits.PreservesLimit (F.comp (CategoryTheory.Comma.snd L R)) R\nc₁ : CategoryTheory.Limits.Cone (F.comp (CategoryTheory.Comma.fst L R))\nc₂ : CategoryTheory.Limits.Cone (F.comp (CategoryTheory.Comma.snd L R))\nt₂ : CategoryTheory.Limits.IsLimit c₂\nj : J\n⊢ Eq ((CategoryTheory.Comma.coneOfPreserves F c₁ t₂).π.app j).right (c₂.π.app j)","decl":"/-- If `R` preserves the appropriate limit, then given a cone for `F ⋙ fst L R : J ⥤ L` and a\nlimit cone for `F ⋙ snd L R : J ⥤ R` we can build a cone for `F` which will turn out to be a limit\ncone.\n-/\n@[simps]\nnoncomputable def coneOfPreserves [PreservesLimit (F ⋙ snd L R) R] (c₁ : Cone (F ⋙ fst L R))\n    {c₂ : Cone (F ⋙ snd L R)} (t₂ : IsLimit c₂) : Cone F where\n  pt :=\n    { left := c₁.pt\n      right := c₂.pt\n      hom := (isLimitOfPreserves R t₂).lift (limitAuxiliaryCone _ c₁) }\n  π :=\n    { app := fun j =>\n        { left := c₁.π.app j\n          right := c₂.π.app j\n          w := ((isLimitOfPreserves R t₂).fac (limitAuxiliaryCone F c₁) j).symm }\n      naturality := fun j₁ j₂ t => by\n        ext\n        · simp [← c₁.w t]\n        · simp [← c₂.w t] }\n\n"}
{"name":"CategoryTheory.Comma.coneOfPreserves_π_app_left","module":"Mathlib.CategoryTheory.Limits.Comma","initialProofState":"J : Type w\ninst✝⁴ : CategoryTheory.Category.{w', w} J\nA : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nF : CategoryTheory.Functor J (CategoryTheory.Comma L R)\ninst✝ : CategoryTheory.Limits.PreservesLimit (F.comp (CategoryTheory.Comma.snd L R)) R\nc₁ : CategoryTheory.Limits.Cone (F.comp (CategoryTheory.Comma.fst L R))\nc₂ : CategoryTheory.Limits.Cone (F.comp (CategoryTheory.Comma.snd L R))\nt₂ : CategoryTheory.Limits.IsLimit c₂\nj : J\n⊢ Eq ((CategoryTheory.Comma.coneOfPreserves F c₁ t₂).π.app j).left (c₁.π.app j)","decl":"/-- If `R` preserves the appropriate limit, then given a cone for `F ⋙ fst L R : J ⥤ L` and a\nlimit cone for `F ⋙ snd L R : J ⥤ R` we can build a cone for `F` which will turn out to be a limit\ncone.\n-/\n@[simps]\nnoncomputable def coneOfPreserves [PreservesLimit (F ⋙ snd L R) R] (c₁ : Cone (F ⋙ fst L R))\n    {c₂ : Cone (F ⋙ snd L R)} (t₂ : IsLimit c₂) : Cone F where\n  pt :=\n    { left := c₁.pt\n      right := c₂.pt\n      hom := (isLimitOfPreserves R t₂).lift (limitAuxiliaryCone _ c₁) }\n  π :=\n    { app := fun j =>\n        { left := c₁.π.app j\n          right := c₂.π.app j\n          w := ((isLimitOfPreserves R t₂).fac (limitAuxiliaryCone F c₁) j).symm }\n      naturality := fun j₁ j₂ t => by\n        ext\n        · simp [← c₁.w t]\n        · simp [← c₂.w t] }\n\n"}
{"name":"CategoryTheory.Comma.coneOfPreserves_pt_left","module":"Mathlib.CategoryTheory.Limits.Comma","initialProofState":"J : Type w\ninst✝⁴ : CategoryTheory.Category.{w', w} J\nA : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nF : CategoryTheory.Functor J (CategoryTheory.Comma L R)\ninst✝ : CategoryTheory.Limits.PreservesLimit (F.comp (CategoryTheory.Comma.snd L R)) R\nc₁ : CategoryTheory.Limits.Cone (F.comp (CategoryTheory.Comma.fst L R))\nc₂ : CategoryTheory.Limits.Cone (F.comp (CategoryTheory.Comma.snd L R))\nt₂ : CategoryTheory.Limits.IsLimit c₂\n⊢ Eq (CategoryTheory.Comma.coneOfPreserves F c₁ t₂).pt.left c₁.pt","decl":"/-- If `R` preserves the appropriate limit, then given a cone for `F ⋙ fst L R : J ⥤ L` and a\nlimit cone for `F ⋙ snd L R : J ⥤ R` we can build a cone for `F` which will turn out to be a limit\ncone.\n-/\n@[simps]\nnoncomputable def coneOfPreserves [PreservesLimit (F ⋙ snd L R) R] (c₁ : Cone (F ⋙ fst L R))\n    {c₂ : Cone (F ⋙ snd L R)} (t₂ : IsLimit c₂) : Cone F where\n  pt :=\n    { left := c₁.pt\n      right := c₂.pt\n      hom := (isLimitOfPreserves R t₂).lift (limitAuxiliaryCone _ c₁) }\n  π :=\n    { app := fun j =>\n        { left := c₁.π.app j\n          right := c₂.π.app j\n          w := ((isLimitOfPreserves R t₂).fac (limitAuxiliaryCone F c₁) j).symm }\n      naturality := fun j₁ j₂ t => by\n        ext\n        · simp [← c₁.w t]\n        · simp [← c₂.w t] }\n\n"}
{"name":"CategoryTheory.Comma.coneOfPreserves_pt_hom","module":"Mathlib.CategoryTheory.Limits.Comma","initialProofState":"J : Type w\ninst✝⁴ : CategoryTheory.Category.{w', w} J\nA : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nF : CategoryTheory.Functor J (CategoryTheory.Comma L R)\ninst✝ : CategoryTheory.Limits.PreservesLimit (F.comp (CategoryTheory.Comma.snd L R)) R\nc₁ : CategoryTheory.Limits.Cone (F.comp (CategoryTheory.Comma.fst L R))\nc₂ : CategoryTheory.Limits.Cone (F.comp (CategoryTheory.Comma.snd L R))\nt₂ : CategoryTheory.Limits.IsLimit c₂\n⊢ Eq (CategoryTheory.Comma.coneOfPreserves F c₁ t₂).pt.hom ((CategoryTheory.Limits.isLimitOfPreserves R t₂).lift (CategoryTheory.Comma.limitAuxiliaryCone F c₁))","decl":"/-- If `R` preserves the appropriate limit, then given a cone for `F ⋙ fst L R : J ⥤ L` and a\nlimit cone for `F ⋙ snd L R : J ⥤ R` we can build a cone for `F` which will turn out to be a limit\ncone.\n-/\n@[simps]\nnoncomputable def coneOfPreserves [PreservesLimit (F ⋙ snd L R) R] (c₁ : Cone (F ⋙ fst L R))\n    {c₂ : Cone (F ⋙ snd L R)} (t₂ : IsLimit c₂) : Cone F where\n  pt :=\n    { left := c₁.pt\n      right := c₂.pt\n      hom := (isLimitOfPreserves R t₂).lift (limitAuxiliaryCone _ c₁) }\n  π :=\n    { app := fun j =>\n        { left := c₁.π.app j\n          right := c₂.π.app j\n          w := ((isLimitOfPreserves R t₂).fac (limitAuxiliaryCone F c₁) j).symm }\n      naturality := fun j₁ j₂ t => by\n        ext\n        · simp [← c₁.w t]\n        · simp [← c₂.w t] }\n\n"}
{"name":"CategoryTheory.Comma.coneOfPreserves_pt_right","module":"Mathlib.CategoryTheory.Limits.Comma","initialProofState":"J : Type w\ninst✝⁴ : CategoryTheory.Category.{w', w} J\nA : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nF : CategoryTheory.Functor J (CategoryTheory.Comma L R)\ninst✝ : CategoryTheory.Limits.PreservesLimit (F.comp (CategoryTheory.Comma.snd L R)) R\nc₁ : CategoryTheory.Limits.Cone (F.comp (CategoryTheory.Comma.fst L R))\nc₂ : CategoryTheory.Limits.Cone (F.comp (CategoryTheory.Comma.snd L R))\nt₂ : CategoryTheory.Limits.IsLimit c₂\n⊢ Eq (CategoryTheory.Comma.coneOfPreserves F c₁ t₂).pt.right c₂.pt","decl":"/-- If `R` preserves the appropriate limit, then given a cone for `F ⋙ fst L R : J ⥤ L` and a\nlimit cone for `F ⋙ snd L R : J ⥤ R` we can build a cone for `F` which will turn out to be a limit\ncone.\n-/\n@[simps]\nnoncomputable def coneOfPreserves [PreservesLimit (F ⋙ snd L R) R] (c₁ : Cone (F ⋙ fst L R))\n    {c₂ : Cone (F ⋙ snd L R)} (t₂ : IsLimit c₂) : Cone F where\n  pt :=\n    { left := c₁.pt\n      right := c₂.pt\n      hom := (isLimitOfPreserves R t₂).lift (limitAuxiliaryCone _ c₁) }\n  π :=\n    { app := fun j =>\n        { left := c₁.π.app j\n          right := c₂.π.app j\n          w := ((isLimitOfPreserves R t₂).fac (limitAuxiliaryCone F c₁) j).symm }\n      naturality := fun j₁ j₂ t => by\n        ext\n        · simp [← c₁.w t]\n        · simp [← c₂.w t] }\n\n"}
{"name":"CategoryTheory.Comma.colimitAuxiliaryCocone_ι_app","module":"Mathlib.CategoryTheory.Limits.Comma","initialProofState":"J : Type w\ninst✝³ : CategoryTheory.Category.{w', w} J\nA : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nF : CategoryTheory.Functor J (CategoryTheory.Comma L R)\nc₂ : CategoryTheory.Limits.Cocone (F.comp (CategoryTheory.Comma.snd L R))\nX : J\n⊢ Eq ((CategoryTheory.Comma.colimitAuxiliaryCocone F c₂).ι.app X) (CategoryTheory.CategoryStruct.comp (F.obj X).hom (R.map (c₂.ι.app X)))","decl":"/-- (Implementation). An auxiliary cocone which is useful in order to construct colimits\nin the comma category. -/\n@[simps!]\ndef colimitAuxiliaryCocone (c₂ : Cocone (F ⋙ snd L R)) : Cocone ((F ⋙ fst L R) ⋙ L) :=\n  (Cocones.precompose (whiskerLeft F (Comma.natTrans L R) :)).obj (R.mapCocone c₂)\n\n"}
{"name":"CategoryTheory.Comma.colimitAuxiliaryCocone_pt","module":"Mathlib.CategoryTheory.Limits.Comma","initialProofState":"J : Type w\ninst✝³ : CategoryTheory.Category.{w', w} J\nA : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nF : CategoryTheory.Functor J (CategoryTheory.Comma L R)\nc₂ : CategoryTheory.Limits.Cocone (F.comp (CategoryTheory.Comma.snd L R))\n⊢ Eq (CategoryTheory.Comma.colimitAuxiliaryCocone F c₂).pt (R.obj c₂.pt)","decl":"/-- (Implementation). An auxiliary cocone which is useful in order to construct colimits\nin the comma category. -/\n@[simps!]\ndef colimitAuxiliaryCocone (c₂ : Cocone (F ⋙ snd L R)) : Cocone ((F ⋙ fst L R) ⋙ L) :=\n  (Cocones.precompose (whiskerLeft F (Comma.natTrans L R) :)).obj (R.mapCocone c₂)\n\n"}
{"name":"CategoryTheory.Comma.coconeOfPreserves_pt_right","module":"Mathlib.CategoryTheory.Limits.Comma","initialProofState":"J : Type w\ninst✝⁴ : CategoryTheory.Category.{w', w} J\nA : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nF : CategoryTheory.Functor J (CategoryTheory.Comma L R)\ninst✝ : CategoryTheory.Limits.PreservesColimit (F.comp (CategoryTheory.Comma.fst L R)) L\nc₁ : CategoryTheory.Limits.Cocone (F.comp (CategoryTheory.Comma.fst L R))\nt₁ : CategoryTheory.Limits.IsColimit c₁\nc₂ : CategoryTheory.Limits.Cocone (F.comp (CategoryTheory.Comma.snd L R))\n⊢ Eq (CategoryTheory.Comma.coconeOfPreserves F t₁ c₂).pt.right c₂.pt","decl":"/--\nIf `L` preserves the appropriate colimit, then given a colimit cocone for `F ⋙ fst L R : J ⥤ L` and\na cocone for `F ⋙ snd L R : J ⥤ R` we can build a cocone for `F` which will turn out to be a\ncolimit cocone.\n-/\n@[simps]\nnoncomputable def coconeOfPreserves [PreservesColimit (F ⋙ fst L R) L] {c₁ : Cocone (F ⋙ fst L R)}\n    (t₁ : IsColimit c₁) (c₂ : Cocone (F ⋙ snd L R)) : Cocone F where\n  pt :=\n    { left := c₁.pt\n      right := c₂.pt\n      hom := (isColimitOfPreserves L t₁).desc (colimitAuxiliaryCocone _ c₂) }\n  ι :=\n    { app := fun j =>\n        { left := c₁.ι.app j\n          right := c₂.ι.app j\n          w := (isColimitOfPreserves L t₁).fac (colimitAuxiliaryCocone _ c₂) j }\n      naturality := fun j₁ j₂ t => by\n        ext\n        · simp [← c₁.w t]\n        · simp [← c₂.w t] }\n\n"}
{"name":"CategoryTheory.Comma.coconeOfPreserves_ι_app_left","module":"Mathlib.CategoryTheory.Limits.Comma","initialProofState":"J : Type w\ninst✝⁴ : CategoryTheory.Category.{w', w} J\nA : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nF : CategoryTheory.Functor J (CategoryTheory.Comma L R)\ninst✝ : CategoryTheory.Limits.PreservesColimit (F.comp (CategoryTheory.Comma.fst L R)) L\nc₁ : CategoryTheory.Limits.Cocone (F.comp (CategoryTheory.Comma.fst L R))\nt₁ : CategoryTheory.Limits.IsColimit c₁\nc₂ : CategoryTheory.Limits.Cocone (F.comp (CategoryTheory.Comma.snd L R))\nj : J\n⊢ Eq ((CategoryTheory.Comma.coconeOfPreserves F t₁ c₂).ι.app j).left (c₁.ι.app j)","decl":"/--\nIf `L` preserves the appropriate colimit, then given a colimit cocone for `F ⋙ fst L R : J ⥤ L` and\na cocone for `F ⋙ snd L R : J ⥤ R` we can build a cocone for `F` which will turn out to be a\ncolimit cocone.\n-/\n@[simps]\nnoncomputable def coconeOfPreserves [PreservesColimit (F ⋙ fst L R) L] {c₁ : Cocone (F ⋙ fst L R)}\n    (t₁ : IsColimit c₁) (c₂ : Cocone (F ⋙ snd L R)) : Cocone F where\n  pt :=\n    { left := c₁.pt\n      right := c₂.pt\n      hom := (isColimitOfPreserves L t₁).desc (colimitAuxiliaryCocone _ c₂) }\n  ι :=\n    { app := fun j =>\n        { left := c₁.ι.app j\n          right := c₂.ι.app j\n          w := (isColimitOfPreserves L t₁).fac (colimitAuxiliaryCocone _ c₂) j }\n      naturality := fun j₁ j₂ t => by\n        ext\n        · simp [← c₁.w t]\n        · simp [← c₂.w t] }\n\n"}
{"name":"CategoryTheory.Comma.coconeOfPreserves_pt_left","module":"Mathlib.CategoryTheory.Limits.Comma","initialProofState":"J : Type w\ninst✝⁴ : CategoryTheory.Category.{w', w} J\nA : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nF : CategoryTheory.Functor J (CategoryTheory.Comma L R)\ninst✝ : CategoryTheory.Limits.PreservesColimit (F.comp (CategoryTheory.Comma.fst L R)) L\nc₁ : CategoryTheory.Limits.Cocone (F.comp (CategoryTheory.Comma.fst L R))\nt₁ : CategoryTheory.Limits.IsColimit c₁\nc₂ : CategoryTheory.Limits.Cocone (F.comp (CategoryTheory.Comma.snd L R))\n⊢ Eq (CategoryTheory.Comma.coconeOfPreserves F t₁ c₂).pt.left c₁.pt","decl":"/--\nIf `L` preserves the appropriate colimit, then given a colimit cocone for `F ⋙ fst L R : J ⥤ L` and\na cocone for `F ⋙ snd L R : J ⥤ R` we can build a cocone for `F` which will turn out to be a\ncolimit cocone.\n-/\n@[simps]\nnoncomputable def coconeOfPreserves [PreservesColimit (F ⋙ fst L R) L] {c₁ : Cocone (F ⋙ fst L R)}\n    (t₁ : IsColimit c₁) (c₂ : Cocone (F ⋙ snd L R)) : Cocone F where\n  pt :=\n    { left := c₁.pt\n      right := c₂.pt\n      hom := (isColimitOfPreserves L t₁).desc (colimitAuxiliaryCocone _ c₂) }\n  ι :=\n    { app := fun j =>\n        { left := c₁.ι.app j\n          right := c₂.ι.app j\n          w := (isColimitOfPreserves L t₁).fac (colimitAuxiliaryCocone _ c₂) j }\n      naturality := fun j₁ j₂ t => by\n        ext\n        · simp [← c₁.w t]\n        · simp [← c₂.w t] }\n\n"}
{"name":"CategoryTheory.Comma.coconeOfPreserves_pt_hom","module":"Mathlib.CategoryTheory.Limits.Comma","initialProofState":"J : Type w\ninst✝⁴ : CategoryTheory.Category.{w', w} J\nA : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nF : CategoryTheory.Functor J (CategoryTheory.Comma L R)\ninst✝ : CategoryTheory.Limits.PreservesColimit (F.comp (CategoryTheory.Comma.fst L R)) L\nc₁ : CategoryTheory.Limits.Cocone (F.comp (CategoryTheory.Comma.fst L R))\nt₁ : CategoryTheory.Limits.IsColimit c₁\nc₂ : CategoryTheory.Limits.Cocone (F.comp (CategoryTheory.Comma.snd L R))\n⊢ Eq (CategoryTheory.Comma.coconeOfPreserves F t₁ c₂).pt.hom ((CategoryTheory.Limits.isColimitOfPreserves L t₁).desc (CategoryTheory.Comma.colimitAuxiliaryCocone F c₂))","decl":"/--\nIf `L` preserves the appropriate colimit, then given a colimit cocone for `F ⋙ fst L R : J ⥤ L` and\na cocone for `F ⋙ snd L R : J ⥤ R` we can build a cocone for `F` which will turn out to be a\ncolimit cocone.\n-/\n@[simps]\nnoncomputable def coconeOfPreserves [PreservesColimit (F ⋙ fst L R) L] {c₁ : Cocone (F ⋙ fst L R)}\n    (t₁ : IsColimit c₁) (c₂ : Cocone (F ⋙ snd L R)) : Cocone F where\n  pt :=\n    { left := c₁.pt\n      right := c₂.pt\n      hom := (isColimitOfPreserves L t₁).desc (colimitAuxiliaryCocone _ c₂) }\n  ι :=\n    { app := fun j =>\n        { left := c₁.ι.app j\n          right := c₂.ι.app j\n          w := (isColimitOfPreserves L t₁).fac (colimitAuxiliaryCocone _ c₂) j }\n      naturality := fun j₁ j₂ t => by\n        ext\n        · simp [← c₁.w t]\n        · simp [← c₂.w t] }\n\n"}
{"name":"CategoryTheory.Comma.coconeOfPreserves_ι_app_right","module":"Mathlib.CategoryTheory.Limits.Comma","initialProofState":"J : Type w\ninst✝⁴ : CategoryTheory.Category.{w', w} J\nA : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nF : CategoryTheory.Functor J (CategoryTheory.Comma L R)\ninst✝ : CategoryTheory.Limits.PreservesColimit (F.comp (CategoryTheory.Comma.fst L R)) L\nc₁ : CategoryTheory.Limits.Cocone (F.comp (CategoryTheory.Comma.fst L R))\nt₁ : CategoryTheory.Limits.IsColimit c₁\nc₂ : CategoryTheory.Limits.Cocone (F.comp (CategoryTheory.Comma.snd L R))\nj : J\n⊢ Eq ((CategoryTheory.Comma.coconeOfPreserves F t₁ c₂).ι.app j).right (c₂.ι.app j)","decl":"/--\nIf `L` preserves the appropriate colimit, then given a colimit cocone for `F ⋙ fst L R : J ⥤ L` and\na cocone for `F ⋙ snd L R : J ⥤ R` we can build a cocone for `F` which will turn out to be a\ncolimit cocone.\n-/\n@[simps]\nnoncomputable def coconeOfPreserves [PreservesColimit (F ⋙ fst L R) L] {c₁ : Cocone (F ⋙ fst L R)}\n    (t₁ : IsColimit c₁) (c₂ : Cocone (F ⋙ snd L R)) : Cocone F where\n  pt :=\n    { left := c₁.pt\n      right := c₂.pt\n      hom := (isColimitOfPreserves L t₁).desc (colimitAuxiliaryCocone _ c₂) }\n  ι :=\n    { app := fun j =>\n        { left := c₁.ι.app j\n          right := c₂.ι.app j\n          w := (isColimitOfPreserves L t₁).fac (colimitAuxiliaryCocone _ c₂) j }\n      naturality := fun j₁ j₂ t => by\n        ext\n        · simp [← c₁.w t]\n        · simp [← c₂.w t] }\n\n"}
{"name":"CategoryTheory.Comma.hasLimit","module":"Mathlib.CategoryTheory.Limits.Comma","initialProofState":"J : Type w\ninst✝⁶ : CategoryTheory.Category.{w', w} J\nA : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nF : CategoryTheory.Functor J (CategoryTheory.Comma L R)\ninst✝² : CategoryTheory.Limits.HasLimit (F.comp (CategoryTheory.Comma.fst L R))\ninst✝¹ : CategoryTheory.Limits.HasLimit (F.comp (CategoryTheory.Comma.snd L R))\ninst✝ : CategoryTheory.Limits.PreservesLimit (F.comp (CategoryTheory.Comma.snd L R)) R\n⊢ CategoryTheory.Limits.HasLimit F","decl":"instance hasLimit (F : J ⥤ Comma L R) [HasLimit (F ⋙ fst L R)] [HasLimit (F ⋙ snd L R)]\n    [PreservesLimit (F ⋙ snd L R) R] : HasLimit F :=\n  HasLimit.mk ⟨_, coneOfPreservesIsLimit _ (limit.isLimit _) (limit.isLimit _)⟩\n\n"}
{"name":"CategoryTheory.Comma.hasLimitsOfShape","module":"Mathlib.CategoryTheory.Limits.Comma","initialProofState":"J : Type w\ninst✝⁶ : CategoryTheory.Category.{w', w} J\nA : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\ninst✝² : CategoryTheory.Limits.HasLimitsOfShape J A\ninst✝¹ : CategoryTheory.Limits.HasLimitsOfShape J B\ninst✝ : CategoryTheory.Limits.PreservesLimitsOfShape J R\n⊢ CategoryTheory.Limits.HasLimitsOfShape J (CategoryTheory.Comma L R)","decl":"instance hasLimitsOfShape [HasLimitsOfShape J A] [HasLimitsOfShape J B]\n    [PreservesLimitsOfShape J R] : HasLimitsOfShape J (Comma L R) where\n\n"}
{"name":"CategoryTheory.Comma.hasLimitsOfSize","module":"Mathlib.CategoryTheory.Limits.Comma","initialProofState":"A : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\ninst✝² : CategoryTheory.Limits.HasLimitsOfSize.{w, w', v₁, u₁} A\ninst✝¹ : CategoryTheory.Limits.HasLimitsOfSize.{w, w', v₂, u₂} B\ninst✝ : CategoryTheory.Limits.PreservesLimitsOfSize.{w, w', v₂, v₃, u₂, u₃} R\n⊢ CategoryTheory.Limits.HasLimitsOfSize.{w, w', max v₁ v₂, max (max u₂ u₁) v₃} (CategoryTheory.Comma L R)","decl":"instance hasLimitsOfSize [HasLimitsOfSize.{w, w'} A] [HasLimitsOfSize.{w, w'} B]\n    [PreservesLimitsOfSize.{w, w'} R] : HasLimitsOfSize.{w, w'} (Comma L R) :=\n  ⟨fun _ _ => inferInstance⟩\n\n"}
{"name":"CategoryTheory.Comma.hasColimit","module":"Mathlib.CategoryTheory.Limits.Comma","initialProofState":"J : Type w\ninst✝⁶ : CategoryTheory.Category.{w', w} J\nA : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nF : CategoryTheory.Functor J (CategoryTheory.Comma L R)\ninst✝² : CategoryTheory.Limits.HasColimit (F.comp (CategoryTheory.Comma.fst L R))\ninst✝¹ : CategoryTheory.Limits.HasColimit (F.comp (CategoryTheory.Comma.snd L R))\ninst✝ : CategoryTheory.Limits.PreservesColimit (F.comp (CategoryTheory.Comma.fst L R)) L\n⊢ CategoryTheory.Limits.HasColimit F","decl":"instance hasColimit (F : J ⥤ Comma L R) [HasColimit (F ⋙ fst L R)] [HasColimit (F ⋙ snd L R)]\n    [PreservesColimit (F ⋙ fst L R) L] : HasColimit F :=\n  HasColimit.mk ⟨_, coconeOfPreservesIsColimit _ (colimit.isColimit _) (colimit.isColimit _)⟩\n\n"}
{"name":"CategoryTheory.Comma.hasColimitsOfShape","module":"Mathlib.CategoryTheory.Limits.Comma","initialProofState":"J : Type w\ninst✝⁶ : CategoryTheory.Category.{w', w} J\nA : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\ninst✝² : CategoryTheory.Limits.HasColimitsOfShape J A\ninst✝¹ : CategoryTheory.Limits.HasColimitsOfShape J B\ninst✝ : CategoryTheory.Limits.PreservesColimitsOfShape J L\n⊢ CategoryTheory.Limits.HasColimitsOfShape J (CategoryTheory.Comma L R)","decl":"instance hasColimitsOfShape [HasColimitsOfShape J A] [HasColimitsOfShape J B]\n    [PreservesColimitsOfShape J L] : HasColimitsOfShape J (Comma L R) where\n\n"}
{"name":"CategoryTheory.Comma.hasColimitsOfSize","module":"Mathlib.CategoryTheory.Limits.Comma","initialProofState":"A : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\ninst✝² : CategoryTheory.Limits.HasColimitsOfSize.{w, w', v₁, u₁} A\ninst✝¹ : CategoryTheory.Limits.HasColimitsOfSize.{w, w', v₂, u₂} B\ninst✝ : CategoryTheory.Limits.PreservesColimitsOfSize.{w, w', v₁, v₃, u₁, u₃} L\n⊢ CategoryTheory.Limits.HasColimitsOfSize.{w, w', max v₁ v₂, max (max u₂ u₁) v₃} (CategoryTheory.Comma L R)","decl":"instance hasColimitsOfSize [HasColimitsOfSize.{w, w'} A] [HasColimitsOfSize.{w, w'} B]\n    [PreservesColimitsOfSize.{w, w'} L] : HasColimitsOfSize.{w, w'} (Comma L R) :=\n  ⟨fun _ _ => inferInstance⟩\n\n"}
{"name":"CategoryTheory.Arrow.hasLimit","module":"Mathlib.CategoryTheory.Limits.Comma","initialProofState":"J : Type w\ninst✝¹ : CategoryTheory.Category.{w', w} J\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nF : CategoryTheory.Functor J (CategoryTheory.Arrow T)\ni₁ : CategoryTheory.Limits.HasLimit (F.comp CategoryTheory.Arrow.leftFunc)\ni₂ : CategoryTheory.Limits.HasLimit (F.comp CategoryTheory.Arrow.rightFunc)\n⊢ CategoryTheory.Limits.HasLimit F","decl":"instance hasLimit (F : J ⥤ Arrow T) [i₁ : HasLimit (F ⋙ leftFunc)] [i₂ : HasLimit (F ⋙ rightFunc)] :\n    HasLimit F := by\n  haveI : HasLimit (F ⋙ Comma.fst _ _) := i₁\n  haveI : HasLimit (F ⋙ Comma.snd _ _) := i₂\n  apply Comma.hasLimit\n\n"}
{"name":"CategoryTheory.Arrow.hasLimitsOfShape","module":"Mathlib.CategoryTheory.Limits.Comma","initialProofState":"J : Type w\ninst✝² : CategoryTheory.Category.{w', w} J\nT : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} T\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape J T\n⊢ CategoryTheory.Limits.HasLimitsOfShape J (CategoryTheory.Arrow T)","decl":"instance hasLimitsOfShape [HasLimitsOfShape J T] : HasLimitsOfShape J (Arrow T) where\n\n"}
{"name":"CategoryTheory.Arrow.hasLimits","module":"Mathlib.CategoryTheory.Limits.Comma","initialProofState":"T : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} T\ninst✝ : CategoryTheory.Limits.HasLimits T\n⊢ CategoryTheory.Limits.HasLimits (CategoryTheory.Arrow T)","decl":"instance hasLimits [HasLimits T] : HasLimits (Arrow T) :=\n  ⟨fun _ _ => inferInstance⟩\n\n"}
{"name":"CategoryTheory.Arrow.hasColimit","module":"Mathlib.CategoryTheory.Limits.Comma","initialProofState":"J : Type w\ninst✝¹ : CategoryTheory.Category.{w', w} J\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nF : CategoryTheory.Functor J (CategoryTheory.Arrow T)\ni₁ : CategoryTheory.Limits.HasColimit (F.comp CategoryTheory.Arrow.leftFunc)\ni₂ : CategoryTheory.Limits.HasColimit (F.comp CategoryTheory.Arrow.rightFunc)\n⊢ CategoryTheory.Limits.HasColimit F","decl":"instance hasColimit (F : J ⥤ Arrow T) [i₁ : HasColimit (F ⋙ leftFunc)]\n    [i₂ : HasColimit (F ⋙ rightFunc)] : HasColimit F := by\n  haveI : HasColimit (F ⋙ Comma.fst _ _) := i₁\n  haveI : HasColimit (F ⋙ Comma.snd _ _) := i₂\n  apply Comma.hasColimit\n\n"}
{"name":"CategoryTheory.Arrow.hasColimitsOfShape","module":"Mathlib.CategoryTheory.Limits.Comma","initialProofState":"J : Type w\ninst✝² : CategoryTheory.Category.{w', w} J\nT : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} T\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape J T\n⊢ CategoryTheory.Limits.HasColimitsOfShape J (CategoryTheory.Arrow T)","decl":"instance hasColimitsOfShape [HasColimitsOfShape J T] : HasColimitsOfShape J (Arrow T) where\n\n"}
{"name":"CategoryTheory.Arrow.hasColimits","module":"Mathlib.CategoryTheory.Limits.Comma","initialProofState":"T : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} T\ninst✝ : CategoryTheory.Limits.HasColimits T\n⊢ CategoryTheory.Limits.HasColimits (CategoryTheory.Arrow T)","decl":"instance hasColimits [HasColimits T] : HasColimits (Arrow T) :=\n  ⟨fun _ _ => inferInstance⟩\n\n"}
{"name":"CategoryTheory.StructuredArrow.hasLimit","module":"Mathlib.CategoryTheory.Limits.Comma","initialProofState":"J : Type w\ninst✝² : CategoryTheory.Category.{w', w} J\nA : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} A\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nX : T\nG : CategoryTheory.Functor A T\nF : CategoryTheory.Functor J (CategoryTheory.StructuredArrow X G)\ni₁ : CategoryTheory.Limits.HasLimit (F.comp (CategoryTheory.StructuredArrow.proj X G))\ni₂ : CategoryTheory.Limits.PreservesLimit (F.comp (CategoryTheory.StructuredArrow.proj X G)) G\n⊢ CategoryTheory.Limits.HasLimit F","decl":"instance hasLimit [i₁ : HasLimit (F ⋙ proj X G)] [i₂ : PreservesLimit (F ⋙ proj X G) G] :\n    HasLimit F := by\n  haveI : HasLimit (F ⋙ Comma.snd (Functor.fromPUnit X) G) := i₁\n  haveI : PreservesLimit (F ⋙ Comma.snd (Functor.fromPUnit X) G) _ := i₂\n  apply Comma.hasLimit\n\n"}
{"name":"CategoryTheory.StructuredArrow.hasLimitsOfShape","module":"Mathlib.CategoryTheory.Limits.Comma","initialProofState":"J : Type w\ninst✝⁴ : CategoryTheory.Category.{w', w} J\nA : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} A\nT : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} T\nX : T\nG : CategoryTheory.Functor A T\ninst✝¹ : CategoryTheory.Limits.HasLimitsOfShape J A\ninst✝ : CategoryTheory.Limits.PreservesLimitsOfShape J G\n⊢ CategoryTheory.Limits.HasLimitsOfShape J (CategoryTheory.StructuredArrow X G)","decl":"instance hasLimitsOfShape [HasLimitsOfShape J A] [PreservesLimitsOfShape J G] :\n    HasLimitsOfShape J (StructuredArrow X G) where\n\n"}
{"name":"CategoryTheory.StructuredArrow.hasLimitsOfSize","module":"Mathlib.CategoryTheory.Limits.Comma","initialProofState":"A : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} A\nT : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} T\nX : T\nG : CategoryTheory.Functor A T\ninst✝¹ : CategoryTheory.Limits.HasLimitsOfSize.{w, w', v₁, u₁} A\ninst✝ : CategoryTheory.Limits.PreservesLimitsOfSize.{w, w', v₁, v₃, u₁, u₃} G\n⊢ CategoryTheory.Limits.HasLimitsOfSize.{w, w', v₁, max u₁ v₃} (CategoryTheory.StructuredArrow X G)","decl":"instance hasLimitsOfSize [HasLimitsOfSize.{w, w'} A] [PreservesLimitsOfSize.{w, w'} G] :\n    HasLimitsOfSize.{w, w'} (StructuredArrow X G) :=\n  ⟨fun J hJ => by infer_instance⟩\n\n"}
{"name":"CategoryTheory.StructuredArrow.mono_right_of_mono","module":"Mathlib.CategoryTheory.Limits.Comma","initialProofState":"A : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} A\nT : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} T\nX : T\nG : CategoryTheory.Functor A T\ninst✝² : CategoryTheory.Limits.HasPullbacks A\ninst✝¹ : CategoryTheory.Limits.PreservesLimitsOfShape CategoryTheory.Limits.WalkingCospan G\nY Z : CategoryTheory.StructuredArrow X G\nf : Quiver.Hom Y Z\ninst✝ : CategoryTheory.Mono f\n⊢ CategoryTheory.Mono f.right","decl":"instance mono_right_of_mono [HasPullbacks A] [PreservesLimitsOfShape WalkingCospan G]\n    {Y Z : StructuredArrow X G} (f : Y ⟶ Z) [Mono f] : Mono f.right :=\n  show Mono ((proj X G).map f) from inferInstance\n\n"}
{"name":"CategoryTheory.StructuredArrow.mono_iff_mono_right","module":"Mathlib.CategoryTheory.Limits.Comma","initialProofState":"A : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} A\nT : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} T\nX : T\nG : CategoryTheory.Functor A T\ninst✝¹ : CategoryTheory.Limits.HasPullbacks A\ninst✝ : CategoryTheory.Limits.PreservesLimitsOfShape CategoryTheory.Limits.WalkingCospan G\nY Z : CategoryTheory.StructuredArrow X G\nf : Quiver.Hom Y Z\n⊢ Iff (CategoryTheory.Mono f) (CategoryTheory.Mono f.right)","decl":"theorem mono_iff_mono_right [HasPullbacks A] [PreservesLimitsOfShape WalkingCospan G]\n    {Y Z : StructuredArrow X G} (f : Y ⟶ Z) : Mono f ↔ Mono f.right :=\n  ⟨fun _ => inferInstance, fun _ => mono_of_mono_right f⟩\n\n"}
{"name":"CategoryTheory.CostructuredArrow.hasTerminal","module":"Mathlib.CategoryTheory.Limits.Comma","initialProofState":"A : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} A\nT : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} T\nG : CategoryTheory.Functor A T\ninst✝¹ : G.Faithful\ninst✝ : G.Full\nY : A\n⊢ CategoryTheory.Limits.HasTerminal (CategoryTheory.CostructuredArrow G (G.obj Y))","decl":"instance hasTerminal [G.Faithful] [G.Full] {Y : A} :\n    HasTerminal (CostructuredArrow G (G.obj Y)) :=\n  CostructuredArrow.mkIdTerminal.hasTerminal\n\n"}
{"name":"CategoryTheory.CostructuredArrow.hasColimit","module":"Mathlib.CategoryTheory.Limits.Comma","initialProofState":"J : Type w\ninst✝² : CategoryTheory.Category.{w', w} J\nA : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} A\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nG : CategoryTheory.Functor A T\nX : T\nF : CategoryTheory.Functor J (CategoryTheory.CostructuredArrow G X)\ni₁ : CategoryTheory.Limits.HasColimit (F.comp (CategoryTheory.CostructuredArrow.proj G X))\ni₂ : CategoryTheory.Limits.PreservesColimit (F.comp (CategoryTheory.CostructuredArrow.proj G X)) G\n⊢ CategoryTheory.Limits.HasColimit F","decl":"instance hasColimit [i₁ : HasColimit (F ⋙ proj G X)] [i₂ : PreservesColimit (F ⋙ proj G X) G] :\n    HasColimit F := by\n  haveI : HasColimit (F ⋙ Comma.fst G (Functor.fromPUnit X)) := i₁\n  haveI : PreservesColimit (F ⋙ Comma.fst G (Functor.fromPUnit X)) _ := i₂\n  apply Comma.hasColimit\n\n"}
{"name":"CategoryTheory.CostructuredArrow.hasColimitsOfShape","module":"Mathlib.CategoryTheory.Limits.Comma","initialProofState":"J : Type w\ninst✝⁴ : CategoryTheory.Category.{w', w} J\nA : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} A\nT : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} T\nG : CategoryTheory.Functor A T\nX : T\ninst✝¹ : CategoryTheory.Limits.HasColimitsOfShape J A\ninst✝ : CategoryTheory.Limits.PreservesColimitsOfShape J G\n⊢ CategoryTheory.Limits.HasColimitsOfShape J (CategoryTheory.CostructuredArrow G X)","decl":"instance hasColimitsOfShape [HasColimitsOfShape J A] [PreservesColimitsOfShape J G] :\n    HasColimitsOfShape J (CostructuredArrow G X) where\n\n"}
{"name":"CategoryTheory.CostructuredArrow.hasColimitsOfSize","module":"Mathlib.CategoryTheory.Limits.Comma","initialProofState":"A : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} A\nT : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} T\nG : CategoryTheory.Functor A T\nX : T\ninst✝¹ : CategoryTheory.Limits.HasColimitsOfSize.{w, w', v₁, u₁} A\ninst✝ : CategoryTheory.Limits.PreservesColimitsOfSize.{w, w', v₁, v₃, u₁, u₃} G\n⊢ CategoryTheory.Limits.HasColimitsOfSize.{w, w', v₁, max u₁ v₃} (CategoryTheory.CostructuredArrow G X)","decl":"instance hasColimitsOfSize [HasColimitsOfSize.{w, w'} A] [PreservesColimitsOfSize.{w, w'} G] :\n    HasColimitsOfSize.{w, w'} (CostructuredArrow G X) :=\n  ⟨fun _ _ => inferInstance⟩\n\n"}
{"name":"CategoryTheory.CostructuredArrow.epi_left_of_epi","module":"Mathlib.CategoryTheory.Limits.Comma","initialProofState":"A : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} A\nT : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} T\nG : CategoryTheory.Functor A T\nX : T\ninst✝² : CategoryTheory.Limits.HasPushouts A\ninst✝¹ : CategoryTheory.Limits.PreservesColimitsOfShape CategoryTheory.Limits.WalkingSpan G\nY Z : CategoryTheory.CostructuredArrow G X\nf : Quiver.Hom Y Z\ninst✝ : CategoryTheory.Epi f\n⊢ CategoryTheory.Epi f.left","decl":"instance epi_left_of_epi [HasPushouts A] [PreservesColimitsOfShape WalkingSpan G]\n    {Y Z : CostructuredArrow G X} (f : Y ⟶ Z) [Epi f] : Epi f.left :=\n  show Epi ((proj G X).map f) from inferInstance\n\n"}
{"name":"CategoryTheory.CostructuredArrow.epi_iff_epi_left","module":"Mathlib.CategoryTheory.Limits.Comma","initialProofState":"A : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} A\nT : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} T\nG : CategoryTheory.Functor A T\nX : T\ninst✝¹ : CategoryTheory.Limits.HasPushouts A\ninst✝ : CategoryTheory.Limits.PreservesColimitsOfShape CategoryTheory.Limits.WalkingSpan G\nY Z : CategoryTheory.CostructuredArrow G X\nf : Quiver.Hom Y Z\n⊢ Iff (CategoryTheory.Epi f) (CategoryTheory.Epi f.left)","decl":"theorem epi_iff_epi_left [HasPushouts A] [PreservesColimitsOfShape WalkingSpan G]\n    {Y Z : CostructuredArrow G X} (f : Y ⟶ Z) : Epi f ↔ Epi f.left :=\n  ⟨fun _ => inferInstance, fun _ => epi_of_epi_left f⟩\n\n"}
{"name":"CategoryTheory.Over.instHasTerminal","module":"Mathlib.CategoryTheory.Limits.Comma","initialProofState":"T : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nX : T\n⊢ CategoryTheory.Limits.HasTerminal (CategoryTheory.Over X)","decl":"instance {X : T} : HasTerminal (Over X) := CostructuredArrow.hasTerminal\n\n"}
