{"name":"Int.le_natCast_sub","module":"Mathlib.Data.Int.Lemmas","initialProofState":"m n : Nat\n⊢ LE.le (HSub.hSub ↑m ↑n) ↑(HSub.hSub m n)","decl":"theorem le_natCast_sub (m n : ℕ) : (m - n : ℤ) ≤ ↑(m - n : ℕ) := by\n  by_cases h : m ≥ n\n  · exact le_of_eq (Int.ofNat_sub h).symm\n  · simp [le_of_not_ge h, ofNat_le]\n\n"}
{"name":"Int.succ_natCast_pos","module":"Mathlib.Data.Int.Lemmas","initialProofState":"n : Nat\n⊢ LT.lt 0 (HAdd.hAdd (↑n) 1)","decl":"theorem succ_natCast_pos (n : ℕ) : 0 < (n : ℤ) + 1 :=\n  lt_add_one_iff.mpr (by simp)\n\n"}
{"name":"Int.natAbs_eq_iff_sq_eq","module":"Mathlib.Data.Int.Lemmas","initialProofState":"a b : Int\n⊢ Iff (Eq a.natAbs b.natAbs) (Eq (HPow.hPow a 2) (HPow.hPow b 2))","decl":"theorem natAbs_eq_iff_sq_eq {a b : ℤ} : a.natAbs = b.natAbs ↔ a ^ 2 = b ^ 2 := by\n  rw [sq, sq]\n  exact natAbs_eq_iff_mul_self_eq\n\n"}
{"name":"Int.natAbs_lt_iff_sq_lt","module":"Mathlib.Data.Int.Lemmas","initialProofState":"a b : Int\n⊢ Iff (LT.lt a.natAbs b.natAbs) (LT.lt (HPow.hPow a 2) (HPow.hPow b 2))","decl":"theorem natAbs_lt_iff_sq_lt {a b : ℤ} : a.natAbs < b.natAbs ↔ a ^ 2 < b ^ 2 := by\n  rw [sq, sq]\n  exact natAbs_lt_iff_mul_self_lt\n\n"}
{"name":"Int.natAbs_le_iff_sq_le","module":"Mathlib.Data.Int.Lemmas","initialProofState":"a b : Int\n⊢ Iff (LE.le a.natAbs b.natAbs) (LE.le (HPow.hPow a 2) (HPow.hPow b 2))","decl":"theorem natAbs_le_iff_sq_le {a b : ℤ} : a.natAbs ≤ b.natAbs ↔ a ^ 2 ≤ b ^ 2 := by\n  rw [sq, sq]\n  exact natAbs_le_iff_mul_self_le\n\n"}
{"name":"Int.natAbs_inj_of_nonneg_of_nonneg","module":"Mathlib.Data.Int.Lemmas","initialProofState":"a b : Int\nha : LE.le 0 a\nhb : LE.le 0 b\n⊢ Iff (Eq a.natAbs b.natAbs) (Eq a b)","decl":"theorem natAbs_inj_of_nonneg_of_nonneg {a b : ℤ} (ha : 0 ≤ a) (hb : 0 ≤ b) :\n    natAbs a = natAbs b ↔ a = b := by rw [← sq_eq_sq₀ ha hb, ← natAbs_eq_iff_sq_eq]\n\n"}
{"name":"Int.natAbs_inj_of_nonpos_of_nonpos","module":"Mathlib.Data.Int.Lemmas","initialProofState":"a b : Int\nha : LE.le a 0\nhb : LE.le b 0\n⊢ Iff (Eq a.natAbs b.natAbs) (Eq a b)","decl":"theorem natAbs_inj_of_nonpos_of_nonpos {a b : ℤ} (ha : a ≤ 0) (hb : b ≤ 0) :\n    natAbs a = natAbs b ↔ a = b := by\n  simpa only [Int.natAbs_neg, neg_inj] using\n    natAbs_inj_of_nonneg_of_nonneg (neg_nonneg_of_nonpos ha) (neg_nonneg_of_nonpos hb)\n\n"}
{"name":"Int.natAbs_inj_of_nonneg_of_nonpos","module":"Mathlib.Data.Int.Lemmas","initialProofState":"a b : Int\nha : LE.le 0 a\nhb : LE.le b 0\n⊢ Iff (Eq a.natAbs b.natAbs) (Eq a (Neg.neg b))","decl":"theorem natAbs_inj_of_nonneg_of_nonpos {a b : ℤ} (ha : 0 ≤ a) (hb : b ≤ 0) :\n    natAbs a = natAbs b ↔ a = -b := by\n  simpa only [Int.natAbs_neg] using natAbs_inj_of_nonneg_of_nonneg ha (neg_nonneg_of_nonpos hb)\n\n"}
{"name":"Int.natAbs_inj_of_nonpos_of_nonneg","module":"Mathlib.Data.Int.Lemmas","initialProofState":"a b : Int\nha : LE.le a 0\nhb : LE.le 0 b\n⊢ Iff (Eq a.natAbs b.natAbs) (Eq (Neg.neg a) b)","decl":"theorem natAbs_inj_of_nonpos_of_nonneg {a b : ℤ} (ha : a ≤ 0) (hb : 0 ≤ b) :\n    natAbs a = natAbs b ↔ -a = b := by\n  simpa only [Int.natAbs_neg] using natAbs_inj_of_nonneg_of_nonneg (neg_nonneg_of_nonpos ha) hb\n\n"}
{"name":"Int.natAbs_coe_sub_coe_le_of_le","module":"Mathlib.Data.Int.Lemmas","initialProofState":"a b n : Nat\na_le_n : LE.le a n\nb_le_n : LE.le b n\n⊢ LE.le (HSub.hSub ↑a ↑b).natAbs n","decl":"/-- A specialization of `abs_sub_le_of_nonneg_of_le` for working with the signed subtraction\n  of natural numbers. -/\ntheorem natAbs_coe_sub_coe_le_of_le {a b n : ℕ} (a_le_n : a ≤ n) (b_le_n : b ≤ n) :\n    natAbs (a - b : ℤ) ≤ n := by\n  rw [← Nat.cast_le (α := ℤ), natCast_natAbs]\n  exact abs_sub_le_of_nonneg_of_le (ofNat_nonneg a) (ofNat_le.mpr a_le_n)\n    (ofNat_nonneg b) (ofNat_le.mpr b_le_n)\n\n"}
{"name":"Int.natAbs_coe_sub_coe_lt_of_lt","module":"Mathlib.Data.Int.Lemmas","initialProofState":"a b n : Nat\na_lt_n : LT.lt a n\nb_lt_n : LT.lt b n\n⊢ LT.lt (HSub.hSub ↑a ↑b).natAbs n","decl":"/-- A specialization of `abs_sub_lt_of_nonneg_of_lt` for working with the signed subtraction\n  of natural numbers. -/\ntheorem natAbs_coe_sub_coe_lt_of_lt {a b n : ℕ} (a_lt_n : a < n) (b_lt_n : b < n) :\n    natAbs (a - b : ℤ) < n := by\n  rw [← Nat.cast_lt (α := ℤ), natCast_natAbs]\n  exact abs_sub_lt_of_nonneg_of_lt (ofNat_nonneg a) (ofNat_lt.mpr a_lt_n)\n    (ofNat_nonneg b) (ofNat_lt.mpr b_lt_n)\n\n"}
{"name":"Int.strictMonoOn_natAbs","module":"Mathlib.Data.Int.Lemmas","initialProofState":"⊢ StrictMonoOn Int.natAbs (Set.Ici 0)","decl":"theorem strictMonoOn_natAbs : StrictMonoOn natAbs (Ici 0) := fun _ ha _ _ hab =>\n  natAbs_lt_natAbs_of_nonneg_of_lt ha hab\n\n"}
{"name":"Int.strictAntiOn_natAbs","module":"Mathlib.Data.Int.Lemmas","initialProofState":"⊢ StrictAntiOn Int.natAbs (Set.Iic 0)","decl":"theorem strictAntiOn_natAbs : StrictAntiOn natAbs (Iic 0) := fun a _ b hb hab => by\n  simpa [Int.natAbs_neg] using\n    natAbs_lt_natAbs_of_nonneg_of_lt (Right.nonneg_neg_iff.mpr hb) (neg_lt_neg_iff.mpr hab)\n\n"}
{"name":"Int.injOn_natAbs_Ici","module":"Mathlib.Data.Int.Lemmas","initialProofState":"⊢ Set.InjOn Int.natAbs (Set.Ici 0)","decl":"theorem injOn_natAbs_Ici : InjOn natAbs (Ici 0) :=\n  strictMonoOn_natAbs.injOn\n\n"}
{"name":"Int.injOn_natAbs_Iic","module":"Mathlib.Data.Int.Lemmas","initialProofState":"⊢ Set.InjOn Int.natAbs (Set.Iic 0)","decl":"theorem injOn_natAbs_Iic : InjOn natAbs (Iic 0) :=\n  strictAntiOn_natAbs.injOn\n\n"}
{"name":"Int.toNat_of_nonpos","module":"Mathlib.Data.Int.Lemmas","initialProofState":"z : Int\na✝ : LE.le z 0\n⊢ Eq z.toNat 0","decl":"theorem toNat_of_nonpos : ∀ {z : ℤ}, z ≤ 0 → z.toNat = 0\n  | 0, _ => rfl\n  | (n + 1 : ℕ), h => (h.not_lt (by simp)).elim\n  | -[_+1], _ => rfl\n\n"}
{"name":"Int.div2_bit","module":"Mathlib.Data.Int.Lemmas","initialProofState":"b : Bool\nn : Int\n⊢ Eq (Int.bit b n).div2 n","decl":"@[simp]\ntheorem div2_bit (b n) : div2 (bit b n) = n := by\n  rw [bit_val, div2_val, add_comm, Int.add_mul_ediv_left, (_ : (_ / 2 : ℤ) = 0), zero_add]\n  cases b\n  · decide\n  · show ofNat _ = _\n    rw [Nat.div_eq_of_lt] <;> simp\n  · decide\n\n"}
{"name":"Int.ediv_emod_unique'","module":"Mathlib.Data.Int.Lemmas","initialProofState":"a b r q : Int\nh : Ne b 0\n⊢ Iff (And (Eq (HDiv.hDiv a b) q) (Eq (HMod.hMod a b) r)) (And (Eq (HAdd.hAdd r (HMul.hMul b q)) a) (And (LE.le 0 r) (LT.lt r (abs b))))","decl":"/-- Like `Int.ediv_emod_unique`, but permitting negative `b`. -/\ntheorem ediv_emod_unique' {a b r q : Int} (h : b ≠ 0) :\n    a / b = q ∧ a % b = r ↔ r + b * q = a ∧ 0 ≤ r ∧ r < |b| := by\n  constructor\n  · intro ⟨rfl, rfl⟩\n    exact ⟨emod_add_ediv a b, emod_nonneg _ h, emod_lt _ h⟩\n  · intro ⟨rfl, hz, hb⟩\n    constructor\n    · rw [Int.add_mul_ediv_left r q h, ediv_eq_zero_of_lt_abs hz hb]\n      simp [Int.zero_add]\n    · rw [add_mul_emod_self_left, ← emod_abs, emod_eq_of_lt hz hb]\n\n"}
