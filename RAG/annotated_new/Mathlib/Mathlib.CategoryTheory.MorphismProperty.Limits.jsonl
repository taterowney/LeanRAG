{"name":"CategoryTheory.MorphismProperty.pullbacks_mk","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\nA B X Y : C\nf : Quiver.Hom A X\nq : Quiver.Hom A B\np : Quiver.Hom X Y\ng : Quiver.Hom B Y\nsq : CategoryTheory.IsPullback f q p g\nhp : P p\n‚ä¢ P.pullbacks q","decl":"lemma pullbacks_mk {A B X Y : C} {f : A ‚ü∂ X} {q : A ‚ü∂ B} {p : X ‚ü∂ Y} {g : B ‚ü∂ Y}\n    (sq : IsPullback f q p g) (hp : P p) :\n    P.pullbacks q :=\n  ‚ü®_, _, _, _, _, hp, sq‚ü©\n\n"}
{"name":"CategoryTheory.MorphismProperty.le_pullbacks","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\n‚ä¢ LE.le P P.pullbacks","decl":"lemma le_pullbacks : P ‚â§ P.pullbacks := by\n  intro A B q hq\n  exact P.pullbacks_mk IsPullback.of_id_fst hq\n\n"}
{"name":"CategoryTheory.MorphismProperty.pushouts_mk","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\nA B X Y : C\nf : Quiver.Hom A X\nq : Quiver.Hom A B\np : Quiver.Hom X Y\ng : Quiver.Hom B Y\nsq : CategoryTheory.IsPushout f q p g\nhq : P q\n‚ä¢ P.pushouts p","decl":"lemma pushouts_mk {A B X Y : C} {f : A ‚ü∂ X} {q : A ‚ü∂ B} {p : X ‚ü∂ Y} {g : B ‚ü∂ Y}\n    (sq : IsPushout f q p g) (hq : P q) :\n    P.pushouts p :=\n  ‚ü®_, _, _, _, _, hq, sq‚ü©\n\n"}
{"name":"CategoryTheory.MorphismProperty.le_pushouts","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\n‚ä¢ LE.le P P.pushouts","decl":"lemma le_pushouts : P ‚â§ P.pushouts := by\n  intro X Y p hp\n  exact P.pushouts_mk IsPushout.of_id_fst hp\n\n"}
{"name":"CategoryTheory.MorphismProperty.instRespectsIsoPushouts","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\n‚ä¢ P.pushouts.RespectsIso","decl":"instance : P.pushouts.RespectsIso :=\n  RespectsIso.of_respects_arrow_iso _ (by\n    rintro q q' e ‚ü®A, B, p, f, g, hp, h‚ü©\n    exact ‚ü®A, B, p, f ‚â´ e.hom.left, g ‚â´ e.hom.right, hp,\n      IsPushout.paste_horiz h (IsPushout.of_horiz_isIso ‚ü®e.hom.w‚ü©)‚ü©)\n\n"}
{"name":"CategoryTheory.MorphismProperty.instRespectsIsoPullbacks","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\n‚ä¢ P.pullbacks.RespectsIso","decl":"instance : P.pullbacks.RespectsIso :=\n  RespectsIso.of_respects_arrow_iso _ (by\n    rintro q q' e ‚ü®X, Y, p, f, g, hp, h‚ü©\n    exact ‚ü®X, Y, p, e.inv.left ‚â´ f, e.inv.right ‚â´ g, hp,\n      IsPullback.paste_horiz (IsPullback.of_horiz_isIso ‚ü®e.inv.w‚ü©) h‚ü©)\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsStableUnderBaseChange.of_isPullback","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\nself : P.IsStableUnderBaseChange\nX Y Y' S : C\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nf' : Quiver.Hom Y' Y\ng' : Quiver.Hom Y' X\nsq : CategoryTheory.IsPullback f' g' g f\nhg : P g\n‚ä¢ P g'","decl":"/-- A morphism property is `IsStableUnderBaseChange` if the base change of such a morphism\nstill falls in the class. -/\nclass IsStableUnderBaseChange : Prop where\n  of_isPullback {X Y Y' S : C} {f : X ‚ü∂ S} {g : Y ‚ü∂ S} {f' : Y' ‚ü∂ Y} {g' : Y' ‚ü∂ X}\n    (sq : IsPullback f' g' g f) (hg : P g) : P g'\n\n"}
{"name":"CategoryTheory.MorphismProperty.instIsStableUnderBaseChangePullbacks","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\n‚ä¢ P.pullbacks.IsStableUnderBaseChange","decl":"instance : P.pullbacks.IsStableUnderBaseChange where\n  of_isPullback := by\n    rintro _ _ _ _ _ _ _ _ h ‚ü®_, _, _, _, _, hp, hq‚ü©\n    exact P.pullbacks_mk (h.paste_horiz hq) hp\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsStableUnderCobaseChange.of_isPushout","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\nself : P.IsStableUnderCobaseChange\nA A' B B' : C\nf : Quiver.Hom A A'\ng : Quiver.Hom A B\nf' : Quiver.Hom B B'\ng' : Quiver.Hom A' B'\nsq : CategoryTheory.IsPushout g f f' g'\nhf : P f\n‚ä¢ P f'","decl":"/-- A morphism property is `IsStableUnderCobaseChange` if the cobase change of such a morphism\nstill falls in the class. -/\nclass IsStableUnderCobaseChange : Prop where\n  of_isPushout {A A' B B' : C} {f : A ‚ü∂ A'} {g : A ‚ü∂ B} {f' : B ‚ü∂ B'} {g' : A' ‚ü∂ B'}\n    (sq : IsPushout g f f' g') (hf : P f) : P f'\n\n"}
{"name":"CategoryTheory.MorphismProperty.instIsStableUnderCobaseChangePushouts","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\n‚ä¢ P.pushouts.IsStableUnderCobaseChange","decl":"instance : P.pushouts.IsStableUnderCobaseChange where\n  of_isPushout := by\n    rintro _ _ _ _ _ _ _ _ h ‚ü®_, _, _, _, _, hp, hq‚ü©\n    exact P.pushouts_mk (hq.paste_horiz h) hp\n\n"}
{"name":"CategoryTheory.MorphismProperty.of_isPullback","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\ninst‚úù : P.IsStableUnderBaseChange\nX Y Y' S : C\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nf' : Quiver.Hom Y' Y\ng' : Quiver.Hom Y' X\nsq : CategoryTheory.IsPullback f' g' g f\nhg : P g\n‚ä¢ P g'","decl":"variable {P} in\nlemma of_isPullback [P.IsStableUnderBaseChange]\n    {X Y Y' S : C} {f : X ‚ü∂ S} {g : Y ‚ü∂ S} {f' : Y' ‚ü∂ Y} {g' : Y' ‚ü∂ X}\n    (sq : IsPullback f' g' g f) (hg : P g) : P g' :=\n  IsStableUnderBaseChange.of_isPullback sq hg\n\n"}
{"name":"CategoryTheory.MorphismProperty.isStableUnderBaseChange_iff_pullbacks_le","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\n‚ä¢ Iff P.IsStableUnderBaseChange (LE.le P.pullbacks P)","decl":"lemma isStableUnderBaseChange_iff_pullbacks_le :\n    P.IsStableUnderBaseChange ‚Üî P.pullbacks ‚â§ P := by\n  constructor\n  ¬∑ intro h _ _ _ ‚ü®_, _, _, _, _, h‚ÇÅ, h‚ÇÇ‚ü©\n    exact of_isPullback h‚ÇÇ h‚ÇÅ\n  ¬∑ intro h\n    constructor\n    intro _ _ _ _ _ _ _ _ h‚ÇÅ h‚ÇÇ\n    exact h _ ‚ü®_, _, _, _, _, h‚ÇÇ, h‚ÇÅ‚ü©\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsStableUnderBaseChange.mk'","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\ninst‚úù : P.RespectsIso\nhP‚ÇÇ : ‚àÄ (X Y S : C) (f : Quiver.Hom X S) (g : Quiver.Hom Y S) [inst : CategoryTheory.Limits.HasPullback f g], P g ‚Üí P (CategoryTheory.Limits.pullback.fst f g)\n‚ä¢ P.IsStableUnderBaseChange","decl":"variable {P} in\n/-- Alternative constructor for `IsStableUnderBaseChange`. -/\ntheorem IsStableUnderBaseChange.mk' [RespectsIso P]\n    (hP‚ÇÇ : ‚àÄ (X Y S : C) (f : X ‚ü∂ S) (g : Y ‚ü∂ S) [HasPullback f g] (_ : P g),\n      P (pullback.fst f g)) :\n    IsStableUnderBaseChange P where\n  of_isPullback {X Y Y' S f g f' g'} sq hg := by\n    haveI : HasPullback f g := sq.flip.hasPullback\n    let e := sq.flip.isoPullback\n    rw [‚Üê P.cancel_left_of_respectsIso e.inv, sq.flip.isoPullback_inv_fst]\n    exact hP‚ÇÇ _ _ _ f g hg\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsStableUnderBaseChange.isomorphisms","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\n‚ä¢ (CategoryTheory.MorphismProperty.isomorphisms C).IsStableUnderBaseChange","decl":"instance IsStableUnderBaseChange.isomorphisms :\n    (isomorphisms C).IsStableUnderBaseChange where\n  of_isPullback {_ _ _ _ f g _ _} h hg :=\n    have : IsIso g := hg\n    have := hasPullback_of_left_iso g f\n    h.isoPullback_hom_snd ‚ñ∏ inferInstanceAs (IsIso _)\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsStableUnderBaseChange.monomorphisms","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\n‚ä¢ (CategoryTheory.MorphismProperty.monomorphisms C).IsStableUnderBaseChange","decl":"instance IsStableUnderBaseChange.monomorphisms :\n    (monomorphisms C).IsStableUnderBaseChange where\n  of_isPullback {X Y Y' S f g f' g'} h hg := by\n    have : Mono g := hg\n    constructor\n    intro Z f‚ÇÅ f‚ÇÇ h‚ÇÅ‚ÇÇ\n    apply PullbackCone.IsLimit.hom_ext h.isLimit\n    ¬∑ rw [‚Üê cancel_mono g]\n      dsimp\n      simp only [Category.assoc, h.w, reassoc_of% h‚ÇÅ‚ÇÇ]\n    ¬∑ exact h‚ÇÅ‚ÇÇ\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsStableUnderBaseChange.respectsIso","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\ninst‚úù : P.IsStableUnderBaseChange\n‚ä¢ P.RespectsIso","decl":"instance (priority := 900) IsStableUnderBaseChange.respectsIso\n    [IsStableUnderBaseChange P] : RespectsIso P := by\n  apply RespectsIso.of_respects_arrow_iso\n  intro f g e\n  exact of_isPullback (IsPullback.of_horiz_isIso (CommSq.mk e.inv.w))\n\n"}
{"name":"CategoryTheory.MorphismProperty.pullback_fst","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\ninst‚úù¬π : P.IsStableUnderBaseChange\nX Y S : C\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\ninst‚úù : CategoryTheory.Limits.HasPullback f g\nH : P g\n‚ä¢ P (CategoryTheory.Limits.pullback.fst f g)","decl":"theorem pullback_fst [IsStableUnderBaseChange P]\n    {X Y S : C} (f : X ‚ü∂ S) (g : Y ‚ü∂ S) [HasPullback f g] (H : P g) :\n    P (pullback.fst f g) :=\n  of_isPullback (IsPullback.of_hasPullback f g).flip H\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsStableUnderBaseChange.fst","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\ninst‚úù¬π : P.IsStableUnderBaseChange\nX Y S : C\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\ninst‚úù : CategoryTheory.Limits.HasPullback f g\nH : P g\n‚ä¢ P (CategoryTheory.Limits.pullback.fst f g)","decl":"@[deprecated (since := \"2024-11-06\")] alias IsStableUnderBaseChange.fst := pullback_fst\n\n"}
{"name":"CategoryTheory.MorphismProperty.pullback_snd","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\ninst‚úù¬π : P.IsStableUnderBaseChange\nX Y S : C\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\ninst‚úù : CategoryTheory.Limits.HasPullback f g\nH : P f\n‚ä¢ P (CategoryTheory.Limits.pullback.snd f g)","decl":"theorem pullback_snd [IsStableUnderBaseChange P]\n    {X Y S : C} (f : X ‚ü∂ S) (g : Y ‚ü∂ S) [HasPullback f g] (H : P f) :\n    P (pullback.snd f g) :=\n  of_isPullback (IsPullback.of_hasPullback f g) H\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsStableUnderBaseChange.snd","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\ninst‚úù¬π : P.IsStableUnderBaseChange\nX Y S : C\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\ninst‚úù : CategoryTheory.Limits.HasPullback f g\nH : P f\n‚ä¢ P (CategoryTheory.Limits.pullback.snd f g)","decl":"@[deprecated (since := \"2024-11-06\")] alias IsStableUnderBaseChange.snd := pullback_snd\n\n"}
{"name":"CategoryTheory.MorphismProperty.baseChange_obj","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\ninst‚úù¬π : CategoryTheory.Limits.HasPullbacks C\ninst‚úù : P.IsStableUnderBaseChange\nS S' : C\nf : Quiver.Hom S' S\nX : CategoryTheory.Over S\nH : P X.hom\n‚ä¢ P ((CategoryTheory.Over.pullback f).obj X).hom","decl":"theorem baseChange_obj [HasPullbacks C]\n    [IsStableUnderBaseChange P] {S S' : C} (f : S' ‚ü∂ S) (X : Over S) (H : P X.hom) :\n    P ((Over.pullback f).obj X).hom :=\n  pullback_snd X.hom f H\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsStableUnderBaseChange.baseChange_obj","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\ninst‚úù¬π : CategoryTheory.Limits.HasPullbacks C\ninst‚úù : P.IsStableUnderBaseChange\nS S' : C\nf : Quiver.Hom S' S\nX : CategoryTheory.Over S\nH : P X.hom\n‚ä¢ P ((CategoryTheory.Over.pullback f).obj X).hom","decl":"@[deprecated (since := \"2024-11-06\")] alias IsStableUnderBaseChange.baseChange_obj := baseChange_obj\n\n"}
{"name":"CategoryTheory.MorphismProperty.baseChange_map","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\ninst‚úù¬π : CategoryTheory.Limits.HasPullbacks C\ninst‚úù : P.IsStableUnderBaseChange\nS S' : C\nf : Quiver.Hom S' S\nX Y : CategoryTheory.Over S\ng : Quiver.Hom X Y\nH : P g.left\n‚ä¢ P ((CategoryTheory.Over.pullback f).map g).left","decl":"theorem baseChange_map [HasPullbacks C]\n    [IsStableUnderBaseChange P] {S S' : C} (f : S' ‚ü∂ S) {X Y : Over S} (g : X ‚ü∂ Y)\n    (H : P g.left) : P ((Over.pullback f).map g).left := by\n  let e :=\n    pullbackRightPullbackFstIso Y.hom f g.left ‚â™‚â´\n      pullback.congrHom (g.w.trans (Category.comp_id _)) rfl\n  have : e.inv ‚â´ (pullback.snd _ _) = ((Over.pullback f).map g).left := by\n    ext <;> dsimp [e] <;> simp\n  rw [‚Üê this, P.cancel_left_of_respectsIso]\n  exact pullback_snd _ _ H\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsStableUnderBaseChange.baseChange_map","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\ninst‚úù¬π : CategoryTheory.Limits.HasPullbacks C\ninst‚úù : P.IsStableUnderBaseChange\nS S' : C\nf : Quiver.Hom S' S\nX Y : CategoryTheory.Over S\ng : Quiver.Hom X Y\nH : P g.left\n‚ä¢ P ((CategoryTheory.Over.pullback f).map g).left","decl":"@[deprecated (since := \"2024-11-06\")] alias IsStableUnderBaseChange.baseChange_map := baseChange_map\n\n"}
{"name":"CategoryTheory.MorphismProperty.pullback_map","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\ninst‚úù¬≤ : CategoryTheory.Limits.HasPullbacks C\ninst‚úù¬π : P.IsStableUnderBaseChange\ninst‚úù : P.IsStableUnderComposition\nS X X' Y Y' : C\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nf' : Quiver.Hom X' S\ng' : Quiver.Hom Y' S\ni‚ÇÅ : Quiver.Hom X X'\ni‚ÇÇ : Quiver.Hom Y Y'\nh‚ÇÅ : P i‚ÇÅ\nh‚ÇÇ : P i‚ÇÇ\ne‚ÇÅ : Eq f (CategoryTheory.CategoryStruct.comp i‚ÇÅ f')\ne‚ÇÇ : Eq g (CategoryTheory.CategoryStruct.comp i‚ÇÇ g')\n‚ä¢ P (CategoryTheory.Limits.pullback.map f g f' g' i‚ÇÅ i‚ÇÇ (CategoryTheory.CategoryStruct.id S) ‚ãØ ‚ãØ)","decl":"theorem pullback_map [HasPullbacks C]\n    [IsStableUnderBaseChange P] [P.IsStableUnderComposition] {S X X' Y Y' : C} {f : X ‚ü∂ S}\n    {g : Y ‚ü∂ S} {f' : X' ‚ü∂ S} {g' : Y' ‚ü∂ S} {i‚ÇÅ : X ‚ü∂ X'} {i‚ÇÇ : Y ‚ü∂ Y'} (h‚ÇÅ : P i‚ÇÅ) (h‚ÇÇ : P i‚ÇÇ)\n    (e‚ÇÅ : f = i‚ÇÅ ‚â´ f') (e‚ÇÇ : g = i‚ÇÇ ‚â´ g') :\n    P (pullback.map f g f' g' i‚ÇÅ i‚ÇÇ (ùüô _) ((Category.comp_id _).trans e‚ÇÅ)\n        ((Category.comp_id _).trans e‚ÇÇ)) := by\n  have :\n    pullback.map f g f' g' i‚ÇÅ i‚ÇÇ (ùüô _) ((Category.comp_id _).trans e‚ÇÅ)\n        ((Category.comp_id _).trans e‚ÇÇ) =\n      ((pullbackSymmetry _ _).hom ‚â´\n          ((Over.pullback _).map (Over.homMk _ e‚ÇÇ.symm : Over.mk g ‚ü∂ Over.mk g')).left) ‚â´\n        (pullbackSymmetry _ _).hom ‚â´\n          ((Over.pullback g').map (Over.homMk _ e‚ÇÅ.symm : Over.mk f ‚ü∂ Over.mk f')).left := by\n    ext <;> dsimp <;> simp\n  rw [this]\n  apply P.comp_mem <;> rw [P.cancel_left_of_respectsIso]\n  exacts [baseChange_map _ (Over.homMk _ e‚ÇÇ.symm : Over.mk g ‚ü∂ Over.mk g') h‚ÇÇ,\n    baseChange_map _ (Over.homMk _ e‚ÇÅ.symm : Over.mk f ‚ü∂ Over.mk f') h‚ÇÅ]\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsStableUnderBaseChange.pullback_map","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\ninst‚úù¬≤ : CategoryTheory.Limits.HasPullbacks C\ninst‚úù¬π : P.IsStableUnderBaseChange\ninst‚úù : P.IsStableUnderComposition\nS X X' Y Y' : C\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nf' : Quiver.Hom X' S\ng' : Quiver.Hom Y' S\ni‚ÇÅ : Quiver.Hom X X'\ni‚ÇÇ : Quiver.Hom Y Y'\nh‚ÇÅ : P i‚ÇÅ\nh‚ÇÇ : P i‚ÇÇ\ne‚ÇÅ : Eq f (CategoryTheory.CategoryStruct.comp i‚ÇÅ f')\ne‚ÇÇ : Eq g (CategoryTheory.CategoryStruct.comp i‚ÇÇ g')\n‚ä¢ P (CategoryTheory.Limits.pullback.map f g f' g' i‚ÇÅ i‚ÇÇ (CategoryTheory.CategoryStruct.id S) ‚ãØ ‚ãØ)","decl":"@[deprecated (since := \"2024-11-06\")] alias IsStableUnderBaseChange.pullback_map := pullback_map\n\n"}
{"name":"CategoryTheory.MorphismProperty.of_isPushout","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\ninst‚úù : P.IsStableUnderCobaseChange\nA A' B B' : C\nf : Quiver.Hom A A'\ng : Quiver.Hom A B\nf' : Quiver.Hom B B'\ng' : Quiver.Hom A' B'\nsq : CategoryTheory.IsPushout g f f' g'\nhf : P f\n‚ä¢ P f'","decl":"lemma of_isPushout [P.IsStableUnderCobaseChange]\n    {A A' B B' : C} {f : A ‚ü∂ A'} {g : A ‚ü∂ B} {f' : B ‚ü∂ B'} {g' : A' ‚ü∂ B'}\n    (sq : IsPushout g f f' g') (hf : P f) : P f' :=\n  IsStableUnderCobaseChange.of_isPushout sq hf\n\n"}
{"name":"CategoryTheory.MorphismProperty.isStableUnderCobaseChange_iff_pushouts_le","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\n‚ä¢ Iff P.IsStableUnderCobaseChange (LE.le P.pushouts P)","decl":"lemma isStableUnderCobaseChange_iff_pushouts_le :\n    P.IsStableUnderCobaseChange ‚Üî P.pushouts ‚â§ P := by\n  constructor\n  ¬∑ intro h _ _ _ ‚ü®_, _, _, _, _, h‚ÇÅ, h‚ÇÇ‚ü©\n    exact of_isPushout h‚ÇÇ h‚ÇÅ\n  ¬∑ intro h\n    constructor\n    intro _ _ _ _ _ _ _ _ h‚ÇÅ h‚ÇÇ\n    exact h _ ‚ü®_, _, _, _, _, h‚ÇÇ, h‚ÇÅ‚ü©\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsStableUnderCobaseChange.mk'","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\ninst‚úù : P.RespectsIso\nhP‚ÇÇ : ‚àÄ (A B A' : C) (f : Quiver.Hom A A') (g : Quiver.Hom A B) [inst : CategoryTheory.Limits.HasPushout f g], P f ‚Üí P (CategoryTheory.Limits.pushout.inr f g)\n‚ä¢ P.IsStableUnderCobaseChange","decl":"/-- An alternative constructor for `IsStableUnderCobaseChange`. -/\ntheorem IsStableUnderCobaseChange.mk' [RespectsIso P]\n    (hP‚ÇÇ : ‚àÄ (A B A' : C) (f : A ‚ü∂ A') (g : A ‚ü∂ B) [HasPushout f g] (_ : P f),\n      P (pushout.inr f g)) :\n    IsStableUnderCobaseChange P where\n  of_isPushout {A A' B B' f g f' g'} sq hf := by\n    haveI : HasPushout f g := sq.flip.hasPushout\n    let e := sq.flip.isoPushout\n    rw [‚Üê P.cancel_right_of_respectsIso _ e.hom, sq.flip.inr_isoPushout_hom]\n    exact hP‚ÇÇ _ _ _ f g hf\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsStableUnderCobaseChange.isomorphisms","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\n‚ä¢ (CategoryTheory.MorphismProperty.isomorphisms C).IsStableUnderCobaseChange","decl":"instance IsStableUnderCobaseChange.isomorphisms :\n    (isomorphisms C).IsStableUnderCobaseChange where\n  of_isPushout {_ _ _ _ f g _ _} h (_ : IsIso f) :=\n    have := hasPushout_of_right_iso g f\n    h.inl_isoPushout_inv ‚ñ∏ inferInstanceAs (IsIso _)\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsStableUnderCobaseChange.epimorphisms","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\n‚ä¢ (CategoryTheory.MorphismProperty.epimorphisms C).IsStableUnderCobaseChange","decl":"variable (C) in\ninstance IsStableUnderCobaseChange.epimorphisms :\n    (epimorphisms C).IsStableUnderCobaseChange where\n  of_isPushout {X Y Y' S f g f' g'} h hf := by\n    have : Epi f := hf\n    constructor\n    intro Z f‚ÇÅ f‚ÇÇ h‚ÇÅ‚ÇÇ\n    apply PushoutCocone.IsColimit.hom_ext h.isColimit\n    ¬∑ exact h‚ÇÅ‚ÇÇ\n    ¬∑ rw [‚Üê cancel_epi f]\n      dsimp\n      simp only [‚Üê reassoc_of% h.w, h‚ÇÅ‚ÇÇ]\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsStableUnderCobaseChange.respectsIso","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\ninst‚úù : P.IsStableUnderCobaseChange\n‚ä¢ P.RespectsIso","decl":"instance IsStableUnderCobaseChange.respectsIso\n    [IsStableUnderCobaseChange P] : RespectsIso P :=\n  RespectsIso.of_respects_arrow_iso _ fun _ _ e ‚Ü¶\n    of_isPushout (IsPushout.of_horiz_isIso (CommSq.mk e.hom.w))\n\n"}
{"name":"CategoryTheory.MorphismProperty.pushout_inl","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\ninst‚úù¬π : P.IsStableUnderCobaseChange\nA B A' : C\nf : Quiver.Hom A A'\ng : Quiver.Hom A B\ninst‚úù : CategoryTheory.Limits.HasPushout f g\nH : P g\n‚ä¢ P (CategoryTheory.Limits.pushout.inl f g)","decl":"theorem pushout_inl [IsStableUnderCobaseChange P]\n    {A B A' : C} (f : A ‚ü∂ A') (g : A ‚ü∂ B) [HasPushout f g] (H : P g) :\n    P (pushout.inl f g) :=\n  of_isPushout (IsPushout.of_hasPushout f g) H\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsStableUnderBaseChange.inl","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\ninst‚úù¬π : P.IsStableUnderCobaseChange\nA B A' : C\nf : Quiver.Hom A A'\ng : Quiver.Hom A B\ninst‚úù : CategoryTheory.Limits.HasPushout f g\nH : P g\n‚ä¢ P (CategoryTheory.Limits.pushout.inl f g)","decl":"@[deprecated (since := \"2024-11-06\")] alias IsStableUnderBaseChange.inl := pushout_inl\n\n"}
{"name":"CategoryTheory.MorphismProperty.pushout_inr","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\ninst‚úù¬π : P.IsStableUnderCobaseChange\nA B A' : C\nf : Quiver.Hom A A'\ng : Quiver.Hom A B\ninst‚úù : CategoryTheory.Limits.HasPushout f g\nH : P f\n‚ä¢ P (CategoryTheory.Limits.pushout.inr f g)","decl":"theorem pushout_inr [IsStableUnderCobaseChange P]\n    {A B A' : C} (f : A ‚ü∂ A') (g : A ‚ü∂ B) [HasPushout f g] (H : P f) : P (pushout.inr f g) :=\n  of_isPushout (IsPushout.of_hasPushout f g).flip H\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsStableUnderBaseChange.inr","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\ninst‚úù¬π : P.IsStableUnderCobaseChange\nA B A' : C\nf : Quiver.Hom A A'\ng : Quiver.Hom A B\ninst‚úù : CategoryTheory.Limits.HasPushout f g\nH : P f\n‚ä¢ P (CategoryTheory.Limits.pushout.inr f g)","decl":"@[deprecated (since := \"2024-11-06\")] alias IsStableUnderBaseChange.inr := pushout_inr\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsStableUnderCobaseChange.op","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\ninst‚úù : P.IsStableUnderCobaseChange\n‚ä¢ P.op.IsStableUnderBaseChange","decl":"instance IsStableUnderCobaseChange.op [IsStableUnderCobaseChange P] :\n    IsStableUnderBaseChange P.op where\n  of_isPullback sq hg := P.of_isPushout sq.unop hg\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsStableUnderCobaseChange.unop","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty (Opposite C)\ninst‚úù : P.IsStableUnderCobaseChange\n‚ä¢ P.unop.IsStableUnderBaseChange","decl":"instance IsStableUnderCobaseChange.unop {P : MorphismProperty C·µí·µñ} [IsStableUnderCobaseChange P] :\n    IsStableUnderBaseChange P.unop where\n  of_isPullback sq hg := P.of_isPushout sq.op hg\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsStableUnderBaseChange.op","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\ninst‚úù : P.IsStableUnderBaseChange\n‚ä¢ P.op.IsStableUnderCobaseChange","decl":"instance IsStableUnderBaseChange.op [IsStableUnderBaseChange P] :\n    IsStableUnderCobaseChange P.op where\n  of_isPushout sq hf := P.of_isPullback sq.unop hf\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsStableUnderBaseChange.unop","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty (Opposite C)\ninst‚úù : P.IsStableUnderBaseChange\n‚ä¢ P.unop.IsStableUnderCobaseChange","decl":"instance IsStableUnderBaseChange.unop {P : MorphismProperty C·µí·µñ} [IsStableUnderBaseChange P] :\n    IsStableUnderCobaseChange P.unop where\n  of_isPushout sq hf := P.of_isPullback sq.op hf\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsStableUnderBaseChange.inf","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nP Q : CategoryTheory.MorphismProperty C\ninst‚úù¬π : P.IsStableUnderBaseChange\ninst‚úù : Q.IsStableUnderBaseChange\n‚ä¢ (Min.min P Q).IsStableUnderBaseChange","decl":"instance IsStableUnderBaseChange.inf {P Q : MorphismProperty C} [IsStableUnderBaseChange P]\n    [IsStableUnderBaseChange Q] :\n    IsStableUnderBaseChange (P ‚äì Q) where\n  of_isPullback hp hg := ‚ü®of_isPullback hp hg.left, of_isPullback hp hg.right‚ü©\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsStableUnderCobaseChange.inf","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nP Q : CategoryTheory.MorphismProperty C\ninst‚úù¬π : P.IsStableUnderCobaseChange\ninst‚úù : Q.IsStableUnderCobaseChange\n‚ä¢ (Min.min P Q).IsStableUnderCobaseChange","decl":"instance IsStableUnderCobaseChange.inf {P Q : MorphismProperty C} [IsStableUnderCobaseChange P]\n    [IsStableUnderCobaseChange Q] :\n    IsStableUnderCobaseChange (P ‚äì Q) where\n  of_isPushout hp hg := ‚ü®of_isPushout hp hg.left, of_isPushout hp hg.right‚ü©\n\n"}
{"name":"CategoryTheory.MorphismProperty.instRespectsIsoLimitsOfShape","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nW : CategoryTheory.MorphismProperty C\nJ : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} J\n‚ä¢ (W.limitsOfShape J).RespectsIso","decl":"instance : (W.limitsOfShape J).RespectsIso :=\n  RespectsIso.of_respects_arrow_iso _ (by\n    rintro ‚ü®_, _, f‚ü© ‚ü®Y‚ÇÅ, Y‚ÇÇ, g‚ü© e ‚ü®X‚ÇÅ, X‚ÇÇ, c‚ÇÅ, c‚ÇÇ, h‚ÇÅ, h‚ÇÇ, f, hf‚ü©\n    let e‚ÇÅ := Arrow.leftFunc.mapIso e\n    let e‚ÇÇ := Arrow.rightFunc.mapIso e\n    have fac : g ‚â´ e‚ÇÇ.inv = e‚ÇÅ.inv ‚â´ h‚ÇÇ.lift (Cone.mk _ (c‚ÇÅ.œÄ ‚â´ f)) :=\n      e.inv.w.symm\n    let c‚ÇÅ' : Cone X‚ÇÅ := { pt := Y‚ÇÅ, œÄ := (Functor.const _).map e‚ÇÅ.inv ‚â´ c‚ÇÅ.œÄ }\n    let c‚ÇÇ' : Cone X‚ÇÇ := { pt := Y‚ÇÇ, œÄ := (Functor.const _).map e‚ÇÇ.inv ‚â´ c‚ÇÇ.œÄ }\n    have h‚ÇÅ' : IsLimit c‚ÇÅ' := IsLimit.ofIsoLimit h‚ÇÅ (Cones.ext e‚ÇÅ)\n    have h‚ÇÇ' : IsLimit c‚ÇÇ' := IsLimit.ofIsoLimit h‚ÇÇ (Cones.ext e‚ÇÇ)\n    obtain hg : h‚ÇÇ'.lift (Cone.mk _ (c‚ÇÅ'.œÄ ‚â´ f)) = g :=\n      h‚ÇÇ'.hom_ext (fun j ‚Ü¶ by\n        rw [h‚ÇÇ'.fac]\n        simp [reassoc_of% fac, c‚ÇÅ', c‚ÇÇ'])\n    rw [‚Üê hg]\n    exact ‚ü®_, _, _, _, h‚ÇÅ', _, _, hf‚ü©)\n\n"}
{"name":"CategoryTheory.MorphismProperty.limitsOfShape_limMap","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nW : CategoryTheory.MorphismProperty C\nJ : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} J\nX Y : CategoryTheory.Functor J C\nf : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasLimit X\ninst‚úù : CategoryTheory.Limits.HasLimit Y\nhf : W.functorCategory J f\n‚ä¢ W.limitsOfShape J (CategoryTheory.Limits.limMap f)","decl":"variable {J} in\nlemma limitsOfShape_limMap {X Y : J ‚•§ C}\n    (f : X ‚ü∂ Y) [HasLimit X] [HasLimit Y] (hf : W.functorCategory _ f) :\n    W.limitsOfShape J (limMap f) :=\n  ‚ü®_, _, _, _, limit.isLimit X, _, _, hf‚ü©\n\n"}
{"name":"CategoryTheory.MorphismProperty.isStableUnderLimitsOfShape_iff_limitsOfShape_le","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nW : CategoryTheory.MorphismProperty C\nJ : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} J\n‚ä¢ Iff (W.IsStableUnderLimitsOfShape J) (LE.le (W.limitsOfShape J) W)","decl":"lemma isStableUnderLimitsOfShape_iff_limitsOfShape_le :\n    W.IsStableUnderLimitsOfShape J ‚Üî W.limitsOfShape J ‚â§ W := by\n  constructor\n  ¬∑ rintro h _ _ _ ‚ü®_, _, _, _, h‚ÇÅ, h‚ÇÇ, f, hf‚ü©\n    exact h _ _ _ _ h‚ÇÅ h‚ÇÇ f hf\n  ¬∑ intro h _ _ _ _ h‚ÇÅ h‚ÇÇ f hf\n    exact h _ ‚ü®_, _, _, _, h‚ÇÅ, _, _, hf‚ü©\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsStableUnderLimitsOfShape.limitsOfShape_le","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nW : CategoryTheory.MorphismProperty C\nJ : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} J\nhW : W.IsStableUnderLimitsOfShape J\n‚ä¢ LE.le (W.limitsOfShape J) W","decl":"lemma IsStableUnderLimitsOfShape.limitsOfShape_le\n    (hW : W.IsStableUnderLimitsOfShape J) : W.limitsOfShape J ‚â§ W :=\n  (W.isStableUnderLimitsOfShape_iff_limitsOfShape_le J).1 hW\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsStableUnderLimitsOfShape.limMap","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nW : CategoryTheory.MorphismProperty C\nJ : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} J\nhW : W.IsStableUnderLimitsOfShape J\nX Y : CategoryTheory.Functor J C\nf : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasLimit X\ninst‚úù : CategoryTheory.Limits.HasLimit Y\nhf : W.functorCategory J f\n‚ä¢ W (CategoryTheory.Limits.limMap f)","decl":"lemma IsStableUnderLimitsOfShape.limMap\n    (hW : W.IsStableUnderLimitsOfShape J) {X Y : J ‚•§ C}\n    (f : X ‚ü∂ Y) [HasLimit X] [HasLimit Y] (hf : W.functorCategory _ f) :\n    W (limMap f) :=\n  hW.limitsOfShape_le _ (limitsOfShape_limMap _ _ hf)\n\n"}
{"name":"CategoryTheory.MorphismProperty.instRespectsIsoColimitsOfShape","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nW : CategoryTheory.MorphismProperty C\nJ : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} J\n‚ä¢ (W.colimitsOfShape J).RespectsIso","decl":"instance : (W.colimitsOfShape J).RespectsIso :=\n  RespectsIso.of_respects_arrow_iso _ (by\n    rintro ‚ü®_, _, f‚ü© ‚ü®Y‚ÇÅ, Y‚ÇÇ, g‚ü© e ‚ü®X‚ÇÅ, X‚ÇÇ, c‚ÇÅ, c‚ÇÇ, h‚ÇÅ, h‚ÇÇ, f, hf‚ü©\n    let e‚ÇÅ := Arrow.leftFunc.mapIso e\n    let e‚ÇÇ := Arrow.rightFunc.mapIso e\n    have fac : e‚ÇÅ.hom ‚â´ g = h‚ÇÅ.desc (Cocone.mk _ (f ‚â´ c‚ÇÇ.Œπ)) ‚â´ e‚ÇÇ.hom := e.hom.w\n    let c‚ÇÅ' : Cocone X‚ÇÅ := { pt := Y‚ÇÅ, Œπ := c‚ÇÅ.Œπ ‚â´ (Functor.const _).map e‚ÇÅ.hom}\n    let c‚ÇÇ' : Cocone X‚ÇÇ := { pt := Y‚ÇÇ, Œπ := c‚ÇÇ.Œπ ‚â´ (Functor.const _).map e‚ÇÇ.hom}\n    have h‚ÇÅ' : IsColimit c‚ÇÅ' := IsColimit.ofIsoColimit h‚ÇÅ (Cocones.ext e‚ÇÅ)\n    have h‚ÇÇ' : IsColimit c‚ÇÇ' := IsColimit.ofIsoColimit h‚ÇÇ (Cocones.ext e‚ÇÇ)\n    obtain hg : h‚ÇÅ'.desc (Cocone.mk _ (f ‚â´ c‚ÇÇ'.Œπ)) = g :=\n      h‚ÇÅ'.hom_ext (fun j ‚Ü¶ by\n        rw [h‚ÇÅ'.fac]\n        simp [fac, c‚ÇÅ', c‚ÇÇ'])\n    rw [‚Üê hg]\n    exact ‚ü®_, _, _, _, _, h‚ÇÇ', _, hf‚ü©)\n\n"}
{"name":"CategoryTheory.MorphismProperty.colimitsOfShape_colimMap","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nW : CategoryTheory.MorphismProperty C\nJ : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} J\nX Y : CategoryTheory.Functor J C\nf : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasColimit X\ninst‚úù : CategoryTheory.Limits.HasColimit Y\nhf : W.functorCategory J f\n‚ä¢ W.colimitsOfShape J (CategoryTheory.Limits.colimMap f)","decl":"variable {J} in\nlemma colimitsOfShape_colimMap {X Y : J ‚•§ C}\n    (f : X ‚ü∂ Y) [HasColimit X] [HasColimit Y] (hf : W.functorCategory _ f) :\n    W.colimitsOfShape J (colimMap f) :=\n  ‚ü®_, _, _, _, _, colimit.isColimit Y, _, hf‚ü©\n\n"}
{"name":"CategoryTheory.MorphismProperty.isStableUnderColimitsOfShape_iff_colimitsOfShape_le","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nW : CategoryTheory.MorphismProperty C\nJ : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} J\n‚ä¢ Iff (W.IsStableUnderColimitsOfShape J) (LE.le (W.colimitsOfShape J) W)","decl":"lemma isStableUnderColimitsOfShape_iff_colimitsOfShape_le :\n    W.IsStableUnderColimitsOfShape J ‚Üî W.colimitsOfShape J ‚â§ W := by\n  constructor\n  ¬∑ rintro h _ _ _ ‚ü®_, _, _, _, h‚ÇÅ, h‚ÇÇ, f, hf‚ü©\n    exact h _ _ _ _ h‚ÇÅ h‚ÇÇ f hf\n  ¬∑ intro h _ _ _ _ h‚ÇÅ h‚ÇÇ f hf\n    exact h _ ‚ü®_, _, _, _, _, h‚ÇÇ, _, hf‚ü©\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsStableUnderColimitsOfShape.colimitsOfShape_le","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nW : CategoryTheory.MorphismProperty C\nJ : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} J\nhW : W.IsStableUnderColimitsOfShape J\n‚ä¢ LE.le (W.colimitsOfShape J) W","decl":"lemma IsStableUnderColimitsOfShape.colimitsOfShape_le\n    (hW : W.IsStableUnderColimitsOfShape J) : W.colimitsOfShape J ‚â§ W :=\n  (W.isStableUnderColimitsOfShape_iff_colimitsOfShape_le J).1 hW\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsStableUnderColimitsOfShape.colimMap","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nW : CategoryTheory.MorphismProperty C\nJ : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} J\nhW : W.IsStableUnderColimitsOfShape J\nX Y : CategoryTheory.Functor J C\nf : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasColimit X\ninst‚úù : CategoryTheory.Limits.HasColimit Y\nhf : W.functorCategory J f\n‚ä¢ W (CategoryTheory.Limits.colimMap f)","decl":"lemma IsStableUnderColimitsOfShape.colimMap\n    (hW : W.IsStableUnderColimitsOfShape J) {X Y : J ‚•§ C}\n    (f : X ‚ü∂ Y) [HasColimit X] [HasColimit Y] (hf : W.functorCategory _ f) :\n    W (colimMap f) :=\n  hW.colimitsOfShape_le _ (colimitsOfShape_colimMap _ _ hf)\n\n"}
{"name":"CategoryTheory.MorphismProperty.colimitsOfShape_le_coproducts","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nW : CategoryTheory.MorphismProperty C\nJ : Type w\n‚ä¢ LE.le (W.colimitsOfShape (CategoryTheory.Discrete J)) W.coproducts","decl":"lemma colimitsOfShape_le_coproducts (J : Type w) :\n    W.colimitsOfShape (Discrete J) ‚â§ coproducts.{w} W :=\n  le_iSup (f := fun (J : Type w) ‚Ü¶ W.colimitsOfShape (Discrete J)) J\n\n"}
{"name":"CategoryTheory.MorphismProperty.coproducts_iff","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nW : CategoryTheory.MorphismProperty C\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ Iff (W.coproducts f) (Exists fun J => W.colimitsOfShape (CategoryTheory.Discrete J) f)","decl":"lemma coproducts_iff {X Y : C} (f : X ‚ü∂ Y) :\n    coproducts.{w} W f ‚Üî ‚àÉ (J : Type w), W.colimitsOfShape (Discrete J) f := by\n  simp only [coproducts, iSup_iff]\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsStableUnderProductsOfShape.mk","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nW : CategoryTheory.MorphismProperty C\nJ : Type u_1\ninst‚úù : W.RespectsIso\nhW : ‚àÄ (X‚ÇÅ X‚ÇÇ : J ‚Üí C) [inst : CategoryTheory.Limits.HasProduct X‚ÇÅ] [inst_1 : CategoryTheory.Limits.HasProduct X‚ÇÇ] (f : (j : J) ‚Üí Quiver.Hom (X‚ÇÅ j) (X‚ÇÇ j)), (‚àÄ (j : J), W (f j)) ‚Üí W (CategoryTheory.Limits.Pi.map f)\n‚ä¢ W.IsStableUnderProductsOfShape J","decl":"lemma IsStableUnderProductsOfShape.mk (J : Type*) [W.RespectsIso]\n    (hW : ‚àÄ (X‚ÇÅ X‚ÇÇ : J ‚Üí C) [HasProduct X‚ÇÅ] [HasProduct X‚ÇÇ]\n      (f : ‚àÄ j, X‚ÇÅ j ‚ü∂ X‚ÇÇ j) (_ : ‚àÄ (j : J), W (f j)),\n      W (Limits.Pi.map f)) : W.IsStableUnderProductsOfShape J := by\n  intro X‚ÇÅ X‚ÇÇ c‚ÇÅ c‚ÇÇ hc‚ÇÅ hc‚ÇÇ f hf\n  let œÜ := fun j => f.app (Discrete.mk j)\n  have : HasLimit X‚ÇÅ := ‚ü®c‚ÇÅ, hc‚ÇÅ‚ü©\n  have : HasLimit X‚ÇÇ := ‚ü®c‚ÇÇ, hc‚ÇÇ‚ü©\n  have : HasProduct fun j ‚Ü¶ X‚ÇÅ.obj (Discrete.mk j) :=\n    hasLimitOfIso (Discrete.natIso (fun j ‚Ü¶ Iso.refl (X‚ÇÅ.obj j)))\n  have : HasProduct fun j ‚Ü¶ X‚ÇÇ.obj (Discrete.mk j) :=\n    hasLimitOfIso (Discrete.natIso (fun j ‚Ü¶ Iso.refl (X‚ÇÇ.obj j)))\n  have hf' := hW _ _ œÜ (fun j => hf (Discrete.mk j))\n  refine (W.arrow_mk_iso_iff ?_).2 hf'\n  refine Arrow.isoMk\n    (IsLimit.conePointUniqueUpToIso hc‚ÇÅ (limit.isLimit X‚ÇÅ) ‚â™‚â´ (Pi.isoLimit X‚ÇÅ).symm)\n    (IsLimit.conePointUniqueUpToIso hc‚ÇÇ (limit.isLimit X‚ÇÇ) ‚â™‚â´ (Pi.isoLimit _).symm) ?_\n  apply limit.hom_ext\n  rintro ‚ü®j‚ü©\n  simp [œÜ]\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsStableUnderCoproductsOfShape.mk","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nW : CategoryTheory.MorphismProperty C\nJ : Type u_1\ninst‚úù : W.RespectsIso\nhW : ‚àÄ (X‚ÇÅ X‚ÇÇ : J ‚Üí C) [inst : CategoryTheory.Limits.HasCoproduct X‚ÇÅ] [inst_1 : CategoryTheory.Limits.HasCoproduct X‚ÇÇ] (f : (j : J) ‚Üí Quiver.Hom (X‚ÇÅ j) (X‚ÇÇ j)), (‚àÄ (j : J), W (f j)) ‚Üí W (CategoryTheory.Limits.Sigma.map f)\n‚ä¢ W.IsStableUnderCoproductsOfShape J","decl":"lemma IsStableUnderCoproductsOfShape.mk (J : Type*) [W.RespectsIso]\n    (hW : ‚àÄ (X‚ÇÅ X‚ÇÇ : J ‚Üí C) [HasCoproduct X‚ÇÅ] [HasCoproduct X‚ÇÇ]\n      (f : ‚àÄ j, X‚ÇÅ j ‚ü∂ X‚ÇÇ j) (_ : ‚àÄ (j : J), W (f j)),\n      W (Limits.Sigma.map f)) : W.IsStableUnderCoproductsOfShape J := by\n  intro X‚ÇÅ X‚ÇÇ c‚ÇÅ c‚ÇÇ hc‚ÇÅ hc‚ÇÇ f hf\n  let œÜ := fun j => f.app (Discrete.mk j)\n  have : HasColimit X‚ÇÅ := ‚ü®c‚ÇÅ, hc‚ÇÅ‚ü©\n  have : HasColimit X‚ÇÇ := ‚ü®c‚ÇÇ, hc‚ÇÇ‚ü©\n  have : HasCoproduct fun j ‚Ü¶ X‚ÇÅ.obj (Discrete.mk j) :=\n    hasColimitOfIso (Discrete.natIso (fun j ‚Ü¶ Iso.refl (X‚ÇÅ.obj j)))\n  have : HasCoproduct fun j ‚Ü¶ X‚ÇÇ.obj (Discrete.mk j) :=\n    hasColimitOfIso (Discrete.natIso (fun j ‚Ü¶ Iso.refl (X‚ÇÇ.obj j)))\n  have hf' := hW _ _ œÜ (fun j => hf (Discrete.mk j))\n  refine (W.arrow_mk_iso_iff ?_).1 hf'\n  refine Arrow.isoMk\n    ((Sigma.isoColimit _) ‚â™‚â´ IsColimit.coconePointUniqueUpToIso (colimit.isColimit X‚ÇÅ) hc‚ÇÅ)\n    ((Sigma.isoColimit _) ‚â™‚â´ IsColimit.coconePointUniqueUpToIso (colimit.isColimit X‚ÇÇ) hc‚ÇÇ) ?_\n  apply colimit.hom_ext\n  rintro ‚ü®j‚ü©\n  simp [œÜ]\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsStableUnderFiniteProducts.isStableUnderProductsOfShape","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nW : CategoryTheory.MorphismProperty C\nself : W.IsStableUnderFiniteProducts\nJ : Type\ninst‚úù : Finite J\n‚ä¢ W.IsStableUnderProductsOfShape J","decl":"/-- The condition that a property of morphisms is stable by finite products. -/\nclass IsStableUnderFiniteProducts : Prop where\n  isStableUnderProductsOfShape (J : Type) [Finite J] : W.IsStableUnderProductsOfShape J\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsStableUnderFiniteCoproducts.isStableUnderCoproductsOfShape","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nW : CategoryTheory.MorphismProperty C\nself : W.IsStableUnderFiniteCoproducts\nJ : Type\ninst‚úù : Finite J\n‚ä¢ W.IsStableUnderCoproductsOfShape J","decl":"/-- The condition that a property of morphisms is stable by finite coproducts. -/\nclass IsStableUnderFiniteCoproducts : Prop where\n  isStableUnderCoproductsOfShape (J : Type) [Finite J] : W.IsStableUnderCoproductsOfShape J\n\n"}
{"name":"CategoryTheory.MorphismProperty.isStableUnderProductsOfShape_of_isStableUnderFiniteProducts","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nW : CategoryTheory.MorphismProperty C\nJ : Type\ninst‚úù¬π : Finite J\ninst‚úù : W.IsStableUnderFiniteProducts\n‚ä¢ W.IsStableUnderProductsOfShape J","decl":"lemma isStableUnderProductsOfShape_of_isStableUnderFiniteProducts\n    (J : Type) [Finite J] [W.IsStableUnderFiniteProducts] :\n    W.IsStableUnderProductsOfShape J :=\n  IsStableUnderFiniteProducts.isStableUnderProductsOfShape J\n\n"}
{"name":"CategoryTheory.MorphismProperty.isStableUnderCoproductsOfShape_of_isStableUnderFiniteCoproducts","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nW : CategoryTheory.MorphismProperty C\nJ : Type\ninst‚úù¬π : Finite J\ninst‚úù : W.IsStableUnderFiniteCoproducts\n‚ä¢ W.IsStableUnderCoproductsOfShape J","decl":"lemma isStableUnderCoproductsOfShape_of_isStableUnderFiniteCoproducts\n    (J : Type) [Finite J] [W.IsStableUnderFiniteCoproducts] :\n    W.IsStableUnderCoproductsOfShape J :=\n  IsStableUnderFiniteCoproducts.isStableUnderCoproductsOfShape J\n\n"}
{"name":"CategoryTheory.MorphismProperty.diagonal_iff","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nP : CategoryTheory.MorphismProperty C\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ Iff (P.diagonal f) (P (CategoryTheory.Limits.pullback.diagonal f))","decl":"theorem diagonal_iff {X Y : C} {f : X ‚ü∂ Y} : P.diagonal f ‚Üî P (pullback.diagonal f) :=\n  Iff.rfl\n\n"}
{"name":"CategoryTheory.MorphismProperty.RespectsIso.diagonal","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasPullbacks C\nP : CategoryTheory.MorphismProperty C\ninst‚úù : P.RespectsIso\n‚ä¢ P.diagonal.RespectsIso","decl":"instance RespectsIso.diagonal [P.RespectsIso] : P.diagonal.RespectsIso := by\n  apply RespectsIso.mk\n  ¬∑ introv H\n    rwa [diagonal_iff, pullback.diagonal_comp, P.cancel_left_of_respectsIso,\n      P.cancel_left_of_respectsIso, ‚Üê P.cancel_right_of_respectsIso _\n        (pullback.map (e.hom ‚â´ f) (e.hom ‚â´ f) f f e.hom e.hom (ùüô Z) (by simp) (by simp)),\n      ‚Üê pullback.condition, P.cancel_left_of_respectsIso]\n  ¬∑ introv H\n    delta diagonal\n    rwa [pullback.diagonal_comp, P.cancel_right_of_respectsIso]\n\n"}
{"name":"CategoryTheory.MorphismProperty.diagonal_isStableUnderComposition","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≥ : CategoryTheory.Limits.HasPullbacks C\nP : CategoryTheory.MorphismProperty C\ninst‚úù¬≤ : P.IsStableUnderComposition\ninst‚úù¬π : P.RespectsIso\ninst‚úù : P.IsStableUnderBaseChange\n‚ä¢ P.diagonal.IsStableUnderComposition","decl":"instance diagonal_isStableUnderComposition [P.IsStableUnderComposition] [RespectsIso P]\n    [IsStableUnderBaseChange P] : P.diagonal.IsStableUnderComposition where\n  comp_mem _ _ h‚ÇÅ h‚ÇÇ := by\n    rw [diagonal_iff, pullback.diagonal_comp]\n    exact P.comp_mem _ _ h‚ÇÅ\n      (by simpa only [cancel_left_of_respectsIso] using P.pullback_snd _ _ h‚ÇÇ)\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsStableUnderBaseChange.diagonal","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasPullbacks C\nP : CategoryTheory.MorphismProperty C\ninst‚úù¬π : P.IsStableUnderBaseChange\ninst‚úù : P.RespectsIso\n‚ä¢ P.diagonal.IsStableUnderBaseChange","decl":"instance IsStableUnderBaseChange.diagonal [IsStableUnderBaseChange P] [P.RespectsIso] :\n    P.diagonal.IsStableUnderBaseChange :=\n  IsStableUnderBaseChange.mk'\n    (by\n      introv h\n      rw [diagonal_iff, diagonal_pullback_fst, P.cancel_left_of_respectsIso,\n        P.cancel_right_of_respectsIso]\n      exact P.baseChange_map f _ (by simpa))\n\n"}
{"name":"CategoryTheory.MorphismProperty.diagonal_isomorphisms","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\n‚ä¢ Eq (CategoryTheory.MorphismProperty.isomorphisms C).diagonal (CategoryTheory.MorphismProperty.monomorphisms C)","decl":"lemma diagonal_isomorphisms : (isomorphisms C).diagonal = monomorphisms C :=\n  ext _ _ fun _ _ _ ‚Ü¶ pullback.isIso_diagonal_iff _\n\n"}
{"name":"CategoryTheory.MorphismProperty.hasOfPostcompProperty_iff_le_diagonal","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≥ : CategoryTheory.Limits.HasPullbacks C\nP : CategoryTheory.MorphismProperty C\ninst‚úù¬≤ : P.IsStableUnderBaseChange\ninst‚úù¬π : P.IsMultiplicative\nQ : CategoryTheory.MorphismProperty C\ninst‚úù : Q.IsStableUnderBaseChange\n‚ä¢ Iff (P.HasOfPostcompProperty Q) (LE.le Q P.diagonal)","decl":"/-- If `P` is multiplicative and stable under base change, having the of-postcomp property\nwrt. `Q` is equivalent to `Q` implying `P` on the diagonal. -/\nlemma hasOfPostcompProperty_iff_le_diagonal [P.IsStableUnderBaseChange]\n    [P.IsMultiplicative] {Q : MorphismProperty C} [Q.IsStableUnderBaseChange] :\n    P.HasOfPostcompProperty Q ‚Üî Q ‚â§ P.diagonal := by\n  refine ‚ü®fun hP X Y f hf ‚Ü¶ ?_, fun hP ‚Ü¶ ‚ü®fun {Y X S} g f hf hcomp ‚Ü¶ ?_‚ü©‚ü©\n  ¬∑ exact hP.of_postcomp _ _ (Q.pullback_fst _ _ hf) (by simpa using P.id_mem X)\n  ¬∑ set gr : Y ‚ü∂ pullback (g ‚â´ f) f := pullback.lift (ùüô Y) g (by simp)\n    have : g = gr ‚â´ pullback.snd _ _ := by simp [gr]\n    rw [this]\n    apply P.comp_mem\n    ¬∑ exact P.of_isPullback (pullback_lift_diagonal_isPullback g f) (hP _ hf)\n    ¬∑ exact P.pullback_snd _ _ hcomp\n\n"}
{"name":"CategoryTheory.MorphismProperty.universally_respectsIso","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\n‚ä¢ P.universally.RespectsIso","decl":"instance universally_respectsIso (P : MorphismProperty C) : P.universally.RespectsIso := by\n  apply RespectsIso.mk\n  ¬∑ intro X Y Z e f hf X' Z' i‚ÇÅ i‚ÇÇ f' H\n    have : IsPullback (ùüô _) (i‚ÇÅ ‚â´ e.hom) i‚ÇÅ e.inv :=\n      IsPullback.of_horiz_isIso\n        ‚ü®by rw [Category.id_comp, Category.assoc, e.hom_inv_id, Category.comp_id]‚ü©\n    exact hf _ _ _\n      (by simpa only [Iso.inv_hom_id_assoc, Category.id_comp] using this.paste_horiz H)\n  ¬∑ intro X Y Z e f hf X' Z' i‚ÇÅ i‚ÇÇ f' H\n    have : IsPullback (ùüô _) i‚ÇÇ (i‚ÇÇ ‚â´ e.inv) e.inv :=\n      IsPullback.of_horiz_isIso ‚ü®Category.id_comp _‚ü©\n    exact hf _ _ _ (by simpa only [Category.assoc, Iso.hom_inv_id,\n      Category.comp_id, Category.comp_id] using H.paste_horiz this)\n\n"}
{"name":"CategoryTheory.MorphismProperty.universally_isStableUnderBaseChange","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\n‚ä¢ P.universally.IsStableUnderBaseChange","decl":"instance universally_isStableUnderBaseChange (P : MorphismProperty C) :\n    P.universally.IsStableUnderBaseChange where\n  of_isPullback H h‚ÇÅ _ _ _ _ _ H' := h‚ÇÅ _ _ _ (H'.paste_vert H.flip)\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsStableUnderComposition.universally","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nP : CategoryTheory.MorphismProperty C\nhP : P.IsStableUnderComposition\n‚ä¢ P.universally.IsStableUnderComposition","decl":"instance IsStableUnderComposition.universally [HasPullbacks C] (P : MorphismProperty C)\n    [hP : P.IsStableUnderComposition] : P.universally.IsStableUnderComposition where\n  comp_mem {X Y Z} f g hf hg X' Z' i‚ÇÅ i‚ÇÇ f' H := by\n    have := pullback.lift_fst _ _ (H.w.trans (Category.assoc _ _ _).symm)\n    rw [‚Üê this] at H ‚ä¢\n    apply P.comp_mem _ _ _ (hg _ _ _ <| IsPullback.of_hasPullback _ _)\n    exact hf _ _ _ (H.of_right (pullback.lift_snd _ _ _) (IsPullback.of_hasPullback i‚ÇÇ g))\n\n"}
{"name":"CategoryTheory.MorphismProperty.universally_le","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\n‚ä¢ LE.le P.universally P","decl":"theorem universally_le (P : MorphismProperty C) : P.universally ‚â§ P := by\n  intro X Y f hf\n  exact hf (ùüô _) (ùüô _) _ (IsPullback.of_vert_isIso ‚ü®by rw [Category.comp_id, Category.id_comp]‚ü©)\n\n"}
{"name":"CategoryTheory.MorphismProperty.universally_inf","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nP Q : CategoryTheory.MorphismProperty C\n‚ä¢ Eq (Min.min P Q).universally (Min.min P.universally Q.universally)","decl":"theorem universally_inf (P Q : MorphismProperty C) :\n    (P ‚äì Q).universally = P.universally ‚äì Q.universally := by\n  ext X Y f\n  show _ ‚Üî _ ‚àß _\n  simp_rw [universally, ‚Üê forall_and]\n  rfl\n\n"}
{"name":"CategoryTheory.MorphismProperty.universally_eq_iff","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\n‚ä¢ Iff (Eq P.universally P) P.IsStableUnderBaseChange","decl":"theorem universally_eq_iff {P : MorphismProperty C} :\n    P.universally = P ‚Üî P.IsStableUnderBaseChange :=\n  ‚ü®(¬∑ ‚ñ∏ P.universally_isStableUnderBaseChange),\n    fun hP ‚Ü¶ P.universally_le.antisymm fun _ _ _ hf _ _ _ _ _ H => hP.of_isPullback H.flip hf‚ü©\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsStableUnderBaseChange.universally_eq","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\nhP : P.IsStableUnderBaseChange\n‚ä¢ Eq P.universally P","decl":"theorem IsStableUnderBaseChange.universally_eq {P : MorphismProperty C}\n    [hP : P.IsStableUnderBaseChange] : P.universally = P := universally_eq_iff.mpr hP\n\n"}
{"name":"CategoryTheory.MorphismProperty.universally_mono","module":"Mathlib.CategoryTheory.MorphismProperty.Limits","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\n‚ä¢ Monotone CategoryTheory.MorphismProperty.universally","decl":"theorem universally_mono : Monotone (universally : MorphismProperty C ‚Üí MorphismProperty C) :=\n  fun _ _ h _ _ _ h‚ÇÅ _ _ _ _ _ H => h _ (h‚ÇÅ _ _ _ H)\n\n"}
