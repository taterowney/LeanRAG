{"name":"Real.deriv_Gamma_nat","module":"Mathlib.NumberTheory.Harmonic.GammaDeriv","initialProofState":"n : Nat\n⊢ Eq (deriv Real.Gamma (HAdd.hAdd (↑n) 1)) (HMul.hMul (↑n.factorial) (HAdd.hAdd (Neg.neg Real.eulerMascheroniConstant) ↑(harmonic n)))","decl":"/-- Explicit formula for the derivative of the Gamma function at positive integers, in terms of\nharmonic numbers and the Euler-Mascheroni constant `γ`. -/\nlemma deriv_Gamma_nat (n : ℕ) :\n    deriv Gamma (n + 1) = n ! * (-γ + harmonic n) := by\n  /- This follows from two properties of the function `f n = log (Gamma n)`:\n  firstly, the elementary computation that `deriv f (n + 1) = deriv f n + 1 / n`, so that\n  `deriv f n = deriv f 1 + harmonic n`; secondly, the convexity of `f` (the Bohr-Mollerup theorem),\n  which shows that `deriv f n` is `log n + o(1)` as `n → ∞`.\n  `-/\n  let f := log ∘ Gamma\n  -- First reduce to computing derivative of `log ∘ Gamma`.\n  suffices deriv (log ∘ Gamma) (n + 1) = -γ + harmonic n by\n    rwa [Function.comp_def, deriv.log (differentiableAt_Gamma (fun m ↦ by linarith))\n      (by positivity), Gamma_nat_eq_factorial, div_eq_iff_mul_eq (by positivity),\n      mul_comm, Eq.comm] at this\n  have hc : ConvexOn ℝ (Ioi 0) f := convexOn_log_Gamma\n  have h_rec (x : ℝ) (hx : 0 < x) : f (x + 1) = f x + log x := by simp only [f, Function.comp_apply,\n      Gamma_add_one hx.ne', log_mul hx.ne' (Gamma_pos_of_pos hx).ne', add_comm]\n  have hder {x : ℝ} (hx : 0 < x) : DifferentiableAt ℝ f x := by\n    refine ((differentiableAt_Gamma ?_).log (Gamma_ne_zero ?_)) <;>\n    exact fun m ↦ ne_of_gt (by linarith)\n  -- Express derivative at general `n` in terms of value at `1` using recurrence relation\n  have hder_rec (x : ℝ) (hx : 0 < x) : deriv f (x + 1) = deriv f x + 1 / x := by\n    rw [← deriv_comp_add_const, one_div, ← deriv_log,\n      ← deriv_add (hder <| by positivity) (differentiableAt_log hx.ne')]\n    apply EventuallyEq.deriv_eq\n    filter_upwards [eventually_gt_nhds hx] using h_rec\n  have hder_nat (n : ℕ) : deriv f (n + 1) = deriv f 1 + harmonic n := by\n    induction' n with n hn\n    · simp\n    · rw [cast_succ, hder_rec (n + 1) (by positivity), hn, harmonic_succ]\n      push_cast\n      ring\n  suffices -deriv f 1 = γ by rw [hder_nat n, ← this, neg_neg]\n  -- Use convexity to show derivative of `f` at `n + 1` is between `log n` and `log (n + 1)`\n  have derivLB (n : ℕ) (hn : 0 < n) : log n ≤ deriv f (n + 1) := by\n    refine (le_of_eq ?_).trans <| hc.slope_le_deriv (mem_Ioi.mpr <| Nat.cast_pos.mpr hn)\n      (by positivity : _ < (_ : ℝ)) (by linarith) (hder <| by positivity)\n    rw [slope_def_field, show n + 1 - n = (1 : ℝ) by ring, div_one, h_rec n (by positivity),\n      add_sub_cancel_left]\n  have derivUB (n : ℕ) : deriv f (n + 1) ≤ log (n + 1) := by\n    refine (hc.deriv_le_slope (by positivity : (0 : ℝ) < n + 1) (by positivity : (0 : ℝ) < n + 2)\n        (by linarith) (hder <| by positivity)).trans (le_of_eq ?_)\n    rw [slope_def_field, show n + 2 - (n + 1) = (1 : ℝ) by ring, div_one,\n      show n + 2 = (n + 1) + (1 : ℝ) by ring, h_rec (n + 1) (by positivity), add_sub_cancel_left]\n  -- deduce `-deriv f 1` is bounded above + below by sequences which both tend to `γ`\n  apply le_antisymm\n  · apply ge_of_tendsto tendsto_harmonic_sub_log\n    filter_upwards [eventually_gt_atTop 0] with n hn\n    rw [le_sub_iff_add_le', ← sub_eq_add_neg, sub_le_iff_le_add', ← hder_nat]\n    exact derivLB n hn\n  · apply le_of_tendsto tendsto_harmonic_sub_log_add_one\n    filter_upwards with n\n    rw [sub_le_iff_le_add', ← sub_eq_add_neg, le_sub_iff_add_le', ← hder_nat]\n    exact derivUB n\n\n\n"}
{"name":"Real.hasDerivAt_Gamma_nat","module":"Mathlib.NumberTheory.Harmonic.GammaDeriv","initialProofState":"n : Nat\n⊢ HasDerivAt Real.Gamma (HMul.hMul (↑n.factorial) (HAdd.hAdd (Neg.neg Real.eulerMascheroniConstant) ↑(harmonic n))) (HAdd.hAdd (↑n) 1)","decl":"lemma hasDerivAt_Gamma_nat (n : ℕ) :\n    HasDerivAt Gamma (n ! * (-γ + harmonic n)) (n + 1) :=\n  (deriv_Gamma_nat n).symm ▸\n    (differentiableAt_Gamma fun m ↦ (by linarith : (n : ℝ) + 1 ≠ -m)).hasDerivAt\n\n"}
{"name":"Real.eulerMascheroniConstant_eq_neg_deriv","module":"Mathlib.NumberTheory.Harmonic.GammaDeriv","initialProofState":"⊢ Eq Real.eulerMascheroniConstant (Neg.neg (deriv Real.Gamma 1))","decl":"lemma eulerMascheroniConstant_eq_neg_deriv : γ = -deriv Gamma 1 := by\n  rw [show (1 : ℝ) = ↑(0 : ℕ) + 1 by simp, deriv_Gamma_nat 0]\n  simp\n\n"}
{"name":"Real.hasDerivAt_Gamma_one","module":"Mathlib.NumberTheory.Harmonic.GammaDeriv","initialProofState":"⊢ HasDerivAt Real.Gamma (Neg.neg Real.eulerMascheroniConstant) 1","decl":"lemma hasDerivAt_Gamma_one : HasDerivAt Gamma (-γ) 1 := by\n  simpa only [factorial_zero, cast_one, harmonic_zero, Rat.cast_zero, add_zero, mul_neg, one_mul,\n    cast_zero, zero_add] using hasDerivAt_Gamma_nat 0\n\n"}
{"name":"Real.hasDerivAt_Gamma_one_half","module":"Mathlib.NumberTheory.Harmonic.GammaDeriv","initialProofState":"⊢ HasDerivAt Real.Gamma (HMul.hMul (Neg.neg Real.pi.sqrt) (HAdd.hAdd Real.eulerMascheroniConstant (HMul.hMul 2 (Real.log 2)))) (1 / 2)","decl":"lemma hasDerivAt_Gamma_one_half : HasDerivAt Gamma (-√π * (γ + 2 * log 2)) (1 / 2) := by\n  have h_diff {s : ℝ} (hs : 0 < s) : DifferentiableAt ℝ Gamma s :=\n    differentiableAt_Gamma fun m ↦ ((neg_nonpos.mpr m.cast_nonneg).trans_lt hs).ne'\n  have h_diff' {s : ℝ} (hs : 0 < s) : DifferentiableAt ℝ (fun s ↦ Gamma (2 * s)) s :=\n    .comp (g := Gamma) _ (h_diff <| mul_pos two_pos hs) (differentiableAt_id.const_mul _)\n  refine (h_diff one_half_pos).hasDerivAt.congr_deriv ?_\n  -- We calculate the deriv of Gamma at 1/2 using the doubling formula, since we already know\n  -- the derivative of Gamma at 1.\n  calc deriv Gamma (1 / 2)\n  _ = (deriv (fun s ↦ Gamma s * Gamma (s + 1 / 2)) (1 / 2)) + √π * γ := by\n    rw [deriv_mul, Gamma_one_half_eq,\n      add_assoc, ← mul_add, deriv_comp_add_const,\n      (by norm_num : 1/2 + 1/2 = (1 : ℝ)), Gamma_one, mul_one,\n      eulerMascheroniConstant_eq_neg_deriv, add_neg_cancel, mul_zero, add_zero]\n    · apply h_diff; norm_num -- s = 1\n    · exact ((h_diff (by norm_num)).hasDerivAt.comp_add_const).differentiableAt -- s = 1\n  _ = (deriv (fun s ↦ Gamma (2 * s) * 2 ^ (1 - 2 * s) * √π) (1 / 2)) + √π * γ := by\n    rw [funext Gamma_mul_Gamma_add_half]\n  _ = √π * (deriv (fun s ↦ Gamma (2 * s) * 2 ^ (1 - 2 * s)) (1 / 2) + γ) := by\n    rw [mul_comm √π, mul_comm √π, deriv_mul_const, add_mul]\n    apply DifferentiableAt.mul\n    · exact .comp (g := Gamma) _ (by apply h_diff; norm_num) -- s = 1\n        (differentiableAt_id.const_mul _)\n    · exact (differentiableAt_const _).rpow (by fun_prop) two_ne_zero\n  _ = √π * (deriv (fun s ↦ Gamma (2 * s)) (1 / 2) +\n              deriv (fun s : ℝ ↦ 2 ^ (1 - 2 * s)) (1 / 2) + γ) := by\n    congr 2\n    rw [deriv_mul]\n    · congr 1 <;> norm_num\n    · exact h_diff' one_half_pos\n    · exact DifferentiableAt.rpow (by fun_prop) (by fun_prop) two_ne_zero\n  _ = √π * (-2 * γ + deriv (fun s : ℝ ↦ 2 ^ (1 - 2 * s)) (1 / 2) + γ) := by\n    congr 3\n    change deriv (Gamma ∘ fun s ↦ 2 * s) _ = _\n    rw [deriv_comp, deriv_const_mul, mul_one_div, div_self two_ne_zero, deriv_id''] <;>\n    dsimp only\n    · rw [mul_one, mul_comm, hasDerivAt_Gamma_one.deriv, mul_neg, neg_mul]\n    · fun_prop\n    · apply h_diff; norm_num -- s = 1\n    · fun_prop\n  _ = √π * (-2 * γ + -(2 * log 2) + γ) := by\n    congr 3\n    apply HasDerivAt.deriv\n    have := HasDerivAt.rpow (hasDerivAt_const (1 / 2 : ℝ) (2 : ℝ))\n      (?_ : HasDerivAt (fun s : ℝ ↦ 1 - 2 * s) (-2) (1 / 2)) two_pos\n    · norm_num at this; exact this\n    simp_rw [mul_comm (2 : ℝ) _]\n    apply HasDerivAt.const_sub\n    exact hasDerivAt_mul_const (2 : ℝ)\n  _ = -√π * (γ + 2 * log 2) := by ring\n\n"}
{"name":"Complex.differentiable_at_Gamma_nat_add_one","module":"Mathlib.NumberTheory.Harmonic.GammaDeriv","initialProofState":"n : Nat\n⊢ DifferentiableAt Complex Complex.Gamma (HAdd.hAdd (↑n) 1)","decl":"lemma differentiable_at_Gamma_nat_add_one (n : ℕ) :\n    DifferentiableAt ℂ Gamma (n + 1) := by\n  refine differentiableAt_Gamma _ (fun m ↦ ?_)\n  simp only [Ne, ← ofReal_natCast, ← ofReal_one, ← ofReal_add, ← ofReal_neg, ofReal_inj,\n    eq_neg_iff_add_eq_zero]\n  positivity\n\n"}
{"name":"Complex.hasDerivAt_Gamma_nat","module":"Mathlib.NumberTheory.Harmonic.GammaDeriv","initialProofState":"n : Nat\n⊢ HasDerivAt Complex.Gamma (HMul.hMul (↑n.factorial) (HAdd.hAdd (Neg.neg ↑Real.eulerMascheroniConstant) ↑(harmonic n))) (HAdd.hAdd (↑n) 1)","decl":"lemma hasDerivAt_Gamma_nat (n : ℕ) :\n    HasDerivAt Gamma (n ! * (-γ + harmonic n)) (n + 1) := by\n  exact_mod_cast HasDerivAt.complex_of_real\n    (by exact_mod_cast differentiable_at_Gamma_nat_add_one n)\n    (Real.hasDerivAt_Gamma_nat n) Gamma_ofReal\n\n"}
{"name":"Complex.deriv_Gamma_nat","module":"Mathlib.NumberTheory.Harmonic.GammaDeriv","initialProofState":"n : Nat\n⊢ Eq (deriv Complex.Gamma (HAdd.hAdd (↑n) 1)) (HMul.hMul (↑n.factorial) (HAdd.hAdd (Neg.neg ↑Real.eulerMascheroniConstant) ↑(harmonic n)))","decl":"/-- Explicit formula for the derivative of the complex Gamma function at positive integers, in\nterms of harmonic numbers and the Euler-Mascheroni constant `γ`. -/\nlemma deriv_Gamma_nat (n : ℕ) :\n    deriv Gamma (n + 1) = n ! * (-γ + harmonic n) :=\n  (hasDerivAt_Gamma_nat n).deriv\n\n"}
{"name":"Complex.hasDerivAt_Gamma_one","module":"Mathlib.NumberTheory.Harmonic.GammaDeriv","initialProofState":"⊢ HasDerivAt Complex.Gamma (Neg.neg ↑Real.eulerMascheroniConstant) 1","decl":"lemma hasDerivAt_Gamma_one : HasDerivAt Gamma (-γ) 1 := by\n  simpa only [factorial_zero, cast_one, harmonic_zero, Rat.cast_zero, add_zero, mul_neg, one_mul,\n    cast_zero, zero_add] using hasDerivAt_Gamma_nat 0\n\n"}
{"name":"Complex.hasDerivAt_Gamma_one_half","module":"Mathlib.NumberTheory.Harmonic.GammaDeriv","initialProofState":"⊢ HasDerivAt Complex.Gamma (HMul.hMul (Neg.neg ↑Real.pi.sqrt) (HAdd.hAdd (↑Real.eulerMascheroniConstant) (HMul.hMul 2 (Complex.log 2)))) (1 / 2)","decl":"lemma hasDerivAt_Gamma_one_half : HasDerivAt Gamma (-√π * (γ + 2 * log 2)) (1 / 2) := by\n  have := HasDerivAt.complex_of_real\n    (differentiableAt_Gamma _ ?_) Real.hasDerivAt_Gamma_one_half Gamma_ofReal\n  · simpa only [neg_mul, one_div, ofReal_neg, ofReal_mul, ofReal_add, ofReal_ofNat, ofNat_log,\n      ofReal_inv] using this\n  · intro m\n    rw [← ofReal_natCast, ← ofReal_neg, ne_eq, ofReal_inj]\n    exact ((neg_nonpos.mpr m.cast_nonneg).trans_lt one_half_pos).ne'\n\n"}
{"name":"Complex.hasDerivAt_Gammaℂ_one","module":"Mathlib.NumberTheory.Harmonic.GammaDeriv","initialProofState":"⊢ HasDerivAt Complex.Gammaℂ (HDiv.hDiv (Neg.neg (HAdd.hAdd (↑Real.eulerMascheroniConstant) (Complex.log (HMul.hMul 2 ↑Real.pi)))) ↑Real.pi) 1","decl":"lemma hasDerivAt_Gammaℂ_one : HasDerivAt Gammaℂ (-(γ + log (2 * π)) / π) 1 := by\n  let f (s : ℂ) : ℂ := 2 * (2 * π) ^ (-s)\n  have : HasDerivAt (fun s : ℂ ↦ 2 * (2 * π : ℂ) ^ (-s)) (-log (2 * π) / π) 1 := by\n    have := (hasDerivAt_neg' (1 : ℂ)).const_cpow (c := 2 * π)\n      (Or.inl (by exact_mod_cast Real.two_pi_pos.ne'))\n    refine (this.const_mul 2).congr_deriv ?_\n    rw [mul_neg_one, mul_neg, cpow_neg_one, ← div_eq_inv_mul, ← mul_div_assoc,\n      mul_div_mul_left _ _ two_ne_zero, neg_div]\n  have := this.mul hasDerivAt_Gamma_one\n  simp only [f] at this\n  rwa [Gamma_one, mul_one, cpow_neg_one, ← div_eq_mul_inv, ← div_div, div_self two_ne_zero,\n    mul_comm (1 / _), mul_one_div, ← _root_.add_div, ← neg_add, add_comm] at this\n\n"}
{"name":"Complex.hasDerivAt_Gammaℝ_one","module":"Mathlib.NumberTheory.Harmonic.GammaDeriv","initialProofState":"⊢ HasDerivAt Complex.Gammaℝ (HDiv.hDiv (Neg.neg (HAdd.hAdd (↑Real.eulerMascheroniConstant) (Complex.log (HMul.hMul 4 ↑Real.pi)))) 2) 1","decl":"lemma hasDerivAt_Gammaℝ_one : HasDerivAt Gammaℝ (-(γ + log (4 * π)) / 2) 1 := by\n  let f (s : ℂ) : ℂ := π ^ (-s / 2)\n  let g (s : ℂ) : ℂ := Gamma (s / 2)\n  have aux : (π : ℂ) ^ (1 / 2 : ℂ) = ↑√π := by\n    rw [Real.sqrt_eq_rpow, ofReal_cpow Real.pi_pos.le, ofReal_div, ofReal_one, ofReal_ofNat]\n  have aux2 : (√π : ℂ) ≠ 0 := by rw [ofReal_ne_zero]; positivity\n  have hf : HasDerivAt f (-log π / 2 / √π) 1 := by\n    have := ((hasDerivAt_neg (1 : ℂ)).div_const 2).const_cpow (c := π) (Or.inr (by norm_num))\n    refine this.congr_deriv ?_\n    rw [mul_assoc, ← mul_div_assoc, mul_neg_one, neg_div, cpow_neg, ← div_eq_inv_mul, aux]\n  have hg : HasDerivAt g (-√π * (γ + 2 * log 2) / 2) 1 := by\n    have := hasDerivAt_Gamma_one_half.comp 1 (?_ : HasDerivAt (fun s : ℂ ↦ s / 2) (1 / 2) 1)\n    · rwa [mul_one_div] at this\n    · exact (hasDerivAt_id _).div_const _\n  refine HasDerivAt.congr_deriv (hf.mul hg) ?_\n  simp only [f]\n  rw [Gamma_one_half_eq, aux, div_mul_cancel₀ _ aux2, neg_div _ (1 : ℂ), cpow_neg, aux,\n    mul_div_assoc, ← mul_assoc, mul_neg, inv_mul_cancel₀ aux2, neg_one_mul, ← neg_div,\n    ← _root_.add_div, ← neg_add, add_comm, add_assoc, ← ofReal_log Real.pi_pos.le, ← ofReal_ofNat,\n    ← ofReal_log zero_le_two,\n    ← ofReal_mul, ← Nat.cast_ofNat (R := ℝ), ← Real.log_pow, ← ofReal_add,\n    ← Real.log_mul (by positivity) (by positivity),\n    Nat.cast_ofNat, ofReal_ofNat, ofReal_log (by positivity)]\n  norm_num\n\n"}
