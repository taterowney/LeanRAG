{"name":"Algebra.FormallyUnramified.iff_exists_tensorProduct","module":"Mathlib.RingTheory.Unramified.Finite","initialProofState":"R : Type u_2\nS : Type u_3\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\ninst✝ : Algebra.EssFiniteType R S\n⊢ Iff (Algebra.FormallyUnramified R S) (Exists fun t => And (∀ (s : S), Eq (HMul.hMul (HSub.hSub (TensorProduct.tmul R 1 s) (TensorProduct.tmul R s 1)) t) 0) (Eq ((Algebra.TensorProduct.lmul' R) t) 1))","decl":"/--\nProposition I.2.3 + I.2.6 of [iversen]\nA finite-type `R`-algebra `S` is (formally) unramified iff there exists a `t : S ⊗[R] S` satisfying\n1. `t` annihilates every `1 ⊗ s - s ⊗ 1`.\n2. the image of `t` is `1` under the map `S ⊗[R] S → S`.\n-/\ntheorem iff_exists_tensorProduct [EssFiniteType R S] :\n    FormallyUnramified R S ↔ ∃ t : S ⊗[R] S,\n      (∀ s, ((1 : S) ⊗ₜ[R] s - s ⊗ₜ[R] (1 : S)) * t = 0) ∧ TensorProduct.lmul' R t = 1 := by\n  rw [formallyUnramified_iff, KaehlerDifferential,\n    Ideal.cotangent_subsingleton_iff, Ideal.isIdempotentElem_iff_of_fg _\n      (KaehlerDifferential.ideal_fg R S)]\n  have : ∀ t : S ⊗[R] S, TensorProduct.lmul' R t = 1 ↔ 1 - t ∈ KaehlerDifferential.ideal R S := by\n    intro t\n    simp only [KaehlerDifferential.ideal, RingHom.mem_ker, map_sub, map_one,\n      sub_eq_zero, @eq_comm S 1]\n  simp_rw [this, ← KaehlerDifferential.span_range_eq_ideal]\n  constructor\n  · rintro ⟨e, he₁, he₂ : _ = Ideal.span _⟩\n    refine ⟨1 - e, ?_, ?_⟩\n    · intro s\n      obtain ⟨x, hx⟩ : e ∣ 1 ⊗ₜ[R] s - s ⊗ₜ[R] 1 := by\n        rw [← Ideal.mem_span_singleton, ← he₂]\n        exact Ideal.subset_span ⟨s, rfl⟩\n      rw [hx, mul_comm, ← mul_assoc, sub_mul, one_mul, he₁.eq, sub_self, zero_mul]\n    · rw [sub_sub_cancel, he₂, Ideal.mem_span_singleton]\n  · rintro ⟨t, ht₁, ht₂⟩\n    use 1 - t\n    rw [← sub_sub_self 1 t] at ht₁; generalize 1 - t = e at *\n    constructor\n    · suffices e ∈ (Submodule.span (S ⊗[R] S) {1 - e}).annihilator by\n        simpa [IsIdempotentElem, mul_sub, sub_eq_zero, eq_comm, -Ideal.submodule_span_eq,\n          Submodule.mem_annihilator_span_singleton] using this\n      exact (show Ideal.span _ ≤ _ by simpa only [Ideal.span_le, Set.range_subset_iff,\n        Submodule.mem_annihilator_span_singleton, SetLike.mem_coe]) ht₂\n    · apply le_antisymm <;> simp only [Ideal.submodule_span_eq, Ideal.mem_span_singleton, ht₂,\n        Ideal.span_le, Set.singleton_subset_iff, SetLike.mem_coe, Set.range_subset_iff]\n      intro s\n      use 1 ⊗ₜ[R] s - s ⊗ₜ[R] 1\n      linear_combination ht₁ s\n\n"}
{"name":"Algebra.FormallyUnramified.finite_of_free_aux","module":"Mathlib.RingTheory.Unramified.Finite","initialProofState":"R : Type u_3\nS : Type u_4\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\nI : Type u_2\ninst✝ : DecidableEq I\nb : Basis I R S\nf : Finsupp I S\nx : S\na : I → Finsupp I R\nha : Eq a fun i => b.repr (HMul.hMul (b i) x)\n⊢ Eq (HMul.hMul (TensorProduct.tmul R 1 x) (f.sum fun i y => TensorProduct.tmul R y (b i))) ((f.support.biUnion fun i => (a i).support).sum fun k => (b.repr (f.sum fun i y => HSMul.hSMul ((a i) k) y)).sum fun j c => HSMul.hSMul c (TensorProduct.tmul R (b j) (b k)))","decl":"lemma finite_of_free_aux (I) [DecidableEq I] (b : Basis I R S)\n    (f : I →₀ S) (x : S) (a : I → I →₀ R) (ha : a = fun i ↦ b.repr (b i * x)) :\n    (1 ⊗ₜ[R] x * Finsupp.sum f fun i y ↦ y ⊗ₜ[R] b i) =\n      Finset.sum (f.support.biUnion fun i ↦ (a i).support) fun k ↦\n    Finsupp.sum (b.repr (f.sum fun i y ↦ a i k • y)) fun j c ↦ c • b j ⊗ₜ[R] b k := by\n  rw [Finsupp.sum, Finset.mul_sum]\n  subst ha\n  let a i := b.repr (b i * x)\n  conv_lhs =>\n    simp only [TensorProduct.tmul_mul_tmul, one_mul, mul_comm x (b _),\n      ← show ∀ i, Finsupp.linearCombination _ b (a i) = b i * x from\n          fun _ ↦ b.linearCombination_repr _]\n  conv_lhs => simp only [Finsupp.linearCombination, Finsupp.coe_lsum,\n    LinearMap.coe_smulRight, LinearMap.id_coe, id_eq, Finsupp.sum, TensorProduct.tmul_sum,\n    ← TensorProduct.smul_tmul]\n  have h₁ : ∀ k,\n    (Finsupp.sum (Finsupp.sum f fun i y ↦ a i k • b.repr y) fun j z ↦ z • b j ⊗ₜ[R] b k) =\n      (f.sum fun i y ↦ (b.repr y).sum fun j z ↦ a i k • z • b j ⊗ₜ[R] b k) := by\n    intro i\n    rw [Finsupp.sum_sum_index]\n    congr\n    ext j s\n    rw [Finsupp.sum_smul_index]\n    simp only [mul_smul, Finsupp.sum, ← Finset.smul_sum]\n    · intro; simp only [zero_smul]\n    · intro; simp only [zero_smul]\n    · intros; simp only [add_smul]\n  have h₂ : ∀ (x : S), ((b.repr x).support.sum fun a ↦ b.repr x a • b a) = x := by\n    simpa only [Finsupp.linearCombination_apply, Finsupp.sum] using b.linearCombination_repr\n  simp only [a] at h₁\n  simp_rw [map_finsupp_sum, map_smul, h₁, Finsupp.sum, Finset.sum_comm (t := f.support),\n    TensorProduct.smul_tmul', ← TensorProduct.sum_tmul, ← Finset.smul_sum, h₂]\n  apply Finset.sum_congr rfl\n  intros i hi\n  apply Finset.sum_subset_zero_on_sdiff\n  · exact Finset.subset_biUnion_of_mem (fun i ↦ (a i).support) hi\n  · simp only [a, Finset.mem_sdiff, Finset.mem_biUnion, Finsupp.mem_support_iff, ne_eq, not_not,\n      and_imp, forall_exists_index]\n    simp (config := {contextual := true})\n  · exact fun _ _ ↦ rfl\n\n"}
{"name":"Algebra.FormallyUnramified.one_tmul_sub_tmul_one_mul_elem","module":"Mathlib.RingTheory.Unramified.Finite","initialProofState":"R : Type u_3\nS : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : Algebra R S\ninst✝¹ : Algebra.FormallyUnramified R S\ninst✝ : Algebra.EssFiniteType R S\ns : S\n⊢ Eq (HMul.hMul (HSub.hSub (TensorProduct.tmul R 1 s) (TensorProduct.tmul R s 1)) (Algebra.FormallyUnramified.elem R S)) 0","decl":"lemma one_tmul_sub_tmul_one_mul_elem\n    (s : S) : (1 ⊗ₜ s - s ⊗ₜ 1) * elem R S = 0 :=\n  (iff_exists_tensorProduct.mp inferInstance).choose_spec.1 s\n\n"}
{"name":"Algebra.FormallyUnramified.one_tmul_mul_elem","module":"Mathlib.RingTheory.Unramified.Finite","initialProofState":"R : Type u_3\nS : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : Algebra R S\ninst✝¹ : Algebra.FormallyUnramified R S\ninst✝ : Algebra.EssFiniteType R S\ns : S\n⊢ Eq (HMul.hMul (TensorProduct.tmul R 1 s) (Algebra.FormallyUnramified.elem R S)) (HMul.hMul (TensorProduct.tmul R s 1) (Algebra.FormallyUnramified.elem R S))","decl":"lemma one_tmul_mul_elem\n    (s : S) : (1 ⊗ₜ s) * elem R S = (s ⊗ₜ 1) * elem R S := by\n  rw [← sub_eq_zero, ← sub_mul, one_tmul_sub_tmul_one_mul_elem]\n\n"}
{"name":"Algebra.FormallyUnramified.lmul_elem","module":"Mathlib.RingTheory.Unramified.Finite","initialProofState":"R : Type u_3\nS : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : Algebra R S\ninst✝¹ : Algebra.FormallyUnramified R S\ninst✝ : Algebra.EssFiniteType R S\n⊢ Eq ((Algebra.TensorProduct.lmul' R) (Algebra.FormallyUnramified.elem R S)) 1","decl":"lemma lmul_elem :\n    TensorProduct.lmul' R (elem R S) = 1 :=\n  (iff_exists_tensorProduct.mp inferInstance).choose_spec.2\n\n\n"}
{"name":"Algebra.FormallyUnramified.finite_of_free","module":"Mathlib.RingTheory.Unramified.Finite","initialProofState":"R : Type u_2\nS : Type u_3\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing S\ninst✝³ : Algebra R S\ninst✝² : Algebra.FormallyUnramified R S\ninst✝¹ : Algebra.EssFiniteType R S\ninst✝ : Module.Free R S\n⊢ Module.Finite R S","decl":"/-- An unramified free algebra is finitely generated. Iversen I.2.8 -/\nlemma finite_of_free [Module.Free R S] : Module.Finite R S := by\n  classical\n  let I := Module.Free.ChooseBasisIndex R S\n  -- Let `bᵢ` be an `R`-basis of `S`.\n  let b : Basis I R S := Module.Free.chooseBasis R S\n  -- Let `∑ₛ fᵢ ⊗ bᵢ : S ⊗[R] S` (summing over some finite `s`) be an element such that\n  -- `∑ₛ fᵢbᵢ = 1` and `∀ x : S, xfᵢ ⊗ bᵢ = aᵢ ⊗ xfᵢ` which exists since `S` is unramified over `R`.\n  have ⟨f, hf⟩ : ∃ (a : I →₀ S), elem R S = a.sum (fun i x ↦ x ⊗ₜ b i) := by\n    let b' := ((Basis.singleton PUnit.{1} S).tensorProduct b).reindex (Equiv.punitProd I)\n    use b'.repr (elem R S)\n    conv_lhs => rw [← b'.linearCombination_repr (elem R S), Finsupp.linearCombination_apply]\n    congr! with _ i x\n    simp [b', Basis.tensorProduct, TensorProduct.smul_tmul']\n  constructor\n  -- I claim that `{ fᵢbⱼ | i, j ∈ s }` spans `S` over `R`.\n  use Finset.image₂ (fun i j ↦ f i * b j) f.support f.support\n  rw [← top_le_iff]\n  -- For all `x : S`, let `bᵢx = ∑ aᵢⱼbⱼ`.\n  rintro x -\n  let a : I → I →₀ R := fun i ↦ b.repr (b i * x)\n  -- Consider `F` such that `fⱼx = ∑ Fᵢⱼbⱼ`.\n  let F : I →₀ I →₀ R := Finsupp.onFinset f.support (fun j ↦ b.repr (x * f j))\n    (fun j ↦ not_imp_comm.mp fun hj ↦ by simp [Finsupp.not_mem_support_iff.mp hj])\n  have hG : ∀ j ∉ (Finset.biUnion f.support fun i ↦ (a i).support),\n      b.repr (f.sum (fun i y ↦ a i j • y)) = 0 := by\n    intros j hj\n    simp only [Finset.mem_biUnion, Finsupp.mem_support_iff, ne_eq, not_exists, not_and,\n      not_not] at hj\n    simp only [Finsupp.sum]\n    trans b.repr (f.support.sum (fun _ ↦ 0))\n    · refine congr_arg b.repr (Finset.sum_congr rfl ?_)\n      simp only [Finsupp.mem_support_iff]\n      intro i hi\n      rw [hj i hi, zero_smul]\n    · simp only [Finset.sum_const_zero, map_zero]\n  -- And `G` such that `∑ₛ aᵢⱼfᵢ = ∑ Gᵢⱼbⱼ`, where `aᵢⱼ` are the coefficients `bᵢx = ∑ aᵢⱼbⱼ`.\n  let G : I →₀ I →₀ R := Finsupp.onFinset (Finset.biUnion f.support (fun i ↦ (a i).support))\n    (fun j ↦ b.repr (f.sum (fun i y ↦ a i j • y)))\n    (fun j ↦ not_imp_comm.mp (hG j))\n  -- Then `∑ Fᵢⱼ(bⱼ ⊗ bᵢ) = ∑ fⱼx ⊗ bᵢ = ∑ fⱼ ⊗ xbᵢ = ∑ aᵢⱼ(fⱼ ⊗ bᵢ) = ∑ Gᵢⱼ(bⱼ ⊗ bᵢ)`.\n  -- Since `bⱼ ⊗ bᵢ` forms an `R`-basis of `S ⊗ S`, we conclude that `F = G`.\n  have : F = G := by\n    apply Finsupp.finsuppProdEquiv.symm.injective\n    apply (Finsupp.equivCongrLeft (Equiv.prodComm I I)).injective\n    apply (b.tensorProduct b).repr.symm.injective\n    simp only [Basis.repr_symm_apply, Finsupp.coe_lsum, LinearMap.coe_smulRight,\n      LinearMap.id_coe, id_eq, Basis.tensorProduct_apply, Finsupp.finsuppProdEquiv,\n      Equiv.coe_fn_symm_mk, Finsupp.uncurry, map_finsupp_sum,\n      Finsupp.linearCombination_single, Basis.tensorProduct_apply, Finsupp.equivCongrLeft_apply,\n      Finsupp.linearCombination_equivMapDomain, Equiv.coe_prodComm]\n    rw [Finsupp.onFinset_sum, Finsupp.onFinset_sum]\n    simp only [Function.comp_apply, Prod.swap_prod_mk, Basis.tensorProduct_apply]\n    have : ∀ i, ((b.repr (x * f i)).sum fun j k ↦ k • b j ⊗ₜ[R] b i) = (x * f i) ⊗ₜ[R] b i := by\n      intro i\n      simp_rw [Finsupp.sum, TensorProduct.smul_tmul', ← TensorProduct.sum_tmul]\n      congr 1\n      exact b.linearCombination_repr _\n    trans (x ⊗ₜ 1) * elem R S\n    · simp_rw [this, hf, Finsupp.sum, Finset.mul_sum, TensorProduct.tmul_mul_tmul, one_mul]\n    · rw [← one_tmul_mul_elem, hf, finite_of_free_aux]\n      rfl\n    · intro; simp\n    · intro; simp\n  -- In particular, `fⱼx = ∑ Fᵢⱼbⱼ = ∑ Gᵢⱼbⱼ = ∑ₛ aᵢⱼfᵢ` for all `j`.\n  have : ∀ j, x * f j = f.sum fun i y ↦ a i j • y := by\n    intro j\n    apply b.repr.injective\n    exact DFunLike.congr_fun this j\n  -- Since `∑ₛ fⱼbⱼ = 1`, `x = ∑ₛ aᵢⱼfᵢbⱼ` is indeed in the span of `{ fᵢbⱼ | i, j ∈ s }`.\n  rw [← mul_one x, ← @lmul_elem R, hf, map_finsupp_sum, Finsupp.sum, Finset.mul_sum]\n  simp only [TensorProduct.lmul'_apply_tmul, Finset.coe_image₂, ← mul_assoc, this,\n    Finsupp.sum, Finset.sum_mul, smul_mul_assoc]\n  apply Submodule.sum_mem; intro i hi\n  apply Submodule.sum_mem; intro j hj\n  apply Submodule.smul_mem\n  apply Submodule.subset_span\n  use j, hj, i, hi\n\n"}
{"name":"Algebra.FormallyUnramified.comp_sec","module":"Mathlib.RingTheory.Unramified.Finite","initialProofState":"R : Type u_3\nS : Type u_2\ninst✝⁸ : CommRing R\ninst✝⁷ : CommRing S\ninst✝⁶ : Algebra R S\nM : Type u_1\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : Module S M\ninst✝² : IsScalarTower R S M\ninst✝¹ : Algebra.FormallyUnramified R S\ninst✝ : Algebra.EssFiniteType R S\n⊢ Eq ((TensorProduct.AlgebraTensorModule.lift (↑R (Algebra.lsmul S S M).toLinearMap.flip).flip).comp (Algebra.FormallyUnramified.sec R S M)) LinearMap.id","decl":"lemma comp_sec :\n    (TensorProduct.AlgebraTensorModule.lift\n      ((lsmul S S M).toLinearMap.flip.restrictScalars R).flip).comp (sec R S M) =\n      LinearMap.id := by\n  ext x\n  simp only [sec, LinearMap.coe_comp, LinearMap.coe_mk, LinearMap.coe_toAddHom,\n    Function.comp_apply, LinearMap.flip_apply, TensorProduct.AlgebraTensorModule.mapBilinear_apply,\n    TensorProduct.AlgebraTensorModule.lift_apply, LinearMap.id_coe, id_eq]\n  trans (TensorProduct.lmul' R (elem R S)) • x\n  · induction' elem R S using TensorProduct.induction_on with r s y z hy hz\n    · simp\n    · simp [mul_smul, smul_comm r s]\n    · simp [hy, hz, add_smul]\n  · rw [lmul_elem, one_smul]\n\n"}
{"name":"Algebra.FormallyUnramified.flat_of_restrictScalars","module":"Mathlib.RingTheory.Unramified.Finite","initialProofState":"R : Type u_2\nS : Type u_3\ninst✝⁹ : CommRing R\ninst✝⁸ : CommRing S\ninst✝⁷ : Algebra R S\nM : Type u_1\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : Module R M\ninst✝⁴ : Module S M\ninst✝³ : IsScalarTower R S M\ninst✝² : Algebra.FormallyUnramified R S\ninst✝¹ : Algebra.EssFiniteType R S\ninst✝ : Module.Flat R M\n⊢ Module.Flat S M","decl":"/-- If `S` is an unramified `R`-algebra, then `R`-flat implies `S`-flat. Iversen I.2.7 -/\nlemma flat_of_restrictScalars [Module.Flat R M] : Module.Flat S M :=\n  Module.Flat.of_retract _ _ (comp_sec R S M)\n\n"}
{"name":"Algebra.FormallyUnramified.projective_of_restrictScalars","module":"Mathlib.RingTheory.Unramified.Finite","initialProofState":"R : Type u_2\nS : Type u_3\ninst✝⁹ : CommRing R\ninst✝⁸ : CommRing S\ninst✝⁷ : Algebra R S\nM : Type u_1\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : Module R M\ninst✝⁴ : Module S M\ninst✝³ : IsScalarTower R S M\ninst✝² : Algebra.FormallyUnramified R S\ninst✝¹ : Algebra.EssFiniteType R S\ninst✝ : Module.Projective R M\n⊢ Module.Projective S M","decl":"/-- If `S` is an unramified `R`-algebra, then `R`-projective implies `S`-projective. -/\nlemma projective_of_restrictScalars [Module.Projective R M] : Module.Projective S M :=\n  Module.Projective.of_split _ _ (comp_sec R S M)\n\n"}
