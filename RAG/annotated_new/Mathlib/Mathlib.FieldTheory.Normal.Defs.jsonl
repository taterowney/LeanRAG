{"name":"Normal.splits'","module":"Mathlib.FieldTheory.Normal.Defs","initialProofState":"F : Type u_1\nK : Type u_2\ninst✝² : Field F\ninst✝¹ : Field K\ninst✝ : Algebra F K\nself : Normal F K\nx : K\n⊢ Polynomial.Splits (algebraMap F K) (minpoly F x)","decl":"/-- Typeclass for normal field extension: `K` is a normal extension of `F` iff the minimal\npolynomial of every element `x` in `K` splits in `K`, i.e. every conjugate of `x` is in `K`. -/\n@[stacks 09HM]\nclass Normal extends Algebra.IsAlgebraic F K : Prop where\n  splits' (x : K) : Splits (algebraMap F K) (minpoly F x)\n\n"}
{"name":"Normal.toIsAlgebraic","module":"Mathlib.FieldTheory.Normal.Defs","initialProofState":"F : Type u_1\nK : Type u_2\ninst✝² : Field F\ninst✝¹ : Field K\ninst✝ : Algebra F K\nself : Normal F K\n⊢ Algebra.IsAlgebraic F K","decl":"/-- Typeclass for normal field extension: `K` is a normal extension of `F` iff the minimal\npolynomial of every element `x` in `K` splits in `K`, i.e. every conjugate of `x` is in `K`. -/\n@[stacks 09HM]\nclass Normal extends Algebra.IsAlgebraic F K : Prop where\n  splits' (x : K) : Splits (algebraMap F K) (minpoly F x)\n\n"}
{"name":"Normal.isIntegral","module":"Mathlib.FieldTheory.Normal.Defs","initialProofState":"F : Type u_1\nK : Type u_2\ninst✝² : Field F\ninst✝¹ : Field K\ninst✝ : Algebra F K\nx✝ : Normal F K\nx : K\n⊢ IsIntegral F x","decl":"theorem Normal.isIntegral (_ : Normal F K) (x : K) : IsIntegral F x :=\n  Algebra.IsIntegral.isIntegral x\n\n"}
{"name":"Normal.splits","module":"Mathlib.FieldTheory.Normal.Defs","initialProofState":"F : Type u_1\nK : Type u_2\ninst✝² : Field F\ninst✝¹ : Field K\ninst✝ : Algebra F K\nx✝ : Normal F K\nx : K\n⊢ Polynomial.Splits (algebraMap F K) (minpoly F x)","decl":"theorem Normal.splits (_ : Normal F K) (x : K) : Splits (algebraMap F K) (minpoly F x) :=\n  Normal.splits' x\n\n"}
{"name":"normal_iff","module":"Mathlib.FieldTheory.Normal.Defs","initialProofState":"F : Type u_1\nK : Type u_2\ninst✝² : Field F\ninst✝¹ : Field K\ninst✝ : Algebra F K\n⊢ Iff (Normal F K) (∀ (x : K), And (IsIntegral F x) (Polynomial.Splits (algebraMap F K) (minpoly F x)))","decl":"theorem normal_iff : Normal F K ↔ ∀ x : K, IsIntegral F x ∧ Splits (algebraMap F K) (minpoly F x) :=\n  ⟨fun h x => ⟨h.isIntegral x, h.splits x⟩, fun h =>\n    { isAlgebraic := fun x => (h x).1.isAlgebraic\n      splits' := fun x => (h x).2 }⟩\n\n"}
{"name":"Normal.out","module":"Mathlib.FieldTheory.Normal.Defs","initialProofState":"F : Type u_1\nK : Type u_2\ninst✝² : Field F\ninst✝¹ : Field K\ninst✝ : Algebra F K\na✝ : Normal F K\nx : K\n⊢ And (IsIntegral F x) (Polynomial.Splits (algebraMap F K) (minpoly F x))","decl":"theorem Normal.out : Normal F K → ∀ x : K, IsIntegral F x ∧ Splits (algebraMap F K) (minpoly F x) :=\n  normal_iff.1\n\n"}
{"name":"normal_self","module":"Mathlib.FieldTheory.Normal.Defs","initialProofState":"F : Type u_1\ninst✝ : Field F\n⊢ Normal F F","decl":"instance normal_self : Normal F F where\n  isAlgebraic := fun _ => isIntegral_algebraMap.isAlgebraic\n  splits' := fun x => (minpoly.eq_X_sub_C' x).symm ▸ splits_X_sub_C _\n\n"}
{"name":"Normal.tower_top_of_normal","module":"Mathlib.FieldTheory.Normal.Defs","initialProofState":"F : Type u_1\nK : Type u_2\ninst✝⁶ : Field F\ninst✝⁵ : Field K\ninst✝⁴ : Algebra F K\nE : Type u_3\ninst✝³ : Field E\ninst✝² : Algebra F E\ninst✝¹ : Algebra K E\ninst✝ : IsScalarTower F K E\nh : Normal F E\n⊢ Normal K E","decl":"@[stacks 09HN]\ntheorem Normal.tower_top_of_normal [h : Normal F E] : Normal K E :=\n  normal_iff.2 fun x => by\n    cases' h.out x with hx hhx\n    rw [algebraMap_eq F K E] at hhx\n    exact\n      ⟨hx.tower_top,\n        Polynomial.splits_of_splits_of_dvd (algebraMap K E)\n          (Polynomial.map_ne_zero (minpoly.ne_zero hx))\n          ((Polynomial.splits_map_iff (algebraMap F K) (algebraMap K E)).mpr hhx)\n          (minpoly.dvd_map_of_isScalarTower F K x)⟩\n\n"}
{"name":"AlgHom.normal_bijective","module":"Mathlib.FieldTheory.Normal.Defs","initialProofState":"F : Type u_1\nK : Type u_2\ninst✝⁶ : Field F\ninst✝⁵ : Field K\ninst✝⁴ : Algebra F K\nE : Type u_3\ninst✝³ : Field E\ninst✝² : Algebra F E\ninst✝¹ : Algebra K E\ninst✝ : IsScalarTower F K E\nh : Normal F E\nϕ : AlgHom F E K\n⊢ Function.Bijective ⇑ϕ","decl":"theorem AlgHom.normal_bijective [h : Normal F E] (ϕ : E →ₐ[F] K) : Function.Bijective ϕ :=\n  h.toIsAlgebraic.bijective_of_isScalarTower' ϕ\n\n"}
{"name":"Normal.of_algEquiv","module":"Mathlib.FieldTheory.Normal.Defs","initialProofState":"F : Type u_1\ninst✝⁴ : Field F\nE : Type u_3\ninst✝³ : Field E\ninst✝² : Algebra F E\nE' : Type u_4\ninst✝¹ : Field E'\ninst✝ : Algebra F E'\nh : Normal F E\nf : AlgEquiv F E E'\n⊢ Normal F E'","decl":"theorem Normal.of_algEquiv [h : Normal F E] (f : E ≃ₐ[F] E') : Normal F E' := by\n  rw [normal_iff] at h ⊢\n  intro x; specialize h (f.symm x)\n  rw [← f.apply_symm_apply x, minpoly.algEquiv_eq, ← f.toAlgHom.comp_algebraMap]\n  exact ⟨h.1.map f, splits_comp_of_splits _ _ h.2⟩\n\n"}
{"name":"AlgEquiv.transfer_normal","module":"Mathlib.FieldTheory.Normal.Defs","initialProofState":"F : Type u_1\ninst✝⁴ : Field F\nE : Type u_3\ninst✝³ : Field E\ninst✝² : Algebra F E\nE' : Type u_4\ninst✝¹ : Field E'\ninst✝ : Algebra F E'\nf : AlgEquiv F E E'\n⊢ Iff (Normal F E) (Normal F E')","decl":"theorem AlgEquiv.transfer_normal (f : E ≃ₐ[F] E') : Normal F E ↔ Normal F E' :=\n  ⟨fun _ ↦ Normal.of_algEquiv f, fun _ ↦ Normal.of_algEquiv f.symm⟩\n\n"}
{"name":"IntermediateField.restrictScalars_normal","module":"Mathlib.FieldTheory.Normal.Defs","initialProofState":"F : Type u_1\nK : Type u_2\ninst✝⁶ : Field F\ninst✝⁵ : Field K\ninst✝⁴ : Algebra F K\nL : Type u_3\ninst✝³ : Field L\ninst✝² : Algebra F L\ninst✝¹ : Algebra K L\ninst✝ : IsScalarTower F K L\nE : IntermediateField K L\n⊢ Iff (Normal F (Subtype fun x => Membership.mem (IntermediateField.restrictScalars F E) x)) (Normal F (Subtype fun x => Membership.mem E x))","decl":"@[simp]\ntheorem restrictScalars_normal {E : IntermediateField K L} :\n    Normal F (E.restrictScalars F) ↔ Normal F E :=\n  Iff.rfl\n\n"}
{"name":"AlgHom.restrictNormal_commutes","module":"Mathlib.FieldTheory.Normal.Defs","initialProofState":"F : Type u_1\ninst✝¹¹ : Field F\nK₁ : Type u_3\nK₂ : Type u_4\ninst✝¹⁰ : Field K₁\ninst✝⁹ : Field K₂\ninst✝⁸ : Algebra F K₁\ninst✝⁷ : Algebra F K₂\nϕ : AlgHom F K₁ K₂\nE : Type u_6\ninst✝⁶ : Field E\ninst✝⁵ : Algebra F E\ninst✝⁴ : Algebra E K₁\ninst✝³ : Algebra E K₂\ninst✝² : IsScalarTower F E K₁\ninst✝¹ : IsScalarTower F E K₂\ninst✝ : Normal F E\nx : E\n⊢ Eq ((algebraMap E K₂) ((ϕ.restrictNormal E) x)) (ϕ ((algebraMap E K₁) x))","decl":"@[simp]\ntheorem AlgHom.restrictNormal_commutes [Normal F E] (x : E) :\n    algebraMap E K₂ (ϕ.restrictNormal E x) = ϕ (algebraMap E K₁ x) :=\n  Subtype.ext_iff.mp\n    (AlgEquiv.apply_symm_apply (AlgEquiv.ofInjectiveField (IsScalarTower.toAlgHom F E K₂))\n      (ϕ.restrictNormalAux E ⟨IsScalarTower.toAlgHom F E K₁ x, x, rfl⟩))\n\n"}
{"name":"AlgHom.restrictNormal_comp","module":"Mathlib.FieldTheory.Normal.Defs","initialProofState":"F : Type u_1\ninst✝¹⁵ : Field F\nK₁ : Type u_3\nK₂ : Type u_4\nK₃ : Type u_5\ninst✝¹⁴ : Field K₁\ninst✝¹³ : Field K₂\ninst✝¹² : Field K₃\ninst✝¹¹ : Algebra F K₁\ninst✝¹⁰ : Algebra F K₂\ninst✝⁹ : Algebra F K₃\nϕ : AlgHom F K₁ K₂\nψ : AlgHom F K₂ K₃\nE : Type u_6\ninst✝⁸ : Field E\ninst✝⁷ : Algebra F E\ninst✝⁶ : Algebra E K₁\ninst✝⁵ : Algebra E K₂\ninst✝⁴ : Algebra E K₃\ninst✝³ : IsScalarTower F E K₁\ninst✝² : IsScalarTower F E K₂\ninst✝¹ : IsScalarTower F E K₃\ninst✝ : Normal F E\n⊢ Eq ((ψ.restrictNormal E).comp (ϕ.restrictNormal E)) ((ψ.comp ϕ).restrictNormal E)","decl":"theorem AlgHom.restrictNormal_comp [Normal F E] :\n    (ψ.restrictNormal E).comp (ϕ.restrictNormal E) = (ψ.comp ϕ).restrictNormal E :=\n  AlgHom.ext fun _ =>\n    (algebraMap E K₃).injective (by simp only [AlgHom.comp_apply, AlgHom.restrictNormal_commutes])\n\n"}
{"name":"AlgEquiv.restrictNormal_commutes","module":"Mathlib.FieldTheory.Normal.Defs","initialProofState":"F : Type u_1\ninst✝¹¹ : Field F\nK₁ : Type u_3\nK₂ : Type u_4\ninst✝¹⁰ : Field K₁\ninst✝⁹ : Field K₂\ninst✝⁸ : Algebra F K₁\ninst✝⁷ : Algebra F K₂\nχ : AlgEquiv F K₁ K₂\nE : Type u_6\ninst✝⁶ : Field E\ninst✝⁵ : Algebra F E\ninst✝⁴ : Algebra E K₁\ninst✝³ : Algebra E K₂\ninst✝² : IsScalarTower F E K₁\ninst✝¹ : IsScalarTower F E K₂\ninst✝ : Normal F E\nx : E\n⊢ Eq ((algebraMap E K₂) ((χ.restrictNormal E) x)) (χ ((algebraMap E K₁) x))","decl":"@[simp]\ntheorem AlgEquiv.restrictNormal_commutes [Normal F E] (x : E) :\n    algebraMap E K₂ (χ.restrictNormal E x) = χ (algebraMap E K₁ x) :=\n  χ.toAlgHom.restrictNormal_commutes E x\n\n"}
{"name":"AlgEquiv.restrictNormal_trans","module":"Mathlib.FieldTheory.Normal.Defs","initialProofState":"F : Type u_1\ninst✝¹⁵ : Field F\nK₁ : Type u_3\nK₂ : Type u_4\nK₃ : Type u_5\ninst✝¹⁴ : Field K₁\ninst✝¹³ : Field K₂\ninst✝¹² : Field K₃\ninst✝¹¹ : Algebra F K₁\ninst✝¹⁰ : Algebra F K₂\ninst✝⁹ : Algebra F K₃\nχ : AlgEquiv F K₁ K₂\nω : AlgEquiv F K₂ K₃\nE : Type u_6\ninst✝⁸ : Field E\ninst✝⁷ : Algebra F E\ninst✝⁶ : Algebra E K₁\ninst✝⁵ : Algebra E K₂\ninst✝⁴ : Algebra E K₃\ninst✝³ : IsScalarTower F E K₁\ninst✝² : IsScalarTower F E K₂\ninst✝¹ : IsScalarTower F E K₃\ninst✝ : Normal F E\n⊢ Eq ((χ.trans ω).restrictNormal E) ((χ.restrictNormal E).trans (ω.restrictNormal E))","decl":"theorem AlgEquiv.restrictNormal_trans [Normal F E] :\n    (χ.trans ω).restrictNormal E = (χ.restrictNormal E).trans (ω.restrictNormal E) :=\n  AlgEquiv.ext fun _ =>\n    (algebraMap E K₃).injective\n      (by simp only [AlgEquiv.trans_apply, AlgEquiv.restrictNormal_commutes])\n\n"}
{"name":"AlgEquiv.restrictNormalHom_apply","module":"Mathlib.FieldTheory.Normal.Defs","initialProofState":"F : Type u_1\ninst✝³ : Field F\nK₁ : Type u_3\ninst✝² : Field K₁\ninst✝¹ : Algebra F K₁\nL : IntermediateField F K₁\ninst✝ : Normal F (Subtype fun x => Membership.mem L x)\nσ : AlgEquiv F K₁ K₁\nx : Subtype fun x => Membership.mem L x\n⊢ Eq (↑(((AlgEquiv.restrictNormalHom (Subtype fun x => Membership.mem L x)) σ) x)) (σ ↑x)","decl":"lemma AlgEquiv.restrictNormalHom_apply (L : IntermediateField F K₁) [Normal F L]\n    (σ : (K₁ ≃ₐ[F] K₁)) (x : L) : restrictNormalHom L σ x = σ x :=\n  AlgEquiv.restrictNormal_commutes σ L x\n\n"}
{"name":"Normal.algHomEquivAut_symm_apply","module":"Mathlib.FieldTheory.Normal.Defs","initialProofState":"F : Type u_1\ninst✝⁷ : Field F\nK₁ : Type u_3\ninst✝⁶ : Field K₁\ninst✝⁵ : Algebra F K₁\nE : Type u_6\ninst✝⁴ : Field E\ninst✝³ : Algebra F E\ninst✝² : Algebra E K₁\ninst✝¹ : IsScalarTower F E K₁\ninst✝ : Normal F E\nσ : AlgEquiv F E E\n⊢ Eq ((Normal.algHomEquivAut F K₁ E).symm σ) ((IsScalarTower.toAlgHom F E K₁).comp ↑σ)","decl":"/-- If `K₁/E/F` is a tower of fields with `E/F` normal then `AlgHom.restrictNormal'` is an\n equivalence. -/\n@[simps, stacks 0BR4]\ndef Normal.algHomEquivAut [Normal F E] : (E →ₐ[F] K₁) ≃ E ≃ₐ[F] E where\n  toFun σ := AlgHom.restrictNormal' σ E\n  invFun σ := (IsScalarTower.toAlgHom F E K₁).comp σ.toAlgHom\n  left_inv σ := by\n    ext\n    simp [AlgHom.restrictNormal']\n  right_inv σ := by\n    ext\n    simp only [AlgHom.restrictNormal', AlgEquiv.toAlgHom_eq_coe, AlgEquiv.coe_ofBijective]\n    apply NoZeroSMulDivisors.algebraMap_injective E K₁\n    rw [AlgHom.restrictNormal_commutes]\n    simp\n\n"}
{"name":"Normal.algHomEquivAut_apply","module":"Mathlib.FieldTheory.Normal.Defs","initialProofState":"F : Type u_1\ninst✝⁷ : Field F\nK₁ : Type u_3\ninst✝⁶ : Field K₁\ninst✝⁵ : Algebra F K₁\nE : Type u_6\ninst✝⁴ : Field E\ninst✝³ : Algebra F E\ninst✝² : Algebra E K₁\ninst✝¹ : IsScalarTower F E K₁\ninst✝ : Normal F E\nσ : AlgHom F E K₁\n⊢ Eq ((Normal.algHomEquivAut F K₁ E) σ) (σ.restrictNormal' E)","decl":"/-- If `K₁/E/F` is a tower of fields with `E/F` normal then `AlgHom.restrictNormal'` is an\n equivalence. -/\n@[simps, stacks 0BR4]\ndef Normal.algHomEquivAut [Normal F E] : (E →ₐ[F] K₁) ≃ E ≃ₐ[F] E where\n  toFun σ := AlgHom.restrictNormal' σ E\n  invFun σ := (IsScalarTower.toAlgHom F E K₁).comp σ.toAlgHom\n  left_inv σ := by\n    ext\n    simp [AlgHom.restrictNormal']\n  right_inv σ := by\n    ext\n    simp only [AlgHom.restrictNormal', AlgEquiv.toAlgHom_eq_coe, AlgEquiv.coe_ofBijective]\n    apply NoZeroSMulDivisors.algebraMap_injective E K₁\n    rw [AlgHom.restrictNormal_commutes]\n    simp\n\n"}
{"name":"AlgEquiv.restrictNormalHom_id","module":"Mathlib.FieldTheory.Normal.Defs","initialProofState":"F : Type u_6\nK : Type u_7\ninst✝³ : Field F\ninst✝² : Field K\ninst✝¹ : Algebra F K\ninst✝ : Normal F K\n⊢ Eq (AlgEquiv.restrictNormalHom K) (MonoidHom.id (AlgEquiv F K K))","decl":"/-- The group homomorphism given by restricting an algebra isomorphism to itself\nis the identity map. -/\n@[simp]\ntheorem AlgEquiv.restrictNormalHom_id (F K : Type*)\n    [Field F] [Field K] [Algebra F K] [Normal F K] :\n    AlgEquiv.restrictNormalHom K = MonoidHom.id (K ≃ₐ[F] K) := by\n  ext f x\n  dsimp only [restrictNormalHom, MonoidHom.mk'_apply, MonoidHom.id_apply]\n  apply (algebraMap K K).injective\n  rw [AlgEquiv.restrictNormal_commutes]\n  simp only [Algebra.id.map_eq_id, RingHom.id_apply]\n\n"}
{"name":"IsScalarTower.AlgEquiv.restrictNormalHom_comp","module":"Mathlib.FieldTheory.Normal.Defs","initialProofState":"F : Type u_6\nK₁ : Type u_7\nK₂ : Type u_8\nK₃ : Type u_9\ninst✝¹⁵ : Field F\ninst✝¹⁴ : Field K₁\ninst✝¹³ : Field K₂\ninst✝¹² : Field K₃\ninst✝¹¹ : Algebra F K₁\ninst✝¹⁰ : Algebra F K₂\ninst✝⁹ : Algebra F K₃\ninst✝⁸ : Algebra K₁ K₂\ninst✝⁷ : Algebra K₁ K₃\ninst✝⁶ : Algebra K₂ K₃\ninst✝⁵ : IsScalarTower F K₁ K₃\ninst✝⁴ : IsScalarTower F K₁ K₂\ninst✝³ : IsScalarTower F K₂ K₃\ninst✝² : IsScalarTower K₁ K₂ K₃\ninst✝¹ : Normal F K₁\ninst✝ : Normal F K₂\n⊢ Eq (AlgEquiv.restrictNormalHom K₁) ((AlgEquiv.restrictNormalHom K₁).comp (AlgEquiv.restrictNormalHom K₂))","decl":"/-- In a scalar tower `K₃/K₂/K₁/F` with `K₁` and `K₂` are normal over `F`, the group homomorphism\ngiven by the restriction of algebra isomorphisms of `K₃` to `K₁` is equal to the composition of\nthe group homomorphism given by the restricting an algebra isomorphism of `K₃` to `K₂` and\nthe group homomorphism given by the restricting an algebra isomorphism of `K₂` to `K₁` -/\ntheorem AlgEquiv.restrictNormalHom_comp (F K₁ K₂ K₃ : Type*)\n    [Field F] [Field K₁] [Field K₂] [Field K₃]\n    [Algebra F K₁] [Algebra F K₂] [Algebra F K₃] [Algebra K₁ K₂] [Algebra K₁ K₃] [Algebra K₂ K₃]\n    [IsScalarTower F K₁ K₃] [IsScalarTower F K₁ K₂] [IsScalarTower F K₂ K₃] [IsScalarTower K₁ K₂ K₃]\n    [Normal F K₁] [Normal F K₂] :\n    AlgEquiv.restrictNormalHom K₁ =\n    (AlgEquiv.restrictNormalHom K₁).comp\n    (AlgEquiv.restrictNormalHom (F := F) (K₁ := K₃) K₂) := by\n  ext f x\n  apply (algebraMap K₁ K₃).injective\n  rw [IsScalarTower.algebraMap_eq K₁ K₂ K₃]\n  simp only [AlgEquiv.restrictNormalHom, MonoidHom.mk'_apply, RingHom.coe_comp, Function.comp_apply,\n    ← algebraMap_apply, AlgEquiv.restrictNormal_commutes, MonoidHom.coe_comp]\n\n"}
{"name":"IsScalarTower.AlgEquiv.restrictNormalHom_comp_apply","module":"Mathlib.FieldTheory.Normal.Defs","initialProofState":"K₁ : Type u_6\nK₂ : Type u_7\nF : Type u_8\nK₃ : Type u_9\ninst✝¹⁵ : Field F\ninst✝¹⁴ : Field K₁\ninst✝¹³ : Field K₂\ninst✝¹² : Field K₃\ninst✝¹¹ : Algebra F K₁\ninst✝¹⁰ : Algebra F K₂\ninst✝⁹ : Algebra F K₃\ninst✝⁸ : Algebra K₁ K₂\ninst✝⁷ : Algebra K₁ K₃\ninst✝⁶ : Algebra K₂ K₃\ninst✝⁵ : IsScalarTower F K₁ K₃\ninst✝⁴ : IsScalarTower F K₁ K₂\ninst✝³ : IsScalarTower F K₂ K₃\ninst✝² : IsScalarTower K₁ K₂ K₃\ninst✝¹ : Normal F K₁\ninst✝ : Normal F K₂\nf : AlgEquiv F K₃ K₃\n⊢ Eq ((AlgEquiv.restrictNormalHom K₁) f) ((AlgEquiv.restrictNormalHom K₁) ((AlgEquiv.restrictNormalHom K₂) f))","decl":"theorem AlgEquiv.restrictNormalHom_comp_apply (K₁ K₂ : Type*) {F K₃ : Type*}\n    [Field F] [Field K₁] [Field K₂] [Field K₃]\n    [Algebra F K₁] [Algebra F K₂] [Algebra F K₃] [Algebra K₁ K₂] [Algebra K₁ K₃] [Algebra K₂ K₃]\n    [IsScalarTower F K₁ K₃] [IsScalarTower F K₁ K₂] [IsScalarTower F K₂ K₃] [IsScalarTower K₁ K₂ K₃]\n    [Normal F K₁] [Normal F K₂] (f : K₃ ≃ₐ[F] K₃) :\n    AlgEquiv.restrictNormalHom K₁ f =\n    (AlgEquiv.restrictNormalHom K₁) (AlgEquiv.restrictNormalHom K₂ f) := by\n  rw [IsScalarTower.AlgEquiv.restrictNormalHom_comp F K₁ K₂ K₃, MonoidHom.comp_apply]\n\n"}
