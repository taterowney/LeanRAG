{"name":"mul_cancel_right_mem_nonZeroDivisors","module":"Mathlib.Algebra.Ring.NonZeroDivisors","initialProofState":"R : Type u_1\ninst✝ : Ring R\nx y r : R\nhr : Membership.mem (nonZeroDivisors R) r\n⊢ Iff (Eq (HMul.hMul x r) (HMul.hMul y r)) (Eq x y)","decl":"lemma mul_cancel_right_mem_nonZeroDivisors (hr : r ∈ R⁰) : x * r = y * r ↔ x = y := by\n  refine ⟨fun h ↦ ?_, congrArg (· * r)⟩\n  rw [← sub_eq_zero, ← mul_right_mem_nonZeroDivisors_eq_zero_iff hr, sub_mul, h, sub_self]\n\n"}
{"name":"mul_cancel_right_coe_nonZeroDivisors","module":"Mathlib.Algebra.Ring.NonZeroDivisors","initialProofState":"R : Type u_1\ninst✝ : Ring R\nx y : R\nc : Subtype fun x => Membership.mem (nonZeroDivisors R) x\n⊢ Iff (Eq (HMul.hMul x ↑c) (HMul.hMul y ↑c)) (Eq x y)","decl":"lemma mul_cancel_right_coe_nonZeroDivisors {c : R⁰} : x * c = y * c ↔ x = y :=\n  mul_cancel_right_mem_nonZeroDivisors c.prop\n\n"}
{"name":"isUnit_iff_mem_nonZeroDivisors_of_finite","module":"Mathlib.Algebra.Ring.NonZeroDivisors","initialProofState":"R : Type u_1\ninst✝¹ : Ring R\na : R\ninst✝ : Finite R\n⊢ Iff (IsUnit a) (Membership.mem (nonZeroDivisors R) a)","decl":"/-- In a finite ring, an element is a unit iff it is a non-zero-divisor. -/\nlemma isUnit_iff_mem_nonZeroDivisors_of_finite [Finite R] : IsUnit a ↔ a ∈ nonZeroDivisors R := by\n  refine ⟨IsUnit.mem_nonZeroDivisors, fun ha ↦ ?_⟩\n  rw [IsUnit.isUnit_iff_mulRight_bijective, ← Finite.injective_iff_bijective]\n  intro b c hbc\n  rw [← sub_eq_zero, ← sub_mul] at hbc\n  exact sub_eq_zero.mp (ha _ hbc)\n\n"}
{"name":"mul_cancel_left_mem_nonZeroDivisors","module":"Mathlib.Algebra.Ring.NonZeroDivisors","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nr x y : R\nhr : Membership.mem (nonZeroDivisors R) r\n⊢ Iff (Eq (HMul.hMul r x) (HMul.hMul r y)) (Eq x y)","decl":"@[simp]\nlemma mul_cancel_left_mem_nonZeroDivisors (hr : r ∈ R⁰) : r * x = r * y ↔ x = y := by\n  simp_rw [mul_comm r, mul_cancel_right_mem_nonZeroDivisors hr]\n\n"}
{"name":"mul_cancel_left_coe_nonZeroDivisors","module":"Mathlib.Algebra.Ring.NonZeroDivisors","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nx y : R\nc : Subtype fun x => Membership.mem (nonZeroDivisors R) x\n⊢ Iff (Eq (HMul.hMul (↑c) x) (HMul.hMul (↑c) y)) (Eq x y)","decl":"lemma mul_cancel_left_coe_nonZeroDivisors {c : R⁰} : (c : R) * x = c * y ↔ x = y :=\n  mul_cancel_left_mem_nonZeroDivisors c.prop\n\n"}
{"name":"dvd_cancel_right_mem_nonZeroDivisors","module":"Mathlib.Algebra.Ring.NonZeroDivisors","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nr x y : R\nhr : Membership.mem (nonZeroDivisors R) r\n⊢ Iff (Dvd.dvd (HMul.hMul x r) (HMul.hMul y r)) (Dvd.dvd x y)","decl":"lemma dvd_cancel_right_mem_nonZeroDivisors (hr : r ∈ R⁰) : x * r ∣ y * r ↔ x ∣ y :=\n  ⟨fun ⟨z, _⟩ ↦ ⟨z, by rwa [← mul_cancel_right_mem_nonZeroDivisors hr, mul_assoc, mul_comm z r,\n    ← mul_assoc]⟩, fun ⟨z, h⟩ ↦ ⟨z, by rw [h, mul_assoc, mul_comm z r, ← mul_assoc]⟩⟩\n\n"}
{"name":"dvd_cancel_right_coe_nonZeroDivisors","module":"Mathlib.Algebra.Ring.NonZeroDivisors","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nx y : R\nc : Subtype fun x => Membership.mem (nonZeroDivisors R) x\n⊢ Iff (Dvd.dvd (HMul.hMul x ↑c) (HMul.hMul y ↑c)) (Dvd.dvd x y)","decl":"lemma dvd_cancel_right_coe_nonZeroDivisors {c : R⁰} : x * c ∣ y * c ↔ x ∣ y :=\n  dvd_cancel_right_mem_nonZeroDivisors c.prop\n\n"}
{"name":"dvd_cancel_left_mem_nonZeroDivisors","module":"Mathlib.Algebra.Ring.NonZeroDivisors","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nr x y : R\nhr : Membership.mem (nonZeroDivisors R) r\n⊢ Iff (Dvd.dvd (HMul.hMul r x) (HMul.hMul r y)) (Dvd.dvd x y)","decl":"lemma dvd_cancel_left_mem_nonZeroDivisors (hr : r ∈ R⁰) : r * x ∣ r * y ↔ x ∣ y :=\n  ⟨fun ⟨z, _⟩ ↦ ⟨z, by rwa [← mul_cancel_left_mem_nonZeroDivisors hr, ← mul_assoc]⟩,\n    fun ⟨z, h⟩ ↦ ⟨z, by rw [h, ← mul_assoc]⟩⟩\n\n"}
{"name":"dvd_cancel_left_coe_nonZeroDivisors","module":"Mathlib.Algebra.Ring.NonZeroDivisors","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nx y : R\nc : Subtype fun x => Membership.mem (nonZeroDivisors R) x\n⊢ Iff (Dvd.dvd (HMul.hMul (↑c) x) (HMul.hMul (↑c) y)) (Dvd.dvd x y)","decl":"lemma dvd_cancel_left_coe_nonZeroDivisors {c : R⁰} : c * x ∣ c * y ↔ x ∣ y :=\n  dvd_cancel_left_mem_nonZeroDivisors c.prop\n\n"}
