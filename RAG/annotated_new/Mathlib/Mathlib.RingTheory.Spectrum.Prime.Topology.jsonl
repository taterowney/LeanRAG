{"name":"PrimeSpectrum.isOpen_iff","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nU : Set (PrimeSpectrum R)\n⊢ Iff (IsOpen U) (Exists fun s => Eq (HasCompl.compl U) (PrimeSpectrum.zeroLocus s))","decl":"theorem isOpen_iff (U : Set (PrimeSpectrum R)) : IsOpen U ↔ ∃ s, Uᶜ = zeroLocus s := by\n  simp only [@eq_comm _ Uᶜ]; rfl\n\n"}
{"name":"PrimeSpectrum.isClosed_iff_zeroLocus","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nZ : Set (PrimeSpectrum R)\n⊢ Iff (IsClosed Z) (Exists fun s => Eq Z (PrimeSpectrum.zeroLocus s))","decl":"theorem isClosed_iff_zeroLocus (Z : Set (PrimeSpectrum R)) : IsClosed Z ↔ ∃ s, Z = zeroLocus s := by\n  rw [← isOpen_compl_iff, isOpen_iff, compl_compl]\n\n"}
{"name":"PrimeSpectrum.isClosed_iff_zeroLocus_ideal","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nZ : Set (PrimeSpectrum R)\n⊢ Iff (IsClosed Z) (Exists fun I => Eq Z (PrimeSpectrum.zeroLocus ↑I))","decl":"theorem isClosed_iff_zeroLocus_ideal (Z : Set (PrimeSpectrum R)) :\n    IsClosed Z ↔ ∃ I : Ideal R, Z = zeroLocus I :=\n  (isClosed_iff_zeroLocus _).trans\n    ⟨fun ⟨s, hs⟩ => ⟨_, (zeroLocus_span s).substr hs⟩, fun ⟨I, hI⟩ => ⟨I, hI⟩⟩\n\n"}
{"name":"PrimeSpectrum.isClosed_iff_zeroLocus_radical_ideal","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nZ : Set (PrimeSpectrum R)\n⊢ Iff (IsClosed Z) (Exists fun I => And I.IsRadical (Eq Z (PrimeSpectrum.zeroLocus ↑I)))","decl":"theorem isClosed_iff_zeroLocus_radical_ideal (Z : Set (PrimeSpectrum R)) :\n    IsClosed Z ↔ ∃ I : Ideal R, I.IsRadical ∧ Z = zeroLocus I :=\n  (isClosed_iff_zeroLocus_ideal _).trans\n    ⟨fun ⟨I, hI⟩ => ⟨_, I.radical_isRadical, (zeroLocus_radical I).substr hI⟩, fun ⟨I, _, hI⟩ =>\n      ⟨I, hI⟩⟩\n\n"}
{"name":"PrimeSpectrum.isClosed_zeroLocus","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommSemiring R\ns : Set R\n⊢ IsClosed (PrimeSpectrum.zeroLocus s)","decl":"theorem isClosed_zeroLocus (s : Set R) : IsClosed (zeroLocus s) := by\n  rw [isClosed_iff_zeroLocus]\n  exact ⟨s, rfl⟩\n\n"}
{"name":"PrimeSpectrum.zeroLocus_vanishingIdeal_eq_closure","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nt : Set (PrimeSpectrum R)\n⊢ Eq (PrimeSpectrum.zeroLocus ↑(PrimeSpectrum.vanishingIdeal t)) (closure t)","decl":"theorem zeroLocus_vanishingIdeal_eq_closure (t : Set (PrimeSpectrum R)) :\n    zeroLocus (vanishingIdeal t : Set R) = closure t := by\n  rcases isClosed_iff_zeroLocus (closure t) |>.mp isClosed_closure with ⟨I, hI⟩\n  rw [subset_antisymm_iff, (isClosed_zeroLocus _).closure_subset_iff, hI,\n      subset_zeroLocus_iff_subset_vanishingIdeal, (gc R).u_l_u_eq_u,\n      ← subset_zeroLocus_iff_subset_vanishingIdeal, ← hI]\n  exact ⟨subset_closure, subset_zeroLocus_vanishingIdeal t⟩\n\n"}
{"name":"PrimeSpectrum.vanishingIdeal_closure","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nt : Set (PrimeSpectrum R)\n⊢ Eq (PrimeSpectrum.vanishingIdeal (closure t)) (PrimeSpectrum.vanishingIdeal t)","decl":"theorem vanishingIdeal_closure (t : Set (PrimeSpectrum R)) :\n    vanishingIdeal (closure t) = vanishingIdeal t :=\n  zeroLocus_vanishingIdeal_eq_closure t ▸ (gc R).u_l_u_eq_u t\n\n"}
{"name":"PrimeSpectrum.closure_singleton","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx : PrimeSpectrum R\n⊢ Eq (closure (Singleton.singleton x)) (PrimeSpectrum.zeroLocus ↑x.asIdeal)","decl":"theorem closure_singleton (x) : closure ({x} : Set (PrimeSpectrum R)) = zeroLocus x.asIdeal := by\n  rw [← zeroLocus_vanishingIdeal_eq_closure, vanishingIdeal_singleton]\n\n"}
{"name":"PrimeSpectrum.isClosed_singleton_iff_isMaximal","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx : PrimeSpectrum R\n⊢ Iff (IsClosed (Singleton.singleton x)) x.asIdeal.IsMaximal","decl":"theorem isClosed_singleton_iff_isMaximal (x : PrimeSpectrum R) :\n    IsClosed ({x} : Set (PrimeSpectrum R)) ↔ x.asIdeal.IsMaximal := by\n  rw [← closure_subset_iff_isClosed, ← zeroLocus_vanishingIdeal_eq_closure,\n      vanishingIdeal_singleton]\n  constructor <;> intro H\n  · rcases x.asIdeal.exists_le_maximal x.2.1 with ⟨m, hm, hxm⟩\n    exact (congr_arg asIdeal (@H ⟨m, hm.isPrime⟩ hxm)) ▸ hm\n  · exact fun p hp ↦ PrimeSpectrum.ext (H.eq_of_le p.2.1 hp).symm\n\n"}
{"name":"PrimeSpectrum.isRadical_vanishingIdeal","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommSemiring R\ns : Set (PrimeSpectrum R)\n⊢ (PrimeSpectrum.vanishingIdeal s).IsRadical","decl":"theorem isRadical_vanishingIdeal (s : Set (PrimeSpectrum R)) : (vanishingIdeal s).IsRadical := by\n  rw [← vanishingIdeal_closure, ← zeroLocus_vanishingIdeal_eq_closure,\n    vanishingIdeal_zeroLocus_eq_radical]\n  apply Ideal.radical_isRadical\n\n"}
{"name":"PrimeSpectrum.zeroLocus_eq_iff","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI J : Ideal R\n⊢ Iff (Eq (PrimeSpectrum.zeroLocus ↑I) (PrimeSpectrum.zeroLocus ↑J)) (Eq I.radical J.radical)","decl":"theorem zeroLocus_eq_iff {I J : Ideal R} :\n    zeroLocus (I : Set R) = zeroLocus J ↔ I.radical = J.radical := by\n  constructor\n  · intro h; simp_rw [← vanishingIdeal_zeroLocus_eq_radical, h]\n  · intro h; rw [← zeroLocus_radical, h, zeroLocus_radical]\n\n"}
{"name":"PrimeSpectrum.vanishingIdeal_anti_mono_iff","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommSemiring R\ns t : Set (PrimeSpectrum R)\nht : IsClosed t\n⊢ Iff (HasSubset.Subset s t) (LE.le (PrimeSpectrum.vanishingIdeal t) (PrimeSpectrum.vanishingIdeal s))","decl":"theorem vanishingIdeal_anti_mono_iff {s t : Set (PrimeSpectrum R)} (ht : IsClosed t) :\n    s ⊆ t ↔ vanishingIdeal t ≤ vanishingIdeal s :=\n  ⟨vanishingIdeal_anti_mono, fun h => by\n    rw [← ht.closure_subset_iff, ← ht.closure_eq]\n    convert ← zeroLocus_anti_mono_ideal h <;> apply zeroLocus_vanishingIdeal_eq_closure⟩\n\n"}
{"name":"PrimeSpectrum.vanishingIdeal_strict_anti_mono_iff","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommSemiring R\ns t : Set (PrimeSpectrum R)\nhs : IsClosed s\nht : IsClosed t\n⊢ Iff (HasSSubset.SSubset s t) (LT.lt (PrimeSpectrum.vanishingIdeal t) (PrimeSpectrum.vanishingIdeal s))","decl":"theorem vanishingIdeal_strict_anti_mono_iff {s t : Set (PrimeSpectrum R)} (hs : IsClosed s)\n    (ht : IsClosed t) : s ⊂ t ↔ vanishingIdeal t < vanishingIdeal s := by\n  rw [Set.ssubset_def, vanishingIdeal_anti_mono_iff hs, vanishingIdeal_anti_mono_iff ht,\n    lt_iff_le_not_le]\n\n"}
{"name":"PrimeSpectrum.t1Space_iff_isField","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝¹ : CommSemiring R\ninst✝ : IsDomain R\n⊢ Iff (T1Space (PrimeSpectrum R)) (IsField R)","decl":"theorem t1Space_iff_isField [IsDomain R] : T1Space (PrimeSpectrum R) ↔ IsField R := by\n  refine ⟨?_, fun h => ?_⟩\n  · intro h\n    have hbot : Ideal.IsPrime (⊥ : Ideal R) := Ideal.bot_prime\n    exact\n      Classical.not_not.1\n        (mt\n          (Ring.ne_bot_of_isMaximal_of_not_isField <|\n            (isClosed_singleton_iff_isMaximal _).1 (T1Space.t1 ⟨⊥, hbot⟩))\n          (by simp))\n  · refine ⟨fun x => (isClosed_singleton_iff_isMaximal x).2 ?_⟩\n    by_cases hx : x.asIdeal = ⊥\n    · letI := h.toSemifield\n      exact hx.symm ▸ Ideal.bot_isMaximal\n    · exact absurd h (Ring.not_isField_iff_exists_prime.2 ⟨x.asIdeal, ⟨hx, x.2⟩⟩)\n\n"}
{"name":"PrimeSpectrum.isIrreducible_zeroLocus_iff_of_radical","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI : Ideal R\nhI : I.IsRadical\n⊢ Iff (IsIrreducible (PrimeSpectrum.zeroLocus ↑I)) I.IsPrime","decl":"theorem isIrreducible_zeroLocus_iff_of_radical (I : Ideal R) (hI : I.IsRadical) :\n    IsIrreducible (zeroLocus (I : Set R)) ↔ I.IsPrime := by\n  rw [Ideal.isPrime_iff, IsIrreducible]\n  apply and_congr\n  · rw [Set.nonempty_iff_ne_empty, Ne, zeroLocus_empty_iff_eq_top]\n  · trans ∀ x y : Ideal R, Z(I) ⊆ Z(x) ∪ Z(y) → Z(I) ⊆ Z(x) ∨ Z(I) ⊆ Z(y)\n    · simp_rw [isPreirreducible_iff_isClosed_union_isClosed, isClosed_iff_zeroLocus_ideal]\n      constructor\n      · rintro h x y\n        exact h _ _ ⟨x, rfl⟩ ⟨y, rfl⟩\n      · rintro h _ _ ⟨x, rfl⟩ ⟨y, rfl⟩\n        exact h x y\n    · simp_rw [← zeroLocus_inf, subset_zeroLocus_iff_le_vanishingIdeal,\n        vanishingIdeal_zeroLocus_eq_radical, hI.radical]\n      constructor\n      · simp_rw [← SetLike.mem_coe, ← Set.singleton_subset_iff, ← Ideal.span_le, ←\n          Ideal.span_singleton_mul_span_singleton]\n        refine fun h x y h' => h _ _ ?_\n        rw [← hI.radical_le_iff] at h' ⊢\n        simpa only [Ideal.radical_inf, Ideal.radical_mul] using h'\n      · simp_rw [or_iff_not_imp_left, SetLike.not_le_iff_exists]\n        rintro h s t h' ⟨x, hx, hx'⟩ y hy\n        exact h (h' ⟨Ideal.mul_mem_right _ _ hx, Ideal.mul_mem_left _ _ hy⟩) hx'\n\n"}
{"name":"PrimeSpectrum.isIrreducible_zeroLocus_iff","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI : Ideal R\n⊢ Iff (IsIrreducible (PrimeSpectrum.zeroLocus ↑I)) I.radical.IsPrime","decl":"theorem isIrreducible_zeroLocus_iff (I : Ideal R) :\n    IsIrreducible (zeroLocus (I : Set R)) ↔ I.radical.IsPrime :=\n  zeroLocus_radical I ▸ isIrreducible_zeroLocus_iff_of_radical _ I.radical_isRadical\n\n"}
{"name":"PrimeSpectrum.isIrreducible_iff_vanishingIdeal_isPrime","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommSemiring R\ns : Set (PrimeSpectrum R)\n⊢ Iff (IsIrreducible s) (PrimeSpectrum.vanishingIdeal s).IsPrime","decl":"theorem isIrreducible_iff_vanishingIdeal_isPrime {s : Set (PrimeSpectrum R)} :\n    IsIrreducible s ↔ (vanishingIdeal s).IsPrime := by\n  rw [← isIrreducible_iff_closure, ← zeroLocus_vanishingIdeal_eq_closure,\n    isIrreducible_zeroLocus_iff_of_radical _ (isRadical_vanishingIdeal s)]\n\n"}
{"name":"PrimeSpectrum.vanishingIdeal_isIrreducible","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommSemiring R\n⊢ Eq (Set.image PrimeSpectrum.vanishingIdeal (setOf fun s => IsIrreducible s)) (setOf fun P => P.IsPrime)","decl":"lemma vanishingIdeal_isIrreducible :\n    vanishingIdeal (R := R) '' {s | IsIrreducible s} = {P | P.IsPrime} :=\n  Set.ext fun I ↦ ⟨fun ⟨_, hs, e⟩ ↦ e ▸ isIrreducible_iff_vanishingIdeal_isPrime.mp hs,\n    fun h ↦ ⟨zeroLocus I, (isIrreducible_zeroLocus_iff_of_radical _ h.isRadical).mpr h,\n      (vanishingIdeal_zeroLocus_eq_radical I).trans h.radical⟩⟩\n\n"}
{"name":"PrimeSpectrum.vanishingIdeal_isClosed_isIrreducible","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommSemiring R\n⊢ Eq (Set.image PrimeSpectrum.vanishingIdeal (setOf fun s => And (IsClosed s) (IsIrreducible s))) (setOf fun P => P.IsPrime)","decl":"lemma vanishingIdeal_isClosed_isIrreducible :\n    vanishingIdeal (R := R) '' {s | IsClosed s ∧ IsIrreducible s} = {P | P.IsPrime} := by\n  refine (subset_antisymm ?_ ?_).trans vanishingIdeal_isIrreducible\n  · exact Set.image_subset _ fun _ ↦ And.right\n  rintro _ ⟨s, hs, rfl⟩\n  exact ⟨closure s, ⟨isClosed_closure, hs.closure⟩, vanishingIdeal_closure s⟩\n\n"}
{"name":"PrimeSpectrum.irreducibleSpace","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝¹ : CommSemiring R\ninst✝ : IsDomain R\n⊢ IrreducibleSpace (PrimeSpectrum R)","decl":"instance irreducibleSpace [IsDomain R] : IrreducibleSpace (PrimeSpectrum R) := by\n  rw [irreducibleSpace_def, Set.top_eq_univ, ← zeroLocus_bot, isIrreducible_zeroLocus_iff]\n  simpa using Ideal.bot_prime\n\n"}
{"name":"PrimeSpectrum.quasiSober","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommSemiring R\n⊢ QuasiSober (PrimeSpectrum R)","decl":"instance quasiSober : QuasiSober (PrimeSpectrum R) :=\n  ⟨fun {S} h₁ h₂ =>\n    ⟨⟨_, isIrreducible_iff_vanishingIdeal_isPrime.1 h₁⟩, by\n      rw [IsGenericPoint, closure_singleton, zeroLocus_vanishingIdeal_eq_closure, h₂.closure_eq]⟩⟩\n\n"}
{"name":"PrimeSpectrum.compactSpace","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommSemiring R\n⊢ CompactSpace (PrimeSpectrum R)","decl":"/-- The prime spectrum of a commutative (semi)ring is a compact topological space. -/\ninstance compactSpace : CompactSpace (PrimeSpectrum R) := by\n  refine compactSpace_of_finite_subfamily_closed fun S S_closed S_empty ↦ ?_\n  choose I hI using fun i ↦ (isClosed_iff_zeroLocus_ideal (S i)).mp (S_closed i)\n  simp_rw [hI, ← zeroLocus_iSup, zeroLocus_empty_iff_eq_top, ← top_le_iff] at S_empty ⊢\n  exact Ideal.isCompactElement_top.exists_finset_of_le_iSup _ _ S_empty\n\n"}
{"name":"PrimeSpectrum.discreteTopology_iff_finite_and_isPrime_imp_isMaximal","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommSemiring R\n⊢ Iff (DiscreteTopology (PrimeSpectrum R)) (And (Finite (PrimeSpectrum R)) (∀ (I : Ideal R), I.IsPrime → I.IsMaximal))","decl":"/-- The prime spectrum of a semiring has discrete Zariski topology iff it is finite and\nall primes are maximal. -/\ntheorem discreteTopology_iff_finite_and_isPrime_imp_isMaximal : DiscreteTopology (PrimeSpectrum R) ↔\n    Finite (PrimeSpectrum R) ∧ ∀ I : Ideal R, I.IsPrime → I.IsMaximal :=\n  ⟨fun _ ↦ ⟨finite_of_compact_of_discrete, fun I hI ↦ (isClosed_singleton_iff_isMaximal ⟨I, hI⟩).mp\n    <| discreteTopology_iff_forall_isClosed.mp ‹_› _⟩, fun ⟨_, h⟩ ↦ .of_finite_of_isClosed_singleton\n    fun p ↦ (isClosed_singleton_iff_isMaximal p).mpr <| h _ p.2⟩\n\n"}
{"name":"PrimeSpectrum.discreteTopology_iff_finite_isMaximal_and_sInf_le_nilradical","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommSemiring R\n⊢ Iff (DiscreteTopology (PrimeSpectrum R)) (And (Finite ↑(setOf fun I => I.IsMaximal)) (LE.le (InfSet.sInf (setOf fun I => I.IsMaximal)) (nilradical R)))","decl":"/-- The prime spectrum of a semiring has discrete Zariski topology iff there are only\nfinitely many maximal ideals and their intersection is contained in the nilradical. -/\ntheorem discreteTopology_iff_finite_isMaximal_and_sInf_le_nilradical :\n    letI s := {I : Ideal R | I.IsMaximal}\n    DiscreteTopology (PrimeSpectrum R) ↔ Finite s ∧ sInf s ≤ nilradical R :=\n  discreteTopology_iff_finite_and_isPrime_imp_isMaximal.trans <| by\n    rw [(equivSubtype R).finite_iff, ← Set.coe_setOf, Set.finite_coe_iff, Set.finite_coe_iff]\n    refine ⟨fun h ↦ ⟨h.1.subset fun _ h ↦ h.isPrime, nilradical_eq_sInf R ▸ sInf_le_sInf h.2⟩,\n      fun ⟨fin, le⟩ ↦ ?_⟩\n    have hpm (I : Ideal R) (hI : I.IsPrime): I.IsMaximal := by\n      replace le := le.trans (nilradical_le_prime I)\n      rw [← fin.coe_toFinset, ← Finset.inf_id_eq_sInf, hI.inf_le'] at le\n      have ⟨M, hM, hMI⟩ := le\n      rw [fin.mem_toFinset] at hM\n      rwa [← hM.eq_of_le hI.1 hMI]\n    exact ⟨fin.subset hpm, hpm⟩\n\n"}
{"name":"PrimeSpectrum.discreteTopology_of_toLocalization_surjective","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nsurj : Function.Surjective ⇑(PrimeSpectrum.toPiLocalization R)\n⊢ DiscreteTopology (PrimeSpectrum R)","decl":"theorem discreteTopology_of_toLocalization_surjective\n    (surj : Function.Surjective (toPiLocalization R)) :\n    DiscreteTopology (PrimeSpectrum R) :=\n  discreteTopology_iff_finite_and_isPrime_imp_isMaximal.mpr ⟨finite_of_toPiLocalization_surjective\n    surj, fun I prime ↦ isMaximal_of_toPiLocalization_surjective surj ⟨I, prime⟩⟩\n\n"}
{"name":"PrimeSpectrum.coe_comap","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S\nf : RingHom R S\n⊢ Eq (⇑(PrimeSpectrum.comap f)) f.specComap","decl":"lemma coe_comap (f : R →+* S) : comap f = f.specComap := rfl\n\n"}
{"name":"PrimeSpectrum.comap_apply","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S\nf : RingHom R S\nx : PrimeSpectrum S\n⊢ Eq ((PrimeSpectrum.comap f) x) (f.specComap x)","decl":"lemma comap_apply (f : R →+* S) (x) : comap f x = f.specComap x := rfl\n\n"}
{"name":"PrimeSpectrum.comap_asIdeal","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S\nf : RingHom R S\ny : PrimeSpectrum S\n⊢ Eq ((PrimeSpectrum.comap f) y).asIdeal (Ideal.comap f y.asIdeal)","decl":"@[simp]\ntheorem comap_asIdeal (y : PrimeSpectrum S) : (comap f y).asIdeal = Ideal.comap f y.asIdeal :=\n  rfl\n\n"}
{"name":"PrimeSpectrum.comap_id","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommSemiring R\n⊢ Eq (PrimeSpectrum.comap (RingHom.id R)) (ContinuousMap.id (PrimeSpectrum R))","decl":"@[simp]\ntheorem comap_id : comap (RingHom.id R) = ContinuousMap.id _ := by\n  ext\n  rfl\n\n"}
{"name":"PrimeSpectrum.comap_comp","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S\nS' : Type u_1\ninst✝ : CommSemiring S'\nf : RingHom R S\ng : RingHom S S'\n⊢ Eq (PrimeSpectrum.comap (g.comp f)) ((PrimeSpectrum.comap f).comp (PrimeSpectrum.comap g))","decl":"@[simp]\ntheorem comap_comp (f : R →+* S) (g : S →+* S') : comap (g.comp f) = (comap f).comp (comap g) :=\n  rfl\n\n"}
{"name":"PrimeSpectrum.comap_comp_apply","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S\nS' : Type u_1\ninst✝ : CommSemiring S'\nf : RingHom R S\ng : RingHom S S'\nx : PrimeSpectrum S'\n⊢ Eq ((PrimeSpectrum.comap (g.comp f)) x) ((PrimeSpectrum.comap f) ((PrimeSpectrum.comap g) x))","decl":"theorem comap_comp_apply (f : R →+* S) (g : S →+* S') (x : PrimeSpectrum S') :\n    PrimeSpectrum.comap (g.comp f) x = (PrimeSpectrum.comap f) (PrimeSpectrum.comap g x) :=\n  rfl\n\n"}
{"name":"PrimeSpectrum.preimage_comap_zeroLocus","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S\nf : RingHom R S\ns : Set R\n⊢ Eq (Set.preimage (⇑(PrimeSpectrum.comap f)) (PrimeSpectrum.zeroLocus s)) (PrimeSpectrum.zeroLocus (Set.image (⇑f) s))","decl":"@[simp]\ntheorem preimage_comap_zeroLocus (s : Set R) : comap f ⁻¹' zeroLocus s = zeroLocus (f '' s) :=\n  preimage_specComap_zeroLocus_aux f s\n\n"}
{"name":"PrimeSpectrum.comap_injective_of_surjective","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S\nf : RingHom R S\nhf : Function.Surjective ⇑f\n⊢ Function.Injective ⇑(PrimeSpectrum.comap f)","decl":"theorem comap_injective_of_surjective (f : R →+* S) (hf : Function.Surjective f) :\n    Function.Injective (comap f) := fun _ _ h => specComap_injective_of_surjective _ hf h\n\n"}
{"name":"PrimeSpectrum.localization_specComap_injective","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommSemiring R\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\nM : Submonoid R\ninst✝ : IsLocalization M S\n⊢ Function.Injective (algebraMap R S).specComap","decl":"theorem localization_specComap_injective [Algebra R S] (M : Submonoid R) [IsLocalization M S] :\n    Function.Injective (algebraMap R S).specComap := by\n  intro p q h\n  replace h := _root_.congr_arg (fun x : PrimeSpectrum R => Ideal.map (algebraMap R S) x.asIdeal) h\n  dsimp only [RingHom.specComap] at h\n  rw [IsLocalization.map_comap M S, IsLocalization.map_comap M S] at h\n  ext1\n  exact h\n\n"}
{"name":"PrimeSpectrum.localization_specComap_range","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommSemiring R\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\nM : Submonoid R\ninst✝ : IsLocalization M S\n⊢ Eq (Set.range (algebraMap R S).specComap) (setOf fun p => Disjoint ↑M ↑p.asIdeal)","decl":"theorem localization_specComap_range [Algebra R S] (M : Submonoid R) [IsLocalization M S] :\n    Set.range (algebraMap R S).specComap = { p | Disjoint (M : Set R) p.asIdeal } := by\n  ext x\n  constructor\n  · simp_rw [disjoint_iff_inf_le]\n    rintro ⟨p, rfl⟩ x ⟨hx₁, hx₂⟩\n    exact (p.2.1 : ¬_) (p.asIdeal.eq_top_of_isUnit_mem hx₂ (IsLocalization.map_units S ⟨x, hx₁⟩))\n  · intro h\n    use ⟨x.asIdeal.map (algebraMap R S), IsLocalization.isPrime_of_isPrime_disjoint M S _ x.2 h⟩\n    ext1\n    exact IsLocalization.comap_map_of_isPrime_disjoint M S _ x.2 h\n\n"}
{"name":"PrimeSpectrum.localization_comap_isInducing","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommSemiring R\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\nM : Submonoid R\ninst✝ : IsLocalization M S\n⊢ Topology.IsInducing ⇑(PrimeSpectrum.comap (algebraMap R S))","decl":"theorem localization_comap_isInducing [Algebra R S] (M : Submonoid R) [IsLocalization M S] :\n    IsInducing (comap (algebraMap R S)) := by\n  refine ⟨TopologicalSpace.ext_isClosed fun Z ↦ ?_⟩\n  simp_rw [isClosed_induced_iff, isClosed_iff_zeroLocus, @eq_comm _ _ (zeroLocus _),\n    exists_exists_eq_and, preimage_comap_zeroLocus]\n  constructor\n  · rintro ⟨s, rfl⟩\n    refine ⟨(Ideal.span s).comap (algebraMap R S), ?_⟩\n    rw [← zeroLocus_span, ← zeroLocus_span s, ← Ideal.map, IsLocalization.map_comap M S]\n  · rintro ⟨s, rfl⟩\n    exact ⟨_, rfl⟩\n\n"}
{"name":"PrimeSpectrum.localization_comap_inducing","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommSemiring R\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\nM : Submonoid R\ninst✝ : IsLocalization M S\n⊢ Topology.IsInducing ⇑(PrimeSpectrum.comap (algebraMap R S))","decl":"@[deprecated (since := \"2024-10-28\")]\nalias localization_comap_inducing := localization_comap_isInducing\n\n"}
{"name":"PrimeSpectrum.localization_comap_injective","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommSemiring R\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\nM : Submonoid R\ninst✝ : IsLocalization M S\n⊢ Function.Injective ⇑(PrimeSpectrum.comap (algebraMap R S))","decl":"theorem localization_comap_injective [Algebra R S] (M : Submonoid R) [IsLocalization M S] :\n    Function.Injective (comap (algebraMap R S)) :=\n  fun _ _ h => localization_specComap_injective S M h\n\n"}
{"name":"PrimeSpectrum.localization_comap_isEmbedding","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommSemiring R\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\nM : Submonoid R\ninst✝ : IsLocalization M S\n⊢ Topology.IsEmbedding ⇑(PrimeSpectrum.comap (algebraMap R S))","decl":"theorem localization_comap_isEmbedding [Algebra R S] (M : Submonoid R) [IsLocalization M S] :\n    IsEmbedding (comap (algebraMap R S)) :=\n  ⟨localization_comap_isInducing S M, localization_comap_injective S M⟩\n\n"}
{"name":"PrimeSpectrum.localization_comap_embedding","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommSemiring R\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\nM : Submonoid R\ninst✝ : IsLocalization M S\n⊢ Topology.IsEmbedding ⇑(PrimeSpectrum.comap (algebraMap R S))","decl":"@[deprecated (since := \"2024-10-26\")]\nalias localization_comap_embedding := localization_comap_isEmbedding\n\n"}
{"name":"PrimeSpectrum.localization_comap_range","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommSemiring R\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\nM : Submonoid R\ninst✝ : IsLocalization M S\n⊢ Eq (Set.range ⇑(PrimeSpectrum.comap (algebraMap R S))) (setOf fun p => Disjoint ↑M ↑p.asIdeal)","decl":"theorem localization_comap_range [Algebra R S] (M : Submonoid R) [IsLocalization M S] :\n    Set.range (comap (algebraMap R S)) = { p | Disjoint (M : Set R) p.asIdeal } :=\n  localization_specComap_range ..\n\n"}
{"name":"PrimeSpectrum.comap_isInducing_of_surjective","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S\nf : RingHom R S\nhf : Function.Surjective ⇑f\n⊢ Topology.IsInducing ⇑(PrimeSpectrum.comap f)","decl":"theorem comap_isInducing_of_surjective (hf : Surjective f) : IsInducing (comap f) where\n  eq_induced := by\n    simp only [TopologicalSpace.ext_iff, ← isClosed_compl_iff, isClosed_iff_zeroLocus,\n      isClosed_induced_iff]\n    refine fun s =>\n      ⟨fun ⟨F, hF⟩ =>\n        ⟨zeroLocus (f ⁻¹' F), ⟨f ⁻¹' F, rfl⟩, by\n          rw [preimage_comap_zeroLocus, Function.Surjective.image_preimage hf, hF]⟩,\n        ?_⟩\n    rintro ⟨-, ⟨F, rfl⟩, hF⟩\n    exact ⟨f '' F, hF.symm.trans (preimage_comap_zeroLocus f F)⟩\n\n"}
{"name":"PrimeSpectrum.comap_inducing_of_surjective","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S\nf : RingHom R S\nhf : Function.Surjective ⇑f\n⊢ Topology.IsInducing ⇑(PrimeSpectrum.comap f)","decl":"@[deprecated (since := \"2024-10-28\")]\nalias comap_inducing_of_surjective := comap_isInducing_of_surjective\n\n"}
{"name":"PrimeSpectrum.comap_singleton_isClosed_of_surjective","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nf : RingHom R S\nhf : Function.Surjective ⇑f\nx : PrimeSpectrum S\nhx : IsClosed (Singleton.singleton x)\n⊢ IsClosed (Singleton.singleton ((PrimeSpectrum.comap f) x))","decl":"theorem comap_singleton_isClosed_of_surjective (f : R →+* S) (hf : Function.Surjective f)\n    (x : PrimeSpectrum S) (hx : IsClosed ({x} : Set (PrimeSpectrum S))) :\n    IsClosed ({comap f x} : Set (PrimeSpectrum R)) :=\n  haveI : x.asIdeal.IsMaximal := (isClosed_singleton_iff_isMaximal x).1 hx\n  (isClosed_singleton_iff_isMaximal _).2 (Ideal.comap_isMaximal_of_surjective f hf)\n\n"}
{"name":"PrimeSpectrum.image_comap_zeroLocus_eq_zeroLocus_comap","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nf : RingHom R S\nhf : Function.Surjective ⇑f\nI : Ideal S\n⊢ Eq (Set.image (⇑(PrimeSpectrum.comap f)) (PrimeSpectrum.zeroLocus ↑I)) (PrimeSpectrum.zeroLocus ↑(Ideal.comap f I))","decl":"theorem image_comap_zeroLocus_eq_zeroLocus_comap (hf : Surjective f) (I : Ideal S) :\n    comap f '' zeroLocus I = zeroLocus (I.comap f) :=\n  image_specComap_zeroLocus_eq_zeroLocus_comap _ f hf I\n\n"}
{"name":"PrimeSpectrum.range_comap_of_surjective","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nf : RingHom R S\nhf : Function.Surjective ⇑f\n⊢ Eq (Set.range ⇑(PrimeSpectrum.comap f)) (PrimeSpectrum.zeroLocus ↑(RingHom.ker f))","decl":"theorem range_comap_of_surjective (hf : Surjective f) :\n    Set.range (comap f) = zeroLocus (ker f) :=\n  range_specComap_of_surjective _ f hf\n\n"}
{"name":"PrimeSpectrum.isClosed_range_comap_of_surjective","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nf : RingHom R S\nhf : Function.Surjective ⇑f\n⊢ IsClosed (Set.range ⇑(PrimeSpectrum.comap f))","decl":"theorem isClosed_range_comap_of_surjective (hf : Surjective f) :\n    IsClosed (Set.range (comap f)) := by\n  rw [range_comap_of_surjective _ f hf]\n  exact isClosed_zeroLocus _\n\n"}
{"name":"PrimeSpectrum.isClosedEmbedding_comap_of_surjective","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nf : RingHom R S\nhf : Function.Surjective ⇑f\n⊢ Topology.IsClosedEmbedding ⇑(PrimeSpectrum.comap f)","decl":"lemma isClosedEmbedding_comap_of_surjective (hf : Surjective f) : IsClosedEmbedding (comap f) where\n  toIsInducing := comap_isInducing_of_surjective S f hf\n  injective := comap_injective_of_surjective f hf\n  isClosed_range := isClosed_range_comap_of_surjective S f hf\n\n"}
{"name":"PrimeSpectrum.closedEmbedding_comap_of_surjective","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nf : RingHom R S\nhf : Function.Surjective ⇑f\n⊢ Topology.IsClosedEmbedding ⇑(PrimeSpectrum.comap f)","decl":"@[deprecated (since := \"2024-10-20\")]\nalias closedEmbedding_comap_of_surjective := isClosedEmbedding_comap_of_surjective\n\n"}
{"name":"PrimeSpectrum.primeSpectrumProd_symm_inl","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nx : PrimeSpectrum R\n⊢ Eq ((PrimeSpectrum.primeSpectrumProd R S).symm (Sum.inl x)) ((PrimeSpectrum.comap (RingHom.fst R S)) x)","decl":"lemma primeSpectrumProd_symm_inl (x) :\n    (primeSpectrumProd R S).symm (.inl x) = comap (RingHom.fst R S) x := by\n  ext; simp [Ideal.prod]\n\n"}
{"name":"PrimeSpectrum.primeSpectrumProd_symm_inr","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nx : PrimeSpectrum S\n⊢ Eq ((PrimeSpectrum.primeSpectrumProd R S).symm (Sum.inr x)) ((PrimeSpectrum.comap (RingHom.snd R S)) x)","decl":"lemma primeSpectrumProd_symm_inr (x) :\n    (primeSpectrumProd R S).symm (.inr x) = comap (RingHom.snd R S) x := by\n  ext; simp [Ideal.prod]\n\n"}
{"name":"PrimeSpectrum.mem_basicOpen","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nf : R\nx : PrimeSpectrum R\n⊢ Iff (Membership.mem (PrimeSpectrum.basicOpen f) x) (Not (Membership.mem x.asIdeal f))","decl":"@[simp]\ntheorem mem_basicOpen (f : R) (x : PrimeSpectrum R) : x ∈ basicOpen f ↔ f ∉ x.asIdeal :=\n  Iff.rfl\n\n"}
{"name":"PrimeSpectrum.isOpen_basicOpen","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommSemiring R\na : R\n⊢ IsOpen ↑(PrimeSpectrum.basicOpen a)","decl":"theorem isOpen_basicOpen {a : R} : IsOpen (basicOpen a : Set (PrimeSpectrum R)) :=\n  (basicOpen a).isOpen\n\n"}
{"name":"PrimeSpectrum.basicOpen_eq_zeroLocus_compl","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nr : R\n⊢ Eq (↑(PrimeSpectrum.basicOpen r)) (HasCompl.compl (PrimeSpectrum.zeroLocus (Singleton.singleton r)))","decl":"@[simp]\ntheorem basicOpen_eq_zeroLocus_compl (r : R) :\n    (basicOpen r : Set (PrimeSpectrum R)) = (zeroLocus {r})ᶜ :=\n  Set.ext fun x => by simp only [SetLike.mem_coe, mem_basicOpen, Set.mem_compl_iff, mem_zeroLocus,\n    Set.singleton_subset_iff]\n\n"}
{"name":"PrimeSpectrum.basicOpen_one","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommSemiring R\n⊢ Eq (PrimeSpectrum.basicOpen 1) Top.top","decl":"@[simp]\ntheorem basicOpen_one : basicOpen (1 : R) = ⊤ :=\n  TopologicalSpace.Opens.ext <| by simp\n\n"}
{"name":"PrimeSpectrum.basicOpen_zero","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommSemiring R\n⊢ Eq (PrimeSpectrum.basicOpen 0) Bot.bot","decl":"@[simp]\ntheorem basicOpen_zero : basicOpen (0 : R) = ⊥ :=\n  TopologicalSpace.Opens.ext <| by simp\n\n"}
{"name":"PrimeSpectrum.basicOpen_le_basicOpen_iff","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nf g : R\n⊢ Iff (LE.le (PrimeSpectrum.basicOpen f) (PrimeSpectrum.basicOpen g)) (Membership.mem (Ideal.span (Singleton.singleton g)).radical f)","decl":"theorem basicOpen_le_basicOpen_iff (f g : R) :\n    basicOpen f ≤ basicOpen g ↔ f ∈ (Ideal.span ({g} : Set R)).radical := by\n  rw [← SetLike.coe_subset_coe, basicOpen_eq_zeroLocus_compl, basicOpen_eq_zeroLocus_compl,\n    Set.compl_subset_compl, zeroLocus_subset_zeroLocus_singleton_iff]\n\n"}
{"name":"PrimeSpectrum.basicOpen_mul","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nf g : R\n⊢ Eq (PrimeSpectrum.basicOpen (HMul.hMul f g)) (Min.min (PrimeSpectrum.basicOpen f) (PrimeSpectrum.basicOpen g))","decl":"theorem basicOpen_mul (f g : R) : basicOpen (f * g) = basicOpen f ⊓ basicOpen g :=\n  TopologicalSpace.Opens.ext <| by simp [zeroLocus_singleton_mul]\n\n"}
{"name":"PrimeSpectrum.basicOpen_mul_le_left","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nf g : R\n⊢ LE.le (PrimeSpectrum.basicOpen (HMul.hMul f g)) (PrimeSpectrum.basicOpen f)","decl":"theorem basicOpen_mul_le_left (f g : R) : basicOpen (f * g) ≤ basicOpen f := by\n  rw [basicOpen_mul f g]\n  exact inf_le_left\n\n"}
{"name":"PrimeSpectrum.basicOpen_mul_le_right","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nf g : R\n⊢ LE.le (PrimeSpectrum.basicOpen (HMul.hMul f g)) (PrimeSpectrum.basicOpen g)","decl":"theorem basicOpen_mul_le_right (f g : R) : basicOpen (f * g) ≤ basicOpen g := by\n  rw [basicOpen_mul f g]\n  exact inf_le_right\n\n"}
{"name":"PrimeSpectrum.basicOpen_pow","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nf : R\nn : Nat\nhn : LT.lt 0 n\n⊢ Eq (PrimeSpectrum.basicOpen (HPow.hPow f n)) (PrimeSpectrum.basicOpen f)","decl":"@[simp]\ntheorem basicOpen_pow (f : R) (n : ℕ) (hn : 0 < n) : basicOpen (f ^ n) = basicOpen f :=\n  TopologicalSpace.Opens.ext <| by simpa using zeroLocus_singleton_pow f n hn\n\n"}
{"name":"PrimeSpectrum.isTopologicalBasis_basic_opens","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommSemiring R\n⊢ TopologicalSpace.IsTopologicalBasis (Set.range fun r => ↑(PrimeSpectrum.basicOpen r))","decl":"theorem isTopologicalBasis_basic_opens :\n    TopologicalSpace.IsTopologicalBasis\n      (Set.range fun r : R => (basicOpen r : Set (PrimeSpectrum R))) := by\n  apply TopologicalSpace.isTopologicalBasis_of_isOpen_of_nhds\n  · rintro _ ⟨r, rfl⟩\n    exact isOpen_basicOpen\n  · rintro p U hp ⟨s, hs⟩\n    rw [← compl_compl U, Set.mem_compl_iff, ← hs, mem_zeroLocus, Set.not_subset] at hp\n    obtain ⟨f, hfs, hfp⟩ := hp\n    refine ⟨basicOpen f, ⟨f, rfl⟩, hfp, ?_⟩\n    rw [← Set.compl_subset_compl, ← hs, basicOpen_eq_zeroLocus_compl, compl_compl]\n    exact zeroLocus_anti_mono (Set.singleton_subset_iff.mpr hfs)\n\n"}
{"name":"PrimeSpectrum.isBasis_basic_opens","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommSemiring R\n⊢ TopologicalSpace.Opens.IsBasis (Set.range PrimeSpectrum.basicOpen)","decl":"theorem isBasis_basic_opens : TopologicalSpace.Opens.IsBasis (Set.range (@basicOpen R _)) := by\n  unfold TopologicalSpace.Opens.IsBasis\n  convert isTopologicalBasis_basic_opens (R := R)\n  rw [← Set.range_comp]\n  rfl\n\n"}
{"name":"PrimeSpectrum.basicOpen_eq_bot_iff","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nf : R\n⊢ Iff (Eq (PrimeSpectrum.basicOpen f) Bot.bot) (IsNilpotent f)","decl":"@[simp]\ntheorem basicOpen_eq_bot_iff (f : R) : basicOpen f = ⊥ ↔ IsNilpotent f := by\n  rw [← TopologicalSpace.Opens.coe_inj, basicOpen_eq_zeroLocus_compl]\n  simp only [Set.eq_univ_iff_forall, Set.singleton_subset_iff, TopologicalSpace.Opens.coe_bot,\n    nilpotent_iff_mem_prime, Set.compl_empty_iff, mem_zeroLocus, SetLike.mem_coe]\n  exact ⟨fun h I hI => h ⟨I, hI⟩, fun h ⟨I, hI⟩ => h I hI⟩\n\n"}
{"name":"PrimeSpectrum.localization_away_comap_range","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝³ : CommSemiring R\nS : Type v\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\nr : R\ninst✝ : IsLocalization.Away r S\n⊢ Eq (Set.range ⇑(PrimeSpectrum.comap (algebraMap R S))) ↑(PrimeSpectrum.basicOpen r)","decl":"theorem localization_away_comap_range (S : Type v) [CommSemiring S] [Algebra R S] (r : R)\n    [IsLocalization.Away r S] : Set.range (comap (algebraMap R S)) = basicOpen r := by\n  rw [localization_comap_range S (Submonoid.powers r)]\n  ext x\n  simp only [mem_zeroLocus, basicOpen_eq_zeroLocus_compl, SetLike.mem_coe, Set.mem_setOf_eq,\n    Set.singleton_subset_iff, Set.mem_compl_iff, disjoint_iff_inf_le]\n  constructor\n  · intro h₁ h₂\n    exact h₁ ⟨Submonoid.mem_powers r, h₂⟩\n  · rintro h₁ _ ⟨⟨n, rfl⟩, h₃⟩\n    exact h₁ (x.2.mem_of_pow_mem _ h₃)\n\n"}
{"name":"PrimeSpectrum.localization_away_isOpenEmbedding","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝³ : CommSemiring R\nS : Type v\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\nr : R\ninst✝ : IsLocalization.Away r S\n⊢ Topology.IsOpenEmbedding ⇑(PrimeSpectrum.comap (algebraMap R S))","decl":"theorem localization_away_isOpenEmbedding (S : Type v) [CommSemiring S] [Algebra R S] (r : R)\n    [IsLocalization.Away r S] : IsOpenEmbedding (comap (algebraMap R S)) where\n  toIsEmbedding := localization_comap_isEmbedding S (Submonoid.powers r)\n  isOpen_range := by\n    rw [localization_away_comap_range S r]\n    exact isOpen_basicOpen\n\n"}
{"name":"PrimeSpectrum.localization_away_openEmbedding","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝³ : CommSemiring R\nS : Type v\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\nr : R\ninst✝ : IsLocalization.Away r S\n⊢ Topology.IsOpenEmbedding ⇑(PrimeSpectrum.comap (algebraMap R S))","decl":"@[deprecated (since := \"2024-10-18\")]\nalias localization_away_openEmbedding := localization_away_isOpenEmbedding\n\n"}
{"name":"PrimeSpectrum.isCompact_basicOpen","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nf : R\n⊢ IsCompact ↑(PrimeSpectrum.basicOpen f)","decl":"theorem isCompact_basicOpen (f : R) : IsCompact (basicOpen f : Set (PrimeSpectrum R)) := by\n  rw [← localization_away_comap_range (Localization (Submonoid.powers f))]\n  exact isCompact_range (map_continuous _)\n\n"}
{"name":"PrimeSpectrum.comap_basicOpen","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S\nf : RingHom R S\nx : R\n⊢ Eq ((TopologicalSpace.Opens.comap (PrimeSpectrum.comap f)) (PrimeSpectrum.basicOpen x)) (PrimeSpectrum.basicOpen (f x))","decl":"lemma comap_basicOpen (f : R →+* S) (x : R) :\n    TopologicalSpace.Opens.comap (comap f) (basicOpen x) = basicOpen (f x) :=\n  rfl\n\n"}
{"name":"PrimeSpectrum.iSup_basicOpen_eq_top_iff","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nι : Type u_1\nf : ι → R\n⊢ Iff (Eq (iSup fun i => PrimeSpectrum.basicOpen (f i)) Top.top) (Eq (Ideal.span (Set.range f)) Top.top)","decl":"open TopologicalSpace in\nlemma iSup_basicOpen_eq_top_iff {ι : Type*} {f : ι → R} :\n    (⨆ i : ι, PrimeSpectrum.basicOpen (f i)) = ⊤ ↔ Ideal.span (Set.range f) = ⊤ := by\n  rw [SetLike.ext'_iff, Opens.coe_iSup]\n  simp only [PrimeSpectrum.basicOpen_eq_zeroLocus_compl, Opens.coe_top, ← Set.compl_iInter,\n    ← PrimeSpectrum.zeroLocus_iUnion]\n  rw [← PrimeSpectrum.zeroLocus_empty_iff_eq_top, compl_involutive.eq_iff]\n  simp only [Set.iUnion_singleton_eq_range,  Set.compl_univ, PrimeSpectrum.zeroLocus_span]\n\n"}
{"name":"PrimeSpectrum.iSup_basicOpen_eq_top_iff'","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommSemiring R\ns : Set R\n⊢ Iff (Eq (iSup fun i => iSup fun h => PrimeSpectrum.basicOpen i) Top.top) (Eq (Ideal.span s) Top.top)","decl":"lemma iSup_basicOpen_eq_top_iff' {s : Set R} :\n    (⨆ i ∈ s, PrimeSpectrum.basicOpen i) = ⊤ ↔ Ideal.span s = ⊤ := by\n  conv_rhs => rw [← Subtype.range_val (s := s), ← iSup_basicOpen_eq_top_iff]\n  simp\n\n"}
{"name":"PrimeSpectrum.isLocalization_away_iff_atPrime_of_basicOpen_eq_singleton","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S\ninst✝ : Algebra R S\nf : R\np : PrimeSpectrum R\nh : Eq (PrimeSpectrum.basicOpen f).carrier (Singleton.singleton p)\n⊢ Iff (IsLocalization.Away f S) (IsLocalization.AtPrime S p.asIdeal)","decl":"theorem isLocalization_away_iff_atPrime_of_basicOpen_eq_singleton [Algebra R S]\n    {f : R} {p : PrimeSpectrum R} (h : (basicOpen f).1 = {p}) :\n    IsLocalization.Away f S ↔ IsLocalization.AtPrime S p.1 :=\n  have : IsLocalization.AtPrime (Localization.Away f) p.1 := by\n    refine .of_le_of_exists_dvd (.powers f) _\n      (Submonoid.powers_le.mpr <| by apply h ▸ Set.mem_singleton p) fun r hr ↦ ?_\n    contrapose! hr\n    simp_rw [← Ideal.mem_span_singleton] at hr\n    have ⟨q, prime, le, disj⟩ := Ideal.exists_le_prime_disjoint (Ideal.span {r})\n      (.powers f) (Set.disjoint_right.mpr hr)\n    have : ⟨q, prime⟩ ∈ (basicOpen f).1 := Set.disjoint_right.mp disj (Submonoid.mem_powers f)\n    rw [h, Set.mem_singleton_iff] at this\n    rw [← this]\n    exact not_not.mpr (q.span_singleton_le_iff_mem.mp le)\n  IsLocalization.isLocalization_iff_of_isLocalization _ _ (Localization.Away f)\n\n"}
{"name":"PrimeSpectrum.range_comap_algebraMap_localization_compl_eq_range_comap_quotientMk","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nc : R\n⊢ Eq (HasCompl.compl (Set.range ⇑(PrimeSpectrum.comap (algebraMap (Polynomial R) (Polynomial (Localization.Away c)))))) (Set.range ⇑(PrimeSpectrum.comap (Polynomial.mapRingHom (Ideal.Quotient.mk (Ideal.span (Singleton.singleton c))))))","decl":"open Localization Polynomial Set in\nlemma range_comap_algebraMap_localization_compl_eq_range_comap_quotientMk\n    {R : Type*} [CommRing R] (c : R) :\n    letI := (mapRingHom (algebraMap R (Away c))).toAlgebra\n    (range (comap (algebraMap R[X] (Away c)[X])))ᶜ\n      = range (comap (mapRingHom (Ideal.Quotient.mk (.span {c})))) := by\n  letI := (mapRingHom (algebraMap R (Away c))).toAlgebra\n  have := Polynomial.isLocalization (.powers c) (Away c)\n  rw [Submonoid.map_powers] at this\n  have surj : Function.Surjective (mapRingHom (Ideal.Quotient.mk (.span {c}))) :=\n    Polynomial.map_surjective _ Ideal.Quotient.mk_surjective\n  rw [range_comap_of_surjective _ _ surj, localization_away_comap_range _ (C c)]\n  simp [Polynomial.ker_mapRingHom, Ideal.map_span]\n\n"}
{"name":"PrimeSpectrum.toPiLocalization_surjective_of_discreteTopology","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝¹ : CommSemiring R\ninst✝ : DiscreteTopology (PrimeSpectrum R)\n⊢ Function.Surjective ⇑(PrimeSpectrum.toPiLocalization R)","decl":"theorem toPiLocalization_surjective_of_discreteTopology :\n    Function.Surjective (toPiLocalization R) := fun x ↦ by\n  have (p : PrimeSpectrum R) : ∃ f, (basicOpen f : Set _) = {p} :=\n    have ⟨_, ⟨f, rfl⟩, hpf, hfp⟩ := isTopologicalBasis_basic_opens.isOpen_iff.mp\n      (isOpen_discrete {p}) p rfl\n    ⟨f, hfp.antisymm <| Set.singleton_subset_iff.mpr hpf⟩\n  choose f hf using this\n  let e := Equiv.ofInjective f fun p q eq ↦ Set.singleton_injective (hf p ▸ eq ▸ hf q)\n  have loc a : IsLocalization.AtPrime (Localization.Away a.1) (e.symm a).1 :=\n    (isLocalization_away_iff_atPrime_of_basicOpen_eq_singleton <| hf _).mp <| by\n      simp_rw [e, Equiv.apply_ofInjective_symm]; infer_instance\n  let algE a := IsLocalization.algEquiv (e.symm a).1.primeCompl\n    (Localization.AtPrime (e.symm a).1) (Localization.Away a.1)\n  have span_eq : Ideal.span (Set.range f) = ⊤ := iSup_basicOpen_eq_top_iff.mp <| top_unique\n    fun p _ ↦ TopologicalSpace.Opens.mem_iSup.mpr ⟨p, (hf p).ge rfl⟩\n  replace hf a : (basicOpen a.1 : Set _) = {e.symm a} := by\n    simp_rw [e, ← hf, Equiv.apply_ofInjective_symm]\n  obtain ⟨r, eq, -⟩ := Localization.existsUnique_algebraMap_eq_of_span_eq_top _ span_eq\n    (fun a ↦ algE a (x _)) fun a b ↦ by\n      obtain rfl | ne := eq_or_ne a b; · rfl\n      have ⟨n, hn⟩ : IsNilpotent (a * b : R) := (basicOpen_eq_bot_iff _).mp <| by\n        simp_rw [basicOpen_mul, SetLike.ext'_iff, TopologicalSpace.Opens.coe_inf, hf]\n        exact bot_unique (fun _ ⟨ha, hb⟩ ↦ ne <| e.symm.injective (ha.symm.trans hb))\n      have := IsLocalization.subsingleton (M := .powers (a * b : R))\n        (S := Localization.Away (a * b : R)) <| hn ▸ ⟨n, rfl⟩\n      apply Subsingleton.elim\n  refine ⟨r, funext fun I ↦ ?_⟩\n  have := eq (e I)\n  rwa [← AlgEquiv.symm_apply_eq, AlgEquiv.commutes, e.symm_apply_apply] at this\n\n"}
{"name":"PrimeSpectrum.maximalSpectrumToPiLocalization_surjective_of_discreteTopology","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝¹ : CommSemiring R\ninst✝ : DiscreteTopology (PrimeSpectrum R)\n⊢ Function.Surjective ⇑(MaximalSpectrum.toPiLocalization R)","decl":"theorem maximalSpectrumToPiLocalization_surjective_of_discreteTopology :\n    Function.Surjective (MaximalSpectrum.toPiLocalization R) := by\n  rw [← piLocalizationToMaximal_comp_toPiLocalization]\n  exact (piLocalizationToMaximal_surjective R).comp\n    (toPiLocalization_surjective_of_discreteTopology R)\n\n"}
{"name":"PrimeSpectrum.discreteTopology_iff_toPiLocalization_surjective","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\n⊢ Iff (DiscreteTopology (PrimeSpectrum R)) (Function.Surjective ⇑(PrimeSpectrum.toPiLocalization R))","decl":"theorem discreteTopology_iff_toPiLocalization_surjective {R} [CommSemiring R] :\n    DiscreteTopology (PrimeSpectrum R) ↔ Function.Surjective (toPiLocalization R) :=\n  ⟨fun _ ↦ toPiLocalization_surjective_of_discreteTopology _,\n    discreteTopology_of_toLocalization_surjective⟩\n\n"}
{"name":"PrimeSpectrum.discreteTopology_iff_toPiLocalization_bijective","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\n⊢ Iff (DiscreteTopology (PrimeSpectrum R)) (Function.Bijective ⇑(PrimeSpectrum.toPiLocalization R))","decl":"theorem discreteTopology_iff_toPiLocalization_bijective {R} [CommSemiring R] :\n    DiscreteTopology (PrimeSpectrum R) ↔ Function.Bijective (toPiLocalization R) :=\n  discreteTopology_iff_toPiLocalization_surjective.trans\n    (and_iff_right <| toPiLocalization_injective _).symm\n\n"}
{"name":"PrimeSpectrum.le_iff_mem_closure","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx y : PrimeSpectrum R\n⊢ Iff (LE.le x y) (Membership.mem (closure (Singleton.singleton x)) y)","decl":"theorem le_iff_mem_closure (x y : PrimeSpectrum R) :\n    x ≤ y ↔ y ∈ closure ({x} : Set (PrimeSpectrum R)) := by\n  rw [← asIdeal_le_asIdeal, ← zeroLocus_vanishingIdeal_eq_closure, mem_zeroLocus,\n    vanishingIdeal_singleton, SetLike.coe_subset_coe]\n\n"}
{"name":"PrimeSpectrum.le_iff_specializes","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx y : PrimeSpectrum R\n⊢ Iff (LE.le x y) (Specializes x y)","decl":"theorem le_iff_specializes (x y : PrimeSpectrum R) : x ≤ y ↔ x ⤳ y :=\n  (le_iff_mem_closure x y).trans specializes_iff_mem_closure.symm\n\n"}
{"name":"PrimeSpectrum.nhdsOrderEmbedding_apply","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx : PrimeSpectrum R\n⊢ Eq (PrimeSpectrum.nhdsOrderEmbedding x) (nhds x)","decl":"/-- `nhds` as an order embedding. -/\n@[simps!]\ndef nhdsOrderEmbedding : PrimeSpectrum R ↪o Filter (PrimeSpectrum R) :=\n  OrderEmbedding.ofMapLEIff nhds fun a b => (le_iff_specializes a b).symm\n\n"}
{"name":"PrimeSpectrum.instT0Space","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommSemiring R\n⊢ T0Space (PrimeSpectrum R)","decl":"instance : T0Space (PrimeSpectrum R) :=\n  ⟨nhdsOrderEmbedding.inj'⟩\n\n"}
{"name":"PrimeSpectrum.isClosed_range_of_stableUnderSpecialization","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nf : RingHom R S\nhf : StableUnderSpecialization (Set.range ⇑(PrimeSpectrum.comap f))\n⊢ IsClosed (Set.range ⇑(PrimeSpectrum.comap f))","decl":"lemma isClosed_range_of_stableUnderSpecialization\n    (hf : StableUnderSpecialization (Set.range (comap f))) :\n    IsClosed (Set.range (comap f)) := by\n  refine (isClosed_iff_zeroLocus _).mpr ⟨RingHom.ker f, le_antisymm ?_ ?_⟩\n  · rintro _ ⟨q, rfl⟩\n    exact Ideal.comap_mono bot_le\n  · intro p hp\n    obtain ⟨q, hq, hqle⟩ := Ideal.exists_minimalPrimes_le hp\n    obtain ⟨q', hq', hq'c⟩ := Ideal.exists_minimalPrimes_comap_eq f q hq\n    exact hf ((le_iff_specializes ⟨q, hq.1.1⟩ p).mp hqle) ⟨⟨q', hq'.1.1⟩, PrimeSpectrum.ext hq'c⟩\n\n"}
{"name":"PrimeSpectrum.isClosed_image_of_stableUnderSpecialization","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nf : RingHom R S\nZ : Set (PrimeSpectrum S)\nhZ : IsClosed Z\nhf : StableUnderSpecialization (Set.image (⇑(PrimeSpectrum.comap f)) Z)\n⊢ IsClosed (Set.image (⇑(PrimeSpectrum.comap f)) Z)","decl":"@[stacks 05JL]\nlemma isClosed_image_of_stableUnderSpecialization\n    (Z : Set (PrimeSpectrum S)) (hZ : IsClosed Z)\n    (hf : StableUnderSpecialization (comap f '' Z)) :\n    IsClosed (comap f '' Z) := by\n  obtain ⟨I, rfl⟩ := (PrimeSpectrum.isClosed_iff_zeroLocus_ideal Z).mp hZ\n  have : (comap f '' zeroLocus I) = Set.range (comap ((Ideal.Quotient.mk I).comp f)) := by\n    rw [comap_comp, ContinuousMap.coe_comp, Set.range_comp, range_comap_of_surjective, Ideal.mk_ker]\n    exact Ideal.Quotient.mk_surjective\n  rw [this] at hf ⊢\n  exact isClosed_range_of_stableUnderSpecialization _ hf\n\n"}
{"name":"PrimeSpectrum.stableUnderSpecialization_range_iff","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nf : RingHom R S\n⊢ Iff (StableUnderSpecialization (Set.range ⇑(PrimeSpectrum.comap f))) (IsClosed (Set.range ⇑(PrimeSpectrum.comap f)))","decl":"variable {f} in\n@[stacks 05JL]\nlemma stableUnderSpecialization_range_iff :\n    StableUnderSpecialization (Set.range (comap f)) ↔ IsClosed (Set.range (comap f)) :=\n  ⟨isClosed_range_of_stableUnderSpecialization f, fun h ↦ h.stableUnderSpecialization⟩\n\n"}
{"name":"PrimeSpectrum.stableUnderSpecialization_image_iff","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nf : RingHom R S\nZ : Set (PrimeSpectrum S)\nhZ : IsClosed Z\n⊢ Iff (StableUnderSpecialization (Set.image (⇑(PrimeSpectrum.comap f)) Z)) (IsClosed (Set.image (⇑(PrimeSpectrum.comap f)) Z))","decl":"lemma stableUnderSpecialization_image_iff\n    (Z : Set (PrimeSpectrum S)) (hZ : IsClosed Z) :\n    StableUnderSpecialization (comap f '' Z) ↔ IsClosed (comap f '' Z) :=\n  ⟨isClosed_image_of_stableUnderSpecialization f Z hZ, fun h ↦ h.stableUnderSpecialization⟩\n\n"}
{"name":"PrimeSpectrum.vanishingIdeal_range_comap","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nf : RingHom R S\n⊢ Eq (PrimeSpectrum.vanishingIdeal (Set.range ⇑(PrimeSpectrum.comap f))) (RingHom.ker f).radical","decl":"lemma vanishingIdeal_range_comap :\n    vanishingIdeal (Set.range (comap f)) = (RingHom.ker f).radical := by\n  ext x\n  rw [RingHom.ker_eq_comap_bot, ← Ideal.comap_radical, Ideal.radical_eq_sInf]\n  simp only [mem_vanishingIdeal, Set.mem_range, forall_exists_index, forall_apply_eq_imp_iff,\n    comap_asIdeal, Ideal.mem_comap, bot_le, true_and, Submodule.mem_sInf, Set.mem_setOf_eq]\n  exact ⟨fun H I hI ↦ H ⟨I, hI⟩, fun H I ↦ H I.1 I.2⟩\n\n"}
{"name":"PrimeSpectrum.closure_range_comap","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nf : RingHom R S\n⊢ Eq (closure (Set.range ⇑(PrimeSpectrum.comap f))) (PrimeSpectrum.zeroLocus ↑(RingHom.ker f))","decl":"lemma closure_range_comap :\n    closure (Set.range (comap f)) = zeroLocus (RingHom.ker f) := by\n  rw [← zeroLocus_vanishingIdeal_eq_closure, vanishingIdeal_range_comap, zeroLocus_radical]\n\n"}
{"name":"PrimeSpectrum.denseRange_comap_iff_ker_le_nilRadical","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nf : RingHom R S\n⊢ Iff (DenseRange ⇑(PrimeSpectrum.comap f)) (LE.le (RingHom.ker f) (nilradical R))","decl":"lemma denseRange_comap_iff_ker_le_nilRadical :\n    DenseRange (comap f) ↔ RingHom.ker f ≤ nilradical R := by\n  rw [denseRange_iff_closure_range, closure_range_comap, ← Set.top_eq_univ, zeroLocus_eq_top_iff,\n    SetLike.coe_subset_coe]\n\n"}
{"name":"PrimeSpectrum.denseRange_comap_iff_minimalPrimes","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nf : RingHom R S\n⊢ Iff (DenseRange ⇑(PrimeSpectrum.comap f)) (∀ (I : Ideal R) (h : Membership.mem (minimalPrimes R) I), Membership.mem (Set.range ⇑(PrimeSpectrum.comap f)) { asIdeal := I, isPrime := ⋯ })","decl":"@[stacks 00FL]\nlemma denseRange_comap_iff_minimalPrimes :\n    DenseRange (comap f) ↔ ∀ I (h : I ∈ minimalPrimes R), ⟨I, h.1.1⟩ ∈ Set.range (comap f) := by\n  constructor\n  · intro H I hI\n    have : I ∈ (RingHom.ker f).minimalPrimes := by\n      rw [denseRange_comap_iff_ker_le_nilRadical] at H\n      simp only [minimalPrimes, Ideal.minimalPrimes, Set.mem_setOf] at hI ⊢\n      convert hI using 2 with p\n      exact ⟨fun h ↦ ⟨h.1, bot_le⟩, fun h ↦ ⟨h.1, H.trans (h.1.radical_le_iff.mpr bot_le)⟩⟩\n    obtain ⟨p, hp, _, rfl⟩ := Ideal.exists_comap_eq_of_mem_minimalPrimes f (I := ⊥) I this\n    exact ⟨⟨p, hp⟩, rfl⟩\n  · intro H p\n    obtain ⟨q, hq, hq'⟩ := Ideal.exists_minimalPrimes_le (J := p.asIdeal) bot_le\n    exact ((le_iff_specializes ⟨q, hq.1.1⟩ p).mp hq').mem_closed isClosed_closure\n      (subset_closure (H q hq))\n\n"}
{"name":"PrimeSpectrum.isMax_iff","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx : PrimeSpectrum R\n⊢ Iff (IsMax x) x.asIdeal.IsMaximal","decl":"/-- Also see `PrimeSpectrum.isClosed_singleton_iff_isMaximal` -/\nlemma isMax_iff {x : PrimeSpectrum R} :\n    IsMax x ↔ x.asIdeal.IsMaximal := by\n  refine ⟨fun hx ↦ ⟨⟨x.2.ne_top, fun I hI ↦ ?_⟩⟩, fun hx y e ↦ (hx.eq_of_le y.2.ne_top e).ge⟩\n  by_contra e\n  obtain ⟨m, hm, hm'⟩ := Ideal.exists_le_maximal I e\n  exact hx.not_lt (show x < ⟨m, hm.isPrime⟩ from hI.trans_le hm')\n\n"}
{"name":"PrimeSpectrum.stableUnderSpecialization_singleton","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx : PrimeSpectrum R\n⊢ Iff (StableUnderSpecialization (Singleton.singleton x)) x.asIdeal.IsMaximal","decl":"lemma stableUnderSpecialization_singleton {x : PrimeSpectrum R} :\n    StableUnderSpecialization {x} ↔ x.asIdeal.IsMaximal := by\n  simp_rw [← isMax_iff, StableUnderSpecialization, ← le_iff_specializes, Set.mem_singleton_iff,\n    @forall_comm _ (_ = _), forall_eq]\n  exact ⟨fun H a h ↦ (H a h).le, fun H a h ↦ le_antisymm (H h) h⟩\n\n"}
{"name":"PrimeSpectrum.isMin_iff","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx : PrimeSpectrum R\n⊢ Iff (IsMin x) (Membership.mem (minimalPrimes R) x.asIdeal)","decl":"lemma isMin_iff {x : PrimeSpectrum R} :\n    IsMin x ↔ x.asIdeal ∈ minimalPrimes R := by\n  show IsMin _ ↔ Minimal (fun q : Ideal R ↦ q.IsPrime ∧ ⊥ ≤ q) _\n  simp only [IsMin, Minimal, x.2, bot_le, and_self, and_true, true_and]\n  exact ⟨fun H y hy e ↦ @H ⟨y, hy⟩ e, fun H y e ↦ H y.2 e⟩\n\n"}
{"name":"PrimeSpectrum.stableUnderGeneralization_singleton","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx : PrimeSpectrum R\n⊢ Iff (StableUnderGeneralization (Singleton.singleton x)) (Membership.mem (minimalPrimes R) x.asIdeal)","decl":"lemma stableUnderGeneralization_singleton {x : PrimeSpectrum R} :\n    StableUnderGeneralization {x} ↔ x.asIdeal ∈ minimalPrimes R := by\n  simp_rw [← isMin_iff, StableUnderGeneralization, ← le_iff_specializes, Set.mem_singleton_iff,\n    @forall_comm _ (_ = _), forall_eq]\n  exact ⟨fun H a h ↦ (H a h).ge, fun H a h ↦ le_antisymm h (H h)⟩\n\n"}
{"name":"PrimeSpectrum.isCompact_isOpen_iff","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommSemiring R\ns : Set (PrimeSpectrum R)\n⊢ Iff (And (IsCompact s) (IsOpen s)) (Exists fun t => Eq (HasCompl.compl (PrimeSpectrum.zeroLocus ↑t)) s)","decl":"lemma isCompact_isOpen_iff {s : Set (PrimeSpectrum R)} :\n    IsCompact s ∧ IsOpen s ↔ ∃ t : Finset R, (zeroLocus t)ᶜ = s := by\n  rw [isCompact_open_iff_eq_finite_iUnion_of_isTopologicalBasis _\n    isTopologicalBasis_basic_opens isCompact_basicOpen]\n  simp only [basicOpen_eq_zeroLocus_compl, ← Set.compl_iInter₂, ← zeroLocus_iUnion₂,\n    Set.biUnion_of_singleton]\n  exact ⟨fun ⟨s, hs, e⟩ ↦ ⟨hs.toFinset, by simpa using e.symm⟩,\n    fun ⟨s, e⟩ ↦ ⟨s, s.finite_toSet, by simpa using e.symm⟩⟩\n\n"}
{"name":"PrimeSpectrum.isCompact_isOpen_iff_ideal","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommSemiring R\ns : Set (PrimeSpectrum R)\n⊢ Iff (And (IsCompact s) (IsOpen s)) (Exists fun I => And I.FG (Eq (HasCompl.compl (PrimeSpectrum.zeroLocus ↑I)) s))","decl":"lemma isCompact_isOpen_iff_ideal {s : Set (PrimeSpectrum R)} :\n    IsCompact s ∧ IsOpen s ↔ ∃ I : Ideal R, I.FG ∧ (zeroLocus I)ᶜ = s := by\n  rw [isCompact_isOpen_iff]\n  exact ⟨fun ⟨s, e⟩ ↦ ⟨.span s, ⟨s, rfl⟩, by simpa using e⟩,\n    fun ⟨I, ⟨s, hs⟩, e⟩ ↦ ⟨s, by simpa [hs.symm] using e⟩⟩\n\n"}
{"name":"PrimeSpectrum.basicOpen_injOn_isIdempotentElem","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommSemiring R\n⊢ Set.InjOn PrimeSpectrum.basicOpen (setOf fun e => IsIdempotentElem e)","decl":"lemma basicOpen_injOn_isIdempotentElem :\n    {e : R | IsIdempotentElem e}.InjOn basicOpen := fun x hx y hy eq ↦ by\n  by_contra! ne\n  wlog ne' : x * y ≠ x generalizing x y\n  · apply this y hy x hx eq.symm ne.symm\n    rwa [mul_comm, of_not_not ne']\n  have : x ∉ Ideal.span {y} := fun mem ↦ ne' <| by\n    obtain ⟨r, rfl⟩ := Ideal.mem_span_singleton'.mp mem\n    rw [mul_assoc, hy]\n  have ⟨p, prime, le, nmem⟩ := Ideal.exists_le_prime_nmem_of_isIdempotentElem _ x hx this\n  exact ne_of_mem_of_not_mem' (a := ⟨p, prime⟩) nmem\n    (not_not.mpr <| p.span_singleton_le_iff_mem.mp le) eq\n\n"}
{"name":"PrimeSpectrum.existsUnique_idempotent_basicOpen_eq_of_isClopen","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommSemiring R\ns : Set (PrimeSpectrum R)\nhs : IsClopen s\n⊢ ExistsUnique fun e => And (IsIdempotentElem e) (Eq s ↑(PrimeSpectrum.basicOpen e))","decl":"@[stacks 00EE]\nlemma existsUnique_idempotent_basicOpen_eq_of_isClopen {s : Set (PrimeSpectrum R)}\n    (hs : IsClopen s) : ∃! e : R, IsIdempotentElem e ∧ s = basicOpen e := by\n  refine existsUnique_of_exists_of_unique ?_ ?_; swap\n  · rintro x y ⟨hx, rfl⟩ ⟨hy, eq⟩\n    exact basicOpen_injOn_isIdempotentElem hx hy (SetLike.ext' eq)\n  cases subsingleton_or_nontrivial R\n  · exact ⟨0, Subsingleton.elim _ _, Subsingleton.elim _ _⟩\n  obtain ⟨I, hI, hI'⟩ := isCompact_isOpen_iff_ideal.mp ⟨hs.1.isCompact, hs.2⟩\n  obtain ⟨J, hJ, hJ'⟩ := isCompact_isOpen_iff_ideal.mp\n    ⟨hs.2.isClosed_compl.isCompact, hs.1.isOpen_compl⟩\n  simp only [compl_eq_iff_isCompl, ← eq_compl_iff_isCompl, compl_compl] at hI' hJ'\n  have : I * J ≤ nilradical R := by\n    refine Ideal.radical_le_radical_iff.mp (le_of_eq ?_)\n    rw [← zeroLocus_eq_iff, Ideal.zero_eq_bot, zeroLocus_bot,\n      zeroLocus_mul, hI', hJ', Set.compl_union_self]\n  obtain ⟨n, hn⟩ := Ideal.exists_pow_le_of_le_radical_of_fg this (Submodule.FG.mul hI hJ)\n  have hnz : n ≠ 0 := by rintro rfl; simp at hn\n  rw [mul_pow, Ideal.zero_eq_bot] at hn\n  have : I ^ n ⊔ J ^ n = ⊤ := by\n    rw [eq_top_iff, ← Ideal.span_pow_eq_top (I ∪ J : Set R) _ n, Ideal.span_le, Set.image_union,\n      Set.union_subset_iff]\n    constructor\n    · rintro _ ⟨x, hx, rfl⟩; exact Ideal.mem_sup_left (Ideal.pow_mem_pow hx n)\n    · rintro _ ⟨x, hx, rfl⟩; exact Ideal.mem_sup_right (Ideal.pow_mem_pow hx n)\n    · rw [Ideal.span_union, Ideal.span_eq, Ideal.span_eq, ← zeroLocus_empty_iff_eq_top,\n        zeroLocus_sup, hI', hJ', Set.compl_inter_self]\n  rw [Ideal.eq_top_iff_one, Submodule.mem_sup] at this\n  obtain ⟨x, hx, y, hy, e⟩ := this\n  refine ⟨x, ?_, subset_antisymm ?_ ?_⟩\n  · replace e := congr(x * $e)\n    rwa [mul_add, hn (Ideal.mul_mem_mul hx hy), add_zero, mul_one] at e\n  · rw [PrimeSpectrum.basicOpen_eq_zeroLocus_compl, Set.subset_compl_iff_disjoint_left,\n      Set.disjoint_iff_inter_eq_empty, ← hJ', ← zeroLocus_span,\n      ← zeroLocus_sup, zeroLocus_empty_iff_eq_top,\n      Ideal.eq_top_iff_one, ← e]\n    exact Submodule.add_mem_sup (Ideal.subset_span (Set.mem_singleton _)) (Ideal.pow_le_self hnz hy)\n  · rw [PrimeSpectrum.basicOpen_eq_zeroLocus_compl, Set.compl_subset_comm, ← hI']\n    exact PrimeSpectrum.zeroLocus_anti_mono\n      (Set.singleton_subset_iff.mpr <| Ideal.pow_le_self hnz hx)\n\n"}
{"name":"PrimeSpectrum.exists_idempotent_basicOpen_eq_of_isClopen","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommSemiring R\ns : Set (PrimeSpectrum R)\nhs : IsClopen s\n⊢ Exists fun e => And (IsIdempotentElem e) (Eq s ↑(PrimeSpectrum.basicOpen e))","decl":"lemma exists_idempotent_basicOpen_eq_of_isClopen {s : Set (PrimeSpectrum R)}\n    (hs : IsClopen s) : ∃ e : R, IsIdempotentElem e ∧ s = basicOpen e :=\n  (existsUnique_idempotent_basicOpen_eq_of_isClopen hs).exists\n\n"}
{"name":"PrimeSpectrum.exists_idempotent_basicOpen_eq_of_is_clopen","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommSemiring R\ns : Set (PrimeSpectrum R)\nhs : IsClopen s\n⊢ Exists fun e => And (IsIdempotentElem e) (Eq s ↑(PrimeSpectrum.basicOpen e))","decl":"@[deprecated (since := \"2024-11-11\")]\nalias exists_idempotent_basicOpen_eq_of_is_clopen := exists_idempotent_basicOpen_eq_of_isClopen\n\n"}
{"name":"PrimeSpectrum.isClosedMap_comap_of_isIntegral","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nf : RingHom R S\nhf : f.IsIntegral\n⊢ IsClosedMap ⇑(PrimeSpectrum.comap f)","decl":"theorem isClosedMap_comap_of_isIntegral (hf : f.IsIntegral) :\n    IsClosedMap (comap f) := by\n  refine fun s hs ↦ isClosed_image_of_stableUnderSpecialization _ _ hs ?_\n  rintro _ y e ⟨x, hx, rfl⟩\n  algebraize [f]\n  obtain ⟨q, hq₁, hq₂, hq₃⟩ := Ideal.exists_ideal_over_prime_of_isIntegral y.asIdeal x.asIdeal\n    ((le_iff_specializes _ _).mpr e)\n  refine ⟨⟨q, hq₂⟩, ((le_iff_specializes _ ⟨q, hq₂⟩).mp hq₁).mem_closed hs hx,\n    PrimeSpectrum.ext hq₃⟩\n\n"}
{"name":"PrimeSpectrum.isClosed_comap_singleton_of_isIntegral","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nf : RingHom R S\nhf : f.IsIntegral\nx : PrimeSpectrum S\nhx : IsClosed (Singleton.singleton x)\n⊢ IsClosed (Singleton.singleton ((PrimeSpectrum.comap f) x))","decl":"theorem isClosed_comap_singleton_of_isIntegral (hf : f.IsIntegral)\n    (x : PrimeSpectrum S) (hx : IsClosed ({x} : Set (PrimeSpectrum S))) :\n    IsClosed ({comap f x} : Set (PrimeSpectrum R)) := by\n  simpa using isClosedMap_comap_of_isIntegral f hf _ hx\n\n"}
{"name":"PrimeSpectrum.closure_image_comap_zeroLocus","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nf : RingHom R S\nI : Ideal S\n⊢ Eq (closure (Set.image (⇑(PrimeSpectrum.comap f)) (PrimeSpectrum.zeroLocus ↑I))) (PrimeSpectrum.zeroLocus ↑(Ideal.comap f I))","decl":"lemma closure_image_comap_zeroLocus (I : Ideal S) :\n    closure (comap f '' zeroLocus I) = zeroLocus (I.comap f) := by\n  apply subset_antisymm\n  · rw [(isClosed_zeroLocus _).closure_subset_iff, Set.image_subset_iff, preimage_comap_zeroLocus]\n    exact zeroLocus_anti_mono (Set.image_preimage_subset _ _)\n  · rintro x (hx : I.comap f ≤ x.asIdeal)\n    obtain ⟨q, hq₁, hq₂⟩ := Ideal.exists_minimalPrimes_le hx\n    obtain ⟨p', hp', hp'', rfl⟩ := Ideal.exists_comap_eq_of_mem_minimalPrimes f _ hq₁\n    let p'' : PrimeSpectrum S := ⟨p', hp'⟩\n    apply isClosed_closure.stableUnderSpecialization ((le_iff_specializes\n      (comap f ⟨p', hp'⟩) x).mp hq₂) (subset_closure (by exact ⟨_, hp'', rfl⟩))\n\n"}
{"name":"PrimeSpectrum.isIntegral_of_isClosedMap_comap_mapRingHom","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nf : RingHom R S\nh : IsClosedMap ⇑(PrimeSpectrum.comap (Polynomial.mapRingHom f))\n⊢ f.IsIntegral","decl":"lemma isIntegral_of_isClosedMap_comap_mapRingHom (h : IsClosedMap (comap (mapRingHom f))) :\n    f.IsIntegral := by\n  algebraize [f]\n  suffices Algebra.IsIntegral R S by rwa [Algebra.isIntegral_def] at this\n  nontriviality R\n  nontriviality S\n  constructor\n  intro r\n  let p : S[X] := C r * X - 1\n  have : (1 : R[X]) ∈ Ideal.span {X} ⊔ (Ideal.span {p}).comap (mapRingHom f) := by\n    have H := h _ (isClosed_zeroLocus {p})\n    rw [← zeroLocus_span, ← closure_eq_iff_isClosed, closure_image_comap_zeroLocus] at H\n    rw [← Ideal.eq_top_iff_one, sup_comm, ← zeroLocus_empty_iff_eq_top, zeroLocus_sup, H]\n    suffices ∀ (a : PrimeSpectrum S[X]), p ∈ a.asIdeal → X ∉ a.asIdeal by\n      simpa [Set.eq_empty_iff_forall_not_mem]\n    intro q hpq hXq\n    have : 1 ∈ q.asIdeal := by simpa [p] using (sub_mem (q.asIdeal.mul_mem_left (C r) hXq) hpq)\n    exact q.2.ne_top (q.asIdeal.eq_top_iff_one.mpr this)\n  obtain ⟨a, b, hb, e⟩ := Ideal.mem_span_singleton_sup.mp this\n  obtain ⟨c, hc : b.map (algebraMap R S) = _⟩ := Ideal.mem_span_singleton.mp hb\n  refine ⟨b.reverse * X ^ (1 + c.natDegree), ?_, ?_⟩\n  · refine Monic.mul ?_ (by simp)\n    have h : b.coeff 0 = 1 := by simpa using congr(($e).coeff 0)\n    have : b.natTrailingDegree = 0 := by simp [h]\n    rw [Monic.def, reverse_leadingCoeff, trailingCoeff, this, h]\n  · have : p.natDegree ≤ 1 := by simpa using natDegree_linear_le (a := r) (b := -1)\n    rw [eval₂_eq_eval_map, reverse, Polynomial.map_mul, ← reflect_map, Polynomial.map_pow,\n      map_X, ← revAt_zero (1 + _), ← reflect_monomial,\n      ← reflect_mul _ _ natDegree_map_le (by simp), pow_zero, mul_one, hc,\n      ← add_assoc, reflect_mul _ _ (this.trans (by simp)) le_rfl,\n      eval_mul, reflect_sub, reflect_mul _ _ (by simp) (by simp)]\n    simp [← pow_succ']\n\n"}
{"name":"PrimeSpectrum.vanishingIdeal_irreducibleComponents","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommSemiring R\n⊢ Eq (Set.image PrimeSpectrum.vanishingIdeal (irreducibleComponents (PrimeSpectrum R))) (minimalPrimes R)","decl":"lemma vanishingIdeal_irreducibleComponents :\n    vanishingIdeal '' (irreducibleComponents <| PrimeSpectrum R) =\n    minimalPrimes R := by\n  rw [irreducibleComponents_eq_maximals_closed, minimalPrimes_eq_minimals,\n    image_antitone_setOf_maximal (fun s t hs _ ↦ (vanishingIdeal_anti_mono_iff hs.1).symm),\n    ← funext (@Set.mem_setOf_eq _ · Ideal.IsPrime), ← vanishingIdeal_isClosed_isIrreducible]\n  rfl\n\n"}
{"name":"PrimeSpectrum.zeroLocus_minimalPrimes","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommSemiring R\n⊢ Eq (Set.image (Function.comp PrimeSpectrum.zeroLocus SetLike.coe) (minimalPrimes R)) (irreducibleComponents (PrimeSpectrum R))","decl":"lemma zeroLocus_minimalPrimes :\n    zeroLocus ∘ (↑) '' minimalPrimes R =\n    irreducibleComponents (PrimeSpectrum R) := by\n  rw [← vanishingIdeal_irreducibleComponents, ← Set.image_comp, Set.EqOn.image_eq_self]\n  intros s hs\n  simpa [zeroLocus_vanishingIdeal_eq_closure, closure_eq_iff_isClosed]\n    using isClosed_of_mem_irreducibleComponents s hs\n\n"}
{"name":"PrimeSpectrum.vanishingIdeal_mem_minimalPrimes","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommSemiring R\ns : Set (PrimeSpectrum R)\n⊢ Iff (Membership.mem (minimalPrimes R) (PrimeSpectrum.vanishingIdeal s)) (Membership.mem (irreducibleComponents (PrimeSpectrum R)) (closure s))","decl":"lemma vanishingIdeal_mem_minimalPrimes {s : Set (PrimeSpectrum R)} :\n    vanishingIdeal s ∈ minimalPrimes R ↔ closure s ∈ irreducibleComponents (PrimeSpectrum R) := by\n  constructor\n  · rw [← zeroLocus_minimalPrimes, ← zeroLocus_vanishingIdeal_eq_closure]\n    exact Set.mem_image_of_mem _\n  · rw [← vanishingIdeal_irreducibleComponents, ← vanishingIdeal_closure]\n    exact Set.mem_image_of_mem _\n\n"}
{"name":"PrimeSpectrum.zeroLocus_ideal_mem_irreducibleComponents","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI : Ideal R\n⊢ Iff (Membership.mem (irreducibleComponents (PrimeSpectrum R)) (PrimeSpectrum.zeroLocus ↑I)) (Membership.mem (minimalPrimes R) I.radical)","decl":"lemma zeroLocus_ideal_mem_irreducibleComponents {I : Ideal R} :\n    zeroLocus I ∈ irreducibleComponents (PrimeSpectrum R) ↔ I.radical ∈ minimalPrimes R := by\n  rw [← vanishingIdeal_zeroLocus_eq_radical]\n  conv_lhs => rw [← (isClosed_zeroLocus _).closure_eq]\n  exact vanishingIdeal_mem_minimalPrimes.symm\n\n"}
{"name":"IsLocalRing.isLocalHom_iff_comap_closedPoint","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝³ : CommSemiring R\ninst✝² : IsLocalRing R\nS : Type v\ninst✝¹ : CommSemiring S\ninst✝ : IsLocalRing S\nf : RingHom R S\n⊢ Iff (IsLocalHom f) (Eq ((PrimeSpectrum.comap f) (IsLocalRing.closedPoint S)) (IsLocalRing.closedPoint R))","decl":"theorem isLocalHom_iff_comap_closedPoint {S : Type v} [CommSemiring S] [IsLocalRing S]\n    (f : R →+* S) : IsLocalHom f ↔ PrimeSpectrum.comap f (closedPoint S) = closedPoint R := by\n  -- Porting note: inline `this` does **not** work\n  have := (local_hom_TFAE f).out 0 4\n  rw [this, PrimeSpectrum.ext_iff]\n  rfl\n\n"}
{"name":"IsLocalRing.isLocalRingHom_iff_comap_closedPoint","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝³ : CommSemiring R\ninst✝² : IsLocalRing R\nS : Type v\ninst✝¹ : CommSemiring S\ninst✝ : IsLocalRing S\nf : RingHom R S\n⊢ Iff (IsLocalHom f) (Eq ((PrimeSpectrum.comap f) (IsLocalRing.closedPoint S)) (IsLocalRing.closedPoint R))","decl":"@[deprecated (since := \"2024-10-10\")]\nalias isLocalRingHom_iff_comap_closedPoint := isLocalHom_iff_comap_closedPoint\n\n"}
{"name":"IsLocalRing.comap_closedPoint","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝⁴ : CommSemiring R\ninst✝³ : IsLocalRing R\nS : Type v\ninst✝² : CommSemiring S\ninst✝¹ : IsLocalRing S\nf : RingHom R S\ninst✝ : IsLocalHom f\n⊢ Eq ((PrimeSpectrum.comap f) (IsLocalRing.closedPoint S)) (IsLocalRing.closedPoint R)","decl":"@[simp]\ntheorem comap_closedPoint {S : Type v} [CommSemiring S] [IsLocalRing S] (f : R →+* S)\n    [IsLocalHom f] : PrimeSpectrum.comap f (closedPoint S) = closedPoint R :=\n  (isLocalHom_iff_comap_closedPoint f).mp inferInstance\n\n"}
{"name":"IsLocalRing.specializes_closedPoint","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝¹ : CommSemiring R\ninst✝ : IsLocalRing R\nx : PrimeSpectrum R\n⊢ Specializes x (IsLocalRing.closedPoint R)","decl":"theorem specializes_closedPoint (x : PrimeSpectrum R) : x ⤳ closedPoint R :=\n  (PrimeSpectrum.le_iff_specializes _ _).mp (IsLocalRing.le_maximalIdeal x.2.1)\n\n"}
{"name":"IsLocalRing.closedPoint_mem_iff","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝¹ : CommSemiring R\ninst✝ : IsLocalRing R\nU : TopologicalSpace.Opens (PrimeSpectrum R)\n⊢ Iff (Membership.mem U (IsLocalRing.closedPoint R)) (Eq U Top.top)","decl":"theorem closedPoint_mem_iff (U : TopologicalSpace.Opens <| PrimeSpectrum R) :\n    closedPoint R ∈ U ↔ U = ⊤ := by\n  constructor\n  · rw [eq_top_iff]\n    exact fun h x _ => (specializes_closedPoint x).mem_open U.2 h\n  · rintro rfl\n    trivial\n\n"}
{"name":"IsLocalRing.closed_point_mem_iff","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝¹ : CommSemiring R\ninst✝ : IsLocalRing R\nU : TopologicalSpace.Opens (PrimeSpectrum R)\n⊢ Iff (Membership.mem U (IsLocalRing.closedPoint R)) (Eq U Top.top)","decl":"lemma closed_point_mem_iff {U : TopologicalSpace.Opens (PrimeSpectrum R)} :\n    closedPoint R ∈ U ↔ U = ⊤ :=\n  ⟨(eq_top_iff.mpr fun x _ ↦ (specializes_closedPoint x).mem_open U.2 ·), (· ▸ trivial)⟩\n\n"}
{"name":"IsLocalRing.PrimeSpectrum.comap_residue","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"T : Type u\ninst✝¹ : CommRing T\ninst✝ : IsLocalRing T\nx : PrimeSpectrum (IsLocalRing.ResidueField T)\n⊢ Eq ((PrimeSpectrum.comap (IsLocalRing.residue T)) x) (IsLocalRing.closedPoint T)","decl":"@[simp]\ntheorem PrimeSpectrum.comap_residue (T : Type u) [CommRing T] [IsLocalRing T]\n    (x : PrimeSpectrum (ResidueField T)) : PrimeSpectrum.comap (residue T) x = closedPoint T := by\n  rw [Subsingleton.elim x ⊥]\n  ext1\n  exact Ideal.mk_ker\n\n"}
{"name":"LocalRing.isLocalHom_iff_comap_closedPoint","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝³ : CommSemiring R\ninst✝² : IsLocalRing R\nS : Type v\ninst✝¹ : CommSemiring S\ninst✝ : IsLocalRing S\nf : RingHom R S\n⊢ Iff (IsLocalHom f) (Eq ((PrimeSpectrum.comap f) (IsLocalRing.closedPoint S)) (IsLocalRing.closedPoint R))","decl":"@[deprecated (since := \"2024-11-11\")]\nalias LocalRing.isLocalHom_iff_comap_closedPoint := IsLocalRing.isLocalHom_iff_comap_closedPoint\n\n"}
{"name":"LocalRing.comap_closedPoint","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝⁴ : CommSemiring R\ninst✝³ : IsLocalRing R\nS : Type v\ninst✝² : CommSemiring S\ninst✝¹ : IsLocalRing S\nf : RingHom R S\ninst✝ : IsLocalHom f\n⊢ Eq ((PrimeSpectrum.comap f) (IsLocalRing.closedPoint S)) (IsLocalRing.closedPoint R)","decl":"@[deprecated (since := \"2024-11-11\")]\nalias LocalRing.comap_closedPoint := IsLocalRing.comap_closedPoint\n\n"}
{"name":"LocalRing.specializes_closedPoint","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝¹ : CommSemiring R\ninst✝ : IsLocalRing R\nx : PrimeSpectrum R\n⊢ Specializes x (IsLocalRing.closedPoint R)","decl":"@[deprecated (since := \"2024-11-11\")]\nalias LocalRing.specializes_closedPoint := IsLocalRing.specializes_closedPoint\n\n"}
{"name":"LocalRing.closedPoint_mem_iff","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝¹ : CommSemiring R\ninst✝ : IsLocalRing R\nU : TopologicalSpace.Opens (PrimeSpectrum R)\n⊢ Iff (Membership.mem U (IsLocalRing.closedPoint R)) (Eq U Top.top)","decl":"@[deprecated (since := \"2024-11-11\")]\nalias LocalRing.closedPoint_mem_iff := IsLocalRing.closedPoint_mem_iff\n\n"}
{"name":"LocalRing.closed_point_mem_iff","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝¹ : CommSemiring R\ninst✝ : IsLocalRing R\nU : TopologicalSpace.Opens (PrimeSpectrum R)\n⊢ Iff (Membership.mem U (IsLocalRing.closedPoint R)) (Eq U Top.top)","decl":"@[deprecated (since := \"2024-11-11\")]\nalias LocalRing.closed_point_mem_iff := IsLocalRing.closed_point_mem_iff\n\n"}
{"name":"LocalRing.PrimeSpectrum.comap_residue","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"T : Type u\ninst✝¹ : CommRing T\ninst✝ : IsLocalRing T\nx : PrimeSpectrum (IsLocalRing.ResidueField T)\n⊢ Eq ((PrimeSpectrum.comap (IsLocalRing.residue T)) x) (IsLocalRing.closedPoint T)","decl":"@[deprecated (since := \"2024-11-11\")]\nalias LocalRing.PrimeSpectrum.comap_residue := IsLocalRing.PrimeSpectrum.comap_residue\n\n"}
{"name":"PrimeSpectrum.topologicalKrullDim_eq_ringKrullDim","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommRing R\n⊢ Eq (topologicalKrullDim (PrimeSpectrum R)) (ringKrullDim R)","decl":"theorem PrimeSpectrum.topologicalKrullDim_eq_ringKrullDim [CommRing R] :\n    topologicalKrullDim (PrimeSpectrum R) = ringKrullDim R :=\n  Order.krullDim_orderDual.symm.trans <| Order.krullDim_eq_of_orderIso\n  (PrimeSpectrum.pointsEquivIrreducibleCloseds R).symm\n\n"}
{"name":"PrimeSpectrum.basicOpen_eq_zeroLocus_of_isIdempotentElem","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommRing R\ne : R\nhe : IsIdempotentElem e\n⊢ Eq (↑(PrimeSpectrum.basicOpen e)) (PrimeSpectrum.zeroLocus (Singleton.singleton (HSub.hSub 1 e)))","decl":"@[stacks 00EC]\nlemma basicOpen_eq_zeroLocus_of_isIdempotentElem\n    (e : R) (he : IsIdempotentElem e) :\n    basicOpen e = zeroLocus {1 - e} := by\n  ext p\n  suffices e ∉ p.asIdeal ↔ 1 - e ∈ p.asIdeal by simpa\n  constructor\n  · refine (p.2.mem_or_mem_of_mul_eq_zero ?_).resolve_left\n    rw [mul_sub, mul_one, he.eq, sub_self]\n  · refine fun h₁ h₂ ↦ p.2.1 ?_\n    rw [Ideal.eq_top_iff_one, ← sub_add_cancel 1 e]\n    exact add_mem h₁ h₂\n\n"}
{"name":"PrimeSpectrum.zeroLocus_eq_basicOpen_of_isIdempotentElem","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommRing R\ne : R\nhe : IsIdempotentElem e\n⊢ Eq (PrimeSpectrum.zeroLocus (Singleton.singleton e)) ↑(PrimeSpectrum.basicOpen (HSub.hSub 1 e))","decl":"@[stacks 00EC]\nlemma zeroLocus_eq_basicOpen_of_isIdempotentElem\n    (e : R) (he : IsIdempotentElem e) :\n    zeroLocus {e} = basicOpen (1 - e) := by\n  rw [basicOpen_eq_zeroLocus_of_isIdempotentElem _ he.one_sub, sub_sub_cancel]\n\n"}
{"name":"PrimeSpectrum.isClopen_iff","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommRing R\ns : Set (PrimeSpectrum R)\n⊢ Iff (IsClopen s) (Exists fun e => And (IsIdempotentElem e) (Eq s ↑(PrimeSpectrum.basicOpen e)))","decl":"lemma isClopen_iff {s : Set (PrimeSpectrum R)} :\n    IsClopen s ↔ ∃ e : R, IsIdempotentElem e ∧ s = basicOpen e := by\n  refine ⟨exists_idempotent_basicOpen_eq_of_isClopen, ?_⟩\n  rintro ⟨e, he, rfl⟩\n  refine ⟨?_, (basicOpen e).2⟩\n  rw [PrimeSpectrum.basicOpen_eq_zeroLocus_of_isIdempotentElem e he]\n  exact isClosed_zeroLocus _\n\n"}
{"name":"PrimeSpectrum.isClopen_iff_zeroLocus","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommRing R\ns : Set (PrimeSpectrum R)\n⊢ Iff (IsClopen s) (Exists fun e => And (IsIdempotentElem e) (Eq s (PrimeSpectrum.zeroLocus (Singleton.singleton e))))","decl":"lemma isClopen_iff_zeroLocus {s : Set (PrimeSpectrum R)} :\n    IsClopen s ↔ ∃ e : R, IsIdempotentElem e ∧ s = zeroLocus {e} :=\n  isClopen_iff.trans <| ⟨fun ⟨e, he, h⟩ ↦ ⟨1 - e, he.one_sub,\n    h.trans (basicOpen_eq_zeroLocus_of_isIdempotentElem e he)⟩,\n    fun ⟨e, he, h⟩ ↦ ⟨1 - e, he.one_sub, h.trans (zeroLocus_eq_basicOpen_of_isIdempotentElem e he)⟩⟩\n\n"}
{"name":"PrimeSpectrum.basicOpen_isIdempotentElemEquivClopens_symm","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommRing R\ns : TopologicalSpace.Clopens (PrimeSpectrum R)\n⊢ Eq (PrimeSpectrum.basicOpen ↑(PrimeSpectrum.isIdempotentElemEquivClopens.symm s)) s.toOpens","decl":"lemma basicOpen_isIdempotentElemEquivClopens_symm (s) :\n    basicOpen (isIdempotentElemEquivClopens (R := R).symm s).1 = s.toOpens :=\n  Opens.ext <| congr_arg (·.1) (isIdempotentElemEquivClopens.apply_symm_apply s)\n\n"}
{"name":"PrimeSpectrum.coe_isIdempotentElemEquivClopens_apply","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommRing R\ne : ↑(setOf fun e => IsIdempotentElem e)\n⊢ Eq ↑(PrimeSpectrum.isIdempotentElemEquivClopens e) ↑(PrimeSpectrum.basicOpen ↑e)","decl":"lemma coe_isIdempotentElemEquivClopens_apply (e) :\n    (isIdempotentElemEquivClopens e : Set (PrimeSpectrum R)) = basicOpen (e.1 : R) := rfl\n\n"}
{"name":"PrimeSpectrum.isIdempotentElemEquivClopens_apply_toOpens","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommRing R\ne : ↑(setOf fun e => IsIdempotentElem e)\n⊢ Eq (PrimeSpectrum.isIdempotentElemEquivClopens e).toOpens (PrimeSpectrum.basicOpen ↑e)","decl":"lemma isIdempotentElemEquivClopens_apply_toOpens (e) :\n    (isIdempotentElemEquivClopens e).toOpens = basicOpen (e.1 : R) := rfl\n\n"}
{"name":"PrimeSpectrum.isIdempotentElemEquivClopens_mul","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommRing R\ne₁ e₂ : ↑(setOf fun e => IsIdempotentElem e)\n⊢ Eq (PrimeSpectrum.isIdempotentElemEquivClopens ⟨HMul.hMul ↑e₁ ↑e₂, ⋯⟩) (Min.min (PrimeSpectrum.isIdempotentElemEquivClopens e₁) (PrimeSpectrum.isIdempotentElemEquivClopens e₂))","decl":"lemma isIdempotentElemEquivClopens_mul (e₁ e₂ : {e : R | IsIdempotentElem e}) :\n    isIdempotentElemEquivClopens ⟨_, e₁.2.mul e₂.2⟩ =\n      isIdempotentElemEquivClopens e₁ ⊓ isIdempotentElemEquivClopens e₂ :=\n  Clopens.ext <| by simp_rw [coe_isIdempotentElemEquivClopens_apply, basicOpen_mul]; rfl\n\n"}
{"name":"PrimeSpectrum.isIdempotentElemEquivClopens_one_sub","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommRing R\ne : ↑(setOf fun e => IsIdempotentElem e)\n⊢ Eq (PrimeSpectrum.isIdempotentElemEquivClopens ⟨HSub.hSub 1 ↑e, ⋯⟩) (HasCompl.compl (PrimeSpectrum.isIdempotentElemEquivClopens e))","decl":"lemma isIdempotentElemEquivClopens_one_sub (e : {e : R | IsIdempotentElem e}) :\n    isIdempotentElemEquivClopens ⟨_, e.2.one_sub⟩ = (isIdempotentElemEquivClopens e)ᶜ :=\n  SetLike.ext' <| by\n    simp_rw [Clopens.coe_compl, coe_isIdempotentElemEquivClopens_apply]\n    rw [basicOpen_eq_zeroLocus_compl, basicOpen_eq_zeroLocus_of_isIdempotentElem _ e.2]\n\n"}
{"name":"PrimeSpectrum.isIdempotentElemEquivClopens_symm_inf","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommRing R\ns₁ s₂ : TopologicalSpace.Clopens (PrimeSpectrum R)\n⊢ Eq (PrimeSpectrum.isIdempotentElemEquivClopens.symm (Min.min s₁ s₂)) ⟨HMul.hMul ↑(PrimeSpectrum.isIdempotentElemEquivClopens.symm s₁) ↑(PrimeSpectrum.isIdempotentElemEquivClopens.symm s₂), ⋯⟩","decl":"lemma isIdempotentElemEquivClopens_symm_inf (s₁ s₂) :\n    letI e := isIdempotentElemEquivClopens (R := R).symm\n    e (s₁ ⊓ s₂) = ⟨_, (e s₁).2.mul (e s₂).2⟩ :=\n  isIdempotentElemEquivClopens.symm_apply_eq.mpr <| by\n    simp_rw [isIdempotentElemEquivClopens_mul, Equiv.apply_symm_apply]\n\n"}
{"name":"PrimeSpectrum.isIdempotentElemEquivClopens_symm_compl","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommRing R\ns : TopologicalSpace.Clopens (PrimeSpectrum R)\n⊢ Eq (PrimeSpectrum.isIdempotentElemEquivClopens.symm (HasCompl.compl s)) ⟨HSub.hSub 1 ↑(PrimeSpectrum.isIdempotentElemEquivClopens.symm s), ⋯⟩","decl":"lemma isIdempotentElemEquivClopens_symm_compl (s : Clopens (PrimeSpectrum R)) :\n    isIdempotentElemEquivClopens.symm sᶜ = ⟨_, (isIdempotentElemEquivClopens.symm s).2.one_sub⟩ :=\n  isIdempotentElemEquivClopens.symm_apply_eq.mpr <| by\n    rw [isIdempotentElemEquivClopens_one_sub, Equiv.apply_symm_apply]\n\n"}
{"name":"PrimeSpectrum.isIdempotentElemEquivClopens_symm_top","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommRing R\n⊢ Eq (PrimeSpectrum.isIdempotentElemEquivClopens.symm Top.top) ⟨1, ⋯⟩","decl":"lemma isIdempotentElemEquivClopens_symm_top :\n    isIdempotentElemEquivClopens.symm ⊤ = ⟨(1 : R), .one⟩ :=\n  isIdempotentElemEquivClopens.symm_apply_eq.mpr <| Clopens.ext <| by\n    rw [coe_isIdempotentElemEquivClopens_apply, basicOpen_one]; rfl\n\n"}
{"name":"PrimeSpectrum.isIdempotentElemEquivClopens_symm_bot","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommRing R\n⊢ Eq (PrimeSpectrum.isIdempotentElemEquivClopens.symm Bot.bot) ⟨0, ⋯⟩","decl":"lemma isIdempotentElemEquivClopens_symm_bot :\n    isIdempotentElemEquivClopens.symm ⊥ = ⟨(0 : R), .zero⟩ :=\n  isIdempotentElemEquivClopens.symm_apply_eq.mpr <| Clopens.ext <| by\n    rw [coe_isIdempotentElemEquivClopens_apply, basicOpen_zero]; rfl\n\n"}
{"name":"PrimeSpectrum.isIdempotentElemEquivClopens_symm_sup","module":"Mathlib.RingTheory.Spectrum.Prime.Topology","initialProofState":"R : Type u\ninst✝ : CommRing R\ns₁ s₂ : TopologicalSpace.Clopens (PrimeSpectrum R)\n⊢ Eq (PrimeSpectrum.isIdempotentElemEquivClopens.symm (Max.max s₁ s₂)) ⟨HSub.hSub (HAdd.hAdd ↑(PrimeSpectrum.isIdempotentElemEquivClopens.symm s₁) ↑(PrimeSpectrum.isIdempotentElemEquivClopens.symm s₂)) (HMul.hMul ↑(PrimeSpectrum.isIdempotentElemEquivClopens.symm s₁) ↑(PrimeSpectrum.isIdempotentElemEquivClopens.symm s₂)), ⋯⟩","decl":"lemma isIdempotentElemEquivClopens_symm_sup (s₁ s₂ : Clopens (PrimeSpectrum R)) :\n    letI e := isIdempotentElemEquivClopens (R := R).symm\n    e (s₁ ⊔ s₂) = ⟨_, (e s₁).2.add_sub_mul (e s₂).2⟩ := Subtype.ext <| by\n  rw [← compl_compl (_ ⊔ _), compl_sup, isIdempotentElemEquivClopens_symm_compl]\n  simp_rw [isIdempotentElemEquivClopens_symm_inf, isIdempotentElemEquivClopens_symm_compl]\n  ring\n\n"}
