{"name":"IsClopen.isOpen","module":"Mathlib.Topology.Clopen","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\nhs : IsClopen s\n⊢ IsOpen s","decl":"protected theorem IsClopen.isOpen (hs : IsClopen s) : IsOpen s := hs.2\n\n"}
{"name":"IsClopen.isClosed","module":"Mathlib.Topology.Clopen","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\nhs : IsClopen s\n⊢ IsClosed s","decl":"protected theorem IsClopen.isClosed (hs : IsClopen s) : IsClosed s := hs.1\n\n"}
{"name":"isClopen_iff_frontier_eq_empty","module":"Mathlib.Topology.Clopen","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ Iff (IsClopen s) (Eq (frontier s) EmptyCollection.emptyCollection)","decl":"theorem isClopen_iff_frontier_eq_empty : IsClopen s ↔ frontier s = ∅ := by\n  rw [IsClopen, ← closure_eq_iff_isClosed, ← interior_eq_iff_isOpen, frontier, diff_eq_empty]\n  refine ⟨fun h => (h.1.trans h.2.symm).subset, fun h => ?_⟩\n  exact ⟨(h.trans interior_subset).antisymm subset_closure,\n    interior_subset.antisymm (subset_closure.trans h)⟩\n\n"}
{"name":"IsClopen.frontier_eq","module":"Mathlib.Topology.Clopen","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\na✝ : IsClopen s\n⊢ Eq (frontier s) EmptyCollection.emptyCollection","decl":"@[simp] alias ⟨IsClopen.frontier_eq, _⟩ := isClopen_iff_frontier_eq_empty\n\n"}
{"name":"IsClopen.union","module":"Mathlib.Topology.Clopen","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns t : Set X\nhs : IsClopen s\nht : IsClopen t\n⊢ IsClopen (Union.union s t)","decl":"theorem IsClopen.union (hs : IsClopen s) (ht : IsClopen t) : IsClopen (s ∪ t) :=\n  ⟨hs.1.union ht.1, hs.2.union ht.2⟩\n\n"}
{"name":"IsClopen.inter","module":"Mathlib.Topology.Clopen","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns t : Set X\nhs : IsClopen s\nht : IsClopen t\n⊢ IsClopen (Inter.inter s t)","decl":"theorem IsClopen.inter (hs : IsClopen s) (ht : IsClopen t) : IsClopen (s ∩ t) :=\n  ⟨hs.1.inter ht.1, hs.2.inter ht.2⟩\n\n"}
{"name":"isClopen_empty","module":"Mathlib.Topology.Clopen","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\n⊢ IsClopen EmptyCollection.emptyCollection","decl":"theorem isClopen_empty : IsClopen (∅ : Set X) := ⟨isClosed_empty, isOpen_empty⟩\n\n"}
{"name":"isClopen_univ","module":"Mathlib.Topology.Clopen","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\n⊢ IsClopen Set.univ","decl":"theorem isClopen_univ : IsClopen (univ : Set X) := ⟨isClosed_univ, isOpen_univ⟩\n\n"}
{"name":"IsClopen.compl","module":"Mathlib.Topology.Clopen","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\nhs : IsClopen s\n⊢ IsClopen (HasCompl.compl s)","decl":"theorem IsClopen.compl (hs : IsClopen s) : IsClopen sᶜ :=\n  ⟨hs.2.isClosed_compl, hs.1.isOpen_compl⟩\n\n"}
{"name":"isClopen_compl_iff","module":"Mathlib.Topology.Clopen","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ Iff (IsClopen (HasCompl.compl s)) (IsClopen s)","decl":"@[simp]\ntheorem isClopen_compl_iff : IsClopen sᶜ ↔ IsClopen s :=\n  ⟨fun h => compl_compl s ▸ IsClopen.compl h, IsClopen.compl⟩\n\n"}
{"name":"IsClopen.diff","module":"Mathlib.Topology.Clopen","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns t : Set X\nhs : IsClopen s\nht : IsClopen t\n⊢ IsClopen (SDiff.sdiff s t)","decl":"theorem IsClopen.diff (hs : IsClopen s) (ht : IsClopen t) : IsClopen (s \\ t) :=\n  hs.inter ht.compl\n\n"}
{"name":"IsClopen.himp","module":"Mathlib.Topology.Clopen","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns t : Set X\nhs : IsClopen s\nht : IsClopen t\n⊢ IsClopen (HImp.himp s t)","decl":"lemma IsClopen.himp (hs : IsClopen s) (ht : IsClopen t) : IsClopen (s ⇨ t) := by\n  simpa [himp_eq] using ht.union hs.compl\n\n"}
{"name":"IsClopen.prod","module":"Mathlib.Topology.Clopen","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ns : Set X\nt : Set Y\nhs : IsClopen s\nht : IsClopen t\n⊢ IsClopen (SProd.sprod s t)","decl":"theorem IsClopen.prod {t : Set Y} (hs : IsClopen s) (ht : IsClopen t) : IsClopen (s ×ˢ t) :=\n  ⟨hs.1.prod ht.1, hs.2.prod ht.2⟩\n\n"}
{"name":"isClopen_iUnion_of_finite","module":"Mathlib.Topology.Clopen","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\nY : Sort u_2\ninst✝ : Finite Y\ns : Y → Set X\nh : ∀ (i : Y), IsClopen (s i)\n⊢ IsClopen (Set.iUnion fun i => s i)","decl":"theorem isClopen_iUnion_of_finite {Y} [Finite Y] {s : Y → Set X} (h : ∀ i, IsClopen (s i)) :\n    IsClopen (⋃ i, s i) :=\n  ⟨isClosed_iUnion_of_finite (forall_and.1 h).1, isOpen_iUnion (forall_and.1 h).2⟩\n\n"}
{"name":"Set.Finite.isClopen_biUnion","module":"Mathlib.Topology.Clopen","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nY : Type u_2\ns : Set Y\nf : Y → Set X\nhs : s.Finite\nh : ∀ (i : Y), Membership.mem s i → IsClopen (f i)\n⊢ IsClopen (Set.iUnion fun i => Set.iUnion fun h => f i)","decl":"theorem Set.Finite.isClopen_biUnion {Y} {s : Set Y} {f : Y → Set X} (hs : s.Finite)\n    (h : ∀ i ∈ s, IsClopen <| f i) : IsClopen (⋃ i ∈ s, f i) :=\n  ⟨hs.isClosed_biUnion fun i hi => (h i hi).1, isOpen_biUnion fun i hi => (h i hi).2⟩\n\n"}
{"name":"isClopen_biUnion_finset","module":"Mathlib.Topology.Clopen","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nY : Type u_2\ns : Finset Y\nf : Y → Set X\nh : ∀ (i : Y), Membership.mem s i → IsClopen (f i)\n⊢ IsClopen (Set.iUnion fun i => Set.iUnion fun h => f i)","decl":"theorem isClopen_biUnion_finset {Y} {s : Finset Y} {f : Y → Set X}\n    (h : ∀ i ∈ s, IsClopen <| f i) : IsClopen (⋃ i ∈ s, f i) :=\n s.finite_toSet.isClopen_biUnion h\n\n"}
{"name":"isClopen_iInter_of_finite","module":"Mathlib.Topology.Clopen","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\nY : Sort u_2\ninst✝ : Finite Y\ns : Y → Set X\nh : ∀ (i : Y), IsClopen (s i)\n⊢ IsClopen (Set.iInter fun i => s i)","decl":"theorem isClopen_iInter_of_finite {Y} [Finite Y] {s : Y → Set X} (h : ∀ i, IsClopen (s i)) :\n    IsClopen (⋂ i, s i) :=\n  ⟨isClosed_iInter (forall_and.1 h).1, isOpen_iInter_of_finite (forall_and.1 h).2⟩\n\n"}
{"name":"Set.Finite.isClopen_biInter","module":"Mathlib.Topology.Clopen","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nY : Type u_2\ns : Set Y\nhs : s.Finite\nf : Y → Set X\nh : ∀ (i : Y), Membership.mem s i → IsClopen (f i)\n⊢ IsClopen (Set.iInter fun i => Set.iInter fun h => f i)","decl":"theorem Set.Finite.isClopen_biInter {Y} {s : Set Y} (hs : s.Finite) {f : Y → Set X}\n    (h : ∀ i ∈ s, IsClopen (f i)) : IsClopen (⋂ i ∈ s, f i) :=\n  ⟨isClosed_biInter fun i hi => (h i hi).1, hs.isOpen_biInter fun i hi => (h i hi).2⟩\n\n"}
{"name":"isClopen_biInter_finset","module":"Mathlib.Topology.Clopen","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nY : Type u_2\ns : Finset Y\nf : Y → Set X\nh : ∀ (i : Y), Membership.mem s i → IsClopen (f i)\n⊢ IsClopen (Set.iInter fun i => Set.iInter fun h => f i)","decl":"theorem isClopen_biInter_finset {Y} {s : Finset Y} {f : Y → Set X}\n    (h : ∀ i ∈ s, IsClopen (f i)) : IsClopen (⋂ i ∈ s, f i) :=\n  s.finite_toSet.isClopen_biInter h\n\n"}
{"name":"IsClopen.preimage","module":"Mathlib.Topology.Clopen","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ns : Set Y\nh : IsClopen s\nf : X → Y\nhf : Continuous f\n⊢ IsClopen (Set.preimage f s)","decl":"theorem IsClopen.preimage {s : Set Y} (h : IsClopen s) {f : X → Y} (hf : Continuous f) :\n    IsClopen (f ⁻¹' s) :=\n  ⟨h.1.preimage hf, h.2.preimage hf⟩\n\n"}
{"name":"ContinuousOn.preimage_isClopen_of_isClopen","module":"Mathlib.Topology.Clopen","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\ns : Set X\nt : Set Y\nhf : ContinuousOn f s\nhs : IsClopen s\nht : IsClopen t\n⊢ IsClopen (Inter.inter s (Set.preimage f t))","decl":"theorem ContinuousOn.preimage_isClopen_of_isClopen {f : X → Y} {s : Set X} {t : Set Y}\n    (hf : ContinuousOn f s) (hs : IsClopen s) (ht : IsClopen t) : IsClopen (s ∩ f ⁻¹' t) :=\n  ⟨ContinuousOn.preimage_isClosed_of_isClosed hf hs.1 ht.1,\n    ContinuousOn.isOpen_inter_preimage hf hs.2 ht.2⟩\n\n"}
{"name":"isClopen_inter_of_disjoint_cover_clopen","module":"Mathlib.Topology.Clopen","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns a b : Set X\nh : IsClopen s\ncover : HasSubset.Subset s (Union.union a b)\nha : IsOpen a\nhb : IsOpen b\nhab : Disjoint a b\n⊢ IsClopen (Inter.inter s a)","decl":"/-- The intersection of a disjoint covering by two open sets of a clopen set will be clopen. -/\ntheorem isClopen_inter_of_disjoint_cover_clopen {s a b : Set X} (h : IsClopen s) (cover : s ⊆ a ∪ b)\n    (ha : IsOpen a) (hb : IsOpen b) (hab : Disjoint a b) : IsClopen (s ∩ a) := by\n  refine ⟨?_, IsOpen.inter h.2 ha⟩\n  have : IsClosed (s ∩ bᶜ) := IsClosed.inter h.1 (isClosed_compl_iff.2 hb)\n  convert this using 1\n  refine (inter_subset_inter_right s hab.subset_compl_right).antisymm ?_\n  rintro x ⟨hx₁, hx₂⟩\n  exact ⟨hx₁, by simpa [not_mem_of_mem_compl hx₂] using cover hx₁⟩\n\n"}
{"name":"isClopen_of_disjoint_cover_open","module":"Mathlib.Topology.Clopen","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\na b : Set X\ncover : HasSubset.Subset Set.univ (Union.union a b)\nha : IsOpen a\nhb : IsOpen b\nhab : Disjoint a b\n⊢ IsClopen a","decl":"theorem isClopen_of_disjoint_cover_open {a b : Set X} (cover : univ ⊆ a ∪ b)\n    (ha : IsOpen a) (hb : IsOpen b) (hab : Disjoint a b) : IsClopen a :=\n  univ_inter a ▸ isClopen_inter_of_disjoint_cover_clopen isClopen_univ cover ha hb hab\n\n"}
{"name":"isClopen_discrete","module":"Mathlib.Topology.Clopen","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\ninst✝ : DiscreteTopology X\ns : Set X\n⊢ IsClopen s","decl":"@[simp]\ntheorem isClopen_discrete [DiscreteTopology X] (s : Set X) : IsClopen s :=\n  ⟨isClosed_discrete _, isOpen_discrete _⟩\n\n"}
{"name":"isClopen_range_inl","module":"Mathlib.Topology.Clopen","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\n⊢ IsClopen (Set.range Sum.inl)","decl":"theorem isClopen_range_inl : IsClopen (range (Sum.inl : X → X ⊕ Y)) :=\n  ⟨isClosed_range_inl, isOpen_range_inl⟩\n\n"}
{"name":"isClopen_range_inr","module":"Mathlib.Topology.Clopen","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\n⊢ IsClopen (Set.range Sum.inr)","decl":"theorem isClopen_range_inr : IsClopen (range (Sum.inr : Y → X ⊕ Y)) :=\n  ⟨isClosed_range_inr, isOpen_range_inr⟩\n\n"}
{"name":"isClopen_range_sigmaMk","module":"Mathlib.Topology.Clopen","initialProofState":"ι : Type u_1\nX : ι → Type u_2\ninst✝ : (i : ι) → TopologicalSpace (X i)\ni : ι\n⊢ IsClopen (Set.range (Sigma.mk i))","decl":"theorem isClopen_range_sigmaMk {X : ι → Type*} [∀ i, TopologicalSpace (X i)] {i : ι} :\n    IsClopen (Set.range (@Sigma.mk ι X i)) :=\n  ⟨IsClosedEmbedding.sigmaMk.isClosed_range, IsOpenEmbedding.sigmaMk.isOpen_range⟩\n\n"}
{"name":"Topology.IsQuotientMap.isClopen_preimage","module":"Mathlib.Topology.Clopen","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nhf : Topology.IsQuotientMap f\ns : Set Y\n⊢ Iff (IsClopen (Set.preimage f s)) (IsClopen s)","decl":"protected theorem Topology.IsQuotientMap.isClopen_preimage {f : X → Y} (hf : IsQuotientMap f)\n    {s : Set Y} : IsClopen (f ⁻¹' s) ↔ IsClopen s :=\n  and_congr hf.isClosed_preimage hf.isOpen_preimage\n\n"}
{"name":"QuotientMap.isClopen_preimage","module":"Mathlib.Topology.Clopen","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nhf : Topology.IsQuotientMap f\ns : Set Y\n⊢ Iff (IsClopen (Set.preimage f s)) (IsClopen s)","decl":"@[deprecated (since := \"2024-10-22\")]\nalias QuotientMap.isClopen_preimage := IsQuotientMap.isClopen_preimage\n\n"}
{"name":"continuous_boolIndicator_iff_isClopen","module":"Mathlib.Topology.Clopen","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nU : Set X\n⊢ Iff (Continuous U.boolIndicator) (IsClopen U)","decl":"theorem continuous_boolIndicator_iff_isClopen (U : Set X) :\n    Continuous U.boolIndicator ↔ IsClopen U := by\n  rw [continuous_bool_rng true, preimage_boolIndicator_true]\n\n"}
{"name":"continuousOn_boolIndicator_iff_isClopen","module":"Mathlib.Topology.Clopen","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns U : Set X\n⊢ Iff (ContinuousOn U.boolIndicator s) (IsClopen (Set.preimage Subtype.val U))","decl":"theorem continuousOn_boolIndicator_iff_isClopen (s U : Set X) :\n    ContinuousOn U.boolIndicator s ↔ IsClopen (((↑) : s → X) ⁻¹' U) := by\n  rw [continuousOn_iff_continuous_restrict, ← continuous_boolIndicator_iff_isClopen]\n  rfl\n\n"}
