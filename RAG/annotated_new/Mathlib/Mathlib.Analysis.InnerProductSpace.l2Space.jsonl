{"name":"lp.summable_inner","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_2\ninstâœÂ² : RCLike ğ•œ\nG : Î¹ â†’ Type u_4\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (G i)\ninstâœ : (i : Î¹) â†’ InnerProductSpace ğ•œ (G i)\nf g : Subtype fun x => Membership.mem (lp G 2) x\nâŠ¢ Summable fun i => Inner.inner (â†‘f i) (â†‘g i)","decl":"theorem summable_inner (f g : lp G 2) : Summable fun i => âŸªf i, g iâŸ« := by\n  -- Apply the Direct Comparison Test, comparing with âˆ‘' i, â€–f iâ€– * â€–g iâ€– (summable by HÃ¶lder)\n  refine .of_norm_bounded (fun i => â€–f iâ€– * â€–g iâ€–) (lp.summable_mul ?_ f g) ?_\n  Â· rw [Real.isConjExponent_iff]; norm_num\n  intro i\n  -- Then apply Cauchy-Schwarz pointwise\n  exact norm_inner_le_norm (ğ•œ := ğ•œ) _ _\n\n"}
{"name":"lp.inner_eq_tsum","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_2\ninstâœÂ² : RCLike ğ•œ\nG : Î¹ â†’ Type u_4\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (G i)\ninstâœ : (i : Î¹) â†’ InnerProductSpace ğ•œ (G i)\nf g : Subtype fun x => Membership.mem (lp G 2) x\nâŠ¢ Eq (Inner.inner f g) (tsum fun i => Inner.inner (â†‘f i) (â†‘g i))","decl":"theorem inner_eq_tsum (f g : lp G 2) : âŸªf, gâŸ« = âˆ‘' i, âŸªf i, g iâŸ« :=\n  rfl\n\n"}
{"name":"lp.hasSum_inner","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_2\ninstâœÂ² : RCLike ğ•œ\nG : Î¹ â†’ Type u_4\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (G i)\ninstâœ : (i : Î¹) â†’ InnerProductSpace ğ•œ (G i)\nf g : Subtype fun x => Membership.mem (lp G 2) x\nâŠ¢ HasSum (fun i => Inner.inner (â†‘f i) (â†‘g i)) (Inner.inner f g)","decl":"theorem hasSum_inner (f g : lp G 2) : HasSum (fun i => âŸªf i, g iâŸ«) âŸªf, gâŸ« :=\n  (summable_inner f g).hasSum\n\n"}
{"name":"lp.inner_single_left","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_2\ninstâœÂ³ : RCLike ğ•œ\nG : Î¹ â†’ Type u_4\ninstâœÂ² : (i : Î¹) â†’ NormedAddCommGroup (G i)\ninstâœÂ¹ : (i : Î¹) â†’ InnerProductSpace ğ•œ (G i)\ninstâœ : DecidableEq Î¹\ni : Î¹\na : G i\nf : Subtype fun x => Membership.mem (lp G 2) x\nâŠ¢ Eq (Inner.inner (lp.single 2 i a) f) (Inner.inner a (â†‘f i))","decl":"theorem inner_single_left [DecidableEq Î¹] (i : Î¹) (a : G i) (f : lp G 2) :\n    âŸªlp.single 2 i a, fâŸ« = âŸªa, f iâŸ« := by\n  refine (hasSum_inner (lp.single 2 i a) f).unique ?_\n  convert hasSum_ite_eq i âŸªa, f iâŸ« using 1\n  ext j\n  rw [lp.single_apply]\n  split_ifs with h\n  Â· subst h; rfl\n  Â· simp\n\n"}
{"name":"lp.inner_single_right","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_2\ninstâœÂ³ : RCLike ğ•œ\nG : Î¹ â†’ Type u_4\ninstâœÂ² : (i : Î¹) â†’ NormedAddCommGroup (G i)\ninstâœÂ¹ : (i : Î¹) â†’ InnerProductSpace ğ•œ (G i)\ninstâœ : DecidableEq Î¹\ni : Î¹\na : G i\nf : Subtype fun x => Membership.mem (lp G 2) x\nâŠ¢ Eq (Inner.inner f (lp.single 2 i a)) (Inner.inner (â†‘f i) a)","decl":"theorem inner_single_right [DecidableEq Î¹] (i : Î¹) (a : G i) (f : lp G 2) :\n    âŸªf, lp.single 2 i aâŸ« = âŸªf i, aâŸ« := by\n  simpa [inner_conj_symm] using congr_arg conj (inner_single_left (ğ•œ := ğ•œ) i a f)\n\n"}
{"name":"OrthogonalFamily.summable_of_lp","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_2\ninstâœâµ : RCLike ğ•œ\nE : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : InnerProductSpace ğ•œ E\nG : Î¹ â†’ Type u_4\ninstâœÂ² : (i : Î¹) â†’ NormedAddCommGroup (G i)\ninstâœÂ¹ : (i : Î¹) â†’ InnerProductSpace ğ•œ (G i)\ninstâœ : CompleteSpace E\nV : (i : Î¹) â†’ LinearIsometry (RingHom.id ğ•œ) (G i) E\nhV : OrthogonalFamily ğ•œ G V\nf : Subtype fun x => Membership.mem (lp G 2) x\nâŠ¢ Summable fun i => (V i) (â†‘f i)","decl":"protected theorem summable_of_lp (f : lp G 2) :\n    Summable fun i => V i (f i) := by\n  rw [hV.summable_iff_norm_sq_summable]\n  convert (lp.memâ„“p f).summable _\n  Â· norm_cast\n  Â· norm_num\n\n"}
{"name":"OrthogonalFamily.linearIsometry_apply","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_2\ninstâœâµ : RCLike ğ•œ\nE : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : InnerProductSpace ğ•œ E\nG : Î¹ â†’ Type u_4\ninstâœÂ² : (i : Î¹) â†’ NormedAddCommGroup (G i)\ninstâœÂ¹ : (i : Î¹) â†’ InnerProductSpace ğ•œ (G i)\ninstâœ : CompleteSpace E\nV : (i : Î¹) â†’ LinearIsometry (RingHom.id ğ•œ) (G i) E\nhV : OrthogonalFamily ğ•œ G V\nf : Subtype fun x => Membership.mem (lp G 2) x\nâŠ¢ Eq (hV.linearIsometry f) (tsum fun i => (V i) (â†‘f i))","decl":"protected theorem linearIsometry_apply (f : lp G 2) : hV.linearIsometry f = âˆ‘' i, V i (f i) :=\n  rfl\n\n"}
{"name":"OrthogonalFamily.hasSum_linearIsometry","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_2\ninstâœâµ : RCLike ğ•œ\nE : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : InnerProductSpace ğ•œ E\nG : Î¹ â†’ Type u_4\ninstâœÂ² : (i : Î¹) â†’ NormedAddCommGroup (G i)\ninstâœÂ¹ : (i : Î¹) â†’ InnerProductSpace ğ•œ (G i)\ninstâœ : CompleteSpace E\nV : (i : Î¹) â†’ LinearIsometry (RingHom.id ğ•œ) (G i) E\nhV : OrthogonalFamily ğ•œ G V\nf : Subtype fun x => Membership.mem (lp G 2) x\nâŠ¢ HasSum (fun i => (V i) (â†‘f i)) (hV.linearIsometry f)","decl":"protected theorem hasSum_linearIsometry (f : lp G 2) :\n    HasSum (fun i => V i (f i)) (hV.linearIsometry f) :=\n  (hV.summable_of_lp f).hasSum\n\n"}
{"name":"OrthogonalFamily.linearIsometry_apply_single","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_2\ninstâœâ¶ : RCLike ğ•œ\nE : Type u_3\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : InnerProductSpace ğ•œ E\nG : Î¹ â†’ Type u_4\ninstâœÂ³ : (i : Î¹) â†’ NormedAddCommGroup (G i)\ninstâœÂ² : (i : Î¹) â†’ InnerProductSpace ğ•œ (G i)\ninstâœÂ¹ : CompleteSpace E\nV : (i : Î¹) â†’ LinearIsometry (RingHom.id ğ•œ) (G i) E\nhV : OrthogonalFamily ğ•œ G V\ninstâœ : DecidableEq Î¹\ni : Î¹\nx : G i\nâŠ¢ Eq (hV.linearIsometry (lp.single 2 i x)) ((V i) x)","decl":"@[simp]\nprotected theorem linearIsometry_apply_single [DecidableEq Î¹] {i : Î¹} (x : G i) :\n    hV.linearIsometry (lp.single 2 i x) = V i x := by\n  rw [hV.linearIsometry_apply, â† tsum_ite_eq i (V i x)]\n  congr\n  ext j\n  rw [lp.single_apply]\n  split_ifs with h\n  Â· subst h; simp\n  Â· simp [h]\n\n"}
{"name":"OrthogonalFamily.linearIsometry_apply_dfinsupp_sum_single","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_2\ninstâœâ· : RCLike ğ•œ\nE : Type u_3\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : InnerProductSpace ğ•œ E\nG : Î¹ â†’ Type u_4\ninstâœâ´ : (i : Î¹) â†’ NormedAddCommGroup (G i)\ninstâœÂ³ : (i : Î¹) â†’ InnerProductSpace ğ•œ (G i)\ninstâœÂ² : CompleteSpace E\nV : (i : Î¹) â†’ LinearIsometry (RingHom.id ğ•œ) (G i) E\nhV : OrthogonalFamily ğ•œ G V\ninstâœÂ¹ : DecidableEq Î¹\ninstâœ : (i : Î¹) â†’ DecidableEq (G i)\nWâ‚€ : DFinsupp fun i => G i\nâŠ¢ Eq (hV.linearIsometry (Wâ‚€.sum (lp.single 2))) (Wâ‚€.sum fun i => â‡‘(V i))","decl":"protected theorem linearIsometry_apply_dfinsupp_sum_single [DecidableEq Î¹] [âˆ€ i, DecidableEq (G i)]\n    (Wâ‚€ : Î â‚€ i : Î¹, G i) : hV.linearIsometry (Wâ‚€.sum (lp.single 2)) = Wâ‚€.sum fun i => V i := by\n  simp\n\n"}
{"name":"OrthogonalFamily.range_linearIsometry","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_2\ninstâœâ¶ : RCLike ğ•œ\nE : Type u_3\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : InnerProductSpace ğ•œ E\nG : Î¹ â†’ Type u_4\ninstâœÂ³ : (i : Î¹) â†’ NormedAddCommGroup (G i)\ninstâœÂ² : (i : Î¹) â†’ InnerProductSpace ğ•œ (G i)\ninstâœÂ¹ : CompleteSpace E\nV : (i : Î¹) â†’ LinearIsometry (RingHom.id ğ•œ) (G i) E\nhV : OrthogonalFamily ğ•œ G V\ninstâœ : âˆ€ (i : Î¹), CompleteSpace (G i)\nâŠ¢ Eq (LinearMap.range hV.linearIsometry.toLinearMap) (iSup fun i => LinearMap.range (V i).toLinearMap).topologicalClosure","decl":"/-- The canonical linear isometry from the `lp 2` of a mutually orthogonal family of subspaces of\n`E` into E, has range the closure of the span of the subspaces. -/\nprotected theorem range_linearIsometry [âˆ€ i, CompleteSpace (G i)] :\n    LinearMap.range hV.linearIsometry.toLinearMap =\n      (â¨† i, LinearMap.range (V i).toLinearMap).topologicalClosure := by\n    -- Porting note: dot notation broken\n  classical\n  refine le_antisymm ?_ ?_\n  Â· rintro x âŸ¨f, rflâŸ©\n    refine mem_closure_of_tendsto (hV.hasSum_linearIsometry f) (Eventually.of_forall ?_)\n    intro s\n    rw [SetLike.mem_coe]\n    refine sum_mem ?_\n    intro i _\n    refine mem_iSup_of_mem i ?_\n    exact LinearMap.mem_range_self _ (f i)\n  Â· apply topologicalClosure_minimal\n    Â· refine iSup_le ?_\n      rintro i x âŸ¨x, rflâŸ©\n      use lp.single 2 i x\n      exact hV.linearIsometry_apply_single x\n    exact hV.linearIsometry.isometry.isUniformInducing.isComplete_range.isClosed\n\n"}
{"name":"IsHilbertSum.OrthogonalFamily","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_2\ninstâœâ´ : RCLike ğ•œ\nE : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\nG : Î¹ â†’ Type u_4\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (G i)\ninstâœ : (i : Î¹) â†’ InnerProductSpace ğ•œ (G i)\nV : (i : Î¹) â†’ LinearIsometry (RingHom.id ğ•œ) (G i) E\nself : IsHilbertSum ğ•œ G V\nâŠ¢ OrthogonalFamily ğ•œ G V","decl":"/-- Given a family of Hilbert spaces `G : Î¹ â†’ Type*`, a Hilbert sum of `G` consists of a Hilbert\nspace `E` and an orthogonal family `V : Î  i, G i â†’â‚—áµ¢[ğ•œ] E` such that the induced isometry\n`Î¦ : lp G 2 â†’ E` is surjective.\n\nKeeping in mind that `lp G 2` is \"the\" external Hilbert sum of `G : Î¹ â†’ Type*`, this is analogous\nto `DirectSum.IsInternal`, except that we don't express it in terms of actual submodules. -/\nstructure IsHilbertSum : Prop where\n  ofSurjective ::\n  /-- The orthogonal family constituting the summands in the Hilbert sum. -/\n  protected OrthogonalFamily : OrthogonalFamily ğ•œ G V\n  /-- The isometry `lp G 2 â†’ E` induced by the orthogonal family is surjective. -/\n  protected surjective_isometry : Function.Surjective OrthogonalFamily.linearIsometry\n\n"}
{"name":"IsHilbertSum.surjective_isometry","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_2\ninstâœâ´ : RCLike ğ•œ\nE : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\nG : Î¹ â†’ Type u_4\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (G i)\ninstâœ : (i : Î¹) â†’ InnerProductSpace ğ•œ (G i)\nV : (i : Î¹) â†’ LinearIsometry (RingHom.id ğ•œ) (G i) E\nself : IsHilbertSum ğ•œ G V\nâŠ¢ Function.Surjective â‡‘â‹¯.linearIsometry","decl":"/-- Given a family of Hilbert spaces `G : Î¹ â†’ Type*`, a Hilbert sum of `G` consists of a Hilbert\nspace `E` and an orthogonal family `V : Î  i, G i â†’â‚—áµ¢[ğ•œ] E` such that the induced isometry\n`Î¦ : lp G 2 â†’ E` is surjective.\n\nKeeping in mind that `lp G 2` is \"the\" external Hilbert sum of `G : Î¹ â†’ Type*`, this is analogous\nto `DirectSum.IsInternal`, except that we don't express it in terms of actual submodules. -/\nstructure IsHilbertSum : Prop where\n  ofSurjective ::\n  /-- The orthogonal family constituting the summands in the Hilbert sum. -/\n  protected OrthogonalFamily : OrthogonalFamily ğ•œ G V\n  /-- The isometry `lp G 2 â†’ E` induced by the orthogonal family is surjective. -/\n  protected surjective_isometry : Function.Surjective OrthogonalFamily.linearIsometry\n\n"}
{"name":"IsHilbertSum.mk","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_2\ninstâœâ¶ : RCLike ğ•œ\nE : Type u_3\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : InnerProductSpace ğ•œ E\nG : Î¹ â†’ Type u_4\ninstâœÂ³ : (i : Î¹) â†’ NormedAddCommGroup (G i)\ninstâœÂ² : (i : Î¹) â†’ InnerProductSpace ğ•œ (G i)\ninstâœÂ¹ : CompleteSpace E\nV : (i : Î¹) â†’ LinearIsometry (RingHom.id ğ•œ) (G i) E\ninstâœ : âˆ€ (i : Î¹), CompleteSpace (G i)\nhVortho : OrthogonalFamily ğ•œ G V\nhVtotal : LE.le Top.top (iSup fun i => LinearMap.range (V i).toLinearMap).topologicalClosure\nâŠ¢ IsHilbertSum ğ•œ G V","decl":"/-- If `V : Î  i, G i â†’â‚—áµ¢[ğ•œ] E` is an orthogonal family such that the supremum of the ranges of\n`V i` is dense, then `(E, V)` is a Hilbert sum of `G`. -/\ntheorem IsHilbertSum.mk [âˆ€ i, CompleteSpace <| G i] (hVortho : OrthogonalFamily ğ•œ G V)\n    (hVtotal : âŠ¤ â‰¤ (â¨† i, LinearMap.range (V i).toLinearMap).topologicalClosure) :\n    IsHilbertSum ğ•œ G V :=\n  { OrthogonalFamily := hVortho\n    surjective_isometry := by\n      rw [â† LinearIsometry.coe_toLinearMap]\n      exact LinearMap.range_eq_top.mp\n        (eq_top_iff.mpr <| hVtotal.trans_eq hVortho.range_linearIsometry.symm) }\n\n"}
{"name":"IsHilbertSum.mkInternal","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_2\ninstâœâ´ : RCLike ğ•œ\nE : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\ninstâœÂ¹ : CompleteSpace E\nF : Î¹ â†’ Submodule ğ•œ E\ninstâœ : âˆ€ (i : Î¹), CompleteSpace (Subtype fun x => Membership.mem (F i) x)\nhFortho : OrthogonalFamily ğ•œ (fun i => Subtype fun x => Membership.mem (F i) x) fun i => (F i).subtypeâ‚—áµ¢\nhFtotal : LE.le Top.top (iSup fun i => F i).topologicalClosure\nâŠ¢ IsHilbertSum ğ•œ (fun i => Subtype fun x => Membership.mem (F i) x) fun i => (F i).subtypeâ‚—áµ¢","decl":"/-- This is `Orthonormal.isHilbertSum` in the case of actual inclusions from subspaces. -/\ntheorem IsHilbertSum.mkInternal [âˆ€ i, CompleteSpace <| F i]\n    (hFortho : OrthogonalFamily ğ•œ (fun i => F i) fun i => (F i).subtypeâ‚—áµ¢)\n    (hFtotal : âŠ¤ â‰¤ (â¨† i, F i).topologicalClosure) :\n    IsHilbertSum ğ•œ (fun i => F i) fun i => (F i).subtypeâ‚—áµ¢ :=\n  IsHilbertSum.mk hFortho (by simpa [subtypeâ‚—áµ¢_toLinearMap, range_subtype] using hFtotal)\n\n"}
{"name":"IsHilbertSum.linearIsometryEquiv_symm_apply","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_2\ninstâœâµ : RCLike ğ•œ\nE : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : InnerProductSpace ğ•œ E\nG : Î¹ â†’ Type u_4\ninstâœÂ² : (i : Î¹) â†’ NormedAddCommGroup (G i)\ninstâœÂ¹ : (i : Î¹) â†’ InnerProductSpace ğ•œ (G i)\ninstâœ : CompleteSpace E\nV : (i : Î¹) â†’ LinearIsometry (RingHom.id ğ•œ) (G i) E\nhV : IsHilbertSum ğ•œ G V\nw : Subtype fun x => Membership.mem (lp G 2) x\nâŠ¢ Eq (hV.linearIsometryEquiv.symm w) (tsum fun i => (V i) (â†‘w i))","decl":"/-- In the canonical isometric isomorphism between a Hilbert sum `E` of `G` and `lp G 2`,\na vector `w : lp G 2` is the image of the infinite sum of the associated elements in `E`. -/\nprotected theorem IsHilbertSum.linearIsometryEquiv_symm_apply (hV : IsHilbertSum ğ•œ G V)\n    (w : lp G 2) : hV.linearIsometryEquiv.symm w = âˆ‘' i, V i (w i) := by\n  simp [IsHilbertSum.linearIsometryEquiv, OrthogonalFamily.linearIsometry_apply]\n\n"}
{"name":"IsHilbertSum.hasSum_linearIsometryEquiv_symm","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_2\ninstâœâµ : RCLike ğ•œ\nE : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : InnerProductSpace ğ•œ E\nG : Î¹ â†’ Type u_4\ninstâœÂ² : (i : Î¹) â†’ NormedAddCommGroup (G i)\ninstâœÂ¹ : (i : Î¹) â†’ InnerProductSpace ğ•œ (G i)\ninstâœ : CompleteSpace E\nV : (i : Î¹) â†’ LinearIsometry (RingHom.id ğ•œ) (G i) E\nhV : IsHilbertSum ğ•œ G V\nw : Subtype fun x => Membership.mem (lp G 2) x\nâŠ¢ HasSum (fun i => (V i) (â†‘w i)) (hV.linearIsometryEquiv.symm w)","decl":"/-- In the canonical isometric isomorphism between a Hilbert sum `E` of `G` and `lp G 2`,\na vector `w : lp G 2` is the image of the infinite sum of the associated elements in `E`, and this\nsum indeed converges. -/\nprotected theorem IsHilbertSum.hasSum_linearIsometryEquiv_symm (hV : IsHilbertSum ğ•œ G V)\n    (w : lp G 2) : HasSum (fun i => V i (w i)) (hV.linearIsometryEquiv.symm w) := by\n  simp [IsHilbertSum.linearIsometryEquiv, OrthogonalFamily.hasSum_linearIsometry]\n\n"}
{"name":"IsHilbertSum.linearIsometryEquiv_symm_apply_single","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_2\ninstâœâ¶ : RCLike ğ•œ\nE : Type u_3\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : InnerProductSpace ğ•œ E\nG : Î¹ â†’ Type u_4\ninstâœÂ³ : (i : Î¹) â†’ NormedAddCommGroup (G i)\ninstâœÂ² : (i : Î¹) â†’ InnerProductSpace ğ•œ (G i)\ninstâœÂ¹ : CompleteSpace E\nV : (i : Î¹) â†’ LinearIsometry (RingHom.id ğ•œ) (G i) E\ninstâœ : DecidableEq Î¹\nhV : IsHilbertSum ğ•œ G V\ni : Î¹\nx : G i\nâŠ¢ Eq (hV.linearIsometryEquiv.symm (lp.single 2 i x)) ((V i) x)","decl":"/-- In the canonical isometric isomorphism between a Hilbert sum `E` of `G : Î¹ â†’ Type*` and\n`lp G 2`, an \"elementary basis vector\" in `lp G 2` supported at `i : Î¹` is the image of the\nassociated element in `E`. -/\n@[simp]\nprotected theorem IsHilbertSum.linearIsometryEquiv_symm_apply_single\n    [DecidableEq Î¹] (hV : IsHilbertSum ğ•œ G V) {i : Î¹} (x : G i) :\n    hV.linearIsometryEquiv.symm (lp.single 2 i x) = V i x := by\n  simp [IsHilbertSum.linearIsometryEquiv, OrthogonalFamily.linearIsometry_apply_single]\n\n"}
{"name":"IsHilbertSum.linearIsometryEquiv_symm_apply_dfinsupp_sum_single","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_2\ninstâœâ· : RCLike ğ•œ\nE : Type u_3\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : InnerProductSpace ğ•œ E\nG : Î¹ â†’ Type u_4\ninstâœâ´ : (i : Î¹) â†’ NormedAddCommGroup (G i)\ninstâœÂ³ : (i : Î¹) â†’ InnerProductSpace ğ•œ (G i)\ninstâœÂ² : CompleteSpace E\nV : (i : Î¹) â†’ LinearIsometry (RingHom.id ğ•œ) (G i) E\ninstâœÂ¹ : DecidableEq Î¹\ninstâœ : (i : Î¹) â†’ DecidableEq (G i)\nhV : IsHilbertSum ğ•œ G V\nWâ‚€ : DFinsupp fun i => G i\nâŠ¢ Eq (hV.linearIsometryEquiv.symm (Wâ‚€.sum (lp.single 2))) (Wâ‚€.sum fun i => â‡‘(V i))","decl":"/-- In the canonical isometric isomorphism between a Hilbert sum `E` of `G : Î¹ â†’ Type*` and\n`lp G 2`, a finitely-supported vector in `lp G 2` is the image of the associated finite sum of\nelements of `E`. -/\nprotected theorem IsHilbertSum.linearIsometryEquiv_symm_apply_dfinsupp_sum_single\n    [DecidableEq Î¹] [âˆ€ i, DecidableEq (G i)] (hV : IsHilbertSum ğ•œ G V) (Wâ‚€ : Î â‚€ i : Î¹, G i) :\n    hV.linearIsometryEquiv.symm (Wâ‚€.sum (lp.single 2)) = Wâ‚€.sum fun i => V i := by\n  simp only [map_dfinsupp_sum, IsHilbertSum.linearIsometryEquiv_symm_apply_single]\n\n"}
{"name":"IsHilbertSum.linearIsometryEquiv_apply_dfinsupp_sum_single","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_2\ninstâœâ· : RCLike ğ•œ\nE : Type u_3\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : InnerProductSpace ğ•œ E\nG : Î¹ â†’ Type u_4\ninstâœâ´ : (i : Î¹) â†’ NormedAddCommGroup (G i)\ninstâœÂ³ : (i : Î¹) â†’ InnerProductSpace ğ•œ (G i)\ninstâœÂ² : CompleteSpace E\nV : (i : Î¹) â†’ LinearIsometry (RingHom.id ğ•œ) (G i) E\ninstâœÂ¹ : DecidableEq Î¹\ninstâœ : (i : Î¹) â†’ DecidableEq (G i)\nhV : IsHilbertSum ğ•œ G V\nWâ‚€ : DFinsupp fun i => G i\nâŠ¢ Eq â†‘(Wâ‚€.sum fun a b => hV.linearIsometryEquiv ((V a) b)) â‡‘Wâ‚€","decl":"/-- In the canonical isometric isomorphism between a Hilbert sum `E` of `G : Î¹ â†’ Type*` and\n`lp G 2`, a finitely-supported vector in `lp G 2` is the image of the associated finite sum of\nelements of `E`. -/\n@[simp]\nprotected theorem IsHilbertSum.linearIsometryEquiv_apply_dfinsupp_sum_single\n    [DecidableEq Î¹] [âˆ€ i, DecidableEq (G i)] (hV : IsHilbertSum ğ•œ G V) (Wâ‚€ : Î â‚€ i : Î¹, G i) :\n    ((Wâ‚€.sum (Î³ := lp G 2) fun a b â†¦ hV.linearIsometryEquiv (V a b)) : âˆ€ i, G i) = Wâ‚€ := by\n  rw [â† map_dfinsupp_sum]\n  rw [â† hV.linearIsometryEquiv_symm_apply_dfinsupp_sum_single]\n  rw [LinearIsometryEquiv.apply_symm_apply]\n  ext i\n  simp +contextual [DFinsupp.sum, lp.single_apply]\n\n"}
{"name":"Orthonormal.isHilbertSum","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_2\ninstâœÂ³ : RCLike ğ•œ\nE : Type u_3\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : CompleteSpace E\nv : Î¹ â†’ E\nhv : Orthonormal ğ•œ v\nhsp : LE.le Top.top (Submodule.span ğ•œ (Set.range v)).topologicalClosure\nâŠ¢ IsHilbertSum ğ•œ (fun x => ğ•œ) fun i => LinearIsometry.toSpanSingleton ğ•œ E â‹¯","decl":"/-- Given a total orthonormal family `v : Î¹ â†’ E`, `E` is a Hilbert sum of `fun i : Î¹ => ğ•œ`\nrelative to the family of linear isometries `fun i k => k â€¢ v i`. -/\ntheorem Orthonormal.isHilbertSum {v : Î¹ â†’ E} (hv : Orthonormal ğ•œ v)\n    (hsp : âŠ¤ â‰¤ (span ğ•œ (Set.range v)).topologicalClosure) :\n    IsHilbertSum ğ•œ (fun _ : Î¹ => ğ•œ) fun i => LinearIsometry.toSpanSingleton ğ•œ E (hv.1 i) :=\n  IsHilbertSum.mk hv.orthogonalFamily (by\n    convert hsp\n    simp [â† LinearMap.span_singleton_eq_range, â† Submodule.span_iUnion])\n\n"}
{"name":"Submodule.isHilbertSumOrthogonal","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"ğ•œ : Type u_2\ninstâœÂ³ : RCLike ğ•œ\nE : Type u_3\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : CompleteSpace E\nK : Submodule ğ•œ E\nhK : CompleteSpace (Subtype fun x => Membership.mem K x)\nâŠ¢ IsHilbertSum ğ•œ (fun b => Subtype fun x => Membership.mem (cond b K K.orthogonal) x) fun b => (cond b K K.orthogonal).subtypeâ‚—áµ¢","decl":"theorem Submodule.isHilbertSumOrthogonal (K : Submodule ğ•œ E) [hK : CompleteSpace K] :\n    IsHilbertSum ğ•œ (fun b => â†¥(cond b K Ká—®)) fun b => (cond b K Ká—®).subtypeâ‚—áµ¢ := by\n  have : âˆ€ b, CompleteSpace (â†¥(cond b K Ká—®)) := by\n    intro b\n    cases b <;> first | exact instOrthogonalCompleteSpace K | assumption\n  refine IsHilbertSum.mkInternal _ K.orthogonalFamily_self ?_\n  refine le_trans ?_ (Submodule.le_topologicalClosure _)\n  rw [iSup_bool_eq, cond, cond]\n  refine Codisjoint.top_le ?_\n  exact Submodule.isCompl_orthogonal_of_completeSpace.codisjoint\n\n"}
{"name":"HilbertBasis.ofRepr.sizeOf_spec","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_2\ninstâœâµ : RCLike ğ•œ\nE : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : InnerProductSpace ğ•œ E\ninstâœÂ² : SizeOf Î¹\ninstâœÂ¹ : SizeOf ğ•œ\ninstâœ : SizeOf E\nrepr : LinearIsometryEquiv (RingHom.id ğ•œ) E (Subtype fun x => Membership.mem (lp (fun i => ğ•œ) 2) x)\nâŠ¢ Eq (SizeOf.sizeOf { repr := repr }) (HAdd.hAdd 1 (SizeOf.sizeOf repr))","decl":"/-- A Hilbert basis on `Î¹` for an inner product space `E` is an identification of `E` with the `lp`\nspace `â„“Â²(Î¹, ğ•œ)`. -/\nstructure HilbertBasis where ofRepr ::\n  /-- The linear isometric equivalence implementing identifying the Hilbert space with `â„“Â²`. -/\n  repr : E â‰ƒâ‚—áµ¢[ğ•œ] â„“Â²(Î¹, ğ•œ)\n\n"}
{"name":"HilbertBasis.ofRepr.inj","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_2\ninstâœÂ² : RCLike ğ•œ\nE : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nreprâœ repr : LinearIsometryEquiv (RingHom.id ğ•œ) E (Subtype fun x => Membership.mem (lp (fun i => ğ•œ) 2) x)\nxâœ : Eq { repr := reprâœ } { repr := repr }\nâŠ¢ Eq reprâœ repr","decl":"/-- A Hilbert basis on `Î¹` for an inner product space `E` is an identification of `E` with the `lp`\nspace `â„“Â²(Î¹, ğ•œ)`. -/\nstructure HilbertBasis where ofRepr ::\n  /-- The linear isometric equivalence implementing identifying the Hilbert space with `â„“Â²`. -/\n  repr : E â‰ƒâ‚—áµ¢[ğ•œ] â„“Â²(Î¹, ğ•œ)\n\n"}
{"name":"HilbertBasis.ofRepr.injEq","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_2\ninstâœÂ² : RCLike ğ•œ\nE : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nreprâœ repr : LinearIsometryEquiv (RingHom.id ğ•œ) E (Subtype fun x => Membership.mem (lp (fun i => ğ•œ) 2) x)\nâŠ¢ Eq (Eq { repr := reprâœ } { repr := repr }) (Eq reprâœ repr)","decl":"/-- A Hilbert basis on `Î¹` for an inner product space `E` is an identification of `E` with the `lp`\nspace `â„“Â²(Î¹, ğ•œ)`. -/\nstructure HilbertBasis where ofRepr ::\n  /-- The linear isometric equivalence implementing identifying the Hilbert space with `â„“Â²`. -/\n  repr : E â‰ƒâ‚—áµ¢[ğ•œ] â„“Â²(Î¹, ğ•œ)\n\n"}
{"name":"HilbertBasis.repr_symm_single","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_2\ninstâœÂ³ : RCLike ğ•œ\nE : Type u_3\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : DecidableEq Î¹\nb : HilbertBasis Î¹ ğ•œ E\ni : Î¹\nâŠ¢ Eq (b.repr.symm (lp.single 2 i 1)) ((fun i => b.repr.symm (lp.single 2 i 1)) i)","decl":"protected theorem repr_symm_single [DecidableEq Î¹] (b : HilbertBasis Î¹ ğ•œ E) (i : Î¹) :\n    b.repr.symm (lp.single 2 i (1 : ğ•œ)) = b i := by\n  convert rfl\n\n"}
{"name":"HilbertBasis.repr_self","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_2\ninstâœÂ³ : RCLike ğ•œ\nE : Type u_3\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : DecidableEq Î¹\nb : HilbertBasis Î¹ ğ•œ E\ni : Î¹\nâŠ¢ Eq (b.repr ((fun i => b.repr.symm (lp.single 2 i 1)) i)) (lp.single 2 i 1)","decl":"protected theorem repr_self [DecidableEq Î¹] (b : HilbertBasis Î¹ ğ•œ E) (i : Î¹) :\n    b.repr (b i) = lp.single 2 i (1 : ğ•œ) := by\n  simp only [LinearIsometryEquiv.apply_symm_apply]\n  convert rfl\n\n"}
{"name":"HilbertBasis.repr_apply_apply","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_2\ninstâœÂ² : RCLike ğ•œ\nE : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nb : HilbertBasis Î¹ ğ•œ E\nv : E\ni : Î¹\nâŠ¢ Eq (â†‘(b.repr v) i) (Inner.inner ((fun i => b.repr.symm (lp.single 2 i 1)) i) v)","decl":"protected theorem repr_apply_apply (b : HilbertBasis Î¹ ğ•œ E) (v : E) (i : Î¹) :\n    b.repr v i = âŸªb i, vâŸ« := by\n  classical\n  rw [â† b.repr.inner_map_map (b i) v, b.repr_self, lp.inner_single_left]\n  simp\n\n"}
{"name":"HilbertBasis.orthonormal","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_2\ninstâœÂ² : RCLike ğ•œ\nE : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nb : HilbertBasis Î¹ ğ•œ E\nâŠ¢ Orthonormal ğ•œ fun i => b.repr.symm (lp.single 2 i 1)","decl":"@[simp]\nprotected theorem orthonormal (b : HilbertBasis Î¹ ğ•œ E) : Orthonormal ğ•œ b := by\n  classical\n  rw [orthonormal_iff_ite]\n  intro i j\n  rw [â† b.repr.inner_map_map (b i) (b j), b.repr_self, b.repr_self, lp.inner_single_left,\n    lp.single_apply]\n  simp\n\n"}
{"name":"HilbertBasis.hasSum_repr_symm","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_2\ninstâœÂ² : RCLike ğ•œ\nE : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nb : HilbertBasis Î¹ ğ•œ E\nf : Subtype fun x => Membership.mem (lp (fun i => ğ•œ) 2) x\nâŠ¢ HasSum (fun i => HSMul.hSMul (â†‘f i) ((fun i => b.repr.symm (lp.single 2 i 1)) i)) (b.repr.symm f)","decl":"protected theorem hasSum_repr_symm (b : HilbertBasis Î¹ ğ•œ E) (f : â„“Â²(Î¹, ğ•œ)) :\n    HasSum (fun i => f i â€¢ b i) (b.repr.symm f) := by\n  classical\n  suffices H : (fun i : Î¹ => f i â€¢ b i) = fun b_1 : Î¹ => b.repr.symm.toContinuousLinearEquiv <|\n      (fun i : Î¹ => lp.single 2 i (f i) (E := (fun _ : Î¹ => ğ•œ))) b_1 by\n    rw [H]\n    have : HasSum (fun i : Î¹ => lp.single 2 i (f i)) f := lp.hasSum_single ENNReal.ofNat_ne_top f\n    exact (â†‘b.repr.symm.toContinuousLinearEquiv : â„“Â²(Î¹, ğ•œ) â†’L[ğ•œ] E).hasSum this\n  ext i\n  apply b.repr.injective\n  letI : NormedSpace ğ•œ (lp (fun _i : Î¹ => ğ•œ) 2) := by infer_instance\n  have : lp.single (E := (fun _ : Î¹ => ğ•œ)) 2 i (f i * 1) = f i â€¢ lp.single 2 i 1 :=\n    lp.single_smul (E := (fun _ : Î¹ => ğ•œ)) 2 i (1 : ğ•œ) (f i)\n  rw [mul_one] at this\n  rw [LinearIsometryEquiv.map_smul, b.repr_self, â† this,\n    LinearIsometryEquiv.coe_toContinuousLinearEquiv]\n  exact (b.repr.apply_symm_apply (lp.single 2 i (f i))).symm\n\n"}
{"name":"HilbertBasis.hasSum_repr","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_2\ninstâœÂ² : RCLike ğ•œ\nE : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nb : HilbertBasis Î¹ ğ•œ E\nx : E\nâŠ¢ HasSum (fun i => HSMul.hSMul (â†‘(b.repr x) i) ((fun i => b.repr.symm (lp.single 2 i 1)) i)) x","decl":"protected theorem hasSum_repr (b : HilbertBasis Î¹ ğ•œ E) (x : E) :\n    HasSum (fun i => b.repr x i â€¢ b i) x := by simpa using b.hasSum_repr_symm (b.repr x)\n\n"}
{"name":"HilbertBasis.dense_span","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_2\ninstâœÂ² : RCLike ğ•œ\nE : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nb : HilbertBasis Î¹ ğ•œ E\nâŠ¢ Eq (Submodule.span ğ•œ (Set.range fun i => b.repr.symm (lp.single 2 i 1))).topologicalClosure Top.top","decl":"@[simp]\nprotected theorem dense_span (b : HilbertBasis Î¹ ğ•œ E) :\n    (span ğ•œ (Set.range b)).topologicalClosure = âŠ¤ := by\n  classical\n    rw [eq_top_iff]\n    rintro x -\n    refine mem_closure_of_tendsto (b.hasSum_repr x) (Eventually.of_forall ?_)\n    intro s\n    simp only [SetLike.mem_coe]\n    refine sum_mem ?_\n    rintro i -\n    refine smul_mem _ _ ?_\n    exact subset_span âŸ¨i, rflâŸ©\n\n"}
{"name":"HilbertBasis.hasSum_inner_mul_inner","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_2\ninstâœÂ² : RCLike ğ•œ\nE : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nb : HilbertBasis Î¹ ğ•œ E\nx y : E\nâŠ¢ HasSum (fun i => HMul.hMul (Inner.inner x ((fun i => b.repr.symm (lp.single 2 i 1)) i)) (Inner.inner ((fun i => b.repr.symm (lp.single 2 i 1)) i) y)) (Inner.inner x y)","decl":"protected theorem hasSum_inner_mul_inner (b : HilbertBasis Î¹ ğ•œ E) (x y : E) :\n    HasSum (fun i => âŸªx, b iâŸ« * âŸªb i, yâŸ«) âŸªx, yâŸ« := by\n  convert (b.hasSum_repr y).mapL (innerSL ğ•œ x) using 1\n  ext i\n  rw [innerSL_apply, b.repr_apply_apply, inner_smul_right, mul_comm]\n\n"}
{"name":"HilbertBasis.summable_inner_mul_inner","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_2\ninstâœÂ² : RCLike ğ•œ\nE : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nb : HilbertBasis Î¹ ğ•œ E\nx y : E\nâŠ¢ Summable fun i => HMul.hMul (Inner.inner x ((fun i => b.repr.symm (lp.single 2 i 1)) i)) (Inner.inner ((fun i => b.repr.symm (lp.single 2 i 1)) i) y)","decl":"protected theorem summable_inner_mul_inner (b : HilbertBasis Î¹ ğ•œ E) (x y : E) :\n    Summable fun i => âŸªx, b iâŸ« * âŸªb i, yâŸ« :=\n  (b.hasSum_inner_mul_inner x y).summable\n\n"}
{"name":"HilbertBasis.tsum_inner_mul_inner","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_2\ninstâœÂ² : RCLike ğ•œ\nE : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nb : HilbertBasis Î¹ ğ•œ E\nx y : E\nâŠ¢ Eq (tsum fun i => HMul.hMul (Inner.inner x ((fun i => b.repr.symm (lp.single 2 i 1)) i)) (Inner.inner ((fun i => b.repr.symm (lp.single 2 i 1)) i) y)) (Inner.inner x y)","decl":"protected theorem tsum_inner_mul_inner (b : HilbertBasis Î¹ ğ•œ E) (x y : E) :\n    âˆ‘' i, âŸªx, b iâŸ« * âŸªb i, yâŸ« = âŸªx, yâŸ« :=\n  (b.hasSum_inner_mul_inner x y).tsum_eq\n\n-- Note: this should be `b.repr` composed with an identification of `lp (fun i : Î¹ => ğ•œ) p` with\n-- `PiLp p (fun i : Î¹ => ğ•œ)` (in this case with `p = 2`), but we don't have this yet (July 2022).\n"}
{"name":"HilbertBasis.coe_toOrthonormalBasis","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_2\ninstâœÂ³ : RCLike ğ•œ\nE : Type u_3\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : Fintype Î¹\nb : HilbertBasis Î¹ ğ•œ E\nâŠ¢ Eq â‡‘b.toOrthonormalBasis fun i => b.repr.symm (lp.single 2 i 1)","decl":"@[simp]\ntheorem coe_toOrthonormalBasis [Fintype Î¹] (b : HilbertBasis Î¹ ğ•œ E) :\n    (b.toOrthonormalBasis : Î¹ â†’ E) = b :=\n  OrthonormalBasis.coe_mk _ _\n\n"}
{"name":"HilbertBasis.hasSum_orthogonalProjection","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_2\ninstâœÂ³ : RCLike ğ•œ\nE : Type u_3\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nU : Submodule ğ•œ E\ninstâœ : CompleteSpace (Subtype fun x => Membership.mem U x)\nb : HilbertBasis Î¹ ğ•œ (Subtype fun x => Membership.mem U x)\nx : E\nâŠ¢ HasSum (fun i => HSMul.hSMul (Inner.inner (â†‘((fun i => b.repr.symm (lp.single 2 i 1)) i)) x) ((fun i => b.repr.symm (lp.single 2 i 1)) i)) ((orthogonalProjection U) x)","decl":"protected theorem hasSum_orthogonalProjection {U : Submodule ğ•œ E} [CompleteSpace U]\n    (b : HilbertBasis Î¹ ğ•œ U) (x : E) :\n    HasSum (fun i => âŸª(b i : E), xâŸ« â€¢ b i) (orthogonalProjection U x) := by\n  simpa only [b.repr_apply_apply, inner_orthogonalProjection_eq_of_mem_left] using\n    b.hasSum_repr (orthogonalProjection U x)\n\n"}
{"name":"HilbertBasis.finite_spans_dense","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_2\ninstâœÂ³ : RCLike ğ•œ\nE : Type u_3\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : DecidableEq E\nb : HilbertBasis Î¹ ğ•œ E\nâŠ¢ Eq (iSup fun J => Submodule.span ğ•œ â†‘(Finset.image (fun i => b.repr.symm (lp.single 2 i 1)) J)).topologicalClosure Top.top","decl":"theorem finite_spans_dense [DecidableEq E] (b : HilbertBasis Î¹ ğ•œ E) :\n    (â¨† J : Finset Î¹, span ğ•œ (J.image b : Set E)).topologicalClosure = âŠ¤ :=\n  eq_top_iff.mpr <| b.dense_span.ge.trans (by\n    simp_rw [â† Submodule.span_iUnion]\n    exact topologicalClosure_mono (span_mono <| Set.range_subset_iff.mpr fun i =>\n      Set.mem_iUnion_of_mem {i} <| Finset.mem_coe.mpr <| Finset.mem_image_of_mem _ <|\n      Finset.mem_singleton_self i))\n\n"}
{"name":"Orthonormal.linearIsometryEquiv_symm_apply_single_one","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_2\ninstâœâ´ : RCLike ğ•œ\nE : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\ninstâœÂ¹ : CompleteSpace E\nv : Î¹ â†’ E\nhv : Orthonormal ğ•œ v\ninstâœ : DecidableEq Î¹\nh : LE.le Top.top (Submodule.span ğ•œ (Set.range v)).topologicalClosure\ni : Î¹\nâŠ¢ Eq (â‹¯.linearIsometryEquiv.symm (lp.single 2 i 1)) (v i)","decl":"theorem _root_.Orthonormal.linearIsometryEquiv_symm_apply_single_one [DecidableEq Î¹] (h i) :\n    (hv.isHilbertSum h).linearIsometryEquiv.symm (lp.single 2 i 1) = v i := by\n  rw [IsHilbertSum.linearIsometryEquiv_symm_apply_single, LinearIsometry.toSpanSingleton_apply,\n    one_smul]\n\n"}
{"name":"HilbertBasis.coe_mk","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_2\ninstâœÂ³ : RCLike ğ•œ\nE : Type u_3\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : CompleteSpace E\nv : Î¹ â†’ E\nhv : Orthonormal ğ•œ v\nhsp : LE.le Top.top (Submodule.span ğ•œ (Set.range v)).topologicalClosure\nâŠ¢ Eq (fun i => (HilbertBasis.mk hv hsp).repr.symm (lp.single 2 i 1)) v","decl":"@[simp]\nprotected theorem coe_mk (hsp : âŠ¤ â‰¤ (span ğ•œ (Set.range v)).topologicalClosure) :\n    â‡‘(HilbertBasis.mk hv hsp) = v := by\n  classical\n  apply funext <| Orthonormal.linearIsometryEquiv_symm_apply_single_one hv hsp\n\n"}
{"name":"HilbertBasis.coe_mkOfOrthogonalEqBot","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_2\ninstâœÂ³ : RCLike ğ•œ\nE : Type u_3\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : CompleteSpace E\nv : Î¹ â†’ E\nhv : Orthonormal ğ•œ v\nhsp : Eq (Submodule.span ğ•œ (Set.range v)).orthogonal Bot.bot\nâŠ¢ Eq (fun i => (HilbertBasis.mkOfOrthogonalEqBot hv hsp).repr.symm (lp.single 2 i 1)) v","decl":"@[simp]\nprotected theorem coe_mkOfOrthogonalEqBot (hsp : (span ğ•œ (Set.range v))á—® = âŠ¥) :\n    â‡‘(HilbertBasis.mkOfOrthogonalEqBot hv hsp) = v :=\n  HilbertBasis.coe_mk hv _\n\n-- Note : this should be `b.repr` composed with an identification of `lp (fun i : Î¹ => ğ•œ) p` with\n-- `PiLp p (fun i : Î¹ => ğ•œ)` (in this case with `p = 2`), but we don't have this yet (July 2022).\n"}
{"name":"OrthonormalBasis.coe_toHilbertBasis","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_2\ninstâœâ´ : RCLike ğ•œ\nE : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\ninstâœÂ¹ : CompleteSpace E\ninstâœ : Fintype Î¹\nb : OrthonormalBasis Î¹ ğ•œ E\nâŠ¢ Eq (fun i => b.toHilbertBasis.repr.symm (lp.single 2 i 1)) â‡‘b","decl":"@[simp]\ntheorem _root_.OrthonormalBasis.coe_toHilbertBasis [Fintype Î¹] (b : OrthonormalBasis Î¹ ğ•œ E) :\n    (b.toHilbertBasis : Î¹ â†’ E) = b :=\n  HilbertBasis.coe_mk _ _\n\n"}
{"name":"Orthonormal.exists_hilbertBasis_extension","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"ğ•œ : Type u_2\ninstâœÂ³ : RCLike ğ•œ\nE : Type u_3\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : CompleteSpace E\ns : Set E\nhs : Orthonormal ğ•œ Subtype.val\nâŠ¢ Exists fun w => Exists fun b => And (HasSubset.Subset s w) (Eq (fun i => b.repr.symm (lp.single 2 i 1)) Subtype.val)","decl":"/-- A Hilbert space admits a Hilbert basis extending a given orthonormal subset. -/\ntheorem _root_.Orthonormal.exists_hilbertBasis_extension {s : Set E}\n    (hs : Orthonormal ğ•œ ((â†‘) : s â†’ E)) :\n    âˆƒ (w : Set E) (b : HilbertBasis w ğ•œ E), s âŠ† w âˆ§ â‡‘b = ((â†‘) : w â†’ E) :=\n  let âŸ¨w, hws, hw_ortho, hw_maxâŸ© := exists_maximal_orthonormal hs\n  âŸ¨w, HilbertBasis.mkOfOrthogonalEqBot hw_ortho\n    (by simpa only [Subtype.range_coe_subtype, Set.setOf_mem_eq,\n      maximal_orthonormal_iff_orthogonalComplement_eq_bot hw_ortho] using hw_max),\n    hws, HilbertBasis.coe_mkOfOrthogonalEqBot _ _âŸ©\n\n"}
{"name":"exists_hilbertBasis","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"ğ•œ : Type u_2\ninstâœÂ³ : RCLike ğ•œ\nE : Type u_3\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : CompleteSpace E\nâŠ¢ Exists fun w => Exists fun b => Eq (fun i => b.repr.symm (lp.single 2 i 1)) Subtype.val","decl":"/-- A Hilbert space admits a Hilbert basis. -/\ntheorem _root_.exists_hilbertBasis : âˆƒ (w : Set E) (b : HilbertBasis w ğ•œ E), â‡‘b = ((â†‘) : w â†’ E) :=\n  let âŸ¨w, hw, _, hw''âŸ© := (orthonormal_empty ğ•œ E).exists_hilbertBasis_extension\n  âŸ¨w, hw, hw''âŸ©\n\n"}
