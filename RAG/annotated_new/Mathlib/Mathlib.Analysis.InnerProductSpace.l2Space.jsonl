{"name":"lp.summable_inner","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"ι : Type u_1\n𝕜 : Type u_2\ninst✝² : RCLike 𝕜\nG : ι → Type u_4\ninst✝¹ : (i : ι) → NormedAddCommGroup (G i)\ninst✝ : (i : ι) → InnerProductSpace 𝕜 (G i)\nf g : Subtype fun x => Membership.mem (lp G 2) x\n⊢ Summable fun i => Inner.inner (↑f i) (↑g i)","decl":"theorem summable_inner (f g : lp G 2) : Summable fun i => ⟪f i, g i⟫ := by\n  -- Apply the Direct Comparison Test, comparing with ∑' i, ‖f i‖ * ‖g i‖ (summable by Hölder)\n  refine .of_norm_bounded (fun i => ‖f i‖ * ‖g i‖) (lp.summable_mul ?_ f g) ?_\n  · rw [Real.isConjExponent_iff]; norm_num\n  intro i\n  -- Then apply Cauchy-Schwarz pointwise\n  exact norm_inner_le_norm (𝕜 := 𝕜) _ _\n\n"}
{"name":"lp.inner_eq_tsum","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"ι : Type u_1\n𝕜 : Type u_2\ninst✝² : RCLike 𝕜\nG : ι → Type u_4\ninst✝¹ : (i : ι) → NormedAddCommGroup (G i)\ninst✝ : (i : ι) → InnerProductSpace 𝕜 (G i)\nf g : Subtype fun x => Membership.mem (lp G 2) x\n⊢ Eq (Inner.inner f g) (tsum fun i => Inner.inner (↑f i) (↑g i))","decl":"theorem inner_eq_tsum (f g : lp G 2) : ⟪f, g⟫ = ∑' i, ⟪f i, g i⟫ :=\n  rfl\n\n"}
{"name":"lp.hasSum_inner","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"ι : Type u_1\n𝕜 : Type u_2\ninst✝² : RCLike 𝕜\nG : ι → Type u_4\ninst✝¹ : (i : ι) → NormedAddCommGroup (G i)\ninst✝ : (i : ι) → InnerProductSpace 𝕜 (G i)\nf g : Subtype fun x => Membership.mem (lp G 2) x\n⊢ HasSum (fun i => Inner.inner (↑f i) (↑g i)) (Inner.inner f g)","decl":"theorem hasSum_inner (f g : lp G 2) : HasSum (fun i => ⟪f i, g i⟫) ⟪f, g⟫ :=\n  (summable_inner f g).hasSum\n\n"}
{"name":"lp.inner_single_left","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"ι : Type u_1\n𝕜 : Type u_2\ninst✝³ : RCLike 𝕜\nG : ι → Type u_4\ninst✝² : (i : ι) → NormedAddCommGroup (G i)\ninst✝¹ : (i : ι) → InnerProductSpace 𝕜 (G i)\ninst✝ : DecidableEq ι\ni : ι\na : G i\nf : Subtype fun x => Membership.mem (lp G 2) x\n⊢ Eq (Inner.inner (lp.single 2 i a) f) (Inner.inner a (↑f i))","decl":"theorem inner_single_left [DecidableEq ι] (i : ι) (a : G i) (f : lp G 2) :\n    ⟪lp.single 2 i a, f⟫ = ⟪a, f i⟫ := by\n  refine (hasSum_inner (lp.single 2 i a) f).unique ?_\n  convert hasSum_ite_eq i ⟪a, f i⟫ using 1\n  ext j\n  rw [lp.single_apply]\n  split_ifs with h\n  · subst h; rfl\n  · simp\n\n"}
{"name":"lp.inner_single_right","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"ι : Type u_1\n𝕜 : Type u_2\ninst✝³ : RCLike 𝕜\nG : ι → Type u_4\ninst✝² : (i : ι) → NormedAddCommGroup (G i)\ninst✝¹ : (i : ι) → InnerProductSpace 𝕜 (G i)\ninst✝ : DecidableEq ι\ni : ι\na : G i\nf : Subtype fun x => Membership.mem (lp G 2) x\n⊢ Eq (Inner.inner f (lp.single 2 i a)) (Inner.inner (↑f i) a)","decl":"theorem inner_single_right [DecidableEq ι] (i : ι) (a : G i) (f : lp G 2) :\n    ⟪f, lp.single 2 i a⟫ = ⟪f i, a⟫ := by\n  simpa [inner_conj_symm] using congr_arg conj (inner_single_left (𝕜 := 𝕜) i a f)\n\n"}
{"name":"OrthogonalFamily.summable_of_lp","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"ι : Type u_1\n𝕜 : Type u_2\ninst✝⁵ : RCLike 𝕜\nE : Type u_3\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : InnerProductSpace 𝕜 E\nG : ι → Type u_4\ninst✝² : (i : ι) → NormedAddCommGroup (G i)\ninst✝¹ : (i : ι) → InnerProductSpace 𝕜 (G i)\ninst✝ : CompleteSpace E\nV : (i : ι) → LinearIsometry (RingHom.id 𝕜) (G i) E\nhV : OrthogonalFamily 𝕜 G V\nf : Subtype fun x => Membership.mem (lp G 2) x\n⊢ Summable fun i => (V i) (↑f i)","decl":"protected theorem summable_of_lp (f : lp G 2) :\n    Summable fun i => V i (f i) := by\n  rw [hV.summable_iff_norm_sq_summable]\n  convert (lp.memℓp f).summable _\n  · norm_cast\n  · norm_num\n\n"}
{"name":"OrthogonalFamily.linearIsometry_apply","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"ι : Type u_1\n𝕜 : Type u_2\ninst✝⁵ : RCLike 𝕜\nE : Type u_3\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : InnerProductSpace 𝕜 E\nG : ι → Type u_4\ninst✝² : (i : ι) → NormedAddCommGroup (G i)\ninst✝¹ : (i : ι) → InnerProductSpace 𝕜 (G i)\ninst✝ : CompleteSpace E\nV : (i : ι) → LinearIsometry (RingHom.id 𝕜) (G i) E\nhV : OrthogonalFamily 𝕜 G V\nf : Subtype fun x => Membership.mem (lp G 2) x\n⊢ Eq (hV.linearIsometry f) (tsum fun i => (V i) (↑f i))","decl":"protected theorem linearIsometry_apply (f : lp G 2) : hV.linearIsometry f = ∑' i, V i (f i) :=\n  rfl\n\n"}
{"name":"OrthogonalFamily.hasSum_linearIsometry","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"ι : Type u_1\n𝕜 : Type u_2\ninst✝⁵ : RCLike 𝕜\nE : Type u_3\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : InnerProductSpace 𝕜 E\nG : ι → Type u_4\ninst✝² : (i : ι) → NormedAddCommGroup (G i)\ninst✝¹ : (i : ι) → InnerProductSpace 𝕜 (G i)\ninst✝ : CompleteSpace E\nV : (i : ι) → LinearIsometry (RingHom.id 𝕜) (G i) E\nhV : OrthogonalFamily 𝕜 G V\nf : Subtype fun x => Membership.mem (lp G 2) x\n⊢ HasSum (fun i => (V i) (↑f i)) (hV.linearIsometry f)","decl":"protected theorem hasSum_linearIsometry (f : lp G 2) :\n    HasSum (fun i => V i (f i)) (hV.linearIsometry f) :=\n  (hV.summable_of_lp f).hasSum\n\n"}
{"name":"OrthogonalFamily.linearIsometry_apply_single","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"ι : Type u_1\n𝕜 : Type u_2\ninst✝⁶ : RCLike 𝕜\nE : Type u_3\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : InnerProductSpace 𝕜 E\nG : ι → Type u_4\ninst✝³ : (i : ι) → NormedAddCommGroup (G i)\ninst✝² : (i : ι) → InnerProductSpace 𝕜 (G i)\ninst✝¹ : CompleteSpace E\nV : (i : ι) → LinearIsometry (RingHom.id 𝕜) (G i) E\nhV : OrthogonalFamily 𝕜 G V\ninst✝ : DecidableEq ι\ni : ι\nx : G i\n⊢ Eq (hV.linearIsometry (lp.single 2 i x)) ((V i) x)","decl":"@[simp]\nprotected theorem linearIsometry_apply_single [DecidableEq ι] {i : ι} (x : G i) :\n    hV.linearIsometry (lp.single 2 i x) = V i x := by\n  rw [hV.linearIsometry_apply, ← tsum_ite_eq i (V i x)]\n  congr\n  ext j\n  rw [lp.single_apply]\n  split_ifs with h\n  · subst h; simp\n  · simp [h]\n\n"}
{"name":"OrthogonalFamily.linearIsometry_apply_dfinsupp_sum_single","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"ι : Type u_1\n𝕜 : Type u_2\ninst✝⁷ : RCLike 𝕜\nE : Type u_3\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : InnerProductSpace 𝕜 E\nG : ι → Type u_4\ninst✝⁴ : (i : ι) → NormedAddCommGroup (G i)\ninst✝³ : (i : ι) → InnerProductSpace 𝕜 (G i)\ninst✝² : CompleteSpace E\nV : (i : ι) → LinearIsometry (RingHom.id 𝕜) (G i) E\nhV : OrthogonalFamily 𝕜 G V\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → DecidableEq (G i)\nW₀ : DFinsupp fun i => G i\n⊢ Eq (hV.linearIsometry (W₀.sum (lp.single 2))) (W₀.sum fun i => ⇑(V i))","decl":"protected theorem linearIsometry_apply_dfinsupp_sum_single [DecidableEq ι] [∀ i, DecidableEq (G i)]\n    (W₀ : Π₀ i : ι, G i) : hV.linearIsometry (W₀.sum (lp.single 2)) = W₀.sum fun i => V i := by\n  simp\n\n"}
{"name":"OrthogonalFamily.range_linearIsometry","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"ι : Type u_1\n𝕜 : Type u_2\ninst✝⁶ : RCLike 𝕜\nE : Type u_3\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : InnerProductSpace 𝕜 E\nG : ι → Type u_4\ninst✝³ : (i : ι) → NormedAddCommGroup (G i)\ninst✝² : (i : ι) → InnerProductSpace 𝕜 (G i)\ninst✝¹ : CompleteSpace E\nV : (i : ι) → LinearIsometry (RingHom.id 𝕜) (G i) E\nhV : OrthogonalFamily 𝕜 G V\ninst✝ : ∀ (i : ι), CompleteSpace (G i)\n⊢ Eq (LinearMap.range hV.linearIsometry.toLinearMap) (iSup fun i => LinearMap.range (V i).toLinearMap).topologicalClosure","decl":"/-- The canonical linear isometry from the `lp 2` of a mutually orthogonal family of subspaces of\n`E` into E, has range the closure of the span of the subspaces. -/\nprotected theorem range_linearIsometry [∀ i, CompleteSpace (G i)] :\n    LinearMap.range hV.linearIsometry.toLinearMap =\n      (⨆ i, LinearMap.range (V i).toLinearMap).topologicalClosure := by\n    -- Porting note: dot notation broken\n  classical\n  refine le_antisymm ?_ ?_\n  · rintro x ⟨f, rfl⟩\n    refine mem_closure_of_tendsto (hV.hasSum_linearIsometry f) (Eventually.of_forall ?_)\n    intro s\n    rw [SetLike.mem_coe]\n    refine sum_mem ?_\n    intro i _\n    refine mem_iSup_of_mem i ?_\n    exact LinearMap.mem_range_self _ (f i)\n  · apply topologicalClosure_minimal\n    · refine iSup_le ?_\n      rintro i x ⟨x, rfl⟩\n      use lp.single 2 i x\n      exact hV.linearIsometry_apply_single x\n    exact hV.linearIsometry.isometry.isUniformInducing.isComplete_range.isClosed\n\n"}
{"name":"IsHilbertSum.OrthogonalFamily","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"ι : Type u_1\n𝕜 : Type u_2\ninst✝⁴ : RCLike 𝕜\nE : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : InnerProductSpace 𝕜 E\nG : ι → Type u_4\ninst✝¹ : (i : ι) → NormedAddCommGroup (G i)\ninst✝ : (i : ι) → InnerProductSpace 𝕜 (G i)\nV : (i : ι) → LinearIsometry (RingHom.id 𝕜) (G i) E\nself : IsHilbertSum 𝕜 G V\n⊢ OrthogonalFamily 𝕜 G V","decl":"/-- Given a family of Hilbert spaces `G : ι → Type*`, a Hilbert sum of `G` consists of a Hilbert\nspace `E` and an orthogonal family `V : Π i, G i →ₗᵢ[𝕜] E` such that the induced isometry\n`Φ : lp G 2 → E` is surjective.\n\nKeeping in mind that `lp G 2` is \"the\" external Hilbert sum of `G : ι → Type*`, this is analogous\nto `DirectSum.IsInternal`, except that we don't express it in terms of actual submodules. -/\nstructure IsHilbertSum : Prop where\n  ofSurjective ::\n  /-- The orthogonal family constituting the summands in the Hilbert sum. -/\n  protected OrthogonalFamily : OrthogonalFamily 𝕜 G V\n  /-- The isometry `lp G 2 → E` induced by the orthogonal family is surjective. -/\n  protected surjective_isometry : Function.Surjective OrthogonalFamily.linearIsometry\n\n"}
{"name":"IsHilbertSum.surjective_isometry","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"ι : Type u_1\n𝕜 : Type u_2\ninst✝⁴ : RCLike 𝕜\nE : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : InnerProductSpace 𝕜 E\nG : ι → Type u_4\ninst✝¹ : (i : ι) → NormedAddCommGroup (G i)\ninst✝ : (i : ι) → InnerProductSpace 𝕜 (G i)\nV : (i : ι) → LinearIsometry (RingHom.id 𝕜) (G i) E\nself : IsHilbertSum 𝕜 G V\n⊢ Function.Surjective ⇑⋯.linearIsometry","decl":"/-- Given a family of Hilbert spaces `G : ι → Type*`, a Hilbert sum of `G` consists of a Hilbert\nspace `E` and an orthogonal family `V : Π i, G i →ₗᵢ[𝕜] E` such that the induced isometry\n`Φ : lp G 2 → E` is surjective.\n\nKeeping in mind that `lp G 2` is \"the\" external Hilbert sum of `G : ι → Type*`, this is analogous\nto `DirectSum.IsInternal`, except that we don't express it in terms of actual submodules. -/\nstructure IsHilbertSum : Prop where\n  ofSurjective ::\n  /-- The orthogonal family constituting the summands in the Hilbert sum. -/\n  protected OrthogonalFamily : OrthogonalFamily 𝕜 G V\n  /-- The isometry `lp G 2 → E` induced by the orthogonal family is surjective. -/\n  protected surjective_isometry : Function.Surjective OrthogonalFamily.linearIsometry\n\n"}
{"name":"IsHilbertSum.mk","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"ι : Type u_1\n𝕜 : Type u_2\ninst✝⁶ : RCLike 𝕜\nE : Type u_3\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : InnerProductSpace 𝕜 E\nG : ι → Type u_4\ninst✝³ : (i : ι) → NormedAddCommGroup (G i)\ninst✝² : (i : ι) → InnerProductSpace 𝕜 (G i)\ninst✝¹ : CompleteSpace E\nV : (i : ι) → LinearIsometry (RingHom.id 𝕜) (G i) E\ninst✝ : ∀ (i : ι), CompleteSpace (G i)\nhVortho : OrthogonalFamily 𝕜 G V\nhVtotal : LE.le Top.top (iSup fun i => LinearMap.range (V i).toLinearMap).topologicalClosure\n⊢ IsHilbertSum 𝕜 G V","decl":"/-- If `V : Π i, G i →ₗᵢ[𝕜] E` is an orthogonal family such that the supremum of the ranges of\n`V i` is dense, then `(E, V)` is a Hilbert sum of `G`. -/\ntheorem IsHilbertSum.mk [∀ i, CompleteSpace <| G i] (hVortho : OrthogonalFamily 𝕜 G V)\n    (hVtotal : ⊤ ≤ (⨆ i, LinearMap.range (V i).toLinearMap).topologicalClosure) :\n    IsHilbertSum 𝕜 G V :=\n  { OrthogonalFamily := hVortho\n    surjective_isometry := by\n      rw [← LinearIsometry.coe_toLinearMap]\n      exact LinearMap.range_eq_top.mp\n        (eq_top_iff.mpr <| hVtotal.trans_eq hVortho.range_linearIsometry.symm) }\n\n"}
{"name":"IsHilbertSum.mkInternal","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"ι : Type u_1\n𝕜 : Type u_2\ninst✝⁴ : RCLike 𝕜\nE : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : InnerProductSpace 𝕜 E\ninst✝¹ : CompleteSpace E\nF : ι → Submodule 𝕜 E\ninst✝ : ∀ (i : ι), CompleteSpace (Subtype fun x => Membership.mem (F i) x)\nhFortho : OrthogonalFamily 𝕜 (fun i => Subtype fun x => Membership.mem (F i) x) fun i => (F i).subtypeₗᵢ\nhFtotal : LE.le Top.top (iSup fun i => F i).topologicalClosure\n⊢ IsHilbertSum 𝕜 (fun i => Subtype fun x => Membership.mem (F i) x) fun i => (F i).subtypeₗᵢ","decl":"/-- This is `Orthonormal.isHilbertSum` in the case of actual inclusions from subspaces. -/\ntheorem IsHilbertSum.mkInternal [∀ i, CompleteSpace <| F i]\n    (hFortho : OrthogonalFamily 𝕜 (fun i => F i) fun i => (F i).subtypeₗᵢ)\n    (hFtotal : ⊤ ≤ (⨆ i, F i).topologicalClosure) :\n    IsHilbertSum 𝕜 (fun i => F i) fun i => (F i).subtypeₗᵢ :=\n  IsHilbertSum.mk hFortho (by simpa [subtypeₗᵢ_toLinearMap, range_subtype] using hFtotal)\n\n"}
{"name":"IsHilbertSum.linearIsometryEquiv_symm_apply","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"ι : Type u_1\n𝕜 : Type u_2\ninst✝⁵ : RCLike 𝕜\nE : Type u_3\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : InnerProductSpace 𝕜 E\nG : ι → Type u_4\ninst✝² : (i : ι) → NormedAddCommGroup (G i)\ninst✝¹ : (i : ι) → InnerProductSpace 𝕜 (G i)\ninst✝ : CompleteSpace E\nV : (i : ι) → LinearIsometry (RingHom.id 𝕜) (G i) E\nhV : IsHilbertSum 𝕜 G V\nw : Subtype fun x => Membership.mem (lp G 2) x\n⊢ Eq (hV.linearIsometryEquiv.symm w) (tsum fun i => (V i) (↑w i))","decl":"/-- In the canonical isometric isomorphism between a Hilbert sum `E` of `G` and `lp G 2`,\na vector `w : lp G 2` is the image of the infinite sum of the associated elements in `E`. -/\nprotected theorem IsHilbertSum.linearIsometryEquiv_symm_apply (hV : IsHilbertSum 𝕜 G V)\n    (w : lp G 2) : hV.linearIsometryEquiv.symm w = ∑' i, V i (w i) := by\n  simp [IsHilbertSum.linearIsometryEquiv, OrthogonalFamily.linearIsometry_apply]\n\n"}
{"name":"IsHilbertSum.hasSum_linearIsometryEquiv_symm","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"ι : Type u_1\n𝕜 : Type u_2\ninst✝⁵ : RCLike 𝕜\nE : Type u_3\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : InnerProductSpace 𝕜 E\nG : ι → Type u_4\ninst✝² : (i : ι) → NormedAddCommGroup (G i)\ninst✝¹ : (i : ι) → InnerProductSpace 𝕜 (G i)\ninst✝ : CompleteSpace E\nV : (i : ι) → LinearIsometry (RingHom.id 𝕜) (G i) E\nhV : IsHilbertSum 𝕜 G V\nw : Subtype fun x => Membership.mem (lp G 2) x\n⊢ HasSum (fun i => (V i) (↑w i)) (hV.linearIsometryEquiv.symm w)","decl":"/-- In the canonical isometric isomorphism between a Hilbert sum `E` of `G` and `lp G 2`,\na vector `w : lp G 2` is the image of the infinite sum of the associated elements in `E`, and this\nsum indeed converges. -/\nprotected theorem IsHilbertSum.hasSum_linearIsometryEquiv_symm (hV : IsHilbertSum 𝕜 G V)\n    (w : lp G 2) : HasSum (fun i => V i (w i)) (hV.linearIsometryEquiv.symm w) := by\n  simp [IsHilbertSum.linearIsometryEquiv, OrthogonalFamily.hasSum_linearIsometry]\n\n"}
{"name":"IsHilbertSum.linearIsometryEquiv_symm_apply_single","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"ι : Type u_1\n𝕜 : Type u_2\ninst✝⁶ : RCLike 𝕜\nE : Type u_3\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : InnerProductSpace 𝕜 E\nG : ι → Type u_4\ninst✝³ : (i : ι) → NormedAddCommGroup (G i)\ninst✝² : (i : ι) → InnerProductSpace 𝕜 (G i)\ninst✝¹ : CompleteSpace E\nV : (i : ι) → LinearIsometry (RingHom.id 𝕜) (G i) E\ninst✝ : DecidableEq ι\nhV : IsHilbertSum 𝕜 G V\ni : ι\nx : G i\n⊢ Eq (hV.linearIsometryEquiv.symm (lp.single 2 i x)) ((V i) x)","decl":"/-- In the canonical isometric isomorphism between a Hilbert sum `E` of `G : ι → Type*` and\n`lp G 2`, an \"elementary basis vector\" in `lp G 2` supported at `i : ι` is the image of the\nassociated element in `E`. -/\n@[simp]\nprotected theorem IsHilbertSum.linearIsometryEquiv_symm_apply_single\n    [DecidableEq ι] (hV : IsHilbertSum 𝕜 G V) {i : ι} (x : G i) :\n    hV.linearIsometryEquiv.symm (lp.single 2 i x) = V i x := by\n  simp [IsHilbertSum.linearIsometryEquiv, OrthogonalFamily.linearIsometry_apply_single]\n\n"}
{"name":"IsHilbertSum.linearIsometryEquiv_symm_apply_dfinsupp_sum_single","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"ι : Type u_1\n𝕜 : Type u_2\ninst✝⁷ : RCLike 𝕜\nE : Type u_3\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : InnerProductSpace 𝕜 E\nG : ι → Type u_4\ninst✝⁴ : (i : ι) → NormedAddCommGroup (G i)\ninst✝³ : (i : ι) → InnerProductSpace 𝕜 (G i)\ninst✝² : CompleteSpace E\nV : (i : ι) → LinearIsometry (RingHom.id 𝕜) (G i) E\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → DecidableEq (G i)\nhV : IsHilbertSum 𝕜 G V\nW₀ : DFinsupp fun i => G i\n⊢ Eq (hV.linearIsometryEquiv.symm (W₀.sum (lp.single 2))) (W₀.sum fun i => ⇑(V i))","decl":"/-- In the canonical isometric isomorphism between a Hilbert sum `E` of `G : ι → Type*` and\n`lp G 2`, a finitely-supported vector in `lp G 2` is the image of the associated finite sum of\nelements of `E`. -/\nprotected theorem IsHilbertSum.linearIsometryEquiv_symm_apply_dfinsupp_sum_single\n    [DecidableEq ι] [∀ i, DecidableEq (G i)] (hV : IsHilbertSum 𝕜 G V) (W₀ : Π₀ i : ι, G i) :\n    hV.linearIsometryEquiv.symm (W₀.sum (lp.single 2)) = W₀.sum fun i => V i := by\n  simp only [map_dfinsupp_sum, IsHilbertSum.linearIsometryEquiv_symm_apply_single]\n\n"}
{"name":"IsHilbertSum.linearIsometryEquiv_apply_dfinsupp_sum_single","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"ι : Type u_1\n𝕜 : Type u_2\ninst✝⁷ : RCLike 𝕜\nE : Type u_3\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : InnerProductSpace 𝕜 E\nG : ι → Type u_4\ninst✝⁴ : (i : ι) → NormedAddCommGroup (G i)\ninst✝³ : (i : ι) → InnerProductSpace 𝕜 (G i)\ninst✝² : CompleteSpace E\nV : (i : ι) → LinearIsometry (RingHom.id 𝕜) (G i) E\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → DecidableEq (G i)\nhV : IsHilbertSum 𝕜 G V\nW₀ : DFinsupp fun i => G i\n⊢ Eq ↑(W₀.sum fun a b => hV.linearIsometryEquiv ((V a) b)) ⇑W₀","decl":"/-- In the canonical isometric isomorphism between a Hilbert sum `E` of `G : ι → Type*` and\n`lp G 2`, a finitely-supported vector in `lp G 2` is the image of the associated finite sum of\nelements of `E`. -/\n@[simp]\nprotected theorem IsHilbertSum.linearIsometryEquiv_apply_dfinsupp_sum_single\n    [DecidableEq ι] [∀ i, DecidableEq (G i)] (hV : IsHilbertSum 𝕜 G V) (W₀ : Π₀ i : ι, G i) :\n    ((W₀.sum (γ := lp G 2) fun a b ↦ hV.linearIsometryEquiv (V a b)) : ∀ i, G i) = W₀ := by\n  rw [← map_dfinsupp_sum]\n  rw [← hV.linearIsometryEquiv_symm_apply_dfinsupp_sum_single]\n  rw [LinearIsometryEquiv.apply_symm_apply]\n  ext i\n  simp +contextual [DFinsupp.sum, lp.single_apply]\n\n"}
{"name":"Orthonormal.isHilbertSum","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"ι : Type u_1\n𝕜 : Type u_2\ninst✝³ : RCLike 𝕜\nE : Type u_3\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : CompleteSpace E\nv : ι → E\nhv : Orthonormal 𝕜 v\nhsp : LE.le Top.top (Submodule.span 𝕜 (Set.range v)).topologicalClosure\n⊢ IsHilbertSum 𝕜 (fun x => 𝕜) fun i => LinearIsometry.toSpanSingleton 𝕜 E ⋯","decl":"/-- Given a total orthonormal family `v : ι → E`, `E` is a Hilbert sum of `fun i : ι => 𝕜`\nrelative to the family of linear isometries `fun i k => k • v i`. -/\ntheorem Orthonormal.isHilbertSum {v : ι → E} (hv : Orthonormal 𝕜 v)\n    (hsp : ⊤ ≤ (span 𝕜 (Set.range v)).topologicalClosure) :\n    IsHilbertSum 𝕜 (fun _ : ι => 𝕜) fun i => LinearIsometry.toSpanSingleton 𝕜 E (hv.1 i) :=\n  IsHilbertSum.mk hv.orthogonalFamily (by\n    convert hsp\n    simp [← LinearMap.span_singleton_eq_range, ← Submodule.span_iUnion])\n\n"}
{"name":"Submodule.isHilbertSumOrthogonal","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"𝕜 : Type u_2\ninst✝³ : RCLike 𝕜\nE : Type u_3\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : CompleteSpace E\nK : Submodule 𝕜 E\nhK : CompleteSpace (Subtype fun x => Membership.mem K x)\n⊢ IsHilbertSum 𝕜 (fun b => Subtype fun x => Membership.mem (cond b K K.orthogonal) x) fun b => (cond b K K.orthogonal).subtypeₗᵢ","decl":"theorem Submodule.isHilbertSumOrthogonal (K : Submodule 𝕜 E) [hK : CompleteSpace K] :\n    IsHilbertSum 𝕜 (fun b => ↥(cond b K Kᗮ)) fun b => (cond b K Kᗮ).subtypeₗᵢ := by\n  have : ∀ b, CompleteSpace (↥(cond b K Kᗮ)) := by\n    intro b\n    cases b <;> first | exact instOrthogonalCompleteSpace K | assumption\n  refine IsHilbertSum.mkInternal _ K.orthogonalFamily_self ?_\n  refine le_trans ?_ (Submodule.le_topologicalClosure _)\n  rw [iSup_bool_eq, cond, cond]\n  refine Codisjoint.top_le ?_\n  exact Submodule.isCompl_orthogonal_of_completeSpace.codisjoint\n\n"}
{"name":"HilbertBasis.ofRepr.sizeOf_spec","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"ι : Type u_1\n𝕜 : Type u_2\ninst✝⁵ : RCLike 𝕜\nE : Type u_3\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : InnerProductSpace 𝕜 E\ninst✝² : SizeOf ι\ninst✝¹ : SizeOf 𝕜\ninst✝ : SizeOf E\nrepr : LinearIsometryEquiv (RingHom.id 𝕜) E (Subtype fun x => Membership.mem (lp (fun i => 𝕜) 2) x)\n⊢ Eq (SizeOf.sizeOf { repr := repr }) (HAdd.hAdd 1 (SizeOf.sizeOf repr))","decl":"/-- A Hilbert basis on `ι` for an inner product space `E` is an identification of `E` with the `lp`\nspace `ℓ²(ι, 𝕜)`. -/\nstructure HilbertBasis where ofRepr ::\n  /-- The linear isometric equivalence implementing identifying the Hilbert space with `ℓ²`. -/\n  repr : E ≃ₗᵢ[𝕜] ℓ²(ι, 𝕜)\n\n"}
{"name":"HilbertBasis.ofRepr.inj","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"ι : Type u_1\n𝕜 : Type u_2\ninst✝² : RCLike 𝕜\nE : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nrepr✝ repr : LinearIsometryEquiv (RingHom.id 𝕜) E (Subtype fun x => Membership.mem (lp (fun i => 𝕜) 2) x)\nx✝ : Eq { repr := repr✝ } { repr := repr }\n⊢ Eq repr✝ repr","decl":"/-- A Hilbert basis on `ι` for an inner product space `E` is an identification of `E` with the `lp`\nspace `ℓ²(ι, 𝕜)`. -/\nstructure HilbertBasis where ofRepr ::\n  /-- The linear isometric equivalence implementing identifying the Hilbert space with `ℓ²`. -/\n  repr : E ≃ₗᵢ[𝕜] ℓ²(ι, 𝕜)\n\n"}
{"name":"HilbertBasis.ofRepr.injEq","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"ι : Type u_1\n𝕜 : Type u_2\ninst✝² : RCLike 𝕜\nE : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nrepr✝ repr : LinearIsometryEquiv (RingHom.id 𝕜) E (Subtype fun x => Membership.mem (lp (fun i => 𝕜) 2) x)\n⊢ Eq (Eq { repr := repr✝ } { repr := repr }) (Eq repr✝ repr)","decl":"/-- A Hilbert basis on `ι` for an inner product space `E` is an identification of `E` with the `lp`\nspace `ℓ²(ι, 𝕜)`. -/\nstructure HilbertBasis where ofRepr ::\n  /-- The linear isometric equivalence implementing identifying the Hilbert space with `ℓ²`. -/\n  repr : E ≃ₗᵢ[𝕜] ℓ²(ι, 𝕜)\n\n"}
{"name":"HilbertBasis.repr_symm_single","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"ι : Type u_1\n𝕜 : Type u_2\ninst✝³ : RCLike 𝕜\nE : Type u_3\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : DecidableEq ι\nb : HilbertBasis ι 𝕜 E\ni : ι\n⊢ Eq (b.repr.symm (lp.single 2 i 1)) ((fun i => b.repr.symm (lp.single 2 i 1)) i)","decl":"protected theorem repr_symm_single [DecidableEq ι] (b : HilbertBasis ι 𝕜 E) (i : ι) :\n    b.repr.symm (lp.single 2 i (1 : 𝕜)) = b i := by\n  convert rfl\n\n"}
{"name":"HilbertBasis.repr_self","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"ι : Type u_1\n𝕜 : Type u_2\ninst✝³ : RCLike 𝕜\nE : Type u_3\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : DecidableEq ι\nb : HilbertBasis ι 𝕜 E\ni : ι\n⊢ Eq (b.repr ((fun i => b.repr.symm (lp.single 2 i 1)) i)) (lp.single 2 i 1)","decl":"protected theorem repr_self [DecidableEq ι] (b : HilbertBasis ι 𝕜 E) (i : ι) :\n    b.repr (b i) = lp.single 2 i (1 : 𝕜) := by\n  simp only [LinearIsometryEquiv.apply_symm_apply]\n  convert rfl\n\n"}
{"name":"HilbertBasis.repr_apply_apply","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"ι : Type u_1\n𝕜 : Type u_2\ninst✝² : RCLike 𝕜\nE : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nb : HilbertBasis ι 𝕜 E\nv : E\ni : ι\n⊢ Eq (↑(b.repr v) i) (Inner.inner ((fun i => b.repr.symm (lp.single 2 i 1)) i) v)","decl":"protected theorem repr_apply_apply (b : HilbertBasis ι 𝕜 E) (v : E) (i : ι) :\n    b.repr v i = ⟪b i, v⟫ := by\n  classical\n  rw [← b.repr.inner_map_map (b i) v, b.repr_self, lp.inner_single_left]\n  simp\n\n"}
{"name":"HilbertBasis.orthonormal","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"ι : Type u_1\n𝕜 : Type u_2\ninst✝² : RCLike 𝕜\nE : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nb : HilbertBasis ι 𝕜 E\n⊢ Orthonormal 𝕜 fun i => b.repr.symm (lp.single 2 i 1)","decl":"@[simp]\nprotected theorem orthonormal (b : HilbertBasis ι 𝕜 E) : Orthonormal 𝕜 b := by\n  classical\n  rw [orthonormal_iff_ite]\n  intro i j\n  rw [← b.repr.inner_map_map (b i) (b j), b.repr_self, b.repr_self, lp.inner_single_left,\n    lp.single_apply]\n  simp\n\n"}
{"name":"HilbertBasis.hasSum_repr_symm","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"ι : Type u_1\n𝕜 : Type u_2\ninst✝² : RCLike 𝕜\nE : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nb : HilbertBasis ι 𝕜 E\nf : Subtype fun x => Membership.mem (lp (fun i => 𝕜) 2) x\n⊢ HasSum (fun i => HSMul.hSMul (↑f i) ((fun i => b.repr.symm (lp.single 2 i 1)) i)) (b.repr.symm f)","decl":"protected theorem hasSum_repr_symm (b : HilbertBasis ι 𝕜 E) (f : ℓ²(ι, 𝕜)) :\n    HasSum (fun i => f i • b i) (b.repr.symm f) := by\n  classical\n  suffices H : (fun i : ι => f i • b i) = fun b_1 : ι => b.repr.symm.toContinuousLinearEquiv <|\n      (fun i : ι => lp.single 2 i (f i) (E := (fun _ : ι => 𝕜))) b_1 by\n    rw [H]\n    have : HasSum (fun i : ι => lp.single 2 i (f i)) f := lp.hasSum_single ENNReal.ofNat_ne_top f\n    exact (↑b.repr.symm.toContinuousLinearEquiv : ℓ²(ι, 𝕜) →L[𝕜] E).hasSum this\n  ext i\n  apply b.repr.injective\n  letI : NormedSpace 𝕜 (lp (fun _i : ι => 𝕜) 2) := by infer_instance\n  have : lp.single (E := (fun _ : ι => 𝕜)) 2 i (f i * 1) = f i • lp.single 2 i 1 :=\n    lp.single_smul (E := (fun _ : ι => 𝕜)) 2 i (1 : 𝕜) (f i)\n  rw [mul_one] at this\n  rw [LinearIsometryEquiv.map_smul, b.repr_self, ← this,\n    LinearIsometryEquiv.coe_toContinuousLinearEquiv]\n  exact (b.repr.apply_symm_apply (lp.single 2 i (f i))).symm\n\n"}
{"name":"HilbertBasis.hasSum_repr","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"ι : Type u_1\n𝕜 : Type u_2\ninst✝² : RCLike 𝕜\nE : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nb : HilbertBasis ι 𝕜 E\nx : E\n⊢ HasSum (fun i => HSMul.hSMul (↑(b.repr x) i) ((fun i => b.repr.symm (lp.single 2 i 1)) i)) x","decl":"protected theorem hasSum_repr (b : HilbertBasis ι 𝕜 E) (x : E) :\n    HasSum (fun i => b.repr x i • b i) x := by simpa using b.hasSum_repr_symm (b.repr x)\n\n"}
{"name":"HilbertBasis.dense_span","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"ι : Type u_1\n𝕜 : Type u_2\ninst✝² : RCLike 𝕜\nE : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nb : HilbertBasis ι 𝕜 E\n⊢ Eq (Submodule.span 𝕜 (Set.range fun i => b.repr.symm (lp.single 2 i 1))).topologicalClosure Top.top","decl":"@[simp]\nprotected theorem dense_span (b : HilbertBasis ι 𝕜 E) :\n    (span 𝕜 (Set.range b)).topologicalClosure = ⊤ := by\n  classical\n    rw [eq_top_iff]\n    rintro x -\n    refine mem_closure_of_tendsto (b.hasSum_repr x) (Eventually.of_forall ?_)\n    intro s\n    simp only [SetLike.mem_coe]\n    refine sum_mem ?_\n    rintro i -\n    refine smul_mem _ _ ?_\n    exact subset_span ⟨i, rfl⟩\n\n"}
{"name":"HilbertBasis.hasSum_inner_mul_inner","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"ι : Type u_1\n𝕜 : Type u_2\ninst✝² : RCLike 𝕜\nE : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nb : HilbertBasis ι 𝕜 E\nx y : E\n⊢ HasSum (fun i => HMul.hMul (Inner.inner x ((fun i => b.repr.symm (lp.single 2 i 1)) i)) (Inner.inner ((fun i => b.repr.symm (lp.single 2 i 1)) i) y)) (Inner.inner x y)","decl":"protected theorem hasSum_inner_mul_inner (b : HilbertBasis ι 𝕜 E) (x y : E) :\n    HasSum (fun i => ⟪x, b i⟫ * ⟪b i, y⟫) ⟪x, y⟫ := by\n  convert (b.hasSum_repr y).mapL (innerSL 𝕜 x) using 1\n  ext i\n  rw [innerSL_apply, b.repr_apply_apply, inner_smul_right, mul_comm]\n\n"}
{"name":"HilbertBasis.summable_inner_mul_inner","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"ι : Type u_1\n𝕜 : Type u_2\ninst✝² : RCLike 𝕜\nE : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nb : HilbertBasis ι 𝕜 E\nx y : E\n⊢ Summable fun i => HMul.hMul (Inner.inner x ((fun i => b.repr.symm (lp.single 2 i 1)) i)) (Inner.inner ((fun i => b.repr.symm (lp.single 2 i 1)) i) y)","decl":"protected theorem summable_inner_mul_inner (b : HilbertBasis ι 𝕜 E) (x y : E) :\n    Summable fun i => ⟪x, b i⟫ * ⟪b i, y⟫ :=\n  (b.hasSum_inner_mul_inner x y).summable\n\n"}
{"name":"HilbertBasis.tsum_inner_mul_inner","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"ι : Type u_1\n𝕜 : Type u_2\ninst✝² : RCLike 𝕜\nE : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nb : HilbertBasis ι 𝕜 E\nx y : E\n⊢ Eq (tsum fun i => HMul.hMul (Inner.inner x ((fun i => b.repr.symm (lp.single 2 i 1)) i)) (Inner.inner ((fun i => b.repr.symm (lp.single 2 i 1)) i) y)) (Inner.inner x y)","decl":"protected theorem tsum_inner_mul_inner (b : HilbertBasis ι 𝕜 E) (x y : E) :\n    ∑' i, ⟪x, b i⟫ * ⟪b i, y⟫ = ⟪x, y⟫ :=\n  (b.hasSum_inner_mul_inner x y).tsum_eq\n\n-- Note: this should be `b.repr` composed with an identification of `lp (fun i : ι => 𝕜) p` with\n-- `PiLp p (fun i : ι => 𝕜)` (in this case with `p = 2`), but we don't have this yet (July 2022).\n"}
{"name":"HilbertBasis.coe_toOrthonormalBasis","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"ι : Type u_1\n𝕜 : Type u_2\ninst✝³ : RCLike 𝕜\nE : Type u_3\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : Fintype ι\nb : HilbertBasis ι 𝕜 E\n⊢ Eq ⇑b.toOrthonormalBasis fun i => b.repr.symm (lp.single 2 i 1)","decl":"@[simp]\ntheorem coe_toOrthonormalBasis [Fintype ι] (b : HilbertBasis ι 𝕜 E) :\n    (b.toOrthonormalBasis : ι → E) = b :=\n  OrthonormalBasis.coe_mk _ _\n\n"}
{"name":"HilbertBasis.hasSum_orthogonalProjection","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"ι : Type u_1\n𝕜 : Type u_2\ninst✝³ : RCLike 𝕜\nE : Type u_3\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\nU : Submodule 𝕜 E\ninst✝ : CompleteSpace (Subtype fun x => Membership.mem U x)\nb : HilbertBasis ι 𝕜 (Subtype fun x => Membership.mem U x)\nx : E\n⊢ HasSum (fun i => HSMul.hSMul (Inner.inner (↑((fun i => b.repr.symm (lp.single 2 i 1)) i)) x) ((fun i => b.repr.symm (lp.single 2 i 1)) i)) ((orthogonalProjection U) x)","decl":"protected theorem hasSum_orthogonalProjection {U : Submodule 𝕜 E} [CompleteSpace U]\n    (b : HilbertBasis ι 𝕜 U) (x : E) :\n    HasSum (fun i => ⟪(b i : E), x⟫ • b i) (orthogonalProjection U x) := by\n  simpa only [b.repr_apply_apply, inner_orthogonalProjection_eq_of_mem_left] using\n    b.hasSum_repr (orthogonalProjection U x)\n\n"}
{"name":"HilbertBasis.finite_spans_dense","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"ι : Type u_1\n𝕜 : Type u_2\ninst✝³ : RCLike 𝕜\nE : Type u_3\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : DecidableEq E\nb : HilbertBasis ι 𝕜 E\n⊢ Eq (iSup fun J => Submodule.span 𝕜 ↑(Finset.image (fun i => b.repr.symm (lp.single 2 i 1)) J)).topologicalClosure Top.top","decl":"theorem finite_spans_dense [DecidableEq E] (b : HilbertBasis ι 𝕜 E) :\n    (⨆ J : Finset ι, span 𝕜 (J.image b : Set E)).topologicalClosure = ⊤ :=\n  eq_top_iff.mpr <| b.dense_span.ge.trans (by\n    simp_rw [← Submodule.span_iUnion]\n    exact topologicalClosure_mono (span_mono <| Set.range_subset_iff.mpr fun i =>\n      Set.mem_iUnion_of_mem {i} <| Finset.mem_coe.mpr <| Finset.mem_image_of_mem _ <|\n      Finset.mem_singleton_self i))\n\n"}
{"name":"Orthonormal.linearIsometryEquiv_symm_apply_single_one","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"ι : Type u_1\n𝕜 : Type u_2\ninst✝⁴ : RCLike 𝕜\nE : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : InnerProductSpace 𝕜 E\ninst✝¹ : CompleteSpace E\nv : ι → E\nhv : Orthonormal 𝕜 v\ninst✝ : DecidableEq ι\nh : LE.le Top.top (Submodule.span 𝕜 (Set.range v)).topologicalClosure\ni : ι\n⊢ Eq (⋯.linearIsometryEquiv.symm (lp.single 2 i 1)) (v i)","decl":"theorem _root_.Orthonormal.linearIsometryEquiv_symm_apply_single_one [DecidableEq ι] (h i) :\n    (hv.isHilbertSum h).linearIsometryEquiv.symm (lp.single 2 i 1) = v i := by\n  rw [IsHilbertSum.linearIsometryEquiv_symm_apply_single, LinearIsometry.toSpanSingleton_apply,\n    one_smul]\n\n"}
{"name":"HilbertBasis.coe_mk","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"ι : Type u_1\n𝕜 : Type u_2\ninst✝³ : RCLike 𝕜\nE : Type u_3\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : CompleteSpace E\nv : ι → E\nhv : Orthonormal 𝕜 v\nhsp : LE.le Top.top (Submodule.span 𝕜 (Set.range v)).topologicalClosure\n⊢ Eq (fun i => (HilbertBasis.mk hv hsp).repr.symm (lp.single 2 i 1)) v","decl":"@[simp]\nprotected theorem coe_mk (hsp : ⊤ ≤ (span 𝕜 (Set.range v)).topologicalClosure) :\n    ⇑(HilbertBasis.mk hv hsp) = v := by\n  classical\n  apply funext <| Orthonormal.linearIsometryEquiv_symm_apply_single_one hv hsp\n\n"}
{"name":"HilbertBasis.coe_mkOfOrthogonalEqBot","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"ι : Type u_1\n𝕜 : Type u_2\ninst✝³ : RCLike 𝕜\nE : Type u_3\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : CompleteSpace E\nv : ι → E\nhv : Orthonormal 𝕜 v\nhsp : Eq (Submodule.span 𝕜 (Set.range v)).orthogonal Bot.bot\n⊢ Eq (fun i => (HilbertBasis.mkOfOrthogonalEqBot hv hsp).repr.symm (lp.single 2 i 1)) v","decl":"@[simp]\nprotected theorem coe_mkOfOrthogonalEqBot (hsp : (span 𝕜 (Set.range v))ᗮ = ⊥) :\n    ⇑(HilbertBasis.mkOfOrthogonalEqBot hv hsp) = v :=\n  HilbertBasis.coe_mk hv _\n\n-- Note : this should be `b.repr` composed with an identification of `lp (fun i : ι => 𝕜) p` with\n-- `PiLp p (fun i : ι => 𝕜)` (in this case with `p = 2`), but we don't have this yet (July 2022).\n"}
{"name":"OrthonormalBasis.coe_toHilbertBasis","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"ι : Type u_1\n𝕜 : Type u_2\ninst✝⁴ : RCLike 𝕜\nE : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : InnerProductSpace 𝕜 E\ninst✝¹ : CompleteSpace E\ninst✝ : Fintype ι\nb : OrthonormalBasis ι 𝕜 E\n⊢ Eq (fun i => b.toHilbertBasis.repr.symm (lp.single 2 i 1)) ⇑b","decl":"@[simp]\ntheorem _root_.OrthonormalBasis.coe_toHilbertBasis [Fintype ι] (b : OrthonormalBasis ι 𝕜 E) :\n    (b.toHilbertBasis : ι → E) = b :=\n  HilbertBasis.coe_mk _ _\n\n"}
{"name":"Orthonormal.exists_hilbertBasis_extension","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"𝕜 : Type u_2\ninst✝³ : RCLike 𝕜\nE : Type u_3\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : CompleteSpace E\ns : Set E\nhs : Orthonormal 𝕜 Subtype.val\n⊢ Exists fun w => Exists fun b => And (HasSubset.Subset s w) (Eq (fun i => b.repr.symm (lp.single 2 i 1)) Subtype.val)","decl":"/-- A Hilbert space admits a Hilbert basis extending a given orthonormal subset. -/\ntheorem _root_.Orthonormal.exists_hilbertBasis_extension {s : Set E}\n    (hs : Orthonormal 𝕜 ((↑) : s → E)) :\n    ∃ (w : Set E) (b : HilbertBasis w 𝕜 E), s ⊆ w ∧ ⇑b = ((↑) : w → E) :=\n  let ⟨w, hws, hw_ortho, hw_max⟩ := exists_maximal_orthonormal hs\n  ⟨w, HilbertBasis.mkOfOrthogonalEqBot hw_ortho\n    (by simpa only [Subtype.range_coe_subtype, Set.setOf_mem_eq,\n      maximal_orthonormal_iff_orthogonalComplement_eq_bot hw_ortho] using hw_max),\n    hws, HilbertBasis.coe_mkOfOrthogonalEqBot _ _⟩\n\n"}
{"name":"exists_hilbertBasis","module":"Mathlib.Analysis.InnerProductSpace.l2Space","initialProofState":"𝕜 : Type u_2\ninst✝³ : RCLike 𝕜\nE : Type u_3\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : CompleteSpace E\n⊢ Exists fun w => Exists fun b => Eq (fun i => b.repr.symm (lp.single 2 i 1)) Subtype.val","decl":"/-- A Hilbert space admits a Hilbert basis. -/\ntheorem _root_.exists_hilbertBasis : ∃ (w : Set E) (b : HilbertBasis w 𝕜 E), ⇑b = ((↑) : w → E) :=\n  let ⟨w, hw, _, hw''⟩ := (orthonormal_empty 𝕜 E).exists_hilbertBasis_extension\n  ⟨w, hw, hw''⟩\n\n"}
