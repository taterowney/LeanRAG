{"name":"Additive.ofMul_symm_eq","module":"Mathlib.Algebra.Group.TypeTags.Basic","initialProofState":"α : Type u\n⊢ Eq Additive.ofMul.symm Additive.toMul","decl":"@[simp]\ntheorem ofMul_symm_eq : (@ofMul α).symm = toMul :=\n  rfl\n\n"}
{"name":"Additive.toMul_symm_eq","module":"Mathlib.Algebra.Group.TypeTags.Basic","initialProofState":"α : Type u\n⊢ Eq Additive.toMul.symm Additive.ofMul","decl":"@[simp]\ntheorem toMul_symm_eq : (@toMul α).symm = ofMul :=\n  rfl\n\n"}
{"name":"Additive.forall","module":"Mathlib.Algebra.Group.TypeTags.Basic","initialProofState":"α : Type u\np : Additive α → Prop\n⊢ Iff (∀ (a : Additive α), p a) (∀ (a : α), p (Additive.ofMul a))","decl":"@[simp]\nprotected lemma «forall» {p : Additive α → Prop} : (∀ a, p a) ↔ ∀ a, p (ofMul a) := Iff.rfl\n\n"}
{"name":"Additive.exists","module":"Mathlib.Algebra.Group.TypeTags.Basic","initialProofState":"α : Type u\np : Additive α → Prop\n⊢ Iff (Exists fun a => p a) (Exists fun a => p (Additive.ofMul a))","decl":"@[simp]\nprotected lemma «exists» {p : Additive α → Prop} : (∃ a, p a) ↔ ∃ a, p (ofMul a) := Iff.rfl\n\n"}
{"name":"Multiplicative.ofAdd_symm_eq","module":"Mathlib.Algebra.Group.TypeTags.Basic","initialProofState":"α : Type u\n⊢ Eq Multiplicative.ofAdd.symm Multiplicative.toAdd","decl":"@[simp]\ntheorem ofAdd_symm_eq : (@ofAdd α).symm = toAdd :=\n  rfl\n\n"}
{"name":"Multiplicative.toAdd_symm_eq","module":"Mathlib.Algebra.Group.TypeTags.Basic","initialProofState":"α : Type u\n⊢ Eq Multiplicative.toAdd.symm Multiplicative.ofAdd","decl":"@[simp]\ntheorem toAdd_symm_eq : (@toAdd α).symm = ofAdd :=\n  rfl\n\n"}
{"name":"Multiplicative.forall","module":"Mathlib.Algebra.Group.TypeTags.Basic","initialProofState":"α : Type u\np : Multiplicative α → Prop\n⊢ Iff (∀ (a : Multiplicative α), p a) (∀ (a : α), p (Multiplicative.ofAdd a))","decl":"@[simp]\nprotected lemma «forall» {p : Multiplicative α → Prop} : (∀ a, p a) ↔ ∀ a, p (ofAdd a) := Iff.rfl\n\n"}
{"name":"Multiplicative.exists","module":"Mathlib.Algebra.Group.TypeTags.Basic","initialProofState":"α : Type u\np : Multiplicative α → Prop\n⊢ Iff (Exists fun a => p a) (Exists fun a => p (Multiplicative.ofAdd a))","decl":"@[simp]\nprotected lemma «exists» {p : Multiplicative α → Prop} : (∃ a, p a) ↔ ∃ a, p (ofAdd a) := Iff.rfl\n\n"}
{"name":"toAdd_ofAdd","module":"Mathlib.Algebra.Group.TypeTags.Basic","initialProofState":"α : Type u\nx : α\n⊢ Eq (Multiplicative.toAdd (Multiplicative.ofAdd x)) x","decl":"@[simp]\ntheorem toAdd_ofAdd (x : α) : (ofAdd x).toAdd = x :=\n  rfl\n\n"}
{"name":"ofAdd_toAdd","module":"Mathlib.Algebra.Group.TypeTags.Basic","initialProofState":"α : Type u\nx : Multiplicative α\n⊢ Eq (Multiplicative.ofAdd (Multiplicative.toAdd x)) x","decl":"@[simp]\ntheorem ofAdd_toAdd (x : Multiplicative α) : ofAdd x.toAdd = x :=\n  rfl\n\n"}
{"name":"toMul_ofMul","module":"Mathlib.Algebra.Group.TypeTags.Basic","initialProofState":"α : Type u\nx : α\n⊢ Eq (Additive.toMul (Additive.ofMul x)) x","decl":"@[simp]\ntheorem toMul_ofMul (x : α) : (ofMul x).toMul = x :=\n  rfl\n\n"}
{"name":"ofMul_toMul","module":"Mathlib.Algebra.Group.TypeTags.Basic","initialProofState":"α : Type u\nx : Additive α\n⊢ Eq (Additive.ofMul (Additive.toMul x)) x","decl":"@[simp]\ntheorem ofMul_toMul (x : Additive α) : ofMul x.toMul = x :=\n  rfl\n\n"}
{"name":"instSubsingletonAdditive","module":"Mathlib.Algebra.Group.TypeTags.Basic","initialProofState":"α : Type u\ninst✝ : Subsingleton α\n⊢ Subsingleton (Additive α)","decl":"instance [Subsingleton α] : Subsingleton (Additive α) := toMul.injective.subsingleton\n"}
{"name":"instSubsingletonMultiplicative","module":"Mathlib.Algebra.Group.TypeTags.Basic","initialProofState":"α : Type u\ninst✝ : Subsingleton α\n⊢ Subsingleton (Multiplicative α)","decl":"instance [Subsingleton α] : Subsingleton (Multiplicative α) := toAdd.injective.subsingleton\n\n"}
{"name":"Additive.instNontrivial","module":"Mathlib.Algebra.Group.TypeTags.Basic","initialProofState":"α : Type u\ninst✝ : Nontrivial α\n⊢ Nontrivial (Additive α)","decl":"instance Additive.instNontrivial [Nontrivial α] : Nontrivial (Additive α) :=\n  ofMul.injective.nontrivial\n\n"}
{"name":"Multiplicative.instNontrivial","module":"Mathlib.Algebra.Group.TypeTags.Basic","initialProofState":"α : Type u\ninst✝ : Nontrivial α\n⊢ Nontrivial (Multiplicative α)","decl":"instance Multiplicative.instNontrivial [Nontrivial α] : Nontrivial (Multiplicative α) :=\n  ofAdd.injective.nontrivial\n\n"}
{"name":"ofAdd_add","module":"Mathlib.Algebra.Group.TypeTags.Basic","initialProofState":"α : Type u\ninst✝ : Add α\nx y : α\n⊢ Eq (Multiplicative.ofAdd (HAdd.hAdd x y)) (HMul.hMul (Multiplicative.ofAdd x) (Multiplicative.ofAdd y))","decl":"@[simp]\ntheorem ofAdd_add [Add α] (x y : α) : ofAdd (x + y) = ofAdd x * ofAdd y := rfl\n\n"}
{"name":"toAdd_mul","module":"Mathlib.Algebra.Group.TypeTags.Basic","initialProofState":"α : Type u\ninst✝ : Add α\nx y : Multiplicative α\n⊢ Eq (Multiplicative.toAdd (HMul.hMul x y)) (HAdd.hAdd (Multiplicative.toAdd x) (Multiplicative.toAdd y))","decl":"@[simp]\ntheorem toAdd_mul [Add α] (x y : Multiplicative α) : (x * y).toAdd = x.toAdd + y.toAdd := rfl\n\n"}
{"name":"ofMul_mul","module":"Mathlib.Algebra.Group.TypeTags.Basic","initialProofState":"α : Type u\ninst✝ : Mul α\nx y : α\n⊢ Eq (Additive.ofMul (HMul.hMul x y)) (HAdd.hAdd (Additive.ofMul x) (Additive.ofMul y))","decl":"@[simp]\ntheorem ofMul_mul [Mul α] (x y : α) : ofMul (x * y) = ofMul x + ofMul y := rfl\n\n"}
{"name":"toMul_add","module":"Mathlib.Algebra.Group.TypeTags.Basic","initialProofState":"α : Type u\ninst✝ : Mul α\nx y : Additive α\n⊢ Eq (Additive.toMul (HAdd.hAdd x y)) (HMul.hMul (Additive.toMul x) (Additive.toMul y))","decl":"@[simp]\ntheorem toMul_add [Mul α] (x y : Additive α) : (x + y).toMul = x.toMul * y.toMul := rfl\n\n"}
{"name":"Additive.isLeftCancelAdd","module":"Mathlib.Algebra.Group.TypeTags.Basic","initialProofState":"α : Type u\ninst✝¹ : Mul α\ninst✝ : IsLeftCancelMul α\n⊢ IsLeftCancelAdd (Additive α)","decl":"instance Additive.isLeftCancelAdd [Mul α] [IsLeftCancelMul α] : IsLeftCancelAdd (Additive α) :=\n  ⟨@mul_left_cancel α _ _⟩\n\n"}
{"name":"Multiplicative.isLeftCancelMul","module":"Mathlib.Algebra.Group.TypeTags.Basic","initialProofState":"α : Type u\ninst✝¹ : Add α\ninst✝ : IsLeftCancelAdd α\n⊢ IsLeftCancelMul (Multiplicative α)","decl":"instance Multiplicative.isLeftCancelMul [Add α] [IsLeftCancelAdd α] :\n    IsLeftCancelMul (Multiplicative α) :=\n  ⟨@add_left_cancel α _ _⟩\n\n"}
{"name":"Additive.isRightCancelAdd","module":"Mathlib.Algebra.Group.TypeTags.Basic","initialProofState":"α : Type u\ninst✝¹ : Mul α\ninst✝ : IsRightCancelMul α\n⊢ IsRightCancelAdd (Additive α)","decl":"instance Additive.isRightCancelAdd [Mul α] [IsRightCancelMul α] : IsRightCancelAdd (Additive α) :=\n  ⟨@mul_right_cancel α _ _⟩\n\n"}
{"name":"Multiplicative.isRightCancelMul","module":"Mathlib.Algebra.Group.TypeTags.Basic","initialProofState":"α : Type u\ninst✝¹ : Add α\ninst✝ : IsRightCancelAdd α\n⊢ IsRightCancelMul (Multiplicative α)","decl":"instance Multiplicative.isRightCancelMul [Add α] [IsRightCancelAdd α] :\n    IsRightCancelMul (Multiplicative α) :=\n  ⟨@add_right_cancel α _ _⟩\n\n"}
{"name":"Additive.isCancelAdd","module":"Mathlib.Algebra.Group.TypeTags.Basic","initialProofState":"α : Type u\ninst✝¹ : Mul α\ninst✝ : IsCancelMul α\n⊢ IsCancelAdd (Additive α)","decl":"instance Additive.isCancelAdd [Mul α] [IsCancelMul α] : IsCancelAdd (Additive α) :=\n  ⟨⟩\n\n"}
{"name":"Multiplicative.isCancelMul","module":"Mathlib.Algebra.Group.TypeTags.Basic","initialProofState":"α : Type u\ninst✝¹ : Add α\ninst✝ : IsCancelAdd α\n⊢ IsCancelMul (Multiplicative α)","decl":"instance Multiplicative.isCancelMul [Add α] [IsCancelAdd α] : IsCancelMul (Multiplicative α) :=\n  ⟨⟩\n\n"}
{"name":"ofMul_one","module":"Mathlib.Algebra.Group.TypeTags.Basic","initialProofState":"α : Type u\ninst✝ : One α\n⊢ Eq (Additive.ofMul 1) 0","decl":"@[simp]\ntheorem ofMul_one [One α] : @Additive.ofMul α 1 = 0 := rfl\n\n"}
{"name":"ofMul_eq_zero","module":"Mathlib.Algebra.Group.TypeTags.Basic","initialProofState":"A : Type u_1\ninst✝ : One A\nx : A\n⊢ Iff (Eq (Additive.ofMul x) 0) (Eq x 1)","decl":"@[simp]\ntheorem ofMul_eq_zero {A : Type*} [One A] {x : A} : Additive.ofMul x = 0 ↔ x = 1 := Iff.rfl\n\n"}
{"name":"toMul_zero","module":"Mathlib.Algebra.Group.TypeTags.Basic","initialProofState":"α : Type u\ninst✝ : One α\n⊢ Eq (Additive.toMul 0) 1","decl":"@[simp]\ntheorem toMul_zero [One α] : (0 : Additive α).toMul = 1 := rfl\n\n"}
{"name":"toMul_eq_one","module":"Mathlib.Algebra.Group.TypeTags.Basic","initialProofState":"α : Type u_1\ninst✝ : One α\nx : Additive α\n⊢ Iff (Eq (Additive.toMul x) 1) (Eq x 0)","decl":"@[simp]\nlemma toMul_eq_one {α : Type*} [One α] {x : Additive α} :\n    x.toMul = 1 ↔ x = 0 :=\n  Iff.rfl\n\n"}
{"name":"ofAdd_zero","module":"Mathlib.Algebra.Group.TypeTags.Basic","initialProofState":"α : Type u\ninst✝ : Zero α\n⊢ Eq (Multiplicative.ofAdd 0) 1","decl":"@[simp]\ntheorem ofAdd_zero [Zero α] : @Multiplicative.ofAdd α 0 = 1 :=\n  rfl\n\n"}
{"name":"ofAdd_eq_one","module":"Mathlib.Algebra.Group.TypeTags.Basic","initialProofState":"A : Type u_1\ninst✝ : Zero A\nx : A\n⊢ Iff (Eq (Multiplicative.ofAdd x) 1) (Eq x 0)","decl":"@[simp]\ntheorem ofAdd_eq_one {A : Type*} [Zero A] {x : A} : Multiplicative.ofAdd x = 1 ↔ x = 0 :=\n  Iff.rfl\n\n"}
{"name":"toAdd_one","module":"Mathlib.Algebra.Group.TypeTags.Basic","initialProofState":"α : Type u\ninst✝ : Zero α\n⊢ Eq (Multiplicative.toAdd 1) 0","decl":"@[simp]\ntheorem toAdd_one [Zero α] : (1 : Multiplicative α).toAdd = 0 :=\n  rfl\n\n"}
{"name":"toAdd_eq_zero","module":"Mathlib.Algebra.Group.TypeTags.Basic","initialProofState":"α : Type u_1\ninst✝ : Zero α\nx : Multiplicative α\n⊢ Iff (Eq (Multiplicative.toAdd x) 0) (Eq x 1)","decl":"@[simp]\nlemma toAdd_eq_zero {α : Type*} [Zero α] {x : Multiplicative α} :\n    x.toAdd = 0 ↔ x = 1 :=\n  Iff.rfl\n\n"}
{"name":"ofMul_pow","module":"Mathlib.Algebra.Group.TypeTags.Basic","initialProofState":"α : Type u\ninst✝ : Monoid α\nn : Nat\na : α\n⊢ Eq (Additive.ofMul (HPow.hPow a n)) (HSMul.hSMul n (Additive.ofMul a))","decl":"@[simp]\ntheorem ofMul_pow [Monoid α] (n : ℕ) (a : α) : ofMul (a ^ n) = n • ofMul a :=\n  rfl\n\n"}
{"name":"toMul_nsmul","module":"Mathlib.Algebra.Group.TypeTags.Basic","initialProofState":"α : Type u\ninst✝ : Monoid α\nn : Nat\na : Additive α\n⊢ Eq (Additive.toMul (HSMul.hSMul n a)) (HPow.hPow (Additive.toMul a) n)","decl":"@[simp]\ntheorem toMul_nsmul [Monoid α] (n : ℕ) (a : Additive α) : (n • a).toMul = a.toMul ^ n :=\n  rfl\n\n"}
{"name":"ofAdd_nsmul","module":"Mathlib.Algebra.Group.TypeTags.Basic","initialProofState":"α : Type u\ninst✝ : AddMonoid α\nn : Nat\na : α\n⊢ Eq (Multiplicative.ofAdd (HSMul.hSMul n a)) (HPow.hPow (Multiplicative.ofAdd a) n)","decl":"@[simp]\ntheorem ofAdd_nsmul [AddMonoid α] (n : ℕ) (a : α) : ofAdd (n • a) = ofAdd a ^ n :=\n  rfl\n\n"}
{"name":"toAdd_pow","module":"Mathlib.Algebra.Group.TypeTags.Basic","initialProofState":"α : Type u\ninst✝ : AddMonoid α\na : Multiplicative α\nn : Nat\n⊢ Eq (Multiplicative.toAdd (HPow.hPow a n)) (HSMul.hSMul n (Multiplicative.toAdd a))","decl":"@[simp]\ntheorem toAdd_pow [AddMonoid α] (a : Multiplicative α) (n : ℕ) : (a ^ n).toAdd = n • a.toAdd :=\n  rfl\n\n"}
{"name":"ofMul_inv","module":"Mathlib.Algebra.Group.TypeTags.Basic","initialProofState":"α : Type u\ninst✝ : Inv α\nx : α\n⊢ Eq (Additive.ofMul (Inv.inv x)) (Neg.neg (Additive.ofMul x))","decl":"@[simp]\ntheorem ofMul_inv [Inv α] (x : α) : ofMul x⁻¹ = -ofMul x :=\n  rfl\n\n"}
{"name":"toMul_neg","module":"Mathlib.Algebra.Group.TypeTags.Basic","initialProofState":"α : Type u\ninst✝ : Inv α\nx : Additive α\n⊢ Eq (Additive.toMul (Neg.neg x)) (Inv.inv (Additive.toMul x))","decl":"@[simp]\ntheorem toMul_neg [Inv α] (x : Additive α) : (-x).toMul = x.toMul⁻¹ :=\n  rfl\n\n"}
{"name":"ofAdd_neg","module":"Mathlib.Algebra.Group.TypeTags.Basic","initialProofState":"α : Type u\ninst✝ : Neg α\nx : α\n⊢ Eq (Multiplicative.ofAdd (Neg.neg x)) (Inv.inv (Multiplicative.ofAdd x))","decl":"@[simp]\ntheorem ofAdd_neg [Neg α] (x : α) : ofAdd (-x) = (ofAdd x)⁻¹ :=\n  rfl\n\n"}
{"name":"toAdd_inv","module":"Mathlib.Algebra.Group.TypeTags.Basic","initialProofState":"α : Type u\ninst✝ : Neg α\nx : Multiplicative α\n⊢ Eq (Multiplicative.toAdd (Inv.inv x)) (Neg.neg (Multiplicative.toAdd x))","decl":"@[simp]\ntheorem toAdd_inv [Neg α] (x : Multiplicative α) : x⁻¹.toAdd = -x.toAdd :=\n  rfl\n\n"}
{"name":"ofAdd_sub","module":"Mathlib.Algebra.Group.TypeTags.Basic","initialProofState":"α : Type u\ninst✝ : Sub α\nx y : α\n⊢ Eq (Multiplicative.ofAdd (HSub.hSub x y)) (HDiv.hDiv (Multiplicative.ofAdd x) (Multiplicative.ofAdd y))","decl":"@[simp]\ntheorem ofAdd_sub [Sub α] (x y : α) : ofAdd (x - y) = ofAdd x / ofAdd y :=\n  rfl\n\n"}
{"name":"toAdd_div","module":"Mathlib.Algebra.Group.TypeTags.Basic","initialProofState":"α : Type u\ninst✝ : Sub α\nx y : Multiplicative α\n⊢ Eq (Multiplicative.toAdd (HDiv.hDiv x y)) (HSub.hSub (Multiplicative.toAdd x) (Multiplicative.toAdd y))","decl":"@[simp]\ntheorem toAdd_div [Sub α] (x y : Multiplicative α) : (x / y).toAdd = x.toAdd - y.toAdd :=\n  rfl\n\n"}
{"name":"ofMul_div","module":"Mathlib.Algebra.Group.TypeTags.Basic","initialProofState":"α : Type u\ninst✝ : Div α\nx y : α\n⊢ Eq (Additive.ofMul (HDiv.hDiv x y)) (HSub.hSub (Additive.ofMul x) (Additive.ofMul y))","decl":"@[simp]\ntheorem ofMul_div [Div α] (x y : α) : ofMul (x / y) = ofMul x - ofMul y :=\n  rfl\n\n"}
{"name":"toMul_sub","module":"Mathlib.Algebra.Group.TypeTags.Basic","initialProofState":"α : Type u\ninst✝ : Div α\nx y : Additive α\n⊢ Eq (Additive.toMul (HSub.hSub x y)) (HDiv.hDiv (Additive.toMul x) (Additive.toMul y))","decl":"@[simp]\ntheorem toMul_sub [Div α] (x y : Additive α) : (x - y).toMul = x.toMul / y.toMul :=\n  rfl\n\n"}
{"name":"ofMul_zpow","module":"Mathlib.Algebra.Group.TypeTags.Basic","initialProofState":"α : Type u\ninst✝ : DivInvMonoid α\nz : Int\na : α\n⊢ Eq (Additive.ofMul (HPow.hPow a z)) (HSMul.hSMul z (Additive.ofMul a))","decl":"@[simp]\ntheorem ofMul_zpow [DivInvMonoid α] (z : ℤ) (a : α) : ofMul (a ^ z) = z • ofMul a :=\n  rfl\n\n"}
{"name":"toMul_zsmul","module":"Mathlib.Algebra.Group.TypeTags.Basic","initialProofState":"α : Type u\ninst✝ : DivInvMonoid α\nz : Int\na : Additive α\n⊢ Eq (Additive.toMul (HSMul.hSMul z a)) (HPow.hPow (Additive.toMul a) z)","decl":"@[simp]\ntheorem toMul_zsmul [DivInvMonoid α] (z : ℤ) (a : Additive α) : (z • a).toMul = a.toMul ^ z :=\n  rfl\n\n"}
{"name":"ofAdd_zsmul","module":"Mathlib.Algebra.Group.TypeTags.Basic","initialProofState":"α : Type u\ninst✝ : SubNegMonoid α\nz : Int\na : α\n⊢ Eq (Multiplicative.ofAdd (HSMul.hSMul z a)) (HPow.hPow (Multiplicative.ofAdd a) z)","decl":"@[simp]\ntheorem ofAdd_zsmul [SubNegMonoid α] (z : ℤ) (a : α) : ofAdd (z • a) = ofAdd a ^ z :=\n  rfl\n\n"}
{"name":"toAdd_zpow","module":"Mathlib.Algebra.Group.TypeTags.Basic","initialProofState":"α : Type u\ninst✝ : SubNegMonoid α\na : Multiplicative α\nz : Int\n⊢ Eq (Multiplicative.toAdd (HPow.hPow a z)) (HSMul.hSMul z (Multiplicative.toAdd a))","decl":"@[simp]\ntheorem toAdd_zpow [SubNegMonoid α] (a : Multiplicative α) (z : ℤ) : (a ^ z).toAdd = z • a.toAdd :=\n  rfl\n\n"}
{"name":"Pi.mulSingle_multiplicativeOfAdd_eq","module":"Mathlib.Algebra.Group.TypeTags.Basic","initialProofState":"ι : Type u_1\ninst✝¹ : DecidableEq ι\nM : ι → Type u_2\ninst✝ : (i : ι) → AddMonoid (M i)\ni : ι\na : M i\nj : ι\n⊢ Eq (Pi.mulSingle i (Multiplicative.ofAdd a) j) (Multiplicative.ofAdd (Pi.single i a j))","decl":"lemma Pi.mulSingle_multiplicativeOfAdd_eq {ι : Type*} [DecidableEq ι] {M : ι → Type*}\n    [(i : ι) → AddMonoid (M i)] (i : ι) (a : M i) (j : ι) :\n    Pi.mulSingle (f := fun i ↦ Multiplicative (M i)) i (Multiplicative.ofAdd a) j =\n      Multiplicative.ofAdd ((Pi.single i a) j) := by\n  rcases eq_or_ne j i with rfl | h\n  · simp only [mulSingle_eq_same, single_eq_same]\n  · simp only [mulSingle, ne_eq, h, not_false_eq_true, Function.update_of_ne, one_apply, single,\n      zero_apply, ofAdd_zero]\n\n"}
{"name":"Pi.single_additiveOfMul_eq","module":"Mathlib.Algebra.Group.TypeTags.Basic","initialProofState":"ι : Type u_1\ninst✝¹ : DecidableEq ι\nM : ι → Type u_2\ninst✝ : (i : ι) → Monoid (M i)\ni : ι\na : M i\nj : ι\n⊢ Eq (Pi.single i (Additive.ofMul a) j) (Additive.ofMul (Pi.mulSingle i a j))","decl":"lemma Pi.single_additiveOfMul_eq {ι : Type*} [DecidableEq ι] {M : ι → Type*}\n    [(i : ι) → Monoid (M i)] (i : ι) (a : M i) (j : ι) :\n    Pi.single (f := fun i ↦ Additive (M i)) i (Additive.ofMul a) j =\n      Additive.ofMul ((Pi.mulSingle i a) j) := by\n  rcases eq_or_ne j i with rfl | h\n  · simp only [mulSingle_eq_same, single_eq_same]\n  · simp only [single, ne_eq, h, not_false_eq_true, Function.update_of_ne, zero_apply, mulSingle,\n      one_apply, ofMul_one]\n"}
