{"name":"WfDvdMonoid.max_power_factor'","module":"Mathlib.RingTheory.UniqueFactorizationDomain.Multiplicity","initialProofState":"α : Type u_1\ninst✝¹ : CommMonoidWithZero α\ninst✝ : WfDvdMonoid α\na₀ x : α\nh : Ne a₀ 0\nhx : Not (IsUnit x)\n⊢ Exists fun n => Exists fun a => And (Not (Dvd.dvd x a)) (Eq a₀ (HMul.hMul (HPow.hPow x n) a))","decl":"theorem WfDvdMonoid.max_power_factor' [CommMonoidWithZero α] [WfDvdMonoid α] {a₀ x : α}\n    (h : a₀ ≠ 0) (hx : ¬IsUnit x) : ∃ (n : ℕ) (a : α), ¬x ∣ a ∧ a₀ = x ^ n * a := by\n  obtain ⟨a, ⟨n, rfl⟩, hm⟩ := wellFounded_dvdNotUnit.has_min\n    {a | ∃ n, x ^ n * a = a₀} ⟨a₀, 0, by rw [pow_zero, one_mul]⟩\n  refine ⟨n, a, ?_, rfl⟩; rintro ⟨d, rfl⟩\n  exact hm d ⟨n + 1, by rw [pow_succ, mul_assoc]⟩\n    ⟨(right_ne_zero_of_mul <| right_ne_zero_of_mul h), x, hx, mul_comm _ _⟩\n\n"}
{"name":"WfDvdMonoid.max_power_factor","module":"Mathlib.RingTheory.UniqueFactorizationDomain.Multiplicity","initialProofState":"α : Type u_1\ninst✝¹ : CommMonoidWithZero α\ninst✝ : WfDvdMonoid α\na₀ x : α\nh : Ne a₀ 0\nhx : Irreducible x\n⊢ Exists fun n => Exists fun a => And (Not (Dvd.dvd x a)) (Eq a₀ (HMul.hMul (HPow.hPow x n) a))","decl":"theorem WfDvdMonoid.max_power_factor [CommMonoidWithZero α] [WfDvdMonoid α] {a₀ x : α}\n    (h : a₀ ≠ 0) (hx : Irreducible x) : ∃ (n : ℕ) (a : α), ¬x ∣ a ∧ a₀ = x ^ n * a :=\n  max_power_factor' h hx.not_unit\n\n"}
{"name":"FiniteMultiplicity.of_not_isUnit","module":"Mathlib.RingTheory.UniqueFactorizationDomain.Multiplicity","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : WfDvdMonoid α\na b : α\nha : Not (IsUnit a)\nhb : Ne b 0\n⊢ FiniteMultiplicity a b","decl":"theorem FiniteMultiplicity.of_not_isUnit [CancelCommMonoidWithZero α] [WfDvdMonoid α]\n    {a b : α} (ha : ¬IsUnit a) (hb : b ≠ 0) : FiniteMultiplicity a b := by\n  obtain ⟨n, c, ndvd, rfl⟩ := WfDvdMonoid.max_power_factor' hb ha\n  exact ⟨n, by rwa [pow_succ, mul_dvd_mul_iff_left (left_ne_zero_of_mul hb)]⟩\n\n"}
{"name":"multiplicity.finite_of_not_isUnit","module":"Mathlib.RingTheory.UniqueFactorizationDomain.Multiplicity","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : WfDvdMonoid α\na b : α\nha : Not (IsUnit a)\nhb : Ne b 0\n⊢ FiniteMultiplicity a b","decl":"@[deprecated (since := \"2024-11-30\")]\nalias multiplicity.finite_of_not_isUnit := FiniteMultiplicity.of_not_isUnit\n\n"}
{"name":"FiniteMultiplicity.of_prime_left","module":"Mathlib.RingTheory.UniqueFactorizationDomain.Multiplicity","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : WfDvdMonoid α\na b : α\nha : Prime a\nhb : Ne b 0\n⊢ FiniteMultiplicity a b","decl":"theorem FiniteMultiplicity.of_prime_left [CancelCommMonoidWithZero α] [WfDvdMonoid α]\n    {a b : α} (ha : Prime a) (hb : b ≠ 0) : FiniteMultiplicity a b :=\n  .of_not_isUnit ha.not_unit hb\n\n"}
{"name":"multiplicity.finite_prime_left","module":"Mathlib.RingTheory.UniqueFactorizationDomain.Multiplicity","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : WfDvdMonoid α\na b : α\nha : Prime a\nhb : Ne b 0\n⊢ FiniteMultiplicity a b","decl":"@[deprecated (since := \"2024-11-30\")]\nalias multiplicity.finite_prime_left := FiniteMultiplicity.of_prime_left\n\n"}
{"name":"UniqueFactorizationMonoid.le_emultiplicity_iff_replicate_le_normalizedFactors","module":"Mathlib.RingTheory.UniqueFactorizationDomain.Multiplicity","initialProofState":"R : Type u_2\ninst✝² : CancelCommMonoidWithZero R\ninst✝¹ : UniqueFactorizationMonoid R\ninst✝ : NormalizationMonoid R\na b : R\nn : Nat\nha : Irreducible a\nhb : Ne b 0\n⊢ Iff (LE.le (↑n) (emultiplicity a b)) (LE.le (Multiset.replicate n (normalize a)) (UniqueFactorizationMonoid.normalizedFactors b))","decl":"theorem le_emultiplicity_iff_replicate_le_normalizedFactors {a b : R} {n : ℕ} (ha : Irreducible a)\n    (hb : b ≠ 0) :\n    ↑n ≤ emultiplicity a b ↔ replicate n (normalize a) ≤ normalizedFactors b := by\n  rw [← pow_dvd_iff_le_emultiplicity]\n  revert b\n  induction' n with n ih; · simp\n  intro b hb\n  constructor\n  · rintro ⟨c, rfl⟩\n    rw [Ne, pow_succ', mul_assoc, mul_eq_zero, not_or] at hb\n    rw [pow_succ', mul_assoc, normalizedFactors_mul hb.1 hb.2, replicate_succ,\n      normalizedFactors_irreducible ha, singleton_add, cons_le_cons_iff, ← ih hb.2]\n    apply Dvd.intro _ rfl\n  · rw [Multiset.le_iff_exists_add]\n    rintro ⟨u, hu⟩\n    rw [← (prod_normalizedFactors hb).dvd_iff_dvd_right, hu, prod_add, prod_replicate]\n    exact (Associated.pow_pow <| associated_normalize a).dvd.trans (Dvd.intro u.prod rfl)\n\n"}
{"name":"UniqueFactorizationMonoid.emultiplicity_eq_count_normalizedFactors","module":"Mathlib.RingTheory.UniqueFactorizationDomain.Multiplicity","initialProofState":"R : Type u_2\ninst✝³ : CancelCommMonoidWithZero R\ninst✝² : UniqueFactorizationMonoid R\ninst✝¹ : NormalizationMonoid R\ninst✝ : DecidableEq R\na b : R\nha : Irreducible a\nhb : Ne b 0\n⊢ Eq (emultiplicity a b) ↑(Multiset.count (normalize a) (UniqueFactorizationMonoid.normalizedFactors b))","decl":"/-- The multiplicity of an irreducible factor of a nonzero element is exactly the number of times\nthe normalized factor occurs in the `normalizedFactors`.\n\nSee also `count_normalizedFactors_eq` which expands the definition of `multiplicity`\nto produce a specification for `count (normalizedFactors _) _`..\n-/\ntheorem emultiplicity_eq_count_normalizedFactors [DecidableEq R] {a b : R} (ha : Irreducible a)\n    (hb : b ≠ 0) : emultiplicity a b = (normalizedFactors b).count (normalize a) := by\n  apply le_antisymm\n  · apply Order.le_of_lt_add_one\n    rw [← Nat.cast_one, ← Nat.cast_add, lt_iff_not_ge, ge_iff_le,\n      le_emultiplicity_iff_replicate_le_normalizedFactors ha hb, ← le_count_iff_replicate_le]\n    simp\n  rw [le_emultiplicity_iff_replicate_le_normalizedFactors ha hb, ← le_count_iff_replicate_le]\n\n"}
{"name":"UniqueFactorizationMonoid.count_normalizedFactors_eq","module":"Mathlib.RingTheory.UniqueFactorizationDomain.Multiplicity","initialProofState":"R : Type u_2\ninst✝³ : CancelCommMonoidWithZero R\ninst✝² : UniqueFactorizationMonoid R\ninst✝¹ : NormalizationMonoid R\ninst✝ : DecidableEq R\np x : R\nhp : Irreducible p\nhnorm : Eq (normalize p) p\nn : Nat\nhle : Dvd.dvd (HPow.hPow p n) x\nhlt : Not (Dvd.dvd (HPow.hPow p (HAdd.hAdd n 1)) x)\n⊢ Eq (Multiset.count p (UniqueFactorizationMonoid.normalizedFactors x)) n","decl":"/-- The number of times an irreducible factor `p` appears in `normalizedFactors x` is defined by\nthe number of times it divides `x`.\n\nSee also `multiplicity_eq_count_normalizedFactors` if `n` is given by `multiplicity p x`.\n-/\ntheorem count_normalizedFactors_eq [DecidableEq R] {p x : R} (hp : Irreducible p)\n    (hnorm : normalize p = p) {n : ℕ} (hle : p ^ n ∣ x) (hlt : ¬p ^ (n + 1) ∣ x) :\n    (normalizedFactors x).count p = n := by classical\n  by_cases hx0 : x = 0\n  · simp [hx0] at hlt\n  apply Nat.cast_injective (R := ℕ∞)\n  convert (emultiplicity_eq_count_normalizedFactors hp hx0).symm\n  · exact hnorm.symm\n  exact (emultiplicity_eq_coe.mpr ⟨hle, hlt⟩).symm\n\n"}
{"name":"UniqueFactorizationMonoid.count_normalizedFactors_eq'","module":"Mathlib.RingTheory.UniqueFactorizationDomain.Multiplicity","initialProofState":"R : Type u_2\ninst✝³ : CancelCommMonoidWithZero R\ninst✝² : UniqueFactorizationMonoid R\ninst✝¹ : NormalizationMonoid R\ninst✝ : DecidableEq R\np x : R\nhp : Or (Eq p 0) (Irreducible p)\nhnorm : Eq (normalize p) p\nn : Nat\nhle : Dvd.dvd (HPow.hPow p n) x\nhlt : Not (Dvd.dvd (HPow.hPow p (HAdd.hAdd n 1)) x)\n⊢ Eq (Multiset.count p (UniqueFactorizationMonoid.normalizedFactors x)) n","decl":"/-- The number of times an irreducible factor `p` appears in `normalizedFactors x` is defined by\nthe number of times it divides `x`. This is a slightly more general version of\n`UniqueFactorizationMonoid.count_normalizedFactors_eq` that allows `p = 0`.\n\nSee also `multiplicity_eq_count_normalizedFactors` if `n` is given by `multiplicity p x`.\n-/\ntheorem count_normalizedFactors_eq' [DecidableEq R] {p x : R} (hp : p = 0 ∨ Irreducible p)\n    (hnorm : normalize p = p) {n : ℕ} (hle : p ^ n ∣ x) (hlt : ¬p ^ (n + 1) ∣ x) :\n    (normalizedFactors x).count p = n := by\n  rcases hp with (rfl | hp)\n  · cases n\n    · exact count_eq_zero.2 (zero_not_mem_normalizedFactors _)\n    · rw [zero_pow (Nat.succ_ne_zero _)] at hle hlt\n      exact absurd hle hlt\n  · exact count_normalizedFactors_eq hp hnorm hle hlt\n\n"}
