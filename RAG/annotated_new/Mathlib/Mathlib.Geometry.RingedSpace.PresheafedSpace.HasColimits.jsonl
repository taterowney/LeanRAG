{"name":"AlgebraicGeometry.PresheafedSpace.map_id_c_app","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.HasColimits","initialProofState":"J : Type u'\ninstâœÂ¹ : CategoryTheory.Category.{v', u'} J\nC : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J (AlgebraicGeometry.PresheafedSpace C)\nj : J\nU : Opposite (TopologicalSpace.Opens â†‘â†‘(F.obj j))\nâŠ¢ Eq ((F.map (CategoryTheory.CategoryStruct.id j)).c.app U) (CategoryTheory.CategoryStruct.comp ((TopCat.Presheaf.Pushforward.id (F.obj j).presheaf).inv.app U) ((TopCat.Presheaf.pushforwardEq â‹¯ (F.obj j).presheaf).hom.app U))","decl":"@[simp]\ntheorem map_id_c_app (F : J â¥¤ PresheafedSpace.{_, _, v} C) (j) (U) :\n    (F.map (ğŸ™ j)).c.app U =\n      (Pushforward.id (F.obj j).presheaf).inv.app U â‰«\n        (pushforwardEq (by simp) (F.obj j).presheaf).hom.app U := by\n  simp [PresheafedSpace.congr_app (F.map_id j)]\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.map_comp_c_app","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.HasColimits","initialProofState":"J : Type u'\ninstâœÂ¹ : CategoryTheory.Category.{v', u'} J\nC : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J (AlgebraicGeometry.PresheafedSpace C)\njâ‚ jâ‚‚ jâ‚ƒ : J\nf : Quiver.Hom jâ‚ jâ‚‚\ng : Quiver.Hom jâ‚‚ jâ‚ƒ\nU : Opposite (TopologicalSpace.Opens â†‘â†‘(F.obj jâ‚ƒ))\nâŠ¢ Eq ((F.map (CategoryTheory.CategoryStruct.comp f g)).c.app U) (CategoryTheory.CategoryStruct.comp ((F.map g).c.app U) (CategoryTheory.CategoryStruct.comp (((TopCat.Presheaf.pushforward C (F.map g).base).map (F.map f).c).app U) ((TopCat.Presheaf.pushforwardEq â‹¯ (F.obj jâ‚).presheaf).hom.app U)))","decl":"@[simp]\ntheorem map_comp_c_app (F : J â¥¤ PresheafedSpace.{_, _, v} C) {jâ‚ jâ‚‚ jâ‚ƒ}\n    (f : jâ‚ âŸ¶ jâ‚‚) (g : jâ‚‚ âŸ¶ jâ‚ƒ) (U) :\n    (F.map (f â‰« g)).c.app U =\n      (F.map g).c.app U â‰«\n        ((pushforward C (F.map g).base).map (F.map f).c).app U â‰«\n          (pushforwardEq (congr_arg Hom.base (F.map_comp f g).symm) _).hom.app U := by\n  simp [PresheafedSpace.congr_app (F.map_comp f g)]\n\n-- See note [dsimp, simp]\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.componentwiseDiagram_map","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.HasColimits","initialProofState":"J : Type u'\ninstâœÂ² : CategoryTheory.Category.{v', u'} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J (AlgebraicGeometry.PresheafedSpace C)\ninstâœ : CategoryTheory.Limits.HasColimit F\nU : TopologicalSpace.Opens â†‘â†‘(CategoryTheory.Limits.colimit F)\nj k : Opposite J\nf : Quiver.Hom j k\nâŠ¢ Eq ((AlgebraicGeometry.PresheafedSpace.componentwiseDiagram F U).map f) (CategoryTheory.CategoryStruct.comp ((F.map f.unop).c.app { unop := (TopologicalSpace.Opens.map (CategoryTheory.Limits.colimit.Î¹ F (Opposite.unop j)).base).obj U }) ((F.obj (Opposite.unop k)).presheaf.map (CategoryTheory.eqToHom â‹¯)))","decl":"/-- Given a diagram of `PresheafedSpace C`s, its colimit is computed by pushing the sheaves onto\nthe colimit of the underlying spaces, and taking componentwise limit.\nThis is the componentwise diagram for an open set `U` of the colimit of the underlying spaces.\n-/\n@[simps]\ndef componentwiseDiagram (F : J â¥¤ PresheafedSpace.{_, _, v} C) [HasColimit F]\n    (U : Opens (Limits.colimit F).carrier) : Jáµ’áµ– â¥¤ C where\n  obj j := (F.obj (unop j)).presheaf.obj (op ((Opens.map (colimit.Î¹ F (unop j)).base).obj U))\n  map {j k} f := (F.map f.unop).c.app _ â‰«\n    (F.obj (unop k)).presheaf.map (eqToHom (by rw [â† colimit.w F f.unop, comp_base]; rfl))\n  map_comp {i j k} f g := by\n    dsimp\n    simp only [assoc, CategoryTheory.NatTrans.naturality_assoc]\n    simp\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.componentwiseDiagram_obj","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.HasColimits","initialProofState":"J : Type u'\ninstâœÂ² : CategoryTheory.Category.{v', u'} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J (AlgebraicGeometry.PresheafedSpace C)\ninstâœ : CategoryTheory.Limits.HasColimit F\nU : TopologicalSpace.Opens â†‘â†‘(CategoryTheory.Limits.colimit F)\nj : Opposite J\nâŠ¢ Eq ((AlgebraicGeometry.PresheafedSpace.componentwiseDiagram F U).obj j) ((F.obj (Opposite.unop j)).presheaf.obj { unop := (TopologicalSpace.Opens.map (CategoryTheory.Limits.colimit.Î¹ F (Opposite.unop j)).base).obj U })","decl":"/-- Given a diagram of `PresheafedSpace C`s, its colimit is computed by pushing the sheaves onto\nthe colimit of the underlying spaces, and taking componentwise limit.\nThis is the componentwise diagram for an open set `U` of the colimit of the underlying spaces.\n-/\n@[simps]\ndef componentwiseDiagram (F : J â¥¤ PresheafedSpace.{_, _, v} C) [HasColimit F]\n    (U : Opens (Limits.colimit F).carrier) : Jáµ’áµ– â¥¤ C where\n  obj j := (F.obj (unop j)).presheaf.obj (op ((Opens.map (colimit.Î¹ F (unop j)).base).obj U))\n  map {j k} f := (F.map f.unop).c.app _ â‰«\n    (F.obj (unop k)).presheaf.map (eqToHom (by rw [â† colimit.w F f.unop, comp_base]; rfl))\n  map_comp {i j k} f g := by\n    dsimp\n    simp only [assoc, CategoryTheory.NatTrans.naturality_assoc]\n    simp\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.pushforwardDiagramToColimit_map","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.HasColimits","initialProofState":"J : Type u'\ninstâœÂ² : CategoryTheory.Category.{v', u'} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasColimitsOfShape J TopCat\nF : CategoryTheory.Functor J (AlgebraicGeometry.PresheafedSpace C)\nj j' : J\nf : Quiver.Hom j j'\nâŠ¢ Eq ((AlgebraicGeometry.PresheafedSpace.pushforwardDiagramToColimit F).map f) (CategoryTheory.CategoryStruct.comp ((TopCat.Presheaf.pushforward C (CategoryTheory.Limits.colimit.Î¹ (F.comp (AlgebraicGeometry.PresheafedSpace.forget C)) j')).map (F.map f).c) (CategoryTheory.CategoryStruct.comp (TopCat.Presheaf.Pushforward.comp ((F.comp (AlgebraicGeometry.PresheafedSpace.forget C)).map f) (CategoryTheory.Limits.colimit.Î¹ (F.comp (AlgebraicGeometry.PresheafedSpace.forget C)) j') (F.obj j).presheaf).inv (TopCat.Presheaf.pushforwardEq â‹¯ (F.obj j).presheaf).hom)).op","decl":"/-- Given a diagram of presheafed spaces,\nwe can push all the presheaves forward to the colimit `X` of the underlying topological spaces,\nobtaining a diagram in `(Presheaf C X)áµ’áµ–`.\n-/\n@[simps]\ndef pushforwardDiagramToColimit (F : J â¥¤ PresheafedSpace.{_, _, v} C) :\n    J â¥¤ (Presheaf C (colimit (F â‹™ PresheafedSpace.forget C)))áµ’áµ– where\n  obj j := op (colimit.Î¹ (F â‹™ PresheafedSpace.forget C) j _* (F.obj j).presheaf)\n  map {j j'} f :=\n    ((pushforward C (colimit.Î¹ (F â‹™ PresheafedSpace.forget C) j')).map (F.map f).c â‰«\n      (Pushforward.comp ((F â‹™ PresheafedSpace.forget C).map f)\n        (colimit.Î¹ (F â‹™ PresheafedSpace.forget C) j') (F.obj j).presheaf).inv â‰«\n      (pushforwardEq (colimit.w (F â‹™ PresheafedSpace.forget C) f) (F.obj j).presheaf).hom).op\n  map_id j := by\n    apply (opEquiv _ _).injective\n    refine NatTrans.ext (funext fun U => ?_)\n    induction U with\n    | h U =>\n      simp [opEquiv]\n      rfl\n  map_comp {jâ‚ jâ‚‚ jâ‚ƒ} f g := by\n    apply (opEquiv _ _).injective\n    refine NatTrans.ext (funext fun U => ?_)\n    dsimp [opEquiv]\n    have :\n      op ((Opens.map (F.map g).base).obj\n          ((Opens.map (colimit.Î¹ (F â‹™ forget C) jâ‚ƒ)).obj U.unop)) =\n        op ((Opens.map (colimit.Î¹ (F â‹™ PresheafedSpace.forget C) jâ‚‚)).obj (unop U)) := by\n      apply unop_injective\n      rw [â† Opens.map_comp_obj]\n      congr\n      exact colimit.w (F â‹™ PresheafedSpace.forget C) g\n    simp only [map_comp_c_app, pushforward_obj_obj, pushforward_map_app, comp_base,\n      pushforwardEq_hom_app, op_obj, Opens.map_comp_obj, id_comp, assoc, eqToHom_map_comp,\n      NatTrans.naturality_assoc, pushforward_obj_map, eqToHom_unop]\n    simp [NatTrans.congr (Î± := (F.map f).c) this]\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.pushforwardDiagramToColimit_obj","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.HasColimits","initialProofState":"J : Type u'\ninstâœÂ² : CategoryTheory.Category.{v', u'} J\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasColimitsOfShape J TopCat\nF : CategoryTheory.Functor J (AlgebraicGeometry.PresheafedSpace C)\nj : J\nâŠ¢ Eq ((AlgebraicGeometry.PresheafedSpace.pushforwardDiagramToColimit F).obj j) { unop := (TopCat.Presheaf.pushforward C (CategoryTheory.Limits.colimit.Î¹ (F.comp (AlgebraicGeometry.PresheafedSpace.forget C)) j)).obj (F.obj j).presheaf }","decl":"/-- Given a diagram of presheafed spaces,\nwe can push all the presheaves forward to the colimit `X` of the underlying topological spaces,\nobtaining a diagram in `(Presheaf C X)áµ’áµ–`.\n-/\n@[simps]\ndef pushforwardDiagramToColimit (F : J â¥¤ PresheafedSpace.{_, _, v} C) :\n    J â¥¤ (Presheaf C (colimit (F â‹™ PresheafedSpace.forget C)))áµ’áµ– where\n  obj j := op (colimit.Î¹ (F â‹™ PresheafedSpace.forget C) j _* (F.obj j).presheaf)\n  map {j j'} f :=\n    ((pushforward C (colimit.Î¹ (F â‹™ PresheafedSpace.forget C) j')).map (F.map f).c â‰«\n      (Pushforward.comp ((F â‹™ PresheafedSpace.forget C).map f)\n        (colimit.Î¹ (F â‹™ PresheafedSpace.forget C) j') (F.obj j).presheaf).inv â‰«\n      (pushforwardEq (colimit.w (F â‹™ PresheafedSpace.forget C) f) (F.obj j).presheaf).hom).op\n  map_id j := by\n    apply (opEquiv _ _).injective\n    refine NatTrans.ext (funext fun U => ?_)\n    induction U with\n    | h U =>\n      simp [opEquiv]\n      rfl\n  map_comp {jâ‚ jâ‚‚ jâ‚ƒ} f g := by\n    apply (opEquiv _ _).injective\n    refine NatTrans.ext (funext fun U => ?_)\n    dsimp [opEquiv]\n    have :\n      op ((Opens.map (F.map g).base).obj\n          ((Opens.map (colimit.Î¹ (F â‹™ forget C) jâ‚ƒ)).obj U.unop)) =\n        op ((Opens.map (colimit.Î¹ (F â‹™ PresheafedSpace.forget C) jâ‚‚)).obj (unop U)) := by\n      apply unop_injective\n      rw [â† Opens.map_comp_obj]\n      congr\n      exact colimit.w (F â‹™ PresheafedSpace.forget C) g\n    simp only [map_comp_c_app, pushforward_obj_obj, pushforward_map_app, comp_base,\n      pushforwardEq_hom_app, op_obj, Opens.map_comp_obj, id_comp, assoc, eqToHom_map_comp,\n      NatTrans.naturality_assoc, pushforward_obj_map, eqToHom_unop]\n    simp [NatTrans.congr (Î± := (F.map f).c) this]\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.colimit_carrier","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.HasColimits","initialProofState":"J : Type u'\ninstâœÂ³ : CategoryTheory.Category.{v', u'} J\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasColimitsOfShape J TopCat\ninstâœ : âˆ€ (X : TopCat), CategoryTheory.Limits.HasLimitsOfShape (Opposite J) (TopCat.Presheaf C X)\nF : CategoryTheory.Functor J (AlgebraicGeometry.PresheafedSpace C)\nâŠ¢ Eq (â†‘(AlgebraicGeometry.PresheafedSpace.colimit F)) (CategoryTheory.Limits.colimit (F.comp (AlgebraicGeometry.PresheafedSpace.forget C)))","decl":"@[simp]\ntheorem colimit_carrier (F : J â¥¤ PresheafedSpace.{_, _, v} C) :\n    (colimit F).carrier = Limits.colimit (F â‹™ PresheafedSpace.forget C) :=\n  rfl\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.colimit_presheaf","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.HasColimits","initialProofState":"J : Type u'\ninstâœÂ³ : CategoryTheory.Category.{v', u'} J\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasColimitsOfShape J TopCat\ninstâœ : âˆ€ (X : TopCat), CategoryTheory.Limits.HasLimitsOfShape (Opposite J) (TopCat.Presheaf C X)\nF : CategoryTheory.Functor J (AlgebraicGeometry.PresheafedSpace C)\nâŠ¢ Eq (AlgebraicGeometry.PresheafedSpace.colimit F).presheaf (CategoryTheory.Limits.limit (AlgebraicGeometry.PresheafedSpace.pushforwardDiagramToColimit F).leftOp)","decl":"@[simp]\ntheorem colimit_presheaf (F : J â¥¤ PresheafedSpace.{_, _, v} C) :\n    (colimit F).presheaf = limit (pushforwardDiagramToColimit F).leftOp :=\n  rfl\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.colimitCocone_Î¹_app_base","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.HasColimits","initialProofState":"J : Type u'\ninstâœÂ³ : CategoryTheory.Category.{v', u'} J\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasColimitsOfShape J TopCat\ninstâœ : âˆ€ (X : TopCat), CategoryTheory.Limits.HasLimitsOfShape (Opposite J) (TopCat.Presheaf C X)\nF : CategoryTheory.Functor J (AlgebraicGeometry.PresheafedSpace C)\nj : J\nâŠ¢ Eq ((AlgebraicGeometry.PresheafedSpace.colimitCocone F).Î¹.app j).base (CategoryTheory.Limits.colimit.Î¹ (F.comp (AlgebraicGeometry.PresheafedSpace.forget C)) j)","decl":"/-- Auxiliary definition for `AlgebraicGeometry.PresheafedSpace.instHasColimits`.\n-/\n@[simps]\ndef colimitCocone (F : J â¥¤ PresheafedSpace.{_, _, v} C) : Cocone F where\n  pt := colimit F\n  Î¹ :=\n    { app := fun j =>\n        { base := colimit.Î¹ (F â‹™ PresheafedSpace.forget C) j\n          c := limit.Ï€ _ (op j) }\n      naturality := fun {j j'} f => by\n        ext1\n        Â· ext x\n          exact colimit.w_apply (F â‹™ PresheafedSpace.forget C) f x\n        Â· ext âŸ¨U, hUâŸ©\n          dsimp [-Presheaf.comp_app]\n          rw [PresheafedSpace.id_c_app, map_id]\n          erw [id_comp]\n          rw [NatTrans.comp_app, PresheafedSpace.comp_c_app, whiskerRight_app, eqToHom_app,\n            â† congr_arg NatTrans.app (limit.w (pushforwardDiagramToColimit F).leftOp f.op),\n            NatTrans.comp_app, Functor.leftOp_map, pushforwardDiagramToColimit_map]\n          simp }\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.colimitCocone_Î¹_app_c","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.HasColimits","initialProofState":"J : Type u'\ninstâœÂ³ : CategoryTheory.Category.{v', u'} J\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasColimitsOfShape J TopCat\ninstâœ : âˆ€ (X : TopCat), CategoryTheory.Limits.HasLimitsOfShape (Opposite J) (TopCat.Presheaf C X)\nF : CategoryTheory.Functor J (AlgebraicGeometry.PresheafedSpace C)\nj : J\nâŠ¢ Eq ((AlgebraicGeometry.PresheafedSpace.colimitCocone F).Î¹.app j).c (CategoryTheory.Limits.limit.Ï€ (AlgebraicGeometry.PresheafedSpace.pushforwardDiagramToColimit F).leftOp { unop := j })","decl":"/-- Auxiliary definition for `AlgebraicGeometry.PresheafedSpace.instHasColimits`.\n-/\n@[simps]\ndef colimitCocone (F : J â¥¤ PresheafedSpace.{_, _, v} C) : Cocone F where\n  pt := colimit F\n  Î¹ :=\n    { app := fun j =>\n        { base := colimit.Î¹ (F â‹™ PresheafedSpace.forget C) j\n          c := limit.Ï€ _ (op j) }\n      naturality := fun {j j'} f => by\n        ext1\n        Â· ext x\n          exact colimit.w_apply (F â‹™ PresheafedSpace.forget C) f x\n        Â· ext âŸ¨U, hUâŸ©\n          dsimp [-Presheaf.comp_app]\n          rw [PresheafedSpace.id_c_app, map_id]\n          erw [id_comp]\n          rw [NatTrans.comp_app, PresheafedSpace.comp_c_app, whiskerRight_app, eqToHom_app,\n            â† congr_arg NatTrans.app (limit.w (pushforwardDiagramToColimit F).leftOp f.op),\n            NatTrans.comp_app, Functor.leftOp_map, pushforwardDiagramToColimit_map]\n          simp }\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.colimitCocone_pt","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.HasColimits","initialProofState":"J : Type u'\ninstâœÂ³ : CategoryTheory.Category.{v', u'} J\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasColimitsOfShape J TopCat\ninstâœ : âˆ€ (X : TopCat), CategoryTheory.Limits.HasLimitsOfShape (Opposite J) (TopCat.Presheaf C X)\nF : CategoryTheory.Functor J (AlgebraicGeometry.PresheafedSpace C)\nâŠ¢ Eq (AlgebraicGeometry.PresheafedSpace.colimitCocone F).pt (AlgebraicGeometry.PresheafedSpace.colimit F)","decl":"/-- Auxiliary definition for `AlgebraicGeometry.PresheafedSpace.instHasColimits`.\n-/\n@[simps]\ndef colimitCocone (F : J â¥¤ PresheafedSpace.{_, _, v} C) : Cocone F where\n  pt := colimit F\n  Î¹ :=\n    { app := fun j =>\n        { base := colimit.Î¹ (F â‹™ PresheafedSpace.forget C) j\n          c := limit.Ï€ _ (op j) }\n      naturality := fun {j j'} f => by\n        ext1\n        Â· ext x\n          exact colimit.w_apply (F â‹™ PresheafedSpace.forget C) f x\n        Â· ext âŸ¨U, hUâŸ©\n          dsimp [-Presheaf.comp_app]\n          rw [PresheafedSpace.id_c_app, map_id]\n          erw [id_comp]\n          rw [NatTrans.comp_app, PresheafedSpace.comp_c_app, whiskerRight_app, eqToHom_app,\n            â† congr_arg NatTrans.app (limit.w (pushforwardDiagramToColimit F).leftOp f.op),\n            NatTrans.comp_app, Functor.leftOp_map, pushforwardDiagramToColimit_map]\n          simp }\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.ColimitCoconeIsColimit.desc_c_naturality","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.HasColimits","initialProofState":"J : Type u'\ninstâœâ´ : CategoryTheory.Category.{v', u'} J\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasColimitsOfShape J TopCat\ninstâœÂ¹ : âˆ€ (X : TopCat), CategoryTheory.Limits.HasLimitsOfShape (Opposite J) (TopCat.Presheaf C X)\ninstâœ : CategoryTheory.Limits.HasLimitsOfShape (Opposite J) C\nF : CategoryTheory.Functor J (AlgebraicGeometry.PresheafedSpace C)\ns : CategoryTheory.Limits.Cocone F\nU V : Opposite (TopologicalSpace.Opens â†‘â†‘s.pt)\ni : Quiver.Hom U V\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (s.pt.presheaf.map i) (AlgebraicGeometry.PresheafedSpace.ColimitCoconeIsColimit.descCApp F s V)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.PresheafedSpace.ColimitCoconeIsColimit.descCApp F s U) (((TopCat.Presheaf.pushforward C (CategoryTheory.Limits.colimit.desc (F.comp (AlgebraicGeometry.PresheafedSpace.forget C)) ((AlgebraicGeometry.PresheafedSpace.forget C).mapCocone s))).obj (AlgebraicGeometry.PresheafedSpace.colimitCocone F).pt.presheaf).map i))","decl":"theorem desc_c_naturality (F : J â¥¤ PresheafedSpace.{_, _, v} C) (s : Cocone F)\n    {U V : (Opens s.pt.carrier)áµ’áµ–} (i : U âŸ¶ V) :\n    s.pt.presheaf.map i â‰« descCApp F s V =\n      descCApp F s U â‰«\n        (colimit.desc (F â‹™ forget C) ((forget C).mapCocone s) _* (colimitCocone F).pt.presheaf).map\n          i := by\n  dsimp [descCApp]\n  refine limit_obj_ext (fun j => ?_)\n  have w := Functor.congr_hom (congr_arg Opens.map\n    (colimit.Î¹_desc ((PresheafedSpace.forget C).mapCocone s) (unop j))) i.unop\n  simp only [Opens.map_comp_map] at w\n  simp [congr_arg Quiver.Hom.op w]\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.ColimitCoconeIsColimit.desc_fac","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.HasColimits","initialProofState":"J : Type u'\ninstâœâ´ : CategoryTheory.Category.{v', u'} J\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasColimitsOfShape J TopCat\ninstâœÂ¹ : âˆ€ (X : TopCat), CategoryTheory.Limits.HasLimitsOfShape (Opposite J) (TopCat.Presheaf C X)\ninstâœ : CategoryTheory.Limits.HasLimitsOfShape (Opposite J) C\nF : CategoryTheory.Functor J (AlgebraicGeometry.PresheafedSpace C)\ns : CategoryTheory.Limits.Cocone F\nj : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((AlgebraicGeometry.PresheafedSpace.colimitCocone F).Î¹.app j) (AlgebraicGeometry.PresheafedSpace.ColimitCoconeIsColimit.desc F s)) (s.Î¹.app j)","decl":"theorem desc_fac (F : J â¥¤ PresheafedSpace.{_, _, v} C) (s : Cocone F) (j : J) :\n    (colimitCocone F).Î¹.app j â‰« desc F s = s.Î¹.app j := by\n  ext U\n  Â· simp [desc]\n  Â· -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): the original proof is just `ext; dsimp [desc, descCApp]; simpa`,\n    -- but this has to be expanded a bit\n    rw [NatTrans.comp_app, PresheafedSpace.comp_c_app, whiskerRight_app]\n    dsimp [desc, descCApp]\n    simp only [eqToHom_app, op_obj, Opens.map_comp_obj, eqToHom_map, Functor.leftOp, assoc]\n    rw [limitObjIsoLimitCompEvaluation_inv_Ï€_app_assoc]\n    simp\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.instHasColimitsOfShape","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.HasColimits","initialProofState":"J : Type u'\ninstâœâ´ : CategoryTheory.Category.{v', u'} J\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasColimitsOfShape J TopCat\ninstâœÂ¹ : âˆ€ (X : TopCat), CategoryTheory.Limits.HasLimitsOfShape (Opposite J) (TopCat.Presheaf C X)\ninstâœ : CategoryTheory.Limits.HasLimitsOfShape (Opposite J) C\nâŠ¢ CategoryTheory.Limits.HasColimitsOfShape J (AlgebraicGeometry.PresheafedSpace C)","decl":"instance : HasColimitsOfShape J (PresheafedSpace.{_, _, v} C) where\n  has_colimit F := âŸ¨colimitCocone F, colimitCoconeIsColimit FâŸ©\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.instPreservesColimitsOfShapeTopCatForget","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.HasColimits","initialProofState":"J : Type u'\ninstâœâ´ : CategoryTheory.Category.{v', u'} J\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasColimitsOfShape J TopCat\ninstâœÂ¹ : âˆ€ (X : TopCat), CategoryTheory.Limits.HasLimitsOfShape (Opposite J) (TopCat.Presheaf C X)\ninstâœ : CategoryTheory.Limits.HasLimitsOfShape (Opposite J) C\nâŠ¢ CategoryTheory.Limits.PreservesColimitsOfShape J (AlgebraicGeometry.PresheafedSpace.forget C)","decl":"instance : PreservesColimitsOfShape J (PresheafedSpace.forget.{u, v, v} C) :=\n  âŸ¨fun {F} => preservesColimit_of_preserves_colimit_cocone (colimitCoconeIsColimit F) <| by\n    apply IsColimit.ofIsoColimit (colimit.isColimit _)\n    fapply Cocones.ext\n    Â· rfl\n    Â· intro j\n      simpâŸ©\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.instHasColimits","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.HasColimits","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasLimits C\nâŠ¢ CategoryTheory.Limits.HasColimits (AlgebraicGeometry.PresheafedSpace C)","decl":"/-- When `C` has limits, the category of presheaved spaces with values in `C` itself has colimits.\n-/\ninstance instHasColimits [HasLimits C] : HasColimits (PresheafedSpace.{_, _, v} C) :=\n  âŸ¨fun {_ _} => âŸ¨fun {F} => âŸ¨colimitCocone F, colimitCoconeIsColimit FâŸ©âŸ©âŸ©\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.forget_preservesColimits","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.HasColimits","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasLimits C\nâŠ¢ CategoryTheory.Limits.PreservesColimits (AlgebraicGeometry.PresheafedSpace.forget C)","decl":"/-- The underlying topological space of a colimit of presheaved spaces is\nthe colimit of the underlying topological spaces.\n-/\ninstance forget_preservesColimits [HasLimits C] :\n    PreservesColimits (PresheafedSpace.forget.{_, _, v} C) where\n  preservesColimitsOfShape {J ğ’¥} :=\n    { preservesColimit := fun {F} => preservesColimit_of_preserves_colimit_cocone\n          (colimitCoconeIsColimit F)\n          (IsColimit.ofIsoColimit (colimit.isColimit _) (Cocones.ext (Iso.refl _))) }\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.colimitPresheafObjIsoComponentwiseLimit_inv_Î¹_app","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.HasColimits","initialProofState":"J : Type u'\ninstâœâ´ : CategoryTheory.Category.{v', u'} J\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasColimitsOfShape J TopCat\ninstâœÂ¹ : âˆ€ (X : TopCat), CategoryTheory.Limits.HasLimitsOfShape (Opposite J) (TopCat.Presheaf C X)\ninstâœ : CategoryTheory.Limits.HasLimitsOfShape (Opposite J) C\nF : CategoryTheory.Functor J (AlgebraicGeometry.PresheafedSpace C)\nU : TopologicalSpace.Opens â†‘â†‘(CategoryTheory.Limits.colimit F)\nj : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.PresheafedSpace.colimitPresheafObjIsoComponentwiseLimit F U).inv ((CategoryTheory.Limits.colimit.Î¹ F j).c.app { unop := U })) (CategoryTheory.Limits.limit.Ï€ (AlgebraicGeometry.PresheafedSpace.componentwiseDiagram F U) { unop := j })","decl":"@[simp]\ntheorem colimitPresheafObjIsoComponentwiseLimit_inv_Î¹_app (F : J â¥¤ PresheafedSpace.{_, _, v} C)\n    (U : Opens (Limits.colimit F).carrier) (j : J) :\n    (colimitPresheafObjIsoComponentwiseLimit F U).inv â‰« (colimit.Î¹ F j).c.app (op U) =\n      limit.Ï€ _ (op j) := by\n  delta colimitPresheafObjIsoComponentwiseLimit\n  rw [Iso.trans_inv, Iso.trans_inv, Iso.app_inv, sheafIsoOfIso_inv, pushforwardToOfIso_app,\n    congr_app (Iso.symm_inv _)]\n  dsimp\n  rw [map_id, comp_id, assoc, assoc, assoc, NatTrans.naturality,\n      â† comp_c_app_assoc,\n      congr_app (colimit.isoColimitCocone_Î¹_hom _ _), assoc]\n  erw [limitObjIsoLimitCompEvaluation_inv_Ï€_app_assoc, limMap_Ï€_assoc]\n  -- Porting note: `convert` doesn't work due to meta variable, so change to a `suffices` block\n  set f := _\n  change _ â‰« f = _\n  suffices f_eq : f = ğŸ™ _ by rw [f_eq, comp_id]\n  erw [â† (F.obj j).presheaf.map_id]\n  change (F.obj j).presheaf.map _ â‰« _ = _\n  simp\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.colimitPresheafObjIsoComponentwiseLimit_hom_Ï€","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.HasColimits","initialProofState":"J : Type u'\ninstâœâ´ : CategoryTheory.Category.{v', u'} J\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasColimitsOfShape J TopCat\ninstâœÂ¹ : âˆ€ (X : TopCat), CategoryTheory.Limits.HasLimitsOfShape (Opposite J) (TopCat.Presheaf C X)\ninstâœ : CategoryTheory.Limits.HasLimitsOfShape (Opposite J) C\nF : CategoryTheory.Functor J (AlgebraicGeometry.PresheafedSpace C)\nU : TopologicalSpace.Opens â†‘â†‘(CategoryTheory.Limits.colimit F)\nj : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.PresheafedSpace.colimitPresheafObjIsoComponentwiseLimit F U).hom (CategoryTheory.Limits.limit.Ï€ (AlgebraicGeometry.PresheafedSpace.componentwiseDiagram F U) { unop := j })) ((CategoryTheory.Limits.colimit.Î¹ F j).c.app { unop := U })","decl":"@[simp]\ntheorem colimitPresheafObjIsoComponentwiseLimit_hom_Ï€ (F : J â¥¤ PresheafedSpace.{_, _, v} C)\n    (U : Opens (Limits.colimit F).carrier) (j : J) :\n    (colimitPresheafObjIsoComponentwiseLimit F U).hom â‰« limit.Ï€ _ (op j) =\n      (colimit.Î¹ F j).c.app (op U) := by\n  rw [â† Iso.eq_inv_comp, colimitPresheafObjIsoComponentwiseLimit_inv_Î¹_app]\n\n"}
