{"name":"AlgebraicGeometry.PresheafedSpace.map_id_c_app","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.HasColimits","initialProofState":"J : Type u'\ninst✝¹ : CategoryTheory.Category.{v', u'} J\nC : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J (AlgebraicGeometry.PresheafedSpace C)\nj : J\nU : Opposite (TopologicalSpace.Opens ↑↑(F.obj j))\n⊢ Eq ((F.map (CategoryTheory.CategoryStruct.id j)).c.app U) (CategoryTheory.CategoryStruct.comp ((TopCat.Presheaf.Pushforward.id (F.obj j).presheaf).inv.app U) ((TopCat.Presheaf.pushforwardEq ⋯ (F.obj j).presheaf).hom.app U))","decl":"@[simp]\ntheorem map_id_c_app (F : J ⥤ PresheafedSpace.{_, _, v} C) (j) (U) :\n    (F.map (𝟙 j)).c.app U =\n      (Pushforward.id (F.obj j).presheaf).inv.app U ≫\n        (pushforwardEq (by simp) (F.obj j).presheaf).hom.app U := by\n  simp [PresheafedSpace.congr_app (F.map_id j)]\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.map_comp_c_app","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.HasColimits","initialProofState":"J : Type u'\ninst✝¹ : CategoryTheory.Category.{v', u'} J\nC : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J (AlgebraicGeometry.PresheafedSpace C)\nj₁ j₂ j₃ : J\nf : Quiver.Hom j₁ j₂\ng : Quiver.Hom j₂ j₃\nU : Opposite (TopologicalSpace.Opens ↑↑(F.obj j₃))\n⊢ Eq ((F.map (CategoryTheory.CategoryStruct.comp f g)).c.app U) (CategoryTheory.CategoryStruct.comp ((F.map g).c.app U) (CategoryTheory.CategoryStruct.comp (((TopCat.Presheaf.pushforward C (F.map g).base).map (F.map f).c).app U) ((TopCat.Presheaf.pushforwardEq ⋯ (F.obj j₁).presheaf).hom.app U)))","decl":"@[simp]\ntheorem map_comp_c_app (F : J ⥤ PresheafedSpace.{_, _, v} C) {j₁ j₂ j₃}\n    (f : j₁ ⟶ j₂) (g : j₂ ⟶ j₃) (U) :\n    (F.map (f ≫ g)).c.app U =\n      (F.map g).c.app U ≫\n        ((pushforward C (F.map g).base).map (F.map f).c).app U ≫\n          (pushforwardEq (congr_arg Hom.base (F.map_comp f g).symm) _).hom.app U := by\n  simp [PresheafedSpace.congr_app (F.map_comp f g)]\n\n-- See note [dsimp, simp]\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.componentwiseDiagram_map","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.HasColimits","initialProofState":"J : Type u'\ninst✝² : CategoryTheory.Category.{v', u'} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J (AlgebraicGeometry.PresheafedSpace C)\ninst✝ : CategoryTheory.Limits.HasColimit F\nU : TopologicalSpace.Opens ↑↑(CategoryTheory.Limits.colimit F)\nj k : Opposite J\nf : Quiver.Hom j k\n⊢ Eq ((AlgebraicGeometry.PresheafedSpace.componentwiseDiagram F U).map f) (CategoryTheory.CategoryStruct.comp ((F.map f.unop).c.app { unop := (TopologicalSpace.Opens.map (CategoryTheory.Limits.colimit.ι F (Opposite.unop j)).base).obj U }) ((F.obj (Opposite.unop k)).presheaf.map (CategoryTheory.eqToHom ⋯)))","decl":"/-- Given a diagram of `PresheafedSpace C`s, its colimit is computed by pushing the sheaves onto\nthe colimit of the underlying spaces, and taking componentwise limit.\nThis is the componentwise diagram for an open set `U` of the colimit of the underlying spaces.\n-/\n@[simps]\ndef componentwiseDiagram (F : J ⥤ PresheafedSpace.{_, _, v} C) [HasColimit F]\n    (U : Opens (Limits.colimit F).carrier) : Jᵒᵖ ⥤ C where\n  obj j := (F.obj (unop j)).presheaf.obj (op ((Opens.map (colimit.ι F (unop j)).base).obj U))\n  map {j k} f := (F.map f.unop).c.app _ ≫\n    (F.obj (unop k)).presheaf.map (eqToHom (by rw [← colimit.w F f.unop, comp_base]; rfl))\n  map_comp {i j k} f g := by\n    dsimp\n    simp only [assoc, CategoryTheory.NatTrans.naturality_assoc]\n    simp\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.componentwiseDiagram_obj","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.HasColimits","initialProofState":"J : Type u'\ninst✝² : CategoryTheory.Category.{v', u'} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J (AlgebraicGeometry.PresheafedSpace C)\ninst✝ : CategoryTheory.Limits.HasColimit F\nU : TopologicalSpace.Opens ↑↑(CategoryTheory.Limits.colimit F)\nj : Opposite J\n⊢ Eq ((AlgebraicGeometry.PresheafedSpace.componentwiseDiagram F U).obj j) ((F.obj (Opposite.unop j)).presheaf.obj { unop := (TopologicalSpace.Opens.map (CategoryTheory.Limits.colimit.ι F (Opposite.unop j)).base).obj U })","decl":"/-- Given a diagram of `PresheafedSpace C`s, its colimit is computed by pushing the sheaves onto\nthe colimit of the underlying spaces, and taking componentwise limit.\nThis is the componentwise diagram for an open set `U` of the colimit of the underlying spaces.\n-/\n@[simps]\ndef componentwiseDiagram (F : J ⥤ PresheafedSpace.{_, _, v} C) [HasColimit F]\n    (U : Opens (Limits.colimit F).carrier) : Jᵒᵖ ⥤ C where\n  obj j := (F.obj (unop j)).presheaf.obj (op ((Opens.map (colimit.ι F (unop j)).base).obj U))\n  map {j k} f := (F.map f.unop).c.app _ ≫\n    (F.obj (unop k)).presheaf.map (eqToHom (by rw [← colimit.w F f.unop, comp_base]; rfl))\n  map_comp {i j k} f g := by\n    dsimp\n    simp only [assoc, CategoryTheory.NatTrans.naturality_assoc]\n    simp\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.pushforwardDiagramToColimit_map","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.HasColimits","initialProofState":"J : Type u'\ninst✝² : CategoryTheory.Category.{v', u'} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape J TopCat\nF : CategoryTheory.Functor J (AlgebraicGeometry.PresheafedSpace C)\nj j' : J\nf : Quiver.Hom j j'\n⊢ Eq ((AlgebraicGeometry.PresheafedSpace.pushforwardDiagramToColimit F).map f) (CategoryTheory.CategoryStruct.comp ((TopCat.Presheaf.pushforward C (CategoryTheory.Limits.colimit.ι (F.comp (AlgebraicGeometry.PresheafedSpace.forget C)) j')).map (F.map f).c) (CategoryTheory.CategoryStruct.comp (TopCat.Presheaf.Pushforward.comp ((F.comp (AlgebraicGeometry.PresheafedSpace.forget C)).map f) (CategoryTheory.Limits.colimit.ι (F.comp (AlgebraicGeometry.PresheafedSpace.forget C)) j') (F.obj j).presheaf).inv (TopCat.Presheaf.pushforwardEq ⋯ (F.obj j).presheaf).hom)).op","decl":"/-- Given a diagram of presheafed spaces,\nwe can push all the presheaves forward to the colimit `X` of the underlying topological spaces,\nobtaining a diagram in `(Presheaf C X)ᵒᵖ`.\n-/\n@[simps]\ndef pushforwardDiagramToColimit (F : J ⥤ PresheafedSpace.{_, _, v} C) :\n    J ⥤ (Presheaf C (colimit (F ⋙ PresheafedSpace.forget C)))ᵒᵖ where\n  obj j := op (colimit.ι (F ⋙ PresheafedSpace.forget C) j _* (F.obj j).presheaf)\n  map {j j'} f :=\n    ((pushforward C (colimit.ι (F ⋙ PresheafedSpace.forget C) j')).map (F.map f).c ≫\n      (Pushforward.comp ((F ⋙ PresheafedSpace.forget C).map f)\n        (colimit.ι (F ⋙ PresheafedSpace.forget C) j') (F.obj j).presheaf).inv ≫\n      (pushforwardEq (colimit.w (F ⋙ PresheafedSpace.forget C) f) (F.obj j).presheaf).hom).op\n  map_id j := by\n    apply (opEquiv _ _).injective\n    refine NatTrans.ext (funext fun U => ?_)\n    induction U with\n    | h U =>\n      simp [opEquiv]\n      rfl\n  map_comp {j₁ j₂ j₃} f g := by\n    apply (opEquiv _ _).injective\n    refine NatTrans.ext (funext fun U => ?_)\n    dsimp [opEquiv]\n    have :\n      op ((Opens.map (F.map g).base).obj\n          ((Opens.map (colimit.ι (F ⋙ forget C) j₃)).obj U.unop)) =\n        op ((Opens.map (colimit.ι (F ⋙ PresheafedSpace.forget C) j₂)).obj (unop U)) := by\n      apply unop_injective\n      rw [← Opens.map_comp_obj]\n      congr\n      exact colimit.w (F ⋙ PresheafedSpace.forget C) g\n    simp only [map_comp_c_app, pushforward_obj_obj, pushforward_map_app, comp_base,\n      pushforwardEq_hom_app, op_obj, Opens.map_comp_obj, id_comp, assoc, eqToHom_map_comp,\n      NatTrans.naturality_assoc, pushforward_obj_map, eqToHom_unop]\n    simp [NatTrans.congr (α := (F.map f).c) this]\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.pushforwardDiagramToColimit_obj","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.HasColimits","initialProofState":"J : Type u'\ninst✝² : CategoryTheory.Category.{v', u'} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape J TopCat\nF : CategoryTheory.Functor J (AlgebraicGeometry.PresheafedSpace C)\nj : J\n⊢ Eq ((AlgebraicGeometry.PresheafedSpace.pushforwardDiagramToColimit F).obj j) { unop := (TopCat.Presheaf.pushforward C (CategoryTheory.Limits.colimit.ι (F.comp (AlgebraicGeometry.PresheafedSpace.forget C)) j)).obj (F.obj j).presheaf }","decl":"/-- Given a diagram of presheafed spaces,\nwe can push all the presheaves forward to the colimit `X` of the underlying topological spaces,\nobtaining a diagram in `(Presheaf C X)ᵒᵖ`.\n-/\n@[simps]\ndef pushforwardDiagramToColimit (F : J ⥤ PresheafedSpace.{_, _, v} C) :\n    J ⥤ (Presheaf C (colimit (F ⋙ PresheafedSpace.forget C)))ᵒᵖ where\n  obj j := op (colimit.ι (F ⋙ PresheafedSpace.forget C) j _* (F.obj j).presheaf)\n  map {j j'} f :=\n    ((pushforward C (colimit.ι (F ⋙ PresheafedSpace.forget C) j')).map (F.map f).c ≫\n      (Pushforward.comp ((F ⋙ PresheafedSpace.forget C).map f)\n        (colimit.ι (F ⋙ PresheafedSpace.forget C) j') (F.obj j).presheaf).inv ≫\n      (pushforwardEq (colimit.w (F ⋙ PresheafedSpace.forget C) f) (F.obj j).presheaf).hom).op\n  map_id j := by\n    apply (opEquiv _ _).injective\n    refine NatTrans.ext (funext fun U => ?_)\n    induction U with\n    | h U =>\n      simp [opEquiv]\n      rfl\n  map_comp {j₁ j₂ j₃} f g := by\n    apply (opEquiv _ _).injective\n    refine NatTrans.ext (funext fun U => ?_)\n    dsimp [opEquiv]\n    have :\n      op ((Opens.map (F.map g).base).obj\n          ((Opens.map (colimit.ι (F ⋙ forget C) j₃)).obj U.unop)) =\n        op ((Opens.map (colimit.ι (F ⋙ PresheafedSpace.forget C) j₂)).obj (unop U)) := by\n      apply unop_injective\n      rw [← Opens.map_comp_obj]\n      congr\n      exact colimit.w (F ⋙ PresheafedSpace.forget C) g\n    simp only [map_comp_c_app, pushforward_obj_obj, pushforward_map_app, comp_base,\n      pushforwardEq_hom_app, op_obj, Opens.map_comp_obj, id_comp, assoc, eqToHom_map_comp,\n      NatTrans.naturality_assoc, pushforward_obj_map, eqToHom_unop]\n    simp [NatTrans.congr (α := (F.map f).c) this]\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.colimit_carrier","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.HasColimits","initialProofState":"J : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} J\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasColimitsOfShape J TopCat\ninst✝ : ∀ (X : TopCat), CategoryTheory.Limits.HasLimitsOfShape (Opposite J) (TopCat.Presheaf C X)\nF : CategoryTheory.Functor J (AlgebraicGeometry.PresheafedSpace C)\n⊢ Eq (↑(AlgebraicGeometry.PresheafedSpace.colimit F)) (CategoryTheory.Limits.colimit (F.comp (AlgebraicGeometry.PresheafedSpace.forget C)))","decl":"@[simp]\ntheorem colimit_carrier (F : J ⥤ PresheafedSpace.{_, _, v} C) :\n    (colimit F).carrier = Limits.colimit (F ⋙ PresheafedSpace.forget C) :=\n  rfl\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.colimit_presheaf","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.HasColimits","initialProofState":"J : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} J\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasColimitsOfShape J TopCat\ninst✝ : ∀ (X : TopCat), CategoryTheory.Limits.HasLimitsOfShape (Opposite J) (TopCat.Presheaf C X)\nF : CategoryTheory.Functor J (AlgebraicGeometry.PresheafedSpace C)\n⊢ Eq (AlgebraicGeometry.PresheafedSpace.colimit F).presheaf (CategoryTheory.Limits.limit (AlgebraicGeometry.PresheafedSpace.pushforwardDiagramToColimit F).leftOp)","decl":"@[simp]\ntheorem colimit_presheaf (F : J ⥤ PresheafedSpace.{_, _, v} C) :\n    (colimit F).presheaf = limit (pushforwardDiagramToColimit F).leftOp :=\n  rfl\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.colimitCocone_ι_app_base","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.HasColimits","initialProofState":"J : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} J\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasColimitsOfShape J TopCat\ninst✝ : ∀ (X : TopCat), CategoryTheory.Limits.HasLimitsOfShape (Opposite J) (TopCat.Presheaf C X)\nF : CategoryTheory.Functor J (AlgebraicGeometry.PresheafedSpace C)\nj : J\n⊢ Eq ((AlgebraicGeometry.PresheafedSpace.colimitCocone F).ι.app j).base (CategoryTheory.Limits.colimit.ι (F.comp (AlgebraicGeometry.PresheafedSpace.forget C)) j)","decl":"/-- Auxiliary definition for `AlgebraicGeometry.PresheafedSpace.instHasColimits`.\n-/\n@[simps]\ndef colimitCocone (F : J ⥤ PresheafedSpace.{_, _, v} C) : Cocone F where\n  pt := colimit F\n  ι :=\n    { app := fun j =>\n        { base := colimit.ι (F ⋙ PresheafedSpace.forget C) j\n          c := limit.π _ (op j) }\n      naturality := fun {j j'} f => by\n        ext1\n        · ext x\n          exact colimit.w_apply (F ⋙ PresheafedSpace.forget C) f x\n        · ext ⟨U, hU⟩\n          dsimp [-Presheaf.comp_app]\n          rw [PresheafedSpace.id_c_app, map_id]\n          erw [id_comp]\n          rw [NatTrans.comp_app, PresheafedSpace.comp_c_app, whiskerRight_app, eqToHom_app,\n            ← congr_arg NatTrans.app (limit.w (pushforwardDiagramToColimit F).leftOp f.op),\n            NatTrans.comp_app, Functor.leftOp_map, pushforwardDiagramToColimit_map]\n          simp }\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.colimitCocone_ι_app_c","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.HasColimits","initialProofState":"J : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} J\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasColimitsOfShape J TopCat\ninst✝ : ∀ (X : TopCat), CategoryTheory.Limits.HasLimitsOfShape (Opposite J) (TopCat.Presheaf C X)\nF : CategoryTheory.Functor J (AlgebraicGeometry.PresheafedSpace C)\nj : J\n⊢ Eq ((AlgebraicGeometry.PresheafedSpace.colimitCocone F).ι.app j).c (CategoryTheory.Limits.limit.π (AlgebraicGeometry.PresheafedSpace.pushforwardDiagramToColimit F).leftOp { unop := j })","decl":"/-- Auxiliary definition for `AlgebraicGeometry.PresheafedSpace.instHasColimits`.\n-/\n@[simps]\ndef colimitCocone (F : J ⥤ PresheafedSpace.{_, _, v} C) : Cocone F where\n  pt := colimit F\n  ι :=\n    { app := fun j =>\n        { base := colimit.ι (F ⋙ PresheafedSpace.forget C) j\n          c := limit.π _ (op j) }\n      naturality := fun {j j'} f => by\n        ext1\n        · ext x\n          exact colimit.w_apply (F ⋙ PresheafedSpace.forget C) f x\n        · ext ⟨U, hU⟩\n          dsimp [-Presheaf.comp_app]\n          rw [PresheafedSpace.id_c_app, map_id]\n          erw [id_comp]\n          rw [NatTrans.comp_app, PresheafedSpace.comp_c_app, whiskerRight_app, eqToHom_app,\n            ← congr_arg NatTrans.app (limit.w (pushforwardDiagramToColimit F).leftOp f.op),\n            NatTrans.comp_app, Functor.leftOp_map, pushforwardDiagramToColimit_map]\n          simp }\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.colimitCocone_pt","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.HasColimits","initialProofState":"J : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} J\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasColimitsOfShape J TopCat\ninst✝ : ∀ (X : TopCat), CategoryTheory.Limits.HasLimitsOfShape (Opposite J) (TopCat.Presheaf C X)\nF : CategoryTheory.Functor J (AlgebraicGeometry.PresheafedSpace C)\n⊢ Eq (AlgebraicGeometry.PresheafedSpace.colimitCocone F).pt (AlgebraicGeometry.PresheafedSpace.colimit F)","decl":"/-- Auxiliary definition for `AlgebraicGeometry.PresheafedSpace.instHasColimits`.\n-/\n@[simps]\ndef colimitCocone (F : J ⥤ PresheafedSpace.{_, _, v} C) : Cocone F where\n  pt := colimit F\n  ι :=\n    { app := fun j =>\n        { base := colimit.ι (F ⋙ PresheafedSpace.forget C) j\n          c := limit.π _ (op j) }\n      naturality := fun {j j'} f => by\n        ext1\n        · ext x\n          exact colimit.w_apply (F ⋙ PresheafedSpace.forget C) f x\n        · ext ⟨U, hU⟩\n          dsimp [-Presheaf.comp_app]\n          rw [PresheafedSpace.id_c_app, map_id]\n          erw [id_comp]\n          rw [NatTrans.comp_app, PresheafedSpace.comp_c_app, whiskerRight_app, eqToHom_app,\n            ← congr_arg NatTrans.app (limit.w (pushforwardDiagramToColimit F).leftOp f.op),\n            NatTrans.comp_app, Functor.leftOp_map, pushforwardDiagramToColimit_map]\n          simp }\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.ColimitCoconeIsColimit.desc_c_naturality","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.HasColimits","initialProofState":"J : Type u'\ninst✝⁴ : CategoryTheory.Category.{v', u'} J\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasColimitsOfShape J TopCat\ninst✝¹ : ∀ (X : TopCat), CategoryTheory.Limits.HasLimitsOfShape (Opposite J) (TopCat.Presheaf C X)\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape (Opposite J) C\nF : CategoryTheory.Functor J (AlgebraicGeometry.PresheafedSpace C)\ns : CategoryTheory.Limits.Cocone F\nU V : Opposite (TopologicalSpace.Opens ↑↑s.pt)\ni : Quiver.Hom U V\n⊢ Eq (CategoryTheory.CategoryStruct.comp (s.pt.presheaf.map i) (AlgebraicGeometry.PresheafedSpace.ColimitCoconeIsColimit.descCApp F s V)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.PresheafedSpace.ColimitCoconeIsColimit.descCApp F s U) (((TopCat.Presheaf.pushforward C (CategoryTheory.Limits.colimit.desc (F.comp (AlgebraicGeometry.PresheafedSpace.forget C)) ((AlgebraicGeometry.PresheafedSpace.forget C).mapCocone s))).obj (AlgebraicGeometry.PresheafedSpace.colimitCocone F).pt.presheaf).map i))","decl":"theorem desc_c_naturality (F : J ⥤ PresheafedSpace.{_, _, v} C) (s : Cocone F)\n    {U V : (Opens s.pt.carrier)ᵒᵖ} (i : U ⟶ V) :\n    s.pt.presheaf.map i ≫ descCApp F s V =\n      descCApp F s U ≫\n        (colimit.desc (F ⋙ forget C) ((forget C).mapCocone s) _* (colimitCocone F).pt.presheaf).map\n          i := by\n  dsimp [descCApp]\n  refine limit_obj_ext (fun j => ?_)\n  have w := Functor.congr_hom (congr_arg Opens.map\n    (colimit.ι_desc ((PresheafedSpace.forget C).mapCocone s) (unop j))) i.unop\n  simp only [Opens.map_comp_map] at w\n  simp [congr_arg Quiver.Hom.op w]\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.ColimitCoconeIsColimit.desc_fac","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.HasColimits","initialProofState":"J : Type u'\ninst✝⁴ : CategoryTheory.Category.{v', u'} J\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasColimitsOfShape J TopCat\ninst✝¹ : ∀ (X : TopCat), CategoryTheory.Limits.HasLimitsOfShape (Opposite J) (TopCat.Presheaf C X)\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape (Opposite J) C\nF : CategoryTheory.Functor J (AlgebraicGeometry.PresheafedSpace C)\ns : CategoryTheory.Limits.Cocone F\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((AlgebraicGeometry.PresheafedSpace.colimitCocone F).ι.app j) (AlgebraicGeometry.PresheafedSpace.ColimitCoconeIsColimit.desc F s)) (s.ι.app j)","decl":"theorem desc_fac (F : J ⥤ PresheafedSpace.{_, _, v} C) (s : Cocone F) (j : J) :\n    (colimitCocone F).ι.app j ≫ desc F s = s.ι.app j := by\n  ext U\n  · simp [desc]\n  · -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): the original proof is just `ext; dsimp [desc, descCApp]; simpa`,\n    -- but this has to be expanded a bit\n    rw [NatTrans.comp_app, PresheafedSpace.comp_c_app, whiskerRight_app]\n    dsimp [desc, descCApp]\n    simp only [eqToHom_app, op_obj, Opens.map_comp_obj, eqToHom_map, Functor.leftOp, assoc]\n    rw [limitObjIsoLimitCompEvaluation_inv_π_app_assoc]\n    simp\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.instHasColimitsOfShape","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.HasColimits","initialProofState":"J : Type u'\ninst✝⁴ : CategoryTheory.Category.{v', u'} J\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasColimitsOfShape J TopCat\ninst✝¹ : ∀ (X : TopCat), CategoryTheory.Limits.HasLimitsOfShape (Opposite J) (TopCat.Presheaf C X)\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape (Opposite J) C\n⊢ CategoryTheory.Limits.HasColimitsOfShape J (AlgebraicGeometry.PresheafedSpace C)","decl":"instance : HasColimitsOfShape J (PresheafedSpace.{_, _, v} C) where\n  has_colimit F := ⟨colimitCocone F, colimitCoconeIsColimit F⟩\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.instPreservesColimitsOfShapeTopCatForget","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.HasColimits","initialProofState":"J : Type u'\ninst✝⁴ : CategoryTheory.Category.{v', u'} J\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasColimitsOfShape J TopCat\ninst✝¹ : ∀ (X : TopCat), CategoryTheory.Limits.HasLimitsOfShape (Opposite J) (TopCat.Presheaf C X)\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape (Opposite J) C\n⊢ CategoryTheory.Limits.PreservesColimitsOfShape J (AlgebraicGeometry.PresheafedSpace.forget C)","decl":"instance : PreservesColimitsOfShape J (PresheafedSpace.forget.{u, v, v} C) :=\n  ⟨fun {F} => preservesColimit_of_preserves_colimit_cocone (colimitCoconeIsColimit F) <| by\n    apply IsColimit.ofIsoColimit (colimit.isColimit _)\n    fapply Cocones.ext\n    · rfl\n    · intro j\n      simp⟩\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.instHasColimits","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.HasColimits","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasLimits C\n⊢ CategoryTheory.Limits.HasColimits (AlgebraicGeometry.PresheafedSpace C)","decl":"/-- When `C` has limits, the category of presheaved spaces with values in `C` itself has colimits.\n-/\ninstance instHasColimits [HasLimits C] : HasColimits (PresheafedSpace.{_, _, v} C) :=\n  ⟨fun {_ _} => ⟨fun {F} => ⟨colimitCocone F, colimitCoconeIsColimit F⟩⟩⟩\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.forget_preservesColimits","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.HasColimits","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasLimits C\n⊢ CategoryTheory.Limits.PreservesColimits (AlgebraicGeometry.PresheafedSpace.forget C)","decl":"/-- The underlying topological space of a colimit of presheaved spaces is\nthe colimit of the underlying topological spaces.\n-/\ninstance forget_preservesColimits [HasLimits C] :\n    PreservesColimits (PresheafedSpace.forget.{_, _, v} C) where\n  preservesColimitsOfShape {J 𝒥} :=\n    { preservesColimit := fun {F} => preservesColimit_of_preserves_colimit_cocone\n          (colimitCoconeIsColimit F)\n          (IsColimit.ofIsoColimit (colimit.isColimit _) (Cocones.ext (Iso.refl _))) }\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.colimitPresheafObjIsoComponentwiseLimit_inv_ι_app","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.HasColimits","initialProofState":"J : Type u'\ninst✝⁴ : CategoryTheory.Category.{v', u'} J\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasColimitsOfShape J TopCat\ninst✝¹ : ∀ (X : TopCat), CategoryTheory.Limits.HasLimitsOfShape (Opposite J) (TopCat.Presheaf C X)\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape (Opposite J) C\nF : CategoryTheory.Functor J (AlgebraicGeometry.PresheafedSpace C)\nU : TopologicalSpace.Opens ↑↑(CategoryTheory.Limits.colimit F)\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.PresheafedSpace.colimitPresheafObjIsoComponentwiseLimit F U).inv ((CategoryTheory.Limits.colimit.ι F j).c.app { unop := U })) (CategoryTheory.Limits.limit.π (AlgebraicGeometry.PresheafedSpace.componentwiseDiagram F U) { unop := j })","decl":"@[simp]\ntheorem colimitPresheafObjIsoComponentwiseLimit_inv_ι_app (F : J ⥤ PresheafedSpace.{_, _, v} C)\n    (U : Opens (Limits.colimit F).carrier) (j : J) :\n    (colimitPresheafObjIsoComponentwiseLimit F U).inv ≫ (colimit.ι F j).c.app (op U) =\n      limit.π _ (op j) := by\n  delta colimitPresheafObjIsoComponentwiseLimit\n  rw [Iso.trans_inv, Iso.trans_inv, Iso.app_inv, sheafIsoOfIso_inv, pushforwardToOfIso_app,\n    congr_app (Iso.symm_inv _)]\n  dsimp\n  rw [map_id, comp_id, assoc, assoc, assoc, NatTrans.naturality,\n      ← comp_c_app_assoc,\n      congr_app (colimit.isoColimitCocone_ι_hom _ _), assoc]\n  erw [limitObjIsoLimitCompEvaluation_inv_π_app_assoc, limMap_π_assoc]\n  -- Porting note: `convert` doesn't work due to meta variable, so change to a `suffices` block\n  set f := _\n  change _ ≫ f = _\n  suffices f_eq : f = 𝟙 _ by rw [f_eq, comp_id]\n  erw [← (F.obj j).presheaf.map_id]\n  change (F.obj j).presheaf.map _ ≫ _ = _\n  simp\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.colimitPresheafObjIsoComponentwiseLimit_hom_π","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.HasColimits","initialProofState":"J : Type u'\ninst✝⁴ : CategoryTheory.Category.{v', u'} J\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasColimitsOfShape J TopCat\ninst✝¹ : ∀ (X : TopCat), CategoryTheory.Limits.HasLimitsOfShape (Opposite J) (TopCat.Presheaf C X)\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape (Opposite J) C\nF : CategoryTheory.Functor J (AlgebraicGeometry.PresheafedSpace C)\nU : TopologicalSpace.Opens ↑↑(CategoryTheory.Limits.colimit F)\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.PresheafedSpace.colimitPresheafObjIsoComponentwiseLimit F U).hom (CategoryTheory.Limits.limit.π (AlgebraicGeometry.PresheafedSpace.componentwiseDiagram F U) { unop := j })) ((CategoryTheory.Limits.colimit.ι F j).c.app { unop := U })","decl":"@[simp]\ntheorem colimitPresheafObjIsoComponentwiseLimit_hom_π (F : J ⥤ PresheafedSpace.{_, _, v} C)\n    (U : Opens (Limits.colimit F).carrier) (j : J) :\n    (colimitPresheafObjIsoComponentwiseLimit F U).hom ≫ limit.π _ (op j) =\n      (colimit.ι F j).c.app (op U) := by\n  rw [← Iso.eq_inv_comp, colimitPresheafObjIsoComponentwiseLimit_inv_ι_app]\n\n"}
