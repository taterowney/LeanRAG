{"name":"Int.cast_mono","module":"Mathlib.Algebra.Order.Ring.Cast","initialProofState":"R : Type u_1\ninst✝³ : AddCommGroupWithOne R\ninst✝² : PartialOrder R\ninst✝¹ : AddLeftMono R\ninst✝ : ZeroLEOneClass R\n⊢ Monotone Int.cast","decl":"lemma cast_mono : Monotone (Int.cast : ℤ → R) := by\n  intro m n h\n  rw [← sub_nonneg] at h\n  lift n - m to ℕ using h with k hk\n  rw [← sub_nonneg, ← cast_sub, ← hk, cast_natCast]\n  exact k.cast_nonneg'\n\n"}
{"name":"Int.GCongr.intCast_mono","module":"Mathlib.Algebra.Order.Ring.Cast","initialProofState":"R : Type u_1\ninst✝³ : AddCommGroupWithOne R\ninst✝² : PartialOrder R\ninst✝¹ : AddLeftMono R\ninst✝ : ZeroLEOneClass R\nm n : Int\nhmn : LE.le m n\n⊢ LE.le ↑m ↑n","decl":"@[gcongr] protected lemma GCongr.intCast_mono {m n : ℤ} (hmn : m ≤ n) : (m : R) ≤ n := cast_mono hmn\n\n"}
{"name":"Int.cast_nonneg","module":"Mathlib.Algebra.Order.Ring.Cast","initialProofState":"R : Type u_1\ninst✝⁴ : AddCommGroupWithOne R\ninst✝³ : PartialOrder R\ninst✝² : AddLeftMono R\ninst✝¹ : ZeroLEOneClass R\ninst✝ : NeZero 1\nn : Int\n⊢ Iff (LE.le 0 ↑n) (LE.le 0 n)","decl":"@[simp] lemma cast_nonneg : ∀ {n : ℤ}, (0 : R) ≤ n ↔ 0 ≤ n\n  | (n : ℕ) => by simp\n  | -[n+1] => by\n    have : -(n : R) < 1 := lt_of_le_of_lt (by simp) zero_lt_one\n    simpa [(negSucc_lt_zero n).not_le, ← sub_eq_add_neg, le_neg] using this.not_le\n\n"}
{"name":"Int.cast_le","module":"Mathlib.Algebra.Order.Ring.Cast","initialProofState":"R : Type u_1\ninst✝⁴ : AddCommGroupWithOne R\ninst✝³ : PartialOrder R\ninst✝² : AddLeftMono R\ninst✝¹ : ZeroLEOneClass R\ninst✝ : NeZero 1\nm n : Int\n⊢ Iff (LE.le ↑m ↑n) (LE.le m n)","decl":"@[simp, norm_cast] lemma cast_le : (m : R) ≤ n ↔ m ≤ n := by\n  rw [← sub_nonneg, ← cast_sub, cast_nonneg, sub_nonneg]\n\n"}
{"name":"Int.cast_strictMono","module":"Mathlib.Algebra.Order.Ring.Cast","initialProofState":"R : Type u_1\ninst✝⁴ : AddCommGroupWithOne R\ninst✝³ : PartialOrder R\ninst✝² : AddLeftMono R\ninst✝¹ : ZeroLEOneClass R\ninst✝ : NeZero 1\n⊢ StrictMono fun x => ↑x","decl":"lemma cast_strictMono : StrictMono (fun x : ℤ => (x : R)) :=\n  strictMono_of_le_iff_le fun _ _ => cast_le.symm\n\n"}
{"name":"Int.cast_lt","module":"Mathlib.Algebra.Order.Ring.Cast","initialProofState":"R : Type u_1\ninst✝⁴ : AddCommGroupWithOne R\ninst✝³ : PartialOrder R\ninst✝² : AddLeftMono R\ninst✝¹ : ZeroLEOneClass R\ninst✝ : NeZero 1\nm n : Int\n⊢ Iff (LT.lt ↑m ↑n) (LT.lt m n)","decl":"@[simp, norm_cast] lemma cast_lt : (m : R) < n ↔ m < n := cast_strictMono.lt_iff_lt\n\n"}
{"name":"Int.GCongr.intCast_strictMono","module":"Mathlib.Algebra.Order.Ring.Cast","initialProofState":"R : Type u_1\ninst✝⁴ : AddCommGroupWithOne R\ninst✝³ : PartialOrder R\ninst✝² : AddLeftMono R\ninst✝¹ : ZeroLEOneClass R\ninst✝ : NeZero 1\nm n : Int\na✝ : LT.lt m n\n⊢ LT.lt ↑m ↑n","decl":"@[gcongr] protected alias ⟨_, GCongr.intCast_strictMono⟩ := Int.cast_lt\n\n"}
{"name":"Int.cast_nonpos","module":"Mathlib.Algebra.Order.Ring.Cast","initialProofState":"R : Type u_1\ninst✝⁴ : AddCommGroupWithOne R\ninst✝³ : PartialOrder R\ninst✝² : AddLeftMono R\ninst✝¹ : ZeroLEOneClass R\ninst✝ : NeZero 1\nn : Int\n⊢ Iff (LE.le (↑n) 0) (LE.le n 0)","decl":"@[simp] lemma cast_nonpos : (n : R) ≤ 0 ↔ n ≤ 0 := by rw [← cast_zero, cast_le]\n\n"}
{"name":"Int.cast_pos","module":"Mathlib.Algebra.Order.Ring.Cast","initialProofState":"R : Type u_1\ninst✝⁴ : AddCommGroupWithOne R\ninst✝³ : PartialOrder R\ninst✝² : AddLeftMono R\ninst✝¹ : ZeroLEOneClass R\ninst✝ : NeZero 1\nn : Int\n⊢ Iff (LT.lt 0 ↑n) (LT.lt 0 n)","decl":"@[simp] lemma cast_pos : (0 : R) < n ↔ 0 < n := by rw [← cast_zero, cast_lt]\n\n"}
{"name":"Int.cast_lt_zero","module":"Mathlib.Algebra.Order.Ring.Cast","initialProofState":"R : Type u_1\ninst✝⁴ : AddCommGroupWithOne R\ninst✝³ : PartialOrder R\ninst✝² : AddLeftMono R\ninst✝¹ : ZeroLEOneClass R\ninst✝ : NeZero 1\nn : Int\n⊢ Iff (LT.lt (↑n) 0) (LT.lt n 0)","decl":"@[simp] lemma cast_lt_zero : (n : R) < 0 ↔ n < 0 := by rw [← cast_zero, cast_lt]\n\n"}
{"name":"Int.cast_min","module":"Mathlib.Algebra.Order.Ring.Cast","initialProofState":"R : Type u_1\ninst✝ : LinearOrderedRing R\na b : Int\n⊢ Eq (↑(Min.min a b)) (Min.min ↑a ↑b)","decl":"@[simp, norm_cast]\nlemma cast_min : ↑(min a b) = (min a b : R) := Monotone.map_min cast_mono\n\n"}
{"name":"Int.cast_max","module":"Mathlib.Algebra.Order.Ring.Cast","initialProofState":"R : Type u_1\ninst✝ : LinearOrderedRing R\na b : Int\n⊢ Eq (↑(Max.max a b)) (Max.max ↑a ↑b)","decl":"@[simp, norm_cast]\nlemma cast_max : (↑(max a b) : R) = max (a : R) (b : R) := Monotone.map_max cast_mono\n\n"}
{"name":"Int.cast_abs","module":"Mathlib.Algebra.Order.Ring.Cast","initialProofState":"R : Type u_1\ninst✝ : LinearOrderedRing R\na : Int\n⊢ Eq (↑(abs a)) (abs ↑a)","decl":"@[simp, norm_cast]\nlemma cast_abs : (↑|a| : R) = |(a : R)| := by simp [abs_eq_max_neg]\n\n"}
{"name":"Int.cast_one_le_of_pos","module":"Mathlib.Algebra.Order.Ring.Cast","initialProofState":"R : Type u_1\ninst✝ : LinearOrderedRing R\na : Int\nh : LT.lt 0 a\n⊢ LE.le 1 ↑a","decl":"lemma cast_one_le_of_pos (h : 0 < a) : (1 : R) ≤ a := mod_cast Int.add_one_le_of_lt h\n\n"}
{"name":"Int.cast_le_neg_one_of_neg","module":"Mathlib.Algebra.Order.Ring.Cast","initialProofState":"R : Type u_1\ninst✝ : LinearOrderedRing R\na : Int\nh : LT.lt a 0\n⊢ LE.le (↑a) (-1)","decl":"lemma cast_le_neg_one_of_neg (h : a < 0) : (a : R) ≤ -1 := by\n  rw [← Int.cast_one, ← Int.cast_neg, cast_le]\n  exact Int.le_sub_one_of_lt h\n\n"}
{"name":"Int.cast_le_neg_one_or_one_le_cast_of_ne_zero","module":"Mathlib.Algebra.Order.Ring.Cast","initialProofState":"R : Type u_1\ninst✝ : LinearOrderedRing R\nn : Int\nhn : Ne n 0\n⊢ Or (LE.le (↑n) (-1)) (LE.le 1 ↑n)","decl":"variable (R) in\nlemma cast_le_neg_one_or_one_le_cast_of_ne_zero (hn : n ≠ 0) : (n : R) ≤ -1 ∨ 1 ≤ (n : R) :=\n  hn.lt_or_lt.imp cast_le_neg_one_of_neg cast_one_le_of_pos\n\n"}
{"name":"Int.nneg_mul_add_sq_of_abs_le_one","module":"Mathlib.Algebra.Order.Ring.Cast","initialProofState":"R : Type u_1\ninst✝ : LinearOrderedRing R\nx : R\nn : Int\nhx : LE.le (abs x) 1\n⊢ LE.le 0 (HAdd.hAdd (HMul.hMul (↑n) x) (HMul.hMul ↑n ↑n))","decl":"lemma nneg_mul_add_sq_of_abs_le_one (n : ℤ) (hx : |x| ≤ 1) : (0 : R) ≤ n * x + n * n := by\n  have hnx : 0 < n → 0 ≤ x + n := fun hn => by\n    have := _root_.add_le_add (neg_le_of_abs_le hx) (cast_one_le_of_pos hn)\n    rwa [neg_add_cancel] at this\n  have hnx' : n < 0 → x + n ≤ 0 := fun hn => by\n    have := _root_.add_le_add (le_of_abs_le hx) (cast_le_neg_one_of_neg hn)\n    rwa [add_neg_cancel] at this\n  rw [← mul_add, mul_nonneg_iff]\n  rcases lt_trichotomy n 0 with (h | rfl | h)\n  · exact Or.inr ⟨mod_cast h.le, hnx' h⟩\n  · simp [le_total 0 x]\n  · exact Or.inl ⟨mod_cast h.le, hnx h⟩\n\n"}
{"name":"Int.cast_natAbs","module":"Mathlib.Algebra.Order.Ring.Cast","initialProofState":"R : Type u_1\ninst✝ : LinearOrderedRing R\nn : Int\n⊢ Eq ↑n.natAbs ↑(abs n)","decl":"lemma cast_natAbs : (n.natAbs : R) = |n| := by\n  cases n\n  · simp\n  · rw [abs_eq_natAbs, natAbs_negSucc, cast_succ, cast_natCast, cast_succ]\n\n"}
{"name":"toDual_intCast","module":"Mathlib.Algebra.Order.Ring.Cast","initialProofState":"R : Type u_1\ninst✝ : IntCast R\nn : Int\n⊢ Eq (OrderDual.toDual ↑n) ↑n","decl":"@[simp] lemma toDual_intCast [IntCast R] (n : ℤ) : toDual (n : R) = n := rfl\n\n"}
{"name":"ofDual_intCast","module":"Mathlib.Algebra.Order.Ring.Cast","initialProofState":"R : Type u_1\ninst✝ : IntCast R\nn : Int\n⊢ Eq (OrderDual.ofDual ↑n) ↑n","decl":"@[simp] lemma ofDual_intCast [IntCast R] (n : ℤ) : (ofDual n : R) = n := rfl\n\n"}
{"name":"toLex_intCast","module":"Mathlib.Algebra.Order.Ring.Cast","initialProofState":"R : Type u_1\ninst✝ : IntCast R\nn : Int\n⊢ Eq (toLex ↑n) ↑n","decl":"@[simp] lemma toLex_intCast [IntCast R] (n : ℤ) : toLex (n : R) = n := rfl\n\n"}
{"name":"ofLex_intCast","module":"Mathlib.Algebra.Order.Ring.Cast","initialProofState":"R : Type u_1\ninst✝ : IntCast R\nn : Int\n⊢ Eq (ofLex ↑n) ↑n","decl":"@[simp] lemma ofLex_intCast [IntCast R] (n : ℤ) : (ofLex n : R) = n := rfl\n"}
