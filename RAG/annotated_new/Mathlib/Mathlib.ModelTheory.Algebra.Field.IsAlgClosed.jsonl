{"name":"FirstOrder.Field.lift_genericMonicPoly","module":"Mathlib.ModelTheory.Algebra.Field.IsAlgClosed","initialProofState":"K : Type u_1\ninst✝¹ : CommRing K\ninst✝ : Nontrivial K\nn : Nat\nv : Fin (HAdd.hAdd n 1) → K\n⊢ Eq ((FreeCommRing.lift v) (FirstOrder.Field.genericMonicPoly n)) (Polynomial.eval (v (Fin.last n)) ↑(((Polynomial.monicEquivDegreeLT n).trans (Polynomial.degreeLTEquiv K n).toEquiv).symm (Function.comp v Fin.castSucc)))","decl":"theorem lift_genericMonicPoly [CommRing K] [Nontrivial K] {n : ℕ} (v : Fin (n+1) → K) :\n    FreeCommRing.lift v (genericMonicPoly n) =\n    (((monicEquivDegreeLT n).trans (degreeLTEquiv K n).toEquiv).symm (v ∘ Fin.castSucc)).1.eval\n      (v (Fin.last _)) := by\n  simp only [genericMonicPoly, map_add, map_pow, lift_of, map_sum, map_mul, monicEquivDegreeLT,\n    degreeLTEquiv, Equiv.symm_trans_apply, LinearEquiv.coe_toEquiv_symm, EquivLike.coe_coe,\n    LinearEquiv.coe_symm_mk, Function.comp_apply, Equiv.coe_fn_symm_mk, eval_add, eval_pow, eval_X,\n    eval_finset_sum, eval_monomial]\n\n"}
{"name":"FirstOrder.Field.realize_genericMonicPolyHasRoot","module":"Mathlib.ModelTheory.Algebra.Field.IsAlgClosed","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : FirstOrder.Ring.CompatibleRing K\nn : Nat\n⊢ Iff (FirstOrder.Language.Sentence.Realize K (FirstOrder.Field.genericMonicPolyHasRoot n)) (∀ (p : Subtype fun p => And p.Monic (Eq p.natDegree n)), Exists fun x => Eq (Polynomial.eval x ↑p) 0)","decl":"theorem realize_genericMonicPolyHasRoot [Field K] [CompatibleRing K] (n : ℕ) :\n    K ⊨ genericMonicPolyHasRoot n ↔\n      ∀ p : { p : K[X] // p.Monic ∧ p.natDegree = n }, ∃ x, p.1.eval x = 0 := by\n  let _ := Classical.decEq K\n  rw [Equiv.forall_congr_left ((monicEquivDegreeLT n).trans (degreeLTEquiv K n).toEquiv)]\n  simp [Sentence.Realize, genericMonicPolyHasRoot, lift_genericMonicPoly]\n\n"}
{"name":"FirstOrder.Field.instModelFieldOfCharOfACF","module":"Mathlib.ModelTheory.Algebra.Field.IsAlgClosed","initialProofState":"K : Type u_1\ninst✝ : FirstOrder.Language.ring.Structure K\np : Nat\nh : FirstOrder.Language.Theory.Model K (FirstOrder.Language.Theory.ACF p)\n⊢ FirstOrder.Language.Theory.Model K (FirstOrder.Language.Theory.fieldOfChar p)","decl":"instance [Language.ring.Structure K] (p : ℕ) [h : (Theory.ACF p).Model K] :\n    (Theory.fieldOfChar p).Model K :=\n  Theory.Model.mono h Set.subset_union_left\n\n"}
{"name":"FirstOrder.Field.instModelACFOfCharPOfIsAlgClosed","module":"Mathlib.ModelTheory.Algebra.Field.IsAlgClosed","initialProofState":"K : Type u_1\ninst✝³ : Field K\ninst✝² : FirstOrder.Ring.CompatibleRing K\np : Nat\ninst✝¹ : CharP K p\ninst✝ : IsAlgClosed K\n⊢ FirstOrder.Language.Theory.Model K (FirstOrder.Language.Theory.ACF p)","decl":"instance [Field K] [CompatibleRing K] {p : ℕ} [CharP K p] [IsAlgClosed K] :\n    (Theory.ACF p).Model K := by\n  refine Theory.model_union_iff.2 ⟨inferInstance, ?_⟩\n  simp only [Theory.model_iff, Set.mem_image, Set.mem_singleton_iff,\n    exists_prop, forall_exists_index, and_imp]\n  rintro _ n hn0 rfl\n  simp only [realize_genericMonicPolyHasRoot]\n  rintro ⟨p, _, rfl⟩\n  exact IsAlgClosed.exists_root p (ne_of_gt\n    (natDegree_pos_iff_degree_pos.1 hn0))\n\n"}
{"name":"FirstOrder.Field.modelField_of_modelACF","module":"Mathlib.ModelTheory.Algebra.Field.IsAlgClosed","initialProofState":"p : Nat\nK : Type u_2\ninst✝ : FirstOrder.Language.ring.Structure K\nh : FirstOrder.Language.Theory.Model K (FirstOrder.Language.Theory.ACF p)\n⊢ FirstOrder.Language.Theory.Model K FirstOrder.Language.Theory.field","decl":"theorem modelField_of_modelACF (p : ℕ) (K : Type*) [Language.ring.Structure K]\n    [h : (Theory.ACF p).Model K] : Theory.field.Model K :=\n  Theory.Model.mono h (Set.subset_union_of_subset_left Set.subset_union_left _)\n\n"}
{"name":"FirstOrder.Field.isAlgClosed_of_model_ACF","module":"Mathlib.ModelTheory.Algebra.Field.IsAlgClosed","initialProofState":"p : Nat\nK : Type u_2\ninst✝¹ : Field K\ninst✝ : FirstOrder.Ring.CompatibleRing K\nh : FirstOrder.Language.Theory.Model K (FirstOrder.Language.Theory.ACF p)\n⊢ IsAlgClosed K","decl":"theorem isAlgClosed_of_model_ACF (p : ℕ) (K : Type*)\n    [Field K] [CompatibleRing K] [h : (Theory.ACF p).Model K] :\n    IsAlgClosed K := by\n  refine IsAlgClosed.of_exists_root _ ?_\n  intro p hpm hpi\n  have h : K ⊨ genericMonicPolyHasRoot '' {n | 0 < n} :=\n    Theory.Model.mono h (by simp [Theory.ACF])\n  simp only [Theory.model_iff, Set.mem_image, Set.mem_singleton_iff,\n    exists_prop, forall_exists_index, and_imp] at h\n  have := h _ p.natDegree (natDegree_pos_iff_degree_pos.2\n    (degree_pos_of_irreducible hpi)) rfl\n  rw [realize_genericMonicPolyHasRoot] at this\n  exact this ⟨_, hpm, rfl⟩\n\n"}
{"name":"FirstOrder.Field.ACF_isSatisfiable","module":"Mathlib.ModelTheory.Algebra.Field.IsAlgClosed","initialProofState":"p : Nat\nhp : Or (Nat.Prime p) (Eq p 0)\n⊢ (FirstOrder.Language.Theory.ACF p).IsSatisfiable","decl":"theorem ACF_isSatisfiable {p : ℕ} (hp : p.Prime ∨ p = 0) :\n    (Theory.ACF p).IsSatisfiable := by\n  cases hp with\n  | inl hp =>\n    have : Fact p.Prime := ⟨hp⟩\n    let _ := compatibleRingOfRing (AlgebraicClosure (ZMod p))\n    have : CharP (AlgebraicClosure (ZMod p)) p :=\n      charP_of_injective_algebraMap\n        (RingHom.injective (algebraMap (ZMod p) (AlgebraicClosure (ZMod p)))) p\n    exact ⟨⟨AlgebraicClosure (ZMod p)⟩⟩\n  | inr hp =>\n    subst hp\n    let _ := compatibleRingOfRing (AlgebraicClosure ℚ)\n    have : CharP (AlgebraicClosure ℚ) 0 :=\n      charP_of_injective_algebraMap\n        (RingHom.injective (algebraMap ℚ (AlgebraicClosure ℚ))) 0\n    exact ⟨⟨AlgebraicClosure ℚ⟩⟩\n\n"}
{"name":"FirstOrder.Field.ACF_categorical","module":"Mathlib.ModelTheory.Algebra.Field.IsAlgClosed","initialProofState":"p : Nat\nκ : Cardinal.{u_2}\nhκ : LT.lt Cardinal.aleph0 κ\n⊢ κ.Categorical (FirstOrder.Language.Theory.ACF p)","decl":"/-- The Theory `Theory.ACF p` is `κ`-categorical whenever `κ` is an uncountable cardinal. -/\ntheorem ACF_categorical {p : ℕ} (κ : Cardinal) (hκ : ℵ₀ < κ) :\n    Categorical κ (Theory.ACF p) := by\n  rintro ⟨M⟩ ⟨N⟩ hM hN\n  let _ := fieldOfModelACF p M\n  have := modelField_of_modelACF p M\n  let _ := compatibleRingOfModelField M\n  have := isAlgClosed_of_model_ACF p M\n  have := charP_of_model_fieldOfChar p M\n  let _ := fieldOfModelACF p N\n  have := modelField_of_modelACF p N\n  let _ := compatibleRingOfModelField N\n  have := isAlgClosed_of_model_ACF p N\n  have := charP_of_model_fieldOfChar p N\n  constructor\n  refine languageEquivEquivRingEquiv.symm ?_\n  apply Classical.choice\n  refine IsAlgClosed.ringEquiv_of_equiv_of_char_eq p ?_ ?_\n  · rw [hM]; exact hκ\n  · rw [← Cardinal.eq, hM, hN]\n\n"}
{"name":"FirstOrder.Field.ACF_isComplete","module":"Mathlib.ModelTheory.Algebra.Field.IsAlgClosed","initialProofState":"p : Nat\nhp : Or (Nat.Prime p) (Eq p 0)\n⊢ (FirstOrder.Language.Theory.ACF p).IsComplete","decl":"theorem ACF_isComplete {p : ℕ} (hp : p.Prime ∨ p = 0) :\n    (Theory.ACF p).IsComplete := by\n  apply Categorical.isComplete.{0, 0, 0} (Order.succ ℵ₀) _\n    (ACF_categorical _ (Order.lt_succ _))\n    (Order.le_succ ℵ₀)\n  · simp only [card_ring, lift_id']\n    exact le_trans (le_of_lt (lt_aleph0_of_finite _)) (Order.le_succ _)\n  · exact ACF_isSatisfiable hp\n  · rintro ⟨M⟩\n    let _ := fieldOfModelACF p M\n    have := modelField_of_modelACF p M\n    let _ := compatibleRingOfModelField M\n    have := isAlgClosed_of_model_ACF p M\n    infer_instance\n\n"}
{"name":"FirstOrder.Field.finite_ACF_prime_not_realize_of_ACF_zero_realize","module":"Mathlib.ModelTheory.Algebra.Field.IsAlgClosed","initialProofState":"φ : FirstOrder.Language.ring.Sentence\nh : (FirstOrder.Language.Theory.ACF 0).ModelsBoundedFormula φ\n⊢ (setOf fun p => Not ((FirstOrder.Language.Theory.ACF ↑p).ModelsBoundedFormula φ)).Finite","decl":"theorem finite_ACF_prime_not_realize_of_ACF_zero_realize\n    (φ : Language.ring.Sentence) (h : Theory.ACF 0 ⊨ᵇ φ) :\n    Set.Finite { p : Nat.Primes | ¬ Theory.ACF p ⊨ᵇ φ } := by\n  rw [Theory.models_iff_finset_models] at h\n  rcases h with ⟨T0, hT0, h⟩\n  have f : ∀ ψ ∈ Theory.ACF 0,\n      { s : Finset Nat.Primes // ∀ q : Nat.Primes, q ∉ s → Theory.ACF q ⊨ᵇ ψ } := by\n    intro ψ hψ\n    rw [Theory.ACF, Theory.fieldOfChar, Set.union_right_comm, Set.mem_union, if_pos rfl,\n      Set.mem_image] at hψ\n    apply Classical.choice\n    rcases hψ with h | ⟨p, hp, rfl⟩\n    · refine ⟨⟨∅, ?_⟩⟩\n      intro q _\n      exact Theory.models_sentence_of_mem\n        (by rw [Theory.ACF, Theory.fieldOfChar, Set.union_right_comm];\n            exact Set.mem_union_left _ h)\n    · refine ⟨⟨{⟨p, hp⟩}, ?_⟩⟩\n      rintro ⟨q, _⟩ hq ⟨K⟩ _ _\n      have hqp : q ≠ p := by simpa [← Nat.Primes.coe_nat_inj] using hq\n      let _ := fieldOfModelACF q K\n      have := modelField_of_modelACF q K\n      let _ := compatibleRingOfModelField K\n      have := charP_of_model_fieldOfChar q K\n      simp only [eqZero, Term.equal, BoundedFormula.realize_not, BoundedFormula.realize_bdEqual,\n        Term.realize_relabel, Sum.elim_comp_inl, realize_termOfFreeCommRing, map_natCast,\n        realize_zero, ← CharP.charP_iff_prime_eq_zero hp]\n      intro _\n      exact hqp <| CharP.eq K inferInstance inferInstance\n  let s : Finset Nat.Primes := T0.attach.biUnion (fun φ => f φ.1 (hT0 φ.2))\n  have hs : ∀ (p : Nat.Primes) ψ, ψ ∈ T0 → p ∉ s → Theory.ACF p ⊨ᵇ ψ := by\n    intro p ψ hψ hpψ\n    simp only [s, Finset.mem_biUnion, Finset.mem_attach, true_and,\n      Subtype.exists, not_exists] at hpψ\n    exact (f ψ (hT0 hψ)).2 p (hpψ _ hψ)\n  refine Set.Finite.subset (Finset.finite_toSet s) (Set.compl_subset_comm.2 ?_)\n  intro p hp\n  exact Theory.models_of_models_theory (fun ψ hψ => hs p ψ hψ hp) h\n\n"}
{"name":"FirstOrder.Field.ACF_zero_realize_iff_infinite_ACF_prime_realize","module":"Mathlib.ModelTheory.Algebra.Field.IsAlgClosed","initialProofState":"φ : FirstOrder.Language.ring.Sentence\n⊢ Iff ((FirstOrder.Language.Theory.ACF 0).ModelsBoundedFormula φ) (setOf fun p => (FirstOrder.Language.Theory.ACF ↑p).ModelsBoundedFormula φ).Infinite","decl":"/-- The **Lefschetz principle**. A first order sentence is modeled by the theory\nof algebraically closed fields of characteristic zero if and only if it is modeled by\nthe theory of algebraically closed fields of characteristic `p` for infinitely many `p`. -/\ntheorem ACF_zero_realize_iff_infinite_ACF_prime_realize {φ : Language.ring.Sentence} :\n    Theory.ACF 0 ⊨ᵇ φ ↔ Set.Infinite { p : Nat.Primes | Theory.ACF p ⊨ᵇ φ } := by\n  refine ⟨fun h => Set.infinite_of_finite_compl\n      (finite_ACF_prime_not_realize_of_ACF_zero_realize φ h),\n    not_imp_not.1 ?_⟩\n  simpa [(ACF_isComplete (Or.inr rfl)).models_not_iff,\n      fun p : Nat.Primes => (ACF_isComplete (Or.inl p.2)).models_not_iff] using\n    finite_ACF_prime_not_realize_of_ACF_zero_realize φ.not\n\n"}
{"name":"FirstOrder.Field.ACF_zero_realize_iff_finite_ACF_prime_not_realize","module":"Mathlib.ModelTheory.Algebra.Field.IsAlgClosed","initialProofState":"φ : FirstOrder.Language.ring.Sentence\n⊢ Iff ((FirstOrder.Language.Theory.ACF 0).ModelsBoundedFormula φ) (HasCompl.compl (setOf fun p => (FirstOrder.Language.Theory.ACF ↑p).ModelsBoundedFormula φ)).Finite","decl":"/-- Another statement of the **Lefschetz principle**. A first order sentence is modeled by the\ntheory of algebraically closed fields of characteristic zero if and only if it is modeled by the\ntheory of algebraically closed fields of characteristic `p` for all but finitely many primes `p`.\n-/\ntheorem ACF_zero_realize_iff_finite_ACF_prime_not_realize {φ : Language.ring.Sentence} :\n    Theory.ACF 0 ⊨ᵇ φ ↔ Set.Finite { p : Nat.Primes | Theory.ACF p ⊨ᵇ φ }ᶜ :=\n  ⟨fun h => finite_ACF_prime_not_realize_of_ACF_zero_realize φ h,\n    fun h => ACF_zero_realize_iff_infinite_ACF_prime_realize.2\n      (Set.infinite_of_finite_compl h)⟩\n\n\n"}
