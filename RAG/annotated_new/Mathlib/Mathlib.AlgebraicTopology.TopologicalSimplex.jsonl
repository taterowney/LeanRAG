{"name":"SimplexCategory.toTopObj.ext","module":"Mathlib.AlgebraicTopology.TopologicalSimplex","initialProofState":"x : SimplexCategory\nf g : ↑x.toTopObj\na✝ : Eq ↑f ↑g\n⊢ Eq f g","decl":"@[ext]\ntheorem toTopObj.ext {x : SimplexCategory} (f g : x.toTopObj) : (f : x → ℝ≥0) = g → f = g :=\n  Subtype.ext\n\n"}
{"name":"SimplexCategory.toTopObj.ext_iff","module":"Mathlib.AlgebraicTopology.TopologicalSimplex","initialProofState":"x : SimplexCategory\nf g : ↑x.toTopObj\n⊢ Iff (Eq f g) (Eq ↑f ↑g)","decl":"@[ext]\ntheorem toTopObj.ext {x : SimplexCategory} (f g : x.toTopObj) : (f : x → ℝ≥0) = g → f = g :=\n  Subtype.ext\n\n"}
{"name":"SimplexCategory.coe_toTopMap","module":"Mathlib.AlgebraicTopology.TopologicalSimplex","initialProofState":"x y : SimplexCategory\nf : Quiver.Hom x y\ng : ↑x.toTopObj\ni : (CategoryTheory.forget SimplexCategory).obj y\n⊢ Eq (↑(SimplexCategory.toTopMap f g) i) ((Finset.filter (fun x_1 => Eq (f x_1) i) Finset.univ).sum fun j => ↑g j)","decl":"open Classical in\n@[simp]\ntheorem coe_toTopMap {x y : SimplexCategory} (f : x ⟶ y) (g : x.toTopObj) (i : y) :\n    toTopMap f g i = ∑ j ∈ Finset.univ.filter (f · = i), g j :=\n  rfl\n\n"}
{"name":"SimplexCategory.continuous_toTopMap","module":"Mathlib.AlgebraicTopology.TopologicalSimplex","initialProofState":"x y : SimplexCategory\nf : Quiver.Hom x y\n⊢ Continuous (SimplexCategory.toTopMap f)","decl":"@[continuity]\ntheorem continuous_toTopMap {x y : SimplexCategory} (f : x ⟶ y) : Continuous (toTopMap f) := by\n  refine Continuous.subtype_mk (continuous_pi fun i => ?_) _\n  dsimp only [coe_toTopMap]\n  exact continuous_finset_sum _ (fun j _ => (continuous_apply _).comp continuous_subtype_val)\n\n"}
{"name":"SimplexCategory.toTop_obj","module":"Mathlib.AlgebraicTopology.TopologicalSimplex","initialProofState":"x : SimplexCategory\n⊢ Eq (SimplexCategory.toTop.obj x) (TopCat.of ↑x.toTopObj)","decl":"/-- The functor associating the topological `n`-simplex to `[n] : SimplexCategory`. -/\n@[simps obj map]\ndef toTop : SimplexCategory ⥤ TopCat where\n  obj x := TopCat.of x.toTopObj\n  map f := ⟨toTopMap f, by continuity⟩\n  map_id := by\n    classical\n    intro Δ\n    ext f\n    apply toTopObj.ext\n    funext i\n    change (Finset.univ.filter (· = i)).sum _ = _\n    simp [Finset.sum_filter, CategoryTheory.id_apply]\n  map_comp := fun f g => by\n    classical\n    ext h\n    apply toTopObj.ext\n    funext i\n    dsimp\n    simp only [CategoryTheory.comp_apply, TopCat.coe_of_of, ContinuousMap.coe_mk, coe_toTopMap]\n    rw [← Finset.sum_biUnion]\n    · apply Finset.sum_congr\n      · exact Finset.ext (fun j => ⟨fun hj => by simpa using hj, fun hj => by simpa using hj⟩)\n      · tauto\n    · apply Set.pairwiseDisjoint_filter\n\n"}
{"name":"SimplexCategory.toTop_map","module":"Mathlib.AlgebraicTopology.TopologicalSimplex","initialProofState":"X✝ Y✝ : SimplexCategory\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (SimplexCategory.toTop.map f) { toFun := SimplexCategory.toTopMap f, continuous_toFun := ⋯ }","decl":"/-- The functor associating the topological `n`-simplex to `[n] : SimplexCategory`. -/\n@[simps obj map]\ndef toTop : SimplexCategory ⥤ TopCat where\n  obj x := TopCat.of x.toTopObj\n  map f := ⟨toTopMap f, by continuity⟩\n  map_id := by\n    classical\n    intro Δ\n    ext f\n    apply toTopObj.ext\n    funext i\n    change (Finset.univ.filter (· = i)).sum _ = _\n    simp [Finset.sum_filter, CategoryTheory.id_apply]\n  map_comp := fun f g => by\n    classical\n    ext h\n    apply toTopObj.ext\n    funext i\n    dsimp\n    simp only [CategoryTheory.comp_apply, TopCat.coe_of_of, ContinuousMap.coe_mk, coe_toTopMap]\n    rw [← Finset.sum_biUnion]\n    · apply Finset.sum_congr\n      · exact Finset.ext (fun j => ⟨fun hj => by simpa using hj, fun hj => by simpa using hj⟩)\n      · tauto\n    · apply Set.pairwiseDisjoint_filter\n\n"}
