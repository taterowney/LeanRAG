{"name":"Algebra.Extension.cotangentComplex_mk","module":"Mathlib.RingTheory.Kaehler.CotangentComplex","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Extension R S\nx : Subtype fun x => Membership.mem P.ker x\n⊢ Eq (P.cotangentComplex (Algebra.Extension.Cotangent.mk x)) (TensorProduct.tmul P.Ring 1 ((KaehlerDifferential.D R P.Ring) ↑x))","decl":"@[simp]\nlemma cotangentComplex_mk (x) : P.cotangentComplex (.mk x) = 1 ⊗ₜ .D _ _ x :=\n  kerCotangentToTensor_toCotangent _ _ _ _\n\n"}
{"name":"Algebra.Extension.CotangentSpace.map_tmul","module":"Mathlib.RingTheory.Kaehler.CotangentComplex","initialProofState":"R : Type u\nS : Type v\ninst✝⁹ : CommRing R\ninst✝⁸ : CommRing S\ninst✝⁷ : Algebra R S\nP : Algebra.Extension R S\nR' : Type u'\nS' : Type v'\ninst✝⁶ : CommRing R'\ninst✝⁵ : CommRing S'\ninst✝⁴ : Algebra R' S'\nP' : Algebra.Extension R' S'\ninst✝³ : Algebra R R'\ninst✝² : Algebra S S'\ninst✝¹ : Algebra R S'\ninst✝ : IsScalarTower R R' S'\nf : P.Hom P'\nx : S\ny : P.Ring\n⊢ Eq ((Algebra.Extension.CotangentSpace.map f) (TensorProduct.tmul P.Ring x ((KaehlerDifferential.D R P.Ring) y))) (TensorProduct.tmul P'.Ring ((algebraMap S S') x) ((KaehlerDifferential.D R' P'.Ring) (f.toAlgHom y)))","decl":"@[simp]\nlemma map_tmul (f : Hom P P') (x y) :\n    CotangentSpace.map f (x ⊗ₜ .D _ _ y) = (algebraMap _ _ x) ⊗ₜ .D _ _ (f.toAlgHom y) := by\n  simp only [CotangentSpace.map, AlgHom.toRingHom_eq_coe, LinearMap.liftBaseChange_tmul,\n    LinearMap.coe_comp, LinearMap.coe_restrictScalars, Function.comp_apply, map_D, mk_apply]\n  rw [smul_tmul', ← Algebra.algebraMap_eq_smul_one]\n  rfl\n\n"}
{"name":"Algebra.Extension.CotangentSpace.map_id","module":"Mathlib.RingTheory.Kaehler.CotangentComplex","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Extension R S\n⊢ Eq (Algebra.Extension.CotangentSpace.map (Algebra.Extension.Hom.id P)) LinearMap.id","decl":"@[simp]\nlemma map_id :\n    CotangentSpace.map (.id P) = LinearMap.id := by ext; simp\n\n"}
{"name":"Algebra.Extension.CotangentSpace.map_comp","module":"Mathlib.RingTheory.Kaehler.CotangentComplex","initialProofState":"R : Type u\nS : Type v\ninst✝²² : CommRing R\ninst✝²¹ : CommRing S\ninst✝²⁰ : Algebra R S\nP : Algebra.Extension R S\nR' : Type u'\nS' : Type v'\ninst✝¹⁹ : CommRing R'\ninst✝¹⁸ : CommRing S'\ninst✝¹⁷ : Algebra R' S'\nP' : Algebra.Extension R' S'\ninst✝¹⁶ : Algebra R R'\ninst✝¹⁵ : Algebra S S'\ninst✝¹⁴ : Algebra R S'\ninst✝¹³ : IsScalarTower R R' S'\nR'' : Type u''\nS'' : Type v''\ninst✝¹² : CommRing R''\ninst✝¹¹ : CommRing S''\ninst✝¹⁰ : Algebra R'' S''\nP'' : Algebra.Extension R'' S''\ninst✝⁹ : Algebra R R''\ninst✝⁸ : Algebra S S''\ninst✝⁷ : Algebra R S''\ninst✝⁶ : IsScalarTower R R'' S''\ninst✝⁵ : Algebra R' R''\ninst✝⁴ : Algebra S' S''\ninst✝³ : Algebra R' S''\ninst✝² : IsScalarTower R' R'' S''\ninst✝¹ : IsScalarTower R R' R''\ninst✝ : IsScalarTower S S' S''\nf : P.Hom P'\ng : P'.Hom P''\n⊢ Eq (Algebra.Extension.CotangentSpace.map (g.comp f)) ((↑S (Algebra.Extension.CotangentSpace.map g)).comp (Algebra.Extension.CotangentSpace.map f))","decl":"lemma map_comp (f : Hom P P') (g : Hom P' P'') :\n    CotangentSpace.map (g.comp f) =\n      (CotangentSpace.map g).restrictScalars S ∘ₗ CotangentSpace.map f := by\n  ext x\n  induction x using TensorProduct.induction_on with\n  | zero =>\n    simp only [map_zero, LinearMap.coe_comp, LinearMap.coe_restrictScalars, Function.comp_apply]\n  | add =>\n    simp only [map_add, LinearMap.coe_comp, LinearMap.coe_restrictScalars, Function.comp_apply, *]\n  | tmul x y =>\n    obtain ⟨y, rfl⟩ := KaehlerDifferential.tensorProductTo_surjective _ _ y\n    induction y with\n    | zero => simp only [map_zero, tmul_zero, LinearMap.coe_comp, LinearMap.coe_restrictScalars,\n        Function.comp_apply]\n    | add => simp only [map_add, tmul_add, LinearMap.coe_comp, LinearMap.coe_restrictScalars,\n      Function.comp_apply, *]\n    | tmul => simp only [Derivation.tensorProductTo_tmul, tmul_smul, smul_tmul', map_tmul,\n        Hom.toAlgHom_apply, Hom.comp_toRingHom, RingHom.coe_comp, Function.comp_apply,\n        LinearMap.coe_comp, LinearMap.coe_restrictScalars,\n        ← IsScalarTower.algebraMap_apply S S' S'']\n\n"}
{"name":"Algebra.Extension.CotangentSpace.map_comp_apply","module":"Mathlib.RingTheory.Kaehler.CotangentComplex","initialProofState":"R : Type u\nS : Type v\ninst✝²² : CommRing R\ninst✝²¹ : CommRing S\ninst✝²⁰ : Algebra R S\nP : Algebra.Extension R S\nR' : Type u'\nS' : Type v'\ninst✝¹⁹ : CommRing R'\ninst✝¹⁸ : CommRing S'\ninst✝¹⁷ : Algebra R' S'\nP' : Algebra.Extension R' S'\ninst✝¹⁶ : Algebra R R'\ninst✝¹⁵ : Algebra S S'\ninst✝¹⁴ : Algebra R S'\ninst✝¹³ : IsScalarTower R R' S'\nR'' : Type u''\nS'' : Type v''\ninst✝¹² : CommRing R''\ninst✝¹¹ : CommRing S''\ninst✝¹⁰ : Algebra R'' S''\nP'' : Algebra.Extension R'' S''\ninst✝⁹ : Algebra R R''\ninst✝⁸ : Algebra S S''\ninst✝⁷ : Algebra R S''\ninst✝⁶ : IsScalarTower R R'' S''\ninst✝⁵ : Algebra R' R''\ninst✝⁴ : Algebra S' S''\ninst✝³ : Algebra R' S''\ninst✝² : IsScalarTower R' R'' S''\ninst✝¹ : IsScalarTower R R' R''\ninst✝ : IsScalarTower S S' S''\nf : P.Hom P'\ng : P'.Hom P''\nx : P.CotangentSpace\n⊢ Eq ((Algebra.Extension.CotangentSpace.map (g.comp f)) x) ((Algebra.Extension.CotangentSpace.map g) ((Algebra.Extension.CotangentSpace.map f) x))","decl":"lemma map_comp_apply (f : Hom P P') (g : Hom P' P'') (x) :\n    CotangentSpace.map (g.comp f) x = .map g (.map f x) :=\n  DFunLike.congr_fun (map_comp f g) x\n\n"}
{"name":"Algebra.Extension.CotangentSpace.map_cotangentComplex","module":"Mathlib.RingTheory.Kaehler.CotangentComplex","initialProofState":"R : Type u\nS : Type v\ninst✝⁹ : CommRing R\ninst✝⁸ : CommRing S\ninst✝⁷ : Algebra R S\nP : Algebra.Extension R S\nR' : Type u'\nS' : Type v'\ninst✝⁶ : CommRing R'\ninst✝⁵ : CommRing S'\ninst✝⁴ : Algebra R' S'\nP' : Algebra.Extension R' S'\ninst✝³ : Algebra R R'\ninst✝² : Algebra S S'\ninst✝¹ : Algebra R S'\ninst✝ : IsScalarTower R R' S'\nf : P.Hom P'\nx : P.Cotangent\n⊢ Eq ((Algebra.Extension.CotangentSpace.map f) (P.cotangentComplex x)) (P'.cotangentComplex ((Algebra.Extension.Cotangent.map f) x))","decl":"lemma map_cotangentComplex (f : Hom P P') (x) :\n    CotangentSpace.map f (P.cotangentComplex x) = P'.cotangentComplex (.map f x) := by\n  obtain ⟨x, rfl⟩ := Cotangent.mk_surjective x\n  rw [cotangentComplex_mk, map_tmul, map_one, Cotangent.map_mk, cotangentComplex_mk]\n\n"}
{"name":"Algebra.Extension.CotangentSpace.map_comp_cotangentComplex","module":"Mathlib.RingTheory.Kaehler.CotangentComplex","initialProofState":"R : Type u\nS : Type v\ninst✝⁹ : CommRing R\ninst✝⁸ : CommRing S\ninst✝⁷ : Algebra R S\nP : Algebra.Extension R S\nR' : Type u'\nS' : Type v'\ninst✝⁶ : CommRing R'\ninst✝⁵ : CommRing S'\ninst✝⁴ : Algebra R' S'\nP' : Algebra.Extension R' S'\ninst✝³ : Algebra R R'\ninst✝² : Algebra S S'\ninst✝¹ : Algebra R S'\ninst✝ : IsScalarTower R R' S'\nf : P.Hom P'\n⊢ Eq ((Algebra.Extension.CotangentSpace.map f).comp P.cotangentComplex) ((↑S P'.cotangentComplex).comp (Algebra.Extension.Cotangent.map f))","decl":"lemma map_comp_cotangentComplex (f : Hom P P') :\n    CotangentSpace.map f ∘ₗ P.cotangentComplex =\n      P'.cotangentComplex.restrictScalars S ∘ₗ Cotangent.map f := by\n  ext x; exact map_cotangentComplex f x\n\n"}
{"name":"Algebra.Extension.Hom.sub_aux","module":"Mathlib.RingTheory.Kaehler.CotangentComplex","initialProofState":"R : Type u\nS : Type v\ninst✝⁹ : CommRing R\ninst✝⁸ : CommRing S\ninst✝⁷ : Algebra R S\nP : Algebra.Extension R S\nR' : Type u'\nS' : Type v'\ninst✝⁶ : CommRing R'\ninst✝⁵ : CommRing S'\ninst✝⁴ : Algebra R' S'\nP' : Algebra.Extension R' S'\ninst✝³ : Algebra R R'\ninst✝² : Algebra S S'\ninst✝¹ : Algebra R S'\ninst✝ : IsScalarTower R R' S'\nf g : P.Hom P'\nx y : P.Ring\n⊢ Membership.mem (HPow.hPow P'.ker 2) (HSub.hSub (HSub.hSub (f.toAlgHom (HMul.hMul x y)) (g.toAlgHom (HMul.hMul x y))) (HAdd.hAdd (HMul.hMul (P'.σ ((algebraMap P.Ring S') x)) (HSub.hSub (f.toAlgHom y) (g.toAlgHom y))) (HMul.hMul (P'.σ ((algebraMap P.Ring S') y)) (HSub.hSub (f.toAlgHom x) (g.toAlgHom x)))))","decl":"lemma Hom.sub_aux (f g : Hom P P') (x y) :\n    letI := ((algebraMap S S').comp (algebraMap P.Ring S)).toAlgebra\n    f.toAlgHom (x * y) - g.toAlgHom (x * y) -\n        (P'.σ ((algebraMap P.Ring S') x) * (f.toAlgHom y - g.toAlgHom y) +\n          P'.σ ((algebraMap P.Ring S') y) * (f.toAlgHom x - g.toAlgHom x)) ∈\n      P'.ker ^ 2 := by\n  letI := ((algebraMap S S').comp (algebraMap P.Ring S)).toAlgebra\n  have :\n      (f.toAlgHom x - P'.σ (algebraMap P.Ring S' x)) * (f.toAlgHom y - g.toAlgHom y) +\n      (g.toAlgHom y - P'.σ (algebraMap P.Ring S' y)) * (f.toAlgHom x - g.toAlgHom x)\n        ∈ P'.ker ^ 2 := by\n    rw [pow_two]\n    refine Ideal.add_mem _ (Ideal.mul_mem_mul ?_ ?_) (Ideal.mul_mem_mul ?_ ?_) <;>\n      simp only [RingHom.algebraMap_toAlgebra, AlgHom.toRingHom_eq_coe, RingHom.coe_comp,\n        RingHom.coe_coe, Function.comp_apply, map_aeval, ← IsScalarTower.algebraMap_eq,\n        coe_eval₂Hom, ← aeval_def, ker, RingHom.mem_ker, map_sub, algebraMap_toRingHom,\n        algebraMap_σ, sub_self, toAlgHom_apply]\n  convert this using 1\n  simp only [map_mul]\n  ring\n\n"}
{"name":"Algebra.Extension.Hom.subToKer_apply_coe","module":"Mathlib.RingTheory.Kaehler.CotangentComplex","initialProofState":"R : Type u\nS : Type v\ninst✝⁹ : CommRing R\ninst✝⁸ : CommRing S\ninst✝⁷ : Algebra R S\nP : Algebra.Extension R S\nR' : Type u'\nS' : Type v'\ninst✝⁶ : CommRing R'\ninst✝⁵ : CommRing S'\ninst✝⁴ : Algebra R' S'\nP' : Algebra.Extension R' S'\ninst✝³ : Algebra R R'\ninst✝² : Algebra S S'\ninst✝¹ : Algebra R S'\ninst✝ : IsScalarTower R R' S'\nf g : P.Hom P'\nc : P.Ring\n⊢ Eq (↑((f.subToKer g) c)) (HSub.hSub (f.toRingHom c) (g.toRingHom c))","decl":"/--\nIf `f` and `g` are two maps `P → P'` between presentations,\nthen the image of `f - g` is in the kernel of `P' → S`.\n-/\n@[simps! apply_coe]\nnoncomputable\ndef Hom.subToKer (f g : Hom P P') : P.Ring →ₗ[R] P'.ker := by\n  refine ((f.toAlgHom.toLinearMap - g.toAlgHom.toLinearMap).codRestrict\n    (P'.ker.restrictScalars R) ?_)\n  intro x\n  simp only [LinearMap.sub_apply, AlgHom.toLinearMap_apply, ker, algebraMap_eq,\n    Submodule.restrictScalars_mem, RingHom.mem_ker, map_sub, RingHom.coe_coe, algebraMap_toRingHom,\n    map_aeval, coe_eval₂Hom, sub_self, toAlgHom_apply]\n\n"}
{"name":"Algebra.Extension.Hom.sub_one_tmul","module":"Mathlib.RingTheory.Kaehler.CotangentComplex","initialProofState":"R : Type u\nS : Type v\ninst✝¹⁰ : CommRing R\ninst✝⁹ : CommRing S\ninst✝⁸ : Algebra R S\nP : Algebra.Extension R S\nR' : Type u'\nS' : Type v'\ninst✝⁷ : CommRing R'\ninst✝⁶ : CommRing S'\ninst✝⁵ : Algebra R' S'\nP' : Algebra.Extension R' S'\ninst✝⁴ : Algebra R R'\ninst✝³ : Algebra S S'\ninst✝² : Algebra R S'\ninst✝¹ : IsScalarTower R R' S'\ninst✝ : IsScalarTower R S S'\nf g : P.Hom P'\nx : P.Ring\n⊢ Eq ((f.sub g) (TensorProduct.tmul P.Ring 1 ((KaehlerDifferential.D R P.Ring) x))) (Algebra.Extension.Cotangent.mk ((f.subToKer g) x))","decl":"lemma Hom.sub_one_tmul (f g : Hom P P') (x) :\n    f.sub g (1 ⊗ₜ .D _ _ x) = Cotangent.mk (f.subToKer g x) := by\n  simp only [sub, LinearMap.liftBaseChange_tmul, Derivation.liftKaehlerDifferential_comp_D,\n    Derivation.mk_coe, LinearMap.coe_comp, LinearMap.coe_restrictScalars, Function.comp_apply,\n    one_smul]\n\n"}
{"name":"Algebra.Extension.Hom.sub_tmul","module":"Mathlib.RingTheory.Kaehler.CotangentComplex","initialProofState":"R : Type u\nS : Type v\ninst✝¹⁰ : CommRing R\ninst✝⁹ : CommRing S\ninst✝⁸ : Algebra R S\nP : Algebra.Extension R S\nR' : Type u'\nS' : Type v'\ninst✝⁷ : CommRing R'\ninst✝⁶ : CommRing S'\ninst✝⁵ : Algebra R' S'\nP' : Algebra.Extension R' S'\ninst✝⁴ : Algebra R R'\ninst✝³ : Algebra S S'\ninst✝² : Algebra R S'\ninst✝¹ : IsScalarTower R R' S'\ninst✝ : IsScalarTower R S S'\nf g : P.Hom P'\nr : S\nx : P.Ring\n⊢ Eq ((f.sub g) (TensorProduct.tmul P.Ring r ((KaehlerDifferential.D R P.Ring) x))) (HSMul.hSMul r (Algebra.Extension.Cotangent.mk ((f.subToKer g) x)))","decl":"@[simp]\nlemma Hom.sub_tmul (f g : Hom P P') (r x) :\n    f.sub g (r ⊗ₜ .D _ _ x) = r • Cotangent.mk (f.subToKer g x) := by\n  simp only [sub, LinearMap.liftBaseChange_tmul, Derivation.liftKaehlerDifferential_comp_D,\n    Derivation.mk_coe, LinearMap.coe_comp, LinearMap.coe_restrictScalars, Function.comp_apply]\n\n"}
{"name":"Algebra.Extension.CotangentSpace.map_sub_map","module":"Mathlib.RingTheory.Kaehler.CotangentComplex","initialProofState":"R : Type u\nS : Type v\ninst✝¹⁰ : CommRing R\ninst✝⁹ : CommRing S\ninst✝⁸ : Algebra R S\nP : Algebra.Extension R S\nR' : Type u'\nS' : Type v'\ninst✝⁷ : CommRing R'\ninst✝⁶ : CommRing S'\ninst✝⁵ : Algebra R' S'\nP' : Algebra.Extension R' S'\ninst✝⁴ : Algebra R R'\ninst✝³ : Algebra S S'\ninst✝² : Algebra R S'\ninst✝¹ : IsScalarTower R R' S'\ninst✝ : IsScalarTower R S S'\nf g : P.Hom P'\n⊢ Eq (HSub.hSub (Algebra.Extension.CotangentSpace.map f) (Algebra.Extension.CotangentSpace.map g)) ((↑S P'.cotangentComplex).comp (f.sub g))","decl":"lemma CotangentSpace.map_sub_map (f g : Hom P P') :\n    CotangentSpace.map f - CotangentSpace.map g =\n      P'.cotangentComplex.restrictScalars S ∘ₗ (f.sub g) := by\n  ext x\n  induction x using TensorProduct.induction_on with\n  | zero =>\n    simp only [map_zero, LinearMap.coe_comp, LinearMap.coe_restrictScalars, Function.comp_apply]\n  | add =>\n    simp only [map_add, LinearMap.coe_comp, LinearMap.coe_restrictScalars, Function.comp_apply, *]\n  | tmul x y =>\n    obtain ⟨y, rfl⟩ := KaehlerDifferential.tensorProductTo_surjective _ _ y\n    induction y with\n    | zero => simp only [map_zero, tmul_zero, LinearMap.coe_comp, LinearMap.coe_restrictScalars,\n        Function.comp_apply]\n    | add => simp only [map_add, tmul_add, LinearMap.coe_comp, LinearMap.coe_restrictScalars,\n      Function.comp_apply, *]\n    | tmul =>\n      simp only [Derivation.tensorProductTo_tmul, tmul_smul, smul_tmul', LinearMap.sub_apply,\n        map_tmul, Hom.toAlgHom_apply, LinearMap.coe_comp, LinearMap.coe_restrictScalars,\n        Function.comp_apply, Hom.sub_tmul, LinearMap.map_smul_of_tower, cotangentComplex_mk,\n        Hom.subToKer_apply_coe, map_sub, ← algebraMap_eq_smul_one, tmul_sub, smul_sub]\n\n"}
{"name":"Algebra.Extension.Cotangent.map_sub_map","module":"Mathlib.RingTheory.Kaehler.CotangentComplex","initialProofState":"R : Type u\nS : Type v\ninst✝¹⁰ : CommRing R\ninst✝⁹ : CommRing S\ninst✝⁸ : Algebra R S\nP : Algebra.Extension R S\nR' : Type u'\nS' : Type v'\ninst✝⁷ : CommRing R'\ninst✝⁶ : CommRing S'\ninst✝⁵ : Algebra R' S'\nP' : Algebra.Extension R' S'\ninst✝⁴ : Algebra R R'\ninst✝³ : Algebra S S'\ninst✝² : Algebra R S'\ninst✝¹ : IsScalarTower R R' S'\ninst✝ : IsScalarTower R S S'\nf g : P.Hom P'\n⊢ Eq (HSub.hSub (Algebra.Extension.Cotangent.map f) (Algebra.Extension.Cotangent.map g)) ((f.sub g).comp P.cotangentComplex)","decl":"lemma Cotangent.map_sub_map (f g : Hom P P') :\n    map f - map g = (f.sub g) ∘ₗ P.cotangentComplex := by\n  ext x\n  obtain ⟨x, rfl⟩ := mk_surjective x\n  simp only [LinearMap.sub_apply, map_mk, LinearMap.coe_comp, Function.comp_apply,\n    cotangentComplex_mk, Hom.sub_tmul, one_smul, val_mk]\n  apply (Ideal.cotangentEquivIdeal _).injective\n  ext\n  simp only [val_sub, val_mk, map_sub, AddSubgroupClass.coe_sub, Ideal.cotangentEquivIdeal_apply,\n    Ideal.toCotangent_to_quotient_square, Submodule.mkQ_apply, Ideal.Quotient.mk_eq_mk,\n    Hom.subToKer_apply_coe]\n  rfl\n\n"}
{"name":"Algebra.Extension.toKaehler_surjective","module":"Mathlib.RingTheory.Kaehler.CotangentComplex","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Extension R S\n⊢ Function.Surjective ⇑P.toKaehler","decl":"lemma toKaehler_surjective : Function.Surjective P.toKaehler :=\n  mapBaseChange_surjective _ _ _ P.algebraMap_surjective\n\n"}
{"name":"Algebra.Extension.exact_cotangentComplex_toKaehler","module":"Mathlib.RingTheory.Kaehler.CotangentComplex","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Extension R S\n⊢ Function.Exact ⇑P.cotangentComplex ⇑P.toKaehler","decl":"lemma exact_cotangentComplex_toKaehler : Function.Exact P.cotangentComplex P.toKaehler :=\n  exact_kerCotangentToTensor_mapBaseChange _ _ _ P.algebraMap_surjective\n\n"}
{"name":"Algebra.Extension.H1Cotangent.val_add","module":"Mathlib.RingTheory.Kaehler.CotangentComplex","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Extension R S\nx y : P.H1Cotangent\n⊢ Eq (↑(HAdd.hAdd x y)) (HAdd.hAdd ↑x ↑y)","decl":"@[simp] lemma H1Cotangent.val_add (x y : P.H1Cotangent) : (x + y).1 = x.1 + y.1 := rfl\n"}
{"name":"Algebra.Extension.H1Cotangent.val_zero","module":"Mathlib.RingTheory.Kaehler.CotangentComplex","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Extension R S\n⊢ Eq (↑0) 0","decl":"@[simp] lemma H1Cotangent.val_zero : (0 : P.H1Cotangent).1 = 0 := rfl\n"}
{"name":"Algebra.Extension.H1Cotangent.val_smul","module":"Mathlib.RingTheory.Kaehler.CotangentComplex","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nP : Algebra.Extension R S\nR₀ : Type u_1\ninst✝³ : CommRing R₀\ninst✝² : Algebra R₀ S\ninst✝¹ : Module R₀ P.Cotangent\ninst✝ : IsScalarTower R₀ S P.Cotangent\nr : R₀\nx : P.H1Cotangent\n⊢ Eq (↑(HSMul.hSMul r x)) (HSMul.hSMul r ↑x)","decl":"@[simp] lemma H1Cotangent.val_smul {R₀} [CommRing R₀] [Algebra R₀ S] [Module R₀ P.Cotangent]\n    [IsScalarTower R₀ S P.Cotangent] (r : R₀) (x : P.H1Cotangent) : (r • x).1 = r • x.1 := rfl\n\n"}
{"name":"Algebra.Extension.instIsScalarTowerH1CotangentOfCotangent","module":"Mathlib.RingTheory.Kaehler.CotangentComplex","initialProofState":"R : Type u\nS : Type v\ninst✝¹² : CommRing R\ninst✝¹¹ : CommRing S\ninst✝¹⁰ : Algebra R S\nP : Algebra.Extension R S\nR₁ : Type u_1\nR₂ : Type u_2\ninst✝⁹ : CommRing R₁\ninst✝⁸ : CommRing R₂\ninst✝⁷ : Algebra R₁ R₂\ninst✝⁶ : Algebra R₁ S\ninst✝⁵ : Algebra R₂ S\ninst✝⁴ : Module R₁ P.Cotangent\ninst✝³ : IsScalarTower R₁ S P.Cotangent\ninst✝² : Module R₂ P.Cotangent\ninst✝¹ : IsScalarTower R₂ S P.Cotangent\ninst✝ : IsScalarTower R₁ R₂ P.Cotangent\n⊢ IsScalarTower R₁ R₂ P.H1Cotangent","decl":"noncomputable\ninstance {R₁ R₂} [CommRing R₁] [CommRing R₂] [Algebra R₁ R₂]\n    [Algebra R₁ S] [Algebra R₂ S]\n    [Module R₁ P.Cotangent] [IsScalarTower R₁ S P.Cotangent]\n    [Module R₂ P.Cotangent] [IsScalarTower R₂ S P.Cotangent]\n    [IsScalarTower R₁ R₂ P.Cotangent] :\n    IsScalarTower R₁ R₂ P.H1Cotangent := by\n  delta Extension.H1Cotangent; infer_instance\n\n"}
{"name":"Algebra.Extension.subsingleton_h1Cotangent","module":"Mathlib.RingTheory.Kaehler.CotangentComplex","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Extension R S\n⊢ Iff (Subsingleton P.H1Cotangent) (Function.Injective ⇑P.cotangentComplex)","decl":"lemma subsingleton_h1Cotangent (P : Extension R S) :\n    Subsingleton P.H1Cotangent ↔ Function.Injective P.cotangentComplex := by\n  delta Extension.H1Cotangent\n  rw [← LinearMap.ker_eq_bot, Submodule.eq_bot_iff, subsingleton_iff_forall_eq 0, Subtype.forall']\n  simp only [Subtype.ext_iff, Submodule.coe_zero]\n\n"}
{"name":"Algebra.Extension.h1Cotangentι_apply","module":"Mathlib.RingTheory.Kaehler.CotangentComplex","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Extension R S\nself : Subtype fun x => Membership.mem (LinearMap.ker P.cotangentComplex) x\n⊢ Eq (Algebra.Extension.h1Cotangentι self) ↑self","decl":"/-- The inclusion of `H¹(L_{S/R})` into the conormal space of a presentation. -/\n@[simps!] def h1Cotangentι : P.H1Cotangent →ₗ[S] P.Cotangent := Submodule.subtype _\n\n"}
{"name":"Algebra.Extension.h1Cotangentι_injective","module":"Mathlib.RingTheory.Kaehler.CotangentComplex","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Extension R S\n⊢ Function.Injective ⇑Algebra.Extension.h1Cotangentι","decl":"lemma h1Cotangentι_injective : Function.Injective P.h1Cotangentι := Subtype.val_injective\n\n"}
{"name":"Algebra.Extension.h1Cotangentι_ext","module":"Mathlib.RingTheory.Kaehler.CotangentComplex","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Extension R S\nx y : P.H1Cotangent\ne : Eq ↑x ↑y\n⊢ Eq x y","decl":"@[ext] lemma h1Cotangentι_ext (x y : P.H1Cotangent) (e : x.1 = y.1) : x = y := Subtype.ext e\n\n"}
{"name":"Algebra.Extension.h1Cotangentι_ext_iff","module":"Mathlib.RingTheory.Kaehler.CotangentComplex","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Extension R S\nx y : P.H1Cotangent\n⊢ Iff (Eq x y) (Eq ↑x ↑y)","decl":"@[ext] lemma h1Cotangentι_ext (x y : P.H1Cotangent) (e : x.1 = y.1) : x = y := Subtype.ext e\n\n"}
{"name":"Algebra.Extension.H1Cotangent.map_apply_coe","module":"Mathlib.RingTheory.Kaehler.CotangentComplex","initialProofState":"R : Type u\nS : Type v\ninst✝⁹ : CommRing R\ninst✝⁸ : CommRing S\ninst✝⁷ : Algebra R S\nR' : Type u'\nS' : Type v'\ninst✝⁶ : CommRing R'\ninst✝⁵ : CommRing S'\ninst✝⁴ : Algebra R' S'\nP' : Algebra.Extension R' S'\ninst✝³ : Algebra R R'\ninst✝² : Algebra S S'\ninst✝¹ : Algebra R S'\ninst✝ : IsScalarTower R R' S'\nP : Algebra.Extension R S\nf : P.Hom P'\nc : Subtype fun x => Membership.mem (LinearMap.ker P.cotangentComplex) x\n⊢ Eq (↑((Algebra.Extension.H1Cotangent.map f) c)) ((Algebra.Extension.Cotangent.map f) ↑c)","decl":"/--\nThe induced map on the first homology of the (naive) cotangent complex.\n-/\n@[simps!]\nnoncomputable\ndef H1Cotangent.map (f : Hom P P') : P.H1Cotangent →ₗ[S] P'.H1Cotangent := by\n  refine (Cotangent.map f).restrict (p := LinearMap.ker P.cotangentComplex)\n    (q := (LinearMap.ker P'.cotangentComplex).restrictScalars S) fun x hx ↦ ?_\n  simp only [LinearMap.mem_ker, Submodule.restrictScalars_mem] at hx ⊢\n  apply_fun (CotangentSpace.map f) at hx\n  rw [CotangentSpace.map_cotangentComplex] at hx\n  rw [hx]\n  exact LinearMap.map_zero _\n\n"}
{"name":"Algebra.Extension.H1Cotangent.map_eq","module":"Mathlib.RingTheory.Kaehler.CotangentComplex","initialProofState":"R : Type u\nS : Type v\ninst✝¹⁰ : CommRing R\ninst✝⁹ : CommRing S\ninst✝⁸ : Algebra R S\nR' : Type u'\nS' : Type v'\ninst✝⁷ : CommRing R'\ninst✝⁶ : CommRing S'\ninst✝⁵ : Algebra R' S'\nP' : Algebra.Extension R' S'\ninst✝⁴ : Algebra R R'\ninst✝³ : Algebra S S'\ninst✝² : Algebra R S'\ninst✝¹ : IsScalarTower R R' S'\ninst✝ : IsScalarTower R S S'\nP : Algebra.Extension R S\nf g : P.Hom P'\n⊢ Eq (Algebra.Extension.H1Cotangent.map f) (Algebra.Extension.H1Cotangent.map g)","decl":"lemma H1Cotangent.map_eq (f g : Hom P P') : map f = map g := by\n  ext x\n  simp only [map_apply_coe]\n  rw [← sub_eq_zero, ← Cotangent.val_sub, ← LinearMap.sub_apply, Cotangent.map_sub_map]\n  simp only [LinearMap.coe_comp, Function.comp_apply, LinearMap.map_coe_ker, map_zero,\n    Cotangent.val_zero]\n\n"}
{"name":"Algebra.Extension.H1Cotangent.map_id","module":"Mathlib.RingTheory.Kaehler.CotangentComplex","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Extension R S\n⊢ Eq (Algebra.Extension.H1Cotangent.map (Algebra.Extension.Hom.id P)) LinearMap.id","decl":"@[simp] lemma H1Cotangent.map_id : map (.id P) = LinearMap.id := by ext; simp\n\n"}
{"name":"Algebra.Extension.H1Cotangent.map_comp","module":"Mathlib.RingTheory.Kaehler.CotangentComplex","initialProofState":"R : Type u\nS : Type v\ninst✝²² : CommRing R\ninst✝²¹ : CommRing S\ninst✝²⁰ : Algebra R S\nR' : Type u'\nS' : Type v'\ninst✝¹⁹ : CommRing R'\ninst✝¹⁸ : CommRing S'\ninst✝¹⁷ : Algebra R' S'\nP' : Algebra.Extension R' S'\ninst✝¹⁶ : Algebra R R'\ninst✝¹⁵ : Algebra S S'\ninst✝¹⁴ : Algebra R S'\ninst✝¹³ : IsScalarTower R R' S'\nR'' : Type u''\nS'' : Type v''\ninst✝¹² : CommRing R''\ninst✝¹¹ : CommRing S''\ninst✝¹⁰ : Algebra R'' S''\nP'' : Algebra.Extension R'' S''\ninst✝⁹ : Algebra R R''\ninst✝⁸ : Algebra S S''\ninst✝⁷ : Algebra R S''\ninst✝⁶ : IsScalarTower R R'' S''\ninst✝⁵ : Algebra R' R''\ninst✝⁴ : Algebra S' S''\ninst✝³ : Algebra R' S''\ninst✝² : IsScalarTower R' R'' S''\ninst✝¹ : IsScalarTower R R' R''\ninst✝ : IsScalarTower S S' S''\nP : Algebra.Extension R S\nf : P.Hom P'\ng : P'.Hom P''\n⊢ Eq (Algebra.Extension.H1Cotangent.map (g.comp f)) ((↑S (Algebra.Extension.H1Cotangent.map g)).comp (Algebra.Extension.H1Cotangent.map f))","decl":"omit [IsScalarTower R S S'] in\nlemma H1Cotangent.map_comp\n    (f : Hom P P') (g : Hom P' P'') :\n    map (g.comp f) = (map g).restrictScalars S ∘ₗ map f := by\n  ext; simp [Cotangent.map_comp]\n\n"}
{"name":"Algebra.Generators.cotangentSpaceBasis_repr_tmul","module":"Mathlib.RingTheory.Kaehler.CotangentComplex","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Generators R S\nr : S\nx : P.Ring\ni : P.vars\n⊢ Eq ((P.cotangentSpaceBasis.repr (TensorProduct.tmul P.Ring r ((KaehlerDifferential.D R P.Ring) x))) i) (HMul.hMul r ((MvPolynomial.aeval P.val) ((MvPolynomial.pderiv i) x)))","decl":"@[simp]\nlemma cotangentSpaceBasis_repr_tmul (r x i) :\n    P.cotangentSpaceBasis.repr (r ⊗ₜ[P.Ring] KaehlerDifferential.D R P.Ring x : _) i =\n      r * aeval P.val (pderiv i x) := by\n  classical\n  simp only [cotangentSpaceBasis, Basis.baseChange_repr_tmul, mvPolynomialBasis_repr_apply,\n    Algebra.smul_def, mul_comm r, algebraMap_apply, toExtension]\n\n"}
{"name":"Algebra.Generators.cotangentSpaceBasis_repr_one_tmul","module":"Mathlib.RingTheory.Kaehler.CotangentComplex","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Generators R S\nx : P.toExtension.Ring\ni : P.vars\n⊢ Eq ((P.cotangentSpaceBasis.repr (TensorProduct.tmul P.toExtension.Ring 1 ((KaehlerDifferential.D R P.toExtension.Ring) x))) i) ((MvPolynomial.aeval P.val) ((MvPolynomial.pderiv i) x))","decl":"lemma cotangentSpaceBasis_repr_one_tmul (x i) :\n    P.cotangentSpaceBasis.repr (1 ⊗ₜ .D _ _ x) i = aeval P.val (pderiv i x) := by\n  simp\n\n"}
{"name":"Algebra.Generators.cotangentSpaceBasis_apply","module":"Mathlib.RingTheory.Kaehler.CotangentComplex","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Generators R S\ni : P.vars\n⊢ Eq (P.cotangentSpaceBasis i) (TensorProduct.tmul P.Ring 1 ((KaehlerDifferential.D R P.Ring) (MvPolynomial.X i)))","decl":"lemma cotangentSpaceBasis_apply (i) :\n    P.cotangentSpaceBasis i = ((1 : S) ⊗ₜ[P.Ring] D R P.Ring (.X i) :) := by\n  simp [cotangentSpaceBasis, toExtension]\n\n"}
{"name":"Algebra.Generators.instFreeCotangentSpaceToExtension","module":"Mathlib.RingTheory.Kaehler.CotangentComplex","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Generators R S\n⊢ Module.Free S P.toExtension.CotangentSpace","decl":"instance (P : Generators R S) : Module.Free S P.toExtension.CotangentSpace :=\n  .of_basis P.cotangentSpaceBasis\n\n"}
{"name":"Algebra.Generators.repr_CotangentSpaceMap","module":"Mathlib.RingTheory.Kaehler.CotangentComplex","initialProofState":"R : Type u\nS : Type v\ninst✝¹⁰ : CommRing R\ninst✝⁹ : CommRing S\ninst✝⁸ : Algebra R S\nP : Algebra.Generators R S\nR' : Type u'\nS' : Type v'\ninst✝⁷ : CommRing R'\ninst✝⁶ : CommRing S'\ninst✝⁵ : Algebra R' S'\nP' : Algebra.Generators R' S'\ninst✝⁴ : Algebra R R'\ninst✝³ : Algebra S S'\ninst✝² : Algebra R S'\ninst✝¹ : IsScalarTower R R' S'\ninst✝ : IsScalarTower R S S'\nf : P.Hom P'\ni : P.vars\nj : P'.vars\n⊢ Eq ((P'.cotangentSpaceBasis.repr ((Algebra.Extension.CotangentSpace.map f.toExtensionHom) (P.cotangentSpaceBasis i))) j) ((MvPolynomial.aeval P'.val) ((MvPolynomial.pderiv j) (f.val i)))","decl":"@[simp]\nlemma repr_CotangentSpaceMap (f : Hom P P') (i j) :\n    P'.cotangentSpaceBasis.repr (CotangentSpace.map f.toExtensionHom (P.cotangentSpaceBasis i)) j =\n      aeval P'.val (pderiv j (f.val i)) := by\n  rw [cotangentSpaceBasis_apply]\n  simp only [toExtension]\n  rw [CotangentSpace.map_tmul, map_one]\n  erw [cotangentSpaceBasis_repr_one_tmul, Hom.toAlgHom_X]\n\n"}
{"name":"Algebra.Generators.toKaehler_cotangentSpaceBasis","module":"Mathlib.RingTheory.Kaehler.CotangentComplex","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Generators R S\ni : P.vars\n⊢ Eq (P.toExtension.toKaehler (P.cotangentSpaceBasis i)) ((KaehlerDifferential.D R S) (P.val i))","decl":"@[simp]\nlemma toKaehler_cotangentSpaceBasis (i) :\n    P.toExtension.toKaehler (P.cotangentSpaceBasis i) = D R S (P.val i) := by\n  rw [cotangentSpaceBasis_apply]\n  exact (KaehlerDifferential.mapBaseChange_tmul ..).trans (by simp)\n\n"}
{"name":"Algebra.instFinitePresentationKaehlerDifferentialOfFinitePresentation","module":"Mathlib.RingTheory.Kaehler.CotangentComplex","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\ninst✝ : Algebra.FinitePresentation R S\n⊢ Module.FinitePresentation S (KaehlerDifferential R S)","decl":"open KaehlerDifferential in\nattribute [local instance] Module.finitePresentation_of_projective in\ninstance [Algebra.FinitePresentation R S] : Module.FinitePresentation S (Ω[S⁄R]) := by\n  let P := Algebra.Presentation.ofFinitePresentation R S\n  have : Algebra.FiniteType R P.toExtension.Ring := .mvPolynomial _ _\n  refine Module.finitePresentation_of_surjective _ P.toExtension.toKaehler_surjective ?_\n  rw [LinearMap.exact_iff.mp P.toExtension.exact_cotangentComplex_toKaehler, ← Submodule.map_top]\n  exact (Extension.Cotangent.finite P.ideal_fg_of_isFinite).1.map P.toExtension.cotangentComplex\n\n"}
{"name":"Algebra.instFiniteH1CotangentOfFinitePresentationOfProjectiveKaehlerDifferential","module":"Mathlib.RingTheory.Kaehler.CotangentComplex","initialProofState":"R : Type u\nS : Type v\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : Algebra R S\ninst✝¹ : Algebra.FinitePresentation R S\ninst✝ : Module.Projective S (KaehlerDifferential R S)\n⊢ Module.Finite S (Algebra.H1Cotangent R S)","decl":"attribute [local instance] Module.finitePresentation_of_projective in\ninstance [FinitePresentation R S] [Module.Projective S (Ω[S⁄R])] :\n    Module.Finite S (H1Cotangent R S) := by\n  let P := Algebra.Presentation.ofFinitePresentation R S\n  have : Algebra.FiniteType R P.toExtension.Ring := FiniteType.mvPolynomial R P.vars\n  suffices Module.Finite S P.toExtension.H1Cotangent from\n    .of_surjective P.equivH1Cotangent.toLinearMap P.equivH1Cotangent.surjective\n  rw [Module.finite_def, Submodule.fg_top, ← LinearMap.ker_rangeRestrict]\n  have := Extension.Cotangent.finite P.ideal_fg_of_isFinite\n  have : Module.FinitePresentation S (LinearMap.range P.toExtension.cotangentComplex) := by\n    rw [← LinearMap.exact_iff.mp P.toExtension.exact_cotangentComplex_toKaehler]\n    exact Module.finitePresentation_of_projective_of_exact\n      _ _ (Subtype.val_injective) P.toExtension.toKaehler_surjective\n      (LinearMap.exact_subtype_ker_map _)\n  exact Module.FinitePresentation.fg_ker (N := LinearMap.range P.toExtension.cotangentComplex)\n    _ P.toExtension.cotangentComplex.surjective_rangeRestrict\n\n"}
