{"name":"List.prod_nil","module":"Mathlib.Algebra.BigOperators.Group.List.Defs","initialProofState":"M : Type u_4\ninst✝¹ : Mul M\ninst✝ : One M\n⊢ Eq List.nil.prod 1","decl":"@[to_additive existing, simp]\ntheorem prod_nil : ([] : List M).prod = 1 :=\n  rfl\n\n"}
{"name":"List.prod_cons","module":"Mathlib.Algebra.BigOperators.Group.List.Defs","initialProofState":"M : Type u_4\ninst✝¹ : Mul M\ninst✝ : One M\na : M\nl : List M\n⊢ Eq (List.cons a l).prod (HMul.hMul a l.prod)","decl":"@[to_additive existing, simp]\ntheorem prod_cons {a} {l : List M} : (a :: l).prod = a * l.prod := rfl\n\n"}
{"name":"List.sum_induction","module":"Mathlib.Algebra.BigOperators.Group.List.Defs","initialProofState":"M : Type u_4\ninst✝¹ : Add M\ninst✝ : Zero M\nl : List M\np : M → Prop\nhom : ∀ (a b : M), p a → p b → p (HAdd.hAdd a b)\nunit : p 0\nbase : ∀ (x : M), Membership.mem l x → p x\n⊢ p l.sum","decl":"@[to_additive]\nlemma prod_induction\n    (p : M → Prop) (hom : ∀ a b, p a → p b → p (a * b)) (unit : p 1) (base : ∀ x ∈ l, p x) :\n    p l.prod := by\n  induction l with\n  | nil => simpa\n  | cons a l ih =>\n    rw [List.prod_cons]\n    simp only [mem_cons, forall_eq_or_imp] at base\n    exact hom _ _ (base.1) (ih base.2)\n\n"}
{"name":"List.prod_induction","module":"Mathlib.Algebra.BigOperators.Group.List.Defs","initialProofState":"M : Type u_4\ninst✝¹ : Mul M\ninst✝ : One M\nl : List M\np : M → Prop\nhom : ∀ (a b : M), p a → p b → p (HMul.hMul a b)\nunit : p 1\nbase : ∀ (x : M), Membership.mem l x → p x\n⊢ p l.prod","decl":"@[to_additive]\nlemma prod_induction\n    (p : M → Prop) (hom : ∀ a b, p a → p b → p (a * b)) (unit : p 1) (base : ∀ x ∈ l, p x) :\n    p l.prod := by\n  induction l with\n  | nil => simpa\n  | cons a l ih =>\n    rw [List.prod_cons]\n    simp only [mem_cons, forall_eq_or_imp] at base\n    exact hom _ _ (base.1) (ih base.2)\n\n"}
{"name":"List.sum_singleton","module":"Mathlib.Algebra.BigOperators.Group.List.Defs","initialProofState":"M : Type u_4\ninst✝ : AddZeroClass M\na : M\n⊢ Eq (List.cons a List.nil).sum a","decl":"@[to_additive]\ntheorem prod_singleton : [a].prod = a :=\n  mul_one a\n\n"}
{"name":"List.prod_singleton","module":"Mathlib.Algebra.BigOperators.Group.List.Defs","initialProofState":"M : Type u_4\ninst✝ : MulOneClass M\na : M\n⊢ Eq (List.cons a List.nil).prod a","decl":"@[to_additive]\ntheorem prod_singleton : [a].prod = a :=\n  mul_one a\n\n"}
{"name":"List.prod_one_cons","module":"Mathlib.Algebra.BigOperators.Group.List.Defs","initialProofState":"M : Type u_4\ninst✝ : MulOneClass M\nl : List M\n⊢ Eq (List.cons 1 l).prod l.prod","decl":"@[to_additive]\ntheorem prod_one_cons : (1 :: l).prod = l.prod := by\n  rw [prod, foldr, one_mul]\n\n"}
{"name":"List.sum_zero_cons","module":"Mathlib.Algebra.BigOperators.Group.List.Defs","initialProofState":"M : Type u_4\ninst✝ : AddZeroClass M\nl : List M\n⊢ Eq (List.cons 0 l).sum l.sum","decl":"@[to_additive]\ntheorem prod_one_cons : (1 :: l).prod = l.prod := by\n  rw [prod, foldr, one_mul]\n\n"}
{"name":"List.prod_map_one","module":"Mathlib.Algebra.BigOperators.Group.List.Defs","initialProofState":"ι : Type u_1\nM : Type u_4\ninst✝ : MulOneClass M\nl : List ι\n⊢ Eq (List.map (fun x => 1) l).prod 1","decl":"@[to_additive]\ntheorem prod_map_one {l : List ι} :\n    (l.map fun _ => (1 : M)).prod = 1 := by\n  induction l with\n  | nil => rfl\n  | cons hd tl ih => rw [map_cons, prod_one_cons, ih]\n\n"}
{"name":"List.sum_map_zero","module":"Mathlib.Algebra.BigOperators.Group.List.Defs","initialProofState":"ι : Type u_1\nM : Type u_4\ninst✝ : AddZeroClass M\nl : List ι\n⊢ Eq (List.map (fun x => 0) l).sum 0","decl":"@[to_additive]\ntheorem prod_map_one {l : List ι} :\n    (l.map fun _ => (1 : M)).prod = 1 := by\n  induction l with\n  | nil => rfl\n  | cons hd tl ih => rw [map_cons, prod_one_cons, ih]\n\n"}
{"name":"List.sum_eq_foldr","module":"Mathlib.Algebra.BigOperators.Group.List.Defs","initialProofState":"M : Type u_4\ninst✝ : AddMonoid M\nl : List M\n⊢ Eq l.sum (List.foldr (fun x1 x2 => HAdd.hAdd x1 x2) 0 l)","decl":"@[to_additive]\ntheorem prod_eq_foldr {l : List M} : l.prod = foldr (· * ·) 1 l := rfl\n\n"}
{"name":"List.prod_eq_foldr","module":"Mathlib.Algebra.BigOperators.Group.List.Defs","initialProofState":"M : Type u_4\ninst✝ : Monoid M\nl : List M\n⊢ Eq l.prod (List.foldr (fun x1 x2 => HMul.hMul x1 x2) 1 l)","decl":"@[to_additive]\ntheorem prod_eq_foldr {l : List M} : l.prod = foldr (· * ·) 1 l := rfl\n\n"}
{"name":"List.prod_replicate","module":"Mathlib.Algebra.BigOperators.Group.List.Defs","initialProofState":"M : Type u_4\ninst✝ : Monoid M\nn : Nat\na : M\n⊢ Eq (List.replicate n a).prod (HPow.hPow a n)","decl":"@[to_additive (attr := simp)]\ntheorem prod_replicate (n : ℕ) (a : M) : (replicate n a).prod = a ^ n := by\n  induction n with\n  | zero => rw [pow_zero, replicate_zero, prod_nil]\n  | succ n ih => rw [replicate_succ, prod_cons, ih, pow_succ']\n\n"}
{"name":"List.sum_replicate","module":"Mathlib.Algebra.BigOperators.Group.List.Defs","initialProofState":"M : Type u_4\ninst✝ : AddMonoid M\nn : Nat\na : M\n⊢ Eq (List.replicate n a).sum (HSMul.hSMul n a)","decl":"@[to_additive (attr := simp)]\ntheorem prod_replicate (n : ℕ) (a : M) : (replicate n a).prod = a ^ n := by\n  induction n with\n  | zero => rw [pow_zero, replicate_zero, prod_nil]\n  | succ n ih => rw [replicate_succ, prod_cons, ih, pow_succ']\n\n"}
{"name":"List.prod_eq_pow_card","module":"Mathlib.Algebra.BigOperators.Group.List.Defs","initialProofState":"M : Type u_4\ninst✝ : Monoid M\nl : List M\nm : M\nh : ∀ (x : M), Membership.mem l x → Eq x m\n⊢ Eq l.prod (HPow.hPow m l.length)","decl":"@[to_additive sum_eq_card_nsmul]\ntheorem prod_eq_pow_card (l : List M) (m : M) (h : ∀ x ∈ l, x = m) : l.prod = m ^ l.length := by\n  rw [← prod_replicate, ← List.eq_replicate_iff.mpr ⟨rfl, h⟩]\n\n"}
{"name":"List.sum_eq_card_nsmul","module":"Mathlib.Algebra.BigOperators.Group.List.Defs","initialProofState":"M : Type u_4\ninst✝ : AddMonoid M\nl : List M\nm : M\nh : ∀ (x : M), Membership.mem l x → Eq x m\n⊢ Eq l.sum (HSMul.hSMul l.length m)","decl":"@[to_additive sum_eq_card_nsmul]\ntheorem prod_eq_pow_card (l : List M) (m : M) (h : ∀ x ∈ l, x = m) : l.prod = m ^ l.length := by\n  rw [← prod_replicate, ← List.eq_replicate_iff.mpr ⟨rfl, h⟩]\n\n"}
{"name":"List.prod_hom_rel","module":"Mathlib.Algebra.BigOperators.Group.List.Defs","initialProofState":"ι : Type u_1\nM : Type u_4\nN : Type u_5\ninst✝¹ : Monoid M\ninst✝ : Monoid N\nl : List ι\nr : M → N → Prop\nf : ι → M\ng : ι → N\nh₁ : r 1 1\nh₂ : ∀ ⦃i : ι⦄ ⦃a : M⦄ ⦃b : N⦄, r a b → r (HMul.hMul (f i) a) (HMul.hMul (g i) b)\n⊢ r (List.map f l).prod (List.map g l).prod","decl":"@[to_additive]\ntheorem prod_hom_rel (l : List ι) {r : M → N → Prop} {f : ι → M} {g : ι → N} (h₁ : r 1 1)\n    (h₂ : ∀ ⦃i a b⦄, r a b → r (f i * a) (g i * b)) : r (l.map f).prod (l.map g).prod :=\n  List.recOn l h₁ fun a l hl => by simp only [map_cons, prod_cons, h₂ hl]\n\n"}
{"name":"List.sum_hom_rel","module":"Mathlib.Algebra.BigOperators.Group.List.Defs","initialProofState":"ι : Type u_1\nM : Type u_4\nN : Type u_5\ninst✝¹ : AddMonoid M\ninst✝ : AddMonoid N\nl : List ι\nr : M → N → Prop\nf : ι → M\ng : ι → N\nh₁ : r 0 0\nh₂ : ∀ ⦃i : ι⦄ ⦃a : M⦄ ⦃b : N⦄, r a b → r (HAdd.hAdd (f i) a) (HAdd.hAdd (g i) b)\n⊢ r (List.map f l).sum (List.map g l).sum","decl":"@[to_additive]\ntheorem prod_hom_rel (l : List ι) {r : M → N → Prop} {f : ι → M} {g : ι → N} (h₁ : r 1 1)\n    (h₂ : ∀ ⦃i a b⦄, r a b → r (f i * a) (g i * b)) : r (l.map f).prod (l.map g).prod :=\n  List.recOn l h₁ fun a l hl => by simp only [map_cons, prod_cons, h₂ hl]\n\n"}
