{"name":"TensorProduct.LieModule.lieModule","module":"Mathlib.Algebra.Lie.TensorProduct","initialProofState":"R : Type u\ninst✝¹⁰ : CommRing R\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁹ : LieRing L\ninst✝⁸ : LieAlgebra R L\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : LieRingModule L M\ninst✝⁴ : LieModule R L M\ninst✝³ : AddCommGroup N\ninst✝² : Module R N\ninst✝¹ : LieRingModule L N\ninst✝ : LieModule R L N\n⊢ LieModule R L (TensorProduct R M N)","decl":"/-- The tensor product of two Lie modules is a Lie module. -/\ninstance lieModule : LieModule R L (M ⊗[R] N) where\n  smul_lie c x t := by\n    change hasBracketAux (c • x) _ = c • hasBracketAux _ _\n    simp only [hasBracketAux, smul_add, LinearMap.rTensor_smul, LinearMap.smul_apply,\n      LinearMap.lTensor_smul, LieHom.map_smul, LinearMap.add_apply]\n  lie_smul c _ := LinearMap.map_smul _ c\n\n"}
{"name":"TensorProduct.LieModule.lie_tmul_right","module":"Mathlib.Algebra.Lie.TensorProduct","initialProofState":"R : Type u\ninst✝¹⁰ : CommRing R\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁹ : LieRing L\ninst✝⁸ : LieAlgebra R L\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : LieRingModule L M\ninst✝⁴ : LieModule R L M\ninst✝³ : AddCommGroup N\ninst✝² : Module R N\ninst✝¹ : LieRingModule L N\ninst✝ : LieModule R L N\nx : L\nm : M\nn : N\n⊢ Eq (Bracket.bracket x (TensorProduct.tmul R m n)) (HAdd.hAdd (TensorProduct.tmul R (Bracket.bracket x m) n) (TensorProduct.tmul R m (Bracket.bracket x n)))","decl":"@[simp]\ntheorem lie_tmul_right (x : L) (m : M) (n : N) : ⁅x, m ⊗ₜ[R] n⁆ = ⁅x, m⁆ ⊗ₜ n + m ⊗ₜ ⁅x, n⁆ :=\n  show hasBracketAux x (m ⊗ₜ[R] n) = _ by\n    simp only [hasBracketAux, LinearMap.rTensor_tmul, toEnd_apply_apply,\n      LinearMap.add_apply, LinearMap.lTensor_tmul]\n\n"}
{"name":"TensorProduct.LieModule.lift_apply","module":"Mathlib.Algebra.Lie.TensorProduct","initialProofState":"R : Type u\ninst✝¹⁴ : CommRing R\nL : Type v\nM : Type w\nN : Type w₁\nP : Type w₂\ninst✝¹³ : LieRing L\ninst✝¹² : LieAlgebra R L\ninst✝¹¹ : AddCommGroup M\ninst✝¹⁰ : Module R M\ninst✝⁹ : LieRingModule L M\ninst✝⁸ : LieModule R L M\ninst✝⁷ : AddCommGroup N\ninst✝⁶ : Module R N\ninst✝⁵ : LieRingModule L N\ninst✝⁴ : LieModule R L N\ninst✝³ : AddCommGroup P\ninst✝² : Module R P\ninst✝¹ : LieRingModule L P\ninst✝ : LieModule R L P\nf : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) N P)\nm : M\nn : N\n⊢ Eq (((TensorProduct.LieModule.lift R L M N P) f) (TensorProduct.tmul R m n)) ((f m) n)","decl":"@[simp]\ntheorem lift_apply (f : M →ₗ[R] N →ₗ[R] P) (m : M) (n : N) : lift R L M N P f (m ⊗ₜ n) = f m n :=\n  rfl\n\n"}
{"name":"TensorProduct.LieModule.coe_liftLie_eq_lift_coe","module":"Mathlib.Algebra.Lie.TensorProduct","initialProofState":"R : Type u\ninst✝¹⁴ : CommRing R\nL : Type v\nM : Type w\nN : Type w₁\nP : Type w₂\ninst✝¹³ : LieRing L\ninst✝¹² : LieAlgebra R L\ninst✝¹¹ : AddCommGroup M\ninst✝¹⁰ : Module R M\ninst✝⁹ : LieRingModule L M\ninst✝⁸ : LieModule R L M\ninst✝⁷ : AddCommGroup N\ninst✝⁶ : Module R N\ninst✝⁵ : LieRingModule L N\ninst✝⁴ : LieModule R L N\ninst✝³ : AddCommGroup P\ninst✝² : Module R P\ninst✝¹ : LieRingModule L P\ninst✝ : LieModule R L P\nf : LieModuleHom R L M (LinearMap (RingHom.id R) N P)\n⊢ Eq ⇑((TensorProduct.LieModule.liftLie R L M N P) f) ⇑((TensorProduct.LieModule.lift R L M N P) ↑f)","decl":"@[simp]\ntheorem coe_liftLie_eq_lift_coe (f : M →ₗ⁅R,L⁆ N →ₗ[R] P) :\n    ⇑(liftLie R L M N P f) = lift R L M N P f := by\n  suffices (liftLie R L M N P f : M ⊗[R] N →ₗ[R] P) = lift R L M N P f by\n    rw [← this, LieModuleHom.coe_toLinearMap]\n  ext m n\n  simp only [liftLie, LinearEquiv.trans_apply, LieModuleEquiv.coe_toLinearEquiv,\n    toLinearMap_maxTrivLinearMapEquivLieModuleHom, coe_maxTrivEquiv_apply,\n    toLinearMap_maxTrivLinearMapEquivLieModuleHom_symm]\n\n"}
{"name":"TensorProduct.LieModule.liftLie_apply","module":"Mathlib.Algebra.Lie.TensorProduct","initialProofState":"R : Type u\ninst✝¹⁴ : CommRing R\nL : Type v\nM : Type w\nN : Type w₁\nP : Type w₂\ninst✝¹³ : LieRing L\ninst✝¹² : LieAlgebra R L\ninst✝¹¹ : AddCommGroup M\ninst✝¹⁰ : Module R M\ninst✝⁹ : LieRingModule L M\ninst✝⁸ : LieModule R L M\ninst✝⁷ : AddCommGroup N\ninst✝⁶ : Module R N\ninst✝⁵ : LieRingModule L N\ninst✝⁴ : LieModule R L N\ninst✝³ : AddCommGroup P\ninst✝² : Module R P\ninst✝¹ : LieRingModule L P\ninst✝ : LieModule R L P\nf : LieModuleHom R L M (LinearMap (RingHom.id R) N P)\nm : M\nn : N\n⊢ Eq (((TensorProduct.LieModule.liftLie R L M N P) f) (TensorProduct.tmul R m n)) ((f m) n)","decl":"theorem liftLie_apply (f : M →ₗ⁅R,L⁆ N →ₗ[R] P) (m : M) (n : N) :\n    liftLie R L M N P f (m ⊗ₜ n) = f m n := by\n  simp only [coe_liftLie_eq_lift_coe, LieModuleHom.coe_toLinearMap, lift_apply]\n\n"}
{"name":"TensorProduct.LieModule.toLinearMap_map","module":"Mathlib.Algebra.Lie.TensorProduct","initialProofState":"R : Type u\ninst✝¹⁸ : CommRing R\nL : Type v\nM : Type w\nN : Type w₁\nP : Type w₂\nQ : Type w₃\ninst✝¹⁷ : LieRing L\ninst✝¹⁶ : LieAlgebra R L\ninst✝¹⁵ : AddCommGroup M\ninst✝¹⁴ : Module R M\ninst✝¹³ : LieRingModule L M\ninst✝¹² : LieModule R L M\ninst✝¹¹ : AddCommGroup N\ninst✝¹⁰ : Module R N\ninst✝⁹ : LieRingModule L N\ninst✝⁸ : LieModule R L N\ninst✝⁷ : AddCommGroup P\ninst✝⁶ : Module R P\ninst✝⁵ : LieRingModule L P\ninst✝⁴ : LieModule R L P\ninst✝³ : AddCommGroup Q\ninst✝² : Module R Q\ninst✝¹ : LieRingModule L Q\ninst✝ : LieModule R L Q\nf : LieModuleHom R L M P\ng : LieModuleHom R L N Q\n⊢ Eq (↑(TensorProduct.LieModule.map f g)) (TensorProduct.map ↑f ↑g)","decl":"@[simp]\ntheorem toLinearMap_map (f : M →ₗ⁅R,L⁆ P) (g : N →ₗ⁅R,L⁆ Q) :\n    (map f g : M ⊗[R] N →ₗ[R] P ⊗[R] Q) = TensorProduct.map (f : M →ₗ[R] P) (g : N →ₗ[R] Q) :=\n  rfl\n\n"}
{"name":"TensorProduct.LieModule.coe_linearMap_map","module":"Mathlib.Algebra.Lie.TensorProduct","initialProofState":"R : Type u\ninst✝¹⁸ : CommRing R\nL : Type v\nM : Type w\nN : Type w₁\nP : Type w₂\nQ : Type w₃\ninst✝¹⁷ : LieRing L\ninst✝¹⁶ : LieAlgebra R L\ninst✝¹⁵ : AddCommGroup M\ninst✝¹⁴ : Module R M\ninst✝¹³ : LieRingModule L M\ninst✝¹² : LieModule R L M\ninst✝¹¹ : AddCommGroup N\ninst✝¹⁰ : Module R N\ninst✝⁹ : LieRingModule L N\ninst✝⁸ : LieModule R L N\ninst✝⁷ : AddCommGroup P\ninst✝⁶ : Module R P\ninst✝⁵ : LieRingModule L P\ninst✝⁴ : LieModule R L P\ninst✝³ : AddCommGroup Q\ninst✝² : Module R Q\ninst✝¹ : LieRingModule L Q\ninst✝ : LieModule R L Q\nf : LieModuleHom R L M P\ng : LieModuleHom R L N Q\n⊢ Eq (↑(TensorProduct.LieModule.map f g)) (TensorProduct.map ↑f ↑g)","decl":"@[deprecated (since := \"2024-12-30\")] alias coe_linearMap_map := toLinearMap_map\n\n"}
{"name":"TensorProduct.LieModule.map_tmul","module":"Mathlib.Algebra.Lie.TensorProduct","initialProofState":"R : Type u\ninst✝¹⁸ : CommRing R\nL : Type v\nM : Type w\nN : Type w₁\nP : Type w₂\nQ : Type w₃\ninst✝¹⁷ : LieRing L\ninst✝¹⁶ : LieAlgebra R L\ninst✝¹⁵ : AddCommGroup M\ninst✝¹⁴ : Module R M\ninst✝¹³ : LieRingModule L M\ninst✝¹² : LieModule R L M\ninst✝¹¹ : AddCommGroup N\ninst✝¹⁰ : Module R N\ninst✝⁹ : LieRingModule L N\ninst✝⁸ : LieModule R L N\ninst✝⁷ : AddCommGroup P\ninst✝⁶ : Module R P\ninst✝⁵ : LieRingModule L P\ninst✝⁴ : LieModule R L P\ninst✝³ : AddCommGroup Q\ninst✝² : Module R Q\ninst✝¹ : LieRingModule L Q\ninst✝ : LieModule R L Q\nf : LieModuleHom R L M P\ng : LieModuleHom R L N Q\nm : M\nn : N\n⊢ Eq ((TensorProduct.LieModule.map f g) (TensorProduct.tmul R m n)) (TensorProduct.tmul R (f m) (g n))","decl":"@[simp]\nnonrec theorem map_tmul (f : M →ₗ⁅R,L⁆ P) (g : N →ₗ⁅R,L⁆ Q) (m : M) (n : N) :\n    map f g (m ⊗ₜ n) = f m ⊗ₜ g n :=\n  map_tmul _ _ _ _\n\n"}
{"name":"TensorProduct.LieModule.mapIncl_def","module":"Mathlib.Algebra.Lie.TensorProduct","initialProofState":"R : Type u\ninst✝¹⁰ : CommRing R\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁹ : LieRing L\ninst✝⁸ : LieAlgebra R L\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : LieRingModule L M\ninst✝⁴ : LieModule R L M\ninst✝³ : AddCommGroup N\ninst✝² : Module R N\ninst✝¹ : LieRingModule L N\ninst✝ : LieModule R L N\nM' : LieSubmodule R L M\nN' : LieSubmodule R L N\n⊢ Eq (TensorProduct.LieModule.mapIncl M' N') (TensorProduct.LieModule.map M'.incl N'.incl)","decl":"@[simp]\ntheorem mapIncl_def (M' : LieSubmodule R L M) (N' : LieSubmodule R L N) :\n    mapIncl M' N' = map M'.incl N'.incl :=\n  rfl\n\n"}
{"name":"LieModule.toModuleHom_apply","module":"Mathlib.Algebra.Lie.TensorProduct","initialProofState":"R : Type u\ninst✝⁶ : CommRing R\nL : Type v\nM : Type w\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nx : L\nm : M\n⊢ Eq ((LieModule.toModuleHom R L M) (TensorProduct.tmul R x m)) (Bracket.bracket x m)","decl":"@[simp]\ntheorem toModuleHom_apply (x : L) (m : M) : toModuleHom R L M (x ⊗ₜ m) = ⁅x, m⁆ := by\n  simp only [toModuleHom, TensorProduct.LieModule.liftLie_apply, LieModuleHom.coe_mk,\n    LinearMap.coe_mk, LinearMap.coe_toAddHom, LieHom.coe_toLinearMap, toEnd_apply_apply]\n\n"}
{"name":"LieSubmodule.lieIdeal_oper_eq_tensor_map_range","module":"Mathlib.Algebra.Lie.TensorProduct","initialProofState":"R : Type u\ninst✝⁶ : CommRing R\nL : Type v\nM : Type w\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nI : LieIdeal R L\nN : LieSubmodule R L M\n⊢ Eq (Bracket.bracket I N) ((LieModule.toModuleHom R L M).comp (TensorProduct.LieModule.mapIncl I N)).range","decl":"/-- A useful alternative characterisation of Lie ideal operations on Lie submodules.\n\nGiven a Lie ideal `I ⊆ L` and a Lie submodule `N ⊆ M`, by tensoring the inclusion maps and then\napplying the action of `L` on `M`, we obtain morphism of Lie modules `f : I ⊗ N → L ⊗ M → M`.\n\nThis lemma states that `⁅I, N⁆ = range f`. -/\ntheorem lieIdeal_oper_eq_tensor_map_range :\n    ⁅I, N⁆ = ((toModuleHom R L M).comp (mapIncl I N : I ⊗[R] N →ₗ⁅R,L⁆ L ⊗[R] M)).range := by\n  rw [← toSubmodule_inj, lieIdeal_oper_eq_linear_span, LieModuleHom.toSubmodule_range,\n    LieModuleHom.toLinearMap_comp, LinearMap.range_comp, mapIncl_def, toLinearMap_map,\n    TensorProduct.map_range_eq_span_tmul, Submodule.map_span]\n  congr; ext m; constructor\n  · rintro ⟨⟨x, hx⟩, ⟨n, hn⟩, rfl⟩; use x ⊗ₜ n; constructor\n    · use ⟨x, hx⟩, ⟨n, hn⟩; rfl\n    · simp\n  · rintro ⟨t, ⟨⟨x, hx⟩, ⟨n, hn⟩, rfl⟩, h⟩; rw [← h]; use ⟨x, hx⟩, ⟨n, hn⟩; rfl\n\n"}
