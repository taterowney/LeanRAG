{"name":"ContDiffBump.rIn_pos","module":"Mathlib.Analysis.Calculus.BumpFunction.Basic","initialProofState":"E : Type u_1\nc : E\nself : ContDiffBump c\n⊢ LT.lt 0 self.rIn","decl":"/-- `f : ContDiffBump c`, where `c` is a point in a normed vector space, is a\nbundled smooth function such that\n\n- `f` is equal to `1` in `Metric.closedBall c f.rIn`;\n- `support f = Metric.ball c f.rOut`;\n- `0 ≤ f x ≤ 1` for all `x`.\n\nThe structure `ContDiffBump` contains the data required to construct the function:\nreal numbers `rIn`, `rOut`, and proofs of `0 < rIn < rOut`. The function itself is available through\n`CoeFun` when the space is nice enough, i.e., satisfies the `HasContDiffBump` typeclass. -/\nstructure ContDiffBump (c : E) where\n  /-- real numbers `0 < rIn < rOut` -/\n  (rIn rOut : ℝ)\n  rIn_pos : 0 < rIn\n  rIn_lt_rOut : rIn < rOut\n\n"}
{"name":"ContDiffBump.mk.injEq","module":"Mathlib.Analysis.Calculus.BumpFunction.Basic","initialProofState":"E : Type u_1\nc : E\nrIn✝ rOut✝ : Real\nrIn_pos✝ : LT.lt 0 rIn✝\nrIn_lt_rOut✝ : LT.lt rIn✝ rOut✝\nrIn rOut : Real\nrIn_pos : LT.lt 0 rIn\nrIn_lt_rOut : LT.lt rIn rOut\n⊢ Eq (Eq { rIn := rIn✝, rOut := rOut✝, rIn_pos := rIn_pos✝, rIn_lt_rOut := rIn_lt_rOut✝ } { rIn := rIn, rOut := rOut, rIn_pos := rIn_pos, rIn_lt_rOut := rIn_lt_rOut }) (And (Eq rIn✝ rIn) (Eq rOut✝ rOut))","decl":"/-- `f : ContDiffBump c`, where `c` is a point in a normed vector space, is a\nbundled smooth function such that\n\n- `f` is equal to `1` in `Metric.closedBall c f.rIn`;\n- `support f = Metric.ball c f.rOut`;\n- `0 ≤ f x ≤ 1` for all `x`.\n\nThe structure `ContDiffBump` contains the data required to construct the function:\nreal numbers `rIn`, `rOut`, and proofs of `0 < rIn < rOut`. The function itself is available through\n`CoeFun` when the space is nice enough, i.e., satisfies the `HasContDiffBump` typeclass. -/\nstructure ContDiffBump (c : E) where\n  /-- real numbers `0 < rIn < rOut` -/\n  (rIn rOut : ℝ)\n  rIn_pos : 0 < rIn\n  rIn_lt_rOut : rIn < rOut\n\n"}
{"name":"ContDiffBump.mk.sizeOf_spec","module":"Mathlib.Analysis.Calculus.BumpFunction.Basic","initialProofState":"E : Type u_1\nc : E\ninst✝ : SizeOf E\nrIn rOut : Real\nrIn_pos : LT.lt 0 rIn\nrIn_lt_rOut : LT.lt rIn rOut\n⊢ Eq (SizeOf.sizeOf { rIn := rIn, rOut := rOut, rIn_pos := rIn_pos, rIn_lt_rOut := rIn_lt_rOut }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf rIn)) (SizeOf.sizeOf rOut)) (SizeOf.sizeOf rIn_pos)) (SizeOf.sizeOf rIn_lt_rOut))","decl":"/-- `f : ContDiffBump c`, where `c` is a point in a normed vector space, is a\nbundled smooth function such that\n\n- `f` is equal to `1` in `Metric.closedBall c f.rIn`;\n- `support f = Metric.ball c f.rOut`;\n- `0 ≤ f x ≤ 1` for all `x`.\n\nThe structure `ContDiffBump` contains the data required to construct the function:\nreal numbers `rIn`, `rOut`, and proofs of `0 < rIn < rOut`. The function itself is available through\n`CoeFun` when the space is nice enough, i.e., satisfies the `HasContDiffBump` typeclass. -/\nstructure ContDiffBump (c : E) where\n  /-- real numbers `0 < rIn < rOut` -/\n  (rIn rOut : ℝ)\n  rIn_pos : 0 < rIn\n  rIn_lt_rOut : rIn < rOut\n\n"}
{"name":"ContDiffBump.mk.inj","module":"Mathlib.Analysis.Calculus.BumpFunction.Basic","initialProofState":"E : Type u_1\nc : E\nrIn✝ rOut✝ : Real\nrIn_pos✝ : LT.lt 0 rIn✝\nrIn_lt_rOut✝ : LT.lt rIn✝ rOut✝\nrIn rOut : Real\nrIn_pos : LT.lt 0 rIn\nrIn_lt_rOut : LT.lt rIn rOut\nx✝ : Eq { rIn := rIn✝, rOut := rOut✝, rIn_pos := rIn_pos✝, rIn_lt_rOut := rIn_lt_rOut✝ } { rIn := rIn, rOut := rOut, rIn_pos := rIn_pos, rIn_lt_rOut := rIn_lt_rOut }\n⊢ And (Eq rIn✝ rIn) (Eq rOut✝ rOut)","decl":"/-- `f : ContDiffBump c`, where `c` is a point in a normed vector space, is a\nbundled smooth function such that\n\n- `f` is equal to `1` in `Metric.closedBall c f.rIn`;\n- `support f = Metric.ball c f.rOut`;\n- `0 ≤ f x ≤ 1` for all `x`.\n\nThe structure `ContDiffBump` contains the data required to construct the function:\nreal numbers `rIn`, `rOut`, and proofs of `0 < rIn < rOut`. The function itself is available through\n`CoeFun` when the space is nice enough, i.e., satisfies the `HasContDiffBump` typeclass. -/\nstructure ContDiffBump (c : E) where\n  /-- real numbers `0 < rIn < rOut` -/\n  (rIn rOut : ℝ)\n  rIn_pos : 0 < rIn\n  rIn_lt_rOut : rIn < rOut\n\n"}
{"name":"ContDiffBump.rIn_lt_rOut","module":"Mathlib.Analysis.Calculus.BumpFunction.Basic","initialProofState":"E : Type u_1\nc : E\nself : ContDiffBump c\n⊢ LT.lt self.rIn self.rOut","decl":"/-- `f : ContDiffBump c`, where `c` is a point in a normed vector space, is a\nbundled smooth function such that\n\n- `f` is equal to `1` in `Metric.closedBall c f.rIn`;\n- `support f = Metric.ball c f.rOut`;\n- `0 ≤ f x ≤ 1` for all `x`.\n\nThe structure `ContDiffBump` contains the data required to construct the function:\nreal numbers `rIn`, `rOut`, and proofs of `0 < rIn < rOut`. The function itself is available through\n`CoeFun` when the space is nice enough, i.e., satisfies the `HasContDiffBump` typeclass. -/\nstructure ContDiffBump (c : E) where\n  /-- real numbers `0 < rIn < rOut` -/\n  (rIn rOut : ℝ)\n  rIn_pos : 0 < rIn\n  rIn_lt_rOut : rIn < rOut\n\n"}
{"name":"ContDiffBumpBase.symmetric","module":"Mathlib.Analysis.Calculus.BumpFunction.Basic","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nself : ContDiffBumpBase E\nR : Real\nx : E\n⊢ Eq (self.toFun R (Neg.neg x)) (self.toFun R x)","decl":"/-- The base function from which one will construct a family of bump functions. One could\nadd more properties if they are useful and satisfied in the examples of inner product spaces\nand finite dimensional vector spaces, notably derivative norm control in terms of `R - 1`.\n\nTODO: do we ever need `f x = 1 ↔ ‖x‖ ≤ 1`? -/\nstructure ContDiffBumpBase (E : Type*) [NormedAddCommGroup E] [NormedSpace ℝ E] where\n  /-- The function underlying this family of bump functions -/\n  toFun : ℝ → E → ℝ\n  mem_Icc : ∀ (R : ℝ) (x : E), toFun R x ∈ Icc (0 : ℝ) 1\n  symmetric : ∀ (R : ℝ) (x : E), toFun R (-x) = toFun R x\n  smooth : ContDiffOn ℝ ∞ (uncurry toFun) (Ioi (1 : ℝ) ×ˢ (univ : Set E))\n  eq_one : ∀ R : ℝ, 1 < R → ∀ x : E, ‖x‖ ≤ 1 → toFun R x = 1\n  support : ∀ R : ℝ, 1 < R → Function.support (toFun R) = Metric.ball (0 : E) R\n\n"}
{"name":"ContDiffBumpBase.mem_Icc","module":"Mathlib.Analysis.Calculus.BumpFunction.Basic","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nself : ContDiffBumpBase E\nR : Real\nx : E\n⊢ Membership.mem (Set.Icc 0 1) (self.toFun R x)","decl":"/-- The base function from which one will construct a family of bump functions. One could\nadd more properties if they are useful and satisfied in the examples of inner product spaces\nand finite dimensional vector spaces, notably derivative norm control in terms of `R - 1`.\n\nTODO: do we ever need `f x = 1 ↔ ‖x‖ ≤ 1`? -/\nstructure ContDiffBumpBase (E : Type*) [NormedAddCommGroup E] [NormedSpace ℝ E] where\n  /-- The function underlying this family of bump functions -/\n  toFun : ℝ → E → ℝ\n  mem_Icc : ∀ (R : ℝ) (x : E), toFun R x ∈ Icc (0 : ℝ) 1\n  symmetric : ∀ (R : ℝ) (x : E), toFun R (-x) = toFun R x\n  smooth : ContDiffOn ℝ ∞ (uncurry toFun) (Ioi (1 : ℝ) ×ˢ (univ : Set E))\n  eq_one : ∀ R : ℝ, 1 < R → ∀ x : E, ‖x‖ ≤ 1 → toFun R x = 1\n  support : ∀ R : ℝ, 1 < R → Function.support (toFun R) = Metric.ball (0 : E) R\n\n"}
{"name":"ContDiffBumpBase.support","module":"Mathlib.Analysis.Calculus.BumpFunction.Basic","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nself : ContDiffBumpBase E\nR : Real\na✝ : LT.lt 1 R\n⊢ Eq (Function.support (self.toFun R)) (Metric.ball 0 R)","decl":"/-- The base function from which one will construct a family of bump functions. One could\nadd more properties if they are useful and satisfied in the examples of inner product spaces\nand finite dimensional vector spaces, notably derivative norm control in terms of `R - 1`.\n\nTODO: do we ever need `f x = 1 ↔ ‖x‖ ≤ 1`? -/\nstructure ContDiffBumpBase (E : Type*) [NormedAddCommGroup E] [NormedSpace ℝ E] where\n  /-- The function underlying this family of bump functions -/\n  toFun : ℝ → E → ℝ\n  mem_Icc : ∀ (R : ℝ) (x : E), toFun R x ∈ Icc (0 : ℝ) 1\n  symmetric : ∀ (R : ℝ) (x : E), toFun R (-x) = toFun R x\n  smooth : ContDiffOn ℝ ∞ (uncurry toFun) (Ioi (1 : ℝ) ×ˢ (univ : Set E))\n  eq_one : ∀ R : ℝ, 1 < R → ∀ x : E, ‖x‖ ≤ 1 → toFun R x = 1\n  support : ∀ R : ℝ, 1 < R → Function.support (toFun R) = Metric.ball (0 : E) R\n\n"}
{"name":"ContDiffBumpBase.eq_one","module":"Mathlib.Analysis.Calculus.BumpFunction.Basic","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nself : ContDiffBumpBase E\nR : Real\na✝¹ : LT.lt 1 R\nx : E\na✝ : LE.le (Norm.norm x) 1\n⊢ Eq (self.toFun R x) 1","decl":"/-- The base function from which one will construct a family of bump functions. One could\nadd more properties if they are useful and satisfied in the examples of inner product spaces\nand finite dimensional vector spaces, notably derivative norm control in terms of `R - 1`.\n\nTODO: do we ever need `f x = 1 ↔ ‖x‖ ≤ 1`? -/\nstructure ContDiffBumpBase (E : Type*) [NormedAddCommGroup E] [NormedSpace ℝ E] where\n  /-- The function underlying this family of bump functions -/\n  toFun : ℝ → E → ℝ\n  mem_Icc : ∀ (R : ℝ) (x : E), toFun R x ∈ Icc (0 : ℝ) 1\n  symmetric : ∀ (R : ℝ) (x : E), toFun R (-x) = toFun R x\n  smooth : ContDiffOn ℝ ∞ (uncurry toFun) (Ioi (1 : ℝ) ×ˢ (univ : Set E))\n  eq_one : ∀ R : ℝ, 1 < R → ∀ x : E, ‖x‖ ≤ 1 → toFun R x = 1\n  support : ∀ R : ℝ, 1 < R → Function.support (toFun R) = Metric.ball (0 : E) R\n\n"}
{"name":"ContDiffBumpBase.mk.sizeOf_spec","module":"Mathlib.Analysis.Calculus.BumpFunction.Basic","initialProofState":"E : Type u_3\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : SizeOf E\ntoFun : Real → E → Real\nmem_Icc : ∀ (R : Real) (x : E), Membership.mem (Set.Icc 0 1) (toFun R x)\nsymmetric : ∀ (R : Real) (x : E), Eq (toFun R (Neg.neg x)) (toFun R x)\nsmooth : ContDiffOn Real (↑Top.top) (Function.uncurry toFun) (SProd.sprod (Set.Ioi 1) Set.univ)\neq_one : ∀ (R : Real), LT.lt 1 R → ∀ (x : E), LE.le (Norm.norm x) 1 → Eq (toFun R x) 1\nsupport : ∀ (R : Real), LT.lt 1 R → Eq (Function.support (toFun R)) (Metric.ball 0 R)\n⊢ Eq (SizeOf.sizeOf { toFun := toFun, mem_Icc := mem_Icc, symmetric := symmetric, smooth := smooth, eq_one := eq_one, support := support }) 1","decl":"/-- The base function from which one will construct a family of bump functions. One could\nadd more properties if they are useful and satisfied in the examples of inner product spaces\nand finite dimensional vector spaces, notably derivative norm control in terms of `R - 1`.\n\nTODO: do we ever need `f x = 1 ↔ ‖x‖ ≤ 1`? -/\nstructure ContDiffBumpBase (E : Type*) [NormedAddCommGroup E] [NormedSpace ℝ E] where\n  /-- The function underlying this family of bump functions -/\n  toFun : ℝ → E → ℝ\n  mem_Icc : ∀ (R : ℝ) (x : E), toFun R x ∈ Icc (0 : ℝ) 1\n  symmetric : ∀ (R : ℝ) (x : E), toFun R (-x) = toFun R x\n  smooth : ContDiffOn ℝ ∞ (uncurry toFun) (Ioi (1 : ℝ) ×ˢ (univ : Set E))\n  eq_one : ∀ R : ℝ, 1 < R → ∀ x : E, ‖x‖ ≤ 1 → toFun R x = 1\n  support : ∀ R : ℝ, 1 < R → Function.support (toFun R) = Metric.ball (0 : E) R\n\n"}
{"name":"ContDiffBumpBase.smooth","module":"Mathlib.Analysis.Calculus.BumpFunction.Basic","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nself : ContDiffBumpBase E\n⊢ ContDiffOn Real (↑Top.top) (Function.uncurry self.toFun) (SProd.sprod (Set.Ioi 1) Set.univ)","decl":"/-- The base function from which one will construct a family of bump functions. One could\nadd more properties if they are useful and satisfied in the examples of inner product spaces\nand finite dimensional vector spaces, notably derivative norm control in terms of `R - 1`.\n\nTODO: do we ever need `f x = 1 ↔ ‖x‖ ≤ 1`? -/\nstructure ContDiffBumpBase (E : Type*) [NormedAddCommGroup E] [NormedSpace ℝ E] where\n  /-- The function underlying this family of bump functions -/\n  toFun : ℝ → E → ℝ\n  mem_Icc : ∀ (R : ℝ) (x : E), toFun R x ∈ Icc (0 : ℝ) 1\n  symmetric : ∀ (R : ℝ) (x : E), toFun R (-x) = toFun R x\n  smooth : ContDiffOn ℝ ∞ (uncurry toFun) (Ioi (1 : ℝ) ×ˢ (univ : Set E))\n  eq_one : ∀ R : ℝ, 1 < R → ∀ x : E, ‖x‖ ≤ 1 → toFun R x = 1\n  support : ∀ R : ℝ, 1 < R → Function.support (toFun R) = Metric.ball (0 : E) R\n\n"}
{"name":"ContDiffBumpBase.mk.inj","module":"Mathlib.Analysis.Calculus.BumpFunction.Basic","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\ntoFun✝ : Real → E → Real\nmem_Icc✝ : ∀ (R : Real) (x : E), Membership.mem (Set.Icc 0 1) (toFun✝ R x)\nsymmetric✝ : ∀ (R : Real) (x : E), Eq (toFun✝ R (Neg.neg x)) (toFun✝ R x)\nsmooth✝ : ContDiffOn Real (↑Top.top) (Function.uncurry toFun✝) (SProd.sprod (Set.Ioi 1) Set.univ)\neq_one✝ : ∀ (R : Real), LT.lt 1 R → ∀ (x : E), LE.le (Norm.norm x) 1 → Eq (toFun✝ R x) 1\nsupport✝ : ∀ (R : Real), LT.lt 1 R → Eq (Function.support (toFun✝ R)) (Metric.ball 0 R)\ntoFun : Real → E → Real\nmem_Icc : ∀ (R : Real) (x : E), Membership.mem (Set.Icc 0 1) (toFun R x)\nsymmetric : ∀ (R : Real) (x : E), Eq (toFun R (Neg.neg x)) (toFun R x)\nsmooth : ContDiffOn Real (↑Top.top) (Function.uncurry toFun) (SProd.sprod (Set.Ioi 1) Set.univ)\neq_one : ∀ (R : Real), LT.lt 1 R → ∀ (x : E), LE.le (Norm.norm x) 1 → Eq (toFun R x) 1\nsupport : ∀ (R : Real), LT.lt 1 R → Eq (Function.support (toFun R)) (Metric.ball 0 R)\nx✝ : Eq { toFun := toFun✝, mem_Icc := mem_Icc✝, symmetric := symmetric✝, smooth := smooth✝, eq_one := eq_one✝, support := support✝ } { toFun := toFun, mem_Icc := mem_Icc, symmetric := symmetric, smooth := smooth, eq_one := eq_one, support := support }\n⊢ Eq toFun✝ toFun","decl":"/-- The base function from which one will construct a family of bump functions. One could\nadd more properties if they are useful and satisfied in the examples of inner product spaces\nand finite dimensional vector spaces, notably derivative norm control in terms of `R - 1`.\n\nTODO: do we ever need `f x = 1 ↔ ‖x‖ ≤ 1`? -/\nstructure ContDiffBumpBase (E : Type*) [NormedAddCommGroup E] [NormedSpace ℝ E] where\n  /-- The function underlying this family of bump functions -/\n  toFun : ℝ → E → ℝ\n  mem_Icc : ∀ (R : ℝ) (x : E), toFun R x ∈ Icc (0 : ℝ) 1\n  symmetric : ∀ (R : ℝ) (x : E), toFun R (-x) = toFun R x\n  smooth : ContDiffOn ℝ ∞ (uncurry toFun) (Ioi (1 : ℝ) ×ˢ (univ : Set E))\n  eq_one : ∀ R : ℝ, 1 < R → ∀ x : E, ‖x‖ ≤ 1 → toFun R x = 1\n  support : ∀ R : ℝ, 1 < R → Function.support (toFun R) = Metric.ball (0 : E) R\n\n"}
{"name":"ContDiffBumpBase.mk.injEq","module":"Mathlib.Analysis.Calculus.BumpFunction.Basic","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\ntoFun✝ : Real → E → Real\nmem_Icc✝ : ∀ (R : Real) (x : E), Membership.mem (Set.Icc 0 1) (toFun✝ R x)\nsymmetric✝ : ∀ (R : Real) (x : E), Eq (toFun✝ R (Neg.neg x)) (toFun✝ R x)\nsmooth✝ : ContDiffOn Real (↑Top.top) (Function.uncurry toFun✝) (SProd.sprod (Set.Ioi 1) Set.univ)\neq_one✝ : ∀ (R : Real), LT.lt 1 R → ∀ (x : E), LE.le (Norm.norm x) 1 → Eq (toFun✝ R x) 1\nsupport✝ : ∀ (R : Real), LT.lt 1 R → Eq (Function.support (toFun✝ R)) (Metric.ball 0 R)\ntoFun : Real → E → Real\nmem_Icc : ∀ (R : Real) (x : E), Membership.mem (Set.Icc 0 1) (toFun R x)\nsymmetric : ∀ (R : Real) (x : E), Eq (toFun R (Neg.neg x)) (toFun R x)\nsmooth : ContDiffOn Real (↑Top.top) (Function.uncurry toFun) (SProd.sprod (Set.Ioi 1) Set.univ)\neq_one : ∀ (R : Real), LT.lt 1 R → ∀ (x : E), LE.le (Norm.norm x) 1 → Eq (toFun R x) 1\nsupport : ∀ (R : Real), LT.lt 1 R → Eq (Function.support (toFun R)) (Metric.ball 0 R)\n⊢ Eq (Eq { toFun := toFun✝, mem_Icc := mem_Icc✝, symmetric := symmetric✝, smooth := smooth✝, eq_one := eq_one✝, support := support✝ } { toFun := toFun, mem_Icc := mem_Icc, symmetric := symmetric, smooth := smooth, eq_one := eq_one, support := support }) (Eq toFun✝ toFun)","decl":"/-- The base function from which one will construct a family of bump functions. One could\nadd more properties if they are useful and satisfied in the examples of inner product spaces\nand finite dimensional vector spaces, notably derivative norm control in terms of `R - 1`.\n\nTODO: do we ever need `f x = 1 ↔ ‖x‖ ≤ 1`? -/\nstructure ContDiffBumpBase (E : Type*) [NormedAddCommGroup E] [NormedSpace ℝ E] where\n  /-- The function underlying this family of bump functions -/\n  toFun : ℝ → E → ℝ\n  mem_Icc : ∀ (R : ℝ) (x : E), toFun R x ∈ Icc (0 : ℝ) 1\n  symmetric : ∀ (R : ℝ) (x : E), toFun R (-x) = toFun R x\n  smooth : ContDiffOn ℝ ∞ (uncurry toFun) (Ioi (1 : ℝ) ×ˢ (univ : Set E))\n  eq_one : ∀ R : ℝ, 1 < R → ∀ x : E, ‖x‖ ≤ 1 → toFun R x = 1\n  support : ∀ R : ℝ, 1 < R → Function.support (toFun R) = Metric.ball (0 : E) R\n\n"}
{"name":"HasContDiffBump.out","module":"Mathlib.Analysis.Calculus.BumpFunction.Basic","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nself : HasContDiffBump E\n⊢ Nonempty (ContDiffBumpBase E)","decl":"/-- A class registering that a real vector space admits bump functions. This will be instantiated\nfirst for inner product spaces, and then for finite-dimensional normed spaces.\nWe use a specific class instead of `Nonempty (ContDiffBumpBase E)` for performance reasons. -/\nclass HasContDiffBump (E : Type*) [NormedAddCommGroup E] [NormedSpace ℝ E] : Prop where\n  out : Nonempty (ContDiffBumpBase E)\n\n"}
{"name":"ContDiffBump.rOut_pos","module":"Mathlib.Analysis.Calculus.BumpFunction.Basic","initialProofState":"E : Type u_1\nc : E\nf : ContDiffBump c\n⊢ LT.lt 0 f.rOut","decl":"theorem rOut_pos {c : E} (f : ContDiffBump c) : 0 < f.rOut :=\n  f.rIn_pos.trans f.rIn_lt_rOut\n\n"}
{"name":"ContDiffBump.one_lt_rOut_div_rIn","module":"Mathlib.Analysis.Calculus.BumpFunction.Basic","initialProofState":"E : Type u_1\nc : E\nf : ContDiffBump c\n⊢ LT.lt 1 (HDiv.hDiv f.rOut f.rIn)","decl":"theorem one_lt_rOut_div_rIn {c : E} (f : ContDiffBump c) : 1 < f.rOut / f.rIn := by\n  rw [one_lt_div f.rIn_pos]\n  exact f.rIn_lt_rOut\n\n"}
{"name":"ContDiffBump.apply","module":"Mathlib.Analysis.Calculus.BumpFunction.Basic","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : HasContDiffBump E\nc : E\nf : ContDiffBump c\nx : E\n⊢ Eq (↑f x) ((someContDiffBumpBase E).toFun (HDiv.hDiv f.rOut f.rIn) (HSMul.hSMul (Inv.inv f.rIn) (HSub.hSub x c)))","decl":"protected theorem apply (x : E) :\n    f x = (someContDiffBumpBase E).toFun (f.rOut / f.rIn) (f.rIn⁻¹ • (x - c)) :=\n  rfl\n\n"}
{"name":"ContDiffBump.sub","module":"Mathlib.Analysis.Calculus.BumpFunction.Basic","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : HasContDiffBump E\nc : E\nf : ContDiffBump c\nx : E\n⊢ Eq (↑f (HSub.hSub c x)) (↑f (HAdd.hAdd c x))","decl":"protected theorem sub (x : E) : f (c - x) = f (c + x) := by\n  simp [f.apply, ContDiffBumpBase.symmetric]\n\n"}
{"name":"ContDiffBump.neg","module":"Mathlib.Analysis.Calculus.BumpFunction.Basic","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : HasContDiffBump E\nf : ContDiffBump 0\nx : E\n⊢ Eq (↑f (Neg.neg x)) (↑f x)","decl":"protected theorem neg (f : ContDiffBump (0 : E)) (x : E) : f (-x) = f x := by\n  simp_rw [← zero_sub, f.sub, zero_add]\n\n"}
{"name":"ContDiffBump.one_of_mem_closedBall","module":"Mathlib.Analysis.Calculus.BumpFunction.Basic","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : HasContDiffBump E\nc : E\nf : ContDiffBump c\nx : E\nhx : Membership.mem (Metric.closedBall c f.rIn) x\n⊢ Eq (↑f x) 1","decl":"theorem one_of_mem_closedBall (hx : x ∈ closedBall c f.rIn) : f x = 1 := by\n  apply ContDiffBumpBase.eq_one _ _ f.one_lt_rOut_div_rIn\n  simpa only [norm_smul, Real.norm_eq_abs, abs_inv, abs_of_nonneg f.rIn_pos.le, ← div_eq_inv_mul,\n    div_le_one f.rIn_pos] using mem_closedBall_iff_norm.1 hx\n\n"}
{"name":"ContDiffBump.nonneg","module":"Mathlib.Analysis.Calculus.BumpFunction.Basic","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : HasContDiffBump E\nc : E\nf : ContDiffBump c\nx : E\n⊢ LE.le 0 (↑f x)","decl":"theorem nonneg : 0 ≤ f x :=\n  (ContDiffBumpBase.mem_Icc (someContDiffBumpBase E) _ _).1\n\n"}
{"name":"ContDiffBump.nonneg'","module":"Mathlib.Analysis.Calculus.BumpFunction.Basic","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : HasContDiffBump E\nc : E\nf : ContDiffBump c\nx : E\n⊢ LE.le 0 (↑f x)","decl":"/-- A version of `ContDiffBump.nonneg` with `x` explicit -/\ntheorem nonneg' (x : E) : 0 ≤ f x := f.nonneg\n\n"}
{"name":"ContDiffBump.le_one","module":"Mathlib.Analysis.Calculus.BumpFunction.Basic","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : HasContDiffBump E\nc : E\nf : ContDiffBump c\nx : E\n⊢ LE.le (↑f x) 1","decl":"theorem le_one : f x ≤ 1 :=\n  (ContDiffBumpBase.mem_Icc (someContDiffBumpBase E) _ _).2\n\n"}
{"name":"ContDiffBump.support_eq","module":"Mathlib.Analysis.Calculus.BumpFunction.Basic","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : HasContDiffBump E\nc : E\nf : ContDiffBump c\n⊢ Eq (Function.support ↑f) (Metric.ball c f.rOut)","decl":"theorem support_eq : Function.support f = Metric.ball c f.rOut := by\n  simp only [toFun, support_comp_eq_preimage, ContDiffBumpBase.support _ _ f.one_lt_rOut_div_rIn]\n  ext x\n  simp only [mem_ball_iff_norm, sub_zero, norm_smul, mem_preimage, Real.norm_eq_abs, abs_inv,\n    abs_of_pos f.rIn_pos, ← div_eq_inv_mul, div_lt_div_iff_of_pos_right f.rIn_pos]\n\n"}
{"name":"ContDiffBump.tsupport_eq","module":"Mathlib.Analysis.Calculus.BumpFunction.Basic","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : HasContDiffBump E\nc : E\nf : ContDiffBump c\n⊢ Eq (tsupport ↑f) (Metric.closedBall c f.rOut)","decl":"theorem tsupport_eq : tsupport f = closedBall c f.rOut := by\n  simp_rw [tsupport, f.support_eq, closure_ball _ f.rOut_pos.ne']\n\n"}
{"name":"ContDiffBump.pos_of_mem_ball","module":"Mathlib.Analysis.Calculus.BumpFunction.Basic","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : HasContDiffBump E\nc : E\nf : ContDiffBump c\nx : E\nhx : Membership.mem (Metric.ball c f.rOut) x\n⊢ LT.lt 0 (↑f x)","decl":"theorem pos_of_mem_ball (hx : x ∈ ball c f.rOut) : 0 < f x :=\n  f.nonneg.lt_of_ne' <| by rwa [← support_eq, mem_support] at hx\n\n"}
{"name":"ContDiffBump.zero_of_le_dist","module":"Mathlib.Analysis.Calculus.BumpFunction.Basic","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : HasContDiffBump E\nc : E\nf : ContDiffBump c\nx : E\nhx : LE.le f.rOut (Dist.dist x c)\n⊢ Eq (↑f x) 0","decl":"theorem zero_of_le_dist (hx : f.rOut ≤ dist x c) : f x = 0 := by\n  rwa [← nmem_support, support_eq, mem_ball, not_lt]\n\n"}
{"name":"ContDiffBump.hasCompactSupport","module":"Mathlib.Analysis.Calculus.BumpFunction.Basic","initialProofState":"E : Type u_1\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\ninst✝¹ : HasContDiffBump E\nc : E\nf : ContDiffBump c\ninst✝ : FiniteDimensional Real E\n⊢ HasCompactSupport ↑f","decl":"protected theorem hasCompactSupport [FiniteDimensional ℝ E] : HasCompactSupport f := by\n  simp_rw [HasCompactSupport, f.tsupport_eq, isCompact_closedBall]\n\n"}
{"name":"ContDiffBump.eventuallyEq_one_of_mem_ball","module":"Mathlib.Analysis.Calculus.BumpFunction.Basic","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : HasContDiffBump E\nc : E\nf : ContDiffBump c\nx : E\nh : Membership.mem (Metric.ball c f.rIn) x\n⊢ (nhds x).EventuallyEq (↑f) 1","decl":"theorem eventuallyEq_one_of_mem_ball (h : x ∈ ball c f.rIn) : f =ᶠ[𝓝 x] 1 :=\n  mem_of_superset (closedBall_mem_nhds_of_mem h) fun _ ↦ f.one_of_mem_closedBall\n\n"}
{"name":"ContDiffBump.eventuallyEq_one","module":"Mathlib.Analysis.Calculus.BumpFunction.Basic","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : HasContDiffBump E\nc : E\nf : ContDiffBump c\n⊢ (nhds c).EventuallyEq (↑f) 1","decl":"theorem eventuallyEq_one : f =ᶠ[𝓝 c] 1 :=\n  f.eventuallyEq_one_of_mem_ball (mem_ball_self f.rIn_pos)\n\n"}
{"name":"ContDiffWithinAt.contDiffBump","module":"Mathlib.Analysis.Calculus.BumpFunction.Basic","initialProofState":"E : Type u_1\nX : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : NormedAddCommGroup X\ninst✝¹ : NormedSpace Real X\ninst✝ : HasContDiffBump E\nn : ENat\nc g : X → E\ns : Set X\nf : (x : X) → ContDiffBump (c x)\nx : X\nhc : ContDiffWithinAt Real (↑n) c s x\nhr : ContDiffWithinAt Real (↑n) (fun x => (f x).rIn) s x\nhR : ContDiffWithinAt Real (↑n) (fun x => (f x).rOut) s x\nhg : ContDiffWithinAt Real (↑n) g s x\n⊢ ContDiffWithinAt Real (↑n) (fun x => ↑(f x) (g x)) s x","decl":"/-- `ContDiffBump` is `𝒞ⁿ` in all its arguments. -/\nprotected theorem _root_.ContDiffWithinAt.contDiffBump {c g : X → E} {s : Set X}\n    {f : ∀ x, ContDiffBump (c x)} {x : X} (hc : ContDiffWithinAt ℝ n c s x)\n    (hr : ContDiffWithinAt ℝ n (fun x => (f x).rIn) s x)\n    (hR : ContDiffWithinAt ℝ n (fun x => (f x).rOut) s x)\n    (hg : ContDiffWithinAt ℝ n g s x) :\n    ContDiffWithinAt ℝ n (fun x => f x (g x)) s x := by\n  change ContDiffWithinAt ℝ n (uncurry (someContDiffBumpBase E).toFun ∘ fun x : X =>\n    ((f x).rOut / (f x).rIn, (f x).rIn⁻¹ • (g x - c x))) s x\n  refine (((someContDiffBumpBase E).smooth.contDiffAt ?_).of_le\n    (mod_cast le_top)).comp_contDiffWithinAt x ?_\n  · exact prod_mem_nhds (Ioi_mem_nhds (f x).one_lt_rOut_div_rIn) univ_mem\n  · exact (hR.div hr (f x).rIn_pos.ne').prod ((hr.inv (f x).rIn_pos.ne').smul (hg.sub hc))\n\n"}
{"name":"ContDiffAt.contDiffBump","module":"Mathlib.Analysis.Calculus.BumpFunction.Basic","initialProofState":"E : Type u_1\nX : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : NormedAddCommGroup X\ninst✝¹ : NormedSpace Real X\ninst✝ : HasContDiffBump E\nn : ENat\nc g : X → E\nf : (x : X) → ContDiffBump (c x)\nx : X\nhc : ContDiffAt Real (↑n) c x\nhr : ContDiffAt Real (↑n) (fun x => (f x).rIn) x\nhR : ContDiffAt Real (↑n) (fun x => (f x).rOut) x\nhg : ContDiffAt Real (↑n) g x\n⊢ ContDiffAt Real (↑n) (fun x => ↑(f x) (g x)) x","decl":"/-- `ContDiffBump` is `𝒞ⁿ` in all its arguments. -/\nprotected nonrec theorem _root_.ContDiffAt.contDiffBump {c g : X → E} {f : ∀ x, ContDiffBump (c x)}\n    {x : X} (hc : ContDiffAt ℝ n c x) (hr : ContDiffAt ℝ n (fun x => (f x).rIn) x)\n    (hR : ContDiffAt ℝ n (fun x => (f x).rOut) x) (hg : ContDiffAt ℝ n g x) :\n    ContDiffAt ℝ n (fun x => f x (g x)) x :=\n  hc.contDiffBump hr hR hg\n\n"}
{"name":"ContDiff.contDiffBump","module":"Mathlib.Analysis.Calculus.BumpFunction.Basic","initialProofState":"E : Type u_1\nX : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : NormedAddCommGroup X\ninst✝¹ : NormedSpace Real X\ninst✝ : HasContDiffBump E\nn : ENat\nc g : X → E\nf : (x : X) → ContDiffBump (c x)\nhc : ContDiff Real (↑n) c\nhr : ContDiff Real ↑n fun x => (f x).rIn\nhR : ContDiff Real ↑n fun x => (f x).rOut\nhg : ContDiff Real (↑n) g\n⊢ ContDiff Real ↑n fun x => ↑(f x) (g x)","decl":"theorem _root_.ContDiff.contDiffBump {c g : X → E} {f : ∀ x, ContDiffBump (c x)}\n    (hc : ContDiff ℝ n c) (hr : ContDiff ℝ n fun x => (f x).rIn)\n    (hR : ContDiff ℝ n fun x => (f x).rOut) (hg : ContDiff ℝ n g) :\n    ContDiff ℝ n fun x => f x (g x) := by\n  rw [contDiff_iff_contDiffAt] at *\n  exact fun x => (hc x).contDiffBump (hr x) (hR x) (hg x)\n\n"}
{"name":"ContDiffBump.contDiff","module":"Mathlib.Analysis.Calculus.BumpFunction.Basic","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : HasContDiffBump E\nc : E\nf : ContDiffBump c\nn : ENat\n⊢ ContDiff Real ↑n ↑f","decl":"protected theorem contDiff : ContDiff ℝ n f :=\n  contDiff_const.contDiffBump contDiff_const contDiff_const contDiff_id\n\n"}
{"name":"ContDiffBump.contDiffAt","module":"Mathlib.Analysis.Calculus.BumpFunction.Basic","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : HasContDiffBump E\nc : E\nf : ContDiffBump c\nx : E\nn : ENat\n⊢ ContDiffAt Real (↑n) (↑f) x","decl":"protected theorem contDiffAt : ContDiffAt ℝ n f x :=\n  f.contDiff.contDiffAt\n\n"}
{"name":"ContDiffBump.contDiffWithinAt","module":"Mathlib.Analysis.Calculus.BumpFunction.Basic","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : HasContDiffBump E\nc : E\nf : ContDiffBump c\nx : E\nn : ENat\ns : Set E\n⊢ ContDiffWithinAt Real (↑n) (↑f) s x","decl":"protected theorem contDiffWithinAt {s : Set E} : ContDiffWithinAt ℝ n f s x :=\n  f.contDiffAt.contDiffWithinAt\n\n"}
{"name":"ContDiffBump.continuous","module":"Mathlib.Analysis.Calculus.BumpFunction.Basic","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : HasContDiffBump E\nc : E\nf : ContDiffBump c\n⊢ Continuous ↑f","decl":"protected theorem continuous : Continuous f :=\n  contDiff_zero.mp f.contDiff\n\n"}
