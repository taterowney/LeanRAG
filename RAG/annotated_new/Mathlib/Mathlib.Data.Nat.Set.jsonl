{"name":"Nat.zero_union_range_succ","module":"Mathlib.Data.Nat.Set","initialProofState":"⊢ Eq (Union.union (Singleton.singleton 0) (Set.range Nat.succ)) Set.univ","decl":"theorem zero_union_range_succ : {0} ∪ range succ = univ := by\n  ext n\n  cases n <;> simp\n\n"}
{"name":"Nat.range_succ","module":"Mathlib.Data.Nat.Set","initialProofState":"⊢ Eq (Set.range Nat.succ) (setOf fun i => LT.lt 0 i)","decl":"@[simp]\nprotected theorem range_succ : range succ = { i | 0 < i } := by\n  ext (_ | i) <;> simp [succ_pos, succ_ne_zero, Set.mem_setOf]\n\n"}
{"name":"Nat.range_of_succ","module":"Mathlib.Data.Nat.Set","initialProofState":"α : Type u_1\nf : Nat → α\n⊢ Eq (Union.union (Singleton.singleton (f 0)) (Set.range (Function.comp f Nat.succ))) (Set.range f)","decl":"theorem range_of_succ (f : ℕ → α) : {f 0} ∪ range (f ∘ succ) = range f := by\n  rw [← image_singleton, range_comp, ← image_union, zero_union_range_succ, image_univ]\n\n"}
{"name":"Nat.range_rec","module":"Mathlib.Data.Nat.Set","initialProofState":"α : Type u_2\nx : α\nf : Nat → α → α\n⊢ Eq (Set.range fun n => Nat.rec x f n) (Union.union (Singleton.singleton x) (Set.range fun n => Nat.rec (f 0 x) (Function.comp f Nat.succ) n))","decl":"theorem range_rec {α : Type*} (x : α) (f : ℕ → α → α) :\n    (Set.range fun n => Nat.rec x f n : Set α) =\n      {x} ∪ Set.range fun n => Nat.rec (f 0 x) (f ∘ succ) n := by\n  convert (range_of_succ (fun n => Nat.rec x f n : ℕ → α)).symm using 4\n  dsimp\n  rename_i n\n  induction n with\n  | zero => rfl\n  | succ n ihn => dsimp at ihn ⊢; rw [ihn]\n\n"}
{"name":"Nat.range_casesOn","module":"Mathlib.Data.Nat.Set","initialProofState":"α : Type u_2\nx : α\nf : Nat → α\n⊢ Eq (Set.range fun n => Nat.casesOn n x f) (Union.union (Singleton.singleton x) (Set.range f))","decl":"theorem range_casesOn {α : Type*} (x : α) (f : ℕ → α) :\n    (Set.range fun n => Nat.casesOn n x f : Set α) = {x} ∪ Set.range f :=\n  (range_of_succ _).symm\n\n"}
