{"name":"Matrix.toMvPolynomial_eval_eq_apply","module":"Mathlib.Algebra.Module.LinearMap.Polynomial","initialProofState":"m : Type u_1\nn : Type u_2\nR : Type u_4\ninst✝¹ : Fintype n\ninst✝ : CommSemiring R\nM : Matrix m n R\ni : m\nc : n → R\n⊢ Eq ((MvPolynomial.eval c) (M.toMvPolynomial i)) (M.mulVec c i)","decl":"lemma toMvPolynomial_eval_eq_apply (M : Matrix m n R) (i : m) (c : n → R) :\n    eval c (M.toMvPolynomial i) = (M *ᵥ c) i := by\n  simp only [toMvPolynomial, map_sum, eval_monomial, pow_zero, Finsupp.prod_single_index, pow_one,\n    mulVec, dotProduct]\n\n"}
{"name":"Matrix.toMvPolynomial_map","module":"Mathlib.Algebra.Module.LinearMap.Polynomial","initialProofState":"m : Type u_1\nn : Type u_2\nR : Type u_4\nS : Type u_5\ninst✝² : Fintype n\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S\nf : RingHom R S\nM : Matrix m n R\ni : m\n⊢ Eq ((M.map ⇑f).toMvPolynomial i) ((MvPolynomial.map f) (M.toMvPolynomial i))","decl":"lemma toMvPolynomial_map (f : R →+* S) (M : Matrix m n R) (i : m) :\n    (M.map f).toMvPolynomial i = MvPolynomial.map f (M.toMvPolynomial i) := by\n  simp only [toMvPolynomial, map_apply, map_sum, map_monomial]\n\n"}
{"name":"Matrix.toMvPolynomial_isHomogeneous","module":"Mathlib.Algebra.Module.LinearMap.Polynomial","initialProofState":"m : Type u_1\nn : Type u_2\nR : Type u_4\ninst✝¹ : Fintype n\ninst✝ : CommSemiring R\nM : Matrix m n R\ni : m\n⊢ (M.toMvPolynomial i).IsHomogeneous 1","decl":"lemma toMvPolynomial_isHomogeneous (M : Matrix m n R) (i : m) :\n    (M.toMvPolynomial i).IsHomogeneous 1 := by\n  apply MvPolynomial.IsHomogeneous.sum\n  rintro j -\n  apply MvPolynomial.isHomogeneous_monomial _ _\n  simp [Finsupp.degree, Finsupp.support_single_ne_zero _ one_ne_zero, Finset.sum_singleton,\n    Finsupp.single_eq_same]\n\n"}
{"name":"Matrix.toMvPolynomial_totalDegree_le","module":"Mathlib.Algebra.Module.LinearMap.Polynomial","initialProofState":"m : Type u_1\nn : Type u_2\nR : Type u_4\ninst✝¹ : Fintype n\ninst✝ : CommSemiring R\nM : Matrix m n R\ni : m\n⊢ LE.le (M.toMvPolynomial i).totalDegree 1","decl":"lemma toMvPolynomial_totalDegree_le (M : Matrix m n R) (i : m) :\n    (M.toMvPolynomial i).totalDegree ≤ 1 := by\n  apply (toMvPolynomial_isHomogeneous _ _).totalDegree_le\n\n"}
{"name":"Matrix.toMvPolynomial_constantCoeff","module":"Mathlib.Algebra.Module.LinearMap.Polynomial","initialProofState":"m : Type u_1\nn : Type u_2\nR : Type u_4\ninst✝¹ : Fintype n\ninst✝ : CommSemiring R\nM : Matrix m n R\ni : m\n⊢ Eq (MvPolynomial.constantCoeff (M.toMvPolynomial i)) 0","decl":"@[simp]\nlemma toMvPolynomial_constantCoeff (M : Matrix m n R) (i : m) :\n    constantCoeff (M.toMvPolynomial i) = 0 := by\n  simp only [toMvPolynomial, ← C_mul_X_eq_monomial, map_sum, _root_.map_mul, constantCoeff_X,\n    mul_zero, Finset.sum_const_zero]\n\n"}
{"name":"Matrix.toMvPolynomial_zero","module":"Mathlib.Algebra.Module.LinearMap.Polynomial","initialProofState":"m : Type u_1\nn : Type u_2\nR : Type u_4\ninst✝¹ : Fintype n\ninst✝ : CommSemiring R\n⊢ Eq (Matrix.toMvPolynomial 0) 0","decl":"@[simp]\nlemma toMvPolynomial_zero : (0 : Matrix m n R).toMvPolynomial = 0 := by\n  ext; simp only [toMvPolynomial, zero_apply, map_zero, Finset.sum_const_zero, Pi.zero_apply]\n\n"}
{"name":"Matrix.toMvPolynomial_one","module":"Mathlib.Algebra.Module.LinearMap.Polynomial","initialProofState":"n : Type u_2\nR : Type u_4\ninst✝² : Fintype n\ninst✝¹ : CommSemiring R\ninst✝ : DecidableEq n\n⊢ Eq (Matrix.toMvPolynomial 1) MvPolynomial.X","decl":"@[simp]\nlemma toMvPolynomial_one [DecidableEq n] : (1 : Matrix n n R).toMvPolynomial = X := by\n  ext i : 1\n  rw [toMvPolynomial, Finset.sum_eq_single i]\n  · simp only [one_apply_eq, ← C_mul_X_eq_monomial, C_1, one_mul]\n  · rintro j - hj\n    simp only [one_apply_ne hj.symm, map_zero]\n  · intro h\n    exact (h (Finset.mem_univ _)).elim\n\n"}
{"name":"Matrix.toMvPolynomial_add","module":"Mathlib.Algebra.Module.LinearMap.Polynomial","initialProofState":"m : Type u_1\nn : Type u_2\nR : Type u_4\ninst✝¹ : Fintype n\ninst✝ : CommSemiring R\nM N : Matrix m n R\n⊢ Eq (HAdd.hAdd M N).toMvPolynomial (HAdd.hAdd M.toMvPolynomial N.toMvPolynomial)","decl":"lemma toMvPolynomial_add (M N : Matrix m n R) :\n    (M + N).toMvPolynomial = M.toMvPolynomial + N.toMvPolynomial := by\n  ext i : 1\n  simp only [toMvPolynomial, add_apply, map_add, Finset.sum_add_distrib, Pi.add_apply]\n\n"}
{"name":"Matrix.toMvPolynomial_mul","module":"Mathlib.Algebra.Module.LinearMap.Polynomial","initialProofState":"m : Type u_1\nn : Type u_2\no : Type u_3\nR : Type u_4\ninst✝² : Fintype n\ninst✝¹ : Fintype o\ninst✝ : CommSemiring R\nM : Matrix m n R\nN : Matrix n o R\ni : m\n⊢ Eq ((HMul.hMul M N).toMvPolynomial i) ((MvPolynomial.bind₁ N.toMvPolynomial) (M.toMvPolynomial i))","decl":"lemma toMvPolynomial_mul (M : Matrix m n R) (N : Matrix n o R) (i : m) :\n    (M * N).toMvPolynomial i = bind₁ N.toMvPolynomial (M.toMvPolynomial i) := by\n  simp only [toMvPolynomial, mul_apply, map_sum, Finset.sum_comm (γ := o), bind₁, aeval,\n    AlgHom.coe_mk, coe_eval₂Hom, eval₂_monomial, algebraMap_apply, Algebra.id.map_eq_id,\n    RingHom.id_apply, C_apply, pow_zero, Finsupp.prod_single_index, pow_one, Finset.mul_sum,\n    monomial_mul, zero_add]\n\n"}
{"name":"LinearMap.toMvPolynomial_eval_eq_apply","module":"Mathlib.Algebra.Module.LinearMap.Polynomial","initialProofState":"R : Type u_1\nM₁ : Type u_2\nM₂ : Type u_3\nι₁ : Type u_4\nι₂ : Type u_5\ninst✝⁷ : CommRing R\ninst✝⁶ : AddCommGroup M₁\ninst✝⁵ : AddCommGroup M₂\ninst✝⁴ : Module R M₁\ninst✝³ : Module R M₂\ninst✝² : Fintype ι₁\ninst✝¹ : Finite ι₂\ninst✝ : DecidableEq ι₁\nb₁ : Basis ι₁ R M₁\nb₂ : Basis ι₂ R M₂\nf : LinearMap (RingHom.id R) M₁ M₂\ni : ι₂\nc : Finsupp ι₁ R\n⊢ Eq ((MvPolynomial.eval ⇑c) (LinearMap.toMvPolynomial b₁ b₂ f i)) ((b₂.repr (f (b₁.repr.symm c))) i)","decl":"lemma toMvPolynomial_eval_eq_apply (f : M₁ →ₗ[R] M₂) (i : ι₂) (c : ι₁ →₀ R) :\n    eval c (f.toMvPolynomial b₁ b₂ i) = b₂.repr (f (b₁.repr.symm c)) i := by\n  rw [toMvPolynomial, Matrix.toMvPolynomial_eval_eq_apply,\n    ← LinearMap.toMatrix_mulVec_repr b₁ b₂, LinearEquiv.apply_symm_apply]\n\n"}
{"name":"LinearMap.toMvPolynomial_baseChange","module":"Mathlib.Algebra.Module.LinearMap.Polynomial","initialProofState":"R : Type u_1\nM₁ : Type u_2\nM₂ : Type u_3\nι₁ : Type u_4\nι₂ : Type u_5\ninst✝⁹ : CommRing R\ninst✝⁸ : AddCommGroup M₁\ninst✝⁷ : AddCommGroup M₂\ninst✝⁶ : Module R M₁\ninst✝⁵ : Module R M₂\ninst✝⁴ : Fintype ι₁\ninst✝³ : Finite ι₂\ninst✝² : DecidableEq ι₁\nb₁ : Basis ι₁ R M₁\nb₂ : Basis ι₂ R M₂\nf : LinearMap (RingHom.id R) M₁ M₂\ni : ι₂\nA : Type u_6\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\n⊢ Eq (LinearMap.toMvPolynomial (Algebra.TensorProduct.basis A b₁) (Algebra.TensorProduct.basis A b₂) (LinearMap.baseChange A f) i) ((MvPolynomial.map (algebraMap R A)) (LinearMap.toMvPolynomial b₁ b₂ f i))","decl":"open Algebra.TensorProduct in\nlemma toMvPolynomial_baseChange (f : M₁ →ₗ[R] M₂) (i : ι₂) (A : Type*) [CommRing A] [Algebra R A] :\n    (f.baseChange A).toMvPolynomial (basis A b₁) (basis A b₂) i =\n      MvPolynomial.map (algebraMap R A) (f.toMvPolynomial b₁ b₂ i) := by\n  simp only [toMvPolynomial, toMatrix_baseChange, Matrix.toMvPolynomial_map]\n\n"}
{"name":"LinearMap.toMvPolynomial_isHomogeneous","module":"Mathlib.Algebra.Module.LinearMap.Polynomial","initialProofState":"R : Type u_1\nM₁ : Type u_2\nM₂ : Type u_3\nι₁ : Type u_4\nι₂ : Type u_5\ninst✝⁷ : CommRing R\ninst✝⁶ : AddCommGroup M₁\ninst✝⁵ : AddCommGroup M₂\ninst✝⁴ : Module R M₁\ninst✝³ : Module R M₂\ninst✝² : Fintype ι₁\ninst✝¹ : Finite ι₂\ninst✝ : DecidableEq ι₁\nb₁ : Basis ι₁ R M₁\nb₂ : Basis ι₂ R M₂\nf : LinearMap (RingHom.id R) M₁ M₂\ni : ι₂\n⊢ (LinearMap.toMvPolynomial b₁ b₂ f i).IsHomogeneous 1","decl":"lemma toMvPolynomial_isHomogeneous (f : M₁ →ₗ[R] M₂) (i : ι₂) :\n    (f.toMvPolynomial b₁ b₂ i).IsHomogeneous 1 :=\n  Matrix.toMvPolynomial_isHomogeneous _ _\n\n"}
{"name":"LinearMap.toMvPolynomial_totalDegree_le","module":"Mathlib.Algebra.Module.LinearMap.Polynomial","initialProofState":"R : Type u_1\nM₁ : Type u_2\nM₂ : Type u_3\nι₁ : Type u_4\nι₂ : Type u_5\ninst✝⁷ : CommRing R\ninst✝⁶ : AddCommGroup M₁\ninst✝⁵ : AddCommGroup M₂\ninst✝⁴ : Module R M₁\ninst✝³ : Module R M₂\ninst✝² : Fintype ι₁\ninst✝¹ : Finite ι₂\ninst✝ : DecidableEq ι₁\nb₁ : Basis ι₁ R M₁\nb₂ : Basis ι₂ R M₂\nf : LinearMap (RingHom.id R) M₁ M₂\ni : ι₂\n⊢ LE.le (LinearMap.toMvPolynomial b₁ b₂ f i).totalDegree 1","decl":"lemma toMvPolynomial_totalDegree_le (f : M₁ →ₗ[R] M₂) (i : ι₂) :\n    (f.toMvPolynomial b₁ b₂ i).totalDegree ≤ 1 :=\n  Matrix.toMvPolynomial_totalDegree_le _ _\n\n"}
{"name":"LinearMap.toMvPolynomial_constantCoeff","module":"Mathlib.Algebra.Module.LinearMap.Polynomial","initialProofState":"R : Type u_1\nM₁ : Type u_2\nM₂ : Type u_3\nι₁ : Type u_4\nι₂ : Type u_5\ninst✝⁷ : CommRing R\ninst✝⁶ : AddCommGroup M₁\ninst✝⁵ : AddCommGroup M₂\ninst✝⁴ : Module R M₁\ninst✝³ : Module R M₂\ninst✝² : Fintype ι₁\ninst✝¹ : Finite ι₂\ninst✝ : DecidableEq ι₁\nb₁ : Basis ι₁ R M₁\nb₂ : Basis ι₂ R M₂\nf : LinearMap (RingHom.id R) M₁ M₂\ni : ι₂\n⊢ Eq (MvPolynomial.constantCoeff (LinearMap.toMvPolynomial b₁ b₂ f i)) 0","decl":"@[simp]\nlemma toMvPolynomial_constantCoeff (f : M₁ →ₗ[R] M₂) (i : ι₂) :\n    constantCoeff (f.toMvPolynomial b₁ b₂ i) = 0 :=\n  Matrix.toMvPolynomial_constantCoeff _ _\n\n"}
{"name":"LinearMap.toMvPolynomial_zero","module":"Mathlib.Algebra.Module.LinearMap.Polynomial","initialProofState":"R : Type u_1\nM₁ : Type u_2\nM₂ : Type u_3\nι₁ : Type u_4\nι₂ : Type u_5\ninst✝⁷ : CommRing R\ninst✝⁶ : AddCommGroup M₁\ninst✝⁵ : AddCommGroup M₂\ninst✝⁴ : Module R M₁\ninst✝³ : Module R M₂\ninst✝² : Fintype ι₁\ninst✝¹ : Finite ι₂\ninst✝ : DecidableEq ι₁\nb₁ : Basis ι₁ R M₁\nb₂ : Basis ι₂ R M₂\n⊢ Eq (LinearMap.toMvPolynomial b₁ b₂ 0) 0","decl":"@[simp]\nlemma toMvPolynomial_zero : (0 : M₁ →ₗ[R] M₂).toMvPolynomial b₁ b₂ = 0 := by\n  unfold toMvPolynomial; simp only [map_zero, Matrix.toMvPolynomial_zero]\n\n"}
{"name":"LinearMap.toMvPolynomial_id","module":"Mathlib.Algebra.Module.LinearMap.Polynomial","initialProofState":"R : Type u_1\nM₁ : Type u_2\nι₁ : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M₁\ninst✝² : Module R M₁\ninst✝¹ : Fintype ι₁\ninst✝ : DecidableEq ι₁\nb₁ : Basis ι₁ R M₁\n⊢ Eq (LinearMap.toMvPolynomial b₁ b₁ LinearMap.id) MvPolynomial.X","decl":"@[simp]\nlemma toMvPolynomial_id : (id : M₁ →ₗ[R] M₁).toMvPolynomial b₁ b₁ = X := by\n  unfold toMvPolynomial; simp only [toMatrix_id, Matrix.toMvPolynomial_one]\n\n"}
{"name":"LinearMap.toMvPolynomial_add","module":"Mathlib.Algebra.Module.LinearMap.Polynomial","initialProofState":"R : Type u_1\nM₁ : Type u_2\nM₂ : Type u_3\nι₁ : Type u_4\nι₂ : Type u_5\ninst✝⁷ : CommRing R\ninst✝⁶ : AddCommGroup M₁\ninst✝⁵ : AddCommGroup M₂\ninst✝⁴ : Module R M₁\ninst✝³ : Module R M₂\ninst✝² : Fintype ι₁\ninst✝¹ : Finite ι₂\ninst✝ : DecidableEq ι₁\nb₁ : Basis ι₁ R M₁\nb₂ : Basis ι₂ R M₂\nf g : LinearMap (RingHom.id R) M₁ M₂\n⊢ Eq (LinearMap.toMvPolynomial b₁ b₂ (HAdd.hAdd f g)) (HAdd.hAdd (LinearMap.toMvPolynomial b₁ b₂ f) (LinearMap.toMvPolynomial b₁ b₂ g))","decl":"lemma toMvPolynomial_add (f g : M₁ →ₗ[R] M₂) :\n    (f + g).toMvPolynomial b₁ b₂ = f.toMvPolynomial b₁ b₂ + g.toMvPolynomial b₁ b₂ := by\n  unfold toMvPolynomial; simp only [map_add, Matrix.toMvPolynomial_add]\n\n"}
{"name":"LinearMap.toMvPolynomial_comp","module":"Mathlib.Algebra.Module.LinearMap.Polynomial","initialProofState":"R : Type u_1\nM₁ : Type u_2\nM₂ : Type u_3\nM₃ : Type u_4\nι₁ : Type u_5\nι₂ : Type u_6\nι₃ : Type u_7\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : AddCommGroup M₁\ninst✝⁹ : AddCommGroup M₂\ninst✝⁸ : AddCommGroup M₃\ninst✝⁷ : Module R M₁\ninst✝⁶ : Module R M₂\ninst✝⁵ : Module R M₃\ninst✝⁴ : Fintype ι₁\ninst✝³ : Fintype ι₂\ninst✝² : Finite ι₃\ninst✝¹ : DecidableEq ι₁\ninst✝ : DecidableEq ι₂\nb₁ : Basis ι₁ R M₁\nb₂ : Basis ι₂ R M₂\nb₃ : Basis ι₃ R M₃\ng : LinearMap (RingHom.id R) M₂ M₃\nf : LinearMap (RingHom.id R) M₁ M₂\ni : ι₃\n⊢ Eq (LinearMap.toMvPolynomial b₁ b₃ (g.comp f) i) ((MvPolynomial.bind₁ (LinearMap.toMvPolynomial b₁ b₂ f)) (LinearMap.toMvPolynomial b₂ b₃ g i))","decl":"lemma toMvPolynomial_comp (g : M₂ →ₗ[R] M₃) (f : M₁ →ₗ[R] M₂) (i : ι₃) :\n    (g ∘ₗ f).toMvPolynomial b₁ b₃ i =\n      bind₁ (f.toMvPolynomial b₁ b₂) (g.toMvPolynomial b₂ b₃ i) := by\n  simp only [toMvPolynomial, toMatrix_comp b₁ b₂ b₃, Matrix.toMvPolynomial_mul]\n  rfl\n\n"}
{"name":"LinearMap.polyCharpolyAux_baseChange","module":"Mathlib.Algebra.Module.LinearMap.Polynomial","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\nι : Type u_5\nιM : Type u_7\ninst✝¹⁰ : CommRing R\ninst✝⁹ : AddCommGroup L\ninst✝⁸ : Module R L\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\nφ : LinearMap (RingHom.id R) L (Module.End R M)\ninst✝⁵ : Fintype ι\ninst✝⁴ : Fintype ιM\ninst✝³ : DecidableEq ι\ninst✝² : DecidableEq ιM\nb : Basis ι R L\nbₘ : Basis ιM R M\nA : Type u_8\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\n⊢ Eq (((LinearMap.tensorProduct R A M M).comp (LinearMap.baseChange A φ)).polyCharpolyAux (Algebra.TensorProduct.basis A b) (Algebra.TensorProduct.basis A bₘ)) (Polynomial.map (MvPolynomial.map (algebraMap R A)) (φ.polyCharpolyAux b bₘ))","decl":"open Algebra.TensorProduct MvPolynomial in\nlemma polyCharpolyAux_baseChange (A : Type*) [CommRing A] [Algebra R A] :\n    polyCharpolyAux (tensorProduct _ _ _ _ ∘ₗ φ.baseChange A) (basis A b) (basis A bₘ) =\n      (polyCharpolyAux φ b bₘ).map (MvPolynomial.map (algebraMap R A)) := by\n  simp only [polyCharpolyAux]\n  rw [← charpoly.univ_map_map _ (algebraMap R A)]\n  simp only [Polynomial.map_map]\n  congr 1\n  apply ringHom_ext\n  · intro r\n    simp only [RingHom.coe_comp, RingHom.coe_coe, Function.comp_apply, map_C, bind₁_C_right]\n  · rintro ij\n    simp only [RingHom.coe_comp, RingHom.coe_coe, Function.comp_apply, map_X, bind₁_X_right]\n    classical\n    rw [toMvPolynomial_comp _ (basis A (Basis.end bₘ)), ← toMvPolynomial_baseChange]\n    #adaptation_note /-- https://github.com/leanprover/lean4/pull/4119\n    we either need to specify the `M₂` argument, or use `set_option maxSynthPendingDepth 2 in`. -/\n    suffices toMvPolynomial (M₂ := (Module.End A (TensorProduct R A M)))\n        (basis A bₘ.end) (basis A bₘ).end (tensorProduct R A M M) ij = X ij by\n      rw [this, bind₁_X_right]\n    simp only [toMvPolynomial, Matrix.toMvPolynomial]\n    suffices ∀ kl,\n        (toMatrix (basis A bₘ.end) (basis A bₘ).end) (tensorProduct R A M M) ij kl =\n        if kl = ij then 1 else 0 by\n      rw [Finset.sum_eq_single ij]\n      · rw [this, if_pos rfl, X]\n      · rintro kl - H\n        rw [this, if_neg H, map_zero]\n      · intro h\n        exact (h (Finset.mem_univ _)).elim\n    intro kl\n    rw [toMatrix_apply, tensorProduct, TensorProduct.AlgebraTensorModule.lift_apply,\n      basis_apply, TensorProduct.lift.tmul, coe_restrictScalars]\n    dsimp only [coe_mk, AddHom.coe_mk, smul_apply, baseChangeHom_apply]\n    rw [one_smul, Basis.baseChange_end, Basis.repr_self_apply]\n\n"}
{"name":"LinearMap.polyCharpolyAux_map_eq_toMatrix_charpoly","module":"Mathlib.Algebra.Module.LinearMap.Polynomial","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\nι : Type u_5\nιM : Type u_7\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup L\ninst✝⁶ : Module R L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\nφ : LinearMap (RingHom.id R) L (Module.End R M)\ninst✝³ : Fintype ι\ninst✝² : Fintype ιM\ninst✝¹ : DecidableEq ι\ninst✝ : DecidableEq ιM\nb : Basis ι R L\nbₘ : Basis ιM R M\nx : L\n⊢ Eq (Polynomial.map (MvPolynomial.eval ⇑(b.repr x)) (φ.polyCharpolyAux b bₘ)) ((LinearMap.toMatrix bₘ bₘ) (φ x)).charpoly","decl":"open LinearMap in\nlemma polyCharpolyAux_map_eq_toMatrix_charpoly (x : L) :\n    (polyCharpolyAux φ b bₘ).map (MvPolynomial.eval (b.repr x)) =\n      (toMatrix bₘ bₘ (φ x)).charpoly := by\n  rw [polyCharpolyAux, Polynomial.map_map, ← MvPolynomial.eval₂Hom_C_eq_bind₁,\n    MvPolynomial.comp_eval₂Hom, charpoly.univ_map_eval₂Hom]\n  congr\n  ext\n  rw [of_apply, Function.curry_apply, toMvPolynomial_eval_eq_apply, LinearEquiv.symm_apply_apply]\n  rfl\n\n"}
{"name":"LinearMap.polyCharpolyAux_eval_eq_toMatrix_charpoly_coeff","module":"Mathlib.Algebra.Module.LinearMap.Polynomial","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\nι : Type u_5\nιM : Type u_7\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup L\ninst✝⁶ : Module R L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\nφ : LinearMap (RingHom.id R) L (Module.End R M)\ninst✝³ : Fintype ι\ninst✝² : Fintype ιM\ninst✝¹ : DecidableEq ι\ninst✝ : DecidableEq ιM\nb : Basis ι R L\nbₘ : Basis ιM R M\nx : L\ni : Nat\n⊢ Eq ((MvPolynomial.eval ⇑(b.repr x)) ((φ.polyCharpolyAux b bₘ).coeff i)) (((LinearMap.toMatrix bₘ bₘ) (φ x)).charpoly.coeff i)","decl":"open LinearMap in\nlemma polyCharpolyAux_eval_eq_toMatrix_charpoly_coeff (x : L) (i : ℕ) :\n    MvPolynomial.eval (b.repr x) ((polyCharpolyAux φ b bₘ).coeff i) =\n      (toMatrix bₘ bₘ (φ x)).charpoly.coeff i := by\n  simp [← polyCharpolyAux_map_eq_toMatrix_charpoly φ b bₘ x]\n\n"}
{"name":"LinearMap.polyCharpolyAux_map_eq_charpoly","module":"Mathlib.Algebra.Module.LinearMap.Polynomial","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\nι : Type u_5\nιM : Type u_7\ninst✝¹⁰ : CommRing R\ninst✝⁹ : AddCommGroup L\ninst✝⁸ : Module R L\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\nφ : LinearMap (RingHom.id R) L (Module.End R M)\ninst✝⁵ : Fintype ι\ninst✝⁴ : Fintype ιM\ninst✝³ : DecidableEq ι\ninst✝² : DecidableEq ιM\nb : Basis ι R L\nbₘ : Basis ιM R M\ninst✝¹ : Module.Finite R M\ninst✝ : Module.Free R M\nx : L\n⊢ Eq (Polynomial.map (MvPolynomial.eval ⇑(b.repr x)) (φ.polyCharpolyAux b bₘ)) (LinearMap.charpoly (φ x))","decl":"@[simp]\nlemma polyCharpolyAux_map_eq_charpoly [Module.Finite R M] [Module.Free R M]\n    (x : L) :\n    (polyCharpolyAux φ b bₘ).map (MvPolynomial.eval (b.repr x)) = (φ x).charpoly := by\n  nontriviality R\n  rw [polyCharpolyAux_map_eq_toMatrix_charpoly, LinearMap.charpoly_toMatrix]\n\n"}
{"name":"LinearMap.polyCharpolyAux_coeff_eval","module":"Mathlib.Algebra.Module.LinearMap.Polynomial","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\nι : Type u_5\nιM : Type u_7\ninst✝¹⁰ : CommRing R\ninst✝⁹ : AddCommGroup L\ninst✝⁸ : Module R L\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\nφ : LinearMap (RingHom.id R) L (Module.End R M)\ninst✝⁵ : Fintype ι\ninst✝⁴ : Fintype ιM\ninst✝³ : DecidableEq ι\ninst✝² : DecidableEq ιM\nb : Basis ι R L\nbₘ : Basis ιM R M\ninst✝¹ : Module.Finite R M\ninst✝ : Module.Free R M\nx : L\ni : Nat\n⊢ Eq ((MvPolynomial.eval ⇑(b.repr x)) ((φ.polyCharpolyAux b bₘ).coeff i)) ((LinearMap.charpoly (φ x)).coeff i)","decl":"@[simp]\nlemma polyCharpolyAux_coeff_eval [Module.Finite R M] [Module.Free R M] (x : L) (i : ℕ) :\n    MvPolynomial.eval (b.repr x) ((polyCharpolyAux φ b bₘ).coeff i) = (φ x).charpoly.coeff i := by\n  nontriviality R\n  rw [← polyCharpolyAux_map_eq_charpoly φ b bₘ x, Polynomial.coeff_map]\n\n"}
{"name":"LinearMap.polyCharpolyAux_map_eval","module":"Mathlib.Algebra.Module.LinearMap.Polynomial","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\nι : Type u_5\nιM : Type u_7\ninst✝¹⁰ : CommRing R\ninst✝⁹ : AddCommGroup L\ninst✝⁸ : Module R L\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\nφ : LinearMap (RingHom.id R) L (Module.End R M)\ninst✝⁵ : Fintype ι\ninst✝⁴ : Fintype ιM\ninst✝³ : DecidableEq ι\ninst✝² : DecidableEq ιM\nb : Basis ι R L\nbₘ : Basis ιM R M\ninst✝¹ : Module.Finite R M\ninst✝ : Module.Free R M\nx : ι → R\n⊢ Eq (Polynomial.map (MvPolynomial.eval x) (φ.polyCharpolyAux b bₘ)) (LinearMap.charpoly (φ (b.repr.symm (Finsupp.equivFunOnFinite.symm x))))","decl":"lemma polyCharpolyAux_map_eval [Module.Finite R M] [Module.Free R M]\n    (x : ι → R) :\n    (polyCharpolyAux φ b bₘ).map (MvPolynomial.eval x) =\n      (φ (b.repr.symm (Finsupp.equivFunOnFinite.symm x))).charpoly := by\n  simp only [← polyCharpolyAux_map_eq_charpoly φ b bₘ, LinearEquiv.apply_symm_apply,\n    Finsupp.equivFunOnFinite, Equiv.coe_fn_symm_mk, Finsupp.coe_mk]\n\n"}
{"name":"LinearMap.polyCharpolyAux_map_aeval","module":"Mathlib.Algebra.Module.LinearMap.Polynomial","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\nι : Type u_5\nιM : Type u_7\ninst✝¹² : CommRing R\ninst✝¹¹ : AddCommGroup L\ninst✝¹⁰ : Module R L\ninst✝⁹ : AddCommGroup M\ninst✝⁸ : Module R M\nφ : LinearMap (RingHom.id R) L (Module.End R M)\ninst✝⁷ : Fintype ι\ninst✝⁶ : Fintype ιM\ninst✝⁵ : DecidableEq ι\ninst✝⁴ : DecidableEq ιM\nb : Basis ι R L\nbₘ : Basis ιM R M\nA : Type u_8\ninst✝³ : CommRing A\ninst✝² : Algebra R A\ninst✝¹ : Module.Finite A (TensorProduct R A M)\ninst✝ : Module.Free A (TensorProduct R A M)\nx : ι → A\n⊢ Eq (Polynomial.map (MvPolynomial.aeval x).toRingHom (φ.polyCharpolyAux b bₘ)) (((LinearMap.tensorProduct R A M M).comp (LinearMap.baseChange A φ)) ((Algebra.TensorProduct.basis A b).repr.symm (Finsupp.equivFunOnFinite.symm x))).charpoly","decl":"open Algebra.TensorProduct TensorProduct in\nlemma polyCharpolyAux_map_aeval\n    (A : Type*) [CommRing A] [Algebra R A] [Module.Finite A (A ⊗[R] M)] [Module.Free A (A ⊗[R] M)]\n    (x : ι → A) :\n    (polyCharpolyAux φ b bₘ).map (MvPolynomial.aeval x).toRingHom =\n      LinearMap.charpoly ((tensorProduct R A M M).comp (baseChange A φ)\n        ((basis A b).repr.symm (Finsupp.equivFunOnFinite.symm x))) := by\n  rw [← polyCharpolyAux_map_eval (tensorProduct R A M M ∘ₗ baseChange A φ) _ (basis A bₘ),\n    polyCharpolyAux_baseChange, Polynomial.map_map]\n  congr\n  exact DFunLike.ext _ _ fun f ↦ (MvPolynomial.eval_map (algebraMap R A) x f).symm\n\n"}
{"name":"LinearMap.polyCharpolyAux_basisIndep","module":"Mathlib.Algebra.Module.LinearMap.Polynomial","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\nι : Type u_5\nιM : Type u_7\ninst✝¹⁰ : CommRing R\ninst✝⁹ : AddCommGroup L\ninst✝⁸ : Module R L\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\nφ : LinearMap (RingHom.id R) L (Module.End R M)\ninst✝⁵ : Fintype ι\ninst✝⁴ : Fintype ιM\ninst✝³ : DecidableEq ι\ninst✝² : DecidableEq ιM\nb : Basis ι R L\nbₘ : Basis ιM R M\nιM' : Type u_8\ninst✝¹ : Fintype ιM'\ninst✝ : DecidableEq ιM'\nbₘ' : Basis ιM' R M\n⊢ Eq (φ.polyCharpolyAux b bₘ) (φ.polyCharpolyAux b bₘ')","decl":"open Algebra.TensorProduct MvPolynomial in\n/-- `LinearMap.polyCharpolyAux` is independent of the choice of basis of the target module.\n\nProof strategy:\n1. Rewrite `polyCharpolyAux` as the (honest, ordinary) characteristic polynomial\n   of the basechange of `φ` to the multivariate polynomial ring `MvPolynomial ι R`.\n2. Use that the characteristic polynomial of a linear map is independent of the choice of basis.\n   This independence result is used transitively via\n   `LinearMap.polyCharpolyAux_map_aeval` and `LinearMap.polyCharpolyAux_map_eq_charpoly`. -/\nlemma polyCharpolyAux_basisIndep {ιM' : Type*} [Fintype ιM'] [DecidableEq ιM']\n    (bₘ' : Basis ιM' R M) :\n    polyCharpolyAux φ b bₘ = polyCharpolyAux φ b bₘ' := by\n  let f : Polynomial (MvPolynomial ι R) → Polynomial (MvPolynomial ι R) :=\n    Polynomial.map (MvPolynomial.aeval X).toRingHom\n  have hf : Function.Injective f := by\n    simp only [f, aeval_X_left, AlgHom.toRingHom_eq_coe, AlgHom.id_toRingHom, Polynomial.map_id]\n    exact Polynomial.map_injective (RingHom.id _) Function.injective_id\n  apply hf\n  let _h1 : Module.Finite (MvPolynomial ι R) (TensorProduct R (MvPolynomial ι R) M) :=\n    Module.Finite.of_basis (basis (MvPolynomial ι R) bₘ)\n  let _h2 : Module.Free (MvPolynomial ι R) (TensorProduct R (MvPolynomial ι R) M) :=\n    Module.Free.of_basis (basis (MvPolynomial ι R) bₘ)\n  simp only [f, polyCharpolyAux_map_aeval, polyCharpolyAux_map_aeval]\n\n"}
{"name":"LinearMap.polyCharpoly_eq_of_basis","module":"Mathlib.Algebra.Module.LinearMap.Polynomial","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\nι : Type u_5\nιM : Type u_7\ninst✝¹⁰ : CommRing R\ninst✝⁹ : AddCommGroup L\ninst✝⁸ : Module R L\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\nφ : LinearMap (RingHom.id R) L (Module.End R M)\ninst✝⁵ : Fintype ι\ninst✝⁴ : Fintype ιM\ninst✝³ : DecidableEq ι\ninst✝² : Module.Free R M\ninst✝¹ : Module.Finite R M\nb : Basis ι R L\ninst✝ : DecidableEq ιM\nbₘ : Basis ιM R M\n⊢ Eq (φ.polyCharpoly b) (Polynomial.map (↑(MvPolynomial.bind₁ (LinearMap.toMvPolynomial b bₘ.end φ))) (Matrix.charpoly.univ R ιM))","decl":"lemma polyCharpoly_eq_of_basis [DecidableEq ιM] (bₘ : Basis ιM R M) :\n    polyCharpoly φ b =\n    (charpoly.univ R ιM).map (MvPolynomial.bind₁ (φ.toMvPolynomial b bₘ.end)) := by\n  rw [polyCharpoly, φ.polyCharpolyAux_basisIndep b (Module.Free.chooseBasis R M) bₘ,\n    polyCharpolyAux]\n\n"}
{"name":"LinearMap.polyCharpoly_monic","module":"Mathlib.Algebra.Module.LinearMap.Polynomial","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\nι : Type u_5\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup L\ninst✝⁶ : Module R L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\nφ : LinearMap (RingHom.id R) L (Module.End R M)\ninst✝³ : Fintype ι\ninst✝² : DecidableEq ι\ninst✝¹ : Module.Free R M\ninst✝ : Module.Finite R M\nb : Basis ι R L\n⊢ (φ.polyCharpoly b).Monic","decl":"lemma polyCharpoly_monic : (polyCharpoly φ b).Monic :=\n  (charpoly.univ_monic R _).map _\n\n"}
{"name":"LinearMap.polyCharpoly_ne_zero","module":"Mathlib.Algebra.Module.LinearMap.Polynomial","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\nι : Type u_5\ninst✝⁹ : CommRing R\ninst✝⁸ : AddCommGroup L\ninst✝⁷ : Module R L\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : Module R M\nφ : LinearMap (RingHom.id R) L (Module.End R M)\ninst✝⁴ : Fintype ι\ninst✝³ : DecidableEq ι\ninst✝² : Module.Free R M\ninst✝¹ : Module.Finite R M\nb : Basis ι R L\ninst✝ : Nontrivial R\n⊢ Ne (φ.polyCharpoly b) 0","decl":"lemma polyCharpoly_ne_zero [Nontrivial R] : (polyCharpoly φ b) ≠ 0 :=\n  (polyCharpoly_monic _ _).ne_zero\n\n"}
{"name":"LinearMap.polyCharpoly_natDegree","module":"Mathlib.Algebra.Module.LinearMap.Polynomial","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\nι : Type u_5\ninst✝⁹ : CommRing R\ninst✝⁸ : AddCommGroup L\ninst✝⁷ : Module R L\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : Module R M\nφ : LinearMap (RingHom.id R) L (Module.End R M)\ninst✝⁴ : Fintype ι\ninst✝³ : DecidableEq ι\ninst✝² : Module.Free R M\ninst✝¹ : Module.Finite R M\nb : Basis ι R L\ninst✝ : Nontrivial R\n⊢ Eq (φ.polyCharpoly b).natDegree (Module.finrank R M)","decl":"@[simp]\nlemma polyCharpoly_natDegree [Nontrivial R] :\n    (polyCharpoly φ b).natDegree = finrank R M := by\n  rw [polyCharpoly, polyCharpolyAux, (charpoly.univ_monic _ _).natDegree_map,\n    charpoly.univ_natDegree, finrank_eq_card_chooseBasisIndex]\n\n"}
{"name":"LinearMap.polyCharpoly_coeff_isHomogeneous","module":"Mathlib.Algebra.Module.LinearMap.Polynomial","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\nι : Type u_5\ninst✝⁹ : CommRing R\ninst✝⁸ : AddCommGroup L\ninst✝⁷ : Module R L\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : Module R M\nφ : LinearMap (RingHom.id R) L (Module.End R M)\ninst✝⁴ : Fintype ι\ninst✝³ : DecidableEq ι\ninst✝² : Module.Free R M\ninst✝¹ : Module.Finite R M\nb : Basis ι R L\ni j : Nat\nhij : Eq (HAdd.hAdd i j) (Module.finrank R M)\ninst✝ : Nontrivial R\n⊢ ((φ.polyCharpoly b).coeff i).IsHomogeneous j","decl":"lemma polyCharpoly_coeff_isHomogeneous (i j : ℕ) (hij : i + j = finrank R M) [Nontrivial R] :\n    ((polyCharpoly φ b).coeff i).IsHomogeneous j := by\n  rw [finrank_eq_card_chooseBasisIndex] at hij\n  rw [polyCharpoly, polyCharpolyAux, Polynomial.coeff_map, ← one_mul j]\n  apply (charpoly.univ_coeff_isHomogeneous _ _ _ _ hij).eval₂\n  · exact fun r ↦ MvPolynomial.isHomogeneous_C _ _\n  · exact LinearMap.toMvPolynomial_isHomogeneous _ _ _\n\n"}
{"name":"LinearMap.polyCharpoly_baseChange","module":"Mathlib.Algebra.Module.LinearMap.Polynomial","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\nι : Type u_5\ninst✝¹⁰ : CommRing R\ninst✝⁹ : AddCommGroup L\ninst✝⁸ : Module R L\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\nφ : LinearMap (RingHom.id R) L (Module.End R M)\ninst✝⁵ : Fintype ι\ninst✝⁴ : DecidableEq ι\ninst✝³ : Module.Free R M\ninst✝² : Module.Finite R M\nb : Basis ι R L\nA : Type u_8\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\n⊢ Eq (((LinearMap.tensorProduct R A M M).comp (LinearMap.baseChange A φ)).polyCharpoly (Algebra.TensorProduct.basis A b)) (Polynomial.map (MvPolynomial.map (algebraMap R A)) (φ.polyCharpoly b))","decl":"open Algebra.TensorProduct MvPolynomial in\nlemma polyCharpoly_baseChange (A : Type*) [CommRing A] [Algebra R A] :\n    polyCharpoly (tensorProduct _ _ _ _ ∘ₗ φ.baseChange A) (basis A b) =\n      (polyCharpoly φ b).map (MvPolynomial.map (algebraMap R A)) := by\n  unfold polyCharpoly\n  rw [← φ.polyCharpolyAux_baseChange]\n  apply polyCharpolyAux_basisIndep\n\n"}
{"name":"LinearMap.polyCharpoly_map_eq_charpoly","module":"Mathlib.Algebra.Module.LinearMap.Polynomial","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\nι : Type u_5\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup L\ninst✝⁶ : Module R L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\nφ : LinearMap (RingHom.id R) L (Module.End R M)\ninst✝³ : Fintype ι\ninst✝² : DecidableEq ι\ninst✝¹ : Module.Free R M\ninst✝ : Module.Finite R M\nb : Basis ι R L\nx : L\n⊢ Eq (Polynomial.map (MvPolynomial.eval ⇑(b.repr x)) (φ.polyCharpoly b)) (LinearMap.charpoly (φ x))","decl":"@[simp]\nlemma polyCharpoly_map_eq_charpoly (x : L) :\n    (polyCharpoly φ b).map (MvPolynomial.eval (b.repr x)) = (φ x).charpoly := by\n  rw [polyCharpoly, polyCharpolyAux_map_eq_charpoly]\n\n"}
{"name":"LinearMap.polyCharpoly_coeff_eval","module":"Mathlib.Algebra.Module.LinearMap.Polynomial","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\nι : Type u_5\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup L\ninst✝⁶ : Module R L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\nφ : LinearMap (RingHom.id R) L (Module.End R M)\ninst✝³ : Fintype ι\ninst✝² : DecidableEq ι\ninst✝¹ : Module.Free R M\ninst✝ : Module.Finite R M\nb : Basis ι R L\nx : L\ni : Nat\n⊢ Eq ((MvPolynomial.eval ⇑(b.repr x)) ((φ.polyCharpoly b).coeff i)) ((LinearMap.charpoly (φ x)).coeff i)","decl":"@[simp]\nlemma polyCharpoly_coeff_eval (x : L) (i : ℕ) :\n    MvPolynomial.eval (b.repr x) ((polyCharpoly φ b).coeff i) = (φ x).charpoly.coeff i := by\n  rw [polyCharpoly, polyCharpolyAux_coeff_eval]\n\n"}
{"name":"LinearMap.polyCharpoly_coeff_eq_zero_of_basis","module":"Mathlib.Algebra.Module.LinearMap.Polynomial","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\nι : Type u_5\nι' : Type u_6\ninst✝¹⁰ : CommRing R\ninst✝⁹ : AddCommGroup L\ninst✝⁸ : Module R L\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\nφ : LinearMap (RingHom.id R) L (Module.End R M)\ninst✝⁵ : Fintype ι\ninst✝⁴ : Fintype ι'\ninst✝³ : DecidableEq ι\ninst✝² : DecidableEq ι'\ninst✝¹ : Module.Free R M\ninst✝ : Module.Finite R M\nb : Basis ι R L\nb' : Basis ι' R L\nk : Nat\nH : Eq ((φ.polyCharpoly b).coeff k) 0\n⊢ Eq ((φ.polyCharpoly b').coeff k) 0","decl":"lemma polyCharpoly_coeff_eq_zero_of_basis (b : Basis ι R L) (b' : Basis ι' R L) (k : ℕ)\n    (H : (polyCharpoly φ b).coeff k = 0) :\n    (polyCharpoly φ b').coeff k = 0 := by\n  rw [polyCharpoly, polyCharpolyAux, Polynomial.coeff_map] at H ⊢\n  set B := (Module.Free.chooseBasis R M).end\n  set g := toMvPolynomial b' b LinearMap.id\n  apply_fun (MvPolynomial.bind₁ g) at H\n  have : toMvPolynomial b' B φ = fun i ↦ (MvPolynomial.bind₁ g) (toMvPolynomial b B φ i) :=\n    funext <| toMvPolynomial_comp b' b B φ LinearMap.id\n  rwa [map_zero, RingHom.coe_coe, MvPolynomial.bind₁_bind₁, ← this] at H\n\n"}
{"name":"LinearMap.polyCharpoly_coeff_eq_zero_iff_of_basis","module":"Mathlib.Algebra.Module.LinearMap.Polynomial","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\nι : Type u_5\nι' : Type u_6\ninst✝¹⁰ : CommRing R\ninst✝⁹ : AddCommGroup L\ninst✝⁸ : Module R L\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\nφ : LinearMap (RingHom.id R) L (Module.End R M)\ninst✝⁵ : Fintype ι\ninst✝⁴ : Fintype ι'\ninst✝³ : DecidableEq ι\ninst✝² : DecidableEq ι'\ninst✝¹ : Module.Free R M\ninst✝ : Module.Finite R M\nb : Basis ι R L\nb' : Basis ι' R L\nk : Nat\n⊢ Iff (Eq ((φ.polyCharpoly b).coeff k) 0) (Eq ((φ.polyCharpoly b').coeff k) 0)","decl":"lemma polyCharpoly_coeff_eq_zero_iff_of_basis (b : Basis ι R L) (b' : Basis ι' R L) (k : ℕ) :\n    (polyCharpoly φ b).coeff k = 0 ↔ (polyCharpoly φ b').coeff k = 0 := by\n  constructor <;> apply polyCharpoly_coeff_eq_zero_of_basis\n\n"}
{"name":"LinearMap.polyCharpoly_coeff_nilRankAux_ne_zero","module":"Mathlib.Algebra.Module.LinearMap.Polynomial","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\nι : Type u_5\ninst✝⁹ : CommRing R\ninst✝⁸ : AddCommGroup L\ninst✝⁷ : Module R L\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : Module R M\nφ : LinearMap (RingHom.id R) L (Module.End R M)\ninst✝⁴ : Fintype ι\ninst✝³ : DecidableEq ι\ninst✝² : Module.Free R M\ninst✝¹ : Module.Finite R M\nb : Basis ι R L\ninst✝ : Nontrivial R\n⊢ Ne ((φ.polyCharpoly b).coeff (φ.nilRankAux b)) 0","decl":"lemma polyCharpoly_coeff_nilRankAux_ne_zero [Nontrivial R] :\n    (polyCharpoly φ b).coeff (nilRankAux φ b) ≠ 0 := by\n  apply Polynomial.trailingCoeff_nonzero_iff_nonzero.mpr\n  apply polyCharpoly_ne_zero\n\n"}
{"name":"LinearMap.nilRankAux_le","module":"Mathlib.Algebra.Module.LinearMap.Polynomial","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\nι : Type u_5\nι' : Type u_6\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : AddCommGroup L\ninst✝⁹ : Module R L\ninst✝⁸ : AddCommGroup M\ninst✝⁷ : Module R M\nφ : LinearMap (RingHom.id R) L (Module.End R M)\ninst✝⁶ : Fintype ι\ninst✝⁵ : Fintype ι'\ninst✝⁴ : DecidableEq ι\ninst✝³ : DecidableEq ι'\ninst✝² : Module.Free R M\ninst✝¹ : Module.Finite R M\ninst✝ : Nontrivial R\nb : Basis ι R L\nb' : Basis ι' R L\n⊢ LE.le (φ.nilRankAux b) (φ.nilRankAux b')","decl":"lemma nilRankAux_le [Nontrivial R] (b : Basis ι R L) (b' : Basis ι' R L) :\n    nilRankAux φ b ≤ nilRankAux φ b' := by\n  apply Polynomial.natTrailingDegree_le_of_ne_zero\n  rw [Ne, (polyCharpoly_coeff_eq_zero_iff_of_basis φ b b' _).not]\n  apply polyCharpoly_coeff_nilRankAux_ne_zero\n\n"}
{"name":"LinearMap.nilRankAux_basis_indep","module":"Mathlib.Algebra.Module.LinearMap.Polynomial","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\nι : Type u_5\nι' : Type u_6\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : AddCommGroup L\ninst✝⁹ : Module R L\ninst✝⁸ : AddCommGroup M\ninst✝⁷ : Module R M\nφ : LinearMap (RingHom.id R) L (Module.End R M)\ninst✝⁶ : Fintype ι\ninst✝⁵ : Fintype ι'\ninst✝⁴ : DecidableEq ι\ninst✝³ : DecidableEq ι'\ninst✝² : Module.Free R M\ninst✝¹ : Module.Finite R M\ninst✝ : Nontrivial R\nb : Basis ι R L\nb' : Basis ι' R L\n⊢ Eq (φ.nilRankAux b) (φ.polyCharpoly b').natTrailingDegree","decl":"lemma nilRankAux_basis_indep [Nontrivial R] (b : Basis ι R L) (b' : Basis ι' R L) :\n    nilRankAux φ b = (polyCharpoly φ b').natTrailingDegree := by\n  apply le_antisymm <;> apply nilRankAux_le\n\n"}
{"name":"LinearMap.nilRank_eq_polyCharpoly_natTrailingDegree","module":"Mathlib.Algebra.Module.LinearMap.Polynomial","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\nι : Type u_5\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : AddCommGroup L\ninst✝⁹ : Module R L\ninst✝⁸ : AddCommGroup M\ninst✝⁷ : Module R M\nφ : LinearMap (RingHom.id R) L (Module.End R M)\ninst✝⁶ : Fintype ι\ninst✝⁵ : DecidableEq ι\ninst✝⁴ : Module.Free R M\ninst✝³ : Module.Finite R M\ninst✝² : Module.Finite R L\ninst✝¹ : Module.Free R L\ninst✝ : Nontrivial R\nb : Basis ι R L\n⊢ Eq φ.nilRank (φ.polyCharpoly b).natTrailingDegree","decl":"lemma nilRank_eq_polyCharpoly_natTrailingDegree (b : Basis ι R L) :\n    nilRank φ = (polyCharpoly φ b).natTrailingDegree := by\n  apply nilRankAux_basis_indep\n\n"}
{"name":"LinearMap.polyCharpoly_coeff_nilRank_ne_zero","module":"Mathlib.Algebra.Module.LinearMap.Polynomial","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\nι : Type u_5\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : AddCommGroup L\ninst✝⁹ : Module R L\ninst✝⁸ : AddCommGroup M\ninst✝⁷ : Module R M\nφ : LinearMap (RingHom.id R) L (Module.End R M)\ninst✝⁶ : Fintype ι\ninst✝⁵ : DecidableEq ι\ninst✝⁴ : Module.Free R M\ninst✝³ : Module.Finite R M\nb : Basis ι R L\ninst✝² : Module.Finite R L\ninst✝¹ : Module.Free R L\ninst✝ : Nontrivial R\n⊢ Ne ((φ.polyCharpoly b).coeff φ.nilRank) 0","decl":"lemma polyCharpoly_coeff_nilRank_ne_zero :\n    (polyCharpoly φ b).coeff (nilRank φ) ≠ 0 := by\n  rw [nilRank_eq_polyCharpoly_natTrailingDegree _ b]\n  apply polyCharpoly_coeff_nilRankAux_ne_zero\n\n"}
{"name":"LinearMap.nilRank_le_card","module":"Mathlib.Algebra.Module.LinearMap.Polynomial","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝¹⁰ : CommRing R\ninst✝⁹ : AddCommGroup L\ninst✝⁸ : Module R L\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\nφ : LinearMap (RingHom.id R) L (Module.End R M)\ninst✝⁵ : Module.Free R M\ninst✝⁴ : Module.Finite R M\ninst✝³ : Module.Finite R L\ninst✝² : Module.Free R L\ninst✝¹ : Nontrivial R\nι : Type u_8\ninst✝ : Fintype ι\nb : Basis ι R M\n⊢ LE.le φ.nilRank (Fintype.card ι)","decl":"lemma nilRank_le_card {ι : Type*} [Fintype ι] (b : Basis ι R M) : nilRank φ ≤ Fintype.card ι := by\n  apply Polynomial.natTrailingDegree_le_of_ne_zero\n  rw [← Module.finrank_eq_card_basis b, ← polyCharpoly_natDegree φ (chooseBasis R L),\n    Polynomial.coeff_natDegree, (polyCharpoly_monic _ _).leadingCoeff]\n  apply one_ne_zero\n\n"}
{"name":"LinearMap.nilRank_le_finrank","module":"Mathlib.Algebra.Module.LinearMap.Polynomial","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁹ : CommRing R\ninst✝⁸ : AddCommGroup L\ninst✝⁷ : Module R L\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : Module R M\nφ : LinearMap (RingHom.id R) L (Module.End R M)\ninst✝⁴ : Module.Free R M\ninst✝³ : Module.Finite R M\ninst✝² : Module.Finite R L\ninst✝¹ : Module.Free R L\ninst✝ : Nontrivial R\n⊢ LE.le φ.nilRank (Module.finrank R M)","decl":"lemma nilRank_le_finrank : nilRank φ ≤ finrank R M := by\n  simpa only [finrank_eq_card_chooseBasisIndex R M] using nilRank_le_card φ (chooseBasis R M)\n\n"}
{"name":"LinearMap.nilRank_le_natTrailingDegree_charpoly","module":"Mathlib.Algebra.Module.LinearMap.Polynomial","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁹ : CommRing R\ninst✝⁸ : AddCommGroup L\ninst✝⁷ : Module R L\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : Module R M\nφ : LinearMap (RingHom.id R) L (Module.End R M)\ninst✝⁴ : Module.Free R M\ninst✝³ : Module.Finite R M\ninst✝² : Module.Finite R L\ninst✝¹ : Module.Free R L\ninst✝ : Nontrivial R\nx : L\n⊢ LE.le φ.nilRank (LinearMap.charpoly (φ x)).natTrailingDegree","decl":"lemma nilRank_le_natTrailingDegree_charpoly (x : L) :\n    nilRank φ ≤ (φ x).charpoly.natTrailingDegree := by\n  apply Polynomial.natTrailingDegree_le_of_ne_zero\n  intro h\n  apply_fun (MvPolynomial.eval ((chooseBasis R L).repr x)) at h\n  rw [polyCharpoly_coeff_eval, map_zero] at h\n  apply Polynomial.trailingCoeff_nonzero_iff_nonzero.mpr _ h\n  apply (LinearMap.charpoly_monic _).ne_zero\n\n"}
{"name":"LinearMap.isNilRegular_def","module":"Mathlib.Algebra.Module.LinearMap.Polynomial","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup L\ninst✝⁶ : Module R L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\nφ : LinearMap (RingHom.id R) L (Module.End R M)\ninst✝³ : Module.Free R M\ninst✝² : Module.Finite R M\ninst✝¹ : Module.Finite R L\ninst✝ : Module.Free R L\nx : L\n⊢ Iff (φ.IsNilRegular x) (Ne ((LinearMap.charpoly (φ x)).coeff φ.nilRank) 0)","decl":"lemma isNilRegular_def :\n    IsNilRegular φ x ↔ (Polynomial.coeff (φ x).charpoly (nilRank φ) ≠ 0) := Iff.rfl\n\n"}
{"name":"LinearMap.isNilRegular_iff_coeff_polyCharpoly_nilRank_ne_zero","module":"Mathlib.Algebra.Module.LinearMap.Polynomial","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\nι : Type u_5\ninst✝¹⁰ : CommRing R\ninst✝⁹ : AddCommGroup L\ninst✝⁸ : Module R L\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\nφ : LinearMap (RingHom.id R) L (Module.End R M)\ninst✝⁵ : Fintype ι\ninst✝⁴ : DecidableEq ι\ninst✝³ : Module.Free R M\ninst✝² : Module.Finite R M\nb : Basis ι R L\ninst✝¹ : Module.Finite R L\ninst✝ : Module.Free R L\nx : L\n⊢ Iff (φ.IsNilRegular x) (Ne ((MvPolynomial.eval ⇑(b.repr x)) ((φ.polyCharpoly b).coeff φ.nilRank)) 0)","decl":"lemma isNilRegular_iff_coeff_polyCharpoly_nilRank_ne_zero :\n    IsNilRegular φ x ↔\n    MvPolynomial.eval (b.repr x)\n      ((polyCharpoly φ b).coeff (nilRank φ)) ≠ 0 := by\n  rw [IsNilRegular, polyCharpoly_coeff_eval]\n\n"}
{"name":"LinearMap.isNilRegular_iff_natTrailingDegree_charpoly_eq_nilRank","module":"Mathlib.Algebra.Module.LinearMap.Polynomial","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁹ : CommRing R\ninst✝⁸ : AddCommGroup L\ninst✝⁷ : Module R L\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : Module R M\nφ : LinearMap (RingHom.id R) L (Module.End R M)\ninst✝⁴ : Module.Free R M\ninst✝³ : Module.Finite R M\ninst✝² : Module.Finite R L\ninst✝¹ : Module.Free R L\nx : L\ninst✝ : Nontrivial R\n⊢ Iff (φ.IsNilRegular x) (Eq (LinearMap.charpoly (φ x)).natTrailingDegree φ.nilRank)","decl":"lemma isNilRegular_iff_natTrailingDegree_charpoly_eq_nilRank [Nontrivial R] :\n    IsNilRegular φ x ↔ (φ x).charpoly.natTrailingDegree = nilRank φ := by\n  rw [isNilRegular_def]\n  constructor\n  · intro h\n    exact le_antisymm\n      (Polynomial.natTrailingDegree_le_of_ne_zero h)\n      (nilRank_le_natTrailingDegree_charpoly φ x)\n  · intro h\n    rw [← h]\n    apply Polynomial.trailingCoeff_nonzero_iff_nonzero.mpr\n    apply (LinearMap.charpoly_monic _).ne_zero\n\n"}
{"name":"LinearMap.exists_isNilRegular_of_finrank_le_card","module":"Mathlib.Algebra.Module.LinearMap.Polynomial","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁹ : CommRing R\ninst✝⁸ : AddCommGroup L\ninst✝⁷ : Module R L\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : Module R M\nφ : LinearMap (RingHom.id R) L (Module.End R M)\ninst✝⁴ : Module.Free R M\ninst✝³ : Module.Finite R M\ninst✝² : Module.Finite R L\ninst✝¹ : Module.Free R L\ninst✝ : IsDomain R\nh : LE.le (↑(Module.finrank R M)) (Cardinal.mk R)\n⊢ Exists fun x => φ.IsNilRegular x","decl":"open Cardinal Module MvPolynomial Module.Free in\nlemma exists_isNilRegular_of_finrank_le_card (h : finrank R M ≤ #R) :\n    ∃ x : L, IsNilRegular φ x := by\n  let b := chooseBasis R L\n  let bₘ := chooseBasis R M\n  let n := Fintype.card (ChooseBasisIndex R M)\n  have aux :\n    ((polyCharpoly φ b).coeff (nilRank φ)).IsHomogeneous (n - nilRank φ) :=\n    polyCharpoly_coeff_isHomogeneous _ b (nilRank φ) (n - nilRank φ)\n      (by simp [n, nilRank_le_card φ bₘ, finrank_eq_card_chooseBasisIndex])\n  obtain ⟨x, hx⟩ : ∃ r, eval r ((polyCharpoly _ b).coeff (nilRank φ)) ≠ 0 := by\n    by_contra! h₀\n    apply polyCharpoly_coeff_nilRank_ne_zero φ b\n    apply aux.eq_zero_of_forall_eval_eq_zero_of_le_card h₀ (le_trans _ h)\n    simp only [n, finrank_eq_card_chooseBasisIndex, Nat.cast_le, Nat.sub_le]\n  let c := Finsupp.equivFunOnFinite.symm x\n  use b.repr.symm c\n  rwa [isNilRegular_iff_coeff_polyCharpoly_nilRank_ne_zero _ b, LinearEquiv.apply_symm_apply]\n\n"}
{"name":"LinearMap.exists_isNilRegular","module":"Mathlib.Algebra.Module.LinearMap.Polynomial","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝¹⁰ : CommRing R\ninst✝⁹ : AddCommGroup L\ninst✝⁸ : Module R L\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\nφ : LinearMap (RingHom.id R) L (Module.End R M)\ninst✝⁵ : Module.Free R M\ninst✝⁴ : Module.Finite R M\ninst✝³ : Module.Finite R L\ninst✝² : Module.Free R L\ninst✝¹ : IsDomain R\ninst✝ : Infinite R\n⊢ Exists fun x => φ.IsNilRegular x","decl":"lemma exists_isNilRegular [Infinite R] : ∃ x : L, IsNilRegular φ x := by\n  apply exists_isNilRegular_of_finrank_le_card\n  exact (Cardinal.nat_lt_aleph0 _).le.trans <| Cardinal.infinite_iff.mp ‹Infinite R›\n\n"}
