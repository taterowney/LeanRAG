{"name":"InnerProductSpace.smul_left","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"ğ•œ : Type u_4\nE : Type u_5\ninstâœÂ¹ : RCLike ğ•œ\ninstâœ : SeminormedAddCommGroup E\nself : InnerProductSpace ğ•œ E\nx y : E\nr : ğ•œ\nâŠ¢ Eq (Inner.inner (HSMul.hSMul r x) y) (HMul.hMul ((starRingEnd ğ•œ) r) (Inner.inner x y))","decl":"/-- A (pre) inner product space is a vector space with an additional operation called inner product.\nThe (semi)norm could be derived from the inner product, instead we require the existence of a\nseminorm and the fact that `â€–xâ€–^2 = re âŸªx, xâŸ«` to be able to put instances on `ğ•‚` or product spaces.\n\nNote that `NormedSpace` does not assume that `â€–xâ€–=0` implies `x=0` (it is rather a seminorm).\n\nTo construct a seminorm from an inner product, see `PreInnerProductSpace.ofCore`.\n-/\nclass InnerProductSpace (ğ•œ : Type*) (E : Type*) [RCLike ğ•œ] [SeminormedAddCommGroup E] extends\n  NormedSpace ğ•œ E, Inner ğ•œ E where\n  /-- The inner product induces the norm. -/\n  norm_sq_eq_inner : âˆ€ x : E, â€–xâ€– ^ 2 = re (inner x x)\n  /-- The inner product is *hermitian*, taking the `conj` swaps the arguments. -/\n  conj_symm : âˆ€ x y, conj (inner y x) = inner x y\n  /-- The inner product is additive in the first coordinate. -/\n  add_left : âˆ€ x y z, inner (x + y) z = inner x z + inner y z\n  /-- The inner product is conjugate linear in the first coordinate. -/\n  smul_left : âˆ€ x y r, inner (r â€¢ x) y = conj r * inner x y\n\n"}
{"name":"InnerProductSpace.norm_sq_eq_inner","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"ğ•œ : Type u_4\nE : Type u_5\ninstâœÂ¹ : RCLike ğ•œ\ninstâœ : SeminormedAddCommGroup E\nself : InnerProductSpace ğ•œ E\nx : E\nâŠ¢ Eq (HPow.hPow (Norm.norm x) 2) (RCLike.re (Inner.inner x x))","decl":"/-- A (pre) inner product space is a vector space with an additional operation called inner product.\nThe (semi)norm could be derived from the inner product, instead we require the existence of a\nseminorm and the fact that `â€–xâ€–^2 = re âŸªx, xâŸ«` to be able to put instances on `ğ•‚` or product spaces.\n\nNote that `NormedSpace` does not assume that `â€–xâ€–=0` implies `x=0` (it is rather a seminorm).\n\nTo construct a seminorm from an inner product, see `PreInnerProductSpace.ofCore`.\n-/\nclass InnerProductSpace (ğ•œ : Type*) (E : Type*) [RCLike ğ•œ] [SeminormedAddCommGroup E] extends\n  NormedSpace ğ•œ E, Inner ğ•œ E where\n  /-- The inner product induces the norm. -/\n  norm_sq_eq_inner : âˆ€ x : E, â€–xâ€– ^ 2 = re (inner x x)\n  /-- The inner product is *hermitian*, taking the `conj` swaps the arguments. -/\n  conj_symm : âˆ€ x y, conj (inner y x) = inner x y\n  /-- The inner product is additive in the first coordinate. -/\n  add_left : âˆ€ x y z, inner (x + y) z = inner x z + inner y z\n  /-- The inner product is conjugate linear in the first coordinate. -/\n  smul_left : âˆ€ x y r, inner (r â€¢ x) y = conj r * inner x y\n\n"}
{"name":"InnerProductSpace.conj_symm","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"ğ•œ : Type u_4\nE : Type u_5\ninstâœÂ¹ : RCLike ğ•œ\ninstâœ : SeminormedAddCommGroup E\nself : InnerProductSpace ğ•œ E\nx y : E\nâŠ¢ Eq ((starRingEnd ğ•œ) (Inner.inner y x)) (Inner.inner x y)","decl":"/-- A (pre) inner product space is a vector space with an additional operation called inner product.\nThe (semi)norm could be derived from the inner product, instead we require the existence of a\nseminorm and the fact that `â€–xâ€–^2 = re âŸªx, xâŸ«` to be able to put instances on `ğ•‚` or product spaces.\n\nNote that `NormedSpace` does not assume that `â€–xâ€–=0` implies `x=0` (it is rather a seminorm).\n\nTo construct a seminorm from an inner product, see `PreInnerProductSpace.ofCore`.\n-/\nclass InnerProductSpace (ğ•œ : Type*) (E : Type*) [RCLike ğ•œ] [SeminormedAddCommGroup E] extends\n  NormedSpace ğ•œ E, Inner ğ•œ E where\n  /-- The inner product induces the norm. -/\n  norm_sq_eq_inner : âˆ€ x : E, â€–xâ€– ^ 2 = re (inner x x)\n  /-- The inner product is *hermitian*, taking the `conj` swaps the arguments. -/\n  conj_symm : âˆ€ x y, conj (inner y x) = inner x y\n  /-- The inner product is additive in the first coordinate. -/\n  add_left : âˆ€ x y z, inner (x + y) z = inner x z + inner y z\n  /-- The inner product is conjugate linear in the first coordinate. -/\n  smul_left : âˆ€ x y r, inner (r â€¢ x) y = conj r * inner x y\n\n"}
{"name":"InnerProductSpace.add_left","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"ğ•œ : Type u_4\nE : Type u_5\ninstâœÂ¹ : RCLike ğ•œ\ninstâœ : SeminormedAddCommGroup E\nself : InnerProductSpace ğ•œ E\nx y z : E\nâŠ¢ Eq (Inner.inner (HAdd.hAdd x y) z) (HAdd.hAdd (Inner.inner x z) (Inner.inner y z))","decl":"/-- A (pre) inner product space is a vector space with an additional operation called inner product.\nThe (semi)norm could be derived from the inner product, instead we require the existence of a\nseminorm and the fact that `â€–xâ€–^2 = re âŸªx, xâŸ«` to be able to put instances on `ğ•‚` or product spaces.\n\nNote that `NormedSpace` does not assume that `â€–xâ€–=0` implies `x=0` (it is rather a seminorm).\n\nTo construct a seminorm from an inner product, see `PreInnerProductSpace.ofCore`.\n-/\nclass InnerProductSpace (ğ•œ : Type*) (E : Type*) [RCLike ğ•œ] [SeminormedAddCommGroup E] extends\n  NormedSpace ğ•œ E, Inner ğ•œ E where\n  /-- The inner product induces the norm. -/\n  norm_sq_eq_inner : âˆ€ x : E, â€–xâ€– ^ 2 = re (inner x x)\n  /-- The inner product is *hermitian*, taking the `conj` swaps the arguments. -/\n  conj_symm : âˆ€ x y, conj (inner y x) = inner x y\n  /-- The inner product is additive in the first coordinate. -/\n  add_left : âˆ€ x y z, inner (x + y) z = inner x z + inner y z\n  /-- The inner product is conjugate linear in the first coordinate. -/\n  smul_left : âˆ€ x y r, inner (r â€¢ x) y = conj r * inner x y\n\n"}
{"name":"PreInnerProductSpace.Core.mk.injEq","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"ğ•œ : Type u_4\nF : Type u_5\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : AddCommGroup F\ninstâœ : Module ğ•œ F\ntoInnerâœ : Inner ğ•œ F\nconj_symmâœ : âˆ€ (x y : F), Eq ((starRingEnd ğ•œ) (Inner.inner y x)) (Inner.inner x y)\nnonneg_reâœ : âˆ€ (x : F), LE.le 0 (RCLike.re (Inner.inner x x))\nadd_leftâœ : âˆ€ (x y z : F), Eq (Inner.inner (HAdd.hAdd x y) z) (HAdd.hAdd (Inner.inner x z) (Inner.inner y z))\nsmul_leftâœ : âˆ€ (x y : F) (r : ğ•œ), Eq (Inner.inner (HSMul.hSMul r x) y) (HMul.hMul ((starRingEnd ğ•œ) r) (Inner.inner x y))\ntoInner : Inner ğ•œ F\nconj_symm : âˆ€ (x y : F), Eq ((starRingEnd ğ•œ) (Inner.inner y x)) (Inner.inner x y)\nnonneg_re : âˆ€ (x : F), LE.le 0 (RCLike.re (Inner.inner x x))\nadd_left : âˆ€ (x y z : F), Eq (Inner.inner (HAdd.hAdd x y) z) (HAdd.hAdd (Inner.inner x z) (Inner.inner y z))\nsmul_left : âˆ€ (x y : F) (r : ğ•œ), Eq (Inner.inner (HSMul.hSMul r x) y) (HMul.hMul ((starRingEnd ğ•œ) r) (Inner.inner x y))\nâŠ¢ Eq (Eq { toInner := toInnerâœ, conj_symm := conj_symmâœ, nonneg_re := nonneg_reâœ, add_left := add_leftâœ, smul_left := smul_leftâœ } { toInner := toInner, conj_symm := conj_symm, nonneg_re := nonneg_re, add_left := add_left, smul_left := smul_left }) (Eq toInnerâœ toInner)","decl":"/-- A structure requiring that a scalar product is positive semidefinite and symmetric. -/\nstructure PreInnerProductSpace.Core (ğ•œ : Type*) (F : Type*) [RCLike ğ•œ] [AddCommGroup F]\n  [Module ğ•œ F] extends Inner ğ•œ F where\n  /-- The inner product is *hermitian*, taking the `conj` swaps the arguments. -/\n  conj_symm : âˆ€ x y, conj (inner y x) = inner x y\n  /-- The inner product is positive (semi)definite. -/\n  nonneg_re : âˆ€ x, 0 â‰¤ re (inner x x)\n  /-- The inner product is additive in the first coordinate. -/\n  add_left : âˆ€ x y z, inner (x + y) z = inner x z + inner y z\n  /-- The inner product is conjugate linear in the first coordinate. -/\n  smul_left : âˆ€ x y r, inner (r â€¢ x) y = conj r * inner x y\n\n"}
{"name":"PreInnerProductSpace.Core.smul_left","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"ğ•œ : Type u_4\nF : Type u_5\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : AddCommGroup F\ninstâœ : Module ğ•œ F\nself : PreInnerProductSpace.Core ğ•œ F\nx y : F\nr : ğ•œ\nâŠ¢ Eq (Inner.inner (HSMul.hSMul r x) y) (HMul.hMul ((starRingEnd ğ•œ) r) (Inner.inner x y))","decl":"/-- A structure requiring that a scalar product is positive semidefinite and symmetric. -/\nstructure PreInnerProductSpace.Core (ğ•œ : Type*) (F : Type*) [RCLike ğ•œ] [AddCommGroup F]\n  [Module ğ•œ F] extends Inner ğ•œ F where\n  /-- The inner product is *hermitian*, taking the `conj` swaps the arguments. -/\n  conj_symm : âˆ€ x y, conj (inner y x) = inner x y\n  /-- The inner product is positive (semi)definite. -/\n  nonneg_re : âˆ€ x, 0 â‰¤ re (inner x x)\n  /-- The inner product is additive in the first coordinate. -/\n  add_left : âˆ€ x y z, inner (x + y) z = inner x z + inner y z\n  /-- The inner product is conjugate linear in the first coordinate. -/\n  smul_left : âˆ€ x y r, inner (r â€¢ x) y = conj r * inner x y\n\n"}
{"name":"PreInnerProductSpace.Core.mk.sizeOf_spec","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"ğ•œ : Type u_4\nF : Type u_5\ninstâœâ´ : RCLike ğ•œ\ninstâœÂ³ : AddCommGroup F\ninstâœÂ² : Module ğ•œ F\ninstâœÂ¹ : SizeOf ğ•œ\ninstâœ : SizeOf F\ntoInner : Inner ğ•œ F\nconj_symm : âˆ€ (x y : F), Eq ((starRingEnd ğ•œ) (Inner.inner y x)) (Inner.inner x y)\nnonneg_re : âˆ€ (x : F), LE.le 0 (RCLike.re (Inner.inner x x))\nadd_left : âˆ€ (x y z : F), Eq (Inner.inner (HAdd.hAdd x y) z) (HAdd.hAdd (Inner.inner x z) (Inner.inner y z))\nsmul_left : âˆ€ (x y : F) (r : ğ•œ), Eq (Inner.inner (HSMul.hSMul r x) y) (HMul.hMul ((starRingEnd ğ•œ) r) (Inner.inner x y))\nâŠ¢ Eq (SizeOf.sizeOf { toInner := toInner, conj_symm := conj_symm, nonneg_re := nonneg_re, add_left := add_left, smul_left := smul_left }) (HAdd.hAdd 1 (SizeOf.sizeOf toInner))","decl":"/-- A structure requiring that a scalar product is positive semidefinite and symmetric. -/\nstructure PreInnerProductSpace.Core (ğ•œ : Type*) (F : Type*) [RCLike ğ•œ] [AddCommGroup F]\n  [Module ğ•œ F] extends Inner ğ•œ F where\n  /-- The inner product is *hermitian*, taking the `conj` swaps the arguments. -/\n  conj_symm : âˆ€ x y, conj (inner y x) = inner x y\n  /-- The inner product is positive (semi)definite. -/\n  nonneg_re : âˆ€ x, 0 â‰¤ re (inner x x)\n  /-- The inner product is additive in the first coordinate. -/\n  add_left : âˆ€ x y z, inner (x + y) z = inner x z + inner y z\n  /-- The inner product is conjugate linear in the first coordinate. -/\n  smul_left : âˆ€ x y r, inner (r â€¢ x) y = conj r * inner x y\n\n"}
{"name":"PreInnerProductSpace.Core.conj_symm","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"ğ•œ : Type u_4\nF : Type u_5\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : AddCommGroup F\ninstâœ : Module ğ•œ F\nself : PreInnerProductSpace.Core ğ•œ F\nx y : F\nâŠ¢ Eq ((starRingEnd ğ•œ) (Inner.inner y x)) (Inner.inner x y)","decl":"/-- A structure requiring that a scalar product is positive semidefinite and symmetric. -/\nstructure PreInnerProductSpace.Core (ğ•œ : Type*) (F : Type*) [RCLike ğ•œ] [AddCommGroup F]\n  [Module ğ•œ F] extends Inner ğ•œ F where\n  /-- The inner product is *hermitian*, taking the `conj` swaps the arguments. -/\n  conj_symm : âˆ€ x y, conj (inner y x) = inner x y\n  /-- The inner product is positive (semi)definite. -/\n  nonneg_re : âˆ€ x, 0 â‰¤ re (inner x x)\n  /-- The inner product is additive in the first coordinate. -/\n  add_left : âˆ€ x y z, inner (x + y) z = inner x z + inner y z\n  /-- The inner product is conjugate linear in the first coordinate. -/\n  smul_left : âˆ€ x y r, inner (r â€¢ x) y = conj r * inner x y\n\n"}
{"name":"PreInnerProductSpace.Core.nonneg_re","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"ğ•œ : Type u_4\nF : Type u_5\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : AddCommGroup F\ninstâœ : Module ğ•œ F\nself : PreInnerProductSpace.Core ğ•œ F\nx : F\nâŠ¢ LE.le 0 (RCLike.re (Inner.inner x x))","decl":"/-- A structure requiring that a scalar product is positive semidefinite and symmetric. -/\nstructure PreInnerProductSpace.Core (ğ•œ : Type*) (F : Type*) [RCLike ğ•œ] [AddCommGroup F]\n  [Module ğ•œ F] extends Inner ğ•œ F where\n  /-- The inner product is *hermitian*, taking the `conj` swaps the arguments. -/\n  conj_symm : âˆ€ x y, conj (inner y x) = inner x y\n  /-- The inner product is positive (semi)definite. -/\n  nonneg_re : âˆ€ x, 0 â‰¤ re (inner x x)\n  /-- The inner product is additive in the first coordinate. -/\n  add_left : âˆ€ x y z, inner (x + y) z = inner x z + inner y z\n  /-- The inner product is conjugate linear in the first coordinate. -/\n  smul_left : âˆ€ x y r, inner (r â€¢ x) y = conj r * inner x y\n\n"}
{"name":"PreInnerProductSpace.Core.add_left","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"ğ•œ : Type u_4\nF : Type u_5\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : AddCommGroup F\ninstâœ : Module ğ•œ F\nself : PreInnerProductSpace.Core ğ•œ F\nx y z : F\nâŠ¢ Eq (Inner.inner (HAdd.hAdd x y) z) (HAdd.hAdd (Inner.inner x z) (Inner.inner y z))","decl":"/-- A structure requiring that a scalar product is positive semidefinite and symmetric. -/\nstructure PreInnerProductSpace.Core (ğ•œ : Type*) (F : Type*) [RCLike ğ•œ] [AddCommGroup F]\n  [Module ğ•œ F] extends Inner ğ•œ F where\n  /-- The inner product is *hermitian*, taking the `conj` swaps the arguments. -/\n  conj_symm : âˆ€ x y, conj (inner y x) = inner x y\n  /-- The inner product is positive (semi)definite. -/\n  nonneg_re : âˆ€ x, 0 â‰¤ re (inner x x)\n  /-- The inner product is additive in the first coordinate. -/\n  add_left : âˆ€ x y z, inner (x + y) z = inner x z + inner y z\n  /-- The inner product is conjugate linear in the first coordinate. -/\n  smul_left : âˆ€ x y r, inner (r â€¢ x) y = conj r * inner x y\n\n"}
{"name":"PreInnerProductSpace.Core.mk.inj","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"ğ•œ : Type u_4\nF : Type u_5\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : AddCommGroup F\ninstâœ : Module ğ•œ F\ntoInnerâœ : Inner ğ•œ F\nconj_symmâœ : âˆ€ (x y : F), Eq ((starRingEnd ğ•œ) (Inner.inner y x)) (Inner.inner x y)\nnonneg_reâœ : âˆ€ (x : F), LE.le 0 (RCLike.re (Inner.inner x x))\nadd_leftâœ : âˆ€ (x y z : F), Eq (Inner.inner (HAdd.hAdd x y) z) (HAdd.hAdd (Inner.inner x z) (Inner.inner y z))\nsmul_leftâœ : âˆ€ (x y : F) (r : ğ•œ), Eq (Inner.inner (HSMul.hSMul r x) y) (HMul.hMul ((starRingEnd ğ•œ) r) (Inner.inner x y))\ntoInner : Inner ğ•œ F\nconj_symm : âˆ€ (x y : F), Eq ((starRingEnd ğ•œ) (Inner.inner y x)) (Inner.inner x y)\nnonneg_re : âˆ€ (x : F), LE.le 0 (RCLike.re (Inner.inner x x))\nadd_left : âˆ€ (x y z : F), Eq (Inner.inner (HAdd.hAdd x y) z) (HAdd.hAdd (Inner.inner x z) (Inner.inner y z))\nsmul_left : âˆ€ (x y : F) (r : ğ•œ), Eq (Inner.inner (HSMul.hSMul r x) y) (HMul.hMul ((starRingEnd ğ•œ) r) (Inner.inner x y))\nxâœ : Eq { toInner := toInnerâœ, conj_symm := conj_symmâœ, nonneg_re := nonneg_reâœ, add_left := add_leftâœ, smul_left := smul_leftâœ } { toInner := toInner, conj_symm := conj_symm, nonneg_re := nonneg_re, add_left := add_left, smul_left := smul_left }\nâŠ¢ Eq toInnerâœ toInner","decl":"/-- A structure requiring that a scalar product is positive semidefinite and symmetric. -/\nstructure PreInnerProductSpace.Core (ğ•œ : Type*) (F : Type*) [RCLike ğ•œ] [AddCommGroup F]\n  [Module ğ•œ F] extends Inner ğ•œ F where\n  /-- The inner product is *hermitian*, taking the `conj` swaps the arguments. -/\n  conj_symm : âˆ€ x y, conj (inner y x) = inner x y\n  /-- The inner product is positive (semi)definite. -/\n  nonneg_re : âˆ€ x, 0 â‰¤ re (inner x x)\n  /-- The inner product is additive in the first coordinate. -/\n  add_left : âˆ€ x y z, inner (x + y) z = inner x z + inner y z\n  /-- The inner product is conjugate linear in the first coordinate. -/\n  smul_left : âˆ€ x y r, inner (r â€¢ x) y = conj r * inner x y\n\n"}
{"name":"InnerProductSpace.Core.definite","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"ğ•œ : Type u_4\nF : Type u_5\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : AddCommGroup F\ninstâœ : Module ğ•œ F\nself : InnerProductSpace.Core ğ•œ F\nx : F\naâœ : Eq (Inner.inner x x) 0\nâŠ¢ Eq x 0","decl":"/-- A structure requiring that a scalar product is positive definite. Some theorems that\nrequire this assumptions are put under section `InnerProductSpace.Core`. -/\n-- @[nolint HasNonemptyInstance] porting note: I don't think we have this linter anymore\nstructure InnerProductSpace.Core (ğ•œ : Type*) (F : Type*) [RCLike ğ•œ] [AddCommGroup F]\n  [Module ğ•œ F] extends PreInnerProductSpace.Core ğ•œ F where\n  /-- The inner product is positive definite. -/\n  definite : âˆ€ x, inner x x = 0 â†’ x = 0\n\n/- We set `InnerProductSpace.Core` to be a class as we will use it as such in the construction\nof the normed space structure that it produces. However, all the instances we will use will be\nlocal to this proof. -/\n"}
{"name":"InnerProductSpace.Core.mk.injEq","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"ğ•œ : Type u_4\nF : Type u_5\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : AddCommGroup F\ninstâœ : Module ğ•œ F\ntoCoreâœ : PreInnerProductSpace.Core ğ•œ F\ndefiniteâœ : âˆ€ (x : F), Eq (Inner.inner x x) 0 â†’ Eq x 0\ntoCore : PreInnerProductSpace.Core ğ•œ F\ndefinite : âˆ€ (x : F), Eq (Inner.inner x x) 0 â†’ Eq x 0\nâŠ¢ Eq (Eq { toCore := toCoreâœ, definite := definiteâœ } { toCore := toCore, definite := definite }) (Eq toCoreâœ toCore)","decl":"/-- A structure requiring that a scalar product is positive definite. Some theorems that\nrequire this assumptions are put under section `InnerProductSpace.Core`. -/\n-- @[nolint HasNonemptyInstance] porting note: I don't think we have this linter anymore\nstructure InnerProductSpace.Core (ğ•œ : Type*) (F : Type*) [RCLike ğ•œ] [AddCommGroup F]\n  [Module ğ•œ F] extends PreInnerProductSpace.Core ğ•œ F where\n  /-- The inner product is positive definite. -/\n  definite : âˆ€ x, inner x x = 0 â†’ x = 0\n\n/- We set `InnerProductSpace.Core` to be a class as we will use it as such in the construction\nof the normed space structure that it produces. However, all the instances we will use will be\nlocal to this proof. -/\n"}
{"name":"InnerProductSpace.Core.mk.inj","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"ğ•œ : Type u_4\nF : Type u_5\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : AddCommGroup F\ninstâœ : Module ğ•œ F\ntoCoreâœ : PreInnerProductSpace.Core ğ•œ F\ndefiniteâœ : âˆ€ (x : F), Eq (Inner.inner x x) 0 â†’ Eq x 0\ntoCore : PreInnerProductSpace.Core ğ•œ F\ndefinite : âˆ€ (x : F), Eq (Inner.inner x x) 0 â†’ Eq x 0\nxâœ : Eq { toCore := toCoreâœ, definite := definiteâœ } { toCore := toCore, definite := definite }\nâŠ¢ Eq toCoreâœ toCore","decl":"/-- A structure requiring that a scalar product is positive definite. Some theorems that\nrequire this assumptions are put under section `InnerProductSpace.Core`. -/\n-- @[nolint HasNonemptyInstance] porting note: I don't think we have this linter anymore\nstructure InnerProductSpace.Core (ğ•œ : Type*) (F : Type*) [RCLike ğ•œ] [AddCommGroup F]\n  [Module ğ•œ F] extends PreInnerProductSpace.Core ğ•œ F where\n  /-- The inner product is positive definite. -/\n  definite : âˆ€ x, inner x x = 0 â†’ x = 0\n\n/- We set `InnerProductSpace.Core` to be a class as we will use it as such in the construction\nof the normed space structure that it produces. However, all the instances we will use will be\nlocal to this proof. -/\n"}
{"name":"InnerProductSpace.Core.mk.sizeOf_spec","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"ğ•œ : Type u_4\nF : Type u_5\ninstâœâ´ : RCLike ğ•œ\ninstâœÂ³ : AddCommGroup F\ninstâœÂ² : Module ğ•œ F\ninstâœÂ¹ : SizeOf ğ•œ\ninstâœ : SizeOf F\ntoCore : PreInnerProductSpace.Core ğ•œ F\ndefinite : âˆ€ (x : F), Eq (Inner.inner x x) 0 â†’ Eq x 0\nâŠ¢ Eq (SizeOf.sizeOf { toCore := toCore, definite := definite }) (HAdd.hAdd 1 (SizeOf.sizeOf toCore))","decl":"/-- A structure requiring that a scalar product is positive definite. Some theorems that\nrequire this assumptions are put under section `InnerProductSpace.Core`. -/\n-- @[nolint HasNonemptyInstance] porting note: I don't think we have this linter anymore\nstructure InnerProductSpace.Core (ğ•œ : Type*) (F : Type*) [RCLike ğ•œ] [AddCommGroup F]\n  [Module ğ•œ F] extends PreInnerProductSpace.Core ğ•œ F where\n  /-- The inner product is positive definite. -/\n  definite : âˆ€ x, inner x x = 0 â†’ x = 0\n\n/- We set `InnerProductSpace.Core` to be a class as we will use it as such in the construction\nof the normed space structure that it produces. However, all the instances we will use will be\nlocal to this proof. -/\n"}
{"name":"InnerProductSpace.Core.inner_conj_symm","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"ğ•œ : Type u_1\nF : Type u_3\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : AddCommGroup F\ninstâœ : Module ğ•œ F\nc : PreInnerProductSpace.Core ğ•œ F\nx y : F\nâŠ¢ Eq ((starRingEnd ğ•œ) (Inner.inner y x)) (Inner.inner x y)","decl":"theorem inner_conj_symm (x y : F) : âŸªy, xâŸ«â€  = âŸªx, yâŸ« :=\n  c.conj_symm x y\n\n"}
{"name":"InnerProductSpace.Core.inner_self_nonneg","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"ğ•œ : Type u_1\nF : Type u_3\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : AddCommGroup F\ninstâœ : Module ğ•œ F\nc : PreInnerProductSpace.Core ğ•œ F\nx : F\nâŠ¢ LE.le 0 (RCLike.re (Inner.inner x x))","decl":"theorem inner_self_nonneg {x : F} : 0 â‰¤ re âŸªx, xâŸ« :=\n  c.nonneg_re _\n\n"}
{"name":"InnerProductSpace.Core.inner_self_im","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"ğ•œ : Type u_1\nF : Type u_3\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : AddCommGroup F\ninstâœ : Module ğ•œ F\nc : PreInnerProductSpace.Core ğ•œ F\nx : F\nâŠ¢ Eq (RCLike.im (Inner.inner x x)) 0","decl":"theorem inner_self_im (x : F) : im âŸªx, xâŸ« = 0 := by\n  rw [â† @ofReal_inj ğ•œ, im_eq_conj_sub]\n  simp [inner_conj_symm]\n\n"}
{"name":"InnerProductSpace.Core.inner_add_left","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"ğ•œ : Type u_1\nF : Type u_3\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : AddCommGroup F\ninstâœ : Module ğ•œ F\nc : PreInnerProductSpace.Core ğ•œ F\nx y z : F\nâŠ¢ Eq (Inner.inner (HAdd.hAdd x y) z) (HAdd.hAdd (Inner.inner x z) (Inner.inner y z))","decl":"theorem inner_add_left (x y z : F) : âŸªx + y, zâŸ« = âŸªx, zâŸ« + âŸªy, zâŸ« :=\n  c.add_left _ _ _\n\n"}
{"name":"InnerProductSpace.Core.inner_add_right","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"ğ•œ : Type u_1\nF : Type u_3\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : AddCommGroup F\ninstâœ : Module ğ•œ F\nc : PreInnerProductSpace.Core ğ•œ F\nx y z : F\nâŠ¢ Eq (Inner.inner x (HAdd.hAdd y z)) (HAdd.hAdd (Inner.inner x y) (Inner.inner x z))","decl":"theorem inner_add_right (x y z : F) : âŸªx, y + zâŸ« = âŸªx, yâŸ« + âŸªx, zâŸ« := by\n  rw [â† inner_conj_symm, inner_add_left, RingHom.map_add]; simp only [inner_conj_symm]\n\n"}
{"name":"InnerProductSpace.Core.ofReal_normSq_eq_inner_self","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"ğ•œ : Type u_1\nF : Type u_3\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : AddCommGroup F\ninstâœ : Module ğ•œ F\nc : PreInnerProductSpace.Core ğ•œ F\nx : F\nâŠ¢ Eq (â†‘(InnerProductSpace.Core.normSq x)) (Inner.inner x x)","decl":"theorem ofReal_normSq_eq_inner_self (x : F) : (normSqF x : ğ•œ) = âŸªx, xâŸ« := by\n  rw [ext_iff]\n  exact âŸ¨by simp only [ofReal_re]; rfl, by simp only [inner_self_im, ofReal_im]âŸ©\n\n"}
{"name":"InnerProductSpace.Core.inner_re_symm","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"ğ•œ : Type u_1\nF : Type u_3\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : AddCommGroup F\ninstâœ : Module ğ•œ F\nc : PreInnerProductSpace.Core ğ•œ F\nx y : F\nâŠ¢ Eq (RCLike.re (Inner.inner x y)) (RCLike.re (Inner.inner y x))","decl":"theorem inner_re_symm (x y : F) : re âŸªx, yâŸ« = re âŸªy, xâŸ« := by rw [â† inner_conj_symm, conj_re]\n\n"}
{"name":"InnerProductSpace.Core.inner_im_symm","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"ğ•œ : Type u_1\nF : Type u_3\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : AddCommGroup F\ninstâœ : Module ğ•œ F\nc : PreInnerProductSpace.Core ğ•œ F\nx y : F\nâŠ¢ Eq (RCLike.im (Inner.inner x y)) (Neg.neg (RCLike.im (Inner.inner y x)))","decl":"theorem inner_im_symm (x y : F) : im âŸªx, yâŸ« = -im âŸªy, xâŸ« := by rw [â† inner_conj_symm, conj_im]\n\n"}
{"name":"InnerProductSpace.Core.inner_smul_left","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"ğ•œ : Type u_1\nF : Type u_3\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : AddCommGroup F\ninstâœ : Module ğ•œ F\nc : PreInnerProductSpace.Core ğ•œ F\nx y : F\nr : ğ•œ\nâŠ¢ Eq (Inner.inner (HSMul.hSMul r x) y) (HMul.hMul ((starRingEnd ğ•œ) r) (Inner.inner x y))","decl":"theorem inner_smul_left (x y : F) {r : ğ•œ} : âŸªr â€¢ x, yâŸ« = râ€  * âŸªx, yâŸ« :=\n  c.smul_left _ _ _\n\n"}
{"name":"InnerProductSpace.Core.inner_smul_right","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"ğ•œ : Type u_1\nF : Type u_3\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : AddCommGroup F\ninstâœ : Module ğ•œ F\nc : PreInnerProductSpace.Core ğ•œ F\nx y : F\nr : ğ•œ\nâŠ¢ Eq (Inner.inner x (HSMul.hSMul r y)) (HMul.hMul r (Inner.inner x y))","decl":"theorem inner_smul_right (x y : F) {r : ğ•œ} : âŸªx, r â€¢ yâŸ« = r * âŸªx, yâŸ« := by\n  rw [â† inner_conj_symm, inner_smul_left]\n  simp only [conj_conj, inner_conj_symm, RingHom.map_mul]\n\n"}
{"name":"InnerProductSpace.Core.inner_zero_left","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"ğ•œ : Type u_1\nF : Type u_3\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : AddCommGroup F\ninstâœ : Module ğ•œ F\nc : PreInnerProductSpace.Core ğ•œ F\nx : F\nâŠ¢ Eq (Inner.inner 0 x) 0","decl":"theorem inner_zero_left (x : F) : âŸª0, xâŸ« = 0 := by\n  rw [â† zero_smul ğ•œ (0 : F), inner_smul_left]\n  simp only [zero_mul, RingHom.map_zero]\n\n"}
{"name":"InnerProductSpace.Core.inner_zero_right","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"ğ•œ : Type u_1\nF : Type u_3\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : AddCommGroup F\ninstâœ : Module ğ•œ F\nc : PreInnerProductSpace.Core ğ•œ F\nx : F\nâŠ¢ Eq (Inner.inner x 0) 0","decl":"theorem inner_zero_right (x : F) : âŸªx, 0âŸ« = 0 := by\n  rw [â† inner_conj_symm, inner_zero_left]; simp only [RingHom.map_zero]\n\n"}
{"name":"InnerProductSpace.Core.inner_self_of_eq_zero","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"ğ•œ : Type u_1\nF : Type u_3\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : AddCommGroup F\ninstâœ : Module ğ•œ F\nc : PreInnerProductSpace.Core ğ•œ F\nx : F\naâœ : Eq x 0\nâŠ¢ Eq (Inner.inner x x) 0","decl":"theorem inner_self_of_eq_zero {x : F} : x = 0 â†’ âŸªx, xâŸ« = 0 := by\n  rintro rfl\n  exact inner_zero_left _\n\n"}
{"name":"InnerProductSpace.Core.normSq_eq_zero_of_eq_zero","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"ğ•œ : Type u_1\nF : Type u_3\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : AddCommGroup F\ninstâœ : Module ğ•œ F\nc : PreInnerProductSpace.Core ğ•œ F\nx : F\naâœ : Eq x 0\nâŠ¢ Eq (InnerProductSpace.Core.normSq x) 0","decl":"theorem normSq_eq_zero_of_eq_zero {x : F} : x = 0 â†’ normSqF x = 0 := by\n  rintro rfl\n  simp [normSq, inner_self_of_eq_zero]\n\n"}
{"name":"InnerProductSpace.Core.ne_zero_of_inner_self_ne_zero","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"ğ•œ : Type u_1\nF : Type u_3\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : AddCommGroup F\ninstâœ : Module ğ•œ F\nc : PreInnerProductSpace.Core ğ•œ F\nx : F\naâœ : Ne (Inner.inner x x) 0\nâŠ¢ Ne x 0","decl":"theorem ne_zero_of_inner_self_ne_zero {x : F} : âŸªx, xâŸ« â‰  0 â†’ x â‰  0 :=\n  mt inner_self_of_eq_zero\n"}
{"name":"InnerProductSpace.Core.inner_self_ofReal_re","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"ğ•œ : Type u_1\nF : Type u_3\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : AddCommGroup F\ninstâœ : Module ğ•œ F\nc : PreInnerProductSpace.Core ğ•œ F\nx : F\nâŠ¢ Eq (â†‘(RCLike.re (Inner.inner x x))) (Inner.inner x x)","decl":"theorem inner_self_ofReal_re (x : F) : (re âŸªx, xâŸ« : ğ•œ) = âŸªx, xâŸ« := by\n  norm_num [ext_iff, inner_self_im]\n\n"}
{"name":"InnerProductSpace.Core.norm_inner_symm","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"ğ•œ : Type u_1\nF : Type u_3\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : AddCommGroup F\ninstâœ : Module ğ•œ F\nc : PreInnerProductSpace.Core ğ•œ F\nx y : F\nâŠ¢ Eq (Norm.norm (Inner.inner x y)) (Norm.norm (Inner.inner y x))","decl":"theorem norm_inner_symm (x y : F) : â€–âŸªx, yâŸ«â€– = â€–âŸªy, xâŸ«â€– := by rw [â† inner_conj_symm, norm_conj]\n\n"}
{"name":"InnerProductSpace.Core.inner_neg_left","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"ğ•œ : Type u_1\nF : Type u_3\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : AddCommGroup F\ninstâœ : Module ğ•œ F\nc : PreInnerProductSpace.Core ğ•œ F\nx y : F\nâŠ¢ Eq (Inner.inner (Neg.neg x) y) (Neg.neg (Inner.inner x y))","decl":"theorem inner_neg_left (x y : F) : âŸª-x, yâŸ« = -âŸªx, yâŸ« := by\n  rw [â† neg_one_smul ğ•œ x, inner_smul_left]\n  simp\n\n"}
{"name":"InnerProductSpace.Core.inner_neg_right","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"ğ•œ : Type u_1\nF : Type u_3\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : AddCommGroup F\ninstâœ : Module ğ•œ F\nc : PreInnerProductSpace.Core ğ•œ F\nx y : F\nâŠ¢ Eq (Inner.inner x (Neg.neg y)) (Neg.neg (Inner.inner x y))","decl":"theorem inner_neg_right (x y : F) : âŸªx, -yâŸ« = -âŸªx, yâŸ« := by\n  rw [â† inner_conj_symm, inner_neg_left]; simp only [RingHom.map_neg, inner_conj_symm]\n\n"}
{"name":"InnerProductSpace.Core.inner_sub_left","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"ğ•œ : Type u_1\nF : Type u_3\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : AddCommGroup F\ninstâœ : Module ğ•œ F\nc : PreInnerProductSpace.Core ğ•œ F\nx y z : F\nâŠ¢ Eq (Inner.inner (HSub.hSub x y) z) (HSub.hSub (Inner.inner x z) (Inner.inner y z))","decl":"theorem inner_sub_left (x y z : F) : âŸªx - y, zâŸ« = âŸªx, zâŸ« - âŸªy, zâŸ« := by\n  simp [sub_eq_add_neg, inner_add_left, inner_neg_left]\n\n"}
{"name":"InnerProductSpace.Core.inner_sub_right","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"ğ•œ : Type u_1\nF : Type u_3\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : AddCommGroup F\ninstâœ : Module ğ•œ F\nc : PreInnerProductSpace.Core ğ•œ F\nx y z : F\nâŠ¢ Eq (Inner.inner x (HSub.hSub y z)) (HSub.hSub (Inner.inner x y) (Inner.inner x z))","decl":"theorem inner_sub_right (x y z : F) : âŸªx, y - zâŸ« = âŸªx, yâŸ« - âŸªx, zâŸ« := by\n  simp [sub_eq_add_neg, inner_add_right, inner_neg_right]\n\n"}
{"name":"InnerProductSpace.Core.inner_mul_symm_re_eq_norm","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"ğ•œ : Type u_1\nF : Type u_3\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : AddCommGroup F\ninstâœ : Module ğ•œ F\nc : PreInnerProductSpace.Core ğ•œ F\nx y : F\nâŠ¢ Eq (RCLike.re (HMul.hMul (Inner.inner x y) (Inner.inner y x))) (Norm.norm (HMul.hMul (Inner.inner x y) (Inner.inner y x)))","decl":"theorem inner_mul_symm_re_eq_norm (x y : F) : re (âŸªx, yâŸ« * âŸªy, xâŸ«) = â€–âŸªx, yâŸ« * âŸªy, xâŸ«â€– := by\n  rw [â† inner_conj_symm, mul_comm]\n  exact re_eq_norm_of_mul_conj (inner y x)\n\n"}
{"name":"InnerProductSpace.Core.inner_add_add_self","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"ğ•œ : Type u_1\nF : Type u_3\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : AddCommGroup F\ninstâœ : Module ğ•œ F\nc : PreInnerProductSpace.Core ğ•œ F\nx y : F\nâŠ¢ Eq (Inner.inner (HAdd.hAdd x y) (HAdd.hAdd x y)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (Inner.inner x x) (Inner.inner x y)) (Inner.inner y x)) (Inner.inner y y))","decl":"/-- Expand `inner (x + y) (x + y)` -/\ntheorem inner_add_add_self (x y : F) : âŸªx + y, x + yâŸ« = âŸªx, xâŸ« + âŸªx, yâŸ« + âŸªy, xâŸ« + âŸªy, yâŸ« := by\n  simp only [inner_add_left, inner_add_right]; ring\n\n-- Expand `inner (x - y) (x - y)`\n"}
{"name":"InnerProductSpace.Core.inner_sub_sub_self","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"ğ•œ : Type u_1\nF : Type u_3\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : AddCommGroup F\ninstâœ : Module ğ•œ F\nc : PreInnerProductSpace.Core ğ•œ F\nx y : F\nâŠ¢ Eq (Inner.inner (HSub.hSub x y) (HSub.hSub x y)) (HAdd.hAdd (HSub.hSub (HSub.hSub (Inner.inner x x) (Inner.inner x y)) (Inner.inner y x)) (Inner.inner y y))","decl":"theorem inner_sub_sub_self (x y : F) : âŸªx - y, x - yâŸ« = âŸªx, xâŸ« - âŸªx, yâŸ« - âŸªy, xâŸ« + âŸªy, yâŸ« := by\n  simp only [inner_sub_left, inner_sub_right]; ring\n\n"}
{"name":"InnerProductSpace.Core.inner_smul_ofReal_left","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"ğ•œ : Type u_1\nF : Type u_3\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : AddCommGroup F\ninstâœ : Module ğ•œ F\nc : PreInnerProductSpace.Core ğ•œ F\nx y : F\nt : Real\nâŠ¢ Eq (Inner.inner (HSMul.hSMul (â†‘t) x) y) (HMul.hMul (Inner.inner x y) â†‘t)","decl":"theorem inner_smul_ofReal_left (x y : F) {t : â„} : âŸª(t : ğ•œ) â€¢ x, yâŸ« = âŸªx, yâŸ« * t := by\n  rw [inner_smul_left, conj_ofReal, mul_comm]\n\n"}
{"name":"InnerProductSpace.Core.inner_smul_ofReal_right","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"ğ•œ : Type u_1\nF : Type u_3\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : AddCommGroup F\ninstâœ : Module ğ•œ F\nc : PreInnerProductSpace.Core ğ•œ F\nx y : F\nt : Real\nâŠ¢ Eq (Inner.inner x (HSMul.hSMul (â†‘t) y)) (HMul.hMul (Inner.inner x y) â†‘t)","decl":"theorem inner_smul_ofReal_right (x y : F) {t : â„} : âŸªx, (t : ğ•œ) â€¢ yâŸ« = âŸªx, yâŸ« * t := by\n  rw [inner_smul_right, mul_comm]\n\n"}
{"name":"InnerProductSpace.Core.re_inner_smul_ofReal_smul_self","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"ğ•œ : Type u_1\nF : Type u_3\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : AddCommGroup F\ninstâœ : Module ğ•œ F\nc : PreInnerProductSpace.Core ğ•œ F\nx : F\nt : Real\nâŠ¢ Eq (RCLike.re (Inner.inner (HSMul.hSMul (â†‘t) x) (HSMul.hSMul (â†‘t) x))) (HMul.hMul (HMul.hMul (InnerProductSpace.Core.normSq x) t) t)","decl":"theorem re_inner_smul_ofReal_smul_self (x : F) {t : â„} :\n    re âŸª(t : ğ•œ) â€¢ x, (t : ğ•œ) â€¢ xâŸ« = normSqF x * t * t := by\n  apply ofReal_injective (K := ğ•œ)\n  simp [inner_self_ofReal_re, inner_smul_ofReal_left, inner_smul_ofReal_right, normSq]\n\n"}
{"name":"InnerProductSpace.Core.cauchy_schwarz_aux'","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"ğ•œ : Type u_1\nF : Type u_3\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : AddCommGroup F\ninstâœ : Module ğ•œ F\nc : PreInnerProductSpace.Core ğ•œ F\nx y : F\nt : Real\nâŠ¢ LE.le 0 (HAdd.hAdd (HAdd.hAdd (HMul.hMul (HMul.hMul (InnerProductSpace.Core.normSq x) t) t) (HMul.hMul (HMul.hMul 2 (RCLike.re (Inner.inner x y))) t)) (InnerProductSpace.Core.normSq y))","decl":"/-- An auxiliary equality useful to prove the **Cauchyâ€“Schwarz inequality**. Here we use the\nstandard argument involving the discriminant of quadratic form. -/\nlemma cauchy_schwarz_aux' (x y : F) (t : â„) : 0 â‰¤ normSqF x * t * t + 2 * re âŸªx, yâŸ« * t\n    + normSqF y := by\n  calc 0 â‰¤ re âŸª(ofReal t : ğ•œ) â€¢ x + y, (ofReal t : ğ•œ) â€¢ x + yâŸ« := inner_self_nonneg\n  _ = re (âŸª(ofReal t : ğ•œ) â€¢ x, (ofReal t : ğ•œ) â€¢ xâŸ« + âŸª(ofReal t : ğ•œ) â€¢ x, yâŸ«\n      + âŸªy, (ofReal t : ğ•œ) â€¢ xâŸ« + âŸªy, yâŸ«) := by rw [inner_add_add_self ((ofReal t : ğ•œ) â€¢ x) y]\n  _ = re âŸª(ofReal t : ğ•œ) â€¢ x, (ofReal t : ğ•œ) â€¢ xâŸ«\n      + re âŸª(ofReal t : ğ•œ) â€¢ x, yâŸ« + re âŸªy, (ofReal t : ğ•œ) â€¢ xâŸ« + re âŸªy, yâŸ« := by\n      simp only [map_add]\n  _ = normSq x * t * t + re (âŸªx, yâŸ« * t) + re (âŸªy, xâŸ« * t) + re âŸªy, yâŸ« := by rw\n    [re_inner_smul_ofReal_smul_self, inner_smul_ofReal_left, inner_smul_ofReal_right]\n  _ = normSq x * t * t + re âŸªx, yâŸ« * t + re âŸªy, xâŸ« * t + re âŸªy, yâŸ« := by rw [mul_comm âŸªx,yâŸ« _,\n    RCLike.re_ofReal_mul, mul_comm t _, mul_comm âŸªy,xâŸ« _, RCLike.re_ofReal_mul, mul_comm t _]\n  _ = normSq x * t * t + re âŸªx, yâŸ« * t + re âŸªy, xâŸ« * t + normSq y := by rw [â† normSq]\n  _ = normSq x * t * t + re âŸªx, yâŸ« * t + re âŸªx, yâŸ« * t + normSq y := by rw [inner_re_symm]\n  _ = normSq x * t * t + 2 * re âŸªx, yâŸ« * t + normSq y := by ring\n\n"}
{"name":"InnerProductSpace.Core.cauchy_schwarz_aux","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"ğ•œ : Type u_1\nF : Type u_3\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : AddCommGroup F\ninstâœ : Module ğ•œ F\nc : PreInnerProductSpace.Core ğ•œ F\nx y : F\nâŠ¢ Eq (InnerProductSpace.Core.normSq (HSub.hSub (HSMul.hSMul (Inner.inner x y) x) (HSMul.hSMul (Inner.inner x x) y))) (HMul.hMul (InnerProductSpace.Core.normSq x) (HSub.hSub (HMul.hMul (InnerProductSpace.Core.normSq x) (InnerProductSpace.Core.normSq y)) (HPow.hPow (Norm.norm (Inner.inner x y)) 2)))","decl":"/-- Another auxiliary equality related with the **Cauchyâ€“Schwarz inequality**: the square of the\nseminorm of `âŸªx, yâŸ« â€¢ x - âŸªx, xâŸ« â€¢ y` is equal to `â€–xâ€– ^ 2 * (â€–xâ€– ^ 2 * â€–yâ€– ^ 2 - â€–âŸªx, yâŸ«â€– ^ 2)`.\nWe use `InnerProductSpace.ofCore.normSq x` etc (defeq to `is_R_or_C.re âŸªx, xâŸ«`) instead of `â€–xâ€– ^ 2`\netc to avoid extra rewrites when applying it to an `InnerProductSpace`. -/\ntheorem cauchy_schwarz_aux (x y : F) : normSqF (âŸªx, yâŸ« â€¢ x - âŸªx, xâŸ« â€¢ y)\n    = normSqF x * (normSqF x * normSqF y - â€–âŸªx, yâŸ«â€– ^ 2) := by\n  rw [â† @ofReal_inj ğ•œ, ofReal_normSq_eq_inner_self]\n  simp only [inner_sub_sub_self, inner_smul_left, inner_smul_right, conj_ofReal, mul_sub, â†\n    ofReal_normSq_eq_inner_self x, â† ofReal_normSq_eq_inner_self y]\n  rw [â† mul_assoc, mul_conj, RCLike.conj_mul, mul_left_comm, â† inner_conj_symm y, mul_conj]\n  push_cast\n  ring\n\n"}
{"name":"InnerProductSpace.Core.inner_mul_inner_self_le","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"ğ•œ : Type u_1\nF : Type u_3\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : AddCommGroup F\ninstâœ : Module ğ•œ F\nc : PreInnerProductSpace.Core ğ•œ F\nx y : F\nâŠ¢ LE.le (HMul.hMul (Norm.norm (Inner.inner x y)) (Norm.norm (Inner.inner y x))) (HMul.hMul (RCLike.re (Inner.inner x x)) (RCLike.re (Inner.inner y y)))","decl":"/-- **Cauchyâ€“Schwarz inequality**.\nWe need this for the `PreInnerProductSpace.Core` structure to prove the triangle inequality below\nwhen showing the core is a normed group and to take the quotient.\n\n(This is not intended for general use; see `Analysis.InnerProductSpace.Basic` for a variety of\nversions of Cauchy-Schwartz for an inner product space, rather than a `PreInnerProductSpace.Core`).\n-/\ntheorem inner_mul_inner_self_le (x y : F) : â€–âŸªx, yâŸ«â€– * â€–âŸªy, xâŸ«â€– â‰¤ re âŸªx, xâŸ« * re âŸªy, yâŸ« := by\n  suffices discrim (normSqF x) (2 * â€–âŸªx, yâŸ«_ğ•œâ€–) (normSqF y) â‰¤ 0 by\n    rw [norm_inner_symm y x]\n    rw [discrim, normSq, normSq, sq] at this\n    linarith\n  refine discrim_le_zero fun t â†¦ ?_\n  by_cases hzero : âŸªx, yâŸ« = 0\n  Â· simp only [mul_assoc, â† sq, hzero, norm_zero, mul_zero, zero_mul, add_zero, ge_iff_le]\n    obtain âŸ¨hx, hyâŸ© : (0 â‰¤ normSqF x âˆ§ 0 â‰¤ normSqF y) := âŸ¨inner_self_nonneg, inner_self_nonnegâŸ©\n    positivity\n  Â· have hzero' : â€–âŸªx, yâŸ«â€– â‰  0 := norm_ne_zero_iff.2 hzero\n    convert cauchy_schwarz_aux' (ğ•œ := ğ•œ) (âŸªx, yâŸ« â€¢ x) y (t / â€–âŸªx, yâŸ«â€–) using 3\n    Â· field_simp\n      rw [â† sq, normSq, normSq, inner_smul_right, inner_smul_left, â† mul_assoc _ _ âŸªx, xâŸ«,\n        mul_conj]\n      nth_rw 2 [sq]\n      rw [â† ofReal_mul, re_ofReal_mul]\n      ring\n    Â· field_simp\n      rw [inner_smul_left, mul_comm _ âŸªx, yâŸ«_ğ•œ, mul_conj, â† ofReal_pow, ofReal_re]\n      ring\n\n"}
{"name":"InnerProductSpace.Core.norm_eq_sqrt_inner","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"ğ•œ : Type u_1\nF : Type u_3\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : AddCommGroup F\ninstâœ : Module ğ•œ F\nc : PreInnerProductSpace.Core ğ•œ F\nx : F\nâŠ¢ Eq (Norm.norm x) (RCLike.re (Inner.inner x x)).sqrt","decl":"theorem norm_eq_sqrt_inner (x : F) : â€–xâ€– = âˆš(re âŸªx, xâŸ«) := rfl\n\n"}
{"name":"InnerProductSpace.Core.inner_self_eq_norm_mul_norm","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"ğ•œ : Type u_1\nF : Type u_3\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : AddCommGroup F\ninstâœ : Module ğ•œ F\nc : PreInnerProductSpace.Core ğ•œ F\nx : F\nâŠ¢ Eq (RCLike.re (Inner.inner x x)) (HMul.hMul (Norm.norm x) (Norm.norm x))","decl":"theorem inner_self_eq_norm_mul_norm (x : F) : re âŸªx, xâŸ« = â€–xâ€– * â€–xâ€– := by\n  rw [norm_eq_sqrt_inner, â† sqrt_mul inner_self_nonneg (re âŸªx, xâŸ«), sqrt_mul_self inner_self_nonneg]\n\n"}
{"name":"InnerProductSpace.Core.sqrt_normSq_eq_norm","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"ğ•œ : Type u_1\nF : Type u_3\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : AddCommGroup F\ninstâœ : Module ğ•œ F\nc : PreInnerProductSpace.Core ğ•œ F\nx : F\nâŠ¢ Eq (InnerProductSpace.Core.normSq x).sqrt (Norm.norm x)","decl":"theorem sqrt_normSq_eq_norm (x : F) : âˆš(normSqF x) = â€–xâ€– := rfl\n\n"}
{"name":"InnerProductSpace.Core.norm_inner_le_norm","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"ğ•œ : Type u_1\nF : Type u_3\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : AddCommGroup F\ninstâœ : Module ğ•œ F\nc : PreInnerProductSpace.Core ğ•œ F\nx y : F\nâŠ¢ LE.le (Norm.norm (Inner.inner x y)) (HMul.hMul (Norm.norm x) (Norm.norm y))","decl":"/-- Cauchyâ€“Schwarz inequality with norm -/\ntheorem norm_inner_le_norm (x y : F) : â€–âŸªx, yâŸ«â€– â‰¤ â€–xâ€– * â€–yâ€– :=\n  nonneg_le_nonneg_of_sq_le_sq (mul_nonneg (sqrt_nonneg _) (sqrt_nonneg _)) <|\n    calc\n      â€–âŸªx, yâŸ«â€– * â€–âŸªx, yâŸ«â€– = â€–âŸªx, yâŸ«â€– * â€–âŸªy, xâŸ«â€– := by rw [norm_inner_symm]\n      _ â‰¤ re âŸªx, xâŸ« * re âŸªy, yâŸ« := inner_mul_inner_self_le x y\n      _ = â€–xâ€– * â€–yâ€– * (â€–xâ€– * â€–yâ€–) := by simp only [inner_self_eq_norm_mul_norm]; ring\n\n"}
{"name":"InnerProductSpace.Core.inner_self_eq_zero","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"ğ•œ : Type u_1\nF : Type u_3\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : AddCommGroup F\ninstâœ : Module ğ•œ F\ncd : InnerProductSpace.Core ğ•œ F\nx : F\nâŠ¢ Iff (Eq (Inner.inner x x) 0) (Eq x 0)","decl":"theorem inner_self_eq_zero {x : F} : âŸªx, xâŸ« = 0 â†” x = 0 :=\n  âŸ¨cd.definite _, inner_self_of_eq_zeroâŸ©\n\n"}
{"name":"InnerProductSpace.Core.normSq_eq_zero","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"ğ•œ : Type u_1\nF : Type u_3\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : AddCommGroup F\ninstâœ : Module ğ•œ F\ncd : InnerProductSpace.Core ğ•œ F\nx : F\nâŠ¢ Iff (Eq (InnerProductSpace.Core.normSq x) 0) (Eq x 0)","decl":"theorem normSq_eq_zero {x : F} : normSqF x = 0 â†” x = 0 :=\n  Iff.trans\n    (by simp only [normSq, ext_iff, map_zero, inner_self_im, eq_self_iff_true, and_true])\n    (@inner_self_eq_zero ğ•œ _ _ _ _ _ x)\n\n"}
{"name":"InnerProductSpace.Core.inner_self_ne_zero","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"ğ•œ : Type u_1\nF : Type u_3\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : AddCommGroup F\ninstâœ : Module ğ•œ F\ncd : InnerProductSpace.Core ğ•œ F\nx : F\nâŠ¢ Iff (Ne (Inner.inner x x) 0) (Ne x 0)","decl":"theorem inner_self_ne_zero {x : F} : âŸªx, xâŸ« â‰  0 â†” x â‰  0 :=\n  inner_self_eq_zero.not\n\n"}
