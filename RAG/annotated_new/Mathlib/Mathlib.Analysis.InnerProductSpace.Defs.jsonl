{"name":"InnerProductSpace.smul_left","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"𝕜 : Type u_4\nE : Type u_5\ninst✝¹ : RCLike 𝕜\ninst✝ : SeminormedAddCommGroup E\nself : InnerProductSpace 𝕜 E\nx y : E\nr : 𝕜\n⊢ Eq (Inner.inner (HSMul.hSMul r x) y) (HMul.hMul ((starRingEnd 𝕜) r) (Inner.inner x y))","decl":"/-- A (pre) inner product space is a vector space with an additional operation called inner product.\nThe (semi)norm could be derived from the inner product, instead we require the existence of a\nseminorm and the fact that `‖x‖^2 = re ⟪x, x⟫` to be able to put instances on `𝕂` or product spaces.\n\nNote that `NormedSpace` does not assume that `‖x‖=0` implies `x=0` (it is rather a seminorm).\n\nTo construct a seminorm from an inner product, see `PreInnerProductSpace.ofCore`.\n-/\nclass InnerProductSpace (𝕜 : Type*) (E : Type*) [RCLike 𝕜] [SeminormedAddCommGroup E] extends\n  NormedSpace 𝕜 E, Inner 𝕜 E where\n  /-- The inner product induces the norm. -/\n  norm_sq_eq_inner : ∀ x : E, ‖x‖ ^ 2 = re (inner x x)\n  /-- The inner product is *hermitian*, taking the `conj` swaps the arguments. -/\n  conj_symm : ∀ x y, conj (inner y x) = inner x y\n  /-- The inner product is additive in the first coordinate. -/\n  add_left : ∀ x y z, inner (x + y) z = inner x z + inner y z\n  /-- The inner product is conjugate linear in the first coordinate. -/\n  smul_left : ∀ x y r, inner (r • x) y = conj r * inner x y\n\n"}
{"name":"InnerProductSpace.norm_sq_eq_inner","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"𝕜 : Type u_4\nE : Type u_5\ninst✝¹ : RCLike 𝕜\ninst✝ : SeminormedAddCommGroup E\nself : InnerProductSpace 𝕜 E\nx : E\n⊢ Eq (HPow.hPow (Norm.norm x) 2) (RCLike.re (Inner.inner x x))","decl":"/-- A (pre) inner product space is a vector space with an additional operation called inner product.\nThe (semi)norm could be derived from the inner product, instead we require the existence of a\nseminorm and the fact that `‖x‖^2 = re ⟪x, x⟫` to be able to put instances on `𝕂` or product spaces.\n\nNote that `NormedSpace` does not assume that `‖x‖=0` implies `x=0` (it is rather a seminorm).\n\nTo construct a seminorm from an inner product, see `PreInnerProductSpace.ofCore`.\n-/\nclass InnerProductSpace (𝕜 : Type*) (E : Type*) [RCLike 𝕜] [SeminormedAddCommGroup E] extends\n  NormedSpace 𝕜 E, Inner 𝕜 E where\n  /-- The inner product induces the norm. -/\n  norm_sq_eq_inner : ∀ x : E, ‖x‖ ^ 2 = re (inner x x)\n  /-- The inner product is *hermitian*, taking the `conj` swaps the arguments. -/\n  conj_symm : ∀ x y, conj (inner y x) = inner x y\n  /-- The inner product is additive in the first coordinate. -/\n  add_left : ∀ x y z, inner (x + y) z = inner x z + inner y z\n  /-- The inner product is conjugate linear in the first coordinate. -/\n  smul_left : ∀ x y r, inner (r • x) y = conj r * inner x y\n\n"}
{"name":"InnerProductSpace.conj_symm","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"𝕜 : Type u_4\nE : Type u_5\ninst✝¹ : RCLike 𝕜\ninst✝ : SeminormedAddCommGroup E\nself : InnerProductSpace 𝕜 E\nx y : E\n⊢ Eq ((starRingEnd 𝕜) (Inner.inner y x)) (Inner.inner x y)","decl":"/-- A (pre) inner product space is a vector space with an additional operation called inner product.\nThe (semi)norm could be derived from the inner product, instead we require the existence of a\nseminorm and the fact that `‖x‖^2 = re ⟪x, x⟫` to be able to put instances on `𝕂` or product spaces.\n\nNote that `NormedSpace` does not assume that `‖x‖=0` implies `x=0` (it is rather a seminorm).\n\nTo construct a seminorm from an inner product, see `PreInnerProductSpace.ofCore`.\n-/\nclass InnerProductSpace (𝕜 : Type*) (E : Type*) [RCLike 𝕜] [SeminormedAddCommGroup E] extends\n  NormedSpace 𝕜 E, Inner 𝕜 E where\n  /-- The inner product induces the norm. -/\n  norm_sq_eq_inner : ∀ x : E, ‖x‖ ^ 2 = re (inner x x)\n  /-- The inner product is *hermitian*, taking the `conj` swaps the arguments. -/\n  conj_symm : ∀ x y, conj (inner y x) = inner x y\n  /-- The inner product is additive in the first coordinate. -/\n  add_left : ∀ x y z, inner (x + y) z = inner x z + inner y z\n  /-- The inner product is conjugate linear in the first coordinate. -/\n  smul_left : ∀ x y r, inner (r • x) y = conj r * inner x y\n\n"}
{"name":"InnerProductSpace.add_left","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"𝕜 : Type u_4\nE : Type u_5\ninst✝¹ : RCLike 𝕜\ninst✝ : SeminormedAddCommGroup E\nself : InnerProductSpace 𝕜 E\nx y z : E\n⊢ Eq (Inner.inner (HAdd.hAdd x y) z) (HAdd.hAdd (Inner.inner x z) (Inner.inner y z))","decl":"/-- A (pre) inner product space is a vector space with an additional operation called inner product.\nThe (semi)norm could be derived from the inner product, instead we require the existence of a\nseminorm and the fact that `‖x‖^2 = re ⟪x, x⟫` to be able to put instances on `𝕂` or product spaces.\n\nNote that `NormedSpace` does not assume that `‖x‖=0` implies `x=0` (it is rather a seminorm).\n\nTo construct a seminorm from an inner product, see `PreInnerProductSpace.ofCore`.\n-/\nclass InnerProductSpace (𝕜 : Type*) (E : Type*) [RCLike 𝕜] [SeminormedAddCommGroup E] extends\n  NormedSpace 𝕜 E, Inner 𝕜 E where\n  /-- The inner product induces the norm. -/\n  norm_sq_eq_inner : ∀ x : E, ‖x‖ ^ 2 = re (inner x x)\n  /-- The inner product is *hermitian*, taking the `conj` swaps the arguments. -/\n  conj_symm : ∀ x y, conj (inner y x) = inner x y\n  /-- The inner product is additive in the first coordinate. -/\n  add_left : ∀ x y z, inner (x + y) z = inner x z + inner y z\n  /-- The inner product is conjugate linear in the first coordinate. -/\n  smul_left : ∀ x y r, inner (r • x) y = conj r * inner x y\n\n"}
{"name":"PreInnerProductSpace.Core.mk.injEq","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"𝕜 : Type u_4\nF : Type u_5\ninst✝² : RCLike 𝕜\ninst✝¹ : AddCommGroup F\ninst✝ : Module 𝕜 F\ntoInner✝ : Inner 𝕜 F\nconj_symm✝ : ∀ (x y : F), Eq ((starRingEnd 𝕜) (Inner.inner y x)) (Inner.inner x y)\nnonneg_re✝ : ∀ (x : F), LE.le 0 (RCLike.re (Inner.inner x x))\nadd_left✝ : ∀ (x y z : F), Eq (Inner.inner (HAdd.hAdd x y) z) (HAdd.hAdd (Inner.inner x z) (Inner.inner y z))\nsmul_left✝ : ∀ (x y : F) (r : 𝕜), Eq (Inner.inner (HSMul.hSMul r x) y) (HMul.hMul ((starRingEnd 𝕜) r) (Inner.inner x y))\ntoInner : Inner 𝕜 F\nconj_symm : ∀ (x y : F), Eq ((starRingEnd 𝕜) (Inner.inner y x)) (Inner.inner x y)\nnonneg_re : ∀ (x : F), LE.le 0 (RCLike.re (Inner.inner x x))\nadd_left : ∀ (x y z : F), Eq (Inner.inner (HAdd.hAdd x y) z) (HAdd.hAdd (Inner.inner x z) (Inner.inner y z))\nsmul_left : ∀ (x y : F) (r : 𝕜), Eq (Inner.inner (HSMul.hSMul r x) y) (HMul.hMul ((starRingEnd 𝕜) r) (Inner.inner x y))\n⊢ Eq (Eq { toInner := toInner✝, conj_symm := conj_symm✝, nonneg_re := nonneg_re✝, add_left := add_left✝, smul_left := smul_left✝ } { toInner := toInner, conj_symm := conj_symm, nonneg_re := nonneg_re, add_left := add_left, smul_left := smul_left }) (Eq toInner✝ toInner)","decl":"/-- A structure requiring that a scalar product is positive semidefinite and symmetric. -/\nstructure PreInnerProductSpace.Core (𝕜 : Type*) (F : Type*) [RCLike 𝕜] [AddCommGroup F]\n  [Module 𝕜 F] extends Inner 𝕜 F where\n  /-- The inner product is *hermitian*, taking the `conj` swaps the arguments. -/\n  conj_symm : ∀ x y, conj (inner y x) = inner x y\n  /-- The inner product is positive (semi)definite. -/\n  nonneg_re : ∀ x, 0 ≤ re (inner x x)\n  /-- The inner product is additive in the first coordinate. -/\n  add_left : ∀ x y z, inner (x + y) z = inner x z + inner y z\n  /-- The inner product is conjugate linear in the first coordinate. -/\n  smul_left : ∀ x y r, inner (r • x) y = conj r * inner x y\n\n"}
{"name":"PreInnerProductSpace.Core.smul_left","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"𝕜 : Type u_4\nF : Type u_5\ninst✝² : RCLike 𝕜\ninst✝¹ : AddCommGroup F\ninst✝ : Module 𝕜 F\nself : PreInnerProductSpace.Core 𝕜 F\nx y : F\nr : 𝕜\n⊢ Eq (Inner.inner (HSMul.hSMul r x) y) (HMul.hMul ((starRingEnd 𝕜) r) (Inner.inner x y))","decl":"/-- A structure requiring that a scalar product is positive semidefinite and symmetric. -/\nstructure PreInnerProductSpace.Core (𝕜 : Type*) (F : Type*) [RCLike 𝕜] [AddCommGroup F]\n  [Module 𝕜 F] extends Inner 𝕜 F where\n  /-- The inner product is *hermitian*, taking the `conj` swaps the arguments. -/\n  conj_symm : ∀ x y, conj (inner y x) = inner x y\n  /-- The inner product is positive (semi)definite. -/\n  nonneg_re : ∀ x, 0 ≤ re (inner x x)\n  /-- The inner product is additive in the first coordinate. -/\n  add_left : ∀ x y z, inner (x + y) z = inner x z + inner y z\n  /-- The inner product is conjugate linear in the first coordinate. -/\n  smul_left : ∀ x y r, inner (r • x) y = conj r * inner x y\n\n"}
{"name":"PreInnerProductSpace.Core.mk.sizeOf_spec","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"𝕜 : Type u_4\nF : Type u_5\ninst✝⁴ : RCLike 𝕜\ninst✝³ : AddCommGroup F\ninst✝² : Module 𝕜 F\ninst✝¹ : SizeOf 𝕜\ninst✝ : SizeOf F\ntoInner : Inner 𝕜 F\nconj_symm : ∀ (x y : F), Eq ((starRingEnd 𝕜) (Inner.inner y x)) (Inner.inner x y)\nnonneg_re : ∀ (x : F), LE.le 0 (RCLike.re (Inner.inner x x))\nadd_left : ∀ (x y z : F), Eq (Inner.inner (HAdd.hAdd x y) z) (HAdd.hAdd (Inner.inner x z) (Inner.inner y z))\nsmul_left : ∀ (x y : F) (r : 𝕜), Eq (Inner.inner (HSMul.hSMul r x) y) (HMul.hMul ((starRingEnd 𝕜) r) (Inner.inner x y))\n⊢ Eq (SizeOf.sizeOf { toInner := toInner, conj_symm := conj_symm, nonneg_re := nonneg_re, add_left := add_left, smul_left := smul_left }) (HAdd.hAdd 1 (SizeOf.sizeOf toInner))","decl":"/-- A structure requiring that a scalar product is positive semidefinite and symmetric. -/\nstructure PreInnerProductSpace.Core (𝕜 : Type*) (F : Type*) [RCLike 𝕜] [AddCommGroup F]\n  [Module 𝕜 F] extends Inner 𝕜 F where\n  /-- The inner product is *hermitian*, taking the `conj` swaps the arguments. -/\n  conj_symm : ∀ x y, conj (inner y x) = inner x y\n  /-- The inner product is positive (semi)definite. -/\n  nonneg_re : ∀ x, 0 ≤ re (inner x x)\n  /-- The inner product is additive in the first coordinate. -/\n  add_left : ∀ x y z, inner (x + y) z = inner x z + inner y z\n  /-- The inner product is conjugate linear in the first coordinate. -/\n  smul_left : ∀ x y r, inner (r • x) y = conj r * inner x y\n\n"}
{"name":"PreInnerProductSpace.Core.conj_symm","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"𝕜 : Type u_4\nF : Type u_5\ninst✝² : RCLike 𝕜\ninst✝¹ : AddCommGroup F\ninst✝ : Module 𝕜 F\nself : PreInnerProductSpace.Core 𝕜 F\nx y : F\n⊢ Eq ((starRingEnd 𝕜) (Inner.inner y x)) (Inner.inner x y)","decl":"/-- A structure requiring that a scalar product is positive semidefinite and symmetric. -/\nstructure PreInnerProductSpace.Core (𝕜 : Type*) (F : Type*) [RCLike 𝕜] [AddCommGroup F]\n  [Module 𝕜 F] extends Inner 𝕜 F where\n  /-- The inner product is *hermitian*, taking the `conj` swaps the arguments. -/\n  conj_symm : ∀ x y, conj (inner y x) = inner x y\n  /-- The inner product is positive (semi)definite. -/\n  nonneg_re : ∀ x, 0 ≤ re (inner x x)\n  /-- The inner product is additive in the first coordinate. -/\n  add_left : ∀ x y z, inner (x + y) z = inner x z + inner y z\n  /-- The inner product is conjugate linear in the first coordinate. -/\n  smul_left : ∀ x y r, inner (r • x) y = conj r * inner x y\n\n"}
{"name":"PreInnerProductSpace.Core.nonneg_re","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"𝕜 : Type u_4\nF : Type u_5\ninst✝² : RCLike 𝕜\ninst✝¹ : AddCommGroup F\ninst✝ : Module 𝕜 F\nself : PreInnerProductSpace.Core 𝕜 F\nx : F\n⊢ LE.le 0 (RCLike.re (Inner.inner x x))","decl":"/-- A structure requiring that a scalar product is positive semidefinite and symmetric. -/\nstructure PreInnerProductSpace.Core (𝕜 : Type*) (F : Type*) [RCLike 𝕜] [AddCommGroup F]\n  [Module 𝕜 F] extends Inner 𝕜 F where\n  /-- The inner product is *hermitian*, taking the `conj` swaps the arguments. -/\n  conj_symm : ∀ x y, conj (inner y x) = inner x y\n  /-- The inner product is positive (semi)definite. -/\n  nonneg_re : ∀ x, 0 ≤ re (inner x x)\n  /-- The inner product is additive in the first coordinate. -/\n  add_left : ∀ x y z, inner (x + y) z = inner x z + inner y z\n  /-- The inner product is conjugate linear in the first coordinate. -/\n  smul_left : ∀ x y r, inner (r • x) y = conj r * inner x y\n\n"}
{"name":"PreInnerProductSpace.Core.add_left","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"𝕜 : Type u_4\nF : Type u_5\ninst✝² : RCLike 𝕜\ninst✝¹ : AddCommGroup F\ninst✝ : Module 𝕜 F\nself : PreInnerProductSpace.Core 𝕜 F\nx y z : F\n⊢ Eq (Inner.inner (HAdd.hAdd x y) z) (HAdd.hAdd (Inner.inner x z) (Inner.inner y z))","decl":"/-- A structure requiring that a scalar product is positive semidefinite and symmetric. -/\nstructure PreInnerProductSpace.Core (𝕜 : Type*) (F : Type*) [RCLike 𝕜] [AddCommGroup F]\n  [Module 𝕜 F] extends Inner 𝕜 F where\n  /-- The inner product is *hermitian*, taking the `conj` swaps the arguments. -/\n  conj_symm : ∀ x y, conj (inner y x) = inner x y\n  /-- The inner product is positive (semi)definite. -/\n  nonneg_re : ∀ x, 0 ≤ re (inner x x)\n  /-- The inner product is additive in the first coordinate. -/\n  add_left : ∀ x y z, inner (x + y) z = inner x z + inner y z\n  /-- The inner product is conjugate linear in the first coordinate. -/\n  smul_left : ∀ x y r, inner (r • x) y = conj r * inner x y\n\n"}
{"name":"PreInnerProductSpace.Core.mk.inj","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"𝕜 : Type u_4\nF : Type u_5\ninst✝² : RCLike 𝕜\ninst✝¹ : AddCommGroup F\ninst✝ : Module 𝕜 F\ntoInner✝ : Inner 𝕜 F\nconj_symm✝ : ∀ (x y : F), Eq ((starRingEnd 𝕜) (Inner.inner y x)) (Inner.inner x y)\nnonneg_re✝ : ∀ (x : F), LE.le 0 (RCLike.re (Inner.inner x x))\nadd_left✝ : ∀ (x y z : F), Eq (Inner.inner (HAdd.hAdd x y) z) (HAdd.hAdd (Inner.inner x z) (Inner.inner y z))\nsmul_left✝ : ∀ (x y : F) (r : 𝕜), Eq (Inner.inner (HSMul.hSMul r x) y) (HMul.hMul ((starRingEnd 𝕜) r) (Inner.inner x y))\ntoInner : Inner 𝕜 F\nconj_symm : ∀ (x y : F), Eq ((starRingEnd 𝕜) (Inner.inner y x)) (Inner.inner x y)\nnonneg_re : ∀ (x : F), LE.le 0 (RCLike.re (Inner.inner x x))\nadd_left : ∀ (x y z : F), Eq (Inner.inner (HAdd.hAdd x y) z) (HAdd.hAdd (Inner.inner x z) (Inner.inner y z))\nsmul_left : ∀ (x y : F) (r : 𝕜), Eq (Inner.inner (HSMul.hSMul r x) y) (HMul.hMul ((starRingEnd 𝕜) r) (Inner.inner x y))\nx✝ : Eq { toInner := toInner✝, conj_symm := conj_symm✝, nonneg_re := nonneg_re✝, add_left := add_left✝, smul_left := smul_left✝ } { toInner := toInner, conj_symm := conj_symm, nonneg_re := nonneg_re, add_left := add_left, smul_left := smul_left }\n⊢ Eq toInner✝ toInner","decl":"/-- A structure requiring that a scalar product is positive semidefinite and symmetric. -/\nstructure PreInnerProductSpace.Core (𝕜 : Type*) (F : Type*) [RCLike 𝕜] [AddCommGroup F]\n  [Module 𝕜 F] extends Inner 𝕜 F where\n  /-- The inner product is *hermitian*, taking the `conj` swaps the arguments. -/\n  conj_symm : ∀ x y, conj (inner y x) = inner x y\n  /-- The inner product is positive (semi)definite. -/\n  nonneg_re : ∀ x, 0 ≤ re (inner x x)\n  /-- The inner product is additive in the first coordinate. -/\n  add_left : ∀ x y z, inner (x + y) z = inner x z + inner y z\n  /-- The inner product is conjugate linear in the first coordinate. -/\n  smul_left : ∀ x y r, inner (r • x) y = conj r * inner x y\n\n"}
{"name":"InnerProductSpace.Core.definite","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"𝕜 : Type u_4\nF : Type u_5\ninst✝² : RCLike 𝕜\ninst✝¹ : AddCommGroup F\ninst✝ : Module 𝕜 F\nself : InnerProductSpace.Core 𝕜 F\nx : F\na✝ : Eq (Inner.inner x x) 0\n⊢ Eq x 0","decl":"/-- A structure requiring that a scalar product is positive definite. Some theorems that\nrequire this assumptions are put under section `InnerProductSpace.Core`. -/\n-- @[nolint HasNonemptyInstance] porting note: I don't think we have this linter anymore\nstructure InnerProductSpace.Core (𝕜 : Type*) (F : Type*) [RCLike 𝕜] [AddCommGroup F]\n  [Module 𝕜 F] extends PreInnerProductSpace.Core 𝕜 F where\n  /-- The inner product is positive definite. -/\n  definite : ∀ x, inner x x = 0 → x = 0\n\n/- We set `InnerProductSpace.Core` to be a class as we will use it as such in the construction\nof the normed space structure that it produces. However, all the instances we will use will be\nlocal to this proof. -/\n"}
{"name":"InnerProductSpace.Core.mk.injEq","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"𝕜 : Type u_4\nF : Type u_5\ninst✝² : RCLike 𝕜\ninst✝¹ : AddCommGroup F\ninst✝ : Module 𝕜 F\ntoCore✝ : PreInnerProductSpace.Core 𝕜 F\ndefinite✝ : ∀ (x : F), Eq (Inner.inner x x) 0 → Eq x 0\ntoCore : PreInnerProductSpace.Core 𝕜 F\ndefinite : ∀ (x : F), Eq (Inner.inner x x) 0 → Eq x 0\n⊢ Eq (Eq { toCore := toCore✝, definite := definite✝ } { toCore := toCore, definite := definite }) (Eq toCore✝ toCore)","decl":"/-- A structure requiring that a scalar product is positive definite. Some theorems that\nrequire this assumptions are put under section `InnerProductSpace.Core`. -/\n-- @[nolint HasNonemptyInstance] porting note: I don't think we have this linter anymore\nstructure InnerProductSpace.Core (𝕜 : Type*) (F : Type*) [RCLike 𝕜] [AddCommGroup F]\n  [Module 𝕜 F] extends PreInnerProductSpace.Core 𝕜 F where\n  /-- The inner product is positive definite. -/\n  definite : ∀ x, inner x x = 0 → x = 0\n\n/- We set `InnerProductSpace.Core` to be a class as we will use it as such in the construction\nof the normed space structure that it produces. However, all the instances we will use will be\nlocal to this proof. -/\n"}
{"name":"InnerProductSpace.Core.mk.inj","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"𝕜 : Type u_4\nF : Type u_5\ninst✝² : RCLike 𝕜\ninst✝¹ : AddCommGroup F\ninst✝ : Module 𝕜 F\ntoCore✝ : PreInnerProductSpace.Core 𝕜 F\ndefinite✝ : ∀ (x : F), Eq (Inner.inner x x) 0 → Eq x 0\ntoCore : PreInnerProductSpace.Core 𝕜 F\ndefinite : ∀ (x : F), Eq (Inner.inner x x) 0 → Eq x 0\nx✝ : Eq { toCore := toCore✝, definite := definite✝ } { toCore := toCore, definite := definite }\n⊢ Eq toCore✝ toCore","decl":"/-- A structure requiring that a scalar product is positive definite. Some theorems that\nrequire this assumptions are put under section `InnerProductSpace.Core`. -/\n-- @[nolint HasNonemptyInstance] porting note: I don't think we have this linter anymore\nstructure InnerProductSpace.Core (𝕜 : Type*) (F : Type*) [RCLike 𝕜] [AddCommGroup F]\n  [Module 𝕜 F] extends PreInnerProductSpace.Core 𝕜 F where\n  /-- The inner product is positive definite. -/\n  definite : ∀ x, inner x x = 0 → x = 0\n\n/- We set `InnerProductSpace.Core` to be a class as we will use it as such in the construction\nof the normed space structure that it produces. However, all the instances we will use will be\nlocal to this proof. -/\n"}
{"name":"InnerProductSpace.Core.mk.sizeOf_spec","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"𝕜 : Type u_4\nF : Type u_5\ninst✝⁴ : RCLike 𝕜\ninst✝³ : AddCommGroup F\ninst✝² : Module 𝕜 F\ninst✝¹ : SizeOf 𝕜\ninst✝ : SizeOf F\ntoCore : PreInnerProductSpace.Core 𝕜 F\ndefinite : ∀ (x : F), Eq (Inner.inner x x) 0 → Eq x 0\n⊢ Eq (SizeOf.sizeOf { toCore := toCore, definite := definite }) (HAdd.hAdd 1 (SizeOf.sizeOf toCore))","decl":"/-- A structure requiring that a scalar product is positive definite. Some theorems that\nrequire this assumptions are put under section `InnerProductSpace.Core`. -/\n-- @[nolint HasNonemptyInstance] porting note: I don't think we have this linter anymore\nstructure InnerProductSpace.Core (𝕜 : Type*) (F : Type*) [RCLike 𝕜] [AddCommGroup F]\n  [Module 𝕜 F] extends PreInnerProductSpace.Core 𝕜 F where\n  /-- The inner product is positive definite. -/\n  definite : ∀ x, inner x x = 0 → x = 0\n\n/- We set `InnerProductSpace.Core` to be a class as we will use it as such in the construction\nof the normed space structure that it produces. However, all the instances we will use will be\nlocal to this proof. -/\n"}
{"name":"InnerProductSpace.Core.inner_conj_symm","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"𝕜 : Type u_1\nF : Type u_3\ninst✝² : RCLike 𝕜\ninst✝¹ : AddCommGroup F\ninst✝ : Module 𝕜 F\nc : PreInnerProductSpace.Core 𝕜 F\nx y : F\n⊢ Eq ((starRingEnd 𝕜) (Inner.inner y x)) (Inner.inner x y)","decl":"theorem inner_conj_symm (x y : F) : ⟪y, x⟫† = ⟪x, y⟫ :=\n  c.conj_symm x y\n\n"}
{"name":"InnerProductSpace.Core.inner_self_nonneg","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"𝕜 : Type u_1\nF : Type u_3\ninst✝² : RCLike 𝕜\ninst✝¹ : AddCommGroup F\ninst✝ : Module 𝕜 F\nc : PreInnerProductSpace.Core 𝕜 F\nx : F\n⊢ LE.le 0 (RCLike.re (Inner.inner x x))","decl":"theorem inner_self_nonneg {x : F} : 0 ≤ re ⟪x, x⟫ :=\n  c.nonneg_re _\n\n"}
{"name":"InnerProductSpace.Core.inner_self_im","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"𝕜 : Type u_1\nF : Type u_3\ninst✝² : RCLike 𝕜\ninst✝¹ : AddCommGroup F\ninst✝ : Module 𝕜 F\nc : PreInnerProductSpace.Core 𝕜 F\nx : F\n⊢ Eq (RCLike.im (Inner.inner x x)) 0","decl":"theorem inner_self_im (x : F) : im ⟪x, x⟫ = 0 := by\n  rw [← @ofReal_inj 𝕜, im_eq_conj_sub]\n  simp [inner_conj_symm]\n\n"}
{"name":"InnerProductSpace.Core.inner_add_left","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"𝕜 : Type u_1\nF : Type u_3\ninst✝² : RCLike 𝕜\ninst✝¹ : AddCommGroup F\ninst✝ : Module 𝕜 F\nc : PreInnerProductSpace.Core 𝕜 F\nx y z : F\n⊢ Eq (Inner.inner (HAdd.hAdd x y) z) (HAdd.hAdd (Inner.inner x z) (Inner.inner y z))","decl":"theorem inner_add_left (x y z : F) : ⟪x + y, z⟫ = ⟪x, z⟫ + ⟪y, z⟫ :=\n  c.add_left _ _ _\n\n"}
{"name":"InnerProductSpace.Core.inner_add_right","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"𝕜 : Type u_1\nF : Type u_3\ninst✝² : RCLike 𝕜\ninst✝¹ : AddCommGroup F\ninst✝ : Module 𝕜 F\nc : PreInnerProductSpace.Core 𝕜 F\nx y z : F\n⊢ Eq (Inner.inner x (HAdd.hAdd y z)) (HAdd.hAdd (Inner.inner x y) (Inner.inner x z))","decl":"theorem inner_add_right (x y z : F) : ⟪x, y + z⟫ = ⟪x, y⟫ + ⟪x, z⟫ := by\n  rw [← inner_conj_symm, inner_add_left, RingHom.map_add]; simp only [inner_conj_symm]\n\n"}
{"name":"InnerProductSpace.Core.ofReal_normSq_eq_inner_self","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"𝕜 : Type u_1\nF : Type u_3\ninst✝² : RCLike 𝕜\ninst✝¹ : AddCommGroup F\ninst✝ : Module 𝕜 F\nc : PreInnerProductSpace.Core 𝕜 F\nx : F\n⊢ Eq (↑(InnerProductSpace.Core.normSq x)) (Inner.inner x x)","decl":"theorem ofReal_normSq_eq_inner_self (x : F) : (normSqF x : 𝕜) = ⟪x, x⟫ := by\n  rw [ext_iff]\n  exact ⟨by simp only [ofReal_re]; rfl, by simp only [inner_self_im, ofReal_im]⟩\n\n"}
{"name":"InnerProductSpace.Core.inner_re_symm","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"𝕜 : Type u_1\nF : Type u_3\ninst✝² : RCLike 𝕜\ninst✝¹ : AddCommGroup F\ninst✝ : Module 𝕜 F\nc : PreInnerProductSpace.Core 𝕜 F\nx y : F\n⊢ Eq (RCLike.re (Inner.inner x y)) (RCLike.re (Inner.inner y x))","decl":"theorem inner_re_symm (x y : F) : re ⟪x, y⟫ = re ⟪y, x⟫ := by rw [← inner_conj_symm, conj_re]\n\n"}
{"name":"InnerProductSpace.Core.inner_im_symm","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"𝕜 : Type u_1\nF : Type u_3\ninst✝² : RCLike 𝕜\ninst✝¹ : AddCommGroup F\ninst✝ : Module 𝕜 F\nc : PreInnerProductSpace.Core 𝕜 F\nx y : F\n⊢ Eq (RCLike.im (Inner.inner x y)) (Neg.neg (RCLike.im (Inner.inner y x)))","decl":"theorem inner_im_symm (x y : F) : im ⟪x, y⟫ = -im ⟪y, x⟫ := by rw [← inner_conj_symm, conj_im]\n\n"}
{"name":"InnerProductSpace.Core.inner_smul_left","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"𝕜 : Type u_1\nF : Type u_3\ninst✝² : RCLike 𝕜\ninst✝¹ : AddCommGroup F\ninst✝ : Module 𝕜 F\nc : PreInnerProductSpace.Core 𝕜 F\nx y : F\nr : 𝕜\n⊢ Eq (Inner.inner (HSMul.hSMul r x) y) (HMul.hMul ((starRingEnd 𝕜) r) (Inner.inner x y))","decl":"theorem inner_smul_left (x y : F) {r : 𝕜} : ⟪r • x, y⟫ = r† * ⟪x, y⟫ :=\n  c.smul_left _ _ _\n\n"}
{"name":"InnerProductSpace.Core.inner_smul_right","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"𝕜 : Type u_1\nF : Type u_3\ninst✝² : RCLike 𝕜\ninst✝¹ : AddCommGroup F\ninst✝ : Module 𝕜 F\nc : PreInnerProductSpace.Core 𝕜 F\nx y : F\nr : 𝕜\n⊢ Eq (Inner.inner x (HSMul.hSMul r y)) (HMul.hMul r (Inner.inner x y))","decl":"theorem inner_smul_right (x y : F) {r : 𝕜} : ⟪x, r • y⟫ = r * ⟪x, y⟫ := by\n  rw [← inner_conj_symm, inner_smul_left]\n  simp only [conj_conj, inner_conj_symm, RingHom.map_mul]\n\n"}
{"name":"InnerProductSpace.Core.inner_zero_left","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"𝕜 : Type u_1\nF : Type u_3\ninst✝² : RCLike 𝕜\ninst✝¹ : AddCommGroup F\ninst✝ : Module 𝕜 F\nc : PreInnerProductSpace.Core 𝕜 F\nx : F\n⊢ Eq (Inner.inner 0 x) 0","decl":"theorem inner_zero_left (x : F) : ⟪0, x⟫ = 0 := by\n  rw [← zero_smul 𝕜 (0 : F), inner_smul_left]\n  simp only [zero_mul, RingHom.map_zero]\n\n"}
{"name":"InnerProductSpace.Core.inner_zero_right","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"𝕜 : Type u_1\nF : Type u_3\ninst✝² : RCLike 𝕜\ninst✝¹ : AddCommGroup F\ninst✝ : Module 𝕜 F\nc : PreInnerProductSpace.Core 𝕜 F\nx : F\n⊢ Eq (Inner.inner x 0) 0","decl":"theorem inner_zero_right (x : F) : ⟪x, 0⟫ = 0 := by\n  rw [← inner_conj_symm, inner_zero_left]; simp only [RingHom.map_zero]\n\n"}
{"name":"InnerProductSpace.Core.inner_self_of_eq_zero","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"𝕜 : Type u_1\nF : Type u_3\ninst✝² : RCLike 𝕜\ninst✝¹ : AddCommGroup F\ninst✝ : Module 𝕜 F\nc : PreInnerProductSpace.Core 𝕜 F\nx : F\na✝ : Eq x 0\n⊢ Eq (Inner.inner x x) 0","decl":"theorem inner_self_of_eq_zero {x : F} : x = 0 → ⟪x, x⟫ = 0 := by\n  rintro rfl\n  exact inner_zero_left _\n\n"}
{"name":"InnerProductSpace.Core.normSq_eq_zero_of_eq_zero","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"𝕜 : Type u_1\nF : Type u_3\ninst✝² : RCLike 𝕜\ninst✝¹ : AddCommGroup F\ninst✝ : Module 𝕜 F\nc : PreInnerProductSpace.Core 𝕜 F\nx : F\na✝ : Eq x 0\n⊢ Eq (InnerProductSpace.Core.normSq x) 0","decl":"theorem normSq_eq_zero_of_eq_zero {x : F} : x = 0 → normSqF x = 0 := by\n  rintro rfl\n  simp [normSq, inner_self_of_eq_zero]\n\n"}
{"name":"InnerProductSpace.Core.ne_zero_of_inner_self_ne_zero","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"𝕜 : Type u_1\nF : Type u_3\ninst✝² : RCLike 𝕜\ninst✝¹ : AddCommGroup F\ninst✝ : Module 𝕜 F\nc : PreInnerProductSpace.Core 𝕜 F\nx : F\na✝ : Ne (Inner.inner x x) 0\n⊢ Ne x 0","decl":"theorem ne_zero_of_inner_self_ne_zero {x : F} : ⟪x, x⟫ ≠ 0 → x ≠ 0 :=\n  mt inner_self_of_eq_zero\n"}
{"name":"InnerProductSpace.Core.inner_self_ofReal_re","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"𝕜 : Type u_1\nF : Type u_3\ninst✝² : RCLike 𝕜\ninst✝¹ : AddCommGroup F\ninst✝ : Module 𝕜 F\nc : PreInnerProductSpace.Core 𝕜 F\nx : F\n⊢ Eq (↑(RCLike.re (Inner.inner x x))) (Inner.inner x x)","decl":"theorem inner_self_ofReal_re (x : F) : (re ⟪x, x⟫ : 𝕜) = ⟪x, x⟫ := by\n  norm_num [ext_iff, inner_self_im]\n\n"}
{"name":"InnerProductSpace.Core.norm_inner_symm","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"𝕜 : Type u_1\nF : Type u_3\ninst✝² : RCLike 𝕜\ninst✝¹ : AddCommGroup F\ninst✝ : Module 𝕜 F\nc : PreInnerProductSpace.Core 𝕜 F\nx y : F\n⊢ Eq (Norm.norm (Inner.inner x y)) (Norm.norm (Inner.inner y x))","decl":"theorem norm_inner_symm (x y : F) : ‖⟪x, y⟫‖ = ‖⟪y, x⟫‖ := by rw [← inner_conj_symm, norm_conj]\n\n"}
{"name":"InnerProductSpace.Core.inner_neg_left","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"𝕜 : Type u_1\nF : Type u_3\ninst✝² : RCLike 𝕜\ninst✝¹ : AddCommGroup F\ninst✝ : Module 𝕜 F\nc : PreInnerProductSpace.Core 𝕜 F\nx y : F\n⊢ Eq (Inner.inner (Neg.neg x) y) (Neg.neg (Inner.inner x y))","decl":"theorem inner_neg_left (x y : F) : ⟪-x, y⟫ = -⟪x, y⟫ := by\n  rw [← neg_one_smul 𝕜 x, inner_smul_left]\n  simp\n\n"}
{"name":"InnerProductSpace.Core.inner_neg_right","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"𝕜 : Type u_1\nF : Type u_3\ninst✝² : RCLike 𝕜\ninst✝¹ : AddCommGroup F\ninst✝ : Module 𝕜 F\nc : PreInnerProductSpace.Core 𝕜 F\nx y : F\n⊢ Eq (Inner.inner x (Neg.neg y)) (Neg.neg (Inner.inner x y))","decl":"theorem inner_neg_right (x y : F) : ⟪x, -y⟫ = -⟪x, y⟫ := by\n  rw [← inner_conj_symm, inner_neg_left]; simp only [RingHom.map_neg, inner_conj_symm]\n\n"}
{"name":"InnerProductSpace.Core.inner_sub_left","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"𝕜 : Type u_1\nF : Type u_3\ninst✝² : RCLike 𝕜\ninst✝¹ : AddCommGroup F\ninst✝ : Module 𝕜 F\nc : PreInnerProductSpace.Core 𝕜 F\nx y z : F\n⊢ Eq (Inner.inner (HSub.hSub x y) z) (HSub.hSub (Inner.inner x z) (Inner.inner y z))","decl":"theorem inner_sub_left (x y z : F) : ⟪x - y, z⟫ = ⟪x, z⟫ - ⟪y, z⟫ := by\n  simp [sub_eq_add_neg, inner_add_left, inner_neg_left]\n\n"}
{"name":"InnerProductSpace.Core.inner_sub_right","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"𝕜 : Type u_1\nF : Type u_3\ninst✝² : RCLike 𝕜\ninst✝¹ : AddCommGroup F\ninst✝ : Module 𝕜 F\nc : PreInnerProductSpace.Core 𝕜 F\nx y z : F\n⊢ Eq (Inner.inner x (HSub.hSub y z)) (HSub.hSub (Inner.inner x y) (Inner.inner x z))","decl":"theorem inner_sub_right (x y z : F) : ⟪x, y - z⟫ = ⟪x, y⟫ - ⟪x, z⟫ := by\n  simp [sub_eq_add_neg, inner_add_right, inner_neg_right]\n\n"}
{"name":"InnerProductSpace.Core.inner_mul_symm_re_eq_norm","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"𝕜 : Type u_1\nF : Type u_3\ninst✝² : RCLike 𝕜\ninst✝¹ : AddCommGroup F\ninst✝ : Module 𝕜 F\nc : PreInnerProductSpace.Core 𝕜 F\nx y : F\n⊢ Eq (RCLike.re (HMul.hMul (Inner.inner x y) (Inner.inner y x))) (Norm.norm (HMul.hMul (Inner.inner x y) (Inner.inner y x)))","decl":"theorem inner_mul_symm_re_eq_norm (x y : F) : re (⟪x, y⟫ * ⟪y, x⟫) = ‖⟪x, y⟫ * ⟪y, x⟫‖ := by\n  rw [← inner_conj_symm, mul_comm]\n  exact re_eq_norm_of_mul_conj (inner y x)\n\n"}
{"name":"InnerProductSpace.Core.inner_add_add_self","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"𝕜 : Type u_1\nF : Type u_3\ninst✝² : RCLike 𝕜\ninst✝¹ : AddCommGroup F\ninst✝ : Module 𝕜 F\nc : PreInnerProductSpace.Core 𝕜 F\nx y : F\n⊢ Eq (Inner.inner (HAdd.hAdd x y) (HAdd.hAdd x y)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (Inner.inner x x) (Inner.inner x y)) (Inner.inner y x)) (Inner.inner y y))","decl":"/-- Expand `inner (x + y) (x + y)` -/\ntheorem inner_add_add_self (x y : F) : ⟪x + y, x + y⟫ = ⟪x, x⟫ + ⟪x, y⟫ + ⟪y, x⟫ + ⟪y, y⟫ := by\n  simp only [inner_add_left, inner_add_right]; ring\n\n-- Expand `inner (x - y) (x - y)`\n"}
{"name":"InnerProductSpace.Core.inner_sub_sub_self","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"𝕜 : Type u_1\nF : Type u_3\ninst✝² : RCLike 𝕜\ninst✝¹ : AddCommGroup F\ninst✝ : Module 𝕜 F\nc : PreInnerProductSpace.Core 𝕜 F\nx y : F\n⊢ Eq (Inner.inner (HSub.hSub x y) (HSub.hSub x y)) (HAdd.hAdd (HSub.hSub (HSub.hSub (Inner.inner x x) (Inner.inner x y)) (Inner.inner y x)) (Inner.inner y y))","decl":"theorem inner_sub_sub_self (x y : F) : ⟪x - y, x - y⟫ = ⟪x, x⟫ - ⟪x, y⟫ - ⟪y, x⟫ + ⟪y, y⟫ := by\n  simp only [inner_sub_left, inner_sub_right]; ring\n\n"}
{"name":"InnerProductSpace.Core.inner_smul_ofReal_left","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"𝕜 : Type u_1\nF : Type u_3\ninst✝² : RCLike 𝕜\ninst✝¹ : AddCommGroup F\ninst✝ : Module 𝕜 F\nc : PreInnerProductSpace.Core 𝕜 F\nx y : F\nt : Real\n⊢ Eq (Inner.inner (HSMul.hSMul (↑t) x) y) (HMul.hMul (Inner.inner x y) ↑t)","decl":"theorem inner_smul_ofReal_left (x y : F) {t : ℝ} : ⟪(t : 𝕜) • x, y⟫ = ⟪x, y⟫ * t := by\n  rw [inner_smul_left, conj_ofReal, mul_comm]\n\n"}
{"name":"InnerProductSpace.Core.inner_smul_ofReal_right","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"𝕜 : Type u_1\nF : Type u_3\ninst✝² : RCLike 𝕜\ninst✝¹ : AddCommGroup F\ninst✝ : Module 𝕜 F\nc : PreInnerProductSpace.Core 𝕜 F\nx y : F\nt : Real\n⊢ Eq (Inner.inner x (HSMul.hSMul (↑t) y)) (HMul.hMul (Inner.inner x y) ↑t)","decl":"theorem inner_smul_ofReal_right (x y : F) {t : ℝ} : ⟪x, (t : 𝕜) • y⟫ = ⟪x, y⟫ * t := by\n  rw [inner_smul_right, mul_comm]\n\n"}
{"name":"InnerProductSpace.Core.re_inner_smul_ofReal_smul_self","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"𝕜 : Type u_1\nF : Type u_3\ninst✝² : RCLike 𝕜\ninst✝¹ : AddCommGroup F\ninst✝ : Module 𝕜 F\nc : PreInnerProductSpace.Core 𝕜 F\nx : F\nt : Real\n⊢ Eq (RCLike.re (Inner.inner (HSMul.hSMul (↑t) x) (HSMul.hSMul (↑t) x))) (HMul.hMul (HMul.hMul (InnerProductSpace.Core.normSq x) t) t)","decl":"theorem re_inner_smul_ofReal_smul_self (x : F) {t : ℝ} :\n    re ⟪(t : 𝕜) • x, (t : 𝕜) • x⟫ = normSqF x * t * t := by\n  apply ofReal_injective (K := 𝕜)\n  simp [inner_self_ofReal_re, inner_smul_ofReal_left, inner_smul_ofReal_right, normSq]\n\n"}
{"name":"InnerProductSpace.Core.cauchy_schwarz_aux'","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"𝕜 : Type u_1\nF : Type u_3\ninst✝² : RCLike 𝕜\ninst✝¹ : AddCommGroup F\ninst✝ : Module 𝕜 F\nc : PreInnerProductSpace.Core 𝕜 F\nx y : F\nt : Real\n⊢ LE.le 0 (HAdd.hAdd (HAdd.hAdd (HMul.hMul (HMul.hMul (InnerProductSpace.Core.normSq x) t) t) (HMul.hMul (HMul.hMul 2 (RCLike.re (Inner.inner x y))) t)) (InnerProductSpace.Core.normSq y))","decl":"/-- An auxiliary equality useful to prove the **Cauchy–Schwarz inequality**. Here we use the\nstandard argument involving the discriminant of quadratic form. -/\nlemma cauchy_schwarz_aux' (x y : F) (t : ℝ) : 0 ≤ normSqF x * t * t + 2 * re ⟪x, y⟫ * t\n    + normSqF y := by\n  calc 0 ≤ re ⟪(ofReal t : 𝕜) • x + y, (ofReal t : 𝕜) • x + y⟫ := inner_self_nonneg\n  _ = re (⟪(ofReal t : 𝕜) • x, (ofReal t : 𝕜) • x⟫ + ⟪(ofReal t : 𝕜) • x, y⟫\n      + ⟪y, (ofReal t : 𝕜) • x⟫ + ⟪y, y⟫) := by rw [inner_add_add_self ((ofReal t : 𝕜) • x) y]\n  _ = re ⟪(ofReal t : 𝕜) • x, (ofReal t : 𝕜) • x⟫\n      + re ⟪(ofReal t : 𝕜) • x, y⟫ + re ⟪y, (ofReal t : 𝕜) • x⟫ + re ⟪y, y⟫ := by\n      simp only [map_add]\n  _ = normSq x * t * t + re (⟪x, y⟫ * t) + re (⟪y, x⟫ * t) + re ⟪y, y⟫ := by rw\n    [re_inner_smul_ofReal_smul_self, inner_smul_ofReal_left, inner_smul_ofReal_right]\n  _ = normSq x * t * t + re ⟪x, y⟫ * t + re ⟪y, x⟫ * t + re ⟪y, y⟫ := by rw [mul_comm ⟪x,y⟫ _,\n    RCLike.re_ofReal_mul, mul_comm t _, mul_comm ⟪y,x⟫ _, RCLike.re_ofReal_mul, mul_comm t _]\n  _ = normSq x * t * t + re ⟪x, y⟫ * t + re ⟪y, x⟫ * t + normSq y := by rw [← normSq]\n  _ = normSq x * t * t + re ⟪x, y⟫ * t + re ⟪x, y⟫ * t + normSq y := by rw [inner_re_symm]\n  _ = normSq x * t * t + 2 * re ⟪x, y⟫ * t + normSq y := by ring\n\n"}
{"name":"InnerProductSpace.Core.cauchy_schwarz_aux","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"𝕜 : Type u_1\nF : Type u_3\ninst✝² : RCLike 𝕜\ninst✝¹ : AddCommGroup F\ninst✝ : Module 𝕜 F\nc : PreInnerProductSpace.Core 𝕜 F\nx y : F\n⊢ Eq (InnerProductSpace.Core.normSq (HSub.hSub (HSMul.hSMul (Inner.inner x y) x) (HSMul.hSMul (Inner.inner x x) y))) (HMul.hMul (InnerProductSpace.Core.normSq x) (HSub.hSub (HMul.hMul (InnerProductSpace.Core.normSq x) (InnerProductSpace.Core.normSq y)) (HPow.hPow (Norm.norm (Inner.inner x y)) 2)))","decl":"/-- Another auxiliary equality related with the **Cauchy–Schwarz inequality**: the square of the\nseminorm of `⟪x, y⟫ • x - ⟪x, x⟫ • y` is equal to `‖x‖ ^ 2 * (‖x‖ ^ 2 * ‖y‖ ^ 2 - ‖⟪x, y⟫‖ ^ 2)`.\nWe use `InnerProductSpace.ofCore.normSq x` etc (defeq to `is_R_or_C.re ⟪x, x⟫`) instead of `‖x‖ ^ 2`\netc to avoid extra rewrites when applying it to an `InnerProductSpace`. -/\ntheorem cauchy_schwarz_aux (x y : F) : normSqF (⟪x, y⟫ • x - ⟪x, x⟫ • y)\n    = normSqF x * (normSqF x * normSqF y - ‖⟪x, y⟫‖ ^ 2) := by\n  rw [← @ofReal_inj 𝕜, ofReal_normSq_eq_inner_self]\n  simp only [inner_sub_sub_self, inner_smul_left, inner_smul_right, conj_ofReal, mul_sub, ←\n    ofReal_normSq_eq_inner_self x, ← ofReal_normSq_eq_inner_self y]\n  rw [← mul_assoc, mul_conj, RCLike.conj_mul, mul_left_comm, ← inner_conj_symm y, mul_conj]\n  push_cast\n  ring\n\n"}
{"name":"InnerProductSpace.Core.inner_mul_inner_self_le","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"𝕜 : Type u_1\nF : Type u_3\ninst✝² : RCLike 𝕜\ninst✝¹ : AddCommGroup F\ninst✝ : Module 𝕜 F\nc : PreInnerProductSpace.Core 𝕜 F\nx y : F\n⊢ LE.le (HMul.hMul (Norm.norm (Inner.inner x y)) (Norm.norm (Inner.inner y x))) (HMul.hMul (RCLike.re (Inner.inner x x)) (RCLike.re (Inner.inner y y)))","decl":"/-- **Cauchy–Schwarz inequality**.\nWe need this for the `PreInnerProductSpace.Core` structure to prove the triangle inequality below\nwhen showing the core is a normed group and to take the quotient.\n\n(This is not intended for general use; see `Analysis.InnerProductSpace.Basic` for a variety of\nversions of Cauchy-Schwartz for an inner product space, rather than a `PreInnerProductSpace.Core`).\n-/\ntheorem inner_mul_inner_self_le (x y : F) : ‖⟪x, y⟫‖ * ‖⟪y, x⟫‖ ≤ re ⟪x, x⟫ * re ⟪y, y⟫ := by\n  suffices discrim (normSqF x) (2 * ‖⟪x, y⟫_𝕜‖) (normSqF y) ≤ 0 by\n    rw [norm_inner_symm y x]\n    rw [discrim, normSq, normSq, sq] at this\n    linarith\n  refine discrim_le_zero fun t ↦ ?_\n  by_cases hzero : ⟪x, y⟫ = 0\n  · simp only [mul_assoc, ← sq, hzero, norm_zero, mul_zero, zero_mul, add_zero, ge_iff_le]\n    obtain ⟨hx, hy⟩ : (0 ≤ normSqF x ∧ 0 ≤ normSqF y) := ⟨inner_self_nonneg, inner_self_nonneg⟩\n    positivity\n  · have hzero' : ‖⟪x, y⟫‖ ≠ 0 := norm_ne_zero_iff.2 hzero\n    convert cauchy_schwarz_aux' (𝕜 := 𝕜) (⟪x, y⟫ • x) y (t / ‖⟪x, y⟫‖) using 3\n    · field_simp\n      rw [← sq, normSq, normSq, inner_smul_right, inner_smul_left, ← mul_assoc _ _ ⟪x, x⟫,\n        mul_conj]\n      nth_rw 2 [sq]\n      rw [← ofReal_mul, re_ofReal_mul]\n      ring\n    · field_simp\n      rw [inner_smul_left, mul_comm _ ⟪x, y⟫_𝕜, mul_conj, ← ofReal_pow, ofReal_re]\n      ring\n\n"}
{"name":"InnerProductSpace.Core.norm_eq_sqrt_inner","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"𝕜 : Type u_1\nF : Type u_3\ninst✝² : RCLike 𝕜\ninst✝¹ : AddCommGroup F\ninst✝ : Module 𝕜 F\nc : PreInnerProductSpace.Core 𝕜 F\nx : F\n⊢ Eq (Norm.norm x) (RCLike.re (Inner.inner x x)).sqrt","decl":"theorem norm_eq_sqrt_inner (x : F) : ‖x‖ = √(re ⟪x, x⟫) := rfl\n\n"}
{"name":"InnerProductSpace.Core.inner_self_eq_norm_mul_norm","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"𝕜 : Type u_1\nF : Type u_3\ninst✝² : RCLike 𝕜\ninst✝¹ : AddCommGroup F\ninst✝ : Module 𝕜 F\nc : PreInnerProductSpace.Core 𝕜 F\nx : F\n⊢ Eq (RCLike.re (Inner.inner x x)) (HMul.hMul (Norm.norm x) (Norm.norm x))","decl":"theorem inner_self_eq_norm_mul_norm (x : F) : re ⟪x, x⟫ = ‖x‖ * ‖x‖ := by\n  rw [norm_eq_sqrt_inner, ← sqrt_mul inner_self_nonneg (re ⟪x, x⟫), sqrt_mul_self inner_self_nonneg]\n\n"}
{"name":"InnerProductSpace.Core.sqrt_normSq_eq_norm","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"𝕜 : Type u_1\nF : Type u_3\ninst✝² : RCLike 𝕜\ninst✝¹ : AddCommGroup F\ninst✝ : Module 𝕜 F\nc : PreInnerProductSpace.Core 𝕜 F\nx : F\n⊢ Eq (InnerProductSpace.Core.normSq x).sqrt (Norm.norm x)","decl":"theorem sqrt_normSq_eq_norm (x : F) : √(normSqF x) = ‖x‖ := rfl\n\n"}
{"name":"InnerProductSpace.Core.norm_inner_le_norm","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"𝕜 : Type u_1\nF : Type u_3\ninst✝² : RCLike 𝕜\ninst✝¹ : AddCommGroup F\ninst✝ : Module 𝕜 F\nc : PreInnerProductSpace.Core 𝕜 F\nx y : F\n⊢ LE.le (Norm.norm (Inner.inner x y)) (HMul.hMul (Norm.norm x) (Norm.norm y))","decl":"/-- Cauchy–Schwarz inequality with norm -/\ntheorem norm_inner_le_norm (x y : F) : ‖⟪x, y⟫‖ ≤ ‖x‖ * ‖y‖ :=\n  nonneg_le_nonneg_of_sq_le_sq (mul_nonneg (sqrt_nonneg _) (sqrt_nonneg _)) <|\n    calc\n      ‖⟪x, y⟫‖ * ‖⟪x, y⟫‖ = ‖⟪x, y⟫‖ * ‖⟪y, x⟫‖ := by rw [norm_inner_symm]\n      _ ≤ re ⟪x, x⟫ * re ⟪y, y⟫ := inner_mul_inner_self_le x y\n      _ = ‖x‖ * ‖y‖ * (‖x‖ * ‖y‖) := by simp only [inner_self_eq_norm_mul_norm]; ring\n\n"}
{"name":"InnerProductSpace.Core.inner_self_eq_zero","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"𝕜 : Type u_1\nF : Type u_3\ninst✝² : RCLike 𝕜\ninst✝¹ : AddCommGroup F\ninst✝ : Module 𝕜 F\ncd : InnerProductSpace.Core 𝕜 F\nx : F\n⊢ Iff (Eq (Inner.inner x x) 0) (Eq x 0)","decl":"theorem inner_self_eq_zero {x : F} : ⟪x, x⟫ = 0 ↔ x = 0 :=\n  ⟨cd.definite _, inner_self_of_eq_zero⟩\n\n"}
{"name":"InnerProductSpace.Core.normSq_eq_zero","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"𝕜 : Type u_1\nF : Type u_3\ninst✝² : RCLike 𝕜\ninst✝¹ : AddCommGroup F\ninst✝ : Module 𝕜 F\ncd : InnerProductSpace.Core 𝕜 F\nx : F\n⊢ Iff (Eq (InnerProductSpace.Core.normSq x) 0) (Eq x 0)","decl":"theorem normSq_eq_zero {x : F} : normSqF x = 0 ↔ x = 0 :=\n  Iff.trans\n    (by simp only [normSq, ext_iff, map_zero, inner_self_im, eq_self_iff_true, and_true])\n    (@inner_self_eq_zero 𝕜 _ _ _ _ _ x)\n\n"}
{"name":"InnerProductSpace.Core.inner_self_ne_zero","module":"Mathlib.Analysis.InnerProductSpace.Defs","initialProofState":"𝕜 : Type u_1\nF : Type u_3\ninst✝² : RCLike 𝕜\ninst✝¹ : AddCommGroup F\ninst✝ : Module 𝕜 F\ncd : InnerProductSpace.Core 𝕜 F\nx : F\n⊢ Iff (Ne (Inner.inner x x) 0) (Ne x 0)","decl":"theorem inner_self_ne_zero {x : F} : ⟪x, x⟫ ≠ 0 ↔ x ≠ 0 :=\n  inner_self_eq_zero.not\n\n"}
