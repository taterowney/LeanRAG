{"name":"MeasureTheory.Measure.MeasureDense.approx","module":"Mathlib.MeasureTheory.Measure.SeparableMeasure","initialProofState":"X : Type u_1\nm : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\nğ’œ : Set (Set X)\nself : Î¼.MeasureDense ğ’œ\ns : Set X\naâœÂ² : MeasurableSet s\naâœÂ¹ : Ne (Î¼ s) Top.top\nÎµ : Real\naâœ : LT.lt 0 Îµ\nâŠ¢ Exists fun t => And (Membership.mem ğ’œ t) (LT.lt (Î¼ (symmDiff s t)) (ENNReal.ofReal Îµ))","decl":"/-- A family `ğ’œ` of sets of a measure space is said to be measure-dense if it contains only\nmeasurable sets and can approximate any measurable set with finite measure, in the sense that\nfor any measurable set `s` with finite measure the symmetric difference `s âˆ† t` can be made\narbitrarily small when `t âˆˆ ğ’œ`. We show below that such a family can be chosen to contain only\nsets with finite measures.\n\nThe term \"measure-dense\" is justified by the fact that the approximating condition translates\nto the usual notion of density in the metric space made by constant indicators of measurable sets\nequipped with the `Láµ–` norm. -/\nstructure Measure.MeasureDense (Î¼ : Measure X) (ğ’œ : Set (Set X)) : Prop where\n  /-- Each set has to be measurable. -/\n  measurable : âˆ€ s âˆˆ ğ’œ, MeasurableSet s\n  /-- Any measurable set can be approximated by sets in the family. -/\n  approx : âˆ€ s, MeasurableSet s â†’ Î¼ s â‰  âˆ â†’ âˆ€ Îµ : â„, 0 < Îµ â†’ âˆƒ t âˆˆ ğ’œ, Î¼ (s âˆ† t) < ENNReal.ofReal Îµ\n\n"}
{"name":"MeasureTheory.Measure.MeasureDense.measurable","module":"Mathlib.MeasureTheory.Measure.SeparableMeasure","initialProofState":"X : Type u_1\nm : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\nğ’œ : Set (Set X)\nself : Î¼.MeasureDense ğ’œ\ns : Set X\naâœ : Membership.mem ğ’œ s\nâŠ¢ MeasurableSet s","decl":"/-- A family `ğ’œ` of sets of a measure space is said to be measure-dense if it contains only\nmeasurable sets and can approximate any measurable set with finite measure, in the sense that\nfor any measurable set `s` with finite measure the symmetric difference `s âˆ† t` can be made\narbitrarily small when `t âˆˆ ğ’œ`. We show below that such a family can be chosen to contain only\nsets with finite measures.\n\nThe term \"measure-dense\" is justified by the fact that the approximating condition translates\nto the usual notion of density in the metric space made by constant indicators of measurable sets\nequipped with the `Láµ–` norm. -/\nstructure Measure.MeasureDense (Î¼ : Measure X) (ğ’œ : Set (Set X)) : Prop where\n  /-- Each set has to be measurable. -/\n  measurable : âˆ€ s âˆˆ ğ’œ, MeasurableSet s\n  /-- Any measurable set can be approximated by sets in the family. -/\n  approx : âˆ€ s, MeasurableSet s â†’ Î¼ s â‰  âˆ â†’ âˆ€ Îµ : â„, 0 < Îµ â†’ âˆƒ t âˆˆ ğ’œ, Î¼ (s âˆ† t) < ENNReal.ofReal Îµ\n\n"}
{"name":"MeasureTheory.Measure.MeasureDense.nonempty","module":"Mathlib.MeasureTheory.Measure.SeparableMeasure","initialProofState":"X : Type u_1\nm : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\nğ’œ : Set (Set X)\nhğ’œ : Î¼.MeasureDense ğ’œ\nâŠ¢ ğ’œ.Nonempty","decl":"theorem Measure.MeasureDense.nonempty (hğ’œ : Î¼.MeasureDense ğ’œ) : ğ’œ.Nonempty := by\n  rcases hğ’œ.approx âˆ… MeasurableSet.empty (by simp) 1 (by norm_num) with âŸ¨t, ht, -âŸ©\n  exact âŸ¨t, htâŸ©\n\n"}
{"name":"MeasureTheory.Measure.MeasureDense.nonempty'","module":"Mathlib.MeasureTheory.Measure.SeparableMeasure","initialProofState":"X : Type u_1\nm : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\nğ’œ : Set (Set X)\nhğ’œ : Î¼.MeasureDense ğ’œ\nâŠ¢ (setOf fun s => And (Membership.mem ğ’œ s) (Ne (Î¼ s) Top.top)).Nonempty","decl":"theorem Measure.MeasureDense.nonempty' (hğ’œ : Î¼.MeasureDense ğ’œ) :\n    {s | s âˆˆ ğ’œ âˆ§ Î¼ s â‰  âˆ}.Nonempty := by\n  rcases hğ’œ.approx âˆ… MeasurableSet.empty (by simp) 1 (by norm_num) with âŸ¨t, ht, hÎ¼tâŸ©\n  refine âŸ¨t, ht, ?_âŸ©\n  convert ne_top_of_lt hÎ¼t\n  rw [â† bot_eq_empty, bot_symmDiff]\n\n"}
{"name":"MeasureTheory.measureDense_measurableSet","module":"Mathlib.MeasureTheory.Measure.SeparableMeasure","initialProofState":"X : Type u_1\nm : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\nâŠ¢ Î¼.MeasureDense (setOf fun s => MeasurableSet s)","decl":"/-- The set of measurable sets is measure-dense. -/\ntheorem measureDense_measurableSet : Î¼.MeasureDense {s | MeasurableSet s} where\n  measurable _ h := h\n  approx s hs _ Îµ Îµ_pos := âŸ¨s, hs, by simpaâŸ©\n\n"}
{"name":"MeasureTheory.Measure.MeasureDense.fin_meas_approx","module":"Mathlib.MeasureTheory.Measure.SeparableMeasure","initialProofState":"X : Type u_1\nm : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\nğ’œ : Set (Set X)\nhğ’œ : Î¼.MeasureDense ğ’œ\ns : Set X\nms : MeasurableSet s\nhÎ¼s : Ne (Î¼ s) Top.top\nÎµ : Real\nÎµ_pos : LT.lt 0 Îµ\nâŠ¢ Exists fun t => And (Membership.mem ğ’œ t) (And (Ne (Î¼ t) Top.top) (LT.lt (Î¼ (symmDiff s t)) (ENNReal.ofReal Îµ)))","decl":"/-- If a family of sets `ğ’œ` is measure-dense in `X`, then any measurable set with finite measure\ncan be approximated by sets in `ğ’œ` with finite measure. -/\nlemma Measure.MeasureDense.fin_meas_approx (hğ’œ : Î¼.MeasureDense ğ’œ) {s : Set X}\n    (ms : MeasurableSet s) (hÎ¼s : Î¼ s â‰  âˆ) (Îµ : â„) (Îµ_pos : 0 < Îµ) :\n    âˆƒ t âˆˆ ğ’œ, Î¼ t â‰  âˆ âˆ§ Î¼ (s âˆ† t) < ENNReal.ofReal Îµ := by\n  rcases hğ’œ.approx s ms hÎ¼s Îµ Îµ_pos with âŸ¨t, t_mem, htâŸ©\n  exact âŸ¨t, t_mem, (measure_ne_top_iff_of_symmDiff <| ne_top_of_lt ht).1 hÎ¼s, htâŸ©\n\n"}
{"name":"MeasureTheory.Measure.MeasureDense.indicatorConstLp_subset_closure","module":"Mathlib.MeasureTheory.Measure.SeparableMeasure","initialProofState":"X : Type u_1\nE : Type u_2\nm : MeasurableSpace X\ninstâœ : NormedAddCommGroup E\nÎ¼ : MeasureTheory.Measure X\np : ENNReal\none_le_p : Fact (LE.le 1 p)\np_ne_top : Fact (Ne p Top.top)\nğ’œ : Set (Set X)\nhğ’œ : Î¼.MeasureDense ğ’œ\nc : E\nâŠ¢ HasSubset.Subset (setOf fun x => Exists fun s => Exists fun hs => Exists fun hÎ¼s => Eq (MeasureTheory.indicatorConstLp p hs hÎ¼s c) x) (closure (setOf fun x => Exists fun s => Exists fun hs => Exists fun hÎ¼s => Eq (MeasureTheory.indicatorConstLp p â‹¯ hÎ¼s c) x))","decl":"variable (p) in\n/-- If `ğ’œ` is a measure-dense family of sets and `c : E`, then the set of constant indicators\nwith constant `c` whose underlying set is in `ğ’œ` is dense in the set of constant indicators\nwhich are in `Lp E p Î¼` when `1 â‰¤ p < âˆ`. -/\ntheorem Measure.MeasureDense.indicatorConstLp_subset_closure (hğ’œ : Î¼.MeasureDense ğ’œ) (c : E) :\n    {indicatorConstLp p hs hÎ¼s c | (s : Set X) (hs : MeasurableSet s) (hÎ¼s : Î¼ s â‰  âˆ)} âŠ†\n    closure {indicatorConstLp p (hğ’œ.measurable s hs) hÎ¼s c |\n      (s : Set X) (hs : s âˆˆ ğ’œ) (hÎ¼s : Î¼ s â‰  âˆ)} := by\n  obtain rfl | hc := eq_or_ne c 0\n  Â· refine Subset.trans ?_ subset_closure\n    rintro - âŸ¨s, ms, hÎ¼s, rflâŸ©\n    obtain âŸ¨t, ht, hÎ¼tâŸ© := hğ’œ.nonempty'\n    refine âŸ¨t, ht, hÎ¼t, ?_âŸ©\n    simp_rw [indicatorConstLp]\n    congr\n    simp\n  Â· have p_pos : 0 < p := lt_of_lt_of_le (by norm_num) one_le_p.elim\n    rintro - âŸ¨s, ms, hÎ¼s, rflâŸ©\n    refine Metric.mem_closure_iff.2 fun Îµ hÎµ â†¦ ?_\n    have aux : 0 < (Îµ / â€–câ€–) ^ p.toReal := rpow_pos_of_pos (div_pos hÎµ (norm_pos_iff.2 hc)) _\n    obtain âŸ¨t, ht, hÎ¼t, hÎ¼stâŸ© := hğ’œ.fin_meas_approx ms hÎ¼s ((Îµ / â€–câ€–) ^ p.toReal) aux\n    refine âŸ¨indicatorConstLp p (hğ’œ.measurable t ht) hÎ¼t c,\n      âŸ¨t, ht, hÎ¼t, rflâŸ©, ?_âŸ©\n    rw [dist_indicatorConstLp_eq_norm, norm_indicatorConstLp p_pos.ne.symm p_ne_top.elim]\n    calc\n      â€–câ€– * (Î¼ (s âˆ† t)).toReal ^ (1 / p.toReal)\n        < â€–câ€– * (ENNReal.ofReal ((Îµ / â€–câ€–) ^ p.toReal)).toReal ^ (1 / p.toReal) := by\n          rw [_root_.mul_lt_mul_left (norm_pos_iff.2 hc)]\n          refine Real.rpow_lt_rpow (by simp) ?_\n            (one_div_pos.2 <| toReal_pos p_pos.ne.symm p_ne_top.elim)\n          rwa [toReal_lt_toReal (measure_symmDiff_ne_top hÎ¼s hÎ¼t) ofReal_ne_top]\n      _ = Îµ := by\n        rw [toReal_ofReal (rpow_nonneg (div_nonneg hÎµ.le (norm_nonneg _)) _),\n          one_div, Real.rpow_rpow_inv (div_nonneg hÎµ.le (norm_nonneg _))\n            (toReal_pos p_pos.ne.symm p_ne_top.elim).ne.symm,\n          mul_div_cancelâ‚€ _ (norm_ne_zero_iff.2 hc)]\n\n"}
{"name":"MeasureTheory.Measure.MeasureDense.fin_meas","module":"Mathlib.MeasureTheory.Measure.SeparableMeasure","initialProofState":"X : Type u_1\nm : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\nğ’œ : Set (Set X)\nhğ’œ : Î¼.MeasureDense ğ’œ\nâŠ¢ Î¼.MeasureDense (setOf fun s => And (Membership.mem ğ’œ s) (Ne (Î¼ s) Top.top))","decl":"/-- If a family of sets `ğ’œ` is measure-dense in `X`, then it is also the case for the sets in `ğ’œ`\nwith finite measure. -/\ntheorem Measure.MeasureDense.fin_meas (hğ’œ : Î¼.MeasureDense ğ’œ) :\n    Î¼.MeasureDense {s | s âˆˆ ğ’œ âˆ§ Î¼ s â‰  âˆ} where\n  measurable s h := hğ’œ.measurable s h.1\n  approx s ms hÎ¼s Îµ Îµ_pos := by\n    rcases Measure.MeasureDense.fin_meas_approx hğ’œ ms hÎ¼s Îµ Îµ_pos with âŸ¨t, t_mem, hÎ¼t, hÎ¼stâŸ©\n    exact âŸ¨t, âŸ¨t_mem, hÎ¼tâŸ©, hÎ¼stâŸ©\n\n"}
{"name":"MeasureTheory.Measure.MeasureDense.of_generateFrom_isSetAlgebra_finite","module":"Mathlib.MeasureTheory.Measure.SeparableMeasure","initialProofState":"X : Type u_1\nm : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\nğ’œ : Set (Set X)\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nhğ’œ : MeasureTheory.IsSetAlgebra ğ’œ\nhgen : Eq m (MeasurableSpace.generateFrom ğ’œ)\nâŠ¢ Î¼.MeasureDense ğ’œ","decl":"/-- If a measurable space equipped with a finite measure is generated by an algebra of sets, then\nthis algebra of sets is measure-dense. -/\ntheorem Measure.MeasureDense.of_generateFrom_isSetAlgebra_finite [IsFiniteMeasure Î¼]\n    (hğ’œ : IsSetAlgebra ğ’œ) (hgen : m = MeasurableSpace.generateFrom ğ’œ) : Î¼.MeasureDense ğ’œ where\n  measurable s hs := hgen â–¸ measurableSet_generateFrom hs\n  approx s ms := by\n    -- We want to show that any measurable set can be approximated by sets in `ğ’œ`. To do so, it is\n    -- enough to show that such sets constitute a `Ïƒ`-algebra containing `ğ’œ`. This is contained in\n    -- the theorem `generateFrom_induction`.\n    have : MeasurableSet s âˆ§ âˆ€ (Îµ : â„), 0 < Îµ â†’ âˆƒ t âˆˆ ğ’œ, (Î¼ (s âˆ† t)).toReal < Îµ := by\n      induction s, hgen â–¸ ms using generateFrom_induction with\n      -- If `t âˆˆ ğ’œ`, then `Î¼ (t âˆ† t) = 0` which is less than any `Îµ > 0`.\n      | hC t t_mem _ =>\n        exact âŸ¨hgen â–¸ measurableSet_generateFrom t_mem, fun Îµ Îµ_pos â†¦ âŸ¨t, t_mem, by simpaâŸ©âŸ©\n      -- `âˆ… âˆˆ ğ’œ` and `Î¼ (âˆ… âˆ† âˆ…) = 0` which is less than any `Îµ > 0`.\n      | empty => exact âŸ¨MeasurableSet.empty, fun Îµ Îµ_pos â†¦ âŸ¨âˆ…, hğ’œ.empty_mem, by simpaâŸ©âŸ©\n      -- If `s` is measurable and `t âˆˆ ğ’œ` such that `Î¼ (s âˆ† t) < Îµ`, then `tá¶œ âˆˆ ğ’œ` and\n      -- `Î¼ (sá¶œ âˆ† tá¶œ) = Î¼ (s âˆ† t) < Îµ` so `sá¶œ` can be approximated.\n      | compl t _ ht =>\n        refine âŸ¨ht.1.compl, fun Îµ Îµ_pos â†¦ ?_âŸ©\n        obtain âŸ¨u, u_mem, hÎ¼tcuâŸ© := ht.2 Îµ Îµ_pos\n        exact âŸ¨uá¶œ, hğ’œ.compl_mem u_mem, by rwa [compl_symmDiff_compl]âŸ©\n      -- Let `(fâ‚™)` be a sequence of measurable sets and `Îµ > 0`.\n      | iUnion f _ hf =>\n        refine âŸ¨MeasurableSet.iUnion (fun n â†¦ (hf n).1), fun Îµ Îµ_pos â†¦ ?_âŸ©\n        -- We have  `Î¼ (â‹ƒ n â‰¤ N, fâ‚™) âŸ¶ Î¼ (â‹ƒ n, fâ‚™)`.\n        have := tendsto_measure_iUnion_accumulate (Î¼ := Î¼) (f := f)\n        rw [â† tendsto_toReal_iff (fun _ â†¦ measure_ne_top _ _) (measure_ne_top _ _)] at this\n        -- So there exists `N` such that `Î¼ (â‹ƒ n, fâ‚™) - Î¼ (â‹ƒ n â‰¤ N, fâ‚™) < Îµ/2`.\n        rcases Metric.tendsto_atTop.1 this (Îµ / 2) (by linarith [Îµ_pos]) with âŸ¨N, hNâŸ©\n        -- For any `n â‰¤ N` there exists `gâ‚™ âˆˆ ğ’œ` such that `Î¼ (fâ‚™ âˆ† gâ‚™) < Îµ/(2*(N+1))`.\n        choose g g_mem hg using fun n â†¦ (hf n).2 (Îµ / (2 * (N + 1))) (div_pos Îµ_pos (by linarith))\n        -- Therefore we have\n        -- `Î¼ ((â‹ƒ n, fâ‚™) âˆ† (â‹ƒ n â‰¤ N, gâ‚™))`\n        --   `â‰¤ Î¼ ((â‹ƒ n, fâ‚™) âˆ† (â‹ƒ n â‰¤ N, fâ‚™)) + Î¼ ((â‹ƒ n â‰¤ N, fâ‚™) âˆ† (â‹ƒ n â‰¤ N, gâ‚™))`\n        --   `< Îµ/2 + âˆ‘ n â‰¤ N, Î¼ (fâ‚™ âˆ† gâ‚™)` (see `biSup_symmDiff_biSup_le`)\n        --   `< Îµ/2 + (N+1)*Îµ/(2*(N+1)) = Îµ/2`.\n        refine âŸ¨â‹ƒ n âˆˆ Finset.range (N + 1), g n, hğ’œ.biUnion_mem _ (fun i _ â†¦ g_mem i), ?_âŸ©\n        calc\n          (Î¼ ((â‹ƒ n, f n) âˆ† (â‹ƒ n âˆˆ (Finset.range (N + 1)), g n))).toReal\n            â‰¤ (Î¼ ((â‹ƒ n, f n) \\ ((â‹ƒ n âˆˆ (Finset.range (N + 1)), f n)) âˆª\n              ((â‹ƒ n âˆˆ (Finset.range (N + 1)), f n) âˆ†\n              (â‹ƒ n âˆˆ (Finset.range (N + 1)), g â†‘n)))).toReal :=\n                toReal_mono (measure_ne_top _ _)\n                  (measure_mono <| symmDiff_of_ge (iUnion_subset <|\n                  fun i â†¦ iUnion_subset (fun _ â†¦ subset_iUnion f i)) â–¸ symmDiff_triangle ..)\n          _ â‰¤ (Î¼ ((â‹ƒ n, f n) \\\n              ((â‹ƒ n âˆˆ (Finset.range (N + 1)), f n)))).toReal +\n              (Î¼ ((â‹ƒ n âˆˆ (Finset.range (N + 1)), f n) âˆ†\n              (â‹ƒ n âˆˆ (Finset.range (N + 1)), g â†‘n))).toReal := by\n                rw [â† toReal_add (measure_ne_top _ _) (measure_ne_top _ _)]\n                exact toReal_mono (add_ne_top.2 âŸ¨measure_ne_top _ _, measure_ne_top _ _âŸ©) <|\n                  measure_union_le _ _\n          _ < Îµ := by\n                rw [â† add_halves Îµ]\n                apply _root_.add_lt_add\n                Â· rw [measure_diff (h_fin := measure_ne_top _ _),\n                    toReal_sub_of_le (ha := measure_ne_top _ _)]\n                  Â· apply lt_of_le_of_lt (sub_le_dist ..)\n                    simp only [Finset.mem_range, Nat.lt_add_one_iff]\n                    exact (dist_comm (Î± := â„) .. â–¸ hN N (le_refl N))\n                  Â· exact measure_mono <| iUnion_subset <|\n                      fun i â†¦ iUnion_subset fun _ â†¦ subset_iUnion f i\n                  Â· exact iUnion_subset <| fun i â†¦ iUnion_subset (fun _ â†¦ subset_iUnion f i)\n                  Â· exact MeasurableSet.biUnion (countable_coe_iff.1 inferInstance)\n                      (fun n _ â†¦ (hf n).1.nullMeasurableSet)\n                Â· calc\n                    (Î¼ ((â‹ƒ n âˆˆ (Finset.range (N + 1)), f n) âˆ†\n                    (â‹ƒ n âˆˆ (Finset.range (N + 1)), g â†‘n))).toReal\n                      â‰¤ (Î¼ (â‹ƒ n âˆˆ (Finset.range (N + 1)), f n âˆ† g n)).toReal :=\n                          toReal_mono (measure_ne_top _ _) (measure_mono biSup_symmDiff_biSup_le)\n                    _ â‰¤ âˆ‘ n âˆˆ Finset.range (N + 1), (Î¼ (f n âˆ† g n)).toReal := by\n                          rw [â† toReal_sum (fun _ _ â†¦ measure_ne_top _ _)]\n                          exact toReal_mono (ne_of_lt <| sum_lt_top.2 fun _ _ â†¦ measure_lt_top Î¼ _)\n                            (measure_biUnion_finset_le _ _)\n                    _ < âˆ‘ n âˆˆ Finset.range (N + 1), (Îµ / (2 * (N + 1))) :=\n                          Finset.sum_lt_sum (fun i _ â†¦ le_of_lt (hg i)) âŸ¨0, by simp, hg 0âŸ©\n                    _ â‰¤ Îµ / 2 := by\n                          simp only [Finset.sum_const, Finset.card_range, nsmul_eq_mul,\n                            Nat.cast_add, Nat.cast_one]\n                          rw [div_mul_eq_div_mul_one_div, â† mul_assoc, mul_comm ((N : â„) + 1),\n                            mul_assoc]\n                          exact mul_le_of_le_one_right (by linarith [Îµ_pos]) <|\n                            le_of_eq <| mul_one_div_cancel <| Nat.cast_add_one_ne_zero _\n    rintro - Îµ Îµ_pos\n    rcases this.2 Îµ Îµ_pos with âŸ¨t, t_mem, hÎ¼stâŸ©\n    exact âŸ¨t, t_mem, (lt_ofReal_iff_toReal_lt (measure_ne_top _ _)).2 hÎ¼stâŸ©\n\n"}
{"name":"MeasureTheory.Measure.MeasureDense.of_generateFrom_isSetAlgebra_sigmaFinite","module":"Mathlib.MeasureTheory.Measure.SeparableMeasure","initialProofState":"X : Type u_1\nm : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\nğ’œ : Set (Set X)\nhğ’œ : MeasureTheory.IsSetAlgebra ğ’œ\nS : Î¼.FiniteSpanningSetsIn ğ’œ\nhgen : Eq m (MeasurableSpace.generateFrom ğ’œ)\nâŠ¢ Î¼.MeasureDense ğ’œ","decl":"/-- If a measure space `X` is generated by an algebra of sets which contains a monotone countable\nfamily of sets with finite measure spanning `X` (thus the measure is `Ïƒ`-finite), then this algebra\nof sets is measure-dense. -/\ntheorem Measure.MeasureDense.of_generateFrom_isSetAlgebra_sigmaFinite (hğ’œ : IsSetAlgebra ğ’œ)\n    (S : Î¼.FiniteSpanningSetsIn ğ’œ) (hgen : m = MeasurableSpace.generateFrom ğ’œ) :\n    Î¼.MeasureDense ğ’œ where\n  measurable s hs := hgen â–¸ measurableSet_generateFrom hs\n  approx s ms hÎ¼s Îµ Îµ_pos := by\n    -- We use partial unions of (Sâ‚™) to get a monotone family spanning `X`.\n    let T := Accumulate S.set\n    have T_mem (n) : T n âˆˆ ğ’œ := by\n      simpa using hğ’œ.biUnion_mem {k | k â‰¤ n}.toFinset (fun k _ â†¦ S.set_mem k)\n    have T_finite (n) : Î¼ (T n) < âˆ := by\n      simpa using measure_biUnion_lt_top {k | k â‰¤ n}.toFinset.finite_toSet\n        (fun k _ â†¦ S.finite k)\n    have T_spanning : â‹ƒ n, T n = univ := S.spanning â–¸ iUnion_accumulate\n    -- We use the fact that we already know this is true for finite measures. As `â‹ƒ n, T n = X`,\n    -- we have that `Î¼ ((T n) âˆ© s) âŸ¶ Î¼ s`.\n    have mono : Monotone (fun n â†¦ (T n) âˆ© s) := fun m n hmn â†¦ inter_subset_inter_left s\n        (biUnion_subset_biUnion_left fun k hkm â†¦ Nat.le_trans hkm hmn)\n    have := tendsto_measure_iUnion_atTop (Î¼ := Î¼) mono\n    rw [â† tendsto_toReal_iff] at this\n    Â· -- We can therefore choose `N` such that `Î¼ s - Î¼ ((S N) âˆ© s) < Îµ/2`.\n      rcases Metric.tendsto_atTop.1 this (Îµ / 2) (by linarith [Îµ_pos]) with âŸ¨N, hNâŸ©\n      have : Fact (Î¼ (T N) < âˆ) := Fact.mk <| T_finite N\n      -- Then we can apply the previous result to the measure `Î¼ ((S N) âˆ© â€¢)`.\n      -- There exists `t âˆˆ ğ’œ` such that `Î¼ ((S N) âˆ© (s âˆ† t)) < Îµ/2`.\n      rcases (Measure.MeasureDense.of_generateFrom_isSetAlgebra_finite\n        (Î¼ := Î¼.restrict (T N)) hğ’œ hgen).approx s ms\n        (ne_of_lt (lt_of_le_of_lt (Î¼.restrict_apply_le _ s) hÎ¼s.lt_top))\n        (Îµ / 2) (by linarith [Îµ_pos])\n        with âŸ¨t, t_mem, htâŸ©\n      -- We can then use `t âˆ© (S N)`, because `S N âˆˆ ğ’œ` by hypothesis.\n      -- `Î¼ (s âˆ† (t âˆ© S N))`\n      --   `â‰¤ Î¼ (s âˆ† (s âˆ© S N)) + Î¼ ((s âˆ© S N) âˆ† (t âˆ© S N))`\n      --   `= Î¼ s - Î¼ (s âˆ© S N) + Î¼ (s âˆ† t) âˆ© S N) < Îµ`.\n      refine âŸ¨t âˆ© T N, hğ’œ.inter_mem t_mem (T_mem N), ?_âŸ©\n      calc\n        Î¼ (s âˆ† (t âˆ© T N))\n          â‰¤ Î¼ (s \\ (s âˆ© T N)) + Î¼ ((s âˆ† t) âˆ© T N) := by\n              rw [â† symmDiff_of_le (inter_subset_left ..), symmDiff_comm _ s,\n                inter_symmDiff_distrib_right]\n              exact measure_symmDiff_le _ _ _\n        _ < ENNReal.ofReal (Îµ / 2) + ENNReal.ofReal (Îµ / 2) := by\n              apply ENNReal.add_lt_add\n              Â· rw [measure_diff\n                    (inter_subset_left ..)\n                    (ms.inter (hgen â–¸ measurableSet_generateFrom (T_mem N))).nullMeasurableSet\n                    (ne_top_of_le_ne_top hÎ¼s (measure_mono (inter_subset_left ..))),\n                  lt_ofReal_iff_toReal_lt (sub_ne_top hÎ¼s),\n                  toReal_sub_of_le (measure_mono (inter_subset_left ..)) hÎ¼s]\n                apply lt_of_le_of_lt (sub_le_dist ..)\n                nth_rw 1 [â† univ_inter s]\n                rw [inter_comm s, dist_comm, â† T_spanning, iUnion_inter _ T]\n                apply hN N (le_refl _)\n              Â· rwa [â† Î¼.restrict_apply' (hgen â–¸ measurableSet_generateFrom (T_mem N))]\n        _ = ENNReal.ofReal Îµ := by\n              rw [â† ofReal_add (by linarith [Îµ_pos]) (by linarith [Îµ_pos]), add_halves]\n    Â· exact fun n â†¦ ne_top_of_le_ne_top hÎ¼s (measure_mono (inter_subset_right ..))\n    Â· exact ne_top_of_le_ne_top hÎ¼s\n        (measure_mono (iUnion_subset (fun i â†¦ inter_subset_right ..)))\n\n"}
{"name":"MeasureTheory.IsSeparable.exists_countable_measureDense","module":"Mathlib.MeasureTheory.Measure.SeparableMeasure","initialProofState":"X : Type u_1\nm : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\nself : MeasureTheory.IsSeparable Î¼\nâŠ¢ Exists fun ğ’œ => And ğ’œ.Countable (Î¼.MeasureDense ğ’œ)","decl":"/-- A measure `Î¼` is separable if there exists a countable and measure-dense family of sets.\n\nThe term \"separable\" is justified by the fact that the definition translates to the usual notion\nof separability in the metric space made by constant indicators equipped with the `Láµ–` norm. -/\nclass IsSeparable (Î¼ : Measure X) : Prop where\n  exists_countable_measureDense : âˆƒ ğ’œ, ğ’œ.Countable âˆ§ Î¼.MeasureDense ğ’œ\n\n"}
{"name":"MeasureTheory.exists_countable_measureDense","module":"Mathlib.MeasureTheory.Measure.SeparableMeasure","initialProofState":"X : Type u_1\nm : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\ninstâœ : MeasureTheory.IsSeparable Î¼\nâŠ¢ Exists fun ğ’œ => And ğ’œ.Countable (Î¼.MeasureDense ğ’œ)","decl":"/-- By definition, a separable measure admits a countable and measure-dense family of sets. -/\ntheorem exists_countable_measureDense [IsSeparable Î¼] :\n    âˆƒ ğ’œ, ğ’œ.Countable âˆ§ Î¼.MeasureDense ğ’œ :=\n  IsSeparable.exists_countable_measureDense\n\n"}
{"name":"MeasureTheory.isSeparable_of_sigmaFinite","module":"Mathlib.MeasureTheory.Measure.SeparableMeasure","initialProofState":"X : Type u_1\nm : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\ninstâœÂ¹ : MeasurableSpace.CountablyGenerated X\ninstâœ : MeasureTheory.SigmaFinite Î¼\nâŠ¢ MeasureTheory.IsSeparable Î¼","decl":"/-- If a measurable space is countably generated and equipped with a `Ïƒ`-finite measure, then the\nmeasure is separable. This is not an instance because it is used below to prove the more\ngeneral case where `Î¼` is s-finite. -/\ntheorem isSeparable_of_sigmaFinite [CountablyGenerated X] [SigmaFinite Î¼] :\n    IsSeparable Î¼ where\n  exists_countable_measureDense := by\n    have h := countable_countableGeneratingSet (Î± := X)\n    have hgen := generateFrom_countableGeneratingSet (Î± := X)\n    let ğ’œ := (countableGeneratingSet X) âˆª {Î¼.toFiniteSpanningSetsIn.set n | n : â„•}\n    have count_ğ’œ : ğ’œ.Countable :=\n      countable_union.2 âŸ¨h, countable_iff_exists_subset_range.2\n        âŸ¨Î¼.toFiniteSpanningSetsIn.set, fun _ hx â†¦ hxâŸ©âŸ©\n    refine âŸ¨generateSetAlgebra ğ’œ, countable_generateSetAlgebra count_ğ’œ,\n      Measure.MeasureDense.of_generateFrom_isSetAlgebra_sigmaFinite isSetAlgebra_generateSetAlgebra\n      { set := Î¼.toFiniteSpanningSetsIn.set\n        set_mem := fun n â†¦ self_subset_generateSetAlgebra (ğ’œ := ğ’œ) <| Or.inr âŸ¨n, rflâŸ©\n        finite := Î¼.toFiniteSpanningSetsIn.finite\n        spanning := Î¼.toFiniteSpanningSetsIn.spanning }\n      (le_antisymm ?_ (generateFrom_le (fun s hs â†¦ ?_)))âŸ©\n    Â· rw [â† hgen]\n      exact generateFrom_mono <| le_trans self_subset_generateSetAlgebra <|\n        generateSetAlgebra_mono <| subset_union_left ..\n    Â· induction hs with\n      | base t t_mem =>\n        rcases t_mem with t_mem | âŸ¨n, rflâŸ©\n        Â· exact hgen â–¸ measurableSet_generateFrom t_mem\n        Â· exact Î¼.toFiniteSpanningSetsIn.set_mem n\n      | empty => exact MeasurableSet.empty\n      | compl t _ t_mem => exact MeasurableSet.compl t_mem\n      | union t u _ _ t_mem u_mem => exact MeasurableSet.union t_mem u_mem\n\n"}
{"name":"MeasureTheory.instIsSeparableOfCountablyGeneratedOfSFinite","module":"Mathlib.MeasureTheory.Measure.SeparableMeasure","initialProofState":"X : Type u_1\nm : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\ninstâœÂ¹ : MeasurableSpace.CountablyGenerated X\ninstâœ : MeasureTheory.SFinite Î¼\nâŠ¢ MeasureTheory.IsSeparable Î¼","decl":"/-- If a measurable space is countably generated and equipped with an s-finite measure, then the\nmeasure is separable. -/\ninstance [CountablyGenerated X] [SFinite Î¼] : IsSeparable Î¼ where\n  exists_countable_measureDense := by\n    have := isSeparable_of_sigmaFinite (Î¼ := Î¼.restrict Î¼.sigmaFiniteSet)\n    rcases exists_countable_measureDense (Î¼ := Î¼.restrict Î¼.sigmaFiniteSet) with âŸ¨ğ’œ, count_ğ’œ, hğ’œâŸ©\n    let â„¬ := {s âˆ© Î¼.sigmaFiniteSet | s âˆˆ ğ’œ}\n    refine âŸ¨â„¬, count_ğ’œ.image (fun s â†¦ s âˆ© Î¼.sigmaFiniteSet), ?_, ?_âŸ©\n    Â· rintro - âŸ¨s, s_mem, rflâŸ©\n      exact (hğ’œ.measurable s s_mem).inter measurableSet_sigmaFiniteSet\n    Â· intro s ms hÎ¼s Îµ Îµ_pos\n      rcases restrict_compl_sigmaFiniteSet_eq_zero_or_top Î¼ s with hs | hs\n      Â· have : (Î¼.restrict Î¼.sigmaFiniteSet) s â‰  âˆ :=\n          ne_top_of_le_ne_top hÎ¼s <| Î¼.restrict_le_self _\n        rcases hğ’œ.approx s ms this Îµ Îµ_pos with âŸ¨t, t_mem, htâŸ©\n        refine âŸ¨t âˆ© Î¼.sigmaFiniteSet, âŸ¨t, t_mem, rflâŸ©, ?_âŸ©\n        have : Î¼ (s âˆ† (t âˆ© Î¼.sigmaFiniteSet) \\ Î¼.sigmaFiniteSet) = 0 := by\n          rw [diff_eq_compl_inter, inter_symmDiff_distrib_left, â† ENNReal.bot_eq_zero, eq_bot_iff]\n          calc\n            Î¼ ((Î¼.sigmaFiniteSetá¶œ âˆ© s) âˆ† (Î¼.sigmaFiniteSetá¶œ âˆ© (t âˆ© Î¼.sigmaFiniteSet)))\n              â‰¤ Î¼ ((Î¼.sigmaFiniteSetá¶œ âˆ© s) âˆª (Î¼.sigmaFiniteSetá¶œ âˆ© (t âˆ© Î¼.sigmaFiniteSet))) :=\n                measure_mono symmDiff_subset_union\n            _ â‰¤ Î¼ (Î¼.sigmaFiniteSetá¶œ âˆ© s) + Î¼ (Î¼.sigmaFiniteSetá¶œ âˆ© (t âˆ© Î¼.sigmaFiniteSet)) :=\n                measure_union_le _ _\n            _ = 0 := by\n                rw [inter_comm, â† Î¼.restrict_apply ms, hs, â† inter_assoc, inter_comm,\n                  â† inter_assoc, inter_compl_self, empty_inter, measure_empty, zero_add]\n        rwa [â† measure_inter_add_diff _ measurableSet_sigmaFiniteSet, this, add_zero,\n          inter_symmDiff_distrib_right, inter_assoc, inter_self, â† inter_symmDiff_distrib_right,\n          â† Î¼.restrict_apply' measurableSet_sigmaFiniteSet]\n      Â· refine False.elim <| hÎ¼s ?_\n        rw [eq_top_iff, â† hs]\n        exact Î¼.restrict_le_self _\n\n"}
{"name":"MeasureTheory.Lp.SecondCountableTopology","module":"Mathlib.MeasureTheory.Measure.SeparableMeasure","initialProofState":"X : Type u_1\nE : Type u_2\nm : MeasurableSpace X\ninstâœÂ² : NormedAddCommGroup E\nÎ¼ : MeasureTheory.Measure X\np : ENNReal\none_le_p : Fact (LE.le 1 p)\ninstâœÂ¹ : MeasureTheory.IsSeparable Î¼\ninstâœ : TopologicalSpace.SeparableSpace E\nâŠ¢ SecondCountableTopology (Subtype fun x => Membership.mem (MeasureTheory.Lp E p Î¼) x)","decl":"/-- If the measure `Î¼` is separable (in particular if `X` is countably generated and `Î¼` is\n`s`-finite), if `E` is a second-countable `NormedAddCommGroup`, and if `1 â‰¤ p < +âˆ`,\nthen the associated `Láµ–` space is second-countable. -/\ninstance Lp.SecondCountableTopology [IsSeparable Î¼] [TopologicalSpace.SeparableSpace E] :\n    SecondCountableTopology (Lp E p Î¼) := by\n  -- It is enough to show that the space is separable, i.e. admits a countable and dense susbet.\n  refine @UniformSpace.secondCountable_of_separable _ _ _ ?_\n  -- There exists a countable and measure-dense family, and we can keep only the sets with finite\n  -- measure while preserving the two properties. This family is denoted `ğ’œâ‚€`.\n  rcases exists_countable_measureDense (Î¼ := Î¼) with âŸ¨ğ’œ, count_ğ’œ, hğ’œâŸ©\n  have hğ’œâ‚€ := Measure.MeasureDense.fin_meas hğ’œ\n  set ğ’œâ‚€ := {s | s âˆˆ ğ’œ âˆ§ Î¼ s â‰  âˆ}\n  have count_ğ’œâ‚€ : ğ’œâ‚€.Countable := count_ğ’œ.mono fun _ âŸ¨h, _âŸ© â†¦ h\n  -- `1 â‰¤ p` so `p â‰  0`, we prove it now as it is often needed.\n  have p_ne_zero : p â‰  0 := ne_of_gt <| lt_of_lt_of_le (by norm_num) one_le_p.elim\n  -- `E` is second-countable, therefore separable and admits a countable and dense subset `u`.\n  rcases exists_countable_dense E with âŸ¨u, countable_u, dense_uâŸ©\n  -- The countable and dense subset of `Láµ–` we are going to build is the set of finite sums of\n  -- constant indicators with support in `ğ’œâ‚€`, and is denoted `D`. To make manipulations easier,\n  -- we define the function `key` which given an integer `n` and two families of `n` elements\n  -- in `u` and `ğ’œâ‚€` associates the corresponding sum.\n  let key (n : â„•) (d : Fin n â†’ u) (s : Fin n â†’ ğ’œâ‚€) : (Lp E p Î¼) :=\n    âˆ‘ i, indicatorConstLp p (hğ’œâ‚€.measurable (s i) (Subtype.mem (s i))) (s i).2.2 (d i : E)\n  let D := {s : Lp E p Î¼ | âˆƒ n d t, s = key n d t}\n  refine âŸ¨D, ?_, ?_âŸ©\n  Â· -- Countability directly follows from countability of `u` and `ğ’œâ‚€`. The function `f` below\n    -- is the uncurryfied version of `key`, which is easier to manipulate as countability of the\n    -- domain is automatically inferred.\n    let f (nds : Î£ n : â„•, (Fin n â†’ u) Ã— (Fin n â†’ ğ’œâ‚€)) : Lp E p Î¼ := key nds.1 nds.2.1 nds.2.2\n    have := count_ğ’œâ‚€.to_subtype\n    have := countable_u.to_subtype\n    have : D âŠ† range f := by\n      rintro - âŸ¨n, d, s, rflâŸ©\n      use âŸ¨n, (d, s)âŸ©\n    exact (countable_range f).mono this\n  Â· -- Let's turn to the density. Thanks to the density of simple functions in `Láµ–`, it is enough\n    -- to show that the closure of `D` contains constant indicators which are in `Láµ–` (i. e. the\n    -- set has finite measure), is closed by sum and closed.\n    -- This is given by `Lp.induction`.\n    refine Lp.induction p_ne_top.elim (P := fun f â†¦ f âˆˆ closure D) ?_ ?_ isClosed_closure\n    Â· intro a s ms hÎ¼s\n      -- We want to approximate `a â€¢ ğŸ™â‚›`.\n      apply ne_of_lt at hÎ¼s\n      rw [SeminormedAddCommGroup.mem_closure_iff]\n      intro Îµ Îµ_pos\n      have Î¼s_pow_nonneg : 0 â‰¤ (Î¼ s).toReal ^ (1 / p.toReal) :=\n        Real.rpow_nonneg ENNReal.toReal_nonneg _\n      -- To do so, we first pick `b âˆˆ u` such that `â€–a - bâ€– < Îµ / (3 * (1 + (Î¼ s)^(1/p)))`.\n      have approx_a_pos : 0 < Îµ / (3 * (1 + (Î¼ s).toReal ^ (1 / p.toReal))) :=\n        div_pos Îµ_pos (by linarith [Î¼s_pow_nonneg])\n      have âŸ¨b, b_mem, hbâŸ© := SeminormedAddCommGroup.mem_closure_iff.1 (dense_u a) _ approx_a_pos\n      -- Then we pick `t âˆˆ ğ’œâ‚€` such that `â€–b â€¢ ğŸ™â‚› - b â€¢ ğŸ™â‚œâ€– < Îµ / 3`.\n      rcases SeminormedAddCommGroup.mem_closure_iff.1\n        (hğ’œâ‚€.indicatorConstLp_subset_closure p b âŸ¨s, ms, hÎ¼s, rflâŸ©)\n          (Îµ / 3) (by linarith [Îµ_pos]) with âŸ¨-, âŸ¨t, ht, hÎ¼t, rflâŸ©, hstâŸ©\n      have mt := hğ’œâ‚€.measurable t ht\n      -- We now show that `â€–a â€¢ ğŸ™â‚› - b â€¢ ğŸ™â‚œâ€–â‚š < Îµ`, as follows:\n      -- `â€–a â€¢ ğŸ™â‚› - b â€¢ ğŸ™â‚œâ€–â‚š`\n      --   `= â€–a â€¢ ğŸ™â‚› - b â€¢ ğŸ™â‚› + b â€¢ ğŸ™â‚› - b â€¢ ğŸ™â‚œâ€–â‚š`\n      --   `â‰¤ â€–a - bâ€– * â€–ğŸ™â‚›â€–â‚š + Îµ / 3`\n      --   `= â€–a - bâ€– * (Î¼ s)^(1/p) + Îµ / 3`\n      --   `< Îµ * (Î¼ s)^(1/p) / (3 * (1 + (Î¼ s)^(1/p))) + Îµ / 3`\n      --   `â‰¤ Îµ / 3 + Îµ / 3 < Îµ`.\n      refine âŸ¨indicatorConstLp p mt hÎ¼t b,\n        âŸ¨1, fun _ â†¦ âŸ¨b, b_memâŸ©, fun _ â†¦ âŸ¨t, htâŸ©, by simp [key]âŸ©, ?_âŸ©\n      rw [Lp.simpleFunc.coe_indicatorConst,\n        â† sub_add_sub_cancel _ (indicatorConstLp p ms hÎ¼s b), â† add_halves Îµ]\n      refine lt_of_le_of_lt (b := Îµ / 3 + Îµ / 3) (norm_add_le_of_le ?_ hst.le) (by linarith [Îµ_pos])\n      rw [indicatorConstLp_sub, norm_indicatorConstLp p_ne_zero p_ne_top.elim]\n      calc\n        â€–a - bâ€– * (Î¼ s).toReal ^ (1 / p.toReal)\n          â‰¤ (Îµ / (3 * (1 + (Î¼ s).toReal ^ (1 / p.toReal)))) * (Î¼ s).toReal ^ (1 / p.toReal) :=\n              mul_le_mul_of_nonneg_right (le_of_lt hb) Î¼s_pow_nonneg\n        _ â‰¤ Îµ / 3 := by\n            rw [â† mul_one (Îµ / 3), div_mul_eq_div_mul_one_div, mul_assoc, one_div_mul_eq_div]\n            exact mul_le_mul_of_nonneg_left\n              ((div_le_one (by linarith [Î¼s_pow_nonneg])).2 (by linarith))\n              (by linarith [Îµ_pos])\n    Â· -- Now we have to show that the closure of `D` is closed by sum. Let `f` and `g` be two\n      -- functions in `Láµ–` which are also in the closure of `D`.\n      rintro f g hf hg - f_mem g_mem\n      rw [SeminormedAddCommGroup.mem_closure_iff] at *\n      intro Îµ Îµ_pos\n      -- For `Îµ > 0`, there exists `bf, bg âˆˆ D` such that `â€–f - bfâ€–â‚š < Îµ/2` and `â€–g - bgâ€–â‚š < Îµ/2`.\n      rcases f_mem (Îµ / 2) (by linarith [Îµ_pos]) with âŸ¨bf, âŸ¨nf, df, sf, bf_eqâŸ©, hbfâŸ©\n      rcases g_mem (Îµ / 2) (by linarith [Îµ_pos]) with âŸ¨bg, âŸ¨ng, dg, sg, bg_eqâŸ©, hbgâŸ©\n      -- It is obvious that `D` is closed by sum, it suffices to concatenate the family of\n      -- elements of `u` and the family of elements of `ğ’œâ‚€`.\n      let d := fun i : Fin (nf + ng) â†¦ if h : i < nf\n        then df (Fin.castLT i h)\n        else dg (Fin.subNat nf (Fin.cast (Nat.add_comm ..) i) (le_of_not_gt h))\n      let s := fun i : Fin (nf + ng) â†¦ if h : i < nf\n        then sf (Fin.castLT i h)\n        else sg (Fin.subNat nf (Fin.cast (Nat.add_comm ..) i) (le_of_not_gt h))\n      -- So we can use `bf + bg`.\n      refine âŸ¨bf + bg, âŸ¨nf + ng, d, s, ?_âŸ©, ?_âŸ©\n      Â· simp [key, d, s, Fin.sum_univ_add, bf_eq, bg_eq]\n      Â· -- We have\n        -- `â€–f + g - (bf + bg)â€–â‚š`\n        --   `â‰¤ â€–f - bfâ€–â‚š + â€–g - bgâ€–â‚š`\n        --   `< Îµ/2 + Îµ/2 = Îµ`.\n        calc\n          â€–Memâ„’p.toLp f hf + Memâ„’p.toLp g hg - (bf + bg)â€–\n            = â€–(Memâ„’p.toLp f hf) - bf + ((Memâ„’p.toLp g hg) - bg)â€– := by congr; abel\n          _ â‰¤ â€–(Memâ„’p.toLp f hf) - bfâ€– + â€–(Memâ„’p.toLp g hg) - bgâ€– := norm_add_le ..\n          _ < Îµ := by linarith [hbf, hbg]\n\n"}
