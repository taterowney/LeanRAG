{"name":"MeasureTheory.Measure.MeasureDense.approx","module":"Mathlib.MeasureTheory.Measure.SeparableMeasure","initialProofState":"X : Type u_1\nm : MeasurableSpace X\nμ : MeasureTheory.Measure X\n𝒜 : Set (Set X)\nself : μ.MeasureDense 𝒜\ns : Set X\na✝² : MeasurableSet s\na✝¹ : Ne (μ s) Top.top\nε : Real\na✝ : LT.lt 0 ε\n⊢ Exists fun t => And (Membership.mem 𝒜 t) (LT.lt (μ (symmDiff s t)) (ENNReal.ofReal ε))","decl":"/-- A family `𝒜` of sets of a measure space is said to be measure-dense if it contains only\nmeasurable sets and can approximate any measurable set with finite measure, in the sense that\nfor any measurable set `s` with finite measure the symmetric difference `s ∆ t` can be made\narbitrarily small when `t ∈ 𝒜`. We show below that such a family can be chosen to contain only\nsets with finite measures.\n\nThe term \"measure-dense\" is justified by the fact that the approximating condition translates\nto the usual notion of density in the metric space made by constant indicators of measurable sets\nequipped with the `Lᵖ` norm. -/\nstructure Measure.MeasureDense (μ : Measure X) (𝒜 : Set (Set X)) : Prop where\n  /-- Each set has to be measurable. -/\n  measurable : ∀ s ∈ 𝒜, MeasurableSet s\n  /-- Any measurable set can be approximated by sets in the family. -/\n  approx : ∀ s, MeasurableSet s → μ s ≠ ∞ → ∀ ε : ℝ, 0 < ε → ∃ t ∈ 𝒜, μ (s ∆ t) < ENNReal.ofReal ε\n\n"}
{"name":"MeasureTheory.Measure.MeasureDense.measurable","module":"Mathlib.MeasureTheory.Measure.SeparableMeasure","initialProofState":"X : Type u_1\nm : MeasurableSpace X\nμ : MeasureTheory.Measure X\n𝒜 : Set (Set X)\nself : μ.MeasureDense 𝒜\ns : Set X\na✝ : Membership.mem 𝒜 s\n⊢ MeasurableSet s","decl":"/-- A family `𝒜` of sets of a measure space is said to be measure-dense if it contains only\nmeasurable sets and can approximate any measurable set with finite measure, in the sense that\nfor any measurable set `s` with finite measure the symmetric difference `s ∆ t` can be made\narbitrarily small when `t ∈ 𝒜`. We show below that such a family can be chosen to contain only\nsets with finite measures.\n\nThe term \"measure-dense\" is justified by the fact that the approximating condition translates\nto the usual notion of density in the metric space made by constant indicators of measurable sets\nequipped with the `Lᵖ` norm. -/\nstructure Measure.MeasureDense (μ : Measure X) (𝒜 : Set (Set X)) : Prop where\n  /-- Each set has to be measurable. -/\n  measurable : ∀ s ∈ 𝒜, MeasurableSet s\n  /-- Any measurable set can be approximated by sets in the family. -/\n  approx : ∀ s, MeasurableSet s → μ s ≠ ∞ → ∀ ε : ℝ, 0 < ε → ∃ t ∈ 𝒜, μ (s ∆ t) < ENNReal.ofReal ε\n\n"}
{"name":"MeasureTheory.Measure.MeasureDense.nonempty","module":"Mathlib.MeasureTheory.Measure.SeparableMeasure","initialProofState":"X : Type u_1\nm : MeasurableSpace X\nμ : MeasureTheory.Measure X\n𝒜 : Set (Set X)\nh𝒜 : μ.MeasureDense 𝒜\n⊢ 𝒜.Nonempty","decl":"theorem Measure.MeasureDense.nonempty (h𝒜 : μ.MeasureDense 𝒜) : 𝒜.Nonempty := by\n  rcases h𝒜.approx ∅ MeasurableSet.empty (by simp) 1 (by norm_num) with ⟨t, ht, -⟩\n  exact ⟨t, ht⟩\n\n"}
{"name":"MeasureTheory.Measure.MeasureDense.nonempty'","module":"Mathlib.MeasureTheory.Measure.SeparableMeasure","initialProofState":"X : Type u_1\nm : MeasurableSpace X\nμ : MeasureTheory.Measure X\n𝒜 : Set (Set X)\nh𝒜 : μ.MeasureDense 𝒜\n⊢ (setOf fun s => And (Membership.mem 𝒜 s) (Ne (μ s) Top.top)).Nonempty","decl":"theorem Measure.MeasureDense.nonempty' (h𝒜 : μ.MeasureDense 𝒜) :\n    {s | s ∈ 𝒜 ∧ μ s ≠ ∞}.Nonempty := by\n  rcases h𝒜.approx ∅ MeasurableSet.empty (by simp) 1 (by norm_num) with ⟨t, ht, hμt⟩\n  refine ⟨t, ht, ?_⟩\n  convert ne_top_of_lt hμt\n  rw [← bot_eq_empty, bot_symmDiff]\n\n"}
{"name":"MeasureTheory.measureDense_measurableSet","module":"Mathlib.MeasureTheory.Measure.SeparableMeasure","initialProofState":"X : Type u_1\nm : MeasurableSpace X\nμ : MeasureTheory.Measure X\n⊢ μ.MeasureDense (setOf fun s => MeasurableSet s)","decl":"/-- The set of measurable sets is measure-dense. -/\ntheorem measureDense_measurableSet : μ.MeasureDense {s | MeasurableSet s} where\n  measurable _ h := h\n  approx s hs _ ε ε_pos := ⟨s, hs, by simpa⟩\n\n"}
{"name":"MeasureTheory.Measure.MeasureDense.fin_meas_approx","module":"Mathlib.MeasureTheory.Measure.SeparableMeasure","initialProofState":"X : Type u_1\nm : MeasurableSpace X\nμ : MeasureTheory.Measure X\n𝒜 : Set (Set X)\nh𝒜 : μ.MeasureDense 𝒜\ns : Set X\nms : MeasurableSet s\nhμs : Ne (μ s) Top.top\nε : Real\nε_pos : LT.lt 0 ε\n⊢ Exists fun t => And (Membership.mem 𝒜 t) (And (Ne (μ t) Top.top) (LT.lt (μ (symmDiff s t)) (ENNReal.ofReal ε)))","decl":"/-- If a family of sets `𝒜` is measure-dense in `X`, then any measurable set with finite measure\ncan be approximated by sets in `𝒜` with finite measure. -/\nlemma Measure.MeasureDense.fin_meas_approx (h𝒜 : μ.MeasureDense 𝒜) {s : Set X}\n    (ms : MeasurableSet s) (hμs : μ s ≠ ∞) (ε : ℝ) (ε_pos : 0 < ε) :\n    ∃ t ∈ 𝒜, μ t ≠ ∞ ∧ μ (s ∆ t) < ENNReal.ofReal ε := by\n  rcases h𝒜.approx s ms hμs ε ε_pos with ⟨t, t_mem, ht⟩\n  exact ⟨t, t_mem, (measure_ne_top_iff_of_symmDiff <| ne_top_of_lt ht).1 hμs, ht⟩\n\n"}
{"name":"MeasureTheory.Measure.MeasureDense.indicatorConstLp_subset_closure","module":"Mathlib.MeasureTheory.Measure.SeparableMeasure","initialProofState":"X : Type u_1\nE : Type u_2\nm : MeasurableSpace X\ninst✝ : NormedAddCommGroup E\nμ : MeasureTheory.Measure X\np : ENNReal\none_le_p : Fact (LE.le 1 p)\np_ne_top : Fact (Ne p Top.top)\n𝒜 : Set (Set X)\nh𝒜 : μ.MeasureDense 𝒜\nc : E\n⊢ HasSubset.Subset (setOf fun x => Exists fun s => Exists fun hs => Exists fun hμs => Eq (MeasureTheory.indicatorConstLp p hs hμs c) x) (closure (setOf fun x => Exists fun s => Exists fun hs => Exists fun hμs => Eq (MeasureTheory.indicatorConstLp p ⋯ hμs c) x))","decl":"variable (p) in\n/-- If `𝒜` is a measure-dense family of sets and `c : E`, then the set of constant indicators\nwith constant `c` whose underlying set is in `𝒜` is dense in the set of constant indicators\nwhich are in `Lp E p μ` when `1 ≤ p < ∞`. -/\ntheorem Measure.MeasureDense.indicatorConstLp_subset_closure (h𝒜 : μ.MeasureDense 𝒜) (c : E) :\n    {indicatorConstLp p hs hμs c | (s : Set X) (hs : MeasurableSet s) (hμs : μ s ≠ ∞)} ⊆\n    closure {indicatorConstLp p (h𝒜.measurable s hs) hμs c |\n      (s : Set X) (hs : s ∈ 𝒜) (hμs : μ s ≠ ∞)} := by\n  obtain rfl | hc := eq_or_ne c 0\n  · refine Subset.trans ?_ subset_closure\n    rintro - ⟨s, ms, hμs, rfl⟩\n    obtain ⟨t, ht, hμt⟩ := h𝒜.nonempty'\n    refine ⟨t, ht, hμt, ?_⟩\n    simp_rw [indicatorConstLp]\n    congr\n    simp\n  · have p_pos : 0 < p := lt_of_lt_of_le (by norm_num) one_le_p.elim\n    rintro - ⟨s, ms, hμs, rfl⟩\n    refine Metric.mem_closure_iff.2 fun ε hε ↦ ?_\n    have aux : 0 < (ε / ‖c‖) ^ p.toReal := rpow_pos_of_pos (div_pos hε (norm_pos_iff.2 hc)) _\n    obtain ⟨t, ht, hμt, hμst⟩ := h𝒜.fin_meas_approx ms hμs ((ε / ‖c‖) ^ p.toReal) aux\n    refine ⟨indicatorConstLp p (h𝒜.measurable t ht) hμt c,\n      ⟨t, ht, hμt, rfl⟩, ?_⟩\n    rw [dist_indicatorConstLp_eq_norm, norm_indicatorConstLp p_pos.ne.symm p_ne_top.elim]\n    calc\n      ‖c‖ * (μ (s ∆ t)).toReal ^ (1 / p.toReal)\n        < ‖c‖ * (ENNReal.ofReal ((ε / ‖c‖) ^ p.toReal)).toReal ^ (1 / p.toReal) := by\n          rw [_root_.mul_lt_mul_left (norm_pos_iff.2 hc)]\n          refine Real.rpow_lt_rpow (by simp) ?_\n            (one_div_pos.2 <| toReal_pos p_pos.ne.symm p_ne_top.elim)\n          rwa [toReal_lt_toReal (measure_symmDiff_ne_top hμs hμt) ofReal_ne_top]\n      _ = ε := by\n        rw [toReal_ofReal (rpow_nonneg (div_nonneg hε.le (norm_nonneg _)) _),\n          one_div, Real.rpow_rpow_inv (div_nonneg hε.le (norm_nonneg _))\n            (toReal_pos p_pos.ne.symm p_ne_top.elim).ne.symm,\n          mul_div_cancel₀ _ (norm_ne_zero_iff.2 hc)]\n\n"}
{"name":"MeasureTheory.Measure.MeasureDense.fin_meas","module":"Mathlib.MeasureTheory.Measure.SeparableMeasure","initialProofState":"X : Type u_1\nm : MeasurableSpace X\nμ : MeasureTheory.Measure X\n𝒜 : Set (Set X)\nh𝒜 : μ.MeasureDense 𝒜\n⊢ μ.MeasureDense (setOf fun s => And (Membership.mem 𝒜 s) (Ne (μ s) Top.top))","decl":"/-- If a family of sets `𝒜` is measure-dense in `X`, then it is also the case for the sets in `𝒜`\nwith finite measure. -/\ntheorem Measure.MeasureDense.fin_meas (h𝒜 : μ.MeasureDense 𝒜) :\n    μ.MeasureDense {s | s ∈ 𝒜 ∧ μ s ≠ ∞} where\n  measurable s h := h𝒜.measurable s h.1\n  approx s ms hμs ε ε_pos := by\n    rcases Measure.MeasureDense.fin_meas_approx h𝒜 ms hμs ε ε_pos with ⟨t, t_mem, hμt, hμst⟩\n    exact ⟨t, ⟨t_mem, hμt⟩, hμst⟩\n\n"}
{"name":"MeasureTheory.Measure.MeasureDense.of_generateFrom_isSetAlgebra_finite","module":"Mathlib.MeasureTheory.Measure.SeparableMeasure","initialProofState":"X : Type u_1\nm : MeasurableSpace X\nμ : MeasureTheory.Measure X\n𝒜 : Set (Set X)\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nh𝒜 : MeasureTheory.IsSetAlgebra 𝒜\nhgen : Eq m (MeasurableSpace.generateFrom 𝒜)\n⊢ μ.MeasureDense 𝒜","decl":"/-- If a measurable space equipped with a finite measure is generated by an algebra of sets, then\nthis algebra of sets is measure-dense. -/\ntheorem Measure.MeasureDense.of_generateFrom_isSetAlgebra_finite [IsFiniteMeasure μ]\n    (h𝒜 : IsSetAlgebra 𝒜) (hgen : m = MeasurableSpace.generateFrom 𝒜) : μ.MeasureDense 𝒜 where\n  measurable s hs := hgen ▸ measurableSet_generateFrom hs\n  approx s ms := by\n    -- We want to show that any measurable set can be approximated by sets in `𝒜`. To do so, it is\n    -- enough to show that such sets constitute a `σ`-algebra containing `𝒜`. This is contained in\n    -- the theorem `generateFrom_induction`.\n    have : MeasurableSet s ∧ ∀ (ε : ℝ), 0 < ε → ∃ t ∈ 𝒜, (μ (s ∆ t)).toReal < ε := by\n      induction s, hgen ▸ ms using generateFrom_induction with\n      -- If `t ∈ 𝒜`, then `μ (t ∆ t) = 0` which is less than any `ε > 0`.\n      | hC t t_mem _ =>\n        exact ⟨hgen ▸ measurableSet_generateFrom t_mem, fun ε ε_pos ↦ ⟨t, t_mem, by simpa⟩⟩\n      -- `∅ ∈ 𝒜` and `μ (∅ ∆ ∅) = 0` which is less than any `ε > 0`.\n      | empty => exact ⟨MeasurableSet.empty, fun ε ε_pos ↦ ⟨∅, h𝒜.empty_mem, by simpa⟩⟩\n      -- If `s` is measurable and `t ∈ 𝒜` such that `μ (s ∆ t) < ε`, then `tᶜ ∈ 𝒜` and\n      -- `μ (sᶜ ∆ tᶜ) = μ (s ∆ t) < ε` so `sᶜ` can be approximated.\n      | compl t _ ht =>\n        refine ⟨ht.1.compl, fun ε ε_pos ↦ ?_⟩\n        obtain ⟨u, u_mem, hμtcu⟩ := ht.2 ε ε_pos\n        exact ⟨uᶜ, h𝒜.compl_mem u_mem, by rwa [compl_symmDiff_compl]⟩\n      -- Let `(fₙ)` be a sequence of measurable sets and `ε > 0`.\n      | iUnion f _ hf =>\n        refine ⟨MeasurableSet.iUnion (fun n ↦ (hf n).1), fun ε ε_pos ↦ ?_⟩\n        -- We have  `μ (⋃ n ≤ N, fₙ) ⟶ μ (⋃ n, fₙ)`.\n        have := tendsto_measure_iUnion_accumulate (μ := μ) (f := f)\n        rw [← tendsto_toReal_iff (fun _ ↦ measure_ne_top _ _) (measure_ne_top _ _)] at this\n        -- So there exists `N` such that `μ (⋃ n, fₙ) - μ (⋃ n ≤ N, fₙ) < ε/2`.\n        rcases Metric.tendsto_atTop.1 this (ε / 2) (by linarith [ε_pos]) with ⟨N, hN⟩\n        -- For any `n ≤ N` there exists `gₙ ∈ 𝒜` such that `μ (fₙ ∆ gₙ) < ε/(2*(N+1))`.\n        choose g g_mem hg using fun n ↦ (hf n).2 (ε / (2 * (N + 1))) (div_pos ε_pos (by linarith))\n        -- Therefore we have\n        -- `μ ((⋃ n, fₙ) ∆ (⋃ n ≤ N, gₙ))`\n        --   `≤ μ ((⋃ n, fₙ) ∆ (⋃ n ≤ N, fₙ)) + μ ((⋃ n ≤ N, fₙ) ∆ (⋃ n ≤ N, gₙ))`\n        --   `< ε/2 + ∑ n ≤ N, μ (fₙ ∆ gₙ)` (see `biSup_symmDiff_biSup_le`)\n        --   `< ε/2 + (N+1)*ε/(2*(N+1)) = ε/2`.\n        refine ⟨⋃ n ∈ Finset.range (N + 1), g n, h𝒜.biUnion_mem _ (fun i _ ↦ g_mem i), ?_⟩\n        calc\n          (μ ((⋃ n, f n) ∆ (⋃ n ∈ (Finset.range (N + 1)), g n))).toReal\n            ≤ (μ ((⋃ n, f n) \\ ((⋃ n ∈ (Finset.range (N + 1)), f n)) ∪\n              ((⋃ n ∈ (Finset.range (N + 1)), f n) ∆\n              (⋃ n ∈ (Finset.range (N + 1)), g ↑n)))).toReal :=\n                toReal_mono (measure_ne_top _ _)\n                  (measure_mono <| symmDiff_of_ge (iUnion_subset <|\n                  fun i ↦ iUnion_subset (fun _ ↦ subset_iUnion f i)) ▸ symmDiff_triangle ..)\n          _ ≤ (μ ((⋃ n, f n) \\\n              ((⋃ n ∈ (Finset.range (N + 1)), f n)))).toReal +\n              (μ ((⋃ n ∈ (Finset.range (N + 1)), f n) ∆\n              (⋃ n ∈ (Finset.range (N + 1)), g ↑n))).toReal := by\n                rw [← toReal_add (measure_ne_top _ _) (measure_ne_top _ _)]\n                exact toReal_mono (add_ne_top.2 ⟨measure_ne_top _ _, measure_ne_top _ _⟩) <|\n                  measure_union_le _ _\n          _ < ε := by\n                rw [← add_halves ε]\n                apply _root_.add_lt_add\n                · rw [measure_diff (h_fin := measure_ne_top _ _),\n                    toReal_sub_of_le (ha := measure_ne_top _ _)]\n                  · apply lt_of_le_of_lt (sub_le_dist ..)\n                    simp only [Finset.mem_range, Nat.lt_add_one_iff]\n                    exact (dist_comm (α := ℝ) .. ▸ hN N (le_refl N))\n                  · exact measure_mono <| iUnion_subset <|\n                      fun i ↦ iUnion_subset fun _ ↦ subset_iUnion f i\n                  · exact iUnion_subset <| fun i ↦ iUnion_subset (fun _ ↦ subset_iUnion f i)\n                  · exact MeasurableSet.biUnion (countable_coe_iff.1 inferInstance)\n                      (fun n _ ↦ (hf n).1.nullMeasurableSet)\n                · calc\n                    (μ ((⋃ n ∈ (Finset.range (N + 1)), f n) ∆\n                    (⋃ n ∈ (Finset.range (N + 1)), g ↑n))).toReal\n                      ≤ (μ (⋃ n ∈ (Finset.range (N + 1)), f n ∆ g n)).toReal :=\n                          toReal_mono (measure_ne_top _ _) (measure_mono biSup_symmDiff_biSup_le)\n                    _ ≤ ∑ n ∈ Finset.range (N + 1), (μ (f n ∆ g n)).toReal := by\n                          rw [← toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n                          exact toReal_mono (ne_of_lt <| sum_lt_top.2 fun _ _ ↦ measure_lt_top μ _)\n                            (measure_biUnion_finset_le _ _)\n                    _ < ∑ n ∈ Finset.range (N + 1), (ε / (2 * (N + 1))) :=\n                          Finset.sum_lt_sum (fun i _ ↦ le_of_lt (hg i)) ⟨0, by simp, hg 0⟩\n                    _ ≤ ε / 2 := by\n                          simp only [Finset.sum_const, Finset.card_range, nsmul_eq_mul,\n                            Nat.cast_add, Nat.cast_one]\n                          rw [div_mul_eq_div_mul_one_div, ← mul_assoc, mul_comm ((N : ℝ) + 1),\n                            mul_assoc]\n                          exact mul_le_of_le_one_right (by linarith [ε_pos]) <|\n                            le_of_eq <| mul_one_div_cancel <| Nat.cast_add_one_ne_zero _\n    rintro - ε ε_pos\n    rcases this.2 ε ε_pos with ⟨t, t_mem, hμst⟩\n    exact ⟨t, t_mem, (lt_ofReal_iff_toReal_lt (measure_ne_top _ _)).2 hμst⟩\n\n"}
{"name":"MeasureTheory.Measure.MeasureDense.of_generateFrom_isSetAlgebra_sigmaFinite","module":"Mathlib.MeasureTheory.Measure.SeparableMeasure","initialProofState":"X : Type u_1\nm : MeasurableSpace X\nμ : MeasureTheory.Measure X\n𝒜 : Set (Set X)\nh𝒜 : MeasureTheory.IsSetAlgebra 𝒜\nS : μ.FiniteSpanningSetsIn 𝒜\nhgen : Eq m (MeasurableSpace.generateFrom 𝒜)\n⊢ μ.MeasureDense 𝒜","decl":"/-- If a measure space `X` is generated by an algebra of sets which contains a monotone countable\nfamily of sets with finite measure spanning `X` (thus the measure is `σ`-finite), then this algebra\nof sets is measure-dense. -/\ntheorem Measure.MeasureDense.of_generateFrom_isSetAlgebra_sigmaFinite (h𝒜 : IsSetAlgebra 𝒜)\n    (S : μ.FiniteSpanningSetsIn 𝒜) (hgen : m = MeasurableSpace.generateFrom 𝒜) :\n    μ.MeasureDense 𝒜 where\n  measurable s hs := hgen ▸ measurableSet_generateFrom hs\n  approx s ms hμs ε ε_pos := by\n    -- We use partial unions of (Sₙ) to get a monotone family spanning `X`.\n    let T := Accumulate S.set\n    have T_mem (n) : T n ∈ 𝒜 := by\n      simpa using h𝒜.biUnion_mem {k | k ≤ n}.toFinset (fun k _ ↦ S.set_mem k)\n    have T_finite (n) : μ (T n) < ∞ := by\n      simpa using measure_biUnion_lt_top {k | k ≤ n}.toFinset.finite_toSet\n        (fun k _ ↦ S.finite k)\n    have T_spanning : ⋃ n, T n = univ := S.spanning ▸ iUnion_accumulate\n    -- We use the fact that we already know this is true for finite measures. As `⋃ n, T n = X`,\n    -- we have that `μ ((T n) ∩ s) ⟶ μ s`.\n    have mono : Monotone (fun n ↦ (T n) ∩ s) := fun m n hmn ↦ inter_subset_inter_left s\n        (biUnion_subset_biUnion_left fun k hkm ↦ Nat.le_trans hkm hmn)\n    have := tendsto_measure_iUnion_atTop (μ := μ) mono\n    rw [← tendsto_toReal_iff] at this\n    · -- We can therefore choose `N` such that `μ s - μ ((S N) ∩ s) < ε/2`.\n      rcases Metric.tendsto_atTop.1 this (ε / 2) (by linarith [ε_pos]) with ⟨N, hN⟩\n      have : Fact (μ (T N) < ∞) := Fact.mk <| T_finite N\n      -- Then we can apply the previous result to the measure `μ ((S N) ∩ •)`.\n      -- There exists `t ∈ 𝒜` such that `μ ((S N) ∩ (s ∆ t)) < ε/2`.\n      rcases (Measure.MeasureDense.of_generateFrom_isSetAlgebra_finite\n        (μ := μ.restrict (T N)) h𝒜 hgen).approx s ms\n        (ne_of_lt (lt_of_le_of_lt (μ.restrict_apply_le _ s) hμs.lt_top))\n        (ε / 2) (by linarith [ε_pos])\n        with ⟨t, t_mem, ht⟩\n      -- We can then use `t ∩ (S N)`, because `S N ∈ 𝒜` by hypothesis.\n      -- `μ (s ∆ (t ∩ S N))`\n      --   `≤ μ (s ∆ (s ∩ S N)) + μ ((s ∩ S N) ∆ (t ∩ S N))`\n      --   `= μ s - μ (s ∩ S N) + μ (s ∆ t) ∩ S N) < ε`.\n      refine ⟨t ∩ T N, h𝒜.inter_mem t_mem (T_mem N), ?_⟩\n      calc\n        μ (s ∆ (t ∩ T N))\n          ≤ μ (s \\ (s ∩ T N)) + μ ((s ∆ t) ∩ T N) := by\n              rw [← symmDiff_of_le (inter_subset_left ..), symmDiff_comm _ s,\n                inter_symmDiff_distrib_right]\n              exact measure_symmDiff_le _ _ _\n        _ < ENNReal.ofReal (ε / 2) + ENNReal.ofReal (ε / 2) := by\n              apply ENNReal.add_lt_add\n              · rw [measure_diff\n                    (inter_subset_left ..)\n                    (ms.inter (hgen ▸ measurableSet_generateFrom (T_mem N))).nullMeasurableSet\n                    (ne_top_of_le_ne_top hμs (measure_mono (inter_subset_left ..))),\n                  lt_ofReal_iff_toReal_lt (sub_ne_top hμs),\n                  toReal_sub_of_le (measure_mono (inter_subset_left ..)) hμs]\n                apply lt_of_le_of_lt (sub_le_dist ..)\n                nth_rw 1 [← univ_inter s]\n                rw [inter_comm s, dist_comm, ← T_spanning, iUnion_inter _ T]\n                apply hN N (le_refl _)\n              · rwa [← μ.restrict_apply' (hgen ▸ measurableSet_generateFrom (T_mem N))]\n        _ = ENNReal.ofReal ε := by\n              rw [← ofReal_add (by linarith [ε_pos]) (by linarith [ε_pos]), add_halves]\n    · exact fun n ↦ ne_top_of_le_ne_top hμs (measure_mono (inter_subset_right ..))\n    · exact ne_top_of_le_ne_top hμs\n        (measure_mono (iUnion_subset (fun i ↦ inter_subset_right ..)))\n\n"}
{"name":"MeasureTheory.IsSeparable.exists_countable_measureDense","module":"Mathlib.MeasureTheory.Measure.SeparableMeasure","initialProofState":"X : Type u_1\nm : MeasurableSpace X\nμ : MeasureTheory.Measure X\nself : MeasureTheory.IsSeparable μ\n⊢ Exists fun 𝒜 => And 𝒜.Countable (μ.MeasureDense 𝒜)","decl":"/-- A measure `μ` is separable if there exists a countable and measure-dense family of sets.\n\nThe term \"separable\" is justified by the fact that the definition translates to the usual notion\nof separability in the metric space made by constant indicators equipped with the `Lᵖ` norm. -/\nclass IsSeparable (μ : Measure X) : Prop where\n  exists_countable_measureDense : ∃ 𝒜, 𝒜.Countable ∧ μ.MeasureDense 𝒜\n\n"}
{"name":"MeasureTheory.exists_countable_measureDense","module":"Mathlib.MeasureTheory.Measure.SeparableMeasure","initialProofState":"X : Type u_1\nm : MeasurableSpace X\nμ : MeasureTheory.Measure X\ninst✝ : MeasureTheory.IsSeparable μ\n⊢ Exists fun 𝒜 => And 𝒜.Countable (μ.MeasureDense 𝒜)","decl":"/-- By definition, a separable measure admits a countable and measure-dense family of sets. -/\ntheorem exists_countable_measureDense [IsSeparable μ] :\n    ∃ 𝒜, 𝒜.Countable ∧ μ.MeasureDense 𝒜 :=\n  IsSeparable.exists_countable_measureDense\n\n"}
{"name":"MeasureTheory.isSeparable_of_sigmaFinite","module":"Mathlib.MeasureTheory.Measure.SeparableMeasure","initialProofState":"X : Type u_1\nm : MeasurableSpace X\nμ : MeasureTheory.Measure X\ninst✝¹ : MeasurableSpace.CountablyGenerated X\ninst✝ : MeasureTheory.SigmaFinite μ\n⊢ MeasureTheory.IsSeparable μ","decl":"/-- If a measurable space is countably generated and equipped with a `σ`-finite measure, then the\nmeasure is separable. This is not an instance because it is used below to prove the more\ngeneral case where `μ` is s-finite. -/\ntheorem isSeparable_of_sigmaFinite [CountablyGenerated X] [SigmaFinite μ] :\n    IsSeparable μ where\n  exists_countable_measureDense := by\n    have h := countable_countableGeneratingSet (α := X)\n    have hgen := generateFrom_countableGeneratingSet (α := X)\n    let 𝒜 := (countableGeneratingSet X) ∪ {μ.toFiniteSpanningSetsIn.set n | n : ℕ}\n    have count_𝒜 : 𝒜.Countable :=\n      countable_union.2 ⟨h, countable_iff_exists_subset_range.2\n        ⟨μ.toFiniteSpanningSetsIn.set, fun _ hx ↦ hx⟩⟩\n    refine ⟨generateSetAlgebra 𝒜, countable_generateSetAlgebra count_𝒜,\n      Measure.MeasureDense.of_generateFrom_isSetAlgebra_sigmaFinite isSetAlgebra_generateSetAlgebra\n      { set := μ.toFiniteSpanningSetsIn.set\n        set_mem := fun n ↦ self_subset_generateSetAlgebra (𝒜 := 𝒜) <| Or.inr ⟨n, rfl⟩\n        finite := μ.toFiniteSpanningSetsIn.finite\n        spanning := μ.toFiniteSpanningSetsIn.spanning }\n      (le_antisymm ?_ (generateFrom_le (fun s hs ↦ ?_)))⟩\n    · rw [← hgen]\n      exact generateFrom_mono <| le_trans self_subset_generateSetAlgebra <|\n        generateSetAlgebra_mono <| subset_union_left ..\n    · induction hs with\n      | base t t_mem =>\n        rcases t_mem with t_mem | ⟨n, rfl⟩\n        · exact hgen ▸ measurableSet_generateFrom t_mem\n        · exact μ.toFiniteSpanningSetsIn.set_mem n\n      | empty => exact MeasurableSet.empty\n      | compl t _ t_mem => exact MeasurableSet.compl t_mem\n      | union t u _ _ t_mem u_mem => exact MeasurableSet.union t_mem u_mem\n\n"}
{"name":"MeasureTheory.instIsSeparableOfCountablyGeneratedOfSFinite","module":"Mathlib.MeasureTheory.Measure.SeparableMeasure","initialProofState":"X : Type u_1\nm : MeasurableSpace X\nμ : MeasureTheory.Measure X\ninst✝¹ : MeasurableSpace.CountablyGenerated X\ninst✝ : MeasureTheory.SFinite μ\n⊢ MeasureTheory.IsSeparable μ","decl":"/-- If a measurable space is countably generated and equipped with an s-finite measure, then the\nmeasure is separable. -/\ninstance [CountablyGenerated X] [SFinite μ] : IsSeparable μ where\n  exists_countable_measureDense := by\n    have := isSeparable_of_sigmaFinite (μ := μ.restrict μ.sigmaFiniteSet)\n    rcases exists_countable_measureDense (μ := μ.restrict μ.sigmaFiniteSet) with ⟨𝒜, count_𝒜, h𝒜⟩\n    let ℬ := {s ∩ μ.sigmaFiniteSet | s ∈ 𝒜}\n    refine ⟨ℬ, count_𝒜.image (fun s ↦ s ∩ μ.sigmaFiniteSet), ?_, ?_⟩\n    · rintro - ⟨s, s_mem, rfl⟩\n      exact (h𝒜.measurable s s_mem).inter measurableSet_sigmaFiniteSet\n    · intro s ms hμs ε ε_pos\n      rcases restrict_compl_sigmaFiniteSet_eq_zero_or_top μ s with hs | hs\n      · have : (μ.restrict μ.sigmaFiniteSet) s ≠ ∞ :=\n          ne_top_of_le_ne_top hμs <| μ.restrict_le_self _\n        rcases h𝒜.approx s ms this ε ε_pos with ⟨t, t_mem, ht⟩\n        refine ⟨t ∩ μ.sigmaFiniteSet, ⟨t, t_mem, rfl⟩, ?_⟩\n        have : μ (s ∆ (t ∩ μ.sigmaFiniteSet) \\ μ.sigmaFiniteSet) = 0 := by\n          rw [diff_eq_compl_inter, inter_symmDiff_distrib_left, ← ENNReal.bot_eq_zero, eq_bot_iff]\n          calc\n            μ ((μ.sigmaFiniteSetᶜ ∩ s) ∆ (μ.sigmaFiniteSetᶜ ∩ (t ∩ μ.sigmaFiniteSet)))\n              ≤ μ ((μ.sigmaFiniteSetᶜ ∩ s) ∪ (μ.sigmaFiniteSetᶜ ∩ (t ∩ μ.sigmaFiniteSet))) :=\n                measure_mono symmDiff_subset_union\n            _ ≤ μ (μ.sigmaFiniteSetᶜ ∩ s) + μ (μ.sigmaFiniteSetᶜ ∩ (t ∩ μ.sigmaFiniteSet)) :=\n                measure_union_le _ _\n            _ = 0 := by\n                rw [inter_comm, ← μ.restrict_apply ms, hs, ← inter_assoc, inter_comm,\n                  ← inter_assoc, inter_compl_self, empty_inter, measure_empty, zero_add]\n        rwa [← measure_inter_add_diff _ measurableSet_sigmaFiniteSet, this, add_zero,\n          inter_symmDiff_distrib_right, inter_assoc, inter_self, ← inter_symmDiff_distrib_right,\n          ← μ.restrict_apply' measurableSet_sigmaFiniteSet]\n      · refine False.elim <| hμs ?_\n        rw [eq_top_iff, ← hs]\n        exact μ.restrict_le_self _\n\n"}
{"name":"MeasureTheory.Lp.SecondCountableTopology","module":"Mathlib.MeasureTheory.Measure.SeparableMeasure","initialProofState":"X : Type u_1\nE : Type u_2\nm : MeasurableSpace X\ninst✝² : NormedAddCommGroup E\nμ : MeasureTheory.Measure X\np : ENNReal\none_le_p : Fact (LE.le 1 p)\ninst✝¹ : MeasureTheory.IsSeparable μ\ninst✝ : TopologicalSpace.SeparableSpace E\n⊢ SecondCountableTopology (Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x)","decl":"/-- If the measure `μ` is separable (in particular if `X` is countably generated and `μ` is\n`s`-finite), if `E` is a second-countable `NormedAddCommGroup`, and if `1 ≤ p < +∞`,\nthen the associated `Lᵖ` space is second-countable. -/\ninstance Lp.SecondCountableTopology [IsSeparable μ] [TopologicalSpace.SeparableSpace E] :\n    SecondCountableTopology (Lp E p μ) := by\n  -- It is enough to show that the space is separable, i.e. admits a countable and dense susbet.\n  refine @UniformSpace.secondCountable_of_separable _ _ _ ?_\n  -- There exists a countable and measure-dense family, and we can keep only the sets with finite\n  -- measure while preserving the two properties. This family is denoted `𝒜₀`.\n  rcases exists_countable_measureDense (μ := μ) with ⟨𝒜, count_𝒜, h𝒜⟩\n  have h𝒜₀ := Measure.MeasureDense.fin_meas h𝒜\n  set 𝒜₀ := {s | s ∈ 𝒜 ∧ μ s ≠ ∞}\n  have count_𝒜₀ : 𝒜₀.Countable := count_𝒜.mono fun _ ⟨h, _⟩ ↦ h\n  -- `1 ≤ p` so `p ≠ 0`, we prove it now as it is often needed.\n  have p_ne_zero : p ≠ 0 := ne_of_gt <| lt_of_lt_of_le (by norm_num) one_le_p.elim\n  -- `E` is second-countable, therefore separable and admits a countable and dense subset `u`.\n  rcases exists_countable_dense E with ⟨u, countable_u, dense_u⟩\n  -- The countable and dense subset of `Lᵖ` we are going to build is the set of finite sums of\n  -- constant indicators with support in `𝒜₀`, and is denoted `D`. To make manipulations easier,\n  -- we define the function `key` which given an integer `n` and two families of `n` elements\n  -- in `u` and `𝒜₀` associates the corresponding sum.\n  let key (n : ℕ) (d : Fin n → u) (s : Fin n → 𝒜₀) : (Lp E p μ) :=\n    ∑ i, indicatorConstLp p (h𝒜₀.measurable (s i) (Subtype.mem (s i))) (s i).2.2 (d i : E)\n  let D := {s : Lp E p μ | ∃ n d t, s = key n d t}\n  refine ⟨D, ?_, ?_⟩\n  · -- Countability directly follows from countability of `u` and `𝒜₀`. The function `f` below\n    -- is the uncurryfied version of `key`, which is easier to manipulate as countability of the\n    -- domain is automatically inferred.\n    let f (nds : Σ n : ℕ, (Fin n → u) × (Fin n → 𝒜₀)) : Lp E p μ := key nds.1 nds.2.1 nds.2.2\n    have := count_𝒜₀.to_subtype\n    have := countable_u.to_subtype\n    have : D ⊆ range f := by\n      rintro - ⟨n, d, s, rfl⟩\n      use ⟨n, (d, s)⟩\n    exact (countable_range f).mono this\n  · -- Let's turn to the density. Thanks to the density of simple functions in `Lᵖ`, it is enough\n    -- to show that the closure of `D` contains constant indicators which are in `Lᵖ` (i. e. the\n    -- set has finite measure), is closed by sum and closed.\n    -- This is given by `Lp.induction`.\n    refine Lp.induction p_ne_top.elim (P := fun f ↦ f ∈ closure D) ?_ ?_ isClosed_closure\n    · intro a s ms hμs\n      -- We want to approximate `a • 𝟙ₛ`.\n      apply ne_of_lt at hμs\n      rw [SeminormedAddCommGroup.mem_closure_iff]\n      intro ε ε_pos\n      have μs_pow_nonneg : 0 ≤ (μ s).toReal ^ (1 / p.toReal) :=\n        Real.rpow_nonneg ENNReal.toReal_nonneg _\n      -- To do so, we first pick `b ∈ u` such that `‖a - b‖ < ε / (3 * (1 + (μ s)^(1/p)))`.\n      have approx_a_pos : 0 < ε / (3 * (1 + (μ s).toReal ^ (1 / p.toReal))) :=\n        div_pos ε_pos (by linarith [μs_pow_nonneg])\n      have ⟨b, b_mem, hb⟩ := SeminormedAddCommGroup.mem_closure_iff.1 (dense_u a) _ approx_a_pos\n      -- Then we pick `t ∈ 𝒜₀` such that `‖b • 𝟙ₛ - b • 𝟙ₜ‖ < ε / 3`.\n      rcases SeminormedAddCommGroup.mem_closure_iff.1\n        (h𝒜₀.indicatorConstLp_subset_closure p b ⟨s, ms, hμs, rfl⟩)\n          (ε / 3) (by linarith [ε_pos]) with ⟨-, ⟨t, ht, hμt, rfl⟩, hst⟩\n      have mt := h𝒜₀.measurable t ht\n      -- We now show that `‖a • 𝟙ₛ - b • 𝟙ₜ‖ₚ < ε`, as follows:\n      -- `‖a • 𝟙ₛ - b • 𝟙ₜ‖ₚ`\n      --   `= ‖a • 𝟙ₛ - b • 𝟙ₛ + b • 𝟙ₛ - b • 𝟙ₜ‖ₚ`\n      --   `≤ ‖a - b‖ * ‖𝟙ₛ‖ₚ + ε / 3`\n      --   `= ‖a - b‖ * (μ s)^(1/p) + ε / 3`\n      --   `< ε * (μ s)^(1/p) / (3 * (1 + (μ s)^(1/p))) + ε / 3`\n      --   `≤ ε / 3 + ε / 3 < ε`.\n      refine ⟨indicatorConstLp p mt hμt b,\n        ⟨1, fun _ ↦ ⟨b, b_mem⟩, fun _ ↦ ⟨t, ht⟩, by simp [key]⟩, ?_⟩\n      rw [Lp.simpleFunc.coe_indicatorConst,\n        ← sub_add_sub_cancel _ (indicatorConstLp p ms hμs b), ← add_halves ε]\n      refine lt_of_le_of_lt (b := ε / 3 + ε / 3) (norm_add_le_of_le ?_ hst.le) (by linarith [ε_pos])\n      rw [indicatorConstLp_sub, norm_indicatorConstLp p_ne_zero p_ne_top.elim]\n      calc\n        ‖a - b‖ * (μ s).toReal ^ (1 / p.toReal)\n          ≤ (ε / (3 * (1 + (μ s).toReal ^ (1 / p.toReal)))) * (μ s).toReal ^ (1 / p.toReal) :=\n              mul_le_mul_of_nonneg_right (le_of_lt hb) μs_pow_nonneg\n        _ ≤ ε / 3 := by\n            rw [← mul_one (ε / 3), div_mul_eq_div_mul_one_div, mul_assoc, one_div_mul_eq_div]\n            exact mul_le_mul_of_nonneg_left\n              ((div_le_one (by linarith [μs_pow_nonneg])).2 (by linarith))\n              (by linarith [ε_pos])\n    · -- Now we have to show that the closure of `D` is closed by sum. Let `f` and `g` be two\n      -- functions in `Lᵖ` which are also in the closure of `D`.\n      rintro f g hf hg - f_mem g_mem\n      rw [SeminormedAddCommGroup.mem_closure_iff] at *\n      intro ε ε_pos\n      -- For `ε > 0`, there exists `bf, bg ∈ D` such that `‖f - bf‖ₚ < ε/2` and `‖g - bg‖ₚ < ε/2`.\n      rcases f_mem (ε / 2) (by linarith [ε_pos]) with ⟨bf, ⟨nf, df, sf, bf_eq⟩, hbf⟩\n      rcases g_mem (ε / 2) (by linarith [ε_pos]) with ⟨bg, ⟨ng, dg, sg, bg_eq⟩, hbg⟩\n      -- It is obvious that `D` is closed by sum, it suffices to concatenate the family of\n      -- elements of `u` and the family of elements of `𝒜₀`.\n      let d := fun i : Fin (nf + ng) ↦ if h : i < nf\n        then df (Fin.castLT i h)\n        else dg (Fin.subNat nf (Fin.cast (Nat.add_comm ..) i) (le_of_not_gt h))\n      let s := fun i : Fin (nf + ng) ↦ if h : i < nf\n        then sf (Fin.castLT i h)\n        else sg (Fin.subNat nf (Fin.cast (Nat.add_comm ..) i) (le_of_not_gt h))\n      -- So we can use `bf + bg`.\n      refine ⟨bf + bg, ⟨nf + ng, d, s, ?_⟩, ?_⟩\n      · simp [key, d, s, Fin.sum_univ_add, bf_eq, bg_eq]\n      · -- We have\n        -- `‖f + g - (bf + bg)‖ₚ`\n        --   `≤ ‖f - bf‖ₚ + ‖g - bg‖ₚ`\n        --   `< ε/2 + ε/2 = ε`.\n        calc\n          ‖Memℒp.toLp f hf + Memℒp.toLp g hg - (bf + bg)‖\n            = ‖(Memℒp.toLp f hf) - bf + ((Memℒp.toLp g hg) - bg)‖ := by congr; abel\n          _ ≤ ‖(Memℒp.toLp f hf) - bf‖ + ‖(Memℒp.toLp g hg) - bg‖ := norm_add_le ..\n          _ < ε := by linarith [hbf, hbg]\n\n"}
