{"name":"Subgroup.normal_of_index_eq_one","module":"Mathlib.GroupTheory.IndexNormal","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nhH : Eq H.index 1\n⊢ H.Normal","decl":"/-- A subgroup of index 1 is normal (does not require finiteness of G) -/\ntheorem normal_of_index_eq_one (hH : H.index = 1) : H.Normal := by\n  rw [index_eq_one] at hH\n  rw [hH]\n  infer_instance\n\n"}
{"name":"Subgroup.normal_of_index_eq_two","module":"Mathlib.GroupTheory.IndexNormal","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nhH : Eq H.index 2\n⊢ H.Normal","decl":"/-- A subgroup of index 2 is normal (does not require finiteness of G) -/\ntheorem normal_of_index_eq_two (hH : H.index = 2) : H.Normal where\n  conj_mem x hxH g := by simp_rw [mul_mem_iff_of_index_two hH, hxH, iff_true, inv_mem_iff]\n\n"}
{"name":"Subgroup.normal_of_index_eq_minFac_card","module":"Mathlib.GroupTheory.IndexNormal","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nhHp : Eq H.index (Nat.card G).minFac\n⊢ H.Normal","decl":"/-- A subgroup of a finite group whose index is the smallest prime factor is normal.\n\nNote : if `G` is infinite, then `Nat.card G = 0` and `(Nat.card G).minFac = 2` -/\ntheorem normal_of_index_eq_minFac_card (hHp : H.index = (Nat.card G).minFac) :\n    H.Normal := by\n  by_cases hG0 : Nat.card G = 0\n  · rw [hG0, minFac_zero] at hHp\n    exact normal_of_index_eq_two hHp\n  by_cases hG1 : Nat.card G = 1\n  · rw [hG1, minFac_one] at hHp\n    exact normal_of_index_eq_one hHp\n  suffices H.normalCore.relindex H = 1 by\n    convert H.normalCore_normal\n    exact le_antisymm (relindex_eq_one.mp this) (normalCore_le H)\n  have : Finite G := finite_of_card_ne_zero hG0\n  have index_ne_zero : H.index ≠ 0 := index_ne_zero_of_finite\n  rw [← mul_left_inj' index_ne_zero, one_mul, relindex_mul_index H.normalCore_le]\n  have hp : Nat.Prime H.index := hHp ▸ minFac_prime hG1\n  have h : H.normalCore.index ∣ H.index ! := by\n    rw [normalCore_eq_ker, index_ker, index_eq_card, ← Nat.card_perm]\n    exact card_subgroup_dvd_card (toPermHom G (G ⧸ H)).range\n  apply dvd_antisymm _ (index_dvd_of_le H.normalCore_le)\n  rwa [← Coprime.dvd_mul_right, mul_factorial_pred hp.pos]\n  have hr1 : H.normalCore.index ≠ 1 := fun hr1 ↦ hp.ne_one <|\n    Nat.eq_one_of_dvd_one (hr1 ▸ H.normalCore.index_dvd_of_le H.normalCore_le)\n  rw [Nat.coprime_factorial_iff hr1]\n  exact lt_of_lt_of_le (Nat.sub_one_lt hp.ne_zero) <|\n    hHp ▸ minFac_le_of_dvd (Nat.minFac_prime hr1).two_le\n      (dvd_trans (minFac_dvd H.normalCore.index) (H.normalCore.index_dvd_card))\n\n"}
