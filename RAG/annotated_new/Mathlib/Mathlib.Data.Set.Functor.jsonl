{"name":"Set.bind_def","module":"Mathlib.Data.Set.Functor","initialProofState":"α β : Type u\ns : Set α\nf : α → Set β\n⊢ Eq (Bind.bind s f) (Set.iUnion fun i => Set.iUnion fun h => f i)","decl":"@[simp]\ntheorem bind_def : s >>= f = ⋃ i ∈ s, f i :=\n  rfl\n\n"}
{"name":"Set.fmap_eq_image","module":"Mathlib.Data.Set.Functor","initialProofState":"α β : Type u\ns : Set α\nf : α → β\n⊢ Eq (Functor.map f s) (Set.image f s)","decl":"@[simp]\ntheorem fmap_eq_image (f : α → β) : f <$> s = f '' s :=\n  rfl\n\n"}
{"name":"Set.seq_eq_set_seq","module":"Mathlib.Data.Set.Functor","initialProofState":"α β : Type u\ns : Set (α → β)\nt : Set α\n⊢ Eq (Seq.seq s fun x => t) (s.seq t)","decl":"@[simp]\ntheorem seq_eq_set_seq (s : Set (α → β)) (t : Set α) : s <*> t = s.seq t :=\n  rfl\n\n"}
{"name":"Set.pure_def","module":"Mathlib.Data.Set.Functor","initialProofState":"α : Type u\na : α\n⊢ Eq (Pure.pure a) (Singleton.singleton a)","decl":"@[simp]\ntheorem pure_def (a : α) : (pure a : Set α) = {a} :=\n  rfl\n\n"}
{"name":"Set.image2_def","module":"Mathlib.Data.Set.Functor","initialProofState":"α β γ : Type u\nf : α → β → γ\ns : Set α\nt : Set β\n⊢ Eq (Set.image2 f s t) (Seq.seq (Functor.map f s) fun x => t)","decl":"/-- `Set.image2` in terms of monadic operations. Note that this can't be taken as the definition\nbecause of the lack of universe polymorphism. -/\ntheorem image2_def {α β γ : Type u} (f : α → β → γ) (s : Set α) (t : Set β) :\n    image2 f s t = f <$> s <*> t := by\n  ext\n  simp\n\n"}
{"name":"Set.instLawfulMonad","module":"Mathlib.Data.Set.Functor","initialProofState":"⊢ LawfulMonad Set","decl":"instance : LawfulMonad Set := LawfulMonad.mk'\n  (id_map := image_id)\n  (pure_bind := biUnion_singleton)\n  (bind_assoc := fun _ _ _ => by simp only [bind_def, biUnion_iUnion])\n  (bind_pure_comp := fun _ _ => (image_eq_iUnion _ _).symm)\n  (bind_map := fun _ _ => seq_def.symm)\n\n"}
{"name":"Set.instCommApplicative","module":"Mathlib.Data.Set.Functor","initialProofState":"⊢ CommApplicative Set","decl":"instance : CommApplicative (Set : Type u → Type u) :=\n  ⟨fun s t => prod_image_seq_comm s t⟩\n\n"}
{"name":"Set.mem_coe_of_mem","module":"Mathlib.Data.Set.Functor","initialProofState":"α : Type u\nβ : Set α\nγ : Set ↑β\na : α\nha : Membership.mem β a\nha' : Membership.mem γ ⟨a, ha⟩\n⊢ Membership.mem (Bind.bind γ fun a => Pure.pure ↑a) a","decl":"theorem mem_coe_of_mem {a : α} (ha : a ∈ β) (ha' : ⟨a, ha⟩ ∈ γ) : a ∈ (γ : Set α) :=\n  ⟨_, ⟨⟨_, rfl⟩, _, ⟨ha', rfl⟩, rfl⟩⟩\n\n"}
{"name":"Set.coe_subset","module":"Mathlib.Data.Set.Functor","initialProofState":"α : Type u\nβ : Set α\nγ : Set ↑β\n⊢ HasSubset.Subset (Bind.bind γ fun a => Pure.pure ↑a) β","decl":"theorem coe_subset : (γ : Set α) ⊆ β := by\n  intro _ ⟨_, ⟨⟨⟨_, ha⟩, rfl⟩, _, ⟨_, rfl⟩, _⟩⟩; convert ha\n\n"}
{"name":"Set.mem_of_mem_coe","module":"Mathlib.Data.Set.Functor","initialProofState":"α : Type u\nβ : Set α\nγ : Set ↑β\na : α\nha : Membership.mem (Bind.bind γ fun a => Pure.pure ↑a) a\n⊢ Membership.mem γ ⟨a, ⋯⟩","decl":"theorem mem_of_mem_coe {a : α} (ha : a ∈ (γ : Set α)) : ⟨a, coe_subset ha⟩ ∈ γ := by\n  rcases ha with ⟨_, ⟨_, rfl⟩, _, ⟨ha, rfl⟩, _⟩; convert ha\n\n"}
{"name":"Set.eq_univ_of_coe_eq","module":"Mathlib.Data.Set.Functor","initialProofState":"α : Type u\nβ : Set α\nγ : Set ↑β\nhγ : Eq (Bind.bind γ fun a => Pure.pure ↑a) β\n⊢ Eq γ Set.univ","decl":"theorem eq_univ_of_coe_eq (hγ : (γ : Set α) = β) : γ = univ :=\n  eq_univ_of_forall fun ⟨_, ha⟩ => mem_of_mem_coe <| hγ.symm ▸ ha\n\n"}
{"name":"Set.image_coe_eq_restrict_image","module":"Mathlib.Data.Set.Functor","initialProofState":"α : Type u\nβ : Set α\nγ : Set ↑β\nδ : Type u_1\nf : α → δ\n⊢ Eq (Set.image f (Bind.bind γ fun a => Pure.pure ↑a)) (Set.image (β.restrict f) γ)","decl":"theorem image_coe_eq_restrict_image {δ : Type*} {f : α → δ} : f '' γ = β.restrict f '' γ :=\n  ext fun _ =>\n    ⟨fun ⟨_, h, ha⟩ => ⟨_, mem_of_mem_coe h, ha⟩, fun ⟨_, h, ha⟩ => ⟨_, mem_coe_of_mem _ h, ha⟩⟩\n\n"}
{"name":"Set.coe_eq_image_val","module":"Mathlib.Data.Set.Functor","initialProofState":"α : Type u\ns : Set α\nt : Set ↑s\n⊢ Eq (Lean.Internal.coeM t) (Set.image Subtype.val t)","decl":"/-- The coercion from `Set.monad` as an instance is equal to the coercion in `Data.Set.Notation`. -/\ntheorem coe_eq_image_val (t : Set s) :\n    @Lean.Internal.coeM Set s α _ Set.monad t = (t : Set α) := by\n  change ⋃ (x ∈ t), {x.1} = _\n  ext\n  simp\n\n"}
{"name":"Set.mem_image_val_of_mem","module":"Mathlib.Data.Set.Functor","initialProofState":"α : Type u\nβ : Set α\nγ : Set ↑β\na : α\nha : Membership.mem β a\nha' : Membership.mem γ ⟨a, ha⟩\n⊢ Membership.mem (Set.image Subtype.val γ) a","decl":"theorem mem_image_val_of_mem (ha : a ∈ β) (ha' : ⟨a, ha⟩ ∈ γ) : a ∈ (γ : Set α) :=\n  ⟨_, ha', rfl⟩\n\n"}
{"name":"Set.image_val_subset","module":"Mathlib.Data.Set.Functor","initialProofState":"α : Type u\nβ : Set α\nγ : Set ↑β\n⊢ HasSubset.Subset (Set.image Subtype.val γ) β","decl":"theorem image_val_subset : (γ : Set α) ⊆ β := by\n  rintro _ ⟨⟨_, ha⟩, _, rfl⟩; exact ha\n\n"}
{"name":"Set.mem_of_mem_image_val","module":"Mathlib.Data.Set.Functor","initialProofState":"α : Type u\nβ : Set α\nγ : Set ↑β\na : α\nha : Membership.mem (Set.image Subtype.val γ) a\n⊢ Membership.mem γ ⟨a, ⋯⟩","decl":"theorem mem_of_mem_image_val (ha : a ∈ (γ : Set α)) : ⟨a, image_val_subset ha⟩ ∈ γ := by\n  rcases ha with ⟨_, ha, rfl⟩; exact ha\n\n"}
{"name":"Set.eq_univ_of_image_val_eq","module":"Mathlib.Data.Set.Functor","initialProofState":"α : Type u\nβ : Set α\nγ : Set ↑β\nhγ : Eq (Set.image Subtype.val γ) β\n⊢ Eq γ Set.univ","decl":"theorem eq_univ_of_image_val_eq (hγ : (γ : Set α) = β) : γ = univ :=\n  eq_univ_of_forall fun ⟨_, ha⟩ => mem_of_mem_image_val <| hγ.symm ▸ ha\n\n"}
{"name":"Set.image_image_val_eq_restrict_image","module":"Mathlib.Data.Set.Functor","initialProofState":"α : Type u\nβ : Set α\nγ : Set ↑β\nδ : Type u_1\nf : α → δ\n⊢ Eq (Set.image f (Set.image Subtype.val γ)) (Set.image (β.restrict f) γ)","decl":"theorem image_image_val_eq_restrict_image {δ : Type*} {f : α → δ} : f '' γ = β.restrict f '' γ := by\n  ext; simp\n\n"}
