{"name":"Finset.mem_finsupp_iff","module":"Mathlib.Data.Finset.Finsupp","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : Zero α\ns : Finset ι\nf : Finsupp ι α\nt : ι → Finset α\n⊢ Iff (Membership.mem (s.finsupp t) f) (And (HasSubset.Subset f.support s) (∀ (i : ι), Membership.mem s i → Membership.mem (t i) (f i)))","decl":"theorem mem_finsupp_iff {t : ι → Finset α} :\n    f ∈ s.finsupp t ↔ f.support ⊆ s ∧ ∀ i ∈ s, f i ∈ t i := by\n  classical\n  refine mem_map.trans ⟨?_, ?_⟩\n  · rintro ⟨f, hf, rfl⟩\n    refine ⟨support_indicator_subset _ _, fun i hi => ?_⟩\n    convert mem_pi.1 hf i hi\n    exact indicator_of_mem hi _\n  · refine fun h => ⟨fun i _ => f i, mem_pi.2 h.2, ?_⟩\n    ext i\n    exact ite_eq_left_iff.2 fun hi => (not_mem_support_iff.1 fun H => hi <| h.1 H).symm\n\n"}
{"name":"Finset.mem_finsupp_iff_of_support_subset","module":"Mathlib.Data.Finset.Finsupp","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : Zero α\ns : Finset ι\nf : Finsupp ι α\nt : Finsupp ι (Finset α)\nht : HasSubset.Subset t.support s\n⊢ Iff (Membership.mem (s.finsupp ⇑t) f) (∀ (i : ι), Membership.mem (t i) (f i))","decl":"/-- When `t` is supported on `s`, `f ∈ s.finsupp t` precisely means that `f` is pointwise in `t`. -/\n@[simp]\ntheorem mem_finsupp_iff_of_support_subset {t : ι →₀ Finset α} (ht : t.support ⊆ s) :\n    f ∈ s.finsupp t ↔ ∀ i, f i ∈ t i := by\n  refine\n    mem_finsupp_iff.trans\n      (forall_and.symm.trans <|\n        forall_congr' fun i =>\n          ⟨fun h => ?_, fun h =>\n            ⟨fun hi => ht <| mem_support_iff.2 fun H => mem_support_iff.1 hi ?_, fun _ => h⟩⟩)\n  · by_cases hi : i ∈ s\n    · exact h.2 hi\n    · rw [not_mem_support_iff.1 (mt h.1 hi), not_mem_support_iff.1 fun H => hi <| ht H]\n      exact zero_mem_zero\n  · rwa [H, mem_zero] at h\n\n"}
{"name":"Finset.card_finsupp","module":"Mathlib.Data.Finset.Finsupp","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : Zero α\ns : Finset ι\nt : ι → Finset α\n⊢ Eq (s.finsupp t).card (s.prod fun i => (t i).card)","decl":"@[simp]\ntheorem card_finsupp (s : Finset ι) (t : ι → Finset α) : #(s.finsupp t) = ∏ i ∈ s, #(t i) := by\n  classical exact (card_map _).trans <| card_pi _ _\n\n"}
{"name":"Finsupp.mem_pi","module":"Mathlib.Data.Finset.Finsupp","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : Zero α\nf : Finsupp ι (Finset α)\ng : Finsupp ι α\n⊢ Iff (Membership.mem f.pi g) (∀ (i : ι), Membership.mem (f i) (g i))","decl":"@[simp]\ntheorem mem_pi {f : ι →₀ Finset α} {g : ι →₀ α} : g ∈ f.pi ↔ ∀ i, g i ∈ f i :=\n  mem_finsupp_iff_of_support_subset <| Subset.refl _\n\n"}
{"name":"Finsupp.card_pi","module":"Mathlib.Data.Finset.Finsupp","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : Zero α\nf : Finsupp ι (Finset α)\n⊢ Eq f.pi.card (f.prod fun i => ↑(f i).card)","decl":"@[simp]\ntheorem card_pi (f : ι →₀ Finset α) : #f.pi = f.prod fun i ↦ #(f i) := by\n  rw [pi, card_finsupp]\n  exact Finset.prod_congr rfl fun i _ => by simp only [Pi.natCast_apply, Nat.cast_id]\n\n"}
