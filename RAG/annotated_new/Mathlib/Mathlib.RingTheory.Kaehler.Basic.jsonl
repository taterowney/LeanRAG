{"name":"KaehlerDifferential.one_smul_sub_smul_one_mem_ideal","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninstâœÂ² : CommRing R\ninstâœÂ¹ : CommRing S\ninstâœ : Algebra R S\na : S\nâŠ¢ Membership.mem (KaehlerDifferential.ideal R S) (HSub.hSub (TensorProduct.tmul R 1 a) (TensorProduct.tmul R a 1))","decl":"theorem KaehlerDifferential.one_smul_sub_smul_one_mem_ideal (a : S) :\n    (1 : S) âŠ—â‚œ[R] a - a âŠ—â‚œ[R] (1 : S) âˆˆ KaehlerDifferential.ideal R S := by simp [RingHom.mem_ker]\n\n"}
{"name":"Derivation.tensorProductTo_tmul","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninstâœâ¶ : CommRing R\ninstâœâµ : CommRing S\ninstâœâ´ : Algebra R S\nM : Type u_1\ninstâœÂ³ : AddCommGroup M\ninstâœÂ² : Module R M\ninstâœÂ¹ : Module S M\ninstâœ : IsScalarTower R S M\nD : Derivation R S M\ns t : S\nâŠ¢ Eq (D.tensorProductTo (TensorProduct.tmul R s t)) (HSMul.hSMul s (D t))","decl":"theorem Derivation.tensorProductTo_tmul (D : Derivation R S M) (s t : S) :\n    D.tensorProductTo (s âŠ—â‚œ t) = s â€¢ D t := rfl\n\n"}
{"name":"Derivation.tensorProductTo_mul","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninstâœâ¶ : CommRing R\ninstâœâµ : CommRing S\ninstâœâ´ : Algebra R S\nM : Type u_1\ninstâœÂ³ : AddCommGroup M\ninstâœÂ² : Module R M\ninstâœÂ¹ : Module S M\ninstâœ : IsScalarTower R S M\nD : Derivation R S M\nx y : TensorProduct R S S\nâŠ¢ Eq (D.tensorProductTo (HMul.hMul x y)) (HAdd.hAdd (HSMul.hSMul ((Algebra.TensorProduct.lmul' R) x) (D.tensorProductTo y)) (HSMul.hSMul ((Algebra.TensorProduct.lmul' R) y) (D.tensorProductTo x)))","decl":"theorem Derivation.tensorProductTo_mul (D : Derivation R S M) (x y : S âŠ—[R] S) :\n    D.tensorProductTo (x * y) =\n      TensorProduct.lmul' (S := S) R x â€¢ D.tensorProductTo y +\n        TensorProduct.lmul' (S := S) R y â€¢ D.tensorProductTo x := by\n  refine TensorProduct.induction_on x ?_ ?_ ?_\n  Â· rw [zero_mul, map_zero, map_zero, zero_smul, smul_zero, add_zero]\n  swap\n  Â· intro xâ‚ yâ‚ hâ‚ hâ‚‚\n    rw [add_mul, map_add, map_add, map_add, add_smul, smul_add, hâ‚, hâ‚‚, add_add_add_comm]\n  intro xâ‚ xâ‚‚\n  refine TensorProduct.induction_on y ?_ ?_ ?_\n  Â· rw [mul_zero, map_zero, map_zero, zero_smul, smul_zero, add_zero]\n  swap\n  Â· intro xâ‚ yâ‚ hâ‚ hâ‚‚\n    rw [mul_add, map_add, map_add, map_add, add_smul, smul_add, hâ‚, hâ‚‚, add_add_add_comm]\n  intro x y\n  simp only [TensorProduct.tmul_mul_tmul, Derivation.tensorProductTo,\n    TensorProduct.AlgebraTensorModule.lift_apply, TensorProduct.lift.tmul',\n    TensorProduct.lmul'_apply_tmul]\n  dsimp\n  rw [D.leibniz]\n  simp only [smul_smul, smul_add, mul_comm (x * y) xâ‚, mul_right_comm xâ‚ xâ‚‚, â† mul_assoc]\n\n"}
{"name":"KaehlerDifferential.submodule_span_range_eq_ideal","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninstâœÂ² : CommRing R\ninstâœÂ¹ : CommRing S\ninstâœ : Algebra R S\nâŠ¢ Eq (Submodule.span S (Set.range fun s => HSub.hSub (TensorProduct.tmul R 1 s) (TensorProduct.tmul R s 1))) (Submodule.restrictScalars S (KaehlerDifferential.ideal R S))","decl":"/-- The kernel of `S âŠ—[R] S â†’â‚[R] S` is generated by `1 âŠ— s - s âŠ— 1` as a `S`-module. -/\ntheorem KaehlerDifferential.submodule_span_range_eq_ideal :\n    Submodule.span S (Set.range fun s : S => (1 : S) âŠ—â‚œ[R] s - s âŠ—â‚œ[R] (1 : S)) =\n      (KaehlerDifferential.ideal R S).restrictScalars S := by\n  apply le_antisymm\n  Â· rw [Submodule.span_le]\n    rintro _ âŸ¨s, rflâŸ©\n    exact KaehlerDifferential.one_smul_sub_smul_one_mem_ideal _ _\n  Â· rintro x (hx : _ = _)\n    have : x - TensorProduct.lmul' (S := S) R x âŠ—â‚œ[R] (1 : S) = x := by\n      rw [hx, TensorProduct.zero_tmul, sub_zero]\n    rw [â† this]\n    clear this hx\n    refine TensorProduct.induction_on x ?_ ?_ ?_\n    Â· rw [map_zero, TensorProduct.zero_tmul, sub_zero]; exact zero_mem _\n    Â· intro x y\n      have : x âŠ—â‚œ[R] y - (x * y) âŠ—â‚œ[R] (1 : S) = x â€¢ ((1 : S) âŠ—â‚œ y - y âŠ—â‚œ (1 : S)) := by\n        simp_rw [smul_sub, TensorProduct.smul_tmul', smul_eq_mul, mul_one]\n      rw [TensorProduct.lmul'_apply_tmul, this]\n      refine Submodule.smul_mem _ x ?_\n      apply Submodule.subset_span\n      exact Set.mem_range_self y\n    Â· intro x y hx hy\n      rw [map_add, TensorProduct.add_tmul, â† sub_add_sub_comm]\n      exact add_mem hx hy\n\n"}
{"name":"KaehlerDifferential.span_range_eq_ideal","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninstâœÂ² : CommRing R\ninstâœÂ¹ : CommRing S\ninstâœ : Algebra R S\nâŠ¢ Eq (Ideal.span (Set.range fun s => HSub.hSub (TensorProduct.tmul R 1 s) (TensorProduct.tmul R s 1))) (KaehlerDifferential.ideal R S)","decl":"theorem KaehlerDifferential.span_range_eq_ideal :\n    Ideal.span (Set.range fun s : S => (1 : S) âŠ—â‚œ[R] s - s âŠ—â‚œ[R] (1 : S)) =\n      KaehlerDifferential.ideal R S := by\n  apply le_antisymm\n  Â· rw [Ideal.span_le]\n    rintro _ âŸ¨s, rflâŸ©\n    exact KaehlerDifferential.one_smul_sub_smul_one_mem_ideal _ _\n  Â· change (KaehlerDifferential.ideal R S).restrictScalars S â‰¤ (Ideal.span _).restrictScalars S\n    rw [â† KaehlerDifferential.submodule_span_range_eq_ideal, Ideal.span]\n    conv_rhs => rw [â† Submodule.span_span_of_tower S]\n    exact Submodule.subset_span\n\n"}
{"name":"instNonemptyKaehlerDifferential","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninstâœÂ² : CommRing R\ninstâœÂ¹ : CommRing S\ninstâœ : Algebra R S\nâŠ¢ Nonempty (KaehlerDifferential R S)","decl":"instance : Nonempty (Î©[Sâ„R]) := âŸ¨0âŸ©\n\n"}
{"name":"instIsScalarTowerTensorProductKaehlerDifferential","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninstâœÂ² : CommRing R\ninstâœÂ¹ : CommRing S\ninstâœ : Algebra R S\nâŠ¢ IsScalarTower S (TensorProduct R S S) (KaehlerDifferential R S)","decl":"instance : IsScalarTower S (S âŠ—[R] S) (Î©[Sâ„R]) :=\n  Ideal.Cotangent.isScalarTower _\n\n"}
{"name":"KaehlerDifferential.isScalarTower_of_tower","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninstâœÂ¹â° : CommRing R\ninstâœâ¹ : CommRing S\ninstâœâ¸ : Algebra R S\nRâ‚ : Type u_2\nRâ‚‚ : Type u_3\ninstâœâ· : CommRing Râ‚\ninstâœâ¶ : CommRing Râ‚‚\ninstâœâµ : Algebra Râ‚ S\ninstâœâ´ : Algebra Râ‚‚ S\ninstâœÂ³ : SMul Râ‚ Râ‚‚\ninstâœÂ² : SMulCommClass R Râ‚ S\ninstâœÂ¹ : SMulCommClass R Râ‚‚ S\ninstâœ : IsScalarTower Râ‚ Râ‚‚ S\nâŠ¢ IsScalarTower Râ‚ Râ‚‚ (KaehlerDifferential R S)","decl":"instance KaehlerDifferential.isScalarTower_of_tower {Râ‚ Râ‚‚ : Type*} [CommRing Râ‚] [CommRing Râ‚‚]\n    [Algebra Râ‚ S] [Algebra Râ‚‚ S] [SMul Râ‚ Râ‚‚]\n    [SMulCommClass R Râ‚ S] [SMulCommClass R Râ‚‚ S] [IsScalarTower Râ‚ Râ‚‚ S] :\n    IsScalarTower Râ‚ Râ‚‚ (Î©[Sâ„R]) :=\n  Submodule.Quotient.isScalarTower _ _\n\n"}
{"name":"KaehlerDifferential.isScalarTower'","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninstâœÂ² : CommRing R\ninstâœÂ¹ : CommRing S\ninstâœ : Algebra R S\nâŠ¢ IsScalarTower R (TensorProduct R S S) (KaehlerDifferential R S)","decl":"instance KaehlerDifferential.isScalarTower' : IsScalarTower R (S âŠ—[R] S) (Î©[Sâ„R]) :=\n  Submodule.Quotient.isScalarTower _ _\n\n"}
{"name":"KaehlerDifferential.DLinearMap_apply","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninstâœÂ² : CommRing R\ninstâœÂ¹ : CommRing S\ninstâœ : Algebra R S\ns : S\nâŠ¢ Eq ((KaehlerDifferential.DLinearMap R S) s) ((KaehlerDifferential.ideal R S).toCotangent âŸ¨HSub.hSub (TensorProduct.tmul R 1 s) (TensorProduct.tmul R s 1), â‹¯âŸ©)","decl":"theorem KaehlerDifferential.DLinearMap_apply (s : S) :\n    KaehlerDifferential.DLinearMap R S s =\n      (KaehlerDifferential.ideal R S).toCotangent\n        âŸ¨1 âŠ—â‚œ s - s âŠ—â‚œ 1, KaehlerDifferential.one_smul_sub_smul_one_mem_ideal R sâŸ© := rfl\n\n"}
{"name":"KaehlerDifferential.D_apply","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninstâœÂ² : CommRing R\ninstâœÂ¹ : CommRing S\ninstâœ : Algebra R S\ns : S\nâŠ¢ Eq ((KaehlerDifferential.D R S) s) ((KaehlerDifferential.ideal R S).toCotangent âŸ¨HSub.hSub (TensorProduct.tmul R 1 s) (TensorProduct.tmul R s 1), â‹¯âŸ©)","decl":"theorem KaehlerDifferential.D_apply (s : S) :\n    KaehlerDifferential.D R S s =\n      (KaehlerDifferential.ideal R S).toCotangent\n        âŸ¨1 âŠ—â‚œ s - s âŠ—â‚œ 1, KaehlerDifferential.one_smul_sub_smul_one_mem_ideal R sâŸ© := rfl\n\n"}
{"name":"KaehlerDifferential.span_range_derivation","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninstâœÂ² : CommRing R\ninstâœÂ¹ : CommRing S\ninstâœ : Algebra R S\nâŠ¢ Eq (Submodule.span S (Set.range â‡‘(KaehlerDifferential.D R S))) Top.top","decl":"theorem KaehlerDifferential.span_range_derivation :\n    Submodule.span S (Set.range <| KaehlerDifferential.D R S) = âŠ¤ := by\n  rw [_root_.eq_top_iff]\n  rintro x -\n  obtain âŸ¨âŸ¨x, hxâŸ©, rflâŸ© := Ideal.toCotangent_surjective _ x\n  have : x âˆˆ (KaehlerDifferential.ideal R S).restrictScalars S := hx\n  rw [â† KaehlerDifferential.submodule_span_range_eq_ideal] at this\n  suffices âˆƒ hx, (KaehlerDifferential.ideal R S).toCotangent âŸ¨x, hxâŸ© âˆˆ\n      Submodule.span S (Set.range <| KaehlerDifferential.D R S) by\n    exact this.choose_spec\n  refine Submodule.span_induction ?_ ?_ ?_ ?_ this\n  Â· rintro _ âŸ¨x, rflâŸ©\n    refine âŸ¨KaehlerDifferential.one_smul_sub_smul_one_mem_ideal R x, ?_âŸ©\n    apply Submodule.subset_span\n    exact âŸ¨x, KaehlerDifferential.DLinearMap_apply R S xâŸ©\n  Â· exact âŸ¨zero_mem _, Submodule.zero_mem _âŸ©\n  Â· rintro x y - - âŸ¨hxâ‚, hxâ‚‚âŸ© âŸ¨hyâ‚, hyâ‚‚âŸ©; exact âŸ¨add_mem hxâ‚ hyâ‚, Submodule.add_mem _ hxâ‚‚ hyâ‚‚âŸ©\n  Â· rintro r x - âŸ¨hxâ‚, hxâ‚‚âŸ©\n    exact âŸ¨((KaehlerDifferential.ideal R S).restrictScalars S).smul_mem r hxâ‚,\n      Submodule.smul_mem _ r hxâ‚‚âŸ©\n\n"}
{"name":"KaehlerDifferential.subsingleton_of_surjective","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninstâœÂ² : CommRing R\ninstâœÂ¹ : CommRing S\ninstâœ : Algebra R S\nh : Function.Surjective â‡‘(algebraMap R S)\nâŠ¢ Subsingleton (KaehlerDifferential R S)","decl":"/-- `Î©[Sâ„R]` is trivial if `R â†’ S` is surjective.\nAlso see `Algebra.FormallyUnramified.iff_subsingleton_kaehlerDifferential`. -/\nlemma KaehlerDifferential.subsingleton_of_surjective (h : Function.Surjective (algebraMap R S)) :\n    Subsingleton (Î©[Sâ„R]) := by\n  suffices (âŠ¤ : Submodule S (Î©[Sâ„R])) â‰¤ âŠ¥ from\n    (subsingleton_iff_forall_eq 0).mpr fun y â†¦ this trivial\n  rw [â† KaehlerDifferential.span_range_derivation, Submodule.span_le]\n  rintro _ âŸ¨x, rflâŸ©; obtain âŸ¨x, rflâŸ© := h x; simp\n\n"}
{"name":"Derivation.liftKaehlerDifferential_apply","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninstâœâ¶ : CommRing R\ninstâœâµ : CommRing S\ninstâœâ´ : Algebra R S\nM : Type u_1\ninstâœÂ³ : AddCommGroup M\ninstâœÂ² : Module R M\ninstâœÂ¹ : Module S M\ninstâœ : IsScalarTower R S M\nD : Derivation R S M\nx : Subtype fun x => Membership.mem (KaehlerDifferential.ideal R S) x\nâŠ¢ Eq (D.liftKaehlerDifferential ((KaehlerDifferential.ideal R S).toCotangent x)) (D.tensorProductTo â†‘x)","decl":"theorem Derivation.liftKaehlerDifferential_apply (D : Derivation R S M) (x) :\n    D.liftKaehlerDifferential ((KaehlerDifferential.ideal R S).toCotangent x) =\n      D.tensorProductTo x := rfl\n\n"}
{"name":"Derivation.liftKaehlerDifferential_comp","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninstâœâ¶ : CommRing R\ninstâœâµ : CommRing S\ninstâœâ´ : Algebra R S\nM : Type u_1\ninstâœÂ³ : AddCommGroup M\ninstâœÂ² : Module R M\ninstâœÂ¹ : Module S M\ninstâœ : IsScalarTower R S M\nD : Derivation R S M\nâŠ¢ Eq (D.liftKaehlerDifferential.compDer (KaehlerDifferential.D R S)) D","decl":"theorem Derivation.liftKaehlerDifferential_comp (D : Derivation R S M) :\n    D.liftKaehlerDifferential.compDer (KaehlerDifferential.D R S) = D := by\n  ext a\n  dsimp [KaehlerDifferential.D_apply]\n  refine (D.liftKaehlerDifferential_apply _).trans ?_\n  rw [Subtype.coe_mk, map_sub, Derivation.tensorProductTo_tmul, Derivation.tensorProductTo_tmul,\n    one_smul, D.map_one_eq_zero, smul_zero, sub_zero]\n\n"}
{"name":"Derivation.liftKaehlerDifferential_comp_D","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninstâœâ¶ : CommRing R\ninstâœâµ : CommRing S\ninstâœâ´ : Algebra R S\nM : Type u_1\ninstâœÂ³ : AddCommGroup M\ninstâœÂ² : Module R M\ninstâœÂ¹ : Module S M\ninstâœ : IsScalarTower R S M\nD' : Derivation R S M\nx : S\nâŠ¢ Eq (D'.liftKaehlerDifferential ((KaehlerDifferential.D R S) x)) (D' x)","decl":"@[simp]\ntheorem Derivation.liftKaehlerDifferential_comp_D (D' : Derivation R S M) (x : S) :\n    D'.liftKaehlerDifferential (KaehlerDifferential.D R S x) = D' x :=\n  Derivation.congr_fun D'.liftKaehlerDifferential_comp x\n\n"}
{"name":"Derivation.liftKaehlerDifferential_unique","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninstâœâ¶ : CommRing R\ninstâœâµ : CommRing S\ninstâœâ´ : Algebra R S\nM : Type u_1\ninstâœÂ³ : AddCommGroup M\ninstâœÂ² : Module R M\ninstâœÂ¹ : Module S M\ninstâœ : IsScalarTower R S M\nf f' : LinearMap (RingHom.id S) (KaehlerDifferential R S) M\nhf : Eq (f.compDer (KaehlerDifferential.D R S)) (f'.compDer (KaehlerDifferential.D R S))\nâŠ¢ Eq f f'","decl":"@[ext]\ntheorem Derivation.liftKaehlerDifferential_unique (f f' : Î©[Sâ„R] â†’â‚—[S] M)\n    (hf : f.compDer (KaehlerDifferential.D R S) = f'.compDer (KaehlerDifferential.D R S)) :\n    f = f' := by\n  apply LinearMap.ext\n  intro x\n  have : x âˆˆ Submodule.span S (Set.range <| KaehlerDifferential.D R S) := by\n    rw [KaehlerDifferential.span_range_derivation]; trivial\n  refine Submodule.span_induction ?_ ?_ ?_ ?_ this\n  Â· rintro _ âŸ¨x, rflâŸ©; exact congr_arg (fun D : Derivation R S M => D x) hf\n  Â· rw [map_zero, map_zero]\n  Â· intro x y _ _ hx hy; rw [map_add, map_add, hx, hy]\n  Â· intro a x _ e; simp [e]\n\n"}
{"name":"Derivation.liftKaehlerDifferential_unique_iff","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninstâœâ¶ : CommRing R\ninstâœâµ : CommRing S\ninstâœâ´ : Algebra R S\nM : Type u_1\ninstâœÂ³ : AddCommGroup M\ninstâœÂ² : Module R M\ninstâœÂ¹ : Module S M\ninstâœ : IsScalarTower R S M\nf f' : LinearMap (RingHom.id S) (KaehlerDifferential R S) M\nâŠ¢ Iff (Eq f f') (Eq (f.compDer (KaehlerDifferential.D R S)) (f'.compDer (KaehlerDifferential.D R S)))","decl":"@[ext]\ntheorem Derivation.liftKaehlerDifferential_unique (f f' : Î©[Sâ„R] â†’â‚—[S] M)\n    (hf : f.compDer (KaehlerDifferential.D R S) = f'.compDer (KaehlerDifferential.D R S)) :\n    f = f' := by\n  apply LinearMap.ext\n  intro x\n  have : x âˆˆ Submodule.span S (Set.range <| KaehlerDifferential.D R S) := by\n    rw [KaehlerDifferential.span_range_derivation]; trivial\n  refine Submodule.span_induction ?_ ?_ ?_ ?_ this\n  Â· rintro _ âŸ¨x, rflâŸ©; exact congr_arg (fun D : Derivation R S M => D x) hf\n  Â· rw [map_zero, map_zero]\n  Â· intro x y _ _ hx hy; rw [map_add, map_add, hx, hy]\n  Â· intro a x _ e; simp [e]\n\n"}
{"name":"Derivation.liftKaehlerDifferential_D","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninstâœÂ² : CommRing R\ninstâœÂ¹ : CommRing S\ninstâœ : Algebra R S\nâŠ¢ Eq (KaehlerDifferential.D R S).liftKaehlerDifferential LinearMap.id","decl":"theorem Derivation.liftKaehlerDifferential_D :\n    (KaehlerDifferential.D R S).liftKaehlerDifferential = LinearMap.id :=\n  Derivation.liftKaehlerDifferential_unique _ _\n    (KaehlerDifferential.D R S).liftKaehlerDifferential_comp\n\n"}
{"name":"KaehlerDifferential.D_tensorProductTo","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninstâœÂ² : CommRing R\ninstâœÂ¹ : CommRing S\ninstâœ : Algebra R S\nx : Subtype fun x => Membership.mem (KaehlerDifferential.ideal R S) x\nâŠ¢ Eq ((KaehlerDifferential.D R S).tensorProductTo â†‘x) ((KaehlerDifferential.ideal R S).toCotangent x)","decl":"theorem KaehlerDifferential.D_tensorProductTo (x : KaehlerDifferential.ideal R S) :\n    (KaehlerDifferential.D R S).tensorProductTo x =\n      (KaehlerDifferential.ideal R S).toCotangent x := by\n  rw [â† Derivation.liftKaehlerDifferential_apply, Derivation.liftKaehlerDifferential_D]\n  rfl\n\n"}
{"name":"KaehlerDifferential.tensorProductTo_surjective","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninstâœÂ² : CommRing R\ninstâœÂ¹ : CommRing S\ninstâœ : Algebra R S\nâŠ¢ Function.Surjective â‡‘(KaehlerDifferential.D R S).tensorProductTo","decl":"theorem KaehlerDifferential.tensorProductTo_surjective :\n    Function.Surjective (KaehlerDifferential.D R S).tensorProductTo := by\n  intro x; obtain âŸ¨x, rflâŸ© := (KaehlerDifferential.ideal R S).toCotangent_surjective x\n  exact âŸ¨x, KaehlerDifferential.D_tensorProductTo xâŸ©\n\n"}
{"name":"KaehlerDifferential.linearMapEquivDerivation_symm_apply","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninstâœâ¶ : CommRing R\ninstâœâµ : CommRing S\ninstâœâ´ : Algebra R S\nM : Type u_1\ninstâœÂ³ : AddCommGroup M\ninstâœÂ² : Module R M\ninstâœÂ¹ : Module S M\ninstâœ : IsScalarTower R S M\nD : Derivation R S M\nâŠ¢ Eq ((KaehlerDifferential.linearMapEquivDerivation R S).symm D) D.liftKaehlerDifferential","decl":"/-- The `S`-linear maps from `Î©[Sâ„R]` to `M` are (`S`-linearly) equivalent to `R`-derivations\nfrom `S` to `M`. -/\n@[simps! symm_apply apply_apply]\ndef KaehlerDifferential.linearMapEquivDerivation : (Î©[Sâ„R] â†’â‚—[S] M) â‰ƒâ‚—[S] Derivation R S M :=\n  { Derivation.llcomp.flip <| KaehlerDifferential.D R S with\n    invFun := Derivation.liftKaehlerDifferential\n    left_inv := fun _ =>\n      Derivation.liftKaehlerDifferential_unique _ _ (Derivation.liftKaehlerDifferential_comp _)\n    right_inv := Derivation.liftKaehlerDifferential_comp }\n\n"}
{"name":"KaehlerDifferential.linearMapEquivDerivation_apply_apply","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninstâœâ¶ : CommRing R\ninstâœâµ : CommRing S\ninstâœâ´ : Algebra R S\nM : Type u_1\ninstâœÂ³ : AddCommGroup M\ninstâœÂ² : Module R M\ninstâœÂ¹ : Module S M\ninstâœ : IsScalarTower R S M\nm : LinearMap (RingHom.id S) (KaehlerDifferential R S) M\naâœ : S\nâŠ¢ Eq (((KaehlerDifferential.linearMapEquivDerivation R S) m) aâœ) (m ((KaehlerDifferential.D R S) aâœ))","decl":"/-- The `S`-linear maps from `Î©[Sâ„R]` to `M` are (`S`-linearly) equivalent to `R`-derivations\nfrom `S` to `M`. -/\n@[simps! symm_apply apply_apply]\ndef KaehlerDifferential.linearMapEquivDerivation : (Î©[Sâ„R] â†’â‚—[S] M) â‰ƒâ‚—[S] Derivation R S M :=\n  { Derivation.llcomp.flip <| KaehlerDifferential.D R S with\n    invFun := Derivation.liftKaehlerDifferential\n    left_inv := fun _ =>\n      Derivation.liftKaehlerDifferential_unique _ _ (Derivation.liftKaehlerDifferential_comp _)\n    right_inv := Derivation.liftKaehlerDifferential_comp }\n\n"}
{"name":"KaehlerDifferential.End_equiv_aux","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninstâœÂ² : CommRing R\ninstâœÂ¹ : CommRing S\ninstâœ : Algebra R S\nf : AlgHom R S (HasQuotient.Quotient (TensorProduct R S S) (HPow.hPow (KaehlerDifferential.ideal R S) 2))\nâŠ¢ Iff (Eq ((Ideal.Quotient.mkâ‚ R (KaehlerDifferential.ideal R S).cotangentIdeal).comp f) (IsScalarTower.toAlgHom R S (HasQuotient.Quotient (HasQuotient.Quotient (TensorProduct R S S) (HPow.hPow (KaehlerDifferential.ideal R S) 2)) (KaehlerDifferential.ideal R S).cotangentIdeal))) (Eq ((Algebra.TensorProduct.lmul' R).kerSquareLift.comp f) (AlgHom.id R S))","decl":"theorem KaehlerDifferential.End_equiv_aux (f : S â†’â‚[R] S âŠ— S â§¸ KaehlerDifferential.ideal R S ^ 2) :\n    (Ideal.Quotient.mkâ‚ R (KaehlerDifferential.ideal R S).cotangentIdeal).comp f =\n        IsScalarTower.toAlgHom R S _ â†”\n      (TensorProduct.lmul' R : S âŠ—[R] S â†’â‚[R] S).kerSquareLift.comp f = AlgHom.id R S := by\n  rw [AlgHom.ext_iff, AlgHom.ext_iff]\n  apply forall_congr'\n  intro x\n  have eâ‚ : (TensorProduct.lmul' R : S âŠ—[R] S â†’â‚[R] S).kerSquareLift (f x) =\n      KaehlerDifferential.quotientCotangentIdealRingEquiv R S\n        (Ideal.Quotient.mk (KaehlerDifferential.ideal R S).cotangentIdeal <| f x) := by\n    generalize f x = y; obtain âŸ¨y, rflâŸ© := Ideal.Quotient.mk_surjective y; rfl\n  have eâ‚‚ :\n    x = KaehlerDifferential.quotientCotangentIdealRingEquiv R S (IsScalarTower.toAlgHom R S _ x) :=\n    (mul_one x).symm\n  constructor\n  Â· intro e\n    exact (eâ‚.trans (@RingEquiv.congr_arg _ _ _ _ _ _\n      (KaehlerDifferential.quotientCotangentIdealRingEquiv R S) _ _ e)).trans eâ‚‚.symm\n  Â· intro e; apply (KaehlerDifferential.quotientCotangentIdealRingEquiv R S).injective\n    exact eâ‚.symm.trans (e.trans eâ‚‚)\n\n/- Note: Lean is slow to synthesize these instances (times out).\n  Without them the endEquivDerivation' and endEquivAuxEquiv both have significant timeouts.\n  In Mathlib 3, it was slow but not this slow. -/\n"}
{"name":"isScalarTower_S_right","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninstâœÂ² : CommRing R\ninstâœÂ¹ : CommRing S\ninstâœ : Algebra R S\nâŠ¢ IsScalarTower S (HasQuotient.Quotient (TensorProduct R S S) (HPow.hPow (KaehlerDifferential.ideal R S) 2)) (HasQuotient.Quotient (TensorProduct R S S) (HPow.hPow (KaehlerDifferential.ideal R S) 2))","decl":"/-- A shortcut instance to prevent timing out. Hopefully to be removed in the future. -/\n@[nolint defLemma]\nlocal instance isScalarTower_S_right :\n    IsScalarTower S (S âŠ—[R] S â§¸ KaehlerDifferential.ideal R S ^ 2)\n      (S âŠ—[R] S â§¸ KaehlerDifferential.ideal R S ^ 2) := Ideal.Quotient.isScalarTower_right\n\n"}
{"name":"isScalarTower_R_right","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninstâœÂ² : CommRing R\ninstâœÂ¹ : CommRing S\ninstâœ : Algebra R S\nâŠ¢ IsScalarTower R (HasQuotient.Quotient (TensorProduct R S S) (HPow.hPow (KaehlerDifferential.ideal R S) 2)) (HasQuotient.Quotient (TensorProduct R S S) (HPow.hPow (KaehlerDifferential.ideal R S) 2))","decl":"/-- A shortcut instance to prevent timing out. Hopefully to be removed in the future. -/\n@[nolint defLemma]\nlocal instance isScalarTower_R_right :\n    IsScalarTower R (S âŠ—[R] S â§¸ KaehlerDifferential.ideal R S ^ 2)\n      (S âŠ—[R] S â§¸ KaehlerDifferential.ideal R S ^ 2) := Ideal.Quotient.isScalarTower_right\n\n"}
{"name":"isScalarTower_SS_right","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninstâœÂ² : CommRing R\ninstâœÂ¹ : CommRing S\ninstâœ : Algebra R S\nâŠ¢ IsScalarTower (TensorProduct R S S) (HasQuotient.Quotient (TensorProduct R S S) (HPow.hPow (KaehlerDifferential.ideal R S) 2)) (HasQuotient.Quotient (TensorProduct R S S) (HPow.hPow (KaehlerDifferential.ideal R S) 2))","decl":"/-- A shortcut instance to prevent timing out. Hopefully to be removed in the future. -/\n@[nolint defLemma]\nlocal instance isScalarTower_SS_right : IsScalarTower (S âŠ—[R] S)\n    (S âŠ—[R] S â§¸ KaehlerDifferential.ideal R S ^ 2) (S âŠ—[R] S â§¸ KaehlerDifferential.ideal R S ^ 2) :=\n  Ideal.Quotient.isScalarTower_right\n\n"}
{"name":"KaehlerDifferential.ideal_fg","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninstâœÂ³ : CommRing R\ninstâœÂ² : CommRing S\ninstâœÂ¹ : Algebra R S\ninstâœ : Algebra.EssFiniteType R S\nâŠ¢ (KaehlerDifferential.ideal R S).FG","decl":"theorem KaehlerDifferential.ideal_fg [EssFiniteType R S] :\n    (KaehlerDifferential.ideal R S).FG := by\n  classical\n  use (EssFiniteType.finset R S).image (fun s â†¦ (1 : S) âŠ—â‚œ[R] s - s âŠ—â‚œ[R] (1 : S))\n  apply le_antisymm\n  Â· rw [Finset.coe_image, Ideal.span_le]\n    rintro _ âŸ¨x, _, rflâŸ©\n    exact KaehlerDifferential.one_smul_sub_smul_one_mem_ideal R x\n  Â· rw [â† KaehlerDifferential.span_range_eq_ideal, Ideal.span_le]\n    rintro _ âŸ¨x, rflâŸ©\n    let I : Ideal (S âŠ—[R] S) := Ideal.span\n      ((EssFiniteType.finset R S).image (fun s â†¦ (1 : S) âŠ—â‚œ[R] s - s âŠ—â‚œ[R] (1 : S)))\n    show _ - _ âˆˆ I\n    have : (IsScalarTower.toAlgHom R (S âŠ—[R] S) (S âŠ—[R] S â§¸ I)).comp TensorProduct.includeRight =\n        (IsScalarTower.toAlgHom R (S âŠ—[R] S) (S âŠ—[R] S â§¸ I)).comp TensorProduct.includeLeft := by\n      apply EssFiniteType.algHom_ext\n      intro a ha\n      simp only [AlgHom.coe_comp, IsScalarTower.coe_toAlgHom', Ideal.Quotient.algebraMap_eq,\n        Function.comp_apply, TensorProduct.includeLeft_apply, TensorProduct.includeRight_apply,\n        Ideal.Quotient.mk_eq_mk_iff_sub_mem]\n      refine Ideal.subset_span ?_\n      simp only [Finset.coe_image, Set.mem_image, Finset.mem_coe]\n      exact âŸ¨a, ha, rflâŸ©\n    simpa [Ideal.Quotient.mk_eq_mk_iff_sub_mem] using AlgHom.congr_fun this x\n\n"}
{"name":"KaehlerDifferential.finite","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninstâœÂ³ : CommRing R\ninstâœÂ² : CommRing S\ninstâœÂ¹ : Algebra R S\ninstâœ : Algebra.EssFiniteType R S\nâŠ¢ Module.Finite S (KaehlerDifferential R S)","decl":"instance KaehlerDifferential.finite [EssFiniteType R S] :\n    Module.Finite S (Î©[Sâ„R]) := by\n  classical\n  let s := (EssFiniteType.finset R S).image (fun s â†¦ D R S s)\n  refine âŸ¨âŸ¨s, top_le_iff.mp ?_âŸ©âŸ©\n  rw [â† span_range_derivation, Submodule.span_le]\n  rintro _ âŸ¨x, rflâŸ©\n  have : âˆ€ x âˆˆ adjoin R (EssFiniteType.finset R S).toSet,\n      .D _ _ x âˆˆ Submodule.span S s.toSet := by\n    intro x hx\n    refine adjoin_induction ?_ ?_ ?_ ?_ hx\n    Â· exact fun x hx â†¦ Submodule.subset_span (Finset.mem_image_of_mem _ hx)\n    Â· simp\n    Â· exact fun x y _ _ hx hy â†¦ (D R S).map_add x y â–¸ add_mem hx hy\n    Â· intro x y _ _ hx hy\n      simp only [Derivation.leibniz]\n      exact add_mem (Submodule.smul_mem _ _ hy) (Submodule.smul_mem _ _ hx)\n  obtain âŸ¨t, ht, ht', hxtâŸ© := (essFiniteType_cond_iff R S (EssFiniteType.finset R S)).mp\n    EssFiniteType.cond.choose_spec x\n  rw [show D R S x =\n    ht'.unitâ»Â¹ â€¢ (D R S (x * t) - x â€¢ D R S t) by simp [smul_smul, Units.smul_def]]\n  exact Submodule.smul_mem _ _ (sub_mem (this _ hxt) (Submodule.smul_mem _ _ (this _ ht)))\n\n"}
{"name":"KaehlerDifferential.kerTotal_mkQ_single_add","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninstâœÂ² : CommRing R\ninstâœÂ¹ : CommRing S\ninstâœ : Algebra R S\nx y z : S\nâŠ¢ Eq ((KaehlerDifferential.kerTotal R S).mkQ (Finsupp.single (HAdd.hAdd x y) z)) (HAdd.hAdd ((KaehlerDifferential.kerTotal R S).mkQ (Finsupp.single x z)) ((KaehlerDifferential.kerTotal R S).mkQ (Finsupp.single y z)))","decl":"theorem KaehlerDifferential.kerTotal_mkQ_single_add (x y z) : (zğ–£x + y) = (zğ–£x) + zğ–£y := by\n  rw [â† map_add, eq_comm, â† sub_eq_zero, â† map_sub (Submodule.mkQ (kerTotal R S)),\n    Submodule.mkQ_apply, Submodule.Quotient.mk_eq_zero]\n  simp_rw [â† Finsupp.smul_single_one _ z, â† smul_add, â† smul_sub]\n  exact Submodule.smul_mem _ _ (Submodule.subset_span (Or.inl <| Or.inl <| âŸ¨âŸ¨_, _âŸ©, rflâŸ©))\n\n"}
{"name":"KaehlerDifferential.kerTotal_mkQ_single_mul","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninstâœÂ² : CommRing R\ninstâœÂ¹ : CommRing S\ninstâœ : Algebra R S\nx y z : S\nâŠ¢ Eq ((KaehlerDifferential.kerTotal R S).mkQ (Finsupp.single (HMul.hMul x y) z)) (HAdd.hAdd ((KaehlerDifferential.kerTotal R S).mkQ (Finsupp.single y (HMul.hMul z x))) ((KaehlerDifferential.kerTotal R S).mkQ (Finsupp.single x (HMul.hMul z y))))","decl":"theorem KaehlerDifferential.kerTotal_mkQ_single_mul (x y z) :\n    (zğ–£x * y) = ((z * x)ğ–£y) + (z * y)ğ–£x := by\n  rw [â† map_add, eq_comm, â† sub_eq_zero, â† map_sub (Submodule.mkQ (kerTotal R S)),\n    Submodule.mkQ_apply, Submodule.Quotient.mk_eq_zero]\n  simp_rw [â† Finsupp.smul_single_one _ z, â† @smul_eq_mul _ _ z, â† Finsupp.smul_single, â† smul_add,\n    â† smul_sub]\n  exact Submodule.smul_mem _ _ (Submodule.subset_span (Or.inl <| Or.inr <| âŸ¨âŸ¨_, _âŸ©, rflâŸ©))\n\n"}
{"name":"KaehlerDifferential.kerTotal_mkQ_single_algebraMap","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninstâœÂ² : CommRing R\ninstâœÂ¹ : CommRing S\ninstâœ : Algebra R S\nx : R\ny : S\nâŠ¢ Eq ((KaehlerDifferential.kerTotal R S).mkQ (Finsupp.single ((algebraMap R S) x) y)) 0","decl":"theorem KaehlerDifferential.kerTotal_mkQ_single_algebraMap (x y) : (yğ–£algebraMap R S x) = 0 := by\n  rw [Submodule.mkQ_apply, Submodule.Quotient.mk_eq_zero, â† Finsupp.smul_single_one _ y]\n  exact Submodule.smul_mem _ _ (Submodule.subset_span (Or.inr <| âŸ¨_, rflâŸ©))\n\n"}
{"name":"KaehlerDifferential.kerTotal_mkQ_single_algebraMap_one","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninstâœÂ² : CommRing R\ninstâœÂ¹ : CommRing S\ninstâœ : Algebra R S\nx : S\nâŠ¢ Eq ((KaehlerDifferential.kerTotal R S).mkQ (Finsupp.single 1 x)) 0","decl":"theorem KaehlerDifferential.kerTotal_mkQ_single_algebraMap_one (x) : (xğ–£1) = 0 := by\n  rw [â† (algebraMap R S).map_one, KaehlerDifferential.kerTotal_mkQ_single_algebraMap]\n\n"}
{"name":"KaehlerDifferential.kerTotal_mkQ_single_smul","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninstâœÂ² : CommRing R\ninstâœÂ¹ : CommRing S\ninstâœ : Algebra R S\nr : R\nx y : S\nâŠ¢ Eq ((KaehlerDifferential.kerTotal R S).mkQ (Finsupp.single (HSMul.hSMul r x) y)) (HSMul.hSMul r ((KaehlerDifferential.kerTotal R S).mkQ (Finsupp.single x y)))","decl":"theorem KaehlerDifferential.kerTotal_mkQ_single_smul (r : R) (x y) : (yğ–£r â€¢ x) = r â€¢ yğ–£x := by\n  letI : SMulZeroClass R S := inferInstance\n  rw [Algebra.smul_def, KaehlerDifferential.kerTotal_mkQ_single_mul,\n    KaehlerDifferential.kerTotal_mkQ_single_algebraMap, add_zero, â† LinearMap.map_smul_of_tower,\n    Finsupp.smul_single, mul_comm, Algebra.smul_def]\n\n"}
{"name":"KaehlerDifferential.derivationQuotKerTotal_apply","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninstâœÂ² : CommRing R\ninstâœÂ¹ : CommRing S\ninstâœ : Algebra R S\nx : S\nâŠ¢ Eq ((KaehlerDifferential.derivationQuotKerTotal R S) x) ((KaehlerDifferential.kerTotal R S).mkQ (Finsupp.single x 1))","decl":"theorem KaehlerDifferential.derivationQuotKerTotal_apply (x) :\n    KaehlerDifferential.derivationQuotKerTotal R S x = 1ğ–£x :=\n  rfl\n\n"}
{"name":"KaehlerDifferential.derivationQuotKerTotal_lift_comp_linearCombination","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninstâœÂ² : CommRing R\ninstâœÂ¹ : CommRing S\ninstâœ : Algebra R S\nâŠ¢ Eq ((KaehlerDifferential.derivationQuotKerTotal R S).liftKaehlerDifferential.comp (Finsupp.linearCombination S â‡‘(KaehlerDifferential.D R S))) (KaehlerDifferential.kerTotal R S).mkQ","decl":"theorem KaehlerDifferential.derivationQuotKerTotal_lift_comp_linearCombination :\n    (KaehlerDifferential.derivationQuotKerTotal R S).liftKaehlerDifferential.comp\n        (Finsupp.linearCombination S (KaehlerDifferential.D R S)) =\n      Submodule.mkQ _ := by\n  apply Finsupp.lhom_ext\n  intro a b\n  conv_rhs => rw [â† Finsupp.smul_single_one a b, LinearMap.map_smul]\n  simp [KaehlerDifferential.derivationQuotKerTotal_apply]\n\n"}
{"name":"KaehlerDifferential.derivationQuotKerTotal_lift_comp_total","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninstâœÂ² : CommRing R\ninstâœÂ¹ : CommRing S\ninstâœ : Algebra R S\nâŠ¢ Eq ((KaehlerDifferential.derivationQuotKerTotal R S).liftKaehlerDifferential.comp (Finsupp.linearCombination S â‡‘(KaehlerDifferential.D R S))) (KaehlerDifferential.kerTotal R S).mkQ","decl":"@[deprecated (since := \"2024-08-29\")] alias\n  KaehlerDifferential.derivationQuotKerTotal_lift_comp_total :=\n  KaehlerDifferential.derivationQuotKerTotal_lift_comp_linearCombination\n\n"}
{"name":"KaehlerDifferential.kerTotal_eq","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninstâœÂ² : CommRing R\ninstâœÂ¹ : CommRing S\ninstâœ : Algebra R S\nâŠ¢ Eq (LinearMap.ker (Finsupp.linearCombination S â‡‘(KaehlerDifferential.D R S))) (KaehlerDifferential.kerTotal R S)","decl":"theorem KaehlerDifferential.kerTotal_eq :\n    LinearMap.ker (Finsupp.linearCombination S (KaehlerDifferential.D R S)) =\n      KaehlerDifferential.kerTotal R S := by\n  apply le_antisymm\n  Â· conv_rhs => rw [â† (KaehlerDifferential.kerTotal R S).ker_mkQ]\n    rw [â† KaehlerDifferential.derivationQuotKerTotal_lift_comp_linearCombination]\n    exact LinearMap.ker_le_ker_comp _ _\n  Â· rw [KaehlerDifferential.kerTotal, Submodule.span_le]\n    rintro _ ((âŸ¨âŸ¨x, yâŸ©, rflâŸ© | âŸ¨âŸ¨x, yâŸ©, rflâŸ©) | âŸ¨x, rflâŸ©) <;> dsimp <;> simp [LinearMap.mem_ker]\n\n"}
{"name":"KaehlerDifferential.linearCombination_surjective","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninstâœÂ² : CommRing R\ninstâœÂ¹ : CommRing S\ninstâœ : Algebra R S\nâŠ¢ Function.Surjective â‡‘(Finsupp.linearCombination S â‡‘(KaehlerDifferential.D R S))","decl":"theorem KaehlerDifferential.linearCombination_surjective :\n    Function.Surjective (Finsupp.linearCombination S (KaehlerDifferential.D R S)) := by\n  rw [â† LinearMap.range_eq_top, range_linearCombination, span_range_derivation]\n\n"}
{"name":"KaehlerDifferential.total_surjective","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninstâœÂ² : CommRing R\ninstâœÂ¹ : CommRing S\ninstâœ : Algebra R S\nâŠ¢ Function.Surjective â‡‘(Finsupp.linearCombination S â‡‘(KaehlerDifferential.D R S))","decl":"@[deprecated (since := \"2024-08-29\")] alias KaehlerDifferential.total_surjective :=\n  KaehlerDifferential.linearCombination_surjective\n\n"}
{"name":"KaehlerDifferential.quotKerTotalEquiv_apply","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninstâœÂ² : CommRing R\ninstâœÂ¹ : CommRing S\ninstâœ : Algebra R S\naâœ : HasQuotient.Quotient (Finsupp S S) (KaehlerDifferential.kerTotal R S).toAddSubgroup\nâŠ¢ Eq ((KaehlerDifferential.quotKerTotalEquiv R S) aâœ) ((QuotientAddGroup.lift (KaehlerDifferential.kerTotal R S).toAddSubgroup (Finsupp.linearCombination S â‡‘(KaehlerDifferential.D R S)).toAddMonoidHom â‹¯) aâœ)","decl":"/-- `Î©[Sâ„R]` is isomorphic to `S` copies of `S` with kernel `KaehlerDifferential.kerTotal`. -/\n@[simps!]\nnoncomputable def KaehlerDifferential.quotKerTotalEquiv :\n    ((S â†’â‚€ S) â§¸ KaehlerDifferential.kerTotal R S) â‰ƒâ‚—[S] Î©[Sâ„R] :=\n  { (KaehlerDifferential.kerTotal R S).liftQ\n      (Finsupp.linearCombination S (KaehlerDifferential.D R S))\n      (KaehlerDifferential.kerTotal_eq R S).ge with\n    invFun := (KaehlerDifferential.derivationQuotKerTotal R S).liftKaehlerDifferential\n    left_inv := by\n      intro x\n      obtain âŸ¨x, rflâŸ© := Submodule.mkQ_surjective _ x\n      exact\n        LinearMap.congr_fun\n          (KaehlerDifferential.derivationQuotKerTotal_lift_comp_linearCombination R S :) x\n    right_inv := by\n      intro x\n      obtain âŸ¨x, rflâŸ© := KaehlerDifferential.linearCombination_surjective R S x\n      have := LinearMap.congr_fun\n        (KaehlerDifferential.derivationQuotKerTotal_lift_comp_linearCombination R S) x\n      rw [LinearMap.comp_apply] at this\n      rw [this]\n      rfl }\n\n"}
{"name":"KaehlerDifferential.quotKerTotalEquiv_symm_apply","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninstâœÂ² : CommRing R\ninstâœÂ¹ : CommRing S\ninstâœ : Algebra R S\na : KaehlerDifferential R S\nâŠ¢ Eq ((KaehlerDifferential.quotKerTotalEquiv R S).symm a) ((KaehlerDifferential.derivationQuotKerTotal R S).liftKaehlerDifferential a)","decl":"/-- `Î©[Sâ„R]` is isomorphic to `S` copies of `S` with kernel `KaehlerDifferential.kerTotal`. -/\n@[simps!]\nnoncomputable def KaehlerDifferential.quotKerTotalEquiv :\n    ((S â†’â‚€ S) â§¸ KaehlerDifferential.kerTotal R S) â‰ƒâ‚—[S] Î©[Sâ„R] :=\n  { (KaehlerDifferential.kerTotal R S).liftQ\n      (Finsupp.linearCombination S (KaehlerDifferential.D R S))\n      (KaehlerDifferential.kerTotal_eq R S).ge with\n    invFun := (KaehlerDifferential.derivationQuotKerTotal R S).liftKaehlerDifferential\n    left_inv := by\n      intro x\n      obtain âŸ¨x, rflâŸ© := Submodule.mkQ_surjective _ x\n      exact\n        LinearMap.congr_fun\n          (KaehlerDifferential.derivationQuotKerTotal_lift_comp_linearCombination R S :) x\n    right_inv := by\n      intro x\n      obtain âŸ¨x, rflâŸ© := KaehlerDifferential.linearCombination_surjective R S x\n      have := LinearMap.congr_fun\n        (KaehlerDifferential.derivationQuotKerTotal_lift_comp_linearCombination R S) x\n      rw [LinearMap.comp_apply] at this\n      rw [this]\n      rfl }\n\n"}
{"name":"KaehlerDifferential.quotKerTotalEquiv_symm_comp_D","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninstâœÂ² : CommRing R\ninstâœÂ¹ : CommRing S\ninstâœ : Algebra R S\nâŠ¢ Eq ((â†‘(KaehlerDifferential.quotKerTotalEquiv R S).symm).compDer (KaehlerDifferential.D R S)) (KaehlerDifferential.derivationQuotKerTotal R S)","decl":"theorem KaehlerDifferential.quotKerTotalEquiv_symm_comp_D :\n    (KaehlerDifferential.quotKerTotalEquiv R S).symm.toLinearMap.compDer\n        (KaehlerDifferential.D R S) =\n      KaehlerDifferential.derivationQuotKerTotal R S := by\n  convert (KaehlerDifferential.derivationQuotKerTotal R S).liftKaehlerDifferential_comp\n\n"}
{"name":"KaehlerDifferential.kerTotal_map","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninstâœÂ¹â° : CommRing R\ninstâœâ¹ : CommRing S\ninstâœâ¸ : Algebra R S\nA : Type u_2\nB : Type u_3\ninstâœâ· : CommRing A\ninstâœâ¶ : CommRing B\ninstâœâµ : Algebra R A\ninstâœâ´ : Algebra A B\ninstâœÂ³ : Algebra S B\ninstâœÂ² : Algebra R B\ninstâœÂ¹ : IsScalarTower R A B\ninstâœ : IsScalarTower R S B\nh : Function.Surjective â‡‘(algebraMap A B)\nâŠ¢ Eq (Max.max (Submodule.map ((Finsupp.mapRange.linearMap (Algebra.linearMap A B)).comp (Finsupp.lmapDomain A A â‡‘(algebraMap A B))) (KaehlerDifferential.kerTotal R A)) (Submodule.span A (Set.range fun x => Finsupp.single ((algebraMap S B) x) 1))) (Submodule.restrictScalars A (KaehlerDifferential.kerTotal S B))","decl":"/--\nGiven the commutative diagram\n```\nA --â†’ B\nâ†‘     â†‘\n|     |\nR --â†’ S\n```\nThe kernel of the presentation `âŠ•â‚“ B dx â†  Î©_{B/S}` is spanned by the image of the\nkernel of `âŠ•â‚“ A dx â†  Î©_{A/R}` and all `ds` with `s : S`.\nSee `kerTotal_map'` for the special case where `R = S`.\n-/\ntheorem KaehlerDifferential.kerTotal_map [Algebra R B] [IsScalarTower R A B] [IsScalarTower R S B]\n    (h : Function.Surjective (algebraMap A B)) :\n    (KaehlerDifferential.kerTotal R A).map finsupp_map âŠ”\n        Submodule.span A (Set.range fun x : S => .single (algebraMap S B x) (1 : B)) =\n      (KaehlerDifferential.kerTotal S B).restrictScalars _ := by\n  rw [KaehlerDifferential.kerTotal, Submodule.map_span, KaehlerDifferential.kerTotal,\n    Submodule.restrictScalars_span _ _ h]\n  simp_rw [Set.image_union, Submodule.span_union, â† Set.image_univ, Set.image_image, Set.image_univ,\n    map_sub, map_add]\n  simp only [LinearMap.comp_apply, Finsupp.lmapDomain_apply, Finsupp.mapDomain_single,\n    Finsupp.mapRange.linearMap_apply, Finsupp.mapRange_single, Algebra.linearMap_apply,\n    map_one, map_add, map_mul]\n  simp_rw [sup_assoc, â† (h.prodMap h).range_comp]\n  congr!\n  -- Porting note: new\n  simp_rw [â† IsScalarTower.algebraMap_apply R A B]\n  rw [sup_eq_right]\n  apply Submodule.span_mono\n  simp_rw [IsScalarTower.algebraMap_apply R S B]\n  exact Set.range_comp_subset_range (algebraMap R S)\n    fun x => Finsupp.single (algebraMap S B x) (1 : B)\n\n"}
{"name":"KaehlerDifferential.kerTotal_map'","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\ninstâœâ¶ : CommRing R\nA : Type u_2\nB : Type u_3\ninstâœâµ : CommRing A\ninstâœâ´ : CommRing B\ninstâœÂ³ : Algebra R A\ninstâœÂ² : Algebra A B\ninstâœÂ¹ : Algebra R B\ninstâœ : IsScalarTower R A B\nh : Function.Surjective â‡‘(algebraMap A B)\nâŠ¢ Eq (Submodule.map ((Finsupp.mapRange.linearMap (Algebra.linearMap A B)).comp (Finsupp.lmapDomain A A â‡‘(algebraMap A B))) (Max.max (KaehlerDifferential.kerTotal R A) (Submodule.span A (Set.range fun x => Finsupp.single ((algebraMap R A) x) 1)))) (Submodule.restrictScalars A (KaehlerDifferential.kerTotal R B))","decl":"/--\nThis is a special case of `kerTotal_map` where `R = S`.\nThe kernel of the presentation `âŠ•â‚“ B dx â†  Î©_{B/R}` is spanned by the image of the\nkernel of `âŠ•â‚“ A dx â†  Î©_{A/R}` and all `da` with `a : A`.\n-/\ntheorem KaehlerDifferential.kerTotal_map' [Algebra R B]\n    [IsScalarTower R A B] (h : Function.Surjective (algebraMap A B)) :\n    (KaehlerDifferential.kerTotal R A âŠ”\n      Submodule.span A (Set.range fun x â†¦ .single (algebraMap R A x) 1)).map finsupp_map =\n      (KaehlerDifferential.kerTotal R B).restrictScalars _ := by\n  rw [Submodule.map_sup, â† kerTotal_map R R A B h, Submodule.map_span, â† Set.range_comp]\n  congr\n  refine congr_arg Set.range ?_\n  ext; simp [IsScalarTower.algebraMap_eq R A B]\n\n"}
{"name":"KaehlerDifferential.map_compDer","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninstâœÂ¹Â¹ : CommRing R\ninstâœÂ¹â° : CommRing S\ninstâœâ¹ : Algebra R S\nA : Type u_2\nB : Type u_3\ninstâœâ¸ : CommRing A\ninstâœâ· : CommRing B\ninstâœâ¶ : Algebra R A\ninstâœâµ : Algebra A B\ninstâœâ´ : Algebra S B\ninstâœÂ³ : Algebra R B\ninstâœÂ² : IsScalarTower R A B\ninstâœÂ¹ : IsScalarTower R S B\ninstâœ : SMulCommClass S A B\nâŠ¢ Eq ((KaehlerDifferential.map R S A B).compDer (KaehlerDifferential.D R A)) (Derivation.compAlgebraMap A (Derivation.restrictScalars R (KaehlerDifferential.D S B)))","decl":"theorem KaehlerDifferential.map_compDer :\n    (KaehlerDifferential.map R S A B).compDer (KaehlerDifferential.D R A) =\n      ((KaehlerDifferential.D S B).restrictScalars R).compAlgebraMap A :=\n  Derivation.liftKaehlerDifferential_comp _\n\n"}
{"name":"KaehlerDifferential.map_D","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninstâœÂ¹Â¹ : CommRing R\ninstâœÂ¹â° : CommRing S\ninstâœâ¹ : Algebra R S\nA : Type u_2\nB : Type u_3\ninstâœâ¸ : CommRing A\ninstâœâ· : CommRing B\ninstâœâ¶ : Algebra R A\ninstâœâµ : Algebra A B\ninstâœâ´ : Algebra S B\ninstâœÂ³ : Algebra R B\ninstâœÂ² : IsScalarTower R A B\ninstâœÂ¹ : IsScalarTower R S B\ninstâœ : SMulCommClass S A B\nx : A\nâŠ¢ Eq ((KaehlerDifferential.map R S A B) ((KaehlerDifferential.D R A) x)) ((KaehlerDifferential.D S B) ((algebraMap A B) x))","decl":"@[simp]\ntheorem KaehlerDifferential.map_D (x : A) :\n    KaehlerDifferential.map R S A B (KaehlerDifferential.D R A x) =\n      KaehlerDifferential.D S B (algebraMap A B x) :=\n  Derivation.congr_fun (KaehlerDifferential.map_compDer R S A B) x\n\n"}
{"name":"KaehlerDifferential.ker_map","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninstâœÂ¹Â¹ : CommRing R\ninstâœÂ¹â° : CommRing S\ninstâœâ¹ : Algebra R S\nA : Type u_2\nB : Type u_3\ninstâœâ¸ : CommRing A\ninstâœâ· : CommRing B\ninstâœâ¶ : Algebra R A\ninstâœâµ : Algebra A B\ninstâœâ´ : Algebra S B\ninstâœÂ³ : Algebra R B\ninstâœÂ² : IsScalarTower R A B\ninstâœÂ¹ : IsScalarTower R S B\ninstâœ : SMulCommClass S A B\nâŠ¢ Eq (LinearMap.ker (KaehlerDifferential.map R S A B)) (Submodule.map (Finsupp.linearCombination A â‡‘(KaehlerDifferential.D R A)) (Submodule.comap ((Finsupp.mapRange.linearMap (Algebra.linearMap A B)).comp (Finsupp.lmapDomain A A â‡‘(algebraMap A B))) (Submodule.restrictScalars A (KaehlerDifferential.kerTotal S B))))","decl":"theorem KaehlerDifferential.ker_map :\n    LinearMap.ker (KaehlerDifferential.map R S A B) =\n      (((kerTotal S B).restrictScalars A).comap finsupp_map).map\n        (Finsupp.linearCombination (M := Î©[Aâ„R]) A (D R A)) := by\n  rw [â† Submodule.map_comap_eq_of_surjective (linearCombination_surjective R A) (LinearMap.ker _)]\n  congr 1\n  ext x\n  simp only [Submodule.mem_comap, LinearMap.mem_ker, Finsupp.apply_linearCombination, â† kerTotal_eq,\n    Submodule.restrictScalars_mem]\n  simp only [linearCombination_apply, Function.comp_apply, LinearMap.coe_comp, lmapDomain_apply,\n    Finsupp.mapRange.linearMap_apply]\n  rw [Finsupp.sum_mapRange_index, Finsupp.sum_mapDomain_index]\n  Â· simp [ofId]\n  Â· simp\n  Â· simp [add_smul]\n  Â· simp\n\n"}
{"name":"KaehlerDifferential.ker_map_of_surjective","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\ninstâœâ¶ : CommRing R\nA : Type u_2\nB : Type u_3\ninstâœâµ : CommRing A\ninstâœâ´ : CommRing B\ninstâœÂ³ : Algebra R A\ninstâœÂ² : Algebra A B\ninstâœÂ¹ : Algebra R B\ninstâœ : IsScalarTower R A B\nh : Function.Surjective â‡‘(algebraMap A B)\nâŠ¢ Eq (LinearMap.ker (KaehlerDifferential.map R R A B)) (Submodule.map (Finsupp.linearCombination A â‡‘(KaehlerDifferential.D R A)) (LinearMap.ker ((Finsupp.mapRange.linearMap (Algebra.linearMap A B)).comp (Finsupp.lmapDomain A A â‡‘(algebraMap A B)))))","decl":"lemma KaehlerDifferential.ker_map_of_surjective (h : Function.Surjective (algebraMap A B)) :\n    LinearMap.ker (map R R A B) =\n      (LinearMap.ker finsupp_map).map (Finsupp.linearCombination A (D R A)) := by\n  rw [ker_map, â† kerTotal_map' R A B h, Submodule.comap_map_eq, Submodule.map_sup,\n    Submodule.map_sup, â† kerTotal_eq, â† Submodule.comap_bot,\n    Submodule.map_comap_eq_of_surjective (linearCombination_surjective _ _),\n    bot_sup_eq, Submodule.map_span, â† Set.range_comp]\n  convert bot_sup_eq _\n  rw [Submodule.span_eq_bot]; simp\n\n"}
{"name":"KaehlerDifferential.map_surjective_of_surjective","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninstâœÂ¹Â¹ : CommRing R\ninstâœÂ¹â° : CommRing S\ninstâœâ¹ : Algebra R S\nA : Type u_2\nB : Type u_3\ninstâœâ¸ : CommRing A\ninstâœâ· : CommRing B\ninstâœâ¶ : Algebra R A\ninstâœâµ : Algebra A B\ninstâœâ´ : Algebra S B\ninstâœÂ³ : Algebra R B\ninstâœÂ² : IsScalarTower R A B\ninstâœÂ¹ : IsScalarTower R S B\ninstâœ : SMulCommClass S A B\nh : Function.Surjective â‡‘(algebraMap A B)\nâŠ¢ Function.Surjective â‡‘(KaehlerDifferential.map R S A B)","decl":"theorem KaehlerDifferential.map_surjective_of_surjective\n    (h : Function.Surjective (algebraMap A B)) :\n    Function.Surjective (KaehlerDifferential.map R S A B) := by\n  rw [â† LinearMap.range_eq_top, _root_.eq_top_iff,\n    â† @Submodule.restrictScalars_top A B, â† span_range_derivation,\n    Submodule.restrictScalars_span _ _ h, Submodule.span_le]\n  rintro _ âŸ¨x, rflâŸ©\n  obtain âŸ¨y, rflâŸ© := h x\n  rw [â† KaehlerDifferential.map_D R S A B]\n  exact âŸ¨_, rflâŸ©\n\n"}
{"name":"KaehlerDifferential.map_surjective","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninstâœâ¶ : CommRing R\ninstâœâµ : CommRing S\ninstâœâ´ : Algebra R S\nB : Type u_3\ninstâœÂ³ : CommRing B\ninstâœÂ² : Algebra S B\ninstâœÂ¹ : Algebra R B\ninstâœ : IsScalarTower R S B\nâŠ¢ Function.Surjective â‡‘(KaehlerDifferential.map R S B B)","decl":"theorem KaehlerDifferential.map_surjective :\n    Function.Surjective (KaehlerDifferential.map R S B B) :=\n  map_surjective_of_surjective R S B B Function.surjective_id\n\n"}
{"name":"KaehlerDifferential.mapBaseChange_tmul","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\ninstâœâ¶ : CommRing R\nA : Type u_2\nB : Type u_3\ninstâœâµ : CommRing A\ninstâœâ´ : CommRing B\ninstâœÂ³ : Algebra R A\ninstâœÂ² : Algebra A B\ninstâœÂ¹ : Algebra R B\ninstâœ : IsScalarTower R A B\nx : B\ny : KaehlerDifferential R A\nâŠ¢ Eq ((KaehlerDifferential.mapBaseChange R A B) (TensorProduct.tmul A x y)) (HSMul.hSMul x ((KaehlerDifferential.map R R A B) y))","decl":"@[simp]\ntheorem KaehlerDifferential.mapBaseChange_tmul (x : B) (y : Î©[Aâ„R]) :\n    KaehlerDifferential.mapBaseChange R A B (x âŠ—â‚œ y) = x â€¢ KaehlerDifferential.map R R A B y := by\n  conv_lhs => rw [â† mul_one x, â† smul_eq_mul, â† TensorProduct.smul_tmul', LinearMap.map_smul]\n  congr 1\n  exact IsBaseChange.lift_eq _ _ _\n\n"}
{"name":"KaehlerDifferential.range_mapBaseChange","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\ninstâœâ¶ : CommRing R\nA : Type u_2\nB : Type u_3\ninstâœâµ : CommRing A\ninstâœâ´ : CommRing B\ninstâœÂ³ : Algebra R A\ninstâœÂ² : Algebra A B\ninstâœÂ¹ : Algebra R B\ninstâœ : IsScalarTower R A B\nâŠ¢ Eq (LinearMap.range (KaehlerDifferential.mapBaseChange R A B)) (LinearMap.ker (KaehlerDifferential.map R A B B))","decl":"lemma KaehlerDifferential.range_mapBaseChange :\n    LinearMap.range (mapBaseChange R A B) = LinearMap.ker (map R A B B) := by\n  apply le_antisymm\n  Â· rintro _ âŸ¨x, rflâŸ©\n    induction' x with r s\n    Â· simp\n    Â· obtain âŸ¨x, rflâŸ© := linearCombination_surjective _ _ s\n      simp only [mapBaseChange_tmul, LinearMap.mem_ker, map_smul]\n      induction x using Finsupp.induction_linear\n      Â· simp\n      Â· simp [smul_add, *]\n      Â· simp\n    Â· rw [map_add]; exact add_mem â€¹_â€º â€¹_â€º\n  Â· convert_to (kerTotal A B).map (Finsupp.linearCombination B (D R B)) â‰¤ _\n    Â· rw [KaehlerDifferential.ker_map]\n      congr 1\n      convert Submodule.comap_id _\n      Â· ext; simp\n    rw [Submodule.map_le_iff_le_comap, kerTotal, Submodule.span_le]\n    rintro f ((âŸ¨âŸ¨x, yâŸ©, rflâŸ©|âŸ¨âŸ¨x, yâŸ©, rflâŸ©)|âŸ¨x, rflâŸ©)\n    Â· use 0; simp\n    Â· use 0; simp\n    Â· use 1 âŠ—â‚œ D _ _ x; simp\n\n"}
{"name":"KaehlerDifferential.exact_mapBaseChange_map","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\ninstâœâ¶ : CommRing R\nA : Type u_2\nB : Type u_3\ninstâœâµ : CommRing A\ninstâœâ´ : CommRing B\ninstâœÂ³ : Algebra R A\ninstâœÂ² : Algebra A B\ninstâœÂ¹ : Algebra R B\ninstâœ : IsScalarTower R A B\nâŠ¢ Function.Exact â‡‘(KaehlerDifferential.mapBaseChange R A B) â‡‘(KaehlerDifferential.map R A B B)","decl":"/-- The sequence `B âŠ—[A] Î©[Aâ„R] â†’ Î©[Bâ„R] â†’ Î©[Bâ„A] â†’ 0` is exact.\nAlso see `KaehlerDifferential.map_surjective`. -/\nlemma KaehlerDifferential.exact_mapBaseChange_map :\n    Function.Exact (mapBaseChange R A B) (map R A B B) :=\n  SetLike.ext_iff.mp (range_mapBaseChange R A B).symm\n\n"}
{"name":"KaehlerDifferential.kerToTensor_apply","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\ninstâœâ´ : CommRing R\nA : Type u_2\nB : Type u_3\ninstâœÂ³ : CommRing A\ninstâœÂ² : CommRing B\ninstâœÂ¹ : Algebra R A\ninstâœ : Algebra A B\nx : Subtype fun x => Membership.mem (RingHom.ker (algebraMap A B)) x\nâŠ¢ Eq ((KaehlerDifferential.kerToTensor R A B) x) (TensorProduct.tmul A 1 ((KaehlerDifferential.D R A) â†‘x))","decl":"/-- The map `I â†’ B âŠ—[A] Î©[Aâ„R]` where `I = ker(A â†’ B)`. -/\n@[simps]\nnoncomputable\ndef KaehlerDifferential.kerToTensor :\n    RingHom.ker (algebraMap A B) â†’â‚—[A] B âŠ—[A] Î©[Aâ„R] where\n  toFun x := 1 âŠ—â‚œ D R A x\n  map_add' x y := by simp only [Submodule.coe_add, map_add, TensorProduct.tmul_add]\n  map_smul' r x := by simp only [SetLike.val_smul, smul_eq_mul, Derivation.leibniz,\n    TensorProduct.tmul_add, TensorProduct.tmul_smul, TensorProduct.smul_tmul', â†\n    algebraMap_eq_smul_one, RingHom.mem_ker.mp x.prop, TensorProduct.zero_tmul, add_zero,\n    RingHom.id_apply]\n\n"}
{"name":"KaehlerDifferential.kerCotangentToTensor_toCotangent","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\ninstâœâ´ : CommRing R\nA : Type u_2\nB : Type u_3\ninstâœÂ³ : CommRing A\ninstâœÂ² : CommRing B\ninstâœÂ¹ : Algebra R A\ninstâœ : Algebra A B\nx : Subtype fun x => Membership.mem (RingHom.ker (algebraMap A B)) x\nâŠ¢ Eq ((KaehlerDifferential.kerCotangentToTensor R A B) ((RingHom.ker (algebraMap A B)).toCotangent x)) (TensorProduct.tmul A 1 ((KaehlerDifferential.D R A) â†‘x))","decl":"@[simp]\nlemma KaehlerDifferential.kerCotangentToTensor_toCotangent (x) :\n    kerCotangentToTensor R A B (Ideal.toCotangent _ x) = 1 âŠ—â‚œ D _ _ x.1 := rfl\n\n"}
{"name":"KaehlerDifferential.range_kerCotangentToTensor","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\ninstâœâ¶ : CommRing R\nA : Type u_2\nB : Type u_3\ninstâœâµ : CommRing A\ninstâœâ´ : CommRing B\ninstâœÂ³ : Algebra R A\ninstâœÂ² : Algebra A B\ninstâœÂ¹ : Algebra R B\ninstâœ : IsScalarTower R A B\nh : Function.Surjective â‡‘(algebraMap A B)\nâŠ¢ Eq (LinearMap.range (KaehlerDifferential.kerCotangentToTensor R A B)) (Submodule.restrictScalars A (LinearMap.ker (KaehlerDifferential.mapBaseChange R A B)))","decl":"theorem KaehlerDifferential.range_kerCotangentToTensor\n    (h : Function.Surjective (algebraMap A B)) :\n    LinearMap.range (kerCotangentToTensor R A B) =\n      (LinearMap.ker (KaehlerDifferential.mapBaseChange R A B)).restrictScalars A := by\n  classical\n  ext x\n  constructor\n  Â· rintro âŸ¨x, rflâŸ©\n    obtain âŸ¨x, rflâŸ© := Ideal.toCotangent_surjective _ x\n    simp only [kerCotangentToTensor_toCotangent, Submodule.restrictScalars_mem, LinearMap.mem_ker,\n      mapBaseChange_tmul, map_D, RingHom.mem_ker.mp x.2, map_zero, smul_zero]\n  Â· intro hx\n    obtain âŸ¨x, rflâŸ© := LinearMap.rTensor_surjective (Î©[Aâ„R]) (g := Algebra.linearMap A B) h x\n    obtain âŸ¨x, rflâŸ© := (TensorProduct.lid _ _).symm.surjective x\n    replace hx : x âˆˆ LinearMap.ker (KaehlerDifferential.map R R A B) := by simpa using hx\n    rw [KaehlerDifferential.ker_map_of_surjective R A B h] at hx\n    obtain âŸ¨x, hx, rflâŸ© := hx\n    simp only [TensorProduct.lid_symm_apply, LinearMap.rTensor_tmul,\n      Algebra.linearMap_apply, map_one]\n    rw [â† Finsupp.sum_single x, Finsupp.sum, â† Finset.sum_fiberwise_of_maps_to\n      (fun _ â†¦ Finset.mem_image_of_mem (algebraMap A B))]\n    simp only [Function.comp_apply, map_sum (s := x.support.image (algebraMap A B)),\n      TensorProduct.tmul_sum]\n    apply sum_mem\n    intro c _\n    simp only [Finset.filter_congr_decidable, TensorProduct.lid_symm_apply, LinearMap.rTensor_tmul,\n      AlgHom.toLinearMap_apply, map_one, LinearMap.mem_range]\n    simp only [map_sum, Finsupp.linearCombination_single]\n    have : (x.support.filter (algebraMap A B Â· = c)).sum x âˆˆ RingHom.ker (algebraMap A B) := by\n      simpa [Finsupp.mapDomain, Finsupp.sum, Finsupp.finset_sum_apply, RingHom.mem_ker,\n        Finsupp.single_apply, â† Finset.sum_filter] using DFunLike.congr_fun hx c\n    obtain âŸ¨a, haâŸ© := h c\n    use (x.support.filter (algebraMap A B Â· = c)).attach.sum\n        fun i â†¦ x i â€¢ Ideal.toCotangent _ âŸ¨i - a, ?_âŸ©; swap\n    Â· have : x i â‰  0 âˆ§ algebraMap A B i = c := by\n        convert i.prop\n        simp_rw [Finset.mem_filter, Finsupp.mem_support_iff]\n      simp [RingHom.mem_ker, ha, this.2]\n    Â· simp only [map_sum, LinearMapClass.map_smul, kerCotangentToTensor_toCotangent, map_sub]\n      simp_rw [â† TensorProduct.tmul_smul]\n      -- was `simp [kerCotangentToTensor_toCotangent, RingHom.mem_ker.mp x.2]` and very slow\n      -- (https://github.com/leanprover-community/mathlib4/issues/19751)\n      simp only [smul_sub, TensorProduct.tmul_sub, Finset.sum_sub_distrib, â† TensorProduct.tmul_sum,\n        â† Finset.sum_smul, Finset.sum_attach, sub_eq_self,\n        Finset.sum_attach (f := fun i â†¦ x i â€¢ KaehlerDifferential.D R A i)]\n      rw [â† TensorProduct.smul_tmul, â† Algebra.algebraMap_eq_smul_one, RingHom.mem_ker.mp this,\n        TensorProduct.zero_tmul]\n\n"}
{"name":"KaehlerDifferential.exact_kerCotangentToTensor_mapBaseChange","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\ninstâœâ¶ : CommRing R\nA : Type u_2\nB : Type u_3\ninstâœâµ : CommRing A\ninstâœâ´ : CommRing B\ninstâœÂ³ : Algebra R A\ninstâœÂ² : Algebra A B\ninstâœÂ¹ : Algebra R B\ninstâœ : IsScalarTower R A B\nh : Function.Surjective â‡‘(algebraMap A B)\nâŠ¢ Function.Exact â‡‘(KaehlerDifferential.kerCotangentToTensor R A B) â‡‘(KaehlerDifferential.mapBaseChange R A B)","decl":"theorem KaehlerDifferential.exact_kerCotangentToTensor_mapBaseChange\n    (h : Function.Surjective (algebraMap A B)) :\n    Function.Exact (kerCotangentToTensor R A B) (KaehlerDifferential.mapBaseChange R A B) :=\n  SetLike.ext_iff.mp (range_kerCotangentToTensor R A B h).symm\n\n"}
{"name":"KaehlerDifferential.mapBaseChange_surjective","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\ninstâœâ¶ : CommRing R\nA : Type u_2\nB : Type u_3\ninstâœâµ : CommRing A\ninstâœâ´ : CommRing B\ninstâœÂ³ : Algebra R A\ninstâœÂ² : Algebra A B\ninstâœÂ¹ : Algebra R B\ninstâœ : IsScalarTower R A B\nh : Function.Surjective â‡‘(algebraMap A B)\nâŠ¢ Function.Surjective â‡‘(KaehlerDifferential.mapBaseChange R A B)","decl":"lemma KaehlerDifferential.mapBaseChange_surjective\n    (h : Function.Surjective (algebraMap A B)) :\n    Function.Surjective (KaehlerDifferential.mapBaseChange R A B) := by\n  have := subsingleton_of_surjective A B h\n  rw [â† LinearMap.range_eq_top, range_mapBaseChange, â† top_le_iff]\n  exact fun x _ â†¦ Subsingleton.elim _ _\n\n"}
