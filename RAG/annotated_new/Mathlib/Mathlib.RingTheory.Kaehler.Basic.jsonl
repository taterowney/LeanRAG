{"name":"KaehlerDifferential.one_smul_sub_smul_one_mem_ideal","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\na : S\n⊢ Membership.mem (KaehlerDifferential.ideal R S) (HSub.hSub (TensorProduct.tmul R 1 a) (TensorProduct.tmul R a 1))","decl":"theorem KaehlerDifferential.one_smul_sub_smul_one_mem_ideal (a : S) :\n    (1 : S) ⊗ₜ[R] a - a ⊗ₜ[R] (1 : S) ∈ KaehlerDifferential.ideal R S := by simp [RingHom.mem_ker]\n\n"}
{"name":"Derivation.tensorProductTo_tmul","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nM : Type u_1\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Module S M\ninst✝ : IsScalarTower R S M\nD : Derivation R S M\ns t : S\n⊢ Eq (D.tensorProductTo (TensorProduct.tmul R s t)) (HSMul.hSMul s (D t))","decl":"theorem Derivation.tensorProductTo_tmul (D : Derivation R S M) (s t : S) :\n    D.tensorProductTo (s ⊗ₜ t) = s • D t := rfl\n\n"}
{"name":"Derivation.tensorProductTo_mul","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nM : Type u_1\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Module S M\ninst✝ : IsScalarTower R S M\nD : Derivation R S M\nx y : TensorProduct R S S\n⊢ Eq (D.tensorProductTo (HMul.hMul x y)) (HAdd.hAdd (HSMul.hSMul ((Algebra.TensorProduct.lmul' R) x) (D.tensorProductTo y)) (HSMul.hSMul ((Algebra.TensorProduct.lmul' R) y) (D.tensorProductTo x)))","decl":"theorem Derivation.tensorProductTo_mul (D : Derivation R S M) (x y : S ⊗[R] S) :\n    D.tensorProductTo (x * y) =\n      TensorProduct.lmul' (S := S) R x • D.tensorProductTo y +\n        TensorProduct.lmul' (S := S) R y • D.tensorProductTo x := by\n  refine TensorProduct.induction_on x ?_ ?_ ?_\n  · rw [zero_mul, map_zero, map_zero, zero_smul, smul_zero, add_zero]\n  swap\n  · intro x₁ y₁ h₁ h₂\n    rw [add_mul, map_add, map_add, map_add, add_smul, smul_add, h₁, h₂, add_add_add_comm]\n  intro x₁ x₂\n  refine TensorProduct.induction_on y ?_ ?_ ?_\n  · rw [mul_zero, map_zero, map_zero, zero_smul, smul_zero, add_zero]\n  swap\n  · intro x₁ y₁ h₁ h₂\n    rw [mul_add, map_add, map_add, map_add, add_smul, smul_add, h₁, h₂, add_add_add_comm]\n  intro x y\n  simp only [TensorProduct.tmul_mul_tmul, Derivation.tensorProductTo,\n    TensorProduct.AlgebraTensorModule.lift_apply, TensorProduct.lift.tmul',\n    TensorProduct.lmul'_apply_tmul]\n  dsimp\n  rw [D.leibniz]\n  simp only [smul_smul, smul_add, mul_comm (x * y) x₁, mul_right_comm x₁ x₂, ← mul_assoc]\n\n"}
{"name":"KaehlerDifferential.submodule_span_range_eq_ideal","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\n⊢ Eq (Submodule.span S (Set.range fun s => HSub.hSub (TensorProduct.tmul R 1 s) (TensorProduct.tmul R s 1))) (Submodule.restrictScalars S (KaehlerDifferential.ideal R S))","decl":"/-- The kernel of `S ⊗[R] S →ₐ[R] S` is generated by `1 ⊗ s - s ⊗ 1` as a `S`-module. -/\ntheorem KaehlerDifferential.submodule_span_range_eq_ideal :\n    Submodule.span S (Set.range fun s : S => (1 : S) ⊗ₜ[R] s - s ⊗ₜ[R] (1 : S)) =\n      (KaehlerDifferential.ideal R S).restrictScalars S := by\n  apply le_antisymm\n  · rw [Submodule.span_le]\n    rintro _ ⟨s, rfl⟩\n    exact KaehlerDifferential.one_smul_sub_smul_one_mem_ideal _ _\n  · rintro x (hx : _ = _)\n    have : x - TensorProduct.lmul' (S := S) R x ⊗ₜ[R] (1 : S) = x := by\n      rw [hx, TensorProduct.zero_tmul, sub_zero]\n    rw [← this]\n    clear this hx\n    refine TensorProduct.induction_on x ?_ ?_ ?_\n    · rw [map_zero, TensorProduct.zero_tmul, sub_zero]; exact zero_mem _\n    · intro x y\n      have : x ⊗ₜ[R] y - (x * y) ⊗ₜ[R] (1 : S) = x • ((1 : S) ⊗ₜ y - y ⊗ₜ (1 : S)) := by\n        simp_rw [smul_sub, TensorProduct.smul_tmul', smul_eq_mul, mul_one]\n      rw [TensorProduct.lmul'_apply_tmul, this]\n      refine Submodule.smul_mem _ x ?_\n      apply Submodule.subset_span\n      exact Set.mem_range_self y\n    · intro x y hx hy\n      rw [map_add, TensorProduct.add_tmul, ← sub_add_sub_comm]\n      exact add_mem hx hy\n\n"}
{"name":"KaehlerDifferential.span_range_eq_ideal","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\n⊢ Eq (Ideal.span (Set.range fun s => HSub.hSub (TensorProduct.tmul R 1 s) (TensorProduct.tmul R s 1))) (KaehlerDifferential.ideal R S)","decl":"theorem KaehlerDifferential.span_range_eq_ideal :\n    Ideal.span (Set.range fun s : S => (1 : S) ⊗ₜ[R] s - s ⊗ₜ[R] (1 : S)) =\n      KaehlerDifferential.ideal R S := by\n  apply le_antisymm\n  · rw [Ideal.span_le]\n    rintro _ ⟨s, rfl⟩\n    exact KaehlerDifferential.one_smul_sub_smul_one_mem_ideal _ _\n  · change (KaehlerDifferential.ideal R S).restrictScalars S ≤ (Ideal.span _).restrictScalars S\n    rw [← KaehlerDifferential.submodule_span_range_eq_ideal, Ideal.span]\n    conv_rhs => rw [← Submodule.span_span_of_tower S]\n    exact Submodule.subset_span\n\n"}
{"name":"instNonemptyKaehlerDifferential","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\n⊢ Nonempty (KaehlerDifferential R S)","decl":"instance : Nonempty (Ω[S⁄R]) := ⟨0⟩\n\n"}
{"name":"instIsScalarTowerTensorProductKaehlerDifferential","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\n⊢ IsScalarTower S (TensorProduct R S S) (KaehlerDifferential R S)","decl":"instance : IsScalarTower S (S ⊗[R] S) (Ω[S⁄R]) :=\n  Ideal.Cotangent.isScalarTower _\n\n"}
{"name":"KaehlerDifferential.isScalarTower_of_tower","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹⁰ : CommRing R\ninst✝⁹ : CommRing S\ninst✝⁸ : Algebra R S\nR₁ : Type u_2\nR₂ : Type u_3\ninst✝⁷ : CommRing R₁\ninst✝⁶ : CommRing R₂\ninst✝⁵ : Algebra R₁ S\ninst✝⁴ : Algebra R₂ S\ninst✝³ : SMul R₁ R₂\ninst✝² : SMulCommClass R R₁ S\ninst✝¹ : SMulCommClass R R₂ S\ninst✝ : IsScalarTower R₁ R₂ S\n⊢ IsScalarTower R₁ R₂ (KaehlerDifferential R S)","decl":"instance KaehlerDifferential.isScalarTower_of_tower {R₁ R₂ : Type*} [CommRing R₁] [CommRing R₂]\n    [Algebra R₁ S] [Algebra R₂ S] [SMul R₁ R₂]\n    [SMulCommClass R R₁ S] [SMulCommClass R R₂ S] [IsScalarTower R₁ R₂ S] :\n    IsScalarTower R₁ R₂ (Ω[S⁄R]) :=\n  Submodule.Quotient.isScalarTower _ _\n\n"}
{"name":"KaehlerDifferential.isScalarTower'","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\n⊢ IsScalarTower R (TensorProduct R S S) (KaehlerDifferential R S)","decl":"instance KaehlerDifferential.isScalarTower' : IsScalarTower R (S ⊗[R] S) (Ω[S⁄R]) :=\n  Submodule.Quotient.isScalarTower _ _\n\n"}
{"name":"KaehlerDifferential.DLinearMap_apply","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\ns : S\n⊢ Eq ((KaehlerDifferential.DLinearMap R S) s) ((KaehlerDifferential.ideal R S).toCotangent ⟨HSub.hSub (TensorProduct.tmul R 1 s) (TensorProduct.tmul R s 1), ⋯⟩)","decl":"theorem KaehlerDifferential.DLinearMap_apply (s : S) :\n    KaehlerDifferential.DLinearMap R S s =\n      (KaehlerDifferential.ideal R S).toCotangent\n        ⟨1 ⊗ₜ s - s ⊗ₜ 1, KaehlerDifferential.one_smul_sub_smul_one_mem_ideal R s⟩ := rfl\n\n"}
{"name":"KaehlerDifferential.D_apply","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\ns : S\n⊢ Eq ((KaehlerDifferential.D R S) s) ((KaehlerDifferential.ideal R S).toCotangent ⟨HSub.hSub (TensorProduct.tmul R 1 s) (TensorProduct.tmul R s 1), ⋯⟩)","decl":"theorem KaehlerDifferential.D_apply (s : S) :\n    KaehlerDifferential.D R S s =\n      (KaehlerDifferential.ideal R S).toCotangent\n        ⟨1 ⊗ₜ s - s ⊗ₜ 1, KaehlerDifferential.one_smul_sub_smul_one_mem_ideal R s⟩ := rfl\n\n"}
{"name":"KaehlerDifferential.span_range_derivation","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\n⊢ Eq (Submodule.span S (Set.range ⇑(KaehlerDifferential.D R S))) Top.top","decl":"theorem KaehlerDifferential.span_range_derivation :\n    Submodule.span S (Set.range <| KaehlerDifferential.D R S) = ⊤ := by\n  rw [_root_.eq_top_iff]\n  rintro x -\n  obtain ⟨⟨x, hx⟩, rfl⟩ := Ideal.toCotangent_surjective _ x\n  have : x ∈ (KaehlerDifferential.ideal R S).restrictScalars S := hx\n  rw [← KaehlerDifferential.submodule_span_range_eq_ideal] at this\n  suffices ∃ hx, (KaehlerDifferential.ideal R S).toCotangent ⟨x, hx⟩ ∈\n      Submodule.span S (Set.range <| KaehlerDifferential.D R S) by\n    exact this.choose_spec\n  refine Submodule.span_induction ?_ ?_ ?_ ?_ this\n  · rintro _ ⟨x, rfl⟩\n    refine ⟨KaehlerDifferential.one_smul_sub_smul_one_mem_ideal R x, ?_⟩\n    apply Submodule.subset_span\n    exact ⟨x, KaehlerDifferential.DLinearMap_apply R S x⟩\n  · exact ⟨zero_mem _, Submodule.zero_mem _⟩\n  · rintro x y - - ⟨hx₁, hx₂⟩ ⟨hy₁, hy₂⟩; exact ⟨add_mem hx₁ hy₁, Submodule.add_mem _ hx₂ hy₂⟩\n  · rintro r x - ⟨hx₁, hx₂⟩\n    exact ⟨((KaehlerDifferential.ideal R S).restrictScalars S).smul_mem r hx₁,\n      Submodule.smul_mem _ r hx₂⟩\n\n"}
{"name":"KaehlerDifferential.subsingleton_of_surjective","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nh : Function.Surjective ⇑(algebraMap R S)\n⊢ Subsingleton (KaehlerDifferential R S)","decl":"/-- `Ω[S⁄R]` is trivial if `R → S` is surjective.\nAlso see `Algebra.FormallyUnramified.iff_subsingleton_kaehlerDifferential`. -/\nlemma KaehlerDifferential.subsingleton_of_surjective (h : Function.Surjective (algebraMap R S)) :\n    Subsingleton (Ω[S⁄R]) := by\n  suffices (⊤ : Submodule S (Ω[S⁄R])) ≤ ⊥ from\n    (subsingleton_iff_forall_eq 0).mpr fun y ↦ this trivial\n  rw [← KaehlerDifferential.span_range_derivation, Submodule.span_le]\n  rintro _ ⟨x, rfl⟩; obtain ⟨x, rfl⟩ := h x; simp\n\n"}
{"name":"Derivation.liftKaehlerDifferential_apply","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nM : Type u_1\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Module S M\ninst✝ : IsScalarTower R S M\nD : Derivation R S M\nx : Subtype fun x => Membership.mem (KaehlerDifferential.ideal R S) x\n⊢ Eq (D.liftKaehlerDifferential ((KaehlerDifferential.ideal R S).toCotangent x)) (D.tensorProductTo ↑x)","decl":"theorem Derivation.liftKaehlerDifferential_apply (D : Derivation R S M) (x) :\n    D.liftKaehlerDifferential ((KaehlerDifferential.ideal R S).toCotangent x) =\n      D.tensorProductTo x := rfl\n\n"}
{"name":"Derivation.liftKaehlerDifferential_comp","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nM : Type u_1\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Module S M\ninst✝ : IsScalarTower R S M\nD : Derivation R S M\n⊢ Eq (D.liftKaehlerDifferential.compDer (KaehlerDifferential.D R S)) D","decl":"theorem Derivation.liftKaehlerDifferential_comp (D : Derivation R S M) :\n    D.liftKaehlerDifferential.compDer (KaehlerDifferential.D R S) = D := by\n  ext a\n  dsimp [KaehlerDifferential.D_apply]\n  refine (D.liftKaehlerDifferential_apply _).trans ?_\n  rw [Subtype.coe_mk, map_sub, Derivation.tensorProductTo_tmul, Derivation.tensorProductTo_tmul,\n    one_smul, D.map_one_eq_zero, smul_zero, sub_zero]\n\n"}
{"name":"Derivation.liftKaehlerDifferential_comp_D","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nM : Type u_1\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Module S M\ninst✝ : IsScalarTower R S M\nD' : Derivation R S M\nx : S\n⊢ Eq (D'.liftKaehlerDifferential ((KaehlerDifferential.D R S) x)) (D' x)","decl":"@[simp]\ntheorem Derivation.liftKaehlerDifferential_comp_D (D' : Derivation R S M) (x : S) :\n    D'.liftKaehlerDifferential (KaehlerDifferential.D R S x) = D' x :=\n  Derivation.congr_fun D'.liftKaehlerDifferential_comp x\n\n"}
{"name":"Derivation.liftKaehlerDifferential_unique","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nM : Type u_1\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Module S M\ninst✝ : IsScalarTower R S M\nf f' : LinearMap (RingHom.id S) (KaehlerDifferential R S) M\nhf : Eq (f.compDer (KaehlerDifferential.D R S)) (f'.compDer (KaehlerDifferential.D R S))\n⊢ Eq f f'","decl":"@[ext]\ntheorem Derivation.liftKaehlerDifferential_unique (f f' : Ω[S⁄R] →ₗ[S] M)\n    (hf : f.compDer (KaehlerDifferential.D R S) = f'.compDer (KaehlerDifferential.D R S)) :\n    f = f' := by\n  apply LinearMap.ext\n  intro x\n  have : x ∈ Submodule.span S (Set.range <| KaehlerDifferential.D R S) := by\n    rw [KaehlerDifferential.span_range_derivation]; trivial\n  refine Submodule.span_induction ?_ ?_ ?_ ?_ this\n  · rintro _ ⟨x, rfl⟩; exact congr_arg (fun D : Derivation R S M => D x) hf\n  · rw [map_zero, map_zero]\n  · intro x y _ _ hx hy; rw [map_add, map_add, hx, hy]\n  · intro a x _ e; simp [e]\n\n"}
{"name":"Derivation.liftKaehlerDifferential_unique_iff","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nM : Type u_1\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Module S M\ninst✝ : IsScalarTower R S M\nf f' : LinearMap (RingHom.id S) (KaehlerDifferential R S) M\n⊢ Iff (Eq f f') (Eq (f.compDer (KaehlerDifferential.D R S)) (f'.compDer (KaehlerDifferential.D R S)))","decl":"@[ext]\ntheorem Derivation.liftKaehlerDifferential_unique (f f' : Ω[S⁄R] →ₗ[S] M)\n    (hf : f.compDer (KaehlerDifferential.D R S) = f'.compDer (KaehlerDifferential.D R S)) :\n    f = f' := by\n  apply LinearMap.ext\n  intro x\n  have : x ∈ Submodule.span S (Set.range <| KaehlerDifferential.D R S) := by\n    rw [KaehlerDifferential.span_range_derivation]; trivial\n  refine Submodule.span_induction ?_ ?_ ?_ ?_ this\n  · rintro _ ⟨x, rfl⟩; exact congr_arg (fun D : Derivation R S M => D x) hf\n  · rw [map_zero, map_zero]\n  · intro x y _ _ hx hy; rw [map_add, map_add, hx, hy]\n  · intro a x _ e; simp [e]\n\n"}
{"name":"Derivation.liftKaehlerDifferential_D","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\n⊢ Eq (KaehlerDifferential.D R S).liftKaehlerDifferential LinearMap.id","decl":"theorem Derivation.liftKaehlerDifferential_D :\n    (KaehlerDifferential.D R S).liftKaehlerDifferential = LinearMap.id :=\n  Derivation.liftKaehlerDifferential_unique _ _\n    (KaehlerDifferential.D R S).liftKaehlerDifferential_comp\n\n"}
{"name":"KaehlerDifferential.D_tensorProductTo","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nx : Subtype fun x => Membership.mem (KaehlerDifferential.ideal R S) x\n⊢ Eq ((KaehlerDifferential.D R S).tensorProductTo ↑x) ((KaehlerDifferential.ideal R S).toCotangent x)","decl":"theorem KaehlerDifferential.D_tensorProductTo (x : KaehlerDifferential.ideal R S) :\n    (KaehlerDifferential.D R S).tensorProductTo x =\n      (KaehlerDifferential.ideal R S).toCotangent x := by\n  rw [← Derivation.liftKaehlerDifferential_apply, Derivation.liftKaehlerDifferential_D]\n  rfl\n\n"}
{"name":"KaehlerDifferential.tensorProductTo_surjective","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\n⊢ Function.Surjective ⇑(KaehlerDifferential.D R S).tensorProductTo","decl":"theorem KaehlerDifferential.tensorProductTo_surjective :\n    Function.Surjective (KaehlerDifferential.D R S).tensorProductTo := by\n  intro x; obtain ⟨x, rfl⟩ := (KaehlerDifferential.ideal R S).toCotangent_surjective x\n  exact ⟨x, KaehlerDifferential.D_tensorProductTo x⟩\n\n"}
{"name":"KaehlerDifferential.linearMapEquivDerivation_symm_apply","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nM : Type u_1\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Module S M\ninst✝ : IsScalarTower R S M\nD : Derivation R S M\n⊢ Eq ((KaehlerDifferential.linearMapEquivDerivation R S).symm D) D.liftKaehlerDifferential","decl":"/-- The `S`-linear maps from `Ω[S⁄R]` to `M` are (`S`-linearly) equivalent to `R`-derivations\nfrom `S` to `M`. -/\n@[simps! symm_apply apply_apply]\ndef KaehlerDifferential.linearMapEquivDerivation : (Ω[S⁄R] →ₗ[S] M) ≃ₗ[S] Derivation R S M :=\n  { Derivation.llcomp.flip <| KaehlerDifferential.D R S with\n    invFun := Derivation.liftKaehlerDifferential\n    left_inv := fun _ =>\n      Derivation.liftKaehlerDifferential_unique _ _ (Derivation.liftKaehlerDifferential_comp _)\n    right_inv := Derivation.liftKaehlerDifferential_comp }\n\n"}
{"name":"KaehlerDifferential.linearMapEquivDerivation_apply_apply","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nM : Type u_1\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Module S M\ninst✝ : IsScalarTower R S M\nm : LinearMap (RingHom.id S) (KaehlerDifferential R S) M\na✝ : S\n⊢ Eq (((KaehlerDifferential.linearMapEquivDerivation R S) m) a✝) (m ((KaehlerDifferential.D R S) a✝))","decl":"/-- The `S`-linear maps from `Ω[S⁄R]` to `M` are (`S`-linearly) equivalent to `R`-derivations\nfrom `S` to `M`. -/\n@[simps! symm_apply apply_apply]\ndef KaehlerDifferential.linearMapEquivDerivation : (Ω[S⁄R] →ₗ[S] M) ≃ₗ[S] Derivation R S M :=\n  { Derivation.llcomp.flip <| KaehlerDifferential.D R S with\n    invFun := Derivation.liftKaehlerDifferential\n    left_inv := fun _ =>\n      Derivation.liftKaehlerDifferential_unique _ _ (Derivation.liftKaehlerDifferential_comp _)\n    right_inv := Derivation.liftKaehlerDifferential_comp }\n\n"}
{"name":"KaehlerDifferential.End_equiv_aux","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nf : AlgHom R S (HasQuotient.Quotient (TensorProduct R S S) (HPow.hPow (KaehlerDifferential.ideal R S) 2))\n⊢ Iff (Eq ((Ideal.Quotient.mkₐ R (KaehlerDifferential.ideal R S).cotangentIdeal).comp f) (IsScalarTower.toAlgHom R S (HasQuotient.Quotient (HasQuotient.Quotient (TensorProduct R S S) (HPow.hPow (KaehlerDifferential.ideal R S) 2)) (KaehlerDifferential.ideal R S).cotangentIdeal))) (Eq ((Algebra.TensorProduct.lmul' R).kerSquareLift.comp f) (AlgHom.id R S))","decl":"theorem KaehlerDifferential.End_equiv_aux (f : S →ₐ[R] S ⊗ S ⧸ KaehlerDifferential.ideal R S ^ 2) :\n    (Ideal.Quotient.mkₐ R (KaehlerDifferential.ideal R S).cotangentIdeal).comp f =\n        IsScalarTower.toAlgHom R S _ ↔\n      (TensorProduct.lmul' R : S ⊗[R] S →ₐ[R] S).kerSquareLift.comp f = AlgHom.id R S := by\n  rw [AlgHom.ext_iff, AlgHom.ext_iff]\n  apply forall_congr'\n  intro x\n  have e₁ : (TensorProduct.lmul' R : S ⊗[R] S →ₐ[R] S).kerSquareLift (f x) =\n      KaehlerDifferential.quotientCotangentIdealRingEquiv R S\n        (Ideal.Quotient.mk (KaehlerDifferential.ideal R S).cotangentIdeal <| f x) := by\n    generalize f x = y; obtain ⟨y, rfl⟩ := Ideal.Quotient.mk_surjective y; rfl\n  have e₂ :\n    x = KaehlerDifferential.quotientCotangentIdealRingEquiv R S (IsScalarTower.toAlgHom R S _ x) :=\n    (mul_one x).symm\n  constructor\n  · intro e\n    exact (e₁.trans (@RingEquiv.congr_arg _ _ _ _ _ _\n      (KaehlerDifferential.quotientCotangentIdealRingEquiv R S) _ _ e)).trans e₂.symm\n  · intro e; apply (KaehlerDifferential.quotientCotangentIdealRingEquiv R S).injective\n    exact e₁.symm.trans (e.trans e₂)\n\n/- Note: Lean is slow to synthesize these instances (times out).\n  Without them the endEquivDerivation' and endEquivAuxEquiv both have significant timeouts.\n  In Mathlib 3, it was slow but not this slow. -/\n"}
{"name":"isScalarTower_S_right","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\n⊢ IsScalarTower S (HasQuotient.Quotient (TensorProduct R S S) (HPow.hPow (KaehlerDifferential.ideal R S) 2)) (HasQuotient.Quotient (TensorProduct R S S) (HPow.hPow (KaehlerDifferential.ideal R S) 2))","decl":"/-- A shortcut instance to prevent timing out. Hopefully to be removed in the future. -/\n@[nolint defLemma]\nlocal instance isScalarTower_S_right :\n    IsScalarTower S (S ⊗[R] S ⧸ KaehlerDifferential.ideal R S ^ 2)\n      (S ⊗[R] S ⧸ KaehlerDifferential.ideal R S ^ 2) := Ideal.Quotient.isScalarTower_right\n\n"}
{"name":"isScalarTower_R_right","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\n⊢ IsScalarTower R (HasQuotient.Quotient (TensorProduct R S S) (HPow.hPow (KaehlerDifferential.ideal R S) 2)) (HasQuotient.Quotient (TensorProduct R S S) (HPow.hPow (KaehlerDifferential.ideal R S) 2))","decl":"/-- A shortcut instance to prevent timing out. Hopefully to be removed in the future. -/\n@[nolint defLemma]\nlocal instance isScalarTower_R_right :\n    IsScalarTower R (S ⊗[R] S ⧸ KaehlerDifferential.ideal R S ^ 2)\n      (S ⊗[R] S ⧸ KaehlerDifferential.ideal R S ^ 2) := Ideal.Quotient.isScalarTower_right\n\n"}
{"name":"isScalarTower_SS_right","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\n⊢ IsScalarTower (TensorProduct R S S) (HasQuotient.Quotient (TensorProduct R S S) (HPow.hPow (KaehlerDifferential.ideal R S) 2)) (HasQuotient.Quotient (TensorProduct R S S) (HPow.hPow (KaehlerDifferential.ideal R S) 2))","decl":"/-- A shortcut instance to prevent timing out. Hopefully to be removed in the future. -/\n@[nolint defLemma]\nlocal instance isScalarTower_SS_right : IsScalarTower (S ⊗[R] S)\n    (S ⊗[R] S ⧸ KaehlerDifferential.ideal R S ^ 2) (S ⊗[R] S ⧸ KaehlerDifferential.ideal R S ^ 2) :=\n  Ideal.Quotient.isScalarTower_right\n\n"}
{"name":"KaehlerDifferential.ideal_fg","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\ninst✝ : Algebra.EssFiniteType R S\n⊢ (KaehlerDifferential.ideal R S).FG","decl":"theorem KaehlerDifferential.ideal_fg [EssFiniteType R S] :\n    (KaehlerDifferential.ideal R S).FG := by\n  classical\n  use (EssFiniteType.finset R S).image (fun s ↦ (1 : S) ⊗ₜ[R] s - s ⊗ₜ[R] (1 : S))\n  apply le_antisymm\n  · rw [Finset.coe_image, Ideal.span_le]\n    rintro _ ⟨x, _, rfl⟩\n    exact KaehlerDifferential.one_smul_sub_smul_one_mem_ideal R x\n  · rw [← KaehlerDifferential.span_range_eq_ideal, Ideal.span_le]\n    rintro _ ⟨x, rfl⟩\n    let I : Ideal (S ⊗[R] S) := Ideal.span\n      ((EssFiniteType.finset R S).image (fun s ↦ (1 : S) ⊗ₜ[R] s - s ⊗ₜ[R] (1 : S)))\n    show _ - _ ∈ I\n    have : (IsScalarTower.toAlgHom R (S ⊗[R] S) (S ⊗[R] S ⧸ I)).comp TensorProduct.includeRight =\n        (IsScalarTower.toAlgHom R (S ⊗[R] S) (S ⊗[R] S ⧸ I)).comp TensorProduct.includeLeft := by\n      apply EssFiniteType.algHom_ext\n      intro a ha\n      simp only [AlgHom.coe_comp, IsScalarTower.coe_toAlgHom', Ideal.Quotient.algebraMap_eq,\n        Function.comp_apply, TensorProduct.includeLeft_apply, TensorProduct.includeRight_apply,\n        Ideal.Quotient.mk_eq_mk_iff_sub_mem]\n      refine Ideal.subset_span ?_\n      simp only [Finset.coe_image, Set.mem_image, Finset.mem_coe]\n      exact ⟨a, ha, rfl⟩\n    simpa [Ideal.Quotient.mk_eq_mk_iff_sub_mem] using AlgHom.congr_fun this x\n\n"}
{"name":"KaehlerDifferential.finite","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\ninst✝ : Algebra.EssFiniteType R S\n⊢ Module.Finite S (KaehlerDifferential R S)","decl":"instance KaehlerDifferential.finite [EssFiniteType R S] :\n    Module.Finite S (Ω[S⁄R]) := by\n  classical\n  let s := (EssFiniteType.finset R S).image (fun s ↦ D R S s)\n  refine ⟨⟨s, top_le_iff.mp ?_⟩⟩\n  rw [← span_range_derivation, Submodule.span_le]\n  rintro _ ⟨x, rfl⟩\n  have : ∀ x ∈ adjoin R (EssFiniteType.finset R S).toSet,\n      .D _ _ x ∈ Submodule.span S s.toSet := by\n    intro x hx\n    refine adjoin_induction ?_ ?_ ?_ ?_ hx\n    · exact fun x hx ↦ Submodule.subset_span (Finset.mem_image_of_mem _ hx)\n    · simp\n    · exact fun x y _ _ hx hy ↦ (D R S).map_add x y ▸ add_mem hx hy\n    · intro x y _ _ hx hy\n      simp only [Derivation.leibniz]\n      exact add_mem (Submodule.smul_mem _ _ hy) (Submodule.smul_mem _ _ hx)\n  obtain ⟨t, ht, ht', hxt⟩ := (essFiniteType_cond_iff R S (EssFiniteType.finset R S)).mp\n    EssFiniteType.cond.choose_spec x\n  rw [show D R S x =\n    ht'.unit⁻¹ • (D R S (x * t) - x • D R S t) by simp [smul_smul, Units.smul_def]]\n  exact Submodule.smul_mem _ _ (sub_mem (this _ hxt) (Submodule.smul_mem _ _ (this _ ht)))\n\n"}
{"name":"KaehlerDifferential.kerTotal_mkQ_single_add","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nx y z : S\n⊢ Eq ((KaehlerDifferential.kerTotal R S).mkQ (Finsupp.single (HAdd.hAdd x y) z)) (HAdd.hAdd ((KaehlerDifferential.kerTotal R S).mkQ (Finsupp.single x z)) ((KaehlerDifferential.kerTotal R S).mkQ (Finsupp.single y z)))","decl":"theorem KaehlerDifferential.kerTotal_mkQ_single_add (x y z) : (z𝖣x + y) = (z𝖣x) + z𝖣y := by\n  rw [← map_add, eq_comm, ← sub_eq_zero, ← map_sub (Submodule.mkQ (kerTotal R S)),\n    Submodule.mkQ_apply, Submodule.Quotient.mk_eq_zero]\n  simp_rw [← Finsupp.smul_single_one _ z, ← smul_add, ← smul_sub]\n  exact Submodule.smul_mem _ _ (Submodule.subset_span (Or.inl <| Or.inl <| ⟨⟨_, _⟩, rfl⟩))\n\n"}
{"name":"KaehlerDifferential.kerTotal_mkQ_single_mul","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nx y z : S\n⊢ Eq ((KaehlerDifferential.kerTotal R S).mkQ (Finsupp.single (HMul.hMul x y) z)) (HAdd.hAdd ((KaehlerDifferential.kerTotal R S).mkQ (Finsupp.single y (HMul.hMul z x))) ((KaehlerDifferential.kerTotal R S).mkQ (Finsupp.single x (HMul.hMul z y))))","decl":"theorem KaehlerDifferential.kerTotal_mkQ_single_mul (x y z) :\n    (z𝖣x * y) = ((z * x)𝖣y) + (z * y)𝖣x := by\n  rw [← map_add, eq_comm, ← sub_eq_zero, ← map_sub (Submodule.mkQ (kerTotal R S)),\n    Submodule.mkQ_apply, Submodule.Quotient.mk_eq_zero]\n  simp_rw [← Finsupp.smul_single_one _ z, ← @smul_eq_mul _ _ z, ← Finsupp.smul_single, ← smul_add,\n    ← smul_sub]\n  exact Submodule.smul_mem _ _ (Submodule.subset_span (Or.inl <| Or.inr <| ⟨⟨_, _⟩, rfl⟩))\n\n"}
{"name":"KaehlerDifferential.kerTotal_mkQ_single_algebraMap","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nx : R\ny : S\n⊢ Eq ((KaehlerDifferential.kerTotal R S).mkQ (Finsupp.single ((algebraMap R S) x) y)) 0","decl":"theorem KaehlerDifferential.kerTotal_mkQ_single_algebraMap (x y) : (y𝖣algebraMap R S x) = 0 := by\n  rw [Submodule.mkQ_apply, Submodule.Quotient.mk_eq_zero, ← Finsupp.smul_single_one _ y]\n  exact Submodule.smul_mem _ _ (Submodule.subset_span (Or.inr <| ⟨_, rfl⟩))\n\n"}
{"name":"KaehlerDifferential.kerTotal_mkQ_single_algebraMap_one","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nx : S\n⊢ Eq ((KaehlerDifferential.kerTotal R S).mkQ (Finsupp.single 1 x)) 0","decl":"theorem KaehlerDifferential.kerTotal_mkQ_single_algebraMap_one (x) : (x𝖣1) = 0 := by\n  rw [← (algebraMap R S).map_one, KaehlerDifferential.kerTotal_mkQ_single_algebraMap]\n\n"}
{"name":"KaehlerDifferential.kerTotal_mkQ_single_smul","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nr : R\nx y : S\n⊢ Eq ((KaehlerDifferential.kerTotal R S).mkQ (Finsupp.single (HSMul.hSMul r x) y)) (HSMul.hSMul r ((KaehlerDifferential.kerTotal R S).mkQ (Finsupp.single x y)))","decl":"theorem KaehlerDifferential.kerTotal_mkQ_single_smul (r : R) (x y) : (y𝖣r • x) = r • y𝖣x := by\n  letI : SMulZeroClass R S := inferInstance\n  rw [Algebra.smul_def, KaehlerDifferential.kerTotal_mkQ_single_mul,\n    KaehlerDifferential.kerTotal_mkQ_single_algebraMap, add_zero, ← LinearMap.map_smul_of_tower,\n    Finsupp.smul_single, mul_comm, Algebra.smul_def]\n\n"}
{"name":"KaehlerDifferential.derivationQuotKerTotal_apply","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nx : S\n⊢ Eq ((KaehlerDifferential.derivationQuotKerTotal R S) x) ((KaehlerDifferential.kerTotal R S).mkQ (Finsupp.single x 1))","decl":"theorem KaehlerDifferential.derivationQuotKerTotal_apply (x) :\n    KaehlerDifferential.derivationQuotKerTotal R S x = 1𝖣x :=\n  rfl\n\n"}
{"name":"KaehlerDifferential.derivationQuotKerTotal_lift_comp_linearCombination","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\n⊢ Eq ((KaehlerDifferential.derivationQuotKerTotal R S).liftKaehlerDifferential.comp (Finsupp.linearCombination S ⇑(KaehlerDifferential.D R S))) (KaehlerDifferential.kerTotal R S).mkQ","decl":"theorem KaehlerDifferential.derivationQuotKerTotal_lift_comp_linearCombination :\n    (KaehlerDifferential.derivationQuotKerTotal R S).liftKaehlerDifferential.comp\n        (Finsupp.linearCombination S (KaehlerDifferential.D R S)) =\n      Submodule.mkQ _ := by\n  apply Finsupp.lhom_ext\n  intro a b\n  conv_rhs => rw [← Finsupp.smul_single_one a b, LinearMap.map_smul]\n  simp [KaehlerDifferential.derivationQuotKerTotal_apply]\n\n"}
{"name":"KaehlerDifferential.derivationQuotKerTotal_lift_comp_total","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\n⊢ Eq ((KaehlerDifferential.derivationQuotKerTotal R S).liftKaehlerDifferential.comp (Finsupp.linearCombination S ⇑(KaehlerDifferential.D R S))) (KaehlerDifferential.kerTotal R S).mkQ","decl":"@[deprecated (since := \"2024-08-29\")] alias\n  KaehlerDifferential.derivationQuotKerTotal_lift_comp_total :=\n  KaehlerDifferential.derivationQuotKerTotal_lift_comp_linearCombination\n\n"}
{"name":"KaehlerDifferential.kerTotal_eq","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\n⊢ Eq (LinearMap.ker (Finsupp.linearCombination S ⇑(KaehlerDifferential.D R S))) (KaehlerDifferential.kerTotal R S)","decl":"theorem KaehlerDifferential.kerTotal_eq :\n    LinearMap.ker (Finsupp.linearCombination S (KaehlerDifferential.D R S)) =\n      KaehlerDifferential.kerTotal R S := by\n  apply le_antisymm\n  · conv_rhs => rw [← (KaehlerDifferential.kerTotal R S).ker_mkQ]\n    rw [← KaehlerDifferential.derivationQuotKerTotal_lift_comp_linearCombination]\n    exact LinearMap.ker_le_ker_comp _ _\n  · rw [KaehlerDifferential.kerTotal, Submodule.span_le]\n    rintro _ ((⟨⟨x, y⟩, rfl⟩ | ⟨⟨x, y⟩, rfl⟩) | ⟨x, rfl⟩) <;> dsimp <;> simp [LinearMap.mem_ker]\n\n"}
{"name":"KaehlerDifferential.linearCombination_surjective","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\n⊢ Function.Surjective ⇑(Finsupp.linearCombination S ⇑(KaehlerDifferential.D R S))","decl":"theorem KaehlerDifferential.linearCombination_surjective :\n    Function.Surjective (Finsupp.linearCombination S (KaehlerDifferential.D R S)) := by\n  rw [← LinearMap.range_eq_top, range_linearCombination, span_range_derivation]\n\n"}
{"name":"KaehlerDifferential.total_surjective","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\n⊢ Function.Surjective ⇑(Finsupp.linearCombination S ⇑(KaehlerDifferential.D R S))","decl":"@[deprecated (since := \"2024-08-29\")] alias KaehlerDifferential.total_surjective :=\n  KaehlerDifferential.linearCombination_surjective\n\n"}
{"name":"KaehlerDifferential.quotKerTotalEquiv_apply","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\na✝ : HasQuotient.Quotient (Finsupp S S) (KaehlerDifferential.kerTotal R S).toAddSubgroup\n⊢ Eq ((KaehlerDifferential.quotKerTotalEquiv R S) a✝) ((QuotientAddGroup.lift (KaehlerDifferential.kerTotal R S).toAddSubgroup (Finsupp.linearCombination S ⇑(KaehlerDifferential.D R S)).toAddMonoidHom ⋯) a✝)","decl":"/-- `Ω[S⁄R]` is isomorphic to `S` copies of `S` with kernel `KaehlerDifferential.kerTotal`. -/\n@[simps!]\nnoncomputable def KaehlerDifferential.quotKerTotalEquiv :\n    ((S →₀ S) ⧸ KaehlerDifferential.kerTotal R S) ≃ₗ[S] Ω[S⁄R] :=\n  { (KaehlerDifferential.kerTotal R S).liftQ\n      (Finsupp.linearCombination S (KaehlerDifferential.D R S))\n      (KaehlerDifferential.kerTotal_eq R S).ge with\n    invFun := (KaehlerDifferential.derivationQuotKerTotal R S).liftKaehlerDifferential\n    left_inv := by\n      intro x\n      obtain ⟨x, rfl⟩ := Submodule.mkQ_surjective _ x\n      exact\n        LinearMap.congr_fun\n          (KaehlerDifferential.derivationQuotKerTotal_lift_comp_linearCombination R S :) x\n    right_inv := by\n      intro x\n      obtain ⟨x, rfl⟩ := KaehlerDifferential.linearCombination_surjective R S x\n      have := LinearMap.congr_fun\n        (KaehlerDifferential.derivationQuotKerTotal_lift_comp_linearCombination R S) x\n      rw [LinearMap.comp_apply] at this\n      rw [this]\n      rfl }\n\n"}
{"name":"KaehlerDifferential.quotKerTotalEquiv_symm_apply","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\na : KaehlerDifferential R S\n⊢ Eq ((KaehlerDifferential.quotKerTotalEquiv R S).symm a) ((KaehlerDifferential.derivationQuotKerTotal R S).liftKaehlerDifferential a)","decl":"/-- `Ω[S⁄R]` is isomorphic to `S` copies of `S` with kernel `KaehlerDifferential.kerTotal`. -/\n@[simps!]\nnoncomputable def KaehlerDifferential.quotKerTotalEquiv :\n    ((S →₀ S) ⧸ KaehlerDifferential.kerTotal R S) ≃ₗ[S] Ω[S⁄R] :=\n  { (KaehlerDifferential.kerTotal R S).liftQ\n      (Finsupp.linearCombination S (KaehlerDifferential.D R S))\n      (KaehlerDifferential.kerTotal_eq R S).ge with\n    invFun := (KaehlerDifferential.derivationQuotKerTotal R S).liftKaehlerDifferential\n    left_inv := by\n      intro x\n      obtain ⟨x, rfl⟩ := Submodule.mkQ_surjective _ x\n      exact\n        LinearMap.congr_fun\n          (KaehlerDifferential.derivationQuotKerTotal_lift_comp_linearCombination R S :) x\n    right_inv := by\n      intro x\n      obtain ⟨x, rfl⟩ := KaehlerDifferential.linearCombination_surjective R S x\n      have := LinearMap.congr_fun\n        (KaehlerDifferential.derivationQuotKerTotal_lift_comp_linearCombination R S) x\n      rw [LinearMap.comp_apply] at this\n      rw [this]\n      rfl }\n\n"}
{"name":"KaehlerDifferential.quotKerTotalEquiv_symm_comp_D","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\n⊢ Eq ((↑(KaehlerDifferential.quotKerTotalEquiv R S).symm).compDer (KaehlerDifferential.D R S)) (KaehlerDifferential.derivationQuotKerTotal R S)","decl":"theorem KaehlerDifferential.quotKerTotalEquiv_symm_comp_D :\n    (KaehlerDifferential.quotKerTotalEquiv R S).symm.toLinearMap.compDer\n        (KaehlerDifferential.D R S) =\n      KaehlerDifferential.derivationQuotKerTotal R S := by\n  convert (KaehlerDifferential.derivationQuotKerTotal R S).liftKaehlerDifferential_comp\n\n"}
{"name":"KaehlerDifferential.kerTotal_map","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹⁰ : CommRing R\ninst✝⁹ : CommRing S\ninst✝⁸ : Algebra R S\nA : Type u_2\nB : Type u_3\ninst✝⁷ : CommRing A\ninst✝⁶ : CommRing B\ninst✝⁵ : Algebra R A\ninst✝⁴ : Algebra A B\ninst✝³ : Algebra S B\ninst✝² : Algebra R B\ninst✝¹ : IsScalarTower R A B\ninst✝ : IsScalarTower R S B\nh : Function.Surjective ⇑(algebraMap A B)\n⊢ Eq (Max.max (Submodule.map ((Finsupp.mapRange.linearMap (Algebra.linearMap A B)).comp (Finsupp.lmapDomain A A ⇑(algebraMap A B))) (KaehlerDifferential.kerTotal R A)) (Submodule.span A (Set.range fun x => Finsupp.single ((algebraMap S B) x) 1))) (Submodule.restrictScalars A (KaehlerDifferential.kerTotal S B))","decl":"/--\nGiven the commutative diagram\n```\nA --→ B\n↑     ↑\n|     |\nR --→ S\n```\nThe kernel of the presentation `⊕ₓ B dx ↠ Ω_{B/S}` is spanned by the image of the\nkernel of `⊕ₓ A dx ↠ Ω_{A/R}` and all `ds` with `s : S`.\nSee `kerTotal_map'` for the special case where `R = S`.\n-/\ntheorem KaehlerDifferential.kerTotal_map [Algebra R B] [IsScalarTower R A B] [IsScalarTower R S B]\n    (h : Function.Surjective (algebraMap A B)) :\n    (KaehlerDifferential.kerTotal R A).map finsupp_map ⊔\n        Submodule.span A (Set.range fun x : S => .single (algebraMap S B x) (1 : B)) =\n      (KaehlerDifferential.kerTotal S B).restrictScalars _ := by\n  rw [KaehlerDifferential.kerTotal, Submodule.map_span, KaehlerDifferential.kerTotal,\n    Submodule.restrictScalars_span _ _ h]\n  simp_rw [Set.image_union, Submodule.span_union, ← Set.image_univ, Set.image_image, Set.image_univ,\n    map_sub, map_add]\n  simp only [LinearMap.comp_apply, Finsupp.lmapDomain_apply, Finsupp.mapDomain_single,\n    Finsupp.mapRange.linearMap_apply, Finsupp.mapRange_single, Algebra.linearMap_apply,\n    map_one, map_add, map_mul]\n  simp_rw [sup_assoc, ← (h.prodMap h).range_comp]\n  congr!\n  -- Porting note: new\n  simp_rw [← IsScalarTower.algebraMap_apply R A B]\n  rw [sup_eq_right]\n  apply Submodule.span_mono\n  simp_rw [IsScalarTower.algebraMap_apply R S B]\n  exact Set.range_comp_subset_range (algebraMap R S)\n    fun x => Finsupp.single (algebraMap S B x) (1 : B)\n\n"}
{"name":"KaehlerDifferential.kerTotal_map'","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\ninst✝⁶ : CommRing R\nA : Type u_2\nB : Type u_3\ninst✝⁵ : CommRing A\ninst✝⁴ : CommRing B\ninst✝³ : Algebra R A\ninst✝² : Algebra A B\ninst✝¹ : Algebra R B\ninst✝ : IsScalarTower R A B\nh : Function.Surjective ⇑(algebraMap A B)\n⊢ Eq (Submodule.map ((Finsupp.mapRange.linearMap (Algebra.linearMap A B)).comp (Finsupp.lmapDomain A A ⇑(algebraMap A B))) (Max.max (KaehlerDifferential.kerTotal R A) (Submodule.span A (Set.range fun x => Finsupp.single ((algebraMap R A) x) 1)))) (Submodule.restrictScalars A (KaehlerDifferential.kerTotal R B))","decl":"/--\nThis is a special case of `kerTotal_map` where `R = S`.\nThe kernel of the presentation `⊕ₓ B dx ↠ Ω_{B/R}` is spanned by the image of the\nkernel of `⊕ₓ A dx ↠ Ω_{A/R}` and all `da` with `a : A`.\n-/\ntheorem KaehlerDifferential.kerTotal_map' [Algebra R B]\n    [IsScalarTower R A B] (h : Function.Surjective (algebraMap A B)) :\n    (KaehlerDifferential.kerTotal R A ⊔\n      Submodule.span A (Set.range fun x ↦ .single (algebraMap R A x) 1)).map finsupp_map =\n      (KaehlerDifferential.kerTotal R B).restrictScalars _ := by\n  rw [Submodule.map_sup, ← kerTotal_map R R A B h, Submodule.map_span, ← Set.range_comp]\n  congr\n  refine congr_arg Set.range ?_\n  ext; simp [IsScalarTower.algebraMap_eq R A B]\n\n"}
{"name":"KaehlerDifferential.map_compDer","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : CommRing S\ninst✝⁹ : Algebra R S\nA : Type u_2\nB : Type u_3\ninst✝⁸ : CommRing A\ninst✝⁷ : CommRing B\ninst✝⁶ : Algebra R A\ninst✝⁵ : Algebra A B\ninst✝⁴ : Algebra S B\ninst✝³ : Algebra R B\ninst✝² : IsScalarTower R A B\ninst✝¹ : IsScalarTower R S B\ninst✝ : SMulCommClass S A B\n⊢ Eq ((KaehlerDifferential.map R S A B).compDer (KaehlerDifferential.D R A)) (Derivation.compAlgebraMap A (Derivation.restrictScalars R (KaehlerDifferential.D S B)))","decl":"theorem KaehlerDifferential.map_compDer :\n    (KaehlerDifferential.map R S A B).compDer (KaehlerDifferential.D R A) =\n      ((KaehlerDifferential.D S B).restrictScalars R).compAlgebraMap A :=\n  Derivation.liftKaehlerDifferential_comp _\n\n"}
{"name":"KaehlerDifferential.map_D","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : CommRing S\ninst✝⁹ : Algebra R S\nA : Type u_2\nB : Type u_3\ninst✝⁸ : CommRing A\ninst✝⁷ : CommRing B\ninst✝⁶ : Algebra R A\ninst✝⁵ : Algebra A B\ninst✝⁴ : Algebra S B\ninst✝³ : Algebra R B\ninst✝² : IsScalarTower R A B\ninst✝¹ : IsScalarTower R S B\ninst✝ : SMulCommClass S A B\nx : A\n⊢ Eq ((KaehlerDifferential.map R S A B) ((KaehlerDifferential.D R A) x)) ((KaehlerDifferential.D S B) ((algebraMap A B) x))","decl":"@[simp]\ntheorem KaehlerDifferential.map_D (x : A) :\n    KaehlerDifferential.map R S A B (KaehlerDifferential.D R A x) =\n      KaehlerDifferential.D S B (algebraMap A B x) :=\n  Derivation.congr_fun (KaehlerDifferential.map_compDer R S A B) x\n\n"}
{"name":"KaehlerDifferential.ker_map","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : CommRing S\ninst✝⁹ : Algebra R S\nA : Type u_2\nB : Type u_3\ninst✝⁸ : CommRing A\ninst✝⁷ : CommRing B\ninst✝⁶ : Algebra R A\ninst✝⁵ : Algebra A B\ninst✝⁴ : Algebra S B\ninst✝³ : Algebra R B\ninst✝² : IsScalarTower R A B\ninst✝¹ : IsScalarTower R S B\ninst✝ : SMulCommClass S A B\n⊢ Eq (LinearMap.ker (KaehlerDifferential.map R S A B)) (Submodule.map (Finsupp.linearCombination A ⇑(KaehlerDifferential.D R A)) (Submodule.comap ((Finsupp.mapRange.linearMap (Algebra.linearMap A B)).comp (Finsupp.lmapDomain A A ⇑(algebraMap A B))) (Submodule.restrictScalars A (KaehlerDifferential.kerTotal S B))))","decl":"theorem KaehlerDifferential.ker_map :\n    LinearMap.ker (KaehlerDifferential.map R S A B) =\n      (((kerTotal S B).restrictScalars A).comap finsupp_map).map\n        (Finsupp.linearCombination (M := Ω[A⁄R]) A (D R A)) := by\n  rw [← Submodule.map_comap_eq_of_surjective (linearCombination_surjective R A) (LinearMap.ker _)]\n  congr 1\n  ext x\n  simp only [Submodule.mem_comap, LinearMap.mem_ker, Finsupp.apply_linearCombination, ← kerTotal_eq,\n    Submodule.restrictScalars_mem]\n  simp only [linearCombination_apply, Function.comp_apply, LinearMap.coe_comp, lmapDomain_apply,\n    Finsupp.mapRange.linearMap_apply]\n  rw [Finsupp.sum_mapRange_index, Finsupp.sum_mapDomain_index]\n  · simp [ofId]\n  · simp\n  · simp [add_smul]\n  · simp\n\n"}
{"name":"KaehlerDifferential.ker_map_of_surjective","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\ninst✝⁶ : CommRing R\nA : Type u_2\nB : Type u_3\ninst✝⁵ : CommRing A\ninst✝⁴ : CommRing B\ninst✝³ : Algebra R A\ninst✝² : Algebra A B\ninst✝¹ : Algebra R B\ninst✝ : IsScalarTower R A B\nh : Function.Surjective ⇑(algebraMap A B)\n⊢ Eq (LinearMap.ker (KaehlerDifferential.map R R A B)) (Submodule.map (Finsupp.linearCombination A ⇑(KaehlerDifferential.D R A)) (LinearMap.ker ((Finsupp.mapRange.linearMap (Algebra.linearMap A B)).comp (Finsupp.lmapDomain A A ⇑(algebraMap A B)))))","decl":"lemma KaehlerDifferential.ker_map_of_surjective (h : Function.Surjective (algebraMap A B)) :\n    LinearMap.ker (map R R A B) =\n      (LinearMap.ker finsupp_map).map (Finsupp.linearCombination A (D R A)) := by\n  rw [ker_map, ← kerTotal_map' R A B h, Submodule.comap_map_eq, Submodule.map_sup,\n    Submodule.map_sup, ← kerTotal_eq, ← Submodule.comap_bot,\n    Submodule.map_comap_eq_of_surjective (linearCombination_surjective _ _),\n    bot_sup_eq, Submodule.map_span, ← Set.range_comp]\n  convert bot_sup_eq _\n  rw [Submodule.span_eq_bot]; simp\n\n"}
{"name":"KaehlerDifferential.map_surjective_of_surjective","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : CommRing S\ninst✝⁹ : Algebra R S\nA : Type u_2\nB : Type u_3\ninst✝⁸ : CommRing A\ninst✝⁷ : CommRing B\ninst✝⁶ : Algebra R A\ninst✝⁵ : Algebra A B\ninst✝⁴ : Algebra S B\ninst✝³ : Algebra R B\ninst✝² : IsScalarTower R A B\ninst✝¹ : IsScalarTower R S B\ninst✝ : SMulCommClass S A B\nh : Function.Surjective ⇑(algebraMap A B)\n⊢ Function.Surjective ⇑(KaehlerDifferential.map R S A B)","decl":"theorem KaehlerDifferential.map_surjective_of_surjective\n    (h : Function.Surjective (algebraMap A B)) :\n    Function.Surjective (KaehlerDifferential.map R S A B) := by\n  rw [← LinearMap.range_eq_top, _root_.eq_top_iff,\n    ← @Submodule.restrictScalars_top A B, ← span_range_derivation,\n    Submodule.restrictScalars_span _ _ h, Submodule.span_le]\n  rintro _ ⟨x, rfl⟩\n  obtain ⟨y, rfl⟩ := h x\n  rw [← KaehlerDifferential.map_D R S A B]\n  exact ⟨_, rfl⟩\n\n"}
{"name":"KaehlerDifferential.map_surjective","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nB : Type u_3\ninst✝³ : CommRing B\ninst✝² : Algebra S B\ninst✝¹ : Algebra R B\ninst✝ : IsScalarTower R S B\n⊢ Function.Surjective ⇑(KaehlerDifferential.map R S B B)","decl":"theorem KaehlerDifferential.map_surjective :\n    Function.Surjective (KaehlerDifferential.map R S B B) :=\n  map_surjective_of_surjective R S B B Function.surjective_id\n\n"}
{"name":"KaehlerDifferential.mapBaseChange_tmul","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\ninst✝⁶ : CommRing R\nA : Type u_2\nB : Type u_3\ninst✝⁵ : CommRing A\ninst✝⁴ : CommRing B\ninst✝³ : Algebra R A\ninst✝² : Algebra A B\ninst✝¹ : Algebra R B\ninst✝ : IsScalarTower R A B\nx : B\ny : KaehlerDifferential R A\n⊢ Eq ((KaehlerDifferential.mapBaseChange R A B) (TensorProduct.tmul A x y)) (HSMul.hSMul x ((KaehlerDifferential.map R R A B) y))","decl":"@[simp]\ntheorem KaehlerDifferential.mapBaseChange_tmul (x : B) (y : Ω[A⁄R]) :\n    KaehlerDifferential.mapBaseChange R A B (x ⊗ₜ y) = x • KaehlerDifferential.map R R A B y := by\n  conv_lhs => rw [← mul_one x, ← smul_eq_mul, ← TensorProduct.smul_tmul', LinearMap.map_smul]\n  congr 1\n  exact IsBaseChange.lift_eq _ _ _\n\n"}
{"name":"KaehlerDifferential.range_mapBaseChange","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\ninst✝⁶ : CommRing R\nA : Type u_2\nB : Type u_3\ninst✝⁵ : CommRing A\ninst✝⁴ : CommRing B\ninst✝³ : Algebra R A\ninst✝² : Algebra A B\ninst✝¹ : Algebra R B\ninst✝ : IsScalarTower R A B\n⊢ Eq (LinearMap.range (KaehlerDifferential.mapBaseChange R A B)) (LinearMap.ker (KaehlerDifferential.map R A B B))","decl":"lemma KaehlerDifferential.range_mapBaseChange :\n    LinearMap.range (mapBaseChange R A B) = LinearMap.ker (map R A B B) := by\n  apply le_antisymm\n  · rintro _ ⟨x, rfl⟩\n    induction' x with r s\n    · simp\n    · obtain ⟨x, rfl⟩ := linearCombination_surjective _ _ s\n      simp only [mapBaseChange_tmul, LinearMap.mem_ker, map_smul]\n      induction x using Finsupp.induction_linear\n      · simp\n      · simp [smul_add, *]\n      · simp\n    · rw [map_add]; exact add_mem ‹_› ‹_›\n  · convert_to (kerTotal A B).map (Finsupp.linearCombination B (D R B)) ≤ _\n    · rw [KaehlerDifferential.ker_map]\n      congr 1\n      convert Submodule.comap_id _\n      · ext; simp\n    rw [Submodule.map_le_iff_le_comap, kerTotal, Submodule.span_le]\n    rintro f ((⟨⟨x, y⟩, rfl⟩|⟨⟨x, y⟩, rfl⟩)|⟨x, rfl⟩)\n    · use 0; simp\n    · use 0; simp\n    · use 1 ⊗ₜ D _ _ x; simp\n\n"}
{"name":"KaehlerDifferential.exact_mapBaseChange_map","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\ninst✝⁶ : CommRing R\nA : Type u_2\nB : Type u_3\ninst✝⁵ : CommRing A\ninst✝⁴ : CommRing B\ninst✝³ : Algebra R A\ninst✝² : Algebra A B\ninst✝¹ : Algebra R B\ninst✝ : IsScalarTower R A B\n⊢ Function.Exact ⇑(KaehlerDifferential.mapBaseChange R A B) ⇑(KaehlerDifferential.map R A B B)","decl":"/-- The sequence `B ⊗[A] Ω[A⁄R] → Ω[B⁄R] → Ω[B⁄A] → 0` is exact.\nAlso see `KaehlerDifferential.map_surjective`. -/\nlemma KaehlerDifferential.exact_mapBaseChange_map :\n    Function.Exact (mapBaseChange R A B) (map R A B B) :=\n  SetLike.ext_iff.mp (range_mapBaseChange R A B).symm\n\n"}
{"name":"KaehlerDifferential.kerToTensor_apply","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\ninst✝⁴ : CommRing R\nA : Type u_2\nB : Type u_3\ninst✝³ : CommRing A\ninst✝² : CommRing B\ninst✝¹ : Algebra R A\ninst✝ : Algebra A B\nx : Subtype fun x => Membership.mem (RingHom.ker (algebraMap A B)) x\n⊢ Eq ((KaehlerDifferential.kerToTensor R A B) x) (TensorProduct.tmul A 1 ((KaehlerDifferential.D R A) ↑x))","decl":"/-- The map `I → B ⊗[A] Ω[A⁄R]` where `I = ker(A → B)`. -/\n@[simps]\nnoncomputable\ndef KaehlerDifferential.kerToTensor :\n    RingHom.ker (algebraMap A B) →ₗ[A] B ⊗[A] Ω[A⁄R] where\n  toFun x := 1 ⊗ₜ D R A x\n  map_add' x y := by simp only [Submodule.coe_add, map_add, TensorProduct.tmul_add]\n  map_smul' r x := by simp only [SetLike.val_smul, smul_eq_mul, Derivation.leibniz,\n    TensorProduct.tmul_add, TensorProduct.tmul_smul, TensorProduct.smul_tmul', ←\n    algebraMap_eq_smul_one, RingHom.mem_ker.mp x.prop, TensorProduct.zero_tmul, add_zero,\n    RingHom.id_apply]\n\n"}
{"name":"KaehlerDifferential.kerCotangentToTensor_toCotangent","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\ninst✝⁴ : CommRing R\nA : Type u_2\nB : Type u_3\ninst✝³ : CommRing A\ninst✝² : CommRing B\ninst✝¹ : Algebra R A\ninst✝ : Algebra A B\nx : Subtype fun x => Membership.mem (RingHom.ker (algebraMap A B)) x\n⊢ Eq ((KaehlerDifferential.kerCotangentToTensor R A B) ((RingHom.ker (algebraMap A B)).toCotangent x)) (TensorProduct.tmul A 1 ((KaehlerDifferential.D R A) ↑x))","decl":"@[simp]\nlemma KaehlerDifferential.kerCotangentToTensor_toCotangent (x) :\n    kerCotangentToTensor R A B (Ideal.toCotangent _ x) = 1 ⊗ₜ D _ _ x.1 := rfl\n\n"}
{"name":"KaehlerDifferential.range_kerCotangentToTensor","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\ninst✝⁶ : CommRing R\nA : Type u_2\nB : Type u_3\ninst✝⁵ : CommRing A\ninst✝⁴ : CommRing B\ninst✝³ : Algebra R A\ninst✝² : Algebra A B\ninst✝¹ : Algebra R B\ninst✝ : IsScalarTower R A B\nh : Function.Surjective ⇑(algebraMap A B)\n⊢ Eq (LinearMap.range (KaehlerDifferential.kerCotangentToTensor R A B)) (Submodule.restrictScalars A (LinearMap.ker (KaehlerDifferential.mapBaseChange R A B)))","decl":"theorem KaehlerDifferential.range_kerCotangentToTensor\n    (h : Function.Surjective (algebraMap A B)) :\n    LinearMap.range (kerCotangentToTensor R A B) =\n      (LinearMap.ker (KaehlerDifferential.mapBaseChange R A B)).restrictScalars A := by\n  classical\n  ext x\n  constructor\n  · rintro ⟨x, rfl⟩\n    obtain ⟨x, rfl⟩ := Ideal.toCotangent_surjective _ x\n    simp only [kerCotangentToTensor_toCotangent, Submodule.restrictScalars_mem, LinearMap.mem_ker,\n      mapBaseChange_tmul, map_D, RingHom.mem_ker.mp x.2, map_zero, smul_zero]\n  · intro hx\n    obtain ⟨x, rfl⟩ := LinearMap.rTensor_surjective (Ω[A⁄R]) (g := Algebra.linearMap A B) h x\n    obtain ⟨x, rfl⟩ := (TensorProduct.lid _ _).symm.surjective x\n    replace hx : x ∈ LinearMap.ker (KaehlerDifferential.map R R A B) := by simpa using hx\n    rw [KaehlerDifferential.ker_map_of_surjective R A B h] at hx\n    obtain ⟨x, hx, rfl⟩ := hx\n    simp only [TensorProduct.lid_symm_apply, LinearMap.rTensor_tmul,\n      Algebra.linearMap_apply, map_one]\n    rw [← Finsupp.sum_single x, Finsupp.sum, ← Finset.sum_fiberwise_of_maps_to\n      (fun _ ↦ Finset.mem_image_of_mem (algebraMap A B))]\n    simp only [Function.comp_apply, map_sum (s := x.support.image (algebraMap A B)),\n      TensorProduct.tmul_sum]\n    apply sum_mem\n    intro c _\n    simp only [Finset.filter_congr_decidable, TensorProduct.lid_symm_apply, LinearMap.rTensor_tmul,\n      AlgHom.toLinearMap_apply, map_one, LinearMap.mem_range]\n    simp only [map_sum, Finsupp.linearCombination_single]\n    have : (x.support.filter (algebraMap A B · = c)).sum x ∈ RingHom.ker (algebraMap A B) := by\n      simpa [Finsupp.mapDomain, Finsupp.sum, Finsupp.finset_sum_apply, RingHom.mem_ker,\n        Finsupp.single_apply, ← Finset.sum_filter] using DFunLike.congr_fun hx c\n    obtain ⟨a, ha⟩ := h c\n    use (x.support.filter (algebraMap A B · = c)).attach.sum\n        fun i ↦ x i • Ideal.toCotangent _ ⟨i - a, ?_⟩; swap\n    · have : x i ≠ 0 ∧ algebraMap A B i = c := by\n        convert i.prop\n        simp_rw [Finset.mem_filter, Finsupp.mem_support_iff]\n      simp [RingHom.mem_ker, ha, this.2]\n    · simp only [map_sum, LinearMapClass.map_smul, kerCotangentToTensor_toCotangent, map_sub]\n      simp_rw [← TensorProduct.tmul_smul]\n      -- was `simp [kerCotangentToTensor_toCotangent, RingHom.mem_ker.mp x.2]` and very slow\n      -- (https://github.com/leanprover-community/mathlib4/issues/19751)\n      simp only [smul_sub, TensorProduct.tmul_sub, Finset.sum_sub_distrib, ← TensorProduct.tmul_sum,\n        ← Finset.sum_smul, Finset.sum_attach, sub_eq_self,\n        Finset.sum_attach (f := fun i ↦ x i • KaehlerDifferential.D R A i)]\n      rw [← TensorProduct.smul_tmul, ← Algebra.algebraMap_eq_smul_one, RingHom.mem_ker.mp this,\n        TensorProduct.zero_tmul]\n\n"}
{"name":"KaehlerDifferential.exact_kerCotangentToTensor_mapBaseChange","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\ninst✝⁶ : CommRing R\nA : Type u_2\nB : Type u_3\ninst✝⁵ : CommRing A\ninst✝⁴ : CommRing B\ninst✝³ : Algebra R A\ninst✝² : Algebra A B\ninst✝¹ : Algebra R B\ninst✝ : IsScalarTower R A B\nh : Function.Surjective ⇑(algebraMap A B)\n⊢ Function.Exact ⇑(KaehlerDifferential.kerCotangentToTensor R A B) ⇑(KaehlerDifferential.mapBaseChange R A B)","decl":"theorem KaehlerDifferential.exact_kerCotangentToTensor_mapBaseChange\n    (h : Function.Surjective (algebraMap A B)) :\n    Function.Exact (kerCotangentToTensor R A B) (KaehlerDifferential.mapBaseChange R A B) :=\n  SetLike.ext_iff.mp (range_kerCotangentToTensor R A B h).symm\n\n"}
{"name":"KaehlerDifferential.mapBaseChange_surjective","module":"Mathlib.RingTheory.Kaehler.Basic","initialProofState":"R : Type u\ninst✝⁶ : CommRing R\nA : Type u_2\nB : Type u_3\ninst✝⁵ : CommRing A\ninst✝⁴ : CommRing B\ninst✝³ : Algebra R A\ninst✝² : Algebra A B\ninst✝¹ : Algebra R B\ninst✝ : IsScalarTower R A B\nh : Function.Surjective ⇑(algebraMap A B)\n⊢ Function.Surjective ⇑(KaehlerDifferential.mapBaseChange R A B)","decl":"lemma KaehlerDifferential.mapBaseChange_surjective\n    (h : Function.Surjective (algebraMap A B)) :\n    Function.Surjective (KaehlerDifferential.mapBaseChange R A B) := by\n  have := subsingleton_of_surjective A B h\n  rw [← LinearMap.range_eq_top, range_mapBaseChange, ← top_le_iff]\n  exact fun x _ ↦ Subsingleton.elim _ _\n\n"}
