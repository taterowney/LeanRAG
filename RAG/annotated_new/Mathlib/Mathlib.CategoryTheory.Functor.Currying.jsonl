{"name":"CategoryTheory.uncurry_obj_map","module":"Mathlib.CategoryTheory.Functor.Currying","initialProofState":"C : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} C\nD : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} D\nE : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} E\nF : CategoryTheory.Functor C (CategoryTheory.Functor D E)\nX Y : Prod C D\nf : Quiver.Hom X Y\n⊢ Eq ((CategoryTheory.uncurry.obj F).map f) (CategoryTheory.CategoryStruct.comp ((F.map f.1).app X.2) ((F.obj Y.1).map f.2))","decl":"/-- The uncurrying functor, taking a functor `C ⥤ (D ⥤ E)` and producing a functor `(C × D) ⥤ E`.\n-/\n@[simps]\ndef uncurry : (C ⥤ D ⥤ E) ⥤ C × D ⥤ E where\n  obj F :=\n    { obj := fun X => (F.obj X.1).obj X.2\n      map := fun {X} {Y} f => (F.map f.1).app X.2 ≫ (F.obj Y.1).map f.2\n      map_comp := fun f g => by\n        simp only [prod_comp_fst, prod_comp_snd, Functor.map_comp, NatTrans.comp_app,\n          Category.assoc]\n        slice_lhs 2 3 => rw [← NatTrans.naturality]\n        rw [Category.assoc] }\n  map T :=\n    { app := fun X => (T.app X.1).app X.2\n      naturality := fun X Y f => by\n        simp only [prod_comp_fst, prod_comp_snd, Category.comp_id, Category.assoc, Functor.map_id,\n          Functor.map_comp, NatTrans.id_app, NatTrans.comp_app]\n        slice_lhs 2 3 => rw [NatTrans.naturality]\n        slice_lhs 1 2 => rw [← NatTrans.comp_app, NatTrans.naturality, NatTrans.comp_app]\n        rw [Category.assoc] }\n\n"}
{"name":"CategoryTheory.uncurry_map_app","module":"Mathlib.CategoryTheory.Functor.Currying","initialProofState":"C : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} C\nD : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} D\nE : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} E\nX✝ Y✝ : CategoryTheory.Functor C (CategoryTheory.Functor D E)\nT : Quiver.Hom X✝ Y✝\nX : Prod C D\n⊢ Eq ((CategoryTheory.uncurry.map T).app X) ((T.app X.1).app X.2)","decl":"/-- The uncurrying functor, taking a functor `C ⥤ (D ⥤ E)` and producing a functor `(C × D) ⥤ E`.\n-/\n@[simps]\ndef uncurry : (C ⥤ D ⥤ E) ⥤ C × D ⥤ E where\n  obj F :=\n    { obj := fun X => (F.obj X.1).obj X.2\n      map := fun {X} {Y} f => (F.map f.1).app X.2 ≫ (F.obj Y.1).map f.2\n      map_comp := fun f g => by\n        simp only [prod_comp_fst, prod_comp_snd, Functor.map_comp, NatTrans.comp_app,\n          Category.assoc]\n        slice_lhs 2 3 => rw [← NatTrans.naturality]\n        rw [Category.assoc] }\n  map T :=\n    { app := fun X => (T.app X.1).app X.2\n      naturality := fun X Y f => by\n        simp only [prod_comp_fst, prod_comp_snd, Category.comp_id, Category.assoc, Functor.map_id,\n          Functor.map_comp, NatTrans.id_app, NatTrans.comp_app]\n        slice_lhs 2 3 => rw [NatTrans.naturality]\n        slice_lhs 1 2 => rw [← NatTrans.comp_app, NatTrans.naturality, NatTrans.comp_app]\n        rw [Category.assoc] }\n\n"}
{"name":"CategoryTheory.uncurry_obj_obj","module":"Mathlib.CategoryTheory.Functor.Currying","initialProofState":"C : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} C\nD : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} D\nE : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} E\nF : CategoryTheory.Functor C (CategoryTheory.Functor D E)\nX : Prod C D\n⊢ Eq ((CategoryTheory.uncurry.obj F).obj X) ((F.obj X.1).obj X.2)","decl":"/-- The uncurrying functor, taking a functor `C ⥤ (D ⥤ E)` and producing a functor `(C × D) ⥤ E`.\n-/\n@[simps]\ndef uncurry : (C ⥤ D ⥤ E) ⥤ C × D ⥤ E where\n  obj F :=\n    { obj := fun X => (F.obj X.1).obj X.2\n      map := fun {X} {Y} f => (F.map f.1).app X.2 ≫ (F.obj Y.1).map f.2\n      map_comp := fun f g => by\n        simp only [prod_comp_fst, prod_comp_snd, Functor.map_comp, NatTrans.comp_app,\n          Category.assoc]\n        slice_lhs 2 3 => rw [← NatTrans.naturality]\n        rw [Category.assoc] }\n  map T :=\n    { app := fun X => (T.app X.1).app X.2\n      naturality := fun X Y f => by\n        simp only [prod_comp_fst, prod_comp_snd, Category.comp_id, Category.assoc, Functor.map_id,\n          Functor.map_comp, NatTrans.id_app, NatTrans.comp_app]\n        slice_lhs 2 3 => rw [NatTrans.naturality]\n        slice_lhs 1 2 => rw [← NatTrans.comp_app, NatTrans.naturality, NatTrans.comp_app]\n        rw [Category.assoc] }\n\n"}
{"name":"CategoryTheory.curry_obj_map_app","module":"Mathlib.CategoryTheory.Functor.Currying","initialProofState":"C : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} C\nD : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} D\nE : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} E\nF : CategoryTheory.Functor (Prod C D) E\nX✝ Y✝ : C\nf : Quiver.Hom X✝ Y✝\nY : D\n⊢ Eq (((CategoryTheory.curry.obj F).map f).app Y) (F.map { fst := f, snd := CategoryTheory.CategoryStruct.id Y })","decl":"/-- The currying functor, taking a functor `(C × D) ⥤ E` and producing a functor `C ⥤ (D ⥤ E)`.\n-/\n@[simps! obj_obj_obj obj_obj_map obj_map_app map_app_app]\ndef curry : (C × D ⥤ E) ⥤ C ⥤ D ⥤ E where\n  obj F := curryObj F\n  map T :=\n    { app := fun X =>\n        { app := fun Y => T.app (X, Y)\n          naturality := fun Y Y' g => by\n            dsimp [curryObj]\n            rw [NatTrans.naturality] }\n      naturality := fun X X' f => by\n        ext; dsimp [curryObj]\n        rw [NatTrans.naturality] }\n\n-- create projection simp lemmas even though this isn't a `{ .. }`.\n"}
{"name":"CategoryTheory.curry_obj_obj_map","module":"Mathlib.CategoryTheory.Functor.Currying","initialProofState":"C : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} C\nD : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} D\nE : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} E\nF : CategoryTheory.Functor (Prod C D) E\nX : C\nX✝ Y✝ : D\ng : Quiver.Hom X✝ Y✝\n⊢ Eq (((CategoryTheory.curry.obj F).obj X).map g) (F.map { fst := CategoryTheory.CategoryStruct.id X, snd := g })","decl":"/-- The currying functor, taking a functor `(C × D) ⥤ E` and producing a functor `C ⥤ (D ⥤ E)`.\n-/\n@[simps! obj_obj_obj obj_obj_map obj_map_app map_app_app]\ndef curry : (C × D ⥤ E) ⥤ C ⥤ D ⥤ E where\n  obj F := curryObj F\n  map T :=\n    { app := fun X =>\n        { app := fun Y => T.app (X, Y)\n          naturality := fun Y Y' g => by\n            dsimp [curryObj]\n            rw [NatTrans.naturality] }\n      naturality := fun X X' f => by\n        ext; dsimp [curryObj]\n        rw [NatTrans.naturality] }\n\n-- create projection simp lemmas even though this isn't a `{ .. }`.\n"}
{"name":"CategoryTheory.curry_obj_obj_obj","module":"Mathlib.CategoryTheory.Functor.Currying","initialProofState":"C : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} C\nD : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} D\nE : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} E\nF : CategoryTheory.Functor (Prod C D) E\nX : C\nY : D\n⊢ Eq (((CategoryTheory.curry.obj F).obj X).obj Y) (F.obj { fst := X, snd := Y })","decl":"/-- The currying functor, taking a functor `(C × D) ⥤ E` and producing a functor `C ⥤ (D ⥤ E)`.\n-/\n@[simps! obj_obj_obj obj_obj_map obj_map_app map_app_app]\ndef curry : (C × D ⥤ E) ⥤ C ⥤ D ⥤ E where\n  obj F := curryObj F\n  map T :=\n    { app := fun X =>\n        { app := fun Y => T.app (X, Y)\n          naturality := fun Y Y' g => by\n            dsimp [curryObj]\n            rw [NatTrans.naturality] }\n      naturality := fun X X' f => by\n        ext; dsimp [curryObj]\n        rw [NatTrans.naturality] }\n\n-- create projection simp lemmas even though this isn't a `{ .. }`.\n"}
{"name":"CategoryTheory.curry_map_app_app","module":"Mathlib.CategoryTheory.Functor.Currying","initialProofState":"C : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} C\nD : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} D\nE : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} E\nX✝ Y✝ : CategoryTheory.Functor (Prod C D) E\nT : Quiver.Hom X✝ Y✝\nX : C\nY : D\n⊢ Eq (((CategoryTheory.curry.map T).app X).app Y) (T.app { fst := X, snd := Y })","decl":"/-- The currying functor, taking a functor `(C × D) ⥤ E` and producing a functor `C ⥤ (D ⥤ E)`.\n-/\n@[simps! obj_obj_obj obj_obj_map obj_map_app map_app_app]\ndef curry : (C × D ⥤ E) ⥤ C ⥤ D ⥤ E where\n  obj F := curryObj F\n  map T :=\n    { app := fun X =>\n        { app := fun Y => T.app (X, Y)\n          naturality := fun Y Y' g => by\n            dsimp [curryObj]\n            rw [NatTrans.naturality] }\n      naturality := fun X X' f => by\n        ext; dsimp [curryObj]\n        rw [NatTrans.naturality] }\n\n-- create projection simp lemmas even though this isn't a `{ .. }`.\n"}
{"name":"CategoryTheory.currying_counitIso_hom_app_app","module":"Mathlib.CategoryTheory.Functor.Currying","initialProofState":"C : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} C\nD : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} D\nE : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} E\nX✝ : CategoryTheory.Functor (Prod C D) E\nX : Prod C D\n⊢ Eq ((CategoryTheory.currying.counitIso.hom.app X✝).app X) (CategoryTheory.CategoryStruct.id (X✝.obj { fst := X.1, snd := X.2 }))","decl":"/-- The equivalence of functor categories given by currying/uncurrying.\n-/\n@[simps!]\ndef currying : C ⥤ D ⥤ E ≌ C × D ⥤ E where\n  functor := uncurry\n  inverse := curry\n  unitIso := NatIso.ofComponents (fun _ ↦ NatIso.ofComponents\n    (fun _ ↦ NatIso.ofComponents (fun _ ↦ Iso.refl _)))\n  counitIso := NatIso.ofComponents\n    (fun F ↦ NatIso.ofComponents (fun _ ↦ Iso.refl _) (by\n      rintro ⟨X₁, X₂⟩ ⟨Y₁, Y₂⟩ ⟨f₁, f₂⟩\n      dsimp at f₁ f₂ ⊢\n      simp only [← F.map_comp, prod_comp, Category.comp_id, Category.id_comp]))\n\n"}
{"name":"CategoryTheory.currying_unitIso_inv_app_app_app","module":"Mathlib.CategoryTheory.Functor.Currying","initialProofState":"C : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} C\nD : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} D\nE : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} E\nX✝¹ : CategoryTheory.Functor C (CategoryTheory.Functor D E)\nX✝ : C\nX : D\n⊢ Eq (((CategoryTheory.currying.unitIso.inv.app X✝¹).app X✝).app X) (CategoryTheory.CategoryStruct.id ((X✝¹.obj X✝).obj X))","decl":"/-- The equivalence of functor categories given by currying/uncurrying.\n-/\n@[simps!]\ndef currying : C ⥤ D ⥤ E ≌ C × D ⥤ E where\n  functor := uncurry\n  inverse := curry\n  unitIso := NatIso.ofComponents (fun _ ↦ NatIso.ofComponents\n    (fun _ ↦ NatIso.ofComponents (fun _ ↦ Iso.refl _)))\n  counitIso := NatIso.ofComponents\n    (fun F ↦ NatIso.ofComponents (fun _ ↦ Iso.refl _) (by\n      rintro ⟨X₁, X₂⟩ ⟨Y₁, Y₂⟩ ⟨f₁, f₂⟩\n      dsimp at f₁ f₂ ⊢\n      simp only [← F.map_comp, prod_comp, Category.comp_id, Category.id_comp]))\n\n"}
{"name":"CategoryTheory.currying_functor_obj_map","module":"Mathlib.CategoryTheory.Functor.Currying","initialProofState":"C : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} C\nD : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} D\nE : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} E\nF : CategoryTheory.Functor C (CategoryTheory.Functor D E)\nX Y : Prod C D\nf : Quiver.Hom X Y\n⊢ Eq ((CategoryTheory.currying.functor.obj F).map f) (CategoryTheory.CategoryStruct.comp ((F.map f.1).app X.2) ((F.obj Y.1).map f.2))","decl":"/-- The equivalence of functor categories given by currying/uncurrying.\n-/\n@[simps!]\ndef currying : C ⥤ D ⥤ E ≌ C × D ⥤ E where\n  functor := uncurry\n  inverse := curry\n  unitIso := NatIso.ofComponents (fun _ ↦ NatIso.ofComponents\n    (fun _ ↦ NatIso.ofComponents (fun _ ↦ Iso.refl _)))\n  counitIso := NatIso.ofComponents\n    (fun F ↦ NatIso.ofComponents (fun _ ↦ Iso.refl _) (by\n      rintro ⟨X₁, X₂⟩ ⟨Y₁, Y₂⟩ ⟨f₁, f₂⟩\n      dsimp at f₁ f₂ ⊢\n      simp only [← F.map_comp, prod_comp, Category.comp_id, Category.id_comp]))\n\n"}
{"name":"CategoryTheory.currying_inverse_obj_obj_map","module":"Mathlib.CategoryTheory.Functor.Currying","initialProofState":"C : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} C\nD : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} D\nE : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} E\nF : CategoryTheory.Functor (Prod C D) E\nX : C\nX✝ Y✝ : D\ng : Quiver.Hom X✝ Y✝\n⊢ Eq (((CategoryTheory.currying.inverse.obj F).obj X).map g) (F.map { fst := CategoryTheory.CategoryStruct.id X, snd := g })","decl":"/-- The equivalence of functor categories given by currying/uncurrying.\n-/\n@[simps!]\ndef currying : C ⥤ D ⥤ E ≌ C × D ⥤ E where\n  functor := uncurry\n  inverse := curry\n  unitIso := NatIso.ofComponents (fun _ ↦ NatIso.ofComponents\n    (fun _ ↦ NatIso.ofComponents (fun _ ↦ Iso.refl _)))\n  counitIso := NatIso.ofComponents\n    (fun F ↦ NatIso.ofComponents (fun _ ↦ Iso.refl _) (by\n      rintro ⟨X₁, X₂⟩ ⟨Y₁, Y₂⟩ ⟨f₁, f₂⟩\n      dsimp at f₁ f₂ ⊢\n      simp only [← F.map_comp, prod_comp, Category.comp_id, Category.id_comp]))\n\n"}
{"name":"CategoryTheory.currying_unitIso_hom_app_app_app","module":"Mathlib.CategoryTheory.Functor.Currying","initialProofState":"C : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} C\nD : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} D\nE : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} E\nX✝¹ : CategoryTheory.Functor C (CategoryTheory.Functor D E)\nX✝ : C\nX : D\n⊢ Eq (((CategoryTheory.currying.unitIso.hom.app X✝¹).app X✝).app X) (CategoryTheory.CategoryStruct.id ((X✝¹.obj X✝).obj X))","decl":"/-- The equivalence of functor categories given by currying/uncurrying.\n-/\n@[simps!]\ndef currying : C ⥤ D ⥤ E ≌ C × D ⥤ E where\n  functor := uncurry\n  inverse := curry\n  unitIso := NatIso.ofComponents (fun _ ↦ NatIso.ofComponents\n    (fun _ ↦ NatIso.ofComponents (fun _ ↦ Iso.refl _)))\n  counitIso := NatIso.ofComponents\n    (fun F ↦ NatIso.ofComponents (fun _ ↦ Iso.refl _) (by\n      rintro ⟨X₁, X₂⟩ ⟨Y₁, Y₂⟩ ⟨f₁, f₂⟩\n      dsimp at f₁ f₂ ⊢\n      simp only [← F.map_comp, prod_comp, Category.comp_id, Category.id_comp]))\n\n"}
{"name":"CategoryTheory.currying_counitIso_inv_app_app","module":"Mathlib.CategoryTheory.Functor.Currying","initialProofState":"C : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} C\nD : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} D\nE : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} E\nX✝ : CategoryTheory.Functor (Prod C D) E\nX : Prod C D\n⊢ Eq ((CategoryTheory.currying.counitIso.inv.app X✝).app X) (CategoryTheory.CategoryStruct.id (X✝.obj { fst := X.1, snd := X.2 }))","decl":"/-- The equivalence of functor categories given by currying/uncurrying.\n-/\n@[simps!]\ndef currying : C ⥤ D ⥤ E ≌ C × D ⥤ E where\n  functor := uncurry\n  inverse := curry\n  unitIso := NatIso.ofComponents (fun _ ↦ NatIso.ofComponents\n    (fun _ ↦ NatIso.ofComponents (fun _ ↦ Iso.refl _)))\n  counitIso := NatIso.ofComponents\n    (fun F ↦ NatIso.ofComponents (fun _ ↦ Iso.refl _) (by\n      rintro ⟨X₁, X₂⟩ ⟨Y₁, Y₂⟩ ⟨f₁, f₂⟩\n      dsimp at f₁ f₂ ⊢\n      simp only [← F.map_comp, prod_comp, Category.comp_id, Category.id_comp]))\n\n"}
{"name":"CategoryTheory.currying_inverse_map_app_app","module":"Mathlib.CategoryTheory.Functor.Currying","initialProofState":"C : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} C\nD : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} D\nE : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} E\nX✝ Y✝ : CategoryTheory.Functor (Prod C D) E\nT : Quiver.Hom X✝ Y✝\nX : C\nY : D\n⊢ Eq (((CategoryTheory.currying.inverse.map T).app X).app Y) (T.app { fst := X, snd := Y })","decl":"/-- The equivalence of functor categories given by currying/uncurrying.\n-/\n@[simps!]\ndef currying : C ⥤ D ⥤ E ≌ C × D ⥤ E where\n  functor := uncurry\n  inverse := curry\n  unitIso := NatIso.ofComponents (fun _ ↦ NatIso.ofComponents\n    (fun _ ↦ NatIso.ofComponents (fun _ ↦ Iso.refl _)))\n  counitIso := NatIso.ofComponents\n    (fun F ↦ NatIso.ofComponents (fun _ ↦ Iso.refl _) (by\n      rintro ⟨X₁, X₂⟩ ⟨Y₁, Y₂⟩ ⟨f₁, f₂⟩\n      dsimp at f₁ f₂ ⊢\n      simp only [← F.map_comp, prod_comp, Category.comp_id, Category.id_comp]))\n\n"}
{"name":"CategoryTheory.currying_functor_obj_obj","module":"Mathlib.CategoryTheory.Functor.Currying","initialProofState":"C : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} C\nD : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} D\nE : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} E\nF : CategoryTheory.Functor C (CategoryTheory.Functor D E)\nX : Prod C D\n⊢ Eq ((CategoryTheory.currying.functor.obj F).obj X) ((F.obj X.1).obj X.2)","decl":"/-- The equivalence of functor categories given by currying/uncurrying.\n-/\n@[simps!]\ndef currying : C ⥤ D ⥤ E ≌ C × D ⥤ E where\n  functor := uncurry\n  inverse := curry\n  unitIso := NatIso.ofComponents (fun _ ↦ NatIso.ofComponents\n    (fun _ ↦ NatIso.ofComponents (fun _ ↦ Iso.refl _)))\n  counitIso := NatIso.ofComponents\n    (fun F ↦ NatIso.ofComponents (fun _ ↦ Iso.refl _) (by\n      rintro ⟨X₁, X₂⟩ ⟨Y₁, Y₂⟩ ⟨f₁, f₂⟩\n      dsimp at f₁ f₂ ⊢\n      simp only [← F.map_comp, prod_comp, Category.comp_id, Category.id_comp]))\n\n"}
{"name":"CategoryTheory.currying_inverse_obj_map_app","module":"Mathlib.CategoryTheory.Functor.Currying","initialProofState":"C : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} C\nD : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} D\nE : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} E\nF : CategoryTheory.Functor (Prod C D) E\nX✝ Y✝ : C\nf : Quiver.Hom X✝ Y✝\nY : D\n⊢ Eq (((CategoryTheory.currying.inverse.obj F).map f).app Y) (F.map { fst := f, snd := CategoryTheory.CategoryStruct.id Y })","decl":"/-- The equivalence of functor categories given by currying/uncurrying.\n-/\n@[simps!]\ndef currying : C ⥤ D ⥤ E ≌ C × D ⥤ E where\n  functor := uncurry\n  inverse := curry\n  unitIso := NatIso.ofComponents (fun _ ↦ NatIso.ofComponents\n    (fun _ ↦ NatIso.ofComponents (fun _ ↦ Iso.refl _)))\n  counitIso := NatIso.ofComponents\n    (fun F ↦ NatIso.ofComponents (fun _ ↦ Iso.refl _) (by\n      rintro ⟨X₁, X₂⟩ ⟨Y₁, Y₂⟩ ⟨f₁, f₂⟩\n      dsimp at f₁ f₂ ⊢\n      simp only [← F.map_comp, prod_comp, Category.comp_id, Category.id_comp]))\n\n"}
{"name":"CategoryTheory.currying_inverse_obj_obj_obj","module":"Mathlib.CategoryTheory.Functor.Currying","initialProofState":"C : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} C\nD : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} D\nE : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} E\nF : CategoryTheory.Functor (Prod C D) E\nX : C\nY : D\n⊢ Eq (((CategoryTheory.currying.inverse.obj F).obj X).obj Y) (F.obj { fst := X, snd := Y })","decl":"/-- The equivalence of functor categories given by currying/uncurrying.\n-/\n@[simps!]\ndef currying : C ⥤ D ⥤ E ≌ C × D ⥤ E where\n  functor := uncurry\n  inverse := curry\n  unitIso := NatIso.ofComponents (fun _ ↦ NatIso.ofComponents\n    (fun _ ↦ NatIso.ofComponents (fun _ ↦ Iso.refl _)))\n  counitIso := NatIso.ofComponents\n    (fun F ↦ NatIso.ofComponents (fun _ ↦ Iso.refl _) (by\n      rintro ⟨X₁, X₂⟩ ⟨Y₁, Y₂⟩ ⟨f₁, f₂⟩\n      dsimp at f₁ f₂ ⊢\n      simp only [← F.map_comp, prod_comp, Category.comp_id, Category.id_comp]))\n\n"}
{"name":"CategoryTheory.currying_functor_map_app","module":"Mathlib.CategoryTheory.Functor.Currying","initialProofState":"C : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} C\nD : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} D\nE : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} E\nX✝ Y✝ : CategoryTheory.Functor C (CategoryTheory.Functor D E)\nT : Quiver.Hom X✝ Y✝\nX : Prod C D\n⊢ Eq ((CategoryTheory.currying.functor.map T).app X) ((T.app X.1).app X.2)","decl":"/-- The equivalence of functor categories given by currying/uncurrying.\n-/\n@[simps!]\ndef currying : C ⥤ D ⥤ E ≌ C × D ⥤ E where\n  functor := uncurry\n  inverse := curry\n  unitIso := NatIso.ofComponents (fun _ ↦ NatIso.ofComponents\n    (fun _ ↦ NatIso.ofComponents (fun _ ↦ Iso.refl _)))\n  counitIso := NatIso.ofComponents\n    (fun F ↦ NatIso.ofComponents (fun _ ↦ Iso.refl _) (by\n      rintro ⟨X₁, X₂⟩ ⟨Y₁, Y₂⟩ ⟨f₁, f₂⟩\n      dsimp at f₁ f₂ ⊢\n      simp only [← F.map_comp, prod_comp, Category.comp_id, Category.id_comp]))\n\n"}
{"name":"CategoryTheory.instFullFunctorProdUncurry","module":"Mathlib.CategoryTheory.Functor.Currying","initialProofState":"C : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} C\nD : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} D\nE : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} E\n⊢ CategoryTheory.uncurry.Full","decl":"instance : (uncurry : (C ⥤ D ⥤ E) ⥤ C × D ⥤ E).Full :=\n  fullyFaithfulUncurry.full\n\n"}
{"name":"CategoryTheory.instFaithfulFunctorProdUncurry","module":"Mathlib.CategoryTheory.Functor.Currying","initialProofState":"C : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} C\nD : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} D\nE : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} E\n⊢ CategoryTheory.uncurry.Faithful","decl":"instance : (uncurry : (C ⥤ D ⥤ E) ⥤ C × D ⥤ E).Faithful :=\n  fullyFaithfulUncurry.faithful\n\n"}
{"name":"CategoryTheory.curryObjProdComp_hom_app_app","module":"Mathlib.CategoryTheory.Functor.Currying","initialProofState":"C : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} C\nD : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} D\nE : Type u₄\ninst✝² : CategoryTheory.Category.{v₄, u₄} E\nC' : Type u_1\nD' : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C'\ninst✝ : CategoryTheory.Category.{u_4, u_2} D'\nF₁ : CategoryTheory.Functor C D\nF₂ : CategoryTheory.Functor C' D'\nG : CategoryTheory.Functor (Prod D D') E\nX✝ : C\nX : C'\n⊢ Eq (((CategoryTheory.curryObjProdComp F₁ F₂ G).hom.app X✝).app X) (CategoryTheory.CategoryStruct.id (G.obj { fst := F₁.obj X✝, snd := F₂.obj X }))","decl":"/-- Given functors `F₁ : C ⥤ D`, `F₂ : C' ⥤ D'` and `G : D × D' ⥤ E`, this is the isomorphism\nbetween `curry.obj ((F₁.prod F₂).comp G)` and\n`F₁ ⋙ curry.obj G ⋙ (whiskeringLeft C' D' E).obj F₂` in the category `C ⥤ C' ⥤ E`. -/\n@[simps!]\ndef curryObjProdComp {C' D' : Type*} [Category C'] [Category D']\n    (F₁ : C ⥤ D) (F₂ : C' ⥤ D') (G : D × D' ⥤ E) :\n    curry.obj ((F₁.prod F₂).comp G) ≅\n      F₁ ⋙ curry.obj G ⋙ (whiskeringLeft C' D' E).obj F₂ :=\n  NatIso.ofComponents (fun X₁ ↦ NatIso.ofComponents (fun X₂ ↦ Iso.refl _))\n\n"}
{"name":"CategoryTheory.curryObjProdComp_inv_app_app","module":"Mathlib.CategoryTheory.Functor.Currying","initialProofState":"C : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} C\nD : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} D\nE : Type u₄\ninst✝² : CategoryTheory.Category.{v₄, u₄} E\nC' : Type u_1\nD' : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C'\ninst✝ : CategoryTheory.Category.{u_4, u_2} D'\nF₁ : CategoryTheory.Functor C D\nF₂ : CategoryTheory.Functor C' D'\nG : CategoryTheory.Functor (Prod D D') E\nX✝ : C\nX : C'\n⊢ Eq (((CategoryTheory.curryObjProdComp F₁ F₂ G).inv.app X✝).app X) (CategoryTheory.CategoryStruct.id (G.obj { fst := F₁.obj X✝, snd := F₂.obj X }))","decl":"/-- Given functors `F₁ : C ⥤ D`, `F₂ : C' ⥤ D'` and `G : D × D' ⥤ E`, this is the isomorphism\nbetween `curry.obj ((F₁.prod F₂).comp G)` and\n`F₁ ⋙ curry.obj G ⋙ (whiskeringLeft C' D' E).obj F₂` in the category `C ⥤ C' ⥤ E`. -/\n@[simps!]\ndef curryObjProdComp {C' D' : Type*} [Category C'] [Category D']\n    (F₁ : C ⥤ D) (F₂ : C' ⥤ D') (G : D × D' ⥤ E) :\n    curry.obj ((F₁.prod F₂).comp G) ≅\n      F₁ ⋙ curry.obj G ⋙ (whiskeringLeft C' D' E).obj F₂ :=\n  NatIso.ofComponents (fun X₁ ↦ NatIso.ofComponents (fun X₂ ↦ Iso.refl _))\n\n"}
{"name":"CategoryTheory.flipIsoCurrySwapUncurry_hom_app_app","module":"Mathlib.CategoryTheory.Functor.Currying","initialProofState":"C : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} C\nD : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} D\nE : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} E\nF : CategoryTheory.Functor C (CategoryTheory.Functor D E)\nX✝ : D\nX : C\n⊢ Eq (((CategoryTheory.flipIsoCurrySwapUncurry F).hom.app X✝).app X) (CategoryTheory.CategoryStruct.id ((F.obj X).obj X✝))","decl":"/-- `F.flip` is isomorphic to uncurrying `F`, swapping the variables, and currying. -/\n@[simps!]\ndef flipIsoCurrySwapUncurry (F : C ⥤ D ⥤ E) : F.flip ≅ curry.obj (Prod.swap _ _ ⋙ uncurry.obj F) :=\n  NatIso.ofComponents fun d => NatIso.ofComponents fun _ => Iso.refl _\n\n"}
{"name":"CategoryTheory.flipIsoCurrySwapUncurry_inv_app_app","module":"Mathlib.CategoryTheory.Functor.Currying","initialProofState":"C : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} C\nD : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} D\nE : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} E\nF : CategoryTheory.Functor C (CategoryTheory.Functor D E)\nX✝ : D\nX : C\n⊢ Eq (((CategoryTheory.flipIsoCurrySwapUncurry F).inv.app X✝).app X) (CategoryTheory.CategoryStruct.id ((F.obj X).obj X✝))","decl":"/-- `F.flip` is isomorphic to uncurrying `F`, swapping the variables, and currying. -/\n@[simps!]\ndef flipIsoCurrySwapUncurry (F : C ⥤ D ⥤ E) : F.flip ≅ curry.obj (Prod.swap _ _ ⋙ uncurry.obj F) :=\n  NatIso.ofComponents fun d => NatIso.ofComponents fun _ => Iso.refl _\n\n"}
{"name":"CategoryTheory.uncurryObjFlip_inv_app","module":"Mathlib.CategoryTheory.Functor.Currying","initialProofState":"C : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} C\nD : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} D\nE : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} E\nF : CategoryTheory.Functor C (CategoryTheory.Functor D E)\nX : Prod D C\n⊢ Eq ((CategoryTheory.uncurryObjFlip F).inv.app X) (CategoryTheory.CategoryStruct.id ((F.obj X.2).obj X.1))","decl":"/-- The uncurrying of `F.flip` is isomorphic to\nswapping the factors followed by the uncurrying of `F`. -/\n@[simps!]\ndef uncurryObjFlip (F : C ⥤ D ⥤ E) : uncurry.obj F.flip ≅ Prod.swap _ _ ⋙ uncurry.obj F :=\n  NatIso.ofComponents fun _ => Iso.refl _\n\n"}
{"name":"CategoryTheory.uncurryObjFlip_hom_app","module":"Mathlib.CategoryTheory.Functor.Currying","initialProofState":"C : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} C\nD : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} D\nE : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} E\nF : CategoryTheory.Functor C (CategoryTheory.Functor D E)\nX : Prod D C\n⊢ Eq ((CategoryTheory.uncurryObjFlip F).hom.app X) (CategoryTheory.CategoryStruct.id ((F.obj X.2).obj X.1))","decl":"/-- The uncurrying of `F.flip` is isomorphic to\nswapping the factors followed by the uncurrying of `F`. -/\n@[simps!]\ndef uncurryObjFlip (F : C ⥤ D ⥤ E) : uncurry.obj F.flip ≅ Prod.swap _ _ ⋙ uncurry.obj F :=\n  NatIso.ofComponents fun _ => Iso.refl _\n\n"}
{"name":"CategoryTheory.whiskeringRight₂_map_app_app_app","module":"Mathlib.CategoryTheory.Functor.Currying","initialProofState":"B : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} B\nC : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} C\nD : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} D\nE : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} E\nX✝ Y✝ : CategoryTheory.Functor C (CategoryTheory.Functor D E)\nf : Quiver.Hom X✝ Y✝\nX : CategoryTheory.Functor B C\nY : CategoryTheory.Functor B D\nc : B\n⊢ Eq (((((CategoryTheory.whiskeringRight₂ B C D E).map f).app X).app Y).app c) ((f.app (X.obj c)).app (Y.obj c))","decl":"/-- A version of `CategoryTheory.whiskeringRight` for bifunctors, obtained by uncurrying,\napplying `whiskeringRight` and currying back\n-/\n@[simps!]\ndef whiskeringRight₂ : (C ⥤ D ⥤ E) ⥤ (B ⥤ C) ⥤ (B ⥤ D) ⥤ B ⥤ E :=\n  uncurry ⋙\n    whiskeringRight _ _ _ ⋙ (whiskeringLeft _ _ _).obj (prodFunctorToFunctorProd _ _ _) ⋙ curry\n\n"}
{"name":"CategoryTheory.whiskeringRight₂_obj_obj_map_app","module":"Mathlib.CategoryTheory.Functor.Currying","initialProofState":"B : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} B\nC : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} C\nD : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} D\nE : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} E\nX✝² : CategoryTheory.Functor C (CategoryTheory.Functor D E)\nX✝¹ : CategoryTheory.Functor B C\nX✝ Y✝ : CategoryTheory.Functor B D\ng : Quiver.Hom X✝ Y✝\nX : B\n⊢ Eq (((((CategoryTheory.whiskeringRight₂ B C D E).obj X✝²).obj X✝¹).map g).app X) ((X✝².obj (X✝¹.obj X)).map (g.app X))","decl":"/-- A version of `CategoryTheory.whiskeringRight` for bifunctors, obtained by uncurrying,\napplying `whiskeringRight` and currying back\n-/\n@[simps!]\ndef whiskeringRight₂ : (C ⥤ D ⥤ E) ⥤ (B ⥤ C) ⥤ (B ⥤ D) ⥤ B ⥤ E :=\n  uncurry ⋙\n    whiskeringRight _ _ _ ⋙ (whiskeringLeft _ _ _).obj (prodFunctorToFunctorProd _ _ _) ⋙ curry\n\n"}
{"name":"CategoryTheory.whiskeringRight₂_obj_map_app_app","module":"Mathlib.CategoryTheory.Functor.Currying","initialProofState":"B : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} B\nC : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} C\nD : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} D\nE : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} E\nX✝¹ : CategoryTheory.Functor C (CategoryTheory.Functor D E)\nX✝ Y✝ : CategoryTheory.Functor B C\nf : Quiver.Hom X✝ Y✝\nY : CategoryTheory.Functor B D\nX : B\n⊢ Eq (((((CategoryTheory.whiskeringRight₂ B C D E).obj X✝¹).map f).app Y).app X) ((X✝¹.map (f.app X)).app (Y.obj X))","decl":"/-- A version of `CategoryTheory.whiskeringRight` for bifunctors, obtained by uncurrying,\napplying `whiskeringRight` and currying back\n-/\n@[simps!]\ndef whiskeringRight₂ : (C ⥤ D ⥤ E) ⥤ (B ⥤ C) ⥤ (B ⥤ D) ⥤ B ⥤ E :=\n  uncurry ⋙\n    whiskeringRight _ _ _ ⋙ (whiskeringLeft _ _ _).obj (prodFunctorToFunctorProd _ _ _) ⋙ curry\n\n"}
{"name":"CategoryTheory.whiskeringRight₂_obj_obj_obj_map","module":"Mathlib.CategoryTheory.Functor.Currying","initialProofState":"B : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} B\nC : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} C\nD : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} D\nE : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} E\nX✝¹ : CategoryTheory.Functor C (CategoryTheory.Functor D E)\nX : CategoryTheory.Functor B C\nY : CategoryTheory.Functor B D\nX✝ Y✝ : B\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (((((CategoryTheory.whiskeringRight₂ B C D E).obj X✝¹).obj X).obj Y).map f) (CategoryTheory.CategoryStruct.comp ((X✝¹.map (X.map f)).app (Y.obj X✝)) ((X✝¹.obj (X.obj Y✝)).map (Y.map f)))","decl":"/-- A version of `CategoryTheory.whiskeringRight` for bifunctors, obtained by uncurrying,\napplying `whiskeringRight` and currying back\n-/\n@[simps!]\ndef whiskeringRight₂ : (C ⥤ D ⥤ E) ⥤ (B ⥤ C) ⥤ (B ⥤ D) ⥤ B ⥤ E :=\n  uncurry ⋙\n    whiskeringRight _ _ _ ⋙ (whiskeringLeft _ _ _).obj (prodFunctorToFunctorProd _ _ _) ⋙ curry\n\n"}
{"name":"CategoryTheory.whiskeringRight₂_obj_obj_obj_obj","module":"Mathlib.CategoryTheory.Functor.Currying","initialProofState":"B : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} B\nC : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} C\nD : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} D\nE : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} E\nX✝¹ : CategoryTheory.Functor C (CategoryTheory.Functor D E)\nX✝ : CategoryTheory.Functor B C\nY : CategoryTheory.Functor B D\nX : B\n⊢ Eq (((((CategoryTheory.whiskeringRight₂ B C D E).obj X✝¹).obj X✝).obj Y).obj X) ((X✝¹.obj (X✝.obj X)).obj (Y.obj X))","decl":"/-- A version of `CategoryTheory.whiskeringRight` for bifunctors, obtained by uncurrying,\napplying `whiskeringRight` and currying back\n-/\n@[simps!]\ndef whiskeringRight₂ : (C ⥤ D ⥤ E) ⥤ (B ⥤ C) ⥤ (B ⥤ D) ⥤ B ⥤ E :=\n  uncurry ⋙\n    whiskeringRight _ _ _ ⋙ (whiskeringLeft _ _ _).obj (prodFunctorToFunctorProd _ _ _) ⋙ curry\n\n"}
{"name":"CategoryTheory.Functor.uncurry_obj_curry_obj","module":"Mathlib.CategoryTheory.Functor.Currying","initialProofState":"B : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} B\nC : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} C\nD : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} D\nF : CategoryTheory.Functor (Prod B C) D\n⊢ Eq (CategoryTheory.uncurry.obj (CategoryTheory.curry.obj F)) F","decl":"lemma uncurry_obj_curry_obj (F : B × C ⥤ D) : uncurry.obj (curry.obj F) = F :=\n  Functor.ext (by simp) (fun ⟨x₁, x₂⟩ ⟨y₁, y₂⟩ ⟨f₁, f₂⟩ => by\n    dsimp\n    simp only [← F.map_comp, Category.id_comp, Category.comp_id, prod_comp])\n\n"}
{"name":"CategoryTheory.Functor.curry_obj_injective","module":"Mathlib.CategoryTheory.Functor.Currying","initialProofState":"C : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} C\nD : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} D\nE : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} E\nF₁ F₂ : CategoryTheory.Functor (Prod C D) E\nh : Eq (CategoryTheory.curry.obj F₁) (CategoryTheory.curry.obj F₂)\n⊢ Eq F₁ F₂","decl":"lemma curry_obj_injective {F₁ F₂ : C × D ⥤ E} (h : curry.obj F₁ = curry.obj F₂) :\n    F₁ = F₂ := by\n  rw [← uncurry_obj_curry_obj F₁, ← uncurry_obj_curry_obj F₂, h]\n\n"}
{"name":"CategoryTheory.Functor.curry_obj_uncurry_obj","module":"Mathlib.CategoryTheory.Functor.Currying","initialProofState":"B : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} B\nC : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} C\nD : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} D\nF : CategoryTheory.Functor B (CategoryTheory.Functor C D)\n⊢ Eq (CategoryTheory.curry.obj (CategoryTheory.uncurry.obj F)) F","decl":"lemma curry_obj_uncurry_obj (F : B ⥤ C ⥤ D) : curry.obj (uncurry.obj F) = F :=\n  Functor.ext (fun _ => Functor.ext (by simp) (by simp)) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.Functor.uncurry_obj_injective","module":"Mathlib.CategoryTheory.Functor.Currying","initialProofState":"B : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} B\nC : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} C\nD : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} D\nF₁ F₂ : CategoryTheory.Functor B (CategoryTheory.Functor C D)\nh : Eq (CategoryTheory.uncurry.obj F₁) (CategoryTheory.uncurry.obj F₂)\n⊢ Eq F₁ F₂","decl":"lemma uncurry_obj_injective {F₁ F₂ : B ⥤ C ⥤ D} (h : uncurry.obj F₁ = uncurry.obj F₂) :\n    F₁ = F₂ := by\n  rw [← curry_obj_uncurry_obj F₁, ← curry_obj_uncurry_obj F₂, h]\n\n"}
{"name":"CategoryTheory.Functor.flip_flip","module":"Mathlib.CategoryTheory.Functor.Currying","initialProofState":"B : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} B\nC : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} C\nD : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} D\nF : CategoryTheory.Functor B (CategoryTheory.Functor C D)\n⊢ Eq F.flip.flip F","decl":"lemma flip_flip (F : B ⥤ C ⥤ D) : F.flip.flip = F := rfl\n\n"}
{"name":"CategoryTheory.Functor.flip_injective","module":"Mathlib.CategoryTheory.Functor.Currying","initialProofState":"B : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} B\nC : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} C\nD : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} D\nF₁ F₂ : CategoryTheory.Functor B (CategoryTheory.Functor C D)\nh : Eq F₁.flip F₂.flip\n⊢ Eq F₁ F₂","decl":"lemma flip_injective {F₁ F₂ : B ⥤ C ⥤ D} (h : F₁.flip = F₂.flip) :\n    F₁ = F₂ := by\n  rw [← flip_flip F₁, ← flip_flip F₂, h]\n\n"}
{"name":"CategoryTheory.Functor.uncurry_obj_curry_obj_flip_flip","module":"Mathlib.CategoryTheory.Functor.Currying","initialProofState":"B : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} B\nC : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} C\nD : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} D\nE : Type u₄\ninst✝¹ : CategoryTheory.Category.{v₄, u₄} E\nH : Type u₅\ninst✝ : CategoryTheory.Category.{v₅, u₅} H\nF₁ : CategoryTheory.Functor B C\nF₂ : CategoryTheory.Functor D E\nG : CategoryTheory.Functor (Prod C E) H\n⊢ Eq (CategoryTheory.uncurry.obj (F₂.comp (F₁.comp (CategoryTheory.curry.obj G)).flip).flip) ((F₁.prod F₂).comp G)","decl":"lemma uncurry_obj_curry_obj_flip_flip (F₁ : B ⥤ C) (F₂ : D ⥤ E) (G : C × E ⥤ H) :\n    uncurry.obj (F₂ ⋙ (F₁ ⋙ curry.obj G).flip).flip = (F₁.prod F₂) ⋙ G :=\n  Functor.ext (by simp) (fun ⟨x₁, x₂⟩ ⟨y₁, y₂⟩ ⟨f₁, f₂⟩ => by\n    dsimp\n    simp only [Category.id_comp, Category.comp_id, ← G.map_comp, prod_comp])\n\n"}
{"name":"CategoryTheory.Functor.uncurry_obj_curry_obj_flip_flip'","module":"Mathlib.CategoryTheory.Functor.Currying","initialProofState":"B : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} B\nC : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} C\nD : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} D\nE : Type u₄\ninst✝¹ : CategoryTheory.Category.{v₄, u₄} E\nH : Type u₅\ninst✝ : CategoryTheory.Category.{v₅, u₅} H\nF₁ : CategoryTheory.Functor B C\nF₂ : CategoryTheory.Functor D E\nG : CategoryTheory.Functor (Prod C E) H\n⊢ Eq (CategoryTheory.uncurry.obj (F₁.comp (F₂.comp (CategoryTheory.curry.obj G).flip).flip)) ((F₁.prod F₂).comp G)","decl":"lemma uncurry_obj_curry_obj_flip_flip' (F₁ : B ⥤ C) (F₂ : D ⥤ E) (G : C × E ⥤ H) :\n    uncurry.obj (F₁ ⋙ (F₂ ⋙ (curry.obj G).flip).flip) = (F₁.prod F₂) ⋙ G :=\n  Functor.ext (by simp) (fun ⟨x₁, x₂⟩ ⟨y₁, y₂⟩ ⟨f₁, f₂⟩ => by\n    dsimp\n    simp only [Category.id_comp, Category.comp_id, ← G.map_comp, prod_comp])\n\n"}
