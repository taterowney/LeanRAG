{"name":"CategoryTheory.evaluationLeftAdjoint_obj_obj","module":"Mathlib.CategoryTheory.Adjunction.Evaluation","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : ∀ (a b : C), CategoryTheory.Limits.HasCoproductsOfShape (Quiver.Hom a b) D\nc : C\nd : D\nt : C\n⊢ Eq (((CategoryTheory.evaluationLeftAdjoint D c).obj d).obj t) (CategoryTheory.Limits.sigmaObj fun x => d)","decl":"/-- The left adjoint of evaluation. -/\n@[simps]\ndef evaluationLeftAdjoint (c : C) : D ⥤ C ⥤ D where\n  obj d :=\n    { obj := fun t => ∐ fun _ : c ⟶ t => d\n      map := fun f => Sigma.desc fun g => (Sigma.ι fun _ => d) <| g ≫ f}\n  map {_ d₂} f :=\n    { app := fun _ => Sigma.desc fun h => f ≫ Sigma.ι (fun _ => d₂) h\n      naturality := by\n        intros\n        dsimp\n        ext\n        simp }\n\n"}
{"name":"CategoryTheory.evaluationLeftAdjoint_obj_map","module":"Mathlib.CategoryTheory.Adjunction.Evaluation","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : ∀ (a b : C), CategoryTheory.Limits.HasCoproductsOfShape (Quiver.Hom a b) D\nc : C\nd : D\nX✝ Y✝ : C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (((CategoryTheory.evaluationLeftAdjoint D c).obj d).map f) (CategoryTheory.Limits.Sigma.desc fun g => CategoryTheory.Limits.Sigma.ι (fun x => d) (CategoryTheory.CategoryStruct.comp g f))","decl":"/-- The left adjoint of evaluation. -/\n@[simps]\ndef evaluationLeftAdjoint (c : C) : D ⥤ C ⥤ D where\n  obj d :=\n    { obj := fun t => ∐ fun _ : c ⟶ t => d\n      map := fun f => Sigma.desc fun g => (Sigma.ι fun _ => d) <| g ≫ f}\n  map {_ d₂} f :=\n    { app := fun _ => Sigma.desc fun h => f ≫ Sigma.ι (fun _ => d₂) h\n      naturality := by\n        intros\n        dsimp\n        ext\n        simp }\n\n"}
{"name":"CategoryTheory.evaluationLeftAdjoint_map_app","module":"Mathlib.CategoryTheory.Adjunction.Evaluation","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : ∀ (a b : C), CategoryTheory.Limits.HasCoproductsOfShape (Quiver.Hom a b) D\nc : C\nx✝¹ d₂ : D\nf : Quiver.Hom x✝¹ d₂\nx✝ : C\n⊢ Eq (((CategoryTheory.evaluationLeftAdjoint D c).map f).app x✝) (CategoryTheory.Limits.Sigma.desc fun h => CategoryTheory.CategoryStruct.comp f (CategoryTheory.Limits.Sigma.ι (fun x => d₂) h))","decl":"/-- The left adjoint of evaluation. -/\n@[simps]\ndef evaluationLeftAdjoint (c : C) : D ⥤ C ⥤ D where\n  obj d :=\n    { obj := fun t => ∐ fun _ : c ⟶ t => d\n      map := fun f => Sigma.desc fun g => (Sigma.ι fun _ => d) <| g ≫ f}\n  map {_ d₂} f :=\n    { app := fun _ => Sigma.desc fun h => f ≫ Sigma.ι (fun _ => d₂) h\n      naturality := by\n        intros\n        dsimp\n        ext\n        simp }\n\n"}
{"name":"CategoryTheory.evaluationAdjunctionRight_counit_app_app","module":"Mathlib.CategoryTheory.Adjunction.Evaluation","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : ∀ (a b : C), CategoryTheory.Limits.HasCoproductsOfShape (Quiver.Hom a b) D\nc : C\nY : CategoryTheory.Functor C D\nx✝ : C\n⊢ Eq (((CategoryTheory.evaluationAdjunctionRight D c).counit.app Y).app x✝) (CategoryTheory.Limits.Sigma.desc fun h => Y.map h)","decl":"/-- The adjunction showing that evaluation is a right adjoint. -/\n@[simps! unit_app counit_app_app]\ndef evaluationAdjunctionRight (c : C) : evaluationLeftAdjoint D c ⊣ (evaluation _ _).obj c :=\n  Adjunction.mkOfHomEquiv\n    { homEquiv := fun d F =>\n        { toFun := fun f => Sigma.ι (fun _ => d) (𝟙 _) ≫ f.app c\n          invFun := fun f =>\n            { app := fun _ => Sigma.desc fun h => f ≫ F.map h\n              naturality := by\n                intros\n                dsimp\n                ext\n                simp }\n          left_inv := by\n            intro f\n            ext x\n            dsimp\n            ext g\n            simp only [colimit.ι_desc, Cofan.mk_ι_app, Category.assoc, ← f.naturality,\n              evaluationLeftAdjoint_obj_map, colimit.ι_desc_assoc,\n              Discrete.functor_obj, Cofan.mk_pt, Discrete.natTrans_app, Category.id_comp]\n          right_inv := fun f => by\n            dsimp\n            simp }\n      -- This used to be automatic before https://github.com/leanprover/lean4/pull/2644\n      homEquiv_naturality_right := by intros; dsimp; simp }\n\n"}
{"name":"CategoryTheory.evaluationAdjunctionRight_unit_app","module":"Mathlib.CategoryTheory.Adjunction.Evaluation","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : ∀ (a b : C), CategoryTheory.Limits.HasCoproductsOfShape (Quiver.Hom a b) D\nc : C\nX : D\n⊢ Eq ((CategoryTheory.evaluationAdjunctionRight D c).unit.app X) (CategoryTheory.Limits.Sigma.ι (fun x => X) (CategoryTheory.CategoryStruct.id c))","decl":"/-- The adjunction showing that evaluation is a right adjoint. -/\n@[simps! unit_app counit_app_app]\ndef evaluationAdjunctionRight (c : C) : evaluationLeftAdjoint D c ⊣ (evaluation _ _).obj c :=\n  Adjunction.mkOfHomEquiv\n    { homEquiv := fun d F =>\n        { toFun := fun f => Sigma.ι (fun _ => d) (𝟙 _) ≫ f.app c\n          invFun := fun f =>\n            { app := fun _ => Sigma.desc fun h => f ≫ F.map h\n              naturality := by\n                intros\n                dsimp\n                ext\n                simp }\n          left_inv := by\n            intro f\n            ext x\n            dsimp\n            ext g\n            simp only [colimit.ι_desc, Cofan.mk_ι_app, Category.assoc, ← f.naturality,\n              evaluationLeftAdjoint_obj_map, colimit.ι_desc_assoc,\n              Discrete.functor_obj, Cofan.mk_pt, Discrete.natTrans_app, Category.id_comp]\n          right_inv := fun f => by\n            dsimp\n            simp }\n      -- This used to be automatic before https://github.com/leanprover/lean4/pull/2644\n      homEquiv_naturality_right := by intros; dsimp; simp }\n\n"}
{"name":"CategoryTheory.evaluationIsRightAdjoint","module":"Mathlib.CategoryTheory.Adjunction.Evaluation","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : ∀ (a b : C), CategoryTheory.Limits.HasCoproductsOfShape (Quiver.Hom a b) D\nc : C\n⊢ ((CategoryTheory.evaluation C D).obj c).IsRightAdjoint","decl":"instance evaluationIsRightAdjoint (c : C) : ((evaluation _ D).obj c).IsRightAdjoint  :=\n  ⟨_, ⟨evaluationAdjunctionRight _ _⟩⟩\n\n"}
{"name":"CategoryTheory.NatTrans.mono_iff_mono_app'","module":"Mathlib.CategoryTheory.Adjunction.Evaluation","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : ∀ (a b : C), CategoryTheory.Limits.HasCoproductsOfShape (Quiver.Hom a b) D\nF G : CategoryTheory.Functor C D\nη : Quiver.Hom F G\n⊢ Iff (CategoryTheory.Mono η) (∀ (c : C), CategoryTheory.Mono (η.app c))","decl":"/-- See also the file `CategoryTheory.Limits.FunctorCategory.EpiMono`\nfor a similar result under a `HasPullbacks` assumption. -/\ntheorem NatTrans.mono_iff_mono_app' {F G : C ⥤ D} (η : F ⟶ G) : Mono η ↔ ∀ c, Mono (η.app c) := by\n  constructor\n  · intro h c\n    exact (inferInstance : Mono (((evaluation _ _).obj c).map η))\n  · intro _\n    apply NatTrans.mono_of_mono_app\n\n"}
{"name":"CategoryTheory.evaluationRightAdjoint_map_app","module":"Mathlib.CategoryTheory.Adjunction.Evaluation","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : ∀ (a b : C), CategoryTheory.Limits.HasProductsOfShape (Quiver.Hom a b) D\nc : C\nX✝ Y✝ : D\nf : Quiver.Hom X✝ Y✝\nx✝ : C\n⊢ Eq (((CategoryTheory.evaluationRightAdjoint D c).map f).app x✝) (CategoryTheory.Limits.Pi.lift fun g => CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.π (fun x => X✝) g) f)","decl":"/-- The right adjoint of evaluation. -/\n@[simps]\ndef evaluationRightAdjoint (c : C) : D ⥤ C ⥤ D where\n  obj d :=\n    { obj := fun t => ∏ᶜ fun _ : t ⟶ c => d\n      map := fun f => Pi.lift fun g => Pi.π _ <| f ≫ g }\n  map f :=\n    { app := fun _ => Pi.lift fun g => Pi.π _ g ≫ f\n      naturality := by\n        intros\n        dsimp\n        ext\n        simp }\n\n"}
{"name":"CategoryTheory.evaluationRightAdjoint_obj_map","module":"Mathlib.CategoryTheory.Adjunction.Evaluation","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : ∀ (a b : C), CategoryTheory.Limits.HasProductsOfShape (Quiver.Hom a b) D\nc : C\nd : D\nX✝ Y✝ : C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (((CategoryTheory.evaluationRightAdjoint D c).obj d).map f) (CategoryTheory.Limits.Pi.lift fun g => CategoryTheory.Limits.Pi.π (fun x => d) (CategoryTheory.CategoryStruct.comp f g))","decl":"/-- The right adjoint of evaluation. -/\n@[simps]\ndef evaluationRightAdjoint (c : C) : D ⥤ C ⥤ D where\n  obj d :=\n    { obj := fun t => ∏ᶜ fun _ : t ⟶ c => d\n      map := fun f => Pi.lift fun g => Pi.π _ <| f ≫ g }\n  map f :=\n    { app := fun _ => Pi.lift fun g => Pi.π _ g ≫ f\n      naturality := by\n        intros\n        dsimp\n        ext\n        simp }\n\n"}
{"name":"CategoryTheory.evaluationRightAdjoint_obj_obj","module":"Mathlib.CategoryTheory.Adjunction.Evaluation","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : ∀ (a b : C), CategoryTheory.Limits.HasProductsOfShape (Quiver.Hom a b) D\nc : C\nd : D\nt : C\n⊢ Eq (((CategoryTheory.evaluationRightAdjoint D c).obj d).obj t) (CategoryTheory.Limits.piObj fun x => d)","decl":"/-- The right adjoint of evaluation. -/\n@[simps]\ndef evaluationRightAdjoint (c : C) : D ⥤ C ⥤ D where\n  obj d :=\n    { obj := fun t => ∏ᶜ fun _ : t ⟶ c => d\n      map := fun f => Pi.lift fun g => Pi.π _ <| f ≫ g }\n  map f :=\n    { app := fun _ => Pi.lift fun g => Pi.π _ g ≫ f\n      naturality := by\n        intros\n        dsimp\n        ext\n        simp }\n\n"}
{"name":"CategoryTheory.evaluationAdjunctionLeft_unit_app_app","module":"Mathlib.CategoryTheory.Adjunction.Evaluation","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : ∀ (a b : C), CategoryTheory.Limits.HasProductsOfShape (Quiver.Hom a b) D\nc : C\nX : CategoryTheory.Functor C D\nx✝ : C\n⊢ Eq (((CategoryTheory.evaluationAdjunctionLeft D c).unit.app X).app x✝) (CategoryTheory.Limits.Pi.lift fun g => X.map g)","decl":"/-- The adjunction showing that evaluation is a left adjoint. -/\n@[simps! unit_app_app counit_app]\ndef evaluationAdjunctionLeft (c : C) : (evaluation _ _).obj c ⊣ evaluationRightAdjoint D c :=\n  Adjunction.mkOfHomEquiv\n    { homEquiv := fun F d =>\n        { toFun := fun f =>\n            { app := fun _ => Pi.lift fun g => F.map g ≫ f\n              naturality := by\n                intros\n                dsimp\n                ext\n                simp }\n          invFun := fun f => f.app _ ≫ Pi.π _ (𝟙 _)\n          left_inv := fun f => by\n            dsimp\n            simp\n          right_inv := by\n            intro f\n            ext x\n            dsimp\n            ext g\n            simp only [Discrete.functor_obj, NatTrans.naturality_assoc,\n              evaluationRightAdjoint_obj_obj, evaluationRightAdjoint_obj_map, limit.lift_π,\n              Fan.mk_pt, Fan.mk_π_app, Discrete.natTrans_app, Category.comp_id] } }\n\n"}
{"name":"CategoryTheory.evaluationAdjunctionLeft_counit_app","module":"Mathlib.CategoryTheory.Adjunction.Evaluation","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : ∀ (a b : C), CategoryTheory.Limits.HasProductsOfShape (Quiver.Hom a b) D\nc : C\nY : D\n⊢ Eq ((CategoryTheory.evaluationAdjunctionLeft D c).counit.app Y) (CategoryTheory.Limits.Pi.π (fun x => Y) (CategoryTheory.CategoryStruct.id c))","decl":"/-- The adjunction showing that evaluation is a left adjoint. -/\n@[simps! unit_app_app counit_app]\ndef evaluationAdjunctionLeft (c : C) : (evaluation _ _).obj c ⊣ evaluationRightAdjoint D c :=\n  Adjunction.mkOfHomEquiv\n    { homEquiv := fun F d =>\n        { toFun := fun f =>\n            { app := fun _ => Pi.lift fun g => F.map g ≫ f\n              naturality := by\n                intros\n                dsimp\n                ext\n                simp }\n          invFun := fun f => f.app _ ≫ Pi.π _ (𝟙 _)\n          left_inv := fun f => by\n            dsimp\n            simp\n          right_inv := by\n            intro f\n            ext x\n            dsimp\n            ext g\n            simp only [Discrete.functor_obj, NatTrans.naturality_assoc,\n              evaluationRightAdjoint_obj_obj, evaluationRightAdjoint_obj_map, limit.lift_π,\n              Fan.mk_pt, Fan.mk_π_app, Discrete.natTrans_app, Category.comp_id] } }\n\n"}
{"name":"CategoryTheory.evaluationIsLeftAdjoint","module":"Mathlib.CategoryTheory.Adjunction.Evaluation","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : ∀ (a b : C), CategoryTheory.Limits.HasProductsOfShape (Quiver.Hom a b) D\nc : C\n⊢ ((CategoryTheory.evaluation C D).obj c).IsLeftAdjoint","decl":"instance evaluationIsLeftAdjoint (c : C) : ((evaluation _ D).obj c).IsLeftAdjoint :=\n  ⟨_, ⟨evaluationAdjunctionLeft _ _⟩⟩\n\n"}
{"name":"CategoryTheory.NatTrans.epi_iff_epi_app'","module":"Mathlib.CategoryTheory.Adjunction.Evaluation","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : ∀ (a b : C), CategoryTheory.Limits.HasProductsOfShape (Quiver.Hom a b) D\nF G : CategoryTheory.Functor C D\nη : Quiver.Hom F G\n⊢ Iff (CategoryTheory.Epi η) (∀ (c : C), CategoryTheory.Epi (η.app c))","decl":"/-- See also the file `CategoryTheory.Limits.FunctorCategory.EpiMono`\nfor a similar result under a `HasPushouts` assumption. -/\ntheorem NatTrans.epi_iff_epi_app' {F G : C ⥤ D} (η : F ⟶ G) : Epi η ↔ ∀ c, Epi (η.app c) := by\n  constructor\n  · intro h c\n    exact (inferInstance : Epi (((evaluation _ _).obj c).map η))\n  · intros\n    apply NatTrans.epi_of_epi_app\n\n"}
