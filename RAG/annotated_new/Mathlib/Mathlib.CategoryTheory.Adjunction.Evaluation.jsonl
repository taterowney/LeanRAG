{"name":"CategoryTheory.evaluationLeftAdjoint_obj_obj","module":"Mathlib.CategoryTheory.Adjunction.Evaluation","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù : ‚àÄ (a b : C), CategoryTheory.Limits.HasCoproductsOfShape (Quiver.Hom a b) D\nc : C\nd : D\nt : C\n‚ä¢ Eq (((CategoryTheory.evaluationLeftAdjoint D c).obj d).obj t) (CategoryTheory.Limits.sigmaObj fun x => d)","decl":"/-- The left adjoint of evaluation. -/\n@[simps]\ndef evaluationLeftAdjoint (c : C) : D ‚•§ C ‚•§ D where\n  obj d :=\n    { obj := fun t => ‚àê fun _ : c ‚ü∂ t => d\n      map := fun f => Sigma.desc fun g => (Sigma.Œπ fun _ => d) <| g ‚â´ f}\n  map {_ d‚ÇÇ} f :=\n    { app := fun _ => Sigma.desc fun h => f ‚â´ Sigma.Œπ (fun _ => d‚ÇÇ) h\n      naturality := by\n        intros\n        dsimp\n        ext\n        simp }\n\n"}
{"name":"CategoryTheory.evaluationLeftAdjoint_obj_map","module":"Mathlib.CategoryTheory.Adjunction.Evaluation","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù : ‚àÄ (a b : C), CategoryTheory.Limits.HasCoproductsOfShape (Quiver.Hom a b) D\nc : C\nd : D\nX‚úù Y‚úù : C\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (((CategoryTheory.evaluationLeftAdjoint D c).obj d).map f) (CategoryTheory.Limits.Sigma.desc fun g => CategoryTheory.Limits.Sigma.Œπ (fun x => d) (CategoryTheory.CategoryStruct.comp g f))","decl":"/-- The left adjoint of evaluation. -/\n@[simps]\ndef evaluationLeftAdjoint (c : C) : D ‚•§ C ‚•§ D where\n  obj d :=\n    { obj := fun t => ‚àê fun _ : c ‚ü∂ t => d\n      map := fun f => Sigma.desc fun g => (Sigma.Œπ fun _ => d) <| g ‚â´ f}\n  map {_ d‚ÇÇ} f :=\n    { app := fun _ => Sigma.desc fun h => f ‚â´ Sigma.Œπ (fun _ => d‚ÇÇ) h\n      naturality := by\n        intros\n        dsimp\n        ext\n        simp }\n\n"}
{"name":"CategoryTheory.evaluationLeftAdjoint_map_app","module":"Mathlib.CategoryTheory.Adjunction.Evaluation","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù : ‚àÄ (a b : C), CategoryTheory.Limits.HasCoproductsOfShape (Quiver.Hom a b) D\nc : C\nx‚úù¬π d‚ÇÇ : D\nf : Quiver.Hom x‚úù¬π d‚ÇÇ\nx‚úù : C\n‚ä¢ Eq (((CategoryTheory.evaluationLeftAdjoint D c).map f).app x‚úù) (CategoryTheory.Limits.Sigma.desc fun h => CategoryTheory.CategoryStruct.comp f (CategoryTheory.Limits.Sigma.Œπ (fun x => d‚ÇÇ) h))","decl":"/-- The left adjoint of evaluation. -/\n@[simps]\ndef evaluationLeftAdjoint (c : C) : D ‚•§ C ‚•§ D where\n  obj d :=\n    { obj := fun t => ‚àê fun _ : c ‚ü∂ t => d\n      map := fun f => Sigma.desc fun g => (Sigma.Œπ fun _ => d) <| g ‚â´ f}\n  map {_ d‚ÇÇ} f :=\n    { app := fun _ => Sigma.desc fun h => f ‚â´ Sigma.Œπ (fun _ => d‚ÇÇ) h\n      naturality := by\n        intros\n        dsimp\n        ext\n        simp }\n\n"}
{"name":"CategoryTheory.evaluationAdjunctionRight_counit_app_app","module":"Mathlib.CategoryTheory.Adjunction.Evaluation","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù : ‚àÄ (a b : C), CategoryTheory.Limits.HasCoproductsOfShape (Quiver.Hom a b) D\nc : C\nY : CategoryTheory.Functor C D\nx‚úù : C\n‚ä¢ Eq (((CategoryTheory.evaluationAdjunctionRight D c).counit.app Y).app x‚úù) (CategoryTheory.Limits.Sigma.desc fun h => Y.map h)","decl":"/-- The adjunction showing that evaluation is a right adjoint. -/\n@[simps! unit_app counit_app_app]\ndef evaluationAdjunctionRight (c : C) : evaluationLeftAdjoint D c ‚ä£ (evaluation _ _).obj c :=\n  Adjunction.mkOfHomEquiv\n    { homEquiv := fun d F =>\n        { toFun := fun f => Sigma.Œπ (fun _ => d) (ùüô _) ‚â´ f.app c\n          invFun := fun f =>\n            { app := fun _ => Sigma.desc fun h => f ‚â´ F.map h\n              naturality := by\n                intros\n                dsimp\n                ext\n                simp }\n          left_inv := by\n            intro f\n            ext x\n            dsimp\n            ext g\n            simp only [colimit.Œπ_desc, Cofan.mk_Œπ_app, Category.assoc, ‚Üê f.naturality,\n              evaluationLeftAdjoint_obj_map, colimit.Œπ_desc_assoc,\n              Discrete.functor_obj, Cofan.mk_pt, Discrete.natTrans_app, Category.id_comp]\n          right_inv := fun f => by\n            dsimp\n            simp }\n      -- This used to be automatic before https://github.com/leanprover/lean4/pull/2644\n      homEquiv_naturality_right := by intros; dsimp; simp }\n\n"}
{"name":"CategoryTheory.evaluationAdjunctionRight_unit_app","module":"Mathlib.CategoryTheory.Adjunction.Evaluation","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù : ‚àÄ (a b : C), CategoryTheory.Limits.HasCoproductsOfShape (Quiver.Hom a b) D\nc : C\nX : D\n‚ä¢ Eq ((CategoryTheory.evaluationAdjunctionRight D c).unit.app X) (CategoryTheory.Limits.Sigma.Œπ (fun x => X) (CategoryTheory.CategoryStruct.id c))","decl":"/-- The adjunction showing that evaluation is a right adjoint. -/\n@[simps! unit_app counit_app_app]\ndef evaluationAdjunctionRight (c : C) : evaluationLeftAdjoint D c ‚ä£ (evaluation _ _).obj c :=\n  Adjunction.mkOfHomEquiv\n    { homEquiv := fun d F =>\n        { toFun := fun f => Sigma.Œπ (fun _ => d) (ùüô _) ‚â´ f.app c\n          invFun := fun f =>\n            { app := fun _ => Sigma.desc fun h => f ‚â´ F.map h\n              naturality := by\n                intros\n                dsimp\n                ext\n                simp }\n          left_inv := by\n            intro f\n            ext x\n            dsimp\n            ext g\n            simp only [colimit.Œπ_desc, Cofan.mk_Œπ_app, Category.assoc, ‚Üê f.naturality,\n              evaluationLeftAdjoint_obj_map, colimit.Œπ_desc_assoc,\n              Discrete.functor_obj, Cofan.mk_pt, Discrete.natTrans_app, Category.id_comp]\n          right_inv := fun f => by\n            dsimp\n            simp }\n      -- This used to be automatic before https://github.com/leanprover/lean4/pull/2644\n      homEquiv_naturality_right := by intros; dsimp; simp }\n\n"}
{"name":"CategoryTheory.evaluationIsRightAdjoint","module":"Mathlib.CategoryTheory.Adjunction.Evaluation","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù : ‚àÄ (a b : C), CategoryTheory.Limits.HasCoproductsOfShape (Quiver.Hom a b) D\nc : C\n‚ä¢ ((CategoryTheory.evaluation C D).obj c).IsRightAdjoint","decl":"instance evaluationIsRightAdjoint (c : C) : ((evaluation _ D).obj c).IsRightAdjoint  :=\n  ‚ü®_, ‚ü®evaluationAdjunctionRight _ _‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.NatTrans.mono_iff_mono_app'","module":"Mathlib.CategoryTheory.Adjunction.Evaluation","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù : ‚àÄ (a b : C), CategoryTheory.Limits.HasCoproductsOfShape (Quiver.Hom a b) D\nF G : CategoryTheory.Functor C D\nŒ∑ : Quiver.Hom F G\n‚ä¢ Iff (CategoryTheory.Mono Œ∑) (‚àÄ (c : C), CategoryTheory.Mono (Œ∑.app c))","decl":"/-- See also the file `CategoryTheory.Limits.FunctorCategory.EpiMono`\nfor a similar result under a `HasPullbacks` assumption. -/\ntheorem NatTrans.mono_iff_mono_app' {F G : C ‚•§ D} (Œ∑ : F ‚ü∂ G) : Mono Œ∑ ‚Üî ‚àÄ c, Mono (Œ∑.app c) := by\n  constructor\n  ¬∑ intro h c\n    exact (inferInstance : Mono (((evaluation _ _).obj c).map Œ∑))\n  ¬∑ intro _\n    apply NatTrans.mono_of_mono_app\n\n"}
{"name":"CategoryTheory.evaluationRightAdjoint_map_app","module":"Mathlib.CategoryTheory.Adjunction.Evaluation","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù : ‚àÄ (a b : C), CategoryTheory.Limits.HasProductsOfShape (Quiver.Hom a b) D\nc : C\nX‚úù Y‚úù : D\nf : Quiver.Hom X‚úù Y‚úù\nx‚úù : C\n‚ä¢ Eq (((CategoryTheory.evaluationRightAdjoint D c).map f).app x‚úù) (CategoryTheory.Limits.Pi.lift fun g => CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.œÄ (fun x => X‚úù) g) f)","decl":"/-- The right adjoint of evaluation. -/\n@[simps]\ndef evaluationRightAdjoint (c : C) : D ‚•§ C ‚•§ D where\n  obj d :=\n    { obj := fun t => ‚àè·∂ú fun _ : t ‚ü∂ c => d\n      map := fun f => Pi.lift fun g => Pi.œÄ _ <| f ‚â´ g }\n  map f :=\n    { app := fun _ => Pi.lift fun g => Pi.œÄ _ g ‚â´ f\n      naturality := by\n        intros\n        dsimp\n        ext\n        simp }\n\n"}
{"name":"CategoryTheory.evaluationRightAdjoint_obj_map","module":"Mathlib.CategoryTheory.Adjunction.Evaluation","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù : ‚àÄ (a b : C), CategoryTheory.Limits.HasProductsOfShape (Quiver.Hom a b) D\nc : C\nd : D\nX‚úù Y‚úù : C\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (((CategoryTheory.evaluationRightAdjoint D c).obj d).map f) (CategoryTheory.Limits.Pi.lift fun g => CategoryTheory.Limits.Pi.œÄ (fun x => d) (CategoryTheory.CategoryStruct.comp f g))","decl":"/-- The right adjoint of evaluation. -/\n@[simps]\ndef evaluationRightAdjoint (c : C) : D ‚•§ C ‚•§ D where\n  obj d :=\n    { obj := fun t => ‚àè·∂ú fun _ : t ‚ü∂ c => d\n      map := fun f => Pi.lift fun g => Pi.œÄ _ <| f ‚â´ g }\n  map f :=\n    { app := fun _ => Pi.lift fun g => Pi.œÄ _ g ‚â´ f\n      naturality := by\n        intros\n        dsimp\n        ext\n        simp }\n\n"}
{"name":"CategoryTheory.evaluationRightAdjoint_obj_obj","module":"Mathlib.CategoryTheory.Adjunction.Evaluation","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù : ‚àÄ (a b : C), CategoryTheory.Limits.HasProductsOfShape (Quiver.Hom a b) D\nc : C\nd : D\nt : C\n‚ä¢ Eq (((CategoryTheory.evaluationRightAdjoint D c).obj d).obj t) (CategoryTheory.Limits.piObj fun x => d)","decl":"/-- The right adjoint of evaluation. -/\n@[simps]\ndef evaluationRightAdjoint (c : C) : D ‚•§ C ‚•§ D where\n  obj d :=\n    { obj := fun t => ‚àè·∂ú fun _ : t ‚ü∂ c => d\n      map := fun f => Pi.lift fun g => Pi.œÄ _ <| f ‚â´ g }\n  map f :=\n    { app := fun _ => Pi.lift fun g => Pi.œÄ _ g ‚â´ f\n      naturality := by\n        intros\n        dsimp\n        ext\n        simp }\n\n"}
{"name":"CategoryTheory.evaluationAdjunctionLeft_unit_app_app","module":"Mathlib.CategoryTheory.Adjunction.Evaluation","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù : ‚àÄ (a b : C), CategoryTheory.Limits.HasProductsOfShape (Quiver.Hom a b) D\nc : C\nX : CategoryTheory.Functor C D\nx‚úù : C\n‚ä¢ Eq (((CategoryTheory.evaluationAdjunctionLeft D c).unit.app X).app x‚úù) (CategoryTheory.Limits.Pi.lift fun g => X.map g)","decl":"/-- The adjunction showing that evaluation is a left adjoint. -/\n@[simps! unit_app_app counit_app]\ndef evaluationAdjunctionLeft (c : C) : (evaluation _ _).obj c ‚ä£ evaluationRightAdjoint D c :=\n  Adjunction.mkOfHomEquiv\n    { homEquiv := fun F d =>\n        { toFun := fun f =>\n            { app := fun _ => Pi.lift fun g => F.map g ‚â´ f\n              naturality := by\n                intros\n                dsimp\n                ext\n                simp }\n          invFun := fun f => f.app _ ‚â´ Pi.œÄ _ (ùüô _)\n          left_inv := fun f => by\n            dsimp\n            simp\n          right_inv := by\n            intro f\n            ext x\n            dsimp\n            ext g\n            simp only [Discrete.functor_obj, NatTrans.naturality_assoc,\n              evaluationRightAdjoint_obj_obj, evaluationRightAdjoint_obj_map, limit.lift_œÄ,\n              Fan.mk_pt, Fan.mk_œÄ_app, Discrete.natTrans_app, Category.comp_id] } }\n\n"}
{"name":"CategoryTheory.evaluationAdjunctionLeft_counit_app","module":"Mathlib.CategoryTheory.Adjunction.Evaluation","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù : ‚àÄ (a b : C), CategoryTheory.Limits.HasProductsOfShape (Quiver.Hom a b) D\nc : C\nY : D\n‚ä¢ Eq ((CategoryTheory.evaluationAdjunctionLeft D c).counit.app Y) (CategoryTheory.Limits.Pi.œÄ (fun x => Y) (CategoryTheory.CategoryStruct.id c))","decl":"/-- The adjunction showing that evaluation is a left adjoint. -/\n@[simps! unit_app_app counit_app]\ndef evaluationAdjunctionLeft (c : C) : (evaluation _ _).obj c ‚ä£ evaluationRightAdjoint D c :=\n  Adjunction.mkOfHomEquiv\n    { homEquiv := fun F d =>\n        { toFun := fun f =>\n            { app := fun _ => Pi.lift fun g => F.map g ‚â´ f\n              naturality := by\n                intros\n                dsimp\n                ext\n                simp }\n          invFun := fun f => f.app _ ‚â´ Pi.œÄ _ (ùüô _)\n          left_inv := fun f => by\n            dsimp\n            simp\n          right_inv := by\n            intro f\n            ext x\n            dsimp\n            ext g\n            simp only [Discrete.functor_obj, NatTrans.naturality_assoc,\n              evaluationRightAdjoint_obj_obj, evaluationRightAdjoint_obj_map, limit.lift_œÄ,\n              Fan.mk_pt, Fan.mk_œÄ_app, Discrete.natTrans_app, Category.comp_id] } }\n\n"}
{"name":"CategoryTheory.evaluationIsLeftAdjoint","module":"Mathlib.CategoryTheory.Adjunction.Evaluation","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù : ‚àÄ (a b : C), CategoryTheory.Limits.HasProductsOfShape (Quiver.Hom a b) D\nc : C\n‚ä¢ ((CategoryTheory.evaluation C D).obj c).IsLeftAdjoint","decl":"instance evaluationIsLeftAdjoint (c : C) : ((evaluation _ D).obj c).IsLeftAdjoint :=\n  ‚ü®_, ‚ü®evaluationAdjunctionLeft _ _‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.NatTrans.epi_iff_epi_app'","module":"Mathlib.CategoryTheory.Adjunction.Evaluation","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù : ‚àÄ (a b : C), CategoryTheory.Limits.HasProductsOfShape (Quiver.Hom a b) D\nF G : CategoryTheory.Functor C D\nŒ∑ : Quiver.Hom F G\n‚ä¢ Iff (CategoryTheory.Epi Œ∑) (‚àÄ (c : C), CategoryTheory.Epi (Œ∑.app c))","decl":"/-- See also the file `CategoryTheory.Limits.FunctorCategory.EpiMono`\nfor a similar result under a `HasPushouts` assumption. -/\ntheorem NatTrans.epi_iff_epi_app' {F G : C ‚•§ D} (Œ∑ : F ‚ü∂ G) : Epi Œ∑ ‚Üî ‚àÄ c, Epi (Œ∑.app c) := by\n  constructor\n  ¬∑ intro h c\n    exact (inferInstance : Epi (((evaluation _ _).obj c).map Œ∑))\n  ¬∑ intros\n    apply NatTrans.epi_of_epi_app\n\n"}
