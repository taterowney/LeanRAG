{"name":"T0Space.t0","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u\ninst‚úù : TopologicalSpace X\nself : T0Space X\nx y : X\na‚úù : Inseparable x y\n‚ä¢ Eq x y","decl":"/-- A T‚ÇÄ space, also known as a Kolmogorov space, is a topological space such that for every pair\n`x ‚â† y`, there is an open set containing one but not the other. We formulate the definition in terms\nof the `Inseparable` relation. -/\nclass T0Space (X : Type u) [TopologicalSpace X] : Prop where\n  /-- Two inseparable points in a T‚ÇÄ space are equal. -/\n  t0 : ‚àÄ ‚¶Éx y : X‚¶Ñ, Inseparable x y ‚Üí x = y\n\n"}
{"name":"t0Space_iff_inseparable","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u\ninst‚úù : TopologicalSpace X\n‚ä¢ Iff (T0Space X) (‚àÄ (x y : X), Inseparable x y ‚Üí Eq x y)","decl":"theorem t0Space_iff_inseparable (X : Type u) [TopologicalSpace X] :\n    T0Space X ‚Üî ‚àÄ x y : X, Inseparable x y ‚Üí x = y :=\n  ‚ü®fun ‚ü®h‚ü© => h, fun h => ‚ü®h‚ü©‚ü©\n\n"}
{"name":"t0Space_iff_not_inseparable","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u\ninst‚úù : TopologicalSpace X\n‚ä¢ Iff (T0Space X) (Pairwise fun x y => Not (Inseparable x y))","decl":"theorem t0Space_iff_not_inseparable (X : Type u) [TopologicalSpace X] :\n    T0Space X ‚Üî Pairwise fun x y : X => ¬¨Inseparable x y := by\n  simp only [t0Space_iff_inseparable, Ne, not_imp_not, Pairwise]\n\n"}
{"name":"Inseparable.eq","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T0Space X\nx y : X\nh : Inseparable x y\n‚ä¢ Eq x y","decl":"theorem Inseparable.eq [T0Space X] {x y : X} (h : Inseparable x y) : x = y :=\n  T0Space.t0 h\n\n"}
{"name":"Topology.IsInducing.injective","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : T0Space X\nf : X ‚Üí Y\nhf : Topology.IsInducing f\n‚ä¢ Function.Injective f","decl":"/-- A topology inducing map from a T‚ÇÄ space is injective. -/\nprotected theorem Topology.IsInducing.injective [TopologicalSpace Y] [T0Space X] {f : X ‚Üí Y}\n    (hf : IsInducing f) : Injective f := fun _ _ h =>\n  (hf.inseparable_iff.1 <| .of_eq h).eq\n\n"}
{"name":"Inducing.injective","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : T0Space X\nf : X ‚Üí Y\nhf : Topology.IsInducing f\n‚ä¢ Function.Injective f","decl":"@[deprecated (since := \"2024-10-28\")] alias Inducing.injective := IsInducing.injective\n\n"}
{"name":"Topology.IsInducing.isEmbedding","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : T0Space X\nf : X ‚Üí Y\nhf : Topology.IsInducing f\n‚ä¢ Topology.IsEmbedding f","decl":"/-- A topology inducing map from a T‚ÇÄ space is a topological embedding. -/\nprotected theorem Topology.IsInducing.isEmbedding [TopologicalSpace Y] [T0Space X] {f : X ‚Üí Y}\n    (hf : IsInducing f) : IsEmbedding f :=\n  ‚ü®hf, hf.injective‚ü©\n\n"}
{"name":"Inducing.isEmbedding","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : T0Space X\nf : X ‚Üí Y\nhf : Topology.IsInducing f\n‚ä¢ Topology.IsEmbedding f","decl":"@[deprecated (since := \"2024-10-28\")] alias Inducing.isEmbedding := IsInducing.isEmbedding\n\n"}
{"name":"Inducing.embedding","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : T0Space X\nf : X ‚Üí Y\nhf : Topology.IsInducing f\n‚ä¢ Topology.IsEmbedding f","decl":"@[deprecated (since := \"2024-10-26\")]\nalias Inducing.embedding := Topology.IsInducing.isEmbedding\n\n"}
{"name":"isEmbedding_iff_isInducing","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : T0Space X\nf : X ‚Üí Y\n‚ä¢ Iff (Topology.IsEmbedding f) (Topology.IsInducing f)","decl":"lemma isEmbedding_iff_isInducing [TopologicalSpace Y] [T0Space X] {f : X ‚Üí Y} :\n    IsEmbedding f ‚Üî IsInducing f :=\n  ‚ü®IsEmbedding.isInducing, IsInducing.isEmbedding‚ü©\n\n"}
{"name":"isEmbedding_iff_inducing","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : T0Space X\nf : X ‚Üí Y\n‚ä¢ Iff (Topology.IsEmbedding f) (Topology.IsInducing f)","decl":"@[deprecated (since := \"2024-10-28\")] alias isEmbedding_iff_inducing := isEmbedding_iff_isInducing\n\n"}
{"name":"embedding_iff_inducing","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : T0Space X\nf : X ‚Üí Y\n‚ä¢ Iff (Topology.IsEmbedding f) (Topology.IsInducing f)","decl":"@[deprecated (since := \"2024-10-26\")]\nalias embedding_iff_inducing := isEmbedding_iff_isInducing\n\n"}
{"name":"t0Space_iff_nhds_injective","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u\ninst‚úù : TopologicalSpace X\n‚ä¢ Iff (T0Space X) (Function.Injective nhds)","decl":"theorem t0Space_iff_nhds_injective (X : Type u) [TopologicalSpace X] :\n    T0Space X ‚Üî Injective (ùìù : X ‚Üí Filter X) :=\n  t0Space_iff_inseparable X\n\n"}
{"name":"nhds_injective","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T0Space X\n‚ä¢ Function.Injective nhds","decl":"theorem nhds_injective [T0Space X] : Injective (ùìù : X ‚Üí Filter X) :=\n  (t0Space_iff_nhds_injective X).1 ‚Äπ_‚Ä∫\n\n"}
{"name":"inseparable_iff_eq","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T0Space X\nx y : X\n‚ä¢ Iff (Inseparable x y) (Eq x y)","decl":"theorem inseparable_iff_eq [T0Space X] {x y : X} : Inseparable x y ‚Üî x = y :=\n  nhds_injective.eq_iff\n\n"}
{"name":"nhds_eq_nhds_iff","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T0Space X\na b : X\n‚ä¢ Iff (Eq (nhds a) (nhds b)) (Eq a b)","decl":"@[simp]\ntheorem nhds_eq_nhds_iff [T0Space X] {a b : X} : ùìù a = ùìù b ‚Üî a = b :=\n  nhds_injective.eq_iff\n\n"}
{"name":"inseparable_eq_eq","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T0Space X\n‚ä¢ Eq Inseparable Eq","decl":"@[simp]\ntheorem inseparable_eq_eq [T0Space X] : Inseparable = @Eq X :=\n  funext‚ÇÇ fun _ _ => propext inseparable_iff_eq\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.inseparable_iff","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nb : Set (Set X)\nhb : TopologicalSpace.IsTopologicalBasis b\nx y : X\n‚ä¢ Iff (Inseparable x y) (‚àÄ (s : Set X), Membership.mem b s ‚Üí Iff (Membership.mem s x) (Membership.mem s y))","decl":"theorem TopologicalSpace.IsTopologicalBasis.inseparable_iff {b : Set (Set X)}\n    (hb : IsTopologicalBasis b) {x y : X} : Inseparable x y ‚Üî ‚àÄ s ‚àà b, (x ‚àà s ‚Üî y ‚àà s) :=\n  ‚ü®fun h _ hs ‚Ü¶ inseparable_iff_forall_isOpen.1 h _ (hb.isOpen hs),\n    fun h ‚Ü¶ hb.nhds_hasBasis.eq_of_same_basis <| by\n      convert hb.nhds_hasBasis using 2\n      exact and_congr_right (h _)‚ü©\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.eq_iff","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T0Space X\nb : Set (Set X)\nhb : TopologicalSpace.IsTopologicalBasis b\nx y : X\n‚ä¢ Iff (Eq x y) (‚àÄ (s : Set X), Membership.mem b s ‚Üí Iff (Membership.mem s x) (Membership.mem s y))","decl":"theorem TopologicalSpace.IsTopologicalBasis.eq_iff [T0Space X] {b : Set (Set X)}\n    (hb : IsTopologicalBasis b) {x y : X} : x = y ‚Üî ‚àÄ s ‚àà b, (x ‚àà s ‚Üî y ‚àà s) :=\n  inseparable_iff_eq.symm.trans hb.inseparable_iff\n\n"}
{"name":"t0Space_iff_exists_isOpen_xor'_mem","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u\ninst‚úù : TopologicalSpace X\n‚ä¢ Iff (T0Space X) (Pairwise fun x y => Exists fun U => And (IsOpen U) (Xor' (Membership.mem U x) (Membership.mem U y)))","decl":"theorem t0Space_iff_exists_isOpen_xor'_mem (X : Type u) [TopologicalSpace X] :\n    T0Space X ‚Üî Pairwise fun x y => ‚àÉ U : Set X, IsOpen U ‚àß Xor' (x ‚àà U) (y ‚àà U) := by\n  simp only [t0Space_iff_not_inseparable, xor_iff_not_iff, not_forall, exists_prop,\n    inseparable_iff_forall_isOpen, Pairwise]\n\n"}
{"name":"exists_isOpen_xor'_mem","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T0Space X\nx y : X\nh : Ne x y\n‚ä¢ Exists fun U => And (IsOpen U) (Xor' (Membership.mem U x) (Membership.mem U y))","decl":"theorem exists_isOpen_xor'_mem [T0Space X] {x y : X} (h : x ‚â† y) :\n    ‚àÉ U : Set X, IsOpen U ‚àß Xor' (x ‚àà U) (y ‚àà U) :=\n  (t0Space_iff_exists_isOpen_xor'_mem X).1 ‚Äπ_‚Ä∫ h\n\n"}
{"name":"SeparationQuotient.instT0Space","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\n‚ä¢ T0Space (SeparationQuotient X)","decl":"instance SeparationQuotient.instT0Space : T0Space (SeparationQuotient X) :=\n  ‚ü®fun x y => Quotient.inductionOn‚ÇÇ' x y fun _ _ h =>\n    SeparationQuotient.mk_eq_mk.2 <| SeparationQuotient.isInducing_mk.inseparable_iff.1 h‚ü©\n\n"}
{"name":"minimal_nonempty_closed_subsingleton","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T0Space X\ns : Set X\nhs : IsClosed s\nhmin : ‚àÄ (t : Set X), HasSubset.Subset t s ‚Üí t.Nonempty ‚Üí IsClosed t ‚Üí Eq t s\n‚ä¢ s.Subsingleton","decl":"theorem minimal_nonempty_closed_subsingleton [T0Space X] {s : Set X} (hs : IsClosed s)\n    (hmin : ‚àÄ t, t ‚äÜ s ‚Üí t.Nonempty ‚Üí IsClosed t ‚Üí t = s) : s.Subsingleton := by\n  refine fun x hx y hy => of_not_not fun hxy => ?_\n  rcases exists_isOpen_xor'_mem hxy with ‚ü®U, hUo, hU‚ü©\n  wlog h : x ‚àà U ‚àß y ‚àâ U\n  ¬∑ refine this hs hmin y hy x hx (Ne.symm hxy) U hUo hU.symm (hU.resolve_left h)\n  cases' h with hxU hyU\n  have : s \\ U = s := hmin (s \\ U) diff_subset ‚ü®y, hy, hyU‚ü© (hs.sdiff hUo)\n  exact (this.symm.subset hx).2 hxU\n\n"}
{"name":"minimal_nonempty_closed_eq_singleton","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T0Space X\ns : Set X\nhs : IsClosed s\nhne : s.Nonempty\nhmin : ‚àÄ (t : Set X), HasSubset.Subset t s ‚Üí t.Nonempty ‚Üí IsClosed t ‚Üí Eq t s\n‚ä¢ Exists fun x => Eq s (Singleton.singleton x)","decl":"theorem minimal_nonempty_closed_eq_singleton [T0Space X] {s : Set X} (hs : IsClosed s)\n    (hne : s.Nonempty) (hmin : ‚àÄ t, t ‚äÜ s ‚Üí t.Nonempty ‚Üí IsClosed t ‚Üí t = s) : ‚àÉ x, s = {x} :=\n  exists_eq_singleton_iff_nonempty_subsingleton.2\n    ‚ü®hne, minimal_nonempty_closed_subsingleton hs hmin‚ü©\n\n"}
{"name":"IsClosed.exists_closed_singleton","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : T0Space X\ninst‚úù : CompactSpace X\nS : Set X\nhS : IsClosed S\nhne : S.Nonempty\n‚ä¢ Exists fun x => And (Membership.mem S x) (IsClosed (Singleton.singleton x))","decl":"/-- Given a closed set `S` in a compact T‚ÇÄ space, there is some `x ‚àà S` such that `{x}` is\nclosed. -/\ntheorem IsClosed.exists_closed_singleton [T0Space X] [CompactSpace X] {S : Set X}\n    (hS : IsClosed S) (hne : S.Nonempty) : ‚àÉ x : X, x ‚àà S ‚àß IsClosed ({x} : Set X) := by\n  obtain ‚ü®V, Vsub, Vne, Vcls, hV‚ü© := hS.exists_minimal_nonempty_closed_subset hne\n  rcases minimal_nonempty_closed_eq_singleton Vcls Vne hV with ‚ü®x, rfl‚ü©\n  exact ‚ü®x, Vsub (mem_singleton x), Vcls‚ü©\n\n"}
{"name":"minimal_nonempty_open_subsingleton","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T0Space X\ns : Set X\nhs : IsOpen s\nhmin : ‚àÄ (t : Set X), HasSubset.Subset t s ‚Üí t.Nonempty ‚Üí IsOpen t ‚Üí Eq t s\n‚ä¢ s.Subsingleton","decl":"theorem minimal_nonempty_open_subsingleton [T0Space X] {s : Set X} (hs : IsOpen s)\n    (hmin : ‚àÄ t, t ‚äÜ s ‚Üí t.Nonempty ‚Üí IsOpen t ‚Üí t = s) : s.Subsingleton := by\n  refine fun x hx y hy => of_not_not fun hxy => ?_\n  rcases exists_isOpen_xor'_mem hxy with ‚ü®U, hUo, hU‚ü©\n  wlog h : x ‚àà U ‚àß y ‚àâ U\n  ¬∑ exact this hs hmin y hy x hx (Ne.symm hxy) U hUo hU.symm (hU.resolve_left h)\n  cases' h with hxU hyU\n  have : s ‚à© U = s := hmin (s ‚à© U) inter_subset_left ‚ü®x, hx, hxU‚ü© (hs.inter hUo)\n  exact hyU (this.symm.subset hy).2\n\n"}
{"name":"minimal_nonempty_open_eq_singleton","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T0Space X\ns : Set X\nhs : IsOpen s\nhne : s.Nonempty\nhmin : ‚àÄ (t : Set X), HasSubset.Subset t s ‚Üí t.Nonempty ‚Üí IsOpen t ‚Üí Eq t s\n‚ä¢ Exists fun x => Eq s (Singleton.singleton x)","decl":"theorem minimal_nonempty_open_eq_singleton [T0Space X] {s : Set X} (hs : IsOpen s)\n    (hne : s.Nonempty) (hmin : ‚àÄ t, t ‚äÜ s ‚Üí t.Nonempty ‚Üí IsOpen t ‚Üí t = s) : ‚àÉ x, s = {x} :=\n  exists_eq_singleton_iff_nonempty_subsingleton.2 ‚ü®hne, minimal_nonempty_open_subsingleton hs hmin‚ü©\n\n"}
{"name":"exists_isOpen_singleton_of_isOpen_finite","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T0Space X\ns : Set X\nhfin : s.Finite\nhne : s.Nonempty\nho : IsOpen s\n‚ä¢ Exists fun x => And (Membership.mem s x) (IsOpen (Singleton.singleton x))","decl":"/-- Given an open finite set `S` in a T‚ÇÄ space, there is some `x ‚àà S` such that `{x}` is open. -/\ntheorem exists_isOpen_singleton_of_isOpen_finite [T0Space X] {s : Set X} (hfin : s.Finite)\n    (hne : s.Nonempty) (ho : IsOpen s) : ‚àÉ x ‚àà s, IsOpen ({x} : Set X) := by\n  lift s to Finset X using hfin\n  induction' s using Finset.strongInductionOn with s ihs\n  rcases em (‚àÉ t, t ‚äÇ s ‚àß t.Nonempty ‚àß IsOpen (t : Set X)) with (‚ü®t, hts, htne, hto‚ü© | ht)\n  ¬∑ rcases ihs t hts htne hto with ‚ü®x, hxt, hxo‚ü©\n    exact ‚ü®x, hts.1 hxt, hxo‚ü©\n  ¬∑ -- Porting note: was `rcases minimal_nonempty_open_eq_singleton ho hne _ with ‚ü®x, hx‚ü©`\n    --               https://github.com/leanprover/std4/issues/116\n    rsuffices ‚ü®x, hx‚ü© : ‚àÉ x, s.toSet = {x}\n    ¬∑ exact ‚ü®x, hx.symm ‚ñ∏ rfl, hx ‚ñ∏ ho‚ü©\n    refine minimal_nonempty_open_eq_singleton ho hne ?_\n    refine fun t hts htne hto => of_not_not fun hts' => ht ?_\n    lift t to Finset X using s.finite_toSet.subset hts\n    exact ‚ü®t, ssubset_iff_subset_ne.2 ‚ü®hts, mt Finset.coe_inj.2 hts'‚ü©, htne, hto‚ü©\n\n"}
{"name":"exists_open_singleton_of_finite","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : T0Space X\ninst‚úù¬π : Finite X\ninst‚úù : Nonempty X\n‚ä¢ Exists fun x => IsOpen (Singleton.singleton x)","decl":"theorem exists_open_singleton_of_finite [T0Space X] [Finite X] [Nonempty X] :\n    ‚àÉ x : X, IsOpen ({x} : Set X) :=\n  let ‚ü®x, _, h‚ü© := exists_isOpen_singleton_of_isOpen_finite (Set.toFinite _)\n    univ_nonempty isOpen_univ\n  ‚ü®x, h‚ü©\n\n"}
{"name":"t0Space_of_injective_of_continuous","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\nf : X ‚Üí Y\nhf : Function.Injective f\nhf' : Continuous f\ninst‚úù : T0Space Y\n‚ä¢ T0Space X","decl":"theorem t0Space_of_injective_of_continuous [TopologicalSpace Y] {f : X ‚Üí Y}\n    (hf : Function.Injective f) (hf' : Continuous f) [T0Space Y] : T0Space X :=\n  ‚ü®fun _ _ h => hf <| (h.map hf').eq‚ü©\n\n"}
{"name":"Topology.IsEmbedding.t0Space","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : T0Space Y\nf : X ‚Üí Y\nhf : Topology.IsEmbedding f\n‚ä¢ T0Space X","decl":"protected theorem Topology.IsEmbedding.t0Space [TopologicalSpace Y] [T0Space Y] {f : X ‚Üí Y}\n    (hf : IsEmbedding f) : T0Space X :=\n  t0Space_of_injective_of_continuous hf.injective hf.continuous\n\n"}
{"name":"Embedding.t0Space","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : T0Space Y\nf : X ‚Üí Y\nhf : Topology.IsEmbedding f\n‚ä¢ T0Space X","decl":"@[deprecated (since := \"2024-10-26\")]\nalias Embedding.t0Space := IsEmbedding.t0Space\n\n"}
{"name":"Subtype.t0Space","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T0Space X\np : X ‚Üí Prop\n‚ä¢ T0Space (Subtype p)","decl":"instance Subtype.t0Space [T0Space X] {p : X ‚Üí Prop} : T0Space (Subtype p) :=\n  IsEmbedding.subtypeVal.t0Space\n\n"}
{"name":"t0Space_iff_or_not_mem_closure","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u\ninst‚úù : TopologicalSpace X\n‚ä¢ Iff (T0Space X) (Pairwise fun a b => Or (Not (Membership.mem (closure (Singleton.singleton b)) a)) (Not (Membership.mem (closure (Singleton.singleton a)) b)))","decl":"theorem t0Space_iff_or_not_mem_closure (X : Type u) [TopologicalSpace X] :\n    T0Space X ‚Üî Pairwise fun a b : X => a ‚àâ closure ({b} : Set X) ‚à® b ‚àâ closure ({a} : Set X) := by\n  simp only [t0Space_iff_not_inseparable, inseparable_iff_mem_closure, not_and_or]\n\n"}
{"name":"Prod.instT0Space","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : TopologicalSpace Y\ninst‚úù¬π : T0Space X\ninst‚úù : T0Space Y\n‚ä¢ T0Space (Prod X Y)","decl":"instance Prod.instT0Space [TopologicalSpace Y] [T0Space X] [T0Space Y] : T0Space (X √ó Y) :=\n  ‚ü®fun _ _ h => Prod.ext (h.map continuous_fst).eq (h.map continuous_snd).eq‚ü©\n\n"}
{"name":"Pi.instT0Space","module":"Mathlib.Topology.Separation.Basic","initialProofState":"Œπ : Type u_3\nX : Œπ ‚Üí Type u_4\ninst‚úù¬π : (i : Œπ) ‚Üí TopologicalSpace (X i)\ninst‚úù : ‚àÄ (i : Œπ), T0Space (X i)\n‚ä¢ T0Space ((i : Œπ) ‚Üí X i)","decl":"instance Pi.instT0Space {Œπ : Type*} {X : Œπ ‚Üí Type*} [‚àÄ i, TopologicalSpace (X i)]\n    [‚àÄ i, T0Space (X i)] :\n    T0Space (‚àÄ i, X i) :=\n  ‚ü®fun _ _ h => funext fun i => (h.map (continuous_apply i)).eq‚ü©\n\n"}
{"name":"ULift.instT0Space","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T0Space X\n‚ä¢ T0Space (ULift.{u_3, u_1} X)","decl":"instance ULift.instT0Space [T0Space X] : T0Space (ULift X) := IsEmbedding.uliftDown.t0Space\n\n"}
{"name":"T0Space.of_cover","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nh : ‚àÄ (x y : X), Inseparable x y ‚Üí Exists fun s => And (Membership.mem s x) (And (Membership.mem s y) (T0Space ‚Üës))\n‚ä¢ T0Space X","decl":"theorem T0Space.of_cover (h : ‚àÄ x y, Inseparable x y ‚Üí ‚àÉ s : Set X, x ‚àà s ‚àß y ‚àà s ‚àß T0Space s) :\n    T0Space X := by\n  refine ‚ü®fun x y hxy => ?_‚ü©\n  rcases h x y hxy with ‚ü®s, hxs, hys, hs‚ü©\n  lift x to s using hxs; lift y to s using hys\n  rw [‚Üê subtype_inseparable_iff] at hxy\n  exact congr_arg Subtype.val hxy.eq\n\n"}
{"name":"T0Space.of_open_cover","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nh : ‚àÄ (x : X), Exists fun s => And (Membership.mem s x) (And (IsOpen s) (T0Space ‚Üës))\n‚ä¢ T0Space X","decl":"theorem T0Space.of_open_cover (h : ‚àÄ x, ‚àÉ s : Set X, x ‚àà s ‚àß IsOpen s ‚àß T0Space s) : T0Space X :=\n  T0Space.of_cover fun x _ hxy =>\n    let ‚ü®s, hxs, hso, hs‚ü© := h x\n    ‚ü®s, hxs, (hxy.mem_open_iff hso).1 hxs, hs‚ü©\n\n"}
{"name":"r0Space_iff","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u\ninst‚úù : TopologicalSpace X\n‚ä¢ Iff (R0Space X) (Symmetric Specializes)","decl":"/-- A topological space is called an R‚ÇÄ space, if `Specializes` relation is symmetric.\n\nIn other words, given two points `x y : X`,\nif every neighborhood of `y` contains `x`, then every neighborhood of `x` contains `y`. -/\n@[mk_iff]\nclass R0Space (X : Type u) [TopologicalSpace X] : Prop where\n  /-- In an R‚ÇÄ space, the `Specializes` relation is symmetric. -/\n  specializes_symmetric : Symmetric (Specializes : X ‚Üí X ‚Üí Prop)\n\n"}
{"name":"R0Space.specializes_symmetric","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u\ninst‚úù : TopologicalSpace X\nself : R0Space X\n‚ä¢ Symmetric Specializes","decl":"/-- A topological space is called an R‚ÇÄ space, if `Specializes` relation is symmetric.\n\nIn other words, given two points `x y : X`,\nif every neighborhood of `y` contains `x`, then every neighborhood of `x` contains `y`. -/\n@[mk_iff]\nclass R0Space (X : Type u) [TopologicalSpace X] : Prop where\n  /-- In an R‚ÇÄ space, the `Specializes` relation is symmetric. -/\n  specializes_symmetric : Symmetric (Specializes : X ‚Üí X ‚Üí Prop)\n\n"}
{"name":"Specializes.symm","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : R0Space X\nx y : X\nh : Specializes x y\n‚ä¢ Specializes y x","decl":"/-- In an R‚ÇÄ space, the `Specializes` relation is symmetric, dot notation version. -/\ntheorem Specializes.symm (h : x ‚§≥ y) : y ‚§≥ x := specializes_symmetric h\n\n"}
{"name":"specializes_comm","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : R0Space X\nx y : X\n‚ä¢ Iff (Specializes x y) (Specializes y x)","decl":"/-- In an R‚ÇÄ space, the `Specializes` relation is symmetric, `Iff` version. -/\ntheorem specializes_comm : x ‚§≥ y ‚Üî y ‚§≥ x := ‚ü®Specializes.symm, Specializes.symm‚ü©\n\n"}
{"name":"specializes_iff_inseparable","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : R0Space X\nx y : X\n‚ä¢ Iff (Specializes x y) (Inseparable x y)","decl":"/-- In an R‚ÇÄ space, `Specializes` is equivalent to `Inseparable`. -/\ntheorem specializes_iff_inseparable : x ‚§≥ y ‚Üî Inseparable x y :=\n  ‚ü®fun h ‚Ü¶ h.antisymm h.symm, Inseparable.specializes‚ü©\n\n"}
{"name":"Specializes.inseparable","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : R0Space X\nx y : X\na‚úù : Specializes x y\n‚ä¢ Inseparable x y","decl":"/-- In an R‚ÇÄ space, `Specializes` implies `Inseparable`. -/\nalias ‚ü®Specializes.inseparable, _‚ü© := specializes_iff_inseparable\n\n"}
{"name":"Topology.IsInducing.r0Space","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : R0Space X\ninst‚úù : TopologicalSpace Y\nf : Y ‚Üí X\nhf : Topology.IsInducing f\n‚ä¢ R0Space Y","decl":"theorem Topology.IsInducing.r0Space [TopologicalSpace Y] {f : Y ‚Üí X} (hf : IsInducing f) :\n    R0Space Y where\n  specializes_symmetric a b := by\n    simpa only [‚Üê hf.specializes_iff] using Specializes.symm\n\n"}
{"name":"Inducing.r0Space","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : R0Space X\ninst‚úù : TopologicalSpace Y\nf : Y ‚Üí X\nhf : Topology.IsInducing f\n‚ä¢ R0Space Y","decl":"@[deprecated (since := \"2024-10-28\")] alias Inducing.r0Space := IsInducing.r0Space\n\n"}
{"name":"instR0SpaceSubtype","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : R0Space X\np : X ‚Üí Prop\n‚ä¢ R0Space (Subtype fun x => p x)","decl":"instance {p : X ‚Üí Prop} : R0Space {x // p x} := IsInducing.subtypeVal.r0Space\n\n"}
{"name":"instR0SpaceProd","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : R0Space X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : R0Space Y\n‚ä¢ R0Space (Prod X Y)","decl":"instance [TopologicalSpace Y] [R0Space Y] : R0Space (X √ó Y) where\n  specializes_symmetric _ _ h := h.fst.symm.prod h.snd.symm\n\n"}
{"name":"instR0SpaceForall","module":"Mathlib.Topology.Separation.Basic","initialProofState":"Œπ : Type u_3\nX : Œπ ‚Üí Type u_4\ninst‚úù¬π : (i : Œπ) ‚Üí TopologicalSpace (X i)\ninst‚úù : ‚àÄ (i : Œπ), R0Space (X i)\n‚ä¢ R0Space ((i : Œπ) ‚Üí X i)","decl":"instance {Œπ : Type*} {X : Œπ ‚Üí Type*} [‚àÄ i, TopologicalSpace (X i)] [‚àÄ i, R0Space (X i)] :\n    R0Space (‚àÄ i, X i) where\n  specializes_symmetric _ _ h := specializes_pi.2 fun i ‚Ü¶ (specializes_pi.1 h i).symm\n\n"}
{"name":"isCompact_closure_singleton","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : R0Space X\nx : X\n‚ä¢ IsCompact (closure (Singleton.singleton x))","decl":"/-- In an R‚ÇÄ space, the closure of a singleton is a compact set. -/\ntheorem isCompact_closure_singleton : IsCompact (closure {x}) := by\n  refine isCompact_of_finite_subcover fun U hUo hxU ‚Ü¶ ?_\n  obtain ‚ü®i, hi‚ü© : ‚àÉ i, x ‚àà U i := mem_iUnion.1 <| hxU <| subset_closure rfl\n  refine ‚ü®{i}, fun y hy ‚Ü¶ ?_‚ü©\n  rw [‚Üê specializes_iff_mem_closure, specializes_comm] at hy\n  simpa using hy.mem_open (hUo i) hi\n\n"}
{"name":"Filter.coclosedCompact_le_cofinite","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : R0Space X\n‚ä¢ LE.le (Filter.coclosedCompact X) Filter.cofinite","decl":"theorem Filter.coclosedCompact_le_cofinite : coclosedCompact X ‚â§ cofinite :=\n  le_cofinite_iff_compl_singleton_mem.2 fun _ ‚Ü¶\n    compl_mem_coclosedCompact.2 isCompact_closure_singleton\n\n"}
{"name":"Bornology.relativelyCompact.isBounded_iff","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : R0Space X\ns : Set X\n‚ä¢ Iff (Bornology.IsBounded s) (IsCompact (closure s))","decl":"theorem Bornology.relativelyCompact.isBounded_iff {s : Set X} :\n    @Bornology.IsBounded _ (Bornology.relativelyCompact X) s ‚Üî IsCompact (closure s) :=\n  compl_mem_coclosedCompact\n\n"}
{"name":"Set.Finite.isCompact_closure","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : R0Space X\ns : Set X\nhs : s.Finite\n‚ä¢ IsCompact (closure s)","decl":"/-- In an R‚ÇÄ space, the closure of a finite set is a compact set. -/\ntheorem Set.Finite.isCompact_closure {s : Set X} (hs : s.Finite) : IsCompact (closure s) :=\n  let _ : Bornology X := .relativelyCompact X\n  Bornology.relativelyCompact.isBounded_iff.1 hs.isBounded\n\n"}
{"name":"T1Space.t1","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u\ninst‚úù : TopologicalSpace X\nself : T1Space X\nx : X\n‚ä¢ IsClosed (Singleton.singleton x)","decl":"/-- A T‚ÇÅ space, also known as a Fr√©chet space, is a topological space\n  where every singleton set is closed. Equivalently, for every pair\n  `x ‚â† y`, there is an open set containing `x` and not `y`. -/\nclass T1Space (X : Type u) [TopologicalSpace X] : Prop where\n  /-- A singleton in a T‚ÇÅ space is a closed set. -/\n  t1 : ‚àÄ x, IsClosed ({x} : Set X)\n\n"}
{"name":"isClosed_singleton","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T1Space X\nx : X\n‚ä¢ IsClosed (Singleton.singleton x)","decl":"theorem isClosed_singleton [T1Space X] {x : X} : IsClosed ({x} : Set X) :=\n  T1Space.t1 x\n\n"}
{"name":"isOpen_compl_singleton","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T1Space X\nx : X\n‚ä¢ IsOpen (HasCompl.compl (Singleton.singleton x))","decl":"theorem isOpen_compl_singleton [T1Space X] {x : X} : IsOpen ({x}·∂ú : Set X) :=\n  isClosed_singleton.isOpen_compl\n\n"}
{"name":"isOpen_ne","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T1Space X\nx : X\n‚ä¢ IsOpen (setOf fun y => Ne y x)","decl":"theorem isOpen_ne [T1Space X] {x : X} : IsOpen { y | y ‚â† x } :=\n  isOpen_compl_singleton\n\n"}
{"name":"Continuous.isOpen_support","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : T1Space X\ninst‚úù¬π : Zero X\ninst‚úù : TopologicalSpace Y\nf : Y ‚Üí X\nhf : Continuous f\n‚ä¢ IsOpen (Function.support f)","decl":"@[to_additive]\ntheorem Continuous.isOpen_mulSupport [T1Space X] [One X] [TopologicalSpace Y] {f : Y ‚Üí X}\n    (hf : Continuous f) : IsOpen (mulSupport f) :=\n  isOpen_ne.preimage hf\n\n"}
{"name":"Continuous.isOpen_mulSupport","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : T1Space X\ninst‚úù¬π : One X\ninst‚úù : TopologicalSpace Y\nf : Y ‚Üí X\nhf : Continuous f\n‚ä¢ IsOpen (Function.mulSupport f)","decl":"@[to_additive]\ntheorem Continuous.isOpen_mulSupport [T1Space X] [One X] [TopologicalSpace Y] {f : Y ‚Üí X}\n    (hf : Continuous f) : IsOpen (mulSupport f) :=\n  isOpen_ne.preimage hf\n\n"}
{"name":"Ne.nhdsWithin_compl_singleton","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T1Space X\nx y : X\nh : Ne x y\n‚ä¢ Eq (nhdsWithin x (HasCompl.compl (Singleton.singleton y))) (nhds x)","decl":"theorem Ne.nhdsWithin_compl_singleton [T1Space X] {x y : X} (h : x ‚â† y) : ùìù[{y}·∂ú] x = ùìù x :=\n  isOpen_ne.nhdsWithin_eq h\n\n"}
{"name":"Ne.nhdsWithin_diff_singleton","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T1Space X\nx y : X\nh : Ne x y\ns : Set X\n‚ä¢ Eq (nhdsWithin x (SDiff.sdiff s (Singleton.singleton y))) (nhdsWithin x s)","decl":"theorem Ne.nhdsWithin_diff_singleton [T1Space X] {x y : X} (h : x ‚â† y) (s : Set X) :\n    ùìù[s \\ {y}] x = ùìù[s] x := by\n  rw [diff_eq, inter_comm, nhdsWithin_inter_of_mem]\n  exact mem_nhdsWithin_of_mem_nhds (isOpen_ne.mem_nhds h)\n\n"}
{"name":"nhdsWithin_compl_singleton_le","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T1Space X\nx y : X\n‚ä¢ LE.le (nhdsWithin x (HasCompl.compl (Singleton.singleton x))) (nhdsWithin x (HasCompl.compl (Singleton.singleton y)))","decl":"lemma nhdsWithin_compl_singleton_le [T1Space X] (x y : X) : ùìù[{x}·∂ú] x ‚â§ ùìù[{y}·∂ú] x := by\n  rcases eq_or_ne x y with rfl|hy\n  ¬∑ exact Eq.le rfl\n  ¬∑ rw [Ne.nhdsWithin_compl_singleton hy]\n    exact nhdsWithin_le_nhds\n\n"}
{"name":"isOpen_setOf_eventually_nhdsWithin","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T1Space X\np : X ‚Üí Prop\n‚ä¢ IsOpen (setOf fun x => Filter.Eventually (fun y => p y) (nhdsWithin x (HasCompl.compl (Singleton.singleton x))))","decl":"theorem isOpen_setOf_eventually_nhdsWithin [T1Space X] {p : X ‚Üí Prop} :\n    IsOpen { x | ‚àÄ·∂† y in ùìù[‚â†] x, p y } := by\n  refine isOpen_iff_mem_nhds.mpr fun a ha => ?_\n  filter_upwards [eventually_nhds_nhdsWithin.mpr ha] with b hb\n  rcases eq_or_ne a b with rfl | h\n  ¬∑ exact hb\n  ¬∑ rw [h.symm.nhdsWithin_compl_singleton] at hb\n    exact hb.filter_mono nhdsWithin_le_nhds\n\n"}
{"name":"Set.Finite.isClosed","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T1Space X\ns : Set X\nhs : s.Finite\n‚ä¢ IsClosed s","decl":"protected theorem Set.Finite.isClosed [T1Space X] {s : Set X} (hs : Set.Finite s) : IsClosed s := by\n  rw [‚Üê biUnion_of_singleton s]\n  exact hs.isClosed_biUnion fun i _ => isClosed_singleton\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.exists_mem_of_ne","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T1Space X\nb : Set (Set X)\nhb : TopologicalSpace.IsTopologicalBasis b\nx y : X\nh : Ne x y\n‚ä¢ Exists fun a => And (Membership.mem b a) (And (Membership.mem a x) (Not (Membership.mem a y)))","decl":"theorem TopologicalSpace.IsTopologicalBasis.exists_mem_of_ne [T1Space X] {b : Set (Set X)}\n    (hb : IsTopologicalBasis b) {x y : X} (h : x ‚â† y) : ‚àÉ a ‚àà b, x ‚àà a ‚àß y ‚àâ a := by\n  rcases hb.isOpen_iff.1 isOpen_ne x h with ‚ü®a, ab, xa, ha‚ü©\n  exact ‚ü®a, ab, xa, fun h => ha h rfl‚ü©\n\n"}
{"name":"Finset.isClosed","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T1Space X\ns : Finset X\n‚ä¢ IsClosed ‚Üës","decl":"protected theorem Finset.isClosed [T1Space X] (s : Finset X) : IsClosed (s : Set X) :=\n  s.finite_toSet.isClosed\n\n"}
{"name":"t1Space_TFAE","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u\ninst‚úù : TopologicalSpace X\n‚ä¢ (List.cons (T1Space X) (List.cons (‚àÄ (x : X), IsClosed (Singleton.singleton x)) (List.cons (‚àÄ (x : X), IsOpen (HasCompl.compl (Singleton.singleton x))) (List.cons (Continuous ‚áëCofiniteTopology.of) (List.cons (‚àÄ ‚¶Éx y : X‚¶Ñ, Ne x y ‚Üí Membership.mem (nhds x) (HasCompl.compl (Singleton.singleton y))) (List.cons (‚àÄ ‚¶Éx y : X‚¶Ñ, Ne x y ‚Üí Exists fun s => And (Membership.mem (nhds x) s) (Not (Membership.mem s y))) (List.cons (‚àÄ ‚¶Éx y : X‚¶Ñ, Ne x y ‚Üí Exists fun U => And (IsOpen U) (And (Membership.mem U x) (Not (Membership.mem U y)))) (List.cons (‚àÄ ‚¶Éx y : X‚¶Ñ, Ne x y ‚Üí Disjoint (nhds x) (Pure.pure y)) (List.cons (‚àÄ ‚¶Éx y : X‚¶Ñ, Ne x y ‚Üí Disjoint (Pure.pure x) (nhds y)) (List.cons (‚àÄ ‚¶Éx y : X‚¶Ñ, Specializes x y ‚Üí Eq x y) List.nil)))))))))).TFAE","decl":"theorem t1Space_TFAE (X : Type u) [TopologicalSpace X] :\n    List.TFAE [T1Space X,\n      ‚àÄ x, IsClosed ({ x } : Set X),\n      ‚àÄ x, IsOpen ({ x }·∂ú : Set X),\n      Continuous (@CofiniteTopology.of X),\n      ‚àÄ ‚¶Éx y : X‚¶Ñ, x ‚â† y ‚Üí {y}·∂ú ‚àà ùìù x,\n      ‚àÄ ‚¶Éx y : X‚¶Ñ, x ‚â† y ‚Üí ‚àÉ s ‚àà ùìù x, y ‚àâ s,\n      ‚àÄ ‚¶Éx y : X‚¶Ñ, x ‚â† y ‚Üí ‚àÉ U : Set X, IsOpen U ‚àß x ‚àà U ‚àß y ‚àâ U,\n      ‚àÄ ‚¶Éx y : X‚¶Ñ, x ‚â† y ‚Üí Disjoint (ùìù x) (pure y),\n      ‚àÄ ‚¶Éx y : X‚¶Ñ, x ‚â† y ‚Üí Disjoint (pure x) (ùìù y),\n      ‚àÄ ‚¶Éx y : X‚¶Ñ, x ‚§≥ y ‚Üí x = y] := by\n  tfae_have 1 ‚Üî 2 := ‚ü®fun h => h.1, fun h => ‚ü®h‚ü©‚ü©\n  tfae_have 2 ‚Üî 3 := by\n    simp only [isOpen_compl_iff]\n  tfae_have 5 ‚Üî 3 := by\n    refine forall_swap.trans ?_\n    simp only [isOpen_iff_mem_nhds, mem_compl_iff, mem_singleton_iff]\n  tfae_have 5 ‚Üî 6 := by\n    simp only [‚Üê subset_compl_singleton_iff, exists_mem_subset_iff]\n  tfae_have 5 ‚Üî 7 := by\n    simp only [(nhds_basis_opens _).mem_iff, subset_compl_singleton_iff, exists_prop, and_assoc,\n      and_left_comm]\n  tfae_have 5 ‚Üî 8 := by\n    simp only [‚Üê principal_singleton, disjoint_principal_right]\n  tfae_have 8 ‚Üî 9 := forall_swap.trans (by simp only [disjoint_comm, ne_comm])\n  tfae_have 1 ‚Üí 4 := by\n    simp only [continuous_def, CofiniteTopology.isOpen_iff']\n    rintro H s (rfl | hs)\n    exacts [isOpen_empty, compl_compl s ‚ñ∏ (@Set.Finite.isClosed _ _ H _ hs).isOpen_compl]\n  tfae_have 4 ‚Üí 2 :=\n    fun h x => (CofiniteTopology.isClosed_iff.2 <| Or.inr (finite_singleton _)).preimage h\n  tfae_have 2 ‚Üî 10 := by\n    simp only [‚Üê closure_subset_iff_isClosed, specializes_iff_mem_closure, subset_def,\n      mem_singleton_iff, eq_comm]\n  tfae_finish\n\n"}
{"name":"t1Space_iff_continuous_cofinite_of","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\n‚ä¢ Iff (T1Space X) (Continuous ‚áëCofiniteTopology.of)","decl":"theorem t1Space_iff_continuous_cofinite_of : T1Space X ‚Üî Continuous (@CofiniteTopology.of X) :=\n  (t1Space_TFAE X).out 0 3\n\n"}
{"name":"CofiniteTopology.continuous_of","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T1Space X\n‚ä¢ Continuous ‚áëCofiniteTopology.of","decl":"theorem CofiniteTopology.continuous_of [T1Space X] : Continuous (@CofiniteTopology.of X) :=\n  t1Space_iff_continuous_cofinite_of.mp ‚Äπ_‚Ä∫\n\n"}
{"name":"t1Space_iff_exists_open","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\n‚ä¢ Iff (T1Space X) (Pairwise fun x y => Exists fun U => And (IsOpen U) (And (Membership.mem U x) (Not (Membership.mem U y))))","decl":"theorem t1Space_iff_exists_open :\n    T1Space X ‚Üî Pairwise fun x y => ‚àÉ U : Set X, IsOpen U ‚àß x ‚àà U ‚àß y ‚àâ U :=\n  (t1Space_TFAE X).out 0 6\n\n"}
{"name":"t1Space_iff_disjoint_pure_nhds","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\n‚ä¢ Iff (T1Space X) (‚àÄ ‚¶Éx y : X‚¶Ñ, Ne x y ‚Üí Disjoint (Pure.pure x) (nhds y))","decl":"theorem t1Space_iff_disjoint_pure_nhds : T1Space X ‚Üî ‚àÄ ‚¶Éx y : X‚¶Ñ, x ‚â† y ‚Üí Disjoint (pure x) (ùìù y) :=\n  (t1Space_TFAE X).out 0 8\n\n"}
{"name":"t1Space_iff_disjoint_nhds_pure","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\n‚ä¢ Iff (T1Space X) (‚àÄ ‚¶Éx y : X‚¶Ñ, Ne x y ‚Üí Disjoint (nhds x) (Pure.pure y))","decl":"theorem t1Space_iff_disjoint_nhds_pure : T1Space X ‚Üî ‚àÄ ‚¶Éx y : X‚¶Ñ, x ‚â† y ‚Üí Disjoint (ùìù x) (pure y) :=\n  (t1Space_TFAE X).out 0 7\n\n"}
{"name":"t1Space_iff_specializes_imp_eq","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\n‚ä¢ Iff (T1Space X) (‚àÄ ‚¶Éx y : X‚¶Ñ, Specializes x y ‚Üí Eq x y)","decl":"theorem t1Space_iff_specializes_imp_eq : T1Space X ‚Üî ‚àÄ ‚¶Éx y : X‚¶Ñ, x ‚§≥ y ‚Üí x = y :=\n  (t1Space_TFAE X).out 0 9\n\n"}
{"name":"disjoint_pure_nhds","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T1Space X\nx y : X\nh : Ne x y\n‚ä¢ Disjoint (Pure.pure x) (nhds y)","decl":"theorem disjoint_pure_nhds [T1Space X] {x y : X} (h : x ‚â† y) : Disjoint (pure x) (ùìù y) :=\n  t1Space_iff_disjoint_pure_nhds.mp ‚Äπ_‚Ä∫ h\n\n"}
{"name":"disjoint_nhds_pure","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T1Space X\nx y : X\nh : Ne x y\n‚ä¢ Disjoint (nhds x) (Pure.pure y)","decl":"theorem disjoint_nhds_pure [T1Space X] {x y : X} (h : x ‚â† y) : Disjoint (ùìù x) (pure y) :=\n  t1Space_iff_disjoint_nhds_pure.mp ‚Äπ_‚Ä∫ h\n\n"}
{"name":"Specializes.eq","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T1Space X\nx y : X\nh : Specializes x y\n‚ä¢ Eq x y","decl":"theorem Specializes.eq [T1Space X] {x y : X} (h : x ‚§≥ y) : x = y :=\n  t1Space_iff_specializes_imp_eq.1 ‚Äπ_‚Ä∫ h\n\n"}
{"name":"specializes_iff_eq","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T1Space X\nx y : X\n‚ä¢ Iff (Specializes x y) (Eq x y)","decl":"theorem specializes_iff_eq [T1Space X] {x y : X} : x ‚§≥ y ‚Üî x = y :=\n  ‚ü®Specializes.eq, fun h => h ‚ñ∏ specializes_rfl‚ü©\n\n"}
{"name":"specializes_eq_eq","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T1Space X\n‚ä¢ Eq (fun x1 x2 => Specializes x1 x2) Eq","decl":"@[simp] theorem specializes_eq_eq [T1Space X] : (¬∑ ‚§≥ ¬∑) = @Eq X :=\n  funext‚ÇÇ fun _ _ => propext specializes_iff_eq\n\n"}
{"name":"pure_le_nhds_iff","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T1Space X\na b : X\n‚ä¢ Iff (LE.le (Pure.pure a) (nhds b)) (Eq a b)","decl":"@[simp]\ntheorem pure_le_nhds_iff [T1Space X] {a b : X} : pure a ‚â§ ùìù b ‚Üî a = b :=\n  specializes_iff_pure.symm.trans specializes_iff_eq\n\n"}
{"name":"nhds_le_nhds_iff","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T1Space X\na b : X\n‚ä¢ Iff (LE.le (nhds a) (nhds b)) (Eq a b)","decl":"@[simp]\ntheorem nhds_le_nhds_iff [T1Space X] {a b : X} : ùìù a ‚â§ ùìù b ‚Üî a = b :=\n  specializes_iff_eq\n\n"}
{"name":"instR0SpaceOfT1Space","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T1Space X\n‚ä¢ R0Space X","decl":"instance (priority := 100) [T1Space X] : R0Space X where\n  specializes_symmetric _ _ := by rw [specializes_iff_eq, specializes_iff_eq]; exact Eq.symm\n\n"}
{"name":"instT1SpaceCofiniteTopology","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\n‚ä¢ T1Space (CofiniteTopology X)","decl":"instance : T1Space (CofiniteTopology X) :=\n  t1Space_iff_continuous_cofinite_of.mpr continuous_id\n\n"}
{"name":"t1Space_antitone","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_3\n‚ä¢ Antitone (@T1Space X)","decl":"theorem t1Space_antitone {X} : Antitone (@T1Space X) := fun a _ h _ =>\n  @T1Space.mk _ a fun x => (T1Space.t1 x).mono h\n\n"}
{"name":"continuousWithinAt_update_of_ne","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : T1Space X\ninst‚úù¬π : DecidableEq X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\ns : Set X\nx x' : X\ny : Y\nhne : Ne x' x\n‚ä¢ Iff (ContinuousWithinAt (Function.update f x y) s x') (ContinuousWithinAt f s x')","decl":"theorem continuousWithinAt_update_of_ne [T1Space X] [DecidableEq X] [TopologicalSpace Y] {f : X ‚Üí Y}\n    {s : Set X} {x x' : X} {y : Y} (hne : x' ‚â† x) :\n    ContinuousWithinAt (Function.update f x y) s x' ‚Üî ContinuousWithinAt f s x' :=\n  EventuallyEq.congr_continuousWithinAt\n    (mem_nhdsWithin_of_mem_nhds <| mem_of_superset (isOpen_ne.mem_nhds hne) fun _y' hy' =>\n      Function.update_of_ne hy' _ _)\n    (Function.update_of_ne hne ..)\n\n"}
{"name":"continuousAt_update_of_ne","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : T1Space X\ninst‚úù¬π : DecidableEq X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\nx x' : X\ny : Y\nhne : Ne x' x\n‚ä¢ Iff (ContinuousAt (Function.update f x y) x') (ContinuousAt f x')","decl":"theorem continuousAt_update_of_ne [T1Space X] [DecidableEq X] [TopologicalSpace Y]\n    {f : X ‚Üí Y} {x x' : X} {y : Y} (hne : x' ‚â† x) :\n    ContinuousAt (Function.update f x y) x' ‚Üî ContinuousAt f x' := by\n  simp only [‚Üê continuousWithinAt_univ, continuousWithinAt_update_of_ne hne]\n\n"}
{"name":"continuousOn_update_iff","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : T1Space X\ninst‚úù¬π : DecidableEq X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\ns : Set X\nx : X\ny : Y\n‚ä¢ Iff (ContinuousOn (Function.update f x y) s) (And (ContinuousOn f (SDiff.sdiff s (Singleton.singleton x))) (Membership.mem s x ‚Üí Filter.Tendsto f (nhdsWithin x (SDiff.sdiff s (Singleton.singleton x))) (nhds y)))","decl":"theorem continuousOn_update_iff [T1Space X] [DecidableEq X] [TopologicalSpace Y] {f : X ‚Üí Y}\n    {s : Set X} {x : X} {y : Y} :\n    ContinuousOn (Function.update f x y) s ‚Üî\n      ContinuousOn f (s \\ {x}) ‚àß (x ‚àà s ‚Üí Tendsto f (ùìù[s \\ {x}] x) (ùìù y)) := by\n  rw [ContinuousOn, ‚Üê and_forall_ne x, and_comm]\n  refine and_congr ‚ü®fun H z hz => ?_, fun H z hzx hzs => ?_‚ü© (forall_congr' fun _ => ?_)\n  ¬∑ specialize H z hz.2 hz.1\n    rw [continuousWithinAt_update_of_ne hz.2] at H\n    exact H.mono diff_subset\n  ¬∑ rw [continuousWithinAt_update_of_ne hzx]\n    refine (H z ‚ü®hzs, hzx‚ü©).mono_of_mem_nhdsWithin (inter_mem_nhdsWithin _ ?_)\n    exact isOpen_ne.mem_nhds hzx\n  ¬∑ exact continuousWithinAt_update_same\n\n"}
{"name":"t1Space_of_injective_of_continuous","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\nf : X ‚Üí Y\nhf : Function.Injective f\nhf' : Continuous f\ninst‚úù : T1Space Y\n‚ä¢ T1Space X","decl":"theorem t1Space_of_injective_of_continuous [TopologicalSpace Y] {f : X ‚Üí Y}\n    (hf : Function.Injective f) (hf' : Continuous f) [T1Space Y] : T1Space X :=\n  t1Space_iff_specializes_imp_eq.2 fun _ _ h => hf (h.map hf').eq\n\n"}
{"name":"Topology.IsEmbedding.t1Space","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : T1Space Y\nf : X ‚Üí Y\nhf : Topology.IsEmbedding f\n‚ä¢ T1Space X","decl":"protected theorem Topology.IsEmbedding.t1Space [TopologicalSpace Y] [T1Space Y] {f : X ‚Üí Y}\n    (hf : IsEmbedding f) : T1Space X :=\n  t1Space_of_injective_of_continuous hf.injective hf.continuous\n\n"}
{"name":"Embedding.t1Space","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : T1Space Y\nf : X ‚Üí Y\nhf : Topology.IsEmbedding f\n‚ä¢ T1Space X","decl":"@[deprecated (since := \"2024-10-26\")]\nalias Embedding.t1Space := IsEmbedding.t1Space\n\n"}
{"name":"Subtype.t1Space","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T1Space X\np : X ‚Üí Prop\n‚ä¢ T1Space (Subtype p)","decl":"instance Subtype.t1Space {X : Type u} [TopologicalSpace X] [T1Space X] {p : X ‚Üí Prop} :\n    T1Space (Subtype p) :=\n  IsEmbedding.subtypeVal.t1Space\n\n"}
{"name":"instT1SpaceProd","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : TopologicalSpace Y\ninst‚úù¬π : T1Space X\ninst‚úù : T1Space Y\n‚ä¢ T1Space (Prod X Y)","decl":"instance [TopologicalSpace Y] [T1Space X] [T1Space Y] : T1Space (X √ó Y) :=\n  ‚ü®fun ‚ü®a, b‚ü© => @singleton_prod_singleton _ _ a b ‚ñ∏ isClosed_singleton.prod isClosed_singleton‚ü©\n\n"}
{"name":"instT1SpaceForall","module":"Mathlib.Topology.Separation.Basic","initialProofState":"Œπ : Type u_3\nX : Œπ ‚Üí Type u_4\ninst‚úù¬π : (i : Œπ) ‚Üí TopologicalSpace (X i)\ninst‚úù : ‚àÄ (i : Œπ), T1Space (X i)\n‚ä¢ T1Space ((i : Œπ) ‚Üí X i)","decl":"instance {Œπ : Type*} {X : Œπ ‚Üí Type*} [‚àÄ i, TopologicalSpace (X i)] [‚àÄ i, T1Space (X i)] :\n    T1Space (‚àÄ i, X i) :=\n  ‚ü®fun f => univ_pi_singleton f ‚ñ∏ isClosed_set_pi fun _ _ => isClosed_singleton‚ü©\n\n"}
{"name":"ULift.instT1Space","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T1Space X\n‚ä¢ T1Space (ULift.{u_3, u_1} X)","decl":"instance ULift.instT1Space [T1Space X] : T1Space (ULift X) :=\n  IsEmbedding.uliftDown.t1Space\n\n-- see Note [lower instance priority]\n"}
{"name":"TotallyDisconnectedSpace.t1Space","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nh : TotallyDisconnectedSpace X\n‚ä¢ T1Space X","decl":"instance (priority := 100) TotallyDisconnectedSpace.t1Space [h : TotallyDisconnectedSpace X] :\n    T1Space X := by\n  rw [((t1Space_TFAE X).out 0 1 :)]\n  intro x\n  rw [‚Üê totallyDisconnectedSpace_iff_connectedComponent_singleton.mp h x]\n  exact isClosed_connectedComponent\n\n-- see Note [lower instance priority]\n"}
{"name":"T1Space.t0Space","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T1Space X\n‚ä¢ T0Space X","decl":"instance (priority := 100) T1Space.t0Space [T1Space X] : T0Space X :=\n  ‚ü®fun _ _ h => h.specializes.eq‚ü©\n\n"}
{"name":"compl_singleton_mem_nhds_iff","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T1Space X\nx y : X\n‚ä¢ Iff (Membership.mem (nhds y) (HasCompl.compl (Singleton.singleton x))) (Ne y x)","decl":"@[simp]\ntheorem compl_singleton_mem_nhds_iff [T1Space X] {x y : X} : {x}·∂ú ‚àà ùìù y ‚Üî y ‚â† x :=\n  isOpen_compl_singleton.mem_nhds_iff\n\n"}
{"name":"compl_singleton_mem_nhds","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T1Space X\nx y : X\nh : Ne y x\n‚ä¢ Membership.mem (nhds y) (HasCompl.compl (Singleton.singleton x))","decl":"theorem compl_singleton_mem_nhds [T1Space X] {x y : X} (h : y ‚â† x) : {x}·∂ú ‚àà ùìù y :=\n  compl_singleton_mem_nhds_iff.mpr h\n\n"}
{"name":"closure_singleton","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T1Space X\nx : X\n‚ä¢ Eq (closure (Singleton.singleton x)) (Singleton.singleton x)","decl":"@[simp]\ntheorem closure_singleton [T1Space X] {x : X} : closure ({x} : Set X) = {x} :=\n  isClosed_singleton.closure_eq\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: the proof was `hs.induction_on (by simp) fun x => by simp`\n"}
{"name":"Set.Subsingleton.closure","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T1Space X\ns : Set X\nhs : s.Subsingleton\n‚ä¢ (closure s).Subsingleton","decl":"theorem Set.Subsingleton.closure [T1Space X] {s : Set X} (hs : s.Subsingleton) :\n    (closure s).Subsingleton := by\n  rcases hs.eq_empty_or_singleton with (rfl | ‚ü®x, rfl‚ü©) <;> simp\n\n"}
{"name":"subsingleton_closure","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T1Space X\ns : Set X\n‚ä¢ Iff (closure s).Subsingleton s.Subsingleton","decl":"@[simp]\ntheorem subsingleton_closure [T1Space X] {s : Set X} : (closure s).Subsingleton ‚Üî s.Subsingleton :=\n  ‚ü®fun h => h.anti subset_closure, fun h => h.closure‚ü©\n\n"}
{"name":"isClosedMap_const","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_3\nY : Type u_4\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : T1Space Y\ny : Y\n‚ä¢ IsClosedMap (Function.const X y)","decl":"theorem isClosedMap_const {X Y} [TopologicalSpace X] [TopologicalSpace Y] [T1Space Y] {y : Y} :\n    IsClosedMap (Function.const X y) :=\n  IsClosedMap.of_nonempty fun s _ h2s => by simp_rw [const, h2s.image_const, isClosed_singleton]\n\n"}
{"name":"nhdsWithin_insert_of_ne","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T1Space X\nx y : X\ns : Set X\nhxy : Ne x y\n‚ä¢ Eq (nhdsWithin x (Insert.insert y s)) (nhdsWithin x s)","decl":"theorem nhdsWithin_insert_of_ne [T1Space X] {x y : X} {s : Set X} (hxy : x ‚â† y) :\n    ùìù[insert y s] x = ùìù[s] x := by\n  refine le_antisymm (Filter.le_def.2 fun t ht => ?_) (nhdsWithin_mono x <| subset_insert y s)\n  obtain ‚ü®o, ho, hxo, host‚ü© := mem_nhdsWithin.mp ht\n  refine mem_nhdsWithin.mpr ‚ü®o \\ {y}, ho.sdiff isClosed_singleton, ‚ü®hxo, hxy‚ü©, ?_‚ü©\n  rw [inter_insert_of_not_mem <| not_mem_diff_of_mem (mem_singleton y)]\n  exact (inter_subset_inter diff_subset Subset.rfl).trans host\n\n"}
{"name":"insert_mem_nhdsWithin_of_subset_insert","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T1Space X\nx y : X\ns t : Set X\nhu : HasSubset.Subset t (Insert.insert y s)\n‚ä¢ Membership.mem (nhdsWithin x t) (Insert.insert x s)","decl":"/-- If `t` is a subset of `s`, except for one point,\nthen `insert x s` is a neighborhood of `x` within `t`. -/\ntheorem insert_mem_nhdsWithin_of_subset_insert [T1Space X] {x y : X} {s t : Set X}\n    (hu : t ‚äÜ insert y s) : insert x s ‚àà ùìù[t] x := by\n  rcases eq_or_ne x y with (rfl | h)\n  ¬∑ exact mem_of_superset self_mem_nhdsWithin hu\n  refine nhdsWithin_mono x hu ?_\n  rw [nhdsWithin_insert_of_ne h]\n  exact mem_of_superset self_mem_nhdsWithin (subset_insert x s)\n\n"}
{"name":"eventuallyEq_insert","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T1Space X\ns t : Set X\nx y : X\nh : (nhdsWithin x (HasCompl.compl (Singleton.singleton y))).EventuallyEq s t\n‚ä¢ (nhds x).EventuallyEq (Insert.insert x s) (Insert.insert x t)","decl":"lemma eventuallyEq_insert [T1Space X] {s t : Set X} {x y : X} (h : s =·∂†[ùìù[{y}·∂ú] x] t) :\n    (insert x s : Set X) =·∂†[ùìù x] (insert x t : Set X) := by\n  simp_rw [eventuallyEq_set] at h ‚ä¢\n  simp_rw [‚Üê union_singleton, ‚Üê nhdsWithin_univ, ‚Üê compl_union_self {x},\n    nhdsWithin_union, eventually_sup, nhdsWithin_singleton,\n    eventually_pure, union_singleton, mem_insert_iff, true_or, and_true]\n  filter_upwards [nhdsWithin_compl_singleton_le x y h] with y using or_congr (Iff.rfl)\n\n"}
{"name":"ker_nhds","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T1Space X\nx : X\n‚ä¢ Eq (nhds x).ker (Singleton.singleton x)","decl":"@[simp]\ntheorem ker_nhds [T1Space X] (x : X) : (ùìù x).ker = {x} := by\n  simp [ker_nhds_eq_specializes]\n\n"}
{"name":"biInter_basis_nhds","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T1Space X\nŒπ : Sort u_3\np : Œπ ‚Üí Prop\ns : Œπ ‚Üí Set X\nx : X\nh : (nhds x).HasBasis p s\n‚ä¢ Eq (Set.iInter fun i => Set.iInter fun x => s i) (Singleton.singleton x)","decl":"theorem biInter_basis_nhds [T1Space X] {Œπ : Sort*} {p : Œπ ‚Üí Prop} {s : Œπ ‚Üí Set X} {x : X}\n    (h : (ùìù x).HasBasis p s) : ‚ãÇ (i) (_ : p i), s i = {x} := by\n  rw [‚Üê h.ker, ker_nhds]\n\n"}
{"name":"compl_singleton_mem_nhdsSet_iff","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T1Space X\nx : X\ns : Set X\n‚ä¢ Iff (Membership.mem (nhdsSet s) (HasCompl.compl (Singleton.singleton x))) (Not (Membership.mem s x))","decl":"@[simp]\ntheorem compl_singleton_mem_nhdsSet_iff [T1Space X] {x : X} {s : Set X} : {x}·∂ú ‚àà ùìùÀ¢ s ‚Üî x ‚àâ s := by\n  rw [isOpen_compl_singleton.mem_nhdsSet, subset_compl_singleton_iff]\n\n"}
{"name":"nhdsSet_le_iff","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T1Space X\ns t : Set X\n‚ä¢ Iff (LE.le (nhdsSet s) (nhdsSet t)) (HasSubset.Subset s t)","decl":"@[simp]\ntheorem nhdsSet_le_iff [T1Space X] {s t : Set X} : ùìùÀ¢ s ‚â§ ùìùÀ¢ t ‚Üî s ‚äÜ t := by\n  refine ‚ü®?_, fun h => monotone_nhdsSet h‚ü©\n  simp_rw [Filter.le_def]; intro h x hx\n  specialize h {x}·∂ú\n  simp_rw [compl_singleton_mem_nhdsSet_iff] at h\n  by_contra hxt\n  exact h hxt hx\n\n"}
{"name":"nhdsSet_inj_iff","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T1Space X\ns t : Set X\n‚ä¢ Iff (Eq (nhdsSet s) (nhdsSet t)) (Eq s t)","decl":"@[simp]\ntheorem nhdsSet_inj_iff [T1Space X] {s t : Set X} : ùìùÀ¢ s = ùìùÀ¢ t ‚Üî s = t := by\n  simp_rw [le_antisymm_iff]\n  exact and_congr nhdsSet_le_iff nhdsSet_le_iff\n\n"}
{"name":"injective_nhdsSet","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T1Space X\n‚ä¢ Function.Injective nhdsSet","decl":"theorem injective_nhdsSet [T1Space X] : Function.Injective (ùìùÀ¢ : Set X ‚Üí Filter X) := fun _ _ hst =>\n  nhdsSet_inj_iff.mp hst\n\n"}
{"name":"strictMono_nhdsSet","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T1Space X\n‚ä¢ StrictMono nhdsSet","decl":"theorem strictMono_nhdsSet [T1Space X] : StrictMono (ùìùÀ¢ : Set X ‚Üí Filter X) :=\n  monotone_nhdsSet.strictMono_of_injective injective_nhdsSet\n\n"}
{"name":"nhds_le_nhdsSet_iff","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T1Space X\ns : Set X\nx : X\n‚ä¢ Iff (LE.le (nhds x) (nhdsSet s)) (Membership.mem s x)","decl":"@[simp]\ntheorem nhds_le_nhdsSet_iff [T1Space X] {s : Set X} {x : X} : ùìù x ‚â§ ùìùÀ¢ s ‚Üî x ‚àà s := by\n  rw [‚Üê nhdsSet_singleton, nhdsSet_le_iff, singleton_subset_iff]\n\n"}
{"name":"Dense.diff_singleton","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : T1Space X\ns : Set X\nhs : Dense s\nx : X\ninst‚úù : (nhdsWithin x (HasCompl.compl (Singleton.singleton x))).NeBot\n‚ä¢ Dense (SDiff.sdiff s (Singleton.singleton x))","decl":"/-- Removing a non-isolated point from a dense set, one still obtains a dense set. -/\ntheorem Dense.diff_singleton [T1Space X] {s : Set X} (hs : Dense s) (x : X) [NeBot (ùìù[‚â†] x)] :\n    Dense (s \\ {x}) :=\n  hs.inter_of_isOpen_right (dense_compl_singleton x) isOpen_compl_singleton\n\n"}
{"name":"Dense.diff_finset","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : T1Space X\ninst‚úù : ‚àÄ (x : X), (nhdsWithin x (HasCompl.compl (Singleton.singleton x))).NeBot\ns : Set X\nhs : Dense s\nt : Finset X\n‚ä¢ Dense (SDiff.sdiff s ‚Üët)","decl":"/-- Removing a finset from a dense set in a space without isolated points, one still\nobtains a dense set. -/\ntheorem Dense.diff_finset [T1Space X] [‚àÄ x : X, NeBot (ùìù[‚â†] x)] {s : Set X} (hs : Dense s)\n    (t : Finset X) : Dense (s \\ t) := by\n  classical\n  induction t using Finset.induction_on with\n  | empty => simpa using hs\n  | insert _ ih =>\n    rw [Finset.coe_insert, ‚Üê union_singleton, ‚Üê diff_diff]\n    exact ih.diff_singleton _\n\n"}
{"name":"Dense.diff_finite","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : T1Space X\ninst‚úù : ‚àÄ (x : X), (nhdsWithin x (HasCompl.compl (Singleton.singleton x))).NeBot\ns : Set X\nhs : Dense s\nt : Set X\nht : t.Finite\n‚ä¢ Dense (SDiff.sdiff s t)","decl":"/-- Removing a finite set from a dense set in a space without isolated points, one still\nobtains a dense set. -/\ntheorem Dense.diff_finite [T1Space X] [‚àÄ x : X, NeBot (ùìù[‚â†] x)] {s : Set X} (hs : Dense s)\n    {t : Set X} (ht : t.Finite) : Dense (s \\ t) := by\n  convert hs.diff_finset ht.toFinset\n  exact (Finite.coe_toFinset _).symm\n\n"}
{"name":"eq_of_tendsto_nhds","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : T1Space Y\nf : X ‚Üí Y\nx : X\ny : Y\nh : Filter.Tendsto f (nhds x) (nhds y)\n‚ä¢ Eq (f x) y","decl":"/-- If a function to a `T1Space` tends to some limit `y` at some point `x`, then necessarily\n`y = f x`. -/\ntheorem eq_of_tendsto_nhds [TopologicalSpace Y] [T1Space Y] {f : X ‚Üí Y} {x : X} {y : Y}\n    (h : Tendsto f (ùìù x) (ùìù y)) : f x = y :=\n  by_contra fun hfa : f x ‚â† y =>\n    have fact‚ÇÅ : {f x}·∂ú ‚àà ùìù y := compl_singleton_mem_nhds hfa.symm\n    have fact‚ÇÇ : Tendsto f (pure x) (ùìù y) := h.comp (tendsto_id'.2 <| pure_le_nhds x)\n    fact‚ÇÇ fact‚ÇÅ (Eq.refl <| f x)\n\n"}
{"name":"Filter.Tendsto.eventually_ne","module":"Mathlib.Topology.Separation.Basic","initialProofState":"Y : Type u_2\nX : Type u_3\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : T1Space Y\ng : X ‚Üí Y\nl : Filter X\nb‚ÇÅ b‚ÇÇ : Y\nhg : Filter.Tendsto g l (nhds b‚ÇÅ)\nhb : Ne b‚ÇÅ b‚ÇÇ\n‚ä¢ Filter.Eventually (fun z => Ne (g z) b‚ÇÇ) l","decl":"theorem Filter.Tendsto.eventually_ne {X} [TopologicalSpace Y] [T1Space Y] {g : X ‚Üí Y}\n    {l : Filter X} {b‚ÇÅ b‚ÇÇ : Y} (hg : Tendsto g l (ùìù b‚ÇÅ)) (hb : b‚ÇÅ ‚â† b‚ÇÇ) : ‚àÄ·∂† z in l, g z ‚â† b‚ÇÇ :=\n  hg.eventually (isOpen_compl_singleton.eventually_mem hb)\n\n"}
{"name":"ContinuousAt.eventually_ne","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : T1Space Y\ng : X ‚Üí Y\nx : X\ny : Y\nhg1 : ContinuousAt g x\nhg2 : Ne (g x) y\n‚ä¢ Filter.Eventually (fun z => Ne (g z) y) (nhds x)","decl":"theorem ContinuousAt.eventually_ne [TopologicalSpace Y] [T1Space Y] {g : X ‚Üí Y} {x : X} {y : Y}\n    (hg1 : ContinuousAt g x) (hg2 : g x ‚â† y) : ‚àÄ·∂† z in ùìù x, g z ‚â† y :=\n  hg1.tendsto.eventually_ne hg2\n\n"}
{"name":"eventually_ne_nhds","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T1Space X\na b : X\nh : Ne a b\n‚ä¢ Filter.Eventually (fun x => Ne x b) (nhds a)","decl":"theorem eventually_ne_nhds [T1Space X] {a b : X} (h : a ‚â† b) : ‚àÄ·∂† x in ùìù a, x ‚â† b :=\n  IsOpen.eventually_mem isOpen_ne h\n\n"}
{"name":"eventually_ne_nhdsWithin","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T1Space X\na b : X\ns : Set X\nh : Ne a b\n‚ä¢ Filter.Eventually (fun x => Ne x b) (nhdsWithin a s)","decl":"theorem eventually_ne_nhdsWithin [T1Space X] {a b : X} {s : Set X} (h : a ‚â† b) :\n    ‚àÄ·∂† x in ùìù[s] a, x ‚â† b :=\n  Filter.Eventually.filter_mono nhdsWithin_le_nhds <| eventually_ne_nhds h\n\n"}
{"name":"continuousWithinAt_insert","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : T1Space X\nx y : X\ns : Set X\nf : X ‚Üí Y\n‚ä¢ Iff (ContinuousWithinAt f (Insert.insert y s) x) (ContinuousWithinAt f s x)","decl":"theorem continuousWithinAt_insert [TopologicalSpace Y] [T1Space X]\n    {x y : X} {s : Set X} {f : X ‚Üí Y} :\n    ContinuousWithinAt f (insert y s) x ‚Üî ContinuousWithinAt f s x := by\n  rcases eq_or_ne x y with (rfl | h)\n  ¬∑ exact continuousWithinAt_insert_self\n  simp_rw [ContinuousWithinAt, nhdsWithin_insert_of_ne h]\n\n"}
{"name":"ContinuousWithinAt.of_insert","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : T1Space X\nx y : X\ns : Set X\nf : X ‚Üí Y\na‚úù : ContinuousWithinAt f (Insert.insert y s) x\n‚ä¢ ContinuousWithinAt f s x","decl":"alias ‚ü®ContinuousWithinAt.of_insert, ContinuousWithinAt.insert'‚ü© := continuousWithinAt_insert\n\n"}
{"name":"ContinuousWithinAt.insert'","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : T1Space X\nx y : X\ns : Set X\nf : X ‚Üí Y\na‚úù : ContinuousWithinAt f s x\n‚ä¢ ContinuousWithinAt f (Insert.insert y s) x","decl":"alias ‚ü®ContinuousWithinAt.of_insert, ContinuousWithinAt.insert'‚ü© := continuousWithinAt_insert\n\n"}
{"name":"continuousWithinAt_diff_singleton","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : T1Space X\nx y : X\ns : Set X\nf : X ‚Üí Y\n‚ä¢ Iff (ContinuousWithinAt f (SDiff.sdiff s (Singleton.singleton y)) x) (ContinuousWithinAt f s x)","decl":"/-- See also `continuousWithinAt_diff_self` for the case `y = x` but not requiring `T1Space`. -/\ntheorem continuousWithinAt_diff_singleton [TopologicalSpace Y] [T1Space X]\n    {x y : X} {s : Set X} {f : X ‚Üí Y} :\n    ContinuousWithinAt f (s \\ {y}) x ‚Üî ContinuousWithinAt f s x := by\n  rw [‚Üê continuousWithinAt_insert, insert_diff_singleton, continuousWithinAt_insert]\n\n"}
{"name":"continuousWithinAt_congr_set'","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : T1Space X\nx : X\ns t : Set X\nf : X ‚Üí Y\ny : X\nh : (nhdsWithin x (HasCompl.compl (Singleton.singleton y))).EventuallyEq s t\n‚ä¢ Iff (ContinuousWithinAt f s x) (ContinuousWithinAt f t x)","decl":"/-- If two sets coincide locally around `x`, except maybe at `y`, then it is equivalent to be\ncontinuous at `x` within one set or the other. -/\ntheorem continuousWithinAt_congr_set' [TopologicalSpace Y] [T1Space X]\n    {x : X} {s t : Set X} {f : X ‚Üí Y} (y : X) (h : s =·∂†[ùìù[{y}·∂ú] x] t) :\n    ContinuousWithinAt f s x ‚Üî ContinuousWithinAt f t x := by\n  rw [‚Üê continuousWithinAt_insert_self (s := s), ‚Üê continuousWithinAt_insert_self (s := t)]\n  exact continuousWithinAt_congr_set (eventuallyEq_insert h)\n\n"}
{"name":"continuousAt_of_tendsto_nhds","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : T1Space Y\nf : X ‚Üí Y\nx : X\ny : Y\nh : Filter.Tendsto f (nhds x) (nhds y)\n‚ä¢ ContinuousAt f x","decl":"/-- To prove a function to a `T1Space` is continuous at some point `x`, it suffices to prove that\n`f` admits *some* limit at `x`. -/\ntheorem continuousAt_of_tendsto_nhds [TopologicalSpace Y] [T1Space Y] {f : X ‚Üí Y} {x : X} {y : Y}\n    (h : Tendsto f (ùìù x) (ùìù y)) : ContinuousAt f x := by\n  rwa [ContinuousAt, eq_of_tendsto_nhds h]\n\n"}
{"name":"tendsto_const_nhds_iff","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : T1Space X\nl : Filter Y\ninst‚úù : l.NeBot\nc d : X\n‚ä¢ Iff (Filter.Tendsto (fun x => c) l (nhds d)) (Eq c d)","decl":"@[simp]\ntheorem tendsto_const_nhds_iff [T1Space X] {l : Filter Y} [NeBot l] {c d : X} :\n    Tendsto (fun _ => c) l (ùìù d) ‚Üî c = d := by simp_rw [Tendsto, Filter.map_const, pure_le_nhds_iff]\n\n"}
{"name":"isOpen_singleton_of_finite_mem_nhds","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T1Space X\nx : X\ns : Set X\nhs : Membership.mem (nhds x) s\nhsf : s.Finite\n‚ä¢ IsOpen (Singleton.singleton x)","decl":"/-- A point with a finite neighborhood has to be isolated. -/\ntheorem isOpen_singleton_of_finite_mem_nhds [T1Space X] (x : X)\n    {s : Set X} (hs : s ‚àà ùìù x) (hsf : s.Finite) : IsOpen ({x} : Set X) := by\n  have A : {x} ‚äÜ s := by simp only [singleton_subset_iff, mem_of_mem_nhds hs]\n  have B : IsClosed (s \\ {x}) := (hsf.subset diff_subset).isClosed\n  have C : (s \\ {x})·∂ú ‚àà ùìù x := B.isOpen_compl.mem_nhds fun h => h.2 rfl\n  have D : {x} ‚àà ùìù x := by simpa only [‚Üê diff_eq, diff_diff_cancel_left A] using inter_mem hs C\n  rwa [‚Üê mem_interior_iff_mem_nhds, ‚Üê singleton_subset_iff, subset_interior_iff_isOpen] at D\n\n"}
{"name":"infinite_of_mem_nhds","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_3\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T1Space X\nx : X\nhx : (nhdsWithin x (HasCompl.compl (Singleton.singleton x))).NeBot\ns : Set X\nhs : Membership.mem (nhds x) s\n‚ä¢ s.Infinite","decl":"/-- If the punctured neighborhoods of a point form a nontrivial filter, then any neighborhood is\ninfinite. -/\ntheorem infinite_of_mem_nhds {X} [TopologicalSpace X] [T1Space X] (x : X) [hx : NeBot (ùìù[‚â†] x)]\n    {s : Set X} (hs : s ‚àà ùìù x) : Set.Infinite s := by\n  refine fun hsf => hx.1 ?_\n  rw [‚Üê isOpen_singleton_iff_punctured_nhds]\n  exact isOpen_singleton_of_finite_mem_nhds x hs hsf\n\n"}
{"name":"Finite.instDiscreteTopology","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : T1Space X\ninst‚úù : Finite X\n‚ä¢ DiscreteTopology X","decl":"instance Finite.instDiscreteTopology [T1Space X] [Finite X] : DiscreteTopology X :=\n  discreteTopology_iff_forall_isClosed.mpr (¬∑ |>.toFinite.isClosed)\n\n"}
{"name":"Set.Finite.continuousOn","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : T1Space X\ninst‚úù : TopologicalSpace Y\ns : Set X\nhs : s.Finite\nf : X ‚Üí Y\n‚ä¢ ContinuousOn f s","decl":"theorem Set.Finite.continuousOn [T1Space X] [TopologicalSpace Y] {s : Set X} (hs : s.Finite)\n    (f : X ‚Üí Y) : ContinuousOn f s := by\n  rw [continuousOn_iff_continuous_restrict]\n  have : Finite s := hs\n  fun_prop\n\n"}
{"name":"PreconnectedSpace.trivial_of_discrete","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : PreconnectedSpace X\ninst‚úù : DiscreteTopology X\n‚ä¢ Subsingleton X","decl":"theorem PreconnectedSpace.trivial_of_discrete [PreconnectedSpace X] [DiscreteTopology X] :\n    Subsingleton X := by\n  rw [‚Üê not_nontrivial_iff_subsingleton]\n  rintro ‚ü®x, y, hxy‚ü©\n  rw [Ne, ‚Üê mem_singleton_iff, (isClopen_discrete _).eq_univ <| singleton_nonempty y] at hxy\n  exact hxy (mem_univ x)\n\n"}
{"name":"IsPreconnected.infinite_of_nontrivial","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T1Space X\ns : Set X\nh : IsPreconnected s\nhs : s.Nontrivial\n‚ä¢ s.Infinite","decl":"theorem IsPreconnected.infinite_of_nontrivial [T1Space X] {s : Set X} (h : IsPreconnected s)\n    (hs : s.Nontrivial) : s.Infinite := by\n  refine mt (fun hf => (subsingleton_coe s).mp ?_) (not_subsingleton_iff.mpr hs)\n  haveI := @Finite.instDiscreteTopology s _ _ hf.to_subtype\n  exact @PreconnectedSpace.trivial_of_discrete _ _ (Subtype.preconnectedSpace h) _\n\n"}
{"name":"ConnectedSpace.infinite","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : ConnectedSpace X\ninst‚úù¬π : Nontrivial X\ninst‚úù : T1Space X\n‚ä¢ Infinite X","decl":"theorem ConnectedSpace.infinite [ConnectedSpace X] [Nontrivial X] [T1Space X] : Infinite X :=\n  infinite_univ_iff.mp <| isPreconnected_univ.infinite_of_nontrivial nontrivial_univ\n\n"}
{"name":"ConnectedSpace.neBot_nhdsWithin_compl_of_nontrivial_of_t1space","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : ConnectedSpace X\ninst‚úù¬π : Nontrivial X\ninst‚úù : T1Space X\nx : X\n‚ä¢ (nhdsWithin x (HasCompl.compl (Singleton.singleton x))).NeBot","decl":"/-- A non-trivial connected T1 space has no isolated points. -/\ninstance (priority := 100) ConnectedSpace.neBot_nhdsWithin_compl_of_nontrivial_of_t1space\n    [ConnectedSpace X] [Nontrivial X] [T1Space X] (x : X) :\n    NeBot (ùìù[‚â†] x) := by\n  by_contra contra\n  rw [not_neBot, ‚Üê isOpen_singleton_iff_punctured_nhds] at contra\n  replace contra := nonempty_inter isOpen_compl_singleton\n    contra (compl_union_self _) (Set.nonempty_compl_of_nontrivial _) (singleton_nonempty _)\n  simp [compl_inter_self {x}] at contra\n\n"}
{"name":"SeparationQuotient.t1Space_iff","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\n‚ä¢ Iff (T1Space (SeparationQuotient X)) (R0Space X)","decl":"theorem SeparationQuotient.t1Space_iff : T1Space (SeparationQuotient X) ‚Üî R0Space X := by\n  rw [r0Space_iff, ((t1Space_TFAE (SeparationQuotient X)).out 0 9 :)]\n  constructor\n  ¬∑ intro h x y xspecy\n    rw [‚Üê IsInducing.specializes_iff isInducing_mk, h xspecy] at *\n  ¬∑ rintro h ‚ü®x‚ü© ‚ü®y‚ü© sxspecsy\n    have xspecy : x ‚§≥ y := isInducing_mk.specializes_iff.mp sxspecsy\n    have yspecx : y ‚§≥ x := h xspecy\n    erw [mk_eq_mk, inseparable_iff_specializes_and]\n    exact ‚ü®xspecy, yspecx‚ü©\n\n"}
{"name":"Set.Subsingleton.isClosed","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T1Space X\nA : Set X\nh : A.Subsingleton\n‚ä¢ IsClosed A","decl":"lemma Set.Subsingleton.isClosed [T1Space X] {A : Set X} (h : A.Subsingleton) : IsClosed A := by\n  rcases h.eq_empty_or_singleton with rfl | ‚ü®x, rfl‚ü©\n  ¬∑ exact isClosed_empty\n  ¬∑ exact isClosed_singleton\n\n"}
{"name":"isClosed_inter_singleton","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T1Space X\nA : Set X\na : X\n‚ä¢ IsClosed (Inter.inter A (Singleton.singleton a))","decl":"lemma isClosed_inter_singleton [T1Space X] {A : Set X} {a : X} : IsClosed (A ‚à© {a}) :=\n  Subsingleton.inter_singleton.isClosed\n\n"}
{"name":"isClosed_singleton_inter","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T1Space X\nA : Set X\na : X\n‚ä¢ IsClosed (Inter.inter (Singleton.singleton a) A)","decl":"lemma isClosed_singleton_inter [T1Space X] {A : Set X} {a : X} : IsClosed ({a} ‚à© A) :=\n  Subsingleton.singleton_inter.isClosed\n\n"}
{"name":"singleton_mem_nhdsWithin_of_mem_discrete","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ns : Set X\ninst‚úù : DiscreteTopology ‚Üës\nx : X\nhx : Membership.mem s x\n‚ä¢ Membership.mem (nhdsWithin x s) (Singleton.singleton x)","decl":"theorem singleton_mem_nhdsWithin_of_mem_discrete {s : Set X} [DiscreteTopology s] {x : X}\n    (hx : x ‚àà s) : {x} ‚àà ùìù[s] x := by\n  have : ({‚ü®x, hx‚ü©} : Set s) ‚àà ùìù (‚ü®x, hx‚ü© : s) := by simp [nhds_discrete]\n  simpa only [nhdsWithin_eq_map_subtype_coe hx, image_singleton] using\n    @image_mem_map _ _ _ ((‚Üë) : s ‚Üí X) _ this\n\n"}
{"name":"nhdsWithin_of_mem_discrete","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ns : Set X\ninst‚úù : DiscreteTopology ‚Üës\nx : X\nhx : Membership.mem s x\n‚ä¢ Eq (nhdsWithin x s) (Pure.pure x)","decl":"/-- The neighbourhoods filter of `x` within `s`, under the discrete topology, is equal to\nthe pure `x` filter (which is the principal filter at the singleton `{x}`.) -/\ntheorem nhdsWithin_of_mem_discrete {s : Set X} [DiscreteTopology s] {x : X} (hx : x ‚àà s) :\n    ùìù[s] x = pure x :=\n  le_antisymm (le_pure_iff.2 <| singleton_mem_nhdsWithin_of_mem_discrete hx) (pure_le_nhdsWithin hx)\n\n"}
{"name":"Filter.HasBasis.exists_inter_eq_singleton_of_mem_discrete","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\nŒπ : Type u_3\np : Œπ ‚Üí Prop\nt : Œπ ‚Üí Set X\ns : Set X\ninst‚úù : DiscreteTopology ‚Üës\nx : X\nhb : (nhds x).HasBasis p t\nhx : Membership.mem s x\n‚ä¢ Exists fun i => And (p i) (Eq (Inter.inter (t i) s) (Singleton.singleton x))","decl":"theorem Filter.HasBasis.exists_inter_eq_singleton_of_mem_discrete {Œπ : Type*} {p : Œπ ‚Üí Prop}\n    {t : Œπ ‚Üí Set X} {s : Set X} [DiscreteTopology s] {x : X} (hb : (ùìù x).HasBasis p t)\n    (hx : x ‚àà s) : ‚àÉ i, p i ‚àß t i ‚à© s = {x} := by\n  rcases (nhdsWithin_hasBasis hb s).mem_iff.1 (singleton_mem_nhdsWithin_of_mem_discrete hx) with\n    ‚ü®i, hi, hix‚ü©\n  exact ‚ü®i, hi, hix.antisymm <| singleton_subset_iff.2 ‚ü®mem_of_mem_nhds <| hb.mem_of_mem hi, hx‚ü©‚ü©\n\n"}
{"name":"nhds_inter_eq_singleton_of_mem_discrete","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ns : Set X\ninst‚úù : DiscreteTopology ‚Üës\nx : X\nhx : Membership.mem s x\n‚ä¢ Exists fun U => And (Membership.mem (nhds x) U) (Eq (Inter.inter U s) (Singleton.singleton x))","decl":"/-- A point `x` in a discrete subset `s` of a topological space admits a neighbourhood\nthat only meets `s` at `x`. -/\ntheorem nhds_inter_eq_singleton_of_mem_discrete {s : Set X} [DiscreteTopology s] {x : X}\n    (hx : x ‚àà s) : ‚àÉ U ‚àà ùìù x, U ‚à© s = {x} := by\n  simpa using (ùìù x).basis_sets.exists_inter_eq_singleton_of_mem_discrete hx\n\n"}
{"name":"isOpen_inter_eq_singleton_of_mem_discrete","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ns : Set X\ninst‚úù : DiscreteTopology ‚Üës\nx : X\nhx : Membership.mem s x\n‚ä¢ Exists fun U => And (IsOpen U) (Eq (Inter.inter U s) (Singleton.singleton x))","decl":"/-- Let `x` be a point in a discrete subset `s` of a topological space, then there exists an open\nset that only meets `s` at `x`. -/\ntheorem isOpen_inter_eq_singleton_of_mem_discrete {s : Set X} [DiscreteTopology s] {x : X}\n    (hx : x ‚àà s) : ‚àÉ U : Set X, IsOpen U ‚àß U ‚à© s = {x} := by\n  obtain ‚ü®U, hU_nhds, hU_inter‚ü© := nhds_inter_eq_singleton_of_mem_discrete hx\n  obtain ‚ü®t, ht_sub, ht_open, ht_x‚ü© := mem_nhds_iff.mp hU_nhds\n  refine ‚ü®t, ht_open, Set.Subset.antisymm ?_ ?_‚ü©\n  ¬∑ exact hU_inter ‚ñ∏ Set.inter_subset_inter_left s ht_sub\n  ¬∑ rw [Set.subset_inter_iff, Set.singleton_subset_iff, Set.singleton_subset_iff]\n    exact ‚ü®ht_x, hx‚ü©\n\n"}
{"name":"disjoint_nhdsWithin_of_mem_discrete","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ns : Set X\ninst‚úù : DiscreteTopology ‚Üës\nx : X\nhx : Membership.mem s x\n‚ä¢ Exists fun U => And (Membership.mem (nhdsWithin x (HasCompl.compl (Singleton.singleton x))) U) (Disjoint U s)","decl":"/-- For point `x` in a discrete subset `s` of a topological space, there is a set `U`\nsuch that\n1. `U` is a punctured neighborhood of `x` (ie. `U ‚à™ {x}` is a neighbourhood of `x`),\n2. `U` is disjoint from `s`.\n-/\ntheorem disjoint_nhdsWithin_of_mem_discrete {s : Set X} [DiscreteTopology s] {x : X} (hx : x ‚àà s) :\n    ‚àÉ U ‚àà ùìù[‚â†] x, Disjoint U s :=\n  let ‚ü®V, h, h'‚ü© := nhds_inter_eq_singleton_of_mem_discrete hx\n  ‚ü®{x}·∂ú ‚à© V, inter_mem_nhdsWithin _ h,\n    disjoint_iff_inter_eq_empty.mpr (by rw [inter_assoc, h', compl_inter_self])‚ü©\n\n"}
{"name":"isClosedEmbedding_update","module":"Mathlib.Topology.Separation.Basic","initialProofState":"Œπ : Type u_3\nŒ≤ : Œπ ‚Üí Type u_4\ninst‚úù¬≤ : DecidableEq Œπ\ninst‚úù¬π : (i : Œπ) ‚Üí TopologicalSpace (Œ≤ i)\nx : (i : Œπ) ‚Üí Œ≤ i\ni : Œπ\ninst‚úù : ‚àÄ (i : Œπ), T1Space (Œ≤ i)\n‚ä¢ Topology.IsClosedEmbedding (Function.update x i)","decl":"theorem isClosedEmbedding_update {Œπ : Type*} {Œ≤ : Œπ ‚Üí Type*}\n    [DecidableEq Œπ] [(i : Œπ) ‚Üí TopologicalSpace (Œ≤ i)]\n    (x : (i : Œπ) ‚Üí Œ≤ i) (i : Œπ) [(i : Œπ) ‚Üí T1Space (Œ≤ i)] :\n    IsClosedEmbedding (update x i) := by\n  refine .of_continuous_injective_isClosedMap (continuous_const.update i continuous_id)\n    (update_injective x i) fun s hs ‚Ü¶ ?_\n  rw [update_image]\n  apply isClosed_set_pi\n  simp [forall_update_iff, hs, isClosed_singleton]\n\n"}
{"name":"closedEmbedding_update","module":"Mathlib.Topology.Separation.Basic","initialProofState":"Œπ : Type u_3\nŒ≤ : Œπ ‚Üí Type u_4\ninst‚úù¬≤ : DecidableEq Œπ\ninst‚úù¬π : (i : Œπ) ‚Üí TopologicalSpace (Œ≤ i)\nx : (i : Œπ) ‚Üí Œ≤ i\ni : Œπ\ninst‚úù : ‚àÄ (i : Œπ), T1Space (Œ≤ i)\n‚ä¢ Topology.IsClosedEmbedding (Function.update x i)","decl":"@[deprecated (since := \"2024-10-20\")]\nalias closedEmbedding_update := isClosedEmbedding_update\n\n"}
{"name":"r1Space_iff_specializes_or_disjoint_nhds","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_3\ninst‚úù : TopologicalSpace X\n‚ä¢ Iff (R1Space X) (‚àÄ (x y : X), Or (Specializes x y) (Disjoint (nhds x) (nhds y)))","decl":"/-- A topological space is called a *preregular* (a.k.a. R‚ÇÅ) space,\nif any two topologically distinguishable points have disjoint neighbourhoods. -/\n@[mk_iff r1Space_iff_specializes_or_disjoint_nhds]\nclass R1Space (X : Type*) [TopologicalSpace X] : Prop where\n  specializes_or_disjoint_nhds (x y : X) : Specializes x y ‚à® Disjoint (ùìù x) (ùìù y)\n\n"}
{"name":"R1Space.specializes_or_disjoint_nhds","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_3\ninst‚úù : TopologicalSpace X\nself : R1Space X\nx y : X\n‚ä¢ Or (Specializes x y) (Disjoint (nhds x) (nhds y))","decl":"/-- A topological space is called a *preregular* (a.k.a. R‚ÇÅ) space,\nif any two topologically distinguishable points have disjoint neighbourhoods. -/\n@[mk_iff r1Space_iff_specializes_or_disjoint_nhds]\nclass R1Space (X : Type*) [TopologicalSpace X] : Prop where\n  specializes_or_disjoint_nhds (x y : X) : Specializes x y ‚à® Disjoint (ùìù x) (ùìù y)\n\n"}
{"name":"instR0Space","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : R1Space X\n‚ä¢ R0Space X","decl":"instance (priority := 100) : R0Space X where\n  specializes_symmetric _ _ h := (specializes_or_disjoint_nhds _ _).resolve_right <| fun hd ‚Ü¶\n    h.not_disjoint hd.symm\n\n"}
{"name":"disjoint_nhds_nhds_iff_not_specializes","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : R1Space X\nx y : X\n‚ä¢ Iff (Disjoint (nhds x) (nhds y)) (Not (Specializes x y))","decl":"theorem disjoint_nhds_nhds_iff_not_specializes : Disjoint (ùìù x) (ùìù y) ‚Üî ¬¨x ‚§≥ y :=\n  ‚ü®fun hd hspec ‚Ü¶ hspec.not_disjoint hd, (specializes_or_disjoint_nhds _ _).resolve_left‚ü©\n\n"}
{"name":"specializes_iff_not_disjoint","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : R1Space X\nx y : X\n‚ä¢ Iff (Specializes x y) (Not (Disjoint (nhds x) (nhds y)))","decl":"theorem specializes_iff_not_disjoint : x ‚§≥ y ‚Üî ¬¨Disjoint (ùìù x) (ùìù y) :=\n  disjoint_nhds_nhds_iff_not_specializes.not_left.symm\n\n"}
{"name":"disjoint_nhds_nhds_iff_not_inseparable","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : R1Space X\nx y : X\n‚ä¢ Iff (Disjoint (nhds x) (nhds y)) (Not (Inseparable x y))","decl":"theorem disjoint_nhds_nhds_iff_not_inseparable : Disjoint (ùìù x) (ùìù y) ‚Üî ¬¨Inseparable x y := by\n  rw [disjoint_nhds_nhds_iff_not_specializes, specializes_iff_inseparable]\n\n"}
{"name":"r1Space_iff_inseparable_or_disjoint_nhds","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_3\ninst‚úù : TopologicalSpace X\n‚ä¢ Iff (R1Space X) (‚àÄ (x y : X), Or (Inseparable x y) (Disjoint (nhds x) (nhds y)))","decl":"theorem r1Space_iff_inseparable_or_disjoint_nhds {X : Type*} [TopologicalSpace X] :\n    R1Space X ‚Üî ‚àÄ x y : X, Inseparable x y ‚à® Disjoint (ùìù x) (ùìù y) :=\n  ‚ü®fun _h x y ‚Ü¶ (specializes_or_disjoint_nhds x y).imp_left Specializes.inseparable, fun h ‚Ü¶\n    ‚ü®fun x y ‚Ü¶ (h x y).imp_left Inseparable.specializes‚ü©‚ü©\n\n"}
{"name":"Inseparable.of_nhds_neBot","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : R1Space X\nx y : X\nh : (Min.min (nhds x) (nhds y)).NeBot\n‚ä¢ Inseparable x y","decl":"theorem Inseparable.of_nhds_neBot {x y : X} (h : NeBot (ùìù x ‚äì ùìù y)) :\n    Inseparable x y :=\n  (r1Space_iff_inseparable_or_disjoint_nhds.mp ‚Äπ_‚Ä∫ _ _).resolve_right fun h' => h.ne h'.eq_bot\n\n"}
{"name":"tendsto_nhds_unique_inseparable","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : R1Space X\nf : Y ‚Üí X\nl : Filter Y\na b : X\ninst‚úù : l.NeBot\nha : Filter.Tendsto f l (nhds a)\nhb : Filter.Tendsto f l (nhds b)\n‚ä¢ Inseparable a b","decl":"/-- Limits are unique up to separability.\n\nA weaker version of `tendsto_nhds_unique` for `R1Space`. -/\ntheorem tendsto_nhds_unique_inseparable {f : Y ‚Üí X} {l : Filter Y} {a b : X} [NeBot l]\n    (ha : Tendsto f l (ùìù a)) (hb : Tendsto f l (ùìù b)) : Inseparable a b :=\n  .of_nhds_neBot <| neBot_of_le <| le_inf ha hb\n\n"}
{"name":"isClosed_setOf_specializes","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : R1Space X\n‚ä¢ IsClosed (setOf fun p => Specializes p.1 p.2)","decl":"theorem isClosed_setOf_specializes : IsClosed { p : X √ó X | p.1 ‚§≥ p.2 } := by\n  simp only [‚Üê isOpen_compl_iff, compl_setOf, ‚Üê disjoint_nhds_nhds_iff_not_specializes,\n    isOpen_setOf_disjoint_nhds_nhds]\n\n"}
{"name":"isClosed_setOf_inseparable","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : R1Space X\n‚ä¢ IsClosed (setOf fun p => Inseparable p.1 p.2)","decl":"theorem isClosed_setOf_inseparable : IsClosed { p : X √ó X | Inseparable p.1 p.2 } := by\n  simp only [‚Üê specializes_iff_inseparable, isClosed_setOf_specializes]\n\n"}
{"name":"IsCompact.mem_closure_iff_exists_inseparable","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : R1Space X\ny : X\nK : Set X\nhK : IsCompact K\n‚ä¢ Iff (Membership.mem (closure K) y) (Exists fun x => And (Membership.mem K x) (Inseparable x y))","decl":"/-- In an R‚ÇÅ space, a point belongs to the closure of a compact set `K`\nif and only if it is topologically inseparable from some point of `K`. -/\ntheorem IsCompact.mem_closure_iff_exists_inseparable {K : Set X} (hK : IsCompact K) :\n    y ‚àà closure K ‚Üî ‚àÉ x ‚àà K, Inseparable x y := by\n  refine ‚ü®fun hy ‚Ü¶ ?_, fun ‚ü®x, hxK, hxy‚ü© ‚Ü¶\n    (hxy.mem_closed_iff isClosed_closure).1 <| subset_closure hxK‚ü©\n  contrapose! hy\n  have : Disjoint (ùìù y) (ùìùÀ¢ K) := hK.disjoint_nhdsSet_right.2 fun x hx ‚Ü¶\n    (disjoint_nhds_nhds_iff_not_inseparable.2 (hy x hx)).symm\n  simpa only [disjoint_iff, not_mem_closure_iff_nhdsWithin_eq_bot]\n    using this.mono_right principal_le_nhdsSet\n\n"}
{"name":"IsCompact.closure_eq_biUnion_inseparable","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : R1Space X\nK : Set X\nhK : IsCompact K\n‚ä¢ Eq (closure K) (Set.iUnion fun x => Set.iUnion fun h => setOf fun y => Inseparable x y)","decl":"theorem IsCompact.closure_eq_biUnion_inseparable {K : Set X} (hK : IsCompact K) :\n    closure K = ‚ãÉ x ‚àà K, {y | Inseparable x y} := by\n  ext; simp [hK.mem_closure_iff_exists_inseparable]\n\n"}
{"name":"IsCompact.closure_eq_biUnion_closure_singleton","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : R1Space X\nK : Set X\nhK : IsCompact K\n‚ä¢ Eq (closure K) (Set.iUnion fun x => Set.iUnion fun h => closure (Singleton.singleton x))","decl":"/-- In an R‚ÇÅ space, the closure of a compact set is the union of the closures of its points. -/\ntheorem IsCompact.closure_eq_biUnion_closure_singleton {K : Set X} (hK : IsCompact K) :\n    closure K = ‚ãÉ x ‚àà K, closure {x} := by\n  simp only [hK.closure_eq_biUnion_inseparable, ‚Üê specializes_iff_inseparable,\n    specializes_iff_mem_closure, setOf_mem_eq]\n\n"}
{"name":"IsCompact.closure_subset_of_isOpen","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : R1Space X\nK : Set X\nhK : IsCompact K\nU : Set X\nhU : IsOpen U\nhKU : HasSubset.Subset K U\n‚ä¢ HasSubset.Subset (closure K) U","decl":"/-- In an R‚ÇÅ space, if a compact set `K` is contained in an open set `U`,\nthen its closure is also contained in `U`. -/\ntheorem IsCompact.closure_subset_of_isOpen {K : Set X} (hK : IsCompact K)\n    {U : Set X} (hU : IsOpen U) (hKU : K ‚äÜ U) : closure K ‚äÜ U := by\n  rw [hK.closure_eq_biUnion_inseparable, iUnion‚ÇÇ_subset_iff]\n  exact fun x hx y hxy ‚Ü¶ (hxy.mem_open_iff hU).1 (hKU hx)\n\n"}
{"name":"IsCompact.closure","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : R1Space X\nK : Set X\nhK : IsCompact K\n‚ä¢ IsCompact (closure K)","decl":"/-- The closure of a compact set in an R‚ÇÅ space is a compact set. -/\nprotected theorem IsCompact.closure {K : Set X} (hK : IsCompact K) : IsCompact (closure K) := by\n  refine isCompact_of_finite_subcover fun U hUo hKU ‚Ü¶ ?_\n  rcases hK.elim_finite_subcover U hUo (subset_closure.trans hKU) with ‚ü®t, ht‚ü©\n  exact ‚ü®t, hK.closure_subset_of_isOpen (isOpen_biUnion fun _ _ ‚Ü¶ hUo _) ht‚ü©\n\n"}
{"name":"IsCompact.closure_of_subset","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : R1Space X\ns K : Set X\nhK : IsCompact K\nh : HasSubset.Subset s K\n‚ä¢ IsCompact (closure s)","decl":"theorem IsCompact.closure_of_subset {s K : Set X} (hK : IsCompact K) (h : s ‚äÜ K) :\n    IsCompact (closure s) :=\n  hK.closure.of_isClosed_subset isClosed_closure (closure_mono h)\n\n"}
{"name":"exists_isCompact_superset_iff","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : R1Space X\ns : Set X\n‚ä¢ Iff (Exists fun K => And (IsCompact K) (HasSubset.Subset s K)) (IsCompact (closure s))","decl":"@[simp]\ntheorem exists_isCompact_superset_iff {s : Set X} :\n    (‚àÉ K, IsCompact K ‚àß s ‚äÜ K) ‚Üî IsCompact (closure s) :=\n  ‚ü®fun ‚ü®_K, hK, hsK‚ü© => hK.closure_of_subset hsK, fun h => ‚ü®closure s, h, subset_closure‚ü©‚ü©\n\n"}
{"name":"SeparatedNhds.of_isCompact_isCompact_isClosed","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : R1Space X\nK L : Set X\nhK : IsCompact K\nhL : IsCompact L\nh'L : IsClosed L\nhd : Disjoint K L\n‚ä¢ SeparatedNhds K L","decl":"/-- If `K` and `L` are disjoint compact sets in an R‚ÇÅ topological space\nand `L` is also closed, then `K` and `L` have disjoint neighborhoods. -/\ntheorem SeparatedNhds.of_isCompact_isCompact_isClosed {K L : Set X} (hK : IsCompact K)\n    (hL : IsCompact L) (h'L : IsClosed L) (hd : Disjoint K L) : SeparatedNhds K L := by\n  simp_rw [separatedNhds_iff_disjoint, hK.disjoint_nhdsSet_left, hL.disjoint_nhdsSet_right,\n    disjoint_nhds_nhds_iff_not_inseparable]\n  intro x hx y hy h\n  exact absurd ((h.mem_closed_iff h'L).2 hy) <| disjoint_left.1 hd hx\n\n"}
{"name":"IsCompact.binary_compact_cover","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : R1Space X\nK U V : Set X\nhK : IsCompact K\nhU : IsOpen U\nhV : IsOpen V\nh2K : HasSubset.Subset K (Union.union U V)\n‚ä¢ Exists fun K‚ÇÅ => Exists fun K‚ÇÇ => And (IsCompact K‚ÇÅ) (And (IsCompact K‚ÇÇ) (And (HasSubset.Subset K‚ÇÅ U) (And (HasSubset.Subset K‚ÇÇ V) (Eq K (Union.union K‚ÇÅ K‚ÇÇ)))))","decl":"/-- If a compact set is covered by two open sets, then we can cover it by two compact subsets. -/\ntheorem IsCompact.binary_compact_cover {K U V : Set X}\n    (hK : IsCompact K) (hU : IsOpen U) (hV : IsOpen V) (h2K : K ‚äÜ U ‚à™ V) :\n    ‚àÉ K‚ÇÅ K‚ÇÇ : Set X, IsCompact K‚ÇÅ ‚àß IsCompact K‚ÇÇ ‚àß K‚ÇÅ ‚äÜ U ‚àß K‚ÇÇ ‚äÜ V ‚àß K = K‚ÇÅ ‚à™ K‚ÇÇ := by\n  have hK' : IsCompact (closure K) := hK.closure\n  have : SeparatedNhds (closure K \\ U) (closure K \\ V) := by\n    apply SeparatedNhds.of_isCompact_isCompact_isClosed (hK'.diff hU) (hK'.diff hV)\n      (isClosed_closure.sdiff hV)\n    rw [disjoint_iff_inter_eq_empty, diff_inter_diff, diff_eq_empty]\n    exact hK.closure_subset_of_isOpen (hU.union hV) h2K\n  have : SeparatedNhds (K \\ U) (K \\ V) :=\n    this.mono (diff_subset_diff_left (subset_closure)) (diff_subset_diff_left (subset_closure))\n  rcases this with ‚ü®O‚ÇÅ, O‚ÇÇ, h1O‚ÇÅ, h1O‚ÇÇ, h2O‚ÇÅ, h2O‚ÇÇ, hO‚ü©\n  exact ‚ü®K \\ O‚ÇÅ, K \\ O‚ÇÇ, hK.diff h1O‚ÇÅ, hK.diff h1O‚ÇÇ, diff_subset_comm.mp h2O‚ÇÅ,\n    diff_subset_comm.mp h2O‚ÇÇ, by rw [‚Üê diff_inter, hO.inter_eq, diff_empty]‚ü©\n\n"}
{"name":"IsCompact.finite_compact_cover","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : R1Space X\ns : Set X\nhs : IsCompact s\nŒπ : Type u_3\nt : Finset Œπ\nU : Œπ ‚Üí Set X\nhU : ‚àÄ (i : Œπ), Membership.mem t i ‚Üí IsOpen (U i)\nhsC : HasSubset.Subset s (Set.iUnion fun i => Set.iUnion fun h => U i)\n‚ä¢ Exists fun K => And (‚àÄ (i : Œπ), IsCompact (K i)) (And (‚àÄ (i : Œπ), HasSubset.Subset (K i) (U i)) (Eq s (Set.iUnion fun i => Set.iUnion fun h => K i)))","decl":"/-- For every finite open cover `U·µ¢` of a compact set, there exists a compact cover `K·µ¢ ‚äÜ U·µ¢`. -/\ntheorem IsCompact.finite_compact_cover {s : Set X} (hs : IsCompact s) {Œπ : Type*}\n    (t : Finset Œπ) (U : Œπ ‚Üí Set X) (hU : ‚àÄ i ‚àà t, IsOpen (U i)) (hsC : s ‚äÜ ‚ãÉ i ‚àà t, U i) :\n    ‚àÉ K : Œπ ‚Üí Set X, (‚àÄ i, IsCompact (K i)) ‚àß (‚àÄ i, K i ‚äÜ U i) ‚àß s = ‚ãÉ i ‚àà t, K i := by\n  classical\n  induction' t using Finset.induction with x t hx ih generalizing U s\n  ¬∑ refine ‚ü®fun _ => ‚àÖ, fun _ => isCompact_empty, fun i => empty_subset _, ?_‚ü©\n    simpa only [subset_empty_iff, Finset.not_mem_empty, iUnion_false, iUnion_empty] using hsC\n  simp only [Finset.set_biUnion_insert] at hsC\n  simp only [Finset.forall_mem_insert] at hU\n  have hU' : ‚àÄ i ‚àà t, IsOpen (U i) := fun i hi => hU.2 i hi\n  rcases hs.binary_compact_cover hU.1 (isOpen_biUnion hU') hsC with\n    ‚ü®K‚ÇÅ, K‚ÇÇ, h1K‚ÇÅ, h1K‚ÇÇ, h2K‚ÇÅ, h2K‚ÇÇ, hK‚ü©\n  rcases ih h1K‚ÇÇ U hU' h2K‚ÇÇ with ‚ü®K, h1K, h2K, h3K‚ü©\n  refine ‚ü®update K x K‚ÇÅ, ?_, ?_, ?_‚ü©\n  ¬∑ intro i\n    rcases eq_or_ne i x with rfl | hi\n    ¬∑ simp only [update_self, h1K‚ÇÅ]\n    ¬∑ simp only [update_of_ne hi, h1K]\n  ¬∑ intro i\n    rcases eq_or_ne i x with rfl | hi\n    ¬∑ simp only [update_self, h2K‚ÇÅ]\n    ¬∑ simp only [update_of_ne hi, h2K]\n  ¬∑ simp only [Finset.set_biUnion_insert_update _ hx, hK, h3K]\n\n"}
{"name":"R1Space.of_continuous_specializes_imp","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : R1Space X\ninst‚úù : TopologicalSpace Y\nf : Y ‚Üí X\nhc : Continuous f\nhspec : ‚àÄ (x y : Y), Specializes (f x) (f y) ‚Üí Specializes x y\n‚ä¢ R1Space Y","decl":"theorem R1Space.of_continuous_specializes_imp [TopologicalSpace Y] {f : Y ‚Üí X} (hc : Continuous f)\n    (hspec : ‚àÄ x y, f x ‚§≥ f y ‚Üí x ‚§≥ y) : R1Space Y where\n  specializes_or_disjoint_nhds x y := (specializes_or_disjoint_nhds (f x) (f y)).imp (hspec x y) <|\n    ((hc.tendsto _).disjoint ¬∑ (hc.tendsto _))\n\n"}
{"name":"Topology.IsInducing.r1Space","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : R1Space X\ninst‚úù : TopologicalSpace Y\nf : Y ‚Üí X\nhf : Topology.IsInducing f\n‚ä¢ R1Space Y","decl":"theorem Topology.IsInducing.r1Space [TopologicalSpace Y] {f : Y ‚Üí X} (hf : IsInducing f) :\n    R1Space Y := .of_continuous_specializes_imp hf.continuous fun _ _ ‚Ü¶ hf.specializes_iff.1\n\n"}
{"name":"Inducing.r1Space","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : R1Space X\ninst‚úù : TopologicalSpace Y\nf : Y ‚Üí X\nhf : Topology.IsInducing f\n‚ä¢ R1Space Y","decl":"@[deprecated (since := \"2024-10-28\")] alias Inducing.r1Space := IsInducing.r1Space\n\n"}
{"name":"R1Space.induced","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : R1Space X\nf : Y ‚Üí X\n‚ä¢ R1Space Y","decl":"protected theorem R1Space.induced (f : Y ‚Üí X) : @R1Space Y (.induced f ‚Äπ_‚Ä∫) :=\n  @IsInducing.r1Space _ _ _ _ (.induced f _) f (.induced f)\n\n"}
{"name":"instR1SpaceSubtype","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : R1Space X\np : X ‚Üí Prop\n‚ä¢ R1Space (Subtype p)","decl":"instance (p : X ‚Üí Prop) : R1Space (Subtype p) := .induced _\n\n"}
{"name":"R1Space.sInf","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_3\nT : Set (TopologicalSpace X)\nhT : ‚àÄ (t : TopologicalSpace X), Membership.mem T t ‚Üí R1Space X\n‚ä¢ R1Space X","decl":"protected theorem R1Space.sInf {X : Type*} {T : Set (TopologicalSpace X)}\n    (hT : ‚àÄ t ‚àà T, @R1Space X t) : @R1Space X (sInf T) := by\n  let _ := sInf T\n  refine ‚ü®fun x y ‚Ü¶ ?_‚ü©\n  simp only [Specializes, nhds_sInf]\n  rcases em (‚àÉ t ‚àà T, Disjoint (@nhds X t x) (@nhds X t y)) with ‚ü®t, htT, htd‚ü© | hTd\n  ¬∑ exact .inr <| htd.mono (iInf‚ÇÇ_le t htT) (iInf‚ÇÇ_le t htT)\n  ¬∑ push_neg at hTd\n    exact .inl <| iInf‚ÇÇ_mono fun t ht ‚Ü¶ ((hT t ht).1 x y).resolve_right (hTd t ht)\n\n"}
{"name":"R1Space.iInf","module":"Mathlib.Topology.Separation.Basic","initialProofState":"Œπ : Type u_3\nX : Type u_4\nt : Œπ ‚Üí TopologicalSpace X\nht : ‚àÄ (i : Œπ), R1Space X\n‚ä¢ R1Space X","decl":"protected theorem R1Space.iInf {Œπ X : Type*} {t : Œπ ‚Üí TopologicalSpace X}\n    (ht : ‚àÄ i, @R1Space X (t i)) : @R1Space X (iInf t) :=\n  .sInf <| forall_mem_range.2 ht\n\n"}
{"name":"R1Space.inf","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_3\nt‚ÇÅ t‚ÇÇ : TopologicalSpace X\nh‚ÇÅ : R1Space X\nh‚ÇÇ : R1Space X\n‚ä¢ R1Space X","decl":"protected theorem R1Space.inf {X : Type*} {t‚ÇÅ t‚ÇÇ : TopologicalSpace X}\n    (h‚ÇÅ : @R1Space X t‚ÇÅ) (h‚ÇÇ : @R1Space X t‚ÇÇ) : @R1Space X (t‚ÇÅ ‚äì t‚ÇÇ) := by\n  rw [inf_eq_iInf]\n  apply R1Space.iInf\n  simp [*]\n\n"}
{"name":"instR1SpaceProd","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : R1Space X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : R1Space Y\n‚ä¢ R1Space (Prod X Y)","decl":"instance [TopologicalSpace Y] [R1Space Y] : R1Space (X √ó Y) :=\n  .inf (.induced _) (.induced _)\n\n"}
{"name":"instR1SpaceForall","module":"Mathlib.Topology.Separation.Basic","initialProofState":"Œπ : Type u_3\nX : Œπ ‚Üí Type u_4\ninst‚úù¬π : (i : Œπ) ‚Üí TopologicalSpace (X i)\ninst‚úù : ‚àÄ (i : Œπ), R1Space (X i)\n‚ä¢ R1Space ((i : Œπ) ‚Üí X i)","decl":"instance {Œπ : Type*} {X : Œπ ‚Üí Type*} [‚àÄ i, TopologicalSpace (X i)] [‚àÄ i, R1Space (X i)] :\n    R1Space (‚àÄ i, X i) :=\n  .iInf fun _ ‚Ü¶ .induced _\n\n"}
{"name":"exists_mem_nhds_isCompact_mapsTo_of_isCompact_mem_nhds","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_3\nY : Type u_4\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : R1Space Y\nf : X ‚Üí Y\nx : X\nK : Set X\ns : Set Y\nhf : Continuous f\nhs : Membership.mem (nhds (f x)) s\nhKc : IsCompact K\nhKx : Membership.mem (nhds x) K\n‚ä¢ Exists fun L => And (Membership.mem (nhds x) L) (And (IsCompact L) (Set.MapsTo f L s))","decl":"theorem exists_mem_nhds_isCompact_mapsTo_of_isCompact_mem_nhds\n    {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] [R1Space Y] {f : X ‚Üí Y} {x : X}\n    {K : Set X} {s : Set Y} (hf : Continuous f) (hs : s ‚àà ùìù (f x)) (hKc : IsCompact K)\n    (hKx : K ‚àà ùìù x) : ‚àÉ L ‚àà ùìù x, IsCompact L ‚àß MapsTo f L s := by\n  have hc : IsCompact (f '' K \\ interior s) := (hKc.image hf).diff isOpen_interior\n  obtain ‚ü®U, V, Uo, Vo, hxU, hV, hd‚ü© : SeparatedNhds {f x} (f '' K \\ interior s) := by\n    simp_rw [separatedNhds_iff_disjoint, nhdsSet_singleton, hc.disjoint_nhdsSet_right,\n      disjoint_nhds_nhds_iff_not_inseparable]\n    rintro y ‚ü®-, hys‚ü© hxy\n    refine hys <| (hxy.mem_open_iff isOpen_interior).1 ?_\n    rwa [mem_interior_iff_mem_nhds]\n  refine ‚ü®K \\ f ‚Åª¬π' V, diff_mem hKx ?_, hKc.diff <| Vo.preimage hf, fun y hy ‚Ü¶ ?_‚ü©\n  ¬∑ filter_upwards [hf.continuousAt <| Uo.mem_nhds (hxU rfl)] with x hx\n      using Set.disjoint_left.1 hd hx\n  ¬∑ by_contra hys\n    exact hy.2 (hV ‚ü®mem_image_of_mem _ hy.1, not_mem_subset interior_subset hys‚ü©)\n\n"}
{"name":"instLocallyCompactPairOfWeaklyLocallyCompactSpaceOfR1Space","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_3\nY : Type u_4\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : WeaklyLocallyCompactSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : R1Space Y\n‚ä¢ LocallyCompactPair X Y","decl":"instance (priority := 900) {X Y : Type*} [TopologicalSpace X] [WeaklyLocallyCompactSpace X]\n    [TopologicalSpace Y] [R1Space Y] : LocallyCompactPair X Y where\n  exists_mem_nhds_isCompact_mapsTo hf hs :=\n    let ‚ü®_K, hKc, hKx‚ü© := exists_compact_mem_nhds _\n    exists_mem_nhds_isCompact_mapsTo_of_isCompact_mem_nhds hf hs hKc hKx\n\n"}
{"name":"IsCompact.isCompact_isClosed_basis_nhds","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : R1Space X\nx : X\nL : Set X\nhLc : IsCompact L\nhxL : Membership.mem (nhds x) L\n‚ä¢ (nhds x).HasBasis (fun K => And (Membership.mem (nhds x) K) (And (IsCompact K) (IsClosed K))) fun x => x","decl":"/-- If a point in an R‚ÇÅ space has a compact neighborhood,\nthen it has a basis of compact closed neighborhoods. -/\ntheorem IsCompact.isCompact_isClosed_basis_nhds {x : X} {L : Set X} (hLc : IsCompact L)\n    (hxL : L ‚àà ùìù x) : (ùìù x).HasBasis (fun K ‚Ü¶ K ‚àà ùìù x ‚àß IsCompact K ‚àß IsClosed K) (¬∑) :=\n  hasBasis_self.2 fun _U hU ‚Ü¶\n    let ‚ü®K, hKx, hKc, hKU‚ü© := exists_mem_nhds_isCompact_mapsTo_of_isCompact_mem_nhds\n      continuous_id (interior_mem_nhds.2 hU) hLc hxL\n    ‚ü®closure K, mem_of_superset hKx subset_closure, ‚ü®hKc.closure, isClosed_closure‚ü©,\n      (hKc.closure_subset_of_isOpen isOpen_interior hKU).trans interior_subset‚ü©\n\n"}
{"name":"Filter.coclosedCompact_eq_cocompact","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : R1Space X\n‚ä¢ Eq (Filter.coclosedCompact X) (Filter.cocompact X)","decl":"/-- In an R‚ÇÅ space, the filters `coclosedCompact` and `cocompact` are equal. -/\n@[simp]\ntheorem Filter.coclosedCompact_eq_cocompact : coclosedCompact X = cocompact X := by\n  refine le_antisymm ?_ cocompact_le_coclosedCompact\n  rw [hasBasis_coclosedCompact.le_basis_iff hasBasis_cocompact]\n  exact fun K hK ‚Ü¶ ‚ü®closure K, ‚ü®isClosed_closure, hK.closure‚ü©, compl_subset_compl.2 subset_closure‚ü©\n\n"}
{"name":"Bornology.relativelyCompact_eq_inCompact","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : R1Space X\n‚ä¢ Eq (Bornology.relativelyCompact X) (Bornology.inCompact X)","decl":"/-- In an R‚ÇÅ space, the bornologies `relativelyCompact` and `inCompact` are equal. -/\n@[simp]\ntheorem Bornology.relativelyCompact_eq_inCompact :\n    Bornology.relativelyCompact X = Bornology.inCompact X :=\n  Bornology.ext _ _ Filter.coclosedCompact_eq_cocompact\n\n"}
{"name":"isCompact_isClosed_basis_nhds","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : R1Space X\ninst‚úù : WeaklyLocallyCompactSpace X\nx : X\n‚ä¢ (nhds x).HasBasis (fun K => And (Membership.mem (nhds x) K) (And (IsCompact K) (IsClosed K))) fun x => x","decl":"/-- In a (weakly) locally compact R‚ÇÅ space, compact closed neighborhoods of a point `x`\nform a basis of neighborhoods of `x`. -/\ntheorem isCompact_isClosed_basis_nhds (x : X) :\n    (ùìù x).HasBasis (fun K => K ‚àà ùìù x ‚àß IsCompact K ‚àß IsClosed K) (¬∑) :=\n  let ‚ü®_L, hLc, hLx‚ü© := exists_compact_mem_nhds x\n  hLc.isCompact_isClosed_basis_nhds hLx\n\n"}
{"name":"exists_mem_nhds_isCompact_isClosed","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : R1Space X\ninst‚úù : WeaklyLocallyCompactSpace X\nx : X\n‚ä¢ Exists fun K => And (Membership.mem (nhds x) K) (And (IsCompact K) (IsClosed K))","decl":"/-- In a (weakly) locally compact R‚ÇÅ space, each point admits a compact closed neighborhood. -/\ntheorem exists_mem_nhds_isCompact_isClosed (x : X) : ‚àÉ K ‚àà ùìù x, IsCompact K ‚àß IsClosed K :=\n  (isCompact_isClosed_basis_nhds x).ex_mem\n\n-- see Note [lower instance priority]\n"}
{"name":"WeaklyLocallyCompactSpace.locallyCompactSpace","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : R1Space X\ninst‚úù : WeaklyLocallyCompactSpace X\n‚ä¢ LocallyCompactSpace X","decl":"/-- A weakly locally compact R‚ÇÅ space is locally compact. -/\ninstance (priority := 80) WeaklyLocallyCompactSpace.locallyCompactSpace : LocallyCompactSpace X :=\n  .of_hasBasis isCompact_isClosed_basis_nhds fun _ _ ‚ü®_, h, _‚ü© ‚Ü¶ h\n\n"}
{"name":"exists_isOpen_superset_and_isCompact_closure","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : R1Space X\ninst‚úù : WeaklyLocallyCompactSpace X\nK : Set X\nhK : IsCompact K\n‚ä¢ Exists fun V => And (IsOpen V) (And (HasSubset.Subset K V) (IsCompact (closure V)))","decl":"/-- In a weakly locally compact R‚ÇÅ space,\nevery compact set has an open neighborhood with compact closure. -/\ntheorem exists_isOpen_superset_and_isCompact_closure {K : Set X} (hK : IsCompact K) :\n    ‚àÉ V, IsOpen V ‚àß K ‚äÜ V ‚àß IsCompact (closure V) := by\n  rcases exists_compact_superset hK with ‚ü®K', hK', hKK'‚ü©\n  exact ‚ü®interior K', isOpen_interior, hKK', hK'.closure_of_subset interior_subset‚ü©\n\n"}
{"name":"exists_isOpen_mem_isCompact_closure","module":"Mathlib.Topology.Separation.Basic","initialProofState":"X : Type u_1\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : R1Space X\ninst‚úù : WeaklyLocallyCompactSpace X\nx : X\n‚ä¢ Exists fun U => And (IsOpen U) (And (Membership.mem U x) (IsCompact (closure U)))","decl":"/-- In a weakly locally compact R‚ÇÅ space,\nevery point has an open neighborhood with compact closure. -/\ntheorem exists_isOpen_mem_isCompact_closure (x : X) :\n    ‚àÉ U : Set X, IsOpen U ‚àß x ‚àà U ‚àß IsCompact (closure U) := by\n  simpa only [singleton_subset_iff]\n    using exists_isOpen_superset_and_isCompact_closure isCompact_singleton\n\n"}
