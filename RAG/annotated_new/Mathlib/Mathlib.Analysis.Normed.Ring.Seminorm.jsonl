{"name":"RingSeminorm.mk.sizeOf_spec","module":"Mathlib.Analysis.Normed.Ring.Seminorm","initialProofState":"R : Type u_2\ninst✝¹ : NonUnitalNonAssocRing R\ninst✝ : SizeOf R\ntoAddGroupSeminorm : AddGroupSeminorm R\nmul_le' : ∀ (x y : R), LE.le (toAddGroupSeminorm.toFun (HMul.hMul x y)) (HMul.hMul (toAddGroupSeminorm.toFun x) (toAddGroupSeminorm.toFun y))\n⊢ Eq (SizeOf.sizeOf { toAddGroupSeminorm := toAddGroupSeminorm, mul_le' := mul_le' }) (HAdd.hAdd 1 (SizeOf.sizeOf toAddGroupSeminorm))","decl":"/-- A seminorm on a ring `R` is a function `f : R → ℝ` that preserves zero, takes nonnegative\n  values, is subadditive and submultiplicative and such that `f (-x) = f x` for all `x ∈ R`. -/\nstructure RingSeminorm (R : Type*) [NonUnitalNonAssocRing R] extends AddGroupSeminorm R where\n  /-- The property of a `RingSeminorm` that for all `x` and `y` in the ring, the norm of `x * y` is\n    less than the norm of `x` times the norm of `y`. -/\n  mul_le' : ∀ x y : R, toFun (x * y) ≤ toFun x * toFun y\n\n"}
{"name":"RingSeminorm.mk.inj","module":"Mathlib.Analysis.Normed.Ring.Seminorm","initialProofState":"R : Type u_2\ninst✝ : NonUnitalNonAssocRing R\ntoAddGroupSeminorm✝ : AddGroupSeminorm R\nmul_le'✝ : ∀ (x y : R), LE.le (toAddGroupSeminorm✝.toFun (HMul.hMul x y)) (HMul.hMul (toAddGroupSeminorm✝.toFun x) (toAddGroupSeminorm✝.toFun y))\ntoAddGroupSeminorm : AddGroupSeminorm R\nmul_le' : ∀ (x y : R), LE.le (toAddGroupSeminorm.toFun (HMul.hMul x y)) (HMul.hMul (toAddGroupSeminorm.toFun x) (toAddGroupSeminorm.toFun y))\nx✝ : Eq { toAddGroupSeminorm := toAddGroupSeminorm✝, mul_le' := mul_le'✝ } { toAddGroupSeminorm := toAddGroupSeminorm, mul_le' := mul_le' }\n⊢ Eq toAddGroupSeminorm✝ toAddGroupSeminorm","decl":"/-- A seminorm on a ring `R` is a function `f : R → ℝ` that preserves zero, takes nonnegative\n  values, is subadditive and submultiplicative and such that `f (-x) = f x` for all `x ∈ R`. -/\nstructure RingSeminorm (R : Type*) [NonUnitalNonAssocRing R] extends AddGroupSeminorm R where\n  /-- The property of a `RingSeminorm` that for all `x` and `y` in the ring, the norm of `x * y` is\n    less than the norm of `x` times the norm of `y`. -/\n  mul_le' : ∀ x y : R, toFun (x * y) ≤ toFun x * toFun y\n\n"}
{"name":"RingSeminorm.mul_le'","module":"Mathlib.Analysis.Normed.Ring.Seminorm","initialProofState":"R : Type u_2\ninst✝ : NonUnitalNonAssocRing R\nself : RingSeminorm R\nx y : R\n⊢ LE.le (self.toFun (HMul.hMul x y)) (HMul.hMul (self.toFun x) (self.toFun y))","decl":"/-- A seminorm on a ring `R` is a function `f : R → ℝ` that preserves zero, takes nonnegative\n  values, is subadditive and submultiplicative and such that `f (-x) = f x` for all `x ∈ R`. -/\nstructure RingSeminorm (R : Type*) [NonUnitalNonAssocRing R] extends AddGroupSeminorm R where\n  /-- The property of a `RingSeminorm` that for all `x` and `y` in the ring, the norm of `x * y` is\n    less than the norm of `x` times the norm of `y`. -/\n  mul_le' : ∀ x y : R, toFun (x * y) ≤ toFun x * toFun y\n\n"}
{"name":"RingSeminorm.mk.injEq","module":"Mathlib.Analysis.Normed.Ring.Seminorm","initialProofState":"R : Type u_2\ninst✝ : NonUnitalNonAssocRing R\ntoAddGroupSeminorm✝ : AddGroupSeminorm R\nmul_le'✝ : ∀ (x y : R), LE.le (toAddGroupSeminorm✝.toFun (HMul.hMul x y)) (HMul.hMul (toAddGroupSeminorm✝.toFun x) (toAddGroupSeminorm✝.toFun y))\ntoAddGroupSeminorm : AddGroupSeminorm R\nmul_le' : ∀ (x y : R), LE.le (toAddGroupSeminorm.toFun (HMul.hMul x y)) (HMul.hMul (toAddGroupSeminorm.toFun x) (toAddGroupSeminorm.toFun y))\n⊢ Eq (Eq { toAddGroupSeminorm := toAddGroupSeminorm✝, mul_le' := mul_le'✝ } { toAddGroupSeminorm := toAddGroupSeminorm, mul_le' := mul_le' }) (Eq toAddGroupSeminorm✝ toAddGroupSeminorm)","decl":"/-- A seminorm on a ring `R` is a function `f : R → ℝ` that preserves zero, takes nonnegative\n  values, is subadditive and submultiplicative and such that `f (-x) = f x` for all `x ∈ R`. -/\nstructure RingSeminorm (R : Type*) [NonUnitalNonAssocRing R] extends AddGroupSeminorm R where\n  /-- The property of a `RingSeminorm` that for all `x` and `y` in the ring, the norm of `x * y` is\n    less than the norm of `x` times the norm of `y`. -/\n  mul_le' : ∀ x y : R, toFun (x * y) ≤ toFun x * toFun y\n\n"}
{"name":"RingNorm.mk.sizeOf_spec","module":"Mathlib.Analysis.Normed.Ring.Seminorm","initialProofState":"R : Type u_2\ninst✝¹ : NonUnitalNonAssocRing R\ninst✝ : SizeOf R\ntoRingSeminorm : RingSeminorm R\neq_zero_of_map_eq_zero' : ∀ (x : R), Eq (toRingSeminorm.toFun x) 0 → Eq x 0\n⊢ Eq (SizeOf.sizeOf { toRingSeminorm := toRingSeminorm, eq_zero_of_map_eq_zero' := eq_zero_of_map_eq_zero' }) (HAdd.hAdd 1 (SizeOf.sizeOf toRingSeminorm))","decl":"/-- A function `f : R → ℝ` is a norm on a (nonunital) ring if it is a seminorm and `f x = 0`\n  implies `x = 0`. -/\nstructure RingNorm (R : Type*) [NonUnitalNonAssocRing R] extends RingSeminorm R, AddGroupNorm R\n\n"}
{"name":"RingNorm.mk.inj","module":"Mathlib.Analysis.Normed.Ring.Seminorm","initialProofState":"R : Type u_2\ninst✝ : NonUnitalNonAssocRing R\ntoRingSeminorm✝ : RingSeminorm R\neq_zero_of_map_eq_zero'✝ : ∀ (x : R), Eq (toRingSeminorm✝.toFun x) 0 → Eq x 0\ntoRingSeminorm : RingSeminorm R\neq_zero_of_map_eq_zero' : ∀ (x : R), Eq (toRingSeminorm.toFun x) 0 → Eq x 0\nx✝ : Eq { toRingSeminorm := toRingSeminorm✝, eq_zero_of_map_eq_zero' := eq_zero_of_map_eq_zero'✝ } { toRingSeminorm := toRingSeminorm, eq_zero_of_map_eq_zero' := eq_zero_of_map_eq_zero' }\n⊢ Eq toRingSeminorm✝ toRingSeminorm","decl":"/-- A function `f : R → ℝ` is a norm on a (nonunital) ring if it is a seminorm and `f x = 0`\n  implies `x = 0`. -/\nstructure RingNorm (R : Type*) [NonUnitalNonAssocRing R] extends RingSeminorm R, AddGroupNorm R\n\n"}
{"name":"RingNorm.mk.injEq","module":"Mathlib.Analysis.Normed.Ring.Seminorm","initialProofState":"R : Type u_2\ninst✝ : NonUnitalNonAssocRing R\ntoRingSeminorm✝ : RingSeminorm R\neq_zero_of_map_eq_zero'✝ : ∀ (x : R), Eq (toRingSeminorm✝.toFun x) 0 → Eq x 0\ntoRingSeminorm : RingSeminorm R\neq_zero_of_map_eq_zero' : ∀ (x : R), Eq (toRingSeminorm.toFun x) 0 → Eq x 0\n⊢ Eq (Eq { toRingSeminorm := toRingSeminorm✝, eq_zero_of_map_eq_zero' := eq_zero_of_map_eq_zero'✝ } { toRingSeminorm := toRingSeminorm, eq_zero_of_map_eq_zero' := eq_zero_of_map_eq_zero' }) (Eq toRingSeminorm✝ toRingSeminorm)","decl":"/-- A function `f : R → ℝ` is a norm on a (nonunital) ring if it is a seminorm and `f x = 0`\n  implies `x = 0`. -/\nstructure RingNorm (R : Type*) [NonUnitalNonAssocRing R] extends RingSeminorm R, AddGroupNorm R\n\n"}
{"name":"RingNorm.eq_zero_of_map_eq_zero'","module":"Mathlib.Analysis.Normed.Ring.Seminorm","initialProofState":"R : Type u_2\ninst✝ : NonUnitalNonAssocRing R\nself : RingNorm R\nx : R\na✝ : Eq (self.toFun x) 0\n⊢ Eq x 0","decl":"/-- A function `f : R → ℝ` is a norm on a (nonunital) ring if it is a seminorm and `f x = 0`\n  implies `x = 0`. -/\nstructure RingNorm (R : Type*) [NonUnitalNonAssocRing R] extends RingSeminorm R, AddGroupNorm R\n\n"}
{"name":"MulRingSeminorm.map_one'","module":"Mathlib.Analysis.Normed.Ring.Seminorm","initialProofState":"R : Type u_2\ninst✝ : NonAssocRing R\nself : MulRingSeminorm R\n⊢ Eq (self.toFun 1) 1","decl":"/-- A multiplicative seminorm on a ring `R` is a function `f : R → ℝ` that preserves zero and\nmultiplication, takes nonnegative values, is subadditive and such that `f (-x) = f x` for all `x`.\n-/\nstructure MulRingSeminorm (R : Type*) [NonAssocRing R] extends AddGroupSeminorm R,\n  MonoidWithZeroHom R ℝ\n\n"}
{"name":"MulRingSeminorm.mk.injEq","module":"Mathlib.Analysis.Normed.Ring.Seminorm","initialProofState":"R : Type u_2\ninst✝ : NonAssocRing R\ntoAddGroupSeminorm✝ : AddGroupSeminorm R\nmap_one'✝ : Eq (toAddGroupSeminorm✝.toFun 1) 1\nmap_mul'✝ : ∀ (x y : R), Eq (toAddGroupSeminorm✝.toFun (HMul.hMul x y)) (HMul.hMul (toAddGroupSeminorm✝.toFun x) (toAddGroupSeminorm✝.toFun y))\ntoAddGroupSeminorm : AddGroupSeminorm R\nmap_one' : Eq (toAddGroupSeminorm.toFun 1) 1\nmap_mul' : ∀ (x y : R), Eq (toAddGroupSeminorm.toFun (HMul.hMul x y)) (HMul.hMul (toAddGroupSeminorm.toFun x) (toAddGroupSeminorm.toFun y))\n⊢ Eq (Eq { toAddGroupSeminorm := toAddGroupSeminorm✝, map_one' := map_one'✝, map_mul' := map_mul'✝ } { toAddGroupSeminorm := toAddGroupSeminorm, map_one' := map_one', map_mul' := map_mul' }) (Eq toAddGroupSeminorm✝ toAddGroupSeminorm)","decl":"/-- A multiplicative seminorm on a ring `R` is a function `f : R → ℝ` that preserves zero and\nmultiplication, takes nonnegative values, is subadditive and such that `f (-x) = f x` for all `x`.\n-/\nstructure MulRingSeminorm (R : Type*) [NonAssocRing R] extends AddGroupSeminorm R,\n  MonoidWithZeroHom R ℝ\n\n"}
{"name":"MulRingSeminorm.map_mul'","module":"Mathlib.Analysis.Normed.Ring.Seminorm","initialProofState":"R : Type u_2\ninst✝ : NonAssocRing R\nself : MulRingSeminorm R\nx y : R\n⊢ Eq (self.toFun (HMul.hMul x y)) (HMul.hMul (self.toFun x) (self.toFun y))","decl":"/-- A multiplicative seminorm on a ring `R` is a function `f : R → ℝ` that preserves zero and\nmultiplication, takes nonnegative values, is subadditive and such that `f (-x) = f x` for all `x`.\n-/\nstructure MulRingSeminorm (R : Type*) [NonAssocRing R] extends AddGroupSeminorm R,\n  MonoidWithZeroHom R ℝ\n\n"}
{"name":"MulRingSeminorm.mk.inj","module":"Mathlib.Analysis.Normed.Ring.Seminorm","initialProofState":"R : Type u_2\ninst✝ : NonAssocRing R\ntoAddGroupSeminorm✝ : AddGroupSeminorm R\nmap_one'✝ : Eq (toAddGroupSeminorm✝.toFun 1) 1\nmap_mul'✝ : ∀ (x y : R), Eq (toAddGroupSeminorm✝.toFun (HMul.hMul x y)) (HMul.hMul (toAddGroupSeminorm✝.toFun x) (toAddGroupSeminorm✝.toFun y))\ntoAddGroupSeminorm : AddGroupSeminorm R\nmap_one' : Eq (toAddGroupSeminorm.toFun 1) 1\nmap_mul' : ∀ (x y : R), Eq (toAddGroupSeminorm.toFun (HMul.hMul x y)) (HMul.hMul (toAddGroupSeminorm.toFun x) (toAddGroupSeminorm.toFun y))\nx✝ : Eq { toAddGroupSeminorm := toAddGroupSeminorm✝, map_one' := map_one'✝, map_mul' := map_mul'✝ } { toAddGroupSeminorm := toAddGroupSeminorm, map_one' := map_one', map_mul' := map_mul' }\n⊢ Eq toAddGroupSeminorm✝ toAddGroupSeminorm","decl":"/-- A multiplicative seminorm on a ring `R` is a function `f : R → ℝ` that preserves zero and\nmultiplication, takes nonnegative values, is subadditive and such that `f (-x) = f x` for all `x`.\n-/\nstructure MulRingSeminorm (R : Type*) [NonAssocRing R] extends AddGroupSeminorm R,\n  MonoidWithZeroHom R ℝ\n\n"}
{"name":"MulRingSeminorm.mk.sizeOf_spec","module":"Mathlib.Analysis.Normed.Ring.Seminorm","initialProofState":"R : Type u_2\ninst✝¹ : NonAssocRing R\ninst✝ : SizeOf R\ntoAddGroupSeminorm : AddGroupSeminorm R\nmap_one' : Eq (toAddGroupSeminorm.toFun 1) 1\nmap_mul' : ∀ (x y : R), Eq (toAddGroupSeminorm.toFun (HMul.hMul x y)) (HMul.hMul (toAddGroupSeminorm.toFun x) (toAddGroupSeminorm.toFun y))\n⊢ Eq (SizeOf.sizeOf { toAddGroupSeminorm := toAddGroupSeminorm, map_one' := map_one', map_mul' := map_mul' }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toAddGroupSeminorm)) (SizeOf.sizeOf map_one'))","decl":"/-- A multiplicative seminorm on a ring `R` is a function `f : R → ℝ` that preserves zero and\nmultiplication, takes nonnegative values, is subadditive and such that `f (-x) = f x` for all `x`.\n-/\nstructure MulRingSeminorm (R : Type*) [NonAssocRing R] extends AddGroupSeminorm R,\n  MonoidWithZeroHom R ℝ\n\n"}
{"name":"MulRingNorm.mk.inj","module":"Mathlib.Analysis.Normed.Ring.Seminorm","initialProofState":"R : Type u_2\ninst✝ : NonAssocRing R\ntoMulRingSeminorm✝ : MulRingSeminorm R\neq_zero_of_map_eq_zero'✝ : ∀ (x : R), Eq (toMulRingSeminorm✝.toFun x) 0 → Eq x 0\ntoMulRingSeminorm : MulRingSeminorm R\neq_zero_of_map_eq_zero' : ∀ (x : R), Eq (toMulRingSeminorm.toFun x) 0 → Eq x 0\nx✝ : Eq { toMulRingSeminorm := toMulRingSeminorm✝, eq_zero_of_map_eq_zero' := eq_zero_of_map_eq_zero'✝ } { toMulRingSeminorm := toMulRingSeminorm, eq_zero_of_map_eq_zero' := eq_zero_of_map_eq_zero' }\n⊢ Eq toMulRingSeminorm✝ toMulRingSeminorm","decl":"/-- A multiplicative norm on a ring `R` is a multiplicative ring seminorm such that `f x = 0`\nimplies `x = 0`.\n\nIt is recommended to use `AbsoluteValue R ℝ` instead (which works for `Semiring R`\nand is equivalent to `MulRingNorm R` for a nontrivial `Ring R`). -/\nstructure MulRingNorm (R : Type*) [NonAssocRing R] extends MulRingSeminorm R, AddGroupNorm R\n\n"}
{"name":"MulRingNorm.eq_zero_of_map_eq_zero'","module":"Mathlib.Analysis.Normed.Ring.Seminorm","initialProofState":"R : Type u_2\ninst✝ : NonAssocRing R\nself : MulRingNorm R\nx : R\na✝ : Eq (self.toFun x) 0\n⊢ Eq x 0","decl":"/-- A multiplicative norm on a ring `R` is a multiplicative ring seminorm such that `f x = 0`\nimplies `x = 0`.\n\nIt is recommended to use `AbsoluteValue R ℝ` instead (which works for `Semiring R`\nand is equivalent to `MulRingNorm R` for a nontrivial `Ring R`). -/\nstructure MulRingNorm (R : Type*) [NonAssocRing R] extends MulRingSeminorm R, AddGroupNorm R\n\n"}
{"name":"MulRingNorm.mk.injEq","module":"Mathlib.Analysis.Normed.Ring.Seminorm","initialProofState":"R : Type u_2\ninst✝ : NonAssocRing R\ntoMulRingSeminorm✝ : MulRingSeminorm R\neq_zero_of_map_eq_zero'✝ : ∀ (x : R), Eq (toMulRingSeminorm✝.toFun x) 0 → Eq x 0\ntoMulRingSeminorm : MulRingSeminorm R\neq_zero_of_map_eq_zero' : ∀ (x : R), Eq (toMulRingSeminorm.toFun x) 0 → Eq x 0\n⊢ Eq (Eq { toMulRingSeminorm := toMulRingSeminorm✝, eq_zero_of_map_eq_zero' := eq_zero_of_map_eq_zero'✝ } { toMulRingSeminorm := toMulRingSeminorm, eq_zero_of_map_eq_zero' := eq_zero_of_map_eq_zero' }) (Eq toMulRingSeminorm✝ toMulRingSeminorm)","decl":"/-- A multiplicative norm on a ring `R` is a multiplicative ring seminorm such that `f x = 0`\nimplies `x = 0`.\n\nIt is recommended to use `AbsoluteValue R ℝ` instead (which works for `Semiring R`\nand is equivalent to `MulRingNorm R` for a nontrivial `Ring R`). -/\nstructure MulRingNorm (R : Type*) [NonAssocRing R] extends MulRingSeminorm R, AddGroupNorm R\n\n"}
{"name":"MulRingNorm.mk.sizeOf_spec","module":"Mathlib.Analysis.Normed.Ring.Seminorm","initialProofState":"R : Type u_2\ninst✝¹ : NonAssocRing R\ninst✝ : SizeOf R\ntoMulRingSeminorm : MulRingSeminorm R\neq_zero_of_map_eq_zero' : ∀ (x : R), Eq (toMulRingSeminorm.toFun x) 0 → Eq x 0\n⊢ Eq (SizeOf.sizeOf { toMulRingSeminorm := toMulRingSeminorm, eq_zero_of_map_eq_zero' := eq_zero_of_map_eq_zero' }) (HAdd.hAdd 1 (SizeOf.sizeOf toMulRingSeminorm))","decl":"/-- A multiplicative norm on a ring `R` is a multiplicative ring seminorm such that `f x = 0`\nimplies `x = 0`.\n\nIt is recommended to use `AbsoluteValue R ℝ` instead (which works for `Semiring R`\nand is equivalent to `MulRingNorm R` for a nontrivial `Ring R`). -/\nstructure MulRingNorm (R : Type*) [NonAssocRing R] extends MulRingSeminorm R, AddGroupNorm R\n\n"}
{"name":"RingSeminorm.ringSeminormClass","module":"Mathlib.Analysis.Normed.Ring.Seminorm","initialProofState":"R : Type u_1\ninst✝ : NonUnitalRing R\n⊢ RingSeminormClass (RingSeminorm R) R Real","decl":"instance ringSeminormClass : RingSeminormClass (RingSeminorm R) R ℝ where\n  map_zero f := f.map_zero'\n  map_add_le_add f := f.add_le'\n  map_mul_le_mul f := f.mul_le'\n  map_neg_eq_map f := f.neg'\n\n"}
{"name":"RingSeminorm.toFun_eq_coe","module":"Mathlib.Analysis.Normed.Ring.Seminorm","initialProofState":"R : Type u_1\ninst✝ : NonUnitalRing R\np : RingSeminorm R\n⊢ Eq ⇑p.toAddGroupSeminorm ⇑p","decl":"@[simp]\ntheorem toFun_eq_coe (p : RingSeminorm R) : (p.toAddGroupSeminorm : R → ℝ) = p :=\n  rfl\n\n"}
{"name":"RingSeminorm.ext_iff","module":"Mathlib.Analysis.Normed.Ring.Seminorm","initialProofState":"R : Type u_1\ninst✝ : NonUnitalRing R\np q : RingSeminorm R\n⊢ Iff (Eq p q) (∀ (x : R), Eq (p x) (q x))","decl":"@[ext]\ntheorem ext {p q : RingSeminorm R} : (∀ x, p x = q x) → p = q :=\n  DFunLike.ext p q\n\n"}
{"name":"RingSeminorm.ext","module":"Mathlib.Analysis.Normed.Ring.Seminorm","initialProofState":"R : Type u_1\ninst✝ : NonUnitalRing R\np q : RingSeminorm R\na✝ : ∀ (x : R), Eq (p x) (q x)\n⊢ Eq p q","decl":"@[ext]\ntheorem ext {p q : RingSeminorm R} : (∀ x, p x = q x) → p = q :=\n  DFunLike.ext p q\n\n"}
{"name":"RingSeminorm.eq_zero_iff","module":"Mathlib.Analysis.Normed.Ring.Seminorm","initialProofState":"R : Type u_1\ninst✝ : NonUnitalRing R\np : RingSeminorm R\n⊢ Iff (Eq p 0) (∀ (x : R), Eq (p x) 0)","decl":"theorem eq_zero_iff {p : RingSeminorm R} : p = 0 ↔ ∀ x, p x = 0 :=\n  DFunLike.ext_iff\n\n"}
{"name":"RingSeminorm.ne_zero_iff","module":"Mathlib.Analysis.Normed.Ring.Seminorm","initialProofState":"R : Type u_1\ninst✝ : NonUnitalRing R\np : RingSeminorm R\n⊢ Iff (Ne p 0) (Exists fun x => Ne (p x) 0)","decl":"theorem ne_zero_iff {p : RingSeminorm R} : p ≠ 0 ↔ ∃ x, p x ≠ 0 := by simp [eq_zero_iff]\n\n"}
{"name":"RingSeminorm.apply_one","module":"Mathlib.Analysis.Normed.Ring.Seminorm","initialProofState":"R : Type u_1\ninst✝¹ : NonUnitalRing R\ninst✝ : DecidableEq R\nx : R\n⊢ Eq (1 x) (ite (Eq x 0) 0 1)","decl":"@[simp]\ntheorem apply_one [DecidableEq R] (x : R) : (1 : RingSeminorm R) x = if x = 0 then 0 else 1 :=\n  rfl\n\n"}
{"name":"RingSeminorm.seminorm_one_eq_one_iff_ne_zero","module":"Mathlib.Analysis.Normed.Ring.Seminorm","initialProofState":"R : Type u_1\ninst✝ : Ring R\np : RingSeminorm R\nhp : LE.le (p 1) 1\n⊢ Iff (Eq (p 1) 1) (Ne p 0)","decl":"theorem seminorm_one_eq_one_iff_ne_zero (hp : p 1 ≤ 1) : p 1 = 1 ↔ p ≠ 0 := by\n  refine\n    ⟨fun h => ne_zero_iff.mpr ⟨1, by rw [h]; exact one_ne_zero⟩,\n      fun h => ?_⟩\n  obtain hp0 | hp0 := (apply_nonneg p (1 : R)).eq_or_gt\n  · exfalso\n    refine h (ext fun x => (apply_nonneg _ _).antisymm' ?_)\n    simpa only [hp0, mul_one, mul_zero] using map_mul_le_mul p x 1\n  · refine hp.antisymm ((le_mul_iff_one_le_left hp0).1 ?_)\n    simpa only [one_mul] using map_mul_le_mul p (1 : R) _\n\n"}
{"name":"RingSeminorm.exists_index_pow_le","module":"Mathlib.Analysis.Normed.Ring.Seminorm","initialProofState":"R : Type u_1\ninst✝ : CommRing R\np : RingSeminorm R\nhna : IsNonarchimedean ⇑p\nx y : R\nn : Nat\n⊢ Exists fun m => And (LT.lt m (HAdd.hAdd n 1)) (LE.le (HPow.hPow (p (HPow.hPow (HAdd.hAdd x y) n)) (HDiv.hDiv 1 ↑n)) (HPow.hPow (HMul.hMul (p (HPow.hPow x m)) (p (HPow.hPow y (HSub.hSub n m)))) (HDiv.hDiv 1 ↑n)))","decl":"theorem exists_index_pow_le (hna : IsNonarchimedean p) (x y : R) (n : ℕ) :\n    ∃ (m : ℕ), m < n + 1 ∧ p ((x + y) ^ (n : ℕ)) ^ (1 / (n : ℝ)) ≤\n      (p (x ^ m) * p (y ^ (n - m : ℕ))) ^ (1 / (n : ℝ)) := by\n  obtain ⟨m, hm_lt, hm⟩ := IsNonarchimedean.add_pow_le hna n x y\n  exact ⟨m, hm_lt, Real.rpow_le_rpow (apply_nonneg p _) hm (one_div_nonneg.mpr n.cast_nonneg')⟩\n\n"}
{"name":"map_pow_le_pow","module":"Mathlib.Analysis.Normed.Ring.Seminorm","initialProofState":"F : Type u_2\nα : Type u_3\ninst✝² : Ring α\ninst✝¹ : FunLike F α Real\ninst✝ : RingSeminormClass F α Real\nf : F\na : α\nn : Nat\na✝ : Ne n 0\n⊢ LE.le (f (HPow.hPow a n)) (HPow.hPow (f a) n)","decl":"/-- If `f` is a ring seminorm on `a`, then `∀ {n : ℕ}, n ≠ 0 → f (a ^ n) ≤ f a ^ n`. -/\ntheorem map_pow_le_pow {F α : Type*} [Ring α] [FunLike F α ℝ] [RingSeminormClass F α ℝ] (f : F)\n    (a : α) : ∀ {n : ℕ}, n ≠ 0 → f (a ^ n) ≤ f a ^ n\n  | 0, h => absurd rfl h\n  | 1, _ => by simp only [pow_one, le_refl]\n  | n + 2, _ => by\n    simp only [pow_succ _ (n + 1)]\n    exact\n      le_trans (map_mul_le_mul f _ a)\n        (mul_le_mul_of_nonneg_right (map_pow_le_pow _ _ n.succ_ne_zero) (apply_nonneg f a))\n\n"}
{"name":"map_pow_le_pow'","module":"Mathlib.Analysis.Normed.Ring.Seminorm","initialProofState":"F : Type u_2\nα : Type u_3\ninst✝² : Ring α\ninst✝¹ : FunLike F α Real\ninst✝ : RingSeminormClass F α Real\nf : F\nhf1 : LE.le (f 1) 1\na : α\nn : Nat\n⊢ LE.le (f (HPow.hPow a n)) (HPow.hPow (f a) n)","decl":"/-- If `f` is a ring seminorm on `a` with `f 1 ≤ 1`, then `∀ (n : ℕ), f (a ^ n) ≤ f a ^ n`. -/\ntheorem map_pow_le_pow' {F α : Type*} [Ring α] [FunLike F α ℝ] [RingSeminormClass F α ℝ] {f : F}\n    (hf1 : f 1 ≤ 1) (a : α) : ∀ n : ℕ, f (a ^ n) ≤ f a ^ n\n  | 0 => by simp only [pow_zero, hf1]\n  | n + 1 => by\n    simp only [pow_succ _ n]\n    exact le_trans (map_mul_le_mul f _ a)\n      (mul_le_mul_of_nonneg_right (map_pow_le_pow' hf1 _ n) (apply_nonneg f a))\n\n"}
{"name":"RingSeminorm.isBoundedUnder","module":"Mathlib.Analysis.Normed.Ring.Seminorm","initialProofState":"R : Type u_1\ninst✝ : Ring R\np : RingSeminorm R\nhp : LE.le (p 1) 1\ns : Nat → Nat\nhs_le : ∀ (n : Nat), LE.le (s n) n\nx : R\nψ : Nat → Nat\n⊢ Filter.IsBoundedUnder LE.le Filter.atTop fun n => HPow.hPow (p (HPow.hPow x (s (ψ n)))) (HDiv.hDiv 1 ↑(ψ n))","decl":"/-- If `f` is a ring seminorm on `R` with `f 1 ≤ 1` and `s : ℕ → ℕ` is bounded by `n`, then\n  `f (x ^ s (ψ n)) ^ (1 / (ψ n : ℝ))` is eventually bounded. -/\ntheorem isBoundedUnder (hp : p 1 ≤ 1) {s : ℕ → ℕ} (hs_le : ∀ n : ℕ, s n ≤ n) {x : R} (ψ : ℕ → ℕ) :\n    IsBoundedUnder LE.le atTop fun n : ℕ => p (x ^ s (ψ n)) ^ (1 / (ψ n : ℝ)) := by\n  have h_le : ∀ m : ℕ, p (x ^ s (ψ m)) ^ (1 / (ψ m : ℝ)) ≤ p x ^ ((s (ψ m) : ℝ) / (ψ m : ℝ)) := by\n    intro m\n    rw [← mul_one_div (s (ψ m) : ℝ), rpow_mul (apply_nonneg p x), rpow_natCast]\n    exact rpow_le_rpow (apply_nonneg _ _) (map_pow_le_pow' hp x _)\n      (one_div_nonneg.mpr (cast_nonneg _))\n  apply isBoundedUnder_of\n  by_cases hfx : p x ≤ 1\n  · use 1, fun m => le_trans (h_le m)\n      (rpow_le_one (apply_nonneg _ _) hfx (div_nonneg (cast_nonneg _) (cast_nonneg _)))\n  · use p x\n    intro m\n    apply le_trans (h_le m)\n    conv_rhs => rw [← rpow_one (p x)]\n    exact rpow_le_rpow_of_exponent_le (le_of_lt (not_le.mp hfx))\n      (div_le_one_of_le₀ (cast_le.mpr (hs_le _)) (cast_nonneg _))\n\n"}
{"name":"RingNorm.ringNormClass","module":"Mathlib.Analysis.Normed.Ring.Seminorm","initialProofState":"R : Type u_1\ninst✝ : NonUnitalRing R\n⊢ RingNormClass (RingNorm R) R Real","decl":"instance ringNormClass : RingNormClass (RingNorm R) R ℝ where\n  map_zero f := f.map_zero'\n  map_add_le_add f := f.add_le'\n  map_mul_le_mul f := f.mul_le'\n  map_neg_eq_map f := f.neg'\n  eq_zero_of_map_eq_zero f := f.eq_zero_of_map_eq_zero' _\n\n-- Porting note: This is no longer `@[simp]` in Lean 4\n"}
{"name":"RingNorm.toFun_eq_coe","module":"Mathlib.Analysis.Normed.Ring.Seminorm","initialProofState":"R : Type u_1\ninst✝ : NonUnitalRing R\np : RingNorm R\n⊢ Eq p.toFun ⇑p","decl":"theorem toFun_eq_coe (p : RingNorm R) : p.toFun = p := rfl\n\n"}
{"name":"RingNorm.ext_iff","module":"Mathlib.Analysis.Normed.Ring.Seminorm","initialProofState":"R : Type u_1\ninst✝ : NonUnitalRing R\np q : RingNorm R\n⊢ Iff (Eq p q) (∀ (x : R), Eq (p x) (q x))","decl":"@[ext]\ntheorem ext {p q : RingNorm R} : (∀ x, p x = q x) → p = q :=\n  DFunLike.ext p q\n\n"}
{"name":"RingNorm.ext","module":"Mathlib.Analysis.Normed.Ring.Seminorm","initialProofState":"R : Type u_1\ninst✝ : NonUnitalRing R\np q : RingNorm R\na✝ : ∀ (x : R), Eq (p x) (q x)\n⊢ Eq p q","decl":"@[ext]\ntheorem ext {p q : RingNorm R} : (∀ x, p x = q x) → p = q :=\n  DFunLike.ext p q\n\n"}
{"name":"RingNorm.apply_one","module":"Mathlib.Analysis.Normed.Ring.Seminorm","initialProofState":"R : Type u_1\ninst✝¹ : NonUnitalRing R\ninst✝ : DecidableEq R\nx : R\n⊢ Eq (1 x) (ite (Eq x 0) 0 1)","decl":"@[simp]\ntheorem apply_one [DecidableEq R] (x : R) : (1 : RingNorm R) x = if x = 0 then 0 else 1 :=\n  rfl\n\n"}
{"name":"MulRingSeminorm.mulRingSeminormClass","module":"Mathlib.Analysis.Normed.Ring.Seminorm","initialProofState":"R : Type u_1\ninst✝ : NonAssocRing R\n⊢ MulRingSeminormClass (MulRingSeminorm R) R Real","decl":"instance mulRingSeminormClass : MulRingSeminormClass (MulRingSeminorm R) R ℝ where\n  map_zero f := f.map_zero'\n  map_one f := f.map_one'\n  map_add_le_add f := f.add_le'\n  map_mul f := f.map_mul'\n  map_neg_eq_map f := f.neg'\n\n"}
{"name":"MulRingSeminorm.toFun_eq_coe","module":"Mathlib.Analysis.Normed.Ring.Seminorm","initialProofState":"R : Type u_1\ninst✝ : NonAssocRing R\np : MulRingSeminorm R\n⊢ Eq ⇑p.toAddGroupSeminorm ⇑p","decl":"@[simp]\ntheorem toFun_eq_coe (p : MulRingSeminorm R) : (p.toAddGroupSeminorm : R → ℝ) = p :=\n  rfl\n\n"}
{"name":"MulRingSeminorm.ext","module":"Mathlib.Analysis.Normed.Ring.Seminorm","initialProofState":"R : Type u_1\ninst✝ : NonAssocRing R\np q : MulRingSeminorm R\na✝ : ∀ (x : R), Eq (p x) (q x)\n⊢ Eq p q","decl":"@[ext]\ntheorem ext {p q : MulRingSeminorm R} : (∀ x, p x = q x) → p = q :=\n  DFunLike.ext p q\n\n"}
{"name":"MulRingSeminorm.ext_iff","module":"Mathlib.Analysis.Normed.Ring.Seminorm","initialProofState":"R : Type u_1\ninst✝ : NonAssocRing R\np q : MulRingSeminorm R\n⊢ Iff (Eq p q) (∀ (x : R), Eq (p x) (q x))","decl":"@[ext]\ntheorem ext {p q : MulRingSeminorm R} : (∀ x, p x = q x) → p = q :=\n  DFunLike.ext p q\n\n"}
{"name":"MulRingSeminorm.apply_one","module":"Mathlib.Analysis.Normed.Ring.Seminorm","initialProofState":"R : Type u_1\ninst✝³ : NonAssocRing R\ninst✝² : DecidableEq R\ninst✝¹ : NoZeroDivisors R\ninst✝ : Nontrivial R\nx : R\n⊢ Eq (1 x) (ite (Eq x 0) 0 1)","decl":"@[simp]\ntheorem apply_one (x : R) : (1 : MulRingSeminorm R) x = if x = 0 then 0 else 1 :=\n  rfl\n\n"}
{"name":"MulRingNorm.mulRingNormClass","module":"Mathlib.Analysis.Normed.Ring.Seminorm","initialProofState":"R : Type u_1\ninst✝ : NonAssocRing R\n⊢ MulRingNormClass (MulRingNorm R) R Real","decl":"instance mulRingNormClass : MulRingNormClass (MulRingNorm R) R ℝ where\n  map_zero f := f.map_zero'\n  map_one f := f.map_one'\n  map_add_le_add f := f.add_le'\n  map_mul f := f.map_mul'\n  map_neg_eq_map f := f.neg'\n  eq_zero_of_map_eq_zero f := f.eq_zero_of_map_eq_zero' _\n\n-- Porting note: This no longer in `@[simp]`-normal form in Lean 4\n"}
{"name":"MulRingNorm.toFun_eq_coe","module":"Mathlib.Analysis.Normed.Ring.Seminorm","initialProofState":"R : Type u_1\ninst✝ : NonAssocRing R\np : MulRingNorm R\n⊢ Eq p.toFun ⇑p","decl":"theorem toFun_eq_coe (p : MulRingNorm R) : p.toFun = p := rfl\n\n"}
{"name":"MulRingNorm.ext","module":"Mathlib.Analysis.Normed.Ring.Seminorm","initialProofState":"R : Type u_1\ninst✝ : NonAssocRing R\np q : MulRingNorm R\na✝ : ∀ (x : R), Eq (p x) (q x)\n⊢ Eq p q","decl":"@[ext]\ntheorem ext {p q : MulRingNorm R} : (∀ x, p x = q x) → p = q :=\n  DFunLike.ext p q\n\n"}
{"name":"MulRingNorm.ext_iff","module":"Mathlib.Analysis.Normed.Ring.Seminorm","initialProofState":"R : Type u_1\ninst✝ : NonAssocRing R\np q : MulRingNorm R\n⊢ Iff (Eq p q) (∀ (x : R), Eq (p x) (q x))","decl":"@[ext]\ntheorem ext {p q : MulRingNorm R} : (∀ x, p x = q x) → p = q :=\n  DFunLike.ext p q\n\n"}
{"name":"MulRingNorm.apply_one","module":"Mathlib.Analysis.Normed.Ring.Seminorm","initialProofState":"R : Type u_1\ninst✝³ : NonAssocRing R\ninst✝² : DecidableEq R\ninst✝¹ : NoZeroDivisors R\ninst✝ : Nontrivial R\nx : R\n⊢ Eq (1 x) (ite (Eq x 0) 0 1)","decl":"@[simp]\ntheorem apply_one (x : R) : (1 : MulRingNorm R) x = if x = 0 then 0 else 1 :=\n  rfl\n\n"}
{"name":"MulRingNorm.mulRingNormEquivAbsoluteValue_apply","module":"Mathlib.Analysis.Normed.Ring.Seminorm","initialProofState":"R : Type u_2\ninst✝¹ : Ring R\ninst✝ : Nontrivial R\nN : MulRingNorm R\nx : R\n⊢ Eq ((MulRingNorm.mulRingNormEquivAbsoluteValue N) x) (N x)","decl":"lemma mulRingNormEquivAbsoluteValue_apply (N : MulRingNorm R) (x : R) :\n    mulRingNormEquivAbsoluteValue N x = N x := rfl\n\n"}
{"name":"MulRingNorm.mulRingNormEquivAbsoluteValue_symm_apply","module":"Mathlib.Analysis.Normed.Ring.Seminorm","initialProofState":"R : Type u_2\ninst✝¹ : Ring R\ninst✝ : Nontrivial R\nv : AbsoluteValue R Real\nx : R\n⊢ Eq ((MulRingNorm.mulRingNormEquivAbsoluteValue.symm v) x) (v x)","decl":"lemma mulRingNormEquivAbsoluteValue_symm_apply (v : AbsoluteValue R ℝ) (x : R) :\n    mulRingNormEquivAbsoluteValue.symm v x = v x := rfl\n\n"}
{"name":"MulRingNorm.equiv_refl","module":"Mathlib.Analysis.Normed.Ring.Seminorm","initialProofState":"R : Type u_2\ninst✝ : Ring R\nf : MulRingNorm R\n⊢ f.equiv f","decl":"set_option linter.deprecated false in\n/-- Equivalence of multiplicative ring norms is reflexive. -/\n@[deprecated \"Use AbsoluteValue.isEquiv_refl instead\" (since := \"2025-01-07\")]\nlemma equiv_refl (f : MulRingNorm R) : equiv f f := by\n    exact ⟨1, Real.zero_lt_one, by simp only [Real.rpow_one]⟩\n\n"}
{"name":"MulRingNorm.equiv_symm","module":"Mathlib.Analysis.Normed.Ring.Seminorm","initialProofState":"R : Type u_2\ninst✝ : Ring R\nf g : MulRingNorm R\nhfg : f.equiv g\n⊢ g.equiv f","decl":"set_option linter.deprecated false in\n/-- Equivalence of multiplicative ring norms is symmetric. -/\n@[deprecated \"Use AbsoluteValue.isEquiv_symm instead\" (since := \"2025-01-07\")]\nlemma equiv_symm {f g : MulRingNorm R} (hfg : equiv f g) : equiv g f := by\n  rcases hfg with ⟨c, hcpos, h⟩\n  use 1/c\n  constructor\n  · simp only [one_div, inv_pos, hcpos]\n  ext x\n  simpa [← congr_fun h x] using Real.rpow_rpow_inv (apply_nonneg f x) (ne_of_lt hcpos).symm\n\n"}
{"name":"MulRingNorm.equiv_trans","module":"Mathlib.Analysis.Normed.Ring.Seminorm","initialProofState":"R : Type u_2\ninst✝ : Ring R\nf g k : MulRingNorm R\nhfg : f.equiv g\nhgk : g.equiv k\n⊢ f.equiv k","decl":"set_option linter.deprecated false in\n/-- Equivalence of multiplicative ring norms is transitive. -/\n@[deprecated \"Use AbsoluteValue.isEquiv_trans instead\" (since := \"2025-01-07\")]\nlemma equiv_trans {f g k : MulRingNorm R} (hfg : equiv f g) (hgk : equiv g k) :\n    equiv f k := by\n  rcases hfg with ⟨c, hcPos, hfg⟩\n  rcases hgk with ⟨d, hdPos, hgk⟩\n  refine ⟨c*d, (mul_pos_iff_of_pos_left hcPos).mpr hdPos, ?_⟩\n  ext x\n  rw [Real.rpow_mul (apply_nonneg f x), congr_fun hfg x, congr_fun hgk x]\n\n"}
{"name":"normRingNorm_toFun","module":"Mathlib.Analysis.Normed.Ring.Seminorm","initialProofState":"R : Type u_2\ninst✝ : NonUnitalNormedRing R\na✝ : R\n⊢ Eq ((normRingNorm R).toFun a✝) (Norm.norm a✝)","decl":"/-- The norm of a `NonUnitalNormedRing` as a `RingNorm`. -/\n@[simps!]\ndef normRingNorm (R : Type*) [NonUnitalNormedRing R] : RingNorm R :=\n  { normAddGroupNorm R, normRingSeminorm R with }\n\n\n"}
{"name":"MulRingNorm_nat_le_nat","module":"Mathlib.Analysis.Normed.Ring.Seminorm","initialProofState":"R : Type u_2\ninst✝ : Ring R\nn : Nat\nf : MulRingNorm R\n⊢ LE.le (f ↑n) ↑n","decl":"/-- A multiplicative ring norm satisfies `f n ≤ n` for every `n : ℕ`. -/\n@[deprecated \"Use AbsoluteValue.apply_nat_le_self instead\" (since := \"2025-01-07\")]\nlemma MulRingNorm_nat_le_nat {R : Type*} [Ring R] (n : ℕ) (f : MulRingNorm R) : f n ≤ n := by\n  induction n with\n  | zero => simp only [Nat.cast_zero, map_zero, le_refl]\n  | succ n hn =>\n    simp only [Nat.cast_succ]\n    calc\n      f (n + 1) ≤ f (n) + f 1 := f.add_le' ↑n 1\n      _ = f (n) + 1 := by rw [map_one]\n      _ ≤ n + 1 := add_le_add_right hn 1\n\n"}
{"name":"MulRingNorm.apply_natAbs_eq","module":"Mathlib.Analysis.Normed.Ring.Seminorm","initialProofState":"R : Type u_2\ninst✝ : Ring R\nx : Int\nf : MulRingNorm R\n⊢ Eq (f ↑x.natAbs) (f ↑x)","decl":"/-- A multiplicative norm composed with the absolute value on integers equals the norm itself. -/\n@[deprecated \"Use AbsoluteValue.apply_natAbs_eq instead\" (since := \"2025-01-07\")]\nlemma MulRingNorm.apply_natAbs_eq {R : Type*} [Ring R] (x : ℤ) (f : MulRingNorm R) : f (natAbs x) =\n    f x := by\n  obtain ⟨n, rfl | rfl⟩ := eq_nat_or_neg x <;>\n  simp only [natAbs_neg, natAbs_ofNat, cast_neg, cast_natCast, map_neg_eq_map]\n\n"}
{"name":"NormedRing.toRingNorm_toFun","module":"Mathlib.Analysis.Normed.Ring.Seminorm","initialProofState":"R : Type u_2\ninst✝ : NormedRing R\na✝ : R\n⊢ Eq ((NormedRing.toRingNorm R).toFun a✝) (Norm.norm a✝)","decl":"/-- The norm on a `NormedRing`, as a `RingNorm`. -/\n@[simps]\ndef NormedRing.toRingNorm (R : Type*) [NormedRing R] : RingNorm R where\n  toFun     := norm\n  map_zero' := norm_zero\n  add_le'   := norm_add_le\n  mul_le'   := norm_mul_le\n  neg'      := norm_neg\n  eq_zero_of_map_eq_zero' x hx := by rw [← norm_eq_zero]; exact hx\n\n"}
{"name":"NormedRing.toRingNorm_apply","module":"Mathlib.Analysis.Normed.Ring.Seminorm","initialProofState":"R : Type u_2\ninst✝ : NormedRing R\nx : R\n⊢ Eq ((NormedRing.toRingNorm R) x) (Norm.norm x)","decl":"@[simp]\ntheorem NormedRing.toRingNorm_apply (R : Type*) [NormedRing R] (x : R) :\n    (NormedRing.toRingNorm R) x = ‖x‖ :=\n  rfl\n\n"}
{"name":"mulRingNorm_sum_le_sum_mulRingNorm","module":"Mathlib.Analysis.Normed.Ring.Seminorm","initialProofState":"R : Type u_2\ninst✝ : NonAssocRing R\nl : List R\nf : MulRingNorm R\n⊢ LE.le (f l.sum) (List.map (⇑f) l).sum","decl":"/-- Triangle inequality for `MulRingNorm` applied to a list. -/\n@[deprecated \"Use AbsoluteValue.listSum_le instead\" (since := \"2025-01-07\")]\nlemma mulRingNorm_sum_le_sum_mulRingNorm {R : Type*} [NonAssocRing R] (l : List R)\n    (f : MulRingNorm R) : f l.sum ≤ (l.map f).sum := by\n  induction l with\n  | nil => simp only [List.sum_nil, map_zero, List.map_nil, le_refl]\n  | cons head tail ih =>\n    simp only [List.sum_cons, List.map_cons]\n    calc f (head + List.sum tail) ≤ f head + f (List.sum tail) := by apply f.add_le'\n      _ ≤ f head + List.sum (List.map f tail) := by simp only [add_le_add_iff_left, ih]\n"}
