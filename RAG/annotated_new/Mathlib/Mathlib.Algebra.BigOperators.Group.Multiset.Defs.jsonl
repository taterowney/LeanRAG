{"name":"Multiset.prod_eq_foldr","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Defs","initialProofState":"α : Type u_3\ninst✝ : CommMonoid α\ns : Multiset α\n⊢ Eq s.prod (Multiset.foldr (fun x1 x2 => HMul.hMul x1 x2) 1 s)","decl":"@[to_additive]\ntheorem prod_eq_foldr (s : Multiset α) :\n    prod s = foldr (· * ·) 1 s :=\n  rfl\n\n"}
{"name":"Multiset.sum_eq_foldr","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Defs","initialProofState":"α : Type u_3\ninst✝ : AddCommMonoid α\ns : Multiset α\n⊢ Eq s.sum (Multiset.foldr (fun x1 x2 => HAdd.hAdd x1 x2) 0 s)","decl":"@[to_additive]\ntheorem prod_eq_foldr (s : Multiset α) :\n    prod s = foldr (· * ·) 1 s :=\n  rfl\n\n"}
{"name":"Multiset.prod_eq_foldl","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Defs","initialProofState":"α : Type u_3\ninst✝ : CommMonoid α\ns : Multiset α\n⊢ Eq s.prod (Multiset.foldl (fun x1 x2 => HMul.hMul x1 x2) 1 s)","decl":"@[to_additive]\ntheorem prod_eq_foldl (s : Multiset α) :\n    prod s = foldl (· * ·) 1 s :=\n  (foldr_swap _ _ _).trans (by simp [mul_comm])\n\n"}
{"name":"Multiset.sum_eq_foldl","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Defs","initialProofState":"α : Type u_3\ninst✝ : AddCommMonoid α\ns : Multiset α\n⊢ Eq s.sum (Multiset.foldl (fun x1 x2 => HAdd.hAdd x1 x2) 0 s)","decl":"@[to_additive]\ntheorem prod_eq_foldl (s : Multiset α) :\n    prod s = foldl (· * ·) 1 s :=\n  (foldr_swap _ _ _).trans (by simp [mul_comm])\n\n"}
{"name":"Multiset.sum_coe","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Defs","initialProofState":"α : Type u_3\ninst✝ : AddCommMonoid α\nl : List α\n⊢ Eq (↑l).sum l.sum","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem prod_coe (l : List α) : prod ↑l = l.prod := rfl\n\n"}
{"name":"Multiset.prod_coe","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Defs","initialProofState":"α : Type u_3\ninst✝ : CommMonoid α\nl : List α\n⊢ Eq (↑l).prod l.prod","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem prod_coe (l : List α) : prod ↑l = l.prod := rfl\n\n"}
{"name":"Multiset.prod_toList","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Defs","initialProofState":"α : Type u_3\ninst✝ : CommMonoid α\ns : Multiset α\n⊢ Eq s.toList.prod s.prod","decl":"@[to_additive (attr := simp)]\ntheorem prod_toList (s : Multiset α) : s.toList.prod = s.prod := by\n  conv_rhs => rw [← coe_toList s]\n  rw [prod_coe]\n\n"}
{"name":"Multiset.sum_toList","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Defs","initialProofState":"α : Type u_3\ninst✝ : AddCommMonoid α\ns : Multiset α\n⊢ Eq s.toList.sum s.sum","decl":"@[to_additive (attr := simp)]\ntheorem prod_toList (s : Multiset α) : s.toList.prod = s.prod := by\n  conv_rhs => rw [← coe_toList s]\n  rw [prod_coe]\n\n"}
{"name":"Multiset.prod_zero","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Defs","initialProofState":"α : Type u_3\ninst✝ : CommMonoid α\n⊢ Eq (Multiset.prod 0) 1","decl":"@[to_additive (attr := simp)]\ntheorem prod_zero : @prod α _ 0 = 1 :=\n  rfl\n\n"}
{"name":"Multiset.sum_zero","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Defs","initialProofState":"α : Type u_3\ninst✝ : AddCommMonoid α\n⊢ Eq (Multiset.sum 0) 0","decl":"@[to_additive (attr := simp)]\ntheorem prod_zero : @prod α _ 0 = 1 :=\n  rfl\n\n"}
{"name":"Multiset.sum_cons","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Defs","initialProofState":"α : Type u_3\ninst✝ : AddCommMonoid α\na : α\ns : Multiset α\n⊢ Eq (Multiset.cons a s).sum (HAdd.hAdd a s.sum)","decl":"@[to_additive (attr := simp)]\ntheorem prod_cons (a : α) (s) : prod (a ::ₘ s) = a * prod s :=\n  foldr_cons _ _ _ _\n\n"}
{"name":"Multiset.prod_cons","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Defs","initialProofState":"α : Type u_3\ninst✝ : CommMonoid α\na : α\ns : Multiset α\n⊢ Eq (Multiset.cons a s).prod (HMul.hMul a s.prod)","decl":"@[to_additive (attr := simp)]\ntheorem prod_cons (a : α) (s) : prod (a ::ₘ s) = a * prod s :=\n  foldr_cons _ _ _ _\n\n"}
{"name":"Multiset.prod_singleton","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Defs","initialProofState":"α : Type u_3\ninst✝ : CommMonoid α\na : α\n⊢ Eq (Singleton.singleton a).prod a","decl":"@[to_additive (attr := simp)]\ntheorem prod_singleton (a : α) : prod {a} = a := by\n  simp only [mul_one, prod_cons, ← cons_zero, eq_self_iff_true, prod_zero]\n\n"}
{"name":"Multiset.sum_singleton","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Defs","initialProofState":"α : Type u_3\ninst✝ : AddCommMonoid α\na : α\n⊢ Eq (Singleton.singleton a).sum a","decl":"@[to_additive (attr := simp)]\ntheorem prod_singleton (a : α) : prod {a} = a := by\n  simp only [mul_one, prod_cons, ← cons_zero, eq_self_iff_true, prod_zero]\n\n"}
{"name":"Multiset.prod_pair","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Defs","initialProofState":"α : Type u_3\ninst✝ : CommMonoid α\na b : α\n⊢ Eq (Insert.insert a (Singleton.singleton b)).prod (HMul.hMul a b)","decl":"@[to_additive]\ntheorem prod_pair (a b : α) : ({a, b} : Multiset α).prod = a * b := by\n  rw [insert_eq_cons, prod_cons, prod_singleton]\n\n"}
{"name":"Multiset.sum_pair","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Defs","initialProofState":"α : Type u_3\ninst✝ : AddCommMonoid α\na b : α\n⊢ Eq (Insert.insert a (Singleton.singleton b)).sum (HAdd.hAdd a b)","decl":"@[to_additive]\ntheorem prod_pair (a b : α) : ({a, b} : Multiset α).prod = a * b := by\n  rw [insert_eq_cons, prod_cons, prod_singleton]\n\n"}
{"name":"Multiset.sum_replicate","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Defs","initialProofState":"α : Type u_3\ninst✝ : AddCommMonoid α\nn : Nat\na : α\n⊢ Eq (Multiset.replicate n a).sum (HSMul.hSMul n a)","decl":"@[to_additive (attr := simp)]\ntheorem prod_replicate (n : ℕ) (a : α) : (replicate n a).prod = a ^ n := by\n  simp [replicate, List.prod_replicate]\n\n"}
{"name":"Multiset.prod_replicate","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Defs","initialProofState":"α : Type u_3\ninst✝ : CommMonoid α\nn : Nat\na : α\n⊢ Eq (Multiset.replicate n a).prod (HPow.hPow a n)","decl":"@[to_additive (attr := simp)]\ntheorem prod_replicate (n : ℕ) (a : α) : (replicate n a).prod = a ^ n := by\n  simp [replicate, List.prod_replicate]\n\n"}
{"name":"Multiset.pow_count","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Defs","initialProofState":"α : Type u_3\ninst✝¹ : CommMonoid α\ns : Multiset α\ninst✝ : DecidableEq α\na : α\n⊢ Eq (HPow.hPow a (Multiset.count a s)) (Multiset.filter (Eq a) s).prod","decl":"@[to_additive]\ntheorem pow_count [DecidableEq α] (a : α) : a ^ s.count a = (s.filter (Eq a)).prod := by\n  rw [filter_eq, prod_replicate]\n\n"}
{"name":"Multiset.nsmul_count","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Defs","initialProofState":"α : Type u_3\ninst✝¹ : AddCommMonoid α\ns : Multiset α\ninst✝ : DecidableEq α\na : α\n⊢ Eq (HSMul.hSMul (Multiset.count a s) a) (Multiset.filter (Eq a) s).sum","decl":"@[to_additive]\ntheorem pow_count [DecidableEq α] (a : α) : a ^ s.count a = (s.filter (Eq a)).prod := by\n  rw [filter_eq, prod_replicate]\n\n"}
{"name":"Multiset.prod_hom_rel","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Defs","initialProofState":"ι : Type u_2\nα : Type u_3\nβ : Type u_4\ninst✝¹ : CommMonoid α\ninst✝ : CommMonoid β\ns : Multiset ι\nr : α → β → Prop\nf : ι → α\ng : ι → β\nh₁ : r 1 1\nh₂ : ∀ ⦃a : ι⦄ ⦃b : α⦄ ⦃c : β⦄, r b c → r (HMul.hMul (f a) b) (HMul.hMul (g a) c)\n⊢ r (Multiset.map f s).prod (Multiset.map g s).prod","decl":"@[to_additive]\ntheorem prod_hom_rel (s : Multiset ι) {r : α → β → Prop} {f : ι → α} {g : ι → β}\n    (h₁ : r 1 1) (h₂ : ∀ ⦃a b c⦄, r b c → r (f a * b) (g a * c)) :\n    r (s.map f).prod (s.map g).prod :=\n  Quotient.inductionOn s fun l => by\n    simp only [l.prod_hom_rel h₁ h₂, quot_mk_to_coe, map_coe, prod_coe]\n\n"}
{"name":"Multiset.sum_hom_rel","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Defs","initialProofState":"ι : Type u_2\nα : Type u_3\nβ : Type u_4\ninst✝¹ : AddCommMonoid α\ninst✝ : AddCommMonoid β\ns : Multiset ι\nr : α → β → Prop\nf : ι → α\ng : ι → β\nh₁ : r 0 0\nh₂ : ∀ ⦃a : ι⦄ ⦃b : α⦄ ⦃c : β⦄, r b c → r (HAdd.hAdd (f a) b) (HAdd.hAdd (g a) c)\n⊢ r (Multiset.map f s).sum (Multiset.map g s).sum","decl":"@[to_additive]\ntheorem prod_hom_rel (s : Multiset ι) {r : α → β → Prop} {f : ι → α} {g : ι → β}\n    (h₁ : r 1 1) (h₂ : ∀ ⦃a b c⦄, r b c → r (f a * b) (g a * c)) :\n    r (s.map f).prod (s.map g).prod :=\n  Quotient.inductionOn s fun l => by\n    simp only [l.prod_hom_rel h₁ h₂, quot_mk_to_coe, map_coe, prod_coe]\n\n"}
{"name":"Multiset.sum_map_zero","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Defs","initialProofState":"ι : Type u_2\nα : Type u_3\ninst✝ : AddCommMonoid α\nm : Multiset ι\n⊢ Eq (Multiset.map (fun x => 0) m).sum 0","decl":"@[to_additive]\ntheorem prod_map_one : prod (m.map fun _ => (1 : α)) = 1 := by\n  rw [map_const', prod_replicate, one_pow]\n\n"}
{"name":"Multiset.prod_map_one","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Defs","initialProofState":"ι : Type u_2\nα : Type u_3\ninst✝ : CommMonoid α\nm : Multiset ι\n⊢ Eq (Multiset.map (fun x => 1) m).prod 1","decl":"@[to_additive]\ntheorem prod_map_one : prod (m.map fun _ => (1 : α)) = 1 := by\n  rw [map_const', prod_replicate, one_pow]\n\n"}
{"name":"Multiset.sum_induction","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Defs","initialProofState":"α : Type u_3\ninst✝ : AddCommMonoid α\np : α → Prop\ns : Multiset α\np_mul : ∀ (a b : α), p a → p b → p (HAdd.hAdd a b)\np_one : p 0\np_s : ∀ (a : α), Membership.mem s a → p a\n⊢ p s.sum","decl":"@[to_additive]\ntheorem prod_induction (p : α → Prop) (s : Multiset α) (p_mul : ∀ a b, p a → p b → p (a * b))\n    (p_one : p 1) (p_s : ∀ a ∈ s, p a) : p s.prod := by\n  rw [prod_eq_foldr]\n  exact foldr_induction (· * ·) 1 p s p_mul p_one p_s\n\n"}
{"name":"Multiset.prod_induction","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Defs","initialProofState":"α : Type u_3\ninst✝ : CommMonoid α\np : α → Prop\ns : Multiset α\np_mul : ∀ (a b : α), p a → p b → p (HMul.hMul a b)\np_one : p 1\np_s : ∀ (a : α), Membership.mem s a → p a\n⊢ p s.prod","decl":"@[to_additive]\ntheorem prod_induction (p : α → Prop) (s : Multiset α) (p_mul : ∀ a b, p a → p b → p (a * b))\n    (p_one : p 1) (p_s : ∀ a ∈ s, p a) : p s.prod := by\n  rw [prod_eq_foldr]\n  exact foldr_induction (· * ·) 1 p s p_mul p_one p_s\n\n"}
{"name":"Multiset.prod_induction_nonempty","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Defs","initialProofState":"α : Type u_3\ninst✝ : CommMonoid α\ns : Multiset α\np : α → Prop\np_mul : ∀ (a b : α), p a → p b → p (HMul.hMul a b)\nhs : Ne s EmptyCollection.emptyCollection\np_s : ∀ (a : α), Membership.mem s a → p a\n⊢ p s.prod","decl":"@[to_additive]\ntheorem prod_induction_nonempty (p : α → Prop) (p_mul : ∀ a b, p a → p b → p (a * b)) (hs : s ≠ ∅)\n    (p_s : ∀ a ∈ s, p a) : p s.prod := by\n  induction s using Multiset.induction_on with\n  | empty => simp at hs\n  | cons a s hsa =>\n    rw [prod_cons]\n    by_cases hs_empty : s = ∅\n    · simp [hs_empty, p_s a]\n    have hps : ∀ x, x ∈ s → p x := fun x hxs => p_s x (mem_cons_of_mem hxs)\n    exact p_mul a s.prod (p_s a (mem_cons_self a s)) (hsa hs_empty hps)\n\n"}
{"name":"Multiset.sum_induction_nonempty","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Defs","initialProofState":"α : Type u_3\ninst✝ : AddCommMonoid α\ns : Multiset α\np : α → Prop\np_mul : ∀ (a b : α), p a → p b → p (HAdd.hAdd a b)\nhs : Ne s EmptyCollection.emptyCollection\np_s : ∀ (a : α), Membership.mem s a → p a\n⊢ p s.sum","decl":"@[to_additive]\ntheorem prod_induction_nonempty (p : α → Prop) (p_mul : ∀ a b, p a → p b → p (a * b)) (hs : s ≠ ∅)\n    (p_s : ∀ a ∈ s, p a) : p s.prod := by\n  induction s using Multiset.induction_on with\n  | empty => simp at hs\n  | cons a s hsa =>\n    rw [prod_cons]\n    by_cases hs_empty : s = ∅\n    · simp [hs_empty, p_s a]\n    have hps : ∀ x, x ∈ s → p x := fun x hxs => p_s x (mem_cons_of_mem hxs)\n    exact p_mul a s.prod (p_s a (mem_cons_self a s)) (hsa hs_empty hps)\n\n"}
