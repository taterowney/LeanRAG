{"name":"Module.mem_freeLocus","module":"Mathlib.RingTheory.Spectrum.Prime.FreeLocus","initialProofState":"R : Type uR\nM : Type uM\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np : PrimeSpectrum R\n⊢ Iff (Membership.mem (Module.freeLocus R M) p) (Module.Free (Localization.AtPrime p.asIdeal) (LocalizedModule p.asIdeal.primeCompl M))","decl":"lemma mem_freeLocus {p} : p ∈ freeLocus R M ↔\n    Module.Free (Localization.AtPrime p.asIdeal) (LocalizedModule p.asIdeal.primeCompl M) :=\n  Iff.rfl\n\n"}
{"name":"Module.mem_freeLocus_of_isLocalization","module":"Mathlib.RingTheory.Spectrum.Prime.FreeLocus","initialProofState":"R : Type uR\nM : Type uM\ninst✝¹⁰ : CommRing R\ninst✝⁹ : AddCommGroup M\ninst✝⁸ : Module R M\np : PrimeSpectrum R\nRₚ : Type u_1\nMₚ : Type u_2\ninst✝⁷ : CommRing Rₚ\ninst✝⁶ : Algebra R Rₚ\ninst✝⁵ : IsLocalization.AtPrime Rₚ p.asIdeal\ninst✝⁴ : AddCommGroup Mₚ\ninst✝³ : Module R Mₚ\nf : LinearMap (RingHom.id R) M Mₚ\ninst✝² : IsLocalizedModule p.asIdeal.primeCompl f\ninst✝¹ : Module Rₚ Mₚ\ninst✝ : IsScalarTower R Rₚ Mₚ\n⊢ Iff (Membership.mem (Module.freeLocus R M) p) (Module.Free Rₚ Mₚ)","decl":"attribute [local instance] RingHomInvPair.of_ringEquiv in\nlemma mem_freeLocus_of_isLocalization (p : PrimeSpectrum R)\n    (Rₚ Mₚ) [CommRing Rₚ] [Algebra R Rₚ] [IsLocalization.AtPrime Rₚ p.asIdeal]\n    [AddCommGroup Mₚ] [Module R Mₚ] (f : M →ₗ[R] Mₚ) [IsLocalizedModule p.asIdeal.primeCompl f]\n    [Module Rₚ Mₚ] [IsScalarTower R Rₚ Mₚ] :\n    p ∈ freeLocus R M ↔ Module.Free Rₚ Mₚ := by\n  apply Module.Free.iff_of_ringEquiv (IsLocalization.algEquiv p.asIdeal.primeCompl\n      (Localization.AtPrime p.asIdeal) Rₚ).toRingEquiv\n  refine { __ := IsLocalizedModule.iso p.asIdeal.primeCompl f, map_smul' := ?_ }\n  intro r x\n  obtain ⟨r, s, rfl⟩ := IsLocalization.mk'_surjective p.asIdeal.primeCompl r\n  apply ((Module.End_isUnit_iff _).mp (IsLocalizedModule.map_units f s)).1\n  simp only [AddHom.toFun_eq_coe, LinearMap.coe_toAddHom, LinearEquiv.coe_coe,\n    algebraMap_end_apply, AlgEquiv.toRingEquiv_eq_coe,\n    AlgEquiv.toRingEquiv_toRingHom, RingHom.coe_coe, IsLocalization.algEquiv_apply,\n    IsLocalization.map_id_mk']\n  simp only [← map_smul, ← smul_assoc, IsLocalization.smul_mk'_self, algebraMap_smul,\n    IsLocalization.map_id_mk']\n\n"}
{"name":"Module.mem_freeLocus_iff_tensor","module":"Mathlib.RingTheory.Spectrum.Prime.FreeLocus","initialProofState":"R : Type uR\nM : Type uM\ninst✝⁵ : CommRing R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\np : PrimeSpectrum R\nRₚ : Type u_1\ninst✝² : CommRing Rₚ\ninst✝¹ : Algebra R Rₚ\ninst✝ : IsLocalization.AtPrime Rₚ p.asIdeal\n⊢ Iff (Membership.mem (Module.freeLocus R M) p) (Module.Free Rₚ (TensorProduct R Rₚ M))","decl":"attribute [local instance] RingHomInvPair.of_ringEquiv in\nlemma mem_freeLocus_iff_tensor (p : PrimeSpectrum R)\n    (Rₚ) [CommRing Rₚ] [Algebra R Rₚ] [IsLocalization.AtPrime Rₚ p.asIdeal] :\n    p ∈ freeLocus R M ↔ Module.Free Rₚ (Rₚ ⊗[R] M) := by\n  have := (isLocalizedModule_iff_isBaseChange p.asIdeal.primeCompl _ _).mpr\n    (TensorProduct.isBaseChange R M Rₚ)\n  exact mem_freeLocus_of_isLocalization p Rₚ (f := TensorProduct.mk R Rₚ M 1)\n\n"}
{"name":"Module.freeLocus_congr","module":"Mathlib.RingTheory.Spectrum.Prime.FreeLocus","initialProofState":"R : Type uR\nM : Type uM\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nM' : Type u_1\ninst✝¹ : AddCommGroup M'\ninst✝ : Module R M'\ne : LinearEquiv (RingHom.id R) M M'\n⊢ Eq (Module.freeLocus R M) (Module.freeLocus R M')","decl":"lemma freeLocus_congr {M'} [AddCommGroup M'] [Module R M'] (e : M ≃ₗ[R] M') :\n    freeLocus R M = freeLocus R M' := by\n  ext p\n  exact mem_freeLocus_of_isLocalization _ _ _\n    (LocalizedModule.mkLinearMap p.asIdeal.primeCompl M' ∘ₗ e.toLinearMap)\n\n"}
{"name":"Module.comap_freeLocus_le","module":"Mathlib.RingTheory.Spectrum.Prime.FreeLocus","initialProofState":"R : Type uR\nM : Type uM\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nA : Type u_1\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\n⊢ LE.le (Set.preimage (⇑(PrimeSpectrum.comap (algebraMap R A))) (Module.freeLocus R M)) (Module.freeLocus A (TensorProduct R A M))","decl":"open TensorProduct in\nlemma comap_freeLocus_le {A} [CommRing A] [Algebra R A] :\n    comap (algebraMap R A) ⁻¹' freeLocus R M ≤ freeLocus A (A ⊗[R] M) := by\n  intro p hp\n  let Rₚ := Localization.AtPrime (comap (algebraMap R A) p).asIdeal\n  let Aₚ := Localization.AtPrime p.asIdeal\n  rw [Set.mem_preimage, mem_freeLocus_iff_tensor _ Rₚ] at hp\n  rw [mem_freeLocus_iff_tensor _ Aₚ]\n  letI algebra : Algebra Rₚ Aₚ := (Localization.localRingHom\n    (comap (algebraMap R A) p).asIdeal p.asIdeal (algebraMap R A) rfl).toAlgebra\n  have : IsScalarTower R Rₚ Aₚ := IsScalarTower.of_algebraMap_eq'\n    (by simp [Rₚ, Aₚ, algebra, RingHom.algebraMap_toAlgebra, Localization.localRingHom,\n        ← IsScalarTower.algebraMap_eq])\n  let e := AlgebraTensorModule.cancelBaseChange R Rₚ Aₚ Aₚ M ≪≫ₗ\n    (AlgebraTensorModule.cancelBaseChange R A Aₚ Aₚ M).symm\n  exact .of_equiv e\n\n"}
{"name":"Module.freeLocus_localization","module":"Mathlib.RingTheory.Spectrum.Prime.FreeLocus","initialProofState":"R : Type uR\nM : Type uM\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nS : Submonoid R\n⊢ Eq (Module.freeLocus (Localization S) (LocalizedModule S M)) (Set.preimage (⇑(PrimeSpectrum.comap (algebraMap R (Localization S)))) (Module.freeLocus R M))","decl":"lemma freeLocus_localization (S : Submonoid R) :\n    freeLocus (Localization S) (LocalizedModule S M) =\n      comap (algebraMap R _) ⁻¹' freeLocus R M := by\n  ext p\n  simp only [Set.mem_preimage]\n  let p' := p.asIdeal.comap (algebraMap R _)\n  have hp' : S ≤ p'.primeCompl := fun x hx H ↦\n    p.isPrime.ne_top (Ideal.eq_top_of_isUnit_mem _ H (IsLocalization.map_units _ ⟨x, hx⟩))\n  let Rₚ := Localization.AtPrime p'\n  let Mₚ := LocalizedModule p'.primeCompl M\n  letI : Algebra (Localization S) Rₚ :=\n    IsLocalization.localizationAlgebraOfSubmonoidLe _ _ S p'.primeCompl hp'\n  have : IsScalarTower R (Localization S) Rₚ :=\n    IsLocalization.localization_isScalarTower_of_submonoid_le ..\n  have : IsLocalization.AtPrime Rₚ p.asIdeal := by\n    have := IsLocalization.isLocalization_of_submonoid_le (Localization S) Rₚ _ _ hp'\n    apply IsLocalization.isLocalization_of_is_exists_mul_mem _\n      (Submonoid.map (algebraMap R (Localization S)) p'.primeCompl)\n    · rintro _ ⟨x, hx, rfl⟩; exact hx\n    · rintro ⟨x, hx⟩\n      obtain ⟨x, s, rfl⟩ := IsLocalization.mk'_surjective S x\n      refine ⟨algebraMap _ _ s.1, x, fun H ↦ hx ?_, by simp⟩\n      rw [IsLocalization.mk'_eq_mul_mk'_one]\n      exact Ideal.mul_mem_right _ _ H\n  letI : Module (Localization S) Mₚ := Module.compHom Mₚ (algebraMap _ Rₚ)\n  have : IsScalarTower R (Localization S) Mₚ :=\n    ⟨fun r r' m ↦ show algebraMap _ Rₚ (r • r') • m = _ by\n      simp [p', Rₚ, Mₚ, Algebra.smul_def, ← IsScalarTower.algebraMap_apply, mul_smul]; rfl⟩\n  have : IsScalarTower (Localization S) Rₚ Mₚ :=\n    ⟨fun r r' m ↦ show _ = algebraMap _ Rₚ r • r' • m by rw [← mul_smul, ← Algebra.smul_def]⟩\n  let l := (IsLocalizedModule.liftOfLE _ _ hp' (LocalizedModule.mkLinearMap S M)\n    (LocalizedModule.mkLinearMap p'.primeCompl M)).extendScalarsOfIsLocalization S\n    (Localization S)\n  have : IsLocalizedModule p.asIdeal.primeCompl l := by\n    have : IsLocalizedModule p'.primeCompl (l.restrictScalars R) :=\n      inferInstanceAs (IsLocalizedModule p'.primeCompl\n        (IsLocalizedModule.liftOfLE _ _ hp' (LocalizedModule.mkLinearMap S M)\n        (LocalizedModule.mkLinearMap p'.primeCompl M)))\n    have : IsLocalizedModule (Algebra.algebraMapSubmonoid (Localization S) p'.primeCompl) l :=\n      IsLocalizedModule.of_restrictScalars p'.primeCompl ..\n    apply IsLocalizedModule.of_exists_mul_mem\n      (Algebra.algebraMapSubmonoid (Localization S) p'.primeCompl)\n    · rintro _ ⟨x, hx, rfl⟩; exact hx\n    · rintro ⟨x, hx⟩\n      obtain ⟨x, s, rfl⟩ := IsLocalization.mk'_surjective S x\n      refine ⟨algebraMap _ _ s.1, x, fun H ↦ hx ?_, by simp⟩\n      rw [IsLocalization.mk'_eq_mul_mk'_one]\n      exact Ideal.mul_mem_right _ _ H\n  rw [mem_freeLocus_of_isLocalization (R := Localization S) p Rₚ Mₚ l]\n  rfl\n\n"}
{"name":"Module.freeLocus_eq_univ_iff","module":"Mathlib.RingTheory.Spectrum.Prime.FreeLocus","initialProofState":"R : Type uR\nM : Type uM\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : Module.FinitePresentation R M\n⊢ Iff (Eq (Module.freeLocus R M) Set.univ) (Module.Projective R M)","decl":"lemma freeLocus_eq_univ_iff [Module.FinitePresentation R M] :\n    freeLocus R M = Set.univ ↔ Module.Projective R M := by\n  simp_rw [Set.eq_univ_iff_forall, mem_freeLocus]\n  exact ⟨fun H ↦ Module.projective_of_localization_maximal fun I hI ↦\n    have := H ⟨I, hI.isPrime⟩; .of_free, fun H x ↦ Module.free_of_flat_of_isLocalRing⟩\n\n"}
{"name":"Module.freeLocus_eq_univ","module":"Mathlib.RingTheory.Spectrum.Prime.FreeLocus","initialProofState":"R : Type uR\nM : Type uM\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Module.FinitePresentation R M\ninst✝ : Module.Flat R M\n⊢ Eq (Module.freeLocus R M) Set.univ","decl":"lemma freeLocus_eq_univ [Module.FinitePresentation R M] [Module.Flat R M] :\n    freeLocus R M = Set.univ := by\n  simp_rw [Set.eq_univ_iff_forall, mem_freeLocus]\n  exact fun x ↦ Module.free_of_flat_of_isLocalRing\n\n"}
{"name":"Module.basicOpen_subset_freeLocus_iff","module":"Mathlib.RingTheory.Spectrum.Prime.FreeLocus","initialProofState":"R : Type uR\nM : Type uM\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : Module.FinitePresentation R M\nf : R\n⊢ Iff (HasSubset.Subset (↑(PrimeSpectrum.basicOpen f)) (Module.freeLocus R M)) (Module.Projective (Localization.Away f) (LocalizedModule (Submonoid.powers f) M))","decl":"lemma basicOpen_subset_freeLocus_iff [Module.FinitePresentation R M] {f : R} :\n    (basicOpen f : Set (PrimeSpectrum R)) ⊆ freeLocus R M ↔\n      Module.Projective (Localization.Away f) (LocalizedModule (.powers f) M) := by\n  rw [← freeLocus_eq_univ_iff, freeLocus_localization,\n    Set.preimage_eq_univ_iff, localization_away_comap_range _ f]\n\n"}
{"name":"Module.isOpen_freeLocus","module":"Mathlib.RingTheory.Spectrum.Prime.FreeLocus","initialProofState":"R : Type uR\nM : Type uM\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : Module.FinitePresentation R M\n⊢ IsOpen (Module.freeLocus R M)","decl":"lemma isOpen_freeLocus [Module.FinitePresentation R M] :\n    IsOpen (freeLocus R M) := by\n  refine isOpen_iff_forall_mem_open.mpr fun x hx ↦ ?_\n  have : Module.Free _ _ := hx\n  obtain ⟨r, hr, hr', _⟩ := Module.FinitePresentation.exists_free_localizedModule_powers\n    x.asIdeal.primeCompl (LocalizedModule.mkLinearMap x.asIdeal.primeCompl M)\n    (Localization.AtPrime x.asIdeal)\n  exact ⟨basicOpen r, basicOpen_subset_freeLocus_iff.mpr inferInstance, (basicOpen r).2, hr⟩\n\n"}
{"name":"Module.isLocallyConstant_rankAtStalk_freeLocus","module":"Mathlib.RingTheory.Spectrum.Prime.FreeLocus","initialProofState":"R : Type uR\nM : Type uM\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : Module.FinitePresentation R M\n⊢ IsLocallyConstant fun x => Module.rankAtStalk M ↑x","decl":"lemma isLocallyConstant_rankAtStalk_freeLocus [Module.FinitePresentation R M] :\n    IsLocallyConstant (fun x : freeLocus R M ↦ rankAtStalk M x.1) := by\n  refine (IsLocallyConstant.iff_exists_open _).mpr fun ⟨x, hx⟩ ↦ ?_\n  have : Module.Free _ _ := hx\n  obtain ⟨f, hf, hf', hf''⟩ := Module.FinitePresentation.exists_free_localizedModule_powers\n    x.asIdeal.primeCompl (LocalizedModule.mkLinearMap x.asIdeal.primeCompl M)\n    (Localization.AtPrime x.asIdeal)\n  refine ⟨Subtype.val ⁻¹' basicOpen f, (basicOpen f).2.preimage continuous_subtype_val, hf, ?_⟩\n  rintro ⟨p, hp''⟩ hp\n  let p' := Algebra.algebraMapSubmonoid (Localization (.powers f)) p.asIdeal.primeCompl\n  have hp' : Submonoid.powers f ≤ p.asIdeal.primeCompl := by\n    simpa [Submonoid.powers_le, Ideal.primeCompl]\n  let Rₚ := Localization.AtPrime p.asIdeal\n  let Mₚ := LocalizedModule p.asIdeal.primeCompl M\n  letI : Algebra (Localization.Away f) Rₚ :=\n    IsLocalization.localizationAlgebraOfSubmonoidLe _ _ (.powers f) p.asIdeal.primeCompl hp'\n  have : IsScalarTower R (Localization.Away f) Rₚ :=\n    IsLocalization.localization_isScalarTower_of_submonoid_le ..\n  letI : Module (Localization.Away f) Mₚ := Module.compHom Mₚ (algebraMap _ Rₚ)\n  have : IsScalarTower R (Localization.Away f) Mₚ :=\n    ⟨fun r r' m ↦ show algebraMap _ Rₚ (r • r') • m = _ by\n      simp [Rₚ, Mₚ, Algebra.smul_def, ← IsScalarTower.algebraMap_apply, mul_smul]; rfl⟩\n  have : IsScalarTower (Localization.Away f) Rₚ Mₚ :=\n    ⟨fun r r' m ↦ show _ = algebraMap _ Rₚ r • r' • m by rw [← mul_smul, ← Algebra.smul_def]⟩\n  let l := (IsLocalizedModule.liftOfLE _ _ hp' (LocalizedModule.mkLinearMap (.powers f) M)\n    (LocalizedModule.mkLinearMap p.asIdeal.primeCompl M)).extendScalarsOfIsLocalization (.powers f)\n    (Localization.Away f)\n  have : IsLocalization p' Rₚ :=\n    IsLocalization.isLocalization_of_submonoid_le (Localization.Away f) Rₚ _ _ hp'\n  have : IsLocalizedModule p.asIdeal.primeCompl (l.restrictScalars R) :=\n    inferInstanceAs (IsLocalizedModule p.asIdeal.primeCompl\n    ((IsLocalizedModule.liftOfLE _ _ hp' (LocalizedModule.mkLinearMap (.powers f) M)\n      (LocalizedModule.mkLinearMap p.asIdeal.primeCompl M))))\n  have : IsLocalizedModule (Algebra.algebraMapSubmonoid _ p.asIdeal.primeCompl) l :=\n      IsLocalizedModule.of_restrictScalars p.asIdeal.primeCompl ..\n  have := Module.finrank_of_isLocalizedModule_of_free Rₚ p' l\n  simp [Rₚ, rankAtStalk, this, hf'']\n\n"}
{"name":"Module.isLocallyConstant_rankAtStalk","module":"Mathlib.RingTheory.Spectrum.Prime.FreeLocus","initialProofState":"R : Type uR\nM : Type uM\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Module.FinitePresentation R M\ninst✝ : Module.Flat R M\n⊢ IsLocallyConstant (Module.rankAtStalk M)","decl":"lemma isLocallyConstant_rankAtStalk [Module.FinitePresentation R M] [Module.Flat R M] :\n    IsLocallyConstant (rankAtStalk (R := R) M) := by\n  let e : freeLocus R M ≃ₜ PrimeSpectrum R :=\n    (Homeomorph.setCongr freeLocus_eq_univ).trans (Homeomorph.Set.univ (PrimeSpectrum R))\n  convert isLocallyConstant_rankAtStalk_freeLocus.comp_continuous e.symm.continuous\n\n"}
