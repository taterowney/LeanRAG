{"name":"Quiver.Path.cons.injEq","module":"Mathlib.Combinatorics.Quiver.Path","initialProofState":"V : Type u\ninst✝ : Quiver V\na b✝ c : V\na✝³ : Quiver.Path a b✝\na✝² : Quiver.Hom b✝ c\nb : V\na✝¹ : Quiver.Path a b\na✝ : Quiver.Hom b c\n⊢ Eq (Eq (a✝³.cons a✝²) (a✝¹.cons a✝)) (And (Eq b✝ b) (And (HEq a✝³ a✝¹) (HEq a✝² a✝)))","decl":"/-- `Path a b` is the type of paths from `a` to `b` through the arrows of `G`. -/\ninductive Path {V : Type u} [Quiver.{v} V] (a : V) : V → Sort max (u + 1) v\n  | nil : Path a a\n  | cons : ∀ {b c : V}, Path a b → (b ⟶ c) → Path a c\n\n-- See issue https://github.com/leanprover/lean4/issues/2049\n"}
{"name":"Quiver.Path.cons.inj","module":"Mathlib.Combinatorics.Quiver.Path","initialProofState":"V : Type u\ninst✝ : Quiver V\na b✝ c : V\na✝³ : Quiver.Path a b✝\na✝² : Quiver.Hom b✝ c\nb : V\na✝¹ : Quiver.Path a b\na✝ : Quiver.Hom b c\nx✝ : Eq (a✝³.cons a✝²) (a✝¹.cons a✝)\n⊢ And (Eq b✝ b) (And (HEq a✝³ a✝¹) (HEq a✝² a✝))","decl":"/-- `Path a b` is the type of paths from `a` to `b` through the arrows of `G`. -/\ninductive Path {V : Type u} [Quiver.{v} V] (a : V) : V → Sort max (u + 1) v\n  | nil : Path a a\n  | cons : ∀ {b c : V}, Path a b → (b ⟶ c) → Path a c\n\n-- See issue https://github.com/leanprover/lean4/issues/2049\n"}
{"name":"Quiver.Path.cons.sizeOf_spec","module":"Mathlib.Combinatorics.Quiver.Path","initialProofState":"V : Type u\ninst✝¹ : Quiver V\na : V\ninst✝ : SizeOf V\nb c : V\na✝¹ : Quiver.Path a b\na✝ : Quiver.Hom b c\n⊢ Eq (SizeOf.sizeOf (a✝¹.cons a✝)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf b)) (SizeOf.sizeOf c)) (SizeOf.sizeOf a✝¹)) (SizeOf.sizeOf a✝))","decl":"/-- `Path a b` is the type of paths from `a` to `b` through the arrows of `G`. -/\ninductive Path {V : Type u} [Quiver.{v} V] (a : V) : V → Sort max (u + 1) v\n  | nil : Path a a\n  | cons : ∀ {b c : V}, Path a b → (b ⟶ c) → Path a c\n\n-- See issue https://github.com/leanprover/lean4/issues/2049\n"}
{"name":"Quiver.Path.nil.sizeOf_spec","module":"Mathlib.Combinatorics.Quiver.Path","initialProofState":"V : Type u\ninst✝¹ : Quiver V\na : V\ninst✝ : SizeOf V\n⊢ Eq (SizeOf.sizeOf Quiver.Path.nil) 1","decl":"/-- `Path a b` is the type of paths from `a` to `b` through the arrows of `G`. -/\ninductive Path {V : Type u} [Quiver.{v} V] (a : V) : V → Sort max (u + 1) v\n  | nil : Path a a\n  | cons : ∀ {b c : V}, Path a b → (b ⟶ c) → Path a c\n\n-- See issue https://github.com/leanprover/lean4/issues/2049\n"}
{"name":"Quiver.Path.nil_ne_cons","module":"Mathlib.Combinatorics.Quiver.Path","initialProofState":"V : Type u\ninst✝ : Quiver V\na b : V\np : Quiver.Path a b\ne : Quiver.Hom b a\n⊢ Ne Quiver.Path.nil (p.cons e)","decl":"lemma nil_ne_cons (p : Path a b) (e : b ⟶ a) : Path.nil ≠ p.cons e :=\n  fun h => by injection h\n\n"}
{"name":"Quiver.Path.cons_ne_nil","module":"Mathlib.Combinatorics.Quiver.Path","initialProofState":"V : Type u\ninst✝ : Quiver V\na b : V\np : Quiver.Path a b\ne : Quiver.Hom b a\n⊢ Ne (p.cons e) Quiver.Path.nil","decl":"lemma cons_ne_nil (p : Path a b) (e : b ⟶ a) : p.cons e ≠ Path.nil :=\n  fun h => by injection h\n\n"}
{"name":"Quiver.Path.obj_eq_of_cons_eq_cons","module":"Mathlib.Combinatorics.Quiver.Path","initialProofState":"V : Type u\ninst✝ : Quiver V\na b c d : V\np : Quiver.Path a b\np' : Quiver.Path a c\ne : Quiver.Hom b d\ne' : Quiver.Hom c d\nh : Eq (p.cons e) (p'.cons e')\n⊢ Eq b c","decl":"lemma obj_eq_of_cons_eq_cons {p : Path a b} {p' : Path a c}\n    {e : b ⟶ d} {e' : c ⟶ d} (h : p.cons e = p'.cons e') : b = c := by injection h\n\n"}
{"name":"Quiver.Path.heq_of_cons_eq_cons","module":"Mathlib.Combinatorics.Quiver.Path","initialProofState":"V : Type u\ninst✝ : Quiver V\na b c d : V\np : Quiver.Path a b\np' : Quiver.Path a c\ne : Quiver.Hom b d\ne' : Quiver.Hom c d\nh : Eq (p.cons e) (p'.cons e')\n⊢ HEq p p'","decl":"lemma heq_of_cons_eq_cons {p : Path a b} {p' : Path a c}\n    {e : b ⟶ d} {e' : c ⟶ d} (h : p.cons e = p'.cons e') : HEq p p' := by injection h\n\n"}
{"name":"Quiver.Path.hom_heq_of_cons_eq_cons","module":"Mathlib.Combinatorics.Quiver.Path","initialProofState":"V : Type u\ninst✝ : Quiver V\na b c d : V\np : Quiver.Path a b\np' : Quiver.Path a c\ne : Quiver.Hom b d\ne' : Quiver.Hom c d\nh : Eq (p.cons e) (p'.cons e')\n⊢ HEq e e'","decl":"lemma hom_heq_of_cons_eq_cons {p : Path a b} {p' : Path a c}\n    {e : b ⟶ d} {e' : c ⟶ d} (h : p.cons e = p'.cons e') : HEq e e' := by injection h\n\n"}
{"name":"Quiver.Path.length_nil","module":"Mathlib.Combinatorics.Quiver.Path","initialProofState":"V : Type u\ninst✝ : Quiver V\na : V\n⊢ Eq Quiver.Path.nil.length 0","decl":"@[simp]\ntheorem length_nil {a : V} : (nil : Path a a).length = 0 :=\n  rfl\n\n"}
{"name":"Quiver.Path.length_cons","module":"Mathlib.Combinatorics.Quiver.Path","initialProofState":"V : Type u\ninst✝ : Quiver V\na b c : V\np : Quiver.Path a b\ne : Quiver.Hom b c\n⊢ Eq (p.cons e).length (HAdd.hAdd p.length 1)","decl":"@[simp]\ntheorem length_cons (a b c : V) (p : Path a b) (e : b ⟶ c) : (p.cons e).length = p.length + 1 :=\n  rfl\n\n"}
{"name":"Quiver.Path.eq_of_length_zero","module":"Mathlib.Combinatorics.Quiver.Path","initialProofState":"V : Type u\ninst✝ : Quiver V\na b : V\np : Quiver.Path a b\nhzero : Eq p.length 0\n⊢ Eq a b","decl":"theorem eq_of_length_zero (p : Path a b) (hzero : p.length = 0) : a = b := by\n  cases p\n  · rfl\n  · cases Nat.succ_ne_zero _ hzero\n\n"}
{"name":"Quiver.Path.eq_nil_of_length_zero","module":"Mathlib.Combinatorics.Quiver.Path","initialProofState":"V : Type u\ninst✝ : Quiver V\na : V\np : Quiver.Path a a\nhzero : Eq p.length 0\n⊢ Eq p Quiver.Path.nil","decl":"theorem eq_nil_of_length_zero (p : Path a a) (hzero : p.length = 0) : p = nil := by\n  cases p\n  · rfl\n  · simp at hzero\n\n"}
{"name":"Quiver.Path.comp_cons","module":"Mathlib.Combinatorics.Quiver.Path","initialProofState":"V : Type u\ninst✝ : Quiver V\na b c d : V\np : Quiver.Path a b\nq : Quiver.Path b c\ne : Quiver.Hom c d\n⊢ Eq (p.comp (q.cons e)) ((p.comp q).cons e)","decl":"@[simp]\ntheorem comp_cons {a b c d : V} (p : Path a b) (q : Path b c) (e : c ⟶ d) :\n    p.comp (q.cons e) = (p.comp q).cons e :=\n  rfl\n\n"}
{"name":"Quiver.Path.comp_nil","module":"Mathlib.Combinatorics.Quiver.Path","initialProofState":"V : Type u\ninst✝ : Quiver V\na b : V\np : Quiver.Path a b\n⊢ Eq (p.comp Quiver.Path.nil) p","decl":"@[simp]\ntheorem comp_nil {a b : V} (p : Path a b) : p.comp Path.nil = p :=\n  rfl\n\n"}
{"name":"Quiver.Path.nil_comp","module":"Mathlib.Combinatorics.Quiver.Path","initialProofState":"V : Type u\ninst✝ : Quiver V\na b : V\np : Quiver.Path a b\n⊢ Eq (Quiver.Path.nil.comp p) p","decl":"@[simp]\ntheorem nil_comp {a : V} : ∀ {b} (p : Path a b), Path.nil.comp p = p\n  | _, nil => rfl\n  | _, cons p _ => by rw [comp_cons, nil_comp p]\n\n"}
{"name":"Quiver.Path.comp_assoc","module":"Mathlib.Combinatorics.Quiver.Path","initialProofState":"V : Type u\ninst✝ : Quiver V\na b c d : V\np : Quiver.Path a b\nq : Quiver.Path b c\nr : Quiver.Path c d\n⊢ Eq ((p.comp q).comp r) (p.comp (q.comp r))","decl":"@[simp]\ntheorem comp_assoc {a b c : V} :\n    ∀ {d} (p : Path a b) (q : Path b c) (r : Path c d), (p.comp q).comp r = p.comp (q.comp r)\n  | _, _, _, nil => rfl\n  | _, p, q, cons r _ => by rw [comp_cons, comp_cons, comp_cons, comp_assoc p q r]\n\n"}
{"name":"Quiver.Path.length_comp","module":"Mathlib.Combinatorics.Quiver.Path","initialProofState":"V : Type u\ninst✝ : Quiver V\na b : V\np : Quiver.Path a b\nc : V\nq : Quiver.Path b c\n⊢ Eq (p.comp q).length (HAdd.hAdd p.length q.length)","decl":"@[simp]\ntheorem length_comp (p : Path a b) : ∀ {c} (q : Path b c), (p.comp q).length = p.length + q.length\n  | _, nil => rfl\n  | _, cons _ _ => congr_arg Nat.succ (length_comp _ _)\n\n"}
{"name":"Quiver.Path.comp_inj","module":"Mathlib.Combinatorics.Quiver.Path","initialProofState":"V : Type u\ninst✝ : Quiver V\na b c : V\np₁ p₂ : Quiver.Path a b\nq₁ q₂ : Quiver.Path b c\nhq : Eq q₁.length q₂.length\n⊢ Iff (Eq (p₁.comp q₁) (p₂.comp q₂)) (And (Eq p₁ p₂) (Eq q₁ q₂))","decl":"theorem comp_inj {p₁ p₂ : Path a b} {q₁ q₂ : Path b c} (hq : q₁.length = q₂.length) :\n    p₁.comp q₁ = p₂.comp q₂ ↔ p₁ = p₂ ∧ q₁ = q₂ := by\n  refine ⟨fun h => ?_, by rintro ⟨rfl, rfl⟩; rfl⟩\n  induction q₁ with\n  | nil =>\n    rcases q₂ with _ | ⟨q₂, f₂⟩\n    · exact ⟨h, rfl⟩\n    · cases hq\n  | cons q₁ f₁ ih =>\n    rcases q₂ with _ | ⟨q₂, f₂⟩\n    · cases hq\n    · simp only [comp_cons, cons.injEq] at h\n      obtain rfl := h.1\n      obtain ⟨rfl, rfl⟩ := ih (Nat.succ.inj hq) h.2.1.eq\n      rw [h.2.2.eq]\n      exact ⟨rfl, rfl⟩\n\n"}
{"name":"Quiver.Path.comp_inj'","module":"Mathlib.Combinatorics.Quiver.Path","initialProofState":"V : Type u\ninst✝ : Quiver V\na b c : V\np₁ p₂ : Quiver.Path a b\nq₁ q₂ : Quiver.Path b c\nh : Eq p₁.length p₂.length\n⊢ Iff (Eq (p₁.comp q₁) (p₂.comp q₂)) (And (Eq p₁ p₂) (Eq q₁ q₂))","decl":"theorem comp_inj' {p₁ p₂ : Path a b} {q₁ q₂ : Path b c} (h : p₁.length = p₂.length) :\n    p₁.comp q₁ = p₂.comp q₂ ↔ p₁ = p₂ ∧ q₁ = q₂ :=\n  ⟨fun h_eq => (comp_inj <| Nat.add_left_cancel (n := p₂.length) <|\n    by simpa [h] using congr_arg length h_eq).1 h_eq,\n   by rintro ⟨rfl, rfl⟩; rfl⟩\n\n"}
{"name":"Quiver.Path.comp_injective_left","module":"Mathlib.Combinatorics.Quiver.Path","initialProofState":"V : Type u\ninst✝ : Quiver V\na b c : V\nq : Quiver.Path b c\n⊢ Function.Injective fun p => p.comp q","decl":"theorem comp_injective_left (q : Path b c) : Injective fun p : Path a b => p.comp q :=\n  fun _ _ h => ((comp_inj rfl).1 h).1\n\n"}
{"name":"Quiver.Path.comp_injective_right","module":"Mathlib.Combinatorics.Quiver.Path","initialProofState":"V : Type u\ninst✝ : Quiver V\na b c : V\np : Quiver.Path a b\n⊢ Function.Injective p.comp","decl":"theorem comp_injective_right (p : Path a b) : Injective (p.comp : Path b c → Path a c) :=\n  fun _ _ h => ((comp_inj' rfl).1 h).2\n\n"}
{"name":"Quiver.Path.comp_inj_left","module":"Mathlib.Combinatorics.Quiver.Path","initialProofState":"V : Type u\ninst✝ : Quiver V\na b c : V\np₁ p₂ : Quiver.Path a b\nq : Quiver.Path b c\n⊢ Iff (Eq (p₁.comp q) (p₂.comp q)) (Eq p₁ p₂)","decl":"@[simp]\ntheorem comp_inj_left {p₁ p₂ : Path a b} {q : Path b c} : p₁.comp q = p₂.comp q ↔ p₁ = p₂ :=\n  q.comp_injective_left.eq_iff\n\n"}
{"name":"Quiver.Path.comp_inj_right","module":"Mathlib.Combinatorics.Quiver.Path","initialProofState":"V : Type u\ninst✝ : Quiver V\na b c : V\np : Quiver.Path a b\nq₁ q₂ : Quiver.Path b c\n⊢ Iff (Eq (p.comp q₁) (p.comp q₂)) (Eq q₁ q₂)","decl":"@[simp]\ntheorem comp_inj_right {p : Path a b} {q₁ q₂ : Path b c} : p.comp q₁ = p.comp q₂ ↔ q₁ = q₂ :=\n  p.comp_injective_right.eq_iff\n\n"}
{"name":"Quiver.Path.eq_toPath_comp_of_length_eq_succ","module":"Mathlib.Combinatorics.Quiver.Path","initialProofState":"V : Type u\ninst✝ : Quiver V\na b : V\np : Quiver.Path a b\nn : Nat\nhp : Eq p.length (HAdd.hAdd n 1)\n⊢ Exists fun c => Exists fun f => Exists fun q => Exists fun x => Eq p (f.toPath.comp q)","decl":"lemma eq_toPath_comp_of_length_eq_succ (p : Path a b) {n : ℕ}\n    (hp : p.length = n + 1) :\n    ∃ (c : V) (f : a ⟶ c) (q : Quiver.Path c b) (_ : q.length = n),\n      p = f.toPath.comp q := by\n  induction p generalizing n with\n  | nil => simp at hp\n  | @cons c d p q h =>\n    cases n\n    · rw [length_cons, Nat.zero_add, Nat.add_left_eq_self] at hp\n      obtain rfl := eq_of_length_zero p hp\n      obtain rfl := eq_nil_of_length_zero p hp\n      exact ⟨d, q, nil, rfl, rfl⟩\n    · rw [length_cons, Nat.add_right_cancel_iff] at hp\n      obtain ⟨x, q'', p'', hl, rfl⟩ := h hp\n      exact ⟨x, q'', p''.cons q, by simpa, rfl⟩\n\n"}
{"name":"Quiver.Path.toList_comp","module":"Mathlib.Combinatorics.Quiver.Path","initialProofState":"V : Type u\ninst✝ : Quiver V\na b : V\np : Quiver.Path a b\nc : V\nq : Quiver.Path b c\n⊢ Eq (p.comp q).toList (HAppend.hAppend q.toList p.toList)","decl":"/-- `Quiver.Path.toList` is a contravariant functor. The inversion comes from `Quiver.Path` and\n`List` having different preferred directions for adding elements. -/\n@[simp]\ntheorem toList_comp (p : Path a b) : ∀ {c} (q : Path b c), (p.comp q).toList = q.toList ++ p.toList\n  | _, nil => by simp\n  | _, @cons _ _ _ d _ q _ => by simp [toList_comp]\n\n"}
{"name":"Quiver.Path.toList_chain_nonempty","module":"Mathlib.Combinatorics.Quiver.Path","initialProofState":"V : Type u\ninst✝ : Quiver V\na b : V\np : Quiver.Path a b\n⊢ List.Chain (fun x y => Nonempty (Quiver.Hom y x)) b p.toList","decl":"theorem toList_chain_nonempty :\n    ∀ {b} (p : Path a b), p.toList.Chain (fun x y => Nonempty (y ⟶ x)) b\n  | _, nil => List.Chain.nil\n  | _, cons p f => p.toList_chain_nonempty.cons ⟨f⟩\n\n"}
{"name":"Quiver.Path.toList_injective","module":"Mathlib.Combinatorics.Quiver.Path","initialProofState":"V : Type u\ninst✝¹ : Quiver V\ninst✝ : ∀ (a b : V), Subsingleton (Quiver.Hom a b)\na b : V\n⊢ Function.Injective Quiver.Path.toList","decl":"theorem toList_injective (a : V) : ∀ b, Injective (toList : Path a b → List V)\n  | _, nil, nil, _ => rfl\n  | _, nil, @cons _ _ _ c _ p f, h => by cases h\n  | _, @cons _ _ _ c _ p f, nil, h => by cases h\n  | _, @cons _ _ _ c _ p f, @cons _ _ _ t _ C D, h => by\n    simp only [toList, List.cons.injEq] at h\n    obtain ⟨rfl, hAC⟩ := h\n    simp [toList_injective _ _ hAC, eq_iff_true_of_subsingleton]\n\n"}
{"name":"Quiver.Path.toList_inj","module":"Mathlib.Combinatorics.Quiver.Path","initialProofState":"V : Type u\ninst✝¹ : Quiver V\na b : V\ninst✝ : ∀ (a b : V), Subsingleton (Quiver.Hom a b)\np q : Quiver.Path a b\n⊢ Iff (Eq p.toList q.toList) (Eq p q)","decl":"@[simp]\ntheorem toList_inj {p q : Path a b} : p.toList = q.toList ↔ p = q :=\n  (toList_injective _ _).eq_iff\n\n"}
{"name":"Prefunctor.mapPath_nil","module":"Mathlib.Combinatorics.Quiver.Path","initialProofState":"V : Type u₁\ninst✝¹ : Quiver V\nW : Type u₂\ninst✝ : Quiver W\nF : Prefunctor V W\na : V\n⊢ Eq (F.mapPath Quiver.Path.nil) Quiver.Path.nil","decl":"@[simp]\ntheorem mapPath_nil (a : V) : F.mapPath (Path.nil : Path a a) = Path.nil :=\n  rfl\n\n"}
{"name":"Prefunctor.mapPath_cons","module":"Mathlib.Combinatorics.Quiver.Path","initialProofState":"V : Type u₁\ninst✝¹ : Quiver V\nW : Type u₂\ninst✝ : Quiver W\nF : Prefunctor V W\na b c : V\np : Quiver.Path a b\ne : Quiver.Hom b c\n⊢ Eq (F.mapPath (p.cons e)) ((F.mapPath p).cons (F.map e))","decl":"@[simp]\ntheorem mapPath_cons {a b c : V} (p : Path a b) (e : b ⟶ c) :\n    F.mapPath (Path.cons p e) = Path.cons (F.mapPath p) (F.map e) :=\n  rfl\n\n"}
{"name":"Prefunctor.mapPath_comp","module":"Mathlib.Combinatorics.Quiver.Path","initialProofState":"V : Type u₁\ninst✝¹ : Quiver V\nW : Type u₂\ninst✝ : Quiver W\nF : Prefunctor V W\na b : V\np : Quiver.Path a b\nc : V\nq : Quiver.Path b c\n⊢ Eq (F.mapPath (p.comp q)) ((F.mapPath p).comp (F.mapPath q))","decl":"@[simp]\ntheorem mapPath_comp {a b : V} (p : Path a b) :\n    ∀ {c : V} (q : Path b c), F.mapPath (p.comp q) = (F.mapPath p).comp (F.mapPath q)\n  | _, Path.nil => rfl\n  | c, Path.cons q e => by dsimp; rw [mapPath_comp p q]\n\n"}
{"name":"Prefunctor.mapPath_toPath","module":"Mathlib.Combinatorics.Quiver.Path","initialProofState":"V : Type u₁\ninst✝¹ : Quiver V\nW : Type u₂\ninst✝ : Quiver W\nF : Prefunctor V W\na b : V\nf : Quiver.Hom a b\n⊢ Eq (F.mapPath f.toPath) (F.map f).toPath","decl":"@[simp]\ntheorem mapPath_toPath {a b : V} (f : a ⟶ b) : F.mapPath f.toPath = (F.map f).toPath :=\n  rfl\n\n"}
