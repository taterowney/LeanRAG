{"name":"Ideal.basisSpanSingleton_apply","module":"Mathlib.RingTheory.Ideal.Basis","initialProofState":"ι : Type u_1\nR : Type u_2\nS : Type u_3\ninst✝³ : CommSemiring R\ninst✝² : CommRing S\ninst✝¹ : IsDomain S\ninst✝ : Algebra R S\nb : Basis ι R S\nx : S\nhx : Ne x 0\ni : ι\n⊢ Eq (↑((Ideal.basisSpanSingleton b hx) i)) (HMul.hMul x (b i))","decl":"@[simp]\ntheorem basisSpanSingleton_apply (b : Basis ι R S) {x : S} (hx : x ≠ 0) (i : ι) :\n    (basisSpanSingleton b hx i : S) = x * b i := by\n  simp only [basisSpanSingleton, Basis.map_apply, LinearEquiv.trans_apply,\n    Submodule.restrictScalarsEquiv_apply, LinearEquiv.ofInjective_apply, LinearEquiv.coe_ofEq_apply,\n    LinearEquiv.restrictScalars_apply, LinearMap.mulLeft_apply, LinearMap.mul_apply']\n\n"}
{"name":"Ideal.constr_basisSpanSingleton","module":"Mathlib.RingTheory.Ideal.Basis","initialProofState":"ι : Type u_1\nR : Type u_2\nS : Type u_3\ninst✝⁶ : CommSemiring R\ninst✝⁵ : CommRing S\ninst✝⁴ : IsDomain S\ninst✝³ : Algebra R S\nN : Type u_4\ninst✝² : Semiring N\ninst✝¹ : Module N S\ninst✝ : SMulCommClass R N S\nb : Basis ι R S\nx : S\nhx : Ne x 0\n⊢ Eq ((↑(b.constr N)).toFun (Function.comp Subtype.val ⇑(Ideal.basisSpanSingleton b hx))) ((Algebra.lmul R S) x)","decl":"@[simp]\ntheorem constr_basisSpanSingleton {N : Type*} [Semiring N] [Module N S] [SMulCommClass R N S]\n    (b : Basis ι R S) {x : S} (hx : x ≠ 0) :\n    (b.constr N).toFun (((↑) : _ → S) ∘ (basisSpanSingleton b hx)) = Algebra.lmul R S x :=\n  b.ext fun i => by simp\n\n"}
{"name":"Basis.mem_ideal_iff","module":"Mathlib.RingTheory.Ideal.Basis","initialProofState":"ι : Type u_1\nR : Type u_2\nS : Type u_3\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nI : Ideal S\nb : Basis ι R (Subtype fun x => Membership.mem I x)\nx : S\n⊢ Iff (Membership.mem I x) (Exists fun c => Eq x (c.sum fun i x => HSMul.hSMul x ↑(b i)))","decl":"/-- If `I : Ideal S` has a basis over `R`,\n`x ∈ I` iff it is a linear combination of basis vectors. -/\ntheorem Basis.mem_ideal_iff {ι R S : Type*} [CommRing R] [CommRing S] [Algebra R S] {I : Ideal S}\n    (b : Basis ι R I) {x : S} : x ∈ I ↔ ∃ c : ι →₀ R, x = Finsupp.sum c fun i x => x • (b i : S) :=\n  (b.map ((I.restrictScalarsEquiv R _ _).restrictScalars R).symm).mem_submodule_iff\n\n"}
{"name":"Basis.mem_ideal_iff'","module":"Mathlib.RingTheory.Ideal.Basis","initialProofState":"ι : Type u_1\nR : Type u_2\nS : Type u_3\ninst✝³ : Fintype ι\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nI : Ideal S\nb : Basis ι R (Subtype fun x => Membership.mem I x)\nx : S\n⊢ Iff (Membership.mem I x) (Exists fun c => Eq x (Finset.univ.sum fun i => HSMul.hSMul (c i) ↑(b i)))","decl":"/-- If `I : Ideal S` has a finite basis over `R`,\n`x ∈ I` iff it is a linear combination of basis vectors. -/\ntheorem Basis.mem_ideal_iff' {ι R S : Type*} [Fintype ι] [CommRing R] [CommRing S] [Algebra R S]\n    {I : Ideal S} (b : Basis ι R I) {x : S} : x ∈ I ↔ ∃ c : ι → R, x = ∑ i, c i • (b i : S) :=\n  (b.map ((I.restrictScalarsEquiv R _ _).restrictScalars R).symm).mem_submodule_iff'\n"}
