{"name":"finite_compl_fixedBy_closure_iff","module":"Mathlib.GroupTheory.Perm.ClosureSwap","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : Group G\ninst✝ : MulAction G α\nS : Set G\n⊢ Iff (∀ (g : G), Membership.mem (Subgroup.closure S) g → (HasCompl.compl (MulAction.fixedBy α g)).Finite) (∀ (g : G), Membership.mem S g → (HasCompl.compl (MulAction.fixedBy α g)).Finite)","decl":"/-- If the support of each element in a generating set of a permutation group is finite,\nthen the support of every element in the group is finite. -/\ntheorem finite_compl_fixedBy_closure_iff {S : Set G} :\n    (∀ g ∈ closure S, (fixedBy α g)ᶜ.Finite) ↔ ∀ g ∈ S, (fixedBy α g)ᶜ.Finite :=\n  ⟨fun h g hg ↦ h g (subset_closure hg), fun h g hg ↦ by\n    refine closure_induction h (by simp) (fun g g' _ _ hg hg' ↦ (hg.union hg').subset ?_)\n      (by simp) hg\n    simp_rw [← compl_inter, compl_subset_compl, fixedBy_mul]⟩\n\n"}
{"name":"exists_smul_not_mem_of_subset_orbit_closure","module":"Mathlib.GroupTheory.Perm.ClosureSwap","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : Group G\ninst✝ : MulAction G α\nS : Set G\nT : Set α\na : α\nhS : ∀ (g : G), Membership.mem S g → Membership.mem S (Inv.inv g)\nsubset : HasSubset.Subset T (MulAction.orbit (Subtype fun x => Membership.mem (Subgroup.closure S) x) a)\nnot_mem : Not (Membership.mem T a)\nnonempty : T.Nonempty\n⊢ Exists fun σ => And (Membership.mem S σ) (Exists fun a => And (Membership.mem T a) (Not (Membership.mem T (HSMul.hSMul σ a))))","decl":"/-- Given a symmetric generating set of a permutation group, if T is a nonempty proper subset of\nan orbit, then there exists a generator that sends some element of T into the complement of T. -/\ntheorem exists_smul_not_mem_of_subset_orbit_closure (S : Set G) (T : Set α) {a : α}\n    (hS : ∀ g ∈ S, g⁻¹ ∈ S) (subset : T ⊆ orbit (closure S) a) (not_mem : a ∉ T)\n    (nonempty : T.Nonempty) : ∃ σ ∈ S, ∃ a ∈ T, σ • a ∉ T := by\n  have key0 : ¬ closure S ≤ stabilizer G T := by\n    have ⟨b, hb⟩ := nonempty\n    obtain ⟨σ, rfl⟩ := subset hb\n    contrapose! not_mem with h\n    exact smul_mem_smul_set_iff.mp ((h σ.2).symm ▸ hb)\n  contrapose! key0\n  refine (closure_le _).mpr fun σ hσ ↦ ?_\n  simp_rw [SetLike.mem_coe, mem_stabilizer_iff, Set.ext_iff, mem_smul_set_iff_inv_smul_mem]\n  exact fun a ↦ ⟨fun h ↦ smul_inv_smul σ a ▸ key0 σ hσ (σ⁻¹ • a) h, key0 σ⁻¹ (hS σ hσ) a⟩\n\n"}
{"name":"finite_compl_fixedBy_swap","module":"Mathlib.GroupTheory.Perm.ClosureSwap","initialProofState":"α : Type u_2\ninst✝ : DecidableEq α\nx y : α\n⊢ (HasCompl.compl (MulAction.fixedBy α (Equiv.swap x y))).Finite","decl":"theorem finite_compl_fixedBy_swap {x y : α} : (fixedBy α (swap x y))ᶜ.Finite :=\n  Set.Finite.subset (s := {x, y}) (by simp)\n    (compl_subset_comm.mp fun z h ↦ by apply swap_apply_of_ne_of_ne <;> rintro rfl <;> simp at h)\n\n"}
{"name":"Equiv.Perm.IsSwap.finite_compl_fixedBy","module":"Mathlib.GroupTheory.Perm.ClosureSwap","initialProofState":"α : Type u_2\ninst✝ : DecidableEq α\nσ : Equiv.Perm α\nh : σ.IsSwap\n⊢ (HasCompl.compl (MulAction.fixedBy α σ)).Finite","decl":"theorem Equiv.Perm.IsSwap.finite_compl_fixedBy {σ : Perm α} (h : σ.IsSwap) :\n    (fixedBy α σ)ᶜ.Finite := by\n  obtain ⟨x, y, -, rfl⟩ := h\n  exact finite_compl_fixedBy_swap\n\n-- this result cannot be moved to Perm/Basic since Perm/Basic is not allowed to import Submonoid\n"}
{"name":"SubmonoidClass.swap_mem_trans","module":"Mathlib.GroupTheory.Perm.ClosureSwap","initialProofState":"α : Type u_2\ninst✝² : DecidableEq α\na b c : α\nC : Type u_3\ninst✝¹ : SetLike C (Equiv.Perm α)\ninst✝ : SubmonoidClass C (Equiv.Perm α)\nM : C\nhab : Membership.mem M (Equiv.swap a b)\nhbc : Membership.mem M (Equiv.swap b c)\n⊢ Membership.mem M (Equiv.swap a c)","decl":"theorem SubmonoidClass.swap_mem_trans {a b c : α} {C} [SetLike C (Perm α)]\n    [SubmonoidClass C (Perm α)] (M : C) (hab : swap a b ∈ M) (hbc : swap b c ∈ M) :\n    swap a c ∈ M := by\n  obtain rfl | hab' := eq_or_ne a b\n  · exact hbc\n  obtain rfl | hac := eq_or_ne a c\n  · exact swap_self a ▸ one_mem M\n  rw [swap_comm, ← swap_mul_swap_mul_swap hab' hac]\n  exact mul_mem (mul_mem hbc hab) hbc\n\n"}
{"name":"swap_mem_closure_isSwap","module":"Mathlib.GroupTheory.Perm.ClosureSwap","initialProofState":"α : Type u_2\ninst✝ : DecidableEq α\nS : Set (Equiv.Perm α)\nhS : ∀ (f : Equiv.Perm α), Membership.mem S f → f.IsSwap\nx y : α\n⊢ Iff (Membership.mem (Subgroup.closure S) (Equiv.swap x y)) (Membership.mem (MulAction.orbit (Subtype fun x => Membership.mem (Subgroup.closure S) x) y) x)","decl":"/-- If a subgroup is generated by transpositions, then a transposition `swap x y` lies in the\n  subgroup if and only if `x` lies in the same orbit as `y`. -/\ntheorem swap_mem_closure_isSwap {S : Set (Perm α)} (hS : ∀ f ∈ S, f.IsSwap) {x y : α} :\n    swap x y ∈ closure S ↔ x ∈ orbit (closure S) y := by\n  refine ⟨fun h ↦ ⟨⟨swap x y, h⟩, swap_apply_right x y⟩, fun hf ↦ ?_⟩\n  by_contra h\n  have := exists_smul_not_mem_of_subset_orbit_closure S {x | swap x y ∈ closure S}\n    (fun f hf ↦ ?_) (fun z hz ↦ ?_) h ⟨y, ?_⟩\n  · obtain ⟨σ, hσ, a, ha, hσa⟩ := this\n    obtain ⟨z, w, hzw, rfl⟩ := hS σ hσ\n    have := ne_of_mem_of_not_mem ha hσa\n    rw [Perm.smul_def, ne_comm, swap_apply_ne_self_iff, and_iff_right hzw] at this\n    refine hσa (SubmonoidClass.swap_mem_trans (closure S) ?_ ha)\n    obtain rfl | rfl := this <;> simpa [swap_comm] using subset_closure hσ\n  · obtain ⟨x, y, -, rfl⟩ := hS f hf; rwa [swap_inv]\n  · exact orbit_eq_iff.mpr hf ▸ ⟨⟨swap z y, hz⟩, swap_apply_right z y⟩\n  · rw [mem_setOf, swap_self]; apply one_mem\n\n"}
{"name":"mem_closure_isSwap","module":"Mathlib.GroupTheory.Perm.ClosureSwap","initialProofState":"α : Type u_2\ninst✝ : DecidableEq α\nS : Set (Equiv.Perm α)\nhS : ∀ (f : Equiv.Perm α), Membership.mem S f → f.IsSwap\nf : Equiv.Perm α\n⊢ Iff (Membership.mem (Subgroup.closure S) f) (And (HasCompl.compl (MulAction.fixedBy α f)).Finite (∀ (x : α), Membership.mem (MulAction.orbit (Subtype fun x => Membership.mem (Subgroup.closure S) x) x) (f x)))","decl":"/-- If a subgroup is generated by transpositions, then a permutation `f` lies in the subgroup if\n  and only if `f` has finite support and `f x` always lies in the same orbit as `x`. -/\ntheorem mem_closure_isSwap {S : Set (Perm α)} (hS : ∀ f ∈ S, f.IsSwap) {f : Perm α} :\n    f ∈ closure S ↔ (fixedBy α f)ᶜ.Finite ∧ ∀ x, f x ∈ orbit (closure S) x := by\n  refine ⟨fun hf ↦ ⟨?_, fun x ↦ mem_orbit_iff.mpr ⟨⟨f, hf⟩, rfl⟩⟩, ?_⟩\n  · exact finite_compl_fixedBy_closure_iff.mpr (fun f hf ↦ (hS f hf).finite_compl_fixedBy) _ hf\n  rintro ⟨fin, hf⟩\n  set supp := (fixedBy α f)ᶜ with supp_eq\n  suffices h : (fixedBy α f)ᶜ ⊆ supp → f ∈ closure S from h supp_eq.symm.subset\n  clear_value supp; clear supp_eq; revert f\n  apply fin.induction_on ..\n  · rintro f - emp; convert (closure S).one_mem; ext; by_contra h; exact emp h\n  rintro a s - - ih f hf supp_subset\n  refine (mul_mem_cancel_left ((swap_mem_closure_isSwap hS).2 (hf a))).1\n    (ih (fun b ↦ ?_) fun b hb ↦ ?_)\n  · rw [Perm.mul_apply, swap_apply_def]; split_ifs with h1 h2\n    · rw [← orbit_eq_iff.mpr (hf b), h1, orbit_eq_iff.mpr (hf a)]; apply mem_orbit_self\n    · rw [← orbit_eq_iff.mpr (hf b), h2]; apply hf\n    · exact hf b\n  · contrapose! hb\n    simp_rw [not_mem_compl_iff, mem_fixedBy, Perm.smul_def, Perm.mul_apply, swap_apply_def,\n      apply_eq_iff_eq]\n    by_cases hb' : f b = b\n    · rw [hb']; split_ifs with h <;> simp only [h]\n    simp [show b = a by simpa [hb] using supp_subset hb']\n\n"}
{"name":"mem_closure_isSwap'","module":"Mathlib.GroupTheory.Perm.ClosureSwap","initialProofState":"α : Type u_2\ninst✝ : DecidableEq α\nf : Equiv.Perm α\n⊢ Iff (Membership.mem (Subgroup.closure (setOf fun σ => σ.IsSwap)) f) (HasCompl.compl (MulAction.fixedBy α f)).Finite","decl":"/-- A permutation is a product of transpositions if and only if it has finite support. -/\ntheorem mem_closure_isSwap' {f : Perm α} :\n    f ∈ closure {σ : Perm α | σ.IsSwap} ↔ (fixedBy α f)ᶜ.Finite := by\n  refine (mem_closure_isSwap fun _ ↦ id).trans\n    (and_iff_left fun x ↦ ⟨⟨swap x (f x), ?_⟩, swap_apply_left x (f x)⟩)\n  by_cases h : x = f x\n  · rw [← h, swap_self]\n    apply Subgroup.one_mem\n  · exact subset_closure ⟨x, f x, h, rfl⟩\n\n"}
{"name":"closure_of_isSwap_of_isPretransitive","module":"Mathlib.GroupTheory.Perm.ClosureSwap","initialProofState":"α : Type u_2\ninst✝² : DecidableEq α\ninst✝¹ : Finite α\nS : Set (Equiv.Perm α)\nhS : ∀ (σ : Equiv.Perm α), Membership.mem S σ → σ.IsSwap\ninst✝ : MulAction.IsPretransitive (Subtype fun x => Membership.mem (Subgroup.closure S) x) α\n⊢ Eq (Subgroup.closure S) Top.top","decl":"/-- A transitive permutation group generated by transpositions must be the whole symmetric group -/\ntheorem closure_of_isSwap_of_isPretransitive [Finite α] {S : Set (Perm α)} (hS : ∀ σ ∈ S, σ.IsSwap)\n    [MulAction.IsPretransitive (Subgroup.closure S) α] : Subgroup.closure S = ⊤ := by\n  simp [eq_top_iff', mem_closure_isSwap hS, orbit_eq_univ, Set.toFinite]\n\n"}
{"name":"surjective_of_isSwap_of_isPretransitive","module":"Mathlib.GroupTheory.Perm.ClosureSwap","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝³ : Group G\ninst✝² : MulAction G α\ninst✝¹ : DecidableEq α\ninst✝ : Finite α\nS : Set G\nhS1 : ∀ (σ : G), Membership.mem S σ → ((MulAction.toPermHom G α) σ).IsSwap\nhS2 : Eq (Subgroup.closure S) Top.top\nh : MulAction.IsPretransitive G α\n⊢ Function.Surjective ⇑(MulAction.toPermHom G α)","decl":"/-- A transitive permutation group generated by transpositions must be the whole symmetric group -/\ntheorem surjective_of_isSwap_of_isPretransitive [Finite α] (S : Set G)\n    (hS1 : ∀ σ ∈ S, Perm.IsSwap (MulAction.toPermHom G α σ)) (hS2 : Subgroup.closure S = ⊤)\n    [h : MulAction.IsPretransitive G α] : Function.Surjective (MulAction.toPermHom G α) := by\n  rw [← MonoidHom.range_eq_top]\n  have := MulAction.IsPretransitive.of_compHom (α := α) (MulAction.toPermHom G α).rangeRestrict\n  rw [MonoidHom.range_eq_map, ← hS2, MonoidHom.map_closure] at this ⊢\n  exact closure_of_isSwap_of_isPretransitive (Set.forall_mem_image.2 hS1)\n"}
