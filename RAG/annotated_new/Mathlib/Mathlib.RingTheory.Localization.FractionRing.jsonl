{"name":"instIsFractionRing","module":"Mathlib.RingTheory.Localization.FractionRing","initialProofState":"R : Type u_6\ninst✝ : Field R\n⊢ IsFractionRing R R","decl":"instance {R : Type*} [Field R] : IsFractionRing R R :=\n  IsLocalization.at_units _ (fun _ ↦ isUnit_of_mem_nonZeroDivisors)\n\n"}
{"name":"Rat.isFractionRing","module":"Mathlib.RingTheory.Localization.FractionRing","initialProofState":"⊢ IsFractionRing Int Rat","decl":"/-- The cast from `Int` to `Rat` as a `FractionRing`. -/\ninstance Rat.isFractionRing : IsFractionRing ℤ ℚ where\n  map_units' := by\n    rintro ⟨x, hx⟩\n    rw [mem_nonZeroDivisors_iff_ne_zero] at hx\n    simpa only [eq_intCast, isUnit_iff_ne_zero, Int.cast_eq_zero, Ne, Subtype.coe_mk] using hx\n  surj' := by\n    rintro ⟨n, d, hd, h⟩\n    refine ⟨⟨n, ⟨d, ?_⟩⟩, Rat.mul_den_eq_num _⟩\n    rw [mem_nonZeroDivisors_iff_ne_zero, Int.natCast_ne_zero_iff_pos]\n    exact Nat.zero_lt_of_ne_zero hd\n  exists_of_eq {x y} := by\n    rw [eq_intCast, eq_intCast, Int.cast_inj]\n    rintro rfl\n    use 1\n\n"}
{"name":"IsFractionRing.to_map_eq_zero_iff","module":"Mathlib.RingTheory.Localization.FractionRing","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nK : Type u_5\ninst✝² : CommRing K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nx : R\n⊢ Iff (Eq ((algebraMap R K) x) 0) (Eq x 0)","decl":"theorem to_map_eq_zero_iff {x : R} : algebraMap R K x = 0 ↔ x = 0 :=\n  IsLocalization.to_map_eq_zero_iff _ le_rfl\n\n"}
{"name":"IsFractionRing.injective","module":"Mathlib.RingTheory.Localization.FractionRing","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nK : Type u_5\ninst✝² : CommRing K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\n⊢ Function.Injective ⇑(algebraMap R K)","decl":"protected theorem injective : Function.Injective (algebraMap R K) :=\n  IsLocalization.injective _ (le_of_eq rfl)\n\n"}
{"name":"IsFractionRing.coe_inj","module":"Mathlib.RingTheory.Localization.FractionRing","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nK : Type u_5\ninst✝² : CommRing K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\na b : R\n⊢ Iff (Eq ↑a ↑b) (Eq a b)","decl":"@[norm_cast, simp]\n-- Porting note: using `↑` didn't work, so I needed to explicitly put in the cast myself\ntheorem coe_inj {a b : R} : (Algebra.cast a : K) = Algebra.cast b ↔ a = b :=\n  (IsFractionRing.injective R K).eq_iff\n\n"}
{"name":"IsFractionRing.instNoZeroSMulDivisorsOfNoZeroDivisors","module":"Mathlib.RingTheory.Localization.FractionRing","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nK : Type u_5\ninst✝³ : CommRing K\ninst✝² : Algebra R K\ninst✝¹ : IsFractionRing R K\ninst✝ : NoZeroDivisors K\n⊢ NoZeroSMulDivisors R K","decl":"instance (priority := 100) [NoZeroDivisors K] : NoZeroSMulDivisors R K :=\n  NoZeroSMulDivisors.of_algebraMap_injective <| IsFractionRing.injective R K\n\n"}
{"name":"IsFractionRing.to_map_ne_zero_of_mem_nonZeroDivisors","module":"Mathlib.RingTheory.Localization.FractionRing","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nK : Type u_5\ninst✝³ : CommRing K\ninst✝² : Algebra R K\ninst✝¹ : IsFractionRing R K\ninst✝ : Nontrivial R\nx : R\nhx : Membership.mem (nonZeroDivisors R) x\n⊢ Ne ((algebraMap R K) x) 0","decl":"protected theorem to_map_ne_zero_of_mem_nonZeroDivisors [Nontrivial R] {x : R}\n    (hx : x ∈ nonZeroDivisors R) : algebraMap R K x ≠ 0 :=\n  IsLocalization.to_map_ne_zero_of_mem_nonZeroDivisors _ le_rfl hx\n\n"}
{"name":"IsFractionRing.isDomain","module":"Mathlib.RingTheory.Localization.FractionRing","initialProofState":"A : Type u_4\ninst✝⁴ : CommRing A\nK : Type u_5\ninst✝³ : CommRing K\ninst✝² : Algebra A K\ninst✝¹ : IsFractionRing A K\ninst✝ : IsDomain A\n⊢ IsDomain K","decl":"include A in\n/-- A `CommRing` `K` which is the localization of an integral domain `R` at `R - {0}` is an\nintegral domain. -/\nprotected theorem isDomain : IsDomain K :=\n  isDomain_of_le_nonZeroDivisors _ (le_refl (nonZeroDivisors A))\n\n"}
{"name":"IsFractionRing.inv_def","module":"Mathlib.RingTheory.Localization.FractionRing","initialProofState":"A : Type u_6\ninst✝⁴ : CommRing A\nK : Type u_7\ninst✝³ : CommRing K\ninst✝² : Algebra A K\ninst✝¹ : IsFractionRing A K\ninst✝ : IsDomain A\nz : K\n⊢ Eq (IsFractionRing.inv A z) (dite (Eq z 0) (fun h => 0) fun h => IsLocalization.mk' K ↑(IsLocalization.sec (nonZeroDivisors A) z).2 ⟨(IsLocalization.sec (nonZeroDivisors A) z).1, ⋯⟩)","decl":"/-- The inverse of an element in the field of fractions of an integral domain. -/\nprotected noncomputable irreducible_def inv (z : K) : K := open scoped Classical in\n  if h : z = 0 then 0\n  else\n    mk' K ↑(sec (nonZeroDivisors A) z).2\n      ⟨(sec _ z).1,\n        mem_nonZeroDivisors_iff_ne_zero.2 fun h0 =>\n          h <| eq_zero_of_fst_eq_zero (sec_spec (nonZeroDivisors A) z) h0⟩\n\n"}
{"name":"IsFractionRing.mul_inv_cancel","module":"Mathlib.RingTheory.Localization.FractionRing","initialProofState":"A : Type u_4\ninst✝⁴ : CommRing A\nK : Type u_5\ninst✝³ : CommRing K\ninst✝² : Algebra A K\ninst✝¹ : IsFractionRing A K\ninst✝ : IsDomain A\nx : K\nhx : Ne x 0\n⊢ Eq (HMul.hMul x (IsFractionRing.inv A x)) 1","decl":"protected theorem mul_inv_cancel (x : K) (hx : x ≠ 0) : x * IsFractionRing.inv A x = 1 := by\n  rw [IsFractionRing.inv, dif_neg hx, ←\n    IsUnit.mul_left_inj\n      (map_units K\n        ⟨(sec _ x).1,\n          mem_nonZeroDivisors_iff_ne_zero.2 fun h0 =>\n            hx <| eq_zero_of_fst_eq_zero (sec_spec (nonZeroDivisors A) x) h0⟩),\n    one_mul, mul_assoc]\n  rw [mk'_spec, ← eq_mk'_iff_mul_eq]\n  exact (mk'_sec _ x).symm\n\n"}
{"name":"IsFractionRing.surjective_iff_isField","module":"Mathlib.RingTheory.Localization.FractionRing","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nK : Type u_5\ninst✝³ : CommRing K\ninst✝² : Algebra R K\ninst✝¹ : IsFractionRing R K\ninst✝ : IsDomain R\n⊢ Iff (Function.Surjective ⇑(algebraMap R K)) (IsField R)","decl":"lemma surjective_iff_isField [IsDomain R] : Function.Surjective (algebraMap R K) ↔ IsField R where\n  mp h := (RingEquiv.ofBijective (algebraMap R K)\n      ⟨IsFractionRing.injective R K, h⟩).toMulEquiv.isField _ (IsFractionRing.toField R).toIsField\n  mpr h :=\n    letI := h.toField\n    (IsLocalization.atUnits R _ (S := K)\n      (fun _ hx ↦ Ne.isUnit (mem_nonZeroDivisors_iff_ne_zero.mp hx))).surjective\n\n"}
{"name":"IsFractionRing.mk'_mk_eq_div","module":"Mathlib.RingTheory.Localization.FractionRing","initialProofState":"A : Type u_4\ninst✝³ : CommRing A\nK : Type u_5\ninst✝² : Field K\ninst✝¹ : Algebra A K\ninst✝ : IsFractionRing A K\nr s : A\nhs : Membership.mem (nonZeroDivisors A) s\n⊢ Eq (IsLocalization.mk' K r ⟨s, hs⟩) (HDiv.hDiv ((algebraMap A K) r) ((algebraMap A K) s))","decl":"theorem mk'_mk_eq_div {r s} (hs : s ∈ nonZeroDivisors A) :\n    mk' K r ⟨s, hs⟩ = algebraMap A K r / algebraMap A K s :=\n  haveI := (algebraMap A K).domain_nontrivial\n  mk'_eq_iff_eq_mul.2 <|\n    (div_mul_cancel₀ (algebraMap A K r)\n        (IsFractionRing.to_map_ne_zero_of_mem_nonZeroDivisors hs)).symm\n\n"}
{"name":"IsFractionRing.mk'_eq_div","module":"Mathlib.RingTheory.Localization.FractionRing","initialProofState":"A : Type u_4\ninst✝³ : CommRing A\nK : Type u_5\ninst✝² : Field K\ninst✝¹ : Algebra A K\ninst✝ : IsFractionRing A K\nr : A\ns : Subtype fun x => Membership.mem (nonZeroDivisors A) x\n⊢ Eq (IsLocalization.mk' K r s) (HDiv.hDiv ((algebraMap A K) r) ((algebraMap A K) ↑s))","decl":"@[simp]\ntheorem mk'_eq_div {r} (s : nonZeroDivisors A) : mk' K r s = algebraMap A K r / algebraMap A K s :=\n  mk'_mk_eq_div s.2\n\n"}
{"name":"IsFractionRing.div_surjective","module":"Mathlib.RingTheory.Localization.FractionRing","initialProofState":"A : Type u_4\ninst✝³ : CommRing A\nK : Type u_5\ninst✝² : Field K\ninst✝¹ : Algebra A K\ninst✝ : IsFractionRing A K\nz : K\n⊢ Exists fun x => Exists fun y => And (Membership.mem (nonZeroDivisors A) y) (Eq (HDiv.hDiv ((algebraMap A K) x) ((algebraMap A K) y)) z)","decl":"theorem div_surjective (z : K) :\n    ∃ x y : A, y ∈ nonZeroDivisors A ∧ algebraMap _ _ x / algebraMap _ _ y = z :=\n  let ⟨x, ⟨y, hy⟩, h⟩ := mk'_surjective (nonZeroDivisors A) z\n  ⟨x, y, hy, by rwa [mk'_eq_div] at h⟩\n\n"}
{"name":"IsFractionRing.isUnit_map_of_injective","module":"Mathlib.RingTheory.Localization.FractionRing","initialProofState":"A : Type u_4\ninst✝¹ : CommRing A\nL : Type u_7\ninst✝ : Field L\ng : RingHom A L\nhg : Function.Injective ⇑g\ny : Subtype fun x => Membership.mem (nonZeroDivisors A) x\n⊢ IsUnit (g ↑y)","decl":"theorem isUnit_map_of_injective (hg : Function.Injective g) (y : nonZeroDivisors A) :\n    IsUnit (g y) :=\n  haveI := g.domain_nontrivial\n  IsUnit.mk0 (g y) <|\n    show g.toMonoidWithZeroHom y ≠ 0 from map_ne_zero_of_mem_nonZeroDivisors g hg y.2\n\n"}
{"name":"IsFractionRing.mk'_eq_zero_iff_eq_zero","module":"Mathlib.RingTheory.Localization.FractionRing","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nK : Type u_5\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nx : R\ny : Subtype fun x => Membership.mem (nonZeroDivisors R) x\n⊢ Iff (Eq (IsLocalization.mk' K x y) 0) (Eq x 0)","decl":"theorem mk'_eq_zero_iff_eq_zero [Algebra R K] [IsFractionRing R K] {x : R} {y : nonZeroDivisors R} :\n    mk' K x y = 0 ↔ x = 0 := by\n  haveI := (algebraMap R K).domain_nontrivial\n  simp [nonZeroDivisors.ne_zero]\n\n"}
{"name":"IsFractionRing.mk'_eq_one_iff_eq","module":"Mathlib.RingTheory.Localization.FractionRing","initialProofState":"A : Type u_4\ninst✝³ : CommRing A\nK : Type u_5\ninst✝² : Field K\ninst✝¹ : Algebra A K\ninst✝ : IsFractionRing A K\nx : A\ny : Subtype fun x => Membership.mem (nonZeroDivisors A) x\n⊢ Iff (Eq (IsLocalization.mk' K x y) 1) (Eq x ↑y)","decl":"theorem mk'_eq_one_iff_eq {x : A} {y : nonZeroDivisors A} : mk' K x y = 1 ↔ x = y := by\n  haveI := (algebraMap A K).domain_nontrivial\n  refine ⟨?_, fun hxy => by rw [hxy, mk'_self']⟩\n  intro hxy\n  have hy : (algebraMap A K) ↑y ≠ (0 : K) :=\n    IsFractionRing.to_map_ne_zero_of_mem_nonZeroDivisors y.property\n  rw [IsFractionRing.mk'_eq_div, div_eq_one_iff_eq hy] at hxy\n  exact IsFractionRing.injective A K hxy\n\n"}
{"name":"IsFractionRing.closure_range_algebraMap","module":"Mathlib.RingTheory.Localization.FractionRing","initialProofState":"A : Type u_4\ninst✝³ : CommRing A\nK : Type u_5\ninst✝² : Field K\ninst✝¹ : Algebra A K\ninst✝ : IsFractionRing A K\n⊢ Eq (Subfield.closure (Set.range ⇑(algebraMap A K))) Top.top","decl":"variable (A K) in\n/-- If `A` is a commutative ring with fraction field `K`, then the subfield of `K` generated by\nthe image of `algebraMap A K` is equal to the whole field `K`. -/\ntheorem closure_range_algebraMap : Subfield.closure (Set.range (algebraMap A K)) = ⊤ :=\n  top_unique fun z _ ↦ by\n    obtain ⟨_, _, -, rfl⟩ := div_surjective (A := A) z\n    apply div_mem <;> exact Subfield.subset_closure ⟨_, rfl⟩\n\n"}
{"name":"IsFractionRing.ringHom_fieldRange_eq_of_comp_eq","module":"Mathlib.RingTheory.Localization.FractionRing","initialProofState":"A : Type u_4\ninst✝⁴ : CommRing A\nK : Type u_5\ninst✝³ : Field K\ninst✝² : Algebra A K\ninst✝¹ : IsFractionRing A K\nL : Type u_8\ninst✝ : Field L\ng : RingHom A L\nf : RingHom K L\nh : Eq (f.comp (algebraMap A K)) g\n⊢ Eq f.fieldRange (Subfield.closure ↑g.range)","decl":"/-- If `A` is a commutative ring with fraction field `K`, `L` is a field, `g : A →+* L` lifts to\n`f : K →+* L`, then the image of `f` is the subfield generated by the image of `g`. -/\ntheorem ringHom_fieldRange_eq_of_comp_eq (h : RingHom.comp f (algebraMap A K) = g) :\n    f.fieldRange = Subfield.closure g.range := by\n  rw [f.fieldRange_eq_map, ← closure_range_algebraMap A K,\n    f.map_field_closure, ← Set.range_comp, ← f.coe_comp, h, g.coe_range]\n\n"}
{"name":"IsFractionRing.ringHom_fieldRange_eq_of_comp_eq_of_range_eq","module":"Mathlib.RingTheory.Localization.FractionRing","initialProofState":"A : Type u_4\ninst✝⁴ : CommRing A\nK : Type u_5\ninst✝³ : Field K\ninst✝² : Algebra A K\ninst✝¹ : IsFractionRing A K\nL : Type u_8\ninst✝ : Field L\ng : RingHom A L\nf : RingHom K L\nh : Eq (f.comp (algebraMap A K)) g\ns : Set L\nhs : Eq g.range (Subring.closure s)\n⊢ Eq f.fieldRange (Subfield.closure s)","decl":"/-- If `A` is a commutative ring with fraction field `K`, `L` is a field, `g : A →+* L` lifts to\n`f : K →+* L`, `s` is a set such that the image of `g` is the subring generated by `s`,\nthen the image of `f` is the subfield generated by `s`. -/\ntheorem ringHom_fieldRange_eq_of_comp_eq_of_range_eq (h : RingHom.comp f (algebraMap A K) = g)\n    {s : Set L} (hs : g.range = Subring.closure s) : f.fieldRange = Subfield.closure s := by\n  rw [ringHom_fieldRange_eq_of_comp_eq h, hs]\n  ext\n  simp_rw [Subfield.mem_closure_iff, Subring.closure_eq]\n\n"}
{"name":"IsFractionRing.lift_unique","module":"Mathlib.RingTheory.Localization.FractionRing","initialProofState":"A : Type u_4\ninst✝⁴ : CommRing A\nK : Type u_5\ninst✝³ : Field K\nL : Type u_7\ninst✝² : Field L\ninst✝¹ : Algebra A K\ninst✝ : IsFractionRing A K\ng : RingHom A L\nhg : Function.Injective ⇑g\nf : RingHom K L\nhf1 : ∀ (x : A), Eq (f ((algebraMap A K) x)) (g x)\n⊢ Eq (IsFractionRing.lift hg) f","decl":"theorem lift_unique (hg : Function.Injective g) {f : K →+* L}\n    (hf1 : ∀ x, f (algebraMap A K x) = g x) : IsFractionRing.lift hg = f :=\n  IsLocalization.lift_unique _ hf1\n\n"}
{"name":"IsFractionRing.ringHom_ext","module":"Mathlib.RingTheory.Localization.FractionRing","initialProofState":"A : Type u_4\ninst✝⁴ : CommRing A\nK : Type u_5\ninst✝³ : Field K\nL : Type u_7\ninst✝² : Field L\ninst✝¹ : Algebra A K\ninst✝ : IsFractionRing A K\nf1 f2 : RingHom K L\nhf : ∀ (x : A), Eq (f1 ((algebraMap A K) x)) (f2 ((algebraMap A K) x))\n⊢ Eq f1 f2","decl":"/-- Another version of unique to give two lift maps should be equal -/\ntheorem ringHom_ext {f1 f2 : K →+* L}\n    (hf : ∀ x : A, f1 (algebraMap A K x) = f2 (algebraMap A K x)) : f1 = f2 := by\n  ext z\n  obtain ⟨x, y, hy, rfl⟩ := IsFractionRing.div_surjective (A := A) z\n  rw [map_div₀, map_div₀, hf, hf]\n\n"}
{"name":"IsFractionRing.injective_comp_algebraMap","module":"Mathlib.RingTheory.Localization.FractionRing","initialProofState":"A : Type u_4\ninst✝⁴ : CommRing A\nK : Type u_5\ninst✝³ : Field K\nL : Type u_7\ninst✝² : Field L\ninst✝¹ : Algebra A K\ninst✝ : IsFractionRing A K\n⊢ Function.Injective fun f => f.comp (algebraMap A K)","decl":"theorem injective_comp_algebraMap :\n    Function.Injective fun (f : K →+* L) => f.comp (algebraMap A K) :=\n  fun _ _ h => ringHom_ext (fun x => RingHom.congr_fun h x)\n\n"}
{"name":"IsFractionRing.liftAlgHom_toRingHom","module":"Mathlib.RingTheory.Localization.FractionRing","initialProofState":"R : Type u_1\ninst✝⁹ : CommRing R\nA : Type u_4\ninst✝⁸ : CommRing A\nK : Type u_5\ninst✝⁷ : Field K\nL : Type u_7\ninst✝⁶ : Field L\ninst✝⁵ : Algebra A K\ninst✝⁴ : IsFractionRing A K\ninst✝³ : Algebra R A\ninst✝² : Algebra R K\ninst✝¹ : IsScalarTower R A K\ninst✝ : Algebra R L\ng : AlgHom R A L\nhg : Function.Injective ⇑g\n⊢ Eq (IsFractionRing.liftAlgHom hg).toRingHom (IsFractionRing.lift hg)","decl":"theorem liftAlgHom_toRingHom : (liftAlgHom hg : K →ₐ[R] L).toRingHom = lift hg := rfl\n\n"}
{"name":"IsFractionRing.coe_liftAlgHom","module":"Mathlib.RingTheory.Localization.FractionRing","initialProofState":"R : Type u_1\ninst✝⁹ : CommRing R\nA : Type u_4\ninst✝⁸ : CommRing A\nK : Type u_5\ninst✝⁷ : Field K\nL : Type u_7\ninst✝⁶ : Field L\ninst✝⁵ : Algebra A K\ninst✝⁴ : IsFractionRing A K\ninst✝³ : Algebra R A\ninst✝² : Algebra R K\ninst✝¹ : IsScalarTower R A K\ninst✝ : Algebra R L\ng : AlgHom R A L\nhg : Function.Injective ⇑g\n⊢ Eq ⇑(IsFractionRing.liftAlgHom hg) ⇑(IsFractionRing.lift hg)","decl":"@[simp]\ntheorem coe_liftAlgHom : ⇑(liftAlgHom hg : K →ₐ[R] L) = lift hg := rfl\n\n"}
{"name":"IsFractionRing.liftAlgHom_apply","module":"Mathlib.RingTheory.Localization.FractionRing","initialProofState":"R : Type u_1\ninst✝⁹ : CommRing R\nA : Type u_4\ninst✝⁸ : CommRing A\nK : Type u_5\ninst✝⁷ : Field K\nL : Type u_7\ninst✝⁶ : Field L\ninst✝⁵ : Algebra A K\ninst✝⁴ : IsFractionRing A K\ninst✝³ : Algebra R A\ninst✝² : Algebra R K\ninst✝¹ : IsScalarTower R A K\ninst✝ : Algebra R L\ng : AlgHom R A L\nhg : Function.Injective ⇑g\nx : K\n⊢ Eq ((IsFractionRing.liftAlgHom hg) x) ((IsFractionRing.lift hg) x)","decl":"theorem liftAlgHom_apply : liftAlgHom hg x = lift hg x := rfl\n\n"}
{"name":"IsFractionRing.lift_algebraMap","module":"Mathlib.RingTheory.Localization.FractionRing","initialProofState":"A : Type u_4\ninst✝⁴ : CommRing A\nK : Type u_5\ninst✝³ : Field K\nL : Type u_7\ninst✝² : Field L\ninst✝¹ : Algebra A K\ninst✝ : IsFractionRing A K\ng : RingHom A L\nhg : Function.Injective ⇑g\nx : A\n⊢ Eq ((IsFractionRing.lift hg) ((algebraMap A K) x)) (g x)","decl":"/-- Given a commutative ring `A` with field of fractions `K`,\nand an injective ring hom `g : A →+* L` where `L` is a field,\nthe field hom induced from `K` to `L` maps `x` to `g x` for all\n`x : A`. -/\n@[simp]\ntheorem lift_algebraMap (hg : Injective g) (x) : lift hg (algebraMap A K x) = g x :=\n  lift_eq _ _\n\n"}
{"name":"IsFractionRing.lift_fieldRange","module":"Mathlib.RingTheory.Localization.FractionRing","initialProofState":"A : Type u_4\ninst✝⁴ : CommRing A\nK : Type u_5\ninst✝³ : Field K\nL : Type u_7\ninst✝² : Field L\ninst✝¹ : Algebra A K\ninst✝ : IsFractionRing A K\ng : RingHom A L\nhg : Function.Injective ⇑g\n⊢ Eq (IsFractionRing.lift hg).fieldRange (Subfield.closure ↑g.range)","decl":"/-- The image of `IsFractionRing.lift` is the subfield generated by the image\nof the ring hom. -/\ntheorem lift_fieldRange (hg : Injective g) :\n    (lift hg : K →+* L).fieldRange = Subfield.closure g.range :=\n  ringHom_fieldRange_eq_of_comp_eq (by ext; simp)\n\n"}
{"name":"IsFractionRing.lift_fieldRange_eq_of_range_eq","module":"Mathlib.RingTheory.Localization.FractionRing","initialProofState":"A : Type u_4\ninst✝⁴ : CommRing A\nK : Type u_5\ninst✝³ : Field K\nL : Type u_7\ninst✝² : Field L\ninst✝¹ : Algebra A K\ninst✝ : IsFractionRing A K\ng : RingHom A L\nhg : Function.Injective ⇑g\ns : Set L\nhs : Eq g.range (Subring.closure s)\n⊢ Eq (IsFractionRing.lift hg).fieldRange (Subfield.closure s)","decl":"/-- The image of `IsFractionRing.lift` is the subfield generated by `s`, if the image\nof the ring hom is the subring generated by `s`. -/\ntheorem lift_fieldRange_eq_of_range_eq (hg : Injective g)\n    {s : Set L} (hs : g.range = Subring.closure s) :\n    (lift hg : K →+* L).fieldRange = Subfield.closure s :=\n  ringHom_fieldRange_eq_of_comp_eq_of_range_eq (by ext; simp) hs\n\n"}
{"name":"IsFractionRing.lift_mk'","module":"Mathlib.RingTheory.Localization.FractionRing","initialProofState":"A : Type u_4\ninst✝⁴ : CommRing A\nK : Type u_5\ninst✝³ : Field K\nL : Type u_7\ninst✝² : Field L\ninst✝¹ : Algebra A K\ninst✝ : IsFractionRing A K\ng : RingHom A L\nhg : Function.Injective ⇑g\nx : A\ny : Subtype fun x => Membership.mem (nonZeroDivisors A) x\n⊢ Eq ((IsFractionRing.lift hg) (IsLocalization.mk' K x y)) (HDiv.hDiv (g x) (g ↑y))","decl":"/-- Given a commutative ring `A` with field of fractions `K`,\nand an injective ring hom `g : A →+* L` where `L` is a field,\nfield hom induced from `K` to `L` maps `f x / f y` to `g x / g y` for all\n`x : A, y ∈ NonZeroDivisors A`. -/\ntheorem lift_mk' (hg : Injective g) (x) (y : nonZeroDivisors A) :\n    lift hg (mk' K x y) = g x / g y := by simp only [mk'_eq_div, map_div₀, lift_algebraMap]\n\n"}
{"name":"IsFractionRing.ringEquivOfRingEquiv_algebraMap","module":"Mathlib.RingTheory.Localization.FractionRing","initialProofState":"A : Type u_8\nK : Type u_9\nB : Type u_10\nL : Type u_11\ninst✝⁷ : CommRing A\ninst✝⁶ : CommRing B\ninst✝⁵ : CommRing K\ninst✝⁴ : CommRing L\ninst✝³ : Algebra A K\ninst✝² : IsFractionRing A K\ninst✝¹ : Algebra B L\ninst✝ : IsFractionRing B L\nh : RingEquiv A B\na : A\n⊢ Eq ((IsFractionRing.ringEquivOfRingEquiv h) ((algebraMap A K) a)) ((algebraMap B L) (h a))","decl":"@[simp]\nlemma ringEquivOfRingEquiv_algebraMap\n    (a : A) : ringEquivOfRingEquiv h (algebraMap A K a) = algebraMap B L (h a) := by\n  simp [ringEquivOfRingEquiv]\n\n"}
{"name":"IsFractionRing.fieldEquivOfRingEquiv_algebraMap","module":"Mathlib.RingTheory.Localization.FractionRing","initialProofState":"A : Type u_8\nK : Type u_9\nB : Type u_10\nL : Type u_11\ninst✝⁷ : CommRing A\ninst✝⁶ : CommRing B\ninst✝⁵ : CommRing K\ninst✝⁴ : CommRing L\ninst✝³ : Algebra A K\ninst✝² : IsFractionRing A K\ninst✝¹ : Algebra B L\ninst✝ : IsFractionRing B L\nh : RingEquiv A B\na : A\n⊢ Eq ((IsFractionRing.ringEquivOfRingEquiv h) ((algebraMap A K) a)) ((algebraMap B L) (h a))","decl":"@[deprecated (since := \"2024-11-05\")]\nalias fieldEquivOfRingEquiv_algebraMap := ringEquivOfRingEquiv_algebraMap\n\n"}
{"name":"IsFractionRing.ringEquivOfRingEquiv_symm","module":"Mathlib.RingTheory.Localization.FractionRing","initialProofState":"A : Type u_8\nK : Type u_9\nB : Type u_10\nL : Type u_11\ninst✝⁷ : CommRing A\ninst✝⁶ : CommRing B\ninst✝⁵ : CommRing K\ninst✝⁴ : CommRing L\ninst✝³ : Algebra A K\ninst✝² : IsFractionRing A K\ninst✝¹ : Algebra B L\ninst✝ : IsFractionRing B L\nh : RingEquiv A B\n⊢ Eq (IsFractionRing.ringEquivOfRingEquiv h).symm (IsFractionRing.ringEquivOfRingEquiv h.symm)","decl":"@[simp]\nlemma ringEquivOfRingEquiv_symm :\n    (ringEquivOfRingEquiv h : K ≃+* L).symm = ringEquivOfRingEquiv h.symm := rfl\n\n"}
{"name":"IsFractionRing.algEquivOfAlgEquiv_algebraMap","module":"Mathlib.RingTheory.Localization.FractionRing","initialProofState":"R : Type u_8\nA : Type u_9\nK : Type u_10\nB : Type u_11\nL : Type u_12\ninst✝¹⁴ : CommSemiring R\ninst✝¹³ : CommRing A\ninst✝¹² : CommRing B\ninst✝¹¹ : CommRing K\ninst✝¹⁰ : CommRing L\ninst✝⁹ : Algebra R A\ninst✝⁸ : Algebra R K\ninst✝⁷ : Algebra A K\ninst✝⁶ : IsFractionRing A K\ninst✝⁵ : IsScalarTower R A K\ninst✝⁴ : Algebra R B\ninst✝³ : Algebra R L\ninst✝² : Algebra B L\ninst✝¹ : IsFractionRing B L\ninst✝ : IsScalarTower R B L\nh : AlgEquiv R A B\na : A\n⊢ Eq ((IsFractionRing.algEquivOfAlgEquiv h) ((algebraMap A K) a)) ((algebraMap B L) (h a))","decl":"@[simp]\nlemma algEquivOfAlgEquiv_algebraMap\n    (a : A) : algEquivOfAlgEquiv h (algebraMap A K a) = algebraMap B L (h a) := by\n  simp [algEquivOfAlgEquiv]\n\n"}
{"name":"IsFractionRing.algEquivOfAlgEquiv_symm","module":"Mathlib.RingTheory.Localization.FractionRing","initialProofState":"R : Type u_8\nA : Type u_9\nK : Type u_10\nB : Type u_11\nL : Type u_12\ninst✝¹⁴ : CommSemiring R\ninst✝¹³ : CommRing A\ninst✝¹² : CommRing B\ninst✝¹¹ : CommRing K\ninst✝¹⁰ : CommRing L\ninst✝⁹ : Algebra R A\ninst✝⁸ : Algebra R K\ninst✝⁷ : Algebra A K\ninst✝⁶ : IsFractionRing A K\ninst✝⁵ : IsScalarTower R A K\ninst✝⁴ : Algebra R B\ninst✝³ : Algebra R L\ninst✝² : Algebra B L\ninst✝¹ : IsFractionRing B L\ninst✝ : IsScalarTower R B L\nh : AlgEquiv R A B\n⊢ Eq (IsFractionRing.algEquivOfAlgEquiv h).symm (IsFractionRing.algEquivOfAlgEquiv h.symm)","decl":"@[simp]\nlemma algEquivOfAlgEquiv_symm :\n    (algEquivOfAlgEquiv h : K ≃ₐ[R] L).symm = algEquivOfAlgEquiv h.symm := rfl\n\n"}
{"name":"IsFractionRing.restrictScalars_fieldEquivOfAlgEquiv","module":"Mathlib.RingTheory.Localization.FractionRing","initialProofState":"A : Type u_8\nB : Type u_9\nC : Type u_10\ninst✝²¹ : CommRing A\ninst✝²⁰ : CommRing B\ninst✝¹⁹ : CommRing C\ninst✝¹⁸ : Algebra A B\ninst✝¹⁷ : Algebra A C\nFA : Type u_12\nFB : Type u_13\nFC : Type u_14\ninst✝¹⁶ : Field FA\ninst✝¹⁵ : Field FB\ninst✝¹⁴ : Field FC\ninst✝¹³ : Algebra A FA\ninst✝¹² : Algebra B FB\ninst✝¹¹ : Algebra C FC\ninst✝¹⁰ : IsFractionRing A FA\ninst✝⁹ : IsFractionRing B FB\ninst✝⁸ : IsFractionRing C FC\ninst✝⁷ : Algebra A FB\ninst✝⁶ : IsScalarTower A B FB\ninst✝⁵ : Algebra A FC\ninst✝⁴ : IsScalarTower A C FC\ninst✝³ : Algebra FA FB\ninst✝² : IsScalarTower A FA FB\ninst✝¹ : Algebra FA FC\ninst✝ : IsScalarTower A FA FC\nf : AlgEquiv A B C\n⊢ Eq (AlgEquiv.restrictScalars A (IsFractionRing.fieldEquivOfAlgEquiv FA FB FC f)) (IsFractionRing.algEquivOfAlgEquiv f)","decl":"lemma restrictScalars_fieldEquivOfAlgEquiv (f : B ≃ₐ[A] C) :\n    (fieldEquivOfAlgEquiv FA FB FC f).restrictScalars A = algEquivOfAlgEquiv f := by\n  ext; rfl\n\n"}
{"name":"IsFractionRing.fieldEquivOfAlgEquiv_algebraMap","module":"Mathlib.RingTheory.Localization.FractionRing","initialProofState":"A : Type u_8\nB : Type u_9\nC : Type u_10\ninst✝²¹ : CommRing A\ninst✝²⁰ : CommRing B\ninst✝¹⁹ : CommRing C\ninst✝¹⁸ : Algebra A B\ninst✝¹⁷ : Algebra A C\nFA : Type u_12\nFB : Type u_13\nFC : Type u_14\ninst✝¹⁶ : Field FA\ninst✝¹⁵ : Field FB\ninst✝¹⁴ : Field FC\ninst✝¹³ : Algebra A FA\ninst✝¹² : Algebra B FB\ninst✝¹¹ : Algebra C FC\ninst✝¹⁰ : IsFractionRing A FA\ninst✝⁹ : IsFractionRing B FB\ninst✝⁸ : IsFractionRing C FC\ninst✝⁷ : Algebra A FB\ninst✝⁶ : IsScalarTower A B FB\ninst✝⁵ : Algebra A FC\ninst✝⁴ : IsScalarTower A C FC\ninst✝³ : Algebra FA FB\ninst✝² : IsScalarTower A FA FB\ninst✝¹ : Algebra FA FC\ninst✝ : IsScalarTower A FA FC\nf : AlgEquiv A B C\nb : B\n⊢ Eq ((IsFractionRing.fieldEquivOfAlgEquiv FA FB FC f) ((algebraMap B FB) b)) ((algebraMap C FC) (f b))","decl":"/-- This says that `fieldEquivOfAlgEquiv f` is an extension of `f` (i.e., it agrees with `f` on\n`B`). Whereas `(fieldEquivOfAlgEquiv f).commutes` says that `fieldEquivOfAlgEquiv f` fixes `K`. -/\n@[simp]\nlemma fieldEquivOfAlgEquiv_algebraMap (f : B ≃ₐ[A] C) (b : B) :\n    fieldEquivOfAlgEquiv FA FB FC f (algebraMap B FB b) = algebraMap C FC (f b) :=\n  ringEquivOfRingEquiv_algebraMap f.toRingEquiv b\n\n"}
{"name":"IsFractionRing.fieldEquivOfAlgEquiv_refl","module":"Mathlib.RingTheory.Localization.FractionRing","initialProofState":"A : Type u_8\nB : Type u_9\ninst✝¹² : CommRing A\ninst✝¹¹ : CommRing B\ninst✝¹⁰ : Algebra A B\nFA : Type u_12\nFB : Type u_13\ninst✝⁹ : Field FA\ninst✝⁸ : Field FB\ninst✝⁷ : Algebra A FA\ninst✝⁶ : Algebra B FB\ninst✝⁵ : IsFractionRing A FA\ninst✝⁴ : IsFractionRing B FB\ninst✝³ : Algebra A FB\ninst✝² : IsScalarTower A B FB\ninst✝¹ : Algebra FA FB\ninst✝ : IsScalarTower A FA FB\n⊢ Eq (IsFractionRing.fieldEquivOfAlgEquiv FA FB FB AlgEquiv.refl) AlgEquiv.refl","decl":"variable (A B) in\n@[simp]\nlemma fieldEquivOfAlgEquiv_refl :\n    fieldEquivOfAlgEquiv FA FB FB (AlgEquiv.refl : B ≃ₐ[A] B) = AlgEquiv.refl := by\n  ext x\n  obtain ⟨x, y, -, rfl⟩ := IsFractionRing.div_surjective (A := B) x\n  simp\n\n"}
{"name":"IsFractionRing.fieldEquivOfAlgEquiv_trans","module":"Mathlib.RingTheory.Localization.FractionRing","initialProofState":"A : Type u_8\nB : Type u_9\nC : Type u_10\nD : Type u_11\ninst✝³⁰ : CommRing A\ninst✝²⁹ : CommRing B\ninst✝²⁸ : CommRing C\ninst✝²⁷ : CommRing D\ninst✝²⁶ : Algebra A B\ninst✝²⁵ : Algebra A C\ninst✝²⁴ : Algebra A D\nFA : Type u_12\nFB : Type u_13\nFC : Type u_14\nFD : Type u_15\ninst✝²³ : Field FA\ninst✝²² : Field FB\ninst✝²¹ : Field FC\ninst✝²⁰ : Field FD\ninst✝¹⁹ : Algebra A FA\ninst✝¹⁸ : Algebra B FB\ninst✝¹⁷ : Algebra C FC\ninst✝¹⁶ : Algebra D FD\ninst✝¹⁵ : IsFractionRing A FA\ninst✝¹⁴ : IsFractionRing B FB\ninst✝¹³ : IsFractionRing C FC\ninst✝¹² : IsFractionRing D FD\ninst✝¹¹ : Algebra A FB\ninst✝¹⁰ : IsScalarTower A B FB\ninst✝⁹ : Algebra A FC\ninst✝⁸ : IsScalarTower A C FC\ninst✝⁷ : Algebra A FD\ninst✝⁶ : IsScalarTower A D FD\ninst✝⁵ : Algebra FA FB\ninst✝⁴ : IsScalarTower A FA FB\ninst✝³ : Algebra FA FC\ninst✝² : IsScalarTower A FA FC\ninst✝¹ : Algebra FA FD\ninst✝ : IsScalarTower A FA FD\nf : AlgEquiv A B C\ng : AlgEquiv A C D\n⊢ Eq (IsFractionRing.fieldEquivOfAlgEquiv FA FB FD (f.trans g)) ((IsFractionRing.fieldEquivOfAlgEquiv FA FB FC f).trans (IsFractionRing.fieldEquivOfAlgEquiv FA FC FD g))","decl":"lemma fieldEquivOfAlgEquiv_trans (f : B ≃ₐ[A] C) (g : C ≃ₐ[A] D) :\n    fieldEquivOfAlgEquiv FA FB FD (f.trans g) =\n      (fieldEquivOfAlgEquiv FA FB FC f).trans (fieldEquivOfAlgEquiv FA FC FD g) := by\n  ext x\n  obtain ⟨x, y, -, rfl⟩ := IsFractionRing.div_surjective (A := B) x\n  simp\n\n"}
{"name":"IsFractionRing.fieldEquivOfAlgEquivHom_apply","module":"Mathlib.RingTheory.Localization.FractionRing","initialProofState":"A : Type u_8\nB : Type u_9\ninst✝¹² : CommRing A\ninst✝¹¹ : CommRing B\ninst✝¹⁰ : Algebra A B\nK : Type u_10\nL : Type u_11\ninst✝⁹ : Field K\ninst✝⁸ : Field L\ninst✝⁷ : Algebra A K\ninst✝⁶ : Algebra B L\ninst✝⁵ : IsFractionRing A K\ninst✝⁴ : IsFractionRing B L\ninst✝³ : Algebra A L\ninst✝² : IsScalarTower A B L\ninst✝¹ : Algebra K L\ninst✝ : IsScalarTower A K L\nf : AlgEquiv A B B\n⊢ Eq ((IsFractionRing.fieldEquivOfAlgEquivHom K L) f) (IsFractionRing.fieldEquivOfAlgEquiv K L L f)","decl":"@[simp]\nlemma fieldEquivOfAlgEquivHom_apply (f : B ≃ₐ[A] B) :\n    fieldEquivOfAlgEquivHom K L f = fieldEquivOfAlgEquiv K L L f :=\n  rfl\n\n"}
{"name":"IsFractionRing.fieldEquivOfAlgEquivHom_injective","module":"Mathlib.RingTheory.Localization.FractionRing","initialProofState":"A : Type u_8\nB : Type u_9\ninst✝¹² : CommRing A\ninst✝¹¹ : CommRing B\ninst✝¹⁰ : Algebra A B\nK : Type u_10\nL : Type u_11\ninst✝⁹ : Field K\ninst✝⁸ : Field L\ninst✝⁷ : Algebra A K\ninst✝⁶ : Algebra B L\ninst✝⁵ : IsFractionRing A K\ninst✝⁴ : IsFractionRing B L\ninst✝³ : Algebra A L\ninst✝² : IsScalarTower A B L\ninst✝¹ : Algebra K L\ninst✝ : IsScalarTower A K L\n⊢ Function.Injective ⇑(IsFractionRing.fieldEquivOfAlgEquivHom K L)","decl":"lemma fieldEquivOfAlgEquivHom_injective :\n    Function.Injective (fieldEquivOfAlgEquivHom K L : (B ≃ₐ[A] B) →* (L ≃ₐ[K] L)) := by\n  intro f g h\n  ext b\n  simpa using AlgEquiv.ext_iff.mp h (algebraMap B L b)\n\n"}
{"name":"IsFractionRing.isFractionRing_iff_of_base_ringEquiv","module":"Mathlib.RingTheory.Localization.FractionRing","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nS : Type u_2\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\nP : Type u_3\ninst✝ : CommRing P\nh : RingEquiv R P\n⊢ Iff (IsFractionRing R S) (IsFractionRing P S)","decl":"theorem isFractionRing_iff_of_base_ringEquiv (h : R ≃+* P) :\n    IsFractionRing R S ↔\n      @IsFractionRing P _ S _ ((algebraMap R S).comp h.symm.toRingHom).toAlgebra := by\n  delta IsFractionRing\n  convert isLocalization_iff_of_base_ringEquiv (nonZeroDivisors R) S h\n  ext x\n  erw [Submonoid.map_equiv_eq_comap_symm]\n  simp only [MulEquiv.coe_toMonoidHom, RingEquiv.toMulEquiv_eq_coe, Submonoid.mem_comap]\n  constructor\n  · rintro hx z (hz : z * h.symm x = 0)\n    rw [← h.map_eq_zero_iff]\n    apply hx\n    simpa only [h.map_zero, h.apply_symm_apply, h.map_mul] using congr_arg h hz\n  · rintro (hx : h.symm x ∈ _) z hz\n    rw [← h.symm.map_eq_zero_iff]\n    apply hx\n    rw [← h.symm.map_mul, hz, h.symm.map_zero]\n\n"}
{"name":"IsFractionRing.nontrivial","module":"Mathlib.RingTheory.Localization.FractionRing","initialProofState":"R : Type u_8\nS : Type u_9\ninst✝⁴ : CommRing R\ninst✝³ : Nontrivial R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\ninst✝ : IsFractionRing R S\n⊢ Nontrivial S","decl":"protected theorem nontrivial (R S : Type*) [CommRing R] [Nontrivial R] [CommRing S] [Algebra R S]\n    [IsFractionRing R S] : Nontrivial S := by\n  apply nontrivial_of_ne\n  · intro h\n    apply @zero_ne_one R\n    exact\n      IsLocalization.injective S (le_of_eq rfl)\n        (((algebraMap R S).map_zero.trans h).trans (algebraMap R S).map_one.symm)\n\n"}
{"name":"algebraMap_injective_of_field_isFractionRing","module":"Mathlib.RingTheory.Localization.FractionRing","initialProofState":"R : Type u_1\ninst✝¹² : CommRing R\nS : Type u_2\ninst✝¹¹ : CommRing S\ninst✝¹⁰ : Algebra R S\nK : Type u_6\nL : Type u_7\ninst✝⁹ : Field K\ninst✝⁸ : Semiring L\ninst✝⁷ : Nontrivial L\ninst✝⁶ : Algebra R K\ninst✝⁵ : IsFractionRing R K\ninst✝⁴ : Algebra S L\ninst✝³ : Algebra K L\ninst✝² : Algebra R L\ninst✝¹ : IsScalarTower R S L\ninst✝ : IsScalarTower R K L\n⊢ Function.Injective ⇑(algebraMap R S)","decl":"theorem algebraMap_injective_of_field_isFractionRing (K L : Type*) [Field K] [Semiring L]\n    [Nontrivial L] [Algebra R K] [IsFractionRing R K] [Algebra S L] [Algebra K L] [Algebra R L]\n    [IsScalarTower R S L] [IsScalarTower R K L] : Function.Injective (algebraMap R S) := by\n  refine Function.Injective.of_comp (f := algebraMap S L) ?_\n  rw [← RingHom.coe_comp, ← IsScalarTower.algebraMap_eq, IsScalarTower.algebraMap_eq R K L]\n  exact (algebraMap K L).injective.comp (IsFractionRing.injective R K)\n\n"}
{"name":"NoZeroSMulDivisors.of_field_isFractionRing","module":"Mathlib.RingTheory.Localization.FractionRing","initialProofState":"R : Type u_1\ninst✝¹³ : CommRing R\nS : Type u_2\ninst✝¹² : CommRing S\ninst✝¹¹ : Algebra R S\ninst✝¹⁰ : NoZeroDivisors S\nK : Type u_6\nL : Type u_7\ninst✝⁹ : Field K\ninst✝⁸ : Semiring L\ninst✝⁷ : Nontrivial L\ninst✝⁶ : Algebra R K\ninst✝⁵ : IsFractionRing R K\ninst✝⁴ : Algebra S L\ninst✝³ : Algebra K L\ninst✝² : Algebra R L\ninst✝¹ : IsScalarTower R S L\ninst✝ : IsScalarTower R K L\n⊢ NoZeroSMulDivisors R S","decl":"theorem NoZeroSMulDivisors.of_field_isFractionRing [NoZeroDivisors S] (K L : Type*) [Field K]\n    [Semiring L] [Nontrivial L] [Algebra R K] [IsFractionRing R K] [Algebra S L] [Algebra K L]\n    [Algebra R L] [IsScalarTower R S L] [IsScalarTower R K L] : NoZeroSMulDivisors R S :=\n  of_algebraMap_injective (algebraMap_injective_of_field_isFractionRing R S K L)\n\n"}
{"name":"FractionRing.instNontrivial","module":"Mathlib.RingTheory.Localization.FractionRing","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : Nontrivial R\n⊢ Nontrivial (FractionRing R)","decl":"instance [Nontrivial R] : Nontrivial (FractionRing R) := inferInstance\n\n"}
{"name":"FractionRing.mk_eq_div","module":"Mathlib.RingTheory.Localization.FractionRing","initialProofState":"A : Type u_4\ninst✝¹ : CommRing A\ninst✝ : IsDomain A\nr : A\ns : Subtype fun x => Membership.mem (nonZeroDivisors A) x\n⊢ Eq (Localization.mk r s) (HDiv.hDiv ((algebraMap A (FractionRing A)) r) ((algebraMap A (FractionRing A)) ↑s))","decl":"@[simp]\ntheorem mk_eq_div {r s} :\n    (Localization.mk r s : FractionRing A) =\n      (algebraMap _ _ r / algebraMap A _ s : FractionRing A) := by\n  rw [Localization.mk_eq_mk', IsFractionRing.mk'_eq_div]\n\n"}
{"name":"FractionRing.isScalarTower_liftAlgebra","module":"Mathlib.RingTheory.Localization.FractionRing","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nK : Type u_5\ninst✝³ : IsDomain R\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : NoZeroSMulDivisors R K\n⊢ IsScalarTower R (FractionRing R) K","decl":"instance isScalarTower_liftAlgebra [IsDomain R] [Field K] [Algebra R K] [NoZeroSMulDivisors R K] :\n    by letI := liftAlgebra R K; exact IsScalarTower R (FractionRing R) K := by\n  letI := liftAlgebra R K\n  exact IsScalarTower.of_algebraMap_eq fun x =>\n    (IsFractionRing.lift_algebraMap (NoZeroSMulDivisors.algebraMap_injective R K) x).symm\n\n"}
{"name":"FractionRing.instNoZeroSMulDivisors","module":"Mathlib.RingTheory.Localization.FractionRing","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nA : Type u_4\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\ninst✝ : NoZeroSMulDivisors R A\n⊢ NoZeroSMulDivisors R (FractionRing A)","decl":"instance [Algebra R A] [NoZeroSMulDivisors R A] : NoZeroSMulDivisors R (FractionRing A) := by\n  apply NoZeroSMulDivisors.of_algebraMap_injective\n  rw [IsScalarTower.algebraMap_eq R A]\n  apply Function.Injective.comp (NoZeroSMulDivisors.algebraMap_injective A (FractionRing A))\n    (NoZeroSMulDivisors.algebraMap_injective R A)\n\n"}
