{"name":"Homeomorph.coe_mulLeft","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : ContinuousMul G\na : G\nâŠ¢ Eq â‡‘(Homeomorph.mulLeft a) fun x => HMul.hMul a x","decl":"@[to_additive (attr := simp)]\ntheorem Homeomorph.coe_mulLeft (a : G) : â‡‘(Homeomorph.mulLeft a) = (a * Â·) :=\n  rfl\n\n"}
{"name":"Homeomorph.coe_addLeft","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : ContinuousAdd G\na : G\nâŠ¢ Eq â‡‘(Homeomorph.addLeft a) fun x => HAdd.hAdd a x","decl":"@[to_additive (attr := simp)]\ntheorem Homeomorph.coe_mulLeft (a : G) : â‡‘(Homeomorph.mulLeft a) = (a * Â·) :=\n  rfl\n\n"}
{"name":"Homeomorph.addLeft_symm","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : ContinuousAdd G\na : G\nâŠ¢ Eq (Homeomorph.addLeft a).symm (Homeomorph.addLeft (Neg.neg a))","decl":"@[to_additive]\ntheorem Homeomorph.mulLeft_symm (a : G) : (Homeomorph.mulLeft a).symm = Homeomorph.mulLeft aâ»Â¹ := by\n  ext\n  rfl\n\n"}
{"name":"Homeomorph.mulLeft_symm","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : ContinuousMul G\na : G\nâŠ¢ Eq (Homeomorph.mulLeft a).symm (Homeomorph.mulLeft (Inv.inv a))","decl":"@[to_additive]\ntheorem Homeomorph.mulLeft_symm (a : G) : (Homeomorph.mulLeft a).symm = Homeomorph.mulLeft aâ»Â¹ := by\n  ext\n  rfl\n\n"}
{"name":"isOpenMap_mul_left","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : ContinuousMul G\na : G\nâŠ¢ IsOpenMap fun x => HMul.hMul a x","decl":"@[to_additive]\nlemma isOpenMap_mul_left (a : G) : IsOpenMap (a * Â·) := (Homeomorph.mulLeft a).isOpenMap\n\n"}
{"name":"isOpenMap_add_left","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : ContinuousAdd G\na : G\nâŠ¢ IsOpenMap fun x => HAdd.hAdd a x","decl":"@[to_additive]\nlemma isOpenMap_mul_left (a : G) : IsOpenMap (a * Â·) := (Homeomorph.mulLeft a).isOpenMap\n\n"}
{"name":"IsOpen.leftCoset","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : ContinuousMul G\nU : Set G\nh : IsOpen U\nx : G\nâŠ¢ IsOpen (HSMul.hSMul x U)","decl":"@[to_additive IsOpen.left_addCoset]\ntheorem IsOpen.leftCoset {U : Set G} (h : IsOpen U) (x : G) : IsOpen (x â€¢ U) :=\n  isOpenMap_mul_left x _ h\n\n"}
{"name":"IsOpen.left_addCoset","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : ContinuousAdd G\nU : Set G\nh : IsOpen U\nx : G\nâŠ¢ IsOpen (HVAdd.hVAdd x U)","decl":"@[to_additive IsOpen.left_addCoset]\ntheorem IsOpen.leftCoset {U : Set G} (h : IsOpen U) (x : G) : IsOpen (x â€¢ U) :=\n  isOpenMap_mul_left x _ h\n\n"}
{"name":"isClosedMap_add_left","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : ContinuousAdd G\na : G\nâŠ¢ IsClosedMap fun x => HAdd.hAdd a x","decl":"@[to_additive]\nlemma isClosedMap_mul_left (a : G) : IsClosedMap (a * Â·) := (Homeomorph.mulLeft a).isClosedMap\n\n"}
{"name":"isClosedMap_mul_left","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : ContinuousMul G\na : G\nâŠ¢ IsClosedMap fun x => HMul.hMul a x","decl":"@[to_additive]\nlemma isClosedMap_mul_left (a : G) : IsClosedMap (a * Â·) := (Homeomorph.mulLeft a).isClosedMap\n\n"}
{"name":"IsClosed.leftCoset","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : ContinuousMul G\nU : Set G\nh : IsClosed U\nx : G\nâŠ¢ IsClosed (HSMul.hSMul x U)","decl":"@[to_additive IsClosed.left_addCoset]\ntheorem IsClosed.leftCoset {U : Set G} (h : IsClosed U) (x : G) : IsClosed (x â€¢ U) :=\n  isClosedMap_mul_left x _ h\n\n"}
{"name":"IsClosed.left_addCoset","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : ContinuousAdd G\nU : Set G\nh : IsClosed U\nx : G\nâŠ¢ IsClosed (HVAdd.hVAdd x U)","decl":"@[to_additive IsClosed.left_addCoset]\ntheorem IsClosed.leftCoset {U : Set G} (h : IsClosed U) (x : G) : IsClosed (x â€¢ U) :=\n  isClosedMap_mul_left x _ h\n\n"}
{"name":"Homeomorph.coe_mulRight","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : ContinuousMul G\na : G\nâŠ¢ Eq â‡‘(Homeomorph.mulRight a) fun x => HMul.hMul x a","decl":"@[to_additive (attr := simp)]\nlemma Homeomorph.coe_mulRight (a : G) : â‡‘(Homeomorph.mulRight a) = (Â· * a) := rfl\n\n"}
{"name":"Homeomorph.coe_addRight","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : ContinuousAdd G\na : G\nâŠ¢ Eq â‡‘(Homeomorph.addRight a) fun x => HAdd.hAdd x a","decl":"@[to_additive (attr := simp)]\nlemma Homeomorph.coe_mulRight (a : G) : â‡‘(Homeomorph.mulRight a) = (Â· * a) := rfl\n\n"}
{"name":"Homeomorph.addRight_symm","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : ContinuousAdd G\na : G\nâŠ¢ Eq (Homeomorph.addRight a).symm (Homeomorph.addRight (Neg.neg a))","decl":"@[to_additive]\ntheorem Homeomorph.mulRight_symm (a : G) :\n    (Homeomorph.mulRight a).symm = Homeomorph.mulRight aâ»Â¹ := by\n  ext\n  rfl\n\n"}
{"name":"Homeomorph.mulRight_symm","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : ContinuousMul G\na : G\nâŠ¢ Eq (Homeomorph.mulRight a).symm (Homeomorph.mulRight (Inv.inv a))","decl":"@[to_additive]\ntheorem Homeomorph.mulRight_symm (a : G) :\n    (Homeomorph.mulRight a).symm = Homeomorph.mulRight aâ»Â¹ := by\n  ext\n  rfl\n\n"}
{"name":"isOpenMap_mul_right","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : ContinuousMul G\na : G\nâŠ¢ IsOpenMap fun x => HMul.hMul x a","decl":"@[to_additive]\ntheorem isOpenMap_mul_right (a : G) : IsOpenMap (Â· * a) :=\n  (Homeomorph.mulRight a).isOpenMap\n\n"}
{"name":"isOpenMap_add_right","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : ContinuousAdd G\na : G\nâŠ¢ IsOpenMap fun x => HAdd.hAdd x a","decl":"@[to_additive]\ntheorem isOpenMap_mul_right (a : G) : IsOpenMap (Â· * a) :=\n  (Homeomorph.mulRight a).isOpenMap\n\n"}
{"name":"IsOpen.rightCoset","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : ContinuousMul G\nU : Set G\nh : IsOpen U\nx : G\nâŠ¢ IsOpen (HSMul.hSMul (MulOpposite.op x) U)","decl":"@[to_additive IsOpen.right_addCoset]\ntheorem IsOpen.rightCoset {U : Set G} (h : IsOpen U) (x : G) : IsOpen (op x â€¢ U) :=\n  isOpenMap_mul_right x _ h\n\n"}
{"name":"IsOpen.right_addCoset","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : ContinuousAdd G\nU : Set G\nh : IsOpen U\nx : G\nâŠ¢ IsOpen (HVAdd.hVAdd (AddOpposite.op x) U)","decl":"@[to_additive IsOpen.right_addCoset]\ntheorem IsOpen.rightCoset {U : Set G} (h : IsOpen U) (x : G) : IsOpen (op x â€¢ U) :=\n  isOpenMap_mul_right x _ h\n\n"}
{"name":"isClosedMap_add_right","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : ContinuousAdd G\na : G\nâŠ¢ IsClosedMap fun x => HAdd.hAdd x a","decl":"@[to_additive]\ntheorem isClosedMap_mul_right (a : G) : IsClosedMap (Â· * a) :=\n  (Homeomorph.mulRight a).isClosedMap\n\n"}
{"name":"isClosedMap_mul_right","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : ContinuousMul G\na : G\nâŠ¢ IsClosedMap fun x => HMul.hMul x a","decl":"@[to_additive]\ntheorem isClosedMap_mul_right (a : G) : IsClosedMap (Â· * a) :=\n  (Homeomorph.mulRight a).isClosedMap\n\n"}
{"name":"IsClosed.rightCoset","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : ContinuousMul G\nU : Set G\nh : IsClosed U\nx : G\nâŠ¢ IsClosed (HSMul.hSMul (MulOpposite.op x) U)","decl":"@[to_additive IsClosed.right_addCoset]\ntheorem IsClosed.rightCoset {U : Set G} (h : IsClosed U) (x : G) : IsClosed (op x â€¢ U) :=\n  isClosedMap_mul_right x _ h\n\n"}
{"name":"IsClosed.right_addCoset","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : ContinuousAdd G\nU : Set G\nh : IsClosed U\nx : G\nâŠ¢ IsClosed (HVAdd.hVAdd (AddOpposite.op x) U)","decl":"@[to_additive IsClosed.right_addCoset]\ntheorem IsClosed.rightCoset {U : Set G} (h : IsClosed U) (x : G) : IsClosed (op x â€¢ U) :=\n  isClosedMap_mul_right x _ h\n\n"}
{"name":"discreteTopology_of_isOpen_singleton_zero","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : ContinuousAdd G\nh : IsOpen (Singleton.singleton 0)\nâŠ¢ DiscreteTopology G","decl":"@[to_additive]\ntheorem discreteTopology_of_isOpen_singleton_one (h : IsOpen ({1} : Set G)) :\n    DiscreteTopology G := by\n  rw [â† singletons_open_iff_discrete]\n  intro g\n  suffices {g} = (gâ»Â¹ * Â·) â»Â¹' {1} by\n    rw [this]\n    exact (continuous_mul_left gâ»Â¹).isOpen_preimage _ h\n  simp only [mul_one, Set.preimage_mul_left_singleton, eq_self_iff_true, inv_inv,\n    Set.singleton_eq_singleton_iff]\n\n"}
{"name":"discreteTopology_of_isOpen_singleton_one","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : ContinuousMul G\nh : IsOpen (Singleton.singleton 1)\nâŠ¢ DiscreteTopology G","decl":"@[to_additive]\ntheorem discreteTopology_of_isOpen_singleton_one (h : IsOpen ({1} : Set G)) :\n    DiscreteTopology G := by\n  rw [â† singletons_open_iff_discrete]\n  intro g\n  suffices {g} = (gâ»Â¹ * Â·) â»Â¹' {1} by\n    rw [this]\n    exact (continuous_mul_left gâ»Â¹).isOpen_preimage _ h\n  simp only [mul_one, Set.preimage_mul_left_singleton, eq_self_iff_true, inv_inv,\n    Set.singleton_eq_singleton_iff]\n\n"}
{"name":"discreteTopology_iff_isOpen_singleton_zero","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : ContinuousAdd G\nâŠ¢ Iff (DiscreteTopology G) (IsOpen (Singleton.singleton 0))","decl":"@[to_additive]\ntheorem discreteTopology_iff_isOpen_singleton_one : DiscreteTopology G â†” IsOpen ({1} : Set G) :=\n  âŸ¨fun h => forall_open_iff_discrete.mpr h {1}, discreteTopology_of_isOpen_singleton_oneâŸ©\n\n"}
{"name":"discreteTopology_iff_isOpen_singleton_one","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : ContinuousMul G\nâŠ¢ Iff (DiscreteTopology G) (IsOpen (Singleton.singleton 1))","decl":"@[to_additive]\ntheorem discreteTopology_iff_isOpen_singleton_one : DiscreteTopology G â†” IsOpen ({1} : Set G) :=\n  âŸ¨fun h => forall_open_iff_discrete.mpr h {1}, discreteTopology_of_isOpen_singleton_oneâŸ©\n\n"}
{"name":"ContinuousNeg.continuous_neg","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type u\ninstâœÂ¹ : TopologicalSpace G\ninstâœ : Neg G\nself : ContinuousNeg G\nâŠ¢ Continuous fun a => Neg.neg a","decl":"/-- Basic hypothesis to talk about a topological additive group. A topological additive group\nover `M`, for example, is obtained by requiring the instances `AddGroup M` and\n`ContinuousAdd M` and `ContinuousNeg M`. -/\nclass ContinuousNeg (G : Type u) [TopologicalSpace G] [Neg G] : Prop where\n  continuous_neg : Continuous fun a : G => -a\n\n"}
{"name":"ContinuousInv.continuous_inv","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type u\ninstâœÂ¹ : TopologicalSpace G\ninstâœ : Inv G\nself : ContinuousInv G\nâŠ¢ Continuous fun a => Inv.inv a","decl":"/-- Basic hypothesis to talk about a topological group. A topological group over `M`, for example,\nis obtained by requiring the instances `Group M` and `ContinuousMul M` and\n`ContinuousInv M`. -/\n@[to_additive (attr := continuity)]\nclass ContinuousInv (G : Type u) [TopologicalSpace G] [Inv G] : Prop where\n  continuous_inv : Continuous fun a : G => aâ»Â¹\n\n"}
{"name":"ContinuousNeg.induced","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nF : Type u_3\ninstâœâ´ : FunLike F Î± Î²\ninstâœÂ³ : AddGroup Î±\ninstâœÂ² : AddGroup Î²\ninstâœÂ¹ : AddMonoidHomClass F Î± Î²\ntÎ² : TopologicalSpace Î²\ninstâœ : ContinuousNeg Î²\nf : F\nâŠ¢ ContinuousNeg Î±","decl":"@[to_additive]\ntheorem ContinuousInv.induced {Î± : Type*} {Î² : Type*} {F : Type*} [FunLike F Î± Î²] [Group Î±]\n    [Group Î²] [MonoidHomClass F Î± Î²] [tÎ² : TopologicalSpace Î²] [ContinuousInv Î²] (f : F) :\n    @ContinuousInv Î± (tÎ².induced f) _ := by\n  let _tÎ± := tÎ².induced f\n  refine âŸ¨continuous_induced_rng.2 ?_âŸ©\n  simp only [Function.comp_def, map_inv]\n  fun_prop\n\n"}
{"name":"ContinuousInv.induced","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nF : Type u_3\ninstâœâ´ : FunLike F Î± Î²\ninstâœÂ³ : Group Î±\ninstâœÂ² : Group Î²\ninstâœÂ¹ : MonoidHomClass F Î± Î²\ntÎ² : TopologicalSpace Î²\ninstâœ : ContinuousInv Î²\nf : F\nâŠ¢ ContinuousInv Î±","decl":"@[to_additive]\ntheorem ContinuousInv.induced {Î± : Type*} {Î² : Type*} {F : Type*} [FunLike F Î± Î²] [Group Î±]\n    [Group Î²] [MonoidHomClass F Î± Î²] [tÎ² : TopologicalSpace Î²] [ContinuousInv Î²] (f : F) :\n    @ContinuousInv Î± (tÎ².induced f) _ := by\n  let _tÎ± := tÎ².induced f\n  refine âŸ¨continuous_induced_rng.2 ?_âŸ©\n  simp only [Function.comp_def, map_inv]\n  fun_prop\n\n"}
{"name":"Specializes.inv","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Inv G\ninstâœ : ContinuousInv G\nx y : G\nh : Specializes x y\nâŠ¢ Specializes (Inv.inv x) (Inv.inv y)","decl":"@[to_additive]\nprotected theorem Specializes.inv {x y : G} (h : x â¤³ y) : (xâ»Â¹) â¤³ (yâ»Â¹) :=\n  h.map continuous_inv\n\n"}
{"name":"Specializes.neg","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Neg G\ninstâœ : ContinuousNeg G\nx y : G\nh : Specializes x y\nâŠ¢ Specializes (Neg.neg x) (Neg.neg y)","decl":"@[to_additive]\nprotected theorem Specializes.inv {x y : G} (h : x â¤³ y) : (xâ»Â¹) â¤³ (yâ»Â¹) :=\n  h.map continuous_inv\n\n"}
{"name":"Inseparable.inv","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Inv G\ninstâœ : ContinuousInv G\nx y : G\nh : Inseparable x y\nâŠ¢ Inseparable (Inv.inv x) (Inv.inv y)","decl":"@[to_additive]\nprotected theorem Inseparable.inv {x y : G} (h : Inseparable x y) : Inseparable (xâ»Â¹) (yâ»Â¹) :=\n  h.map continuous_inv\n\n"}
{"name":"Inseparable.neg","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Neg G\ninstâœ : ContinuousNeg G\nx y : G\nh : Inseparable x y\nâŠ¢ Inseparable (Neg.neg x) (Neg.neg y)","decl":"@[to_additive]\nprotected theorem Inseparable.inv {x y : G} (h : Inseparable x y) : Inseparable (xâ»Â¹) (yâ»Â¹) :=\n  h.map continuous_inv\n\n"}
{"name":"Specializes.zsmul","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type u_1\ninstâœÂ³ : SubNegMonoid G\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : ContinuousAdd G\ninstâœ : ContinuousNeg G\nx y : G\nh : Specializes x y\nm : Int\nâŠ¢ Specializes (HSMul.hSMul m x) (HSMul.hSMul m y)","decl":"@[to_additive]\nprotected theorem Specializes.zpow {G : Type*} [DivInvMonoid G] [TopologicalSpace G]\n    [ContinuousMul G] [ContinuousInv G] {x y : G} (h : x â¤³ y) : âˆ€ m : â„¤, (x ^ m) â¤³ (y ^ m)\n  | .ofNat n => by simpa using h.pow n\n  | .negSucc n => by simpa using (h.pow (n + 1)).inv\n\n"}
{"name":"Specializes.zpow","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type u_1\ninstâœÂ³ : DivInvMonoid G\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : ContinuousMul G\ninstâœ : ContinuousInv G\nx y : G\nh : Specializes x y\nm : Int\nâŠ¢ Specializes (HPow.hPow x m) (HPow.hPow y m)","decl":"@[to_additive]\nprotected theorem Specializes.zpow {G : Type*} [DivInvMonoid G] [TopologicalSpace G]\n    [ContinuousMul G] [ContinuousInv G] {x y : G} (h : x â¤³ y) : âˆ€ m : â„¤, (x ^ m) â¤³ (y ^ m)\n  | .ofNat n => by simpa using h.pow n\n  | .negSucc n => by simpa using (h.pow (n + 1)).inv\n\n"}
{"name":"Inseparable.zpow","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type u_1\ninstâœÂ³ : DivInvMonoid G\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : ContinuousMul G\ninstâœ : ContinuousInv G\nx y : G\nh : Inseparable x y\nm : Int\nâŠ¢ Inseparable (HPow.hPow x m) (HPow.hPow y m)","decl":"@[to_additive]\nprotected theorem Inseparable.zpow {G : Type*} [DivInvMonoid G] [TopologicalSpace G]\n    [ContinuousMul G] [ContinuousInv G] {x y : G} (h : Inseparable x y) (m : â„¤) :\n    Inseparable (x ^ m) (y ^ m) :=\n  (h.specializes.zpow m).antisymm (h.specializes'.zpow m)\n\n"}
{"name":"Inseparable.zsmul","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type u_1\ninstâœÂ³ : SubNegMonoid G\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : ContinuousAdd G\ninstâœ : ContinuousNeg G\nx y : G\nh : Inseparable x y\nm : Int\nâŠ¢ Inseparable (HSMul.hSMul m x) (HSMul.hSMul m y)","decl":"@[to_additive]\nprotected theorem Inseparable.zpow {G : Type*} [DivInvMonoid G] [TopologicalSpace G]\n    [ContinuousMul G] [ContinuousInv G] {x y : G} (h : Inseparable x y) (m : â„¤) :\n    Inseparable (x ^ m) (y ^ m) :=\n  (h.specializes.zpow m).antisymm (h.specializes'.zpow m)\n\n"}
{"name":"instContinuousNegULift","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Neg G\ninstâœ : ContinuousNeg G\nâŠ¢ ContinuousNeg (ULift.{u_1, w} G)","decl":"@[to_additive]\ninstance : ContinuousInv (ULift G) :=\n  âŸ¨continuous_uLift_up.comp (continuous_inv.comp continuous_uLift_down)âŸ©\n\n"}
{"name":"instContinuousInvULift","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Inv G\ninstâœ : ContinuousInv G\nâŠ¢ ContinuousInv (ULift.{u_1, w} G)","decl":"@[to_additive]\ninstance : ContinuousInv (ULift G) :=\n  âŸ¨continuous_uLift_up.comp (continuous_inv.comp continuous_uLift_down)âŸ©\n\n"}
{"name":"continuousOn_neg","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Neg G\ninstâœ : ContinuousNeg G\ns : Set G\nâŠ¢ ContinuousOn Neg.neg s","decl":"@[to_additive]\ntheorem continuousOn_inv {s : Set G} : ContinuousOn Inv.inv s :=\n  continuous_inv.continuousOn\n\n"}
{"name":"continuousOn_inv","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Inv G\ninstâœ : ContinuousInv G\ns : Set G\nâŠ¢ ContinuousOn Inv.inv s","decl":"@[to_additive]\ntheorem continuousOn_inv {s : Set G} : ContinuousOn Inv.inv s :=\n  continuous_inv.continuousOn\n\n"}
{"name":"continuousWithinAt_inv","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Inv G\ninstâœ : ContinuousInv G\ns : Set G\nx : G\nâŠ¢ ContinuousWithinAt Inv.inv s x","decl":"@[to_additive]\ntheorem continuousWithinAt_inv {s : Set G} {x : G} : ContinuousWithinAt Inv.inv s x :=\n  continuous_inv.continuousWithinAt\n\n"}
{"name":"continuousWithinAt_neg","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Neg G\ninstâœ : ContinuousNeg G\ns : Set G\nx : G\nâŠ¢ ContinuousWithinAt Neg.neg s x","decl":"@[to_additive]\ntheorem continuousWithinAt_inv {s : Set G} {x : G} : ContinuousWithinAt Inv.inv s x :=\n  continuous_inv.continuousWithinAt\n\n"}
{"name":"continuousAt_neg","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Neg G\ninstâœ : ContinuousNeg G\nx : G\nâŠ¢ ContinuousAt Neg.neg x","decl":"@[to_additive]\ntheorem continuousAt_inv {x : G} : ContinuousAt Inv.inv x :=\n  continuous_inv.continuousAt\n\n"}
{"name":"continuousAt_inv","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Inv G\ninstâœ : ContinuousInv G\nx : G\nâŠ¢ ContinuousAt Inv.inv x","decl":"@[to_additive]\ntheorem continuousAt_inv {x : G} : ContinuousAt Inv.inv x :=\n  continuous_inv.continuousAt\n\n"}
{"name":"tendsto_inv","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Inv G\ninstâœ : ContinuousInv G\na : G\nâŠ¢ Filter.Tendsto Inv.inv (nhds a) (nhds (Inv.inv a))","decl":"@[to_additive]\ntheorem tendsto_inv (a : G) : Tendsto Inv.inv (ð“ a) (ð“ aâ»Â¹) :=\n  continuousAt_inv\n\n"}
{"name":"tendsto_neg","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Neg G\ninstâœ : ContinuousNeg G\na : G\nâŠ¢ Filter.Tendsto Neg.neg (nhds a) (nhds (Neg.neg a))","decl":"@[to_additive]\ntheorem tendsto_inv (a : G) : Tendsto Inv.inv (ð“ a) (ð“ aâ»Â¹) :=\n  continuousAt_inv\n\n"}
{"name":"Filter.Tendsto.neg","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\nÎ± : Type u\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Neg G\ninstâœ : ContinuousNeg G\nf : Î± â†’ G\nl : Filter Î±\ny : G\nh : Filter.Tendsto f l (nhds y)\nâŠ¢ Filter.Tendsto (fun x => Neg.neg (f x)) l (nhds (Neg.neg y))","decl":"/-- If a function converges to a value in a multiplicative topological group, then its inverse\nconverges to the inverse of this value. For the version in normed fields assuming additionally\nthat the limit is nonzero, use `Tendsto.inv'`. -/\n@[to_additive\n  \"If a function converges to a value in an additive topological group, then its\n  negation converges to the negation of this value.\"]\ntheorem Filter.Tendsto.inv {f : Î± â†’ G} {l : Filter Î±} {y : G} (h : Tendsto f l (ð“ y)) :\n    Tendsto (fun x => (f x)â»Â¹) l (ð“ yâ»Â¹) :=\n  (continuous_inv.tendsto y).comp h\n\n"}
{"name":"Filter.Tendsto.inv","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\nÎ± : Type u\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Inv G\ninstâœ : ContinuousInv G\nf : Î± â†’ G\nl : Filter Î±\ny : G\nh : Filter.Tendsto f l (nhds y)\nâŠ¢ Filter.Tendsto (fun x => Inv.inv (f x)) l (nhds (Inv.inv y))","decl":"/-- If a function converges to a value in a multiplicative topological group, then its inverse\nconverges to the inverse of this value. For the version in normed fields assuming additionally\nthat the limit is nonzero, use `Tendsto.inv'`. -/\n@[to_additive\n  \"If a function converges to a value in an additive topological group, then its\n  negation converges to the negation of this value.\"]\ntheorem Filter.Tendsto.inv {f : Î± â†’ G} {l : Filter Î±} {y : G} (h : Tendsto f l (ð“ y)) :\n    Tendsto (fun x => (f x)â»Â¹) l (ð“ yâ»Â¹) :=\n  (continuous_inv.tendsto y).comp h\n\n"}
{"name":"Continuous.inv","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\nÎ± : Type u\ninstâœÂ³ : TopologicalSpace G\ninstâœÂ² : Inv G\ninstâœÂ¹ : ContinuousInv G\ninstâœ : TopologicalSpace Î±\nf : Î± â†’ G\nhf : Continuous f\nâŠ¢ Continuous fun x => Inv.inv (f x)","decl":"@[to_additive (attr := continuity, fun_prop)]\ntheorem Continuous.inv (hf : Continuous f) : Continuous fun x => (f x)â»Â¹ :=\n  continuous_inv.comp hf\n\n"}
{"name":"Continuous.neg","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\nÎ± : Type u\ninstâœÂ³ : TopologicalSpace G\ninstâœÂ² : Neg G\ninstâœÂ¹ : ContinuousNeg G\ninstâœ : TopologicalSpace Î±\nf : Î± â†’ G\nhf : Continuous f\nâŠ¢ Continuous fun x => Neg.neg (f x)","decl":"@[to_additive (attr := continuity, fun_prop)]\ntheorem Continuous.inv (hf : Continuous f) : Continuous fun x => (f x)â»Â¹ :=\n  continuous_inv.comp hf\n\n"}
{"name":"ContinuousAt.inv","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\nÎ± : Type u\ninstâœÂ³ : TopologicalSpace G\ninstâœÂ² : Inv G\ninstâœÂ¹ : ContinuousInv G\ninstâœ : TopologicalSpace Î±\nf : Î± â†’ G\nx : Î±\nhf : ContinuousAt f x\nâŠ¢ ContinuousAt (fun x => Inv.inv (f x)) x","decl":"@[to_additive (attr := fun_prop)]\ntheorem ContinuousAt.inv (hf : ContinuousAt f x) : ContinuousAt (fun x => (f x)â»Â¹) x :=\n  continuousAt_inv.comp hf\n\n"}
{"name":"ContinuousAt.neg","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\nÎ± : Type u\ninstâœÂ³ : TopologicalSpace G\ninstâœÂ² : Neg G\ninstâœÂ¹ : ContinuousNeg G\ninstâœ : TopologicalSpace Î±\nf : Î± â†’ G\nx : Î±\nhf : ContinuousAt f x\nâŠ¢ ContinuousAt (fun x => Neg.neg (f x)) x","decl":"@[to_additive (attr := fun_prop)]\ntheorem ContinuousAt.inv (hf : ContinuousAt f x) : ContinuousAt (fun x => (f x)â»Â¹) x :=\n  continuousAt_inv.comp hf\n\n"}
{"name":"ContinuousOn.neg","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\nÎ± : Type u\ninstâœÂ³ : TopologicalSpace G\ninstâœÂ² : Neg G\ninstâœÂ¹ : ContinuousNeg G\ninstâœ : TopologicalSpace Î±\nf : Î± â†’ G\ns : Set Î±\nhf : ContinuousOn f s\nâŠ¢ ContinuousOn (fun x => Neg.neg (f x)) s","decl":"@[to_additive (attr := fun_prop)]\ntheorem ContinuousOn.inv (hf : ContinuousOn f s) : ContinuousOn (fun x => (f x)â»Â¹) s :=\n  continuous_inv.comp_continuousOn hf\n\n"}
{"name":"ContinuousOn.inv","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\nÎ± : Type u\ninstâœÂ³ : TopologicalSpace G\ninstâœÂ² : Inv G\ninstâœÂ¹ : ContinuousInv G\ninstâœ : TopologicalSpace Î±\nf : Î± â†’ G\ns : Set Î±\nhf : ContinuousOn f s\nâŠ¢ ContinuousOn (fun x => Inv.inv (f x)) s","decl":"@[to_additive (attr := fun_prop)]\ntheorem ContinuousOn.inv (hf : ContinuousOn f s) : ContinuousOn (fun x => (f x)â»Â¹) s :=\n  continuous_inv.comp_continuousOn hf\n\n"}
{"name":"ContinuousWithinAt.inv","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\nÎ± : Type u\ninstâœÂ³ : TopologicalSpace G\ninstâœÂ² : Inv G\ninstâœÂ¹ : ContinuousInv G\ninstâœ : TopologicalSpace Î±\nf : Î± â†’ G\ns : Set Î±\nx : Î±\nhf : ContinuousWithinAt f s x\nâŠ¢ ContinuousWithinAt (fun x => Inv.inv (f x)) s x","decl":"@[to_additive]\ntheorem ContinuousWithinAt.inv (hf : ContinuousWithinAt f s x) :\n    ContinuousWithinAt (fun x => (f x)â»Â¹) s x :=\n  Filter.Tendsto.inv hf\n\n"}
{"name":"ContinuousWithinAt.neg","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\nÎ± : Type u\ninstâœÂ³ : TopologicalSpace G\ninstâœÂ² : Neg G\ninstâœÂ¹ : ContinuousNeg G\ninstâœ : TopologicalSpace Î±\nf : Î± â†’ G\ns : Set Î±\nx : Î±\nhf : ContinuousWithinAt f s x\nâŠ¢ ContinuousWithinAt (fun x => Neg.neg (f x)) s x","decl":"@[to_additive]\ntheorem ContinuousWithinAt.inv (hf : ContinuousWithinAt f s x) :\n    ContinuousWithinAt (fun x => (f x)â»Â¹) s x :=\n  Filter.Tendsto.inv hf\n\n"}
{"name":"OrderDual.instContinuousInv","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ¹ : TopologicalSpace G\ninstâœ : Inv G\nâŠ¢ ContinuousInv (OrderDual G)","decl":"@[to_additive]\ninstance OrderDual.instContinuousInv : ContinuousInv Gáµ’áµˆ := â€¹ContinuousInv Gâ€º\n\n"}
{"name":"OrderDual.instContinuousNeg","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ¹ : TopologicalSpace G\ninstâœ : Neg G\nâŠ¢ ContinuousNeg (OrderDual G)","decl":"@[to_additive]\ninstance OrderDual.instContinuousInv : ContinuousInv Gáµ’áµˆ := â€¹ContinuousInv Gâ€º\n\n"}
{"name":"Prod.continuousNeg","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\nH : Type x\ninstâœâµ : TopologicalSpace G\ninstâœâ´ : Neg G\ninstâœÂ³ : ContinuousNeg G\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : Neg H\ninstâœ : ContinuousNeg H\nâŠ¢ ContinuousNeg (Prod G H)","decl":"@[to_additive]\ninstance Prod.continuousInv [TopologicalSpace H] [Inv H] [ContinuousInv H] :\n    ContinuousInv (G Ã— H) :=\n  âŸ¨continuous_inv.fst'.prod_mk continuous_inv.snd'âŸ©\n\n"}
{"name":"Prod.continuousInv","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\nH : Type x\ninstâœâµ : TopologicalSpace G\ninstâœâ´ : Inv G\ninstâœÂ³ : ContinuousInv G\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : Inv H\ninstâœ : ContinuousInv H\nâŠ¢ ContinuousInv (Prod G H)","decl":"@[to_additive]\ninstance Prod.continuousInv [TopologicalSpace H] [Inv H] [ContinuousInv H] :\n    ContinuousInv (G Ã— H) :=\n  âŸ¨continuous_inv.fst'.prod_mk continuous_inv.snd'âŸ©\n\n"}
{"name":"Pi.continuousInv","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î¹ : Type u_1\nC : Î¹ â†’ Type u_2\ninstâœÂ² : (i : Î¹) â†’ TopologicalSpace (C i)\ninstâœÂ¹ : (i : Î¹) â†’ Inv (C i)\ninstâœ : âˆ€ (i : Î¹), ContinuousInv (C i)\nâŠ¢ ContinuousInv ((i : Î¹) â†’ C i)","decl":"@[to_additive]\ninstance Pi.continuousInv {C : Î¹ â†’ Type*} [âˆ€ i, TopologicalSpace (C i)] [âˆ€ i, Inv (C i)]\n    [âˆ€ i, ContinuousInv (C i)] : ContinuousInv (âˆ€ i, C i) where\n  continuous_inv := continuous_pi fun i => (continuous_apply i).inv\n\n"}
{"name":"Pi.continuousNeg","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î¹ : Type u_1\nC : Î¹ â†’ Type u_2\ninstâœÂ² : (i : Î¹) â†’ TopologicalSpace (C i)\ninstâœÂ¹ : (i : Î¹) â†’ Neg (C i)\ninstâœ : âˆ€ (i : Î¹), ContinuousNeg (C i)\nâŠ¢ ContinuousNeg ((i : Î¹) â†’ C i)","decl":"@[to_additive]\ninstance Pi.continuousInv {C : Î¹ â†’ Type*} [âˆ€ i, TopologicalSpace (C i)] [âˆ€ i, Inv (C i)]\n    [âˆ€ i, ContinuousInv (C i)] : ContinuousInv (âˆ€ i, C i) where\n  continuous_inv := continuous_pi fun i => (continuous_apply i).inv\n\n"}
{"name":"Pi.has_continuous_neg'","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Neg G\ninstâœ : ContinuousNeg G\nÎ¹ : Type u_1\nâŠ¢ ContinuousNeg (Î¹ â†’ G)","decl":"/-- A version of `Pi.continuousInv` for non-dependent functions. It is needed because sometimes\nLean fails to use `Pi.continuousInv` for non-dependent functions. -/\n@[to_additive\n  \"A version of `Pi.continuousNeg` for non-dependent functions. It is needed\n  because sometimes Lean fails to use `Pi.continuousNeg` for non-dependent functions.\"]\ninstance Pi.has_continuous_inv' : ContinuousInv (Î¹ â†’ G) :=\n  Pi.continuousInv\n\n"}
{"name":"Pi.has_continuous_inv'","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Inv G\ninstâœ : ContinuousInv G\nÎ¹ : Type u_1\nâŠ¢ ContinuousInv (Î¹ â†’ G)","decl":"/-- A version of `Pi.continuousInv` for non-dependent functions. It is needed because sometimes\nLean fails to use `Pi.continuousInv` for non-dependent functions. -/\n@[to_additive\n  \"A version of `Pi.continuousNeg` for non-dependent functions. It is needed\n  because sometimes Lean fails to use `Pi.continuousNeg` for non-dependent functions.\"]\ninstance Pi.has_continuous_inv' : ContinuousInv (Î¹ â†’ G) :=\n  Pi.continuousInv\n\n"}
{"name":"continuousInv_of_discreteTopology","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"H : Type x\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : Inv H\ninstâœ : DiscreteTopology H\nâŠ¢ ContinuousInv H","decl":"@[to_additive]\ninstance (priority := 100) continuousInv_of_discreteTopology [TopologicalSpace H] [Inv H]\n    [DiscreteTopology H] : ContinuousInv H :=\n  âŸ¨continuous_of_discreteTopologyâŸ©\n\n"}
{"name":"continuousNeg_of_discreteTopology","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"H : Type x\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : Neg H\ninstâœ : DiscreteTopology H\nâŠ¢ ContinuousNeg H","decl":"@[to_additive]\ninstance (priority := 100) continuousInv_of_discreteTopology [TopologicalSpace H] [Inv H]\n    [DiscreteTopology H] : ContinuousInv H :=\n  âŸ¨continuous_of_discreteTopologyâŸ©\n\n"}
{"name":"isClosed_setOf_map_neg","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Gâ‚ : Type u_2\nGâ‚‚ : Type u_3\ninstâœâ´ : TopologicalSpace Gâ‚‚\ninstâœÂ³ : T2Space Gâ‚‚\ninstâœÂ² : Neg Gâ‚\ninstâœÂ¹ : Neg Gâ‚‚\ninstâœ : ContinuousNeg Gâ‚‚\nâŠ¢ IsClosed (setOf fun f => âˆ€ (x : Gâ‚), Eq (f (Neg.neg x)) (Neg.neg (f x)))","decl":"@[to_additive]\ntheorem isClosed_setOf_map_inv [Inv Gâ‚] [Inv Gâ‚‚] [ContinuousInv Gâ‚‚] :\n    IsClosed { f : Gâ‚ â†’ Gâ‚‚ | âˆ€ x, f xâ»Â¹ = (f x)â»Â¹ } := by\n  simp only [setOf_forall]\n  exact isClosed_iInter fun i => isClosed_eq (continuous_apply _) (continuous_apply _).inv\n\n"}
{"name":"isClosed_setOf_map_inv","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Gâ‚ : Type u_2\nGâ‚‚ : Type u_3\ninstâœâ´ : TopologicalSpace Gâ‚‚\ninstâœÂ³ : T2Space Gâ‚‚\ninstâœÂ² : Inv Gâ‚\ninstâœÂ¹ : Inv Gâ‚‚\ninstâœ : ContinuousInv Gâ‚‚\nâŠ¢ IsClosed (setOf fun f => âˆ€ (x : Gâ‚), Eq (f (Inv.inv x)) (Inv.inv (f x)))","decl":"@[to_additive]\ntheorem isClosed_setOf_map_inv [Inv Gâ‚] [Inv Gâ‚‚] [ContinuousInv Gâ‚‚] :\n    IsClosed { f : Gâ‚ â†’ Gâ‚‚ | âˆ€ x, f xâ»Â¹ = (f x)â»Â¹ } := by\n  simp only [setOf_forall]\n  exact isClosed_iInter fun i => isClosed_eq (continuous_apply _) (continuous_apply _).inv\n\n"}
{"name":"instContinuousNegAdditiveOfContinuousInv","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"H : Type x\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : Inv H\ninstâœ : ContinuousInv H\nâŠ¢ ContinuousNeg (Additive H)","decl":"instance [TopologicalSpace H] [Inv H] [ContinuousInv H] : ContinuousNeg (Additive H) where\n  continuous_neg := @continuous_inv H _ _ _\n\n"}
{"name":"instContinuousInvMultiplicativeOfContinuousNeg","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"H : Type x\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : Neg H\ninstâœ : ContinuousNeg H\nâŠ¢ ContinuousInv (Multiplicative H)","decl":"instance [TopologicalSpace H] [Neg H] [ContinuousNeg H] : ContinuousInv (Multiplicative H) where\n  continuous_inv := @continuous_neg H _ _ _\n\n"}
{"name":"IsCompact.neg","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : InvolutiveNeg G\ninstâœ : ContinuousNeg G\ns : Set G\nhs : IsCompact s\nâŠ¢ IsCompact (Neg.neg s)","decl":"@[to_additive]\ntheorem IsCompact.inv (hs : IsCompact s) : IsCompact sâ»Â¹ := by\n  rw [â† image_inv_eq_inv]\n  exact hs.image continuous_inv\n\n"}
{"name":"IsCompact.inv","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : InvolutiveInv G\ninstâœ : ContinuousInv G\ns : Set G\nhs : IsCompact s\nâŠ¢ IsCompact (Inv.inv s)","decl":"@[to_additive]\ntheorem IsCompact.inv (hs : IsCompact s) : IsCompact sâ»Â¹ := by\n  rw [â† image_inv_eq_inv]\n  exact hs.image continuous_inv\n\n"}
{"name":"Homeomorph.coe_neg","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type u_1\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : InvolutiveNeg G\ninstâœ : ContinuousNeg G\nâŠ¢ Eq (â‡‘(Homeomorph.neg G)) Neg.neg","decl":"@[to_additive (attr := simp)]\nlemma Homeomorph.coe_inv {G : Type*} [TopologicalSpace G] [InvolutiveInv G] [ContinuousInv G] :\n    â‡‘(Homeomorph.inv G) = Inv.inv := rfl\n\n"}
{"name":"Homeomorph.coe_inv","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type u_1\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : InvolutiveInv G\ninstâœ : ContinuousInv G\nâŠ¢ Eq (â‡‘(Homeomorph.inv G)) Inv.inv","decl":"@[to_additive (attr := simp)]\nlemma Homeomorph.coe_inv {G : Type*} [TopologicalSpace G] [InvolutiveInv G] [ContinuousInv G] :\n    â‡‘(Homeomorph.inv G) = Inv.inv := rfl\n\n"}
{"name":"nhds_neg","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : InvolutiveNeg G\ninstâœ : ContinuousNeg G\na : G\nâŠ¢ Eq (nhds (Neg.neg a)) (Neg.neg (nhds a))","decl":"@[to_additive]\ntheorem nhds_inv (a : G) : ð“ aâ»Â¹ = (ð“ a)â»Â¹ :=\n  ((Homeomorph.inv G).map_nhds_eq a).symm\n\n"}
{"name":"nhds_inv","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : InvolutiveInv G\ninstâœ : ContinuousInv G\na : G\nâŠ¢ Eq (nhds (Inv.inv a)) (Inv.inv (nhds a))","decl":"@[to_additive]\ntheorem nhds_inv (a : G) : ð“ aâ»Â¹ = (ð“ a)â»Â¹ :=\n  ((Homeomorph.inv G).map_nhds_eq a).symm\n\n"}
{"name":"isOpenMap_inv","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : InvolutiveInv G\ninstâœ : ContinuousInv G\nâŠ¢ IsOpenMap Inv.inv","decl":"@[to_additive]\ntheorem isOpenMap_inv : IsOpenMap (Inv.inv : G â†’ G) :=\n  (Homeomorph.inv _).isOpenMap\n\n"}
{"name":"isOpenMap_neg","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : InvolutiveNeg G\ninstâœ : ContinuousNeg G\nâŠ¢ IsOpenMap Neg.neg","decl":"@[to_additive]\ntheorem isOpenMap_inv : IsOpenMap (Inv.inv : G â†’ G) :=\n  (Homeomorph.inv _).isOpenMap\n\n"}
{"name":"isClosedMap_inv","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : InvolutiveInv G\ninstâœ : ContinuousInv G\nâŠ¢ IsClosedMap Inv.inv","decl":"@[to_additive]\ntheorem isClosedMap_inv : IsClosedMap (Inv.inv : G â†’ G) :=\n  (Homeomorph.inv _).isClosedMap\n\n"}
{"name":"isClosedMap_neg","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : InvolutiveNeg G\ninstâœ : ContinuousNeg G\nâŠ¢ IsClosedMap Neg.neg","decl":"@[to_additive]\ntheorem isClosedMap_inv : IsClosedMap (Inv.inv : G â†’ G) :=\n  (Homeomorph.inv _).isClosedMap\n\n"}
{"name":"IsOpen.neg","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : InvolutiveNeg G\ninstâœ : ContinuousNeg G\ns : Set G\nhs : IsOpen s\nâŠ¢ IsOpen (Neg.neg s)","decl":"@[to_additive]\ntheorem IsOpen.inv (hs : IsOpen s) : IsOpen sâ»Â¹ :=\n  hs.preimage continuous_inv\n\n"}
{"name":"IsOpen.inv","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : InvolutiveInv G\ninstâœ : ContinuousInv G\ns : Set G\nhs : IsOpen s\nâŠ¢ IsOpen (Inv.inv s)","decl":"@[to_additive]\ntheorem IsOpen.inv (hs : IsOpen s) : IsOpen sâ»Â¹ :=\n  hs.preimage continuous_inv\n\n"}
{"name":"IsClosed.neg","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : InvolutiveNeg G\ninstâœ : ContinuousNeg G\ns : Set G\nhs : IsClosed s\nâŠ¢ IsClosed (Neg.neg s)","decl":"@[to_additive]\ntheorem IsClosed.inv (hs : IsClosed s) : IsClosed sâ»Â¹ :=\n  hs.preimage continuous_inv\n\n"}
{"name":"IsClosed.inv","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : InvolutiveInv G\ninstâœ : ContinuousInv G\ns : Set G\nhs : IsClosed s\nâŠ¢ IsClosed (Inv.inv s)","decl":"@[to_additive]\ntheorem IsClosed.inv (hs : IsClosed s) : IsClosed sâ»Â¹ :=\n  hs.preimage continuous_inv\n\n"}
{"name":"neg_closure","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : InvolutiveNeg G\ninstâœ : ContinuousNeg G\ns : Set G\nâŠ¢ Eq (Neg.neg (closure s)) (closure (Neg.neg s))","decl":"@[to_additive]\ntheorem inv_closure : âˆ€ s : Set G, (closure s)â»Â¹ = closure sâ»Â¹ :=\n  (Homeomorph.inv G).preimage_closure\n\n"}
{"name":"inv_closure","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : InvolutiveInv G\ninstâœ : ContinuousInv G\ns : Set G\nâŠ¢ Eq (Inv.inv (closure s)) (closure (Inv.inv s))","decl":"@[to_additive]\ntheorem inv_closure : âˆ€ s : Set G, (closure s)â»Â¹ = closure sâ»Â¹ :=\n  (Homeomorph.inv G).preimage_closure\n\n"}
{"name":"continuous_inv_iff","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\nÎ± : Type u\ninstâœÂ³ : TopologicalSpace G\ninstâœÂ² : InvolutiveInv G\ninstâœÂ¹ : ContinuousInv G\ninstâœ : TopologicalSpace Î±\nf : Î± â†’ G\nâŠ¢ Iff (Continuous (Inv.inv f)) (Continuous f)","decl":"@[to_additive (attr := simp)]\nlemma continuous_inv_iff : Continuous fâ»Â¹ â†” Continuous f := (Homeomorph.inv G).comp_continuous_iff\n\n"}
{"name":"continuous_neg_iff","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\nÎ± : Type u\ninstâœÂ³ : TopologicalSpace G\ninstâœÂ² : InvolutiveNeg G\ninstâœÂ¹ : ContinuousNeg G\ninstâœ : TopologicalSpace Î±\nf : Î± â†’ G\nâŠ¢ Iff (Continuous (Neg.neg f)) (Continuous f)","decl":"@[to_additive (attr := simp)]\nlemma continuous_inv_iff : Continuous fâ»Â¹ â†” Continuous f := (Homeomorph.inv G).comp_continuous_iff\n\n"}
{"name":"continuousAt_inv_iff","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\nÎ± : Type u\ninstâœÂ³ : TopologicalSpace G\ninstâœÂ² : InvolutiveInv G\ninstâœÂ¹ : ContinuousInv G\ninstâœ : TopologicalSpace Î±\nf : Î± â†’ G\nx : Î±\nâŠ¢ Iff (ContinuousAt (Inv.inv f) x) (ContinuousAt f x)","decl":"@[to_additive (attr := simp)]\nlemma continuousAt_inv_iff : ContinuousAt fâ»Â¹ x â†” ContinuousAt f x :=\n  (Homeomorph.inv G).comp_continuousAt_iff _ _\n\n"}
{"name":"continuousAt_neg_iff","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\nÎ± : Type u\ninstâœÂ³ : TopologicalSpace G\ninstâœÂ² : InvolutiveNeg G\ninstâœÂ¹ : ContinuousNeg G\ninstâœ : TopologicalSpace Î±\nf : Î± â†’ G\nx : Î±\nâŠ¢ Iff (ContinuousAt (Neg.neg f) x) (ContinuousAt f x)","decl":"@[to_additive (attr := simp)]\nlemma continuousAt_inv_iff : ContinuousAt fâ»Â¹ x â†” ContinuousAt f x :=\n  (Homeomorph.inv G).comp_continuousAt_iff _ _\n\n"}
{"name":"continuousOn_inv_iff","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\nÎ± : Type u\ninstâœÂ³ : TopologicalSpace G\ninstâœÂ² : InvolutiveInv G\ninstâœÂ¹ : ContinuousInv G\ninstâœ : TopologicalSpace Î±\nf : Î± â†’ G\ns : Set Î±\nâŠ¢ Iff (ContinuousOn (Inv.inv f) s) (ContinuousOn f s)","decl":"@[to_additive (attr := simp)]\nlemma continuousOn_inv_iff : ContinuousOn fâ»Â¹ s â†” ContinuousOn f s :=\n  (Homeomorph.inv G).comp_continuousOn_iff _ _\n\n"}
{"name":"continuousOn_neg_iff","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\nÎ± : Type u\ninstâœÂ³ : TopologicalSpace G\ninstâœÂ² : InvolutiveNeg G\ninstâœÂ¹ : ContinuousNeg G\ninstâœ : TopologicalSpace Î±\nf : Î± â†’ G\ns : Set Î±\nâŠ¢ Iff (ContinuousOn (Neg.neg f) s) (ContinuousOn f s)","decl":"@[to_additive (attr := simp)]\nlemma continuousOn_inv_iff : ContinuousOn fâ»Â¹ s â†” ContinuousOn f s :=\n  (Homeomorph.inv G).comp_continuousOn_iff _ _\n\n"}
{"name":"Continuous.of_neg","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\nÎ± : Type u\ninstâœÂ³ : TopologicalSpace G\ninstâœÂ² : InvolutiveNeg G\ninstâœÂ¹ : ContinuousNeg G\ninstâœ : TopologicalSpace Î±\nf : Î± â†’ G\naâœ : Continuous (Neg.neg f)\nâŠ¢ Continuous f","decl":"@[to_additive] alias âŸ¨Continuous.of_inv, _âŸ© := continuous_inv_iff\n"}
{"name":"Continuous.of_inv","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\nÎ± : Type u\ninstâœÂ³ : TopologicalSpace G\ninstâœÂ² : InvolutiveInv G\ninstâœÂ¹ : ContinuousInv G\ninstâœ : TopologicalSpace Î±\nf : Î± â†’ G\naâœ : Continuous (Inv.inv f)\nâŠ¢ Continuous f","decl":"@[to_additive] alias âŸ¨Continuous.of_inv, _âŸ© := continuous_inv_iff\n"}
{"name":"ContinuousAt.of_neg","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\nÎ± : Type u\ninstâœÂ³ : TopologicalSpace G\ninstâœÂ² : InvolutiveNeg G\ninstâœÂ¹ : ContinuousNeg G\ninstâœ : TopologicalSpace Î±\nf : Î± â†’ G\nx : Î±\naâœ : ContinuousAt (Neg.neg f) x\nâŠ¢ ContinuousAt f x","decl":"@[to_additive] alias âŸ¨ContinuousAt.of_inv, _âŸ© := continuousAt_inv_iff\n"}
{"name":"ContinuousAt.of_inv","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\nÎ± : Type u\ninstâœÂ³ : TopologicalSpace G\ninstâœÂ² : InvolutiveInv G\ninstâœÂ¹ : ContinuousInv G\ninstâœ : TopologicalSpace Î±\nf : Î± â†’ G\nx : Î±\naâœ : ContinuousAt (Inv.inv f) x\nâŠ¢ ContinuousAt f x","decl":"@[to_additive] alias âŸ¨ContinuousAt.of_inv, _âŸ© := continuousAt_inv_iff\n"}
{"name":"ContinuousOn.of_neg","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\nÎ± : Type u\ninstâœÂ³ : TopologicalSpace G\ninstâœÂ² : InvolutiveNeg G\ninstâœÂ¹ : ContinuousNeg G\ninstâœ : TopologicalSpace Î±\nf : Î± â†’ G\ns : Set Î±\naâœ : ContinuousOn (Neg.neg f) s\nâŠ¢ ContinuousOn f s","decl":"@[to_additive] alias âŸ¨ContinuousOn.of_inv, _âŸ© := continuousOn_inv_iff\n\n"}
{"name":"ContinuousOn.of_inv","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\nÎ± : Type u\ninstâœÂ³ : TopologicalSpace G\ninstâœÂ² : InvolutiveInv G\ninstâœÂ¹ : ContinuousInv G\ninstâœ : TopologicalSpace Î±\nf : Î± â†’ G\ns : Set Î±\naâœ : ContinuousOn (Inv.inv f) s\nâŠ¢ ContinuousOn f s","decl":"@[to_additive] alias âŸ¨ContinuousOn.of_inv, _âŸ© := continuousOn_inv_iff\n\n"}
{"name":"continuousInv_sInf","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœ : Inv G\nts : Set (TopologicalSpace G)\nh : âˆ€ (t : TopologicalSpace G), Membership.mem ts t â†’ ContinuousInv G\nâŠ¢ ContinuousInv G","decl":"@[to_additive]\ntheorem continuousInv_sInf {ts : Set (TopologicalSpace G)}\n    (h : âˆ€ t âˆˆ ts, @ContinuousInv G t _) : @ContinuousInv G (sInf ts) _ :=\n  letI := sInf ts\n  { continuous_inv :=\n      continuous_sInf_rng.2 fun t ht =>\n        continuous_sInf_dom ht (@ContinuousInv.continuous_inv G t _ (h t ht)) }\n\n"}
{"name":"continuousNeg_sInf","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœ : Neg G\nts : Set (TopologicalSpace G)\nh : âˆ€ (t : TopologicalSpace G), Membership.mem ts t â†’ ContinuousNeg G\nâŠ¢ ContinuousNeg G","decl":"@[to_additive]\ntheorem continuousInv_sInf {ts : Set (TopologicalSpace G)}\n    (h : âˆ€ t âˆˆ ts, @ContinuousInv G t _) : @ContinuousInv G (sInf ts) _ :=\n  letI := sInf ts\n  { continuous_inv :=\n      continuous_sInf_rng.2 fun t ht =>\n        continuous_sInf_dom ht (@ContinuousInv.continuous_inv G t _ (h t ht)) }\n\n"}
{"name":"continuousNeg_iInf","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\nÎ¹' : Sort u_1\ninstâœ : Neg G\nts' : Î¹' â†’ TopologicalSpace G\nh' : âˆ€ (i : Î¹'), ContinuousNeg G\nâŠ¢ ContinuousNeg G","decl":"@[to_additive]\ntheorem continuousInv_iInf {ts' : Î¹' â†’ TopologicalSpace G}\n    (h' : âˆ€ i, @ContinuousInv G (ts' i) _) : @ContinuousInv G (â¨… i, ts' i) _ := by\n  rw [â† sInf_range]\n  exact continuousInv_sInf (Set.forall_mem_range.mpr h')\n\n"}
{"name":"continuousInv_iInf","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\nÎ¹' : Sort u_1\ninstâœ : Inv G\nts' : Î¹' â†’ TopologicalSpace G\nh' : âˆ€ (i : Î¹'), ContinuousInv G\nâŠ¢ ContinuousInv G","decl":"@[to_additive]\ntheorem continuousInv_iInf {ts' : Î¹' â†’ TopologicalSpace G}\n    (h' : âˆ€ i, @ContinuousInv G (ts' i) _) : @ContinuousInv G (â¨… i, ts' i) _ := by\n  rw [â† sInf_range]\n  exact continuousInv_sInf (Set.forall_mem_range.mpr h')\n\n"}
{"name":"continuousNeg_inf","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœ : Neg G\ntâ‚ tâ‚‚ : TopologicalSpace G\nhâ‚ : ContinuousNeg G\nhâ‚‚ : ContinuousNeg G\nâŠ¢ ContinuousNeg G","decl":"@[to_additive]\ntheorem continuousInv_inf {tâ‚ tâ‚‚ : TopologicalSpace G} (hâ‚ : @ContinuousInv G tâ‚ _)\n    (hâ‚‚ : @ContinuousInv G tâ‚‚ _) : @ContinuousInv G (tâ‚ âŠ“ tâ‚‚) _ := by\n  rw [inf_eq_iInf]\n  refine continuousInv_iInf fun b => ?_\n  cases b <;> assumption\n\n"}
{"name":"continuousInv_inf","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœ : Inv G\ntâ‚ tâ‚‚ : TopologicalSpace G\nhâ‚ : ContinuousInv G\nhâ‚‚ : ContinuousInv G\nâŠ¢ ContinuousInv G","decl":"@[to_additive]\ntheorem continuousInv_inf {tâ‚ tâ‚‚ : TopologicalSpace G} (hâ‚ : @ContinuousInv G tâ‚ _)\n    (hâ‚‚ : @ContinuousInv G tâ‚‚ _) : @ContinuousInv G (tâ‚ âŠ“ tâ‚‚) _ := by\n  rw [inf_eq_iInf]\n  refine continuousInv_iInf fun b => ?_\n  cases b <;> assumption\n\n"}
{"name":"Topology.IsInducing.continuousNeg","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type u_1\nH : Type u_2\ninstâœâ´ : Neg G\ninstâœÂ³ : Neg H\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : TopologicalSpace H\ninstâœ : ContinuousNeg H\nf : G â†’ H\nhf : Topology.IsInducing f\nhf_inv : âˆ€ (x : G), Eq (f (Neg.neg x)) (Neg.neg (f x))\nâŠ¢ ContinuousNeg G","decl":"@[to_additive]\ntheorem Topology.IsInducing.continuousInv {G H : Type*} [Inv G] [Inv H] [TopologicalSpace G]\n    [TopologicalSpace H] [ContinuousInv H] {f : G â†’ H} (hf : IsInducing f)\n    (hf_inv : âˆ€ x, f xâ»Â¹ = (f x)â»Â¹) : ContinuousInv G :=\n  âŸ¨hf.continuous_iff.2 <| by simpa only [Function.comp_def, hf_inv] using hf.continuous.invâŸ©\n\n"}
{"name":"Topology.IsInducing.continuousInv","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type u_1\nH : Type u_2\ninstâœâ´ : Inv G\ninstâœÂ³ : Inv H\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : TopologicalSpace H\ninstâœ : ContinuousInv H\nf : G â†’ H\nhf : Topology.IsInducing f\nhf_inv : âˆ€ (x : G), Eq (f (Inv.inv x)) (Inv.inv (f x))\nâŠ¢ ContinuousInv G","decl":"@[to_additive]\ntheorem Topology.IsInducing.continuousInv {G H : Type*} [Inv G] [Inv H] [TopologicalSpace G]\n    [TopologicalSpace H] [ContinuousInv H] {f : G â†’ H} (hf : IsInducing f)\n    (hf_inv : âˆ€ x, f xâ»Â¹ = (f x)â»Â¹) : ContinuousInv G :=\n  âŸ¨hf.continuous_iff.2 <| by simpa only [Function.comp_def, hf_inv] using hf.continuous.invâŸ©\n\n"}
{"name":"Inducing.continuousInv","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type u_1\nH : Type u_2\ninstâœâ´ : Inv G\ninstâœÂ³ : Inv H\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : TopologicalSpace H\ninstâœ : ContinuousInv H\nf : G â†’ H\nhf : Topology.IsInducing f\nhf_inv : âˆ€ (x : G), Eq (f (Inv.inv x)) (Inv.inv (f x))\nâŠ¢ ContinuousInv G","decl":"@[deprecated (since := \"2024-10-28\")] alias Inducing.continuousInv := IsInducing.continuousInv\n\n"}
{"name":"TopologicalAddGroup.toContinuousAdd","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type u\ninstâœÂ¹ : TopologicalSpace G\ninstâœ : AddGroup G\nself : TopologicalAddGroup G\nâŠ¢ ContinuousAdd G","decl":"/-- A topological (additive) group is a group in which the addition and negation operations are\ncontinuous. -/\nclass TopologicalAddGroup (G : Type u) [TopologicalSpace G] [AddGroup G] extends\n  ContinuousAdd G, ContinuousNeg G : Prop\n\n"}
{"name":"TopologicalAddGroup.toContinuousNeg","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type u\ninstâœÂ¹ : TopologicalSpace G\ninstâœ : AddGroup G\nself : TopologicalAddGroup G\nâŠ¢ ContinuousNeg G","decl":"/-- A topological (additive) group is a group in which the addition and negation operations are\ncontinuous. -/\nclass TopologicalAddGroup (G : Type u) [TopologicalSpace G] [AddGroup G] extends\n  ContinuousAdd G, ContinuousNeg G : Prop\n\n"}
{"name":"TopologicalGroup.toContinuousMul","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type u_1\ninstâœÂ¹ : TopologicalSpace G\ninstâœ : Group G\nself : TopologicalGroup G\nâŠ¢ ContinuousMul G","decl":"/-- A topological group is a group in which the multiplication and inversion operations are\ncontinuous.\n\nWhen you declare an instance that does not already have a `UniformSpace` instance,\nyou should also provide an instance of `UniformSpace` and `UniformGroup` using\n`TopologicalGroup.toUniformSpace` and `topologicalCommGroup_isUniform`. -/\n-- Porting note: check that these â†‘ names exist once they've been ported in the future.\n@[to_additive]\nclass TopologicalGroup (G : Type*) [TopologicalSpace G] [Group G] extends ContinuousMul G,\n  ContinuousInv G : Prop\n\n"}
{"name":"TopologicalGroup.toContinuousInv","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type u_1\ninstâœÂ¹ : TopologicalSpace G\ninstâœ : Group G\nself : TopologicalGroup G\nâŠ¢ ContinuousInv G","decl":"/-- A topological group is a group in which the multiplication and inversion operations are\ncontinuous.\n\nWhen you declare an instance that does not already have a `UniformSpace` instance,\nyou should also provide an instance of `UniformSpace` and `UniformGroup` using\n`TopologicalGroup.toUniformSpace` and `topologicalCommGroup_isUniform`. -/\n-- Porting note: check that these â†‘ names exist once they've been ported in the future.\n@[to_additive]\nclass TopologicalGroup (G : Type*) [TopologicalSpace G] [Group G] extends ContinuousMul G,\n  ContinuousInv G : Prop\n\n"}
{"name":"ConjAct.units_continuousConstSMul","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"M : Type u_1\ninstâœÂ² : Monoid M\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ContinuousMul M\nâŠ¢ ContinuousConstSMul (ConjAct (Units M)) M","decl":"instance ConjAct.units_continuousConstSMul {M} [Monoid M] [TopologicalSpace M]\n    [ContinuousMul M] : ContinuousConstSMul (ConjAct MË£) M :=\n  âŸ¨fun _ => (continuous_const.mul continuous_id).mul continuous_constâŸ©\n\n"}
{"name":"TopologicalGroup.continuous_conj_prod","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœâ´ : TopologicalSpace G\ninstâœÂ³ : Inv G\ninstâœÂ² : Mul G\ninstâœÂ¹ : ContinuousMul G\ninstâœ : ContinuousInv G\nâŠ¢ Continuous fun g => HMul.hMul (HMul.hMul g.1 g.2) (Inv.inv g.1)","decl":"/-- Conjugation is jointly continuous on `G Ã— G` when both `mul` and `inv` are continuous. -/\n@[to_additive\n  \"Conjugation is jointly continuous on `G Ã— G` when both `add` and `neg` are continuous.\"]\ntheorem TopologicalGroup.continuous_conj_prod [ContinuousInv G] :\n    Continuous fun g : G Ã— G => g.fst * g.snd * g.fstâ»Â¹ :=\n  continuous_mul.mul (continuous_inv.comp continuous_fst)\n\n"}
{"name":"TopologicalAddGroup.continuous_conj_sum","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœâ´ : TopologicalSpace G\ninstâœÂ³ : Neg G\ninstâœÂ² : Add G\ninstâœÂ¹ : ContinuousAdd G\ninstâœ : ContinuousNeg G\nâŠ¢ Continuous fun g => HAdd.hAdd (HAdd.hAdd g.1 g.2) (Neg.neg g.1)","decl":"/-- Conjugation is jointly continuous on `G Ã— G` when both `mul` and `inv` are continuous. -/\n@[to_additive\n  \"Conjugation is jointly continuous on `G Ã— G` when both `add` and `neg` are continuous.\"]\ntheorem TopologicalGroup.continuous_conj_prod [ContinuousInv G] :\n    Continuous fun g : G Ã— G => g.fst * g.snd * g.fstâ»Â¹ :=\n  continuous_mul.mul (continuous_inv.comp continuous_fst)\n\n"}
{"name":"TopologicalAddGroup.continuous_conj","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ³ : TopologicalSpace G\ninstâœÂ² : Neg G\ninstâœÂ¹ : Add G\ninstâœ : ContinuousAdd G\ng : G\nâŠ¢ Continuous fun h => HAdd.hAdd (HAdd.hAdd g h) (Neg.neg g)","decl":"/-- Conjugation by a fixed element is continuous when `mul` is continuous. -/\n@[to_additive (attr := continuity)\n  \"Conjugation by a fixed element is continuous when `add` is continuous.\"]\ntheorem TopologicalGroup.continuous_conj (g : G) : Continuous fun h : G => g * h * gâ»Â¹ :=\n  (continuous_mul_right gâ»Â¹).comp (continuous_mul_left g)\n\n"}
{"name":"TopologicalGroup.continuous_conj","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ³ : TopologicalSpace G\ninstâœÂ² : Inv G\ninstâœÂ¹ : Mul G\ninstâœ : ContinuousMul G\ng : G\nâŠ¢ Continuous fun h => HMul.hMul (HMul.hMul g h) (Inv.inv g)","decl":"/-- Conjugation by a fixed element is continuous when `mul` is continuous. -/\n@[to_additive (attr := continuity)\n  \"Conjugation by a fixed element is continuous when `add` is continuous.\"]\ntheorem TopologicalGroup.continuous_conj (g : G) : Continuous fun h : G => g * h * gâ»Â¹ :=\n  (continuous_mul_right gâ»Â¹).comp (continuous_mul_left g)\n\n"}
{"name":"TopologicalGroup.continuous_conj'","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœâ´ : TopologicalSpace G\ninstâœÂ³ : Inv G\ninstâœÂ² : Mul G\ninstâœÂ¹ : ContinuousMul G\ninstâœ : ContinuousInv G\nh : G\nâŠ¢ Continuous fun g => HMul.hMul (HMul.hMul g h) (Inv.inv g)","decl":"/-- Conjugation acting on fixed element of the group is continuous when both `mul` and\n`inv` are continuous. -/\n@[to_additive (attr := continuity)\n  \"Conjugation acting on fixed element of the additive group is continuous when both\n    `add` and `neg` are continuous.\"]\ntheorem TopologicalGroup.continuous_conj' [ContinuousInv G] (h : G) :\n    Continuous fun g : G => g * h * gâ»Â¹ :=\n  (continuous_mul_right h).mul continuous_inv\n\n"}
{"name":"TopologicalAddGroup.continuous_conj'","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœâ´ : TopologicalSpace G\ninstâœÂ³ : Neg G\ninstâœÂ² : Add G\ninstâœÂ¹ : ContinuousAdd G\ninstâœ : ContinuousNeg G\nh : G\nâŠ¢ Continuous fun g => HAdd.hAdd (HAdd.hAdd g h) (Neg.neg g)","decl":"/-- Conjugation acting on fixed element of the group is continuous when both `mul` and\n`inv` are continuous. -/\n@[to_additive (attr := continuity)\n  \"Conjugation acting on fixed element of the additive group is continuous when both\n    `add` and `neg` are continuous.\"]\ntheorem TopologicalGroup.continuous_conj' [ContinuousInv G] (h : G) :\n    Continuous fun g : G => g * h * gâ»Â¹ :=\n  (continuous_mul_right h).mul continuous_inv\n\n"}
{"name":"instTopologicalGroupULift","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : TopologicalGroup G\nâŠ¢ TopologicalGroup (ULift.{u_1, w} G)","decl":"instance : TopologicalGroup (ULift G) where\n\n"}
{"name":"continuous_zpow","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : TopologicalGroup G\nz : Int\nâŠ¢ Continuous fun a => HPow.hPow a z","decl":"@[to_additive (attr := continuity)]\ntheorem continuous_zpow : âˆ€ z : â„¤, Continuous fun a : G => a ^ z\n  | Int.ofNat n => by simpa using continuous_pow n\n  | Int.negSucc n => by simpa using (continuous_pow (n + 1)).inv\n\n"}
{"name":"continuous_zsmul","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : TopologicalAddGroup G\nz : Int\nâŠ¢ Continuous fun a => HSMul.hSMul z a","decl":"@[to_additive (attr := continuity)]\ntheorem continuous_zpow : âˆ€ z : â„¤, Continuous fun a : G => a ^ z\n  | Int.ofNat n => by simpa using continuous_pow n\n  | Int.negSucc n => by simpa using (continuous_pow (n + 1)).inv\n\n"}
{"name":"AddGroup.continuousConstSMul_int","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"A : Type u_1\ninstâœÂ² : AddGroup A\ninstâœÂ¹ : TopologicalSpace A\ninstâœ : TopologicalAddGroup A\nâŠ¢ ContinuousConstSMul Int A","decl":"instance AddGroup.continuousConstSMul_int {A} [AddGroup A] [TopologicalSpace A]\n    [TopologicalAddGroup A] : ContinuousConstSMul â„¤ A :=\n  âŸ¨continuous_zsmulâŸ©\n\n"}
{"name":"AddGroup.continuousSMul_int","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"A : Type u_1\ninstâœÂ² : AddGroup A\ninstâœÂ¹ : TopologicalSpace A\ninstâœ : TopologicalAddGroup A\nâŠ¢ ContinuousSMul Int A","decl":"instance AddGroup.continuousSMul_int {A} [AddGroup A] [TopologicalSpace A]\n    [TopologicalAddGroup A] : ContinuousSMul â„¤ A :=\n  âŸ¨continuous_prod_of_discrete_left.mpr continuous_zsmulâŸ©\n\n"}
{"name":"Continuous.zsmul","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\nÎ± : Type u\ninstâœÂ³ : TopologicalSpace G\ninstâœÂ² : AddGroup G\ninstâœÂ¹ : TopologicalAddGroup G\ninstâœ : TopologicalSpace Î±\nf : Î± â†’ G\nh : Continuous f\nz : Int\nâŠ¢ Continuous fun b => HSMul.hSMul z (f b)","decl":"@[to_additive (attr := continuity, fun_prop)]\ntheorem Continuous.zpow {f : Î± â†’ G} (h : Continuous f) (z : â„¤) : Continuous fun b => f b ^ z :=\n  (continuous_zpow z).comp h\n\n"}
{"name":"Continuous.zpow","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\nÎ± : Type u\ninstâœÂ³ : TopologicalSpace G\ninstâœÂ² : Group G\ninstâœÂ¹ : TopologicalGroup G\ninstâœ : TopologicalSpace Î±\nf : Î± â†’ G\nh : Continuous f\nz : Int\nâŠ¢ Continuous fun b => HPow.hPow (f b) z","decl":"@[to_additive (attr := continuity, fun_prop)]\ntheorem Continuous.zpow {f : Î± â†’ G} (h : Continuous f) (z : â„¤) : Continuous fun b => f b ^ z :=\n  (continuous_zpow z).comp h\n\n"}
{"name":"continuousOn_zpow","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : TopologicalGroup G\ns : Set G\nz : Int\nâŠ¢ ContinuousOn (fun x => HPow.hPow x z) s","decl":"@[to_additive]\ntheorem continuousOn_zpow {s : Set G} (z : â„¤) : ContinuousOn (fun x => x ^ z) s :=\n  (continuous_zpow z).continuousOn\n\n"}
{"name":"continuousOn_zsmul","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : TopologicalAddGroup G\ns : Set G\nz : Int\nâŠ¢ ContinuousOn (fun x => HSMul.hSMul z x) s","decl":"@[to_additive]\ntheorem continuousOn_zpow {s : Set G} (z : â„¤) : ContinuousOn (fun x => x ^ z) s :=\n  (continuous_zpow z).continuousOn\n\n"}
{"name":"continuousAt_zpow","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : TopologicalGroup G\nx : G\nz : Int\nâŠ¢ ContinuousAt (fun x => HPow.hPow x z) x","decl":"@[to_additive]\ntheorem continuousAt_zpow (x : G) (z : â„¤) : ContinuousAt (fun x => x ^ z) x :=\n  (continuous_zpow z).continuousAt\n\n"}
{"name":"continuousAt_zsmul","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : TopologicalAddGroup G\nx : G\nz : Int\nâŠ¢ ContinuousAt (fun x => HSMul.hSMul z x) x","decl":"@[to_additive]\ntheorem continuousAt_zpow (x : G) (z : â„¤) : ContinuousAt (fun x => x ^ z) x :=\n  (continuous_zpow z).continuousAt\n\n"}
{"name":"Filter.Tendsto.zsmul","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : TopologicalAddGroup G\nÎ± : Type u_1\nl : Filter Î±\nf : Î± â†’ G\nx : G\nhf : Filter.Tendsto f l (nhds x)\nz : Int\nâŠ¢ Filter.Tendsto (fun x => HSMul.hSMul z (f x)) l (nhds (HSMul.hSMul z x))","decl":"@[to_additive]\ntheorem Filter.Tendsto.zpow {Î±} {l : Filter Î±} {f : Î± â†’ G} {x : G} (hf : Tendsto f l (ð“ x))\n    (z : â„¤) : Tendsto (fun x => f x ^ z) l (ð“ (x ^ z)) :=\n  (continuousAt_zpow _ _).tendsto.comp hf\n\n"}
{"name":"Filter.Tendsto.zpow","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : TopologicalGroup G\nÎ± : Type u_1\nl : Filter Î±\nf : Î± â†’ G\nx : G\nhf : Filter.Tendsto f l (nhds x)\nz : Int\nâŠ¢ Filter.Tendsto (fun x => HPow.hPow (f x) z) l (nhds (HPow.hPow x z))","decl":"@[to_additive]\ntheorem Filter.Tendsto.zpow {Î±} {l : Filter Î±} {f : Î± â†’ G} {x : G} (hf : Tendsto f l (ð“ x))\n    (z : â„¤) : Tendsto (fun x => f x ^ z) l (ð“ (x ^ z)) :=\n  (continuousAt_zpow _ _).tendsto.comp hf\n\n"}
{"name":"ContinuousWithinAt.zsmul","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\nÎ± : Type u\ninstâœÂ³ : TopologicalSpace G\ninstâœÂ² : AddGroup G\ninstâœÂ¹ : TopologicalAddGroup G\ninstâœ : TopologicalSpace Î±\nf : Î± â†’ G\nx : Î±\ns : Set Î±\nhf : ContinuousWithinAt f s x\nz : Int\nâŠ¢ ContinuousWithinAt (fun x => HSMul.hSMul z (f x)) s x","decl":"@[to_additive]\ntheorem ContinuousWithinAt.zpow {f : Î± â†’ G} {x : Î±} {s : Set Î±} (hf : ContinuousWithinAt f s x)\n    (z : â„¤) : ContinuousWithinAt (fun x => f x ^ z) s x :=\n  Filter.Tendsto.zpow hf z\n\n"}
{"name":"ContinuousWithinAt.zpow","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\nÎ± : Type u\ninstâœÂ³ : TopologicalSpace G\ninstâœÂ² : Group G\ninstâœÂ¹ : TopologicalGroup G\ninstâœ : TopologicalSpace Î±\nf : Î± â†’ G\nx : Î±\ns : Set Î±\nhf : ContinuousWithinAt f s x\nz : Int\nâŠ¢ ContinuousWithinAt (fun x => HPow.hPow (f x) z) s x","decl":"@[to_additive]\ntheorem ContinuousWithinAt.zpow {f : Î± â†’ G} {x : Î±} {s : Set Î±} (hf : ContinuousWithinAt f s x)\n    (z : â„¤) : ContinuousWithinAt (fun x => f x ^ z) s x :=\n  Filter.Tendsto.zpow hf z\n\n"}
{"name":"ContinuousAt.zpow","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\nÎ± : Type u\ninstâœÂ³ : TopologicalSpace G\ninstâœÂ² : Group G\ninstâœÂ¹ : TopologicalGroup G\ninstâœ : TopologicalSpace Î±\nf : Î± â†’ G\nx : Î±\nhf : ContinuousAt f x\nz : Int\nâŠ¢ ContinuousAt (fun x => HPow.hPow (f x) z) x","decl":"@[to_additive (attr := fun_prop)]\ntheorem ContinuousAt.zpow {f : Î± â†’ G} {x : Î±} (hf : ContinuousAt f x) (z : â„¤) :\n    ContinuousAt (fun x => f x ^ z) x :=\n  Filter.Tendsto.zpow hf z\n\n"}
{"name":"ContinuousAt.zsmul","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\nÎ± : Type u\ninstâœÂ³ : TopologicalSpace G\ninstâœÂ² : AddGroup G\ninstâœÂ¹ : TopologicalAddGroup G\ninstâœ : TopologicalSpace Î±\nf : Î± â†’ G\nx : Î±\nhf : ContinuousAt f x\nz : Int\nâŠ¢ ContinuousAt (fun x => HSMul.hSMul z (f x)) x","decl":"@[to_additive (attr := fun_prop)]\ntheorem ContinuousAt.zpow {f : Î± â†’ G} {x : Î±} (hf : ContinuousAt f x) (z : â„¤) :\n    ContinuousAt (fun x => f x ^ z) x :=\n  Filter.Tendsto.zpow hf z\n\n"}
{"name":"ContinuousOn.zsmul","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\nÎ± : Type u\ninstâœÂ³ : TopologicalSpace G\ninstâœÂ² : AddGroup G\ninstâœÂ¹ : TopologicalAddGroup G\ninstâœ : TopologicalSpace Î±\nf : Î± â†’ G\ns : Set Î±\nhf : ContinuousOn f s\nz : Int\nâŠ¢ ContinuousOn (fun x => HSMul.hSMul z (f x)) s","decl":"@[to_additive (attr := fun_prop)]\ntheorem ContinuousOn.zpow {f : Î± â†’ G} {s : Set Î±} (hf : ContinuousOn f s) (z : â„¤) :\n    ContinuousOn (fun x => f x ^ z) s := fun x hx => (hf x hx).zpow z\n\n"}
{"name":"ContinuousOn.zpow","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\nÎ± : Type u\ninstâœÂ³ : TopologicalSpace G\ninstâœÂ² : Group G\ninstâœÂ¹ : TopologicalGroup G\ninstâœ : TopologicalSpace Î±\nf : Î± â†’ G\ns : Set Î±\nhf : ContinuousOn f s\nz : Int\nâŠ¢ ContinuousOn (fun x => HPow.hPow (f x) z) s","decl":"@[to_additive (attr := fun_prop)]\ntheorem ContinuousOn.zpow {f : Î± â†’ G} {s : Set Î±} (hf : ContinuousOn f s) (z : â„¤) :\n    ContinuousOn (fun x => f x ^ z) s := fun x hx => (hf x hx).zpow z\n\n"}
{"name":"tendsto_neg_nhdsGT","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"H : Type x\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : OrderedAddCommGroup H\ninstâœ : ContinuousNeg H\na : H\nâŠ¢ Filter.Tendsto Neg.neg (nhdsWithin a (Set.Ioi a)) (nhdsWithin (Neg.neg a) (Set.Iio (Neg.neg a)))","decl":"@[to_additive]\ntheorem tendsto_inv_nhdsGT {a : H} : Tendsto Inv.inv (ð“[>] a) (ð“[<] aâ»Â¹) :=\n  (continuous_inv.tendsto a).inf <| by simp [tendsto_principal_principal]\n\n"}
{"name":"tendsto_inv_nhdsGT","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"H : Type x\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : OrderedCommGroup H\ninstâœ : ContinuousInv H\na : H\nâŠ¢ Filter.Tendsto Inv.inv (nhdsWithin a (Set.Ioi a)) (nhdsWithin (Inv.inv a) (Set.Iio (Inv.inv a)))","decl":"@[to_additive]\ntheorem tendsto_inv_nhdsGT {a : H} : Tendsto Inv.inv (ð“[>] a) (ð“[<] aâ»Â¹) :=\n  (continuous_inv.tendsto a).inf <| by simp [tendsto_principal_principal]\n\n"}
{"name":"tendsto_neg_nhdsWithin_Ioi","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"H : Type x\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : OrderedAddCommGroup H\ninstâœ : ContinuousNeg H\na : H\nâŠ¢ Filter.Tendsto Neg.neg (nhdsWithin a (Set.Ioi a)) (nhdsWithin (Neg.neg a) (Set.Iio (Neg.neg a)))","decl":"@[deprecated (since := \"2024-12-22\")]\nalias tendsto_neg_nhdsWithin_Ioi := tendsto_neg_nhdsGT\n"}
{"name":"tendsto_inv_nhdsWithin_Ioi","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"H : Type x\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : OrderedCommGroup H\ninstâœ : ContinuousInv H\na : H\nâŠ¢ Filter.Tendsto Inv.inv (nhdsWithin a (Set.Ioi a)) (nhdsWithin (Inv.inv a) (Set.Iio (Inv.inv a)))","decl":"@[to_additive existing, deprecated (since := \"2024-12-22\")]\nalias tendsto_inv_nhdsWithin_Ioi := tendsto_inv_nhdsGT\n\n"}
{"name":"tendsto_neg_nhdsLT","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"H : Type x\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : OrderedAddCommGroup H\ninstâœ : ContinuousNeg H\na : H\nâŠ¢ Filter.Tendsto Neg.neg (nhdsWithin a (Set.Iio a)) (nhdsWithin (Neg.neg a) (Set.Ioi (Neg.neg a)))","decl":"@[to_additive]\ntheorem tendsto_inv_nhdsLT {a : H} : Tendsto Inv.inv (ð“[<] a) (ð“[>] aâ»Â¹) :=\n  (continuous_inv.tendsto a).inf <| by simp [tendsto_principal_principal]\n\n"}
{"name":"tendsto_inv_nhdsLT","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"H : Type x\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : OrderedCommGroup H\ninstâœ : ContinuousInv H\na : H\nâŠ¢ Filter.Tendsto Inv.inv (nhdsWithin a (Set.Iio a)) (nhdsWithin (Inv.inv a) (Set.Ioi (Inv.inv a)))","decl":"@[to_additive]\ntheorem tendsto_inv_nhdsLT {a : H} : Tendsto Inv.inv (ð“[<] a) (ð“[>] aâ»Â¹) :=\n  (continuous_inv.tendsto a).inf <| by simp [tendsto_principal_principal]\n\n"}
{"name":"tendsto_neg_nhdsWithin_Iio","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"H : Type x\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : OrderedAddCommGroup H\ninstâœ : ContinuousNeg H\na : H\nâŠ¢ Filter.Tendsto Neg.neg (nhdsWithin a (Set.Iio a)) (nhdsWithin (Neg.neg a) (Set.Ioi (Neg.neg a)))","decl":"@[deprecated (since := \"2024-12-22\")]\nalias tendsto_neg_nhdsWithin_Iio := tendsto_neg_nhdsLT\n"}
{"name":"tendsto_inv_nhdsWithin_Iio","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"H : Type x\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : OrderedCommGroup H\ninstâœ : ContinuousInv H\na : H\nâŠ¢ Filter.Tendsto Inv.inv (nhdsWithin a (Set.Iio a)) (nhdsWithin (Inv.inv a) (Set.Ioi (Inv.inv a)))","decl":"@[to_additive existing, deprecated (since := \"2024-12-22\")]\nalias tendsto_inv_nhdsWithin_Iio := tendsto_inv_nhdsLT\n\n"}
{"name":"tendsto_neg_nhdsGT_neg","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"H : Type x\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : OrderedAddCommGroup H\ninstâœ : ContinuousNeg H\na : H\nâŠ¢ Filter.Tendsto Neg.neg (nhdsWithin (Neg.neg a) (Set.Ioi (Neg.neg a))) (nhdsWithin a (Set.Iio a))","decl":"@[to_additive]\ntheorem tendsto_inv_nhdsGT_inv {a : H} : Tendsto Inv.inv (ð“[>] aâ»Â¹) (ð“[<] a) := by\n  simpa only [inv_inv] using @tendsto_inv_nhdsGT _ _ _ _ aâ»Â¹\n\n"}
{"name":"tendsto_inv_nhdsGT_inv","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"H : Type x\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : OrderedCommGroup H\ninstâœ : ContinuousInv H\na : H\nâŠ¢ Filter.Tendsto Inv.inv (nhdsWithin (Inv.inv a) (Set.Ioi (Inv.inv a))) (nhdsWithin a (Set.Iio a))","decl":"@[to_additive]\ntheorem tendsto_inv_nhdsGT_inv {a : H} : Tendsto Inv.inv (ð“[>] aâ»Â¹) (ð“[<] a) := by\n  simpa only [inv_inv] using @tendsto_inv_nhdsGT _ _ _ _ aâ»Â¹\n\n"}
{"name":"tendsto_neg_nhdsWithin_Ioi_neg","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"H : Type x\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : OrderedAddCommGroup H\ninstâœ : ContinuousNeg H\na : H\nâŠ¢ Filter.Tendsto Neg.neg (nhdsWithin (Neg.neg a) (Set.Ioi (Neg.neg a))) (nhdsWithin a (Set.Iio a))","decl":"@[deprecated (since := \"2024-12-22\")]\nalias tendsto_neg_nhdsWithin_Ioi_neg := tendsto_neg_nhdsGT_neg\n"}
{"name":"tendsto_inv_nhdsWithin_Ioi_inv","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"H : Type x\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : OrderedCommGroup H\ninstâœ : ContinuousInv H\na : H\nâŠ¢ Filter.Tendsto Inv.inv (nhdsWithin (Inv.inv a) (Set.Ioi (Inv.inv a))) (nhdsWithin a (Set.Iio a))","decl":"@[to_additive existing, deprecated (since := \"2024-12-22\")]\nalias tendsto_inv_nhdsWithin_Ioi_inv := tendsto_inv_nhdsGT_inv\n\n"}
{"name":"tendsto_neg_nhdsLT_neg","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"H : Type x\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : OrderedAddCommGroup H\ninstâœ : ContinuousNeg H\na : H\nâŠ¢ Filter.Tendsto Neg.neg (nhdsWithin (Neg.neg a) (Set.Iio (Neg.neg a))) (nhdsWithin a (Set.Ioi a))","decl":"@[to_additive]\ntheorem tendsto_inv_nhdsLT_inv {a : H} : Tendsto Inv.inv (ð“[<] aâ»Â¹) (ð“[>] a) := by\n  simpa only [inv_inv] using @tendsto_inv_nhdsLT _ _ _ _ aâ»Â¹\n\n"}
{"name":"tendsto_inv_nhdsLT_inv","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"H : Type x\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : OrderedCommGroup H\ninstâœ : ContinuousInv H\na : H\nâŠ¢ Filter.Tendsto Inv.inv (nhdsWithin (Inv.inv a) (Set.Iio (Inv.inv a))) (nhdsWithin a (Set.Ioi a))","decl":"@[to_additive]\ntheorem tendsto_inv_nhdsLT_inv {a : H} : Tendsto Inv.inv (ð“[<] aâ»Â¹) (ð“[>] a) := by\n  simpa only [inv_inv] using @tendsto_inv_nhdsLT _ _ _ _ aâ»Â¹\n\n"}
{"name":"tendsto_neg_nhdsWithin_Iio_neg","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"H : Type x\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : OrderedAddCommGroup H\ninstâœ : ContinuousNeg H\na : H\nâŠ¢ Filter.Tendsto Neg.neg (nhdsWithin (Neg.neg a) (Set.Iio (Neg.neg a))) (nhdsWithin a (Set.Ioi a))","decl":"@[deprecated (since := \"2024-12-22\")]\nalias tendsto_neg_nhdsWithin_Iio_neg := tendsto_neg_nhdsLT_neg\n"}
{"name":"tendsto_inv_nhdsWithin_Iio_inv","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"H : Type x\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : OrderedCommGroup H\ninstâœ : ContinuousInv H\na : H\nâŠ¢ Filter.Tendsto Inv.inv (nhdsWithin (Inv.inv a) (Set.Iio (Inv.inv a))) (nhdsWithin a (Set.Ioi a))","decl":"@[to_additive existing, deprecated (since := \"2024-12-22\")]\nalias tendsto_inv_nhdsWithin_Iio_inv := tendsto_inv_nhdsLT_inv\n\n"}
{"name":"tendsto_inv_nhdsGE","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"H : Type x\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : OrderedCommGroup H\ninstâœ : ContinuousInv H\na : H\nâŠ¢ Filter.Tendsto Inv.inv (nhdsWithin a (Set.Ici a)) (nhdsWithin (Inv.inv a) (Set.Iic (Inv.inv a)))","decl":"@[to_additive]\ntheorem tendsto_inv_nhdsGE {a : H} : Tendsto Inv.inv (ð“[â‰¥] a) (ð“[â‰¤] aâ»Â¹) :=\n  (continuous_inv.tendsto a).inf <| by simp [tendsto_principal_principal]\n\n"}
{"name":"tendsto_neg_nhdsGE","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"H : Type x\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : OrderedAddCommGroup H\ninstâœ : ContinuousNeg H\na : H\nâŠ¢ Filter.Tendsto Neg.neg (nhdsWithin a (Set.Ici a)) (nhdsWithin (Neg.neg a) (Set.Iic (Neg.neg a)))","decl":"@[to_additive]\ntheorem tendsto_inv_nhdsGE {a : H} : Tendsto Inv.inv (ð“[â‰¥] a) (ð“[â‰¤] aâ»Â¹) :=\n  (continuous_inv.tendsto a).inf <| by simp [tendsto_principal_principal]\n\n"}
{"name":"tendsto_neg_nhdsWithin_Ici","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"H : Type x\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : OrderedAddCommGroup H\ninstâœ : ContinuousNeg H\na : H\nâŠ¢ Filter.Tendsto Neg.neg (nhdsWithin a (Set.Ici a)) (nhdsWithin (Neg.neg a) (Set.Iic (Neg.neg a)))","decl":"@[deprecated (since := \"2024-12-22\")]\nalias tendsto_neg_nhdsWithin_Ici := tendsto_neg_nhdsGE\n"}
{"name":"tendsto_inv_nhdsWithin_Ici","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"H : Type x\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : OrderedCommGroup H\ninstâœ : ContinuousInv H\na : H\nâŠ¢ Filter.Tendsto Inv.inv (nhdsWithin a (Set.Ici a)) (nhdsWithin (Inv.inv a) (Set.Iic (Inv.inv a)))","decl":"@[to_additive existing, deprecated (since := \"2024-12-22\")]\nalias tendsto_inv_nhdsWithin_Ici := tendsto_inv_nhdsGE\n\n"}
{"name":"tendsto_neg_nhdsLE","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"H : Type x\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : OrderedAddCommGroup H\ninstâœ : ContinuousNeg H\na : H\nâŠ¢ Filter.Tendsto Neg.neg (nhdsWithin a (Set.Iic a)) (nhdsWithin (Neg.neg a) (Set.Ici (Neg.neg a)))","decl":"@[to_additive]\ntheorem tendsto_inv_nhdsLE {a : H} : Tendsto Inv.inv (ð“[â‰¤] a) (ð“[â‰¥] aâ»Â¹) :=\n  (continuous_inv.tendsto a).inf <| by simp [tendsto_principal_principal]\n\n"}
{"name":"tendsto_inv_nhdsLE","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"H : Type x\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : OrderedCommGroup H\ninstâœ : ContinuousInv H\na : H\nâŠ¢ Filter.Tendsto Inv.inv (nhdsWithin a (Set.Iic a)) (nhdsWithin (Inv.inv a) (Set.Ici (Inv.inv a)))","decl":"@[to_additive]\ntheorem tendsto_inv_nhdsLE {a : H} : Tendsto Inv.inv (ð“[â‰¤] a) (ð“[â‰¥] aâ»Â¹) :=\n  (continuous_inv.tendsto a).inf <| by simp [tendsto_principal_principal]\n\n"}
{"name":"tendsto_neg_nhdsWithin_Iic","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"H : Type x\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : OrderedAddCommGroup H\ninstâœ : ContinuousNeg H\na : H\nâŠ¢ Filter.Tendsto Neg.neg (nhdsWithin a (Set.Iic a)) (nhdsWithin (Neg.neg a) (Set.Ici (Neg.neg a)))","decl":"@[deprecated (since := \"2024-12-22\")]\nalias tendsto_neg_nhdsWithin_Iic := tendsto_neg_nhdsLE\n"}
{"name":"tendsto_inv_nhdsWithin_Iic","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"H : Type x\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : OrderedCommGroup H\ninstâœ : ContinuousInv H\na : H\nâŠ¢ Filter.Tendsto Inv.inv (nhdsWithin a (Set.Iic a)) (nhdsWithin (Inv.inv a) (Set.Ici (Inv.inv a)))","decl":"@[to_additive existing, deprecated (since := \"2024-12-22\")]\nalias tendsto_inv_nhdsWithin_Iic := tendsto_inv_nhdsLE\n\n"}
{"name":"tendsto_neg_nhdsGE_neg","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"H : Type x\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : OrderedAddCommGroup H\ninstâœ : ContinuousNeg H\na : H\nâŠ¢ Filter.Tendsto Neg.neg (nhdsWithin (Neg.neg a) (Set.Ici (Neg.neg a))) (nhdsWithin a (Set.Iic a))","decl":"@[to_additive]\ntheorem tendsto_inv_nhdsGE_inv {a : H} : Tendsto Inv.inv (ð“[â‰¥] aâ»Â¹) (ð“[â‰¤] a) := by\n  simpa only [inv_inv] using @tendsto_inv_nhdsGE _ _ _ _ aâ»Â¹\n\n"}
{"name":"tendsto_inv_nhdsGE_inv","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"H : Type x\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : OrderedCommGroup H\ninstâœ : ContinuousInv H\na : H\nâŠ¢ Filter.Tendsto Inv.inv (nhdsWithin (Inv.inv a) (Set.Ici (Inv.inv a))) (nhdsWithin a (Set.Iic a))","decl":"@[to_additive]\ntheorem tendsto_inv_nhdsGE_inv {a : H} : Tendsto Inv.inv (ð“[â‰¥] aâ»Â¹) (ð“[â‰¤] a) := by\n  simpa only [inv_inv] using @tendsto_inv_nhdsGE _ _ _ _ aâ»Â¹\n\n"}
{"name":"tendsto_neg_nhdsWithin_Ici_neg","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"H : Type x\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : OrderedAddCommGroup H\ninstâœ : ContinuousNeg H\na : H\nâŠ¢ Filter.Tendsto Neg.neg (nhdsWithin (Neg.neg a) (Set.Ici (Neg.neg a))) (nhdsWithin a (Set.Iic a))","decl":"@[deprecated (since := \"2024-12-22\")]\nalias tendsto_neg_nhdsWithin_Ici_neg := tendsto_neg_nhdsGE_neg\n"}
{"name":"tendsto_inv_nhdsWithin_Ici_inv","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"H : Type x\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : OrderedCommGroup H\ninstâœ : ContinuousInv H\na : H\nâŠ¢ Filter.Tendsto Inv.inv (nhdsWithin (Inv.inv a) (Set.Ici (Inv.inv a))) (nhdsWithin a (Set.Iic a))","decl":"@[to_additive existing, deprecated (since := \"2024-12-22\")]\nalias tendsto_inv_nhdsWithin_Ici_inv := tendsto_inv_nhdsGE_inv\n\n"}
{"name":"tendsto_neg_nhdsLE_neg","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"H : Type x\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : OrderedAddCommGroup H\ninstâœ : ContinuousNeg H\na : H\nâŠ¢ Filter.Tendsto Neg.neg (nhdsWithin (Neg.neg a) (Set.Iic (Neg.neg a))) (nhdsWithin a (Set.Ici a))","decl":"@[to_additive]\ntheorem tendsto_inv_nhdsLE_inv {a : H} : Tendsto Inv.inv (ð“[â‰¤] aâ»Â¹) (ð“[â‰¥] a) := by\n  simpa only [inv_inv] using @tendsto_inv_nhdsLE _ _ _ _ aâ»Â¹\n\n"}
{"name":"tendsto_inv_nhdsLE_inv","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"H : Type x\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : OrderedCommGroup H\ninstâœ : ContinuousInv H\na : H\nâŠ¢ Filter.Tendsto Inv.inv (nhdsWithin (Inv.inv a) (Set.Iic (Inv.inv a))) (nhdsWithin a (Set.Ici a))","decl":"@[to_additive]\ntheorem tendsto_inv_nhdsLE_inv {a : H} : Tendsto Inv.inv (ð“[â‰¤] aâ»Â¹) (ð“[â‰¥] a) := by\n  simpa only [inv_inv] using @tendsto_inv_nhdsLE _ _ _ _ aâ»Â¹\n\n"}
{"name":"tendsto_neg_nhdsWithin_Iic_neg","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"H : Type x\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : OrderedAddCommGroup H\ninstâœ : ContinuousNeg H\na : H\nâŠ¢ Filter.Tendsto Neg.neg (nhdsWithin (Neg.neg a) (Set.Iic (Neg.neg a))) (nhdsWithin a (Set.Ici a))","decl":"@[deprecated (since := \"2024-12-22\")]\nalias tendsto_neg_nhdsWithin_Iic_neg := tendsto_neg_nhdsLE_neg\n"}
{"name":"tendsto_inv_nhdsWithin_Iic_inv","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"H : Type x\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : OrderedCommGroup H\ninstâœ : ContinuousInv H\na : H\nâŠ¢ Filter.Tendsto Inv.inv (nhdsWithin (Inv.inv a) (Set.Iic (Inv.inv a))) (nhdsWithin a (Set.Ici a))","decl":"@[to_additive existing, deprecated (since := \"2024-12-22\")]\nalias tendsto_inv_nhdsWithin_Iic_inv := tendsto_inv_nhdsLE_inv\n\n"}
{"name":"instTopologicalGroupProd","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\nH : Type x\ninstâœâµ : TopologicalSpace G\ninstâœâ´ : Group G\ninstâœÂ³ : TopologicalGroup G\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : Group H\ninstâœ : TopologicalGroup H\nâŠ¢ TopologicalGroup (Prod G H)","decl":"@[to_additive]\ninstance [TopologicalSpace H] [Group H] [TopologicalGroup H] : TopologicalGroup (G Ã— H) where\n  continuous_inv := continuous_inv.prodMap continuous_inv\n\n"}
{"name":"instTopologicalAddGroupSum","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\nH : Type x\ninstâœâµ : TopologicalSpace G\ninstâœâ´ : AddGroup G\ninstâœÂ³ : TopologicalAddGroup G\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : AddGroup H\ninstâœ : TopologicalAddGroup H\nâŠ¢ TopologicalAddGroup (Prod G H)","decl":"@[to_additive]\ninstance [TopologicalSpace H] [Group H] [TopologicalGroup H] : TopologicalGroup (G Ã— H) where\n  continuous_inv := continuous_inv.prodMap continuous_inv\n\n"}
{"name":"OrderDual.instTopologicalGroup","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : TopologicalGroup G\nâŠ¢ TopologicalGroup (OrderDual G)","decl":"@[to_additive]\ninstance OrderDual.instTopologicalGroup : TopologicalGroup Gáµ’áµˆ where\n\n"}
{"name":"OrderDual.instTopologicalAddGroup","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : TopologicalAddGroup G\nâŠ¢ TopologicalAddGroup (OrderDual G)","decl":"@[to_additive]\ninstance OrderDual.instTopologicalGroup : TopologicalGroup Gáµ’áµˆ where\n\n"}
{"name":"Pi.topologicalAddGroup","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î² : Type v\nC : Î² â†’ Type u_1\ninstâœÂ² : (b : Î²) â†’ TopologicalSpace (C b)\ninstâœÂ¹ : (b : Î²) â†’ AddGroup (C b)\ninstâœ : âˆ€ (b : Î²), TopologicalAddGroup (C b)\nâŠ¢ TopologicalAddGroup ((b : Î²) â†’ C b)","decl":"@[to_additive]\ninstance Pi.topologicalGroup {C : Î² â†’ Type*} [âˆ€ b, TopologicalSpace (C b)] [âˆ€ b, Group (C b)]\n    [âˆ€ b, TopologicalGroup (C b)] : TopologicalGroup (âˆ€ b, C b) where\n  continuous_inv := continuous_pi fun i => (continuous_apply i).inv\n\n"}
{"name":"Pi.topologicalGroup","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î² : Type v\nC : Î² â†’ Type u_1\ninstâœÂ² : (b : Î²) â†’ TopologicalSpace (C b)\ninstâœÂ¹ : (b : Î²) â†’ Group (C b)\ninstâœ : âˆ€ (b : Î²), TopologicalGroup (C b)\nâŠ¢ TopologicalGroup ((b : Î²) â†’ C b)","decl":"@[to_additive]\ninstance Pi.topologicalGroup {C : Î² â†’ Type*} [âˆ€ b, TopologicalSpace (C b)] [âˆ€ b, Group (C b)]\n    [âˆ€ b, TopologicalGroup (C b)] : TopologicalGroup (âˆ€ b, C b) where\n  continuous_inv := continuous_pi fun i => (continuous_apply i).inv\n\n"}
{"name":"instContinuousInvMulOpposite","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : Inv Î±\ninstâœ : ContinuousInv Î±\nâŠ¢ ContinuousInv (MulOpposite Î±)","decl":"@[to_additive]\ninstance [Inv Î±] [ContinuousInv Î±] : ContinuousInv Î±áµáµ’áµ– :=\n  opHomeomorph.symm.isInducing.continuousInv unop_inv\n\n"}
{"name":"instContinuousNegAddOpposite","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : Neg Î±\ninstâœ : ContinuousNeg Î±\nâŠ¢ ContinuousNeg (AddOpposite Î±)","decl":"@[to_additive]\ninstance [Inv Î±] [ContinuousInv Î±] : ContinuousInv Î±áµáµ’áµ– :=\n  opHomeomorph.symm.isInducing.continuousInv unop_inv\n\n"}
{"name":"instTopologicalGroupMulOpposite","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : Group Î±\ninstâœ : TopologicalGroup Î±\nâŠ¢ TopologicalGroup (MulOpposite Î±)","decl":"/-- If multiplication is continuous in `Î±`, then it also is in `Î±áµáµ’áµ–`. -/\n@[to_additive \"If addition is continuous in `Î±`, then it also is in `Î±áµƒáµ’áµ–`.\"]\ninstance [Group Î±] [TopologicalGroup Î±] : TopologicalGroup Î±áµáµ’áµ– where\n\n"}
{"name":"instTopologicalAddGroupAddOpposite","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : AddGroup Î±\ninstâœ : TopologicalAddGroup Î±\nâŠ¢ TopologicalAddGroup (AddOpposite Î±)","decl":"/-- If multiplication is continuous in `Î±`, then it also is in `Î±áµáµ’áµ–`. -/\n@[to_additive \"If addition is continuous in `Î±`, then it also is in `Î±áµƒáµ’áµ–`.\"]\ninstance [Group Î±] [TopologicalGroup Î±] : TopologicalGroup Î±áµáµ’áµ– where\n\n"}
{"name":"nhds_zero_symm","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : TopologicalAddGroup G\nâŠ¢ Eq (Filter.comap Neg.neg (nhds 0)) (nhds 0)","decl":"@[to_additive]\ntheorem nhds_one_symm : comap Inv.inv (ð“ (1 : G)) = ð“ (1 : G) :=\n  ((Homeomorph.inv G).comap_nhds_eq _).trans (congr_arg nhds inv_one)\n\n"}
{"name":"nhds_one_symm","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : TopologicalGroup G\nâŠ¢ Eq (Filter.comap Inv.inv (nhds 1)) (nhds 1)","decl":"@[to_additive]\ntheorem nhds_one_symm : comap Inv.inv (ð“ (1 : G)) = ð“ (1 : G) :=\n  ((Homeomorph.inv G).comap_nhds_eq _).trans (congr_arg nhds inv_one)\n\n"}
{"name":"nhds_zero_symm'","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : TopologicalAddGroup G\nâŠ¢ Eq (Filter.map Neg.neg (nhds 0)) (nhds 0)","decl":"@[to_additive]\ntheorem nhds_one_symm' : map Inv.inv (ð“ (1 : G)) = ð“ (1 : G) :=\n  ((Homeomorph.inv G).map_nhds_eq _).trans (congr_arg nhds inv_one)\n\n"}
{"name":"nhds_one_symm'","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : TopologicalGroup G\nâŠ¢ Eq (Filter.map Inv.inv (nhds 1)) (nhds 1)","decl":"@[to_additive]\ntheorem nhds_one_symm' : map Inv.inv (ð“ (1 : G)) = ð“ (1 : G) :=\n  ((Homeomorph.inv G).map_nhds_eq _).trans (congr_arg nhds inv_one)\n\n"}
{"name":"inv_mem_nhds_one","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : TopologicalGroup G\nS : Set G\nhS : Membership.mem (nhds 1) S\nâŠ¢ Membership.mem (nhds 1) (Inv.inv S)","decl":"@[to_additive]\ntheorem inv_mem_nhds_one {S : Set G} (hS : S âˆˆ (ð“ 1 : Filter G)) : Sâ»Â¹ âˆˆ ð“ (1 : G) := by\n  rwa [â† nhds_one_symm'] at hS\n\n"}
{"name":"neg_mem_nhds_zero","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : TopologicalAddGroup G\nS : Set G\nhS : Membership.mem (nhds 0) S\nâŠ¢ Membership.mem (nhds 0) (Neg.neg S)","decl":"@[to_additive]\ntheorem inv_mem_nhds_one {S : Set G} (hS : S âˆˆ (ð“ 1 : Filter G)) : Sâ»Â¹ âˆˆ ð“ (1 : G) := by\n  rwa [â† nhds_one_symm'] at hS\n\n"}
{"name":"Homeomorph.shearAddRight_coe","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : TopologicalAddGroup G\nâŠ¢ Eq â‡‘(Homeomorph.shearAddRight G) fun z => { fst := z.1, snd := HAdd.hAdd z.1 z.2 }","decl":"@[to_additive (attr := simp)]\ntheorem Homeomorph.shearMulRight_coe :\n    â‡‘(Homeomorph.shearMulRight G) = fun z : G Ã— G => (z.1, z.1 * z.2) :=\n  rfl\n\n"}
{"name":"Homeomorph.shearMulRight_coe","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : TopologicalGroup G\nâŠ¢ Eq â‡‘(Homeomorph.shearMulRight G) fun z => { fst := z.1, snd := HMul.hMul z.1 z.2 }","decl":"@[to_additive (attr := simp)]\ntheorem Homeomorph.shearMulRight_coe :\n    â‡‘(Homeomorph.shearMulRight G) = fun z : G Ã— G => (z.1, z.1 * z.2) :=\n  rfl\n\n"}
{"name":"Homeomorph.shearAddRight_symm_coe","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : TopologicalAddGroup G\nâŠ¢ Eq â‡‘(Homeomorph.shearAddRight G).symm fun z => { fst := z.1, snd := HAdd.hAdd (Neg.neg z.1) z.2 }","decl":"@[to_additive (attr := simp)]\ntheorem Homeomorph.shearMulRight_symm_coe :\n    â‡‘(Homeomorph.shearMulRight G).symm = fun z : G Ã— G => (z.1, z.1â»Â¹ * z.2) :=\n  rfl\n\n"}
{"name":"Homeomorph.shearMulRight_symm_coe","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : TopologicalGroup G\nâŠ¢ Eq â‡‘(Homeomorph.shearMulRight G).symm fun z => { fst := z.1, snd := HMul.hMul (Inv.inv z.1) z.2 }","decl":"@[to_additive (attr := simp)]\ntheorem Homeomorph.shearMulRight_symm_coe :\n    â‡‘(Homeomorph.shearMulRight G).symm = fun z : G Ã— G => (z.1, z.1â»Â¹ * z.2) :=\n  rfl\n\n"}
{"name":"Topology.IsInducing.topologicalGroup","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\nH : Type x\ninstâœâ¶ : TopologicalSpace G\ninstâœâµ : Group G\ninstâœâ´ : TopologicalGroup G\nF : Type u_1\ninstâœÂ³ : Group H\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : FunLike F H G\ninstâœ : MonoidHomClass F H G\nf : F\nhf : Topology.IsInducing â‡‘f\nâŠ¢ TopologicalGroup H","decl":"@[to_additive]\nprotected theorem Topology.IsInducing.topologicalGroup {F : Type*} [Group H] [TopologicalSpace H]\n    [FunLike F H G] [MonoidHomClass F H G] (f : F) (hf : IsInducing f) : TopologicalGroup H :=\n  { toContinuousMul := hf.continuousMul _\n    toContinuousInv := hf.continuousInv (map_inv f) }\n\n"}
{"name":"Topology.IsInducing.topologicalAddGroup","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\nH : Type x\ninstâœâ¶ : TopologicalSpace G\ninstâœâµ : AddGroup G\ninstâœâ´ : TopologicalAddGroup G\nF : Type u_1\ninstâœÂ³ : AddGroup H\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : FunLike F H G\ninstâœ : AddMonoidHomClass F H G\nf : F\nhf : Topology.IsInducing â‡‘f\nâŠ¢ TopologicalAddGroup H","decl":"@[to_additive]\nprotected theorem Topology.IsInducing.topologicalGroup {F : Type*} [Group H] [TopologicalSpace H]\n    [FunLike F H G] [MonoidHomClass F H G] (f : F) (hf : IsInducing f) : TopologicalGroup H :=\n  { toContinuousMul := hf.continuousMul _\n    toContinuousInv := hf.continuousInv (map_inv f) }\n\n"}
{"name":"Inducing.topologicalGroup","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\nH : Type x\ninstâœâ¶ : TopologicalSpace G\ninstâœâµ : Group G\ninstâœâ´ : TopologicalGroup G\nF : Type u_1\ninstâœÂ³ : Group H\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : FunLike F H G\ninstâœ : MonoidHomClass F H G\nf : F\nhf : Topology.IsInducing â‡‘f\nâŠ¢ TopologicalGroup H","decl":"@[deprecated (since := \"2024-10-28\")] alias Inducing.topologicalGroup := IsInducing.topologicalGroup\n\n"}
{"name":"topologicalGroup_induced","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\nH : Type x\ninstâœâµ : TopologicalSpace G\ninstâœâ´ : Group G\ninstâœÂ³ : TopologicalGroup G\nF : Type u_1\ninstâœÂ² : Group H\ninstâœÂ¹ : FunLike F H G\ninstâœ : MonoidHomClass F H G\nf : F\nâŠ¢ TopologicalGroup H","decl":"@[to_additive]\ntheorem topologicalGroup_induced {F : Type*} [Group H] [FunLike F H G] [MonoidHomClass F H G]\n    (f : F) :\n    @TopologicalGroup H (induced f â€¹_â€º) _ :=\n  letI := induced f â€¹_â€º\n  IsInducing.topologicalGroup f âŸ¨rflâŸ©\n\n"}
{"name":"topologicalAddGroup_induced","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\nH : Type x\ninstâœâµ : TopologicalSpace G\ninstâœâ´ : AddGroup G\ninstâœÂ³ : TopologicalAddGroup G\nF : Type u_1\ninstâœÂ² : AddGroup H\ninstâœÂ¹ : FunLike F H G\ninstâœ : AddMonoidHomClass F H G\nf : F\nâŠ¢ TopologicalAddGroup H","decl":"@[to_additive]\ntheorem topologicalGroup_induced {F : Type*} [Group H] [FunLike F H G] [MonoidHomClass F H G]\n    (f : F) :\n    @TopologicalGroup H (induced f â€¹_â€º) _ :=\n  letI := induced f â€¹_â€º\n  IsInducing.topologicalGroup f âŸ¨rflâŸ©\n\n"}
{"name":"AddSubgroup.instTopologicalAddGroupSubtypeMem","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : TopologicalAddGroup G\nS : AddSubgroup G\nâŠ¢ TopologicalAddGroup (Subtype fun x => Membership.mem S x)","decl":"@[to_additive]\ninstance (S : Subgroup G) : TopologicalGroup S :=\n  IsInducing.subtypeVal.topologicalGroup S.subtype\n\n"}
{"name":"Subgroup.instTopologicalGroupSubtypeMem","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : TopologicalGroup G\nS : Subgroup G\nâŠ¢ TopologicalGroup (Subtype fun x => Membership.mem S x)","decl":"@[to_additive]\ninstance (S : Subgroup G) : TopologicalGroup S :=\n  IsInducing.subtypeVal.topologicalGroup S.subtype\n\n"}
{"name":"Subgroup.topologicalClosure_coe","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : TopologicalGroup G\ns : Subgroup G\nâŠ¢ Eq (â†‘s.topologicalClosure) (closure â†‘s)","decl":"@[to_additive (attr := simp)]\ntheorem Subgroup.topologicalClosure_coe {s : Subgroup G} :\n    (s.topologicalClosure : Set G) = _root_.closure s :=\n  rfl\n\n"}
{"name":"AddSubgroup.topologicalClosure_coe","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : TopologicalAddGroup G\ns : AddSubgroup G\nâŠ¢ Eq (â†‘s.topologicalClosure) (closure â†‘s)","decl":"@[to_additive (attr := simp)]\ntheorem Subgroup.topologicalClosure_coe {s : Subgroup G} :\n    (s.topologicalClosure : Set G) = _root_.closure s :=\n  rfl\n\n"}
{"name":"Subgroup.le_topologicalClosure","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : TopologicalGroup G\ns : Subgroup G\nâŠ¢ LE.le s s.topologicalClosure","decl":"@[to_additive]\ntheorem Subgroup.le_topologicalClosure (s : Subgroup G) : s â‰¤ s.topologicalClosure :=\n  _root_.subset_closure\n\n"}
{"name":"AddSubgroup.le_topologicalClosure","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : TopologicalAddGroup G\ns : AddSubgroup G\nâŠ¢ LE.le s s.topologicalClosure","decl":"@[to_additive]\ntheorem Subgroup.le_topologicalClosure (s : Subgroup G) : s â‰¤ s.topologicalClosure :=\n  _root_.subset_closure\n\n"}
{"name":"Subgroup.isClosed_topologicalClosure","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : TopologicalGroup G\ns : Subgroup G\nâŠ¢ IsClosed â†‘s.topologicalClosure","decl":"@[to_additive]\ntheorem Subgroup.isClosed_topologicalClosure (s : Subgroup G) :\n    IsClosed (s.topologicalClosure : Set G) := isClosed_closure\n\n"}
{"name":"AddSubgroup.isClosed_topologicalClosure","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : TopologicalAddGroup G\ns : AddSubgroup G\nâŠ¢ IsClosed â†‘s.topologicalClosure","decl":"@[to_additive]\ntheorem Subgroup.isClosed_topologicalClosure (s : Subgroup G) :\n    IsClosed (s.topologicalClosure : Set G) := isClosed_closure\n\n"}
{"name":"Subgroup.topologicalClosure_minimal","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : TopologicalGroup G\ns t : Subgroup G\nh : LE.le s t\nht : IsClosed â†‘t\nâŠ¢ LE.le s.topologicalClosure t","decl":"@[to_additive]\ntheorem Subgroup.topologicalClosure_minimal (s : Subgroup G) {t : Subgroup G} (h : s â‰¤ t)\n    (ht : IsClosed (t : Set G)) : s.topologicalClosure â‰¤ t :=\n  closure_minimal h ht\n\n"}
{"name":"AddSubgroup.topologicalClosure_minimal","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : TopologicalAddGroup G\ns t : AddSubgroup G\nh : LE.le s t\nht : IsClosed â†‘t\nâŠ¢ LE.le s.topologicalClosure t","decl":"@[to_additive]\ntheorem Subgroup.topologicalClosure_minimal (s : Subgroup G) {t : Subgroup G} (h : s â‰¤ t)\n    (ht : IsClosed (t : Set G)) : s.topologicalClosure â‰¤ t :=\n  closure_minimal h ht\n\n"}
{"name":"DenseRange.topologicalClosure_map_subgroup","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\nH : Type x\ninstâœâµ : TopologicalSpace G\ninstâœâ´ : Group G\ninstâœÂ³ : TopologicalGroup G\ninstâœÂ² : Group H\ninstâœÂ¹ : TopologicalSpace H\ninstâœ : TopologicalGroup H\nf : MonoidHom G H\nhf : Continuous â‡‘f\nhf' : DenseRange â‡‘f\ns : Subgroup G\nhs : Eq s.topologicalClosure Top.top\nâŠ¢ Eq (Subgroup.map f s).topologicalClosure Top.top","decl":"@[to_additive]\ntheorem DenseRange.topologicalClosure_map_subgroup [Group H] [TopologicalSpace H]\n    [TopologicalGroup H] {f : G â†’* H} (hf : Continuous f) (hf' : DenseRange f) {s : Subgroup G}\n    (hs : s.topologicalClosure = âŠ¤) : (s.map f).topologicalClosure = âŠ¤ := by\n  rw [SetLike.ext'_iff] at hs âŠ¢\n  simp only [Subgroup.topologicalClosure_coe, Subgroup.coe_top, â† dense_iff_closure_eq] at hs âŠ¢\n  exact hf'.dense_image hf hs\n\n"}
{"name":"DenseRange.topologicalClosure_map_addSubgroup","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\nH : Type x\ninstâœâµ : TopologicalSpace G\ninstâœâ´ : AddGroup G\ninstâœÂ³ : TopologicalAddGroup G\ninstâœÂ² : AddGroup H\ninstâœÂ¹ : TopologicalSpace H\ninstâœ : TopologicalAddGroup H\nf : AddMonoidHom G H\nhf : Continuous â‡‘f\nhf' : DenseRange â‡‘f\ns : AddSubgroup G\nhs : Eq s.topologicalClosure Top.top\nâŠ¢ Eq (AddSubgroup.map f s).topologicalClosure Top.top","decl":"@[to_additive]\ntheorem DenseRange.topologicalClosure_map_subgroup [Group H] [TopologicalSpace H]\n    [TopologicalGroup H] {f : G â†’* H} (hf : Continuous f) (hf' : DenseRange f) {s : Subgroup G}\n    (hs : s.topologicalClosure = âŠ¤) : (s.map f).topologicalClosure = âŠ¤ := by\n  rw [SetLike.ext'_iff] at hs âŠ¢\n  simp only [Subgroup.topologicalClosure_coe, Subgroup.coe_top, â† dense_iff_closure_eq] at hs âŠ¢\n  exact hf'.dense_image hf hs\n\n"}
{"name":"Subgroup.is_normal_topologicalClosure","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type u_1\ninstâœÂ³ : TopologicalSpace G\ninstâœÂ² : Group G\ninstâœÂ¹ : TopologicalGroup G\nN : Subgroup G\ninstâœ : N.Normal\nâŠ¢ N.topologicalClosure.Normal","decl":"/-- The topological closure of a normal subgroup is normal. -/\n@[to_additive \"The topological closure of a normal additive subgroup is normal.\"]\ntheorem Subgroup.is_normal_topologicalClosure {G : Type*} [TopologicalSpace G] [Group G]\n    [TopologicalGroup G] (N : Subgroup G) [N.Normal] : (Subgroup.topologicalClosure N).Normal where\n  conj_mem n hn g := by\n    apply map_mem_closure (TopologicalGroup.continuous_conj g) hn\n    exact fun m hm => Subgroup.Normal.conj_mem inferInstance m hm g\n\n"}
{"name":"AddSubgroup.is_normal_topologicalClosure","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type u_1\ninstâœÂ³ : TopologicalSpace G\ninstâœÂ² : AddGroup G\ninstâœÂ¹ : TopologicalAddGroup G\nN : AddSubgroup G\ninstâœ : N.Normal\nâŠ¢ N.topologicalClosure.Normal","decl":"/-- The topological closure of a normal subgroup is normal. -/\n@[to_additive \"The topological closure of a normal additive subgroup is normal.\"]\ntheorem Subgroup.is_normal_topologicalClosure {G : Type*} [TopologicalSpace G] [Group G]\n    [TopologicalGroup G] (N : Subgroup G) [N.Normal] : (Subgroup.topologicalClosure N).Normal where\n  conj_mem n hn g := by\n    apply map_mem_closure (TopologicalGroup.continuous_conj g) hn\n    exact fun m hm => Subgroup.Normal.conj_mem inferInstance m hm g\n\n"}
{"name":"add_mem_connectedComponent_zero","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type u_1\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddZeroClass G\ninstâœ : ContinuousAdd G\ng h : G\nhg : Membership.mem (connectedComponent 0) g\nhh : Membership.mem (connectedComponent 0) h\nâŠ¢ Membership.mem (connectedComponent 0) (HAdd.hAdd g h)","decl":"@[to_additive]\ntheorem mul_mem_connectedComponent_one {G : Type*} [TopologicalSpace G] [MulOneClass G]\n    [ContinuousMul G] {g h : G} (hg : g âˆˆ connectedComponent (1 : G))\n    (hh : h âˆˆ connectedComponent (1 : G)) : g * h âˆˆ connectedComponent (1 : G) := by\n  rw [connectedComponent_eq hg]\n  have hmul : g âˆˆ connectedComponent (g * h) := by\n    apply Continuous.image_connectedComponent_subset (continuous_mul_left g)\n    rw [â† connectedComponent_eq hh]\n    exact âŸ¨(1 : G), mem_connectedComponent, by simp only [mul_one]âŸ©\n  simpa [â† connectedComponent_eq hmul] using mem_connectedComponent\n\n"}
{"name":"mul_mem_connectedComponent_one","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type u_1\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : MulOneClass G\ninstâœ : ContinuousMul G\ng h : G\nhg : Membership.mem (connectedComponent 1) g\nhh : Membership.mem (connectedComponent 1) h\nâŠ¢ Membership.mem (connectedComponent 1) (HMul.hMul g h)","decl":"@[to_additive]\ntheorem mul_mem_connectedComponent_one {G : Type*} [TopologicalSpace G] [MulOneClass G]\n    [ContinuousMul G] {g h : G} (hg : g âˆˆ connectedComponent (1 : G))\n    (hh : h âˆˆ connectedComponent (1 : G)) : g * h âˆˆ connectedComponent (1 : G) := by\n  rw [connectedComponent_eq hg]\n  have hmul : g âˆˆ connectedComponent (g * h) := by\n    apply Continuous.image_connectedComponent_subset (continuous_mul_left g)\n    rw [â† connectedComponent_eq hh]\n    exact âŸ¨(1 : G), mem_connectedComponent, by simp only [mul_one]âŸ©\n  simpa [â† connectedComponent_eq hmul] using mem_connectedComponent\n\n"}
{"name":"neg_mem_connectedComponent_zero","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type u_1\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : TopologicalAddGroup G\ng : G\nhg : Membership.mem (connectedComponent 0) g\nâŠ¢ Membership.mem (connectedComponent 0) (Neg.neg g)","decl":"@[to_additive]\ntheorem inv_mem_connectedComponent_one {G : Type*} [TopologicalSpace G] [Group G]\n    [TopologicalGroup G] {g : G} (hg : g âˆˆ connectedComponent (1 : G)) :\n    gâ»Â¹ âˆˆ connectedComponent (1 : G) := by\n  rw [â† inv_one]\n  exact\n    Continuous.image_connectedComponent_subset continuous_inv _\n      ((Set.mem_image _ _ _).mp âŸ¨g, hg, rflâŸ©)\n\n"}
{"name":"inv_mem_connectedComponent_one","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type u_1\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : TopologicalGroup G\ng : G\nhg : Membership.mem (connectedComponent 1) g\nâŠ¢ Membership.mem (connectedComponent 1) (Inv.inv g)","decl":"@[to_additive]\ntheorem inv_mem_connectedComponent_one {G : Type*} [TopologicalSpace G] [Group G]\n    [TopologicalGroup G] {g : G} (hg : g âˆˆ connectedComponent (1 : G)) :\n    gâ»Â¹ âˆˆ connectedComponent (1 : G) := by\n  rw [â† inv_one]\n  exact\n    Continuous.image_connectedComponent_subset continuous_inv _\n      ((Set.mem_image _ _ _).mp âŸ¨g, hg, rflâŸ©)\n\n"}
{"name":"Subgroup.coe_topologicalClosure_bot","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : TopologicalGroup G\nâŠ¢ Eq (â†‘Bot.bot.topologicalClosure) (closure (Singleton.singleton 1))","decl":"variable (G) in\n@[to_additive]\nlemma Subgroup.coe_topologicalClosure_bot :\n    ((âŠ¥ : Subgroup G).topologicalClosure : Set G) = _root_.closure ({1} : Set G) := by simp\n\n"}
{"name":"AddSubgroup.coe_topologicalClosure_bot","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : TopologicalAddGroup G\nâŠ¢ Eq (â†‘Bot.bot.topologicalClosure) (closure (Singleton.singleton 0))","decl":"variable (G) in\n@[to_additive]\nlemma Subgroup.coe_topologicalClosure_bot :\n    ((âŠ¥ : Subgroup G).topologicalClosure : Set G) = _root_.closure ({1} : Set G) := by simp\n\n"}
{"name":"exists_nhds_split_inv","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : TopologicalGroup G\ns : Set G\nhs : Membership.mem (nhds 1) s\nâŠ¢ Exists fun V => And (Membership.mem (nhds 1) V) (âˆ€ (v : G), Membership.mem V v â†’ âˆ€ (w : G), Membership.mem V w â†’ Membership.mem s (HDiv.hDiv v w))","decl":"@[to_additive exists_nhds_half_neg]\ntheorem exists_nhds_split_inv {s : Set G} (hs : s âˆˆ ð“ (1 : G)) :\n    âˆƒ V âˆˆ ð“ (1 : G), âˆ€ v âˆˆ V, âˆ€ w âˆˆ V, v / w âˆˆ s := by\n  have : (fun p : G Ã— G => p.1 * p.2â»Â¹) â»Â¹' s âˆˆ ð“ ((1, 1) : G Ã— G) :=\n    continuousAt_fst.mul continuousAt_snd.inv (by simpa)\n  simpa only [div_eq_mul_inv, nhds_prod_eq, mem_prod_self_iff, prod_subset_iff, mem_preimage] using\n    this\n\n"}
{"name":"exists_nhds_half_neg","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : TopologicalAddGroup G\ns : Set G\nhs : Membership.mem (nhds 0) s\nâŠ¢ Exists fun V => And (Membership.mem (nhds 0) V) (âˆ€ (v : G), Membership.mem V v â†’ âˆ€ (w : G), Membership.mem V w â†’ Membership.mem s (HSub.hSub v w))","decl":"@[to_additive exists_nhds_half_neg]\ntheorem exists_nhds_split_inv {s : Set G} (hs : s âˆˆ ð“ (1 : G)) :\n    âˆƒ V âˆˆ ð“ (1 : G), âˆ€ v âˆˆ V, âˆ€ w âˆˆ V, v / w âˆˆ s := by\n  have : (fun p : G Ã— G => p.1 * p.2â»Â¹) â»Â¹' s âˆˆ ð“ ((1, 1) : G Ã— G) :=\n    continuousAt_fst.mul continuousAt_snd.inv (by simpa)\n  simpa only [div_eq_mul_inv, nhds_prod_eq, mem_prod_self_iff, prod_subset_iff, mem_preimage] using\n    this\n\n"}
{"name":"nhds_translation_mul_inv","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : TopologicalGroup G\nx : G\nâŠ¢ Eq (Filter.comap (fun x_1 => HMul.hMul x_1 (Inv.inv x)) (nhds 1)) (nhds x)","decl":"@[to_additive]\ntheorem nhds_translation_mul_inv (x : G) : comap (Â· * xâ»Â¹) (ð“ 1) = ð“ x :=\n  ((Homeomorph.mulRight xâ»Â¹).comap_nhds_eq 1).trans <| show ð“ (1 * xâ»Â¹â»Â¹) = ð“ x by simp\n\n"}
{"name":"nhds_translation_add_neg","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : TopologicalAddGroup G\nx : G\nâŠ¢ Eq (Filter.comap (fun x_1 => HAdd.hAdd x_1 (Neg.neg x)) (nhds 0)) (nhds x)","decl":"@[to_additive]\ntheorem nhds_translation_mul_inv (x : G) : comap (Â· * xâ»Â¹) (ð“ 1) = ð“ x :=\n  ((Homeomorph.mulRight xâ»Â¹).comap_nhds_eq 1).trans <| show ð“ (1 * xâ»Â¹â»Â¹) = ð“ x by simp\n\n"}
{"name":"map_mul_left_nhds","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : TopologicalGroup G\nx y : G\nâŠ¢ Eq (Filter.map (fun x_1 => HMul.hMul x x_1) (nhds y)) (nhds (HMul.hMul x y))","decl":"@[to_additive (attr := simp)]\ntheorem map_mul_left_nhds (x y : G) : map (x * Â·) (ð“ y) = ð“ (x * y) :=\n  (Homeomorph.mulLeft x).map_nhds_eq y\n\n"}
{"name":"map_add_left_nhds","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : TopologicalAddGroup G\nx y : G\nâŠ¢ Eq (Filter.map (fun x_1 => HAdd.hAdd x x_1) (nhds y)) (nhds (HAdd.hAdd x y))","decl":"@[to_additive (attr := simp)]\ntheorem map_mul_left_nhds (x y : G) : map (x * Â·) (ð“ y) = ð“ (x * y) :=\n  (Homeomorph.mulLeft x).map_nhds_eq y\n\n"}
{"name":"map_add_left_nhds_zero","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : TopologicalAddGroup G\nx : G\nâŠ¢ Eq (Filter.map (fun x_1 => HAdd.hAdd x x_1) (nhds 0)) (nhds x)","decl":"@[to_additive]\ntheorem map_mul_left_nhds_one (x : G) : map (x * Â·) (ð“ 1) = ð“ x := by simp\n\n"}
{"name":"map_mul_left_nhds_one","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : TopologicalGroup G\nx : G\nâŠ¢ Eq (Filter.map (fun x_1 => HMul.hMul x x_1) (nhds 1)) (nhds x)","decl":"@[to_additive]\ntheorem map_mul_left_nhds_one (x : G) : map (x * Â·) (ð“ 1) = ð“ x := by simp\n\n"}
{"name":"map_add_right_nhds","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : TopologicalAddGroup G\nx y : G\nâŠ¢ Eq (Filter.map (fun x_1 => HAdd.hAdd x_1 x) (nhds y)) (nhds (HAdd.hAdd y x))","decl":"@[to_additive (attr := simp)]\ntheorem map_mul_right_nhds (x y : G) : map (Â· * x) (ð“ y) = ð“ (y * x) :=\n  (Homeomorph.mulRight x).map_nhds_eq y\n\n"}
{"name":"map_mul_right_nhds","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : TopologicalGroup G\nx y : G\nâŠ¢ Eq (Filter.map (fun x_1 => HMul.hMul x_1 x) (nhds y)) (nhds (HMul.hMul y x))","decl":"@[to_additive (attr := simp)]\ntheorem map_mul_right_nhds (x y : G) : map (Â· * x) (ð“ y) = ð“ (y * x) :=\n  (Homeomorph.mulRight x).map_nhds_eq y\n\n"}
{"name":"map_add_right_nhds_zero","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : TopologicalAddGroup G\nx : G\nâŠ¢ Eq (Filter.map (fun x_1 => HAdd.hAdd x_1 x) (nhds 0)) (nhds x)","decl":"@[to_additive]\ntheorem map_mul_right_nhds_one (x : G) : map (Â· * x) (ð“ 1) = ð“ x := by simp\n\n"}
{"name":"map_mul_right_nhds_one","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : TopologicalGroup G\nx : G\nâŠ¢ Eq (Filter.map (fun x_1 => HMul.hMul x_1 x) (nhds 1)) (nhds x)","decl":"@[to_additive]\ntheorem map_mul_right_nhds_one (x : G) : map (Â· * x) (ð“ 1) = ð“ x := by simp\n\n"}
{"name":"Filter.HasBasis.nhds_of_one","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : TopologicalGroup G\nÎ¹ : Sort u_1\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set G\nhb : (nhds 1).HasBasis p s\nx : G\nâŠ¢ (nhds x).HasBasis p fun i => setOf fun y => Membership.mem (s i) (HDiv.hDiv y x)","decl":"@[to_additive]\ntheorem Filter.HasBasis.nhds_of_one {Î¹ : Sort*} {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set G}\n    (hb : HasBasis (ð“ 1 : Filter G) p s) (x : G) :\n    HasBasis (ð“ x) p fun i => { y | y / x âˆˆ s i } := by\n  rw [â† nhds_translation_mul_inv]\n  simp_rw [div_eq_mul_inv]\n  exact hb.comap _\n\n"}
{"name":"Filter.HasBasis.nhds_of_zero","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : TopologicalAddGroup G\nÎ¹ : Sort u_1\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set G\nhb : (nhds 0).HasBasis p s\nx : G\nâŠ¢ (nhds x).HasBasis p fun i => setOf fun y => Membership.mem (s i) (HSub.hSub y x)","decl":"@[to_additive]\ntheorem Filter.HasBasis.nhds_of_one {Î¹ : Sort*} {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set G}\n    (hb : HasBasis (ð“ 1 : Filter G) p s) (x : G) :\n    HasBasis (ð“ x) p fun i => { y | y / x âˆˆ s i } := by\n  rw [â† nhds_translation_mul_inv]\n  simp_rw [div_eq_mul_inv]\n  exact hb.comap _\n\n"}
{"name":"mem_closure_iff_nhds_one","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : TopologicalGroup G\nx : G\ns : Set G\nâŠ¢ Iff (Membership.mem (closure s) x) (âˆ€ (U : Set G), Membership.mem (nhds 1) U â†’ Exists fun y => And (Membership.mem s y) (Membership.mem U (HDiv.hDiv y x)))","decl":"@[to_additive]\ntheorem mem_closure_iff_nhds_one {x : G} {s : Set G} :\n    x âˆˆ closure s â†” âˆ€ U âˆˆ (ð“ 1 : Filter G), âˆƒ y âˆˆ s, y / x âˆˆ U := by\n  rw [mem_closure_iff_nhds_basis ((ð“ 1 : Filter G).basis_sets.nhds_of_one x)]\n  simp_rw [Set.mem_setOf, id]\n\n"}
{"name":"mem_closure_iff_nhds_zero","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : TopologicalAddGroup G\nx : G\ns : Set G\nâŠ¢ Iff (Membership.mem (closure s) x) (âˆ€ (U : Set G), Membership.mem (nhds 0) U â†’ Exists fun y => And (Membership.mem s y) (Membership.mem U (HSub.hSub y x)))","decl":"@[to_additive]\ntheorem mem_closure_iff_nhds_one {x : G} {s : Set G} :\n    x âˆˆ closure s â†” âˆ€ U âˆˆ (ð“ 1 : Filter G), âˆƒ y âˆˆ s, y / x âˆˆ U := by\n  rw [mem_closure_iff_nhds_basis ((ð“ 1 : Filter G).basis_sets.nhds_of_one x)]\n  simp_rw [Set.mem_setOf, id]\n\n"}
{"name":"continuous_of_continuousAt_one","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœâ· : TopologicalSpace G\ninstâœâ¶ : Group G\ninstâœâµ : TopologicalGroup G\nM : Type u_1\nhom : Type u_2\ninstâœâ´ : MulOneClass M\ninstâœÂ³ : TopologicalSpace M\ninstâœÂ² : ContinuousMul M\ninstâœÂ¹ : FunLike hom G M\ninstâœ : MonoidHomClass hom G M\nf : hom\nhf : ContinuousAt (â‡‘f) 1\nâŠ¢ Continuous â‡‘f","decl":"/-- A monoid homomorphism (a bundled morphism of a type that implements `MonoidHomClass`) from a\ntopological group to a topological monoid is continuous provided that it is continuous at one. See\nalso `uniformContinuous_of_continuousAt_one`. -/\n@[to_additive\n  \"An additive monoid homomorphism (a bundled morphism of a type that implements\n  `AddMonoidHomClass`) from an additive topological group to an additive topological monoid is\n  continuous provided that it is continuous at zero. See also\n  `uniformContinuous_of_continuousAt_zero`.\"]\ntheorem continuous_of_continuousAt_one {M hom : Type*} [MulOneClass M] [TopologicalSpace M]\n    [ContinuousMul M] [FunLike hom G M] [MonoidHomClass hom G M] (f : hom)\n    (hf : ContinuousAt f 1) :\n    Continuous f :=\n  continuous_iff_continuousAt.2 fun x => by\n    simpa only [ContinuousAt, â† map_mul_left_nhds_one x, tendsto_map'_iff, Function.comp_def,\n      map_mul, map_one, mul_one] using hf.tendsto.const_mul (f x)\n\n"}
{"name":"continuous_of_continuousAt_zero","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœâ· : TopologicalSpace G\ninstâœâ¶ : AddGroup G\ninstâœâµ : TopologicalAddGroup G\nM : Type u_1\nhom : Type u_2\ninstâœâ´ : AddZeroClass M\ninstâœÂ³ : TopologicalSpace M\ninstâœÂ² : ContinuousAdd M\ninstâœÂ¹ : FunLike hom G M\ninstâœ : AddMonoidHomClass hom G M\nf : hom\nhf : ContinuousAt (â‡‘f) 0\nâŠ¢ Continuous â‡‘f","decl":"/-- A monoid homomorphism (a bundled morphism of a type that implements `MonoidHomClass`) from a\ntopological group to a topological monoid is continuous provided that it is continuous at one. See\nalso `uniformContinuous_of_continuousAt_one`. -/\n@[to_additive\n  \"An additive monoid homomorphism (a bundled morphism of a type that implements\n  `AddMonoidHomClass`) from an additive topological group to an additive topological monoid is\n  continuous provided that it is continuous at zero. See also\n  `uniformContinuous_of_continuousAt_zero`.\"]\ntheorem continuous_of_continuousAt_one {M hom : Type*} [MulOneClass M] [TopologicalSpace M]\n    [ContinuousMul M] [FunLike hom G M] [MonoidHomClass hom G M] (f : hom)\n    (hf : ContinuousAt f 1) :\n    Continuous f :=\n  continuous_iff_continuousAt.2 fun x => by\n    simpa only [ContinuousAt, â† map_mul_left_nhds_one x, tendsto_map'_iff, Function.comp_def,\n      map_mul, map_one, mul_one] using hf.tendsto.const_mul (f x)\n\n"}
{"name":"continuous_of_continuousAt_zeroâ‚‚","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœâ¸ : TopologicalSpace G\ninstâœâ· : AddGroup G\ninstâœâ¶ : TopologicalAddGroup G\nH : Type u_1\nM : Type u_2\ninstâœâµ : AddCommMonoid M\ninstâœâ´ : TopologicalSpace M\ninstâœÂ³ : ContinuousAdd M\ninstâœÂ² : AddGroup H\ninstâœÂ¹ : TopologicalSpace H\ninstâœ : TopologicalAddGroup H\nf : AddMonoidHom G (AddMonoidHom H M)\nhf : ContinuousAt (fun x => (f x.1) x.2) { fst := 0, snd := 0 }\nhl : âˆ€ (x : G), ContinuousAt (â‡‘(f x)) 0\nhr : âˆ€ (y : H), ContinuousAt (fun x => (f x) y) 0\nâŠ¢ Continuous fun x => (f x.1) x.2","decl":"@[to_additive continuous_of_continuousAt_zeroâ‚‚]\ntheorem continuous_of_continuousAt_oneâ‚‚ {H M : Type*} [CommMonoid M] [TopologicalSpace M]\n    [ContinuousMul M] [Group H] [TopologicalSpace H] [TopologicalGroup H] (f : G â†’* H â†’* M)\n    (hf : ContinuousAt (fun x : G Ã— H â†¦ f x.1 x.2) (1, 1))\n    (hl : âˆ€ x, ContinuousAt (f x) 1) (hr : âˆ€ y, ContinuousAt (f Â· y) 1) :\n    Continuous (fun x : G Ã— H â†¦ f x.1 x.2) := continuous_iff_continuousAt.2 fun (x, y) => by\n  simp only [ContinuousAt, nhds_prod_eq, â† map_mul_left_nhds_one x, â† map_mul_left_nhds_one y,\n    prod_map_map_eq, tendsto_map'_iff, Function.comp_def, map_mul, MonoidHom.mul_apply] at *\n  refine ((tendsto_const_nhds.mul ((hr y).comp tendsto_fst)).mul\n    (((hl x).comp tendsto_snd).mul hf)).mono_right (le_of_eq ?_)\n  simp only [map_one, mul_one, MonoidHom.one_apply]\n\n"}
{"name":"continuous_of_continuousAt_oneâ‚‚","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœâ¸ : TopologicalSpace G\ninstâœâ· : Group G\ninstâœâ¶ : TopologicalGroup G\nH : Type u_1\nM : Type u_2\ninstâœâµ : CommMonoid M\ninstâœâ´ : TopologicalSpace M\ninstâœÂ³ : ContinuousMul M\ninstâœÂ² : Group H\ninstâœÂ¹ : TopologicalSpace H\ninstâœ : TopologicalGroup H\nf : MonoidHom G (MonoidHom H M)\nhf : ContinuousAt (fun x => (f x.1) x.2) { fst := 1, snd := 1 }\nhl : âˆ€ (x : G), ContinuousAt (â‡‘(f x)) 1\nhr : âˆ€ (y : H), ContinuousAt (fun x => (f x) y) 1\nâŠ¢ Continuous fun x => (f x.1) x.2","decl":"@[to_additive continuous_of_continuousAt_zeroâ‚‚]\ntheorem continuous_of_continuousAt_oneâ‚‚ {H M : Type*} [CommMonoid M] [TopologicalSpace M]\n    [ContinuousMul M] [Group H] [TopologicalSpace H] [TopologicalGroup H] (f : G â†’* H â†’* M)\n    (hf : ContinuousAt (fun x : G Ã— H â†¦ f x.1 x.2) (1, 1))\n    (hl : âˆ€ x, ContinuousAt (f x) 1) (hr : âˆ€ y, ContinuousAt (f Â· y) 1) :\n    Continuous (fun x : G Ã— H â†¦ f x.1 x.2) := continuous_iff_continuousAt.2 fun (x, y) => by\n  simp only [ContinuousAt, nhds_prod_eq, â† map_mul_left_nhds_one x, â† map_mul_left_nhds_one y,\n    prod_map_map_eq, tendsto_map'_iff, Function.comp_def, map_mul, MonoidHom.mul_apply] at *\n  refine ((tendsto_const_nhds.mul ((hr y).comp tendsto_fst)).mul\n    (((hl x).comp tendsto_snd).mul hf)).mono_right (le_of_eq ?_)\n  simp only [map_one, mul_one, MonoidHom.one_apply]\n\n"}
{"name":"TopologicalAddGroup.isInducing_iff_nhds_zero","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœâ· : TopologicalSpace G\ninstâœâ¶ : AddGroup G\ninstâœâµ : TopologicalAddGroup G\nH : Type u_1\ninstâœâ´ : AddGroup H\ninstâœÂ³ : TopologicalSpace H\ninstâœÂ² : TopologicalAddGroup H\nF : Type u_2\ninstâœÂ¹ : FunLike F G H\ninstâœ : AddMonoidHomClass F G H\nf : F\nâŠ¢ Iff (Topology.IsInducing â‡‘f) (Eq (nhds 0) (Filter.comap (â‡‘f) (nhds 0)))","decl":"@[to_additive]\nlemma TopologicalGroup.isInducing_iff_nhds_one\n    {H : Type*} [Group H] [TopologicalSpace H] [TopologicalGroup H] {F : Type*}\n    [FunLike F G H] [MonoidHomClass F G H] {f : F} :\n    Topology.IsInducing f â†” ð“ (1 : G) = (ð“ (1 : H)).comap f := by\n  rw [Topology.isInducing_iff_nhds]\n  refine âŸ¨(map_one f â–¸ Â· 1), fun hf x â†¦ ?_âŸ©\n  rw [â† nhds_translation_mul_inv, â† nhds_translation_mul_inv (f x), Filter.comap_comap, hf,\n    Filter.comap_comap]\n  congr 1\n  ext; simp\n\n-- TODO: unify with `QuotientGroup.isOpenQuotientMap_mk`\n"}
{"name":"TopologicalGroup.isInducing_iff_nhds_one","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœâ· : TopologicalSpace G\ninstâœâ¶ : Group G\ninstâœâµ : TopologicalGroup G\nH : Type u_1\ninstâœâ´ : Group H\ninstâœÂ³ : TopologicalSpace H\ninstâœÂ² : TopologicalGroup H\nF : Type u_2\ninstâœÂ¹ : FunLike F G H\ninstâœ : MonoidHomClass F G H\nf : F\nâŠ¢ Iff (Topology.IsInducing â‡‘f) (Eq (nhds 1) (Filter.comap (â‡‘f) (nhds 1)))","decl":"@[to_additive]\nlemma TopologicalGroup.isInducing_iff_nhds_one\n    {H : Type*} [Group H] [TopologicalSpace H] [TopologicalGroup H] {F : Type*}\n    [FunLike F G H] [MonoidHomClass F G H] {f : F} :\n    Topology.IsInducing f â†” ð“ (1 : G) = (ð“ (1 : H)).comap f := by\n  rw [Topology.isInducing_iff_nhds]\n  refine âŸ¨(map_one f â–¸ Â· 1), fun hf x â†¦ ?_âŸ©\n  rw [â† nhds_translation_mul_inv, â† nhds_translation_mul_inv (f x), Filter.comap_comap, hf,\n    Filter.comap_comap]\n  congr 1\n  ext; simp\n\n-- TODO: unify with `QuotientGroup.isOpenQuotientMap_mk`\n"}
{"name":"AddMonoidHom.isOpenQuotientMap_of_isQuotientMap","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"A : Type u_1\ninstâœâ¶ : AddGroup A\ninstâœâµ : TopologicalSpace A\ninstâœâ´ : TopologicalAddGroup A\nB : Type u_2\ninstâœÂ³ : AddGroup B\ninstâœÂ² : TopologicalSpace B\nF : Type u_3\ninstâœÂ¹ : FunLike F A B\ninstâœ : AddMonoidHomClass F A B\nÏ† : F\nhÏ† : Topology.IsQuotientMap â‡‘Ï†\nâŠ¢ IsOpenQuotientMap â‡‘Ï†","decl":"/-- Let `A` and `B` be topological groups, and let `Ï† : A â†’ B` be a continuous surjective group\nhomomorphism. Assume furthermore that `Ï†` is a quotient map (i.e., `V âŠ† B`\nis open iff `Ï†â»Â¹ V` is open). Then `Ï†` is an open quotient map, and in particular an open map. -/\n@[to_additive \"Let `A` and `B` be topological additive groups, and let `Ï† : A â†’ B` be a continuous\nsurjective additive group homomorphism. Assume furthermore that `Ï†` is a quotient map (i.e., `V âŠ† B`\nis open iff `Ï†â»Â¹ V` is open). Then `Ï†` is an open quotient map, and in particular an open map.\"]\nlemma MonoidHom.isOpenQuotientMap_of_isQuotientMap {A : Type*} [Group A]\n    [TopologicalSpace A] [TopologicalGroup A] {B : Type*} [Group B] [TopologicalSpace B]\n    {F : Type*} [FunLike F A B] [MonoidHomClass F A B] {Ï† : F}\n    (hÏ† : IsQuotientMap Ï†) : IsOpenQuotientMap Ï† where\n    surjective := hÏ†.surjective\n    continuous := hÏ†.continuous\n    isOpenMap := by\n      -- We need to check that if `U âŠ† A` is open then `Ï†â»Â¹ (Ï† U)` is open.\n      intro U hU\n      rw [â† hÏ†.isOpen_preimage]\n      -- It suffices to show that `Ï†â»Â¹ (Ï† U) = â‹ƒ (U * kâ»Â¹)` as `k` runs through the kernel of `Ï†`,\n      -- as `U * kâ»Â¹` is open because `x â†¦ x * k` is continuous.\n      -- Remark: here is where we use that we have groups not monoids (you cannot avoid\n      -- using both `k` and `kâ»Â¹` at this point).\n      suffices â‡‘Ï† â»Â¹' (â‡‘Ï† '' U) = â‹ƒ k âˆˆ ker (Ï† : A â†’* B), (fun x â†¦ x * k) â»Â¹' U by\n        exact this â–¸ isOpen_biUnion (fun k _ â†¦ Continuous.isOpen_preimage (by fun_prop) _ hU)\n      ext x\n      -- But this is an elementary calculation.\n      constructor\n      Â· rintro âŸ¨y, hyU, hyxâŸ©\n        apply Set.mem_iUnion_of_mem (xâ»Â¹ * y)\n        simp_all\n      Â· rintro âŸ¨_, âŸ¨k, rflâŸ©, _, âŸ¨(hk : Ï† k = 1), rflâŸ©, hxâŸ©\n        use x * k, hx\n        rw [map_mul, hk, mul_one]\n\n"}
{"name":"MonoidHom.isOpenQuotientMap_of_isQuotientMap","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"A : Type u_1\ninstâœâ¶ : Group A\ninstâœâµ : TopologicalSpace A\ninstâœâ´ : TopologicalGroup A\nB : Type u_2\ninstâœÂ³ : Group B\ninstâœÂ² : TopologicalSpace B\nF : Type u_3\ninstâœÂ¹ : FunLike F A B\ninstâœ : MonoidHomClass F A B\nÏ† : F\nhÏ† : Topology.IsQuotientMap â‡‘Ï†\nâŠ¢ IsOpenQuotientMap â‡‘Ï†","decl":"/-- Let `A` and `B` be topological groups, and let `Ï† : A â†’ B` be a continuous surjective group\nhomomorphism. Assume furthermore that `Ï†` is a quotient map (i.e., `V âŠ† B`\nis open iff `Ï†â»Â¹ V` is open). Then `Ï†` is an open quotient map, and in particular an open map. -/\n@[to_additive \"Let `A` and `B` be topological additive groups, and let `Ï† : A â†’ B` be a continuous\nsurjective additive group homomorphism. Assume furthermore that `Ï†` is a quotient map (i.e., `V âŠ† B`\nis open iff `Ï†â»Â¹ V` is open). Then `Ï†` is an open quotient map, and in particular an open map.\"]\nlemma MonoidHom.isOpenQuotientMap_of_isQuotientMap {A : Type*} [Group A]\n    [TopologicalSpace A] [TopologicalGroup A] {B : Type*} [Group B] [TopologicalSpace B]\n    {F : Type*} [FunLike F A B] [MonoidHomClass F A B] {Ï† : F}\n    (hÏ† : IsQuotientMap Ï†) : IsOpenQuotientMap Ï† where\n    surjective := hÏ†.surjective\n    continuous := hÏ†.continuous\n    isOpenMap := by\n      -- We need to check that if `U âŠ† A` is open then `Ï†â»Â¹ (Ï† U)` is open.\n      intro U hU\n      rw [â† hÏ†.isOpen_preimage]\n      -- It suffices to show that `Ï†â»Â¹ (Ï† U) = â‹ƒ (U * kâ»Â¹)` as `k` runs through the kernel of `Ï†`,\n      -- as `U * kâ»Â¹` is open because `x â†¦ x * k` is continuous.\n      -- Remark: here is where we use that we have groups not monoids (you cannot avoid\n      -- using both `k` and `kâ»Â¹` at this point).\n      suffices â‡‘Ï† â»Â¹' (â‡‘Ï† '' U) = â‹ƒ k âˆˆ ker (Ï† : A â†’* B), (fun x â†¦ x * k) â»Â¹' U by\n        exact this â–¸ isOpen_biUnion (fun k _ â†¦ Continuous.isOpen_preimage (by fun_prop) _ hU)\n      ext x\n      -- But this is an elementary calculation.\n      constructor\n      Â· rintro âŸ¨y, hyU, hyxâŸ©\n        apply Set.mem_iUnion_of_mem (xâ»Â¹ * y)\n        simp_all\n      Â· rintro âŸ¨_, âŸ¨k, rflâŸ©, _, âŸ¨(hk : Ï† k = 1), rflâŸ©, hxâŸ©\n        use x * k, hx\n        rw [map_mul, hk, mul_one]\n\n"}
{"name":"TopologicalAddGroup.ext","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type u_1\ninstâœ : AddGroup G\nt t' : TopologicalSpace G\ntg : TopologicalAddGroup G\ntg' : TopologicalAddGroup G\nh : Eq (nhds 0) (nhds 0)\nâŠ¢ Eq t t'","decl":"@[to_additive]\ntheorem TopologicalGroup.ext {G : Type*} [Group G] {t t' : TopologicalSpace G}\n    (tg : @TopologicalGroup G t _) (tg' : @TopologicalGroup G t' _)\n    (h : @nhds G t 1 = @nhds G t' 1) : t = t' :=\n  TopologicalSpace.ext_nhds fun x â†¦ by\n    rw [â† @nhds_translation_mul_inv G t _ _ x, â† @nhds_translation_mul_inv G t' _ _ x, â† h]\n\n"}
{"name":"TopologicalGroup.ext","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type u_1\ninstâœ : Group G\nt t' : TopologicalSpace G\ntg : TopologicalGroup G\ntg' : TopologicalGroup G\nh : Eq (nhds 1) (nhds 1)\nâŠ¢ Eq t t'","decl":"@[to_additive]\ntheorem TopologicalGroup.ext {G : Type*} [Group G] {t t' : TopologicalSpace G}\n    (tg : @TopologicalGroup G t _) (tg' : @TopologicalGroup G t' _)\n    (h : @nhds G t 1 = @nhds G t' 1) : t = t' :=\n  TopologicalSpace.ext_nhds fun x â†¦ by\n    rw [â† @nhds_translation_mul_inv G t _ _ x, â† @nhds_translation_mul_inv G t' _ _ x, â† h]\n\n"}
{"name":"TopologicalGroup.ext_iff","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type u_1\ninstâœ : Group G\nt t' : TopologicalSpace G\ntg : TopologicalGroup G\ntg' : TopologicalGroup G\nâŠ¢ Iff (Eq t t') (Eq (nhds 1) (nhds 1))","decl":"@[to_additive]\ntheorem TopologicalGroup.ext_iff {G : Type*} [Group G] {t t' : TopologicalSpace G}\n    (tg : @TopologicalGroup G t _) (tg' : @TopologicalGroup G t' _) :\n    t = t' â†” @nhds G t 1 = @nhds G t' 1 :=\n  âŸ¨fun h => h â–¸ rfl, tg.ext tg'âŸ©\n\n"}
{"name":"TopologicalAddGroup.ext_iff","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type u_1\ninstâœ : AddGroup G\nt t' : TopologicalSpace G\ntg : TopologicalAddGroup G\ntg' : TopologicalAddGroup G\nâŠ¢ Iff (Eq t t') (Eq (nhds 0) (nhds 0))","decl":"@[to_additive]\ntheorem TopologicalGroup.ext_iff {G : Type*} [Group G] {t t' : TopologicalSpace G}\n    (tg : @TopologicalGroup G t _) (tg' : @TopologicalGroup G t' _) :\n    t = t' â†” @nhds G t 1 = @nhds G t' 1 :=\n  âŸ¨fun h => h â–¸ rfl, tg.ext tg'âŸ©\n\n"}
{"name":"ContinuousInv.of_nhds_one","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type u_1\ninstâœÂ¹ : Group G\ninstâœ : TopologicalSpace G\nhinv : Filter.Tendsto (fun x => Inv.inv x) (nhds 1) (nhds 1)\nhleft : âˆ€ (xâ‚€ : G), Eq (nhds xâ‚€) (Filter.map (fun x => HMul.hMul xâ‚€ x) (nhds 1))\nhconj : âˆ€ (xâ‚€ : G), Filter.Tendsto (fun x => HMul.hMul (HMul.hMul xâ‚€ x) (Inv.inv xâ‚€)) (nhds 1) (nhds 1)\nâŠ¢ ContinuousInv G","decl":"@[to_additive]\ntheorem ContinuousInv.of_nhds_one {G : Type*} [Group G] [TopologicalSpace G]\n    (hinv : Tendsto (fun x : G => xâ»Â¹) (ð“ 1) (ð“ 1))\n    (hleft : âˆ€ xâ‚€ : G, ð“ xâ‚€ = map (fun x : G => xâ‚€ * x) (ð“ 1))\n    (hconj : âˆ€ xâ‚€ : G, Tendsto (fun x : G => xâ‚€ * x * xâ‚€â»Â¹) (ð“ 1) (ð“ 1)) : ContinuousInv G := by\n  refine âŸ¨continuous_iff_continuousAt.2 fun xâ‚€ => ?_âŸ©\n  have : Tendsto (fun x => xâ‚€â»Â¹ * (xâ‚€ * xâ»Â¹ * xâ‚€â»Â¹)) (ð“ 1) (map (xâ‚€â»Â¹ * Â·) (ð“ 1)) :=\n    (tendsto_map.comp <| hconj xâ‚€).comp hinv\n  simpa only [ContinuousAt, hleft xâ‚€, hleft xâ‚€â»Â¹, tendsto_map'_iff, Function.comp_def, mul_assoc,\n    mul_inv_rev, inv_mul_cancel_left] using this\n\n"}
{"name":"ContinuousNeg.of_nhds_zero","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type u_1\ninstâœÂ¹ : AddGroup G\ninstâœ : TopologicalSpace G\nhinv : Filter.Tendsto (fun x => Neg.neg x) (nhds 0) (nhds 0)\nhleft : âˆ€ (xâ‚€ : G), Eq (nhds xâ‚€) (Filter.map (fun x => HAdd.hAdd xâ‚€ x) (nhds 0))\nhconj : âˆ€ (xâ‚€ : G), Filter.Tendsto (fun x => HAdd.hAdd (HAdd.hAdd xâ‚€ x) (Neg.neg xâ‚€)) (nhds 0) (nhds 0)\nâŠ¢ ContinuousNeg G","decl":"@[to_additive]\ntheorem ContinuousInv.of_nhds_one {G : Type*} [Group G] [TopologicalSpace G]\n    (hinv : Tendsto (fun x : G => xâ»Â¹) (ð“ 1) (ð“ 1))\n    (hleft : âˆ€ xâ‚€ : G, ð“ xâ‚€ = map (fun x : G => xâ‚€ * x) (ð“ 1))\n    (hconj : âˆ€ xâ‚€ : G, Tendsto (fun x : G => xâ‚€ * x * xâ‚€â»Â¹) (ð“ 1) (ð“ 1)) : ContinuousInv G := by\n  refine âŸ¨continuous_iff_continuousAt.2 fun xâ‚€ => ?_âŸ©\n  have : Tendsto (fun x => xâ‚€â»Â¹ * (xâ‚€ * xâ»Â¹ * xâ‚€â»Â¹)) (ð“ 1) (map (xâ‚€â»Â¹ * Â·) (ð“ 1)) :=\n    (tendsto_map.comp <| hconj xâ‚€).comp hinv\n  simpa only [ContinuousAt, hleft xâ‚€, hleft xâ‚€â»Â¹, tendsto_map'_iff, Function.comp_def, mul_assoc,\n    mul_inv_rev, inv_mul_cancel_left] using this\n\n"}
{"name":"TopologicalGroup.of_nhds_one'","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type u\ninstâœÂ¹ : Group G\ninstâœ : TopologicalSpace G\nhmul : Filter.Tendsto (Function.uncurry fun x1 x2 => HMul.hMul x1 x2) (SProd.sprod (nhds 1) (nhds 1)) (nhds 1)\nhinv : Filter.Tendsto (fun x => Inv.inv x) (nhds 1) (nhds 1)\nhleft : âˆ€ (xâ‚€ : G), Eq (nhds xâ‚€) (Filter.map (fun x => HMul.hMul xâ‚€ x) (nhds 1))\nhright : âˆ€ (xâ‚€ : G), Eq (nhds xâ‚€) (Filter.map (fun x => HMul.hMul x xâ‚€) (nhds 1))\nâŠ¢ TopologicalGroup G","decl":"@[to_additive]\ntheorem TopologicalGroup.of_nhds_one' {G : Type u} [Group G] [TopologicalSpace G]\n    (hmul : Tendsto (uncurry ((Â· * Â·) : G â†’ G â†’ G)) (ð“ 1 Ã—Ë¢ ð“ 1) (ð“ 1))\n    (hinv : Tendsto (fun x : G => xâ»Â¹) (ð“ 1) (ð“ 1))\n    (hleft : âˆ€ xâ‚€ : G, ð“ xâ‚€ = map (fun x => xâ‚€ * x) (ð“ 1))\n    (hright : âˆ€ xâ‚€ : G, ð“ xâ‚€ = map (fun x => x * xâ‚€) (ð“ 1)) : TopologicalGroup G :=\n  { toContinuousMul := ContinuousMul.of_nhds_one hmul hleft hright\n    toContinuousInv :=\n      ContinuousInv.of_nhds_one hinv hleft fun xâ‚€ =>\n        le_of_eq\n          (by\n            rw [show (fun x => xâ‚€ * x * xâ‚€â»Â¹) = (fun x => x * xâ‚€â»Â¹) âˆ˜ fun x => xâ‚€ * x from rfl, â†\n              map_map, â† hleft, hright, map_map]\n            simp [(Â· âˆ˜ Â·)]) }\n\n"}
{"name":"TopologicalAddGroup.of_nhds_zero'","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type u\ninstâœÂ¹ : AddGroup G\ninstâœ : TopologicalSpace G\nhmul : Filter.Tendsto (Function.uncurry fun x1 x2 => HAdd.hAdd x1 x2) (SProd.sprod (nhds 0) (nhds 0)) (nhds 0)\nhinv : Filter.Tendsto (fun x => Neg.neg x) (nhds 0) (nhds 0)\nhleft : âˆ€ (xâ‚€ : G), Eq (nhds xâ‚€) (Filter.map (fun x => HAdd.hAdd xâ‚€ x) (nhds 0))\nhright : âˆ€ (xâ‚€ : G), Eq (nhds xâ‚€) (Filter.map (fun x => HAdd.hAdd x xâ‚€) (nhds 0))\nâŠ¢ TopologicalAddGroup G","decl":"@[to_additive]\ntheorem TopologicalGroup.of_nhds_one' {G : Type u} [Group G] [TopologicalSpace G]\n    (hmul : Tendsto (uncurry ((Â· * Â·) : G â†’ G â†’ G)) (ð“ 1 Ã—Ë¢ ð“ 1) (ð“ 1))\n    (hinv : Tendsto (fun x : G => xâ»Â¹) (ð“ 1) (ð“ 1))\n    (hleft : âˆ€ xâ‚€ : G, ð“ xâ‚€ = map (fun x => xâ‚€ * x) (ð“ 1))\n    (hright : âˆ€ xâ‚€ : G, ð“ xâ‚€ = map (fun x => x * xâ‚€) (ð“ 1)) : TopologicalGroup G :=\n  { toContinuousMul := ContinuousMul.of_nhds_one hmul hleft hright\n    toContinuousInv :=\n      ContinuousInv.of_nhds_one hinv hleft fun xâ‚€ =>\n        le_of_eq\n          (by\n            rw [show (fun x => xâ‚€ * x * xâ‚€â»Â¹) = (fun x => x * xâ‚€â»Â¹) âˆ˜ fun x => xâ‚€ * x from rfl, â†\n              map_map, â† hleft, hright, map_map]\n            simp [(Â· âˆ˜ Â·)]) }\n\n"}
{"name":"TopologicalAddGroup.of_nhds_zero","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type u\ninstâœÂ¹ : AddGroup G\ninstâœ : TopologicalSpace G\nhmul : Filter.Tendsto (Function.uncurry fun x1 x2 => HAdd.hAdd x1 x2) (SProd.sprod (nhds 0) (nhds 0)) (nhds 0)\nhinv : Filter.Tendsto (fun x => Neg.neg x) (nhds 0) (nhds 0)\nhleft : âˆ€ (xâ‚€ : G), Eq (nhds xâ‚€) (Filter.map (fun x => HAdd.hAdd xâ‚€ x) (nhds 0))\nhconj : âˆ€ (xâ‚€ : G), Filter.Tendsto (fun x => HAdd.hAdd (HAdd.hAdd xâ‚€ x) (Neg.neg xâ‚€)) (nhds 0) (nhds 0)\nâŠ¢ TopologicalAddGroup G","decl":"@[to_additive]\ntheorem TopologicalGroup.of_nhds_one {G : Type u} [Group G] [TopologicalSpace G]\n    (hmul : Tendsto (uncurry ((Â· * Â·) : G â†’ G â†’ G)) (ð“ 1 Ã—Ë¢ ð“ 1) (ð“ 1))\n    (hinv : Tendsto (fun x : G => xâ»Â¹) (ð“ 1) (ð“ 1))\n    (hleft : âˆ€ xâ‚€ : G, ð“ xâ‚€ = map (xâ‚€ * Â·) (ð“ 1))\n    (hconj : âˆ€ xâ‚€ : G, Tendsto (xâ‚€ * Â· * xâ‚€â»Â¹) (ð“ 1) (ð“ 1)) : TopologicalGroup G := by\n  refine TopologicalGroup.of_nhds_one' hmul hinv hleft fun xâ‚€ => ?_\n  replace hconj : âˆ€ xâ‚€ : G, map (xâ‚€ * Â· * xâ‚€â»Â¹) (ð“ 1) = ð“ 1 :=\n    fun xâ‚€ => map_eq_of_inverse (xâ‚€â»Â¹ * Â· * xâ‚€â»Â¹â»Â¹) (by ext; simp [mul_assoc]) (hconj _) (hconj _)\n  rw [â† hconj xâ‚€]\n  simpa [Function.comp_def] using hleft _\n\n"}
{"name":"TopologicalGroup.of_nhds_one","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type u\ninstâœÂ¹ : Group G\ninstâœ : TopologicalSpace G\nhmul : Filter.Tendsto (Function.uncurry fun x1 x2 => HMul.hMul x1 x2) (SProd.sprod (nhds 1) (nhds 1)) (nhds 1)\nhinv : Filter.Tendsto (fun x => Inv.inv x) (nhds 1) (nhds 1)\nhleft : âˆ€ (xâ‚€ : G), Eq (nhds xâ‚€) (Filter.map (fun x => HMul.hMul xâ‚€ x) (nhds 1))\nhconj : âˆ€ (xâ‚€ : G), Filter.Tendsto (fun x => HMul.hMul (HMul.hMul xâ‚€ x) (Inv.inv xâ‚€)) (nhds 1) (nhds 1)\nâŠ¢ TopologicalGroup G","decl":"@[to_additive]\ntheorem TopologicalGroup.of_nhds_one {G : Type u} [Group G] [TopologicalSpace G]\n    (hmul : Tendsto (uncurry ((Â· * Â·) : G â†’ G â†’ G)) (ð“ 1 Ã—Ë¢ ð“ 1) (ð“ 1))\n    (hinv : Tendsto (fun x : G => xâ»Â¹) (ð“ 1) (ð“ 1))\n    (hleft : âˆ€ xâ‚€ : G, ð“ xâ‚€ = map (xâ‚€ * Â·) (ð“ 1))\n    (hconj : âˆ€ xâ‚€ : G, Tendsto (xâ‚€ * Â· * xâ‚€â»Â¹) (ð“ 1) (ð“ 1)) : TopologicalGroup G := by\n  refine TopologicalGroup.of_nhds_one' hmul hinv hleft fun xâ‚€ => ?_\n  replace hconj : âˆ€ xâ‚€ : G, map (xâ‚€ * Â· * xâ‚€â»Â¹) (ð“ 1) = ð“ 1 :=\n    fun xâ‚€ => map_eq_of_inverse (xâ‚€â»Â¹ * Â· * xâ‚€â»Â¹â»Â¹) (by ext; simp [mul_assoc]) (hconj _) (hconj _)\n  rw [â† hconj xâ‚€]\n  simpa [Function.comp_def] using hleft _\n\n"}
{"name":"TopologicalAddGroup.of_comm_of_nhds_zero","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type u\ninstâœÂ¹ : AddCommGroup G\ninstâœ : TopologicalSpace G\nhmul : Filter.Tendsto (Function.uncurry fun x1 x2 => HAdd.hAdd x1 x2) (SProd.sprod (nhds 0) (nhds 0)) (nhds 0)\nhinv : Filter.Tendsto (fun x => Neg.neg x) (nhds 0) (nhds 0)\nhleft : âˆ€ (xâ‚€ : G), Eq (nhds xâ‚€) (Filter.map (fun x => HAdd.hAdd xâ‚€ x) (nhds 0))\nâŠ¢ TopologicalAddGroup G","decl":"@[to_additive]\ntheorem TopologicalGroup.of_comm_of_nhds_one {G : Type u} [CommGroup G] [TopologicalSpace G]\n    (hmul : Tendsto (uncurry ((Â· * Â·) : G â†’ G â†’ G)) (ð“ 1 Ã—Ë¢ ð“ 1) (ð“ 1))\n    (hinv : Tendsto (fun x : G => xâ»Â¹) (ð“ 1) (ð“ 1))\n    (hleft : âˆ€ xâ‚€ : G, ð“ xâ‚€ = map (xâ‚€ * Â·) (ð“ 1)) : TopologicalGroup G :=\n  TopologicalGroup.of_nhds_one hmul hinv hleft (by simpa using tendsto_id)\n\n"}
{"name":"TopologicalGroup.of_comm_of_nhds_one","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type u\ninstâœÂ¹ : CommGroup G\ninstâœ : TopologicalSpace G\nhmul : Filter.Tendsto (Function.uncurry fun x1 x2 => HMul.hMul x1 x2) (SProd.sprod (nhds 1) (nhds 1)) (nhds 1)\nhinv : Filter.Tendsto (fun x => Inv.inv x) (nhds 1) (nhds 1)\nhleft : âˆ€ (xâ‚€ : G), Eq (nhds xâ‚€) (Filter.map (fun x => HMul.hMul xâ‚€ x) (nhds 1))\nâŠ¢ TopologicalGroup G","decl":"@[to_additive]\ntheorem TopologicalGroup.of_comm_of_nhds_one {G : Type u} [CommGroup G] [TopologicalSpace G]\n    (hmul : Tendsto (uncurry ((Â· * Â·) : G â†’ G â†’ G)) (ð“ 1 Ã—Ë¢ ð“ 1) (ð“ 1))\n    (hinv : Tendsto (fun x : G => xâ»Â¹) (ð“ 1) (ð“ 1))\n    (hleft : âˆ€ xâ‚€ : G, ð“ xâ‚€ = map (xâ‚€ * Â·) (ð“ 1)) : TopologicalGroup G :=\n  TopologicalGroup.of_nhds_one hmul hinv hleft (by simpa using tendsto_id)\n\n"}
{"name":"TopologicalGroup.exists_antitone_basis_nhds_one","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ³ : TopologicalSpace G\ninstâœÂ² : Group G\ninstâœÂ¹ : TopologicalGroup G\ninstâœ : FirstCountableTopology G\nâŠ¢ Exists fun u => And ((nhds 1).HasAntitoneBasis u) (âˆ€ (n : Nat), HasSubset.Subset (HMul.hMul (u (HAdd.hAdd n 1)) (u (HAdd.hAdd n 1))) (u n))","decl":"variable (G) in\n/-- Any first countable topological group has an antitone neighborhood basis `u : â„• â†’ Set G` for\nwhich `(u (n + 1)) ^ 2 âŠ† u n`. The existence of such a neighborhood basis is a key tool for\n`QuotientGroup.completeSpace` -/\n@[to_additive\n  \"Any first countable topological additive group has an antitone neighborhood basis\n  `u : â„• â†’ set G` for which `u (n + 1) + u (n + 1) âŠ† u n`.\n  The existence of such a neighborhood basis is a key tool for `QuotientAddGroup.completeSpace`\"]\ntheorem TopologicalGroup.exists_antitone_basis_nhds_one [FirstCountableTopology G] :\n    âˆƒ u : â„• â†’ Set G, (ð“ 1).HasAntitoneBasis u âˆ§ âˆ€ n, u (n + 1) * u (n + 1) âŠ† u n := by\n  rcases (ð“ (1 : G)).exists_antitone_basis with âŸ¨u, hu, u_antiâŸ©\n  have :=\n    ((hu.prod_nhds hu).tendsto_iff hu).mp\n      (by simpa only [mul_one] using continuous_mul.tendsto ((1, 1) : G Ã— G))\n  simp only [and_self_iff, mem_prod, and_imp, Prod.forall, exists_true_left, Prod.exists,\n    forall_true_left] at this\n  have event_mul : âˆ€ n : â„•, âˆ€á¶  m in atTop, u m * u m âŠ† u n := by\n    intro n\n    rcases this n with âŸ¨j, k, -, hâŸ©\n    refine atTop_basis.eventually_iff.mpr âŸ¨max j k, True.intro, fun m hm => ?_âŸ©\n    rintro - âŸ¨a, ha, b, hb, rflâŸ©\n    exact h a b (u_anti ((le_max_left _ _).trans hm) ha) (u_anti ((le_max_right _ _).trans hm) hb)\n  obtain âŸ¨Ï†, -, hÏ†, Ï†_anti_basisâŸ© := HasAntitoneBasis.subbasis_with_rel âŸ¨hu, u_antiâŸ© event_mul\n  exact âŸ¨u âˆ˜ Ï†, Ï†_anti_basis, fun n => hÏ† n.lt_succ_selfâŸ©\n\n"}
{"name":"TopologicalAddGroup.exists_antitone_basis_nhds_zero","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ³ : TopologicalSpace G\ninstâœÂ² : AddGroup G\ninstâœÂ¹ : TopologicalAddGroup G\ninstâœ : FirstCountableTopology G\nâŠ¢ Exists fun u => And ((nhds 0).HasAntitoneBasis u) (âˆ€ (n : Nat), HasSubset.Subset (HAdd.hAdd (u (HAdd.hAdd n 1)) (u (HAdd.hAdd n 1))) (u n))","decl":"variable (G) in\n/-- Any first countable topological group has an antitone neighborhood basis `u : â„• â†’ Set G` for\nwhich `(u (n + 1)) ^ 2 âŠ† u n`. The existence of such a neighborhood basis is a key tool for\n`QuotientGroup.completeSpace` -/\n@[to_additive\n  \"Any first countable topological additive group has an antitone neighborhood basis\n  `u : â„• â†’ set G` for which `u (n + 1) + u (n + 1) âŠ† u n`.\n  The existence of such a neighborhood basis is a key tool for `QuotientAddGroup.completeSpace`\"]\ntheorem TopologicalGroup.exists_antitone_basis_nhds_one [FirstCountableTopology G] :\n    âˆƒ u : â„• â†’ Set G, (ð“ 1).HasAntitoneBasis u âˆ§ âˆ€ n, u (n + 1) * u (n + 1) âŠ† u n := by\n  rcases (ð“ (1 : G)).exists_antitone_basis with âŸ¨u, hu, u_antiâŸ©\n  have :=\n    ((hu.prod_nhds hu).tendsto_iff hu).mp\n      (by simpa only [mul_one] using continuous_mul.tendsto ((1, 1) : G Ã— G))\n  simp only [and_self_iff, mem_prod, and_imp, Prod.forall, exists_true_left, Prod.exists,\n    forall_true_left] at this\n  have event_mul : âˆ€ n : â„•, âˆ€á¶  m in atTop, u m * u m âŠ† u n := by\n    intro n\n    rcases this n with âŸ¨j, k, -, hâŸ©\n    refine atTop_basis.eventually_iff.mpr âŸ¨max j k, True.intro, fun m hm => ?_âŸ©\n    rintro - âŸ¨a, ha, b, hb, rflâŸ©\n    exact h a b (u_anti ((le_max_left _ _).trans hm) ha) (u_anti ((le_max_right _ _).trans hm) hb)\n  obtain âŸ¨Ï†, -, hÏ†, Ï†_anti_basisâŸ© := HasAntitoneBasis.subbasis_with_rel âŸ¨hu, u_antiâŸ© event_mul\n  exact âŸ¨u âˆ˜ Ï†, Ï†_anti_basis, fun n => hÏ† n.lt_succ_selfâŸ©\n\n"}
{"name":"ContinuousSub.continuous_sub","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type u_1\ninstâœÂ¹ : TopologicalSpace G\ninstâœ : Sub G\nself : ContinuousSub G\nâŠ¢ Continuous fun p => HSub.hSub p.1 p.2","decl":"/-- A typeclass saying that `p : G Ã— G â†¦ p.1 - p.2` is a continuous function. This property\nautomatically holds for topological additive groups but it also holds, e.g., for `â„â‰¥0`. -/\nclass ContinuousSub (G : Type*) [TopologicalSpace G] [Sub G] : Prop where\n  continuous_sub : Continuous fun p : G Ã— G => p.1 - p.2\n\n"}
{"name":"ContinuousDiv.continuous_div'","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type u_1\ninstâœÂ¹ : TopologicalSpace G\ninstâœ : Div G\nself : ContinuousDiv G\nâŠ¢ Continuous fun p => HDiv.hDiv p.1 p.2","decl":"/-- A typeclass saying that `p : G Ã— G â†¦ p.1 / p.2` is a continuous function. This property\nautomatically holds for topological groups. Lemmas using this class have primes.\nThe unprimed version is for `GroupWithZero`. -/\n@[to_additive existing]\nclass ContinuousDiv (G : Type*) [TopologicalSpace G] [Div G] : Prop where\n  continuous_div' : Continuous fun p : G Ã— G => p.1 / p.2\n\n-- see Note [lower instance priority]\n"}
{"name":"TopologicalGroup.to_continuousDiv","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : TopologicalGroup G\nâŠ¢ ContinuousDiv G","decl":"@[to_additive]\ninstance (priority := 100) TopologicalGroup.to_continuousDiv [TopologicalSpace G] [Group G]\n    [TopologicalGroup G] : ContinuousDiv G :=\n  âŸ¨by\n    simp only [div_eq_mul_inv]\n    exact continuous_fst.mul continuous_snd.invâŸ©\n\n"}
{"name":"TopologicalAddGroup.to_continuousSub","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : TopologicalAddGroup G\nâŠ¢ ContinuousSub G","decl":"@[to_additive]\ninstance (priority := 100) TopologicalGroup.to_continuousDiv [TopologicalSpace G] [Group G]\n    [TopologicalGroup G] : ContinuousDiv G :=\n  âŸ¨by\n    simp only [div_eq_mul_inv]\n    exact continuous_fst.mul continuous_snd.invâŸ©\n\n"}
{"name":"Filter.Tendsto.sub","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\nÎ± : Type u\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Sub G\ninstâœ : ContinuousSub G\nf g : Î± â†’ G\nl : Filter Î±\na b : G\nhf : Filter.Tendsto f l (nhds a)\nhg : Filter.Tendsto g l (nhds b)\nâŠ¢ Filter.Tendsto (fun x => HSub.hSub (f x) (g x)) l (nhds (HSub.hSub a b))","decl":"@[to_additive sub]\ntheorem Filter.Tendsto.div' {f g : Î± â†’ G} {l : Filter Î±} {a b : G} (hf : Tendsto f l (ð“ a))\n    (hg : Tendsto g l (ð“ b)) : Tendsto (fun x => f x / g x) l (ð“ (a / b)) :=\n  (continuous_div'.tendsto (a, b)).comp (hf.prod_mk_nhds hg)\n\n"}
{"name":"Filter.Tendsto.div'","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\nÎ± : Type u\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Div G\ninstâœ : ContinuousDiv G\nf g : Î± â†’ G\nl : Filter Î±\na b : G\nhf : Filter.Tendsto f l (nhds a)\nhg : Filter.Tendsto g l (nhds b)\nâŠ¢ Filter.Tendsto (fun x => HDiv.hDiv (f x) (g x)) l (nhds (HDiv.hDiv a b))","decl":"@[to_additive sub]\ntheorem Filter.Tendsto.div' {f g : Î± â†’ G} {l : Filter Î±} {a b : G} (hf : Tendsto f l (ð“ a))\n    (hg : Tendsto g l (ð“ b)) : Tendsto (fun x => f x / g x) l (ð“ (a / b)) :=\n  (continuous_div'.tendsto (a, b)).comp (hf.prod_mk_nhds hg)\n\n"}
{"name":"Filter.Tendsto.const_sub","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\nÎ± : Type u\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Sub G\ninstâœ : ContinuousSub G\nb c : G\nf : Î± â†’ G\nl : Filter Î±\nh : Filter.Tendsto f l (nhds c)\nâŠ¢ Filter.Tendsto (fun k => HSub.hSub b (f k)) l (nhds (HSub.hSub b c))","decl":"@[to_additive const_sub]\ntheorem Filter.Tendsto.const_div' (b : G) {c : G} {f : Î± â†’ G} {l : Filter Î±}\n    (h : Tendsto f l (ð“ c)) : Tendsto (fun k : Î± => b / f k) l (ð“ (b / c)) :=\n  tendsto_const_nhds.div' h\n\n"}
{"name":"Filter.Tendsto.const_div'","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\nÎ± : Type u\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Div G\ninstâœ : ContinuousDiv G\nb c : G\nf : Î± â†’ G\nl : Filter Î±\nh : Filter.Tendsto f l (nhds c)\nâŠ¢ Filter.Tendsto (fun k => HDiv.hDiv b (f k)) l (nhds (HDiv.hDiv b c))","decl":"@[to_additive const_sub]\ntheorem Filter.Tendsto.const_div' (b : G) {c : G} {f : Î± â†’ G} {l : Filter Î±}\n    (h : Tendsto f l (ð“ c)) : Tendsto (fun k : Î± => b / f k) l (ð“ (b / c)) :=\n  tendsto_const_nhds.div' h\n\n"}
{"name":"Filter.tendsto_const_div_iff","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\nG : Type u_1\ninstâœÂ² : CommGroup G\ninstâœÂ¹ : TopologicalSpace G\ninstâœ : ContinuousDiv G\nb c : G\nf : Î± â†’ G\nl : Filter Î±\nâŠ¢ Iff (Filter.Tendsto (fun k => HDiv.hDiv b (f k)) l (nhds (HDiv.hDiv b c))) (Filter.Tendsto f l (nhds c))","decl":"@[to_additive]\nlemma Filter.tendsto_const_div_iff {G : Type*} [CommGroup G] [TopologicalSpace G] [ContinuousDiv G]\n    (b : G) {c : G} {f : Î± â†’ G} {l : Filter Î±} :\n    Tendsto (fun k : Î± â†¦ b / f k) l (ð“ (b / c)) â†” Tendsto f l (ð“ c) := by\n  refine âŸ¨fun h â†¦ ?_, Filter.Tendsto.const_div' bâŸ©\n  convert h.const_div' b with k <;> rw [div_div_cancel]\n\n"}
{"name":"Filter.tendsto_const_sub_iff","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\nG : Type u_1\ninstâœÂ² : AddCommGroup G\ninstâœÂ¹ : TopologicalSpace G\ninstâœ : ContinuousSub G\nb c : G\nf : Î± â†’ G\nl : Filter Î±\nâŠ¢ Iff (Filter.Tendsto (fun k => HSub.hSub b (f k)) l (nhds (HSub.hSub b c))) (Filter.Tendsto f l (nhds c))","decl":"@[to_additive]\nlemma Filter.tendsto_const_div_iff {G : Type*} [CommGroup G] [TopologicalSpace G] [ContinuousDiv G]\n    (b : G) {c : G} {f : Î± â†’ G} {l : Filter Î±} :\n    Tendsto (fun k : Î± â†¦ b / f k) l (ð“ (b / c)) â†” Tendsto f l (ð“ c) := by\n  refine âŸ¨fun h â†¦ ?_, Filter.Tendsto.const_div' bâŸ©\n  convert h.const_div' b with k <;> rw [div_div_cancel]\n\n"}
{"name":"Filter.Tendsto.sub_const","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\nÎ± : Type u\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Sub G\ninstâœ : ContinuousSub G\nc : G\nf : Î± â†’ G\nl : Filter Î±\nh : Filter.Tendsto f l (nhds c)\nb : G\nâŠ¢ Filter.Tendsto (fun x => HSub.hSub (f x) b) l (nhds (HSub.hSub c b))","decl":"@[to_additive sub_const]\ntheorem Filter.Tendsto.div_const' {c : G} {f : Î± â†’ G} {l : Filter Î±} (h : Tendsto f l (ð“ c))\n    (b : G) : Tendsto (f Â· / b) l (ð“ (c / b)) :=\n  h.div' tendsto_const_nhds\n\n"}
{"name":"Filter.Tendsto.div_const'","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\nÎ± : Type u\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Div G\ninstâœ : ContinuousDiv G\nc : G\nf : Î± â†’ G\nl : Filter Î±\nh : Filter.Tendsto f l (nhds c)\nb : G\nâŠ¢ Filter.Tendsto (fun x => HDiv.hDiv (f x) b) l (nhds (HDiv.hDiv c b))","decl":"@[to_additive sub_const]\ntheorem Filter.Tendsto.div_const' {c : G} {f : Î± â†’ G} {l : Filter Î±} (h : Tendsto f l (ð“ c))\n    (b : G) : Tendsto (f Â· / b) l (ð“ (c / b)) :=\n  h.div' tendsto_const_nhds\n\n"}
{"name":"Filter.tendsto_div_const_iff","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\nG : Type u_1\ninstâœÂ² : CommGroupWithZero G\ninstâœÂ¹ : TopologicalSpace G\ninstâœ : ContinuousDiv G\nb : G\nhb : Ne b 0\nc : G\nf : Î± â†’ G\nl : Filter Î±\nâŠ¢ Iff (Filter.Tendsto (fun x => HDiv.hDiv (f x) b) l (nhds (HDiv.hDiv c b))) (Filter.Tendsto f l (nhds c))","decl":"lemma Filter.tendsto_div_const_iff {G : Type*}\n    [CommGroupWithZero G] [TopologicalSpace G] [ContinuousDiv G]\n    {b : G} (hb : b â‰  0) {c : G} {f : Î± â†’ G} {l : Filter Î±} :\n    Tendsto (f Â· / b) l (ð“ (c / b)) â†” Tendsto f l (ð“ c) := by\n  refine âŸ¨fun h â†¦ ?_, fun h â†¦ Filter.Tendsto.div_const' h bâŸ©\n  convert h.div_const' bâ»Â¹ with k <;> rw [div_div, mul_inv_cancelâ‚€ hb, div_one]\n\n"}
{"name":"Filter.tendsto_sub_const_iff","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\nG : Type u_1\ninstâœÂ² : AddCommGroup G\ninstâœÂ¹ : TopologicalSpace G\ninstâœ : ContinuousSub G\nb c : G\nf : Î± â†’ G\nl : Filter Î±\nâŠ¢ Iff (Filter.Tendsto (fun x => HSub.hSub (f x) b) l (nhds (HSub.hSub c b))) (Filter.Tendsto f l (nhds c))","decl":"lemma Filter.tendsto_sub_const_iff {G : Type*}\n    [AddCommGroup G] [TopologicalSpace G] [ContinuousSub G]\n    (b : G) {c : G} {f : Î± â†’ G} {l : Filter Î±} :\n    Tendsto (f Â· - b) l (ð“ (c - b)) â†” Tendsto f l (ð“ c) := by\n  refine âŸ¨fun h â†¦ ?_, fun h â†¦ Filter.Tendsto.sub_const h bâŸ©\n  convert h.sub_const (-b) with k <;> rw [sub_sub, â† sub_eq_add_neg, sub_self, sub_zero]\n\n"}
{"name":"Continuous.div'","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\nÎ± : Type u\ninstâœÂ³ : TopologicalSpace G\ninstâœÂ² : Div G\ninstâœÂ¹ : ContinuousDiv G\ninstâœ : TopologicalSpace Î±\nf g : Î± â†’ G\nhf : Continuous f\nhg : Continuous g\nâŠ¢ Continuous fun x => HDiv.hDiv (f x) (g x)","decl":"@[to_additive (attr := continuity, fun_prop) sub]\ntheorem Continuous.div' (hf : Continuous f) (hg : Continuous g) : Continuous fun x => f x / g x :=\n  continuous_div'.comp (hf.prod_mk hg :)\n\n"}
{"name":"Continuous.sub","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\nÎ± : Type u\ninstâœÂ³ : TopologicalSpace G\ninstâœÂ² : Sub G\ninstâœÂ¹ : ContinuousSub G\ninstâœ : TopologicalSpace Î±\nf g : Î± â†’ G\nhf : Continuous f\nhg : Continuous g\nâŠ¢ Continuous fun x => HSub.hSub (f x) (g x)","decl":"@[to_additive (attr := continuity, fun_prop) sub]\ntheorem Continuous.div' (hf : Continuous f) (hg : Continuous g) : Continuous fun x => f x / g x :=\n  continuous_div'.comp (hf.prod_mk hg :)\n\n"}
{"name":"continuous_div_left'","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Div G\ninstâœ : ContinuousDiv G\na : G\nâŠ¢ Continuous fun x => HDiv.hDiv a x","decl":"@[to_additive (attr := continuity) continuous_sub_left]\nlemma continuous_div_left' (a : G) : Continuous (a / Â·) := continuous_const.div' continuous_id\n\n"}
{"name":"continuous_sub_left","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Sub G\ninstâœ : ContinuousSub G\na : G\nâŠ¢ Continuous fun x => HSub.hSub a x","decl":"@[to_additive (attr := continuity) continuous_sub_left]\nlemma continuous_div_left' (a : G) : Continuous (a / Â·) := continuous_const.div' continuous_id\n\n"}
{"name":"continuous_div_right'","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Div G\ninstâœ : ContinuousDiv G\na : G\nâŠ¢ Continuous fun x => HDiv.hDiv x a","decl":"@[to_additive (attr := continuity) continuous_sub_right]\nlemma continuous_div_right' (a : G) : Continuous (Â· / a) := continuous_id.div' continuous_const\n\n"}
{"name":"continuous_sub_right","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Sub G\ninstâœ : ContinuousSub G\na : G\nâŠ¢ Continuous fun x => HSub.hSub x a","decl":"@[to_additive (attr := continuity) continuous_sub_right]\nlemma continuous_div_right' (a : G) : Continuous (Â· / a) := continuous_id.div' continuous_const\n\n"}
{"name":"ContinuousAt.sub","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\nÎ± : Type u\ninstâœÂ³ : TopologicalSpace G\ninstâœÂ² : Sub G\ninstâœÂ¹ : ContinuousSub G\ninstâœ : TopologicalSpace Î±\nf g : Î± â†’ G\nx : Î±\nhf : ContinuousAt f x\nhg : ContinuousAt g x\nâŠ¢ ContinuousAt (fun x => HSub.hSub (f x) (g x)) x","decl":"@[to_additive (attr := fun_prop) sub]\ntheorem ContinuousAt.div' {f g : Î± â†’ G} {x : Î±} (hf : ContinuousAt f x) (hg : ContinuousAt g x) :\n    ContinuousAt (fun x => f x / g x) x :=\n  Filter.Tendsto.div' hf hg\n\n"}
{"name":"ContinuousAt.div'","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\nÎ± : Type u\ninstâœÂ³ : TopologicalSpace G\ninstâœÂ² : Div G\ninstâœÂ¹ : ContinuousDiv G\ninstâœ : TopologicalSpace Î±\nf g : Î± â†’ G\nx : Î±\nhf : ContinuousAt f x\nhg : ContinuousAt g x\nâŠ¢ ContinuousAt (fun x => HDiv.hDiv (f x) (g x)) x","decl":"@[to_additive (attr := fun_prop) sub]\ntheorem ContinuousAt.div' {f g : Î± â†’ G} {x : Î±} (hf : ContinuousAt f x) (hg : ContinuousAt g x) :\n    ContinuousAt (fun x => f x / g x) x :=\n  Filter.Tendsto.div' hf hg\n\n"}
{"name":"ContinuousWithinAt.div'","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\nÎ± : Type u\ninstâœÂ³ : TopologicalSpace G\ninstâœÂ² : Div G\ninstâœÂ¹ : ContinuousDiv G\ninstâœ : TopologicalSpace Î±\nf g : Î± â†’ G\ns : Set Î±\nx : Î±\nhf : ContinuousWithinAt f s x\nhg : ContinuousWithinAt g s x\nâŠ¢ ContinuousWithinAt (fun x => HDiv.hDiv (f x) (g x)) s x","decl":"@[to_additive sub]\ntheorem ContinuousWithinAt.div' (hf : ContinuousWithinAt f s x) (hg : ContinuousWithinAt g s x) :\n    ContinuousWithinAt (fun x => f x / g x) s x :=\n  Filter.Tendsto.div' hf hg\n\n"}
{"name":"ContinuousWithinAt.sub","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\nÎ± : Type u\ninstâœÂ³ : TopologicalSpace G\ninstâœÂ² : Sub G\ninstâœÂ¹ : ContinuousSub G\ninstâœ : TopologicalSpace Î±\nf g : Î± â†’ G\ns : Set Î±\nx : Î±\nhf : ContinuousWithinAt f s x\nhg : ContinuousWithinAt g s x\nâŠ¢ ContinuousWithinAt (fun x => HSub.hSub (f x) (g x)) s x","decl":"@[to_additive sub]\ntheorem ContinuousWithinAt.div' (hf : ContinuousWithinAt f s x) (hg : ContinuousWithinAt g s x) :\n    ContinuousWithinAt (fun x => f x / g x) s x :=\n  Filter.Tendsto.div' hf hg\n\n"}
{"name":"ContinuousOn.div'","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\nÎ± : Type u\ninstâœÂ³ : TopologicalSpace G\ninstâœÂ² : Div G\ninstâœÂ¹ : ContinuousDiv G\ninstâœ : TopologicalSpace Î±\nf g : Î± â†’ G\ns : Set Î±\nhf : ContinuousOn f s\nhg : ContinuousOn g s\nâŠ¢ ContinuousOn (fun x => HDiv.hDiv (f x) (g x)) s","decl":"@[to_additive (attr := fun_prop) sub]\ntheorem ContinuousOn.div' (hf : ContinuousOn f s) (hg : ContinuousOn g s) :\n    ContinuousOn (fun x => f x / g x) s := fun x hx => (hf x hx).div' (hg x hx)\n\n"}
{"name":"ContinuousOn.sub","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\nÎ± : Type u\ninstâœÂ³ : TopologicalSpace G\ninstâœÂ² : Sub G\ninstâœÂ¹ : ContinuousSub G\ninstâœ : TopologicalSpace Î±\nf g : Î± â†’ G\ns : Set Î±\nhf : ContinuousOn f s\nhg : ContinuousOn g s\nâŠ¢ ContinuousOn (fun x => HSub.hSub (f x) (g x)) s","decl":"@[to_additive (attr := fun_prop) sub]\ntheorem ContinuousOn.div' (hf : ContinuousOn f s) (hg : ContinuousOn g s) :\n    ContinuousOn (fun x => f x / g x) s := fun x hx => (hf x hx).div' (hg x hx)\n\n"}
{"name":"Homeomorph.divLeft_apply","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : Group G\ninstâœÂ¹ : TopologicalSpace G\ninstâœ : TopologicalGroup G\nx b : G\nâŠ¢ Eq ((Homeomorph.divLeft x) b) (HDiv.hDiv x b)","decl":"/-- A version of `Homeomorph.mulLeft a bâ»Â¹` that is defeq to `a / b`. -/\n@[to_additive (attr := simps! (config := { simpRhs := true }))\n  \" A version of `Homeomorph.addLeft a (-b)` that is defeq to `a - b`. \"]\ndef Homeomorph.divLeft (x : G) : G â‰ƒâ‚œ G :=\n  { Equiv.divLeft x with\n    continuous_toFun := continuous_const.div' continuous_id\n    continuous_invFun := continuous_inv.mul continuous_const }\n\n"}
{"name":"Homeomorph.subLeft_apply","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : AddGroup G\ninstâœÂ¹ : TopologicalSpace G\ninstâœ : TopologicalAddGroup G\nx b : G\nâŠ¢ Eq ((Homeomorph.subLeft x) b) (HSub.hSub x b)","decl":"/-- A version of `Homeomorph.mulLeft a bâ»Â¹` that is defeq to `a / b`. -/\n@[to_additive (attr := simps! (config := { simpRhs := true }))\n  \" A version of `Homeomorph.addLeft a (-b)` that is defeq to `a - b`. \"]\ndef Homeomorph.divLeft (x : G) : G â‰ƒâ‚œ G :=\n  { Equiv.divLeft x with\n    continuous_toFun := continuous_const.div' continuous_id\n    continuous_invFun := continuous_inv.mul continuous_const }\n\n"}
{"name":"Homeomorph.subLeft_symm_apply","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : AddGroup G\ninstâœÂ¹ : TopologicalSpace G\ninstâœ : TopologicalAddGroup G\nx b : G\nâŠ¢ Eq ((Homeomorph.subLeft x).symm b) (HAdd.hAdd (Neg.neg b) x)","decl":"/-- A version of `Homeomorph.mulLeft a bâ»Â¹` that is defeq to `a / b`. -/\n@[to_additive (attr := simps! (config := { simpRhs := true }))\n  \" A version of `Homeomorph.addLeft a (-b)` that is defeq to `a - b`. \"]\ndef Homeomorph.divLeft (x : G) : G â‰ƒâ‚œ G :=\n  { Equiv.divLeft x with\n    continuous_toFun := continuous_const.div' continuous_id\n    continuous_invFun := continuous_inv.mul continuous_const }\n\n"}
{"name":"Homeomorph.divLeft_symm_apply","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : Group G\ninstâœÂ¹ : TopologicalSpace G\ninstâœ : TopologicalGroup G\nx b : G\nâŠ¢ Eq ((Homeomorph.divLeft x).symm b) (HMul.hMul (Inv.inv b) x)","decl":"/-- A version of `Homeomorph.mulLeft a bâ»Â¹` that is defeq to `a / b`. -/\n@[to_additive (attr := simps! (config := { simpRhs := true }))\n  \" A version of `Homeomorph.addLeft a (-b)` that is defeq to `a - b`. \"]\ndef Homeomorph.divLeft (x : G) : G â‰ƒâ‚œ G :=\n  { Equiv.divLeft x with\n    continuous_toFun := continuous_const.div' continuous_id\n    continuous_invFun := continuous_inv.mul continuous_const }\n\n"}
{"name":"isOpenMap_sub_left","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : AddGroup G\ninstâœÂ¹ : TopologicalSpace G\ninstâœ : TopologicalAddGroup G\na : G\nâŠ¢ IsOpenMap fun x => HSub.hSub a x","decl":"@[to_additive]\ntheorem isOpenMap_div_left (a : G) : IsOpenMap (a / Â·) :=\n  (Homeomorph.divLeft _).isOpenMap\n\n"}
{"name":"isOpenMap_div_left","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : Group G\ninstâœÂ¹ : TopologicalSpace G\ninstâœ : TopologicalGroup G\na : G\nâŠ¢ IsOpenMap fun x => HDiv.hDiv a x","decl":"@[to_additive]\ntheorem isOpenMap_div_left (a : G) : IsOpenMap (a / Â·) :=\n  (Homeomorph.divLeft _).isOpenMap\n\n"}
{"name":"isClosedMap_sub_left","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : AddGroup G\ninstâœÂ¹ : TopologicalSpace G\ninstâœ : TopologicalAddGroup G\na : G\nâŠ¢ IsClosedMap fun x => HSub.hSub a x","decl":"@[to_additive]\ntheorem isClosedMap_div_left (a : G) : IsClosedMap (a / Â·) :=\n  (Homeomorph.divLeft _).isClosedMap\n\n"}
{"name":"isClosedMap_div_left","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : Group G\ninstâœÂ¹ : TopologicalSpace G\ninstâœ : TopologicalGroup G\na : G\nâŠ¢ IsClosedMap fun x => HDiv.hDiv a x","decl":"@[to_additive]\ntheorem isClosedMap_div_left (a : G) : IsClosedMap (a / Â·) :=\n  (Homeomorph.divLeft _).isClosedMap\n\n"}
{"name":"Homeomorph.divRight_symm_apply","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : Group G\ninstâœÂ¹ : TopologicalSpace G\ninstâœ : TopologicalGroup G\nx b : G\nâŠ¢ Eq ((Homeomorph.divRight x).symm b) (HMul.hMul b x)","decl":"/-- A version of `Homeomorph.mulRight aâ»Â¹ b` that is defeq to `b / a`. -/\n@[to_additive (attr := simps! (config := { simpRhs := true }))\n  \"A version of `Homeomorph.addRight (-a) b` that is defeq to `b - a`. \"]\ndef Homeomorph.divRight (x : G) : G â‰ƒâ‚œ G :=\n  { Equiv.divRight x with\n    continuous_toFun := continuous_id.div' continuous_const\n    continuous_invFun := continuous_id.mul continuous_const }\n\n"}
{"name":"Homeomorph.subRight_symm_apply","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : AddGroup G\ninstâœÂ¹ : TopologicalSpace G\ninstâœ : TopologicalAddGroup G\nx b : G\nâŠ¢ Eq ((Homeomorph.subRight x).symm b) (HAdd.hAdd b x)","decl":"/-- A version of `Homeomorph.mulRight aâ»Â¹ b` that is defeq to `b / a`. -/\n@[to_additive (attr := simps! (config := { simpRhs := true }))\n  \"A version of `Homeomorph.addRight (-a) b` that is defeq to `b - a`. \"]\ndef Homeomorph.divRight (x : G) : G â‰ƒâ‚œ G :=\n  { Equiv.divRight x with\n    continuous_toFun := continuous_id.div' continuous_const\n    continuous_invFun := continuous_id.mul continuous_const }\n\n"}
{"name":"Homeomorph.divRight_apply","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : Group G\ninstâœÂ¹ : TopologicalSpace G\ninstâœ : TopologicalGroup G\nx b : G\nâŠ¢ Eq ((Homeomorph.divRight x) b) (HDiv.hDiv b x)","decl":"/-- A version of `Homeomorph.mulRight aâ»Â¹ b` that is defeq to `b / a`. -/\n@[to_additive (attr := simps! (config := { simpRhs := true }))\n  \"A version of `Homeomorph.addRight (-a) b` that is defeq to `b - a`. \"]\ndef Homeomorph.divRight (x : G) : G â‰ƒâ‚œ G :=\n  { Equiv.divRight x with\n    continuous_toFun := continuous_id.div' continuous_const\n    continuous_invFun := continuous_id.mul continuous_const }\n\n"}
{"name":"Homeomorph.subRight_apply","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : AddGroup G\ninstâœÂ¹ : TopologicalSpace G\ninstâœ : TopologicalAddGroup G\nx b : G\nâŠ¢ Eq ((Homeomorph.subRight x) b) (HSub.hSub b x)","decl":"/-- A version of `Homeomorph.mulRight aâ»Â¹ b` that is defeq to `b / a`. -/\n@[to_additive (attr := simps! (config := { simpRhs := true }))\n  \"A version of `Homeomorph.addRight (-a) b` that is defeq to `b - a`. \"]\ndef Homeomorph.divRight (x : G) : G â‰ƒâ‚œ G :=\n  { Equiv.divRight x with\n    continuous_toFun := continuous_id.div' continuous_const\n    continuous_invFun := continuous_id.mul continuous_const }\n\n"}
{"name":"isOpenMap_div_right","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : Group G\ninstâœÂ¹ : TopologicalSpace G\ninstâœ : TopologicalGroup G\na : G\nâŠ¢ IsOpenMap fun x => HDiv.hDiv x a","decl":"@[to_additive]\nlemma isOpenMap_div_right (a : G) : IsOpenMap (Â· / a) := (Homeomorph.divRight a).isOpenMap\n\n"}
{"name":"isOpenMap_sub_right","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : AddGroup G\ninstâœÂ¹ : TopologicalSpace G\ninstâœ : TopologicalAddGroup G\na : G\nâŠ¢ IsOpenMap fun x => HSub.hSub x a","decl":"@[to_additive]\nlemma isOpenMap_div_right (a : G) : IsOpenMap (Â· / a) := (Homeomorph.divRight a).isOpenMap\n\n"}
{"name":"isClosedMap_div_right","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : Group G\ninstâœÂ¹ : TopologicalSpace G\ninstâœ : TopologicalGroup G\na : G\nâŠ¢ IsClosedMap fun x => HDiv.hDiv x a","decl":"@[to_additive]\nlemma isClosedMap_div_right (a : G) : IsClosedMap (Â· / a) := (Homeomorph.divRight a).isClosedMap\n\n"}
{"name":"isClosedMap_sub_right","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : AddGroup G\ninstâœÂ¹ : TopologicalSpace G\ninstâœ : TopologicalAddGroup G\na : G\nâŠ¢ IsClosedMap fun x => HSub.hSub x a","decl":"@[to_additive]\nlemma isClosedMap_div_right (a : G) : IsClosedMap (Â· / a) := (Homeomorph.divRight a).isClosedMap\n\n"}
{"name":"tendsto_sub_nhds_zero_iff","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : AddGroup G\ninstâœÂ¹ : TopologicalSpace G\ninstâœ : TopologicalAddGroup G\nÎ± : Type u_1\nl : Filter Î±\nx : G\nu : Î± â†’ G\nâŠ¢ Iff (Filter.Tendsto (fun x_1 => HSub.hSub (u x_1) x) l (nhds 0)) (Filter.Tendsto u l (nhds x))","decl":"@[to_additive]\ntheorem tendsto_div_nhds_one_iff {Î± : Type*} {l : Filter Î±} {x : G} {u : Î± â†’ G} :\n    Tendsto (u Â· / x) l (ð“ 1) â†” Tendsto u l (ð“ x) :=\n  haveI A : Tendsto (fun _ : Î± => x) l (ð“ x) := tendsto_const_nhds\n  âŸ¨fun h => by simpa using h.mul A, fun h => by simpa using h.div' AâŸ©\n\n"}
{"name":"tendsto_div_nhds_one_iff","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : Group G\ninstâœÂ¹ : TopologicalSpace G\ninstâœ : TopologicalGroup G\nÎ± : Type u_1\nl : Filter Î±\nx : G\nu : Î± â†’ G\nâŠ¢ Iff (Filter.Tendsto (fun x_1 => HDiv.hDiv (u x_1) x) l (nhds 1)) (Filter.Tendsto u l (nhds x))","decl":"@[to_additive]\ntheorem tendsto_div_nhds_one_iff {Î± : Type*} {l : Filter Î±} {x : G} {u : Î± â†’ G} :\n    Tendsto (u Â· / x) l (ð“ 1) â†” Tendsto u l (ð“ x) :=\n  haveI A : Tendsto (fun _ : Î± => x) l (ð“ x) := tendsto_const_nhds\n  âŸ¨fun h => by simpa using h.mul A, fun h => by simpa using h.div' AâŸ©\n\n"}
{"name":"nhds_translation_div","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : Group G\ninstâœÂ¹ : TopologicalSpace G\ninstâœ : TopologicalGroup G\nx : G\nâŠ¢ Eq (Filter.comap (fun x_1 => HDiv.hDiv x_1 x) (nhds 1)) (nhds x)","decl":"@[to_additive]\ntheorem nhds_translation_div (x : G) : comap (Â· / x) (ð“ 1) = ð“ x := by\n  simpa only [div_eq_mul_inv] using nhds_translation_mul_inv x\n\n"}
{"name":"nhds_translation_sub","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : AddGroup G\ninstâœÂ¹ : TopologicalSpace G\ninstâœ : TopologicalAddGroup G\nx : G\nâŠ¢ Eq (Filter.comap (fun x_1 => HSub.hSub x_1 x) (nhds 0)) (nhds x)","decl":"@[to_additive]\ntheorem nhds_translation_div (x : G) : comap (Â· / x) (ð“ 1) = ð“ x := by\n  simpa only [div_eq_mul_inv] using nhds_translation_mul_inv x\n\n"}
{"name":"subset_interior_smul","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœâ´ : TopologicalSpace Î²\ninstâœÂ³ : Group Î±\ninstâœÂ² : MulAction Î± Î²\ninstâœÂ¹ : ContinuousConstSMul Î± Î²\ns : Set Î±\nt : Set Î²\ninstâœ : TopologicalSpace Î±\nâŠ¢ HasSubset.Subset (HSMul.hSMul (interior s) (interior t)) (interior (HSMul.hSMul s t))","decl":"@[to_additive]\ntheorem subset_interior_smul : interior s â€¢ interior t âŠ† interior (s â€¢ t) :=\n  (Set.smul_subset_smul_right interior_subset).trans subset_interior_smul_right\n\n"}
{"name":"subset_interior_vadd","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœâ´ : TopologicalSpace Î²\ninstâœÂ³ : AddGroup Î±\ninstâœÂ² : AddAction Î± Î²\ninstâœÂ¹ : ContinuousConstVAdd Î± Î²\ns : Set Î±\nt : Set Î²\ninstâœ : TopologicalSpace Î±\nâŠ¢ HasSubset.Subset (HVAdd.hVAdd (interior s) (interior t)) (interior (HVAdd.hVAdd s t))","decl":"@[to_additive]\ntheorem subset_interior_smul : interior s â€¢ interior t âŠ† interior (s â€¢ t) :=\n  (Set.smul_subset_smul_right interior_subset).trans subset_interior_smul_right\n\n"}
{"name":"IsClosed.vadd_left_of_isCompact","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœâµ : TopologicalSpace Î±\ninstâœâ´ : TopologicalSpace Î²\ninstâœÂ³ : AddGroup Î±\ninstâœÂ² : AddAction Î± Î²\ninstâœÂ¹ : ContinuousNeg Î±\ninstâœ : ContinuousVAdd Î± Î²\ns : Set Î±\nt : Set Î²\nht : IsClosed t\nhs : IsCompact s\nâŠ¢ IsClosed (HVAdd.hVAdd s t)","decl":"@[to_additive]\ntheorem IsClosed.smul_left_of_isCompact (ht : IsClosed t) (hs : IsCompact s) :\n    IsClosed (s â€¢ t) := by\n  have : âˆ€ x âˆˆ s â€¢ t, âˆƒ g âˆˆ s, gâ»Â¹ â€¢ x âˆˆ t := by\n    rintro x âŸ¨g, hgs, y, hyt, rflâŸ©\n    refine âŸ¨g, hgs, ?_âŸ©\n    rwa [inv_smul_smul]\n  choose! f hf using this\n  refine isClosed_of_closure_subset (fun x hx â†¦ ?_)\n  rcases mem_closure_iff_ultrafilter.mp hx with âŸ¨u, hust, huxâŸ©\n  have : Ultrafilter.map f u â‰¤ ð“Ÿ s :=\n    calc Ultrafilter.map f u â‰¤ map f (ð“Ÿ (s â€¢ t)) := map_mono (le_principal_iff.mpr hust)\n      _ = ð“Ÿ (f '' (s â€¢ t)) := map_principal\n      _ â‰¤ ð“Ÿ s := principal_mono.mpr (image_subset_iff.mpr (fun x hx â†¦ (hf x hx).1))\n  rcases hs.ultrafilter_le_nhds (Ultrafilter.map f u) this with âŸ¨g, hg, hugâŸ©\n  suffices gâ»Â¹ â€¢ x âˆˆ t from\n    âŸ¨g, hg, gâ»Â¹ â€¢ x, this, smul_inv_smul _ _âŸ©\n  exact ht.mem_of_tendsto ((Tendsto.inv hug).smul hux)\n    (Eventually.mono hust (fun y hy â†¦ (hf y hy).2))\n\n"}
{"name":"IsClosed.smul_left_of_isCompact","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœâµ : TopologicalSpace Î±\ninstâœâ´ : TopologicalSpace Î²\ninstâœÂ³ : Group Î±\ninstâœÂ² : MulAction Î± Î²\ninstâœÂ¹ : ContinuousInv Î±\ninstâœ : ContinuousSMul Î± Î²\ns : Set Î±\nt : Set Î²\nht : IsClosed t\nhs : IsCompact s\nâŠ¢ IsClosed (HSMul.hSMul s t)","decl":"@[to_additive]\ntheorem IsClosed.smul_left_of_isCompact (ht : IsClosed t) (hs : IsCompact s) :\n    IsClosed (s â€¢ t) := by\n  have : âˆ€ x âˆˆ s â€¢ t, âˆƒ g âˆˆ s, gâ»Â¹ â€¢ x âˆˆ t := by\n    rintro x âŸ¨g, hgs, y, hyt, rflâŸ©\n    refine âŸ¨g, hgs, ?_âŸ©\n    rwa [inv_smul_smul]\n  choose! f hf using this\n  refine isClosed_of_closure_subset (fun x hx â†¦ ?_)\n  rcases mem_closure_iff_ultrafilter.mp hx with âŸ¨u, hust, huxâŸ©\n  have : Ultrafilter.map f u â‰¤ ð“Ÿ s :=\n    calc Ultrafilter.map f u â‰¤ map f (ð“Ÿ (s â€¢ t)) := map_mono (le_principal_iff.mpr hust)\n      _ = ð“Ÿ (f '' (s â€¢ t)) := map_principal\n      _ â‰¤ ð“Ÿ s := principal_mono.mpr (image_subset_iff.mpr (fun x hx â†¦ (hf x hx).1))\n  rcases hs.ultrafilter_le_nhds (Ultrafilter.map f u) this with âŸ¨g, hg, hugâŸ©\n  suffices gâ»Â¹ â€¢ x âˆˆ t from\n    âŸ¨g, hg, gâ»Â¹ â€¢ x, this, smul_inv_smul _ _âŸ©\n  exact ht.mem_of_tendsto ((Tendsto.inv hug).smul hux)\n    (Eventually.mono hust (fun y hy â†¦ (hf y hy).2))\n\n"}
{"name":"AddAction.isClosedMap_quotient","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœâ¶ : TopologicalSpace Î±\ninstâœâµ : TopologicalSpace Î²\ninstâœâ´ : AddGroup Î±\ninstâœÂ³ : AddAction Î± Î²\ninstâœÂ² : ContinuousNeg Î±\ninstâœÂ¹ : ContinuousVAdd Î± Î²\ninstâœ : CompactSpace Î±\nâŠ¢ IsClosedMap Quotient.mk'","decl":"@[to_additive]\ntheorem MulAction.isClosedMap_quotient [CompactSpace Î±] :\n    letI := orbitRel Î± Î²\n    IsClosedMap (Quotient.mk' : Î² â†’ Quotient (orbitRel Î± Î²)) := by\n  intro t ht\n  rw [â† isQuotientMap_quotient_mk'.isClosed_preimage,\n    MulAction.quotient_preimage_image_eq_union_mul]\n  convert ht.smul_left_of_isCompact (isCompact_univ (X := Î±))\n  rw [â† biUnion_univ, â† iUnion_smul_left_image]\n  rfl\n\n"}
{"name":"MulAction.isClosedMap_quotient","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœâ¶ : TopologicalSpace Î±\ninstâœâµ : TopologicalSpace Î²\ninstâœâ´ : Group Î±\ninstâœÂ³ : MulAction Î± Î²\ninstâœÂ² : ContinuousInv Î±\ninstâœÂ¹ : ContinuousSMul Î± Î²\ninstâœ : CompactSpace Î±\nâŠ¢ IsClosedMap Quotient.mk'","decl":"@[to_additive]\ntheorem MulAction.isClosedMap_quotient [CompactSpace Î±] :\n    letI := orbitRel Î± Î²\n    IsClosedMap (Quotient.mk' : Î² â†’ Quotient (orbitRel Î± Î²)) := by\n  intro t ht\n  rw [â† isQuotientMap_quotient_mk'.isClosed_preimage,\n    MulAction.quotient_preimage_image_eq_union_mul]\n  convert ht.smul_left_of_isCompact (isCompact_univ (X := Î±))\n  rw [â† biUnion_univ, â† iUnion_smul_left_image]\n  rfl\n\n"}
{"name":"IsOpen.mul_left","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : Group Î±\ninstâœ : ContinuousConstSMul Î± Î±\ns t : Set Î±\naâœ : IsOpen t\nâŠ¢ IsOpen (HMul.hMul s t)","decl":"@[to_additive]\ntheorem IsOpen.mul_left : IsOpen t â†’ IsOpen (s * t) :=\n  IsOpen.smul_left\n\n"}
{"name":"IsOpen.add_left","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : AddGroup Î±\ninstâœ : ContinuousConstVAdd Î± Î±\ns t : Set Î±\naâœ : IsOpen t\nâŠ¢ IsOpen (HAdd.hAdd s t)","decl":"@[to_additive]\ntheorem IsOpen.mul_left : IsOpen t â†’ IsOpen (s * t) :=\n  IsOpen.smul_left\n\n"}
{"name":"subset_interior_add_right","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : AddGroup Î±\ninstâœ : ContinuousConstVAdd Î± Î±\ns t : Set Î±\nâŠ¢ HasSubset.Subset (HAdd.hAdd s (interior t)) (interior (HAdd.hAdd s t))","decl":"@[to_additive]\ntheorem subset_interior_mul_right : s * interior t âŠ† interior (s * t) :=\n  subset_interior_smul_right\n\n"}
{"name":"subset_interior_mul_right","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : Group Î±\ninstâœ : ContinuousConstSMul Î± Î±\ns t : Set Î±\nâŠ¢ HasSubset.Subset (HMul.hMul s (interior t)) (interior (HMul.hMul s t))","decl":"@[to_additive]\ntheorem subset_interior_mul_right : s * interior t âŠ† interior (s * t) :=\n  subset_interior_smul_right\n\n"}
{"name":"subset_interior_mul","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : Group Î±\ninstâœ : ContinuousConstSMul Î± Î±\ns t : Set Î±\nâŠ¢ HasSubset.Subset (HMul.hMul (interior s) (interior t)) (interior (HMul.hMul s t))","decl":"@[to_additive]\ntheorem subset_interior_mul : interior s * interior t âŠ† interior (s * t) :=\n  subset_interior_smul\n\n"}
{"name":"subset_interior_add","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : AddGroup Î±\ninstâœ : ContinuousConstVAdd Î± Î±\ns t : Set Î±\nâŠ¢ HasSubset.Subset (HAdd.hAdd (interior s) (interior t)) (interior (HAdd.hAdd s t))","decl":"@[to_additive]\ntheorem subset_interior_mul : interior s * interior t âŠ† interior (s * t) :=\n  subset_interior_smul\n\n"}
{"name":"singleton_add_mem_nhds","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : AddGroup Î±\ninstâœ : ContinuousConstVAdd Î± Î±\ns : Set Î±\na b : Î±\nh : Membership.mem (nhds b) s\nâŠ¢ Membership.mem (nhds (HAdd.hAdd a b)) (HAdd.hAdd (Singleton.singleton a) s)","decl":"@[to_additive]\ntheorem singleton_mul_mem_nhds (a : Î±) {b : Î±} (h : s âˆˆ ð“ b) : {a} * s âˆˆ ð“ (a * b) := by\n  rwa [â† smul_eq_mul, â† smul_eq_mul, singleton_smul, smul_mem_nhds_smul_iff]\n\n"}
{"name":"singleton_mul_mem_nhds","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : Group Î±\ninstâœ : ContinuousConstSMul Î± Î±\ns : Set Î±\na b : Î±\nh : Membership.mem (nhds b) s\nâŠ¢ Membership.mem (nhds (HMul.hMul a b)) (HMul.hMul (Singleton.singleton a) s)","decl":"@[to_additive]\ntheorem singleton_mul_mem_nhds (a : Î±) {b : Î±} (h : s âˆˆ ð“ b) : {a} * s âˆˆ ð“ (a * b) := by\n  rwa [â† smul_eq_mul, â† smul_eq_mul, singleton_smul, smul_mem_nhds_smul_iff]\n\n"}
{"name":"singleton_mul_mem_nhds_of_nhds_one","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : Group Î±\ninstâœ : ContinuousConstSMul Î± Î±\ns : Set Î±\na : Î±\nh : Membership.mem (nhds 1) s\nâŠ¢ Membership.mem (nhds a) (HMul.hMul (Singleton.singleton a) s)","decl":"@[to_additive]\ntheorem singleton_mul_mem_nhds_of_nhds_one (a : Î±) (h : s âˆˆ ð“ (1 : Î±)) : {a} * s âˆˆ ð“ a := by\n  simpa only [mul_one] using singleton_mul_mem_nhds a h\n\n"}
{"name":"singleton_add_mem_nhds_of_nhds_zero","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : AddGroup Î±\ninstâœ : ContinuousConstVAdd Î± Î±\ns : Set Î±\na : Î±\nh : Membership.mem (nhds 0) s\nâŠ¢ Membership.mem (nhds a) (HAdd.hAdd (Singleton.singleton a) s)","decl":"@[to_additive]\ntheorem singleton_mul_mem_nhds_of_nhds_one (a : Î±) (h : s âˆˆ ð“ (1 : Î±)) : {a} * s âˆˆ ð“ a := by\n  simpa only [mul_one] using singleton_mul_mem_nhds a h\n\n"}
{"name":"IsOpen.add_right","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : AddGroup Î±\ninstâœ : ContinuousConstVAdd (AddOpposite Î±) Î±\ns t : Set Î±\nhs : IsOpen s\nâŠ¢ IsOpen (HAdd.hAdd s t)","decl":"@[to_additive]\ntheorem IsOpen.mul_right (hs : IsOpen s) : IsOpen (s * t) := by\n  rw [â† image_op_smul]\n  exact hs.smul_left\n\n"}
{"name":"IsOpen.mul_right","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : Group Î±\ninstâœ : ContinuousConstSMul (MulOpposite Î±) Î±\ns t : Set Î±\nhs : IsOpen s\nâŠ¢ IsOpen (HMul.hMul s t)","decl":"@[to_additive]\ntheorem IsOpen.mul_right (hs : IsOpen s) : IsOpen (s * t) := by\n  rw [â† image_op_smul]\n  exact hs.smul_left\n\n"}
{"name":"subset_interior_mul_left","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : Group Î±\ninstâœ : ContinuousConstSMul (MulOpposite Î±) Î±\ns t : Set Î±\nâŠ¢ HasSubset.Subset (HMul.hMul (interior s) t) (interior (HMul.hMul s t))","decl":"@[to_additive]\ntheorem subset_interior_mul_left : interior s * t âŠ† interior (s * t) :=\n  interior_maximal (Set.mul_subset_mul_right interior_subset) isOpen_interior.mul_right\n\n"}
{"name":"subset_interior_add_left","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : AddGroup Î±\ninstâœ : ContinuousConstVAdd (AddOpposite Î±) Î±\ns t : Set Î±\nâŠ¢ HasSubset.Subset (HAdd.hAdd (interior s) t) (interior (HAdd.hAdd s t))","decl":"@[to_additive]\ntheorem subset_interior_mul_left : interior s * t âŠ† interior (s * t) :=\n  interior_maximal (Set.mul_subset_mul_right interior_subset) isOpen_interior.mul_right\n\n"}
{"name":"subset_interior_mul'","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : Group Î±\ninstâœ : ContinuousConstSMul (MulOpposite Î±) Î±\ns t : Set Î±\nâŠ¢ HasSubset.Subset (HMul.hMul (interior s) (interior t)) (interior (HMul.hMul s t))","decl":"@[to_additive]\ntheorem subset_interior_mul' : interior s * interior t âŠ† interior (s * t) :=\n  (Set.mul_subset_mul_left interior_subset).trans subset_interior_mul_left\n\n"}
{"name":"subset_interior_add'","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : AddGroup Î±\ninstâœ : ContinuousConstVAdd (AddOpposite Î±) Î±\ns t : Set Î±\nâŠ¢ HasSubset.Subset (HAdd.hAdd (interior s) (interior t)) (interior (HAdd.hAdd s t))","decl":"@[to_additive]\ntheorem subset_interior_mul' : interior s * interior t âŠ† interior (s * t) :=\n  (Set.mul_subset_mul_left interior_subset).trans subset_interior_mul_left\n\n"}
{"name":"mul_singleton_mem_nhds","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : Group Î±\ninstâœ : ContinuousConstSMul (MulOpposite Î±) Î±\ns : Set Î±\na b : Î±\nh : Membership.mem (nhds b) s\nâŠ¢ Membership.mem (nhds (HMul.hMul b a)) (HMul.hMul s (Singleton.singleton a))","decl":"@[to_additive]\ntheorem mul_singleton_mem_nhds (a : Î±) {b : Î±} (h : s âˆˆ ð“ b) : s * {a} âˆˆ ð“ (b * a) := by\n  rw [mul_singleton]\n  exact smul_mem_nhds_smul (op a) h\n\n"}
{"name":"add_singleton_mem_nhds","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : AddGroup Î±\ninstâœ : ContinuousConstVAdd (AddOpposite Î±) Î±\ns : Set Î±\na b : Î±\nh : Membership.mem (nhds b) s\nâŠ¢ Membership.mem (nhds (HAdd.hAdd b a)) (HAdd.hAdd s (Singleton.singleton a))","decl":"@[to_additive]\ntheorem mul_singleton_mem_nhds (a : Î±) {b : Î±} (h : s âˆˆ ð“ b) : s * {a} âˆˆ ð“ (b * a) := by\n  rw [mul_singleton]\n  exact smul_mem_nhds_smul (op a) h\n\n"}
{"name":"mul_singleton_mem_nhds_of_nhds_one","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : Group Î±\ninstâœ : ContinuousConstSMul (MulOpposite Î±) Î±\ns : Set Î±\na : Î±\nh : Membership.mem (nhds 1) s\nâŠ¢ Membership.mem (nhds a) (HMul.hMul s (Singleton.singleton a))","decl":"@[to_additive]\ntheorem mul_singleton_mem_nhds_of_nhds_one (a : Î±) (h : s âˆˆ ð“ (1 : Î±)) : s * {a} âˆˆ ð“ a := by\n  simpa only [one_mul] using mul_singleton_mem_nhds a h\n\n"}
{"name":"add_singleton_mem_nhds_of_nhds_zero","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : AddGroup Î±\ninstâœ : ContinuousConstVAdd (AddOpposite Î±) Î±\ns : Set Î±\na : Î±\nh : Membership.mem (nhds 0) s\nâŠ¢ Membership.mem (nhds a) (HAdd.hAdd s (Singleton.singleton a))","decl":"@[to_additive]\ntheorem mul_singleton_mem_nhds_of_nhds_one (a : Î±) (h : s âˆˆ ð“ (1 : Î±)) : s * {a} âˆˆ ð“ a := by\n  simpa only [one_mul] using mul_singleton_mem_nhds a h\n\n"}
{"name":"IsOpen.sub_left","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : TopologicalAddGroup G\ns t : Set G\nht : IsOpen t\nâŠ¢ IsOpen (HSub.hSub s t)","decl":"@[to_additive]\ntheorem IsOpen.div_left (ht : IsOpen t) : IsOpen (s / t) := by\n  rw [â† iUnion_div_left_image]\n  exact isOpen_biUnion fun a _ => isOpenMap_div_left a t ht\n\n"}
{"name":"IsOpen.div_left","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : TopologicalGroup G\ns t : Set G\nht : IsOpen t\nâŠ¢ IsOpen (HDiv.hDiv s t)","decl":"@[to_additive]\ntheorem IsOpen.div_left (ht : IsOpen t) : IsOpen (s / t) := by\n  rw [â† iUnion_div_left_image]\n  exact isOpen_biUnion fun a _ => isOpenMap_div_left a t ht\n\n"}
{"name":"IsOpen.div_right","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : TopologicalGroup G\ns t : Set G\nhs : IsOpen s\nâŠ¢ IsOpen (HDiv.hDiv s t)","decl":"@[to_additive]\ntheorem IsOpen.div_right (hs : IsOpen s) : IsOpen (s / t) := by\n  rw [â† iUnion_div_right_image]\n  exact isOpen_biUnion fun a _ => isOpenMap_div_right a s hs\n\n"}
{"name":"IsOpen.sub_right","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : TopologicalAddGroup G\ns t : Set G\nhs : IsOpen s\nâŠ¢ IsOpen (HSub.hSub s t)","decl":"@[to_additive]\ntheorem IsOpen.div_right (hs : IsOpen s) : IsOpen (s / t) := by\n  rw [â† iUnion_div_right_image]\n  exact isOpen_biUnion fun a _ => isOpenMap_div_right a s hs\n\n"}
{"name":"subset_interior_sub_left","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : TopologicalAddGroup G\ns t : Set G\nâŠ¢ HasSubset.Subset (HSub.hSub (interior s) t) (interior (HSub.hSub s t))","decl":"@[to_additive]\ntheorem subset_interior_div_left : interior s / t âŠ† interior (s / t) :=\n  interior_maximal (div_subset_div_right interior_subset) isOpen_interior.div_right\n\n"}
{"name":"subset_interior_div_left","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : TopologicalGroup G\ns t : Set G\nâŠ¢ HasSubset.Subset (HDiv.hDiv (interior s) t) (interior (HDiv.hDiv s t))","decl":"@[to_additive]\ntheorem subset_interior_div_left : interior s / t âŠ† interior (s / t) :=\n  interior_maximal (div_subset_div_right interior_subset) isOpen_interior.div_right\n\n"}
{"name":"subset_interior_sub_right","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : TopologicalAddGroup G\ns t : Set G\nâŠ¢ HasSubset.Subset (HSub.hSub s (interior t)) (interior (HSub.hSub s t))","decl":"@[to_additive]\ntheorem subset_interior_div_right : s / interior t âŠ† interior (s / t) :=\n  interior_maximal (div_subset_div_left interior_subset) isOpen_interior.div_left\n\n"}
{"name":"subset_interior_div_right","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : TopologicalGroup G\ns t : Set G\nâŠ¢ HasSubset.Subset (HDiv.hDiv s (interior t)) (interior (HDiv.hDiv s t))","decl":"@[to_additive]\ntheorem subset_interior_div_right : s / interior t âŠ† interior (s / t) :=\n  interior_maximal (div_subset_div_left interior_subset) isOpen_interior.div_left\n\n"}
{"name":"subset_interior_sub","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : TopologicalAddGroup G\ns t : Set G\nâŠ¢ HasSubset.Subset (HSub.hSub (interior s) (interior t)) (interior (HSub.hSub s t))","decl":"@[to_additive]\ntheorem subset_interior_div : interior s / interior t âŠ† interior (s / t) :=\n  (div_subset_div_left interior_subset).trans subset_interior_div_left\n\n"}
{"name":"subset_interior_div","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : TopologicalGroup G\ns t : Set G\nâŠ¢ HasSubset.Subset (HDiv.hDiv (interior s) (interior t)) (interior (HDiv.hDiv s t))","decl":"@[to_additive]\ntheorem subset_interior_div : interior s / interior t âŠ† interior (s / t) :=\n  (div_subset_div_left interior_subset).trans subset_interior_div_left\n\n"}
{"name":"IsOpen.mul_closure","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : TopologicalGroup G\ns : Set G\nhs : IsOpen s\nt : Set G\nâŠ¢ Eq (HMul.hMul s (closure t)) (HMul.hMul s t)","decl":"@[to_additive]\ntheorem IsOpen.mul_closure (hs : IsOpen s) (t : Set G) : s * closure t = s * t := by\n  refine (mul_subset_iff.2 fun a ha b hb => ?_).antisymm (mul_subset_mul_left subset_closure)\n  rw [mem_closure_iff] at hb\n  have hbU : b âˆˆ sâ»Â¹ * {a * b} := âŸ¨aâ»Â¹, Set.inv_mem_inv.2 ha, a * b, rfl, inv_mul_cancel_left _ _âŸ©\n  obtain âŸ¨_, âŸ¨c, hc, d, rfl : d = _, rflâŸ©, hcsâŸ© := hb _ hs.inv.mul_right hbU\n  exact âŸ¨câ»Â¹, hc, _, hcs, inv_mul_cancel_left _ _âŸ©\n\n"}
{"name":"IsOpen.add_closure","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : TopologicalAddGroup G\ns : Set G\nhs : IsOpen s\nt : Set G\nâŠ¢ Eq (HAdd.hAdd s (closure t)) (HAdd.hAdd s t)","decl":"@[to_additive]\ntheorem IsOpen.mul_closure (hs : IsOpen s) (t : Set G) : s * closure t = s * t := by\n  refine (mul_subset_iff.2 fun a ha b hb => ?_).antisymm (mul_subset_mul_left subset_closure)\n  rw [mem_closure_iff] at hb\n  have hbU : b âˆˆ sâ»Â¹ * {a * b} := âŸ¨aâ»Â¹, Set.inv_mem_inv.2 ha, a * b, rfl, inv_mul_cancel_left _ _âŸ©\n  obtain âŸ¨_, âŸ¨c, hc, d, rfl : d = _, rflâŸ©, hcsâŸ© := hb _ hs.inv.mul_right hbU\n  exact âŸ¨câ»Â¹, hc, _, hcs, inv_mul_cancel_left _ _âŸ©\n\n"}
{"name":"IsOpen.closure_add","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : TopologicalAddGroup G\nt : Set G\nht : IsOpen t\ns : Set G\nâŠ¢ Eq (HAdd.hAdd (closure s) t) (HAdd.hAdd s t)","decl":"@[to_additive]\ntheorem IsOpen.closure_mul (ht : IsOpen t) (s : Set G) : closure s * t = s * t := by\n  rw [â† inv_inv (closure s * t), mul_inv_rev, inv_closure, ht.inv.mul_closure, mul_inv_rev, inv_inv,\n    inv_inv]\n\n"}
{"name":"IsOpen.closure_mul","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : TopologicalGroup G\nt : Set G\nht : IsOpen t\ns : Set G\nâŠ¢ Eq (HMul.hMul (closure s) t) (HMul.hMul s t)","decl":"@[to_additive]\ntheorem IsOpen.closure_mul (ht : IsOpen t) (s : Set G) : closure s * t = s * t := by\n  rw [â† inv_inv (closure s * t), mul_inv_rev, inv_closure, ht.inv.mul_closure, mul_inv_rev, inv_inv,\n    inv_inv]\n\n"}
{"name":"IsOpen.div_closure","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : TopologicalGroup G\ns : Set G\nhs : IsOpen s\nt : Set G\nâŠ¢ Eq (HDiv.hDiv s (closure t)) (HDiv.hDiv s t)","decl":"@[to_additive]\ntheorem IsOpen.div_closure (hs : IsOpen s) (t : Set G) : s / closure t = s / t := by\n  simp_rw [div_eq_mul_inv, inv_closure, hs.mul_closure]\n\n"}
{"name":"IsOpen.sub_closure","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : TopologicalAddGroup G\ns : Set G\nhs : IsOpen s\nt : Set G\nâŠ¢ Eq (HSub.hSub s (closure t)) (HSub.hSub s t)","decl":"@[to_additive]\ntheorem IsOpen.div_closure (hs : IsOpen s) (t : Set G) : s / closure t = s / t := by\n  simp_rw [div_eq_mul_inv, inv_closure, hs.mul_closure]\n\n"}
{"name":"IsOpen.closure_sub","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : TopologicalAddGroup G\nt : Set G\nht : IsOpen t\ns : Set G\nâŠ¢ Eq (HSub.hSub (closure s) t) (HSub.hSub s t)","decl":"@[to_additive]\ntheorem IsOpen.closure_div (ht : IsOpen t) (s : Set G) : closure s / t = s / t := by\n  simp_rw [div_eq_mul_inv, ht.inv.closure_mul]\n\n"}
{"name":"IsOpen.closure_div","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : TopologicalGroup G\nt : Set G\nht : IsOpen t\ns : Set G\nâŠ¢ Eq (HDiv.hDiv (closure s) t) (HDiv.hDiv s t)","decl":"@[to_additive]\ntheorem IsOpen.closure_div (ht : IsOpen t) (s : Set G) : closure s / t = s / t := by\n  simp_rw [div_eq_mul_inv, ht.inv.closure_mul]\n\n"}
{"name":"IsClosed.mul_left_of_isCompact","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : TopologicalGroup G\ns t : Set G\nht : IsClosed t\nhs : IsCompact s\nâŠ¢ IsClosed (HMul.hMul s t)","decl":"@[to_additive]\ntheorem IsClosed.mul_left_of_isCompact (ht : IsClosed t) (hs : IsCompact s) : IsClosed (s * t) :=\n  ht.smul_left_of_isCompact hs\n\n"}
{"name":"IsClosed.add_left_of_isCompact","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : TopologicalAddGroup G\ns t : Set G\nht : IsClosed t\nhs : IsCompact s\nâŠ¢ IsClosed (HAdd.hAdd s t)","decl":"@[to_additive]\ntheorem IsClosed.mul_left_of_isCompact (ht : IsClosed t) (hs : IsCompact s) : IsClosed (s * t) :=\n  ht.smul_left_of_isCompact hs\n\n"}
{"name":"IsClosed.add_right_of_isCompact","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : TopologicalAddGroup G\ns t : Set G\nht : IsClosed t\nhs : IsCompact s\nâŠ¢ IsClosed (HAdd.hAdd t s)","decl":"@[to_additive]\ntheorem IsClosed.mul_right_of_isCompact (ht : IsClosed t) (hs : IsCompact s) :\n    IsClosed (t * s) := by\n  rw [â† image_op_smul]\n  exact IsClosed.smul_left_of_isCompact ht (hs.image continuous_op)\n\n"}
{"name":"IsClosed.mul_right_of_isCompact","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : TopologicalGroup G\ns t : Set G\nht : IsClosed t\nhs : IsCompact s\nâŠ¢ IsClosed (HMul.hMul t s)","decl":"@[to_additive]\ntheorem IsClosed.mul_right_of_isCompact (ht : IsClosed t) (hs : IsCompact s) :\n    IsClosed (t * s) := by\n  rw [â† image_op_smul]\n  exact IsClosed.smul_left_of_isCompact ht (hs.image continuous_op)\n\n"}
{"name":"subset_add_closure_zero","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type u_1\ninstâœÂ¹ : AddZeroClass G\ninstâœ : TopologicalSpace G\ns : Set G\nâŠ¢ HasSubset.Subset s (HAdd.hAdd s (closure (Singleton.singleton 0)))","decl":"@[to_additive]\nlemma subset_mul_closure_one {G} [MulOneClass G] [TopologicalSpace G] (s : Set G) :\n    s âŠ† s * (closure {1} : Set G) := by\n  have : s âŠ† s * ({1} : Set G) := by simp\n  exact this.trans (smul_subset_smul_left subset_closure)\n\n"}
{"name":"subset_mul_closure_one","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type u_1\ninstâœÂ¹ : MulOneClass G\ninstâœ : TopologicalSpace G\ns : Set G\nâŠ¢ HasSubset.Subset s (HMul.hMul s (closure (Singleton.singleton 1)))","decl":"@[to_additive]\nlemma subset_mul_closure_one {G} [MulOneClass G] [TopologicalSpace G] (s : Set G) :\n    s âŠ† s * (closure {1} : Set G) := by\n  have : s âŠ† s * ({1} : Set G) := by simp\n  exact this.trans (smul_subset_smul_left subset_closure)\n\n"}
{"name":"IsCompact.add_closure_zero_eq_closure","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : TopologicalAddGroup G\nK : Set G\nhK : IsCompact K\nâŠ¢ Eq (HAdd.hAdd K (closure (Singleton.singleton 0))) (closure K)","decl":"@[to_additive]\nlemma IsCompact.mul_closure_one_eq_closure {K : Set G} (hK : IsCompact K) :\n    K * (closure {1} : Set G) = closure K := by\n  apply Subset.antisymm ?_ ?_\n  Â· calc\n    K * (closure {1} : Set G) âŠ† closure K * (closure {1} : Set G) :=\n      smul_subset_smul_right subset_closure\n    _ âŠ† closure (K * ({1} : Set G)) := smul_set_closure_subset _ _\n    _ = closure K := by simp\n  Â· have : IsClosed (K * (closure {1} : Set G)) :=\n      IsClosed.smul_left_of_isCompact isClosed_closure hK\n    rw [IsClosed.closure_subset_iff this]\n    exact subset_mul_closure_one K\n\n"}
{"name":"IsCompact.mul_closure_one_eq_closure","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : TopologicalGroup G\nK : Set G\nhK : IsCompact K\nâŠ¢ Eq (HMul.hMul K (closure (Singleton.singleton 1))) (closure K)","decl":"@[to_additive]\nlemma IsCompact.mul_closure_one_eq_closure {K : Set G} (hK : IsCompact K) :\n    K * (closure {1} : Set G) = closure K := by\n  apply Subset.antisymm ?_ ?_\n  Â· calc\n    K * (closure {1} : Set G) âŠ† closure K * (closure {1} : Set G) :=\n      smul_subset_smul_right subset_closure\n    _ âŠ† closure (K * ({1} : Set G)) := smul_set_closure_subset _ _\n    _ = closure K := by simp\n  Â· have : IsClosed (K * (closure {1} : Set G)) :=\n      IsClosed.smul_left_of_isCompact isClosed_closure hK\n    rw [IsClosed.closure_subset_iff this]\n    exact subset_mul_closure_one K\n\n"}
{"name":"IsClosed.add_closure_zero_eq","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : TopologicalAddGroup G\nF : Set G\nhF : IsClosed F\nâŠ¢ Eq (HAdd.hAdd F (closure (Singleton.singleton 0))) F","decl":"@[to_additive]\nlemma IsClosed.mul_closure_one_eq {F : Set G} (hF : IsClosed F) :\n    F * (closure {1} : Set G) = F := by\n  refine Subset.antisymm ?_ (subset_mul_closure_one F)\n  calc\n  F * (closure {1} : Set G) = closure F * closure ({1} : Set G) := by rw [hF.closure_eq]\n  _ âŠ† closure (F * ({1} : Set G)) := smul_set_closure_subset _ _\n  _ = F := by simp [hF.closure_eq]\n\n"}
{"name":"IsClosed.mul_closure_one_eq","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : TopologicalGroup G\nF : Set G\nhF : IsClosed F\nâŠ¢ Eq (HMul.hMul F (closure (Singleton.singleton 1))) F","decl":"@[to_additive]\nlemma IsClosed.mul_closure_one_eq {F : Set G} (hF : IsClosed F) :\n    F * (closure {1} : Set G) = F := by\n  refine Subset.antisymm ?_ (subset_mul_closure_one F)\n  calc\n  F * (closure {1} : Set G) = closure F * closure ({1} : Set G) := by rw [hF.closure_eq]\n  _ âŠ† closure (F * ({1} : Set G)) := smul_set_closure_subset _ _\n  _ = F := by simp [hF.closure_eq]\n\n"}
{"name":"compl_mul_closure_one_eq","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : TopologicalGroup G\nt : Set G\nht : Eq (HMul.hMul t (closure (Singleton.singleton 1))) t\nâŠ¢ Eq (HMul.hMul (HasCompl.compl t) (closure (Singleton.singleton 1))) (HasCompl.compl t)","decl":"@[to_additive]\nlemma compl_mul_closure_one_eq {t : Set G} (ht : t * (closure {1} : Set G) = t) :\n    tá¶œ * (closure {1} : Set G) = tá¶œ := by\n  refine Subset.antisymm ?_ (subset_mul_closure_one tá¶œ)\n  rintro - âŸ¨x, hx, g, hg, rflâŸ©\n  by_contra H\n  have : x âˆˆ t * (closure {1} : Set G) := by\n    rw [â† Subgroup.coe_topologicalClosure_bot G] at hg âŠ¢\n    simp only [smul_eq_mul, mem_compl_iff, not_not] at H\n    exact âŸ¨x * g, H, gâ»Â¹, Subgroup.inv_mem _ hg, by simpâŸ©\n  rw [ht] at this\n  exact hx this\n\n"}
{"name":"compl_add_closure_zero_eq","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : TopologicalAddGroup G\nt : Set G\nht : Eq (HAdd.hAdd t (closure (Singleton.singleton 0))) t\nâŠ¢ Eq (HAdd.hAdd (HasCompl.compl t) (closure (Singleton.singleton 0))) (HasCompl.compl t)","decl":"@[to_additive]\nlemma compl_mul_closure_one_eq {t : Set G} (ht : t * (closure {1} : Set G) = t) :\n    tá¶œ * (closure {1} : Set G) = tá¶œ := by\n  refine Subset.antisymm ?_ (subset_mul_closure_one tá¶œ)\n  rintro - âŸ¨x, hx, g, hg, rflâŸ©\n  by_contra H\n  have : x âˆˆ t * (closure {1} : Set G) := by\n    rw [â† Subgroup.coe_topologicalClosure_bot G] at hg âŠ¢\n    simp only [smul_eq_mul, mem_compl_iff, not_not] at H\n    exact âŸ¨x * g, H, gâ»Â¹, Subgroup.inv_mem _ hg, by simpâŸ©\n  rw [ht] at this\n  exact hx this\n\n"}
{"name":"compl_add_closure_zero_eq_iff","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : TopologicalAddGroup G\nt : Set G\nâŠ¢ Iff (Eq (HAdd.hAdd (HasCompl.compl t) (closure (Singleton.singleton 0))) (HasCompl.compl t)) (Eq (HAdd.hAdd t (closure (Singleton.singleton 0))) t)","decl":"@[to_additive]\nlemma compl_mul_closure_one_eq_iff {t : Set G} :\n    tá¶œ * (closure {1} : Set G) = tá¶œ â†” t * (closure {1} : Set G) = t :=\n  âŸ¨fun h â†¦ by simpa using compl_mul_closure_one_eq h, fun h â†¦ compl_mul_closure_one_eq hâŸ©\n\n"}
{"name":"compl_mul_closure_one_eq_iff","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : TopologicalGroup G\nt : Set G\nâŠ¢ Iff (Eq (HMul.hMul (HasCompl.compl t) (closure (Singleton.singleton 1))) (HasCompl.compl t)) (Eq (HMul.hMul t (closure (Singleton.singleton 1))) t)","decl":"@[to_additive]\nlemma compl_mul_closure_one_eq_iff {t : Set G} :\n    tá¶œ * (closure {1} : Set G) = tá¶œ â†” t * (closure {1} : Set G) = t :=\n  âŸ¨fun h â†¦ by simpa using compl_mul_closure_one_eq h, fun h â†¦ compl_mul_closure_one_eq hâŸ©\n\n"}
{"name":"IsOpen.mul_closure_one_eq","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : TopologicalGroup G\nU : Set G\nhU : IsOpen U\nâŠ¢ Eq (HMul.hMul U (closure (Singleton.singleton 1))) U","decl":"@[to_additive]\nlemma IsOpen.mul_closure_one_eq {U : Set G} (hU : IsOpen U) :\n    U * (closure {1} : Set G) = U :=\n  compl_mul_closure_one_eq_iff.1 (hU.isClosed_compl.mul_closure_one_eq)\n\n"}
{"name":"IsOpen.add_closure_zero_eq","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : TopologicalAddGroup G\nU : Set G\nhU : IsOpen U\nâŠ¢ Eq (HAdd.hAdd U (closure (Singleton.singleton 0))) U","decl":"@[to_additive]\nlemma IsOpen.mul_closure_one_eq {U : Set G} (hU : IsOpen U) :\n    U * (closure {1} : Set G) = U :=\n  compl_mul_closure_one_eq_iff.1 (hU.isClosed_compl.mul_closure_one_eq)\n\n"}
{"name":"TopologicalAddGroup.t1Space","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : ContinuousAdd G\nh : IsClosed (Singleton.singleton 0)\nâŠ¢ T1Space G","decl":"@[to_additive]\ntheorem TopologicalGroup.t1Space (h : @IsClosed G _ {1}) : T1Space G :=\n  âŸ¨fun x => by simpa using isClosedMap_mul_right x _ hâŸ©\n\n"}
{"name":"TopologicalGroup.t1Space","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : ContinuousMul G\nh : IsClosed (Singleton.singleton 1)\nâŠ¢ T1Space G","decl":"@[to_additive]\ntheorem TopologicalGroup.t1Space (h : @IsClosed G _ {1}) : T1Space G :=\n  âŸ¨fun x => by simpa using isClosedMap_mul_right x _ hâŸ©\n\n"}
{"name":"TopologicalGroup.regularSpace","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœ : TopologicalSpace G\nâŠ¢ RegularSpace G","decl":"@[to_additive]\ninstance (priority := 100) TopologicalGroup.regularSpace : RegularSpace G := by\n  refine .of_exists_mem_nhds_isClosed_subset fun a s hs â†¦ ?_\n  have : Tendsto (fun p : G Ã— G => p.1 * p.2) (ð“ (a, 1)) (ð“ a) :=\n    continuous_mul.tendsto' _ _ (mul_one a)\n  rcases mem_nhds_prod_iff.mp (this hs) with âŸ¨U, hU, V, hV, hUVâŸ©\n  rw [â† image_subset_iff, image_prod] at hUV\n  refine âŸ¨closure U, mem_of_superset hU subset_closure, isClosed_closure, ?_âŸ©\n  calc\n    closure U âŠ† closure U * interior V := subset_mul_left _ (mem_interior_iff_mem_nhds.2 hV)\n    _ = U * interior V := isOpen_interior.closure_mul U\n    _ âŠ† U * V := mul_subset_mul_left interior_subset\n    _ âŠ† s := hUV\n\n-- `inferInstance` can find these instances now\n\n"}
{"name":"TopologicalAddGroup.regularSpace","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœ : TopologicalSpace G\nâŠ¢ RegularSpace G","decl":"@[to_additive]\ninstance (priority := 100) TopologicalGroup.regularSpace : RegularSpace G := by\n  refine .of_exists_mem_nhds_isClosed_subset fun a s hs â†¦ ?_\n  have : Tendsto (fun p : G Ã— G => p.1 * p.2) (ð“ (a, 1)) (ð“ a) :=\n    continuous_mul.tendsto' _ _ (mul_one a)\n  rcases mem_nhds_prod_iff.mp (this hs) with âŸ¨U, hU, V, hV, hUVâŸ©\n  rw [â† image_subset_iff, image_prod] at hUV\n  refine âŸ¨closure U, mem_of_superset hU subset_closure, isClosed_closure, ?_âŸ©\n  calc\n    closure U âŠ† closure U * interior V := subset_mul_left _ (mem_interior_iff_mem_nhds.2 hV)\n    _ = U * interior V := isOpen_interior.closure_mul U\n    _ âŠ† U * V := mul_subset_mul_left interior_subset\n    _ âŠ† s := hUV\n\n-- `inferInstance` can find these instances now\n\n"}
{"name":"group_inseparable_iff","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : TopologicalGroup G\nx y : G\nâŠ¢ Iff (Inseparable x y) (Membership.mem (closure 1) (HDiv.hDiv x y))","decl":"@[to_additive]\ntheorem group_inseparable_iff {x y : G} : Inseparable x y â†” x / y âˆˆ closure (1 : Set G) := by\n  rw [â† singleton_one, â† specializes_iff_mem_closure, specializes_comm, specializes_iff_inseparable,\n    â† (Homeomorph.mulRight yâ»Â¹).isEmbedding.inseparable_iff]\n  simp [div_eq_mul_inv]\n\n"}
{"name":"addGroup_inseparable_iff","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : TopologicalAddGroup G\nx y : G\nâŠ¢ Iff (Inseparable x y) (Membership.mem (closure 0) (HSub.hSub x y))","decl":"@[to_additive]\ntheorem group_inseparable_iff {x y : G} : Inseparable x y â†” x / y âˆˆ closure (1 : Set G) := by\n  rw [â† singleton_one, â† specializes_iff_mem_closure, specializes_comm, specializes_iff_inseparable,\n    â† (Homeomorph.mulRight yâ»Â¹).isEmbedding.inseparable_iff]\n  simp [div_eq_mul_inv]\n\n"}
{"name":"TopologicalGroup.t2Space_iff_one_closed","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : TopologicalGroup G\nâŠ¢ Iff (T2Space G) (IsClosed (Singleton.singleton 1))","decl":"@[to_additive]\ntheorem TopologicalGroup.t2Space_iff_one_closed : T2Space G â†” IsClosed ({1} : Set G) :=\n  âŸ¨fun _ â†¦ isClosed_singleton, fun h â†¦\n    have := TopologicalGroup.t1Space G h; inferInstanceâŸ©\n\n"}
{"name":"TopologicalAddGroup.t2Space_iff_zero_closed","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : TopologicalAddGroup G\nâŠ¢ Iff (T2Space G) (IsClosed (Singleton.singleton 0))","decl":"@[to_additive]\ntheorem TopologicalGroup.t2Space_iff_one_closed : T2Space G â†” IsClosed ({1} : Set G) :=\n  âŸ¨fun _ â†¦ isClosed_singleton, fun h â†¦\n    have := TopologicalGroup.t1Space G h; inferInstanceâŸ©\n\n"}
{"name":"TopologicalAddGroup.t2Space_of_zero_sep","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : TopologicalAddGroup G\nH : âˆ€ (x : G), Ne x 0 â†’ Exists fun U => And (Membership.mem (nhds 0) U) (Not (Membership.mem U x))\nâŠ¢ T2Space G","decl":"@[to_additive]\ntheorem TopologicalGroup.t2Space_of_one_sep (H : âˆ€ x : G, x â‰  1 â†’ âˆƒ U âˆˆ ð“ (1 : G), x âˆ‰ U) :\n    T2Space G := by\n  suffices T1Space G from inferInstance\n  refine t1Space_iff_specializes_imp_eq.2 fun x y hspec â†¦ by_contra fun hne â†¦ ?_\n  rcases H (x * yâ»Â¹) (by rwa [Ne, mul_inv_eq_one]) with âŸ¨U, hUâ‚, hUâŸ©\n  exact hU <| mem_of_mem_nhds <| hspec.map (continuous_mul_right yâ»Â¹) (by rwa [mul_inv_cancel])\n\n"}
{"name":"TopologicalGroup.t2Space_of_one_sep","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : TopologicalGroup G\nH : âˆ€ (x : G), Ne x 1 â†’ Exists fun U => And (Membership.mem (nhds 1) U) (Not (Membership.mem U x))\nâŠ¢ T2Space G","decl":"@[to_additive]\ntheorem TopologicalGroup.t2Space_of_one_sep (H : âˆ€ x : G, x â‰  1 â†’ âˆƒ U âˆˆ ð“ (1 : G), x âˆ‰ U) :\n    T2Space G := by\n  suffices T1Space G from inferInstance\n  refine t1Space_iff_specializes_imp_eq.2 fun x y hspec â†¦ by_contra fun hne â†¦ ?_\n  rcases H (x * yâ»Â¹) (by rwa [Ne, mul_inv_eq_one]) with âŸ¨U, hUâ‚, hUâŸ©\n  exact hU <| mem_of_mem_nhds <| hspec.map (continuous_mul_right yâ»Â¹) (by rwa [mul_inv_cancel])\n\n"}
{"name":"exists_closed_nhds_zero_neg_eq_add_subset","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : TopologicalAddGroup G\nU : Set G\nhU : Membership.mem (nhds 0) U\nâŠ¢ Exists fun V => And (Membership.mem (nhds 0) V) (And (IsClosed V) (And (Eq (Neg.neg V) V) (HasSubset.Subset (HAdd.hAdd V V) U)))","decl":"/-- Given a neighborhood `U` of the identity, one may find a neighborhood `V` of the identity which\nis closed, symmetric, and satisfies `V * V âŠ† U`. -/\n@[to_additive \"Given a neighborhood `U` of the identity, one may find a neighborhood `V` of the\nidentity which is closed, symmetric, and satisfies `V + V âŠ† U`.\"]\ntheorem exists_closed_nhds_one_inv_eq_mul_subset {U : Set G} (hU : U âˆˆ ð“ 1) :\n    âˆƒ V âˆˆ ð“ 1, IsClosed V âˆ§ Vâ»Â¹ = V âˆ§ V * V âŠ† U := by\n  rcases exists_open_nhds_one_mul_subset hU with âŸ¨V, V_open, V_mem, hVâŸ©\n  rcases exists_mem_nhds_isClosed_subset (V_open.mem_nhds V_mem) with âŸ¨W, W_mem, W_closed, hWâŸ©\n  refine âŸ¨W âˆ© Wâ»Â¹, Filter.inter_mem W_mem (inv_mem_nhds_one G W_mem), W_closed.inter W_closed.inv,\n    by simp [inter_comm], ?_âŸ©\n  calc\n  W âˆ© Wâ»Â¹ * (W âˆ© Wâ»Â¹)\n    âŠ† W * W := mul_subset_mul inter_subset_left inter_subset_left\n  _ âŠ† V * V := mul_subset_mul hW hW\n  _ âŠ† U := hV\n\n"}
{"name":"exists_closed_nhds_one_inv_eq_mul_subset","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : TopologicalGroup G\nU : Set G\nhU : Membership.mem (nhds 1) U\nâŠ¢ Exists fun V => And (Membership.mem (nhds 1) V) (And (IsClosed V) (And (Eq (Inv.inv V) V) (HasSubset.Subset (HMul.hMul V V) U)))","decl":"/-- Given a neighborhood `U` of the identity, one may find a neighborhood `V` of the identity which\nis closed, symmetric, and satisfies `V * V âŠ† U`. -/\n@[to_additive \"Given a neighborhood `U` of the identity, one may find a neighborhood `V` of the\nidentity which is closed, symmetric, and satisfies `V + V âŠ† U`.\"]\ntheorem exists_closed_nhds_one_inv_eq_mul_subset {U : Set G} (hU : U âˆˆ ð“ 1) :\n    âˆƒ V âˆˆ ð“ 1, IsClosed V âˆ§ Vâ»Â¹ = V âˆ§ V * V âŠ† U := by\n  rcases exists_open_nhds_one_mul_subset hU with âŸ¨V, V_open, V_mem, hVâŸ©\n  rcases exists_mem_nhds_isClosed_subset (V_open.mem_nhds V_mem) with âŸ¨W, W_mem, W_closed, hWâŸ©\n  refine âŸ¨W âˆ© Wâ»Â¹, Filter.inter_mem W_mem (inv_mem_nhds_one G W_mem), W_closed.inter W_closed.inv,\n    by simp [inter_comm], ?_âŸ©\n  calc\n  W âˆ© Wâ»Â¹ * (W âˆ© Wâ»Â¹)\n    âŠ† W * W := mul_subset_mul inter_subset_left inter_subset_left\n  _ âŠ† V * V := mul_subset_mul hW hW\n  _ âŠ† U := hV\n\n"}
{"name":"Subgroup.properlyDiscontinuousSMul_of_tendsto_cofinite","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : TopologicalGroup G\nS : Subgroup G\nhS : Filter.Tendsto (â‡‘S.subtype) Filter.cofinite (Filter.cocompact G)\nâŠ¢ ProperlyDiscontinuousSMul (Subtype fun x => Membership.mem S x) G","decl":"/-- A subgroup `S` of a topological group `G` acts on `G` properly discontinuously on the left, if\nit is discrete in the sense that `S âˆ© K` is finite for all compact `K`. (See also\n`DiscreteTopology`.) -/\n@[to_additive\n  \"A subgroup `S` of an additive topological group `G` acts on `G` properly\n  discontinuously on the left, if it is discrete in the sense that `S âˆ© K` is finite for all compact\n  `K`. (See also `DiscreteTopology`.\"]\ntheorem Subgroup.properlyDiscontinuousSMul_of_tendsto_cofinite (S : Subgroup G)\n    (hS : Tendsto S.subtype cofinite (cocompact G)) : ProperlyDiscontinuousSMul S G :=\n  { finite_disjoint_inter_image := by\n      intro K L hK hL\n      have H : Set.Finite _ := hS ((hL.prod hK).image continuous_div').compl_mem_cocompact\n      rw [preimage_compl, compl_compl] at H\n      convert H\n      ext x\n      simp only [image_smul, mem_setOf_eq, coeSubtype, mem_preimage, mem_image, Prod.exists]\n      exact Set.smul_inter_ne_empty_iff' }\n\n-- attribute [local semireducible] MulOpposite -- Porting note: doesn't work in Lean 4\n\n"}
{"name":"AddSubgroup.properlyDiscontinuousVAdd_of_tendsto_cofinite","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : TopologicalAddGroup G\nS : AddSubgroup G\nhS : Filter.Tendsto (â‡‘S.subtype) Filter.cofinite (Filter.cocompact G)\nâŠ¢ ProperlyDiscontinuousVAdd (Subtype fun x => Membership.mem S x) G","decl":"/-- A subgroup `S` of a topological group `G` acts on `G` properly discontinuously on the left, if\nit is discrete in the sense that `S âˆ© K` is finite for all compact `K`. (See also\n`DiscreteTopology`.) -/\n@[to_additive\n  \"A subgroup `S` of an additive topological group `G` acts on `G` properly\n  discontinuously on the left, if it is discrete in the sense that `S âˆ© K` is finite for all compact\n  `K`. (See also `DiscreteTopology`.\"]\ntheorem Subgroup.properlyDiscontinuousSMul_of_tendsto_cofinite (S : Subgroup G)\n    (hS : Tendsto S.subtype cofinite (cocompact G)) : ProperlyDiscontinuousSMul S G :=\n  { finite_disjoint_inter_image := by\n      intro K L hK hL\n      have H : Set.Finite _ := hS ((hL.prod hK).image continuous_div').compl_mem_cocompact\n      rw [preimage_compl, compl_compl] at H\n      convert H\n      ext x\n      simp only [image_smul, mem_setOf_eq, coeSubtype, mem_preimage, mem_image, Prod.exists]\n      exact Set.smul_inter_ne_empty_iff' }\n\n-- attribute [local semireducible] MulOpposite -- Porting note: doesn't work in Lean 4\n\n"}
{"name":"Subgroup.properlyDiscontinuousSMul_opposite_of_tendsto_cofinite","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : TopologicalGroup G\nS : Subgroup G\nhS : Filter.Tendsto (â‡‘S.subtype) Filter.cofinite (Filter.cocompact G)\nâŠ¢ ProperlyDiscontinuousSMul (Subtype fun x => Membership.mem S.op x) G","decl":"/-- A subgroup `S` of a topological group `G` acts on `G` properly discontinuously on the right, if\nit is discrete in the sense that `S âˆ© K` is finite for all compact `K`. (See also\n`DiscreteTopology`.)\n\nIf `G` is Hausdorff, this can be combined with `t2Space_of_properlyDiscontinuousSMul_of_t2Space`\nto show that the quotient group `G â§¸ S` is Hausdorff. -/\n@[to_additive\n  \"A subgroup `S` of an additive topological group `G` acts on `G` properly discontinuously\n  on the right, if it is discrete in the sense that `S âˆ© K` is finite for all compact `K`.\n  (See also `DiscreteTopology`.)\n\n  If `G` is Hausdorff, this can be combined with `t2Space_of_properlyDiscontinuousVAdd_of_t2Space`\n  to show that the quotient group `G â§¸ S` is Hausdorff.\"]\ntheorem Subgroup.properlyDiscontinuousSMul_opposite_of_tendsto_cofinite (S : Subgroup G)\n    (hS : Tendsto S.subtype cofinite (cocompact G)) : ProperlyDiscontinuousSMul S.op G :=\n  { finite_disjoint_inter_image := by\n      intro K L hK hL\n      have : Continuous fun p : G Ã— G => (p.1â»Â¹, p.2) := continuous_inv.prodMap continuous_id\n      have H : Set.Finite _ :=\n        hS ((hK.prod hL).image (continuous_mul.comp this)).compl_mem_cocompact\n      simp only [preimage_compl, compl_compl, coeSubtype, comp_apply] at H\n      apply Finite.of_preimage _ (equivOp S).surjective\n      convert H using 1\n      ext x\n      simp only [image_smul, mem_setOf_eq, coeSubtype, mem_preimage, mem_image, Prod.exists]\n      exact Set.op_smul_inter_ne_empty_iff }\n\n"}
{"name":"AddSubgroup.properlyDiscontinuousVAdd_opposite_of_tendsto_cofinite","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : TopologicalAddGroup G\nS : AddSubgroup G\nhS : Filter.Tendsto (â‡‘S.subtype) Filter.cofinite (Filter.cocompact G)\nâŠ¢ ProperlyDiscontinuousVAdd (Subtype fun x => Membership.mem S.op x) G","decl":"/-- A subgroup `S` of a topological group `G` acts on `G` properly discontinuously on the right, if\nit is discrete in the sense that `S âˆ© K` is finite for all compact `K`. (See also\n`DiscreteTopology`.)\n\nIf `G` is Hausdorff, this can be combined with `t2Space_of_properlyDiscontinuousSMul_of_t2Space`\nto show that the quotient group `G â§¸ S` is Hausdorff. -/\n@[to_additive\n  \"A subgroup `S` of an additive topological group `G` acts on `G` properly discontinuously\n  on the right, if it is discrete in the sense that `S âˆ© K` is finite for all compact `K`.\n  (See also `DiscreteTopology`.)\n\n  If `G` is Hausdorff, this can be combined with `t2Space_of_properlyDiscontinuousVAdd_of_t2Space`\n  to show that the quotient group `G â§¸ S` is Hausdorff.\"]\ntheorem Subgroup.properlyDiscontinuousSMul_opposite_of_tendsto_cofinite (S : Subgroup G)\n    (hS : Tendsto S.subtype cofinite (cocompact G)) : ProperlyDiscontinuousSMul S.op G :=\n  { finite_disjoint_inter_image := by\n      intro K L hK hL\n      have : Continuous fun p : G Ã— G => (p.1â»Â¹, p.2) := continuous_inv.prodMap continuous_id\n      have H : Set.Finite _ :=\n        hS ((hK.prod hL).image (continuous_mul.comp this)).compl_mem_cocompact\n      simp only [preimage_compl, compl_compl, coeSubtype, comp_apply] at H\n      apply Finite.of_preimage _ (equivOp S).surjective\n      convert H using 1\n      ext x\n      simp only [image_smul, mem_setOf_eq, coeSubtype, mem_preimage, mem_image, Prod.exists]\n      exact Set.op_smul_inter_ne_empty_iff }\n\n"}
{"name":"compact_open_separated_add_right","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddZeroClass G\ninstâœ : ContinuousAdd G\nK U : Set G\nhK : IsCompact K\nhU : IsOpen U\nhKU : HasSubset.Subset K U\nâŠ¢ Exists fun V => And (Membership.mem (nhds 0) V) (HasSubset.Subset (HAdd.hAdd K V) U)","decl":"/-- Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of `1`\n  such that `K * V âŠ† U`. -/\n@[to_additive\n  \"Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of\n  `0` such that `K + V âŠ† U`.\"]\ntheorem compact_open_separated_mul_right {K U : Set G} (hK : IsCompact K) (hU : IsOpen U)\n    (hKU : K âŠ† U) : âˆƒ V âˆˆ ð“ (1 : G), K * V âŠ† U := by\n  refine hK.induction_on ?_ ?_ ?_ ?_\n  Â· exact âŸ¨univ, by simpâŸ©\n  Â· rintro s t hst âŸ¨V, hV, hV'âŸ©\n    exact âŸ¨V, hV, (mul_subset_mul_right hst).trans hV'âŸ©\n  Â· rintro s t âŸ¨V, V_in, hV'âŸ© âŸ¨W, W_in, hW'âŸ©\n    use V âˆ© W, inter_mem V_in W_in\n    rw [union_mul]\n    exact\n      union_subset ((mul_subset_mul_left V.inter_subset_left).trans hV')\n        ((mul_subset_mul_left V.inter_subset_right).trans hW')\n  Â· intro x hx\n    have := tendsto_mul (show U âˆˆ ð“ (x * 1) by simpa using hU.mem_nhds (hKU hx))\n    rw [nhds_prod_eq, mem_map, mem_prod_iff] at this\n    rcases this with âŸ¨t, ht, s, hs, hâŸ©\n    rw [â† image_subset_iff, image_mul_prod] at h\n    exact âŸ¨t, mem_nhdsWithin_of_mem_nhds ht, s, hs, hâŸ©\n\n"}
{"name":"compact_open_separated_mul_right","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : MulOneClass G\ninstâœ : ContinuousMul G\nK U : Set G\nhK : IsCompact K\nhU : IsOpen U\nhKU : HasSubset.Subset K U\nâŠ¢ Exists fun V => And (Membership.mem (nhds 1) V) (HasSubset.Subset (HMul.hMul K V) U)","decl":"/-- Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of `1`\n  such that `K * V âŠ† U`. -/\n@[to_additive\n  \"Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of\n  `0` such that `K + V âŠ† U`.\"]\ntheorem compact_open_separated_mul_right {K U : Set G} (hK : IsCompact K) (hU : IsOpen U)\n    (hKU : K âŠ† U) : âˆƒ V âˆˆ ð“ (1 : G), K * V âŠ† U := by\n  refine hK.induction_on ?_ ?_ ?_ ?_\n  Â· exact âŸ¨univ, by simpâŸ©\n  Â· rintro s t hst âŸ¨V, hV, hV'âŸ©\n    exact âŸ¨V, hV, (mul_subset_mul_right hst).trans hV'âŸ©\n  Â· rintro s t âŸ¨V, V_in, hV'âŸ© âŸ¨W, W_in, hW'âŸ©\n    use V âˆ© W, inter_mem V_in W_in\n    rw [union_mul]\n    exact\n      union_subset ((mul_subset_mul_left V.inter_subset_left).trans hV')\n        ((mul_subset_mul_left V.inter_subset_right).trans hW')\n  Â· intro x hx\n    have := tendsto_mul (show U âˆˆ ð“ (x * 1) by simpa using hU.mem_nhds (hKU hx))\n    rw [nhds_prod_eq, mem_map, mem_prod_iff] at this\n    rcases this with âŸ¨t, ht, s, hs, hâŸ©\n    rw [â† image_subset_iff, image_mul_prod] at h\n    exact âŸ¨t, mem_nhdsWithin_of_mem_nhds ht, s, hs, hâŸ©\n\n"}
{"name":"compact_open_separated_add_left","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddZeroClass G\ninstâœ : ContinuousAdd G\nK U : Set G\nhK : IsCompact K\nhU : IsOpen U\nhKU : HasSubset.Subset K U\nâŠ¢ Exists fun V => And (Membership.mem (nhds 0) V) (HasSubset.Subset (HAdd.hAdd V K) U)","decl":"/-- Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of `1`\n  such that `V * K âŠ† U`. -/\n@[to_additive\n  \"Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of\n  `0` such that `V + K âŠ† U`.\"]\ntheorem compact_open_separated_mul_left {K U : Set G} (hK : IsCompact K) (hU : IsOpen U)\n    (hKU : K âŠ† U) : âˆƒ V âˆˆ ð“ (1 : G), V * K âŠ† U := by\n  rcases compact_open_separated_mul_right (hK.image continuous_op) (opHomeomorph.isOpenMap U hU)\n      (image_subset op hKU) with\n    âŸ¨V, hV : V âˆˆ ð“ (op (1 : G)), hV' : op '' K * V âŠ† op '' UâŸ©\n  refine âŸ¨op â»Â¹' V, continuous_op.continuousAt hV, ?_âŸ©\n  rwa [â† image_preimage_eq V op_surjective, â† image_op_mul, image_subset_iff,\n    preimage_image_eq _ op_injective] at hV'\n\n"}
{"name":"compact_open_separated_mul_left","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : MulOneClass G\ninstâœ : ContinuousMul G\nK U : Set G\nhK : IsCompact K\nhU : IsOpen U\nhKU : HasSubset.Subset K U\nâŠ¢ Exists fun V => And (Membership.mem (nhds 1) V) (HasSubset.Subset (HMul.hMul V K) U)","decl":"/-- Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of `1`\n  such that `V * K âŠ† U`. -/\n@[to_additive\n  \"Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of\n  `0` such that `V + K âŠ† U`.\"]\ntheorem compact_open_separated_mul_left {K U : Set G} (hK : IsCompact K) (hU : IsOpen U)\n    (hKU : K âŠ† U) : âˆƒ V âˆˆ ð“ (1 : G), V * K âŠ† U := by\n  rcases compact_open_separated_mul_right (hK.image continuous_op) (opHomeomorph.isOpenMap U hU)\n      (image_subset op hKU) with\n    âŸ¨V, hV : V âˆˆ ð“ (op (1 : G)), hV' : op '' K * V âŠ† op '' UâŸ©\n  refine âŸ¨op â»Â¹' V, continuous_op.continuousAt hV, ?_âŸ©\n  rwa [â† image_preimage_eq V op_surjective, â† image_op_mul, image_subset_iff,\n    preimage_image_eq _ op_injective] at hV'\n\n"}
{"name":"compact_covered_by_mul_left_translates","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : TopologicalGroup G\nK V : Set G\nhK : IsCompact K\nhV : (interior V).Nonempty\nâŠ¢ Exists fun t => HasSubset.Subset K (Set.iUnion fun g => Set.iUnion fun h => Set.preimage (fun x => HMul.hMul g x) V)","decl":"/-- A compact set is covered by finitely many left multiplicative translates of a set\n  with non-empty interior. -/\n@[to_additive\n  \"A compact set is covered by finitely many left additive translates of a set\n    with non-empty interior.\"]\ntheorem compact_covered_by_mul_left_translates {K V : Set G} (hK : IsCompact K)\n    (hV : (interior V).Nonempty) : âˆƒ t : Finset G, K âŠ† â‹ƒ g âˆˆ t, (g * Â·) â»Â¹' V := by\n  obtain âŸ¨t, htâŸ© : âˆƒ t : Finset G, K âŠ† â‹ƒ x âˆˆ t, interior ((x * Â·) â»Â¹' V) := by\n    refine\n      hK.elim_finite_subcover (fun x => interior <| (x * Â·) â»Â¹' V) (fun x => isOpen_interior) ?_\n    cases' hV with gâ‚€ hgâ‚€\n    refine fun g _ => mem_iUnion.2 âŸ¨gâ‚€ * gâ»Â¹, ?_âŸ©\n    refine preimage_interior_subset_interior_preimage (continuous_const.mul continuous_id) ?_\n    rwa [mem_preimage, Function.id_def, inv_mul_cancel_right]\n  exact âŸ¨t, Subset.trans ht <| iUnionâ‚‚_mono fun g _ => interior_subsetâŸ©\n\n"}
{"name":"compact_covered_by_add_left_translates","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : TopologicalAddGroup G\nK V : Set G\nhK : IsCompact K\nhV : (interior V).Nonempty\nâŠ¢ Exists fun t => HasSubset.Subset K (Set.iUnion fun g => Set.iUnion fun h => Set.preimage (fun x => HAdd.hAdd g x) V)","decl":"/-- A compact set is covered by finitely many left multiplicative translates of a set\n  with non-empty interior. -/\n@[to_additive\n  \"A compact set is covered by finitely many left additive translates of a set\n    with non-empty interior.\"]\ntheorem compact_covered_by_mul_left_translates {K V : Set G} (hK : IsCompact K)\n    (hV : (interior V).Nonempty) : âˆƒ t : Finset G, K âŠ† â‹ƒ g âˆˆ t, (g * Â·) â»Â¹' V := by\n  obtain âŸ¨t, htâŸ© : âˆƒ t : Finset G, K âŠ† â‹ƒ x âˆˆ t, interior ((x * Â·) â»Â¹' V) := by\n    refine\n      hK.elim_finite_subcover (fun x => interior <| (x * Â·) â»Â¹' V) (fun x => isOpen_interior) ?_\n    cases' hV with gâ‚€ hgâ‚€\n    refine fun g _ => mem_iUnion.2 âŸ¨gâ‚€ * gâ»Â¹, ?_âŸ©\n    refine preimage_interior_subset_interior_preimage (continuous_const.mul continuous_id) ?_\n    rwa [mem_preimage, Function.id_def, inv_mul_cancel_right]\n  exact âŸ¨t, Subset.trans ht <| iUnionâ‚‚_mono fun g _ => interior_subsetâŸ©\n\n"}
{"name":"SeparableWeaklyLocallyCompactGroup.sigmaCompactSpace","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : TopologicalSpace.SeparableSpace G\ninstâœ : WeaklyLocallyCompactSpace G\nâŠ¢ SigmaCompactSpace G","decl":"/-- Every weakly locally compact separable topological group is Ïƒ-compact.\n  Note: this is not true if we drop the topological group hypothesis. -/\n@[to_additive SeparableWeaklyLocallyCompactAddGroup.sigmaCompactSpace\n  \"Every weakly locally compact separable topological additive group is Ïƒ-compact.\n  Note: this is not true if we drop the topological group hypothesis.\"]\ninstance (priority := 100) SeparableWeaklyLocallyCompactGroup.sigmaCompactSpace [SeparableSpace G]\n    [WeaklyLocallyCompactSpace G] : SigmaCompactSpace G := by\n  obtain âŸ¨L, hLc, hL1âŸ© := exists_compact_mem_nhds (1 : G)\n  refine âŸ¨âŸ¨fun n => (fun x => x * denseSeq G n) â»Â¹' L, ?_, ?_âŸ©âŸ©\n  Â· intro n\n    exact (Homeomorph.mulRight _).isCompact_preimage.mpr hLc\n  Â· refine iUnion_eq_univ_iff.2 fun x => ?_\n    obtain âŸ¨_, âŸ¨n, rflâŸ©, hnâŸ© : (range (denseSeq G) âˆ© (fun y => x * y) â»Â¹' L).Nonempty := by\n      rw [â† (Homeomorph.mulLeft x).apply_symm_apply 1] at hL1\n      exact (denseRange_denseSeq G).inter_nhds_nonempty\n          ((Homeomorph.mulLeft x).continuous.continuousAt <| hL1)\n    exact âŸ¨n, hnâŸ©\n\n"}
{"name":"SeparableWeaklyLocallyCompactAddGroup.sigmaCompactSpace","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : TopologicalSpace.SeparableSpace G\ninstâœ : WeaklyLocallyCompactSpace G\nâŠ¢ SigmaCompactSpace G","decl":"/-- Every weakly locally compact separable topological group is Ïƒ-compact.\n  Note: this is not true if we drop the topological group hypothesis. -/\n@[to_additive SeparableWeaklyLocallyCompactAddGroup.sigmaCompactSpace\n  \"Every weakly locally compact separable topological additive group is Ïƒ-compact.\n  Note: this is not true if we drop the topological group hypothesis.\"]\ninstance (priority := 100) SeparableWeaklyLocallyCompactGroup.sigmaCompactSpace [SeparableSpace G]\n    [WeaklyLocallyCompactSpace G] : SigmaCompactSpace G := by\n  obtain âŸ¨L, hLc, hL1âŸ© := exists_compact_mem_nhds (1 : G)\n  refine âŸ¨âŸ¨fun n => (fun x => x * denseSeq G n) â»Â¹' L, ?_, ?_âŸ©âŸ©\n  Â· intro n\n    exact (Homeomorph.mulRight _).isCompact_preimage.mpr hLc\n  Â· refine iUnion_eq_univ_iff.2 fun x => ?_\n    obtain âŸ¨_, âŸ¨n, rflâŸ©, hnâŸ© : (range (denseSeq G) âˆ© (fun y => x * y) â»Â¹' L).Nonempty := by\n      rw [â† (Homeomorph.mulLeft x).apply_symm_apply 1] at hL1\n      exact (denseRange_denseSeq G).inter_nhds_nonempty\n          ((Homeomorph.mulLeft x).continuous.continuousAt <| hL1)\n    exact âŸ¨n, hnâŸ©\n\n"}
{"name":"exists_disjoint_vadd_of_isCompact","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ³ : TopologicalSpace G\ninstâœÂ² : AddGroup G\ninstâœÂ¹ : TopologicalAddGroup G\ninstâœ : NoncompactSpace G\nK L : Set G\nhK : IsCompact K\nhL : IsCompact L\nâŠ¢ Exists fun g => Disjoint K (HVAdd.hVAdd g L)","decl":"/-- Given two compact sets in a noncompact topological group, there is a translate of the second\none that is disjoint from the first one. -/\n@[to_additive\n  \"Given two compact sets in a noncompact additive topological group, there is a\n  translate of the second one that is disjoint from the first one.\"]\ntheorem exists_disjoint_smul_of_isCompact [NoncompactSpace G] {K L : Set G} (hK : IsCompact K)\n    (hL : IsCompact L) : âˆƒ g : G, Disjoint K (g â€¢ L) := by\n  have A : Â¬K * Lâ»Â¹ = univ := (hK.mul hL.inv).ne_univ\n  obtain âŸ¨g, hgâŸ© : âˆƒ g, g âˆ‰ K * Lâ»Â¹ := by\n    contrapose! A\n    exact eq_univ_iff_forall.2 A\n  refine âŸ¨g, ?_âŸ©\n  refine disjoint_left.2 fun a ha h'a => hg ?_\n  rcases h'a with âŸ¨b, bL, rflâŸ©\n  refine âŸ¨g * b, ha, bâ»Â¹, by simpa only [Set.mem_inv, inv_inv] using bL, ?_âŸ©\n  simp only [smul_eq_mul, mul_inv_cancel_right]\n\n"}
{"name":"exists_disjoint_smul_of_isCompact","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ³ : TopologicalSpace G\ninstâœÂ² : Group G\ninstâœÂ¹ : TopologicalGroup G\ninstâœ : NoncompactSpace G\nK L : Set G\nhK : IsCompact K\nhL : IsCompact L\nâŠ¢ Exists fun g => Disjoint K (HSMul.hSMul g L)","decl":"/-- Given two compact sets in a noncompact topological group, there is a translate of the second\none that is disjoint from the first one. -/\n@[to_additive\n  \"Given two compact sets in a noncompact additive topological group, there is a\n  translate of the second one that is disjoint from the first one.\"]\ntheorem exists_disjoint_smul_of_isCompact [NoncompactSpace G] {K L : Set G} (hK : IsCompact K)\n    (hL : IsCompact L) : âˆƒ g : G, Disjoint K (g â€¢ L) := by\n  have A : Â¬K * Lâ»Â¹ = univ := (hK.mul hL.inv).ne_univ\n  obtain âŸ¨g, hgâŸ© : âˆƒ g, g âˆ‰ K * Lâ»Â¹ := by\n    contrapose! A\n    exact eq_univ_iff_forall.2 A\n  refine âŸ¨g, ?_âŸ©\n  refine disjoint_left.2 fun a ha h'a => hg ?_\n  rcases h'a with âŸ¨b, bL, rflâŸ©\n  refine âŸ¨g * b, ha, bâ»Â¹, by simpa only [Set.mem_inv, inv_inv] using bL, ?_âŸ©\n  simp only [smul_eq_mul, mul_inv_cancel_right]\n\n"}
{"name":"IsCompact.locallyCompactSpace_of_mem_nhds_of_group","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : TopologicalGroup G\nK : Set G\nhK : IsCompact K\nx : G\nh : Membership.mem (nhds x) K\nâŠ¢ LocallyCompactSpace G","decl":"/-- If a point in a topological group has a compact neighborhood, then the group is\nlocally compact. -/\n@[to_additive]\ntheorem IsCompact.locallyCompactSpace_of_mem_nhds_of_group {K : Set G} (hK : IsCompact K) {x : G}\n    (h : K âˆˆ ð“ x) : LocallyCompactSpace G := by\n  suffices WeaklyLocallyCompactSpace G from inferInstance\n  refine âŸ¨fun y â†¦ âŸ¨(y * xâ»Â¹) â€¢ K, ?_, ?_âŸ©âŸ©\n  Â· exact hK.smul _\n  Â· rw [â† preimage_smul_inv]\n    exact (continuous_const_smul _).continuousAt.preimage_mem_nhds (by simpa using h)\n\n"}
{"name":"IsCompact.locallyCompactSpace_of_mem_nhds_of_addGroup","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : TopologicalAddGroup G\nK : Set G\nhK : IsCompact K\nx : G\nh : Membership.mem (nhds x) K\nâŠ¢ LocallyCompactSpace G","decl":"/-- If a point in a topological group has a compact neighborhood, then the group is\nlocally compact. -/\n@[to_additive]\ntheorem IsCompact.locallyCompactSpace_of_mem_nhds_of_group {K : Set G} (hK : IsCompact K) {x : G}\n    (h : K âˆˆ ð“ x) : LocallyCompactSpace G := by\n  suffices WeaklyLocallyCompactSpace G from inferInstance\n  refine âŸ¨fun y â†¦ âŸ¨(y * xâ»Â¹) â€¢ K, ?_, ?_âŸ©âŸ©\n  Â· exact hK.smul _\n  Â· rw [â† preimage_smul_inv]\n    exact (continuous_const_smul _).continuousAt.preimage_mem_nhds (by simpa using h)\n\n"}
{"name":"eq_zero_or_locallyCompactSpace_of_support_subset_isCompact_of_addGroup","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\nÎ± : Type u\ninstâœâµ : TopologicalSpace G\ninstâœâ´ : AddGroup G\ninstâœÂ³ : TopologicalAddGroup G\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : Zero Î±\ninstâœ : T1Space Î±\nf : G â†’ Î±\nk : Set G\nhk : IsCompact k\nhf : HasSubset.Subset (Function.support f) k\nh'f : Continuous f\nâŠ¢ Or (Eq f 0) (LocallyCompactSpace G)","decl":"/-- If a function defined on a topological group has a support contained in a\ncompact set, then either the function is trivial or the group is locally compact. -/\n@[to_additive\n      \"If a function defined on a topological additive group has a support contained in a compact\n      set, then either the function is trivial or the group is locally compact.\"]\ntheorem eq_zero_or_locallyCompactSpace_of_support_subset_isCompact_of_group\n    [TopologicalSpace Î±] [Zero Î±] [T1Space Î±]\n    {f : G â†’ Î±} {k : Set G} (hk : IsCompact k) (hf : support f âŠ† k) (h'f : Continuous f) :\n    f = 0 âˆ¨ LocallyCompactSpace G := by\n  refine or_iff_not_imp_left.mpr fun h => ?_\n  simp_rw [funext_iff, Pi.zero_apply] at h\n  push_neg at h\n  obtain âŸ¨x, hxâŸ© : âˆƒ x, f x â‰  0 := h\n  have : k âˆˆ ð“ x :=\n    mem_of_superset (h'f.isOpen_support.mem_nhds hx) hf\n  exact IsCompact.locallyCompactSpace_of_mem_nhds_of_group hk this\n\n"}
{"name":"eq_zero_or_locallyCompactSpace_of_support_subset_isCompact_of_group","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\nÎ± : Type u\ninstâœâµ : TopologicalSpace G\ninstâœâ´ : Group G\ninstâœÂ³ : TopologicalGroup G\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : Zero Î±\ninstâœ : T1Space Î±\nf : G â†’ Î±\nk : Set G\nhk : IsCompact k\nhf : HasSubset.Subset (Function.support f) k\nh'f : Continuous f\nâŠ¢ Or (Eq f 0) (LocallyCompactSpace G)","decl":"/-- If a function defined on a topological group has a support contained in a\ncompact set, then either the function is trivial or the group is locally compact. -/\n@[to_additive\n      \"If a function defined on a topological additive group has a support contained in a compact\n      set, then either the function is trivial or the group is locally compact.\"]\ntheorem eq_zero_or_locallyCompactSpace_of_support_subset_isCompact_of_group\n    [TopologicalSpace Î±] [Zero Î±] [T1Space Î±]\n    {f : G â†’ Î±} {k : Set G} (hk : IsCompact k) (hf : support f âŠ† k) (h'f : Continuous f) :\n    f = 0 âˆ¨ LocallyCompactSpace G := by\n  refine or_iff_not_imp_left.mpr fun h => ?_\n  simp_rw [funext_iff, Pi.zero_apply] at h\n  push_neg at h\n  obtain âŸ¨x, hxâŸ© : âˆƒ x, f x â‰  0 := h\n  have : k âˆˆ ð“ x :=\n    mem_of_superset (h'f.isOpen_support.mem_nhds hx) hf\n  exact IsCompact.locallyCompactSpace_of_mem_nhds_of_group hk this\n\n"}
{"name":"HasCompactSupport.eq_zero_or_locallyCompactSpace_of_addGroup","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\nÎ± : Type u\ninstâœâµ : TopologicalSpace G\ninstâœâ´ : AddGroup G\ninstâœÂ³ : TopologicalAddGroup G\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : Zero Î±\ninstâœ : T1Space Î±\nf : G â†’ Î±\nhf : HasCompactSupport f\nh'f : Continuous f\nâŠ¢ Or (Eq f 0) (LocallyCompactSpace G)","decl":"/-- If a function defined on a topological group has compact support, then either\nthe function is trivial or the group is locally compact. -/\n@[to_additive\n      \"If a function defined on a topological additive group has compact support,\n      then either the function is trivial or the group is locally compact.\"]\ntheorem HasCompactSupport.eq_zero_or_locallyCompactSpace_of_group\n    [TopologicalSpace Î±] [Zero Î±] [T1Space Î±]\n    {f : G â†’ Î±} (hf : HasCompactSupport f) (h'f : Continuous f) :\n    f = 0 âˆ¨ LocallyCompactSpace G :=\n  eq_zero_or_locallyCompactSpace_of_support_subset_isCompact_of_group hf (subset_tsupport f) h'f\n\n"}
{"name":"HasCompactSupport.eq_zero_or_locallyCompactSpace_of_group","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\nÎ± : Type u\ninstâœâµ : TopologicalSpace G\ninstâœâ´ : Group G\ninstâœÂ³ : TopologicalGroup G\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : Zero Î±\ninstâœ : T1Space Î±\nf : G â†’ Î±\nhf : HasCompactSupport f\nh'f : Continuous f\nâŠ¢ Or (Eq f 0) (LocallyCompactSpace G)","decl":"/-- If a function defined on a topological group has compact support, then either\nthe function is trivial or the group is locally compact. -/\n@[to_additive\n      \"If a function defined on a topological additive group has compact support,\n      then either the function is trivial or the group is locally compact.\"]\ntheorem HasCompactSupport.eq_zero_or_locallyCompactSpace_of_group\n    [TopologicalSpace Î±] [Zero Î±] [T1Space Î±]\n    {f : G â†’ Î±} (hf : HasCompactSupport f) (h'f : Continuous f) :\n    f = 0 âˆ¨ LocallyCompactSpace G :=\n  eq_zero_or_locallyCompactSpace_of_support_subset_isCompact_of_group hf (subset_tsupport f) h'f\n\n"}
{"name":"nhds_add","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : TopologicalAddGroup G\nx y : G\nâŠ¢ Eq (nhds (HAdd.hAdd x y)) (HAdd.hAdd (nhds x) (nhds y))","decl":"@[to_additive]\ntheorem nhds_mul (x y : G) : ð“ (x * y) = ð“ x * ð“ y :=\n  calc\n    ð“ (x * y) = map (x * Â·) (map (Â· * y) (ð“ 1 * ð“ 1)) := by simp\n    _ = mapâ‚‚ (fun a b => x * (a * b * y)) (ð“ 1) (ð“ 1) := by rw [â† mapâ‚‚_mul, map_mapâ‚‚, map_mapâ‚‚]\n    _ = mapâ‚‚ (fun a b => x * a * (b * y)) (ð“ 1) (ð“ 1) := by simp only [mul_assoc]\n    _ = ð“ x * ð“ y := by\n      rw [â† map_mul_left_nhds_one x, â† map_mul_right_nhds_one y, â† mapâ‚‚_mul, mapâ‚‚_map_left,\n        mapâ‚‚_map_right]\n\n"}
{"name":"nhds_mul","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : TopologicalGroup G\nx y : G\nâŠ¢ Eq (nhds (HMul.hMul x y)) (HMul.hMul (nhds x) (nhds y))","decl":"@[to_additive]\ntheorem nhds_mul (x y : G) : ð“ (x * y) = ð“ x * ð“ y :=\n  calc\n    ð“ (x * y) = map (x * Â·) (map (Â· * y) (ð“ 1 * ð“ 1)) := by simp\n    _ = mapâ‚‚ (fun a b => x * (a * b * y)) (ð“ 1) (ð“ 1) := by rw [â† mapâ‚‚_mul, map_mapâ‚‚, map_mapâ‚‚]\n    _ = mapâ‚‚ (fun a b => x * a * (b * y)) (ð“ 1) (ð“ 1) := by simp only [mul_assoc]\n    _ = ð“ x * ð“ y := by\n      rw [â† map_mul_left_nhds_one x, â† map_mul_right_nhds_one y, â† mapâ‚‚_mul, mapâ‚‚_map_left,\n        mapâ‚‚_map_right]\n\n"}
{"name":"nhdsAddHom_apply","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : TopologicalAddGroup G\nx : G\nâŠ¢ Eq (nhdsAddHom x) (nhds x)","decl":"/-- On a topological group, `ð“ : G â†’ Filter G` can be promoted to a `MulHom`. -/\n@[to_additive (attr := simps)\n  \"On an additive topological group, `ð“ : G â†’ Filter G` can be promoted to an `AddHom`.\"]\ndef nhdsMulHom : G â†’â‚™* Filter G where\n  toFun := ð“\n  map_mul' _ _ := nhds_mul _ _\n\n"}
{"name":"nhdsMulHom_apply","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : TopologicalGroup G\nx : G\nâŠ¢ Eq (nhdsMulHom x) (nhds x)","decl":"/-- On a topological group, `ð“ : G â†’ Filter G` can be promoted to a `MulHom`. -/\n@[to_additive (attr := simps)\n  \"On an additive topological group, `ð“ : G â†’ Filter G` can be promoted to an `AddHom`.\"]\ndef nhdsMulHom : G â†’â‚™* Filter G where\n  toFun := ð“\n  map_mul' _ _ := nhds_mul _ _\n\n"}
{"name":"instTopologicalAddGroupAdditiveOfTopologicalGroup","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type u_1\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : TopologicalGroup G\nâŠ¢ TopologicalAddGroup (Additive G)","decl":"instance {G} [TopologicalSpace G] [Group G] [TopologicalGroup G] :\n    TopologicalAddGroup (Additive G) where\n  continuous_neg := @continuous_inv G _ _ _\n\n"}
{"name":"instTopologicalGroupMultiplicativeOfTopologicalAddGroup","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type u_1\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddGroup G\ninstâœ : TopologicalAddGroup G\nâŠ¢ TopologicalGroup (Multiplicative G)","decl":"instance {G} [TopologicalSpace G] [AddGroup G] [TopologicalAddGroup G] :\n    TopologicalGroup (Multiplicative G) where\n  continuous_inv := @continuous_neg G _ _ _\n\n"}
{"name":"AddUnits.isEmbedding_val","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : AddGroup G\ninstâœÂ¹ : TopologicalSpace G\ninstâœ : ContinuousNeg G\nâŠ¢ Topology.IsEmbedding AddUnits.val","decl":"@[to_additive] theorem Units.isEmbedding_val [Group G] [TopologicalSpace G] [ContinuousInv G] :\n    IsEmbedding (val : GË£ â†’ G) :=\n  toUnits_homeomorph.symm.isEmbedding\n\n"}
{"name":"Units.isEmbedding_val","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : Group G\ninstâœÂ¹ : TopologicalSpace G\ninstâœ : ContinuousInv G\nâŠ¢ Topology.IsEmbedding Units.val","decl":"@[to_additive] theorem Units.isEmbedding_val [Group G] [TopologicalSpace G] [ContinuousInv G] :\n    IsEmbedding (val : GË£ â†’ G) :=\n  toUnits_homeomorph.symm.isEmbedding\n\n"}
{"name":"Units.embedding_val","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœÂ² : Group G\ninstâœÂ¹ : TopologicalSpace G\ninstâœ : ContinuousInv G\nâŠ¢ Topology.IsEmbedding Units.val","decl":"@[deprecated (since := \"2024-10-26\")]\nalias Units.embedding_val := Units.isEmbedding_val\n\n"}
{"name":"AddUnits.instTopologicalAddGroupOfContinuousAdd","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\ninstâœÂ² : AddMonoid Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : ContinuousAdd Î±\nâŠ¢ TopologicalAddGroup (AddUnits Î±)","decl":"@[to_additive]\ninstance [ContinuousMul Î±] : TopologicalGroup Î±Ë£ where\n  continuous_inv := Units.continuous_iff.2 <| âŸ¨continuous_coe_inv, continuous_valâŸ©\n\n"}
{"name":"Units.instTopologicalGroupOfContinuousMul","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\ninstâœÂ² : Monoid Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : ContinuousMul Î±\nâŠ¢ TopologicalGroup (Units Î±)","decl":"@[to_additive]\ninstance [ContinuousMul Î±] : TopologicalGroup Î±Ë£ where\n  continuous_inv := Units.continuous_iff.2 <| âŸ¨continuous_coe_inv, continuous_valâŸ©\n\n"}
{"name":"topologicalAddGroup_sInf","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœ : AddGroup G\nts : Set (TopologicalSpace G)\nh : âˆ€ (t : TopologicalSpace G), Membership.mem ts t â†’ TopologicalAddGroup G\nâŠ¢ TopologicalAddGroup G","decl":"@[to_additive]\ntheorem topologicalGroup_sInf {ts : Set (TopologicalSpace G)}\n    (h : âˆ€ t âˆˆ ts, @TopologicalGroup G t _) : @TopologicalGroup G (sInf ts) _ :=\n  letI := sInf ts\n  { toContinuousInv :=\n      @continuousInv_sInf _ _ _ fun t ht => @TopologicalGroup.toContinuousInv G t _ <| h t ht\n    toContinuousMul :=\n      @continuousMul_sInf _ _ _ fun t ht =>\n        @TopologicalGroup.toContinuousMul G t _ <| h t ht }\n\n"}
{"name":"topologicalGroup_sInf","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœ : Group G\nts : Set (TopologicalSpace G)\nh : âˆ€ (t : TopologicalSpace G), Membership.mem ts t â†’ TopologicalGroup G\nâŠ¢ TopologicalGroup G","decl":"@[to_additive]\ntheorem topologicalGroup_sInf {ts : Set (TopologicalSpace G)}\n    (h : âˆ€ t âˆˆ ts, @TopologicalGroup G t _) : @TopologicalGroup G (sInf ts) _ :=\n  letI := sInf ts\n  { toContinuousInv :=\n      @continuousInv_sInf _ _ _ fun t ht => @TopologicalGroup.toContinuousInv G t _ <| h t ht\n    toContinuousMul :=\n      @continuousMul_sInf _ _ _ fun t ht =>\n        @TopologicalGroup.toContinuousMul G t _ <| h t ht }\n\n"}
{"name":"topologicalGroup_iInf","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\nÎ¹ : Sort u_1\ninstâœ : Group G\nts' : Î¹ â†’ TopologicalSpace G\nh' : âˆ€ (i : Î¹), TopologicalGroup G\nâŠ¢ TopologicalGroup G","decl":"@[to_additive]\ntheorem topologicalGroup_iInf {ts' : Î¹ â†’ TopologicalSpace G}\n    (h' : âˆ€ i, @TopologicalGroup G (ts' i) _) : @TopologicalGroup G (â¨… i, ts' i) _ := by\n  rw [â† sInf_range]\n  exact topologicalGroup_sInf (Set.forall_mem_range.mpr h')\n\n"}
{"name":"topologicalAddGroup_iInf","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\nÎ¹ : Sort u_1\ninstâœ : AddGroup G\nts' : Î¹ â†’ TopologicalSpace G\nh' : âˆ€ (i : Î¹), TopologicalAddGroup G\nâŠ¢ TopologicalAddGroup G","decl":"@[to_additive]\ntheorem topologicalGroup_iInf {ts' : Î¹ â†’ TopologicalSpace G}\n    (h' : âˆ€ i, @TopologicalGroup G (ts' i) _) : @TopologicalGroup G (â¨… i, ts' i) _ := by\n  rw [â† sInf_range]\n  exact topologicalGroup_sInf (Set.forall_mem_range.mpr h')\n\n"}
{"name":"topologicalAddGroup_inf","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœ : AddGroup G\ntâ‚ tâ‚‚ : TopologicalSpace G\nhâ‚ : TopologicalAddGroup G\nhâ‚‚ : TopologicalAddGroup G\nâŠ¢ TopologicalAddGroup G","decl":"@[to_additive]\ntheorem topologicalGroup_inf {tâ‚ tâ‚‚ : TopologicalSpace G} (hâ‚ : @TopologicalGroup G tâ‚ _)\n    (hâ‚‚ : @TopologicalGroup G tâ‚‚ _) : @TopologicalGroup G (tâ‚ âŠ“ tâ‚‚) _ := by\n  rw [inf_eq_iInf]\n  refine topologicalGroup_iInf fun b => ?_\n  cases b <;> assumption\n\n"}
{"name":"topologicalGroup_inf","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"G : Type w\ninstâœ : Group G\ntâ‚ tâ‚‚ : TopologicalSpace G\nhâ‚ : TopologicalGroup G\nhâ‚‚ : TopologicalGroup G\nâŠ¢ TopologicalGroup G","decl":"@[to_additive]\ntheorem topologicalGroup_inf {tâ‚ tâ‚‚ : TopologicalSpace G} (hâ‚ : @TopologicalGroup G tâ‚ _)\n    (hâ‚‚ : @TopologicalGroup G tâ‚‚ _) : @TopologicalGroup G (tâ‚ âŠ“ tâ‚‚) _ := by\n  rw [inf_eq_iInf]\n  refine topologicalGroup_iInf fun b => ?_\n  cases b <;> assumption\n\n"}
{"name":"GroupTopology.mk.sizeOf_spec","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\ninstâœÂ¹ : Group Î±\ninstâœ : SizeOf Î±\ntoTopologicalSpace : TopologicalSpace Î±\ntoTopologicalGroup : TopologicalGroup Î±\nâŠ¢ Eq (SizeOf.sizeOf { toTopologicalSpace := toTopologicalSpace, toTopologicalGroup := toTopologicalGroup }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toTopologicalSpace)) (SizeOf.sizeOf toTopologicalGroup))","decl":"/-- A group topology on a group `Î±` is a topology for which multiplication and inversion\nare continuous. -/\nstructure GroupTopology (Î± : Type u) [Group Î±] extends TopologicalSpace Î±, TopologicalGroup Î± :\n  Type u\n\n"}
{"name":"GroupTopology.toTopologicalGroup","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\ninstâœ : Group Î±\nself : GroupTopology Î±\nâŠ¢ TopologicalGroup Î±","decl":"/-- A group topology on a group `Î±` is a topology for which multiplication and inversion\nare continuous. -/\nstructure GroupTopology (Î± : Type u) [Group Î±] extends TopologicalSpace Î±, TopologicalGroup Î± :\n  Type u\n\n"}
{"name":"GroupTopology.mk.injEq","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\ninstâœ : Group Î±\ntoTopologicalSpaceâœ : TopologicalSpace Î±\ntoTopologicalGroupâœ : TopologicalGroup Î±\ntoTopologicalSpace : TopologicalSpace Î±\ntoTopologicalGroup : TopologicalGroup Î±\nâŠ¢ Eq (Eq { toTopologicalSpace := toTopologicalSpaceâœ, toTopologicalGroup := toTopologicalGroupâœ } { toTopologicalSpace := toTopologicalSpace, toTopologicalGroup := toTopologicalGroup }) (Eq toTopologicalSpaceâœ toTopologicalSpace)","decl":"/-- A group topology on a group `Î±` is a topology for which multiplication and inversion\nare continuous. -/\nstructure GroupTopology (Î± : Type u) [Group Î±] extends TopologicalSpace Î±, TopologicalGroup Î± :\n  Type u\n\n"}
{"name":"GroupTopology.mk.inj","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\ninstâœ : Group Î±\ntoTopologicalSpaceâœ : TopologicalSpace Î±\ntoTopologicalGroupâœ : TopologicalGroup Î±\ntoTopologicalSpace : TopologicalSpace Î±\ntoTopologicalGroup : TopologicalGroup Î±\nxâœ : Eq { toTopologicalSpace := toTopologicalSpaceâœ, toTopologicalGroup := toTopologicalGroupâœ } { toTopologicalSpace := toTopologicalSpace, toTopologicalGroup := toTopologicalGroup }\nâŠ¢ Eq toTopologicalSpaceâœ toTopologicalSpace","decl":"/-- A group topology on a group `Î±` is a topology for which multiplication and inversion\nare continuous. -/\nstructure GroupTopology (Î± : Type u) [Group Î±] extends TopologicalSpace Î±, TopologicalGroup Î± :\n  Type u\n\n"}
{"name":"AddGroupTopology.mk.inj","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\ninstâœ : AddGroup Î±\ntoTopologicalSpaceâœ : TopologicalSpace Î±\ntoTopologicalAddGroupâœ : TopologicalAddGroup Î±\ntoTopologicalSpace : TopologicalSpace Î±\ntoTopologicalAddGroup : TopologicalAddGroup Î±\nxâœ : Eq { toTopologicalSpace := toTopologicalSpaceâœ, toTopologicalAddGroup := toTopologicalAddGroupâœ } { toTopologicalSpace := toTopologicalSpace, toTopologicalAddGroup := toTopologicalAddGroup }\nâŠ¢ Eq toTopologicalSpaceâœ toTopologicalSpace","decl":"/-- An additive group topology on an additive group `Î±` is a topology for which addition and\n  negation are continuous. -/\nstructure AddGroupTopology (Î± : Type u) [AddGroup Î±] extends TopologicalSpace Î±,\n  TopologicalAddGroup Î± : Type u\n\n"}
{"name":"AddGroupTopology.mk.injEq","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\ninstâœ : AddGroup Î±\ntoTopologicalSpaceâœ : TopologicalSpace Î±\ntoTopologicalAddGroupâœ : TopologicalAddGroup Î±\ntoTopologicalSpace : TopologicalSpace Î±\ntoTopologicalAddGroup : TopologicalAddGroup Î±\nâŠ¢ Eq (Eq { toTopologicalSpace := toTopologicalSpaceâœ, toTopologicalAddGroup := toTopologicalAddGroupâœ } { toTopologicalSpace := toTopologicalSpace, toTopologicalAddGroup := toTopologicalAddGroup }) (Eq toTopologicalSpaceâœ toTopologicalSpace)","decl":"/-- An additive group topology on an additive group `Î±` is a topology for which addition and\n  negation are continuous. -/\nstructure AddGroupTopology (Î± : Type u) [AddGroup Î±] extends TopologicalSpace Î±,\n  TopologicalAddGroup Î± : Type u\n\n"}
{"name":"AddGroupTopology.toTopologicalAddGroup","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\ninstâœ : AddGroup Î±\nself : AddGroupTopology Î±\nâŠ¢ TopologicalAddGroup Î±","decl":"/-- An additive group topology on an additive group `Î±` is a topology for which addition and\n  negation are continuous. -/\nstructure AddGroupTopology (Î± : Type u) [AddGroup Î±] extends TopologicalSpace Î±,\n  TopologicalAddGroup Î± : Type u\n\n"}
{"name":"AddGroupTopology.mk.sizeOf_spec","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\ninstâœÂ¹ : AddGroup Î±\ninstâœ : SizeOf Î±\ntoTopologicalSpace : TopologicalSpace Î±\ntoTopologicalAddGroup : TopologicalAddGroup Î±\nâŠ¢ Eq (SizeOf.sizeOf { toTopologicalSpace := toTopologicalSpace, toTopologicalAddGroup := toTopologicalAddGroup }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toTopologicalSpace)) (SizeOf.sizeOf toTopologicalAddGroup))","decl":"/-- An additive group topology on an additive group `Î±` is a topology for which addition and\n  negation are continuous. -/\nstructure AddGroupTopology (Î± : Type u) [AddGroup Î±] extends TopologicalSpace Î±,\n  TopologicalAddGroup Î± : Type u\n\n"}
{"name":"GroupTopology.continuous_mul'","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\ninstâœ : Group Î±\ng : GroupTopology Î±\nâŠ¢ Continuous fun p => HMul.hMul p.1 p.2","decl":"/-- A version of the global `continuous_mul` suitable for dot notation. -/\n@[to_additive \"A version of the global `continuous_add` suitable for dot notation.\"]\ntheorem continuous_mul' (g : GroupTopology Î±) :\n    haveI := g.toTopologicalSpace\n    Continuous fun p : Î± Ã— Î± => p.1 * p.2 := by\n  letI := g.toTopologicalSpace\n  haveI := g.toTopologicalGroup\n  exact continuous_mul\n\n"}
{"name":"AddGroupTopology.continuous_add'","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\ninstâœ : AddGroup Î±\ng : AddGroupTopology Î±\nâŠ¢ Continuous fun p => HAdd.hAdd p.1 p.2","decl":"/-- A version of the global `continuous_mul` suitable for dot notation. -/\n@[to_additive \"A version of the global `continuous_add` suitable for dot notation.\"]\ntheorem continuous_mul' (g : GroupTopology Î±) :\n    haveI := g.toTopologicalSpace\n    Continuous fun p : Î± Ã— Î± => p.1 * p.2 := by\n  letI := g.toTopologicalSpace\n  haveI := g.toTopologicalGroup\n  exact continuous_mul\n\n"}
{"name":"GroupTopology.continuous_inv'","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\ninstâœ : Group Î±\ng : GroupTopology Î±\nâŠ¢ Continuous Inv.inv","decl":"/-- A version of the global `continuous_inv` suitable for dot notation. -/\n@[to_additive \"A version of the global `continuous_neg` suitable for dot notation.\"]\ntheorem continuous_inv' (g : GroupTopology Î±) :\n    haveI := g.toTopologicalSpace\n    Continuous (Inv.inv : Î± â†’ Î±) := by\n  letI := g.toTopologicalSpace\n  haveI := g.toTopologicalGroup\n  exact continuous_inv\n\n"}
{"name":"AddGroupTopology.continuous_neg'","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\ninstâœ : AddGroup Î±\ng : AddGroupTopology Î±\nâŠ¢ Continuous Neg.neg","decl":"/-- A version of the global `continuous_inv` suitable for dot notation. -/\n@[to_additive \"A version of the global `continuous_neg` suitable for dot notation.\"]\ntheorem continuous_inv' (g : GroupTopology Î±) :\n    haveI := g.toTopologicalSpace\n    Continuous (Inv.inv : Î± â†’ Î±) := by\n  letI := g.toTopologicalSpace\n  haveI := g.toTopologicalGroup\n  exact continuous_inv\n\n"}
{"name":"AddGroupTopology.toTopologicalSpace_injective","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\ninstâœ : AddGroup Î±\nâŠ¢ Function.Injective AddGroupTopology.toTopologicalSpace","decl":"@[to_additive]\ntheorem toTopologicalSpace_injective :\n    Function.Injective (toTopologicalSpace : GroupTopology Î± â†’ TopologicalSpace Î±) :=\n  fun f g h => by\n    cases f\n    cases g\n    congr\n\n"}
{"name":"GroupTopology.toTopologicalSpace_injective","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\ninstâœ : Group Î±\nâŠ¢ Function.Injective GroupTopology.toTopologicalSpace","decl":"@[to_additive]\ntheorem toTopologicalSpace_injective :\n    Function.Injective (toTopologicalSpace : GroupTopology Î± â†’ TopologicalSpace Î±) :=\n  fun f g h => by\n    cases f\n    cases g\n    congr\n\n"}
{"name":"GroupTopology.ext'_iff","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\ninstâœ : Group Î±\nf g : GroupTopology Î±\nâŠ¢ Iff (Eq f g) (Eq TopologicalSpace.IsOpen TopologicalSpace.IsOpen)","decl":"@[to_additive (attr := ext)]\ntheorem ext' {f g : GroupTopology Î±} (h : f.IsOpen = g.IsOpen) : f = g :=\n  toTopologicalSpace_injective <| TopologicalSpace.ext h\n\n"}
{"name":"AddGroupTopology.ext'","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\ninstâœ : AddGroup Î±\nf g : AddGroupTopology Î±\nh : Eq TopologicalSpace.IsOpen TopologicalSpace.IsOpen\nâŠ¢ Eq f g","decl":"@[to_additive (attr := ext)]\ntheorem ext' {f g : GroupTopology Î±} (h : f.IsOpen = g.IsOpen) : f = g :=\n  toTopologicalSpace_injective <| TopologicalSpace.ext h\n\n"}
{"name":"AddGroupTopology.ext'_iff","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\ninstâœ : AddGroup Î±\nf g : AddGroupTopology Î±\nâŠ¢ Iff (Eq f g) (Eq TopologicalSpace.IsOpen TopologicalSpace.IsOpen)","decl":"@[to_additive (attr := ext)]\ntheorem ext' {f g : GroupTopology Î±} (h : f.IsOpen = g.IsOpen) : f = g :=\n  toTopologicalSpace_injective <| TopologicalSpace.ext h\n\n"}
{"name":"GroupTopology.ext'","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\ninstâœ : Group Î±\nf g : GroupTopology Î±\nh : Eq TopologicalSpace.IsOpen TopologicalSpace.IsOpen\nâŠ¢ Eq f g","decl":"@[to_additive (attr := ext)]\ntheorem ext' {f g : GroupTopology Î±} (h : f.IsOpen = g.IsOpen) : f = g :=\n  toTopologicalSpace_injective <| TopologicalSpace.ext h\n\n"}
{"name":"AddGroupTopology.toTopologicalSpace_le","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\ninstâœ : AddGroup Î±\nx y : AddGroupTopology Î±\nâŠ¢ Iff (LE.le x.toTopologicalSpace y.toTopologicalSpace) (LE.le x y)","decl":"@[to_additive (attr := simp)]\ntheorem toTopologicalSpace_le {x y : GroupTopology Î±} :\n    x.toTopologicalSpace â‰¤ y.toTopologicalSpace â†” x â‰¤ y :=\n  Iff.rfl\n\n"}
{"name":"GroupTopology.toTopologicalSpace_le","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\ninstâœ : Group Î±\nx y : GroupTopology Î±\nâŠ¢ Iff (LE.le x.toTopologicalSpace y.toTopologicalSpace) (LE.le x y)","decl":"@[to_additive (attr := simp)]\ntheorem toTopologicalSpace_le {x y : GroupTopology Î±} :\n    x.toTopologicalSpace â‰¤ y.toTopologicalSpace â†” x â‰¤ y :=\n  Iff.rfl\n\n"}
{"name":"AddGroupTopology.toTopologicalSpace_top","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\ninstâœ : AddGroup Î±\nâŠ¢ Eq Top.top.toTopologicalSpace Top.top","decl":"@[to_additive (attr := simp)]\ntheorem toTopologicalSpace_top : (âŠ¤ : GroupTopology Î±).toTopologicalSpace = âŠ¤ :=\n  rfl\n\n"}
{"name":"GroupTopology.toTopologicalSpace_top","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\ninstâœ : Group Î±\nâŠ¢ Eq Top.top.toTopologicalSpace Top.top","decl":"@[to_additive (attr := simp)]\ntheorem toTopologicalSpace_top : (âŠ¤ : GroupTopology Î±).toTopologicalSpace = âŠ¤ :=\n  rfl\n\n"}
{"name":"GroupTopology.toTopologicalSpace_bot","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\ninstâœ : Group Î±\nâŠ¢ Eq Bot.bot.toTopologicalSpace Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem toTopologicalSpace_bot : (âŠ¥ : GroupTopology Î±).toTopologicalSpace = âŠ¥ :=\n  rfl\n\n"}
{"name":"AddGroupTopology.toTopologicalSpace_bot","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\ninstâœ : AddGroup Î±\nâŠ¢ Eq Bot.bot.toTopologicalSpace Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem toTopologicalSpace_bot : (âŠ¥ : GroupTopology Î±).toTopologicalSpace = âŠ¥ :=\n  rfl\n\n"}
{"name":"GroupTopology.toTopologicalSpace_inf","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\ninstâœ : Group Î±\nx y : GroupTopology Î±\nâŠ¢ Eq (Min.min x y).toTopologicalSpace (Min.min x.toTopologicalSpace y.toTopologicalSpace)","decl":"@[to_additive (attr := simp)]\ntheorem toTopologicalSpace_inf (x y : GroupTopology Î±) :\n    (x âŠ“ y).toTopologicalSpace = x.toTopologicalSpace âŠ“ y.toTopologicalSpace :=\n  rfl\n\n"}
{"name":"AddGroupTopology.toTopologicalSpace_inf","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\ninstâœ : AddGroup Î±\nx y : AddGroupTopology Î±\nâŠ¢ Eq (Min.min x y).toTopologicalSpace (Min.min x.toTopologicalSpace y.toTopologicalSpace)","decl":"@[to_additive (attr := simp)]\ntheorem toTopologicalSpace_inf (x y : GroupTopology Î±) :\n    (x âŠ“ y).toTopologicalSpace = x.toTopologicalSpace âŠ“ y.toTopologicalSpace :=\n  rfl\n\n"}
{"name":"GroupTopology.toTopologicalSpace_sInf","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\ninstâœ : Group Î±\ns : Set (GroupTopology Î±)\nâŠ¢ Eq (InfSet.sInf s).toTopologicalSpace (InfSet.sInf (Set.image GroupTopology.toTopologicalSpace s))","decl":"@[to_additive (attr := simp)]\ntheorem toTopologicalSpace_sInf (s : Set (GroupTopology Î±)) :\n    (sInf s).toTopologicalSpace = sInf (toTopologicalSpace '' s) := rfl\n\n"}
{"name":"AddGroupTopology.toTopologicalSpace_sInf","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\ninstâœ : AddGroup Î±\ns : Set (AddGroupTopology Î±)\nâŠ¢ Eq (InfSet.sInf s).toTopologicalSpace (InfSet.sInf (Set.image AddGroupTopology.toTopologicalSpace s))","decl":"@[to_additive (attr := simp)]\ntheorem toTopologicalSpace_sInf (s : Set (GroupTopology Î±)) :\n    (sInf s).toTopologicalSpace = sInf (toTopologicalSpace '' s) := rfl\n\n"}
{"name":"GroupTopology.toTopologicalSpace_iInf","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\ninstâœ : Group Î±\nÎ¹ : Sort u_1\ns : Î¹ â†’ GroupTopology Î±\nâŠ¢ Eq (iInf fun i => s i).toTopologicalSpace (iInf fun i => (s i).toTopologicalSpace)","decl":"@[to_additive (attr := simp)]\ntheorem toTopologicalSpace_iInf {Î¹} (s : Î¹ â†’ GroupTopology Î±) :\n    (â¨… i, s i).toTopologicalSpace = â¨… i, (s i).toTopologicalSpace :=\n  congr_arg sInf (range_comp _ _).symm\n\n"}
{"name":"AddGroupTopology.toTopologicalSpace_iInf","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u\ninstâœ : AddGroup Î±\nÎ¹ : Sort u_1\ns : Î¹ â†’ AddGroupTopology Î±\nâŠ¢ Eq (iInf fun i => s i).toTopologicalSpace (iInf fun i => (s i).toTopologicalSpace)","decl":"@[to_additive (attr := simp)]\ntheorem toTopologicalSpace_iInf {Î¹} (s : Î¹ â†’ GroupTopology Î±) :\n    (â¨… i, s i).toTopologicalSpace = â¨… i, (s i).toTopologicalSpace :=\n  congr_arg sInf (range_comp _ _).symm\n\n"}
{"name":"AddGroupTopology.coinduced_continuous","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nt : TopologicalSpace Î±\ninstâœ : AddGroup Î²\nf : Î± â†’ Î²\nâŠ¢ Continuous f","decl":"@[to_additive]\ntheorem coinduced_continuous {Î± Î² : Type*} [t : TopologicalSpace Î±] [Group Î²] (f : Î± â†’ Î²) :\n    Continuous[t, (coinduced f).toTopologicalSpace] f := by\n  rw [continuous_sInf_rng]\n  rintro _ âŸ¨t', ht', rflâŸ©\n  exact continuous_iff_coinduced_le.2 ht'\n\n"}
{"name":"GroupTopology.coinduced_continuous","module":"Mathlib.Topology.Algebra.Group.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nt : TopologicalSpace Î±\ninstâœ : Group Î²\nf : Î± â†’ Î²\nâŠ¢ Continuous f","decl":"@[to_additive]\ntheorem coinduced_continuous {Î± Î² : Type*} [t : TopologicalSpace Î±] [Group Î²] (f : Î± â†’ Î²) :\n    Continuous[t, (coinduced f).toTopologicalSpace] f := by\n  rw [continuous_sInf_rng]\n  rintro _ âŸ¨t', ht', rflâŸ©\n  exact continuous_iff_coinduced_le.2 ht'\n\n"}
