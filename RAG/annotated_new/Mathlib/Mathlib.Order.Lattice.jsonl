{"name":"SemilatticeSup.sup_le","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\nself : SemilatticeSup α\na b c : α\na✝¹ : LE.le a c\na✝ : LE.le b c\n⊢ LE.le (SemilatticeSup.sup a b) c","decl":"/-- A `SemilatticeSup` is a join-semilattice, that is, a partial order\n  with a join (a.k.a. lub / least upper bound, sup / supremum) operation\n  `⊔` which is the least element larger than both factors. -/\nclass SemilatticeSup (α : Type u) extends PartialOrder α where\n  /-- The binary supremum, used to derive `Max α` -/\n  sup : α → α → α\n  /-- The supremum is an upper bound on the first argument -/\n  protected le_sup_left : ∀ a b : α, a ≤ sup a b\n  /-- The supremum is an upper bound on the second argument -/\n  protected le_sup_right : ∀ a b : α, b ≤ sup a b\n  /-- The supremum is the *least* upper bound -/\n  protected sup_le : ∀ a b c : α, a ≤ c → b ≤ c → sup a b ≤ c\n\n"}
{"name":"SemilatticeSup.le_sup_right","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\nself : SemilatticeSup α\na b : α\n⊢ LE.le b (SemilatticeSup.sup a b)","decl":"/-- A `SemilatticeSup` is a join-semilattice, that is, a partial order\n  with a join (a.k.a. lub / least upper bound, sup / supremum) operation\n  `⊔` which is the least element larger than both factors. -/\nclass SemilatticeSup (α : Type u) extends PartialOrder α where\n  /-- The binary supremum, used to derive `Max α` -/\n  sup : α → α → α\n  /-- The supremum is an upper bound on the first argument -/\n  protected le_sup_left : ∀ a b : α, a ≤ sup a b\n  /-- The supremum is an upper bound on the second argument -/\n  protected le_sup_right : ∀ a b : α, b ≤ sup a b\n  /-- The supremum is the *least* upper bound -/\n  protected sup_le : ∀ a b c : α, a ≤ c → b ≤ c → sup a b ≤ c\n\n"}
{"name":"SemilatticeSup.le_sup_left","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\nself : SemilatticeSup α\na b : α\n⊢ LE.le a (SemilatticeSup.sup a b)","decl":"/-- A `SemilatticeSup` is a join-semilattice, that is, a partial order\n  with a join (a.k.a. lub / least upper bound, sup / supremum) operation\n  `⊔` which is the least element larger than both factors. -/\nclass SemilatticeSup (α : Type u) extends PartialOrder α where\n  /-- The binary supremum, used to derive `Max α` -/\n  sup : α → α → α\n  /-- The supremum is an upper bound on the first argument -/\n  protected le_sup_left : ∀ a b : α, a ≤ sup a b\n  /-- The supremum is an upper bound on the second argument -/\n  protected le_sup_right : ∀ a b : α, b ≤ sup a b\n  /-- The supremum is the *least* upper bound -/\n  protected sup_le : ∀ a b c : α, a ≤ c → b ≤ c → sup a b ≤ c\n\n"}
{"name":"le_sup_left","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeSup α\na b : α\n⊢ LE.le a (Max.max a b)","decl":"@[simp]\ntheorem le_sup_left : a ≤ a ⊔ b :=\n  SemilatticeSup.le_sup_left a b\n\n"}
{"name":"le_sup_right","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeSup α\na b : α\n⊢ LE.le b (Max.max a b)","decl":"@[simp]\ntheorem le_sup_right : b ≤ a ⊔ b :=\n  SemilatticeSup.le_sup_right a b\n\n"}
{"name":"le_sup_of_le_left","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeSup α\na b c : α\nh : LE.le c a\n⊢ LE.le c (Max.max a b)","decl":"theorem le_sup_of_le_left (h : c ≤ a) : c ≤ a ⊔ b :=\n  le_trans h le_sup_left\n\n"}
{"name":"le_sup_of_le_right","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeSup α\na b c : α\nh : LE.le c b\n⊢ LE.le c (Max.max a b)","decl":"theorem le_sup_of_le_right (h : c ≤ b) : c ≤ a ⊔ b :=\n  le_trans h le_sup_right\n\n"}
{"name":"lt_sup_of_lt_left","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeSup α\na b c : α\nh : LT.lt c a\n⊢ LT.lt c (Max.max a b)","decl":"theorem lt_sup_of_lt_left (h : c < a) : c < a ⊔ b :=\n  h.trans_le le_sup_left\n\n"}
{"name":"lt_sup_of_lt_right","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeSup α\na b c : α\nh : LT.lt c b\n⊢ LT.lt c (Max.max a b)","decl":"theorem lt_sup_of_lt_right (h : c < b) : c < a ⊔ b :=\n  h.trans_le le_sup_right\n\n"}
{"name":"sup_le","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeSup α\na b c : α\na✝¹ : LE.le a c\na✝ : LE.le b c\n⊢ LE.le (Max.max a b) c","decl":"theorem sup_le : a ≤ c → b ≤ c → a ⊔ b ≤ c :=\n  SemilatticeSup.sup_le a b c\n\n"}
{"name":"sup_le_iff","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeSup α\na b c : α\n⊢ Iff (LE.le (Max.max a b) c) (And (LE.le a c) (LE.le b c))","decl":"@[simp]\ntheorem sup_le_iff : a ⊔ b ≤ c ↔ a ≤ c ∧ b ≤ c :=\n  ⟨fun h : a ⊔ b ≤ c => ⟨le_trans le_sup_left h, le_trans le_sup_right h⟩,\n   fun ⟨h₁, h₂⟩ => sup_le h₁ h₂⟩\n\n"}
{"name":"sup_eq_left","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeSup α\na b : α\n⊢ Iff (Eq (Max.max a b) a) (LE.le b a)","decl":"@[simp]\ntheorem sup_eq_left : a ⊔ b = a ↔ b ≤ a :=\n  le_antisymm_iff.trans <| by simp [le_rfl]\n\n"}
{"name":"sup_eq_right","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeSup α\na b : α\n⊢ Iff (Eq (Max.max a b) b) (LE.le a b)","decl":"@[simp]\ntheorem sup_eq_right : a ⊔ b = b ↔ a ≤ b :=\n  le_antisymm_iff.trans <| by simp [le_rfl]\n\n"}
{"name":"left_eq_sup","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeSup α\na b : α\n⊢ Iff (Eq a (Max.max a b)) (LE.le b a)","decl":"@[simp]\ntheorem left_eq_sup : a = a ⊔ b ↔ b ≤ a :=\n  eq_comm.trans sup_eq_left\n\n"}
{"name":"right_eq_sup","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeSup α\na b : α\n⊢ Iff (Eq b (Max.max a b)) (LE.le a b)","decl":"@[simp]\ntheorem right_eq_sup : b = a ⊔ b ↔ a ≤ b :=\n  eq_comm.trans sup_eq_right\n\n"}
{"name":"sup_of_le_left","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeSup α\na b : α\na✝ : LE.le b a\n⊢ Eq (Max.max a b) a","decl":"alias ⟨_, sup_of_le_left⟩ := sup_eq_left\n\n"}
{"name":"le_of_sup_eq","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeSup α\na b : α\na✝ : Eq (Max.max a b) b\n⊢ LE.le a b","decl":"alias ⟨le_of_sup_eq, sup_of_le_right⟩ := sup_eq_right\n\n"}
{"name":"sup_of_le_right","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeSup α\na b : α\na✝ : LE.le a b\n⊢ Eq (Max.max a b) b","decl":"alias ⟨le_of_sup_eq, sup_of_le_right⟩ := sup_eq_right\n\n"}
{"name":"left_lt_sup","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeSup α\na b : α\n⊢ Iff (LT.lt a (Max.max a b)) (Not (LE.le b a))","decl":"@[simp]\ntheorem left_lt_sup : a < a ⊔ b ↔ ¬b ≤ a :=\n  le_sup_left.lt_iff_ne.trans <| not_congr left_eq_sup\n\n"}
{"name":"right_lt_sup","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeSup α\na b : α\n⊢ Iff (LT.lt b (Max.max a b)) (Not (LE.le a b))","decl":"@[simp]\ntheorem right_lt_sup : b < a ⊔ b ↔ ¬a ≤ b :=\n  le_sup_right.lt_iff_ne.trans <| not_congr right_eq_sup\n\n"}
{"name":"left_or_right_lt_sup","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeSup α\na b : α\nh : Ne a b\n⊢ Or (LT.lt a (Max.max a b)) (LT.lt b (Max.max a b))","decl":"theorem left_or_right_lt_sup (h : a ≠ b) : a < a ⊔ b ∨ b < a ⊔ b :=\n  h.not_le_or_not_le.symm.imp left_lt_sup.2 right_lt_sup.2\n\n"}
{"name":"le_iff_exists_sup","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeSup α\na b : α\n⊢ Iff (LE.le a b) (Exists fun c => Eq b (Max.max a c))","decl":"theorem le_iff_exists_sup : a ≤ b ↔ ∃ c, b = a ⊔ c := by\n  constructor\n  · intro h\n    exact ⟨b, (sup_eq_right.mpr h).symm⟩\n  · rintro ⟨c, rfl : _ = _ ⊔ _⟩\n    exact le_sup_left\n\n"}
{"name":"sup_le_sup","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeSup α\na b c d : α\nh₁ : LE.le a b\nh₂ : LE.le c d\n⊢ LE.le (Max.max a c) (Max.max b d)","decl":"@[gcongr]\ntheorem sup_le_sup (h₁ : a ≤ b) (h₂ : c ≤ d) : a ⊔ c ≤ b ⊔ d :=\n  sup_le (le_sup_of_le_left h₁) (le_sup_of_le_right h₂)\n\n"}
{"name":"sup_le_sup_left","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeSup α\na b : α\nh₁ : LE.le a b\nc : α\n⊢ LE.le (Max.max c a) (Max.max c b)","decl":"@[gcongr]\ntheorem sup_le_sup_left (h₁ : a ≤ b) (c) : c ⊔ a ≤ c ⊔ b :=\n  sup_le_sup le_rfl h₁\n\n"}
{"name":"sup_le_sup_right","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeSup α\na b : α\nh₁ : LE.le a b\nc : α\n⊢ LE.le (Max.max a c) (Max.max b c)","decl":"@[gcongr]\ntheorem sup_le_sup_right (h₁ : a ≤ b) (c) : a ⊔ c ≤ b ⊔ c :=\n  sup_le_sup h₁ le_rfl\n\n"}
{"name":"sup_idem","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeSup α\na : α\n⊢ Eq (Max.max a a) a","decl":"theorem sup_idem (a : α) : a ⊔ a = a := by simp\n\n"}
{"name":"instIdempotentOpMax","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeSup α\n⊢ Std.IdempotentOp fun x1 x2 => Max.max x1 x2","decl":"instance : Std.IdempotentOp (α := α) (· ⊔ ·) := ⟨sup_idem⟩\n\n"}
{"name":"sup_comm","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeSup α\na b : α\n⊢ Eq (Max.max a b) (Max.max b a)","decl":"theorem sup_comm (a b : α) : a ⊔ b = b ⊔ a := by apply le_antisymm <;> simp\n\n"}
{"name":"instCommutativeMax","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeSup α\n⊢ Std.Commutative fun x1 x2 => Max.max x1 x2","decl":"instance : Std.Commutative (α := α) (· ⊔ ·) := ⟨sup_comm⟩\n\n"}
{"name":"sup_assoc","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeSup α\na b c : α\n⊢ Eq (Max.max (Max.max a b) c) (Max.max a (Max.max b c))","decl":"theorem sup_assoc (a b c : α) : a ⊔ b ⊔ c = a ⊔ (b ⊔ c) :=\n  eq_of_forall_ge_iff fun x => by simp only [sup_le_iff]; rw [and_assoc]\n\n"}
{"name":"instAssociativeMax","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeSup α\n⊢ Std.Associative fun x1 x2 => Max.max x1 x2","decl":"instance : Std.Associative (α := α) (· ⊔ ·) := ⟨sup_assoc⟩\n\n"}
{"name":"sup_left_right_swap","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeSup α\na b c : α\n⊢ Eq (Max.max (Max.max a b) c) (Max.max (Max.max c b) a)","decl":"theorem sup_left_right_swap (a b c : α) : a ⊔ b ⊔ c = c ⊔ b ⊔ a := by\n  rw [sup_comm, sup_comm a, sup_assoc]\n\n"}
{"name":"sup_left_idem","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeSup α\na b : α\n⊢ Eq (Max.max a (Max.max a b)) (Max.max a b)","decl":"theorem sup_left_idem (a b : α) : a ⊔ (a ⊔ b) = a ⊔ b := by simp\n\n"}
{"name":"sup_right_idem","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeSup α\na b : α\n⊢ Eq (Max.max (Max.max a b) b) (Max.max a b)","decl":"theorem sup_right_idem (a b : α) : a ⊔ b ⊔ b = a ⊔ b := by simp\n\n"}
{"name":"sup_left_comm","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeSup α\na b c : α\n⊢ Eq (Max.max a (Max.max b c)) (Max.max b (Max.max a c))","decl":"theorem sup_left_comm (a b c : α) : a ⊔ (b ⊔ c) = b ⊔ (a ⊔ c) := by\n  rw [← sup_assoc, ← sup_assoc, @sup_comm α _ a]\n\n"}
{"name":"sup_right_comm","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeSup α\na b c : α\n⊢ Eq (Max.max (Max.max a b) c) (Max.max (Max.max a c) b)","decl":"theorem sup_right_comm (a b c : α) : a ⊔ b ⊔ c = a ⊔ c ⊔ b := by\n  rw [sup_assoc, sup_assoc, sup_comm b]\n\n"}
{"name":"sup_sup_sup_comm","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeSup α\na b c d : α\n⊢ Eq (Max.max (Max.max a b) (Max.max c d)) (Max.max (Max.max a c) (Max.max b d))","decl":"theorem sup_sup_sup_comm (a b c d : α) : a ⊔ b ⊔ (c ⊔ d) = a ⊔ c ⊔ (b ⊔ d) := by\n  rw [sup_assoc, sup_left_comm b, ← sup_assoc]\n\n"}
{"name":"sup_sup_distrib_left","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeSup α\na b c : α\n⊢ Eq (Max.max a (Max.max b c)) (Max.max (Max.max a b) (Max.max a c))","decl":"theorem sup_sup_distrib_left (a b c : α) : a ⊔ (b ⊔ c) = a ⊔ b ⊔ (a ⊔ c) := by\n  rw [sup_sup_sup_comm, sup_idem]\n\n"}
{"name":"sup_sup_distrib_right","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeSup α\na b c : α\n⊢ Eq (Max.max (Max.max a b) c) (Max.max (Max.max a c) (Max.max b c))","decl":"theorem sup_sup_distrib_right (a b c : α) : a ⊔ b ⊔ c = a ⊔ c ⊔ (b ⊔ c) := by\n  rw [sup_sup_sup_comm, sup_idem]\n\n"}
{"name":"sup_congr_left","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeSup α\na b c : α\nhb : LE.le b (Max.max a c)\nhc : LE.le c (Max.max a b)\n⊢ Eq (Max.max a b) (Max.max a c)","decl":"theorem sup_congr_left (hb : b ≤ a ⊔ c) (hc : c ≤ a ⊔ b) : a ⊔ b = a ⊔ c :=\n  (sup_le le_sup_left hb).antisymm <| sup_le le_sup_left hc\n\n"}
{"name":"sup_congr_right","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeSup α\na b c : α\nha : LE.le a (Max.max b c)\nhb : LE.le b (Max.max a c)\n⊢ Eq (Max.max a c) (Max.max b c)","decl":"theorem sup_congr_right (ha : a ≤ b ⊔ c) (hb : b ≤ a ⊔ c) : a ⊔ c = b ⊔ c :=\n  (sup_le ha le_sup_right).antisymm <| sup_le hb le_sup_right\n\n"}
{"name":"sup_eq_sup_iff_left","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeSup α\na b c : α\n⊢ Iff (Eq (Max.max a b) (Max.max a c)) (And (LE.le b (Max.max a c)) (LE.le c (Max.max a b)))","decl":"theorem sup_eq_sup_iff_left : a ⊔ b = a ⊔ c ↔ b ≤ a ⊔ c ∧ c ≤ a ⊔ b :=\n  ⟨fun h => ⟨h ▸ le_sup_right, h.symm ▸ le_sup_right⟩, fun h => sup_congr_left h.1 h.2⟩\n\n"}
{"name":"sup_eq_sup_iff_right","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeSup α\na b c : α\n⊢ Iff (Eq (Max.max a c) (Max.max b c)) (And (LE.le a (Max.max b c)) (LE.le b (Max.max a c)))","decl":"theorem sup_eq_sup_iff_right : a ⊔ c = b ⊔ c ↔ a ≤ b ⊔ c ∧ b ≤ a ⊔ c :=\n  ⟨fun h => ⟨h ▸ le_sup_left, h.symm ▸ le_sup_left⟩, fun h => sup_congr_right h.1 h.2⟩\n\n"}
{"name":"Ne.lt_sup_or_lt_sup","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeSup α\na b : α\nhab : Ne a b\n⊢ Or (LT.lt a (Max.max a b)) (LT.lt b (Max.max a b))","decl":"theorem Ne.lt_sup_or_lt_sup (hab : a ≠ b) : a < a ⊔ b ∨ b < a ⊔ b :=\n  hab.symm.not_le_or_not_le.imp left_lt_sup.2 right_lt_sup.2\n\n"}
{"name":"Monotone.forall_le_of_antitone","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝¹ : SemilatticeSup α\nβ : Type u_1\ninst✝ : Preorder β\nf g : α → β\nhf : Monotone f\nhg : Antitone g\nh : LE.le f g\nm n : α\n⊢ LE.le (f m) (g n)","decl":"/-- If `f` is monotone, `g` is antitone, and `f ≤ g`, then for all `a`, `b` we have `f a ≤ g b`. -/\ntheorem Monotone.forall_le_of_antitone {β : Type*} [Preorder β] {f g : α → β} (hf : Monotone f)\n    (hg : Antitone g) (h : f ≤ g) (m n : α) : f m ≤ g n :=\n  calc\n    f m ≤ f (m ⊔ n) := hf le_sup_left\n    _ ≤ g (m ⊔ n) := h _\n    _ ≤ g n := hg le_sup_right\n\n"}
{"name":"SemilatticeSup.ext_sup","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u_1\nA B : SemilatticeSup α\nH : ∀ (x y : α), Iff (LE.le x y) (LE.le x y)\nx y : α\n⊢ Eq (Max.max x y) (Max.max x y)","decl":"theorem SemilatticeSup.ext_sup {α} {A B : SemilatticeSup α}\n    (H : ∀ x y : α, (haveI := A; x ≤ y) ↔ x ≤ y)\n    (x y : α) :\n    (haveI := A; x ⊔ y) = x ⊔ y :=\n  eq_of_forall_ge_iff fun c => by simp only [sup_le_iff]; rw [← H, @sup_le_iff α A, H, H]\n\n"}
{"name":"SemilatticeSup.ext","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u_1\nA B : SemilatticeSup α\nH : ∀ (x y : α), Iff (LE.le x y) (LE.le x y)\n⊢ Eq A B","decl":"theorem SemilatticeSup.ext {α} {A B : SemilatticeSup α}\n    (H : ∀ x y : α, (haveI := A; x ≤ y) ↔ x ≤ y) :\n    A = B := by\n  cases A\n  cases B\n  cases PartialOrder.ext H\n  congr\n  ext; apply SemilatticeSup.ext_sup H\n\n"}
{"name":"ite_le_sup","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝¹ : SemilatticeSup α\ns s' : α\nP : Prop\ninst✝ : Decidable P\n⊢ LE.le (ite P s s') (Max.max s s')","decl":"theorem ite_le_sup (s s' : α) (P : Prop) [Decidable P] : ite P s s' ≤ s ⊔ s' :=\n  if h : P then (if_pos h).trans_le le_sup_left else (if_neg h).trans_le le_sup_right\n\n"}
{"name":"SemilatticeInf.inf_le_left","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\nself : SemilatticeInf α\na b : α\n⊢ LE.le (SemilatticeInf.inf a b) a","decl":"/-- A `SemilatticeInf` is a meet-semilattice, that is, a partial order\n  with a meet (a.k.a. glb / greatest lower bound, inf / infimum) operation\n  `⊓` which is the greatest element smaller than both factors. -/\nclass SemilatticeInf (α : Type u) extends PartialOrder α where\n  /-- The binary infimum, used to derive `Min α` -/\n  inf : α → α → α\n  /-- The infimum is a lower bound on the first argument -/\n  protected inf_le_left : ∀ a b : α, inf a b ≤ a\n  /-- The infimum is a lower bound on the second argument -/\n  protected inf_le_right : ∀ a b : α, inf a b ≤ b\n  /-- The infimum is the *greatest* lower bound -/\n  protected le_inf : ∀ a b c : α, a ≤ b → a ≤ c → a ≤ inf b c\n\n"}
{"name":"SemilatticeInf.inf_le_right","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\nself : SemilatticeInf α\na b : α\n⊢ LE.le (SemilatticeInf.inf a b) b","decl":"/-- A `SemilatticeInf` is a meet-semilattice, that is, a partial order\n  with a meet (a.k.a. glb / greatest lower bound, inf / infimum) operation\n  `⊓` which is the greatest element smaller than both factors. -/\nclass SemilatticeInf (α : Type u) extends PartialOrder α where\n  /-- The binary infimum, used to derive `Min α` -/\n  inf : α → α → α\n  /-- The infimum is a lower bound on the first argument -/\n  protected inf_le_left : ∀ a b : α, inf a b ≤ a\n  /-- The infimum is a lower bound on the second argument -/\n  protected inf_le_right : ∀ a b : α, inf a b ≤ b\n  /-- The infimum is the *greatest* lower bound -/\n  protected le_inf : ∀ a b c : α, a ≤ b → a ≤ c → a ≤ inf b c\n\n"}
{"name":"SemilatticeInf.le_inf","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\nself : SemilatticeInf α\na b c : α\na✝¹ : LE.le a b\na✝ : LE.le a c\n⊢ LE.le a (SemilatticeInf.inf b c)","decl":"/-- A `SemilatticeInf` is a meet-semilattice, that is, a partial order\n  with a meet (a.k.a. glb / greatest lower bound, inf / infimum) operation\n  `⊓` which is the greatest element smaller than both factors. -/\nclass SemilatticeInf (α : Type u) extends PartialOrder α where\n  /-- The binary infimum, used to derive `Min α` -/\n  inf : α → α → α\n  /-- The infimum is a lower bound on the first argument -/\n  protected inf_le_left : ∀ a b : α, inf a b ≤ a\n  /-- The infimum is a lower bound on the second argument -/\n  protected inf_le_right : ∀ a b : α, inf a b ≤ b\n  /-- The infimum is the *greatest* lower bound -/\n  protected le_inf : ∀ a b c : α, a ≤ b → a ≤ c → a ≤ inf b c\n\n"}
{"name":"SemilatticeSup.dual_dual","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u_1\nH : SemilatticeSup α\n⊢ Eq (OrderDual.instSemilatticeSup (OrderDual α)) H","decl":"theorem SemilatticeSup.dual_dual (α : Type*) [H : SemilatticeSup α] :\n    OrderDual.instSemilatticeSup αᵒᵈ = H :=\n  SemilatticeSup.ext fun _ _ => Iff.rfl\n\n"}
{"name":"inf_le_left","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeInf α\na b : α\n⊢ LE.le (Min.min a b) a","decl":"@[simp]\ntheorem inf_le_left : a ⊓ b ≤ a :=\n  SemilatticeInf.inf_le_left a b\n\n"}
{"name":"inf_le_right","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeInf α\na b : α\n⊢ LE.le (Min.min a b) b","decl":"@[simp]\ntheorem inf_le_right : a ⊓ b ≤ b :=\n  SemilatticeInf.inf_le_right a b\n\n"}
{"name":"le_inf","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeInf α\na b c : α\na✝¹ : LE.le a b\na✝ : LE.le a c\n⊢ LE.le a (Min.min b c)","decl":"theorem le_inf : a ≤ b → a ≤ c → a ≤ b ⊓ c :=\n  SemilatticeInf.le_inf a b c\n\n"}
{"name":"inf_le_of_left_le","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeInf α\na b c : α\nh : LE.le a c\n⊢ LE.le (Min.min a b) c","decl":"theorem inf_le_of_left_le (h : a ≤ c) : a ⊓ b ≤ c :=\n  le_trans inf_le_left h\n\n"}
{"name":"inf_le_of_right_le","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeInf α\na b c : α\nh : LE.le b c\n⊢ LE.le (Min.min a b) c","decl":"theorem inf_le_of_right_le (h : b ≤ c) : a ⊓ b ≤ c :=\n  le_trans inf_le_right h\n\n"}
{"name":"inf_lt_of_left_lt","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeInf α\na b c : α\nh : LT.lt a c\n⊢ LT.lt (Min.min a b) c","decl":"theorem inf_lt_of_left_lt (h : a < c) : a ⊓ b < c :=\n  lt_of_le_of_lt inf_le_left h\n\n"}
{"name":"inf_lt_of_right_lt","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeInf α\na b c : α\nh : LT.lt b c\n⊢ LT.lt (Min.min a b) c","decl":"theorem inf_lt_of_right_lt (h : b < c) : a ⊓ b < c :=\n  lt_of_le_of_lt inf_le_right h\n\n"}
{"name":"le_inf_iff","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeInf α\na b c : α\n⊢ Iff (LE.le a (Min.min b c)) (And (LE.le a b) (LE.le a c))","decl":"@[simp]\ntheorem le_inf_iff : a ≤ b ⊓ c ↔ a ≤ b ∧ a ≤ c :=\n  @sup_le_iff αᵒᵈ _ _ _ _\n\n"}
{"name":"inf_eq_left","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeInf α\na b : α\n⊢ Iff (Eq (Min.min a b) a) (LE.le a b)","decl":"@[simp]\ntheorem inf_eq_left : a ⊓ b = a ↔ a ≤ b :=\n  le_antisymm_iff.trans <| by simp [le_rfl]\n\n"}
{"name":"inf_eq_right","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeInf α\na b : α\n⊢ Iff (Eq (Min.min a b) b) (LE.le b a)","decl":"@[simp]\ntheorem inf_eq_right : a ⊓ b = b ↔ b ≤ a :=\n  le_antisymm_iff.trans <| by simp [le_rfl]\n\n"}
{"name":"left_eq_inf","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeInf α\na b : α\n⊢ Iff (Eq a (Min.min a b)) (LE.le a b)","decl":"@[simp]\ntheorem left_eq_inf : a = a ⊓ b ↔ a ≤ b :=\n  eq_comm.trans inf_eq_left\n\n"}
{"name":"right_eq_inf","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeInf α\na b : α\n⊢ Iff (Eq b (Min.min a b)) (LE.le b a)","decl":"@[simp]\ntheorem right_eq_inf : b = a ⊓ b ↔ b ≤ a :=\n  eq_comm.trans inf_eq_right\n\n"}
{"name":"le_of_inf_eq","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeInf α\na b : α\na✝ : Eq (Min.min a b) a\n⊢ LE.le a b","decl":"alias ⟨le_of_inf_eq, inf_of_le_left⟩ := inf_eq_left\n\n"}
{"name":"inf_of_le_left","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeInf α\na b : α\na✝ : LE.le a b\n⊢ Eq (Min.min a b) a","decl":"alias ⟨le_of_inf_eq, inf_of_le_left⟩ := inf_eq_left\n\n"}
{"name":"inf_of_le_right","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeInf α\na b : α\na✝ : LE.le b a\n⊢ Eq (Min.min a b) b","decl":"alias ⟨_, inf_of_le_right⟩ := inf_eq_right\n\n"}
{"name":"inf_lt_left","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeInf α\na b : α\n⊢ Iff (LT.lt (Min.min a b) a) (Not (LE.le a b))","decl":"@[simp]\ntheorem inf_lt_left : a ⊓ b < a ↔ ¬a ≤ b :=\n  @left_lt_sup αᵒᵈ _ _ _\n\n"}
{"name":"inf_lt_right","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeInf α\na b : α\n⊢ Iff (LT.lt (Min.min a b) b) (Not (LE.le b a))","decl":"@[simp]\ntheorem inf_lt_right : a ⊓ b < b ↔ ¬b ≤ a :=\n  @right_lt_sup αᵒᵈ _ _ _\n\n"}
{"name":"inf_lt_left_or_right","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeInf α\na b : α\nh : Ne a b\n⊢ Or (LT.lt (Min.min a b) a) (LT.lt (Min.min a b) b)","decl":"theorem inf_lt_left_or_right (h : a ≠ b) : a ⊓ b < a ∨ a ⊓ b < b :=\n  @left_or_right_lt_sup αᵒᵈ _ _ _ h\n\n"}
{"name":"inf_le_inf","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeInf α\na b c d : α\nh₁ : LE.le a b\nh₂ : LE.le c d\n⊢ LE.le (Min.min a c) (Min.min b d)","decl":"@[gcongr]\ntheorem inf_le_inf (h₁ : a ≤ b) (h₂ : c ≤ d) : a ⊓ c ≤ b ⊓ d :=\n  @sup_le_sup αᵒᵈ _ _ _ _ _ h₁ h₂\n\n"}
{"name":"inf_le_inf_right","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeInf α\na b c : α\nh : LE.le b c\n⊢ LE.le (Min.min b a) (Min.min c a)","decl":"@[gcongr]\ntheorem inf_le_inf_right (a : α) {b c : α} (h : b ≤ c) : b ⊓ a ≤ c ⊓ a :=\n  inf_le_inf h le_rfl\n\n"}
{"name":"inf_le_inf_left","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeInf α\na b c : α\nh : LE.le b c\n⊢ LE.le (Min.min a b) (Min.min a c)","decl":"@[gcongr]\ntheorem inf_le_inf_left (a : α) {b c : α} (h : b ≤ c) : a ⊓ b ≤ a ⊓ c :=\n  inf_le_inf le_rfl h\n\n"}
{"name":"inf_idem","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeInf α\na : α\n⊢ Eq (Min.min a a) a","decl":"theorem inf_idem (a : α) : a ⊓ a = a := by simp\n\n"}
{"name":"instIdempotentOpMin","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeInf α\n⊢ Std.IdempotentOp fun x1 x2 => Min.min x1 x2","decl":"instance : Std.IdempotentOp (α := α) (· ⊓ ·) := ⟨inf_idem⟩\n\n"}
{"name":"inf_comm","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeInf α\na b : α\n⊢ Eq (Min.min a b) (Min.min b a)","decl":"theorem inf_comm (a b : α) : a ⊓ b = b ⊓ a := @sup_comm αᵒᵈ _ _ _\n\n"}
{"name":"instCommutativeMin","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeInf α\n⊢ Std.Commutative fun x1 x2 => Min.min x1 x2","decl":"instance : Std.Commutative (α := α) (· ⊓ ·) := ⟨inf_comm⟩\n\n"}
{"name":"inf_assoc","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeInf α\na b c : α\n⊢ Eq (Min.min (Min.min a b) c) (Min.min a (Min.min b c))","decl":"theorem inf_assoc (a b c : α) : a ⊓ b ⊓ c = a ⊓ (b ⊓ c) := @sup_assoc αᵒᵈ _ _ _ _\n\n"}
{"name":"instAssociativeMin","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeInf α\n⊢ Std.Associative fun x1 x2 => Min.min x1 x2","decl":"instance : Std.Associative (α := α) (· ⊓ ·) := ⟨inf_assoc⟩\n\n"}
{"name":"inf_left_right_swap","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeInf α\na b c : α\n⊢ Eq (Min.min (Min.min a b) c) (Min.min (Min.min c b) a)","decl":"theorem inf_left_right_swap (a b c : α) : a ⊓ b ⊓ c = c ⊓ b ⊓ a :=\n  @sup_left_right_swap αᵒᵈ _ _ _ _\n\n"}
{"name":"inf_left_idem","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeInf α\na b : α\n⊢ Eq (Min.min a (Min.min a b)) (Min.min a b)","decl":"theorem inf_left_idem (a b : α) : a ⊓ (a ⊓ b) = a ⊓ b := by simp\n\n"}
{"name":"inf_right_idem","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeInf α\na b : α\n⊢ Eq (Min.min (Min.min a b) b) (Min.min a b)","decl":"theorem inf_right_idem (a b : α) : a ⊓ b ⊓ b = a ⊓ b := by simp\n\n"}
{"name":"inf_left_comm","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeInf α\na b c : α\n⊢ Eq (Min.min a (Min.min b c)) (Min.min b (Min.min a c))","decl":"theorem inf_left_comm (a b c : α) : a ⊓ (b ⊓ c) = b ⊓ (a ⊓ c) :=\n  @sup_left_comm αᵒᵈ _ a b c\n\n"}
{"name":"inf_right_comm","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeInf α\na b c : α\n⊢ Eq (Min.min (Min.min a b) c) (Min.min (Min.min a c) b)","decl":"theorem inf_right_comm (a b c : α) : a ⊓ b ⊓ c = a ⊓ c ⊓ b :=\n  @sup_right_comm αᵒᵈ _ a b c\n\n"}
{"name":"inf_inf_inf_comm","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeInf α\na b c d : α\n⊢ Eq (Min.min (Min.min a b) (Min.min c d)) (Min.min (Min.min a c) (Min.min b d))","decl":"theorem inf_inf_inf_comm (a b c d : α) : a ⊓ b ⊓ (c ⊓ d) = a ⊓ c ⊓ (b ⊓ d) :=\n  @sup_sup_sup_comm αᵒᵈ _ _ _ _ _\n\n"}
{"name":"inf_inf_distrib_left","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeInf α\na b c : α\n⊢ Eq (Min.min a (Min.min b c)) (Min.min (Min.min a b) (Min.min a c))","decl":"theorem inf_inf_distrib_left (a b c : α) : a ⊓ (b ⊓ c) = a ⊓ b ⊓ (a ⊓ c) :=\n  @sup_sup_distrib_left αᵒᵈ _ _ _ _\n\n"}
{"name":"inf_inf_distrib_right","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeInf α\na b c : α\n⊢ Eq (Min.min (Min.min a b) c) (Min.min (Min.min a c) (Min.min b c))","decl":"theorem inf_inf_distrib_right (a b c : α) : a ⊓ b ⊓ c = a ⊓ c ⊓ (b ⊓ c) :=\n  @sup_sup_distrib_right αᵒᵈ _ _ _ _\n\n"}
{"name":"inf_congr_left","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeInf α\na b c : α\nhb : LE.le (Min.min a c) b\nhc : LE.le (Min.min a b) c\n⊢ Eq (Min.min a b) (Min.min a c)","decl":"theorem inf_congr_left (hb : a ⊓ c ≤ b) (hc : a ⊓ b ≤ c) : a ⊓ b = a ⊓ c :=\n  @sup_congr_left αᵒᵈ _ _ _ _ hb hc\n\n"}
{"name":"inf_congr_right","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeInf α\na b c : α\nh1 : LE.le (Min.min b c) a\nh2 : LE.le (Min.min a c) b\n⊢ Eq (Min.min a c) (Min.min b c)","decl":"theorem inf_congr_right (h1 : b ⊓ c ≤ a) (h2 : a ⊓ c ≤ b) : a ⊓ c = b ⊓ c :=\n  @sup_congr_right αᵒᵈ _ _ _ _ h1 h2\n\n"}
{"name":"inf_eq_inf_iff_left","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeInf α\na b c : α\n⊢ Iff (Eq (Min.min a b) (Min.min a c)) (And (LE.le (Min.min a c) b) (LE.le (Min.min a b) c))","decl":"theorem inf_eq_inf_iff_left : a ⊓ b = a ⊓ c ↔ a ⊓ c ≤ b ∧ a ⊓ b ≤ c :=\n  @sup_eq_sup_iff_left αᵒᵈ _ _ _ _\n\n"}
{"name":"inf_eq_inf_iff_right","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeInf α\na b c : α\n⊢ Iff (Eq (Min.min a c) (Min.min b c)) (And (LE.le (Min.min b c) a) (LE.le (Min.min a c) b))","decl":"theorem inf_eq_inf_iff_right : a ⊓ c = b ⊓ c ↔ b ⊓ c ≤ a ∧ a ⊓ c ≤ b :=\n  @sup_eq_sup_iff_right αᵒᵈ _ _ _ _\n\n"}
{"name":"Ne.inf_lt_or_inf_lt","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeInf α\na b : α\na✝ : Ne a b\n⊢ Or (LT.lt (Min.min a b) a) (LT.lt (Min.min a b) b)","decl":"theorem Ne.inf_lt_or_inf_lt : a ≠ b → a ⊓ b < a ∨ a ⊓ b < b :=\n  @Ne.lt_sup_or_lt_sup αᵒᵈ _ _ _\n\n"}
{"name":"SemilatticeInf.ext_inf","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u_1\nA B : SemilatticeInf α\nH : ∀ (x y : α), Iff (LE.le x y) (LE.le x y)\nx y : α\n⊢ Eq (Min.min x y) (Min.min x y)","decl":"theorem SemilatticeInf.ext_inf {α} {A B : SemilatticeInf α}\n    (H : ∀ x y : α, (haveI := A; x ≤ y) ↔ x ≤ y)\n    (x y : α) :\n    (haveI := A; x ⊓ y) = x ⊓ y :=\n  eq_of_forall_le_iff fun c => by simp only [le_inf_iff]; rw [← H, @le_inf_iff α A, H, H]\n\n"}
{"name":"SemilatticeInf.ext","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u_1\nA B : SemilatticeInf α\nH : ∀ (x y : α), Iff (LE.le x y) (LE.le x y)\n⊢ Eq A B","decl":"theorem SemilatticeInf.ext {α} {A B : SemilatticeInf α}\n    (H : ∀ x y : α, (haveI := A; x ≤ y) ↔ x ≤ y) :\n    A = B := by\n  cases A\n  cases B\n  cases PartialOrder.ext H\n  congr\n  ext; apply SemilatticeInf.ext_inf H\n\n"}
{"name":"SemilatticeInf.dual_dual","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u_1\nH : SemilatticeInf α\n⊢ Eq (OrderDual.instSemilatticeInf (OrderDual α)) H","decl":"theorem SemilatticeInf.dual_dual (α : Type*) [H : SemilatticeInf α] :\n    OrderDual.instSemilatticeInf αᵒᵈ = H :=\n  SemilatticeInf.ext fun _ _ => Iff.rfl\n\n"}
{"name":"inf_le_ite","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝¹ : SemilatticeInf α\ns s' : α\nP : Prop\ninst✝ : Decidable P\n⊢ LE.le (Min.min s s') (ite P s s')","decl":"theorem inf_le_ite (s s' : α) (P : Prop) [Decidable P] : s ⊓ s' ≤ ite P s s' :=\n  @ite_le_sup αᵒᵈ _ _ _ _ _\n\n"}
{"name":"Lattice.inf_le_right","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\nself : Lattice α\na b : α\n⊢ LE.le (Lattice.inf a b) b","decl":"/-- A lattice is a join-semilattice which is also a meet-semilattice. -/\nclass Lattice (α : Type u) extends SemilatticeSup α, SemilatticeInf α\n\n"}
{"name":"Lattice.inf_le_left","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\nself : Lattice α\na b : α\n⊢ LE.le (Lattice.inf a b) a","decl":"/-- A lattice is a join-semilattice which is also a meet-semilattice. -/\nclass Lattice (α : Type u) extends SemilatticeSup α, SemilatticeInf α\n\n"}
{"name":"Lattice.le_inf","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\nself : Lattice α\na b c : α\na✝¹ : LE.le a b\na✝ : LE.le a c\n⊢ LE.le a (Lattice.inf b c)","decl":"/-- A lattice is a join-semilattice which is also a meet-semilattice. -/\nclass Lattice (α : Type u) extends SemilatticeSup α, SemilatticeInf α\n\n"}
{"name":"semilatticeSup_mk'_partialOrder_eq_semilatticeInf_mk'_partialOrder","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u_1\ninst✝¹ : Max α\ninst✝ : Min α\nsup_comm : ∀ (a b : α), Eq (Max.max a b) (Max.max b a)\nsup_assoc : ∀ (a b c : α), Eq (Max.max (Max.max a b) c) (Max.max a (Max.max b c))\nsup_idem : ∀ (a : α), Eq (Max.max a a) a\ninf_comm : ∀ (a b : α), Eq (Min.min a b) (Min.min b a)\ninf_assoc : ∀ (a b c : α), Eq (Min.min (Min.min a b) c) (Min.min a (Min.min b c))\ninf_idem : ∀ (a : α), Eq (Min.min a a) a\nsup_inf_self : ∀ (a b : α), Eq (Max.max a (Min.min a b)) a\ninf_sup_self : ∀ (a b : α), Eq (Min.min a (Max.max a b)) a\n⊢ Eq SemilatticeSup.toPartialOrder SemilatticeInf.toPartialOrder","decl":"/-- The partial orders from `SemilatticeSup_mk'` and `SemilatticeInf_mk'` agree\nif `sup` and `inf` satisfy the lattice absorption laws `sup_inf_self` (`a ⊔ a ⊓ b = a`)\nand `inf_sup_self` (`a ⊓ (a ⊔ b) = a`). -/\ntheorem semilatticeSup_mk'_partialOrder_eq_semilatticeInf_mk'_partialOrder\n    {α : Type*} [Max α] [Min α]\n    (sup_comm : ∀ a b : α, a ⊔ b = b ⊔ a) (sup_assoc : ∀ a b c : α, a ⊔ b ⊔ c = a ⊔ (b ⊔ c))\n    (sup_idem : ∀ a : α, a ⊔ a = a) (inf_comm : ∀ a b : α, a ⊓ b = b ⊓ a)\n    (inf_assoc : ∀ a b c : α, a ⊓ b ⊓ c = a ⊓ (b ⊓ c)) (inf_idem : ∀ a : α, a ⊓ a = a)\n    (sup_inf_self : ∀ a b : α, a ⊔ a ⊓ b = a) (inf_sup_self : ∀ a b : α, a ⊓ (a ⊔ b) = a) :\n    @SemilatticeSup.toPartialOrder _ (SemilatticeSup.mk' sup_comm sup_assoc sup_idem) =\n      @SemilatticeInf.toPartialOrder _ (SemilatticeInf.mk' inf_comm inf_assoc inf_idem) :=\n  PartialOrder.ext fun a b =>\n    show a ⊔ b = b ↔ b ⊓ a = a from\n      ⟨fun h => by rw [← h, inf_comm, inf_sup_self], fun h => by rw [← h, sup_comm, sup_inf_self]⟩\n\n"}
{"name":"inf_le_sup","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : Lattice α\na b : α\n⊢ LE.le (Min.min a b) (Max.max a b)","decl":"theorem inf_le_sup : a ⊓ b ≤ a ⊔ b :=\n  inf_le_left.trans le_sup_left\n\n"}
{"name":"sup_le_inf","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : Lattice α\na b : α\n⊢ Iff (LE.le (Max.max a b) (Min.min a b)) (Eq a b)","decl":"theorem sup_le_inf : a ⊔ b ≤ a ⊓ b ↔ a = b := by simp [le_antisymm_iff, and_comm]\n\n"}
{"name":"inf_eq_sup","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : Lattice α\na b : α\n⊢ Iff (Eq (Min.min a b) (Max.max a b)) (Eq a b)","decl":"@[simp] lemma inf_eq_sup : a ⊓ b = a ⊔ b ↔ a = b := by rw [← inf_le_sup.ge_iff_eq, sup_le_inf]\n"}
{"name":"sup_eq_inf","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : Lattice α\na b : α\n⊢ Iff (Eq (Max.max a b) (Min.min a b)) (Eq a b)","decl":"@[simp] lemma sup_eq_inf : a ⊔ b = a ⊓ b ↔ a = b := eq_comm.trans inf_eq_sup\n"}
{"name":"inf_lt_sup","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : Lattice α\na b : α\n⊢ Iff (LT.lt (Min.min a b) (Max.max a b)) (Ne a b)","decl":"@[simp] lemma inf_lt_sup : a ⊓ b < a ⊔ b ↔ a ≠ b := by rw [inf_le_sup.lt_iff_ne, Ne, inf_eq_sup]\n\n"}
{"name":"inf_eq_and_sup_eq_iff","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : Lattice α\na b c : α\n⊢ Iff (And (Eq (Min.min a b) c) (Eq (Max.max a b) c)) (And (Eq a c) (Eq b c))","decl":"lemma inf_eq_and_sup_eq_iff : a ⊓ b = c ∧ a ⊔ b = c ↔ a = c ∧ b = c := by\n  refine ⟨fun h ↦ ?_, ?_⟩\n  · obtain rfl := sup_eq_inf.1 (h.2.trans h.1.symm)\n    simpa using h\n  · rintro ⟨rfl, rfl⟩\n    exact ⟨inf_idem _, sup_idem _⟩\n\n"}
{"name":"sup_inf_le","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : Lattice α\na b c : α\n⊢ LE.le (Max.max a (Min.min b c)) (Min.min (Max.max a b) (Max.max a c))","decl":"theorem sup_inf_le : a ⊔ b ⊓ c ≤ (a ⊔ b) ⊓ (a ⊔ c) :=\n  le_inf (sup_le_sup_left inf_le_left _) (sup_le_sup_left inf_le_right _)\n\n"}
{"name":"le_inf_sup","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : Lattice α\na b c : α\n⊢ LE.le (Max.max (Min.min a b) (Min.min a c)) (Min.min a (Max.max b c))","decl":"theorem le_inf_sup : a ⊓ b ⊔ a ⊓ c ≤ a ⊓ (b ⊔ c) :=\n  sup_le (inf_le_inf_left _ le_sup_left) (inf_le_inf_left _ le_sup_right)\n\n"}
{"name":"inf_sup_self","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : Lattice α\na b : α\n⊢ Eq (Min.min a (Max.max a b)) a","decl":"theorem inf_sup_self : a ⊓ (a ⊔ b) = a := by simp\n\n"}
{"name":"sup_inf_self","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : Lattice α\na b : α\n⊢ Eq (Max.max a (Min.min a b)) a","decl":"theorem sup_inf_self : a ⊔ a ⊓ b = a := by simp\n\n"}
{"name":"sup_eq_iff_inf_eq","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : Lattice α\na b : α\n⊢ Iff (Eq (Max.max a b) b) (Eq (Min.min a b) a)","decl":"theorem sup_eq_iff_inf_eq : a ⊔ b = b ↔ a ⊓ b = a := by rw [sup_eq_right, ← inf_eq_left]\n\n"}
{"name":"Lattice.ext","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u_1\nA B : Lattice α\nH : ∀ (x y : α), Iff (LE.le x y) (LE.le x y)\n⊢ Eq A B","decl":"theorem Lattice.ext {α} {A B : Lattice α} (H : ∀ x y : α, (haveI := A; x ≤ y) ↔ x ≤ y) :\n    A = B := by\n  cases A\n  cases B\n  cases SemilatticeSup.ext H\n  cases SemilatticeInf.ext H\n  congr\n\n"}
{"name":"DistribLattice.le_sup_inf","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u_1\nself : DistribLattice α\nx y z : α\n⊢ LE.le (Min.min (Max.max x y) (Max.max x z)) (Max.max x (Min.min y z))","decl":"/-- A distributive lattice is a lattice that satisfies any of four\nequivalent distributive properties (of `sup` over `inf` or `inf` over `sup`,\non the left or right).\n\nThe definition here chooses `le_sup_inf`: `(x ⊔ y) ⊓ (x ⊔ z) ≤ x ⊔ (y ⊓ z)`. To prove distributivity\nfrom the dual law, use `DistribLattice.of_inf_sup_le`.\n\nA classic example of a distributive lattice\nis the lattice of subsets of a set, and in fact this example is\ngeneric in the sense that every distributive lattice is realizable\nas a sublattice of a powerset lattice. -/\nclass DistribLattice (α) extends Lattice α where\n  /-- The infimum distributes over the supremum -/\n  protected le_sup_inf : ∀ x y z : α, (x ⊔ y) ⊓ (x ⊔ z) ≤ x ⊔ y ⊓ z\n\n"}
{"name":"le_sup_inf","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : DistribLattice α\nx y z : α\n⊢ LE.le (Min.min (Max.max x y) (Max.max x z)) (Max.max x (Min.min y z))","decl":"theorem le_sup_inf : ∀ {x y z : α}, (x ⊔ y) ⊓ (x ⊔ z) ≤ x ⊔ y ⊓ z :=\n  fun {x y z} => DistribLattice.le_sup_inf x y z\n\n"}
{"name":"sup_inf_left","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : DistribLattice α\na b c : α\n⊢ Eq (Max.max a (Min.min b c)) (Min.min (Max.max a b) (Max.max a c))","decl":"theorem sup_inf_left (a b c : α) : a ⊔ b ⊓ c = (a ⊔ b) ⊓ (a ⊔ c) :=\n  le_antisymm sup_inf_le le_sup_inf\n\n"}
{"name":"sup_inf_right","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : DistribLattice α\na b c : α\n⊢ Eq (Max.max (Min.min a b) c) (Min.min (Max.max a c) (Max.max b c))","decl":"theorem sup_inf_right (a b c : α) : a ⊓ b ⊔ c = (a ⊔ c) ⊓ (b ⊔ c) := by\n  simp only [sup_inf_left, sup_comm _ c, eq_self_iff_true]\n\n"}
{"name":"inf_sup_left","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : DistribLattice α\na b c : α\n⊢ Eq (Min.min a (Max.max b c)) (Max.max (Min.min a b) (Min.min a c))","decl":"theorem inf_sup_left (a b c : α) : a ⊓ (b ⊔ c) = a ⊓ b ⊔ a ⊓ c :=\n  calc\n    a ⊓ (b ⊔ c) = a ⊓ (a ⊔ c) ⊓ (b ⊔ c) := by rw [inf_sup_self]\n    _ = a ⊓ (a ⊓ b ⊔ c) := by simp only [inf_assoc, sup_inf_right, eq_self_iff_true]\n    _ = (a ⊔ a ⊓ b) ⊓ (a ⊓ b ⊔ c) := by rw [sup_inf_self]\n    _ = (a ⊓ b ⊔ a) ⊓ (a ⊓ b ⊔ c) := by rw [sup_comm]\n    _ = a ⊓ b ⊔ a ⊓ c := by rw [sup_inf_left]\n\n"}
{"name":"inf_sup_right","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : DistribLattice α\na b c : α\n⊢ Eq (Min.min (Max.max a b) c) (Max.max (Min.min a c) (Min.min b c))","decl":"theorem inf_sup_right (a b c : α) : (a ⊔ b) ⊓ c = a ⊓ c ⊔ b ⊓ c := by\n  simp only [inf_sup_left, inf_comm _ c, eq_self_iff_true]\n\n"}
{"name":"le_of_inf_le_sup_le","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : DistribLattice α\nx y z : α\nh₁ : LE.le (Min.min x z) (Min.min y z)\nh₂ : LE.le (Max.max x z) (Max.max y z)\n⊢ LE.le x y","decl":"theorem le_of_inf_le_sup_le (h₁ : x ⊓ z ≤ y ⊓ z) (h₂ : x ⊔ z ≤ y ⊔ z) : x ≤ y :=\n  calc\n    x ≤ y ⊓ z ⊔ x := le_sup_right\n    _ = (y ⊔ x) ⊓ (x ⊔ z) := by rw [sup_inf_right, sup_comm x]\n    _ ≤ (y ⊔ x) ⊓ (y ⊔ z) := inf_le_inf_left _ h₂\n    _ = y ⊔ x ⊓ z := by rw [← sup_inf_left]\n    _ ≤ y ⊔ y ⊓ z := sup_le_sup_left h₁ _\n    _ ≤ _ := sup_le (le_refl y) inf_le_left\n\n"}
{"name":"eq_of_inf_eq_sup_eq","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : DistribLattice α\na b c : α\nh₁ : Eq (Min.min b a) (Min.min c a)\nh₂ : Eq (Max.max b a) (Max.max c a)\n⊢ Eq b c","decl":"theorem eq_of_inf_eq_sup_eq {a b c : α} (h₁ : b ⊓ a = c ⊓ a) (h₂ : b ⊔ a = c ⊔ a) : b = c :=\n  le_antisymm (le_of_inf_le_sup_le (le_of_eq h₁) (le_of_eq h₂))\n    (le_of_inf_le_sup_le (le_of_eq h₁.symm) (le_of_eq h₂.symm))\n\n"}
{"name":"sup_eq_max","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : LinearOrder α\na b : α\n⊢ Eq (Max.max a b) (Max.max a b)","decl":"@[deprecated \"is syntactical\" (since := \"2024-11-13\"), nolint synTaut]\ntheorem sup_eq_max : a ⊔ b = max a b :=\n  rfl\n\n"}
{"name":"inf_eq_min","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : LinearOrder α\na b : α\n⊢ Eq (Min.min a b) (Min.min a b)","decl":"@[deprecated \"is syntactical\" (since := \"2024-11-13\"), nolint synTaut]\ntheorem inf_eq_min : a ⊓ b = min a b :=\n  rfl\n\n"}
{"name":"sup_ind","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : LinearOrder α\na b : α\np : α → Prop\nha : p a\nhb : p b\n⊢ p (Max.max a b)","decl":"theorem sup_ind (a b : α) {p : α → Prop} (ha : p a) (hb : p b) : p (a ⊔ b) :=\n  (IsTotal.total a b).elim (fun h : a ≤ b => by rwa [sup_eq_right.2 h]) fun h => by\n  rwa [sup_eq_left.2 h]\n\n"}
{"name":"le_sup_iff","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : LinearOrder α\na b c : α\n⊢ Iff (LE.le a (Max.max b c)) (Or (LE.le a b) (LE.le a c))","decl":"@[simp]\ntheorem le_sup_iff : a ≤ b ⊔ c ↔ a ≤ b ∨ a ≤ c := by\n  exact ⟨fun h =>\n    (le_total c b).imp\n      (fun bc => by rwa [sup_eq_left.2 bc] at h)\n      (fun bc => by rwa [sup_eq_right.2 bc] at h),\n    fun h => h.elim le_sup_of_le_left le_sup_of_le_right⟩\n\n"}
{"name":"lt_sup_iff","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : LinearOrder α\na b c : α\n⊢ Iff (LT.lt a (Max.max b c)) (Or (LT.lt a b) (LT.lt a c))","decl":"@[simp]\ntheorem lt_sup_iff : a < b ⊔ c ↔ a < b ∨ a < c := by\n  exact ⟨fun h =>\n    (le_total c b).imp\n      (fun bc => by rwa [sup_eq_left.2 bc] at h)\n      (fun bc => by rwa [sup_eq_right.2 bc] at h),\n    fun h => h.elim lt_sup_of_lt_left lt_sup_of_lt_right⟩\n\n"}
{"name":"sup_lt_iff","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : LinearOrder α\na b c : α\n⊢ Iff (LT.lt (Max.max b c) a) (And (LT.lt b a) (LT.lt c a))","decl":"@[simp]\ntheorem sup_lt_iff : b ⊔ c < a ↔ b < a ∧ c < a :=\n  ⟨fun h => ⟨le_sup_left.trans_lt h, le_sup_right.trans_lt h⟩,\n   fun h => sup_ind (p := (· < a)) b c h.1 h.2⟩\n\n"}
{"name":"inf_ind","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : LinearOrder α\na b : α\np : α → Prop\na✝¹ : p a\na✝ : p b\n⊢ p (Min.min a b)","decl":"theorem inf_ind (a b : α) {p : α → Prop} : p a → p b → p (a ⊓ b) :=\n  @sup_ind αᵒᵈ _ _ _ _\n\n"}
{"name":"inf_le_iff","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : LinearOrder α\na b c : α\n⊢ Iff (LE.le (Min.min b c) a) (Or (LE.le b a) (LE.le c a))","decl":"@[simp]\ntheorem inf_le_iff : b ⊓ c ≤ a ↔ b ≤ a ∨ c ≤ a :=\n  @le_sup_iff αᵒᵈ _ _ _ _\n\n"}
{"name":"inf_lt_iff","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : LinearOrder α\na b c : α\n⊢ Iff (LT.lt (Min.min b c) a) (Or (LT.lt b a) (LT.lt c a))","decl":"@[simp]\ntheorem inf_lt_iff : b ⊓ c < a ↔ b < a ∨ c < a :=\n  @lt_sup_iff αᵒᵈ _ _ _ _\n\n"}
{"name":"lt_inf_iff","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : LinearOrder α\na b c : α\n⊢ Iff (LT.lt a (Min.min b c)) (And (LT.lt a b) (LT.lt a c))","decl":"@[simp]\ntheorem lt_inf_iff : a < b ⊓ c ↔ a < b ∧ a < c :=\n  @sup_lt_iff αᵒᵈ _ _ _ _\n\n"}
{"name":"max_max_max_comm","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : LinearOrder α\na b c d : α\n⊢ Eq (Max.max (Max.max a b) (Max.max c d)) (Max.max (Max.max a c) (Max.max b d))","decl":"theorem max_max_max_comm : max (max a b) (max c d) = max (max a c) (max b d) :=\n  sup_sup_sup_comm _ _ _ _\n\n"}
{"name":"min_min_min_comm","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : LinearOrder α\na b c d : α\n⊢ Eq (Min.min (Min.min a b) (Min.min c d)) (Min.min (Min.min a c) (Min.min b d))","decl":"theorem min_min_min_comm : min (min a b) (min c d) = min (min a c) (min b d) :=\n  inf_inf_inf_comm _ _ _ _\n\n"}
{"name":"sup_eq_maxDefault","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝² : SemilatticeSup α\ninst✝¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ninst✝ : IsTotal α fun x1 x2 => LE.le x1 x2\n⊢ Eq (fun x1 x2 => Max.max x1 x2) maxDefault","decl":"theorem sup_eq_maxDefault [SemilatticeSup α] [DecidableRel ((· ≤ ·) : α → α → Prop)]\n    [IsTotal α (· ≤ ·)] :\n    (· ⊔ ·) = (maxDefault : α → α → α) := by\n  ext x y\n  unfold maxDefault\n  split_ifs with h'\n  exacts [sup_of_le_right h', sup_of_le_left <| (total_of (· ≤ ·) x y).resolve_left h']\n\n"}
{"name":"inf_eq_minDefault","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝² : SemilatticeInf α\ninst✝¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ninst✝ : IsTotal α fun x1 x2 => LE.le x1 x2\n⊢ Eq (fun x1 x2 => Min.min x1 x2) minDefault","decl":"theorem inf_eq_minDefault [SemilatticeInf α] [DecidableRel ((· ≤ ·) : α → α → Prop)]\n    [IsTotal α (· ≤ ·)] :\n    (· ⊓ ·) = (minDefault : α → α → α) := by\n  ext x y\n  unfold minDefault\n  split_ifs with h'\n  exacts [inf_of_le_left h', inf_of_le_right <| (total_of (· ≤ ·) x y).resolve_left h']\n\n"}
{"name":"ofDual_inf","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : Max α\na b : OrderDual α\n⊢ Eq (OrderDual.ofDual (Min.min a b)) (Max.max (OrderDual.ofDual a) (OrderDual.ofDual b))","decl":"@[simp]\ntheorem ofDual_inf [Max α] (a b : αᵒᵈ) : ofDual (a ⊓ b) = ofDual a ⊔ ofDual b :=\n  rfl\n\n"}
{"name":"ofDual_sup","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : Min α\na b : OrderDual α\n⊢ Eq (OrderDual.ofDual (Max.max a b)) (Min.min (OrderDual.ofDual a) (OrderDual.ofDual b))","decl":"@[simp]\ntheorem ofDual_sup [Min α] (a b : αᵒᵈ) : ofDual (a ⊔ b) = ofDual a ⊓ ofDual b :=\n  rfl\n\n"}
{"name":"toDual_inf","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : Min α\na b : α\n⊢ Eq (OrderDual.toDual (Min.min a b)) (Max.max (OrderDual.toDual a) (OrderDual.toDual b))","decl":"@[simp]\ntheorem toDual_inf [Min α] (a b : α) : toDual (a ⊓ b) = toDual a ⊔ toDual b :=\n  rfl\n\n"}
{"name":"toDual_sup","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : Max α\na b : α\n⊢ Eq (OrderDual.toDual (Max.max a b)) (Min.min (OrderDual.toDual a) (OrderDual.toDual b))","decl":"@[simp]\ntheorem toDual_sup [Max α] (a b : α) : toDual (a ⊔ b) = toDual a ⊓ toDual b :=\n  rfl\n\n"}
{"name":"ofDual_min","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : LinearOrder α\na b : OrderDual α\n⊢ Eq (OrderDual.ofDual (Min.min a b)) (Max.max (OrderDual.ofDual a) (OrderDual.ofDual b))","decl":"@[simp]\ntheorem ofDual_min (a b : αᵒᵈ) : ofDual (min a b) = max (ofDual a) (ofDual b) :=\n  rfl\n\n"}
{"name":"ofDual_max","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : LinearOrder α\na b : OrderDual α\n⊢ Eq (OrderDual.ofDual (Max.max a b)) (Min.min (OrderDual.ofDual a) (OrderDual.ofDual b))","decl":"@[simp]\ntheorem ofDual_max (a b : αᵒᵈ) : ofDual (max a b) = min (ofDual a) (ofDual b) :=\n  rfl\n\n"}
{"name":"toDual_min","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : LinearOrder α\na b : α\n⊢ Eq (OrderDual.toDual (Min.min a b)) (Max.max (OrderDual.toDual a) (OrderDual.toDual b))","decl":"@[simp]\ntheorem toDual_min (a b : α) : toDual (min a b) = max (toDual a) (toDual b) :=\n  rfl\n\n"}
{"name":"toDual_max","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : LinearOrder α\na b : α\n⊢ Eq (OrderDual.toDual (Max.max a b)) (Min.min (OrderDual.toDual a) (OrderDual.toDual b))","decl":"@[simp]\ntheorem toDual_max (a b : α) : toDual (max a b) = min (toDual a) (toDual b) :=\n  rfl\n\n"}
{"name":"Pi.sup_apply","module":"Mathlib.Order.Lattice","initialProofState":"ι : Type u_1\nα' : ι → Type u_2\ninst✝ : (i : ι) → Max (α' i)\nf g : (i : ι) → α' i\ni : ι\n⊢ Eq (Max.max f g i) (Max.max (f i) (g i))","decl":"@[simp]\ntheorem sup_apply [∀ i, Max (α' i)] (f g : ∀ i, α' i) (i : ι) : (f ⊔ g) i = f i ⊔ g i :=\n  rfl\n\n"}
{"name":"Pi.sup_def","module":"Mathlib.Order.Lattice","initialProofState":"ι : Type u_1\nα' : ι → Type u_2\ninst✝ : (i : ι) → Max (α' i)\nf g : (i : ι) → α' i\n⊢ Eq (Max.max f g) fun i => Max.max (f i) (g i)","decl":"theorem sup_def [∀ i, Max (α' i)] (f g : ∀ i, α' i) : f ⊔ g = fun i => f i ⊔ g i :=\n  rfl\n\n"}
{"name":"Pi.inf_apply","module":"Mathlib.Order.Lattice","initialProofState":"ι : Type u_1\nα' : ι → Type u_2\ninst✝ : (i : ι) → Min (α' i)\nf g : (i : ι) → α' i\ni : ι\n⊢ Eq (Min.min f g i) (Min.min (f i) (g i))","decl":"@[simp]\ntheorem inf_apply [∀ i, Min (α' i)] (f g : ∀ i, α' i) (i : ι) : (f ⊓ g) i = f i ⊓ g i :=\n  rfl\n\n"}
{"name":"Pi.inf_def","module":"Mathlib.Order.Lattice","initialProofState":"ι : Type u_1\nα' : ι → Type u_2\ninst✝ : (i : ι) → Min (α' i)\nf g : (i : ι) → α' i\n⊢ Eq (Min.min f g) fun i => Min.min (f i) (g i)","decl":"theorem inf_def [∀ i, Min (α' i)] (f g : ∀ i, α' i) : f ⊓ g = fun i => f i ⊓ g i :=\n  rfl\n\n"}
{"name":"Function.update_sup","module":"Mathlib.Order.Lattice","initialProofState":"ι : Type u_1\nπ : ι → Type u_2\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → SemilatticeSup (π i)\nf : (i : ι) → π i\ni : ι\na b : π i\n⊢ Eq (Function.update f i (Max.max a b)) (Max.max (Function.update f i a) (Function.update f i b))","decl":"theorem update_sup [∀ i, SemilatticeSup (π i)] (f : ∀ i, π i) (i : ι) (a b : π i) :\n    update f i (a ⊔ b) = update f i a ⊔ update f i b :=\n  funext fun j => by obtain rfl | hji := eq_or_ne j i <;> simp [update_of_ne, *]\n\n"}
{"name":"Function.update_inf","module":"Mathlib.Order.Lattice","initialProofState":"ι : Type u_1\nπ : ι → Type u_2\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → SemilatticeInf (π i)\nf : (i : ι) → π i\ni : ι\na b : π i\n⊢ Eq (Function.update f i (Min.min a b)) (Min.min (Function.update f i a) (Function.update f i b))","decl":"theorem update_inf [∀ i, SemilatticeInf (π i)] (f : ∀ i, π i) (i : ι) (a b : π i) :\n    update f i (a ⊓ b) = update f i a ⊓ update f i b :=\n  funext fun j => by obtain rfl | hji := eq_or_ne j i <;> simp [update_of_ne, *]\n\n"}
{"name":"Monotone.sup","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : SemilatticeSup β\nf g : α → β\nhf : Monotone f\nhg : Monotone g\n⊢ Monotone (Max.max f g)","decl":"/-- Pointwise supremum of two monotone functions is a monotone function. -/\nprotected theorem sup [Preorder α] [SemilatticeSup β] {f g : α → β} (hf : Monotone f)\n    (hg : Monotone g) :\n    Monotone (f ⊔ g) := fun _ _ h => sup_le_sup (hf h) (hg h)\n\n"}
{"name":"Monotone.inf","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : SemilatticeInf β\nf g : α → β\nhf : Monotone f\nhg : Monotone g\n⊢ Monotone (Min.min f g)","decl":"/-- Pointwise infimum of two monotone functions is a monotone function. -/\nprotected theorem inf [Preorder α] [SemilatticeInf β] {f g : α → β} (hf : Monotone f)\n    (hg : Monotone g) :\n    Monotone (f ⊓ g) := fun _ _ h => inf_le_inf (hf h) (hg h)\n\n"}
{"name":"Monotone.max","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : LinearOrder β\nf g : α → β\nhf : Monotone f\nhg : Monotone g\n⊢ Monotone fun x => Max.max (f x) (g x)","decl":"/-- Pointwise maximum of two monotone functions is a monotone function. -/\nprotected theorem max [Preorder α] [LinearOrder β] {f g : α → β} (hf : Monotone f)\n    (hg : Monotone g) :\n    Monotone fun x => max (f x) (g x) :=\n  hf.sup hg\n\n"}
{"name":"Monotone.min","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : LinearOrder β\nf g : α → β\nhf : Monotone f\nhg : Monotone g\n⊢ Monotone fun x => Min.min (f x) (g x)","decl":"/-- Pointwise minimum of two monotone functions is a monotone function. -/\nprotected theorem min [Preorder α] [LinearOrder β] {f g : α → β} (hf : Monotone f)\n    (hg : Monotone g) :\n    Monotone fun x => min (f x) (g x) :=\n  hf.inf hg\n\n"}
{"name":"Monotone.le_map_sup","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : SemilatticeSup α\ninst✝ : SemilatticeSup β\nf : α → β\nh : Monotone f\nx y : α\n⊢ LE.le (Max.max (f x) (f y)) (f (Max.max x y))","decl":"theorem le_map_sup [SemilatticeSup α] [SemilatticeSup β] {f : α → β} (h : Monotone f) (x y : α) :\n    f x ⊔ f y ≤ f (x ⊔ y) :=\n  sup_le (h le_sup_left) (h le_sup_right)\n\n"}
{"name":"Monotone.map_inf_le","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : SemilatticeInf α\ninst✝ : SemilatticeInf β\nf : α → β\nh : Monotone f\nx y : α\n⊢ LE.le (f (Min.min x y)) (Min.min (f x) (f y))","decl":"theorem map_inf_le [SemilatticeInf α] [SemilatticeInf β] {f : α → β} (h : Monotone f) (x y : α) :\n    f (x ⊓ y) ≤ f x ⊓ f y :=\n  le_inf (h inf_le_left) (h inf_le_right)\n\n"}
{"name":"Monotone.of_map_inf_le_left","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : SemilatticeInf α\ninst✝ : Preorder β\nf : α → β\nh : ∀ (x y : α), LE.le (f (Min.min x y)) (f x)\n⊢ Monotone f","decl":"theorem of_map_inf_le_left [SemilatticeInf α] [Preorder β] {f : α → β}\n    (h : ∀ x y, f (x ⊓ y) ≤ f x) : Monotone f := by\n  intro x y hxy\n  rw [← inf_eq_right.2 hxy]\n  apply h\n\n"}
{"name":"Monotone.of_map_inf_le","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : SemilatticeInf α\ninst✝ : SemilatticeInf β\nf : α → β\nh : ∀ (x y : α), LE.le (f (Min.min x y)) (Min.min (f x) (f y))\n⊢ Monotone f","decl":"theorem of_map_inf_le [SemilatticeInf α] [SemilatticeInf β] {f : α → β}\n    (h : ∀ x y, f (x ⊓ y) ≤ f x ⊓ f y) : Monotone f :=\n  of_map_inf_le_left fun x y ↦ (h x y).trans inf_le_left\n\n"}
{"name":"Monotone.of_map_inf","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : SemilatticeInf α\ninst✝ : SemilatticeInf β\nf : α → β\nh : ∀ (x y : α), Eq (f (Min.min x y)) (Min.min (f x) (f y))\n⊢ Monotone f","decl":"theorem of_map_inf [SemilatticeInf α] [SemilatticeInf β] {f : α → β}\n    (h : ∀ x y, f (x ⊓ y) = f x ⊓ f y) : Monotone f :=\n  of_map_inf_le fun x y ↦ (h x y).le\n\n"}
{"name":"Monotone.of_left_le_map_sup","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : SemilatticeSup α\ninst✝ : Preorder β\nf : α → β\nh : ∀ (x y : α), LE.le (f x) (f (Max.max x y))\n⊢ Monotone f","decl":"theorem of_left_le_map_sup [SemilatticeSup α] [Preorder β] {f : α → β}\n    (h : ∀ x y, f x ≤ f (x ⊔ y)) : Monotone f :=\n  monotone_dual_iff.1 <| of_map_inf_le_left h\n\n"}
{"name":"Monotone.of_le_map_sup","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : SemilatticeSup α\ninst✝ : SemilatticeSup β\nf : α → β\nh : ∀ (x y : α), LE.le (Max.max (f x) (f y)) (f (Max.max x y))\n⊢ Monotone f","decl":"theorem of_le_map_sup [SemilatticeSup α] [SemilatticeSup β] {f : α → β}\n    (h : ∀ x y, f x ⊔ f y ≤ f (x ⊔ y)) : Monotone f :=\n  monotone_dual_iff.mp <| of_map_inf_le h\n\n"}
{"name":"Monotone.of_map_sup","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : SemilatticeSup α\ninst✝ : SemilatticeSup β\nf : α → β\nh : ∀ (x y : α), Eq (f (Max.max x y)) (Max.max (f x) (f y))\n⊢ Monotone f","decl":"theorem of_map_sup [SemilatticeSup α] [SemilatticeSup β] {f : α → β}\n    (h : ∀ x y, f (x ⊔ y) = f x ⊔ f y) : Monotone f :=\n  (@of_map_inf (OrderDual α) (OrderDual β) _ _ _ h).dual\n\n"}
{"name":"Monotone.map_sup","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : LinearOrder α\ninst✝ : SemilatticeSup β\nf : α → β\nhf : Monotone f\nx y : α\n⊢ Eq (f (Max.max x y)) (Max.max (f x) (f y))","decl":"theorem map_sup [SemilatticeSup β] {f : α → β} (hf : Monotone f) (x y : α) :\n    f (x ⊔ y) = f x ⊔ f y :=\n  (IsTotal.total x y).elim (fun h : x ≤ y => by simp only [h, hf h, sup_of_le_right]) fun h => by\n    simp only [h, hf h, sup_of_le_left]\n\n"}
{"name":"Monotone.map_inf","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : LinearOrder α\ninst✝ : SemilatticeInf β\nf : α → β\nhf : Monotone f\nx y : α\n⊢ Eq (f (Min.min x y)) (Min.min (f x) (f y))","decl":"theorem map_inf [SemilatticeInf β] {f : α → β} (hf : Monotone f) (x y : α) :\n    f (x ⊓ y) = f x ⊓ f y :=\n  hf.dual.map_sup _ _\n\n"}
{"name":"MonotoneOn.sup","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : SemilatticeSup β\nf g : α → β\ns : Set α\nhf : MonotoneOn f s\nhg : MonotoneOn g s\n⊢ MonotoneOn (Max.max f g) s","decl":"/-- Pointwise supremum of two monotone functions is a monotone function. -/\nprotected theorem sup [Preorder α] [SemilatticeSup β] {f g : α → β} {s : Set α}\n    (hf : MonotoneOn f s) (hg : MonotoneOn g s) : MonotoneOn (f ⊔ g) s :=\n  fun _ hx _ hy h => sup_le_sup (hf hx hy h) (hg hx hy h)\n\n"}
{"name":"MonotoneOn.inf","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : SemilatticeInf β\nf g : α → β\ns : Set α\nhf : MonotoneOn f s\nhg : MonotoneOn g s\n⊢ MonotoneOn (Min.min f g) s","decl":"/-- Pointwise infimum of two monotone functions is a monotone function. -/\nprotected theorem inf [Preorder α] [SemilatticeInf β] {f g : α → β} {s : Set α}\n    (hf : MonotoneOn f s) (hg : MonotoneOn g s) : MonotoneOn (f ⊓ g) s :=\n  (hf.dual.sup hg.dual).dual\n\n"}
{"name":"MonotoneOn.max","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : LinearOrder β\nf g : α → β\ns : Set α\nhf : MonotoneOn f s\nhg : MonotoneOn g s\n⊢ MonotoneOn (fun x => Max.max (f x) (g x)) s","decl":"/-- Pointwise maximum of two monotone functions is a monotone function. -/\nprotected theorem max [Preorder α] [LinearOrder β] {f g : α → β} {s : Set α} (hf : MonotoneOn f s)\n    (hg : MonotoneOn g s) : MonotoneOn (fun x => max (f x) (g x)) s :=\n  hf.sup hg\n\n"}
{"name":"MonotoneOn.min","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : LinearOrder β\nf g : α → β\ns : Set α\nhf : MonotoneOn f s\nhg : MonotoneOn g s\n⊢ MonotoneOn (fun x => Min.min (f x) (g x)) s","decl":"/-- Pointwise minimum of two monotone functions is a monotone function. -/\nprotected theorem min [Preorder α] [LinearOrder β] {f g : α → β} {s : Set α} (hf : MonotoneOn f s)\n    (hg : MonotoneOn g s) : MonotoneOn (fun x => min (f x) (g x)) s :=\n  hf.inf hg\n\n"}
{"name":"MonotoneOn.of_map_inf","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ns : Set α\ninst✝¹ : SemilatticeInf α\ninst✝ : SemilatticeInf β\nh : ∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem s y → Eq (f (Min.min x y)) (Min.min (f x) (f y))\n⊢ MonotoneOn f s","decl":"theorem of_map_inf [SemilatticeInf α] [SemilatticeInf β]\n    (h : ∀ x ∈ s, ∀ y ∈ s, f (x ⊓ y) = f x ⊓ f y) : MonotoneOn f s := fun x hx y hy hxy =>\n  inf_eq_left.1 <| by rw [← h _ hx _ hy, inf_eq_left.2 hxy]\n\n"}
{"name":"MonotoneOn.of_map_sup","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ns : Set α\ninst✝¹ : SemilatticeSup α\ninst✝ : SemilatticeSup β\nh : ∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem s y → Eq (f (Max.max x y)) (Max.max (f x) (f y))\n⊢ MonotoneOn f s","decl":"theorem of_map_sup [SemilatticeSup α] [SemilatticeSup β]\n    (h : ∀ x ∈ s, ∀ y ∈ s, f (x ⊔ y) = f x ⊔ f y) : MonotoneOn f s :=\n  (@of_map_inf αᵒᵈ βᵒᵈ _ _ _ _ h).dual\n\n"}
{"name":"MonotoneOn.map_sup","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ns : Set α\nx y : α\ninst✝¹ : LinearOrder α\ninst✝ : SemilatticeSup β\nhf : MonotoneOn f s\nhx : Membership.mem s x\nhy : Membership.mem s y\n⊢ Eq (f (Max.max x y)) (Max.max (f x) (f y))","decl":"theorem map_sup [SemilatticeSup β] (hf : MonotoneOn f s) (hx : x ∈ s) (hy : y ∈ s) :\n    f (x ⊔ y) = f x ⊔ f y := by\n  cases le_total x y <;> have := hf ?_ ?_ ‹_› <;>\n    first\n    | assumption\n    | simp only [*, sup_of_le_left, sup_of_le_right]\n\n"}
{"name":"MonotoneOn.map_inf","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ns : Set α\nx y : α\ninst✝¹ : LinearOrder α\ninst✝ : SemilatticeInf β\nhf : MonotoneOn f s\nhx : Membership.mem s x\nhy : Membership.mem s y\n⊢ Eq (f (Min.min x y)) (Min.min (f x) (f y))","decl":"theorem map_inf [SemilatticeInf β] (hf : MonotoneOn f s) (hx : x ∈ s) (hy : y ∈ s) :\n    f (x ⊓ y) = f x ⊓ f y :=\n  hf.dual.map_sup hx hy\n\n"}
{"name":"Antitone.sup","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : SemilatticeSup β\nf g : α → β\nhf : Antitone f\nhg : Antitone g\n⊢ Antitone (Max.max f g)","decl":"/-- Pointwise supremum of two monotone functions is a monotone function. -/\nprotected theorem sup [Preorder α] [SemilatticeSup β] {f g : α → β} (hf : Antitone f)\n    (hg : Antitone g) :\n    Antitone (f ⊔ g) := fun _ _ h => sup_le_sup (hf h) (hg h)\n\n"}
{"name":"Antitone.inf","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : SemilatticeInf β\nf g : α → β\nhf : Antitone f\nhg : Antitone g\n⊢ Antitone (Min.min f g)","decl":"/-- Pointwise infimum of two monotone functions is a monotone function. -/\nprotected theorem inf [Preorder α] [SemilatticeInf β] {f g : α → β} (hf : Antitone f)\n    (hg : Antitone g) :\n    Antitone (f ⊓ g) := fun _ _ h => inf_le_inf (hf h) (hg h)\n\n"}
{"name":"Antitone.max","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : LinearOrder β\nf g : α → β\nhf : Antitone f\nhg : Antitone g\n⊢ Antitone fun x => Max.max (f x) (g x)","decl":"/-- Pointwise maximum of two monotone functions is a monotone function. -/\nprotected theorem max [Preorder α] [LinearOrder β] {f g : α → β} (hf : Antitone f)\n    (hg : Antitone g) :\n    Antitone fun x => max (f x) (g x) :=\n  hf.sup hg\n\n"}
{"name":"Antitone.min","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : LinearOrder β\nf g : α → β\nhf : Antitone f\nhg : Antitone g\n⊢ Antitone fun x => Min.min (f x) (g x)","decl":"/-- Pointwise minimum of two monotone functions is a monotone function. -/\nprotected theorem min [Preorder α] [LinearOrder β] {f g : α → β} (hf : Antitone f)\n    (hg : Antitone g) :\n    Antitone fun x => min (f x) (g x) :=\n  hf.inf hg\n\n"}
{"name":"Antitone.map_sup_le","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : SemilatticeSup α\ninst✝ : SemilatticeInf β\nf : α → β\nh : Antitone f\nx y : α\n⊢ LE.le (f (Max.max x y)) (Min.min (f x) (f y))","decl":"theorem map_sup_le [SemilatticeSup α] [SemilatticeInf β] {f : α → β} (h : Antitone f) (x y : α) :\n    f (x ⊔ y) ≤ f x ⊓ f y :=\n  h.dual_right.le_map_sup x y\n\n"}
{"name":"Antitone.le_map_inf","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : SemilatticeInf α\ninst✝ : SemilatticeSup β\nf : α → β\nh : Antitone f\nx y : α\n⊢ LE.le (Max.max (f x) (f y)) (f (Min.min x y))","decl":"theorem le_map_inf [SemilatticeInf α] [SemilatticeSup β] {f : α → β} (h : Antitone f) (x y : α) :\n    f x ⊔ f y ≤ f (x ⊓ y) :=\n  h.dual_right.map_inf_le x y\n\n"}
{"name":"Antitone.map_sup","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : LinearOrder α\ninst✝ : SemilatticeInf β\nf : α → β\nhf : Antitone f\nx y : α\n⊢ Eq (f (Max.max x y)) (Min.min (f x) (f y))","decl":"theorem map_sup [SemilatticeInf β] {f : α → β} (hf : Antitone f) (x y : α) :\n    f (x ⊔ y) = f x ⊓ f y :=\n  hf.dual_right.map_sup x y\n\n"}
{"name":"Antitone.map_inf","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : LinearOrder α\ninst✝ : SemilatticeSup β\nf : α → β\nhf : Antitone f\nx y : α\n⊢ Eq (f (Min.min x y)) (Max.max (f x) (f y))","decl":"theorem map_inf [SemilatticeSup β] {f : α → β} (hf : Antitone f) (x y : α) :\n    f (x ⊓ y) = f x ⊔ f y :=\n  hf.dual_right.map_inf x y\n\n"}
{"name":"AntitoneOn.sup","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : SemilatticeSup β\nf g : α → β\ns : Set α\nhf : AntitoneOn f s\nhg : AntitoneOn g s\n⊢ AntitoneOn (Max.max f g) s","decl":"/-- Pointwise supremum of two antitone functions is an antitone function. -/\nprotected theorem sup [Preorder α] [SemilatticeSup β] {f g : α → β} {s : Set α}\n    (hf : AntitoneOn f s) (hg : AntitoneOn g s) : AntitoneOn (f ⊔ g) s :=\n  fun _ hx _ hy h => sup_le_sup (hf hx hy h) (hg hx hy h)\n\n"}
{"name":"AntitoneOn.inf","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : SemilatticeInf β\nf g : α → β\ns : Set α\nhf : AntitoneOn f s\nhg : AntitoneOn g s\n⊢ AntitoneOn (Min.min f g) s","decl":"/-- Pointwise infimum of two antitone functions is an antitone function. -/\nprotected theorem inf [Preorder α] [SemilatticeInf β] {f g : α → β} {s : Set α}\n    (hf : AntitoneOn f s) (hg : AntitoneOn g s) : AntitoneOn (f ⊓ g) s :=\n  (hf.dual.sup hg.dual).dual\n\n"}
{"name":"AntitoneOn.max","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : LinearOrder β\nf g : α → β\ns : Set α\nhf : AntitoneOn f s\nhg : AntitoneOn g s\n⊢ AntitoneOn (fun x => Max.max (f x) (g x)) s","decl":"/-- Pointwise maximum of two antitone functions is an antitone function. -/\nprotected theorem max [Preorder α] [LinearOrder β] {f g : α → β} {s : Set α} (hf : AntitoneOn f s)\n    (hg : AntitoneOn g s) : AntitoneOn (fun x => max (f x) (g x)) s :=\n  hf.sup hg\n\n"}
{"name":"AntitoneOn.min","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : LinearOrder β\nf g : α → β\ns : Set α\nhf : AntitoneOn f s\nhg : AntitoneOn g s\n⊢ AntitoneOn (fun x => Min.min (f x) (g x)) s","decl":"/-- Pointwise minimum of two antitone functions is an antitone function. -/\nprotected theorem min [Preorder α] [LinearOrder β] {f g : α → β} {s : Set α} (hf : AntitoneOn f s)\n    (hg : AntitoneOn g s) : AntitoneOn (fun x => min (f x) (g x)) s :=\n  hf.inf hg\n\n"}
{"name":"AntitoneOn.of_map_inf","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ns : Set α\ninst✝¹ : SemilatticeInf α\ninst✝ : SemilatticeSup β\nh : ∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem s y → Eq (f (Min.min x y)) (Max.max (f x) (f y))\n⊢ AntitoneOn f s","decl":"theorem of_map_inf [SemilatticeInf α] [SemilatticeSup β]\n    (h : ∀ x ∈ s, ∀ y ∈ s, f (x ⊓ y) = f x ⊔ f y) : AntitoneOn f s := fun x hx y hy hxy =>\n  sup_eq_left.1 <| by rw [← h _ hx _ hy, inf_eq_left.2 hxy]\n\n"}
{"name":"AntitoneOn.of_map_sup","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ns : Set α\ninst✝¹ : SemilatticeSup α\ninst✝ : SemilatticeInf β\nh : ∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem s y → Eq (f (Max.max x y)) (Min.min (f x) (f y))\n⊢ AntitoneOn f s","decl":"theorem of_map_sup [SemilatticeSup α] [SemilatticeInf β]\n    (h : ∀ x ∈ s, ∀ y ∈ s, f (x ⊔ y) = f x ⊓ f y) : AntitoneOn f s :=\n  (@of_map_inf αᵒᵈ βᵒᵈ _ _ _ _ h).dual\n\n"}
{"name":"AntitoneOn.map_sup","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ns : Set α\nx y : α\ninst✝¹ : LinearOrder α\ninst✝ : SemilatticeInf β\nhf : AntitoneOn f s\nhx : Membership.mem s x\nhy : Membership.mem s y\n⊢ Eq (f (Max.max x y)) (Min.min (f x) (f y))","decl":"theorem map_sup [SemilatticeInf β] (hf : AntitoneOn f s) (hx : x ∈ s) (hy : y ∈ s) :\n    f (x ⊔ y) = f x ⊓ f y := by\n  cases le_total x y <;> have := hf ?_ ?_ ‹_› <;>\n    first\n    | assumption\n    | simp only [*, sup_of_le_left, sup_of_le_right, inf_of_le_left, inf_of_le_right]\n\n"}
{"name":"AntitoneOn.map_inf","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ns : Set α\nx y : α\ninst✝¹ : LinearOrder α\ninst✝ : SemilatticeSup β\nhf : AntitoneOn f s\nhx : Membership.mem s x\nhy : Membership.mem s y\n⊢ Eq (f (Min.min x y)) (Max.max (f x) (f y))","decl":"theorem map_inf [SemilatticeSup β] (hf : AntitoneOn f s) (hx : x ∈ s) (hy : y ∈ s) :\n    f (x ⊓ y) = f x ⊔ f y :=\n  hf.dual.map_sup hx hy\n\n"}
{"name":"Prod.mk_sup_mk","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Max α\ninst✝ : Max β\na₁ a₂ : α\nb₁ b₂ : β\n⊢ Eq (Max.max { fst := a₁, snd := b₁ } { fst := a₂, snd := b₂ }) { fst := Max.max a₁ a₂, snd := Max.max b₁ b₂ }","decl":"@[simp]\ntheorem mk_sup_mk [Max α] [Max β] (a₁ a₂ : α) (b₁ b₂ : β) :\n    (a₁, b₁) ⊔ (a₂, b₂) = (a₁ ⊔ a₂, b₁ ⊔ b₂) :=\n  rfl\n\n"}
{"name":"Prod.mk_inf_mk","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Min α\ninst✝ : Min β\na₁ a₂ : α\nb₁ b₂ : β\n⊢ Eq (Min.min { fst := a₁, snd := b₁ } { fst := a₂, snd := b₂ }) { fst := Min.min a₁ a₂, snd := Min.min b₁ b₂ }","decl":"@[simp]\ntheorem mk_inf_mk [Min α] [Min β] (a₁ a₂ : α) (b₁ b₂ : β) :\n    (a₁, b₁) ⊓ (a₂, b₂) = (a₁ ⊓ a₂, b₁ ⊓ b₂) :=\n  rfl\n\n"}
{"name":"Prod.fst_sup","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Max α\ninst✝ : Max β\np q : Prod α β\n⊢ Eq (Max.max p q).fst (Max.max p.fst q.fst)","decl":"@[simp]\ntheorem fst_sup [Max α] [Max β] (p q : α × β) : (p ⊔ q).fst = p.fst ⊔ q.fst :=\n  rfl\n\n"}
{"name":"Prod.fst_inf","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Min α\ninst✝ : Min β\np q : Prod α β\n⊢ Eq (Min.min p q).fst (Min.min p.fst q.fst)","decl":"@[simp]\ntheorem fst_inf [Min α] [Min β] (p q : α × β) : (p ⊓ q).fst = p.fst ⊓ q.fst :=\n  rfl\n\n"}
{"name":"Prod.snd_sup","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Max α\ninst✝ : Max β\np q : Prod α β\n⊢ Eq (Max.max p q).snd (Max.max p.snd q.snd)","decl":"@[simp]\ntheorem snd_sup [Max α] [Max β] (p q : α × β) : (p ⊔ q).snd = p.snd ⊔ q.snd :=\n  rfl\n\n"}
{"name":"Prod.snd_inf","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Min α\ninst✝ : Min β\np q : Prod α β\n⊢ Eq (Min.min p q).snd (Min.min p.snd q.snd)","decl":"@[simp]\ntheorem snd_inf [Min α] [Min β] (p q : α × β) : (p ⊓ q).snd = p.snd ⊓ q.snd :=\n  rfl\n\n"}
{"name":"Prod.swap_sup","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Max α\ninst✝ : Max β\np q : Prod α β\n⊢ Eq (Max.max p q).swap (Max.max p.swap q.swap)","decl":"@[simp]\ntheorem swap_sup [Max α] [Max β] (p q : α × β) : (p ⊔ q).swap = p.swap ⊔ q.swap :=\n  rfl\n\n"}
{"name":"Prod.swap_inf","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Min α\ninst✝ : Min β\np q : Prod α β\n⊢ Eq (Min.min p q).swap (Min.min p.swap q.swap)","decl":"@[simp]\ntheorem swap_inf [Min α] [Min β] (p q : α × β) : (p ⊓ q).swap = p.swap ⊓ q.swap :=\n  rfl\n\n"}
{"name":"Prod.sup_def","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Max α\ninst✝ : Max β\np q : Prod α β\n⊢ Eq (Max.max p q) { fst := Max.max p.fst q.fst, snd := Max.max p.snd q.snd }","decl":"theorem sup_def [Max α] [Max β] (p q : α × β) : p ⊔ q = (p.fst ⊔ q.fst, p.snd ⊔ q.snd) :=\n  rfl\n\n"}
{"name":"Prod.inf_def","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Min α\ninst✝ : Min β\np q : Prod α β\n⊢ Eq (Min.min p q) { fst := Min.min p.fst q.fst, snd := Min.min p.snd q.snd }","decl":"theorem inf_def [Min α] [Min β] (p q : α × β) : p ⊓ q = (p.fst ⊓ q.fst, p.snd ⊓ q.snd) :=\n  rfl\n\n"}
{"name":"Subtype.coe_sup","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeSup α\nP : α → Prop\nPsup : ∀ ⦃x y : α⦄, P x → P y → P (Max.max x y)\nx y : Subtype P\n⊢ Eq (↑(Max.max x y)) (Max.max ↑x ↑y)","decl":"@[simp, norm_cast]\ntheorem coe_sup [SemilatticeSup α] {P : α → Prop}\n    (Psup : ∀ ⦃x y⦄, P x → P y → P (x ⊔ y)) (x y : Subtype P) :\n    (haveI := Subtype.semilatticeSup Psup; (x ⊔ y : Subtype P) : α) = (x ⊔ y : α) :=\n  rfl\n\n"}
{"name":"Subtype.coe_inf","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeInf α\nP : α → Prop\nPinf : ∀ ⦃x y : α⦄, P x → P y → P (Min.min x y)\nx y : Subtype P\n⊢ Eq (↑(Min.min x y)) (Min.min ↑x ↑y)","decl":"@[simp, norm_cast]\ntheorem coe_inf [SemilatticeInf α] {P : α → Prop}\n    (Pinf : ∀ ⦃x y⦄, P x → P y → P (x ⊓ y)) (x y : Subtype P) :\n    (haveI := Subtype.semilatticeInf Pinf; (x ⊓ y : Subtype P) : α) = (x ⊓ y : α) :=\n  rfl\n\n"}
{"name":"Subtype.mk_sup_mk","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeSup α\nP : α → Prop\nPsup : ∀ ⦃x y : α⦄, P x → P y → P (Max.max x y)\nx y : α\nhx : P x\nhy : P y\n⊢ Eq (Max.max ⟨x, hx⟩ ⟨y, hy⟩) ⟨Max.max x y, ⋯⟩","decl":"@[simp]\ntheorem mk_sup_mk [SemilatticeSup α] {P : α → Prop}\n    (Psup : ∀ ⦃x y⦄, P x → P y → P (x ⊔ y)) {x y : α} (hx : P x) (hy : P y) :\n    (haveI := Subtype.semilatticeSup Psup; (⟨x, hx⟩ ⊔ ⟨y, hy⟩ : Subtype P)) =\n      ⟨x ⊔ y, Psup hx hy⟩ :=\n  rfl\n\n"}
{"name":"Subtype.mk_inf_mk","module":"Mathlib.Order.Lattice","initialProofState":"α : Type u\ninst✝ : SemilatticeInf α\nP : α → Prop\nPinf : ∀ ⦃x y : α⦄, P x → P y → P (Min.min x y)\nx y : α\nhx : P x\nhy : P y\n⊢ Eq (Min.min ⟨x, hx⟩ ⟨y, hy⟩) ⟨Min.min x y, ⋯⟩","decl":"@[simp]\ntheorem mk_inf_mk [SemilatticeInf α] {P : α → Prop}\n    (Pinf : ∀ ⦃x y⦄, P x → P y → P (x ⊓ y)) {x y : α} (hx : P x) (hy : P y) :\n    (haveI := Subtype.semilatticeInf Pinf; (⟨x, hx⟩ ⊓ ⟨y, hy⟩ : Subtype P)) =\n      ⟨x ⊓ y, Pinf hx hy⟩ :=\n  rfl\n\n"}
