{"name":"AdicCompletion.ofTensorProduct_tmul","module":"Mathlib.RingTheory.AdicCompletion.AsTensorProduct","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nr : AdicCompletion I R\nx : M\n⊢ Eq ((AdicCompletion.ofTensorProduct I M) (TensorProduct.tmul R r x)) (HSMul.hSMul r ((AdicCompletion.of I M) x))","decl":"@[simp]\nlemma ofTensorProduct_tmul (r : AdicCompletion I R) (x : M) :\n    ofTensorProduct I M (r ⊗ₜ x) = r • of I M x := by\n  simp [ofTensorProduct]\n\n"}
{"name":"AdicCompletion.ofTensorProduct_naturality","module":"Mathlib.RingTheory.AdicCompletion.AsTensorProduct","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nI : Ideal R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nf : LinearMap (RingHom.id R) M N\n⊢ Eq ((AdicCompletion.map I f).comp (AdicCompletion.ofTensorProduct I M)) ((AdicCompletion.ofTensorProduct I N).comp (TensorProduct.AlgebraTensorModule.map LinearMap.id f))","decl":"variable {M} in\n/-- `ofTensorProduct` is functorial in `M`. -/\nlemma ofTensorProduct_naturality (f : M →ₗ[R] N) :\n    map I f ∘ₗ ofTensorProduct I M =\n      ofTensorProduct I N ∘ₗ AlgebraTensorModule.map LinearMap.id f := by\n  ext\n  simp\n\n"}
{"name":"AdicCompletion.ofTensorProduct_bijective_of_pi_of_fintype","module":"Mathlib.RingTheory.AdicCompletion.AsTensorProduct","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\nI : Ideal R\nι : Type u_4\ninst✝ : Finite ι\n⊢ Function.Bijective ⇑(AdicCompletion.ofTensorProduct I (ι → R))","decl":"/-- If `M = R^ι`, `ofTensorProduct` is bijective. -/\nlemma ofTensorProduct_bijective_of_pi_of_fintype [Finite ι] :\n    Function.Bijective (ofTensorProduct I (ι → R)) := by\n  classical\n  cases nonempty_fintype ι\n  exact EquivLike.bijective (ofTensorProductEquivOfPiFintype I ι)\n\n"}
{"name":"AdicCompletion.ofTensorProduct_surjective_of_finite","module":"Mathlib.RingTheory.AdicCompletion.AsTensorProduct","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nI : Ideal R\nM : Type u_2\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : Module.Finite R M\n⊢ Function.Surjective ⇑(AdicCompletion.ofTensorProduct I M)","decl":"/-- If `M` is a finite `R`-module, then the canonical map\n`AdicCompletion I R ⊗[R] M →ₗ AdicCompletion I M` is surjective. -/\nlemma ofTensorProduct_surjective_of_finite [Module.Finite R M] :\n    Function.Surjective (ofTensorProduct I M) := by\n  obtain ⟨n, p, hp⟩ := Module.Finite.exists_fin' R M\n  let f := ofTensorProduct I M ∘ₗ p.baseChange (AdicCompletion I R)\n  let g := map I p ∘ₗ ofTensorProduct I (Fin n → R)\n  have hfg : f = g := by\n    ext\n    simp [f, g]\n  have hf : Function.Surjective f := by\n    simp only [hfg, LinearMap.coe_comp, g]\n    apply Function.Surjective.comp\n    · exact AdicCompletion.map_surjective I hp\n    · exact (ofTensorProduct_bijective_of_pi_of_fintype I (Fin n)).surjective\n  exact Function.Surjective.of_comp hf\n\n"}
{"name":"AdicCompletion.ofTensorProduct_bijective_of_finite_of_isNoetherian","module":"Mathlib.RingTheory.AdicCompletion.AsTensorProduct","initialProofState":"R : Type u\ninst✝⁴ : CommRing R\nI : Ideal R\nM : Type u\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : IsNoetherianRing R\ninst✝ : Module.Finite R M\n⊢ Function.Bijective ⇑(AdicCompletion.ofTensorProduct I M)","decl":"/-- If `R` is a Noetherian ring and `M` is a finite `R`-module, then the natural map\ngiven by `AdicCompletion.ofTensorProduct` is an isomorphism. -/\ntheorem ofTensorProduct_bijective_of_finite_of_isNoetherian\n    [Module.Finite R M] :\n    Function.Bijective (ofTensorProduct I M) := by\n  obtain ⟨n, f, hf⟩ := Module.Finite.exists_fin' R M\n  exact ofTensorProduct_bijective_of_map_from_fin I M f hf\n\n"}
{"name":"AdicCompletion.ofTensorProductEquivOfFiniteNoetherian_apply","module":"Mathlib.RingTheory.AdicCompletion.AsTensorProduct","initialProofState":"R : Type u\ninst✝⁴ : CommRing R\nI : Ideal R\nM : Type u\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : IsNoetherianRing R\ninst✝ : Module.Finite R M\nx : TensorProduct R (AdicCompletion I R) M\n⊢ Eq ((AdicCompletion.ofTensorProductEquivOfFiniteNoetherian I M) x) ((AdicCompletion.ofTensorProduct I M) x)","decl":"@[simp]\nlemma ofTensorProductEquivOfFiniteNoetherian_apply [Module.Finite R M]\n    (x : AdicCompletion I R ⊗[R] M) :\n    ofTensorProductEquivOfFiniteNoetherian I M x = ofTensorProduct I M x :=\n  rfl\n\n"}
{"name":"AdicCompletion.ofTensorProductEquivOfFiniteNoetherian_symm_of","module":"Mathlib.RingTheory.AdicCompletion.AsTensorProduct","initialProofState":"R : Type u\ninst✝⁴ : CommRing R\nI : Ideal R\nM : Type u\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : IsNoetherianRing R\ninst✝ : Module.Finite R M\nx : M\n⊢ Eq ((AdicCompletion.ofTensorProductEquivOfFiniteNoetherian I M).symm ((AdicCompletion.of I M) x)) (TensorProduct.tmul R 1 x)","decl":"@[simp]\nlemma ofTensorProductEquivOfFiniteNoetherian_symm_of\n    [Module.Finite R M] (x : M) :\n    (ofTensorProductEquivOfFiniteNoetherian I M).symm ((of I M) x) = 1 ⊗ₜ x := by\n  have h : (of I M) x = ofTensorProductEquivOfFiniteNoetherian I M (1 ⊗ₜ x) := by\n    simp\n  rw [h, LinearEquiv.symm_apply_apply]\n\n"}
{"name":"AdicCompletion.tensor_map_id_left_eq_map","module":"Mathlib.RingTheory.AdicCompletion.AsTensorProduct","initialProofState":"R : Type u\ninst✝⁷ : CommRing R\nI : Ideal R\ninst✝⁶ : IsNoetherianRing R\nM : Type u\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\nN : Type u\ninst✝³ : AddCommGroup N\ninst✝² : Module R N\nf : LinearMap (RingHom.id R) M N\ninst✝¹ : Module.Finite R M\ninst✝ : Module.Finite R N\n⊢ Eq (TensorProduct.AlgebraTensorModule.map LinearMap.id f) ((↑(AdicCompletion.ofTensorProductEquivOfFiniteNoetherian I N).symm).comp ((AdicCompletion.map I f).comp ↑(AdicCompletion.ofTensorProductEquivOfFiniteNoetherian I M)))","decl":"lemma tensor_map_id_left_eq_map :\n    (AlgebraTensorModule.map LinearMap.id f) =\n      (ofTensorProductEquivOfFiniteNoetherian I N).symm.toLinearMap ∘ₗ\n      map I f ∘ₗ\n      (ofTensorProductEquivOfFiniteNoetherian I M).toLinearMap := by\n  erw [ofTensorProduct_naturality I f]\n  ext x\n  simp\n\n"}
{"name":"AdicCompletion.tensor_map_id_left_injective_of_injective","module":"Mathlib.RingTheory.AdicCompletion.AsTensorProduct","initialProofState":"R : Type u\ninst✝⁷ : CommRing R\nI : Ideal R\ninst✝⁶ : IsNoetherianRing R\nM : Type u\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\nN : Type u\ninst✝³ : AddCommGroup N\ninst✝² : Module R N\nf : LinearMap (RingHom.id R) M N\ninst✝¹ : Module.Finite R M\ninst✝ : Module.Finite R N\nhf : Function.Injective ⇑f\n⊢ Function.Injective ⇑(TensorProduct.AlgebraTensorModule.map LinearMap.id f)","decl":"lemma tensor_map_id_left_injective_of_injective (hf : Function.Injective f) :\n    Function.Injective (AlgebraTensorModule.map LinearMap.id f :\n        AdicCompletion I R ⊗[R] M →ₗ[AdicCompletion I R] AdicCompletion I R ⊗[R] N) := by\n  rw [tensor_map_id_left_eq_map I f]\n  simp only [LinearMap.coe_comp, LinearEquiv.coe_coe, EmbeddingLike.comp_injective,\n    EquivLike.injective_comp]\n  exact map_injective I hf\n\n"}
{"name":"AdicCompletion.flat_of_isNoetherian","module":"Mathlib.RingTheory.AdicCompletion.AsTensorProduct","initialProofState":"R : Type u\ninst✝¹ : CommRing R\nI : Ideal R\ninst✝ : IsNoetherianRing R\n⊢ Module.Flat R (AdicCompletion I R)","decl":"/-- Adic completion of a Noetherian ring `R` is flat over `R`. -/\ninstance flat_of_isNoetherian [IsNoetherianRing R] : Module.Flat R (AdicCompletion I R) :=\n  Module.Flat.iff_lTensor_injective'.mpr fun J ↦\n    tensor_map_id_left_injective_of_injective I (Submodule.injective_subtype J)\n\n"}
