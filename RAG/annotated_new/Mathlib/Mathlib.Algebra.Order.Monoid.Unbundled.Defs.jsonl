{"name":"CovariantClass.elim","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"M : Type u_1\nN : Type u_2\nμ : M → N → N\nr : N → N → Prop\nself : CovariantClass M N μ r\n⊢ Covariant M N μ r","decl":"/-- Given an action `μ` of a Type `M` on a Type `N` and a relation `r` on `N`, informally, the\n`CovariantClass` says that \"the action `μ` preserves the relation `r`.\"\n\nMore precisely, the `CovariantClass` is a class taking two Types `M N`, together with an \"action\"\n`μ : M → N → N` and a relation `r : N → N → Prop`.  Its unique field `elim` is the assertion that\nfor all `m ∈ M` and all elements `n₁, n₂ ∈ N`, if the relation `r` holds for the pair\n`(n₁, n₂)`, then, the relation `r` also holds for the pair `(μ m n₁, μ m n₂)`,\nobtained from `(n₁, n₂)` by acting upon it by `m`.\n\nIf `m : M` and `h : r n₁ n₂`, then `CovariantClass.elim m h : r (μ m n₁) (μ m n₂)`.\n-/\nclass CovariantClass : Prop where\n  /-- For all `m ∈ M` and all elements `n₁, n₂ ∈ N`, if the relation `r` holds for the pair\n  `(n₁, n₂)`, then, the relation `r` also holds for the pair `(μ m n₁, μ m n₂)` -/\n  protected elim : Covariant M N μ r\n\n"}
{"name":"ContravariantClass.elim","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"M : Type u_1\nN : Type u_2\nμ : M → N → N\nr : N → N → Prop\nself : ContravariantClass M N μ r\n⊢ Contravariant M N μ r","decl":"/-- Given an action `μ` of a Type `M` on a Type `N` and a relation `r` on `N`, informally, the\n`ContravariantClass` says that \"if the result of the action `μ` on a pair satisfies the\nrelation `r`, then the initial pair satisfied the relation `r`.\"\n\nMore precisely, the `ContravariantClass` is a class taking two Types `M N`, together with an\n\"action\" `μ : M → N → N` and a relation `r : N → N → Prop`.  Its unique field `elim` is the\nassertion that for all `m ∈ M` and all elements `n₁, n₂ ∈ N`, if the relation `r` holds for the\npair `(μ m n₁, μ m n₂)` obtained from `(n₁, n₂)` by acting upon it by `m`, then, the relation\n`r` also holds for the pair `(n₁, n₂)`.\n\nIf `m : M` and `h : r (μ m n₁) (μ m n₂)`, then `ContravariantClass.elim m h : r n₁ n₂`.\n-/\nclass ContravariantClass : Prop where\n  /-- For all `m ∈ M` and all elements `n₁, n₂ ∈ N`, if the relation `r` holds for the\n  pair `(μ m n₁, μ m n₂)` obtained from `(n₁, n₂)` by acting upon it by `m`, then, the relation\n  `r` also holds for the pair `(n₁, n₂)`. -/\n  protected elim : Contravariant M N μ r\n\n"}
{"name":"rel_iff_cov","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"M : Type u_1\nN : Type u_2\nμ : M → N → N\nr : N → N → Prop\ninst✝¹ : CovariantClass M N μ r\ninst✝ : ContravariantClass M N μ r\nm : M\na b : N\n⊢ Iff (r (μ m a) (μ m b)) (r a b)","decl":"theorem rel_iff_cov [CovariantClass M N μ r] [ContravariantClass M N μ r] (m : M) {a b : N} :\n    r (μ m a) (μ m b) ↔ r a b :=\n  ⟨ContravariantClass.elim _, CovariantClass.elim _⟩\n\n"}
{"name":"Covariant.flip","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"M : Type u_1\nN : Type u_2\nμ : M → N → N\nr : N → N → Prop\nh : Covariant M N μ r\n⊢ Covariant M N μ (flip r)","decl":"theorem Covariant.flip (h : Covariant M N μ r) : Covariant M N μ (flip r) :=\n  fun a _ _ ↦ h a\n\n"}
{"name":"Contravariant.flip","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"M : Type u_1\nN : Type u_2\nμ : M → N → N\nr : N → N → Prop\nh : Contravariant M N μ r\n⊢ Contravariant M N μ (flip r)","decl":"theorem Contravariant.flip (h : Contravariant M N μ r) : Contravariant M N μ (flip r) :=\n  fun a _ _ ↦ h a\n\n"}
{"name":"act_rel_act_of_rel","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"M : Type u_1\nN : Type u_2\nμ : M → N → N\nr : N → N → Prop\ninst✝ : CovariantClass M N μ r\nm : M\na b : N\nab : r a b\n⊢ r (μ m a) (μ m b)","decl":"theorem act_rel_act_of_rel (m : M) {a b : N} (ab : r a b) : r (μ m a) (μ m b) :=\n  CovariantClass.elim _ ab\n\n"}
{"name":"AddGroup.covariant_iff_contravariant","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"N : Type u_2\nr : N → N → Prop\ninst✝ : AddGroup N\n⊢ Iff (Covariant N N (fun x1 x2 => HAdd.hAdd x1 x2) r) (Contravariant N N (fun x1 x2 => HAdd.hAdd x1 x2) r)","decl":"@[to_additive]\ntheorem Group.covariant_iff_contravariant [Group N] :\n    Covariant N N (· * ·) r ↔ Contravariant N N (· * ·) r := by\n  refine ⟨fun h a b c bc ↦ ?_, fun h a b c bc ↦ ?_⟩\n  · rw [← inv_mul_cancel_left a b, ← inv_mul_cancel_left a c]\n    exact h a⁻¹ bc\n  · rw [← inv_mul_cancel_left a b, ← inv_mul_cancel_left a c] at bc\n    exact h a⁻¹ bc\n\n"}
{"name":"Group.covariant_iff_contravariant","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"N : Type u_2\nr : N → N → Prop\ninst✝ : Group N\n⊢ Iff (Covariant N N (fun x1 x2 => HMul.hMul x1 x2) r) (Contravariant N N (fun x1 x2 => HMul.hMul x1 x2) r)","decl":"@[to_additive]\ntheorem Group.covariant_iff_contravariant [Group N] :\n    Covariant N N (· * ·) r ↔ Contravariant N N (· * ·) r := by\n  refine ⟨fun h a b c bc ↦ ?_, fun h a b c bc ↦ ?_⟩\n  · rw [← inv_mul_cancel_left a b, ← inv_mul_cancel_left a c]\n    exact h a⁻¹ bc\n  · rw [← inv_mul_cancel_left a b, ← inv_mul_cancel_left a c] at bc\n    exact h a⁻¹ bc\n\n"}
{"name":"Group.covconv","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"N : Type u_2\nr : N → N → Prop\ninst✝¹ : Group N\ninst✝ : CovariantClass N N (fun x1 x2 => HMul.hMul x1 x2) r\n⊢ ContravariantClass N N (fun x1 x2 => HMul.hMul x1 x2) r","decl":"@[to_additive]\ninstance (priority := 100) Group.covconv [Group N] [CovariantClass N N (· * ·) r] :\n    ContravariantClass N N (· * ·) r :=\n  ⟨Group.covariant_iff_contravariant.mp CovariantClass.elim⟩\n\n"}
{"name":"AddGroup.covconv","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"N : Type u_2\nr : N → N → Prop\ninst✝¹ : AddGroup N\ninst✝ : CovariantClass N N (fun x1 x2 => HAdd.hAdd x1 x2) r\n⊢ ContravariantClass N N (fun x1 x2 => HAdd.hAdd x1 x2) r","decl":"@[to_additive]\ninstance (priority := 100) Group.covconv [Group N] [CovariantClass N N (· * ·) r] :\n    ContravariantClass N N (· * ·) r :=\n  ⟨Group.covariant_iff_contravariant.mp CovariantClass.elim⟩\n\n"}
{"name":"Group.mulLeftReflectLE_of_mulLeftMono","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"N : Type u_2\ninst✝² : Group N\ninst✝¹ : LE N\ninst✝ : MulLeftMono N\n⊢ MulLeftReflectLE N","decl":"@[to_additive]\ntheorem Group.mulLeftReflectLE_of_mulLeftMono [Group N] [LE N]\n    [MulLeftMono N] : MulLeftReflectLE N :=\n  inferInstance\n\n"}
{"name":"AddGroup.addLeftReflectLE_of_addLeftMono","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"N : Type u_2\ninst✝² : AddGroup N\ninst✝¹ : LE N\ninst✝ : AddLeftMono N\n⊢ AddLeftReflectLE N","decl":"@[to_additive]\ntheorem Group.mulLeftReflectLE_of_mulLeftMono [Group N] [LE N]\n    [MulLeftMono N] : MulLeftReflectLE N :=\n  inferInstance\n\n"}
{"name":"AddGroup.addLeftReflectLT_of_addLeftStrictMono","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"N : Type u_2\ninst✝² : AddGroup N\ninst✝¹ : LT N\ninst✝ : AddLeftStrictMono N\n⊢ AddLeftReflectLT N","decl":"@[to_additive]\ntheorem Group.mulLeftReflectLT_of_mulLeftStrictMono [Group N] [LT N]\n    [MulLeftStrictMono N] : MulLeftReflectLT N :=\n  inferInstance\n\n"}
{"name":"Group.mulLeftReflectLT_of_mulLeftStrictMono","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"N : Type u_2\ninst✝² : Group N\ninst✝¹ : LT N\ninst✝ : MulLeftStrictMono N\n⊢ MulLeftReflectLT N","decl":"@[to_additive]\ntheorem Group.mulLeftReflectLT_of_mulLeftStrictMono [Group N] [LT N]\n    [MulLeftStrictMono N] : MulLeftReflectLT N :=\n  inferInstance\n\n"}
{"name":"Group.covariant_swap_iff_contravariant_swap","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"N : Type u_2\nr : N → N → Prop\ninst✝ : Group N\n⊢ Iff (Covariant N N (Function.swap fun x1 x2 => HMul.hMul x1 x2) r) (Contravariant N N (Function.swap fun x1 x2 => HMul.hMul x1 x2) r)","decl":"@[to_additive]\ntheorem Group.covariant_swap_iff_contravariant_swap [Group N] :\n    Covariant N N (swap (· * ·)) r ↔ Contravariant N N (swap (· * ·)) r := by\n  refine ⟨fun h a b c bc ↦ ?_, fun h a b c bc ↦ ?_⟩\n  · rw [← mul_inv_cancel_right b a, ← mul_inv_cancel_right c a]\n    exact h a⁻¹ bc\n  · rw [← mul_inv_cancel_right b a, ← mul_inv_cancel_right c a] at bc\n    exact h a⁻¹ bc\n\n\n"}
{"name":"AddGroup.covariant_swap_iff_contravariant_swap","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"N : Type u_2\nr : N → N → Prop\ninst✝ : AddGroup N\n⊢ Iff (Covariant N N (Function.swap fun x1 x2 => HAdd.hAdd x1 x2) r) (Contravariant N N (Function.swap fun x1 x2 => HAdd.hAdd x1 x2) r)","decl":"@[to_additive]\ntheorem Group.covariant_swap_iff_contravariant_swap [Group N] :\n    Covariant N N (swap (· * ·)) r ↔ Contravariant N N (swap (· * ·)) r := by\n  refine ⟨fun h a b c bc ↦ ?_, fun h a b c bc ↦ ?_⟩\n  · rw [← mul_inv_cancel_right b a, ← mul_inv_cancel_right c a]\n    exact h a⁻¹ bc\n  · rw [← mul_inv_cancel_right b a, ← mul_inv_cancel_right c a] at bc\n    exact h a⁻¹ bc\n\n\n"}
{"name":"Group.covconv_swap","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"N : Type u_2\nr : N → N → Prop\ninst✝¹ : Group N\ninst✝ : CovariantClass N N (Function.swap fun x1 x2 => HMul.hMul x1 x2) r\n⊢ ContravariantClass N N (Function.swap fun x1 x2 => HMul.hMul x1 x2) r","decl":"@[to_additive]\ninstance (priority := 100) Group.covconv_swap [Group N] [CovariantClass N N (swap (· * ·)) r] :\n    ContravariantClass N N (swap (· * ·)) r :=\n  ⟨Group.covariant_swap_iff_contravariant_swap.mp CovariantClass.elim⟩\n\n"}
{"name":"AddGroup.covconv_swap","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"N : Type u_2\nr : N → N → Prop\ninst✝¹ : AddGroup N\ninst✝ : CovariantClass N N (Function.swap fun x1 x2 => HAdd.hAdd x1 x2) r\n⊢ ContravariantClass N N (Function.swap fun x1 x2 => HAdd.hAdd x1 x2) r","decl":"@[to_additive]\ninstance (priority := 100) Group.covconv_swap [Group N] [CovariantClass N N (swap (· * ·)) r] :\n    ContravariantClass N N (swap (· * ·)) r :=\n  ⟨Group.covariant_swap_iff_contravariant_swap.mp CovariantClass.elim⟩\n\n"}
{"name":"Group.mulRightReflectLE_of_mulRightMono","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"N : Type u_2\ninst✝² : Group N\ninst✝¹ : LE N\ninst✝ : MulRightMono N\n⊢ MulRightReflectLE N","decl":"@[to_additive]\ntheorem Group.mulRightReflectLE_of_mulRightMono [Group N] [LE N]\n    [MulRightMono N] : MulRightReflectLE N :=\n  inferInstance\n\n"}
{"name":"AddGroup.addRightReflectLE_of_addRightMono","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"N : Type u_2\ninst✝² : AddGroup N\ninst✝¹ : LE N\ninst✝ : AddRightMono N\n⊢ AddRightReflectLE N","decl":"@[to_additive]\ntheorem Group.mulRightReflectLE_of_mulRightMono [Group N] [LE N]\n    [MulRightMono N] : MulRightReflectLE N :=\n  inferInstance\n\n"}
{"name":"Group.mulRightReflectLT_of_mulRightStrictMono","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"N : Type u_2\ninst✝² : Group N\ninst✝¹ : LT N\ninst✝ : MulRightStrictMono N\n⊢ MulRightReflectLT N","decl":"@[to_additive]\ntheorem Group.mulRightReflectLT_of_mulRightStrictMono [Group N] [LT N]\n    [MulRightStrictMono N] : MulRightReflectLT N :=\n  inferInstance\n\n\n"}
{"name":"AddGroup.addRightReflectLT_of_addRightStrictMono","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"N : Type u_2\ninst✝² : AddGroup N\ninst✝¹ : LT N\ninst✝ : AddRightStrictMono N\n⊢ AddRightReflectLT N","decl":"@[to_additive]\ntheorem Group.mulRightReflectLT_of_mulRightStrictMono [Group N] [LT N]\n    [MulRightStrictMono N] : MulRightReflectLT N :=\n  inferInstance\n\n\n"}
{"name":"act_rel_of_rel_of_act_rel","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"M : Type u_1\nN : Type u_2\nμ : M → N → N\nr : N → N → Prop\ninst✝¹ : CovariantClass M N μ r\ninst✝ : IsTrans N r\nm : M\na b c : N\nab : r a b\nrl : r (μ m b) c\n⊢ r (μ m a) c","decl":"theorem act_rel_of_rel_of_act_rel (ab : r a b) (rl : r (μ m b) c) : r (μ m a) c :=\n  _root_.trans (act_rel_act_of_rel m ab) rl\n\n"}
{"name":"rel_act_of_rel_of_rel_act","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"M : Type u_1\nN : Type u_2\nμ : M → N → N\nr : N → N → Prop\ninst✝¹ : CovariantClass M N μ r\ninst✝ : IsTrans N r\nm : M\na b c : N\nab : r a b\nrr : r c (μ m a)\n⊢ r c (μ m b)","decl":"theorem rel_act_of_rel_of_rel_act (ab : r a b) (rr : r c (μ m a)) : r c (μ m b) :=\n  _root_.trans rr (act_rel_act_of_rel _ ab)\n\n"}
{"name":"act_rel_act_of_rel_of_rel","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"N : Type u_2\nr : N → N → Prop\nmu : N → N → N\ninst✝ : IsTrans N r\ni : CovariantClass N N mu r\ni' : CovariantClass N N (Function.swap mu) r\na b c d : N\nab : r a b\ncd : r c d\n⊢ r (mu a c) (mu b d)","decl":"theorem act_rel_act_of_rel_of_rel (ab : r a b) (cd : r c d) : r (mu a c) (mu b d) :=\n  _root_.trans (@act_rel_act_of_rel _ _ (swap mu) r _ c _ _ ab) (act_rel_act_of_rel b cd)\n\n"}
{"name":"rel_of_act_rel_act","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"M : Type u_1\nN : Type u_2\nμ : M → N → N\nr : N → N → Prop\ninst✝ : ContravariantClass M N μ r\nm : M\na b : N\nab : r (μ m a) (μ m b)\n⊢ r a b","decl":"theorem rel_of_act_rel_act (m : M) {a b : N} (ab : r (μ m a) (μ m b)) : r a b :=\n  ContravariantClass.elim _ ab\n\n"}
{"name":"act_rel_of_act_rel_of_rel_act_rel","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"M : Type u_1\nN : Type u_2\nμ : M → N → N\nr : N → N → Prop\ninst✝¹ : ContravariantClass M N μ r\ninst✝ : IsTrans N r\nm : M\na b c : N\nab : r (μ m a) b\nrl : r (μ m b) (μ m c)\n⊢ r (μ m a) c","decl":"theorem act_rel_of_act_rel_of_rel_act_rel (ab : r (μ m a) b) (rl : r (μ m b) (μ m c)) :\n    r (μ m a) c :=\n  _root_.trans ab (rel_of_act_rel_act m rl)\n\n"}
{"name":"rel_act_of_act_rel_act_of_rel_act","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"M : Type u_1\nN : Type u_2\nμ : M → N → N\nr : N → N → Prop\ninst✝¹ : ContravariantClass M N μ r\ninst✝ : IsTrans N r\nm : M\na b c : N\nab : r (μ m a) (μ m b)\nrr : r b (μ m c)\n⊢ r a (μ m c)","decl":"theorem rel_act_of_act_rel_act_of_rel_act (ab : r (μ m a) (μ m b)) (rr : r b (μ m c)) :\n    r a (μ m c) :=\n  _root_.trans (rel_of_act_rel_act m ab) rr\n\n"}
{"name":"Covariant.monotone_of_const","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"M : Type u_1\nN : Type u_2\nμ : M → N → N\ninst✝¹ : Preorder N\ninst✝ : CovariantClass M N μ fun x1 x2 => LE.le x1 x2\nm : M\n⊢ Monotone (μ m)","decl":"/-- The partial application of a constant to a covariant operator is monotone. -/\ntheorem Covariant.monotone_of_const [CovariantClass M N μ (· ≤ ·)] (m : M) : Monotone (μ m) :=\n  fun _ _ ↦ CovariantClass.elim m\n\n"}
{"name":"Monotone.covariant_of_const","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"M : Type u_1\nN : Type u_2\nμ : M → N → N\nα : Type u_3\ninst✝² : Preorder α\ninst✝¹ : Preorder N\nf : N → α\ninst✝ : CovariantClass M N μ fun x1 x2 => LE.le x1 x2\nhf : Monotone f\nm : M\n⊢ Monotone fun x => f (μ m x)","decl":"/-- A monotone function remains monotone when composed with the partial application\nof a covariant operator. E.g., `∀ (m : ℕ), Monotone f → Monotone (fun n ↦ f (m + n))`. -/\ntheorem Monotone.covariant_of_const [CovariantClass M N μ (· ≤ ·)] (hf : Monotone f) (m : M) :\n    Monotone (f <| μ m ·) :=\n  hf.comp (Covariant.monotone_of_const m)\n\n"}
{"name":"Monotone.covariant_of_const'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"N : Type u_2\nα : Type u_3\ninst✝² : Preorder α\ninst✝¹ : Preorder N\nf : N → α\nμ : N → N → N\ninst✝ : CovariantClass N N (Function.swap μ) fun x1 x2 => LE.le x1 x2\nhf : Monotone f\nm : N\n⊢ Monotone fun x => f (μ x m)","decl":"/-- Same as `Monotone.covariant_of_const`, but with the constant on the other side of\nthe operator.  E.g., `∀ (m : ℕ), Monotone f → Monotone (fun n ↦ f (n + m))`. -/\ntheorem Monotone.covariant_of_const' {μ : N → N → N} [CovariantClass N N (swap μ) (· ≤ ·)]\n    (hf : Monotone f) (m : N) : Monotone (f <| μ · m) :=\n  Monotone.covariant_of_const (μ := swap μ) hf m\n\n"}
{"name":"Antitone.covariant_of_const","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"M : Type u_1\nN : Type u_2\nμ : M → N → N\nα : Type u_3\ninst✝² : Preorder α\ninst✝¹ : Preorder N\nf : N → α\ninst✝ : CovariantClass M N μ fun x1 x2 => LE.le x1 x2\nhf : Antitone f\nm : M\n⊢ Antitone fun x => f (μ m x)","decl":"/-- Dual of `Monotone.covariant_of_const` -/\ntheorem Antitone.covariant_of_const [CovariantClass M N μ (· ≤ ·)] (hf : Antitone f) (m : M) :\n    Antitone (f <| μ m ·) :=\n  hf.comp_monotone <| Covariant.monotone_of_const m\n\n"}
{"name":"Antitone.covariant_of_const'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"N : Type u_2\nα : Type u_3\ninst✝² : Preorder α\ninst✝¹ : Preorder N\nf : N → α\nμ : N → N → N\ninst✝ : CovariantClass N N (Function.swap μ) fun x1 x2 => LE.le x1 x2\nhf : Antitone f\nm : N\n⊢ Antitone fun x => f (μ x m)","decl":"/-- Dual of `Monotone.covariant_of_const'` -/\ntheorem Antitone.covariant_of_const' {μ : N → N → N} [CovariantClass N N (swap μ) (· ≤ ·)]\n    (hf : Antitone f) (m : N) : Antitone (f <| μ · m) :=\n  Antitone.covariant_of_const (μ := swap μ) hf m\n\n"}
{"name":"covariant_le_of_covariant_lt","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"M : Type u_1\nN : Type u_2\nμ : M → N → N\ninst✝ : PartialOrder N\na✝ : Covariant M N μ fun x1 x2 => LT.lt x1 x2\n⊢ Covariant M N μ fun x1 x2 => LE.le x1 x2","decl":"theorem covariant_le_of_covariant_lt [PartialOrder N] :\n    Covariant M N μ (· < ·) → Covariant M N μ (· ≤ ·) := by\n  intro h a b c bc\n  rcases bc.eq_or_lt with (rfl | bc)\n  · exact le_rfl\n  · exact (h _ bc).le\n\n"}
{"name":"covariantClass_le_of_lt","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"M : Type u_1\nN : Type u_2\nμ : M → N → N\ninst✝¹ : PartialOrder N\ninst✝ : CovariantClass M N μ fun x1 x2 => LT.lt x1 x2\n⊢ CovariantClass M N μ fun x1 x2 => LE.le x1 x2","decl":"theorem covariantClass_le_of_lt [PartialOrder N] [CovariantClass M N μ (· < ·)] :\n    CovariantClass M N μ (· ≤ ·) := ⟨covariant_le_of_covariant_lt _ _ _ CovariantClass.elim⟩\n\n"}
{"name":"mulLeftMono_of_mulLeftStrictMono","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"M : Type u_3\ninst✝² : Mul M\ninst✝¹ : PartialOrder M\ninst✝ : MulLeftStrictMono M\n⊢ MulLeftMono M","decl":"@[to_additive]\ntheorem mulLeftMono_of_mulLeftStrictMono (M) [Mul M] [PartialOrder M] [MulLeftStrictMono M] :\n    MulLeftMono M := covariantClass_le_of_lt _ _ _\n\n"}
{"name":"addLeftMono_of_addLeftStrictMono","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"M : Type u_3\ninst✝² : Add M\ninst✝¹ : PartialOrder M\ninst✝ : AddLeftStrictMono M\n⊢ AddLeftMono M","decl":"@[to_additive]\ntheorem mulLeftMono_of_mulLeftStrictMono (M) [Mul M] [PartialOrder M] [MulLeftStrictMono M] :\n    MulLeftMono M := covariantClass_le_of_lt _ _ _\n\n"}
{"name":"addRightMono_of_addRightStrictMono","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"M : Type u_3\ninst✝² : Add M\ninst✝¹ : PartialOrder M\ninst✝ : AddRightStrictMono M\n⊢ AddRightMono M","decl":"@[to_additive]\ntheorem mulRightMono_of_mulRightStrictMono (M) [Mul M] [PartialOrder M] [MulRightStrictMono M] :\n    MulRightMono M := covariantClass_le_of_lt _ _ _\n\n"}
{"name":"mulRightMono_of_mulRightStrictMono","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"M : Type u_3\ninst✝² : Mul M\ninst✝¹ : PartialOrder M\ninst✝ : MulRightStrictMono M\n⊢ MulRightMono M","decl":"@[to_additive]\ntheorem mulRightMono_of_mulRightStrictMono (M) [Mul M] [PartialOrder M] [MulRightStrictMono M] :\n    MulRightMono M := covariantClass_le_of_lt _ _ _\n\n"}
{"name":"contravariant_le_iff_contravariant_lt_and_eq","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"M : Type u_1\nN : Type u_2\nμ : M → N → N\ninst✝ : PartialOrder N\n⊢ Iff (Contravariant M N μ fun x1 x2 => LE.le x1 x2) (And (Contravariant M N μ fun x1 x2 => LT.lt x1 x2) (Contravariant M N μ fun x1 x2 => Eq x1 x2))","decl":"theorem contravariant_le_iff_contravariant_lt_and_eq [PartialOrder N] :\n    Contravariant M N μ (· ≤ ·) ↔ Contravariant M N μ (· < ·) ∧ Contravariant M N μ (· = ·) := by\n  refine ⟨fun h ↦ ⟨fun a b c bc ↦ ?_, fun a b c bc ↦ ?_⟩, fun h ↦ fun a b c bc ↦ ?_⟩\n  · exact (h a bc.le).lt_of_ne (by rintro rfl; exact lt_irrefl _ bc)\n  · exact (h a bc.le).antisymm (h a bc.ge)\n  · exact bc.lt_or_eq.elim (fun bc ↦ (h.1 a bc).le) (fun bc ↦ (h.2 a bc).le)\n\n"}
{"name":"contravariant_lt_of_contravariant_le","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"M : Type u_1\nN : Type u_2\nμ : M → N → N\ninst✝ : PartialOrder N\na✝ : Contravariant M N μ fun x1 x2 => LE.le x1 x2\n⊢ Contravariant M N μ fun x1 x2 => LT.lt x1 x2","decl":"theorem contravariant_lt_of_contravariant_le [PartialOrder N] :\n    Contravariant M N μ (· ≤ ·) → Contravariant M N μ (· < ·) :=\n  And.left ∘ (contravariant_le_iff_contravariant_lt_and_eq M N μ).mp\n\n"}
{"name":"covariant_le_iff_contravariant_lt","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"M : Type u_1\nN : Type u_2\nμ : M → N → N\ninst✝ : LinearOrder N\n⊢ Iff (Covariant M N μ fun x1 x2 => LE.le x1 x2) (Contravariant M N μ fun x1 x2 => LT.lt x1 x2)","decl":"theorem covariant_le_iff_contravariant_lt [LinearOrder N] :\n    Covariant M N μ (· ≤ ·) ↔ Contravariant M N μ (· < ·) :=\n  ⟨fun h _ _ _ bc ↦ not_le.mp fun k ↦ bc.not_le (h _ k),\n   fun h _ _ _ bc ↦ not_lt.mp fun k ↦ bc.not_lt (h _ k)⟩\n\n"}
{"name":"covariant_lt_iff_contravariant_le","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"M : Type u_1\nN : Type u_2\nμ : M → N → N\ninst✝ : LinearOrder N\n⊢ Iff (Covariant M N μ fun x1 x2 => LT.lt x1 x2) (Contravariant M N μ fun x1 x2 => LE.le x1 x2)","decl":"theorem covariant_lt_iff_contravariant_le [LinearOrder N] :\n    Covariant M N μ (· < ·) ↔ Contravariant M N μ (· ≤ ·) :=\n  ⟨fun h _ _ _ bc ↦ not_lt.mp fun k ↦ bc.not_lt (h _ k),\n   fun h _ _ _ bc ↦ not_le.mp fun k ↦ bc.not_le (h _ k)⟩\n\n"}
{"name":"covariant_flip_iff","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"N : Type u_2\nr : N → N → Prop\nmu : N → N → N\nh : Std.Commutative mu\n⊢ Iff (Covariant N N (flip mu) r) (Covariant N N mu r)","decl":"theorem covariant_flip_iff [h : Std.Commutative mu] :\n    Covariant N N (flip mu) r ↔ Covariant N N mu r := by unfold flip; simp_rw [h.comm]\n\n"}
{"name":"contravariant_flip_iff","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"N : Type u_2\nr : N → N → Prop\nmu : N → N → N\nh : Std.Commutative mu\n⊢ Iff (Contravariant N N (flip mu) r) (Contravariant N N mu r)","decl":"theorem contravariant_flip_iff [h : Std.Commutative mu] :\n    Contravariant N N (flip mu) r ↔ Contravariant N N mu r := by unfold flip; simp_rw [h.comm]\n\n"}
{"name":"contravariant_lt_of_covariant_le","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"N : Type u_2\nmu : N → N → N\ninst✝¹ : LinearOrder N\ninst✝ : CovariantClass N N mu fun x1 x2 => LE.le x1 x2\n⊢ ContravariantClass N N mu fun x1 x2 => LT.lt x1 x2","decl":"instance contravariant_lt_of_covariant_le [LinearOrder N]\n    [CovariantClass N N mu (· ≤ ·)] : ContravariantClass N N mu (· < ·) where\n  elim := (covariant_le_iff_contravariant_lt N N mu).mp CovariantClass.elim\n\n"}
{"name":"addLeftReflectLT_of_addLeftMono","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"N : Type u_2\ninst✝² : Add N\ninst✝¹ : LinearOrder N\ninst✝ : AddLeftMono N\n⊢ AddLeftReflectLT N","decl":"@[to_additive]\ntheorem mulLeftReflectLT_of_mulLeftMono [Mul N] [LinearOrder N] [MulLeftMono N] :\n    MulLeftReflectLT N :=\n  inferInstance\n\n"}
{"name":"mulLeftReflectLT_of_mulLeftMono","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"N : Type u_2\ninst✝² : Mul N\ninst✝¹ : LinearOrder N\ninst✝ : MulLeftMono N\n⊢ MulLeftReflectLT N","decl":"@[to_additive]\ntheorem mulLeftReflectLT_of_mulLeftMono [Mul N] [LinearOrder N] [MulLeftMono N] :\n    MulLeftReflectLT N :=\n  inferInstance\n\n"}
{"name":"mulRightReflectLT_of_mulRightMono","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"N : Type u_2\ninst✝² : Mul N\ninst✝¹ : LinearOrder N\ninst✝ : MulRightMono N\n⊢ MulRightReflectLT N","decl":"@[to_additive]\ntheorem mulRightReflectLT_of_mulRightMono [Mul N] [LinearOrder N] [MulRightMono N] :\n    MulRightReflectLT N :=\n  inferInstance\n\n"}
{"name":"addRightReflectLT_of_addRightMono","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"N : Type u_2\ninst✝² : Add N\ninst✝¹ : LinearOrder N\ninst✝ : AddRightMono N\n⊢ AddRightReflectLT N","decl":"@[to_additive]\ntheorem mulRightReflectLT_of_mulRightMono [Mul N] [LinearOrder N] [MulRightMono N] :\n    MulRightReflectLT N :=\n  inferInstance\n\n"}
{"name":"covariant_lt_of_contravariant_le","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"N : Type u_2\nmu : N → N → N\ninst✝¹ : LinearOrder N\ninst✝ : ContravariantClass N N mu fun x1 x2 => LE.le x1 x2\n⊢ CovariantClass N N mu fun x1 x2 => LT.lt x1 x2","decl":"instance covariant_lt_of_contravariant_le [LinearOrder N]\n    [ContravariantClass N N mu (· ≤ ·)] : CovariantClass N N mu (· < ·) where\n  elim := (covariant_lt_iff_contravariant_le N N mu).mpr ContravariantClass.elim\n\n"}
{"name":"mulLeftStrictMono_of_mulLeftReflectLE","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"N : Type u_2\ninst✝² : Mul N\ninst✝¹ : LinearOrder N\ninst✝ : MulLeftReflectLE N\n⊢ MulLeftStrictMono N","decl":"@[to_additive]\ntheorem mulLeftStrictMono_of_mulLeftReflectLE [Mul N] [LinearOrder N] [MulLeftReflectLE N] :\n    MulLeftStrictMono N :=\n  inferInstance\n\n"}
{"name":"addLeftStrictMono_of_addLeftReflectLE","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"N : Type u_2\ninst✝² : Add N\ninst✝¹ : LinearOrder N\ninst✝ : AddLeftReflectLE N\n⊢ AddLeftStrictMono N","decl":"@[to_additive]\ntheorem mulLeftStrictMono_of_mulLeftReflectLE [Mul N] [LinearOrder N] [MulLeftReflectLE N] :\n    MulLeftStrictMono N :=\n  inferInstance\n\n"}
{"name":"addRightStrictMono_of_addRightReflectLE","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"N : Type u_2\ninst✝² : Add N\ninst✝¹ : LinearOrder N\ninst✝ : AddRightReflectLE N\n⊢ AddRightStrictMono N","decl":"@[to_additive]\ntheorem mulRightStrictMono_of_mulRightReflectLE [Mul N] [LinearOrder N] [MulRightReflectLE N] :\n    MulRightStrictMono N :=\n  inferInstance\n\n"}
{"name":"mulRightStrictMono_of_mulRightReflectLE","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"N : Type u_2\ninst✝² : Mul N\ninst✝¹ : LinearOrder N\ninst✝ : MulRightReflectLE N\n⊢ MulRightStrictMono N","decl":"@[to_additive]\ntheorem mulRightStrictMono_of_mulRightReflectLE [Mul N] [LinearOrder N] [MulRightReflectLE N] :\n    MulRightStrictMono N :=\n  inferInstance\n\n"}
{"name":"covariant_swap_mul_of_covariant_mul","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"N : Type u_2\nr : N → N → Prop\ninst✝¹ : CommSemigroup N\ninst✝ : CovariantClass N N (fun x1 x2 => HMul.hMul x1 x2) r\n⊢ CovariantClass N N (Function.swap fun x1 x2 => HMul.hMul x1 x2) r","decl":"@[to_additive]\ninstance covariant_swap_mul_of_covariant_mul [CommSemigroup N]\n    [CovariantClass N N (· * ·) r] : CovariantClass N N (swap (· * ·)) r where\n  elim := (covariant_flip_iff N r (· * ·)).mpr CovariantClass.elim\n\n"}
{"name":"covariant_swap_add_of_covariant_add","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"N : Type u_2\nr : N → N → Prop\ninst✝¹ : AddCommSemigroup N\ninst✝ : CovariantClass N N (fun x1 x2 => HAdd.hAdd x1 x2) r\n⊢ CovariantClass N N (Function.swap fun x1 x2 => HAdd.hAdd x1 x2) r","decl":"@[to_additive]\ninstance covariant_swap_mul_of_covariant_mul [CommSemigroup N]\n    [CovariantClass N N (· * ·) r] : CovariantClass N N (swap (· * ·)) r where\n  elim := (covariant_flip_iff N r (· * ·)).mpr CovariantClass.elim\n\n"}
{"name":"addRightMono_of_addLeftMono","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"N : Type u_2\ninst✝² : AddCommSemigroup N\ninst✝¹ : LE N\ninst✝ : AddLeftMono N\n⊢ AddRightMono N","decl":"@[to_additive]\ntheorem mulRightMono_of_mulLeftMono [CommSemigroup N] [LE N] [MulLeftMono N] :\n    MulRightMono N :=\n  inferInstance\n\n"}
{"name":"mulRightMono_of_mulLeftMono","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"N : Type u_2\ninst✝² : CommSemigroup N\ninst✝¹ : LE N\ninst✝ : MulLeftMono N\n⊢ MulRightMono N","decl":"@[to_additive]\ntheorem mulRightMono_of_mulLeftMono [CommSemigroup N] [LE N] [MulLeftMono N] :\n    MulRightMono N :=\n  inferInstance\n\n"}
{"name":"addRightStrictMono_of_addLeftStrictMono","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"N : Type u_2\ninst✝² : AddCommSemigroup N\ninst✝¹ : LT N\ninst✝ : AddLeftStrictMono N\n⊢ AddRightStrictMono N","decl":"@[to_additive]\ntheorem mulRightStrictMono_of_mulLeftStrictMono [CommSemigroup N] [LT N] [MulLeftStrictMono N] :\n    MulRightStrictMono N :=\n  inferInstance\n\n"}
{"name":"mulRightStrictMono_of_mulLeftStrictMono","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"N : Type u_2\ninst✝² : CommSemigroup N\ninst✝¹ : LT N\ninst✝ : MulLeftStrictMono N\n⊢ MulRightStrictMono N","decl":"@[to_additive]\ntheorem mulRightStrictMono_of_mulLeftStrictMono [CommSemigroup N] [LT N] [MulLeftStrictMono N] :\n    MulRightStrictMono N :=\n  inferInstance\n\n"}
{"name":"contravariant_swap_add_of_contravariant_add","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"N : Type u_2\nr : N → N → Prop\ninst✝¹ : AddCommSemigroup N\ninst✝ : ContravariantClass N N (fun x1 x2 => HAdd.hAdd x1 x2) r\n⊢ ContravariantClass N N (Function.swap fun x1 x2 => HAdd.hAdd x1 x2) r","decl":"@[to_additive]\ninstance contravariant_swap_mul_of_contravariant_mul [CommSemigroup N]\n    [ContravariantClass N N (· * ·) r] : ContravariantClass N N (swap (· * ·)) r where\n  elim := (contravariant_flip_iff N r (· * ·)).mpr ContravariantClass.elim\n\n"}
{"name":"contravariant_swap_mul_of_contravariant_mul","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"N : Type u_2\nr : N → N → Prop\ninst✝¹ : CommSemigroup N\ninst✝ : ContravariantClass N N (fun x1 x2 => HMul.hMul x1 x2) r\n⊢ ContravariantClass N N (Function.swap fun x1 x2 => HMul.hMul x1 x2) r","decl":"@[to_additive]\ninstance contravariant_swap_mul_of_contravariant_mul [CommSemigroup N]\n    [ContravariantClass N N (· * ·) r] : ContravariantClass N N (swap (· * ·)) r where\n  elim := (contravariant_flip_iff N r (· * ·)).mpr ContravariantClass.elim\n\n"}
{"name":"addRightReflectLE_of_addLeftReflectLE","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"N : Type u_2\ninst✝² : AddCommSemigroup N\ninst✝¹ : LE N\ninst✝ : AddLeftReflectLE N\n⊢ AddRightReflectLE N","decl":"@[to_additive]\ntheorem mulRightReflectLE_of_mulLeftReflectLE [CommSemigroup N] [LE N] [MulLeftReflectLE N] :\n    MulRightReflectLE N :=\n  inferInstance\n\n"}
{"name":"mulRightReflectLE_of_mulLeftReflectLE","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"N : Type u_2\ninst✝² : CommSemigroup N\ninst✝¹ : LE N\ninst✝ : MulLeftReflectLE N\n⊢ MulRightReflectLE N","decl":"@[to_additive]\ntheorem mulRightReflectLE_of_mulLeftReflectLE [CommSemigroup N] [LE N] [MulLeftReflectLE N] :\n    MulRightReflectLE N :=\n  inferInstance\n\n"}
{"name":"addRightReflectLT_of_addLeftReflectLT","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"N : Type u_2\ninst✝² : AddCommSemigroup N\ninst✝¹ : LT N\ninst✝ : AddLeftReflectLT N\n⊢ AddRightReflectLT N","decl":"@[to_additive]\ntheorem mulRightReflectLT_of_mulLeftReflectLT [CommSemigroup N] [LT N] [MulLeftReflectLT N] :\n    MulRightReflectLT N :=\n  inferInstance\n\n"}
{"name":"mulRightReflectLT_of_mulLeftReflectLT","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"N : Type u_2\ninst✝² : CommSemigroup N\ninst✝¹ : LT N\ninst✝ : MulLeftReflectLT N\n⊢ MulRightReflectLT N","decl":"@[to_additive]\ntheorem mulRightReflectLT_of_mulLeftReflectLT [CommSemigroup N] [LT N] [MulLeftReflectLT N] :\n    MulRightReflectLT N :=\n  inferInstance\n\n"}
{"name":"covariant_lt_of_covariant_le_of_contravariant_eq","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"M : Type u_1\nN : Type u_2\nμ : M → N → N\ninst✝² : ContravariantClass M N μ fun x1 x2 => Eq x1 x2\ninst✝¹ : PartialOrder N\ninst✝ : CovariantClass M N μ fun x1 x2 => LE.le x1 x2\n⊢ CovariantClass M N μ fun x1 x2 => LT.lt x1 x2","decl":"theorem covariant_lt_of_covariant_le_of_contravariant_eq [ContravariantClass M N μ (· = ·)]\n    [PartialOrder N] [CovariantClass M N μ (· ≤ ·)] : CovariantClass M N μ (· < ·) where\n  elim a _ _ bc := (CovariantClass.elim a bc.le).lt_of_ne (bc.ne ∘ ContravariantClass.elim _)\n\n"}
{"name":"contravariant_le_of_contravariant_eq_and_lt","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"M : Type u_1\nN : Type u_2\nμ : M → N → N\ninst✝² : PartialOrder N\ninst✝¹ : ContravariantClass M N μ fun x1 x2 => Eq x1 x2\ninst✝ : ContravariantClass M N μ fun x1 x2 => LT.lt x1 x2\n⊢ ContravariantClass M N μ fun x1 x2 => LE.le x1 x2","decl":"theorem contravariant_le_of_contravariant_eq_and_lt [PartialOrder N]\n    [ContravariantClass M N μ (· = ·)] [ContravariantClass M N μ (· < ·)] :\n    ContravariantClass M N μ (· ≤ ·) where\n  elim := (contravariant_le_iff_contravariant_lt_and_eq M N μ).mpr\n    ⟨ContravariantClass.elim, ContravariantClass.elim⟩\n\n/- TODO:\n  redefine `IsLeftCancel N mu` as abbrev of `ContravariantClass N N mu (· = ·)`,\n  redefine `IsRightCancel N mu` as abbrev of `ContravariantClass N N (flip mu) (· = ·)`,\n  redefine `IsLeftCancelMul` as abbrev of `IsLeftCancel`,\n  then the following four instances (actually eight) can be removed in favor of the above two. -/\n\n"}
{"name":"IsLeftCancelAdd.addLeftStrictMono_of_addLeftMono","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"N : Type u_2\ninst✝³ : Add N\ninst✝² : IsLeftCancelAdd N\ninst✝¹ : PartialOrder N\ninst✝ : AddLeftMono N\n⊢ AddLeftStrictMono N","decl":"@[to_additive]\ninstance IsLeftCancelMul.mulLeftStrictMono_of_mulLeftMono [Mul N] [IsLeftCancelMul N]\n    [PartialOrder N] [MulLeftMono N] :\n    MulLeftStrictMono N where\n  elim a _ _ bc := (CovariantClass.elim a bc.le).lt_of_ne ((mul_ne_mul_right a).mpr bc.ne)\n\n"}
{"name":"IsLeftCancelMul.mulLeftStrictMono_of_mulLeftMono","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"N : Type u_2\ninst✝³ : Mul N\ninst✝² : IsLeftCancelMul N\ninst✝¹ : PartialOrder N\ninst✝ : MulLeftMono N\n⊢ MulLeftStrictMono N","decl":"@[to_additive]\ninstance IsLeftCancelMul.mulLeftStrictMono_of_mulLeftMono [Mul N] [IsLeftCancelMul N]\n    [PartialOrder N] [MulLeftMono N] :\n    MulLeftStrictMono N where\n  elim a _ _ bc := (CovariantClass.elim a bc.le).lt_of_ne ((mul_ne_mul_right a).mpr bc.ne)\n\n"}
{"name":"IsRightCancelAdd.addRightStrictMono_of_addRightMono","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"N : Type u_2\ninst✝³ : Add N\ninst✝² : IsRightCancelAdd N\ninst✝¹ : PartialOrder N\ninst✝ : AddRightMono N\n⊢ AddRightStrictMono N","decl":"@[to_additive]\ninstance IsRightCancelMul.mulRightStrictMono_of_mulRightMono\n    [Mul N] [IsRightCancelMul N] [PartialOrder N] [MulRightMono N] :\n    MulRightStrictMono N where\n  elim a _ _ bc := (CovariantClass.elim a bc.le).lt_of_ne ((mul_ne_mul_left a).mpr bc.ne)\n\n"}
{"name":"IsRightCancelMul.mulRightStrictMono_of_mulRightMono","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"N : Type u_2\ninst✝³ : Mul N\ninst✝² : IsRightCancelMul N\ninst✝¹ : PartialOrder N\ninst✝ : MulRightMono N\n⊢ MulRightStrictMono N","decl":"@[to_additive]\ninstance IsRightCancelMul.mulRightStrictMono_of_mulRightMono\n    [Mul N] [IsRightCancelMul N] [PartialOrder N] [MulRightMono N] :\n    MulRightStrictMono N where\n  elim a _ _ bc := (CovariantClass.elim a bc.le).lt_of_ne ((mul_ne_mul_left a).mpr bc.ne)\n\n"}
{"name":"IsLeftCancelMul.mulLeftReflectLE_of_mulLeftReflectLT","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"N : Type u_2\ninst✝³ : Mul N\ninst✝² : IsLeftCancelMul N\ninst✝¹ : PartialOrder N\ninst✝ : MulLeftReflectLT N\n⊢ MulLeftReflectLE N","decl":"@[to_additive]\ninstance IsLeftCancelMul.mulLeftReflectLE_of_mulLeftReflectLT [Mul N] [IsLeftCancelMul N]\n    [PartialOrder N] [MulLeftReflectLT N] :\n    MulLeftReflectLE N where\n  elim := (contravariant_le_iff_contravariant_lt_and_eq N N _).mpr\n    ⟨ContravariantClass.elim, fun _ ↦ mul_left_cancel⟩\n\n"}
{"name":"IsLeftCancelAdd.addLeftReflectLE_of_addLeftReflectLT","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"N : Type u_2\ninst✝³ : Add N\ninst✝² : IsLeftCancelAdd N\ninst✝¹ : PartialOrder N\ninst✝ : AddLeftReflectLT N\n⊢ AddLeftReflectLE N","decl":"@[to_additive]\ninstance IsLeftCancelMul.mulLeftReflectLE_of_mulLeftReflectLT [Mul N] [IsLeftCancelMul N]\n    [PartialOrder N] [MulLeftReflectLT N] :\n    MulLeftReflectLE N where\n  elim := (contravariant_le_iff_contravariant_lt_and_eq N N _).mpr\n    ⟨ContravariantClass.elim, fun _ ↦ mul_left_cancel⟩\n\n"}
{"name":"IsRightCancelAdd.addRightReflectLE_of_addRightReflectLT","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"N : Type u_2\ninst✝³ : Add N\ninst✝² : IsRightCancelAdd N\ninst✝¹ : PartialOrder N\ninst✝ : AddRightReflectLT N\n⊢ AddRightReflectLE N","decl":"@[to_additive]\ninstance IsRightCancelMul.mulRightReflectLE_of_mulRightReflectLT\n    [Mul N] [IsRightCancelMul N] [PartialOrder N] [MulRightReflectLT N] :\n    MulRightReflectLE N where\n  elim := (contravariant_le_iff_contravariant_lt_and_eq N N _).mpr\n    ⟨ContravariantClass.elim, fun _ ↦ mul_right_cancel⟩\n\n"}
{"name":"IsRightCancelMul.mulRightReflectLE_of_mulRightReflectLT","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Defs","initialProofState":"N : Type u_2\ninst✝³ : Mul N\ninst✝² : IsRightCancelMul N\ninst✝¹ : PartialOrder N\ninst✝ : MulRightReflectLT N\n⊢ MulRightReflectLE N","decl":"@[to_additive]\ninstance IsRightCancelMul.mulRightReflectLE_of_mulRightReflectLT\n    [Mul N] [IsRightCancelMul N] [PartialOrder N] [MulRightReflectLT N] :\n    MulRightReflectLE N where\n  elim := (contravariant_le_iff_contravariant_lt_and_eq N N _).mpr\n    ⟨ContravariantClass.elim, fun _ ↦ mul_right_cancel⟩\n\n"}
