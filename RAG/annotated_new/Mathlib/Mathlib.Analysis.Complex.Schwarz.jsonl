{"name":"Complex.schwarz_aux","module":"Mathlib.Analysis.Complex.Schwarz","initialProofState":"R‚ÇÅ R‚ÇÇ : Real\nc z : Complex\nf : Complex ‚Üí Complex\nhd : DifferentiableOn Complex f (Metric.ball c R‚ÇÅ)\nh_maps : Set.MapsTo f (Metric.ball c R‚ÇÅ) (Metric.ball (f c) R‚ÇÇ)\nhz : Membership.mem (Metric.ball c R‚ÇÅ) z\n‚ä¢ LE.le (Norm.norm (dslope f c z)) (HDiv.hDiv R‚ÇÇ R‚ÇÅ)","decl":"/-- An auxiliary lemma for `Complex.norm_dslope_le_div_of_mapsTo_ball`. -/\ntheorem schwarz_aux {f : ‚ÑÇ ‚Üí ‚ÑÇ} (hd : DifferentiableOn ‚ÑÇ f (ball c R‚ÇÅ))\n    (h_maps : MapsTo f (ball c R‚ÇÅ) (ball (f c) R‚ÇÇ)) (hz : z ‚àà ball c R‚ÇÅ) :\n    ‚Äñdslope f c z‚Äñ ‚â§ R‚ÇÇ / R‚ÇÅ := by\n  have hR‚ÇÅ : 0 < R‚ÇÅ := nonempty_ball.1 ‚ü®z, hz‚ü©\n  suffices ‚àÄ·∂† r in ùìù[<] R‚ÇÅ, ‚Äñdslope f c z‚Äñ ‚â§ R‚ÇÇ / r by\n    refine ge_of_tendsto ?_ this\n    exact (tendsto_const_nhds.div tendsto_id hR‚ÇÅ.ne').mono_left nhdsWithin_le_nhds\n  rw [mem_ball] at hz\n  filter_upwards [Ioo_mem_nhdsLT hz] with r hr\n  have hr‚ÇÄ : 0 < r := dist_nonneg.trans_lt hr.1\n  replace hd : DiffContOnCl ‚ÑÇ (dslope f c) (ball c r) := by\n    refine DifferentiableOn.diffContOnCl ?_\n    rw [closure_ball c hr‚ÇÄ.ne']\n    exact ((differentiableOn_dslope <| ball_mem_nhds _ hR‚ÇÅ).mpr hd).mono\n      (closedBall_subset_ball hr.2)\n  refine norm_le_of_forall_mem_frontier_norm_le isBounded_ball hd ?_ ?_\n  ¬∑ rw [frontier_ball c hr‚ÇÄ.ne']\n    intro z hz\n    have hz' : z ‚â† c := ne_of_mem_sphere hz hr‚ÇÄ.ne'\n    rw [dslope_of_ne _ hz', slope_def_module, norm_smul, norm_inv, mem_sphere_iff_norm.1 hz, ‚Üê\n      div_eq_inv_mul, div_le_div_iff_of_pos_right hr‚ÇÄ, ‚Üê dist_eq_norm]\n    exact le_of_lt (h_maps (mem_ball.2 (by rw [mem_sphere.1 hz]; exact hr.2)))\n  ¬∑ rw [closure_ball c hr‚ÇÄ.ne', mem_closedBall]\n    exact hr.1.le\n\n"}
{"name":"Complex.norm_dslope_le_div_of_mapsTo_ball","module":"Mathlib.Analysis.Complex.Schwarz","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nR‚ÇÅ R‚ÇÇ : Real\nf : Complex ‚Üí E\nc z : Complex\nhd : DifferentiableOn Complex f (Metric.ball c R‚ÇÅ)\nh_maps : Set.MapsTo f (Metric.ball c R‚ÇÅ) (Metric.ball (f c) R‚ÇÇ)\nhz : Membership.mem (Metric.ball c R‚ÇÅ) z\n‚ä¢ LE.le (Norm.norm (dslope f c z)) (HDiv.hDiv R‚ÇÇ R‚ÇÅ)","decl":"/-- Two cases of the **Schwarz Lemma** (derivative and distance), merged together. -/\ntheorem norm_dslope_le_div_of_mapsTo_ball (hd : DifferentiableOn ‚ÑÇ f (ball c R‚ÇÅ))\n    (h_maps : MapsTo f (ball c R‚ÇÅ) (ball (f c) R‚ÇÇ)) (hz : z ‚àà ball c R‚ÇÅ) :\n    ‚Äñdslope f c z‚Äñ ‚â§ R‚ÇÇ / R‚ÇÅ := by\n  have hR‚ÇÅ : 0 < R‚ÇÅ := nonempty_ball.1 ‚ü®z, hz‚ü©\n  have hR‚ÇÇ : 0 < R‚ÇÇ := nonempty_ball.1 ‚ü®f z, h_maps hz‚ü©\n  rcases eq_or_ne (dslope f c z) 0 with hc | hc\n  ¬∑ rw [hc, norm_zero]; exact div_nonneg hR‚ÇÇ.le hR‚ÇÅ.le\n  rcases exists_dual_vector ‚ÑÇ _ hc with ‚ü®g, hg, hgf‚ü©\n  have hg' : ‚Äñg‚Äñ‚Çä = 1 := NNReal.eq hg\n  have hg‚ÇÄ : ‚Äñg‚Äñ‚Çä ‚â† 0 := by simpa only [hg'] using one_ne_zero\n  calc\n    ‚Äñdslope f c z‚Äñ = ‚Äñdslope (g ‚àò f) c z‚Äñ := by\n      rw [g.dslope_comp, hgf, RCLike.norm_ofReal, abs_norm]\n      exact fun _ => hd.differentiableAt (ball_mem_nhds _ hR‚ÇÅ)\n    _ ‚â§ R‚ÇÇ / R‚ÇÅ := by\n      refine schwarz_aux (g.differentiable.comp_differentiableOn hd) (MapsTo.comp ?_ h_maps) hz\n      simpa only [hg', NNReal.coe_one, one_mul] using g.lipschitz.mapsTo_ball hg‚ÇÄ (f c) R‚ÇÇ\n\n"}
{"name":"Complex.affine_of_mapsTo_ball_of_exists_norm_dslope_eq_div","module":"Mathlib.Analysis.Complex.Schwarz","initialProofState":"E : Type u_1\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Complex E\nR‚ÇÅ R‚ÇÇ : Real\nf : Complex ‚Üí E\nc z‚ÇÄ : Complex\ninst‚úù¬π : CompleteSpace E\ninst‚úù : StrictConvexSpace Real E\nhd : DifferentiableOn Complex f (Metric.ball c R‚ÇÅ)\nh_maps : Set.MapsTo f (Metric.ball c R‚ÇÅ) (Metric.ball (f c) R‚ÇÇ)\nh_z‚ÇÄ : Membership.mem (Metric.ball c R‚ÇÅ) z‚ÇÄ\nh_eq : Eq (Norm.norm (dslope f c z‚ÇÄ)) (HDiv.hDiv R‚ÇÇ R‚ÇÅ)\n‚ä¢ Set.EqOn f (fun z => HAdd.hAdd (f c) (HSMul.hSMul (HSub.hSub z c) (dslope f c z‚ÇÄ))) (Metric.ball c R‚ÇÅ)","decl":"/-- Equality case in the **Schwarz Lemma**: in the setup of `norm_dslope_le_div_of_mapsTo_ball`, if\n`‚Äñdslope f c z‚ÇÄ‚Äñ = R‚ÇÇ / R‚ÇÅ` holds at a point in the ball then the map `f` is affine. -/\ntheorem affine_of_mapsTo_ball_of_exists_norm_dslope_eq_div [CompleteSpace E] [StrictConvexSpace ‚Ñù E]\n    (hd : DifferentiableOn ‚ÑÇ f (ball c R‚ÇÅ)) (h_maps : Set.MapsTo f (ball c R‚ÇÅ) (ball (f c) R‚ÇÇ))\n    (h_z‚ÇÄ : z‚ÇÄ ‚àà ball c R‚ÇÅ) (h_eq : ‚Äñdslope f c z‚ÇÄ‚Äñ = R‚ÇÇ / R‚ÇÅ) :\n    Set.EqOn f (fun z => f c + (z - c) ‚Ä¢ dslope f c z‚ÇÄ) (ball c R‚ÇÅ) := by\n  set g := dslope f c\n  rintro z hz\n  by_cases h : z = c; ¬∑ simp [h]\n  have h_R‚ÇÅ : 0 < R‚ÇÅ := nonempty_ball.mp ‚ü®_, h_z‚ÇÄ‚ü©\n  have g_le_div : ‚àÄ z ‚àà ball c R‚ÇÅ, ‚Äñg z‚Äñ ‚â§ R‚ÇÇ / R‚ÇÅ := fun z hz =>\n    norm_dslope_le_div_of_mapsTo_ball hd h_maps hz\n  have g_max : IsMaxOn (norm ‚àò g) (ball c R‚ÇÅ) z‚ÇÄ :=\n    isMaxOn_iff.mpr fun z hz => by simpa [h_eq] using g_le_div z hz\n  have g_diff : DifferentiableOn ‚ÑÇ g (ball c R‚ÇÅ) :=\n    (differentiableOn_dslope (isOpen_ball.mem_nhds (mem_ball_self h_R‚ÇÅ))).mpr hd\n  have : g z = g z‚ÇÄ := eqOn_of_isPreconnected_of_isMaxOn_norm (convex_ball c R‚ÇÅ).isPreconnected\n    isOpen_ball g_diff h_z‚ÇÄ g_max hz\n  simp only [g] at this\n  simp [g, ‚Üê this]\n\n"}
{"name":"Complex.affine_of_mapsTo_ball_of_exists_norm_dslope_eq_div'","module":"Mathlib.Analysis.Complex.Schwarz","initialProofState":"E : Type u_1\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Complex E\nR‚ÇÅ R‚ÇÇ : Real\nf : Complex ‚Üí E\nc : Complex\ninst‚úù¬π : CompleteSpace E\ninst‚úù : StrictConvexSpace Real E\nhd : DifferentiableOn Complex f (Metric.ball c R‚ÇÅ)\nh_maps : Set.MapsTo f (Metric.ball c R‚ÇÅ) (Metric.ball (f c) R‚ÇÇ)\nh_z‚ÇÄ : Exists fun z‚ÇÄ => And (Membership.mem (Metric.ball c R‚ÇÅ) z‚ÇÄ) (Eq (Norm.norm (dslope f c z‚ÇÄ)) (HDiv.hDiv R‚ÇÇ R‚ÇÅ))\n‚ä¢ Exists fun C => And (Eq (Norm.norm C) (HDiv.hDiv R‚ÇÇ R‚ÇÅ)) (Set.EqOn f (fun z => HAdd.hAdd (f c) (HSMul.hSMul (HSub.hSub z c) C)) (Metric.ball c R‚ÇÅ))","decl":"theorem affine_of_mapsTo_ball_of_exists_norm_dslope_eq_div' [CompleteSpace E]\n    [StrictConvexSpace ‚Ñù E] (hd : DifferentiableOn ‚ÑÇ f (ball c R‚ÇÅ))\n    (h_maps : Set.MapsTo f (ball c R‚ÇÅ) (ball (f c) R‚ÇÇ))\n    (h_z‚ÇÄ : ‚àÉ z‚ÇÄ ‚àà ball c R‚ÇÅ, ‚Äñdslope f c z‚ÇÄ‚Äñ = R‚ÇÇ / R‚ÇÅ) :\n    ‚àÉ C : E, ‚ÄñC‚Äñ = R‚ÇÇ / R‚ÇÅ ‚àß Set.EqOn f (fun z => f c + (z - c) ‚Ä¢ C) (ball c R‚ÇÅ) :=\n  let ‚ü®z‚ÇÄ, h_z‚ÇÄ, h_eq‚ü© := h_z‚ÇÄ\n  ‚ü®dslope f c z‚ÇÄ, h_eq, affine_of_mapsTo_ball_of_exists_norm_dslope_eq_div hd h_maps h_z‚ÇÄ h_eq‚ü©\n\n"}
{"name":"Complex.norm_deriv_le_div_of_mapsTo_ball","module":"Mathlib.Analysis.Complex.Schwarz","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nR‚ÇÅ R‚ÇÇ : Real\nf : Complex ‚Üí E\nc : Complex\nhd : DifferentiableOn Complex f (Metric.ball c R‚ÇÅ)\nh_maps : Set.MapsTo f (Metric.ball c R‚ÇÅ) (Metric.ball (f c) R‚ÇÇ)\nh‚ÇÄ : LT.lt 0 R‚ÇÅ\n‚ä¢ LE.le (Norm.norm (deriv f c)) (HDiv.hDiv R‚ÇÇ R‚ÇÅ)","decl":"/-- The **Schwarz Lemma**: if `f : ‚ÑÇ ‚Üí E` sends an open disk with center `c` and a positive radius\n`R‚ÇÅ` to an open ball with center `f c` and radius `R‚ÇÇ`, then the absolute value of the derivative of\n`f` at `c` is at most the ratio `R‚ÇÇ / R‚ÇÅ`. -/\ntheorem norm_deriv_le_div_of_mapsTo_ball (hd : DifferentiableOn ‚ÑÇ f (ball c R‚ÇÅ))\n    (h_maps : MapsTo f (ball c R‚ÇÅ) (ball (f c) R‚ÇÇ)) (h‚ÇÄ : 0 < R‚ÇÅ) : ‚Äñderiv f c‚Äñ ‚â§ R‚ÇÇ / R‚ÇÅ := by\n  simpa only [dslope_same] using norm_dslope_le_div_of_mapsTo_ball hd h_maps (mem_ball_self h‚ÇÄ)\n\n"}
{"name":"Complex.dist_le_div_mul_dist_of_mapsTo_ball","module":"Mathlib.Analysis.Complex.Schwarz","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nR‚ÇÅ R‚ÇÇ : Real\nf : Complex ‚Üí E\nc z : Complex\nhd : DifferentiableOn Complex f (Metric.ball c R‚ÇÅ)\nh_maps : Set.MapsTo f (Metric.ball c R‚ÇÅ) (Metric.ball (f c) R‚ÇÇ)\nhz : Membership.mem (Metric.ball c R‚ÇÅ) z\n‚ä¢ LE.le (Dist.dist (f z) (f c)) (HMul.hMul (HDiv.hDiv R‚ÇÇ R‚ÇÅ) (Dist.dist z c))","decl":"/-- The **Schwarz Lemma**: if `f : ‚ÑÇ ‚Üí E` sends an open disk with center `c` and radius `R‚ÇÅ` to an\nopen ball with center `f c` and radius `R‚ÇÇ`, then for any `z` in the former disk we have\n`dist (f z) (f c) ‚â§ (R‚ÇÇ / R‚ÇÅ) * dist z c`. -/\ntheorem dist_le_div_mul_dist_of_mapsTo_ball (hd : DifferentiableOn ‚ÑÇ f (ball c R‚ÇÅ))\n    (h_maps : MapsTo f (ball c R‚ÇÅ) (ball (f c) R‚ÇÇ)) (hz : z ‚àà ball c R‚ÇÅ) :\n    dist (f z) (f c) ‚â§ R‚ÇÇ / R‚ÇÅ * dist z c := by\n  rcases eq_or_ne z c with (rfl | hne)\n  ¬∑ simp only [dist_self, mul_zero, le_rfl]\n  simpa only [dslope_of_ne _ hne, slope_def_module, norm_smul, norm_inv, ‚Üê div_eq_inv_mul, ‚Üê\n    dist_eq_norm, div_le_iff‚ÇÄ (dist_pos.2 hne)] using norm_dslope_le_div_of_mapsTo_ball hd h_maps hz\n\n"}
{"name":"Complex.abs_deriv_le_div_of_mapsTo_ball","module":"Mathlib.Analysis.Complex.Schwarz","initialProofState":"f : Complex ‚Üí Complex\nc : Complex\nR‚ÇÅ R‚ÇÇ : Real\nhd : DifferentiableOn Complex f (Metric.ball c R‚ÇÅ)\nh_maps : Set.MapsTo f (Metric.ball c R‚ÇÅ) (Metric.ball (f c) R‚ÇÇ)\nh‚ÇÄ : LT.lt 0 R‚ÇÅ\n‚ä¢ LE.le (Complex.abs (deriv f c)) (HDiv.hDiv R‚ÇÇ R‚ÇÅ)","decl":"/-- The **Schwarz Lemma**: if `f : ‚ÑÇ ‚Üí ‚ÑÇ` sends an open disk with center `c` and a positive radius\n`R‚ÇÅ` to an open disk with center `f c` and radius `R‚ÇÇ`, then the absolute value of the derivative of\n`f` at `c` is at most the ratio `R‚ÇÇ / R‚ÇÅ`. -/\ntheorem abs_deriv_le_div_of_mapsTo_ball (hd : DifferentiableOn ‚ÑÇ f (ball c R‚ÇÅ))\n    (h_maps : MapsTo f (ball c R‚ÇÅ) (ball (f c) R‚ÇÇ)) (h‚ÇÄ : 0 < R‚ÇÅ) : abs (deriv f c) ‚â§ R‚ÇÇ / R‚ÇÅ :=\n  norm_deriv_le_div_of_mapsTo_ball hd h_maps h‚ÇÄ\n\n"}
{"name":"Complex.abs_deriv_le_one_of_mapsTo_ball","module":"Mathlib.Analysis.Complex.Schwarz","initialProofState":"f : Complex ‚Üí Complex\nc : Complex\nR : Real\nhd : DifferentiableOn Complex f (Metric.ball c R)\nh_maps : Set.MapsTo f (Metric.ball c R) (Metric.ball c R)\nhc : Eq (f c) c\nh‚ÇÄ : LT.lt 0 R\n‚ä¢ LE.le (Complex.abs (deriv f c)) 1","decl":"/-- The **Schwarz Lemma**: if `f : ‚ÑÇ ‚Üí ‚ÑÇ` sends an open disk of positive radius to itself and the\ncenter of this disk to itself, then the absolute value of the derivative of `f` at the center of\nthis disk is at most `1`. -/\ntheorem abs_deriv_le_one_of_mapsTo_ball (hd : DifferentiableOn ‚ÑÇ f (ball c R))\n    (h_maps : MapsTo f (ball c R) (ball c R)) (hc : f c = c) (h‚ÇÄ : 0 < R) : abs (deriv f c) ‚â§ 1 :=\n  (norm_deriv_le_div_of_mapsTo_ball hd (by rwa [hc]) h‚ÇÄ).trans_eq (div_self h‚ÇÄ.ne')\n\n"}
{"name":"Complex.dist_le_dist_of_mapsTo_ball_self","module":"Mathlib.Analysis.Complex.Schwarz","initialProofState":"f : Complex ‚Üí Complex\nc z : Complex\nR : Real\nhd : DifferentiableOn Complex f (Metric.ball c R)\nh_maps : Set.MapsTo f (Metric.ball c R) (Metric.ball c R)\nhc : Eq (f c) c\nhz : Membership.mem (Metric.ball c R) z\n‚ä¢ LE.le (Dist.dist (f z) c) (Dist.dist z c)","decl":"/-- The **Schwarz Lemma**: if `f : ‚ÑÇ ‚Üí ‚ÑÇ` sends an open disk to itself and the center `c` of this\ndisk to itself, then for any point `z` of this disk we have `dist (f z) c ‚â§ dist z c`. -/\ntheorem dist_le_dist_of_mapsTo_ball_self (hd : DifferentiableOn ‚ÑÇ f (ball c R))\n    (h_maps : MapsTo f (ball c R) (ball c R)) (hc : f c = c) (hz : z ‚àà ball c R) :\n    dist (f z) c ‚â§ dist z c := by\n  -- Porting note: `simp` was failing to use `div_self`\n  have := dist_le_div_mul_dist_of_mapsTo_ball hd (by rwa [hc]) hz\n  rwa [hc, div_self, one_mul] at this\n  exact (nonempty_ball.1 ‚ü®z, hz‚ü©).ne'\n\n"}
{"name":"Complex.abs_le_abs_of_mapsTo_ball_self","module":"Mathlib.Analysis.Complex.Schwarz","initialProofState":"f : Complex ‚Üí Complex\nz : Complex\nR : Real\nhd : DifferentiableOn Complex f (Metric.ball 0 R)\nh_maps : Set.MapsTo f (Metric.ball 0 R) (Metric.ball 0 R)\nh‚ÇÄ : Eq (f 0) 0\nhz : LT.lt (Complex.abs z) R\n‚ä¢ LE.le (Complex.abs (f z)) (Complex.abs z)","decl":"/-- The **Schwarz Lemma**: if `f : ‚ÑÇ ‚Üí ‚ÑÇ` sends an open disk with center `0` to itself, then for any\npoint `z` of this disk we have `abs (f z) ‚â§ abs z`. -/\ntheorem abs_le_abs_of_mapsTo_ball_self (hd : DifferentiableOn ‚ÑÇ f (ball 0 R))\n    (h_maps : MapsTo f (ball 0 R) (ball 0 R)) (h‚ÇÄ : f 0 = 0) (hz : abs z < R) :\n    abs (f z) ‚â§ abs z := by\n  replace hz : z ‚àà ball (0 : ‚ÑÇ) R := mem_ball_zero_iff.2 hz\n  simpa only [dist_zero_right] using dist_le_dist_of_mapsTo_ball_self hd h_maps h‚ÇÄ hz\n\n"}
