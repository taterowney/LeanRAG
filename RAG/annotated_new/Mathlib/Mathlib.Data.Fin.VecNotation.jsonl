{"name":"Matrix.empty_eq","module":"Mathlib.Data.Fin.VecNotation","initialProofState":"α : Type u\nv : Fin 0 → α\n⊢ Eq v Matrix.vecEmpty","decl":"theorem empty_eq (v : Fin 0 → α) : v = ![] :=\n  Subsingleton.elim _ _\n\n"}
{"name":"Matrix.head_fin_const","module":"Mathlib.Data.Fin.VecNotation","initialProofState":"α : Type u\nn : Nat\na : α\n⊢ Eq (Matrix.vecHead fun x => a) a","decl":"@[simp]\ntheorem head_fin_const (a : α) : (vecHead fun _ : Fin (n + 1) => a) = a :=\n  rfl\n\n"}
{"name":"Matrix.cons_val_zero","module":"Mathlib.Data.Fin.VecNotation","initialProofState":"α : Type u\nm : Nat\nx : α\nu : Fin m → α\n⊢ Eq (Matrix.vecCons x u 0) x","decl":"@[simp]\ntheorem cons_val_zero (x : α) (u : Fin m → α) : vecCons x u 0 = x :=\n  rfl\n\n"}
{"name":"Matrix.cons_val_zero'","module":"Mathlib.Data.Fin.VecNotation","initialProofState":"α : Type u\nm : Nat\nh : LT.lt 0 m.succ\nx : α\nu : Fin m → α\n⊢ Eq (Matrix.vecCons x u ⟨0, h⟩) x","decl":"theorem cons_val_zero' (h : 0 < m.succ) (x : α) (u : Fin m → α) : vecCons x u ⟨0, h⟩ = x :=\n  rfl\n\n"}
{"name":"Matrix.cons_val_succ","module":"Mathlib.Data.Fin.VecNotation","initialProofState":"α : Type u\nm : Nat\nx : α\nu : Fin m → α\ni : Fin m\n⊢ Eq (Matrix.vecCons x u i.succ) (u i)","decl":"@[simp]\ntheorem cons_val_succ (x : α) (u : Fin m → α) (i : Fin m) : vecCons x u i.succ = u i := by\n  simp [vecCons]\n\n"}
{"name":"Matrix.cons_val_succ'","module":"Mathlib.Data.Fin.VecNotation","initialProofState":"α : Type u\nm i : Nat\nh : LT.lt i.succ m.succ\nx : α\nu : Fin m → α\n⊢ Eq (Matrix.vecCons x u ⟨i.succ, h⟩) (u ⟨i, ⋯⟩)","decl":"@[simp]\ntheorem cons_val_succ' {i : ℕ} (h : i.succ < m.succ) (x : α) (u : Fin m → α) :\n    vecCons x u ⟨i.succ, h⟩ = u ⟨i, Nat.lt_of_succ_lt_succ h⟩ := by\n  simp only [vecCons, Fin.cons, Fin.cases_succ']\n\n"}
{"name":"Matrix.head_cons","module":"Mathlib.Data.Fin.VecNotation","initialProofState":"α : Type u\nm : Nat\nx : α\nu : Fin m → α\n⊢ Eq (Matrix.vecHead (Matrix.vecCons x u)) x","decl":"@[simp]\ntheorem head_cons (x : α) (u : Fin m → α) : vecHead (vecCons x u) = x :=\n  rfl\n\n"}
{"name":"Matrix.tail_cons","module":"Mathlib.Data.Fin.VecNotation","initialProofState":"α : Type u\nm : Nat\nx : α\nu : Fin m → α\n⊢ Eq (Matrix.vecTail (Matrix.vecCons x u)) u","decl":"@[simp]\ntheorem tail_cons (x : α) (u : Fin m → α) : vecTail (vecCons x u) = u := by\n  ext\n  simp [vecTail]\n\n"}
{"name":"Matrix.empty_val'","module":"Mathlib.Data.Fin.VecNotation","initialProofState":"α : Type u\nn' : Type u_1\nj : n'\n⊢ Eq (fun i => Matrix.vecEmpty i j) Matrix.vecEmpty","decl":"@[simp]\ntheorem empty_val' {n' : Type*} (j : n') : (fun i => (![] : Fin 0 → n' → α) i j) = ![] :=\n  empty_eq _\n\n"}
{"name":"Matrix.cons_head_tail","module":"Mathlib.Data.Fin.VecNotation","initialProofState":"α : Type u\nm : Nat\nu : Fin m.succ → α\n⊢ Eq (Matrix.vecCons (Matrix.vecHead u) (Matrix.vecTail u)) u","decl":"@[simp]\ntheorem cons_head_tail (u : Fin m.succ → α) : vecCons (vecHead u) (vecTail u) = u :=\n  Fin.cons_self_tail _\n\n"}
{"name":"Matrix.range_cons","module":"Mathlib.Data.Fin.VecNotation","initialProofState":"α : Type u\nn : Nat\nx : α\nu : Fin n → α\n⊢ Eq (Set.range (Matrix.vecCons x u)) (Union.union (Singleton.singleton x) (Set.range u))","decl":"@[simp]\ntheorem range_cons (x : α) (u : Fin n → α) : Set.range (vecCons x u) = {x} ∪ Set.range u :=\n  Set.ext fun y => by simp [Fin.exists_fin_succ, eq_comm]\n\n"}
{"name":"Matrix.range_empty","module":"Mathlib.Data.Fin.VecNotation","initialProofState":"α : Type u\nu : Fin 0 → α\n⊢ Eq (Set.range u) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem range_empty (u : Fin 0 → α) : Set.range u = ∅ :=\n  Set.range_eq_empty _\n\n"}
{"name":"Matrix.range_cons_empty","module":"Mathlib.Data.Fin.VecNotation","initialProofState":"α : Type u\nx : α\nu : Fin 0 → α\n⊢ Eq (Set.range (Matrix.vecCons x u)) (Singleton.singleton x)","decl":"theorem range_cons_empty (x : α) (u : Fin 0 → α) : Set.range (Matrix.vecCons x u) = {x} := by\n  rw [range_cons, range_empty, Set.union_empty]\n\n-- simp can prove this (up to commutativity)\n"}
{"name":"Matrix.range_cons_cons_empty","module":"Mathlib.Data.Fin.VecNotation","initialProofState":"α : Type u\nx y : α\nu : Fin 0 → α\n⊢ Eq (Set.range (Matrix.vecCons x (Matrix.vecCons y u))) (Insert.insert x (Singleton.singleton y))","decl":"theorem range_cons_cons_empty (x y : α) (u : Fin 0 → α) :\n    Set.range (vecCons x <| vecCons y u) = {x, y} := by\n  rw [range_cons, range_cons_empty, Set.singleton_union]\n\n"}
{"name":"Matrix.vecCons_const","module":"Mathlib.Data.Fin.VecNotation","initialProofState":"α : Type u\nn : Nat\na : α\n⊢ Eq (Matrix.vecCons a fun x => a) fun x => a","decl":"theorem vecCons_const (a : α) : (vecCons a fun _ : Fin n => a) = fun _ => a :=\n  funext <| Fin.forall_iff_succ.2 ⟨rfl, cons_val_succ _ _⟩\n\n"}
{"name":"Matrix.vec_single_eq_const","module":"Mathlib.Data.Fin.VecNotation","initialProofState":"α : Type u\na : α\n⊢ Eq (Matrix.vecCons a Matrix.vecEmpty) fun x => a","decl":"theorem vec_single_eq_const (a : α) : ![a] = fun _ => a :=\n  let _ : Unique (Fin 1) := inferInstance\n  funext <| Unique.forall_iff.2 rfl\n\n"}
{"name":"Matrix.cons_val_one","module":"Mathlib.Data.Fin.VecNotation","initialProofState":"α : Type u\nm : Nat\nx : α\nu : Fin m.succ → α\n⊢ Eq (Matrix.vecCons x u 1) (Matrix.vecHead u)","decl":"/-- `![a, b, ...] 1` is equal to `b`.\n\n  The simplifier needs a special lemma for length `≥ 2`, in addition to\n  `cons_val_succ`, because `1 : Fin 1 = 0 : Fin 1`.\n-/\n@[simp]\ntheorem cons_val_one (x : α) (u : Fin m.succ → α) : vecCons x u 1 = vecHead u :=\n  rfl\n\n"}
{"name":"Matrix.cons_val_two","module":"Mathlib.Data.Fin.VecNotation","initialProofState":"α : Type u\nm : Nat\nx : α\nu : Fin m.succ.succ → α\n⊢ Eq (Matrix.vecCons x u 2) (Matrix.vecHead (Matrix.vecTail u))","decl":"@[simp]\ntheorem cons_val_two (x : α) (u : Fin m.succ.succ → α) : vecCons x u 2 = vecHead (vecTail u) :=\n  rfl\n\n"}
{"name":"Matrix.cons_val_three","module":"Mathlib.Data.Fin.VecNotation","initialProofState":"α : Type u\nm : Nat\nx : α\nu : Fin m.succ.succ.succ → α\n⊢ Eq (Matrix.vecCons x u 3) (Matrix.vecHead (Matrix.vecTail (Matrix.vecTail u)))","decl":"@[simp]\nlemma cons_val_three (x : α) (u : Fin m.succ.succ.succ → α) :\n    vecCons x u 3 = vecHead (vecTail (vecTail u)) :=\n  rfl\n\n"}
{"name":"Matrix.cons_val_four","module":"Mathlib.Data.Fin.VecNotation","initialProofState":"α : Type u\nm : Nat\nx : α\nu : Fin m.succ.succ.succ.succ → α\n⊢ Eq (Matrix.vecCons x u 4) (Matrix.vecHead (Matrix.vecTail (Matrix.vecTail (Matrix.vecTail u))))","decl":"@[simp]\nlemma cons_val_four (x : α) (u : Fin m.succ.succ.succ.succ → α) :\n    vecCons x u 4 = vecHead (vecTail (vecTail (vecTail u))) :=\n  rfl\n\n"}
{"name":"Matrix.cons_val_fin_one","module":"Mathlib.Data.Fin.VecNotation","initialProofState":"α : Type u\nx : α\nu : Fin 0 → α\ni : Fin 1\n⊢ Eq (Matrix.vecCons x u i) x","decl":"@[simp]\ntheorem cons_val_fin_one (x : α) (u : Fin 0 → α) : ∀ (i : Fin 1), vecCons x u i = x := by\n  rw [Fin.forall_fin_one]\n  rfl\n\n"}
{"name":"Matrix.cons_fin_one","module":"Mathlib.Data.Fin.VecNotation","initialProofState":"α : Type u\nx : α\nu : Fin 0 → α\n⊢ Eq (Matrix.vecCons x u) fun x_1 => x","decl":"theorem cons_fin_one (x : α) (u : Fin 0 → α) : vecCons x u = fun _ => x :=\n  funext (cons_val_fin_one x u)\n\n"}
{"name":"Matrix.vecAppend_eq_ite","module":"Mathlib.Data.Fin.VecNotation","initialProofState":"m n : Nat\nα : Type u_1\no : Nat\nho : Eq o (HAdd.hAdd m n)\nu : Fin m → α\nv : Fin n → α\n⊢ Eq (Matrix.vecAppend ho u v) fun i => dite (LT.lt (↑i) m) (fun h => u ⟨↑i, h⟩) fun h => v ⟨HSub.hSub (↑i) m, ⋯⟩","decl":"theorem vecAppend_eq_ite {α : Type*} {o : ℕ} (ho : o = m + n) (u : Fin m → α) (v : Fin n → α) :\n    vecAppend ho u v = fun i : Fin o =>\n      if h : (i : ℕ) < m then u ⟨i, h⟩ else v ⟨(i : ℕ) - m, by omega⟩ := by\n  ext i\n  rw [vecAppend, Fin.append, Function.comp_apply, Fin.addCases]\n  congr with hi\n  simp only [eq_rec_constant]\n  rfl\n\n-- Porting note: proof was `rfl`, so this is no longer a `dsimp`-lemma\n-- Could become one again with change to `Nat.ble`:\n-- https://github.com/leanprover-community/mathlib4/pull/1741/files/#r1083902351\n"}
{"name":"Matrix.vecAppend_apply_zero","module":"Mathlib.Data.Fin.VecNotation","initialProofState":"m n : Nat\nα : Type u_1\no : Nat\nho : Eq (HAdd.hAdd o 1) (HAdd.hAdd (HAdd.hAdd m 1) n)\nu : Fin (HAdd.hAdd m 1) → α\nv : Fin n → α\n⊢ Eq (Matrix.vecAppend ho u v 0) (u 0)","decl":"@[simp]\ntheorem vecAppend_apply_zero {α : Type*} {o : ℕ} (ho : o + 1 = m + 1 + n) (u : Fin (m + 1) → α)\n    (v : Fin n → α) : vecAppend ho u v 0 = u 0 :=\n  dif_pos _\n\n"}
{"name":"Matrix.empty_vecAppend","module":"Mathlib.Data.Fin.VecNotation","initialProofState":"α : Type u\nn : Nat\nv : Fin n → α\n⊢ Eq (Matrix.vecAppend ⋯ Matrix.vecEmpty v) v","decl":"@[simp]\ntheorem empty_vecAppend (v : Fin n → α) : vecAppend n.zero_add.symm ![] v = v := by\n  ext\n  simp [vecAppend_eq_ite]\n\n"}
{"name":"Matrix.cons_vecAppend","module":"Mathlib.Data.Fin.VecNotation","initialProofState":"α : Type u\nm n o : Nat\nho : Eq (HAdd.hAdd o 1) (HAdd.hAdd (HAdd.hAdd m 1) n)\nx : α\nu : Fin m → α\nv : Fin n → α\n⊢ Eq (Matrix.vecAppend ho (Matrix.vecCons x u) v) (Matrix.vecCons x (Matrix.vecAppend ⋯ u v))","decl":"@[simp]\ntheorem cons_vecAppend (ho : o + 1 = m + 1 + n) (x : α) (u : Fin m → α) (v : Fin n → α) :\n    vecAppend ho (vecCons x u) v = vecCons x (vecAppend (by omega) u v) := by\n  ext i\n  simp_rw [vecAppend_eq_ite]\n  split_ifs with h\n  · rcases i with ⟨⟨⟩ | i, hi⟩\n    · simp\n    · simp only [Nat.add_lt_add_iff_right, Fin.val_mk] at h\n      simp [h]\n  · rcases i with ⟨⟨⟩ | i, hi⟩\n    · simp at h\n    · rw [not_lt, Fin.val_mk, Nat.add_le_add_iff_right] at h\n      simp [h, not_lt.2 h]\n\n"}
{"name":"Matrix.vecAlt0_vecAppend","module":"Mathlib.Data.Fin.VecNotation","initialProofState":"α : Type u\nn : Nat\nv : Fin n → α\n⊢ Eq (Matrix.vecAlt0 ⋯ (Matrix.vecAppend ⋯ v v)) (Function.comp v fun n_1 => HAdd.hAdd n_1 n_1)","decl":"theorem vecAlt0_vecAppend (v : Fin n → α) :\n    vecAlt0 rfl (vecAppend rfl v v) = v ∘ (fun n ↦ n + n) := by\n  ext i\n  simp_rw [Function.comp, vecAlt0, vecAppend_eq_ite]\n  split_ifs with h <;> congr\n  · rw [Fin.val_mk] at h\n    exact (Nat.mod_eq_of_lt h).symm\n  · rw [Fin.val_mk, not_lt] at h\n    simp only [Fin.ext_iff, Fin.val_add, Fin.val_mk, Nat.mod_eq_sub_mod h]\n    refine (Nat.mod_eq_of_lt ?_).symm\n    omega\n\n"}
{"name":"Matrix.vecAlt1_vecAppend","module":"Mathlib.Data.Fin.VecNotation","initialProofState":"α : Type u\nn : Nat\nv : Fin (HAdd.hAdd n 1) → α\n⊢ Eq (Matrix.vecAlt1 ⋯ (Matrix.vecAppend ⋯ v v)) (Function.comp v fun n_1 => HAdd.hAdd (HAdd.hAdd n_1 n_1) 1)","decl":"theorem vecAlt1_vecAppend (v : Fin (n + 1) → α) :\n    vecAlt1 rfl (vecAppend rfl v v) = v ∘ (fun n ↦ (n + n) + 1) := by\n  ext i\n  simp_rw [Function.comp, vecAlt1, vecAppend_eq_ite]\n  cases n with\n  | zero =>\n    cases' i with i hi\n    simp only [Nat.zero_add, Nat.lt_one_iff] at hi; subst i; rfl\n  | succ n =>\n    split_ifs with h <;> congr\n    · simp [Nat.mod_eq_of_lt, h]\n    · rw [Fin.val_mk, not_lt] at h\n      simp only [Fin.ext_iff, Fin.val_add, Fin.val_mk, Nat.mod_add_mod, Fin.val_one,\n        Nat.mod_eq_sub_mod h, show 1 % (n + 2) = 1 from Nat.mod_eq_of_lt (by omega)]\n      refine (Nat.mod_eq_of_lt ?_).symm\n      omega\n\n"}
{"name":"Matrix.vecHead_vecAlt0","module":"Mathlib.Data.Fin.VecNotation","initialProofState":"α : Type u\nm n : Nat\nhm : Eq (HAdd.hAdd m 2) (HAdd.hAdd (HAdd.hAdd n 1) (HAdd.hAdd n 1))\nv : Fin (HAdd.hAdd m 2) → α\n⊢ Eq (Matrix.vecHead (Matrix.vecAlt0 hm v)) (v 0)","decl":"@[simp]\ntheorem vecHead_vecAlt0 (hm : m + 2 = n + 1 + (n + 1)) (v : Fin (m + 2) → α) :\n    vecHead (vecAlt0 hm v) = v 0 :=\n  rfl\n\n"}
{"name":"Matrix.vecHead_vecAlt1","module":"Mathlib.Data.Fin.VecNotation","initialProofState":"α : Type u\nm n : Nat\nhm : Eq (HAdd.hAdd m 2) (HAdd.hAdd (HAdd.hAdd n 1) (HAdd.hAdd n 1))\nv : Fin (HAdd.hAdd m 2) → α\n⊢ Eq (Matrix.vecHead (Matrix.vecAlt1 hm v)) (v 1)","decl":"@[simp]\ntheorem vecHead_vecAlt1 (hm : m + 2 = n + 1 + (n + 1)) (v : Fin (m + 2) → α) :\n    vecHead (vecAlt1 hm v) = v 1 := by simp [vecHead, vecAlt1]\n\n"}
{"name":"Matrix.cons_vec_bit0_eq_alt0","module":"Mathlib.Data.Fin.VecNotation","initialProofState":"α : Type u\nn : Nat\nx : α\nu : Fin n → α\ni : Fin (HAdd.hAdd n 1)\n⊢ Eq (Matrix.vecCons x u (HAdd.hAdd i i)) (Matrix.vecAlt0 ⋯ (Matrix.vecAppend ⋯ (Matrix.vecCons x u) (Matrix.vecCons x u)) i)","decl":"@[simp]\ntheorem cons_vec_bit0_eq_alt0 (x : α) (u : Fin n → α) (i : Fin (n + 1)) :\n    vecCons x u (i + i) = vecAlt0 rfl (vecAppend rfl (vecCons x u) (vecCons x u)) i := by\n  rw [vecAlt0_vecAppend]; rfl\n\n"}
{"name":"Matrix.cons_vec_bit1_eq_alt1","module":"Mathlib.Data.Fin.VecNotation","initialProofState":"α : Type u\nn : Nat\nx : α\nu : Fin n → α\ni : Fin (HAdd.hAdd n 1)\n⊢ Eq (Matrix.vecCons x u (HAdd.hAdd (HAdd.hAdd i i) 1)) (Matrix.vecAlt1 ⋯ (Matrix.vecAppend ⋯ (Matrix.vecCons x u) (Matrix.vecCons x u)) i)","decl":"@[simp]\ntheorem cons_vec_bit1_eq_alt1 (x : α) (u : Fin n → α) (i : Fin (n + 1)) :\n    vecCons x u ((i + i) + 1) = vecAlt1 rfl (vecAppend rfl (vecCons x u) (vecCons x u)) i := by\n  rw [vecAlt1_vecAppend]; rfl\n\n"}
{"name":"Matrix.cons_vecAlt0","module":"Mathlib.Data.Fin.VecNotation","initialProofState":"α : Type u\nm n : Nat\nh : Eq (HAdd.hAdd (HAdd.hAdd m 1) 1) (HAdd.hAdd (HAdd.hAdd n 1) (HAdd.hAdd n 1))\nx y : α\nu : Fin m → α\n⊢ Eq (Matrix.vecAlt0 h (Matrix.vecCons x (Matrix.vecCons y u))) (Matrix.vecCons x (Matrix.vecAlt0 ⋯ u))","decl":"@[simp]\ntheorem cons_vecAlt0 (h : m + 1 + 1 = n + 1 + (n + 1)) (x y : α) (u : Fin m → α) :\n    vecAlt0 h (vecCons x (vecCons y u)) = vecCons x (vecAlt0 (by omega) u) := by\n  ext i\n  simp_rw [vecAlt0]\n  rcases i with ⟨⟨⟩ | i, hi⟩\n  · rfl\n  · simp only [← Nat.add_assoc, Nat.add_right_comm, cons_val_succ',\n      cons_vecAppend, Nat.add_eq, vecAlt0]\n\n-- Although proved by simp, extracting element 8 of a five-element\n-- vector does not work by simp unless this lemma is present.\n"}
{"name":"Matrix.empty_vecAlt0","module":"Mathlib.Data.Fin.VecNotation","initialProofState":"α : Type u_1\nh : Eq 0 (HAdd.hAdd 0 0)\n⊢ Eq (Matrix.vecAlt0 h Matrix.vecEmpty) Matrix.vecEmpty","decl":"@[simp]\ntheorem empty_vecAlt0 (α) {h} : vecAlt0 h (![] : Fin 0 → α) = ![] := by\n  simp [eq_iff_true_of_subsingleton]\n\n"}
{"name":"Matrix.cons_vecAlt1","module":"Mathlib.Data.Fin.VecNotation","initialProofState":"α : Type u\nm n : Nat\nh : Eq (HAdd.hAdd (HAdd.hAdd m 1) 1) (HAdd.hAdd (HAdd.hAdd n 1) (HAdd.hAdd n 1))\nx y : α\nu : Fin m → α\n⊢ Eq (Matrix.vecAlt1 h (Matrix.vecCons x (Matrix.vecCons y u))) (Matrix.vecCons y (Matrix.vecAlt1 ⋯ u))","decl":"@[simp]\ntheorem cons_vecAlt1 (h : m + 1 + 1 = n + 1 + (n + 1)) (x y : α) (u : Fin m → α) :\n    vecAlt1 h (vecCons x (vecCons y u)) = vecCons y (vecAlt1 (by omega) u) := by\n  ext i\n  simp_rw [vecAlt1]\n  rcases i with ⟨⟨⟩ | i, hi⟩\n  · rfl\n  · simp [vecAlt1, Nat.add_right_comm, ← Nat.add_assoc]\n\n-- Although proved by simp, extracting element 9 of a five-element\n-- vector does not work by simp unless this lemma is present.\n"}
{"name":"Matrix.empty_vecAlt1","module":"Mathlib.Data.Fin.VecNotation","initialProofState":"α : Type u_1\nh : Eq 0 (HAdd.hAdd 0 0)\n⊢ Eq (Matrix.vecAlt1 h Matrix.vecEmpty) Matrix.vecEmpty","decl":"@[simp]\ntheorem empty_vecAlt1 (α) {h} : vecAlt1 h (![] : Fin 0 → α) = ![] := by\n  simp [eq_iff_true_of_subsingleton]\n\n"}
{"name":"Matrix.const_fin1_eq","module":"Mathlib.Data.Fin.VecNotation","initialProofState":"α : Type u\nx : α\n⊢ Eq (fun x_1 => x) (Matrix.vecCons x Matrix.vecEmpty)","decl":"lemma const_fin1_eq (x : α) : (fun _ : Fin 1 => x) = ![x] :=\n  (cons_fin_one x _).symm\n\n"}
