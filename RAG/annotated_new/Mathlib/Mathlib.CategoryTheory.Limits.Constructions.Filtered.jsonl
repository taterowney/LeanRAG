{"name":"CategoryTheory.Limits.CoproductsFromFiniteFiltered.liftToFinsetObj_map","module":"Mathlib.CategoryTheory.Limits.Constructions.Filtered","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nα : Type w\ninst✝ : CategoryTheory.Limits.HasFiniteCoproducts C\nF : CategoryTheory.Functor (CategoryTheory.Discrete α) C\nx✝ Y : Finset (CategoryTheory.Discrete α)\nh : Quiver.Hom x✝ Y\n⊢ Eq ((CategoryTheory.Limits.CoproductsFromFiniteFiltered.liftToFinsetObj F).map h) (CategoryTheory.Limits.Sigma.desc fun y => CategoryTheory.Limits.Sigma.ι (fun x => F.obj ↑x) ⟨↑y, ⋯⟩)","decl":"/-- If `C` has finite coproducts, a functor `Discrete α ⥤ C` lifts to a functor\n    `Finset (Discrete α) ⥤ C` by taking coproducts. -/\n@[simps!]\ndef liftToFinsetObj (F : Discrete α ⥤ C) : Finset (Discrete α) ⥤ C where\n  obj s := ∐ fun x : s => F.obj x\n  map {_ Y} h := Sigma.desc fun y =>\n    Sigma.ι (fun (x : { x // x ∈ Y }) => F.obj x) ⟨y, h.down.down y.2⟩\n\n"}
{"name":"CategoryTheory.Limits.CoproductsFromFiniteFiltered.liftToFinsetObj_obj","module":"Mathlib.CategoryTheory.Limits.Constructions.Filtered","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nα : Type w\ninst✝ : CategoryTheory.Limits.HasFiniteCoproducts C\nF : CategoryTheory.Functor (CategoryTheory.Discrete α) C\ns : Finset (CategoryTheory.Discrete α)\n⊢ Eq ((CategoryTheory.Limits.CoproductsFromFiniteFiltered.liftToFinsetObj F).obj s) (CategoryTheory.Limits.sigmaObj fun x => F.obj ↑x)","decl":"/-- If `C` has finite coproducts, a functor `Discrete α ⥤ C` lifts to a functor\n    `Finset (Discrete α) ⥤ C` by taking coproducts. -/\n@[simps!]\ndef liftToFinsetObj (F : Discrete α ⥤ C) : Finset (Discrete α) ⥤ C where\n  obj s := ∐ fun x : s => F.obj x\n  map {_ Y} h := Sigma.desc fun y =>\n    Sigma.ι (fun (x : { x // x ∈ Y }) => F.obj x) ⟨y, h.down.down y.2⟩\n\n"}
{"name":"CategoryTheory.Limits.CoproductsFromFiniteFiltered.liftToFinsetColimitCocone_cocone_ι_app","module":"Mathlib.CategoryTheory.Limits.Constructions.Filtered","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nα : Type w\ninst✝¹ : CategoryTheory.Limits.HasFiniteCoproducts C\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape (Finset (CategoryTheory.Discrete α)) C\nF : CategoryTheory.Functor (CategoryTheory.Discrete α) C\nj : CategoryTheory.Discrete α\n⊢ Eq ((CategoryTheory.Limits.CoproductsFromFiniteFiltered.liftToFinsetColimitCocone F).cocone.ι.app j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.ι (fun x => F.obj ↑x) ⟨j, ⋯⟩) (CategoryTheory.Limits.colimit.ι (CategoryTheory.Limits.CoproductsFromFiniteFiltered.liftToFinsetObj F) (Singleton.singleton j)))","decl":"/-- If `C` has finite coproducts and filtered colimits, we can construct arbitrary coproducts by\n    taking the colimit of the diagram formed by the coproducts of finite sets over the indexing\n    type. -/\n@[simps!]\ndef liftToFinsetColimitCocone [HasColimitsOfShape (Finset (Discrete α)) C]\n    (F : Discrete α ⥤ C) : ColimitCocone F where\n  cocone :=\n    { pt := colimit (liftToFinsetObj F)\n      ι :=\n        Discrete.natTrans fun j =>\n          @Sigma.ι _ _ _ (fun x : ({j} : Finset (Discrete α)) => F.obj x) _ ⟨j, by simp⟩ ≫\n            colimit.ι (liftToFinsetObj F) {j} }\n  isColimit :=\n    { desc := fun s =>\n        colimit.desc (liftToFinsetObj F)\n          { pt := s.pt\n            ι := { app := fun _ => Sigma.desc fun x => s.ι.app x } }\n      uniq := fun s m h => by\n        apply colimit.hom_ext\n        rintro t\n        dsimp [liftToFinsetObj]\n        apply colimit.hom_ext\n        rintro ⟨⟨j, hj⟩⟩\n        convert h j using 1\n        · simp [← colimit.w (liftToFinsetObj F) ⟨⟨Finset.singleton_subset_iff.2 hj⟩⟩]\n          rfl\n        · simp }\n\n"}
{"name":"CategoryTheory.Limits.CoproductsFromFiniteFiltered.liftToFinsetColimitCocone_cocone_pt","module":"Mathlib.CategoryTheory.Limits.Constructions.Filtered","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nα : Type w\ninst✝¹ : CategoryTheory.Limits.HasFiniteCoproducts C\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape (Finset (CategoryTheory.Discrete α)) C\nF : CategoryTheory.Functor (CategoryTheory.Discrete α) C\n⊢ Eq (CategoryTheory.Limits.CoproductsFromFiniteFiltered.liftToFinsetColimitCocone F).cocone.pt (CategoryTheory.Limits.colimit (CategoryTheory.Limits.CoproductsFromFiniteFiltered.liftToFinsetObj F))","decl":"/-- If `C` has finite coproducts and filtered colimits, we can construct arbitrary coproducts by\n    taking the colimit of the diagram formed by the coproducts of finite sets over the indexing\n    type. -/\n@[simps!]\ndef liftToFinsetColimitCocone [HasColimitsOfShape (Finset (Discrete α)) C]\n    (F : Discrete α ⥤ C) : ColimitCocone F where\n  cocone :=\n    { pt := colimit (liftToFinsetObj F)\n      ι :=\n        Discrete.natTrans fun j =>\n          @Sigma.ι _ _ _ (fun x : ({j} : Finset (Discrete α)) => F.obj x) _ ⟨j, by simp⟩ ≫\n            colimit.ι (liftToFinsetObj F) {j} }\n  isColimit :=\n    { desc := fun s =>\n        colimit.desc (liftToFinsetObj F)\n          { pt := s.pt\n            ι := { app := fun _ => Sigma.desc fun x => s.ι.app x } }\n      uniq := fun s m h => by\n        apply colimit.hom_ext\n        rintro t\n        dsimp [liftToFinsetObj]\n        apply colimit.hom_ext\n        rintro ⟨⟨j, hj⟩⟩\n        convert h j using 1\n        · simp [← colimit.w (liftToFinsetObj F) ⟨⟨Finset.singleton_subset_iff.2 hj⟩⟩]\n          rfl\n        · simp }\n\n"}
{"name":"CategoryTheory.Limits.CoproductsFromFiniteFiltered.liftToFinsetColimitCocone_isColimit_desc","module":"Mathlib.CategoryTheory.Limits.Constructions.Filtered","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nα : Type w\ninst✝¹ : CategoryTheory.Limits.HasFiniteCoproducts C\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape (Finset (CategoryTheory.Discrete α)) C\nF : CategoryTheory.Functor (CategoryTheory.Discrete α) C\ns : CategoryTheory.Limits.Cocone F\n⊢ Eq ((CategoryTheory.Limits.CoproductsFromFiniteFiltered.liftToFinsetColimitCocone F).isColimit.desc s) (CategoryTheory.Limits.colimit.desc (CategoryTheory.Limits.CoproductsFromFiniteFiltered.liftToFinsetObj F) { pt := s.pt, ι := { app := fun x => CategoryTheory.Limits.Sigma.desc fun x_1 => s.ι.app ↑x_1, naturality := ⋯ } })","decl":"/-- If `C` has finite coproducts and filtered colimits, we can construct arbitrary coproducts by\n    taking the colimit of the diagram formed by the coproducts of finite sets over the indexing\n    type. -/\n@[simps!]\ndef liftToFinsetColimitCocone [HasColimitsOfShape (Finset (Discrete α)) C]\n    (F : Discrete α ⥤ C) : ColimitCocone F where\n  cocone :=\n    { pt := colimit (liftToFinsetObj F)\n      ι :=\n        Discrete.natTrans fun j =>\n          @Sigma.ι _ _ _ (fun x : ({j} : Finset (Discrete α)) => F.obj x) _ ⟨j, by simp⟩ ≫\n            colimit.ι (liftToFinsetObj F) {j} }\n  isColimit :=\n    { desc := fun s =>\n        colimit.desc (liftToFinsetObj F)\n          { pt := s.pt\n            ι := { app := fun _ => Sigma.desc fun x => s.ι.app x } }\n      uniq := fun s m h => by\n        apply colimit.hom_ext\n        rintro t\n        dsimp [liftToFinsetObj]\n        apply colimit.hom_ext\n        rintro ⟨⟨j, hj⟩⟩\n        convert h j using 1\n        · simp [← colimit.w (liftToFinsetObj F) ⟨⟨Finset.singleton_subset_iff.2 hj⟩⟩]\n          rfl\n        · simp }\n\n"}
{"name":"CategoryTheory.Limits.CoproductsFromFiniteFiltered.liftToFinset_obj_map","module":"Mathlib.CategoryTheory.Limits.Constructions.Filtered","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nα : Type w\ninst✝ : CategoryTheory.Limits.HasFiniteCoproducts C\nF : CategoryTheory.Functor (CategoryTheory.Discrete α) C\nx✝ Y : Finset (CategoryTheory.Discrete α)\nh : Quiver.Hom x✝ Y\n⊢ Eq (((CategoryTheory.Limits.CoproductsFromFiniteFiltered.liftToFinset C α).obj F).map h) (CategoryTheory.Limits.Sigma.desc fun y => CategoryTheory.Limits.Sigma.ι (fun x => F.obj ↑x) ⟨↑y, ⋯⟩)","decl":"/-- The functor taking a functor `Discrete α ⥤ C` to a functor `Finset (Discrete α) ⥤ C` by taking\ncoproducts. -/\n@[simps!]\ndef liftToFinset : (Discrete α ⥤ C) ⥤ (Finset (Discrete α) ⥤ C) where\n  obj := liftToFinsetObj\n  map := fun β => { app := fun _ => Sigma.map (fun x => β.app x.val) }\n\n"}
{"name":"CategoryTheory.Limits.CoproductsFromFiniteFiltered.liftToFinset_map_app","module":"Mathlib.CategoryTheory.Limits.Constructions.Filtered","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nα : Type w\ninst✝ : CategoryTheory.Limits.HasFiniteCoproducts C\nX✝ Y✝ : CategoryTheory.Functor (CategoryTheory.Discrete α) C\nβ : Quiver.Hom X✝ Y✝\nx✝ : Finset (CategoryTheory.Discrete α)\n⊢ Eq (((CategoryTheory.Limits.CoproductsFromFiniteFiltered.liftToFinset C α).map β).app x✝) (CategoryTheory.Limits.Sigma.map fun x => β.app ↑x)","decl":"/-- The functor taking a functor `Discrete α ⥤ C` to a functor `Finset (Discrete α) ⥤ C` by taking\ncoproducts. -/\n@[simps!]\ndef liftToFinset : (Discrete α ⥤ C) ⥤ (Finset (Discrete α) ⥤ C) where\n  obj := liftToFinsetObj\n  map := fun β => { app := fun _ => Sigma.map (fun x => β.app x.val) }\n\n"}
{"name":"CategoryTheory.Limits.CoproductsFromFiniteFiltered.liftToFinset_obj_obj","module":"Mathlib.CategoryTheory.Limits.Constructions.Filtered","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nα : Type w\ninst✝ : CategoryTheory.Limits.HasFiniteCoproducts C\nF : CategoryTheory.Functor (CategoryTheory.Discrete α) C\ns : Finset (CategoryTheory.Discrete α)\n⊢ Eq (((CategoryTheory.Limits.CoproductsFromFiniteFiltered.liftToFinset C α).obj F).obj s) (CategoryTheory.Limits.sigmaObj fun x => F.obj ↑x)","decl":"/-- The functor taking a functor `Discrete α ⥤ C` to a functor `Finset (Discrete α) ⥤ C` by taking\ncoproducts. -/\n@[simps!]\ndef liftToFinset : (Discrete α ⥤ C) ⥤ (Finset (Discrete α) ⥤ C) where\n  obj := liftToFinsetObj\n  map := fun β => { app := fun _ => Sigma.map (fun x => β.app x.val) }\n\n"}
{"name":"CategoryTheory.Limits.hasCoproducts_of_finite_and_filtered","module":"Mathlib.CategoryTheory.Limits.Constructions.Filtered","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteCoproducts C\ninst✝ : CategoryTheory.Limits.HasFilteredColimitsOfSize.{w, w, v, u} C\n⊢ CategoryTheory.Limits.HasCoproducts C","decl":"theorem hasCoproducts_of_finite_and_filtered [HasFiniteCoproducts C]\n    [HasFilteredColimitsOfSize.{w, w} C] : HasCoproducts.{w} C := fun α => by\n  classical exact ⟨fun F => HasColimit.mk (liftToFinsetColimitCocone F)⟩\n\n"}
{"name":"CategoryTheory.Limits.has_colimits_of_finite_and_filtered","module":"Mathlib.CategoryTheory.Limits.Constructions.Filtered","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteColimits C\ninst✝ : CategoryTheory.Limits.HasFilteredColimitsOfSize.{w, w, v, u} C\n⊢ CategoryTheory.Limits.HasColimitsOfSize.{w, w, v, u} C","decl":"theorem has_colimits_of_finite_and_filtered [HasFiniteColimits C]\n    [HasFilteredColimitsOfSize.{w, w} C] : HasColimitsOfSize.{w, w} C :=\n  have : HasCoproducts.{w} C := hasCoproducts_of_finite_and_filtered\n  has_colimits_of_hasCoequalizers_and_coproducts\n\n"}
{"name":"CategoryTheory.Limits.hasProducts_of_finite_and_cofiltered","module":"Mathlib.CategoryTheory.Limits.Constructions.Filtered","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : CategoryTheory.Limits.HasCofilteredLimitsOfSize.{w, w, v, u} C\n⊢ CategoryTheory.Limits.HasProducts C","decl":"theorem hasProducts_of_finite_and_cofiltered [HasFiniteProducts C]\n    [HasCofilteredLimitsOfSize.{w, w} C] : HasProducts.{w} C :=\n  have : HasCoproducts.{w} Cᵒᵖ := hasCoproducts_of_finite_and_filtered\n  hasProducts_of_opposite\n\n"}
{"name":"CategoryTheory.Limits.has_limits_of_finite_and_cofiltered","module":"Mathlib.CategoryTheory.Limits.Constructions.Filtered","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteLimits C\ninst✝ : CategoryTheory.Limits.HasCofilteredLimitsOfSize.{w, w, v, u} C\n⊢ CategoryTheory.Limits.HasLimitsOfSize.{w, w, v, u} C","decl":"theorem has_limits_of_finite_and_cofiltered [HasFiniteLimits C]\n    [HasCofilteredLimitsOfSize.{w, w} C] : HasLimitsOfSize.{w, w} C :=\n  have : HasProducts.{w} C := hasProducts_of_finite_and_cofiltered\n  has_limits_of_hasEqualizers_and_products\n\n"}
{"name":"CategoryTheory.Limits.CoproductsFromFiniteFiltered.liftToFinsetColimIso_aux","module":"Mathlib.CategoryTheory.Limits.Constructions.Filtered","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nα : Type w\ninst✝² : CategoryTheory.Limits.HasFiniteCoproducts C\ninst✝¹ : CategoryTheory.Limits.HasColimitsOfShape (Finset (CategoryTheory.Discrete α)) C\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete α) C\nF : CategoryTheory.Functor (CategoryTheory.Discrete α) C\nJ : Finset (CategoryTheory.Discrete α)\nj : Subtype fun x => Membership.mem J x\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.ι (fun x => F.obj ↑x) j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι (CategoryTheory.Limits.CoproductsFromFiniteFiltered.liftToFinsetObj F) J) (CategoryTheory.Limits.colimit.isoColimitCocone (CategoryTheory.Limits.CoproductsFromFiniteFiltered.liftToFinsetColimitCocone F)).inv)) (CategoryTheory.Limits.colimit.ι F ↑j)","decl":"/-- Helper construction for `liftToFinsetColimIso`. -/\n@[reassoc]\ntheorem liftToFinsetColimIso_aux (F : Discrete α ⥤ C) {J : Finset (Discrete α)} (j : J) :\n    Sigma.ι (F.obj ·.val) j ≫ colimit.ι (liftToFinsetObj F) J ≫\n      (colimit.isoColimitCocone (liftToFinsetColimitCocone F)).inv\n    = colimit.ι F j := by\n  simp [colimit.isoColimitCocone, IsColimit.coconePointUniqueUpToIso]\n\n"}
{"name":"CategoryTheory.Limits.CoproductsFromFiniteFiltered.liftToFinsetColimIso_aux_assoc","module":"Mathlib.CategoryTheory.Limits.Constructions.Filtered","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nα : Type w\ninst✝² : CategoryTheory.Limits.HasFiniteCoproducts C\ninst✝¹ : CategoryTheory.Limits.HasColimitsOfShape (Finset (CategoryTheory.Discrete α)) C\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete α) C\nF : CategoryTheory.Functor (CategoryTheory.Discrete α) C\nJ : Finset (CategoryTheory.Discrete α)\nj : Subtype fun x => Membership.mem J x\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.colimit F) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.ι (fun x => F.obj ↑x) j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι (CategoryTheory.Limits.CoproductsFromFiniteFiltered.liftToFinsetObj F) J) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.isoColimitCocone (CategoryTheory.Limits.CoproductsFromFiniteFiltered.liftToFinsetColimitCocone F)).inv h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι F ↑j) h)","decl":"/-- Helper construction for `liftToFinsetColimIso`. -/\n@[reassoc]\ntheorem liftToFinsetColimIso_aux (F : Discrete α ⥤ C) {J : Finset (Discrete α)} (j : J) :\n    Sigma.ι (F.obj ·.val) j ≫ colimit.ι (liftToFinsetObj F) J ≫\n      (colimit.isoColimitCocone (liftToFinsetColimitCocone F)).inv\n    = colimit.ι F j := by\n  simp [colimit.isoColimitCocone, IsColimit.coconePointUniqueUpToIso]\n\n"}
{"name":"CategoryTheory.Limits.ProductsFromFiniteCofiltered.liftToFinsetObj_map","module":"Mathlib.CategoryTheory.Limits.Constructions.Filtered","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nα : Type w\ninst✝ : CategoryTheory.Limits.HasFiniteProducts C\nF : CategoryTheory.Functor (CategoryTheory.Discrete α) C\nY x✝ : Opposite (Finset (CategoryTheory.Discrete α))\nh : Quiver.Hom Y x✝\n⊢ Eq ((CategoryTheory.Limits.ProductsFromFiniteCofiltered.liftToFinsetObj F).map h) (CategoryTheory.Limits.Pi.lift fun y => CategoryTheory.Limits.Pi.π (fun x => F.obj ↑x) ⟨↑y, ⋯⟩)","decl":"/-- If `C` has finite coproducts, a functor `Discrete α ⥤ C` lifts to a functor\n    `Finset (Discrete α) ⥤ C` by taking coproducts. -/\n@[simps!]\ndef liftToFinsetObj (F : Discrete α ⥤ C) : (Finset (Discrete α))ᵒᵖ ⥤ C where\n  obj s := ∏ᶜ (fun x : s.unop => F.obj x)\n  map {Y _} h := Pi.lift fun y =>\n    Pi.π (fun (x : { x // x ∈ Y.unop }) => F.obj x) ⟨y, h.unop.down.down y.2⟩\n\n\n"}
{"name":"CategoryTheory.Limits.ProductsFromFiniteCofiltered.liftToFinsetObj_obj","module":"Mathlib.CategoryTheory.Limits.Constructions.Filtered","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nα : Type w\ninst✝ : CategoryTheory.Limits.HasFiniteProducts C\nF : CategoryTheory.Functor (CategoryTheory.Discrete α) C\ns : Opposite (Finset (CategoryTheory.Discrete α))\n⊢ Eq ((CategoryTheory.Limits.ProductsFromFiniteCofiltered.liftToFinsetObj F).obj s) (CategoryTheory.Limits.piObj fun x => F.obj ↑x)","decl":"/-- If `C` has finite coproducts, a functor `Discrete α ⥤ C` lifts to a functor\n    `Finset (Discrete α) ⥤ C` by taking coproducts. -/\n@[simps!]\ndef liftToFinsetObj (F : Discrete α ⥤ C) : (Finset (Discrete α))ᵒᵖ ⥤ C where\n  obj s := ∏ᶜ (fun x : s.unop => F.obj x)\n  map {Y _} h := Pi.lift fun y =>\n    Pi.π (fun (x : { x // x ∈ Y.unop }) => F.obj x) ⟨y, h.unop.down.down y.2⟩\n\n\n"}
{"name":"CategoryTheory.Limits.ProductsFromFiniteCofiltered.liftToFinsetLimitCone_cone_pt","module":"Mathlib.CategoryTheory.Limits.Constructions.Filtered","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nα : Type w\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape (Opposite (Finset (CategoryTheory.Discrete α))) C\nF : CategoryTheory.Functor (CategoryTheory.Discrete α) C\n⊢ Eq (CategoryTheory.Limits.ProductsFromFiniteCofiltered.liftToFinsetLimitCone F).cone.pt (CategoryTheory.Limits.limit (CategoryTheory.Limits.ProductsFromFiniteCofiltered.liftToFinsetObj F))","decl":"/-- If `C` has finite coproducts and filtered colimits, we can construct arbitrary coproducts by\n    taking the colimit of the diagram formed by the coproducts of finite sets over the indexing\n    type. -/\n@[simps!]\ndef liftToFinsetLimitCone [HasLimitsOfShape (Finset (Discrete α))ᵒᵖ C]\n    (F : Discrete α ⥤ C) : LimitCone F where\n  cone :=\n    { pt := limit (liftToFinsetObj F)\n      π := Discrete.natTrans fun j =>\n        limit.π (liftToFinsetObj F) ⟨{j}⟩ ≫ Pi.π _ (⟨j, by simp⟩ : ({j} : Finset (Discrete α))) }\n  isLimit :=\n    { lift := fun s =>\n        limit.lift (liftToFinsetObj F)\n          { pt := s.pt\n            π := { app := fun _ => Pi.lift fun x => s.π.app x } }\n      uniq := fun s m h => by\n        apply limit.hom_ext\n        rintro t\n        dsimp [liftToFinsetObj]\n        apply limit.hom_ext\n        rintro ⟨⟨j, hj⟩⟩\n        convert h j using 1\n        · simp [← limit.w (liftToFinsetObj F) ⟨⟨⟨Finset.singleton_subset_iff.2 hj⟩⟩⟩]\n          rfl\n        · simp }\n\n"}
{"name":"CategoryTheory.Limits.ProductsFromFiniteCofiltered.liftToFinsetLimitCone_cone_π_app","module":"Mathlib.CategoryTheory.Limits.Constructions.Filtered","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nα : Type w\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape (Opposite (Finset (CategoryTheory.Discrete α))) C\nF : CategoryTheory.Functor (CategoryTheory.Discrete α) C\nj : CategoryTheory.Discrete α\n⊢ Eq ((CategoryTheory.Limits.ProductsFromFiniteCofiltered.liftToFinsetLimitCone F).cone.π.app j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π (CategoryTheory.Limits.ProductsFromFiniteCofiltered.liftToFinsetObj F) { unop := Singleton.singleton j }) (CategoryTheory.Limits.Pi.π (fun x => F.obj ↑x) ⟨j, ⋯⟩))","decl":"/-- If `C` has finite coproducts and filtered colimits, we can construct arbitrary coproducts by\n    taking the colimit of the diagram formed by the coproducts of finite sets over the indexing\n    type. -/\n@[simps!]\ndef liftToFinsetLimitCone [HasLimitsOfShape (Finset (Discrete α))ᵒᵖ C]\n    (F : Discrete α ⥤ C) : LimitCone F where\n  cone :=\n    { pt := limit (liftToFinsetObj F)\n      π := Discrete.natTrans fun j =>\n        limit.π (liftToFinsetObj F) ⟨{j}⟩ ≫ Pi.π _ (⟨j, by simp⟩ : ({j} : Finset (Discrete α))) }\n  isLimit :=\n    { lift := fun s =>\n        limit.lift (liftToFinsetObj F)\n          { pt := s.pt\n            π := { app := fun _ => Pi.lift fun x => s.π.app x } }\n      uniq := fun s m h => by\n        apply limit.hom_ext\n        rintro t\n        dsimp [liftToFinsetObj]\n        apply limit.hom_ext\n        rintro ⟨⟨j, hj⟩⟩\n        convert h j using 1\n        · simp [← limit.w (liftToFinsetObj F) ⟨⟨⟨Finset.singleton_subset_iff.2 hj⟩⟩⟩]\n          rfl\n        · simp }\n\n"}
{"name":"CategoryTheory.Limits.ProductsFromFiniteCofiltered.liftToFinsetLimitCone_isLimit_lift","module":"Mathlib.CategoryTheory.Limits.Constructions.Filtered","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nα : Type w\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape (Opposite (Finset (CategoryTheory.Discrete α))) C\nF : CategoryTheory.Functor (CategoryTheory.Discrete α) C\ns : CategoryTheory.Limits.Cone F\n⊢ Eq ((CategoryTheory.Limits.ProductsFromFiniteCofiltered.liftToFinsetLimitCone F).isLimit.lift s) (CategoryTheory.Limits.limit.lift (CategoryTheory.Limits.ProductsFromFiniteCofiltered.liftToFinsetObj F) { pt := s.pt, π := { app := fun x => CategoryTheory.Limits.Pi.lift fun x_1 => s.π.app ↑x_1, naturality := ⋯ } })","decl":"/-- If `C` has finite coproducts and filtered colimits, we can construct arbitrary coproducts by\n    taking the colimit of the diagram formed by the coproducts of finite sets over the indexing\n    type. -/\n@[simps!]\ndef liftToFinsetLimitCone [HasLimitsOfShape (Finset (Discrete α))ᵒᵖ C]\n    (F : Discrete α ⥤ C) : LimitCone F where\n  cone :=\n    { pt := limit (liftToFinsetObj F)\n      π := Discrete.natTrans fun j =>\n        limit.π (liftToFinsetObj F) ⟨{j}⟩ ≫ Pi.π _ (⟨j, by simp⟩ : ({j} : Finset (Discrete α))) }\n  isLimit :=\n    { lift := fun s =>\n        limit.lift (liftToFinsetObj F)\n          { pt := s.pt\n            π := { app := fun _ => Pi.lift fun x => s.π.app x } }\n      uniq := fun s m h => by\n        apply limit.hom_ext\n        rintro t\n        dsimp [liftToFinsetObj]\n        apply limit.hom_ext\n        rintro ⟨⟨j, hj⟩⟩\n        convert h j using 1\n        · simp [← limit.w (liftToFinsetObj F) ⟨⟨⟨Finset.singleton_subset_iff.2 hj⟩⟩⟩]\n          rfl\n        · simp }\n\n"}
{"name":"CategoryTheory.Limits.ProductsFromFiniteCofiltered.liftToFinset_obj_obj","module":"Mathlib.CategoryTheory.Limits.Constructions.Filtered","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nα : Type w\ninst✝ : CategoryTheory.Limits.HasFiniteProducts C\nF : CategoryTheory.Functor (CategoryTheory.Discrete α) C\ns : Opposite (Finset (CategoryTheory.Discrete α))\n⊢ Eq (((CategoryTheory.Limits.ProductsFromFiniteCofiltered.liftToFinset C α).obj F).obj s) (CategoryTheory.Limits.piObj fun x => F.obj ↑x)","decl":"/-- The functor taking a functor `Discrete α ⥤ C` to a functor `Finset (Discrete α) ⥤ C` by taking\ncoproducts. -/\n@[simps!]\ndef liftToFinset : (Discrete α ⥤ C) ⥤ ((Finset (Discrete α))ᵒᵖ ⥤ C) where\n  obj := liftToFinsetObj\n  map := fun β => { app := fun _ => Pi.map (fun x => β.app x.val) }\n\n"}
{"name":"CategoryTheory.Limits.ProductsFromFiniteCofiltered.liftToFinset_map_app","module":"Mathlib.CategoryTheory.Limits.Constructions.Filtered","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nα : Type w\ninst✝ : CategoryTheory.Limits.HasFiniteProducts C\nX✝ Y✝ : CategoryTheory.Functor (CategoryTheory.Discrete α) C\nβ : Quiver.Hom X✝ Y✝\nx✝ : Opposite (Finset (CategoryTheory.Discrete α))\n⊢ Eq (((CategoryTheory.Limits.ProductsFromFiniteCofiltered.liftToFinset C α).map β).app x✝) (CategoryTheory.Limits.Pi.map fun x => β.app ↑x)","decl":"/-- The functor taking a functor `Discrete α ⥤ C` to a functor `Finset (Discrete α) ⥤ C` by taking\ncoproducts. -/\n@[simps!]\ndef liftToFinset : (Discrete α ⥤ C) ⥤ ((Finset (Discrete α))ᵒᵖ ⥤ C) where\n  obj := liftToFinsetObj\n  map := fun β => { app := fun _ => Pi.map (fun x => β.app x.val) }\n\n"}
{"name":"CategoryTheory.Limits.ProductsFromFiniteCofiltered.liftToFinset_obj_map","module":"Mathlib.CategoryTheory.Limits.Constructions.Filtered","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nα : Type w\ninst✝ : CategoryTheory.Limits.HasFiniteProducts C\nF : CategoryTheory.Functor (CategoryTheory.Discrete α) C\nY x✝ : Opposite (Finset (CategoryTheory.Discrete α))\nh : Quiver.Hom Y x✝\n⊢ Eq (((CategoryTheory.Limits.ProductsFromFiniteCofiltered.liftToFinset C α).obj F).map h) (CategoryTheory.Limits.Pi.lift fun y => CategoryTheory.Limits.Pi.π (fun x => F.obj ↑x) ⟨↑y, ⋯⟩)","decl":"/-- The functor taking a functor `Discrete α ⥤ C` to a functor `Finset (Discrete α) ⥤ C` by taking\ncoproducts. -/\n@[simps!]\ndef liftToFinset : (Discrete α ⥤ C) ⥤ ((Finset (Discrete α))ᵒᵖ ⥤ C) where\n  obj := liftToFinsetObj\n  map := fun β => { app := fun _ => Pi.map (fun x => β.app x.val) }\n\n"}
