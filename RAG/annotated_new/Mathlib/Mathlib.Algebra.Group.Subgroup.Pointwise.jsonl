{"name":"neg_coe_set","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\nS : Type u_4\ninst✝² : InvolutiveNeg G\ninst✝¹ : SetLike S G\ninst✝ : NegMemClass S G\nH : S\n⊢ Eq (Neg.neg ↑H) ↑H","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem inv_coe_set [InvolutiveInv G] [SetLike S G] [InvMemClass S G] {H : S} : (H : Set G)⁻¹ = H :=\n  Set.ext fun _ => inv_mem_iff\n\n"}
{"name":"inv_coe_set","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\nS : Type u_4\ninst✝² : InvolutiveInv G\ninst✝¹ : SetLike S G\ninst✝ : InvMemClass S G\nH : S\n⊢ Eq (Inv.inv ↑H) ↑H","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem inv_coe_set [InvolutiveInv G] [SetLike S G] [InvMemClass S G] {H : S} : (H : Set G)⁻¹ = H :=\n  Set.ext fun _ => inv_mem_iff\n\n"}
{"name":"vadd_coe_set","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\nS : Type u_4\ninst✝² : AddGroup G\ninst✝¹ : SetLike S G\ninst✝ : AddSubgroupClass S G\ns : S\na : G\nha : Membership.mem s a\n⊢ Eq (HVAdd.hVAdd a ↑s) ↑s","decl":"@[to_additive (attr := simp)]\nlemma smul_coe_set [Group G] [SetLike S G] [SubgroupClass S G] {s : S} {a : G} (ha : a ∈ s) :\n    a • (s : Set G) = s := by\n  ext; simp [Set.mem_smul_set_iff_inv_smul_mem, mul_mem_cancel_left, ha]\n\n"}
{"name":"smul_coe_set","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\nS : Type u_4\ninst✝² : Group G\ninst✝¹ : SetLike S G\ninst✝ : SubgroupClass S G\ns : S\na : G\nha : Membership.mem s a\n⊢ Eq (HSMul.hSMul a ↑s) ↑s","decl":"@[to_additive (attr := simp)]\nlemma smul_coe_set [Group G] [SetLike S G] [SubgroupClass S G] {s : S} {a : G} (ha : a ∈ s) :\n    a • (s : Set G) = s := by\n  ext; simp [Set.mem_smul_set_iff_inv_smul_mem, mul_mem_cancel_left, ha]\n\n"}
{"name":"coe_set_eq_zero","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\ninst✝ : AddGroup G\ns : AddSubgroup G\n⊢ Iff (Eq (↑s) 0) (Eq s Bot.bot)","decl":"@[norm_cast, to_additive]\nlemma coe_set_eq_one [Group G] {s : Subgroup G} : (s : Set G) = 1 ↔ s = ⊥ :=\n  (SetLike.ext'_iff.trans (by rfl)).symm\n\n"}
{"name":"coe_set_eq_one","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\ninst✝ : Group G\ns : Subgroup G\n⊢ Iff (Eq (↑s) 1) (Eq s Bot.bot)","decl":"@[norm_cast, to_additive]\nlemma coe_set_eq_one [Group G] {s : Subgroup G} : (s : Set G) = 1 ↔ s = ⊥ :=\n  (SetLike.ext'_iff.trans (by rfl)).symm\n\n"}
{"name":"op_smul_coe_set","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\nS : Type u_4\ninst✝² : Group G\ninst✝¹ : SetLike S G\ninst✝ : SubgroupClass S G\ns : S\na : G\nha : Membership.mem s a\n⊢ Eq (HSMul.hSMul (MulOpposite.op a) ↑s) ↑s","decl":"@[to_additive (attr := simp)]\nlemma op_smul_coe_set [Group G] [SetLike S G] [SubgroupClass S G] {s : S} {a : G} (ha : a ∈ s) :\n    MulOpposite.op a • (s : Set G) = s := by\n  ext; simp [Set.mem_smul_set_iff_inv_smul_mem, mul_mem_cancel_right, ha]\n\n"}
{"name":"op_vadd_coe_set","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\nS : Type u_4\ninst✝² : AddGroup G\ninst✝¹ : SetLike S G\ninst✝ : AddSubgroupClass S G\ns : S\na : G\nha : Membership.mem s a\n⊢ Eq (HVAdd.hVAdd (AddOpposite.op a) ↑s) ↑s","decl":"@[to_additive (attr := simp)]\nlemma op_smul_coe_set [Group G] [SetLike S G] [SubgroupClass S G] {s : S} {a : G} (ha : a ∈ s) :\n    MulOpposite.op a • (s : Set G) = s := by\n  ext; simp [Set.mem_smul_set_iff_inv_smul_mem, mul_mem_cancel_right, ha]\n\n"}
{"name":"coe_div_coe","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\nS : Type u_4\ninst✝² : SetLike S G\ninst✝¹ : DivisionMonoid G\ninst✝ : SubgroupClass S G\nH : S\n⊢ Eq (HDiv.hDiv ↑H ↑H) ↑H","decl":"@[to_additive (attr := simp, norm_cast)]\nlemma coe_div_coe [SetLike S G] [DivisionMonoid G] [SubgroupClass S G] (H : S) :\n    H / H = (H : Set G) := by simp [div_eq_mul_inv]\n\n"}
{"name":"coe_sub_coe","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\nS : Type u_4\ninst✝² : SetLike S G\ninst✝¹ : SubtractionMonoid G\ninst✝ : AddSubgroupClass S G\nH : S\n⊢ Eq (HSub.hSub ↑H ↑H) ↑H","decl":"@[to_additive (attr := simp, norm_cast)]\nlemma coe_div_coe [SetLike S G] [DivisionMonoid G] [SubgroupClass S G] (H : S) :\n    H / H = (H : Set G) := by simp [div_eq_mul_inv]\n\n"}
{"name":"Set.add_addSubgroupClosure","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\ninst✝ : AddGroup G\ns : Set G\nhs : s.Nonempty\n⊢ Eq (HAdd.hAdd s ↑(AddSubgroup.closure s)) ↑(AddSubgroup.closure s)","decl":"@[to_additive (attr := simp)]\nlemma mul_subgroupClosure (hs : s.Nonempty) : s * closure s = closure s := by\n  rw [← smul_eq_mul, ← Set.iUnion_smul_set]\n  have h a (ha : a ∈ s) : a • (closure s : Set G) = closure s :=\n    smul_coe_set <| subset_closure ha\n  simp +contextual [h, hs]\n\n"}
{"name":"Set.mul_subgroupClosure","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\ninst✝ : Group G\ns : Set G\nhs : s.Nonempty\n⊢ Eq (HMul.hMul s ↑(Subgroup.closure s)) ↑(Subgroup.closure s)","decl":"@[to_additive (attr := simp)]\nlemma mul_subgroupClosure (hs : s.Nonempty) : s * closure s = closure s := by\n  rw [← smul_eq_mul, ← Set.iUnion_smul_set]\n  have h a (ha : a ∈ s) : a • (closure s : Set G) = closure s :=\n    smul_coe_set <| subset_closure ha\n  simp +contextual [h, hs]\n\n"}
{"name":"Set.subgroupClosure_mul","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\ninst✝ : Group G\ns : Set G\nhs : s.Nonempty\n⊢ Eq (HMul.hMul (↑(Subgroup.closure s)) s) ↑(Subgroup.closure s)","decl":"open scoped RightActions in\n@[to_additive (attr := simp)]\nlemma subgroupClosure_mul (hs : s.Nonempty) : closure s * s = closure s := by\n  rw [← Set.iUnion_op_smul_set]\n  have h a (ha : a ∈ s) :  (closure s : Set G) <• a = closure s :=\n    op_smul_coe_set <| subset_closure ha\n  simp +contextual [h, hs]\n\n"}
{"name":"Set.addSubgroupClosure_add","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\ninst✝ : AddGroup G\ns : Set G\nhs : s.Nonempty\n⊢ Eq (HAdd.hAdd (↑(AddSubgroup.closure s)) s) ↑(AddSubgroup.closure s)","decl":"open scoped RightActions in\n@[to_additive (attr := simp)]\nlemma subgroupClosure_mul (hs : s.Nonempty) : closure s * s = closure s := by\n  rw [← Set.iUnion_op_smul_set]\n  have h a (ha : a ∈ s) :  (closure s : Set G) <• a = closure s :=\n    op_smul_coe_set <| subset_closure ha\n  simp +contextual [h, hs]\n\n"}
{"name":"Set.pow_mul_subgroupClosure","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\ninst✝ : Group G\ns : Set G\nhs : s.Nonempty\nn : Nat\n⊢ Eq (HMul.hMul (HPow.hPow s n) ↑(Subgroup.closure s)) ↑(Subgroup.closure s)","decl":"@[to_additive (attr := simp)]\nlemma pow_mul_subgroupClosure (hs : s.Nonempty) : ∀ n, s ^ n * closure s = closure s\n  | 0 => by simp\n  | n + 1 => by rw [pow_succ, mul_assoc, mul_subgroupClosure hs, pow_mul_subgroupClosure hs]\n\n"}
{"name":"Set.nsmul_add_addSubgroupClosure","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\ninst✝ : AddGroup G\ns : Set G\nhs : s.Nonempty\nn : Nat\n⊢ Eq (HAdd.hAdd (HSMul.hSMul n s) ↑(AddSubgroup.closure s)) ↑(AddSubgroup.closure s)","decl":"@[to_additive (attr := simp)]\nlemma pow_mul_subgroupClosure (hs : s.Nonempty) : ∀ n, s ^ n * closure s = closure s\n  | 0 => by simp\n  | n + 1 => by rw [pow_succ, mul_assoc, mul_subgroupClosure hs, pow_mul_subgroupClosure hs]\n\n"}
{"name":"Set.addSubgroupClosure_add_nsmul","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\ninst✝ : AddGroup G\ns : Set G\nhs : s.Nonempty\nn : Nat\n⊢ Eq (HAdd.hAdd (↑(AddSubgroup.closure s)) (HSMul.hSMul n s)) ↑(AddSubgroup.closure s)","decl":"@[to_additive (attr := simp)]\nlemma subgroupClosure_mul_pow (hs : s.Nonempty) : ∀ n, closure s * s ^ n = closure s\n  | 0 => by simp\n  | n + 1 => by rw [pow_succ', ← mul_assoc, subgroupClosure_mul hs, subgroupClosure_mul_pow hs]\n\n"}
{"name":"Set.subgroupClosure_mul_pow","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\ninst✝ : Group G\ns : Set G\nhs : s.Nonempty\nn : Nat\n⊢ Eq (HMul.hMul (↑(Subgroup.closure s)) (HPow.hPow s n)) ↑(Subgroup.closure s)","decl":"@[to_additive (attr := simp)]\nlemma subgroupClosure_mul_pow (hs : s.Nonempty) : ∀ n, closure s * s ^ n = closure s\n  | 0 => by simp\n  | n + 1 => by rw [pow_succ', ← mul_assoc, subgroupClosure_mul hs, subgroupClosure_mul_pow hs]\n\n"}
{"name":"Subgroup.inv_subset_closure","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\ninst✝ : Group G\nS : Set G\n⊢ HasSubset.Subset (Inv.inv S) ↑(Subgroup.closure S)","decl":"@[to_additive (attr := simp)]\ntheorem inv_subset_closure (S : Set G) : S⁻¹ ⊆ closure S := fun s hs => by\n  rw [SetLike.mem_coe, ← Subgroup.inv_mem_iff]\n  exact subset_closure (mem_inv.mp hs)\n\n"}
{"name":"AddSubgroup.neg_subset_closure","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\ninst✝ : AddGroup G\nS : Set G\n⊢ HasSubset.Subset (Neg.neg S) ↑(AddSubgroup.closure S)","decl":"@[to_additive (attr := simp)]\ntheorem inv_subset_closure (S : Set G) : S⁻¹ ⊆ closure S := fun s hs => by\n  rw [SetLike.mem_coe, ← Subgroup.inv_mem_iff]\n  exact subset_closure (mem_inv.mp hs)\n\n"}
{"name":"Subgroup.closure_toSubmonoid","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\ninst✝ : Group G\nS : Set G\n⊢ Eq (Subgroup.closure S).toSubmonoid (Submonoid.closure (Union.union S (Inv.inv S)))","decl":"@[to_additive]\ntheorem closure_toSubmonoid (S : Set G) :\n    (closure S).toSubmonoid = Submonoid.closure (S ∪ S⁻¹) := by\n  refine le_antisymm (fun x hx => ?_) (Submonoid.closure_le.2 ?_)\n  · refine\n      closure_induction\n        (fun x hx => Submonoid.closure_mono subset_union_left (Submonoid.subset_closure hx))\n        (Submonoid.one_mem _) (fun x y _ _ hx hy => Submonoid.mul_mem _ hx hy) (fun x _ hx => ?_) hx\n    rwa [← Submonoid.mem_closure_inv, Set.union_inv, inv_inv, Set.union_comm]\n  · simp only [true_and, coe_toSubmonoid, union_subset_iff, subset_closure, inv_subset_closure]\n\n"}
{"name":"AddSubgroup.closure_toAddSubmonoid","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\ninst✝ : AddGroup G\nS : Set G\n⊢ Eq (AddSubgroup.closure S).toAddSubmonoid (AddSubmonoid.closure (Union.union S (Neg.neg S)))","decl":"@[to_additive]\ntheorem closure_toSubmonoid (S : Set G) :\n    (closure S).toSubmonoid = Submonoid.closure (S ∪ S⁻¹) := by\n  refine le_antisymm (fun x hx => ?_) (Submonoid.closure_le.2 ?_)\n  · refine\n      closure_induction\n        (fun x hx => Submonoid.closure_mono subset_union_left (Submonoid.subset_closure hx))\n        (Submonoid.one_mem _) (fun x y _ _ hx hy => Submonoid.mul_mem _ hx hy) (fun x _ hx => ?_) hx\n    rwa [← Submonoid.mem_closure_inv, Set.union_inv, inv_inv, Set.union_comm]\n  · simp only [true_and, coe_toSubmonoid, union_subset_iff, subset_closure, inv_subset_closure]\n\n"}
{"name":"Subgroup.closure_induction_left","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\ninst✝ : Group G\ns : Set G\np : (x : G) → Membership.mem (Subgroup.closure s) x → Prop\none : p 1 ⋯\nmul_left : ∀ (x : G) (hx : Membership.mem s x) (y : G) (hy : Membership.mem (Subgroup.closure s) y), p y hy → p (HMul.hMul x y) ⋯\ninv_mul_cancel : ∀ (x : G) (hx : Membership.mem s x) (y : G) (hy : Membership.mem (Subgroup.closure s) y), p y hy → p (HMul.hMul (Inv.inv x) y) ⋯\nx : G\nh : Membership.mem (Subgroup.closure s) x\n⊢ p x h","decl":"/-- For subgroups generated by a single element, see the simpler `zpow_induction_left`. -/\n@[to_additive (attr := elab_as_elim)\n  \"For additive subgroups generated by a single element, see the simpler\n  `zsmul_induction_left`.\"]\ntheorem closure_induction_left {p : (x : G) → x ∈ closure s → Prop} (one : p 1 (one_mem _))\n    (mul_left : ∀ x (hx : x ∈ s), ∀ (y) hy, p y hy → p (x * y) (mul_mem (subset_closure hx) hy))\n    (inv_mul_cancel : ∀ x (hx : x ∈ s), ∀ (y) hy, p y hy →\n      p (x⁻¹ * y) (mul_mem (inv_mem (subset_closure hx)) hy))\n    {x : G} (h : x ∈ closure s) : p x h := by\n  revert h\n  simp_rw [← mem_toSubmonoid, closure_toSubmonoid] at *\n  intro h\n  induction h using Submonoid.closure_induction_left with\n  | one => exact one\n  | mul_left x hx y hy ih =>\n    cases hx with\n    | inl hx => exact mul_left _ hx _ hy ih\n    | inr hx => simpa only [inv_inv] using inv_mul_cancel _ hx _ hy ih\n\n"}
{"name":"AddSubgroup.closure_induction_left","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\ninst✝ : AddGroup G\ns : Set G\np : (x : G) → Membership.mem (AddSubgroup.closure s) x → Prop\none : p 0 ⋯\nmul_left : ∀ (x : G) (hx : Membership.mem s x) (y : G) (hy : Membership.mem (AddSubgroup.closure s) y), p y hy → p (HAdd.hAdd x y) ⋯\ninv_mul_cancel : ∀ (x : G) (hx : Membership.mem s x) (y : G) (hy : Membership.mem (AddSubgroup.closure s) y), p y hy → p (HAdd.hAdd (Neg.neg x) y) ⋯\nx : G\nh : Membership.mem (AddSubgroup.closure s) x\n⊢ p x h","decl":"/-- For subgroups generated by a single element, see the simpler `zpow_induction_left`. -/\n@[to_additive (attr := elab_as_elim)\n  \"For additive subgroups generated by a single element, see the simpler\n  `zsmul_induction_left`.\"]\ntheorem closure_induction_left {p : (x : G) → x ∈ closure s → Prop} (one : p 1 (one_mem _))\n    (mul_left : ∀ x (hx : x ∈ s), ∀ (y) hy, p y hy → p (x * y) (mul_mem (subset_closure hx) hy))\n    (inv_mul_cancel : ∀ x (hx : x ∈ s), ∀ (y) hy, p y hy →\n      p (x⁻¹ * y) (mul_mem (inv_mem (subset_closure hx)) hy))\n    {x : G} (h : x ∈ closure s) : p x h := by\n  revert h\n  simp_rw [← mem_toSubmonoid, closure_toSubmonoid] at *\n  intro h\n  induction h using Submonoid.closure_induction_left with\n  | one => exact one\n  | mul_left x hx y hy ih =>\n    cases hx with\n    | inl hx => exact mul_left _ hx _ hy ih\n    | inr hx => simpa only [inv_inv] using inv_mul_cancel _ hx _ hy ih\n\n"}
{"name":"AddSubgroup.closure_induction_right","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\ninst✝ : AddGroup G\ns : Set G\np : (x : G) → Membership.mem (AddSubgroup.closure s) x → Prop\none : p 0 ⋯\nmul_right : ∀ (x : G) (hx : Membership.mem (AddSubgroup.closure s) x) (y : G) (hy : Membership.mem s y), p x hx → p (HAdd.hAdd x y) ⋯\nmul_inv_cancel : ∀ (x : G) (hx : Membership.mem (AddSubgroup.closure s) x) (y : G) (hy : Membership.mem s y), p x hx → p (HAdd.hAdd x (Neg.neg y)) ⋯\nx : G\nh : Membership.mem (AddSubgroup.closure s) x\n⊢ p x h","decl":"/-- For subgroups generated by a single element, see the simpler `zpow_induction_right`. -/\n@[to_additive (attr := elab_as_elim)\n  \"For additive subgroups generated by a single element, see the simpler\n  `zsmul_induction_right`.\"]\ntheorem closure_induction_right {p : (x : G) → x ∈ closure s → Prop} (one : p 1 (one_mem _))\n    (mul_right : ∀ (x) hx, ∀ y (hy : y ∈ s), p x hx → p (x * y) (mul_mem hx (subset_closure hy)))\n    (mul_inv_cancel : ∀ (x) hx, ∀ y (hy : y ∈ s), p x hx →\n      p (x * y⁻¹) (mul_mem hx (inv_mem (subset_closure hy))))\n    {x : G} (h : x ∈ closure s) : p x h :=\n  closure_induction_left (s := MulOpposite.unop ⁻¹' s)\n    (p := fun m hm => p m.unop <| by rwa [← op_closure] at hm)\n    one\n    (fun _x hx _y _ => mul_right _ _ _ hx)\n    (fun _x hx _y _ => mul_inv_cancel _ _ _ hx)\n    (by rwa [← op_closure])\n\n"}
{"name":"Subgroup.closure_induction_right","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\ninst✝ : Group G\ns : Set G\np : (x : G) → Membership.mem (Subgroup.closure s) x → Prop\none : p 1 ⋯\nmul_right : ∀ (x : G) (hx : Membership.mem (Subgroup.closure s) x) (y : G) (hy : Membership.mem s y), p x hx → p (HMul.hMul x y) ⋯\nmul_inv_cancel : ∀ (x : G) (hx : Membership.mem (Subgroup.closure s) x) (y : G) (hy : Membership.mem s y), p x hx → p (HMul.hMul x (Inv.inv y)) ⋯\nx : G\nh : Membership.mem (Subgroup.closure s) x\n⊢ p x h","decl":"/-- For subgroups generated by a single element, see the simpler `zpow_induction_right`. -/\n@[to_additive (attr := elab_as_elim)\n  \"For additive subgroups generated by a single element, see the simpler\n  `zsmul_induction_right`.\"]\ntheorem closure_induction_right {p : (x : G) → x ∈ closure s → Prop} (one : p 1 (one_mem _))\n    (mul_right : ∀ (x) hx, ∀ y (hy : y ∈ s), p x hx → p (x * y) (mul_mem hx (subset_closure hy)))\n    (mul_inv_cancel : ∀ (x) hx, ∀ y (hy : y ∈ s), p x hx →\n      p (x * y⁻¹) (mul_mem hx (inv_mem (subset_closure hy))))\n    {x : G} (h : x ∈ closure s) : p x h :=\n  closure_induction_left (s := MulOpposite.unop ⁻¹' s)\n    (p := fun m hm => p m.unop <| by rwa [← op_closure] at hm)\n    one\n    (fun _x hx _y _ => mul_right _ _ _ hx)\n    (fun _x hx _y _ => mul_inv_cancel _ _ _ hx)\n    (by rwa [← op_closure])\n\n"}
{"name":"Subgroup.closure_inv","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\ninst✝ : Group G\ns : Set G\n⊢ Eq (Subgroup.closure (Inv.inv s)) (Subgroup.closure s)","decl":"@[to_additive (attr := simp)]\ntheorem closure_inv (s : Set G) : closure s⁻¹ = closure s := by\n  simp only [← toSubmonoid_inj, closure_toSubmonoid, inv_inv, union_comm]\n\n"}
{"name":"AddSubgroup.closure_neg","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\ninst✝ : AddGroup G\ns : Set G\n⊢ Eq (AddSubgroup.closure (Neg.neg s)) (AddSubgroup.closure s)","decl":"@[to_additive (attr := simp)]\ntheorem closure_inv (s : Set G) : closure s⁻¹ = closure s := by\n  simp only [← toSubmonoid_inj, closure_toSubmonoid, inv_inv, union_comm]\n\n"}
{"name":"Subgroup.closure_singleton_inv","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\ninst✝ : Group G\nx : G\n⊢ Eq (Subgroup.closure (Singleton.singleton (Inv.inv x))) (Subgroup.closure (Singleton.singleton x))","decl":"@[to_additive (attr := simp)]\nlemma closure_singleton_inv (x : G) : closure {x⁻¹} = closure {x} := by\n  rw [← Set.inv_singleton, closure_inv]\n\n"}
{"name":"AddSubgroup.closure_singleton_neg","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\ninst✝ : AddGroup G\nx : G\n⊢ Eq (AddSubgroup.closure (Singleton.singleton (Neg.neg x))) (AddSubgroup.closure (Singleton.singleton x))","decl":"@[to_additive (attr := simp)]\nlemma closure_singleton_inv (x : G) : closure {x⁻¹} = closure {x} := by\n  rw [← Set.inv_singleton, closure_inv]\n\n"}
{"name":"Subgroup.closure_induction''","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\ninst✝ : Group G\ns : Set G\np : (g : G) → Membership.mem (Subgroup.closure s) g → Prop\nmem : ∀ (x : G) (hx : Membership.mem s x), p x ⋯\ninv_mem : ∀ (x : G) (hx : Membership.mem s x), p (Inv.inv x) ⋯\none : p 1 ⋯\nmul : ∀ (x y : G) (hx : Membership.mem (Subgroup.closure s) x) (hy : Membership.mem (Subgroup.closure s) y), p x hx → p y hy → p (HMul.hMul x y) ⋯\nx : G\nh : Membership.mem (Subgroup.closure s) x\n⊢ p x h","decl":"/-- An induction principle for closure membership. If `p` holds for `1` and all elements of\n`k` and their inverse, and is preserved under multiplication, then `p` holds for all elements of\nthe closure of `k`. -/\n@[to_additive (attr := elab_as_elim)\n  \"An induction principle for additive closure membership. If `p` holds for `0` and all\n  elements of `k` and their negation, and is preserved under addition, then `p` holds for all\n  elements of the additive closure of `k`.\"]\ntheorem closure_induction'' {p : (g : G) → g ∈ closure s → Prop}\n    (mem : ∀ x (hx : x ∈ s), p x (subset_closure hx))\n    (inv_mem : ∀ x (hx : x ∈ s), p x⁻¹ (inv_mem (subset_closure hx)))\n    (one : p 1 (one_mem _))\n    (mul : ∀ x y hx hy, p x hx → p y hy → p (x * y) (mul_mem hx hy))\n    {x} (h : x ∈ closure s) : p x h :=\n  closure_induction_left one (fun x hx y _ hy => mul x y _ _ (mem x hx) hy)\n    (fun x hx y _ => mul x⁻¹ y _ _ <| inv_mem x hx) h\n\n"}
{"name":"AddSubgroup.closure_induction''","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\ninst✝ : AddGroup G\ns : Set G\np : (g : G) → Membership.mem (AddSubgroup.closure s) g → Prop\nmem : ∀ (x : G) (hx : Membership.mem s x), p x ⋯\ninv_mem : ∀ (x : G) (hx : Membership.mem s x), p (Neg.neg x) ⋯\none : p 0 ⋯\nmul : ∀ (x y : G) (hx : Membership.mem (AddSubgroup.closure s) x) (hy : Membership.mem (AddSubgroup.closure s) y), p x hx → p y hy → p (HAdd.hAdd x y) ⋯\nx : G\nh : Membership.mem (AddSubgroup.closure s) x\n⊢ p x h","decl":"/-- An induction principle for closure membership. If `p` holds for `1` and all elements of\n`k` and their inverse, and is preserved under multiplication, then `p` holds for all elements of\nthe closure of `k`. -/\n@[to_additive (attr := elab_as_elim)\n  \"An induction principle for additive closure membership. If `p` holds for `0` and all\n  elements of `k` and their negation, and is preserved under addition, then `p` holds for all\n  elements of the additive closure of `k`.\"]\ntheorem closure_induction'' {p : (g : G) → g ∈ closure s → Prop}\n    (mem : ∀ x (hx : x ∈ s), p x (subset_closure hx))\n    (inv_mem : ∀ x (hx : x ∈ s), p x⁻¹ (inv_mem (subset_closure hx)))\n    (one : p 1 (one_mem _))\n    (mul : ∀ x y hx hy, p x hx → p y hy → p (x * y) (mul_mem hx hy))\n    {x} (h : x ∈ closure s) : p x h :=\n  closure_induction_left one (fun x hx y _ hy => mul x y _ _ (mem x hx) hy)\n    (fun x hx y _ => mul x⁻¹ y _ _ <| inv_mem x hx) h\n\n"}
{"name":"AddSubgroup.iSup_induction","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\ninst✝ : AddGroup G\nι : Sort u_5\nS : ι → AddSubgroup G\nC : G → Prop\nx : G\nhx : Membership.mem (iSup fun i => S i) x\nmem : ∀ (i : ι) (x : G), Membership.mem (S i) x → C x\none : C 0\nmul : ∀ (x y : G), C x → C y → C (HAdd.hAdd x y)\n⊢ C x","decl":"/-- An induction principle for elements of `⨆ i, S i`.\nIf `C` holds for `1` and all elements of `S i` for all `i`, and is preserved under multiplication,\nthen it holds for all elements of the supremum of `S`. -/\n@[to_additive (attr := elab_as_elim) \" An induction principle for elements of `⨆ i, S i`.\nIf `C` holds for `0` and all elements of `S i` for all `i`, and is preserved under addition,\nthen it holds for all elements of the supremum of `S`. \"]\ntheorem iSup_induction {ι : Sort*} (S : ι → Subgroup G) {C : G → Prop} {x : G} (hx : x ∈ ⨆ i, S i)\n    (mem : ∀ (i), ∀ x ∈ S i, C x) (one : C 1) (mul : ∀ x y, C x → C y → C (x * y)) : C x := by\n  rw [iSup_eq_closure] at hx\n  induction hx using closure_induction'' with\n  | one => exact one\n  | mem x hx =>\n    obtain ⟨i, hi⟩ := Set.mem_iUnion.mp hx\n    exact mem _ _ hi\n  | inv_mem x hx =>\n    obtain ⟨i, hi⟩ := Set.mem_iUnion.mp hx\n    exact mem _ _ (inv_mem hi)\n  | mul x y _ _ ihx ihy => exact mul x y ihx ihy\n\n"}
{"name":"Subgroup.iSup_induction","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\ninst✝ : Group G\nι : Sort u_5\nS : ι → Subgroup G\nC : G → Prop\nx : G\nhx : Membership.mem (iSup fun i => S i) x\nmem : ∀ (i : ι) (x : G), Membership.mem (S i) x → C x\none : C 1\nmul : ∀ (x y : G), C x → C y → C (HMul.hMul x y)\n⊢ C x","decl":"/-- An induction principle for elements of `⨆ i, S i`.\nIf `C` holds for `1` and all elements of `S i` for all `i`, and is preserved under multiplication,\nthen it holds for all elements of the supremum of `S`. -/\n@[to_additive (attr := elab_as_elim) \" An induction principle for elements of `⨆ i, S i`.\nIf `C` holds for `0` and all elements of `S i` for all `i`, and is preserved under addition,\nthen it holds for all elements of the supremum of `S`. \"]\ntheorem iSup_induction {ι : Sort*} (S : ι → Subgroup G) {C : G → Prop} {x : G} (hx : x ∈ ⨆ i, S i)\n    (mem : ∀ (i), ∀ x ∈ S i, C x) (one : C 1) (mul : ∀ x y, C x → C y → C (x * y)) : C x := by\n  rw [iSup_eq_closure] at hx\n  induction hx using closure_induction'' with\n  | one => exact one\n  | mem x hx =>\n    obtain ⟨i, hi⟩ := Set.mem_iUnion.mp hx\n    exact mem _ _ hi\n  | inv_mem x hx =>\n    obtain ⟨i, hi⟩ := Set.mem_iUnion.mp hx\n    exact mem _ _ (inv_mem hi)\n  | mul x y _ _ ihx ihy => exact mul x y ihx ihy\n\n"}
{"name":"Subgroup.iSup_induction'","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\ninst✝ : Group G\nι : Sort u_5\nS : ι → Subgroup G\nC : (x : G) → Membership.mem (iSup fun i => S i) x → Prop\nhp : ∀ (i : ι) (x : G) (hx : Membership.mem (S i) x), C x ⋯\nh1 : C 1 ⋯\nhmul : ∀ (x y : G) (hx : Membership.mem (iSup fun i => S i) x) (hy : Membership.mem (iSup fun i => S i) y), C x hx → C y hy → C (HMul.hMul x y) ⋯\nx : G\nhx : Membership.mem (iSup fun i => S i) x\n⊢ C x hx","decl":"/-- A dependent version of `Subgroup.iSup_induction`. -/\n@[to_additive (attr := elab_as_elim) \"A dependent version of `AddSubgroup.iSup_induction`. \"]\ntheorem iSup_induction' {ι : Sort*} (S : ι → Subgroup G) {C : ∀ x, (x ∈ ⨆ i, S i) → Prop}\n    (hp : ∀ (i), ∀ x (hx : x ∈ S i), C x (mem_iSup_of_mem i hx)) (h1 : C 1 (one_mem _))\n    (hmul : ∀ x y hx hy, C x hx → C y hy → C (x * y) (mul_mem ‹_› ‹_›)) {x : G}\n    (hx : x ∈ ⨆ i, S i) : C x hx := by\n  suffices ∃ h, C x h from this.snd\n  refine iSup_induction S (C := fun x => ∃ h, C x h) hx (fun i x hx => ?_) ?_ fun x y => ?_\n  · exact ⟨_, hp i _ hx⟩\n  · exact ⟨_, h1⟩\n  · rintro ⟨_, Cx⟩ ⟨_, Cy⟩\n    exact ⟨_, hmul _ _ _ _ Cx Cy⟩\n\n"}
{"name":"AddSubgroup.iSup_induction'","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\ninst✝ : AddGroup G\nι : Sort u_5\nS : ι → AddSubgroup G\nC : (x : G) → Membership.mem (iSup fun i => S i) x → Prop\nhp : ∀ (i : ι) (x : G) (hx : Membership.mem (S i) x), C x ⋯\nh1 : C 0 ⋯\nhmul : ∀ (x y : G) (hx : Membership.mem (iSup fun i => S i) x) (hy : Membership.mem (iSup fun i => S i) y), C x hx → C y hy → C (HAdd.hAdd x y) ⋯\nx : G\nhx : Membership.mem (iSup fun i => S i) x\n⊢ C x hx","decl":"/-- A dependent version of `Subgroup.iSup_induction`. -/\n@[to_additive (attr := elab_as_elim) \"A dependent version of `AddSubgroup.iSup_induction`. \"]\ntheorem iSup_induction' {ι : Sort*} (S : ι → Subgroup G) {C : ∀ x, (x ∈ ⨆ i, S i) → Prop}\n    (hp : ∀ (i), ∀ x (hx : x ∈ S i), C x (mem_iSup_of_mem i hx)) (h1 : C 1 (one_mem _))\n    (hmul : ∀ x y hx hy, C x hx → C y hy → C (x * y) (mul_mem ‹_› ‹_›)) {x : G}\n    (hx : x ∈ ⨆ i, S i) : C x hx := by\n  suffices ∃ h, C x h from this.snd\n  refine iSup_induction S (C := fun x => ∃ h, C x h) hx (fun i x hx => ?_) ?_ fun x y => ?_\n  · exact ⟨_, hp i _ hx⟩\n  · exact ⟨_, h1⟩\n  · rintro ⟨_, Cx⟩ ⟨_, Cy⟩\n    exact ⟨_, hmul _ _ _ _ Cx Cy⟩\n\n"}
{"name":"Subgroup.closure_mul_le","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\ninst✝ : Group G\nS T : Set G\n⊢ LE.le (Subgroup.closure (HMul.hMul S T)) (Max.max (Subgroup.closure S) (Subgroup.closure T))","decl":"@[to_additive]\ntheorem closure_mul_le (S T : Set G) : closure (S * T) ≤ closure S ⊔ closure T :=\n  sInf_le fun _x ⟨_s, hs, _t, ht, hx⟩ => hx ▸\n    (closure S ⊔ closure T).mul_mem (SetLike.le_def.mp le_sup_left <| subset_closure hs)\n      (SetLike.le_def.mp le_sup_right <| subset_closure ht)\n\n"}
{"name":"AddSubgroup.closure_add_le","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\ninst✝ : AddGroup G\nS T : Set G\n⊢ LE.le (AddSubgroup.closure (HAdd.hAdd S T)) (Max.max (AddSubgroup.closure S) (AddSubgroup.closure T))","decl":"@[to_additive]\ntheorem closure_mul_le (S T : Set G) : closure (S * T) ≤ closure S ⊔ closure T :=\n  sInf_le fun _x ⟨_s, hs, _t, ht, hx⟩ => hx ▸\n    (closure S ⊔ closure T).mul_mem (SetLike.le_def.mp le_sup_left <| subset_closure hs)\n      (SetLike.le_def.mp le_sup_right <| subset_closure ht)\n\n"}
{"name":"AddSubgroup.closure_nsmul_le","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\ninst✝ : AddGroup G\ns : Set G\nn : Nat\na✝ : Ne n 0\n⊢ LE.le (AddSubgroup.closure (HSMul.hSMul n s)) (AddSubgroup.closure s)","decl":"@[to_additive]\nlemma closure_pow_le : ∀ {n}, n ≠ 0 → closure (s ^ n) ≤ closure s\n  | 1, _ => by simp\n  | n + 2, _ =>\n    calc\n      closure (s ^ (n + 2))\n      _ = closure (s ^ (n + 1) * s) := by rw [pow_succ]\n      _ ≤ closure (s ^ (n + 1)) ⊔ closure s := closure_mul_le ..\n      _ ≤ closure s ⊔ closure s := by gcongr ?_ ⊔ _; exact closure_pow_le n.succ_ne_zero\n      _ = closure s := sup_idem _\n\n"}
{"name":"Subgroup.closure_pow_le","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\ninst✝ : Group G\ns : Set G\nn : Nat\na✝ : Ne n 0\n⊢ LE.le (Subgroup.closure (HPow.hPow s n)) (Subgroup.closure s)","decl":"@[to_additive]\nlemma closure_pow_le : ∀ {n}, n ≠ 0 → closure (s ^ n) ≤ closure s\n  | 1, _ => by simp\n  | n + 2, _ =>\n    calc\n      closure (s ^ (n + 2))\n      _ = closure (s ^ (n + 1) * s) := by rw [pow_succ]\n      _ ≤ closure (s ^ (n + 1)) ⊔ closure s := closure_mul_le ..\n      _ ≤ closure s ⊔ closure s := by gcongr ?_ ⊔ _; exact closure_pow_le n.succ_ne_zero\n      _ = closure s := sup_idem _\n\n"}
{"name":"AddSubgroup.closure_nsmul","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\ninst✝ : AddGroup G\ns : Set G\nn : Nat\nhs : Membership.mem s 0\nhn : Ne n 0\n⊢ Eq (AddSubgroup.closure (HSMul.hSMul n s)) (AddSubgroup.closure s)","decl":"@[to_additive]\nlemma closure_pow {n : ℕ} (hs : 1 ∈ s) (hn : n ≠ 0) : closure (s ^ n) = closure s :=\n  (closure_pow_le hn).antisymm <| by gcongr; exact subset_pow hs hn\n\n"}
{"name":"Subgroup.closure_pow","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\ninst✝ : Group G\ns : Set G\nn : Nat\nhs : Membership.mem s 1\nhn : Ne n 0\n⊢ Eq (Subgroup.closure (HPow.hPow s n)) (Subgroup.closure s)","decl":"@[to_additive]\nlemma closure_pow {n : ℕ} (hs : 1 ∈ s) (hn : n ≠ 0) : closure (s ^ n) = closure s :=\n  (closure_pow_le hn).antisymm <| by gcongr; exact subset_pow hs hn\n\n"}
{"name":"Subgroup.sup_eq_closure_mul","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\ninst✝ : Group G\nH K : Subgroup G\n⊢ Eq (Max.max H K) (Subgroup.closure (HMul.hMul ↑H ↑K))","decl":"@[to_additive]\ntheorem sup_eq_closure_mul (H K : Subgroup G) : H ⊔ K = closure ((H : Set G) * (K : Set G)) :=\n  le_antisymm\n    (sup_le (fun h hh => subset_closure ⟨h, hh, 1, K.one_mem, mul_one h⟩) fun k hk =>\n      subset_closure ⟨1, H.one_mem, k, hk, one_mul k⟩)\n    ((closure_mul_le _ _).trans <| by rw [closure_eq, closure_eq])\n\n"}
{"name":"AddSubgroup.sup_eq_closure_add","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\ninst✝ : AddGroup G\nH K : AddSubgroup G\n⊢ Eq (Max.max H K) (AddSubgroup.closure (HAdd.hAdd ↑H ↑K))","decl":"@[to_additive]\ntheorem sup_eq_closure_mul (H K : Subgroup G) : H ⊔ K = closure ((H : Set G) * (K : Set G)) :=\n  le_antisymm\n    (sup_le (fun h hh => subset_closure ⟨h, hh, 1, K.one_mem, mul_one h⟩) fun k hk =>\n      subset_closure ⟨1, H.one_mem, k, hk, one_mul k⟩)\n    ((closure_mul_le _ _).trans <| by rw [closure_eq, closure_eq])\n\n"}
{"name":"AddSubgroup.set_add_normal_comm","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\ninst✝ : AddGroup G\ns : Set G\nN : AddSubgroup G\nhN : N.Normal\n⊢ Eq (HAdd.hAdd s ↑N) (HAdd.hAdd (↑N) s)","decl":"@[to_additive]\ntheorem set_mul_normal_comm (s : Set G) (N : Subgroup G) [hN : N.Normal] :\n    s * (N : Set G) = (N : Set G) * s := by\n  rw [← iUnion_mul_left_image, ← iUnion_mul_right_image]\n  simp only [image_mul_left, image_mul_right, Set.preimage, SetLike.mem_coe, hN.mem_comm_iff]\n\n"}
{"name":"Subgroup.set_mul_normal_comm","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\ninst✝ : Group G\ns : Set G\nN : Subgroup G\nhN : N.Normal\n⊢ Eq (HMul.hMul s ↑N) (HMul.hMul (↑N) s)","decl":"@[to_additive]\ntheorem set_mul_normal_comm (s : Set G) (N : Subgroup G) [hN : N.Normal] :\n    s * (N : Set G) = (N : Set G) * s := by\n  rw [← iUnion_mul_left_image, ← iUnion_mul_right_image]\n  simp only [image_mul_left, image_mul_right, Set.preimage, SetLike.mem_coe, hN.mem_comm_iff]\n\n"}
{"name":"AddSubgroup.add_normal","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\ninst✝ : AddGroup G\nH N : AddSubgroup G\nhN : N.Normal\n⊢ Eq (↑(Max.max H N)) (HAdd.hAdd ↑H ↑N)","decl":"/-- The carrier of `H ⊔ N` is just `↑H * ↑N` (pointwise set product) when `N` is normal. -/\n@[to_additive \"The carrier of `H ⊔ N` is just `↑H + ↑N` (pointwise set addition)\nwhen `N` is normal.\"]\ntheorem mul_normal (H N : Subgroup G) [hN : N.Normal] : (↑(H ⊔ N) : Set G) = H * N := by\n  rw [sup_eq_closure_mul]\n  refine Set.Subset.antisymm (fun x hx => ?_) subset_closure\n  induction hx using closure_induction'' with\n  | one => exact ⟨1, one_mem _, 1, one_mem _, mul_one 1⟩\n  | mem _ hx => exact hx\n  | inv_mem x hx =>\n    obtain ⟨x, hx, y, hy, rfl⟩ := hx\n    simpa only [mul_inv_rev, mul_assoc, inv_inv, inv_mul_cancel_left]\n      using mul_mem_mul (inv_mem hx) (hN.conj_mem _ (inv_mem hy) x)\n  | mul x' x' _ _ hx hx' =>\n    obtain ⟨x, hx, y, hy, rfl⟩ := hx\n    obtain ⟨x', hx', y', hy', rfl⟩ := hx'\n    refine ⟨x * x', mul_mem hx hx', x'⁻¹ * y * x' * y', mul_mem ?_ hy', ?_⟩\n    · simpa using hN.conj_mem _ hy x'⁻¹\n    · simp only [mul_assoc, mul_inv_cancel_left]\n\n"}
{"name":"Subgroup.mul_normal","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\ninst✝ : Group G\nH N : Subgroup G\nhN : N.Normal\n⊢ Eq (↑(Max.max H N)) (HMul.hMul ↑H ↑N)","decl":"/-- The carrier of `H ⊔ N` is just `↑H * ↑N` (pointwise set product) when `N` is normal. -/\n@[to_additive \"The carrier of `H ⊔ N` is just `↑H + ↑N` (pointwise set addition)\nwhen `N` is normal.\"]\ntheorem mul_normal (H N : Subgroup G) [hN : N.Normal] : (↑(H ⊔ N) : Set G) = H * N := by\n  rw [sup_eq_closure_mul]\n  refine Set.Subset.antisymm (fun x hx => ?_) subset_closure\n  induction hx using closure_induction'' with\n  | one => exact ⟨1, one_mem _, 1, one_mem _, mul_one 1⟩\n  | mem _ hx => exact hx\n  | inv_mem x hx =>\n    obtain ⟨x, hx, y, hy, rfl⟩ := hx\n    simpa only [mul_inv_rev, mul_assoc, inv_inv, inv_mul_cancel_left]\n      using mul_mem_mul (inv_mem hx) (hN.conj_mem _ (inv_mem hy) x)\n  | mul x' x' _ _ hx hx' =>\n    obtain ⟨x, hx, y, hy, rfl⟩ := hx\n    obtain ⟨x', hx', y', hy', rfl⟩ := hx'\n    refine ⟨x * x', mul_mem hx hx', x'⁻¹ * y * x' * y', mul_mem ?_ hy', ?_⟩\n    · simpa using hN.conj_mem _ hy x'⁻¹\n    · simp only [mul_assoc, mul_inv_cancel_left]\n\n"}
{"name":"Subgroup.normal_mul","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\ninst✝¹ : Group G\nN H : Subgroup G\ninst✝ : N.Normal\n⊢ Eq (↑(Max.max N H)) (HMul.hMul ↑N ↑H)","decl":"/-- The carrier of `N ⊔ H` is just `↑N * ↑H` (pointwise set product) when `N` is normal. -/\n@[to_additive \"The carrier of `N ⊔ H` is just `↑N + ↑H` (pointwise set addition)\nwhen `N` is normal.\"]\ntheorem normal_mul (N H : Subgroup G) [N.Normal] : (↑(N ⊔ H) : Set G) = N * H := by\n  rw [← set_mul_normal_comm, sup_comm, mul_normal]\n\n"}
{"name":"AddSubgroup.normal_add","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\ninst✝¹ : AddGroup G\nN H : AddSubgroup G\ninst✝ : N.Normal\n⊢ Eq (↑(Max.max N H)) (HAdd.hAdd ↑N ↑H)","decl":"/-- The carrier of `N ⊔ H` is just `↑N * ↑H` (pointwise set product) when `N` is normal. -/\n@[to_additive \"The carrier of `N ⊔ H` is just `↑N + ↑H` (pointwise set addition)\nwhen `N` is normal.\"]\ntheorem normal_mul (N H : Subgroup G) [N.Normal] : (↑(N ⊔ H) : Set G) = N * H := by\n  rw [← set_mul_normal_comm, sup_comm, mul_normal]\n\n"}
{"name":"AddSubgroup.add_inf_assoc","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\ninst✝ : AddGroup G\nA B C : AddSubgroup G\nh : LE.le A C\n⊢ Eq (HAdd.hAdd ↑A ↑(Min.min B C)) (Inter.inter (HAdd.hAdd ↑A ↑B) ↑C)","decl":"@[to_additive]\ntheorem mul_inf_assoc (A B C : Subgroup G) (h : A ≤ C) :\n    (A : Set G) * ↑(B ⊓ C) = (A : Set G) * (B : Set G) ∩ C := by\n  ext\n  simp only [coe_inf, Set.mem_mul, Set.mem_inter_iff]\n  constructor\n  · rintro ⟨y, hy, z, ⟨hzB, hzC⟩, rfl⟩\n    refine ⟨?_, mul_mem (h hy) hzC⟩\n    exact ⟨y, hy, z, hzB, rfl⟩\n  rintro ⟨⟨y, hy, z, hz, rfl⟩, hyz⟩\n  refine ⟨y, hy, z, ⟨hz, ?_⟩, rfl⟩\n  suffices y⁻¹ * (y * z) ∈ C by simpa\n  exact mul_mem (inv_mem (h hy)) hyz\n\n"}
{"name":"Subgroup.mul_inf_assoc","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\ninst✝ : Group G\nA B C : Subgroup G\nh : LE.le A C\n⊢ Eq (HMul.hMul ↑A ↑(Min.min B C)) (Inter.inter (HMul.hMul ↑A ↑B) ↑C)","decl":"@[to_additive]\ntheorem mul_inf_assoc (A B C : Subgroup G) (h : A ≤ C) :\n    (A : Set G) * ↑(B ⊓ C) = (A : Set G) * (B : Set G) ∩ C := by\n  ext\n  simp only [coe_inf, Set.mem_mul, Set.mem_inter_iff]\n  constructor\n  · rintro ⟨y, hy, z, ⟨hzB, hzC⟩, rfl⟩\n    refine ⟨?_, mul_mem (h hy) hzC⟩\n    exact ⟨y, hy, z, hzB, rfl⟩\n  rintro ⟨⟨y, hy, z, hz, rfl⟩, hyz⟩\n  refine ⟨y, hy, z, ⟨hz, ?_⟩, rfl⟩\n  suffices y⁻¹ * (y * z) ∈ C by simpa\n  exact mul_mem (inv_mem (h hy)) hyz\n\n"}
{"name":"AddSubgroup.inf_add_assoc","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\ninst✝ : AddGroup G\nA B C : AddSubgroup G\nh : LE.le C A\n⊢ Eq (HAdd.hAdd ↑(Min.min A B) ↑C) (Inter.inter (↑A) (HAdd.hAdd ↑B ↑C))","decl":"@[to_additive]\ntheorem inf_mul_assoc (A B C : Subgroup G) (h : C ≤ A) :\n    ((A ⊓ B : Subgroup G) : Set G) * C = (A : Set G) ∩ (↑B * ↑C) := by\n  ext\n  simp only [coe_inf, Set.mem_mul, Set.mem_inter_iff]\n  constructor\n  · rintro ⟨y, ⟨hyA, hyB⟩, z, hz, rfl⟩\n    refine ⟨A.mul_mem hyA (h hz), ?_⟩\n    exact ⟨y, hyB, z, hz, rfl⟩\n  rintro ⟨hyz, y, hy, z, hz, rfl⟩\n  refine ⟨y, ⟨?_, hy⟩, z, hz, rfl⟩\n  suffices y * z * z⁻¹ ∈ A by simpa\n  exact mul_mem hyz (inv_mem (h hz))\n\n"}
{"name":"Subgroup.inf_mul_assoc","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\ninst✝ : Group G\nA B C : Subgroup G\nh : LE.le C A\n⊢ Eq (HMul.hMul ↑(Min.min A B) ↑C) (Inter.inter (↑A) (HMul.hMul ↑B ↑C))","decl":"@[to_additive]\ntheorem inf_mul_assoc (A B C : Subgroup G) (h : C ≤ A) :\n    ((A ⊓ B : Subgroup G) : Set G) * C = (A : Set G) ∩ (↑B * ↑C) := by\n  ext\n  simp only [coe_inf, Set.mem_mul, Set.mem_inter_iff]\n  constructor\n  · rintro ⟨y, ⟨hyA, hyB⟩, z, hz, rfl⟩\n    refine ⟨A.mul_mem hyA (h hz), ?_⟩\n    exact ⟨y, hyB, z, hz, rfl⟩\n  rintro ⟨hyz, y, hy, z, hz, rfl⟩\n  refine ⟨y, ⟨?_, hy⟩, z, hz, rfl⟩\n  suffices y * z * z⁻¹ ∈ A by simpa\n  exact mul_mem hyz (inv_mem (h hz))\n\n"}
{"name":"Subgroup.sup_normal","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\ninst✝ : Group G\nH K : Subgroup G\nhH : H.Normal\nhK : K.Normal\n⊢ (Max.max H K).Normal","decl":"@[to_additive]\ninstance sup_normal (H K : Subgroup G) [hH : H.Normal] [hK : K.Normal] : (H ⊔ K).Normal where\n  conj_mem n hmem g := by\n    rw [← SetLike.mem_coe, normal_mul] at hmem ⊢\n    rcases hmem with ⟨h, hh, k, hk, rfl⟩\n    refine ⟨g * h * g⁻¹, hH.conj_mem h hh g, g * k * g⁻¹, hK.conj_mem k hk g, ?_⟩\n    simp only [mul_assoc, inv_mul_cancel_left]\n\n"}
{"name":"AddSubgroup.sup_normal","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\ninst✝ : AddGroup G\nH K : AddSubgroup G\nhH : H.Normal\nhK : K.Normal\n⊢ (Max.max H K).Normal","decl":"@[to_additive]\ninstance sup_normal (H K : Subgroup G) [hH : H.Normal] [hK : K.Normal] : (H ⊔ K).Normal where\n  conj_mem n hmem g := by\n    rw [← SetLike.mem_coe, normal_mul] at hmem ⊢\n    rcases hmem with ⟨h, hh, k, hk, rfl⟩\n    refine ⟨g * h * g⁻¹, hH.conj_mem h hh g, g * k * g⁻¹, hK.conj_mem k hk g, ?_⟩\n    simp only [mul_assoc, inv_mul_cancel_left]\n\n"}
{"name":"AddSubgroup.vadd_mem_of_mem_closure_of_mem","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\ninst✝¹ : AddGroup G\nX : Type u_5\ninst✝ : AddAction G X\ns : Set G\nt : Set X\nhs : ∀ (g : G), Membership.mem s g → Membership.mem s (Neg.neg g)\nhst : ∀ (g : G), Membership.mem s g → ∀ (x : X), Membership.mem t x → Membership.mem t (HVAdd.hVAdd g x)\ng : G\nhg : Membership.mem (AddSubgroup.closure s) g\nx : X\nhx : Membership.mem t x\n⊢ Membership.mem t (HVAdd.hVAdd g x)","decl":"@[to_additive]\ntheorem smul_mem_of_mem_closure_of_mem {X : Type*} [MulAction G X] {s : Set G} {t : Set X}\n    (hs : ∀ g ∈ s, g⁻¹ ∈ s) (hst : ∀ᵉ (g ∈ s) (x ∈ t), g • x ∈ t) {g : G}\n    (hg : g ∈ Subgroup.closure s) {x : X} (hx : x ∈ t) : g • x ∈ t := by\n  induction hg using Subgroup.closure_induction'' generalizing x with\n  | one => simpa\n  | mem g' hg' => exact hst g' hg' x hx\n  | inv_mem g' hg' => exact hst g'⁻¹ (hs g' hg') x hx\n  | mul _ _ _ _ h₁ h₂ => rw [mul_smul]; exact h₁ (h₂ hx)\n\n"}
{"name":"Subgroup.smul_mem_of_mem_closure_of_mem","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\ninst✝¹ : Group G\nX : Type u_5\ninst✝ : MulAction G X\ns : Set G\nt : Set X\nhs : ∀ (g : G), Membership.mem s g → Membership.mem s (Inv.inv g)\nhst : ∀ (g : G), Membership.mem s g → ∀ (x : X), Membership.mem t x → Membership.mem t (HSMul.hSMul g x)\ng : G\nhg : Membership.mem (Subgroup.closure s) g\nx : X\nhx : Membership.mem t x\n⊢ Membership.mem t (HSMul.hSMul g x)","decl":"@[to_additive]\ntheorem smul_mem_of_mem_closure_of_mem {X : Type*} [MulAction G X] {s : Set G} {t : Set X}\n    (hs : ∀ g ∈ s, g⁻¹ ∈ s) (hst : ∀ᵉ (g ∈ s) (x ∈ t), g • x ∈ t) {g : G}\n    (hg : g ∈ Subgroup.closure s) {x : X} (hx : x ∈ t) : g • x ∈ t := by\n  induction hg using Subgroup.closure_induction'' generalizing x with\n  | one => simpa\n  | mem g' hg' => exact hst g' hg' x hx\n  | inv_mem g' hg' => exact hst g'⁻¹ (hs g' hg') x hx\n  | mul _ _ _ _ h₁ h₂ => rw [mul_smul]; exact h₁ (h₂ hx)\n\n"}
{"name":"Subgroup.smul_opposite_image_mul_preimage'","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\ninst✝ : Group G\ng : G\nh : MulOpposite G\ns : Set G\n⊢ Eq (Set.image (fun y => HSMul.hSMul h y) (Set.preimage (fun x => HMul.hMul g x) s)) (Set.preimage (fun x => HMul.hMul g x) (Set.image (fun y => HSMul.hSMul h y) s))","decl":"@[to_additive]\ntheorem smul_opposite_image_mul_preimage' (g : G) (h : Gᵐᵒᵖ) (s : Set G) :\n    (fun y => h • y) '' ((g * ·) ⁻¹' s) = (g * ·) ⁻¹' ((fun y => h • y) '' s) := by\n  simp [preimage_preimage, mul_assoc]\n\n-- Porting note: deprecate?\n"}
{"name":"AddSubgroup.vadd_opposite_image_add_preimage'","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\ninst✝ : AddGroup G\ng : G\nh : AddOpposite G\ns : Set G\n⊢ Eq (Set.image (fun y => HVAdd.hVAdd h y) (Set.preimage (fun x => HAdd.hAdd g x) s)) (Set.preimage (fun x => HAdd.hAdd g x) (Set.image (fun y => HVAdd.hVAdd h y) s))","decl":"@[to_additive]\ntheorem smul_opposite_image_mul_preimage' (g : G) (h : Gᵐᵒᵖ) (s : Set G) :\n    (fun y => h • y) '' ((g * ·) ⁻¹' s) = (g * ·) ⁻¹' ((fun y => h • y) '' s) := by\n  simp [preimage_preimage, mul_assoc]\n\n-- Porting note: deprecate?\n"}
{"name":"AddSubgroup.vadd_opposite_image_add_preimage","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\ninst✝ : AddGroup G\nH : AddSubgroup G\ng : G\nh : Subtype fun x => Membership.mem H.op x\ns : Set G\n⊢ Eq (Set.image (fun y => HVAdd.hVAdd h y) (Set.preimage (fun x => HAdd.hAdd g x) s)) (Set.preimage (fun x => HAdd.hAdd g x) (Set.image (fun y => HVAdd.hVAdd h y) s))","decl":"@[to_additive]\ntheorem smul_opposite_image_mul_preimage {H : Subgroup G} (g : G) (h : H.op) (s : Set G) :\n    (fun y => h • y) '' ((g * ·) ⁻¹' s) = (g * ·) ⁻¹' ((fun y => h • y) '' s) :=\n  smul_opposite_image_mul_preimage' g h s\n\n"}
{"name":"Subgroup.smul_opposite_image_mul_preimage","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\ninst✝ : Group G\nH : Subgroup G\ng : G\nh : Subtype fun x => Membership.mem H.op x\ns : Set G\n⊢ Eq (Set.image (fun y => HSMul.hSMul h y) (Set.preimage (fun x => HMul.hMul g x) s)) (Set.preimage (fun x => HMul.hMul g x) (Set.image (fun y => HSMul.hSMul h y) s))","decl":"@[to_additive]\ntheorem smul_opposite_image_mul_preimage {H : Subgroup G} (g : G) (h : H.op) (s : Set G) :\n    (fun y => h • y) '' ((g * ·) ⁻¹' s) = (g * ·) ⁻¹' ((fun y => h • y) '' s) :=\n  smul_opposite_image_mul_preimage' g h s\n\n"}
{"name":"Subgroup.pointwise_smul_def","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝² : Group G\ninst✝¹ : Monoid α\ninst✝ : MulDistribMulAction α G\na : α\nS : Subgroup G\n⊢ Eq (HSMul.hSMul a S) (Subgroup.map ((MulDistribMulAction.toMonoidEnd α G) a) S)","decl":"theorem pointwise_smul_def {a : α} (S : Subgroup G) :\n    a • S = S.map (MulDistribMulAction.toMonoidEnd _ _ a) :=\n  rfl\n\n"}
{"name":"Subgroup.coe_pointwise_smul","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝² : Group G\ninst✝¹ : Monoid α\ninst✝ : MulDistribMulAction α G\na : α\nS : Subgroup G\n⊢ Eq (↑(HSMul.hSMul a S)) (HSMul.hSMul a ↑S)","decl":"@[simp]\ntheorem coe_pointwise_smul (a : α) (S : Subgroup G) : ↑(a • S) = a • (S : Set G) :=\n  rfl\n\n"}
{"name":"Subgroup.pointwise_smul_toSubmonoid","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝² : Group G\ninst✝¹ : Monoid α\ninst✝ : MulDistribMulAction α G\na : α\nS : Subgroup G\n⊢ Eq (HSMul.hSMul a S).toSubmonoid (HSMul.hSMul a S.toSubmonoid)","decl":"@[simp]\ntheorem pointwise_smul_toSubmonoid (a : α) (S : Subgroup G) :\n    (a • S).toSubmonoid = a • S.toSubmonoid :=\n  rfl\n\n"}
{"name":"Subgroup.smul_mem_pointwise_smul","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝² : Group G\ninst✝¹ : Monoid α\ninst✝ : MulDistribMulAction α G\nm : G\na : α\nS : Subgroup G\na✝ : Membership.mem S m\n⊢ Membership.mem (HSMul.hSMul a S) (HSMul.hSMul a m)","decl":"theorem smul_mem_pointwise_smul (m : G) (a : α) (S : Subgroup G) : m ∈ S → a • m ∈ a • S :=\n  (Set.smul_mem_smul_set : _ → _ ∈ a • (S : Set G))\n\n"}
{"name":"Subgroup.instCovariantClassHSMulLe","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝² : Group G\ninst✝¹ : Monoid α\ninst✝ : MulDistribMulAction α G\n⊢ CovariantClass α (Subgroup G) HSMul.hSMul LE.le","decl":"instance : CovariantClass α (Subgroup G) HSMul.hSMul LE.le :=\n  ⟨fun _ _ => image_subset _⟩\n\n"}
{"name":"Subgroup.mem_smul_pointwise_iff_exists","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝² : Group G\ninst✝¹ : Monoid α\ninst✝ : MulDistribMulAction α G\nm : G\na : α\nS : Subgroup G\n⊢ Iff (Membership.mem (HSMul.hSMul a S) m) (Exists fun s => And (Membership.mem S s) (Eq (HSMul.hSMul a s) m))","decl":"theorem mem_smul_pointwise_iff_exists (m : G) (a : α) (S : Subgroup G) :\n    m ∈ a • S ↔ ∃ s : G, s ∈ S ∧ a • s = m :=\n  (Set.mem_smul_set : m ∈ a • (S : Set G) ↔ _)\n\n"}
{"name":"Subgroup.smul_bot","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝² : Group G\ninst✝¹ : Monoid α\ninst✝ : MulDistribMulAction α G\na : α\n⊢ Eq (HSMul.hSMul a Bot.bot) Bot.bot","decl":"@[simp]\ntheorem smul_bot (a : α) : a • (⊥ : Subgroup G) = ⊥ :=\n  map_bot _\n\n"}
{"name":"Subgroup.smul_sup","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝² : Group G\ninst✝¹ : Monoid α\ninst✝ : MulDistribMulAction α G\na : α\nS T : Subgroup G\n⊢ Eq (HSMul.hSMul a (Max.max S T)) (Max.max (HSMul.hSMul a S) (HSMul.hSMul a T))","decl":"theorem smul_sup (a : α) (S T : Subgroup G) : a • (S ⊔ T) = a • S ⊔ a • T :=\n  map_sup _ _ _\n\n"}
{"name":"Subgroup.smul_closure","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝² : Group G\ninst✝¹ : Monoid α\ninst✝ : MulDistribMulAction α G\na : α\ns : Set G\n⊢ Eq (HSMul.hSMul a (Subgroup.closure s)) (Subgroup.closure (HSMul.hSMul a s))","decl":"theorem smul_closure (a : α) (s : Set G) : a • closure s = closure (a • s) :=\n  MonoidHom.map_closure _ _\n\n"}
{"name":"Subgroup.pointwise_isCentralScalar","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝⁴ : Group G\ninst✝³ : Monoid α\ninst✝² : MulDistribMulAction α G\ninst✝¹ : MulDistribMulAction (MulOpposite α) G\ninst✝ : IsCentralScalar α G\n⊢ IsCentralScalar α (Subgroup G)","decl":"instance pointwise_isCentralScalar [MulDistribMulAction αᵐᵒᵖ G] [IsCentralScalar α G] :\n    IsCentralScalar α (Subgroup G) :=\n  ⟨fun _ S => (congr_arg fun f => S.map f) <| MonoidHom.ext <| op_smul_eq_smul _⟩\n\n"}
{"name":"Subgroup.conj_smul_le_of_le","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\ninst✝ : Group G\nP H : Subgroup G\nhP : LE.le P H\nh : Subtype fun x => Membership.mem H x\n⊢ LE.le (HSMul.hSMul (MulAut.conj ↑h) P) H","decl":"theorem conj_smul_le_of_le {P H : Subgroup G} (hP : P ≤ H) (h : H) :\n    MulAut.conj (h : G) • P ≤ H := by\n  rintro - ⟨g, hg, rfl⟩\n  exact H.mul_mem (H.mul_mem h.2 (hP hg)) (H.inv_mem h.2)\n\n"}
{"name":"Subgroup.conj_smul_subgroupOf","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\ninst✝ : Group G\nP H : Subgroup G\nhP : LE.le P H\nh : Subtype fun x => Membership.mem H x\n⊢ Eq (HSMul.hSMul (MulAut.conj h) (P.subgroupOf H)) ((HSMul.hSMul (MulAut.conj ↑h) P).subgroupOf H)","decl":"theorem conj_smul_subgroupOf {P H : Subgroup G} (hP : P ≤ H) (h : H) :\n    MulAut.conj h • P.subgroupOf H = (MulAut.conj (h : G) • P).subgroupOf H := by\n  refine le_antisymm ?_ ?_\n  · rintro - ⟨g, hg, rfl⟩\n    exact ⟨g, hg, rfl⟩\n  · rintro p ⟨g, hg, hp⟩\n    exact ⟨⟨g, hP hg⟩, hg, Subtype.ext hp⟩\n\n"}
{"name":"Subgroup.smul_mem_pointwise_smul_iff","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝² : Group G\ninst✝¹ : Group α\ninst✝ : MulDistribMulAction α G\na : α\nS : Subgroup G\nx : G\n⊢ Iff (Membership.mem (HSMul.hSMul a S) (HSMul.hSMul a x)) (Membership.mem S x)","decl":"@[simp]\ntheorem smul_mem_pointwise_smul_iff {a : α} {S : Subgroup G} {x : G} : a • x ∈ a • S ↔ x ∈ S :=\n  smul_mem_smul_set_iff\n\n"}
{"name":"Subgroup.mem_pointwise_smul_iff_inv_smul_mem","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝² : Group G\ninst✝¹ : Group α\ninst✝ : MulDistribMulAction α G\na : α\nS : Subgroup G\nx : G\n⊢ Iff (Membership.mem (HSMul.hSMul a S) x) (Membership.mem S (HSMul.hSMul (Inv.inv a) x))","decl":"theorem mem_pointwise_smul_iff_inv_smul_mem {a : α} {S : Subgroup G} {x : G} :\n    x ∈ a • S ↔ a⁻¹ • x ∈ S :=\n  mem_smul_set_iff_inv_smul_mem\n\n"}
{"name":"Subgroup.mem_inv_pointwise_smul_iff","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝² : Group G\ninst✝¹ : Group α\ninst✝ : MulDistribMulAction α G\na : α\nS : Subgroup G\nx : G\n⊢ Iff (Membership.mem (HSMul.hSMul (Inv.inv a) S) x) (Membership.mem S (HSMul.hSMul a x))","decl":"theorem mem_inv_pointwise_smul_iff {a : α} {S : Subgroup G} {x : G} : x ∈ a⁻¹ • S ↔ a • x ∈ S :=\n  mem_inv_smul_set_iff\n\n"}
{"name":"Subgroup.pointwise_smul_le_pointwise_smul_iff","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝² : Group G\ninst✝¹ : Group α\ninst✝ : MulDistribMulAction α G\na : α\nS T : Subgroup G\n⊢ Iff (LE.le (HSMul.hSMul a S) (HSMul.hSMul a T)) (LE.le S T)","decl":"@[simp]\ntheorem pointwise_smul_le_pointwise_smul_iff {a : α} {S T : Subgroup G} : a • S ≤ a • T ↔ S ≤ T :=\n  smul_set_subset_smul_set_iff\n\n"}
{"name":"Subgroup.pointwise_smul_subset_iff","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝² : Group G\ninst✝¹ : Group α\ninst✝ : MulDistribMulAction α G\na : α\nS T : Subgroup G\n⊢ Iff (LE.le (HSMul.hSMul a S) T) (LE.le S (HSMul.hSMul (Inv.inv a) T))","decl":"theorem pointwise_smul_subset_iff {a : α} {S T : Subgroup G} : a • S ≤ T ↔ S ≤ a⁻¹ • T :=\n  smul_set_subset_iff_subset_inv_smul_set\n\n"}
{"name":"Subgroup.subset_pointwise_smul_iff","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝² : Group G\ninst✝¹ : Group α\ninst✝ : MulDistribMulAction α G\na : α\nS T : Subgroup G\n⊢ Iff (LE.le S (HSMul.hSMul a T)) (LE.le (HSMul.hSMul (Inv.inv a) S) T)","decl":"theorem subset_pointwise_smul_iff {a : α} {S T : Subgroup G} : S ≤ a • T ↔ a⁻¹ • S ≤ T :=\n  subset_smul_set_iff\n\n"}
{"name":"Subgroup.smul_inf","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝² : Group G\ninst✝¹ : Group α\ninst✝ : MulDistribMulAction α G\na : α\nS T : Subgroup G\n⊢ Eq (HSMul.hSMul a (Min.min S T)) (Min.min (HSMul.hSMul a S) (HSMul.hSMul a T))","decl":"@[simp]\ntheorem smul_inf (a : α) (S T : Subgroup G) : a • (S ⊓ T) = a • S ⊓ a • T := by\n  simp [SetLike.ext_iff, mem_pointwise_smul_iff_inv_smul_mem]\n\n"}
{"name":"Subgroup.equivSMul_symm_apply_coe","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝² : Group G\ninst✝¹ : Group α\ninst✝ : MulDistribMulAction α G\na : α\nH : Subgroup G\ny : ↑(Set.image ⇑↑(MulDistribMulAction.toMulEquiv G a) ↑H.toSubmonoid)\n⊢ Eq (↑((Subgroup.equivSMul a H).symm y)) (HSMul.hSMul (Inv.inv a) ↑y)","decl":"/-- Applying a `MulDistribMulAction` results in an isomorphic subgroup -/\n@[simps!]\ndef equivSMul (a : α) (H : Subgroup G) : H ≃* (a • H : Subgroup G) :=\n  (MulDistribMulAction.toMulEquiv G a).subgroupMap H\n\n"}
{"name":"Subgroup.equivSMul_apply_coe","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝² : Group G\ninst✝¹ : Group α\ninst✝ : MulDistribMulAction α G\na : α\nH : Subgroup G\nx : ↑↑H.toSubmonoid\n⊢ Eq (↑((Subgroup.equivSMul a H) x)) (HSMul.hSMul a ↑x)","decl":"/-- Applying a `MulDistribMulAction` results in an isomorphic subgroup -/\n@[simps!]\ndef equivSMul (a : α) (H : Subgroup G) : H ≃* (a • H : Subgroup G) :=\n  (MulDistribMulAction.toMulEquiv G a).subgroupMap H\n\n"}
{"name":"Subgroup.subgroup_mul_singleton","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\ninst✝ : Group G\nH : Subgroup G\nh : G\nhh : Membership.mem H h\n⊢ Eq (HMul.hMul (↑H) (Singleton.singleton h)) ↑H","decl":"theorem subgroup_mul_singleton {H : Subgroup G} {h : G} (hh : h ∈ H) : (H : Set G) * {h} = H := by\n  simp [preimage, mul_mem_cancel_right (inv_mem hh)]\n\n"}
{"name":"Subgroup.singleton_mul_subgroup","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\ninst✝ : Group G\nH : Subgroup G\nh : G\nhh : Membership.mem H h\n⊢ Eq (HMul.hMul (Singleton.singleton h) ↑H) ↑H","decl":"theorem singleton_mul_subgroup {H : Subgroup G} {h : G} (hh : h ∈ H) : {h} * (H : Set G) = H := by\n  simp [preimage, mul_mem_cancel_left (inv_mem hh)]\n\n"}
{"name":"Subgroup.Normal.conjAct","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\ninst✝ : Group G\nH : Subgroup G\nhH : H.Normal\ng : ConjAct G\n⊢ Eq (HSMul.hSMul g H) H","decl":"theorem Normal.conjAct {H : Subgroup G} (hH : H.Normal) (g : ConjAct G) : g • H = H :=\n  have : ∀ g : ConjAct G, g • H ≤ H :=\n    fun _ => map_le_iff_le_comap.2 fun _ h => hH.conj_mem _ h _\n  (this g).antisymm <| (smul_inv_smul g H).symm.trans_le (map_mono <| this _)\n\n"}
{"name":"Subgroup.smul_normal","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\ninst✝ : Group G\ng : G\nH : Subgroup G\nh : H.Normal\n⊢ Eq (HSMul.hSMul (MulAut.conj g) H) H","decl":"@[simp]\ntheorem smul_normal (g : G) (H : Subgroup G) [h : Normal H] : MulAut.conj g • H = H :=\n  h.conjAct g\n\n"}
{"name":"Subgroup.Normal.of_conjugate_fixed","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\ninst✝ : Group G\nH : Subgroup G\nh : ∀ (g : G), Eq (HSMul.hSMul (MulAut.conj g) H) H\n⊢ H.Normal","decl":"theorem Normal.of_conjugate_fixed {H : Subgroup G} (h : ∀ g : G, (MulAut.conj g) • H = H) :\n    H.Normal := by\n  constructor\n  intro n hn g\n  rw [← h g, Subgroup.mem_pointwise_smul_iff_inv_smul_mem, ← map_inv, MulAut.smul_def,\n    MulAut.conj_apply, inv_inv, mul_assoc, mul_assoc, inv_mul_cancel, mul_one,\n    ← mul_assoc, inv_mul_cancel, one_mul]\n  exact hn\n\n"}
{"name":"Subgroup.normalCore_eq_iInf_conjAct","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"G : Type u_2\ninst✝ : Group G\nH : Subgroup G\n⊢ Eq H.normalCore (iInf fun g => HSMul.hSMul g H)","decl":"theorem normalCore_eq_iInf_conjAct (H : Subgroup G) :\n    H.normalCore = ⨅ (g : ConjAct G), g • H := by\n  ext g\n  simp only [Subgroup.normalCore, Subgroup.mem_iInf, Subgroup.mem_pointwise_smul_iff_inv_smul_mem]\n  refine ⟨fun h x ↦ h x⁻¹, fun h x ↦ ?_⟩\n  simpa only [ConjAct.toConjAct_inv, inv_inv] using h x⁻¹\n\n"}
{"name":"Subgroup.smul_mem_pointwise_smul_iff₀","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝² : Group G\ninst✝¹ : GroupWithZero α\ninst✝ : MulDistribMulAction α G\na : α\nha : Ne a 0\nS : Subgroup G\nx : G\n⊢ Iff (Membership.mem (HSMul.hSMul a S) (HSMul.hSMul a x)) (Membership.mem S x)","decl":"@[simp]\ntheorem smul_mem_pointwise_smul_iff₀ {a : α} (ha : a ≠ 0) (S : Subgroup G) (x : G) :\n    a • x ∈ a • S ↔ x ∈ S :=\n  smul_mem_smul_set_iff₀ ha (S : Set G) x\n\n"}
{"name":"Subgroup.mem_pointwise_smul_iff_inv_smul_mem₀","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝² : Group G\ninst✝¹ : GroupWithZero α\ninst✝ : MulDistribMulAction α G\na : α\nha : Ne a 0\nS : Subgroup G\nx : G\n⊢ Iff (Membership.mem (HSMul.hSMul a S) x) (Membership.mem S (HSMul.hSMul (Inv.inv a) x))","decl":"theorem mem_pointwise_smul_iff_inv_smul_mem₀ {a : α} (ha : a ≠ 0) (S : Subgroup G) (x : G) :\n    x ∈ a • S ↔ a⁻¹ • x ∈ S :=\n  mem_smul_set_iff_inv_smul_mem₀ ha (S : Set G) x\n\n"}
{"name":"Subgroup.mem_inv_pointwise_smul_iff₀","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝² : Group G\ninst✝¹ : GroupWithZero α\ninst✝ : MulDistribMulAction α G\na : α\nha : Ne a 0\nS : Subgroup G\nx : G\n⊢ Iff (Membership.mem (HSMul.hSMul (Inv.inv a) S) x) (Membership.mem S (HSMul.hSMul a x))","decl":"theorem mem_inv_pointwise_smul_iff₀ {a : α} (ha : a ≠ 0) (S : Subgroup G) (x : G) :\n    x ∈ a⁻¹ • S ↔ a • x ∈ S :=\n  mem_inv_smul_set_iff₀ ha (S : Set G) x\n\n"}
{"name":"Subgroup.pointwise_smul_le_pointwise_smul_iff₀","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝² : Group G\ninst✝¹ : GroupWithZero α\ninst✝ : MulDistribMulAction α G\na : α\nha : Ne a 0\nS T : Subgroup G\n⊢ Iff (LE.le (HSMul.hSMul a S) (HSMul.hSMul a T)) (LE.le S T)","decl":"@[simp]\ntheorem pointwise_smul_le_pointwise_smul_iff₀ {a : α} (ha : a ≠ 0) {S T : Subgroup G} :\n    a • S ≤ a • T ↔ S ≤ T :=\n  smul_set_subset_smul_set_iff₀ ha\n\n"}
{"name":"Subgroup.pointwise_smul_le_iff₀","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝² : Group G\ninst✝¹ : GroupWithZero α\ninst✝ : MulDistribMulAction α G\na : α\nha : Ne a 0\nS T : Subgroup G\n⊢ Iff (LE.le (HSMul.hSMul a S) T) (LE.le S (HSMul.hSMul (Inv.inv a) T))","decl":"theorem pointwise_smul_le_iff₀ {a : α} (ha : a ≠ 0) {S T : Subgroup G} : a • S ≤ T ↔ S ≤ a⁻¹ • T :=\n  smul_set_subset_iff₀ ha\n\n"}
{"name":"Subgroup.le_pointwise_smul_iff₀","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝² : Group G\ninst✝¹ : GroupWithZero α\ninst✝ : MulDistribMulAction α G\na : α\nha : Ne a 0\nS T : Subgroup G\n⊢ Iff (LE.le S (HSMul.hSMul a T)) (LE.le (HSMul.hSMul (Inv.inv a) S) T)","decl":"theorem le_pointwise_smul_iff₀ {a : α} (ha : a ≠ 0) {S T : Subgroup G} : S ≤ a • T ↔ a⁻¹ • S ≤ T :=\n  subset_smul_set_iff₀ ha\n\n"}
{"name":"AddSubgroup.pointwise_smul_def","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"α : Type u_1\nA : Type u_3\ninst✝² : AddGroup A\ninst✝¹ : Monoid α\ninst✝ : DistribMulAction α A\na : α\nS : AddSubgroup A\n⊢ Eq (HSMul.hSMul a S) (AddSubgroup.map ((DistribMulAction.toAddMonoidEnd α A) a) S)","decl":"theorem pointwise_smul_def {a : α} (S : AddSubgroup A) :\n    a • S = S.map (DistribMulAction.toAddMonoidEnd _ _ a) :=\n  rfl\n\n"}
{"name":"AddSubgroup.coe_pointwise_smul","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"α : Type u_1\nA : Type u_3\ninst✝² : AddGroup A\ninst✝¹ : Monoid α\ninst✝ : DistribMulAction α A\na : α\nS : AddSubgroup A\n⊢ Eq (↑(HSMul.hSMul a S)) (HSMul.hSMul a ↑S)","decl":"@[simp]\ntheorem coe_pointwise_smul (a : α) (S : AddSubgroup A) : ↑(a • S) = a • (S : Set A) :=\n  rfl\n\n"}
{"name":"AddSubgroup.pointwise_smul_toAddSubmonoid","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"α : Type u_1\nA : Type u_3\ninst✝² : AddGroup A\ninst✝¹ : Monoid α\ninst✝ : DistribMulAction α A\na : α\nS : AddSubgroup A\n⊢ Eq (HSMul.hSMul a S).toAddSubmonoid (HSMul.hSMul a S.toAddSubmonoid)","decl":"@[simp]\ntheorem pointwise_smul_toAddSubmonoid (a : α) (S : AddSubgroup A) :\n    (a • S).toAddSubmonoid = a • S.toAddSubmonoid :=\n  rfl\n\n"}
{"name":"AddSubgroup.smul_mem_pointwise_smul","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"α : Type u_1\nA : Type u_3\ninst✝² : AddGroup A\ninst✝¹ : Monoid α\ninst✝ : DistribMulAction α A\nm : A\na : α\nS : AddSubgroup A\na✝ : Membership.mem S m\n⊢ Membership.mem (HSMul.hSMul a S) (HSMul.hSMul a m)","decl":"theorem smul_mem_pointwise_smul (m : A) (a : α) (S : AddSubgroup A) : m ∈ S → a • m ∈ a • S :=\n  (Set.smul_mem_smul_set : _ → _ ∈ a • (S : Set A))\n\n"}
{"name":"AddSubgroup.mem_smul_pointwise_iff_exists","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"α : Type u_1\nA : Type u_3\ninst✝² : AddGroup A\ninst✝¹ : Monoid α\ninst✝ : DistribMulAction α A\nm : A\na : α\nS : AddSubgroup A\n⊢ Iff (Membership.mem (HSMul.hSMul a S) m) (Exists fun s => And (Membership.mem S s) (Eq (HSMul.hSMul a s) m))","decl":"theorem mem_smul_pointwise_iff_exists (m : A) (a : α) (S : AddSubgroup A) :\n    m ∈ a • S ↔ ∃ s : A, s ∈ S ∧ a • s = m :=\n  (Set.mem_smul_set : m ∈ a • (S : Set A) ↔ _)\n\n"}
{"name":"AddSubgroup.pointwise_isCentralScalar","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"α : Type u_1\nA : Type u_3\ninst✝⁴ : AddGroup A\ninst✝³ : Monoid α\ninst✝² : DistribMulAction α A\ninst✝¹ : DistribMulAction (MulOpposite α) A\ninst✝ : IsCentralScalar α A\n⊢ IsCentralScalar α (AddSubgroup A)","decl":"instance pointwise_isCentralScalar [DistribMulAction αᵐᵒᵖ A] [IsCentralScalar α A] :\n    IsCentralScalar α (AddSubgroup A) :=\n  ⟨fun _ S => (congr_arg fun f => S.map f) <| AddMonoidHom.ext <| op_smul_eq_smul _⟩\n\n"}
{"name":"AddSubgroup.smul_mem_pointwise_smul_iff","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"α : Type u_1\nA : Type u_3\ninst✝² : AddGroup A\ninst✝¹ : Group α\ninst✝ : DistribMulAction α A\na : α\nS : AddSubgroup A\nx : A\n⊢ Iff (Membership.mem (HSMul.hSMul a S) (HSMul.hSMul a x)) (Membership.mem S x)","decl":"@[simp]\ntheorem smul_mem_pointwise_smul_iff {a : α} {S : AddSubgroup A} {x : A} : a • x ∈ a • S ↔ x ∈ S :=\n  smul_mem_smul_set_iff\n\n"}
{"name":"AddSubgroup.mem_pointwise_smul_iff_inv_smul_mem","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"α : Type u_1\nA : Type u_3\ninst✝² : AddGroup A\ninst✝¹ : Group α\ninst✝ : DistribMulAction α A\na : α\nS : AddSubgroup A\nx : A\n⊢ Iff (Membership.mem (HSMul.hSMul a S) x) (Membership.mem S (HSMul.hSMul (Inv.inv a) x))","decl":"theorem mem_pointwise_smul_iff_inv_smul_mem {a : α} {S : AddSubgroup A} {x : A} :\n    x ∈ a • S ↔ a⁻¹ • x ∈ S :=\n  mem_smul_set_iff_inv_smul_mem\n\n"}
{"name":"AddSubgroup.mem_inv_pointwise_smul_iff","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"α : Type u_1\nA : Type u_3\ninst✝² : AddGroup A\ninst✝¹ : Group α\ninst✝ : DistribMulAction α A\na : α\nS : AddSubgroup A\nx : A\n⊢ Iff (Membership.mem (HSMul.hSMul (Inv.inv a) S) x) (Membership.mem S (HSMul.hSMul a x))","decl":"theorem mem_inv_pointwise_smul_iff {a : α} {S : AddSubgroup A} {x : A} : x ∈ a⁻¹ • S ↔ a • x ∈ S :=\n  mem_inv_smul_set_iff\n\n"}
{"name":"AddSubgroup.pointwise_smul_le_pointwise_smul_iff","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"α : Type u_1\nA : Type u_3\ninst✝² : AddGroup A\ninst✝¹ : Group α\ninst✝ : DistribMulAction α A\na : α\nS T : AddSubgroup A\n⊢ Iff (LE.le (HSMul.hSMul a S) (HSMul.hSMul a T)) (LE.le S T)","decl":"@[simp]\ntheorem pointwise_smul_le_pointwise_smul_iff {a : α} {S T : AddSubgroup A} :\n    a • S ≤ a • T ↔ S ≤ T :=\n  smul_set_subset_smul_set_iff\n\n"}
{"name":"AddSubgroup.pointwise_smul_le_iff","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"α : Type u_1\nA : Type u_3\ninst✝² : AddGroup A\ninst✝¹ : Group α\ninst✝ : DistribMulAction α A\na : α\nS T : AddSubgroup A\n⊢ Iff (LE.le (HSMul.hSMul a S) T) (LE.le S (HSMul.hSMul (Inv.inv a) T))","decl":"theorem pointwise_smul_le_iff {a : α} {S T : AddSubgroup A} : a • S ≤ T ↔ S ≤ a⁻¹ • T :=\n  smul_set_subset_iff_subset_inv_smul_set\n\n"}
{"name":"AddSubgroup.le_pointwise_smul_iff","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"α : Type u_1\nA : Type u_3\ninst✝² : AddGroup A\ninst✝¹ : Group α\ninst✝ : DistribMulAction α A\na : α\nS T : AddSubgroup A\n⊢ Iff (LE.le S (HSMul.hSMul a T)) (LE.le (HSMul.hSMul (Inv.inv a) S) T)","decl":"theorem le_pointwise_smul_iff {a : α} {S T : AddSubgroup A} : S ≤ a • T ↔ a⁻¹ • S ≤ T :=\n  subset_smul_set_iff\n\n"}
{"name":"AddSubgroup.smul_mem_pointwise_smul_iff₀","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"α : Type u_1\nA : Type u_3\ninst✝² : AddGroup A\ninst✝¹ : GroupWithZero α\ninst✝ : DistribMulAction α A\na : α\nha : Ne a 0\nS : AddSubgroup A\nx : A\n⊢ Iff (Membership.mem (HSMul.hSMul a S) (HSMul.hSMul a x)) (Membership.mem S x)","decl":"@[simp]\ntheorem smul_mem_pointwise_smul_iff₀ {a : α} (ha : a ≠ 0) (S : AddSubgroup A) (x : A) :\n    a • x ∈ a • S ↔ x ∈ S :=\n  smul_mem_smul_set_iff₀ ha (S : Set A) x\n\n"}
{"name":"AddSubgroup.mem_pointwise_smul_iff_inv_smul_mem₀","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"α : Type u_1\nA : Type u_3\ninst✝² : AddGroup A\ninst✝¹ : GroupWithZero α\ninst✝ : DistribMulAction α A\na : α\nha : Ne a 0\nS : AddSubgroup A\nx : A\n⊢ Iff (Membership.mem (HSMul.hSMul a S) x) (Membership.mem S (HSMul.hSMul (Inv.inv a) x))","decl":"theorem mem_pointwise_smul_iff_inv_smul_mem₀ {a : α} (ha : a ≠ 0) (S : AddSubgroup A) (x : A) :\n    x ∈ a • S ↔ a⁻¹ • x ∈ S :=\n  mem_smul_set_iff_inv_smul_mem₀ ha (S : Set A) x\n\n"}
{"name":"AddSubgroup.mem_inv_pointwise_smul_iff₀","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"α : Type u_1\nA : Type u_3\ninst✝² : AddGroup A\ninst✝¹ : GroupWithZero α\ninst✝ : DistribMulAction α A\na : α\nha : Ne a 0\nS : AddSubgroup A\nx : A\n⊢ Iff (Membership.mem (HSMul.hSMul (Inv.inv a) S) x) (Membership.mem S (HSMul.hSMul a x))","decl":"theorem mem_inv_pointwise_smul_iff₀ {a : α} (ha : a ≠ 0) (S : AddSubgroup A) (x : A) :\n    x ∈ a⁻¹ • S ↔ a • x ∈ S :=\n  mem_inv_smul_set_iff₀ ha (S : Set A) x\n\n"}
{"name":"AddSubgroup.pointwise_smul_le_pointwise_smul_iff₀","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"α : Type u_1\nA : Type u_3\ninst✝² : AddGroup A\ninst✝¹ : GroupWithZero α\ninst✝ : DistribMulAction α A\na : α\nha : Ne a 0\nS T : AddSubgroup A\n⊢ Iff (LE.le (HSMul.hSMul a S) (HSMul.hSMul a T)) (LE.le S T)","decl":"@[simp]\ntheorem pointwise_smul_le_pointwise_smul_iff₀ {a : α} (ha : a ≠ 0) {S T : AddSubgroup A} :\n    a • S ≤ a • T ↔ S ≤ T :=\n  smul_set_subset_smul_set_iff₀ ha\n\n"}
{"name":"AddSubgroup.pointwise_smul_le_iff₀","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"α : Type u_1\nA : Type u_3\ninst✝² : AddGroup A\ninst✝¹ : GroupWithZero α\ninst✝ : DistribMulAction α A\na : α\nha : Ne a 0\nS T : AddSubgroup A\n⊢ Iff (LE.le (HSMul.hSMul a S) T) (LE.le S (HSMul.hSMul (Inv.inv a) T))","decl":"theorem pointwise_smul_le_iff₀ {a : α} (ha : a ≠ 0) {S T : AddSubgroup A} :\n    a • S ≤ T ↔ S ≤ a⁻¹ • T :=\n  smul_set_subset_iff₀ ha\n\n"}
{"name":"AddSubgroup.le_pointwise_smul_iff₀","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"α : Type u_1\nA : Type u_3\ninst✝² : AddGroup A\ninst✝¹ : GroupWithZero α\ninst✝ : DistribMulAction α A\na : α\nha : Ne a 0\nS T : AddSubgroup A\n⊢ Iff (LE.le S (HSMul.hSMul a T)) (LE.le (HSMul.hSMul (Inv.inv a) S) T)","decl":"theorem le_pointwise_smul_iff₀ {a : α} (ha : a ≠ 0) {S T : AddSubgroup A} :\n    S ≤ a • T ↔ a⁻¹ • S ≤ T :=\n  subset_smul_set_iff₀ ha\n\n"}
{"name":"AddSubgroup.zero_smul","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"R : Type u_5\nM : Type u_6\ninst✝² : Semiring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\ns : AddSubgroup M\n⊢ Eq (HSMul.hSMul 0 s) Bot.bot","decl":"@[simp] protected lemma zero_smul (s : AddSubgroup M) : (0 : R) • s = ⊥ := by\n  simp [eq_bot_iff_forall, pointwise_smul_def]\n\n"}
{"name":"AddSubgroup.mul_toAddSubmonoid","module":"Mathlib.Algebra.Group.Subgroup.Pointwise","initialProofState":"R : Type u_5\ninst✝ : NonUnitalNonAssocRing R\nM N : AddSubgroup R\n⊢ Eq (HMul.hMul M N).toAddSubmonoid (HMul.hMul M.toAddSubmonoid N.toAddSubmonoid)","decl":"theorem mul_toAddSubmonoid (M N : AddSubgroup R) :\n    (M * N).toAddSubmonoid = M.toAddSubmonoid * N.toAddSubmonoid := rfl\n\n"}
