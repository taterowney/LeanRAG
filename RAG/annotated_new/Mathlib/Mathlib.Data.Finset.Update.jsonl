{"name":"Function.updateFinset_def","module":"Mathlib.Data.Finset.Update","initialProofState":"ι : Type u_1\nπ : ι → Sort u_2\nx : (i : ι) → π i\ninst✝ : DecidableEq ι\ns : Finset ι\ny : (i : Subtype fun x => Membership.mem s x) → π ↑i\n⊢ Eq (Function.updateFinset x s y) fun i => dite (Membership.mem s i) (fun hi => y ⟨i, hi⟩) fun hi => x i","decl":"theorem updateFinset_def {s : Finset ι} {y} :\n    updateFinset x s y = fun i ↦ if hi : i ∈ s then y ⟨i, hi⟩ else x i :=\n  rfl\n\n"}
{"name":"Function.updateFinset_empty","module":"Mathlib.Data.Finset.Update","initialProofState":"ι : Type u_1\nπ : ι → Sort u_2\nx : (i : ι) → π i\ninst✝ : DecidableEq ι\ny : (i : Subtype fun x => Membership.mem EmptyCollection.emptyCollection x) → π ↑i\n⊢ Eq (Function.updateFinset x EmptyCollection.emptyCollection y) x","decl":"@[simp] theorem updateFinset_empty {y} : updateFinset x ∅ y = x :=\n  rfl\n\n"}
{"name":"Function.updateFinset_singleton","module":"Mathlib.Data.Finset.Update","initialProofState":"ι : Type u_1\nπ : ι → Sort u_2\nx : (i : ι) → π i\ninst✝ : DecidableEq ι\ni : ι\ny : (i_1 : Subtype fun x => Membership.mem (Singleton.singleton i) x) → π ↑i_1\n⊢ Eq (Function.updateFinset x (Singleton.singleton i) y) (Function.update x i (y ⟨i, ⋯⟩))","decl":"theorem updateFinset_singleton {i y} :\n    updateFinset x {i} y = Function.update x i (y ⟨i, mem_singleton_self i⟩) := by\n  congr with j\n  by_cases hj : j = i\n  · cases hj\n    simp only [dif_pos, Finset.mem_singleton, update_self, updateFinset]\n  · simp [hj, updateFinset]\n\n"}
{"name":"Function.update_eq_updateFinset","module":"Mathlib.Data.Finset.Update","initialProofState":"ι : Type u_1\nπ : ι → Sort u_2\nx : (i : ι) → π i\ninst✝ : DecidableEq ι\ni : ι\ny : π i\n⊢ Eq (Function.update x i y) (Function.updateFinset x (Singleton.singleton i) (uniqueElim y))","decl":"theorem update_eq_updateFinset {i y} :\n    Function.update x i y = updateFinset x {i} (uniqueElim y) := by\n  congr with j\n  by_cases hj : j = i\n  · cases hj\n    simp only [dif_pos, Finset.mem_singleton, update_self, updateFinset]\n    exact uniqueElim_default (α := fun j : ({i} : Finset ι) => π j) y\n  · simp [hj, updateFinset]\n\n"}
{"name":"Function.updateFinset_updateFinset","module":"Mathlib.Data.Finset.Update","initialProofState":"ι : Type u_1\nπ : ι → Type u_2\nx : (i : ι) → π i\ninst✝ : DecidableEq ι\ns t : Finset ι\nhst : Disjoint s t\ny : (i : Subtype fun x => Membership.mem s x) → π ↑i\nz : (i : Subtype fun x => Membership.mem t x) → π ↑i\n⊢ Eq (Function.updateFinset (Function.updateFinset x s y) t z) (Function.updateFinset x (Union.union s t) ((Equiv.piFinsetUnion π hst) { fst := y, snd := z }))","decl":"theorem updateFinset_updateFinset {s t : Finset ι} (hst : Disjoint s t)\n    {y : ∀ i : ↥s, π i} {z : ∀ i : ↥t, π i} :\n    updateFinset (updateFinset x s y) t z =\n    updateFinset x (s ∪ t) (Equiv.piFinsetUnion π hst ⟨y, z⟩) := by\n  set e := Equiv.Finset.union s t hst\n  congr with i\n  by_cases his : i ∈ s <;> by_cases hit : i ∈ t <;>\n    simp only [updateFinset, his, hit, dif_pos, dif_neg, Finset.mem_union, false_or, not_false_iff]\n  · exfalso; exact Finset.disjoint_left.mp hst his hit\n  · exact piCongrLeft_sum_inl (fun b : ↥(s ∪ t) => π b) e y z ⟨i, his⟩ |>.symm\n  · exact piCongrLeft_sum_inr (fun b : ↥(s ∪ t) => π b) e y z ⟨i, hit⟩ |>.symm\n\n"}
