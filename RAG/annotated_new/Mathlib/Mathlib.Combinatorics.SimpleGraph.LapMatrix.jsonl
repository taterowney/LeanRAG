{"name":"SimpleGraph.degree_eq_sum_if_adj","module":"Mathlib.Combinatorics.SimpleGraph.LapMatrix","initialProofState":"V : Type u_1\ninst✝² : Fintype V\nG : SimpleGraph V\ninst✝¹ : DecidableRel G.Adj\nR : Type u_3\ninst✝ : AddCommMonoidWithOne R\ni : V\n⊢ Eq (↑(G.degree i)) (Finset.univ.sum fun j => ite (G.Adj i j) 1 0)","decl":"theorem degree_eq_sum_if_adj {R : Type*} [AddCommMonoidWithOne R] (i : V) :\n    (G.degree i : R) = ∑ j : V, if G.Adj i j then 1 else 0 := by\n  unfold degree neighborFinset neighborSet\n  rw [sum_boole, Set.toFinset_setOf]\n\n"}
{"name":"SimpleGraph.isSymm_degMatrix","module":"Mathlib.Combinatorics.SimpleGraph.LapMatrix","initialProofState":"V : Type u_1\nR : Type u_2\ninst✝³ : Fintype V\nG : SimpleGraph V\ninst✝² : DecidableRel G.Adj\ninst✝¹ : DecidableEq V\ninst✝ : AddMonoidWithOne R\n⊢ (SimpleGraph.degMatrix R G).IsSymm","decl":"theorem isSymm_degMatrix [AddMonoidWithOne R] : (G.degMatrix R).IsSymm :=\n  isSymm_diagonal _\n\n"}
{"name":"SimpleGraph.isSymm_lapMatrix","module":"Mathlib.Combinatorics.SimpleGraph.LapMatrix","initialProofState":"V : Type u_1\nR : Type u_2\ninst✝³ : Fintype V\nG : SimpleGraph V\ninst✝² : DecidableRel G.Adj\ninst✝¹ : DecidableEq V\ninst✝ : AddGroupWithOne R\n⊢ (SimpleGraph.lapMatrix R G).IsSymm","decl":"theorem isSymm_lapMatrix [AddGroupWithOne R] : (G.lapMatrix R).IsSymm :=\n  (isSymm_degMatrix _).sub (isSymm_adjMatrix _)\n\n"}
{"name":"SimpleGraph.degMatrix_mulVec_apply","module":"Mathlib.Combinatorics.SimpleGraph.LapMatrix","initialProofState":"V : Type u_1\nR : Type u_2\ninst✝³ : Fintype V\nG : SimpleGraph V\ninst✝² : DecidableRel G.Adj\ninst✝¹ : DecidableEq V\ninst✝ : NonAssocSemiring R\nv : V\nvec : V → R\n⊢ Eq ((SimpleGraph.degMatrix R G).mulVec vec v) (HMul.hMul (↑(G.degree v)) (vec v))","decl":"theorem degMatrix_mulVec_apply [NonAssocSemiring R] (v : V) (vec : V → R) :\n    (G.degMatrix R *ᵥ vec) v = G.degree v * vec v := by\n  rw [degMatrix, mulVec_diagonal]\n\n"}
{"name":"SimpleGraph.lapMatrix_mulVec_apply","module":"Mathlib.Combinatorics.SimpleGraph.LapMatrix","initialProofState":"V : Type u_1\nR : Type u_2\ninst✝³ : Fintype V\nG : SimpleGraph V\ninst✝² : DecidableRel G.Adj\ninst✝¹ : DecidableEq V\ninst✝ : NonAssocRing R\nv : V\nvec : V → R\n⊢ Eq ((SimpleGraph.lapMatrix R G).mulVec vec v) (HSub.hSub (HMul.hMul (↑(G.degree v)) (vec v)) ((G.neighborFinset v).sum fun u => vec u))","decl":"theorem lapMatrix_mulVec_apply [NonAssocRing R] (v : V) (vec : V → R) :\n    (G.lapMatrix R *ᵥ vec) v = G.degree v * vec v - ∑ u ∈ G.neighborFinset v, vec u := by\n  simp_rw [lapMatrix, sub_mulVec, Pi.sub_apply, degMatrix_mulVec_apply, adjMatrix_mulVec_apply]\n\n"}
{"name":"SimpleGraph.lapMatrix_mulVec_const_eq_zero","module":"Mathlib.Combinatorics.SimpleGraph.LapMatrix","initialProofState":"V : Type u_1\nR : Type u_2\ninst✝³ : Fintype V\nG : SimpleGraph V\ninst✝² : DecidableRel G.Adj\ninst✝¹ : DecidableEq V\ninst✝ : Ring R\n⊢ Eq ((SimpleGraph.lapMatrix R G).mulVec fun x => 1) 0","decl":"theorem lapMatrix_mulVec_const_eq_zero [Ring R] : mulVec (G.lapMatrix R) (fun _ ↦ 1) = 0 := by\n  ext1 i\n  rw [lapMatrix_mulVec_apply]\n  simp\n\n"}
{"name":"SimpleGraph.dotProduct_mulVec_degMatrix","module":"Mathlib.Combinatorics.SimpleGraph.LapMatrix","initialProofState":"V : Type u_1\nR : Type u_2\ninst✝³ : Fintype V\nG : SimpleGraph V\ninst✝² : DecidableRel G.Adj\ninst✝¹ : DecidableEq V\ninst✝ : CommRing R\nx : V → R\n⊢ Eq (dotProduct x ((SimpleGraph.degMatrix R G).mulVec x)) (Finset.univ.sum fun i => HMul.hMul (HMul.hMul (↑(G.degree i)) (x i)) (x i))","decl":"theorem dotProduct_mulVec_degMatrix [CommRing R] (x : V → R) :\n    x ⬝ᵥ (G.degMatrix R *ᵥ x) = ∑ i : V, G.degree i * x i * x i := by\n  simp only [dotProduct, degMatrix, mulVec_diagonal, ← mul_assoc, mul_comm]\n\n"}
{"name":"SimpleGraph.lapMatrix_toLinearMap₂'","module":"Mathlib.Combinatorics.SimpleGraph.LapMatrix","initialProofState":"V : Type u_1\nR : Type u_2\ninst✝⁴ : Fintype V\nG : SimpleGraph V\ninst✝³ : DecidableRel G.Adj\ninst✝² : DecidableEq V\ninst✝¹ : Field R\ninst✝ : CharZero R\nx : V → R\n⊢ Eq ((((Matrix.toLinearMap₂' R) (SimpleGraph.lapMatrix R G)) x) x) (HDiv.hDiv (Finset.univ.sum fun i => Finset.univ.sum fun j => ite (G.Adj i j) (HPow.hPow (HSub.hSub (x i) (x j)) 2) 0) 2)","decl":"/-- Let $L$ be the graph Laplacian and let $x \\in \\mathbb{R}$, then\n$$x^{\\top} L x = \\sum_{i \\sim j} (x_{i}-x_{j})^{2}$$,\nwhere $\\sim$ denotes the adjacency relation -/\ntheorem lapMatrix_toLinearMap₂' [Field R] [CharZero R] (x : V → R) :\n    toLinearMap₂' R (G.lapMatrix R) x x =\n    (∑ i : V, ∑ j : V, if G.Adj i j then (x i - x j)^2 else 0) / 2 := by\n  simp_rw [toLinearMap₂'_apply', lapMatrix, sub_mulVec, dotProduct_sub, dotProduct_mulVec_degMatrix,\n    dotProduct_mulVec_adjMatrix, ← sum_sub_distrib, degree_eq_sum_if_adj, sum_mul, ite_mul, one_mul,\n    zero_mul, ← sum_sub_distrib, ite_sub_ite, sub_zero]\n  rw [← add_self_div_two (∑ x_1 : V, ∑ x_2 : V, _)]\n  conv_lhs => enter [1,2,2,i,2,j]; rw [if_congr (adj_comm G i j) rfl rfl]\n  conv_lhs => enter [1,2]; rw [Finset.sum_comm]\n  simp_rw [← sum_add_distrib, ite_add_ite]\n  congr 2 with i\n  congr 2 with j\n  ring_nf\n\n"}
{"name":"SimpleGraph.posSemidef_lapMatrix","module":"Mathlib.Combinatorics.SimpleGraph.LapMatrix","initialProofState":"V : Type u_1\nR : Type u_2\ninst✝⁵ : Fintype V\nG : SimpleGraph V\ninst✝⁴ : DecidableRel G.Adj\ninst✝³ : DecidableEq V\ninst✝² : LinearOrderedField R\ninst✝¹ : StarRing R\ninst✝ : TrivialStar R\n⊢ (SimpleGraph.lapMatrix R G).PosSemidef","decl":"/-- The Laplacian matrix is positive semidefinite -/\ntheorem posSemidef_lapMatrix [LinearOrderedField R] [StarRing R]\n    [TrivialStar R] : PosSemidef (G.lapMatrix R) := by\n  constructor\n  · rw [IsHermitian, conjTranspose_eq_transpose_of_trivial, isSymm_lapMatrix]\n  · intro x\n    rw [star_trivial, ← toLinearMap₂'_apply', lapMatrix_toLinearMap₂']\n    positivity\n\n"}
{"name":"SimpleGraph.lapMatrix_toLinearMap₂'_apply'_eq_zero_iff_forall_adj","module":"Mathlib.Combinatorics.SimpleGraph.LapMatrix","initialProofState":"V : Type u_1\nR : Type u_2\ninst✝³ : Fintype V\nG : SimpleGraph V\ninst✝² : DecidableRel G.Adj\ninst✝¹ : DecidableEq V\ninst✝ : LinearOrderedField R\nx : V → R\n⊢ Iff (Eq ((((Matrix.toLinearMap₂' R) (SimpleGraph.lapMatrix R G)) x) x) 0) (∀ (i j : V), G.Adj i j → Eq (x i) (x j))","decl":"theorem lapMatrix_toLinearMap₂'_apply'_eq_zero_iff_forall_adj [LinearOrderedField R] (x : V → R) :\n    Matrix.toLinearMap₂' R (G.lapMatrix R) x x = 0 ↔ ∀ i j : V, G.Adj i j → x i = x j := by\n  simp (disch := intros; positivity)\n    [lapMatrix_toLinearMap₂', sum_eq_zero_iff_of_nonneg, sub_eq_zero]\n\n"}
{"name":"SimpleGraph.lapMatrix_toLin'_apply_eq_zero_iff_forall_adj","module":"Mathlib.Combinatorics.SimpleGraph.LapMatrix","initialProofState":"V : Type u_1\ninst✝² : Fintype V\nG : SimpleGraph V\ninst✝¹ : DecidableRel G.Adj\ninst✝ : DecidableEq V\nx : V → Real\n⊢ Iff (Eq ((Matrix.toLin' (SimpleGraph.lapMatrix Real G)) x) 0) (∀ (i j : V), G.Adj i j → Eq (x i) (x j))","decl":"theorem lapMatrix_toLin'_apply_eq_zero_iff_forall_adj (x : V → ℝ) :\n    Matrix.toLin' (G.lapMatrix ℝ) x = 0 ↔ ∀ i j : V, G.Adj i j → x i = x j := by\n  rw [← (posSemidef_lapMatrix ℝ G).toLinearMap₂'_zero_iff, star_trivial,\n      lapMatrix_toLinearMap₂'_apply'_eq_zero_iff_forall_adj]\n\n"}
{"name":"SimpleGraph.lapMatrix_toLinearMap₂'_apply'_eq_zero_iff_forall_reachable","module":"Mathlib.Combinatorics.SimpleGraph.LapMatrix","initialProofState":"V : Type u_1\ninst✝² : Fintype V\nG : SimpleGraph V\ninst✝¹ : DecidableRel G.Adj\ninst✝ : DecidableEq V\nx : V → Real\n⊢ Iff (Eq ((((Matrix.toLinearMap₂' Real) (SimpleGraph.lapMatrix Real G)) x) x) 0) (∀ (i j : V), G.Reachable i j → Eq (x i) (x j))","decl":"theorem lapMatrix_toLinearMap₂'_apply'_eq_zero_iff_forall_reachable (x : V → ℝ) :\n    Matrix.toLinearMap₂' ℝ (G.lapMatrix ℝ) x x = 0 ↔\n      ∀ i j : V, G.Reachable i j → x i = x j := by\n  rw [lapMatrix_toLinearMap₂'_apply'_eq_zero_iff_forall_adj]\n  refine ⟨?_, fun h i j hA ↦ h i j hA.reachable⟩\n  intro h i j ⟨w⟩\n  induction w with\n  | nil => rfl\n  | cons hA _ h' => exact (h _ _ hA).trans h'\n\n"}
{"name":"SimpleGraph.lapMatrix_toLin'_apply_eq_zero_iff_forall_reachable","module":"Mathlib.Combinatorics.SimpleGraph.LapMatrix","initialProofState":"V : Type u_1\ninst✝² : Fintype V\nG : SimpleGraph V\ninst✝¹ : DecidableRel G.Adj\ninst✝ : DecidableEq V\nx : V → Real\n⊢ Iff (Eq ((Matrix.toLin' (SimpleGraph.lapMatrix Real G)) x) 0) (∀ (i j : V), G.Reachable i j → Eq (x i) (x j))","decl":"theorem lapMatrix_toLin'_apply_eq_zero_iff_forall_reachable (x : V → ℝ) :\n    Matrix.toLin' (G.lapMatrix ℝ) x = 0 ↔ ∀ i j : V, G.Reachable i j → x i = x j := by\n  rw [← (posSemidef_lapMatrix ℝ G).toLinearMap₂'_zero_iff, star_trivial,\n      lapMatrix_toLinearMap₂'_apply'_eq_zero_iff_forall_reachable]\n\n"}
{"name":"SimpleGraph.mem_ker_toLin'_lapMatrix_of_connectedComponent","module":"Mathlib.Combinatorics.SimpleGraph.LapMatrix","initialProofState":"V : Type u_1\ninst✝³ : Fintype V\ninst✝² : DecidableEq V\nG : SimpleGraph V\ninst✝¹ : DecidableRel G.Adj\ninst✝ : DecidableEq G.ConnectedComponent\nc : G.ConnectedComponent\n⊢ Membership.mem (LinearMap.ker (Matrix.toLin' (SimpleGraph.lapMatrix Real G))) fun i => ite (Eq (G.connectedComponentMk i) c) 1 0","decl":"lemma mem_ker_toLin'_lapMatrix_of_connectedComponent {G : SimpleGraph V} [DecidableRel G.Adj]\n    [DecidableEq G.ConnectedComponent] (c : G.ConnectedComponent) :\n    (fun i ↦ if connectedComponentMk G i = c then 1 else 0) ∈\n      LinearMap.ker (toLin' (lapMatrix ℝ G)) := by\n  rw [LinearMap.mem_ker, lapMatrix_toLin'_apply_eq_zero_iff_forall_reachable]\n  intro i j h\n  split_ifs with h₁ h₂ h₃\n  · rfl\n  · rw [← ConnectedComponent.eq] at h\n    exact (h₂ (h₁ ▸ h.symm)).elim\n  · rw [← ConnectedComponent.eq] at h\n    exact (h₁ (h₃ ▸ h)).elim\n  · rfl\n\n"}
{"name":"SimpleGraph.linearIndependent_lapMatrix_ker_basis_aux","module":"Mathlib.Combinatorics.SimpleGraph.LapMatrix","initialProofState":"V : Type u_1\ninst✝³ : Fintype V\nG : SimpleGraph V\ninst✝² : DecidableRel G.Adj\ninst✝¹ : DecidableEq V\ninst✝ : DecidableEq G.ConnectedComponent\n⊢ LinearIndependent Real G.lapMatrix_ker_basis_aux","decl":"lemma linearIndependent_lapMatrix_ker_basis_aux :\n    LinearIndependent ℝ (lapMatrix_ker_basis_aux G) := by\n  rw [Fintype.linearIndependent_iff]\n  intro g h0\n  rw [Subtype.ext_iff] at h0\n  have h : ∑ c, g c • lapMatrix_ker_basis_aux G c = fun i ↦ g (connectedComponentMk G i) := by\n    simp only [lapMatrix_ker_basis_aux, SetLike.mk_smul_mk, AddSubmonoid.coe_finset_sum]\n    repeat rw [AddSubmonoid.coe_finset_sum]\n    ext i\n    simp only [Finset.sum_apply, Pi.smul_apply, smul_eq_mul, mul_ite, mul_one, mul_zero, sum_ite_eq,\n      mem_univ, ↓reduceIte]\n  rw [h] at h0\n  intro c\n  obtain ⟨i, h'⟩ : ∃ i : V, G.connectedComponentMk i = c := Quot.exists_rep c\n  exact h' ▸ congrFun h0 i\n\n"}
{"name":"SimpleGraph.top_le_span_range_lapMatrix_ker_basis_aux","module":"Mathlib.Combinatorics.SimpleGraph.LapMatrix","initialProofState":"V : Type u_1\ninst✝³ : Fintype V\nG : SimpleGraph V\ninst✝² : DecidableRel G.Adj\ninst✝¹ : DecidableEq V\ninst✝ : DecidableEq G.ConnectedComponent\n⊢ LE.le Top.top (Submodule.span Real (Set.range G.lapMatrix_ker_basis_aux))","decl":"lemma top_le_span_range_lapMatrix_ker_basis_aux :\n    ⊤ ≤ Submodule.span ℝ (Set.range (lapMatrix_ker_basis_aux G)) := by\n  intro x _\n  rw [mem_span_range_iff_exists_fun]\n  use Quot.lift x.val (by rw [← lapMatrix_toLin'_apply_eq_zero_iff_forall_reachable G x,\n    LinearMap.map_coe_ker])\n  ext j\n  simp only [lapMatrix_ker_basis_aux]\n  rw [AddSubmonoid.coe_finset_sum]\n  simp only [SetLike.mk_smul_mk, Finset.sum_apply, Pi.smul_apply, smul_eq_mul, mul_ite, mul_one,\n    mul_zero, sum_ite_eq, mem_univ, ↓reduceIte]\n  rfl\n\n"}
{"name":"SimpleGraph.card_ConnectedComponent_eq_rank_ker_lapMatrix","module":"Mathlib.Combinatorics.SimpleGraph.LapMatrix","initialProofState":"V : Type u_1\ninst✝² : Fintype V\nG : SimpleGraph V\ninst✝¹ : DecidableRel G.Adj\ninst✝ : DecidableEq V\n⊢ Eq (Fintype.card G.ConnectedComponent) (Module.finrank Real (Subtype fun x => Membership.mem (LinearMap.ker (Matrix.toLin' (SimpleGraph.lapMatrix Real G))) x))","decl":"/-- The number of connected components in `G` is the dimension of the nullspace of its Laplacian. -/\ntheorem card_ConnectedComponent_eq_rank_ker_lapMatrix : Fintype.card G.ConnectedComponent =\n    Module.finrank ℝ (LinearMap.ker (Matrix.toLin' (G.lapMatrix ℝ))) := by\n  classical\n  rw [Module.finrank_eq_card_basis (lapMatrix_ker_basis G)]\n\n"}
