{"name":"LinearMap.isSymmetric_iff_sesqForm","module":"Mathlib.Analysis.InnerProductSpace.Symmetric","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nT : LinearMap (RingHom.id ğ•œ) E E\nâŠ¢ Iff T.IsSymmetric (sesqFormOfInner.IsSelfAdjoint â‡‘T)","decl":"/-- An operator `T` on an inner product space is symmetric if and only if it is\n`LinearMap.IsSelfAdjoint` with respect to the sesquilinear form given by the inner product. -/\ntheorem isSymmetric_iff_sesqForm (T : E â†’â‚—[ğ•œ] E) :\n    T.IsSymmetric â†” LinearMap.IsSelfAdjoint (R := ğ•œ) (M := E) sesqFormOfInner T :=\n  âŸ¨fun h x y => (h y x).symm, fun h x y => (h y x).symmâŸ©\n\n"}
{"name":"LinearMap.IsSymmetric.conj_inner_sym","module":"Mathlib.Analysis.InnerProductSpace.Symmetric","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nT : LinearMap (RingHom.id ğ•œ) E E\nhT : T.IsSymmetric\nx y : E\nâŠ¢ Eq ((starRingEnd ğ•œ) (Inner.inner (T x) y)) (Inner.inner (T y) x)","decl":"theorem IsSymmetric.conj_inner_sym {T : E â†’â‚—[ğ•œ] E} (hT : IsSymmetric T) (x y : E) :\n    conj âŸªT x, yâŸ« = âŸªT y, xâŸ« := by rw [hT x y, inner_conj_symm]\n\n"}
{"name":"LinearMap.IsSymmetric.apply_clm","module":"Mathlib.Analysis.InnerProductSpace.Symmetric","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nT : ContinuousLinearMap (RingHom.id ğ•œ) E E\nhT : (â†‘T).IsSymmetric\nx y : E\nâŠ¢ Eq (Inner.inner (T x) y) (Inner.inner x (T y))","decl":"@[simp]\ntheorem IsSymmetric.apply_clm {T : E â†’L[ğ•œ] E} (hT : IsSymmetric (T : E â†’â‚—[ğ•œ] E)) (x y : E) :\n    âŸªT x, yâŸ« = âŸªx, T yâŸ« :=\n  hT x y\n\n"}
{"name":"LinearMap.IsSymmetric.zero","module":"Mathlib.Analysis.InnerProductSpace.Symmetric","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nâŠ¢ LinearMap.IsSymmetric 0","decl":"@[simp]\nprotected theorem IsSymmetric.zero : (0 : E â†’â‚—[ğ•œ] E).IsSymmetric := fun x y =>\n  (inner_zero_right x : âŸªx, 0âŸ« = 0).symm â–¸ (inner_zero_left y : âŸª0, yâŸ« = 0)\n\n"}
{"name":"LinearMap.isSymmetric_zero","module":"Mathlib.Analysis.InnerProductSpace.Symmetric","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nâŠ¢ LinearMap.IsSymmetric 0","decl":"@[deprecated (since := \"2024-09-30\")] alias isSymmetric_zero := IsSymmetric.zero\n\n"}
{"name":"LinearMap.IsSymmetric.id","module":"Mathlib.Analysis.InnerProductSpace.Symmetric","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nâŠ¢ LinearMap.id.IsSymmetric","decl":"@[simp]\nprotected theorem IsSymmetric.id : (LinearMap.id : E â†’â‚—[ğ•œ] E).IsSymmetric := fun _ _ => rfl\n\n"}
{"name":"LinearMap.isSymmetric_id","module":"Mathlib.Analysis.InnerProductSpace.Symmetric","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nâŠ¢ LinearMap.id.IsSymmetric","decl":"@[deprecated (since := \"2024-09-30\")] alias isSymmetric_id := IsSymmetric.id\n\n"}
{"name":"LinearMap.IsSymmetric.add","module":"Mathlib.Analysis.InnerProductSpace.Symmetric","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nT S : LinearMap (RingHom.id ğ•œ) E E\nhT : T.IsSymmetric\nhS : S.IsSymmetric\nâŠ¢ (HAdd.hAdd T S).IsSymmetric","decl":"@[aesop safe apply]\ntheorem IsSymmetric.add {T S : E â†’â‚—[ğ•œ] E} (hT : T.IsSymmetric) (hS : S.IsSymmetric) :\n    (T + S).IsSymmetric := by\n  intro x y\n  rw [add_apply, inner_add_left, hT x y, hS x y, â† inner_add_right, add_apply]\n\n"}
{"name":"LinearMap.IsSymmetric.sub","module":"Mathlib.Analysis.InnerProductSpace.Symmetric","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nT S : LinearMap (RingHom.id ğ•œ) E E\nhT : T.IsSymmetric\nhS : S.IsSymmetric\nâŠ¢ (HSub.hSub T S).IsSymmetric","decl":"@[aesop safe apply]\ntheorem IsSymmetric.sub {T S : E â†’â‚—[ğ•œ] E} (hT : T.IsSymmetric) (hS : S.IsSymmetric) :\n    (T - S).IsSymmetric := by\n  intro x y\n  rw [sub_apply, inner_sub_left, hT x y, hS x y, â† inner_sub_right, sub_apply]\n\n"}
{"name":"LinearMap.IsSymmetric.smul","module":"Mathlib.Analysis.InnerProductSpace.Symmetric","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nc : ğ•œ\nhc : Eq ((starRingEnd ğ•œ) c) c\nT : LinearMap (RingHom.id ğ•œ) E E\nhT : T.IsSymmetric\nâŠ¢ (HSMul.hSMul c T).IsSymmetric","decl":"@[aesop safe apply]\ntheorem IsSymmetric.smul {c : ğ•œ} (hc : conj c = c) {T : E â†’â‚—[ğ•œ] E} (hT : T.IsSymmetric) :\n    c â€¢ T |>.IsSymmetric := by\n  intro x y\n  simp only [smul_apply, inner_smul_left, hc, hT x y, inner_smul_right]\n\n"}
{"name":"LinearMap.IsSymmetric.mul_of_commute","module":"Mathlib.Analysis.InnerProductSpace.Symmetric","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nS T : LinearMap (RingHom.id ğ•œ) E E\nhS : S.IsSymmetric\nhT : T.IsSymmetric\nhST : Commute S T\nâŠ¢ (HMul.hMul S T).IsSymmetric","decl":"@[aesop 30% apply]\nlemma IsSymmetric.mul_of_commute {S T : E â†’â‚—[ğ•œ] E} (hS : S.IsSymmetric) (hT : T.IsSymmetric)\n    (hST : Commute S T) : (S * T).IsSymmetric :=\n  fun _ _ â†¦ by rw [mul_apply, hS, hT, hST, mul_apply]\n\n"}
{"name":"LinearMap.IsSymmetric.pow","module":"Mathlib.Analysis.InnerProductSpace.Symmetric","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nT : LinearMap (RingHom.id ğ•œ) E E\nhT : T.IsSymmetric\nn : Nat\nâŠ¢ (HPow.hPow T n).IsSymmetric","decl":"@[aesop safe apply]\nlemma IsSymmetric.pow {T : E â†’â‚—[ğ•œ] E} (hT : T.IsSymmetric) (n : â„•) : (T ^ n).IsSymmetric := by\n  refine Nat.le_induction (by simp [one_eq_id]) (fun k _ ih â†¦ ?_) n n.zero_le\n  rw [iterate_succ, â† mul_eq_comp]\n  exact ih.mul_of_commute hT <| .pow_left rfl k\n\n"}
{"name":"LinearMap.IsSymmetric.coe_reApplyInnerSelf_apply","module":"Mathlib.Analysis.InnerProductSpace.Symmetric","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nT : ContinuousLinearMap (RingHom.id ğ•œ) E E\nhT : (â†‘T).IsSymmetric\nx : E\nâŠ¢ Eq (â†‘(T.reApplyInnerSelf x)) (Inner.inner (T x) x)","decl":"/-- For a symmetric operator `T`, the function `fun x â†¦ âŸªT x, xâŸ«` is real-valued. -/\n@[simp]\ntheorem IsSymmetric.coe_reApplyInnerSelf_apply {T : E â†’L[ğ•œ] E} (hT : IsSymmetric (T : E â†’â‚—[ğ•œ] E))\n    (x : E) : (T.reApplyInnerSelf x : ğ•œ) = âŸªT x, xâŸ« := by\n  rsuffices âŸ¨r, hrâŸ© : âˆƒ r : â„, âŸªT x, xâŸ« = r\n  Â· simp [hr, T.reApplyInnerSelf_apply]\n  rw [â† conj_eq_iff_real]\n  exact hT.conj_inner_sym x x\n\n"}
{"name":"LinearMap.IsSymmetric.restrict_invariant","module":"Mathlib.Analysis.InnerProductSpace.Symmetric","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nT : LinearMap (RingHom.id ğ•œ) E E\nhT : T.IsSymmetric\nV : Submodule ğ•œ E\nhV : âˆ€ (v : E), Membership.mem V v â†’ Membership.mem V (T v)\nâŠ¢ (T.restrict hV).IsSymmetric","decl":"/-- If a symmetric operator preserves a submodule, its restriction to that submodule is\nsymmetric. -/\ntheorem IsSymmetric.restrict_invariant {T : E â†’â‚—[ğ•œ] E} (hT : IsSymmetric T) {V : Submodule ğ•œ E}\n    (hV : âˆ€ v âˆˆ V, T v âˆˆ V) : IsSymmetric (T.restrict hV) := fun v w => hT v w\n\n"}
{"name":"LinearMap.IsSymmetric.restrictScalars","module":"Mathlib.Analysis.InnerProductSpace.Symmetric","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nT : LinearMap (RingHom.id ğ•œ) E E\nhT : T.IsSymmetric\nâŠ¢ (â†‘Real T).IsSymmetric","decl":"theorem IsSymmetric.restrictScalars {T : E â†’â‚—[ğ•œ] E} (hT : T.IsSymmetric) :\n    letI := InnerProductSpace.rclikeToReal ğ•œ E\n    letI : IsScalarTower â„ ğ•œ E := RestrictScalars.isScalarTower _ _ _\n    (T.restrictScalars â„).IsSymmetric :=\n  fun x y => by simp [hT x y, real_inner_eq_re_inner, LinearMap.coe_restrictScalars â„]\n\n"}
{"name":"LinearMap.isSymmetric_iff_inner_map_self_real","module":"Mathlib.Analysis.InnerProductSpace.Symmetric","initialProofState":"V : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup V\ninstâœ : InnerProductSpace Complex V\nT : LinearMap (RingHom.id Complex) V V\nâŠ¢ Iff T.IsSymmetric (âˆ€ (v : V), Eq ((starRingEnd Complex) (Inner.inner (T v) v)) (Inner.inner (T v) v))","decl":"attribute [local simp] map_ofNat in -- use `ofNat` simp theorem with bad keys\nopen scoped InnerProductSpace in\n/-- A linear operator on a complex inner product space is symmetric precisely when\n`âŸªT v, vâŸ«_â„‚` is real for all v. -/\ntheorem isSymmetric_iff_inner_map_self_real (T : V â†’â‚—[â„‚] V) :\n    IsSymmetric T â†” âˆ€ v : V, conj âŸªT v, vâŸ«_â„‚ = âŸªT v, vâŸ«_â„‚ := by\n  constructor\n  Â· intro hT v\n    apply IsSymmetric.conj_inner_sym hT\n  Â· intro h x y\n    rw [â† inner_conj_symm x (T y)]\n    rw [inner_map_polarization T x y]\n    simp only [starRingEnd_apply, star_divâ‚€, star_sub, star_add, star_mul]\n    simp only [â† starRingEnd_apply]\n    rw [h (x + y), h (x - y), h (x + Complex.I â€¢ y), h (x - Complex.I â€¢ y)]\n    simp only [Complex.conj_I]\n    rw [inner_map_polarization']\n    norm_num\n    ring\n\n"}
{"name":"LinearMap.IsSymmetric.inner_map_polarization","module":"Mathlib.Analysis.InnerProductSpace.Symmetric","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nT : LinearMap (RingHom.id ğ•œ) E E\nhT : T.IsSymmetric\nx y : E\nâŠ¢ Eq (Inner.inner (T x) y) (HDiv.hDiv (HAdd.hAdd (HSub.hSub (HSub.hSub (Inner.inner (T (HAdd.hAdd x y)) (HAdd.hAdd x y)) (Inner.inner (T (HSub.hSub x y)) (HSub.hSub x y))) (HMul.hMul RCLike.I (Inner.inner (T (HAdd.hAdd x (HSMul.hSMul RCLike.I y))) (HAdd.hAdd x (HSMul.hSMul RCLike.I y))))) (HMul.hMul RCLike.I (Inner.inner (T (HSub.hSub x (HSMul.hSMul RCLike.I y))) (HSub.hSub x (HSMul.hSMul RCLike.I y))))) 4)","decl":"/-- Polarization identity for symmetric linear maps.\nSee `inner_map_polarization` for the complex version without the symmetric assumption. -/\ntheorem IsSymmetric.inner_map_polarization {T : E â†’â‚—[ğ•œ] E} (hT : T.IsSymmetric) (x y : E) :\n    âŸªT x, yâŸ« =\n      (âŸªT (x + y), x + yâŸ« - âŸªT (x - y), x - yâŸ« - I * âŸªT (x + (I : ğ•œ) â€¢ y), x + (I : ğ•œ) â€¢ yâŸ« +\n          I * âŸªT (x - (I : ğ•œ) â€¢ y), x - (I : ğ•œ) â€¢ yâŸ«) /\n        4 := by\n  rcases@I_mul_I_ax ğ•œ _ with (h | h)\n  Â· simp_rw [h, zero_mul, sub_zero, add_zero, map_add, map_sub, inner_add_left,\n      inner_add_right, inner_sub_left, inner_sub_right, hT x, â† inner_conj_symm x (T y)]\n    suffices (re âŸªT y, xâŸ« : ğ•œ) = âŸªT y, xâŸ« by\n      rw [conj_eq_iff_re.mpr this]\n      ring\n    rw [â† re_add_im âŸªT y, xâŸ«]\n    simp_rw [h, mul_zero, add_zero]\n    norm_cast\n  Â· simp_rw [map_add, map_sub, inner_add_left, inner_add_right, inner_sub_left, inner_sub_right,\n      LinearMap.map_smul, inner_smul_left, inner_smul_right, RCLike.conj_I, mul_add, mul_sub,\n      sub_sub, â† mul_assoc, mul_neg, h, neg_neg, one_mul, neg_one_mul]\n    ring\n\n"}
{"name":"LinearMap.IsSymmetric.continuous","module":"Mathlib.Analysis.InnerProductSpace.Symmetric","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : CompleteSpace E\nT : LinearMap (RingHom.id ğ•œ) E E\nhT : T.IsSymmetric\nâŠ¢ Continuous â‡‘T","decl":"/-- The **Hellinger--Toeplitz theorem**: if a symmetric operator is defined on a complete space,\n  then it is automatically continuous. -/\ntheorem IsSymmetric.continuous [CompleteSpace E] {T : E â†’â‚—[ğ•œ] E} (hT : IsSymmetric T) :\n    Continuous T := by\n  -- We prove it by using the closed graph theorem\n  refine T.continuous_of_seq_closed_graph fun u x y hu hTu => ?_\n  rw [â† sub_eq_zero, â† @inner_self_eq_zero ğ•œ]\n  have hlhs : âˆ€ k : â„•, âŸªT (u k) - T x, y - T xâŸ« = âŸªu k - x, T (y - T x)âŸ« := by\n    intro k\n    rw [â† T.map_sub, hT]\n  refine tendsto_nhds_unique ((hTu.sub_const _).inner tendsto_const_nhds) ?_\n  simp_rw [Function.comp_apply, hlhs]\n  rw [â† inner_zero_left (T (y - T x))]\n  refine Filter.Tendsto.inner ?_ tendsto_const_nhds\n  rw [â† sub_self x]\n  exact hu.sub_const _\n\n"}
{"name":"LinearMap.IsSymmetric.inner_map_self_eq_zero","module":"Mathlib.Analysis.InnerProductSpace.Symmetric","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nT : LinearMap (RingHom.id ğ•œ) E E\nhT : T.IsSymmetric\nâŠ¢ Iff (âˆ€ (x : E), Eq (Inner.inner (T x) x) 0) (Eq T 0)","decl":"/-- A symmetric linear map `T` is zero if and only if `âŸªT x, xâŸ«_â„ = 0` for all `x`.\nSee `inner_map_self_eq_zero` for the complex version without the symmetric assumption. -/\ntheorem IsSymmetric.inner_map_self_eq_zero {T : E â†’â‚—[ğ•œ] E} (hT : T.IsSymmetric) :\n    (âˆ€ x, âŸªT x, xâŸ« = 0) â†” T = 0 := by\n  simp_rw [LinearMap.ext_iff, zero_apply]\n  refine âŸ¨fun h x => ?_, fun h => by simp_rw [h, inner_zero_left, forall_const]âŸ©\n  rw [â† @inner_self_eq_zero ğ•œ, hT.inner_map_polarization]\n  simp_rw [h _]\n  ring\n\n"}
