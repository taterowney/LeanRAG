{"name":"Submodule.coe_set_neg","module":"Mathlib.Algebra.Module.Submodule.Pointwise","initialProofState":"R : Type u_2\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nS : Submodule R M\n⊢ Eq (↑(Neg.neg S)) (Neg.neg ↑S)","decl":"@[simp]\ntheorem coe_set_neg (S : Submodule R M) : ↑(-S) = -(S : Set M) :=\n  rfl\n\n"}
{"name":"Submodule.neg_toAddSubmonoid","module":"Mathlib.Algebra.Module.Submodule.Pointwise","initialProofState":"R : Type u_2\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nS : Submodule R M\n⊢ Eq (Neg.neg S).toAddSubmonoid (Neg.neg S.toAddSubmonoid)","decl":"@[simp]\ntheorem neg_toAddSubmonoid (S : Submodule R M) : (-S).toAddSubmonoid = -S.toAddSubmonoid :=\n  rfl\n\n"}
{"name":"Submodule.mem_neg","module":"Mathlib.Algebra.Module.Submodule.Pointwise","initialProofState":"R : Type u_2\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\ng : M\nS : Submodule R M\n⊢ Iff (Membership.mem (Neg.neg S) g) (Membership.mem S (Neg.neg g))","decl":"@[simp]\ntheorem mem_neg {g : M} {S : Submodule R M} : g ∈ -S ↔ -g ∈ S :=\n  Iff.rfl\n\n"}
{"name":"Submodule.neg_le_neg","module":"Mathlib.Algebra.Module.Submodule.Pointwise","initialProofState":"R : Type u_2\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nS T : Submodule R M\n⊢ Iff (LE.le (Neg.neg S) (Neg.neg T)) (LE.le S T)","decl":"@[simp]\ntheorem neg_le_neg (S T : Submodule R M) : -S ≤ -T ↔ S ≤ T :=\n  SetLike.coe_subset_coe.symm.trans Set.neg_subset_neg\n\n"}
{"name":"Submodule.neg_le","module":"Mathlib.Algebra.Module.Submodule.Pointwise","initialProofState":"R : Type u_2\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nS T : Submodule R M\n⊢ Iff (LE.le (Neg.neg S) T) (LE.le S (Neg.neg T))","decl":"theorem neg_le (S T : Submodule R M) : -S ≤ T ↔ S ≤ -T :=\n  SetLike.coe_subset_coe.symm.trans Set.neg_subset\n\n"}
{"name":"Submodule.closure_neg","module":"Mathlib.Algebra.Module.Submodule.Pointwise","initialProofState":"R : Type u_2\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\ns : Set M\n⊢ Eq (Submodule.span R (Neg.neg s)) (Neg.neg (Submodule.span R s))","decl":"theorem closure_neg (s : Set M) : span R (-s) = -span R s := by\n  apply le_antisymm\n  · rw [span_le, coe_set_neg, ← Set.neg_subset, neg_neg]\n    exact subset_span\n  · rw [neg_le, span_le, coe_set_neg, ← Set.neg_subset]\n    exact subset_span\n\n"}
{"name":"Submodule.neg_inf","module":"Mathlib.Algebra.Module.Submodule.Pointwise","initialProofState":"R : Type u_2\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nS T : Submodule R M\n⊢ Eq (Neg.neg (Min.min S T)) (Min.min (Neg.neg S) (Neg.neg T))","decl":"@[simp]\ntheorem neg_inf (S T : Submodule R M) : -(S ⊓ T) = -S ⊓ -T :=\n  SetLike.coe_injective Set.inter_neg\n\n"}
{"name":"Submodule.neg_sup","module":"Mathlib.Algebra.Module.Submodule.Pointwise","initialProofState":"R : Type u_2\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nS T : Submodule R M\n⊢ Eq (Neg.neg (Max.max S T)) (Max.max (Neg.neg S) (Neg.neg T))","decl":"@[simp]\ntheorem neg_sup (S T : Submodule R M) : -(S ⊔ T) = -S ⊔ -T :=\n  (negOrderIso : Submodule R M ≃o Submodule R M).map_sup S T\n\n"}
{"name":"Submodule.neg_bot","module":"Mathlib.Algebra.Module.Submodule.Pointwise","initialProofState":"R : Type u_2\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Eq (Neg.neg Bot.bot) Bot.bot","decl":"@[simp]\ntheorem neg_bot : -(⊥ : Submodule R M) = ⊥ :=\n  SetLike.coe_injective <| (Set.neg_singleton 0).trans <| congr_arg _ neg_zero\n\n"}
{"name":"Submodule.neg_top","module":"Mathlib.Algebra.Module.Submodule.Pointwise","initialProofState":"R : Type u_2\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Eq (Neg.neg Top.top) Top.top","decl":"@[simp]\ntheorem neg_top : -(⊤ : Submodule R M) = ⊤ :=\n  SetLike.coe_injective <| Set.neg_univ\n\n"}
{"name":"Submodule.neg_iInf","module":"Mathlib.Algebra.Module.Submodule.Pointwise","initialProofState":"R : Type u_2\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nι : Sort u_4\nS : ι → Submodule R M\n⊢ Eq (Neg.neg (iInf fun i => S i)) (iInf fun i => Neg.neg (S i))","decl":"@[simp]\ntheorem neg_iInf {ι : Sort*} (S : ι → Submodule R M) : (-⨅ i, S i) = ⨅ i, -S i :=\n  (negOrderIso : Submodule R M ≃o Submodule R M).map_iInf _\n\n"}
{"name":"Submodule.neg_iSup","module":"Mathlib.Algebra.Module.Submodule.Pointwise","initialProofState":"R : Type u_2\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nι : Sort u_4\nS : ι → Submodule R M\n⊢ Eq (Neg.neg (iSup fun i => S i)) (iSup fun i => Neg.neg (S i))","decl":"@[simp]\ntheorem neg_iSup {ι : Sort*} (S : ι → Submodule R M) : (-⨆ i, S i) = ⨆ i, -S i :=\n  (negOrderIso : Submodule R M ≃o Submodule R M).map_iSup _\n\n"}
{"name":"Submodule.neg_eq_self","module":"Mathlib.Algebra.Module.Submodule.Pointwise","initialProofState":"R : Type u_2\nM : Type u_3\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np : Submodule R M\n⊢ Eq (Neg.neg p) p","decl":"@[simp]\ntheorem neg_eq_self [Ring R] [AddCommGroup M] [Module R M] (p : Submodule R M) : -p = p :=\n  ext fun _ => p.neg_mem_iff\n\n"}
{"name":"Submodule.add_eq_sup","module":"Mathlib.Algebra.Module.Submodule.Pointwise","initialProofState":"R : Type u_2\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np q : Submodule R M\n⊢ Eq (HAdd.hAdd p q) (Max.max p q)","decl":"@[simp]\ntheorem add_eq_sup (p q : Submodule R M) : p + q = p ⊔ q :=\n  rfl\n\n"}
{"name":"Submodule.zero_eq_bot","module":"Mathlib.Algebra.Module.Submodule.Pointwise","initialProofState":"R : Type u_2\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Eq 0 Bot.bot","decl":"@[simp]\ntheorem zero_eq_bot : (0 : Submodule R M) = ⊥ :=\n  rfl\n\n"}
{"name":"Submodule.instCanonicallyOrderedAdd","module":"Mathlib.Algebra.Module.Submodule.Pointwise","initialProofState":"R : Type u_2\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ CanonicallyOrderedAdd (Submodule R M)","decl":"instance : CanonicallyOrderedAdd (Submodule R M) where\n  exists_add_of_le := @fun _a b h => ⟨b, (sup_eq_right.2 h).symm⟩\n  le_self_add := fun _a _b => le_sup_left\n\n"}
{"name":"Submodule.coe_pointwise_smul","module":"Mathlib.Algebra.Module.Submodule.Pointwise","initialProofState":"α : Type u_1\nR : Type u_2\nM : Type u_3\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : Monoid α\ninst✝¹ : DistribMulAction α M\ninst✝ : SMulCommClass α R M\na : α\nS : Submodule R M\n⊢ Eq (↑(HSMul.hSMul a S)) (HSMul.hSMul a ↑S)","decl":"@[simp]\ntheorem coe_pointwise_smul (a : α) (S : Submodule R M) : ↑(a • S) = a • (S : Set M) :=\n  rfl\n\n"}
{"name":"Submodule.pointwise_smul_toAddSubmonoid","module":"Mathlib.Algebra.Module.Submodule.Pointwise","initialProofState":"α : Type u_1\nR : Type u_2\nM : Type u_3\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : Monoid α\ninst✝¹ : DistribMulAction α M\ninst✝ : SMulCommClass α R M\na : α\nS : Submodule R M\n⊢ Eq (HSMul.hSMul a S).toAddSubmonoid (HSMul.hSMul a S.toAddSubmonoid)","decl":"@[simp]\ntheorem pointwise_smul_toAddSubmonoid (a : α) (S : Submodule R M) :\n    (a • S).toAddSubmonoid = a • S.toAddSubmonoid :=\n  rfl\n\n"}
{"name":"Submodule.pointwise_smul_toAddSubgroup","module":"Mathlib.Algebra.Module.Submodule.Pointwise","initialProofState":"α : Type u_1\ninst✝⁵ : Monoid α\nR : Type u_4\nM : Type u_5\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : DistribMulAction α M\ninst✝¹ : Module R M\ninst✝ : SMulCommClass α R M\na : α\nS : Submodule R M\n⊢ Eq (HSMul.hSMul a S).toAddSubgroup (HSMul.hSMul a S.toAddSubgroup)","decl":"@[simp]\ntheorem pointwise_smul_toAddSubgroup {R M : Type*} [Ring R] [AddCommGroup M] [DistribMulAction α M]\n    [Module R M] [SMulCommClass α R M] (a : α) (S : Submodule R M) :\n    (a • S).toAddSubgroup = a • S.toAddSubgroup :=\n  rfl\n\n"}
{"name":"Submodule.smul_mem_pointwise_smul","module":"Mathlib.Algebra.Module.Submodule.Pointwise","initialProofState":"α : Type u_1\nR : Type u_2\nM : Type u_3\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : Monoid α\ninst✝¹ : DistribMulAction α M\ninst✝ : SMulCommClass α R M\nm : M\na : α\nS : Submodule R M\na✝ : Membership.mem S m\n⊢ Membership.mem (HSMul.hSMul a S) (HSMul.hSMul a m)","decl":"theorem smul_mem_pointwise_smul (m : M) (a : α) (S : Submodule R M) : m ∈ S → a • m ∈ a • S :=\n  (Set.smul_mem_smul_set : _ → _ ∈ a • (S : Set M))\n\n"}
{"name":"Submodule.instCovariantClassHSMulLe","module":"Mathlib.Algebra.Module.Submodule.Pointwise","initialProofState":"α : Type u_1\nR : Type u_2\nM : Type u_3\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : Monoid α\ninst✝¹ : DistribMulAction α M\ninst✝ : SMulCommClass α R M\n⊢ CovariantClass α (Submodule R M) HSMul.hSMul LE.le","decl":"instance : CovariantClass α (Submodule R M) HSMul.hSMul LE.le :=\n  ⟨fun _ _ => map_mono⟩\n\n"}
{"name":"Submodule.smul_bot'","module":"Mathlib.Algebra.Module.Submodule.Pointwise","initialProofState":"α : Type u_1\nR : Type u_2\nM : Type u_3\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : Monoid α\ninst✝¹ : DistribMulAction α M\ninst✝ : SMulCommClass α R M\na : α\n⊢ Eq (HSMul.hSMul a Bot.bot) Bot.bot","decl":"/-- See also `Submodule.smul_bot`. -/\n@[simp]\ntheorem smul_bot' (a : α) : a • (⊥ : Submodule R M) = ⊥ :=\n  map_bot _\n\n"}
{"name":"Submodule.smul_sup'","module":"Mathlib.Algebra.Module.Submodule.Pointwise","initialProofState":"α : Type u_1\nR : Type u_2\nM : Type u_3\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : Monoid α\ninst✝¹ : DistribMulAction α M\ninst✝ : SMulCommClass α R M\na : α\nS T : Submodule R M\n⊢ Eq (HSMul.hSMul a (Max.max S T)) (Max.max (HSMul.hSMul a S) (HSMul.hSMul a T))","decl":"/-- See also `Submodule.smul_sup`. -/\ntheorem smul_sup' (a : α) (S T : Submodule R M) : a • (S ⊔ T) = a • S ⊔ a • T :=\n  map_sup _ _ _\n\n"}
{"name":"Submodule.smul_span","module":"Mathlib.Algebra.Module.Submodule.Pointwise","initialProofState":"α : Type u_1\nR : Type u_2\nM : Type u_3\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : Monoid α\ninst✝¹ : DistribMulAction α M\ninst✝ : SMulCommClass α R M\na : α\ns : Set M\n⊢ Eq (HSMul.hSMul a (Submodule.span R s)) (Submodule.span R (HSMul.hSMul a s))","decl":"theorem smul_span (a : α) (s : Set M) : a • span R s = span R (a • s) :=\n  map_span _ _\n\n"}
{"name":"Submodule.smul_def","module":"Mathlib.Algebra.Module.Submodule.Pointwise","initialProofState":"α : Type u_1\nR : Type u_2\nM : Type u_3\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : Monoid α\ninst✝¹ : DistribMulAction α M\ninst✝ : SMulCommClass α R M\na : α\nS : Submodule R M\n⊢ Eq (HSMul.hSMul a S) (Submodule.span R (HSMul.hSMul a ↑S))","decl":"lemma smul_def (a : α) (S : Submodule R M) : a • S = span R (a • S : Set M) := by simp [← smul_span]\n\n"}
{"name":"Submodule.span_smul","module":"Mathlib.Algebra.Module.Submodule.Pointwise","initialProofState":"α : Type u_1\nR : Type u_2\nM : Type u_3\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : Monoid α\ninst✝¹ : DistribMulAction α M\ninst✝ : SMulCommClass α R M\na : α\ns : Set M\n⊢ Eq (Submodule.span R (HSMul.hSMul a s)) (HSMul.hSMul a (Submodule.span R s))","decl":"theorem span_smul (a : α) (s : Set M) : span R (a • s) = a • span R s :=\n  Eq.symm (span_image _).symm\n\n"}
{"name":"Submodule.pointwiseCentralScalar","module":"Mathlib.Algebra.Module.Submodule.Pointwise","initialProofState":"α : Type u_1\nR : Type u_2\nM : Type u_3\ninst✝⁸ : Semiring R\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R M\ninst✝⁵ : Monoid α\ninst✝⁴ : DistribMulAction α M\ninst✝³ : SMulCommClass α R M\ninst✝² : DistribMulAction (MulOpposite α) M\ninst✝¹ : SMulCommClass (MulOpposite α) R M\ninst✝ : IsCentralScalar α M\n⊢ IsCentralScalar α (Submodule R M)","decl":"instance pointwiseCentralScalar [DistribMulAction αᵐᵒᵖ M] [SMulCommClass αᵐᵒᵖ R M]\n    [IsCentralScalar α M] : IsCentralScalar α (Submodule R M) :=\n  ⟨fun _a S => (congr_arg fun f : Module.End R M => S.map f) <| LinearMap.ext <| op_smul_eq_smul _⟩\n\n"}
{"name":"Submodule.smul_le_self_of_tower","module":"Mathlib.Algebra.Module.Submodule.Pointwise","initialProofState":"R : Type u_2\nM : Type u_3\ninst✝⁷ : Semiring R\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\nα : Type u_4\ninst✝⁴ : Semiring α\ninst✝³ : Module α R\ninst✝² : Module α M\ninst✝¹ : SMulCommClass α R M\ninst✝ : IsScalarTower α R M\na : α\nS : Submodule R M\n⊢ LE.le (HSMul.hSMul a S) S","decl":"@[simp]\ntheorem smul_le_self_of_tower {α : Type*} [Semiring α] [Module α R] [Module α M]\n    [SMulCommClass α R M] [IsScalarTower α R M] (a : α) (S : Submodule R M) : a • S ≤ S := by\n  rintro y ⟨x, hx, rfl⟩\n  exact smul_of_tower_mem _ a hx\n\n"}
{"name":"Submodule.mem_set_smul_def","module":"Mathlib.Algebra.Module.Submodule.Pointwise","initialProofState":"R : Type u_2\nM : Type u_3\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nS : Type u_4\ninst✝¹ : Monoid S\ninst✝ : DistribMulAction S M\ns : Set S\nN : Submodule R M\nx : M\n⊢ Iff (Membership.mem (HSMul.hSMul s N) x) (Membership.mem (InfSet.sInf (setOf fun p => ∀ ⦃r : S⦄ {n : M}, Membership.mem s r → Membership.mem N n → Membership.mem p (HSMul.hSMul r n))) x)","decl":"lemma mem_set_smul_def (x : M) :\n    x ∈ s • N ↔\n  x ∈ sInf { p : Submodule R M | ∀ ⦃r : S⦄ {n : M}, r ∈ s → n ∈ N → r • n ∈ p } := Iff.rfl\n\n"}
{"name":"Submodule.mem_set_smul_of_mem_mem","module":"Mathlib.Algebra.Module.Submodule.Pointwise","initialProofState":"R : Type u_2\nM : Type u_3\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nS : Type u_4\ninst✝¹ : Monoid S\ninst✝ : DistribMulAction S M\ns : Set S\nN : Submodule R M\nr : S\nm : M\nmem1 : Membership.mem s r\nmem2 : Membership.mem N m\n⊢ Membership.mem (HSMul.hSMul s N) (HSMul.hSMul r m)","decl":"variable {s N} in\n@[aesop safe]\nlemma mem_set_smul_of_mem_mem {r : S} {m : M} (mem1 : r ∈ s) (mem2 : m ∈ N) :\n    r • m ∈ s • N := by\n  rw [mem_set_smul_def, mem_sInf]\n  exact fun _ h => h mem1 mem2\n\n"}
{"name":"Submodule.set_smul_le","module":"Mathlib.Algebra.Module.Submodule.Pointwise","initialProofState":"R : Type u_2\nM : Type u_3\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nS : Type u_4\ninst✝¹ : Monoid S\ninst✝ : DistribMulAction S M\ns : Set S\nN p : Submodule R M\nclosed_under_smul : ∀ ⦃r : S⦄ ⦃n : M⦄, Membership.mem s r → Membership.mem N n → Membership.mem p (HSMul.hSMul r n)\n⊢ LE.le (HSMul.hSMul s N) p","decl":"lemma set_smul_le (p : Submodule R M)\n    (closed_under_smul : ∀ ⦃r : S⦄ ⦃n : M⦄, r ∈ s → n ∈ N → r • n ∈ p) :\n    s • N ≤ p :=\n  sInf_le closed_under_smul\n\n"}
{"name":"Submodule.set_smul_le_iff","module":"Mathlib.Algebra.Module.Submodule.Pointwise","initialProofState":"R : Type u_2\nM : Type u_3\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nS : Type u_4\ninst✝¹ : Monoid S\ninst✝ : DistribMulAction S M\ns : Set S\nN p : Submodule R M\n⊢ Iff (LE.le (HSMul.hSMul s N) p) (∀ ⦃r : S⦄ ⦃n : M⦄, Membership.mem s r → Membership.mem N n → Membership.mem p (HSMul.hSMul r n))","decl":"lemma set_smul_le_iff (p : Submodule R M) :\n    s • N ≤ p ↔\n    ∀ ⦃r : S⦄ ⦃n : M⦄, r ∈ s → n ∈ N → r • n ∈ p := by\n  fconstructor\n  · intro h r n hr hn\n    exact h <| mem_set_smul_of_mem_mem hr hn\n  · apply set_smul_le\n\n"}
{"name":"Submodule.set_smul_eq_of_le","module":"Mathlib.Algebra.Module.Submodule.Pointwise","initialProofState":"R : Type u_2\nM : Type u_3\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nS : Type u_4\ninst✝¹ : Monoid S\ninst✝ : DistribMulAction S M\ns : Set S\nN p : Submodule R M\nclosed_under_smul : ∀ ⦃r : S⦄ ⦃n : M⦄, Membership.mem s r → Membership.mem N n → Membership.mem p (HSMul.hSMul r n)\nle : LE.le p (HSMul.hSMul s N)\n⊢ Eq (HSMul.hSMul s N) p","decl":"lemma set_smul_eq_of_le (p : Submodule R M)\n    (closed_under_smul : ∀ ⦃r : S⦄ ⦃n : M⦄, r ∈ s → n ∈ N → r • n ∈ p)\n    (le : p ≤ s • N) :\n    s • N = p :=\n  le_antisymm (set_smul_le s N p closed_under_smul) le\n\n"}
{"name":"Submodule.instCovariantClassSetHSMulLe","module":"Mathlib.Algebra.Module.Submodule.Pointwise","initialProofState":"R : Type u_2\nM : Type u_3\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nS : Type u_4\ninst✝¹ : Monoid S\ninst✝ : DistribMulAction S M\n⊢ CovariantClass (Set S) (Submodule R M) HSMul.hSMul LE.le","decl":"instance : CovariantClass (Set S) (Submodule R M) HSMul.hSMul LE.le :=\n  ⟨fun _ _ _ le => set_smul_le _ _ _ fun _ _ hr hm => mem_set_smul_of_mem_mem (mem1 := hr)\n    (mem2 := le hm)⟩\n\n"}
{"name":"Submodule.set_smul_mono_left","module":"Mathlib.Algebra.Module.Submodule.Pointwise","initialProofState":"R : Type u_2\nM : Type u_3\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nS : Type u_4\ninst✝¹ : Monoid S\ninst✝ : DistribMulAction S M\nN : Submodule R M\ns t : Set S\nle : LE.le s t\n⊢ LE.le (HSMul.hSMul s N) (HSMul.hSMul t N)","decl":"lemma set_smul_mono_left {s t : Set S} (le : s ≤ t) :\n    s • N ≤ t • N :=\n  set_smul_le _ _ _ fun _ _ hr hm => mem_set_smul_of_mem_mem (mem1 := le hr)\n    (mem2 := hm)\n\n"}
{"name":"Submodule.set_smul_le_of_le_le","module":"Mathlib.Algebra.Module.Submodule.Pointwise","initialProofState":"R : Type u_2\nM : Type u_3\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nS : Type u_4\ninst✝¹ : Monoid S\ninst✝ : DistribMulAction S M\ns t : Set S\np q : Submodule R M\nle_set : LE.le s t\nle_submodule : LE.le p q\n⊢ LE.le (HSMul.hSMul s p) (HSMul.hSMul t q)","decl":"lemma set_smul_le_of_le_le {s t : Set S} {p q : Submodule R M}\n    (le_set : s ≤ t) (le_submodule : p ≤ q) : s • p ≤ t • q :=\n  le_trans (set_smul_mono_left _ le_set) <| smul_mono_right _ le_submodule\n\n"}
{"name":"Submodule.set_smul_eq_iSup","module":"Mathlib.Algebra.Module.Submodule.Pointwise","initialProofState":"R : Type u_2\nM : Type u_3\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nS : Type u_4\ninst✝² : Monoid S\ninst✝¹ : DistribMulAction S M\ninst✝ : SMulCommClass S R M\ns : Set S\nN : Submodule R M\n⊢ Eq (HSMul.hSMul s N) (iSup fun a => iSup fun h => HSMul.hSMul a N)","decl":"lemma set_smul_eq_iSup [SMulCommClass S R M] (s : Set S) (N : Submodule R M) :\n    s • N = ⨆ (a ∈ s), a • N := by\n  refine Eq.trans (congrArg sInf ?_) csInf_Ici\n  simp_rw [← Set.Ici_def, iSup_le_iff, @forall_comm M]\n  exact Set.ext fun _ => forall₂_congr (fun _ _ => Iff.symm map_le_iff_le_comap)\n\n"}
{"name":"Submodule.set_smul_span","module":"Mathlib.Algebra.Module.Submodule.Pointwise","initialProofState":"R : Type u_2\nM : Type u_3\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nS : Type u_4\ninst✝² : Monoid S\ninst✝¹ : DistribMulAction S M\ninst✝ : SMulCommClass S R M\ns : Set S\nt : Set M\n⊢ Eq (HSMul.hSMul s (Submodule.span R t)) (Submodule.span R (HSMul.hSMul s t))","decl":"theorem set_smul_span [SMulCommClass S R M] (s : Set S) (t : Set M) :\n    s • span R t = span R (s • t) := by\n  simp_rw [set_smul_eq_iSup, smul_span, iSup_span, Set.iUnion_smul_set]\n\n"}
{"name":"Submodule.span_set_smul","module":"Mathlib.Algebra.Module.Submodule.Pointwise","initialProofState":"R : Type u_2\nM : Type u_3\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nS : Type u_4\ninst✝² : Monoid S\ninst✝¹ : DistribMulAction S M\ninst✝ : SMulCommClass S R M\ns : Set S\nt : Set M\n⊢ Eq (Submodule.span R (HSMul.hSMul s t)) (HSMul.hSMul s (Submodule.span R t))","decl":"theorem span_set_smul [SMulCommClass S R M] (s : Set S) (t : Set M) :\n    span R (s • t) = s • span R t := (set_smul_span s t).symm\n\n"}
{"name":"Submodule.set_smul_inductionOn","module":"Mathlib.Algebra.Module.Submodule.Pointwise","initialProofState":"R : Type u_2\nM : Type u_3\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nS : Type u_4\ninst✝¹ : Monoid S\ninst✝ : DistribMulAction S M\ns : Set S\nN : Submodule R M\nmotive : (x : M) → Membership.mem (HSMul.hSMul s N) x → Prop\nx : M\nhx : Membership.mem (HSMul.hSMul s N) x\nsmul₀ : ∀ ⦃r : S⦄ ⦃n : M⦄ (mem₁ : Membership.mem s r) (mem₂ : Membership.mem N n), motive (HSMul.hSMul r n) ⋯\nsmul₁ : ∀ (r : R) ⦃m : M⦄ (mem : Membership.mem (HSMul.hSMul s N) m), motive m mem → motive (HSMul.hSMul r m) ⋯\nadd : ∀ ⦃m₁ m₂ : M⦄ (mem₁ : Membership.mem (HSMul.hSMul s N) m₁) (mem₂ : Membership.mem (HSMul.hSMul s N) m₂), motive m₁ mem₁ → motive m₂ mem₂ → motive (HAdd.hAdd m₁ m₂) ⋯\nzero : motive 0 ⋯\n⊢ motive x hx","decl":"variable {s N} in\n/--\nInduction principle for set acting on submodules. To prove `P` holds for all `s • N`, it is enough\nto prove:\n- for all `r ∈ s` and `n ∈ N`, `P (r • n)`;\n- for all `r` and `m ∈ s • N`, `P (r • n)`;\n- for all `m₁, m₂`, `P m₁` and `P m₂` implies `P (m₁ + m₂)`;\n- `P 0`.\n\nTo invoke this induction principle, use `induction x, hx using Submodule.set_smul_inductionOn` where\n`x : M` and `hx : x ∈ s • N`\n-/\n@[elab_as_elim]\nlemma set_smul_inductionOn {motive : (x : M) → (_ : x ∈ s • N) → Prop}\n    (x : M)\n    (hx : x ∈ s • N)\n    (smul₀ : ∀ ⦃r : S⦄ ⦃n : M⦄ (mem₁ : r ∈ s) (mem₂ : n ∈ N),\n      motive (r • n) (mem_set_smul_of_mem_mem mem₁ mem₂))\n    (smul₁ : ∀ (r : R) ⦃m : M⦄ (mem : m ∈ s • N) ,\n      motive m mem → motive (r • m) (Submodule.smul_mem _ r mem)) --\n    (add : ∀ ⦃m₁ m₂ : M⦄ (mem₁ : m₁ ∈ s • N) (mem₂ : m₂ ∈ s • N),\n      motive m₁ mem₁ → motive m₂ mem₂ → motive (m₁ + m₂) (Submodule.add_mem _ mem₁ mem₂))\n    (zero : motive 0 (Submodule.zero_mem _)) :\n    motive x hx :=\n  let ⟨_, h⟩ := set_smul_le s N\n    { carrier := { m | ∃ (mem : m ∈ s • N), motive m mem },\n      zero_mem' := ⟨Submodule.zero_mem _, zero⟩\n      add_mem' := fun ⟨mem, h⟩ ⟨mem', h'⟩ ↦ ⟨_, add mem mem' h h'⟩\n      smul_mem' := fun r _ ⟨mem, h⟩ ↦ ⟨_, smul₁ r mem h⟩ }\n    (fun _ _ mem mem' ↦ ⟨mem_set_smul_of_mem_mem mem mem', smul₀ mem mem'⟩) hx\n  h\n\n-- Implementation note: if `N` is both an `R`-submodule and `S`-submodule and `SMulCommClass R S M`,\n-- this lemma is also true for any `s : Set S`.\n"}
{"name":"Submodule.set_smul_eq_map","module":"Mathlib.Algebra.Module.Submodule.Pointwise","initialProofState":"R : Type u_2\nM : Type u_3\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\nsR : Set R\nN : Submodule R M\ninst✝ : SMulCommClass R R (Subtype fun x => Membership.mem N x)\n⊢ Eq (HSMul.hSMul sR N) (Submodule.map (N.subtype.comp ((Finsupp.lsum R) (DistribMulAction.toLinearMap R (Subtype fun x => Membership.mem N x)))) (Finsupp.supported (Subtype fun x => Membership.mem N x) R sR))","decl":"lemma set_smul_eq_map [SMulCommClass R R N] :\n    sR • N =\n    Submodule.map\n      (N.subtype.comp (Finsupp.lsum R <| DistribMulAction.toLinearMap _ _))\n      (Finsupp.supported N R sR) := by\n  classical\n  apply set_smul_eq_of_le\n  · intro r n hr hn\n    exact ⟨Finsupp.single r ⟨n, hn⟩, Finsupp.single_mem_supported _ _ hr, by simp⟩\n  · intro x hx\n    obtain ⟨c, hc, rfl⟩ := hx\n    simp only [LinearMap.coe_comp, coe_subtype, Finsupp.coe_lsum, Finsupp.sum, Function.comp_apply]\n    rw [AddSubmonoid.coe_finset_sum]\n    refine Submodule.sum_mem (p := sR • N) (t := c.support) ?_ _ ⟨sR • N, ?_⟩\n    · rintro r hr\n      rw [mem_set_smul_def, Submodule.mem_sInf]\n      rintro p hp\n      exact hp (hc hr) (c r).2\n    · ext x : 1\n      simp only [Set.mem_iInter, SetLike.mem_coe]\n      fconstructor\n      · refine fun h ↦ h fun r n hr hn ↦ ?_\n        rw [mem_set_smul_def, mem_sInf]\n        exact fun p hp ↦ hp hr hn\n      · aesop\n\n"}
{"name":"Submodule.mem_set_smul","module":"Mathlib.Algebra.Module.Submodule.Pointwise","initialProofState":"R : Type u_2\nM : Type u_3\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\nsR : Set R\nN : Submodule R M\nx : M\ninst✝ : SMulCommClass R R (Subtype fun x => Membership.mem N x)\n⊢ Iff (Membership.mem (HSMul.hSMul sR N) x) (Exists fun c => And (HasSubset.Subset (↑c.support) sR) (Eq x ↑(c.sum fun r m => HSMul.hSMul r m)))","decl":"lemma mem_set_smul (x : M) [SMulCommClass R R N] :\n    x ∈ sR • N ↔ ∃ (c : R →₀ N), (c.support : Set R) ⊆ sR ∧ x = c.sum fun r m ↦ r • m := by\n  fconstructor\n  · intros h\n    rw [set_smul_eq_map] at h\n    obtain ⟨c, hc, rfl⟩ := h\n    exact ⟨c, hc, rfl⟩\n  · rw [mem_set_smul_def, Submodule.mem_sInf]\n    rintro ⟨c, hc1, rfl⟩ p hp\n    rw [Finsupp.sum, AddSubmonoid.coe_finset_sum]\n    exact Submodule.sum_mem _ fun r hr ↦ hp (hc1 hr) (c _).2\n\n"}
{"name":"Submodule.empty_set_smul","module":"Mathlib.Algebra.Module.Submodule.Pointwise","initialProofState":"R : Type u_2\nM : Type u_3\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nS : Type u_4\ninst✝¹ : Monoid S\ninst✝ : DistribMulAction S M\nN : Submodule R M\n⊢ Eq (HSMul.hSMul EmptyCollection.emptyCollection N) Bot.bot","decl":"@[simp] lemma empty_set_smul : (∅ : Set S) • N = ⊥ := by\n  ext\n  fconstructor\n  · intro hx\n    rw [mem_set_smul_def, Submodule.mem_sInf] at hx\n    exact hx ⊥ (fun r _ hr ↦ hr.elim)\n  · rintro rfl; exact Submodule.zero_mem _\n\n"}
{"name":"Submodule.set_smul_bot","module":"Mathlib.Algebra.Module.Submodule.Pointwise","initialProofState":"R : Type u_2\nM : Type u_3\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nS : Type u_4\ninst✝¹ : Monoid S\ninst✝ : DistribMulAction S M\ns : Set S\n⊢ Eq (HSMul.hSMul s Bot.bot) Bot.bot","decl":"@[simp] lemma set_smul_bot : s • (⊥ : Submodule R M) = ⊥ :=\n  eq_bot_iff.mpr fun x hx ↦ by induction x, hx using set_smul_inductionOn <;> aesop\n\n"}
{"name":"Submodule.singleton_set_smul","module":"Mathlib.Algebra.Module.Submodule.Pointwise","initialProofState":"R : Type u_2\nM : Type u_3\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nS : Type u_4\ninst✝² : Monoid S\ninst✝¹ : DistribMulAction S M\nN : Submodule R M\ninst✝ : SMulCommClass S R M\nr : S\n⊢ Eq (HSMul.hSMul (Singleton.singleton r) N) (HSMul.hSMul r N)","decl":"lemma singleton_set_smul [SMulCommClass S R M] (r : S) : ({r} : Set S) • N = r • N := by\n  apply set_smul_eq_of_le\n  · rintro _ m rfl hm; exact ⟨m, hm, rfl⟩\n  · rintro _ ⟨m, hm, rfl⟩\n    rw [mem_set_smul_def, Submodule.mem_sInf]\n    intro _ hp; exact hp rfl hm\n\n"}
{"name":"Submodule.mem_singleton_set_smul","module":"Mathlib.Algebra.Module.Submodule.Pointwise","initialProofState":"R : Type u_2\nM : Type u_3\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nS : Type u_4\ninst✝² : Monoid S\ninst✝¹ : DistribMulAction S M\nN : Submodule R M\ninst✝ : SMulCommClass R S M\nr : S\nx : M\n⊢ Iff (Membership.mem (HSMul.hSMul (Singleton.singleton r) N) x) (Exists fun m => And (Membership.mem N m) (Eq x (HSMul.hSMul r m)))","decl":"lemma mem_singleton_set_smul [SMulCommClass R S M] (r : S) (x : M) :\n    x ∈ ({r} : Set S) • N ↔ ∃ (m : M), m ∈ N ∧ x = r • m := by\n  fconstructor\n  · intro hx\n    induction' x, hx using Submodule.set_smul_inductionOn with\n      t n memₜ memₙ t n mem h m₁ m₂ mem₁ mem₂ h₁ h₂\n    · aesop\n    · rcases h with ⟨n, hn, rfl⟩\n      exact ⟨t • n, by aesop,  smul_comm _ _ _⟩\n    · rcases h₁ with ⟨m₁, h₁, rfl⟩\n      rcases h₂ with ⟨m₂, h₂, rfl⟩\n      exact ⟨m₁ + m₂, Submodule.add_mem _ h₁ h₂, by simp⟩\n    · exact ⟨0, Submodule.zero_mem _, by simp⟩\n  · aesop\n\n"}
{"name":"Submodule.smul_inductionOn_pointwise","module":"Mathlib.Algebra.Module.Submodule.Pointwise","initialProofState":"R : Type u_2\nM : Type u_3\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nS : Type u_4\ninst✝² : Monoid S\ninst✝¹ : DistribMulAction S M\nN : Submodule R M\ninst✝ : SMulCommClass S R M\na : S\np : (x : M) → Membership.mem (HSMul.hSMul a N) x → Prop\nsmul₀ : ∀ (s : M) (hs : Membership.mem N s), p (HSMul.hSMul a s) ⋯\nsmul₁ : ∀ (r : R) (m : M) (mem : Membership.mem (HSMul.hSMul a N) m), p m mem → p (HSMul.hSMul r m) ⋯\nadd : ∀ (x y : M) (hx : Membership.mem (HSMul.hSMul a N) x) (hy : Membership.mem (HSMul.hSMul a N) y), p x hx → p y hy → p (HAdd.hAdd x y) ⋯\nzero : p 0 ⋯\nx : M\nhx : Membership.mem (HSMul.hSMul a N) x\n⊢ p x hx","decl":"lemma smul_inductionOn_pointwise [SMulCommClass S R M] {a : S} {p : (x : M) → x ∈ a • N → Prop}\n    (smul₀ : ∀ (s : M) (hs : s ∈ N), p (a • s) (Submodule.smul_mem_pointwise_smul _ _ _ hs))\n    (smul₁ : ∀ (r : R) (m : M) (mem : m ∈ a • N), p m mem → p (r • m) (Submodule.smul_mem _ _ mem))\n    (add : ∀ (x y : M) (hx : x ∈ a • N) (hy : y ∈ a • N),\n      p x hx → p y hy → p (x + y) (Submodule.add_mem _ hx hy))\n    (zero : p 0 (Submodule.zero_mem _)) {x : M} (hx : x ∈ a • N) :\n    p x hx := by\n  simp_all only [← Submodule.singleton_set_smul]\n  let p' (x : M) (hx : x ∈ ({a} : Set S) • N) : Prop :=\n    p x (by rwa [← Submodule.singleton_set_smul])\n  refine Submodule.set_smul_inductionOn (motive := p') _ (N.singleton_set_smul a ▸ hx)\n      (fun r n hr hn ↦ ?_) smul₁ add zero\n  · simp only [Set.mem_singleton_iff] at hr\n    subst hr\n    exact smul₀ n hn\n\n-- Note that this can't be generalized to `Set S`, because even though `SMulCommClass R R M` implies\n-- `SMulComm R R N` for all `R`-submodules `N`, `SMulCommClass R S N` for all `R`-submodules `N`\n-- does not make sense. If we just focus on `R`-submodules that are also `S`-submodule, then this\n-- should be true.\n"}
{"name":"Submodule.sup_set_smul","module":"Mathlib.Algebra.Module.Submodule.Pointwise","initialProofState":"R : Type u_2\nM : Type u_3\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nS : Type u_4\ninst✝¹ : Monoid S\ninst✝ : DistribMulAction S M\nN : Submodule R M\ns t : Set S\n⊢ Eq (HSMul.hSMul (Max.max s t) N) (Max.max (HSMul.hSMul s N) (HSMul.hSMul t N))","decl":"lemma sup_set_smul (s t : Set S) :\n    (s ⊔ t) • N = s • N ⊔ t • N :=\n  set_smul_eq_of_le _ _ _\n    (by rintro _ _ (hr|hr) hn\n        · exact Submodule.mem_sup_left (mem_set_smul_of_mem_mem hr hn)\n        · exact Submodule.mem_sup_right (mem_set_smul_of_mem_mem hr hn))\n    (sup_le (set_smul_mono_left _ le_sup_left) (set_smul_mono_left _ le_sup_right))\n\n"}
