{"name":"padicNorm.eq_zpow_of_nonzero","module":"Mathlib.NumberTheory.Padics.PadicNorm","initialProofState":"p : Nat\nq : Rat\nhq : Ne q 0\n⊢ Eq (padicNorm p q) (HPow.hPow (↑p) (Neg.neg (padicValRat p q)))","decl":"/-- Unfolds the definition of the `p`-adic norm of `q` when `q ≠ 0`. -/\n@[simp]\nprotected theorem eq_zpow_of_nonzero {q : ℚ} (hq : q ≠ 0) :\n    padicNorm p q = (p : ℚ) ^ (-padicValRat p q) := by simp [hq, padicNorm]\n\n"}
{"name":"padicNorm.nonneg","module":"Mathlib.NumberTheory.Padics.PadicNorm","initialProofState":"p : Nat\nq : Rat\n⊢ LE.le 0 (padicNorm p q)","decl":"/-- The `p`-adic norm is nonnegative. -/\nprotected theorem nonneg (q : ℚ) : 0 ≤ padicNorm p q :=\n  if hq : q = 0 then by simp [hq, padicNorm]\n  else by\n    unfold padicNorm\n    split_ifs\n    apply zpow_nonneg\n    exact mod_cast Nat.zero_le _\n\n"}
{"name":"padicNorm.zero","module":"Mathlib.NumberTheory.Padics.PadicNorm","initialProofState":"p : Nat\n⊢ Eq (padicNorm p 0) 0","decl":"/-- The `p`-adic norm of `0` is `0`. -/\n@[simp]\nprotected theorem zero : padicNorm p 0 = 0 := by simp [padicNorm]\n\n"}
{"name":"padicNorm.one","module":"Mathlib.NumberTheory.Padics.PadicNorm","initialProofState":"p : Nat\n⊢ Eq (padicNorm p 1) 1","decl":"/-- The `p`-adic norm of `1` is `1`. -/\nprotected theorem one : padicNorm p 1 = 1 := by simp [padicNorm]\n\n"}
{"name":"padicNorm.padicNorm_p","module":"Mathlib.NumberTheory.Padics.PadicNorm","initialProofState":"p : Nat\nhp : LT.lt 1 p\n⊢ Eq (padicNorm p ↑p) (Inv.inv ↑p)","decl":"/-- The `p`-adic norm of `p` is `p⁻¹` if `p > 1`.\n\nSee also `padicNorm.padicNorm_p_of_prime` for a version assuming `p` is prime. -/\ntheorem padicNorm_p (hp : 1 < p) : padicNorm p p = (p : ℚ)⁻¹ := by\n  simp [padicNorm, (pos_of_gt hp).ne', padicValNat.self hp]\n\n"}
{"name":"padicNorm.padicNorm_p_of_prime","module":"Mathlib.NumberTheory.Padics.PadicNorm","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\n⊢ Eq (padicNorm p ↑p) (Inv.inv ↑p)","decl":"/-- The `p`-adic norm of `p` is `p⁻¹` if `p` is prime.\n\nSee also `padicNorm.padicNorm_p` for a version assuming `1 < p`. -/\n@[simp]\ntheorem padicNorm_p_of_prime [Fact p.Prime] : padicNorm p p = (p : ℚ)⁻¹ :=\n  padicNorm_p <| Nat.Prime.one_lt Fact.out\n\n"}
{"name":"padicNorm.padicNorm_of_prime_of_ne","module":"Mathlib.NumberTheory.Padics.PadicNorm","initialProofState":"p q : Nat\np_prime : Fact (Nat.Prime p)\nq_prime : Fact (Nat.Prime q)\nneq : Ne p q\n⊢ Eq (padicNorm p ↑q) 1","decl":"/-- The `p`-adic norm of `q` is `1` if `q` is prime and not equal to `p`. -/\ntheorem padicNorm_of_prime_of_ne {q : ℕ} [p_prime : Fact p.Prime] [q_prime : Fact q.Prime]\n    (neq : p ≠ q) : padicNorm p q = 1 := by\n  have p : padicValRat p q = 0 := mod_cast padicValNat_primes neq\n  rw [padicNorm, p]\n  simp [q_prime.1.ne_zero]\n\n"}
{"name":"padicNorm.padicNorm_p_lt_one","module":"Mathlib.NumberTheory.Padics.PadicNorm","initialProofState":"p : Nat\nhp : LT.lt 1 p\n⊢ LT.lt (padicNorm p ↑p) 1","decl":"/-- The `p`-adic norm of `p` is less than `1` if `1 < p`.\n\nSee also `padicNorm.padicNorm_p_lt_one_of_prime` for a version assuming `p` is prime. -/\ntheorem padicNorm_p_lt_one (hp : 1 < p) : padicNorm p p < 1 := by\n  rw [padicNorm_p hp, inv_lt_one_iff₀]\n  exact mod_cast Or.inr hp\n\n"}
{"name":"padicNorm.padicNorm_p_lt_one_of_prime","module":"Mathlib.NumberTheory.Padics.PadicNorm","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\n⊢ LT.lt (padicNorm p ↑p) 1","decl":"/-- The `p`-adic norm of `p` is less than `1` if `p` is prime.\n\nSee also `padicNorm.padicNorm_p_lt_one` for a version assuming `1 < p`. -/\ntheorem padicNorm_p_lt_one_of_prime [Fact p.Prime] : padicNorm p p < 1 :=\n  padicNorm_p_lt_one <| Nat.Prime.one_lt Fact.out\n\n"}
{"name":"padicNorm.values_discrete","module":"Mathlib.NumberTheory.Padics.PadicNorm","initialProofState":"p : Nat\nq : Rat\nhq : Ne q 0\n⊢ Exists fun z => Eq (padicNorm p q) (HPow.hPow (↑p) (Neg.neg z))","decl":"/-- `padicNorm p q` takes discrete values `p ^ -z` for `z : ℤ`. -/\nprotected theorem values_discrete {q : ℚ} (hq : q ≠ 0) : ∃ z : ℤ, padicNorm p q = (p : ℚ) ^ (-z) :=\n  ⟨padicValRat p q, by simp [padicNorm, hq]⟩\n\n"}
{"name":"padicNorm.neg","module":"Mathlib.NumberTheory.Padics.PadicNorm","initialProofState":"p : Nat\nq : Rat\n⊢ Eq (padicNorm p (Neg.neg q)) (padicNorm p q)","decl":"/-- `padicNorm p` is symmetric. -/\n@[simp]\nprotected theorem neg (q : ℚ) : padicNorm p (-q) = padicNorm p q :=\n  if hq : q = 0 then by simp [hq] else by simp [padicNorm, hq]\n\n"}
{"name":"padicNorm.nonzero","module":"Mathlib.NumberTheory.Padics.PadicNorm","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nq : Rat\nhq : Ne q 0\n⊢ Ne (padicNorm p q) 0","decl":"/-- If `q ≠ 0`, then `padicNorm p q ≠ 0`. -/\nprotected theorem nonzero {q : ℚ} (hq : q ≠ 0) : padicNorm p q ≠ 0 := by\n  rw [padicNorm.eq_zpow_of_nonzero hq]\n  apply zpow_ne_zero\n  exact mod_cast ne_of_gt hp.1.pos\n\n"}
{"name":"padicNorm.zero_of_padicNorm_eq_zero","module":"Mathlib.NumberTheory.Padics.PadicNorm","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nq : Rat\nh : Eq (padicNorm p q) 0\n⊢ Eq q 0","decl":"/-- If the `p`-adic norm of `q` is 0, then `q` is `0`. -/\ntheorem zero_of_padicNorm_eq_zero {q : ℚ} (h : padicNorm p q = 0) : q = 0 := by\n  apply by_contradiction; intro hq\n  unfold padicNorm at h; rw [if_neg hq] at h\n  apply absurd h\n  apply zpow_ne_zero\n  exact mod_cast hp.1.ne_zero\n\n"}
{"name":"padicNorm.mul","module":"Mathlib.NumberTheory.Padics.PadicNorm","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nq r : Rat\n⊢ Eq (padicNorm p (HMul.hMul q r)) (HMul.hMul (padicNorm p q) (padicNorm p r))","decl":"/-- The `p`-adic norm is multiplicative. -/\n@[simp]\nprotected theorem mul (q r : ℚ) : padicNorm p (q * r) = padicNorm p q * padicNorm p r :=\n  if hq : q = 0 then by simp [hq]\n  else\n    if hr : r = 0 then by simp [hr]\n    else by\n      have : (p : ℚ) ≠ 0 := by simp [hp.1.ne_zero]\n      simp [padicNorm, *, padicValRat.mul, zpow_add₀ this, mul_comm]\n\n"}
{"name":"padicNorm.div","module":"Mathlib.NumberTheory.Padics.PadicNorm","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nq r : Rat\n⊢ Eq (padicNorm p (HDiv.hDiv q r)) (HDiv.hDiv (padicNorm p q) (padicNorm p r))","decl":"/-- The `p`-adic norm respects division. -/\n@[simp]\nprotected theorem div (q r : ℚ) : padicNorm p (q / r) = padicNorm p q / padicNorm p r :=\n  if hr : r = 0 then by simp [hr]\n  else eq_div_of_mul_eq (padicNorm.nonzero hr) (by rw [← padicNorm.mul, div_mul_cancel₀ _ hr])\n\n"}
{"name":"padicNorm.of_int","module":"Mathlib.NumberTheory.Padics.PadicNorm","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nz : Int\n⊢ LE.le (padicNorm p ↑z) 1","decl":"/-- The `p`-adic norm of an integer is at most `1`. -/\nprotected theorem of_int (z : ℤ) : padicNorm p z ≤ 1 := by\n  obtain rfl | hz := eq_or_ne z 0\n  · simp\n  · rw [padicNorm, if_neg (mod_cast hz)]\n    exact zpow_le_one_of_nonpos₀ (mod_cast hp.1.one_le) (by simp)\n\n"}
{"name":"padicNorm.nonarchimedean","module":"Mathlib.NumberTheory.Padics.PadicNorm","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nq r : Rat\n⊢ LE.le (padicNorm p (HAdd.hAdd q r)) (Max.max (padicNorm p q) (padicNorm p r))","decl":"/-- The `p`-adic norm is nonarchimedean: the norm of `p + q` is at most the max of the norm of `p`\nand the norm of `q`. -/\nprotected theorem nonarchimedean {q r : ℚ} :\n    padicNorm p (q + r) ≤ max (padicNorm p q) (padicNorm p r) := by\n  wlog hle : padicValRat p q ≤ padicValRat p r generalizing q r\n  · rw [add_comm, max_comm]\n    exact this (le_of_not_le hle)\n  exact nonarchimedean_aux hle\n\n"}
{"name":"padicNorm.triangle_ineq","module":"Mathlib.NumberTheory.Padics.PadicNorm","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nq r : Rat\n⊢ LE.le (padicNorm p (HAdd.hAdd q r)) (HAdd.hAdd (padicNorm p q) (padicNorm p r))","decl":"/-- The `p`-adic norm respects the triangle inequality: the norm of `p + q` is at most the norm of\n`p` plus the norm of `q`. -/\ntheorem triangle_ineq (q r : ℚ) : padicNorm p (q + r) ≤ padicNorm p q + padicNorm p r :=\n  calc\n    padicNorm p (q + r) ≤ max (padicNorm p q) (padicNorm p r) := padicNorm.nonarchimedean\n    _ ≤ padicNorm p q + padicNorm p r :=\n      max_le_add_of_nonneg (padicNorm.nonneg _) (padicNorm.nonneg _)\n\n"}
{"name":"padicNorm.sub","module":"Mathlib.NumberTheory.Padics.PadicNorm","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nq r : Rat\n⊢ LE.le (padicNorm p (HSub.hSub q r)) (Max.max (padicNorm p q) (padicNorm p r))","decl":"/-- The `p`-adic norm of a difference is at most the max of each component. Restates the archimedean\nproperty of the `p`-adic norm. -/\nprotected theorem sub {q r : ℚ} : padicNorm p (q - r) ≤ max (padicNorm p q) (padicNorm p r) := by\n  rw [sub_eq_add_neg, ← padicNorm.neg r]\n  exact padicNorm.nonarchimedean\n\n"}
{"name":"padicNorm.add_eq_max_of_ne","module":"Mathlib.NumberTheory.Padics.PadicNorm","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nq r : Rat\nhne : Ne (padicNorm p q) (padicNorm p r)\n⊢ Eq (padicNorm p (HAdd.hAdd q r)) (Max.max (padicNorm p q) (padicNorm p r))","decl":"/-- If the `p`-adic norms of `q` and `r` are different, then the norm of `q + r` is equal to the max\nof the norms of `q` and `r`. -/\ntheorem add_eq_max_of_ne {q r : ℚ} (hne : padicNorm p q ≠ padicNorm p r) :\n    padicNorm p (q + r) = max (padicNorm p q) (padicNorm p r) := by\n  wlog hlt : padicNorm p r < padicNorm p q\n  · rw [add_comm, max_comm]\n    exact this hne.symm (hne.lt_or_lt.resolve_right hlt)\n  have : padicNorm p q ≤ max (padicNorm p (q + r)) (padicNorm p r) :=\n    calc\n      padicNorm p q = padicNorm p (q + r + (-r)) := by ring_nf\n      _ ≤ max (padicNorm p (q + r)) (padicNorm p (-r)) := padicNorm.nonarchimedean\n      _ = max (padicNorm p (q + r)) (padicNorm p r) := by simp\n  have hnge : padicNorm p r ≤ padicNorm p (q + r) := by\n    apply le_of_not_gt\n    intro hgt\n    rw [max_eq_right_of_lt hgt] at this\n    exact not_lt_of_ge this hlt\n  have : padicNorm p q ≤ padicNorm p (q + r) := by rwa [max_eq_left hnge] at this\n  apply _root_.le_antisymm\n  · apply padicNorm.nonarchimedean\n  · rwa [max_eq_left_of_lt hlt]\n\n"}
{"name":"padicNorm.instIsAbsoluteValueRat","module":"Mathlib.NumberTheory.Padics.PadicNorm","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\n⊢ IsAbsoluteValue (padicNorm p)","decl":"/-- The `p`-adic norm is an absolute value: positive-definite and multiplicative, satisfying the\ntriangle inequality. -/\ninstance : IsAbsoluteValue (padicNorm p) where\n  abv_nonneg' := padicNorm.nonneg\n  abv_eq_zero' := ⟨zero_of_padicNorm_eq_zero, fun hx ↦ by simp [hx]⟩\n  abv_add' := padicNorm.triangle_ineq\n  abv_mul' := padicNorm.mul\n\n"}
{"name":"padicNorm.dvd_iff_norm_le","module":"Mathlib.NumberTheory.Padics.PadicNorm","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nn : Nat\nz : Int\n⊢ Iff (Dvd.dvd (↑(HPow.hPow p n)) z) (LE.le (padicNorm p ↑z) (HPow.hPow (↑p) (Neg.neg ↑n)))","decl":"theorem dvd_iff_norm_le {n : ℕ} {z : ℤ} : ↑(p ^ n) ∣ z ↔ padicNorm p z ≤ (p : ℚ) ^ (-n : ℤ) := by\n  unfold padicNorm; split_ifs with hz\n  · norm_cast at hz\n    simp [hz]\n  · rw [zpow_le_zpow_iff_right₀, neg_le_neg_iff, padicValRat.of_int,\n      padicValInt.of_ne_one_ne_zero hp.1.ne_one _]\n    · norm_cast\n      rw [← FiniteMultiplicity.pow_dvd_iff_le_multiplicity]\n      · norm_cast\n      · apply Int.finiteMultiplicity_iff.2 ⟨by simp [hp.out.ne_one], mod_cast hz⟩\n    · exact_mod_cast hz\n    · exact_mod_cast hp.out.one_lt\n\n"}
{"name":"padicNorm.int_eq_one_iff","module":"Mathlib.NumberTheory.Padics.PadicNorm","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nm : Int\n⊢ Iff (Eq (padicNorm p ↑m) 1) (Not (Dvd.dvd (↑p) m))","decl":"/-- The `p`-adic norm of an integer `m` is one iff `p` doesn't divide `m`. -/\ntheorem int_eq_one_iff (m : ℤ) : padicNorm p m = 1 ↔ ¬(p : ℤ) ∣ m := by\n  nth_rw 2 [← pow_one p]\n  simp only [dvd_iff_norm_le, Int.cast_natCast, Nat.cast_one, zpow_neg, zpow_one, not_le]\n  constructor\n  · intro h\n    rw [h, inv_lt_one₀] <;> norm_cast\n    · exact Nat.Prime.one_lt Fact.out\n    · exact Nat.Prime.pos Fact.out\n  · simp only [padicNorm]\n    split_ifs\n    · rw [inv_lt_zero, ← Nat.cast_zero, Nat.cast_lt]\n      intro h\n      exact (Nat.not_lt_zero p h).elim\n    · have : 1 < (p : ℚ) := by norm_cast; exact Nat.Prime.one_lt (Fact.out : Nat.Prime p)\n      rw [← zpow_neg_one, zpow_lt_zpow_iff_right₀ this]\n      have : 0 ≤ padicValRat p m := by simp only [of_int, Nat.cast_nonneg]\n      intro h\n      rw [← zpow_zero (p : ℚ), zpow_right_inj₀] <;> linarith\n\n"}
{"name":"padicNorm.int_lt_one_iff","module":"Mathlib.NumberTheory.Padics.PadicNorm","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nm : Int\n⊢ Iff (LT.lt (padicNorm p ↑m) 1) (Dvd.dvd (↑p) m)","decl":"theorem int_lt_one_iff (m : ℤ) : padicNorm p m < 1 ↔ (p : ℤ) ∣ m := by\n  rw [← not_iff_not, ← int_eq_one_iff, eq_iff_le_not_lt]\n  simp only [padicNorm.of_int, true_and]\n\n"}
{"name":"padicNorm.of_nat","module":"Mathlib.NumberTheory.Padics.PadicNorm","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nm : Nat\n⊢ LE.le (padicNorm p ↑m) 1","decl":"theorem of_nat (m : ℕ) : padicNorm p m ≤ 1 :=\n  padicNorm.of_int (m : ℤ)\n\n"}
{"name":"padicNorm.nat_eq_one_iff","module":"Mathlib.NumberTheory.Padics.PadicNorm","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nm : Nat\n⊢ Iff (Eq (padicNorm p ↑m) 1) (Not (Dvd.dvd p m))","decl":"/-- The `p`-adic norm of a natural `m` is one iff `p` doesn't divide `m`. -/\ntheorem nat_eq_one_iff (m : ℕ) : padicNorm p m = 1 ↔ ¬p ∣ m := by\n  rw [← Int.natCast_dvd_natCast, ← int_eq_one_iff, Int.cast_natCast]\n\n"}
{"name":"padicNorm.nat_lt_one_iff","module":"Mathlib.NumberTheory.Padics.PadicNorm","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nm : Nat\n⊢ Iff (LT.lt (padicNorm p ↑m) 1) (Dvd.dvd p m)","decl":"theorem nat_lt_one_iff (m : ℕ) : padicNorm p m < 1 ↔ p ∣ m := by\n  rw [← Int.natCast_dvd_natCast, ← int_lt_one_iff, Int.cast_natCast]\n\n"}
{"name":"padicNorm.not_int_of_not_padic_int","module":"Mathlib.NumberTheory.Padics.PadicNorm","initialProofState":"p : Nat\na : Rat\nhp : Fact (Nat.Prime p)\nH : LT.lt 1 (padicNorm p a)\n⊢ Not (Eq a.isInt Bool.true)","decl":"/-- If a rational is not a p-adic integer, it is not an integer. -/\ntheorem not_int_of_not_padic_int (p : ℕ) {a : ℚ} [hp : Fact (Nat.Prime p)]\n    (H : 1 < padicNorm p a) : ¬ a.isInt := by\n  contrapose! H\n  rw [Rat.eq_num_of_isInt H]\n  apply padicNorm.of_int\n\n"}
{"name":"padicNorm.sum_lt","module":"Mathlib.NumberTheory.Padics.PadicNorm","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nα : Type u_1\nF : α → Rat\nt : Rat\ns : Finset α\na✝¹ : s.Nonempty\na✝ : ∀ (i : α), Membership.mem s i → LT.lt (padicNorm p (F i)) t\n⊢ LT.lt (padicNorm p (s.sum fun i => F i)) t","decl":"theorem sum_lt {α : Type*} {F : α → ℚ} {t : ℚ} {s : Finset α} :\n    s.Nonempty → (∀ i ∈ s, padicNorm p (F i) < t) → padicNorm p (∑ i ∈ s, F i) < t := by\n  classical\n    refine s.induction_on (by rintro ⟨-, ⟨⟩⟩) ?_\n    rintro a S haS IH - ht\n    by_cases hs : S.Nonempty\n    · rw [Finset.sum_insert haS]\n      exact\n        lt_of_le_of_lt padicNorm.nonarchimedean\n          (max_lt (ht a (Finset.mem_insert_self a S))\n            (IH hs fun b hb ↦ ht b (Finset.mem_insert_of_mem hb)))\n    · simp_all\n\n"}
{"name":"padicNorm.sum_le","module":"Mathlib.NumberTheory.Padics.PadicNorm","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nα : Type u_1\nF : α → Rat\nt : Rat\ns : Finset α\na✝¹ : s.Nonempty\na✝ : ∀ (i : α), Membership.mem s i → LE.le (padicNorm p (F i)) t\n⊢ LE.le (padicNorm p (s.sum fun i => F i)) t","decl":"theorem sum_le {α : Type*} {F : α → ℚ} {t : ℚ} {s : Finset α} :\n    s.Nonempty → (∀ i ∈ s, padicNorm p (F i) ≤ t) → padicNorm p (∑ i ∈ s, F i) ≤ t := by\n  classical\n    refine s.induction_on (by rintro ⟨-, ⟨⟩⟩) ?_\n    rintro a S haS IH - ht\n    by_cases hs : S.Nonempty\n    · rw [Finset.sum_insert haS]\n      exact\n        padicNorm.nonarchimedean.trans\n          (max_le (ht a (Finset.mem_insert_self a S))\n            (IH hs fun b hb ↦ ht b (Finset.mem_insert_of_mem hb)))\n    · simp_all\n\n"}
{"name":"padicNorm.sum_lt'","module":"Mathlib.NumberTheory.Padics.PadicNorm","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nα : Type u_1\nF : α → Rat\nt : Rat\ns : Finset α\nhF : ∀ (i : α), Membership.mem s i → LT.lt (padicNorm p (F i)) t\nht : LT.lt 0 t\n⊢ LT.lt (padicNorm p (s.sum fun i => F i)) t","decl":"theorem sum_lt' {α : Type*} {F : α → ℚ} {t : ℚ} {s : Finset α}\n    (hF : ∀ i ∈ s, padicNorm p (F i) < t) (ht : 0 < t) : padicNorm p (∑ i ∈ s, F i) < t := by\n  obtain rfl | hs := Finset.eq_empty_or_nonempty s\n  · simp [ht]\n  · exact sum_lt hs hF\n\n"}
{"name":"padicNorm.sum_le'","module":"Mathlib.NumberTheory.Padics.PadicNorm","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nα : Type u_1\nF : α → Rat\nt : Rat\ns : Finset α\nhF : ∀ (i : α), Membership.mem s i → LE.le (padicNorm p (F i)) t\nht : LE.le 0 t\n⊢ LE.le (padicNorm p (s.sum fun i => F i)) t","decl":"theorem sum_le' {α : Type*} {F : α → ℚ} {t : ℚ} {s : Finset α}\n    (hF : ∀ i ∈ s, padicNorm p (F i) ≤ t) (ht : 0 ≤ t) : padicNorm p (∑ i ∈ s, F i) ≤ t := by\n  obtain rfl | hs := Finset.eq_empty_or_nonempty s\n  · simp [ht]\n  · exact sum_le hs hF\n\n"}
