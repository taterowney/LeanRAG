{"name":"MeasureTheory.AEStronglyMeasurable'.congr","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.AEMeasurable","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nm m0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : TopologicalSpace Œ≤\nf g : Œ± ‚Üí Œ≤\nhf : MeasureTheory.AEStronglyMeasurable f Œº\nhfg : (MeasureTheory.ae Œº).EventuallyEq f g\n‚ä¢ MeasureTheory.AEStronglyMeasurable g Œº","decl":"@[deprecated AEStronglyMeasurable.congr (since := \"2025-01-23\")]\ntheorem congr (hf : AEStronglyMeasurable[m] f Œº) (hfg : f =·µê[Œº] g) :\n    AEStronglyMeasurable[m] g Œº := AEStronglyMeasurable.congr hf hfg\n\n"}
{"name":"MeasureTheory.AEStronglyMeasurable'.mono","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.AEMeasurable","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nm m0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : TopologicalSpace Œ≤\nf : Œ± ‚Üí Œ≤\nm' : MeasurableSpace Œ±\nhf : MeasureTheory.AEStronglyMeasurable f Œº\nhm : LE.le m m'\n‚ä¢ MeasureTheory.AEStronglyMeasurable' m' f Œº","decl":"@[deprecated AEStronglyMeasurable.mono (since := \"2025-01-23\")]\ntheorem mono {m'} (hf : AEStronglyMeasurable[m] f Œº) (hm : m ‚â§ m') :\n    AEStronglyMeasurable' m' f Œº := AEStronglyMeasurable.mono hm hf\n\n"}
{"name":"MeasureTheory.AEStronglyMeasurable'.add","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.AEMeasurable","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nm m0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬≤ : TopologicalSpace Œ≤\nf g : Œ± ‚Üí Œ≤\ninst‚úù¬π : Add Œ≤\ninst‚úù : ContinuousAdd Œ≤\nhf : MeasureTheory.AEStronglyMeasurable f Œº\nhg : MeasureTheory.AEStronglyMeasurable g Œº\n‚ä¢ MeasureTheory.AEStronglyMeasurable (HAdd.hAdd f g) Œº","decl":"@[deprecated AEStronglyMeasurable.add (since := \"2025-01-23\")]\ntheorem add [Add Œ≤] [ContinuousAdd Œ≤] (hf : AEStronglyMeasurable[m] f Œº)\n    (hg : AEStronglyMeasurable[m] g Œº) : AEStronglyMeasurable[m] (f + g) Œº :=\n  AEStronglyMeasurable.add hf hg\n\n"}
{"name":"MeasureTheory.AEStronglyMeasurable'.neg","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.AEMeasurable","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nm m0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬≤ : TopologicalSpace Œ≤\ninst‚úù¬π : AddGroup Œ≤\ninst‚úù : TopologicalAddGroup Œ≤\nf : Œ± ‚Üí Œ≤\nhfm : MeasureTheory.AEStronglyMeasurable f Œº\n‚ä¢ MeasureTheory.AEStronglyMeasurable (Neg.neg f) Œº","decl":"@[deprecated AEStronglyMeasurable.neg (since := \"2025-01-23\")]\ntheorem neg [AddGroup Œ≤] [TopologicalAddGroup Œ≤] {f : Œ± ‚Üí Œ≤} (hfm : AEStronglyMeasurable[m] f Œº) :\n    AEStronglyMeasurable[m] (-f) Œº :=\n  AEStronglyMeasurable.neg hfm\n\n"}
{"name":"MeasureTheory.AEStronglyMeasurable'.sub","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.AEMeasurable","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nm m0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬≤ : TopologicalSpace Œ≤\ninst‚úù¬π : AddGroup Œ≤\ninst‚úù : TopologicalAddGroup Œ≤\nf g : Œ± ‚Üí Œ≤\nhfm : MeasureTheory.AEStronglyMeasurable f Œº\nhgm : MeasureTheory.AEStronglyMeasurable g Œº\n‚ä¢ MeasureTheory.AEStronglyMeasurable (HSub.hSub f g) Œº","decl":"@[deprecated AEStronglyMeasurable.sub (since := \"2025-01-23\")]\ntheorem sub [AddGroup Œ≤] [TopologicalAddGroup Œ≤] {f g : Œ± ‚Üí Œ≤} (hfm : AEStronglyMeasurable[m] f Œº)\n    (hgm : AEStronglyMeasurable[m] g Œº) : AEStronglyMeasurable[m] (f - g) Œº :=\n  AEStronglyMeasurable.sub hfm hgm\n\n"}
{"name":"MeasureTheory.AEStronglyMeasurable'.const_smul","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.AEMeasurable","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nùïú : Type u_3\nm m0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬≤ : TopologicalSpace Œ≤\nf : Œ± ‚Üí Œ≤\ninst‚úù¬π : SMul ùïú Œ≤\ninst‚úù : ContinuousConstSMul ùïú Œ≤\nc : ùïú\nhf : MeasureTheory.AEStronglyMeasurable f Œº\n‚ä¢ MeasureTheory.AEStronglyMeasurable (HSMul.hSMul c f) Œº","decl":"@[deprecated AEStronglyMeasurable.const_smul (since := \"2025-01-23\")]\ntheorem const_smul [SMul ùïú Œ≤] [ContinuousConstSMul ùïú Œ≤] (c : ùïú) (hf : AEStronglyMeasurable[m] f Œº) :\n    AEStronglyMeasurable[m] (c ‚Ä¢ f) Œº :=\n  AEStronglyMeasurable.const_smul hf _\n\n"}
{"name":"MeasureTheory.AEStronglyMeasurable'.const_inner","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.AEMeasurable","initialProofState":"Œ± : Type u_1\nm m0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nùïú : Type u_4\nŒ≤ : Type u_5\ninst‚úù¬≤ : RCLike ùïú\ninst‚úù¬π : NormedAddCommGroup Œ≤\ninst‚úù : InnerProductSpace ùïú Œ≤\nf : Œ± ‚Üí Œ≤\nhfm : MeasureTheory.AEStronglyMeasurable f Œº\nc : Œ≤\n‚ä¢ MeasureTheory.AEStronglyMeasurable (fun x => Inner.inner c (f x)) Œº","decl":"@[deprecated AEStronglyMeasurable.const_inner (since := \"2025-01-23\")]\ntheorem const_inner {ùïú Œ≤} [RCLike ùïú] [NormedAddCommGroup Œ≤] [InnerProductSpace ùïú Œ≤] {f : Œ± ‚Üí Œ≤}\n    (hfm : AEStronglyMeasurable[m] f Œº) (c : Œ≤) :\n    AEStronglyMeasurable[m] (fun x => (inner c (f x) : ùïú)) Œº :=\n  AEStronglyMeasurable.const_inner hfm\n\n"}
{"name":"MeasureTheory.AEStronglyMeasurable'.of_subsingleton","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.AEMeasurable","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nm m0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : TopologicalSpace Œ≤\nf : Œ± ‚Üí Œ≤\ninst‚úù : Subsingleton Œ≤\n‚ä¢ MeasureTheory.AEStronglyMeasurable f Œº","decl":"@[deprecated AEStronglyMeasurable.of_subsingleton_cod (since := \"2025-01-23\")]\ntheorem of_subsingleton [Subsingleton Œ≤] : AEStronglyMeasurable[m] f Œº := .of_subsingleton_cod\n\n"}
{"name":"MeasureTheory.AEStronglyMeasurable'.of_subsingleton'","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.AEMeasurable","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nm m0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : TopologicalSpace Œ≤\nf : Œ± ‚Üí Œ≤\ninst‚úù : Subsingleton Œ±\n‚ä¢ MeasureTheory.AEStronglyMeasurable f Œº","decl":"@[deprecated AEStronglyMeasurable.of_subsingleton_dom (since := \"2025-01-23\")]\ntheorem of_subsingleton' [Subsingleton Œ±] : AEStronglyMeasurable[m] f Œº := .of_subsingleton_dom\n\n"}
{"name":"MeasureTheory.AEStronglyMeasurable'.stronglyMeasurable_mk","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.AEMeasurable","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nm m0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : TopologicalSpace Œ≤\nf : Œ± ‚Üí Œ≤\nhfm : MeasureTheory.AEStronglyMeasurable f Œº\n‚ä¢ MeasureTheory.StronglyMeasurable (MeasureTheory.AEStronglyMeasurable.mk f hfm)","decl":"@[deprecated AEStronglyMeasurable.stronglyMeasurable_mk (since := \"2025-01-23\")]\ntheorem stronglyMeasurable_mk {f : Œ± ‚Üí Œ≤} (hfm : AEStronglyMeasurable[m] f Œº) :\n    StronglyMeasurable[m] (hfm.mk f) :=\n  AEStronglyMeasurable.stronglyMeasurable_mk hfm\n\n"}
{"name":"MeasureTheory.AEStronglyMeasurable'.ae_eq_mk","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.AEMeasurable","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nm m0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : TopologicalSpace Œ≤\nf : Œ± ‚Üí Œ≤\nhfm : MeasureTheory.AEStronglyMeasurable f Œº\n‚ä¢ (MeasureTheory.ae Œº).EventuallyEq f (MeasureTheory.AEStronglyMeasurable.mk f hfm)","decl":"@[deprecated AEStronglyMeasurable.ae_eq_mk (since := \"2025-01-23\")]\ntheorem ae_eq_mk {f : Œ± ‚Üí Œ≤} (hfm : AEStronglyMeasurable[m] f Œº) : f =·µê[Œº] hfm.mk f :=\n  AEStronglyMeasurable.ae_eq_mk hfm\n\n"}
{"name":"MeasureTheory.AEStronglyMeasurable'.continuous_comp","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.AEMeasurable","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nm m0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : TopologicalSpace Œ≤\nŒ≥ : Type u_4\ninst‚úù : TopologicalSpace Œ≥\nf : Œ± ‚Üí Œ≤\ng : Œ≤ ‚Üí Œ≥\nhg : Continuous g\nhf : MeasureTheory.AEStronglyMeasurable f Œº\n‚ä¢ MeasureTheory.AEStronglyMeasurable (Function.comp g f) Œº","decl":"@[deprecated Continuous.comp_aestronglyMeasurable (since := \"2025-01-23\")]\ntheorem continuous_comp {Œ≥} [TopologicalSpace Œ≥] {f : Œ± ‚Üí Œ≤} {g : Œ≤ ‚Üí Œ≥} (hg : Continuous g)\n    (hf : AEStronglyMeasurable[m] f Œº) : AEStronglyMeasurable[m] (g ‚àò f) Œº :=\n  hg.comp_aestronglyMeasurable hf\n\n"}
{"name":"MeasureTheory.aeStronglyMeasurable'_of_aeStronglyMeasurable'_trim","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.AEMeasurable","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nm m0 m0' : MeasurableSpace Œ±\ninst‚úù : TopologicalSpace Œ≤\nhm0 : LE.le m0 m0'\nŒº : MeasureTheory.Measure Œ±\nf : Œ± ‚Üí Œ≤\nhf : MeasureTheory.AEStronglyMeasurable f (Œº.trim hm0)\n‚ä¢ MeasureTheory.AEStronglyMeasurable f Œº","decl":"@[deprecated AEStronglyMeasurable.of_trim (since := \"2025-01-23\")]\ntheorem aeStronglyMeasurable'_of_aeStronglyMeasurable'_trim {Œ± Œ≤} {m m0 m0' : MeasurableSpace Œ±}\n    [TopologicalSpace Œ≤] (hm0 : m0 ‚â§ m0') {Œº : Measure Œ±} {f : Œ± ‚Üí Œ≤}\n    (hf : AEStronglyMeasurable[m] f (Œº.trim hm0)) : AEStronglyMeasurable[m] f Œº := .of_trim hm0 hf\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.aeStronglyMeasurable'","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.AEMeasurable","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nm x‚úù : MeasurableSpace Œ±\ninst‚úù : TopologicalSpace Œ≤\nŒº : MeasureTheory.Measure Œ±\nf : Œ± ‚Üí Œ≤\nhf : MeasureTheory.StronglyMeasurable f\n‚ä¢ MeasureTheory.AEStronglyMeasurable f Œº","decl":"@[deprecated StronglyMeasurable.aestronglyMeasurable (since := \"2025-01-23\")]\ntheorem StronglyMeasurable.aeStronglyMeasurable' {Œ± Œ≤} {m _ : MeasurableSpace Œ±}\n    [TopologicalSpace Œ≤] {Œº : Measure Œ±} {f : Œ± ‚Üí Œ≤} (hf : StronglyMeasurable[m] f) :\n    AEStronglyMeasurable[m] f Œº := hf.aestronglyMeasurable\n\n"}
{"name":"MeasureTheory.ae_eq_trim_iff_of_aeStronglyMeasurable'","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.AEMeasurable","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬π : TopologicalSpace Œ≤\ninst‚úù : TopologicalSpace.MetrizableSpace Œ≤\nm m0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf g : Œ± ‚Üí Œ≤\nhm : LE.le m m0\nhfm : MeasureTheory.AEStronglyMeasurable f Œº\nhgm : MeasureTheory.AEStronglyMeasurable g Œº\n‚ä¢ Iff ((MeasureTheory.ae (Œº.trim hm)).EventuallyEq (MeasureTheory.AEStronglyMeasurable.mk f hfm) (MeasureTheory.AEStronglyMeasurable.mk g hgm)) ((MeasureTheory.ae Œº).EventuallyEq f g)","decl":"theorem ae_eq_trim_iff_of_aeStronglyMeasurable' {Œ± Œ≤} [TopologicalSpace Œ≤] [MetrizableSpace Œ≤]\n    {m m0 : MeasurableSpace Œ±} {Œº : Measure Œ±} {f g : Œ± ‚Üí Œ≤} (hm : m ‚â§ m0)\n    (hfm : AEStronglyMeasurable[m] f Œº) (hgm : AEStronglyMeasurable[m] g Œº) :\n    hfm.mk f =·µê[Œº.trim hm] hgm.mk g ‚Üî f =·µê[Œº] g :=\n  (hfm.stronglyMeasurable_mk.ae_eq_trim_iff hm  hgm.stronglyMeasurable_mk).trans\n    ‚ü®fun h => hfm.ae_eq_mk.trans (h.trans hgm.ae_eq_mk.symm), fun h =>\n      hfm.ae_eq_mk.symm.trans (h.trans hgm.ae_eq_mk)‚ü©\n\n"}
{"name":"MeasureTheory.AEStronglyMeasurable.comp_ae_measurable'","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.AEMeasurable","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒ≥ : Type u_3\ninst‚úù : TopologicalSpace Œ≤\nmŒ± : MeasurableSpace Œ±\nx‚úù : MeasurableSpace Œ≥\nf : Œ± ‚Üí Œ≤\nŒº : MeasureTheory.Measure Œ≥\ng : Œ≥ ‚Üí Œ±\nhf : MeasureTheory.AEStronglyMeasurable f (MeasureTheory.Measure.map g Œº)\nhg : AEMeasurable g Œº\n‚ä¢ MeasureTheory.AEStronglyMeasurable' (MeasurableSpace.comap g mŒ±) (Function.comp f g) Œº","decl":"theorem AEStronglyMeasurable.comp_ae_measurable' {Œ± Œ≤ Œ≥ : Type*} [TopologicalSpace Œ≤]\n    {mŒ± : MeasurableSpace Œ±} {_ : MeasurableSpace Œ≥} {f : Œ± ‚Üí Œ≤} {Œº : Measure Œ≥} {g : Œ≥ ‚Üí Œ±}\n    (hf : AEStronglyMeasurable f (Œº.map g)) (hg : AEMeasurable g Œº) :\n    AEStronglyMeasurable' (mŒ±.comap g) (f ‚àò g) Œº :=\n  ‚ü®hf.mk f ‚àò g, hf.stronglyMeasurable_mk.comp_measurable (measurable_iff_comap_le.mpr le_rfl),\n    ae_eq_comp hg hf.ae_eq_mk‚ü©\n\n"}
{"name":"MeasureTheory.AEStronglyMeasurable'.aeStronglyMeasurable'_of_measurableSpace_le_on","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.AEMeasurable","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm m‚ÇÇ m0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : TopologicalSpace E\ninst‚úù : Zero E\nhm : LE.le m m0\ns : Set Œ±\nf : Œ± ‚Üí E\nhs_m : MeasurableSet s\nhs : ‚àÄ (t : Set Œ±), MeasurableSet (Inter.inter s t) ‚Üí MeasurableSet (Inter.inter s t)\nhf : MeasureTheory.AEStronglyMeasurable f Œº\nhf_zero : (MeasureTheory.ae (Œº.restrict (HasCompl.compl s))).EventuallyEq f 0\n‚ä¢ MeasureTheory.AEStronglyMeasurable' m‚ÇÇ f Œº","decl":"/-- If the restriction to a set `s` of a œÉ-algebra `m` is included in the restriction to `s` of\nanother œÉ-algebra `m‚ÇÇ` (hypothesis `hs`), the set `s` is `m` measurable and a function `f` almost\neverywhere supported on `s` is `m`-ae-strongly-measurable, then `f` is also\n`m‚ÇÇ`-ae-strongly-measurable. -/\n@[deprecated AEStronglyMeasurable.of_measurableSpace_le_on (since := \"2025-01-23\")]\ntheorem AEStronglyMeasurable'.aeStronglyMeasurable'_of_measurableSpace_le_on {Œ± E}\n    {m m‚ÇÇ m0 : MeasurableSpace Œ±} {Œº : Measure Œ±} [TopologicalSpace E] [Zero E] (hm : m ‚â§ m0)\n    {s : Set Œ±} {f : Œ± ‚Üí E} (hs_m : MeasurableSet[m] s)\n    (hs : ‚àÄ t, MeasurableSet[m] (s ‚à© t) ‚Üí MeasurableSet[m‚ÇÇ] (s ‚à© t))\n    (hf : AEStronglyMeasurable[m] f Œº) (hf_zero : f =·µê[Œº.restrict s·∂ú] 0) :\n    AEStronglyMeasurable' m‚ÇÇ f Œº :=\n  .of_measurableSpace_le_on hm hs_m hs hf hf_zero\n\n"}
{"name":"MeasureTheory.mem_lpMeasSubgroup_iff_aeStronglyMeasurable","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.AEMeasurable","initialProofState":"Œ± : Type u_1\nF : Type u_2\np : ENNReal\ninst‚úù : NormedAddCommGroup F\nm m0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp F p Œº) x\n‚ä¢ Iff (Membership.mem (MeasureTheory.lpMeasSubgroup F m p Œº) f) (MeasureTheory.AEStronglyMeasurable (‚Üë‚Üëf) Œº)","decl":"theorem mem_lpMeasSubgroup_iff_aeStronglyMeasurable {m m0 : MeasurableSpace Œ±} {Œº : Measure Œ±}\n    {f : Lp F p Œº} : f ‚àà lpMeasSubgroup F m p Œº ‚Üî AEStronglyMeasurable[m] f Œº := by\n  rw [‚Üê AddSubgroup.mem_carrier, lpMeasSubgroup, Set.mem_setOf_eq]\n\n"}
{"name":"MeasureTheory.mem_lpMeasSubgroup_iff_aeStronglyMeasurable'","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.AEMeasurable","initialProofState":"Œ± : Type u_1\nF : Type u_2\np : ENNReal\ninst‚úù : NormedAddCommGroup F\nm m0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp F p Œº) x\n‚ä¢ Iff (Membership.mem (MeasureTheory.lpMeasSubgroup F m p Œº) f) (MeasureTheory.AEStronglyMeasurable (‚Üë‚Üëf) Œº)","decl":"@[deprecated (since := \"2025-01-24\")]\nalias mem_lpMeasSubgroup_iff_aeStronglyMeasurable' := mem_lpMeasSubgroup_iff_aeStronglyMeasurable\n\n"}
{"name":"MeasureTheory.mem_lpMeas_iff_aeStronglyMeasurable","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.AEMeasurable","initialProofState":"Œ± : Type u_1\nF : Type u_2\nùïú : Type u_3\np : ENNReal\ninst‚úù¬≤ : RCLike ùïú\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú F\nm m0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp F p Œº) x\n‚ä¢ Iff (Membership.mem (MeasureTheory.lpMeas F ùïú m p Œº) f) (MeasureTheory.AEStronglyMeasurable (‚Üë‚Üëf) Œº)","decl":"theorem mem_lpMeas_iff_aeStronglyMeasurable {m m0 : MeasurableSpace Œ±} {Œº : Measure Œ±}\n    {f : Lp F p Œº} : f ‚àà lpMeas F ùïú m p Œº ‚Üî AEStronglyMeasurable[m] f Œº := by\n  rw [‚Üê SetLike.mem_coe, ‚Üê Submodule.mem_carrier, lpMeas, Set.mem_setOf_eq]\n\n"}
{"name":"MeasureTheory.mem_lpMeas_iff_aeStronglyMeasurable'","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.AEMeasurable","initialProofState":"Œ± : Type u_1\nF : Type u_2\nùïú : Type u_3\np : ENNReal\ninst‚úù¬≤ : RCLike ùïú\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú F\nm m0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp F p Œº) x\n‚ä¢ Iff (Membership.mem (MeasureTheory.lpMeas F ùïú m p Œº) f) (MeasureTheory.AEStronglyMeasurable (‚Üë‚Üëf) Œº)","decl":"@[deprecated (since := \"2025-01-24\")]\nalias mem_lpMeas_iff_aeStronglyMeasurable' := mem_lpMeas_iff_aeStronglyMeasurable\n\n"}
{"name":"MeasureTheory.lpMeas.aeStronglyMeasurable","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.AEMeasurable","initialProofState":"Œ± : Type u_1\nF : Type u_2\nùïú : Type u_3\np : ENNReal\ninst‚úù¬≤ : RCLike ùïú\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú F\nm x‚úù : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Subtype fun x => Membership.mem (MeasureTheory.lpMeas F ùïú m p Œº) x\n‚ä¢ MeasureTheory.AEStronglyMeasurable (‚Üë‚Üë‚Üëf) Œº","decl":"theorem lpMeas.aeStronglyMeasurable {m _ : MeasurableSpace Œ±} {Œº : Measure Œ±}\n    (f : lpMeas F ùïú m p Œº) : AEStronglyMeasurable[m] (f : Œ± ‚Üí F) Œº :=\n  mem_lpMeas_iff_aeStronglyMeasurable.mp f.mem\n\n"}
{"name":"MeasureTheory.lpMeas.aeStronglyMeasurable'","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.AEMeasurable","initialProofState":"Œ± : Type u_1\nF : Type u_2\nùïú : Type u_3\np : ENNReal\ninst‚úù¬≤ : RCLike ùïú\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú F\nm x‚úù : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Subtype fun x => Membership.mem (MeasureTheory.lpMeas F ùïú m p Œº) x\n‚ä¢ MeasureTheory.AEStronglyMeasurable (‚Üë‚Üë‚Üëf) Œº","decl":"@[deprecated (since := \"2025-01-24\")]\nalias lpMeas.aeStronglyMeasurable' := lpMeas.aeStronglyMeasurable\n\n"}
{"name":"MeasureTheory.mem_lpMeas_self","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.AEMeasurable","initialProofState":"Œ± : Type u_1\nF : Type u_2\nùïú : Type u_3\np : ENNReal\ninst‚úù¬≤ : RCLike ùïú\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú F\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp F p Œº) x\n‚ä¢ Membership.mem (MeasureTheory.lpMeas F ùïú m0 p Œº) f","decl":"theorem mem_lpMeas_self {m0 : MeasurableSpace Œ±} (Œº : Measure Œ±) (f : Lp F p Œº) :\n    f ‚àà lpMeas F ùïú m0 p Œº :=\n  mem_lpMeas_iff_aeStronglyMeasurable.mpr (Lp.aestronglyMeasurable f)\n\n"}
{"name":"MeasureTheory.lpMeasSubgroup_coe","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.AEMeasurable","initialProofState":"Œ± : Type u_1\nF : Type u_2\np : ENNReal\ninst‚úù : NormedAddCommGroup F\nm x‚úù : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Subtype fun x => Membership.mem (MeasureTheory.lpMeasSubgroup F m p Œº) x\n‚ä¢ Eq ‚Üë‚Üë‚Üëf ‚Üë‚Üë‚Üëf","decl":"theorem lpMeasSubgroup_coe {m _ : MeasurableSpace Œ±} {Œº : Measure Œ±} {f : lpMeasSubgroup F m p Œº} :\n    (f : _ ‚Üí _) = (f : Lp F p Œº) :=\n  rfl\n\n"}
{"name":"MeasureTheory.lpMeas_coe","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.AEMeasurable","initialProofState":"Œ± : Type u_1\nF : Type u_2\nùïú : Type u_3\np : ENNReal\ninst‚úù¬≤ : RCLike ùïú\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú F\nm x‚úù : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Subtype fun x => Membership.mem (MeasureTheory.lpMeas F ùïú m p Œº) x\n‚ä¢ Eq ‚Üë‚Üë‚Üëf ‚Üë‚Üë‚Üëf","decl":"theorem lpMeas_coe {m _ : MeasurableSpace Œ±} {Œº : Measure Œ±} {f : lpMeas F ùïú m p Œº} :\n    (f : _ ‚Üí _) = (f : Lp F p Œº) :=\n  rfl\n\n"}
{"name":"MeasureTheory.mem_lpMeas_indicatorConstLp","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.AEMeasurable","initialProofState":"Œ± : Type u_1\nF : Type u_2\nùïú : Type u_3\np : ENNReal\ninst‚úù¬≤ : RCLike ùïú\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú F\nm m0 : MeasurableSpace Œ±\nhm : LE.le m m0\nŒº : MeasureTheory.Measure Œ±\ns : Set Œ±\nhs : MeasurableSet s\nhŒºs : Ne (Œº s) Top.top\nc : F\n‚ä¢ Membership.mem (MeasureTheory.lpMeas F ùïú m p Œº) (MeasureTheory.indicatorConstLp p ‚ãØ hŒºs c)","decl":"theorem mem_lpMeas_indicatorConstLp {m m0 : MeasurableSpace Œ±} (hm : m ‚â§ m0) {Œº : Measure Œ±}\n    {s : Set Œ±} (hs : MeasurableSet[m] s) (hŒºs : Œº s ‚â† ‚àû) {c : F} :\n    indicatorConstLp p (hm s hs) hŒºs c ‚àà lpMeas F ùïú m p Œº :=\n  ‚ü®s.indicator fun _ : Œ± => c, (@stronglyMeasurable_const _ _ m _ _).indicator hs,\n    indicatorConstLp_coeFn‚ü©\n\n"}
{"name":"MeasureTheory.mem‚Ñíp_trim_of_mem_lpMeasSubgroup","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.AEMeasurable","initialProofState":"Œ± : Type u_1\nF : Type u_2\np : ENNReal\ninst‚úù : NormedAddCommGroup F\nm m0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nhm : LE.le m m0\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp F p Œº) x\nhf_meas : Membership.mem (MeasureTheory.lpMeasSubgroup F m p Œº) f\n‚ä¢ MeasureTheory.Mem‚Ñíp (Exists.choose ‚ãØ) p (Œº.trim hm)","decl":"/-- If `f` belongs to `lpMeasSubgroup F m p Œº`, then the measurable function it is almost\neverywhere equal to (given by `AEMeasurable.mk`) belongs to `‚Ñíp` for the measure `Œº.trim hm`. -/\ntheorem mem‚Ñíp_trim_of_mem_lpMeasSubgroup (hm : m ‚â§ m0) (f : Lp F p Œº)\n    (hf_meas : f ‚àà lpMeasSubgroup F m p Œº) :\n    Mem‚Ñíp (mem_lpMeasSubgroup_iff_aeStronglyMeasurable.mp hf_meas).choose p (Œº.trim hm) := by\n  have hf : AEStronglyMeasurable[m] f Œº :=\n    mem_lpMeasSubgroup_iff_aeStronglyMeasurable.mp hf_meas\n  let g := hf.choose\n  obtain ‚ü®hg, hfg‚ü© := hf.choose_spec\n  change Mem‚Ñíp g p (Œº.trim hm)\n  refine ‚ü®hg.aestronglyMeasurable, ?_‚ü©\n  have h_eLpNorm_fg : eLpNorm g p (Œº.trim hm) = eLpNorm f p Œº := by\n    rw [eLpNorm_trim hm hg]\n    exact eLpNorm_congr_ae hfg.symm\n  rw [h_eLpNorm_fg]\n  exact Lp.eLpNorm_lt_top f\n\n"}
{"name":"MeasureTheory.mem_lpMeasSubgroup_toLp_of_trim","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.AEMeasurable","initialProofState":"Œ± : Type u_1\nF : Type u_2\np : ENNReal\ninst‚úù : NormedAddCommGroup F\nm m0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nhm : LE.le m m0\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp F p (Œº.trim hm)) x\n‚ä¢ Membership.mem (MeasureTheory.lpMeasSubgroup F m p Œº) (MeasureTheory.Mem‚Ñíp.toLp ‚Üë‚Üëf ‚ãØ)","decl":"/-- If `f` belongs to `Lp` for the measure `Œº.trim hm`, then it belongs to the subgroup\n`lpMeasSubgroup F m p Œº`. -/\ntheorem mem_lpMeasSubgroup_toLp_of_trim (hm : m ‚â§ m0) (f : Lp F p (Œº.trim hm)) :\n    (mem‚Ñíp_of_mem‚Ñíp_trim hm (Lp.mem‚Ñíp f)).toLp f ‚àà lpMeasSubgroup F m p Œº := by\n  let hf_mem_‚Ñíp := mem‚Ñíp_of_mem‚Ñíp_trim hm (Lp.mem‚Ñíp f)\n  rw [mem_lpMeasSubgroup_iff_aeStronglyMeasurable]\n  refine AEStronglyMeasurable'.congr ?_ (Mem‚Ñíp.coeFn_toLp hf_mem_‚Ñíp).symm\n  refine aeStronglyMeasurable'_of_aeStronglyMeasurable'_trim hm ?_\n  exact Lp.aestronglyMeasurable f\n\n"}
{"name":"MeasureTheory.lpMeasSubgroupToLpTrim_ae_eq","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.AEMeasurable","initialProofState":"Œ± : Type u_1\nF : Type u_2\np : ENNReal\ninst‚úù : NormedAddCommGroup F\nm m0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nhm : LE.le m m0\nf : Subtype fun x => Membership.mem (MeasureTheory.lpMeasSubgroup F m p Œº) x\n‚ä¢ (MeasureTheory.ae Œº).EventuallyEq ‚Üë‚Üë(MeasureTheory.lpMeasSubgroupToLpTrim F p Œº hm f) ‚Üë‚Üë‚Üëf","decl":"theorem lpMeasSubgroupToLpTrim_ae_eq (hm : m ‚â§ m0) (f : lpMeasSubgroup F m p Œº) :\n    lpMeasSubgroupToLpTrim F p Œº hm f =·µê[Œº] f :=\n  -- Porting note: replaced `(‚Üëf)` with `f.1` here.\n  (ae_eq_of_ae_eq_trim (Mem‚Ñíp.coeFn_toLp (mem‚Ñíp_trim_of_mem_lpMeasSubgroup hm f.1 f.mem))).trans\n    (mem_lpMeasSubgroup_iff_aeStronglyMeasurable.mp f.mem).choose_spec.2.symm\n\n"}
{"name":"MeasureTheory.lpTrimToLpMeasSubgroup_ae_eq","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.AEMeasurable","initialProofState":"Œ± : Type u_1\nF : Type u_2\np : ENNReal\ninst‚úù : NormedAddCommGroup F\nm m0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nhm : LE.le m m0\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp F p (Œº.trim hm)) x\n‚ä¢ (MeasureTheory.ae Œº).EventuallyEq ‚Üë‚Üë‚Üë(MeasureTheory.lpTrimToLpMeasSubgroup F p Œº hm f) ‚Üë‚Üëf","decl":"theorem lpTrimToLpMeasSubgroup_ae_eq (hm : m ‚â§ m0) (f : Lp F p (Œº.trim hm)) :\n    lpTrimToLpMeasSubgroup F p Œº hm f =·µê[Œº] f :=\n  -- Porting note: filled in the argument\n  Mem‚Ñíp.coeFn_toLp (mem‚Ñíp_of_mem‚Ñíp_trim hm (Lp.mem‚Ñíp f))\n\n"}
{"name":"MeasureTheory.lpMeasToLpTrim_ae_eq","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.AEMeasurable","initialProofState":"Œ± : Type u_1\nF : Type u_2\nùïú : Type u_3\np : ENNReal\ninst‚úù¬≤ : RCLike ùïú\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú F\nm m0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nhm : LE.le m m0\nf : Subtype fun x => Membership.mem (MeasureTheory.lpMeas F ùïú m p Œº) x\n‚ä¢ (MeasureTheory.ae Œº).EventuallyEq ‚Üë‚Üë(MeasureTheory.lpMeasToLpTrim F ùïú p Œº hm f) ‚Üë‚Üë‚Üëf","decl":"theorem lpMeasToLpTrim_ae_eq (hm : m ‚â§ m0) (f : lpMeas F ùïú m p Œº) :\n    lpMeasToLpTrim F ùïú p Œº hm f =·µê[Œº] f :=\n  -- Porting note: replaced `(‚Üëf)` with `f.1` here.\n  (ae_eq_of_ae_eq_trim (Mem‚Ñíp.coeFn_toLp (mem‚Ñíp_trim_of_mem_lpMeasSubgroup hm f.1 f.mem))).trans\n    (mem_lpMeasSubgroup_iff_aeStronglyMeasurable.mp f.mem).choose_spec.2.symm\n\n"}
{"name":"MeasureTheory.lpTrimToLpMeas_ae_eq","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.AEMeasurable","initialProofState":"Œ± : Type u_1\nF : Type u_2\nùïú : Type u_3\np : ENNReal\ninst‚úù¬≤ : RCLike ùïú\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú F\nm m0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nhm : LE.le m m0\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp F p (Œº.trim hm)) x\n‚ä¢ (MeasureTheory.ae Œº).EventuallyEq ‚Üë‚Üë‚Üë(MeasureTheory.lpTrimToLpMeas F ùïú p Œº hm f) ‚Üë‚Üëf","decl":"theorem lpTrimToLpMeas_ae_eq (hm : m ‚â§ m0) (f : Lp F p (Œº.trim hm)) :\n    lpTrimToLpMeas F ùïú p Œº hm f =·µê[Œº] f :=\n  -- Porting note: filled in the argument\n  Mem‚Ñíp.coeFn_toLp (mem‚Ñíp_of_mem‚Ñíp_trim hm (Lp.mem‚Ñíp f))\n\n"}
{"name":"MeasureTheory.lpMeasSubgroupToLpTrim_right_inv","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.AEMeasurable","initialProofState":"Œ± : Type u_1\nF : Type u_2\np : ENNReal\ninst‚úù : NormedAddCommGroup F\nm m0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nhm : LE.le m m0\n‚ä¢ Function.RightInverse (MeasureTheory.lpTrimToLpMeasSubgroup F p Œº hm) (MeasureTheory.lpMeasSubgroupToLpTrim F p Œº hm)","decl":"/-- `lpTrimToLpMeasSubgroup` is a right inverse of `lpMeasSubgroupToLpTrim`. -/\ntheorem lpMeasSubgroupToLpTrim_right_inv (hm : m ‚â§ m0) :\n    Function.RightInverse (lpTrimToLpMeasSubgroup F p Œº hm) (lpMeasSubgroupToLpTrim F p Œº hm) := by\n  intro f\n  ext1\n  refine\n    (Lp.stronglyMeasurable _).ae_eq_trim_of_stronglyMeasurable hm (Lp.stronglyMeasurable _) ?_\n  exact (lpMeasSubgroupToLpTrim_ae_eq hm _).trans (lpTrimToLpMeasSubgroup_ae_eq hm _)\n\n"}
{"name":"MeasureTheory.lpMeasSubgroupToLpTrim_left_inv","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.AEMeasurable","initialProofState":"Œ± : Type u_1\nF : Type u_2\np : ENNReal\ninst‚úù : NormedAddCommGroup F\nm m0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nhm : LE.le m m0\n‚ä¢ Function.LeftInverse (MeasureTheory.lpTrimToLpMeasSubgroup F p Œº hm) (MeasureTheory.lpMeasSubgroupToLpTrim F p Œº hm)","decl":"/-- `lpTrimToLpMeasSubgroup` is a left inverse of `lpMeasSubgroupToLpTrim`. -/\ntheorem lpMeasSubgroupToLpTrim_left_inv (hm : m ‚â§ m0) :\n    Function.LeftInverse (lpTrimToLpMeasSubgroup F p Œº hm) (lpMeasSubgroupToLpTrim F p Œº hm) := by\n  intro f\n  ext1\n  ext1\n  rw [‚Üê lpMeasSubgroup_coe]\n  exact (lpTrimToLpMeasSubgroup_ae_eq hm _).trans (lpMeasSubgroupToLpTrim_ae_eq hm _)\n\n"}
{"name":"MeasureTheory.lpMeasSubgroupToLpTrim_add","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.AEMeasurable","initialProofState":"Œ± : Type u_1\nF : Type u_2\np : ENNReal\ninst‚úù : NormedAddCommGroup F\nm m0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nhm : LE.le m m0\nf g : Subtype fun x => Membership.mem (MeasureTheory.lpMeasSubgroup F m p Œº) x\n‚ä¢ Eq (MeasureTheory.lpMeasSubgroupToLpTrim F p Œº hm (HAdd.hAdd f g)) (HAdd.hAdd (MeasureTheory.lpMeasSubgroupToLpTrim F p Œº hm f) (MeasureTheory.lpMeasSubgroupToLpTrim F p Œº hm g))","decl":"theorem lpMeasSubgroupToLpTrim_add (hm : m ‚â§ m0) (f g : lpMeasSubgroup F m p Œº) :\n    lpMeasSubgroupToLpTrim F p Œº hm (f + g) =\n      lpMeasSubgroupToLpTrim F p Œº hm f + lpMeasSubgroupToLpTrim F p Œº hm g := by\n  ext1\n  refine EventuallyEq.trans ?_ (Lp.coeFn_add _ _).symm\n  refine (Lp.stronglyMeasurable _).ae_eq_trim_of_stronglyMeasurable hm  ?_ ?_\n  ¬∑ exact (Lp.stronglyMeasurable _).add (Lp.stronglyMeasurable _)\n  refine (lpMeasSubgroupToLpTrim_ae_eq hm _).trans ?_\n  refine\n    EventuallyEq.trans ?_\n      (EventuallyEq.add (lpMeasSubgroupToLpTrim_ae_eq hm f).symm\n        (lpMeasSubgroupToLpTrim_ae_eq hm g).symm)\n  refine (Lp.coeFn_add _ _).trans ?_\n  simp_rw [lpMeasSubgroup_coe]\n  filter_upwards with x using rfl\n\n"}
{"name":"MeasureTheory.lpMeasSubgroupToLpTrim_neg","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.AEMeasurable","initialProofState":"Œ± : Type u_1\nF : Type u_2\np : ENNReal\ninst‚úù : NormedAddCommGroup F\nm m0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nhm : LE.le m m0\nf : Subtype fun x => Membership.mem (MeasureTheory.lpMeasSubgroup F m p Œº) x\n‚ä¢ Eq (MeasureTheory.lpMeasSubgroupToLpTrim F p Œº hm (Neg.neg f)) (Neg.neg (MeasureTheory.lpMeasSubgroupToLpTrim F p Œº hm f))","decl":"theorem lpMeasSubgroupToLpTrim_neg (hm : m ‚â§ m0) (f : lpMeasSubgroup F m p Œº) :\n    lpMeasSubgroupToLpTrim F p Œº hm (-f) = -lpMeasSubgroupToLpTrim F p Œº hm f := by\n  ext1\n  refine EventuallyEq.trans ?_ (Lp.coeFn_neg _).symm\n  refine (Lp.stronglyMeasurable _).ae_eq_trim_of_stronglyMeasurable hm (Lp.stronglyMeasurable _).neg\n    <| (lpMeasSubgroupToLpTrim_ae_eq hm _).trans <|\n    ((Lp.coeFn_neg _).trans ?_).trans  (lpMeasSubgroupToLpTrim_ae_eq hm f).symm.neg\n  simp_rw [lpMeasSubgroup_coe]\n  exact Eventually.of_forall fun x => by rfl\n\n"}
{"name":"MeasureTheory.lpMeasSubgroupToLpTrim_sub","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.AEMeasurable","initialProofState":"Œ± : Type u_1\nF : Type u_2\np : ENNReal\ninst‚úù : NormedAddCommGroup F\nm m0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nhm : LE.le m m0\nf g : Subtype fun x => Membership.mem (MeasureTheory.lpMeasSubgroup F m p Œº) x\n‚ä¢ Eq (MeasureTheory.lpMeasSubgroupToLpTrim F p Œº hm (HSub.hSub f g)) (HSub.hSub (MeasureTheory.lpMeasSubgroupToLpTrim F p Œº hm f) (MeasureTheory.lpMeasSubgroupToLpTrim F p Œº hm g))","decl":"theorem lpMeasSubgroupToLpTrim_sub (hm : m ‚â§ m0) (f g : lpMeasSubgroup F m p Œº) :\n    lpMeasSubgroupToLpTrim F p Œº hm (f - g) =\n      lpMeasSubgroupToLpTrim F p Œº hm f - lpMeasSubgroupToLpTrim F p Œº hm g := by\n  rw [sub_eq_add_neg, sub_eq_add_neg, lpMeasSubgroupToLpTrim_add,\n    lpMeasSubgroupToLpTrim_neg]\n\n"}
{"name":"MeasureTheory.lpMeasToLpTrim_smul","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.AEMeasurable","initialProofState":"Œ± : Type u_1\nF : Type u_2\nùïú : Type u_3\np : ENNReal\ninst‚úù¬≤ : RCLike ùïú\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú F\nm m0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nhm : LE.le m m0\nc : ùïú\nf : Subtype fun x => Membership.mem (MeasureTheory.lpMeas F ùïú m p Œº) x\n‚ä¢ Eq (MeasureTheory.lpMeasToLpTrim F ùïú p Œº hm (HSMul.hSMul c f)) (HSMul.hSMul c (MeasureTheory.lpMeasToLpTrim F ùïú p Œº hm f))","decl":"theorem lpMeasToLpTrim_smul (hm : m ‚â§ m0) (c : ùïú) (f : lpMeas F ùïú m p Œº) :\n    lpMeasToLpTrim F ùïú p Œº hm (c ‚Ä¢ f) = c ‚Ä¢ lpMeasToLpTrim F ùïú p Œº hm f := by\n  ext1\n  refine EventuallyEq.trans ?_ (Lp.coeFn_smul _ _).symm\n  refine (Lp.stronglyMeasurable _).ae_eq_trim_of_stronglyMeasurable hm ?_ ?_\n  ¬∑ exact (Lp.stronglyMeasurable _).const_smul c\n  refine (lpMeasToLpTrim_ae_eq hm _).trans ?_\n  refine (Lp.coeFn_smul _ _).trans ?_\n  refine (lpMeasToLpTrim_ae_eq hm f).mono fun x hx => ?_\n  simp only [Pi.smul_apply, hx]\n\n"}
{"name":"MeasureTheory.lpMeasSubgroupToLpTrim_norm_map","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.AEMeasurable","initialProofState":"Œ± : Type u_1\nF : Type u_2\np : ENNReal\ninst‚úù : NormedAddCommGroup F\nm m0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nhp : Fact (LE.le 1 p)\nhm : LE.le m m0\nf : Subtype fun x => Membership.mem (MeasureTheory.lpMeasSubgroup F m p Œº) x\n‚ä¢ Eq (Norm.norm (MeasureTheory.lpMeasSubgroupToLpTrim F p Œº hm f)) (Norm.norm f)","decl":"/-- `lpMeasSubgroupToLpTrim` preserves the norm. -/\ntheorem lpMeasSubgroupToLpTrim_norm_map [hp : Fact (1 ‚â§ p)] (hm : m ‚â§ m0)\n    (f : lpMeasSubgroup F m p Œº) : ‚ÄñlpMeasSubgroupToLpTrim F p Œº hm f‚Äñ = ‚Äñf‚Äñ := by\n  rw [Lp.norm_def, eLpNorm_trim hm (Lp.stronglyMeasurable _),\n    eLpNorm_congr_ae (lpMeasSubgroupToLpTrim_ae_eq hm _), lpMeasSubgroup_coe, ‚Üê Lp.norm_def]\n  congr\n\n"}
{"name":"MeasureTheory.isometry_lpMeasSubgroupToLpTrim","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.AEMeasurable","initialProofState":"Œ± : Type u_1\nF : Type u_2\np : ENNReal\ninst‚úù : NormedAddCommGroup F\nm m0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nhp : Fact (LE.le 1 p)\nhm : LE.le m m0\n‚ä¢ Isometry (MeasureTheory.lpMeasSubgroupToLpTrim F p Œº hm)","decl":"theorem isometry_lpMeasSubgroupToLpTrim [hp : Fact (1 ‚â§ p)] (hm : m ‚â§ m0) :\n    Isometry (lpMeasSubgroupToLpTrim F p Œº hm) :=\n  Isometry.of_dist_eq fun f g => by\n    rw [dist_eq_norm, ‚Üê lpMeasSubgroupToLpTrim_sub, lpMeasSubgroupToLpTrim_norm_map,\n      dist_eq_norm]\n\n"}
{"name":"MeasureTheory.instCompleteSpaceSubtypeAEEqFunMemAddSubgroupLpLpMeasSubgroupOfFactLeMeasurableSpace","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.AEMeasurable","initialProofState":"Œ± : Type u_1\nF : Type u_2\np : ENNReal\ninst‚úù¬π : NormedAddCommGroup F\nm m0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nhm : Fact (LE.le m m0)\ninst‚úù : CompleteSpace F\nhp : Fact (LE.le 1 p)\n‚ä¢ CompleteSpace (Subtype fun x => Membership.mem (MeasureTheory.lpMeasSubgroup F m p Œº) x)","decl":"instance [hm : Fact (m ‚â§ m0)] [CompleteSpace F] [hp : Fact (1 ‚â§ p)] :\n    CompleteSpace (lpMeasSubgroup F m p Œº) := by\n  rw [(lpMeasSubgroupToLpTrimIso F p Œº hm.elim).completeSpace_iff]; infer_instance\n\n-- For now just no-lint this; lean4's tree-based logging will make this easier to debug.\n-- One possible change might be to generalize `ùïú` from `RCLike` to `NormedField`, as this\n-- result may well hold there.\n-- Porting note: removed @[nolint fails_quickly]\n"}
{"name":"MeasureTheory.instCompleteSpaceSubtypeAEEqFunMemAddSubgroupLpSubmoduleLpMeasOfFactLeMeasurableSpace","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.AEMeasurable","initialProofState":"Œ± : Type u_1\nF : Type u_2\nùïú : Type u_3\np : ENNReal\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace ùïú F\nm m0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nhm : Fact (LE.le m m0)\ninst‚úù : CompleteSpace F\nhp : Fact (LE.le 1 p)\n‚ä¢ CompleteSpace (Subtype fun x => Membership.mem (MeasureTheory.lpMeas F ùïú m p Œº) x)","decl":"instance [hm : Fact (m ‚â§ m0)] [CompleteSpace F] [hp : Fact (1 ‚â§ p)] :\n    CompleteSpace (lpMeas F ùïú m p Œº) := by\n  rw [(lpMeasSubgroupToLpMeasIso F ùïú p Œº).symm.completeSpace_iff]; infer_instance\n\n"}
{"name":"MeasureTheory.isComplete_aeStronglyMeasurable'","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.AEMeasurable","initialProofState":"Œ± : Type u_1\nF : Type u_2\np : ENNReal\ninst‚úù¬π : NormedAddCommGroup F\nm m0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nhp : Fact (LE.le 1 p)\ninst‚úù : CompleteSpace F\nhm : LE.le m m0\n‚ä¢ IsComplete (setOf fun f => MeasureTheory.AEStronglyMeasurable (‚Üë‚Üëf) Œº)","decl":"theorem isComplete_aeStronglyMeasurable' [hp : Fact (1 ‚â§ p)] [CompleteSpace F] (hm : m ‚â§ m0) :\n    IsComplete {f : Lp F p Œº | AEStronglyMeasurable[m] f Œº} := by\n  rw [‚Üê completeSpace_coe_iff_isComplete]\n  haveI : Fact (m ‚â§ m0) := ‚ü®hm‚ü©\n  change CompleteSpace (lpMeasSubgroup F m p Œº)\n  infer_instance\n\n"}
{"name":"MeasureTheory.isClosed_aeStronglyMeasurable'","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.AEMeasurable","initialProofState":"Œ± : Type u_1\nF : Type u_2\np : ENNReal\ninst‚úù¬≤ : NormedAddCommGroup F\nm m0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : Fact (LE.le 1 p)\ninst‚úù : CompleteSpace F\nhm : LE.le m m0\n‚ä¢ IsClosed (setOf fun f => MeasureTheory.AEStronglyMeasurable (‚Üë‚Üëf) Œº)","decl":"theorem isClosed_aeStronglyMeasurable' [Fact (1 ‚â§ p)] [CompleteSpace F] (hm : m ‚â§ m0) :\n    IsClosed {f : Lp F p Œº | AEStronglyMeasurable[m] f Œº} :=\n  IsComplete.isClosed (isComplete_aeStronglyMeasurable' hm)\n\n"}
{"name":"MeasureTheory.lpMeas.ae_fin_strongly_measurable'","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.AEMeasurable","initialProofState":"Œ± : Type u_1\nF : Type u_2\nùïú : Type u_3\np : ENNReal\ninst‚úù¬≤ : RCLike ùïú\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú F\nm m0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nhm : LE.le m m0\nf : Subtype fun x => Membership.mem (MeasureTheory.lpMeas F ùïú m p Œº) x\nhp_ne_zero : Ne p 0\nhp_ne_top : Ne p Top.top\n‚ä¢ Exists fun g => And (MeasureTheory.FinStronglyMeasurable g (Œº.trim hm)) ((MeasureTheory.ae Œº).EventuallyEq (‚Üë‚Üë‚Üëf) g)","decl":"/-- We do not get `ae_fin_strongly_measurable f (Œº.trim hm)`, since we don't have\n`f =·µê[Œº.trim hm] Lp_meas_to_Lp_trim F ùïú p Œº hm f` but only the weaker\n`f =·µê[Œº] Lp_meas_to_Lp_trim F ùïú p Œº hm f`. -/\ntheorem lpMeas.ae_fin_strongly_measurable' (hm : m ‚â§ m0) (f : lpMeas F ùïú m p Œº) (hp_ne_zero : p ‚â† 0)\n    (hp_ne_top : p ‚â† ‚àû) :\n    -- Porting note: changed `f` to `f.1` in the next line. Not certain this is okay.\n    ‚àÉ g, FinStronglyMeasurable g (Œº.trim hm) ‚àß f.1 =·µê[Œº] g :=\n  ‚ü®lpMeasSubgroupToLpTrim F p Œº hm f, Lp.finStronglyMeasurable _ hp_ne_zero hp_ne_top,\n    (lpMeasSubgroupToLpTrim_ae_eq hm f).symm‚ü©\n\n"}
{"name":"MeasureTheory.lpMeasToLpTrimLie_symm_indicator","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.AEMeasurable","initialProofState":"Œ± : Type u_1\nF : Type u_2\np : ENNReal\ninst‚úù¬π : NormedAddCommGroup F\nm m0 : MeasurableSpace Œ±\none_le_p : Fact (LE.le 1 p)\ninst‚úù : NormedSpace Real F\nhm : LE.le m m0\ns : Set Œ±\nŒº : MeasureTheory.Measure Œ±\nhs : MeasurableSet s\nhŒºs : Ne ((Œº.trim hm) s) Top.top\nc : F\n‚ä¢ Eq (‚Üë((MeasureTheory.lpMeasToLpTrimLie F Real p Œº hm).symm (MeasureTheory.indicatorConstLp p hs hŒºs c))) (MeasureTheory.indicatorConstLp p ‚ãØ ‚ãØ c)","decl":"/-- When applying the inverse of `lpMeasToLpTrimLie` (which takes a function in the Lp space of\nthe sub-sigma algebra and returns its version in the larger Lp space) to an indicator of the\nsub-sigma-algebra, we obtain an indicator in the Lp space of the larger sigma-algebra. -/\ntheorem lpMeasToLpTrimLie_symm_indicator [one_le_p : Fact (1 ‚â§ p)] [NormedSpace ‚Ñù F] {hm : m ‚â§ m0}\n    {s : Set Œ±} {Œº : Measure Œ±} (hs : MeasurableSet[m] s) (hŒºs : Œº.trim hm s ‚â† ‚àû) (c : F) :\n    ((lpMeasToLpTrimLie F ‚Ñù p Œº hm).symm (indicatorConstLp p hs hŒºs c) : Lp F p Œº) =\n      indicatorConstLp p (hm s hs) ((le_trim hm).trans_lt hŒºs.lt_top).ne c := by\n  ext1\n  rw [‚Üê lpMeas_coe]\n  change\n    lpTrimToLpMeas F ‚Ñù p Œº hm (indicatorConstLp p hs hŒºs c) =·µê[Œº]\n      (indicatorConstLp p _ _ c : Œ± ‚Üí F)\n  refine (lpTrimToLpMeas_ae_eq hm _).trans ?_\n  exact (ae_eq_of_ae_eq_trim indicatorConstLp_coeFn).trans indicatorConstLp_coeFn.symm\n\n"}
{"name":"MeasureTheory.lpMeasToLpTrimLie_symm_toLp","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.AEMeasurable","initialProofState":"Œ± : Type u_1\nF : Type u_2\np : ENNReal\ninst‚úù¬π : NormedAddCommGroup F\nm m0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\none_le_p : Fact (LE.le 1 p)\ninst‚úù : NormedSpace Real F\nhm : LE.le m m0\nf : Œ± ‚Üí F\nhf : MeasureTheory.Mem‚Ñíp f p (Œº.trim hm)\n‚ä¢ Eq (‚Üë((MeasureTheory.lpMeasToLpTrimLie F Real p Œº hm).symm (MeasureTheory.Mem‚Ñíp.toLp f hf))) (MeasureTheory.Mem‚Ñíp.toLp f ‚ãØ)","decl":"theorem lpMeasToLpTrimLie_symm_toLp [one_le_p : Fact (1 ‚â§ p)] [NormedSpace ‚Ñù F] (hm : m ‚â§ m0)\n    (f : Œ± ‚Üí F) (hf : Mem‚Ñíp f p (Œº.trim hm)) :\n    ((lpMeasToLpTrimLie F ‚Ñù p Œº hm).symm (hf.toLp f) : Lp F p Œº) =\n      (mem‚Ñíp_of_mem‚Ñíp_trim hm hf).toLp f := by\n  ext1\n  rw [‚Üê lpMeas_coe]\n  refine (lpTrimToLpMeas_ae_eq hm _).trans ?_\n  exact (ae_eq_of_ae_eq_trim (Mem‚Ñíp.coeFn_toLp hf)).trans (Mem‚Ñíp.coeFn_toLp _).symm\n\n"}
{"name":"MeasureTheory.Lp.induction_stronglyMeasurable_aux","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.AEMeasurable","initialProofState":"Œ± : Type u_1\nF : Type u_2\np : ENNReal\ninst‚úù¬≤ : NormedAddCommGroup F\nm m0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : Fact (LE.le 1 p)\ninst‚úù : NormedSpace Real F\nhm : LE.le m m0\nhp_ne_top : Ne p Top.top\nP : (Subtype fun x => Membership.mem (MeasureTheory.Lp F p Œº) x) ‚Üí Prop\nh_ind : ‚àÄ (c : F) {s : Set Œ±} (hs : MeasurableSet s) (hŒºs : LT.lt (Œº s) Top.top), P ‚Üë(MeasureTheory.Lp.simpleFunc.indicatorConst p ‚ãØ ‚ãØ c)\nh_add : ‚àÄ ‚¶Éf g : Œ± ‚Üí F‚¶Ñ (hf : MeasureTheory.Mem‚Ñíp f p Œº) (hg : MeasureTheory.Mem‚Ñíp g p Œº), MeasureTheory.AEStronglyMeasurable f Œº ‚Üí MeasureTheory.AEStronglyMeasurable g Œº ‚Üí Disjoint (Function.support f) (Function.support g) ‚Üí P (MeasureTheory.Mem‚Ñíp.toLp f hf) ‚Üí P (MeasureTheory.Mem‚Ñíp.toLp g hg) ‚Üí P (HAdd.hAdd (MeasureTheory.Mem‚Ñíp.toLp f hf) (MeasureTheory.Mem‚Ñíp.toLp g hg))\nh_closed : IsClosed (setOf fun f => P ‚Üëf)\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp F p Œº) x\na‚úù : MeasureTheory.AEStronglyMeasurable (‚Üë‚Üëf) Œº\n‚ä¢ P f","decl":"/-- Auxiliary lemma for `Lp.induction_stronglyMeasurable`. -/\n@[elab_as_elim]\ntheorem Lp.induction_stronglyMeasurable_aux (hm : m ‚â§ m0) (hp_ne_top : p ‚â† ‚àû) (P : Lp F p Œº ‚Üí Prop)\n    (h_ind : ‚àÄ (c : F) {s : Set Œ±} (hs : MeasurableSet[m] s) (hŒºs : Œº s < ‚àû),\n      P (Lp.simpleFunc.indicatorConst p (hm s hs) hŒºs.ne c))\n    (h_add : ‚àÄ ‚¶Éf g‚¶Ñ, ‚àÄ hf : Mem‚Ñíp f p Œº, ‚àÄ hg : Mem‚Ñíp g p Œº, AEStronglyMeasurable[m] f Œº ‚Üí\n      AEStronglyMeasurable[m] g Œº ‚Üí Disjoint (Function.support f) (Function.support g) ‚Üí\n        P (hf.toLp f) ‚Üí P (hg.toLp g) ‚Üí P (hf.toLp f + hg.toLp g))\n    (h_closed : IsClosed {f : lpMeas F ‚Ñù m p Œº | P f}) :\n    ‚àÄ f : Lp F p Œº, AEStronglyMeasurable[m] f Œº ‚Üí P f := by\n  intro f hf\n  let f' := (‚ü®f, hf‚ü© : lpMeas F ‚Ñù m p Œº)\n  let g := lpMeasToLpTrimLie F ‚Ñù p Œº hm f'\n  have hfg : f' = (lpMeasToLpTrimLie F ‚Ñù p Œº hm).symm g := by\n    simp only [f', g, LinearIsometryEquiv.symm_apply_apply]\n  change P ‚Üëf'\n  rw [hfg]\n  refine\n    @Lp.induction Œ± F m _ p (Œº.trim hm) _ hp_ne_top\n      (fun g => P ((lpMeasToLpTrimLie F ‚Ñù p Œº hm).symm g)) ?_ ?_ ?_ g\n  ¬∑ intro b t ht hŒºt\n    -- Porting note: needed to pass `m` to `Lp.simpleFunc.coe_indicatorConst` to avoid\n    -- synthesized type class instance is not definitionally equal to expression inferred by typing\n    -- rules, synthesized m0 inferred m\n    rw [@Lp.simpleFunc.coe_indicatorConst _ _ m, lpMeasToLpTrimLie_symm_indicator ht hŒºt.ne b]\n    have hŒºt' : Œº t < ‚àû := (le_trim hm).trans_lt hŒºt\n    specialize h_ind b ht hŒºt'\n    rwa [Lp.simpleFunc.coe_indicatorConst] at h_ind\n  ¬∑ intro f g hf hg h_disj hfP hgP\n    rw [LinearIsometryEquiv.map_add]\n    push_cast\n    have h_eq :\n      ‚àÄ (f : Œ± ‚Üí F) (hf : Mem‚Ñíp f p (Œº.trim hm)),\n        ((lpMeasToLpTrimLie F ‚Ñù p Œº hm).symm (Mem‚Ñíp.toLp f hf) : Lp F p Œº) =\n          (mem‚Ñíp_of_mem‚Ñíp_trim hm hf).toLp f :=\n      lpMeasToLpTrimLie_symm_toLp hm\n    rw [h_eq f hf] at hfP ‚ä¢\n    rw [h_eq g hg] at hgP ‚ä¢\n    exact\n      h_add (mem‚Ñíp_of_mem‚Ñíp_trim hm hf) (mem‚Ñíp_of_mem‚Ñíp_trim hm hg)\n        (aeStronglyMeasurable'_of_aeStronglyMeasurable'_trim hm hf.aestronglyMeasurable)\n        (aeStronglyMeasurable'_of_aeStronglyMeasurable'_trim hm hg.aestronglyMeasurable)\n        h_disj hfP hgP\n  ¬∑ change IsClosed ((lpMeasToLpTrimLie F ‚Ñù p Œº hm).symm ‚Åª¬π' {g : lpMeas F ‚Ñù m p Œº | P ‚Üëg})\n    exact IsClosed.preimage (LinearIsometryEquiv.continuous _) h_closed\n\n"}
{"name":"MeasureTheory.Lp.induction_stronglyMeasurable","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.AEMeasurable","initialProofState":"Œ± : Type u_1\nF : Type u_2\np : ENNReal\ninst‚úù¬≤ : NormedAddCommGroup F\nm m0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : Fact (LE.le 1 p)\ninst‚úù : NormedSpace Real F\nhm : LE.le m m0\nhp_ne_top : Ne p Top.top\nP : (Subtype fun x => Membership.mem (MeasureTheory.Lp F p Œº) x) ‚Üí Prop\nh_ind : ‚àÄ (c : F) {s : Set Œ±} (hs : MeasurableSet s) (hŒºs : LT.lt (Œº s) Top.top), P ‚Üë(MeasureTheory.Lp.simpleFunc.indicatorConst p ‚ãØ ‚ãØ c)\nh_add : ‚àÄ ‚¶Éf g : Œ± ‚Üí F‚¶Ñ (hf : MeasureTheory.Mem‚Ñíp f p Œº) (hg : MeasureTheory.Mem‚Ñíp g p Œº), MeasureTheory.StronglyMeasurable f ‚Üí MeasureTheory.StronglyMeasurable g ‚Üí Disjoint (Function.support f) (Function.support g) ‚Üí P (MeasureTheory.Mem‚Ñíp.toLp f hf) ‚Üí P (MeasureTheory.Mem‚Ñíp.toLp g hg) ‚Üí P (HAdd.hAdd (MeasureTheory.Mem‚Ñíp.toLp f hf) (MeasureTheory.Mem‚Ñíp.toLp g hg))\nh_closed : IsClosed (setOf fun f => P ‚Üëf)\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp F p Œº) x\na‚úù : MeasureTheory.AEStronglyMeasurable (‚Üë‚Üëf) Œº\n‚ä¢ P f","decl":"/-- To prove something for an `Lp` function a.e. strongly measurable with respect to a\nsub-œÉ-algebra `m` in a normed space, it suffices to show that\n* the property holds for (multiples of) characteristic functions which are measurable w.r.t. `m`;\n* is closed under addition;\n* the set of functions in `Lp` strongly measurable w.r.t. `m` for which the property holds is\n  closed.\n-/\n@[elab_as_elim]\ntheorem Lp.induction_stronglyMeasurable (hm : m ‚â§ m0) (hp_ne_top : p ‚â† ‚àû) (P : Lp F p Œº ‚Üí Prop)\n    (h_ind : ‚àÄ (c : F) {s : Set Œ±} (hs : MeasurableSet[m] s) (hŒºs : Œº s < ‚àû),\n      P (Lp.simpleFunc.indicatorConst p (hm s hs) hŒºs.ne c))\n    (h_add : ‚àÄ ‚¶Éf g‚¶Ñ, ‚àÄ hf : Mem‚Ñíp f p Œº, ‚àÄ hg : Mem‚Ñíp g p Œº, StronglyMeasurable[m] f ‚Üí\n      StronglyMeasurable[m] g ‚Üí Disjoint (Function.support f) (Function.support g) ‚Üí\n        P (hf.toLp f) ‚Üí P (hg.toLp g) ‚Üí P (hf.toLp f + hg.toLp g))\n    (h_closed : IsClosed {f : lpMeas F ‚Ñù m p Œº | P f}) :\n    ‚àÄ f : Lp F p Œº, AEStronglyMeasurable[m] f Œº ‚Üí P f := by\n  intro f hf\n  suffices h_add_ae :\n    ‚àÄ ‚¶Éf g‚¶Ñ, ‚àÄ hf : Mem‚Ñíp f p Œº, ‚àÄ hg : Mem‚Ñíp g p Œº, AEStronglyMeasurable[m] f Œº ‚Üí\n      AEStronglyMeasurable[m] g Œº ‚Üí Disjoint (Function.support f) (Function.support g) ‚Üí\n        P (hf.toLp f) ‚Üí P (hg.toLp g) ‚Üí P (hf.toLp f + hg.toLp g) from\n    Lp.induction_stronglyMeasurable_aux hm hp_ne_top _ h_ind h_add_ae h_closed f hf\n  intro f g hf hg hfm hgm h_disj hPf hPg\n  let s_f : Set Œ± := Function.support (hfm.mk f)\n  have hs_f : MeasurableSet[m] s_f := hfm.stronglyMeasurable_mk.measurableSet_support\n  have hs_f_eq : s_f =·µê[Œº] Function.support f := hfm.ae_eq_mk.symm.support\n  let s_g : Set Œ± := Function.support (hgm.mk g)\n  have hs_g : MeasurableSet[m] s_g := hgm.stronglyMeasurable_mk.measurableSet_support\n  have hs_g_eq : s_g =·µê[Œº] Function.support g := hgm.ae_eq_mk.symm.support\n  have h_inter_empty : (s_f ‚à© s_g : Set Œ±) =·µê[Œº] (‚àÖ : Set Œ±) := by\n    refine (hs_f_eq.inter hs_g_eq).trans ?_\n    suffices Function.support f ‚à© Function.support g = ‚àÖ by rw [this]\n    exact Set.disjoint_iff_inter_eq_empty.mp h_disj\n  let f' := (s_f \\ s_g).indicator (hfm.mk f)\n  have hff' : f =·µê[Œº] f' := by\n    have : s_f \\ s_g =·µê[Œº] s_f := by\n      rw [‚Üê Set.diff_inter_self_eq_diff, Set.inter_comm]\n      refine ((ae_eq_refl s_f).diff h_inter_empty).trans ?_\n      rw [Set.diff_empty]\n    refine ((indicator_ae_eq_of_ae_eq_set this).trans ?_).symm\n    rw [Set.indicator_support]\n    exact hfm.ae_eq_mk.symm\n  have hf'_meas : StronglyMeasurable[m] f' := hfm.stronglyMeasurable_mk.indicator (hs_f.diff hs_g)\n  have hf'_Lp : Mem‚Ñíp f' p Œº := hf.ae_eq hff'\n  let g' := (s_g \\ s_f).indicator (hgm.mk g)\n  have hgg' : g =·µê[Œº] g' := by\n    have : s_g \\ s_f =·µê[Œº] s_g := by\n      rw [‚Üê Set.diff_inter_self_eq_diff]\n      refine ((ae_eq_refl s_g).diff h_inter_empty).trans ?_\n      rw [Set.diff_empty]\n    refine ((indicator_ae_eq_of_ae_eq_set this).trans ?_).symm\n    rw [Set.indicator_support]\n    exact hgm.ae_eq_mk.symm\n  have hg'_meas : StronglyMeasurable[m] g' := hgm.stronglyMeasurable_mk.indicator (hs_g.diff hs_f)\n  have hg'_Lp : Mem‚Ñíp g' p Œº := hg.ae_eq hgg'\n  have h_disj : Disjoint (Function.support f') (Function.support g') :=\n    haveI : Disjoint (s_f \\ s_g) (s_g \\ s_f) := disjoint_sdiff_sdiff\n    this.mono Set.support_indicator_subset Set.support_indicator_subset\n  rw [‚Üê Mem‚Ñíp.toLp_congr hf'_Lp hf hff'.symm] at hPf ‚ä¢\n  rw [‚Üê Mem‚Ñíp.toLp_congr hg'_Lp hg hgg'.symm] at hPg ‚ä¢\n  exact h_add hf'_Lp hg'_Lp hf'_meas hg'_meas h_disj hPf hPg\n\n"}
{"name":"MeasureTheory.Mem‚Ñíp.induction_stronglyMeasurable","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.AEMeasurable","initialProofState":"Œ± : Type u_1\nF : Type u_2\np : ENNReal\ninst‚úù¬≤ : NormedAddCommGroup F\nm m0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : Fact (LE.le 1 p)\ninst‚úù : NormedSpace Real F\nhm : LE.le m m0\nhp_ne_top : Ne p Top.top\nP : (Œ± ‚Üí F) ‚Üí Prop\nh_ind : ‚àÄ (c : F) ‚¶És : Set Œ±‚¶Ñ, MeasurableSet s ‚Üí LT.lt (Œº s) Top.top ‚Üí P (s.indicator fun x => c)\nh_add : ‚àÄ ‚¶Éf g : Œ± ‚Üí F‚¶Ñ, Disjoint (Function.support f) (Function.support g) ‚Üí MeasureTheory.Mem‚Ñíp f p Œº ‚Üí MeasureTheory.Mem‚Ñíp g p Œº ‚Üí MeasureTheory.StronglyMeasurable f ‚Üí MeasureTheory.StronglyMeasurable g ‚Üí P f ‚Üí P g ‚Üí P (HAdd.hAdd f g)\nh_closed : IsClosed (setOf fun f => P ‚Üë‚Üë‚Üëf)\nh_ae : ‚àÄ ‚¶Éf g : Œ± ‚Üí F‚¶Ñ, (MeasureTheory.ae Œº).EventuallyEq f g ‚Üí MeasureTheory.Mem‚Ñíp f p Œº ‚Üí P f ‚Üí P g\nf : Œ± ‚Üí F\na‚úù¬π : MeasureTheory.Mem‚Ñíp f p Œº\na‚úù : MeasureTheory.AEStronglyMeasurable f Œº\n‚ä¢ P f","decl":"/-- To prove something for an arbitrary `Mem‚Ñíp` function a.e. strongly measurable with respect\nto a sub-œÉ-algebra `m` in a normed space, it suffices to show that\n* the property holds for (multiples of) characteristic functions which are measurable w.r.t. `m`;\n* is closed under addition;\n* the set of functions in the `L·µñ` space strongly measurable w.r.t. `m` for which the property\n  holds is closed.\n* the property is closed under the almost-everywhere equal relation.\n-/\n@[elab_as_elim]\ntheorem Mem‚Ñíp.induction_stronglyMeasurable (hm : m ‚â§ m0) (hp_ne_top : p ‚â† ‚àû) (P : (Œ± ‚Üí F) ‚Üí Prop)\n    (h_ind : ‚àÄ (c : F) ‚¶És‚¶Ñ, MeasurableSet[m] s ‚Üí Œº s < ‚àû ‚Üí P (s.indicator fun _ => c))\n    (h_add : ‚àÄ ‚¶Éf g : Œ± ‚Üí F‚¶Ñ, Disjoint (Function.support f) (Function.support g) ‚Üí\n      Mem‚Ñíp f p Œº ‚Üí Mem‚Ñíp g p Œº ‚Üí StronglyMeasurable[m] f ‚Üí StronglyMeasurable[m] g ‚Üí\n        P f ‚Üí P g ‚Üí P (f + g))\n    (h_closed : IsClosed {f : lpMeas F ‚Ñù m p Œº | P f})\n    (h_ae : ‚àÄ ‚¶Éf g‚¶Ñ, f =·µê[Œº] g ‚Üí Mem‚Ñíp f p Œº ‚Üí P f ‚Üí P g) :\n    ‚àÄ ‚¶Éf : Œ± ‚Üí F‚¶Ñ, Mem‚Ñíp f p Œº ‚Üí AEStronglyMeasurable[m] f Œº ‚Üí P f := by\n  intro f hf hfm\n  let f_Lp := hf.toLp f\n  have hfm_Lp : AEStronglyMeasurable[m] f_Lp Œº := hfm.congr hf.coeFn_toLp.symm\n  refine h_ae hf.coeFn_toLp (Lp.mem‚Ñíp _) ?_\n  change P f_Lp\n  refine Lp.induction_stronglyMeasurable hm hp_ne_top (fun f => P f) ?_ ?_ h_closed f_Lp hfm_Lp\n  ¬∑ intro c s hs hŒºs\n    rw [Lp.simpleFunc.coe_indicatorConst]\n    refine h_ae indicatorConstLp_coeFn.symm ?_ (h_ind c hs hŒºs)\n    exact mem‚Ñíp_indicator_const p (hm s hs) c (Or.inr hŒºs.ne)\n  ¬∑ intro f g hf_mem hg_mem hfm hgm h_disj hfP hgP\n    have hfP' : P f := h_ae hf_mem.coeFn_toLp (Lp.mem‚Ñíp _) hfP\n    have hgP' : P g := h_ae hg_mem.coeFn_toLp (Lp.mem‚Ñíp _) hgP\n    specialize h_add h_disj hf_mem hg_mem hfm hgm hfP' hgP'\n    refine h_ae ?_ (hf_mem.add hg_mem) h_add\n    exact (hf_mem.coeFn_toLp.symm.add hg_mem.coeFn_toLp.symm).trans (Lp.coeFn_add _ _).symm\n\n"}
