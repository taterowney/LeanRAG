{"name":"IsUnit.val_inv_subInvSMul","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninstâœÂ² : CommSemiring R\ninstâœÂ¹ : Ring A\ninstâœ : Algebra R A\nr : Units R\ns : R\na : A\nh : IsUnit (HSub.hSub (HSMul.hSMul r ((algebraMap R A) s)) a)\nâŠ¢ Eq (â†‘(Inv.inv h.subInvSMul)) (HSMul.hSMul r â†‘(Inv.inv h.unit))","decl":"/-- The unit `1 - râ»Â¹ â€¢ a` constructed from `r â€¢ 1 - a` when the latter is a unit. -/\n@[simps]\nnoncomputable def IsUnit.subInvSMul {r : RË£} {s : R} {a : A} (h : IsUnit <| r â€¢ â†‘â‚ s - a) : AË£ where\n  val := â†‘â‚ s - râ»Â¹ â€¢ a\n  inv := r â€¢ â†‘h.unitâ»Â¹\n  val_inv := by rw [mul_smul_comm, â† smul_mul_assoc, smul_sub, smul_inv_smul, h.mul_val_inv]\n  inv_val := by rw [smul_mul_assoc, â† mul_smul_comm, smul_sub, smul_inv_smul, h.val_inv_mul]\n\n"}
{"name":"IsUnit.val_subInvSMul","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninstâœÂ² : CommSemiring R\ninstâœÂ¹ : Ring A\ninstâœ : Algebra R A\nr : Units R\ns : R\na : A\nh : IsUnit (HSub.hSub (HSMul.hSMul r ((algebraMap R A) s)) a)\nâŠ¢ Eq (â†‘h.subInvSMul) (HSub.hSub ((algebraMap R A) s) (HSMul.hSMul (Inv.inv r) a))","decl":"/-- The unit `1 - râ»Â¹ â€¢ a` constructed from `r â€¢ 1 - a` when the latter is a unit. -/\n@[simps]\nnoncomputable def IsUnit.subInvSMul {r : RË£} {s : R} {a : A} (h : IsUnit <| r â€¢ â†‘â‚ s - a) : AË£ where\n  val := â†‘â‚ s - râ»Â¹ â€¢ a\n  inv := r â€¢ â†‘h.unitâ»Â¹\n  val_inv := by rw [mul_smul_comm, â† smul_mul_assoc, smul_sub, smul_inv_smul, h.mul_val_inv]\n  inv_val := by rw [smul_mul_assoc, â† mul_smul_comm, smul_sub, smul_inv_smul, h.val_inv_mul]\n\n"}
{"name":"spectrum.mem_iff","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninstâœÂ² : CommSemiring R\ninstâœÂ¹ : Ring A\ninstâœ : Algebra R A\nr : R\na : A\nâŠ¢ Iff (Membership.mem (spectrum R a) r) (Not (IsUnit (HSub.hSub ((algebraMap R A) r) a)))","decl":"theorem mem_iff {r : R} {a : A} : r âˆˆ Ïƒ a â†” Â¬IsUnit (â†‘â‚ r - a) :=\n  Iff.rfl\n\n"}
{"name":"spectrum.not_mem_iff","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninstâœÂ² : CommSemiring R\ninstâœÂ¹ : Ring A\ninstâœ : Algebra R A\nr : R\na : A\nâŠ¢ Iff (Not (Membership.mem (spectrum R a) r)) (IsUnit (HSub.hSub ((algebraMap R A) r) a))","decl":"theorem not_mem_iff {r : R} {a : A} : r âˆ‰ Ïƒ a â†” IsUnit (â†‘â‚ r - a) := by\n  apply not_iff_not.mp\n  simp [Set.not_not_mem, mem_iff]\n\n"}
{"name":"spectrum.zero_mem_iff","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninstâœÂ² : CommSemiring R\ninstâœÂ¹ : Ring A\ninstâœ : Algebra R A\na : A\nâŠ¢ Iff (Membership.mem (spectrum R a) 0) (Not (IsUnit a))","decl":"theorem zero_mem_iff {a : A} : (0 : R) âˆˆ Ïƒ a â†” Â¬IsUnit a := by\n  rw [mem_iff, map_zero, zero_sub, IsUnit.neg_iff]\n\n"}
{"name":"spectrum.zero_mem","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninstâœÂ² : CommSemiring R\ninstâœÂ¹ : Ring A\ninstâœ : Algebra R A\na : A\naâœ : Not (IsUnit a)\nâŠ¢ Membership.mem (spectrum R a) 0","decl":"alias âŸ¨not_isUnit_of_zero_mem, zero_memâŸ© := spectrum.zero_mem_iff\n\n"}
{"name":"spectrum.not_isUnit_of_zero_mem","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninstâœÂ² : CommSemiring R\ninstâœÂ¹ : Ring A\ninstâœ : Algebra R A\na : A\naâœ : Membership.mem (spectrum R a) 0\nâŠ¢ Not (IsUnit a)","decl":"alias âŸ¨not_isUnit_of_zero_mem, zero_memâŸ© := spectrum.zero_mem_iff\n\n"}
{"name":"spectrum.zero_not_mem_iff","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninstâœÂ² : CommSemiring R\ninstâœÂ¹ : Ring A\ninstâœ : Algebra R A\na : A\nâŠ¢ Iff (Not (Membership.mem (spectrum R a) 0)) (IsUnit a)","decl":"theorem zero_not_mem_iff {a : A} : (0 : R) âˆ‰ Ïƒ a â†” IsUnit a := by\n  rw [zero_mem_iff, Classical.not_not]\n\n"}
{"name":"spectrum.zero_not_mem","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninstâœÂ² : CommSemiring R\ninstâœÂ¹ : Ring A\ninstâœ : Algebra R A\na : A\naâœ : IsUnit a\nâŠ¢ Not (Membership.mem (spectrum R a) 0)","decl":"alias âŸ¨isUnit_of_zero_not_mem, zero_not_memâŸ© := spectrum.zero_not_mem_iff\n\n"}
{"name":"spectrum.isUnit_of_zero_not_mem","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninstâœÂ² : CommSemiring R\ninstâœÂ¹ : Ring A\ninstâœ : Algebra R A\na : A\naâœ : Not (Membership.mem (spectrum R a) 0)\nâŠ¢ IsUnit a","decl":"alias âŸ¨isUnit_of_zero_not_mem, zero_not_memâŸ© := spectrum.zero_not_mem_iff\n\n"}
{"name":"Units.zero_not_mem_spectrum","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninstâœÂ² : CommSemiring R\ninstâœÂ¹ : Ring A\ninstâœ : Algebra R A\na : Units A\nâŠ¢ Not (Membership.mem (spectrum R â†‘a) 0)","decl":"@[simp]\nlemma _root_.Units.zero_not_mem_spectrum (a : AË£) : 0 âˆ‰ spectrum R (a : A) :=\n  spectrum.zero_not_mem R a.isUnit\n\n"}
{"name":"spectrum.subset_singleton_zero_compl","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninstâœÂ² : CommSemiring R\ninstâœÂ¹ : Ring A\ninstâœ : Algebra R A\na : A\nha : IsUnit a\nâŠ¢ HasSubset.Subset (spectrum R a) (HasCompl.compl (Singleton.singleton 0))","decl":"lemma subset_singleton_zero_compl {a : A} (ha : IsUnit a) : spectrum R a âŠ† {0}á¶œ :=\n  Set.subset_compl_singleton_iff.mpr <| spectrum.zero_not_mem R ha\n\n"}
{"name":"spectrum.mem_resolventSet_of_left_right_inverse","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninstâœÂ² : CommSemiring R\ninstâœÂ¹ : Ring A\ninstâœ : Algebra R A\nr : R\na b c : A\nhâ‚ : Eq (HMul.hMul (HSub.hSub ((algebraMap R A) r) a) b) 1\nhâ‚‚ : Eq (HMul.hMul c (HSub.hSub ((algebraMap R A) r) a)) 1\nâŠ¢ Membership.mem (resolventSet R a) r","decl":"theorem mem_resolventSet_of_left_right_inverse {r : R} {a b c : A} (hâ‚ : (â†‘â‚ r - a) * b = 1)\n    (hâ‚‚ : c * (â†‘â‚ r - a) = 1) : r âˆˆ resolventSet R a :=\n  Units.isUnit âŸ¨â†‘â‚ r - a, b, hâ‚, by rwa [â† left_inv_eq_right_inv hâ‚‚ hâ‚]âŸ©\n\n"}
{"name":"spectrum.mem_resolventSet_iff","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninstâœÂ² : CommSemiring R\ninstâœÂ¹ : Ring A\ninstâœ : Algebra R A\nr : R\na : A\nâŠ¢ Iff (Membership.mem (resolventSet R a) r) (IsUnit (HSub.hSub ((algebraMap R A) r) a))","decl":"theorem mem_resolventSet_iff {r : R} {a : A} : r âˆˆ resolventSet R a â†” IsUnit (â†‘â‚ r - a) :=\n  Iff.rfl\n\n"}
{"name":"spectrum.algebraMap_mem_iff","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"S : Type u_1\nR : Type u_2\nA : Type u_3\ninstâœâ¶ : CommSemiring R\ninstâœâµ : CommSemiring S\ninstâœâ´ : Ring A\ninstâœÂ³ : Algebra R S\ninstâœÂ² : Algebra R A\ninstâœÂ¹ : Algebra S A\ninstâœ : IsScalarTower R S A\na : A\nr : R\nâŠ¢ Iff (Membership.mem (spectrum S a) ((algebraMap R S) r)) (Membership.mem (spectrum R a) r)","decl":"@[simp]\ntheorem algebraMap_mem_iff (S : Type*) {R A : Type*} [CommSemiring R] [CommSemiring S]\n    [Ring A] [Algebra R S] [Algebra R A] [Algebra S A] [IsScalarTower R S A] {a : A} {r : R} :\n    algebraMap R S r âˆˆ spectrum S a â†” r âˆˆ spectrum R a := by\n  simp only [spectrum.mem_iff, Algebra.algebraMap_eq_smul_one, smul_assoc, one_smul]\n\n"}
{"name":"spectrum.algebraMap_mem","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"S : Type u_1\nR : Type u_2\nA : Type u_3\ninstâœâ¶ : CommSemiring R\ninstâœâµ : CommSemiring S\ninstâœâ´ : Ring A\ninstâœÂ³ : Algebra R S\ninstâœÂ² : Algebra R A\ninstâœÂ¹ : Algebra S A\ninstâœ : IsScalarTower R S A\na : A\nr : R\naâœ : Membership.mem (spectrum R a) r\nâŠ¢ Membership.mem (spectrum S a) ((algebraMap R S) r)","decl":"protected alias âŸ¨of_algebraMap_mem, algebraMap_memâŸ© := spectrum.algebraMap_mem_iff\n\n"}
{"name":"spectrum.of_algebraMap_mem","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"S : Type u_1\nR : Type u_2\nA : Type u_3\ninstâœâ¶ : CommSemiring R\ninstâœâµ : CommSemiring S\ninstâœâ´ : Ring A\ninstâœÂ³ : Algebra R S\ninstâœÂ² : Algebra R A\ninstâœÂ¹ : Algebra S A\ninstâœ : IsScalarTower R S A\na : A\nr : R\naâœ : Membership.mem (spectrum S a) ((algebraMap R S) r)\nâŠ¢ Membership.mem (spectrum R a) r","decl":"protected alias âŸ¨of_algebraMap_mem, algebraMap_memâŸ© := spectrum.algebraMap_mem_iff\n\n"}
{"name":"spectrum.preimage_algebraMap","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"S : Type u_1\nR : Type u_2\nA : Type u_3\ninstâœâ¶ : CommSemiring R\ninstâœâµ : CommSemiring S\ninstâœâ´ : Ring A\ninstâœÂ³ : Algebra R S\ninstâœÂ² : Algebra R A\ninstâœÂ¹ : Algebra S A\ninstâœ : IsScalarTower R S A\na : A\nâŠ¢ Eq (Set.preimage (â‡‘(algebraMap R S)) (spectrum S a)) (spectrum R a)","decl":"@[simp]\ntheorem preimage_algebraMap (S : Type*) {R A : Type*} [CommSemiring R] [CommSemiring S]\n    [Ring A] [Algebra R S] [Algebra R A] [Algebra S A] [IsScalarTower R S A] {a : A} :\n    algebraMap R S â»Â¹' spectrum S a = spectrum R a :=\n  Set.ext fun _ => spectrum.algebraMap_mem_iff _\n\n"}
{"name":"spectrum.resolventSet_of_subsingleton","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninstâœÂ³ : CommSemiring R\ninstâœÂ² : Ring A\ninstâœÂ¹ : Algebra R A\ninstâœ : Subsingleton A\na : A\nâŠ¢ Eq (resolventSet R a) Set.univ","decl":"@[simp]\ntheorem resolventSet_of_subsingleton [Subsingleton A] (a : A) : resolventSet R a = Set.univ := by\n  simp_rw [resolventSet, Subsingleton.elim (algebraMap R A _ - a) 1, isUnit_one, Set.setOf_true]\n\n"}
{"name":"spectrum.of_subsingleton","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninstâœÂ³ : CommSemiring R\ninstâœÂ² : Ring A\ninstâœÂ¹ : Algebra R A\ninstâœ : Subsingleton A\na : A\nâŠ¢ Eq (spectrum R a) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem of_subsingleton [Subsingleton A] (a : A) : spectrum R a = âˆ… := by\n  rw [spectrum, resolventSet_of_subsingleton, Set.compl_univ]\n\n"}
{"name":"spectrum.resolvent_eq","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninstâœÂ² : CommSemiring R\ninstâœÂ¹ : Ring A\ninstâœ : Algebra R A\na : A\nr : R\nh : Membership.mem (resolventSet R a) r\nâŠ¢ Eq (resolvent a r) â†‘(Inv.inv (IsUnit.unit h))","decl":"theorem resolvent_eq {a : A} {r : R} (h : r âˆˆ resolventSet R a) : resolvent a r = â†‘h.unitâ»Â¹ :=\n  Ring.inverse_unit h.unit\n\n"}
{"name":"spectrum.units_smul_resolvent","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninstâœÂ² : CommSemiring R\ninstâœÂ¹ : Ring A\ninstâœ : Algebra R A\nr : Units R\ns : R\na : A\nâŠ¢ Eq (HSMul.hSMul r (resolvent a s)) (resolvent (HSMul.hSMul (Inv.inv r) a) (HSMul.hSMul (Inv.inv r) s))","decl":"theorem units_smul_resolvent {r : RË£} {s : R} {a : A} :\n    r â€¢ resolvent a (s : R) = resolvent (râ»Â¹ â€¢ a) (râ»Â¹ â€¢ s : R) := by\n  by_cases h : s âˆˆ spectrum R a\n  Â· rw [mem_iff] at h\n    simp only [resolvent, Algebra.algebraMap_eq_smul_one] at *\n    rw [smul_assoc, â† smul_sub]\n    have h' : Â¬IsUnit (râ»Â¹ â€¢ (s â€¢ (1 : A) - a)) := fun hu =>\n      h (by simpa only [smul_inv_smul] using IsUnit.smul r hu)\n    simp only [Ring.inverse_non_unit _ h, Ring.inverse_non_unit _ h', smul_zero]\n  Â· simp only [resolvent]\n    have h' : IsUnit (r â€¢ algebraMap R A (râ»Â¹ â€¢ s) - a) := by\n      simpa [Algebra.algebraMap_eq_smul_one, smul_assoc] using not_mem_iff.mp h\n    rw [â† h'.val_subInvSMul, â† (not_mem_iff.mp h).unit_spec, Ring.inverse_unit, Ring.inverse_unit,\n      h'.val_inv_subInvSMul]\n    simp only [Algebra.algebraMap_eq_smul_one, smul_assoc, smul_inv_smul]\n\n"}
{"name":"spectrum.units_smul_resolvent_self","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninstâœÂ² : CommSemiring R\ninstâœÂ¹ : Ring A\ninstâœ : Algebra R A\nr : Units R\na : A\nâŠ¢ Eq (HSMul.hSMul r (resolvent a â†‘r)) (resolvent (HSMul.hSMul (Inv.inv r) a) 1)","decl":"theorem units_smul_resolvent_self {r : RË£} {a : A} :\n    r â€¢ resolvent a (r : R) = resolvent (râ»Â¹ â€¢ a) (1 : R) := by\n  simpa only [Units.smul_def, Algebra.id.smul_eq_mul, Units.inv_mul] using\n    @units_smul_resolvent _ _ _ _ _ r r a\n\n"}
{"name":"spectrum.isUnit_resolvent","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninstâœÂ² : CommSemiring R\ninstâœÂ¹ : Ring A\ninstâœ : Algebra R A\nr : R\na : A\nâŠ¢ Iff (Membership.mem (resolventSet R a) r) (IsUnit (resolvent a r))","decl":"/-- The resolvent is a unit when the argument is in the resolvent set. -/\ntheorem isUnit_resolvent {r : R} {a : A} : r âˆˆ resolventSet R a â†” IsUnit (resolvent a r) :=\n  isUnit_ring_inverse.symm\n\n"}
{"name":"spectrum.inv_mem_resolventSet","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninstâœÂ² : CommSemiring R\ninstâœÂ¹ : Ring A\ninstâœ : Algebra R A\nr : Units R\na : Units A\nh : Membership.mem (resolventSet R â†‘a) â†‘r\nâŠ¢ Membership.mem (resolventSet R â†‘(Inv.inv a)) â†‘(Inv.inv r)","decl":"theorem inv_mem_resolventSet {r : RË£} {a : AË£} (h : (r : R) âˆˆ resolventSet R (a : A)) :\n    (â†‘râ»Â¹ : R) âˆˆ resolventSet R (â†‘aâ»Â¹ : A) := by\n  rw [mem_resolventSet_iff, Algebra.algebraMap_eq_smul_one, â† Units.smul_def] at h âŠ¢\n  rw [IsUnit.smul_sub_iff_sub_inv_smul, inv_inv, IsUnit.sub_iff]\n  have hâ‚ : (a : A) * (r â€¢ (â†‘aâ»Â¹ : A) - 1) = r â€¢ (1 : A) - a := by\n    rw [mul_sub, mul_smul_comm, a.mul_inv, mul_one]\n  have hâ‚‚ : (r â€¢ (â†‘aâ»Â¹ : A) - 1) * a = r â€¢ (1 : A) - a := by\n    rw [sub_mul, smul_mul_assoc, a.inv_mul, one_mul]\n  have hcomm : Commute (a : A) (r â€¢ (â†‘aâ»Â¹ : A) - 1) := by rwa [â† hâ‚‚] at hâ‚\n  exact (hcomm.isUnit_mul_iff.mp (hâ‚.symm â–¸ h)).2\n\n"}
{"name":"spectrum.inv_mem_iff","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninstâœÂ² : CommSemiring R\ninstâœÂ¹ : Ring A\ninstâœ : Algebra R A\nr : Units R\na : Units A\nâŠ¢ Iff (Membership.mem (spectrum R â†‘a) â†‘r) (Membership.mem (spectrum R â†‘(Inv.inv a)) â†‘(Inv.inv r))","decl":"theorem inv_mem_iff {r : RË£} {a : AË£} : (r : R) âˆˆ Ïƒ (a : A) â†” (â†‘râ»Â¹ : R) âˆˆ Ïƒ (â†‘aâ»Â¹ : A) :=\n  not_iff_not.2 <| âŸ¨inv_mem_resolventSet, inv_mem_resolventSetâŸ©\n\n"}
{"name":"spectrum.zero_mem_resolventSet_of_unit","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninstâœÂ² : CommSemiring R\ninstâœÂ¹ : Ring A\ninstâœ : Algebra R A\na : Units A\nâŠ¢ Membership.mem (resolventSet R â†‘a) 0","decl":"theorem zero_mem_resolventSet_of_unit (a : AË£) : 0 âˆˆ resolventSet R (a : A) := by\n  simpa only [mem_resolventSet_iff, â† not_mem_iff, zero_not_mem_iff] using a.isUnit\n\n"}
{"name":"spectrum.ne_zero_of_mem_of_unit","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninstâœÂ² : CommSemiring R\ninstâœÂ¹ : Ring A\ninstâœ : Algebra R A\na : Units A\nr : R\nhr : Membership.mem (spectrum R â†‘a) r\nâŠ¢ Ne r 0","decl":"theorem ne_zero_of_mem_of_unit {a : AË£} {r : R} (hr : r âˆˆ Ïƒ (a : A)) : r â‰  0 := fun hn =>\n  (hn â–¸ hr) (zero_mem_resolventSet_of_unit a)\n\n"}
{"name":"spectrum.add_mem_iff","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninstâœÂ² : CommSemiring R\ninstâœÂ¹ : Ring A\ninstâœ : Algebra R A\na : A\nr s : R\nâŠ¢ Iff (Membership.mem (spectrum R a) (HAdd.hAdd r s)) (Membership.mem (spectrum R (HAdd.hAdd (Neg.neg ((algebraMap R A) s)) a)) r)","decl":"theorem add_mem_iff {a : A} {r s : R} : r + s âˆˆ Ïƒ a â†” r âˆˆ Ïƒ (-â†‘â‚ s + a) := by\n  simp only [mem_iff, sub_neg_eq_add, â† sub_sub, map_add]\n\n"}
{"name":"spectrum.add_mem_add_iff","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninstâœÂ² : CommSemiring R\ninstâœÂ¹ : Ring A\ninstâœ : Algebra R A\na : A\nr s : R\nâŠ¢ Iff (Membership.mem (spectrum R (HAdd.hAdd ((algebraMap R A) s) a)) (HAdd.hAdd r s)) (Membership.mem (spectrum R a) r)","decl":"theorem add_mem_add_iff {a : A} {r s : R} : r + s âˆˆ Ïƒ (â†‘â‚ s + a) â†” r âˆˆ Ïƒ a := by\n  rw [add_mem_iff, neg_add_cancel_left]\n\n"}
{"name":"spectrum.smul_mem_smul_iff","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninstâœÂ² : CommSemiring R\ninstâœÂ¹ : Ring A\ninstâœ : Algebra R A\na : A\ns : R\nr : Units R\nâŠ¢ Iff (Membership.mem (spectrum R (HSMul.hSMul r a)) (HSMul.hSMul r s)) (Membership.mem (spectrum R a) s)","decl":"theorem smul_mem_smul_iff {a : A} {s : R} {r : RË£} : r â€¢ s âˆˆ Ïƒ (r â€¢ a) â†” s âˆˆ Ïƒ a := by\n  simp only [mem_iff, not_iff_not, Algebra.algebraMap_eq_smul_one, smul_assoc, â† smul_sub,\n    isUnit_smul_iff]\n\n"}
{"name":"spectrum.unit_smul_eq_smul","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninstâœÂ² : CommSemiring R\ninstâœÂ¹ : Ring A\ninstâœ : Algebra R A\na : A\nr : Units R\nâŠ¢ Eq (spectrum R (HSMul.hSMul r a)) (HSMul.hSMul r (spectrum R a))","decl":"theorem unit_smul_eq_smul (a : A) (r : RË£) : Ïƒ (r â€¢ a) = r â€¢ Ïƒ a := by\n  ext x\n  have x_eq : x = r â€¢ râ»Â¹ â€¢ x := by simp\n  nth_rw 1 [x_eq]\n  rw [smul_mem_smul_iff]\n  constructor\n  Â· exact fun h => âŸ¨râ»Â¹ â€¢ x, âŸ¨h, show r â€¢ râ»Â¹ â€¢ x = x by simpâŸ©âŸ©\n  Â· rintro âŸ¨w, _, (x'_eq : r â€¢ w = x)âŸ©\n    simpa [â† x'_eq ]\n\n-- `r âˆˆ Ïƒ(a*b) â†” r âˆˆ Ïƒ(b*a)` for any `r : RË£`\n"}
{"name":"spectrum.unit_mem_mul_iff_mem_swap_mul","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninstâœÂ² : CommSemiring R\ninstâœÂ¹ : Ring A\ninstâœ : Algebra R A\na b : A\nr : Units R\nâŠ¢ Iff (Membership.mem (spectrum R (HMul.hMul a b)) â†‘r) (Membership.mem (spectrum R (HMul.hMul b a)) â†‘r)","decl":"theorem unit_mem_mul_iff_mem_swap_mul {a b : A} {r : RË£} : â†‘r âˆˆ Ïƒ (a * b) â†” â†‘r âˆˆ Ïƒ (b * a) := by\n  have hâ‚ : âˆ€ x y : A, IsUnit (1 - x * y) â†’ IsUnit (1 - y * x) := by\n    refine fun x y h => âŸ¨âŸ¨1 - y * x, 1 + y * h.unit.inv * x, ?_, ?_âŸ©, rflâŸ©\n    Â· calc\n        (1 - y * x) * (1 + y * (IsUnit.unit h).inv * x) =\n            1 - y * x + y * ((1 - x * y) * h.unit.inv) * x := by noncomm_ring\n        _ = 1 := by simp only [Units.inv_eq_val_inv, IsUnit.mul_val_inv, mul_one, sub_add_cancel]\n    Â· calc\n        (1 + y * (IsUnit.unit h).inv * x) * (1 - y * x) =\n            1 - y * x + y * (h.unit.inv * (1 - x * y)) * x := by noncomm_ring\n        _ = 1 := by simp only [Units.inv_eq_val_inv, IsUnit.val_inv_mul, mul_one, sub_add_cancel]\n  have := Iff.intro (hâ‚ (râ»Â¹ â€¢ a) b) (hâ‚ b (râ»Â¹ â€¢ a))\n  rw [mul_smul_comm râ»Â¹ b a] at this\n  simpa only [mem_iff, not_iff_not, Algebra.algebraMap_eq_smul_one, â† Units.smul_def,\n    IsUnit.smul_sub_iff_sub_inv_smul, smul_mul_assoc]\n\n"}
{"name":"spectrum.preimage_units_mul_eq_swap_mul","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninstâœÂ² : CommSemiring R\ninstâœÂ¹ : Ring A\ninstâœ : Algebra R A\na b : A\nâŠ¢ Eq (Set.preimage Units.val (spectrum R (HMul.hMul a b))) (Set.preimage Units.val (spectrum R (HMul.hMul b a)))","decl":"theorem preimage_units_mul_eq_swap_mul {a b : A} :\n    ((â†‘) : RË£ â†’ R) â»Â¹' Ïƒ (a * b) = (â†‘) â»Â¹' Ïƒ (b * a) :=\n  Set.ext fun _ => unit_mem_mul_iff_mem_swap_mul\n\n"}
{"name":"spectrum.star_mem_resolventSet_iff","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninstâœâµ : CommSemiring R\ninstâœâ´ : Ring A\ninstâœÂ³ : Algebra R A\ninstâœÂ² : InvolutiveStar R\ninstâœÂ¹ : StarRing A\ninstâœ : StarModule R A\nr : R\na : A\nâŠ¢ Iff (Membership.mem (resolventSet R a) (Star.star r)) (Membership.mem (resolventSet R (Star.star a)) r)","decl":"theorem star_mem_resolventSet_iff {r : R} {a : A} :\n    star r âˆˆ resolventSet R a â†” r âˆˆ resolventSet R (star a) := by\n  refine âŸ¨fun h => ?_, fun h => ?_âŸ© <;>\n    simpa only [mem_resolventSet_iff, Algebra.algebraMap_eq_smul_one, star_sub, star_smul,\n      star_star, star_one] using IsUnit.star h\n\n"}
{"name":"spectrum.map_star","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninstâœâµ : CommSemiring R\ninstâœâ´ : Ring A\ninstâœÂ³ : Algebra R A\ninstâœÂ² : InvolutiveStar R\ninstâœÂ¹ : StarRing A\ninstâœ : StarModule R A\na : A\nâŠ¢ Eq (spectrum R (Star.star a)) (Star.star (spectrum R a))","decl":"protected theorem map_star (a : A) : Ïƒ (star a) = star (Ïƒ a) := by\n  ext\n  simpa only [Set.mem_star, mem_iff, not_iff_not] using star_mem_resolventSet_iff.symm\n\n"}
{"name":"spectrum.subset_subalgebra","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"S : Type u_1\nR : Type u_2\nA : Type u_3\ninstâœâµ : CommSemiring R\ninstâœâ´ : Ring A\ninstâœÂ³ : Algebra R A\ninstâœÂ² : SetLike S A\ninstâœÂ¹ : SubringClass S A\ninstâœ : SMulMemClass S R A\ns : S\na : Subtype fun x => Membership.mem s x\nâŠ¢ HasSubset.Subset (spectrum R â†‘a) (spectrum R a)","decl":"theorem subset_subalgebra {S R A : Type*} [CommSemiring R] [Ring A] [Algebra R A]\n    [SetLike S A] [SubringClass S A] [SMulMemClass S R A] {s : S} (a : s) :\n    spectrum R (a : A) âŠ† spectrum R a :=\n  Set.compl_subset_compl.mpr fun _ â†¦ IsUnit.map (SubalgebraClass.val s)\n\n"}
{"name":"spectrum.singleton_add_eq","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninstâœÂ² : CommRing R\ninstâœÂ¹ : Ring A\ninstâœ : Algebra R A\na : A\nr : R\nâŠ¢ Eq (HAdd.hAdd (Singleton.singleton r) (spectrum R a)) (spectrum R (HAdd.hAdd ((algebraMap R A) r) a))","decl":"theorem singleton_add_eq (a : A) (r : R) : {r} + Ïƒ a = Ïƒ (â†‘â‚ r + a) :=\n  ext fun x => by\n    rw [singleton_add, image_add_left, mem_preimage, add_comm, add_mem_iff, map_neg, neg_neg]\n\n"}
{"name":"spectrum.add_singleton_eq","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninstâœÂ² : CommRing R\ninstâœÂ¹ : Ring A\ninstâœ : Algebra R A\na : A\nr : R\nâŠ¢ Eq (HAdd.hAdd (spectrum R a) (Singleton.singleton r)) (spectrum R (HAdd.hAdd a ((algebraMap R A) r)))","decl":"theorem add_singleton_eq (a : A) (r : R) : Ïƒ a + {r} = Ïƒ (a + â†‘â‚ r) :=\n  add_comm {r} (Ïƒ a) â–¸ add_comm (algebraMap R A r) a â–¸ singleton_add_eq a r\n\n"}
{"name":"spectrum.vadd_eq","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninstâœÂ² : CommRing R\ninstâœÂ¹ : Ring A\ninstâœ : Algebra R A\na : A\nr : R\nâŠ¢ Eq (HVAdd.hVAdd r (spectrum R a)) (spectrum R (HAdd.hAdd ((algebraMap R A) r) a))","decl":"theorem vadd_eq (a : A) (r : R) : r +áµ¥ Ïƒ a = Ïƒ (â†‘â‚ r + a) :=\n  singleton_add.symm.trans <| singleton_add_eq a r\n\n"}
{"name":"spectrum.neg_eq","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninstâœÂ² : CommRing R\ninstâœÂ¹ : Ring A\ninstâœ : Algebra R A\na : A\nâŠ¢ Eq (Neg.neg (spectrum R a)) (spectrum R (Neg.neg a))","decl":"theorem neg_eq (a : A) : -Ïƒ a = Ïƒ (-a) :=\n  Set.ext fun x => by\n    simp only [mem_neg, mem_iff, map_neg, â† neg_add', IsUnit.neg_iff, sub_neg_eq_add]\n\n"}
{"name":"spectrum.singleton_sub_eq","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninstâœÂ² : CommRing R\ninstâœÂ¹ : Ring A\ninstâœ : Algebra R A\na : A\nr : R\nâŠ¢ Eq (HSub.hSub (Singleton.singleton r) (spectrum R a)) (spectrum R (HSub.hSub ((algebraMap R A) r) a))","decl":"theorem singleton_sub_eq (a : A) (r : R) : {r} - Ïƒ a = Ïƒ (â†‘â‚ r - a) := by\n  rw [sub_eq_add_neg, neg_eq, singleton_add_eq, sub_eq_add_neg]\n\n"}
{"name":"spectrum.sub_singleton_eq","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninstâœÂ² : CommRing R\ninstâœÂ¹ : Ring A\ninstâœ : Algebra R A\na : A\nr : R\nâŠ¢ Eq (HSub.hSub (spectrum R a) (Singleton.singleton r)) (spectrum R (HSub.hSub a ((algebraMap R A) r)))","decl":"theorem sub_singleton_eq (a : A) (r : R) : Ïƒ a - {r} = Ïƒ (a - â†‘â‚ r) := by\n  simpa only [neg_sub, neg_eq] using congr_arg Neg.neg (singleton_sub_eq a r)\n\n"}
{"name":"spectrum.invâ‚€_mem_iff","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninstâœÂ² : Semifield R\ninstâœÂ¹ : Ring A\ninstâœ : Algebra R A\nr : R\na : Units A\nâŠ¢ Iff (Membership.mem (spectrum R â†‘a) (Inv.inv r)) (Membership.mem (spectrum R â†‘(Inv.inv a)) r)","decl":"@[simp]\nlemma invâ‚€_mem_iff {r : R} {a : AË£} :\n    râ»Â¹ âˆˆ spectrum R (a : A) â†” r âˆˆ spectrum R (â†‘aâ»Â¹ : A) := by\n  obtain (rfl | hr) := eq_or_ne r 0\n  Â· simp [zero_mem_iff]\n  Â· lift r to RË£ using hr.isUnit\n    simp [inv_mem_iff]\n\n"}
{"name":"spectrum.invâ‚€_mem_inv_iff","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninstâœÂ² : Semifield R\ninstâœÂ¹ : Ring A\ninstâœ : Algebra R A\nr : R\na : Units A\nâŠ¢ Iff (Membership.mem (spectrum R â†‘(Inv.inv a)) (Inv.inv r)) (Membership.mem (spectrum R â†‘a) r)","decl":"lemma invâ‚€_mem_inv_iff {r : R} {a : AË£} :\n    râ»Â¹ âˆˆ spectrum R (â†‘aâ»Â¹ : A) â†” r âˆˆ spectrum R (a : A) := by\n  simp\n\n"}
{"name":"spectrum.invâ‚€_mem","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninstâœÂ² : Semifield R\ninstâœÂ¹ : Ring A\ninstâœ : Algebra R A\nr : R\na : Units A\naâœ : Membership.mem (spectrum R â†‘(Inv.inv a)) r\nâŠ¢ Membership.mem (spectrum R â†‘a) (Inv.inv r)","decl":"alias âŸ¨of_invâ‚€_mem, invâ‚€_memâŸ© := invâ‚€_mem_iff\n"}
{"name":"spectrum.of_invâ‚€_mem","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninstâœÂ² : Semifield R\ninstâœÂ¹ : Ring A\ninstâœ : Algebra R A\nr : R\na : Units A\naâœ : Membership.mem (spectrum R â†‘a) (Inv.inv r)\nâŠ¢ Membership.mem (spectrum R â†‘(Inv.inv a)) r","decl":"alias âŸ¨of_invâ‚€_mem, invâ‚€_memâŸ© := invâ‚€_mem_iff\n"}
{"name":"spectrum.of_invâ‚€_mem_inv","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninstâœÂ² : Semifield R\ninstâœÂ¹ : Ring A\ninstâœ : Algebra R A\nr : R\na : Units A\naâœ : Membership.mem (spectrum R â†‘(Inv.inv a)) (Inv.inv r)\nâŠ¢ Membership.mem (spectrum R â†‘a) r","decl":"alias âŸ¨of_invâ‚€_mem_inv, invâ‚€_mem_invâŸ© := invâ‚€_mem_inv_iff\n\n"}
{"name":"spectrum.invâ‚€_mem_inv","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninstâœÂ² : Semifield R\ninstâœÂ¹ : Ring A\ninstâœ : Algebra R A\nr : R\na : Units A\naâœ : Membership.mem (spectrum R â†‘a) r\nâŠ¢ Membership.mem (spectrum R â†‘(Inv.inv a)) (Inv.inv r)","decl":"alias âŸ¨of_invâ‚€_mem_inv, invâ‚€_mem_invâŸ© := invâ‚€_mem_inv_iff\n\n"}
{"name":"spectrum.zero_eq","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"ğ•œ : Type u\nA : Type v\ninstâœÂ³ : Field ğ•œ\ninstâœÂ² : Ring A\ninstâœÂ¹ : Algebra ğ•œ A\ninstâœ : Nontrivial A\nâŠ¢ Eq (spectrum ğ•œ 0) (Singleton.singleton 0)","decl":"/-- Without the assumption `Nontrivial A`, then `0 : A` would be invertible. -/\n@[simp]\ntheorem zero_eq [Nontrivial A] : Ïƒ (0 : A) = {0} := by\n  refine Set.Subset.antisymm ?_ (by simp [Algebra.algebraMap_eq_smul_one, mem_iff])\n  rw [spectrum, Set.compl_subset_comm]\n  intro k hk\n  rw [Set.mem_compl_singleton_iff] at hk\n  have : IsUnit (Units.mk0 k hk â€¢ (1 : A)) := IsUnit.smul (Units.mk0 k hk) isUnit_one\n  simpa [mem_resolventSet_iff, Algebra.algebraMap_eq_smul_one]\n\n"}
{"name":"spectrum.scalar_eq","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"ğ•œ : Type u\nA : Type v\ninstâœÂ³ : Field ğ•œ\ninstâœÂ² : Ring A\ninstâœÂ¹ : Algebra ğ•œ A\ninstâœ : Nontrivial A\nk : ğ•œ\nâŠ¢ Eq (spectrum ğ•œ ((algebraMap ğ•œ A) k)) (Singleton.singleton k)","decl":"@[simp]\ntheorem scalar_eq [Nontrivial A] (k : ğ•œ) : Ïƒ (â†‘â‚ k) = {k} := by\n  rw [â† add_zero (â†‘â‚ k), â† singleton_add_eq, zero_eq, Set.singleton_add_singleton, add_zero]\n\n"}
{"name":"spectrum.one_eq","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"ğ•œ : Type u\nA : Type v\ninstâœÂ³ : Field ğ•œ\ninstâœÂ² : Ring A\ninstâœÂ¹ : Algebra ğ•œ A\ninstâœ : Nontrivial A\nâŠ¢ Eq (spectrum ğ•œ 1) (Singleton.singleton 1)","decl":"@[simp]\ntheorem one_eq [Nontrivial A] : Ïƒ (1 : A) = {1} :=\n  calc\n    Ïƒ (1 : A) = Ïƒ (â†‘â‚ 1) := by rw [Algebra.algebraMap_eq_smul_one, one_smul]\n    _ = {1} := scalar_eq 1\n\n"}
{"name":"spectrum.smul_eq_smul","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"ğ•œ : Type u\nA : Type v\ninstâœÂ³ : Field ğ•œ\ninstâœÂ² : Ring A\ninstâœÂ¹ : Algebra ğ•œ A\ninstâœ : Nontrivial A\nk : ğ•œ\na : A\nha : (spectrum ğ•œ a).Nonempty\nâŠ¢ Eq (spectrum ğ•œ (HSMul.hSMul k a)) (HSMul.hSMul k (spectrum ğ•œ a))","decl":"/-- the assumption `(Ïƒ a).Nonempty` is necessary and cannot be removed without\nfurther conditions on the algebra `A` and scalar field `ğ•œ`. -/\ntheorem smul_eq_smul [Nontrivial A] (k : ğ•œ) (a : A) (ha : (Ïƒ a).Nonempty) :\n    Ïƒ (k â€¢ a) = k â€¢ Ïƒ a := by\n  rcases eq_or_ne k 0 with (rfl | h)\n  Â· simpa [ha, zero_smul_set] using (show {(0 : ğ•œ)} = (0 : Set ğ•œ) from rfl)\n  Â· exact unit_smul_eq_smul a (Units.mk0 k h)\n\n"}
{"name":"spectrum.nonzero_mul_eq_swap_mul","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"ğ•œ : Type u\nA : Type v\ninstâœÂ² : Field ğ•œ\ninstâœÂ¹ : Ring A\ninstâœ : Algebra ğ•œ A\na b : A\nâŠ¢ Eq (SDiff.sdiff (spectrum ğ•œ (HMul.hMul a b)) (Singleton.singleton 0)) (SDiff.sdiff (spectrum ğ•œ (HMul.hMul b a)) (Singleton.singleton 0))","decl":"theorem nonzero_mul_eq_swap_mul (a b : A) : Ïƒ (a * b) \\ {0} = Ïƒ (b * a) \\ {0} := by\n  suffices h : âˆ€ x y : A, Ïƒ (x * y) \\ {0} âŠ† Ïƒ (y * x) \\ {0} from\n    Set.eq_of_subset_of_subset (h a b) (h b a)\n  rintro _ _ k âŸ¨k_mem, k_neqâŸ©\n  change ((Units.mk0 k k_neq) : ğ•œ) âˆˆ _ at k_mem\n  exact âŸ¨unit_mem_mul_iff_mem_swap_mul.mp k_mem, k_neqâŸ©\n\n"}
{"name":"spectrum.map_inv","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"ğ•œ : Type u\nA : Type v\ninstâœÂ² : Field ğ•œ\ninstâœÂ¹ : Ring A\ninstâœ : Algebra ğ•œ A\na : Units A\nâŠ¢ Eq (Inv.inv (spectrum ğ•œ â†‘a)) (spectrum ğ•œ â†‘(Inv.inv a))","decl":"protected theorem map_inv (a : AË£) : (Ïƒ (a : A))â»Â¹ = Ïƒ (â†‘aâ»Â¹ : A) := by\n  refine Set.eq_of_subset_of_subset (fun k hk => ?_) fun k hk => ?_\n  Â· rw [Set.mem_inv] at hk\n    have : k â‰  0 := by simpa only [inv_inv] using inv_ne_zero (ne_zero_of_mem_of_unit hk)\n    lift k to ğ•œË£ using isUnit_iff_ne_zero.mpr this\n    rw [â† Units.val_inv_eq_inv_val k] at hk\n    exact inv_mem_iff.mp hk\n  Â· lift k to ğ•œË£ using isUnit_iff_ne_zero.mpr (ne_zero_of_mem_of_unit hk)\n    simpa only [Units.val_inv_eq_inv_val] using inv_mem_iff.mp hk\n\n"}
{"name":"AlgHom.mem_resolventSet_apply","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"F : Type u_1\nR : Type u_2\nA : Type u_3\nB : Type u_4\ninstâœâ¶ : CommSemiring R\ninstâœâµ : Ring A\ninstâœâ´ : Algebra R A\ninstâœÂ³ : Ring B\ninstâœÂ² : Algebra R B\ninstâœÂ¹ : FunLike F A B\ninstâœ : AlgHomClass F R A B\nÏ† : F\na : A\nr : R\nh : Membership.mem (resolventSet R a) r\nâŠ¢ Membership.mem (resolventSet R (Ï† a)) r","decl":"theorem mem_resolventSet_apply (Ï† : F) {a : A} {r : R} (h : r âˆˆ resolventSet R a) :\n    r âˆˆ resolventSet R ((Ï† : A â†’ B) a) := by\n  simpa only [map_sub, AlgHomClass.commutes] using h.map Ï†\n\n"}
{"name":"AlgHom.spectrum_apply_subset","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"F : Type u_1\nR : Type u_2\nA : Type u_3\nB : Type u_4\ninstâœâ¶ : CommSemiring R\ninstâœâµ : Ring A\ninstâœâ´ : Algebra R A\ninstâœÂ³ : Ring B\ninstâœÂ² : Algebra R B\ninstâœÂ¹ : FunLike F A B\ninstâœ : AlgHomClass F R A B\nÏ† : F\na : A\nâŠ¢ HasSubset.Subset (spectrum R (Ï† a)) (spectrum R a)","decl":"theorem spectrum_apply_subset (Ï† : F) (a : A) : Ïƒ ((Ï† : A â†’ B) a) âŠ† Ïƒ a := fun _ =>\n  mt (mem_resolventSet_apply Ï†)\n\n"}
{"name":"AlgHom.apply_mem_spectrum","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"F : Type u_1\nR : Type u_2\nA : Type u_3\ninstâœâµ : CommRing R\ninstâœâ´ : Ring A\ninstâœÂ³ : Algebra R A\ninstâœÂ² : FunLike F A R\ninstâœÂ¹ : AlgHomClass F R A R\ninstâœ : Nontrivial R\nÏ† : F\na : A\nâŠ¢ Membership.mem (spectrum R a) (Ï† a)","decl":"theorem apply_mem_spectrum [Nontrivial R] (Ï† : F) (a : A) : Ï† a âˆˆ Ïƒ a := by\n  have h : â†‘â‚ (Ï† a) - a âˆˆ RingHom.ker (Ï† : A â†’+* R) := by\n    simp only [RingHom.mem_ker, map_sub, RingHom.coe_coe, AlgHomClass.commutes,\n      Algebra.id.map_eq_id, RingHom.id_apply, sub_self]\n  simp only [spectrum.mem_iff, â† mem_nonunits_iff,\n    coe_subset_nonunits (RingHom.ker_ne_top (Ï† : A â†’+* R)) h]\n\n"}
{"name":"AlgEquiv.spectrum_eq","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"F : Type u_1\nR : Type u_2\nA : Type u_3\nB : Type u_4\ninstâœâ¶ : CommSemiring R\ninstâœâµ : Ring A\ninstâœâ´ : Ring B\ninstâœÂ³ : Algebra R A\ninstâœÂ² : Algebra R B\ninstâœÂ¹ : EquivLike F A B\ninstâœ : AlgEquivClass F R A B\nf : F\na : A\nâŠ¢ Eq (spectrum R (f a)) (spectrum R a)","decl":"@[simp]\ntheorem AlgEquiv.spectrum_eq {F R A B : Type*} [CommSemiring R] [Ring A] [Ring B] [Algebra R A]\n    [Algebra R B] [EquivLike F A B] [AlgEquivClass F R A B] (f : F) (a : A) :\n    spectrum R (f a) = spectrum R a :=\n  Set.Subset.antisymm (AlgHom.spectrum_apply_subset _ _) <| by\n    simpa only [AlgEquiv.coe_algHom, AlgEquiv.coe_coe_symm_apply_coe_apply] using\n      AlgHom.spectrum_apply_subset (f : A â‰ƒâ‚[R] B).symm (f a)\n\n"}
{"name":"spectrum.units_conjugate","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u_1\nA : Type u_2\ninstâœÂ² : CommSemiring R\ninstâœÂ¹ : Ring A\ninstâœ : Algebra R A\na : A\nu : Units A\nâŠ¢ Eq (spectrum R (HMul.hMul (HMul.hMul (â†‘u) a) â†‘(Inv.inv u))) (spectrum R a)","decl":"/-- Conjugation by a unit preserves the spectrum, inverse on right. -/\n@[simp]\nlemma spectrum.units_conjugate {a : A} {u : AË£} :\n    spectrum R (u * a * uâ»Â¹) = spectrum R a := by\n  suffices âˆ€ (b : A) (v : AË£), spectrum R (v * b * vâ»Â¹) âŠ† spectrum R b by\n    refine le_antisymm (this a u) ?_\n    apply le_of_eq_of_le ?_ <| this (u * a * uâ»Â¹) uâ»Â¹\n    simp [mul_assoc]\n  intro a u Î¼ hÎ¼\n  rw [spectrum.mem_iff] at hÎ¼ âŠ¢\n  contrapose! hÎ¼\n  simpa [mul_sub, sub_mul, Algebra.right_comm] using u.isUnit.mul hÎ¼ |>.mul uâ»Â¹.isUnit\n\n"}
{"name":"spectrum.units_conjugate'","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u_1\nA : Type u_2\ninstâœÂ² : CommSemiring R\ninstâœÂ¹ : Ring A\ninstâœ : Algebra R A\na : A\nu : Units A\nâŠ¢ Eq (spectrum R (HMul.hMul (HMul.hMul (â†‘(Inv.inv u)) a) â†‘u)) (spectrum R a)","decl":"/-- Conjugation by a unit preserves the spectrum, inverse on left. -/\n@[simp]\nlemma spectrum.units_conjugate' {a : A} {u : AË£} :\n    spectrum R (uâ»Â¹ * a * u) = spectrum R a := by\n  simpa using spectrum.units_conjugate (u := uâ»Â¹)\n\n"}
