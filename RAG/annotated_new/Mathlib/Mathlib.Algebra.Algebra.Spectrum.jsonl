{"name":"IsUnit.val_inv_subInvSMul","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nr : Units R\ns : R\na : A\nh : IsUnit (HSub.hSub (HSMul.hSMul r ((algebraMap R A) s)) a)\n⊢ Eq (↑(Inv.inv h.subInvSMul)) (HSMul.hSMul r ↑(Inv.inv h.unit))","decl":"/-- The unit `1 - r⁻¹ • a` constructed from `r • 1 - a` when the latter is a unit. -/\n@[simps]\nnoncomputable def IsUnit.subInvSMul {r : Rˣ} {s : R} {a : A} (h : IsUnit <| r • ↑ₐ s - a) : Aˣ where\n  val := ↑ₐ s - r⁻¹ • a\n  inv := r • ↑h.unit⁻¹\n  val_inv := by rw [mul_smul_comm, ← smul_mul_assoc, smul_sub, smul_inv_smul, h.mul_val_inv]\n  inv_val := by rw [smul_mul_assoc, ← mul_smul_comm, smul_sub, smul_inv_smul, h.val_inv_mul]\n\n"}
{"name":"IsUnit.val_subInvSMul","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nr : Units R\ns : R\na : A\nh : IsUnit (HSub.hSub (HSMul.hSMul r ((algebraMap R A) s)) a)\n⊢ Eq (↑h.subInvSMul) (HSub.hSub ((algebraMap R A) s) (HSMul.hSMul (Inv.inv r) a))","decl":"/-- The unit `1 - r⁻¹ • a` constructed from `r • 1 - a` when the latter is a unit. -/\n@[simps]\nnoncomputable def IsUnit.subInvSMul {r : Rˣ} {s : R} {a : A} (h : IsUnit <| r • ↑ₐ s - a) : Aˣ where\n  val := ↑ₐ s - r⁻¹ • a\n  inv := r • ↑h.unit⁻¹\n  val_inv := by rw [mul_smul_comm, ← smul_mul_assoc, smul_sub, smul_inv_smul, h.mul_val_inv]\n  inv_val := by rw [smul_mul_assoc, ← mul_smul_comm, smul_sub, smul_inv_smul, h.val_inv_mul]\n\n"}
{"name":"spectrum.mem_iff","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nr : R\na : A\n⊢ Iff (Membership.mem (spectrum R a) r) (Not (IsUnit (HSub.hSub ((algebraMap R A) r) a)))","decl":"theorem mem_iff {r : R} {a : A} : r ∈ σ a ↔ ¬IsUnit (↑ₐ r - a) :=\n  Iff.rfl\n\n"}
{"name":"spectrum.not_mem_iff","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nr : R\na : A\n⊢ Iff (Not (Membership.mem (spectrum R a) r)) (IsUnit (HSub.hSub ((algebraMap R A) r) a))","decl":"theorem not_mem_iff {r : R} {a : A} : r ∉ σ a ↔ IsUnit (↑ₐ r - a) := by\n  apply not_iff_not.mp\n  simp [Set.not_not_mem, mem_iff]\n\n"}
{"name":"spectrum.zero_mem_iff","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\na : A\n⊢ Iff (Membership.mem (spectrum R a) 0) (Not (IsUnit a))","decl":"theorem zero_mem_iff {a : A} : (0 : R) ∈ σ a ↔ ¬IsUnit a := by\n  rw [mem_iff, map_zero, zero_sub, IsUnit.neg_iff]\n\n"}
{"name":"spectrum.zero_mem","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\na : A\na✝ : Not (IsUnit a)\n⊢ Membership.mem (spectrum R a) 0","decl":"alias ⟨not_isUnit_of_zero_mem, zero_mem⟩ := spectrum.zero_mem_iff\n\n"}
{"name":"spectrum.not_isUnit_of_zero_mem","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\na : A\na✝ : Membership.mem (spectrum R a) 0\n⊢ Not (IsUnit a)","decl":"alias ⟨not_isUnit_of_zero_mem, zero_mem⟩ := spectrum.zero_mem_iff\n\n"}
{"name":"spectrum.zero_not_mem_iff","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\na : A\n⊢ Iff (Not (Membership.mem (spectrum R a) 0)) (IsUnit a)","decl":"theorem zero_not_mem_iff {a : A} : (0 : R) ∉ σ a ↔ IsUnit a := by\n  rw [zero_mem_iff, Classical.not_not]\n\n"}
{"name":"spectrum.zero_not_mem","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\na : A\na✝ : IsUnit a\n⊢ Not (Membership.mem (spectrum R a) 0)","decl":"alias ⟨isUnit_of_zero_not_mem, zero_not_mem⟩ := spectrum.zero_not_mem_iff\n\n"}
{"name":"spectrum.isUnit_of_zero_not_mem","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\na : A\na✝ : Not (Membership.mem (spectrum R a) 0)\n⊢ IsUnit a","decl":"alias ⟨isUnit_of_zero_not_mem, zero_not_mem⟩ := spectrum.zero_not_mem_iff\n\n"}
{"name":"Units.zero_not_mem_spectrum","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\na : Units A\n⊢ Not (Membership.mem (spectrum R ↑a) 0)","decl":"@[simp]\nlemma _root_.Units.zero_not_mem_spectrum (a : Aˣ) : 0 ∉ spectrum R (a : A) :=\n  spectrum.zero_not_mem R a.isUnit\n\n"}
{"name":"spectrum.subset_singleton_zero_compl","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\na : A\nha : IsUnit a\n⊢ HasSubset.Subset (spectrum R a) (HasCompl.compl (Singleton.singleton 0))","decl":"lemma subset_singleton_zero_compl {a : A} (ha : IsUnit a) : spectrum R a ⊆ {0}ᶜ :=\n  Set.subset_compl_singleton_iff.mpr <| spectrum.zero_not_mem R ha\n\n"}
{"name":"spectrum.mem_resolventSet_of_left_right_inverse","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nr : R\na b c : A\nh₁ : Eq (HMul.hMul (HSub.hSub ((algebraMap R A) r) a) b) 1\nh₂ : Eq (HMul.hMul c (HSub.hSub ((algebraMap R A) r) a)) 1\n⊢ Membership.mem (resolventSet R a) r","decl":"theorem mem_resolventSet_of_left_right_inverse {r : R} {a b c : A} (h₁ : (↑ₐ r - a) * b = 1)\n    (h₂ : c * (↑ₐ r - a) = 1) : r ∈ resolventSet R a :=\n  Units.isUnit ⟨↑ₐ r - a, b, h₁, by rwa [← left_inv_eq_right_inv h₂ h₁]⟩\n\n"}
{"name":"spectrum.mem_resolventSet_iff","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nr : R\na : A\n⊢ Iff (Membership.mem (resolventSet R a) r) (IsUnit (HSub.hSub ((algebraMap R A) r) a))","decl":"theorem mem_resolventSet_iff {r : R} {a : A} : r ∈ resolventSet R a ↔ IsUnit (↑ₐ r - a) :=\n  Iff.rfl\n\n"}
{"name":"spectrum.algebraMap_mem_iff","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"S : Type u_1\nR : Type u_2\nA : Type u_3\ninst✝⁶ : CommSemiring R\ninst✝⁵ : CommSemiring S\ninst✝⁴ : Ring A\ninst✝³ : Algebra R S\ninst✝² : Algebra R A\ninst✝¹ : Algebra S A\ninst✝ : IsScalarTower R S A\na : A\nr : R\n⊢ Iff (Membership.mem (spectrum S a) ((algebraMap R S) r)) (Membership.mem (spectrum R a) r)","decl":"@[simp]\ntheorem algebraMap_mem_iff (S : Type*) {R A : Type*} [CommSemiring R] [CommSemiring S]\n    [Ring A] [Algebra R S] [Algebra R A] [Algebra S A] [IsScalarTower R S A] {a : A} {r : R} :\n    algebraMap R S r ∈ spectrum S a ↔ r ∈ spectrum R a := by\n  simp only [spectrum.mem_iff, Algebra.algebraMap_eq_smul_one, smul_assoc, one_smul]\n\n"}
{"name":"spectrum.algebraMap_mem","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"S : Type u_1\nR : Type u_2\nA : Type u_3\ninst✝⁶ : CommSemiring R\ninst✝⁵ : CommSemiring S\ninst✝⁴ : Ring A\ninst✝³ : Algebra R S\ninst✝² : Algebra R A\ninst✝¹ : Algebra S A\ninst✝ : IsScalarTower R S A\na : A\nr : R\na✝ : Membership.mem (spectrum R a) r\n⊢ Membership.mem (spectrum S a) ((algebraMap R S) r)","decl":"protected alias ⟨of_algebraMap_mem, algebraMap_mem⟩ := spectrum.algebraMap_mem_iff\n\n"}
{"name":"spectrum.of_algebraMap_mem","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"S : Type u_1\nR : Type u_2\nA : Type u_3\ninst✝⁶ : CommSemiring R\ninst✝⁵ : CommSemiring S\ninst✝⁴ : Ring A\ninst✝³ : Algebra R S\ninst✝² : Algebra R A\ninst✝¹ : Algebra S A\ninst✝ : IsScalarTower R S A\na : A\nr : R\na✝ : Membership.mem (spectrum S a) ((algebraMap R S) r)\n⊢ Membership.mem (spectrum R a) r","decl":"protected alias ⟨of_algebraMap_mem, algebraMap_mem⟩ := spectrum.algebraMap_mem_iff\n\n"}
{"name":"spectrum.preimage_algebraMap","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"S : Type u_1\nR : Type u_2\nA : Type u_3\ninst✝⁶ : CommSemiring R\ninst✝⁵ : CommSemiring S\ninst✝⁴ : Ring A\ninst✝³ : Algebra R S\ninst✝² : Algebra R A\ninst✝¹ : Algebra S A\ninst✝ : IsScalarTower R S A\na : A\n⊢ Eq (Set.preimage (⇑(algebraMap R S)) (spectrum S a)) (spectrum R a)","decl":"@[simp]\ntheorem preimage_algebraMap (S : Type*) {R A : Type*} [CommSemiring R] [CommSemiring S]\n    [Ring A] [Algebra R S] [Algebra R A] [Algebra S A] [IsScalarTower R S A] {a : A} :\n    algebraMap R S ⁻¹' spectrum S a = spectrum R a :=\n  Set.ext fun _ => spectrum.algebraMap_mem_iff _\n\n"}
{"name":"spectrum.resolventSet_of_subsingleton","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninst✝³ : CommSemiring R\ninst✝² : Ring A\ninst✝¹ : Algebra R A\ninst✝ : Subsingleton A\na : A\n⊢ Eq (resolventSet R a) Set.univ","decl":"@[simp]\ntheorem resolventSet_of_subsingleton [Subsingleton A] (a : A) : resolventSet R a = Set.univ := by\n  simp_rw [resolventSet, Subsingleton.elim (algebraMap R A _ - a) 1, isUnit_one, Set.setOf_true]\n\n"}
{"name":"spectrum.of_subsingleton","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninst✝³ : CommSemiring R\ninst✝² : Ring A\ninst✝¹ : Algebra R A\ninst✝ : Subsingleton A\na : A\n⊢ Eq (spectrum R a) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem of_subsingleton [Subsingleton A] (a : A) : spectrum R a = ∅ := by\n  rw [spectrum, resolventSet_of_subsingleton, Set.compl_univ]\n\n"}
{"name":"spectrum.resolvent_eq","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\na : A\nr : R\nh : Membership.mem (resolventSet R a) r\n⊢ Eq (resolvent a r) ↑(Inv.inv (IsUnit.unit h))","decl":"theorem resolvent_eq {a : A} {r : R} (h : r ∈ resolventSet R a) : resolvent a r = ↑h.unit⁻¹ :=\n  Ring.inverse_unit h.unit\n\n"}
{"name":"spectrum.units_smul_resolvent","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nr : Units R\ns : R\na : A\n⊢ Eq (HSMul.hSMul r (resolvent a s)) (resolvent (HSMul.hSMul (Inv.inv r) a) (HSMul.hSMul (Inv.inv r) s))","decl":"theorem units_smul_resolvent {r : Rˣ} {s : R} {a : A} :\n    r • resolvent a (s : R) = resolvent (r⁻¹ • a) (r⁻¹ • s : R) := by\n  by_cases h : s ∈ spectrum R a\n  · rw [mem_iff] at h\n    simp only [resolvent, Algebra.algebraMap_eq_smul_one] at *\n    rw [smul_assoc, ← smul_sub]\n    have h' : ¬IsUnit (r⁻¹ • (s • (1 : A) - a)) := fun hu =>\n      h (by simpa only [smul_inv_smul] using IsUnit.smul r hu)\n    simp only [Ring.inverse_non_unit _ h, Ring.inverse_non_unit _ h', smul_zero]\n  · simp only [resolvent]\n    have h' : IsUnit (r • algebraMap R A (r⁻¹ • s) - a) := by\n      simpa [Algebra.algebraMap_eq_smul_one, smul_assoc] using not_mem_iff.mp h\n    rw [← h'.val_subInvSMul, ← (not_mem_iff.mp h).unit_spec, Ring.inverse_unit, Ring.inverse_unit,\n      h'.val_inv_subInvSMul]\n    simp only [Algebra.algebraMap_eq_smul_one, smul_assoc, smul_inv_smul]\n\n"}
{"name":"spectrum.units_smul_resolvent_self","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nr : Units R\na : A\n⊢ Eq (HSMul.hSMul r (resolvent a ↑r)) (resolvent (HSMul.hSMul (Inv.inv r) a) 1)","decl":"theorem units_smul_resolvent_self {r : Rˣ} {a : A} :\n    r • resolvent a (r : R) = resolvent (r⁻¹ • a) (1 : R) := by\n  simpa only [Units.smul_def, Algebra.id.smul_eq_mul, Units.inv_mul] using\n    @units_smul_resolvent _ _ _ _ _ r r a\n\n"}
{"name":"spectrum.isUnit_resolvent","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nr : R\na : A\n⊢ Iff (Membership.mem (resolventSet R a) r) (IsUnit (resolvent a r))","decl":"/-- The resolvent is a unit when the argument is in the resolvent set. -/\ntheorem isUnit_resolvent {r : R} {a : A} : r ∈ resolventSet R a ↔ IsUnit (resolvent a r) :=\n  isUnit_ring_inverse.symm\n\n"}
{"name":"spectrum.inv_mem_resolventSet","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nr : Units R\na : Units A\nh : Membership.mem (resolventSet R ↑a) ↑r\n⊢ Membership.mem (resolventSet R ↑(Inv.inv a)) ↑(Inv.inv r)","decl":"theorem inv_mem_resolventSet {r : Rˣ} {a : Aˣ} (h : (r : R) ∈ resolventSet R (a : A)) :\n    (↑r⁻¹ : R) ∈ resolventSet R (↑a⁻¹ : A) := by\n  rw [mem_resolventSet_iff, Algebra.algebraMap_eq_smul_one, ← Units.smul_def] at h ⊢\n  rw [IsUnit.smul_sub_iff_sub_inv_smul, inv_inv, IsUnit.sub_iff]\n  have h₁ : (a : A) * (r • (↑a⁻¹ : A) - 1) = r • (1 : A) - a := by\n    rw [mul_sub, mul_smul_comm, a.mul_inv, mul_one]\n  have h₂ : (r • (↑a⁻¹ : A) - 1) * a = r • (1 : A) - a := by\n    rw [sub_mul, smul_mul_assoc, a.inv_mul, one_mul]\n  have hcomm : Commute (a : A) (r • (↑a⁻¹ : A) - 1) := by rwa [← h₂] at h₁\n  exact (hcomm.isUnit_mul_iff.mp (h₁.symm ▸ h)).2\n\n"}
{"name":"spectrum.inv_mem_iff","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nr : Units R\na : Units A\n⊢ Iff (Membership.mem (spectrum R ↑a) ↑r) (Membership.mem (spectrum R ↑(Inv.inv a)) ↑(Inv.inv r))","decl":"theorem inv_mem_iff {r : Rˣ} {a : Aˣ} : (r : R) ∈ σ (a : A) ↔ (↑r⁻¹ : R) ∈ σ (↑a⁻¹ : A) :=\n  not_iff_not.2 <| ⟨inv_mem_resolventSet, inv_mem_resolventSet⟩\n\n"}
{"name":"spectrum.zero_mem_resolventSet_of_unit","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\na : Units A\n⊢ Membership.mem (resolventSet R ↑a) 0","decl":"theorem zero_mem_resolventSet_of_unit (a : Aˣ) : 0 ∈ resolventSet R (a : A) := by\n  simpa only [mem_resolventSet_iff, ← not_mem_iff, zero_not_mem_iff] using a.isUnit\n\n"}
{"name":"spectrum.ne_zero_of_mem_of_unit","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\na : Units A\nr : R\nhr : Membership.mem (spectrum R ↑a) r\n⊢ Ne r 0","decl":"theorem ne_zero_of_mem_of_unit {a : Aˣ} {r : R} (hr : r ∈ σ (a : A)) : r ≠ 0 := fun hn =>\n  (hn ▸ hr) (zero_mem_resolventSet_of_unit a)\n\n"}
{"name":"spectrum.add_mem_iff","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\na : A\nr s : R\n⊢ Iff (Membership.mem (spectrum R a) (HAdd.hAdd r s)) (Membership.mem (spectrum R (HAdd.hAdd (Neg.neg ((algebraMap R A) s)) a)) r)","decl":"theorem add_mem_iff {a : A} {r s : R} : r + s ∈ σ a ↔ r ∈ σ (-↑ₐ s + a) := by\n  simp only [mem_iff, sub_neg_eq_add, ← sub_sub, map_add]\n\n"}
{"name":"spectrum.add_mem_add_iff","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\na : A\nr s : R\n⊢ Iff (Membership.mem (spectrum R (HAdd.hAdd ((algebraMap R A) s) a)) (HAdd.hAdd r s)) (Membership.mem (spectrum R a) r)","decl":"theorem add_mem_add_iff {a : A} {r s : R} : r + s ∈ σ (↑ₐ s + a) ↔ r ∈ σ a := by\n  rw [add_mem_iff, neg_add_cancel_left]\n\n"}
{"name":"spectrum.smul_mem_smul_iff","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\na : A\ns : R\nr : Units R\n⊢ Iff (Membership.mem (spectrum R (HSMul.hSMul r a)) (HSMul.hSMul r s)) (Membership.mem (spectrum R a) s)","decl":"theorem smul_mem_smul_iff {a : A} {s : R} {r : Rˣ} : r • s ∈ σ (r • a) ↔ s ∈ σ a := by\n  simp only [mem_iff, not_iff_not, Algebra.algebraMap_eq_smul_one, smul_assoc, ← smul_sub,\n    isUnit_smul_iff]\n\n"}
{"name":"spectrum.unit_smul_eq_smul","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\na : A\nr : Units R\n⊢ Eq (spectrum R (HSMul.hSMul r a)) (HSMul.hSMul r (spectrum R a))","decl":"theorem unit_smul_eq_smul (a : A) (r : Rˣ) : σ (r • a) = r • σ a := by\n  ext x\n  have x_eq : x = r • r⁻¹ • x := by simp\n  nth_rw 1 [x_eq]\n  rw [smul_mem_smul_iff]\n  constructor\n  · exact fun h => ⟨r⁻¹ • x, ⟨h, show r • r⁻¹ • x = x by simp⟩⟩\n  · rintro ⟨w, _, (x'_eq : r • w = x)⟩\n    simpa [← x'_eq ]\n\n-- `r ∈ σ(a*b) ↔ r ∈ σ(b*a)` for any `r : Rˣ`\n"}
{"name":"spectrum.unit_mem_mul_iff_mem_swap_mul","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\na b : A\nr : Units R\n⊢ Iff (Membership.mem (spectrum R (HMul.hMul a b)) ↑r) (Membership.mem (spectrum R (HMul.hMul b a)) ↑r)","decl":"theorem unit_mem_mul_iff_mem_swap_mul {a b : A} {r : Rˣ} : ↑r ∈ σ (a * b) ↔ ↑r ∈ σ (b * a) := by\n  have h₁ : ∀ x y : A, IsUnit (1 - x * y) → IsUnit (1 - y * x) := by\n    refine fun x y h => ⟨⟨1 - y * x, 1 + y * h.unit.inv * x, ?_, ?_⟩, rfl⟩\n    · calc\n        (1 - y * x) * (1 + y * (IsUnit.unit h).inv * x) =\n            1 - y * x + y * ((1 - x * y) * h.unit.inv) * x := by noncomm_ring\n        _ = 1 := by simp only [Units.inv_eq_val_inv, IsUnit.mul_val_inv, mul_one, sub_add_cancel]\n    · calc\n        (1 + y * (IsUnit.unit h).inv * x) * (1 - y * x) =\n            1 - y * x + y * (h.unit.inv * (1 - x * y)) * x := by noncomm_ring\n        _ = 1 := by simp only [Units.inv_eq_val_inv, IsUnit.val_inv_mul, mul_one, sub_add_cancel]\n  have := Iff.intro (h₁ (r⁻¹ • a) b) (h₁ b (r⁻¹ • a))\n  rw [mul_smul_comm r⁻¹ b a] at this\n  simpa only [mem_iff, not_iff_not, Algebra.algebraMap_eq_smul_one, ← Units.smul_def,\n    IsUnit.smul_sub_iff_sub_inv_smul, smul_mul_assoc]\n\n"}
{"name":"spectrum.preimage_units_mul_eq_swap_mul","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\na b : A\n⊢ Eq (Set.preimage Units.val (spectrum R (HMul.hMul a b))) (Set.preimage Units.val (spectrum R (HMul.hMul b a)))","decl":"theorem preimage_units_mul_eq_swap_mul {a b : A} :\n    ((↑) : Rˣ → R) ⁻¹' σ (a * b) = (↑) ⁻¹' σ (b * a) :=\n  Set.ext fun _ => unit_mem_mul_iff_mem_swap_mul\n\n"}
{"name":"spectrum.star_mem_resolventSet_iff","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninst✝⁵ : CommSemiring R\ninst✝⁴ : Ring A\ninst✝³ : Algebra R A\ninst✝² : InvolutiveStar R\ninst✝¹ : StarRing A\ninst✝ : StarModule R A\nr : R\na : A\n⊢ Iff (Membership.mem (resolventSet R a) (Star.star r)) (Membership.mem (resolventSet R (Star.star a)) r)","decl":"theorem star_mem_resolventSet_iff {r : R} {a : A} :\n    star r ∈ resolventSet R a ↔ r ∈ resolventSet R (star a) := by\n  refine ⟨fun h => ?_, fun h => ?_⟩ <;>\n    simpa only [mem_resolventSet_iff, Algebra.algebraMap_eq_smul_one, star_sub, star_smul,\n      star_star, star_one] using IsUnit.star h\n\n"}
{"name":"spectrum.map_star","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninst✝⁵ : CommSemiring R\ninst✝⁴ : Ring A\ninst✝³ : Algebra R A\ninst✝² : InvolutiveStar R\ninst✝¹ : StarRing A\ninst✝ : StarModule R A\na : A\n⊢ Eq (spectrum R (Star.star a)) (Star.star (spectrum R a))","decl":"protected theorem map_star (a : A) : σ (star a) = star (σ a) := by\n  ext\n  simpa only [Set.mem_star, mem_iff, not_iff_not] using star_mem_resolventSet_iff.symm\n\n"}
{"name":"spectrum.subset_subalgebra","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"S : Type u_1\nR : Type u_2\nA : Type u_3\ninst✝⁵ : CommSemiring R\ninst✝⁴ : Ring A\ninst✝³ : Algebra R A\ninst✝² : SetLike S A\ninst✝¹ : SubringClass S A\ninst✝ : SMulMemClass S R A\ns : S\na : Subtype fun x => Membership.mem s x\n⊢ HasSubset.Subset (spectrum R ↑a) (spectrum R a)","decl":"theorem subset_subalgebra {S R A : Type*} [CommSemiring R] [Ring A] [Algebra R A]\n    [SetLike S A] [SubringClass S A] [SMulMemClass S R A] {s : S} (a : s) :\n    spectrum R (a : A) ⊆ spectrum R a :=\n  Set.compl_subset_compl.mpr fun _ ↦ IsUnit.map (SubalgebraClass.val s)\n\n"}
{"name":"spectrum.singleton_add_eq","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\na : A\nr : R\n⊢ Eq (HAdd.hAdd (Singleton.singleton r) (spectrum R a)) (spectrum R (HAdd.hAdd ((algebraMap R A) r) a))","decl":"theorem singleton_add_eq (a : A) (r : R) : {r} + σ a = σ (↑ₐ r + a) :=\n  ext fun x => by\n    rw [singleton_add, image_add_left, mem_preimage, add_comm, add_mem_iff, map_neg, neg_neg]\n\n"}
{"name":"spectrum.add_singleton_eq","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\na : A\nr : R\n⊢ Eq (HAdd.hAdd (spectrum R a) (Singleton.singleton r)) (spectrum R (HAdd.hAdd a ((algebraMap R A) r)))","decl":"theorem add_singleton_eq (a : A) (r : R) : σ a + {r} = σ (a + ↑ₐ r) :=\n  add_comm {r} (σ a) ▸ add_comm (algebraMap R A r) a ▸ singleton_add_eq a r\n\n"}
{"name":"spectrum.vadd_eq","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\na : A\nr : R\n⊢ Eq (HVAdd.hVAdd r (spectrum R a)) (spectrum R (HAdd.hAdd ((algebraMap R A) r) a))","decl":"theorem vadd_eq (a : A) (r : R) : r +ᵥ σ a = σ (↑ₐ r + a) :=\n  singleton_add.symm.trans <| singleton_add_eq a r\n\n"}
{"name":"spectrum.neg_eq","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\na : A\n⊢ Eq (Neg.neg (spectrum R a)) (spectrum R (Neg.neg a))","decl":"theorem neg_eq (a : A) : -σ a = σ (-a) :=\n  Set.ext fun x => by\n    simp only [mem_neg, mem_iff, map_neg, ← neg_add', IsUnit.neg_iff, sub_neg_eq_add]\n\n"}
{"name":"spectrum.singleton_sub_eq","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\na : A\nr : R\n⊢ Eq (HSub.hSub (Singleton.singleton r) (spectrum R a)) (spectrum R (HSub.hSub ((algebraMap R A) r) a))","decl":"theorem singleton_sub_eq (a : A) (r : R) : {r} - σ a = σ (↑ₐ r - a) := by\n  rw [sub_eq_add_neg, neg_eq, singleton_add_eq, sub_eq_add_neg]\n\n"}
{"name":"spectrum.sub_singleton_eq","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\na : A\nr : R\n⊢ Eq (HSub.hSub (spectrum R a) (Singleton.singleton r)) (spectrum R (HSub.hSub a ((algebraMap R A) r)))","decl":"theorem sub_singleton_eq (a : A) (r : R) : σ a - {r} = σ (a - ↑ₐ r) := by\n  simpa only [neg_sub, neg_eq] using congr_arg Neg.neg (singleton_sub_eq a r)\n\n"}
{"name":"spectrum.inv₀_mem_iff","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninst✝² : Semifield R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nr : R\na : Units A\n⊢ Iff (Membership.mem (spectrum R ↑a) (Inv.inv r)) (Membership.mem (spectrum R ↑(Inv.inv a)) r)","decl":"@[simp]\nlemma inv₀_mem_iff {r : R} {a : Aˣ} :\n    r⁻¹ ∈ spectrum R (a : A) ↔ r ∈ spectrum R (↑a⁻¹ : A) := by\n  obtain (rfl | hr) := eq_or_ne r 0\n  · simp [zero_mem_iff]\n  · lift r to Rˣ using hr.isUnit\n    simp [inv_mem_iff]\n\n"}
{"name":"spectrum.inv₀_mem_inv_iff","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninst✝² : Semifield R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nr : R\na : Units A\n⊢ Iff (Membership.mem (spectrum R ↑(Inv.inv a)) (Inv.inv r)) (Membership.mem (spectrum R ↑a) r)","decl":"lemma inv₀_mem_inv_iff {r : R} {a : Aˣ} :\n    r⁻¹ ∈ spectrum R (↑a⁻¹ : A) ↔ r ∈ spectrum R (a : A) := by\n  simp\n\n"}
{"name":"spectrum.inv₀_mem","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninst✝² : Semifield R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nr : R\na : Units A\na✝ : Membership.mem (spectrum R ↑(Inv.inv a)) r\n⊢ Membership.mem (spectrum R ↑a) (Inv.inv r)","decl":"alias ⟨of_inv₀_mem, inv₀_mem⟩ := inv₀_mem_iff\n"}
{"name":"spectrum.of_inv₀_mem","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninst✝² : Semifield R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nr : R\na : Units A\na✝ : Membership.mem (spectrum R ↑a) (Inv.inv r)\n⊢ Membership.mem (spectrum R ↑(Inv.inv a)) r","decl":"alias ⟨of_inv₀_mem, inv₀_mem⟩ := inv₀_mem_iff\n"}
{"name":"spectrum.of_inv₀_mem_inv","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninst✝² : Semifield R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nr : R\na : Units A\na✝ : Membership.mem (spectrum R ↑(Inv.inv a)) (Inv.inv r)\n⊢ Membership.mem (spectrum R ↑a) r","decl":"alias ⟨of_inv₀_mem_inv, inv₀_mem_inv⟩ := inv₀_mem_inv_iff\n\n"}
{"name":"spectrum.inv₀_mem_inv","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u\nA : Type v\ninst✝² : Semifield R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nr : R\na : Units A\na✝ : Membership.mem (spectrum R ↑a) r\n⊢ Membership.mem (spectrum R ↑(Inv.inv a)) (Inv.inv r)","decl":"alias ⟨of_inv₀_mem_inv, inv₀_mem_inv⟩ := inv₀_mem_inv_iff\n\n"}
{"name":"spectrum.zero_eq","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"𝕜 : Type u\nA : Type v\ninst✝³ : Field 𝕜\ninst✝² : Ring A\ninst✝¹ : Algebra 𝕜 A\ninst✝ : Nontrivial A\n⊢ Eq (spectrum 𝕜 0) (Singleton.singleton 0)","decl":"/-- Without the assumption `Nontrivial A`, then `0 : A` would be invertible. -/\n@[simp]\ntheorem zero_eq [Nontrivial A] : σ (0 : A) = {0} := by\n  refine Set.Subset.antisymm ?_ (by simp [Algebra.algebraMap_eq_smul_one, mem_iff])\n  rw [spectrum, Set.compl_subset_comm]\n  intro k hk\n  rw [Set.mem_compl_singleton_iff] at hk\n  have : IsUnit (Units.mk0 k hk • (1 : A)) := IsUnit.smul (Units.mk0 k hk) isUnit_one\n  simpa [mem_resolventSet_iff, Algebra.algebraMap_eq_smul_one]\n\n"}
{"name":"spectrum.scalar_eq","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"𝕜 : Type u\nA : Type v\ninst✝³ : Field 𝕜\ninst✝² : Ring A\ninst✝¹ : Algebra 𝕜 A\ninst✝ : Nontrivial A\nk : 𝕜\n⊢ Eq (spectrum 𝕜 ((algebraMap 𝕜 A) k)) (Singleton.singleton k)","decl":"@[simp]\ntheorem scalar_eq [Nontrivial A] (k : 𝕜) : σ (↑ₐ k) = {k} := by\n  rw [← add_zero (↑ₐ k), ← singleton_add_eq, zero_eq, Set.singleton_add_singleton, add_zero]\n\n"}
{"name":"spectrum.one_eq","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"𝕜 : Type u\nA : Type v\ninst✝³ : Field 𝕜\ninst✝² : Ring A\ninst✝¹ : Algebra 𝕜 A\ninst✝ : Nontrivial A\n⊢ Eq (spectrum 𝕜 1) (Singleton.singleton 1)","decl":"@[simp]\ntheorem one_eq [Nontrivial A] : σ (1 : A) = {1} :=\n  calc\n    σ (1 : A) = σ (↑ₐ 1) := by rw [Algebra.algebraMap_eq_smul_one, one_smul]\n    _ = {1} := scalar_eq 1\n\n"}
{"name":"spectrum.smul_eq_smul","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"𝕜 : Type u\nA : Type v\ninst✝³ : Field 𝕜\ninst✝² : Ring A\ninst✝¹ : Algebra 𝕜 A\ninst✝ : Nontrivial A\nk : 𝕜\na : A\nha : (spectrum 𝕜 a).Nonempty\n⊢ Eq (spectrum 𝕜 (HSMul.hSMul k a)) (HSMul.hSMul k (spectrum 𝕜 a))","decl":"/-- the assumption `(σ a).Nonempty` is necessary and cannot be removed without\nfurther conditions on the algebra `A` and scalar field `𝕜`. -/\ntheorem smul_eq_smul [Nontrivial A] (k : 𝕜) (a : A) (ha : (σ a).Nonempty) :\n    σ (k • a) = k • σ a := by\n  rcases eq_or_ne k 0 with (rfl | h)\n  · simpa [ha, zero_smul_set] using (show {(0 : 𝕜)} = (0 : Set 𝕜) from rfl)\n  · exact unit_smul_eq_smul a (Units.mk0 k h)\n\n"}
{"name":"spectrum.nonzero_mul_eq_swap_mul","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"𝕜 : Type u\nA : Type v\ninst✝² : Field 𝕜\ninst✝¹ : Ring A\ninst✝ : Algebra 𝕜 A\na b : A\n⊢ Eq (SDiff.sdiff (spectrum 𝕜 (HMul.hMul a b)) (Singleton.singleton 0)) (SDiff.sdiff (spectrum 𝕜 (HMul.hMul b a)) (Singleton.singleton 0))","decl":"theorem nonzero_mul_eq_swap_mul (a b : A) : σ (a * b) \\ {0} = σ (b * a) \\ {0} := by\n  suffices h : ∀ x y : A, σ (x * y) \\ {0} ⊆ σ (y * x) \\ {0} from\n    Set.eq_of_subset_of_subset (h a b) (h b a)\n  rintro _ _ k ⟨k_mem, k_neq⟩\n  change ((Units.mk0 k k_neq) : 𝕜) ∈ _ at k_mem\n  exact ⟨unit_mem_mul_iff_mem_swap_mul.mp k_mem, k_neq⟩\n\n"}
{"name":"spectrum.map_inv","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"𝕜 : Type u\nA : Type v\ninst✝² : Field 𝕜\ninst✝¹ : Ring A\ninst✝ : Algebra 𝕜 A\na : Units A\n⊢ Eq (Inv.inv (spectrum 𝕜 ↑a)) (spectrum 𝕜 ↑(Inv.inv a))","decl":"protected theorem map_inv (a : Aˣ) : (σ (a : A))⁻¹ = σ (↑a⁻¹ : A) := by\n  refine Set.eq_of_subset_of_subset (fun k hk => ?_) fun k hk => ?_\n  · rw [Set.mem_inv] at hk\n    have : k ≠ 0 := by simpa only [inv_inv] using inv_ne_zero (ne_zero_of_mem_of_unit hk)\n    lift k to 𝕜ˣ using isUnit_iff_ne_zero.mpr this\n    rw [← Units.val_inv_eq_inv_val k] at hk\n    exact inv_mem_iff.mp hk\n  · lift k to 𝕜ˣ using isUnit_iff_ne_zero.mpr (ne_zero_of_mem_of_unit hk)\n    simpa only [Units.val_inv_eq_inv_val] using inv_mem_iff.mp hk\n\n"}
{"name":"AlgHom.mem_resolventSet_apply","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"F : Type u_1\nR : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Ring A\ninst✝⁴ : Algebra R A\ninst✝³ : Ring B\ninst✝² : Algebra R B\ninst✝¹ : FunLike F A B\ninst✝ : AlgHomClass F R A B\nφ : F\na : A\nr : R\nh : Membership.mem (resolventSet R a) r\n⊢ Membership.mem (resolventSet R (φ a)) r","decl":"theorem mem_resolventSet_apply (φ : F) {a : A} {r : R} (h : r ∈ resolventSet R a) :\n    r ∈ resolventSet R ((φ : A → B) a) := by\n  simpa only [map_sub, AlgHomClass.commutes] using h.map φ\n\n"}
{"name":"AlgHom.spectrum_apply_subset","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"F : Type u_1\nR : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Ring A\ninst✝⁴ : Algebra R A\ninst✝³ : Ring B\ninst✝² : Algebra R B\ninst✝¹ : FunLike F A B\ninst✝ : AlgHomClass F R A B\nφ : F\na : A\n⊢ HasSubset.Subset (spectrum R (φ a)) (spectrum R a)","decl":"theorem spectrum_apply_subset (φ : F) (a : A) : σ ((φ : A → B) a) ⊆ σ a := fun _ =>\n  mt (mem_resolventSet_apply φ)\n\n"}
{"name":"AlgHom.apply_mem_spectrum","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"F : Type u_1\nR : Type u_2\nA : Type u_3\ninst✝⁵ : CommRing R\ninst✝⁴ : Ring A\ninst✝³ : Algebra R A\ninst✝² : FunLike F A R\ninst✝¹ : AlgHomClass F R A R\ninst✝ : Nontrivial R\nφ : F\na : A\n⊢ Membership.mem (spectrum R a) (φ a)","decl":"theorem apply_mem_spectrum [Nontrivial R] (φ : F) (a : A) : φ a ∈ σ a := by\n  have h : ↑ₐ (φ a) - a ∈ RingHom.ker (φ : A →+* R) := by\n    simp only [RingHom.mem_ker, map_sub, RingHom.coe_coe, AlgHomClass.commutes,\n      Algebra.id.map_eq_id, RingHom.id_apply, sub_self]\n  simp only [spectrum.mem_iff, ← mem_nonunits_iff,\n    coe_subset_nonunits (RingHom.ker_ne_top (φ : A →+* R)) h]\n\n"}
{"name":"AlgEquiv.spectrum_eq","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"F : Type u_1\nR : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Ring A\ninst✝⁴ : Ring B\ninst✝³ : Algebra R A\ninst✝² : Algebra R B\ninst✝¹ : EquivLike F A B\ninst✝ : AlgEquivClass F R A B\nf : F\na : A\n⊢ Eq (spectrum R (f a)) (spectrum R a)","decl":"@[simp]\ntheorem AlgEquiv.spectrum_eq {F R A B : Type*} [CommSemiring R] [Ring A] [Ring B] [Algebra R A]\n    [Algebra R B] [EquivLike F A B] [AlgEquivClass F R A B] (f : F) (a : A) :\n    spectrum R (f a) = spectrum R a :=\n  Set.Subset.antisymm (AlgHom.spectrum_apply_subset _ _) <| by\n    simpa only [AlgEquiv.coe_algHom, AlgEquiv.coe_coe_symm_apply_coe_apply] using\n      AlgHom.spectrum_apply_subset (f : A ≃ₐ[R] B).symm (f a)\n\n"}
{"name":"spectrum.units_conjugate","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\na : A\nu : Units A\n⊢ Eq (spectrum R (HMul.hMul (HMul.hMul (↑u) a) ↑(Inv.inv u))) (spectrum R a)","decl":"/-- Conjugation by a unit preserves the spectrum, inverse on right. -/\n@[simp]\nlemma spectrum.units_conjugate {a : A} {u : Aˣ} :\n    spectrum R (u * a * u⁻¹) = spectrum R a := by\n  suffices ∀ (b : A) (v : Aˣ), spectrum R (v * b * v⁻¹) ⊆ spectrum R b by\n    refine le_antisymm (this a u) ?_\n    apply le_of_eq_of_le ?_ <| this (u * a * u⁻¹) u⁻¹\n    simp [mul_assoc]\n  intro a u μ hμ\n  rw [spectrum.mem_iff] at hμ ⊢\n  contrapose! hμ\n  simpa [mul_sub, sub_mul, Algebra.right_comm] using u.isUnit.mul hμ |>.mul u⁻¹.isUnit\n\n"}
{"name":"spectrum.units_conjugate'","module":"Mathlib.Algebra.Algebra.Spectrum","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\na : A\nu : Units A\n⊢ Eq (spectrum R (HMul.hMul (HMul.hMul (↑(Inv.inv u)) a) ↑u)) (spectrum R a)","decl":"/-- Conjugation by a unit preserves the spectrum, inverse on left. -/\n@[simp]\nlemma spectrum.units_conjugate' {a : A} {u : Aˣ} :\n    spectrum R (u⁻¹ * a * u) = spectrum R a := by\n  simpa using spectrum.units_conjugate (u := u⁻¹)\n\n"}
