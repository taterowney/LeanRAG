{"name":"PresheafOfModules.Monoidal.tensorObj_obj","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Monoidal","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nR : CategoryTheory.Functor (Opposite C) CommRingCat\nM₁ M₂ : PresheafOfModules (R.comp (CategoryTheory.forget₂ CommRingCat RingCat))\nX : Opposite C\n⊢ Eq ((PresheafOfModules.Monoidal.tensorObj M₁ M₂).obj X) (CategoryTheory.MonoidalCategoryStruct.tensorObj (M₁.obj X) (M₂.obj X))","decl":"/-- The tensor product of two presheaves of modules. -/\n@[simps obj]\nnoncomputable def tensorObj : PresheafOfModules (R ⋙ forget₂ _ _) where\n  obj X := M₁.obj X ⊗ M₂.obj X\n  map f := tensorObjMap M₁ M₂ f\n  map_id X := ModuleCat.MonoidalCategory.tensor_ext (by\n    intro m₁ m₂\n    dsimp [tensorObjMap]\n    simp\n    rfl) -- `ModuleCat.restrictScalarsId'App_inv_apply` doesn't get picked up due to type mismatch\n  map_comp f g := ModuleCat.MonoidalCategory.tensor_ext (by\n    intro m₁ m₂\n    dsimp [tensorObjMap]\n    simp)\n\n"}
{"name":"PresheafOfModules.Monoidal.tensorObj_map_tmul","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Monoidal","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nR : CategoryTheory.Functor (Opposite C) CommRingCat\nM₁ M₂ : PresheafOfModules (R.comp (CategoryTheory.forget₂ CommRingCat RingCat))\nX Y : Opposite C\nf : Quiver.Hom X Y\nm₁ : ↑(M₁.obj X)\nm₂ : ↑(M₂.obj X)\n⊢ Eq ((ModuleCat.Hom.hom ((PresheafOfModules.Monoidal.tensorObj M₁ M₂).map f)) (TensorProduct.tmul (↑(R.obj X)) m₁ m₂)) (TensorProduct.tmul (↑(R.obj Y)) ((CategoryTheory.ConcreteCategory.hom (M₁.map f)) m₁) ((CategoryTheory.ConcreteCategory.hom (M₂.map f)) m₂))","decl":"@[simp]\nlemma tensorObj_map_tmul {X Y : Cᵒᵖ} (f : X ⟶ Y) (m₁ : M₁.obj X) (m₂ : M₂.obj X) :\n    DFunLike.coe (α := (M₁.obj X ⊗ M₂.obj X :))\n      (β := fun _ ↦ (ModuleCat.restrictScalars (R.map f).hom).obj (M₁.obj Y ⊗ M₂.obj Y))\n      (ModuleCat.Hom.hom (R := ↑(R.obj X)) ((tensorObj M₁ M₂).map f)) (m₁ ⊗ₜ[R.obj X] m₂) =\n    M₁.map f m₁ ⊗ₜ[R.obj Y] M₂.map f m₂ := rfl\n\n"}
{"name":"PresheafOfModules.Monoidal.tensorHom_app","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Monoidal","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nR : CategoryTheory.Functor (Opposite C) CommRingCat\nM₁ M₂ M₃ M₄ : PresheafOfModules (R.comp (CategoryTheory.forget₂ CommRingCat RingCat))\nf : Quiver.Hom M₁ M₂\ng : Quiver.Hom M₃ M₄\nX : Opposite C\n⊢ Eq ((PresheafOfModules.Monoidal.tensorHom f g).app X) (CategoryTheory.MonoidalCategoryStruct.tensorHom (f.app X) (g.app X))","decl":"/-- The tensor product of two morphisms of presheaves of modules. -/\n@[simps]\nnoncomputable def tensorHom (f : M₁ ⟶ M₂) (g : M₃ ⟶ M₄) : tensorObj M₁ M₃ ⟶ tensorObj M₂ M₄ where\n  app X := f.app X ⊗ g.app X\n  naturality {X Y} φ := ModuleCat.MonoidalCategory.tensor_ext (fun m₁ m₃ ↦ by\n    dsimp\n    rw [tensorObj_map_tmul]\n    -- Need `erw` because of the type mismatch in `map` and the tensor product.\n    erw [ModuleCat.MonoidalCategory.tensorHom_tmul, tensorObj_map_tmul]\n    rw [naturality_apply, naturality_apply]\n    simp)\n\n"}
