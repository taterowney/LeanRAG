{"name":"CategoryTheory.SemiadditiveOfBinaryBiproducts.isUnital_leftAdd","module":"Mathlib.CategoryTheory.Preadditive.OfBiproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nX Y : C\n⊢ EckmannHilton.IsUnital (fun x1 x2 => CategoryTheory.SemiadditiveOfBinaryBiproducts.leftAdd X Y x1 x2) 0","decl":"theorem isUnital_leftAdd : EckmannHilton.IsUnital (· +ₗ ·) 0 := by\n  have hr : ∀ f : X ⟶ Y, biprod.lift (0 : X ⟶ Y) f = f ≫ biprod.inr := by\n    intro f\n    ext\n    · simp\n    · simp [biprod.lift_fst, Category.assoc, biprod.inr_fst, comp_zero]\n  have hl : ∀ f : X ⟶ Y, biprod.lift f (0 : X ⟶ Y) = f ≫ biprod.inl := by\n    intro f\n    ext\n    · simp\n    · simp [biprod.lift_snd, Category.assoc, biprod.inl_snd, comp_zero]\n  exact {\n    left_id := fun f => by simp [hr f, leftAdd, Category.assoc, Category.comp_id, biprod.inr_desc],\n    right_id := fun f => by simp [hl f, leftAdd, Category.assoc, Category.comp_id, biprod.inl_desc]\n  }\n\n"}
{"name":"CategoryTheory.SemiadditiveOfBinaryBiproducts.isUnital_rightAdd","module":"Mathlib.CategoryTheory.Preadditive.OfBiproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nX Y : C\n⊢ EckmannHilton.IsUnital (fun x1 x2 => CategoryTheory.SemiadditiveOfBinaryBiproducts.rightAdd X Y x1 x2) 0","decl":"theorem isUnital_rightAdd : EckmannHilton.IsUnital (· +ᵣ ·) 0 := by\n  have h₂ : ∀ f : X ⟶ Y, biprod.desc (0 : X ⟶ Y) f = biprod.snd ≫ f := by\n    intro f\n    ext\n    · simp\n    · simp only [biprod.inr_desc, BinaryBicone.inr_snd_assoc]\n  have h₁ : ∀ f : X ⟶ Y, biprod.desc f (0 : X ⟶ Y) = biprod.fst ≫ f := by\n    intro f\n    ext\n    · simp\n    · simp only [biprod.inr_desc, BinaryBicone.inr_fst_assoc, zero_comp]\n  exact {\n    left_id := fun f => by simp [h₂ f, rightAdd, biprod.lift_snd_assoc, Category.id_comp],\n    right_id := fun f => by simp [h₁ f, rightAdd, biprod.lift_fst_assoc, Category.id_comp]\n  }\n\n"}
{"name":"CategoryTheory.SemiadditiveOfBinaryBiproducts.distrib","module":"Mathlib.CategoryTheory.Preadditive.OfBiproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nX Y : C\nf g h k : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.SemiadditiveOfBinaryBiproducts.leftAdd X Y (CategoryTheory.SemiadditiveOfBinaryBiproducts.rightAdd X Y f g) (CategoryTheory.SemiadditiveOfBinaryBiproducts.rightAdd X Y h k)) (CategoryTheory.SemiadditiveOfBinaryBiproducts.rightAdd X Y (CategoryTheory.SemiadditiveOfBinaryBiproducts.leftAdd X Y f h) (CategoryTheory.SemiadditiveOfBinaryBiproducts.leftAdd X Y g k))","decl":"theorem distrib (f g h k : X ⟶ Y) : (f +ᵣ g) +ₗ h +ᵣ k = (f +ₗ h) +ᵣ g +ₗ k := by\n  let diag : X ⊞ X ⟶ Y ⊞ Y := biprod.lift (biprod.desc f g) (biprod.desc h k)\n  have hd₁ : biprod.inl ≫ diag = biprod.lift f h := by ext <;> simp [diag]\n  have hd₂ : biprod.inr ≫ diag = biprod.lift g k := by ext <;> simp [diag]\n  have h₁ : biprod.lift (f +ᵣ g) (h +ᵣ k) = biprod.lift (𝟙 X) (𝟙 X) ≫ diag := by\n    ext <;> aesop_cat\n  have h₂ : diag ≫ biprod.desc (𝟙 Y) (𝟙 Y) = biprod.desc (f +ₗ h) (g +ₗ k) := by\n    ext <;> simp [reassoc_of% hd₁, reassoc_of% hd₂]\n  rw [leftAdd, h₁, Category.assoc, h₂, rightAdd]\n\n"}
{"name":"CategoryTheory.SemiadditiveOfBinaryBiproducts.add_eq_right_addition","module":"Mathlib.CategoryTheory.Preadditive.OfBiproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nX Y : C\nf g : Quiver.Hom X Y\n⊢ Eq (HAdd.hAdd f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.lift (CategoryTheory.CategoryStruct.id X) (CategoryTheory.CategoryStruct.id X)) (CategoryTheory.Limits.biprod.desc f g))","decl":"theorem add_eq_right_addition (f g : X ⟶ Y) : f + g = biprod.lift (𝟙 X) (𝟙 X) ≫ biprod.desc f g :=\n  rfl\n\n"}
{"name":"CategoryTheory.SemiadditiveOfBinaryBiproducts.add_eq_left_addition","module":"Mathlib.CategoryTheory.Preadditive.OfBiproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nX Y : C\nf g : Quiver.Hom X Y\n⊢ Eq (HAdd.hAdd f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.lift f g) (CategoryTheory.Limits.biprod.desc (CategoryTheory.CategoryStruct.id Y) (CategoryTheory.CategoryStruct.id Y)))","decl":"theorem add_eq_left_addition (f g : X ⟶ Y) : f + g = biprod.lift f g ≫ biprod.desc (𝟙 Y) (𝟙 Y) :=\n  congr_fun₂ (EckmannHilton.mul (isUnital_leftAdd X Y) (isUnital_rightAdd X Y) (distrib X Y)).symm f\n    g\n\n"}
{"name":"CategoryTheory.SemiadditiveOfBinaryBiproducts.add_comp","module":"Mathlib.CategoryTheory.Preadditive.OfBiproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nX Y Z : C\nf g : Quiver.Hom X Y\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HAdd.hAdd f g) h) (HAdd.hAdd (CategoryTheory.CategoryStruct.comp f h) (CategoryTheory.CategoryStruct.comp g h))","decl":"theorem add_comp (f g : X ⟶ Y) (h : Y ⟶ Z) : (f + g) ≫ h = f ≫ h + g ≫ h := by\n  simp only [add_eq_right_addition, Category.assoc]\n  congr\n  ext <;> simp\n\n"}
{"name":"CategoryTheory.SemiadditiveOfBinaryBiproducts.comp_add","module":"Mathlib.CategoryTheory.Preadditive.OfBiproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nX Y Z : C\nf : Quiver.Hom X Y\ng h : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (HAdd.hAdd g h)) (HAdd.hAdd (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp f h))","decl":"theorem comp_add (f : X ⟶ Y) (g h : Y ⟶ Z) : f ≫ (g + h) = f ≫ g + f ≫ h := by\n  simp only [add_eq_left_addition, ← Category.assoc]\n  congr\n  ext <;> simp\n\n"}
