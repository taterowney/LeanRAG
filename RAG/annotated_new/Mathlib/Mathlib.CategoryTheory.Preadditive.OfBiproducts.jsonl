{"name":"CategoryTheory.SemiadditiveOfBinaryBiproducts.isUnital_leftAdd","module":"Mathlib.CategoryTheory.Preadditive.OfBiproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproducts C\nX Y : C\nâŠ¢ EckmannHilton.IsUnital (fun x1 x2 => CategoryTheory.SemiadditiveOfBinaryBiproducts.leftAdd X Y x1 x2) 0","decl":"theorem isUnital_leftAdd : EckmannHilton.IsUnital (Â· +â‚— Â·) 0 := by\n  have hr : âˆ€ f : X âŸ¶ Y, biprod.lift (0 : X âŸ¶ Y) f = f â‰« biprod.inr := by\n    intro f\n    ext\n    Â· simp\n    Â· simp [biprod.lift_fst, Category.assoc, biprod.inr_fst, comp_zero]\n  have hl : âˆ€ f : X âŸ¶ Y, biprod.lift f (0 : X âŸ¶ Y) = f â‰« biprod.inl := by\n    intro f\n    ext\n    Â· simp\n    Â· simp [biprod.lift_snd, Category.assoc, biprod.inl_snd, comp_zero]\n  exact {\n    left_id := fun f => by simp [hr f, leftAdd, Category.assoc, Category.comp_id, biprod.inr_desc],\n    right_id := fun f => by simp [hl f, leftAdd, Category.assoc, Category.comp_id, biprod.inl_desc]\n  }\n\n"}
{"name":"CategoryTheory.SemiadditiveOfBinaryBiproducts.isUnital_rightAdd","module":"Mathlib.CategoryTheory.Preadditive.OfBiproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproducts C\nX Y : C\nâŠ¢ EckmannHilton.IsUnital (fun x1 x2 => CategoryTheory.SemiadditiveOfBinaryBiproducts.rightAdd X Y x1 x2) 0","decl":"theorem isUnital_rightAdd : EckmannHilton.IsUnital (Â· +áµ£ Â·) 0 := by\n  have hâ‚‚ : âˆ€ f : X âŸ¶ Y, biprod.desc (0 : X âŸ¶ Y) f = biprod.snd â‰« f := by\n    intro f\n    ext\n    Â· simp\n    Â· simp only [biprod.inr_desc, BinaryBicone.inr_snd_assoc]\n  have hâ‚ : âˆ€ f : X âŸ¶ Y, biprod.desc f (0 : X âŸ¶ Y) = biprod.fst â‰« f := by\n    intro f\n    ext\n    Â· simp\n    Â· simp only [biprod.inr_desc, BinaryBicone.inr_fst_assoc, zero_comp]\n  exact {\n    left_id := fun f => by simp [hâ‚‚ f, rightAdd, biprod.lift_snd_assoc, Category.id_comp],\n    right_id := fun f => by simp [hâ‚ f, rightAdd, biprod.lift_fst_assoc, Category.id_comp]\n  }\n\n"}
{"name":"CategoryTheory.SemiadditiveOfBinaryBiproducts.distrib","module":"Mathlib.CategoryTheory.Preadditive.OfBiproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproducts C\nX Y : C\nf g h k : Quiver.Hom X Y\nâŠ¢ Eq (CategoryTheory.SemiadditiveOfBinaryBiproducts.leftAdd X Y (CategoryTheory.SemiadditiveOfBinaryBiproducts.rightAdd X Y f g) (CategoryTheory.SemiadditiveOfBinaryBiproducts.rightAdd X Y h k)) (CategoryTheory.SemiadditiveOfBinaryBiproducts.rightAdd X Y (CategoryTheory.SemiadditiveOfBinaryBiproducts.leftAdd X Y f h) (CategoryTheory.SemiadditiveOfBinaryBiproducts.leftAdd X Y g k))","decl":"theorem distrib (f g h k : X âŸ¶ Y) : (f +áµ£ g) +â‚— h +áµ£ k = (f +â‚— h) +áµ£ g +â‚— k := by\n  let diag : X âŠ X âŸ¶ Y âŠ Y := biprod.lift (biprod.desc f g) (biprod.desc h k)\n  have hdâ‚ : biprod.inl â‰« diag = biprod.lift f h := by ext <;> simp [diag]\n  have hdâ‚‚ : biprod.inr â‰« diag = biprod.lift g k := by ext <;> simp [diag]\n  have hâ‚ : biprod.lift (f +áµ£ g) (h +áµ£ k) = biprod.lift (ğŸ™ X) (ğŸ™ X) â‰« diag := by\n    ext <;> aesop_cat\n  have hâ‚‚ : diag â‰« biprod.desc (ğŸ™ Y) (ğŸ™ Y) = biprod.desc (f +â‚— h) (g +â‚— k) := by\n    ext <;> simp [reassoc_of% hdâ‚, reassoc_of% hdâ‚‚]\n  rw [leftAdd, hâ‚, Category.assoc, hâ‚‚, rightAdd]\n\n"}
{"name":"CategoryTheory.SemiadditiveOfBinaryBiproducts.add_eq_right_addition","module":"Mathlib.CategoryTheory.Preadditive.OfBiproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproducts C\nX Y : C\nf g : Quiver.Hom X Y\nâŠ¢ Eq (HAdd.hAdd f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.lift (CategoryTheory.CategoryStruct.id X) (CategoryTheory.CategoryStruct.id X)) (CategoryTheory.Limits.biprod.desc f g))","decl":"theorem add_eq_right_addition (f g : X âŸ¶ Y) : f + g = biprod.lift (ğŸ™ X) (ğŸ™ X) â‰« biprod.desc f g :=\n  rfl\n\n"}
{"name":"CategoryTheory.SemiadditiveOfBinaryBiproducts.add_eq_left_addition","module":"Mathlib.CategoryTheory.Preadditive.OfBiproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproducts C\nX Y : C\nf g : Quiver.Hom X Y\nâŠ¢ Eq (HAdd.hAdd f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.lift f g) (CategoryTheory.Limits.biprod.desc (CategoryTheory.CategoryStruct.id Y) (CategoryTheory.CategoryStruct.id Y)))","decl":"theorem add_eq_left_addition (f g : X âŸ¶ Y) : f + g = biprod.lift f g â‰« biprod.desc (ğŸ™ Y) (ğŸ™ Y) :=\n  congr_funâ‚‚ (EckmannHilton.mul (isUnital_leftAdd X Y) (isUnital_rightAdd X Y) (distrib X Y)).symm f\n    g\n\n"}
{"name":"CategoryTheory.SemiadditiveOfBinaryBiproducts.add_comp","module":"Mathlib.CategoryTheory.Preadditive.OfBiproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproducts C\nX Y Z : C\nf g : Quiver.Hom X Y\nh : Quiver.Hom Y Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (HAdd.hAdd f g) h) (HAdd.hAdd (CategoryTheory.CategoryStruct.comp f h) (CategoryTheory.CategoryStruct.comp g h))","decl":"theorem add_comp (f g : X âŸ¶ Y) (h : Y âŸ¶ Z) : (f + g) â‰« h = f â‰« h + g â‰« h := by\n  simp only [add_eq_right_addition, Category.assoc]\n  congr\n  ext <;> simp\n\n"}
{"name":"CategoryTheory.SemiadditiveOfBinaryBiproducts.comp_add","module":"Mathlib.CategoryTheory.Preadditive.OfBiproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproducts C\nX Y Z : C\nf : Quiver.Hom X Y\ng h : Quiver.Hom Y Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp f (HAdd.hAdd g h)) (HAdd.hAdd (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp f h))","decl":"theorem comp_add (f : X âŸ¶ Y) (g h : Y âŸ¶ Z) : f â‰« (g + h) = f â‰« g + f â‰« h := by\n  simp only [add_eq_left_addition, â† Category.assoc]\n  congr\n  ext <;> simp\n\n"}
