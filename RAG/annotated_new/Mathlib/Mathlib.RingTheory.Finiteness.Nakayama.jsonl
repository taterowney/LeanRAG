{"name":"Submodule.exists_sub_one_mem_and_smul_eq_zero_of_fg_of_le_smul","module":"Mathlib.RingTheory.Finiteness.Nakayama","initialProofState":"R : Type u_3\ninst✝² : CommRing R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nI : Ideal R\nN : Submodule R M\nhn : N.FG\nhin : LE.le N (HSMul.hSMul I N)\n⊢ Exists fun r => And (Membership.mem I (HSub.hSub r 1)) (∀ (n : M), Membership.mem N n → Eq (HSMul.hSMul r n) 0)","decl":"/-- **Nakayama's Lemma**. Atiyah-Macdonald 2.5, Eisenbud 4.7, Matsumura 2.2. -/\n@[stacks 00DV]\ntheorem exists_sub_one_mem_and_smul_eq_zero_of_fg_of_le_smul {R : Type*} [CommRing R] {M : Type*}\n    [AddCommGroup M] [Module R M] (I : Ideal R) (N : Submodule R M) (hn : N.FG) (hin : N ≤ I • N) :\n    ∃ r : R, r - 1 ∈ I ∧ ∀ n ∈ N, r • n = (0 : M) := by\n  rw [fg_def] at hn\n  rcases hn with ⟨s, hfs, hs⟩\n  have : ∃ r : R, r - 1 ∈ I ∧ N ≤ (I • span R s).comap (LinearMap.lsmul R M r) ∧ s ⊆ N := by\n    refine ⟨1, ?_, ?_, ?_⟩\n    · rw [sub_self]\n      exact I.zero_mem\n    · rw [hs]\n      intro n hn\n      rw [mem_comap]\n      change (1 : R) • n ∈ I • N\n      rw [one_smul]\n      exact hin hn\n    · rw [← span_le, hs]\n  clear hin hs\n  revert this\n  refine Set.Finite.induction_on _ hfs (fun H => ?_) @fun i s _ _ ih H => ?_\n  · rcases H with ⟨r, hr1, hrn, _⟩\n    refine ⟨r, hr1, fun n hn => ?_⟩\n    specialize hrn hn\n    rwa [mem_comap, span_empty, smul_bot, mem_bot] at hrn\n  apply ih\n  rcases H with ⟨r, hr1, hrn, hs⟩\n  rw [← Set.singleton_union, span_union, smul_sup] at hrn\n  rw [Set.insert_subset_iff] at hs\n  have : ∃ c : R, c - 1 ∈ I ∧ c • i ∈ I • span R s := by\n    specialize hrn hs.1\n    rw [mem_comap, mem_sup] at hrn\n    rcases hrn with ⟨y, hy, z, hz, hyz⟩\n    dsimp at hyz\n    rw [mem_smul_span_singleton] at hy\n    rcases hy with ⟨c, hci, rfl⟩\n    use r - c\n    constructor\n    · rw [sub_right_comm]\n      exact I.sub_mem hr1 hci\n    · rw [sub_smul, ← hyz, add_sub_cancel_left]\n      exact hz\n  rcases this with ⟨c, hc1, hci⟩\n  refine ⟨c * r, ?_, ?_, hs.2⟩\n  · simpa only [mul_sub, mul_one, sub_add_sub_cancel] using I.add_mem (I.mul_mem_left c hr1) hc1\n  · intro n hn\n    specialize hrn hn\n    rw [mem_comap, mem_sup] at hrn\n    rcases hrn with ⟨y, hy, z, hz, hyz⟩\n    dsimp at hyz\n    rw [mem_smul_span_singleton] at hy\n    rcases hy with ⟨d, _, rfl⟩\n    simp only [mem_comap, LinearMap.lsmul_apply]\n    rw [mul_smul, ← hyz, smul_add, smul_smul, mul_comm, mul_smul]\n    exact add_mem (smul_mem _ _ hci) (smul_mem _ _ hz)\n\n"}
{"name":"Submodule.exists_mem_and_smul_eq_self_of_fg_of_le_smul","module":"Mathlib.RingTheory.Finiteness.Nakayama","initialProofState":"R : Type u_3\ninst✝² : CommRing R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nI : Ideal R\nN : Submodule R M\nhn : N.FG\nhin : LE.le N (HSMul.hSMul I N)\n⊢ Exists fun r => And (Membership.mem I r) (∀ (n : M), Membership.mem N n → Eq (HSMul.hSMul r n) n)","decl":"theorem exists_mem_and_smul_eq_self_of_fg_of_le_smul {R : Type*} [CommRing R] {M : Type*}\n    [AddCommGroup M] [Module R M] (I : Ideal R) (N : Submodule R M) (hn : N.FG) (hin : N ≤ I • N) :\n    ∃ r ∈ I, ∀ n ∈ N, r • n = n := by\n  obtain ⟨r, hr, hr'⟩ := exists_sub_one_mem_and_smul_eq_zero_of_fg_of_le_smul I N hn hin\n  exact ⟨-(r - 1), I.neg_mem hr, fun n hn => by simpa [sub_smul] using hr' n hn⟩\n\n"}
