{"name":"MulEquivClass.toMulEquiv_injective","module":"Mathlib.Algebra.Group.Equiv.Basic","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : EquivLike F α β\ninst✝² : Mul α\ninst✝¹ : Mul β\ninst✝ : MulEquivClass F α β\n⊢ Function.Injective MulEquivClass.toMulEquiv","decl":"@[to_additive]\ntheorem MulEquivClass.toMulEquiv_injective [Mul α] [Mul β] [MulEquivClass F α β] :\n    Function.Injective ((↑) : F → α ≃* β) :=\n  fun _ _ e ↦ DFunLike.ext _ _ fun a ↦ congr_arg (fun e : α ≃* β ↦ e.toFun a) e\n\n"}
{"name":"AddEquivClass.toAddEquiv_injective","module":"Mathlib.Algebra.Group.Equiv.Basic","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : EquivLike F α β\ninst✝² : Add α\ninst✝¹ : Add β\ninst✝ : AddEquivClass F α β\n⊢ Function.Injective AddEquivClass.toAddEquiv","decl":"@[to_additive]\ntheorem MulEquivClass.toMulEquiv_injective [Mul α] [Mul β] [MulEquivClass F α β] :\n    Function.Injective ((↑) : F → α ≃* β) :=\n  fun _ _ e ↦ DFunLike.ext _ _ fun a ↦ congr_arg (fun e : α ≃* β ↦ e.toFun a) e\n\n"}
{"name":"AddEquiv.arrowCongr_apply","module":"Mathlib.Algebra.Group.Equiv.Basic","initialProofState":"M : Type u_9\nN : Type u_10\nP : Type u_11\nQ : Type u_12\ninst✝¹ : Add P\ninst✝ : Add Q\nf : Equiv M N\ng : AddEquiv P Q\nh : M → P\nn : N\n⊢ Eq ((AddEquiv.arrowCongr f g) h n) (g (h (f.symm n)))","decl":"/-- A multiplicative analogue of `Equiv.arrowCongr`,\nwhere the equivalence between the targets is multiplicative.\n-/\n@[to_additive (attr := simps apply) \"An additive analogue of `Equiv.arrowCongr`,\n  where the equivalence between the targets is additive.\"]\ndef arrowCongr {M N P Q : Type*} [Mul P] [Mul Q] (f : M ≃ N) (g : P ≃* Q) :\n    (M → P) ≃* (N → Q) where\n  toFun h n := g (h (f.symm n))\n  invFun k m := g.symm (k (f m))\n  left_inv h := by ext; simp\n  right_inv k := by ext; simp\n  map_mul' h k := by ext; simp\n\n"}
{"name":"MulEquiv.arrowCongr_apply","module":"Mathlib.Algebra.Group.Equiv.Basic","initialProofState":"M : Type u_9\nN : Type u_10\nP : Type u_11\nQ : Type u_12\ninst✝¹ : Mul P\ninst✝ : Mul Q\nf : Equiv M N\ng : MulEquiv P Q\nh : M → P\nn : N\n⊢ Eq ((MulEquiv.arrowCongr f g) h n) (g (h (f.symm n)))","decl":"/-- A multiplicative analogue of `Equiv.arrowCongr`,\nwhere the equivalence between the targets is multiplicative.\n-/\n@[to_additive (attr := simps apply) \"An additive analogue of `Equiv.arrowCongr`,\n  where the equivalence between the targets is additive.\"]\ndef arrowCongr {M N P Q : Type*} [Mul P] [Mul Q] (f : M ≃ N) (g : P ≃* Q) :\n    (M → P) ≃* (N → Q) where\n  toFun h n := g (h (f.symm n))\n  invFun k m := g.symm (k (f m))\n  left_inv h := by ext; simp\n  right_inv k := by ext; simp\n  map_mul' h k := by ext; simp\n\n"}
{"name":"MulEquiv.monoidHomCongr_apply","module":"Mathlib.Algebra.Group.Equiv.Basic","initialProofState":"M : Type u_9\nN : Type u_10\nP : Type u_11\nQ : Type u_12\ninst✝³ : MulOneClass M\ninst✝² : MulOneClass N\ninst✝¹ : CommMonoid P\ninst✝ : CommMonoid Q\nf : MulEquiv M N\ng : MulEquiv P Q\nh : MonoidHom M P\n⊢ Eq ((f.monoidHomCongr g) h) (g.toMonoidHom.comp (h.comp f.symm.toMonoidHom))","decl":"/-- A multiplicative analogue of `Equiv.arrowCongr`,\nfor multiplicative maps from a monoid to a commutative monoid.\n-/\n@[to_additive (attr := simps apply)\n  \"An additive analogue of `Equiv.arrowCongr`,\n  for additive maps from an additive monoid to a commutative additive monoid.\"]\ndef monoidHomCongr {M N P Q} [MulOneClass M] [MulOneClass N] [CommMonoid P] [CommMonoid Q]\n    (f : M ≃* N) (g : P ≃* Q) : (M →* P) ≃* (N →* Q) where\n  toFun h := g.toMonoidHom.comp (h.comp f.symm.toMonoidHom)\n  invFun k := g.symm.toMonoidHom.comp (k.comp f.toMonoidHom)\n  left_inv h := by ext; simp\n  right_inv k := by ext; simp\n  map_mul' h k := by ext; simp\n\n"}
{"name":"AddEquiv.addMonoidHomCongr_apply","module":"Mathlib.Algebra.Group.Equiv.Basic","initialProofState":"M : Type u_9\nN : Type u_10\nP : Type u_11\nQ : Type u_12\ninst✝³ : AddZeroClass M\ninst✝² : AddZeroClass N\ninst✝¹ : AddCommMonoid P\ninst✝ : AddCommMonoid Q\nf : AddEquiv M N\ng : AddEquiv P Q\nh : AddMonoidHom M P\n⊢ Eq ((f.addMonoidHomCongr g) h) (g.toAddMonoidHom.comp (h.comp f.symm.toAddMonoidHom))","decl":"/-- A multiplicative analogue of `Equiv.arrowCongr`,\nfor multiplicative maps from a monoid to a commutative monoid.\n-/\n@[to_additive (attr := simps apply)\n  \"An additive analogue of `Equiv.arrowCongr`,\n  for additive maps from an additive monoid to a commutative additive monoid.\"]\ndef monoidHomCongr {M N P Q} [MulOneClass M] [MulOneClass N] [CommMonoid P] [CommMonoid Q]\n    (f : M ≃* N) (g : P ≃* Q) : (M →* P) ≃* (N →* Q) where\n  toFun h := g.toMonoidHom.comp (h.comp f.symm.toMonoidHom)\n  invFun k := g.symm.toMonoidHom.comp (k.comp f.toMonoidHom)\n  left_inv h := by ext; simp\n  right_inv k := by ext; simp\n  map_mul' h k := by ext; simp\n\n"}
{"name":"MulEquiv.piCongrRight_apply","module":"Mathlib.Algebra.Group.Equiv.Basic","initialProofState":"η : Type u_9\nMs : η → Type u_10\nNs : η → Type u_11\ninst✝¹ : (j : η) → Mul (Ms j)\ninst✝ : (j : η) → Mul (Ns j)\nes : (j : η) → MulEquiv (Ms j) (Ns j)\nx : (j : η) → Ms j\nj : η\n⊢ Eq ((MulEquiv.piCongrRight es) x j) ((es j) (x j))","decl":"/-- A family of multiplicative equivalences `Π j, (Ms j ≃* Ns j)` generates a\nmultiplicative equivalence between `Π j, Ms j` and `Π j, Ns j`.\n\nThis is the `MulEquiv` version of `Equiv.piCongrRight`, and the dependent version of\n`MulEquiv.arrowCongr`.\n-/\n@[to_additive (attr := simps apply)\n  \"A family of additive equivalences `Π j, (Ms j ≃+ Ns j)`\n  generates an additive equivalence between `Π j, Ms j` and `Π j, Ns j`.\n\n  This is the `AddEquiv` version of `Equiv.piCongrRight`, and the dependent version of\n  `AddEquiv.arrowCongr`.\"]\ndef piCongrRight {η : Type*} {Ms Ns : η → Type*} [∀ j, Mul (Ms j)] [∀ j, Mul (Ns j)]\n    (es : ∀ j, Ms j ≃* Ns j) : (∀ j, Ms j) ≃* ∀ j, Ns j :=\n  { Equiv.piCongrRight fun j => (es j).toEquiv with\n    toFun := fun x j => es j (x j),\n    invFun := fun x j => (es j).symm (x j),\n    map_mul' := fun x y => funext fun j => map_mul (es j) (x j) (y j) }\n\n"}
{"name":"AddEquiv.piCongrRight_apply","module":"Mathlib.Algebra.Group.Equiv.Basic","initialProofState":"η : Type u_9\nMs : η → Type u_10\nNs : η → Type u_11\ninst✝¹ : (j : η) → Add (Ms j)\ninst✝ : (j : η) → Add (Ns j)\nes : (j : η) → AddEquiv (Ms j) (Ns j)\nx : (j : η) → Ms j\nj : η\n⊢ Eq ((AddEquiv.piCongrRight es) x j) ((es j) (x j))","decl":"/-- A family of multiplicative equivalences `Π j, (Ms j ≃* Ns j)` generates a\nmultiplicative equivalence between `Π j, Ms j` and `Π j, Ns j`.\n\nThis is the `MulEquiv` version of `Equiv.piCongrRight`, and the dependent version of\n`MulEquiv.arrowCongr`.\n-/\n@[to_additive (attr := simps apply)\n  \"A family of additive equivalences `Π j, (Ms j ≃+ Ns j)`\n  generates an additive equivalence between `Π j, Ms j` and `Π j, Ns j`.\n\n  This is the `AddEquiv` version of `Equiv.piCongrRight`, and the dependent version of\n  `AddEquiv.arrowCongr`.\"]\ndef piCongrRight {η : Type*} {Ms Ns : η → Type*} [∀ j, Mul (Ms j)] [∀ j, Mul (Ns j)]\n    (es : ∀ j, Ms j ≃* Ns j) : (∀ j, Ms j) ≃* ∀ j, Ns j :=\n  { Equiv.piCongrRight fun j => (es j).toEquiv with\n    toFun := fun x j => es j (x j),\n    invFun := fun x j => (es j).symm (x j),\n    map_mul' := fun x y => funext fun j => map_mul (es j) (x j) (y j) }\n\n"}
{"name":"AddEquiv.piCongrRight_refl","module":"Mathlib.Algebra.Group.Equiv.Basic","initialProofState":"η : Type u_9\nMs : η → Type u_10\ninst✝ : (j : η) → Add (Ms j)\n⊢ Eq (AddEquiv.piCongrRight fun j => AddEquiv.refl (Ms j)) (AddEquiv.refl ((j : η) → Ms j))","decl":"@[to_additive (attr := simp)]\ntheorem piCongrRight_refl {η : Type*} {Ms : η → Type*} [∀ j, Mul (Ms j)] :\n    (piCongrRight fun j => MulEquiv.refl (Ms j)) = MulEquiv.refl _ := rfl\n\n"}
{"name":"MulEquiv.piCongrRight_refl","module":"Mathlib.Algebra.Group.Equiv.Basic","initialProofState":"η : Type u_9\nMs : η → Type u_10\ninst✝ : (j : η) → Mul (Ms j)\n⊢ Eq (MulEquiv.piCongrRight fun j => MulEquiv.refl (Ms j)) (MulEquiv.refl ((j : η) → Ms j))","decl":"@[to_additive (attr := simp)]\ntheorem piCongrRight_refl {η : Type*} {Ms : η → Type*} [∀ j, Mul (Ms j)] :\n    (piCongrRight fun j => MulEquiv.refl (Ms j)) = MulEquiv.refl _ := rfl\n\n"}
{"name":"AddEquiv.piCongrRight_symm","module":"Mathlib.Algebra.Group.Equiv.Basic","initialProofState":"η : Type u_9\nMs : η → Type u_10\nNs : η → Type u_11\ninst✝¹ : (j : η) → Add (Ms j)\ninst✝ : (j : η) → Add (Ns j)\nes : (j : η) → AddEquiv (Ms j) (Ns j)\n⊢ Eq (AddEquiv.piCongrRight es).symm (AddEquiv.piCongrRight fun i => (es i).symm)","decl":"@[to_additive (attr := simp)]\ntheorem piCongrRight_symm {η : Type*} {Ms Ns : η → Type*} [∀ j, Mul (Ms j)] [∀ j, Mul (Ns j)]\n    (es : ∀ j, Ms j ≃* Ns j) : (piCongrRight es).symm = piCongrRight fun i => (es i).symm := rfl\n\n"}
{"name":"MulEquiv.piCongrRight_symm","module":"Mathlib.Algebra.Group.Equiv.Basic","initialProofState":"η : Type u_9\nMs : η → Type u_10\nNs : η → Type u_11\ninst✝¹ : (j : η) → Mul (Ms j)\ninst✝ : (j : η) → Mul (Ns j)\nes : (j : η) → MulEquiv (Ms j) (Ns j)\n⊢ Eq (MulEquiv.piCongrRight es).symm (MulEquiv.piCongrRight fun i => (es i).symm)","decl":"@[to_additive (attr := simp)]\ntheorem piCongrRight_symm {η : Type*} {Ms Ns : η → Type*} [∀ j, Mul (Ms j)] [∀ j, Mul (Ns j)]\n    (es : ∀ j, Ms j ≃* Ns j) : (piCongrRight es).symm = piCongrRight fun i => (es i).symm := rfl\n\n"}
{"name":"AddEquiv.piCongrRight_trans","module":"Mathlib.Algebra.Group.Equiv.Basic","initialProofState":"η : Type u_9\nMs : η → Type u_10\nNs : η → Type u_11\nPs : η → Type u_12\ninst✝² : (j : η) → Add (Ms j)\ninst✝¹ : (j : η) → Add (Ns j)\ninst✝ : (j : η) → Add (Ps j)\nes : (j : η) → AddEquiv (Ms j) (Ns j)\nfs : (j : η) → AddEquiv (Ns j) (Ps j)\n⊢ Eq ((AddEquiv.piCongrRight es).trans (AddEquiv.piCongrRight fs)) (AddEquiv.piCongrRight fun i => (es i).trans (fs i))","decl":"@[to_additive (attr := simp)]\ntheorem piCongrRight_trans {η : Type*} {Ms Ns Ps : η → Type*} [∀ j, Mul (Ms j)]\n    [∀ j, Mul (Ns j)] [∀ j, Mul (Ps j)] (es : ∀ j, Ms j ≃* Ns j) (fs : ∀ j, Ns j ≃* Ps j) :\n    (piCongrRight es).trans (piCongrRight fs) = piCongrRight fun i => (es i).trans (fs i) := rfl\n\n"}
{"name":"MulEquiv.piCongrRight_trans","module":"Mathlib.Algebra.Group.Equiv.Basic","initialProofState":"η : Type u_9\nMs : η → Type u_10\nNs : η → Type u_11\nPs : η → Type u_12\ninst✝² : (j : η) → Mul (Ms j)\ninst✝¹ : (j : η) → Mul (Ns j)\ninst✝ : (j : η) → Mul (Ps j)\nes : (j : η) → MulEquiv (Ms j) (Ns j)\nfs : (j : η) → MulEquiv (Ns j) (Ps j)\n⊢ Eq ((MulEquiv.piCongrRight es).trans (MulEquiv.piCongrRight fs)) (MulEquiv.piCongrRight fun i => (es i).trans (fs i))","decl":"@[to_additive (attr := simp)]\ntheorem piCongrRight_trans {η : Type*} {Ms Ns Ps : η → Type*} [∀ j, Mul (Ms j)]\n    [∀ j, Mul (Ns j)] [∀ j, Mul (Ps j)] (es : ∀ j, Ms j ≃* Ns j) (fs : ∀ j, Ns j ≃* Ps j) :\n    (piCongrRight es).trans (piCongrRight fs) = piCongrRight fun i => (es i).trans (fs i) := rfl\n\n"}
{"name":"AddEquiv.piUnique_symm_apply","module":"Mathlib.Algebra.Group.Equiv.Basic","initialProofState":"ι : Type u_9\nM : ι → Type u_10\ninst✝¹ : (j : ι) → Add (M j)\ninst✝ : Unique ι\nx : M Inhabited.default\ni : ι\n⊢ Eq ((AddEquiv.piUnique M).symm x i) (uniqueElim x i)","decl":"/-- A family indexed by a type with a unique element\nis `MulEquiv` to the element at the single index. -/\n@[to_additive (attr := simps!)\n  \"A family indexed by a type with a unique element\n  is `AddEquiv` to the element at the single index.\"]\ndef piUnique {ι : Type*} (M : ι → Type*) [∀ j, Mul (M j)] [Unique ι] :\n    (∀ j, M j) ≃* M default :=\n  { Equiv.piUnique M with map_mul' := fun _ _ => Pi.mul_apply _ _ _ }\n\n"}
{"name":"MulEquiv.piUnique_apply","module":"Mathlib.Algebra.Group.Equiv.Basic","initialProofState":"ι : Type u_9\nM : ι → Type u_10\ninst✝¹ : (j : ι) → Mul (M j)\ninst✝ : Unique ι\nf : (i : ι) → M i\n⊢ Eq ((MulEquiv.piUnique M) f) (f Inhabited.default)","decl":"/-- A family indexed by a type with a unique element\nis `MulEquiv` to the element at the single index. -/\n@[to_additive (attr := simps!)\n  \"A family indexed by a type with a unique element\n  is `AddEquiv` to the element at the single index.\"]\ndef piUnique {ι : Type*} (M : ι → Type*) [∀ j, Mul (M j)] [Unique ι] :\n    (∀ j, M j) ≃* M default :=\n  { Equiv.piUnique M with map_mul' := fun _ _ => Pi.mul_apply _ _ _ }\n\n"}
{"name":"MulEquiv.piUnique_symm_apply","module":"Mathlib.Algebra.Group.Equiv.Basic","initialProofState":"ι : Type u_9\nM : ι → Type u_10\ninst✝¹ : (j : ι) → Mul (M j)\ninst✝ : Unique ι\nx : M Inhabited.default\ni : ι\n⊢ Eq ((MulEquiv.piUnique M).symm x i) (uniqueElim x i)","decl":"/-- A family indexed by a type with a unique element\nis `MulEquiv` to the element at the single index. -/\n@[to_additive (attr := simps!)\n  \"A family indexed by a type with a unique element\n  is `AddEquiv` to the element at the single index.\"]\ndef piUnique {ι : Type*} (M : ι → Type*) [∀ j, Mul (M j)] [Unique ι] :\n    (∀ j, M j) ≃* M default :=\n  { Equiv.piUnique M with map_mul' := fun _ _ => Pi.mul_apply _ _ _ }\n\n"}
{"name":"AddEquiv.piUnique_apply","module":"Mathlib.Algebra.Group.Equiv.Basic","initialProofState":"ι : Type u_9\nM : ι → Type u_10\ninst✝¹ : (j : ι) → Add (M j)\ninst✝ : Unique ι\nf : (i : ι) → M i\n⊢ Eq ((AddEquiv.piUnique M) f) (f Inhabited.default)","decl":"/-- A family indexed by a type with a unique element\nis `MulEquiv` to the element at the single index. -/\n@[to_additive (attr := simps!)\n  \"A family indexed by a type with a unique element\n  is `AddEquiv` to the element at the single index.\"]\ndef piUnique {ι : Type*} (M : ι → Type*) [∀ j, Mul (M j)] [Unique ι] :\n    (∀ j, M j) ≃* M default :=\n  { Equiv.piUnique M with map_mul' := fun _ _ => Pi.mul_apply _ _ _ }\n\n"}
{"name":"MonoidHom.precompEquiv_symm_apply","module":"Mathlib.Algebra.Group.Equiv.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\ninst✝² : Monoid α\ninst✝¹ : Monoid β\ne : MulEquiv α β\nγ : Type u_11\ninst✝ : Monoid γ\ng : MonoidHom α γ\n⊢ Eq ((MonoidHom.precompEquiv e γ).symm g) (g.comp ↑e.symm)","decl":"/-- The equivalence `(β →* γ) ≃ (α →* γ)` obtained by precomposition with\na multiplicative equivalence `e : α ≃* β`. -/\n@[to_additive (attr := simps)\n\"The equivalence `(β →+ γ) ≃ (α →+ γ)` obtained by precomposition with\nan additive equivalence `e : α ≃+ β`.\"]\ndef precompEquiv {α β : Type*} [Monoid α] [Monoid β] (e : α ≃* β) (γ : Type*) [Monoid γ] :\n    (β →* γ) ≃ (α →* γ) where\n  toFun f := f.comp e\n  invFun g := g.comp e.symm\n  left_inv _ := by ext; simp\n  right_inv _ := by ext; simp\n\n"}
{"name":"AddMonoidHom.precompEquiv_apply","module":"Mathlib.Algebra.Group.Equiv.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\ninst✝² : AddMonoid α\ninst✝¹ : AddMonoid β\ne : AddEquiv α β\nγ : Type u_11\ninst✝ : AddMonoid γ\nf : AddMonoidHom β γ\n⊢ Eq ((AddMonoidHom.precompEquiv e γ) f) (f.comp ↑e)","decl":"/-- The equivalence `(β →* γ) ≃ (α →* γ)` obtained by precomposition with\na multiplicative equivalence `e : α ≃* β`. -/\n@[to_additive (attr := simps)\n\"The equivalence `(β →+ γ) ≃ (α →+ γ)` obtained by precomposition with\nan additive equivalence `e : α ≃+ β`.\"]\ndef precompEquiv {α β : Type*} [Monoid α] [Monoid β] (e : α ≃* β) (γ : Type*) [Monoid γ] :\n    (β →* γ) ≃ (α →* γ) where\n  toFun f := f.comp e\n  invFun g := g.comp e.symm\n  left_inv _ := by ext; simp\n  right_inv _ := by ext; simp\n\n"}
{"name":"MonoidHom.precompEquiv_apply","module":"Mathlib.Algebra.Group.Equiv.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\ninst✝² : Monoid α\ninst✝¹ : Monoid β\ne : MulEquiv α β\nγ : Type u_11\ninst✝ : Monoid γ\nf : MonoidHom β γ\n⊢ Eq ((MonoidHom.precompEquiv e γ) f) (f.comp ↑e)","decl":"/-- The equivalence `(β →* γ) ≃ (α →* γ)` obtained by precomposition with\na multiplicative equivalence `e : α ≃* β`. -/\n@[to_additive (attr := simps)\n\"The equivalence `(β →+ γ) ≃ (α →+ γ)` obtained by precomposition with\nan additive equivalence `e : α ≃+ β`.\"]\ndef precompEquiv {α β : Type*} [Monoid α] [Monoid β] (e : α ≃* β) (γ : Type*) [Monoid γ] :\n    (β →* γ) ≃ (α →* γ) where\n  toFun f := f.comp e\n  invFun g := g.comp e.symm\n  left_inv _ := by ext; simp\n  right_inv _ := by ext; simp\n\n"}
{"name":"AddMonoidHom.precompEquiv_symm_apply","module":"Mathlib.Algebra.Group.Equiv.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\ninst✝² : AddMonoid α\ninst✝¹ : AddMonoid β\ne : AddEquiv α β\nγ : Type u_11\ninst✝ : AddMonoid γ\ng : AddMonoidHom α γ\n⊢ Eq ((AddMonoidHom.precompEquiv e γ).symm g) (g.comp ↑e.symm)","decl":"/-- The equivalence `(β →* γ) ≃ (α →* γ)` obtained by precomposition with\na multiplicative equivalence `e : α ≃* β`. -/\n@[to_additive (attr := simps)\n\"The equivalence `(β →+ γ) ≃ (α →+ γ)` obtained by precomposition with\nan additive equivalence `e : α ≃+ β`.\"]\ndef precompEquiv {α β : Type*} [Monoid α] [Monoid β] (e : α ≃* β) (γ : Type*) [Monoid γ] :\n    (β →* γ) ≃ (α →* γ) where\n  toFun f := f.comp e\n  invFun g := g.comp e.symm\n  left_inv _ := by ext; simp\n  right_inv _ := by ext; simp\n\n"}
{"name":"MonoidHom.postcompEquiv_symm_apply","module":"Mathlib.Algebra.Group.Equiv.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\ninst✝² : Monoid α\ninst✝¹ : Monoid β\ne : MulEquiv α β\nγ : Type u_11\ninst✝ : Monoid γ\ng : MonoidHom γ β\n⊢ Eq ((MonoidHom.postcompEquiv e γ).symm g) (e.symm.toMonoidHom.comp g)","decl":"/-- The equivalence `(γ →* α) ≃ (γ →* β)` obtained by postcomposition with\na multiplicative equivalence `e : α ≃* β`. -/\n@[to_additive (attr := simps)\n\"The equivalence `(γ →+ α) ≃ (γ →+ β)` obtained by postcomposition with\nan additive equivalence `e : α ≃+ β`.\"]\ndef postcompEquiv {α β : Type*} [Monoid α] [Monoid β] (e : α ≃* β) (γ : Type*) [Monoid γ] :\n    (γ →* α) ≃ (γ →* β) where\n  toFun f := e.toMonoidHom.comp f\n  invFun g := e.symm.toMonoidHom.comp g\n  left_inv _ := by ext; simp\n  right_inv _ := by ext; simp\n\n"}
{"name":"AddMonoidHom.postcompEquiv_apply","module":"Mathlib.Algebra.Group.Equiv.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\ninst✝² : AddMonoid α\ninst✝¹ : AddMonoid β\ne : AddEquiv α β\nγ : Type u_11\ninst✝ : AddMonoid γ\nf : AddMonoidHom γ α\n⊢ Eq ((AddMonoidHom.postcompEquiv e γ) f) (e.toAddMonoidHom.comp f)","decl":"/-- The equivalence `(γ →* α) ≃ (γ →* β)` obtained by postcomposition with\na multiplicative equivalence `e : α ≃* β`. -/\n@[to_additive (attr := simps)\n\"The equivalence `(γ →+ α) ≃ (γ →+ β)` obtained by postcomposition with\nan additive equivalence `e : α ≃+ β`.\"]\ndef postcompEquiv {α β : Type*} [Monoid α] [Monoid β] (e : α ≃* β) (γ : Type*) [Monoid γ] :\n    (γ →* α) ≃ (γ →* β) where\n  toFun f := e.toMonoidHom.comp f\n  invFun g := e.symm.toMonoidHom.comp g\n  left_inv _ := by ext; simp\n  right_inv _ := by ext; simp\n\n"}
{"name":"AddMonoidHom.postcompEquiv_symm_apply","module":"Mathlib.Algebra.Group.Equiv.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\ninst✝² : AddMonoid α\ninst✝¹ : AddMonoid β\ne : AddEquiv α β\nγ : Type u_11\ninst✝ : AddMonoid γ\ng : AddMonoidHom γ β\n⊢ Eq ((AddMonoidHom.postcompEquiv e γ).symm g) (e.symm.toAddMonoidHom.comp g)","decl":"/-- The equivalence `(γ →* α) ≃ (γ →* β)` obtained by postcomposition with\na multiplicative equivalence `e : α ≃* β`. -/\n@[to_additive (attr := simps)\n\"The equivalence `(γ →+ α) ≃ (γ →+ β)` obtained by postcomposition with\nan additive equivalence `e : α ≃+ β`.\"]\ndef postcompEquiv {α β : Type*} [Monoid α] [Monoid β] (e : α ≃* β) (γ : Type*) [Monoid γ] :\n    (γ →* α) ≃ (γ →* β) where\n  toFun f := e.toMonoidHom.comp f\n  invFun g := e.symm.toMonoidHom.comp g\n  left_inv _ := by ext; simp\n  right_inv _ := by ext; simp\n\n"}
{"name":"MonoidHom.postcompEquiv_apply","module":"Mathlib.Algebra.Group.Equiv.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\ninst✝² : Monoid α\ninst✝¹ : Monoid β\ne : MulEquiv α β\nγ : Type u_11\ninst✝ : Monoid γ\nf : MonoidHom γ α\n⊢ Eq ((MonoidHom.postcompEquiv e γ) f) (e.toMonoidHom.comp f)","decl":"/-- The equivalence `(γ →* α) ≃ (γ →* β)` obtained by postcomposition with\na multiplicative equivalence `e : α ≃* β`. -/\n@[to_additive (attr := simps)\n\"The equivalence `(γ →+ α) ≃ (γ →+ β)` obtained by postcomposition with\nan additive equivalence `e : α ≃+ β`.\"]\ndef postcompEquiv {α β : Type*} [Monoid α] [Monoid β] (e : α ≃* β) (γ : Type*) [Monoid γ] :\n    (γ →* α) ≃ (γ →* β) where\n  toFun f := e.toMonoidHom.comp f\n  invFun g := e.symm.toMonoidHom.comp g\n  left_inv _ := by ext; simp\n  right_inv _ := by ext; simp\n\n"}
{"name":"Equiv.neg_apply","module":"Mathlib.Algebra.Group.Equiv.Basic","initialProofState":"G : Type u_7\ninst✝ : InvolutiveNeg G\n⊢ Eq (⇑(Equiv.neg G)) Neg.neg","decl":"/-- Inversion on a `Group` or `GroupWithZero` is a permutation of the underlying type. -/\n@[to_additive (attr := simps! (config := .asFn) apply)\n    \"Negation on an `AddGroup` is a permutation of the underlying type.\"]\nprotected def inv : Perm G :=\n  inv_involutive.toPerm _\n\n"}
{"name":"Equiv.inv_apply","module":"Mathlib.Algebra.Group.Equiv.Basic","initialProofState":"G : Type u_7\ninst✝ : InvolutiveInv G\n⊢ Eq (⇑(Equiv.inv G)) Inv.inv","decl":"/-- Inversion on a `Group` or `GroupWithZero` is a permutation of the underlying type. -/\n@[to_additive (attr := simps! (config := .asFn) apply)\n    \"Negation on an `AddGroup` is a permutation of the underlying type.\"]\nprotected def inv : Perm G :=\n  inv_involutive.toPerm _\n\n"}
{"name":"Equiv.inv_symm","module":"Mathlib.Algebra.Group.Equiv.Basic","initialProofState":"G : Type u_7\ninst✝ : InvolutiveInv G\n⊢ Eq (Equiv.symm (Equiv.inv G)) (Equiv.inv G)","decl":"@[to_additive (attr := simp)]\ntheorem inv_symm : (Equiv.inv G).symm = Equiv.inv G := rfl\n\n"}
{"name":"Equiv.neg_symm","module":"Mathlib.Algebra.Group.Equiv.Basic","initialProofState":"G : Type u_7\ninst✝ : InvolutiveNeg G\n⊢ Eq (Equiv.symm (Equiv.neg G)) (Equiv.neg G)","decl":"@[to_additive (attr := simp)]\ntheorem inv_symm : (Equiv.inv G).symm = Equiv.inv G := rfl\n\n"}
