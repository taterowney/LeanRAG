{"name":"ContinuousLinearMap.mul_apply'","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\n𝕜' : Type u_3\ninst✝³ : NonUnitalSeminormedRing 𝕜'\ninst✝² : NormedSpace 𝕜 𝕜'\ninst✝¹ : IsScalarTower 𝕜 𝕜' 𝕜'\ninst✝ : SMulCommClass 𝕜 𝕜' 𝕜'\nx y : 𝕜'\n⊢ Eq (((ContinuousLinearMap.mul 𝕜 𝕜') x) y) (HMul.hMul x y)","decl":"@[simp]\ntheorem mul_apply' (x y : 𝕜') : mul 𝕜 𝕜' x y = x * y :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.opNorm_mul_apply_le","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\n𝕜' : Type u_3\ninst✝³ : NonUnitalSeminormedRing 𝕜'\ninst✝² : NormedSpace 𝕜 𝕜'\ninst✝¹ : IsScalarTower 𝕜 𝕜' 𝕜'\ninst✝ : SMulCommClass 𝕜 𝕜' 𝕜'\nx : 𝕜'\n⊢ LE.le (Norm.norm ((ContinuousLinearMap.mul 𝕜 𝕜') x)) (Norm.norm x)","decl":"@[simp]\ntheorem opNorm_mul_apply_le (x : 𝕜') : ‖mul 𝕜 𝕜' x‖ ≤ ‖x‖ :=\n  opNorm_le_bound _ (norm_nonneg x) (norm_mul_le x)\n\n\n"}
{"name":"ContinuousLinearMap.opNorm_mul_le","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\n𝕜' : Type u_3\ninst✝³ : NonUnitalSeminormedRing 𝕜'\ninst✝² : NormedSpace 𝕜 𝕜'\ninst✝¹ : IsScalarTower 𝕜 𝕜' 𝕜'\ninst✝ : SMulCommClass 𝕜 𝕜' 𝕜'\n⊢ LE.le (Norm.norm (ContinuousLinearMap.mul 𝕜 𝕜')) 1","decl":"theorem opNorm_mul_le : ‖mul 𝕜 𝕜'‖ ≤ 1 :=\n  LinearMap.mkContinuous₂_norm_le _ zero_le_one _\n\n\n"}
{"name":"NonUnitalAlgHom.coe_Lmul","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\n𝕜' : Type u_3\ninst✝³ : NonUnitalSeminormedRing 𝕜'\ninst✝² : NormedSpace 𝕜 𝕜'\ninst✝¹ : IsScalarTower 𝕜 𝕜' 𝕜'\ninst✝ : SMulCommClass 𝕜 𝕜' 𝕜'\n⊢ Eq ⇑(NonUnitalAlgHom.Lmul 𝕜 𝕜') ⇑(ContinuousLinearMap.mul 𝕜 𝕜')","decl":"variable {𝕜 𝕜'} in\n@[simp]\ntheorem _root_.NonUnitalAlgHom.coe_Lmul : ⇑(NonUnitalAlgHom.Lmul 𝕜 𝕜') = mul 𝕜 𝕜' :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.mulLeftRight_apply","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\n𝕜' : Type u_3\ninst✝³ : NonUnitalSeminormedRing 𝕜'\ninst✝² : NormedSpace 𝕜 𝕜'\ninst✝¹ : IsScalarTower 𝕜 𝕜' 𝕜'\ninst✝ : SMulCommClass 𝕜 𝕜' 𝕜'\nx y z : 𝕜'\n⊢ Eq ((((ContinuousLinearMap.mulLeftRight 𝕜 𝕜') x) y) z) (HMul.hMul (HMul.hMul x z) y)","decl":"@[simp]\ntheorem mulLeftRight_apply (x y z : 𝕜') : mulLeftRight 𝕜 𝕜' x y z = x * z * y :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.opNorm_mulLeftRight_apply_apply_le","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\n𝕜' : Type u_3\ninst✝³ : NonUnitalSeminormedRing 𝕜'\ninst✝² : NormedSpace 𝕜 𝕜'\ninst✝¹ : IsScalarTower 𝕜 𝕜' 𝕜'\ninst✝ : SMulCommClass 𝕜 𝕜' 𝕜'\nx y : 𝕜'\n⊢ LE.le (Norm.norm (((ContinuousLinearMap.mulLeftRight 𝕜 𝕜') x) y)) (HMul.hMul (Norm.norm x) (Norm.norm y))","decl":"theorem opNorm_mulLeftRight_apply_apply_le (x y : 𝕜') : ‖mulLeftRight 𝕜 𝕜' x y‖ ≤ ‖x‖ * ‖y‖ :=\n  (opNorm_comp_le _ _).trans <|\n    (mul_comm _ _).trans_le <|\n      mul_le_mul (opNorm_mul_apply_le _ _ _)\n        (opNorm_le_bound _ (norm_nonneg _) fun _ => (norm_mul_le _ _).trans_eq (mul_comm _ _))\n        (norm_nonneg _) (norm_nonneg _)\n\n"}
{"name":"ContinuousLinearMap.opNorm_mulLeftRight_apply_le","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\n𝕜' : Type u_3\ninst✝³ : NonUnitalSeminormedRing 𝕜'\ninst✝² : NormedSpace 𝕜 𝕜'\ninst✝¹ : IsScalarTower 𝕜 𝕜' 𝕜'\ninst✝ : SMulCommClass 𝕜 𝕜' 𝕜'\nx : 𝕜'\n⊢ LE.le (Norm.norm ((ContinuousLinearMap.mulLeftRight 𝕜 𝕜') x)) (Norm.norm x)","decl":"theorem opNorm_mulLeftRight_apply_le (x : 𝕜') : ‖mulLeftRight 𝕜 𝕜' x‖ ≤ ‖x‖ :=\n  opNorm_le_bound _ (norm_nonneg x) (opNorm_mulLeftRight_apply_apply_le 𝕜 𝕜' x)\n\n"}
{"name":"ContinuousLinearMap.opNorm_mulLeftRight_le","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\n𝕜' : Type u_3\ninst✝³ : NonUnitalSeminormedRing 𝕜'\ninst✝² : NormedSpace 𝕜 𝕜'\ninst✝¹ : IsScalarTower 𝕜 𝕜' 𝕜'\ninst✝ : SMulCommClass 𝕜 𝕜' 𝕜'\n⊢ LE.le (Norm.norm (ContinuousLinearMap.mulLeftRight 𝕜 𝕜')) 1","decl":"set_option maxSynthPendingDepth 2 in\ntheorem opNorm_mulLeftRight_le :\n    ‖mulLeftRight 𝕜 𝕜'‖ ≤ 1 :=\n  opNorm_le_bound _ zero_le_one fun x => (one_mul ‖x‖).symm ▸ opNorm_mulLeftRight_apply_le 𝕜 𝕜' x\n\n\n"}
{"name":"RegularNormedAlgebra.isometry_mul'","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\n𝕜' : Type u_3\ninst✝³ : NonUnitalSeminormedRing 𝕜'\ninst✝² : NormedSpace 𝕜 𝕜'\ninst✝¹ : IsScalarTower 𝕜 𝕜' 𝕜'\ninst✝ : SMulCommClass 𝕜 𝕜' 𝕜'\nself : RegularNormedAlgebra 𝕜 𝕜'\n⊢ Isometry ⇑(ContinuousLinearMap.mul 𝕜 𝕜')","decl":"/-- This is a mixin class for non-unital normed algebras which states that the left-regular\nrepresentation of the algebra on itself is isometric. Every unital normed algebra with `‖1‖ = 1` is\na regular normed algebra (see `NormedAlgebra.instRegularNormedAlgebra`). In addition, so is every\nC⋆-algebra, non-unital included (see `CStarRing.instRegularNormedAlgebra`), but there are yet other\nexamples. Any algebra with an approximate identity (e.g., $$L^1$$) is also regular.\n\nThis is a useful class because it gives rise to a nice norm on the unitization; in particular it is\na C⋆-norm when the norm on `A` is a C⋆-norm. -/\nclass _root_.RegularNormedAlgebra : Prop where\n  /-- The left regular representation of the algebra on itself is an isometry. -/\n  isometry_mul' : Isometry (mul 𝕜 𝕜')\n\n"}
{"name":"NormedAlgebra.instRegularNormedAlgebra","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Mul","initialProofState":"𝕜 : Type u_4\n𝕜' : Type u_5\ninst✝³ : NontriviallyNormedField 𝕜\ninst✝² : SeminormedRing 𝕜'\ninst✝¹ : NormedAlgebra 𝕜 𝕜'\ninst✝ : NormOneClass 𝕜'\n⊢ RegularNormedAlgebra 𝕜 𝕜'","decl":"/-- Every (unital) normed algebra such that `‖1‖ = 1` is a `RegularNormedAlgebra`. -/\ninstance _root_.NormedAlgebra.instRegularNormedAlgebra {𝕜 𝕜' : Type*} [NontriviallyNormedField 𝕜]\n    [SeminormedRing 𝕜'] [NormedAlgebra 𝕜 𝕜'] [NormOneClass 𝕜'] : RegularNormedAlgebra 𝕜 𝕜' where\n  isometry_mul' := AddMonoidHomClass.isometry_of_norm (mul 𝕜 𝕜') <|\n    fun x => le_antisymm (opNorm_mul_apply_le _ _ _) <| by\n      convert ratio_le_opNorm ((mul 𝕜 𝕜') x) (1 : 𝕜')\n      simp [norm_one]\n\n"}
{"name":"ContinuousLinearMap.isometry_mul","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\n𝕜' : Type u_3\ninst✝⁴ : NonUnitalSeminormedRing 𝕜'\ninst✝³ : NormedSpace 𝕜 𝕜'\ninst✝² : IsScalarTower 𝕜 𝕜' 𝕜'\ninst✝¹ : SMulCommClass 𝕜 𝕜' 𝕜'\ninst✝ : RegularNormedAlgebra 𝕜 𝕜'\n⊢ Isometry ⇑(ContinuousLinearMap.mul 𝕜 𝕜')","decl":"lemma isometry_mul : Isometry (mul 𝕜 𝕜') :=\n  RegularNormedAlgebra.isometry_mul'\n\n"}
{"name":"ContinuousLinearMap.opNorm_mul_apply","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\n𝕜' : Type u_3\ninst✝⁴ : NonUnitalSeminormedRing 𝕜'\ninst✝³ : NormedSpace 𝕜 𝕜'\ninst✝² : IsScalarTower 𝕜 𝕜' 𝕜'\ninst✝¹ : SMulCommClass 𝕜 𝕜' 𝕜'\ninst✝ : RegularNormedAlgebra 𝕜 𝕜'\nx : 𝕜'\n⊢ Eq (Norm.norm ((ContinuousLinearMap.mul 𝕜 𝕜') x)) (Norm.norm x)","decl":"@[simp]\nlemma opNorm_mul_apply (x : 𝕜') : ‖mul 𝕜 𝕜' x‖ = ‖x‖ :=\n  (AddMonoidHomClass.isometry_iff_norm (mul 𝕜 𝕜')).mp (isometry_mul 𝕜 𝕜') x\n\n\n"}
{"name":"ContinuousLinearMap.opNNNorm_mul_apply","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\n𝕜' : Type u_3\ninst✝⁴ : NonUnitalSeminormedRing 𝕜'\ninst✝³ : NormedSpace 𝕜 𝕜'\ninst✝² : IsScalarTower 𝕜 𝕜' 𝕜'\ninst✝¹ : SMulCommClass 𝕜 𝕜' 𝕜'\ninst✝ : RegularNormedAlgebra 𝕜 𝕜'\nx : 𝕜'\n⊢ Eq (NNNorm.nnnorm ((ContinuousLinearMap.mul 𝕜 𝕜') x)) (NNNorm.nnnorm x)","decl":"@[simp]\nlemma opNNNorm_mul_apply (x : 𝕜') : ‖mul 𝕜 𝕜' x‖₊ = ‖x‖₊ :=\n  Subtype.ext <| opNorm_mul_apply 𝕜 𝕜' x\n\n\n"}
{"name":"ContinuousLinearMap.coe_mulₗᵢ","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\n𝕜' : Type u_3\ninst✝⁴ : NonUnitalSeminormedRing 𝕜'\ninst✝³ : NormedSpace 𝕜 𝕜'\ninst✝² : IsScalarTower 𝕜 𝕜' 𝕜'\ninst✝¹ : SMulCommClass 𝕜 𝕜' 𝕜'\ninst✝ : RegularNormedAlgebra 𝕜 𝕜'\n⊢ Eq ⇑(ContinuousLinearMap.mulₗᵢ 𝕜 𝕜') ⇑(ContinuousLinearMap.mul 𝕜 𝕜')","decl":"@[simp]\ntheorem coe_mulₗᵢ : ⇑(mulₗᵢ 𝕜 𝕜') = mul 𝕜 𝕜' :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.lsmul_apply","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Mul","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : SeminormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\n𝕜' : Type u_3\ninst✝³ : NormedField 𝕜'\ninst✝² : NormedAlgebra 𝕜 𝕜'\ninst✝¹ : NormedSpace 𝕜' E\ninst✝ : IsScalarTower 𝕜 𝕜' E\nc : 𝕜'\nx : E\n⊢ Eq (((ContinuousLinearMap.lsmul 𝕜 𝕜') c) x) (HSMul.hSMul c x)","decl":"@[simp]\ntheorem lsmul_apply (c : 𝕜') (x : E) : lsmul 𝕜 𝕜' c x = c • x :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.norm_toSpanSingleton","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Mul","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : NontriviallyNormedField 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nx : E\n⊢ Eq (Norm.norm (ContinuousLinearMap.toSpanSingleton 𝕜 x)) (Norm.norm x)","decl":"theorem norm_toSpanSingleton (x : E) : ‖toSpanSingleton 𝕜 x‖ = ‖x‖ := by\n  refine opNorm_eq_of_bounds (norm_nonneg _) (fun x => ?_) fun N _ h => ?_\n  · rw [toSpanSingleton_apply, norm_smul, mul_comm]\n  · specialize h 1\n    rw [toSpanSingleton_apply, norm_smul, mul_comm] at h\n    exact (mul_le_mul_right (by simp)).mp h\n\n"}
{"name":"ContinuousLinearMap.opNorm_lsmul_apply_le","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Mul","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : SeminormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\n𝕜' : Type u_3\ninst✝³ : NormedField 𝕜'\ninst✝² : NormedAlgebra 𝕜 𝕜'\ninst✝¹ : NormedSpace 𝕜' E\ninst✝ : IsScalarTower 𝕜 𝕜' E\nx : 𝕜'\n⊢ LE.le (Norm.norm ((ContinuousLinearMap.lsmul 𝕜 𝕜') x)) (Norm.norm x)","decl":"theorem opNorm_lsmul_apply_le (x : 𝕜') : ‖(lsmul 𝕜 𝕜' x : E →L[𝕜] E)‖ ≤ ‖x‖ :=\n  ContinuousLinearMap.opNorm_le_bound _ (norm_nonneg x) fun y => norm_smul_le x y\n\n\n"}
{"name":"ContinuousLinearMap.opNorm_lsmul_le","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Mul","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : SeminormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\n𝕜' : Type u_3\ninst✝³ : NormedField 𝕜'\ninst✝² : NormedAlgebra 𝕜 𝕜'\ninst✝¹ : NormedSpace 𝕜' E\ninst✝ : IsScalarTower 𝕜 𝕜' E\n⊢ LE.le (Norm.norm (ContinuousLinearMap.lsmul 𝕜 𝕜')) 1","decl":"/-- The norm of `lsmul` is at most 1 in any semi-normed group. -/\ntheorem opNorm_lsmul_le : ‖(lsmul 𝕜 𝕜' : 𝕜' →L[𝕜] E →L[𝕜] E)‖ ≤ 1 := by\n  refine ContinuousLinearMap.opNorm_le_bound _ zero_le_one fun x => ?_\n  simp_rw [one_mul]\n  exact opNorm_lsmul_apply_le _\n\n\n"}
{"name":"ContinuousLinearMap.opNorm_mul","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\n𝕜' : Type u_3\ninst✝⁵ : NonUnitalNormedRing 𝕜'\ninst✝⁴ : NormedSpace 𝕜 𝕜'\ninst✝³ : IsScalarTower 𝕜 𝕜' 𝕜'\ninst✝² : SMulCommClass 𝕜 𝕜' 𝕜'\ninst✝¹ : RegularNormedAlgebra 𝕜 𝕜'\ninst✝ : Nontrivial 𝕜'\n⊢ Eq (Norm.norm (ContinuousLinearMap.mul 𝕜 𝕜')) 1","decl":"@[simp]\ntheorem opNorm_mul : ‖mul 𝕜 𝕜'‖ = 1 :=\n  (mulₗᵢ 𝕜 𝕜').norm_toContinuousLinearMap\n\n\n"}
{"name":"ContinuousLinearMap.opNNNorm_mul","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Mul","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\n𝕜' : Type u_3\ninst✝⁵ : NonUnitalNormedRing 𝕜'\ninst✝⁴ : NormedSpace 𝕜 𝕜'\ninst✝³ : IsScalarTower 𝕜 𝕜' 𝕜'\ninst✝² : SMulCommClass 𝕜 𝕜' 𝕜'\ninst✝¹ : RegularNormedAlgebra 𝕜 𝕜'\ninst✝ : Nontrivial 𝕜'\n⊢ Eq (NNNorm.nnnorm (ContinuousLinearMap.mul 𝕜 𝕜')) 1","decl":"@[simp]\ntheorem opNNNorm_mul : ‖mul 𝕜 𝕜'‖₊ = 1 :=\n  Subtype.ext <| opNorm_mul 𝕜 𝕜'\n\n\n"}
{"name":"ContinuousLinearMap.opNorm_lsmul","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Mul","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : NormedSpace 𝕜 E\n𝕜' : Type u_3\ninst✝⁴ : NormedField 𝕜'\ninst✝³ : NormedAlgebra 𝕜 𝕜'\ninst✝² : NormedSpace 𝕜' E\ninst✝¹ : IsScalarTower 𝕜 𝕜' E\ninst✝ : Nontrivial E\n⊢ Eq (Norm.norm (ContinuousLinearMap.lsmul 𝕜 𝕜')) 1","decl":"/-- The norm of `lsmul` equals 1 in any nontrivial normed group.\n\nThis is `ContinuousLinearMap.opNorm_lsmul_le` as an equality. -/\n@[simp]\ntheorem opNorm_lsmul [NormedField 𝕜'] [NormedAlgebra 𝕜 𝕜'] [NormedSpace 𝕜' E]\n    [IsScalarTower 𝕜 𝕜' E] [Nontrivial E] : ‖(lsmul 𝕜 𝕜' : 𝕜' →L[𝕜] E →L[𝕜] E)‖ = 1 := by\n  refine ContinuousLinearMap.opNorm_eq_of_bounds zero_le_one (fun x => ?_) fun N _ h => ?_\n  · rw [one_mul]\n    apply opNorm_lsmul_apply_le\n  obtain ⟨y, hy⟩ := exists_ne (0 : E)\n  have := le_of_opNorm_le _ (h 1) y\n  simp_rw [lsmul_apply, one_smul, norm_one, mul_one] at this\n  refine le_of_mul_le_mul_right ?_ (norm_pos_iff.mpr hy)\n  simp_rw [one_mul, this]\n\n\n"}
