{"name":"ContinuousLinearMap.mul_apply'","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nğ•œ' : Type u_3\ninstâœÂ³ : NonUnitalSeminormedRing ğ•œ'\ninstâœÂ² : NormedSpace ğ•œ ğ•œ'\ninstâœÂ¹ : IsScalarTower ğ•œ ğ•œ' ğ•œ'\ninstâœ : SMulCommClass ğ•œ ğ•œ' ğ•œ'\nx y : ğ•œ'\nâŠ¢ Eq (((ContinuousLinearMap.mul ğ•œ ğ•œ') x) y) (HMul.hMul x y)","decl":"@[simp]\ntheorem mul_apply' (x y : ğ•œ') : mul ğ•œ ğ•œ' x y = x * y :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.opNorm_mul_apply_le","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nğ•œ' : Type u_3\ninstâœÂ³ : NonUnitalSeminormedRing ğ•œ'\ninstâœÂ² : NormedSpace ğ•œ ğ•œ'\ninstâœÂ¹ : IsScalarTower ğ•œ ğ•œ' ğ•œ'\ninstâœ : SMulCommClass ğ•œ ğ•œ' ğ•œ'\nx : ğ•œ'\nâŠ¢ LE.le (Norm.norm ((ContinuousLinearMap.mul ğ•œ ğ•œ') x)) (Norm.norm x)","decl":"@[simp]\ntheorem opNorm_mul_apply_le (x : ğ•œ') : â€–mul ğ•œ ğ•œ' xâ€– â‰¤ â€–xâ€– :=\n  opNorm_le_bound _ (norm_nonneg x) (norm_mul_le x)\n\n\n"}
{"name":"ContinuousLinearMap.opNorm_mul_le","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nğ•œ' : Type u_3\ninstâœÂ³ : NonUnitalSeminormedRing ğ•œ'\ninstâœÂ² : NormedSpace ğ•œ ğ•œ'\ninstâœÂ¹ : IsScalarTower ğ•œ ğ•œ' ğ•œ'\ninstâœ : SMulCommClass ğ•œ ğ•œ' ğ•œ'\nâŠ¢ LE.le (Norm.norm (ContinuousLinearMap.mul ğ•œ ğ•œ')) 1","decl":"theorem opNorm_mul_le : â€–mul ğ•œ ğ•œ'â€– â‰¤ 1 :=\n  LinearMap.mkContinuousâ‚‚_norm_le _ zero_le_one _\n\n\n"}
{"name":"NonUnitalAlgHom.coe_Lmul","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nğ•œ' : Type u_3\ninstâœÂ³ : NonUnitalSeminormedRing ğ•œ'\ninstâœÂ² : NormedSpace ğ•œ ğ•œ'\ninstâœÂ¹ : IsScalarTower ğ•œ ğ•œ' ğ•œ'\ninstâœ : SMulCommClass ğ•œ ğ•œ' ğ•œ'\nâŠ¢ Eq â‡‘(NonUnitalAlgHom.Lmul ğ•œ ğ•œ') â‡‘(ContinuousLinearMap.mul ğ•œ ğ•œ')","decl":"variable {ğ•œ ğ•œ'} in\n@[simp]\ntheorem _root_.NonUnitalAlgHom.coe_Lmul : â‡‘(NonUnitalAlgHom.Lmul ğ•œ ğ•œ') = mul ğ•œ ğ•œ' :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.mulLeftRight_apply","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nğ•œ' : Type u_3\ninstâœÂ³ : NonUnitalSeminormedRing ğ•œ'\ninstâœÂ² : NormedSpace ğ•œ ğ•œ'\ninstâœÂ¹ : IsScalarTower ğ•œ ğ•œ' ğ•œ'\ninstâœ : SMulCommClass ğ•œ ğ•œ' ğ•œ'\nx y z : ğ•œ'\nâŠ¢ Eq ((((ContinuousLinearMap.mulLeftRight ğ•œ ğ•œ') x) y) z) (HMul.hMul (HMul.hMul x z) y)","decl":"@[simp]\ntheorem mulLeftRight_apply (x y z : ğ•œ') : mulLeftRight ğ•œ ğ•œ' x y z = x * z * y :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.opNorm_mulLeftRight_apply_apply_le","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nğ•œ' : Type u_3\ninstâœÂ³ : NonUnitalSeminormedRing ğ•œ'\ninstâœÂ² : NormedSpace ğ•œ ğ•œ'\ninstâœÂ¹ : IsScalarTower ğ•œ ğ•œ' ğ•œ'\ninstâœ : SMulCommClass ğ•œ ğ•œ' ğ•œ'\nx y : ğ•œ'\nâŠ¢ LE.le (Norm.norm (((ContinuousLinearMap.mulLeftRight ğ•œ ğ•œ') x) y)) (HMul.hMul (Norm.norm x) (Norm.norm y))","decl":"theorem opNorm_mulLeftRight_apply_apply_le (x y : ğ•œ') : â€–mulLeftRight ğ•œ ğ•œ' x yâ€– â‰¤ â€–xâ€– * â€–yâ€– :=\n  (opNorm_comp_le _ _).trans <|\n    (mul_comm _ _).trans_le <|\n      mul_le_mul (opNorm_mul_apply_le _ _ _)\n        (opNorm_le_bound _ (norm_nonneg _) fun _ => (norm_mul_le _ _).trans_eq (mul_comm _ _))\n        (norm_nonneg _) (norm_nonneg _)\n\n"}
{"name":"ContinuousLinearMap.opNorm_mulLeftRight_apply_le","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nğ•œ' : Type u_3\ninstâœÂ³ : NonUnitalSeminormedRing ğ•œ'\ninstâœÂ² : NormedSpace ğ•œ ğ•œ'\ninstâœÂ¹ : IsScalarTower ğ•œ ğ•œ' ğ•œ'\ninstâœ : SMulCommClass ğ•œ ğ•œ' ğ•œ'\nx : ğ•œ'\nâŠ¢ LE.le (Norm.norm ((ContinuousLinearMap.mulLeftRight ğ•œ ğ•œ') x)) (Norm.norm x)","decl":"theorem opNorm_mulLeftRight_apply_le (x : ğ•œ') : â€–mulLeftRight ğ•œ ğ•œ' xâ€– â‰¤ â€–xâ€– :=\n  opNorm_le_bound _ (norm_nonneg x) (opNorm_mulLeftRight_apply_apply_le ğ•œ ğ•œ' x)\n\n"}
{"name":"ContinuousLinearMap.opNorm_mulLeftRight_le","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nğ•œ' : Type u_3\ninstâœÂ³ : NonUnitalSeminormedRing ğ•œ'\ninstâœÂ² : NormedSpace ğ•œ ğ•œ'\ninstâœÂ¹ : IsScalarTower ğ•œ ğ•œ' ğ•œ'\ninstâœ : SMulCommClass ğ•œ ğ•œ' ğ•œ'\nâŠ¢ LE.le (Norm.norm (ContinuousLinearMap.mulLeftRight ğ•œ ğ•œ')) 1","decl":"set_option maxSynthPendingDepth 2 in\ntheorem opNorm_mulLeftRight_le :\n    â€–mulLeftRight ğ•œ ğ•œ'â€– â‰¤ 1 :=\n  opNorm_le_bound _ zero_le_one fun x => (one_mul â€–xâ€–).symm â–¸ opNorm_mulLeftRight_apply_le ğ•œ ğ•œ' x\n\n\n"}
{"name":"RegularNormedAlgebra.isometry_mul'","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nğ•œ' : Type u_3\ninstâœÂ³ : NonUnitalSeminormedRing ğ•œ'\ninstâœÂ² : NormedSpace ğ•œ ğ•œ'\ninstâœÂ¹ : IsScalarTower ğ•œ ğ•œ' ğ•œ'\ninstâœ : SMulCommClass ğ•œ ğ•œ' ğ•œ'\nself : RegularNormedAlgebra ğ•œ ğ•œ'\nâŠ¢ Isometry â‡‘(ContinuousLinearMap.mul ğ•œ ğ•œ')","decl":"/-- This is a mixin class for non-unital normed algebras which states that the left-regular\nrepresentation of the algebra on itself is isometric. Every unital normed algebra with `â€–1â€– = 1` is\na regular normed algebra (see `NormedAlgebra.instRegularNormedAlgebra`). In addition, so is every\nCâ‹†-algebra, non-unital included (see `CStarRing.instRegularNormedAlgebra`), but there are yet other\nexamples. Any algebra with an approximate identity (e.g., $$L^1$$) is also regular.\n\nThis is a useful class because it gives rise to a nice norm on the unitization; in particular it is\na Câ‹†-norm when the norm on `A` is a Câ‹†-norm. -/\nclass _root_.RegularNormedAlgebra : Prop where\n  /-- The left regular representation of the algebra on itself is an isometry. -/\n  isometry_mul' : Isometry (mul ğ•œ ğ•œ')\n\n"}
{"name":"NormedAlgebra.instRegularNormedAlgebra","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Mul","initialProofState":"ğ•œ : Type u_4\nğ•œ' : Type u_5\ninstâœÂ³ : NontriviallyNormedField ğ•œ\ninstâœÂ² : SeminormedRing ğ•œ'\ninstâœÂ¹ : NormedAlgebra ğ•œ ğ•œ'\ninstâœ : NormOneClass ğ•œ'\nâŠ¢ RegularNormedAlgebra ğ•œ ğ•œ'","decl":"/-- Every (unital) normed algebra such that `â€–1â€– = 1` is a `RegularNormedAlgebra`. -/\ninstance _root_.NormedAlgebra.instRegularNormedAlgebra {ğ•œ ğ•œ' : Type*} [NontriviallyNormedField ğ•œ]\n    [SeminormedRing ğ•œ'] [NormedAlgebra ğ•œ ğ•œ'] [NormOneClass ğ•œ'] : RegularNormedAlgebra ğ•œ ğ•œ' where\n  isometry_mul' := AddMonoidHomClass.isometry_of_norm (mul ğ•œ ğ•œ') <|\n    fun x => le_antisymm (opNorm_mul_apply_le _ _ _) <| by\n      convert ratio_le_opNorm ((mul ğ•œ ğ•œ') x) (1 : ğ•œ')\n      simp [norm_one]\n\n"}
{"name":"ContinuousLinearMap.isometry_mul","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nğ•œ' : Type u_3\ninstâœâ´ : NonUnitalSeminormedRing ğ•œ'\ninstâœÂ³ : NormedSpace ğ•œ ğ•œ'\ninstâœÂ² : IsScalarTower ğ•œ ğ•œ' ğ•œ'\ninstâœÂ¹ : SMulCommClass ğ•œ ğ•œ' ğ•œ'\ninstâœ : RegularNormedAlgebra ğ•œ ğ•œ'\nâŠ¢ Isometry â‡‘(ContinuousLinearMap.mul ğ•œ ğ•œ')","decl":"lemma isometry_mul : Isometry (mul ğ•œ ğ•œ') :=\n  RegularNormedAlgebra.isometry_mul'\n\n"}
{"name":"ContinuousLinearMap.opNorm_mul_apply","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nğ•œ' : Type u_3\ninstâœâ´ : NonUnitalSeminormedRing ğ•œ'\ninstâœÂ³ : NormedSpace ğ•œ ğ•œ'\ninstâœÂ² : IsScalarTower ğ•œ ğ•œ' ğ•œ'\ninstâœÂ¹ : SMulCommClass ğ•œ ğ•œ' ğ•œ'\ninstâœ : RegularNormedAlgebra ğ•œ ğ•œ'\nx : ğ•œ'\nâŠ¢ Eq (Norm.norm ((ContinuousLinearMap.mul ğ•œ ğ•œ') x)) (Norm.norm x)","decl":"@[simp]\nlemma opNorm_mul_apply (x : ğ•œ') : â€–mul ğ•œ ğ•œ' xâ€– = â€–xâ€– :=\n  (AddMonoidHomClass.isometry_iff_norm (mul ğ•œ ğ•œ')).mp (isometry_mul ğ•œ ğ•œ') x\n\n\n"}
{"name":"ContinuousLinearMap.opNNNorm_mul_apply","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nğ•œ' : Type u_3\ninstâœâ´ : NonUnitalSeminormedRing ğ•œ'\ninstâœÂ³ : NormedSpace ğ•œ ğ•œ'\ninstâœÂ² : IsScalarTower ğ•œ ğ•œ' ğ•œ'\ninstâœÂ¹ : SMulCommClass ğ•œ ğ•œ' ğ•œ'\ninstâœ : RegularNormedAlgebra ğ•œ ğ•œ'\nx : ğ•œ'\nâŠ¢ Eq (NNNorm.nnnorm ((ContinuousLinearMap.mul ğ•œ ğ•œ') x)) (NNNorm.nnnorm x)","decl":"@[simp]\nlemma opNNNorm_mul_apply (x : ğ•œ') : â€–mul ğ•œ ğ•œ' xâ€–â‚Š = â€–xâ€–â‚Š :=\n  Subtype.ext <| opNorm_mul_apply ğ•œ ğ•œ' x\n\n\n"}
{"name":"ContinuousLinearMap.coe_mulâ‚—áµ¢","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nğ•œ' : Type u_3\ninstâœâ´ : NonUnitalSeminormedRing ğ•œ'\ninstâœÂ³ : NormedSpace ğ•œ ğ•œ'\ninstâœÂ² : IsScalarTower ğ•œ ğ•œ' ğ•œ'\ninstâœÂ¹ : SMulCommClass ğ•œ ğ•œ' ğ•œ'\ninstâœ : RegularNormedAlgebra ğ•œ ğ•œ'\nâŠ¢ Eq â‡‘(ContinuousLinearMap.mulâ‚—áµ¢ ğ•œ ğ•œ') â‡‘(ContinuousLinearMap.mul ğ•œ ğ•œ')","decl":"@[simp]\ntheorem coe_mulâ‚—áµ¢ : â‡‘(mulâ‚—áµ¢ ğ•œ ğ•œ') = mul ğ•œ ğ•œ' :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.lsmul_apply","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Mul","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : SeminormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nğ•œ' : Type u_3\ninstâœÂ³ : NormedField ğ•œ'\ninstâœÂ² : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ¹ : NormedSpace ğ•œ' E\ninstâœ : IsScalarTower ğ•œ ğ•œ' E\nc : ğ•œ'\nx : E\nâŠ¢ Eq (((ContinuousLinearMap.lsmul ğ•œ ğ•œ') c) x) (HSMul.hSMul c x)","decl":"@[simp]\ntheorem lsmul_apply (c : ğ•œ') (x : E) : lsmul ğ•œ ğ•œ' c x = c â€¢ x :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.norm_toSpanSingleton","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Mul","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : NontriviallyNormedField ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nx : E\nâŠ¢ Eq (Norm.norm (ContinuousLinearMap.toSpanSingleton ğ•œ x)) (Norm.norm x)","decl":"theorem norm_toSpanSingleton (x : E) : â€–toSpanSingleton ğ•œ xâ€– = â€–xâ€– := by\n  refine opNorm_eq_of_bounds (norm_nonneg _) (fun x => ?_) fun N _ h => ?_\n  Â· rw [toSpanSingleton_apply, norm_smul, mul_comm]\n  Â· specialize h 1\n    rw [toSpanSingleton_apply, norm_smul, mul_comm] at h\n    exact (mul_le_mul_right (by simp)).mp h\n\n"}
{"name":"ContinuousLinearMap.opNorm_lsmul_apply_le","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Mul","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : SeminormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nğ•œ' : Type u_3\ninstâœÂ³ : NormedField ğ•œ'\ninstâœÂ² : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ¹ : NormedSpace ğ•œ' E\ninstâœ : IsScalarTower ğ•œ ğ•œ' E\nx : ğ•œ'\nâŠ¢ LE.le (Norm.norm ((ContinuousLinearMap.lsmul ğ•œ ğ•œ') x)) (Norm.norm x)","decl":"theorem opNorm_lsmul_apply_le (x : ğ•œ') : â€–(lsmul ğ•œ ğ•œ' x : E â†’L[ğ•œ] E)â€– â‰¤ â€–xâ€– :=\n  ContinuousLinearMap.opNorm_le_bound _ (norm_nonneg x) fun y => norm_smul_le x y\n\n\n"}
{"name":"ContinuousLinearMap.opNorm_lsmul_le","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Mul","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : SeminormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nğ•œ' : Type u_3\ninstâœÂ³ : NormedField ğ•œ'\ninstâœÂ² : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ¹ : NormedSpace ğ•œ' E\ninstâœ : IsScalarTower ğ•œ ğ•œ' E\nâŠ¢ LE.le (Norm.norm (ContinuousLinearMap.lsmul ğ•œ ğ•œ')) 1","decl":"/-- The norm of `lsmul` is at most 1 in any semi-normed group. -/\ntheorem opNorm_lsmul_le : â€–(lsmul ğ•œ ğ•œ' : ğ•œ' â†’L[ğ•œ] E â†’L[ğ•œ] E)â€– â‰¤ 1 := by\n  refine ContinuousLinearMap.opNorm_le_bound _ zero_le_one fun x => ?_\n  simp_rw [one_mul]\n  exact opNorm_lsmul_apply_le _\n\n\n"}
{"name":"ContinuousLinearMap.opNorm_mul","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nğ•œ' : Type u_3\ninstâœâµ : NonUnitalNormedRing ğ•œ'\ninstâœâ´ : NormedSpace ğ•œ ğ•œ'\ninstâœÂ³ : IsScalarTower ğ•œ ğ•œ' ğ•œ'\ninstâœÂ² : SMulCommClass ğ•œ ğ•œ' ğ•œ'\ninstâœÂ¹ : RegularNormedAlgebra ğ•œ ğ•œ'\ninstâœ : Nontrivial ğ•œ'\nâŠ¢ Eq (Norm.norm (ContinuousLinearMap.mul ğ•œ ğ•œ')) 1","decl":"@[simp]\ntheorem opNorm_mul : â€–mul ğ•œ ğ•œ'â€– = 1 :=\n  (mulâ‚—áµ¢ ğ•œ ğ•œ').norm_toContinuousLinearMap\n\n\n"}
{"name":"ContinuousLinearMap.opNNNorm_mul","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Mul","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nğ•œ' : Type u_3\ninstâœâµ : NonUnitalNormedRing ğ•œ'\ninstâœâ´ : NormedSpace ğ•œ ğ•œ'\ninstâœÂ³ : IsScalarTower ğ•œ ğ•œ' ğ•œ'\ninstâœÂ² : SMulCommClass ğ•œ ğ•œ' ğ•œ'\ninstâœÂ¹ : RegularNormedAlgebra ğ•œ ğ•œ'\ninstâœ : Nontrivial ğ•œ'\nâŠ¢ Eq (NNNorm.nnnorm (ContinuousLinearMap.mul ğ•œ ğ•œ')) 1","decl":"@[simp]\ntheorem opNNNorm_mul : â€–mul ğ•œ ğ•œ'â€–â‚Š = 1 :=\n  Subtype.ext <| opNorm_mul ğ•œ ğ•œ'\n\n\n"}
{"name":"ContinuousLinearMap.opNorm_lsmul","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Mul","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace ğ•œ E\nğ•œ' : Type u_3\ninstâœâ´ : NormedField ğ•œ'\ninstâœÂ³ : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ² : NormedSpace ğ•œ' E\ninstâœÂ¹ : IsScalarTower ğ•œ ğ•œ' E\ninstâœ : Nontrivial E\nâŠ¢ Eq (Norm.norm (ContinuousLinearMap.lsmul ğ•œ ğ•œ')) 1","decl":"/-- The norm of `lsmul` equals 1 in any nontrivial normed group.\n\nThis is `ContinuousLinearMap.opNorm_lsmul_le` as an equality. -/\n@[simp]\ntheorem opNorm_lsmul [NormedField ğ•œ'] [NormedAlgebra ğ•œ ğ•œ'] [NormedSpace ğ•œ' E]\n    [IsScalarTower ğ•œ ğ•œ' E] [Nontrivial E] : â€–(lsmul ğ•œ ğ•œ' : ğ•œ' â†’L[ğ•œ] E â†’L[ğ•œ] E)â€– = 1 := by\n  refine ContinuousLinearMap.opNorm_eq_of_bounds zero_le_one (fun x => ?_) fun N _ h => ?_\n  Â· rw [one_mul]\n    apply opNorm_lsmul_apply_le\n  obtain âŸ¨y, hyâŸ© := exists_ne (0 : E)\n  have := le_of_opNorm_le _ (h 1) y\n  simp_rw [lsmul_apply, one_smul, norm_one, mul_one] at this\n  refine le_of_mul_le_mul_right ?_ (norm_pos_iff.mpr hy)\n  simp_rw [one_mul, this]\n\n\n"}
