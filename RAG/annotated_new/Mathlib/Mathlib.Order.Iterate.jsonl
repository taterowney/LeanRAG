{"name":"Monotone.seq_le_seq","module":"Mathlib.Order.Iterate","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nf : α → α\nx y : Nat → α\nhf : Monotone f\nn : Nat\nh₀ : LE.le (x 0) (y 0)\nhx : ∀ (k : Nat), LT.lt k n → LE.le (x (HAdd.hAdd k 1)) (f (x k))\nhy : ∀ (k : Nat), LT.lt k n → LE.le (f (y k)) (y (HAdd.hAdd k 1))\n⊢ LE.le (x n) (y n)","decl":"theorem seq_le_seq (hf : Monotone f) (n : ℕ) (h₀ : x 0 ≤ y 0) (hx : ∀ k < n, x (k + 1) ≤ f (x k))\n    (hy : ∀ k < n, f (y k) ≤ y (k + 1)) : x n ≤ y n := by\n  induction n with\n  | zero => exact h₀\n  | succ n ihn =>\n    refine (hx _ n.lt_succ_self).trans ((hf <| ihn ?_ ?_).trans (hy _ n.lt_succ_self))\n    · exact fun k hk => hx _ (hk.trans n.lt_succ_self)\n    · exact fun k hk => hy _ (hk.trans n.lt_succ_self)\n\n"}
{"name":"Monotone.seq_pos_lt_seq_of_lt_of_le","module":"Mathlib.Order.Iterate","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nf : α → α\nx y : Nat → α\nhf : Monotone f\nn : Nat\nhn : LT.lt 0 n\nh₀ : LE.le (x 0) (y 0)\nhx : ∀ (k : Nat), LT.lt k n → LT.lt (x (HAdd.hAdd k 1)) (f (x k))\nhy : ∀ (k : Nat), LT.lt k n → LE.le (f (y k)) (y (HAdd.hAdd k 1))\n⊢ LT.lt (x n) (y n)","decl":"theorem seq_pos_lt_seq_of_lt_of_le (hf : Monotone f) {n : ℕ} (hn : 0 < n) (h₀ : x 0 ≤ y 0)\n    (hx : ∀ k < n, x (k + 1) < f (x k)) (hy : ∀ k < n, f (y k) ≤ y (k + 1)) : x n < y n := by\n  induction n with\n  | zero => exact hn.false.elim\n  | succ n ihn =>\n  suffices x n ≤ y n from (hx n n.lt_succ_self).trans_le ((hf this).trans <| hy n n.lt_succ_self)\n  cases n with\n  | zero => exact h₀\n  | succ n =>\n    refine (ihn n.zero_lt_succ (fun k hk => hx _ ?_) fun k hk => hy _ ?_).le <;>\n    exact hk.trans n.succ.lt_succ_self\n\n"}
{"name":"Monotone.seq_pos_lt_seq_of_le_of_lt","module":"Mathlib.Order.Iterate","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nf : α → α\nx y : Nat → α\nhf : Monotone f\nn : Nat\nhn : LT.lt 0 n\nh₀ : LE.le (x 0) (y 0)\nhx : ∀ (k : Nat), LT.lt k n → LE.le (x (HAdd.hAdd k 1)) (f (x k))\nhy : ∀ (k : Nat), LT.lt k n → LT.lt (f (y k)) (y (HAdd.hAdd k 1))\n⊢ LT.lt (x n) (y n)","decl":"theorem seq_pos_lt_seq_of_le_of_lt (hf : Monotone f) {n : ℕ} (hn : 0 < n) (h₀ : x 0 ≤ y 0)\n    (hx : ∀ k < n, x (k + 1) ≤ f (x k)) (hy : ∀ k < n, f (y k) < y (k + 1)) : x n < y n :=\n  hf.dual.seq_pos_lt_seq_of_lt_of_le hn h₀ hy hx\n\n"}
{"name":"Monotone.seq_lt_seq_of_lt_of_le","module":"Mathlib.Order.Iterate","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nf : α → α\nx y : Nat → α\nhf : Monotone f\nn : Nat\nh₀ : LT.lt (x 0) (y 0)\nhx : ∀ (k : Nat), LT.lt k n → LT.lt (x (HAdd.hAdd k 1)) (f (x k))\nhy : ∀ (k : Nat), LT.lt k n → LE.le (f (y k)) (y (HAdd.hAdd k 1))\n⊢ LT.lt (x n) (y n)","decl":"theorem seq_lt_seq_of_lt_of_le (hf : Monotone f) (n : ℕ) (h₀ : x 0 < y 0)\n    (hx : ∀ k < n, x (k + 1) < f (x k)) (hy : ∀ k < n, f (y k) ≤ y (k + 1)) : x n < y n := by\n  cases n\n  exacts [h₀, hf.seq_pos_lt_seq_of_lt_of_le (Nat.zero_lt_succ _) h₀.le hx hy]\n\n"}
{"name":"Monotone.seq_lt_seq_of_le_of_lt","module":"Mathlib.Order.Iterate","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nf : α → α\nx y : Nat → α\nhf : Monotone f\nn : Nat\nh₀ : LT.lt (x 0) (y 0)\nhx : ∀ (k : Nat), LT.lt k n → LE.le (x (HAdd.hAdd k 1)) (f (x k))\nhy : ∀ (k : Nat), LT.lt k n → LT.lt (f (y k)) (y (HAdd.hAdd k 1))\n⊢ LT.lt (x n) (y n)","decl":"theorem seq_lt_seq_of_le_of_lt (hf : Monotone f) (n : ℕ) (h₀ : x 0 < y 0)\n    (hx : ∀ k < n, x (k + 1) ≤ f (x k)) (hy : ∀ k < n, f (y k) < y (k + 1)) : x n < y n :=\n  hf.dual.seq_lt_seq_of_lt_of_le n h₀ hy hx\n\n"}
{"name":"Monotone.le_iterate_comp_of_le","module":"Mathlib.Order.Iterate","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nf : α → α\nβ : Type u_2\ng : β → β\nh : β → α\nhf : Monotone f\nH : LE.le (Function.comp h g) (Function.comp f h)\nn : Nat\n⊢ LE.le (Function.comp h (Nat.iterate g n)) (Function.comp (Nat.iterate f n) h)","decl":"theorem le_iterate_comp_of_le (hf : Monotone f) (H : h ∘ g ≤ f ∘ h) (n : ℕ) :\n    h ∘ g^[n] ≤ f^[n] ∘ h := fun x => by\n  apply hf.seq_le_seq n <;> intros <;>\n    simp [iterate_succ', -iterate_succ, comp_apply, id_eq, le_refl]\n  case hx => exact H _\n\n"}
{"name":"Monotone.iterate_comp_le_of_le","module":"Mathlib.Order.Iterate","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nf : α → α\nβ : Type u_2\ng : β → β\nh : β → α\nhf : Monotone f\nH : LE.le (Function.comp f h) (Function.comp h g)\nn : Nat\n⊢ LE.le (Function.comp (Nat.iterate f n) h) (Function.comp h (Nat.iterate g n))","decl":"theorem iterate_comp_le_of_le (hf : Monotone f) (H : f ∘ h ≤ h ∘ g) (n : ℕ) :\n    f^[n] ∘ h ≤ h ∘ g^[n] :=\n  hf.dual.le_iterate_comp_of_le H n\n\n"}
{"name":"Monotone.iterate_le_of_le","module":"Mathlib.Order.Iterate","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nf g : α → α\nhf : Monotone f\nh : LE.le f g\nn : Nat\n⊢ LE.le (Nat.iterate f n) (Nat.iterate g n)","decl":"/-- If `f ≤ g` and `f` is monotone, then `f^[n] ≤ g^[n]`. -/\ntheorem iterate_le_of_le {g : α → α} (hf : Monotone f) (h : f ≤ g) (n : ℕ) : f^[n] ≤ g^[n] :=\n  hf.iterate_comp_le_of_le h n\n\n"}
{"name":"Monotone.le_iterate_of_le","module":"Mathlib.Order.Iterate","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nf g : α → α\nhg : Monotone g\nh : LE.le f g\nn : Nat\n⊢ LE.le (Nat.iterate f n) (Nat.iterate g n)","decl":"/-- If `f ≤ g` and `g` is monotone, then `f^[n] ≤ g^[n]`. -/\ntheorem le_iterate_of_le {g : α → α} (hg : Monotone g) (h : f ≤ g) (n : ℕ) : f^[n] ≤ g^[n] :=\n  hg.dual.iterate_le_of_le h n\n\n"}
{"name":"Function.id_le_iterate_of_id_le","module":"Mathlib.Order.Iterate","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nf : α → α\nh : LE.le id f\nn : Nat\n⊢ LE.le id (Nat.iterate f n)","decl":"/-- If $x ≤ f x$ for all $x$ (we write this as `id ≤ f`), then the same is true for any iterate\n`f^[n]` of `f`. -/\ntheorem id_le_iterate_of_id_le (h : id ≤ f) (n : ℕ) : id ≤ f^[n] := by\n  simpa only [iterate_id] using monotone_id.iterate_le_of_le h n\n\n"}
{"name":"Function.iterate_le_id_of_le_id","module":"Mathlib.Order.Iterate","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nf : α → α\nh : LE.le f id\nn : Nat\n⊢ LE.le (Nat.iterate f n) id","decl":"theorem iterate_le_id_of_le_id (h : f ≤ id) (n : ℕ) : f^[n] ≤ id :=\n  @id_le_iterate_of_id_le αᵒᵈ _ f h n\n\n"}
{"name":"Function.monotone_iterate_of_id_le","module":"Mathlib.Order.Iterate","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nf : α → α\nh : LE.le id f\n⊢ Monotone fun m => Nat.iterate f m","decl":"theorem monotone_iterate_of_id_le (h : id ≤ f) : Monotone fun m => f^[m] :=\n  monotone_nat_of_le_succ fun n x => by\n    rw [iterate_succ_apply']\n    exact h _\n\n"}
{"name":"Function.antitone_iterate_of_le_id","module":"Mathlib.Order.Iterate","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nf : α → α\nh : LE.le f id\n⊢ Antitone fun m => Nat.iterate f m","decl":"theorem antitone_iterate_of_le_id (h : f ≤ id) : Antitone fun m => f^[m] := fun m n hmn =>\n  @monotone_iterate_of_id_le αᵒᵈ _ f h m n hmn\n\n"}
{"name":"Function.Commute.iterate_le_of_map_le","module":"Mathlib.Order.Iterate","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nf g : α → α\nh : Function.Commute f g\nhf : Monotone f\nhg : Monotone g\nx : α\nhx : LE.le (f x) (g x)\nn : Nat\n⊢ LE.le (Nat.iterate f n x) (Nat.iterate g n x)","decl":"theorem iterate_le_of_map_le (h : Commute f g) (hf : Monotone f) (hg : Monotone g) {x}\n    (hx : f x ≤ g x) (n : ℕ) : f^[n] x ≤ g^[n] x := by\n  apply hf.seq_le_seq n\n  · rfl\n  · intros; rw [iterate_succ_apply']\n  · intros; simp [h.iterate_right _ _, hg.iterate _ hx]\n\n"}
{"name":"Function.Commute.iterate_pos_lt_of_map_lt","module":"Mathlib.Order.Iterate","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nf g : α → α\nh : Function.Commute f g\nhf : Monotone f\nhg : StrictMono g\nx : α\nhx : LT.lt (f x) (g x)\nn : Nat\nhn : LT.lt 0 n\n⊢ LT.lt (Nat.iterate f n x) (Nat.iterate g n x)","decl":"theorem iterate_pos_lt_of_map_lt (h : Commute f g) (hf : Monotone f) (hg : StrictMono g) {x}\n    (hx : f x < g x) {n} (hn : 0 < n) : f^[n] x < g^[n] x := by\n  apply hf.seq_pos_lt_seq_of_le_of_lt hn\n  · rfl\n  · intros; rw [iterate_succ_apply']\n  · intros; simp [h.iterate_right _ _, hg.iterate _ hx]\n\n"}
{"name":"Function.Commute.iterate_pos_lt_of_map_lt'","module":"Mathlib.Order.Iterate","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nf g : α → α\nh : Function.Commute f g\nhf : StrictMono f\nhg : Monotone g\nx : α\nhx : LT.lt (f x) (g x)\nn : Nat\nhn : LT.lt 0 n\n⊢ LT.lt (Nat.iterate f n x) (Nat.iterate g n x)","decl":"theorem iterate_pos_lt_of_map_lt' (h : Commute f g) (hf : StrictMono f) (hg : Monotone g) {x}\n    (hx : f x < g x) {n} (hn : 0 < n) : f^[n] x < g^[n] x :=\n  @iterate_pos_lt_of_map_lt αᵒᵈ _ g f h.symm hg.dual hf.dual x hx n hn\n\n"}
{"name":"Function.Commute.iterate_pos_lt_iff_map_lt","module":"Mathlib.Order.Iterate","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nf g : α → α\nh : Function.Commute f g\nhf : Monotone f\nhg : StrictMono g\nx : α\nn : Nat\nhn : LT.lt 0 n\n⊢ Iff (LT.lt (Nat.iterate f n x) (Nat.iterate g n x)) (LT.lt (f x) (g x))","decl":"theorem iterate_pos_lt_iff_map_lt (h : Commute f g) (hf : Monotone f) (hg : StrictMono g) {x n}\n    (hn : 0 < n) : f^[n] x < g^[n] x ↔ f x < g x := by\n  rcases lt_trichotomy (f x) (g x) with (H | H | H)\n  · simp only [*, iterate_pos_lt_of_map_lt]\n  · simp only [*, h.iterate_eq_of_map_eq, lt_irrefl]\n  · simp only [lt_asymm H, lt_asymm (h.symm.iterate_pos_lt_of_map_lt' hg hf H hn)]\n\n"}
{"name":"Function.Commute.iterate_pos_lt_iff_map_lt'","module":"Mathlib.Order.Iterate","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nf g : α → α\nh : Function.Commute f g\nhf : StrictMono f\nhg : Monotone g\nx : α\nn : Nat\nhn : LT.lt 0 n\n⊢ Iff (LT.lt (Nat.iterate f n x) (Nat.iterate g n x)) (LT.lt (f x) (g x))","decl":"theorem iterate_pos_lt_iff_map_lt' (h : Commute f g) (hf : StrictMono f) (hg : Monotone g) {x n}\n    (hn : 0 < n) : f^[n] x < g^[n] x ↔ f x < g x :=\n  @iterate_pos_lt_iff_map_lt αᵒᵈ _ _ _ h.symm hg.dual hf.dual x n hn\n\n"}
{"name":"Function.Commute.iterate_pos_le_iff_map_le","module":"Mathlib.Order.Iterate","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nf g : α → α\nh : Function.Commute f g\nhf : Monotone f\nhg : StrictMono g\nx : α\nn : Nat\nhn : LT.lt 0 n\n⊢ Iff (LE.le (Nat.iterate f n x) (Nat.iterate g n x)) (LE.le (f x) (g x))","decl":"theorem iterate_pos_le_iff_map_le (h : Commute f g) (hf : Monotone f) (hg : StrictMono g) {x n}\n    (hn : 0 < n) : f^[n] x ≤ g^[n] x ↔ f x ≤ g x := by\n  simpa only [not_lt] using not_congr (h.symm.iterate_pos_lt_iff_map_lt' hg hf hn)\n\n"}
{"name":"Function.Commute.iterate_pos_le_iff_map_le'","module":"Mathlib.Order.Iterate","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nf g : α → α\nh : Function.Commute f g\nhf : StrictMono f\nhg : Monotone g\nx : α\nn : Nat\nhn : LT.lt 0 n\n⊢ Iff (LE.le (Nat.iterate f n x) (Nat.iterate g n x)) (LE.le (f x) (g x))","decl":"theorem iterate_pos_le_iff_map_le' (h : Commute f g) (hf : StrictMono f) (hg : Monotone g) {x n}\n    (hn : 0 < n) : f^[n] x ≤ g^[n] x ↔ f x ≤ g x := by\n  simpa only [not_lt] using not_congr (h.symm.iterate_pos_lt_iff_map_lt hg hf hn)\n\n"}
{"name":"Function.Commute.iterate_pos_eq_iff_map_eq","module":"Mathlib.Order.Iterate","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nf g : α → α\nh : Function.Commute f g\nhf : Monotone f\nhg : StrictMono g\nx : α\nn : Nat\nhn : LT.lt 0 n\n⊢ Iff (Eq (Nat.iterate f n x) (Nat.iterate g n x)) (Eq (f x) (g x))","decl":"theorem iterate_pos_eq_iff_map_eq (h : Commute f g) (hf : Monotone f) (hg : StrictMono g) {x n}\n    (hn : 0 < n) : f^[n] x = g^[n] x ↔ f x = g x := by\n  simp only [le_antisymm_iff, h.iterate_pos_le_iff_map_le hf hg hn,\n    h.symm.iterate_pos_le_iff_map_le' hg hf hn]\n\n"}
{"name":"Monotone.monotone_iterate_of_le_map","module":"Mathlib.Order.Iterate","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nf : α → α\nx : α\nhf : Monotone f\nhx : LE.le x (f x)\n⊢ Monotone fun n => Nat.iterate f n x","decl":"/-- If `f` is a monotone map and `x ≤ f x` at some point `x`, then the iterates `f^[n] x` form\na monotone sequence. -/\ntheorem monotone_iterate_of_le_map (hf : Monotone f) (hx : x ≤ f x) : Monotone fun n => f^[n] x :=\n  monotone_nat_of_le_succ fun n => by\n    rw [iterate_succ_apply]\n    exact hf.iterate n hx\n\n"}
{"name":"Monotone.antitone_iterate_of_map_le","module":"Mathlib.Order.Iterate","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nf : α → α\nx : α\nhf : Monotone f\nhx : LE.le (f x) x\n⊢ Antitone fun n => Nat.iterate f n x","decl":"/-- If `f` is a monotone map and `f x ≤ x` at some point `x`, then the iterates `f^[n] x` form\nan antitone sequence. -/\ntheorem antitone_iterate_of_map_le (hf : Monotone f) (hx : f x ≤ x) : Antitone fun n => f^[n] x :=\n  hf.dual.monotone_iterate_of_le_map hx\n\n"}
{"name":"StrictMono.strictMono_iterate_of_lt_map","module":"Mathlib.Order.Iterate","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nf : α → α\nx : α\nhf : StrictMono f\nhx : LT.lt x (f x)\n⊢ StrictMono fun n => Nat.iterate f n x","decl":"/-- If `f` is a strictly monotone map and `x < f x` at some point `x`, then the iterates `f^[n] x`\nform a strictly monotone sequence. -/\ntheorem strictMono_iterate_of_lt_map (hf : StrictMono f) (hx : x < f x) :\n    StrictMono fun n => f^[n] x :=\n  strictMono_nat_of_lt_succ fun n => by\n    rw [iterate_succ_apply]\n    exact hf.iterate n hx\n\n"}
{"name":"StrictMono.strictAnti_iterate_of_map_lt","module":"Mathlib.Order.Iterate","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nf : α → α\nx : α\nhf : StrictMono f\nhx : LT.lt (f x) x\n⊢ StrictAnti fun n => Nat.iterate f n x","decl":"/-- If `f` is a strictly antitone map and `f x < x` at some point `x`, then the iterates `f^[n] x`\nform a strictly antitone sequence. -/\ntheorem strictAnti_iterate_of_map_lt (hf : StrictMono f) (hx : f x < x) :\n    StrictAnti fun n => f^[n] x :=\n  hf.dual.strictMono_iterate_of_lt_map hx\n\n"}
