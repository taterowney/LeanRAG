{"name":"Algebra.PreSubmersivePresentation.cotangentComplexAux_apply","module":"Mathlib.RingTheory.Smooth.StandardSmoothCotangent","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.PreSubmersivePresentation R S\nx : Subtype fun x => Membership.mem P.ker x\ni : P.rels\n⊢ Eq (P.cotangentComplexAux (Algebra.Extension.Cotangent.mk x) i) ((MvPolynomial.aeval P.val) ((MvPolynomial.pderiv (P.map i)) ↑x))","decl":"lemma cotangentComplexAux_apply (P : PreSubmersivePresentation R S) (x : P.ker) (i : P.rels) :\n    P.cotangentComplexAux (Cotangent.mk x) i = (aeval P.val) (pderiv (P.map i) x.val) := by\n  dsimp only [cotangentComplexAux, LinearMap.coe_comp, LinearEquiv.coe_coe, Function.comp_apply,\n    cotangentComplex_mk]\n  simp only [Generators.toExtension_Ring, Finsupp.lcomapDomain_apply,\n    Finsupp.linearEquivFunOnFinite_apply, Finsupp.comapDomain_apply,\n    Generators.cotangentSpaceBasis_repr_tmul, one_mul]\n\n"}
{"name":"Algebra.PreSubmersivePresentation.cotangentComplexAux_zero_iff","module":"Mathlib.RingTheory.Smooth.StandardSmoothCotangent","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.PreSubmersivePresentation R S\nx : Subtype fun x => Membership.mem P.ker x\n⊢ Iff (Eq (P.cotangentComplexAux (Algebra.Extension.Cotangent.mk x)) 0) (∀ (i : P.rels), Eq ((MvPolynomial.aeval P.val) ((MvPolynomial.pderiv (P.map i)) ↑x)) 0)","decl":"lemma cotangentComplexAux_zero_iff {P : PreSubmersivePresentation R S} (x : P.ker) :\n    P.cotangentComplexAux (Cotangent.mk x) = 0 ↔\n      ∀ i : P.rels, (aeval P.val) (pderiv (P.map i) x.val) = 0 := by\n  rw [funext_iff]\n  simp_rw [cotangentComplexAux_apply, Pi.zero_apply]\n\n"}
{"name":"Algebra.SubmersivePresentation.cotangentComplexAux_injective","module":"Mathlib.RingTheory.Smooth.StandardSmoothCotangent","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.SubmersivePresentation R S\n⊢ Function.Injective ⇑P.cotangentComplexAux","decl":"lemma cotangentComplexAux_injective : Function.Injective P.cotangentComplexAux := by\n  rw [← LinearMap.ker_eq_bot, eq_bot_iff]\n  intro x hx\n  obtain ⟨(x : P.ker), rfl⟩ := Cotangent.mk_surjective x\n  rw [Submodule.mem_bot, Cotangent.mk_eq_zero_iff]\n  rw [LinearMap.mem_ker, P.cotangentComplexAux_zero_iff] at hx\n  have : x.val ∈ Ideal.span (Set.range P.relation) := by\n    rw [P.span_range_relation_eq_ker]\n    exact x.property\n  obtain ⟨c, hc⟩ := Finsupp.mem_ideal_span_range_iff_exists_finsupp.mp this\n  have heq (i : P.rels) :\n      aeval P.val (pderiv (P.map i) <| c.sum fun i a ↦ a * P.relation i) = 0 := by\n    rw [hc]\n    apply hx\n  simp only [Finsupp.sum, map_sum, Derivation.leibniz, smul_eq_mul, map_add, map_mul,\n    Presentation.aeval_val_relation, zero_mul, add_zero] at heq\n  have heq2 : ∑ i ∈ c.support,\n      aeval P.val (c i) • (fun j ↦ aeval P.val (pderiv (P.map j) (P.relation i))) = 0 := by\n    ext j\n    simp only [Finset.sum_apply, Pi.smul_apply, smul_eq_mul, Pi.zero_apply]\n    apply heq\n  have (i : P.rels) : aeval P.val (c i) = 0 := by\n    have := P.linearIndependent_aeval_val_pderiv_relation\n    rw [linearIndependent_iff''] at this\n    have := this c.support (fun i ↦ aeval P.val (c i))\n      (by intro i; simp only [Finsupp.mem_support_iff, ne_eq, not_not]; intro h; simp [h]) heq2\n    exact this i\n  show _ ∈ P.ker ^ 2\n  rw [← hc]\n  apply Ideal.sum_mem\n  intro i hi\n  rw [pow_two]\n  apply Ideal.mul_mem_mul\n  · rw [P.ker_eq_ker_aeval_val]\n    simpa using this i\n  · exact P.relation_mem_ker i\n\n"}
{"name":"Algebra.SubmersivePresentation.cotangentComplexAux_surjective","module":"Mathlib.RingTheory.Smooth.StandardSmoothCotangent","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.SubmersivePresentation R S\n⊢ Function.Surjective ⇑P.cotangentComplexAux","decl":"lemma cotangentComplexAux_surjective : Function.Surjective P.cotangentComplexAux := by\n  rw [← LinearMap.range_eq_top, _root_.eq_top_iff, ← P.basisDeriv.span_eq, Submodule.span_le]\n  rintro - ⟨i, rfl⟩\n  use Cotangent.mk ⟨P.relation i, P.relation_mem_ker i⟩\n  ext j\n  rw [P.cotangentComplexAux_apply]\n  simp\n\n"}
{"name":"Algebra.SubmersivePresentation.cotangentEquiv_apply","module":"Mathlib.RingTheory.Smooth.StandardSmoothCotangent","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.SubmersivePresentation R S\na✝¹ : P.toExtension.Cotangent\na✝ : P.rels\n⊢ Eq (P.cotangentEquiv a✝¹ a✝) (P.cotangentComplexAux a✝¹ a✝)","decl":"/-- The isomorphism of `S`-modules between `I ⧸ I ^ 2` and `P.rels → S` given\nby `P.relation i ↦ ∂ⱼ (P.relation i)`. -/\n@[simps! apply]\nnoncomputable def cotangentEquiv : P.toExtension.Cotangent ≃ₗ[S] P.rels → S :=\n  LinearEquiv.ofBijective _ ⟨P.cotangentComplexAux_injective, P.cotangentComplexAux_surjective⟩\n\n"}
{"name":"Algebra.SubmersivePresentation.cotangentComplex_injective","module":"Mathlib.RingTheory.Smooth.StandardSmoothCotangent","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.SubmersivePresentation R S\n⊢ Function.Injective ⇑P.toExtension.cotangentComplex","decl":"lemma cotangentComplex_injective : Function.Injective P.toExtension.cotangentComplex := by\n  have := P.cotangentComplexAux_injective\n  simp only [PreSubmersivePresentation.cotangentComplexAux, LinearMap.coe_comp,\n    LinearEquiv.coe_coe] at this\n  exact Function.Injective.of_comp (Function.Injective.of_comp <| Function.Injective.of_comp this)\n\n"}
{"name":"Algebra.SubmersivePresentation.subsingleton_h1Cotangent","module":"Mathlib.RingTheory.Smooth.StandardSmoothCotangent","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.SubmersivePresentation R S\n⊢ Subsingleton P.toExtension.H1Cotangent","decl":"/-- If `P` is a submersive presentation, `H¹` of the associated cotangent complex vanishes. -/\ninstance subsingleton_h1Cotangent : Subsingleton P.toExtension.H1Cotangent := by\n  rw [Algebra.Extension.subsingleton_h1Cotangent]\n  exact cotangentComplex_injective P\n\n"}
{"name":"Algebra.SubmersivePresentation.free_cotangent","module":"Mathlib.RingTheory.Smooth.StandardSmoothCotangent","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.SubmersivePresentation R S\n⊢ Module.Free S P.toExtension.Cotangent","decl":"@[stacks 00T7 \"(3)\"]\ninstance free_cotangent : Module.Free S P.toExtension.Cotangent :=\n  Module.Free.of_basis P.basisCotangent\n\n"}
{"name":"Algebra.SubmersivePresentation.sectionCotangent_eq_iff","module":"Mathlib.RingTheory.Smooth.StandardSmoothCotangent","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.SubmersivePresentation R S\nx : P.toExtension.CotangentSpace\ny : P.toExtension.Cotangent\n⊢ Iff (Eq (P.sectionCotangent x) y) (∀ (i : P.rels), Eq ((P.cotangentSpaceBasis.repr x) (P.map i)) (P.cotangentComplexAux y i))","decl":"lemma sectionCotangent_eq_iff (x : P.toExtension.CotangentSpace) (y : P.toExtension.Cotangent) :\n    sectionCotangent P x = y ↔\n      ∀ i : P.rels, P.cotangentSpaceBasis.repr x (P.map i) = (P.cotangentComplexAux y) i := by\n  simp only [sectionCotangent, LinearMap.coe_comp, LinearEquiv.coe_coe, Function.comp_apply]\n  rw [← (cotangentEquiv P).injective.eq_iff, funext_iff, LinearEquiv.apply_symm_apply]\n  simp\n\n"}
{"name":"Algebra.SubmersivePresentation.sectionCotangent_comp","module":"Mathlib.RingTheory.Smooth.StandardSmoothCotangent","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.SubmersivePresentation R S\n⊢ Eq (P.sectionCotangent.comp P.toExtension.cotangentComplex) LinearMap.id","decl":"lemma sectionCotangent_comp :\n    sectionCotangent P ∘ₗ P.toExtension.cotangentComplex = LinearMap.id := by\n  ext : 1\n  simp only [LinearMap.coe_comp, Function.comp_apply, LinearMap.id_coe, id_eq]\n  rw [sectionCotangent_eq_iff]\n  intro i\n  rfl\n\n"}
{"name":"Algebra.SubmersivePresentation.sectionCotangent_zero_of_not_mem_range","module":"Mathlib.RingTheory.Smooth.StandardSmoothCotangent","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.SubmersivePresentation R S\ni : P.vars\nhi : Not (Membership.mem (Set.range P.map) i)\n⊢ Eq (P.sectionCotangent (P.cotangentSpaceBasis i)) 0","decl":"lemma sectionCotangent_zero_of_not_mem_range (i : P.vars) (hi : i ∉ Set.range P.map) :\n    (sectionCotangent P) (P.cotangentSpaceBasis i) = 0 := by\n  classical\n  contrapose hi\n  rw [sectionCotangent_eq_iff] at hi\n  simp only [Basis.repr_self, map_zero, Pi.zero_apply, not_forall,\n    Finsupp.single_apply, ite_eq_right_iff, Classical.not_imp, exists_and_right] at hi\n  obtain ⟨j, hij, _⟩ := hi\n  simp only [Set.mem_range, not_exists, not_forall, not_not]\n  use j\n  exact hij.symm\n\n"}
{"name":"Algebra.SubmersivePresentation.free_kaehlerDifferential","module":"Mathlib.RingTheory.Smooth.StandardSmoothCotangent","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.SubmersivePresentation R S\n⊢ Module.Free S (KaehlerDifferential R S)","decl":"/-- If `P` is a submersive presentation of `S` as an `R`-algebra, `Ω[S⁄R]` is free. -/\n@[stacks 00T7 \"(2)\"]\ntheorem free_kaehlerDifferential (P : SubmersivePresentation R S) :\n    Module.Free S (Ω[S⁄R]) :=\n  Module.Free.of_basis P.basisKaehler\n\n"}
{"name":"Algebra.SubmersivePresentation.rank_kaehlerDifferential","module":"Mathlib.RingTheory.Smooth.StandardSmoothCotangent","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\ninst✝ : Nontrivial S\nP : Algebra.SubmersivePresentation R S\n⊢ Eq (Module.rank S (KaehlerDifferential R S)) ↑P.dimension","decl":"attribute [local instance] Fintype.ofFinite in\n/-- If `P` is a submersive presentation of `S` as an `R`-algebra and `S` is nontrivial,\n`Ω[S⁄R]` is free of rank the dimension of `P`, i.e. the number of generators minus the number\nof relations. -/\ntheorem rank_kaehlerDifferential [Nontrivial S]\n    (P : SubmersivePresentation R S) : Module.rank S (Ω[S⁄R]) = P.dimension := by\n  simp only [rank_eq_card_basis P.basisKaehler, Nat.cast_inj, Fintype.card_compl_set,\n    Presentation.dimension, Nat.card_eq_fintype_card, Set.card_range_of_injective P.map_inj]\n\n"}
{"name":"Algebra.IsStandardSmooth.free_kaehlerDifferential","module":"Mathlib.RingTheory.Smooth.StandardSmoothCotangent","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\ninst✝ : Algebra.IsStandardSmooth R S\n⊢ Module.Free S (KaehlerDifferential R S)","decl":"/-- If `S` is `R`-standard smooth, `Ω[S⁄R]` is a free `S`-module. -/\ninstance IsStandardSmooth.free_kaehlerDifferential [IsStandardSmooth R S] :\n    Module.Free S (Ω[S⁄R]) := by\n  obtain ⟨⟨P⟩⟩ := ‹IsStandardSmooth R S›\n  exact P.free_kaehlerDifferential\n\n"}
{"name":"Algebra.IsStandardSmooth.subsingleton_h1Cotangent","module":"Mathlib.RingTheory.Smooth.StandardSmoothCotangent","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\ninst✝ : Algebra.IsStandardSmooth R S\n⊢ Subsingleton (Algebra.H1Cotangent R S)","decl":"instance IsStandardSmooth.subsingleton_h1Cotangent [IsStandardSmooth R S] :\n    Subsingleton (H1Cotangent R S) := by\n  obtain ⟨⟨P⟩⟩ := ‹IsStandardSmooth R S›\n  exact P.equivH1Cotangent.symm.toEquiv.subsingleton\n\n"}
{"name":"Algebra.IsStandardSmoothOfRelativeDimension.rank_kaehlerDifferential","module":"Mathlib.RingTheory.Smooth.StandardSmoothCotangent","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : Algebra R S\ninst✝¹ : Nontrivial S\nn : Nat\ninst✝ : Algebra.IsStandardSmoothOfRelativeDimension n R S\n⊢ Eq (Module.rank S (KaehlerDifferential R S)) ↑n","decl":"/-- If `S` is non-trivial and `R`-standard smooth of relative dimension, `Ω[S⁄R]` is a free\n`S`-module of rank `n`. -/\ntheorem IsStandardSmoothOfRelativeDimension.rank_kaehlerDifferential [Nontrivial S] (n : ℕ)\n    [IsStandardSmoothOfRelativeDimension n R S] :\n    Module.rank S (Ω[S⁄R]) = n := by\n  obtain ⟨⟨P, hP⟩⟩ := ‹IsStandardSmoothOfRelativeDimension n R S›\n  rw [P.rank_kaehlerDifferential, hP]\n\n"}
{"name":"Algebra.IsStandardSmoothOfRelationDimension.subsingleton_kaehlerDifferential","module":"Mathlib.RingTheory.Smooth.StandardSmoothCotangent","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\ninst✝ : Algebra.IsStandardSmoothOfRelativeDimension 0 R S\n⊢ Subsingleton (KaehlerDifferential R S)","decl":"instance IsStandardSmoothOfRelationDimension.subsingleton_kaehlerDifferential\n    [IsStandardSmoothOfRelativeDimension 0 R S] : Subsingleton (Ω[S⁄R]) := by\n  cases subsingleton_or_nontrivial S\n  · exact Module.subsingleton S _\n  haveI : IsStandardSmooth R S := IsStandardSmoothOfRelativeDimension.isStandardSmooth 0\n  exact Module.subsingleton_of_rank_zero\n    (IsStandardSmoothOfRelativeDimension.rank_kaehlerDifferential 0)\n\n"}
{"name":"Algebra.instSmoothOfIsStandardSmooth","module":"Mathlib.RingTheory.Smooth.StandardSmoothCotangent","initialProofState":"R S : Type u\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\ninst✝ : Algebra.IsStandardSmooth R S\n⊢ Algebra.Smooth R S","decl":"instance (priority := 900) [IsStandardSmooth R S] : Smooth R S where\n  formallySmooth := by\n    rw [Algebra.FormallySmooth.iff_subsingleton_and_projective]\n    exact ⟨inferInstance, inferInstance⟩\n\n"}
{"name":"Algebra.instEtaleOfIsStandardSmoothOfRelativeDimensionOfNatNat","module":"Mathlib.RingTheory.Smooth.StandardSmoothCotangent","initialProofState":"R S : Type u\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\ninst✝ : Algebra.IsStandardSmoothOfRelativeDimension 0 R S\n⊢ Algebra.Etale R S","decl":"/-- If `S` is `R`-standard smooth of relative dimension zero, it is étale. -/\ninstance (priority := 900) [IsStandardSmoothOfRelativeDimension 0 R S] : Etale R S where\n  finitePresentation := (IsStandardSmoothOfRelativeDimension.isStandardSmooth 0).finitePresentation\n  formallyEtale :=\n    have : IsStandardSmooth R S := IsStandardSmoothOfRelativeDimension.isStandardSmooth 0\n    have : FormallyUnramified R S := ⟨inferInstance⟩\n    Algebra.FormallyEtale.of_unramified_and_smooth\n\n"}
