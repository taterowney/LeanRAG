{"name":"AddSubmonoid.coe_sInf","module":"Mathlib.Algebra.Group.Submonoid.Basic","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\nS : Set (AddSubmonoid M)\n⊢ Eq (↑(InfSet.sInf S)) (Set.iInter fun s => Set.iInter fun h => ↑s)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_sInf (S : Set (Submonoid M)) : ((sInf S : Submonoid M) : Set M) = ⋂ s ∈ S, ↑s :=\n  rfl\n\n"}
{"name":"Submonoid.coe_sInf","module":"Mathlib.Algebra.Group.Submonoid.Basic","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\nS : Set (Submonoid M)\n⊢ Eq (↑(InfSet.sInf S)) (Set.iInter fun s => Set.iInter fun h => ↑s)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_sInf (S : Set (Submonoid M)) : ((sInf S : Submonoid M) : Set M) = ⋂ s ∈ S, ↑s :=\n  rfl\n\n"}
{"name":"AddSubmonoid.mem_sInf","module":"Mathlib.Algebra.Group.Submonoid.Basic","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\nS : Set (AddSubmonoid M)\nx : M\n⊢ Iff (Membership.mem (InfSet.sInf S) x) (∀ (p : AddSubmonoid M), Membership.mem S p → Membership.mem p x)","decl":"@[to_additive]\ntheorem mem_sInf {S : Set (Submonoid M)} {x : M} : x ∈ sInf S ↔ ∀ p ∈ S, x ∈ p :=\n  Set.mem_iInter₂\n\n"}
{"name":"Submonoid.mem_sInf","module":"Mathlib.Algebra.Group.Submonoid.Basic","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\nS : Set (Submonoid M)\nx : M\n⊢ Iff (Membership.mem (InfSet.sInf S) x) (∀ (p : Submonoid M), Membership.mem S p → Membership.mem p x)","decl":"@[to_additive]\ntheorem mem_sInf {S : Set (Submonoid M)} {x : M} : x ∈ sInf S ↔ ∀ p ∈ S, x ∈ p :=\n  Set.mem_iInter₂\n\n"}
{"name":"AddSubmonoid.mem_iInf","module":"Mathlib.Algebra.Group.Submonoid.Basic","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\nι : Sort u_4\nS : ι → AddSubmonoid M\nx : M\n⊢ Iff (Membership.mem (iInf fun i => S i) x) (∀ (i : ι), Membership.mem (S i) x)","decl":"@[to_additive]\ntheorem mem_iInf {ι : Sort*} {S : ι → Submonoid M} {x : M} : (x ∈ ⨅ i, S i) ↔ ∀ i, x ∈ S i := by\n  simp only [iInf, mem_sInf, Set.forall_mem_range]\n\n"}
{"name":"Submonoid.mem_iInf","module":"Mathlib.Algebra.Group.Submonoid.Basic","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\nι : Sort u_4\nS : ι → Submonoid M\nx : M\n⊢ Iff (Membership.mem (iInf fun i => S i) x) (∀ (i : ι), Membership.mem (S i) x)","decl":"@[to_additive]\ntheorem mem_iInf {ι : Sort*} {S : ι → Submonoid M} {x : M} : (x ∈ ⨅ i, S i) ↔ ∀ i, x ∈ S i := by\n  simp only [iInf, mem_sInf, Set.forall_mem_range]\n\n"}
{"name":"Submonoid.coe_iInf","module":"Mathlib.Algebra.Group.Submonoid.Basic","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\nι : Sort u_4\nS : ι → Submonoid M\n⊢ Eq (↑(iInf fun i => S i)) (Set.iInter fun i => ↑(S i))","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_iInf {ι : Sort*} {S : ι → Submonoid M} : (↑(⨅ i, S i) : Set M) = ⋂ i, S i := by\n  simp only [iInf, coe_sInf, Set.biInter_range]\n\n"}
{"name":"AddSubmonoid.coe_iInf","module":"Mathlib.Algebra.Group.Submonoid.Basic","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\nι : Sort u_4\nS : ι → AddSubmonoid M\n⊢ Eq (↑(iInf fun i => S i)) (Set.iInter fun i => ↑(S i))","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_iInf {ι : Sort*} {S : ι → Submonoid M} : (↑(⨅ i, S i) : Set M) = ⋂ i, S i := by\n  simp only [iInf, coe_sInf, Set.biInter_range]\n\n"}
{"name":"AddSubmonoid.mem_closure","module":"Mathlib.Algebra.Group.Submonoid.Basic","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\ns : Set M\nx : M\n⊢ Iff (Membership.mem (AddSubmonoid.closure s) x) (∀ (S : AddSubmonoid M), HasSubset.Subset s ↑S → Membership.mem S x)","decl":"@[to_additive]\ntheorem mem_closure {x : M} : x ∈ closure s ↔ ∀ S : Submonoid M, s ⊆ S → x ∈ S :=\n  mem_sInf\n\n"}
{"name":"Submonoid.mem_closure","module":"Mathlib.Algebra.Group.Submonoid.Basic","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\ns : Set M\nx : M\n⊢ Iff (Membership.mem (Submonoid.closure s) x) (∀ (S : Submonoid M), HasSubset.Subset s ↑S → Membership.mem S x)","decl":"@[to_additive]\ntheorem mem_closure {x : M} : x ∈ closure s ↔ ∀ S : Submonoid M, s ⊆ S → x ∈ S :=\n  mem_sInf\n\n"}
{"name":"AddSubmonoid.subset_closure","module":"Mathlib.Algebra.Group.Submonoid.Basic","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\ns : Set M\n⊢ HasSubset.Subset s ↑(AddSubmonoid.closure s)","decl":"/-- The submonoid generated by a set includes the set. -/\n@[to_additive (attr := simp, aesop safe 20 apply (rule_sets := [SetLike]))\n  \"The `AddSubmonoid` generated by a set includes the set.\"]\ntheorem subset_closure : s ⊆ closure s := fun _ hx => mem_closure.2 fun _ hS => hS hx\n\n"}
{"name":"Submonoid.subset_closure","module":"Mathlib.Algebra.Group.Submonoid.Basic","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\ns : Set M\n⊢ HasSubset.Subset s ↑(Submonoid.closure s)","decl":"/-- The submonoid generated by a set includes the set. -/\n@[to_additive (attr := simp, aesop safe 20 apply (rule_sets := [SetLike]))\n  \"The `AddSubmonoid` generated by a set includes the set.\"]\ntheorem subset_closure : s ⊆ closure s := fun _ hx => mem_closure.2 fun _ hS => hS hx\n\n"}
{"name":"Submonoid.not_mem_of_not_mem_closure","module":"Mathlib.Algebra.Group.Submonoid.Basic","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\ns : Set M\nP : M\nhP : Not (Membership.mem (Submonoid.closure s) P)\n⊢ Not (Membership.mem s P)","decl":"@[to_additive]\ntheorem not_mem_of_not_mem_closure {P : M} (hP : P ∉ closure s) : P ∉ s := fun h =>\n  hP (subset_closure h)\n\n"}
{"name":"AddSubmonoid.not_mem_of_not_mem_closure","module":"Mathlib.Algebra.Group.Submonoid.Basic","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\ns : Set M\nP : M\nhP : Not (Membership.mem (AddSubmonoid.closure s) P)\n⊢ Not (Membership.mem s P)","decl":"@[to_additive]\ntheorem not_mem_of_not_mem_closure {P : M} (hP : P ∉ closure s) : P ∉ s := fun h =>\n  hP (subset_closure h)\n\n"}
{"name":"AddSubmonoid.closure_le","module":"Mathlib.Algebra.Group.Submonoid.Basic","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\ns : Set M\nS : AddSubmonoid M\n⊢ Iff (LE.le (AddSubmonoid.closure s) S) (HasSubset.Subset s ↑S)","decl":"/-- A submonoid `S` includes `closure s` if and only if it includes `s`. -/\n@[to_additive (attr := simp)\n\"An additive submonoid `S` includes `closure s` if and only if it includes `s`\"]\ntheorem closure_le : closure s ≤ S ↔ s ⊆ S :=\n  ⟨Subset.trans subset_closure, fun h => sInf_le h⟩\n\n"}
{"name":"Submonoid.closure_le","module":"Mathlib.Algebra.Group.Submonoid.Basic","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\ns : Set M\nS : Submonoid M\n⊢ Iff (LE.le (Submonoid.closure s) S) (HasSubset.Subset s ↑S)","decl":"/-- A submonoid `S` includes `closure s` if and only if it includes `s`. -/\n@[to_additive (attr := simp)\n\"An additive submonoid `S` includes `closure s` if and only if it includes `s`\"]\ntheorem closure_le : closure s ≤ S ↔ s ⊆ S :=\n  ⟨Subset.trans subset_closure, fun h => sInf_le h⟩\n\n"}
{"name":"AddSubmonoid.closure_mono","module":"Mathlib.Algebra.Group.Submonoid.Basic","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\ns t : Set M\nh : HasSubset.Subset s t\n⊢ LE.le (AddSubmonoid.closure s) (AddSubmonoid.closure t)","decl":"/-- Submonoid closure of a set is monotone in its argument: if `s ⊆ t`,\nthen `closure s ≤ closure t`. -/\n@[to_additive (attr := gcongr)\n      \"Additive submonoid closure of a set is monotone in its argument: if `s ⊆ t`,\n      then `closure s ≤ closure t`\"]\ntheorem closure_mono ⦃s t : Set M⦄ (h : s ⊆ t) : closure s ≤ closure t :=\n  closure_le.2 <| Subset.trans h subset_closure\n\n"}
{"name":"Submonoid.closure_mono","module":"Mathlib.Algebra.Group.Submonoid.Basic","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\ns t : Set M\nh : HasSubset.Subset s t\n⊢ LE.le (Submonoid.closure s) (Submonoid.closure t)","decl":"/-- Submonoid closure of a set is monotone in its argument: if `s ⊆ t`,\nthen `closure s ≤ closure t`. -/\n@[to_additive (attr := gcongr)\n      \"Additive submonoid closure of a set is monotone in its argument: if `s ⊆ t`,\n      then `closure s ≤ closure t`\"]\ntheorem closure_mono ⦃s t : Set M⦄ (h : s ⊆ t) : closure s ≤ closure t :=\n  closure_le.2 <| Subset.trans h subset_closure\n\n"}
{"name":"AddSubmonoid.closure_eq_of_le","module":"Mathlib.Algebra.Group.Submonoid.Basic","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\ns : Set M\nS : AddSubmonoid M\nh₁ : HasSubset.Subset s ↑S\nh₂ : LE.le S (AddSubmonoid.closure s)\n⊢ Eq (AddSubmonoid.closure s) S","decl":"@[to_additive]\ntheorem closure_eq_of_le (h₁ : s ⊆ S) (h₂ : S ≤ closure s) : closure s = S :=\n  le_antisymm (closure_le.2 h₁) h₂\n\n"}
{"name":"Submonoid.closure_eq_of_le","module":"Mathlib.Algebra.Group.Submonoid.Basic","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\ns : Set M\nS : Submonoid M\nh₁ : HasSubset.Subset s ↑S\nh₂ : LE.le S (Submonoid.closure s)\n⊢ Eq (Submonoid.closure s) S","decl":"@[to_additive]\ntheorem closure_eq_of_le (h₁ : s ⊆ S) (h₂ : S ≤ closure s) : closure s = S :=\n  le_antisymm (closure_le.2 h₁) h₂\n\n"}
{"name":"AddSubmonoid.closure_induction","module":"Mathlib.Algebra.Group.Submonoid.Basic","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\ns : Set M\np : (x : M) → Membership.mem (AddSubmonoid.closure s) x → Prop\nmem : ∀ (x : M) (h : Membership.mem s x), p x ⋯\none : p 0 ⋯\nmul : ∀ (x y : M) (hx : Membership.mem (AddSubmonoid.closure s) x) (hy : Membership.mem (AddSubmonoid.closure s) y), p x hx → p y hy → p (HAdd.hAdd x y) ⋯\nx : M\nhx : Membership.mem (AddSubmonoid.closure s) x\n⊢ p x hx","decl":"/-- An induction principle for closure membership. If `p` holds for `1` and all elements of `s`, and\nis preserved under multiplication, then `p` holds for all elements of the closure of `s`. -/\n@[to_additive (attr := elab_as_elim)\n      \"An induction principle for additive closure membership. If `p` holds for `0` and all\n      elements of `s`, and is preserved under addition, then `p` holds for all elements of the\n      additive closure of `s`.\"]\ntheorem closure_induction {s : Set M} {p : (x : M) → x ∈ closure s → Prop}\n    (mem : ∀ (x) (h : x ∈ s), p x (subset_closure h)) (one : p 1 (one_mem _))\n    (mul : ∀ x y hx hy, p x hx → p y hy → p (x * y) (mul_mem hx hy)) {x} (hx : x ∈ closure s) :\n    p x hx :=\n  let S : Submonoid M :=\n    { carrier := { x | ∃ hx, p x hx }\n      one_mem' := ⟨_, one⟩\n      mul_mem' := fun ⟨_, hpx⟩ ⟨_, hpy⟩ ↦ ⟨_, mul _ _ _ _ hpx hpy⟩ }\n  closure_le (S := S) |>.mpr (fun y hy ↦ ⟨subset_closure hy, mem y hy⟩) hx |>.elim fun _ ↦ id\n\n"}
{"name":"Submonoid.closure_induction","module":"Mathlib.Algebra.Group.Submonoid.Basic","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\ns : Set M\np : (x : M) → Membership.mem (Submonoid.closure s) x → Prop\nmem : ∀ (x : M) (h : Membership.mem s x), p x ⋯\none : p 1 ⋯\nmul : ∀ (x y : M) (hx : Membership.mem (Submonoid.closure s) x) (hy : Membership.mem (Submonoid.closure s) y), p x hx → p y hy → p (HMul.hMul x y) ⋯\nx : M\nhx : Membership.mem (Submonoid.closure s) x\n⊢ p x hx","decl":"/-- An induction principle for closure membership. If `p` holds for `1` and all elements of `s`, and\nis preserved under multiplication, then `p` holds for all elements of the closure of `s`. -/\n@[to_additive (attr := elab_as_elim)\n      \"An induction principle for additive closure membership. If `p` holds for `0` and all\n      elements of `s`, and is preserved under addition, then `p` holds for all elements of the\n      additive closure of `s`.\"]\ntheorem closure_induction {s : Set M} {p : (x : M) → x ∈ closure s → Prop}\n    (mem : ∀ (x) (h : x ∈ s), p x (subset_closure h)) (one : p 1 (one_mem _))\n    (mul : ∀ x y hx hy, p x hx → p y hy → p (x * y) (mul_mem hx hy)) {x} (hx : x ∈ closure s) :\n    p x hx :=\n  let S : Submonoid M :=\n    { carrier := { x | ∃ hx, p x hx }\n      one_mem' := ⟨_, one⟩\n      mul_mem' := fun ⟨_, hpx⟩ ⟨_, hpy⟩ ↦ ⟨_, mul _ _ _ _ hpx hpy⟩ }\n  closure_le (S := S) |>.mpr (fun y hy ↦ ⟨subset_closure hy, mem y hy⟩) hx |>.elim fun _ ↦ id\n\n"}
{"name":"Submonoid.closure_induction'","module":"Mathlib.Algebra.Group.Submonoid.Basic","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\ns : Set M\np : (x : M) → Membership.mem (Submonoid.closure s) x → Prop\nmem : ∀ (x : M) (h : Membership.mem s x), p x ⋯\none : p 1 ⋯\nmul : ∀ (x y : M) (hx : Membership.mem (Submonoid.closure s) x) (hy : Membership.mem (Submonoid.closure s) y), p x hx → p y hy → p (HMul.hMul x y) ⋯\nx : M\nhx : Membership.mem (Submonoid.closure s) x\n⊢ p x hx","decl":"@[deprecated closure_induction (since := \"2024-10-10\")]\nalias closure_induction' := closure_induction\n\n"}
{"name":"Submonoid.closure_induction₂","module":"Mathlib.Algebra.Group.Submonoid.Basic","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\ns : Set M\np : (x y : M) → Membership.mem (Submonoid.closure s) x → Membership.mem (Submonoid.closure s) y → Prop\nmem : ∀ (x y : M) (hx : Membership.mem s x) (hy : Membership.mem s y), p x y ⋯ ⋯\none_left : ∀ (x : M) (hx : Membership.mem (Submonoid.closure s) x), p 1 x ⋯ hx\none_right : ∀ (x : M) (hx : Membership.mem (Submonoid.closure s) x), p x 1 hx ⋯\nmul_left : ∀ (x y z : M) (hx : Membership.mem (Submonoid.closure s) x) (hy : Membership.mem (Submonoid.closure s) y) (hz : Membership.mem (Submonoid.closure s) z), p x z hx hz → p y z hy hz → p (HMul.hMul x y) z ⋯ hz\nmul_right : ∀ (x y z : M) (hx : Membership.mem (Submonoid.closure s) x) (hy : Membership.mem (Submonoid.closure s) y) (hz : Membership.mem (Submonoid.closure s) z), p z x hz hx → p z y hz hy → p z (HMul.hMul x y) hz ⋯\nx y : M\nhx : Membership.mem (Submonoid.closure s) x\nhy : Membership.mem (Submonoid.closure s) y\n⊢ p x y hx hy","decl":"/-- An induction principle for closure membership for predicates with two arguments. -/\n@[to_additive (attr := elab_as_elim)\n      \"An induction principle for additive closure membership for predicates with two arguments.\"]\ntheorem closure_induction₂ {p : (x y : M) → x ∈ closure s → y ∈ closure s → Prop}\n    (mem : ∀ (x) (y) (hx : x ∈ s) (hy : y ∈ s), p x y (subset_closure hx) (subset_closure hy))\n    (one_left : ∀ x hx, p 1 x (one_mem _) hx) (one_right : ∀ x hx, p x 1 hx (one_mem _))\n    (mul_left : ∀ x y z hx hy hz, p x z hx hz → p y z hy hz → p (x * y) z (mul_mem hx hy) hz)\n    (mul_right : ∀ x y z hx hy hz, p z x hz hx → p z y hz hy → p z (x * y) hz (mul_mem hx hy))\n    {x y : M} (hx : x ∈ closure s) (hy : y ∈ closure s) : p x y hx hy := by\n  induction hy using closure_induction with\n  | mem z hz => induction hx using closure_induction with\n    | mem _ h => exact mem _ _ h hz\n    | one => exact one_left _ (subset_closure hz)\n    | mul _ _ _ _ h₁ h₂ => exact mul_left _ _ _ _ _ _ h₁ h₂\n  | one => exact one_right x hx\n  | mul _ _ _ _ h₁ h₂ => exact mul_right _ _ _ _ _ hx h₁ h₂\n\n"}
{"name":"AddSubmonoid.closure_induction₂","module":"Mathlib.Algebra.Group.Submonoid.Basic","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\ns : Set M\np : (x y : M) → Membership.mem (AddSubmonoid.closure s) x → Membership.mem (AddSubmonoid.closure s) y → Prop\nmem : ∀ (x y : M) (hx : Membership.mem s x) (hy : Membership.mem s y), p x y ⋯ ⋯\none_left : ∀ (x : M) (hx : Membership.mem (AddSubmonoid.closure s) x), p 0 x ⋯ hx\none_right : ∀ (x : M) (hx : Membership.mem (AddSubmonoid.closure s) x), p x 0 hx ⋯\nmul_left : ∀ (x y z : M) (hx : Membership.mem (AddSubmonoid.closure s) x) (hy : Membership.mem (AddSubmonoid.closure s) y) (hz : Membership.mem (AddSubmonoid.closure s) z), p x z hx hz → p y z hy hz → p (HAdd.hAdd x y) z ⋯ hz\nmul_right : ∀ (x y z : M) (hx : Membership.mem (AddSubmonoid.closure s) x) (hy : Membership.mem (AddSubmonoid.closure s) y) (hz : Membership.mem (AddSubmonoid.closure s) z), p z x hz hx → p z y hz hy → p z (HAdd.hAdd x y) hz ⋯\nx y : M\nhx : Membership.mem (AddSubmonoid.closure s) x\nhy : Membership.mem (AddSubmonoid.closure s) y\n⊢ p x y hx hy","decl":"/-- An induction principle for closure membership for predicates with two arguments. -/\n@[to_additive (attr := elab_as_elim)\n      \"An induction principle for additive closure membership for predicates with two arguments.\"]\ntheorem closure_induction₂ {p : (x y : M) → x ∈ closure s → y ∈ closure s → Prop}\n    (mem : ∀ (x) (y) (hx : x ∈ s) (hy : y ∈ s), p x y (subset_closure hx) (subset_closure hy))\n    (one_left : ∀ x hx, p 1 x (one_mem _) hx) (one_right : ∀ x hx, p x 1 hx (one_mem _))\n    (mul_left : ∀ x y z hx hy hz, p x z hx hz → p y z hy hz → p (x * y) z (mul_mem hx hy) hz)\n    (mul_right : ∀ x y z hx hy hz, p z x hz hx → p z y hz hy → p z (x * y) hz (mul_mem hx hy))\n    {x y : M} (hx : x ∈ closure s) (hy : y ∈ closure s) : p x y hx hy := by\n  induction hy using closure_induction with\n  | mem z hz => induction hx using closure_induction with\n    | mem _ h => exact mem _ _ h hz\n    | one => exact one_left _ (subset_closure hz)\n    | mul _ _ _ _ h₁ h₂ => exact mul_left _ _ _ _ _ _ h₁ h₂\n  | one => exact one_right x hx\n  | mul _ _ _ _ h₁ h₂ => exact mul_right _ _ _ _ _ hx h₁ h₂\n\n"}
{"name":"AddSubmonoid.dense_induction","module":"Mathlib.Algebra.Group.Submonoid.Basic","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\np : M → Prop\ns : Set M\nclosure : Eq (AddSubmonoid.closure s) Top.top\nmem : ∀ (x : M), Membership.mem s x → p x\none : p 0\nmul : ∀ (x y : M), p x → p y → p (HAdd.hAdd x y)\nx : M\n⊢ p x","decl":"/-- If `s` is a dense set in a monoid `M`, `Submonoid.closure s = ⊤`, then in order to prove that\nsome predicate `p` holds for all `x : M` it suffices to verify `p x` for `x ∈ s`, verify `p 1`,\nand verify that `p x` and `p y` imply `p (x * y)`. -/\n@[to_additive (attr := elab_as_elim)\n      \"If `s` is a dense set in an additive monoid `M`, `AddSubmonoid.closure s = ⊤`, then in\n      order to prove that some predicate `p` holds for all `x : M` it suffices to verify `p x` for\n      `x ∈ s`, verify `p 0`, and verify that `p x` and `p y` imply `p (x + y)`.\"]\ntheorem dense_induction {p : M → Prop} (s : Set M) (closure : closure s = ⊤) (mem : ∀ x ∈ s, p x)\n    (one : p 1) (mul : ∀ x y, p x → p y → p (x * y)) (x : M) : p x := by\n  induction closure.symm ▸ mem_top x using closure_induction with\n  | mem _ h => exact mem _ h\n  | one => exact one\n  | mul _ _ _ _ h₁ h₂ => exact mul _ _ h₁ h₂\n\n/- The argument `s : Set M` is explicit in `Submonoid.dense_induction` because the type of the\ninduction variable, namely `x : M`, does not reference `x`. Making `s` explicit allows the user\nto apply the induction principle while deferring the proof of `closure s = ⊤` without creating\nmetavariables, as in the following example. -/\n"}
{"name":"Submonoid.dense_induction","module":"Mathlib.Algebra.Group.Submonoid.Basic","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\np : M → Prop\ns : Set M\nclosure : Eq (Submonoid.closure s) Top.top\nmem : ∀ (x : M), Membership.mem s x → p x\none : p 1\nmul : ∀ (x y : M), p x → p y → p (HMul.hMul x y)\nx : M\n⊢ p x","decl":"/-- If `s` is a dense set in a monoid `M`, `Submonoid.closure s = ⊤`, then in order to prove that\nsome predicate `p` holds for all `x : M` it suffices to verify `p x` for `x ∈ s`, verify `p 1`,\nand verify that `p x` and `p y` imply `p (x * y)`. -/\n@[to_additive (attr := elab_as_elim)\n      \"If `s` is a dense set in an additive monoid `M`, `AddSubmonoid.closure s = ⊤`, then in\n      order to prove that some predicate `p` holds for all `x : M` it suffices to verify `p x` for\n      `x ∈ s`, verify `p 0`, and verify that `p x` and `p y` imply `p (x + y)`.\"]\ntheorem dense_induction {p : M → Prop} (s : Set M) (closure : closure s = ⊤) (mem : ∀ x ∈ s, p x)\n    (one : p 1) (mul : ∀ x y, p x → p y → p (x * y)) (x : M) : p x := by\n  induction closure.symm ▸ mem_top x using closure_induction with\n  | mem _ h => exact mem _ h\n  | one => exact one\n  | mul _ _ _ _ h₁ h₂ => exact mul _ _ h₁ h₂\n\n/- The argument `s : Set M` is explicit in `Submonoid.dense_induction` because the type of the\ninduction variable, namely `x : M`, does not reference `x`. Making `s` explicit allows the user\nto apply the induction principle while deferring the proof of `closure s = ⊤` without creating\nmetavariables, as in the following example. -/\n"}
{"name":"Submonoid.closure_eq_one_union","module":"Mathlib.Algebra.Group.Submonoid.Basic","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\ns : Set M\n⊢ Eq (↑(Submonoid.closure s)) (Union.union (Singleton.singleton 1) ↑(Subsemigroup.closure s))","decl":"/-- The `Submonoid.closure` of a set is the union of `{1}` and its `Subsemigroup.closure`. -/\nlemma closure_eq_one_union (s : Set M) :\n    closure s = {(1 : M)} ∪ (Subsemigroup.closure s : Set M) := by\n  apply le_antisymm\n  · intro x hx\n    induction hx using closure_induction with\n    | mem x hx => exact Or.inr <| Subsemigroup.subset_closure hx\n    | one => exact Or.inl <| by simp\n    | mul x hx y hy hx hy =>\n      simp only [singleton_union, mem_insert_iff, SetLike.mem_coe] at hx hy\n      obtain ⟨(rfl | hx), (rfl | hy)⟩ := And.intro hx hy\n      all_goals simp_all\n      exact Or.inr <| mul_mem hx hy\n  · rintro x (hx | hx)\n    · exact (show x = 1 by simpa using hx) ▸ one_mem (closure s)\n    · exact Subsemigroup.closure_le.mpr subset_closure hx\n\n"}
{"name":"AddSubmonoid.closure_eq","module":"Mathlib.Algebra.Group.Submonoid.Basic","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\nS : AddSubmonoid M\n⊢ Eq (AddSubmonoid.closure ↑S) S","decl":"/-- Closure of a submonoid `S` equals `S`. -/\n@[to_additive (attr := simp) \"Additive closure of an additive submonoid `S` equals `S`\"]\ntheorem closure_eq : closure (S : Set M) = S :=\n  (Submonoid.gi M).l_u_eq S\n\n"}
{"name":"Submonoid.closure_eq","module":"Mathlib.Algebra.Group.Submonoid.Basic","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\nS : Submonoid M\n⊢ Eq (Submonoid.closure ↑S) S","decl":"/-- Closure of a submonoid `S` equals `S`. -/\n@[to_additive (attr := simp) \"Additive closure of an additive submonoid `S` equals `S`\"]\ntheorem closure_eq : closure (S : Set M) = S :=\n  (Submonoid.gi M).l_u_eq S\n\n"}
{"name":"AddSubmonoid.closure_empty","module":"Mathlib.Algebra.Group.Submonoid.Basic","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\n⊢ Eq (AddSubmonoid.closure EmptyCollection.emptyCollection) Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem closure_empty : closure (∅ : Set M) = ⊥ :=\n  (Submonoid.gi M).gc.l_bot\n\n"}
{"name":"Submonoid.closure_empty","module":"Mathlib.Algebra.Group.Submonoid.Basic","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\n⊢ Eq (Submonoid.closure EmptyCollection.emptyCollection) Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem closure_empty : closure (∅ : Set M) = ⊥ :=\n  (Submonoid.gi M).gc.l_bot\n\n"}
{"name":"AddSubmonoid.closure_univ","module":"Mathlib.Algebra.Group.Submonoid.Basic","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\n⊢ Eq (AddSubmonoid.closure Set.univ) Top.top","decl":"@[to_additive (attr := simp)]\ntheorem closure_univ : closure (univ : Set M) = ⊤ :=\n  @coe_top M _ ▸ closure_eq ⊤\n\n"}
{"name":"Submonoid.closure_univ","module":"Mathlib.Algebra.Group.Submonoid.Basic","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\n⊢ Eq (Submonoid.closure Set.univ) Top.top","decl":"@[to_additive (attr := simp)]\ntheorem closure_univ : closure (univ : Set M) = ⊤ :=\n  @coe_top M _ ▸ closure_eq ⊤\n\n"}
{"name":"Submonoid.closure_union","module":"Mathlib.Algebra.Group.Submonoid.Basic","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\ns t : Set M\n⊢ Eq (Submonoid.closure (Union.union s t)) (Max.max (Submonoid.closure s) (Submonoid.closure t))","decl":"@[to_additive]\ntheorem closure_union (s t : Set M) : closure (s ∪ t) = closure s ⊔ closure t :=\n  (Submonoid.gi M).gc.l_sup\n\n"}
{"name":"AddSubmonoid.closure_union","module":"Mathlib.Algebra.Group.Submonoid.Basic","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\ns t : Set M\n⊢ Eq (AddSubmonoid.closure (Union.union s t)) (Max.max (AddSubmonoid.closure s) (AddSubmonoid.closure t))","decl":"@[to_additive]\ntheorem closure_union (s t : Set M) : closure (s ∪ t) = closure s ⊔ closure t :=\n  (Submonoid.gi M).gc.l_sup\n\n"}
{"name":"Submonoid.sup_eq_closure","module":"Mathlib.Algebra.Group.Submonoid.Basic","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\nN N' : Submonoid M\n⊢ Eq (Max.max N N') (Submonoid.closure (Union.union ↑N ↑N'))","decl":"@[to_additive]\ntheorem sup_eq_closure (N N' : Submonoid M) : N ⊔ N' = closure ((N : Set M) ∪ (N' : Set M)) := by\n  simp_rw [closure_union, closure_eq]\n\n"}
{"name":"AddSubmonoid.sup_eq_closure","module":"Mathlib.Algebra.Group.Submonoid.Basic","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\nN N' : AddSubmonoid M\n⊢ Eq (Max.max N N') (AddSubmonoid.closure (Union.union ↑N ↑N'))","decl":"@[to_additive]\ntheorem sup_eq_closure (N N' : Submonoid M) : N ⊔ N' = closure ((N : Set M) ∪ (N' : Set M)) := by\n  simp_rw [closure_union, closure_eq]\n\n"}
{"name":"AddSubmonoid.closure_iUnion","module":"Mathlib.Algebra.Group.Submonoid.Basic","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\nι : Sort u_4\ns : ι → Set M\n⊢ Eq (AddSubmonoid.closure (Set.iUnion fun i => s i)) (iSup fun i => AddSubmonoid.closure (s i))","decl":"@[to_additive]\ntheorem closure_iUnion {ι} (s : ι → Set M) : closure (⋃ i, s i) = ⨆ i, closure (s i) :=\n  (Submonoid.gi M).gc.l_iSup\n\n"}
{"name":"Submonoid.closure_iUnion","module":"Mathlib.Algebra.Group.Submonoid.Basic","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\nι : Sort u_4\ns : ι → Set M\n⊢ Eq (Submonoid.closure (Set.iUnion fun i => s i)) (iSup fun i => Submonoid.closure (s i))","decl":"@[to_additive]\ntheorem closure_iUnion {ι} (s : ι → Set M) : closure (⋃ i, s i) = ⨆ i, closure (s i) :=\n  (Submonoid.gi M).gc.l_iSup\n\n"}
{"name":"AddSubmonoid.closure_singleton_le_iff_mem","module":"Mathlib.Algebra.Group.Submonoid.Basic","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\nm : M\np : AddSubmonoid M\n⊢ Iff (LE.le (AddSubmonoid.closure (Singleton.singleton m)) p) (Membership.mem p m)","decl":"@[to_additive]\ntheorem closure_singleton_le_iff_mem (m : M) (p : Submonoid M) : closure {m} ≤ p ↔ m ∈ p := by\n  rw [closure_le, singleton_subset_iff, SetLike.mem_coe]\n\n"}
{"name":"Submonoid.closure_singleton_le_iff_mem","module":"Mathlib.Algebra.Group.Submonoid.Basic","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\nm : M\np : Submonoid M\n⊢ Iff (LE.le (Submonoid.closure (Singleton.singleton m)) p) (Membership.mem p m)","decl":"@[to_additive]\ntheorem closure_singleton_le_iff_mem (m : M) (p : Submonoid M) : closure {m} ≤ p ↔ m ∈ p := by\n  rw [closure_le, singleton_subset_iff, SetLike.mem_coe]\n\n"}
{"name":"AddSubmonoid.mem_iSup","module":"Mathlib.Algebra.Group.Submonoid.Basic","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\nι : Sort u_4\np : ι → AddSubmonoid M\nm : M\n⊢ Iff (Membership.mem (iSup fun i => p i) m) (∀ (N : AddSubmonoid M), (∀ (i : ι), LE.le (p i) N) → Membership.mem N m)","decl":"@[to_additive]\ntheorem mem_iSup {ι : Sort*} (p : ι → Submonoid M) {m : M} :\n    (m ∈ ⨆ i, p i) ↔ ∀ N, (∀ i, p i ≤ N) → m ∈ N := by\n  rw [← closure_singleton_le_iff_mem, le_iSup_iff]\n  simp only [closure_singleton_le_iff_mem]\n\n"}
{"name":"Submonoid.mem_iSup","module":"Mathlib.Algebra.Group.Submonoid.Basic","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\nι : Sort u_4\np : ι → Submonoid M\nm : M\n⊢ Iff (Membership.mem (iSup fun i => p i) m) (∀ (N : Submonoid M), (∀ (i : ι), LE.le (p i) N) → Membership.mem N m)","decl":"@[to_additive]\ntheorem mem_iSup {ι : Sort*} (p : ι → Submonoid M) {m : M} :\n    (m ∈ ⨆ i, p i) ↔ ∀ N, (∀ i, p i ≤ N) → m ∈ N := by\n  rw [← closure_singleton_le_iff_mem, le_iSup_iff]\n  simp only [closure_singleton_le_iff_mem]\n\n"}
{"name":"AddSubmonoid.iSup_eq_closure","module":"Mathlib.Algebra.Group.Submonoid.Basic","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\nι : Sort u_4\np : ι → AddSubmonoid M\n⊢ Eq (iSup fun i => p i) (AddSubmonoid.closure (Set.iUnion fun i => ↑(p i)))","decl":"@[to_additive]\ntheorem iSup_eq_closure {ι : Sort*} (p : ι → Submonoid M) :\n    ⨆ i, p i = Submonoid.closure (⋃ i, (p i : Set M)) := by\n  simp_rw [Submonoid.closure_iUnion, Submonoid.closure_eq]\n\n"}
{"name":"Submonoid.iSup_eq_closure","module":"Mathlib.Algebra.Group.Submonoid.Basic","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\nι : Sort u_4\np : ι → Submonoid M\n⊢ Eq (iSup fun i => p i) (Submonoid.closure (Set.iUnion fun i => ↑(p i)))","decl":"@[to_additive]\ntheorem iSup_eq_closure {ι : Sort*} (p : ι → Submonoid M) :\n    ⨆ i, p i = Submonoid.closure (⋃ i, (p i : Set M)) := by\n  simp_rw [Submonoid.closure_iUnion, Submonoid.closure_eq]\n\n"}
{"name":"AddSubmonoid.disjoint_def","module":"Mathlib.Algebra.Group.Submonoid.Basic","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\np₁ p₂ : AddSubmonoid M\n⊢ Iff (Disjoint p₁ p₂) (∀ {x : M}, Membership.mem p₁ x → Membership.mem p₂ x → Eq x 0)","decl":"@[to_additive]\ntheorem disjoint_def {p₁ p₂ : Submonoid M} :\n    Disjoint p₁ p₂ ↔ ∀ {x : M}, x ∈ p₁ → x ∈ p₂ → x = 1 := by\n  simp_rw [disjoint_iff_inf_le, SetLike.le_def, mem_inf, and_imp, mem_bot]\n\n"}
{"name":"Submonoid.disjoint_def","module":"Mathlib.Algebra.Group.Submonoid.Basic","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\np₁ p₂ : Submonoid M\n⊢ Iff (Disjoint p₁ p₂) (∀ {x : M}, Membership.mem p₁ x → Membership.mem p₂ x → Eq x 1)","decl":"@[to_additive]\ntheorem disjoint_def {p₁ p₂ : Submonoid M} :\n    Disjoint p₁ p₂ ↔ ∀ {x : M}, x ∈ p₁ → x ∈ p₂ → x = 1 := by\n  simp_rw [disjoint_iff_inf_le, SetLike.le_def, mem_inf, and_imp, mem_bot]\n\n"}
{"name":"AddSubmonoid.disjoint_def'","module":"Mathlib.Algebra.Group.Submonoid.Basic","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\np₁ p₂ : AddSubmonoid M\n⊢ Iff (Disjoint p₁ p₂) (∀ {x y : M}, Membership.mem p₁ x → Membership.mem p₂ y → Eq x y → Eq x 0)","decl":"@[to_additive]\ntheorem disjoint_def' {p₁ p₂ : Submonoid M} :\n    Disjoint p₁ p₂ ↔ ∀ {x y : M}, x ∈ p₁ → y ∈ p₂ → x = y → x = 1 :=\n  disjoint_def.trans ⟨fun h _ _ hx hy hxy => h hx <| hxy.symm ▸ hy, fun h _ hx hx' => h hx hx' rfl⟩\n\n"}
{"name":"Submonoid.disjoint_def'","module":"Mathlib.Algebra.Group.Submonoid.Basic","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\np₁ p₂ : Submonoid M\n⊢ Iff (Disjoint p₁ p₂) (∀ {x y : M}, Membership.mem p₁ x → Membership.mem p₂ y → Eq x y → Eq x 1)","decl":"@[to_additive]\ntheorem disjoint_def' {p₁ p₂ : Submonoid M} :\n    Disjoint p₁ p₂ ↔ ∀ {x y : M}, x ∈ p₁ → y ∈ p₂ → x = y → x = 1 :=\n  disjoint_def.trans ⟨fun h _ _ hx hy hxy => h hx <| hxy.symm ▸ hy, fun h _ hx hx' => h hx hx' rfl⟩\n\n"}
{"name":"AddMonoidHom.eqOn_closureM","module":"Mathlib.Algebra.Group.Submonoid.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\nf g : AddMonoidHom M N\ns : Set M\nh : Set.EqOn (⇑f) (⇑g) s\n⊢ Set.EqOn ⇑f ⇑g ↑(AddSubmonoid.closure s)","decl":"/-- If two monoid homomorphisms are equal on a set, then they are equal on its submonoid closure. -/\n@[to_additive\n      \"If two monoid homomorphisms are equal on a set, then they are equal on its submonoid\n      closure.\"]\ntheorem eqOn_closureM {f g : M →* N} {s : Set M} (h : Set.EqOn f g s) : Set.EqOn f g (closure s) :=\n  show closure s ≤ f.eqLocusM g from closure_le.2 h\n\n"}
{"name":"MonoidHom.eqOn_closureM","module":"Mathlib.Algebra.Group.Submonoid.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\nf g : MonoidHom M N\ns : Set M\nh : Set.EqOn (⇑f) (⇑g) s\n⊢ Set.EqOn ⇑f ⇑g ↑(Submonoid.closure s)","decl":"/-- If two monoid homomorphisms are equal on a set, then they are equal on its submonoid closure. -/\n@[to_additive\n      \"If two monoid homomorphisms are equal on a set, then they are equal on its submonoid\n      closure.\"]\ntheorem eqOn_closureM {f g : M →* N} {s : Set M} (h : Set.EqOn f g s) : Set.EqOn f g (closure s) :=\n  show closure s ≤ f.eqLocusM g from closure_le.2 h\n\n"}
{"name":"AddMonoidHom.eq_of_eqOn_denseM","module":"Mathlib.Algebra.Group.Submonoid.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\ns : Set M\nhs : Eq (AddSubmonoid.closure s) Top.top\nf g : AddMonoidHom M N\nh : Set.EqOn (⇑f) (⇑g) s\n⊢ Eq f g","decl":"@[to_additive]\ntheorem eq_of_eqOn_denseM {s : Set M} (hs : closure s = ⊤) {f g : M →* N} (h : s.EqOn f g) :\n    f = g :=\n  eq_of_eqOn_topM <| hs ▸ eqOn_closureM h\n\n"}
{"name":"MonoidHom.eq_of_eqOn_denseM","module":"Mathlib.Algebra.Group.Submonoid.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\ns : Set M\nhs : Eq (Submonoid.closure s) Top.top\nf g : MonoidHom M N\nh : Set.EqOn (⇑f) (⇑g) s\n⊢ Eq f g","decl":"@[to_additive]\ntheorem eq_of_eqOn_denseM {s : Set M} (hs : closure s = ⊤) {f g : M →* N} (h : s.EqOn f g) :\n    f = g :=\n  eq_of_eqOn_topM <| hs ▸ eqOn_closureM h\n\n"}
{"name":"IsUnit.mem_submonoid_iff","module":"Mathlib.Algebra.Group.Submonoid.Basic","initialProofState":"M : Type u_4\ninst✝ : Monoid M\na : M\n⊢ Iff (Membership.mem (IsUnit.submonoid M) a) (IsUnit a)","decl":"@[to_additive]\ntheorem IsUnit.mem_submonoid_iff {M : Type*} [Monoid M] (a : M) :\n    a ∈ IsUnit.submonoid M ↔ IsUnit a := by\n  change a ∈ setOf IsUnit ↔ IsUnit a\n  rw [Set.mem_setOf_eq]\n\n"}
{"name":"IsAddUnit.mem_addSubmonoid_iff","module":"Mathlib.Algebra.Group.Submonoid.Basic","initialProofState":"M : Type u_4\ninst✝ : AddMonoid M\na : M\n⊢ Iff (Membership.mem (IsAddUnit.addSubmonoid M) a) (IsAddUnit a)","decl":"@[to_additive]\ntheorem IsUnit.mem_submonoid_iff {M : Type*} [Monoid M] (a : M) :\n    a ∈ IsUnit.submonoid M ↔ IsUnit a := by\n  change a ∈ setOf IsUnit ↔ IsUnit a\n  rw [Set.mem_setOf_eq]\n\n"}
{"name":"AddMonoidHom.coe_ofClosureMEqTopLeft","module":"Mathlib.Algebra.Group.Submonoid.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddMonoid M\ninst✝ : AddMonoid N\ns : Set M\nf : M → N\nhs : Eq (AddSubmonoid.closure s) Top.top\nh1 : Eq (f 0) 0\nhmul : ∀ (x : M), Membership.mem s x → ∀ (y : M), Eq (f (HAdd.hAdd x y)) (HAdd.hAdd (f x) (f y))\n⊢ Eq (⇑(AddMonoidHom.ofClosureMEqTopLeft f hs h1 hmul)) f","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_ofClosureMEqTopLeft (f : M → N) (hs : closure s = ⊤) (h1 hmul) :\n    ⇑(ofClosureMEqTopLeft f hs h1 hmul) = f :=\n  rfl\n\n"}
{"name":"MonoidHom.coe_ofClosureMEqTopLeft","module":"Mathlib.Algebra.Group.Submonoid.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Monoid M\ninst✝ : Monoid N\ns : Set M\nf : M → N\nhs : Eq (Submonoid.closure s) Top.top\nh1 : Eq (f 1) 1\nhmul : ∀ (x : M), Membership.mem s x → ∀ (y : M), Eq (f (HMul.hMul x y)) (HMul.hMul (f x) (f y))\n⊢ Eq (⇑(MonoidHom.ofClosureMEqTopLeft f hs h1 hmul)) f","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_ofClosureMEqTopLeft (f : M → N) (hs : closure s = ⊤) (h1 hmul) :\n    ⇑(ofClosureMEqTopLeft f hs h1 hmul) = f :=\n  rfl\n\n"}
{"name":"AddMonoidHom.coe_ofClosureMEqTopRight","module":"Mathlib.Algebra.Group.Submonoid.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddMonoid M\ninst✝ : AddMonoid N\ns : Set M\nf : M → N\nhs : Eq (AddSubmonoid.closure s) Top.top\nh1 : Eq (f 0) 0\nhmul : ∀ (x y : M), Membership.mem s y → Eq (f (HAdd.hAdd x y)) (HAdd.hAdd (f x) (f y))\n⊢ Eq (⇑(AddMonoidHom.ofClosureMEqTopRight f hs h1 hmul)) f","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_ofClosureMEqTopRight (f : M → N) (hs : closure s = ⊤) (h1 hmul) :\n    ⇑(ofClosureMEqTopRight f hs h1 hmul) = f :=\n  rfl\n\n"}
{"name":"MonoidHom.coe_ofClosureMEqTopRight","module":"Mathlib.Algebra.Group.Submonoid.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Monoid M\ninst✝ : Monoid N\ns : Set M\nf : M → N\nhs : Eq (Submonoid.closure s) Top.top\nh1 : Eq (f 1) 1\nhmul : ∀ (x y : M), Membership.mem s y → Eq (f (HMul.hMul x y)) (HMul.hMul (f x) (f y))\n⊢ Eq (⇑(MonoidHom.ofClosureMEqTopRight f hs h1 hmul)) f","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_ofClosureMEqTopRight (f : M → N) (hs : closure s = ⊤) (h1 hmul) :\n    ⇑(ofClosureMEqTopRight f hs h1 hmul) = f :=\n  rfl\n\n"}
