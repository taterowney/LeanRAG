{"name":"Unitization.splitMul_apply","module":"Mathlib.Analysis.Normed.Algebra.Unitization","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NonUnitalNormedRing A\ninstâœÂ² : NormedSpace ğ•œ A\ninstâœÂ¹ : IsScalarTower ğ•œ A A\ninstâœ : SMulCommClass ğ•œ A A\nx : Unitization ğ•œ A\nâŠ¢ Eq ((Unitization.splitMul ğ•œ A) x) { fst := x.fst, snd := HAdd.hAdd ((algebraMap ğ•œ (ContinuousLinearMap (RingHom.id ğ•œ) A A)) x.fst) ((ContinuousLinearMap.mul ğ•œ A) x.snd) }","decl":"@[simp]\ntheorem splitMul_apply (x : Unitization ğ•œ A) :\n    splitMul ğ•œ A x = (x.fst, algebraMap ğ•œ (A â†’L[ğ•œ] A) x.fst + mul ğ•œ A x.snd) :=\n  show (x.fst + 0, _) = (x.fst, _) by rw [add_zero]; rfl\n\n"}
{"name":"Unitization.splitMul_injective_of_clm_mul_injective","module":"Mathlib.Analysis.Normed.Algebra.Unitization","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NonUnitalNormedRing A\ninstâœÂ² : NormedSpace ğ•œ A\ninstâœÂ¹ : IsScalarTower ğ•œ A A\ninstâœ : SMulCommClass ğ•œ A A\nh : Function.Injective â‡‘(ContinuousLinearMap.mul ğ•œ A)\nâŠ¢ Function.Injective â‡‘(Unitization.splitMul ğ•œ A)","decl":"/-- this lemma establishes that if `ContinuousLinearMap.mul ğ•œ A` is injective, then so is\n`Unitization.splitMul ğ•œ A`. When `A` is a `RegularNormedAlgebra`, then\n`ContinuousLinearMap.mul ğ•œ A` is an isometry, and is therefore automatically injective. -/\ntheorem splitMul_injective_of_clm_mul_injective\n    (h : Function.Injective (mul ğ•œ A)) :\n    Function.Injective (splitMul ğ•œ A) := by\n  rw [injective_iff_map_eq_zero]\n  intro x hx\n  induction x\n  rw [map_add] at hx\n  simp only [splitMul_apply, fst_inl, snd_inl, map_zero, add_zero, fst_inr, snd_inr,\n    zero_add, Prod.mk_add_mk, Prod.mk_eq_zero] at hx\n  obtain âŸ¨rfl, hxâŸ© := hx\n  simp only [map_zero, zero_add, inl_zero] at hx âŠ¢\n  rw [â† map_zero (mul ğ•œ A)] at hx\n  rw [h hx, inr_zero]\n\n"}
{"name":"Unitization.splitMul_injective","module":"Mathlib.Analysis.Normed.Algebra.Unitization","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : NonUnitalNormedRing A\ninstâœÂ³ : NormedSpace ğ•œ A\ninstâœÂ² : IsScalarTower ğ•œ A A\ninstâœÂ¹ : SMulCommClass ğ•œ A A\ninstâœ : RegularNormedAlgebra ğ•œ A\nâŠ¢ Function.Injective â‡‘(Unitization.splitMul ğ•œ A)","decl":"/-- In a `RegularNormedAlgebra`, the map `Unitization.splitMul ğ•œ A` is injective.\nWe will use this to pull back the norm from `ğ•œ Ã— (A â†’L[ğ•œ] A)` to `Unitization ğ•œ A`. -/\ntheorem splitMul_injective : Function.Injective (splitMul ğ•œ A) :=\n  splitMul_injective_of_clm_mul_injective (isometry_mul ğ•œ A).injective\n\n"}
{"name":"Unitization.norm_def","module":"Mathlib.Analysis.Normed.Algebra.Unitization","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : NonUnitalNormedRing A\ninstâœÂ³ : NormedSpace ğ•œ A\ninstâœÂ² : IsScalarTower ğ•œ A A\ninstâœÂ¹ : SMulCommClass ğ•œ A A\ninstâœ : RegularNormedAlgebra ğ•œ A\nx : Unitization ğ•œ A\nâŠ¢ Eq (Norm.norm x) (Norm.norm ((Unitization.splitMul ğ•œ A) x))","decl":"theorem norm_def (x : Unitization ğ•œ A) : â€–xâ€– = â€–splitMul ğ•œ A xâ€– :=\n  rfl\n\n"}
{"name":"Unitization.nnnorm_def","module":"Mathlib.Analysis.Normed.Algebra.Unitization","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : NonUnitalNormedRing A\ninstâœÂ³ : NormedSpace ğ•œ A\ninstâœÂ² : IsScalarTower ğ•œ A A\ninstâœÂ¹ : SMulCommClass ğ•œ A A\ninstâœ : RegularNormedAlgebra ğ•œ A\nx : Unitization ğ•œ A\nâŠ¢ Eq (NNNorm.nnnorm x) (NNNorm.nnnorm ((Unitization.splitMul ğ•œ A) x))","decl":"theorem nnnorm_def (x : Unitization ğ•œ A) : â€–xâ€–â‚Š = â€–splitMul ğ•œ A xâ€–â‚Š :=\n  rfl\n\n"}
{"name":"Unitization.norm_eq_sup","module":"Mathlib.Analysis.Normed.Algebra.Unitization","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : NonUnitalNormedRing A\ninstâœÂ³ : NormedSpace ğ•œ A\ninstâœÂ² : IsScalarTower ğ•œ A A\ninstâœÂ¹ : SMulCommClass ğ•œ A A\ninstâœ : RegularNormedAlgebra ğ•œ A\nx : Unitization ğ•œ A\nâŠ¢ Eq (Norm.norm x) (Max.max (Norm.norm x.fst) (Norm.norm (HAdd.hAdd ((algebraMap ğ•œ (ContinuousLinearMap (RingHom.id ğ•œ) A A)) x.fst) ((ContinuousLinearMap.mul ğ•œ A) x.snd))))","decl":"/-- This is often the more useful lemma to rewrite the norm as opposed to `Unitization.norm_def`. -/\ntheorem norm_eq_sup (x : Unitization ğ•œ A) :\n    â€–xâ€– = â€–x.fstâ€– âŠ” â€–algebraMap ğ•œ (A â†’L[ğ•œ] A) x.fst + mul ğ•œ A x.sndâ€– := by\n  rw [norm_def, splitMul_apply, Prod.norm_def]\n\n"}
{"name":"Unitization.nnnorm_eq_sup","module":"Mathlib.Analysis.Normed.Algebra.Unitization","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : NonUnitalNormedRing A\ninstâœÂ³ : NormedSpace ğ•œ A\ninstâœÂ² : IsScalarTower ğ•œ A A\ninstâœÂ¹ : SMulCommClass ğ•œ A A\ninstâœ : RegularNormedAlgebra ğ•œ A\nx : Unitization ğ•œ A\nâŠ¢ Eq (NNNorm.nnnorm x) (Max.max (NNNorm.nnnorm x.fst) (NNNorm.nnnorm (HAdd.hAdd ((algebraMap ğ•œ (ContinuousLinearMap (RingHom.id ğ•œ) A A)) x.fst) ((ContinuousLinearMap.mul ğ•œ A) x.snd))))","decl":"/-- This is often the more useful lemma to rewrite the norm as opposed to\n`Unitization.nnnorm_def`. -/\ntheorem nnnorm_eq_sup (x : Unitization ğ•œ A) :\n    â€–xâ€–â‚Š = â€–x.fstâ€–â‚Š âŠ” â€–algebraMap ğ•œ (A â†’L[ğ•œ] A) x.fst + mul ğ•œ A x.sndâ€–â‚Š :=\n  NNReal.eq <| norm_eq_sup x\n\n"}
{"name":"Unitization.lipschitzWith_addEquiv","module":"Mathlib.Analysis.Normed.Algebra.Unitization","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : NonUnitalNormedRing A\ninstâœÂ³ : NormedSpace ğ•œ A\ninstâœÂ² : IsScalarTower ğ•œ A A\ninstâœÂ¹ : SMulCommClass ğ•œ A A\ninstâœ : RegularNormedAlgebra ğ•œ A\nâŠ¢ LipschitzWith 2 â‡‘(Unitization.addEquiv ğ•œ A)","decl":"theorem lipschitzWith_addEquiv :\n    LipschitzWith 2 (Unitization.addEquiv ğ•œ A) := by\n  rw [â† Real.toNNReal_ofNat]\n  refine AddMonoidHomClass.lipschitz_of_bound (Unitization.addEquiv ğ•œ A) 2 fun x => ?_\n  rw [norm_eq_sup, Prod.norm_def]\n  refine max_le ?_ ?_\n  Â· rw [mul_max_of_nonneg _ _ (zero_le_two : (0 : â„) â‰¤ 2)]\n    exact le_max_of_le_left ((le_add_of_nonneg_left (norm_nonneg _)).trans_eq (two_mul _).symm)\n  Â· nontriviality A\n    rw [two_mul]\n    calc\n      â€–x.sndâ€– = â€–mul ğ•œ A x.sndâ€– :=\n        .symm <| (isometry_mul ğ•œ A).norm_map_of_map_zero (map_zero _) _\n      _ â‰¤ â€–algebraMap ğ•œ _ x.fst + mul ğ•œ A x.sndâ€– + â€–x.fstâ€– := by\n        simpa only [add_comm _ (mul ğ•œ A x.snd), norm_algebraMap'] using\n          norm_le_add_norm_add (mul ğ•œ A x.snd) (algebraMap ğ•œ _ x.fst)\n      _ â‰¤ _ := add_le_add le_sup_right le_sup_left\n\n"}
{"name":"Unitization.antilipschitzWith_addEquiv","module":"Mathlib.Analysis.Normed.Algebra.Unitization","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : NonUnitalNormedRing A\ninstâœÂ³ : NormedSpace ğ•œ A\ninstâœÂ² : IsScalarTower ğ•œ A A\ninstâœÂ¹ : SMulCommClass ğ•œ A A\ninstâœ : RegularNormedAlgebra ğ•œ A\nâŠ¢ AntilipschitzWith 2 â‡‘(Unitization.addEquiv ğ•œ A)","decl":"theorem antilipschitzWith_addEquiv :\n    AntilipschitzWith 2 (addEquiv ğ•œ A) := by\n  refine AddMonoidHomClass.antilipschitz_of_bound (addEquiv ğ•œ A) fun x => ?_\n  rw [norm_eq_sup, Prod.norm_def, NNReal.coe_two]\n  refine max_le ?_ ?_\n  Â· rw [mul_max_of_nonneg _ _ (zero_le_two : (0 : â„) â‰¤ 2)]\n    exact le_max_of_le_left ((le_add_of_nonneg_left (norm_nonneg _)).trans_eq (two_mul _).symm)\n  Â· nontriviality A\n    calc\n      â€–algebraMap ğ•œ _ x.fst + mul ğ•œ A x.sndâ€– â‰¤ â€–algebraMap ğ•œ _ x.fstâ€– + â€–mul ğ•œ A x.sndâ€– :=\n        norm_add_le _ _\n      _ = â€–x.fstâ€– + â€–x.sndâ€– := by\n        rw [norm_algebraMap', (AddMonoidHomClass.isometry_iff_norm (mul ğ•œ A)).mp (isometry_mul ğ•œ A)]\n      _ â‰¤ _ := (add_le_add (le_max_left _ _) (le_max_right _ _)).trans_eq (two_mul _).symm\n\n"}
{"name":"Unitization.uniformity_eq_aux","module":"Mathlib.Analysis.Normed.Algebra.Unitization","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : NonUnitalNormedRing A\ninstâœÂ³ : NormedSpace ğ•œ A\ninstâœÂ² : IsScalarTower ğ•œ A A\ninstâœÂ¹ : SMulCommClass ğ•œ A A\ninstâœ : RegularNormedAlgebra ğ•œ A\nâŠ¢ Eq (uniformity (Unitization ğ•œ A)) (uniformity (Unitization ğ•œ A))","decl":"theorem uniformity_eq_aux :\n    ğ“¤[instUniformSpaceProd.comap <| addEquiv ğ•œ A] = ğ“¤ (Unitization ğ•œ A) := by\n  have key : IsUniformInducing (addEquiv ğ•œ A) :=\n    antilipschitzWith_addEquiv.isUniformInducing lipschitzWith_addEquiv.uniformContinuous\n  rw [â† key.comap_uniformity]\n  rfl\n\n"}
{"name":"Unitization.cobounded_eq_aux","module":"Mathlib.Analysis.Normed.Algebra.Unitization","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : NonUnitalNormedRing A\ninstâœÂ³ : NormedSpace ğ•œ A\ninstâœÂ² : IsScalarTower ğ•œ A A\ninstâœÂ¹ : SMulCommClass ğ•œ A A\ninstâœ : RegularNormedAlgebra ğ•œ A\nâŠ¢ Eq (Bornology.cobounded (Unitization ğ•œ A)) (Bornology.cobounded (Unitization ğ•œ A))","decl":"theorem cobounded_eq_aux :\n    @cobounded _ (Bornology.induced <| addEquiv ğ•œ A) = cobounded (Unitization ğ•œ A) :=\n  le_antisymm lipschitzWith_addEquiv.comap_cobounded_le\n    antilipschitzWith_addEquiv.tendsto_cobounded.le_comap\n\n"}
{"name":"Unitization.isUniformEmbedding_addEquiv","module":"Mathlib.Analysis.Normed.Algebra.Unitization","initialProofState":"A : Type u_2\ninstâœÂ¹ : NonUnitalNormedRing A\nğ•œ : Type u_3\ninstâœ : NontriviallyNormedField ğ•œ\nâŠ¢ IsUniformEmbedding â‡‘(Unitization.addEquiv ğ•œ A)","decl":"theorem isUniformEmbedding_addEquiv {ğ•œ} [NontriviallyNormedField ğ•œ] :\n    IsUniformEmbedding (addEquiv ğ•œ A) where\n  comap_uniformity := rfl\n  injective := (addEquiv ğ•œ A).injective\n\n"}
{"name":"Unitization.uniformEmbedding_addEquiv","module":"Mathlib.Analysis.Normed.Algebra.Unitization","initialProofState":"A : Type u_2\ninstâœÂ¹ : NonUnitalNormedRing A\nğ•œ : Type u_3\ninstâœ : NontriviallyNormedField ğ•œ\nâŠ¢ IsUniformEmbedding â‡‘(Unitization.addEquiv ğ•œ A)","decl":"@[deprecated (since := \"2024-10-01\")]\nalias uniformEmbedding_addEquiv := isUniformEmbedding_addEquiv\n\n"}
{"name":"Unitization.instCompleteSpace","module":"Mathlib.Analysis.Normed.Algebra.Unitization","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœÂ³ : NontriviallyNormedField ğ•œ\ninstâœÂ² : NonUnitalNormedRing A\ninstâœÂ¹ : CompleteSpace ğ•œ\ninstâœ : CompleteSpace A\nâŠ¢ CompleteSpace (Unitization ğ•œ A)","decl":"/-- `Unitization ğ•œ A` is complete whenever `ğ•œ` and `A` are also. -/\ninstance instCompleteSpace [CompleteSpace ğ•œ] [CompleteSpace A] :\n    CompleteSpace (Unitization ğ•œ A) :=\n  uniformEquivProd.completeSpace_iff.2 .prod\n\n"}
{"name":"Unitization.instNormOneClass","module":"Mathlib.Analysis.Normed.Algebra.Unitization","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : NonUnitalNormedRing A\ninstâœÂ³ : NormedSpace ğ•œ A\ninstâœÂ² : IsScalarTower ğ•œ A A\ninstâœÂ¹ : SMulCommClass ğ•œ A A\ninstâœ : RegularNormedAlgebra ğ•œ A\nâŠ¢ NormOneClass (Unitization ğ•œ A)","decl":"instance instNormOneClass : NormOneClass (Unitization ğ•œ A) where\n  norm_one := by simpa only [norm_eq_sup, fst_one, norm_one, snd_one, map_one, map_zero,\n      add_zero, sup_eq_left] using opNorm_le_bound _ zero_le_one fun x => by simp\n\n"}
{"name":"Unitization.norm_inr","module":"Mathlib.Analysis.Normed.Algebra.Unitization","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : NonUnitalNormedRing A\ninstâœÂ³ : NormedSpace ğ•œ A\ninstâœÂ² : IsScalarTower ğ•œ A A\ninstâœÂ¹ : SMulCommClass ğ•œ A A\ninstâœ : RegularNormedAlgebra ğ•œ A\na : A\nâŠ¢ Eq (Norm.norm â†‘a) (Norm.norm a)","decl":"lemma norm_inr (a : A) : â€–(a : Unitization ğ•œ A)â€– = â€–aâ€– := by\n  simp [norm_eq_sup]\n\n"}
{"name":"Unitization.nnnorm_inr","module":"Mathlib.Analysis.Normed.Algebra.Unitization","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : NonUnitalNormedRing A\ninstâœÂ³ : NormedSpace ğ•œ A\ninstâœÂ² : IsScalarTower ğ•œ A A\ninstâœÂ¹ : SMulCommClass ğ•œ A A\ninstâœ : RegularNormedAlgebra ğ•œ A\na : A\nâŠ¢ Eq (NNNorm.nnnorm â†‘a) (NNNorm.nnnorm a)","decl":"lemma nnnorm_inr (a : A) : â€–(a : Unitization ğ•œ A)â€–â‚Š = â€–aâ€–â‚Š :=\n  NNReal.eq <| norm_inr a\n\n"}
{"name":"Unitization.isometry_inr","module":"Mathlib.Analysis.Normed.Algebra.Unitization","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : NonUnitalNormedRing A\ninstâœÂ³ : NormedSpace ğ•œ A\ninstâœÂ² : IsScalarTower ğ•œ A A\ninstâœÂ¹ : SMulCommClass ğ•œ A A\ninstâœ : RegularNormedAlgebra ğ•œ A\nâŠ¢ Isometry Unitization.inr","decl":"lemma isometry_inr : Isometry ((â†‘) : A â†’ Unitization ğ•œ A) :=\n  AddMonoidHomClass.isometry_of_norm (inrNonUnitalAlgHom ğ•œ A) norm_inr\n\n"}
{"name":"Unitization.continuous_inr","module":"Mathlib.Analysis.Normed.Algebra.Unitization","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : NonUnitalNormedRing A\ninstâœÂ³ : NormedSpace ğ•œ A\ninstâœÂ² : IsScalarTower ğ•œ A A\ninstâœÂ¹ : SMulCommClass ğ•œ A A\ninstâœ : RegularNormedAlgebra ğ•œ A\nâŠ¢ Continuous Unitization.inr","decl":"@[fun_prop]\ntheorem continuous_inr : Continuous (inr : A â†’ Unitization ğ•œ A) :=\n  isometry_inr.continuous\n\n"}
{"name":"Unitization.dist_inr","module":"Mathlib.Analysis.Normed.Algebra.Unitization","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : NonUnitalNormedRing A\ninstâœÂ³ : NormedSpace ğ•œ A\ninstâœÂ² : IsScalarTower ğ•œ A A\ninstâœÂ¹ : SMulCommClass ğ•œ A A\ninstâœ : RegularNormedAlgebra ğ•œ A\na b : A\nâŠ¢ Eq (Dist.dist â†‘a â†‘b) (Dist.dist a b)","decl":"lemma dist_inr (a b : A) : dist (a : Unitization ğ•œ A) (b : Unitization ğ•œ A) = dist a b :=\n  isometry_inr.dist_eq a b\n\n"}
{"name":"Unitization.nndist_inr","module":"Mathlib.Analysis.Normed.Algebra.Unitization","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : NonUnitalNormedRing A\ninstâœÂ³ : NormedSpace ğ•œ A\ninstâœÂ² : IsScalarTower ğ•œ A A\ninstâœÂ¹ : SMulCommClass ğ•œ A A\ninstâœ : RegularNormedAlgebra ğ•œ A\na b : A\nâŠ¢ Eq (NNDist.nndist â†‘a â†‘b) (NNDist.nndist a b)","decl":"lemma nndist_inr (a b : A) : nndist (a : Unitization ğ•œ A) (b : Unitization ğ•œ A) = nndist a b :=\n  isometry_inr.nndist_eq a b\n\n/- These examples verify that the bornology and uniformity (hence also the topology) are the\ncorrect ones. -/\n"}
