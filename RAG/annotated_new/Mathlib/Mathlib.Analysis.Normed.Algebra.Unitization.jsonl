{"name":"Unitization.splitMul_apply","module":"Mathlib.Analysis.Normed.Algebra.Unitization","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NonUnitalNormedRing A\ninst✝² : NormedSpace 𝕜 A\ninst✝¹ : IsScalarTower 𝕜 A A\ninst✝ : SMulCommClass 𝕜 A A\nx : Unitization 𝕜 A\n⊢ Eq ((Unitization.splitMul 𝕜 A) x) { fst := x.fst, snd := HAdd.hAdd ((algebraMap 𝕜 (ContinuousLinearMap (RingHom.id 𝕜) A A)) x.fst) ((ContinuousLinearMap.mul 𝕜 A) x.snd) }","decl":"@[simp]\ntheorem splitMul_apply (x : Unitization 𝕜 A) :\n    splitMul 𝕜 A x = (x.fst, algebraMap 𝕜 (A →L[𝕜] A) x.fst + mul 𝕜 A x.snd) :=\n  show (x.fst + 0, _) = (x.fst, _) by rw [add_zero]; rfl\n\n"}
{"name":"Unitization.splitMul_injective_of_clm_mul_injective","module":"Mathlib.Analysis.Normed.Algebra.Unitization","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NonUnitalNormedRing A\ninst✝² : NormedSpace 𝕜 A\ninst✝¹ : IsScalarTower 𝕜 A A\ninst✝ : SMulCommClass 𝕜 A A\nh : Function.Injective ⇑(ContinuousLinearMap.mul 𝕜 A)\n⊢ Function.Injective ⇑(Unitization.splitMul 𝕜 A)","decl":"/-- this lemma establishes that if `ContinuousLinearMap.mul 𝕜 A` is injective, then so is\n`Unitization.splitMul 𝕜 A`. When `A` is a `RegularNormedAlgebra`, then\n`ContinuousLinearMap.mul 𝕜 A` is an isometry, and is therefore automatically injective. -/\ntheorem splitMul_injective_of_clm_mul_injective\n    (h : Function.Injective (mul 𝕜 A)) :\n    Function.Injective (splitMul 𝕜 A) := by\n  rw [injective_iff_map_eq_zero]\n  intro x hx\n  induction x\n  rw [map_add] at hx\n  simp only [splitMul_apply, fst_inl, snd_inl, map_zero, add_zero, fst_inr, snd_inr,\n    zero_add, Prod.mk_add_mk, Prod.mk_eq_zero] at hx\n  obtain ⟨rfl, hx⟩ := hx\n  simp only [map_zero, zero_add, inl_zero] at hx ⊢\n  rw [← map_zero (mul 𝕜 A)] at hx\n  rw [h hx, inr_zero]\n\n"}
{"name":"Unitization.splitMul_injective","module":"Mathlib.Analysis.Normed.Algebra.Unitization","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NonUnitalNormedRing A\ninst✝³ : NormedSpace 𝕜 A\ninst✝² : IsScalarTower 𝕜 A A\ninst✝¹ : SMulCommClass 𝕜 A A\ninst✝ : RegularNormedAlgebra 𝕜 A\n⊢ Function.Injective ⇑(Unitization.splitMul 𝕜 A)","decl":"/-- In a `RegularNormedAlgebra`, the map `Unitization.splitMul 𝕜 A` is injective.\nWe will use this to pull back the norm from `𝕜 × (A →L[𝕜] A)` to `Unitization 𝕜 A`. -/\ntheorem splitMul_injective : Function.Injective (splitMul 𝕜 A) :=\n  splitMul_injective_of_clm_mul_injective (isometry_mul 𝕜 A).injective\n\n"}
{"name":"Unitization.norm_def","module":"Mathlib.Analysis.Normed.Algebra.Unitization","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NonUnitalNormedRing A\ninst✝³ : NormedSpace 𝕜 A\ninst✝² : IsScalarTower 𝕜 A A\ninst✝¹ : SMulCommClass 𝕜 A A\ninst✝ : RegularNormedAlgebra 𝕜 A\nx : Unitization 𝕜 A\n⊢ Eq (Norm.norm x) (Norm.norm ((Unitization.splitMul 𝕜 A) x))","decl":"theorem norm_def (x : Unitization 𝕜 A) : ‖x‖ = ‖splitMul 𝕜 A x‖ :=\n  rfl\n\n"}
{"name":"Unitization.nnnorm_def","module":"Mathlib.Analysis.Normed.Algebra.Unitization","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NonUnitalNormedRing A\ninst✝³ : NormedSpace 𝕜 A\ninst✝² : IsScalarTower 𝕜 A A\ninst✝¹ : SMulCommClass 𝕜 A A\ninst✝ : RegularNormedAlgebra 𝕜 A\nx : Unitization 𝕜 A\n⊢ Eq (NNNorm.nnnorm x) (NNNorm.nnnorm ((Unitization.splitMul 𝕜 A) x))","decl":"theorem nnnorm_def (x : Unitization 𝕜 A) : ‖x‖₊ = ‖splitMul 𝕜 A x‖₊ :=\n  rfl\n\n"}
{"name":"Unitization.norm_eq_sup","module":"Mathlib.Analysis.Normed.Algebra.Unitization","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NonUnitalNormedRing A\ninst✝³ : NormedSpace 𝕜 A\ninst✝² : IsScalarTower 𝕜 A A\ninst✝¹ : SMulCommClass 𝕜 A A\ninst✝ : RegularNormedAlgebra 𝕜 A\nx : Unitization 𝕜 A\n⊢ Eq (Norm.norm x) (Max.max (Norm.norm x.fst) (Norm.norm (HAdd.hAdd ((algebraMap 𝕜 (ContinuousLinearMap (RingHom.id 𝕜) A A)) x.fst) ((ContinuousLinearMap.mul 𝕜 A) x.snd))))","decl":"/-- This is often the more useful lemma to rewrite the norm as opposed to `Unitization.norm_def`. -/\ntheorem norm_eq_sup (x : Unitization 𝕜 A) :\n    ‖x‖ = ‖x.fst‖ ⊔ ‖algebraMap 𝕜 (A →L[𝕜] A) x.fst + mul 𝕜 A x.snd‖ := by\n  rw [norm_def, splitMul_apply, Prod.norm_def]\n\n"}
{"name":"Unitization.nnnorm_eq_sup","module":"Mathlib.Analysis.Normed.Algebra.Unitization","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NonUnitalNormedRing A\ninst✝³ : NormedSpace 𝕜 A\ninst✝² : IsScalarTower 𝕜 A A\ninst✝¹ : SMulCommClass 𝕜 A A\ninst✝ : RegularNormedAlgebra 𝕜 A\nx : Unitization 𝕜 A\n⊢ Eq (NNNorm.nnnorm x) (Max.max (NNNorm.nnnorm x.fst) (NNNorm.nnnorm (HAdd.hAdd ((algebraMap 𝕜 (ContinuousLinearMap (RingHom.id 𝕜) A A)) x.fst) ((ContinuousLinearMap.mul 𝕜 A) x.snd))))","decl":"/-- This is often the more useful lemma to rewrite the norm as opposed to\n`Unitization.nnnorm_def`. -/\ntheorem nnnorm_eq_sup (x : Unitization 𝕜 A) :\n    ‖x‖₊ = ‖x.fst‖₊ ⊔ ‖algebraMap 𝕜 (A →L[𝕜] A) x.fst + mul 𝕜 A x.snd‖₊ :=\n  NNReal.eq <| norm_eq_sup x\n\n"}
{"name":"Unitization.lipschitzWith_addEquiv","module":"Mathlib.Analysis.Normed.Algebra.Unitization","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NonUnitalNormedRing A\ninst✝³ : NormedSpace 𝕜 A\ninst✝² : IsScalarTower 𝕜 A A\ninst✝¹ : SMulCommClass 𝕜 A A\ninst✝ : RegularNormedAlgebra 𝕜 A\n⊢ LipschitzWith 2 ⇑(Unitization.addEquiv 𝕜 A)","decl":"theorem lipschitzWith_addEquiv :\n    LipschitzWith 2 (Unitization.addEquiv 𝕜 A) := by\n  rw [← Real.toNNReal_ofNat]\n  refine AddMonoidHomClass.lipschitz_of_bound (Unitization.addEquiv 𝕜 A) 2 fun x => ?_\n  rw [norm_eq_sup, Prod.norm_def]\n  refine max_le ?_ ?_\n  · rw [mul_max_of_nonneg _ _ (zero_le_two : (0 : ℝ) ≤ 2)]\n    exact le_max_of_le_left ((le_add_of_nonneg_left (norm_nonneg _)).trans_eq (two_mul _).symm)\n  · nontriviality A\n    rw [two_mul]\n    calc\n      ‖x.snd‖ = ‖mul 𝕜 A x.snd‖ :=\n        .symm <| (isometry_mul 𝕜 A).norm_map_of_map_zero (map_zero _) _\n      _ ≤ ‖algebraMap 𝕜 _ x.fst + mul 𝕜 A x.snd‖ + ‖x.fst‖ := by\n        simpa only [add_comm _ (mul 𝕜 A x.snd), norm_algebraMap'] using\n          norm_le_add_norm_add (mul 𝕜 A x.snd) (algebraMap 𝕜 _ x.fst)\n      _ ≤ _ := add_le_add le_sup_right le_sup_left\n\n"}
{"name":"Unitization.antilipschitzWith_addEquiv","module":"Mathlib.Analysis.Normed.Algebra.Unitization","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NonUnitalNormedRing A\ninst✝³ : NormedSpace 𝕜 A\ninst✝² : IsScalarTower 𝕜 A A\ninst✝¹ : SMulCommClass 𝕜 A A\ninst✝ : RegularNormedAlgebra 𝕜 A\n⊢ AntilipschitzWith 2 ⇑(Unitization.addEquiv 𝕜 A)","decl":"theorem antilipschitzWith_addEquiv :\n    AntilipschitzWith 2 (addEquiv 𝕜 A) := by\n  refine AddMonoidHomClass.antilipschitz_of_bound (addEquiv 𝕜 A) fun x => ?_\n  rw [norm_eq_sup, Prod.norm_def, NNReal.coe_two]\n  refine max_le ?_ ?_\n  · rw [mul_max_of_nonneg _ _ (zero_le_two : (0 : ℝ) ≤ 2)]\n    exact le_max_of_le_left ((le_add_of_nonneg_left (norm_nonneg _)).trans_eq (two_mul _).symm)\n  · nontriviality A\n    calc\n      ‖algebraMap 𝕜 _ x.fst + mul 𝕜 A x.snd‖ ≤ ‖algebraMap 𝕜 _ x.fst‖ + ‖mul 𝕜 A x.snd‖ :=\n        norm_add_le _ _\n      _ = ‖x.fst‖ + ‖x.snd‖ := by\n        rw [norm_algebraMap', (AddMonoidHomClass.isometry_iff_norm (mul 𝕜 A)).mp (isometry_mul 𝕜 A)]\n      _ ≤ _ := (add_le_add (le_max_left _ _) (le_max_right _ _)).trans_eq (two_mul _).symm\n\n"}
{"name":"Unitization.uniformity_eq_aux","module":"Mathlib.Analysis.Normed.Algebra.Unitization","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NonUnitalNormedRing A\ninst✝³ : NormedSpace 𝕜 A\ninst✝² : IsScalarTower 𝕜 A A\ninst✝¹ : SMulCommClass 𝕜 A A\ninst✝ : RegularNormedAlgebra 𝕜 A\n⊢ Eq (uniformity (Unitization 𝕜 A)) (uniformity (Unitization 𝕜 A))","decl":"theorem uniformity_eq_aux :\n    𝓤[instUniformSpaceProd.comap <| addEquiv 𝕜 A] = 𝓤 (Unitization 𝕜 A) := by\n  have key : IsUniformInducing (addEquiv 𝕜 A) :=\n    antilipschitzWith_addEquiv.isUniformInducing lipschitzWith_addEquiv.uniformContinuous\n  rw [← key.comap_uniformity]\n  rfl\n\n"}
{"name":"Unitization.cobounded_eq_aux","module":"Mathlib.Analysis.Normed.Algebra.Unitization","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NonUnitalNormedRing A\ninst✝³ : NormedSpace 𝕜 A\ninst✝² : IsScalarTower 𝕜 A A\ninst✝¹ : SMulCommClass 𝕜 A A\ninst✝ : RegularNormedAlgebra 𝕜 A\n⊢ Eq (Bornology.cobounded (Unitization 𝕜 A)) (Bornology.cobounded (Unitization 𝕜 A))","decl":"theorem cobounded_eq_aux :\n    @cobounded _ (Bornology.induced <| addEquiv 𝕜 A) = cobounded (Unitization 𝕜 A) :=\n  le_antisymm lipschitzWith_addEquiv.comap_cobounded_le\n    antilipschitzWith_addEquiv.tendsto_cobounded.le_comap\n\n"}
{"name":"Unitization.isUniformEmbedding_addEquiv","module":"Mathlib.Analysis.Normed.Algebra.Unitization","initialProofState":"A : Type u_2\ninst✝¹ : NonUnitalNormedRing A\n𝕜 : Type u_3\ninst✝ : NontriviallyNormedField 𝕜\n⊢ IsUniformEmbedding ⇑(Unitization.addEquiv 𝕜 A)","decl":"theorem isUniformEmbedding_addEquiv {𝕜} [NontriviallyNormedField 𝕜] :\n    IsUniformEmbedding (addEquiv 𝕜 A) where\n  comap_uniformity := rfl\n  injective := (addEquiv 𝕜 A).injective\n\n"}
{"name":"Unitization.uniformEmbedding_addEquiv","module":"Mathlib.Analysis.Normed.Algebra.Unitization","initialProofState":"A : Type u_2\ninst✝¹ : NonUnitalNormedRing A\n𝕜 : Type u_3\ninst✝ : NontriviallyNormedField 𝕜\n⊢ IsUniformEmbedding ⇑(Unitization.addEquiv 𝕜 A)","decl":"@[deprecated (since := \"2024-10-01\")]\nalias uniformEmbedding_addEquiv := isUniformEmbedding_addEquiv\n\n"}
{"name":"Unitization.instCompleteSpace","module":"Mathlib.Analysis.Normed.Algebra.Unitization","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝³ : NontriviallyNormedField 𝕜\ninst✝² : NonUnitalNormedRing A\ninst✝¹ : CompleteSpace 𝕜\ninst✝ : CompleteSpace A\n⊢ CompleteSpace (Unitization 𝕜 A)","decl":"/-- `Unitization 𝕜 A` is complete whenever `𝕜` and `A` are also. -/\ninstance instCompleteSpace [CompleteSpace 𝕜] [CompleteSpace A] :\n    CompleteSpace (Unitization 𝕜 A) :=\n  uniformEquivProd.completeSpace_iff.2 .prod\n\n"}
{"name":"Unitization.instNormOneClass","module":"Mathlib.Analysis.Normed.Algebra.Unitization","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NonUnitalNormedRing A\ninst✝³ : NormedSpace 𝕜 A\ninst✝² : IsScalarTower 𝕜 A A\ninst✝¹ : SMulCommClass 𝕜 A A\ninst✝ : RegularNormedAlgebra 𝕜 A\n⊢ NormOneClass (Unitization 𝕜 A)","decl":"instance instNormOneClass : NormOneClass (Unitization 𝕜 A) where\n  norm_one := by simpa only [norm_eq_sup, fst_one, norm_one, snd_one, map_one, map_zero,\n      add_zero, sup_eq_left] using opNorm_le_bound _ zero_le_one fun x => by simp\n\n"}
{"name":"Unitization.norm_inr","module":"Mathlib.Analysis.Normed.Algebra.Unitization","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NonUnitalNormedRing A\ninst✝³ : NormedSpace 𝕜 A\ninst✝² : IsScalarTower 𝕜 A A\ninst✝¹ : SMulCommClass 𝕜 A A\ninst✝ : RegularNormedAlgebra 𝕜 A\na : A\n⊢ Eq (Norm.norm ↑a) (Norm.norm a)","decl":"lemma norm_inr (a : A) : ‖(a : Unitization 𝕜 A)‖ = ‖a‖ := by\n  simp [norm_eq_sup]\n\n"}
{"name":"Unitization.nnnorm_inr","module":"Mathlib.Analysis.Normed.Algebra.Unitization","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NonUnitalNormedRing A\ninst✝³ : NormedSpace 𝕜 A\ninst✝² : IsScalarTower 𝕜 A A\ninst✝¹ : SMulCommClass 𝕜 A A\ninst✝ : RegularNormedAlgebra 𝕜 A\na : A\n⊢ Eq (NNNorm.nnnorm ↑a) (NNNorm.nnnorm a)","decl":"lemma nnnorm_inr (a : A) : ‖(a : Unitization 𝕜 A)‖₊ = ‖a‖₊ :=\n  NNReal.eq <| norm_inr a\n\n"}
{"name":"Unitization.isometry_inr","module":"Mathlib.Analysis.Normed.Algebra.Unitization","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NonUnitalNormedRing A\ninst✝³ : NormedSpace 𝕜 A\ninst✝² : IsScalarTower 𝕜 A A\ninst✝¹ : SMulCommClass 𝕜 A A\ninst✝ : RegularNormedAlgebra 𝕜 A\n⊢ Isometry Unitization.inr","decl":"lemma isometry_inr : Isometry ((↑) : A → Unitization 𝕜 A) :=\n  AddMonoidHomClass.isometry_of_norm (inrNonUnitalAlgHom 𝕜 A) norm_inr\n\n"}
{"name":"Unitization.continuous_inr","module":"Mathlib.Analysis.Normed.Algebra.Unitization","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NonUnitalNormedRing A\ninst✝³ : NormedSpace 𝕜 A\ninst✝² : IsScalarTower 𝕜 A A\ninst✝¹ : SMulCommClass 𝕜 A A\ninst✝ : RegularNormedAlgebra 𝕜 A\n⊢ Continuous Unitization.inr","decl":"@[fun_prop]\ntheorem continuous_inr : Continuous (inr : A → Unitization 𝕜 A) :=\n  isometry_inr.continuous\n\n"}
{"name":"Unitization.dist_inr","module":"Mathlib.Analysis.Normed.Algebra.Unitization","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NonUnitalNormedRing A\ninst✝³ : NormedSpace 𝕜 A\ninst✝² : IsScalarTower 𝕜 A A\ninst✝¹ : SMulCommClass 𝕜 A A\ninst✝ : RegularNormedAlgebra 𝕜 A\na b : A\n⊢ Eq (Dist.dist ↑a ↑b) (Dist.dist a b)","decl":"lemma dist_inr (a b : A) : dist (a : Unitization 𝕜 A) (b : Unitization 𝕜 A) = dist a b :=\n  isometry_inr.dist_eq a b\n\n"}
{"name":"Unitization.nndist_inr","module":"Mathlib.Analysis.Normed.Algebra.Unitization","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NonUnitalNormedRing A\ninst✝³ : NormedSpace 𝕜 A\ninst✝² : IsScalarTower 𝕜 A A\ninst✝¹ : SMulCommClass 𝕜 A A\ninst✝ : RegularNormedAlgebra 𝕜 A\na b : A\n⊢ Eq (NNDist.nndist ↑a ↑b) (NNDist.nndist a b)","decl":"lemma nndist_inr (a b : A) : nndist (a : Unitization 𝕜 A) (b : Unitization 𝕜 A) = nndist a b :=\n  isometry_inr.nndist_eq a b\n\n/- These examples verify that the bornology and uniformity (hence also the topology) are the\ncorrect ones. -/\n"}
