{"name":"ContinuousLinearMap.rayleigh_smul","module":"Mathlib.Analysis.InnerProductSpace.Rayleigh","initialProofState":"𝕜 : Type u_1\ninst✝² : RCLike 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nT : ContinuousLinearMap (RingHom.id 𝕜) E E\nx : E\nc : 𝕜\nhc : Ne c 0\n⊢ Eq (T.rayleighQuotient (HSMul.hSMul c x)) (T.rayleighQuotient x)","decl":"theorem rayleigh_smul (x : E) {c : 𝕜} (hc : c ≠ 0) :\n    rayleighQuotient T (c • x) = rayleighQuotient T x := by\n  by_cases hx : x = 0\n  · simp [hx]\n  field_simp [norm_smul, T.reApplyInnerSelf_smul]\n  ring\n\n"}
{"name":"ContinuousLinearMap.image_rayleigh_eq_image_rayleigh_sphere","module":"Mathlib.Analysis.InnerProductSpace.Rayleigh","initialProofState":"𝕜 : Type u_1\ninst✝² : RCLike 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nT : ContinuousLinearMap (RingHom.id 𝕜) E E\nr : Real\nhr : LT.lt 0 r\n⊢ Eq (Set.image T.rayleighQuotient (HasCompl.compl (Singleton.singleton 0))) (Set.image T.rayleighQuotient (Metric.sphere 0 r))","decl":"theorem image_rayleigh_eq_image_rayleigh_sphere {r : ℝ} (hr : 0 < r) :\n    rayleighQuotient T '' {0}ᶜ = rayleighQuotient T '' sphere 0 r := by\n  ext a\n  constructor\n  · rintro ⟨x, hx : x ≠ 0, hxT⟩\n    have : ‖x‖ ≠ 0 := by simp [hx]\n    let c : 𝕜 := ↑‖x‖⁻¹ * r\n    have : c ≠ 0 := by simp [c, hx, hr.ne']\n    refine ⟨c • x, ?_, ?_⟩\n    · field_simp [c, norm_smul, abs_of_pos hr]\n    · rw [T.rayleigh_smul x this]\n      exact hxT\n  · rintro ⟨x, hx, hxT⟩\n    exact ⟨x, ne_zero_of_mem_sphere hr.ne' ⟨x, hx⟩, hxT⟩\n\n"}
{"name":"ContinuousLinearMap.iSup_rayleigh_eq_iSup_rayleigh_sphere","module":"Mathlib.Analysis.InnerProductSpace.Rayleigh","initialProofState":"𝕜 : Type u_1\ninst✝² : RCLike 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nT : ContinuousLinearMap (RingHom.id 𝕜) E E\nr : Real\nhr : LT.lt 0 r\n⊢ Eq (iSup fun x => T.rayleighQuotient ↑x) (iSup fun x => T.rayleighQuotient ↑x)","decl":"theorem iSup_rayleigh_eq_iSup_rayleigh_sphere {r : ℝ} (hr : 0 < r) :\n    ⨆ x : { x : E // x ≠ 0 }, rayleighQuotient T x =\n      ⨆ x : sphere (0 : E) r, rayleighQuotient T x :=\n  show ⨆ x : ({0}ᶜ : Set E), rayleighQuotient T x = _ by\n    simp only [← @sSup_image' _ _ _ _ (rayleighQuotient T),\n      T.image_rayleigh_eq_image_rayleigh_sphere hr]\n\n"}
{"name":"ContinuousLinearMap.iInf_rayleigh_eq_iInf_rayleigh_sphere","module":"Mathlib.Analysis.InnerProductSpace.Rayleigh","initialProofState":"𝕜 : Type u_1\ninst✝² : RCLike 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nT : ContinuousLinearMap (RingHom.id 𝕜) E E\nr : Real\nhr : LT.lt 0 r\n⊢ Eq (iInf fun x => T.rayleighQuotient ↑x) (iInf fun x => T.rayleighQuotient ↑x)","decl":"theorem iInf_rayleigh_eq_iInf_rayleigh_sphere {r : ℝ} (hr : 0 < r) :\n    ⨅ x : { x : E // x ≠ 0 }, rayleighQuotient T x =\n      ⨅ x : sphere (0 : E) r, rayleighQuotient T x :=\n  show ⨅ x : ({0}ᶜ : Set E), rayleighQuotient T x = _ by\n    simp only [← @sInf_image' _ _ _ _ (rayleighQuotient T),\n      T.image_rayleigh_eq_image_rayleigh_sphere hr]\n\n"}
{"name":"LinearMap.IsSymmetric.hasStrictFDerivAt_reApplyInnerSelf","module":"Mathlib.Analysis.InnerProductSpace.Rayleigh","initialProofState":"F : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : InnerProductSpace Real F\nT : ContinuousLinearMap (RingHom.id Real) F F\nhT : (↑T).IsSymmetric\nx₀ : F\n⊢ HasStrictFDerivAt T.reApplyInnerSelf (HSMul.hSMul 2 ((innerSL Real) (T x₀))) x₀","decl":"theorem _root_.LinearMap.IsSymmetric.hasStrictFDerivAt_reApplyInnerSelf {T : F →L[ℝ] F}\n    (hT : (T : F →ₗ[ℝ] F).IsSymmetric) (x₀ : F) :\n    HasStrictFDerivAt T.reApplyInnerSelf (2 • (innerSL ℝ (T x₀))) x₀ := by\n  convert T.hasStrictFDerivAt.inner ℝ (hasStrictFDerivAt_id x₀) using 1\n  ext y\n  rw [ContinuousLinearMap.smul_apply, ContinuousLinearMap.comp_apply, fderivInnerCLM_apply,\n    ContinuousLinearMap.prod_apply, innerSL_apply, id, ContinuousLinearMap.id_apply,\n    hT.apply_clm x₀ y, real_inner_comm _ x₀, two_smul]\n\n"}
{"name":"IsSelfAdjoint.linearly_dependent_of_isLocalExtrOn","module":"Mathlib.Analysis.InnerProductSpace.Rayleigh","initialProofState":"F : Type u_3\ninst✝² : NormedAddCommGroup F\ninst✝¹ : InnerProductSpace Real F\ninst✝ : CompleteSpace F\nT : ContinuousLinearMap (RingHom.id Real) F F\nhT : IsSelfAdjoint T\nx₀ : F\nhextr : IsLocalExtrOn T.reApplyInnerSelf (Metric.sphere 0 (Norm.norm x₀)) x₀\n⊢ Exists fun a => Exists fun b => And (Ne { fst := a, snd := b } 0) (Eq (HAdd.hAdd (HSMul.hSMul a x₀) (HSMul.hSMul b (T x₀))) 0)","decl":"theorem linearly_dependent_of_isLocalExtrOn (hT : IsSelfAdjoint T) {x₀ : F}\n    (hextr : IsLocalExtrOn T.reApplyInnerSelf (sphere (0 : F) ‖x₀‖) x₀) :\n    ∃ a b : ℝ, (a, b) ≠ 0 ∧ a • x₀ + b • T x₀ = 0 := by\n  have H : IsLocalExtrOn T.reApplyInnerSelf {x : F | ‖x‖ ^ 2 = ‖x₀‖ ^ 2} x₀ := by\n    convert hextr\n    ext x\n    simp [dist_eq_norm]\n  -- find Lagrange multipliers for the function `T.re_apply_inner_self` and the\n  -- hypersurface-defining function `fun x ↦ ‖x‖ ^ 2`\n  obtain ⟨a, b, h₁, h₂⟩ :=\n    IsLocalExtrOn.exists_multipliers_of_hasStrictFDerivAt_1d H (hasStrictFDerivAt_norm_sq x₀)\n      (hT.isSymmetric.hasStrictFDerivAt_reApplyInnerSelf x₀)\n  refine ⟨a, b, h₁, ?_⟩\n  apply (InnerProductSpace.toDualMap ℝ F).injective\n  simp only [LinearIsometry.map_add, LinearIsometry.map_smul, LinearIsometry.map_zero]\n  -- Note: https://github.com/leanprover-community/mathlib4/pull/8386 changed `map_smulₛₗ` into `map_smulₛₗ _`\n  simp only [map_smulₛₗ _, RCLike.conj_to_real]\n  change a • innerSL ℝ x₀ + b • innerSL ℝ (T x₀) = 0\n  apply smul_right_injective (F →L[ℝ] ℝ) (two_ne_zero : (2 : ℝ) ≠ 0)\n  simpa only [two_smul, smul_add, add_smul, add_zero] using h₂\n\n"}
{"name":"IsSelfAdjoint.eq_smul_self_of_isLocalExtrOn_real","module":"Mathlib.Analysis.InnerProductSpace.Rayleigh","initialProofState":"F : Type u_3\ninst✝² : NormedAddCommGroup F\ninst✝¹ : InnerProductSpace Real F\ninst✝ : CompleteSpace F\nT : ContinuousLinearMap (RingHom.id Real) F F\nhT : IsSelfAdjoint T\nx₀ : F\nhextr : IsLocalExtrOn T.reApplyInnerSelf (Metric.sphere 0 (Norm.norm x₀)) x₀\n⊢ Eq (T x₀) (HSMul.hSMul (T.rayleighQuotient x₀) x₀)","decl":"open scoped InnerProductSpace in\ntheorem eq_smul_self_of_isLocalExtrOn_real (hT : IsSelfAdjoint T) {x₀ : F}\n    (hextr : IsLocalExtrOn T.reApplyInnerSelf (sphere (0 : F) ‖x₀‖) x₀) :\n    T x₀ = T.rayleighQuotient x₀ • x₀ := by\n  obtain ⟨a, b, h₁, h₂⟩ := hT.linearly_dependent_of_isLocalExtrOn hextr\n  by_cases hx₀ : x₀ = 0\n  · simp [hx₀]\n  by_cases hb : b = 0\n  · have : a ≠ 0 := by simpa [hb] using h₁\n    refine absurd ?_ hx₀\n    apply smul_right_injective F this\n    simpa [hb] using h₂\n  let c : ℝ := -b⁻¹ * a\n  have hc : T x₀ = c • x₀ := by\n    have : b * (b⁻¹ * a) = a := by field_simp [mul_comm]\n    apply smul_right_injective F hb\n    simp [c, eq_neg_of_add_eq_zero_left h₂, ← mul_smul, this]\n  convert hc\n  have := congr_arg (fun x => ⟪x, x₀⟫_ℝ) hc\n  field_simp [inner_smul_left, real_inner_self_eq_norm_mul_norm, sq] at this ⊢\n  exact this\n\n"}
{"name":"IsSelfAdjoint.eq_smul_self_of_isLocalExtrOn","module":"Mathlib.Analysis.InnerProductSpace.Rayleigh","initialProofState":"𝕜 : Type u_1\ninst✝³ : RCLike 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : CompleteSpace E\nT : ContinuousLinearMap (RingHom.id 𝕜) E E\nhT : IsSelfAdjoint T\nx₀ : E\nhextr : IsLocalExtrOn T.reApplyInnerSelf (Metric.sphere 0 (Norm.norm x₀)) x₀\n⊢ Eq (T x₀) (HSMul.hSMul (↑(T.rayleighQuotient x₀)) x₀)","decl":"theorem eq_smul_self_of_isLocalExtrOn (hT : IsSelfAdjoint T) {x₀ : E}\n    (hextr : IsLocalExtrOn T.reApplyInnerSelf (sphere (0 : E) ‖x₀‖) x₀) :\n    T x₀ = (↑(T.rayleighQuotient x₀) : 𝕜) • x₀ := by\n  letI := InnerProductSpace.rclikeToReal 𝕜 E\n  let hSA := hT.isSymmetric.restrictScalars.toSelfAdjoint.prop\n  exact hSA.eq_smul_self_of_isLocalExtrOn_real hextr\n\n"}
{"name":"IsSelfAdjoint.hasEigenvector_of_isLocalExtrOn","module":"Mathlib.Analysis.InnerProductSpace.Rayleigh","initialProofState":"𝕜 : Type u_1\ninst✝³ : RCLike 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : CompleteSpace E\nT : ContinuousLinearMap (RingHom.id 𝕜) E E\nhT : IsSelfAdjoint T\nx₀ : E\nhx₀ : Ne x₀ 0\nhextr : IsLocalExtrOn T.reApplyInnerSelf (Metric.sphere 0 (Norm.norm x₀)) x₀\n⊢ Module.End.HasEigenvector (↑T) (↑(T.rayleighQuotient x₀)) x₀","decl":"/-- For a self-adjoint operator `T`, a local extremum of the Rayleigh quotient of `T` on a sphere\ncentred at the origin is an eigenvector of `T`. -/\ntheorem hasEigenvector_of_isLocalExtrOn (hT : IsSelfAdjoint T) {x₀ : E} (hx₀ : x₀ ≠ 0)\n    (hextr : IsLocalExtrOn T.reApplyInnerSelf (sphere (0 : E) ‖x₀‖) x₀) :\n    HasEigenvector (T : E →ₗ[𝕜] E) (↑(T.rayleighQuotient x₀)) x₀ := by\n  refine ⟨?_, hx₀⟩\n  rw [Module.End.mem_eigenspace_iff]\n  exact hT.eq_smul_self_of_isLocalExtrOn hextr\n\n"}
{"name":"IsSelfAdjoint.hasEigenvector_of_isMaxOn","module":"Mathlib.Analysis.InnerProductSpace.Rayleigh","initialProofState":"𝕜 : Type u_1\ninst✝³ : RCLike 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : CompleteSpace E\nT : ContinuousLinearMap (RingHom.id 𝕜) E E\nhT : IsSelfAdjoint T\nx₀ : E\nhx₀ : Ne x₀ 0\nhextr : IsMaxOn T.reApplyInnerSelf (Metric.sphere 0 (Norm.norm x₀)) x₀\n⊢ Module.End.HasEigenvector (↑T) (↑(iSup fun x => T.rayleighQuotient ↑x)) x₀","decl":"/-- For a self-adjoint operator `T`, a maximum of the Rayleigh quotient of `T` on a sphere centred\nat the origin is an eigenvector of `T`, with eigenvalue the global supremum of the Rayleigh\nquotient. -/\ntheorem hasEigenvector_of_isMaxOn (hT : IsSelfAdjoint T) {x₀ : E} (hx₀ : x₀ ≠ 0)\n    (hextr : IsMaxOn T.reApplyInnerSelf (sphere (0 : E) ‖x₀‖) x₀) :\n    HasEigenvector (T : E →ₗ[𝕜] E) (↑(⨆ x : { x : E // x ≠ 0 }, T.rayleighQuotient x)) x₀ := by\n  convert hT.hasEigenvector_of_isLocalExtrOn hx₀ (Or.inr hextr.localize)\n  have hx₀' : 0 < ‖x₀‖ := by simp [hx₀]\n  have hx₀'' : x₀ ∈ sphere (0 : E) ‖x₀‖ := by simp\n  rw [T.iSup_rayleigh_eq_iSup_rayleigh_sphere hx₀']\n  refine IsMaxOn.iSup_eq hx₀'' ?_\n  intro x hx\n  dsimp\n  have : ‖x‖ = ‖x₀‖ := by simpa using hx\n  simp only [ContinuousLinearMap.rayleighQuotient]\n  rw [this]\n  gcongr\n  exact hextr hx\n\n"}
{"name":"IsSelfAdjoint.hasEigenvector_of_isMinOn","module":"Mathlib.Analysis.InnerProductSpace.Rayleigh","initialProofState":"𝕜 : Type u_1\ninst✝³ : RCLike 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : CompleteSpace E\nT : ContinuousLinearMap (RingHom.id 𝕜) E E\nhT : IsSelfAdjoint T\nx₀ : E\nhx₀ : Ne x₀ 0\nhextr : IsMinOn T.reApplyInnerSelf (Metric.sphere 0 (Norm.norm x₀)) x₀\n⊢ Module.End.HasEigenvector (↑T) (↑(iInf fun x => T.rayleighQuotient ↑x)) x₀","decl":"/-- For a self-adjoint operator `T`, a minimum of the Rayleigh quotient of `T` on a sphere centred\nat the origin is an eigenvector of `T`, with eigenvalue the global infimum of the Rayleigh\nquotient. -/\ntheorem hasEigenvector_of_isMinOn (hT : IsSelfAdjoint T) {x₀ : E} (hx₀ : x₀ ≠ 0)\n    (hextr : IsMinOn T.reApplyInnerSelf (sphere (0 : E) ‖x₀‖) x₀) :\n    HasEigenvector (T : E →ₗ[𝕜] E) (↑(⨅ x : { x : E // x ≠ 0 }, T.rayleighQuotient x)) x₀ := by\n  convert hT.hasEigenvector_of_isLocalExtrOn hx₀ (Or.inl hextr.localize)\n  have hx₀' : 0 < ‖x₀‖ := by simp [hx₀]\n  have hx₀'' : x₀ ∈ sphere (0 : E) ‖x₀‖ := by simp\n  rw [T.iInf_rayleigh_eq_iInf_rayleigh_sphere hx₀']\n  refine IsMinOn.iInf_eq hx₀'' ?_\n  intro x hx\n  dsimp\n  have : ‖x‖ = ‖x₀‖ := by simpa using hx\n  simp only [ContinuousLinearMap.rayleighQuotient]\n  rw [this]\n  gcongr\n  exact hextr hx\n\n"}
{"name":"LinearMap.IsSymmetric.hasEigenvalue_iSup_of_finiteDimensional","module":"Mathlib.Analysis.InnerProductSpace.Rayleigh","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : RCLike 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : InnerProductSpace 𝕜 E\ninst✝¹ : FiniteDimensional 𝕜 E\nT : LinearMap (RingHom.id 𝕜) E E\ninst✝ : Nontrivial E\nhT : T.IsSymmetric\n⊢ Module.End.HasEigenvalue T ↑(iSup fun x => HDiv.hDiv (RCLike.re (Inner.inner (T ↑x) ↑x)) (HPow.hPow (Norm.norm ↑x) 2))","decl":"/-- The supremum of the Rayleigh quotient of a symmetric operator `T` on a nontrivial\nfinite-dimensional vector space is an eigenvalue for that operator. -/\ntheorem hasEigenvalue_iSup_of_finiteDimensional [Nontrivial E] (hT : T.IsSymmetric) :\n    HasEigenvalue T ↑(⨆ x : { x : E // x ≠ 0 }, RCLike.re ⟪T x, x⟫ / ‖(x : E)‖ ^ 2 : ℝ) := by\n  haveI := FiniteDimensional.proper_rclike 𝕜 E\n  let T' := hT.toSelfAdjoint\n  obtain ⟨x, hx⟩ : ∃ x : E, x ≠ 0 := exists_ne 0\n  have H₁ : IsCompact (sphere (0 : E) ‖x‖) := isCompact_sphere _ _\n  have H₂ : (sphere (0 : E) ‖x‖).Nonempty := ⟨x, by simp⟩\n  -- key point: in finite dimension, a continuous function on the sphere has a max\n  obtain ⟨x₀, hx₀', hTx₀⟩ :=\n    H₁.exists_isMaxOn H₂ T'.val.reApplyInnerSelf_continuous.continuousOn\n  have hx₀ : ‖x₀‖ = ‖x‖ := by simpa using hx₀'\n  have : IsMaxOn T'.val.reApplyInnerSelf (sphere 0 ‖x₀‖) x₀ := by simpa only [← hx₀] using hTx₀\n  have hx₀_ne : x₀ ≠ 0 := by\n    have : ‖x₀‖ ≠ 0 := by simp only [hx₀, norm_eq_zero, hx, Ne, not_false_iff]\n    simpa [← norm_eq_zero, Ne]\n  exact hasEigenvalue_of_hasEigenvector (T'.prop.hasEigenvector_of_isMaxOn hx₀_ne this)\n\n"}
{"name":"LinearMap.IsSymmetric.hasEigenvalue_iInf_of_finiteDimensional","module":"Mathlib.Analysis.InnerProductSpace.Rayleigh","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : RCLike 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : InnerProductSpace 𝕜 E\ninst✝¹ : FiniteDimensional 𝕜 E\nT : LinearMap (RingHom.id 𝕜) E E\ninst✝ : Nontrivial E\nhT : T.IsSymmetric\n⊢ Module.End.HasEigenvalue T ↑(iInf fun x => HDiv.hDiv (RCLike.re (Inner.inner (T ↑x) ↑x)) (HPow.hPow (Norm.norm ↑x) 2))","decl":"/-- The infimum of the Rayleigh quotient of a symmetric operator `T` on a nontrivial\nfinite-dimensional vector space is an eigenvalue for that operator. -/\ntheorem hasEigenvalue_iInf_of_finiteDimensional [Nontrivial E] (hT : T.IsSymmetric) :\n    HasEigenvalue T ↑(⨅ x : { x : E // x ≠ 0 }, RCLike.re ⟪T x, x⟫ / ‖(x : E)‖ ^ 2 : ℝ) := by\n  haveI := FiniteDimensional.proper_rclike 𝕜 E\n  let T' := hT.toSelfAdjoint\n  obtain ⟨x, hx⟩ : ∃ x : E, x ≠ 0 := exists_ne 0\n  have H₁ : IsCompact (sphere (0 : E) ‖x‖) := isCompact_sphere _ _\n  have H₂ : (sphere (0 : E) ‖x‖).Nonempty := ⟨x, by simp⟩\n  -- key point: in finite dimension, a continuous function on the sphere has a min\n  obtain ⟨x₀, hx₀', hTx₀⟩ :=\n    H₁.exists_isMinOn H₂ T'.val.reApplyInnerSelf_continuous.continuousOn\n  have hx₀ : ‖x₀‖ = ‖x‖ := by simpa using hx₀'\n  have : IsMinOn T'.val.reApplyInnerSelf (sphere 0 ‖x₀‖) x₀ := by simpa only [← hx₀] using hTx₀\n  have hx₀_ne : x₀ ≠ 0 := by\n    have : ‖x₀‖ ≠ 0 := by simp only [hx₀, norm_eq_zero, hx, Ne, not_false_iff]\n    simpa [← norm_eq_zero, Ne]\n  exact hasEigenvalue_of_hasEigenvector (T'.prop.hasEigenvector_of_isMinOn hx₀_ne this)\n\n"}
{"name":"LinearMap.IsSymmetric.subsingleton_of_no_eigenvalue_finiteDimensional","module":"Mathlib.Analysis.InnerProductSpace.Rayleigh","initialProofState":"𝕜 : Type u_1\ninst✝³ : RCLike 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : FiniteDimensional 𝕜 E\nT : LinearMap (RingHom.id 𝕜) E E\nhT : T.IsSymmetric\nhT' : ∀ (μ : 𝕜), Eq (Module.End.eigenspace T μ) Bot.bot\n⊢ Subsingleton E","decl":"theorem subsingleton_of_no_eigenvalue_finiteDimensional (hT : T.IsSymmetric)\n    (hT' : ∀ μ : 𝕜, Module.End.eigenspace (T : E →ₗ[𝕜] E) μ = ⊥) : Subsingleton E :=\n  (subsingleton_or_nontrivial E).resolve_right fun _h =>\n    absurd (hT' _) hT.hasEigenvalue_iSup_of_finiteDimensional\n\n"}
