{"name":"ContinuousLinearMap.rayleigh_smul","module":"Mathlib.Analysis.InnerProductSpace.Rayleigh","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : RCLike ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nT : ContinuousLinearMap (RingHom.id ğ•œ) E E\nx : E\nc : ğ•œ\nhc : Ne c 0\nâŠ¢ Eq (T.rayleighQuotient (HSMul.hSMul c x)) (T.rayleighQuotient x)","decl":"theorem rayleigh_smul (x : E) {c : ğ•œ} (hc : c â‰  0) :\n    rayleighQuotient T (c â€¢ x) = rayleighQuotient T x := by\n  by_cases hx : x = 0\n  Â· simp [hx]\n  field_simp [norm_smul, T.reApplyInnerSelf_smul]\n  ring\n\n"}
{"name":"ContinuousLinearMap.image_rayleigh_eq_image_rayleigh_sphere","module":"Mathlib.Analysis.InnerProductSpace.Rayleigh","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : RCLike ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nT : ContinuousLinearMap (RingHom.id ğ•œ) E E\nr : Real\nhr : LT.lt 0 r\nâŠ¢ Eq (Set.image T.rayleighQuotient (HasCompl.compl (Singleton.singleton 0))) (Set.image T.rayleighQuotient (Metric.sphere 0 r))","decl":"theorem image_rayleigh_eq_image_rayleigh_sphere {r : â„} (hr : 0 < r) :\n    rayleighQuotient T '' {0}á¶œ = rayleighQuotient T '' sphere 0 r := by\n  ext a\n  constructor\n  Â· rintro âŸ¨x, hx : x â‰  0, hxTâŸ©\n    have : â€–xâ€– â‰  0 := by simp [hx]\n    let c : ğ•œ := â†‘â€–xâ€–â»Â¹ * r\n    have : c â‰  0 := by simp [c, hx, hr.ne']\n    refine âŸ¨c â€¢ x, ?_, ?_âŸ©\n    Â· field_simp [c, norm_smul, abs_of_pos hr]\n    Â· rw [T.rayleigh_smul x this]\n      exact hxT\n  Â· rintro âŸ¨x, hx, hxTâŸ©\n    exact âŸ¨x, ne_zero_of_mem_sphere hr.ne' âŸ¨x, hxâŸ©, hxTâŸ©\n\n"}
{"name":"ContinuousLinearMap.iSup_rayleigh_eq_iSup_rayleigh_sphere","module":"Mathlib.Analysis.InnerProductSpace.Rayleigh","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : RCLike ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nT : ContinuousLinearMap (RingHom.id ğ•œ) E E\nr : Real\nhr : LT.lt 0 r\nâŠ¢ Eq (iSup fun x => T.rayleighQuotient â†‘x) (iSup fun x => T.rayleighQuotient â†‘x)","decl":"theorem iSup_rayleigh_eq_iSup_rayleigh_sphere {r : â„} (hr : 0 < r) :\n    â¨† x : { x : E // x â‰  0 }, rayleighQuotient T x =\n      â¨† x : sphere (0 : E) r, rayleighQuotient T x :=\n  show â¨† x : ({0}á¶œ : Set E), rayleighQuotient T x = _ by\n    simp only [â† @sSup_image' _ _ _ _ (rayleighQuotient T),\n      T.image_rayleigh_eq_image_rayleigh_sphere hr]\n\n"}
{"name":"ContinuousLinearMap.iInf_rayleigh_eq_iInf_rayleigh_sphere","module":"Mathlib.Analysis.InnerProductSpace.Rayleigh","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : RCLike ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nT : ContinuousLinearMap (RingHom.id ğ•œ) E E\nr : Real\nhr : LT.lt 0 r\nâŠ¢ Eq (iInf fun x => T.rayleighQuotient â†‘x) (iInf fun x => T.rayleighQuotient â†‘x)","decl":"theorem iInf_rayleigh_eq_iInf_rayleigh_sphere {r : â„} (hr : 0 < r) :\n    â¨… x : { x : E // x â‰  0 }, rayleighQuotient T x =\n      â¨… x : sphere (0 : E) r, rayleighQuotient T x :=\n  show â¨… x : ({0}á¶œ : Set E), rayleighQuotient T x = _ by\n    simp only [â† @sInf_image' _ _ _ _ (rayleighQuotient T),\n      T.image_rayleigh_eq_image_rayleigh_sphere hr]\n\n"}
{"name":"LinearMap.IsSymmetric.hasStrictFDerivAt_reApplyInnerSelf","module":"Mathlib.Analysis.InnerProductSpace.Rayleigh","initialProofState":"F : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : InnerProductSpace Real F\nT : ContinuousLinearMap (RingHom.id Real) F F\nhT : (â†‘T).IsSymmetric\nxâ‚€ : F\nâŠ¢ HasStrictFDerivAt T.reApplyInnerSelf (HSMul.hSMul 2 ((innerSL Real) (T xâ‚€))) xâ‚€","decl":"theorem _root_.LinearMap.IsSymmetric.hasStrictFDerivAt_reApplyInnerSelf {T : F â†’L[â„] F}\n    (hT : (T : F â†’â‚—[â„] F).IsSymmetric) (xâ‚€ : F) :\n    HasStrictFDerivAt T.reApplyInnerSelf (2 â€¢ (innerSL â„ (T xâ‚€))) xâ‚€ := by\n  convert T.hasStrictFDerivAt.inner â„ (hasStrictFDerivAt_id xâ‚€) using 1\n  ext y\n  rw [ContinuousLinearMap.smul_apply, ContinuousLinearMap.comp_apply, fderivInnerCLM_apply,\n    ContinuousLinearMap.prod_apply, innerSL_apply, id, ContinuousLinearMap.id_apply,\n    hT.apply_clm xâ‚€ y, real_inner_comm _ xâ‚€, two_smul]\n\n"}
{"name":"IsSelfAdjoint.linearly_dependent_of_isLocalExtrOn","module":"Mathlib.Analysis.InnerProductSpace.Rayleigh","initialProofState":"F : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : InnerProductSpace Real F\ninstâœ : CompleteSpace F\nT : ContinuousLinearMap (RingHom.id Real) F F\nhT : IsSelfAdjoint T\nxâ‚€ : F\nhextr : IsLocalExtrOn T.reApplyInnerSelf (Metric.sphere 0 (Norm.norm xâ‚€)) xâ‚€\nâŠ¢ Exists fun a => Exists fun b => And (Ne { fst := a, snd := b } 0) (Eq (HAdd.hAdd (HSMul.hSMul a xâ‚€) (HSMul.hSMul b (T xâ‚€))) 0)","decl":"theorem linearly_dependent_of_isLocalExtrOn (hT : IsSelfAdjoint T) {xâ‚€ : F}\n    (hextr : IsLocalExtrOn T.reApplyInnerSelf (sphere (0 : F) â€–xâ‚€â€–) xâ‚€) :\n    âˆƒ a b : â„, (a, b) â‰  0 âˆ§ a â€¢ xâ‚€ + b â€¢ T xâ‚€ = 0 := by\n  have H : IsLocalExtrOn T.reApplyInnerSelf {x : F | â€–xâ€– ^ 2 = â€–xâ‚€â€– ^ 2} xâ‚€ := by\n    convert hextr\n    ext x\n    simp [dist_eq_norm]\n  -- find Lagrange multipliers for the function `T.re_apply_inner_self` and the\n  -- hypersurface-defining function `fun x â†¦ â€–xâ€– ^ 2`\n  obtain âŸ¨a, b, hâ‚, hâ‚‚âŸ© :=\n    IsLocalExtrOn.exists_multipliers_of_hasStrictFDerivAt_1d H (hasStrictFDerivAt_norm_sq xâ‚€)\n      (hT.isSymmetric.hasStrictFDerivAt_reApplyInnerSelf xâ‚€)\n  refine âŸ¨a, b, hâ‚, ?_âŸ©\n  apply (InnerProductSpace.toDualMap â„ F).injective\n  simp only [LinearIsometry.map_add, LinearIsometry.map_smul, LinearIsometry.map_zero]\n  -- Note: https://github.com/leanprover-community/mathlib4/pull/8386 changed `map_smulâ‚›â‚—` into `map_smulâ‚›â‚— _`\n  simp only [map_smulâ‚›â‚— _, RCLike.conj_to_real]\n  change a â€¢ innerSL â„ xâ‚€ + b â€¢ innerSL â„ (T xâ‚€) = 0\n  apply smul_right_injective (F â†’L[â„] â„) (two_ne_zero : (2 : â„) â‰  0)\n  simpa only [two_smul, smul_add, add_smul, add_zero] using hâ‚‚\n\n"}
{"name":"IsSelfAdjoint.eq_smul_self_of_isLocalExtrOn_real","module":"Mathlib.Analysis.InnerProductSpace.Rayleigh","initialProofState":"F : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : InnerProductSpace Real F\ninstâœ : CompleteSpace F\nT : ContinuousLinearMap (RingHom.id Real) F F\nhT : IsSelfAdjoint T\nxâ‚€ : F\nhextr : IsLocalExtrOn T.reApplyInnerSelf (Metric.sphere 0 (Norm.norm xâ‚€)) xâ‚€\nâŠ¢ Eq (T xâ‚€) (HSMul.hSMul (T.rayleighQuotient xâ‚€) xâ‚€)","decl":"open scoped InnerProductSpace in\ntheorem eq_smul_self_of_isLocalExtrOn_real (hT : IsSelfAdjoint T) {xâ‚€ : F}\n    (hextr : IsLocalExtrOn T.reApplyInnerSelf (sphere (0 : F) â€–xâ‚€â€–) xâ‚€) :\n    T xâ‚€ = T.rayleighQuotient xâ‚€ â€¢ xâ‚€ := by\n  obtain âŸ¨a, b, hâ‚, hâ‚‚âŸ© := hT.linearly_dependent_of_isLocalExtrOn hextr\n  by_cases hxâ‚€ : xâ‚€ = 0\n  Â· simp [hxâ‚€]\n  by_cases hb : b = 0\n  Â· have : a â‰  0 := by simpa [hb] using hâ‚\n    refine absurd ?_ hxâ‚€\n    apply smul_right_injective F this\n    simpa [hb] using hâ‚‚\n  let c : â„ := -bâ»Â¹ * a\n  have hc : T xâ‚€ = c â€¢ xâ‚€ := by\n    have : b * (bâ»Â¹ * a) = a := by field_simp [mul_comm]\n    apply smul_right_injective F hb\n    simp [c, eq_neg_of_add_eq_zero_left hâ‚‚, â† mul_smul, this]\n  convert hc\n  have := congr_arg (fun x => âŸªx, xâ‚€âŸ«_â„) hc\n  field_simp [inner_smul_left, real_inner_self_eq_norm_mul_norm, sq] at this âŠ¢\n  exact this\n\n"}
{"name":"IsSelfAdjoint.eq_smul_self_of_isLocalExtrOn","module":"Mathlib.Analysis.InnerProductSpace.Rayleigh","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : RCLike ğ•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : CompleteSpace E\nT : ContinuousLinearMap (RingHom.id ğ•œ) E E\nhT : IsSelfAdjoint T\nxâ‚€ : E\nhextr : IsLocalExtrOn T.reApplyInnerSelf (Metric.sphere 0 (Norm.norm xâ‚€)) xâ‚€\nâŠ¢ Eq (T xâ‚€) (HSMul.hSMul (â†‘(T.rayleighQuotient xâ‚€)) xâ‚€)","decl":"theorem eq_smul_self_of_isLocalExtrOn (hT : IsSelfAdjoint T) {xâ‚€ : E}\n    (hextr : IsLocalExtrOn T.reApplyInnerSelf (sphere (0 : E) â€–xâ‚€â€–) xâ‚€) :\n    T xâ‚€ = (â†‘(T.rayleighQuotient xâ‚€) : ğ•œ) â€¢ xâ‚€ := by\n  letI := InnerProductSpace.rclikeToReal ğ•œ E\n  let hSA := hT.isSymmetric.restrictScalars.toSelfAdjoint.prop\n  exact hSA.eq_smul_self_of_isLocalExtrOn_real hextr\n\n"}
{"name":"IsSelfAdjoint.hasEigenvector_of_isLocalExtrOn","module":"Mathlib.Analysis.InnerProductSpace.Rayleigh","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : RCLike ğ•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : CompleteSpace E\nT : ContinuousLinearMap (RingHom.id ğ•œ) E E\nhT : IsSelfAdjoint T\nxâ‚€ : E\nhxâ‚€ : Ne xâ‚€ 0\nhextr : IsLocalExtrOn T.reApplyInnerSelf (Metric.sphere 0 (Norm.norm xâ‚€)) xâ‚€\nâŠ¢ Module.End.HasEigenvector (â†‘T) (â†‘(T.rayleighQuotient xâ‚€)) xâ‚€","decl":"/-- For a self-adjoint operator `T`, a local extremum of the Rayleigh quotient of `T` on a sphere\ncentred at the origin is an eigenvector of `T`. -/\ntheorem hasEigenvector_of_isLocalExtrOn (hT : IsSelfAdjoint T) {xâ‚€ : E} (hxâ‚€ : xâ‚€ â‰  0)\n    (hextr : IsLocalExtrOn T.reApplyInnerSelf (sphere (0 : E) â€–xâ‚€â€–) xâ‚€) :\n    HasEigenvector (T : E â†’â‚—[ğ•œ] E) (â†‘(T.rayleighQuotient xâ‚€)) xâ‚€ := by\n  refine âŸ¨?_, hxâ‚€âŸ©\n  rw [Module.End.mem_eigenspace_iff]\n  exact hT.eq_smul_self_of_isLocalExtrOn hextr\n\n"}
{"name":"IsSelfAdjoint.hasEigenvector_of_isMaxOn","module":"Mathlib.Analysis.InnerProductSpace.Rayleigh","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : RCLike ğ•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : CompleteSpace E\nT : ContinuousLinearMap (RingHom.id ğ•œ) E E\nhT : IsSelfAdjoint T\nxâ‚€ : E\nhxâ‚€ : Ne xâ‚€ 0\nhextr : IsMaxOn T.reApplyInnerSelf (Metric.sphere 0 (Norm.norm xâ‚€)) xâ‚€\nâŠ¢ Module.End.HasEigenvector (â†‘T) (â†‘(iSup fun x => T.rayleighQuotient â†‘x)) xâ‚€","decl":"/-- For a self-adjoint operator `T`, a maximum of the Rayleigh quotient of `T` on a sphere centred\nat the origin is an eigenvector of `T`, with eigenvalue the global supremum of the Rayleigh\nquotient. -/\ntheorem hasEigenvector_of_isMaxOn (hT : IsSelfAdjoint T) {xâ‚€ : E} (hxâ‚€ : xâ‚€ â‰  0)\n    (hextr : IsMaxOn T.reApplyInnerSelf (sphere (0 : E) â€–xâ‚€â€–) xâ‚€) :\n    HasEigenvector (T : E â†’â‚—[ğ•œ] E) (â†‘(â¨† x : { x : E // x â‰  0 }, T.rayleighQuotient x)) xâ‚€ := by\n  convert hT.hasEigenvector_of_isLocalExtrOn hxâ‚€ (Or.inr hextr.localize)\n  have hxâ‚€' : 0 < â€–xâ‚€â€– := by simp [hxâ‚€]\n  have hxâ‚€'' : xâ‚€ âˆˆ sphere (0 : E) â€–xâ‚€â€– := by simp\n  rw [T.iSup_rayleigh_eq_iSup_rayleigh_sphere hxâ‚€']\n  refine IsMaxOn.iSup_eq hxâ‚€'' ?_\n  intro x hx\n  dsimp\n  have : â€–xâ€– = â€–xâ‚€â€– := by simpa using hx\n  simp only [ContinuousLinearMap.rayleighQuotient]\n  rw [this]\n  gcongr\n  exact hextr hx\n\n"}
{"name":"IsSelfAdjoint.hasEigenvector_of_isMinOn","module":"Mathlib.Analysis.InnerProductSpace.Rayleigh","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : RCLike ğ•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : CompleteSpace E\nT : ContinuousLinearMap (RingHom.id ğ•œ) E E\nhT : IsSelfAdjoint T\nxâ‚€ : E\nhxâ‚€ : Ne xâ‚€ 0\nhextr : IsMinOn T.reApplyInnerSelf (Metric.sphere 0 (Norm.norm xâ‚€)) xâ‚€\nâŠ¢ Module.End.HasEigenvector (â†‘T) (â†‘(iInf fun x => T.rayleighQuotient â†‘x)) xâ‚€","decl":"/-- For a self-adjoint operator `T`, a minimum of the Rayleigh quotient of `T` on a sphere centred\nat the origin is an eigenvector of `T`, with eigenvalue the global infimum of the Rayleigh\nquotient. -/\ntheorem hasEigenvector_of_isMinOn (hT : IsSelfAdjoint T) {xâ‚€ : E} (hxâ‚€ : xâ‚€ â‰  0)\n    (hextr : IsMinOn T.reApplyInnerSelf (sphere (0 : E) â€–xâ‚€â€–) xâ‚€) :\n    HasEigenvector (T : E â†’â‚—[ğ•œ] E) (â†‘(â¨… x : { x : E // x â‰  0 }, T.rayleighQuotient x)) xâ‚€ := by\n  convert hT.hasEigenvector_of_isLocalExtrOn hxâ‚€ (Or.inl hextr.localize)\n  have hxâ‚€' : 0 < â€–xâ‚€â€– := by simp [hxâ‚€]\n  have hxâ‚€'' : xâ‚€ âˆˆ sphere (0 : E) â€–xâ‚€â€– := by simp\n  rw [T.iInf_rayleigh_eq_iInf_rayleigh_sphere hxâ‚€']\n  refine IsMinOn.iInf_eq hxâ‚€'' ?_\n  intro x hx\n  dsimp\n  have : â€–xâ€– = â€–xâ‚€â€– := by simpa using hx\n  simp only [ContinuousLinearMap.rayleighQuotient]\n  rw [this]\n  gcongr\n  exact hextr hx\n\n"}
{"name":"LinearMap.IsSymmetric.hasEigenvalue_iSup_of_finiteDimensional","module":"Mathlib.Analysis.InnerProductSpace.Rayleigh","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : RCLike ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\ninstâœÂ¹ : FiniteDimensional ğ•œ E\nT : LinearMap (RingHom.id ğ•œ) E E\ninstâœ : Nontrivial E\nhT : T.IsSymmetric\nâŠ¢ Module.End.HasEigenvalue T â†‘(iSup fun x => HDiv.hDiv (RCLike.re (Inner.inner (T â†‘x) â†‘x)) (HPow.hPow (Norm.norm â†‘x) 2))","decl":"/-- The supremum of the Rayleigh quotient of a symmetric operator `T` on a nontrivial\nfinite-dimensional vector space is an eigenvalue for that operator. -/\ntheorem hasEigenvalue_iSup_of_finiteDimensional [Nontrivial E] (hT : T.IsSymmetric) :\n    HasEigenvalue T â†‘(â¨† x : { x : E // x â‰  0 }, RCLike.re âŸªT x, xâŸ« / â€–(x : E)â€– ^ 2 : â„) := by\n  haveI := FiniteDimensional.proper_rclike ğ•œ E\n  let T' := hT.toSelfAdjoint\n  obtain âŸ¨x, hxâŸ© : âˆƒ x : E, x â‰  0 := exists_ne 0\n  have Hâ‚ : IsCompact (sphere (0 : E) â€–xâ€–) := isCompact_sphere _ _\n  have Hâ‚‚ : (sphere (0 : E) â€–xâ€–).Nonempty := âŸ¨x, by simpâŸ©\n  -- key point: in finite dimension, a continuous function on the sphere has a max\n  obtain âŸ¨xâ‚€, hxâ‚€', hTxâ‚€âŸ© :=\n    Hâ‚.exists_isMaxOn Hâ‚‚ T'.val.reApplyInnerSelf_continuous.continuousOn\n  have hxâ‚€ : â€–xâ‚€â€– = â€–xâ€– := by simpa using hxâ‚€'\n  have : IsMaxOn T'.val.reApplyInnerSelf (sphere 0 â€–xâ‚€â€–) xâ‚€ := by simpa only [â† hxâ‚€] using hTxâ‚€\n  have hxâ‚€_ne : xâ‚€ â‰  0 := by\n    have : â€–xâ‚€â€– â‰  0 := by simp only [hxâ‚€, norm_eq_zero, hx, Ne, not_false_iff]\n    simpa [â† norm_eq_zero, Ne]\n  exact hasEigenvalue_of_hasEigenvector (T'.prop.hasEigenvector_of_isMaxOn hxâ‚€_ne this)\n\n"}
{"name":"LinearMap.IsSymmetric.hasEigenvalue_iInf_of_finiteDimensional","module":"Mathlib.Analysis.InnerProductSpace.Rayleigh","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : RCLike ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\ninstâœÂ¹ : FiniteDimensional ğ•œ E\nT : LinearMap (RingHom.id ğ•œ) E E\ninstâœ : Nontrivial E\nhT : T.IsSymmetric\nâŠ¢ Module.End.HasEigenvalue T â†‘(iInf fun x => HDiv.hDiv (RCLike.re (Inner.inner (T â†‘x) â†‘x)) (HPow.hPow (Norm.norm â†‘x) 2))","decl":"/-- The infimum of the Rayleigh quotient of a symmetric operator `T` on a nontrivial\nfinite-dimensional vector space is an eigenvalue for that operator. -/\ntheorem hasEigenvalue_iInf_of_finiteDimensional [Nontrivial E] (hT : T.IsSymmetric) :\n    HasEigenvalue T â†‘(â¨… x : { x : E // x â‰  0 }, RCLike.re âŸªT x, xâŸ« / â€–(x : E)â€– ^ 2 : â„) := by\n  haveI := FiniteDimensional.proper_rclike ğ•œ E\n  let T' := hT.toSelfAdjoint\n  obtain âŸ¨x, hxâŸ© : âˆƒ x : E, x â‰  0 := exists_ne 0\n  have Hâ‚ : IsCompact (sphere (0 : E) â€–xâ€–) := isCompact_sphere _ _\n  have Hâ‚‚ : (sphere (0 : E) â€–xâ€–).Nonempty := âŸ¨x, by simpâŸ©\n  -- key point: in finite dimension, a continuous function on the sphere has a min\n  obtain âŸ¨xâ‚€, hxâ‚€', hTxâ‚€âŸ© :=\n    Hâ‚.exists_isMinOn Hâ‚‚ T'.val.reApplyInnerSelf_continuous.continuousOn\n  have hxâ‚€ : â€–xâ‚€â€– = â€–xâ€– := by simpa using hxâ‚€'\n  have : IsMinOn T'.val.reApplyInnerSelf (sphere 0 â€–xâ‚€â€–) xâ‚€ := by simpa only [â† hxâ‚€] using hTxâ‚€\n  have hxâ‚€_ne : xâ‚€ â‰  0 := by\n    have : â€–xâ‚€â€– â‰  0 := by simp only [hxâ‚€, norm_eq_zero, hx, Ne, not_false_iff]\n    simpa [â† norm_eq_zero, Ne]\n  exact hasEigenvalue_of_hasEigenvector (T'.prop.hasEigenvector_of_isMinOn hxâ‚€_ne this)\n\n"}
{"name":"LinearMap.IsSymmetric.subsingleton_of_no_eigenvalue_finiteDimensional","module":"Mathlib.Analysis.InnerProductSpace.Rayleigh","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : RCLike ğ•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : FiniteDimensional ğ•œ E\nT : LinearMap (RingHom.id ğ•œ) E E\nhT : T.IsSymmetric\nhT' : âˆ€ (Î¼ : ğ•œ), Eq (Module.End.eigenspace T Î¼) Bot.bot\nâŠ¢ Subsingleton E","decl":"theorem subsingleton_of_no_eigenvalue_finiteDimensional (hT : T.IsSymmetric)\n    (hT' : âˆ€ Î¼ : ğ•œ, Module.End.eigenspace (T : E â†’â‚—[ğ•œ] E) Î¼ = âŠ¥) : Subsingleton E :=\n  (subsingleton_or_nontrivial E).resolve_right fun _h =>\n    absurd (hT' _) hT.hasEigenvalue_iSup_of_finiteDimensional\n\n"}
