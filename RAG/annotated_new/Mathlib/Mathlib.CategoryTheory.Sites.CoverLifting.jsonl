{"name":"CategoryTheory.Functor.IsCocontinuous.cover_lift","module":"Mathlib.CategoryTheory.Sites.CoverLifting","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_1} C\nD : Type u_2\ninst‚úù : CategoryTheory.Category.{u_5, u_2} D\nG : CategoryTheory.Functor C D\nJ : CategoryTheory.GrothendieckTopology C\nK : CategoryTheory.GrothendieckTopology D\nself : G.IsCocontinuous J K\nU : C\nS : CategoryTheory.Sieve (G.obj U)\nx‚úù : Membership.mem (K (G.obj U)) S\n‚ä¢ Membership.mem (J U) (CategoryTheory.Sieve.functorPullback G S)","decl":"/-- A functor `G : (C, J) ‚•§ (D, K)` between sites is called cocontinuous (SGA 4 III 2.1)\nif for all covering sieves `R` in `D`, `R.pullback G` is a covering sieve in `C`.\n-/\nclass Functor.IsCocontinuous : Prop where\n  cover_lift : ‚àÄ {U : C} {S : Sieve (G.obj U)} (_ : S ‚àà K (G.obj U)), S.functorPullback G ‚àà J U\n\n"}
{"name":"CategoryTheory.Functor.cover_lift","module":"Mathlib.CategoryTheory.Sites.CoverLifting","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} C\nD : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_2} D\nG : CategoryTheory.Functor C D\nJ : CategoryTheory.GrothendieckTopology C\nK : CategoryTheory.GrothendieckTopology D\ninst‚úù : G.IsCocontinuous J K\nU : C\nS : CategoryTheory.Sieve (G.obj U)\nhS : Membership.mem (K (G.obj U)) S\n‚ä¢ Membership.mem (J U) (CategoryTheory.Sieve.functorPullback G S)","decl":"lemma Functor.cover_lift [G.IsCocontinuous J K] {U : C} {S : Sieve (G.obj U)}\n    (hS : S ‚àà K (G.obj U)) : S.functorPullback G ‚àà J U :=\n  IsCocontinuous.cover_lift hS\n\n"}
{"name":"CategoryTheory.isCocontinuous_id","module":"Mathlib.CategoryTheory.Sites.CoverLifting","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_4, u_1} C\nJ : CategoryTheory.GrothendieckTopology C\n‚ä¢ (CategoryTheory.Functor.id C).IsCocontinuous J J","decl":"/-- The identity functor on a site is cocontinuous. -/\ninstance isCocontinuous_id : Functor.IsCocontinuous (ùü≠ C) J J :=\n  ‚ü®fun h => by simpa using h‚ü©\n\n"}
{"name":"CategoryTheory.isCocontinuous_comp","module":"Mathlib.CategoryTheory.Sites.CoverLifting","initialProofState":"C : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} C\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_2} D\nE : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_3} E\nG : CategoryTheory.Functor C D\nG' : CategoryTheory.Functor D E\nJ : CategoryTheory.GrothendieckTopology C\nK : CategoryTheory.GrothendieckTopology D\nL : CategoryTheory.GrothendieckTopology E\ninst‚úù¬π : G.IsCocontinuous J K\ninst‚úù : G'.IsCocontinuous K L\n‚ä¢ (G.comp G').IsCocontinuous J L","decl":"/-- The composition of two cocontinuous functors is cocontinuous. -/\ntheorem isCocontinuous_comp [G.IsCocontinuous J K] [G'.IsCocontinuous K L] :\n    (G ‚ãô G').IsCocontinuous J L where\n  cover_lift h := G.cover_lift J K (G'.cover_lift K L h)\n\n"}
{"name":"CategoryTheory.RanIsSheafOfIsCocontinuous.liftAux_map","module":"Mathlib.CategoryTheory.Sites.CoverLifting","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_2} D\nG : CategoryTheory.Functor C D\nA : Type w\ninst‚úù¬π : CategoryTheory.Category.{w', w} A\nJ : CategoryTheory.GrothendieckTopology C\nK : CategoryTheory.GrothendieckTopology D\ninst‚úù : G.IsCocontinuous J K\nF : CategoryTheory.Functor (Opposite C) A\nhF : CategoryTheory.Presheaf.IsSheaf J F\nR : CategoryTheory.Functor (Opposite D) A\nŒ± : Quiver.Hom (G.op.comp R) F\nX : D\nS : K.Cover X\ns : CategoryTheory.Limits.Multifork (S.index R)\nY : C\nf : Quiver.Hom (G.obj Y) X\nW : C\ng : Quiver.Hom W Y\ni : S.Arrow\nh : Quiver.Hom (G.obj W) i.Y\nw : Eq (CategoryTheory.CategoryStruct.comp h i.f) (CategoryTheory.CategoryStruct.comp (G.map g) f)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.RanIsSheafOfIsCocontinuous.liftAux hF Œ± s f) (F.map g.op)) (CategoryTheory.CategoryStruct.comp (s.Œπ i) (CategoryTheory.CategoryStruct.comp (R.map h.op) (Œ±.app { unop := W })))","decl":"lemma liftAux_map {Y : C} (f : G.obj Y ‚ü∂ X) {W : C} (g : W ‚ü∂ Y) (i : S.Arrow)\n    (h : G.obj W ‚ü∂ i.Y) (w : h ‚â´ i.f = G.map g ‚â´ f) :\n    liftAux hF Œ± s f ‚â´ F.map g.op = s.Œπ i ‚â´ R.map h.op ‚â´ Œ±.app _ :=\n  (Multifork.IsLimit.fac\n    (hF.isLimitMultifork ‚ü®_, G.cover_lift J K (K.pullback_stable f S.2)‚ü©) _ _\n      ‚ü®W, g, by simpa only [Sieve.functorPullback_apply, functorPullback_mem,\n        Sieve.pullback_apply, ‚Üê w] using S.1.downward_closed i.hf h‚ü©).trans (by\n        dsimp\n        simp only [‚Üê Category.assoc]\n        congr 1\n        let r : S.Relation :=\n          GrothendieckTopology.Cover.Relation.mk\n            { f := G.map g ‚â´ f\n              hf := by simpa only [‚Üê w] using S.1.downward_closed i.hf h } i\n            { g‚ÇÅ := ùüô _\n              g‚ÇÇ := h\n              w := by simpa using w.symm }\n        simpa [r] using s.condition r )\n\n"}
{"name":"CategoryTheory.RanIsSheafOfIsCocontinuous.liftAux_map'","module":"Mathlib.CategoryTheory.Sites.CoverLifting","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_2} D\nG : CategoryTheory.Functor C D\nA : Type w\ninst‚úù¬π : CategoryTheory.Category.{w', w} A\nJ : CategoryTheory.GrothendieckTopology C\nK : CategoryTheory.GrothendieckTopology D\ninst‚úù : G.IsCocontinuous J K\nF : CategoryTheory.Functor (Opposite C) A\nhF : CategoryTheory.Presheaf.IsSheaf J F\nR : CategoryTheory.Functor (Opposite D) A\nŒ± : Quiver.Hom (G.op.comp R) F\nX : D\nS : K.Cover X\ns : CategoryTheory.Limits.Multifork (S.index R)\nY Y' : C\nf : Quiver.Hom (G.obj Y) X\nf' : Quiver.Hom (G.obj Y') X\nW : C\na : Quiver.Hom W Y\nb : Quiver.Hom W Y'\nw : Eq (CategoryTheory.CategoryStruct.comp (G.map a) f) (CategoryTheory.CategoryStruct.comp (G.map b) f')\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.RanIsSheafOfIsCocontinuous.liftAux hF Œ± s f) (F.map a.op)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.RanIsSheafOfIsCocontinuous.liftAux hF Œ± s f') (F.map b.op))","decl":"lemma liftAux_map' {Y Y' : C} (f : G.obj Y ‚ü∂ X) (f' : G.obj Y' ‚ü∂ X) {W : C}\n    (a : W ‚ü∂ Y) (b : W ‚ü∂ Y') (w : G.map a ‚â´ f = G.map b ‚â´ f') :\n    liftAux hF Œ± s f ‚â´ F.map a.op = liftAux hF Œ± s f' ‚â´ F.map b.op := by\n  apply hF.hom_ext ‚ü®_, G.cover_lift J K (K.pullback_stable (G.map a ‚â´ f) S.2)‚ü©\n  rintro ‚ü®T, g, hg‚ü©\n  dsimp\n  have eq‚ÇÅ := liftAux_map hF Œ± s f (g ‚â´ a) ‚ü®_, _, hg‚ü© (ùüô _) (by simp)\n  have eq‚ÇÇ := liftAux_map hF Œ± s f' (g ‚â´ b) ‚ü®_, _, hg‚ü© (ùüô _) (by simp [w])\n  dsimp at eq‚ÇÅ eq‚ÇÇ\n  simp only [Functor.map_comp, Functor.map_id, Category.id_comp] at eq‚ÇÅ eq‚ÇÇ\n  simp only [Category.assoc, eq‚ÇÅ, eq‚ÇÇ]\n\n"}
{"name":"CategoryTheory.RanIsSheafOfIsCocontinuous.fac'","module":"Mathlib.CategoryTheory.Sites.CoverLifting","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_2} D\nG : CategoryTheory.Functor C D\nA : Type w\ninst‚úù¬π : CategoryTheory.Category.{w', w} A\nJ : CategoryTheory.GrothendieckTopology C\nK : CategoryTheory.GrothendieckTopology D\ninst‚úù : G.IsCocontinuous J K\nF : CategoryTheory.Functor (Opposite C) A\nhF : CategoryTheory.Presheaf.IsSheaf J F\nR : CategoryTheory.Functor (Opposite D) A\nŒ± : Quiver.Hom (G.op.comp R) F\nhR : (CategoryTheory.Functor.RightExtension.mk R Œ±).IsPointwiseRightKanExtension\nX : D\nS : K.Cover X\ns : CategoryTheory.Limits.Multifork (S.index R)\nj : CategoryTheory.StructuredArrow { unop := X } G.op\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.RanIsSheafOfIsCocontinuous.lift hF hR s) (CategoryTheory.CategoryStruct.comp (R.map j.hom) (Œ±.app j.right))) (CategoryTheory.RanIsSheafOfIsCocontinuous.liftAux hF Œ± s j.hom.unop)","decl":"lemma fac' (j : StructuredArrow (op X) G.op) :\n    lift hF hR s ‚â´ R.map j.hom ‚â´ Œ±.app j.right = liftAux hF Œ± s j.hom.unop := by\n  apply IsLimit.fac\n\n"}
{"name":"CategoryTheory.RanIsSheafOfIsCocontinuous.fac","module":"Mathlib.CategoryTheory.Sites.CoverLifting","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_2} D\nG : CategoryTheory.Functor C D\nA : Type w\ninst‚úù¬π : CategoryTheory.Category.{w', w} A\nJ : CategoryTheory.GrothendieckTopology C\nK : CategoryTheory.GrothendieckTopology D\ninst‚úù : G.IsCocontinuous J K\nF : CategoryTheory.Functor (Opposite C) A\nhF : CategoryTheory.Presheaf.IsSheaf J F\nR : CategoryTheory.Functor (Opposite D) A\nŒ± : Quiver.Hom (G.op.comp R) F\nhR : (CategoryTheory.Functor.RightExtension.mk R Œ±).IsPointwiseRightKanExtension\nX : D\nS : K.Cover X\ns : CategoryTheory.Limits.Multifork (S.index R)\ni : S.Arrow\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.RanIsSheafOfIsCocontinuous.lift hF hR s) (R.map i.f.op)) (s.Œπ i)","decl":"@[reassoc (attr := simp)]\nlemma fac (i : S.Arrow) : lift hF hR s ‚â´ R.map i.f.op = s.Œπ i := by\n  apply (hR (op i.Y)).hom_ext\n  intro j\n  have eq := fac' hF hR s (StructuredArrow.mk (i.f.op ‚â´ j.hom))\n  dsimp at eq ‚ä¢\n  simp only [Functor.map_comp, Category.assoc] at eq\n  rw [Category.assoc, eq]\n  simpa using liftAux_map hF Œ± s (j.hom.unop ‚â´ i.f) (ùüô _) i j.hom.unop (by simp)\n\n"}
{"name":"CategoryTheory.RanIsSheafOfIsCocontinuous.fac_assoc","module":"Mathlib.CategoryTheory.Sites.CoverLifting","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_2} D\nG : CategoryTheory.Functor C D\nA : Type w\ninst‚úù¬π : CategoryTheory.Category.{w', w} A\nJ : CategoryTheory.GrothendieckTopology C\nK : CategoryTheory.GrothendieckTopology D\ninst‚úù : G.IsCocontinuous J K\nF : CategoryTheory.Functor (Opposite C) A\nhF : CategoryTheory.Presheaf.IsSheaf J F\nR : CategoryTheory.Functor (Opposite D) A\nŒ± : Quiver.Hom (G.op.comp R) F\nhR : (CategoryTheory.Functor.RightExtension.mk R Œ±).IsPointwiseRightKanExtension\nX : D\nS : K.Cover X\ns : CategoryTheory.Limits.Multifork (S.index R)\ni : S.Arrow\nZ : A\nh : Quiver.Hom (R.obj { unop := i.Y }) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.RanIsSheafOfIsCocontinuous.lift hF hR s) (CategoryTheory.CategoryStruct.comp (R.map i.f.op) h)) (CategoryTheory.CategoryStruct.comp (s.Œπ i) h)","decl":"@[reassoc (attr := simp)]\nlemma fac (i : S.Arrow) : lift hF hR s ‚â´ R.map i.f.op = s.Œπ i := by\n  apply (hR (op i.Y)).hom_ext\n  intro j\n  have eq := fac' hF hR s (StructuredArrow.mk (i.f.op ‚â´ j.hom))\n  dsimp at eq ‚ä¢\n  simp only [Functor.map_comp, Category.assoc] at eq\n  rw [Category.assoc, eq]\n  simpa using liftAux_map hF Œ± s (j.hom.unop ‚â´ i.f) (ùüô _) i j.hom.unop (by simp)\n\n"}
{"name":"CategoryTheory.RanIsSheafOfIsCocontinuous.hom_ext","module":"Mathlib.CategoryTheory.Sites.CoverLifting","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_2} D\nG : CategoryTheory.Functor C D\nA : Type w\ninst‚úù¬π : CategoryTheory.Category.{w', w} A\nJ : CategoryTheory.GrothendieckTopology C\nK : CategoryTheory.GrothendieckTopology D\ninst‚úù : G.IsCocontinuous J K\nF : CategoryTheory.Functor (Opposite C) A\nhF : CategoryTheory.Presheaf.IsSheaf J F\nR : CategoryTheory.Functor (Opposite D) A\nŒ± : Quiver.Hom (G.op.comp R) F\nhR : (CategoryTheory.Functor.RightExtension.mk R Œ±).IsPointwiseRightKanExtension\nX : D\nS : K.Cover X\nW : A\nf g : Quiver.Hom W (R.obj { unop := X })\nh : ‚àÄ (i : S.Arrow), Eq (CategoryTheory.CategoryStruct.comp f (R.map i.f.op)) (CategoryTheory.CategoryStruct.comp g (R.map i.f.op))\n‚ä¢ Eq f g","decl":"include hR hF in\nvariable (K) in\nlemma hom_ext {W : A} {f g : W ‚ü∂ R.obj (op X)}\n    (h : ‚àÄ (i : S.Arrow), f ‚â´ R.map i.f.op = g ‚â´ R.map i.f.op) : f = g := by\n  apply (hR (op X)).hom_ext\n  intro j\n  apply hF.hom_ext ‚ü®_, G.cover_lift J K (K.pullback_stable j.hom.unop S.2)‚ü©\n  intro ‚ü®W, i, hi‚ü©\n  have eq := h (GrothendieckTopology.Cover.Arrow.mk _ (G.map i ‚â´ j.hom.unop) hi)\n  dsimp at eq ‚ä¢\n  simp only [Category.assoc, ‚Üê NatTrans.naturality, Functor.comp_map, ‚Üê Functor.map_comp_assoc,\n    Functor.op_map, Quiver.Hom.unop_op]\n  rw [reassoc_of% eq]\n\n"}
{"name":"CategoryTheory.ran_isSheaf_of_isCocontinuous","module":"Mathlib.CategoryTheory.Sites.CoverLifting","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_2} D\nG : CategoryTheory.Functor C D\nA : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{w', w} A\nJ : CategoryTheory.GrothendieckTopology C\nK : CategoryTheory.GrothendieckTopology D\ninst‚úù¬π : G.IsCocontinuous J K\ninst‚úù : ‚àÄ (F : CategoryTheory.Functor (Opposite C) A), G.op.HasPointwiseRightKanExtension F\n‚Ñ± : CategoryTheory.Sheaf J A\n‚ä¢ CategoryTheory.Presheaf.IsSheaf K (G.op.ran.obj ‚Ñ±.val)","decl":"/-- If `G` is cocontinuous, then `G.op.ran` pushes sheaves to sheaves.\n\nThis is SGA 4 III 2.2. -/\n@[stacks 00XK \"Alternative reference. There, results are obtained under the additional assumption\nthat `C` and `D` have pullbacks.\"]\ntheorem ran_isSheaf_of_isCocontinuous (‚Ñ± : Sheaf J A) :\n    Presheaf.IsSheaf K (G.op.ran.obj ‚Ñ±.val) := by\n  rw [Presheaf.isSheaf_iff_multifork]\n  intros X S\n  exact ‚ü®RanIsSheafOfIsCocontinuous.isLimitMultifork ‚Ñ±.2\n    (G.op.isPointwiseRightKanExtensionRanCounit ‚Ñ±.val) S‚ü©\n\n"}
{"name":"CategoryTheory.Functor.sheafPushforwardCocontinuousCompSheafToPresheafIso_hom","module":"Mathlib.CategoryTheory.Sites.CoverLifting","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_2} D\nG : CategoryTheory.Functor C D\nA : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{w', w} A\nJ : CategoryTheory.GrothendieckTopology C\nK : CategoryTheory.GrothendieckTopology D\ninst‚úù¬π : G.IsCocontinuous J K\ninst‚úù : ‚àÄ (F : CategoryTheory.Functor (Opposite C) A), G.op.HasPointwiseRightKanExtension F\n‚ä¢ Eq (G.sheafPushforwardCocontinuousCompSheafToPresheafIso A J K).hom (CategoryTheory.CategoryStruct.id ((G.sheafPushforwardCocontinuous A J K).comp (CategoryTheory.sheafToPresheaf K A)))","decl":"/-- `G.sheafPushforwardCocontinuous A J K : Sheaf J A ‚•§ Sheaf K A` is induced\nby the right Kan extension functor `G.op.ran` on presheaves. -/\n@[simps! hom inv]\ndef Functor.sheafPushforwardCocontinuousCompSheafToPresheafIso :\n    G.sheafPushforwardCocontinuous A J K ‚ãô sheafToPresheaf K A ‚âÖ\n      sheafToPresheaf J A ‚ãô G.op.ran := Iso.refl _\n\n/-\n\nGiven a cocontinuous functor `G`, the precomposition with `G.op` induces a functor\non presheaves with leads to a \"pullback\" functor `Sheaf K A ‚•§ Sheaf J A` (TODO: formalize\nthis as `G.sheafPullbackCocontinuous A J K`) using the associated sheaf functor.\nIt is shown in SGA 4 III 2.3 that this pullback functor is\nleft adjoint to `G.sheafPushforwardCocontinuous A J K`. This adjunction may replace\n`Functor.sheafAdjunctionCocontinuous` below, and then, it could be shown that if\n`G` is also continuous, then we have an isomorphism\n`G.sheafPullbackCocontinuous A J K ‚âÖ G.sheafPushforwardContinuous A J K` (TODO).\n\n-/\n\n"}
{"name":"CategoryTheory.Functor.sheafPushforwardCocontinuousCompSheafToPresheafIso_inv","module":"Mathlib.CategoryTheory.Sites.CoverLifting","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_2} D\nG : CategoryTheory.Functor C D\nA : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{w', w} A\nJ : CategoryTheory.GrothendieckTopology C\nK : CategoryTheory.GrothendieckTopology D\ninst‚úù¬π : G.IsCocontinuous J K\ninst‚úù : ‚àÄ (F : CategoryTheory.Functor (Opposite C) A), G.op.HasPointwiseRightKanExtension F\n‚ä¢ Eq (G.sheafPushforwardCocontinuousCompSheafToPresheafIso A J K).inv (CategoryTheory.CategoryStruct.id ((G.sheafPushforwardCocontinuous A J K).comp (CategoryTheory.sheafToPresheaf K A)))","decl":"/-- `G.sheafPushforwardCocontinuous A J K : Sheaf J A ‚•§ Sheaf K A` is induced\nby the right Kan extension functor `G.op.ran` on presheaves. -/\n@[simps! hom inv]\ndef Functor.sheafPushforwardCocontinuousCompSheafToPresheafIso :\n    G.sheafPushforwardCocontinuous A J K ‚ãô sheafToPresheaf K A ‚âÖ\n      sheafToPresheaf J A ‚ãô G.op.ran := Iso.refl _\n\n/-\n\nGiven a cocontinuous functor `G`, the precomposition with `G.op` induces a functor\non presheaves with leads to a \"pullback\" functor `Sheaf K A ‚•§ Sheaf J A` (TODO: formalize\nthis as `G.sheafPullbackCocontinuous A J K`) using the associated sheaf functor.\nIt is shown in SGA 4 III 2.3 that this pullback functor is\nleft adjoint to `G.sheafPushforwardCocontinuous A J K`. This adjunction may replace\n`Functor.sheafAdjunctionCocontinuous` below, and then, it could be shown that if\n`G` is also continuous, then we have an isomorphism\n`G.sheafPullbackCocontinuous A J K ‚âÖ G.sheafPushforwardContinuous A J K` (TODO).\n\n-/\n\n"}
{"name":"CategoryTheory.Functor.sheafAdjunctionCocontinuous_unit_app_val","module":"Mathlib.CategoryTheory.Sites.CoverLifting","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Åµ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_3, u_2} D\nG : CategoryTheory.Functor C D\nA : Type w\ninst‚úù¬≥ : CategoryTheory.Category.{w', w} A\nJ : CategoryTheory.GrothendieckTopology C\nK : CategoryTheory.GrothendieckTopology D\ninst‚úù¬≤ : G.IsCocontinuous J K\ninst‚úù¬π : ‚àÄ (F : CategoryTheory.Functor (Opposite C) A), G.op.HasPointwiseRightKanExtension F\ninst‚úù : G.IsContinuous J K\nF : CategoryTheory.Sheaf K A\n‚ä¢ Eq ((G.sheafAdjunctionCocontinuous A J K).unit.app F).val ((G.op.ranAdjunction A).unit.app F.val)","decl":"lemma sheafAdjunctionCocontinuous_unit_app_val (F : Sheaf K A) :\n    ((G.sheafAdjunctionCocontinuous A J K).unit.app F).val =\n      (G.op.ranAdjunction A).unit.app F.val := by\n  apply ((G.op.ranAdjunction A).map_restrictFullyFaithful_unit_app\n    (fullyFaithfulSheafToPresheaf K A) (fullyFaithfulSheafToPresheaf J A)\n    (G.sheafPushforwardContinuousCompSheafToPresheafIso A J K).symm\n    (G.sheafPushforwardCocontinuousCompSheafToPresheafIso A J K).symm F).trans\n  dsimp\n  erw [Functor.map_id]\n  change _ ‚â´ ùüô _ ‚â´ ùüô _ = _\n  simp only [Category.comp_id]\n\n"}
{"name":"CategoryTheory.Functor.sheafAdjunctionCocontinuous_counit_app_val","module":"Mathlib.CategoryTheory.Sites.CoverLifting","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Åµ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_2} D\nG : CategoryTheory.Functor C D\nA : Type w\ninst‚úù¬≥ : CategoryTheory.Category.{w', w} A\nJ : CategoryTheory.GrothendieckTopology C\nK : CategoryTheory.GrothendieckTopology D\ninst‚úù¬≤ : G.IsCocontinuous J K\ninst‚úù¬π : ‚àÄ (F : CategoryTheory.Functor (Opposite C) A), G.op.HasPointwiseRightKanExtension F\ninst‚úù : G.IsContinuous J K\nF : CategoryTheory.Sheaf J A\n‚ä¢ Eq ((G.sheafAdjunctionCocontinuous A J K).counit.app F).val ((G.op.ranAdjunction A).counit.app F.val)","decl":"lemma sheafAdjunctionCocontinuous_counit_app_val (F : Sheaf J A) :\n    ((G.sheafAdjunctionCocontinuous A J K).counit.app F).val =\n      (G.op.ranAdjunction A).counit.app F.val :=\n  ((G.op.ranAdjunction A).map_restrictFullyFaithful_counit_app\n    (fullyFaithfulSheafToPresheaf K A) (fullyFaithfulSheafToPresheaf J A)\n    (G.sheafPushforwardContinuousCompSheafToPresheafIso A J K).symm\n    (G.sheafPushforwardCocontinuousCompSheafToPresheafIso A J K).symm F).trans\n      (by aesop_cat)\n\n"}
{"name":"CategoryTheory.Functor.sheafAdjunctionCocontinuous_homEquiv_apply_val","module":"Mathlib.CategoryTheory.Sites.CoverLifting","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Åµ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_3, u_2} D\nG : CategoryTheory.Functor C D\nA : Type w\ninst‚úù¬≥ : CategoryTheory.Category.{w', w} A\nJ : CategoryTheory.GrothendieckTopology C\nK : CategoryTheory.GrothendieckTopology D\ninst‚úù¬≤ : G.IsCocontinuous J K\ninst‚úù¬π : ‚àÄ (F : CategoryTheory.Functor (Opposite C) A), G.op.HasPointwiseRightKanExtension F\ninst‚úù : G.IsContinuous J K\nF : CategoryTheory.Sheaf K A\nH : CategoryTheory.Sheaf J A\nf : Quiver.Hom ((G.sheafPushforwardContinuous A J K).obj F) H\n‚ä¢ Eq (((G.sheafAdjunctionCocontinuous A J K).homEquiv F H) f).val (((G.op.ranAdjunction A).homEquiv F.val H.val) f.val)","decl":"lemma sheafAdjunctionCocontinuous_homEquiv_apply_val {F : Sheaf K A} {H : Sheaf J A}\n    (f : (G.sheafPushforwardContinuous A J K).obj F ‚ü∂ H) :\n    ((G.sheafAdjunctionCocontinuous A J K).homEquiv F H f).val =\n      (G.op.ranAdjunction A).homEquiv F.val H.val f.val :=\n  ((sheafToPresheaf K A).congr_map\n    (((G.op.ranAdjunction A).restrictFullyFaithful_homEquiv_apply\n      (fullyFaithfulSheafToPresheaf K A) (fullyFaithfulSheafToPresheaf J A)\n      (G.sheafPushforwardContinuousCompSheafToPresheafIso A J K).symm\n      (G.sheafPushforwardCocontinuousCompSheafToPresheafIso A J K).symm f))).trans (by\n        dsimp\n        erw [Functor.map_id, Category.comp_id, Category.id_comp,\n          Adjunction.homEquiv_unit])\n\n"}
{"name":"CategoryTheory.Functor.toSheafify_pullbackSheafificationCompatibility","module":"Mathlib.CategoryTheory.Sites.CoverLifting","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å∑ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_3, u_2} D\nG : CategoryTheory.Functor C D\nA : Type w\ninst‚úù‚Åµ : CategoryTheory.Category.{w', w} A\nJ : CategoryTheory.GrothendieckTopology C\nK : CategoryTheory.GrothendieckTopology D\ninst‚úù‚Å¥ : G.IsCocontinuous J K\ninst‚úù¬≥ : ‚àÄ (F : CategoryTheory.Functor (Opposite C) A), G.op.HasPointwiseRightKanExtension F\ninst‚úù¬≤ : G.IsContinuous J K\ninst‚úù¬π : CategoryTheory.HasWeakSheafify J A\ninst‚úù : CategoryTheory.HasWeakSheafify K A\nF : CategoryTheory.Functor (Opposite D) A\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.toSheafify J (G.op.comp F)) ((G.pushforwardContinuousSheafificationCompatibility A J K).hom.app F).val) (CategoryTheory.whiskerLeft G.op (CategoryTheory.toSheafify K F))","decl":"lemma toSheafify_pullbackSheafificationCompatibility (F : D·µí·µñ ‚•§ A) :\n    toSheafify J (G.op ‚ãô F) ‚â´\n    ((G.pushforwardContinuousSheafificationCompatibility A J K).hom.app F).val =\n    whiskerLeft _ (toSheafify K _) := by\n  let adj‚ÇÅ := G.op.ranAdjunction A\n  let adj‚ÇÇ := sheafificationAdjunction J A\n  let adj‚ÇÉ := sheafificationAdjunction K A\n  let adj‚ÇÑ := G.sheafAdjunctionCocontinuous A J K\n  change adj‚ÇÇ.unit.app (((whiskeringLeft C·µí·µñ D·µí·µñ A).obj G.op).obj F) ‚â´\n    (sheafToPresheaf J A).map (((adj‚ÇÅ.comp adj‚ÇÇ).leftAdjointUniq (adj‚ÇÉ.comp adj‚ÇÑ)).hom.app F) =\n      ((whiskeringLeft C·µí·µñ D·µí·µñ A).obj G.op).map (adj‚ÇÉ.unit.app F)\n  apply (adj‚ÇÅ.homEquiv _ _).injective\n  have eq := (adj‚ÇÅ.comp adj‚ÇÇ).unit_leftAdjointUniq_hom_app (adj‚ÇÉ.comp adj‚ÇÑ) F\n  rw [Adjunction.comp_unit_app, Adjunction.comp_unit_app, comp_map,\n    Category.assoc] at eq\n  rw [adj‚ÇÅ.homEquiv_unit, Functor.map_comp, eq]\n  apply (adj‚ÇÅ.homEquiv _ _).symm.injective\n  simp only [Adjunction.homEquiv_counit, map_comp, Category.assoc,\n    Adjunction.homEquiv_unit, Adjunction.unit_naturality]\n  congr 3\n  exact G.sheafAdjunctionCocontinuous_unit_app_val A J K ((presheafToSheaf K A).obj F)\n\n"}
{"name":"CategoryTheory.Functor.pushforwardContinuousSheafificationCompatibility_hom_app_val","module":"Mathlib.CategoryTheory.Sites.CoverLifting","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å∑ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_3, u_2} D\nG : CategoryTheory.Functor C D\nA : Type w\ninst‚úù‚Åµ : CategoryTheory.Category.{w', w} A\nJ : CategoryTheory.GrothendieckTopology C\nK : CategoryTheory.GrothendieckTopology D\ninst‚úù‚Å¥ : G.IsCocontinuous J K\ninst‚úù¬≥ : ‚àÄ (F : CategoryTheory.Functor (Opposite C) A), G.op.HasPointwiseRightKanExtension F\ninst‚úù¬≤ : G.IsContinuous J K\ninst‚úù¬π : CategoryTheory.HasWeakSheafify J A\ninst‚úù : CategoryTheory.HasWeakSheafify K A\nF : CategoryTheory.Functor (Opposite D) A\n‚ä¢ Eq ((G.pushforwardContinuousSheafificationCompatibility A J K).hom.app F).val (CategoryTheory.sheafifyLift J (CategoryTheory.whiskerLeft G.op (CategoryTheory.toSheafify K F)) ‚ãØ)","decl":"@[simp]\nlemma pushforwardContinuousSheafificationCompatibility_hom_app_val (F : D·µí·µñ ‚•§ A) :\n    ((G.pushforwardContinuousSheafificationCompatibility A J K).hom.app F).val =\n    sheafifyLift J (whiskerLeft G.op <| toSheafify K F)\n      ((presheafToSheaf K A ‚ãô G.sheafPushforwardContinuous A J K).obj F).cond := by\n  apply sheafifyLift_unique\n  apply toSheafify_pullbackSheafificationCompatibility\n\n"}
