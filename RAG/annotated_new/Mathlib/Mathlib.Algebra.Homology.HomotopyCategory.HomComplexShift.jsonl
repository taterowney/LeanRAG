{"name":"CochainComplex.HomComplex.Cochain.rightShift_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplexShift","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nK L : CochainComplex C Int\nn : Int\nγ : CochainComplex.HomComplex.Cochain K L n\na n' : Int\nhn' : Eq (HAdd.hAdd n' a) n\np q : Int\nhpq : Eq (HAdd.hAdd p n') q\np' : Int\nhp' : Eq (HAdd.hAdd p n) p'\n⊢ Eq ((γ.rightShift a n' hn').v p q hpq) (CategoryTheory.CategoryStruct.comp (γ.v p p' hp') (L.shiftFunctorObjXIso a q p' ⋯).inv)","decl":"lemma rightShift_v (a n' : ℤ) (hn' : n' + a = n) (p q : ℤ) (hpq : p + n' = q)\n    (p' : ℤ) (hp' : p + n = p') :\n    (γ.rightShift a n' hn').v p q hpq = γ.v p p' hp' ≫\n      (L.shiftFunctorObjXIso a q p' (by rw [← hp', ← hpq, ← hn', add_assoc])).inv := by\n  subst hp'\n  dsimp only [rightShift]\n  simp only [mk_v]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.leftShift_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplexShift","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nK L : CochainComplex C Int\nn : Int\nγ : CochainComplex.HomComplex.Cochain K L n\na n' : Int\nhn' : Eq (HAdd.hAdd n a) n'\np q : Int\nhpq : Eq (HAdd.hAdd p n') q\np' : Int\nhp' : Eq (HAdd.hAdd p' n) q\n⊢ Eq ((γ.leftShift a n' hn').v p q hpq) (HSMul.hSMul (HAdd.hAdd (HMul.hMul a n') (HDiv.hDiv (HMul.hMul a (HSub.hSub a 1)) 2)).negOnePow (CategoryTheory.CategoryStruct.comp (K.shiftFunctorObjXIso a p p' ⋯).hom (γ.v p' q hp')))","decl":"lemma leftShift_v (a n' : ℤ) (hn' : n + a = n') (p q : ℤ) (hpq : p + n' = q)\n    (p' : ℤ) (hp' : p' + n = q) :\n    (γ.leftShift a n' hn').v p q hpq = (a * n' + ((a * (a - 1))/2)).negOnePow •\n      (K.shiftFunctorObjXIso a p p'\n        (by rw [← add_left_inj n, hp', add_assoc, add_comm a, hn', hpq])).hom ≫ γ.v p' q hp' := by\n  obtain rfl : p' = p + a := by omega\n  dsimp only [leftShift]\n  simp only [mk_v]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.rightUnshift_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplexShift","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nK L : CochainComplex C Int\nn' a : Int\nγ : CochainComplex.HomComplex.Cochain K ((CategoryTheory.shiftFunctor (CochainComplex C Int) a).obj L) n'\nn : Int\nhn : Eq (HAdd.hAdd n' a) n\np q : Int\nhpq : Eq (HAdd.hAdd p n) q\np' : Int\nhp' : Eq (HAdd.hAdd p n') p'\n⊢ Eq ((γ.rightUnshift n hn).v p q hpq) (CategoryTheory.CategoryStruct.comp (γ.v p p' hp') (L.shiftFunctorObjXIso a p' q ⋯).hom)","decl":"lemma rightUnshift_v {n' a : ℤ} (γ : Cochain K (L⟦a⟧) n') (n : ℤ) (hn : n' + a = n)\n    (p q : ℤ) (hpq : p + n = q) (p' : ℤ) (hp' : p + n' = p') :\n    (γ.rightUnshift n hn).v p q hpq = γ.v p p' hp' ≫\n      (L.shiftFunctorObjXIso a p' q (by rw [← hpq, ← hn, ← add_assoc, hp'])).hom := by\n  subst hp'\n  dsimp only [rightUnshift]\n  simp only [mk_v]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.leftUnshift_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplexShift","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nK L : CochainComplex C Int\nn' a : Int\nγ : CochainComplex.HomComplex.Cochain ((CategoryTheory.shiftFunctor (CochainComplex C Int) a).obj K) L n'\nn : Int\nhn : Eq (HAdd.hAdd n a) n'\np q : Int\nhpq : Eq (HAdd.hAdd p n) q\np' : Int\nhp' : Eq (HAdd.hAdd p' n') q\n⊢ Eq ((γ.leftUnshift n hn).v p q hpq) (HSMul.hSMul (HAdd.hAdd (HMul.hMul a n') (HDiv.hDiv (HMul.hMul a (HSub.hSub a 1)) 2)).negOnePow (CategoryTheory.CategoryStruct.comp (K.shiftFunctorObjXIso a p' p ⋯).inv (γ.v p' q ⋯)))","decl":"lemma leftUnshift_v {n' a : ℤ} (γ : Cochain (K⟦a⟧) L n') (n : ℤ) (hn : n + a = n')\n    (p q : ℤ) (hpq : p + n = q) (p' : ℤ) (hp' : p' + n' = q) :\n    (γ.leftUnshift n hn).v p q hpq = (a * n' + ((a * (a-1))/2)).negOnePow •\n      (K.shiftFunctorObjXIso a p' p (by omega)).inv ≫ γ.v p' q (by omega) := by\n  obtain rfl : p' = p - a := by omega\n  rfl\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.shift_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplexShift","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nK L : CochainComplex C Int\nn : Int\nγ : CochainComplex.HomComplex.Cochain K L n\na p q : Int\nhpq : Eq (HAdd.hAdd p n) q\np' q' : Int\nhp' : Eq p' (HAdd.hAdd p a)\nhq' : Eq q' (HAdd.hAdd q a)\n⊢ Eq ((γ.shift a).v p q hpq) (CategoryTheory.CategoryStruct.comp (K.shiftFunctorObjXIso a p p' hp').hom (CategoryTheory.CategoryStruct.comp (γ.v p' q' ⋯) (L.shiftFunctorObjXIso a q q' hq').inv))","decl":"lemma shift_v (a : ℤ) (p q : ℤ) (hpq : p + n = q) (p' q' : ℤ)\n    (hp' : p' = p + a) (hq' : q' = q + a) :\n    (γ.shift a).v p q hpq = (K.shiftFunctorObjXIso a p p' hp').hom ≫\n      γ.v p' q' (by rw [hp', hq', ← hpq, add_assoc, add_comm a, add_assoc]) ≫\n      (L.shiftFunctorObjXIso a q q' hq').inv := by\n  subst hp' hq'\n  rfl\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.shift_v'","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplexShift","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nK L : CochainComplex C Int\nn : Int\nγ : CochainComplex.HomComplex.Cochain K L n\na p q : Int\nhpq : Eq (HAdd.hAdd p n) q\n⊢ Eq ((γ.shift a).v p q hpq) (γ.v (HAdd.hAdd p a) (HAdd.hAdd q a) ⋯)","decl":"lemma shift_v' (a : ℤ) (p q : ℤ) (hpq : p + n = q) :\n    (γ.shift a).v p q hpq = γ.v (p + a) (q + a) (by omega) := by\n  simp only [shift_v γ a p q hpq _ _ rfl rfl, shiftFunctor_obj_X, shiftFunctorObjXIso,\n    HomologicalComplex.XIsoOfEq_rfl, Iso.refl_hom, Iso.refl_inv, comp_id, id_comp]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.rightUnshift_rightShift","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplexShift","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nK L : CochainComplex C Int\nn : Int\nγ : CochainComplex.HomComplex.Cochain K L n\na n' : Int\nhn' : Eq (HAdd.hAdd n' a) n\n⊢ Eq ((γ.rightShift a n' hn').rightUnshift n hn') γ","decl":"@[simp]\nlemma rightUnshift_rightShift (a n' : ℤ) (hn' : n' + a = n) :\n    (γ.rightShift a n' hn').rightUnshift n hn' = γ := by\n  ext p q hpq\n  simp only [rightUnshift_v _ n hn' p q hpq (p + n') rfl,\n    γ.rightShift_v _ _ hn' p (p + n') rfl q hpq,\n    shiftFunctorObjXIso, assoc, Iso.inv_hom_id, comp_id]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.rightShift_rightUnshift","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplexShift","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nK L : CochainComplex C Int\na n' : Int\nγ : CochainComplex.HomComplex.Cochain K ((CategoryTheory.shiftFunctor (CochainComplex C Int) a).obj L) n'\nn : Int\nhn' : Eq (HAdd.hAdd n' a) n\n⊢ Eq ((γ.rightUnshift n hn').rightShift a n' hn') γ","decl":"@[simp]\nlemma rightShift_rightUnshift {a n' : ℤ} (γ : Cochain K (L⟦a⟧) n') (n : ℤ) (hn' : n' + a = n) :\n    (γ.rightUnshift n hn').rightShift a n' hn' = γ := by\n  ext p q hpq\n  simp only [(γ.rightUnshift n hn').rightShift_v a n' hn' p q hpq (p + n) rfl,\n    γ.rightUnshift_v n hn' p (p + n) rfl q hpq,\n    shiftFunctorObjXIso, assoc, Iso.hom_inv_id, comp_id]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.leftUnshift_leftShift","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplexShift","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nK L : CochainComplex C Int\nn : Int\nγ : CochainComplex.HomComplex.Cochain K L n\na n' : Int\nhn' : Eq (HAdd.hAdd n a) n'\n⊢ Eq ((γ.leftShift a n' hn').leftUnshift n hn') γ","decl":"@[simp]\nlemma leftUnshift_leftShift (a n' : ℤ) (hn' : n + a = n') :\n    (γ.leftShift a n' hn').leftUnshift n hn' = γ := by\n  ext p q hpq\n  rw [(γ.leftShift a n' hn').leftUnshift_v n hn' p q hpq (q-n') (by omega),\n    γ.leftShift_v a n' hn' (q-n') q (by omega) p hpq, Linear.comp_units_smul,\n    Iso.inv_hom_id_assoc, smul_smul, Int.units_mul_self, one_smul]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.leftShift_leftUnshift","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplexShift","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nK L : CochainComplex C Int\na n' : Int\nγ : CochainComplex.HomComplex.Cochain ((CategoryTheory.shiftFunctor (CochainComplex C Int) a).obj K) L n'\nn : Int\nhn' : Eq (HAdd.hAdd n a) n'\n⊢ Eq ((γ.leftUnshift n hn').leftShift a n' hn') γ","decl":"@[simp]\nlemma leftShift_leftUnshift {a n' : ℤ} (γ : Cochain (K⟦a⟧) L n') (n : ℤ) (hn' : n + a = n') :\n    (γ.leftUnshift n hn').leftShift a n' hn' = γ := by\n  ext p q hpq\n  rw [(γ.leftUnshift n hn').leftShift_v a n' hn' p q hpq (q-n) (by omega),\n    γ.leftUnshift_v n hn' (q-n) q (by omega) p hpq, Linear.comp_units_smul, smul_smul,\n    Iso.hom_inv_id_assoc, Int.units_mul_self, one_smul]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.rightShift_add","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplexShift","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nK L : CochainComplex C Int\nn : Int\nγ₁ γ₂ : CochainComplex.HomComplex.Cochain K L n\na n' : Int\nhn' : Eq (HAdd.hAdd n' a) n\n⊢ Eq ((HAdd.hAdd γ₁ γ₂).rightShift a n' hn') (HAdd.hAdd (γ₁.rightShift a n' hn') (γ₂.rightShift a n' hn'))","decl":"@[simp]\nlemma rightShift_add (a n' : ℤ) (hn' : n' + a = n) :\n    (γ₁ + γ₂).rightShift a n' hn' = γ₁.rightShift a n' hn' + γ₂.rightShift a n' hn' := by\n  ext p q hpq\n  dsimp\n  simp only [rightShift_v _ a n' hn' p q hpq _ rfl, add_v, add_comp]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.leftShift_add","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplexShift","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nK L : CochainComplex C Int\nn : Int\nγ₁ γ₂ : CochainComplex.HomComplex.Cochain K L n\na n' : Int\nhn' : Eq (HAdd.hAdd n a) n'\n⊢ Eq ((HAdd.hAdd γ₁ γ₂).leftShift a n' hn') (HAdd.hAdd (γ₁.leftShift a n' hn') (γ₂.leftShift a n' hn'))","decl":"@[simp]\nlemma leftShift_add (a n' : ℤ) (hn' : n + a = n') :\n    (γ₁ + γ₂).leftShift a n' hn' = γ₁.leftShift a n' hn' + γ₂.leftShift a n' hn' := by\n  ext p q hpq\n  dsimp\n  simp only [leftShift_v _ a n' hn' p q hpq (p + a) (by omega), add_v, comp_add, smul_add]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.shift_add","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplexShift","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nK L : CochainComplex C Int\nn : Int\nγ₁ γ₂ : CochainComplex.HomComplex.Cochain K L n\na : Int\n⊢ Eq ((HAdd.hAdd γ₁ γ₂).shift a) (HAdd.hAdd (γ₁.shift a) (γ₂.shift a))","decl":"@[simp]\nlemma shift_add (a : ℤ) :\n    (γ₁ + γ₂).shift a = γ₁.shift a + γ₂.shift a := by\n  ext p q hpq\n  dsimp\n  simp only [shift_v', add_v]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.rightShiftAddEquiv_apply","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplexShift","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nK L : CochainComplex C Int\nn a n' : Int\nhn' : Eq (HAdd.hAdd n' a) n\nγ : CochainComplex.HomComplex.Cochain K L n\n⊢ Eq ((CochainComplex.HomComplex.Cochain.rightShiftAddEquiv K L n a n' hn') γ) (γ.rightShift a n' hn')","decl":"/-- The additive equivalence `Cochain K L n ≃+ Cochain K L⟦a⟧ n'` when `n' + a = n`. -/\n@[simps]\ndef rightShiftAddEquiv (n a n' : ℤ) (hn' : n' + a = n) :\n    Cochain K L n ≃+ Cochain K (L⟦a⟧) n' where\n  toFun γ := γ.rightShift a n' hn'\n  invFun γ := γ.rightUnshift n hn'\n  left_inv γ := by dsimp; simp only [rightUnshift_rightShift]\n  right_inv γ := by dsimp; simp only [rightShift_rightUnshift]\n  map_add' γ γ' := by dsimp; simp only [rightShift_add]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.rightShiftAddEquiv_symm_apply","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplexShift","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nK L : CochainComplex C Int\nn a n' : Int\nhn' : Eq (HAdd.hAdd n' a) n\nγ : CochainComplex.HomComplex.Cochain K ((CategoryTheory.shiftFunctor (CochainComplex C Int) a).obj L) n'\n⊢ Eq ((CochainComplex.HomComplex.Cochain.rightShiftAddEquiv K L n a n' hn').symm γ) (γ.rightUnshift n hn')","decl":"/-- The additive equivalence `Cochain K L n ≃+ Cochain K L⟦a⟧ n'` when `n' + a = n`. -/\n@[simps]\ndef rightShiftAddEquiv (n a n' : ℤ) (hn' : n' + a = n) :\n    Cochain K L n ≃+ Cochain K (L⟦a⟧) n' where\n  toFun γ := γ.rightShift a n' hn'\n  invFun γ := γ.rightUnshift n hn'\n  left_inv γ := by dsimp; simp only [rightUnshift_rightShift]\n  right_inv γ := by dsimp; simp only [rightShift_rightUnshift]\n  map_add' γ γ' := by dsimp; simp only [rightShift_add]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.leftShiftAddEquiv_symm_apply","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplexShift","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nK L : CochainComplex C Int\nn a n' : Int\nhn' : Eq (HAdd.hAdd n a) n'\nγ : CochainComplex.HomComplex.Cochain ((CategoryTheory.shiftFunctor (CochainComplex C Int) a).obj K) L n'\n⊢ Eq ((CochainComplex.HomComplex.Cochain.leftShiftAddEquiv K L n a n' hn').symm γ) (γ.leftUnshift n hn')","decl":"/-- The additive equivalence `Cochain K L n ≃+ Cochain (K⟦a⟧) L n'` when `n + a = n'`. -/\n@[simps]\ndef leftShiftAddEquiv (n a n' : ℤ) (hn' : n + a = n') :\n    Cochain K L n ≃+ Cochain (K⟦a⟧) L n' where\n  toFun γ := γ.leftShift a n' hn'\n  invFun γ := γ.leftUnshift n hn'\n  left_inv γ := by dsimp; simp only [leftUnshift_leftShift]\n  right_inv γ := by dsimp; simp only [leftShift_leftUnshift]\n  map_add' γ γ' := by dsimp; simp only [leftShift_add]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.leftShiftAddEquiv_apply","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplexShift","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nK L : CochainComplex C Int\nn a n' : Int\nhn' : Eq (HAdd.hAdd n a) n'\nγ : CochainComplex.HomComplex.Cochain K L n\n⊢ Eq ((CochainComplex.HomComplex.Cochain.leftShiftAddEquiv K L n a n' hn') γ) (γ.leftShift a n' hn')","decl":"/-- The additive equivalence `Cochain K L n ≃+ Cochain (K⟦a⟧) L n'` when `n + a = n'`. -/\n@[simps]\ndef leftShiftAddEquiv (n a n' : ℤ) (hn' : n + a = n') :\n    Cochain K L n ≃+ Cochain (K⟦a⟧) L n' where\n  toFun γ := γ.leftShift a n' hn'\n  invFun γ := γ.leftUnshift n hn'\n  left_inv γ := by dsimp; simp only [leftUnshift_leftShift]\n  right_inv γ := by dsimp; simp only [leftShift_leftUnshift]\n  map_add' γ γ' := by dsimp; simp only [leftShift_add]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.shiftAddHom_apply","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplexShift","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nK L : CochainComplex C Int\nn a : Int\nγ : CochainComplex.HomComplex.Cochain K L n\n⊢ Eq ((CochainComplex.HomComplex.Cochain.shiftAddHom K L n a) γ) (γ.shift a)","decl":"/-- The additive map `Cochain K L n →+ Cochain (K⟦a⟧) (L⟦a⟧) n`. -/\n@[simps!]\ndef shiftAddHom (n a : ℤ) : Cochain K L n →+ Cochain (K⟦a⟧) (L⟦a⟧) n :=\n  AddMonoidHom.mk' (fun γ => γ.shift a) (by intros; dsimp; simp only [shift_add])\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.rightShift_zero","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplexShift","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nK L : CochainComplex C Int\nn a n' : Int\nhn' : Eq (HAdd.hAdd n' a) n\n⊢ Eq (CochainComplex.HomComplex.Cochain.rightShift 0 a n' hn') 0","decl":"@[simp]\nlemma rightShift_zero (a n' : ℤ) (hn' : n' + a = n) :\n    (0 : Cochain K L n).rightShift a n' hn' = 0 := by\n  change rightShiftAddEquiv K L n a n' hn' 0 = 0\n  apply _root_.map_zero\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.rightUnshift_zero","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplexShift","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nK L : CochainComplex C Int\nn a n' : Int\nhn' : Eq (HAdd.hAdd n' a) n\n⊢ Eq (CochainComplex.HomComplex.Cochain.rightUnshift 0 n hn') 0","decl":"@[simp]\nlemma rightUnshift_zero (a n' : ℤ) (hn' : n' + a = n) :\n    (0 : Cochain K (L⟦a⟧) n').rightUnshift n hn' = 0 := by\n  change (rightShiftAddEquiv K L n a n' hn').symm 0 = 0\n  apply _root_.map_zero\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.leftShift_zero","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplexShift","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nK L : CochainComplex C Int\nn a n' : Int\nhn' : Eq (HAdd.hAdd n a) n'\n⊢ Eq (CochainComplex.HomComplex.Cochain.leftShift 0 a n' hn') 0","decl":"@[simp]\nlemma leftShift_zero (a n' : ℤ) (hn' : n + a = n') :\n    (0 : Cochain K L n).leftShift a n' hn' = 0 := by\n  change leftShiftAddEquiv K L n a n' hn' 0 = 0\n  apply _root_.map_zero\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.leftUnshift_zero","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplexShift","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nK L : CochainComplex C Int\nn a n' : Int\nhn' : Eq (HAdd.hAdd n a) n'\n⊢ Eq (CochainComplex.HomComplex.Cochain.leftUnshift 0 n hn') 0","decl":"@[simp]\nlemma leftUnshift_zero (a n' : ℤ) (hn' : n + a = n') :\n    (0 : Cochain (K⟦a⟧) L n').leftUnshift n hn' = 0 := by\n  change (leftShiftAddEquiv K L n a n' hn').symm 0 = 0\n  apply _root_.map_zero\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.shift_zero","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplexShift","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nK L : CochainComplex C Int\nn a : Int\n⊢ Eq (CochainComplex.HomComplex.Cochain.shift 0 a) 0","decl":"@[simp]\nlemma shift_zero (a : ℤ) :\n    (0 : Cochain K L n).shift a = 0 := by\n  change shiftAddHom K L n a 0 = 0\n  apply _root_.map_zero\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.rightShift_neg","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplexShift","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nK L : CochainComplex C Int\nn : Int\nγ : CochainComplex.HomComplex.Cochain K L n\na n' : Int\nhn' : Eq (HAdd.hAdd n' a) n\n⊢ Eq ((Neg.neg γ).rightShift a n' hn') (Neg.neg (γ.rightShift a n' hn'))","decl":"@[simp]\nlemma rightShift_neg (a n' : ℤ) (hn' : n' + a = n) :\n    (-γ).rightShift a n' hn' = -γ.rightShift a n' hn' := by\n  change rightShiftAddEquiv K L n a n' hn' (-γ) = _\n  apply _root_.map_neg\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.rightUnshift_neg","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplexShift","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nK L : CochainComplex C Int\nn' a : Int\nγ : CochainComplex.HomComplex.Cochain K ((CategoryTheory.shiftFunctor (CochainComplex C Int) a).obj L) n'\nn : Int\nhn : Eq (HAdd.hAdd n' a) n\n⊢ Eq ((Neg.neg γ).rightUnshift n hn) (Neg.neg (γ.rightUnshift n hn))","decl":"@[simp]\nlemma rightUnshift_neg {n' a : ℤ} (γ : Cochain K (L⟦a⟧) n') (n : ℤ) (hn : n' + a = n) :\n    (-γ).rightUnshift n hn = -γ.rightUnshift n hn := by\n  change (rightShiftAddEquiv K L n a n' hn).symm (-γ) = _\n  apply _root_.map_neg\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.leftShift_neg","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplexShift","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nK L : CochainComplex C Int\nn : Int\nγ : CochainComplex.HomComplex.Cochain K L n\na n' : Int\nhn' : Eq (HAdd.hAdd n a) n'\n⊢ Eq ((Neg.neg γ).leftShift a n' hn') (Neg.neg (γ.leftShift a n' hn'))","decl":"@[simp]\nlemma leftShift_neg (a n' : ℤ) (hn' : n + a = n') :\n    (-γ).leftShift a n' hn' = -γ.leftShift a n' hn' := by\n  change leftShiftAddEquiv K L n a n' hn' (-γ) = _\n  apply _root_.map_neg\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.leftUnshift_neg","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplexShift","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nK L : CochainComplex C Int\nn' a : Int\nγ : CochainComplex.HomComplex.Cochain ((CategoryTheory.shiftFunctor (CochainComplex C Int) a).obj K) L n'\nn : Int\nhn : Eq (HAdd.hAdd n a) n'\n⊢ Eq ((Neg.neg γ).leftUnshift n hn) (Neg.neg (γ.leftUnshift n hn))","decl":"@[simp]\nlemma leftUnshift_neg {n' a : ℤ} (γ : Cochain (K⟦a⟧) L n') (n : ℤ) (hn : n + a = n') :\n    (-γ).leftUnshift n hn = -γ.leftUnshift n hn := by\n  change (leftShiftAddEquiv K L n a n' hn).symm (-γ) = _\n  apply _root_.map_neg\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.shift_neg","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplexShift","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nK L : CochainComplex C Int\nn : Int\nγ : CochainComplex.HomComplex.Cochain K L n\na : Int\n⊢ Eq ((Neg.neg γ).shift a) (Neg.neg (γ.shift a))","decl":"@[simp]\nlemma shift_neg (a : ℤ) :\n    (-γ).shift a = -γ.shift a := by\n  change shiftAddHom K L n a (-γ) = _\n  apply _root_.map_neg\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.rightUnshift_add","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplexShift","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nK L : CochainComplex C Int\nn' a : Int\nγ₁ γ₂ : CochainComplex.HomComplex.Cochain K ((CategoryTheory.shiftFunctor (CochainComplex C Int) a).obj L) n'\nn : Int\nhn : Eq (HAdd.hAdd n' a) n\n⊢ Eq ((HAdd.hAdd γ₁ γ₂).rightUnshift n hn) (HAdd.hAdd (γ₁.rightUnshift n hn) (γ₂.rightUnshift n hn))","decl":"@[simp]\nlemma rightUnshift_add {n' a : ℤ} (γ₁ γ₂ : Cochain K (L⟦a⟧) n') (n : ℤ) (hn : n' + a = n) :\n    (γ₁ + γ₂).rightUnshift n hn = γ₁.rightUnshift n hn + γ₂.rightUnshift n hn := by\n  change (rightShiftAddEquiv K L n a n' hn).symm (γ₁ + γ₂) = _\n  apply _root_.map_add\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.leftUnshift_add","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplexShift","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nK L : CochainComplex C Int\nn' a : Int\nγ₁ γ₂ : CochainComplex.HomComplex.Cochain ((CategoryTheory.shiftFunctor (CochainComplex C Int) a).obj K) L n'\nn : Int\nhn : Eq (HAdd.hAdd n a) n'\n⊢ Eq ((HAdd.hAdd γ₁ γ₂).leftUnshift n hn) (HAdd.hAdd (γ₁.leftUnshift n hn) (γ₂.leftUnshift n hn))","decl":"@[simp]\nlemma leftUnshift_add {n' a : ℤ} (γ₁ γ₂ : Cochain (K⟦a⟧) L n') (n : ℤ) (hn : n + a = n') :\n    (γ₁ + γ₂).leftUnshift n hn = γ₁.leftUnshift n hn + γ₂.leftUnshift n hn := by\n  change (leftShiftAddEquiv K L n a n' hn).symm (γ₁ + γ₂) = _\n  apply _root_.map_add\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.rightShift_smul","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplexShift","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Preadditive C\nR : Type u_1\ninst✝¹ : Ring R\ninst✝ : CategoryTheory.Linear R C\nK L : CochainComplex C Int\nn : Int\nγ : CochainComplex.HomComplex.Cochain K L n\na n' : Int\nhn' : Eq (HAdd.hAdd n' a) n\nx : R\n⊢ Eq ((HSMul.hSMul x γ).rightShift a n' hn') (HSMul.hSMul x (γ.rightShift a n' hn'))","decl":"@[simp]\nlemma rightShift_smul (a n' : ℤ) (hn' : n' + a = n) (x : R) :\n    (x • γ).rightShift a n' hn' = x • γ.rightShift a n' hn' := by\n  ext p q hpq\n  dsimp\n  simp only [rightShift_v _ a n' hn' p q hpq _ rfl, smul_v, Linear.smul_comp]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.leftShift_smul","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplexShift","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Preadditive C\nR : Type u_1\ninst✝¹ : Ring R\ninst✝ : CategoryTheory.Linear R C\nK L : CochainComplex C Int\nn : Int\nγ : CochainComplex.HomComplex.Cochain K L n\na n' : Int\nhn' : Eq (HAdd.hAdd n a) n'\nx : R\n⊢ Eq ((HSMul.hSMul x γ).leftShift a n' hn') (HSMul.hSMul x (γ.leftShift a n' hn'))","decl":"@[simp]\nlemma leftShift_smul (a n' : ℤ) (hn' : n + a = n') (x : R) :\n    (x • γ).leftShift a n' hn' = x • γ.leftShift a n' hn' := by\n  ext p q hpq\n  dsimp\n  simp only [leftShift_v _ a n' hn' p q hpq (p + a) (by omega), smul_v, Linear.comp_smul,\n    smul_comm x]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.shift_smul","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplexShift","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Preadditive C\nR : Type u_1\ninst✝¹ : Ring R\ninst✝ : CategoryTheory.Linear R C\nK L : CochainComplex C Int\nn : Int\nγ : CochainComplex.HomComplex.Cochain K L n\na : Int\nx : R\n⊢ Eq ((HSMul.hSMul x γ).shift a) (HSMul.hSMul x (γ.shift a))","decl":"@[simp]\nlemma shift_smul (a : ℤ) (x : R) :\n    (x • γ).shift a = x • (γ.shift a) := by\n  ext p q hpq\n  dsimp\n  simp only [shift_v', smul_v]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.rightShiftLinearEquiv_apply","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplexShift","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Preadditive C\nR : Type u_1\ninst✝¹ : Ring R\ninst✝ : CategoryTheory.Linear R C\nK L : CochainComplex C Int\nn a n' : Int\nhn' : Eq (HAdd.hAdd n' a) n\na✝ : CochainComplex.HomComplex.Cochain K L n\n⊢ Eq ((CochainComplex.HomComplex.Cochain.rightShiftLinearEquiv R K L n a n' hn') a✝) (a✝.rightShift a n' hn')","decl":"/-- The linear equivalence `Cochain K L n ≃+ Cochain K L⟦a⟧ n'` when `n' + a = n` and\nthe category is `R`-linear. -/\n@[simps!]\ndef rightShiftLinearEquiv (n a n' : ℤ) (hn' : n' + a = n) :\n    Cochain K L n ≃ₗ[R] Cochain K (L⟦a⟧) n' :=\n  (rightShiftAddEquiv K L n a n' hn').toLinearEquiv\n    (fun x γ => by dsimp; simp only [rightShift_smul])\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.rightShiftLinearEquiv_symm_apply","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplexShift","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Preadditive C\nR : Type u_1\ninst✝¹ : Ring R\ninst✝ : CategoryTheory.Linear R C\nK L : CochainComplex C Int\nn a n' : Int\nhn' : Eq (HAdd.hAdd n' a) n\na✝ : CochainComplex.HomComplex.Cochain K ((CategoryTheory.shiftFunctor (CochainComplex C Int) a).obj L) n'\n⊢ Eq ((CochainComplex.HomComplex.Cochain.rightShiftLinearEquiv R K L n a n' hn').symm a✝) (a✝.rightUnshift n hn')","decl":"/-- The linear equivalence `Cochain K L n ≃+ Cochain K L⟦a⟧ n'` when `n' + a = n` and\nthe category is `R`-linear. -/\n@[simps!]\ndef rightShiftLinearEquiv (n a n' : ℤ) (hn' : n' + a = n) :\n    Cochain K L n ≃ₗ[R] Cochain K (L⟦a⟧) n' :=\n  (rightShiftAddEquiv K L n a n' hn').toLinearEquiv\n    (fun x γ => by dsimp; simp only [rightShift_smul])\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.leftShiftLinearEquiv_symm_apply","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplexShift","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Preadditive C\nR : Type u_1\ninst✝¹ : Ring R\ninst✝ : CategoryTheory.Linear R C\nK L : CochainComplex C Int\nn a n' : Int\nhn : Eq (HAdd.hAdd n a) n'\na✝ : CochainComplex.HomComplex.Cochain ((CategoryTheory.shiftFunctor (CochainComplex C Int) a).obj K) L n'\n⊢ Eq ((CochainComplex.HomComplex.Cochain.leftShiftLinearEquiv R K L n a n' hn).symm a✝) (a✝.leftUnshift n hn)","decl":"/-- The additive equivalence `Cochain K L n ≃+ Cochain (K⟦a⟧) L n'` when `n + a = n'` and\nthe category is `R`-linear. -/\n@[simps!]\ndef leftShiftLinearEquiv (n a n' : ℤ) (hn : n + a = n') :\n    Cochain K L n ≃ₗ[R] Cochain (K⟦a⟧) L n' :=\n  (leftShiftAddEquiv K L n a n' hn).toLinearEquiv\n    (fun x γ => by dsimp; simp only [leftShift_smul])\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.leftShiftLinearEquiv_apply","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplexShift","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Preadditive C\nR : Type u_1\ninst✝¹ : Ring R\ninst✝ : CategoryTheory.Linear R C\nK L : CochainComplex C Int\nn a n' : Int\nhn : Eq (HAdd.hAdd n a) n'\na✝ : CochainComplex.HomComplex.Cochain K L n\n⊢ Eq ((CochainComplex.HomComplex.Cochain.leftShiftLinearEquiv R K L n a n' hn) a✝) (a✝.leftShift a n' hn)","decl":"/-- The additive equivalence `Cochain K L n ≃+ Cochain (K⟦a⟧) L n'` when `n + a = n'` and\nthe category is `R`-linear. -/\n@[simps!]\ndef leftShiftLinearEquiv (n a n' : ℤ) (hn : n + a = n') :\n    Cochain K L n ≃ₗ[R] Cochain (K⟦a⟧) L n' :=\n  (leftShiftAddEquiv K L n a n' hn).toLinearEquiv\n    (fun x γ => by dsimp; simp only [leftShift_smul])\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.shiftLinearMap_apply","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplexShift","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Preadditive C\nR : Type u_1\ninst✝¹ : Ring R\ninst✝ : CategoryTheory.Linear R C\nK L : CochainComplex C Int\nn a✝ : Int\na : CochainComplex.HomComplex.Cochain K L n\n⊢ Eq ((CochainComplex.HomComplex.Cochain.shiftLinearMap R K L n a✝) a) (a.shift a✝)","decl":"/-- The linear map `Cochain K L n ≃+ Cochain (K⟦a⟧) (L⟦a⟧) n` when the category is `R`-linear. -/\n@[simps!]\ndef shiftLinearMap (n a : ℤ) :\n    Cochain K L n →ₗ[R] Cochain (K⟦a⟧) (L⟦a⟧) n where\n  toAddHom := shiftAddHom K L n a\n  map_smul' _ _ := by dsimp; simp only [shift_smul]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.rightShift_units_smul","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplexShift","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Preadditive C\nR : Type u_1\ninst✝¹ : Ring R\ninst✝ : CategoryTheory.Linear R C\nK L : CochainComplex C Int\nn : Int\nγ : CochainComplex.HomComplex.Cochain K L n\na n' : Int\nhn' : Eq (HAdd.hAdd n' a) n\nx : Units R\n⊢ Eq ((HSMul.hSMul x γ).rightShift a n' hn') (HSMul.hSMul x (γ.rightShift a n' hn'))","decl":"@[simp]\nlemma rightShift_units_smul (a n' : ℤ) (hn' : n' + a = n) (x : Rˣ) :\n    (x • γ).rightShift a n' hn' = x • γ.rightShift a n' hn' := by\n  apply rightShift_smul\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.leftShift_units_smul","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplexShift","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Preadditive C\nR : Type u_1\ninst✝¹ : Ring R\ninst✝ : CategoryTheory.Linear R C\nK L : CochainComplex C Int\nn : Int\nγ : CochainComplex.HomComplex.Cochain K L n\na n' : Int\nhn' : Eq (HAdd.hAdd n a) n'\nx : Units R\n⊢ Eq ((HSMul.hSMul x γ).leftShift a n' hn') (HSMul.hSMul x (γ.leftShift a n' hn'))","decl":"@[simp]\nlemma leftShift_units_smul (a n' : ℤ) (hn' : n + a = n') (x : Rˣ) :\n    (x • γ).leftShift a n' hn' = x • γ.leftShift a n' hn' := by\n  apply leftShift_smul\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.shift_units_smul","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplexShift","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Preadditive C\nR : Type u_1\ninst✝¹ : Ring R\ninst✝ : CategoryTheory.Linear R C\nK L : CochainComplex C Int\nn : Int\nγ : CochainComplex.HomComplex.Cochain K L n\na : Int\nx : Units R\n⊢ Eq ((HSMul.hSMul x γ).shift a) (HSMul.hSMul x (γ.shift a))","decl":"@[simp]\nlemma shift_units_smul (a : ℤ) (x : Rˣ) :\n    (x • γ).shift a = x • (γ.shift a) := by\n  ext p q hpq\n  dsimp\n  simp only [shift_v', units_smul_v]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.rightUnshift_smul","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplexShift","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Preadditive C\nR : Type u_1\ninst✝¹ : Ring R\ninst✝ : CategoryTheory.Linear R C\nK L : CochainComplex C Int\nn' a : Int\nγ : CochainComplex.HomComplex.Cochain K ((CategoryTheory.shiftFunctor (CochainComplex C Int) a).obj L) n'\nn : Int\nhn : Eq (HAdd.hAdd n' a) n\nx : R\n⊢ Eq ((HSMul.hSMul x γ).rightUnshift n hn) (HSMul.hSMul x (γ.rightUnshift n hn))","decl":"@[simp]\nlemma rightUnshift_smul {n' a : ℤ} (γ : Cochain K (L⟦a⟧) n') (n : ℤ) (hn : n' + a = n) (x : R) :\n    (x • γ).rightUnshift n hn = x • γ.rightUnshift n hn := by\n  change (rightShiftLinearEquiv  R K L n a n' hn).symm (x • γ) = _\n  apply map_smul\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.rightUnshift_units_smul","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplexShift","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Preadditive C\nR : Type u_1\ninst✝¹ : Ring R\ninst✝ : CategoryTheory.Linear R C\nK L : CochainComplex C Int\nn' a : Int\nγ : CochainComplex.HomComplex.Cochain K ((CategoryTheory.shiftFunctor (CochainComplex C Int) a).obj L) n'\nn : Int\nhn : Eq (HAdd.hAdd n' a) n\nx : Units R\n⊢ Eq ((HSMul.hSMul x γ).rightUnshift n hn) (HSMul.hSMul x (γ.rightUnshift n hn))","decl":"@[simp]\nlemma rightUnshift_units_smul {n' a : ℤ} (γ : Cochain K (L⟦a⟧) n') (n : ℤ)\n    (hn : n' + a = n) (x : Rˣ) :\n    (x • γ).rightUnshift n hn = x • γ.rightUnshift n hn := by\n  apply rightUnshift_smul\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.leftUnshift_smul","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplexShift","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Preadditive C\nR : Type u_1\ninst✝¹ : Ring R\ninst✝ : CategoryTheory.Linear R C\nK L : CochainComplex C Int\nn' a : Int\nγ : CochainComplex.HomComplex.Cochain ((CategoryTheory.shiftFunctor (CochainComplex C Int) a).obj K) L n'\nn : Int\nhn : Eq (HAdd.hAdd n a) n'\nx : R\n⊢ Eq ((HSMul.hSMul x γ).leftUnshift n hn) (HSMul.hSMul x (γ.leftUnshift n hn))","decl":"@[simp]\nlemma leftUnshift_smul {n' a : ℤ} (γ : Cochain (K⟦a⟧) L n') (n : ℤ) (hn : n + a = n') (x : R) :\n    (x • γ).leftUnshift n hn = x • γ.leftUnshift n hn := by\n  change (leftShiftLinearEquiv  R K L n a n' hn).symm (x • γ) = _\n  apply map_smul\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.leftUnshift_units_smul","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplexShift","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Preadditive C\nR : Type u_1\ninst✝¹ : Ring R\ninst✝ : CategoryTheory.Linear R C\nK L : CochainComplex C Int\nn' a : Int\nγ : CochainComplex.HomComplex.Cochain ((CategoryTheory.shiftFunctor (CochainComplex C Int) a).obj K) L n'\nn : Int\nhn : Eq (HAdd.hAdd n a) n'\nx : Units R\n⊢ Eq ((HSMul.hSMul x γ).leftUnshift n hn) (HSMul.hSMul x (γ.leftUnshift n hn))","decl":"@[simp]\nlemma leftUnshift_units_smul {n' a : ℤ} (γ : Cochain (K⟦a⟧) L n') (n : ℤ)\n    (hn : n + a = n') (x : Rˣ) :\n    (x • γ).leftUnshift n hn = x • γ.leftUnshift n hn := by\n  apply leftUnshift_smul\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.rightUnshift_comp","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplexShift","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nK L M : CochainComplex C Int\nn : Int\nγ : CochainComplex.HomComplex.Cochain K L n\nm a : Int\nγ' : CochainComplex.HomComplex.Cochain L ((CategoryTheory.shiftFunctor (CochainComplex C Int) a).obj M) m\nnm : Int\nhnm : Eq (HAdd.hAdd n m) nm\nnm' : Int\nhnm' : Eq (HAdd.hAdd nm a) nm'\nm' : Int\nhm' : Eq (HAdd.hAdd m a) m'\n⊢ Eq ((γ.comp γ' hnm).rightUnshift nm' hnm') (γ.comp (γ'.rightUnshift m' hm') ⋯)","decl":"lemma rightUnshift_comp {m : ℤ} {a : ℤ} (γ' : Cochain L (M⟦a⟧) m) {nm : ℤ} (hnm : n + m = nm)\n    (nm' : ℤ) (hnm' : nm + a = nm') (m' : ℤ) (hm' : m + a = m') :\n    (γ.comp γ' hnm).rightUnshift nm' hnm' =\n      γ.comp (γ'.rightUnshift m' hm') (by omega) := by\n  ext p q hpq\n  rw [(γ.comp γ' hnm).rightUnshift_v nm' hnm' p q hpq (p + n + m) (by omega),\n    γ.comp_v γ' hnm p (p + n) (p + n + m) rfl rfl,\n    comp_v _ _ (show n + m' = nm' by omega) p (p + n) q (by omega) (by omega),\n    γ'.rightUnshift_v m' hm' (p + n) q (by omega) (p + n + m) rfl, assoc]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.leftShift_comp","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplexShift","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nK L M : CochainComplex C Int\nn : Int\nγ : CochainComplex.HomComplex.Cochain K L n\na n' : Int\nhn' : Eq (HAdd.hAdd n a) n'\nm t t' : Int\nγ' : CochainComplex.HomComplex.Cochain L M m\nh : Eq (HAdd.hAdd n m) t\nht' : Eq (HAdd.hAdd t a) t'\n⊢ Eq ((γ.comp γ' h).leftShift a t' ht') (HSMul.hSMul (HMul.hMul a m).negOnePow ((γ.leftShift a n' hn').comp γ' ⋯))","decl":"lemma leftShift_comp (a n' : ℤ) (hn' : n + a = n') {m t t' : ℤ} (γ' : Cochain L M m)\n    (h : n + m = t) (ht' : t + a = t') :\n    (γ.comp γ' h).leftShift a t' ht' = (a * m).negOnePow • (γ.leftShift a n' hn').comp γ'\n      (by rw [← ht', ← h, ← hn', add_assoc, add_comm a, add_assoc]) := by\n  ext p q hpq\n  have h' : n' + m = t' := by omega\n  dsimp\n  simp only [Cochain.comp_v _ _ h' p (p + n') q rfl (by omega),\n    γ.leftShift_v a n' hn' p (p + n') rfl (p + a) (by omega),\n    (γ.comp γ' h).leftShift_v a t' (by omega) p q hpq (p + a) (by omega),\n    smul_smul, Linear.units_smul_comp, assoc, Int.negOnePow_add, ← mul_assoc, ← h',\n    comp_v _ _ h (p + a) (p + n') q (by omega) (by omega)]\n  congr 2\n  rw [add_comm n', mul_add, Int.negOnePow_add]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.leftShift_comp_zero_cochain","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplexShift","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nK L M : CochainComplex C Int\nn : Int\nγ : CochainComplex.HomComplex.Cochain K L n\na n' : Int\nhn' : Eq (HAdd.hAdd n a) n'\nγ' : CochainComplex.HomComplex.Cochain L M 0\n⊢ Eq ((γ.comp γ' ⋯).leftShift a n' hn') ((γ.leftShift a n' hn').comp γ' ⋯)","decl":"@[simp]\nlemma leftShift_comp_zero_cochain (a n' : ℤ) (hn' : n + a = n') (γ' : Cochain L M 0) :\n    (γ.comp γ' (add_zero n)).leftShift a n' hn' =\n      (γ.leftShift a n' hn').comp γ' (add_zero n') := by\n  rw [leftShift_comp γ a n' hn' γ' (add_zero _) hn', mul_zero, Int.negOnePow_zero, one_smul]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.δ_rightShift","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplexShift","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nK L : CochainComplex C Int\nn : Int\nγ : CochainComplex.HomComplex.Cochain K L n\na n' m' : Int\nhn' : Eq (HAdd.hAdd n' a) n\nm : Int\nhm' : Eq (HAdd.hAdd m' a) m\n⊢ Eq (CochainComplex.HomComplex.δ n' m' (γ.rightShift a n' hn')) (HSMul.hSMul a.negOnePow ((CochainComplex.HomComplex.δ n m γ).rightShift a m' hm'))","decl":"lemma δ_rightShift (a n' m' : ℤ) (hn' : n' + a = n) (m : ℤ) (hm' : m' + a = m) :\n    δ n' m' (γ.rightShift a n' hn') = a.negOnePow • (δ n m γ).rightShift a m' hm' := by\n  by_cases hnm : n + 1 = m\n  · have hnm' : n' + 1 = m' := by omega\n    ext p q hpq\n    dsimp\n    rw [(δ n m γ).rightShift_v a m' hm' p q hpq _ rfl,\n      δ_v n m hnm _ p (p+m) rfl (p+n) (p+1) (by omega) rfl,\n      δ_v n' m' hnm' _ p q hpq (p+n') (p+1) (by omega) rfl,\n      γ.rightShift_v a n' hn' p (p+n') rfl (p+n) rfl,\n      γ.rightShift_v a n' hn' (p+1) q _ (p+m) (by omega)]\n    simp only [shiftFunctorObjXIso, shiftFunctor_obj_d',\n      Linear.comp_units_smul, assoc, HomologicalComplex.XIsoOfEq_inv_comp_d,\n      add_comp, HomologicalComplex.d_comp_XIsoOfEq_inv, Linear.units_smul_comp, smul_add,\n      add_right_inj, smul_smul]\n    congr 1\n    simp only [← hm', add_comm m', Int.negOnePow_add, ← mul_assoc,\n      Int.units_mul_self, one_mul]\n  · have hnm' : ¬ n' + 1 = m' := fun _ => hnm (by omega)\n    rw [δ_shape _ _ hnm', δ_shape _ _ hnm, rightShift_zero, smul_zero]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.δ_rightUnshift","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplexShift","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nK L : CochainComplex C Int\na n' : Int\nγ : CochainComplex.HomComplex.Cochain K ((CategoryTheory.shiftFunctor (CochainComplex C Int) a).obj L) n'\nn : Int\nhn : Eq (HAdd.hAdd n' a) n\nm m' : Int\nhm' : Eq (HAdd.hAdd m' a) m\n⊢ Eq (CochainComplex.HomComplex.δ n m (γ.rightUnshift n hn)) (HSMul.hSMul a.negOnePow ((CochainComplex.HomComplex.δ n' m' γ).rightUnshift m hm'))","decl":"lemma δ_rightUnshift {a n' : ℤ} (γ : Cochain K (L⟦a⟧) n') (n : ℤ) (hn : n' + a = n)\n    (m m' : ℤ) (hm' : m' + a = m) :\n    δ n m (γ.rightUnshift n hn) = a.negOnePow • (δ n' m' γ).rightUnshift m hm' := by\n  obtain ⟨γ', rfl⟩ := (rightShiftAddEquiv K L n a n' hn).surjective γ\n  dsimp\n  simp only [rightUnshift_rightShift, γ'.δ_rightShift a n' m' hn m hm', rightUnshift_units_smul,\n    smul_smul, Int.units_mul_self, one_smul]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.δ_leftShift","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplexShift","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nK L : CochainComplex C Int\nn : Int\nγ : CochainComplex.HomComplex.Cochain K L n\na n' m' : Int\nhn' : Eq (HAdd.hAdd n a) n'\nm : Int\nhm' : Eq (HAdd.hAdd m a) m'\n⊢ Eq (CochainComplex.HomComplex.δ n' m' (γ.leftShift a n' hn')) (HSMul.hSMul a.negOnePow ((CochainComplex.HomComplex.δ n m γ).leftShift a m' hm'))","decl":"lemma δ_leftShift (a n' m' : ℤ) (hn' : n + a = n') (m : ℤ) (hm' : m + a = m') :\n    δ n' m' (γ.leftShift a n' hn') = a.negOnePow • (δ n m γ).leftShift a m' hm' := by\n  by_cases hnm : n + 1 = m\n  · have hnm' : n' + 1 = m' := by omega\n    ext p q hpq\n    dsimp\n    rw [(δ n m γ).leftShift_v a m' hm' p q hpq (p+a) (by omega),\n      δ_v n m hnm _ (p+a) q (by omega) (p+n') (p+1+a) (by omega) (by omega),\n      δ_v n' m' hnm' _ p q hpq (p+n') (p+1) (by omega) rfl,\n      γ.leftShift_v a n' hn' p (p+n') rfl (p+a) (by omega),\n      γ.leftShift_v a n' hn' (p+1) q (by omega) (p+1+a) (by omega)]\n    simp only [shiftFunctor_obj_X, shiftFunctorObjXIso, HomologicalComplex.XIsoOfEq_rfl,\n      Iso.refl_hom, id_comp, Linear.units_smul_comp, shiftFunctor_obj_d',\n      Linear.comp_units_smul, smul_add, smul_smul]\n    congr 2\n    · rw [← hnm', add_comm n', mul_add, mul_one]\n      simp only [Int.negOnePow_add, ← mul_assoc, Int.units_mul_self, one_mul]\n    · simp only [← Int.negOnePow_add, ← hn', ← hm', ← hnm]\n      congr 1\n      linarith\n  · have hnm' : ¬ n' + 1 = m' := fun _ => hnm (by omega)\n    rw [δ_shape _ _ hnm', δ_shape _ _ hnm, leftShift_zero, smul_zero]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.δ_leftUnshift","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplexShift","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nK L : CochainComplex C Int\na n' : Int\nγ : CochainComplex.HomComplex.Cochain ((CategoryTheory.shiftFunctor (CochainComplex C Int) a).obj K) L n'\nn : Int\nhn : Eq (HAdd.hAdd n a) n'\nm m' : Int\nhm' : Eq (HAdd.hAdd m a) m'\n⊢ Eq (CochainComplex.HomComplex.δ n m (γ.leftUnshift n hn)) (HSMul.hSMul a.negOnePow ((CochainComplex.HomComplex.δ n' m' γ).leftUnshift m hm'))","decl":"lemma δ_leftUnshift {a n' : ℤ} (γ : Cochain (K⟦a⟧) L n') (n : ℤ) (hn : n + a = n')\n    (m m' : ℤ) (hm' : m + a = m') :\n    δ n m (γ.leftUnshift n hn) = a.negOnePow • (δ n' m' γ).leftUnshift m hm' := by\n  obtain ⟨γ', rfl⟩ := (leftShiftAddEquiv K L n a n' hn).surjective γ\n  dsimp\n  simp only [leftUnshift_leftShift, γ'.δ_leftShift a n' m' hn m hm', leftUnshift_units_smul,\n    smul_smul, Int.units_mul_self, one_smul]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.δ_shift","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplexShift","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nK L : CochainComplex C Int\nn : Int\nγ : CochainComplex.HomComplex.Cochain K L n\na m : Int\n⊢ Eq (CochainComplex.HomComplex.δ n m (γ.shift a)) (HSMul.hSMul a.negOnePow ((CochainComplex.HomComplex.δ n m γ).shift a))","decl":"@[simp]\nlemma δ_shift (a m : ℤ) :\n    δ n m (γ.shift a) = a.negOnePow • (δ n m γ).shift a := by\n  by_cases hnm : n + 1 = m\n  · ext p q hpq\n    dsimp\n    simp only [shift_v', sub_add_cancel, shiftFunctor_obj_d',\n      δ_v n m hnm _ p q hpq (q - 1) (p + 1) rfl rfl,\n      δ_v n m hnm _ (p + a) (q + a) (by omega) (q - 1 + a) (p + 1 + a)\n        (by omega) (by omega),\n      smul_add, Linear.units_smul_comp, Linear.comp_units_smul, add_right_inj]\n    rw [smul_comm]\n  · rw [δ_shape _ _ hnm, δ_shape _ _ hnm, shift_zero, smul_zero]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.leftShift_rightShift","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplexShift","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nK L : CochainComplex C Int\nn : Int\nγ : CochainComplex.HomComplex.Cochain K L n\na n' : Int\nhn' : Eq (HAdd.hAdd n' a) n\n⊢ Eq ((γ.rightShift a n' hn').leftShift a n hn') (HSMul.hSMul (HAdd.hAdd (HMul.hMul a n) (HDiv.hDiv (HMul.hMul a (HSub.hSub a 1)) 2)).negOnePow (γ.shift a))","decl":"lemma leftShift_rightShift (a n' : ℤ) (hn' : n' + a = n) :\n    (γ.rightShift a n' hn').leftShift a n hn' =\n      (a * n + (a * (a - 1)) / 2).negOnePow • γ.shift a := by\n  ext p q hpq\n  simp only [leftShift_v _ a n hn' p q hpq (p + a) (by omega),\n    rightShift_v _ a n' hn' (p + a) q (by omega) (q + a) (by omega), units_smul_v, shift_v']\n  dsimp\n  rw [id_comp, comp_id]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.rightShift_leftShift","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplexShift","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nK L : CochainComplex C Int\nn : Int\nγ : CochainComplex.HomComplex.Cochain K L n\na n' : Int\nhn' : Eq (HAdd.hAdd n a) n'\n⊢ Eq ((γ.leftShift a n' hn').rightShift a n hn') (HSMul.hSMul (HAdd.hAdd (HMul.hMul a n') (HDiv.hDiv (HMul.hMul a (HSub.hSub a 1)) 2)).negOnePow (γ.shift a))","decl":"lemma rightShift_leftShift (a n' : ℤ) (hn' : n + a = n') :\n    (γ.leftShift a n' hn').rightShift a n hn' =\n      (a * n' + (a * (a - 1)) / 2).negOnePow • γ.shift a := by\n  ext p q hpq\n  simp only [rightShift_v _ a n hn' p q hpq (q + a) (by omega),\n    leftShift_v _ a n' hn' p (q + a) (by omega) (p + a) (by omega), units_smul_v, shift_v']\n  dsimp\n  rw [id_comp, comp_id]\n\n"}
{"name":"CochainComplex.HomComplex.Cochain.leftShift_rightShift_eq_negOnePow_rightShift_leftShift","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplexShift","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nK L : CochainComplex C Int\nn : Int\nγ : CochainComplex.HomComplex.Cochain K L n\na n' n'' : Int\nhn' : Eq (HAdd.hAdd n' a) n\nhn'' : Eq (HAdd.hAdd n a) n''\n⊢ Eq ((γ.rightShift a n' hn').leftShift a n hn') (HSMul.hSMul a.negOnePow ((γ.leftShift a n'' hn'').rightShift a n hn''))","decl":"/-- The left and right shift of cochains commute only up to a sign. -/\nlemma leftShift_rightShift_eq_negOnePow_rightShift_leftShift\n    (a n' n'' : ℤ) (hn' : n' + a = n) (hn'' : n + a = n'') :\n    (γ.rightShift a n' hn').leftShift a n hn' =\n      a.negOnePow • (γ.leftShift a n'' hn'').rightShift a n hn'' := by\n  rw [leftShift_rightShift, rightShift_leftShift, smul_smul, ← hn'', add_comm n a, mul_add,\n    Int.negOnePow_add, Int.negOnePow_add, Int.negOnePow_add, Int.negOnePow_mul_self,\n    ← mul_assoc, ← mul_assoc, Int.units_mul_self, one_mul]\n\n"}
{"name":"CochainComplex.HomComplex.Cocycle.rightShift_coe","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplexShift","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nK L : CochainComplex C Int\nn : Int\nγ : CochainComplex.HomComplex.Cocycle K L n\na n' : Int\nhn' : Eq (HAdd.hAdd n' a) n\n⊢ Eq (↑(γ.rightShift a n' hn')) ((↑γ).rightShift a n' hn')","decl":"/-- The map `Cocycle K L n → Cocycle K (L⟦a⟧) n'` when `n' + a = n`. -/\n@[simps!]\ndef rightShift (γ : Cocycle K L n) (a n' : ℤ) (hn' : n' + a = n) :\n    Cocycle K (L⟦a⟧) n' :=\n  Cocycle.mk (γ.1.rightShift a n' hn') _ rfl (by\n    simp only [Cochain.δ_rightShift _ a n' (n' + 1) hn' (n + 1) (by omega),\n      δ_eq_zero, Cochain.rightShift_zero, smul_zero])\n\n"}
{"name":"CochainComplex.HomComplex.Cocycle.rightUnshift_coe","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplexShift","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nK L : CochainComplex C Int\nn' a : Int\nγ : CochainComplex.HomComplex.Cocycle K ((CategoryTheory.shiftFunctor (CochainComplex C Int) a).obj L) n'\nn : Int\nhn : Eq (HAdd.hAdd n' a) n\n⊢ Eq (↑(γ.rightUnshift n hn)) ((↑γ).rightUnshift n hn)","decl":"/-- The map `Cocycle K (L⟦a⟧) n' → Cocycle K L n` when `n' + a = n`. -/\n@[simps!]\ndef rightUnshift {n' a : ℤ} (γ : Cocycle K (L⟦a⟧) n') (n : ℤ) (hn : n' + a = n) :\n    Cocycle K L n :=\n  Cocycle.mk (γ.1.rightUnshift n hn) _ rfl (by\n    rw [Cochain.δ_rightUnshift _ n hn (n + 1) (n + 1 - a) (by omega),\n      δ_eq_zero, Cochain.rightUnshift_zero, smul_zero])\n\n"}
{"name":"CochainComplex.HomComplex.Cocycle.leftShift_coe","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplexShift","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nK L : CochainComplex C Int\nn : Int\nγ : CochainComplex.HomComplex.Cocycle K L n\na n' : Int\nhn' : Eq (HAdd.hAdd n a) n'\n⊢ Eq (↑(γ.leftShift a n' hn')) ((↑γ).leftShift a n' hn')","decl":"/-- The map `Cocycle K L n → Cocycle (K⟦a⟧) L n'` when `n + a = n'`. -/\n@[simps!]\ndef leftShift (γ : Cocycle K L n) (a n' : ℤ) (hn' : n + a = n') :\n    Cocycle (K⟦a⟧) L n' :=\n  Cocycle.mk (γ.1.leftShift a n' hn') _ rfl (by\n    simp only [Cochain.δ_leftShift _ a n' (n' + 1) hn' (n + 1) (by omega),\n      δ_eq_zero, Cochain.leftShift_zero, smul_zero])\n\n"}
{"name":"CochainComplex.HomComplex.Cocycle.leftUnshift_coe","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplexShift","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nK L : CochainComplex C Int\nn' a : Int\nγ : CochainComplex.HomComplex.Cocycle ((CategoryTheory.shiftFunctor (CochainComplex C Int) a).obj K) L n'\nn : Int\nhn : Eq (HAdd.hAdd n a) n'\n⊢ Eq (↑(γ.leftUnshift n hn)) ((↑γ).leftUnshift n hn)","decl":"/-- The map `Cocycle (K⟦a⟧) L n' → Cocycle K L n` when `n + a = n'`. -/\n@[simps!]\ndef leftUnshift {n' a : ℤ} (γ : Cocycle (K⟦a⟧) L n') (n : ℤ) (hn : n + a = n') :\n    Cocycle K L n :=\n  Cocycle.mk (γ.1.leftUnshift n hn) _ rfl (by\n    rw [Cochain.δ_leftUnshift _ n hn (n + 1) (n + 1 + a) rfl,\n      δ_eq_zero, Cochain.leftUnshift_zero, smul_zero])\n\n"}
{"name":"CochainComplex.HomComplex.Cocycle.shift_coe","module":"Mathlib.Algebra.Homology.HomotopyCategory.HomComplexShift","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nK L : CochainComplex C Int\nn : Int\nγ : CochainComplex.HomComplex.Cocycle K L n\na : Int\n⊢ Eq (↑(γ.shift a)) ((↑γ).shift a)","decl":"/-- The map `Cocycle K L n → Cocycle (K⟦a⟧) (L⟦a⟧) n`. -/\n@[simps!]\ndef shift (γ : Cocycle K L n) (a : ℤ) :\n    Cocycle (K⟦a⟧) (L⟦a⟧) n :=\n  Cocycle.mk (γ.1.shift a) _ rfl\n    (by simp only [Cochain.δ_shift, δ_eq_zero, Cochain.shift_zero, smul_zero])\n\n"}
