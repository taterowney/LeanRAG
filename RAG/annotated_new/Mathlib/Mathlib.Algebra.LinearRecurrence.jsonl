{"name":"LinearRecurrence.mk.injEq","module":"Mathlib.Algebra.LinearRecurrence","initialProofState":"α : Type u_1\ninst✝ : CommSemiring α\norder✝ : Nat\ncoeffs✝ : Fin order✝ → α\norder : Nat\ncoeffs : Fin order → α\n⊢ Eq (Eq { order := order✝, coeffs := coeffs✝ } { order := order, coeffs := coeffs }) (And (Eq order✝ order) (HEq coeffs✝ coeffs))","decl":"/-- A \"linear recurrence relation\" over a commutative semiring is given by its\n  order `n` and `n` coefficients. -/\nstructure LinearRecurrence (α : Type*) [CommSemiring α] where\n  order : ℕ\n  coeffs : Fin order → α\n\n"}
{"name":"LinearRecurrence.mk.inj","module":"Mathlib.Algebra.LinearRecurrence","initialProofState":"α : Type u_1\ninst✝ : CommSemiring α\norder✝ : Nat\ncoeffs✝ : Fin order✝ → α\norder : Nat\ncoeffs : Fin order → α\nx✝ : Eq { order := order✝, coeffs := coeffs✝ } { order := order, coeffs := coeffs }\n⊢ And (Eq order✝ order) (HEq coeffs✝ coeffs)","decl":"/-- A \"linear recurrence relation\" over a commutative semiring is given by its\n  order `n` and `n` coefficients. -/\nstructure LinearRecurrence (α : Type*) [CommSemiring α] where\n  order : ℕ\n  coeffs : Fin order → α\n\n"}
{"name":"LinearRecurrence.mk.sizeOf_spec","module":"Mathlib.Algebra.LinearRecurrence","initialProofState":"α : Type u_1\ninst✝¹ : CommSemiring α\ninst✝ : SizeOf α\norder : Nat\ncoeffs : Fin order → α\n⊢ Eq (SizeOf.sizeOf { order := order, coeffs := coeffs }) (HAdd.hAdd 1 (SizeOf.sizeOf order))","decl":"/-- A \"linear recurrence relation\" over a commutative semiring is given by its\n  order `n` and `n` coefficients. -/\nstructure LinearRecurrence (α : Type*) [CommSemiring α] where\n  order : ℕ\n  coeffs : Fin order → α\n\n"}
{"name":"LinearRecurrence.is_sol_mkSol","module":"Mathlib.Algebra.LinearRecurrence","initialProofState":"α : Type u_1\ninst✝ : CommSemiring α\nE : LinearRecurrence α\ninit : Fin E.order → α\n⊢ E.IsSolution (E.mkSol init)","decl":"/-- `E.mkSol` indeed gives solutions to `E`. -/\ntheorem is_sol_mkSol (init : Fin E.order → α) : E.IsSolution (E.mkSol init) := by\n  intro n\n  rw [mkSol]\n  simp\n\n"}
{"name":"LinearRecurrence.mkSol_eq_init","module":"Mathlib.Algebra.LinearRecurrence","initialProofState":"α : Type u_1\ninst✝ : CommSemiring α\nE : LinearRecurrence α\ninit : Fin E.order → α\nn : Fin E.order\n⊢ Eq (E.mkSol init ↑n) (init n)","decl":"/-- `E.mkSol init`'s first `E.order` terms are `init`. -/\ntheorem mkSol_eq_init (init : Fin E.order → α) : ∀ n : Fin E.order, E.mkSol init n = init n := by\n  intro n\n  rw [mkSol]\n  simp only [n.is_lt, dif_pos, Fin.mk_val, Fin.eta]\n\n"}
{"name":"LinearRecurrence.eq_mk_of_is_sol_of_eq_init","module":"Mathlib.Algebra.LinearRecurrence","initialProofState":"α : Type u_1\ninst✝ : CommSemiring α\nE : LinearRecurrence α\nu : Nat → α\ninit : Fin E.order → α\nh : E.IsSolution u\nheq : ∀ (n : Fin E.order), Eq (u ↑n) (init n)\nn : Nat\n⊢ Eq (u n) (E.mkSol init n)","decl":"/-- If `u` is a solution to `E` and `init` designates its first `E.order` values,\n  then `∀ n, u n = E.mkSol init n`. -/\ntheorem eq_mk_of_is_sol_of_eq_init {u : ℕ → α} {init : Fin E.order → α} (h : E.IsSolution u)\n    (heq : ∀ n : Fin E.order, u n = init n) : ∀ n, u n = E.mkSol init n := by\n  intro n\n  rw [mkSol]\n  split_ifs with h'\n  · exact mod_cast heq ⟨n, h'⟩\n  · rw [← tsub_add_cancel_of_le (le_of_not_lt h'), h (n - E.order)]\n    congr with k\n    have : n - E.order + k < n := by omega\n    rw [eq_mk_of_is_sol_of_eq_init h heq (n - E.order + k)]\n    simp\n\n"}
{"name":"LinearRecurrence.eq_mk_of_is_sol_of_eq_init'","module":"Mathlib.Algebra.LinearRecurrence","initialProofState":"α : Type u_1\ninst✝ : CommSemiring α\nE : LinearRecurrence α\nu : Nat → α\ninit : Fin E.order → α\nh : E.IsSolution u\nheq : ∀ (n : Fin E.order), Eq (u ↑n) (init n)\n⊢ Eq u (E.mkSol init)","decl":"/-- If `u` is a solution to `E` and `init` designates its first `E.order` values,\n  then `u = E.mkSol init`. This proves that `E.mkSol init` is the only solution\n  of `E` whose first `E.order` values are given by `init`. -/\ntheorem eq_mk_of_is_sol_of_eq_init' {u : ℕ → α} {init : Fin E.order → α} (h : E.IsSolution u)\n    (heq : ∀ n : Fin E.order, u n = init n) : u = E.mkSol init :=\n  funext (E.eq_mk_of_is_sol_of_eq_init h heq)\n\n"}
{"name":"LinearRecurrence.is_sol_iff_mem_solSpace","module":"Mathlib.Algebra.LinearRecurrence","initialProofState":"α : Type u_1\ninst✝ : CommSemiring α\nE : LinearRecurrence α\nu : Nat → α\n⊢ Iff (E.IsSolution u) (Membership.mem E.solSpace u)","decl":"/-- Defining property of the solution space : `u` is a solution\n  iff it belongs to the solution space. -/\ntheorem is_sol_iff_mem_solSpace (u : ℕ → α) : E.IsSolution u ↔ u ∈ E.solSpace :=\n  Iff.rfl\n\n"}
{"name":"LinearRecurrence.sol_eq_of_eq_init","module":"Mathlib.Algebra.LinearRecurrence","initialProofState":"α : Type u_1\ninst✝ : CommSemiring α\nE : LinearRecurrence α\nu v : Nat → α\nhu : E.IsSolution u\nhv : E.IsSolution v\n⊢ Iff (Eq u v) (Set.EqOn u v ↑(Finset.range E.order))","decl":"/-- Two solutions are equal iff they are equal on `range E.order`. -/\ntheorem sol_eq_of_eq_init (u v : ℕ → α) (hu : E.IsSolution u) (hv : E.IsSolution v) :\n    u = v ↔ Set.EqOn u v ↑(range E.order) := by\n  refine Iff.intro (fun h x _ ↦ h ▸ rfl) ?_\n  intro h\n  set u' : ↥E.solSpace := ⟨u, hu⟩\n  set v' : ↥E.solSpace := ⟨v, hv⟩\n  change u'.val = v'.val\n  suffices h' : u' = v' from h' ▸ rfl\n  rw [← E.toInit.toEquiv.apply_eq_iff_eq, LinearEquiv.coe_toEquiv]\n  ext x\n  exact mod_cast h (mem_range.mpr x.2)\n\n"}
{"name":"LinearRecurrence.solSpace_rank","module":"Mathlib.Algebra.LinearRecurrence","initialProofState":"α : Type u_1\ninst✝¹ : CommRing α\ninst✝ : StrongRankCondition α\nE : LinearRecurrence α\n⊢ Eq (Module.rank α (Subtype fun x => Membership.mem E.solSpace x)) ↑E.order","decl":"/-- The dimension of `E.solSpace` is `E.order`. -/\ntheorem solSpace_rank : Module.rank α E.solSpace = E.order :=\n  letI := nontrivial_of_invariantBasisNumber α\n  @rank_fin_fun α _ _ E.order ▸ E.toInit.rank_eq\n\n"}
{"name":"LinearRecurrence.geom_sol_iff_root_charPoly","module":"Mathlib.Algebra.LinearRecurrence","initialProofState":"α : Type u_1\ninst✝ : CommRing α\nE : LinearRecurrence α\nq : α\n⊢ Iff (E.IsSolution fun n => HPow.hPow q n) (E.charPoly.IsRoot q)","decl":"/-- The geometric sequence `q^n` is a solution of `E` iff\n  `q` is a root of `E`'s characteristic polynomial. -/\ntheorem geom_sol_iff_root_charPoly (q : α) :\n    (E.IsSolution fun n ↦ q ^ n) ↔ E.charPoly.IsRoot q := by\n  rw [charPoly, Polynomial.IsRoot.def, Polynomial.eval]\n  simp only [Polynomial.eval₂_finset_sum, one_mul, RingHom.id_apply, Polynomial.eval₂_monomial,\n    Polynomial.eval₂_sub]\n  constructor\n  · intro h\n    simpa [sub_eq_zero] using h 0\n  · intro h n\n    simp only [pow_add, sub_eq_zero.mp h, mul_sum]\n    exact sum_congr rfl fun _ _ ↦ by ring\n\n"}
