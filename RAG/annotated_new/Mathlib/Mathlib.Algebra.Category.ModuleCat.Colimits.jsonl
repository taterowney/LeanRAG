{"name":"ModuleCat.HasColimit.coconePointSMul_apply","module":"Mathlib.Algebra.Category.ModuleCat.Colimits","initialProofState":"R : Type w\ninst✝² : Ring R\nJ : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} J\nF : CategoryTheory.Functor J (ModuleCat R)\ninst✝ : CategoryTheory.Limits.HasColimit (F.comp (CategoryTheory.forget₂ (ModuleCat R) AddCommGrp))\nr : R\n⊢ Eq ((ModuleCat.HasColimit.coconePointSMul F) r) (CategoryTheory.Limits.colimMap { app := fun j => (F.obj j).smul r, naturality := ⋯ })","decl":"/-- The induced scalar multiplication on\n`colimit (F ⋙ forget₂ _ AddCommGrp)`. -/\n@[simps]\nnoncomputable def coconePointSMul :\n    R →+* End (colimit (F ⋙ forget₂ _ AddCommGrp)) where\n  toFun r := colimMap\n    { app := fun j => (F.obj j).smul r\n      naturality := fun _ _ _ => smul_naturality _ _ }\n  map_zero' := colimit.hom_ext (by simp)\n  map_one' := colimit.hom_ext (by simp)\n  map_add' r s := colimit.hom_ext (fun j => by\n    simp only [Functor.comp_obj, forget₂_obj, map_add, ι_colimMap]\n    rw [Preadditive.add_comp, Preadditive.comp_add]\n    simp only [ι_colimMap, Functor.comp_obj, forget₂_obj])\n  map_mul' r s := colimit.hom_ext (fun j => by simp)\n\n"}
{"name":"ModuleCat.HasColimit.colimitCocone_pt_isAddCommGroup","module":"Mathlib.Algebra.Category.ModuleCat.Colimits","initialProofState":"R : Type w\ninst✝² : Ring R\nJ : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} J\nF : CategoryTheory.Functor J (ModuleCat R)\ninst✝ : CategoryTheory.Limits.HasColimit (F.comp (CategoryTheory.forget₂ (ModuleCat R) AddCommGrp))\n⊢ Eq (ModuleCat.HasColimit.colimitCocone F).pt.isAddCommGroup (ModuleCat.instAddCommGroupCarrierMkOfSMul' (ModuleCat.HasColimit.coconePointSMul F))","decl":"/-- The cocone for `F` constructed from the colimit of\n`(F ⋙ forget₂ (ModuleCat R) AddCommGrp)`. -/\n@[simps]\nnoncomputable def colimitCocone : Cocone F where\n  pt := mkOfSMul (coconePointSMul F)\n  ι :=\n    { app := fun j => homMk (colimit.ι (F ⋙ forget₂ _ AddCommGrp)  j) (fun r => by\n        dsimp\n        -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n        erw [mkOfSMul_smul]\n        simp)\n      naturality := fun i j f => by\n        apply (forget₂ _ AddCommGrp).map_injective\n        simp only [Functor.map_comp, forget₂_map_homMk]\n        dsimp\n        erw [colimit.w (F ⋙ forget₂ _ AddCommGrp), comp_id] }\n\n"}
{"name":"ModuleCat.HasColimit.colimitCocone_ι_app","module":"Mathlib.Algebra.Category.ModuleCat.Colimits","initialProofState":"R : Type w\ninst✝² : Ring R\nJ : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} J\nF : CategoryTheory.Functor J (ModuleCat R)\ninst✝ : CategoryTheory.Limits.HasColimit (F.comp (CategoryTheory.forget₂ (ModuleCat R) AddCommGrp))\nj : J\n⊢ Eq ((ModuleCat.HasColimit.colimitCocone F).ι.app j) (ModuleCat.homMk (CategoryTheory.Limits.colimit.ι (F.comp (CategoryTheory.forget₂ (ModuleCat R) AddCommGrp)) j) ⋯)","decl":"/-- The cocone for `F` constructed from the colimit of\n`(F ⋙ forget₂ (ModuleCat R) AddCommGrp)`. -/\n@[simps]\nnoncomputable def colimitCocone : Cocone F where\n  pt := mkOfSMul (coconePointSMul F)\n  ι :=\n    { app := fun j => homMk (colimit.ι (F ⋙ forget₂ _ AddCommGrp)  j) (fun r => by\n        dsimp\n        -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n        erw [mkOfSMul_smul]\n        simp)\n      naturality := fun i j f => by\n        apply (forget₂ _ AddCommGrp).map_injective\n        simp only [Functor.map_comp, forget₂_map_homMk]\n        dsimp\n        erw [colimit.w (F ⋙ forget₂ _ AddCommGrp), comp_id] }\n\n"}
{"name":"ModuleCat.HasColimit.colimitCocone_pt_isModule","module":"Mathlib.Algebra.Category.ModuleCat.Colimits","initialProofState":"R : Type w\ninst✝² : Ring R\nJ : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} J\nF : CategoryTheory.Functor J (ModuleCat R)\ninst✝ : CategoryTheory.Limits.HasColimit (F.comp (CategoryTheory.forget₂ (ModuleCat R) AddCommGrp))\n⊢ Eq (ModuleCat.HasColimit.colimitCocone F).pt.isModule (ModuleCat.instModuleCarrierMkOfSMul' (ModuleCat.HasColimit.coconePointSMul F))","decl":"/-- The cocone for `F` constructed from the colimit of\n`(F ⋙ forget₂ (ModuleCat R) AddCommGrp)`. -/\n@[simps]\nnoncomputable def colimitCocone : Cocone F where\n  pt := mkOfSMul (coconePointSMul F)\n  ι :=\n    { app := fun j => homMk (colimit.ι (F ⋙ forget₂ _ AddCommGrp)  j) (fun r => by\n        dsimp\n        -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n        erw [mkOfSMul_smul]\n        simp)\n      naturality := fun i j f => by\n        apply (forget₂ _ AddCommGrp).map_injective\n        simp only [Functor.map_comp, forget₂_map_homMk]\n        dsimp\n        erw [colimit.w (F ⋙ forget₂ _ AddCommGrp), comp_id] }\n\n"}
{"name":"ModuleCat.HasColimit.colimitCocone_pt_carrier","module":"Mathlib.Algebra.Category.ModuleCat.Colimits","initialProofState":"R : Type w\ninst✝² : Ring R\nJ : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} J\nF : CategoryTheory.Functor J (ModuleCat R)\ninst✝ : CategoryTheory.Limits.HasColimit (F.comp (CategoryTheory.forget₂ (ModuleCat R) AddCommGrp))\n⊢ Eq ↑(ModuleCat.HasColimit.colimitCocone F).pt ↑(ModuleCat.mkOfSMul' (ModuleCat.HasColimit.coconePointSMul F))","decl":"/-- The cocone for `F` constructed from the colimit of\n`(F ⋙ forget₂ (ModuleCat R) AddCommGrp)`. -/\n@[simps]\nnoncomputable def colimitCocone : Cocone F where\n  pt := mkOfSMul (coconePointSMul F)\n  ι :=\n    { app := fun j => homMk (colimit.ι (F ⋙ forget₂ _ AddCommGrp)  j) (fun r => by\n        dsimp\n        -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n        erw [mkOfSMul_smul]\n        simp)\n      naturality := fun i j f => by\n        apply (forget₂ _ AddCommGrp).map_injective\n        simp only [Functor.map_comp, forget₂_map_homMk]\n        dsimp\n        erw [colimit.w (F ⋙ forget₂ _ AddCommGrp), comp_id] }\n\n"}
{"name":"ModuleCat.HasColimit.instHasColimit","module":"Mathlib.Algebra.Category.ModuleCat.Colimits","initialProofState":"R : Type w\ninst✝² : Ring R\nJ : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} J\nF : CategoryTheory.Functor J (ModuleCat R)\ninst✝ : CategoryTheory.Limits.HasColimit (F.comp (CategoryTheory.forget₂ (ModuleCat R) AddCommGrp))\n⊢ CategoryTheory.Limits.HasColimit F","decl":"instance : HasColimit F := ⟨_, isColimitColimitCocone F⟩\n\n"}
{"name":"ModuleCat.HasColimit.instPreservesColimitAddCommGrpForget₂","module":"Mathlib.Algebra.Category.ModuleCat.Colimits","initialProofState":"R : Type w\ninst✝² : Ring R\nJ : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} J\nF : CategoryTheory.Functor J (ModuleCat R)\ninst✝ : CategoryTheory.Limits.HasColimit (F.comp (CategoryTheory.forget₂ (ModuleCat R) AddCommGrp))\n⊢ CategoryTheory.Limits.PreservesColimit F (CategoryTheory.forget₂ (ModuleCat R) AddCommGrp)","decl":"noncomputable instance : PreservesColimit F (forget₂ _ AddCommGrp) :=\n  preservesColimit_of_preserves_colimit_cocone (isColimitColimitCocone F) (colimit.isColimit _)\n\n"}
{"name":"ModuleCat.HasColimit.reflectsColimit","module":"Mathlib.Algebra.Category.ModuleCat.Colimits","initialProofState":"R : Type w\ninst✝² : Ring R\nJ : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} J\nF : CategoryTheory.Functor J (ModuleCat R)\ninst✝ : CategoryTheory.Limits.HasColimit (F.comp (CategoryTheory.forget₂ (ModuleCat R) AddCommGrp))\n⊢ CategoryTheory.Limits.ReflectsColimit F (CategoryTheory.forget₂ (ModuleCat R) AddCommGrp)","decl":"noncomputable instance reflectsColimit :\n    ReflectsColimit F (forget₂ (ModuleCat.{w'} R) AddCommGrp) :=\n  reflectsColimit_of_reflectsIsomorphisms _ _\n\n"}
{"name":"ModuleCat.hasColimitsOfShape","module":"Mathlib.Algebra.Category.ModuleCat.Colimits","initialProofState":"R : Type w\ninst✝² : Ring R\nJ : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} J\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape J AddCommGrp\n⊢ CategoryTheory.Limits.HasColimitsOfShape J (ModuleCat R)","decl":"instance hasColimitsOfShape [HasColimitsOfShape J AddCommGrp.{w'}] :\n    HasColimitsOfShape J (ModuleCat.{w'} R) where\n\n"}
{"name":"ModuleCat.reflectsColimitsOfShape","module":"Mathlib.Algebra.Category.ModuleCat.Colimits","initialProofState":"R : Type w\ninst✝² : Ring R\nJ : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} J\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape J AddCommGrp\n⊢ CategoryTheory.Limits.ReflectsColimitsOfShape J (CategoryTheory.forget₂ (ModuleCat R) AddCommGrp)","decl":"noncomputable instance reflectsColimitsOfShape [HasColimitsOfShape J AddCommGrp.{w'}] :\n    ReflectsColimitsOfShape J (forget₂ (ModuleCat.{w'} R) AddCommGrp) where\n\n"}
{"name":"ModuleCat.hasColimitsOfSize","module":"Mathlib.Algebra.Category.ModuleCat.Colimits","initialProofState":"R : Type w\ninst✝¹ : Ring R\ninst✝ : CategoryTheory.Limits.HasColimitsOfSize.{v, u, w', w' + 1} AddCommGrp\n⊢ CategoryTheory.Limits.HasColimitsOfSize.{v, u, w', max (w' + 1) w} (ModuleCat R)","decl":"instance hasColimitsOfSize [HasColimitsOfSize.{v, u} AddCommGrp.{w'}] :\n    HasColimitsOfSize.{v, u} (ModuleCat.{w'} R) where\n\n"}
{"name":"ModuleCat.forget₂PreservesColimitsOfShape","module":"Mathlib.Algebra.Category.ModuleCat.Colimits","initialProofState":"R : Type w\ninst✝² : Ring R\nJ : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} J\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape J AddCommGrp\n⊢ CategoryTheory.Limits.PreservesColimitsOfShape J (CategoryTheory.forget₂ (ModuleCat R) AddCommGrp)","decl":"noncomputable instance forget₂PreservesColimitsOfShape\n    [HasColimitsOfShape J AddCommGrp.{w'}] :\n    PreservesColimitsOfShape J (forget₂ (ModuleCat.{w'} R) AddCommGrp) where\n\n"}
{"name":"ModuleCat.forget₂PreservesColimitsOfSize","module":"Mathlib.Algebra.Category.ModuleCat.Colimits","initialProofState":"R : Type w\ninst✝¹ : Ring R\ninst✝ : CategoryTheory.Limits.HasColimitsOfSize.{u, v, w', w' + 1} AddCommGrp\n⊢ CategoryTheory.Limits.PreservesColimitsOfSize.{u, v, w', w', max w (w' + 1), w' + 1} (CategoryTheory.forget₂ (ModuleCat R) AddCommGrp)","decl":"noncomputable instance forget₂PreservesColimitsOfSize\n    [HasColimitsOfSize.{u, v} AddCommGrp.{w'}] :\n    PreservesColimitsOfSize.{u, v} (forget₂ (ModuleCat.{w'} R) AddCommGrp) where\n\n"}
{"name":"ModuleCat.instPreservesColimitsOfSizeModuleCatMaxAddCommGrpForget₂OfHasColimitsOfSizeAddCommGrpMax","module":"Mathlib.Algebra.Category.ModuleCat.Colimits","initialProofState":"R : Type w\ninst✝¹ : Ring R\ninst✝ : CategoryTheory.Limits.HasColimitsOfSize.{u, v, max w w', max (w + 1) (w' + 1)} AddCommGrpMax\n⊢ CategoryTheory.Limits.PreservesColimitsOfSize.{u, v, max w w', max w w', max (w + 1) (w' + 1), max (w + 1) (w' + 1)} (CategoryTheory.forget₂ (ModuleCatMax R) AddCommGrp)","decl":"noncomputable instance\n    [HasColimitsOfSize.{u, v} AddCommGrpMax.{w, w'}] :\n    PreservesColimitsOfSize.{u, v} (forget₂ (ModuleCatMax.{w, w'} R) AddCommGrp) where\n\n"}
{"name":"ModuleCat.instHasFiniteColimits","module":"Mathlib.Algebra.Category.ModuleCat.Colimits","initialProofState":"R : Type w\ninst✝ : Ring R\n⊢ CategoryTheory.Limits.HasFiniteColimits (ModuleCat R)","decl":"instance : HasFiniteColimits (ModuleCat.{w'} R) := inferInstance\n\n-- Sanity checks, just to make sure typeclass search can find the instances we want.\n"}
{"name":"ModuleCat.instHasCoequalizers","module":"Mathlib.Algebra.Category.ModuleCat.Colimits","initialProofState":"R : Type w\ninst✝ : Ring R\n⊢ CategoryTheory.Limits.HasCoequalizers (ModuleCat R)","decl":"instance : HasCoequalizers (ModuleCat.{v} R) where\n\n"}
