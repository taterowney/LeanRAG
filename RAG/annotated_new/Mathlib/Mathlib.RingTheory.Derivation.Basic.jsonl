{"name":"Derivation.mk.sizeOf_spec","module":"Mathlib.RingTheory.Derivation.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_3\ninst✝⁸ : CommSemiring R\ninst✝⁷ : CommSemiring A\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Algebra R A\ninst✝⁴ : Module A M\ninst✝³ : Module R M\ninst✝² : SizeOf R\ninst✝¹ : SizeOf A\ninst✝ : SizeOf M\ntoLinearMap : LinearMap (RingHom.id R) A M\nmap_one_eq_zero' : Eq (toLinearMap 1) 0\nleibniz' : ∀ (a b : A), Eq (toLinearMap (HMul.hMul a b)) (HAdd.hAdd (HSMul.hSMul a (toLinearMap b)) (HSMul.hSMul b (toLinearMap a)))\n⊢ Eq (SizeOf.sizeOf { toLinearMap := toLinearMap, map_one_eq_zero' := map_one_eq_zero', leibniz' := leibniz' }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toLinearMap)) (SizeOf.sizeOf map_one_eq_zero'))","decl":"/-- `D : Derivation R A M` is an `R`-linear map from `A` to `M` that satisfies the `leibniz`\nequality. We also require that `D 1 = 0`. See `Derivation.mk'` for a constructor that deduces this\nassumption from the Leibniz rule when `M` is cancellative.\n\nTODO: update this when bimodules are defined. -/\nstructure Derivation (R : Type*) (A : Type*) (M : Type*)\n    [CommSemiring R] [CommSemiring A] [AddCommMonoid M] [Algebra R A] [Module A M] [Module R M]\n    extends A →ₗ[R] M where\n  protected map_one_eq_zero' : toLinearMap 1 = 0\n  protected leibniz' (a b : A) : toLinearMap (a * b) = a • toLinearMap b + b • toLinearMap a\n\n"}
{"name":"Derivation.map_one_eq_zero'","module":"Mathlib.RingTheory.Derivation.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_3\ninst✝⁵ : CommSemiring R\ninst✝⁴ : CommSemiring A\ninst✝³ : AddCommMonoid M\ninst✝² : Algebra R A\ninst✝¹ : Module A M\ninst✝ : Module R M\nself : Derivation R A M\n⊢ Eq (self.toLinearMap 1) 0","decl":"/-- `D : Derivation R A M` is an `R`-linear map from `A` to `M` that satisfies the `leibniz`\nequality. We also require that `D 1 = 0`. See `Derivation.mk'` for a constructor that deduces this\nassumption from the Leibniz rule when `M` is cancellative.\n\nTODO: update this when bimodules are defined. -/\nstructure Derivation (R : Type*) (A : Type*) (M : Type*)\n    [CommSemiring R] [CommSemiring A] [AddCommMonoid M] [Algebra R A] [Module A M] [Module R M]\n    extends A →ₗ[R] M where\n  protected map_one_eq_zero' : toLinearMap 1 = 0\n  protected leibniz' (a b : A) : toLinearMap (a * b) = a • toLinearMap b + b • toLinearMap a\n\n"}
{"name":"Derivation.mk.inj","module":"Mathlib.RingTheory.Derivation.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_3\ninst✝⁵ : CommSemiring R\ninst✝⁴ : CommSemiring A\ninst✝³ : AddCommMonoid M\ninst✝² : Algebra R A\ninst✝¹ : Module A M\ninst✝ : Module R M\ntoLinearMap✝ : LinearMap (RingHom.id R) A M\nmap_one_eq_zero'✝ : Eq (toLinearMap✝ 1) 0\nleibniz'✝ : ∀ (a b : A), Eq (toLinearMap✝ (HMul.hMul a b)) (HAdd.hAdd (HSMul.hSMul a (toLinearMap✝ b)) (HSMul.hSMul b (toLinearMap✝ a)))\ntoLinearMap : LinearMap (RingHom.id R) A M\nmap_one_eq_zero' : Eq (toLinearMap 1) 0\nleibniz' : ∀ (a b : A), Eq (toLinearMap (HMul.hMul a b)) (HAdd.hAdd (HSMul.hSMul a (toLinearMap b)) (HSMul.hSMul b (toLinearMap a)))\nx✝ : Eq { toLinearMap := toLinearMap✝, map_one_eq_zero' := map_one_eq_zero'✝, leibniz' := leibniz'✝ } { toLinearMap := toLinearMap, map_one_eq_zero' := map_one_eq_zero', leibniz' := leibniz' }\n⊢ Eq toLinearMap✝ toLinearMap","decl":"/-- `D : Derivation R A M` is an `R`-linear map from `A` to `M` that satisfies the `leibniz`\nequality. We also require that `D 1 = 0`. See `Derivation.mk'` for a constructor that deduces this\nassumption from the Leibniz rule when `M` is cancellative.\n\nTODO: update this when bimodules are defined. -/\nstructure Derivation (R : Type*) (A : Type*) (M : Type*)\n    [CommSemiring R] [CommSemiring A] [AddCommMonoid M] [Algebra R A] [Module A M] [Module R M]\n    extends A →ₗ[R] M where\n  protected map_one_eq_zero' : toLinearMap 1 = 0\n  protected leibniz' (a b : A) : toLinearMap (a * b) = a • toLinearMap b + b • toLinearMap a\n\n"}
{"name":"Derivation.mk.injEq","module":"Mathlib.RingTheory.Derivation.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_3\ninst✝⁵ : CommSemiring R\ninst✝⁴ : CommSemiring A\ninst✝³ : AddCommMonoid M\ninst✝² : Algebra R A\ninst✝¹ : Module A M\ninst✝ : Module R M\ntoLinearMap✝ : LinearMap (RingHom.id R) A M\nmap_one_eq_zero'✝ : Eq (toLinearMap✝ 1) 0\nleibniz'✝ : ∀ (a b : A), Eq (toLinearMap✝ (HMul.hMul a b)) (HAdd.hAdd (HSMul.hSMul a (toLinearMap✝ b)) (HSMul.hSMul b (toLinearMap✝ a)))\ntoLinearMap : LinearMap (RingHom.id R) A M\nmap_one_eq_zero' : Eq (toLinearMap 1) 0\nleibniz' : ∀ (a b : A), Eq (toLinearMap (HMul.hMul a b)) (HAdd.hAdd (HSMul.hSMul a (toLinearMap b)) (HSMul.hSMul b (toLinearMap a)))\n⊢ Eq (Eq { toLinearMap := toLinearMap✝, map_one_eq_zero' := map_one_eq_zero'✝, leibniz' := leibniz'✝ } { toLinearMap := toLinearMap, map_one_eq_zero' := map_one_eq_zero', leibniz' := leibniz' }) (Eq toLinearMap✝ toLinearMap)","decl":"/-- `D : Derivation R A M` is an `R`-linear map from `A` to `M` that satisfies the `leibniz`\nequality. We also require that `D 1 = 0`. See `Derivation.mk'` for a constructor that deduces this\nassumption from the Leibniz rule when `M` is cancellative.\n\nTODO: update this when bimodules are defined. -/\nstructure Derivation (R : Type*) (A : Type*) (M : Type*)\n    [CommSemiring R] [CommSemiring A] [AddCommMonoid M] [Algebra R A] [Module A M] [Module R M]\n    extends A →ₗ[R] M where\n  protected map_one_eq_zero' : toLinearMap 1 = 0\n  protected leibniz' (a b : A) : toLinearMap (a * b) = a • toLinearMap b + b • toLinearMap a\n\n"}
{"name":"Derivation.leibniz'","module":"Mathlib.RingTheory.Derivation.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_3\ninst✝⁵ : CommSemiring R\ninst✝⁴ : CommSemiring A\ninst✝³ : AddCommMonoid M\ninst✝² : Algebra R A\ninst✝¹ : Module A M\ninst✝ : Module R M\nself : Derivation R A M\na b : A\n⊢ Eq (self.toLinearMap (HMul.hMul a b)) (HAdd.hAdd (HSMul.hSMul a (self.toLinearMap b)) (HSMul.hSMul b (self.toLinearMap a)))","decl":"/-- `D : Derivation R A M` is an `R`-linear map from `A` to `M` that satisfies the `leibniz`\nequality. We also require that `D 1 = 0`. See `Derivation.mk'` for a constructor that deduces this\nassumption from the Leibniz rule when `M` is cancellative.\n\nTODO: update this when bimodules are defined. -/\nstructure Derivation (R : Type*) (A : Type*) (M : Type*)\n    [CommSemiring R] [CommSemiring A] [AddCommMonoid M] [Algebra R A] [Module A M] [Module R M]\n    extends A →ₗ[R] M where\n  protected map_one_eq_zero' : toLinearMap 1 = 0\n  protected leibniz' (a b : A) : toLinearMap (a * b) = a • toLinearMap b + b • toLinearMap a\n\n"}
{"name":"Derivation.instAddMonoidHomClass","module":"Mathlib.RingTheory.Derivation.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_4\ninst✝⁵ : CommSemiring R\ninst✝⁴ : CommSemiring A\ninst✝³ : AddCommMonoid M\ninst✝² : Algebra R A\ninst✝¹ : Module A M\ninst✝ : Module R M\n⊢ AddMonoidHomClass (Derivation R A M) A M","decl":"instance : AddMonoidHomClass (Derivation R A M) A M where\n  map_add D := D.toLinearMap.map_add'\n  map_zero D := D.toLinearMap.map_zero\n\n-- Not a simp lemma because it can be proved via `coeFn_coe` + `toLinearMap_eq_coe`\n"}
{"name":"Derivation.toFun_eq_coe","module":"Mathlib.RingTheory.Derivation.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_4\ninst✝⁵ : CommSemiring R\ninst✝⁴ : CommSemiring A\ninst✝³ : AddCommMonoid M\ninst✝² : Algebra R A\ninst✝¹ : Module A M\ninst✝ : Module R M\nD : Derivation R A M\n⊢ Eq D.toFun ⇑D","decl":"theorem toFun_eq_coe : D.toFun = ⇑D :=\n  rfl\n\n"}
{"name":"Derivation.mk_coe","module":"Mathlib.RingTheory.Derivation.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_4\ninst✝⁵ : CommSemiring R\ninst✝⁴ : CommSemiring A\ninst✝³ : AddCommMonoid M\ninst✝² : Algebra R A\ninst✝¹ : Module A M\ninst✝ : Module R M\nf : LinearMap (RingHom.id R) A M\nh₁ : Eq (f 1) 0\nh₂ : ∀ (a b : A), Eq (f (HMul.hMul a b)) (HAdd.hAdd (HSMul.hSMul a (f b)) (HSMul.hSMul b (f a)))\n⊢ Eq ⇑{ toLinearMap := f, map_one_eq_zero' := h₁, leibniz' := h₂ } ⇑f","decl":"@[simp]\ntheorem mk_coe (f : A →ₗ[R] M) (h₁ h₂) : ((⟨f, h₁, h₂⟩ : Derivation R A M) : A → M) = f :=\n  rfl\n\n"}
{"name":"Derivation.coeFn_coe","module":"Mathlib.RingTheory.Derivation.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_4\ninst✝⁵ : CommSemiring R\ninst✝⁴ : CommSemiring A\ninst✝³ : AddCommMonoid M\ninst✝² : Algebra R A\ninst✝¹ : Module A M\ninst✝ : Module R M\nf : Derivation R A M\n⊢ Eq ⇑↑f ⇑f","decl":"@[simp, norm_cast]\ntheorem coeFn_coe (f : Derivation R A M) : ⇑(f : A →ₗ[R] M) = f :=\n  rfl\n\n"}
{"name":"Derivation.coe_injective","module":"Mathlib.RingTheory.Derivation.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_4\ninst✝⁵ : CommSemiring R\ninst✝⁴ : CommSemiring A\ninst✝³ : AddCommMonoid M\ninst✝² : Algebra R A\ninst✝¹ : Module A M\ninst✝ : Module R M\n⊢ Function.Injective DFunLike.coe","decl":"theorem coe_injective : @Function.Injective (Derivation R A M) (A → M) DFunLike.coe :=\n  DFunLike.coe_injective\n\n"}
{"name":"Derivation.ext_iff","module":"Mathlib.RingTheory.Derivation.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_4\ninst✝⁵ : CommSemiring R\ninst✝⁴ : CommSemiring A\ninst✝³ : AddCommMonoid M\ninst✝² : Algebra R A\ninst✝¹ : Module A M\ninst✝ : Module R M\nD1 D2 : Derivation R A M\n⊢ Iff (Eq D1 D2) (∀ (a : A), Eq (D1 a) (D2 a))","decl":"@[ext]\ntheorem ext (H : ∀ a, D1 a = D2 a) : D1 = D2 :=\n  DFunLike.ext _ _ H\n\n"}
{"name":"Derivation.ext","module":"Mathlib.RingTheory.Derivation.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_4\ninst✝⁵ : CommSemiring R\ninst✝⁴ : CommSemiring A\ninst✝³ : AddCommMonoid M\ninst✝² : Algebra R A\ninst✝¹ : Module A M\ninst✝ : Module R M\nD1 D2 : Derivation R A M\nH : ∀ (a : A), Eq (D1 a) (D2 a)\n⊢ Eq D1 D2","decl":"@[ext]\ntheorem ext (H : ∀ a, D1 a = D2 a) : D1 = D2 :=\n  DFunLike.ext _ _ H\n\n"}
{"name":"Derivation.congr_fun","module":"Mathlib.RingTheory.Derivation.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_4\ninst✝⁵ : CommSemiring R\ninst✝⁴ : CommSemiring A\ninst✝³ : AddCommMonoid M\ninst✝² : Algebra R A\ninst✝¹ : Module A M\ninst✝ : Module R M\nD1 D2 : Derivation R A M\nh : Eq D1 D2\na : A\n⊢ Eq (D1 a) (D2 a)","decl":"theorem congr_fun (h : D1 = D2) (a : A) : D1 a = D2 a :=\n  DFunLike.congr_fun h a\n\n"}
{"name":"Derivation.map_add","module":"Mathlib.RingTheory.Derivation.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_4\ninst✝⁵ : CommSemiring R\ninst✝⁴ : CommSemiring A\ninst✝³ : AddCommMonoid M\ninst✝² : Algebra R A\ninst✝¹ : Module A M\ninst✝ : Module R M\nD : Derivation R A M\na b : A\n⊢ Eq (D (HAdd.hAdd a b)) (HAdd.hAdd (D a) (D b))","decl":"protected theorem map_add : D (a + b) = D a + D b :=\n  map_add D a b\n\n"}
{"name":"Derivation.map_zero","module":"Mathlib.RingTheory.Derivation.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_4\ninst✝⁵ : CommSemiring R\ninst✝⁴ : CommSemiring A\ninst✝³ : AddCommMonoid M\ninst✝² : Algebra R A\ninst✝¹ : Module A M\ninst✝ : Module R M\nD : Derivation R A M\n⊢ Eq (D 0) 0","decl":"protected theorem map_zero : D 0 = 0 :=\n  map_zero D\n\n"}
{"name":"Derivation.map_smul","module":"Mathlib.RingTheory.Derivation.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_4\ninst✝⁵ : CommSemiring R\ninst✝⁴ : CommSemiring A\ninst✝³ : AddCommMonoid M\ninst✝² : Algebra R A\ninst✝¹ : Module A M\ninst✝ : Module R M\nD : Derivation R A M\nr : R\na : A\n⊢ Eq (D (HSMul.hSMul r a)) (HSMul.hSMul r (D a))","decl":"@[simp]\ntheorem map_smul : D (r • a) = r • D a :=\n  D.toLinearMap.map_smul r a\n\n"}
{"name":"Derivation.leibniz","module":"Mathlib.RingTheory.Derivation.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_4\ninst✝⁵ : CommSemiring R\ninst✝⁴ : CommSemiring A\ninst✝³ : AddCommMonoid M\ninst✝² : Algebra R A\ninst✝¹ : Module A M\ninst✝ : Module R M\nD : Derivation R A M\na b : A\n⊢ Eq (D (HMul.hMul a b)) (HAdd.hAdd (HSMul.hSMul a (D b)) (HSMul.hSMul b (D a)))","decl":"@[simp]\ntheorem leibniz : D (a * b) = a • D b + b • D a :=\n  D.leibniz' _ _\n\n"}
{"name":"Derivation.map_smul_of_tower","module":"Mathlib.RingTheory.Derivation.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_4\ninst✝⁸ : CommSemiring R\ninst✝⁷ : CommSemiring A\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Algebra R A\ninst✝⁴ : Module A M\ninst✝³ : Module R M\nS : Type u_5\ninst✝² : SMul S A\ninst✝¹ : SMul S M\ninst✝ : LinearMap.CompatibleSMul A M S R\nD : Derivation R A M\nr : S\na : A\n⊢ Eq (D (HSMul.hSMul r a)) (HSMul.hSMul r (D a))","decl":"@[simp]\ntheorem map_smul_of_tower {S : Type*} [SMul S A] [SMul S M] [LinearMap.CompatibleSMul A M S R]\n    (D : Derivation R A M) (r : S) (a : A) : D (r • a) = r • D a :=\n  D.toLinearMap.map_smul_of_tower r a\n\n"}
{"name":"Derivation.map_one_eq_zero","module":"Mathlib.RingTheory.Derivation.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_4\ninst✝⁵ : CommSemiring R\ninst✝⁴ : CommSemiring A\ninst✝³ : AddCommMonoid M\ninst✝² : Algebra R A\ninst✝¹ : Module A M\ninst✝ : Module R M\nD : Derivation R A M\n⊢ Eq (D 1) 0","decl":"@[simp]\ntheorem map_one_eq_zero : D 1 = 0 :=\n  D.map_one_eq_zero'\n\n"}
{"name":"Derivation.map_algebraMap","module":"Mathlib.RingTheory.Derivation.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_4\ninst✝⁵ : CommSemiring R\ninst✝⁴ : CommSemiring A\ninst✝³ : AddCommMonoid M\ninst✝² : Algebra R A\ninst✝¹ : Module A M\ninst✝ : Module R M\nD : Derivation R A M\nr : R\n⊢ Eq (D ((algebraMap R A) r)) 0","decl":"@[simp]\ntheorem map_algebraMap : D (algebraMap R A r) = 0 := by\n  rw [← mul_one r, RingHom.map_mul, RingHom.map_one, ← smul_def, map_smul, map_one_eq_zero,\n    smul_zero]\n\n"}
{"name":"Derivation.map_natCast","module":"Mathlib.RingTheory.Derivation.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_4\ninst✝⁵ : CommSemiring R\ninst✝⁴ : CommSemiring A\ninst✝³ : AddCommMonoid M\ninst✝² : Algebra R A\ninst✝¹ : Module A M\ninst✝ : Module R M\nD : Derivation R A M\nn : Nat\n⊢ Eq (D ↑n) 0","decl":"@[simp]\ntheorem map_natCast (n : ℕ) : D (n : A) = 0 := by\n  rw [← nsmul_one, D.map_smul_of_tower n, map_one_eq_zero, smul_zero]\n\n"}
{"name":"Derivation.leibniz_pow","module":"Mathlib.RingTheory.Derivation.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_4\ninst✝⁵ : CommSemiring R\ninst✝⁴ : CommSemiring A\ninst✝³ : AddCommMonoid M\ninst✝² : Algebra R A\ninst✝¹ : Module A M\ninst✝ : Module R M\nD : Derivation R A M\na : A\nn : Nat\n⊢ Eq (D (HPow.hPow a n)) (HSMul.hSMul n (HSMul.hSMul (HPow.hPow a (HSub.hSub n 1)) (D a)))","decl":"@[simp]\ntheorem leibniz_pow (n : ℕ) : D (a ^ n) = n • a ^ (n - 1) • D a := by\n  induction' n with n ihn\n  · rw [pow_zero, map_one_eq_zero, zero_smul]\n  · rcases (zero_le n).eq_or_lt with (rfl | hpos)\n    · simp\n    · have : a * a ^ (n - 1) = a ^ n := by rw [← pow_succ', Nat.sub_add_cancel hpos]\n      simp only [pow_succ', leibniz, ihn, smul_comm a n (_ : M), smul_smul a, add_smul, this,\n        Nat.succ_eq_add_one, Nat.add_succ_sub_one, add_zero, one_nsmul]\n\n"}
{"name":"Derivation.map_aeval","module":"Mathlib.RingTheory.Derivation.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_4\ninst✝⁵ : CommSemiring R\ninst✝⁴ : CommSemiring A\ninst✝³ : AddCommMonoid M\ninst✝² : Algebra R A\ninst✝¹ : Module A M\ninst✝ : Module R M\nD : Derivation R A M\nP : Polynomial R\nx : A\n⊢ Eq (D ((Polynomial.aeval x) P)) (HSMul.hSMul ((Polynomial.aeval x) (Polynomial.derivative P)) (D x))","decl":"open Polynomial in\n@[simp]\ntheorem map_aeval (P : R[X]) (x : A) :\n    D (aeval x P) = aeval x (derivative P) • D x := by\n  induction P using Polynomial.induction_on\n  · simp\n  · simp [add_smul, *]\n  · simp [mul_smul, ← Nat.cast_smul_eq_nsmul A]\n\n"}
{"name":"Derivation.eqOn_adjoin","module":"Mathlib.RingTheory.Derivation.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_4\ninst✝⁵ : CommSemiring R\ninst✝⁴ : CommSemiring A\ninst✝³ : AddCommMonoid M\ninst✝² : Algebra R A\ninst✝¹ : Module A M\ninst✝ : Module R M\nD1 D2 : Derivation R A M\ns : Set A\nh : Set.EqOn (⇑D1) (⇑D2) s\n⊢ Set.EqOn ⇑D1 ⇑D2 ↑(Algebra.adjoin R s)","decl":"theorem eqOn_adjoin {s : Set A} (h : Set.EqOn D1 D2 s) : Set.EqOn D1 D2 (adjoin R s) := fun _ hx =>\n  Algebra.adjoin_induction (hx := hx) h\n    (fun r => (D1.map_algebraMap r).trans (D2.map_algebraMap r).symm)\n    (fun x y _ _ hx hy => by simp only [map_add, *]) fun x y _ _ hx hy => by simp only [leibniz, *]\n\n"}
{"name":"Derivation.ext_of_adjoin_eq_top","module":"Mathlib.RingTheory.Derivation.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_4\ninst✝⁵ : CommSemiring R\ninst✝⁴ : CommSemiring A\ninst✝³ : AddCommMonoid M\ninst✝² : Algebra R A\ninst✝¹ : Module A M\ninst✝ : Module R M\nD1 D2 : Derivation R A M\ns : Set A\nhs : Eq (Algebra.adjoin R s) Top.top\nh : Set.EqOn (⇑D1) (⇑D2) s\n⊢ Eq D1 D2","decl":"/-- If adjoin of a set is the whole algebra, then any two derivations equal on this set are equal\non the whole algebra. -/\ntheorem ext_of_adjoin_eq_top (s : Set A) (hs : adjoin R s = ⊤) (h : Set.EqOn D1 D2 s) : D1 = D2 :=\n  ext fun _ => eqOn_adjoin h <| hs.symm ▸ trivial\n\n-- Data typeclasses\n"}
{"name":"Derivation.coe_zero","module":"Mathlib.RingTheory.Derivation.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_4\ninst✝⁵ : CommSemiring R\ninst✝⁴ : CommSemiring A\ninst✝³ : AddCommMonoid M\ninst✝² : Algebra R A\ninst✝¹ : Module A M\ninst✝ : Module R M\n⊢ Eq (⇑0) 0","decl":"@[simp]\ntheorem coe_zero : ⇑(0 : Derivation R A M) = 0 :=\n  rfl\n\n"}
{"name":"Derivation.coe_zero_linearMap","module":"Mathlib.RingTheory.Derivation.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_4\ninst✝⁵ : CommSemiring R\ninst✝⁴ : CommSemiring A\ninst✝³ : AddCommMonoid M\ninst✝² : Algebra R A\ninst✝¹ : Module A M\ninst✝ : Module R M\n⊢ Eq (↑0) 0","decl":"@[simp]\ntheorem coe_zero_linearMap : ↑(0 : Derivation R A M) = (0 : A →ₗ[R] M) :=\n  rfl\n\n"}
{"name":"Derivation.zero_apply","module":"Mathlib.RingTheory.Derivation.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_4\ninst✝⁵ : CommSemiring R\ninst✝⁴ : CommSemiring A\ninst✝³ : AddCommMonoid M\ninst✝² : Algebra R A\ninst✝¹ : Module A M\ninst✝ : Module R M\na : A\n⊢ Eq (0 a) 0","decl":"theorem zero_apply (a : A) : (0 : Derivation R A M) a = 0 :=\n  rfl\n\n"}
{"name":"Derivation.coe_add","module":"Mathlib.RingTheory.Derivation.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_4\ninst✝⁵ : CommSemiring R\ninst✝⁴ : CommSemiring A\ninst✝³ : AddCommMonoid M\ninst✝² : Algebra R A\ninst✝¹ : Module A M\ninst✝ : Module R M\nD1 D2 : Derivation R A M\n⊢ Eq (⇑(HAdd.hAdd D1 D2)) (HAdd.hAdd ⇑D1 ⇑D2)","decl":"@[simp]\ntheorem coe_add (D1 D2 : Derivation R A M) : ⇑(D1 + D2) = D1 + D2 :=\n  rfl\n\n"}
{"name":"Derivation.coe_add_linearMap","module":"Mathlib.RingTheory.Derivation.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_4\ninst✝⁵ : CommSemiring R\ninst✝⁴ : CommSemiring A\ninst✝³ : AddCommMonoid M\ninst✝² : Algebra R A\ninst✝¹ : Module A M\ninst✝ : Module R M\nD1 D2 : Derivation R A M\n⊢ Eq (↑(HAdd.hAdd D1 D2)) (HAdd.hAdd ↑D1 ↑D2)","decl":"@[simp]\ntheorem coe_add_linearMap (D1 D2 : Derivation R A M) : ↑(D1 + D2) = (D1 + D2 : A →ₗ[R] M) :=\n  rfl\n\n"}
{"name":"Derivation.add_apply","module":"Mathlib.RingTheory.Derivation.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_4\ninst✝⁵ : CommSemiring R\ninst✝⁴ : CommSemiring A\ninst✝³ : AddCommMonoid M\ninst✝² : Algebra R A\ninst✝¹ : Module A M\ninst✝ : Module R M\nD1 D2 : Derivation R A M\na : A\n⊢ Eq ((HAdd.hAdd D1 D2) a) (HAdd.hAdd (D1 a) (D2 a))","decl":"theorem add_apply : (D1 + D2) a = D1 a + D2 a :=\n  rfl\n\n"}
{"name":"Derivation.coe_smul","module":"Mathlib.RingTheory.Derivation.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_4\ninst✝⁹ : CommSemiring R\ninst✝⁸ : CommSemiring A\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Algebra R A\ninst✝⁵ : Module A M\ninst✝⁴ : Module R M\nS : Type u_5\ninst✝³ : Monoid S\ninst✝² : DistribMulAction S M\ninst✝¹ : SMulCommClass R S M\ninst✝ : SMulCommClass S A M\nr : S\nD : Derivation R A M\n⊢ Eq (⇑(HSMul.hSMul r D)) (HSMul.hSMul r ⇑D)","decl":"@[simp]\ntheorem coe_smul (r : S) (D : Derivation R A M) : ⇑(r • D) = r • ⇑D :=\n  rfl\n\n"}
{"name":"Derivation.coe_smul_linearMap","module":"Mathlib.RingTheory.Derivation.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_4\ninst✝⁹ : CommSemiring R\ninst✝⁸ : CommSemiring A\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Algebra R A\ninst✝⁵ : Module A M\ninst✝⁴ : Module R M\nS : Type u_5\ninst✝³ : Monoid S\ninst✝² : DistribMulAction S M\ninst✝¹ : SMulCommClass R S M\ninst✝ : SMulCommClass S A M\nr : S\nD : Derivation R A M\n⊢ Eq (↑(HSMul.hSMul r D)) (HSMul.hSMul r ↑D)","decl":"@[simp]\ntheorem coe_smul_linearMap (r : S) (D : Derivation R A M) : ↑(r • D) = r • (D : A →ₗ[R] M) :=\n  rfl\n\n"}
{"name":"Derivation.smul_apply","module":"Mathlib.RingTheory.Derivation.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_4\ninst✝⁹ : CommSemiring R\ninst✝⁸ : CommSemiring A\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Algebra R A\ninst✝⁵ : Module A M\ninst✝⁴ : Module R M\na : A\nS : Type u_5\ninst✝³ : Monoid S\ninst✝² : DistribMulAction S M\ninst✝¹ : SMulCommClass R S M\ninst✝ : SMulCommClass S A M\nr : S\nD : Derivation R A M\n⊢ Eq ((HSMul.hSMul r D) a) (HSMul.hSMul r (D a))","decl":"theorem smul_apply (r : S) (D : Derivation R A M) : (r • D) a = r • D a :=\n  rfl\n\n"}
{"name":"Derivation.instIsCentralScalar","module":"Mathlib.RingTheory.Derivation.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_4\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : CommSemiring A\ninst✝⁸ : AddCommMonoid M\ninst✝⁷ : Algebra R A\ninst✝⁶ : Module A M\ninst✝⁵ : Module R M\nS : Type u_5\ninst✝⁴ : Monoid S\ninst✝³ : DistribMulAction S M\ninst✝² : SMulCommClass R S M\ninst✝¹ : DistribMulAction (MulOpposite S) M\ninst✝ : IsCentralScalar S M\n⊢ IsCentralScalar S (Derivation R A M)","decl":"instance [DistribMulAction Sᵐᵒᵖ M] [IsCentralScalar S M] :\n    IsCentralScalar S (Derivation R A M) where\n  op_smul_eq_smul _ _ := ext fun _ => op_smul_eq_smul _ _\n\n"}
{"name":"Derivation.instIsScalarTower","module":"Mathlib.RingTheory.Derivation.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_4\ninst✝¹³ : CommSemiring R\ninst✝¹² : CommSemiring A\ninst✝¹¹ : AddCommMonoid M\ninst✝¹⁰ : Algebra R A\ninst✝⁹ : Module A M\ninst✝⁸ : Module R M\nS : Type u_5\nT : Type u_6\ninst✝⁷ : Monoid S\ninst✝⁶ : DistribMulAction S M\ninst✝⁵ : SMulCommClass R S M\ninst✝⁴ : Monoid T\ninst✝³ : DistribMulAction T M\ninst✝² : SMulCommClass R T M\ninst✝¹ : SMul S T\ninst✝ : IsScalarTower S T M\n⊢ IsScalarTower S T (Derivation R A M)","decl":"instance [SMul S T] [IsScalarTower S T M] : IsScalarTower S T (Derivation R A M) :=\n  ⟨fun _ _ _ => ext fun _ => smul_assoc _ _ _⟩\n\n"}
{"name":"Derivation.instSMulCommClass","module":"Mathlib.RingTheory.Derivation.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_4\ninst✝¹² : CommSemiring R\ninst✝¹¹ : CommSemiring A\ninst✝¹⁰ : AddCommMonoid M\ninst✝⁹ : Algebra R A\ninst✝⁸ : Module A M\ninst✝⁷ : Module R M\nS : Type u_5\nT : Type u_6\ninst✝⁶ : Monoid S\ninst✝⁵ : DistribMulAction S M\ninst✝⁴ : SMulCommClass R S M\ninst✝³ : Monoid T\ninst✝² : DistribMulAction T M\ninst✝¹ : SMulCommClass R T M\ninst✝ : SMulCommClass S T M\n⊢ SMulCommClass S T (Derivation R A M)","decl":"instance [SMulCommClass S T M] : SMulCommClass S T (Derivation R A M) :=\n  ⟨fun _ _ _ => ext fun _ => smul_comm _ _ _⟩\n\n"}
{"name":"Derivation.coe_to_linearMap_comp","module":"Mathlib.RingTheory.Derivation.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_4\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : CommSemiring A\ninst✝⁸ : AddCommMonoid M\ninst✝⁷ : Algebra R A\ninst✝⁶ : Module A M\ninst✝⁵ : Module R M\nD : Derivation R A M\nN : Type u_5\ninst✝⁴ : AddCommMonoid N\ninst✝³ : Module A N\ninst✝² : Module R N\ninst✝¹ : IsScalarTower R A M\ninst✝ : IsScalarTower R A N\nf : LinearMap (RingHom.id A) M N\n⊢ Eq (↑(f.compDer D)) ((↑R f).comp ↑D)","decl":"@[simp]\ntheorem coe_to_linearMap_comp : (f.compDer D : A →ₗ[R] N) = (f : M →ₗ[R] N).comp (D : A →ₗ[R] M) :=\n  rfl\n\n"}
{"name":"Derivation.coe_comp","module":"Mathlib.RingTheory.Derivation.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_4\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : CommSemiring A\ninst✝⁸ : AddCommMonoid M\ninst✝⁷ : Algebra R A\ninst✝⁶ : Module A M\ninst✝⁵ : Module R M\nD : Derivation R A M\nN : Type u_5\ninst✝⁴ : AddCommMonoid N\ninst✝³ : Module A N\ninst✝² : Module R N\ninst✝¹ : IsScalarTower R A M\ninst✝ : IsScalarTower R A N\nf : LinearMap (RingHom.id A) M N\n⊢ Eq ⇑(f.compDer D) ⇑((↑R f).comp ↑D)","decl":"@[simp]\ntheorem coe_comp : (f.compDer D : A → N) = (f : M →ₗ[R] N).comp (D : A →ₗ[R] M) :=\n  rfl\n\n"}
{"name":"Derivation.llcomp_apply","module":"Mathlib.RingTheory.Derivation.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_4\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : CommSemiring A\ninst✝⁸ : AddCommMonoid M\ninst✝⁷ : Algebra R A\ninst✝⁶ : Module A M\ninst✝⁵ : Module R M\nN : Type u_5\ninst✝⁴ : AddCommMonoid N\ninst✝³ : Module A N\ninst✝² : Module R N\ninst✝¹ : IsScalarTower R A M\ninst✝ : IsScalarTower R A N\nf : LinearMap (RingHom.id A) M N\n⊢ Eq (Derivation.llcomp f) f.compDer","decl":"/-- The composition of a derivation with a linear map as a bilinear map -/\n@[simps]\ndef llcomp : (M →ₗ[A] N) →ₗ[A] Derivation R A M →ₗ[R] Derivation R A N where\n  toFun f := f.compDer\n  map_add' f₁ f₂ := by ext; rfl\n  map_smul' r D := by ext; rfl\n\n"}
{"name":"Derivation.linearEquiv_coe_to_linearMap_comp","module":"Mathlib.RingTheory.Derivation.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_4\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : CommSemiring A\ninst✝⁸ : AddCommMonoid M\ninst✝⁷ : Algebra R A\ninst✝⁶ : Module A M\ninst✝⁵ : Module R M\nD : Derivation R A M\nN : Type u_5\ninst✝⁴ : AddCommMonoid N\ninst✝³ : Module A N\ninst✝² : Module R N\ninst✝¹ : IsScalarTower R A M\ninst✝ : IsScalarTower R A N\ne : LinearEquiv (RingHom.id A) M N\n⊢ Eq (↑(e.compDer D)) ((↑R ↑e).comp ↑D)","decl":"@[simp]\ntheorem linearEquiv_coe_to_linearMap_comp :\n    (e.compDer D : A →ₗ[R] N) = (e.toLinearMap : M →ₗ[R] N).comp (D : A →ₗ[R] M) :=\n  rfl\n\n"}
{"name":"Derivation.linearEquiv_coe_comp","module":"Mathlib.RingTheory.Derivation.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_4\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : CommSemiring A\ninst✝⁸ : AddCommMonoid M\ninst✝⁷ : Algebra R A\ninst✝⁶ : Module A M\ninst✝⁵ : Module R M\nD : Derivation R A M\nN : Type u_5\ninst✝⁴ : AddCommMonoid N\ninst✝³ : Module A N\ninst✝² : Module R N\ninst✝¹ : IsScalarTower R A M\ninst✝ : IsScalarTower R A N\ne : LinearEquiv (RingHom.id A) M N\n⊢ Eq ⇑(e.compDer D) ⇑((↑R ↑e).comp ↑D)","decl":"@[simp]\ntheorem linearEquiv_coe_comp :\n    (e.compDer D : A → N) = (e.toLinearMap : M →ₗ[R] N).comp (D : A →ₗ[R] M) :=\n  rfl\n\n"}
{"name":"Derivation.compAlgebraMap_apply","module":"Mathlib.RingTheory.Derivation.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\nM : Type u_4\ninst✝¹¹ : CommSemiring R\ninst✝¹⁰ : CommSemiring A\ninst✝⁹ : CommSemiring B\ninst✝⁸ : AddCommMonoid M\ninst✝⁷ : Algebra R A\ninst✝⁶ : Algebra R B\ninst✝⁵ : Module A M\ninst✝⁴ : Module B M\ninst✝³ : Module R M\ninst✝² : Algebra A B\ninst✝¹ : IsScalarTower R A B\ninst✝ : IsScalarTower A B M\nd : Derivation R B M\na✝ : A\n⊢ Eq ((Derivation.compAlgebraMap A d) a✝) (d ((algebraMap A B) a✝))","decl":"variable (A) in\n/-- For a tower `R → A → B` and an `R`-derivation `B → M`, we may compose with `A → B` to obtain an\n`R`-derivation `A → M`. -/\n@[simps!]\ndef compAlgebraMap [Algebra A B] [IsScalarTower R A B] [IsScalarTower A B M]\n    (d : Derivation R B M) : Derivation R A M where\n  map_one_eq_zero' := by simp\n  leibniz' a b := by simp\n  toLinearMap := d.toLinearMap.comp (IsScalarTower.toAlgHom R A B).toLinearMap\n\n"}
{"name":"Derivation.coe_restrictScalars","module":"Mathlib.RingTheory.Derivation.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_4\ninst✝⁹ : CommSemiring R\ninst✝⁸ : CommSemiring A\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Algebra R A\ninst✝⁵ : Module A M\ninst✝⁴ : Module R M\nS : Type u_5\ninst✝³ : CommSemiring S\ninst✝² : Algebra S A\ninst✝¹ : Module S M\ninst✝ : LinearMap.CompatibleSMul A M R S\nd : Derivation S A M\n⊢ Eq ⇑(Derivation.restrictScalars R d) ⇑d","decl":"lemma coe_restrictScalars (d : Derivation S A M) : ⇑(d.restrictScalars R) = ⇑d := rfl\n\n"}
{"name":"Derivation.restrictScalars_apply","module":"Mathlib.RingTheory.Derivation.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_4\ninst✝⁹ : CommSemiring R\ninst✝⁸ : CommSemiring A\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Algebra R A\ninst✝⁵ : Module A M\ninst✝⁴ : Module R M\nS : Type u_5\ninst✝³ : CommSemiring S\ninst✝² : Algebra S A\ninst✝¹ : Module S M\ninst✝ : LinearMap.CompatibleSMul A M R S\nd : Derivation S A M\nx : A\n⊢ Eq ((Derivation.restrictScalars R d) x) (d x)","decl":"@[simp]\nlemma restrictScalars_apply (d : Derivation S A M) (x : A) : d.restrictScalars R x = d x := rfl\n\n"}
{"name":"Derivation.liftOfRightInverse_apply","module":"Mathlib.RingTheory.Derivation.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_3\ninst✝⁶ : CommSemiring R\ninst✝⁵ : CommRing A\ninst✝⁴ : CommRing M\ninst✝³ : Algebra R A\ninst✝² : Algebra R M\nF : Type u_4\ninst✝¹ : FunLike F A M\ninst✝ : AlgHomClass F R A M\nf : F\nf_inv : M → A\nhf : Function.RightInverse f_inv ⇑f\nd : Derivation R A A\nhd : ∀ (x : A), Eq (f x) 0 → Eq (f (d x)) 0\nx : A\n⊢ Eq ((Derivation.liftOfRightInverse hf hd) (f x)) (f (d x))","decl":"@[simp]\nlemma liftOfRightInverse_apply {f : F} {f_inv : M → A} (hf : Function.RightInverse f_inv f)\n    {d : Derivation R A A} (hd : ∀ x, f x = 0 → f (d x) = 0) (x : A) :\n    Derivation.liftOfRightInverse hf hd (f x) = f (d x) := by\n  suffices f (d (f_inv (f x) - x)) = 0 by simpa [sub_eq_zero]\n  apply hd\n  simp [hf _]\n\n"}
{"name":"Derivation.liftOfSurjective_apply","module":"Mathlib.RingTheory.Derivation.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_3\ninst✝⁶ : CommSemiring R\ninst✝⁵ : CommRing A\ninst✝⁴ : CommRing M\ninst✝³ : Algebra R A\ninst✝² : Algebra R M\nF : Type u_4\ninst✝¹ : FunLike F A M\ninst✝ : AlgHomClass F R A M\nf : F\nhf : Function.Surjective ⇑f\nd : Derivation R A A\nhd : ∀ (x : A), Eq (f x) 0 → Eq (f (d x)) 0\nx : A\n⊢ Eq ((Derivation.liftOfSurjective hf hd) (f x)) (f (d x))","decl":"lemma liftOfSurjective_apply {f : F} (hf : Function.Surjective f)\n    {d : Derivation R A A} (hd : ∀ x, f x = 0 → f (d x) = 0) (x : A) :\n    Derivation.liftOfSurjective hf hd (f x) = f (d x) := by simp\n\n"}
{"name":"Derivation.coe_mk'","module":"Mathlib.RingTheory.Derivation.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommSemiring R\nA : Type u_2\ninst✝⁴ : CommSemiring A\ninst✝³ : Algebra R A\nM : Type u_3\ninst✝² : AddCancelCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Module A M\nD : LinearMap (RingHom.id R) A M\nh : ∀ (a b : A), Eq (D (HMul.hMul a b)) (HAdd.hAdd (HSMul.hSMul a (D b)) (HSMul.hSMul b (D a)))\n⊢ Eq ⇑(Derivation.mk' D h) ⇑D","decl":"@[simp]\ntheorem coe_mk' (D : A →ₗ[R] M) (h) : ⇑(mk' D h) = D :=\n  rfl\n\n"}
{"name":"Derivation.coe_mk'_linearMap","module":"Mathlib.RingTheory.Derivation.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommSemiring R\nA : Type u_2\ninst✝⁴ : CommSemiring A\ninst✝³ : Algebra R A\nM : Type u_3\ninst✝² : AddCancelCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Module A M\nD : LinearMap (RingHom.id R) A M\nh : ∀ (a b : A), Eq (D (HMul.hMul a b)) (HAdd.hAdd (HSMul.hSMul a (D b)) (HSMul.hSMul b (D a)))\n⊢ Eq (↑(Derivation.mk' D h)) D","decl":"@[simp]\ntheorem coe_mk'_linearMap (D : A →ₗ[R] M) (h) : (mk' D h : A →ₗ[R] M) = D :=\n  rfl\n\n"}
{"name":"Derivation.map_neg","module":"Mathlib.RingTheory.Derivation.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommRing R\nA : Type u_2\ninst✝⁴ : CommRing A\ninst✝³ : Algebra R A\nM : Type u_3\ninst✝² : AddCommGroup M\ninst✝¹ : Module A M\ninst✝ : Module R M\nD : Derivation R A M\na : A\n⊢ Eq (D (Neg.neg a)) (Neg.neg (D a))","decl":"protected theorem map_neg : D (-a) = -D a :=\n  map_neg D a\n\n"}
{"name":"Derivation.map_sub","module":"Mathlib.RingTheory.Derivation.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommRing R\nA : Type u_2\ninst✝⁴ : CommRing A\ninst✝³ : Algebra R A\nM : Type u_3\ninst✝² : AddCommGroup M\ninst✝¹ : Module A M\ninst✝ : Module R M\nD : Derivation R A M\na b : A\n⊢ Eq (D (HSub.hSub a b)) (HSub.hSub (D a) (D b))","decl":"protected theorem map_sub : D (a - b) = D a - D b :=\n  map_sub D a b\n\n"}
{"name":"Derivation.map_intCast","module":"Mathlib.RingTheory.Derivation.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommRing R\nA : Type u_2\ninst✝⁴ : CommRing A\ninst✝³ : Algebra R A\nM : Type u_3\ninst✝² : AddCommGroup M\ninst✝¹ : Module A M\ninst✝ : Module R M\nD : Derivation R A M\nn : Int\n⊢ Eq (D ↑n) 0","decl":"@[simp]\ntheorem map_intCast (n : ℤ) : D (n : A) = 0 := by\n  rw [← zsmul_one, D.map_smul_of_tower n, map_one_eq_zero, smul_zero]\n\n"}
{"name":"Derivation.leibniz_of_mul_eq_one","module":"Mathlib.RingTheory.Derivation.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommRing R\nA : Type u_2\ninst✝⁴ : CommRing A\ninst✝³ : Algebra R A\nM : Type u_3\ninst✝² : AddCommGroup M\ninst✝¹ : Module A M\ninst✝ : Module R M\nD : Derivation R A M\na b : A\nh : Eq (HMul.hMul a b) 1\n⊢ Eq (D a) (HSMul.hSMul (Neg.neg (HPow.hPow a 2)) (D b))","decl":"theorem leibniz_of_mul_eq_one {a b : A} (h : a * b = 1) : D a = -a ^ 2 • D b := by\n  rw [neg_smul]\n  refine eq_neg_of_add_eq_zero_left ?_\n  calc\n    D a + a ^ 2 • D b = a • b • D a + a • a • D b := by simp only [smul_smul, h, one_smul, sq]\n    _ = a • D (a * b) := by rw [leibniz, smul_add, add_comm]\n    _ = 0 := by rw [h, map_one_eq_zero, smul_zero]\n\n"}
{"name":"Derivation.leibniz_invOf","module":"Mathlib.RingTheory.Derivation.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommRing R\nA : Type u_2\ninst✝⁵ : CommRing A\ninst✝⁴ : Algebra R A\nM : Type u_3\ninst✝³ : AddCommGroup M\ninst✝² : Module A M\ninst✝¹ : Module R M\nD : Derivation R A M\na : A\ninst✝ : Invertible a\n⊢ Eq (D (Invertible.invOf a)) (HSMul.hSMul (Neg.neg (HPow.hPow (Invertible.invOf a) 2)) (D a))","decl":"theorem leibniz_invOf [Invertible a] : D (⅟ a) = -⅟ a ^ 2 • D a :=\n  D.leibniz_of_mul_eq_one <| invOf_mul_self a\n\n"}
{"name":"Derivation.leibniz_inv","module":"Mathlib.RingTheory.Derivation.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommRing R\nM : Type u_3\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\nK : Type u_4\ninst✝² : Field K\ninst✝¹ : Module K M\ninst✝ : Algebra R K\nD : Derivation R K M\na : K\n⊢ Eq (D (Inv.inv a)) (HSMul.hSMul (Neg.neg (HPow.hPow (Inv.inv a) 2)) (D a))","decl":"theorem leibniz_inv (a : K) : D a⁻¹ = -a⁻¹ ^ 2 • D a := by\n  rcases eq_or_ne a 0 with (rfl | ha)\n  · simp\n  · exact D.leibniz_of_mul_eq_one (inv_mul_cancel₀ ha)\n\n"}
{"name":"Derivation.leibniz_div","module":"Mathlib.RingTheory.Derivation.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommRing R\nM : Type u_3\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\nK : Type u_4\ninst✝² : Field K\ninst✝¹ : Module K M\ninst✝ : Algebra R K\nD : Derivation R K M\na b : K\n⊢ Eq (D (HDiv.hDiv a b)) (HSMul.hSMul (HPow.hPow (Inv.inv b) 2) (HSub.hSub (HSMul.hSMul b (D a)) (HSMul.hSMul a (D b))))","decl":"theorem leibniz_div (a b : K) : D (a / b) = b⁻¹ ^ 2 • (b • D a - a • D b) := by\n  simp only [div_eq_mul_inv, leibniz, leibniz_inv, inv_pow, neg_smul, smul_neg, smul_smul, add_comm,\n    sub_eq_add_neg, smul_add]\n  rw [← inv_mul_mul_self b⁻¹, inv_inv]\n  ring_nf\n\n"}
{"name":"Derivation.leibniz_div_const","module":"Mathlib.RingTheory.Derivation.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommRing R\nM : Type u_3\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\nK : Type u_4\ninst✝² : Field K\ninst✝¹ : Module K M\ninst✝ : Algebra R K\nD : Derivation R K M\na b : K\nh : Eq (D b) 0\n⊢ Eq (D (HDiv.hDiv a b)) (HSMul.hSMul (Inv.inv b) (D a))","decl":"theorem leibniz_div_const (a b : K) (h : D b = 0) : D (a / b) = b⁻¹ • D a := by\n  simp only [leibniz_div, inv_pow, h, smul_zero, sub_zero, smul_smul]\n  rw [← mul_self_mul_inv b⁻¹, inv_inv]\n  ring_nf\n\n"}
{"name":"Derivation.leibniz_zpow","module":"Mathlib.RingTheory.Derivation.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommRing R\nM : Type u_3\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\nK : Type u_4\ninst✝² : Field K\ninst✝¹ : Module K M\ninst✝ : Algebra R K\nD : Derivation R K M\na : K\nn : Int\n⊢ Eq (D (HPow.hPow a n)) (HSMul.hSMul n (HSMul.hSMul (HPow.hPow a (HSub.hSub n 1)) (D a)))","decl":"lemma leibniz_zpow (a : K) (n : ℤ) : D (a ^ n) = n • a ^ (n - 1) • D a := by\n  by_cases hn : n = 0\n  · simp [hn]\n  by_cases ha : a = 0\n  · simp [ha, zero_zpow n hn]\n  rcases Int.natAbs_eq n with h | h\n  · rw [h]\n    simp only [zpow_natCast, leibniz_pow, natCast_zsmul]\n    rw [← zpow_natCast]\n    congr\n    omega\n  · rw [h, zpow_neg, zpow_natCast, leibniz_inv, leibniz_pow, inv_pow, ← pow_mul, ← zpow_natCast,\n      ← zpow_natCast, ← Nat.cast_smul_eq_nsmul K, ← Int.cast_smul_eq_zsmul K, smul_smul, smul_smul,\n      smul_smul]\n    trans (-n.natAbs * (a ^ ((n.natAbs - 1 : ℕ) : ℤ) / (a ^ ((n.natAbs * 2 : ℕ) : ℤ)))) • D a\n    · ring_nf\n    rw [← zpow_sub₀ ha]\n    congr 3\n    · norm_cast\n    omega\n\n"}
{"name":"Derivation.coe_neg","module":"Mathlib.RingTheory.Derivation.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommRing R\nA : Type u_2\ninst✝⁴ : CommRing A\ninst✝³ : Algebra R A\nM : Type u_3\ninst✝² : AddCommGroup M\ninst✝¹ : Module A M\ninst✝ : Module R M\nD : Derivation R A M\n⊢ Eq (⇑(Neg.neg D)) (Neg.neg ⇑D)","decl":"@[simp]\ntheorem coe_neg (D : Derivation R A M) : ⇑(-D) = -D :=\n  rfl\n\n"}
{"name":"Derivation.coe_neg_linearMap","module":"Mathlib.RingTheory.Derivation.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommRing R\nA : Type u_2\ninst✝⁴ : CommRing A\ninst✝³ : Algebra R A\nM : Type u_3\ninst✝² : AddCommGroup M\ninst✝¹ : Module A M\ninst✝ : Module R M\nD : Derivation R A M\n⊢ Eq (↑(Neg.neg D)) (Neg.neg ↑D)","decl":"@[simp]\ntheorem coe_neg_linearMap (D : Derivation R A M) : ↑(-D) = (-D : A →ₗ[R] M) :=\n  rfl\n\n"}
{"name":"Derivation.neg_apply","module":"Mathlib.RingTheory.Derivation.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommRing R\nA : Type u_2\ninst✝⁴ : CommRing A\ninst✝³ : Algebra R A\nM : Type u_3\ninst✝² : AddCommGroup M\ninst✝¹ : Module A M\ninst✝ : Module R M\nD : Derivation R A M\na : A\n⊢ Eq ((Neg.neg D) a) (Neg.neg (D a))","decl":"theorem neg_apply : (-D) a = -D a :=\n  rfl\n\n"}
{"name":"Derivation.coe_sub","module":"Mathlib.RingTheory.Derivation.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommRing R\nA : Type u_2\ninst✝⁴ : CommRing A\ninst✝³ : Algebra R A\nM : Type u_3\ninst✝² : AddCommGroup M\ninst✝¹ : Module A M\ninst✝ : Module R M\nD1 D2 : Derivation R A M\n⊢ Eq (⇑(HSub.hSub D1 D2)) (HSub.hSub ⇑D1 ⇑D2)","decl":"@[simp]\ntheorem coe_sub (D1 D2 : Derivation R A M) : ⇑(D1 - D2) = D1 - D2 :=\n  rfl\n\n"}
{"name":"Derivation.coe_sub_linearMap","module":"Mathlib.RingTheory.Derivation.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommRing R\nA : Type u_2\ninst✝⁴ : CommRing A\ninst✝³ : Algebra R A\nM : Type u_3\ninst✝² : AddCommGroup M\ninst✝¹ : Module A M\ninst✝ : Module R M\nD1 D2 : Derivation R A M\n⊢ Eq (↑(HSub.hSub D1 D2)) (HSub.hSub ↑D1 ↑D2)","decl":"@[simp]\ntheorem coe_sub_linearMap (D1 D2 : Derivation R A M) : ↑(D1 - D2) = (D1 - D2 : A →ₗ[R] M) :=\n  rfl\n\n"}
{"name":"Derivation.sub_apply","module":"Mathlib.RingTheory.Derivation.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommRing R\nA : Type u_2\ninst✝⁴ : CommRing A\ninst✝³ : Algebra R A\nM : Type u_3\ninst✝² : AddCommGroup M\ninst✝¹ : Module A M\ninst✝ : Module R M\nD1 D2 : Derivation R A M\na : A\n⊢ Eq ((HSub.hSub D1 D2) a) (HSub.hSub (D1 a) (D2 a))","decl":"theorem sub_apply : (D1 - D2) a = D1 a - D2 a :=\n  rfl\n\n"}
