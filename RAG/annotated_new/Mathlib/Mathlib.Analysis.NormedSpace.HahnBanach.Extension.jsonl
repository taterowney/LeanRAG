{"name":"Real.exists_extension_norm_eq","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Extension","initialProofState":"E : Type u_1\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace Real E\np : Subspace Real E\nf : ContinuousLinearMap (RingHom.id Real) (Subtype fun x => Membership.mem p x) Real\nâŠ¢ Exists fun g => And (âˆ€ (x : Subtype fun x => Membership.mem p x), Eq (g â†‘x) (f x)) (Eq (Norm.norm g) (Norm.norm f))","decl":"/-- **Hahn-Banach theorem** for continuous linear functions over `â„`.\nSee also `exists_extension_norm_eq` in the root namespace for a more general version\nthat works both for `â„` and `â„‚`. -/\ntheorem exists_extension_norm_eq (p : Subspace â„ E) (f : p â†’L[â„] â„) :\n    âˆƒ g : E â†’L[â„] â„, (âˆ€ x : p, g x = f x) âˆ§ â€–gâ€– = â€–fâ€– := by\n  rcases exists_extension_of_le_sublinear âŸ¨p, fâŸ© (fun x => â€–fâ€– * â€–xâ€–)\n      (fun c hc x => by simp only [norm_smul c x, Real.norm_eq_abs, abs_of_pos hc, mul_left_comm])\n      (fun x y => by -- Porting note: placeholder filled here\n        rw [â† left_distrib]\n        exact mul_le_mul_of_nonneg_left (norm_add_le x y) (@norm_nonneg _ _ f))\n      fun x => le_trans (le_abs_self _) (f.le_opNorm _) with âŸ¨g, g_eq, g_leâŸ©\n  set g' :=\n    g.mkContinuous â€–fâ€– fun x => abs_le.2 âŸ¨neg_le.1 <| g.map_neg x â–¸ norm_neg x â–¸ g_le (-x), g_le xâŸ©\n  refine âŸ¨g', g_eq, ?_âŸ©\n  apply le_antisymm (g.mkContinuous_norm_le (norm_nonneg f) _)\n  refine f.opNorm_le_bound (norm_nonneg _) fun x => ?_\n  dsimp at g_eq\n  rw [â† g_eq]\n  apply g'.le_opNorm\n\n"}
{"name":"exists_extension_norm_eq","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Extension","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ğ•œ\ninstâœÂ² : IsRCLikeNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\np : Subspace ğ•œ E\nf : ContinuousLinearMap (RingHom.id ğ•œ) (Subtype fun x => Membership.mem p x) ğ•œ\nâŠ¢ Exists fun g => And (âˆ€ (x : Subtype fun x => Membership.mem p x), Eq (g â†‘x) (f x)) (Eq (Norm.norm g) (Norm.norm f))","decl":"/-- **Hahn-Banach theorem** for continuous linear functions over `ğ•œ`\nsatisfying `IsRCLikeNormedField ğ•œ`. -/\ntheorem exists_extension_norm_eq (p : Subspace ğ•œ E) (f : p â†’L[ğ•œ] ğ•œ) :\n    âˆƒ g : E â†’L[ğ•œ] ğ•œ, (âˆ€ x : p, g x = f x) âˆ§ â€–gâ€– = â€–fâ€– := by\n  letI : RCLike ğ•œ := IsRCLikeNormedField.rclike ğ•œ\n  letI : Module â„ E := RestrictScalars.module â„ ğ•œ E\n  letI : IsScalarTower â„ ğ•œ E := RestrictScalars.isScalarTower _ _ _\n  letI : NormedSpace â„ E := NormedSpace.restrictScalars _ ğ•œ _\n  -- Let `fr: p â†’L[â„] â„` be the real part of `f`.\n  let fr := reCLM.comp (f.restrictScalars â„)\n  -- Use the real version to get a norm-preserving extension of `fr`, which\n  -- we'll call `g : E â†’L[â„] â„`.\n  rcases Real.exists_extension_norm_eq (p.restrictScalars â„) fr with âŸ¨g, âŸ¨hextends, hnormeqâŸ©âŸ©\n  -- Now `g` can be extended to the `E â†’L[ğ•œ] ğ•œ` we need.\n  refine âŸ¨g.extendToğ•œ, ?_âŸ©\n  -- It is an extension of `f`.\n  have h : âˆ€ x : p, g.extendToğ•œ x = f x := by\n    intro x\n    -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n    erw [ContinuousLinearMap.extendToğ•œ_apply, â† Submodule.coe_smul, hextends, hextends]\n    have :\n        (fr x : ğ•œ) - I * â†‘(fr ((I : ğ•œ) â€¢ x)) = (re (f x) : ğ•œ) - (I : ğ•œ) * re (f ((I : ğ•œ) â€¢ x)) := by\n      rfl\n    -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n    erw [this]\n    apply ext\n    Â· simp only [add_zero, Algebra.id.smul_eq_mul, I_re, ofReal_im, AddMonoidHom.map_add, zero_sub,\n        I_im', zero_mul, ofReal_re, eq_self_iff_true, sub_zero, mul_neg, ofReal_neg,\n        mul_re, mul_zero, sub_neg_eq_add, ContinuousLinearMap.map_smul]\n    Â· simp only [Algebra.id.smul_eq_mul, I_re, ofReal_im, AddMonoidHom.map_add, zero_sub, I_im',\n        zero_mul, ofReal_re, mul_neg, mul_im, zero_add, ofReal_neg, mul_re,\n        sub_neg_eq_add, ContinuousLinearMap.map_smul]\n  -- And we derive the equality of the norms by bounding on both sides.\n  refine âŸ¨h, le_antisymm ?_ ?_âŸ©\n  Â· calc\n      â€–g.extendToğ•œâ€– = â€–gâ€– := g.norm_extendToğ•œ\n      _ = â€–frâ€– := hnormeq\n      _ â‰¤ â€–reCLMâ€– * â€–fâ€– := ContinuousLinearMap.opNorm_comp_le _ _\n      _ = â€–fâ€– := by rw [reCLM_norm, one_mul]\n  Â· exact f.opNorm_le_bound g.extendToğ•œ.opNorm_nonneg fun x => h x â–¸ g.extendToğ•œ.le_opNorm x\n\n"}
{"name":"ContinuousLinearMap.exist_extension_of_finiteDimensional_range","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Extension","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : IsRCLikeNormedField ğ•œ\nE : Type u_2\nF : Type u_3\ninstâœâ´ : SeminormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\np : Submodule ğ•œ E\nf : ContinuousLinearMap (RingHom.id ğ•œ) (Subtype fun x => Membership.mem p x) F\ninstâœ : FiniteDimensional ğ•œ (Subtype fun x => Membership.mem (LinearMap.range f) x)\nâŠ¢ Exists fun g => Eq f (g.comp p.subtypeL)","decl":"/-- Corollary of the **Hahn-Banach theorem**: if `f : p â†’ F` is a continuous linear map\nfrom a submodule of a normed space `E` over `ğ•œ`, `ğ•œ = â„` or `ğ•œ = â„‚`,\nwith a finite dimensional range, then `f` admits an extension to a continuous linear map `E â†’ F`.\n\nNote that contrary to the case `F = ğ•œ`, see `exists_extension_norm_eq`,\nwe provide no estimates on the norm of the extension.\n-/\nlemma ContinuousLinearMap.exist_extension_of_finiteDimensional_range {p : Submodule ğ•œ E}\n    (f : p â†’L[ğ•œ] F) [FiniteDimensional ğ•œ (LinearMap.range f)] :\n    âˆƒ g : E â†’L[ğ•œ] F, f = g.comp p.subtypeL := by\n  letI : RCLike ğ•œ := IsRCLikeNormedField.rclike ğ•œ\n  set b := Module.finBasis ğ•œ (LinearMap.range f)\n  set e := b.equivFunL\n  set fi := fun i â†¦ (LinearMap.toContinuousLinearMap (b.coord i)).comp\n    (f.codRestrict _ <| LinearMap.mem_range_self _)\n  choose gi hgf _ using fun i â†¦ exists_extension_norm_eq p (fi i)\n  use (LinearMap.range f).subtypeL.comp <| e.symm.toContinuousLinearMap.comp (.pi gi)\n  ext x\n  simp [fi, e, hgf]\n\n"}
{"name":"Submodule.ClosedComplemented.of_finiteDimensional","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Extension","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : IsRCLikeNormedField ğ•œ\nF : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\np : Submodule ğ•œ F\ninstâœ : FiniteDimensional ğ•œ (Subtype fun x => Membership.mem p x)\nâŠ¢ p.ClosedComplemented","decl":"/-- A finite dimensional submodule over `â„` or `â„‚` is `Submodule.ClosedComplemented`. -/\nlemma Submodule.ClosedComplemented.of_finiteDimensional (p : Submodule ğ•œ F)\n    [FiniteDimensional ğ•œ p] : p.ClosedComplemented :=\n  let âŸ¨g, hgâŸ© := (ContinuousLinearMap.id ğ•œ p).exist_extension_of_finiteDimensional_range\n  âŸ¨g, DFunLike.congr_fun hg.symmâŸ©\n\n"}
{"name":"coord_norm'","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Extension","initialProofState":"ğ•œ : Type v\ninstâœÂ² : RCLike ğ•œ\nE : Type u\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nx : E\nh : Ne x 0\nâŠ¢ Eq (Norm.norm (HSMul.hSMul (â†‘(Norm.norm x)) (ContinuousLinearEquiv.coord ğ•œ x h))) 1","decl":"theorem coord_norm' {x : E} (h : x â‰  0) : â€–(â€–xâ€– : ğ•œ) â€¢ coord ğ•œ x hâ€– = 1 := by\n  #adaptation_note /-- https://github.com/leanprover/lean4/pull/4119\n  `set_option maxSynthPendingDepth 2` required after https://github.com/leanprover/lean4/pull/4119\n  Alternatively, we can add:\n  ```\n  let X : SeminormedAddCommGroup (â†¥(span ğ•œ {x}) â†’L[ğ•œ] ğ•œ) := inferInstance\n  have : BoundedSMul ğ•œ (â†¥(span ğ•œ {x}) â†’L[ğ•œ] ğ•œ) := @NormedSpace.boundedSMul ğ•œ _ _ X _\n  ```\n  -/\n  set_option maxSynthPendingDepth 2 in\n  rw [norm_smul (Î± := ğ•œ) (x := coord ğ•œ x h), RCLike.norm_coe_norm, coord_norm,\n    mul_inv_cancelâ‚€ (mt norm_eq_zero.mp h)]\n\n"}
{"name":"exists_dual_vector","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Extension","initialProofState":"ğ•œ : Type v\ninstâœÂ² : RCLike ğ•œ\nE : Type u\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nx : E\nh : Ne x 0\nâŠ¢ Exists fun g => And (Eq (Norm.norm g) 1) (Eq (g x) â†‘(Norm.norm x))","decl":"/-- Corollary of Hahn-Banach. Given a nonzero element `x` of a normed space, there exists an\n    element of the dual space, of norm `1`, whose value on `x` is `â€–xâ€–`. -/\ntheorem exists_dual_vector (x : E) (h : x â‰  0) : âˆƒ g : E â†’L[ğ•œ] ğ•œ, â€–gâ€– = 1 âˆ§ g x = â€–xâ€– := by\n  let p : Submodule ğ•œ E := ğ•œ âˆ™ x\n  let f := (â€–xâ€– : ğ•œ) â€¢ coord ğ•œ x h\n  obtain âŸ¨g, hgâŸ© := exists_extension_norm_eq p f\n  refine âŸ¨g, ?_, ?_âŸ©\n  Â· rw [hg.2, coord_norm']\n  Â· calc\n      g x = g (âŸ¨x, mem_span_singleton_self xâŸ© : ğ•œ âˆ™ x) := by rw [coe_mk]\n      _ = ((â€–xâ€– : ğ•œ) â€¢ coord ğ•œ x h) (âŸ¨x, mem_span_singleton_self xâŸ© : ğ•œ âˆ™ x) := by rw [â† hg.1]\n      _ = â€–xâ€– := by simp\n\n"}
{"name":"exists_dual_vector'","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Extension","initialProofState":"ğ•œ : Type v\ninstâœÂ³ : RCLike ğ•œ\nE : Type u\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ğ•œ E\ninstâœ : Nontrivial E\nx : E\nâŠ¢ Exists fun g => And (Eq (Norm.norm g) 1) (Eq (g x) â†‘(Norm.norm x))","decl":"/-- Variant of Hahn-Banach, eliminating the hypothesis that `x` be nonzero, and choosing\n    the dual element arbitrarily when `x = 0`. -/\ntheorem exists_dual_vector' [Nontrivial E] (x : E) : âˆƒ g : E â†’L[ğ•œ] ğ•œ, â€–gâ€– = 1 âˆ§ g x = â€–xâ€– := by\n  by_cases hx : x = 0\n  Â· obtain âŸ¨y, hyâŸ© := exists_ne (0 : E)\n    obtain âŸ¨g, hgâŸ© : âˆƒ g : E â†’L[ğ•œ] ğ•œ, â€–gâ€– = 1 âˆ§ g y = â€–yâ€– := exists_dual_vector ğ•œ y hy\n    refine âŸ¨g, hg.left, ?_âŸ©\n    simp [hx]\n  Â· exact exists_dual_vector ğ•œ x hx\n\n"}
{"name":"exists_dual_vector''","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Extension","initialProofState":"ğ•œ : Type v\ninstâœÂ² : RCLike ğ•œ\nE : Type u\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nx : E\nâŠ¢ Exists fun g => And (LE.le (Norm.norm g) 1) (Eq (g x) â†‘(Norm.norm x))","decl":"/-- Variant of Hahn-Banach, eliminating the hypothesis that `x` be nonzero, but only ensuring that\n    the dual element has norm at most `1` (this can not be improved for the trivial\n    vector space). -/\ntheorem exists_dual_vector'' (x : E) : âˆƒ g : E â†’L[ğ•œ] ğ•œ, â€–gâ€– â‰¤ 1 âˆ§ g x = â€–xâ€– := by\n  by_cases hx : x = 0\n  Â· refine âŸ¨0, by simp, ?_âŸ©\n    symm\n    simp [hx]\n  Â· rcases exists_dual_vector ğ•œ x hx with âŸ¨g, g_norm, g_eqâŸ©\n    exact âŸ¨g, g_norm.le, g_eqâŸ©\n\n"}
