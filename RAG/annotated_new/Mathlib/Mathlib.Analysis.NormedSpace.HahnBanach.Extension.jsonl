{"name":"Real.exists_extension_norm_eq","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Extension","initialProofState":"E : Type u_1\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : NormedSpace Real E\np : Subspace Real E\nf : ContinuousLinearMap (RingHom.id Real) (Subtype fun x => Membership.mem p x) Real\n⊢ Exists fun g => And (∀ (x : Subtype fun x => Membership.mem p x), Eq (g ↑x) (f x)) (Eq (Norm.norm g) (Norm.norm f))","decl":"/-- **Hahn-Banach theorem** for continuous linear functions over `ℝ`.\nSee also `exists_extension_norm_eq` in the root namespace for a more general version\nthat works both for `ℝ` and `ℂ`. -/\ntheorem exists_extension_norm_eq (p : Subspace ℝ E) (f : p →L[ℝ] ℝ) :\n    ∃ g : E →L[ℝ] ℝ, (∀ x : p, g x = f x) ∧ ‖g‖ = ‖f‖ := by\n  rcases exists_extension_of_le_sublinear ⟨p, f⟩ (fun x => ‖f‖ * ‖x‖)\n      (fun c hc x => by simp only [norm_smul c x, Real.norm_eq_abs, abs_of_pos hc, mul_left_comm])\n      (fun x y => by -- Porting note: placeholder filled here\n        rw [← left_distrib]\n        exact mul_le_mul_of_nonneg_left (norm_add_le x y) (@norm_nonneg _ _ f))\n      fun x => le_trans (le_abs_self _) (f.le_opNorm _) with ⟨g, g_eq, g_le⟩\n  set g' :=\n    g.mkContinuous ‖f‖ fun x => abs_le.2 ⟨neg_le.1 <| g.map_neg x ▸ norm_neg x ▸ g_le (-x), g_le x⟩\n  refine ⟨g', g_eq, ?_⟩\n  apply le_antisymm (g.mkContinuous_norm_le (norm_nonneg f) _)\n  refine f.opNorm_le_bound (norm_nonneg _) fun x => ?_\n  dsimp at g_eq\n  rw [← g_eq]\n  apply g'.le_opNorm\n\n"}
{"name":"exists_extension_norm_eq","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Extension","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\ninst✝² : IsRCLikeNormedField 𝕜\nE : Type u_2\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\np : Subspace 𝕜 E\nf : ContinuousLinearMap (RingHom.id 𝕜) (Subtype fun x => Membership.mem p x) 𝕜\n⊢ Exists fun g => And (∀ (x : Subtype fun x => Membership.mem p x), Eq (g ↑x) (f x)) (Eq (Norm.norm g) (Norm.norm f))","decl":"/-- **Hahn-Banach theorem** for continuous linear functions over `𝕜`\nsatisfying `IsRCLikeNormedField 𝕜`. -/\ntheorem exists_extension_norm_eq (p : Subspace 𝕜 E) (f : p →L[𝕜] 𝕜) :\n    ∃ g : E →L[𝕜] 𝕜, (∀ x : p, g x = f x) ∧ ‖g‖ = ‖f‖ := by\n  letI : RCLike 𝕜 := IsRCLikeNormedField.rclike 𝕜\n  letI : Module ℝ E := RestrictScalars.module ℝ 𝕜 E\n  letI : IsScalarTower ℝ 𝕜 E := RestrictScalars.isScalarTower _ _ _\n  letI : NormedSpace ℝ E := NormedSpace.restrictScalars _ 𝕜 _\n  -- Let `fr: p →L[ℝ] ℝ` be the real part of `f`.\n  let fr := reCLM.comp (f.restrictScalars ℝ)\n  -- Use the real version to get a norm-preserving extension of `fr`, which\n  -- we'll call `g : E →L[ℝ] ℝ`.\n  rcases Real.exists_extension_norm_eq (p.restrictScalars ℝ) fr with ⟨g, ⟨hextends, hnormeq⟩⟩\n  -- Now `g` can be extended to the `E →L[𝕜] 𝕜` we need.\n  refine ⟨g.extendTo𝕜, ?_⟩\n  -- It is an extension of `f`.\n  have h : ∀ x : p, g.extendTo𝕜 x = f x := by\n    intro x\n    -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n    erw [ContinuousLinearMap.extendTo𝕜_apply, ← Submodule.coe_smul, hextends, hextends]\n    have :\n        (fr x : 𝕜) - I * ↑(fr ((I : 𝕜) • x)) = (re (f x) : 𝕜) - (I : 𝕜) * re (f ((I : 𝕜) • x)) := by\n      rfl\n    -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n    erw [this]\n    apply ext\n    · simp only [add_zero, Algebra.id.smul_eq_mul, I_re, ofReal_im, AddMonoidHom.map_add, zero_sub,\n        I_im', zero_mul, ofReal_re, eq_self_iff_true, sub_zero, mul_neg, ofReal_neg,\n        mul_re, mul_zero, sub_neg_eq_add, ContinuousLinearMap.map_smul]\n    · simp only [Algebra.id.smul_eq_mul, I_re, ofReal_im, AddMonoidHom.map_add, zero_sub, I_im',\n        zero_mul, ofReal_re, mul_neg, mul_im, zero_add, ofReal_neg, mul_re,\n        sub_neg_eq_add, ContinuousLinearMap.map_smul]\n  -- And we derive the equality of the norms by bounding on both sides.\n  refine ⟨h, le_antisymm ?_ ?_⟩\n  · calc\n      ‖g.extendTo𝕜‖ = ‖g‖ := g.norm_extendTo𝕜\n      _ = ‖fr‖ := hnormeq\n      _ ≤ ‖reCLM‖ * ‖f‖ := ContinuousLinearMap.opNorm_comp_le _ _\n      _ = ‖f‖ := by rw [reCLM_norm, one_mul]\n  · exact f.opNorm_le_bound g.extendTo𝕜.opNorm_nonneg fun x => h x ▸ g.extendTo𝕜.le_opNorm x\n\n"}
{"name":"ContinuousLinearMap.exist_extension_of_finiteDimensional_range","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Extension","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : IsRCLikeNormedField 𝕜\nE : Type u_2\nF : Type u_3\ninst✝⁴ : SeminormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\np : Submodule 𝕜 E\nf : ContinuousLinearMap (RingHom.id 𝕜) (Subtype fun x => Membership.mem p x) F\ninst✝ : FiniteDimensional 𝕜 (Subtype fun x => Membership.mem (LinearMap.range f) x)\n⊢ Exists fun g => Eq f (g.comp p.subtypeL)","decl":"/-- Corollary of the **Hahn-Banach theorem**: if `f : p → F` is a continuous linear map\nfrom a submodule of a normed space `E` over `𝕜`, `𝕜 = ℝ` or `𝕜 = ℂ`,\nwith a finite dimensional range, then `f` admits an extension to a continuous linear map `E → F`.\n\nNote that contrary to the case `F = 𝕜`, see `exists_extension_norm_eq`,\nwe provide no estimates on the norm of the extension.\n-/\nlemma ContinuousLinearMap.exist_extension_of_finiteDimensional_range {p : Submodule 𝕜 E}\n    (f : p →L[𝕜] F) [FiniteDimensional 𝕜 (LinearMap.range f)] :\n    ∃ g : E →L[𝕜] F, f = g.comp p.subtypeL := by\n  letI : RCLike 𝕜 := IsRCLikeNormedField.rclike 𝕜\n  set b := Module.finBasis 𝕜 (LinearMap.range f)\n  set e := b.equivFunL\n  set fi := fun i ↦ (LinearMap.toContinuousLinearMap (b.coord i)).comp\n    (f.codRestrict _ <| LinearMap.mem_range_self _)\n  choose gi hgf _ using fun i ↦ exists_extension_norm_eq p (fi i)\n  use (LinearMap.range f).subtypeL.comp <| e.symm.toContinuousLinearMap.comp (.pi gi)\n  ext x\n  simp [fi, e, hgf]\n\n"}
{"name":"Submodule.ClosedComplemented.of_finiteDimensional","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Extension","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : IsRCLikeNormedField 𝕜\nF : Type u_3\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\np : Submodule 𝕜 F\ninst✝ : FiniteDimensional 𝕜 (Subtype fun x => Membership.mem p x)\n⊢ p.ClosedComplemented","decl":"/-- A finite dimensional submodule over `ℝ` or `ℂ` is `Submodule.ClosedComplemented`. -/\nlemma Submodule.ClosedComplemented.of_finiteDimensional (p : Submodule 𝕜 F)\n    [FiniteDimensional 𝕜 p] : p.ClosedComplemented :=\n  let ⟨g, hg⟩ := (ContinuousLinearMap.id 𝕜 p).exist_extension_of_finiteDimensional_range\n  ⟨g, DFunLike.congr_fun hg.symm⟩\n\n"}
{"name":"coord_norm'","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Extension","initialProofState":"𝕜 : Type v\ninst✝² : RCLike 𝕜\nE : Type u\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nx : E\nh : Ne x 0\n⊢ Eq (Norm.norm (HSMul.hSMul (↑(Norm.norm x)) (ContinuousLinearEquiv.coord 𝕜 x h))) 1","decl":"theorem coord_norm' {x : E} (h : x ≠ 0) : ‖(‖x‖ : 𝕜) • coord 𝕜 x h‖ = 1 := by\n  #adaptation_note /-- https://github.com/leanprover/lean4/pull/4119\n  `set_option maxSynthPendingDepth 2` required after https://github.com/leanprover/lean4/pull/4119\n  Alternatively, we can add:\n  ```\n  let X : SeminormedAddCommGroup (↥(span 𝕜 {x}) →L[𝕜] 𝕜) := inferInstance\n  have : BoundedSMul 𝕜 (↥(span 𝕜 {x}) →L[𝕜] 𝕜) := @NormedSpace.boundedSMul 𝕜 _ _ X _\n  ```\n  -/\n  set_option maxSynthPendingDepth 2 in\n  rw [norm_smul (α := 𝕜) (x := coord 𝕜 x h), RCLike.norm_coe_norm, coord_norm,\n    mul_inv_cancel₀ (mt norm_eq_zero.mp h)]\n\n"}
{"name":"exists_dual_vector","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Extension","initialProofState":"𝕜 : Type v\ninst✝² : RCLike 𝕜\nE : Type u\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nx : E\nh : Ne x 0\n⊢ Exists fun g => And (Eq (Norm.norm g) 1) (Eq (g x) ↑(Norm.norm x))","decl":"/-- Corollary of Hahn-Banach. Given a nonzero element `x` of a normed space, there exists an\n    element of the dual space, of norm `1`, whose value on `x` is `‖x‖`. -/\ntheorem exists_dual_vector (x : E) (h : x ≠ 0) : ∃ g : E →L[𝕜] 𝕜, ‖g‖ = 1 ∧ g x = ‖x‖ := by\n  let p : Submodule 𝕜 E := 𝕜 ∙ x\n  let f := (‖x‖ : 𝕜) • coord 𝕜 x h\n  obtain ⟨g, hg⟩ := exists_extension_norm_eq p f\n  refine ⟨g, ?_, ?_⟩\n  · rw [hg.2, coord_norm']\n  · calc\n      g x = g (⟨x, mem_span_singleton_self x⟩ : 𝕜 ∙ x) := by rw [coe_mk]\n      _ = ((‖x‖ : 𝕜) • coord 𝕜 x h) (⟨x, mem_span_singleton_self x⟩ : 𝕜 ∙ x) := by rw [← hg.1]\n      _ = ‖x‖ := by simp\n\n"}
{"name":"exists_dual_vector'","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Extension","initialProofState":"𝕜 : Type v\ninst✝³ : RCLike 𝕜\nE : Type u\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : Nontrivial E\nx : E\n⊢ Exists fun g => And (Eq (Norm.norm g) 1) (Eq (g x) ↑(Norm.norm x))","decl":"/-- Variant of Hahn-Banach, eliminating the hypothesis that `x` be nonzero, and choosing\n    the dual element arbitrarily when `x = 0`. -/\ntheorem exists_dual_vector' [Nontrivial E] (x : E) : ∃ g : E →L[𝕜] 𝕜, ‖g‖ = 1 ∧ g x = ‖x‖ := by\n  by_cases hx : x = 0\n  · obtain ⟨y, hy⟩ := exists_ne (0 : E)\n    obtain ⟨g, hg⟩ : ∃ g : E →L[𝕜] 𝕜, ‖g‖ = 1 ∧ g y = ‖y‖ := exists_dual_vector 𝕜 y hy\n    refine ⟨g, hg.left, ?_⟩\n    simp [hx]\n  · exact exists_dual_vector 𝕜 x hx\n\n"}
{"name":"exists_dual_vector''","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Extension","initialProofState":"𝕜 : Type v\ninst✝² : RCLike 𝕜\nE : Type u\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nx : E\n⊢ Exists fun g => And (LE.le (Norm.norm g) 1) (Eq (g x) ↑(Norm.norm x))","decl":"/-- Variant of Hahn-Banach, eliminating the hypothesis that `x` be nonzero, but only ensuring that\n    the dual element has norm at most `1` (this can not be improved for the trivial\n    vector space). -/\ntheorem exists_dual_vector'' (x : E) : ∃ g : E →L[𝕜] 𝕜, ‖g‖ ≤ 1 ∧ g x = ‖x‖ := by\n  by_cases hx : x = 0\n  · refine ⟨0, by simp, ?_⟩\n    symm\n    simp [hx]\n  · rcases exists_dual_vector 𝕜 x hx with ⟨g, g_norm, g_eq⟩\n    exact ⟨g, g_norm.le, g_eq⟩\n\n"}
