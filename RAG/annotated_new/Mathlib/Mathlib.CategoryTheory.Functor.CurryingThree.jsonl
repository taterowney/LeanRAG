{"name":"CategoryTheory.curry‚ÇÉ_obj_map_app_app","module":"Mathlib.CategoryTheory.Functor.CurryingThree","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_4\nE : Type u_9\ninst‚úù¬≥ : CategoryTheory.Category.{u_10, u_1} C‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u_11, u_2} C‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{u_12, u_4} C‚ÇÉ\ninst‚úù : CategoryTheory.Category.{u_13, u_9} E\nF : CategoryTheory.Functor (Prod C‚ÇÅ (Prod C‚ÇÇ C‚ÇÉ)) E\nX‚ÇÅ Y‚ÇÅ : C‚ÇÅ\nf : Quiver.Hom X‚ÇÅ Y‚ÇÅ\nX‚ÇÇ : C‚ÇÇ\nX‚ÇÉ : C‚ÇÉ\n‚ä¢ Eq ((((CategoryTheory.curry‚ÇÉ.obj F).map f).app X‚ÇÇ).app X‚ÇÉ) (F.map { fst := f, snd := { fst := CategoryTheory.CategoryStruct.id X‚ÇÇ, snd := CategoryTheory.CategoryStruct.id X‚ÇÉ } })","decl":"@[simp]\nlemma curry‚ÇÉ_obj_map_app_app (F : C‚ÇÅ √ó C‚ÇÇ √ó C‚ÇÉ ‚•§ E)\n    {X‚ÇÅ Y‚ÇÅ : C‚ÇÅ} (f : X‚ÇÅ ‚ü∂ Y‚ÇÅ) (X‚ÇÇ : C‚ÇÇ) (X‚ÇÉ : C‚ÇÉ) :\n    (((curry‚ÇÉ.obj F).map f).app X‚ÇÇ).app X‚ÇÉ = F.map ‚ü®f, ùüô X‚ÇÇ, ùüô X‚ÇÉ‚ü© := rfl\n\n"}
{"name":"CategoryTheory.curry‚ÇÉ_obj_obj_map_app","module":"Mathlib.CategoryTheory.Functor.CurryingThree","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_4\nE : Type u_9\ninst‚úù¬≥ : CategoryTheory.Category.{u_10, u_1} C‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u_11, u_2} C‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{u_12, u_4} C‚ÇÉ\ninst‚úù : CategoryTheory.Category.{u_13, u_9} E\nF : CategoryTheory.Functor (Prod C‚ÇÅ (Prod C‚ÇÇ C‚ÇÉ)) E\nX‚ÇÅ : C‚ÇÅ\nX‚ÇÇ Y‚ÇÇ : C‚ÇÇ\nf : Quiver.Hom X‚ÇÇ Y‚ÇÇ\nX‚ÇÉ : C‚ÇÉ\n‚ä¢ Eq ((((CategoryTheory.curry‚ÇÉ.obj F).obj X‚ÇÅ).map f).app X‚ÇÉ) (F.map { fst := CategoryTheory.CategoryStruct.id X‚ÇÅ, snd := { fst := f, snd := CategoryTheory.CategoryStruct.id X‚ÇÉ } })","decl":"@[simp]\nlemma curry‚ÇÉ_obj_obj_map_app (F : C‚ÇÅ √ó C‚ÇÇ √ó C‚ÇÉ ‚•§ E)\n    (X‚ÇÅ : C‚ÇÅ) {X‚ÇÇ Y‚ÇÇ : C‚ÇÇ} (f : X‚ÇÇ ‚ü∂ Y‚ÇÇ) (X‚ÇÉ : C‚ÇÉ) :\n    (((curry‚ÇÉ.obj F).obj X‚ÇÅ).map f).app X‚ÇÉ = F.map ‚ü®ùüô X‚ÇÅ, f, ùüô X‚ÇÉ‚ü© := rfl\n\n"}
{"name":"CategoryTheory.curry‚ÇÉ_obj_obj_obj_map","module":"Mathlib.CategoryTheory.Functor.CurryingThree","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_4\nE : Type u_9\ninst‚úù¬≥ : CategoryTheory.Category.{u_10, u_1} C‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u_11, u_2} C‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{u_12, u_4} C‚ÇÉ\ninst‚úù : CategoryTheory.Category.{u_13, u_9} E\nF : CategoryTheory.Functor (Prod C‚ÇÅ (Prod C‚ÇÇ C‚ÇÉ)) E\nX‚ÇÅ : C‚ÇÅ\nX‚ÇÇ : C‚ÇÇ\nX‚ÇÉ Y‚ÇÉ : C‚ÇÉ\nf : Quiver.Hom X‚ÇÉ Y‚ÇÉ\n‚ä¢ Eq ((((CategoryTheory.curry‚ÇÉ.obj F).obj X‚ÇÅ).obj X‚ÇÇ).map f) (F.map { fst := CategoryTheory.CategoryStruct.id X‚ÇÅ, snd := { fst := CategoryTheory.CategoryStruct.id X‚ÇÇ, snd := f } })","decl":"@[simp]\nlemma curry‚ÇÉ_obj_obj_obj_map (F : C‚ÇÅ √ó C‚ÇÇ √ó C‚ÇÉ ‚•§ E)\n    (X‚ÇÅ : C‚ÇÅ) (X‚ÇÇ : C‚ÇÇ) {X‚ÇÉ Y‚ÇÉ : C‚ÇÉ} (f : X‚ÇÉ ‚ü∂ Y‚ÇÉ) :\n    (((curry‚ÇÉ.obj F).obj X‚ÇÅ).obj X‚ÇÇ).map f = F.map ‚ü®ùüô X‚ÇÅ, ùüô X‚ÇÇ, f‚ü© := rfl\n\n"}
{"name":"CategoryTheory.curry‚ÇÉ_map_app_app_app","module":"Mathlib.CategoryTheory.Functor.CurryingThree","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_4\nE : Type u_9\ninst‚úù¬≥ : CategoryTheory.Category.{u_10, u_1} C‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u_11, u_2} C‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{u_12, u_4} C‚ÇÉ\ninst‚úù : CategoryTheory.Category.{u_13, u_9} E\nF G : CategoryTheory.Functor (Prod C‚ÇÅ (Prod C‚ÇÇ C‚ÇÉ)) E\nf : Quiver.Hom F G\nX‚ÇÅ : C‚ÇÅ\nX‚ÇÇ : C‚ÇÇ\nX‚ÇÉ : C‚ÇÉ\n‚ä¢ Eq ((((CategoryTheory.curry‚ÇÉ.map f).app X‚ÇÅ).app X‚ÇÇ).app X‚ÇÉ) (f.app { fst := X‚ÇÅ, snd := { fst := X‚ÇÇ, snd := X‚ÇÉ } })","decl":"@[simp]\nlemma curry‚ÇÉ_map_app_app_app {F G : C‚ÇÅ √ó C‚ÇÇ √ó C‚ÇÉ ‚•§ E} (f : F ‚ü∂ G)\n    (X‚ÇÅ : C‚ÇÅ) (X‚ÇÇ : C‚ÇÇ) (X‚ÇÉ : C‚ÇÉ) :\n    (((curry‚ÇÉ.map f).app X‚ÇÅ).app X‚ÇÇ).app X‚ÇÉ = f.app ‚ü®X‚ÇÅ, X‚ÇÇ, X‚ÇÉ‚ü© := rfl\n\n"}
{"name":"CategoryTheory.currying‚ÇÉ_unitIso_hom_app_app_app_app","module":"Mathlib.CategoryTheory.Functor.CurryingThree","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_4\nE : Type u_9\ninst‚úù¬≥ : CategoryTheory.Category.{u_10, u_1} C‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u_13, u_2} C‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{u_12, u_4} C‚ÇÉ\ninst‚úù : CategoryTheory.Category.{u_11, u_9} E\nF : CategoryTheory.Functor C‚ÇÅ (CategoryTheory.Functor C‚ÇÇ (CategoryTheory.Functor C‚ÇÉ E))\nX‚ÇÅ : C‚ÇÅ\nX‚ÇÇ : C‚ÇÇ\nX‚ÇÉ : C‚ÇÉ\n‚ä¢ Eq ((((CategoryTheory.currying‚ÇÉ.unitIso.hom.app F).app X‚ÇÅ).app X‚ÇÇ).app X‚ÇÉ) (CategoryTheory.CategoryStruct.id (((((CategoryTheory.Functor.id (CategoryTheory.Functor C‚ÇÅ (CategoryTheory.Functor C‚ÇÇ (CategoryTheory.Functor C‚ÇÉ E)))).obj F).obj X‚ÇÅ).obj X‚ÇÇ).obj X‚ÇÉ))","decl":"@[simp]\nlemma currying‚ÇÉ_unitIso_hom_app_app_app_app (F : C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ C‚ÇÉ ‚•§ E)\n    (X‚ÇÅ : C‚ÇÅ) (X‚ÇÇ : C‚ÇÇ) (X‚ÇÉ : C‚ÇÉ) :\n    (((currying‚ÇÉ.unitIso.hom.app F).app X‚ÇÅ).app X‚ÇÇ).app X‚ÇÉ = ùüô _ := by\n  simp [currying‚ÇÉ, Equivalence.unit]\n\n"}
{"name":"CategoryTheory.currying‚ÇÉ_unitIso_inv_app_app_app_app","module":"Mathlib.CategoryTheory.Functor.CurryingThree","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_4\nE : Type u_9\ninst‚úù¬≥ : CategoryTheory.Category.{u_10, u_1} C‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u_13, u_2} C‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{u_12, u_4} C‚ÇÉ\ninst‚úù : CategoryTheory.Category.{u_11, u_9} E\nF : CategoryTheory.Functor C‚ÇÅ (CategoryTheory.Functor C‚ÇÇ (CategoryTheory.Functor C‚ÇÉ E))\nX‚ÇÅ : C‚ÇÅ\nX‚ÇÇ : C‚ÇÇ\nX‚ÇÉ : C‚ÇÉ\n‚ä¢ Eq ((((CategoryTheory.currying‚ÇÉ.unitIso.inv.app F).app X‚ÇÅ).app X‚ÇÇ).app X‚ÇÉ) (CategoryTheory.CategoryStruct.id (((((CategoryTheory.currying‚ÇÉ.functor.comp CategoryTheory.currying‚ÇÉ.inverse).obj F).obj X‚ÇÅ).obj X‚ÇÇ).obj X‚ÇÉ))","decl":"@[simp]\nlemma currying‚ÇÉ_unitIso_inv_app_app_app_app (F : C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ C‚ÇÉ ‚•§ E)\n    (X‚ÇÅ : C‚ÇÅ) (X‚ÇÇ : C‚ÇÇ) (X‚ÇÉ : C‚ÇÉ) :\n    (((currying‚ÇÉ.unitIso.inv.app F).app X‚ÇÅ).app X‚ÇÇ).app X‚ÇÉ = ùüô _ := by\n  simp [currying‚ÇÉ, Equivalence.unitInv]\n\n"}
{"name":"CategoryTheory.curry‚ÇÉObjProdComp_inv_app_app_app","module":"Mathlib.CategoryTheory.Functor.CurryingThree","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_4\nD‚ÇÅ : Type u_6\nD‚ÇÇ : Type u_7\nD‚ÇÉ : Type u_8\nE : Type u_9\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_10, u_1} C‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{u_11, u_2} C‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_12, u_4} C‚ÇÉ\ninst‚úù¬≥ : CategoryTheory.Category.{u_13, u_6} D‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u_14, u_7} D‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{u_15, u_8} D‚ÇÉ\ninst‚úù : CategoryTheory.Category.{u_16, u_9} E\nF‚ÇÅ : CategoryTheory.Functor C‚ÇÅ D‚ÇÅ\nF‚ÇÇ : CategoryTheory.Functor C‚ÇÇ D‚ÇÇ\nF‚ÇÉ : CategoryTheory.Functor C‚ÇÉ D‚ÇÉ\nG : CategoryTheory.Functor (Prod D‚ÇÅ (Prod D‚ÇÇ D‚ÇÉ)) E\nX‚úù¬π : C‚ÇÅ\nX‚úù : C‚ÇÇ\nX : C‚ÇÉ\n‚ä¢ Eq ((((CategoryTheory.curry‚ÇÉObjProdComp F‚ÇÅ F‚ÇÇ F‚ÇÉ G).inv.app X‚úù¬π).app X‚úù).app X) (CategoryTheory.CategoryStruct.id ((((CategoryTheory.curry‚ÇÉ.obj ((F‚ÇÅ.prod (F‚ÇÇ.prod F‚ÇÉ)).comp G)).obj X‚úù¬π).obj X‚úù).obj X))","decl":"/-- Given functors `F‚ÇÅ : C‚ÇÅ ‚•§ D‚ÇÅ`, `F‚ÇÇ : C‚ÇÇ ‚•§ D‚ÇÇ`, `F‚ÇÉ : C‚ÇÉ ‚•§ D‚ÇÉ`\nand `G : D‚ÇÅ √ó D‚ÇÇ √ó D‚ÇÉ ‚•§ E`, this is the isomorphism between\n`curry‚ÇÉ.obj (F‚ÇÅ.prod (F‚ÇÇ.prod F‚ÇÉ) ‚ãô G) : C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ C‚ÇÉ ‚•§ E`\nand `F‚ÇÅ ‚ãô curry‚ÇÉ.obj G ‚ãô ((whiskeringLeft‚ÇÇ E).obj F‚ÇÇ).obj F‚ÇÉ`. -/\n@[simps!]\ndef curry‚ÇÉObjProdComp (F‚ÇÅ : C‚ÇÅ ‚•§ D‚ÇÅ) (F‚ÇÇ : C‚ÇÇ ‚•§ D‚ÇÇ) (F‚ÇÉ : C‚ÇÉ ‚•§ D‚ÇÉ) (G : D‚ÇÅ √ó D‚ÇÇ √ó D‚ÇÉ ‚•§ E) :\n    curry‚ÇÉ.obj (F‚ÇÅ.prod (F‚ÇÇ.prod F‚ÇÉ) ‚ãô G) ‚âÖ\n      F‚ÇÅ ‚ãô curry‚ÇÉ.obj G ‚ãô ((whiskeringLeft‚ÇÇ E).obj F‚ÇÇ).obj F‚ÇÉ :=\n  NatIso.ofComponents\n    (fun X‚ÇÅ ‚Ü¶ NatIso.ofComponents\n      (fun X‚ÇÇ ‚Ü¶ NatIso.ofComponents (fun X‚ÇÉ ‚Ü¶ Iso.refl _)))\n\n"}
{"name":"CategoryTheory.curry‚ÇÉObjProdComp_hom_app_app_app","module":"Mathlib.CategoryTheory.Functor.CurryingThree","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_4\nD‚ÇÅ : Type u_6\nD‚ÇÇ : Type u_7\nD‚ÇÉ : Type u_8\nE : Type u_9\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_10, u_1} C‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{u_11, u_2} C‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_12, u_4} C‚ÇÉ\ninst‚úù¬≥ : CategoryTheory.Category.{u_13, u_6} D‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u_14, u_7} D‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{u_15, u_8} D‚ÇÉ\ninst‚úù : CategoryTheory.Category.{u_16, u_9} E\nF‚ÇÅ : CategoryTheory.Functor C‚ÇÅ D‚ÇÅ\nF‚ÇÇ : CategoryTheory.Functor C‚ÇÇ D‚ÇÇ\nF‚ÇÉ : CategoryTheory.Functor C‚ÇÉ D‚ÇÉ\nG : CategoryTheory.Functor (Prod D‚ÇÅ (Prod D‚ÇÇ D‚ÇÉ)) E\nX‚úù¬π : C‚ÇÅ\nX‚úù : C‚ÇÇ\nX : C‚ÇÉ\n‚ä¢ Eq ((((CategoryTheory.curry‚ÇÉObjProdComp F‚ÇÅ F‚ÇÇ F‚ÇÉ G).hom.app X‚úù¬π).app X‚úù).app X) (CategoryTheory.CategoryStruct.id ((((CategoryTheory.curry‚ÇÉ.obj ((F‚ÇÅ.prod (F‚ÇÇ.prod F‚ÇÉ)).comp G)).obj X‚úù¬π).obj X‚úù).obj X))","decl":"/-- Given functors `F‚ÇÅ : C‚ÇÅ ‚•§ D‚ÇÅ`, `F‚ÇÇ : C‚ÇÇ ‚•§ D‚ÇÇ`, `F‚ÇÉ : C‚ÇÉ ‚•§ D‚ÇÉ`\nand `G : D‚ÇÅ √ó D‚ÇÇ √ó D‚ÇÉ ‚•§ E`, this is the isomorphism between\n`curry‚ÇÉ.obj (F‚ÇÅ.prod (F‚ÇÇ.prod F‚ÇÉ) ‚ãô G) : C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ C‚ÇÉ ‚•§ E`\nand `F‚ÇÅ ‚ãô curry‚ÇÉ.obj G ‚ãô ((whiskeringLeft‚ÇÇ E).obj F‚ÇÇ).obj F‚ÇÉ`. -/\n@[simps!]\ndef curry‚ÇÉObjProdComp (F‚ÇÅ : C‚ÇÅ ‚•§ D‚ÇÅ) (F‚ÇÇ : C‚ÇÇ ‚•§ D‚ÇÇ) (F‚ÇÉ : C‚ÇÉ ‚•§ D‚ÇÉ) (G : D‚ÇÅ √ó D‚ÇÇ √ó D‚ÇÉ ‚•§ E) :\n    curry‚ÇÉ.obj (F‚ÇÅ.prod (F‚ÇÇ.prod F‚ÇÉ) ‚ãô G) ‚âÖ\n      F‚ÇÅ ‚ãô curry‚ÇÉ.obj G ‚ãô ((whiskeringLeft‚ÇÇ E).obj F‚ÇÇ).obj F‚ÇÉ :=\n  NatIso.ofComponents\n    (fun X‚ÇÅ ‚Ü¶ NatIso.ofComponents\n      (fun X‚ÇÇ ‚Ü¶ NatIso.ofComponents (fun X‚ÇÉ ‚Ü¶ Iso.refl _)))\n\n"}
{"name":"CategoryTheory.bifunctorComp‚ÇÅ‚ÇÇIso_hom_app_app_app","module":"Mathlib.CategoryTheory.Functor.CurryingThree","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÅ‚ÇÇ : Type u_3\nC‚ÇÉ : Type u_4\nE : Type u_9\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_10, u_1} C‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{u_11, u_2} C‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{u_12, u_4} C‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{u_13, u_3} C‚ÇÅ‚ÇÇ\ninst‚úù : CategoryTheory.Category.{u_14, u_9} E\nF‚ÇÅ‚ÇÇ : CategoryTheory.Functor C‚ÇÅ (CategoryTheory.Functor C‚ÇÇ C‚ÇÅ‚ÇÇ)\nG : CategoryTheory.Functor C‚ÇÅ‚ÇÇ (CategoryTheory.Functor C‚ÇÉ E)\nX‚úù¬π : C‚ÇÅ\nX‚úù : C‚ÇÇ\nX : C‚ÇÉ\n‚ä¢ Eq ((((CategoryTheory.bifunctorComp‚ÇÅ‚ÇÇIso F‚ÇÅ‚ÇÇ G).hom.app X‚úù¬π).app X‚úù).app X) (CategoryTheory.CategoryStruct.id ((G.obj ((F‚ÇÅ‚ÇÇ.obj X‚úù¬π).obj X‚úù)).obj X))","decl":"/-- `bifunctorComp‚ÇÅ‚ÇÇ` can be described in terms of the curryfication of functors. -/\n@[simps!]\ndef bifunctorComp‚ÇÅ‚ÇÇIso (F‚ÇÅ‚ÇÇ : C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ C‚ÇÅ‚ÇÇ) (G : C‚ÇÅ‚ÇÇ ‚•§ C‚ÇÉ ‚•§ E) :\n    bifunctorComp‚ÇÅ‚ÇÇ F‚ÇÅ‚ÇÇ G ‚âÖ curry.obj (uncurry.obj F‚ÇÅ‚ÇÇ ‚ãô G) :=\n  NatIso.ofComponents (fun _ => NatIso.ofComponents (fun _ => Iso.refl _))\n\n"}
{"name":"CategoryTheory.bifunctorComp‚ÇÅ‚ÇÇIso_inv_app_app_app","module":"Mathlib.CategoryTheory.Functor.CurryingThree","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÅ‚ÇÇ : Type u_3\nC‚ÇÉ : Type u_4\nE : Type u_9\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_10, u_1} C‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{u_11, u_2} C‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{u_12, u_4} C‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{u_13, u_3} C‚ÇÅ‚ÇÇ\ninst‚úù : CategoryTheory.Category.{u_14, u_9} E\nF‚ÇÅ‚ÇÇ : CategoryTheory.Functor C‚ÇÅ (CategoryTheory.Functor C‚ÇÇ C‚ÇÅ‚ÇÇ)\nG : CategoryTheory.Functor C‚ÇÅ‚ÇÇ (CategoryTheory.Functor C‚ÇÉ E)\nX‚úù¬π : C‚ÇÅ\nX‚úù : C‚ÇÇ\nX : C‚ÇÉ\n‚ä¢ Eq ((((CategoryTheory.bifunctorComp‚ÇÅ‚ÇÇIso F‚ÇÅ‚ÇÇ G).inv.app X‚úù¬π).app X‚úù).app X) (CategoryTheory.CategoryStruct.id ((G.obj ((F‚ÇÅ‚ÇÇ.obj X‚úù¬π).obj X‚úù)).obj X))","decl":"/-- `bifunctorComp‚ÇÅ‚ÇÇ` can be described in terms of the curryfication of functors. -/\n@[simps!]\ndef bifunctorComp‚ÇÅ‚ÇÇIso (F‚ÇÅ‚ÇÇ : C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ C‚ÇÅ‚ÇÇ) (G : C‚ÇÅ‚ÇÇ ‚•§ C‚ÇÉ ‚•§ E) :\n    bifunctorComp‚ÇÅ‚ÇÇ F‚ÇÅ‚ÇÇ G ‚âÖ curry.obj (uncurry.obj F‚ÇÅ‚ÇÇ ‚ãô G) :=\n  NatIso.ofComponents (fun _ => NatIso.ofComponents (fun _ => Iso.refl _))\n\n"}
{"name":"CategoryTheory.bifunctorComp‚ÇÇ‚ÇÉIso_hom_app_app_app","module":"Mathlib.CategoryTheory.Functor.CurryingThree","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_4\nC‚ÇÇ‚ÇÉ : Type u_5\nE : Type u_9\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_10, u_1} C‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{u_11, u_2} C‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{u_12, u_4} C‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{u_13, u_5} C‚ÇÇ‚ÇÉ\ninst‚úù : CategoryTheory.Category.{u_14, u_9} E\nF : CategoryTheory.Functor C‚ÇÅ (CategoryTheory.Functor C‚ÇÇ‚ÇÉ E)\nG‚ÇÇ‚ÇÉ : CategoryTheory.Functor C‚ÇÇ (CategoryTheory.Functor C‚ÇÉ C‚ÇÇ‚ÇÉ)\nX‚úù¬π : C‚ÇÅ\nX‚úù : C‚ÇÇ\nX : C‚ÇÉ\n‚ä¢ Eq ((((CategoryTheory.bifunctorComp‚ÇÇ‚ÇÉIso F G‚ÇÇ‚ÇÉ).hom.app X‚úù¬π).app X‚úù).app X) (CategoryTheory.CategoryStruct.id ((F.obj X‚úù¬π).obj ((G‚ÇÇ‚ÇÉ.obj X‚úù).obj X)))","decl":"/-- `bifunctorComp‚ÇÇ‚ÇÉ` can be described in terms of the curryfication of functors. -/\n@[simps!]\ndef bifunctorComp‚ÇÇ‚ÇÉIso (F : C‚ÇÅ ‚•§ C‚ÇÇ‚ÇÉ ‚•§ E) (G‚ÇÇ‚ÇÉ : C‚ÇÇ ‚•§ C‚ÇÉ ‚•§ C‚ÇÇ‚ÇÉ) :\n    bifunctorComp‚ÇÇ‚ÇÉ F G‚ÇÇ‚ÇÉ ‚âÖ\n    curry.obj (curry.obj (prod.associator _ _ _ ‚ãô\n      uncurry.obj (uncurry.obj G‚ÇÇ‚ÇÉ ‚ãô F.flip).flip)) :=\n  NatIso.ofComponents (fun _ ‚Ü¶ NatIso.ofComponents (fun _ ‚Ü¶\n    NatIso.ofComponents (fun _ ‚Ü¶ Iso.refl _)))\n\n"}
{"name":"CategoryTheory.bifunctorComp‚ÇÇ‚ÇÉIso_inv_app_app_app","module":"Mathlib.CategoryTheory.Functor.CurryingThree","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_4\nC‚ÇÇ‚ÇÉ : Type u_5\nE : Type u_9\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_10, u_1} C‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{u_11, u_2} C‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{u_12, u_4} C‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{u_13, u_5} C‚ÇÇ‚ÇÉ\ninst‚úù : CategoryTheory.Category.{u_14, u_9} E\nF : CategoryTheory.Functor C‚ÇÅ (CategoryTheory.Functor C‚ÇÇ‚ÇÉ E)\nG‚ÇÇ‚ÇÉ : CategoryTheory.Functor C‚ÇÇ (CategoryTheory.Functor C‚ÇÉ C‚ÇÇ‚ÇÉ)\nX‚úù¬π : C‚ÇÅ\nX‚úù : C‚ÇÇ\nX : C‚ÇÉ\n‚ä¢ Eq ((((CategoryTheory.bifunctorComp‚ÇÇ‚ÇÉIso F G‚ÇÇ‚ÇÉ).inv.app X‚úù¬π).app X‚úù).app X) (CategoryTheory.CategoryStruct.id ((F.obj X‚úù¬π).obj ((G‚ÇÇ‚ÇÉ.obj X‚úù).obj X)))","decl":"/-- `bifunctorComp‚ÇÇ‚ÇÉ` can be described in terms of the curryfication of functors. -/\n@[simps!]\ndef bifunctorComp‚ÇÇ‚ÇÉIso (F : C‚ÇÅ ‚•§ C‚ÇÇ‚ÇÉ ‚•§ E) (G‚ÇÇ‚ÇÉ : C‚ÇÇ ‚•§ C‚ÇÉ ‚•§ C‚ÇÇ‚ÇÉ) :\n    bifunctorComp‚ÇÇ‚ÇÉ F G‚ÇÇ‚ÇÉ ‚âÖ\n    curry.obj (curry.obj (prod.associator _ _ _ ‚ãô\n      uncurry.obj (uncurry.obj G‚ÇÇ‚ÇÉ ‚ãô F.flip).flip)) :=\n  NatIso.ofComponents (fun _ ‚Ü¶ NatIso.ofComponents (fun _ ‚Ü¶\n    NatIso.ofComponents (fun _ ‚Ü¶ Iso.refl _)))\n\n"}
