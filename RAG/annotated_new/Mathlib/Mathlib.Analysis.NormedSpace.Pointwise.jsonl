{"name":"ediam_smul_le","module":"Mathlib.Analysis.NormedSpace.Pointwise","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : SeminormedAddCommGroup ğ•œ\ninstâœÂ² : SeminormedAddCommGroup E\ninstâœÂ¹ : SMulZeroClass ğ•œ E\ninstâœ : BoundedSMul ğ•œ E\nc : ğ•œ\ns : Set E\nâŠ¢ LE.le (EMetric.diam (HSMul.hSMul c s)) (HSMul.hSMul (NNNorm.nnnorm c) (EMetric.diam s))","decl":"theorem ediam_smul_le (c : ğ•œ) (s : Set E) : EMetric.diam (c â€¢ s) â‰¤ â€–câ€–â‚Š â€¢ EMetric.diam s :=\n  (lipschitzWith_smul c).ediam_image_le s\n\n"}
{"name":"ediam_smulâ‚€","module":"Mathlib.Analysis.NormedSpace.Pointwise","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : NormedDivisionRing ğ•œ\ninstâœÂ² : SeminormedAddCommGroup E\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : BoundedSMul ğ•œ E\nc : ğ•œ\ns : Set E\nâŠ¢ Eq (EMetric.diam (HSMul.hSMul c s)) (HSMul.hSMul (NNNorm.nnnorm c) (EMetric.diam s))","decl":"theorem ediam_smulâ‚€ (c : ğ•œ) (s : Set E) : EMetric.diam (c â€¢ s) = â€–câ€–â‚Š â€¢ EMetric.diam s := by\n  refine le_antisymm (ediam_smul_le c s) ?_\n  obtain rfl | hc := eq_or_ne c 0\n  Â· obtain rfl | hs := s.eq_empty_or_nonempty\n    Â· simp\n    simp [zero_smul_set hs, â† Set.singleton_zero]\n  Â· have := (lipschitzWith_smul câ»Â¹).ediam_image_le (c â€¢ s)\n    rwa [â† smul_eq_mul, â† ENNReal.smul_def, Set.image_smul, inv_smul_smulâ‚€ hc s, nnnorm_inv,\n      le_inv_smul_iff_of_pos (nnnorm_pos.2 hc)] at this\n\n"}
{"name":"diam_smulâ‚€","module":"Mathlib.Analysis.NormedSpace.Pointwise","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : NormedDivisionRing ğ•œ\ninstâœÂ² : SeminormedAddCommGroup E\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : BoundedSMul ğ•œ E\nc : ğ•œ\nx : Set E\nâŠ¢ Eq (Metric.diam (HSMul.hSMul c x)) (HMul.hMul (Norm.norm c) (Metric.diam x))","decl":"theorem diam_smulâ‚€ (c : ğ•œ) (x : Set E) : diam (c â€¢ x) = â€–câ€– * diam x := by\n  simp_rw [diam, ediam_smulâ‚€, ENNReal.toReal_smul, NNReal.smul_def, coe_nnnorm, smul_eq_mul]\n\n"}
{"name":"infEdist_smulâ‚€","module":"Mathlib.Analysis.NormedSpace.Pointwise","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : NormedDivisionRing ğ•œ\ninstâœÂ² : SeminormedAddCommGroup E\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : BoundedSMul ğ•œ E\nc : ğ•œ\nhc : Ne c 0\ns : Set E\nx : E\nâŠ¢ Eq (EMetric.infEdist (HSMul.hSMul c x) (HSMul.hSMul c s)) (HSMul.hSMul (NNNorm.nnnorm c) (EMetric.infEdist x s))","decl":"theorem infEdist_smulâ‚€ {c : ğ•œ} (hc : c â‰  0) (s : Set E) (x : E) :\n    EMetric.infEdist (c â€¢ x) (c â€¢ s) = â€–câ€–â‚Š â€¢ EMetric.infEdist x s := by\n  simp_rw [EMetric.infEdist]\n  have : Function.Surjective ((c â€¢ Â·) : E â†’ E) :=\n    Function.RightInverse.surjective (smul_inv_smulâ‚€ hc)\n  trans â¨… (y) (_ : y âˆˆ s), â€–câ€–â‚Š â€¢ edist x y\n  Â· refine (this.iInf_congr _ fun y => ?_).symm\n    simp_rw [smul_mem_smul_set_iffâ‚€ hc, edist_smulâ‚€]\n  Â· have : (â€–câ€–â‚Š : ENNReal) â‰  0 := by simp [hc]\n    simp_rw [ENNReal.smul_def, smul_eq_mul, ENNReal.mul_iInf_of_ne this ENNReal.coe_ne_top]\n\n"}
{"name":"infDist_smulâ‚€","module":"Mathlib.Analysis.NormedSpace.Pointwise","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : NormedDivisionRing ğ•œ\ninstâœÂ² : SeminormedAddCommGroup E\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : BoundedSMul ğ•œ E\nc : ğ•œ\nhc : Ne c 0\ns : Set E\nx : E\nâŠ¢ Eq (Metric.infDist (HSMul.hSMul c x) (HSMul.hSMul c s)) (HMul.hMul (Norm.norm c) (Metric.infDist x s))","decl":"theorem infDist_smulâ‚€ {c : ğ•œ} (hc : c â‰  0) (s : Set E) (x : E) :\n    Metric.infDist (c â€¢ x) (c â€¢ s) = â€–câ€– * Metric.infDist x s := by\n  simp_rw [Metric.infDist, infEdist_smulâ‚€ hc s, ENNReal.toReal_smul, NNReal.smul_def, coe_nnnorm,\n    smul_eq_mul]\n\n"}
{"name":"smul_ball","module":"Mathlib.Analysis.NormedSpace.Pointwise","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nc : ğ•œ\nhc : Ne c 0\nx : E\nr : Real\nâŠ¢ Eq (HSMul.hSMul c (Metric.ball x r)) (Metric.ball (HSMul.hSMul c x) (HMul.hMul (Norm.norm c) r))","decl":"theorem smul_ball {c : ğ•œ} (hc : c â‰  0) (x : E) (r : â„) : c â€¢ ball x r = ball (c â€¢ x) (â€–câ€– * r) := by\n  ext y\n  rw [mem_smul_set_iff_inv_smul_memâ‚€ hc]\n  conv_lhs => rw [â† inv_smul_smulâ‚€ hc x]\n  simp [â† div_eq_inv_mul, div_lt_iffâ‚€ (norm_pos_iff.2 hc), mul_comm _ r, dist_smulâ‚€]\n\n"}
{"name":"smul_unitBall","module":"Mathlib.Analysis.NormedSpace.Pointwise","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nc : ğ•œ\nhc : Ne c 0\nâŠ¢ Eq (HSMul.hSMul c (Metric.ball 0 1)) (Metric.ball 0 (Norm.norm c))","decl":"theorem smul_unitBall {c : ğ•œ} (hc : c â‰  0) : c â€¢ ball (0 : E) (1 : â„) = ball (0 : E) â€–câ€– := by\n  rw [_root_.smul_ball hc, smul_zero, mul_one]\n\n"}
{"name":"smul_sphere'","module":"Mathlib.Analysis.NormedSpace.Pointwise","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nc : ğ•œ\nhc : Ne c 0\nx : E\nr : Real\nâŠ¢ Eq (HSMul.hSMul c (Metric.sphere x r)) (Metric.sphere (HSMul.hSMul c x) (HMul.hMul (Norm.norm c) r))","decl":"theorem smul_sphere' {c : ğ•œ} (hc : c â‰  0) (x : E) (r : â„) :\n    c â€¢ sphere x r = sphere (c â€¢ x) (â€–câ€– * r) := by\n  ext y\n  rw [mem_smul_set_iff_inv_smul_memâ‚€ hc]\n  conv_lhs => rw [â† inv_smul_smulâ‚€ hc x]\n  simp only [mem_sphere, dist_smulâ‚€, norm_inv, â† div_eq_inv_mul, div_eq_iff (norm_pos_iff.2 hc).ne',\n    mul_comm r]\n\n"}
{"name":"smul_closedBall'","module":"Mathlib.Analysis.NormedSpace.Pointwise","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nc : ğ•œ\nhc : Ne c 0\nx : E\nr : Real\nâŠ¢ Eq (HSMul.hSMul c (Metric.closedBall x r)) (Metric.closedBall (HSMul.hSMul c x) (HMul.hMul (Norm.norm c) r))","decl":"theorem smul_closedBall' {c : ğ•œ} (hc : c â‰  0) (x : E) (r : â„) :\n    c â€¢ closedBall x r = closedBall (c â€¢ x) (â€–câ€– * r) := by\n  simp only [â† ball_union_sphere, Set.smul_set_union, _root_.smul_ball hc, smul_sphere' hc]\n\n"}
{"name":"set_smul_sphere_zero","module":"Mathlib.Analysis.NormedSpace.Pointwise","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\ns : Set ğ•œ\nhs : Not (Membership.mem s 0)\nr : Real\nâŠ¢ Eq (HSMul.hSMul s (Metric.sphere 0 r)) (Set.preimage (fun x => Norm.norm x) (Set.image (fun x => HMul.hMul (Norm.norm x) r) s))","decl":"theorem set_smul_sphere_zero {s : Set ğ•œ} (hs : 0 âˆ‰ s) (r : â„) :\n    s â€¢ sphere (0 : E) r = (â€–Â·â€–) â»Â¹' ((â€–Â·â€– * r) '' s) :=\n  calc\n    s â€¢ sphere (0 : E) r = â‹ƒ c âˆˆ s, c â€¢ sphere (0 : E) r := iUnion_smul_left_image.symm\n    _ = â‹ƒ c âˆˆ s, sphere (0 : E) (â€–câ€– * r) := iUnionâ‚‚_congr fun c hc â†¦ by\n      rw [smul_sphere' (ne_of_mem_of_not_mem hc hs), smul_zero]\n    _ = (â€–Â·â€–) â»Â¹' ((â€–Â·â€– * r) '' s) := by ext; simp [eq_comm]\n\n"}
{"name":"Bornology.IsBounded.smulâ‚€","module":"Mathlib.Analysis.NormedSpace.Pointwise","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\ns : Set E\nhs : Bornology.IsBounded s\nc : ğ•œ\nâŠ¢ Bornology.IsBounded (HSMul.hSMul c s)","decl":"/-- Image of a bounded set in a normed space under scalar multiplication by a constant is\nbounded. See also `Bornology.IsBounded.smul` for a similar lemma about an isometric action. -/\ntheorem Bornology.IsBounded.smulâ‚€ {s : Set E} (hs : IsBounded s) (c : ğ•œ) : IsBounded (c â€¢ s) :=\n  (lipschitzWith_smul c).isBounded_image hs\n\n"}
{"name":"eventually_singleton_add_smul_subset","module":"Mathlib.Analysis.NormedSpace.Pointwise","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nx : E\ns : Set E\nhs : Bornology.IsBounded s\nu : Set E\nhu : Membership.mem (nhds x) u\nâŠ¢ Filter.Eventually (fun r => HasSubset.Subset (HAdd.hAdd (Singleton.singleton x) (HSMul.hSMul r s)) u) (nhds 0)","decl":"/-- If `s` is a bounded set, then for small enough `r`, the set `{x} + r â€¢ s` is contained in any\nfixed neighborhood of `x`. -/\ntheorem eventually_singleton_add_smul_subset {x : E} {s : Set E} (hs : Bornology.IsBounded s)\n    {u : Set E} (hu : u âˆˆ ğ“ x) : âˆ€á¶  r in ğ“ (0 : ğ•œ), {x} + r â€¢ s âŠ† u := by\n  obtain âŸ¨Îµ, Îµpos, hÎµâŸ© : âˆƒ Îµ : â„, 0 < Îµ âˆ§ closedBall x Îµ âŠ† u := nhds_basis_closedBall.mem_iff.1 hu\n  obtain âŸ¨R, Rpos, hRâŸ© : âˆƒ R : â„, 0 < R âˆ§ s âŠ† closedBall 0 R := hs.subset_closedBall_lt 0 0\n  have : Metric.closedBall (0 : ğ•œ) (Îµ / R) âˆˆ ğ“ (0 : ğ•œ) := closedBall_mem_nhds _ (div_pos Îµpos Rpos)\n  filter_upwards [this] with r hr\n  simp only [image_add_left, singleton_add]\n  intro y hy\n  obtain âŸ¨z, zs, hzâŸ© : âˆƒ z : E, z âˆˆ s âˆ§ r â€¢ z = -x + y := by simpa [mem_smul_set] using hy\n  have I : â€–r â€¢ zâ€– â‰¤ Îµ :=\n    calc\n      â€–r â€¢ zâ€– = â€–râ€– * â€–zâ€– := norm_smul _ _\n      _ â‰¤ Îµ / R * R :=\n        (mul_le_mul (mem_closedBall_zero_iff.1 hr) (mem_closedBall_zero_iff.1 (hR zs))\n          (norm_nonneg _) (div_pos Îµpos Rpos).le)\n      _ = Îµ := by field_simp\n  have : y = x + r â€¢ z := by simp only [hz, add_neg_cancel_left]\n  apply hÎµ\n  simpa only [this, dist_eq_norm, add_sub_cancel_left, mem_closedBall] using I\n\n"}
{"name":"smul_unitBall_of_pos","module":"Mathlib.Analysis.NormedSpace.Pointwise","initialProofState":"E : Type u_2\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace Real E\nr : Real\nhr : LT.lt 0 r\nâŠ¢ Eq (HSMul.hSMul r (Metric.ball 0 1)) (Metric.ball 0 r)","decl":"/-- In a real normed space, the image of the unit ball under scalar multiplication by a positive\nconstant `r` is the ball of radius `r`. -/\ntheorem smul_unitBall_of_pos {r : â„} (hr : 0 < r) : r â€¢ ball (0 : E) 1 = ball (0 : E) r := by\n  rw [smul_unitBall hr.ne', Real.norm_of_nonneg hr.le]\n\n"}
{"name":"Ioo_smul_sphere_zero","module":"Mathlib.Analysis.NormedSpace.Pointwise","initialProofState":"E : Type u_2\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace Real E\na b r : Real\nha : LE.le 0 a\nhr : LT.lt 0 r\nâŠ¢ Eq (HSMul.hSMul (Set.Ioo a b) (Metric.sphere 0 r)) (SDiff.sdiff (Metric.ball 0 (HMul.hMul b r)) (Metric.closedBall 0 (HMul.hMul a r)))","decl":"lemma Ioo_smul_sphere_zero {a b r : â„} (ha : 0 â‰¤ a) (hr : 0 < r) :\n    Ioo a b â€¢ sphere (0 : E) r = ball 0 (b * r) \\ closedBall 0 (a * r) := by\n  have : EqOn (â€–Â·â€–) id (Ioo a b) := fun x hx â†¦ abs_of_pos (ha.trans_lt hx.1)\n  rw [set_smul_sphere_zero (by simp [ha.not_lt]), â† image_image (Â· * r), this.image_eq, image_id,\n    image_mul_right_Ioo _ _ hr]\n  ext x; simp [and_comm]\n\n-- This is also true for `â„š`-normed spaces\n"}
{"name":"exists_dist_eq","module":"Mathlib.Analysis.NormedSpace.Pointwise","initialProofState":"E : Type u_2\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace Real E\nx z : E\na b : Real\nha : LE.le 0 a\nhb : LE.le 0 b\nhab : Eq (HAdd.hAdd a b) 1\nâŠ¢ Exists fun y => And (Eq (Dist.dist x y) (HMul.hMul b (Dist.dist x z))) (Eq (Dist.dist y z) (HMul.hMul a (Dist.dist x z)))","decl":"theorem exists_dist_eq (x z : E) {a b : â„} (ha : 0 â‰¤ a) (hb : 0 â‰¤ b) (hab : a + b = 1) :\n    âˆƒ y, dist x y = b * dist x z âˆ§ dist y z = a * dist x z := by\n  use a â€¢ x + b â€¢ z\n  nth_rw 1 [â† one_smul â„ x]\n  nth_rw 4 [â† one_smul â„ z]\n  simp [dist_eq_norm, â† hab, add_smul, â† smul_sub, norm_smul_of_nonneg, ha, hb]\n\n"}
{"name":"exists_dist_le_le","module":"Mathlib.Analysis.NormedSpace.Pointwise","initialProofState":"E : Type u_2\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace Real E\nx z : E\nÎ´ Îµ : Real\nhÎ´ : LE.le 0 Î´\nhÎµ : LE.le 0 Îµ\nh : LE.le (Dist.dist x z) (HAdd.hAdd Îµ Î´)\nâŠ¢ Exists fun y => And (LE.le (Dist.dist x y) Î´) (LE.le (Dist.dist y z) Îµ)","decl":"theorem exists_dist_le_le (hÎ´ : 0 â‰¤ Î´) (hÎµ : 0 â‰¤ Îµ) (h : dist x z â‰¤ Îµ + Î´) :\n    âˆƒ y, dist x y â‰¤ Î´ âˆ§ dist y z â‰¤ Îµ := by\n  obtain rfl | hÎµ' := hÎµ.eq_or_lt\n  Â· exact âŸ¨z, by rwa [zero_add] at h, (dist_self _).leâŸ©\n  have hÎµÎ´ := add_pos_of_pos_of_nonneg hÎµ' hÎ´\n  refine (exists_dist_eq x z (div_nonneg hÎµ <| add_nonneg hÎµ hÎ´)\n    (div_nonneg hÎ´ <| add_nonneg hÎµ hÎ´) <| by\n      rw [â† add_div, div_self hÎµÎ´.ne']).imp\n    fun y hy => ?_\n  rw [hy.1, hy.2, div_mul_comm, div_mul_comm Îµ]\n  rw [â† div_le_one hÎµÎ´] at h\n  exact âŸ¨mul_le_of_le_one_left hÎ´ h, mul_le_of_le_one_left hÎµ hâŸ©\n\n-- This is also true for `â„š`-normed spaces\n"}
{"name":"exists_dist_le_lt","module":"Mathlib.Analysis.NormedSpace.Pointwise","initialProofState":"E : Type u_2\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace Real E\nx z : E\nÎ´ Îµ : Real\nhÎ´ : LE.le 0 Î´\nhÎµ : LT.lt 0 Îµ\nh : LT.lt (Dist.dist x z) (HAdd.hAdd Îµ Î´)\nâŠ¢ Exists fun y => And (LE.le (Dist.dist x y) Î´) (LT.lt (Dist.dist y z) Îµ)","decl":"theorem exists_dist_le_lt (hÎ´ : 0 â‰¤ Î´) (hÎµ : 0 < Îµ) (h : dist x z < Îµ + Î´) :\n    âˆƒ y, dist x y â‰¤ Î´ âˆ§ dist y z < Îµ := by\n  refine (exists_dist_eq x z (div_nonneg hÎµ.le <| add_nonneg hÎµ.le hÎ´)\n    (div_nonneg hÎ´ <| add_nonneg hÎµ.le hÎ´) <| by\n      rw [â† add_div, div_self (add_pos_of_pos_of_nonneg hÎµ hÎ´).ne']).imp\n    fun y hy => ?_\n  rw [hy.1, hy.2, div_mul_comm, div_mul_comm Îµ]\n  rw [â† div_lt_one (add_pos_of_pos_of_nonneg hÎµ hÎ´)] at h\n  exact âŸ¨mul_le_of_le_one_left hÎ´ h.le, mul_lt_of_lt_one_left hÎµ hâŸ©\n\n-- This is also true for `â„š`-normed spaces\n"}
{"name":"exists_dist_lt_le","module":"Mathlib.Analysis.NormedSpace.Pointwise","initialProofState":"E : Type u_2\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace Real E\nx z : E\nÎ´ Îµ : Real\nhÎ´ : LT.lt 0 Î´\nhÎµ : LE.le 0 Îµ\nh : LT.lt (Dist.dist x z) (HAdd.hAdd Îµ Î´)\nâŠ¢ Exists fun y => And (LT.lt (Dist.dist x y) Î´) (LE.le (Dist.dist y z) Îµ)","decl":"theorem exists_dist_lt_le (hÎ´ : 0 < Î´) (hÎµ : 0 â‰¤ Îµ) (h : dist x z < Îµ + Î´) :\n    âˆƒ y, dist x y < Î´ âˆ§ dist y z â‰¤ Îµ := by\n  obtain âŸ¨y, yz, xyâŸ© :=\n    exists_dist_le_lt hÎµ hÎ´ (show dist z x < Î´ + Îµ by simpa only [dist_comm, add_comm] using h)\n  exact âŸ¨y, by simp [dist_comm x y, dist_comm y z, *]âŸ©\n\n-- This is also true for `â„š`-normed spaces\n"}
{"name":"exists_dist_lt_lt","module":"Mathlib.Analysis.NormedSpace.Pointwise","initialProofState":"E : Type u_2\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace Real E\nx z : E\nÎ´ Îµ : Real\nhÎ´ : LT.lt 0 Î´\nhÎµ : LT.lt 0 Îµ\nh : LT.lt (Dist.dist x z) (HAdd.hAdd Îµ Î´)\nâŠ¢ Exists fun y => And (LT.lt (Dist.dist x y) Î´) (LT.lt (Dist.dist y z) Îµ)","decl":"theorem exists_dist_lt_lt (hÎ´ : 0 < Î´) (hÎµ : 0 < Îµ) (h : dist x z < Îµ + Î´) :\n    âˆƒ y, dist x y < Î´ âˆ§ dist y z < Îµ := by\n  refine (exists_dist_eq x z (div_nonneg hÎµ.le <| add_nonneg hÎµ.le hÎ´.le)\n    (div_nonneg hÎ´.le <| add_nonneg hÎµ.le hÎ´.le) <| by\n      rw [â† add_div, div_self (add_pos hÎµ hÎ´).ne']).imp\n    fun y hy => ?_\n  rw [hy.1, hy.2, div_mul_comm, div_mul_comm Îµ]\n  rw [â† div_lt_one (add_pos hÎµ hÎ´)] at h\n  exact âŸ¨mul_lt_of_lt_one_left hÎ´ h, mul_lt_of_lt_one_left hÎµ hâŸ©\n\n-- This is also true for `â„š`-normed spaces\n"}
{"name":"disjoint_ball_ball_iff","module":"Mathlib.Analysis.NormedSpace.Pointwise","initialProofState":"E : Type u_2\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace Real E\nx y : E\nÎ´ Îµ : Real\nhÎ´ : LT.lt 0 Î´\nhÎµ : LT.lt 0 Îµ\nâŠ¢ Iff (Disjoint (Metric.ball x Î´) (Metric.ball y Îµ)) (LE.le (HAdd.hAdd Î´ Îµ) (Dist.dist x y))","decl":"theorem disjoint_ball_ball_iff (hÎ´ : 0 < Î´) (hÎµ : 0 < Îµ) :\n    Disjoint (ball x Î´) (ball y Îµ) â†” Î´ + Îµ â‰¤ dist x y := by\n  refine âŸ¨fun h => le_of_not_lt fun hxy => ?_, ball_disjoint_ballâŸ©\n  rw [add_comm] at hxy\n  obtain âŸ¨z, hxz, hzyâŸ© := exists_dist_lt_lt hÎ´ hÎµ hxy\n  rw [dist_comm] at hxz\n  exact h.le_bot âŸ¨hxz, hzyâŸ©\n\n-- This is also true for `â„š`-normed spaces\n"}
{"name":"disjoint_ball_closedBall_iff","module":"Mathlib.Analysis.NormedSpace.Pointwise","initialProofState":"E : Type u_2\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace Real E\nx y : E\nÎ´ Îµ : Real\nhÎ´ : LT.lt 0 Î´\nhÎµ : LE.le 0 Îµ\nâŠ¢ Iff (Disjoint (Metric.ball x Î´) (Metric.closedBall y Îµ)) (LE.le (HAdd.hAdd Î´ Îµ) (Dist.dist x y))","decl":"theorem disjoint_ball_closedBall_iff (hÎ´ : 0 < Î´) (hÎµ : 0 â‰¤ Îµ) :\n    Disjoint (ball x Î´) (closedBall y Îµ) â†” Î´ + Îµ â‰¤ dist x y := by\n  refine âŸ¨fun h => le_of_not_lt fun hxy => ?_, ball_disjoint_closedBallâŸ©\n  rw [add_comm] at hxy\n  obtain âŸ¨z, hxz, hzyâŸ© := exists_dist_lt_le hÎ´ hÎµ hxy\n  rw [dist_comm] at hxz\n  exact h.le_bot âŸ¨hxz, hzyâŸ©\n\n-- This is also true for `â„š`-normed spaces\n"}
{"name":"disjoint_closedBall_ball_iff","module":"Mathlib.Analysis.NormedSpace.Pointwise","initialProofState":"E : Type u_2\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace Real E\nx y : E\nÎ´ Îµ : Real\nhÎ´ : LE.le 0 Î´\nhÎµ : LT.lt 0 Îµ\nâŠ¢ Iff (Disjoint (Metric.closedBall x Î´) (Metric.ball y Îµ)) (LE.le (HAdd.hAdd Î´ Îµ) (Dist.dist x y))","decl":"theorem disjoint_closedBall_ball_iff (hÎ´ : 0 â‰¤ Î´) (hÎµ : 0 < Îµ) :\n    Disjoint (closedBall x Î´) (ball y Îµ) â†” Î´ + Îµ â‰¤ dist x y := by\n  rw [disjoint_comm, disjoint_ball_closedBall_iff hÎµ hÎ´, add_comm, dist_comm]\n\n"}
{"name":"disjoint_closedBall_closedBall_iff","module":"Mathlib.Analysis.NormedSpace.Pointwise","initialProofState":"E : Type u_2\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace Real E\nx y : E\nÎ´ Îµ : Real\nhÎ´ : LE.le 0 Î´\nhÎµ : LE.le 0 Îµ\nâŠ¢ Iff (Disjoint (Metric.closedBall x Î´) (Metric.closedBall y Îµ)) (LT.lt (HAdd.hAdd Î´ Îµ) (Dist.dist x y))","decl":"theorem disjoint_closedBall_closedBall_iff (hÎ´ : 0 â‰¤ Î´) (hÎµ : 0 â‰¤ Îµ) :\n    Disjoint (closedBall x Î´) (closedBall y Îµ) â†” Î´ + Îµ < dist x y := by\n  refine âŸ¨fun h => lt_of_not_ge fun hxy => ?_, closedBall_disjoint_closedBallâŸ©\n  rw [add_comm] at hxy\n  obtain âŸ¨z, hxz, hzyâŸ© := exists_dist_le_le hÎ´ hÎµ hxy\n  rw [dist_comm] at hxz\n  exact h.le_bot âŸ¨hxz, hzyâŸ©\n\n"}
{"name":"infEdist_thickening","module":"Mathlib.Analysis.NormedSpace.Pointwise","initialProofState":"E : Type u_2\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace Real E\nÎ´ : Real\nhÎ´ : LT.lt 0 Î´\ns : Set E\nx : E\nâŠ¢ Eq (EMetric.infEdist x (Metric.thickening Î´ s)) (HSub.hSub (EMetric.infEdist x s) (ENNReal.ofReal Î´))","decl":"@[simp]\ntheorem infEdist_thickening (hÎ´ : 0 < Î´) (s : Set E) (x : E) :\n    infEdist x (thickening Î´ s) = infEdist x s - ENNReal.ofReal Î´ := by\n  obtain hs | hs := lt_or_le (infEdist x s) (ENNReal.ofReal Î´)\n  Â· rw [infEdist_zero_of_mem, tsub_eq_zero_of_le hs.le]\n    exact hs\n  refine (tsub_le_iff_right.2 infEdist_le_infEdist_thickening_add).antisymm' ?_\n  refine le_sub_of_add_le_right ofReal_ne_top ?_\n  refine le_infEdist.2 fun z hz => le_of_forall_lt' fun r h => ?_\n  cases' r with r\n  Â· exact add_lt_top.2 âŸ¨lt_top_iff_ne_top.2 <| infEdist_ne_top âŸ¨z, self_subset_thickening hÎ´ _ hzâŸ©,\n      ofReal_lt_topâŸ©\n  have hr : 0 < â†‘r - Î´ := by\n    refine sub_pos_of_lt ?_\n    have := hs.trans_lt ((infEdist_le_edist_of_mem hz).trans_lt h)\n    rw [ofReal_eq_coe_nnreal hÎ´.le] at this\n    exact mod_cast this\n  rw [edist_lt_coe, â† dist_lt_coe, â† add_sub_cancel Î´ â†‘r] at h\n  obtain âŸ¨y, hxy, hyzâŸ© := exists_dist_lt_lt hr hÎ´ h\n  refine (ENNReal.add_lt_add_right ofReal_ne_top <|\n    infEdist_lt_iff.2 âŸ¨_, mem_thickening_iff.2 âŸ¨_, hz, hyzâŸ©, edist_lt_ofReal.2 hxyâŸ©).trans_le ?_\n  rw [â† ofReal_add hr.le hÎ´.le, sub_add_cancel, ofReal_coe_nnreal]\n\n"}
{"name":"thickening_thickening","module":"Mathlib.Analysis.NormedSpace.Pointwise","initialProofState":"E : Type u_2\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace Real E\nÎ´ Îµ : Real\nhÎµ : LT.lt 0 Îµ\nhÎ´ : LT.lt 0 Î´\ns : Set E\nâŠ¢ Eq (Metric.thickening Îµ (Metric.thickening Î´ s)) (Metric.thickening (HAdd.hAdd Îµ Î´) s)","decl":"@[simp]\ntheorem thickening_thickening (hÎµ : 0 < Îµ) (hÎ´ : 0 < Î´) (s : Set E) :\n    thickening Îµ (thickening Î´ s) = thickening (Îµ + Î´) s :=\n  (thickening_thickening_subset _ _ _).antisymm fun x => by\n    simp_rw [mem_thickening_iff]\n    rintro âŸ¨z, hz, hxzâŸ©\n    rw [add_comm] at hxz\n    obtain âŸ¨y, hxy, hyzâŸ© := exists_dist_lt_lt hÎµ hÎ´ hxz\n    exact âŸ¨y, âŸ¨_, hz, hyzâŸ©, hxyâŸ©\n\n"}
{"name":"cthickening_thickening","module":"Mathlib.Analysis.NormedSpace.Pointwise","initialProofState":"E : Type u_2\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace Real E\nÎ´ Îµ : Real\nhÎµ : LE.le 0 Îµ\nhÎ´ : LT.lt 0 Î´\ns : Set E\nâŠ¢ Eq (Metric.cthickening Îµ (Metric.thickening Î´ s)) (Metric.cthickening (HAdd.hAdd Îµ Î´) s)","decl":"@[simp]\ntheorem cthickening_thickening (hÎµ : 0 â‰¤ Îµ) (hÎ´ : 0 < Î´) (s : Set E) :\n    cthickening Îµ (thickening Î´ s) = cthickening (Îµ + Î´) s :=\n  (cthickening_thickening_subset hÎµ _ _).antisymm fun x => by\n    simp_rw [mem_cthickening_iff, ENNReal.ofReal_add hÎµ hÎ´.le, infEdist_thickening hÎ´]\n    exact tsub_le_iff_right.2\n\n-- Note: `interior (cthickening Î´ s) â‰  thickening Î´ s` in general\n"}
{"name":"closure_thickening","module":"Mathlib.Analysis.NormedSpace.Pointwise","initialProofState":"E : Type u_2\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace Real E\nÎ´ : Real\nhÎ´ : LT.lt 0 Î´\ns : Set E\nâŠ¢ Eq (closure (Metric.thickening Î´ s)) (Metric.cthickening Î´ s)","decl":"@[simp]\ntheorem closure_thickening (hÎ´ : 0 < Î´) (s : Set E) :\n    closure (thickening Î´ s) = cthickening Î´ s := by\n  rw [â† cthickening_zero, cthickening_thickening le_rfl hÎ´, zero_add]\n\n"}
{"name":"infEdist_cthickening","module":"Mathlib.Analysis.NormedSpace.Pointwise","initialProofState":"E : Type u_2\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace Real E\nÎ´ : Real\ns : Set E\nx : E\nâŠ¢ Eq (EMetric.infEdist x (Metric.cthickening Î´ s)) (HSub.hSub (EMetric.infEdist x s) (ENNReal.ofReal Î´))","decl":"@[simp]\ntheorem infEdist_cthickening (Î´ : â„) (s : Set E) (x : E) :\n    infEdist x (cthickening Î´ s) = infEdist x s - ENNReal.ofReal Î´ := by\n  obtain hÎ´ | hÎ´ := le_or_lt Î´ 0\n  Â· rw [cthickening_of_nonpos hÎ´, infEdist_closure, ofReal_of_nonpos hÎ´, tsub_zero]\n  Â· rw [â† closure_thickening hÎ´, infEdist_closure, infEdist_thickening hÎ´]\n\n"}
{"name":"thickening_cthickening","module":"Mathlib.Analysis.NormedSpace.Pointwise","initialProofState":"E : Type u_2\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace Real E\nÎ´ Îµ : Real\nhÎµ : LT.lt 0 Îµ\nhÎ´ : LE.le 0 Î´\ns : Set E\nâŠ¢ Eq (Metric.thickening Îµ (Metric.cthickening Î´ s)) (Metric.thickening (HAdd.hAdd Îµ Î´) s)","decl":"@[simp]\ntheorem thickening_cthickening (hÎµ : 0 < Îµ) (hÎ´ : 0 â‰¤ Î´) (s : Set E) :\n    thickening Îµ (cthickening Î´ s) = thickening (Îµ + Î´) s := by\n  obtain rfl | hÎ´ := hÎ´.eq_or_lt\n  Â· rw [cthickening_zero, thickening_closure, add_zero]\n  Â· rw [â† closure_thickening hÎ´, thickening_closure, thickening_thickening hÎµ hÎ´]\n\n"}
{"name":"cthickening_cthickening","module":"Mathlib.Analysis.NormedSpace.Pointwise","initialProofState":"E : Type u_2\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace Real E\nÎ´ Îµ : Real\nhÎµ : LE.le 0 Îµ\nhÎ´ : LE.le 0 Î´\ns : Set E\nâŠ¢ Eq (Metric.cthickening Îµ (Metric.cthickening Î´ s)) (Metric.cthickening (HAdd.hAdd Îµ Î´) s)","decl":"@[simp]\ntheorem cthickening_cthickening (hÎµ : 0 â‰¤ Îµ) (hÎ´ : 0 â‰¤ Î´) (s : Set E) :\n    cthickening Îµ (cthickening Î´ s) = cthickening (Îµ + Î´) s :=\n  (cthickening_cthickening_subset hÎµ hÎ´ _).antisymm fun x => by\n    simp_rw [mem_cthickening_iff, ENNReal.ofReal_add hÎµ hÎ´, infEdist_cthickening]\n    exact tsub_le_iff_right.2\n\n"}
{"name":"thickening_ball","module":"Mathlib.Analysis.NormedSpace.Pointwise","initialProofState":"E : Type u_2\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace Real E\nÎ´ Îµ : Real\nhÎµ : LT.lt 0 Îµ\nhÎ´ : LT.lt 0 Î´\nx : E\nâŠ¢ Eq (Metric.thickening Îµ (Metric.ball x Î´)) (Metric.ball x (HAdd.hAdd Îµ Î´))","decl":"@[simp]\ntheorem thickening_ball (hÎµ : 0 < Îµ) (hÎ´ : 0 < Î´) (x : E) :\n    thickening Îµ (ball x Î´) = ball x (Îµ + Î´) := by\n  rw [â† thickening_singleton, thickening_thickening hÎµ hÎ´, thickening_singleton]\n\n"}
{"name":"thickening_closedBall","module":"Mathlib.Analysis.NormedSpace.Pointwise","initialProofState":"E : Type u_2\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace Real E\nÎ´ Îµ : Real\nhÎµ : LT.lt 0 Îµ\nhÎ´ : LE.le 0 Î´\nx : E\nâŠ¢ Eq (Metric.thickening Îµ (Metric.closedBall x Î´)) (Metric.ball x (HAdd.hAdd Îµ Î´))","decl":"@[simp]\ntheorem thickening_closedBall (hÎµ : 0 < Îµ) (hÎ´ : 0 â‰¤ Î´) (x : E) :\n    thickening Îµ (closedBall x Î´) = ball x (Îµ + Î´) := by\n  rw [â† cthickening_singleton _ hÎ´, thickening_cthickening hÎµ hÎ´, thickening_singleton]\n\n"}
{"name":"cthickening_ball","module":"Mathlib.Analysis.NormedSpace.Pointwise","initialProofState":"E : Type u_2\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace Real E\nÎ´ Îµ : Real\nhÎµ : LE.le 0 Îµ\nhÎ´ : LT.lt 0 Î´\nx : E\nâŠ¢ Eq (Metric.cthickening Îµ (Metric.ball x Î´)) (Metric.closedBall x (HAdd.hAdd Îµ Î´))","decl":"@[simp]\ntheorem cthickening_ball (hÎµ : 0 â‰¤ Îµ) (hÎ´ : 0 < Î´) (x : E) :\n    cthickening Îµ (ball x Î´) = closedBall x (Îµ + Î´) := by\n  rw [â† thickening_singleton, cthickening_thickening hÎµ hÎ´,\n      cthickening_singleton _ (add_nonneg hÎµ hÎ´.le)]\n\n"}
{"name":"cthickening_closedBall","module":"Mathlib.Analysis.NormedSpace.Pointwise","initialProofState":"E : Type u_2\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace Real E\nÎ´ Îµ : Real\nhÎµ : LE.le 0 Îµ\nhÎ´ : LE.le 0 Î´\nx : E\nâŠ¢ Eq (Metric.cthickening Îµ (Metric.closedBall x Î´)) (Metric.closedBall x (HAdd.hAdd Îµ Î´))","decl":"@[simp]\ntheorem cthickening_closedBall (hÎµ : 0 â‰¤ Îµ) (hÎ´ : 0 â‰¤ Î´) (x : E) :\n    cthickening Îµ (closedBall x Î´) = closedBall x (Îµ + Î´) := by\n  rw [â† cthickening_singleton _ hÎ´, cthickening_cthickening hÎµ hÎ´,\n      cthickening_singleton _ (add_nonneg hÎµ hÎ´)]\n\n"}
{"name":"ball_add_ball","module":"Mathlib.Analysis.NormedSpace.Pointwise","initialProofState":"E : Type u_2\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace Real E\nÎ´ Îµ : Real\nhÎµ : LT.lt 0 Îµ\nhÎ´ : LT.lt 0 Î´\na b : E\nâŠ¢ Eq (HAdd.hAdd (Metric.ball a Îµ) (Metric.ball b Î´)) (Metric.ball (HAdd.hAdd a b) (HAdd.hAdd Îµ Î´))","decl":"theorem ball_add_ball (hÎµ : 0 < Îµ) (hÎ´ : 0 < Î´) (a b : E) :\n    ball a Îµ + ball b Î´ = ball (a + b) (Îµ + Î´) := by\n  rw [ball_add, thickening_ball hÎµ hÎ´ b, Metric.vadd_ball, vadd_eq_add]\n\n"}
{"name":"ball_sub_ball","module":"Mathlib.Analysis.NormedSpace.Pointwise","initialProofState":"E : Type u_2\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace Real E\nÎ´ Îµ : Real\nhÎµ : LT.lt 0 Îµ\nhÎ´ : LT.lt 0 Î´\na b : E\nâŠ¢ Eq (HSub.hSub (Metric.ball a Îµ) (Metric.ball b Î´)) (Metric.ball (HSub.hSub a b) (HAdd.hAdd Îµ Î´))","decl":"theorem ball_sub_ball (hÎµ : 0 < Îµ) (hÎ´ : 0 < Î´) (a b : E) :\n    ball a Îµ - ball b Î´ = ball (a - b) (Îµ + Î´) := by\n  simp_rw [sub_eq_add_neg, neg_ball, ball_add_ball hÎµ hÎ´]\n\n"}
{"name":"ball_add_closedBall","module":"Mathlib.Analysis.NormedSpace.Pointwise","initialProofState":"E : Type u_2\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace Real E\nÎ´ Îµ : Real\nhÎµ : LT.lt 0 Îµ\nhÎ´ : LE.le 0 Î´\na b : E\nâŠ¢ Eq (HAdd.hAdd (Metric.ball a Îµ) (Metric.closedBall b Î´)) (Metric.ball (HAdd.hAdd a b) (HAdd.hAdd Îµ Î´))","decl":"theorem ball_add_closedBall (hÎµ : 0 < Îµ) (hÎ´ : 0 â‰¤ Î´) (a b : E) :\n    ball a Îµ + closedBall b Î´ = ball (a + b) (Îµ + Î´) := by\n  rw [ball_add, thickening_closedBall hÎµ hÎ´ b, Metric.vadd_ball, vadd_eq_add]\n\n"}
{"name":"ball_sub_closedBall","module":"Mathlib.Analysis.NormedSpace.Pointwise","initialProofState":"E : Type u_2\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace Real E\nÎ´ Îµ : Real\nhÎµ : LT.lt 0 Îµ\nhÎ´ : LE.le 0 Î´\na b : E\nâŠ¢ Eq (HSub.hSub (Metric.ball a Îµ) (Metric.closedBall b Î´)) (Metric.ball (HSub.hSub a b) (HAdd.hAdd Îµ Î´))","decl":"theorem ball_sub_closedBall (hÎµ : 0 < Îµ) (hÎ´ : 0 â‰¤ Î´) (a b : E) :\n    ball a Îµ - closedBall b Î´ = ball (a - b) (Îµ + Î´) := by\n  simp_rw [sub_eq_add_neg, neg_closedBall, ball_add_closedBall hÎµ hÎ´]\n\n"}
{"name":"closedBall_add_ball","module":"Mathlib.Analysis.NormedSpace.Pointwise","initialProofState":"E : Type u_2\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace Real E\nÎ´ Îµ : Real\nhÎµ : LE.le 0 Îµ\nhÎ´ : LT.lt 0 Î´\na b : E\nâŠ¢ Eq (HAdd.hAdd (Metric.closedBall a Îµ) (Metric.ball b Î´)) (Metric.ball (HAdd.hAdd a b) (HAdd.hAdd Îµ Î´))","decl":"theorem closedBall_add_ball (hÎµ : 0 â‰¤ Îµ) (hÎ´ : 0 < Î´) (a b : E) :\n    closedBall a Îµ + ball b Î´ = ball (a + b) (Îµ + Î´) := by\n  rw [add_comm, ball_add_closedBall hÎ´ hÎµ b, add_comm, add_comm Î´]\n\n"}
{"name":"closedBall_sub_ball","module":"Mathlib.Analysis.NormedSpace.Pointwise","initialProofState":"E : Type u_2\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace Real E\nÎ´ Îµ : Real\nhÎµ : LE.le 0 Îµ\nhÎ´ : LT.lt 0 Î´\na b : E\nâŠ¢ Eq (HSub.hSub (Metric.closedBall a Îµ) (Metric.ball b Î´)) (Metric.ball (HSub.hSub a b) (HAdd.hAdd Îµ Î´))","decl":"theorem closedBall_sub_ball (hÎµ : 0 â‰¤ Îµ) (hÎ´ : 0 < Î´) (a b : E) :\n    closedBall a Îµ - ball b Î´ = ball (a - b) (Îµ + Î´) := by\n  simp_rw [sub_eq_add_neg, neg_ball, closedBall_add_ball hÎµ hÎ´]\n\n"}
{"name":"closedBall_add_closedBall","module":"Mathlib.Analysis.NormedSpace.Pointwise","initialProofState":"E : Type u_2\ninstâœÂ² : SeminormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\nÎ´ Îµ : Real\ninstâœ : ProperSpace E\nhÎµ : LE.le 0 Îµ\nhÎ´ : LE.le 0 Î´\na b : E\nâŠ¢ Eq (HAdd.hAdd (Metric.closedBall a Îµ) (Metric.closedBall b Î´)) (Metric.closedBall (HAdd.hAdd a b) (HAdd.hAdd Îµ Î´))","decl":"theorem closedBall_add_closedBall [ProperSpace E] (hÎµ : 0 â‰¤ Îµ) (hÎ´ : 0 â‰¤ Î´) (a b : E) :\n    closedBall a Îµ + closedBall b Î´ = closedBall (a + b) (Îµ + Î´) := by\n  rw [(isCompact_closedBall _ _).add_closedBall hÎ´ b, cthickening_closedBall hÎ´ hÎµ a,\n    Metric.vadd_closedBall, vadd_eq_add, add_comm, add_comm Î´]\n\n"}
{"name":"closedBall_sub_closedBall","module":"Mathlib.Analysis.NormedSpace.Pointwise","initialProofState":"E : Type u_2\ninstâœÂ² : SeminormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\nÎ´ Îµ : Real\ninstâœ : ProperSpace E\nhÎµ : LE.le 0 Îµ\nhÎ´ : LE.le 0 Î´\na b : E\nâŠ¢ Eq (HSub.hSub (Metric.closedBall a Îµ) (Metric.closedBall b Î´)) (Metric.closedBall (HSub.hSub a b) (HAdd.hAdd Îµ Î´))","decl":"theorem closedBall_sub_closedBall [ProperSpace E] (hÎµ : 0 â‰¤ Îµ) (hÎ´ : 0 â‰¤ Î´) (a b : E) :\n    closedBall a Îµ - closedBall b Î´ = closedBall (a - b) (Îµ + Î´) := by\n  rw [sub_eq_add_neg, neg_closedBall, closedBall_add_closedBall hÎµ hÎ´, sub_eq_add_neg]\n\n"}
{"name":"smul_closedBall","module":"Mathlib.Analysis.NormedSpace.Pointwise","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nc : ğ•œ\nx : E\nr : Real\nhr : LE.le 0 r\nâŠ¢ Eq (HSMul.hSMul c (Metric.closedBall x r)) (Metric.closedBall (HSMul.hSMul c x) (HMul.hMul (Norm.norm c) r))","decl":"theorem smul_closedBall (c : ğ•œ) (x : E) {r : â„} (hr : 0 â‰¤ r) :\n    c â€¢ closedBall x r = closedBall (c â€¢ x) (â€–câ€– * r) := by\n  rcases eq_or_ne c 0 with (rfl | hc)\n  Â· simp [hr, zero_smul_set, Set.singleton_zero, nonempty_closedBall]\n  Â· exact smul_closedBall' hc x r\n\n"}
{"name":"smul_unitClosedBall","module":"Mathlib.Analysis.NormedSpace.Pointwise","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nc : ğ•œ\nâŠ¢ Eq (HSMul.hSMul c (Metric.closedBall 0 1)) (Metric.closedBall 0 (Norm.norm c))","decl":"theorem smul_unitClosedBall (c : ğ•œ) : c â€¢ closedBall (0 : E) (1 : â„) = closedBall (0 : E) â€–câ€– := by\n  rw [_root_.smul_closedBall _ _ zero_le_one, smul_zero, mul_one]\n\n"}
{"name":"smul_closedUnitBall","module":"Mathlib.Analysis.NormedSpace.Pointwise","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nc : ğ•œ\nâŠ¢ Eq (HSMul.hSMul c (Metric.closedBall 0 1)) (Metric.closedBall 0 (Norm.norm c))","decl":"@[deprecated (since := \"2024-12-01\")] alias smul_closedUnitBall := smul_unitClosedBall\n\n"}
{"name":"smul_unitClosedBall_of_nonneg","module":"Mathlib.Analysis.NormedSpace.Pointwise","initialProofState":"E : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nr : Real\nhr : LE.le 0 r\nâŠ¢ Eq (HSMul.hSMul r (Metric.closedBall 0 1)) (Metric.closedBall 0 r)","decl":"/-- In a real normed space, the image of the unit closed ball under multiplication by a nonnegative\nnumber `r` is the closed ball of radius `r` with center at the origin. -/\ntheorem smul_unitClosedBall_of_nonneg {r : â„} (hr : 0 â‰¤ r) :\n    r â€¢ closedBall (0 : E) 1 = closedBall (0 : E) r := by\n  rw [smul_unitClosedBall, Real.norm_of_nonneg hr]\n\n"}
{"name":"smul_closedUnitBall_of_nonneg","module":"Mathlib.Analysis.NormedSpace.Pointwise","initialProofState":"E : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nr : Real\nhr : LE.le 0 r\nâŠ¢ Eq (HSMul.hSMul r (Metric.closedBall 0 1)) (Metric.closedBall 0 r)","decl":"@[deprecated (since := \"2024-12-01\")]\nalias smul_closedUnitBall_of_nonneg := smul_unitClosedBall_of_nonneg\n\n"}
{"name":"NormedSpace.sphere_nonempty","module":"Mathlib.Analysis.NormedSpace.Pointwise","initialProofState":"E : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : Nontrivial E\nx : E\nr : Real\nâŠ¢ Iff (Metric.sphere x r).Nonempty (LE.le 0 r)","decl":"/-- In a nontrivial real normed space, a sphere is nonempty if and only if its radius is\nnonnegative. -/\n@[simp]\ntheorem NormedSpace.sphere_nonempty [Nontrivial E] {x : E} {r : â„} :\n    (sphere x r).Nonempty â†” 0 â‰¤ r := by\n  obtain âŸ¨y, hyâŸ© := exists_ne x\n  refine âŸ¨fun h => nonempty_closedBall.1 (h.mono sphere_subset_closedBall), fun hr =>\n    âŸ¨r â€¢ â€–y - xâ€–â»Â¹ â€¢ (y - x) + x, ?_âŸ©âŸ©\n  have : â€–y - xâ€– â‰  0 := by simpa [sub_eq_zero]\n  simp only [mem_sphere_iff_norm, add_sub_cancel_right, norm_smul, Real.norm_eq_abs, norm_inv,\n    norm_norm, ne_eq, norm_eq_zero]\n  simp only [abs_norm, ne_eq, norm_eq_zero]\n  rw [inv_mul_cancelâ‚€ this, mul_one, abs_eq_self.mpr hr]\n\n"}
{"name":"smul_sphere","module":"Mathlib.Analysis.NormedSpace.Pointwise","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : NormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : Nontrivial E\nc : ğ•œ\nx : E\nr : Real\nhr : LE.le 0 r\nâŠ¢ Eq (HSMul.hSMul c (Metric.sphere x r)) (Metric.sphere (HSMul.hSMul c x) (HMul.hMul (Norm.norm c) r))","decl":"theorem smul_sphere [Nontrivial E] (c : ğ•œ) (x : E) {r : â„} (hr : 0 â‰¤ r) :\n    c â€¢ sphere x r = sphere (c â€¢ x) (â€–câ€– * r) := by\n  rcases eq_or_ne c 0 with (rfl | hc)\n  Â· simp [zero_smul_set, Set.singleton_zero, hr]\n  Â· exact smul_sphere' hc x r\n\n"}
{"name":"affinity_unitBall","module":"Mathlib.Analysis.NormedSpace.Pointwise","initialProofState":"E : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nr : Real\nhr : LT.lt 0 r\nx : E\nâŠ¢ Eq (HVAdd.hVAdd x (HSMul.hSMul r (Metric.ball 0 1))) (Metric.ball x r)","decl":"/-- Any ball `Metric.ball x r`, `0 < r` is the image of the unit ball under `fun y â†¦ x + r â€¢ y`. -/\ntheorem affinity_unitBall {r : â„} (hr : 0 < r) (x : E) : x +áµ¥ r â€¢ ball (0 : E) 1 = ball x r := by\n  rw [smul_unitBall_of_pos hr, vadd_ball_zero]\n\n"}
{"name":"affinity_unitClosedBall","module":"Mathlib.Analysis.NormedSpace.Pointwise","initialProofState":"E : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nr : Real\nhr : LE.le 0 r\nx : E\nâŠ¢ Eq (HVAdd.hVAdd x (HSMul.hSMul r (Metric.closedBall 0 1))) (Metric.closedBall x r)","decl":"/-- Any closed ball `Metric.closedBall x r`, `0 â‰¤ r` is the image of the unit closed ball under\n`fun y â†¦ x + r â€¢ y`. -/\ntheorem affinity_unitClosedBall {r : â„} (hr : 0 â‰¤ r) (x : E) :\n    x +áµ¥ r â€¢ closedBall (0 : E) 1 = closedBall x r := by\n  rw [smul_unitClosedBall, Real.norm_of_nonneg hr, vadd_closedBall_zero]\n\n"}
