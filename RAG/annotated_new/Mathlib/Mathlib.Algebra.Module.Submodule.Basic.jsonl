{"name":"Submodule.toAddSubmonoid_strictMono","module":"Mathlib.Algebra.Module.Submodule.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ StrictMono Submodule.toAddSubmonoid","decl":"@[mono]\ntheorem toAddSubmonoid_strictMono : StrictMono (toAddSubmonoid : Submodule R M → AddSubmonoid M) :=\n  fun _ _ => id\n\n"}
{"name":"Submodule.toAddSubmonoid_le","module":"Mathlib.Algebra.Module.Submodule.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np q : Submodule R M\n⊢ Iff (LE.le p.toAddSubmonoid q.toAddSubmonoid) (LE.le p q)","decl":"theorem toAddSubmonoid_le : p.toAddSubmonoid ≤ q.toAddSubmonoid ↔ p ≤ q :=\n  Iff.rfl\n\n"}
{"name":"Submodule.toAddSubmonoid_mono","module":"Mathlib.Algebra.Module.Submodule.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Monotone Submodule.toAddSubmonoid","decl":"@[mono]\ntheorem toAddSubmonoid_mono : Monotone (toAddSubmonoid : Submodule R M → AddSubmonoid M) :=\n  toAddSubmonoid_strictMono.monotone\n\n"}
{"name":"Submodule.toSubMulAction_strictMono","module":"Mathlib.Algebra.Module.Submodule.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ StrictMono Submodule.toSubMulAction","decl":"@[mono]\ntheorem toSubMulAction_strictMono :\n    StrictMono (toSubMulAction : Submodule R M → SubMulAction R M) := fun _ _ => id\n\n"}
{"name":"Submodule.toSubMulAction_mono","module":"Mathlib.Algebra.Module.Submodule.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Monotone Submodule.toSubMulAction","decl":"@[mono]\ntheorem toSubMulAction_mono : Monotone (toSubMulAction : Submodule R M → SubMulAction R M) :=\n  toSubMulAction_strictMono.monotone\n\n"}
{"name":"Submodule.sum_mem","module":"Mathlib.Algebra.Module.Submodule.Basic","initialProofState":"R : Type u\nM : Type v\nι : Type w\ninst✝¹ : Semiring R\ninst✝ : AddCommMonoid M\nmodule_M : Module R M\np : Submodule R M\nt : Finset ι\nf : ι → M\na✝ : ∀ (c : ι), Membership.mem t c → Membership.mem p (f c)\n⊢ Membership.mem p (t.sum fun i => f i)","decl":"protected theorem sum_mem {t : Finset ι} {f : ι → M} : (∀ c ∈ t, f c ∈ p) → (∑ i ∈ t, f i) ∈ p :=\n  sum_mem\n\n"}
{"name":"Submodule.sum_smul_mem","module":"Mathlib.Algebra.Module.Submodule.Basic","initialProofState":"R : Type u\nM : Type v\nι : Type w\ninst✝¹ : Semiring R\ninst✝ : AddCommMonoid M\nmodule_M : Module R M\np : Submodule R M\nt : Finset ι\nf : ι → M\nr : ι → R\nhyp : ∀ (c : ι), Membership.mem t c → Membership.mem p (f c)\n⊢ Membership.mem p (t.sum fun i => HSMul.hSMul (r i) (f i))","decl":"theorem sum_smul_mem {t : Finset ι} {f : ι → M} (r : ι → R) (hyp : ∀ c ∈ t, f c ∈ p) :\n    (∑ i ∈ t, r i • f i) ∈ p :=\n  sum_mem fun i hi => smul_mem _ _ (hyp i hi)\n\n"}
{"name":"Submodule.isCentralScalar","module":"Mathlib.Algebra.Module.Submodule.Basic","initialProofState":"S : Type u'\nR : Type u\nM : Type v\ninst✝⁸ : Semiring R\ninst✝⁷ : AddCommMonoid M\nmodule_M : Module R M\np : Submodule R M\ninst✝⁶ : SMul S R\ninst✝⁵ : SMul S M\ninst✝⁴ : IsScalarTower S R M\ninst✝³ : SMul (MulOpposite S) R\ninst✝² : SMul (MulOpposite S) M\ninst✝¹ : IsScalarTower (MulOpposite S) R M\ninst✝ : IsCentralScalar S M\n⊢ IsCentralScalar S (Subtype fun x => Membership.mem p x)","decl":"instance isCentralScalar [SMul S R] [SMul S M] [IsScalarTower S R M] [SMul Sᵐᵒᵖ R] [SMul Sᵐᵒᵖ M]\n    [IsScalarTower Sᵐᵒᵖ R M] [IsCentralScalar S M] : IsCentralScalar S p :=\n  p.toSubMulAction.isCentralScalar\n\n"}
{"name":"Submodule.noZeroSMulDivisors","module":"Mathlib.Algebra.Module.Submodule.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\nmodule_M : Module R M\np : Submodule R M\ninst✝ : NoZeroSMulDivisors R M\n⊢ NoZeroSMulDivisors R (Subtype fun x => Membership.mem p x)","decl":"instance noZeroSMulDivisors [NoZeroSMulDivisors R M] : NoZeroSMulDivisors R p :=\n  ⟨fun {c} {x : p} h =>\n    have : c = 0 ∨ (x : M) = 0 := eq_zero_or_eq_zero_of_smul_eq_zero (congr_arg Subtype.val h)\n    this.imp_right (@Subtype.ext_iff _ _ x 0).mpr⟩\n\n"}
{"name":"Submodule.vaddCommClass","module":"Mathlib.Algebra.Module.Submodule.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\nmodule_M : Module R M\np : Submodule R M\nα : Type u_1\nβ : Type u_2\ninst✝² : VAdd M β\ninst✝¹ : VAdd α β\ninst✝ : VAddCommClass M α β\n⊢ VAddCommClass (Subtype fun x => Membership.mem p x) α β","decl":"instance vaddCommClass [VAdd M β] [VAdd α β] [VAddCommClass M α β] : VAddCommClass p α β :=\n  ⟨fun a => vadd_comm (a : M)⟩\n\n"}
{"name":"Submodule.instFaithfulVAddSubtypeMem","module":"Mathlib.Algebra.Module.Submodule.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\nmodule_M : Module R M\np : Submodule R M\nα : Type u_1\ninst✝¹ : VAdd M α\ninst✝ : FaithfulVAdd M α\n⊢ FaithfulVAdd (Subtype fun x => Membership.mem p x) α","decl":"instance [VAdd M α] [FaithfulVAdd M α] : FaithfulVAdd p α :=\n  ⟨fun h => Subtype.ext <| eq_of_vadd_eq_vadd h⟩\n\n"}
{"name":"Submodule.vadd_def","module":"Mathlib.Algebra.Module.Submodule.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\nmodule_M : Module R M\np : Submodule R M\nα : Type u_1\ninst✝ : VAdd M α\ng : Subtype fun x => Membership.mem p x\nm : α\n⊢ Eq (HVAdd.hVAdd g m) (HVAdd.hVAdd (↑g) m)","decl":"theorem vadd_def [VAdd M α] (g : p) (m : α) : g +ᵥ m = (g : M) +ᵥ m :=\n  rfl\n\n"}
{"name":"Submodule.toAddSubgroup_strictMono","module":"Mathlib.Algebra.Module.Submodule.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : Ring R\ninst✝ : AddCommGroup M\nmodule_M : Module R M\n⊢ StrictMono Submodule.toAddSubgroup","decl":"@[mono]\ntheorem toAddSubgroup_strictMono : StrictMono (toAddSubgroup : Submodule R M → AddSubgroup M) :=\n  fun _ _ => id\n\n"}
{"name":"Submodule.toAddSubgroup_le","module":"Mathlib.Algebra.Module.Submodule.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : Ring R\ninst✝ : AddCommGroup M\nmodule_M : Module R M\np p' : Submodule R M\n⊢ Iff (LE.le p.toAddSubgroup p'.toAddSubgroup) (LE.le p p')","decl":"theorem toAddSubgroup_le : p.toAddSubgroup ≤ p'.toAddSubgroup ↔ p ≤ p' :=\n  Iff.rfl\n\n"}
{"name":"Submodule.toAddSubgroup_mono","module":"Mathlib.Algebra.Module.Submodule.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : Ring R\ninst✝ : AddCommGroup M\nmodule_M : Module R M\n⊢ Monotone Submodule.toAddSubgroup","decl":"@[mono]\ntheorem toAddSubgroup_mono : Monotone (toAddSubgroup : Submodule R M → AddSubgroup M) :=\n  toAddSubgroup_strictMono.monotone\n\n-- See `neg_coe_set`\n"}
{"name":"Submodule.neg_coe","module":"Mathlib.Algebra.Module.Submodule.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : Ring R\ninst✝ : AddCommGroup M\nmodule_M : Module R M\np : Submodule R M\n⊢ Eq (Neg.neg ↑p) ↑p","decl":"theorem neg_coe : -(p : Set M) = p :=\n  Set.ext fun _ => p.neg_mem_iff\n\n"}
{"name":"Submodule.not_mem_of_ortho","module":"Mathlib.Algebra.Module.Submodule.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝³ : Ring R\ninst✝² : IsDomain R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nx : M\nN : Submodule R M\northo : ∀ (c : R) (y : M), Membership.mem N y → Eq (HAdd.hAdd (HSMul.hSMul c x) y) 0 → Eq c 0\n⊢ Not (Membership.mem N x)","decl":"theorem not_mem_of_ortho {x : M} {N : Submodule R M}\n    (ortho : ∀ (c : R), ∀ y ∈ N, c • x + y = (0 : M) → c = 0) : x ∉ N := by\n  intro hx\n  simpa using ortho (-1) x hx\n\n"}
{"name":"Submodule.ne_zero_of_ortho","module":"Mathlib.Algebra.Module.Submodule.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝³ : Ring R\ninst✝² : IsDomain R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nx : M\nN : Submodule R M\northo : ∀ (c : R) (y : M), Membership.mem N y → Eq (HAdd.hAdd (HSMul.hSMul c x) y) 0 → Eq c 0\n⊢ Ne x 0","decl":"theorem ne_zero_of_ortho {x : M} {N : Submodule R M}\n    (ortho : ∀ (c : R), ∀ y ∈ N, c • x + y = (0 : M) → c = 0) : x ≠ 0 :=\n  mt (fun h => show x ∈ N from h.symm ▸ N.zero_mem) (not_mem_of_ortho ortho)\n\n"}
{"name":"Submodule.smul_mem_iff","module":"Mathlib.Algebra.Module.Submodule.Basic","initialProofState":"S : Type u'\nR : Type u\nM : Type v\ninst✝⁶ : DivisionSemiring S\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : SMul S R\ninst✝¹ : Module S M\ninst✝ : IsScalarTower S R M\np : Submodule R M\ns : S\nx : M\ns0 : Ne s 0\n⊢ Iff (Membership.mem p (HSMul.hSMul s x)) (Membership.mem p x)","decl":"theorem smul_mem_iff (s0 : s ≠ 0) : s • x ∈ p ↔ x ∈ p :=\n  p.toSubMulAction.smul_mem_iff s0\n\n"}
