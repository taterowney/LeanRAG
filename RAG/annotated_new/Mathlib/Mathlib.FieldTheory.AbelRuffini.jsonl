{"name":"gal_zero_isSolvable","module":"Mathlib.FieldTheory.AbelRuffini","initialProofState":"F : Type u_1\ninst✝ : Field F\n⊢ IsSolvable (Polynomial.Gal 0)","decl":"theorem gal_zero_isSolvable : IsSolvable (0 : F[X]).Gal := by infer_instance\n\n"}
{"name":"gal_one_isSolvable","module":"Mathlib.FieldTheory.AbelRuffini","initialProofState":"F : Type u_1\ninst✝ : Field F\n⊢ IsSolvable (Polynomial.Gal 1)","decl":"theorem gal_one_isSolvable : IsSolvable (1 : F[X]).Gal := by infer_instance\n\n"}
{"name":"gal_C_isSolvable","module":"Mathlib.FieldTheory.AbelRuffini","initialProofState":"F : Type u_1\ninst✝ : Field F\nx : F\n⊢ IsSolvable (Polynomial.C x).Gal","decl":"theorem gal_C_isSolvable (x : F) : IsSolvable (C x).Gal := by infer_instance\n\n"}
{"name":"gal_X_isSolvable","module":"Mathlib.FieldTheory.AbelRuffini","initialProofState":"F : Type u_1\ninst✝ : Field F\n⊢ IsSolvable Polynomial.X.Gal","decl":"theorem gal_X_isSolvable : IsSolvable (X : F[X]).Gal := by infer_instance\n\n"}
{"name":"gal_X_sub_C_isSolvable","module":"Mathlib.FieldTheory.AbelRuffini","initialProofState":"F : Type u_1\ninst✝ : Field F\nx : F\n⊢ IsSolvable (HSub.hSub Polynomial.X (Polynomial.C x)).Gal","decl":"theorem gal_X_sub_C_isSolvable (x : F) : IsSolvable (X - C x).Gal := by infer_instance\n\n"}
{"name":"gal_X_pow_isSolvable","module":"Mathlib.FieldTheory.AbelRuffini","initialProofState":"F : Type u_1\ninst✝ : Field F\nn : Nat\n⊢ IsSolvable (HPow.hPow Polynomial.X n).Gal","decl":"theorem gal_X_pow_isSolvable (n : ℕ) : IsSolvable (X ^ n : F[X]).Gal := by infer_instance\n\n"}
{"name":"gal_mul_isSolvable","module":"Mathlib.FieldTheory.AbelRuffini","initialProofState":"F : Type u_1\ninst✝ : Field F\np q : Polynomial F\nx✝¹ : IsSolvable p.Gal\nx✝ : IsSolvable q.Gal\n⊢ IsSolvable (HMul.hMul p q).Gal","decl":"theorem gal_mul_isSolvable {p q : F[X]} (_ : IsSolvable p.Gal) (_ : IsSolvable q.Gal) :\n    IsSolvable (p * q).Gal :=\n  solvable_of_solvable_injective (Gal.restrictProd_injective p q)\n\n"}
{"name":"gal_prod_isSolvable","module":"Mathlib.FieldTheory.AbelRuffini","initialProofState":"F : Type u_1\ninst✝ : Field F\ns : Multiset (Polynomial F)\nhs : ∀ (p : Polynomial F), Membership.mem s p → IsSolvable p.Gal\n⊢ IsSolvable s.prod.Gal","decl":"theorem gal_prod_isSolvable {s : Multiset F[X]} (hs : ∀ p ∈ s, IsSolvable (Gal p)) :\n    IsSolvable s.prod.Gal := by\n  apply Multiset.induction_on' s\n  · exact gal_one_isSolvable\n  · intro p t hps _ ht\n    rw [Multiset.insert_eq_cons, Multiset.prod_cons]\n    exact gal_mul_isSolvable (hs p hps) ht\n\n"}
{"name":"gal_isSolvable_of_splits","module":"Mathlib.FieldTheory.AbelRuffini","initialProofState":"F : Type u_1\ninst✝ : Field F\np q : Polynomial F\nx✝ : Fact (Polynomial.Splits (algebraMap F q.SplittingField) p)\nhq : IsSolvable q.Gal\n⊢ IsSolvable p.Gal","decl":"theorem gal_isSolvable_of_splits {p q : F[X]}\n    (_ : Fact (p.Splits (algebraMap F q.SplittingField))) (hq : IsSolvable q.Gal) :\n    IsSolvable p.Gal :=\n  haveI : IsSolvable (q.SplittingField ≃ₐ[F] q.SplittingField) := hq\n  solvable_of_surjective (AlgEquiv.restrictNormalHom_surjective q.SplittingField)\n\n"}
{"name":"gal_isSolvable_tower","module":"Mathlib.FieldTheory.AbelRuffini","initialProofState":"F : Type u_1\ninst✝ : Field F\np q : Polynomial F\nhpq : Polynomial.Splits (algebraMap F q.SplittingField) p\nhp : IsSolvable p.Gal\nhq : IsSolvable (Polynomial.map (algebraMap F p.SplittingField) q).Gal\n⊢ IsSolvable q.Gal","decl":"theorem gal_isSolvable_tower (p q : F[X]) (hpq : p.Splits (algebraMap F q.SplittingField))\n    (hp : IsSolvable p.Gal) (hq : IsSolvable (q.map (algebraMap F p.SplittingField)).Gal) :\n    IsSolvable q.Gal := by\n  let K := p.SplittingField\n  let L := q.SplittingField\n  haveI : Fact (p.Splits (algebraMap F L)) := ⟨hpq⟩\n  let ϕ : (L ≃ₐ[K] L) ≃* (q.map (algebraMap F K)).Gal :=\n    (IsSplittingField.algEquiv L (q.map (algebraMap F K))).autCongr\n  have ϕ_inj : Function.Injective ϕ.toMonoidHom := ϕ.injective\n  haveI : IsSolvable (K ≃ₐ[F] K) := hp\n  haveI : IsSolvable (L ≃ₐ[K] L) := solvable_of_solvable_injective ϕ_inj\n  exact isSolvable_of_isScalarTower F p.SplittingField q.SplittingField\n\n"}
{"name":"gal_X_pow_sub_one_isSolvable","module":"Mathlib.FieldTheory.AbelRuffini","initialProofState":"F : Type u_1\ninst✝ : Field F\nn : Nat\n⊢ IsSolvable (HSub.hSub (HPow.hPow Polynomial.X n) 1).Gal","decl":"theorem gal_X_pow_sub_one_isSolvable (n : ℕ) : IsSolvable (X ^ n - 1 : F[X]).Gal := by\n  by_cases hn : n = 0\n  · rw [hn, pow_zero, sub_self]\n    exact gal_zero_isSolvable\n  have hn' : 0 < n := pos_iff_ne_zero.mpr hn\n  have hn'' : (X ^ n - 1 : F[X]) ≠ 0 := X_pow_sub_C_ne_zero hn' 1\n  apply isSolvable_of_comm\n  intro σ τ\n  ext a ha\n  simp only [mem_rootSet_of_ne hn'', map_sub, aeval_X_pow, aeval_one, sub_eq_zero] at ha\n  have key : ∀ σ : (X ^ n - 1 : F[X]).Gal, ∃ m : ℕ, σ a = a ^ m := by\n    intro σ\n    lift n to ℕ+ using hn'\n    exact map_rootsOfUnity_eq_pow_self σ.toAlgHom (rootsOfUnity.mkOfPowEq a ha)\n  obtain ⟨c, hc⟩ := key σ\n  obtain ⟨d, hd⟩ := key τ\n  rw [σ.mul_apply, τ.mul_apply, hc, map_pow, hd, map_pow, hc, ← pow_mul, pow_mul']\n\n"}
{"name":"gal_X_pow_sub_C_isSolvable_aux","module":"Mathlib.FieldTheory.AbelRuffini","initialProofState":"F : Type u_1\ninst✝ : Field F\nn : Nat\na : F\nh : Polynomial.Splits (RingHom.id F) (HSub.hSub (HPow.hPow Polynomial.X n) 1)\n⊢ IsSolvable (HSub.hSub (HPow.hPow Polynomial.X n) (Polynomial.C a)).Gal","decl":"theorem gal_X_pow_sub_C_isSolvable_aux (n : ℕ) (a : F)\n    (h : (X ^ n - 1 : F[X]).Splits (RingHom.id F)) : IsSolvable (X ^ n - C a).Gal := by\n  by_cases ha : a = 0\n  · rw [ha, C_0, sub_zero]\n    exact gal_X_pow_isSolvable n\n  have ha' : algebraMap F (X ^ n - C a).SplittingField a ≠ 0 :=\n    mt ((injective_iff_map_eq_zero _).mp (RingHom.injective _) a) ha\n  by_cases hn : n = 0\n  · rw [hn, pow_zero, ← C_1, ← C_sub]\n    exact gal_C_isSolvable (1 - a)\n  have hn' : 0 < n := pos_iff_ne_zero.mpr hn\n  have hn'' : X ^ n - C a ≠ 0 := X_pow_sub_C_ne_zero hn' a\n  have hn''' : (X ^ n - 1 : F[X]) ≠ 0 := X_pow_sub_C_ne_zero hn' 1\n  have mem_range : ∀ {c : (X ^ n - C a).SplittingField},\n      (c ^ n = 1 → (∃ d, algebraMap F (X ^ n - C a).SplittingField d = c)) := fun {c} hc =>\n    RingHom.mem_range.mp (minpoly.mem_range_of_degree_eq_one F c (h.def.resolve_left hn'''\n      (minpoly.irreducible ((SplittingField.instNormal (X ^ n - C a)).isIntegral c))\n      (minpoly.dvd F c (by rwa [map_id, map_sub, sub_eq_zero, aeval_X_pow, aeval_one]))))\n  apply isSolvable_of_comm\n  intro σ τ\n  ext b hb\n  rw [mem_rootSet_of_ne hn'', map_sub, aeval_X_pow, aeval_C, sub_eq_zero] at hb\n  have hb' : b ≠ 0 := by\n    intro hb'\n    rw [hb', zero_pow hn] at hb\n    exact ha' hb.symm\n  have key : ∀ σ : (X ^ n - C a).Gal, ∃ c, σ b = b * algebraMap F _ c := by\n    intro σ\n    have key : (σ b / b) ^ n = 1 := by rw [div_pow, ← map_pow, hb, σ.commutes, div_self ha']\n    obtain ⟨c, hc⟩ := mem_range key\n    use c\n    rw [hc, mul_div_cancel₀ (σ b) hb']\n  obtain ⟨c, hc⟩ := key σ\n  obtain ⟨d, hd⟩ := key τ\n  rw [σ.mul_apply, τ.mul_apply, hc, map_mul, τ.commutes, hd, map_mul, σ.commutes, hc,\n    mul_assoc, mul_assoc, mul_right_inj' hb', mul_comm]\n\n"}
{"name":"splits_X_pow_sub_one_of_X_pow_sub_C","module":"Mathlib.FieldTheory.AbelRuffini","initialProofState":"F : Type u_3\ninst✝¹ : Field F\nE : Type u_4\ninst✝ : Field E\ni : RingHom F E\nn : Nat\na : F\nha : Ne a 0\nh : Polynomial.Splits i (HSub.hSub (HPow.hPow Polynomial.X n) (Polynomial.C a))\n⊢ Polynomial.Splits i (HSub.hSub (HPow.hPow Polynomial.X n) 1)","decl":"theorem splits_X_pow_sub_one_of_X_pow_sub_C {F : Type*} [Field F] {E : Type*} [Field E]\n    (i : F →+* E) (n : ℕ) {a : F} (ha : a ≠ 0) (h : (X ^ n - C a).Splits i) :\n    (X ^ n - 1 : F[X]).Splits i := by\n  have ha' : i a ≠ 0 := mt ((injective_iff_map_eq_zero i).mp i.injective a) ha\n  by_cases hn : n = 0\n  · rw [hn, pow_zero, sub_self]\n    exact splits_zero i\n  have hn' : 0 < n := pos_iff_ne_zero.mpr hn\n  have hn'' : (X ^ n - C a).degree ≠ 0 :=\n    ne_of_eq_of_ne (degree_X_pow_sub_C hn' a) (mt WithBot.coe_eq_coe.mp hn)\n  obtain ⟨b, hb⟩ := exists_root_of_splits i h hn''\n  rw [eval₂_sub, eval₂_X_pow, eval₂_C, sub_eq_zero] at hb\n  have hb' : b ≠ 0 := by\n    intro hb'\n    rw [hb', zero_pow hn] at hb\n    exact ha' hb.symm\n  let s := ((X ^ n - C a).map i).roots\n  have hs : _ = _ * (s.map _).prod := eq_prod_roots_of_splits h\n  rw [leadingCoeff_X_pow_sub_C hn', RingHom.map_one, C_1, one_mul] at hs\n  have hs' : Multiset.card s = n := (natDegree_eq_card_roots h).symm.trans natDegree_X_pow_sub_C\n  apply @splits_of_exists_multiset F E _ _ i (X ^ n - 1) (s.map fun c : E => c / b)\n  rw [leadingCoeff_X_pow_sub_one hn', RingHom.map_one, C_1, one_mul, Multiset.map_map]\n  have C_mul_C : C (i a⁻¹) * C (i a) = 1 := by\n    rw [← C_mul, ← i.map_mul, inv_mul_cancel₀ ha, i.map_one, C_1]\n  have key1 : (X ^ n - 1 : F[X]).map i = C (i a⁻¹) * ((X ^ n - C a).map i).comp (C b * X) := by\n    rw [Polynomial.map_sub, Polynomial.map_sub, Polynomial.map_pow, map_X, map_C,\n      Polynomial.map_one, sub_comp, pow_comp, X_comp, C_comp, mul_pow, ← C_pow, hb, mul_sub, ←\n      mul_assoc, C_mul_C, one_mul]\n  have key2 : ((fun q : E[X] => q.comp (C b * X)) ∘ fun c : E => X - C c) = fun c : E =>\n      C b * (X - C (c / b)) := by\n    ext1 c\n    dsimp only [Function.comp_apply]\n    rw [sub_comp, X_comp, C_comp, mul_sub, ← C_mul, mul_div_cancel₀ c hb']\n  rw [key1, hs, multiset_prod_comp, Multiset.map_map, key2, Multiset.prod_map_mul,\n    -- Porting note: needed for `Multiset.map_const` to work\n    show (fun (_ : E) => C b) = Function.const E (C b) by rfl,\n    Multiset.map_const, Multiset.prod_replicate, hs', ← C_pow, hb, ← mul_assoc, C_mul_C, one_mul]\n  rfl\n\n"}
{"name":"gal_X_pow_sub_C_isSolvable","module":"Mathlib.FieldTheory.AbelRuffini","initialProofState":"F : Type u_1\ninst✝ : Field F\nn : Nat\nx : F\n⊢ IsSolvable (HSub.hSub (HPow.hPow Polynomial.X n) (Polynomial.C x)).Gal","decl":"theorem gal_X_pow_sub_C_isSolvable (n : ℕ) (x : F) : IsSolvable (X ^ n - C x).Gal := by\n  by_cases hx : x = 0\n  · rw [hx, C_0, sub_zero]\n    exact gal_X_pow_isSolvable n\n  apply gal_isSolvable_tower (X ^ n - 1) (X ^ n - C x)\n  · exact splits_X_pow_sub_one_of_X_pow_sub_C _ n hx (SplittingField.splits _)\n  · exact gal_X_pow_sub_one_isSolvable n\n  · rw [Polynomial.map_sub, Polynomial.map_pow, map_X, map_C]\n    apply gal_X_pow_sub_C_isSolvable_aux\n    have key := SplittingField.splits (X ^ n - 1 : F[X])\n    rwa [← splits_id_iff_splits, Polynomial.map_sub, Polynomial.map_pow, map_X,\n      Polynomial.map_one] at key\n\n"}
{"name":"IsSolvableByRad.brecOn","module":"Mathlib.FieldTheory.AbelRuffini","initialProofState":"F : Type u_1\ninst✝² : Field F\nE : Type u_2\ninst✝¹ : Field E\ninst✝ : Algebra F E\nmotive✝ : (a : E) → IsSolvableByRad F a → Prop\na✝ : E\nx✝ : IsSolvableByRad F a✝\nih✝ : ∀ (a : E) (x : IsSolvableByRad F a), x.below → motive✝ a x\n⊢ motive✝ a✝ x✝","decl":"/-- Inductive definition of solvable by radicals -/\ninductive IsSolvableByRad : E → Prop\n  | base (α : F) : IsSolvableByRad (algebraMap F E α)\n  | add (α β : E) : IsSolvableByRad α → IsSolvableByRad β → IsSolvableByRad (α + β)\n  | neg (α : E) : IsSolvableByRad α → IsSolvableByRad (-α)\n  | mul (α β : E) : IsSolvableByRad α → IsSolvableByRad β → IsSolvableByRad (α * β)\n  | inv (α : E) : IsSolvableByRad α → IsSolvableByRad α⁻¹\n  | rad (α : E) (n : ℕ) (hn : n ≠ 0) : IsSolvableByRad (α ^ n) → IsSolvableByRad α\n\n"}
{"name":"solvableByRad.induction","module":"Mathlib.FieldTheory.AbelRuffini","initialProofState":"F : Type u_1\ninst✝² : Field F\nE : Type u_2\ninst✝¹ : Field E\ninst✝ : Algebra F E\nP : (Subtype fun x => Membership.mem (solvableByRad F E) x) → Prop\nbase : ∀ (α : F), P ((algebraMap F (Subtype fun x => Membership.mem (solvableByRad F E) x)) α)\nadd : ∀ (α β : Subtype fun x => Membership.mem (solvableByRad F E) x), P α → P β → P (HAdd.hAdd α β)\nneg : ∀ (α : Subtype fun x => Membership.mem (solvableByRad F E) x), P α → P (Neg.neg α)\nmul : ∀ (α β : Subtype fun x => Membership.mem (solvableByRad F E) x), P α → P β → P (HMul.hMul α β)\ninv : ∀ (α : Subtype fun x => Membership.mem (solvableByRad F E) x), P α → P (Inv.inv α)\nrad : ∀ (α : Subtype fun x => Membership.mem (solvableByRad F E) x) (n : Nat), Ne n 0 → P (HPow.hPow α n) → P α\nα : Subtype fun x => Membership.mem (solvableByRad F E) x\n⊢ P α","decl":"theorem induction (P : solvableByRad F E → Prop)\n    (base : ∀ α : F, P (algebraMap F (solvableByRad F E) α))\n    (add : ∀ α β : solvableByRad F E, P α → P β → P (α + β))\n    (neg : ∀ α : solvableByRad F E, P α → P (-α))\n    (mul : ∀ α β : solvableByRad F E, P α → P β → P (α * β))\n    (inv : ∀ α : solvableByRad F E, P α → P α⁻¹)\n    (rad : ∀ α : solvableByRad F E, ∀ n : ℕ, n ≠ 0 → P (α ^ n) → P α) (α : solvableByRad F E) :\n    P α := by\n  revert α\n  suffices ∀ α : E, IsSolvableByRad F α → ∃ β : solvableByRad F E, ↑β = α ∧ P β by\n    intro α\n    obtain ⟨α₀, hα₀, Pα⟩ := this α (Subtype.mem α)\n    convert Pα\n    exact Subtype.ext hα₀.symm\n  apply IsSolvableByRad.rec\n  · exact fun α => ⟨algebraMap F (solvableByRad F E) α, rfl, base α⟩\n  · intro α β _ _ Pα Pβ\n    obtain ⟨⟨α₀, hα₀, Pα⟩, β₀, hβ₀, Pβ⟩ := Pα, Pβ\n    exact ⟨α₀ + β₀, by rw [← hα₀, ← hβ₀]; rfl, add α₀ β₀ Pα Pβ⟩\n  · intro α _ Pα\n    obtain ⟨α₀, hα₀, Pα⟩ := Pα\n    exact ⟨-α₀, by rw [← hα₀]; rfl, neg α₀ Pα⟩\n  · intro α β _ _ Pα Pβ\n    obtain ⟨⟨α₀, hα₀, Pα⟩, β₀, hβ₀, Pβ⟩ := Pα, Pβ\n    exact ⟨α₀ * β₀, by rw [← hα₀, ← hβ₀]; rfl, mul α₀ β₀ Pα Pβ⟩\n  · intro α _ Pα\n    obtain ⟨α₀, hα₀, Pα⟩ := Pα\n    exact ⟨α₀⁻¹, by rw [← hα₀]; rfl, inv α₀ Pα⟩\n  · intro α n hn hα Pα\n    obtain ⟨α₀, hα₀, Pα⟩ := Pα\n    refine ⟨⟨α, IsSolvableByRad.rad α n hn hα⟩, rfl, rad _ n hn ?_⟩\n    convert Pα\n    exact Subtype.ext (Eq.trans ((solvableByRad F E).coe_pow _ n) hα₀.symm)\n\n"}
{"name":"solvableByRad.isIntegral","module":"Mathlib.FieldTheory.AbelRuffini","initialProofState":"F : Type u_1\ninst✝² : Field F\nE : Type u_2\ninst✝¹ : Field E\ninst✝ : Algebra F E\nα : Subtype fun x => Membership.mem (solvableByRad F E) x\n⊢ IsIntegral F α","decl":"theorem isIntegral (α : solvableByRad F E) : IsIntegral F α := by\n  revert α\n  apply solvableByRad.induction\n  · exact fun _ => isIntegral_algebraMap\n  · exact fun _ _ => IsIntegral.add\n  · exact fun _ => IsIntegral.neg\n  · exact fun _ _ => IsIntegral.mul\n  · intro α hα\n    exact IsIntegral.inv hα\n  · intro α n hn hα\n    obtain ⟨p, h1, h2⟩ := hα.isAlgebraic\n    refine IsAlgebraic.isIntegral ⟨p.comp (X ^ n),\n      ⟨fun h => h1 (leadingCoeff_eq_zero.mp ?_), by rw [aeval_comp, aeval_X_pow, h2]⟩⟩\n    rwa [← leadingCoeff_eq_zero, leadingCoeff_comp, leadingCoeff_X_pow, one_pow, mul_one] at h\n    rwa [natDegree_X_pow]\n\n"}
{"name":"solvableByRad.induction3","module":"Mathlib.FieldTheory.AbelRuffini","initialProofState":"F : Type u_1\ninst✝² : Field F\nE : Type u_2\ninst✝¹ : Field E\ninst✝ : Algebra F E\nα : Subtype fun x => Membership.mem (solvableByRad F E) x\nn : Nat\nhn : Ne n 0\nhα : solvableByRad.P (HPow.hPow α n)\n⊢ solvableByRad.P α","decl":"/-- An auxiliary induction lemma, which is generalized by `solvableByRad.isSolvable`. -/\ntheorem induction3 {α : solvableByRad F E} {n : ℕ} (hn : n ≠ 0) (hα : P (α ^ n)) : P α := by\n  let p := minpoly F (α ^ n)\n  have hp : p.comp (X ^ n) ≠ 0 := by\n    intro h\n    cases' comp_eq_zero_iff.mp h with h' h'\n    · exact minpoly.ne_zero (isIntegral (α ^ n)) h'\n    · exact hn (by rw [← @natDegree_C F, ← h'.2, natDegree_X_pow])\n  apply gal_isSolvable_of_splits\n  · exact ⟨splits_of_splits_of_dvd _ hp (SplittingField.splits (p.comp (X ^ n)))\n      (minpoly.dvd F α (by rw [aeval_comp, aeval_X_pow, minpoly.aeval]))⟩\n  · refine gal_isSolvable_tower p (p.comp (X ^ n)) ?_ hα ?_\n    · exact Gal.splits_in_splittingField_of_comp _ _ (by rwa [natDegree_X_pow])\n    · obtain ⟨s, hs⟩ := (splits_iff_exists_multiset _).1 (SplittingField.splits p)\n      rw [map_comp, Polynomial.map_pow, map_X, hs, mul_comp, C_comp]\n      apply gal_mul_isSolvable (gal_C_isSolvable _)\n      rw [multiset_prod_comp]\n      apply gal_prod_isSolvable\n      intro q hq\n      rw [Multiset.mem_map] at hq\n      obtain ⟨q, hq, rfl⟩ := hq\n      rw [Multiset.mem_map] at hq\n      obtain ⟨q, _, rfl⟩ := hq\n      rw [sub_comp, X_comp, C_comp]\n      exact gal_X_pow_sub_C_isSolvable n q\n\n"}
{"name":"solvableByRad.induction2","module":"Mathlib.FieldTheory.AbelRuffini","initialProofState":"F : Type u_1\ninst✝² : Field F\nE : Type u_2\ninst✝¹ : Field E\ninst✝ : Algebra F E\nα β γ : Subtype fun x => Membership.mem (solvableByRad F E) x\nhγ : Membership.mem (IntermediateField.adjoin F (Insert.insert α (Singleton.singleton β))) γ\nhα : solvableByRad.P α\nhβ : solvableByRad.P β\n⊢ solvableByRad.P γ","decl":"/-- An auxiliary induction lemma, which is generalized by `solvableByRad.isSolvable`. -/\ntheorem induction2 {α β γ : solvableByRad F E} (hγ : γ ∈ F⟮α, β⟯) (hα : P α) (hβ : P β) : P γ := by\n  let p := minpoly F α\n  let q := minpoly F β\n  have hpq := Polynomial.splits_of_splits_mul _\n    (mul_ne_zero (minpoly.ne_zero (isIntegral α)) (minpoly.ne_zero (isIntegral β)))\n    (SplittingField.splits (p * q))\n  let f : ↥F⟮α, β⟯ →ₐ[F] (p * q).SplittingField :=\n    Classical.choice <| nonempty_algHom_adjoin_of_splits <| by\n      intro x hx\n      simp only [Set.mem_insert_iff, Set.mem_singleton_iff] at hx\n      cases hx with rw [hx]\n      | inl hx => exact ⟨isIntegral α, hpq.1⟩\n      | inr hx => exact ⟨isIntegral β, hpq.2⟩\n  have key : minpoly F γ = minpoly F (f ⟨γ, hγ⟩) := by\n    refine minpoly.eq_of_irreducible_of_monic\n      (minpoly.irreducible (isIntegral γ)) ?_ (minpoly.monic (isIntegral γ))\n    suffices aeval (⟨γ, hγ⟩ : F⟮α, β⟯) (minpoly F γ) = 0 by\n      rw [aeval_algHom_apply, this, map_zero]\n    apply (algebraMap (↥F⟮α, β⟯) (solvableByRad F E)).injective\n    simp only [map_zero, _root_.map_eq_zero]\n    -- Porting note: end of the proof was `exact minpoly.aeval F γ`.\n    apply Subtype.val_injective\n    -- This used to be `simp`, but we need `erw` and `simp` after https://github.com/leanprover/lean4/pull/2644\n    erw [Polynomial.aeval_subalgebra_coe (minpoly F γ)]\n    simp\n  rw [P, key]\n  refine gal_isSolvable_of_splits ⟨Normal.splits ?_ (f ⟨γ, hγ⟩)⟩ (gal_mul_isSolvable hα hβ)\n  apply SplittingField.instNormal\n\n"}
{"name":"solvableByRad.induction1","module":"Mathlib.FieldTheory.AbelRuffini","initialProofState":"F : Type u_1\ninst✝² : Field F\nE : Type u_2\ninst✝¹ : Field E\ninst✝ : Algebra F E\nα β : Subtype fun x => Membership.mem (solvableByRad F E) x\nhβ : Membership.mem (IntermediateField.adjoin F (Singleton.singleton α)) β\nhα : solvableByRad.P α\n⊢ solvableByRad.P β","decl":"/-- An auxiliary induction lemma, which is generalized by `solvableByRad.isSolvable`. -/\ntheorem induction1 {α β : solvableByRad F E} (hβ : β ∈ F⟮α⟯) (hα : P α) : P β :=\n  induction2 (adjoin.mono F _ _ (ge_of_eq (Set.pair_eq_singleton α)) hβ) hα hα\n\n"}
{"name":"solvableByRad.isSolvable","module":"Mathlib.FieldTheory.AbelRuffini","initialProofState":"F : Type u_1\ninst✝² : Field F\nE : Type u_2\ninst✝¹ : Field E\ninst✝ : Algebra F E\nα : Subtype fun x => Membership.mem (solvableByRad F E) x\n⊢ IsSolvable (minpoly F α).Gal","decl":"theorem isSolvable (α : solvableByRad F E) : IsSolvable (minpoly F α).Gal := by\n  revert α\n  apply solvableByRad.induction\n  · exact fun α => by rw [minpoly.eq_X_sub_C (solvableByRad F E)]; exact gal_X_sub_C_isSolvable α\n  · exact fun α β => induction2 (add_mem (subset_adjoin F _ (Set.mem_insert α _))\n      (subset_adjoin F _ (Set.mem_insert_of_mem α (Set.mem_singleton β))))\n  · exact fun α => induction1 (neg_mem (mem_adjoin_simple_self F α))\n  · exact fun α β => induction2 (mul_mem (subset_adjoin F _ (Set.mem_insert α _))\n      (subset_adjoin F _ (Set.mem_insert_of_mem α (Set.mem_singleton β))))\n  · exact fun α => induction1 (inv_mem (mem_adjoin_simple_self F α))\n  · exact fun α n => induction3\n\n"}
{"name":"solvableByRad.isSolvable'","module":"Mathlib.FieldTheory.AbelRuffini","initialProofState":"F : Type u_1\ninst✝² : Field F\nE : Type u_2\ninst✝¹ : Field E\ninst✝ : Algebra F E\nα : E\nq : Polynomial F\nq_irred : Irreducible q\nq_aeval : Eq ((Polynomial.aeval α) q) 0\nhα : IsSolvableByRad F α\n⊢ IsSolvable q.Gal","decl":"/-- **Abel-Ruffini Theorem** (one direction): An irreducible polynomial with an\n`IsSolvableByRad` root has solvable Galois group -/\ntheorem isSolvable' {α : E} {q : F[X]} (q_irred : Irreducible q) (q_aeval : aeval α q = 0)\n    (hα : IsSolvableByRad F α) : IsSolvable q.Gal := by\n  have : _root_.IsSolvable (q * C q.leadingCoeff⁻¹).Gal := by\n    rw [minpoly.eq_of_irreducible q_irred q_aeval, ←\n      show minpoly F (⟨α, hα⟩ : solvableByRad F E) = minpoly F α from\n        (minpoly.algebraMap_eq (RingHom.injective _) _).symm]\n    exact isSolvable ⟨α, hα⟩\n  refine solvable_of_surjective (Gal.restrictDvd_surjective ⟨C q.leadingCoeff⁻¹, rfl⟩ ?_)\n  rw [mul_ne_zero_iff, Ne, Ne, C_eq_zero, inv_eq_zero]\n  exact ⟨q_irred.ne_zero, leadingCoeff_ne_zero.mpr q_irred.ne_zero⟩\n\n"}
