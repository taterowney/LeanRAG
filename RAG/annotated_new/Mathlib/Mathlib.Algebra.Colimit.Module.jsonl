{"name":"Module.DirectedSystem.map_self","module":"Mathlib.Algebra.Colimit.Module","initialProofState":"ι : Type u_1\ninst✝² : Preorder ι\nF : ι → Type u_4\nT : ⦃i j : ι⦄ → LE.le i j → Sort u_8\nf : (i j : ι) → (h : LE.le i j) → T h\ninst✝¹ : ⦃i j : ι⦄ → (h : LE.le i j) → FunLike (T h) (F i) (F j)\ninst✝ : DirectedSystem F fun x1 x2 x3 => ⇑(f x1 x2 x3)\ni : ι\nx : F i\n⊢ Eq ((f i i ⋯) x) x","decl":"alias DirectedSystem.map_self := DirectedSystem.map_self'\n"}
{"name":"Module.DirectedSystem.map_map","module":"Mathlib.Algebra.Colimit.Module","initialProofState":"ι : Type u_1\ninst✝² : Preorder ι\nF : ι → Type u_4\nT : ⦃i j : ι⦄ → LE.le i j → Sort u_8\nf : (i j : ι) → (h : LE.le i j) → T h\ninst✝¹ : ⦃i j : ι⦄ → (h : LE.le i j) → FunLike (T h) (F i) (F j)\ninst✝ : DirectedSystem F fun x1 x2 x3 => ⇑(f x1 x2 x3)\ni j k : ι\nhij : LE.le i j\nhjk : LE.le j k\nx : F i\n⊢ Eq ((f j k hjk) ((f i j hij) x)) ((f i k ⋯) x)","decl":"alias DirectedSystem.map_map := DirectedSystem.map_map'\n\n"}
{"name":"Module.DirectLimit.quotMk_of","module":"Mathlib.Algebra.Colimit.Module","initialProofState":"R : Type u_1\ninst✝⁴ : Semiring R\nι : Type u_2\ninst✝³ : Preorder ι\nG : ι → Type u_3\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → AddCommMonoid (G i)\ninst✝ : (i : ι) → Module R (G i)\nf : (i j : ι) → LE.le i j → LinearMap (RingHom.id R) (G i) (G j)\ni : ι\nx : G i\n⊢ Eq (Quot.mk (⇑(addConGen (Module.DirectLimit.Eqv f)).toSetoid) ((DirectSum.of G i) x)) ((Module.DirectLimit.of R ι G f i) x)","decl":"theorem quotMk_of (i x) : Quot.mk _ (.of G i x) = of R ι G f i x := rfl\n\n"}
{"name":"Module.DirectLimit.of_f","module":"Mathlib.Algebra.Colimit.Module","initialProofState":"R : Type u_1\ninst✝⁴ : Semiring R\nι : Type u_2\ninst✝³ : Preorder ι\nG : ι → Type u_3\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → AddCommMonoid (G i)\ninst✝ : (i : ι) → Module R (G i)\nf : (i j : ι) → LE.le i j → LinearMap (RingHom.id R) (G i) (G j)\ni j : ι\nhij : LE.le i j\nx : G i\n⊢ Eq ((Module.DirectLimit.of R ι G f j) ((f i j hij) x)) ((Module.DirectLimit.of R ι G f i) x)","decl":"@[simp]\ntheorem of_f {i j hij x} : of R ι G f j (f i j hij x) = of R ι G f i x :=\n  (AddCon.eq _).mpr <| .symm <| .of _ _ (.of_map _ _)\n\n"}
{"name":"Module.DirectLimit.exists_of","module":"Mathlib.Algebra.Colimit.Module","initialProofState":"R : Type u_1\ninst✝⁶ : Semiring R\nι : Type u_2\ninst✝⁵ : Preorder ι\nG : ι → Type u_3\ninst✝⁴ : DecidableEq ι\ninst✝³ : (i : ι) → AddCommMonoid (G i)\ninst✝² : (i : ι) → Module R (G i)\nf : (i j : ι) → LE.le i j → LinearMap (RingHom.id R) (G i) (G j)\ninst✝¹ : Nonempty ι\ninst✝ : IsDirected ι fun x1 x2 => LE.le x1 x2\nz : Module.DirectLimit G f\n⊢ Exists fun i => Exists fun x => Eq ((Module.DirectLimit.of R ι G f i) x) z","decl":"/-- Every element of the direct limit corresponds to some element in\nsome component of the directed system. -/\ntheorem exists_of [Nonempty ι] [IsDirected ι (· ≤ ·)] (z : DirectLimit G f) :\n    ∃ i x, of R ι G f i x = z :=\n  Nonempty.elim (by infer_instance) fun ind : ι ↦\n    Quotient.inductionOn' z fun z ↦\n      DirectSum.induction_on z ⟨ind, 0, LinearMap.map_zero _⟩ (fun i x ↦ ⟨i, x, rfl⟩)\n        fun p q ⟨i, x, ihx⟩ ⟨j, y, ihy⟩ ↦\n        let ⟨k, hik, hjk⟩ := exists_ge_ge i j\n        ⟨k, f i k hik x + f j k hjk y, by\n          rw [LinearMap.map_add, of_f, of_f, ihx, ihy]\n          rfl ⟩\n\n"}
{"name":"Module.DirectLimit.exists_of₂","module":"Mathlib.Algebra.Colimit.Module","initialProofState":"R : Type u_1\ninst✝⁶ : Semiring R\nι : Type u_2\ninst✝⁵ : Preorder ι\nG : ι → Type u_3\ninst✝⁴ : DecidableEq ι\ninst✝³ : (i : ι) → AddCommMonoid (G i)\ninst✝² : (i : ι) → Module R (G i)\nf : (i j : ι) → LE.le i j → LinearMap (RingHom.id R) (G i) (G j)\ninst✝¹ : Nonempty ι\ninst✝ : IsDirected ι fun x1 x2 => LE.le x1 x2\nz w : Module.DirectLimit G f\n⊢ Exists fun i => Exists fun x => Exists fun y => And (Eq ((Module.DirectLimit.of R ι G f i) x) z) (Eq ((Module.DirectLimit.of R ι G f i) y) w)","decl":"theorem exists_of₂ [Nonempty ι] [IsDirected ι (· ≤ ·)] (z w : DirectLimit G f) :\n    ∃ i x y, of R ι G f i x = z ∧ of R ι G f i y = w :=\n  have ⟨i, x, hx⟩ := exists_of z\n  have ⟨j, y, hy⟩ := exists_of w\n  have ⟨k, hik, hjk⟩ := exists_ge_ge i j\n  ⟨k, f i k hik x, f j k hjk y, by rw [of_f, hx], by rw [of_f, hy]⟩\n\n"}
{"name":"Module.DirectLimit.induction_on","module":"Mathlib.Algebra.Colimit.Module","initialProofState":"R : Type u_1\ninst✝⁶ : Semiring R\nι : Type u_2\ninst✝⁵ : Preorder ι\nG : ι → Type u_3\ninst✝⁴ : DecidableEq ι\ninst✝³ : (i : ι) → AddCommMonoid (G i)\ninst✝² : (i : ι) → Module R (G i)\nf : (i j : ι) → LE.le i j → LinearMap (RingHom.id R) (G i) (G j)\ninst✝¹ : Nonempty ι\ninst✝ : IsDirected ι fun x1 x2 => LE.le x1 x2\nC : Module.DirectLimit G f → Prop\nz : Module.DirectLimit G f\nih : ∀ (i : ι) (x : G i), C ((Module.DirectLimit.of R ι G f i) x)\n⊢ C z","decl":"@[elab_as_elim]\nprotected theorem induction_on [Nonempty ι] [IsDirected ι (· ≤ ·)] {C : DirectLimit G f → Prop}\n    (z : DirectLimit G f) (ih : ∀ i x, C (of R ι G f i x)) : C z :=\n  let ⟨i, x, h⟩ := exists_of z\n  h ▸ ih i x\n\n"}
{"name":"Module.DirectLimit.lift_of","module":"Mathlib.Algebra.Colimit.Module","initialProofState":"R : Type u_1\ninst✝⁶ : Semiring R\nι : Type u_2\ninst✝⁵ : Preorder ι\nG : ι → Type u_3\ninst✝⁴ : DecidableEq ι\ninst✝³ : (i : ι) → AddCommMonoid (G i)\ninst✝² : (i : ι) → Module R (G i)\nf : (i j : ι) → LE.le i j → LinearMap (RingHom.id R) (G i) (G j)\nP : Type u_4\ninst✝¹ : AddCommMonoid P\ninst✝ : Module R P\ng : (i : ι) → LinearMap (RingHom.id R) (G i) P\nHg : ∀ (i j : ι) (hij : LE.le i j) (x : G i), Eq ((g j) ((f i j hij) x)) ((g i) x)\ni : ι\nx : G i\n⊢ Eq ((Module.DirectLimit.lift R ι G f g Hg) ((Module.DirectLimit.of R ι G f i) x)) ((g i) x)","decl":"@[simp] theorem lift_of {i} (x) : lift R ι G f g Hg (of R ι G f i x) = g i x :=\n  DirectSum.toModule_lof R _ _\n\n"}
{"name":"Module.DirectLimit.lift_unique","module":"Mathlib.Algebra.Colimit.Module","initialProofState":"R : Type u_1\ninst✝⁶ : Semiring R\nι : Type u_2\ninst✝⁵ : Preorder ι\nG : ι → Type u_3\ninst✝⁴ : DecidableEq ι\ninst✝³ : (i : ι) → AddCommMonoid (G i)\ninst✝² : (i : ι) → Module R (G i)\nf : (i j : ι) → LE.le i j → LinearMap (RingHom.id R) (G i) (G j)\nP : Type u_4\ninst✝¹ : AddCommMonoid P\ninst✝ : Module R P\nF : LinearMap (RingHom.id R) (Module.DirectLimit G f) P\nx : Module.DirectLimit G f\n⊢ Eq (F x) ((Module.DirectLimit.lift R ι G f (fun i => F.comp (Module.DirectLimit.of R ι G f i)) ⋯) x)","decl":"theorem lift_unique (F : DirectLimit G f →ₗ[R] P) (x) :\n    F x = lift R ι G f (fun i ↦ F.comp <| of R ι G f i) (fun i j hij x ↦ by simp) x := by\n  rcases x with ⟨x⟩\n  exact x.induction_on (by simp) (fun _ _ ↦ .symm <| lift_of ..) (by simp +contextual)\n\n"}
{"name":"Module.DirectLimit.lift_injective","module":"Mathlib.Algebra.Colimit.Module","initialProofState":"R : Type u_1\ninst✝⁷ : Semiring R\nι : Type u_2\ninst✝⁶ : Preorder ι\nG : ι → Type u_3\ninst✝⁵ : DecidableEq ι\ninst✝⁴ : (i : ι) → AddCommMonoid (G i)\ninst✝³ : (i : ι) → Module R (G i)\nf : (i j : ι) → LE.le i j → LinearMap (RingHom.id R) (G i) (G j)\nP : Type u_4\ninst✝² : AddCommMonoid P\ninst✝¹ : Module R P\ng : (i : ι) → LinearMap (RingHom.id R) (G i) P\nHg : ∀ (i j : ι) (hij : LE.le i j) (x : G i), Eq ((g j) ((f i j hij) x)) ((g i) x)\ninst✝ : IsDirected ι fun x1 x2 => LE.le x1 x2\ninjective : ∀ (i : ι), Function.Injective ⇑(g i)\n⊢ Function.Injective ⇑(Module.DirectLimit.lift R ι G f g Hg)","decl":"lemma lift_injective [IsDirected ι (· ≤ ·)]\n    (injective : ∀ i, Function.Injective <| g i) :\n    Function.Injective (lift R ι G f g Hg) := by\n  cases isEmpty_or_nonempty ι\n  · apply Function.injective_of_subsingleton\n  intros z w eq\n  obtain ⟨i, x, y, rfl, rfl⟩ := exists_of₂ z w\n  simp_rw [lift_of] at eq\n  rw [injective _ eq]\n\n"}
{"name":"Module.DirectLimit.map_apply_of","module":"Mathlib.Algebra.Colimit.Module","initialProofState":"R : Type u_1\ninst✝⁶ : Semiring R\nι : Type u_2\ninst✝⁵ : Preorder ι\nG : ι → Type u_3\ninst✝⁴ : DecidableEq ι\ninst✝³ : (i : ι) → AddCommMonoid (G i)\ninst✝² : (i : ι) → Module R (G i)\nf : (i j : ι) → LE.le i j → LinearMap (RingHom.id R) (G i) (G j)\nG' : ι → Type u_5\ninst✝¹ : (i : ι) → AddCommMonoid (G' i)\ninst✝ : (i : ι) → Module R (G' i)\nf' : (i j : ι) → LE.le i j → LinearMap (RingHom.id R) (G' i) (G' j)\ng : (i : ι) → LinearMap (RingHom.id R) (G i) (G' i)\nhg : ∀ (i j : ι) (h : LE.le i j), Eq ((g j).comp (f i j h)) ((f' i j h).comp (g i))\ni : ι\nx : G i\n⊢ Eq ((Module.DirectLimit.map g hg) ((Module.DirectLimit.of R ι G f i) x)) ((Module.DirectLimit.of R ι G' f' i) ((g i) x))","decl":"@[simp] lemma map_apply_of (g : (i : ι) → G i →ₗ[R] G' i)\n    (hg : ∀ i j h, g j ∘ₗ f i j h = f' i j h ∘ₗ g i)\n    {i : ι} (x : G i) :\n    map g hg (of _ _ G f _ x) = of R ι G' f' i (g i x) :=\n  lift_of _ _ _\n\n"}
{"name":"Module.DirectLimit.map_id","module":"Mathlib.Algebra.Colimit.Module","initialProofState":"R : Type u_1\ninst✝⁴ : Semiring R\nι : Type u_2\ninst✝³ : Preorder ι\nG : ι → Type u_3\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → AddCommMonoid (G i)\ninst✝ : (i : ι) → Module R (G i)\nf : (i j : ι) → LE.le i j → LinearMap (RingHom.id R) (G i) (G j)\n⊢ Eq (Module.DirectLimit.map (fun x => LinearMap.id) ⋯) LinearMap.id","decl":"@[simp] lemma map_id :\n    map (fun _ ↦ LinearMap.id) (fun _ _ _ ↦ rfl) = LinearMap.id (R := R) (M := DirectLimit G f) :=\n  DFunLike.ext _ _ <| by\n    rintro ⟨x⟩; refine x.induction_on (by simp) (fun _ ↦ map_apply_of _ _) (by simp +contextual)\n\n"}
{"name":"Module.DirectLimit.map_comp","module":"Mathlib.Algebra.Colimit.Module","initialProofState":"R : Type u_1\ninst✝⁸ : Semiring R\nι : Type u_2\ninst✝⁷ : Preorder ι\nG : ι → Type u_3\ninst✝⁶ : DecidableEq ι\ninst✝⁵ : (i : ι) → AddCommMonoid (G i)\ninst✝⁴ : (i : ι) → Module R (G i)\nf : (i j : ι) → LE.le i j → LinearMap (RingHom.id R) (G i) (G j)\nG' : ι → Type u_5\ninst✝³ : (i : ι) → AddCommMonoid (G' i)\ninst✝² : (i : ι) → Module R (G' i)\nf' : (i j : ι) → LE.le i j → LinearMap (RingHom.id R) (G' i) (G' j)\nG'' : ι → Type u_6\ninst✝¹ : (i : ι) → AddCommMonoid (G'' i)\ninst✝ : (i : ι) → Module R (G'' i)\nf'' : (i j : ι) → LE.le i j → LinearMap (RingHom.id R) (G'' i) (G'' j)\ng₁ : (i : ι) → LinearMap (RingHom.id R) (G i) (G' i)\ng₂ : (i : ι) → LinearMap (RingHom.id R) (G' i) (G'' i)\nhg₁ : ∀ (i j : ι) (h : LE.le i j), Eq ((g₁ j).comp (f i j h)) ((f' i j h).comp (g₁ i))\nhg₂ : ∀ (i j : ι) (h : LE.le i j), Eq ((g₂ j).comp (f' i j h)) ((f'' i j h).comp (g₂ i))\n⊢ Eq ((Module.DirectLimit.map g₂ hg₂).comp (Module.DirectLimit.map g₁ hg₁)) (Module.DirectLimit.map (fun i => (g₂ i).comp (g₁ i)) ⋯)","decl":"lemma map_comp (g₁ : (i : ι) → G i →ₗ[R] G' i) (g₂ : (i : ι) → G' i →ₗ[R] G'' i)\n    (hg₁ : ∀ i j h, g₁ j ∘ₗ f i j h = f' i j h ∘ₗ g₁ i)\n    (hg₂ : ∀ i j h, g₂ j ∘ₗ f' i j h = f'' i j h ∘ₗ g₂ i) :\n    (map g₂ hg₂ ∘ₗ map g₁ hg₁ :\n      DirectLimit G f →ₗ[R] DirectLimit G'' f'') =\n    (map (fun i ↦ g₂ i ∘ₗ g₁ i) fun i j h ↦ by\n        rw [LinearMap.comp_assoc, hg₁ i, ← LinearMap.comp_assoc, hg₂ i, LinearMap.comp_assoc] :\n      DirectLimit G f →ₗ[R] DirectLimit G'' f'') :=\n  DFunLike.ext _ _ <| by\n    rintro ⟨x⟩; refine x.induction_on (by simp) (fun _ _ ↦ ?_) (by simp +contextual)\n    show map g₂ hg₂ (map g₁ hg₁ <| of _ _ _ _ _ _) = map _ _ (of _ _ _ _ _ _)\n    simp_rw [map_apply_of]; rfl\n\n"}
{"name":"Module.DirectLimit.congr_apply_of","module":"Mathlib.Algebra.Colimit.Module","initialProofState":"R : Type u_1\ninst✝⁶ : Semiring R\nι : Type u_2\ninst✝⁵ : Preorder ι\nG : ι → Type u_3\ninst✝⁴ : DecidableEq ι\ninst✝³ : (i : ι) → AddCommMonoid (G i)\ninst✝² : (i : ι) → Module R (G i)\nf : (i j : ι) → LE.le i j → LinearMap (RingHom.id R) (G i) (G j)\nG' : ι → Type u_5\ninst✝¹ : (i : ι) → AddCommMonoid (G' i)\ninst✝ : (i : ι) → Module R (G' i)\nf' : (i j : ι) → LE.le i j → LinearMap (RingHom.id R) (G' i) (G' j)\ne : (i : ι) → LinearEquiv (RingHom.id R) (G i) (G' i)\nhe : ∀ (i j : ι) (h : LE.le i j), Eq ((↑(e j)).comp (f i j h)) ((f' i j h).comp ↑(e i))\ni : ι\ng : G i\n⊢ Eq ((Module.DirectLimit.congr e he) ((Module.DirectLimit.of R ι G f i) g)) ((Module.DirectLimit.of R ι G' f' i) ((e i) g))","decl":"lemma congr_apply_of (e : (i : ι) → G i ≃ₗ[R] G' i) (he : ∀ i j h, e j ∘ₗ f i j h = f' i j h ∘ₗ e i)\n    {i : ι} (g : G i) :\n    congr e he (of _ _ G f i g) = of _ _ G' f' i (e i g) :=\n  map_apply_of _ he _\n\n"}
{"name":"Module.DirectLimit.congr_symm_apply_of","module":"Mathlib.Algebra.Colimit.Module","initialProofState":"R : Type u_1\ninst✝⁶ : Semiring R\nι : Type u_2\ninst✝⁵ : Preorder ι\nG : ι → Type u_3\ninst✝⁴ : DecidableEq ι\ninst✝³ : (i : ι) → AddCommMonoid (G i)\ninst✝² : (i : ι) → Module R (G i)\nf : (i j : ι) → LE.le i j → LinearMap (RingHom.id R) (G i) (G j)\nG' : ι → Type u_5\ninst✝¹ : (i : ι) → AddCommMonoid (G' i)\ninst✝ : (i : ι) → Module R (G' i)\nf' : (i j : ι) → LE.le i j → LinearMap (RingHom.id R) (G' i) (G' j)\ne : (i : ι) → LinearEquiv (RingHom.id R) (G i) (G' i)\nhe : ∀ (i j : ι) (h : LE.le i j), Eq ((↑(e j)).comp (f i j h)) ((f' i j h).comp ↑(e i))\ni : ι\ng : G' i\n⊢ Eq ((Module.DirectLimit.congr e he).symm ((Module.DirectLimit.of R ι G' f' i) g)) ((Module.DirectLimit.of R ι G f i) ((e i).symm g))","decl":"open LinearEquiv LinearMap in\nlemma congr_symm_apply_of (e : (i : ι) → G i ≃ₗ[R] G' i)\n    (he : ∀ i j h, e j ∘ₗ f i j h = f' i j h ∘ₗ e i) {i : ι} (g : G' i) :\n    (congr e he).symm (of _ _ G' f' i g) = of _ _ G f i ((e i).symm g) :=\n  map_apply_of _ (fun i j h ↦ by\n    rw [toLinearMap_symm_comp_eq, ← comp_assoc, he i, comp_assoc, comp_coe, symm_trans_self,\n      refl_toLinearMap, comp_id]) _\n\n"}
{"name":"Module.DirectLimit.linearEquiv_of","module":"Mathlib.Algebra.Colimit.Module","initialProofState":"R : Type u_1\ninst✝⁷ : Semiring R\nι : Type u_2\ninst✝⁶ : Preorder ι\nG : ι → Type u_3\ninst✝⁵ : DecidableEq ι\ninst✝⁴ : (i : ι) → AddCommMonoid (G i)\ninst✝³ : (i : ι) → Module R (G i)\nf : (i j : ι) → LE.le i j → LinearMap (RingHom.id R) (G i) (G j)\ninst✝² : Nonempty ι\ninst✝¹ : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝ : DirectedSystem G fun x1 x2 x3 => ⇑(f x1 x2 x3)\ni : ι\ng : G i\n⊢ Eq ((Module.DirectLimit.linearEquiv G f) ((Module.DirectLimit.of R ι G f i) g)) (Quotient.mk (DirectLimit.setoid f) ⟨i, g⟩)","decl":"theorem linearEquiv_of {i g} : linearEquiv _ _ (of _ _ G f i g) = ⟦⟨i, g⟩⟧ := by\n  simp [linearEquiv]; rfl\n\n"}
{"name":"Module.DirectLimit.linearEquiv_symm_mk","module":"Mathlib.Algebra.Colimit.Module","initialProofState":"R : Type u_1\ninst✝⁷ : Semiring R\nι : Type u_2\ninst✝⁶ : Preorder ι\nG : ι → Type u_3\ninst✝⁵ : DecidableEq ι\ninst✝⁴ : (i : ι) → AddCommMonoid (G i)\ninst✝³ : (i : ι) → Module R (G i)\nf : (i j : ι) → LE.le i j → LinearMap (RingHom.id R) (G i) (G j)\ninst✝² : Nonempty ι\ninst✝¹ : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝ : DirectedSystem G fun x1 x2 x3 => ⇑(f x1 x2 x3)\ng : Sigma fun i => G i\n⊢ Eq ((Module.DirectLimit.linearEquiv G f).symm (Quotient.mk (DirectLimit.setoid f) g)) ((Module.DirectLimit.of R ι G f g.fst) g.snd)","decl":"theorem linearEquiv_symm_mk {g} : (linearEquiv _ _).symm ⟦g⟧ = of _ _ G f g.1 g.2 := rfl\n\n"}
{"name":"Module.DirectLimit.exists_eq_of_of_eq","module":"Mathlib.Algebra.Colimit.Module","initialProofState":"R : Type u_1\ninst✝⁶ : Semiring R\nι : Type u_2\ninst✝⁵ : Preorder ι\nG : ι → Type u_3\ninst✝⁴ : DecidableEq ι\ninst✝³ : (i : ι) → AddCommMonoid (G i)\ninst✝² : (i : ι) → Module R (G i)\nf : (i j : ι) → LE.le i j → LinearMap (RingHom.id R) (G i) (G j)\ninst✝¹ : DirectedSystem G fun x1 x2 x3 => ⇑(f x1 x2 x3)\ninst✝ : IsDirected ι fun x1 x2 => LE.le x1 x2\ni : ι\nx y : G i\nh : Eq ((Module.DirectLimit.of R ι G f i) x) ((Module.DirectLimit.of R ι G f i) y)\n⊢ Exists fun j => Exists fun hij => Eq ((f i j hij) x) ((f i j hij) y)","decl":"theorem exists_eq_of_of_eq {i x y} (h : of R ι G f i x = of R ι G f i y) :\n    ∃ j hij, f i j hij x = f i j hij y := by\n  have := Nonempty.intro i\n  apply_fun linearEquiv _ _ at h\n  simp_rw [linearEquiv_of] at h\n  have ⟨j, h⟩ := Quotient.exact h\n  exact ⟨j, h.1, h.2.2⟩\n\n"}
{"name":"Module.DirectLimit.of.zero_exact","module":"Mathlib.Algebra.Colimit.Module","initialProofState":"R : Type u_1\ninst✝⁶ : Semiring R\nι : Type u_2\ninst✝⁵ : Preorder ι\nG : ι → Type u_3\ninst✝⁴ : DecidableEq ι\ninst✝³ : (i : ι) → AddCommMonoid (G i)\ninst✝² : (i : ι) → Module R (G i)\nf : (i j : ι) → LE.le i j → LinearMap (RingHom.id R) (G i) (G j)\ninst✝¹ : DirectedSystem G fun x1 x2 x3 => ⇑(f x1 x2 x3)\ninst✝ : IsDirected ι fun x1 x2 => LE.le x1 x2\ni : ι\nx : G i\nH : Eq ((Module.DirectLimit.of R ι G f i) x) 0\n⊢ Exists fun j => Exists fun hij => Eq ((f i j hij) x) 0","decl":"/-- A component that corresponds to zero in the direct limit is already zero in some\nbigger module in the directed system. -/\ntheorem of.zero_exact {i x} (H : of R ι G f i x = 0) :\n    ∃ j hij, f i j hij x = (0 : G j) := by\n  convert exists_eq_of_of_eq (H.trans (map_zero <| _).symm)\n  rw [map_zero]\n\n"}
{"name":"AddCommGroup.DirectLimit.directedSystem","module":"Mathlib.Algebra.Colimit.Module","initialProofState":"ι : Type u_2\ninst✝¹ : Preorder ι\nG : ι → Type u_3\ninst✝ : (i : ι) → AddCommMonoid (G i)\nf : (i j : ι) → LE.le i j → AddMonoidHom (G i) (G j)\nh : DirectedSystem G fun i j h => ⇑(f i j h)\n⊢ DirectedSystem G fun i j hij => ⇑(f i j hij).toNatLinearMap","decl":"local instance directedSystem [h : DirectedSystem G fun i j h ↦ f i j h] :\n    DirectedSystem G fun i j hij ↦ (f i j hij).toNatLinearMap :=\n  h\n\n"}
{"name":"AddCommGroup.DirectLimit.of_f","module":"Mathlib.Algebra.Colimit.Module","initialProofState":"ι : Type u_2\ninst✝² : Preorder ι\nG : ι → Type u_3\ninst✝¹ : (i : ι) → AddCommMonoid (G i)\nf : (i j : ι) → LE.le i j → AddMonoidHom (G i) (G j)\ninst✝ : DecidableEq ι\ni j : ι\nhij : LE.le i j\nx : G i\n⊢ Eq ((AddCommGroup.DirectLimit.of G f j) ((f i j hij) x)) ((AddCommGroup.DirectLimit.of G f i) x)","decl":"@[simp]\ntheorem of_f {i j} (hij) (x) : of G f j (f i j hij x) = of G f i x :=\n  Module.DirectLimit.of_f\n\n"}
{"name":"AddCommGroup.DirectLimit.induction_on","module":"Mathlib.Algebra.Colimit.Module","initialProofState":"ι : Type u_2\ninst✝⁴ : Preorder ι\nG : ι → Type u_3\ninst✝³ : (i : ι) → AddCommMonoid (G i)\nf : (i j : ι) → LE.le i j → AddMonoidHom (G i) (G j)\ninst✝² : DecidableEq ι\ninst✝¹ : Nonempty ι\ninst✝ : IsDirected ι fun x1 x2 => LE.le x1 x2\nC : AddCommGroup.DirectLimit G f → Prop\nz : AddCommGroup.DirectLimit G f\nih : ∀ (i : ι) (x : G i), C ((AddCommGroup.DirectLimit.of G f i) x)\n⊢ C z","decl":"@[elab_as_elim]\nprotected theorem induction_on [Nonempty ι] [IsDirected ι (· ≤ ·)] {C : DirectLimit G f → Prop}\n    (z : DirectLimit G f) (ih : ∀ i x, C (of G f i x)) : C z :=\n  Module.DirectLimit.induction_on z ih\n\n"}
{"name":"AddCommGroup.DirectLimit.of.zero_exact","module":"Mathlib.Algebra.Colimit.Module","initialProofState":"ι : Type u_2\ninst✝⁴ : Preorder ι\nG : ι → Type u_3\ninst✝³ : (i : ι) → AddCommMonoid (G i)\nf : (i j : ι) → LE.le i j → AddMonoidHom (G i) (G j)\ninst✝² : DecidableEq ι\ninst✝¹ : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝ : DirectedSystem G fun i j h => ⇑(f i j h)\ni : ι\nx : G i\nh : Eq ((AddCommGroup.DirectLimit.of G f i) x) 0\n⊢ Exists fun j => Exists fun hij => Eq ((f i j hij) x) 0","decl":"/-- A component that corresponds to zero in the direct limit is already zero in some\nbigger module in the directed system. -/\ntheorem of.zero_exact [IsDirected ι (· ≤ ·)] [DirectedSystem G fun i j h ↦ f i j h] (i x)\n    (h : of G f i x = 0) : ∃ j hij, f i j hij x = 0 :=\n  Module.DirectLimit.of.zero_exact h\n\n"}
{"name":"AddCommGroup.DirectLimit.lift_of","module":"Mathlib.Algebra.Colimit.Module","initialProofState":"ι : Type u_2\ninst✝³ : Preorder ι\nG : ι → Type u_3\ninst✝² : (i : ι) → AddCommMonoid (G i)\nf : (i j : ι) → LE.le i j → AddMonoidHom (G i) (G j)\ninst✝¹ : DecidableEq ι\nP : Type u_4\ninst✝ : AddCommMonoid P\ng : (i : ι) → AddMonoidHom (G i) P\nHg : ∀ (i j : ι) (hij : LE.le i j) (x : G i), Eq ((g j) ((f i j hij) x)) ((g i) x)\ni : ι\nx : G i\n⊢ Eq ((AddCommGroup.DirectLimit.lift G f P g Hg) ((AddCommGroup.DirectLimit.of G f i) x)) ((g i) x)","decl":"@[simp]\ntheorem lift_of (i x) : lift G f P g Hg (of G f i x) = g i x :=\n  Module.DirectLimit.lift_of\n    -- Note: had to make these arguments explicit https://github.com/leanprover-community/mathlib4/pull/8386\n    (f := fun i j hij ↦ (f i j hij).toNatLinearMap)\n    (fun i ↦ (g i).toNatLinearMap)\n    Hg\n    x\n\n"}
{"name":"AddCommGroup.DirectLimit.lift_unique","module":"Mathlib.Algebra.Colimit.Module","initialProofState":"ι : Type u_2\ninst✝³ : Preorder ι\nG : ι → Type u_3\ninst✝² : (i : ι) → AddCommMonoid (G i)\nf : (i j : ι) → LE.le i j → AddMonoidHom (G i) (G j)\ninst✝¹ : DecidableEq ι\nP : Type u_4\ninst✝ : AddCommMonoid P\nF : AddMonoidHom (AddCommGroup.DirectLimit G f) P\nx : AddCommGroup.DirectLimit G f\n⊢ Eq (F x) ((AddCommGroup.DirectLimit.lift G f P (fun i => F.comp (AddCommGroup.DirectLimit.of G f i)) ⋯) x)","decl":"theorem lift_unique (F : DirectLimit G f →+ P) (x) :\n    F x = lift G f P (fun i ↦ F.comp (of G f i)) (fun i j hij x ↦ by simp) x := by\n  rcases x with ⟨x⟩\n  exact x.induction_on (by simp) (fun _ _ ↦ .symm <| lift_of ..) (by simp +contextual)\n\n"}
{"name":"AddCommGroup.DirectLimit.lift_injective","module":"Mathlib.Algebra.Colimit.Module","initialProofState":"ι : Type u_2\ninst✝⁴ : Preorder ι\nG : ι → Type u_3\ninst✝³ : (i : ι) → AddCommMonoid (G i)\nf : (i j : ι) → LE.le i j → AddMonoidHom (G i) (G j)\ninst✝² : DecidableEq ι\nP : Type u_4\ninst✝¹ : AddCommMonoid P\ng : (i : ι) → AddMonoidHom (G i) P\nHg : ∀ (i j : ι) (hij : LE.le i j) (x : G i), Eq ((g j) ((f i j hij) x)) ((g i) x)\ninst✝ : IsDirected ι fun x1 x2 => LE.le x1 x2\ninjective : ∀ (i : ι), Function.Injective ⇑(g i)\n⊢ Function.Injective ⇑(AddCommGroup.DirectLimit.lift G f P g Hg)","decl":"lemma lift_injective [IsDirected ι (· ≤ ·)]\n    (injective : ∀ i, Function.Injective <| g i) :\n    Function.Injective (lift G f P g Hg) :=\n  Module.DirectLimit.lift_injective (f := fun i j hij ↦ (f i j hij).toNatLinearMap) _ Hg injective\n\n"}
{"name":"AddCommGroup.DirectLimit.map_apply_of","module":"Mathlib.Algebra.Colimit.Module","initialProofState":"ι : Type u_2\ninst✝³ : Preorder ι\nG : ι → Type u_3\ninst✝² : (i : ι) → AddCommMonoid (G i)\nf : (i j : ι) → LE.le i j → AddMonoidHom (G i) (G j)\ninst✝¹ : DecidableEq ι\nG' : ι → Type u_5\ninst✝ : (i : ι) → AddCommMonoid (G' i)\nf' : (i j : ι) → LE.le i j → AddMonoidHom (G' i) (G' j)\ng : (i : ι) → AddMonoidHom (G i) (G' i)\nhg : ∀ (i j : ι) (h : LE.le i j), Eq ((g j).comp (f i j h)) ((f' i j h).comp (g i))\ni : ι\nx : G i\n⊢ Eq ((AddCommGroup.DirectLimit.map g hg) ((AddCommGroup.DirectLimit.of G f i) x)) ((AddCommGroup.DirectLimit.of G' f' i) ((g i) x))","decl":"@[simp] lemma map_apply_of (g : (i : ι) → G i →+ G' i)\n    (hg : ∀ i j h, (g j).comp (f i j h) = (f' i j h).comp (g i))\n    {i : ι} (x : G i) :\n    map g hg (of G f _ x) = of G' f' i (g i x) :=\n  lift_of _ _ _ _ _\n\n"}
{"name":"AddCommGroup.DirectLimit.map_id","module":"Mathlib.Algebra.Colimit.Module","initialProofState":"ι : Type u_2\ninst✝² : Preorder ι\nG : ι → Type u_3\ninst✝¹ : (i : ι) → AddCommMonoid (G i)\nf : (i j : ι) → LE.le i j → AddMonoidHom (G i) (G j)\ninst✝ : DecidableEq ι\n⊢ Eq (AddCommGroup.DirectLimit.map (fun x => AddMonoidHom.id (G x)) ⋯) (AddMonoidHom.id (AddCommGroup.DirectLimit G f))","decl":"@[simp] lemma map_id :\n    map (fun _ ↦ AddMonoidHom.id _) (fun _ _ _ ↦ rfl) = AddMonoidHom.id (DirectLimit G f) :=\n  DFunLike.ext _ _ <| by\n    rintro ⟨x⟩; refine x.induction_on (by simp) (fun _ ↦ map_apply_of _ _) (by simp +contextual)\n\n"}
{"name":"AddCommGroup.DirectLimit.map_comp","module":"Mathlib.Algebra.Colimit.Module","initialProofState":"ι : Type u_2\ninst✝⁴ : Preorder ι\nG : ι → Type u_3\ninst✝³ : (i : ι) → AddCommMonoid (G i)\nf : (i j : ι) → LE.le i j → AddMonoidHom (G i) (G j)\ninst✝² : DecidableEq ι\nG' : ι → Type u_5\ninst✝¹ : (i : ι) → AddCommMonoid (G' i)\nf' : (i j : ι) → LE.le i j → AddMonoidHom (G' i) (G' j)\nG'' : ι → Type u_6\ninst✝ : (i : ι) → AddCommMonoid (G'' i)\nf'' : (i j : ι) → LE.le i j → AddMonoidHom (G'' i) (G'' j)\ng₁ : (i : ι) → AddMonoidHom (G i) (G' i)\ng₂ : (i : ι) → AddMonoidHom (G' i) (G'' i)\nhg₁ : ∀ (i j : ι) (h : LE.le i j), Eq ((g₁ j).comp (f i j h)) ((f' i j h).comp (g₁ i))\nhg₂ : ∀ (i j : ι) (h : LE.le i j), Eq ((g₂ j).comp (f' i j h)) ((f'' i j h).comp (g₂ i))\n⊢ Eq ((AddCommGroup.DirectLimit.map g₂ hg₂).comp (AddCommGroup.DirectLimit.map g₁ hg₁)) (AddCommGroup.DirectLimit.map (fun i => (g₂ i).comp (g₁ i)) ⋯)","decl":"lemma map_comp (g₁ : (i : ι) → G i →+ G' i) (g₂ : (i : ι) → G' i →+ G'' i)\n    (hg₁ : ∀ i j h, (g₁ j).comp (f i j h) = (f' i j h).comp (g₁ i))\n    (hg₂ : ∀ i j h, (g₂ j).comp (f' i j h) = (f'' i j h).comp (g₂ i)) :\n    ((map g₂ hg₂).comp (map g₁ hg₁) :\n      DirectLimit G f →+ DirectLimit G'' f'') =\n    (map (fun i ↦ (g₂ i).comp (g₁ i)) fun i j h ↦ by\n      rw [AddMonoidHom.comp_assoc, hg₁ i, ← AddMonoidHom.comp_assoc, hg₂ i,\n        AddMonoidHom.comp_assoc] :\n      DirectLimit G f →+ DirectLimit G'' f'') :=\n  DFunLike.ext _ _ <| by\n    rintro ⟨x⟩; refine x.induction_on (by simp) (fun _ _ ↦ ?_) (by simp +contextual)\n    show map g₂ hg₂ (map g₁ hg₁ <| of _ _ _ _) = map _ _ (of _ _ _ _)\n    simp_rw [map_apply_of]; rfl\n\n"}
{"name":"AddCommGroup.DirectLimit.congr_apply_of","module":"Mathlib.Algebra.Colimit.Module","initialProofState":"ι : Type u_2\ninst✝³ : Preorder ι\nG : ι → Type u_3\ninst✝² : (i : ι) → AddCommMonoid (G i)\nf : (i j : ι) → LE.le i j → AddMonoidHom (G i) (G j)\ninst✝¹ : DecidableEq ι\nG' : ι → Type u_5\ninst✝ : (i : ι) → AddCommMonoid (G' i)\nf' : (i j : ι) → LE.le i j → AddMonoidHom (G' i) (G' j)\ne : (i : ι) → AddEquiv (G i) (G' i)\nhe : ∀ (i j : ι) (h : LE.le i j), Eq ((e j).toAddMonoidHom.comp (f i j h)) ((f' i j h).comp ↑(e i))\ni : ι\ng : G i\n⊢ Eq ((AddCommGroup.DirectLimit.congr e he) ((AddCommGroup.DirectLimit.of G f i) g)) ((AddCommGroup.DirectLimit.of G' f' i) ((e i) g))","decl":"lemma congr_apply_of (e : (i : ι) → G i ≃+ G' i)\n    (he : ∀ i j h, (e j).toAddMonoidHom.comp (f i j h) = (f' i j h).comp (e i))\n    {i : ι} (g : G i) :\n    congr e he (of G f i g) = of G' f' i (e i g) :=\n  map_apply_of _ he _\n\n"}
{"name":"AddCommGroup.DirectLimit.congr_symm_apply_of","module":"Mathlib.Algebra.Colimit.Module","initialProofState":"ι : Type u_2\ninst✝³ : Preorder ι\nG : ι → Type u_3\ninst✝² : (i : ι) → AddCommMonoid (G i)\nf : (i j : ι) → LE.le i j → AddMonoidHom (G i) (G j)\ninst✝¹ : DecidableEq ι\nG' : ι → Type u_5\ninst✝ : (i : ι) → AddCommMonoid (G' i)\nf' : (i j : ι) → LE.le i j → AddMonoidHom (G' i) (G' j)\ne : (i : ι) → AddEquiv (G i) (G' i)\nhe : ∀ (i j : ι) (h : LE.le i j), Eq ((e j).toAddMonoidHom.comp (f i j h)) ((f' i j h).comp ↑(e i))\ni : ι\ng : G' i\n⊢ Eq ((AddCommGroup.DirectLimit.congr e he).symm ((AddCommGroup.DirectLimit.of G' f' i) g)) ((AddCommGroup.DirectLimit.of G f i) ((e i).symm g))","decl":"lemma congr_symm_apply_of (e : (i : ι) → G i ≃+ G' i)\n    (he : ∀ i j h, (e j).toAddMonoidHom.comp (f i j h) = (f' i j h).comp (e i))\n    {i : ι} (g : G' i) :\n    (congr e he).symm (of G' f' i g) = of G f i ((e i).symm g) := by\n  simp only [congr, AddMonoidHom.toAddEquiv_symm_apply, map_apply_of, AddMonoidHom.coe_coe]\n\n"}
