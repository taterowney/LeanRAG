{"name":"CircleDeg1Lift.mk.injEq","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"toOrderHom‚úù : OrderHom Real Real\nmap_add_one'‚úù : ‚àÄ (x : Real), Eq (toOrderHom‚úù.toFun (HAdd.hAdd x 1)) (HAdd.hAdd (toOrderHom‚úù.toFun x) 1)\ntoOrderHom : OrderHom Real Real\nmap_add_one' : ‚àÄ (x : Real), Eq (toOrderHom.toFun (HAdd.hAdd x 1)) (HAdd.hAdd (toOrderHom.toFun x) 1)\n‚ä¢ Eq (Eq { toOrderHom := toOrderHom‚úù, map_add_one' := map_add_one'‚úù } { toOrderHom := toOrderHom, map_add_one' := map_add_one' }) (Eq toOrderHom‚úù toOrderHom)","decl":"/-- A lift of a monotone degree one map `S¬π ‚Üí S¬π`. -/\nstructure CircleDeg1Lift extends ‚Ñù ‚Üío ‚Ñù : Type where\n  map_add_one' : ‚àÄ x, toFun (x + 1) = toFun x + 1\n\n"}
{"name":"CircleDeg1Lift.mk.inj","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"toOrderHom‚úù : OrderHom Real Real\nmap_add_one'‚úù : ‚àÄ (x : Real), Eq (toOrderHom‚úù.toFun (HAdd.hAdd x 1)) (HAdd.hAdd (toOrderHom‚úù.toFun x) 1)\ntoOrderHom : OrderHom Real Real\nmap_add_one' : ‚àÄ (x : Real), Eq (toOrderHom.toFun (HAdd.hAdd x 1)) (HAdd.hAdd (toOrderHom.toFun x) 1)\nx‚úù : Eq { toOrderHom := toOrderHom‚úù, map_add_one' := map_add_one'‚úù } { toOrderHom := toOrderHom, map_add_one' := map_add_one' }\n‚ä¢ Eq toOrderHom‚úù toOrderHom","decl":"/-- A lift of a monotone degree one map `S¬π ‚Üí S¬π`. -/\nstructure CircleDeg1Lift extends ‚Ñù ‚Üío ‚Ñù : Type where\n  map_add_one' : ‚àÄ x, toFun (x + 1) = toFun x + 1\n\n"}
{"name":"CircleDeg1Lift.map_add_one'","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"self : CircleDeg1Lift\nx : Real\n‚ä¢ Eq (self.toFun (HAdd.hAdd x 1)) (HAdd.hAdd (self.toFun x) 1)","decl":"/-- A lift of a monotone degree one map `S¬π ‚Üí S¬π`. -/\nstructure CircleDeg1Lift extends ‚Ñù ‚Üío ‚Ñù : Type where\n  map_add_one' : ‚àÄ x, toFun (x + 1) = toFun x + 1\n\n"}
{"name":"CircleDeg1Lift.mk.sizeOf_spec","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"toOrderHom : OrderHom Real Real\nmap_add_one' : ‚àÄ (x : Real), Eq (toOrderHom.toFun (HAdd.hAdd x 1)) (HAdd.hAdd (toOrderHom.toFun x) 1)\n‚ä¢ Eq (SizeOf.sizeOf { toOrderHom := toOrderHom, map_add_one' := map_add_one' }) (HAdd.hAdd 1 (SizeOf.sizeOf toOrderHom))","decl":"/-- A lift of a monotone degree one map `S¬π ‚Üí S¬π`. -/\nstructure CircleDeg1Lift extends ‚Ñù ‚Üío ‚Ñù : Type where\n  map_add_one' : ‚àÄ x, toFun (x + 1) = toFun x + 1\n\n"}
{"name":"CircleDeg1Lift.instOrderHomClassReal","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"‚ä¢ OrderHomClass CircleDeg1Lift Real Real","decl":"instance : OrderHomClass CircleDeg1Lift ‚Ñù ‚Ñù where\n  map_rel f _ _ h := f.monotone' h\n\n"}
{"name":"CircleDeg1Lift.coe_mk","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : OrderHom Real Real\nh : ‚àÄ (x : Real), Eq (f.toFun (HAdd.hAdd x 1)) (HAdd.hAdd (f.toFun x) 1)\n‚ä¢ Eq ‚áë{ toOrderHom := f, map_add_one' := h } ‚áëf","decl":"@[simp] theorem coe_mk (f h) : ‚áë(mk f h) = f := rfl\n\n"}
{"name":"CircleDeg1Lift.coe_toOrderHom","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\n‚ä¢ Eq ‚áëf.toOrderHom ‚áëf","decl":"@[simp] theorem coe_toOrderHom : ‚áëf.toOrderHom = f := rfl\n\n"}
{"name":"CircleDeg1Lift.monotone","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\n‚ä¢ Monotone ‚áëf","decl":"protected theorem monotone : Monotone f := f.monotone'\n\n"}
{"name":"CircleDeg1Lift.mono","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\nx y : Real\nh : LE.le x y\n‚ä¢ LE.le (f x) (f y)","decl":"@[mono] theorem mono {x y} (h : x ‚â§ y) : f x ‚â§ f y := f.monotone h\n\n"}
{"name":"CircleDeg1Lift.strictMono_iff_injective","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\n‚ä¢ Iff (StrictMono ‚áëf) (Function.Injective ‚áëf)","decl":"theorem strictMono_iff_injective : StrictMono f ‚Üî Injective f :=\n  f.monotone.strictMono_iff_injective\n\n"}
{"name":"CircleDeg1Lift.map_add_one","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\nx : Real\n‚ä¢ Eq (f (HAdd.hAdd x 1)) (HAdd.hAdd (f x) 1)","decl":"@[simp]\ntheorem map_add_one : ‚àÄ x, f (x + 1) = f x + 1 :=\n  f.map_add_one'\n\n"}
{"name":"CircleDeg1Lift.map_one_add","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\nx : Real\n‚ä¢ Eq (f (HAdd.hAdd 1 x)) (HAdd.hAdd 1 (f x))","decl":"@[simp]\ntheorem map_one_add (x : ‚Ñù) : f (1 + x) = 1 + f x := by rw [add_comm, map_add_one, add_comm 1]\n\n"}
{"name":"CircleDeg1Lift.ext_iff","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f g : CircleDeg1Lift\n‚ä¢ Iff (Eq f g) (‚àÄ (x : Real), Eq (f x) (g x))","decl":"@[ext]\ntheorem ext ‚¶Éf g : CircleDeg1Lift‚¶Ñ (h : ‚àÄ x, f x = g x) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"CircleDeg1Lift.ext","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f g : CircleDeg1Lift\nh : ‚àÄ (x : Real), Eq (f x) (g x)\n‚ä¢ Eq f g","decl":"@[ext]\ntheorem ext ‚¶Éf g : CircleDeg1Lift‚¶Ñ (h : ‚àÄ x, f x = g x) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"CircleDeg1Lift.coe_mul","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f g : CircleDeg1Lift\n‚ä¢ Eq (‚áë(HMul.hMul f g)) (Function.comp ‚áëf ‚áëg)","decl":"@[simp]\ntheorem coe_mul : ‚áë(f * g) = f ‚àò g :=\n  rfl\n\n"}
{"name":"CircleDeg1Lift.mul_apply","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f g : CircleDeg1Lift\nx : Real\n‚ä¢ Eq ((HMul.hMul f g) x) (f (g x))","decl":"theorem mul_apply (x) : (f * g) x = f (g x) :=\n  rfl\n\n"}
{"name":"CircleDeg1Lift.coe_one","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"‚ä¢ Eq (‚áë1) id","decl":"@[simp]\ntheorem coe_one : ‚áë(1 : CircleDeg1Lift) = id :=\n  rfl\n\n"}
{"name":"CircleDeg1Lift.units_inv_apply_apply","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : Units CircleDeg1Lift\nx : Real\n‚ä¢ Eq (‚Üë(Inv.inv f) (‚Üëf x)) x","decl":"@[simp]\ntheorem units_inv_apply_apply (f : CircleDeg1LiftÀ£) (x : ‚Ñù) :\n    (f‚Åª¬π : CircleDeg1LiftÀ£) (f x) = x := by simp only [‚Üê mul_apply, f.inv_mul, coe_one, id]\n\n"}
{"name":"CircleDeg1Lift.units_apply_inv_apply","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : Units CircleDeg1Lift\nx : Real\n‚ä¢ Eq (‚Üëf (‚Üë(Inv.inv f) x)) x","decl":"@[simp]\ntheorem units_apply_inv_apply (f : CircleDeg1LiftÀ£) (x : ‚Ñù) :\n    f ((f‚Åª¬π : CircleDeg1LiftÀ£) x) = x := by simp only [‚Üê mul_apply, f.mul_inv, coe_one, id]\n\n"}
{"name":"CircleDeg1Lift.coe_toOrderIso","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : Units CircleDeg1Lift\n‚ä¢ Eq ‚áë(CircleDeg1Lift.toOrderIso f) ‚áë‚Üëf","decl":"@[simp]\ntheorem coe_toOrderIso (f : CircleDeg1LiftÀ£) : ‚áë(toOrderIso f) = f :=\n  rfl\n\n"}
{"name":"CircleDeg1Lift.coe_toOrderIso_symm","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : Units CircleDeg1Lift\n‚ä¢ Eq ‚áë(CircleDeg1Lift.toOrderIso f).symm ‚áë‚Üë(Inv.inv f)","decl":"@[simp]\ntheorem coe_toOrderIso_symm (f : CircleDeg1LiftÀ£) :\n    ‚áë(toOrderIso f).symm = (f‚Åª¬π : CircleDeg1LiftÀ£) :=\n  rfl\n\n"}
{"name":"CircleDeg1Lift.coe_toOrderIso_inv","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : Units CircleDeg1Lift\n‚ä¢ Eq ‚áë(Inv.inv (CircleDeg1Lift.toOrderIso f)) ‚áë‚Üë(Inv.inv f)","decl":"@[simp]\ntheorem coe_toOrderIso_inv (f : CircleDeg1LiftÀ£) : ‚áë(toOrderIso f)‚Åª¬π = (f‚Åª¬π : CircleDeg1LiftÀ£) :=\n  rfl\n\n"}
{"name":"CircleDeg1Lift.isUnit_iff_bijective","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\n‚ä¢ Iff (IsUnit f) (Function.Bijective ‚áëf)","decl":"theorem isUnit_iff_bijective {f : CircleDeg1Lift} : IsUnit f ‚Üî Bijective f :=\n  ‚ü®fun ‚ü®u, h‚ü© => h ‚ñ∏ (toOrderIso u).bijective, fun h =>\n    Units.isUnit\n      { val := f\n        inv :=\n          { toFun := (Equiv.ofBijective f h).symm\n            monotone' := fun x y hxy =>\n              (f.strictMono_iff_injective.2 h.1).le_iff_le.1\n                (by simp only [Equiv.ofBijective_apply_symm_apply f h, hxy])\n            map_add_one' := fun x =>\n              h.1 <| by simp only [Equiv.ofBijective_apply_symm_apply f, f.map_add_one] }\n        val_inv := ext <| Equiv.ofBijective_apply_symm_apply f h\n        inv_val := ext <| Equiv.ofBijective_symm_apply_apply f h }‚ü©\n\n"}
{"name":"CircleDeg1Lift.coe_pow","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\nn : Nat\n‚ä¢ Eq (‚áë(HPow.hPow f n)) (Nat.iterate (‚áëf) n)","decl":"theorem coe_pow : ‚àÄ n : ‚Ñï, ‚áë(f ^ n) = f^[n]\n  | 0 => rfl\n  | n + 1 => by\n    ext x\n    simp [coe_pow n, pow_succ]\n\n"}
{"name":"CircleDeg1Lift.semiconjBy_iff_semiconj","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f g‚ÇÅ g‚ÇÇ : CircleDeg1Lift\n‚ä¢ Iff (SemiconjBy f g‚ÇÅ g‚ÇÇ) (Function.Semiconj ‚áëf ‚áëg‚ÇÅ ‚áëg‚ÇÇ)","decl":"theorem semiconjBy_iff_semiconj {f g‚ÇÅ g‚ÇÇ : CircleDeg1Lift} :\n    SemiconjBy f g‚ÇÅ g‚ÇÇ ‚Üî Semiconj f g‚ÇÅ g‚ÇÇ :=\n  CircleDeg1Lift.ext_iff\n\n"}
{"name":"CircleDeg1Lift.commute_iff_commute","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f g : CircleDeg1Lift\n‚ä¢ Iff (Commute f g) (Function.Commute ‚áëf ‚áëg)","decl":"theorem commute_iff_commute {f g : CircleDeg1Lift} : Commute f g ‚Üî Function.Commute f g :=\n  CircleDeg1Lift.ext_iff\n\n"}
{"name":"CircleDeg1Lift.translate_apply","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"x y : Real\n‚ä¢ Eq (‚Üë(CircleDeg1Lift.translate (Multiplicative.ofAdd x)) y) (HAdd.hAdd x y)","decl":"@[simp]\ntheorem translate_apply (x y : ‚Ñù) : translate (Multiplicative.ofAdd x) y = x + y :=\n  rfl\n\n"}
{"name":"CircleDeg1Lift.translate_inv_apply","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"x y : Real\n‚ä¢ Eq (‚Üë(Inv.inv (CircleDeg1Lift.translate (Multiplicative.ofAdd x))) y) (HAdd.hAdd (Neg.neg x) y)","decl":"@[simp]\ntheorem translate_inv_apply (x y : ‚Ñù) : (translate <| Multiplicative.ofAdd x)‚Åª¬π y = -x + y :=\n  rfl\n\n"}
{"name":"CircleDeg1Lift.translate_zpow","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"x : Real\nn : Int\n‚ä¢ Eq (HPow.hPow (CircleDeg1Lift.translate (Multiplicative.ofAdd x)) n) (CircleDeg1Lift.translate (Multiplicative.ofAdd (HMul.hMul (‚Üën) x)))","decl":"@[simp]\ntheorem translate_zpow (x : ‚Ñù) (n : ‚Ñ§) :\n    translate (Multiplicative.ofAdd x) ^ n = translate (Multiplicative.ofAdd <| ‚Üën * x) := by\n  simp only [‚Üê zsmul_eq_mul, ofAdd_zsmul, MonoidHom.map_zpow]\n\n"}
{"name":"CircleDeg1Lift.translate_pow","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"x : Real\nn : Nat\n‚ä¢ Eq (HPow.hPow (CircleDeg1Lift.translate (Multiplicative.ofAdd x)) n) (CircleDeg1Lift.translate (Multiplicative.ofAdd (HMul.hMul (‚Üën) x)))","decl":"@[simp]\ntheorem translate_pow (x : ‚Ñù) (n : ‚Ñï) :\n    translate (Multiplicative.ofAdd x) ^ n = translate (Multiplicative.ofAdd <| ‚Üën * x) :=\n  translate_zpow x n\n\n"}
{"name":"CircleDeg1Lift.translate_iterate","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"x : Real\nn : Nat\n‚ä¢ Eq (Nat.iterate (‚áë‚Üë(CircleDeg1Lift.translate (Multiplicative.ofAdd x))) n) ‚áë‚Üë(CircleDeg1Lift.translate (Multiplicative.ofAdd (HMul.hMul (‚Üën) x)))","decl":"@[simp]\ntheorem translate_iterate (x : ‚Ñù) (n : ‚Ñï) :\n    (translate (Multiplicative.ofAdd x))^[n] = translate (Multiplicative.ofAdd <| ‚Üën * x) := by\n  rw [‚Üê coe_pow, ‚Üê Units.val_pow_eq_pow_val, translate_pow]\n\n"}
{"name":"CircleDeg1Lift.commute_nat_add","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\nn : Nat\n‚ä¢ Function.Commute ‚áëf fun x => HAdd.hAdd (‚Üën) x","decl":"theorem commute_nat_add (n : ‚Ñï) : Function.Commute f (n + ¬∑) := by\n  simpa only [nsmul_one, add_left_iterate] using Function.Commute.iterate_right f.map_one_add n\n\n"}
{"name":"CircleDeg1Lift.commute_add_nat","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\nn : Nat\n‚ä¢ Function.Commute ‚áëf fun x => HAdd.hAdd x ‚Üën","decl":"theorem commute_add_nat (n : ‚Ñï) : Function.Commute f (¬∑ + n) := by\n  simp only [add_comm _ (n : ‚Ñù), f.commute_nat_add n]\n\n"}
{"name":"CircleDeg1Lift.commute_sub_nat","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\nn : Nat\n‚ä¢ Function.Commute ‚áëf fun x => HSub.hSub x ‚Üën","decl":"theorem commute_sub_nat (n : ‚Ñï) : Function.Commute f (¬∑ - n) := by\n  simpa only [sub_eq_add_neg] using\n    (f.commute_add_nat n).inverses_right (Equiv.addRight _).right_inv (Equiv.addRight _).left_inv\n\n"}
{"name":"CircleDeg1Lift.commute_add_int","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\nn : Int\n‚ä¢ Function.Commute ‚áëf fun x => HAdd.hAdd x ‚Üën","decl":"theorem commute_add_int : ‚àÄ n : ‚Ñ§, Function.Commute f (¬∑ + n)\n  | (n : ‚Ñï) => f.commute_add_nat n\n  | -[n+1] => by simpa [sub_eq_add_neg] using f.commute_sub_nat (n + 1)\n\n"}
{"name":"CircleDeg1Lift.commute_int_add","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\nn : Int\n‚ä¢ Function.Commute ‚áëf fun x => HAdd.hAdd (‚Üën) x","decl":"theorem commute_int_add (n : ‚Ñ§) : Function.Commute f (n + ¬∑) := by\n  simpa only [add_comm _ (n : ‚Ñù)] using f.commute_add_int n\n\n"}
{"name":"CircleDeg1Lift.commute_sub_int","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\nn : Int\n‚ä¢ Function.Commute ‚áëf fun x => HSub.hSub x ‚Üën","decl":"theorem commute_sub_int (n : ‚Ñ§) : Function.Commute f (¬∑ - n) := by\n  simpa only [sub_eq_add_neg] using\n    (f.commute_add_int n).inverses_right (Equiv.addRight _).right_inv (Equiv.addRight _).left_inv\n\n"}
{"name":"CircleDeg1Lift.map_int_add","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\nm : Int\nx : Real\n‚ä¢ Eq (f (HAdd.hAdd (‚Üëm) x)) (HAdd.hAdd (‚Üëm) (f x))","decl":"@[simp]\ntheorem map_int_add (m : ‚Ñ§) (x : ‚Ñù) : f (m + x) = m + f x :=\n  f.commute_int_add m x\n\n"}
{"name":"CircleDeg1Lift.map_add_int","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\nx : Real\nm : Int\n‚ä¢ Eq (f (HAdd.hAdd x ‚Üëm)) (HAdd.hAdd (f x) ‚Üëm)","decl":"@[simp]\ntheorem map_add_int (x : ‚Ñù) (m : ‚Ñ§) : f (x + m) = f x + m :=\n  f.commute_add_int m x\n\n"}
{"name":"CircleDeg1Lift.map_sub_int","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\nx : Real\nn : Int\n‚ä¢ Eq (f (HSub.hSub x ‚Üën)) (HSub.hSub (f x) ‚Üën)","decl":"@[simp]\ntheorem map_sub_int (x : ‚Ñù) (n : ‚Ñ§) : f (x - n) = f x - n :=\n  f.commute_sub_int n x\n\n"}
{"name":"CircleDeg1Lift.map_add_nat","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\nx : Real\nn : Nat\n‚ä¢ Eq (f (HAdd.hAdd x ‚Üën)) (HAdd.hAdd (f x) ‚Üën)","decl":"@[simp]\ntheorem map_add_nat (x : ‚Ñù) (n : ‚Ñï) : f (x + n) = f x + n :=\n  f.map_add_int x n\n\n"}
{"name":"CircleDeg1Lift.map_nat_add","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\nn : Nat\nx : Real\n‚ä¢ Eq (f (HAdd.hAdd (‚Üën) x)) (HAdd.hAdd (‚Üën) (f x))","decl":"@[simp]\ntheorem map_nat_add (n : ‚Ñï) (x : ‚Ñù) : f (n + x) = n + f x :=\n  f.map_int_add n x\n\n"}
{"name":"CircleDeg1Lift.map_sub_nat","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\nx : Real\nn : Nat\n‚ä¢ Eq (f (HSub.hSub x ‚Üën)) (HSub.hSub (f x) ‚Üën)","decl":"@[simp]\ntheorem map_sub_nat (x : ‚Ñù) (n : ‚Ñï) : f (x - n) = f x - n :=\n  f.map_sub_int x n\n\n"}
{"name":"CircleDeg1Lift.map_int_of_map_zero","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\nn : Int\n‚ä¢ Eq (f ‚Üën) (HAdd.hAdd (f 0) ‚Üën)","decl":"theorem map_int_of_map_zero (n : ‚Ñ§) : f n = f 0 + n := by rw [‚Üê f.map_add_int, zero_add]\n\n"}
{"name":"CircleDeg1Lift.map_fract_sub_fract_eq","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\nx : Real\n‚ä¢ Eq (HSub.hSub (f (Int.fract x)) (Int.fract x)) (HSub.hSub (f x) x)","decl":"@[simp]\ntheorem map_fract_sub_fract_eq (x : ‚Ñù) : f (fract x) - fract x = f x - x := by\n  rw [Int.fract, f.map_sub_int, sub_sub_sub_cancel_right]\n\n"}
{"name":"CircleDeg1Lift.sup_apply","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f g : CircleDeg1Lift\nx : Real\n‚ä¢ Eq ((Max.max f g) x) (Max.max (f x) (g x))","decl":"@[simp]\ntheorem sup_apply (x : ‚Ñù) : (f ‚äî g) x = max (f x) (g x) :=\n  rfl\n\n"}
{"name":"CircleDeg1Lift.inf_apply","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f g : CircleDeg1Lift\nx : Real\n‚ä¢ Eq ((Min.min f g) x) (Min.min (f x) (g x))","decl":"@[simp]\ntheorem inf_apply (x : ‚Ñù) : (f ‚äì g) x = min (f x) (g x) :=\n  rfl\n\n"}
{"name":"CircleDeg1Lift.iterate_monotone","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"n : Nat\n‚ä¢ Monotone fun f => Nat.iterate (‚áëf) n","decl":"theorem iterate_monotone (n : ‚Ñï) : Monotone fun f : CircleDeg1Lift => f^[n] := fun f _ h =>\n  f.monotone.iterate_le_of_le h _\n\n"}
{"name":"CircleDeg1Lift.iterate_mono","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f g : CircleDeg1Lift\nh : LE.le f g\nn : Nat\n‚ä¢ LE.le (Nat.iterate (‚áëf) n) (Nat.iterate (‚áëg) n)","decl":"theorem iterate_mono {f g : CircleDeg1Lift} (h : f ‚â§ g) (n : ‚Ñï) : f^[n] ‚â§ g^[n] :=\n  iterate_monotone n h\n\n"}
{"name":"CircleDeg1Lift.pow_mono","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f g : CircleDeg1Lift\nh : LE.le f g\nn : Nat\n‚ä¢ LE.le (HPow.hPow f n) (HPow.hPow g n)","decl":"theorem pow_mono {f g : CircleDeg1Lift} (h : f ‚â§ g) (n : ‚Ñï) : f ^ n ‚â§ g ^ n := fun x => by\n  simp only [coe_pow, iterate_mono h n x]\n\n"}
{"name":"CircleDeg1Lift.pow_monotone","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"n : Nat\n‚ä¢ Monotone fun f => HPow.hPow f n","decl":"theorem pow_monotone (n : ‚Ñï) : Monotone fun f : CircleDeg1Lift => f ^ n := fun _ _ h => pow_mono h n\n\n"}
{"name":"CircleDeg1Lift.map_le_of_map_zero","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\nx : Real\n‚ä¢ LE.le (f x) (HAdd.hAdd (f 0) ‚Üë(Int.ceil x))","decl":"theorem map_le_of_map_zero (x : ‚Ñù) : f x ‚â§ f 0 + ‚åàx‚åâ :=\n  calc\n    f x ‚â§ f ‚åàx‚åâ := f.monotone <| le_ceil _\n    _ = f 0 + ‚åàx‚åâ := f.map_int_of_map_zero _\n\n"}
{"name":"CircleDeg1Lift.map_map_zero_le","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f g : CircleDeg1Lift\n‚ä¢ LE.le (f (g 0)) (HAdd.hAdd (f 0) ‚Üë(Int.ceil (g 0)))","decl":"theorem map_map_zero_le : f (g 0) ‚â§ f 0 + ‚åàg 0‚åâ :=\n  f.map_le_of_map_zero (g 0)\n\n"}
{"name":"CircleDeg1Lift.floor_map_map_zero_le","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f g : CircleDeg1Lift\n‚ä¢ LE.le (Int.floor (f (g 0))) (HAdd.hAdd (Int.floor (f 0)) (Int.ceil (g 0)))","decl":"theorem floor_map_map_zero_le : ‚åäf (g 0)‚åã ‚â§ ‚åäf 0‚åã + ‚åàg 0‚åâ :=\n  calc\n    ‚åäf (g 0)‚åã ‚â§ ‚åäf 0 + ‚åàg 0‚åâ‚åã := floor_mono <| f.map_map_zero_le g\n    _ = ‚åäf 0‚åã + ‚åàg 0‚åâ := floor_add_int _ _\n\n"}
{"name":"CircleDeg1Lift.ceil_map_map_zero_le","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f g : CircleDeg1Lift\n‚ä¢ LE.le (Int.ceil (f (g 0))) (HAdd.hAdd (Int.ceil (f 0)) (Int.ceil (g 0)))","decl":"theorem ceil_map_map_zero_le : ‚åàf (g 0)‚åâ ‚â§ ‚åàf 0‚åâ + ‚åàg 0‚åâ :=\n  calc\n    ‚åàf (g 0)‚åâ ‚â§ ‚åàf 0 + ‚åàg 0‚åâ‚åâ := ceil_mono <| f.map_map_zero_le g\n    _ = ‚åàf 0‚åâ + ‚åàg 0‚åâ := ceil_add_int _ _\n\n"}
{"name":"CircleDeg1Lift.map_map_zero_lt","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f g : CircleDeg1Lift\n‚ä¢ LT.lt (f (g 0)) (HAdd.hAdd (HAdd.hAdd (f 0) (g 0)) 1)","decl":"theorem map_map_zero_lt : f (g 0) < f 0 + g 0 + 1 :=\n  calc\n    f (g 0) ‚â§ f 0 + ‚åàg 0‚åâ := f.map_map_zero_le g\n    _ < f 0 + (g 0 + 1) := add_lt_add_left (ceil_lt_add_one _) _\n    _ = f 0 + g 0 + 1 := (add_assoc _ _ _).symm\n\n"}
{"name":"CircleDeg1Lift.le_map_of_map_zero","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\nx : Real\n‚ä¢ LE.le (HAdd.hAdd (f 0) ‚Üë(Int.floor x)) (f x)","decl":"theorem le_map_of_map_zero (x : ‚Ñù) : f 0 + ‚åäx‚åã ‚â§ f x :=\n  calc\n    f 0 + ‚åäx‚åã = f ‚åäx‚åã := (f.map_int_of_map_zero _).symm\n    _ ‚â§ f x := f.monotone <| floor_le _\n\n"}
{"name":"CircleDeg1Lift.le_map_map_zero","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f g : CircleDeg1Lift\n‚ä¢ LE.le (HAdd.hAdd (f 0) ‚Üë(Int.floor (g 0))) (f (g 0))","decl":"theorem le_map_map_zero : f 0 + ‚åäg 0‚åã ‚â§ f (g 0) :=\n  f.le_map_of_map_zero (g 0)\n\n"}
{"name":"CircleDeg1Lift.le_floor_map_map_zero","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f g : CircleDeg1Lift\n‚ä¢ LE.le (HAdd.hAdd (Int.floor (f 0)) (Int.floor (g 0))) (Int.floor (f (g 0)))","decl":"theorem le_floor_map_map_zero : ‚åäf 0‚åã + ‚åäg 0‚åã ‚â§ ‚åäf (g 0)‚åã :=\n  calc\n    ‚åäf 0‚åã + ‚åäg 0‚åã = ‚åäf 0 + ‚åäg 0‚åã‚åã := (floor_add_int _ _).symm\n    _ ‚â§ ‚åäf (g 0)‚åã := floor_mono <| f.le_map_map_zero g\n\n"}
{"name":"CircleDeg1Lift.le_ceil_map_map_zero","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f g : CircleDeg1Lift\n‚ä¢ LE.le (HAdd.hAdd (Int.ceil (f 0)) (Int.floor (g 0))) (Int.ceil ((HMul.hMul f g) 0))","decl":"theorem le_ceil_map_map_zero : ‚åàf 0‚åâ + ‚åäg 0‚åã ‚â§ ‚åà(f * g) 0‚åâ :=\n  calc\n    ‚åàf 0‚åâ + ‚åäg 0‚åã = ‚åàf 0 + ‚åäg 0‚åã‚åâ := (ceil_add_int _ _).symm\n    _ ‚â§ ‚åàf (g 0)‚åâ := ceil_mono <| f.le_map_map_zero g\n\n"}
{"name":"CircleDeg1Lift.lt_map_map_zero","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f g : CircleDeg1Lift\n‚ä¢ LT.lt (HSub.hSub (HAdd.hAdd (f 0) (g 0)) 1) (f (g 0))","decl":"theorem lt_map_map_zero : f 0 + g 0 - 1 < f (g 0) :=\n  calc\n    f 0 + g 0 - 1 = f 0 + (g 0 - 1) := add_sub_assoc _ _ _\n    _ < f 0 + ‚åäg 0‚åã := add_lt_add_left (sub_one_lt_floor _) _\n    _ ‚â§ f (g 0) := f.le_map_map_zero g\n\n"}
{"name":"CircleDeg1Lift.dist_map_map_zero_lt","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f g : CircleDeg1Lift\n‚ä¢ LT.lt (Dist.dist (HAdd.hAdd (f 0) (g 0)) (f (g 0))) 1","decl":"theorem dist_map_map_zero_lt : dist (f 0 + g 0) (f (g 0)) < 1 := by\n  rw [dist_comm, Real.dist_eq, abs_lt, lt_sub_iff_add_lt', sub_lt_iff_lt_add', ‚Üê sub_eq_add_neg]\n  exact ‚ü®f.lt_map_map_zero g, f.map_map_zero_lt g‚ü©\n\n"}
{"name":"CircleDeg1Lift.dist_map_zero_lt_of_semiconj","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f g‚ÇÅ g‚ÇÇ : CircleDeg1Lift\nh : Function.Semiconj ‚áëf ‚áëg‚ÇÅ ‚áëg‚ÇÇ\n‚ä¢ LT.lt (Dist.dist (g‚ÇÅ 0) (g‚ÇÇ 0)) 2","decl":"theorem dist_map_zero_lt_of_semiconj {f g‚ÇÅ g‚ÇÇ : CircleDeg1Lift} (h : Function.Semiconj f g‚ÇÅ g‚ÇÇ) :\n    dist (g‚ÇÅ 0) (g‚ÇÇ 0) < 2 :=\n  calc\n    dist (g‚ÇÅ 0) (g‚ÇÇ 0) ‚â§ dist (g‚ÇÅ 0) (f (g‚ÇÅ 0) - f 0) + dist _ (g‚ÇÇ 0) := dist_triangle _ _ _\n    _ = dist (f 0 + g‚ÇÅ 0) (f (g‚ÇÅ 0)) + dist (g‚ÇÇ 0 + f 0) (g‚ÇÇ (f 0)) := by\n      simp only [h.eq, Real.dist_eq, sub_sub, add_comm (f 0), sub_sub_eq_add_sub,\n        abs_sub_comm (g‚ÇÇ (f 0))]\n    _ < 1 + 1 := add_lt_add (f.dist_map_map_zero_lt g‚ÇÅ) (g‚ÇÇ.dist_map_map_zero_lt f)\n    _ = 2 := one_add_one_eq_two\n\n"}
{"name":"CircleDeg1Lift.dist_map_zero_lt_of_semiconjBy","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f g‚ÇÅ g‚ÇÇ : CircleDeg1Lift\nh : SemiconjBy f g‚ÇÅ g‚ÇÇ\n‚ä¢ LT.lt (Dist.dist (g‚ÇÅ 0) (g‚ÇÇ 0)) 2","decl":"theorem dist_map_zero_lt_of_semiconjBy {f g‚ÇÅ g‚ÇÇ : CircleDeg1Lift} (h : SemiconjBy f g‚ÇÅ g‚ÇÇ) :\n    dist (g‚ÇÅ 0) (g‚ÇÇ 0) < 2 :=\n  dist_map_zero_lt_of_semiconj <| semiconjBy_iff_semiconj.1 h\n\n"}
{"name":"CircleDeg1Lift.tendsto_atBot","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\n‚ä¢ Filter.Tendsto (‚áëf) Filter.atBot Filter.atBot","decl":"protected theorem tendsto_atBot : Tendsto f atBot atBot :=\n  tendsto_atBot_mono f.map_le_of_map_zero <| tendsto_atBot_add_const_left _ _ <|\n    (tendsto_atBot_mono fun x => (ceil_lt_add_one x).le) <|\n      tendsto_atBot_add_const_right _ _ tendsto_id\n\n"}
{"name":"CircleDeg1Lift.tendsto_atTop","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\n‚ä¢ Filter.Tendsto (‚áëf) Filter.atTop Filter.atTop","decl":"protected theorem tendsto_atTop : Tendsto f atTop atTop :=\n  tendsto_atTop_mono f.le_map_of_map_zero <| tendsto_atTop_add_const_left _ _ <|\n    (tendsto_atTop_mono fun x => (sub_one_lt_floor x).le) <| by\n      simpa [sub_eq_add_neg] using tendsto_atTop_add_const_right _ _ tendsto_id\n\n"}
{"name":"CircleDeg1Lift.continuous_iff_surjective","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\n‚ä¢ Iff (Continuous ‚áëf) (Function.Surjective ‚áëf)","decl":"theorem continuous_iff_surjective : Continuous f ‚Üî Function.Surjective f :=\n  ‚ü®fun h => h.surjective f.tendsto_atTop f.tendsto_atBot, f.monotone.continuous_of_surjective‚ü©\n\n"}
{"name":"CircleDeg1Lift.iterate_le_of_map_le_add_int","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\nx : Real\nm : Int\nh : LE.le (f x) (HAdd.hAdd x ‚Üëm)\nn : Nat\n‚ä¢ LE.le (Nat.iterate (‚áëf) n x) (HAdd.hAdd x (HMul.hMul ‚Üën ‚Üëm))","decl":"theorem iterate_le_of_map_le_add_int {x : ‚Ñù} {m : ‚Ñ§} (h : f x ‚â§ x + m) (n : ‚Ñï) :\n    f^[n] x ‚â§ x + n * m := by\n  simpa only [nsmul_eq_mul, add_right_iterate] using\n    (f.commute_add_int m).iterate_le_of_map_le f.monotone (monotone_id.add_const (m : ‚Ñù)) h n\n\n"}
{"name":"CircleDeg1Lift.le_iterate_of_add_int_le_map","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\nx : Real\nm : Int\nh : LE.le (HAdd.hAdd x ‚Üëm) (f x)\nn : Nat\n‚ä¢ LE.le (HAdd.hAdd x (HMul.hMul ‚Üën ‚Üëm)) (Nat.iterate (‚áëf) n x)","decl":"theorem le_iterate_of_add_int_le_map {x : ‚Ñù} {m : ‚Ñ§} (h : x + m ‚â§ f x) (n : ‚Ñï) :\n    x + n * m ‚â§ f^[n] x := by\n  simpa only [nsmul_eq_mul, add_right_iterate] using\n    (f.commute_add_int m).symm.iterate_le_of_map_le (monotone_id.add_const (m : ‚Ñù)) f.monotone h n\n\n"}
{"name":"CircleDeg1Lift.iterate_eq_of_map_eq_add_int","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\nx : Real\nm : Int\nh : Eq (f x) (HAdd.hAdd x ‚Üëm)\nn : Nat\n‚ä¢ Eq (Nat.iterate (‚áëf) n x) (HAdd.hAdd x (HMul.hMul ‚Üën ‚Üëm))","decl":"theorem iterate_eq_of_map_eq_add_int {x : ‚Ñù} {m : ‚Ñ§} (h : f x = x + m) (n : ‚Ñï) :\n    f^[n] x = x + n * m := by\n  simpa only [nsmul_eq_mul, add_right_iterate] using (f.commute_add_int m).iterate_eq_of_map_eq n h\n\n"}
{"name":"CircleDeg1Lift.iterate_pos_le_iff","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\nx : Real\nm : Int\nn : Nat\nhn : LT.lt 0 n\n‚ä¢ Iff (LE.le (Nat.iterate (‚áëf) n x) (HAdd.hAdd x (HMul.hMul ‚Üën ‚Üëm))) (LE.le (f x) (HAdd.hAdd x ‚Üëm))","decl":"theorem iterate_pos_le_iff {x : ‚Ñù} {m : ‚Ñ§} {n : ‚Ñï} (hn : 0 < n) :\n    f^[n] x ‚â§ x + n * m ‚Üî f x ‚â§ x + m := by\n  simpa only [nsmul_eq_mul, add_right_iterate] using\n    (f.commute_add_int m).iterate_pos_le_iff_map_le f.monotone (strictMono_id.add_const (m : ‚Ñù)) hn\n\n"}
{"name":"CircleDeg1Lift.iterate_pos_lt_iff","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\nx : Real\nm : Int\nn : Nat\nhn : LT.lt 0 n\n‚ä¢ Iff (LT.lt (Nat.iterate (‚áëf) n x) (HAdd.hAdd x (HMul.hMul ‚Üën ‚Üëm))) (LT.lt (f x) (HAdd.hAdd x ‚Üëm))","decl":"theorem iterate_pos_lt_iff {x : ‚Ñù} {m : ‚Ñ§} {n : ‚Ñï} (hn : 0 < n) :\n    f^[n] x < x + n * m ‚Üî f x < x + m := by\n  simpa only [nsmul_eq_mul, add_right_iterate] using\n    (f.commute_add_int m).iterate_pos_lt_iff_map_lt f.monotone (strictMono_id.add_const (m : ‚Ñù)) hn\n\n"}
{"name":"CircleDeg1Lift.iterate_pos_eq_iff","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\nx : Real\nm : Int\nn : Nat\nhn : LT.lt 0 n\n‚ä¢ Iff (Eq (Nat.iterate (‚áëf) n x) (HAdd.hAdd x (HMul.hMul ‚Üën ‚Üëm))) (Eq (f x) (HAdd.hAdd x ‚Üëm))","decl":"theorem iterate_pos_eq_iff {x : ‚Ñù} {m : ‚Ñ§} {n : ‚Ñï} (hn : 0 < n) :\n    f^[n] x = x + n * m ‚Üî f x = x + m := by\n  simpa only [nsmul_eq_mul, add_right_iterate] using\n    (f.commute_add_int m).iterate_pos_eq_iff_map_eq f.monotone (strictMono_id.add_const (m : ‚Ñù)) hn\n\n"}
{"name":"CircleDeg1Lift.le_iterate_pos_iff","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\nx : Real\nm : Int\nn : Nat\nhn : LT.lt 0 n\n‚ä¢ Iff (LE.le (HAdd.hAdd x (HMul.hMul ‚Üën ‚Üëm)) (Nat.iterate (‚áëf) n x)) (LE.le (HAdd.hAdd x ‚Üëm) (f x))","decl":"theorem le_iterate_pos_iff {x : ‚Ñù} {m : ‚Ñ§} {n : ‚Ñï} (hn : 0 < n) :\n    x + n * m ‚â§ f^[n] x ‚Üî x + m ‚â§ f x := by\n  simpa only [not_lt] using not_congr (f.iterate_pos_lt_iff hn)\n\n"}
{"name":"CircleDeg1Lift.lt_iterate_pos_iff","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\nx : Real\nm : Int\nn : Nat\nhn : LT.lt 0 n\n‚ä¢ Iff (LT.lt (HAdd.hAdd x (HMul.hMul ‚Üën ‚Üëm)) (Nat.iterate (‚áëf) n x)) (LT.lt (HAdd.hAdd x ‚Üëm) (f x))","decl":"theorem lt_iterate_pos_iff {x : ‚Ñù} {m : ‚Ñ§} {n : ‚Ñï} (hn : 0 < n) :\n    x + n * m < f^[n] x ‚Üî x + m < f x := by\n  simpa only [not_le] using not_congr (f.iterate_pos_le_iff hn)\n\n"}
{"name":"CircleDeg1Lift.mul_floor_map_zero_le_floor_iterate_zero","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\nn : Nat\n‚ä¢ LE.le (HMul.hMul (‚Üën) (Int.floor (f 0))) (Int.floor (Nat.iterate (‚áëf) n 0))","decl":"theorem mul_floor_map_zero_le_floor_iterate_zero (n : ‚Ñï) : ‚Üën * ‚åäf 0‚åã ‚â§ ‚åäf^[n] 0‚åã := by\n  rw [le_floor, Int.cast_mul, Int.cast_natCast, ‚Üê zero_add ((n : ‚Ñù) * _)]\n  apply le_iterate_of_add_int_le_map\n  simp [floor_le]\n\n"}
{"name":"CircleDeg1Lift.transnumAuxSeq_def","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\n‚ä¢ Eq f.transnumAuxSeq fun n => HDiv.hDiv ((HPow.hPow f (HPow.hPow 2 n)) 0) (HPow.hPow 2 n)","decl":"theorem transnumAuxSeq_def : f.transnumAuxSeq = fun n : ‚Ñï => (f ^ (2 ^ n : ‚Ñï)) 0 / 2 ^ n :=\n  rfl\n\n"}
{"name":"CircleDeg1Lift.translationNumber_eq_of_tendsto_aux","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\nœÑ' : Real\nh : Filter.Tendsto f.transnumAuxSeq Filter.atTop (nhds œÑ')\n‚ä¢ Eq f.translationNumber œÑ'","decl":"theorem translationNumber_eq_of_tendsto_aux {œÑ' : ‚Ñù} (h : Tendsto f.transnumAuxSeq atTop (ùìù œÑ')) :\n    œÑ f = œÑ' :=\n  h.limUnder_eq\n\n"}
{"name":"CircleDeg1Lift.translationNumber_eq_of_tendsto‚ÇÄ","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\nœÑ' : Real\nh : Filter.Tendsto (fun n => HDiv.hDiv (Nat.iterate (‚áëf) n 0) ‚Üën) Filter.atTop (nhds œÑ')\n‚ä¢ Eq f.translationNumber œÑ'","decl":"theorem translationNumber_eq_of_tendsto‚ÇÄ {œÑ' : ‚Ñù}\n    (h : Tendsto (fun n : ‚Ñï => f^[n] 0 / n) atTop (ùìù œÑ')) : œÑ f = œÑ' :=\n  f.translationNumber_eq_of_tendsto_aux <| by\n    simpa [Function.comp_def, transnumAuxSeq_def, coe_pow] using\n      h.comp (Nat.tendsto_pow_atTop_atTop_of_one_lt one_lt_two)\n\n"}
{"name":"CircleDeg1Lift.translationNumber_eq_of_tendsto‚ÇÄ'","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\nœÑ' : Real\nh : Filter.Tendsto (fun n => HDiv.hDiv (Nat.iterate (‚áëf) (HAdd.hAdd n 1) 0) (HAdd.hAdd (‚Üën) 1)) Filter.atTop (nhds œÑ')\n‚ä¢ Eq f.translationNumber œÑ'","decl":"theorem translationNumber_eq_of_tendsto‚ÇÄ' {œÑ' : ‚Ñù}\n    (h : Tendsto (fun n : ‚Ñï => f^[n + 1] 0 / (n + 1)) atTop (ùìù œÑ')) : œÑ f = œÑ' :=\n  f.translationNumber_eq_of_tendsto‚ÇÄ <| (tendsto_add_atTop_iff_nat 1).1 (mod_cast h)\n\n"}
{"name":"CircleDeg1Lift.transnumAuxSeq_zero","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\n‚ä¢ Eq (f.transnumAuxSeq 0) (f 0)","decl":"theorem transnumAuxSeq_zero : f.transnumAuxSeq 0 = f 0 := by simp [transnumAuxSeq]\n\n"}
{"name":"CircleDeg1Lift.transnumAuxSeq_dist_lt","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\nn : Nat\n‚ä¢ LT.lt (Dist.dist (f.transnumAuxSeq n) (f.transnumAuxSeq (HAdd.hAdd n 1))) (HDiv.hDiv (1 / 2) (HPow.hPow 2 n))","decl":"theorem transnumAuxSeq_dist_lt (n : ‚Ñï) :\n    dist (f.transnumAuxSeq n) (f.transnumAuxSeq (n + 1)) < 1 / 2 / 2 ^ n := by\n  have : 0 < (2 ^ (n + 1) : ‚Ñù) := pow_pos zero_lt_two _\n  rw [div_div, ‚Üê pow_succ', ‚Üê abs_of_pos this]\n  calc\n    _ = dist ((f ^ 2 ^ n) 0 + (f ^ 2 ^ n) 0) ((f ^ 2 ^ n) ((f ^ 2 ^ n) 0)) / |2 ^ (n + 1)| := by\n      simp_rw [transnumAuxSeq, Real.dist_eq]\n      rw [‚Üê abs_div, sub_div, pow_succ, pow_succ', ‚Üê two_mul, mul_div_mul_left _ _ (two_ne_zero' ‚Ñù),\n        pow_mul, sq, mul_apply]\n    _ < _ := by gcongr; exact (f ^ 2 ^ n).dist_map_map_zero_lt (f ^ 2 ^ n)\n\n"}
{"name":"CircleDeg1Lift.tendsto_translationNumber_aux","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\n‚ä¢ Filter.Tendsto f.transnumAuxSeq Filter.atTop (nhds f.translationNumber)","decl":"theorem tendsto_translationNumber_aux : Tendsto f.transnumAuxSeq atTop (ùìù <| œÑ f) :=\n  (cauchySeq_of_le_geometric_two fun n => le_of_lt <| f.transnumAuxSeq_dist_lt n).tendsto_limUnder\n\n"}
{"name":"CircleDeg1Lift.dist_map_zero_translationNumber_le","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\n‚ä¢ LE.le (Dist.dist (f 0) f.translationNumber) 1","decl":"theorem dist_map_zero_translationNumber_le : dist (f 0) (œÑ f) ‚â§ 1 :=\n  f.transnumAuxSeq_zero ‚ñ∏\n    dist_le_of_le_geometric_two_of_tendsto‚ÇÄ (fun n => le_of_lt <| f.transnumAuxSeq_dist_lt n)\n      f.tendsto_translationNumber_aux\n\n"}
{"name":"CircleDeg1Lift.tendsto_translationNumber_of_dist_bounded_aux","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\nx : Nat ‚Üí Real\nC : Real\nH : ‚àÄ (n : Nat), LE.le (Dist.dist ((HPow.hPow f n) 0) (x n)) C\n‚ä¢ Filter.Tendsto (fun n => HDiv.hDiv (x (HPow.hPow 2 n)) (HPow.hPow 2 n)) Filter.atTop (nhds f.translationNumber)","decl":"theorem tendsto_translationNumber_of_dist_bounded_aux (x : ‚Ñï ‚Üí ‚Ñù) (C : ‚Ñù)\n    (H : ‚àÄ n : ‚Ñï, dist ((f ^ n) 0) (x n) ‚â§ C) :\n    Tendsto (fun n : ‚Ñï => x (2 ^ n) / 2 ^ n) atTop (ùìù <| œÑ f) := by\n  apply f.tendsto_translationNumber_aux.congr_dist (squeeze_zero (fun _ => dist_nonneg) _ _)\n  ¬∑ exact fun n => C / 2 ^ n\n  ¬∑ intro n\n    have : 0 < (2 ^ n : ‚Ñù) := pow_pos zero_lt_two _\n    convert (div_le_div_iff_of_pos_right this).2 (H (2 ^ n)) using 1\n    rw [transnumAuxSeq, Real.dist_eq, ‚Üê sub_div, abs_div, abs_of_pos this, Real.dist_eq]\n  ¬∑ exact mul_zero C ‚ñ∏ tendsto_const_nhds.mul <| tendsto_inv_atTop_zero.comp <|\n      tendsto_pow_atTop_atTop_of_one_lt one_lt_two\n\n"}
{"name":"CircleDeg1Lift.translationNumber_eq_of_dist_bounded","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f g : CircleDeg1Lift\nC : Real\nH : ‚àÄ (n : Nat), LE.le (Dist.dist ((HPow.hPow f n) 0) ((HPow.hPow g n) 0)) C\n‚ä¢ Eq f.translationNumber g.translationNumber","decl":"theorem translationNumber_eq_of_dist_bounded {f g : CircleDeg1Lift} (C : ‚Ñù)\n    (H : ‚àÄ n : ‚Ñï, dist ((f ^ n) 0) ((g ^ n) 0) ‚â§ C) : œÑ f = œÑ g :=\n  Eq.symm <| g.translationNumber_eq_of_tendsto_aux <|\n    f.tendsto_translationNumber_of_dist_bounded_aux (fun n ‚Ü¶ (g ^ n) 0) C H\n\n"}
{"name":"CircleDeg1Lift.translationNumber_one","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"‚ä¢ Eq (CircleDeg1Lift.translationNumber 1) 0","decl":"@[simp]\ntheorem translationNumber_one : œÑ 1 = 0 :=\n  translationNumber_eq_of_tendsto‚ÇÄ _ <| by simp [tendsto_const_nhds]\n\n"}
{"name":"CircleDeg1Lift.translationNumber_eq_of_semiconjBy","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f g‚ÇÅ g‚ÇÇ : CircleDeg1Lift\nH : SemiconjBy f g‚ÇÅ g‚ÇÇ\n‚ä¢ Eq g‚ÇÅ.translationNumber g‚ÇÇ.translationNumber","decl":"theorem translationNumber_eq_of_semiconjBy {f g‚ÇÅ g‚ÇÇ : CircleDeg1Lift} (H : SemiconjBy f g‚ÇÅ g‚ÇÇ) :\n    œÑ g‚ÇÅ = œÑ g‚ÇÇ :=\n  translationNumber_eq_of_dist_bounded 2 fun n =>\n    le_of_lt <| dist_map_zero_lt_of_semiconjBy <| H.pow_right n\n\n"}
{"name":"CircleDeg1Lift.translationNumber_eq_of_semiconj","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f g‚ÇÅ g‚ÇÇ : CircleDeg1Lift\nH : Function.Semiconj ‚áëf ‚áëg‚ÇÅ ‚áëg‚ÇÇ\n‚ä¢ Eq g‚ÇÅ.translationNumber g‚ÇÇ.translationNumber","decl":"theorem translationNumber_eq_of_semiconj {f g‚ÇÅ g‚ÇÇ : CircleDeg1Lift}\n    (H : Function.Semiconj f g‚ÇÅ g‚ÇÇ) : œÑ g‚ÇÅ = œÑ g‚ÇÇ :=\n  translationNumber_eq_of_semiconjBy <| semiconjBy_iff_semiconj.2 H\n\n"}
{"name":"CircleDeg1Lift.translationNumber_mul_of_commute","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f g : CircleDeg1Lift\nh : Commute f g\n‚ä¢ Eq (HMul.hMul f g).translationNumber (HAdd.hAdd f.translationNumber g.translationNumber)","decl":"theorem translationNumber_mul_of_commute {f g : CircleDeg1Lift} (h : Commute f g) :\n    œÑ (f * g) = œÑ f + œÑ g := by\n  refine tendsto_nhds_unique ?_\n    (f.tendsto_translationNumber_aux.add g.tendsto_translationNumber_aux)\n  simp only [transnumAuxSeq, ‚Üê add_div]\n  refine (f * g).tendsto_translationNumber_of_dist_bounded_aux\n    (fun n ‚Ü¶ (f ^ n) 0 + (g ^ n) 0) 1 fun n ‚Ü¶ ?_\n  rw [h.mul_pow, dist_comm]\n  exact le_of_lt ((f ^ n).dist_map_map_zero_lt (g ^ n))\n\n"}
{"name":"CircleDeg1Lift.translationNumber_units_inv","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : Units CircleDeg1Lift\n‚ä¢ Eq (‚Üë(Inv.inv f)).translationNumber (Neg.neg (‚Üëf).translationNumber)","decl":"@[simp]\ntheorem translationNumber_units_inv (f : CircleDeg1LiftÀ£) : œÑ ‚Üëf‚Åª¬π = -œÑ f :=\n  eq_neg_iff_add_eq_zero.2 <| by\n    simp [‚Üê translationNumber_mul_of_commute (Commute.refl _).units_inv_left]\n\n"}
{"name":"CircleDeg1Lift.translationNumber_pow","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\nn : Nat\n‚ä¢ Eq (HPow.hPow f n).translationNumber (HMul.hMul (‚Üën) f.translationNumber)","decl":"@[simp]\ntheorem translationNumber_pow : ‚àÄ n : ‚Ñï, œÑ (f ^ n) = n * œÑ f\n  | 0 => by simp\n  | n + 1 => by\n    rw [pow_succ, translationNumber_mul_of_commute (Commute.pow_self f n),\n      translationNumber_pow n, Nat.cast_add_one, add_mul, one_mul]\n\n"}
{"name":"CircleDeg1Lift.translationNumber_zpow","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : Units CircleDeg1Lift\nn : Int\n‚ä¢ Eq (‚Üë(HPow.hPow f n)).translationNumber (HMul.hMul (‚Üën) (‚Üëf).translationNumber)","decl":"@[simp]\ntheorem translationNumber_zpow (f : CircleDeg1LiftÀ£) : ‚àÄ n : ‚Ñ§, œÑ (f ^ n : Units _) = n * œÑ f\n  | (n : ‚Ñï) => by simp [translationNumber_pow f n]\n  | -[n+1] => by simp; ring\n\n"}
{"name":"CircleDeg1Lift.translationNumber_conj_eq","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : Units CircleDeg1Lift\ng : CircleDeg1Lift\n‚ä¢ Eq (HMul.hMul (HMul.hMul (‚Üëf) g) ‚Üë(Inv.inv f)).translationNumber g.translationNumber","decl":"@[simp]\ntheorem translationNumber_conj_eq (f : CircleDeg1LiftÀ£) (g : CircleDeg1Lift) :\n    œÑ (‚Üëf * g * ‚Üëf‚Åª¬π) = œÑ g :=\n  (translationNumber_eq_of_semiconjBy (f.mk_semiconjBy g)).symm\n\n"}
{"name":"CircleDeg1Lift.translationNumber_conj_eq'","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : Units CircleDeg1Lift\ng : CircleDeg1Lift\n‚ä¢ Eq (HMul.hMul (HMul.hMul (‚Üë(Inv.inv f)) g) ‚Üëf).translationNumber g.translationNumber","decl":"@[simp]\ntheorem translationNumber_conj_eq' (f : CircleDeg1LiftÀ£) (g : CircleDeg1Lift) :\n    œÑ (‚Üëf‚Åª¬π * g * f) = œÑ g :=\n  translationNumber_conj_eq f‚Åª¬π g\n\n"}
{"name":"CircleDeg1Lift.dist_pow_map_zero_mul_translationNumber_le","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\nn : Nat\n‚ä¢ LE.le (Dist.dist ((HPow.hPow f n) 0) (HMul.hMul (‚Üën) f.translationNumber)) 1","decl":"theorem dist_pow_map_zero_mul_translationNumber_le (n : ‚Ñï) :\n    dist ((f ^ n) 0) (n * f.translationNumber) ‚â§ 1 :=\n  f.translationNumber_pow n ‚ñ∏ (f ^ n).dist_map_zero_translationNumber_le\n\n"}
{"name":"CircleDeg1Lift.tendsto_translation_number‚ÇÄ'","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\n‚ä¢ Filter.Tendsto (fun n => HDiv.hDiv ((HPow.hPow f (HAdd.hAdd n 1)) 0) (HAdd.hAdd (‚Üën) 1)) Filter.atTop (nhds f.translationNumber)","decl":"theorem tendsto_translation_number‚ÇÄ' :\n    Tendsto (fun n : ‚Ñï => (f ^ (n + 1) : CircleDeg1Lift) 0 / ((n : ‚Ñù) + 1)) atTop (ùìù <| œÑ f) := by\n  refine\n    tendsto_iff_dist_tendsto_zero.2 <|\n      squeeze_zero (fun _ => dist_nonneg) (fun n => ?_)\n        ((tendsto_const_div_atTop_nhds_zero_nat 1).comp (tendsto_add_atTop_nat 1))\n  dsimp\n  have : (0 : ‚Ñù) < n + 1 := n.cast_add_one_pos\n  rw [Real.dist_eq, div_sub' _ _ _ (ne_of_gt this), abs_div, ‚Üê Real.dist_eq, abs_of_pos this,\n    Nat.cast_add_one, div_le_div_iff_of_pos_right this, ‚Üê Nat.cast_add_one]\n  apply dist_pow_map_zero_mul_translationNumber_le\n\n"}
{"name":"CircleDeg1Lift.tendsto_translation_number‚ÇÄ","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\n‚ä¢ Filter.Tendsto (fun n => HDiv.hDiv ((HPow.hPow f n) 0) ‚Üën) Filter.atTop (nhds f.translationNumber)","decl":"theorem tendsto_translation_number‚ÇÄ : Tendsto (fun n : ‚Ñï => (f ^ n) 0 / n) atTop (ùìù <| œÑ f) :=\n  (tendsto_add_atTop_iff_nat 1).1 (mod_cast f.tendsto_translation_number‚ÇÄ')\n\n"}
{"name":"CircleDeg1Lift.tendsto_translationNumber","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\nx : Real\n‚ä¢ Filter.Tendsto (fun n => HDiv.hDiv (HSub.hSub ((HPow.hPow f n) x) x) ‚Üën) Filter.atTop (nhds f.translationNumber)","decl":"/-- For any `x : ‚Ñù` the sequence $\\frac{f^n(x)-x}{n}$ tends to the translation number of `f`.\nIn particular, this limit does not depend on `x`. -/\ntheorem tendsto_translationNumber (x : ‚Ñù) :\n    Tendsto (fun n : ‚Ñï => ((f ^ n) x - x) / n) atTop (ùìù <| œÑ f) := by\n  rw [‚Üê translationNumber_conj_eq' (translate <| Multiplicative.ofAdd x)]\n  refine (tendsto_translation_number‚ÇÄ _).congr fun n ‚Ü¶ ?_\n  simp [sub_eq_neg_add, Units.conj_pow']\n\n"}
{"name":"CircleDeg1Lift.tendsto_translation_number'","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\nx : Real\n‚ä¢ Filter.Tendsto (fun n => HDiv.hDiv (HSub.hSub ((HPow.hPow f (HAdd.hAdd n 1)) x) x) (HAdd.hAdd (‚Üën) 1)) Filter.atTop (nhds f.translationNumber)","decl":"theorem tendsto_translation_number' (x : ‚Ñù) :\n    Tendsto (fun n : ‚Ñï => ((f ^ (n + 1) : CircleDeg1Lift) x - x) / (n + 1)) atTop (ùìù <| œÑ f) :=\n  mod_cast (tendsto_add_atTop_iff_nat 1).2 (f.tendsto_translationNumber x)\n\n"}
{"name":"CircleDeg1Lift.translationNumber_mono","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"‚ä¢ Monotone CircleDeg1Lift.translationNumber","decl":"theorem translationNumber_mono : Monotone œÑ := fun f g h =>\n  le_of_tendsto_of_tendsto' f.tendsto_translation_number‚ÇÄ g.tendsto_translation_number‚ÇÄ fun n => by\n    gcongr; exact pow_mono h _ _\n\n"}
{"name":"CircleDeg1Lift.translationNumber_translate","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"x : Real\n‚ä¢ Eq (‚Üë(CircleDeg1Lift.translate (Multiplicative.ofAdd x))).translationNumber x","decl":"theorem translationNumber_translate (x : ‚Ñù) : œÑ (translate <| Multiplicative.ofAdd x) = x :=\n  translationNumber_eq_of_tendsto‚ÇÄ' _ <| by\n    simp only [translate_iterate, translate_apply, add_zero, Nat.cast_succ,\n      mul_div_cancel_left‚ÇÄ (M‚ÇÄ := ‚Ñù) _ (Nat.cast_add_one_ne_zero _), tendsto_const_nhds]\n\n"}
{"name":"CircleDeg1Lift.translationNumber_le_of_le_add","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\nz : Real\nhz : ‚àÄ (x : Real), LE.le (f x) (HAdd.hAdd x z)\n‚ä¢ LE.le f.translationNumber z","decl":"theorem translationNumber_le_of_le_add {z : ‚Ñù} (hz : ‚àÄ x, f x ‚â§ x + z) : œÑ f ‚â§ z :=\n  translationNumber_translate z ‚ñ∏ translationNumber_mono fun x => (hz x).trans_eq (add_comm _ _)\n\n"}
{"name":"CircleDeg1Lift.le_translationNumber_of_add_le","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\nz : Real\nhz : ‚àÄ (x : Real), LE.le (HAdd.hAdd x z) (f x)\n‚ä¢ LE.le z f.translationNumber","decl":"theorem le_translationNumber_of_add_le {z : ‚Ñù} (hz : ‚àÄ x, x + z ‚â§ f x) : z ‚â§ œÑ f :=\n  translationNumber_translate z ‚ñ∏ translationNumber_mono fun x => (add_comm _ _).trans_le (hz x)\n\n"}
{"name":"CircleDeg1Lift.translationNumber_le_of_le_add_int","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\nx : Real\nm : Int\nh : LE.le (f x) (HAdd.hAdd x ‚Üëm)\n‚ä¢ LE.le f.translationNumber ‚Üëm","decl":"theorem translationNumber_le_of_le_add_int {x : ‚Ñù} {m : ‚Ñ§} (h : f x ‚â§ x + m) : œÑ f ‚â§ m :=\n  le_of_tendsto' (f.tendsto_translation_number' x) fun n =>\n    (div_le_iff‚ÇÄ' (n.cast_add_one_pos : (0 : ‚Ñù) < _)).mpr <| sub_le_iff_le_add'.2 <|\n      (coe_pow f (n + 1)).symm ‚ñ∏ @Nat.cast_add_one ‚Ñù _ n ‚ñ∏ f.iterate_le_of_map_le_add_int h (n + 1)\n\n"}
{"name":"CircleDeg1Lift.translationNumber_le_of_le_add_nat","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\nx : Real\nm : Nat\nh : LE.le (f x) (HAdd.hAdd x ‚Üëm)\n‚ä¢ LE.le f.translationNumber ‚Üëm","decl":"theorem translationNumber_le_of_le_add_nat {x : ‚Ñù} {m : ‚Ñï} (h : f x ‚â§ x + m) : œÑ f ‚â§ m :=\n  @translationNumber_le_of_le_add_int f x m h\n\n"}
{"name":"CircleDeg1Lift.le_translationNumber_of_add_int_le","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\nx : Real\nm : Int\nh : LE.le (HAdd.hAdd x ‚Üëm) (f x)\n‚ä¢ LE.le (‚Üëm) f.translationNumber","decl":"theorem le_translationNumber_of_add_int_le {x : ‚Ñù} {m : ‚Ñ§} (h : x + m ‚â§ f x) : ‚Üëm ‚â§ œÑ f :=\n  ge_of_tendsto' (f.tendsto_translation_number' x) fun n =>\n    (le_div_iff‚ÇÄ (n.cast_add_one_pos : (0 : ‚Ñù) < _)).mpr <| le_sub_iff_add_le'.2 <| by\n      simp only [coe_pow, mul_comm (m : ‚Ñù), ‚Üê Nat.cast_add_one, f.le_iterate_of_add_int_le_map h]\n\n"}
{"name":"CircleDeg1Lift.le_translationNumber_of_add_nat_le","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\nx : Real\nm : Nat\nh : LE.le (HAdd.hAdd x ‚Üëm) (f x)\n‚ä¢ LE.le (‚Üëm) f.translationNumber","decl":"theorem le_translationNumber_of_add_nat_le {x : ‚Ñù} {m : ‚Ñï} (h : x + m ‚â§ f x) : ‚Üëm ‚â§ œÑ f :=\n  @le_translationNumber_of_add_int_le f x m h\n\n"}
{"name":"CircleDeg1Lift.translationNumber_of_eq_add_int","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\nx : Real\nm : Int\nh : Eq (f x) (HAdd.hAdd x ‚Üëm)\n‚ä¢ Eq f.translationNumber ‚Üëm","decl":"/-- If `f x - x` is an integer number `m` for some point `x`, then `œÑ f = m`.\nOn the circle this means that a map with a fixed point has rotation number zero. -/\ntheorem translationNumber_of_eq_add_int {x : ‚Ñù} {m : ‚Ñ§} (h : f x = x + m) : œÑ f = m :=\n  le_antisymm (translationNumber_le_of_le_add_int f <| le_of_eq h)\n    (le_translationNumber_of_add_int_le f <| le_of_eq h.symm)\n\n"}
{"name":"CircleDeg1Lift.floor_sub_le_translationNumber","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\nx : Real\n‚ä¢ LE.le (‚Üë(Int.floor (HSub.hSub (f x) x))) f.translationNumber","decl":"theorem floor_sub_le_translationNumber (x : ‚Ñù) : ‚Üë‚åäf x - x‚åã ‚â§ œÑ f :=\n  le_translationNumber_of_add_int_le f <| le_sub_iff_add_le'.1 (floor_le <| f x - x)\n\n"}
{"name":"CircleDeg1Lift.translationNumber_le_ceil_sub","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\nx : Real\n‚ä¢ LE.le f.translationNumber ‚Üë(Int.ceil (HSub.hSub (f x) x))","decl":"theorem translationNumber_le_ceil_sub (x : ‚Ñù) : œÑ f ‚â§ ‚åàf x - x‚åâ :=\n  translationNumber_le_of_le_add_int f <| sub_le_iff_le_add'.1 (le_ceil <| f x - x)\n\n"}
{"name":"CircleDeg1Lift.map_lt_of_translationNumber_lt_int","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\nn : Int\nh : LT.lt f.translationNumber ‚Üën\nx : Real\n‚ä¢ LT.lt (f x) (HAdd.hAdd x ‚Üën)","decl":"theorem map_lt_of_translationNumber_lt_int {n : ‚Ñ§} (h : œÑ f < n) (x : ‚Ñù) : f x < x + n :=\n  not_le.1 <| mt f.le_translationNumber_of_add_int_le <| not_le.2 h\n\n"}
{"name":"CircleDeg1Lift.map_lt_of_translationNumber_lt_nat","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\nn : Nat\nh : LT.lt f.translationNumber ‚Üën\nx : Real\n‚ä¢ LT.lt (f x) (HAdd.hAdd x ‚Üën)","decl":"theorem map_lt_of_translationNumber_lt_nat {n : ‚Ñï} (h : œÑ f < n) (x : ‚Ñù) : f x < x + n :=\n  @map_lt_of_translationNumber_lt_int f n h x\n\n"}
{"name":"CircleDeg1Lift.map_lt_add_floor_translationNumber_add_one","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\nx : Real\n‚ä¢ LT.lt (f x) (HAdd.hAdd (HAdd.hAdd x ‚Üë(Int.floor f.translationNumber)) 1)","decl":"theorem map_lt_add_floor_translationNumber_add_one (x : ‚Ñù) : f x < x + ‚åäœÑ f‚åã + 1 := by\n  rw [add_assoc]\n  norm_cast\n  refine map_lt_of_translationNumber_lt_int _ ?_ _\n  push_cast\n  exact lt_floor_add_one _\n\n"}
{"name":"CircleDeg1Lift.map_lt_add_translationNumber_add_one","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\nx : Real\n‚ä¢ LT.lt (f x) (HAdd.hAdd (HAdd.hAdd x f.translationNumber) 1)","decl":"theorem map_lt_add_translationNumber_add_one (x : ‚Ñù) : f x < x + œÑ f + 1 :=\n  calc\n    f x < x + ‚åäœÑ f‚åã + 1 := f.map_lt_add_floor_translationNumber_add_one x\n    _ ‚â§ x + œÑ f + 1 := by gcongr; apply floor_le\n\n"}
{"name":"CircleDeg1Lift.lt_map_of_int_lt_translationNumber","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\nn : Int\nh : LT.lt (‚Üën) f.translationNumber\nx : Real\n‚ä¢ LT.lt (HAdd.hAdd x ‚Üën) (f x)","decl":"theorem lt_map_of_int_lt_translationNumber {n : ‚Ñ§} (h : ‚Üën < œÑ f) (x : ‚Ñù) : x + n < f x :=\n  not_le.1 <| mt f.translationNumber_le_of_le_add_int <| not_le.2 h\n\n"}
{"name":"CircleDeg1Lift.lt_map_of_nat_lt_translationNumber","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\nn : Nat\nh : LT.lt (‚Üën) f.translationNumber\nx : Real\n‚ä¢ LT.lt (HAdd.hAdd x ‚Üën) (f x)","decl":"theorem lt_map_of_nat_lt_translationNumber {n : ‚Ñï} (h : ‚Üën < œÑ f) (x : ‚Ñù) : x + n < f x :=\n  @lt_map_of_int_lt_translationNumber f n h x\n\n"}
{"name":"CircleDeg1Lift.translationNumber_of_map_pow_eq_add_int","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\nx : Real\nn : Nat\nm : Int\nh : Eq ((HPow.hPow f n) x) (HAdd.hAdd x ‚Üëm)\nhn : LT.lt 0 n\n‚ä¢ Eq f.translationNumber (HDiv.hDiv ‚Üëm ‚Üën)","decl":"/-- If `f^n x - x`, `n > 0`, is an integer number `m` for some point `x`, then\n`œÑ f = m / n`. On the circle this means that a map with a periodic orbit has\na rational rotation number. -/\ntheorem translationNumber_of_map_pow_eq_add_int {x : ‚Ñù} {n : ‚Ñï} {m : ‚Ñ§} (h : (f ^ n) x = x + m)\n    (hn : 0 < n) : œÑ f = m / n := by\n  have := (f ^ n).translationNumber_of_eq_add_int h\n  rwa [translationNumber_pow, mul_comm, ‚Üê eq_div_iff] at this\n  exact Nat.cast_ne_zero.2 (ne_of_gt hn)\n\n"}
{"name":"CircleDeg1Lift.forall_map_sub_of_Icc","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\nP : Real ‚Üí Prop\nh : ‚àÄ (x : Real), Membership.mem (Set.Icc 0 1) x ‚Üí P (HSub.hSub (f x) x)\nx : Real\n‚ä¢ P (HSub.hSub (f x) x)","decl":"/-- If a predicate depends only on `f x - x` and holds for all `0 ‚â§ x ‚â§ 1`,\nthen it holds for all `x`. -/\ntheorem forall_map_sub_of_Icc (P : ‚Ñù ‚Üí Prop) (h : ‚àÄ x ‚àà Icc (0 : ‚Ñù) 1, P (f x - x)) (x : ‚Ñù) :\n    P (f x - x) :=\n  f.map_fract_sub_fract_eq x ‚ñ∏ h _ ‚ü®fract_nonneg _, le_of_lt (fract_lt_one _)‚ü©\n\n"}
{"name":"CircleDeg1Lift.translationNumber_lt_of_forall_lt_add","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\nhf : Continuous ‚áëf\nz : Real\nhz : ‚àÄ (x : Real), LT.lt (f x) (HAdd.hAdd x z)\n‚ä¢ LT.lt f.translationNumber z","decl":"theorem translationNumber_lt_of_forall_lt_add (hf : Continuous f) {z : ‚Ñù} (hz : ‚àÄ x, f x < x + z) :\n    œÑ f < z := by\n  obtain ‚ü®x, -, hx‚ü© : ‚àÉ x ‚àà Icc (0 : ‚Ñù) 1, ‚àÄ y ‚àà Icc (0 : ‚Ñù) 1, f y - y ‚â§ f x - x :=\n    isCompact_Icc.exists_isMaxOn (nonempty_Icc.2 zero_le_one)\n      (hf.sub continuous_id).continuousOn\n  refine lt_of_le_of_lt ?_ (sub_lt_iff_lt_add'.2 <| hz x)\n  apply translationNumber_le_of_le_add\n  simp only [‚Üê sub_le_iff_le_add']\n  exact f.forall_map_sub_of_Icc (fun a => a ‚â§ f x - x) hx\n\n"}
{"name":"CircleDeg1Lift.lt_translationNumber_of_forall_add_lt","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\nhf : Continuous ‚áëf\nz : Real\nhz : ‚àÄ (x : Real), LT.lt (HAdd.hAdd x z) (f x)\n‚ä¢ LT.lt z f.translationNumber","decl":"theorem lt_translationNumber_of_forall_add_lt (hf : Continuous f) {z : ‚Ñù} (hz : ‚àÄ x, x + z < f x) :\n    z < œÑ f := by\n  obtain ‚ü®x, -, hx‚ü© : ‚àÉ x ‚àà Icc (0 : ‚Ñù) 1, ‚àÄ y ‚àà Icc (0 : ‚Ñù) 1, f x - x ‚â§ f y - y :=\n    isCompact_Icc.exists_isMinOn (nonempty_Icc.2 zero_le_one) (hf.sub continuous_id).continuousOn\n  refine lt_of_lt_of_le (lt_sub_iff_add_lt'.2 <| hz x) ?_\n  apply le_translationNumber_of_add_le\n  simp only [‚Üê le_sub_iff_add_le']\n  exact f.forall_map_sub_of_Icc _ hx\n\n"}
{"name":"CircleDeg1Lift.exists_eq_add_translationNumber","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\nhf : Continuous ‚áëf\n‚ä¢ Exists fun x => Eq (f x) (HAdd.hAdd x f.translationNumber)","decl":"/-- If `f` is a continuous monotone map `‚Ñù ‚Üí ‚Ñù`, `f (x + 1) = f x + 1`, then there exists `x`\nsuch that `f x = x + œÑ f`. -/\ntheorem exists_eq_add_translationNumber (hf : Continuous f) : ‚àÉ x, f x = x + œÑ f := by\n  obtain ‚ü®a, ha‚ü© : ‚àÉ x, f x ‚â§ x + œÑ f := by\n    by_contra! H\n    exact lt_irrefl _ (f.lt_translationNumber_of_forall_add_lt hf H)\n  obtain ‚ü®b, hb‚ü© : ‚àÉ x, x + œÑ f ‚â§ f x := by\n    by_contra! H\n    exact lt_irrefl _ (f.translationNumber_lt_of_forall_lt_add hf H)\n  exact intermediate_value_univ‚ÇÇ hf (continuous_id.add continuous_const) ha hb\n\n"}
{"name":"CircleDeg1Lift.translationNumber_eq_int_iff","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\nhf : Continuous ‚áëf\nm : Int\n‚ä¢ Iff (Eq f.translationNumber ‚Üëm) (Exists fun x => Eq (f x) (HAdd.hAdd x ‚Üëm))","decl":"theorem translationNumber_eq_int_iff (hf : Continuous f) {m : ‚Ñ§} :\n    œÑ f = m ‚Üî ‚àÉ x : ‚Ñù, f x = x + m := by\n  constructor\n  ¬∑ intro h\n    simp only [‚Üê h]\n    exact f.exists_eq_add_translationNumber hf\n  ¬∑ rintro ‚ü®x, hx‚ü©\n    exact f.translationNumber_of_eq_add_int hx\n\n"}
{"name":"CircleDeg1Lift.continuous_pow","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\nhf : Continuous ‚áëf\nn : Nat\n‚ä¢ Continuous ‚áë(HPow.hPow f n)","decl":"theorem continuous_pow (hf : Continuous f) (n : ‚Ñï) : Continuous (f ^ n : CircleDeg1Lift) := by\n  rw [coe_pow]\n  exact hf.iterate n\n\n"}
{"name":"CircleDeg1Lift.translationNumber_eq_rat_iff","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f : CircleDeg1Lift\nhf : Continuous ‚áëf\nm : Int\nn : Nat\nhn : LT.lt 0 n\n‚ä¢ Iff (Eq f.translationNumber (HDiv.hDiv ‚Üëm ‚Üën)) (Exists fun x => Eq ((HPow.hPow f n) x) (HAdd.hAdd x ‚Üëm))","decl":"theorem translationNumber_eq_rat_iff (hf : Continuous f) {m : ‚Ñ§} {n : ‚Ñï} (hn : 0 < n) :\n    œÑ f = m / n ‚Üî ‚àÉ x, (f ^ n) x = x + m := by\n  rw [eq_div_iff, mul_comm, ‚Üê translationNumber_pow] <;> [skip; exact ne_of_gt (Nat.cast_pos.2 hn)]\n  exact (f ^ n).translationNumber_eq_int_iff (f.continuous_pow hf n)\n\n"}
{"name":"CircleDeg1Lift.semiconj_of_group_action_of_forall_translationNumber_eq","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"G : Type u_1\ninst‚úù : Group G\nf‚ÇÅ f‚ÇÇ : MonoidHom G CircleDeg1Lift\nh : ‚àÄ (g : G), Eq (f‚ÇÅ g).translationNumber (f‚ÇÇ g).translationNumber\n‚ä¢ Exists fun F => ‚àÄ (g : G), Function.Semiconj ‚áëF ‚áë(f‚ÇÅ g) ‚áë(f‚ÇÇ g)","decl":"/-- Consider two actions `f‚ÇÅ f‚ÇÇ : G ‚Üí* CircleDeg1Lift` of a group on the real line by lifts of\norientation preserving circle homeomorphisms. Suppose that for each `g : G` the homeomorphisms\n`f‚ÇÅ g` and `f‚ÇÇ g` have equal rotation numbers. Then there exists `F : CircleDeg1Lift` such that\n`F * f‚ÇÅ g = f‚ÇÇ g * F` for all `g : G`.\n\nThis is a version of Proposition 5.4 from [√âtienne Ghys, Groupes d'homeomorphismes du cercle et\ncohomologie bornee][ghys87:groupes]. -/\ntheorem semiconj_of_group_action_of_forall_translationNumber_eq {G : Type*} [Group G]\n    (f‚ÇÅ f‚ÇÇ : G ‚Üí* CircleDeg1Lift) (h : ‚àÄ g, œÑ (f‚ÇÅ g) = œÑ (f‚ÇÇ g)) :\n    ‚àÉ F : CircleDeg1Lift, ‚àÄ g, Semiconj F (f‚ÇÅ g) (f‚ÇÇ g) := by\n  -- Equality of translation number guarantees that for each `x`\n  -- the set `{f‚ÇÇ g‚Åª¬π (f‚ÇÅ g x) | g : G}` is bounded above.\n  have : ‚àÄ x, BddAbove (range fun g => f‚ÇÇ g‚Åª¬π (f‚ÇÅ g x)) := by\n    refine fun x => ‚ü®x + 2, ?_‚ü©\n    rintro _ ‚ü®g, rfl‚ü©\n    have : œÑ (f‚ÇÇ g‚Åª¬π) = -œÑ (f‚ÇÇ g) := by\n      rw [‚Üê MonoidHom.coe_toHomUnits, MonoidHom.map_inv, translationNumber_units_inv,\n        MonoidHom.coe_toHomUnits]\n    calc\n      f‚ÇÇ g‚Åª¬π (f‚ÇÅ g x) ‚â§ f‚ÇÇ g‚Åª¬π (x + œÑ (f‚ÇÅ g) + 1) :=\n        mono _ (map_lt_add_translationNumber_add_one _ _).le\n      _ = f‚ÇÇ g‚Åª¬π (x + œÑ (f‚ÇÇ g)) + 1 := by rw [h, map_add_one]\n      _ ‚â§ x + œÑ (f‚ÇÇ g) + œÑ (f‚ÇÇ g‚Åª¬π) + 1 + 1 :=\n        add_le_add_right (map_lt_add_translationNumber_add_one _ _).le _\n      _ = x + 2 := by simp [this, add_assoc, one_add_one_eq_two]\n  -- We have a theorem about actions by `OrderIso`, so we introduce auxiliary maps\n  -- to `‚Ñù ‚âÉo ‚Ñù`.\n  set F‚ÇÅ := toOrderIso.comp f‚ÇÅ.toHomUnits\n  set F‚ÇÇ := toOrderIso.comp f‚ÇÇ.toHomUnits\n  have hF‚ÇÅ : ‚àÄ g, ‚áë(F‚ÇÅ g) = f‚ÇÅ g := fun _ => rfl\n  have hF‚ÇÇ : ‚àÄ g, ‚áë(F‚ÇÇ g) = f‚ÇÇ g := fun _ => rfl\n  -- Now we apply `csSup_div_semiconj` and go back to `f‚ÇÅ` and `f‚ÇÇ`.\n  refine ‚ü®‚ü®‚ü®fun x ‚Ü¶ ‚®Ü g', (F‚ÇÇ g')‚Åª¬π (F‚ÇÅ g' x), fun x y hxy => ?_‚ü©, fun x => ?_‚ü©,\n    csSup_div_semiconj F‚ÇÇ F‚ÇÅ fun x => ?_‚ü© <;> simp only [hF‚ÇÅ, hF‚ÇÇ, ‚Üê map_inv, coe_mk]\n  ¬∑ exact ciSup_mono (this y) fun g => mono _ (mono _ hxy)\n  ¬∑ simp only [map_add_one]\n    exact (Monotone.map_ciSup_of_continuousAt (continuousAt_id.add continuousAt_const)\n      (monotone_id.add_const (1 : ‚Ñù)) (this x)).symm\n  ¬∑ exact this x\n\n"}
{"name":"CircleDeg1Lift.units_semiconj_of_translationNumber_eq","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f‚ÇÅ f‚ÇÇ : Units CircleDeg1Lift\nh : Eq (‚Üëf‚ÇÅ).translationNumber (‚Üëf‚ÇÇ).translationNumber\n‚ä¢ Exists fun F => Function.Semiconj ‚áëF ‚áë‚Üëf‚ÇÅ ‚áë‚Üëf‚ÇÇ","decl":"/-- If two lifts of circle homeomorphisms have the same translation number, then they are\nsemiconjugate by a `CircleDeg1Lift`. This version uses arguments `f‚ÇÅ f‚ÇÇ : CircleDeg1LiftÀ£`\nto assume that `f‚ÇÅ` and `f‚ÇÇ` are homeomorphisms. -/\ntheorem units_semiconj_of_translationNumber_eq {f‚ÇÅ f‚ÇÇ : CircleDeg1LiftÀ£} (h : œÑ f‚ÇÅ = œÑ f‚ÇÇ) :\n    ‚àÉ F : CircleDeg1Lift, Semiconj F f‚ÇÅ f‚ÇÇ :=\n  have : ‚àÄ n : Multiplicative ‚Ñ§,\n      œÑ ((Units.coeHom _).comp (zpowersHom _ f‚ÇÅ) n) =\n        œÑ ((Units.coeHom _).comp (zpowersHom _ f‚ÇÇ) n) := fun n ‚Ü¶ by\n    simp [h]\n  (semiconj_of_group_action_of_forall_translationNumber_eq _ _ this).imp fun F hF => by\n    simpa using hF (Multiplicative.ofAdd 1)\n\n"}
{"name":"CircleDeg1Lift.semiconj_of_isUnit_of_translationNumber_eq","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f‚ÇÅ f‚ÇÇ : CircleDeg1Lift\nh‚ÇÅ : IsUnit f‚ÇÅ\nh‚ÇÇ : IsUnit f‚ÇÇ\nh : Eq f‚ÇÅ.translationNumber f‚ÇÇ.translationNumber\n‚ä¢ Exists fun F => Function.Semiconj ‚áëF ‚áëf‚ÇÅ ‚áëf‚ÇÇ","decl":"/-- If two lifts of circle homeomorphisms have the same translation number, then they are\nsemiconjugate by a `CircleDeg1Lift`. This version uses assumptions `IsUnit f‚ÇÅ` and `IsUnit f‚ÇÇ`\nto assume that `f‚ÇÅ` and `f‚ÇÇ` are homeomorphisms. -/\ntheorem semiconj_of_isUnit_of_translationNumber_eq {f‚ÇÅ f‚ÇÇ : CircleDeg1Lift} (h‚ÇÅ : IsUnit f‚ÇÅ)\n    (h‚ÇÇ : IsUnit f‚ÇÇ) (h : œÑ f‚ÇÅ = œÑ f‚ÇÇ) : ‚àÉ F : CircleDeg1Lift, Semiconj F f‚ÇÅ f‚ÇÇ := by\n  rcases h‚ÇÅ, h‚ÇÇ with ‚ü®‚ü®f‚ÇÅ, rfl‚ü©, ‚ü®f‚ÇÇ, rfl‚ü©‚ü©\n  exact units_semiconj_of_translationNumber_eq h\n\n"}
{"name":"CircleDeg1Lift.semiconj_of_bijective_of_translationNumber_eq","module":"Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber","initialProofState":"f‚ÇÅ f‚ÇÇ : CircleDeg1Lift\nh‚ÇÅ : Function.Bijective ‚áëf‚ÇÅ\nh‚ÇÇ : Function.Bijective ‚áëf‚ÇÇ\nh : Eq f‚ÇÅ.translationNumber f‚ÇÇ.translationNumber\n‚ä¢ Exists fun F => Function.Semiconj ‚áëF ‚áëf‚ÇÅ ‚áëf‚ÇÇ","decl":"/-- If two lifts of circle homeomorphisms have the same translation number, then they are\nsemiconjugate by a `CircleDeg1Lift`. This version uses assumptions `bijective f‚ÇÅ` and\n`bijective f‚ÇÇ` to assume that `f‚ÇÅ` and `f‚ÇÇ` are homeomorphisms. -/\ntheorem semiconj_of_bijective_of_translationNumber_eq {f‚ÇÅ f‚ÇÇ : CircleDeg1Lift} (h‚ÇÅ : Bijective f‚ÇÅ)\n    (h‚ÇÇ : Bijective f‚ÇÇ) (h : œÑ f‚ÇÅ = œÑ f‚ÇÇ) : ‚àÉ F : CircleDeg1Lift, Semiconj F f‚ÇÅ f‚ÇÇ :=\n  semiconj_of_isUnit_of_translationNumber_eq (isUnit_iff_bijective.2 h‚ÇÅ) (isUnit_iff_bijective.2 h‚ÇÇ)\n    h\n\n"}
