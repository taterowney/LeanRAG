{"name":"PresheafOfModules.Sheafify.app_eq_of_isLocallyInjective","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Sheafify","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nR₀ R : CategoryTheory.Functor (Opposite C) RingCat\nα : Quiver.Hom R₀ R\ninst✝¹ : CategoryTheory.Presheaf.IsLocallyInjective J α\nM₀ : PresheafOfModules R₀\nA : CategoryTheory.Functor (Opposite C) AddCommGrp\nφ : Quiver.Hom M₀.presheaf A\ninst✝ : CategoryTheory.Presheaf.IsLocallyInjective J φ\nhA : CategoryTheory.Presheaf.IsSeparated J A\nY : C\nr₀ r₀' : ↑(R₀.obj { unop := Y })\nm₀ m₀' : ↑(M₀.obj { unop := Y })\nhr₀ : Eq ((CategoryTheory.ConcreteCategory.hom (α.app { unop := Y })) r₀) ((CategoryTheory.ConcreteCategory.hom (α.app { unop := Y })) r₀')\nhm₀ : Eq ((CategoryTheory.ConcreteCategory.hom (φ.app { unop := Y })) m₀) ((CategoryTheory.ConcreteCategory.hom (φ.app { unop := Y })) m₀')\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom (φ.app { unop := Y })) (HSMul.hSMul r₀ m₀)) ((CategoryTheory.ConcreteCategory.hom (φ.app { unop := Y })) (HSMul.hSMul r₀' m₀'))","decl":"lemma _root_.PresheafOfModules.Sheafify.app_eq_of_isLocallyInjective\n    {Y : C} (r₀ r₀' : R₀.obj (Opposite.op Y))\n    (m₀ m₀' : M₀.obj (Opposite.op Y))\n    (hr₀ : α.app _ r₀ = α.app _ r₀')\n    (hm₀ : φ.app _ m₀ = φ.app _ m₀') :\n    φ.app _ (r₀ • m₀) = φ.app _ (r₀' • m₀') := by\n  apply hA _ (Presheaf.equalizerSieve r₀ r₀' ⊓\n      Presheaf.equalizerSieve (F := M₀.presheaf) m₀ m₀')\n  · apply J.intersection_covering\n    · exact Presheaf.equalizerSieve_mem J α _ _ hr₀\n    · exact Presheaf.equalizerSieve_mem J φ _ _ hm₀\n  · intro Z g hg\n    erw [← NatTrans.naturality_apply, ← NatTrans.naturality_apply, M₀.map_smul, M₀.map_smul,\n      hg.1, hg.2]\n    rfl\n\n"}
{"name":"CategoryTheory.Presieve.FamilyOfElements.isCompatible_map_smul_aux","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Sheafify","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nR₀ R : CategoryTheory.Functor (Opposite C) RingCat\nα : Quiver.Hom R₀ R\ninst✝¹ : CategoryTheory.Presheaf.IsLocallyInjective J α\nM₀ : PresheafOfModules R₀\nA : CategoryTheory.Functor (Opposite C) AddCommGrp\nφ : Quiver.Hom M₀.presheaf A\ninst✝ : CategoryTheory.Presheaf.IsLocallyInjective J φ\nhA : CategoryTheory.Presheaf.IsSeparated J A\nX : C\nr : ↑(R.obj { unop := X })\nm : ↑(A.obj { unop := X })\nY Z : C\nf : Quiver.Hom Y X\ng : Quiver.Hom Z Y\nr₀ : ↑(R₀.obj { unop := Y })\nr₀' : ↑(R₀.obj { unop := Z })\nm₀ : ↑(M₀.obj { unop := Y })\nm₀' : ↑(M₀.obj { unop := Z })\nhr₀ : Eq ((CategoryTheory.ConcreteCategory.hom (α.app { unop := Y })) r₀) ((CategoryTheory.ConcreteCategory.hom (R.map f.op)) r)\nhr₀' : Eq ((CategoryTheory.ConcreteCategory.hom (α.app { unop := Z })) r₀') ((CategoryTheory.ConcreteCategory.hom (R.map (CategoryTheory.CategoryStruct.comp f.op g.op))) r)\nhm₀ : Eq ((CategoryTheory.ConcreteCategory.hom (φ.app { unop := Y })) m₀) ((CategoryTheory.ConcreteCategory.hom (A.map f.op)) m)\nhm₀' : Eq ((CategoryTheory.ConcreteCategory.hom (φ.app { unop := Z })) m₀') ((CategoryTheory.ConcreteCategory.hom (A.map (CategoryTheory.CategoryStruct.comp f.op g.op))) m)\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom (φ.app { unop := Z })) ((CategoryTheory.ConcreteCategory.hom (M₀.map g.op)) (HSMul.hSMul r₀ m₀))) ((CategoryTheory.ConcreteCategory.hom (φ.app { unop := Z })) (HSMul.hSMul r₀' m₀'))","decl":"lemma isCompatible_map_smul_aux {Y Z : C} (f : Y ⟶ X) (g : Z ⟶ Y)\n    (r₀ : R₀.obj (Opposite.op Y)) (r₀' : R₀.obj (Opposite.op Z))\n    (m₀ : M₀.obj (Opposite.op Y)) (m₀' : M₀.obj (Opposite.op Z))\n    (hr₀ : α.app _ r₀ = R.map f.op r) (hr₀' : α.app _ r₀' = R.map (f.op ≫ g.op) r)\n    (hm₀ : φ.app _ m₀ = A.map f.op m) (hm₀' : φ.app _ m₀' = A.map (f.op ≫ g.op) m) :\n    φ.app _ (M₀.map g.op (r₀ • m₀)) = φ.app _ (r₀' • m₀') := by\n  rw [← PresheafOfModules.Sheafify.app_eq_of_isLocallyInjective α φ hA (R₀.map g.op r₀) r₀'\n    (M₀.map g.op m₀) m₀', M₀.map_smul]\n  · rw [hr₀', R.map_comp, RingCat.comp_apply, ← hr₀, ← RingCat.comp_apply, NatTrans.naturality,\n      RingCat.comp_apply]\n  · rw [hm₀', A.map_comp, AddCommGrp.coe_comp, Function.comp_apply, ← hm₀]\n    erw [NatTrans.naturality_apply φ]\n    rfl -- `ConcreteCategory`/`HasForget` mismatch workaround\n\n"}
{"name":"CategoryTheory.Presieve.FamilyOfElements.isCompatible_map_smul","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Sheafify","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nR₀ R : CategoryTheory.Functor (Opposite C) RingCat\nα : Quiver.Hom R₀ R\ninst✝¹ : CategoryTheory.Presheaf.IsLocallyInjective J α\nM₀ : PresheafOfModules R₀\nA : CategoryTheory.Functor (Opposite C) AddCommGrp\nφ : Quiver.Hom M₀.presheaf A\ninst✝ : CategoryTheory.Presheaf.IsLocallyInjective J φ\nhA : CategoryTheory.Presheaf.IsSeparated J A\nX : C\nr : ↑(R.obj { unop := X })\nm : ↑(A.obj { unop := X })\nP : CategoryTheory.Presieve X\nr₀ : CategoryTheory.Presieve.FamilyOfElements (R₀.comp (CategoryTheory.forget RingCat)) P\nm₀ : CategoryTheory.Presieve.FamilyOfElements (M₀.presheaf.comp (CategoryTheory.forget Ab)) P\nhr₀ : (r₀.map (CategoryTheory.whiskerRight α (CategoryTheory.forget RingCat))).IsAmalgamation r\nhm₀ : (m₀.map (CategoryTheory.whiskerRight φ (CategoryTheory.forget Ab))).IsAmalgamation m\n⊢ ((r₀.smul m₀).map (CategoryTheory.whiskerRight φ (CategoryTheory.forget Ab))).Compatible","decl":"include hr₀ hm₀ in\nlemma isCompatible_map_smul : ((r₀.smul m₀).map (whiskerRight φ (forget _))).Compatible := by\n  intro Y₁ Y₂ Z g₁ g₂ f₁ f₂ h₁ h₂ fac\n  let a₁ := r₀ f₁ h₁\n  let b₁ := m₀ f₁ h₁\n  let a₂ := r₀ f₂ h₂\n  let b₂ := m₀ f₂ h₂\n  let a₀ := R₀.map g₁.op a₁\n  let b₀ := M₀.map g₁.op b₁\n  have ha₁ : (α.app (Opposite.op Y₁)) a₁ = (R.map f₁.op) r := (hr₀ f₁ h₁).symm\n  have ha₂ : (α.app (Opposite.op Y₂)) a₂ = (R.map f₂.op) r := (hr₀ f₂ h₂).symm\n  have hb₁ : (φ.app (Opposite.op Y₁)) b₁ = (A.map f₁.op) m := (hm₀ f₁ h₁).symm\n  have hb₂ : (φ.app (Opposite.op Y₂)) b₂ = (A.map f₂.op) m := (hm₀ f₂ h₂).symm\n  have ha₀ : (α.app (Opposite.op Z)) a₀ = (R.map (f₁.op ≫ g₁.op)) r := by\n    dsimp [a₀]\n    rw [← RingCat.comp_apply, NatTrans.naturality, RingCat.comp_apply, ha₁, Functor.map_comp,\n      RingCat.comp_apply]\n  have hb₀ : (φ.app (Opposite.op Z)) b₀ = (A.map (f₁.op ≫ g₁.op)) m := by\n    dsimp [b₀]\n    erw [NatTrans.naturality_apply φ, hb₁, Functor.map_comp, ConcreteCategory.comp_apply]\n    rfl -- `ConcreteCategory`/`HasForget` mismatch workaround\n  have ha₀' : (α.app (Opposite.op Z)) a₀ = (R.map (f₂.op ≫ g₂.op)) r := by\n    rw [ha₀, ← op_comp, fac, op_comp]\n  have hb₀' : (φ.app (Opposite.op Z)) b₀ = (A.map (f₂.op ≫ g₂.op)) m := by\n    rw [hb₀, ← op_comp, fac, op_comp]\n  dsimp\n  erw [← NatTrans.naturality_apply φ, ← NatTrans.naturality_apply φ]\n  exact (isCompatible_map_smul_aux α φ hA r m f₁ g₁ a₁ a₀ b₁ b₀ ha₁ ha₀ hb₁ hb₀).trans\n    (isCompatible_map_smul_aux α φ hA r m f₂ g₂ a₂ a₀ b₂ b₀ ha₂ ha₀' hb₂ hb₀').symm\n\n"}
{"name":"PresheafOfModules.Sheafify.SMulCandidate.mk.sizeOf_spec","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Sheafify","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nR₀ : CategoryTheory.Functor (Opposite C) RingCat\nR : CategoryTheory.Sheaf J RingCat\nα : Quiver.Hom R₀ R.val\nM₀ : PresheafOfModules R₀\nA : CategoryTheory.Sheaf J AddCommGrp\nφ : Quiver.Hom M₀.presheaf A.val\nX : Opposite C\nr : ↑(R.val.obj X)\nm : ↑(A.val.obj X)\ninst✝ : SizeOf C\nx : ↑(A.val.obj X)\nh : ∀ ⦃Y : Opposite C⦄ (f : Quiver.Hom X Y) (r₀ : ↑(R₀.obj Y)), Eq ((CategoryTheory.ConcreteCategory.hom (α.app Y)) r₀) ((CategoryTheory.ConcreteCategory.hom (R.val.map f)) r) → ∀ (m₀ : ↑(M₀.obj Y)), Eq ((CategoryTheory.ConcreteCategory.hom (φ.app Y)) m₀) ((CategoryTheory.ConcreteCategory.hom (A.val.map f)) m) → Eq ((CategoryTheory.ConcreteCategory.hom (A.val.map f)) x) ((CategoryTheory.ConcreteCategory.hom (φ.app Y)) (HSMul.hSMul r₀ m₀))\n⊢ Eq (SizeOf.sizeOf { x := x, h := h }) (HAdd.hAdd 1 (SizeOf.sizeOf x))","decl":"/-- Assuming `α : R₀ ⟶ R.val` is the sheafification map of a presheaf of rings `R₀`\nand `φ : M₀.presheaf ⟶ A.val` is the sheafification map of the underlying\nsheaf of abelian groups of a presheaf of modules `M₀` over `R₀`, then given\n`r : R.val.obj X` and `m : A.val.obj X`, this structure contains the data\nof `x : A.val.obj X` along with the property which makes `x` a good candidate\nfor the definition of the scalar multiplication `r • m`. -/\nstructure SMulCandidate where\n  /-- The candidate for the scalar product `r • m`. -/\n  x : A.val.obj X\n  h ⦃Y : Cᵒᵖ⦄ (f : X ⟶ Y) (r₀ : R₀.obj Y) (hr₀ : α.app Y r₀ = R.val.map f r)\n    (m₀ : M₀.obj Y) (hm₀ : φ.app Y m₀ = A.val.map f m) : A.val.map f x = φ.app Y (r₀ • m₀)\n\n"}
{"name":"PresheafOfModules.Sheafify.SMulCandidate.mk.inj","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Sheafify","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nR₀ : CategoryTheory.Functor (Opposite C) RingCat\nR : CategoryTheory.Sheaf J RingCat\nα : Quiver.Hom R₀ R.val\nM₀ : PresheafOfModules R₀\nA : CategoryTheory.Sheaf J AddCommGrp\nφ : Quiver.Hom M₀.presheaf A.val\nX : Opposite C\nr : ↑(R.val.obj X)\nm x✝¹ : ↑(A.val.obj X)\nh✝ : ∀ ⦃Y : Opposite C⦄ (f : Quiver.Hom X Y) (r₀ : ↑(R₀.obj Y)), Eq ((CategoryTheory.ConcreteCategory.hom (α.app Y)) r₀) ((CategoryTheory.ConcreteCategory.hom (R.val.map f)) r) → ∀ (m₀ : ↑(M₀.obj Y)), Eq ((CategoryTheory.ConcreteCategory.hom (φ.app Y)) m₀) ((CategoryTheory.ConcreteCategory.hom (A.val.map f)) m) → Eq ((CategoryTheory.ConcreteCategory.hom (A.val.map f)) x✝¹) ((CategoryTheory.ConcreteCategory.hom (φ.app Y)) (HSMul.hSMul r₀ m₀))\nx : ↑(A.val.obj X)\nh : ∀ ⦃Y : Opposite C⦄ (f : Quiver.Hom X Y) (r₀ : ↑(R₀.obj Y)), Eq ((CategoryTheory.ConcreteCategory.hom (α.app Y)) r₀) ((CategoryTheory.ConcreteCategory.hom (R.val.map f)) r) → ∀ (m₀ : ↑(M₀.obj Y)), Eq ((CategoryTheory.ConcreteCategory.hom (φ.app Y)) m₀) ((CategoryTheory.ConcreteCategory.hom (A.val.map f)) m) → Eq ((CategoryTheory.ConcreteCategory.hom (A.val.map f)) x) ((CategoryTheory.ConcreteCategory.hom (φ.app Y)) (HSMul.hSMul r₀ m₀))\nx✝ : Eq { x := x✝¹, h := h✝ } { x := x, h := h }\n⊢ Eq x✝¹ x","decl":"/-- Assuming `α : R₀ ⟶ R.val` is the sheafification map of a presheaf of rings `R₀`\nand `φ : M₀.presheaf ⟶ A.val` is the sheafification map of the underlying\nsheaf of abelian groups of a presheaf of modules `M₀` over `R₀`, then given\n`r : R.val.obj X` and `m : A.val.obj X`, this structure contains the data\nof `x : A.val.obj X` along with the property which makes `x` a good candidate\nfor the definition of the scalar multiplication `r • m`. -/\nstructure SMulCandidate where\n  /-- The candidate for the scalar product `r • m`. -/\n  x : A.val.obj X\n  h ⦃Y : Cᵒᵖ⦄ (f : X ⟶ Y) (r₀ : R₀.obj Y) (hr₀ : α.app Y r₀ = R.val.map f r)\n    (m₀ : M₀.obj Y) (hm₀ : φ.app Y m₀ = A.val.map f m) : A.val.map f x = φ.app Y (r₀ • m₀)\n\n"}
{"name":"PresheafOfModules.Sheafify.SMulCandidate.mk.injEq","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Sheafify","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nR₀ : CategoryTheory.Functor (Opposite C) RingCat\nR : CategoryTheory.Sheaf J RingCat\nα : Quiver.Hom R₀ R.val\nM₀ : PresheafOfModules R₀\nA : CategoryTheory.Sheaf J AddCommGrp\nφ : Quiver.Hom M₀.presheaf A.val\nX : Opposite C\nr : ↑(R.val.obj X)\nm x✝ : ↑(A.val.obj X)\nh✝ : ∀ ⦃Y : Opposite C⦄ (f : Quiver.Hom X Y) (r₀ : ↑(R₀.obj Y)), Eq ((CategoryTheory.ConcreteCategory.hom (α.app Y)) r₀) ((CategoryTheory.ConcreteCategory.hom (R.val.map f)) r) → ∀ (m₀ : ↑(M₀.obj Y)), Eq ((CategoryTheory.ConcreteCategory.hom (φ.app Y)) m₀) ((CategoryTheory.ConcreteCategory.hom (A.val.map f)) m) → Eq ((CategoryTheory.ConcreteCategory.hom (A.val.map f)) x✝) ((CategoryTheory.ConcreteCategory.hom (φ.app Y)) (HSMul.hSMul r₀ m₀))\nx : ↑(A.val.obj X)\nh : ∀ ⦃Y : Opposite C⦄ (f : Quiver.Hom X Y) (r₀ : ↑(R₀.obj Y)), Eq ((CategoryTheory.ConcreteCategory.hom (α.app Y)) r₀) ((CategoryTheory.ConcreteCategory.hom (R.val.map f)) r) → ∀ (m₀ : ↑(M₀.obj Y)), Eq ((CategoryTheory.ConcreteCategory.hom (φ.app Y)) m₀) ((CategoryTheory.ConcreteCategory.hom (A.val.map f)) m) → Eq ((CategoryTheory.ConcreteCategory.hom (A.val.map f)) x) ((CategoryTheory.ConcreteCategory.hom (φ.app Y)) (HSMul.hSMul r₀ m₀))\n⊢ Eq (Eq { x := x✝, h := h✝ } { x := x, h := h }) (Eq x✝ x)","decl":"/-- Assuming `α : R₀ ⟶ R.val` is the sheafification map of a presheaf of rings `R₀`\nand `φ : M₀.presheaf ⟶ A.val` is the sheafification map of the underlying\nsheaf of abelian groups of a presheaf of modules `M₀` over `R₀`, then given\n`r : R.val.obj X` and `m : A.val.obj X`, this structure contains the data\nof `x : A.val.obj X` along with the property which makes `x` a good candidate\nfor the definition of the scalar multiplication `r • m`. -/\nstructure SMulCandidate where\n  /-- The candidate for the scalar product `r • m`. -/\n  x : A.val.obj X\n  h ⦃Y : Cᵒᵖ⦄ (f : X ⟶ Y) (r₀ : R₀.obj Y) (hr₀ : α.app Y r₀ = R.val.map f r)\n    (m₀ : M₀.obj Y) (hm₀ : φ.app Y m₀ = A.val.map f m) : A.val.map f x = φ.app Y (r₀ • m₀)\n\n"}
{"name":"PresheafOfModules.Sheafify.SMulCandidate.h","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Sheafify","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nR₀ : CategoryTheory.Functor (Opposite C) RingCat\nR : CategoryTheory.Sheaf J RingCat\nα : Quiver.Hom R₀ R.val\nM₀ : PresheafOfModules R₀\nA : CategoryTheory.Sheaf J AddCommGrp\nφ : Quiver.Hom M₀.presheaf A.val\nX : Opposite C\nr : ↑(R.val.obj X)\nm : ↑(A.val.obj X)\nself : PresheafOfModules.Sheafify.SMulCandidate α φ r m\nY : Opposite C\nf : Quiver.Hom X Y\nr₀ : ↑(R₀.obj Y)\nhr₀ : Eq ((CategoryTheory.ConcreteCategory.hom (α.app Y)) r₀) ((CategoryTheory.ConcreteCategory.hom (R.val.map f)) r)\nm₀ : ↑(M₀.obj Y)\nhm₀ : Eq ((CategoryTheory.ConcreteCategory.hom (φ.app Y)) m₀) ((CategoryTheory.ConcreteCategory.hom (A.val.map f)) m)\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom (A.val.map f)) self.x) ((CategoryTheory.ConcreteCategory.hom (φ.app Y)) (HSMul.hSMul r₀ m₀))","decl":"/-- Assuming `α : R₀ ⟶ R.val` is the sheafification map of a presheaf of rings `R₀`\nand `φ : M₀.presheaf ⟶ A.val` is the sheafification map of the underlying\nsheaf of abelian groups of a presheaf of modules `M₀` over `R₀`, then given\n`r : R.val.obj X` and `m : A.val.obj X`, this structure contains the data\nof `x : A.val.obj X` along with the property which makes `x` a good candidate\nfor the definition of the scalar multiplication `r • m`. -/\nstructure SMulCandidate where\n  /-- The candidate for the scalar product `r • m`. -/\n  x : A.val.obj X\n  h ⦃Y : Cᵒᵖ⦄ (f : X ⟶ Y) (r₀ : R₀.obj Y) (hr₀ : α.app Y r₀ = R.val.map f r)\n    (m₀ : M₀.obj Y) (hm₀ : φ.app Y m₀ = A.val.map f m) : A.val.map f x = φ.app Y (r₀ • m₀)\n\n"}
{"name":"PresheafOfModules.Sheafify.instNonemptySMulCandidate","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Sheafify","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nR₀ : CategoryTheory.Functor (Opposite C) RingCat\nR : CategoryTheory.Sheaf J RingCat\nα : Quiver.Hom R₀ R.val\ninst✝³ : CategoryTheory.Presheaf.IsLocallyInjective J α\ninst✝² : CategoryTheory.Presheaf.IsLocallySurjective J α\nM₀ : PresheafOfModules R₀\nA : CategoryTheory.Sheaf J AddCommGrp\nφ : Quiver.Hom M₀.presheaf A.val\ninst✝¹ : CategoryTheory.Presheaf.IsLocallyInjective J φ\ninst✝ : CategoryTheory.Presheaf.IsLocallySurjective J φ\nX : Opposite C\nr : ↑(R.val.obj X)\nm : ↑(A.val.obj X)\n⊢ Nonempty (PresheafOfModules.Sheafify.SMulCandidate α φ r m)","decl":"instance : Nonempty (SMulCandidate α φ r m) := ⟨by\n  let S := (Presheaf.imageSieve α r ⊓ Presheaf.imageSieve φ m)\n  have hS : S ∈ J _ := by\n    apply J.intersection_covering\n    all_goals apply Presheaf.imageSieve_mem\n  have h₁ : S ≤ Presheaf.imageSieve α r := fun _ _ h => h.1\n  have h₂ : S ≤ Presheaf.imageSieve φ m := fun _ _ h => h.2\n  let r₀ := (Presieve.FamilyOfElements.localPreimage (whiskerRight α (forget _)) r).restrict h₁\n  let m₀ := (Presieve.FamilyOfElements.localPreimage (whiskerRight φ (forget _)) m).restrict h₂\n  have hr₀ : (r₀.map (whiskerRight α (forget _))).IsAmalgamation r := by\n    rw [Presieve.FamilyOfElements.restrict_map]\n    apply Presieve.isAmalgamation_restrict\n    apply Presieve.FamilyOfElements.isAmalgamation_map_localPreimage\n  have hm₀ : (m₀.map (whiskerRight φ (forget _))).IsAmalgamation m := by\n    rw [Presieve.FamilyOfElements.restrict_map]\n    apply Presieve.isAmalgamation_restrict\n    apply Presieve.FamilyOfElements.isAmalgamation_map_localPreimage\n  exact SMulCandidate.mk' α φ r m S hS r₀ m₀ hr₀ hm₀ _ (Presieve.IsSheafFor.isAmalgamation\n    (((sheafCompose J (forget _)).obj A).2.isSheafFor S hS)\n    (Presieve.FamilyOfElements.isCompatible_map_smul α φ A.isSeparated r m r₀ m₀ hr₀ hm₀))⟩\n\n"}
{"name":"PresheafOfModules.Sheafify.instSubsingletonSMulCandidate","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Sheafify","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nR₀ : CategoryTheory.Functor (Opposite C) RingCat\nR : CategoryTheory.Sheaf J RingCat\nα : Quiver.Hom R₀ R.val\nM₀ : PresheafOfModules R₀\nA : CategoryTheory.Sheaf J AddCommGrp\nφ : Quiver.Hom M₀.presheaf A.val\nX : Opposite C\nr : ↑(R.val.obj X)\nm : ↑(A.val.obj X)\n⊢ Subsingleton (PresheafOfModules.Sheafify.SMulCandidate α φ r m)","decl":"instance : Subsingleton (SMulCandidate α φ r m) where\n  allEq := by\n    rintro ⟨x₁, h₁⟩ ⟨x₂, h₂⟩\n    simp only [SMulCandidate.mk.injEq]\n    let S := (Presheaf.imageSieve α r ⊓ Presheaf.imageSieve φ m)\n    have hS : S ∈ J _ := by\n      apply J.intersection_covering\n      all_goals apply Presheaf.imageSieve_mem\n    apply A.isSeparated _ _ hS\n    intro Y f ⟨⟨r₀, hr₀⟩, ⟨m₀, hm₀⟩⟩\n    show A.val.map f.op _ = A.val.map f.op _ -- `ConcreteCategory`/`HasForget` mismatch workaround\n    rw [h₁ f.op r₀ hr₀ m₀ hm₀, h₂ f.op r₀ hr₀ m₀ hm₀]\n\n"}
{"name":"PresheafOfModules.Sheafify.map_smul_eq","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Sheafify","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nR₀ : CategoryTheory.Functor (Opposite C) RingCat\nR : CategoryTheory.Sheaf J RingCat\nα : Quiver.Hom R₀ R.val\ninst✝³ : CategoryTheory.Presheaf.IsLocallyInjective J α\ninst✝² : CategoryTheory.Presheaf.IsLocallySurjective J α\nM₀ : PresheafOfModules R₀\nA : CategoryTheory.Sheaf J AddCommGrp\nφ : Quiver.Hom M₀.presheaf A.val\ninst✝¹ : CategoryTheory.Presheaf.IsLocallyInjective J φ\ninst✝ : CategoryTheory.Presheaf.IsLocallySurjective J φ\nX : Opposite C\nr : ↑(R.val.obj X)\nm : ↑(A.val.obj X)\nY : Opposite C\nf : Quiver.Hom X Y\nr₀ : ↑(R₀.obj Y)\nhr₀ : Eq ((CategoryTheory.ConcreteCategory.hom (α.app Y)) r₀) ((CategoryTheory.ConcreteCategory.hom (R.val.map f)) r)\nm₀ : ↑(M₀.obj Y)\nhm₀ : Eq ((CategoryTheory.ConcreteCategory.hom (φ.app Y)) m₀) ((CategoryTheory.ConcreteCategory.hom (A.val.map f)) m)\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom (A.val.map f)) (PresheafOfModules.Sheafify.smul α φ r m)) ((CategoryTheory.ConcreteCategory.hom (φ.app Y)) (HSMul.hSMul r₀ m₀))","decl":"lemma map_smul_eq {Y : Cᵒᵖ} (f : X ⟶ Y) (r₀ : R₀.obj Y) (hr₀ : α.app Y r₀ = R.val.map f r)\n    (m₀ : M₀.obj Y) (hm₀ : φ.app Y m₀ = A.val.map f m) :\n    A.val.map f (smul α φ r m) = φ.app Y (r₀ • m₀) :=\n  (smulCandidate α φ r m).h f r₀ hr₀ m₀ hm₀\n\n"}
{"name":"PresheafOfModules.Sheafify.one_smul","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Sheafify","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nR₀ : CategoryTheory.Functor (Opposite C) RingCat\nR : CategoryTheory.Sheaf J RingCat\nα : Quiver.Hom R₀ R.val\ninst✝³ : CategoryTheory.Presheaf.IsLocallyInjective J α\ninst✝² : CategoryTheory.Presheaf.IsLocallySurjective J α\nM₀ : PresheafOfModules R₀\nA : CategoryTheory.Sheaf J AddCommGrp\nφ : Quiver.Hom M₀.presheaf A.val\ninst✝¹ : CategoryTheory.Presheaf.IsLocallyInjective J φ\ninst✝ : CategoryTheory.Presheaf.IsLocallySurjective J φ\nX : Opposite C\nm : ↑(A.val.obj X)\n⊢ Eq (PresheafOfModules.Sheafify.smul α φ 1 m) m","decl":"protected lemma one_smul : smul α φ 1 m = m := by\n  apply A.isSeparated _ _ (Presheaf.imageSieve_mem J φ m)\n  rintro Y f ⟨m₀, hm₀⟩\n  show A.val.map f.op _ = _ -- `ConcreteCategory`/`HasForget` mismatch workaround\n  rw [← hm₀, map_smul_eq α φ 1 m f.op 1 (by simp) m₀ hm₀, one_smul]\n  rfl -- `ConcreteCategory`/`HasForget` mismatch workaround\n\n"}
{"name":"PresheafOfModules.Sheafify.zero_smul","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Sheafify","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nR₀ : CategoryTheory.Functor (Opposite C) RingCat\nR : CategoryTheory.Sheaf J RingCat\nα : Quiver.Hom R₀ R.val\ninst✝³ : CategoryTheory.Presheaf.IsLocallyInjective J α\ninst✝² : CategoryTheory.Presheaf.IsLocallySurjective J α\nM₀ : PresheafOfModules R₀\nA : CategoryTheory.Sheaf J AddCommGrp\nφ : Quiver.Hom M₀.presheaf A.val\ninst✝¹ : CategoryTheory.Presheaf.IsLocallyInjective J φ\ninst✝ : CategoryTheory.Presheaf.IsLocallySurjective J φ\nX : Opposite C\nm : ↑(A.val.obj X)\n⊢ Eq (PresheafOfModules.Sheafify.smul α φ 0 m) 0","decl":"protected lemma zero_smul : smul α φ 0 m = 0 := by\n  apply A.isSeparated _ _ (Presheaf.imageSieve_mem J φ m)\n  rintro Y f ⟨m₀, hm₀⟩\n  show A.val.map f.op _ = A.val.map f.op _ -- `ConcreteCategory`/`HasForget` mismatch workaround\n  rw [map_smul_eq α φ 0 m f.op 0 (by simp) m₀ hm₀, zero_smul, map_zero,\n    (A.val.map f.op).hom.map_zero]\n\n"}
{"name":"PresheafOfModules.Sheafify.smul_zero","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Sheafify","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nR₀ : CategoryTheory.Functor (Opposite C) RingCat\nR : CategoryTheory.Sheaf J RingCat\nα : Quiver.Hom R₀ R.val\ninst✝³ : CategoryTheory.Presheaf.IsLocallyInjective J α\ninst✝² : CategoryTheory.Presheaf.IsLocallySurjective J α\nM₀ : PresheafOfModules R₀\nA : CategoryTheory.Sheaf J AddCommGrp\nφ : Quiver.Hom M₀.presheaf A.val\ninst✝¹ : CategoryTheory.Presheaf.IsLocallyInjective J φ\ninst✝ : CategoryTheory.Presheaf.IsLocallySurjective J φ\nX : Opposite C\nr : ↑(R.val.obj X)\n⊢ Eq (PresheafOfModules.Sheafify.smul α φ r 0) 0","decl":"protected lemma smul_zero : smul α φ r 0 = 0 := by\n  apply A.isSeparated _ _ (Presheaf.imageSieve_mem J α r)\n  rintro Y f ⟨r₀, hr₀⟩\n  show A.val.map f.op _ = A.val.map f.op _ -- `ConcreteCategory`/`HasForget` mismatch workaround\n  rw [(A.val.map f.op).hom.map_zero, map_smul_eq α φ r 0 f.op r₀ hr₀ 0 (by simp),\n    smul_zero, map_zero]\n\n"}
{"name":"PresheafOfModules.Sheafify.smul_add","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Sheafify","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nR₀ : CategoryTheory.Functor (Opposite C) RingCat\nR : CategoryTheory.Sheaf J RingCat\nα : Quiver.Hom R₀ R.val\ninst✝³ : CategoryTheory.Presheaf.IsLocallyInjective J α\ninst✝² : CategoryTheory.Presheaf.IsLocallySurjective J α\nM₀ : PresheafOfModules R₀\nA : CategoryTheory.Sheaf J AddCommGrp\nφ : Quiver.Hom M₀.presheaf A.val\ninst✝¹ : CategoryTheory.Presheaf.IsLocallyInjective J φ\ninst✝ : CategoryTheory.Presheaf.IsLocallySurjective J φ\nX : Opposite C\nr : ↑(R.val.obj X)\nm m' : ↑(A.val.obj X)\n⊢ Eq (PresheafOfModules.Sheafify.smul α φ r (HAdd.hAdd m m')) (HAdd.hAdd (PresheafOfModules.Sheafify.smul α φ r m) (PresheafOfModules.Sheafify.smul α φ r m'))","decl":"protected lemma smul_add : smul α φ r (m + m') = smul α φ r m + smul α φ r m' := by\n  let S := Presheaf.imageSieve α r ⊓ Presheaf.imageSieve φ m ⊓ Presheaf.imageSieve φ m'\n  have hS : S ∈ J X.unop := by\n    refine J.intersection_covering (J.intersection_covering ?_ ?_) ?_\n    all_goals apply Presheaf.imageSieve_mem\n  apply A.isSeparated _ _ hS\n  rintro Y f ⟨⟨⟨r₀, hr₀⟩, ⟨m₀ : M₀.obj _, hm₀ : (φ.app _) _ = _⟩⟩,\n    ⟨m₀' : M₀.obj _, hm₀' : (φ.app _) _ = _⟩⟩\n  show A.val.map f.op _ = A.val.map f.op _ -- `ConcreteCategory`/`HasForget` mismatch workaround\n  rw [(A.val.map f.op).hom.map_add, map_smul_eq α φ r m f.op r₀ hr₀ m₀ hm₀,\n    map_smul_eq α φ r m' f.op r₀ hr₀ m₀' hm₀',\n    map_smul_eq α φ r (m + m') f.op r₀ hr₀ (m₀ + m₀')\n      (by rw [map_add, map_add, hm₀, hm₀']; rfl),\n    smul_add, map_add]\n\n"}
{"name":"PresheafOfModules.Sheafify.add_smul","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Sheafify","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nR₀ : CategoryTheory.Functor (Opposite C) RingCat\nR : CategoryTheory.Sheaf J RingCat\nα : Quiver.Hom R₀ R.val\ninst✝³ : CategoryTheory.Presheaf.IsLocallyInjective J α\ninst✝² : CategoryTheory.Presheaf.IsLocallySurjective J α\nM₀ : PresheafOfModules R₀\nA : CategoryTheory.Sheaf J AddCommGrp\nφ : Quiver.Hom M₀.presheaf A.val\ninst✝¹ : CategoryTheory.Presheaf.IsLocallyInjective J φ\ninst✝ : CategoryTheory.Presheaf.IsLocallySurjective J φ\nX : Opposite C\nr r' : ↑(R.val.obj X)\nm : ↑(A.val.obj X)\n⊢ Eq (PresheafOfModules.Sheafify.smul α φ (HAdd.hAdd r r') m) (HAdd.hAdd (PresheafOfModules.Sheafify.smul α φ r m) (PresheafOfModules.Sheafify.smul α φ r' m))","decl":"protected lemma add_smul : smul α φ (r + r') m = smul α φ r m + smul α φ r' m := by\n  let S := Presheaf.imageSieve α r ⊓ Presheaf.imageSieve α r' ⊓ Presheaf.imageSieve φ m\n  have hS : S ∈ J X.unop := by\n    refine J.intersection_covering (J.intersection_covering ?_ ?_) ?_\n    all_goals apply Presheaf.imageSieve_mem\n  apply A.isSeparated _ _ hS\n  rintro Y f ⟨⟨⟨r₀ : R₀.obj _, (hr₀ : (α.app (Opposite.op Y)) r₀ = (R.val.map f.op) r)⟩,\n    ⟨r₀' : R₀.obj _, (hr₀' : (α.app (Opposite.op Y)) r₀' = (R.val.map f.op) r')⟩⟩, ⟨m₀, hm₀⟩⟩\n  show A.val.map f.op _ = A.val.map f.op _ -- `ConcreteCategory`/`HasForget` mismatch workaround\n  rw [(A.val.map f.op).hom.map_add, map_smul_eq α φ r m f.op r₀ hr₀ m₀ hm₀,\n    map_smul_eq α φ r' m f.op r₀' hr₀' m₀ hm₀,\n    map_smul_eq α φ (r + r') m f.op (r₀ + r₀') (by rw [map_add, map_add, hr₀, hr₀'])\n      m₀ hm₀, add_smul, map_add]\n\n"}
{"name":"PresheafOfModules.Sheafify.mul_smul","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Sheafify","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nR₀ : CategoryTheory.Functor (Opposite C) RingCat\nR : CategoryTheory.Sheaf J RingCat\nα : Quiver.Hom R₀ R.val\ninst✝³ : CategoryTheory.Presheaf.IsLocallyInjective J α\ninst✝² : CategoryTheory.Presheaf.IsLocallySurjective J α\nM₀ : PresheafOfModules R₀\nA : CategoryTheory.Sheaf J AddCommGrp\nφ : Quiver.Hom M₀.presheaf A.val\ninst✝¹ : CategoryTheory.Presheaf.IsLocallyInjective J φ\ninst✝ : CategoryTheory.Presheaf.IsLocallySurjective J φ\nX : Opposite C\nr r' : ↑(R.val.obj X)\nm : ↑(A.val.obj X)\n⊢ Eq (PresheafOfModules.Sheafify.smul α φ (HMul.hMul r r') m) (PresheafOfModules.Sheafify.smul α φ r (PresheafOfModules.Sheafify.smul α φ r' m))","decl":"protected lemma mul_smul : smul α φ (r * r') m = smul α φ r (smul α φ r' m) := by\n  let S := Presheaf.imageSieve α r ⊓ Presheaf.imageSieve α r' ⊓ Presheaf.imageSieve φ m\n  have hS : S ∈ J X.unop := by\n    refine J.intersection_covering (J.intersection_covering ?_ ?_) ?_\n    all_goals apply Presheaf.imageSieve_mem\n  apply A.isSeparated _ _ hS\n  rintro Y f ⟨⟨⟨r₀ : R₀.obj _, (hr₀ : (α.app (Opposite.op Y)) r₀ = (R.val.map f.op) r)⟩,\n    ⟨r₀' : R₀.obj _, (hr₀' : (α.app (Opposite.op Y)) r₀' = (R.val.map f.op) r')⟩⟩,\n    ⟨m₀ : M₀.obj _, hm₀⟩⟩\n  show A.val.map f.op _ = A.val.map f.op _ -- `ConcreteCategory`/`HasForget` mismatch workaround\n  rw [map_smul_eq α φ (r * r') m f.op (r₀ * r₀')\n    (by rw [map_mul, map_mul, hr₀, hr₀']) m₀ hm₀, mul_smul,\n    map_smul_eq α φ r (smul α φ r' m) f.op r₀ hr₀ (r₀' • m₀)\n      (map_smul_eq α φ r' m f.op r₀' hr₀' m₀ hm₀).symm]\n\n"}
{"name":"PresheafOfModules.Sheafify.map_smul","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Sheafify","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nR₀ : CategoryTheory.Functor (Opposite C) RingCat\nR : CategoryTheory.Sheaf J RingCat\nα : Quiver.Hom R₀ R.val\ninst✝³ : CategoryTheory.Presheaf.IsLocallyInjective J α\ninst✝² : CategoryTheory.Presheaf.IsLocallySurjective J α\nM₀ : PresheafOfModules R₀\nA : CategoryTheory.Sheaf J AddCommGrp\nφ : Quiver.Hom M₀.presheaf A.val\ninst✝¹ : CategoryTheory.Presheaf.IsLocallyInjective J φ\ninst✝ : CategoryTheory.Presheaf.IsLocallySurjective J φ\nX Y : Opposite C\nπ : Quiver.Hom X Y\nr : ↑(R.val.obj X)\nm : ↑(A.val.obj X)\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom (A.val.map π)) (PresheafOfModules.Sheafify.smul α φ r m)) (PresheafOfModules.Sheafify.smul α φ ((CategoryTheory.ConcreteCategory.hom (R.val.map π)) r) ((CategoryTheory.ConcreteCategory.hom (A.val.map π)) m))","decl":"lemma map_smul :\n    A.val.map π (smul α φ r m) = smul α φ (R.val.map π r) (A.val.map π m) := by\n  let S := Presheaf.imageSieve α (R.val.map π r) ⊓ Presheaf.imageSieve φ (A.val.map π m)\n  have hS : S ∈ J Y.unop := by\n    apply J.intersection_covering\n    all_goals apply Presheaf.imageSieve_mem\n  apply A.isSeparated _ _ hS\n  rintro Y f ⟨⟨r₀,\n    (hr₀ : (α.app (Opposite.op Y)).hom r₀ = (R.val.map f.op).hom ((R.val.map π).hom r))⟩,\n    ⟨m₀, (hm₀ : (φ.app _) _ = _)⟩⟩\n  show A.val.map f.op _ = A.val.map f.op _ -- `ConcreteCategory`/`HasForget` mismatch workaround\n  rw [← ConcreteCategory.comp_apply, ← Functor.map_comp,\n    map_smul_eq α φ r m (π ≫ f.op) r₀ (by rw [hr₀, Functor.map_comp, RingCat.comp_apply]) m₀\n      (by rw [hm₀, Functor.map_comp, ConcreteCategory.comp_apply]; rfl),\n    map_smul_eq α φ (R.val.map π r) (A.val.map π m) f.op r₀ hr₀ m₀ hm₀]\n\n"}
{"name":"PresheafOfModules.toSheafify_app_apply","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Sheafify","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nR₀ : CategoryTheory.Functor (Opposite C) RingCat\nR : CategoryTheory.Sheaf J RingCat\nα : Quiver.Hom R₀ R.val\ninst✝³ : CategoryTheory.Presheaf.IsLocallyInjective J α\ninst✝² : CategoryTheory.Presheaf.IsLocallySurjective J α\nM₀ : PresheafOfModules R₀\nA : CategoryTheory.Sheaf J AddCommGrp\nφ : Quiver.Hom M₀.presheaf A.val\ninst✝¹ : CategoryTheory.Presheaf.IsLocallyInjective J φ\ninst✝ : CategoryTheory.Presheaf.IsLocallySurjective J φ\nX : Opposite C\nx : ↑(M₀.obj X)\n⊢ Eq ((ModuleCat.Hom.hom ((PresheafOfModules.toSheafify α φ).app X)) x) ((CategoryTheory.ConcreteCategory.hom (φ.app X)) x)","decl":"lemma toSheafify_app_apply (X : Cᵒᵖ) (x : M₀.obj X) :\n    ((toSheafify α φ).app X).hom x = φ.app X x := rfl\n\n"}
{"name":"PresheafOfModules.toSheafify_app_apply'","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Sheafify","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nR₀ : CategoryTheory.Functor (Opposite C) RingCat\nR : CategoryTheory.Sheaf J RingCat\nα : Quiver.Hom R₀ R.val\ninst✝³ : CategoryTheory.Presheaf.IsLocallyInjective J α\ninst✝² : CategoryTheory.Presheaf.IsLocallySurjective J α\nM₀ : PresheafOfModules R₀\nA : CategoryTheory.Sheaf J AddCommGrp\nφ : Quiver.Hom M₀.presheaf A.val\ninst✝¹ : CategoryTheory.Presheaf.IsLocallyInjective J φ\ninst✝ : CategoryTheory.Presheaf.IsLocallySurjective J φ\nX : Opposite C\nx : ↑(M₀.obj X)\n⊢ Eq ((ModuleCat.Hom.hom ((PresheafOfModules.toSheafify α φ).app X)) x) ((CategoryTheory.ConcreteCategory.hom (φ.app X)) x)","decl":"/-- `@[simp]`-normal form of `toSheafify_app_apply`. -/\n@[simp]\nlemma toSheafify_app_apply' (X : Cᵒᵖ) (x : M₀.obj X) :\n    DFunLike.coe (F := (_ →ₗ[_] ↑((ModuleCat.restrictScalars (α.app X).hom).obj _)))\n    ((toSheafify α φ).app X).hom x = φ.app X x := rfl\n\n"}
{"name":"PresheafOfModules.toPresheaf_map_toSheafify","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Sheafify","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nR₀ : CategoryTheory.Functor (Opposite C) RingCat\nR : CategoryTheory.Sheaf J RingCat\nα : Quiver.Hom R₀ R.val\ninst✝³ : CategoryTheory.Presheaf.IsLocallyInjective J α\ninst✝² : CategoryTheory.Presheaf.IsLocallySurjective J α\nM₀ : PresheafOfModules R₀\nA : CategoryTheory.Sheaf J AddCommGrp\nφ : Quiver.Hom M₀.presheaf A.val\ninst✝¹ : CategoryTheory.Presheaf.IsLocallyInjective J φ\ninst✝ : CategoryTheory.Presheaf.IsLocallySurjective J φ\n⊢ Eq ((PresheafOfModules.toPresheaf R₀).map (PresheafOfModules.toSheafify α φ)) φ","decl":"@[simp]\nlemma toPresheaf_map_toSheafify : (toPresheaf R₀).map (toSheafify α φ) = φ := rfl\n\n"}
{"name":"PresheafOfModules.instIsLocallyInjectiveToSheafify","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Sheafify","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nR₀ : CategoryTheory.Functor (Opposite C) RingCat\nR : CategoryTheory.Sheaf J RingCat\nα : Quiver.Hom R₀ R.val\ninst✝³ : CategoryTheory.Presheaf.IsLocallyInjective J α\ninst✝² : CategoryTheory.Presheaf.IsLocallySurjective J α\nM₀ : PresheafOfModules R₀\nA : CategoryTheory.Sheaf J AddCommGrp\nφ : Quiver.Hom M₀.presheaf A.val\ninst✝¹ : CategoryTheory.Presheaf.IsLocallyInjective J φ\ninst✝ : CategoryTheory.Presheaf.IsLocallySurjective J φ\n⊢ PresheafOfModules.IsLocallyInjective J (PresheafOfModules.toSheafify α φ)","decl":"instance : IsLocallyInjective J (toSheafify α φ) := by\n  dsimp [IsLocallyInjective]; infer_instance\n\n"}
{"name":"PresheafOfModules.instIsLocallySurjectiveToSheafify","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Sheafify","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nR₀ : CategoryTheory.Functor (Opposite C) RingCat\nR : CategoryTheory.Sheaf J RingCat\nα : Quiver.Hom R₀ R.val\ninst✝³ : CategoryTheory.Presheaf.IsLocallyInjective J α\ninst✝² : CategoryTheory.Presheaf.IsLocallySurjective J α\nM₀ : PresheafOfModules R₀\nA : CategoryTheory.Sheaf J AddCommGrp\nφ : Quiver.Hom M₀.presheaf A.val\ninst✝¹ : CategoryTheory.Presheaf.IsLocallyInjective J φ\ninst✝ : CategoryTheory.Presheaf.IsLocallySurjective J φ\n⊢ PresheafOfModules.IsLocallySurjective J (PresheafOfModules.toSheafify α φ)","decl":"instance : IsLocallySurjective J (toSheafify α φ) := by\n  dsimp [IsLocallySurjective]; infer_instance\n\n"}
{"name":"PresheafOfModules.comp_toPresheaf_map_sheafifyHomEquiv'_symm_hom","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Sheafify","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nR₀ : CategoryTheory.Functor (Opposite C) RingCat\nR : CategoryTheory.Sheaf J RingCat\nα : Quiver.Hom R₀ R.val\ninst✝⁴ : CategoryTheory.Presheaf.IsLocallyInjective J α\ninst✝³ : CategoryTheory.Presheaf.IsLocallySurjective J α\nM₀ : PresheafOfModules R₀\nA : CategoryTheory.Sheaf J AddCommGrp\nφ : Quiver.Hom M₀.presheaf A.val\ninst✝² : CategoryTheory.Presheaf.IsLocallyInjective J φ\ninst✝¹ : CategoryTheory.Presheaf.IsLocallySurjective J φ\ninst✝ : J.WEqualsLocallyBijective AddCommGrp\nF : PresheafOfModules R.val\nhF : CategoryTheory.Presheaf.IsSheaf J F.presheaf\nf : Quiver.Hom M₀ ((PresheafOfModules.restrictScalars α).obj F)\n⊢ Eq (CategoryTheory.CategoryStruct.comp φ ((PresheafOfModules.toPresheaf R.val).map ((PresheafOfModules.sheafifyHomEquiv' α φ hF).symm f))) ((PresheafOfModules.toPresheaf R₀).map f)","decl":"lemma comp_toPresheaf_map_sheafifyHomEquiv'_symm_hom {F : PresheafOfModules.{v} R.val}\n    (hF : Presheaf.IsSheaf J F.presheaf) (f : M₀ ⟶ (restrictScalars α).obj F) :\n    φ ≫ (toPresheaf R.val).map ((sheafifyHomEquiv' α φ hF).symm f) = (toPresheaf R₀).map f :=\n  (toPresheaf _).congr_map ((sheafifyHomEquiv' α φ hF).apply_symm_apply f)\n\n"}
{"name":"PresheafOfModules.sheafifyMap_val","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Sheafify","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nR₀ : CategoryTheory.Functor (Opposite C) RingCat\nR : CategoryTheory.Sheaf J RingCat\nα : Quiver.Hom R₀ R.val\ninst✝⁵ : CategoryTheory.Presheaf.IsLocallyInjective J α\ninst✝⁴ : CategoryTheory.Presheaf.IsLocallySurjective J α\nM₀ : PresheafOfModules R₀\nA : CategoryTheory.Sheaf J AddCommGrp\nφ : Quiver.Hom M₀.presheaf A.val\ninst✝³ : CategoryTheory.Presheaf.IsLocallyInjective J φ\ninst✝² : CategoryTheory.Presheaf.IsLocallySurjective J φ\nM₀' : PresheafOfModules R₀\nA' : CategoryTheory.Sheaf J AddCommGrp\nφ' : Quiver.Hom M₀'.presheaf A'.val\ninst✝¹ : CategoryTheory.Presheaf.IsLocallyInjective J φ'\ninst✝ : CategoryTheory.Presheaf.IsLocallySurjective J φ'\nτ₀ : Quiver.Hom M₀ M₀'\nτ : Quiver.Hom A A'\nfac : Eq (CategoryTheory.CategoryStruct.comp ((PresheafOfModules.toPresheaf R₀).map τ₀) φ') (CategoryTheory.CategoryStruct.comp φ τ.val)\n⊢ Eq (PresheafOfModules.sheafifyMap α φ φ' τ₀ τ fac).val (PresheafOfModules.homMk τ.val ⋯)","decl":"/-- The morphism of sheaves of modules `sheafify α φ ⟶ sheafify α φ'`\ninduced by morphisms `τ₀ : M₀ ⟶ M₀'` and `τ : A ⟶ A'`\nwhich satisfy `τ₀.hom ≫ φ' = φ ≫ τ.val`. -/\n@[simps]\ndef sheafifyMap (fac : (toPresheaf R₀).map τ₀ ≫ φ' = φ ≫ τ.val) :\n    sheafify α φ ⟶ sheafify α φ' where\n  val := homMk τ.val (fun X r m ↦ by\n    let f := (sheafifyHomEquiv' α φ (by exact A'.cond)).symm (τ₀ ≫ toSheafify α φ')\n    suffices τ.val = (toPresheaf _).map f by simpa only [this] using (f.app X).hom.map_smul r m\n    apply ((J.W_of_isLocallyBijective φ).homEquiv _ A'.cond).injective\n    dsimp [f]\n    erw [comp_toPresheaf_map_sheafifyHomEquiv'_symm_hom]\n    rw [← fac, Functor.map_comp, toPresheaf_map_toSheafify])\n\n"}
