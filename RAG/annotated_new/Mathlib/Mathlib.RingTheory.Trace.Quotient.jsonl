{"name":"Algebra.trace_quotient_mk","module":"Mathlib.RingTheory.Trace.Quotient","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing S\ninst✝³ : Algebra R S\ninst✝² : Module.Free R S\ninst✝¹ : Module.Finite R S\ninst✝ : IsLocalRing R\nx : S\n⊢ Eq ((Algebra.trace (HasQuotient.Quotient R (IsLocalRing.maximalIdeal R)) (HasQuotient.Quotient S (Ideal.map (algebraMap R S) (IsLocalRing.maximalIdeal R)))) ((Ideal.Quotient.mk (Ideal.map (algebraMap R S) (IsLocalRing.maximalIdeal R))) x)) ((Ideal.Quotient.mk (IsLocalRing.maximalIdeal R)) ((Algebra.trace R S) x))","decl":"lemma Algebra.trace_quotient_mk [IsLocalRing R] (x : S) :\n    Algebra.trace (R ⧸ p) (S ⧸ pS) (Ideal.Quotient.mk pS x) =\n      Ideal.Quotient.mk p (Algebra.trace R S x) := by\n  classical\n  let ι := Module.Free.ChooseBasisIndex R S\n  let b : Basis ι R S := Module.Free.chooseBasis R S\n  rw [trace_eq_matrix_trace b, trace_eq_matrix_trace (basisQuotient b), AddMonoidHom.map_trace]\n  congr 1\n  ext i j\n  simp only [leftMulMatrix_apply, coe_lmul_eq_mul, LinearMap.toMatrix_apply,\n    basisQuotient_apply, LinearMap.mul_apply', RingHom.toAddMonoidHom_eq_coe,\n    AddMonoidHom.mapMatrix_apply, AddMonoidHom.coe_coe, Matrix.map_apply, ← map_mul,\n    basisQuotient_repr]\n\n"}
{"name":"IsLocalization.AtPrime.map_eq_maximalIdeal","module":"Mathlib.RingTheory.Trace.Quotient","initialProofState":"R : Type u_1\ninst✝⁵ : CommRing R\np : Ideal R\ninst✝⁴ : p.IsMaximal\nRₚ : Type u_3\ninst✝³ : CommRing Rₚ\ninst✝² : Algebra R Rₚ\ninst✝¹ : IsLocalization.AtPrime Rₚ p\ninst✝ : IsLocalRing Rₚ\n⊢ Eq (Ideal.map (algebraMap R Rₚ) p) (IsLocalRing.maximalIdeal Rₚ)","decl":"lemma IsLocalization.AtPrime.map_eq_maximalIdeal :\n    p.map (algebraMap R Rₚ) = maximalIdeal Rₚ := by\n  convert congr_arg (Ideal.map (algebraMap R Rₚ))\n    (IsLocalization.AtPrime.comap_maximalIdeal Rₚ p).symm\n  rw [map_comap p.primeCompl]\n\n"}
{"name":"comap_map_eq_map_of_isLocalization_algebraMapSubmonoid","module":"Mathlib.RingTheory.Trace.Quotient","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁸ : CommRing R\ninst✝⁷ : CommRing S\ninst✝⁶ : Algebra R S\np : Ideal R\ninst✝⁵ : p.IsMaximal\nSₚ : Type u_4\ninst✝⁴ : CommRing Sₚ\ninst✝³ : Algebra S Sₚ\ninst✝² : Algebra R Sₚ\ninst✝¹ : IsLocalization (Algebra.algebraMapSubmonoid S p.primeCompl) Sₚ\ninst✝ : IsScalarTower R S Sₚ\n⊢ Eq (Ideal.comap (algebraMap S Sₚ) (Ideal.map (algebraMap R Sₚ) p)) (Ideal.map (algebraMap R S) p)","decl":"lemma comap_map_eq_map_of_isLocalization_algebraMapSubmonoid :\n    (Ideal.map (algebraMap R Sₚ) p).comap (algebraMap S Sₚ) = pS := by\n  rw [IsScalarTower.algebraMap_eq R S Sₚ, ← Ideal.map_map, eq_comm]\n  apply Ideal.le_comap_map.antisymm\n  intro x hx\n  obtain ⟨α, hα, hαx⟩ : ∃ α ∉ p, α • x ∈ pS := by\n    have ⟨⟨y, s⟩, hy⟩ := (IsLocalization.mem_map_algebraMap_iff\n      (Algebra.algebraMapSubmonoid S p.primeCompl) Sₚ).mp hx\n    rw [← map_mul,\n      IsLocalization.eq_iff_exists (Algebra.algebraMapSubmonoid S p.primeCompl)] at hy\n    obtain ⟨c, hc⟩ := hy\n    obtain ⟨α, hα, e⟩ := (c * s).prop\n    refine ⟨α, hα, ?_⟩\n    rw [Algebra.smul_def, e, Submonoid.coe_mul, mul_assoc, mul_comm _ x, hc]\n    exact Ideal.mul_mem_left _ _ y.prop\n  obtain ⟨β, γ, hγ, hβ⟩ : ∃ β γ, γ ∈ p ∧ β * α = 1 + γ := by\n    obtain ⟨β, hβ⟩ := Ideal.Quotient.mk_surjective (I := p) (Ideal.Quotient.mk p α)⁻¹\n    refine ⟨β, β * α - 1, ?_, ?_⟩\n    · rw [← Ideal.Quotient.eq_zero_iff_mem, map_sub, map_one,\n        map_mul, hβ, inv_mul_cancel₀, sub_self]\n      rwa [Ne, Ideal.Quotient.eq_zero_iff_mem]\n    · rw [add_sub_cancel]\n  have := Ideal.mul_mem_left _ (algebraMap _ _ β) hαx\n  rw [← Algebra.smul_def, smul_smul, hβ, add_smul, one_smul] at this\n  refine (Submodule.add_mem_iff_left _ ?_).mp this\n  rw [Algebra.smul_def]\n  apply Ideal.mul_mem_right\n  exact Ideal.mem_map_of_mem _ hγ\n\n"}
{"name":"trace_quotient_eq_trace_localization_quotient","module":"Mathlib.RingTheory.Trace.Quotient","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹⁴ : CommRing R\ninst✝¹³ : CommRing S\ninst✝¹² : Algebra R S\np : Ideal R\ninst✝¹¹ : p.IsMaximal\nRₚ : Type u_3\nSₚ : Type u_4\ninst✝¹⁰ : CommRing Rₚ\ninst✝⁹ : CommRing Sₚ\ninst✝⁸ : Algebra R Rₚ\ninst✝⁷ : IsLocalization.AtPrime Rₚ p\ninst✝⁶ : IsLocalRing Rₚ\ninst✝⁵ : Algebra S Sₚ\ninst✝⁴ : Algebra R Sₚ\ninst✝³ : Algebra Rₚ Sₚ\ninst✝² : IsLocalization (Algebra.algebraMapSubmonoid S p.primeCompl) Sₚ\ninst✝¹ : IsScalarTower R S Sₚ\ninst✝ : IsScalarTower R Rₚ Sₚ\nx : S\n⊢ Eq ((Algebra.trace (HasQuotient.Quotient R p) (HasQuotient.Quotient S (Ideal.map (algebraMap R S) p))) ((Ideal.Quotient.mk (Ideal.map (algebraMap R S) p)) x)) ((equivQuotMaximalIdealOfIsLocalization p Rₚ).symm ((Algebra.trace (HasQuotient.Quotient Rₚ (IsLocalRing.maximalIdeal Rₚ)) (HasQuotient.Quotient Sₚ (Ideal.map (algebraMap Rₚ Sₚ) (IsLocalRing.maximalIdeal Rₚ)))) ((algebraMap S (HasQuotient.Quotient Sₚ (Ideal.map (algebraMap Rₚ Sₚ) (IsLocalRing.maximalIdeal Rₚ)))) x)))","decl":"lemma trace_quotient_eq_trace_localization_quotient (x) :\n    Algebra.trace (R ⧸ p) (S ⧸ pS) (Ideal.Quotient.mk pS x) =\n      (equivQuotMaximalIdealOfIsLocalization p Rₚ).symm\n        (Algebra.trace (Rₚ ⧸ maximalIdeal Rₚ) (Sₚ ⧸ pSₚ) (algebraMap S _ x)) := by\n  have : IsScalarTower R (Rₚ ⧸ maximalIdeal Rₚ) (Sₚ ⧸ pSₚ) := by\n    apply IsScalarTower.of_algebraMap_eq'\n    rw [IsScalarTower.algebraMap_eq R Rₚ (Rₚ ⧸ _), IsScalarTower.algebraMap_eq R Rₚ (Sₚ ⧸ _),\n      ← RingHom.comp_assoc, ← IsScalarTower.algebraMap_eq Rₚ]\n  rw [Algebra.trace_eq_of_equiv_equiv (equivQuotMaximalIdealOfIsLocalization p Rₚ)\n    (quotMapEquivQuotMapMaximalIdealOfIsLocalization S p Rₚ Sₚ)]\n  · congr\n  · ext x\n    simp only [equivQuotMaximalIdealOfIsLocalization, RingHom.quotientKerEquivOfSurjective,\n      RingEquiv.coe_ringHom_trans, RingHom.coe_comp, RingHom.coe_coe, Function.comp_apply,\n      Ideal.quotEquivOfEq_mk, RingHom.quotientKerEquivOfRightInverse.apply, RingHom.kerLift_mk,\n      quotMapEquivQuotMapMaximalIdealOfIsLocalization,\n      Ideal.Quotient.algebraMap_quotient_map_quotient]\n    rw [← IsScalarTower.algebraMap_apply, ← IsScalarTower.algebraMap_apply]\n\n"}
{"name":"Algebra.trace_quotient_eq_of_isDedekindDomain","module":"Mathlib.RingTheory.Trace.Quotient","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁸ : CommRing R\ninst✝⁷ : CommRing S\ninst✝⁶ : Algebra R S\np : Ideal R\ninst✝⁵ : p.IsMaximal\nx : S\ninst✝⁴ : IsDedekindDomain R\ninst✝³ : IsDomain S\ninst✝² : NoZeroSMulDivisors R S\ninst✝¹ : Module.Finite R S\ninst✝ : IsIntegrallyClosed S\n⊢ Eq ((Algebra.trace (HasQuotient.Quotient R p) (HasQuotient.Quotient S (Ideal.map (algebraMap R S) p))) ((Ideal.Quotient.mk (Ideal.map (algebraMap R S) p)) x)) ((Ideal.Quotient.mk p) ((Algebra.intTrace R S) x))","decl":"open nonZeroDivisors in\n/-- The trace map on `B → A` coincides with the trace map on `B⧸pB → A⧸p`. -/\nlemma Algebra.trace_quotient_eq_of_isDedekindDomain (x) [IsDedekindDomain R] [IsDomain S]\n    [NoZeroSMulDivisors R S] [Module.Finite R S] [IsIntegrallyClosed S] :\n    Algebra.trace (R ⧸ p) (S ⧸ pS) (Ideal.Quotient.mk pS x) =\n      Ideal.Quotient.mk p (Algebra.intTrace R S x) := by\n  let Rₚ := Localization.AtPrime p\n  let Sₚ := Localization (Algebra.algebraMapSubmonoid S p.primeCompl)\n  letI : Algebra Rₚ Sₚ := localizationAlgebra p.primeCompl S\n  haveI : IsScalarTower R Rₚ Sₚ := IsScalarTower.of_algebraMap_eq'\n    (by rw [RingHom.algebraMap_toAlgebra, IsLocalization.map_comp, ← IsScalarTower.algebraMap_eq])\n  haveI : IsLocalization (Submonoid.map (algebraMap R S) (Ideal.primeCompl p)) Sₚ :=\n    inferInstanceAs (IsLocalization (Algebra.algebraMapSubmonoid S p.primeCompl) Sₚ)\n  have e : Algebra.algebraMapSubmonoid S p.primeCompl ≤ S⁰ :=\n    Submonoid.map_le_of_le_comap _ <| p.primeCompl_le_nonZeroDivisors.trans\n      (nonZeroDivisors_le_comap_nonZeroDivisors_of_injective _\n        (NoZeroSMulDivisors.algebraMap_injective _ _))\n  haveI : IsDomain Sₚ := IsLocalization.isDomain_of_le_nonZeroDivisors S e\n  haveI : NoZeroSMulDivisors Rₚ Sₚ := by\n    rw [NoZeroSMulDivisors.iff_algebraMap_injective, RingHom.injective_iff_ker_eq_bot,\n      RingHom.ker_eq_bot_iff_eq_zero]\n    intro x hx\n    obtain ⟨x, s, rfl⟩ := IsLocalization.mk'_surjective p.primeCompl x\n    simp only [Sₚ, RingHom.algebraMap_toAlgebra, IsLocalization.map_mk',\n      IsLocalization.mk'_eq_zero_iff, mul_eq_zero, Subtype.exists, exists_prop] at hx ⊢\n    obtain ⟨_, ⟨a, ha, rfl⟩, H⟩ := hx\n    simp only [(injective_iff_map_eq_zero' _).mp (NoZeroSMulDivisors.algebraMap_injective R S)] at H\n    refine ⟨a, ha, H⟩\n  haveI : Module.Finite Rₚ Sₚ := Module.Finite_of_isLocalization R S _ _ p.primeCompl\n  haveI : IsIntegrallyClosed Sₚ := isIntegrallyClosed_of_isLocalization _ _ e\n  have : IsPrincipalIdealRing Rₚ := by\n    by_cases hp : p = ⊥\n    · infer_instance\n    · have := (IsDedekindDomain.isDedekindDomainDvr R).2 p hp inferInstance\n      infer_instance\n  haveI : Module.Free Rₚ Sₚ := Module.free_of_finite_type_torsion_free'\n  apply (equivQuotMaximalIdealOfIsLocalization p Rₚ).injective\n  rw [trace_quotient_eq_trace_localization_quotient S p Rₚ Sₚ, IsScalarTower.algebraMap_eq S Sₚ,\n    RingHom.comp_apply, Ideal.Quotient.algebraMap_eq, Algebra.trace_quotient_mk,\n    RingEquiv.apply_symm_apply, ← Algebra.intTrace_eq_trace,\n    ← Algebra.intTrace_eq_of_isLocalization R S p.primeCompl (Aₘ := Rₚ) (Bₘ := Sₚ) x,\n    ← Ideal.Quotient.algebraMap_eq, ← IsScalarTower.algebraMap_apply]\n  simp only [equivQuotMaximalIdealOfIsLocalization, RingHom.quotientKerEquivOfSurjective,\n    RingEquiv.coe_trans, Function.comp_apply, Ideal.quotEquivOfEq_mk,\n    RingHom.quotientKerEquivOfRightInverse.apply, RingHom.kerLift_mk]\n\n"}
