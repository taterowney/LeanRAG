{"name":"Quiver.HasInvolutiveReverse.inv'","module":"Mathlib.Combinatorics.Quiver.Symmetric","initialProofState":"V : Type u_2\ninst✝ : Quiver V\nself : Quiver.HasInvolutiveReverse V\na b : V\nf : Quiver.Hom a b\n⊢ Eq (Quiver.reverse (Quiver.reverse f)) f","decl":"/-- A quiver `HasInvolutiveReverse` if reversing twice is the identity. -/\nclass HasInvolutiveReverse extends HasReverse V where\n  /-- `reverse` is involutive -/\n  inv' : ∀ {a b : V} (f : a ⟶ b), reverse (reverse f) = f\n\n"}
{"name":"Quiver.reverse_reverse","module":"Mathlib.Combinatorics.Quiver.Symmetric","initialProofState":"V : Type u_2\ninst✝ : Quiver V\nh : Quiver.HasInvolutiveReverse V\na b : V\nf : Quiver.Hom a b\n⊢ Eq (Quiver.reverse (Quiver.reverse f)) f","decl":"@[simp]\ntheorem reverse_reverse [h : HasInvolutiveReverse V] {a b : V} (f : a ⟶ b) :\n    reverse (reverse f) = f := by apply h.inv'\n\n"}
{"name":"Quiver.reverse_inj","module":"Mathlib.Combinatorics.Quiver.Symmetric","initialProofState":"V : Type u_2\ninst✝ : Quiver V\nh : Quiver.HasInvolutiveReverse V\na b : V\nf g : Quiver.Hom a b\n⊢ Iff (Eq (Quiver.reverse f) (Quiver.reverse g)) (Eq f g)","decl":"@[simp]\ntheorem reverse_inj [h : HasInvolutiveReverse V] {a b : V}\n    (f g : a ⟶ b) : reverse f = reverse g ↔ f = g := by\n  constructor\n  · rintro h\n    simpa using congr_arg Quiver.reverse h\n  · rintro h\n    congr\n\n"}
{"name":"Quiver.eq_reverse_iff","module":"Mathlib.Combinatorics.Quiver.Symmetric","initialProofState":"V : Type u_2\ninst✝ : Quiver V\nh : Quiver.HasInvolutiveReverse V\na b : V\nf : Quiver.Hom a b\ng : Quiver.Hom b a\n⊢ Iff (Eq f (Quiver.reverse g)) (Eq (Quiver.reverse f) g)","decl":"theorem eq_reverse_iff [h : HasInvolutiveReverse V] {a b : V} (f : a ⟶ b)\n    (g : b ⟶ a) : f = reverse g ↔ reverse f = g := by\n  rw [← reverse_inj, reverse_reverse]\n\n"}
{"name":"Prefunctor.MapReverse.map_reverse'","module":"Mathlib.Combinatorics.Quiver.Symmetric","initialProofState":"U : Type u_1\nV : Type u_2\ninst✝³ : Quiver U\ninst✝² : Quiver V\ninst✝¹ : Quiver.HasReverse U\ninst✝ : Quiver.HasReverse V\nφ : Prefunctor U V\nself : φ.MapReverse\nu v : U\ne : Quiver.Hom u v\n⊢ Eq (φ.map (Quiver.reverse e)) (Quiver.reverse (φ.map e))","decl":"/-- A prefunctor preserving reversal of arrows -/\nclass _root_.Prefunctor.MapReverse (φ : U ⥤q V) : Prop where\n  /-- The image of a reverse is the reverse of the image. -/\n  map_reverse' : ∀ {u v : U} (e : u ⟶ v), φ.map (reverse e) = reverse (φ.map e)\n\n"}
{"name":"Prefunctor.map_reverse","module":"Mathlib.Combinatorics.Quiver.Symmetric","initialProofState":"U : Type u_1\nV : Type u_2\ninst✝⁴ : Quiver U\ninst✝³ : Quiver V\ninst✝² : Quiver.HasReverse U\ninst✝¹ : Quiver.HasReverse V\nφ : Prefunctor U V\ninst✝ : φ.MapReverse\nu v : U\ne : Quiver.Hom u v\n⊢ Eq (φ.map (Quiver.reverse e)) (Quiver.reverse (φ.map e))","decl":"@[simp]\ntheorem _root_.Prefunctor.map_reverse (φ : U ⥤q V) [φ.MapReverse]\n    {u v : U} (e : u ⟶ v) : φ.map (reverse e) = reverse (φ.map e) :=\n  Prefunctor.MapReverse.map_reverse' e\n\n"}
{"name":"Prefunctor.mapReverseComp","module":"Mathlib.Combinatorics.Quiver.Symmetric","initialProofState":"U : Type u_1\nV : Type u_2\nW : Type u_3\ninst✝⁷ : Quiver U\ninst✝⁶ : Quiver V\ninst✝⁵ : Quiver W\ninst✝⁴ : Quiver.HasReverse U\ninst✝³ : Quiver.HasReverse V\ninst✝² : Quiver.HasReverse W\nφ : Prefunctor U V\nψ : Prefunctor V W\ninst✝¹ : φ.MapReverse\ninst✝ : ψ.MapReverse\n⊢ (φ.comp ψ).MapReverse","decl":"instance _root_.Prefunctor.mapReverseComp\n    (φ : U ⥤q V) (ψ : V ⥤q W) [φ.MapReverse] [ψ.MapReverse] :\n    (φ ⋙q ψ).MapReverse where\n  map_reverse' e := by\n    simp only [Prefunctor.comp_map, Prefunctor.MapReverse.map_reverse']\n\n"}
{"name":"Prefunctor.mapReverseId","module":"Mathlib.Combinatorics.Quiver.Symmetric","initialProofState":"U : Type u_1\ninst✝¹ : Quiver U\ninst✝ : Quiver.HasReverse U\n⊢ (Prefunctor.id U).MapReverse","decl":"instance _root_.Prefunctor.mapReverseId :\n    (Prefunctor.id U).MapReverse where\n  map_reverse' _ := rfl\n\n"}
{"name":"Quiver.symmetrify_reverse","module":"Mathlib.Combinatorics.Quiver.Symmetric","initialProofState":"V : Type u_2\ninst✝ : Quiver V\na b : Quiver.Symmetrify V\ne : Quiver.Hom a b\n⊢ Eq (Quiver.reverse e) (Sum.swap e)","decl":"@[simp]\ntheorem symmetrify_reverse {a b : Symmetrify V} (e : a ⟶ b) : reverse e = e.swap :=\n  rfl\n\n"}
{"name":"Quiver.Path.reverse_toPath","module":"Mathlib.Combinatorics.Quiver.Symmetric","initialProofState":"V : Type u_2\ninst✝¹ : Quiver V\ninst✝ : Quiver.HasReverse V\na b : V\nf : Quiver.Hom a b\n⊢ Eq f.toPath.reverse (Quiver.reverse f).toPath","decl":"@[simp]\ntheorem Path.reverse_toPath [HasReverse V] {a b : V} (f : a ⟶ b) :\n    f.toPath.reverse = (Quiver.reverse f).toPath :=\n  rfl\n\n"}
{"name":"Quiver.Path.reverse_comp","module":"Mathlib.Combinatorics.Quiver.Symmetric","initialProofState":"V : Type u_2\ninst✝¹ : Quiver V\ninst✝ : Quiver.HasReverse V\na b c : V\np : Quiver.Path a b\nq : Quiver.Path b c\n⊢ Eq (p.comp q).reverse (q.reverse.comp p.reverse)","decl":"@[simp]\ntheorem Path.reverse_comp [HasReverse V] {a b c : V} (p : Path a b) (q : Path b c) :\n    (p.comp q).reverse = q.reverse.comp p.reverse := by\n  induction q with\n  | nil => simp\n  | cons _ _ h => simp [h]\n\n"}
{"name":"Quiver.Path.reverse_reverse","module":"Mathlib.Combinatorics.Quiver.Symmetric","initialProofState":"V : Type u_2\ninst✝ : Quiver V\nh : Quiver.HasInvolutiveReverse V\na b : V\np : Quiver.Path a b\n⊢ Eq p.reverse.reverse p","decl":"@[simp]\ntheorem Path.reverse_reverse [h : HasInvolutiveReverse V] {a b : V} (p : Path a b) :\n    p.reverse.reverse = p := by\n  induction p with\n  | nil => simp\n  | cons _ _ h =>\n    rw [Path.reverse, Path.reverse_comp, h, Path.reverse_toPath, Quiver.reverse_reverse]\n    rfl\n\n"}
{"name":"Quiver.Symmetrify.lift_spec","module":"Mathlib.Combinatorics.Quiver.Symmetric","initialProofState":"V : Type u_2\ninst✝² : Quiver V\nV' : Type u_4\ninst✝¹ : Quiver V'\ninst✝ : Quiver.HasReverse V'\nφ : Prefunctor V V'\n⊢ Eq (Quiver.Symmetrify.of.comp (Quiver.Symmetrify.lift φ)) φ","decl":"theorem lift_spec [HasReverse V'] (φ : Prefunctor V V') :\n    Symmetrify.of.comp (Symmetrify.lift φ) = φ := by\n  fapply Prefunctor.ext\n  · rintro X\n    rfl\n  · rintro X Y f\n    rfl\n\n"}
{"name":"Quiver.Symmetrify.lift_reverse","module":"Mathlib.Combinatorics.Quiver.Symmetric","initialProofState":"V : Type u_2\ninst✝¹ : Quiver V\nV' : Type u_4\ninst✝ : Quiver V'\nh : Quiver.HasInvolutiveReverse V'\nφ : Prefunctor V V'\nX Y : Quiver.Symmetrify V\nf : Quiver.Hom X Y\n⊢ Eq ((Quiver.Symmetrify.lift φ).map (Quiver.reverse f)) (Quiver.reverse ((Quiver.Symmetrify.lift φ).map f))","decl":"theorem lift_reverse [h : HasInvolutiveReverse V']\n    (φ : Prefunctor V V') {X Y : Symmetrify V} (f : X ⟶ Y) :\n    (Symmetrify.lift φ).map (Quiver.reverse f) = Quiver.reverse ((Symmetrify.lift φ).map f) := by\n  dsimp [Symmetrify.lift]; cases f\n  · simp only\n    rfl\n  · simp only [reverse_reverse]\n    rfl\n\n"}
{"name":"Quiver.Symmetrify.lift_unique","module":"Mathlib.Combinatorics.Quiver.Symmetric","initialProofState":"V : Type u_2\ninst✝² : Quiver V\nV' : Type u_4\ninst✝¹ : Quiver V'\ninst✝ : Quiver.HasReverse V'\nφ : Prefunctor V V'\nΦ : Prefunctor (Quiver.Symmetrify V) V'\nhΦ : Eq (Quiver.Symmetrify.of.comp Φ) φ\nhΦinv : ∀ {X Y : Quiver.Symmetrify V} (f : Quiver.Hom X Y), Eq (Φ.map (Quiver.reverse f)) (Quiver.reverse (Φ.map f))\n⊢ Eq Φ (Quiver.Symmetrify.lift φ)","decl":"/-- `lift φ` is the only prefunctor extending `φ` and preserving reverses. -/\ntheorem lift_unique [HasReverse V'] (φ : V ⥤q V') (Φ : Symmetrify V ⥤q V') (hΦ : (of ⋙q Φ) = φ)\n    (hΦinv : ∀ {X Y : Symmetrify V} (f : X ⟶ Y),\n      Φ.map (Quiver.reverse f) = Quiver.reverse (Φ.map f)) :\n    Φ = Symmetrify.lift φ := by\n  subst_vars\n  fapply Prefunctor.ext\n  · rintro X\n    rfl\n  · rintro X Y f\n    cases f\n    · rfl\n    · exact hΦinv (Sum.inl _)\n\n"}
{"name":"Prefunctor.symmetrify_obj","module":"Mathlib.Combinatorics.Quiver.Symmetric","initialProofState":"U : Type u_1\nV : Type u_2\ninst✝¹ : Quiver U\ninst✝ : Quiver V\nφ : Prefunctor U V\na✝ : U\n⊢ Eq (φ.symmetrify.obj a✝) (φ.obj a✝)","decl":"/-- A prefunctor canonically defines a prefunctor of the symmetrifications. -/\n@[simps]\ndef _root_.Prefunctor.symmetrify (φ : U ⥤q V) : Symmetrify U ⥤q Symmetrify V where\n  obj := φ.obj\n  map := Sum.map φ.map φ.map\n\n"}
{"name":"Prefunctor.symmetrify_map","module":"Mathlib.Combinatorics.Quiver.Symmetric","initialProofState":"U : Type u_1\nV : Type u_2\ninst✝¹ : Quiver U\ninst✝ : Quiver V\nφ : Prefunctor U V\nX✝ Y✝ : Quiver.Symmetrify U\na✝ : Sum (Quiver.Hom X✝ Y✝) (Quiver.Hom Y✝ X✝)\n⊢ Eq (φ.symmetrify.map a✝) (Sum.map φ.map φ.map a✝)","decl":"/-- A prefunctor canonically defines a prefunctor of the symmetrifications. -/\n@[simps]\ndef _root_.Prefunctor.symmetrify (φ : U ⥤q V) : Symmetrify U ⥤q Symmetrify V where\n  obj := φ.obj\n  map := Sum.map φ.map φ.map\n\n"}
{"name":"Prefunctor.symmetrify_mapReverse","module":"Mathlib.Combinatorics.Quiver.Symmetric","initialProofState":"U : Type u_1\nV : Type u_2\ninst✝¹ : Quiver U\ninst✝ : Quiver V\nφ : Prefunctor U V\n⊢ φ.symmetrify.MapReverse","decl":"instance _root_.Prefunctor.symmetrify_mapReverse (φ : U ⥤q V) :\n    Prefunctor.MapReverse φ.symmetrify :=\n  ⟨fun e => by cases e <;> rfl⟩\n\n"}
{"name":"Quiver.Push.of_reverse","module":"Mathlib.Combinatorics.Quiver.Symmetric","initialProofState":"V : Type u_2\ninst✝¹ : Quiver V\nV' : Type u_4\nσ : V → V'\ninst✝ : Quiver.HasInvolutiveReverse V\nX Y : V\nf : Quiver.Hom X Y\n⊢ Eq (Quiver.reverse ((Quiver.Push.of σ).map f)) ((Quiver.Push.of σ).map (Quiver.reverse f))","decl":"theorem of_reverse [HasInvolutiveReverse V] (X Y : V) (f : X ⟶ Y) :\n    (reverse <| (Push.of σ).map f) = (Push.of σ).map (reverse f) :=\n  rfl\n\n"}
{"name":"Quiver.Push.ofMapReverse","module":"Mathlib.Combinatorics.Quiver.Symmetric","initialProofState":"V : Type u_2\ninst✝ : Quiver V\nV' : Type u_4\nσ : V → V'\nh : Quiver.HasInvolutiveReverse V\n⊢ (Quiver.Push.of σ).MapReverse","decl":"instance ofMapReverse [h : HasInvolutiveReverse V] : (Push.of σ).MapReverse :=\n  ⟨by simp [of_reverse]⟩\n\n"}
