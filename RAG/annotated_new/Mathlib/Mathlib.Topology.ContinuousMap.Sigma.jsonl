{"name":"ContinuousMap.isEmbedding_sigmaMk_comp","module":"Mathlib.Topology.ContinuousMap.Sigma","initialProofState":"X : Type u_1\nι : Type u_2\nY : ι → Type u_3\ninst✝² : TopologicalSpace X\ninst✝¹ : (i : ι) → TopologicalSpace (Y i)\ninst✝ : Nonempty X\n⊢ Topology.IsEmbedding fun g => (ContinuousMap.sigmaMk g.fst).comp g.snd","decl":"theorem isEmbedding_sigmaMk_comp [Nonempty X] :\n    IsEmbedding (fun g : Σ i, C(X, Y i) ↦ (sigmaMk g.1).comp g.2) where\n  toIsInducing := inducing_sigma.2\n    ⟨fun i ↦ (sigmaMk i).isInducing_postcomp IsEmbedding.sigmaMk.isInducing, fun i ↦\n      let ⟨x⟩ := ‹Nonempty X›\n      ⟨_, (isOpen_sigma_fst_preimage {i}).preimage (continuous_eval_const x), fun _ ↦ Iff.rfl⟩⟩\n  injective := by\n    rintro ⟨i, g⟩ ⟨i', g'⟩ h\n    obtain ⟨rfl, hg⟩ : i = i' ∧ HEq (⇑g) (⇑g') :=\n      Function.eq_of_sigmaMk_comp <| congr_arg DFunLike.coe h\n    simpa using hg\n\n"}
{"name":"ContinuousMap.embedding_sigmaMk_comp","module":"Mathlib.Topology.ContinuousMap.Sigma","initialProofState":"X : Type u_1\nι : Type u_2\nY : ι → Type u_3\ninst✝² : TopologicalSpace X\ninst✝¹ : (i : ι) → TopologicalSpace (Y i)\ninst✝ : Nonempty X\n⊢ Topology.IsEmbedding fun g => (ContinuousMap.sigmaMk g.fst).comp g.snd","decl":"@[deprecated (since := \"2024-10-26\")]\nalias embedding_sigmaMk_comp := isEmbedding_sigmaMk_comp\n\n"}
{"name":"ContinuousMap.exists_lift_sigma","module":"Mathlib.Topology.ContinuousMap.Sigma","initialProofState":"X : Type u_1\nι : Type u_2\nY : ι → Type u_3\ninst✝² : TopologicalSpace X\ninst✝¹ : (i : ι) → TopologicalSpace (Y i)\ninst✝ : ConnectedSpace X\nf : ContinuousMap X (Sigma fun i => Y i)\n⊢ Exists fun i => Exists fun g => Eq f ((ContinuousMap.sigmaMk i).comp g)","decl":"/-- Every continuous map from a connected topological space to the disjoint union of a family of\ntopological spaces is a composition of the embedding `ContinuousMap.sigmMk i : C(Y i, Σ i, Y i)` for\nsome `i` and a continuous map `g : C(X, Y i)`. See also `Continuous.exists_lift_sigma` for a version\nwith unbundled functions and `ContinuousMap.sigmaCodHomeomorph` for a homeomorphism defined using\nthis fact. -/\ntheorem exists_lift_sigma (f : C(X, Σ i, Y i)) : ∃ i g, f = (sigmaMk i).comp g :=\n  let ⟨i, g, hg, hfg⟩ := (map_continuous f).exists_lift_sigma\n  ⟨i, ⟨g, hg⟩, DFunLike.ext' hfg⟩\n\n"}
{"name":"ContinuousMap.sigmaCodHomeomorph_symm_apply","module":"Mathlib.Topology.ContinuousMap.Sigma","initialProofState":"X : Type u_1\nι : Type u_2\nY : ι → Type u_3\ninst✝² : TopologicalSpace X\ninst✝¹ : (i : ι) → TopologicalSpace (Y i)\ninst✝ : ConnectedSpace X\na✝ : Sigma fun i => ContinuousMap X (Y i)\n⊢ Eq ((ContinuousMap.sigmaCodHomeomorph X Y).symm a✝) ((ContinuousMap.sigmaMk a✝.fst).comp a✝.snd)","decl":"/-- Homeomorphism between the type `C(X, Σ i, Y i)` of continuous maps from a connected topological\nspace to the disjoint union of a family of topological spaces and the disjoint union of the types of\ncontinuous maps `C(X, Y i)`.\n\nThe inverse map sends `⟨i, g⟩` to `ContinuousMap.comp (ContinuousMap.sigmaMk i) g`. -/\n@[simps! symm_apply]\ndef sigmaCodHomeomorph : C(X, Σ i, Y i) ≃ₜ Σ i, C(X, Y i) :=\n  .symm <| Equiv.toHomeomorphOfIsInducing\n    (.ofBijective _ ⟨isEmbedding_sigmaMk_comp.injective, fun f ↦\n      let ⟨i, g, hg⟩ := f.exists_lift_sigma; ⟨⟨i, g⟩, hg.symm⟩⟩)\n    isEmbedding_sigmaMk_comp.isInducing\n\n"}
