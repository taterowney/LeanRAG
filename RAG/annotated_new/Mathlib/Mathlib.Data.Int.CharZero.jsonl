{"name":"Int.cast_div_charZero","module":"Mathlib.Data.Int.CharZero","initialProofState":"k : Type u_3\ninst✝¹ : DivisionRing k\ninst✝ : CharZero k\nm n : Int\nn_dvd : Dvd.dvd n m\n⊢ Eq (↑(HDiv.hDiv m n)) (HDiv.hDiv ↑m ↑n)","decl":"@[simp, norm_cast]\ntheorem cast_div_charZero {k : Type*} [DivisionRing k] [CharZero k] {m n : ℤ} (n_dvd : n ∣ m) :\n    ((m / n : ℤ) : k) = m / n := by\n  rcases eq_or_ne n 0 with (rfl | hn)\n  · simp [Int.ediv_zero]\n  · exact cast_div n_dvd (cast_ne_zero.mpr hn)\n\n-- Necessary for confluence with `ofNat_ediv` and `cast_div_charZero`.\n"}
{"name":"Int.cast_div_ofNat_charZero","module":"Mathlib.Data.Int.CharZero","initialProofState":"k : Type u_3\ninst✝¹ : DivisionRing k\ninst✝ : CharZero k\nm n : Nat\nn_dvd : Dvd.dvd n m\n⊢ Eq (↑(HDiv.hDiv ↑m ↑n)) (HDiv.hDiv ↑m ↑n)","decl":"@[simp, norm_cast]\ntheorem cast_div_ofNat_charZero {k : Type*} [DivisionRing k] [CharZero k] {m n : ℕ}\n    (n_dvd : n ∣ m) : (((m : ℤ) / (n : ℤ) : ℤ) : k) = m / n := by\n  rw [cast_div_charZero (Int.ofNat_dvd.mpr n_dvd), cast_natCast, cast_natCast]\n\n"}
{"name":"RingHom.injective_int","module":"Mathlib.Data.Int.CharZero","initialProofState":"α : Type u_3\ninst✝¹ : NonAssocRing α\nf : RingHom Int α\ninst✝ : CharZero α\n⊢ Function.Injective ⇑f","decl":"theorem RingHom.injective_int {α : Type*} [NonAssocRing α] (f : ℤ →+* α) [CharZero α] :\n    Function.Injective f :=\n  Subsingleton.elim (Int.castRingHom _) f ▸ Int.cast_injective\n\n"}
{"name":"Function.support_intCast","module":"Mathlib.Data.Int.CharZero","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : AddGroupWithOne β\ninst✝ : CharZero β\nn : Int\nhn : Ne n 0\n⊢ Eq (Function.support ↑n) Set.univ","decl":"lemma support_intCast (hn : n ≠ 0) : support (n : α → β) = univ :=\n  support_const <| Int.cast_ne_zero.2 hn\n\n"}
{"name":"Function.mulSupport_intCast","module":"Mathlib.Data.Int.CharZero","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : AddGroupWithOne β\ninst✝ : CharZero β\nn : Int\nhn : Ne n 1\n⊢ Eq (Function.mulSupport ↑n) Set.univ","decl":"lemma mulSupport_intCast (hn : n ≠ 1) : mulSupport (n : α → β) = univ :=\n  mulSupport_const <| Int.cast_ne_one.2 hn\n\n"}
