{"name":"CategoryTheory.instIsThin","module":"Mathlib.CategoryTheory.Limits.SmallComplete","initialProofState":"C : Type u\ninst✝ : CategoryTheory.SmallCategory C\n⊢ Quiver.IsThin C","decl":"/-- A small category with products is a thin category.\n\nin Lean, a preorder category is one where the morphisms are in Prop, which is weaker than the usual\nnotion of a preorder/thin category which says that each homset is subsingleton; we show the latter\nrather than providing a `Preorder C` instance.\n-/\ninstance (priority := 100) : Quiver.IsThin C := fun X Y =>\n  ⟨fun r s => by\n    classical\n      by_contra r_ne_s\n      have z : (2 : Cardinal) ≤ #(X ⟶ Y) := by\n        rw [Cardinal.two_le_iff]\n        exact ⟨_, _, r_ne_s⟩\n      let md := ΣZ W : C, Z ⟶ W\n      let α := #md\n      apply not_le_of_lt (Cardinal.cantor α)\n      let yp : C := ∏ᶜ fun _ : md => Y\n      apply _root_.trans _ _\n      · exact #(X ⟶ yp)\n      · apply le_trans (Cardinal.power_le_power_right z)\n        rw [Cardinal.power_def]\n        apply le_of_eq\n        rw [Cardinal.eq]\n        refine ⟨⟨Pi.lift, fun f k => f ≫ Pi.π _ k, ?_, ?_⟩⟩\n        · intro f\n          ext k\n          simp [yp]\n        · intro f\n          ext ⟨j⟩\n          simp [yp]\n      · apply Cardinal.mk_le_of_injective _\n        · intro f\n          exact ⟨_, _, f⟩\n        · rintro f g k\n          cases k\n          rfl⟩\n\n"}
