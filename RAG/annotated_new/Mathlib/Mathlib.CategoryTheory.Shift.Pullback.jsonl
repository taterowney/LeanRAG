{"name":"CategoryTheory.instHasZeroObjectPullbackShift","module":"Mathlib.CategoryTheory.Shift.Pullback","initialProofState":"C : Type u_1\ninstâœâ´ : CategoryTheory.Category.{u_4, u_1} C\nA : Type u_2\nB : Type u_3\ninstâœÂ³ : AddMonoid A\ninstâœÂ² : AddMonoid B\nÏ† : AddMonoidHom A B\ninstâœÂ¹ : CategoryTheory.HasShift C B\ninstâœ : CategoryTheory.Limits.HasZeroObject C\nâŠ¢ CategoryTheory.Limits.HasZeroObject (CategoryTheory.PullbackShift C Ï†)","decl":"instance [HasZeroObject C] : HasZeroObject (PullbackShift C Ï†) := by\n  dsimp [PullbackShift]\n  infer_instance\n\n"}
{"name":"CategoryTheory.instAdditivePullbackShiftShiftFunctorOfCoeAddMonoidHom","module":"Mathlib.CategoryTheory.Shift.Pullback","initialProofState":"C : Type u_1\ninstâœâµ : CategoryTheory.Category.{u_4, u_1} C\nA : Type u_2\nB : Type u_3\ninstâœâ´ : AddMonoid A\ninstâœÂ³ : AddMonoid B\nÏ† : AddMonoidHom A B\ninstâœÂ² : CategoryTheory.HasShift C B\ninstâœÂ¹ : CategoryTheory.Preadditive C\na : A\ninstâœ : (CategoryTheory.shiftFunctor C (Ï† a)).Additive\nâŠ¢ (CategoryTheory.shiftFunctor (CategoryTheory.PullbackShift C Ï†) a).Additive","decl":"instance [Preadditive C] (a : A) [(shiftFunctor C (Ï† a)).Additive] :\n    (shiftFunctor (PullbackShift C Ï†) a).Additive := by\n  change (shiftFunctor C (Ï† a)).Additive\n  infer_instance\n\n"}
{"name":"CategoryTheory.pullbackShiftFunctorZero_inv_app","module":"Mathlib.CategoryTheory.Shift.Pullback","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_4, u_1} C\nA : Type u_2\nB : Type u_3\ninstâœÂ² : AddMonoid A\ninstâœÂ¹ : AddMonoid B\nÏ† : AddMonoidHom A B\ninstâœ : CategoryTheory.HasShift C B\nX : CategoryTheory.PullbackShift C Ï†\nâŠ¢ Eq ((CategoryTheory.shiftFunctorZero (CategoryTheory.PullbackShift C Ï†) A).inv.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorZero C B).inv.app X) ((CategoryTheory.pullbackShiftIso C Ï† 0 0 â‹¯).inv.app X))","decl":"lemma pullbackShiftFunctorZero_inv_app :\n    (shiftFunctorZero _ A).inv.app X =\n      (shiftFunctorZero C B).inv.app X â‰« (pullbackShiftIso C Ï† 0 0 (by simp)).inv.app X := by\n  change (shiftFunctorZero C B).inv.app X â‰« _ = _\n  dsimp [Discrete.eqToHom, Discrete.addMonoidalFunctor_Îµ]\n  congr 2\n  apply eqToHom_map\n\n"}
{"name":"CategoryTheory.pullbackShiftFunctorZero_hom_app","module":"Mathlib.CategoryTheory.Shift.Pullback","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_4, u_1} C\nA : Type u_2\nB : Type u_3\ninstâœÂ² : AddMonoid A\ninstâœÂ¹ : AddMonoid B\nÏ† : AddMonoidHom A B\ninstâœ : CategoryTheory.HasShift C B\nX : CategoryTheory.PullbackShift C Ï†\nâŠ¢ Eq ((CategoryTheory.shiftFunctorZero (CategoryTheory.PullbackShift C Ï†) A).hom.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.pullbackShiftIso C Ï† 0 0 â‹¯).hom.app X) ((CategoryTheory.shiftFunctorZero C B).hom.app X))","decl":"lemma pullbackShiftFunctorZero_hom_app :\n    (shiftFunctorZero _ A).hom.app X =\n      (pullbackShiftIso C Ï† 0 0 (by simp)).hom.app X â‰« (shiftFunctorZero C B).hom.app X := by\n  rw [â† cancel_epi ((shiftFunctorZero _ A).inv.app X), Iso.inv_hom_id_app,\n    pullbackShiftFunctorZero_inv_app, assoc, Iso.inv_hom_id_app_assoc, Iso.inv_hom_id_app]\n  rfl\n\n"}
{"name":"CategoryTheory.pullbackShiftFunctorZero'_inv_app","module":"Mathlib.CategoryTheory.Shift.Pullback","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_4, u_1} C\nA : Type u_2\nB : Type u_3\ninstâœÂ² : AddMonoid A\ninstâœÂ¹ : AddMonoid B\nÏ† : AddMonoidHom A B\ninstâœ : CategoryTheory.HasShift C B\nX : CategoryTheory.PullbackShift C Ï†\nâŠ¢ Eq ((CategoryTheory.shiftFunctorZero (CategoryTheory.PullbackShift C Ï†) A).inv.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorZero' C (Ï† 0) â‹¯).inv.app X) ((CategoryTheory.pullbackShiftIso C Ï† 0 (Ï† 0) â‹¯).inv.app X))","decl":"lemma pullbackShiftFunctorZero'_inv_app :\n    (shiftFunctorZero _ A).inv.app X = (shiftFunctorZero' C (Ï† 0) (by rw [map_zero])).inv.app X â‰«\n      (pullbackShiftIso C Ï† 0 (Ï† 0) rfl).inv.app X := by\n  rw [pullbackShiftFunctorZero_inv_app]\n  simp only [Functor.id_obj, pullbackShiftIso, eqToIso.inv, eqToHom_app, shiftFunctorZero',\n    Iso.trans_inv, NatTrans.comp_app, eqToIso_refl, Iso.refl_inv, NatTrans.id_app, assoc]\n  erw [comp_id]\n\n"}
{"name":"CategoryTheory.pullbackShiftFunctorZero'_hom_app","module":"Mathlib.CategoryTheory.Shift.Pullback","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_4, u_1} C\nA : Type u_2\nB : Type u_3\ninstâœÂ² : AddMonoid A\ninstâœÂ¹ : AddMonoid B\nÏ† : AddMonoidHom A B\ninstâœ : CategoryTheory.HasShift C B\nX : CategoryTheory.PullbackShift C Ï†\nâŠ¢ Eq ((CategoryTheory.shiftFunctorZero (CategoryTheory.PullbackShift C Ï†) A).hom.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.pullbackShiftIso C Ï† 0 (Ï† 0) â‹¯).hom.app X) ((CategoryTheory.shiftFunctorZero' C (Ï† 0) â‹¯).hom.app X))","decl":"lemma pullbackShiftFunctorZero'_hom_app :\n    (shiftFunctorZero _ A).hom.app X = (pullbackShiftIso C Ï† 0 (Ï† 0) rfl).hom.app X â‰«\n      (shiftFunctorZero' C (Ï† 0) (by rw [map_zero])).hom.app X := by\n  rw [â† cancel_epi ((shiftFunctorZero _ A).inv.app X), Iso.inv_hom_id_app,\n    pullbackShiftFunctorZero'_inv_app, assoc, Iso.inv_hom_id_app_assoc, Iso.inv_hom_id_app]\n  rfl\n\n"}
{"name":"CategoryTheory.pullbackShiftFunctorAdd'_inv_app","module":"Mathlib.CategoryTheory.Shift.Pullback","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_4, u_1} C\nA : Type u_2\nB : Type u_3\ninstâœÂ² : AddMonoid A\ninstâœÂ¹ : AddMonoid B\nÏ† : AddMonoidHom A B\ninstâœ : CategoryTheory.HasShift C B\nX : CategoryTheory.PullbackShift C Ï†\naâ‚ aâ‚‚ aâ‚ƒ : A\nh : Eq (HAdd.hAdd aâ‚ aâ‚‚) aâ‚ƒ\nbâ‚ bâ‚‚ bâ‚ƒ : B\nhâ‚ : Eq bâ‚ (Ï† aâ‚)\nhâ‚‚ : Eq bâ‚‚ (Ï† aâ‚‚)\nhâ‚ƒ : Eq bâ‚ƒ (Ï† aâ‚ƒ)\nâŠ¢ Eq ((CategoryTheory.shiftFunctorAdd' (CategoryTheory.PullbackShift C Ï†) aâ‚ aâ‚‚ aâ‚ƒ h).inv.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor (CategoryTheory.PullbackShift C Ï†) aâ‚‚).map ((CategoryTheory.pullbackShiftIso C Ï† aâ‚ bâ‚ hâ‚).hom.app X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.pullbackShiftIso C Ï† aâ‚‚ bâ‚‚ hâ‚‚).hom.app ((CategoryTheory.shiftFunctor C bâ‚).obj X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd' C bâ‚ bâ‚‚ bâ‚ƒ â‹¯).inv.app X) ((CategoryTheory.pullbackShiftIso C Ï† aâ‚ƒ bâ‚ƒ hâ‚ƒ).inv.app X))))","decl":"lemma pullbackShiftFunctorAdd'_inv_app :\n    (shiftFunctorAdd' _ aâ‚ aâ‚‚ aâ‚ƒ h).inv.app X =\n      (shiftFunctor (PullbackShift C Ï†) aâ‚‚).map ((pullbackShiftIso C Ï† aâ‚ bâ‚ hâ‚).hom.app X) â‰«\n        (pullbackShiftIso C Ï† aâ‚‚ bâ‚‚ hâ‚‚).hom.app _ â‰«\n        (shiftFunctorAdd' C bâ‚ bâ‚‚ bâ‚ƒ (by rw [hâ‚, hâ‚‚, hâ‚ƒ, â† h, Ï†.map_add])).inv.app X â‰«\n        (pullbackShiftIso C Ï† aâ‚ƒ bâ‚ƒ hâ‚ƒ).inv.app X := by\n  subst hâ‚ hâ‚‚ h\n  obtain rfl : bâ‚ƒ = Ï† aâ‚ + Ï† aâ‚‚ := by rw [hâ‚ƒ, Ï†.map_add]\n  simp\n  erw [Functor.map_id, id_comp, id_comp, shiftFunctorAdd'_eq_shiftFunctorAdd,\n    shiftFunctorAdd'_eq_shiftFunctorAdd]\n  change _ â‰« _ = _\n  congr 1\n  rw [Discrete.addMonoidalFunctor_Î¼]\n  dsimp [Discrete.eqToHom]\n  congr 2\n  apply eqToHom_map\n\n"}
{"name":"CategoryTheory.pullbackShiftFunctorAdd'_hom_app","module":"Mathlib.CategoryTheory.Shift.Pullback","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_4, u_1} C\nA : Type u_2\nB : Type u_3\ninstâœÂ² : AddMonoid A\ninstâœÂ¹ : AddMonoid B\nÏ† : AddMonoidHom A B\ninstâœ : CategoryTheory.HasShift C B\nX : CategoryTheory.PullbackShift C Ï†\naâ‚ aâ‚‚ aâ‚ƒ : A\nh : Eq (HAdd.hAdd aâ‚ aâ‚‚) aâ‚ƒ\nbâ‚ bâ‚‚ bâ‚ƒ : B\nhâ‚ : Eq bâ‚ (Ï† aâ‚)\nhâ‚‚ : Eq bâ‚‚ (Ï† aâ‚‚)\nhâ‚ƒ : Eq bâ‚ƒ (Ï† aâ‚ƒ)\nâŠ¢ Eq ((CategoryTheory.shiftFunctorAdd' (CategoryTheory.PullbackShift C Ï†) aâ‚ aâ‚‚ aâ‚ƒ h).hom.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.pullbackShiftIso C Ï† aâ‚ƒ bâ‚ƒ hâ‚ƒ).hom.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd' C bâ‚ bâ‚‚ bâ‚ƒ â‹¯).hom.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.pullbackShiftIso C Ï† aâ‚‚ bâ‚‚ hâ‚‚).inv.app ((CategoryTheory.shiftFunctor C bâ‚).obj X)) ((CategoryTheory.shiftFunctor (CategoryTheory.PullbackShift C Ï†) aâ‚‚).map ((CategoryTheory.pullbackShiftIso C Ï† aâ‚ bâ‚ hâ‚).inv.app X)))))","decl":"lemma pullbackShiftFunctorAdd'_hom_app :\n    (shiftFunctorAdd' _ aâ‚ aâ‚‚ aâ‚ƒ h).hom.app X =\n      (pullbackShiftIso C Ï† aâ‚ƒ bâ‚ƒ hâ‚ƒ).hom.app X â‰«\n      (shiftFunctorAdd' C bâ‚ bâ‚‚ bâ‚ƒ (by rw [hâ‚, hâ‚‚, hâ‚ƒ, â† h, Ï†.map_add])).hom.app X â‰«\n      (pullbackShiftIso C Ï† aâ‚‚ bâ‚‚ hâ‚‚).inv.app _ â‰«\n      (shiftFunctor (PullbackShift C Ï†) aâ‚‚).map ((pullbackShiftIso C Ï† aâ‚ bâ‚ hâ‚).inv.app X) := by\n  rw [â† cancel_epi ((shiftFunctorAdd' _ aâ‚ aâ‚‚ aâ‚ƒ h).inv.app X), Iso.inv_hom_id_app,\n    pullbackShiftFunctorAdd'_inv_app Ï† X aâ‚ aâ‚‚ aâ‚ƒ h bâ‚ bâ‚‚ bâ‚ƒ hâ‚ hâ‚‚ hâ‚ƒ, assoc, assoc, assoc,\n    Iso.inv_hom_id_app_assoc, Iso.inv_hom_id_app_assoc, Iso.hom_inv_id_app_assoc,\n    â† Functor.map_comp, Iso.hom_inv_id_app, Functor.map_id]\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.commShiftPullback_iso_eq","module":"Mathlib.CategoryTheory.Shift.Pullback","initialProofState":"C : Type u_1\ninstâœâ¶ : CategoryTheory.Category.{u_6, u_1} C\nA : Type u_2\nB : Type u_3\ninstâœâµ : AddMonoid A\ninstâœâ´ : AddMonoid B\nÏ† : AddMonoidHom A B\ninstâœÂ³ : CategoryTheory.HasShift C B\nD : Type u_4\ninstâœÂ² : CategoryTheory.Category.{u_5, u_4} D\ninstâœÂ¹ : CategoryTheory.HasShift D B\nF : CategoryTheory.Functor C D\ninstâœ : F.CommShift B\na : A\nb : B\nh : Eq b (Ï† a)\nâŠ¢ Eq ((CategoryTheory.PullbackShift.functor Ï† F).commShiftIso a) ((CategoryTheory.isoWhiskerRight (CategoryTheory.pullbackShiftIso C Ï† a b h) F).trans ((F.commShiftIso b).trans (CategoryTheory.isoWhiskerLeft F (CategoryTheory.pullbackShiftIso D Ï† a b h).symm)))","decl":"lemma commShiftPullback_iso_eq (a : A) (b : B) (h : b = Ï† a) :\n    (PullbackShift.functor Ï† F).commShiftIso a (C := PullbackShift C Ï†) (D := PullbackShift D Ï†) =\n      isoWhiskerRight (pullbackShiftIso C Ï† a b h) F â‰ªâ‰« (F.commShiftIso b) â‰ªâ‰«\n        isoWhiskerLeft F (pullbackShiftIso D Ï† a b h).symm := by\n  obtain rfl : b = Ï† a := h\n  rfl\n\n"}
{"name":"CategoryTheory.NatTrans.commShiftPullback","module":"Mathlib.CategoryTheory.Shift.Pullback","initialProofState":"C : Type u_1\ninstâœâ¸ : CategoryTheory.Category.{u_6, u_1} C\nA : Type u_2\nB : Type u_3\ninstâœâ· : AddMonoid A\ninstâœâ¶ : AddMonoid B\nÏ† : AddMonoidHom A B\ninstâœâµ : CategoryTheory.HasShift C B\nD : Type u_4\ninstâœâ´ : CategoryTheory.Category.{u_5, u_4} D\ninstâœÂ³ : CategoryTheory.HasShift D B\nF : CategoryTheory.Functor C D\ninstâœÂ² : F.CommShift B\nG : CategoryTheory.Functor C D\ninstâœÂ¹ : G.CommShift B\nÏ„ : Quiver.Hom F G\ninstâœ : CategoryTheory.NatTrans.CommShift Ï„ B\nâŠ¢ CategoryTheory.NatTrans.CommShift (CategoryTheory.PullbackShift.natTrans Ï† Ï„) A","decl":"open Functor in\ninstance commShiftPullback (Ï„ : F âŸ¶ G) [NatTrans.CommShift Ï„ B] :\n    NatTrans.CommShift (PullbackShift.natTrans Ï† Ï„) A where\n  shift_comm _ := by\n    ext\n    dsimp [PullbackShift.natTrans]\n    simp only [commShiftPullback_iso_eq Ï† _ _ _ rfl, Iso.trans_hom, isoWhiskerRight_hom,\n      isoWhiskerLeft_hom, Iso.symm_hom, comp_app, comp_obj, whiskerRight_app, whiskerLeft_app,\n      assoc]\n    rw [â† Ï„.naturality_assoc]\n    simp  [â† NatTrans.shift_app_comm_assoc]\n\n"}
{"name":"CategoryTheory.NatTrans.instCommShiftPullbackShiftHomFunctorNatIsoId","module":"Mathlib.CategoryTheory.Shift.Pullback","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_5, u_1} C\nA : Type u_2\nB : Type u_3\ninstâœÂ² : AddMonoid A\ninstâœÂ¹ : AddMonoid B\nÏ† : AddMonoidHom A B\ninstâœ : CategoryTheory.HasShift C B\nâŠ¢ CategoryTheory.NatTrans.CommShift (CategoryTheory.NatTrans.PullbackShift.natIsoId C Ï†).hom A","decl":"/--\nThis expresses the compatibility between two `CommShift` structures by `A` on (synonyms of)\n`ğŸ­ C`: the canonical `CommShift` structure on `ğŸ­ (PullbackShift C Ï†)`, and the `CommShift`\nstructure on `PullbackShift.functor (ğŸ­ C) Ï†` (i.e the pullback of the canonical `CommShift`\nstructure on `ğŸ­ C`).\n-/\ninstance : NatTrans.CommShift (PullbackShift.natIsoId C Ï†).hom A where\n  shift_comm _ := by\n    ext\n    simp [PullbackShift.natIsoId, Functor.commShiftPullback_iso_eq]\n\n"}
{"name":"CategoryTheory.NatTrans.instCommShiftPullbackShiftHomFunctorNatIsoComp","module":"Mathlib.CategoryTheory.Shift.Pullback","initialProofState":"C : Type u_1\ninstâœâ¹ : CategoryTheory.Category.{u_6, u_1} C\nA : Type u_2\nB : Type u_3\ninstâœâ¸ : AddMonoid A\ninstâœâ· : AddMonoid B\nÏ† : AddMonoidHom A B\ninstâœâ¶ : CategoryTheory.HasShift C B\nD : Type u_4\ninstâœâµ : CategoryTheory.Category.{u_8, u_4} D\ninstâœâ´ : CategoryTheory.HasShift D B\nF : CategoryTheory.Functor C D\ninstâœÂ³ : F.CommShift B\nE : Type u_5\ninstâœÂ² : CategoryTheory.Category.{u_7, u_5} E\ninstâœÂ¹ : CategoryTheory.HasShift E B\nG : CategoryTheory.Functor D E\ninstâœ : G.CommShift B\nâŠ¢ CategoryTheory.NatTrans.CommShift (CategoryTheory.NatTrans.PullbackShift.natIsoComp Ï† F G).hom A","decl":"open Functor in\ninstance : NatTrans.CommShift (PullbackShift.natIsoComp Ï† F G).hom A where\n  shift_comm _ := by\n    ext\n    dsimp [PullbackShift.natIsoComp]\n    simp only [commShiftPullback_iso_eq Ï† _ _ _ rfl, Iso.trans_hom, isoWhiskerRight_hom,\n      isoWhiskerLeft_hom, Iso.symm_hom, comp_app, comp_obj, whiskerRight_app, Functor.comp_map,\n      commShiftIso_comp_hom_app, whiskerLeft_app, assoc, map_id, comp_id, map_comp, id_comp]\n    dsimp [PullbackShift.functor]\n    slice_rhs 3 4 => rw [â† G.map_comp, Iso.inv_hom_id_app]\n    simp\n\n"}
{"name":"CategoryTheory.PullbackShift.adjunction_counit","module":"Mathlib.CategoryTheory.Shift.Pullback","initialProofState":"C : Type u_1\ninstâœâµ : CategoryTheory.Category.{u_5, u_1} C\nA : Type u_2\nB : Type u_3\ninstâœâ´ : AddMonoid A\ninstâœÂ³ : AddMonoid B\nÏ† : AddMonoidHom A B\ninstâœÂ² : CategoryTheory.HasShift C B\nD : Type u_4\ninstâœÂ¹ : CategoryTheory.Category.{u_6, u_4} D\ninstâœ : CategoryTheory.HasShift D B\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nâŠ¢ Eq (CategoryTheory.PullbackShift.adjunction Ï† adj).counit (CategoryTheory.CategoryStruct.comp (CategoryTheory.NatTrans.PullbackShift.natIsoComp Ï† G F).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.PullbackShift.natTrans Ï† adj.counit) (CategoryTheory.NatTrans.PullbackShift.natIsoId D Ï†).inv))","decl":"/--\nThe adjunction `adj`, seen as an adjunction between `PullbackShift.functor F Ï†`\nand `PullbackShift.functor G Ï†`.\n-/\n@[simps (config := .lemmasOnly)]\ndef PullbackShift.adjunction {F} {G : D â¥¤ C} (adj : F âŠ£ G) :\n    PullbackShift.functor Ï† F âŠ£ PullbackShift.functor Ï† G where\n  unit := (NatTrans.PullbackShift.natIsoId C Ï†).hom â‰«\n    PullbackShift.natTrans Ï† adj.unit â‰« (NatTrans.PullbackShift.natIsoComp Ï† F G).hom\n  counit := (NatTrans.PullbackShift.natIsoComp Ï† G F).inv â‰«\n    PullbackShift.natTrans Ï† adj.counit â‰« (NatTrans.PullbackShift.natIsoId D Ï†).inv\n  left_triangle_components _ := by\n    simp [PullbackShift.natTrans, NatTrans.PullbackShift.natIsoComp,\n      NatTrans.PullbackShift.natIsoId, PullbackShift.functor]\n  right_triangle_components _ := by\n    simp [PullbackShift.natTrans, NatTrans.PullbackShift.natIsoComp,\n      NatTrans.PullbackShift.natIsoId, PullbackShift.functor]\n\n"}
{"name":"CategoryTheory.PullbackShift.adjunction_unit","module":"Mathlib.CategoryTheory.Shift.Pullback","initialProofState":"C : Type u_1\ninstâœâµ : CategoryTheory.Category.{u_5, u_1} C\nA : Type u_2\nB : Type u_3\ninstâœâ´ : AddMonoid A\ninstâœÂ³ : AddMonoid B\nÏ† : AddMonoidHom A B\ninstâœÂ² : CategoryTheory.HasShift C B\nD : Type u_4\ninstâœÂ¹ : CategoryTheory.Category.{u_6, u_4} D\ninstâœ : CategoryTheory.HasShift D B\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nâŠ¢ Eq (CategoryTheory.PullbackShift.adjunction Ï† adj).unit (CategoryTheory.CategoryStruct.comp (CategoryTheory.NatTrans.PullbackShift.natIsoId C Ï†).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.PullbackShift.natTrans Ï† adj.unit) (CategoryTheory.NatTrans.PullbackShift.natIsoComp Ï† F G).hom))","decl":"/--\nThe adjunction `adj`, seen as an adjunction between `PullbackShift.functor F Ï†`\nand `PullbackShift.functor G Ï†`.\n-/\n@[simps (config := .lemmasOnly)]\ndef PullbackShift.adjunction {F} {G : D â¥¤ C} (adj : F âŠ£ G) :\n    PullbackShift.functor Ï† F âŠ£ PullbackShift.functor Ï† G where\n  unit := (NatTrans.PullbackShift.natIsoId C Ï†).hom â‰«\n    PullbackShift.natTrans Ï† adj.unit â‰« (NatTrans.PullbackShift.natIsoComp Ï† F G).hom\n  counit := (NatTrans.PullbackShift.natIsoComp Ï† G F).inv â‰«\n    PullbackShift.natTrans Ï† adj.counit â‰« (NatTrans.PullbackShift.natIsoId D Ï†).inv\n  left_triangle_components _ := by\n    simp [PullbackShift.natTrans, NatTrans.PullbackShift.natIsoComp,\n      NatTrans.PullbackShift.natIsoId, PullbackShift.functor]\n  right_triangle_components _ := by\n    simp [PullbackShift.natTrans, NatTrans.PullbackShift.natIsoComp,\n      NatTrans.PullbackShift.natIsoId, PullbackShift.functor]\n\n"}
{"name":"CategoryTheory.Adjunction.commShiftPullback","module":"Mathlib.CategoryTheory.Shift.Pullback","initialProofState":"C : Type u_1\ninstâœâ¸ : CategoryTheory.Category.{u_5, u_1} C\nA : Type u_2\nB : Type u_3\ninstâœâ· : AddMonoid A\ninstâœâ¶ : AddMonoid B\nÏ† : AddMonoidHom A B\ninstâœâµ : CategoryTheory.HasShift C B\nD : Type u_4\ninstâœâ´ : CategoryTheory.Category.{u_6, u_4} D\ninstâœÂ³ : CategoryTheory.HasShift D B\nF : CategoryTheory.Functor C D\ninstâœÂ² : F.CommShift B\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninstâœÂ¹ : G.CommShift B\ninstâœ : adj.CommShift B\nâŠ¢ (CategoryTheory.PullbackShift.adjunction Ï† adj).CommShift A","decl":"/--\nIf an adjunction `F âŠ£ G` is compatible with `CommShift` structures on `F` and `G`, then\nit is also compatible with the pulled back `CommShift` structures by an additive map\n`Ï† : B â†’+ A`.\n-/\ninstance commShiftPullback [adj.CommShift B] : (PullbackShift.adjunction Ï† adj).CommShift A where\n  commShift_unit := by\n    dsimp [PullbackShift.adjunction]\n    infer_instance\n  commShift_counit := by\n    dsimp [PullbackShift.adjunction]\n    infer_instance\n\n"}
