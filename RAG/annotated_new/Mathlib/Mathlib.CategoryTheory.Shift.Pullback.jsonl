{"name":"CategoryTheory.instHasZeroObjectPullbackShift","module":"Mathlib.CategoryTheory.Shift.Pullback","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\nA : Type u_2\nB : Type u_3\ninst✝³ : AddMonoid A\ninst✝² : AddMonoid B\nφ : AddMonoidHom A B\ninst✝¹ : CategoryTheory.HasShift C B\ninst✝ : CategoryTheory.Limits.HasZeroObject C\n⊢ CategoryTheory.Limits.HasZeroObject (CategoryTheory.PullbackShift C φ)","decl":"instance [HasZeroObject C] : HasZeroObject (PullbackShift C φ) := by\n  dsimp [PullbackShift]\n  infer_instance\n\n"}
{"name":"CategoryTheory.instAdditivePullbackShiftShiftFunctorOfCoeAddMonoidHom","module":"Mathlib.CategoryTheory.Shift.Pullback","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_4, u_1} C\nA : Type u_2\nB : Type u_3\ninst✝⁴ : AddMonoid A\ninst✝³ : AddMonoid B\nφ : AddMonoidHom A B\ninst✝² : CategoryTheory.HasShift C B\ninst✝¹ : CategoryTheory.Preadditive C\na : A\ninst✝ : (CategoryTheory.shiftFunctor C (φ a)).Additive\n⊢ (CategoryTheory.shiftFunctor (CategoryTheory.PullbackShift C φ) a).Additive","decl":"instance [Preadditive C] (a : A) [(shiftFunctor C (φ a)).Additive] :\n    (shiftFunctor (PullbackShift C φ) a).Additive := by\n  change (shiftFunctor C (φ a)).Additive\n  infer_instance\n\n"}
{"name":"CategoryTheory.pullbackShiftFunctorZero_inv_app","module":"Mathlib.CategoryTheory.Shift.Pullback","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_4, u_1} C\nA : Type u_2\nB : Type u_3\ninst✝² : AddMonoid A\ninst✝¹ : AddMonoid B\nφ : AddMonoidHom A B\ninst✝ : CategoryTheory.HasShift C B\nX : CategoryTheory.PullbackShift C φ\n⊢ Eq ((CategoryTheory.shiftFunctorZero (CategoryTheory.PullbackShift C φ) A).inv.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorZero C B).inv.app X) ((CategoryTheory.pullbackShiftIso C φ 0 0 ⋯).inv.app X))","decl":"lemma pullbackShiftFunctorZero_inv_app :\n    (shiftFunctorZero _ A).inv.app X =\n      (shiftFunctorZero C B).inv.app X ≫ (pullbackShiftIso C φ 0 0 (by simp)).inv.app X := by\n  change (shiftFunctorZero C B).inv.app X ≫ _ = _\n  dsimp [Discrete.eqToHom, Discrete.addMonoidalFunctor_ε]\n  congr 2\n  apply eqToHom_map\n\n"}
{"name":"CategoryTheory.pullbackShiftFunctorZero_hom_app","module":"Mathlib.CategoryTheory.Shift.Pullback","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_4, u_1} C\nA : Type u_2\nB : Type u_3\ninst✝² : AddMonoid A\ninst✝¹ : AddMonoid B\nφ : AddMonoidHom A B\ninst✝ : CategoryTheory.HasShift C B\nX : CategoryTheory.PullbackShift C φ\n⊢ Eq ((CategoryTheory.shiftFunctorZero (CategoryTheory.PullbackShift C φ) A).hom.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.pullbackShiftIso C φ 0 0 ⋯).hom.app X) ((CategoryTheory.shiftFunctorZero C B).hom.app X))","decl":"lemma pullbackShiftFunctorZero_hom_app :\n    (shiftFunctorZero _ A).hom.app X =\n      (pullbackShiftIso C φ 0 0 (by simp)).hom.app X ≫ (shiftFunctorZero C B).hom.app X := by\n  rw [← cancel_epi ((shiftFunctorZero _ A).inv.app X), Iso.inv_hom_id_app,\n    pullbackShiftFunctorZero_inv_app, assoc, Iso.inv_hom_id_app_assoc, Iso.inv_hom_id_app]\n  rfl\n\n"}
{"name":"CategoryTheory.pullbackShiftFunctorZero'_inv_app","module":"Mathlib.CategoryTheory.Shift.Pullback","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_4, u_1} C\nA : Type u_2\nB : Type u_3\ninst✝² : AddMonoid A\ninst✝¹ : AddMonoid B\nφ : AddMonoidHom A B\ninst✝ : CategoryTheory.HasShift C B\nX : CategoryTheory.PullbackShift C φ\n⊢ Eq ((CategoryTheory.shiftFunctorZero (CategoryTheory.PullbackShift C φ) A).inv.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorZero' C (φ 0) ⋯).inv.app X) ((CategoryTheory.pullbackShiftIso C φ 0 (φ 0) ⋯).inv.app X))","decl":"lemma pullbackShiftFunctorZero'_inv_app :\n    (shiftFunctorZero _ A).inv.app X = (shiftFunctorZero' C (φ 0) (by rw [map_zero])).inv.app X ≫\n      (pullbackShiftIso C φ 0 (φ 0) rfl).inv.app X := by\n  rw [pullbackShiftFunctorZero_inv_app]\n  simp only [Functor.id_obj, pullbackShiftIso, eqToIso.inv, eqToHom_app, shiftFunctorZero',\n    Iso.trans_inv, NatTrans.comp_app, eqToIso_refl, Iso.refl_inv, NatTrans.id_app, assoc]\n  erw [comp_id]\n\n"}
{"name":"CategoryTheory.pullbackShiftFunctorZero'_hom_app","module":"Mathlib.CategoryTheory.Shift.Pullback","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_4, u_1} C\nA : Type u_2\nB : Type u_3\ninst✝² : AddMonoid A\ninst✝¹ : AddMonoid B\nφ : AddMonoidHom A B\ninst✝ : CategoryTheory.HasShift C B\nX : CategoryTheory.PullbackShift C φ\n⊢ Eq ((CategoryTheory.shiftFunctorZero (CategoryTheory.PullbackShift C φ) A).hom.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.pullbackShiftIso C φ 0 (φ 0) ⋯).hom.app X) ((CategoryTheory.shiftFunctorZero' C (φ 0) ⋯).hom.app X))","decl":"lemma pullbackShiftFunctorZero'_hom_app :\n    (shiftFunctorZero _ A).hom.app X = (pullbackShiftIso C φ 0 (φ 0) rfl).hom.app X ≫\n      (shiftFunctorZero' C (φ 0) (by rw [map_zero])).hom.app X := by\n  rw [← cancel_epi ((shiftFunctorZero _ A).inv.app X), Iso.inv_hom_id_app,\n    pullbackShiftFunctorZero'_inv_app, assoc, Iso.inv_hom_id_app_assoc, Iso.inv_hom_id_app]\n  rfl\n\n"}
{"name":"CategoryTheory.pullbackShiftFunctorAdd'_inv_app","module":"Mathlib.CategoryTheory.Shift.Pullback","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_4, u_1} C\nA : Type u_2\nB : Type u_3\ninst✝² : AddMonoid A\ninst✝¹ : AddMonoid B\nφ : AddMonoidHom A B\ninst✝ : CategoryTheory.HasShift C B\nX : CategoryTheory.PullbackShift C φ\na₁ a₂ a₃ : A\nh : Eq (HAdd.hAdd a₁ a₂) a₃\nb₁ b₂ b₃ : B\nh₁ : Eq b₁ (φ a₁)\nh₂ : Eq b₂ (φ a₂)\nh₃ : Eq b₃ (φ a₃)\n⊢ Eq ((CategoryTheory.shiftFunctorAdd' (CategoryTheory.PullbackShift C φ) a₁ a₂ a₃ h).inv.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor (CategoryTheory.PullbackShift C φ) a₂).map ((CategoryTheory.pullbackShiftIso C φ a₁ b₁ h₁).hom.app X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.pullbackShiftIso C φ a₂ b₂ h₂).hom.app ((CategoryTheory.shiftFunctor C b₁).obj X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd' C b₁ b₂ b₃ ⋯).inv.app X) ((CategoryTheory.pullbackShiftIso C φ a₃ b₃ h₃).inv.app X))))","decl":"lemma pullbackShiftFunctorAdd'_inv_app :\n    (shiftFunctorAdd' _ a₁ a₂ a₃ h).inv.app X =\n      (shiftFunctor (PullbackShift C φ) a₂).map ((pullbackShiftIso C φ a₁ b₁ h₁).hom.app X) ≫\n        (pullbackShiftIso C φ a₂ b₂ h₂).hom.app _ ≫\n        (shiftFunctorAdd' C b₁ b₂ b₃ (by rw [h₁, h₂, h₃, ← h, φ.map_add])).inv.app X ≫\n        (pullbackShiftIso C φ a₃ b₃ h₃).inv.app X := by\n  subst h₁ h₂ h\n  obtain rfl : b₃ = φ a₁ + φ a₂ := by rw [h₃, φ.map_add]\n  simp\n  erw [Functor.map_id, id_comp, id_comp, shiftFunctorAdd'_eq_shiftFunctorAdd,\n    shiftFunctorAdd'_eq_shiftFunctorAdd]\n  change _ ≫ _ = _\n  congr 1\n  rw [Discrete.addMonoidalFunctor_μ]\n  dsimp [Discrete.eqToHom]\n  congr 2\n  apply eqToHom_map\n\n"}
{"name":"CategoryTheory.pullbackShiftFunctorAdd'_hom_app","module":"Mathlib.CategoryTheory.Shift.Pullback","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_4, u_1} C\nA : Type u_2\nB : Type u_3\ninst✝² : AddMonoid A\ninst✝¹ : AddMonoid B\nφ : AddMonoidHom A B\ninst✝ : CategoryTheory.HasShift C B\nX : CategoryTheory.PullbackShift C φ\na₁ a₂ a₃ : A\nh : Eq (HAdd.hAdd a₁ a₂) a₃\nb₁ b₂ b₃ : B\nh₁ : Eq b₁ (φ a₁)\nh₂ : Eq b₂ (φ a₂)\nh₃ : Eq b₃ (φ a₃)\n⊢ Eq ((CategoryTheory.shiftFunctorAdd' (CategoryTheory.PullbackShift C φ) a₁ a₂ a₃ h).hom.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.pullbackShiftIso C φ a₃ b₃ h₃).hom.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd' C b₁ b₂ b₃ ⋯).hom.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.pullbackShiftIso C φ a₂ b₂ h₂).inv.app ((CategoryTheory.shiftFunctor C b₁).obj X)) ((CategoryTheory.shiftFunctor (CategoryTheory.PullbackShift C φ) a₂).map ((CategoryTheory.pullbackShiftIso C φ a₁ b₁ h₁).inv.app X)))))","decl":"lemma pullbackShiftFunctorAdd'_hom_app :\n    (shiftFunctorAdd' _ a₁ a₂ a₃ h).hom.app X =\n      (pullbackShiftIso C φ a₃ b₃ h₃).hom.app X ≫\n      (shiftFunctorAdd' C b₁ b₂ b₃ (by rw [h₁, h₂, h₃, ← h, φ.map_add])).hom.app X ≫\n      (pullbackShiftIso C φ a₂ b₂ h₂).inv.app _ ≫\n      (shiftFunctor (PullbackShift C φ) a₂).map ((pullbackShiftIso C φ a₁ b₁ h₁).inv.app X) := by\n  rw [← cancel_epi ((shiftFunctorAdd' _ a₁ a₂ a₃ h).inv.app X), Iso.inv_hom_id_app,\n    pullbackShiftFunctorAdd'_inv_app φ X a₁ a₂ a₃ h b₁ b₂ b₃ h₁ h₂ h₃, assoc, assoc, assoc,\n    Iso.inv_hom_id_app_assoc, Iso.inv_hom_id_app_assoc, Iso.hom_inv_id_app_assoc,\n    ← Functor.map_comp, Iso.hom_inv_id_app, Functor.map_id]\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.commShiftPullback_iso_eq","module":"Mathlib.CategoryTheory.Shift.Pullback","initialProofState":"C : Type u_1\ninst✝⁶ : CategoryTheory.Category.{u_6, u_1} C\nA : Type u_2\nB : Type u_3\ninst✝⁵ : AddMonoid A\ninst✝⁴ : AddMonoid B\nφ : AddMonoidHom A B\ninst✝³ : CategoryTheory.HasShift C B\nD : Type u_4\ninst✝² : CategoryTheory.Category.{u_5, u_4} D\ninst✝¹ : CategoryTheory.HasShift D B\nF : CategoryTheory.Functor C D\ninst✝ : F.CommShift B\na : A\nb : B\nh : Eq b (φ a)\n⊢ Eq ((CategoryTheory.PullbackShift.functor φ F).commShiftIso a) ((CategoryTheory.isoWhiskerRight (CategoryTheory.pullbackShiftIso C φ a b h) F).trans ((F.commShiftIso b).trans (CategoryTheory.isoWhiskerLeft F (CategoryTheory.pullbackShiftIso D φ a b h).symm)))","decl":"lemma commShiftPullback_iso_eq (a : A) (b : B) (h : b = φ a) :\n    (PullbackShift.functor φ F).commShiftIso a (C := PullbackShift C φ) (D := PullbackShift D φ) =\n      isoWhiskerRight (pullbackShiftIso C φ a b h) F ≪≫ (F.commShiftIso b) ≪≫\n        isoWhiskerLeft F (pullbackShiftIso D φ a b h).symm := by\n  obtain rfl : b = φ a := h\n  rfl\n\n"}
{"name":"CategoryTheory.NatTrans.commShiftPullback","module":"Mathlib.CategoryTheory.Shift.Pullback","initialProofState":"C : Type u_1\ninst✝⁸ : CategoryTheory.Category.{u_6, u_1} C\nA : Type u_2\nB : Type u_3\ninst✝⁷ : AddMonoid A\ninst✝⁶ : AddMonoid B\nφ : AddMonoidHom A B\ninst✝⁵ : CategoryTheory.HasShift C B\nD : Type u_4\ninst✝⁴ : CategoryTheory.Category.{u_5, u_4} D\ninst✝³ : CategoryTheory.HasShift D B\nF : CategoryTheory.Functor C D\ninst✝² : F.CommShift B\nG : CategoryTheory.Functor C D\ninst✝¹ : G.CommShift B\nτ : Quiver.Hom F G\ninst✝ : CategoryTheory.NatTrans.CommShift τ B\n⊢ CategoryTheory.NatTrans.CommShift (CategoryTheory.PullbackShift.natTrans φ τ) A","decl":"open Functor in\ninstance commShiftPullback (τ : F ⟶ G) [NatTrans.CommShift τ B] :\n    NatTrans.CommShift (PullbackShift.natTrans φ τ) A where\n  shift_comm _ := by\n    ext\n    dsimp [PullbackShift.natTrans]\n    simp only [commShiftPullback_iso_eq φ _ _ _ rfl, Iso.trans_hom, isoWhiskerRight_hom,\n      isoWhiskerLeft_hom, Iso.symm_hom, comp_app, comp_obj, whiskerRight_app, whiskerLeft_app,\n      assoc]\n    rw [← τ.naturality_assoc]\n    simp  [← NatTrans.shift_app_comm_assoc]\n\n"}
{"name":"CategoryTheory.NatTrans.instCommShiftPullbackShiftHomFunctorNatIsoId","module":"Mathlib.CategoryTheory.Shift.Pullback","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_5, u_1} C\nA : Type u_2\nB : Type u_3\ninst✝² : AddMonoid A\ninst✝¹ : AddMonoid B\nφ : AddMonoidHom A B\ninst✝ : CategoryTheory.HasShift C B\n⊢ CategoryTheory.NatTrans.CommShift (CategoryTheory.NatTrans.PullbackShift.natIsoId C φ).hom A","decl":"/--\nThis expresses the compatibility between two `CommShift` structures by `A` on (synonyms of)\n`𝟭 C`: the canonical `CommShift` structure on `𝟭 (PullbackShift C φ)`, and the `CommShift`\nstructure on `PullbackShift.functor (𝟭 C) φ` (i.e the pullback of the canonical `CommShift`\nstructure on `𝟭 C`).\n-/\ninstance : NatTrans.CommShift (PullbackShift.natIsoId C φ).hom A where\n  shift_comm _ := by\n    ext\n    simp [PullbackShift.natIsoId, Functor.commShiftPullback_iso_eq]\n\n"}
{"name":"CategoryTheory.NatTrans.instCommShiftPullbackShiftHomFunctorNatIsoComp","module":"Mathlib.CategoryTheory.Shift.Pullback","initialProofState":"C : Type u_1\ninst✝⁹ : CategoryTheory.Category.{u_6, u_1} C\nA : Type u_2\nB : Type u_3\ninst✝⁸ : AddMonoid A\ninst✝⁷ : AddMonoid B\nφ : AddMonoidHom A B\ninst✝⁶ : CategoryTheory.HasShift C B\nD : Type u_4\ninst✝⁵ : CategoryTheory.Category.{u_8, u_4} D\ninst✝⁴ : CategoryTheory.HasShift D B\nF : CategoryTheory.Functor C D\ninst✝³ : F.CommShift B\nE : Type u_5\ninst✝² : CategoryTheory.Category.{u_7, u_5} E\ninst✝¹ : CategoryTheory.HasShift E B\nG : CategoryTheory.Functor D E\ninst✝ : G.CommShift B\n⊢ CategoryTheory.NatTrans.CommShift (CategoryTheory.NatTrans.PullbackShift.natIsoComp φ F G).hom A","decl":"open Functor in\ninstance : NatTrans.CommShift (PullbackShift.natIsoComp φ F G).hom A where\n  shift_comm _ := by\n    ext\n    dsimp [PullbackShift.natIsoComp]\n    simp only [commShiftPullback_iso_eq φ _ _ _ rfl, Iso.trans_hom, isoWhiskerRight_hom,\n      isoWhiskerLeft_hom, Iso.symm_hom, comp_app, comp_obj, whiskerRight_app, Functor.comp_map,\n      commShiftIso_comp_hom_app, whiskerLeft_app, assoc, map_id, comp_id, map_comp, id_comp]\n    dsimp [PullbackShift.functor]\n    slice_rhs 3 4 => rw [← G.map_comp, Iso.inv_hom_id_app]\n    simp\n\n"}
{"name":"CategoryTheory.PullbackShift.adjunction_counit","module":"Mathlib.CategoryTheory.Shift.Pullback","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_5, u_1} C\nA : Type u_2\nB : Type u_3\ninst✝⁴ : AddMonoid A\ninst✝³ : AddMonoid B\nφ : AddMonoidHom A B\ninst✝² : CategoryTheory.HasShift C B\nD : Type u_4\ninst✝¹ : CategoryTheory.Category.{u_6, u_4} D\ninst✝ : CategoryTheory.HasShift D B\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\n⊢ Eq (CategoryTheory.PullbackShift.adjunction φ adj).counit (CategoryTheory.CategoryStruct.comp (CategoryTheory.NatTrans.PullbackShift.natIsoComp φ G F).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.PullbackShift.natTrans φ adj.counit) (CategoryTheory.NatTrans.PullbackShift.natIsoId D φ).inv))","decl":"/--\nThe adjunction `adj`, seen as an adjunction between `PullbackShift.functor F φ`\nand `PullbackShift.functor G φ`.\n-/\n@[simps (config := .lemmasOnly)]\ndef PullbackShift.adjunction {F} {G : D ⥤ C} (adj : F ⊣ G) :\n    PullbackShift.functor φ F ⊣ PullbackShift.functor φ G where\n  unit := (NatTrans.PullbackShift.natIsoId C φ).hom ≫\n    PullbackShift.natTrans φ adj.unit ≫ (NatTrans.PullbackShift.natIsoComp φ F G).hom\n  counit := (NatTrans.PullbackShift.natIsoComp φ G F).inv ≫\n    PullbackShift.natTrans φ adj.counit ≫ (NatTrans.PullbackShift.natIsoId D φ).inv\n  left_triangle_components _ := by\n    simp [PullbackShift.natTrans, NatTrans.PullbackShift.natIsoComp,\n      NatTrans.PullbackShift.natIsoId, PullbackShift.functor]\n  right_triangle_components _ := by\n    simp [PullbackShift.natTrans, NatTrans.PullbackShift.natIsoComp,\n      NatTrans.PullbackShift.natIsoId, PullbackShift.functor]\n\n"}
{"name":"CategoryTheory.PullbackShift.adjunction_unit","module":"Mathlib.CategoryTheory.Shift.Pullback","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_5, u_1} C\nA : Type u_2\nB : Type u_3\ninst✝⁴ : AddMonoid A\ninst✝³ : AddMonoid B\nφ : AddMonoidHom A B\ninst✝² : CategoryTheory.HasShift C B\nD : Type u_4\ninst✝¹ : CategoryTheory.Category.{u_6, u_4} D\ninst✝ : CategoryTheory.HasShift D B\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\n⊢ Eq (CategoryTheory.PullbackShift.adjunction φ adj).unit (CategoryTheory.CategoryStruct.comp (CategoryTheory.NatTrans.PullbackShift.natIsoId C φ).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.PullbackShift.natTrans φ adj.unit) (CategoryTheory.NatTrans.PullbackShift.natIsoComp φ F G).hom))","decl":"/--\nThe adjunction `adj`, seen as an adjunction between `PullbackShift.functor F φ`\nand `PullbackShift.functor G φ`.\n-/\n@[simps (config := .lemmasOnly)]\ndef PullbackShift.adjunction {F} {G : D ⥤ C} (adj : F ⊣ G) :\n    PullbackShift.functor φ F ⊣ PullbackShift.functor φ G where\n  unit := (NatTrans.PullbackShift.natIsoId C φ).hom ≫\n    PullbackShift.natTrans φ adj.unit ≫ (NatTrans.PullbackShift.natIsoComp φ F G).hom\n  counit := (NatTrans.PullbackShift.natIsoComp φ G F).inv ≫\n    PullbackShift.natTrans φ adj.counit ≫ (NatTrans.PullbackShift.natIsoId D φ).inv\n  left_triangle_components _ := by\n    simp [PullbackShift.natTrans, NatTrans.PullbackShift.natIsoComp,\n      NatTrans.PullbackShift.natIsoId, PullbackShift.functor]\n  right_triangle_components _ := by\n    simp [PullbackShift.natTrans, NatTrans.PullbackShift.natIsoComp,\n      NatTrans.PullbackShift.natIsoId, PullbackShift.functor]\n\n"}
{"name":"CategoryTheory.Adjunction.commShiftPullback","module":"Mathlib.CategoryTheory.Shift.Pullback","initialProofState":"C : Type u_1\ninst✝⁸ : CategoryTheory.Category.{u_5, u_1} C\nA : Type u_2\nB : Type u_3\ninst✝⁷ : AddMonoid A\ninst✝⁶ : AddMonoid B\nφ : AddMonoidHom A B\ninst✝⁵ : CategoryTheory.HasShift C B\nD : Type u_4\ninst✝⁴ : CategoryTheory.Category.{u_6, u_4} D\ninst✝³ : CategoryTheory.HasShift D B\nF : CategoryTheory.Functor C D\ninst✝² : F.CommShift B\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst✝¹ : G.CommShift B\ninst✝ : adj.CommShift B\n⊢ (CategoryTheory.PullbackShift.adjunction φ adj).CommShift A","decl":"/--\nIf an adjunction `F ⊣ G` is compatible with `CommShift` structures on `F` and `G`, then\nit is also compatible with the pulled back `CommShift` structures by an additive map\n`φ : B →+ A`.\n-/\ninstance commShiftPullback [adj.CommShift B] : (PullbackShift.adjunction φ adj).CommShift A where\n  commShift_unit := by\n    dsimp [PullbackShift.adjunction]\n    infer_instance\n  commShift_counit := by\n    dsimp [PullbackShift.adjunction]\n    infer_instance\n\n"}
