{"name":"Tree.comp_traverse","module":"Mathlib.Data.Tree.Traversable","initialProofState":"α : Type u_1\nF : Type u → Type v\nG : Type v → Type w\ninst✝² : Applicative F\ninst✝¹ : Applicative G\ninst✝ : LawfulApplicative G\nβ : Type v\nγ : Type u\nf : β → F γ\ng : α → G β\nt : Tree α\n⊢ Eq (Tree.traverse (Function.comp Functor.Comp.mk (Function.comp (fun x => Functor.map f x) g)) t) (Functor.Comp.mk (Functor.map (fun x => Tree.traverse f x) (Tree.traverse g t)))","decl":"lemma comp_traverse\n    {F : Type u → Type v} {G : Type v → Type w} [Applicative F] [Applicative G]\n    [LawfulApplicative G] {β : Type v} {γ : Type u} (f : β → F γ) (g : α → G β)\n    (t : Tree α) : t.traverse (Functor.Comp.mk ∘ (f <$> ·) ∘ g) =\n      Functor.Comp.mk ((·.traverse f) <$> (t.traverse g)) := by\n  induction t with\n  | nil => rw [traverse, traverse, map_pure, traverse]; rfl\n  | node v l r hl hr =>\n    rw [traverse, hl, hr, traverse]\n    simp only [Function.comp_def, Function.comp_apply, Functor.Comp.map_mk, Functor.map_map,\n      Comp.seq_mk, seq_map_assoc, map_seq]\n    rfl\n\n"}
{"name":"Tree.traverse_eq_map_id","module":"Mathlib.Data.Tree.Traversable","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nt : Tree α\n⊢ Eq (Tree.traverse (Function.comp Pure.pure f) t) (Tree.map f t)","decl":"lemma traverse_eq_map_id (f : α → β) (t : Tree α) :\n    t.traverse ((pure : β → Id β) ∘ f) = t.map f := by\n  rw [← Id.pure_eq (t.map f)]\n  induction t with\n  | nil => rw [traverse, map]\n  | node v l r hl hr =>\n    rw [traverse, map, hl, hr, Function.comp_apply, map_pure, pure_seq, map_pure, pure_seq,\n      map_pure]\n\n"}
{"name":"Tree.naturality","module":"Mathlib.Data.Tree.Traversable","initialProofState":"α : Type u_1\nF : Type u → Type u_3\nG : Type u → Type u_4\ninst✝³ : Applicative F\ninst✝² : Applicative G\ninst✝¹ : LawfulApplicative F\ninst✝ : LawfulApplicative G\nη : ApplicativeTransformation F G\nβ : Type u\nf : α → F β\nt : Tree α\n⊢ Eq ((fun {α} => η.app α) (Tree.traverse f t)) (Tree.traverse (Function.comp (η.app β) f) t)","decl":"lemma naturality {F G : Type u → Type*} [Applicative F] [Applicative G] [LawfulApplicative F]\n    [LawfulApplicative G] (η : ApplicativeTransformation F G) {β : Type u} (f : α → F β)\n    (t : Tree α) : η (t.traverse f) = t.traverse (η.app β ∘ f : α → G β) := by\n  induction t with\n  | nil => rw [traverse, traverse, η.preserves_pure]\n  | node v l r hl hr =>\n    rw [traverse, traverse, η.preserves_seq, η.preserves_seq, η.preserves_map, hl, hr,\n      Function.comp_apply]\n\n"}
{"name":"Tree.instLawfulTraversable","module":"Mathlib.Data.Tree.Traversable","initialProofState":"⊢ LawfulTraversable Tree","decl":"instance : LawfulTraversable Tree where\n  map_const := rfl\n  id_map := id_map\n  comp_map := comp_map\n  id_traverse t := traverse_pure t\n  comp_traverse := comp_traverse\n  traverse_eq_map_id := traverse_eq_map_id\n  naturality η := naturality η\n\n"}
