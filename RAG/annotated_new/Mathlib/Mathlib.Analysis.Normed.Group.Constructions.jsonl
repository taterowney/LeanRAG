{"name":"PUnit.norm_eq_zero","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"x : PUnit.{u_5 + 1}\n⊢ Eq (Norm.norm x) 0","decl":"@[simp] lemma norm_eq_zero (x : PUnit) : ‖x‖ = 0 := rfl\n\n"}
{"name":"ULift.norm_def","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"E : Type u_2\ninst✝ : Norm E\nx : ULift.{u_5, u_2} E\n⊢ Eq (Norm.norm x) (Norm.norm x.down)","decl":"lemma norm_def (x : ULift E) : ‖x‖ = ‖x.down‖ := rfl\n\n"}
{"name":"ULift.norm_up","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"E : Type u_2\ninst✝ : Norm E\nx : E\n⊢ Eq (Norm.norm { down := x }) (Norm.norm x)","decl":"@[simp] lemma norm_up (x : E) : ‖ULift.up x‖ = ‖x‖ := rfl\n\n"}
{"name":"ULift.norm_down","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"E : Type u_2\ninst✝ : Norm E\nx : ULift.{u_5, u_2} E\n⊢ Eq (Norm.norm x.down) (Norm.norm x)","decl":"@[simp] lemma norm_down (x : ULift E) : ‖x.down‖ = ‖x‖ := rfl\n\n"}
{"name":"ULift.nnnorm_def","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"E : Type u_2\ninst✝ : NNNorm E\nx : ULift.{u_5, u_2} E\n⊢ Eq (NNNorm.nnnorm x) (NNNorm.nnnorm x.down)","decl":"lemma nnnorm_def (x : ULift E) : ‖x‖₊ = ‖x.down‖₊ := rfl\n\n"}
{"name":"ULift.nnnorm_up","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"E : Type u_2\ninst✝ : NNNorm E\nx : E\n⊢ Eq (NNNorm.nnnorm { down := x }) (NNNorm.nnnorm x)","decl":"@[simp] lemma nnnorm_up (x : E) : ‖ULift.up x‖₊ = ‖x‖₊ := rfl\n\n"}
{"name":"ULift.nnnorm_down","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"E : Type u_2\ninst✝ : NNNorm E\nx : ULift.{u_5, u_2} E\n⊢ Eq (NNNorm.nnnorm x.down) (NNNorm.nnnorm x)","decl":"@[simp] lemma nnnorm_down (x : ULift E) : ‖x.down‖₊ = ‖x‖₊ := rfl\n\n"}
{"name":"norm_toMul","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"E : Type u_2\ninst✝ : Norm E\nx : Additive E\n⊢ Eq (Norm.norm (Additive.toMul x)) (Norm.norm x)","decl":"@[simp] lemma norm_toMul (x : Additive E) : ‖(x.toMul : E)‖ = ‖x‖ := rfl\n\n"}
{"name":"norm_ofMul","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"E : Type u_2\ninst✝ : Norm E\nx : E\n⊢ Eq (Norm.norm (Additive.ofMul x)) (Norm.norm x)","decl":"@[simp] lemma norm_ofMul (x : E) : ‖ofMul x‖ = ‖x‖ := rfl\n\n"}
{"name":"norm_toAdd","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"E : Type u_2\ninst✝ : Norm E\nx : Multiplicative E\n⊢ Eq (Norm.norm (Multiplicative.toAdd x)) (Norm.norm x)","decl":"@[simp] lemma norm_toAdd (x : Multiplicative E) : ‖(x.toAdd : E)‖ = ‖x‖ := rfl\n\n"}
{"name":"norm_ofAdd","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"E : Type u_2\ninst✝ : Norm E\nx : E\n⊢ Eq (Norm.norm (Multiplicative.ofAdd x)) (Norm.norm x)","decl":"@[simp] lemma norm_ofAdd (x : E) : ‖ofAdd x‖ = ‖x‖ := rfl\n\n"}
{"name":"nnnorm_toMul","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"E : Type u_2\ninst✝ : NNNorm E\nx : Additive E\n⊢ Eq (NNNorm.nnnorm (Additive.toMul x)) (NNNorm.nnnorm x)","decl":"@[simp] lemma nnnorm_toMul (x : Additive E) : ‖(x.toMul : E)‖₊ = ‖x‖₊ := rfl\n\n"}
{"name":"nnnorm_ofMul","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"E : Type u_2\ninst✝ : NNNorm E\nx : E\n⊢ Eq (NNNorm.nnnorm (Additive.ofMul x)) (NNNorm.nnnorm x)","decl":"@[simp] lemma nnnorm_ofMul (x : E) : ‖ofMul x‖₊ = ‖x‖₊ := rfl\n\n"}
{"name":"nnnorm_toAdd","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"E : Type u_2\ninst✝ : NNNorm E\nx : Multiplicative E\n⊢ Eq (NNNorm.nnnorm (Multiplicative.toAdd x)) (NNNorm.nnnorm x)","decl":"@[simp] lemma nnnorm_toAdd (x : Multiplicative E) : ‖(x.toAdd : E)‖₊ = ‖x‖₊ := rfl\n\n"}
{"name":"nnnorm_ofAdd","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"E : Type u_2\ninst✝ : NNNorm E\nx : E\n⊢ Eq (NNNorm.nnnorm (Multiplicative.ofAdd x)) (NNNorm.nnnorm x)","decl":"@[simp] lemma nnnorm_ofAdd (x : E) : ‖ofAdd x‖₊ = ‖x‖₊ := rfl\n\n"}
{"name":"norm_toDual","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"E : Type u_2\ninst✝ : Norm E\nx : E\n⊢ Eq (Norm.norm (OrderDual.toDual x)) (Norm.norm x)","decl":"@[simp] lemma norm_toDual (x : E) : ‖toDual x‖ = ‖x‖ := rfl\n\n"}
{"name":"norm_ofDual","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"E : Type u_2\ninst✝ : Norm E\nx : OrderDual E\n⊢ Eq (Norm.norm (OrderDual.ofDual x)) (Norm.norm x)","decl":"@[simp] lemma norm_ofDual (x : Eᵒᵈ) : ‖ofDual x‖ = ‖x‖ := rfl\n\n"}
{"name":"nnnorm_toDual","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"E : Type u_2\ninst✝ : NNNorm E\nx : E\n⊢ Eq (NNNorm.nnnorm (OrderDual.toDual x)) (NNNorm.nnnorm x)","decl":"@[simp] lemma nnnorm_toDual (x : E) : ‖toDual x‖₊ = ‖x‖₊ := rfl\n\n"}
{"name":"nnnorm_ofDual","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"E : Type u_2\ninst✝ : NNNorm E\nx : OrderDual E\n⊢ Eq (NNNorm.nnnorm (OrderDual.ofDual x)) (NNNorm.nnnorm x)","decl":"@[simp] lemma nnnorm_ofDual (x : Eᵒᵈ) : ‖ofDual x‖₊ = ‖x‖₊ := rfl\n\n"}
{"name":"Prod.norm_def","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"E : Type u_2\nF : Type u_3\ninst✝¹ : Norm E\ninst✝ : Norm F\nx : Prod E F\n⊢ Eq (Norm.norm x) (Max.max (Norm.norm x.1) (Norm.norm x.2))","decl":"lemma Prod.norm_def (x : E × F) : ‖x‖ = max ‖x.1‖ ‖x.2‖ := rfl\n\n"}
{"name":"Prod.norm_mk","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"E : Type u_2\nF : Type u_3\ninst✝¹ : Norm E\ninst✝ : Norm F\nx : E\ny : F\n⊢ Eq (Norm.norm { fst := x, snd := y }) (Max.max (Norm.norm x) (Norm.norm y))","decl":"@[simp] lemma Prod.norm_mk (x : E) (y : F) : ‖(x, y)‖ = max ‖x‖ ‖y‖ := rfl\n\n"}
{"name":"norm_fst_le","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"E : Type u_2\nF : Type u_3\ninst✝¹ : Norm E\ninst✝ : Norm F\nx : Prod E F\n⊢ LE.le (Norm.norm x.1) (Norm.norm x)","decl":"lemma norm_fst_le (x : E × F) : ‖x.1‖ ≤ ‖x‖ := le_max_left _ _\n\n"}
{"name":"norm_snd_le","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"E : Type u_2\nF : Type u_3\ninst✝¹ : Norm E\ninst✝ : Norm F\nx : Prod E F\n⊢ LE.le (Norm.norm x.2) (Norm.norm x)","decl":"lemma norm_snd_le (x : E × F) : ‖x.2‖ ≤ ‖x‖ := le_max_right _ _\n\n"}
{"name":"norm_prod_le_iff","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"E : Type u_2\nF : Type u_3\ninst✝¹ : Norm E\ninst✝ : Norm F\nx : Prod E F\nr : Real\n⊢ Iff (LE.le (Norm.norm x) r) (And (LE.le (Norm.norm x.1) r) (LE.le (Norm.norm x.2) r))","decl":"lemma norm_prod_le_iff : ‖x‖ ≤ r ↔ ‖x.1‖ ≤ r ∧ ‖x.2‖ ≤ r := max_le_iff\n\n"}
{"name":"Prod.nnnorm_def","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"E : Type u_2\nF : Type u_3\ninst✝¹ : SeminormedAddGroup E\ninst✝ : SeminormedAddGroup F\nx : Prod E F\n⊢ Eq (NNNorm.nnnorm x) (Max.max (NNNorm.nnnorm x.1) (NNNorm.nnnorm x.2))","decl":"/-- Multiplicative version of `Prod.nnnorm_def`.\nEarlier, this names was used for the additive version. -/\n@[to_additive Prod.nnnorm_def]\nlemma Prod.nnnorm_def' (x : E × F) : ‖x‖₊ = max ‖x.1‖₊ ‖x.2‖₊ := rfl\n\n"}
{"name":"Prod.nnnorm_def'","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"E : Type u_2\nF : Type u_3\ninst✝¹ : SeminormedGroup E\ninst✝ : SeminormedGroup F\nx : Prod E F\n⊢ Eq (NNNorm.nnnorm x) (Max.max (NNNorm.nnnorm x.1) (NNNorm.nnnorm x.2))","decl":"/-- Multiplicative version of `Prod.nnnorm_def`.\nEarlier, this names was used for the additive version. -/\n@[to_additive Prod.nnnorm_def]\nlemma Prod.nnnorm_def' (x : E × F) : ‖x‖₊ = max ‖x.1‖₊ ‖x.2‖₊ := rfl\n\n"}
{"name":"Prod.nnorm_def","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"E : Type u_2\nF : Type u_3\ninst✝¹ : SeminormedGroup E\ninst✝ : SeminormedGroup F\nx : Prod E F\n⊢ Eq (NNNorm.nnnorm x) (Max.max (NNNorm.nnnorm x.1) (NNNorm.nnnorm x.2))","decl":"@[deprecated (since := \"2025-01-02\")] alias Prod.nnorm_def := Prod.nnnorm_def'\n\n"}
{"name":"Prod.nnnorm_mk'","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"E : Type u_2\nF : Type u_3\ninst✝¹ : SeminormedGroup E\ninst✝ : SeminormedGroup F\nx : E\ny : F\n⊢ Eq (NNNorm.nnnorm { fst := x, snd := y }) (Max.max (NNNorm.nnnorm x) (NNNorm.nnnorm y))","decl":"/-- Multiplicative version of `Prod.nnnorm_mk`. -/\n@[to_additive (attr := simp) Prod.nnnorm_mk]\nlemma Prod.nnnorm_mk' (x : E) (y : F) : ‖(x, y)‖₊ = max ‖x‖₊ ‖y‖₊ := rfl\n\n"}
{"name":"Prod.nnnorm_mk","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"E : Type u_2\nF : Type u_3\ninst✝¹ : SeminormedAddGroup E\ninst✝ : SeminormedAddGroup F\nx : E\ny : F\n⊢ Eq (NNNorm.nnnorm { fst := x, snd := y }) (Max.max (NNNorm.nnnorm x) (NNNorm.nnnorm y))","decl":"/-- Multiplicative version of `Prod.nnnorm_mk`. -/\n@[to_additive (attr := simp) Prod.nnnorm_mk]\nlemma Prod.nnnorm_mk' (x : E) (y : F) : ‖(x, y)‖₊ = max ‖x‖₊ ‖y‖₊ := rfl\n\n"}
{"name":"Pi.norm_def'","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"ι : Type u_1\nπ : ι → Type u_4\ninst✝¹ : Fintype ι\ninst✝ : (i : ι) → SeminormedGroup (π i)\nf : (i : ι) → π i\n⊢ Eq (Norm.norm f) ↑(Finset.univ.sup fun b => NNNorm.nnnorm (f b))","decl":"@[to_additive Pi.norm_def]\nlemma Pi.norm_def' : ‖f‖ = ↑(Finset.univ.sup fun b => ‖f b‖₊) := rfl\n\n"}
{"name":"Pi.norm_def","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"ι : Type u_1\nπ : ι → Type u_4\ninst✝¹ : Fintype ι\ninst✝ : (i : ι) → SeminormedAddGroup (π i)\nf : (i : ι) → π i\n⊢ Eq (Norm.norm f) ↑(Finset.univ.sup fun b => NNNorm.nnnorm (f b))","decl":"@[to_additive Pi.norm_def]\nlemma Pi.norm_def' : ‖f‖ = ↑(Finset.univ.sup fun b => ‖f b‖₊) := rfl\n\n"}
{"name":"Pi.nnnorm_def","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"ι : Type u_1\nπ : ι → Type u_4\ninst✝¹ : Fintype ι\ninst✝ : (i : ι) → SeminormedAddGroup (π i)\nf : (i : ι) → π i\n⊢ Eq (NNNorm.nnnorm f) (Finset.univ.sup fun b => NNNorm.nnnorm (f b))","decl":"@[to_additive Pi.nnnorm_def]\nlemma Pi.nnnorm_def' : ‖f‖₊ = Finset.univ.sup fun b => ‖f b‖₊ := Subtype.eta _ _\n\n"}
{"name":"Pi.nnnorm_def'","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"ι : Type u_1\nπ : ι → Type u_4\ninst✝¹ : Fintype ι\ninst✝ : (i : ι) → SeminormedGroup (π i)\nf : (i : ι) → π i\n⊢ Eq (NNNorm.nnnorm f) (Finset.univ.sup fun b => NNNorm.nnnorm (f b))","decl":"@[to_additive Pi.nnnorm_def]\nlemma Pi.nnnorm_def' : ‖f‖₊ = Finset.univ.sup fun b => ‖f b‖₊ := Subtype.eta _ _\n\n"}
{"name":"pi_norm_le_iff_of_nonneg'","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"ι : Type u_1\nπ : ι → Type u_4\ninst✝¹ : Fintype ι\ninst✝ : (i : ι) → SeminormedGroup (π i)\nx : (i : ι) → π i\nr : Real\nhr : LE.le 0 r\n⊢ Iff (LE.le (Norm.norm x) r) (∀ (i : ι), LE.le (Norm.norm (x i)) r)","decl":"/-- The seminorm of an element in a product space is `≤ r` if and only if the norm of each\ncomponent is. -/\n@[to_additive pi_norm_le_iff_of_nonneg \"The seminorm of an element in a product space is `≤ r` if\nand only if the norm of each component is.\"]\nlemma pi_norm_le_iff_of_nonneg' (hr : 0 ≤ r) : ‖x‖ ≤ r ↔ ∀ i, ‖x i‖ ≤ r := by\n  simp only [← dist_one_right, dist_pi_le_iff hr, Pi.one_apply]\n\n"}
{"name":"pi_norm_le_iff_of_nonneg","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"ι : Type u_1\nπ : ι → Type u_4\ninst✝¹ : Fintype ι\ninst✝ : (i : ι) → SeminormedAddGroup (π i)\nx : (i : ι) → π i\nr : Real\nhr : LE.le 0 r\n⊢ Iff (LE.le (Norm.norm x) r) (∀ (i : ι), LE.le (Norm.norm (x i)) r)","decl":"/-- The seminorm of an element in a product space is `≤ r` if and only if the norm of each\ncomponent is. -/\n@[to_additive pi_norm_le_iff_of_nonneg \"The seminorm of an element in a product space is `≤ r` if\nand only if the norm of each component is.\"]\nlemma pi_norm_le_iff_of_nonneg' (hr : 0 ≤ r) : ‖x‖ ≤ r ↔ ∀ i, ‖x i‖ ≤ r := by\n  simp only [← dist_one_right, dist_pi_le_iff hr, Pi.one_apply]\n\n"}
{"name":"pi_nnnorm_le_iff","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"ι : Type u_1\nπ : ι → Type u_4\ninst✝¹ : Fintype ι\ninst✝ : (i : ι) → SeminormedAddGroup (π i)\nx : (i : ι) → π i\nr : NNReal\n⊢ Iff (LE.le (NNNorm.nnnorm x) r) (∀ (i : ι), LE.le (NNNorm.nnnorm (x i)) r)","decl":"@[to_additive pi_nnnorm_le_iff]\nlemma pi_nnnorm_le_iff' {r : ℝ≥0} : ‖x‖₊ ≤ r ↔ ∀ i, ‖x i‖₊ ≤ r :=\n  pi_norm_le_iff_of_nonneg' r.coe_nonneg\n\n"}
{"name":"pi_nnnorm_le_iff'","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"ι : Type u_1\nπ : ι → Type u_4\ninst✝¹ : Fintype ι\ninst✝ : (i : ι) → SeminormedGroup (π i)\nx : (i : ι) → π i\nr : NNReal\n⊢ Iff (LE.le (NNNorm.nnnorm x) r) (∀ (i : ι), LE.le (NNNorm.nnnorm (x i)) r)","decl":"@[to_additive pi_nnnorm_le_iff]\nlemma pi_nnnorm_le_iff' {r : ℝ≥0} : ‖x‖₊ ≤ r ↔ ∀ i, ‖x i‖₊ ≤ r :=\n  pi_norm_le_iff_of_nonneg' r.coe_nonneg\n\n"}
{"name":"pi_norm_le_iff_of_nonempty'","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"ι : Type u_1\nπ : ι → Type u_4\ninst✝² : Fintype ι\ninst✝¹ : (i : ι) → SeminormedGroup (π i)\nf : (i : ι) → π i\nr : Real\ninst✝ : Nonempty ι\n⊢ Iff (LE.le (Norm.norm f) r) (∀ (b : ι), LE.le (Norm.norm (f b)) r)","decl":"@[to_additive pi_norm_le_iff_of_nonempty]\nlemma pi_norm_le_iff_of_nonempty' [Nonempty ι] : ‖f‖ ≤ r ↔ ∀ b, ‖f b‖ ≤ r := by\n  by_cases hr : 0 ≤ r\n  · exact pi_norm_le_iff_of_nonneg' hr\n  · exact\n      iff_of_false (fun h => hr <| (norm_nonneg' _).trans h) fun h =>\n        hr <| (norm_nonneg' _).trans <| h <| Classical.arbitrary _\n\n"}
{"name":"pi_norm_le_iff_of_nonempty","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"ι : Type u_1\nπ : ι → Type u_4\ninst✝² : Fintype ι\ninst✝¹ : (i : ι) → SeminormedAddGroup (π i)\nf : (i : ι) → π i\nr : Real\ninst✝ : Nonempty ι\n⊢ Iff (LE.le (Norm.norm f) r) (∀ (b : ι), LE.le (Norm.norm (f b)) r)","decl":"@[to_additive pi_norm_le_iff_of_nonempty]\nlemma pi_norm_le_iff_of_nonempty' [Nonempty ι] : ‖f‖ ≤ r ↔ ∀ b, ‖f b‖ ≤ r := by\n  by_cases hr : 0 ≤ r\n  · exact pi_norm_le_iff_of_nonneg' hr\n  · exact\n      iff_of_false (fun h => hr <| (norm_nonneg' _).trans h) fun h =>\n        hr <| (norm_nonneg' _).trans <| h <| Classical.arbitrary _\n\n"}
{"name":"pi_norm_lt_iff","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"ι : Type u_1\nπ : ι → Type u_4\ninst✝¹ : Fintype ι\ninst✝ : (i : ι) → SeminormedAddGroup (π i)\nx : (i : ι) → π i\nr : Real\nhr : LT.lt 0 r\n⊢ Iff (LT.lt (Norm.norm x) r) (∀ (i : ι), LT.lt (Norm.norm (x i)) r)","decl":"/-- The seminorm of an element in a product space is `< r` if and only if the norm of each\ncomponent is. -/\n@[to_additive pi_norm_lt_iff \"The seminorm of an element in a product space is `< r` if and only\nif the norm of each component is.\"]\nlemma pi_norm_lt_iff' (hr : 0 < r) : ‖x‖ < r ↔ ∀ i, ‖x i‖ < r := by\n  simp only [← dist_one_right, dist_pi_lt_iff hr, Pi.one_apply]\n\n"}
{"name":"pi_norm_lt_iff'","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"ι : Type u_1\nπ : ι → Type u_4\ninst✝¹ : Fintype ι\ninst✝ : (i : ι) → SeminormedGroup (π i)\nx : (i : ι) → π i\nr : Real\nhr : LT.lt 0 r\n⊢ Iff (LT.lt (Norm.norm x) r) (∀ (i : ι), LT.lt (Norm.norm (x i)) r)","decl":"/-- The seminorm of an element in a product space is `< r` if and only if the norm of each\ncomponent is. -/\n@[to_additive pi_norm_lt_iff \"The seminorm of an element in a product space is `< r` if and only\nif the norm of each component is.\"]\nlemma pi_norm_lt_iff' (hr : 0 < r) : ‖x‖ < r ↔ ∀ i, ‖x i‖ < r := by\n  simp only [← dist_one_right, dist_pi_lt_iff hr, Pi.one_apply]\n\n"}
{"name":"pi_nnnorm_lt_iff'","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"ι : Type u_1\nπ : ι → Type u_4\ninst✝¹ : Fintype ι\ninst✝ : (i : ι) → SeminormedGroup (π i)\nx : (i : ι) → π i\nr : NNReal\nhr : LT.lt 0 r\n⊢ Iff (LT.lt (NNNorm.nnnorm x) r) (∀ (i : ι), LT.lt (NNNorm.nnnorm (x i)) r)","decl":"@[to_additive pi_nnnorm_lt_iff]\nlemma pi_nnnorm_lt_iff' {r : ℝ≥0} (hr : 0 < r) : ‖x‖₊ < r ↔ ∀ i, ‖x i‖₊ < r :=\n  pi_norm_lt_iff' hr\n\n"}
{"name":"pi_nnnorm_lt_iff","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"ι : Type u_1\nπ : ι → Type u_4\ninst✝¹ : Fintype ι\ninst✝ : (i : ι) → SeminormedAddGroup (π i)\nx : (i : ι) → π i\nr : NNReal\nhr : LT.lt 0 r\n⊢ Iff (LT.lt (NNNorm.nnnorm x) r) (∀ (i : ι), LT.lt (NNNorm.nnnorm (x i)) r)","decl":"@[to_additive pi_nnnorm_lt_iff]\nlemma pi_nnnorm_lt_iff' {r : ℝ≥0} (hr : 0 < r) : ‖x‖₊ < r ↔ ∀ i, ‖x i‖₊ < r :=\n  pi_norm_lt_iff' hr\n\n"}
{"name":"norm_le_pi_norm'","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"ι : Type u_1\nπ : ι → Type u_4\ninst✝¹ : Fintype ι\ninst✝ : (i : ι) → SeminormedGroup (π i)\nf : (i : ι) → π i\ni : ι\n⊢ LE.le (Norm.norm (f i)) (Norm.norm f)","decl":"@[to_additive norm_le_pi_norm]\nlemma norm_le_pi_norm' (i : ι) : ‖f i‖ ≤ ‖f‖ :=\n  (pi_norm_le_iff_of_nonneg' <| norm_nonneg' _).1 le_rfl i\n\n"}
{"name":"norm_le_pi_norm","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"ι : Type u_1\nπ : ι → Type u_4\ninst✝¹ : Fintype ι\ninst✝ : (i : ι) → SeminormedAddGroup (π i)\nf : (i : ι) → π i\ni : ι\n⊢ LE.le (Norm.norm (f i)) (Norm.norm f)","decl":"@[to_additive norm_le_pi_norm]\nlemma norm_le_pi_norm' (i : ι) : ‖f i‖ ≤ ‖f‖ :=\n  (pi_norm_le_iff_of_nonneg' <| norm_nonneg' _).1 le_rfl i\n\n"}
{"name":"nnnorm_le_pi_nnnorm","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"ι : Type u_1\nπ : ι → Type u_4\ninst✝¹ : Fintype ι\ninst✝ : (i : ι) → SeminormedAddGroup (π i)\nf : (i : ι) → π i\ni : ι\n⊢ LE.le (NNNorm.nnnorm (f i)) (NNNorm.nnnorm f)","decl":"@[to_additive nnnorm_le_pi_nnnorm]\nlemma nnnorm_le_pi_nnnorm' (i : ι) : ‖f i‖₊ ≤ ‖f‖₊ :=\n  norm_le_pi_norm' _ i\n\n"}
{"name":"nnnorm_le_pi_nnnorm'","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"ι : Type u_1\nπ : ι → Type u_4\ninst✝¹ : Fintype ι\ninst✝ : (i : ι) → SeminormedGroup (π i)\nf : (i : ι) → π i\ni : ι\n⊢ LE.le (NNNorm.nnnorm (f i)) (NNNorm.nnnorm f)","decl":"@[to_additive nnnorm_le_pi_nnnorm]\nlemma nnnorm_le_pi_nnnorm' (i : ι) : ‖f i‖₊ ≤ ‖f‖₊ :=\n  norm_le_pi_norm' _ i\n\n"}
{"name":"pi_norm_const_le","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"ι : Type u_1\nE : Type u_2\ninst✝¹ : Fintype ι\ninst✝ : SeminormedAddGroup E\na : E\n⊢ LE.le (Norm.norm fun x => a) (Norm.norm a)","decl":"@[to_additive pi_norm_const_le]\nlemma pi_norm_const_le' (a : E) : ‖fun _ : ι => a‖ ≤ ‖a‖ :=\n  (pi_norm_le_iff_of_nonneg' <| norm_nonneg' _).2 fun _ => le_rfl\n\n"}
{"name":"pi_norm_const_le'","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"ι : Type u_1\nE : Type u_2\ninst✝¹ : Fintype ι\ninst✝ : SeminormedGroup E\na : E\n⊢ LE.le (Norm.norm fun x => a) (Norm.norm a)","decl":"@[to_additive pi_norm_const_le]\nlemma pi_norm_const_le' (a : E) : ‖fun _ : ι => a‖ ≤ ‖a‖ :=\n  (pi_norm_le_iff_of_nonneg' <| norm_nonneg' _).2 fun _ => le_rfl\n\n"}
{"name":"pi_nnnorm_const_le","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"ι : Type u_1\nE : Type u_2\ninst✝¹ : Fintype ι\ninst✝ : SeminormedAddGroup E\na : E\n⊢ LE.le (NNNorm.nnnorm fun x => a) (NNNorm.nnnorm a)","decl":"@[to_additive pi_nnnorm_const_le]\nlemma pi_nnnorm_const_le' (a : E) : ‖fun _ : ι => a‖₊ ≤ ‖a‖₊ :=\n  pi_norm_const_le' _\n\n"}
{"name":"pi_nnnorm_const_le'","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"ι : Type u_1\nE : Type u_2\ninst✝¹ : Fintype ι\ninst✝ : SeminormedGroup E\na : E\n⊢ LE.le (NNNorm.nnnorm fun x => a) (NNNorm.nnnorm a)","decl":"@[to_additive pi_nnnorm_const_le]\nlemma pi_nnnorm_const_le' (a : E) : ‖fun _ : ι => a‖₊ ≤ ‖a‖₊ :=\n  pi_norm_const_le' _\n\n"}
{"name":"pi_norm_const","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"ι : Type u_1\nE : Type u_2\ninst✝² : Fintype ι\ninst✝¹ : SeminormedAddGroup E\ninst✝ : Nonempty ι\na : E\n⊢ Eq (Norm.norm fun _i => a) (Norm.norm a)","decl":"@[to_additive (attr := simp) pi_norm_const]\nlemma pi_norm_const' [Nonempty ι] (a : E) : ‖fun _i : ι => a‖ = ‖a‖ := by\n  simpa only [← dist_one_right] using dist_pi_const a 1\n\n"}
{"name":"pi_norm_const'","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"ι : Type u_1\nE : Type u_2\ninst✝² : Fintype ι\ninst✝¹ : SeminormedGroup E\ninst✝ : Nonempty ι\na : E\n⊢ Eq (Norm.norm fun _i => a) (Norm.norm a)","decl":"@[to_additive (attr := simp) pi_norm_const]\nlemma pi_norm_const' [Nonempty ι] (a : E) : ‖fun _i : ι => a‖ = ‖a‖ := by\n  simpa only [← dist_one_right] using dist_pi_const a 1\n\n"}
{"name":"pi_nnnorm_const'","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"ι : Type u_1\nE : Type u_2\ninst✝² : Fintype ι\ninst✝¹ : SeminormedGroup E\ninst✝ : Nonempty ι\na : E\n⊢ Eq (NNNorm.nnnorm fun _i => a) (NNNorm.nnnorm a)","decl":"@[to_additive (attr := simp) pi_nnnorm_const]\nlemma pi_nnnorm_const' [Nonempty ι] (a : E) : ‖fun _i : ι => a‖₊ = ‖a‖₊ :=\n  NNReal.eq <| pi_norm_const' a\n\n"}
{"name":"pi_nnnorm_const","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"ι : Type u_1\nE : Type u_2\ninst✝² : Fintype ι\ninst✝¹ : SeminormedAddGroup E\ninst✝ : Nonempty ι\na : E\n⊢ Eq (NNNorm.nnnorm fun _i => a) (NNNorm.nnnorm a)","decl":"@[to_additive (attr := simp) pi_nnnorm_const]\nlemma pi_nnnorm_const' [Nonempty ι] (a : E) : ‖fun _i : ι => a‖₊ = ‖a‖₊ :=\n  NNReal.eq <| pi_norm_const' a\n\n"}
{"name":"Pi.sum_norm_apply_le_norm'","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"ι : Type u_1\nπ : ι → Type u_4\ninst✝¹ : Fintype ι\ninst✝ : (i : ι) → SeminormedGroup (π i)\nf : (i : ι) → π i\n⊢ LE.le (Finset.univ.sum fun i => Norm.norm (f i)) (HSMul.hSMul (Fintype.card ι) (Norm.norm f))","decl":"/-- The $L^1$ norm is less than the $L^\\infty$ norm scaled by the cardinality. -/\n@[to_additive Pi.sum_norm_apply_le_norm \"The $L^1$ norm is less than the $L^\\\\infty$ norm scaled by\nthe cardinality.\"]\nlemma Pi.sum_norm_apply_le_norm' : ∑ i, ‖f i‖ ≤ Fintype.card ι • ‖f‖ :=\n  Finset.sum_le_card_nsmul _ _ _ fun i _hi => norm_le_pi_norm' _ i\n\n"}
{"name":"Pi.sum_norm_apply_le_norm","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"ι : Type u_1\nπ : ι → Type u_4\ninst✝¹ : Fintype ι\ninst✝ : (i : ι) → SeminormedAddGroup (π i)\nf : (i : ι) → π i\n⊢ LE.le (Finset.univ.sum fun i => Norm.norm (f i)) (HSMul.hSMul (Fintype.card ι) (Norm.norm f))","decl":"/-- The $L^1$ norm is less than the $L^\\infty$ norm scaled by the cardinality. -/\n@[to_additive Pi.sum_norm_apply_le_norm \"The $L^1$ norm is less than the $L^\\\\infty$ norm scaled by\nthe cardinality.\"]\nlemma Pi.sum_norm_apply_le_norm' : ∑ i, ‖f i‖ ≤ Fintype.card ι • ‖f‖ :=\n  Finset.sum_le_card_nsmul _ _ _ fun i _hi => norm_le_pi_norm' _ i\n\n"}
{"name":"Pi.sum_nnnorm_apply_le_nnnorm'","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"ι : Type u_1\nπ : ι → Type u_4\ninst✝¹ : Fintype ι\ninst✝ : (i : ι) → SeminormedGroup (π i)\nf : (i : ι) → π i\n⊢ LE.le (Finset.univ.sum fun i => NNNorm.nnnorm (f i)) (HSMul.hSMul (Fintype.card ι) (NNNorm.nnnorm f))","decl":"/-- The $L^1$ norm is less than the $L^\\infty$ norm scaled by the cardinality. -/\n@[to_additive Pi.sum_nnnorm_apply_le_nnnorm \"The $L^1$ norm is less than the $L^\\\\infty$ norm\nscaled by the cardinality.\"]\nlemma Pi.sum_nnnorm_apply_le_nnnorm' : ∑ i, ‖f i‖₊ ≤ Fintype.card ι • ‖f‖₊ :=\n  (NNReal.coe_sum ..).trans_le <| Pi.sum_norm_apply_le_norm' _\n\n"}
{"name":"Pi.sum_nnnorm_apply_le_nnnorm","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"ι : Type u_1\nπ : ι → Type u_4\ninst✝¹ : Fintype ι\ninst✝ : (i : ι) → SeminormedAddGroup (π i)\nf : (i : ι) → π i\n⊢ LE.le (Finset.univ.sum fun i => NNNorm.nnnorm (f i)) (HSMul.hSMul (Fintype.card ι) (NNNorm.nnnorm f))","decl":"/-- The $L^1$ norm is less than the $L^\\infty$ norm scaled by the cardinality. -/\n@[to_additive Pi.sum_nnnorm_apply_le_nnnorm \"The $L^1$ norm is less than the $L^\\\\infty$ norm\nscaled by the cardinality.\"]\nlemma Pi.sum_nnnorm_apply_le_nnnorm' : ∑ i, ‖f i‖₊ ≤ Fintype.card ι • ‖f‖₊ :=\n  (NNReal.coe_sum ..).trans_le <| Pi.sum_norm_apply_le_norm' _\n\n"}
{"name":"Pi.nnnorm_single","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"ι : Type u_1\nπ : ι → Type u_4\ninst✝² : Fintype ι\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → NormedAddCommGroup (π i)\ni : ι\ny : π i\n⊢ Eq (NNNorm.nnnorm (Pi.single i y)) (NNNorm.nnnorm y)","decl":"theorem Pi.nnnorm_single [DecidableEq ι] [∀ i, NormedAddCommGroup (π i)] {i : ι} (y : π i) :\n    ‖Pi.single i y‖₊ = ‖y‖₊ := by\n  have H : ∀ b, ‖single i y b‖₊ = single (f := fun _ ↦ ℝ≥0) i ‖y‖₊ b := by\n    intro b\n    refine Pi.apply_single (fun i (x : π i) ↦ ‖x‖₊) ?_ i y b\n    simp\n  simp [Pi.nnnorm_def, H, Pi.single_apply, Finset.sup_ite, Finset.filter_eq']\n\n"}
{"name":"Pi.enorm_single","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"ι : Type u_1\nπ : ι → Type u_4\ninst✝² : Fintype ι\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → NormedAddCommGroup (π i)\ni : ι\ny : π i\n⊢ Eq (ENorm.enorm (Pi.single i y)) (ENorm.enorm y)","decl":"lemma Pi.enorm_single [DecidableEq ι] [∀ i, NormedAddCommGroup (π i)] {i : ι} (y : π i) :\n    ‖Pi.single i y‖ₑ = ‖y‖ₑ := by simp [enorm, Pi.nnnorm_single]\n\n"}
{"name":"Pi.norm_single","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"ι : Type u_1\nπ : ι → Type u_4\ninst✝² : Fintype ι\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → NormedAddCommGroup (π i)\ni : ι\ny : π i\n⊢ Eq (Norm.norm (Pi.single i y)) (Norm.norm y)","decl":"theorem Pi.norm_single [DecidableEq ι] [∀ i, NormedAddCommGroup (π i)] {i : ι} (y : π i) :\n    ‖Pi.single i y‖ = ‖y‖ :=\n  congr_arg Subtype.val <| Pi.nnnorm_single y\n\n"}
{"name":"MulOpposite.norm_op","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"E : Type u_2\ninst✝ : SeminormedAddGroup E\na : E\n⊢ Eq (Norm.norm (MulOpposite.op a)) (Norm.norm a)","decl":"lemma norm_op [SeminormedAddGroup E] (a : E) : ‖MulOpposite.op a‖ = ‖a‖ := rfl\n\n"}
{"name":"MulOpposite.norm_unop","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"E : Type u_2\ninst✝ : SeminormedAddGroup E\na : MulOpposite E\n⊢ Eq (Norm.norm (MulOpposite.unop a)) (Norm.norm a)","decl":"lemma norm_unop [SeminormedAddGroup E] (a : Eᵐᵒᵖ) : ‖MulOpposite.unop a‖ = ‖a‖ := rfl\n\n"}
{"name":"MulOpposite.nnnorm_op","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"E : Type u_2\ninst✝ : SeminormedAddGroup E\na : E\n⊢ Eq (NNNorm.nnnorm (MulOpposite.op a)) (NNNorm.nnnorm a)","decl":"lemma nnnorm_op [SeminormedAddGroup E] (a : E) : ‖MulOpposite.op a‖₊ = ‖a‖₊ := rfl\n\n"}
{"name":"MulOpposite.nnnorm_unop","module":"Mathlib.Analysis.Normed.Group.Constructions","initialProofState":"E : Type u_2\ninst✝ : SeminormedAddGroup E\na : MulOpposite E\n⊢ Eq (NNNorm.nnnorm (MulOpposite.unop a)) (NNNorm.nnnorm a)","decl":"lemma nnnorm_unop [SeminormedAddGroup E] (a : Eᵐᵒᵖ) : ‖MulOpposite.unop a‖₊ = ‖a‖₊ := rfl\n\n"}
