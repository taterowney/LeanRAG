{"name":"Multiset.lcm_zero","module":"Mathlib.Algebra.GCDMonoid.Multiset","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\n⊢ Eq (Multiset.lcm 0) 1","decl":"@[simp]\ntheorem lcm_zero : (0 : Multiset α).lcm = 1 :=\n  fold_zero _ _\n\n"}
{"name":"Multiset.lcm_cons","module":"Mathlib.Algebra.GCDMonoid.Multiset","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\na : α\ns : Multiset α\n⊢ Eq (Multiset.cons a s).lcm (GCDMonoid.lcm a s.lcm)","decl":"@[simp]\ntheorem lcm_cons (a : α) (s : Multiset α) : (a ::ₘ s).lcm = GCDMonoid.lcm a s.lcm :=\n  fold_cons_left _ _ _ _\n\n"}
{"name":"Multiset.lcm_singleton","module":"Mathlib.Algebra.GCDMonoid.Multiset","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\na : α\n⊢ Eq (Singleton.singleton a).lcm (normalize a)","decl":"@[simp]\ntheorem lcm_singleton {a : α} : ({a} : Multiset α).lcm = normalize a :=\n  (fold_singleton _ _ _).trans <| lcm_one_right _\n\n"}
{"name":"Multiset.lcm_add","module":"Mathlib.Algebra.GCDMonoid.Multiset","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\ns₁ s₂ : Multiset α\n⊢ Eq (HAdd.hAdd s₁ s₂).lcm (GCDMonoid.lcm s₁.lcm s₂.lcm)","decl":"@[simp]\ntheorem lcm_add (s₁ s₂ : Multiset α) : (s₁ + s₂).lcm = GCDMonoid.lcm s₁.lcm s₂.lcm :=\n  Eq.trans (by simp [lcm]) (fold_add _ _ _ _ _)\n\n"}
{"name":"Multiset.lcm_dvd","module":"Mathlib.Algebra.GCDMonoid.Multiset","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\ns : Multiset α\na : α\n⊢ Iff (Dvd.dvd s.lcm a) (∀ (b : α), Membership.mem s b → Dvd.dvd b a)","decl":"theorem lcm_dvd {s : Multiset α} {a : α} : s.lcm ∣ a ↔ ∀ b ∈ s, b ∣ a :=\n  Multiset.induction_on s (by simp)\n    (by simp +contextual [or_imp, forall_and, lcm_dvd_iff])\n\n"}
{"name":"Multiset.dvd_lcm","module":"Mathlib.Algebra.GCDMonoid.Multiset","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\ns : Multiset α\na : α\nh : Membership.mem s a\n⊢ Dvd.dvd a s.lcm","decl":"theorem dvd_lcm {s : Multiset α} {a : α} (h : a ∈ s) : a ∣ s.lcm :=\n  lcm_dvd.1 dvd_rfl _ h\n\n"}
{"name":"Multiset.lcm_mono","module":"Mathlib.Algebra.GCDMonoid.Multiset","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\ns₁ s₂ : Multiset α\nh : HasSubset.Subset s₁ s₂\n⊢ Dvd.dvd s₁.lcm s₂.lcm","decl":"theorem lcm_mono {s₁ s₂ : Multiset α} (h : s₁ ⊆ s₂) : s₁.lcm ∣ s₂.lcm :=\n  lcm_dvd.2 fun _ hb ↦ dvd_lcm (h hb)\n\n"}
{"name":"Multiset.normalize_lcm","module":"Mathlib.Algebra.GCDMonoid.Multiset","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\ns : Multiset α\n⊢ Eq (normalize s.lcm) s.lcm","decl":"@[simp]\ntheorem normalize_lcm (s : Multiset α) : normalize s.lcm = s.lcm :=\n  Multiset.induction_on s (by simp) fun a s _ ↦ by simp\n\n"}
{"name":"Multiset.lcm_eq_zero_iff","module":"Mathlib.Algebra.GCDMonoid.Multiset","initialProofState":"α : Type u_1\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : NormalizedGCDMonoid α\ninst✝ : Nontrivial α\ns : Multiset α\n⊢ Iff (Eq s.lcm 0) (Membership.mem s 0)","decl":"@[simp]\nnonrec theorem lcm_eq_zero_iff [Nontrivial α] (s : Multiset α) : s.lcm = 0 ↔ (0 : α) ∈ s := by\n  induction s using Multiset.induction_on with\n  | empty => simp only [lcm_zero, one_ne_zero, not_mem_zero]\n  | cons a s ihs => simp only [mem_cons, lcm_cons, lcm_eq_zero_iff, ihs, @eq_comm _ a]\n\n"}
{"name":"Multiset.lcm_dedup","module":"Mathlib.Algebra.GCDMonoid.Multiset","initialProofState":"α : Type u_1\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : NormalizedGCDMonoid α\ninst✝ : DecidableEq α\ns : Multiset α\n⊢ Eq s.dedup.lcm s.lcm","decl":"@[simp]\ntheorem lcm_dedup (s : Multiset α) : (dedup s).lcm = s.lcm :=\n  Multiset.induction_on s (by simp) fun a s IH ↦ by\n    by_cases h : a ∈ s <;> simp [IH, h]\n    unfold lcm\n    rw [← cons_erase h, fold_cons_left, ← lcm_assoc, lcm_same]\n    apply lcm_eq_of_associated_left (associated_normalize _)\n\n"}
{"name":"Multiset.lcm_ndunion","module":"Mathlib.Algebra.GCDMonoid.Multiset","initialProofState":"α : Type u_1\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : NormalizedGCDMonoid α\ninst✝ : DecidableEq α\ns₁ s₂ : Multiset α\n⊢ Eq (s₁.ndunion s₂).lcm (GCDMonoid.lcm s₁.lcm s₂.lcm)","decl":"@[simp]\ntheorem lcm_ndunion (s₁ s₂ : Multiset α) : (ndunion s₁ s₂).lcm = GCDMonoid.lcm s₁.lcm s₂.lcm := by\n  rw [← lcm_dedup, dedup_ext.2, lcm_dedup, lcm_add]\n  simp\n\n"}
{"name":"Multiset.lcm_union","module":"Mathlib.Algebra.GCDMonoid.Multiset","initialProofState":"α : Type u_1\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : NormalizedGCDMonoid α\ninst✝ : DecidableEq α\ns₁ s₂ : Multiset α\n⊢ Eq (Union.union s₁ s₂).lcm (GCDMonoid.lcm s₁.lcm s₂.lcm)","decl":"@[simp]\ntheorem lcm_union (s₁ s₂ : Multiset α) : (s₁ ∪ s₂).lcm = GCDMonoid.lcm s₁.lcm s₂.lcm := by\n  rw [← lcm_dedup, dedup_ext.2, lcm_dedup, lcm_add]\n  simp\n\n"}
{"name":"Multiset.lcm_ndinsert","module":"Mathlib.Algebra.GCDMonoid.Multiset","initialProofState":"α : Type u_1\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : NormalizedGCDMonoid α\ninst✝ : DecidableEq α\na : α\ns : Multiset α\n⊢ Eq (Multiset.ndinsert a s).lcm (GCDMonoid.lcm a s.lcm)","decl":"@[simp]\ntheorem lcm_ndinsert (a : α) (s : Multiset α) : (ndinsert a s).lcm = GCDMonoid.lcm a s.lcm := by\n  rw [← lcm_dedup, dedup_ext.2, lcm_dedup, lcm_cons]\n  simp\n\n"}
{"name":"Multiset.gcd_zero","module":"Mathlib.Algebra.GCDMonoid.Multiset","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\n⊢ Eq (Multiset.gcd 0) 0","decl":"@[simp]\ntheorem gcd_zero : (0 : Multiset α).gcd = 0 :=\n  fold_zero _ _\n\n"}
{"name":"Multiset.gcd_cons","module":"Mathlib.Algebra.GCDMonoid.Multiset","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\na : α\ns : Multiset α\n⊢ Eq (Multiset.cons a s).gcd (GCDMonoid.gcd a s.gcd)","decl":"@[simp]\ntheorem gcd_cons (a : α) (s : Multiset α) : (a ::ₘ s).gcd = GCDMonoid.gcd a s.gcd :=\n  fold_cons_left _ _ _ _\n\n"}
{"name":"Multiset.gcd_singleton","module":"Mathlib.Algebra.GCDMonoid.Multiset","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\na : α\n⊢ Eq (Singleton.singleton a).gcd (normalize a)","decl":"@[simp]\ntheorem gcd_singleton {a : α} : ({a} : Multiset α).gcd = normalize a :=\n  (fold_singleton _ _ _).trans <| gcd_zero_right _\n\n"}
{"name":"Multiset.gcd_add","module":"Mathlib.Algebra.GCDMonoid.Multiset","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\ns₁ s₂ : Multiset α\n⊢ Eq (HAdd.hAdd s₁ s₂).gcd (GCDMonoid.gcd s₁.gcd s₂.gcd)","decl":"@[simp]\ntheorem gcd_add (s₁ s₂ : Multiset α) : (s₁ + s₂).gcd = GCDMonoid.gcd s₁.gcd s₂.gcd :=\n  Eq.trans (by simp [gcd]) (fold_add _ _ _ _ _)\n\n"}
{"name":"Multiset.dvd_gcd","module":"Mathlib.Algebra.GCDMonoid.Multiset","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\ns : Multiset α\na : α\n⊢ Iff (Dvd.dvd a s.gcd) (∀ (b : α), Membership.mem s b → Dvd.dvd a b)","decl":"theorem dvd_gcd {s : Multiset α} {a : α} : a ∣ s.gcd ↔ ∀ b ∈ s, a ∣ b :=\n  Multiset.induction_on s (by simp)\n    (by simp +contextual [or_imp, forall_and, dvd_gcd_iff])\n\n"}
{"name":"Multiset.gcd_dvd","module":"Mathlib.Algebra.GCDMonoid.Multiset","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\ns : Multiset α\na : α\nh : Membership.mem s a\n⊢ Dvd.dvd s.gcd a","decl":"theorem gcd_dvd {s : Multiset α} {a : α} (h : a ∈ s) : s.gcd ∣ a :=\n  dvd_gcd.1 dvd_rfl _ h\n\n"}
{"name":"Multiset.gcd_mono","module":"Mathlib.Algebra.GCDMonoid.Multiset","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\ns₁ s₂ : Multiset α\nh : HasSubset.Subset s₁ s₂\n⊢ Dvd.dvd s₂.gcd s₁.gcd","decl":"theorem gcd_mono {s₁ s₂ : Multiset α} (h : s₁ ⊆ s₂) : s₂.gcd ∣ s₁.gcd :=\n  dvd_gcd.2 fun _ hb ↦ gcd_dvd (h hb)\n\n"}
{"name":"Multiset.normalize_gcd","module":"Mathlib.Algebra.GCDMonoid.Multiset","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\ns : Multiset α\n⊢ Eq (normalize s.gcd) s.gcd","decl":"@[simp]\ntheorem normalize_gcd (s : Multiset α) : normalize s.gcd = s.gcd :=\n  Multiset.induction_on s (by simp) fun a s _ ↦ by simp\n\n"}
{"name":"Multiset.gcd_eq_zero_iff","module":"Mathlib.Algebra.GCDMonoid.Multiset","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\ns : Multiset α\n⊢ Iff (Eq s.gcd 0) (∀ (x : α), Membership.mem s x → Eq x 0)","decl":"theorem gcd_eq_zero_iff (s : Multiset α) : s.gcd = 0 ↔ ∀ x : α, x ∈ s → x = 0 := by\n  constructor\n  · intro h x hx\n    apply eq_zero_of_zero_dvd\n    rw [← h]\n    apply gcd_dvd hx\n  · refine s.induction_on ?_ ?_\n    · simp\n    intro a s sgcd h\n    simp [h a (mem_cons_self a s), sgcd fun x hx ↦ h x (mem_cons_of_mem hx)]\n\n"}
{"name":"Multiset.gcd_map_mul","module":"Mathlib.Algebra.GCDMonoid.Multiset","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\na : α\ns : Multiset α\n⊢ Eq (Multiset.map (fun x => HMul.hMul a x) s).gcd (HMul.hMul (normalize a) s.gcd)","decl":"theorem gcd_map_mul (a : α) (s : Multiset α) : (s.map (a * ·)).gcd = normalize a * s.gcd := by\n  refine s.induction_on ?_ fun b s ih ↦ ?_\n  · simp_rw [map_zero, gcd_zero, mul_zero]\n  · simp_rw [map_cons, gcd_cons, ← gcd_mul_left]\n    rw [ih]\n    apply ((normalize_associated a).mul_right _).gcd_eq_right\n\n"}
{"name":"Multiset.gcd_dedup","module":"Mathlib.Algebra.GCDMonoid.Multiset","initialProofState":"α : Type u_1\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : NormalizedGCDMonoid α\ninst✝ : DecidableEq α\ns : Multiset α\n⊢ Eq s.dedup.gcd s.gcd","decl":"@[simp]\ntheorem gcd_dedup (s : Multiset α) : (dedup s).gcd = s.gcd :=\n  Multiset.induction_on s (by simp) fun a s IH ↦ by\n    by_cases h : a ∈ s <;> simp [IH, h]\n    unfold gcd\n    rw [← cons_erase h, fold_cons_left, ← gcd_assoc, gcd_same]\n    apply (associated_normalize _).gcd_eq_left\n\n"}
{"name":"Multiset.gcd_ndunion","module":"Mathlib.Algebra.GCDMonoid.Multiset","initialProofState":"α : Type u_1\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : NormalizedGCDMonoid α\ninst✝ : DecidableEq α\ns₁ s₂ : Multiset α\n⊢ Eq (s₁.ndunion s₂).gcd (GCDMonoid.gcd s₁.gcd s₂.gcd)","decl":"@[simp]\ntheorem gcd_ndunion (s₁ s₂ : Multiset α) : (ndunion s₁ s₂).gcd = GCDMonoid.gcd s₁.gcd s₂.gcd := by\n  rw [← gcd_dedup, dedup_ext.2, gcd_dedup, gcd_add]\n  simp\n\n"}
{"name":"Multiset.gcd_union","module":"Mathlib.Algebra.GCDMonoid.Multiset","initialProofState":"α : Type u_1\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : NormalizedGCDMonoid α\ninst✝ : DecidableEq α\ns₁ s₂ : Multiset α\n⊢ Eq (Union.union s₁ s₂).gcd (GCDMonoid.gcd s₁.gcd s₂.gcd)","decl":"@[simp]\ntheorem gcd_union (s₁ s₂ : Multiset α) : (s₁ ∪ s₂).gcd = GCDMonoid.gcd s₁.gcd s₂.gcd := by\n  rw [← gcd_dedup, dedup_ext.2, gcd_dedup, gcd_add]\n  simp\n\n"}
{"name":"Multiset.gcd_ndinsert","module":"Mathlib.Algebra.GCDMonoid.Multiset","initialProofState":"α : Type u_1\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : NormalizedGCDMonoid α\ninst✝ : DecidableEq α\na : α\ns : Multiset α\n⊢ Eq (Multiset.ndinsert a s).gcd (GCDMonoid.gcd a s.gcd)","decl":"@[simp]\ntheorem gcd_ndinsert (a : α) (s : Multiset α) : (ndinsert a s).gcd = GCDMonoid.gcd a s.gcd := by\n  rw [← gcd_dedup, dedup_ext.2, gcd_dedup, gcd_cons]\n  simp\n\n"}
{"name":"Multiset.extract_gcd'","module":"Mathlib.Algebra.GCDMonoid.Multiset","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\ns t : Multiset α\nhs : Exists fun x => And (Membership.mem s x) (Ne x 0)\nht : Eq s (Multiset.map (fun x => HMul.hMul s.gcd x) t)\n⊢ Eq t.gcd 1","decl":"theorem extract_gcd' (s t : Multiset α) (hs : ∃ x, x ∈ s ∧ x ≠ (0 : α))\n    (ht : s = t.map (s.gcd * ·)) : t.gcd = 1 :=\n  ((@mul_right_eq_self₀ _ _ s.gcd _).1 <| by\n        conv_lhs => rw [← normalize_gcd, ← gcd_map_mul, ← ht]).resolve_right <| by\n    contrapose! hs\n    exact s.gcd_eq_zero_iff.1 hs\n\n/- Porting note: The old proof used a strange form\n`have := _, refine ⟨s.pmap @f (fun _ ↦ id), this, extract_gcd' s _ h this⟩,`\nso I rearranged the proof slightly. -/\n"}
{"name":"Multiset.extract_gcd","module":"Mathlib.Algebra.GCDMonoid.Multiset","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\ns : Multiset α\nhs : Ne s 0\n⊢ Exists fun t => And (Eq s (Multiset.map (fun x => HMul.hMul s.gcd x) t)) (Eq t.gcd 1)","decl":"theorem extract_gcd (s : Multiset α) (hs : s ≠ 0) :\n    ∃ t : Multiset α, s = t.map (s.gcd * ·) ∧ t.gcd = 1 := by\n  classical\n    by_cases h : ∀ x ∈ s, x = (0 : α)\n    · use replicate (card s) 1\n      rw [map_replicate, eq_replicate, mul_one, s.gcd_eq_zero_iff.2 h, ← nsmul_singleton,\n    ← gcd_dedup, dedup_nsmul (card_pos.2 hs).ne', dedup_singleton, gcd_singleton]\n      exact ⟨⟨rfl, h⟩, normalize_one⟩\n    · choose f hf using @gcd_dvd _ _ _ s\n      push_neg at h\n      refine ⟨s.pmap @f fun _ ↦ id, ?_, extract_gcd' s _ h ?_⟩ <;>\n      · rw [map_pmap]\n        conv_lhs => rw [← s.map_id, ← s.pmap_eq_map _ _ fun _ ↦ id]\n        congr with (x hx)\n        rw [id, ← hf hx]\n\n"}
