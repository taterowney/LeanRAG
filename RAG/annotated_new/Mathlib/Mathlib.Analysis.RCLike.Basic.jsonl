{"name":"RCLike.I_mul_I_ax","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : semiOutParam (Type u_1)\nself : RCLike K\n⊢ Or (Eq RCLike.I 0) (Eq (HMul.hMul RCLike.I RCLike.I) (-1))","decl":"/--\nThis typeclass captures properties shared by ℝ and ℂ, with an API that closely matches that of ℂ.\n-/\nclass RCLike (K : semiOutParam Type*) extends DenselyNormedField K, StarRing K,\n    NormedAlgebra ℝ K, CompleteSpace K where\n  re : K →+ ℝ\n  im : K →+ ℝ\n  /-- Imaginary unit in `K`. Meant to be set to `0` for `K = ℝ`. -/\n  I : K\n  I_re_ax : re I = 0\n  I_mul_I_ax : I = 0 ∨ I * I = -1\n  re_add_im_ax : ∀ z : K, 𝓚 (re z) + 𝓚 (im z) * I = z\n  ofReal_re_ax : ∀ r : ℝ, re (𝓚 r) = r\n  ofReal_im_ax : ∀ r : ℝ, im (𝓚 r) = 0\n  mul_re_ax : ∀ z w : K, re (z * w) = re z * re w - im z * im w\n  mul_im_ax : ∀ z w : K, im (z * w) = re z * im w + im z * re w\n  conj_re_ax : ∀ z : K, re (conj z) = re z\n  conj_im_ax : ∀ z : K, im (conj z) = -im z\n  conj_I_ax : conj I = -I\n  norm_sq_eq_def_ax : ∀ z : K, ‖z‖ ^ 2 = re z * re z + im z * im z\n  mul_im_I_ax : ∀ z : K, im z * im I = im z\n  /-- only an instance in the `ComplexOrder` locale -/\n  [toPartialOrder : PartialOrder K]\n  le_iff_re_im {z w : K} : z ≤ w ↔ re z ≤ re w ∧ im z = im w\n  -- note we cannot put this in the `extends` clause\n  [toDecidableEq : DecidableEq K]\n\n"}
{"name":"RCLike.toCompleteSpace","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : semiOutParam (Type u_1)\nself : RCLike K\n⊢ CompleteSpace K","decl":"/--\nThis typeclass captures properties shared by ℝ and ℂ, with an API that closely matches that of ℂ.\n-/\nclass RCLike (K : semiOutParam Type*) extends DenselyNormedField K, StarRing K,\n    NormedAlgebra ℝ K, CompleteSpace K where\n  re : K →+ ℝ\n  im : K →+ ℝ\n  /-- Imaginary unit in `K`. Meant to be set to `0` for `K = ℝ`. -/\n  I : K\n  I_re_ax : re I = 0\n  I_mul_I_ax : I = 0 ∨ I * I = -1\n  re_add_im_ax : ∀ z : K, 𝓚 (re z) + 𝓚 (im z) * I = z\n  ofReal_re_ax : ∀ r : ℝ, re (𝓚 r) = r\n  ofReal_im_ax : ∀ r : ℝ, im (𝓚 r) = 0\n  mul_re_ax : ∀ z w : K, re (z * w) = re z * re w - im z * im w\n  mul_im_ax : ∀ z w : K, im (z * w) = re z * im w + im z * re w\n  conj_re_ax : ∀ z : K, re (conj z) = re z\n  conj_im_ax : ∀ z : K, im (conj z) = -im z\n  conj_I_ax : conj I = -I\n  norm_sq_eq_def_ax : ∀ z : K, ‖z‖ ^ 2 = re z * re z + im z * im z\n  mul_im_I_ax : ∀ z : K, im z * im I = im z\n  /-- only an instance in the `ComplexOrder` locale -/\n  [toPartialOrder : PartialOrder K]\n  le_iff_re_im {z w : K} : z ≤ w ↔ re z ≤ re w ∧ im z = im w\n  -- note we cannot put this in the `extends` clause\n  [toDecidableEq : DecidableEq K]\n\n"}
{"name":"RCLike.ofReal_im_ax","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : semiOutParam (Type u_1)\nself : RCLike K\nr : Real\n⊢ Eq (RCLike.im ((algebraMap Real K) r)) 0","decl":"/--\nThis typeclass captures properties shared by ℝ and ℂ, with an API that closely matches that of ℂ.\n-/\nclass RCLike (K : semiOutParam Type*) extends DenselyNormedField K, StarRing K,\n    NormedAlgebra ℝ K, CompleteSpace K where\n  re : K →+ ℝ\n  im : K →+ ℝ\n  /-- Imaginary unit in `K`. Meant to be set to `0` for `K = ℝ`. -/\n  I : K\n  I_re_ax : re I = 0\n  I_mul_I_ax : I = 0 ∨ I * I = -1\n  re_add_im_ax : ∀ z : K, 𝓚 (re z) + 𝓚 (im z) * I = z\n  ofReal_re_ax : ∀ r : ℝ, re (𝓚 r) = r\n  ofReal_im_ax : ∀ r : ℝ, im (𝓚 r) = 0\n  mul_re_ax : ∀ z w : K, re (z * w) = re z * re w - im z * im w\n  mul_im_ax : ∀ z w : K, im (z * w) = re z * im w + im z * re w\n  conj_re_ax : ∀ z : K, re (conj z) = re z\n  conj_im_ax : ∀ z : K, im (conj z) = -im z\n  conj_I_ax : conj I = -I\n  norm_sq_eq_def_ax : ∀ z : K, ‖z‖ ^ 2 = re z * re z + im z * im z\n  mul_im_I_ax : ∀ z : K, im z * im I = im z\n  /-- only an instance in the `ComplexOrder` locale -/\n  [toPartialOrder : PartialOrder K]\n  le_iff_re_im {z w : K} : z ≤ w ↔ re z ≤ re w ∧ im z = im w\n  -- note we cannot put this in the `extends` clause\n  [toDecidableEq : DecidableEq K]\n\n"}
{"name":"RCLike.mul_im_ax","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : semiOutParam (Type u_1)\nself : RCLike K\nz w : K\n⊢ Eq (RCLike.im (HMul.hMul z w)) (HAdd.hAdd (HMul.hMul (RCLike.re z) (RCLike.im w)) (HMul.hMul (RCLike.im z) (RCLike.re w)))","decl":"/--\nThis typeclass captures properties shared by ℝ and ℂ, with an API that closely matches that of ℂ.\n-/\nclass RCLike (K : semiOutParam Type*) extends DenselyNormedField K, StarRing K,\n    NormedAlgebra ℝ K, CompleteSpace K where\n  re : K →+ ℝ\n  im : K →+ ℝ\n  /-- Imaginary unit in `K`. Meant to be set to `0` for `K = ℝ`. -/\n  I : K\n  I_re_ax : re I = 0\n  I_mul_I_ax : I = 0 ∨ I * I = -1\n  re_add_im_ax : ∀ z : K, 𝓚 (re z) + 𝓚 (im z) * I = z\n  ofReal_re_ax : ∀ r : ℝ, re (𝓚 r) = r\n  ofReal_im_ax : ∀ r : ℝ, im (𝓚 r) = 0\n  mul_re_ax : ∀ z w : K, re (z * w) = re z * re w - im z * im w\n  mul_im_ax : ∀ z w : K, im (z * w) = re z * im w + im z * re w\n  conj_re_ax : ∀ z : K, re (conj z) = re z\n  conj_im_ax : ∀ z : K, im (conj z) = -im z\n  conj_I_ax : conj I = -I\n  norm_sq_eq_def_ax : ∀ z : K, ‖z‖ ^ 2 = re z * re z + im z * im z\n  mul_im_I_ax : ∀ z : K, im z * im I = im z\n  /-- only an instance in the `ComplexOrder` locale -/\n  [toPartialOrder : PartialOrder K]\n  le_iff_re_im {z w : K} : z ≤ w ↔ re z ≤ re w ∧ im z = im w\n  -- note we cannot put this in the `extends` clause\n  [toDecidableEq : DecidableEq K]\n\n"}
{"name":"RCLike.conj_im_ax","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : semiOutParam (Type u_1)\nself : RCLike K\nz : K\n⊢ Eq (RCLike.im ((starRingEnd K) z)) (Neg.neg (RCLike.im z))","decl":"/--\nThis typeclass captures properties shared by ℝ and ℂ, with an API that closely matches that of ℂ.\n-/\nclass RCLike (K : semiOutParam Type*) extends DenselyNormedField K, StarRing K,\n    NormedAlgebra ℝ K, CompleteSpace K where\n  re : K →+ ℝ\n  im : K →+ ℝ\n  /-- Imaginary unit in `K`. Meant to be set to `0` for `K = ℝ`. -/\n  I : K\n  I_re_ax : re I = 0\n  I_mul_I_ax : I = 0 ∨ I * I = -1\n  re_add_im_ax : ∀ z : K, 𝓚 (re z) + 𝓚 (im z) * I = z\n  ofReal_re_ax : ∀ r : ℝ, re (𝓚 r) = r\n  ofReal_im_ax : ∀ r : ℝ, im (𝓚 r) = 0\n  mul_re_ax : ∀ z w : K, re (z * w) = re z * re w - im z * im w\n  mul_im_ax : ∀ z w : K, im (z * w) = re z * im w + im z * re w\n  conj_re_ax : ∀ z : K, re (conj z) = re z\n  conj_im_ax : ∀ z : K, im (conj z) = -im z\n  conj_I_ax : conj I = -I\n  norm_sq_eq_def_ax : ∀ z : K, ‖z‖ ^ 2 = re z * re z + im z * im z\n  mul_im_I_ax : ∀ z : K, im z * im I = im z\n  /-- only an instance in the `ComplexOrder` locale -/\n  [toPartialOrder : PartialOrder K]\n  le_iff_re_im {z w : K} : z ≤ w ↔ re z ≤ re w ∧ im z = im w\n  -- note we cannot put this in the `extends` clause\n  [toDecidableEq : DecidableEq K]\n\n"}
{"name":"RCLike.conj_re_ax","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : semiOutParam (Type u_1)\nself : RCLike K\nz : K\n⊢ Eq (RCLike.re ((starRingEnd K) z)) (RCLike.re z)","decl":"/--\nThis typeclass captures properties shared by ℝ and ℂ, with an API that closely matches that of ℂ.\n-/\nclass RCLike (K : semiOutParam Type*) extends DenselyNormedField K, StarRing K,\n    NormedAlgebra ℝ K, CompleteSpace K where\n  re : K →+ ℝ\n  im : K →+ ℝ\n  /-- Imaginary unit in `K`. Meant to be set to `0` for `K = ℝ`. -/\n  I : K\n  I_re_ax : re I = 0\n  I_mul_I_ax : I = 0 ∨ I * I = -1\n  re_add_im_ax : ∀ z : K, 𝓚 (re z) + 𝓚 (im z) * I = z\n  ofReal_re_ax : ∀ r : ℝ, re (𝓚 r) = r\n  ofReal_im_ax : ∀ r : ℝ, im (𝓚 r) = 0\n  mul_re_ax : ∀ z w : K, re (z * w) = re z * re w - im z * im w\n  mul_im_ax : ∀ z w : K, im (z * w) = re z * im w + im z * re w\n  conj_re_ax : ∀ z : K, re (conj z) = re z\n  conj_im_ax : ∀ z : K, im (conj z) = -im z\n  conj_I_ax : conj I = -I\n  norm_sq_eq_def_ax : ∀ z : K, ‖z‖ ^ 2 = re z * re z + im z * im z\n  mul_im_I_ax : ∀ z : K, im z * im I = im z\n  /-- only an instance in the `ComplexOrder` locale -/\n  [toPartialOrder : PartialOrder K]\n  le_iff_re_im {z w : K} : z ≤ w ↔ re z ≤ re w ∧ im z = im w\n  -- note we cannot put this in the `extends` clause\n  [toDecidableEq : DecidableEq K]\n\n"}
{"name":"RCLike.ofReal_re_ax","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : semiOutParam (Type u_1)\nself : RCLike K\nr : Real\n⊢ Eq (RCLike.re ((algebraMap Real K) r)) r","decl":"/--\nThis typeclass captures properties shared by ℝ and ℂ, with an API that closely matches that of ℂ.\n-/\nclass RCLike (K : semiOutParam Type*) extends DenselyNormedField K, StarRing K,\n    NormedAlgebra ℝ K, CompleteSpace K where\n  re : K →+ ℝ\n  im : K →+ ℝ\n  /-- Imaginary unit in `K`. Meant to be set to `0` for `K = ℝ`. -/\n  I : K\n  I_re_ax : re I = 0\n  I_mul_I_ax : I = 0 ∨ I * I = -1\n  re_add_im_ax : ∀ z : K, 𝓚 (re z) + 𝓚 (im z) * I = z\n  ofReal_re_ax : ∀ r : ℝ, re (𝓚 r) = r\n  ofReal_im_ax : ∀ r : ℝ, im (𝓚 r) = 0\n  mul_re_ax : ∀ z w : K, re (z * w) = re z * re w - im z * im w\n  mul_im_ax : ∀ z w : K, im (z * w) = re z * im w + im z * re w\n  conj_re_ax : ∀ z : K, re (conj z) = re z\n  conj_im_ax : ∀ z : K, im (conj z) = -im z\n  conj_I_ax : conj I = -I\n  norm_sq_eq_def_ax : ∀ z : K, ‖z‖ ^ 2 = re z * re z + im z * im z\n  mul_im_I_ax : ∀ z : K, im z * im I = im z\n  /-- only an instance in the `ComplexOrder` locale -/\n  [toPartialOrder : PartialOrder K]\n  le_iff_re_im {z w : K} : z ≤ w ↔ re z ≤ re w ∧ im z = im w\n  -- note we cannot put this in the `extends` clause\n  [toDecidableEq : DecidableEq K]\n\n"}
{"name":"RCLike.I_re_ax","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : semiOutParam (Type u_1)\nself : RCLike K\n⊢ Eq (RCLike.re RCLike.I) 0","decl":"/--\nThis typeclass captures properties shared by ℝ and ℂ, with an API that closely matches that of ℂ.\n-/\nclass RCLike (K : semiOutParam Type*) extends DenselyNormedField K, StarRing K,\n    NormedAlgebra ℝ K, CompleteSpace K where\n  re : K →+ ℝ\n  im : K →+ ℝ\n  /-- Imaginary unit in `K`. Meant to be set to `0` for `K = ℝ`. -/\n  I : K\n  I_re_ax : re I = 0\n  I_mul_I_ax : I = 0 ∨ I * I = -1\n  re_add_im_ax : ∀ z : K, 𝓚 (re z) + 𝓚 (im z) * I = z\n  ofReal_re_ax : ∀ r : ℝ, re (𝓚 r) = r\n  ofReal_im_ax : ∀ r : ℝ, im (𝓚 r) = 0\n  mul_re_ax : ∀ z w : K, re (z * w) = re z * re w - im z * im w\n  mul_im_ax : ∀ z w : K, im (z * w) = re z * im w + im z * re w\n  conj_re_ax : ∀ z : K, re (conj z) = re z\n  conj_im_ax : ∀ z : K, im (conj z) = -im z\n  conj_I_ax : conj I = -I\n  norm_sq_eq_def_ax : ∀ z : K, ‖z‖ ^ 2 = re z * re z + im z * im z\n  mul_im_I_ax : ∀ z : K, im z * im I = im z\n  /-- only an instance in the `ComplexOrder` locale -/\n  [toPartialOrder : PartialOrder K]\n  le_iff_re_im {z w : K} : z ≤ w ↔ re z ≤ re w ∧ im z = im w\n  -- note we cannot put this in the `extends` clause\n  [toDecidableEq : DecidableEq K]\n\n"}
{"name":"RCLike.norm_sq_eq_def_ax","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : semiOutParam (Type u_1)\nself : RCLike K\nz : K\n⊢ Eq (HPow.hPow (Norm.norm z) 2) (HAdd.hAdd (HMul.hMul (RCLike.re z) (RCLike.re z)) (HMul.hMul (RCLike.im z) (RCLike.im z)))","decl":"/--\nThis typeclass captures properties shared by ℝ and ℂ, with an API that closely matches that of ℂ.\n-/\nclass RCLike (K : semiOutParam Type*) extends DenselyNormedField K, StarRing K,\n    NormedAlgebra ℝ K, CompleteSpace K where\n  re : K →+ ℝ\n  im : K →+ ℝ\n  /-- Imaginary unit in `K`. Meant to be set to `0` for `K = ℝ`. -/\n  I : K\n  I_re_ax : re I = 0\n  I_mul_I_ax : I = 0 ∨ I * I = -1\n  re_add_im_ax : ∀ z : K, 𝓚 (re z) + 𝓚 (im z) * I = z\n  ofReal_re_ax : ∀ r : ℝ, re (𝓚 r) = r\n  ofReal_im_ax : ∀ r : ℝ, im (𝓚 r) = 0\n  mul_re_ax : ∀ z w : K, re (z * w) = re z * re w - im z * im w\n  mul_im_ax : ∀ z w : K, im (z * w) = re z * im w + im z * re w\n  conj_re_ax : ∀ z : K, re (conj z) = re z\n  conj_im_ax : ∀ z : K, im (conj z) = -im z\n  conj_I_ax : conj I = -I\n  norm_sq_eq_def_ax : ∀ z : K, ‖z‖ ^ 2 = re z * re z + im z * im z\n  mul_im_I_ax : ∀ z : K, im z * im I = im z\n  /-- only an instance in the `ComplexOrder` locale -/\n  [toPartialOrder : PartialOrder K]\n  le_iff_re_im {z w : K} : z ≤ w ↔ re z ≤ re w ∧ im z = im w\n  -- note we cannot put this in the `extends` clause\n  [toDecidableEq : DecidableEq K]\n\n"}
{"name":"RCLike.le_iff_re_im","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : semiOutParam (Type u_1)\nself : RCLike K\nz w : K\n⊢ Iff (LE.le z w) (And (LE.le (RCLike.re z) (RCLike.re w)) (Eq (RCLike.im z) (RCLike.im w)))","decl":"/--\nThis typeclass captures properties shared by ℝ and ℂ, with an API that closely matches that of ℂ.\n-/\nclass RCLike (K : semiOutParam Type*) extends DenselyNormedField K, StarRing K,\n    NormedAlgebra ℝ K, CompleteSpace K where\n  re : K →+ ℝ\n  im : K →+ ℝ\n  /-- Imaginary unit in `K`. Meant to be set to `0` for `K = ℝ`. -/\n  I : K\n  I_re_ax : re I = 0\n  I_mul_I_ax : I = 0 ∨ I * I = -1\n  re_add_im_ax : ∀ z : K, 𝓚 (re z) + 𝓚 (im z) * I = z\n  ofReal_re_ax : ∀ r : ℝ, re (𝓚 r) = r\n  ofReal_im_ax : ∀ r : ℝ, im (𝓚 r) = 0\n  mul_re_ax : ∀ z w : K, re (z * w) = re z * re w - im z * im w\n  mul_im_ax : ∀ z w : K, im (z * w) = re z * im w + im z * re w\n  conj_re_ax : ∀ z : K, re (conj z) = re z\n  conj_im_ax : ∀ z : K, im (conj z) = -im z\n  conj_I_ax : conj I = -I\n  norm_sq_eq_def_ax : ∀ z : K, ‖z‖ ^ 2 = re z * re z + im z * im z\n  mul_im_I_ax : ∀ z : K, im z * im I = im z\n  /-- only an instance in the `ComplexOrder` locale -/\n  [toPartialOrder : PartialOrder K]\n  le_iff_re_im {z w : K} : z ≤ w ↔ re z ≤ re w ∧ im z = im w\n  -- note we cannot put this in the `extends` clause\n  [toDecidableEq : DecidableEq K]\n\n"}
{"name":"RCLike.mul_im_I_ax","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : semiOutParam (Type u_1)\nself : RCLike K\nz : K\n⊢ Eq (HMul.hMul (RCLike.im z) (RCLike.im RCLike.I)) (RCLike.im z)","decl":"/--\nThis typeclass captures properties shared by ℝ and ℂ, with an API that closely matches that of ℂ.\n-/\nclass RCLike (K : semiOutParam Type*) extends DenselyNormedField K, StarRing K,\n    NormedAlgebra ℝ K, CompleteSpace K where\n  re : K →+ ℝ\n  im : K →+ ℝ\n  /-- Imaginary unit in `K`. Meant to be set to `0` for `K = ℝ`. -/\n  I : K\n  I_re_ax : re I = 0\n  I_mul_I_ax : I = 0 ∨ I * I = -1\n  re_add_im_ax : ∀ z : K, 𝓚 (re z) + 𝓚 (im z) * I = z\n  ofReal_re_ax : ∀ r : ℝ, re (𝓚 r) = r\n  ofReal_im_ax : ∀ r : ℝ, im (𝓚 r) = 0\n  mul_re_ax : ∀ z w : K, re (z * w) = re z * re w - im z * im w\n  mul_im_ax : ∀ z w : K, im (z * w) = re z * im w + im z * re w\n  conj_re_ax : ∀ z : K, re (conj z) = re z\n  conj_im_ax : ∀ z : K, im (conj z) = -im z\n  conj_I_ax : conj I = -I\n  norm_sq_eq_def_ax : ∀ z : K, ‖z‖ ^ 2 = re z * re z + im z * im z\n  mul_im_I_ax : ∀ z : K, im z * im I = im z\n  /-- only an instance in the `ComplexOrder` locale -/\n  [toPartialOrder : PartialOrder K]\n  le_iff_re_im {z w : K} : z ≤ w ↔ re z ≤ re w ∧ im z = im w\n  -- note we cannot put this in the `extends` clause\n  [toDecidableEq : DecidableEq K]\n\n"}
{"name":"RCLike.mul_re_ax","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : semiOutParam (Type u_1)\nself : RCLike K\nz w : K\n⊢ Eq (RCLike.re (HMul.hMul z w)) (HSub.hSub (HMul.hMul (RCLike.re z) (RCLike.re w)) (HMul.hMul (RCLike.im z) (RCLike.im w)))","decl":"/--\nThis typeclass captures properties shared by ℝ and ℂ, with an API that closely matches that of ℂ.\n-/\nclass RCLike (K : semiOutParam Type*) extends DenselyNormedField K, StarRing K,\n    NormedAlgebra ℝ K, CompleteSpace K where\n  re : K →+ ℝ\n  im : K →+ ℝ\n  /-- Imaginary unit in `K`. Meant to be set to `0` for `K = ℝ`. -/\n  I : K\n  I_re_ax : re I = 0\n  I_mul_I_ax : I = 0 ∨ I * I = -1\n  re_add_im_ax : ∀ z : K, 𝓚 (re z) + 𝓚 (im z) * I = z\n  ofReal_re_ax : ∀ r : ℝ, re (𝓚 r) = r\n  ofReal_im_ax : ∀ r : ℝ, im (𝓚 r) = 0\n  mul_re_ax : ∀ z w : K, re (z * w) = re z * re w - im z * im w\n  mul_im_ax : ∀ z w : K, im (z * w) = re z * im w + im z * re w\n  conj_re_ax : ∀ z : K, re (conj z) = re z\n  conj_im_ax : ∀ z : K, im (conj z) = -im z\n  conj_I_ax : conj I = -I\n  norm_sq_eq_def_ax : ∀ z : K, ‖z‖ ^ 2 = re z * re z + im z * im z\n  mul_im_I_ax : ∀ z : K, im z * im I = im z\n  /-- only an instance in the `ComplexOrder` locale -/\n  [toPartialOrder : PartialOrder K]\n  le_iff_re_im {z w : K} : z ≤ w ↔ re z ≤ re w ∧ im z = im w\n  -- note we cannot put this in the `extends` clause\n  [toDecidableEq : DecidableEq K]\n\n"}
{"name":"RCLike.re_add_im_ax","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : semiOutParam (Type u_1)\nself : RCLike K\nz : K\n⊢ Eq (HAdd.hAdd ((algebraMap Real K) (RCLike.re z)) (HMul.hMul ((algebraMap Real K) (RCLike.im z)) RCLike.I)) z","decl":"/--\nThis typeclass captures properties shared by ℝ and ℂ, with an API that closely matches that of ℂ.\n-/\nclass RCLike (K : semiOutParam Type*) extends DenselyNormedField K, StarRing K,\n    NormedAlgebra ℝ K, CompleteSpace K where\n  re : K →+ ℝ\n  im : K →+ ℝ\n  /-- Imaginary unit in `K`. Meant to be set to `0` for `K = ℝ`. -/\n  I : K\n  I_re_ax : re I = 0\n  I_mul_I_ax : I = 0 ∨ I * I = -1\n  re_add_im_ax : ∀ z : K, 𝓚 (re z) + 𝓚 (im z) * I = z\n  ofReal_re_ax : ∀ r : ℝ, re (𝓚 r) = r\n  ofReal_im_ax : ∀ r : ℝ, im (𝓚 r) = 0\n  mul_re_ax : ∀ z w : K, re (z * w) = re z * re w - im z * im w\n  mul_im_ax : ∀ z w : K, im (z * w) = re z * im w + im z * re w\n  conj_re_ax : ∀ z : K, re (conj z) = re z\n  conj_im_ax : ∀ z : K, im (conj z) = -im z\n  conj_I_ax : conj I = -I\n  norm_sq_eq_def_ax : ∀ z : K, ‖z‖ ^ 2 = re z * re z + im z * im z\n  mul_im_I_ax : ∀ z : K, im z * im I = im z\n  /-- only an instance in the `ComplexOrder` locale -/\n  [toPartialOrder : PartialOrder K]\n  le_iff_re_im {z w : K} : z ≤ w ↔ re z ≤ re w ∧ im z = im w\n  -- note we cannot put this in the `extends` clause\n  [toDecidableEq : DecidableEq K]\n\n"}
{"name":"RCLike.conj_I_ax","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : semiOutParam (Type u_1)\nself : RCLike K\n⊢ Eq ((starRingEnd K) RCLike.I) (Neg.neg RCLike.I)","decl":"/--\nThis typeclass captures properties shared by ℝ and ℂ, with an API that closely matches that of ℂ.\n-/\nclass RCLike (K : semiOutParam Type*) extends DenselyNormedField K, StarRing K,\n    NormedAlgebra ℝ K, CompleteSpace K where\n  re : K →+ ℝ\n  im : K →+ ℝ\n  /-- Imaginary unit in `K`. Meant to be set to `0` for `K = ℝ`. -/\n  I : K\n  I_re_ax : re I = 0\n  I_mul_I_ax : I = 0 ∨ I * I = -1\n  re_add_im_ax : ∀ z : K, 𝓚 (re z) + 𝓚 (im z) * I = z\n  ofReal_re_ax : ∀ r : ℝ, re (𝓚 r) = r\n  ofReal_im_ax : ∀ r : ℝ, im (𝓚 r) = 0\n  mul_re_ax : ∀ z w : K, re (z * w) = re z * re w - im z * im w\n  mul_im_ax : ∀ z w : K, im (z * w) = re z * im w + im z * re w\n  conj_re_ax : ∀ z : K, re (conj z) = re z\n  conj_im_ax : ∀ z : K, im (conj z) = -im z\n  conj_I_ax : conj I = -I\n  norm_sq_eq_def_ax : ∀ z : K, ‖z‖ ^ 2 = re z * re z + im z * im z\n  mul_im_I_ax : ∀ z : K, im z * im I = im z\n  /-- only an instance in the `ComplexOrder` locale -/\n  [toPartialOrder : PartialOrder K]\n  le_iff_re_im {z w : K} : z ≤ w ↔ re z ≤ re w ∧ im z = im w\n  -- note we cannot put this in the `extends` clause\n  [toDecidableEq : DecidableEq K]\n\n"}
{"name":"RCLike.ofReal_alg","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nx : Real\n⊢ Eq (↑x) (HSMul.hSMul x 1)","decl":"theorem ofReal_alg (x : ℝ) : (x : K) = x • (1 : K) :=\n  Algebra.algebraMap_eq_smul_one x\n\n"}
{"name":"RCLike.real_smul_eq_coe_mul","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nr : Real\nz : K\n⊢ Eq (HSMul.hSMul r z) (HMul.hMul (↑r) z)","decl":"theorem real_smul_eq_coe_mul (r : ℝ) (z : K) : r • z = (r : K) * z :=\n  Algebra.smul_def r z\n\n"}
{"name":"RCLike.real_smul_eq_coe_smul","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\nE : Type u_2\ninst✝⁴ : RCLike K\ninst✝³ : AddCommGroup E\ninst✝² : Module K E\ninst✝¹ : Module Real E\ninst✝ : IsScalarTower Real K E\nr : Real\nx : E\n⊢ Eq (HSMul.hSMul r x) (HSMul.hSMul (↑r) x)","decl":"theorem real_smul_eq_coe_smul [AddCommGroup E] [Module K E] [Module ℝ E] [IsScalarTower ℝ K E]\n    (r : ℝ) (x : E) : r • x = (r : K) • x := by rw [RCLike.ofReal_alg, smul_one_smul]\n\n"}
{"name":"RCLike.algebraMap_eq_ofReal","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\n⊢ Eq (⇑(algebraMap Real K)) RCLike.ofReal","decl":"theorem algebraMap_eq_ofReal : ⇑(algebraMap ℝ K) = ofReal :=\n  rfl\n\n"}
{"name":"RCLike.re_add_im","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz : K\n⊢ Eq (HAdd.hAdd (↑(RCLike.re z)) (HMul.hMul (↑(RCLike.im z)) RCLike.I)) z","decl":"@[simp, rclike_simps]\ntheorem re_add_im (z : K) : (re z : K) + im z * I = z :=\n  RCLike.re_add_im_ax z\n\n"}
{"name":"RCLike.ofReal_re","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nr : Real\n⊢ Eq (RCLike.re ↑r) r","decl":"@[simp, norm_cast, rclike_simps]\ntheorem ofReal_re : ∀ r : ℝ, re (r : K) = r :=\n  RCLike.ofReal_re_ax\n\n"}
{"name":"RCLike.ofReal_im","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nr : Real\n⊢ Eq (RCLike.im ↑r) 0","decl":"@[simp, norm_cast, rclike_simps]\ntheorem ofReal_im : ∀ r : ℝ, im (r : K) = 0 :=\n  RCLike.ofReal_im_ax\n\n"}
{"name":"RCLike.mul_re","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz w : K\n⊢ Eq (RCLike.re (HMul.hMul z w)) (HSub.hSub (HMul.hMul (RCLike.re z) (RCLike.re w)) (HMul.hMul (RCLike.im z) (RCLike.im w)))","decl":"@[simp, rclike_simps]\ntheorem mul_re : ∀ z w : K, re (z * w) = re z * re w - im z * im w :=\n  RCLike.mul_re_ax\n\n"}
{"name":"RCLike.mul_im","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz w : K\n⊢ Eq (RCLike.im (HMul.hMul z w)) (HAdd.hAdd (HMul.hMul (RCLike.re z) (RCLike.im w)) (HMul.hMul (RCLike.im z) (RCLike.re w)))","decl":"@[simp, rclike_simps]\ntheorem mul_im : ∀ z w : K, im (z * w) = re z * im w + im z * re w :=\n  RCLike.mul_im_ax\n\n"}
{"name":"RCLike.ext_iff","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz w : K\n⊢ Iff (Eq z w) (And (Eq (RCLike.re z) (RCLike.re w)) (Eq (RCLike.im z) (RCLike.im w)))","decl":"theorem ext_iff {z w : K} : z = w ↔ re z = re w ∧ im z = im w :=\n  ⟨fun h => h ▸ ⟨rfl, rfl⟩, fun ⟨h₁, h₂⟩ => re_add_im z ▸ re_add_im w ▸ h₁ ▸ h₂ ▸ rfl⟩\n\n"}
{"name":"RCLike.ext","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz w : K\nhre : Eq (RCLike.re z) (RCLike.re w)\nhim : Eq (RCLike.im z) (RCLike.im w)\n⊢ Eq z w","decl":"theorem ext {z w : K} (hre : re z = re w) (him : im z = im w) : z = w :=\n  ext_iff.2 ⟨hre, him⟩\n\n"}
{"name":"RCLike.ofReal_zero","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\n⊢ Eq (↑0) 0","decl":"@[norm_cast]\ntheorem ofReal_zero : ((0 : ℝ) : K) = 0 :=\n  algebraMap.coe_zero\n\n"}
{"name":"RCLike.zero_re'","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\n⊢ Eq (RCLike.re 0) 0","decl":"@[rclike_simps]\ntheorem zero_re' : re (0 : K) = (0 : ℝ) :=\n  map_zero re\n\n"}
{"name":"RCLike.ofReal_one","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\n⊢ Eq (↑1) 1","decl":"@[norm_cast]\ntheorem ofReal_one : ((1 : ℝ) : K) = 1 :=\n  map_one (algebraMap ℝ K)\n\n"}
{"name":"RCLike.one_re","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\n⊢ Eq (RCLike.re 1) 1","decl":"@[simp, rclike_simps]\ntheorem one_re : re (1 : K) = 1 := by rw [← ofReal_one, ofReal_re]\n\n"}
{"name":"RCLike.one_im","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\n⊢ Eq (RCLike.im 1) 0","decl":"@[simp, rclike_simps]\ntheorem one_im : im (1 : K) = 0 := by rw [← ofReal_one, ofReal_im]\n\n"}
{"name":"RCLike.ofReal_injective","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\n⊢ Function.Injective RCLike.ofReal","decl":"theorem ofReal_injective : Function.Injective ((↑) : ℝ → K) :=\n  (algebraMap ℝ K).injective\n\n"}
{"name":"RCLike.ofReal_inj","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz w : Real\n⊢ Iff (Eq ↑z ↑w) (Eq z w)","decl":"@[norm_cast]\ntheorem ofReal_inj {z w : ℝ} : (z : K) = (w : K) ↔ z = w :=\n  algebraMap.coe_inj\n\n-- replaced by `RCLike.ofNat_re`\n-- replaced by `RCLike.ofNat_im`\n\n"}
{"name":"RCLike.ofReal_eq_zero","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nx : Real\n⊢ Iff (Eq (↑x) 0) (Eq x 0)","decl":"theorem ofReal_eq_zero {x : ℝ} : (x : K) = 0 ↔ x = 0 :=\n  algebraMap.lift_map_eq_zero_iff x\n\n"}
{"name":"RCLike.ofReal_ne_zero","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nx : Real\n⊢ Iff (Ne (↑x) 0) (Ne x 0)","decl":"theorem ofReal_ne_zero {x : ℝ} : (x : K) ≠ 0 ↔ x ≠ 0 :=\n  ofReal_eq_zero.not\n\n"}
{"name":"RCLike.ofReal_add","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nr s : Real\n⊢ Eq (↑(HAdd.hAdd r s)) (HAdd.hAdd ↑r ↑s)","decl":"@[rclike_simps, norm_cast]\ntheorem ofReal_add (r s : ℝ) : ((r + s : ℝ) : K) = r + s :=\n  algebraMap.coe_add _ _\n\n-- replaced by `RCLike.ofReal_ofNat`\n\n"}
{"name":"RCLike.ofReal_neg","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nr : Real\n⊢ Eq (↑(Neg.neg r)) (Neg.neg ↑r)","decl":"@[rclike_simps, norm_cast]\ntheorem ofReal_neg (r : ℝ) : ((-r : ℝ) : K) = -r :=\n  algebraMap.coe_neg r\n\n"}
{"name":"RCLike.ofReal_sub","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nr s : Real\n⊢ Eq (↑(HSub.hSub r s)) (HSub.hSub ↑r ↑s)","decl":"@[rclike_simps, norm_cast]\ntheorem ofReal_sub (r s : ℝ) : ((r - s : ℝ) : K) = r - s :=\n  map_sub (algebraMap ℝ K) r s\n\n"}
{"name":"RCLike.ofReal_sum","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nα : Type u_3\ns : Finset α\nf : α → Real\n⊢ Eq (↑(s.sum fun i => f i)) (s.sum fun i => ↑(f i))","decl":"@[rclike_simps, norm_cast]\ntheorem ofReal_sum {α : Type*} (s : Finset α) (f : α → ℝ) :\n    ((∑ i ∈ s, f i : ℝ) : K) = ∑ i ∈ s, (f i : K) :=\n  map_sum (algebraMap ℝ K) _ _\n\n"}
{"name":"RCLike.ofReal_finsupp_sum","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝¹ : RCLike K\nα : Type u_3\nM : Type u_4\ninst✝ : Zero M\nf : Finsupp α M\ng : α → M → Real\n⊢ Eq (↑(f.sum fun a b => g a b)) (f.sum fun a b => ↑(g a b))","decl":"@[simp, rclike_simps, norm_cast]\ntheorem ofReal_finsupp_sum {α M : Type*} [Zero M] (f : α →₀ M) (g : α → M → ℝ) :\n    ((f.sum fun a b => g a b : ℝ) : K) = f.sum fun a b => (g a b : K) :=\n  map_finsupp_sum (algebraMap ℝ K) f g\n\n"}
{"name":"RCLike.ofReal_mul","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nr s : Real\n⊢ Eq (↑(HMul.hMul r s)) (HMul.hMul ↑r ↑s)","decl":"@[rclike_simps, norm_cast]\ntheorem ofReal_mul (r s : ℝ) : ((r * s : ℝ) : K) = r * s :=\n  algebraMap.coe_mul _ _\n\n"}
{"name":"RCLike.ofReal_pow","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nr : Real\nn : Nat\n⊢ Eq (↑(HPow.hPow r n)) (HPow.hPow (↑r) n)","decl":"@[rclike_simps, norm_cast]\ntheorem ofReal_pow (r : ℝ) (n : ℕ) : ((r ^ n : ℝ) : K) = (r : K) ^ n :=\n  map_pow (algebraMap ℝ K) r n\n\n"}
{"name":"RCLike.ofReal_prod","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nα : Type u_3\ns : Finset α\nf : α → Real\n⊢ Eq (↑(s.prod fun i => f i)) (s.prod fun i => ↑(f i))","decl":"@[rclike_simps, norm_cast]\ntheorem ofReal_prod {α : Type*} (s : Finset α) (f : α → ℝ) :\n    ((∏ i ∈ s, f i : ℝ) : K) = ∏ i ∈ s, (f i : K) :=\n  map_prod (algebraMap ℝ K) _ _\n\n"}
{"name":"RCLike.ofReal_finsupp_prod","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝¹ : RCLike K\nα : Type u_3\nM : Type u_4\ninst✝ : Zero M\nf : Finsupp α M\ng : α → M → Real\n⊢ Eq (↑(f.prod fun a b => g a b)) (f.prod fun a b => ↑(g a b))","decl":"@[simp, rclike_simps, norm_cast]\ntheorem ofReal_finsupp_prod {α M : Type*} [Zero M] (f : α →₀ M) (g : α → M → ℝ) :\n    ((f.prod fun a b => g a b : ℝ) : K) = f.prod fun a b => (g a b : K) :=\n  map_finsupp_prod _ f g\n\n"}
{"name":"RCLike.real_smul_ofReal","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nr x : Real\n⊢ Eq (HSMul.hSMul r ↑x) (HMul.hMul ↑r ↑x)","decl":"@[simp, norm_cast, rclike_simps]\ntheorem real_smul_ofReal (r x : ℝ) : r • (x : K) = (r : K) * (x : K) :=\n  real_smul_eq_coe_mul _ _\n\n"}
{"name":"RCLike.re_ofReal_mul","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nr : Real\nz : K\n⊢ Eq (RCLike.re (HMul.hMul (↑r) z)) (HMul.hMul r (RCLike.re z))","decl":"@[rclike_simps]\ntheorem re_ofReal_mul (r : ℝ) (z : K) : re (↑r * z) = r * re z := by\n  simp only [mul_re, ofReal_im, zero_mul, ofReal_re, sub_zero]\n\n"}
{"name":"RCLike.im_ofReal_mul","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nr : Real\nz : K\n⊢ Eq (RCLike.im (HMul.hMul (↑r) z)) (HMul.hMul r (RCLike.im z))","decl":"@[rclike_simps]\ntheorem im_ofReal_mul (r : ℝ) (z : K) : im (↑r * z) = r * im z := by\n  simp only [add_zero, ofReal_im, zero_mul, ofReal_re, mul_im]\n\n"}
{"name":"RCLike.smul_re","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nr : Real\nz : K\n⊢ Eq (RCLike.re (HSMul.hSMul r z)) (HMul.hMul r (RCLike.re z))","decl":"@[rclike_simps]\ntheorem smul_re (r : ℝ) (z : K) : re (r • z) = r * re z := by\n  rw [real_smul_eq_coe_mul, re_ofReal_mul]\n\n"}
{"name":"RCLike.smul_im","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nr : Real\nz : K\n⊢ Eq (RCLike.im (HSMul.hSMul r z)) (HMul.hMul r (RCLike.im z))","decl":"@[rclike_simps]\ntheorem smul_im (r : ℝ) (z : K) : im (r • z) = r * im z := by\n  rw [real_smul_eq_coe_mul, im_ofReal_mul]\n\n"}
{"name":"RCLike.norm_ofReal","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nr : Real\n⊢ Eq (Norm.norm ↑r) (abs r)","decl":"@[rclike_simps, norm_cast]\ntheorem norm_ofReal (r : ℝ) : ‖(r : K)‖ = |r| :=\n  norm_algebraMap' K r\n\n"}
{"name":"RCLike.charZero_rclike","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\n⊢ CharZero K","decl":"/-- ℝ and ℂ are both of characteristic zero. -/\ninstance (priority := 100) charZero_rclike : CharZero K :=\n  (RingHom.charZero_iff (algebraMap ℝ K).injective).1 inferInstance\n\n"}
{"name":"RCLike.ofReal_expect","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nα : Type u_3\ns : Finset α\nf : α → Real\n⊢ Eq (↑(s.expect fun i => f i)) (s.expect fun i => ↑(f i))","decl":"@[rclike_simps, norm_cast]\nlemma ofReal_expect {α : Type*} (s : Finset α) (f : α → ℝ) : 𝔼 i ∈ s, f i = 𝔼 i ∈ s, (f i : K) :=\n  map_expect (algebraMap ..) ..\n\n"}
{"name":"RCLike.ofReal_balance","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝¹ : RCLike K\nι : Type u_3\ninst✝ : Fintype ι\nf : ι → Real\ni : ι\n⊢ Eq (↑(Fintype.balance f i)) (Fintype.balance (Function.comp RCLike.ofReal f) i)","decl":"@[norm_cast]\nlemma ofReal_balance {ι : Type*} [Fintype ι] (f : ι → ℝ) (i : ι) :\n    ((balance f i : ℝ) : K) = balance ((↑) ∘ f) i := map_balance (algebraMap ..) ..\n\n"}
{"name":"RCLike.ofReal_comp_balance","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝¹ : RCLike K\nι : Type u_3\ninst✝ : Fintype ι\nf : ι → Real\n⊢ Eq (Function.comp RCLike.ofReal (Fintype.balance f)) (Fintype.balance (Function.comp RCLike.ofReal f))","decl":"@[simp] lemma ofReal_comp_balance {ι : Type*} [Fintype ι] (f : ι → ℝ) :\n    ofReal ∘ balance f = balance (ofReal ∘ f : ι → K) := funext <| ofReal_balance _\n\n"}
{"name":"RCLike.I_re","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\n⊢ Eq (RCLike.re RCLike.I) 0","decl":"/-- The imaginary unit. -/\n@[simp, rclike_simps]\ntheorem I_re : re (I : K) = 0 :=\n  I_re_ax\n\n"}
{"name":"RCLike.I_im","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz : K\n⊢ Eq (HMul.hMul (RCLike.im z) (RCLike.im RCLike.I)) (RCLike.im z)","decl":"@[simp, rclike_simps]\ntheorem I_im (z : K) : im z * im (I : K) = im z :=\n  mul_im_I_ax z\n\n"}
{"name":"RCLike.I_im'","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz : K\n⊢ Eq (HMul.hMul (RCLike.im RCLike.I) (RCLike.im z)) (RCLike.im z)","decl":"@[simp, rclike_simps]\ntheorem I_im' (z : K) : im (I : K) * im z = im z := by rw [mul_comm, I_im]\n\n"}
{"name":"RCLike.I_mul_re","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz : K\n⊢ Eq (RCLike.re (HMul.hMul RCLike.I z)) (Neg.neg (RCLike.im z))","decl":"@[rclike_simps] -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11119): was `simp`\ntheorem I_mul_re (z : K) : re (I * z) = -im z := by\n  simp only [I_re, zero_sub, I_im', zero_mul, mul_re]\n\n"}
{"name":"RCLike.I_mul_I","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\n⊢ Or (Eq RCLike.I 0) (Eq (HMul.hMul RCLike.I RCLike.I) (-1))","decl":"theorem I_mul_I : (I : K) = 0 ∨ (I : K) * I = -1 :=\n  I_mul_I_ax\n\n"}
{"name":"RCLike.I_eq_zero_or_im_I_eq_one","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\n⊢ Or (Eq RCLike.I 0) (Eq (RCLike.im RCLike.I) 1)","decl":"variable (𝕜) in\nlemma I_eq_zero_or_im_I_eq_one : (I : K) = 0 ∨ im (I : K) = 1 :=\n  I_mul_I (K := K) |>.imp_right fun h ↦ by simpa [h] using (I_mul_re (I : K)).symm\n\n"}
{"name":"RCLike.conj_re","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz : K\n⊢ Eq (RCLike.re ((starRingEnd K) z)) (RCLike.re z)","decl":"@[simp, rclike_simps]\ntheorem conj_re (z : K) : re (conj z) = re z :=\n  RCLike.conj_re_ax z\n\n"}
{"name":"RCLike.conj_im","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz : K\n⊢ Eq (RCLike.im ((starRingEnd K) z)) (Neg.neg (RCLike.im z))","decl":"@[simp, rclike_simps]\ntheorem conj_im (z : K) : im (conj z) = -im z :=\n  RCLike.conj_im_ax z\n\n"}
{"name":"RCLike.conj_I","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\n⊢ Eq ((starRingEnd K) RCLike.I) (Neg.neg RCLike.I)","decl":"@[simp, rclike_simps]\ntheorem conj_I : conj (I : K) = -I :=\n  RCLike.conj_I_ax\n\n"}
{"name":"RCLike.conj_ofReal","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nr : Real\n⊢ Eq ((starRingEnd K) ↑r) ↑r","decl":"@[simp, rclike_simps]\ntheorem conj_ofReal (r : ℝ) : conj (r : K) = (r : K) := by\n  rw [ext_iff]\n  simp only [ofReal_im, conj_im, eq_self_iff_true, conj_re, and_self_iff, neg_zero]\n\n-- replaced by `RCLike.conj_ofNat`\n\n"}
{"name":"RCLike.conj_nat_cast","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nn : Nat\n⊢ Eq ((starRingEnd K) ↑n) ↑n","decl":"theorem conj_nat_cast (n : ℕ) : conj (n : K) = n := map_natCast _ _\n\n"}
{"name":"RCLike.conj_ofNat","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝¹ : RCLike K\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq ((starRingEnd K) (OfNat.ofNat n)) (OfNat.ofNat n)","decl":"theorem conj_ofNat (n : ℕ) [n.AtLeastTwo] : conj (ofNat(n) : K) = ofNat(n) :=\n  map_ofNat _ _\n\n"}
{"name":"RCLike.conj_neg_I","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\n⊢ Eq ((starRingEnd K) (Neg.neg RCLike.I)) RCLike.I","decl":"@[rclike_simps, simp]\ntheorem conj_neg_I : conj (-I) = (I : K) := by rw [map_neg, conj_I, neg_neg]\n\n"}
{"name":"RCLike.conj_eq_re_sub_im","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz : K\n⊢ Eq ((starRingEnd K) z) (HSub.hSub (↑(RCLike.re z)) (HMul.hMul (↑(RCLike.im z)) RCLike.I))","decl":"theorem conj_eq_re_sub_im (z : K) : conj z = re z - im z * I :=\n  (congr_arg conj (re_add_im z).symm).trans <| by\n    rw [map_add, map_mul, conj_I, conj_ofReal, conj_ofReal, mul_neg, sub_eq_add_neg]\n\n"}
{"name":"RCLike.sub_conj","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz : K\n⊢ Eq (HSub.hSub z ((starRingEnd K) z)) (HMul.hMul (HMul.hMul 2 ↑(RCLike.im z)) RCLike.I)","decl":"theorem sub_conj (z : K) : z - conj z = 2 * im z * I :=\n  calc\n    z - conj z = re z + im z * I - (re z - im z * I) := by rw [re_add_im, ← conj_eq_re_sub_im]\n    _ = 2 * im z * I := by rw [add_sub_sub_cancel, ← two_mul, mul_assoc]\n\n"}
{"name":"RCLike.conj_smul","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nr : Real\nz : K\n⊢ Eq ((starRingEnd K) (HSMul.hSMul r z)) (HSMul.hSMul r ((starRingEnd K) z))","decl":"@[rclike_simps]\ntheorem conj_smul (r : ℝ) (z : K) : conj (r • z) = r • conj z := by\n  rw [conj_eq_re_sub_im, conj_eq_re_sub_im, smul_re, smul_im, ofReal_mul, ofReal_mul,\n    real_smul_eq_coe_mul r (_ - _), mul_sub, mul_assoc]\n\n"}
{"name":"RCLike.add_conj","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz : K\n⊢ Eq (HAdd.hAdd z ((starRingEnd K) z)) (HMul.hMul 2 ↑(RCLike.re z))","decl":"theorem add_conj (z : K) : z + conj z = 2 * re z :=\n  calc\n    z + conj z = re z + im z * I + (re z - im z * I) := by rw [re_add_im, conj_eq_re_sub_im]\n    _ = 2 * re z := by rw [add_add_sub_cancel, two_mul]\n\n"}
{"name":"RCLike.re_eq_add_conj","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz : K\n⊢ Eq (↑(RCLike.re z)) (HDiv.hDiv (HAdd.hAdd z ((starRingEnd K) z)) 2)","decl":"theorem re_eq_add_conj (z : K) : ↑(re z) = (z + conj z) / 2 := by\n  rw [add_conj, mul_div_cancel_left₀ (re z : K) two_ne_zero]\n\n"}
{"name":"RCLike.im_eq_conj_sub","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz : K\n⊢ Eq (↑(RCLike.im z)) (HDiv.hDiv (HMul.hMul RCLike.I (HSub.hSub ((starRingEnd K) z) z)) 2)","decl":"theorem im_eq_conj_sub (z : K) : ↑(im z) = I * (conj z - z) / 2 := by\n  rw [← neg_inj, ← ofReal_neg, ← I_mul_re, re_eq_add_conj, map_mul, conj_I, ← neg_div, ← mul_neg,\n    neg_sub, mul_sub, neg_mul, sub_eq_add_neg]\n\n"}
{"name":"RCLike.is_real_TFAE","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz : K\n⊢ (List.cons (Eq ((starRingEnd K) z) z) (List.cons (Exists fun r => Eq (↑r) z) (List.cons (Eq (↑(RCLike.re z)) z) (List.cons (Eq (RCLike.im z) 0) List.nil)))).TFAE","decl":"open List in\n/-- There are several equivalent ways to say that a number `z` is in fact a real number. -/\ntheorem is_real_TFAE (z : K) : TFAE [conj z = z, ∃ r : ℝ, (r : K) = z, ↑(re z) = z, im z = 0] := by\n  tfae_have 1 → 4\n  | h => by\n    rw [← @ofReal_inj K, im_eq_conj_sub, h, sub_self, mul_zero, zero_div,\n      ofReal_zero]\n  tfae_have 4 → 3\n  | h => by\n    conv_rhs => rw [← re_add_im z, h, ofReal_zero, zero_mul, add_zero]\n  tfae_have 3 → 2 := fun h => ⟨_, h⟩\n  tfae_have 2 → 1 := fun ⟨r, hr⟩ => hr ▸ conj_ofReal _\n  tfae_finish\n\n"}
{"name":"RCLike.conj_eq_iff_real","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz : K\n⊢ Iff (Eq ((starRingEnd K) z) z) (Exists fun r => Eq z ↑r)","decl":"theorem conj_eq_iff_real {z : K} : conj z = z ↔ ∃ r : ℝ, z = (r : K) :=\n  calc\n    _ ↔ ∃ r : ℝ, (r : K) = z := (is_real_TFAE z).out 0 1\n    _ ↔ _                    := by simp only [eq_comm]\n\n"}
{"name":"RCLike.conj_eq_iff_re","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz : K\n⊢ Iff (Eq ((starRingEnd K) z) z) (Eq (↑(RCLike.re z)) z)","decl":"theorem conj_eq_iff_re {z : K} : conj z = z ↔ (re z : K) = z :=\n  (is_real_TFAE z).out 0 2\n\n"}
{"name":"RCLike.conj_eq_iff_im","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz : K\n⊢ Iff (Eq ((starRingEnd K) z) z) (Eq (RCLike.im z) 0)","decl":"theorem conj_eq_iff_im {z : K} : conj z = z ↔ im z = 0 :=\n  (is_real_TFAE z).out 0 3\n\n"}
{"name":"RCLike.star_def","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\n⊢ Eq Star.star ⇑(starRingEnd K)","decl":"@[simp]\ntheorem star_def : (Star.star : K → K) = conj :=\n  rfl\n\n"}
{"name":"RCLike.normSq_apply","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz : K\n⊢ Eq (RCLike.normSq z) (HAdd.hAdd (HMul.hMul (RCLike.re z) (RCLike.re z)) (HMul.hMul (RCLike.im z) (RCLike.im z)))","decl":"theorem normSq_apply (z : K) : normSq z = re z * re z + im z * im z :=\n  rfl\n\n"}
{"name":"RCLike.norm_sq_eq_def","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz : K\n⊢ Eq (HPow.hPow (Norm.norm z) 2) (HAdd.hAdd (HMul.hMul (RCLike.re z) (RCLike.re z)) (HMul.hMul (RCLike.im z) (RCLike.im z)))","decl":"theorem norm_sq_eq_def {z : K} : ‖z‖ ^ 2 = re z * re z + im z * im z :=\n  norm_sq_eq_def_ax z\n\n"}
{"name":"RCLike.normSq_eq_def'","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz : K\n⊢ Eq (RCLike.normSq z) (HPow.hPow (Norm.norm z) 2)","decl":"theorem normSq_eq_def' (z : K) : normSq z = ‖z‖ ^ 2 :=\n  norm_sq_eq_def.symm\n\n"}
{"name":"RCLike.normSq_zero","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\n⊢ Eq (RCLike.normSq 0) 0","decl":"@[rclike_simps]\ntheorem normSq_zero : normSq (0 : K) = 0 :=\n  normSq.map_zero\n\n"}
{"name":"RCLike.normSq_one","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\n⊢ Eq (RCLike.normSq 1) 1","decl":"@[rclike_simps]\ntheorem normSq_one : normSq (1 : K) = 1 :=\n  normSq.map_one\n\n"}
{"name":"RCLike.normSq_nonneg","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz : K\n⊢ LE.le 0 (RCLike.normSq z)","decl":"theorem normSq_nonneg (z : K) : 0 ≤ normSq z :=\n  add_nonneg (mul_self_nonneg _) (mul_self_nonneg _)\n\n"}
{"name":"RCLike.normSq_eq_zero","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz : K\n⊢ Iff (Eq (RCLike.normSq z) 0) (Eq z 0)","decl":"@[rclike_simps] -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11119): was `simp`\ntheorem normSq_eq_zero {z : K} : normSq z = 0 ↔ z = 0 :=\n  map_eq_zero _\n\n"}
{"name":"RCLike.normSq_pos","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz : K\n⊢ Iff (LT.lt 0 (RCLike.normSq z)) (Ne z 0)","decl":"@[simp, rclike_simps]\ntheorem normSq_pos {z : K} : 0 < normSq z ↔ z ≠ 0 := by\n  rw [lt_iff_le_and_ne, Ne, eq_comm]; simp [normSq_nonneg]\n\n"}
{"name":"RCLike.normSq_neg","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz : K\n⊢ Eq (RCLike.normSq (Neg.neg z)) (RCLike.normSq z)","decl":"@[simp, rclike_simps]\ntheorem normSq_neg (z : K) : normSq (-z) = normSq z := by simp only [normSq_eq_def', norm_neg]\n\n"}
{"name":"RCLike.normSq_conj","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz : K\n⊢ Eq (RCLike.normSq ((starRingEnd K) z)) (RCLike.normSq z)","decl":"@[simp, rclike_simps]\ntheorem normSq_conj (z : K) : normSq (conj z) = normSq z := by\n  simp only [normSq_apply, neg_mul, mul_neg, neg_neg, rclike_simps]\n\n"}
{"name":"RCLike.normSq_mul","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz w : K\n⊢ Eq (RCLike.normSq (HMul.hMul z w)) (HMul.hMul (RCLike.normSq z) (RCLike.normSq w))","decl":"@[rclike_simps] -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11119): was `simp`\ntheorem normSq_mul (z w : K) : normSq (z * w) = normSq z * normSq w :=\n  map_mul _ z w\n\n"}
{"name":"RCLike.normSq_add","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz w : K\n⊢ Eq (RCLike.normSq (HAdd.hAdd z w)) (HAdd.hAdd (HAdd.hAdd (RCLike.normSq z) (RCLike.normSq w)) (HMul.hMul 2 (RCLike.re (HMul.hMul z ((starRingEnd K) w)))))","decl":"theorem normSq_add (z w : K) : normSq (z + w) = normSq z + normSq w + 2 * re (z * conj w) := by\n  simp only [normSq_apply, map_add, rclike_simps]\n  ring\n\n"}
{"name":"RCLike.re_sq_le_normSq","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz : K\n⊢ LE.le (HMul.hMul (RCLike.re z) (RCLike.re z)) (RCLike.normSq z)","decl":"theorem re_sq_le_normSq (z : K) : re z * re z ≤ normSq z :=\n  le_add_of_nonneg_right (mul_self_nonneg _)\n\n"}
{"name":"RCLike.im_sq_le_normSq","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz : K\n⊢ LE.le (HMul.hMul (RCLike.im z) (RCLike.im z)) (RCLike.normSq z)","decl":"theorem im_sq_le_normSq (z : K) : im z * im z ≤ normSq z :=\n  le_add_of_nonneg_left (mul_self_nonneg _)\n\n"}
{"name":"RCLike.mul_conj","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz : K\n⊢ Eq (HMul.hMul z ((starRingEnd K) z)) (HPow.hPow (↑(Norm.norm z)) 2)","decl":"theorem mul_conj (z : K) : z * conj z = ‖z‖ ^ 2 := by\n  apply ext <;> simp [← ofReal_pow, norm_sq_eq_def, mul_comm]\n\n"}
{"name":"RCLike.conj_mul","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz : K\n⊢ Eq (HMul.hMul ((starRingEnd K) z) z) (HPow.hPow (↑(Norm.norm z)) 2)","decl":"theorem conj_mul (z : K) : conj z * z = ‖z‖ ^ 2 := by rw [mul_comm, mul_conj]\n\n"}
{"name":"RCLike.inv_eq_conj","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz : K\nhz : Eq (Norm.norm z) 1\n⊢ Eq (Inv.inv z) ((starRingEnd K) z)","decl":"lemma inv_eq_conj (hz : ‖z‖ = 1) : z⁻¹ = conj z :=\n  inv_eq_of_mul_eq_one_left <| by simp_rw [conj_mul, hz, algebraMap.coe_one, one_pow]\n\n"}
{"name":"RCLike.normSq_sub","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz w : K\n⊢ Eq (RCLike.normSq (HSub.hSub z w)) (HSub.hSub (HAdd.hAdd (RCLike.normSq z) (RCLike.normSq w)) (HMul.hMul 2 (RCLike.re (HMul.hMul z ((starRingEnd K) w)))))","decl":"theorem normSq_sub (z w : K) : normSq (z - w) = normSq z + normSq w - 2 * re (z * conj w) := by\n  simp only [normSq_add, sub_eq_add_neg, map_neg, mul_neg, normSq_neg, map_neg]\n\n"}
{"name":"RCLike.sqrt_normSq_eq_norm","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz : K\n⊢ Eq (RCLike.normSq z).sqrt (Norm.norm z)","decl":"theorem sqrt_normSq_eq_norm {z : K} : √(normSq z) = ‖z‖ := by\n  rw [normSq_eq_def', Real.sqrt_sq (norm_nonneg _)]\n\n"}
{"name":"RCLike.ofReal_inv","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nr : Real\n⊢ Eq (↑(Inv.inv r)) (Inv.inv ↑r)","decl":"@[rclike_simps, norm_cast]\ntheorem ofReal_inv (r : ℝ) : ((r⁻¹ : ℝ) : K) = (r : K)⁻¹ :=\n  map_inv₀ _ r\n\n"}
{"name":"RCLike.inv_def","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz : K\n⊢ Eq (Inv.inv z) (HMul.hMul ((starRingEnd K) z) ↑(Inv.inv (HPow.hPow (Norm.norm z) 2)))","decl":"theorem inv_def (z : K) : z⁻¹ = conj z * ((‖z‖ ^ 2)⁻¹ : ℝ) := by\n  rcases eq_or_ne z 0 with (rfl | h₀)\n  · simp\n  · apply inv_eq_of_mul_eq_one_right\n    rw [← mul_assoc, mul_conj, ofReal_inv, ofReal_pow, mul_inv_cancel₀]\n    simpa\n\n"}
{"name":"RCLike.inv_re","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz : K\n⊢ Eq (RCLike.re (Inv.inv z)) (HDiv.hDiv (RCLike.re z) (RCLike.normSq z))","decl":"@[simp, rclike_simps]\ntheorem inv_re (z : K) : re z⁻¹ = re z / normSq z := by\n  rw [inv_def, normSq_eq_def', mul_comm, re_ofReal_mul, conj_re, div_eq_inv_mul]\n\n"}
{"name":"RCLike.inv_im","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz : K\n⊢ Eq (RCLike.im (Inv.inv z)) (HDiv.hDiv (Neg.neg (RCLike.im z)) (RCLike.normSq z))","decl":"@[simp, rclike_simps]\ntheorem inv_im (z : K) : im z⁻¹ = -im z / normSq z := by\n  rw [inv_def, normSq_eq_def', mul_comm, im_ofReal_mul, conj_im, div_eq_inv_mul]\n\n"}
{"name":"RCLike.div_re","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz w : K\n⊢ Eq (RCLike.re (HDiv.hDiv z w)) (HAdd.hAdd (HDiv.hDiv (HMul.hMul (RCLike.re z) (RCLike.re w)) (RCLike.normSq w)) (HDiv.hDiv (HMul.hMul (RCLike.im z) (RCLike.im w)) (RCLike.normSq w)))","decl":"theorem div_re (z w : K) : re (z / w) = re z * re w / normSq w + im z * im w / normSq w := by\n  simp only [div_eq_mul_inv, mul_assoc, sub_eq_add_neg, neg_mul, mul_neg, neg_neg, map_neg,\n    rclike_simps]\n\n"}
{"name":"RCLike.div_im","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz w : K\n⊢ Eq (RCLike.im (HDiv.hDiv z w)) (HSub.hSub (HDiv.hDiv (HMul.hMul (RCLike.im z) (RCLike.re w)) (RCLike.normSq w)) (HDiv.hDiv (HMul.hMul (RCLike.re z) (RCLike.im w)) (RCLike.normSq w)))","decl":"theorem div_im (z w : K) : im (z / w) = im z * re w / normSq w - re z * im w / normSq w := by\n  simp only [div_eq_mul_inv, mul_assoc, sub_eq_add_neg, add_comm, neg_mul, mul_neg, map_neg,\n    rclike_simps]\n\n"}
{"name":"RCLike.conj_inv","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nx : K\n⊢ Eq ((starRingEnd K) (Inv.inv x)) (Inv.inv ((starRingEnd K) x))","decl":"@[rclike_simps] -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11119): was `simp`\ntheorem conj_inv (x : K) : conj x⁻¹ = (conj x)⁻¹ :=\n  star_inv₀ _\n\n"}
{"name":"RCLike.conj_div","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nx y : K\n⊢ Eq ((starRingEnd K) (HDiv.hDiv x y)) (HDiv.hDiv ((starRingEnd K) x) ((starRingEnd K) y))","decl":"lemma conj_div (x y : K) : conj (x / y) = conj x / conj y := map_div' conj conj_inv _ _\n\n--TODO: Do we rather want the map as an explicit definition?\n"}
{"name":"RCLike.exists_norm_eq_mul_self","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nx : K\n⊢ Exists fun c => And (Eq (Norm.norm c) 1) (Eq (↑(Norm.norm x)) (HMul.hMul c x))","decl":"lemma exists_norm_eq_mul_self (x : K) : ∃ c, ‖c‖ = 1 ∧ ↑‖x‖ = c * x := by\n  obtain rfl | hx := eq_or_ne x 0\n  · exact ⟨1, by simp⟩\n  · exact ⟨‖x‖ / x, by simp [norm_ne_zero_iff.2, hx]⟩\n\n"}
{"name":"RCLike.exists_norm_mul_eq_self","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nx : K\n⊢ Exists fun c => And (Eq (Norm.norm c) 1) (Eq (HMul.hMul c ↑(Norm.norm x)) x)","decl":"lemma exists_norm_mul_eq_self (x : K) : ∃ c, ‖c‖ = 1 ∧ c * ‖x‖ = x := by\n  obtain rfl | hx := eq_or_ne x 0\n  · exact ⟨1, by simp⟩\n  · exact ⟨x / ‖x‖, by simp [norm_ne_zero_iff.2, hx]⟩\n\n"}
{"name":"RCLike.ofReal_div","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nr s : Real\n⊢ Eq (↑(HDiv.hDiv r s)) (HDiv.hDiv ↑r ↑s)","decl":"@[rclike_simps, norm_cast]\ntheorem ofReal_div (r s : ℝ) : ((r / s : ℝ) : K) = r / s :=\n  map_div₀ (algebraMap ℝ K) r s\n\n"}
{"name":"RCLike.div_re_ofReal","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz : K\nr : Real\n⊢ Eq (RCLike.re (HDiv.hDiv z ↑r)) (HDiv.hDiv (RCLike.re z) r)","decl":"theorem div_re_ofReal {z : K} {r : ℝ} : re (z / r) = re z / r := by\n  rw [div_eq_inv_mul, div_eq_inv_mul, ← ofReal_inv, re_ofReal_mul]\n\n"}
{"name":"RCLike.ofReal_zpow","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nr : Real\nn : Int\n⊢ Eq (↑(HPow.hPow r n)) (HPow.hPow (↑r) n)","decl":"@[rclike_simps, norm_cast]\ntheorem ofReal_zpow (r : ℝ) (n : ℤ) : ((r ^ n : ℝ) : K) = (r : K) ^ n :=\n  map_zpow₀ (algebraMap ℝ K) r n\n\n"}
{"name":"RCLike.I_mul_I_of_nonzero","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\na✝ : Ne RCLike.I 0\n⊢ Eq (HMul.hMul RCLike.I RCLike.I) (-1)","decl":"theorem I_mul_I_of_nonzero : (I : K) ≠ 0 → (I : K) * I = -1 :=\n  I_mul_I_ax.resolve_left\n\n"}
{"name":"RCLike.inv_I","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\n⊢ Eq (Inv.inv RCLike.I) (Neg.neg RCLike.I)","decl":"@[simp, rclike_simps]\ntheorem inv_I : (I : K)⁻¹ = -I := by\n  by_cases h : (I : K) = 0\n  · simp [h]\n  · field_simp [I_mul_I_of_nonzero h]\n\n"}
{"name":"RCLike.div_I","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz : K\n⊢ Eq (HDiv.hDiv z RCLike.I) (Neg.neg (HMul.hMul z RCLike.I))","decl":"@[simp, rclike_simps]\ntheorem div_I (z : K) : z / I = -(z * I) := by rw [div_eq_mul_inv, inv_I, mul_neg]\n\n"}
{"name":"RCLike.normSq_inv","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz : K\n⊢ Eq (RCLike.normSq (Inv.inv z)) (Inv.inv (RCLike.normSq z))","decl":"@[rclike_simps] -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11119): was `simp`\ntheorem normSq_inv (z : K) : normSq z⁻¹ = (normSq z)⁻¹ :=\n  map_inv₀ normSq z\n\n"}
{"name":"RCLike.normSq_div","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz w : K\n⊢ Eq (RCLike.normSq (HDiv.hDiv z w)) (HDiv.hDiv (RCLike.normSq z) (RCLike.normSq w))","decl":"@[rclike_simps] -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11119): was `simp`\ntheorem normSq_div (z w : K) : normSq (z / w) = normSq z / normSq w :=\n  map_div₀ normSq z w\n\n"}
{"name":"RCLike.norm_conj","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz : K\n⊢ Eq (Norm.norm ((starRingEnd K) z)) (Norm.norm z)","decl":"@[simp 1100, rclike_simps]\ntheorem norm_conj (z : K) : ‖conj z‖ = ‖z‖ := by simp only [← sqrt_normSq_eq_norm, normSq_conj]\n\n"}
{"name":"RCLike.nnnorm_conj","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz : K\n⊢ Eq (NNNorm.nnnorm ((starRingEnd K) z)) (NNNorm.nnnorm z)","decl":"@[simp, rclike_simps] lemma nnnorm_conj (z : K) : ‖conj z‖₊ = ‖z‖₊ := by simp [nnnorm]\n\n"}
{"name":"RCLike.instCStarRing","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\n⊢ CStarRing K","decl":"instance (priority := 100) : CStarRing K where\n  norm_mul_self_le x := le_of_eq <| ((norm_mul _ _).trans <| congr_arg (· * ‖x‖) (norm_conj _)).symm\n\n"}
{"name":"RCLike.ofReal_natCast","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nn : Nat\n⊢ Eq ↑↑n ↑n","decl":"@[rclike_simps, norm_cast]\ntheorem ofReal_natCast (n : ℕ) : ((n : ℝ) : K) = n :=\n  map_natCast (algebraMap ℝ K) n\n\n"}
{"name":"RCLike.ofReal_nnratCast","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nq : NNRat\n⊢ Eq ↑↑q ↑q","decl":"@[rclike_simps, norm_cast]\nlemma ofReal_nnratCast (q : ℚ≥0) : ((q : ℝ) : K) = q := map_nnratCast (algebraMap ℝ K) _\n\n"}
{"name":"RCLike.natCast_re","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nn : Nat\n⊢ Eq (RCLike.re ↑n) ↑n","decl":"@[simp, rclike_simps] -- Porting note: removed `norm_cast`\ntheorem natCast_re (n : ℕ) : re (n : K) = n := by rw [← ofReal_natCast, ofReal_re]\n\n"}
{"name":"RCLike.natCast_im","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nn : Nat\n⊢ Eq (RCLike.im ↑n) 0","decl":"@[simp, rclike_simps, norm_cast]\ntheorem natCast_im (n : ℕ) : im (n : K) = 0 := by rw [← ofReal_natCast, ofReal_im]\n"}
{"name":"RCLike.ofNat_re","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝¹ : RCLike K\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (RCLike.re (OfNat.ofNat n)) (OfNat.ofNat n)","decl":"@[simp, rclike_simps]\ntheorem ofNat_re (n : ℕ) [n.AtLeastTwo] : re (ofNat(n) : K) = ofNat(n) :=\n  natCast_re n\n"}
{"name":"RCLike.ofNat_im","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝¹ : RCLike K\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (RCLike.im (OfNat.ofNat n)) 0","decl":"@[simp, rclike_simps]\ntheorem ofNat_im (n : ℕ) [n.AtLeastTwo] : im (ofNat(n) : K) = 0 :=\n  natCast_im n\n\n"}
{"name":"RCLike.ofReal_ofNat","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝¹ : RCLike K\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (↑(OfNat.ofNat n)) (OfNat.ofNat n)","decl":"@[rclike_simps, norm_cast]\ntheorem ofReal_ofNat (n : ℕ) [n.AtLeastTwo] : ((ofNat(n) : ℝ) : K) = ofNat(n) :=\n  ofReal_natCast n\n\n"}
{"name":"RCLike.ofNat_mul_re","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝¹ : RCLike K\nn : Nat\ninst✝ : n.AtLeastTwo\nz : K\n⊢ Eq (RCLike.re (HMul.hMul (OfNat.ofNat n) z)) (HMul.hMul (OfNat.ofNat n) (RCLike.re z))","decl":"theorem ofNat_mul_re (n : ℕ) [n.AtLeastTwo] (z : K) :\n    re (ofNat(n) * z) = ofNat(n) * re z := by\n  rw [← ofReal_ofNat, re_ofReal_mul]\n\n"}
{"name":"RCLike.ofNat_mul_im","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝¹ : RCLike K\nn : Nat\ninst✝ : n.AtLeastTwo\nz : K\n⊢ Eq (RCLike.im (HMul.hMul (OfNat.ofNat n) z)) (HMul.hMul (OfNat.ofNat n) (RCLike.im z))","decl":"theorem ofNat_mul_im (n : ℕ) [n.AtLeastTwo] (z : K) :\n    im (ofNat(n) * z) = ofNat(n) * im z := by\n  rw [← ofReal_ofNat, im_ofReal_mul]\n\n"}
{"name":"RCLike.ofReal_intCast","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nn : Int\n⊢ Eq ↑↑n ↑n","decl":"@[rclike_simps, norm_cast]\ntheorem ofReal_intCast (n : ℤ) : ((n : ℝ) : K) = n :=\n  map_intCast _ n\n\n"}
{"name":"RCLike.intCast_re","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nn : Int\n⊢ Eq (RCLike.re ↑n) ↑n","decl":"@[simp, rclike_simps] -- Porting note: removed `norm_cast`\ntheorem intCast_re (n : ℤ) : re (n : K) = n := by rw [← ofReal_intCast, ofReal_re]\n\n"}
{"name":"RCLike.intCast_im","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nn : Int\n⊢ Eq (RCLike.im ↑n) 0","decl":"@[simp, rclike_simps, norm_cast]\ntheorem intCast_im (n : ℤ) : im (n : K) = 0 := by rw [← ofReal_intCast, ofReal_im]\n\n"}
{"name":"RCLike.ofReal_ratCast","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nn : Rat\n⊢ Eq ↑↑n ↑n","decl":"@[rclike_simps, norm_cast]\ntheorem ofReal_ratCast (n : ℚ) : ((n : ℝ) : K) = n :=\n  map_ratCast _ n\n\n"}
{"name":"RCLike.ratCast_re","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nq : Rat\n⊢ Eq (RCLike.re ↑q) ↑q","decl":"@[simp, rclike_simps] -- Porting note: removed `norm_cast`\ntheorem ratCast_re (q : ℚ) : re (q : K) = q := by rw [← ofReal_ratCast, ofReal_re]\n\n"}
{"name":"RCLike.ratCast_im","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nq : Rat\n⊢ Eq (RCLike.im ↑q) 0","decl":"@[simp, rclike_simps, norm_cast]\ntheorem ratCast_im (q : ℚ) : im (q : K) = 0 := by rw [← ofReal_ratCast, ofReal_im]\n\n"}
{"name":"RCLike.norm_of_nonneg","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nr : Real\nh : LE.le 0 r\n⊢ Eq (Norm.norm ↑r) r","decl":"theorem norm_of_nonneg {r : ℝ} (h : 0 ≤ r) : ‖(r : K)‖ = r :=\n  (norm_ofReal _).trans (abs_of_nonneg h)\n\n"}
{"name":"RCLike.norm_natCast","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nn : Nat\n⊢ Eq (Norm.norm ↑n) ↑n","decl":"@[simp, rclike_simps, norm_cast]\ntheorem norm_natCast (n : ℕ) : ‖(n : K)‖ = n := by\n  rw [← ofReal_natCast]\n  exact norm_of_nonneg (Nat.cast_nonneg n)\n\n"}
{"name":"RCLike.nnnorm_natCast","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nn : Nat\n⊢ Eq (NNNorm.nnnorm ↑n) ↑n","decl":"@[simp, rclike_simps, norm_cast] lemma nnnorm_natCast (n : ℕ) : ‖(n : K)‖₊ = n := by simp [nnnorm]\n\n"}
{"name":"RCLike.norm_ofNat","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝¹ : RCLike K\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (Norm.norm (OfNat.ofNat n)) (OfNat.ofNat n)","decl":"@[simp, rclike_simps]\ntheorem norm_ofNat (n : ℕ) [n.AtLeastTwo] : ‖(ofNat(n) : K)‖ = ofNat(n) :=\n  norm_natCast n\n\n"}
{"name":"RCLike.nnnorm_ofNat","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝¹ : RCLike K\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (NNNorm.nnnorm (OfNat.ofNat n)) (OfNat.ofNat n)","decl":"@[simp, rclike_simps]\nlemma nnnorm_ofNat (n : ℕ) [n.AtLeastTwo] : ‖(ofNat(n) : K)‖₊ = ofNat(n) :=\n  nnnorm_natCast n\n\n"}
{"name":"RCLike.norm_two","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\n⊢ Eq (Norm.norm 2) 2","decl":"lemma norm_two : ‖(2 : K)‖ = 2 := norm_ofNat 2\n"}
{"name":"RCLike.nnnorm_two","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\n⊢ Eq (NNNorm.nnnorm 2) 2","decl":"lemma nnnorm_two : ‖(2 : K)‖₊ = 2 := nnnorm_ofNat 2\n\n"}
{"name":"RCLike.norm_nnratCast","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nq : NNRat\n⊢ Eq (Norm.norm ↑q) ↑q","decl":"@[simp, rclike_simps, norm_cast]\nlemma norm_nnratCast (q : ℚ≥0) : ‖(q : K)‖ = q := by\n  rw [← ofReal_nnratCast]; exact norm_of_nonneg q.cast_nonneg\n\n"}
{"name":"RCLike.nnnorm_nnratCast","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nq : NNRat\n⊢ Eq (NNNorm.nnnorm ↑q) ↑q","decl":"@[simp, rclike_simps, norm_cast]\nlemma nnnorm_nnratCast (q : ℚ≥0) : ‖(q : K)‖₊ = q := by simp [nnnorm]\n\n"}
{"name":"RCLike.norm_nsmul","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\nE : Type u_2\ninst✝² : RCLike K\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace K E\nn : Nat\nx : E\n⊢ Eq (Norm.norm (HSMul.hSMul n x)) (HSMul.hSMul n (Norm.norm x))","decl":"variable (K) in\nlemma norm_nsmul [NormedAddCommGroup E] [NormedSpace K E] (n : ℕ) (x : E) : ‖n • x‖ = n • ‖x‖ := by\n  simpa [Nat.cast_smul_eq_nsmul] using norm_smul (n : K) x\n\n"}
{"name":"RCLike.nnnorm_nsmul","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\nE : Type u_2\ninst✝² : RCLike K\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace K E\nn : Nat\nx : E\n⊢ Eq (NNNorm.nnnorm (HSMul.hSMul n x)) (HSMul.hSMul n (NNNorm.nnnorm x))","decl":"variable (K) in\nlemma nnnorm_nsmul [NormedAddCommGroup E] [NormedSpace K E] (n : ℕ) (x : E) :\n    ‖n • x‖₊ = n • ‖x‖₊ := by simpa [Nat.cast_smul_eq_nsmul] using nnnorm_smul (n : K) x\n\n"}
{"name":"RCLike.norm_nnqsmul","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\nE : Type u_2\ninst✝³ : RCLike K\ninst✝² : NormedField E\ninst✝¹ : CharZero E\ninst✝ : NormedSpace K E\nq : NNRat\nx : E\n⊢ Eq (Norm.norm (HSMul.hSMul q x)) (HSMul.hSMul q (Norm.norm x))","decl":"variable (K) in\nlemma norm_nnqsmul (q : ℚ≥0) (x : E) : ‖q • x‖ = q • ‖x‖ := by\n  simpa [NNRat.cast_smul_eq_nnqsmul] using norm_smul (q : K) x\n\n"}
{"name":"RCLike.nnnorm_nnqsmul","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\nE : Type u_2\ninst✝³ : RCLike K\ninst✝² : NormedField E\ninst✝¹ : CharZero E\ninst✝ : NormedSpace K E\nq : NNRat\nx : E\n⊢ Eq (NNNorm.nnnorm (HSMul.hSMul q x)) (HSMul.hSMul q (NNNorm.nnnorm x))","decl":"variable (K) in\nlemma nnnorm_nnqsmul (q : ℚ≥0) (x : E) : ‖q • x‖₊ = q • ‖x‖₊ := by\n  simpa [NNRat.cast_smul_eq_nnqsmul] using nnnorm_smul (q : K) x\n\n"}
{"name":"RCLike.norm_expect_le","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\nE : Type u_2\ninst✝³ : RCLike K\ninst✝² : NormedField E\ninst✝¹ : CharZero E\ninst✝ : NormedSpace K E\nι : Type u_3\ns : Finset ι\nf : ι → E\n⊢ LE.le (Norm.norm (s.expect fun i => f i)) (s.expect fun i => Norm.norm (f i))","decl":"@[bound]\nlemma norm_expect_le {ι : Type*} {s : Finset ι} {f : ι → E} : ‖𝔼 i ∈ s, f i‖ ≤ 𝔼 i ∈ s, ‖f i‖ :=\n  Finset.le_expect_of_subadditive norm_zero norm_add_le fun _ _ ↦ by rw [norm_nnqsmul K]\n\n"}
{"name":"RCLike.mul_self_norm","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz : K\n⊢ Eq (HMul.hMul (Norm.norm z) (Norm.norm z)) (RCLike.normSq z)","decl":"theorem mul_self_norm (z : K) : ‖z‖ * ‖z‖ = normSq z := by rw [normSq_eq_def', sq]\n\n"}
{"name":"RCLike.abs_re_le_norm","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz : K\n⊢ LE.le (abs (RCLike.re z)) (Norm.norm z)","decl":"theorem abs_re_le_norm (z : K) : |re z| ≤ ‖z‖ := by\n  rw [mul_self_le_mul_self_iff (abs_nonneg _) (norm_nonneg _), abs_mul_abs_self, mul_self_norm]\n  apply re_sq_le_normSq\n\n"}
{"name":"RCLike.abs_im_le_norm","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz : K\n⊢ LE.le (abs (RCLike.im z)) (Norm.norm z)","decl":"theorem abs_im_le_norm (z : K) : |im z| ≤ ‖z‖ := by\n  rw [mul_self_le_mul_self_iff (abs_nonneg _) (norm_nonneg _), abs_mul_abs_self, mul_self_norm]\n  apply im_sq_le_normSq\n\n"}
{"name":"RCLike.norm_re_le_norm","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz : K\n⊢ LE.le (Norm.norm (RCLike.re z)) (Norm.norm z)","decl":"theorem norm_re_le_norm (z : K) : ‖re z‖ ≤ ‖z‖ :=\n  abs_re_le_norm z\n\n"}
{"name":"RCLike.norm_im_le_norm","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz : K\n⊢ LE.le (Norm.norm (RCLike.im z)) (Norm.norm z)","decl":"theorem norm_im_le_norm (z : K) : ‖im z‖ ≤ ‖z‖ :=\n  abs_im_le_norm z\n\n"}
{"name":"RCLike.re_le_norm","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz : K\n⊢ LE.le (RCLike.re z) (Norm.norm z)","decl":"theorem re_le_norm (z : K) : re z ≤ ‖z‖ :=\n  (abs_le.1 (abs_re_le_norm z)).2\n\n"}
{"name":"RCLike.im_le_norm","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz : K\n⊢ LE.le (RCLike.im z) (Norm.norm z)","decl":"theorem im_le_norm (z : K) : im z ≤ ‖z‖ :=\n  (abs_le.1 (abs_im_le_norm _)).2\n\n"}
{"name":"RCLike.im_eq_zero_of_le","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\na : K\nh : LE.le (Norm.norm a) (RCLike.re a)\n⊢ Eq (RCLike.im a) 0","decl":"theorem im_eq_zero_of_le {a : K} (h : ‖a‖ ≤ re a) : im a = 0 := by\n  simpa only [mul_self_norm a, normSq_apply, self_eq_add_right, mul_self_eq_zero]\n    using congr_arg (fun z => z * z) ((re_le_norm a).antisymm h)\n\n"}
{"name":"RCLike.re_eq_self_of_le","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\na : K\nh : LE.le (Norm.norm a) (RCLike.re a)\n⊢ Eq (↑(RCLike.re a)) a","decl":"theorem re_eq_self_of_le {a : K} (h : ‖a‖ ≤ re a) : (re a : K) = a := by\n  rw [← conj_eq_iff_re, conj_eq_iff_im, im_eq_zero_of_le h]\n\n"}
{"name":"RCLike.abs_re_div_norm_le_one","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz : K\n⊢ LE.le (abs (HDiv.hDiv (RCLike.re z) (Norm.norm z))) 1","decl":"theorem abs_re_div_norm_le_one (z : K) : |re z / ‖z‖| ≤ 1 := by\n  rw [abs_div, abs_norm]\n  exact div_le_one_of_le₀ (abs_re_le_norm _) (norm_nonneg _)\n\n"}
{"name":"RCLike.abs_im_div_norm_le_one","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz : K\n⊢ LE.le (abs (HDiv.hDiv (RCLike.im z) (Norm.norm z))) 1","decl":"theorem abs_im_div_norm_le_one (z : K) : |im z / ‖z‖| ≤ 1 := by\n  rw [abs_div, abs_norm]\n  exact div_le_one_of_le₀ (abs_im_le_norm _) (norm_nonneg _)\n\n"}
{"name":"RCLike.norm_I_of_ne_zero","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nhI : Ne RCLike.I 0\n⊢ Eq (Norm.norm RCLike.I) 1","decl":"theorem norm_I_of_ne_zero (hI : (I : K) ≠ 0) : ‖(I : K)‖ = 1 := by\n  rw [← mul_self_inj_of_nonneg (norm_nonneg I) zero_le_one, one_mul, ← norm_mul,\n    I_mul_I_of_nonzero hI, norm_neg, norm_one]\n\n"}
{"name":"RCLike.re_eq_norm_of_mul_conj","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nx : K\n⊢ Eq (RCLike.re (HMul.hMul x ((starRingEnd K) x))) (Norm.norm (HMul.hMul x ((starRingEnd K) x)))","decl":"theorem re_eq_norm_of_mul_conj (x : K) : re (x * conj x) = ‖x * conj x‖ := by\n  rw [mul_conj, ← ofReal_pow]; simp [-map_pow]\n\n"}
{"name":"RCLike.norm_sq_re_add_conj","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nx : K\n⊢ Eq (HPow.hPow (Norm.norm (HAdd.hAdd x ((starRingEnd K) x))) 2) (HPow.hPow (RCLike.re (HAdd.hAdd x ((starRingEnd K) x))) 2)","decl":"theorem norm_sq_re_add_conj (x : K) : ‖x + conj x‖ ^ 2 = re (x + conj x) ^ 2 := by\n  rw [add_conj, ← ofReal_ofNat, ← ofReal_mul, norm_ofReal, sq_abs, ofReal_re]\n\n"}
{"name":"RCLike.norm_sq_re_conj_add","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nx : K\n⊢ Eq (HPow.hPow (Norm.norm (HAdd.hAdd ((starRingEnd K) x) x)) 2) (HPow.hPow (RCLike.re (HAdd.hAdd ((starRingEnd K) x) x)) 2)","decl":"theorem norm_sq_re_conj_add (x : K) : ‖conj x + x‖ ^ 2 = re (conj x + x) ^ 2 := by\n  rw [add_comm, norm_sq_re_add_conj]\n\n"}
{"name":"RCLike.isCauSeq_re","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nf : CauSeq K Norm.norm\n⊢ IsCauSeq abs fun n => RCLike.re (↑f n)","decl":"theorem isCauSeq_re (f : CauSeq K norm) : IsCauSeq abs fun n => re (f n) := fun _ ε0 =>\n  (f.cauchy ε0).imp fun i H j ij =>\n    lt_of_le_of_lt (by simpa only [map_sub] using abs_re_le_norm (f j - f i)) (H _ ij)\n\n"}
{"name":"RCLike.isCauSeq_im","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nf : CauSeq K Norm.norm\n⊢ IsCauSeq abs fun n => RCLike.im (↑f n)","decl":"theorem isCauSeq_im (f : CauSeq K norm) : IsCauSeq abs fun n => im (f n) := fun _ ε0 =>\n  (f.cauchy ε0).imp fun i H j ij =>\n    lt_of_le_of_lt (by simpa only [map_sub] using abs_im_le_norm (f j - f i)) (H _ ij)\n\n"}
{"name":"RCLike.isCauSeq_norm","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nf : Nat → K\nhf : IsCauSeq Norm.norm f\n⊢ IsCauSeq abs (Function.comp Norm.norm f)","decl":"theorem isCauSeq_norm {f : ℕ → K} (hf : IsCauSeq norm f) : IsCauSeq abs (norm ∘ f) := fun ε ε0 =>\n  let ⟨i, hi⟩ := hf ε ε0\n  ⟨i, fun j hj => lt_of_le_of_lt (abs_norm_sub_norm_le _ _) (hi j hj)⟩\n\n"}
{"name":"RCLike.lt_iff_re_im","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz w : K\n⊢ Iff (LT.lt z w) (And (LT.lt (RCLike.re z) (RCLike.re w)) (Eq (RCLike.im z) (RCLike.im w)))","decl":"theorem lt_iff_re_im : z < w ↔ re z < re w ∧ im z = im w := by\n  simp_rw [lt_iff_le_and_ne, @RCLike.le_iff_re_im K]\n  constructor\n  · rintro ⟨⟨hr, hi⟩, heq⟩\n    exact ⟨⟨hr, mt (fun hreq => ext hreq hi) heq⟩, hi⟩\n  · rintro ⟨⟨hr, hrn⟩, hi⟩\n    exact ⟨⟨hr, hi⟩, ne_of_apply_ne _ hrn⟩\n\n"}
{"name":"RCLike.nonneg_iff","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz : K\n⊢ Iff (LE.le 0 z) (And (LE.le 0 (RCLike.re z)) (Eq (RCLike.im z) 0))","decl":"theorem nonneg_iff : 0 ≤ z ↔ 0 ≤ re z ∧ im z = 0 := by\n  simpa only [map_zero, eq_comm] using le_iff_re_im (z := 0) (w := z)\n\n"}
{"name":"RCLike.pos_iff","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz : K\n⊢ Iff (LT.lt 0 z) (And (LT.lt 0 (RCLike.re z)) (Eq (RCLike.im z) 0))","decl":"theorem pos_iff : 0 < z ↔ 0 < re z ∧ im z = 0 := by\n  simpa only [map_zero, eq_comm] using lt_iff_re_im (z := 0) (w := z)\n\n"}
{"name":"RCLike.nonpos_iff","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz : K\n⊢ Iff (LE.le z 0) (And (LE.le (RCLike.re z) 0) (Eq (RCLike.im z) 0))","decl":"theorem nonpos_iff : z ≤ 0 ↔ re z ≤ 0 ∧ im z = 0 := by\n  simpa only [map_zero] using le_iff_re_im (z := z) (w := 0)\n\n"}
{"name":"RCLike.neg_iff","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz : K\n⊢ Iff (LT.lt z 0) (And (LT.lt (RCLike.re z) 0) (Eq (RCLike.im z) 0))","decl":"theorem neg_iff : z < 0 ↔ re z < 0 ∧ im z = 0 := by\n  simpa only [map_zero] using lt_iff_re_im (z := z) (w := 0)\n\n"}
{"name":"RCLike.nonneg_iff_exists_ofReal","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz : K\n⊢ Iff (LE.le 0 z) (Exists fun x => And (GE.ge x 0) (Eq (↑x) z))","decl":"lemma nonneg_iff_exists_ofReal : 0 ≤ z ↔ ∃ x ≥ (0 : ℝ), x = z := by\n  simp_rw [nonneg_iff (K := K), ext_iff (K := K)]; aesop\n\n"}
{"name":"RCLike.pos_iff_exists_ofReal","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz : K\n⊢ Iff (LT.lt 0 z) (Exists fun x => And (GT.gt x 0) (Eq (↑x) z))","decl":"lemma pos_iff_exists_ofReal : 0 < z ↔ ∃ x > (0 : ℝ), x = z := by\n  simp_rw [pos_iff (K := K), ext_iff (K := K)]; aesop\n\n"}
{"name":"RCLike.nonpos_iff_exists_ofReal","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz : K\n⊢ Iff (LE.le z 0) (Exists fun x => And (LE.le x 0) (Eq (↑x) z))","decl":"lemma nonpos_iff_exists_ofReal : z ≤ 0 ↔ ∃ x ≤ (0 : ℝ), x = z := by\n  simp_rw [nonpos_iff (K := K), ext_iff (K := K)]; aesop\n\n"}
{"name":"RCLike.neg_iff_exists_ofReal","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz : K\n⊢ Iff (LT.lt z 0) (Exists fun x => And (LT.lt x 0) (Eq (↑x) z))","decl":"lemma neg_iff_exists_ofReal : z < 0 ↔ ∃ x < (0 : ℝ), x = z := by\n  simp_rw [neg_iff (K := K), ext_iff (K := K)]; aesop\n\n"}
{"name":"RCLike.ofReal_le_ofReal","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nx y : Real\n⊢ Iff (LE.le ↑x ↑y) (LE.le x y)","decl":"@[simp, norm_cast]\nlemma ofReal_le_ofReal {x y : ℝ} : (x : K) ≤ (y : K) ↔ x ≤ y := by\n  rw [le_iff_re_im]\n  simp\n\n"}
{"name":"RCLike.ofReal_lt_ofReal","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nx y : Real\n⊢ Iff (LT.lt ↑x ↑y) (LT.lt x y)","decl":"@[simp, norm_cast]\nlemma ofReal_lt_ofReal {x y : ℝ} : (x : K) < (y : K) ↔ x < y := by\n  rw [lt_iff_re_im]\n  simp\n\n"}
{"name":"RCLike.ofReal_nonneg","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nx : Real\n⊢ Iff (LE.le 0 ↑x) (LE.le 0 x)","decl":"@[simp, norm_cast]\nlemma ofReal_nonneg {x : ℝ} : 0 ≤ (x : K) ↔ 0 ≤ x := by\n  rw [← ofReal_zero, ofReal_le_ofReal]\n\n"}
{"name":"RCLike.ofReal_nonpos","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nx : Real\n⊢ Iff (LE.le (↑x) 0) (LE.le x 0)","decl":"@[simp, norm_cast]\nlemma ofReal_nonpos {x : ℝ} : (x : K) ≤ 0 ↔ x ≤ 0 := by\n  rw [← ofReal_zero, ofReal_le_ofReal]\n\n"}
{"name":"RCLike.ofReal_pos","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nx : Real\n⊢ Iff (LT.lt 0 ↑x) (LT.lt 0 x)","decl":"@[simp, norm_cast]\nlemma ofReal_pos {x : ℝ} : 0 < (x : K) ↔ 0 < x := by\n  rw [← ofReal_zero, ofReal_lt_ofReal]\n\n"}
{"name":"RCLike.ofReal_lt_zero","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nx : Real\n⊢ Iff (LT.lt (↑x) 0) (LT.lt x 0)","decl":"@[simp, norm_cast]\nlemma ofReal_lt_zero {x : ℝ} : (x : K) < 0 ↔ x < 0 := by\n  rw [← ofReal_zero, ofReal_lt_ofReal]\n\n"}
{"name":"RCLike.inv_pos_of_pos","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz : K\nhz : LT.lt 0 z\n⊢ LT.lt 0 (Inv.inv z)","decl":"protected lemma inv_pos_of_pos (hz : 0 < z) : 0 < z⁻¹ := by\n  rw [pos_iff_exists_ofReal] at hz\n  obtain ⟨x, hx, hx'⟩ := hz\n  rw [← hx', ← ofReal_inv, ofReal_pos]\n  exact inv_pos_of_pos hx\n\n"}
{"name":"RCLike.inv_pos","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nz : K\n⊢ Iff (LT.lt 0 (Inv.inv z)) (LT.lt 0 z)","decl":"protected lemma inv_pos : 0 < z⁻¹ ↔ 0 < z := by\n  refine ⟨fun h => ?_, fun h => RCLike.inv_pos_of_pos h⟩\n  rw [← inv_inv z]\n  exact RCLike.inv_pos_of_pos h\n\n"}
{"name":"RCLike.toStarOrderedRing","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\n⊢ StarOrderedRing K","decl":"/-- With `z ≤ w` iff `w - z` is real and nonnegative, `ℝ` and `ℂ` are star ordered rings.\n(That is, a star ring in which the nonnegative elements are those of the form `star z * z`.)\n\nNote this is only an instance with `open scoped ComplexOrder`. -/\nlemma toStarOrderedRing : StarOrderedRing K :=\n  StarOrderedRing.of_nonneg_iff'\n    (h_add := fun {x y} hxy z => by\n      rw [RCLike.le_iff_re_im] at *\n      simpa [map_add, add_le_add_iff_left, add_right_inj] using hxy)\n    (h_nonneg_iff := fun x => by\n      rw [nonneg_iff]\n      refine ⟨fun h ↦ ⟨√(re x), by simp [ext_iff (K := K), h.1, h.2]⟩, ?_⟩\n      rintro ⟨s, rfl⟩\n      simp [mul_comm, mul_self_nonneg, add_nonneg])\n\n"}
{"name":"RCLike.toOrderedSMul","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\n⊢ OrderedSMul Real K","decl":"theorem toOrderedSMul : OrderedSMul ℝ K :=\n  OrderedSMul.mk' fun a b r hab hr => by\n    replace hab := hab.le\n    rw [RCLike.le_iff_re_im] at hab\n    rw [RCLike.le_iff_re_im, smul_re, smul_re, smul_im, smul_im]\n    exact hab.imp (fun h => mul_le_mul_of_nonneg_left h hr.le) (congr_arg _)\n\n"}
{"name":"StarModule.instOrderedSMul","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝⁸ : RCLike K\nA : Type u_3\ninst✝⁷ : NonUnitalRing A\ninst✝⁶ : StarRing A\ninst✝⁵ : PartialOrder A\ninst✝⁴ : StarOrderedRing A\ninst✝³ : Module K A\ninst✝² : StarModule K A\ninst✝¹ : IsScalarTower K A A\ninst✝ : SMulCommClass K A A\n⊢ OrderedSMul K A","decl":"/-- A star algebra over `K` has a scalar multiplication that respects the order. -/\nlemma _root_.StarModule.instOrderedSMul {A : Type*} [NonUnitalRing A] [StarRing A] [PartialOrder A]\n    [StarOrderedRing A] [Module K A] [StarModule K A] [IsScalarTower K A A] [SMulCommClass K A A] :\n    OrderedSMul K A where\n  smul_lt_smul_of_pos {_ _ _} hxy hc := StarModule.smul_lt_smul_of_pos hxy hc\n  lt_of_smul_lt_smul_of_pos {x y c} hxy hc := by\n    have : c⁻¹ • c • x < c⁻¹ • c • y :=\n      StarModule.smul_lt_smul_of_pos hxy (RCLike.inv_pos_of_pos hc)\n    simpa [smul_smul, inv_mul_cancel₀ hc.ne'] using this\n\n"}
{"name":"RCLike.instOrderedSMulRealOfStarModuleOfIsScalarTowerOfSMulCommClass","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"A : Type u_3\ninst✝⁷ : NonUnitalRing A\ninst✝⁶ : StarRing A\ninst✝⁵ : PartialOrder A\ninst✝⁴ : StarOrderedRing A\ninst✝³ : Module Real A\ninst✝² : StarModule Real A\ninst✝¹ : IsScalarTower Real A A\ninst✝ : SMulCommClass Real A A\n⊢ OrderedSMul Real A","decl":"instance {A : Type*} [NonUnitalRing A] [StarRing A] [PartialOrder A] [StarOrderedRing A]\n    [Module ℝ A] [StarModule ℝ A] [IsScalarTower ℝ A A] [SMulCommClass ℝ A A] :\n    OrderedSMul ℝ A :=\n  StarModule.instOrderedSMul\n\n"}
{"name":"RCLike.ofReal_mul_pos_iff","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nx : Real\nz : K\n⊢ Iff (LT.lt 0 (HMul.hMul (↑x) z)) (Or (And (LT.lt x 0) (LT.lt z 0)) (And (LT.lt 0 x) (LT.lt 0 z)))","decl":"theorem ofReal_mul_pos_iff (x : ℝ) (z : K) :\n    0 < x * z ↔ (x < 0 ∧ z < 0) ∨ (0 < x ∧ 0 < z) := by\n  simp only [pos_iff (K := K), neg_iff (K := K), re_ofReal_mul, im_ofReal_mul]\n  obtain hx | hx | hx := lt_trichotomy x 0\n  · simp only [mul_pos_iff, not_lt_of_gt hx, false_and, hx, true_and, false_or, mul_eq_zero, hx.ne,\n      or_false]\n  · simp only [hx, zero_mul, lt_self_iff_false, false_and, false_or]\n  · simp only [mul_pos_iff, hx, true_and, not_lt_of_gt hx, false_and, or_false, mul_eq_zero,\n      hx.ne', false_or]\n\n"}
{"name":"RCLike.ofReal_mul_neg_iff","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nx : Real\nz : K\n⊢ Iff (LT.lt (HMul.hMul (↑x) z) 0) (Or (And (LT.lt x 0) (LT.lt 0 z)) (And (LT.lt 0 x) (LT.lt z 0)))","decl":"theorem ofReal_mul_neg_iff (x : ℝ) (z : K) :\n    x * z < 0 ↔ (x < 0 ∧ 0 < z) ∨ (0 < x ∧ z < 0) := by\n  simpa only [mul_neg, neg_pos, neg_neg_iff_pos] using ofReal_mul_pos_iff x (-z)\n\n"}
{"name":"RCLike.re_to_real","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"x : Real\n⊢ Eq (RCLike.re x) x","decl":"@[simp, rclike_simps]\ntheorem re_to_real {x : ℝ} : reR x = x :=\n  rfl\n\n"}
{"name":"RCLike.im_to_real","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"x : Real\n⊢ Eq (RCLike.im x) 0","decl":"@[simp, rclike_simps]\ntheorem im_to_real {x : ℝ} : imR x = 0 :=\n  rfl\n\n"}
{"name":"RCLike.conj_to_real","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"x : Real\n⊢ Eq ((starRingEnd Real) x) x","decl":"@[rclike_simps]\ntheorem conj_to_real {x : ℝ} : conj x = x :=\n  rfl\n\n"}
{"name":"RCLike.I_to_real","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"⊢ Eq RCLike.I 0","decl":"@[simp, rclike_simps]\ntheorem I_to_real : IR = 0 :=\n  rfl\n\n"}
{"name":"RCLike.normSq_to_real","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"x : Real\n⊢ Eq (RCLike.normSq x) (HMul.hMul x x)","decl":"@[simp, rclike_simps]\ntheorem normSq_to_real {x : ℝ} : normSq x = x * x := by simp [RCLike.normSq]\n\n"}
{"name":"RCLike.ofReal_real_eq_id","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"⊢ Eq RCLike.ofReal id","decl":"@[simp]\ntheorem ofReal_real_eq_id : @ofReal ℝ _ = id :=\n  rfl\n\n"}
{"name":"RCLike.reLm_coe","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\n⊢ Eq ⇑RCLike.reLm ⇑RCLike.re","decl":"@[simp, rclike_simps]\ntheorem reLm_coe : (reLm : K → ℝ) = re :=\n  rfl\n\n"}
{"name":"RCLike.reCLM_coe","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\n⊢ Eq (↑RCLike.reCLM) RCLike.reLm","decl":"@[simp, rclike_simps, norm_cast]\ntheorem reCLM_coe : ((reCLM : K →L[ℝ] ℝ) : K →ₗ[ℝ] ℝ) = reLm :=\n  rfl\n\n"}
{"name":"RCLike.reCLM_apply","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\n⊢ Eq ⇑RCLike.reCLM ⇑RCLike.re","decl":"@[simp, rclike_simps]\ntheorem reCLM_apply : ((reCLM : K →L[ℝ] ℝ) : K → ℝ) = re :=\n  rfl\n\n"}
{"name":"RCLike.continuous_re","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\n⊢ Continuous ⇑RCLike.re","decl":"@[continuity, fun_prop]\ntheorem continuous_re : Continuous (re : K → ℝ) :=\n  reCLM.continuous\n\n"}
{"name":"RCLike.imLm_coe","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\n⊢ Eq ⇑RCLike.imLm ⇑RCLike.im","decl":"@[simp, rclike_simps]\ntheorem imLm_coe : (imLm : K → ℝ) = im :=\n  rfl\n\n"}
{"name":"RCLike.imCLM_coe","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\n⊢ Eq (↑RCLike.imCLM) RCLike.imLm","decl":"@[simp, rclike_simps, norm_cast]\ntheorem imCLM_coe : ((imCLM : K →L[ℝ] ℝ) : K →ₗ[ℝ] ℝ) = imLm :=\n  rfl\n\n"}
{"name":"RCLike.imCLM_apply","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\n⊢ Eq ⇑RCLike.imCLM ⇑RCLike.im","decl":"@[simp, rclike_simps]\ntheorem imCLM_apply : ((imCLM : K →L[ℝ] ℝ) : K → ℝ) = im :=\n  rfl\n\n"}
{"name":"RCLike.continuous_im","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\n⊢ Continuous ⇑RCLike.im","decl":"@[continuity, fun_prop]\ntheorem continuous_im : Continuous (im : K → ℝ) :=\n  imCLM.continuous\n\n"}
{"name":"RCLike.conjAe_coe","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\n⊢ Eq ⇑RCLike.conjAe ⇑(starRingEnd K)","decl":"@[simp, rclike_simps]\ntheorem conjAe_coe : (conjAe : K → K) = conj :=\n  rfl\n\n"}
{"name":"RCLike.conjLIE_apply","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\n⊢ Eq ⇑RCLike.conjLIE ⇑(starRingEnd K)","decl":"@[simp, rclike_simps]\ntheorem conjLIE_apply : (conjLIE : K → K) = conj :=\n  rfl\n\n"}
{"name":"RCLike.conjCLE_coe","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\n⊢ Eq RCLike.conjCLE.toLinearEquiv RCLike.conjAe.toLinearEquiv","decl":"@[simp, rclike_simps]\ntheorem conjCLE_coe : (@conjCLE K _).toLinearEquiv = conjAe.toLinearEquiv :=\n  rfl\n\n"}
{"name":"RCLike.conjCLE_apply","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\n⊢ Eq ⇑RCLike.conjCLE ⇑(starRingEnd K)","decl":"@[simp, rclike_simps]\ntheorem conjCLE_apply : (conjCLE : K → K) = conj :=\n  rfl\n\n"}
{"name":"RCLike.instContinuousStar","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\n⊢ ContinuousStar K","decl":"instance (priority := 100) : ContinuousStar K :=\n  ⟨conjLIE.continuous⟩\n\n"}
{"name":"RCLike.continuous_conj","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\n⊢ Continuous ⇑(starRingEnd K)","decl":"@[continuity]\ntheorem continuous_conj : Continuous (conj : K → K) :=\n  continuous_star\n\n"}
{"name":"RCLike.ofRealAm_coe","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\n⊢ Eq (⇑RCLike.ofRealAm) RCLike.ofReal","decl":"@[simp, rclike_simps]\ntheorem ofRealAm_coe : (ofRealAm : ℝ → K) = ofReal :=\n  rfl\n\n"}
{"name":"RCLike.ofRealLI_apply","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\n⊢ Eq (⇑RCLike.ofRealLI) RCLike.ofReal","decl":"@[simp, rclike_simps]\ntheorem ofRealLI_apply : (ofRealLI : ℝ → K) = ofReal :=\n  rfl\n\n"}
{"name":"RCLike.ofRealCLM_coe","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\n⊢ Eq (↑RCLike.ofRealCLM) RCLike.ofRealAm.toLinearMap","decl":"@[simp, rclike_simps]\ntheorem ofRealCLM_coe : (@ofRealCLM K _ : ℝ →ₗ[ℝ] K) = ofRealAm.toLinearMap :=\n  rfl\n\n"}
{"name":"RCLike.ofRealCLM_apply","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\n⊢ Eq (⇑RCLike.ofRealCLM) RCLike.ofReal","decl":"@[simp, rclike_simps]\ntheorem ofRealCLM_apply : (ofRealCLM : ℝ → K) = ofReal :=\n  rfl\n\n"}
{"name":"RCLike.continuous_ofReal","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\n⊢ Continuous RCLike.ofReal","decl":"@[continuity, fun_prop]\ntheorem continuous_ofReal : Continuous (ofReal : ℝ → K) :=\n  ofRealLI.continuous\n\n"}
{"name":"RCLike.continuous_normSq","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\n⊢ Continuous ⇑RCLike.normSq","decl":"@[continuity]\ntheorem continuous_normSq : Continuous (normSq : K → ℝ) :=\n  (continuous_re.mul continuous_re).add (continuous_im.mul continuous_im)\n\n"}
{"name":"RCLike.im_eq_zero","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nh : Eq RCLike.I 0\nz : K\n⊢ Eq (RCLike.im z) 0","decl":"lemma im_eq_zero (h : I = (0 : K)) (z : K) : im z = 0 := by\n  rw [← re_add_im z, h]\n  simp\n\n"}
{"name":"RCLike.realRingEquiv_apply","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nh : Eq RCLike.I 0\na : K\n⊢ Eq ((RCLike.realRingEquiv h) a) (RCLike.re a)","decl":"/-- The natural isomorphism between `𝕜` satisfying `RCLike 𝕜` and `ℝ` when `RCLike.I = 0`. -/\n@[simps]\ndef realRingEquiv (h : I = (0 : K)) : K ≃+* ℝ where\n  toFun := re\n  invFun := (↑)\n  left_inv x := by nth_rw 2 [← re_add_im x]; simp [h]\n  right_inv := ofReal_re\n  map_add' := map_add re\n  map_mul' := by simp [im_eq_zero h]\n\n"}
{"name":"RCLike.realRingEquiv_symm_apply","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nh : Eq RCLike.I 0\na✝ : Real\n⊢ Eq ((RCLike.realRingEquiv h).symm a✝) ↑a✝","decl":"/-- The natural isomorphism between `𝕜` satisfying `RCLike 𝕜` and `ℝ` when `RCLike.I = 0`. -/\n@[simps]\ndef realRingEquiv (h : I = (0 : K)) : K ≃+* ℝ where\n  toFun := re\n  invFun := (↑)\n  left_inv x := by nth_rw 2 [← re_add_im x]; simp [h]\n  right_inv := ofReal_re\n  map_add' := map_add re\n  map_mul' := by simp [im_eq_zero h]\n\n"}
{"name":"RCLike.realLinearIsometryEquiv_apply","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nh : Eq RCLike.I 0\na✝ : K\n⊢ Eq ((RCLike.realLinearIsometryEquiv h) a✝) ((RCLike.realRingEquiv h).toFun a✝)","decl":"/-- The natural `ℝ`-linear isometry equivalence between `𝕜` satisfying `RCLike 𝕜` and `ℝ` when\n`RCLike.I = 0`. -/\n@[simps]\nnoncomputable def realLinearIsometryEquiv (h : I = (0 : K)) : K ≃ₗᵢ[ℝ] ℝ where\n  map_smul' := smul_re\n  norm_map' z := by rw [← re_add_im z]; simp [- re_add_im, h]\n  __ := realRingEquiv h\n\n"}
{"name":"RCLike.realLinearIsometryEquiv_symm_apply","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝ : RCLike K\nh : Eq RCLike.I 0\na✝ : Real\n⊢ Eq ((RCLike.realLinearIsometryEquiv h).symm a✝) ((RCLike.realRingEquiv h).invFun a✝)","decl":"/-- The natural `ℝ`-linear isometry equivalence between `𝕜` satisfying `RCLike 𝕜` and `ℝ` when\n`RCLike.I = 0`. -/\n@[simps]\nnoncomputable def realLinearIsometryEquiv (h : I = (0 : K)) : K ≃ₗᵢ[ℝ] ℝ where\n  map_smul' := smul_re\n  norm_map' z := by rw [← re_add_im z]; simp [- re_add_im, h]\n  __ := realRingEquiv h\n\n"}
{"name":"AddChar.inv_apply_eq_conj","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝² : RCLike K\nG : Type u_3\ninst✝¹ : Finite G\ninst✝ : AddLeftCancelMonoid G\nψ : AddChar G K\nx : G\n⊢ Eq (Inv.inv (ψ x)) ((starRingEnd K) (ψ x))","decl":"lemma inv_apply_eq_conj [AddLeftCancelMonoid G] (ψ : AddChar G K) (x : G) : (ψ x)⁻¹ = conj (ψ x) :=\n  RCLike.inv_eq_conj <| norm_apply _ _\n\n"}
{"name":"AddChar.map_neg_eq_conj","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst✝² : RCLike K\nG : Type u_3\ninst✝¹ : Finite G\ninst✝ : AddCommGroup G\nψ : AddChar G K\nx : G\n⊢ Eq (ψ (Neg.neg x)) ((starRingEnd K) (ψ x))","decl":"lemma map_neg_eq_conj [AddCommGroup G] (ψ : AddChar G K) (x : G) : ψ (-x) = conj (ψ x) := by\n  rw [map_neg_eq_inv, inv_apply_eq_conj]\n\n"}
{"name":"IsRCLikeNormedField.out","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"𝕜 : Type u_3\nhk : NormedField 𝕜\nself : IsRCLikeNormedField 𝕜\n⊢ Exists fun h => Eq hk DenselyNormedField.toNormedField","decl":"/-- A mixin over a normed field, saying that the norm field structure is the same as `ℝ` or `ℂ`.\nTo endow such a field with a compatible `RCLike` structure in a proof, use\n`letI := IsRCLikeNormedField.rclike 𝕜`.-/\nclass IsRCLikeNormedField (𝕜 : Type*) [hk : NormedField 𝕜] : Prop where\n  out : ∃ h : RCLike 𝕜, hk = h.toNormedField\n\n"}
{"name":"instIsRCLikeNormedField","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"𝕜 : Type u_3\nh : RCLike 𝕜\n⊢ IsRCLikeNormedField 𝕜","decl":"instance (priority := 100) (𝕜 : Type*) [h : RCLike 𝕜] : IsRCLikeNormedField 𝕜 := ⟨⟨h, rfl⟩⟩\n\n"}
