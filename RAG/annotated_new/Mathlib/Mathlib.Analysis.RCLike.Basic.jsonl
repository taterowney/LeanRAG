{"name":"RCLike.I_mul_I_ax","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : semiOutParam (Type u_1)\nself : RCLike K\n‚ä¢ Or (Eq RCLike.I 0) (Eq (HMul.hMul RCLike.I RCLike.I) (-1))","decl":"/--\nThis typeclass captures properties shared by ‚Ñù and ‚ÑÇ, with an API that closely matches that of ‚ÑÇ.\n-/\nclass RCLike (K : semiOutParam Type*) extends DenselyNormedField K, StarRing K,\n    NormedAlgebra ‚Ñù K, CompleteSpace K where\n  re : K ‚Üí+ ‚Ñù\n  im : K ‚Üí+ ‚Ñù\n  /-- Imaginary unit in `K`. Meant to be set to `0` for `K = ‚Ñù`. -/\n  I : K\n  I_re_ax : re I = 0\n  I_mul_I_ax : I = 0 ‚à® I * I = -1\n  re_add_im_ax : ‚àÄ z : K, ùìö (re z) + ùìö (im z) * I = z\n  ofReal_re_ax : ‚àÄ r : ‚Ñù, re (ùìö r) = r\n  ofReal_im_ax : ‚àÄ r : ‚Ñù, im (ùìö r) = 0\n  mul_re_ax : ‚àÄ z w : K, re (z * w) = re z * re w - im z * im w\n  mul_im_ax : ‚àÄ z w : K, im (z * w) = re z * im w + im z * re w\n  conj_re_ax : ‚àÄ z : K, re (conj z) = re z\n  conj_im_ax : ‚àÄ z : K, im (conj z) = -im z\n  conj_I_ax : conj I = -I\n  norm_sq_eq_def_ax : ‚àÄ z : K, ‚Äñz‚Äñ ^ 2 = re z * re z + im z * im z\n  mul_im_I_ax : ‚àÄ z : K, im z * im I = im z\n  /-- only an instance in the `ComplexOrder` locale -/\n  [toPartialOrder : PartialOrder K]\n  le_iff_re_im {z w : K} : z ‚â§ w ‚Üî re z ‚â§ re w ‚àß im z = im w\n  -- note we cannot put this in the `extends` clause\n  [toDecidableEq : DecidableEq K]\n\n"}
{"name":"RCLike.toCompleteSpace","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : semiOutParam (Type u_1)\nself : RCLike K\n‚ä¢ CompleteSpace K","decl":"/--\nThis typeclass captures properties shared by ‚Ñù and ‚ÑÇ, with an API that closely matches that of ‚ÑÇ.\n-/\nclass RCLike (K : semiOutParam Type*) extends DenselyNormedField K, StarRing K,\n    NormedAlgebra ‚Ñù K, CompleteSpace K where\n  re : K ‚Üí+ ‚Ñù\n  im : K ‚Üí+ ‚Ñù\n  /-- Imaginary unit in `K`. Meant to be set to `0` for `K = ‚Ñù`. -/\n  I : K\n  I_re_ax : re I = 0\n  I_mul_I_ax : I = 0 ‚à® I * I = -1\n  re_add_im_ax : ‚àÄ z : K, ùìö (re z) + ùìö (im z) * I = z\n  ofReal_re_ax : ‚àÄ r : ‚Ñù, re (ùìö r) = r\n  ofReal_im_ax : ‚àÄ r : ‚Ñù, im (ùìö r) = 0\n  mul_re_ax : ‚àÄ z w : K, re (z * w) = re z * re w - im z * im w\n  mul_im_ax : ‚àÄ z w : K, im (z * w) = re z * im w + im z * re w\n  conj_re_ax : ‚àÄ z : K, re (conj z) = re z\n  conj_im_ax : ‚àÄ z : K, im (conj z) = -im z\n  conj_I_ax : conj I = -I\n  norm_sq_eq_def_ax : ‚àÄ z : K, ‚Äñz‚Äñ ^ 2 = re z * re z + im z * im z\n  mul_im_I_ax : ‚àÄ z : K, im z * im I = im z\n  /-- only an instance in the `ComplexOrder` locale -/\n  [toPartialOrder : PartialOrder K]\n  le_iff_re_im {z w : K} : z ‚â§ w ‚Üî re z ‚â§ re w ‚àß im z = im w\n  -- note we cannot put this in the `extends` clause\n  [toDecidableEq : DecidableEq K]\n\n"}
{"name":"RCLike.ofReal_im_ax","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : semiOutParam (Type u_1)\nself : RCLike K\nr : Real\n‚ä¢ Eq (RCLike.im ((algebraMap Real K) r)) 0","decl":"/--\nThis typeclass captures properties shared by ‚Ñù and ‚ÑÇ, with an API that closely matches that of ‚ÑÇ.\n-/\nclass RCLike (K : semiOutParam Type*) extends DenselyNormedField K, StarRing K,\n    NormedAlgebra ‚Ñù K, CompleteSpace K where\n  re : K ‚Üí+ ‚Ñù\n  im : K ‚Üí+ ‚Ñù\n  /-- Imaginary unit in `K`. Meant to be set to `0` for `K = ‚Ñù`. -/\n  I : K\n  I_re_ax : re I = 0\n  I_mul_I_ax : I = 0 ‚à® I * I = -1\n  re_add_im_ax : ‚àÄ z : K, ùìö (re z) + ùìö (im z) * I = z\n  ofReal_re_ax : ‚àÄ r : ‚Ñù, re (ùìö r) = r\n  ofReal_im_ax : ‚àÄ r : ‚Ñù, im (ùìö r) = 0\n  mul_re_ax : ‚àÄ z w : K, re (z * w) = re z * re w - im z * im w\n  mul_im_ax : ‚àÄ z w : K, im (z * w) = re z * im w + im z * re w\n  conj_re_ax : ‚àÄ z : K, re (conj z) = re z\n  conj_im_ax : ‚àÄ z : K, im (conj z) = -im z\n  conj_I_ax : conj I = -I\n  norm_sq_eq_def_ax : ‚àÄ z : K, ‚Äñz‚Äñ ^ 2 = re z * re z + im z * im z\n  mul_im_I_ax : ‚àÄ z : K, im z * im I = im z\n  /-- only an instance in the `ComplexOrder` locale -/\n  [toPartialOrder : PartialOrder K]\n  le_iff_re_im {z w : K} : z ‚â§ w ‚Üî re z ‚â§ re w ‚àß im z = im w\n  -- note we cannot put this in the `extends` clause\n  [toDecidableEq : DecidableEq K]\n\n"}
{"name":"RCLike.mul_im_ax","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : semiOutParam (Type u_1)\nself : RCLike K\nz w : K\n‚ä¢ Eq (RCLike.im (HMul.hMul z w)) (HAdd.hAdd (HMul.hMul (RCLike.re z) (RCLike.im w)) (HMul.hMul (RCLike.im z) (RCLike.re w)))","decl":"/--\nThis typeclass captures properties shared by ‚Ñù and ‚ÑÇ, with an API that closely matches that of ‚ÑÇ.\n-/\nclass RCLike (K : semiOutParam Type*) extends DenselyNormedField K, StarRing K,\n    NormedAlgebra ‚Ñù K, CompleteSpace K where\n  re : K ‚Üí+ ‚Ñù\n  im : K ‚Üí+ ‚Ñù\n  /-- Imaginary unit in `K`. Meant to be set to `0` for `K = ‚Ñù`. -/\n  I : K\n  I_re_ax : re I = 0\n  I_mul_I_ax : I = 0 ‚à® I * I = -1\n  re_add_im_ax : ‚àÄ z : K, ùìö (re z) + ùìö (im z) * I = z\n  ofReal_re_ax : ‚àÄ r : ‚Ñù, re (ùìö r) = r\n  ofReal_im_ax : ‚àÄ r : ‚Ñù, im (ùìö r) = 0\n  mul_re_ax : ‚àÄ z w : K, re (z * w) = re z * re w - im z * im w\n  mul_im_ax : ‚àÄ z w : K, im (z * w) = re z * im w + im z * re w\n  conj_re_ax : ‚àÄ z : K, re (conj z) = re z\n  conj_im_ax : ‚àÄ z : K, im (conj z) = -im z\n  conj_I_ax : conj I = -I\n  norm_sq_eq_def_ax : ‚àÄ z : K, ‚Äñz‚Äñ ^ 2 = re z * re z + im z * im z\n  mul_im_I_ax : ‚àÄ z : K, im z * im I = im z\n  /-- only an instance in the `ComplexOrder` locale -/\n  [toPartialOrder : PartialOrder K]\n  le_iff_re_im {z w : K} : z ‚â§ w ‚Üî re z ‚â§ re w ‚àß im z = im w\n  -- note we cannot put this in the `extends` clause\n  [toDecidableEq : DecidableEq K]\n\n"}
{"name":"RCLike.conj_im_ax","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : semiOutParam (Type u_1)\nself : RCLike K\nz : K\n‚ä¢ Eq (RCLike.im ((starRingEnd K) z)) (Neg.neg (RCLike.im z))","decl":"/--\nThis typeclass captures properties shared by ‚Ñù and ‚ÑÇ, with an API that closely matches that of ‚ÑÇ.\n-/\nclass RCLike (K : semiOutParam Type*) extends DenselyNormedField K, StarRing K,\n    NormedAlgebra ‚Ñù K, CompleteSpace K where\n  re : K ‚Üí+ ‚Ñù\n  im : K ‚Üí+ ‚Ñù\n  /-- Imaginary unit in `K`. Meant to be set to `0` for `K = ‚Ñù`. -/\n  I : K\n  I_re_ax : re I = 0\n  I_mul_I_ax : I = 0 ‚à® I * I = -1\n  re_add_im_ax : ‚àÄ z : K, ùìö (re z) + ùìö (im z) * I = z\n  ofReal_re_ax : ‚àÄ r : ‚Ñù, re (ùìö r) = r\n  ofReal_im_ax : ‚àÄ r : ‚Ñù, im (ùìö r) = 0\n  mul_re_ax : ‚àÄ z w : K, re (z * w) = re z * re w - im z * im w\n  mul_im_ax : ‚àÄ z w : K, im (z * w) = re z * im w + im z * re w\n  conj_re_ax : ‚àÄ z : K, re (conj z) = re z\n  conj_im_ax : ‚àÄ z : K, im (conj z) = -im z\n  conj_I_ax : conj I = -I\n  norm_sq_eq_def_ax : ‚àÄ z : K, ‚Äñz‚Äñ ^ 2 = re z * re z + im z * im z\n  mul_im_I_ax : ‚àÄ z : K, im z * im I = im z\n  /-- only an instance in the `ComplexOrder` locale -/\n  [toPartialOrder : PartialOrder K]\n  le_iff_re_im {z w : K} : z ‚â§ w ‚Üî re z ‚â§ re w ‚àß im z = im w\n  -- note we cannot put this in the `extends` clause\n  [toDecidableEq : DecidableEq K]\n\n"}
{"name":"RCLike.conj_re_ax","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : semiOutParam (Type u_1)\nself : RCLike K\nz : K\n‚ä¢ Eq (RCLike.re ((starRingEnd K) z)) (RCLike.re z)","decl":"/--\nThis typeclass captures properties shared by ‚Ñù and ‚ÑÇ, with an API that closely matches that of ‚ÑÇ.\n-/\nclass RCLike (K : semiOutParam Type*) extends DenselyNormedField K, StarRing K,\n    NormedAlgebra ‚Ñù K, CompleteSpace K where\n  re : K ‚Üí+ ‚Ñù\n  im : K ‚Üí+ ‚Ñù\n  /-- Imaginary unit in `K`. Meant to be set to `0` for `K = ‚Ñù`. -/\n  I : K\n  I_re_ax : re I = 0\n  I_mul_I_ax : I = 0 ‚à® I * I = -1\n  re_add_im_ax : ‚àÄ z : K, ùìö (re z) + ùìö (im z) * I = z\n  ofReal_re_ax : ‚àÄ r : ‚Ñù, re (ùìö r) = r\n  ofReal_im_ax : ‚àÄ r : ‚Ñù, im (ùìö r) = 0\n  mul_re_ax : ‚àÄ z w : K, re (z * w) = re z * re w - im z * im w\n  mul_im_ax : ‚àÄ z w : K, im (z * w) = re z * im w + im z * re w\n  conj_re_ax : ‚àÄ z : K, re (conj z) = re z\n  conj_im_ax : ‚àÄ z : K, im (conj z) = -im z\n  conj_I_ax : conj I = -I\n  norm_sq_eq_def_ax : ‚àÄ z : K, ‚Äñz‚Äñ ^ 2 = re z * re z + im z * im z\n  mul_im_I_ax : ‚àÄ z : K, im z * im I = im z\n  /-- only an instance in the `ComplexOrder` locale -/\n  [toPartialOrder : PartialOrder K]\n  le_iff_re_im {z w : K} : z ‚â§ w ‚Üî re z ‚â§ re w ‚àß im z = im w\n  -- note we cannot put this in the `extends` clause\n  [toDecidableEq : DecidableEq K]\n\n"}
{"name":"RCLike.ofReal_re_ax","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : semiOutParam (Type u_1)\nself : RCLike K\nr : Real\n‚ä¢ Eq (RCLike.re ((algebraMap Real K) r)) r","decl":"/--\nThis typeclass captures properties shared by ‚Ñù and ‚ÑÇ, with an API that closely matches that of ‚ÑÇ.\n-/\nclass RCLike (K : semiOutParam Type*) extends DenselyNormedField K, StarRing K,\n    NormedAlgebra ‚Ñù K, CompleteSpace K where\n  re : K ‚Üí+ ‚Ñù\n  im : K ‚Üí+ ‚Ñù\n  /-- Imaginary unit in `K`. Meant to be set to `0` for `K = ‚Ñù`. -/\n  I : K\n  I_re_ax : re I = 0\n  I_mul_I_ax : I = 0 ‚à® I * I = -1\n  re_add_im_ax : ‚àÄ z : K, ùìö (re z) + ùìö (im z) * I = z\n  ofReal_re_ax : ‚àÄ r : ‚Ñù, re (ùìö r) = r\n  ofReal_im_ax : ‚àÄ r : ‚Ñù, im (ùìö r) = 0\n  mul_re_ax : ‚àÄ z w : K, re (z * w) = re z * re w - im z * im w\n  mul_im_ax : ‚àÄ z w : K, im (z * w) = re z * im w + im z * re w\n  conj_re_ax : ‚àÄ z : K, re (conj z) = re z\n  conj_im_ax : ‚àÄ z : K, im (conj z) = -im z\n  conj_I_ax : conj I = -I\n  norm_sq_eq_def_ax : ‚àÄ z : K, ‚Äñz‚Äñ ^ 2 = re z * re z + im z * im z\n  mul_im_I_ax : ‚àÄ z : K, im z * im I = im z\n  /-- only an instance in the `ComplexOrder` locale -/\n  [toPartialOrder : PartialOrder K]\n  le_iff_re_im {z w : K} : z ‚â§ w ‚Üî re z ‚â§ re w ‚àß im z = im w\n  -- note we cannot put this in the `extends` clause\n  [toDecidableEq : DecidableEq K]\n\n"}
{"name":"RCLike.I_re_ax","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : semiOutParam (Type u_1)\nself : RCLike K\n‚ä¢ Eq (RCLike.re RCLike.I) 0","decl":"/--\nThis typeclass captures properties shared by ‚Ñù and ‚ÑÇ, with an API that closely matches that of ‚ÑÇ.\n-/\nclass RCLike (K : semiOutParam Type*) extends DenselyNormedField K, StarRing K,\n    NormedAlgebra ‚Ñù K, CompleteSpace K where\n  re : K ‚Üí+ ‚Ñù\n  im : K ‚Üí+ ‚Ñù\n  /-- Imaginary unit in `K`. Meant to be set to `0` for `K = ‚Ñù`. -/\n  I : K\n  I_re_ax : re I = 0\n  I_mul_I_ax : I = 0 ‚à® I * I = -1\n  re_add_im_ax : ‚àÄ z : K, ùìö (re z) + ùìö (im z) * I = z\n  ofReal_re_ax : ‚àÄ r : ‚Ñù, re (ùìö r) = r\n  ofReal_im_ax : ‚àÄ r : ‚Ñù, im (ùìö r) = 0\n  mul_re_ax : ‚àÄ z w : K, re (z * w) = re z * re w - im z * im w\n  mul_im_ax : ‚àÄ z w : K, im (z * w) = re z * im w + im z * re w\n  conj_re_ax : ‚àÄ z : K, re (conj z) = re z\n  conj_im_ax : ‚àÄ z : K, im (conj z) = -im z\n  conj_I_ax : conj I = -I\n  norm_sq_eq_def_ax : ‚àÄ z : K, ‚Äñz‚Äñ ^ 2 = re z * re z + im z * im z\n  mul_im_I_ax : ‚àÄ z : K, im z * im I = im z\n  /-- only an instance in the `ComplexOrder` locale -/\n  [toPartialOrder : PartialOrder K]\n  le_iff_re_im {z w : K} : z ‚â§ w ‚Üî re z ‚â§ re w ‚àß im z = im w\n  -- note we cannot put this in the `extends` clause\n  [toDecidableEq : DecidableEq K]\n\n"}
{"name":"RCLike.norm_sq_eq_def_ax","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : semiOutParam (Type u_1)\nself : RCLike K\nz : K\n‚ä¢ Eq (HPow.hPow (Norm.norm z) 2) (HAdd.hAdd (HMul.hMul (RCLike.re z) (RCLike.re z)) (HMul.hMul (RCLike.im z) (RCLike.im z)))","decl":"/--\nThis typeclass captures properties shared by ‚Ñù and ‚ÑÇ, with an API that closely matches that of ‚ÑÇ.\n-/\nclass RCLike (K : semiOutParam Type*) extends DenselyNormedField K, StarRing K,\n    NormedAlgebra ‚Ñù K, CompleteSpace K where\n  re : K ‚Üí+ ‚Ñù\n  im : K ‚Üí+ ‚Ñù\n  /-- Imaginary unit in `K`. Meant to be set to `0` for `K = ‚Ñù`. -/\n  I : K\n  I_re_ax : re I = 0\n  I_mul_I_ax : I = 0 ‚à® I * I = -1\n  re_add_im_ax : ‚àÄ z : K, ùìö (re z) + ùìö (im z) * I = z\n  ofReal_re_ax : ‚àÄ r : ‚Ñù, re (ùìö r) = r\n  ofReal_im_ax : ‚àÄ r : ‚Ñù, im (ùìö r) = 0\n  mul_re_ax : ‚àÄ z w : K, re (z * w) = re z * re w - im z * im w\n  mul_im_ax : ‚àÄ z w : K, im (z * w) = re z * im w + im z * re w\n  conj_re_ax : ‚àÄ z : K, re (conj z) = re z\n  conj_im_ax : ‚àÄ z : K, im (conj z) = -im z\n  conj_I_ax : conj I = -I\n  norm_sq_eq_def_ax : ‚àÄ z : K, ‚Äñz‚Äñ ^ 2 = re z * re z + im z * im z\n  mul_im_I_ax : ‚àÄ z : K, im z * im I = im z\n  /-- only an instance in the `ComplexOrder` locale -/\n  [toPartialOrder : PartialOrder K]\n  le_iff_re_im {z w : K} : z ‚â§ w ‚Üî re z ‚â§ re w ‚àß im z = im w\n  -- note we cannot put this in the `extends` clause\n  [toDecidableEq : DecidableEq K]\n\n"}
{"name":"RCLike.le_iff_re_im","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : semiOutParam (Type u_1)\nself : RCLike K\nz w : K\n‚ä¢ Iff (LE.le z w) (And (LE.le (RCLike.re z) (RCLike.re w)) (Eq (RCLike.im z) (RCLike.im w)))","decl":"/--\nThis typeclass captures properties shared by ‚Ñù and ‚ÑÇ, with an API that closely matches that of ‚ÑÇ.\n-/\nclass RCLike (K : semiOutParam Type*) extends DenselyNormedField K, StarRing K,\n    NormedAlgebra ‚Ñù K, CompleteSpace K where\n  re : K ‚Üí+ ‚Ñù\n  im : K ‚Üí+ ‚Ñù\n  /-- Imaginary unit in `K`. Meant to be set to `0` for `K = ‚Ñù`. -/\n  I : K\n  I_re_ax : re I = 0\n  I_mul_I_ax : I = 0 ‚à® I * I = -1\n  re_add_im_ax : ‚àÄ z : K, ùìö (re z) + ùìö (im z) * I = z\n  ofReal_re_ax : ‚àÄ r : ‚Ñù, re (ùìö r) = r\n  ofReal_im_ax : ‚àÄ r : ‚Ñù, im (ùìö r) = 0\n  mul_re_ax : ‚àÄ z w : K, re (z * w) = re z * re w - im z * im w\n  mul_im_ax : ‚àÄ z w : K, im (z * w) = re z * im w + im z * re w\n  conj_re_ax : ‚àÄ z : K, re (conj z) = re z\n  conj_im_ax : ‚àÄ z : K, im (conj z) = -im z\n  conj_I_ax : conj I = -I\n  norm_sq_eq_def_ax : ‚àÄ z : K, ‚Äñz‚Äñ ^ 2 = re z * re z + im z * im z\n  mul_im_I_ax : ‚àÄ z : K, im z * im I = im z\n  /-- only an instance in the `ComplexOrder` locale -/\n  [toPartialOrder : PartialOrder K]\n  le_iff_re_im {z w : K} : z ‚â§ w ‚Üî re z ‚â§ re w ‚àß im z = im w\n  -- note we cannot put this in the `extends` clause\n  [toDecidableEq : DecidableEq K]\n\n"}
{"name":"RCLike.mul_im_I_ax","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : semiOutParam (Type u_1)\nself : RCLike K\nz : K\n‚ä¢ Eq (HMul.hMul (RCLike.im z) (RCLike.im RCLike.I)) (RCLike.im z)","decl":"/--\nThis typeclass captures properties shared by ‚Ñù and ‚ÑÇ, with an API that closely matches that of ‚ÑÇ.\n-/\nclass RCLike (K : semiOutParam Type*) extends DenselyNormedField K, StarRing K,\n    NormedAlgebra ‚Ñù K, CompleteSpace K where\n  re : K ‚Üí+ ‚Ñù\n  im : K ‚Üí+ ‚Ñù\n  /-- Imaginary unit in `K`. Meant to be set to `0` for `K = ‚Ñù`. -/\n  I : K\n  I_re_ax : re I = 0\n  I_mul_I_ax : I = 0 ‚à® I * I = -1\n  re_add_im_ax : ‚àÄ z : K, ùìö (re z) + ùìö (im z) * I = z\n  ofReal_re_ax : ‚àÄ r : ‚Ñù, re (ùìö r) = r\n  ofReal_im_ax : ‚àÄ r : ‚Ñù, im (ùìö r) = 0\n  mul_re_ax : ‚àÄ z w : K, re (z * w) = re z * re w - im z * im w\n  mul_im_ax : ‚àÄ z w : K, im (z * w) = re z * im w + im z * re w\n  conj_re_ax : ‚àÄ z : K, re (conj z) = re z\n  conj_im_ax : ‚àÄ z : K, im (conj z) = -im z\n  conj_I_ax : conj I = -I\n  norm_sq_eq_def_ax : ‚àÄ z : K, ‚Äñz‚Äñ ^ 2 = re z * re z + im z * im z\n  mul_im_I_ax : ‚àÄ z : K, im z * im I = im z\n  /-- only an instance in the `ComplexOrder` locale -/\n  [toPartialOrder : PartialOrder K]\n  le_iff_re_im {z w : K} : z ‚â§ w ‚Üî re z ‚â§ re w ‚àß im z = im w\n  -- note we cannot put this in the `extends` clause\n  [toDecidableEq : DecidableEq K]\n\n"}
{"name":"RCLike.mul_re_ax","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : semiOutParam (Type u_1)\nself : RCLike K\nz w : K\n‚ä¢ Eq (RCLike.re (HMul.hMul z w)) (HSub.hSub (HMul.hMul (RCLike.re z) (RCLike.re w)) (HMul.hMul (RCLike.im z) (RCLike.im w)))","decl":"/--\nThis typeclass captures properties shared by ‚Ñù and ‚ÑÇ, with an API that closely matches that of ‚ÑÇ.\n-/\nclass RCLike (K : semiOutParam Type*) extends DenselyNormedField K, StarRing K,\n    NormedAlgebra ‚Ñù K, CompleteSpace K where\n  re : K ‚Üí+ ‚Ñù\n  im : K ‚Üí+ ‚Ñù\n  /-- Imaginary unit in `K`. Meant to be set to `0` for `K = ‚Ñù`. -/\n  I : K\n  I_re_ax : re I = 0\n  I_mul_I_ax : I = 0 ‚à® I * I = -1\n  re_add_im_ax : ‚àÄ z : K, ùìö (re z) + ùìö (im z) * I = z\n  ofReal_re_ax : ‚àÄ r : ‚Ñù, re (ùìö r) = r\n  ofReal_im_ax : ‚àÄ r : ‚Ñù, im (ùìö r) = 0\n  mul_re_ax : ‚àÄ z w : K, re (z * w) = re z * re w - im z * im w\n  mul_im_ax : ‚àÄ z w : K, im (z * w) = re z * im w + im z * re w\n  conj_re_ax : ‚àÄ z : K, re (conj z) = re z\n  conj_im_ax : ‚àÄ z : K, im (conj z) = -im z\n  conj_I_ax : conj I = -I\n  norm_sq_eq_def_ax : ‚àÄ z : K, ‚Äñz‚Äñ ^ 2 = re z * re z + im z * im z\n  mul_im_I_ax : ‚àÄ z : K, im z * im I = im z\n  /-- only an instance in the `ComplexOrder` locale -/\n  [toPartialOrder : PartialOrder K]\n  le_iff_re_im {z w : K} : z ‚â§ w ‚Üî re z ‚â§ re w ‚àß im z = im w\n  -- note we cannot put this in the `extends` clause\n  [toDecidableEq : DecidableEq K]\n\n"}
{"name":"RCLike.re_add_im_ax","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : semiOutParam (Type u_1)\nself : RCLike K\nz : K\n‚ä¢ Eq (HAdd.hAdd ((algebraMap Real K) (RCLike.re z)) (HMul.hMul ((algebraMap Real K) (RCLike.im z)) RCLike.I)) z","decl":"/--\nThis typeclass captures properties shared by ‚Ñù and ‚ÑÇ, with an API that closely matches that of ‚ÑÇ.\n-/\nclass RCLike (K : semiOutParam Type*) extends DenselyNormedField K, StarRing K,\n    NormedAlgebra ‚Ñù K, CompleteSpace K where\n  re : K ‚Üí+ ‚Ñù\n  im : K ‚Üí+ ‚Ñù\n  /-- Imaginary unit in `K`. Meant to be set to `0` for `K = ‚Ñù`. -/\n  I : K\n  I_re_ax : re I = 0\n  I_mul_I_ax : I = 0 ‚à® I * I = -1\n  re_add_im_ax : ‚àÄ z : K, ùìö (re z) + ùìö (im z) * I = z\n  ofReal_re_ax : ‚àÄ r : ‚Ñù, re (ùìö r) = r\n  ofReal_im_ax : ‚àÄ r : ‚Ñù, im (ùìö r) = 0\n  mul_re_ax : ‚àÄ z w : K, re (z * w) = re z * re w - im z * im w\n  mul_im_ax : ‚àÄ z w : K, im (z * w) = re z * im w + im z * re w\n  conj_re_ax : ‚àÄ z : K, re (conj z) = re z\n  conj_im_ax : ‚àÄ z : K, im (conj z) = -im z\n  conj_I_ax : conj I = -I\n  norm_sq_eq_def_ax : ‚àÄ z : K, ‚Äñz‚Äñ ^ 2 = re z * re z + im z * im z\n  mul_im_I_ax : ‚àÄ z : K, im z * im I = im z\n  /-- only an instance in the `ComplexOrder` locale -/\n  [toPartialOrder : PartialOrder K]\n  le_iff_re_im {z w : K} : z ‚â§ w ‚Üî re z ‚â§ re w ‚àß im z = im w\n  -- note we cannot put this in the `extends` clause\n  [toDecidableEq : DecidableEq K]\n\n"}
{"name":"RCLike.conj_I_ax","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : semiOutParam (Type u_1)\nself : RCLike K\n‚ä¢ Eq ((starRingEnd K) RCLike.I) (Neg.neg RCLike.I)","decl":"/--\nThis typeclass captures properties shared by ‚Ñù and ‚ÑÇ, with an API that closely matches that of ‚ÑÇ.\n-/\nclass RCLike (K : semiOutParam Type*) extends DenselyNormedField K, StarRing K,\n    NormedAlgebra ‚Ñù K, CompleteSpace K where\n  re : K ‚Üí+ ‚Ñù\n  im : K ‚Üí+ ‚Ñù\n  /-- Imaginary unit in `K`. Meant to be set to `0` for `K = ‚Ñù`. -/\n  I : K\n  I_re_ax : re I = 0\n  I_mul_I_ax : I = 0 ‚à® I * I = -1\n  re_add_im_ax : ‚àÄ z : K, ùìö (re z) + ùìö (im z) * I = z\n  ofReal_re_ax : ‚àÄ r : ‚Ñù, re (ùìö r) = r\n  ofReal_im_ax : ‚àÄ r : ‚Ñù, im (ùìö r) = 0\n  mul_re_ax : ‚àÄ z w : K, re (z * w) = re z * re w - im z * im w\n  mul_im_ax : ‚àÄ z w : K, im (z * w) = re z * im w + im z * re w\n  conj_re_ax : ‚àÄ z : K, re (conj z) = re z\n  conj_im_ax : ‚àÄ z : K, im (conj z) = -im z\n  conj_I_ax : conj I = -I\n  norm_sq_eq_def_ax : ‚àÄ z : K, ‚Äñz‚Äñ ^ 2 = re z * re z + im z * im z\n  mul_im_I_ax : ‚àÄ z : K, im z * im I = im z\n  /-- only an instance in the `ComplexOrder` locale -/\n  [toPartialOrder : PartialOrder K]\n  le_iff_re_im {z w : K} : z ‚â§ w ‚Üî re z ‚â§ re w ‚àß im z = im w\n  -- note we cannot put this in the `extends` clause\n  [toDecidableEq : DecidableEq K]\n\n"}
{"name":"RCLike.ofReal_alg","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nx : Real\n‚ä¢ Eq (‚Üëx) (HSMul.hSMul x 1)","decl":"theorem ofReal_alg (x : ‚Ñù) : (x : K) = x ‚Ä¢ (1 : K) :=\n  Algebra.algebraMap_eq_smul_one x\n\n"}
{"name":"RCLike.real_smul_eq_coe_mul","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nr : Real\nz : K\n‚ä¢ Eq (HSMul.hSMul r z) (HMul.hMul (‚Üër) z)","decl":"theorem real_smul_eq_coe_mul (r : ‚Ñù) (z : K) : r ‚Ä¢ z = (r : K) * z :=\n  Algebra.smul_def r z\n\n"}
{"name":"RCLike.real_smul_eq_coe_smul","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\nE : Type u_2\ninst‚úù‚Å¥ : RCLike K\ninst‚úù¬≥ : AddCommGroup E\ninst‚úù¬≤ : Module K E\ninst‚úù¬π : Module Real E\ninst‚úù : IsScalarTower Real K E\nr : Real\nx : E\n‚ä¢ Eq (HSMul.hSMul r x) (HSMul.hSMul (‚Üër) x)","decl":"theorem real_smul_eq_coe_smul [AddCommGroup E] [Module K E] [Module ‚Ñù E] [IsScalarTower ‚Ñù K E]\n    (r : ‚Ñù) (x : E) : r ‚Ä¢ x = (r : K) ‚Ä¢ x := by rw [RCLike.ofReal_alg, smul_one_smul]\n\n"}
{"name":"RCLike.algebraMap_eq_ofReal","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\n‚ä¢ Eq (‚áë(algebraMap Real K)) RCLike.ofReal","decl":"theorem algebraMap_eq_ofReal : ‚áë(algebraMap ‚Ñù K) = ofReal :=\n  rfl\n\n"}
{"name":"RCLike.re_add_im","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz : K\n‚ä¢ Eq (HAdd.hAdd (‚Üë(RCLike.re z)) (HMul.hMul (‚Üë(RCLike.im z)) RCLike.I)) z","decl":"@[simp, rclike_simps]\ntheorem re_add_im (z : K) : (re z : K) + im z * I = z :=\n  RCLike.re_add_im_ax z\n\n"}
{"name":"RCLike.ofReal_re","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nr : Real\n‚ä¢ Eq (RCLike.re ‚Üër) r","decl":"@[simp, norm_cast, rclike_simps]\ntheorem ofReal_re : ‚àÄ r : ‚Ñù, re (r : K) = r :=\n  RCLike.ofReal_re_ax\n\n"}
{"name":"RCLike.ofReal_im","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nr : Real\n‚ä¢ Eq (RCLike.im ‚Üër) 0","decl":"@[simp, norm_cast, rclike_simps]\ntheorem ofReal_im : ‚àÄ r : ‚Ñù, im (r : K) = 0 :=\n  RCLike.ofReal_im_ax\n\n"}
{"name":"RCLike.mul_re","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz w : K\n‚ä¢ Eq (RCLike.re (HMul.hMul z w)) (HSub.hSub (HMul.hMul (RCLike.re z) (RCLike.re w)) (HMul.hMul (RCLike.im z) (RCLike.im w)))","decl":"@[simp, rclike_simps]\ntheorem mul_re : ‚àÄ z w : K, re (z * w) = re z * re w - im z * im w :=\n  RCLike.mul_re_ax\n\n"}
{"name":"RCLike.mul_im","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz w : K\n‚ä¢ Eq (RCLike.im (HMul.hMul z w)) (HAdd.hAdd (HMul.hMul (RCLike.re z) (RCLike.im w)) (HMul.hMul (RCLike.im z) (RCLike.re w)))","decl":"@[simp, rclike_simps]\ntheorem mul_im : ‚àÄ z w : K, im (z * w) = re z * im w + im z * re w :=\n  RCLike.mul_im_ax\n\n"}
{"name":"RCLike.ext_iff","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz w : K\n‚ä¢ Iff (Eq z w) (And (Eq (RCLike.re z) (RCLike.re w)) (Eq (RCLike.im z) (RCLike.im w)))","decl":"theorem ext_iff {z w : K} : z = w ‚Üî re z = re w ‚àß im z = im w :=\n  ‚ü®fun h => h ‚ñ∏ ‚ü®rfl, rfl‚ü©, fun ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© => re_add_im z ‚ñ∏ re_add_im w ‚ñ∏ h‚ÇÅ ‚ñ∏ h‚ÇÇ ‚ñ∏ rfl‚ü©\n\n"}
{"name":"RCLike.ext","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz w : K\nhre : Eq (RCLike.re z) (RCLike.re w)\nhim : Eq (RCLike.im z) (RCLike.im w)\n‚ä¢ Eq z w","decl":"theorem ext {z w : K} (hre : re z = re w) (him : im z = im w) : z = w :=\n  ext_iff.2 ‚ü®hre, him‚ü©\n\n"}
{"name":"RCLike.ofReal_zero","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\n‚ä¢ Eq (‚Üë0) 0","decl":"@[norm_cast]\ntheorem ofReal_zero : ((0 : ‚Ñù) : K) = 0 :=\n  algebraMap.coe_zero\n\n"}
{"name":"RCLike.zero_re'","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\n‚ä¢ Eq (RCLike.re 0) 0","decl":"@[rclike_simps]\ntheorem zero_re' : re (0 : K) = (0 : ‚Ñù) :=\n  map_zero re\n\n"}
{"name":"RCLike.ofReal_one","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\n‚ä¢ Eq (‚Üë1) 1","decl":"@[norm_cast]\ntheorem ofReal_one : ((1 : ‚Ñù) : K) = 1 :=\n  map_one (algebraMap ‚Ñù K)\n\n"}
{"name":"RCLike.one_re","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\n‚ä¢ Eq (RCLike.re 1) 1","decl":"@[simp, rclike_simps]\ntheorem one_re : re (1 : K) = 1 := by rw [‚Üê ofReal_one, ofReal_re]\n\n"}
{"name":"RCLike.one_im","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\n‚ä¢ Eq (RCLike.im 1) 0","decl":"@[simp, rclike_simps]\ntheorem one_im : im (1 : K) = 0 := by rw [‚Üê ofReal_one, ofReal_im]\n\n"}
{"name":"RCLike.ofReal_injective","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\n‚ä¢ Function.Injective RCLike.ofReal","decl":"theorem ofReal_injective : Function.Injective ((‚Üë) : ‚Ñù ‚Üí K) :=\n  (algebraMap ‚Ñù K).injective\n\n"}
{"name":"RCLike.ofReal_inj","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz w : Real\n‚ä¢ Iff (Eq ‚Üëz ‚Üëw) (Eq z w)","decl":"@[norm_cast]\ntheorem ofReal_inj {z w : ‚Ñù} : (z : K) = (w : K) ‚Üî z = w :=\n  algebraMap.coe_inj\n\n-- replaced by `RCLike.ofNat_re`\n-- replaced by `RCLike.ofNat_im`\n\n"}
{"name":"RCLike.ofReal_eq_zero","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nx : Real\n‚ä¢ Iff (Eq (‚Üëx) 0) (Eq x 0)","decl":"theorem ofReal_eq_zero {x : ‚Ñù} : (x : K) = 0 ‚Üî x = 0 :=\n  algebraMap.lift_map_eq_zero_iff x\n\n"}
{"name":"RCLike.ofReal_ne_zero","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nx : Real\n‚ä¢ Iff (Ne (‚Üëx) 0) (Ne x 0)","decl":"theorem ofReal_ne_zero {x : ‚Ñù} : (x : K) ‚â† 0 ‚Üî x ‚â† 0 :=\n  ofReal_eq_zero.not\n\n"}
{"name":"RCLike.ofReal_add","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nr s : Real\n‚ä¢ Eq (‚Üë(HAdd.hAdd r s)) (HAdd.hAdd ‚Üër ‚Üës)","decl":"@[rclike_simps, norm_cast]\ntheorem ofReal_add (r s : ‚Ñù) : ((r + s : ‚Ñù) : K) = r + s :=\n  algebraMap.coe_add _ _\n\n-- replaced by `RCLike.ofReal_ofNat`\n\n"}
{"name":"RCLike.ofReal_neg","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nr : Real\n‚ä¢ Eq (‚Üë(Neg.neg r)) (Neg.neg ‚Üër)","decl":"@[rclike_simps, norm_cast]\ntheorem ofReal_neg (r : ‚Ñù) : ((-r : ‚Ñù) : K) = -r :=\n  algebraMap.coe_neg r\n\n"}
{"name":"RCLike.ofReal_sub","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nr s : Real\n‚ä¢ Eq (‚Üë(HSub.hSub r s)) (HSub.hSub ‚Üër ‚Üës)","decl":"@[rclike_simps, norm_cast]\ntheorem ofReal_sub (r s : ‚Ñù) : ((r - s : ‚Ñù) : K) = r - s :=\n  map_sub (algebraMap ‚Ñù K) r s\n\n"}
{"name":"RCLike.ofReal_sum","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nŒ± : Type u_3\ns : Finset Œ±\nf : Œ± ‚Üí Real\n‚ä¢ Eq (‚Üë(s.sum fun i => f i)) (s.sum fun i => ‚Üë(f i))","decl":"@[rclike_simps, norm_cast]\ntheorem ofReal_sum {Œ± : Type*} (s : Finset Œ±) (f : Œ± ‚Üí ‚Ñù) :\n    ((‚àë i ‚àà s, f i : ‚Ñù) : K) = ‚àë i ‚àà s, (f i : K) :=\n  map_sum (algebraMap ‚Ñù K) _ _\n\n"}
{"name":"RCLike.ofReal_finsupp_sum","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : RCLike K\nŒ± : Type u_3\nM : Type u_4\ninst‚úù : Zero M\nf : Finsupp Œ± M\ng : Œ± ‚Üí M ‚Üí Real\n‚ä¢ Eq (‚Üë(f.sum fun a b => g a b)) (f.sum fun a b => ‚Üë(g a b))","decl":"@[simp, rclike_simps, norm_cast]\ntheorem ofReal_finsupp_sum {Œ± M : Type*} [Zero M] (f : Œ± ‚Üí‚ÇÄ M) (g : Œ± ‚Üí M ‚Üí ‚Ñù) :\n    ((f.sum fun a b => g a b : ‚Ñù) : K) = f.sum fun a b => (g a b : K) :=\n  map_finsupp_sum (algebraMap ‚Ñù K) f g\n\n"}
{"name":"RCLike.ofReal_mul","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nr s : Real\n‚ä¢ Eq (‚Üë(HMul.hMul r s)) (HMul.hMul ‚Üër ‚Üës)","decl":"@[rclike_simps, norm_cast]\ntheorem ofReal_mul (r s : ‚Ñù) : ((r * s : ‚Ñù) : K) = r * s :=\n  algebraMap.coe_mul _ _\n\n"}
{"name":"RCLike.ofReal_pow","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nr : Real\nn : Nat\n‚ä¢ Eq (‚Üë(HPow.hPow r n)) (HPow.hPow (‚Üër) n)","decl":"@[rclike_simps, norm_cast]\ntheorem ofReal_pow (r : ‚Ñù) (n : ‚Ñï) : ((r ^ n : ‚Ñù) : K) = (r : K) ^ n :=\n  map_pow (algebraMap ‚Ñù K) r n\n\n"}
{"name":"RCLike.ofReal_prod","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nŒ± : Type u_3\ns : Finset Œ±\nf : Œ± ‚Üí Real\n‚ä¢ Eq (‚Üë(s.prod fun i => f i)) (s.prod fun i => ‚Üë(f i))","decl":"@[rclike_simps, norm_cast]\ntheorem ofReal_prod {Œ± : Type*} (s : Finset Œ±) (f : Œ± ‚Üí ‚Ñù) :\n    ((‚àè i ‚àà s, f i : ‚Ñù) : K) = ‚àè i ‚àà s, (f i : K) :=\n  map_prod (algebraMap ‚Ñù K) _ _\n\n"}
{"name":"RCLike.ofReal_finsupp_prod","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : RCLike K\nŒ± : Type u_3\nM : Type u_4\ninst‚úù : Zero M\nf : Finsupp Œ± M\ng : Œ± ‚Üí M ‚Üí Real\n‚ä¢ Eq (‚Üë(f.prod fun a b => g a b)) (f.prod fun a b => ‚Üë(g a b))","decl":"@[simp, rclike_simps, norm_cast]\ntheorem ofReal_finsupp_prod {Œ± M : Type*} [Zero M] (f : Œ± ‚Üí‚ÇÄ M) (g : Œ± ‚Üí M ‚Üí ‚Ñù) :\n    ((f.prod fun a b => g a b : ‚Ñù) : K) = f.prod fun a b => (g a b : K) :=\n  map_finsupp_prod _ f g\n\n"}
{"name":"RCLike.real_smul_ofReal","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nr x : Real\n‚ä¢ Eq (HSMul.hSMul r ‚Üëx) (HMul.hMul ‚Üër ‚Üëx)","decl":"@[simp, norm_cast, rclike_simps]\ntheorem real_smul_ofReal (r x : ‚Ñù) : r ‚Ä¢ (x : K) = (r : K) * (x : K) :=\n  real_smul_eq_coe_mul _ _\n\n"}
{"name":"RCLike.re_ofReal_mul","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nr : Real\nz : K\n‚ä¢ Eq (RCLike.re (HMul.hMul (‚Üër) z)) (HMul.hMul r (RCLike.re z))","decl":"@[rclike_simps]\ntheorem re_ofReal_mul (r : ‚Ñù) (z : K) : re (‚Üër * z) = r * re z := by\n  simp only [mul_re, ofReal_im, zero_mul, ofReal_re, sub_zero]\n\n"}
{"name":"RCLike.im_ofReal_mul","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nr : Real\nz : K\n‚ä¢ Eq (RCLike.im (HMul.hMul (‚Üër) z)) (HMul.hMul r (RCLike.im z))","decl":"@[rclike_simps]\ntheorem im_ofReal_mul (r : ‚Ñù) (z : K) : im (‚Üër * z) = r * im z := by\n  simp only [add_zero, ofReal_im, zero_mul, ofReal_re, mul_im]\n\n"}
{"name":"RCLike.smul_re","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nr : Real\nz : K\n‚ä¢ Eq (RCLike.re (HSMul.hSMul r z)) (HMul.hMul r (RCLike.re z))","decl":"@[rclike_simps]\ntheorem smul_re (r : ‚Ñù) (z : K) : re (r ‚Ä¢ z) = r * re z := by\n  rw [real_smul_eq_coe_mul, re_ofReal_mul]\n\n"}
{"name":"RCLike.smul_im","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nr : Real\nz : K\n‚ä¢ Eq (RCLike.im (HSMul.hSMul r z)) (HMul.hMul r (RCLike.im z))","decl":"@[rclike_simps]\ntheorem smul_im (r : ‚Ñù) (z : K) : im (r ‚Ä¢ z) = r * im z := by\n  rw [real_smul_eq_coe_mul, im_ofReal_mul]\n\n"}
{"name":"RCLike.norm_ofReal","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nr : Real\n‚ä¢ Eq (Norm.norm ‚Üër) (abs r)","decl":"@[rclike_simps, norm_cast]\ntheorem norm_ofReal (r : ‚Ñù) : ‚Äñ(r : K)‚Äñ = |r| :=\n  norm_algebraMap' K r\n\n"}
{"name":"RCLike.charZero_rclike","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\n‚ä¢ CharZero K","decl":"/-- ‚Ñù and ‚ÑÇ are both of characteristic zero. -/\ninstance (priority := 100) charZero_rclike : CharZero K :=\n  (RingHom.charZero_iff (algebraMap ‚Ñù K).injective).1 inferInstance\n\n"}
{"name":"RCLike.ofReal_expect","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nŒ± : Type u_3\ns : Finset Œ±\nf : Œ± ‚Üí Real\n‚ä¢ Eq (‚Üë(s.expect fun i => f i)) (s.expect fun i => ‚Üë(f i))","decl":"@[rclike_simps, norm_cast]\nlemma ofReal_expect {Œ± : Type*} (s : Finset Œ±) (f : Œ± ‚Üí ‚Ñù) : ùîº i ‚àà s, f i = ùîº i ‚àà s, (f i : K) :=\n  map_expect (algebraMap ..) ..\n\n"}
{"name":"RCLike.ofReal_balance","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : RCLike K\nŒπ : Type u_3\ninst‚úù : Fintype Œπ\nf : Œπ ‚Üí Real\ni : Œπ\n‚ä¢ Eq (‚Üë(Fintype.balance f i)) (Fintype.balance (Function.comp RCLike.ofReal f) i)","decl":"@[norm_cast]\nlemma ofReal_balance {Œπ : Type*} [Fintype Œπ] (f : Œπ ‚Üí ‚Ñù) (i : Œπ) :\n    ((balance f i : ‚Ñù) : K) = balance ((‚Üë) ‚àò f) i := map_balance (algebraMap ..) ..\n\n"}
{"name":"RCLike.ofReal_comp_balance","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : RCLike K\nŒπ : Type u_3\ninst‚úù : Fintype Œπ\nf : Œπ ‚Üí Real\n‚ä¢ Eq (Function.comp RCLike.ofReal (Fintype.balance f)) (Fintype.balance (Function.comp RCLike.ofReal f))","decl":"@[simp] lemma ofReal_comp_balance {Œπ : Type*} [Fintype Œπ] (f : Œπ ‚Üí ‚Ñù) :\n    ofReal ‚àò balance f = balance (ofReal ‚àò f : Œπ ‚Üí K) := funext <| ofReal_balance _\n\n"}
{"name":"RCLike.I_re","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\n‚ä¢ Eq (RCLike.re RCLike.I) 0","decl":"/-- The imaginary unit. -/\n@[simp, rclike_simps]\ntheorem I_re : re (I : K) = 0 :=\n  I_re_ax\n\n"}
{"name":"RCLike.I_im","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz : K\n‚ä¢ Eq (HMul.hMul (RCLike.im z) (RCLike.im RCLike.I)) (RCLike.im z)","decl":"@[simp, rclike_simps]\ntheorem I_im (z : K) : im z * im (I : K) = im z :=\n  mul_im_I_ax z\n\n"}
{"name":"RCLike.I_im'","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz : K\n‚ä¢ Eq (HMul.hMul (RCLike.im RCLike.I) (RCLike.im z)) (RCLike.im z)","decl":"@[simp, rclike_simps]\ntheorem I_im' (z : K) : im (I : K) * im z = im z := by rw [mul_comm, I_im]\n\n"}
{"name":"RCLike.I_mul_re","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz : K\n‚ä¢ Eq (RCLike.re (HMul.hMul RCLike.I z)) (Neg.neg (RCLike.im z))","decl":"@[rclike_simps] -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11119): was `simp`\ntheorem I_mul_re (z : K) : re (I * z) = -im z := by\n  simp only [I_re, zero_sub, I_im', zero_mul, mul_re]\n\n"}
{"name":"RCLike.I_mul_I","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\n‚ä¢ Or (Eq RCLike.I 0) (Eq (HMul.hMul RCLike.I RCLike.I) (-1))","decl":"theorem I_mul_I : (I : K) = 0 ‚à® (I : K) * I = -1 :=\n  I_mul_I_ax\n\n"}
{"name":"RCLike.I_eq_zero_or_im_I_eq_one","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\n‚ä¢ Or (Eq RCLike.I 0) (Eq (RCLike.im RCLike.I) 1)","decl":"variable (ùïú) in\nlemma I_eq_zero_or_im_I_eq_one : (I : K) = 0 ‚à® im (I : K) = 1 :=\n  I_mul_I (K := K) |>.imp_right fun h ‚Ü¶ by simpa [h] using (I_mul_re (I : K)).symm\n\n"}
{"name":"RCLike.conj_re","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz : K\n‚ä¢ Eq (RCLike.re ((starRingEnd K) z)) (RCLike.re z)","decl":"@[simp, rclike_simps]\ntheorem conj_re (z : K) : re (conj z) = re z :=\n  RCLike.conj_re_ax z\n\n"}
{"name":"RCLike.conj_im","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz : K\n‚ä¢ Eq (RCLike.im ((starRingEnd K) z)) (Neg.neg (RCLike.im z))","decl":"@[simp, rclike_simps]\ntheorem conj_im (z : K) : im (conj z) = -im z :=\n  RCLike.conj_im_ax z\n\n"}
{"name":"RCLike.conj_I","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\n‚ä¢ Eq ((starRingEnd K) RCLike.I) (Neg.neg RCLike.I)","decl":"@[simp, rclike_simps]\ntheorem conj_I : conj (I : K) = -I :=\n  RCLike.conj_I_ax\n\n"}
{"name":"RCLike.conj_ofReal","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nr : Real\n‚ä¢ Eq ((starRingEnd K) ‚Üër) ‚Üër","decl":"@[simp, rclike_simps]\ntheorem conj_ofReal (r : ‚Ñù) : conj (r : K) = (r : K) := by\n  rw [ext_iff]\n  simp only [ofReal_im, conj_im, eq_self_iff_true, conj_re, and_self_iff, neg_zero]\n\n-- replaced by `RCLike.conj_ofNat`\n\n"}
{"name":"RCLike.conj_nat_cast","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nn : Nat\n‚ä¢ Eq ((starRingEnd K) ‚Üën) ‚Üën","decl":"theorem conj_nat_cast (n : ‚Ñï) : conj (n : K) = n := map_natCast _ _\n\n"}
{"name":"RCLike.conj_ofNat","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : RCLike K\nn : Nat\ninst‚úù : n.AtLeastTwo\n‚ä¢ Eq ((starRingEnd K) (OfNat.ofNat n)) (OfNat.ofNat n)","decl":"theorem conj_ofNat (n : ‚Ñï) [n.AtLeastTwo] : conj (ofNat(n) : K) = ofNat(n) :=\n  map_ofNat _ _\n\n"}
{"name":"RCLike.conj_neg_I","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\n‚ä¢ Eq ((starRingEnd K) (Neg.neg RCLike.I)) RCLike.I","decl":"@[rclike_simps, simp]\ntheorem conj_neg_I : conj (-I) = (I : K) := by rw [map_neg, conj_I, neg_neg]\n\n"}
{"name":"RCLike.conj_eq_re_sub_im","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz : K\n‚ä¢ Eq ((starRingEnd K) z) (HSub.hSub (‚Üë(RCLike.re z)) (HMul.hMul (‚Üë(RCLike.im z)) RCLike.I))","decl":"theorem conj_eq_re_sub_im (z : K) : conj z = re z - im z * I :=\n  (congr_arg conj (re_add_im z).symm).trans <| by\n    rw [map_add, map_mul, conj_I, conj_ofReal, conj_ofReal, mul_neg, sub_eq_add_neg]\n\n"}
{"name":"RCLike.sub_conj","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz : K\n‚ä¢ Eq (HSub.hSub z ((starRingEnd K) z)) (HMul.hMul (HMul.hMul 2 ‚Üë(RCLike.im z)) RCLike.I)","decl":"theorem sub_conj (z : K) : z - conj z = 2 * im z * I :=\n  calc\n    z - conj z = re z + im z * I - (re z - im z * I) := by rw [re_add_im, ‚Üê conj_eq_re_sub_im]\n    _ = 2 * im z * I := by rw [add_sub_sub_cancel, ‚Üê two_mul, mul_assoc]\n\n"}
{"name":"RCLike.conj_smul","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nr : Real\nz : K\n‚ä¢ Eq ((starRingEnd K) (HSMul.hSMul r z)) (HSMul.hSMul r ((starRingEnd K) z))","decl":"@[rclike_simps]\ntheorem conj_smul (r : ‚Ñù) (z : K) : conj (r ‚Ä¢ z) = r ‚Ä¢ conj z := by\n  rw [conj_eq_re_sub_im, conj_eq_re_sub_im, smul_re, smul_im, ofReal_mul, ofReal_mul,\n    real_smul_eq_coe_mul r (_ - _), mul_sub, mul_assoc]\n\n"}
{"name":"RCLike.add_conj","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz : K\n‚ä¢ Eq (HAdd.hAdd z ((starRingEnd K) z)) (HMul.hMul 2 ‚Üë(RCLike.re z))","decl":"theorem add_conj (z : K) : z + conj z = 2 * re z :=\n  calc\n    z + conj z = re z + im z * I + (re z - im z * I) := by rw [re_add_im, conj_eq_re_sub_im]\n    _ = 2 * re z := by rw [add_add_sub_cancel, two_mul]\n\n"}
{"name":"RCLike.re_eq_add_conj","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz : K\n‚ä¢ Eq (‚Üë(RCLike.re z)) (HDiv.hDiv (HAdd.hAdd z ((starRingEnd K) z)) 2)","decl":"theorem re_eq_add_conj (z : K) : ‚Üë(re z) = (z + conj z) / 2 := by\n  rw [add_conj, mul_div_cancel_left‚ÇÄ (re z : K) two_ne_zero]\n\n"}
{"name":"RCLike.im_eq_conj_sub","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz : K\n‚ä¢ Eq (‚Üë(RCLike.im z)) (HDiv.hDiv (HMul.hMul RCLike.I (HSub.hSub ((starRingEnd K) z) z)) 2)","decl":"theorem im_eq_conj_sub (z : K) : ‚Üë(im z) = I * (conj z - z) / 2 := by\n  rw [‚Üê neg_inj, ‚Üê ofReal_neg, ‚Üê I_mul_re, re_eq_add_conj, map_mul, conj_I, ‚Üê neg_div, ‚Üê mul_neg,\n    neg_sub, mul_sub, neg_mul, sub_eq_add_neg]\n\n"}
{"name":"RCLike.is_real_TFAE","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz : K\n‚ä¢ (List.cons (Eq ((starRingEnd K) z) z) (List.cons (Exists fun r => Eq (‚Üër) z) (List.cons (Eq (‚Üë(RCLike.re z)) z) (List.cons (Eq (RCLike.im z) 0) List.nil)))).TFAE","decl":"open List in\n/-- There are several equivalent ways to say that a number `z` is in fact a real number. -/\ntheorem is_real_TFAE (z : K) : TFAE [conj z = z, ‚àÉ r : ‚Ñù, (r : K) = z, ‚Üë(re z) = z, im z = 0] := by\n  tfae_have 1 ‚Üí 4\n  | h => by\n    rw [‚Üê @ofReal_inj K, im_eq_conj_sub, h, sub_self, mul_zero, zero_div,\n      ofReal_zero]\n  tfae_have 4 ‚Üí 3\n  | h => by\n    conv_rhs => rw [‚Üê re_add_im z, h, ofReal_zero, zero_mul, add_zero]\n  tfae_have 3 ‚Üí 2 := fun h => ‚ü®_, h‚ü©\n  tfae_have 2 ‚Üí 1 := fun ‚ü®r, hr‚ü© => hr ‚ñ∏ conj_ofReal _\n  tfae_finish\n\n"}
{"name":"RCLike.conj_eq_iff_real","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz : K\n‚ä¢ Iff (Eq ((starRingEnd K) z) z) (Exists fun r => Eq z ‚Üër)","decl":"theorem conj_eq_iff_real {z : K} : conj z = z ‚Üî ‚àÉ r : ‚Ñù, z = (r : K) :=\n  calc\n    _ ‚Üî ‚àÉ r : ‚Ñù, (r : K) = z := (is_real_TFAE z).out 0 1\n    _ ‚Üî _                    := by simp only [eq_comm]\n\n"}
{"name":"RCLike.conj_eq_iff_re","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz : K\n‚ä¢ Iff (Eq ((starRingEnd K) z) z) (Eq (‚Üë(RCLike.re z)) z)","decl":"theorem conj_eq_iff_re {z : K} : conj z = z ‚Üî (re z : K) = z :=\n  (is_real_TFAE z).out 0 2\n\n"}
{"name":"RCLike.conj_eq_iff_im","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz : K\n‚ä¢ Iff (Eq ((starRingEnd K) z) z) (Eq (RCLike.im z) 0)","decl":"theorem conj_eq_iff_im {z : K} : conj z = z ‚Üî im z = 0 :=\n  (is_real_TFAE z).out 0 3\n\n"}
{"name":"RCLike.star_def","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\n‚ä¢ Eq Star.star ‚áë(starRingEnd K)","decl":"@[simp]\ntheorem star_def : (Star.star : K ‚Üí K) = conj :=\n  rfl\n\n"}
{"name":"RCLike.normSq_apply","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz : K\n‚ä¢ Eq (RCLike.normSq z) (HAdd.hAdd (HMul.hMul (RCLike.re z) (RCLike.re z)) (HMul.hMul (RCLike.im z) (RCLike.im z)))","decl":"theorem normSq_apply (z : K) : normSq z = re z * re z + im z * im z :=\n  rfl\n\n"}
{"name":"RCLike.norm_sq_eq_def","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz : K\n‚ä¢ Eq (HPow.hPow (Norm.norm z) 2) (HAdd.hAdd (HMul.hMul (RCLike.re z) (RCLike.re z)) (HMul.hMul (RCLike.im z) (RCLike.im z)))","decl":"theorem norm_sq_eq_def {z : K} : ‚Äñz‚Äñ ^ 2 = re z * re z + im z * im z :=\n  norm_sq_eq_def_ax z\n\n"}
{"name":"RCLike.normSq_eq_def'","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz : K\n‚ä¢ Eq (RCLike.normSq z) (HPow.hPow (Norm.norm z) 2)","decl":"theorem normSq_eq_def' (z : K) : normSq z = ‚Äñz‚Äñ ^ 2 :=\n  norm_sq_eq_def.symm\n\n"}
{"name":"RCLike.normSq_zero","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\n‚ä¢ Eq (RCLike.normSq 0) 0","decl":"@[rclike_simps]\ntheorem normSq_zero : normSq (0 : K) = 0 :=\n  normSq.map_zero\n\n"}
{"name":"RCLike.normSq_one","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\n‚ä¢ Eq (RCLike.normSq 1) 1","decl":"@[rclike_simps]\ntheorem normSq_one : normSq (1 : K) = 1 :=\n  normSq.map_one\n\n"}
{"name":"RCLike.normSq_nonneg","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz : K\n‚ä¢ LE.le 0 (RCLike.normSq z)","decl":"theorem normSq_nonneg (z : K) : 0 ‚â§ normSq z :=\n  add_nonneg (mul_self_nonneg _) (mul_self_nonneg _)\n\n"}
{"name":"RCLike.normSq_eq_zero","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz : K\n‚ä¢ Iff (Eq (RCLike.normSq z) 0) (Eq z 0)","decl":"@[rclike_simps] -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11119): was `simp`\ntheorem normSq_eq_zero {z : K} : normSq z = 0 ‚Üî z = 0 :=\n  map_eq_zero _\n\n"}
{"name":"RCLike.normSq_pos","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz : K\n‚ä¢ Iff (LT.lt 0 (RCLike.normSq z)) (Ne z 0)","decl":"@[simp, rclike_simps]\ntheorem normSq_pos {z : K} : 0 < normSq z ‚Üî z ‚â† 0 := by\n  rw [lt_iff_le_and_ne, Ne, eq_comm]; simp [normSq_nonneg]\n\n"}
{"name":"RCLike.normSq_neg","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz : K\n‚ä¢ Eq (RCLike.normSq (Neg.neg z)) (RCLike.normSq z)","decl":"@[simp, rclike_simps]\ntheorem normSq_neg (z : K) : normSq (-z) = normSq z := by simp only [normSq_eq_def', norm_neg]\n\n"}
{"name":"RCLike.normSq_conj","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz : K\n‚ä¢ Eq (RCLike.normSq ((starRingEnd K) z)) (RCLike.normSq z)","decl":"@[simp, rclike_simps]\ntheorem normSq_conj (z : K) : normSq (conj z) = normSq z := by\n  simp only [normSq_apply, neg_mul, mul_neg, neg_neg, rclike_simps]\n\n"}
{"name":"RCLike.normSq_mul","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz w : K\n‚ä¢ Eq (RCLike.normSq (HMul.hMul z w)) (HMul.hMul (RCLike.normSq z) (RCLike.normSq w))","decl":"@[rclike_simps] -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11119): was `simp`\ntheorem normSq_mul (z w : K) : normSq (z * w) = normSq z * normSq w :=\n  map_mul _ z w\n\n"}
{"name":"RCLike.normSq_add","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz w : K\n‚ä¢ Eq (RCLike.normSq (HAdd.hAdd z w)) (HAdd.hAdd (HAdd.hAdd (RCLike.normSq z) (RCLike.normSq w)) (HMul.hMul 2 (RCLike.re (HMul.hMul z ((starRingEnd K) w)))))","decl":"theorem normSq_add (z w : K) : normSq (z + w) = normSq z + normSq w + 2 * re (z * conj w) := by\n  simp only [normSq_apply, map_add, rclike_simps]\n  ring\n\n"}
{"name":"RCLike.re_sq_le_normSq","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz : K\n‚ä¢ LE.le (HMul.hMul (RCLike.re z) (RCLike.re z)) (RCLike.normSq z)","decl":"theorem re_sq_le_normSq (z : K) : re z * re z ‚â§ normSq z :=\n  le_add_of_nonneg_right (mul_self_nonneg _)\n\n"}
{"name":"RCLike.im_sq_le_normSq","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz : K\n‚ä¢ LE.le (HMul.hMul (RCLike.im z) (RCLike.im z)) (RCLike.normSq z)","decl":"theorem im_sq_le_normSq (z : K) : im z * im z ‚â§ normSq z :=\n  le_add_of_nonneg_left (mul_self_nonneg _)\n\n"}
{"name":"RCLike.mul_conj","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz : K\n‚ä¢ Eq (HMul.hMul z ((starRingEnd K) z)) (HPow.hPow (‚Üë(Norm.norm z)) 2)","decl":"theorem mul_conj (z : K) : z * conj z = ‚Äñz‚Äñ ^ 2 := by\n  apply ext <;> simp [‚Üê ofReal_pow, norm_sq_eq_def, mul_comm]\n\n"}
{"name":"RCLike.conj_mul","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz : K\n‚ä¢ Eq (HMul.hMul ((starRingEnd K) z) z) (HPow.hPow (‚Üë(Norm.norm z)) 2)","decl":"theorem conj_mul (z : K) : conj z * z = ‚Äñz‚Äñ ^ 2 := by rw [mul_comm, mul_conj]\n\n"}
{"name":"RCLike.inv_eq_conj","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz : K\nhz : Eq (Norm.norm z) 1\n‚ä¢ Eq (Inv.inv z) ((starRingEnd K) z)","decl":"lemma inv_eq_conj (hz : ‚Äñz‚Äñ = 1) : z‚Åª¬π = conj z :=\n  inv_eq_of_mul_eq_one_left <| by simp_rw [conj_mul, hz, algebraMap.coe_one, one_pow]\n\n"}
{"name":"RCLike.normSq_sub","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz w : K\n‚ä¢ Eq (RCLike.normSq (HSub.hSub z w)) (HSub.hSub (HAdd.hAdd (RCLike.normSq z) (RCLike.normSq w)) (HMul.hMul 2 (RCLike.re (HMul.hMul z ((starRingEnd K) w)))))","decl":"theorem normSq_sub (z w : K) : normSq (z - w) = normSq z + normSq w - 2 * re (z * conj w) := by\n  simp only [normSq_add, sub_eq_add_neg, map_neg, mul_neg, normSq_neg, map_neg]\n\n"}
{"name":"RCLike.sqrt_normSq_eq_norm","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz : K\n‚ä¢ Eq (RCLike.normSq z).sqrt (Norm.norm z)","decl":"theorem sqrt_normSq_eq_norm {z : K} : ‚àö(normSq z) = ‚Äñz‚Äñ := by\n  rw [normSq_eq_def', Real.sqrt_sq (norm_nonneg _)]\n\n"}
{"name":"RCLike.ofReal_inv","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nr : Real\n‚ä¢ Eq (‚Üë(Inv.inv r)) (Inv.inv ‚Üër)","decl":"@[rclike_simps, norm_cast]\ntheorem ofReal_inv (r : ‚Ñù) : ((r‚Åª¬π : ‚Ñù) : K) = (r : K)‚Åª¬π :=\n  map_inv‚ÇÄ _ r\n\n"}
{"name":"RCLike.inv_def","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz : K\n‚ä¢ Eq (Inv.inv z) (HMul.hMul ((starRingEnd K) z) ‚Üë(Inv.inv (HPow.hPow (Norm.norm z) 2)))","decl":"theorem inv_def (z : K) : z‚Åª¬π = conj z * ((‚Äñz‚Äñ ^ 2)‚Åª¬π : ‚Ñù) := by\n  rcases eq_or_ne z 0 with (rfl | h‚ÇÄ)\n  ¬∑ simp\n  ¬∑ apply inv_eq_of_mul_eq_one_right\n    rw [‚Üê mul_assoc, mul_conj, ofReal_inv, ofReal_pow, mul_inv_cancel‚ÇÄ]\n    simpa\n\n"}
{"name":"RCLike.inv_re","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz : K\n‚ä¢ Eq (RCLike.re (Inv.inv z)) (HDiv.hDiv (RCLike.re z) (RCLike.normSq z))","decl":"@[simp, rclike_simps]\ntheorem inv_re (z : K) : re z‚Åª¬π = re z / normSq z := by\n  rw [inv_def, normSq_eq_def', mul_comm, re_ofReal_mul, conj_re, div_eq_inv_mul]\n\n"}
{"name":"RCLike.inv_im","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz : K\n‚ä¢ Eq (RCLike.im (Inv.inv z)) (HDiv.hDiv (Neg.neg (RCLike.im z)) (RCLike.normSq z))","decl":"@[simp, rclike_simps]\ntheorem inv_im (z : K) : im z‚Åª¬π = -im z / normSq z := by\n  rw [inv_def, normSq_eq_def', mul_comm, im_ofReal_mul, conj_im, div_eq_inv_mul]\n\n"}
{"name":"RCLike.div_re","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz w : K\n‚ä¢ Eq (RCLike.re (HDiv.hDiv z w)) (HAdd.hAdd (HDiv.hDiv (HMul.hMul (RCLike.re z) (RCLike.re w)) (RCLike.normSq w)) (HDiv.hDiv (HMul.hMul (RCLike.im z) (RCLike.im w)) (RCLike.normSq w)))","decl":"theorem div_re (z w : K) : re (z / w) = re z * re w / normSq w + im z * im w / normSq w := by\n  simp only [div_eq_mul_inv, mul_assoc, sub_eq_add_neg, neg_mul, mul_neg, neg_neg, map_neg,\n    rclike_simps]\n\n"}
{"name":"RCLike.div_im","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz w : K\n‚ä¢ Eq (RCLike.im (HDiv.hDiv z w)) (HSub.hSub (HDiv.hDiv (HMul.hMul (RCLike.im z) (RCLike.re w)) (RCLike.normSq w)) (HDiv.hDiv (HMul.hMul (RCLike.re z) (RCLike.im w)) (RCLike.normSq w)))","decl":"theorem div_im (z w : K) : im (z / w) = im z * re w / normSq w - re z * im w / normSq w := by\n  simp only [div_eq_mul_inv, mul_assoc, sub_eq_add_neg, add_comm, neg_mul, mul_neg, map_neg,\n    rclike_simps]\n\n"}
{"name":"RCLike.conj_inv","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nx : K\n‚ä¢ Eq ((starRingEnd K) (Inv.inv x)) (Inv.inv ((starRingEnd K) x))","decl":"@[rclike_simps] -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11119): was `simp`\ntheorem conj_inv (x : K) : conj x‚Åª¬π = (conj x)‚Åª¬π :=\n  star_inv‚ÇÄ _\n\n"}
{"name":"RCLike.conj_div","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nx y : K\n‚ä¢ Eq ((starRingEnd K) (HDiv.hDiv x y)) (HDiv.hDiv ((starRingEnd K) x) ((starRingEnd K) y))","decl":"lemma conj_div (x y : K) : conj (x / y) = conj x / conj y := map_div' conj conj_inv _ _\n\n--TODO: Do we rather want the map as an explicit definition?\n"}
{"name":"RCLike.exists_norm_eq_mul_self","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nx : K\n‚ä¢ Exists fun c => And (Eq (Norm.norm c) 1) (Eq (‚Üë(Norm.norm x)) (HMul.hMul c x))","decl":"lemma exists_norm_eq_mul_self (x : K) : ‚àÉ c, ‚Äñc‚Äñ = 1 ‚àß ‚Üë‚Äñx‚Äñ = c * x := by\n  obtain rfl | hx := eq_or_ne x 0\n  ¬∑ exact ‚ü®1, by simp‚ü©\n  ¬∑ exact ‚ü®‚Äñx‚Äñ / x, by simp [norm_ne_zero_iff.2, hx]‚ü©\n\n"}
{"name":"RCLike.exists_norm_mul_eq_self","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nx : K\n‚ä¢ Exists fun c => And (Eq (Norm.norm c) 1) (Eq (HMul.hMul c ‚Üë(Norm.norm x)) x)","decl":"lemma exists_norm_mul_eq_self (x : K) : ‚àÉ c, ‚Äñc‚Äñ = 1 ‚àß c * ‚Äñx‚Äñ = x := by\n  obtain rfl | hx := eq_or_ne x 0\n  ¬∑ exact ‚ü®1, by simp‚ü©\n  ¬∑ exact ‚ü®x / ‚Äñx‚Äñ, by simp [norm_ne_zero_iff.2, hx]‚ü©\n\n"}
{"name":"RCLike.ofReal_div","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nr s : Real\n‚ä¢ Eq (‚Üë(HDiv.hDiv r s)) (HDiv.hDiv ‚Üër ‚Üës)","decl":"@[rclike_simps, norm_cast]\ntheorem ofReal_div (r s : ‚Ñù) : ((r / s : ‚Ñù) : K) = r / s :=\n  map_div‚ÇÄ (algebraMap ‚Ñù K) r s\n\n"}
{"name":"RCLike.div_re_ofReal","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz : K\nr : Real\n‚ä¢ Eq (RCLike.re (HDiv.hDiv z ‚Üër)) (HDiv.hDiv (RCLike.re z) r)","decl":"theorem div_re_ofReal {z : K} {r : ‚Ñù} : re (z / r) = re z / r := by\n  rw [div_eq_inv_mul, div_eq_inv_mul, ‚Üê ofReal_inv, re_ofReal_mul]\n\n"}
{"name":"RCLike.ofReal_zpow","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nr : Real\nn : Int\n‚ä¢ Eq (‚Üë(HPow.hPow r n)) (HPow.hPow (‚Üër) n)","decl":"@[rclike_simps, norm_cast]\ntheorem ofReal_zpow (r : ‚Ñù) (n : ‚Ñ§) : ((r ^ n : ‚Ñù) : K) = (r : K) ^ n :=\n  map_zpow‚ÇÄ (algebraMap ‚Ñù K) r n\n\n"}
{"name":"RCLike.I_mul_I_of_nonzero","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\na‚úù : Ne RCLike.I 0\n‚ä¢ Eq (HMul.hMul RCLike.I RCLike.I) (-1)","decl":"theorem I_mul_I_of_nonzero : (I : K) ‚â† 0 ‚Üí (I : K) * I = -1 :=\n  I_mul_I_ax.resolve_left\n\n"}
{"name":"RCLike.inv_I","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\n‚ä¢ Eq (Inv.inv RCLike.I) (Neg.neg RCLike.I)","decl":"@[simp, rclike_simps]\ntheorem inv_I : (I : K)‚Åª¬π = -I := by\n  by_cases h : (I : K) = 0\n  ¬∑ simp [h]\n  ¬∑ field_simp [I_mul_I_of_nonzero h]\n\n"}
{"name":"RCLike.div_I","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz : K\n‚ä¢ Eq (HDiv.hDiv z RCLike.I) (Neg.neg (HMul.hMul z RCLike.I))","decl":"@[simp, rclike_simps]\ntheorem div_I (z : K) : z / I = -(z * I) := by rw [div_eq_mul_inv, inv_I, mul_neg]\n\n"}
{"name":"RCLike.normSq_inv","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz : K\n‚ä¢ Eq (RCLike.normSq (Inv.inv z)) (Inv.inv (RCLike.normSq z))","decl":"@[rclike_simps] -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11119): was `simp`\ntheorem normSq_inv (z : K) : normSq z‚Åª¬π = (normSq z)‚Åª¬π :=\n  map_inv‚ÇÄ normSq z\n\n"}
{"name":"RCLike.normSq_div","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz w : K\n‚ä¢ Eq (RCLike.normSq (HDiv.hDiv z w)) (HDiv.hDiv (RCLike.normSq z) (RCLike.normSq w))","decl":"@[rclike_simps] -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11119): was `simp`\ntheorem normSq_div (z w : K) : normSq (z / w) = normSq z / normSq w :=\n  map_div‚ÇÄ normSq z w\n\n"}
{"name":"RCLike.norm_conj","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz : K\n‚ä¢ Eq (Norm.norm ((starRingEnd K) z)) (Norm.norm z)","decl":"@[simp 1100, rclike_simps]\ntheorem norm_conj (z : K) : ‚Äñconj z‚Äñ = ‚Äñz‚Äñ := by simp only [‚Üê sqrt_normSq_eq_norm, normSq_conj]\n\n"}
{"name":"RCLike.nnnorm_conj","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz : K\n‚ä¢ Eq (NNNorm.nnnorm ((starRingEnd K) z)) (NNNorm.nnnorm z)","decl":"@[simp, rclike_simps] lemma nnnorm_conj (z : K) : ‚Äñconj z‚Äñ‚Çä = ‚Äñz‚Äñ‚Çä := by simp [nnnorm]\n\n"}
{"name":"RCLike.instCStarRing","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\n‚ä¢ CStarRing K","decl":"instance (priority := 100) : CStarRing K where\n  norm_mul_self_le x := le_of_eq <| ((norm_mul _ _).trans <| congr_arg (¬∑ * ‚Äñx‚Äñ) (norm_conj _)).symm\n\n"}
{"name":"RCLike.ofReal_natCast","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nn : Nat\n‚ä¢ Eq ‚Üë‚Üën ‚Üën","decl":"@[rclike_simps, norm_cast]\ntheorem ofReal_natCast (n : ‚Ñï) : ((n : ‚Ñù) : K) = n :=\n  map_natCast (algebraMap ‚Ñù K) n\n\n"}
{"name":"RCLike.ofReal_nnratCast","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nq : NNRat\n‚ä¢ Eq ‚Üë‚Üëq ‚Üëq","decl":"@[rclike_simps, norm_cast]\nlemma ofReal_nnratCast (q : ‚Ñö‚â•0) : ((q : ‚Ñù) : K) = q := map_nnratCast (algebraMap ‚Ñù K) _\n\n"}
{"name":"RCLike.natCast_re","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nn : Nat\n‚ä¢ Eq (RCLike.re ‚Üën) ‚Üën","decl":"@[simp, rclike_simps] -- Porting note: removed `norm_cast`\ntheorem natCast_re (n : ‚Ñï) : re (n : K) = n := by rw [‚Üê ofReal_natCast, ofReal_re]\n\n"}
{"name":"RCLike.natCast_im","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nn : Nat\n‚ä¢ Eq (RCLike.im ‚Üën) 0","decl":"@[simp, rclike_simps, norm_cast]\ntheorem natCast_im (n : ‚Ñï) : im (n : K) = 0 := by rw [‚Üê ofReal_natCast, ofReal_im]\n"}
{"name":"RCLike.ofNat_re","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : RCLike K\nn : Nat\ninst‚úù : n.AtLeastTwo\n‚ä¢ Eq (RCLike.re (OfNat.ofNat n)) (OfNat.ofNat n)","decl":"@[simp, rclike_simps]\ntheorem ofNat_re (n : ‚Ñï) [n.AtLeastTwo] : re (ofNat(n) : K) = ofNat(n) :=\n  natCast_re n\n"}
{"name":"RCLike.ofNat_im","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : RCLike K\nn : Nat\ninst‚úù : n.AtLeastTwo\n‚ä¢ Eq (RCLike.im (OfNat.ofNat n)) 0","decl":"@[simp, rclike_simps]\ntheorem ofNat_im (n : ‚Ñï) [n.AtLeastTwo] : im (ofNat(n) : K) = 0 :=\n  natCast_im n\n\n"}
{"name":"RCLike.ofReal_ofNat","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : RCLike K\nn : Nat\ninst‚úù : n.AtLeastTwo\n‚ä¢ Eq (‚Üë(OfNat.ofNat n)) (OfNat.ofNat n)","decl":"@[rclike_simps, norm_cast]\ntheorem ofReal_ofNat (n : ‚Ñï) [n.AtLeastTwo] : ((ofNat(n) : ‚Ñù) : K) = ofNat(n) :=\n  ofReal_natCast n\n\n"}
{"name":"RCLike.ofNat_mul_re","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : RCLike K\nn : Nat\ninst‚úù : n.AtLeastTwo\nz : K\n‚ä¢ Eq (RCLike.re (HMul.hMul (OfNat.ofNat n) z)) (HMul.hMul (OfNat.ofNat n) (RCLike.re z))","decl":"theorem ofNat_mul_re (n : ‚Ñï) [n.AtLeastTwo] (z : K) :\n    re (ofNat(n) * z) = ofNat(n) * re z := by\n  rw [‚Üê ofReal_ofNat, re_ofReal_mul]\n\n"}
{"name":"RCLike.ofNat_mul_im","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : RCLike K\nn : Nat\ninst‚úù : n.AtLeastTwo\nz : K\n‚ä¢ Eq (RCLike.im (HMul.hMul (OfNat.ofNat n) z)) (HMul.hMul (OfNat.ofNat n) (RCLike.im z))","decl":"theorem ofNat_mul_im (n : ‚Ñï) [n.AtLeastTwo] (z : K) :\n    im (ofNat(n) * z) = ofNat(n) * im z := by\n  rw [‚Üê ofReal_ofNat, im_ofReal_mul]\n\n"}
{"name":"RCLike.ofReal_intCast","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nn : Int\n‚ä¢ Eq ‚Üë‚Üën ‚Üën","decl":"@[rclike_simps, norm_cast]\ntheorem ofReal_intCast (n : ‚Ñ§) : ((n : ‚Ñù) : K) = n :=\n  map_intCast _ n\n\n"}
{"name":"RCLike.intCast_re","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nn : Int\n‚ä¢ Eq (RCLike.re ‚Üën) ‚Üën","decl":"@[simp, rclike_simps] -- Porting note: removed `norm_cast`\ntheorem intCast_re (n : ‚Ñ§) : re (n : K) = n := by rw [‚Üê ofReal_intCast, ofReal_re]\n\n"}
{"name":"RCLike.intCast_im","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nn : Int\n‚ä¢ Eq (RCLike.im ‚Üën) 0","decl":"@[simp, rclike_simps, norm_cast]\ntheorem intCast_im (n : ‚Ñ§) : im (n : K) = 0 := by rw [‚Üê ofReal_intCast, ofReal_im]\n\n"}
{"name":"RCLike.ofReal_ratCast","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nn : Rat\n‚ä¢ Eq ‚Üë‚Üën ‚Üën","decl":"@[rclike_simps, norm_cast]\ntheorem ofReal_ratCast (n : ‚Ñö) : ((n : ‚Ñù) : K) = n :=\n  map_ratCast _ n\n\n"}
{"name":"RCLike.ratCast_re","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nq : Rat\n‚ä¢ Eq (RCLike.re ‚Üëq) ‚Üëq","decl":"@[simp, rclike_simps] -- Porting note: removed `norm_cast`\ntheorem ratCast_re (q : ‚Ñö) : re (q : K) = q := by rw [‚Üê ofReal_ratCast, ofReal_re]\n\n"}
{"name":"RCLike.ratCast_im","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nq : Rat\n‚ä¢ Eq (RCLike.im ‚Üëq) 0","decl":"@[simp, rclike_simps, norm_cast]\ntheorem ratCast_im (q : ‚Ñö) : im (q : K) = 0 := by rw [‚Üê ofReal_ratCast, ofReal_im]\n\n"}
{"name":"RCLike.norm_of_nonneg","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nr : Real\nh : LE.le 0 r\n‚ä¢ Eq (Norm.norm ‚Üër) r","decl":"theorem norm_of_nonneg {r : ‚Ñù} (h : 0 ‚â§ r) : ‚Äñ(r : K)‚Äñ = r :=\n  (norm_ofReal _).trans (abs_of_nonneg h)\n\n"}
{"name":"RCLike.norm_natCast","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nn : Nat\n‚ä¢ Eq (Norm.norm ‚Üën) ‚Üën","decl":"@[simp, rclike_simps, norm_cast]\ntheorem norm_natCast (n : ‚Ñï) : ‚Äñ(n : K)‚Äñ = n := by\n  rw [‚Üê ofReal_natCast]\n  exact norm_of_nonneg (Nat.cast_nonneg n)\n\n"}
{"name":"RCLike.nnnorm_natCast","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nn : Nat\n‚ä¢ Eq (NNNorm.nnnorm ‚Üën) ‚Üën","decl":"@[simp, rclike_simps, norm_cast] lemma nnnorm_natCast (n : ‚Ñï) : ‚Äñ(n : K)‚Äñ‚Çä = n := by simp [nnnorm]\n\n"}
{"name":"RCLike.norm_ofNat","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : RCLike K\nn : Nat\ninst‚úù : n.AtLeastTwo\n‚ä¢ Eq (Norm.norm (OfNat.ofNat n)) (OfNat.ofNat n)","decl":"@[simp, rclike_simps]\ntheorem norm_ofNat (n : ‚Ñï) [n.AtLeastTwo] : ‚Äñ(ofNat(n) : K)‚Äñ = ofNat(n) :=\n  norm_natCast n\n\n"}
{"name":"RCLike.nnnorm_ofNat","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : RCLike K\nn : Nat\ninst‚úù : n.AtLeastTwo\n‚ä¢ Eq (NNNorm.nnnorm (OfNat.ofNat n)) (OfNat.ofNat n)","decl":"@[simp, rclike_simps]\nlemma nnnorm_ofNat (n : ‚Ñï) [n.AtLeastTwo] : ‚Äñ(ofNat(n) : K)‚Äñ‚Çä = ofNat(n) :=\n  nnnorm_natCast n\n\n"}
{"name":"RCLike.norm_two","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\n‚ä¢ Eq (Norm.norm 2) 2","decl":"lemma norm_two : ‚Äñ(2 : K)‚Äñ = 2 := norm_ofNat 2\n"}
{"name":"RCLike.nnnorm_two","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\n‚ä¢ Eq (NNNorm.nnnorm 2) 2","decl":"lemma nnnorm_two : ‚Äñ(2 : K)‚Äñ‚Çä = 2 := nnnorm_ofNat 2\n\n"}
{"name":"RCLike.norm_nnratCast","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nq : NNRat\n‚ä¢ Eq (Norm.norm ‚Üëq) ‚Üëq","decl":"@[simp, rclike_simps, norm_cast]\nlemma norm_nnratCast (q : ‚Ñö‚â•0) : ‚Äñ(q : K)‚Äñ = q := by\n  rw [‚Üê ofReal_nnratCast]; exact norm_of_nonneg q.cast_nonneg\n\n"}
{"name":"RCLike.nnnorm_nnratCast","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nq : NNRat\n‚ä¢ Eq (NNNorm.nnnorm ‚Üëq) ‚Üëq","decl":"@[simp, rclike_simps, norm_cast]\nlemma nnnorm_nnratCast (q : ‚Ñö‚â•0) : ‚Äñ(q : K)‚Äñ‚Çä = q := by simp [nnnorm]\n\n"}
{"name":"RCLike.norm_nsmul","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\nE : Type u_2\ninst‚úù¬≤ : RCLike K\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace K E\nn : Nat\nx : E\n‚ä¢ Eq (Norm.norm (HSMul.hSMul n x)) (HSMul.hSMul n (Norm.norm x))","decl":"variable (K) in\nlemma norm_nsmul [NormedAddCommGroup E] [NormedSpace K E] (n : ‚Ñï) (x : E) : ‚Äñn ‚Ä¢ x‚Äñ = n ‚Ä¢ ‚Äñx‚Äñ := by\n  simpa [Nat.cast_smul_eq_nsmul] using norm_smul (n : K) x\n\n"}
{"name":"RCLike.nnnorm_nsmul","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\nE : Type u_2\ninst‚úù¬≤ : RCLike K\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace K E\nn : Nat\nx : E\n‚ä¢ Eq (NNNorm.nnnorm (HSMul.hSMul n x)) (HSMul.hSMul n (NNNorm.nnnorm x))","decl":"variable (K) in\nlemma nnnorm_nsmul [NormedAddCommGroup E] [NormedSpace K E] (n : ‚Ñï) (x : E) :\n    ‚Äñn ‚Ä¢ x‚Äñ‚Çä = n ‚Ä¢ ‚Äñx‚Äñ‚Çä := by simpa [Nat.cast_smul_eq_nsmul] using nnnorm_smul (n : K) x\n\n"}
{"name":"RCLike.norm_nnqsmul","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike K\ninst‚úù¬≤ : NormedField E\ninst‚úù¬π : CharZero E\ninst‚úù : NormedSpace K E\nq : NNRat\nx : E\n‚ä¢ Eq (Norm.norm (HSMul.hSMul q x)) (HSMul.hSMul q (Norm.norm x))","decl":"variable (K) in\nlemma norm_nnqsmul (q : ‚Ñö‚â•0) (x : E) : ‚Äñq ‚Ä¢ x‚Äñ = q ‚Ä¢ ‚Äñx‚Äñ := by\n  simpa [NNRat.cast_smul_eq_nnqsmul] using norm_smul (q : K) x\n\n"}
{"name":"RCLike.nnnorm_nnqsmul","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike K\ninst‚úù¬≤ : NormedField E\ninst‚úù¬π : CharZero E\ninst‚úù : NormedSpace K E\nq : NNRat\nx : E\n‚ä¢ Eq (NNNorm.nnnorm (HSMul.hSMul q x)) (HSMul.hSMul q (NNNorm.nnnorm x))","decl":"variable (K) in\nlemma nnnorm_nnqsmul (q : ‚Ñö‚â•0) (x : E) : ‚Äñq ‚Ä¢ x‚Äñ‚Çä = q ‚Ä¢ ‚Äñx‚Äñ‚Çä := by\n  simpa [NNRat.cast_smul_eq_nnqsmul] using nnnorm_smul (q : K) x\n\n"}
{"name":"RCLike.norm_expect_le","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\nE : Type u_2\ninst‚úù¬≥ : RCLike K\ninst‚úù¬≤ : NormedField E\ninst‚úù¬π : CharZero E\ninst‚úù : NormedSpace K E\nŒπ : Type u_3\ns : Finset Œπ\nf : Œπ ‚Üí E\n‚ä¢ LE.le (Norm.norm (s.expect fun i => f i)) (s.expect fun i => Norm.norm (f i))","decl":"@[bound]\nlemma norm_expect_le {Œπ : Type*} {s : Finset Œπ} {f : Œπ ‚Üí E} : ‚Äñùîº i ‚àà s, f i‚Äñ ‚â§ ùîº i ‚àà s, ‚Äñf i‚Äñ :=\n  Finset.le_expect_of_subadditive norm_zero norm_add_le fun _ _ ‚Ü¶ by rw [norm_nnqsmul K]\n\n"}
{"name":"RCLike.mul_self_norm","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz : K\n‚ä¢ Eq (HMul.hMul (Norm.norm z) (Norm.norm z)) (RCLike.normSq z)","decl":"theorem mul_self_norm (z : K) : ‚Äñz‚Äñ * ‚Äñz‚Äñ = normSq z := by rw [normSq_eq_def', sq]\n\n"}
{"name":"RCLike.abs_re_le_norm","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz : K\n‚ä¢ LE.le (abs (RCLike.re z)) (Norm.norm z)","decl":"theorem abs_re_le_norm (z : K) : |re z| ‚â§ ‚Äñz‚Äñ := by\n  rw [mul_self_le_mul_self_iff (abs_nonneg _) (norm_nonneg _), abs_mul_abs_self, mul_self_norm]\n  apply re_sq_le_normSq\n\n"}
{"name":"RCLike.abs_im_le_norm","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz : K\n‚ä¢ LE.le (abs (RCLike.im z)) (Norm.norm z)","decl":"theorem abs_im_le_norm (z : K) : |im z| ‚â§ ‚Äñz‚Äñ := by\n  rw [mul_self_le_mul_self_iff (abs_nonneg _) (norm_nonneg _), abs_mul_abs_self, mul_self_norm]\n  apply im_sq_le_normSq\n\n"}
{"name":"RCLike.norm_re_le_norm","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz : K\n‚ä¢ LE.le (Norm.norm (RCLike.re z)) (Norm.norm z)","decl":"theorem norm_re_le_norm (z : K) : ‚Äñre z‚Äñ ‚â§ ‚Äñz‚Äñ :=\n  abs_re_le_norm z\n\n"}
{"name":"RCLike.norm_im_le_norm","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz : K\n‚ä¢ LE.le (Norm.norm (RCLike.im z)) (Norm.norm z)","decl":"theorem norm_im_le_norm (z : K) : ‚Äñim z‚Äñ ‚â§ ‚Äñz‚Äñ :=\n  abs_im_le_norm z\n\n"}
{"name":"RCLike.re_le_norm","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz : K\n‚ä¢ LE.le (RCLike.re z) (Norm.norm z)","decl":"theorem re_le_norm (z : K) : re z ‚â§ ‚Äñz‚Äñ :=\n  (abs_le.1 (abs_re_le_norm z)).2\n\n"}
{"name":"RCLike.im_le_norm","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz : K\n‚ä¢ LE.le (RCLike.im z) (Norm.norm z)","decl":"theorem im_le_norm (z : K) : im z ‚â§ ‚Äñz‚Äñ :=\n  (abs_le.1 (abs_im_le_norm _)).2\n\n"}
{"name":"RCLike.im_eq_zero_of_le","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\na : K\nh : LE.le (Norm.norm a) (RCLike.re a)\n‚ä¢ Eq (RCLike.im a) 0","decl":"theorem im_eq_zero_of_le {a : K} (h : ‚Äña‚Äñ ‚â§ re a) : im a = 0 := by\n  simpa only [mul_self_norm a, normSq_apply, self_eq_add_right, mul_self_eq_zero]\n    using congr_arg (fun z => z * z) ((re_le_norm a).antisymm h)\n\n"}
{"name":"RCLike.re_eq_self_of_le","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\na : K\nh : LE.le (Norm.norm a) (RCLike.re a)\n‚ä¢ Eq (‚Üë(RCLike.re a)) a","decl":"theorem re_eq_self_of_le {a : K} (h : ‚Äña‚Äñ ‚â§ re a) : (re a : K) = a := by\n  rw [‚Üê conj_eq_iff_re, conj_eq_iff_im, im_eq_zero_of_le h]\n\n"}
{"name":"RCLike.abs_re_div_norm_le_one","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz : K\n‚ä¢ LE.le (abs (HDiv.hDiv (RCLike.re z) (Norm.norm z))) 1","decl":"theorem abs_re_div_norm_le_one (z : K) : |re z / ‚Äñz‚Äñ| ‚â§ 1 := by\n  rw [abs_div, abs_norm]\n  exact div_le_one_of_le‚ÇÄ (abs_re_le_norm _) (norm_nonneg _)\n\n"}
{"name":"RCLike.abs_im_div_norm_le_one","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz : K\n‚ä¢ LE.le (abs (HDiv.hDiv (RCLike.im z) (Norm.norm z))) 1","decl":"theorem abs_im_div_norm_le_one (z : K) : |im z / ‚Äñz‚Äñ| ‚â§ 1 := by\n  rw [abs_div, abs_norm]\n  exact div_le_one_of_le‚ÇÄ (abs_im_le_norm _) (norm_nonneg _)\n\n"}
{"name":"RCLike.norm_I_of_ne_zero","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nhI : Ne RCLike.I 0\n‚ä¢ Eq (Norm.norm RCLike.I) 1","decl":"theorem norm_I_of_ne_zero (hI : (I : K) ‚â† 0) : ‚Äñ(I : K)‚Äñ = 1 := by\n  rw [‚Üê mul_self_inj_of_nonneg (norm_nonneg I) zero_le_one, one_mul, ‚Üê norm_mul,\n    I_mul_I_of_nonzero hI, norm_neg, norm_one]\n\n"}
{"name":"RCLike.re_eq_norm_of_mul_conj","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nx : K\n‚ä¢ Eq (RCLike.re (HMul.hMul x ((starRingEnd K) x))) (Norm.norm (HMul.hMul x ((starRingEnd K) x)))","decl":"theorem re_eq_norm_of_mul_conj (x : K) : re (x * conj x) = ‚Äñx * conj x‚Äñ := by\n  rw [mul_conj, ‚Üê ofReal_pow]; simp [-map_pow]\n\n"}
{"name":"RCLike.norm_sq_re_add_conj","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nx : K\n‚ä¢ Eq (HPow.hPow (Norm.norm (HAdd.hAdd x ((starRingEnd K) x))) 2) (HPow.hPow (RCLike.re (HAdd.hAdd x ((starRingEnd K) x))) 2)","decl":"theorem norm_sq_re_add_conj (x : K) : ‚Äñx + conj x‚Äñ ^ 2 = re (x + conj x) ^ 2 := by\n  rw [add_conj, ‚Üê ofReal_ofNat, ‚Üê ofReal_mul, norm_ofReal, sq_abs, ofReal_re]\n\n"}
{"name":"RCLike.norm_sq_re_conj_add","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nx : K\n‚ä¢ Eq (HPow.hPow (Norm.norm (HAdd.hAdd ((starRingEnd K) x) x)) 2) (HPow.hPow (RCLike.re (HAdd.hAdd ((starRingEnd K) x) x)) 2)","decl":"theorem norm_sq_re_conj_add (x : K) : ‚Äñconj x + x‚Äñ ^ 2 = re (conj x + x) ^ 2 := by\n  rw [add_comm, norm_sq_re_add_conj]\n\n"}
{"name":"RCLike.isCauSeq_re","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nf : CauSeq K Norm.norm\n‚ä¢ IsCauSeq abs fun n => RCLike.re (‚Üëf n)","decl":"theorem isCauSeq_re (f : CauSeq K norm) : IsCauSeq abs fun n => re (f n) := fun _ Œµ0 =>\n  (f.cauchy Œµ0).imp fun i H j ij =>\n    lt_of_le_of_lt (by simpa only [map_sub] using abs_re_le_norm (f j - f i)) (H _ ij)\n\n"}
{"name":"RCLike.isCauSeq_im","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nf : CauSeq K Norm.norm\n‚ä¢ IsCauSeq abs fun n => RCLike.im (‚Üëf n)","decl":"theorem isCauSeq_im (f : CauSeq K norm) : IsCauSeq abs fun n => im (f n) := fun _ Œµ0 =>\n  (f.cauchy Œµ0).imp fun i H j ij =>\n    lt_of_le_of_lt (by simpa only [map_sub] using abs_im_le_norm (f j - f i)) (H _ ij)\n\n"}
{"name":"RCLike.isCauSeq_norm","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nf : Nat ‚Üí K\nhf : IsCauSeq Norm.norm f\n‚ä¢ IsCauSeq abs (Function.comp Norm.norm f)","decl":"theorem isCauSeq_norm {f : ‚Ñï ‚Üí K} (hf : IsCauSeq norm f) : IsCauSeq abs (norm ‚àò f) := fun Œµ Œµ0 =>\n  let ‚ü®i, hi‚ü© := hf Œµ Œµ0\n  ‚ü®i, fun j hj => lt_of_le_of_lt (abs_norm_sub_norm_le _ _) (hi j hj)‚ü©\n\n"}
{"name":"RCLike.lt_iff_re_im","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz w : K\n‚ä¢ Iff (LT.lt z w) (And (LT.lt (RCLike.re z) (RCLike.re w)) (Eq (RCLike.im z) (RCLike.im w)))","decl":"theorem lt_iff_re_im : z < w ‚Üî re z < re w ‚àß im z = im w := by\n  simp_rw [lt_iff_le_and_ne, @RCLike.le_iff_re_im K]\n  constructor\n  ¬∑ rintro ‚ü®‚ü®hr, hi‚ü©, heq‚ü©\n    exact ‚ü®‚ü®hr, mt (fun hreq => ext hreq hi) heq‚ü©, hi‚ü©\n  ¬∑ rintro ‚ü®‚ü®hr, hrn‚ü©, hi‚ü©\n    exact ‚ü®‚ü®hr, hi‚ü©, ne_of_apply_ne _ hrn‚ü©\n\n"}
{"name":"RCLike.nonneg_iff","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz : K\n‚ä¢ Iff (LE.le 0 z) (And (LE.le 0 (RCLike.re z)) (Eq (RCLike.im z) 0))","decl":"theorem nonneg_iff : 0 ‚â§ z ‚Üî 0 ‚â§ re z ‚àß im z = 0 := by\n  simpa only [map_zero, eq_comm] using le_iff_re_im (z := 0) (w := z)\n\n"}
{"name":"RCLike.pos_iff","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz : K\n‚ä¢ Iff (LT.lt 0 z) (And (LT.lt 0 (RCLike.re z)) (Eq (RCLike.im z) 0))","decl":"theorem pos_iff : 0 < z ‚Üî 0 < re z ‚àß im z = 0 := by\n  simpa only [map_zero, eq_comm] using lt_iff_re_im (z := 0) (w := z)\n\n"}
{"name":"RCLike.nonpos_iff","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz : K\n‚ä¢ Iff (LE.le z 0) (And (LE.le (RCLike.re z) 0) (Eq (RCLike.im z) 0))","decl":"theorem nonpos_iff : z ‚â§ 0 ‚Üî re z ‚â§ 0 ‚àß im z = 0 := by\n  simpa only [map_zero] using le_iff_re_im (z := z) (w := 0)\n\n"}
{"name":"RCLike.neg_iff","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz : K\n‚ä¢ Iff (LT.lt z 0) (And (LT.lt (RCLike.re z) 0) (Eq (RCLike.im z) 0))","decl":"theorem neg_iff : z < 0 ‚Üî re z < 0 ‚àß im z = 0 := by\n  simpa only [map_zero] using lt_iff_re_im (z := z) (w := 0)\n\n"}
{"name":"RCLike.nonneg_iff_exists_ofReal","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz : K\n‚ä¢ Iff (LE.le 0 z) (Exists fun x => And (GE.ge x 0) (Eq (‚Üëx) z))","decl":"lemma nonneg_iff_exists_ofReal : 0 ‚â§ z ‚Üî ‚àÉ x ‚â• (0 : ‚Ñù), x = z := by\n  simp_rw [nonneg_iff (K := K), ext_iff (K := K)]; aesop\n\n"}
{"name":"RCLike.pos_iff_exists_ofReal","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz : K\n‚ä¢ Iff (LT.lt 0 z) (Exists fun x => And (GT.gt x 0) (Eq (‚Üëx) z))","decl":"lemma pos_iff_exists_ofReal : 0 < z ‚Üî ‚àÉ x > (0 : ‚Ñù), x = z := by\n  simp_rw [pos_iff (K := K), ext_iff (K := K)]; aesop\n\n"}
{"name":"RCLike.nonpos_iff_exists_ofReal","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz : K\n‚ä¢ Iff (LE.le z 0) (Exists fun x => And (LE.le x 0) (Eq (‚Üëx) z))","decl":"lemma nonpos_iff_exists_ofReal : z ‚â§ 0 ‚Üî ‚àÉ x ‚â§ (0 : ‚Ñù), x = z := by\n  simp_rw [nonpos_iff (K := K), ext_iff (K := K)]; aesop\n\n"}
{"name":"RCLike.neg_iff_exists_ofReal","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz : K\n‚ä¢ Iff (LT.lt z 0) (Exists fun x => And (LT.lt x 0) (Eq (‚Üëx) z))","decl":"lemma neg_iff_exists_ofReal : z < 0 ‚Üî ‚àÉ x < (0 : ‚Ñù), x = z := by\n  simp_rw [neg_iff (K := K), ext_iff (K := K)]; aesop\n\n"}
{"name":"RCLike.ofReal_le_ofReal","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nx y : Real\n‚ä¢ Iff (LE.le ‚Üëx ‚Üëy) (LE.le x y)","decl":"@[simp, norm_cast]\nlemma ofReal_le_ofReal {x y : ‚Ñù} : (x : K) ‚â§ (y : K) ‚Üî x ‚â§ y := by\n  rw [le_iff_re_im]\n  simp\n\n"}
{"name":"RCLike.ofReal_lt_ofReal","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nx y : Real\n‚ä¢ Iff (LT.lt ‚Üëx ‚Üëy) (LT.lt x y)","decl":"@[simp, norm_cast]\nlemma ofReal_lt_ofReal {x y : ‚Ñù} : (x : K) < (y : K) ‚Üî x < y := by\n  rw [lt_iff_re_im]\n  simp\n\n"}
{"name":"RCLike.ofReal_nonneg","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nx : Real\n‚ä¢ Iff (LE.le 0 ‚Üëx) (LE.le 0 x)","decl":"@[simp, norm_cast]\nlemma ofReal_nonneg {x : ‚Ñù} : 0 ‚â§ (x : K) ‚Üî 0 ‚â§ x := by\n  rw [‚Üê ofReal_zero, ofReal_le_ofReal]\n\n"}
{"name":"RCLike.ofReal_nonpos","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nx : Real\n‚ä¢ Iff (LE.le (‚Üëx) 0) (LE.le x 0)","decl":"@[simp, norm_cast]\nlemma ofReal_nonpos {x : ‚Ñù} : (x : K) ‚â§ 0 ‚Üî x ‚â§ 0 := by\n  rw [‚Üê ofReal_zero, ofReal_le_ofReal]\n\n"}
{"name":"RCLike.ofReal_pos","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nx : Real\n‚ä¢ Iff (LT.lt 0 ‚Üëx) (LT.lt 0 x)","decl":"@[simp, norm_cast]\nlemma ofReal_pos {x : ‚Ñù} : 0 < (x : K) ‚Üî 0 < x := by\n  rw [‚Üê ofReal_zero, ofReal_lt_ofReal]\n\n"}
{"name":"RCLike.ofReal_lt_zero","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nx : Real\n‚ä¢ Iff (LT.lt (‚Üëx) 0) (LT.lt x 0)","decl":"@[simp, norm_cast]\nlemma ofReal_lt_zero {x : ‚Ñù} : (x : K) < 0 ‚Üî x < 0 := by\n  rw [‚Üê ofReal_zero, ofReal_lt_ofReal]\n\n"}
{"name":"RCLike.inv_pos_of_pos","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz : K\nhz : LT.lt 0 z\n‚ä¢ LT.lt 0 (Inv.inv z)","decl":"protected lemma inv_pos_of_pos (hz : 0 < z) : 0 < z‚Åª¬π := by\n  rw [pos_iff_exists_ofReal] at hz\n  obtain ‚ü®x, hx, hx'‚ü© := hz\n  rw [‚Üê hx', ‚Üê ofReal_inv, ofReal_pos]\n  exact inv_pos_of_pos hx\n\n"}
{"name":"RCLike.inv_pos","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nz : K\n‚ä¢ Iff (LT.lt 0 (Inv.inv z)) (LT.lt 0 z)","decl":"protected lemma inv_pos : 0 < z‚Åª¬π ‚Üî 0 < z := by\n  refine ‚ü®fun h => ?_, fun h => RCLike.inv_pos_of_pos h‚ü©\n  rw [‚Üê inv_inv z]\n  exact RCLike.inv_pos_of_pos h\n\n"}
{"name":"RCLike.toStarOrderedRing","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\n‚ä¢ StarOrderedRing K","decl":"/-- With `z ‚â§ w` iff `w - z` is real and nonnegative, `‚Ñù` and `‚ÑÇ` are star ordered rings.\n(That is, a star ring in which the nonnegative elements are those of the form `star z * z`.)\n\nNote this is only an instance with `open scoped ComplexOrder`. -/\nlemma toStarOrderedRing : StarOrderedRing K :=\n  StarOrderedRing.of_nonneg_iff'\n    (h_add := fun {x y} hxy z => by\n      rw [RCLike.le_iff_re_im] at *\n      simpa [map_add, add_le_add_iff_left, add_right_inj] using hxy)\n    (h_nonneg_iff := fun x => by\n      rw [nonneg_iff]\n      refine ‚ü®fun h ‚Ü¶ ‚ü®‚àö(re x), by simp [ext_iff (K := K), h.1, h.2]‚ü©, ?_‚ü©\n      rintro ‚ü®s, rfl‚ü©\n      simp [mul_comm, mul_self_nonneg, add_nonneg])\n\n"}
{"name":"RCLike.toOrderedSMul","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\n‚ä¢ OrderedSMul Real K","decl":"theorem toOrderedSMul : OrderedSMul ‚Ñù K :=\n  OrderedSMul.mk' fun a b r hab hr => by\n    replace hab := hab.le\n    rw [RCLike.le_iff_re_im] at hab\n    rw [RCLike.le_iff_re_im, smul_re, smul_re, smul_im, smul_im]\n    exact hab.imp (fun h => mul_le_mul_of_nonneg_left h hr.le) (congr_arg _)\n\n"}
{"name":"StarModule.instOrderedSMul","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù‚Å∏ : RCLike K\nA : Type u_3\ninst‚úù‚Å∑ : NonUnitalRing A\ninst‚úù‚Å∂ : StarRing A\ninst‚úù‚Åµ : PartialOrder A\ninst‚úù‚Å¥ : StarOrderedRing A\ninst‚úù¬≥ : Module K A\ninst‚úù¬≤ : StarModule K A\ninst‚úù¬π : IsScalarTower K A A\ninst‚úù : SMulCommClass K A A\n‚ä¢ OrderedSMul K A","decl":"/-- A star algebra over `K` has a scalar multiplication that respects the order. -/\nlemma _root_.StarModule.instOrderedSMul {A : Type*} [NonUnitalRing A] [StarRing A] [PartialOrder A]\n    [StarOrderedRing A] [Module K A] [StarModule K A] [IsScalarTower K A A] [SMulCommClass K A A] :\n    OrderedSMul K A where\n  smul_lt_smul_of_pos {_ _ _} hxy hc := StarModule.smul_lt_smul_of_pos hxy hc\n  lt_of_smul_lt_smul_of_pos {x y c} hxy hc := by\n    have : c‚Åª¬π ‚Ä¢ c ‚Ä¢ x < c‚Åª¬π ‚Ä¢ c ‚Ä¢ y :=\n      StarModule.smul_lt_smul_of_pos hxy (RCLike.inv_pos_of_pos hc)\n    simpa [smul_smul, inv_mul_cancel‚ÇÄ hc.ne'] using this\n\n"}
{"name":"RCLike.instOrderedSMulRealOfStarModuleOfIsScalarTowerOfSMulCommClass","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"A : Type u_3\ninst‚úù‚Å∑ : NonUnitalRing A\ninst‚úù‚Å∂ : StarRing A\ninst‚úù‚Åµ : PartialOrder A\ninst‚úù‚Å¥ : StarOrderedRing A\ninst‚úù¬≥ : Module Real A\ninst‚úù¬≤ : StarModule Real A\ninst‚úù¬π : IsScalarTower Real A A\ninst‚úù : SMulCommClass Real A A\n‚ä¢ OrderedSMul Real A","decl":"instance {A : Type*} [NonUnitalRing A] [StarRing A] [PartialOrder A] [StarOrderedRing A]\n    [Module ‚Ñù A] [StarModule ‚Ñù A] [IsScalarTower ‚Ñù A A] [SMulCommClass ‚Ñù A A] :\n    OrderedSMul ‚Ñù A :=\n  StarModule.instOrderedSMul\n\n"}
{"name":"RCLike.ofReal_mul_pos_iff","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nx : Real\nz : K\n‚ä¢ Iff (LT.lt 0 (HMul.hMul (‚Üëx) z)) (Or (And (LT.lt x 0) (LT.lt z 0)) (And (LT.lt 0 x) (LT.lt 0 z)))","decl":"theorem ofReal_mul_pos_iff (x : ‚Ñù) (z : K) :\n    0 < x * z ‚Üî (x < 0 ‚àß z < 0) ‚à® (0 < x ‚àß 0 < z) := by\n  simp only [pos_iff (K := K), neg_iff (K := K), re_ofReal_mul, im_ofReal_mul]\n  obtain hx | hx | hx := lt_trichotomy x 0\n  ¬∑ simp only [mul_pos_iff, not_lt_of_gt hx, false_and, hx, true_and, false_or, mul_eq_zero, hx.ne,\n      or_false]\n  ¬∑ simp only [hx, zero_mul, lt_self_iff_false, false_and, false_or]\n  ¬∑ simp only [mul_pos_iff, hx, true_and, not_lt_of_gt hx, false_and, or_false, mul_eq_zero,\n      hx.ne', false_or]\n\n"}
{"name":"RCLike.ofReal_mul_neg_iff","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nx : Real\nz : K\n‚ä¢ Iff (LT.lt (HMul.hMul (‚Üëx) z) 0) (Or (And (LT.lt x 0) (LT.lt 0 z)) (And (LT.lt 0 x) (LT.lt z 0)))","decl":"theorem ofReal_mul_neg_iff (x : ‚Ñù) (z : K) :\n    x * z < 0 ‚Üî (x < 0 ‚àß 0 < z) ‚à® (0 < x ‚àß z < 0) := by\n  simpa only [mul_neg, neg_pos, neg_neg_iff_pos] using ofReal_mul_pos_iff x (-z)\n\n"}
{"name":"RCLike.re_to_real","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"x : Real\n‚ä¢ Eq (RCLike.re x) x","decl":"@[simp, rclike_simps]\ntheorem re_to_real {x : ‚Ñù} : reR x = x :=\n  rfl\n\n"}
{"name":"RCLike.im_to_real","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"x : Real\n‚ä¢ Eq (RCLike.im x) 0","decl":"@[simp, rclike_simps]\ntheorem im_to_real {x : ‚Ñù} : imR x = 0 :=\n  rfl\n\n"}
{"name":"RCLike.conj_to_real","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"x : Real\n‚ä¢ Eq ((starRingEnd Real) x) x","decl":"@[rclike_simps]\ntheorem conj_to_real {x : ‚Ñù} : conj x = x :=\n  rfl\n\n"}
{"name":"RCLike.I_to_real","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"‚ä¢ Eq RCLike.I 0","decl":"@[simp, rclike_simps]\ntheorem I_to_real : IR = 0 :=\n  rfl\n\n"}
{"name":"RCLike.normSq_to_real","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"x : Real\n‚ä¢ Eq (RCLike.normSq x) (HMul.hMul x x)","decl":"@[simp, rclike_simps]\ntheorem normSq_to_real {x : ‚Ñù} : normSq x = x * x := by simp [RCLike.normSq]\n\n"}
{"name":"RCLike.ofReal_real_eq_id","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"‚ä¢ Eq RCLike.ofReal id","decl":"@[simp]\ntheorem ofReal_real_eq_id : @ofReal ‚Ñù _ = id :=\n  rfl\n\n"}
{"name":"RCLike.reLm_coe","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\n‚ä¢ Eq ‚áëRCLike.reLm ‚áëRCLike.re","decl":"@[simp, rclike_simps]\ntheorem reLm_coe : (reLm : K ‚Üí ‚Ñù) = re :=\n  rfl\n\n"}
{"name":"RCLike.reCLM_coe","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\n‚ä¢ Eq (‚ÜëRCLike.reCLM) RCLike.reLm","decl":"@[simp, rclike_simps, norm_cast]\ntheorem reCLM_coe : ((reCLM : K ‚ÜíL[‚Ñù] ‚Ñù) : K ‚Üí‚Çó[‚Ñù] ‚Ñù) = reLm :=\n  rfl\n\n"}
{"name":"RCLike.reCLM_apply","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\n‚ä¢ Eq ‚áëRCLike.reCLM ‚áëRCLike.re","decl":"@[simp, rclike_simps]\ntheorem reCLM_apply : ((reCLM : K ‚ÜíL[‚Ñù] ‚Ñù) : K ‚Üí ‚Ñù) = re :=\n  rfl\n\n"}
{"name":"RCLike.continuous_re","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\n‚ä¢ Continuous ‚áëRCLike.re","decl":"@[continuity, fun_prop]\ntheorem continuous_re : Continuous (re : K ‚Üí ‚Ñù) :=\n  reCLM.continuous\n\n"}
{"name":"RCLike.imLm_coe","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\n‚ä¢ Eq ‚áëRCLike.imLm ‚áëRCLike.im","decl":"@[simp, rclike_simps]\ntheorem imLm_coe : (imLm : K ‚Üí ‚Ñù) = im :=\n  rfl\n\n"}
{"name":"RCLike.imCLM_coe","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\n‚ä¢ Eq (‚ÜëRCLike.imCLM) RCLike.imLm","decl":"@[simp, rclike_simps, norm_cast]\ntheorem imCLM_coe : ((imCLM : K ‚ÜíL[‚Ñù] ‚Ñù) : K ‚Üí‚Çó[‚Ñù] ‚Ñù) = imLm :=\n  rfl\n\n"}
{"name":"RCLike.imCLM_apply","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\n‚ä¢ Eq ‚áëRCLike.imCLM ‚áëRCLike.im","decl":"@[simp, rclike_simps]\ntheorem imCLM_apply : ((imCLM : K ‚ÜíL[‚Ñù] ‚Ñù) : K ‚Üí ‚Ñù) = im :=\n  rfl\n\n"}
{"name":"RCLike.continuous_im","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\n‚ä¢ Continuous ‚áëRCLike.im","decl":"@[continuity, fun_prop]\ntheorem continuous_im : Continuous (im : K ‚Üí ‚Ñù) :=\n  imCLM.continuous\n\n"}
{"name":"RCLike.conjAe_coe","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\n‚ä¢ Eq ‚áëRCLike.conjAe ‚áë(starRingEnd K)","decl":"@[simp, rclike_simps]\ntheorem conjAe_coe : (conjAe : K ‚Üí K) = conj :=\n  rfl\n\n"}
{"name":"RCLike.conjLIE_apply","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\n‚ä¢ Eq ‚áëRCLike.conjLIE ‚áë(starRingEnd K)","decl":"@[simp, rclike_simps]\ntheorem conjLIE_apply : (conjLIE : K ‚Üí K) = conj :=\n  rfl\n\n"}
{"name":"RCLike.conjCLE_coe","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\n‚ä¢ Eq RCLike.conjCLE.toLinearEquiv RCLike.conjAe.toLinearEquiv","decl":"@[simp, rclike_simps]\ntheorem conjCLE_coe : (@conjCLE K _).toLinearEquiv = conjAe.toLinearEquiv :=\n  rfl\n\n"}
{"name":"RCLike.conjCLE_apply","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\n‚ä¢ Eq ‚áëRCLike.conjCLE ‚áë(starRingEnd K)","decl":"@[simp, rclike_simps]\ntheorem conjCLE_apply : (conjCLE : K ‚Üí K) = conj :=\n  rfl\n\n"}
{"name":"RCLike.instContinuousStar","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\n‚ä¢ ContinuousStar K","decl":"instance (priority := 100) : ContinuousStar K :=\n  ‚ü®conjLIE.continuous‚ü©\n\n"}
{"name":"RCLike.continuous_conj","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\n‚ä¢ Continuous ‚áë(starRingEnd K)","decl":"@[continuity]\ntheorem continuous_conj : Continuous (conj : K ‚Üí K) :=\n  continuous_star\n\n"}
{"name":"RCLike.ofRealAm_coe","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\n‚ä¢ Eq (‚áëRCLike.ofRealAm) RCLike.ofReal","decl":"@[simp, rclike_simps]\ntheorem ofRealAm_coe : (ofRealAm : ‚Ñù ‚Üí K) = ofReal :=\n  rfl\n\n"}
{"name":"RCLike.ofRealLI_apply","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\n‚ä¢ Eq (‚áëRCLike.ofRealLI) RCLike.ofReal","decl":"@[simp, rclike_simps]\ntheorem ofRealLI_apply : (ofRealLI : ‚Ñù ‚Üí K) = ofReal :=\n  rfl\n\n"}
{"name":"RCLike.ofRealCLM_coe","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\n‚ä¢ Eq (‚ÜëRCLike.ofRealCLM) RCLike.ofRealAm.toLinearMap","decl":"@[simp, rclike_simps]\ntheorem ofRealCLM_coe : (@ofRealCLM K _ : ‚Ñù ‚Üí‚Çó[‚Ñù] K) = ofRealAm.toLinearMap :=\n  rfl\n\n"}
{"name":"RCLike.ofRealCLM_apply","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\n‚ä¢ Eq (‚áëRCLike.ofRealCLM) RCLike.ofReal","decl":"@[simp, rclike_simps]\ntheorem ofRealCLM_apply : (ofRealCLM : ‚Ñù ‚Üí K) = ofReal :=\n  rfl\n\n"}
{"name":"RCLike.continuous_ofReal","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\n‚ä¢ Continuous RCLike.ofReal","decl":"@[continuity, fun_prop]\ntheorem continuous_ofReal : Continuous (ofReal : ‚Ñù ‚Üí K) :=\n  ofRealLI.continuous\n\n"}
{"name":"RCLike.continuous_normSq","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\n‚ä¢ Continuous ‚áëRCLike.normSq","decl":"@[continuity]\ntheorem continuous_normSq : Continuous (normSq : K ‚Üí ‚Ñù) :=\n  (continuous_re.mul continuous_re).add (continuous_im.mul continuous_im)\n\n"}
{"name":"RCLike.im_eq_zero","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nh : Eq RCLike.I 0\nz : K\n‚ä¢ Eq (RCLike.im z) 0","decl":"lemma im_eq_zero (h : I = (0 : K)) (z : K) : im z = 0 := by\n  rw [‚Üê re_add_im z, h]\n  simp\n\n"}
{"name":"RCLike.realRingEquiv_apply","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nh : Eq RCLike.I 0\na : K\n‚ä¢ Eq ((RCLike.realRingEquiv h) a) (RCLike.re a)","decl":"/-- The natural isomorphism between `ùïú` satisfying `RCLike ùïú` and `‚Ñù` when `RCLike.I = 0`. -/\n@[simps]\ndef realRingEquiv (h : I = (0 : K)) : K ‚âÉ+* ‚Ñù where\n  toFun := re\n  invFun := (‚Üë)\n  left_inv x := by nth_rw 2 [‚Üê re_add_im x]; simp [h]\n  right_inv := ofReal_re\n  map_add' := map_add re\n  map_mul' := by simp [im_eq_zero h]\n\n"}
{"name":"RCLike.realRingEquiv_symm_apply","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nh : Eq RCLike.I 0\na‚úù : Real\n‚ä¢ Eq ((RCLike.realRingEquiv h).symm a‚úù) ‚Üëa‚úù","decl":"/-- The natural isomorphism between `ùïú` satisfying `RCLike ùïú` and `‚Ñù` when `RCLike.I = 0`. -/\n@[simps]\ndef realRingEquiv (h : I = (0 : K)) : K ‚âÉ+* ‚Ñù where\n  toFun := re\n  invFun := (‚Üë)\n  left_inv x := by nth_rw 2 [‚Üê re_add_im x]; simp [h]\n  right_inv := ofReal_re\n  map_add' := map_add re\n  map_mul' := by simp [im_eq_zero h]\n\n"}
{"name":"RCLike.realLinearIsometryEquiv_apply","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nh : Eq RCLike.I 0\na‚úù : K\n‚ä¢ Eq ((RCLike.realLinearIsometryEquiv h) a‚úù) ((RCLike.realRingEquiv h).toFun a‚úù)","decl":"/-- The natural `‚Ñù`-linear isometry equivalence between `ùïú` satisfying `RCLike ùïú` and `‚Ñù` when\n`RCLike.I = 0`. -/\n@[simps]\nnoncomputable def realLinearIsometryEquiv (h : I = (0 : K)) : K ‚âÉ‚Çó·µ¢[‚Ñù] ‚Ñù where\n  map_smul' := smul_re\n  norm_map' z := by rw [‚Üê re_add_im z]; simp [- re_add_im, h]\n  __ := realRingEquiv h\n\n"}
{"name":"RCLike.realLinearIsometryEquiv_symm_apply","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù : RCLike K\nh : Eq RCLike.I 0\na‚úù : Real\n‚ä¢ Eq ((RCLike.realLinearIsometryEquiv h).symm a‚úù) ((RCLike.realRingEquiv h).invFun a‚úù)","decl":"/-- The natural `‚Ñù`-linear isometry equivalence between `ùïú` satisfying `RCLike ùïú` and `‚Ñù` when\n`RCLike.I = 0`. -/\n@[simps]\nnoncomputable def realLinearIsometryEquiv (h : I = (0 : K)) : K ‚âÉ‚Çó·µ¢[‚Ñù] ‚Ñù where\n  map_smul' := smul_re\n  norm_map' z := by rw [‚Üê re_add_im z]; simp [- re_add_im, h]\n  __ := realRingEquiv h\n\n"}
{"name":"AddChar.inv_apply_eq_conj","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù¬≤ : RCLike K\nG : Type u_3\ninst‚úù¬π : Finite G\ninst‚úù : AddLeftCancelMonoid G\nœà : AddChar G K\nx : G\n‚ä¢ Eq (Inv.inv (œà x)) ((starRingEnd K) (œà x))","decl":"lemma inv_apply_eq_conj [AddLeftCancelMonoid G] (œà : AddChar G K) (x : G) : (œà x)‚Åª¬π = conj (œà x) :=\n  RCLike.inv_eq_conj <| norm_apply _ _\n\n"}
{"name":"AddChar.map_neg_eq_conj","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"K : Type u_1\ninst‚úù¬≤ : RCLike K\nG : Type u_3\ninst‚úù¬π : Finite G\ninst‚úù : AddCommGroup G\nœà : AddChar G K\nx : G\n‚ä¢ Eq (œà (Neg.neg x)) ((starRingEnd K) (œà x))","decl":"lemma map_neg_eq_conj [AddCommGroup G] (œà : AddChar G K) (x : G) : œà (-x) = conj (œà x) := by\n  rw [map_neg_eq_inv, inv_apply_eq_conj]\n\n"}
{"name":"IsRCLikeNormedField.out","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"ùïú : Type u_3\nhk : NormedField ùïú\nself : IsRCLikeNormedField ùïú\n‚ä¢ Exists fun h => Eq hk DenselyNormedField.toNormedField","decl":"/-- A mixin over a normed field, saying that the norm field structure is the same as `‚Ñù` or `‚ÑÇ`.\nTo endow such a field with a compatible `RCLike` structure in a proof, use\n`letI := IsRCLikeNormedField.rclike ùïú`.-/\nclass IsRCLikeNormedField (ùïú : Type*) [hk : NormedField ùïú] : Prop where\n  out : ‚àÉ h : RCLike ùïú, hk = h.toNormedField\n\n"}
{"name":"instIsRCLikeNormedField","module":"Mathlib.Analysis.RCLike.Basic","initialProofState":"ùïú : Type u_3\nh : RCLike ùïú\n‚ä¢ IsRCLikeNormedField ùïú","decl":"instance (priority := 100) (ùïú : Type*) [h : RCLike ùïú] : IsRCLikeNormedField ùïú := ‚ü®‚ü®h, rfl‚ü©‚ü©\n\n"}
