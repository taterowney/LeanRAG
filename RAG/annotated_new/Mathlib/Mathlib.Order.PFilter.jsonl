{"name":"Order.PFilter.mk.sizeOf_spec","module":"Mathlib.Order.PFilter","initialProofState":"P : Type u_1\ninst✝¹ : Preorder P\ninst✝ : SizeOf P\ndual : Order.Ideal (OrderDual P)\n⊢ Eq (SizeOf.sizeOf { dual := dual }) (HAdd.hAdd 1 (SizeOf.sizeOf dual))","decl":"/-- A filter on a preorder `P` is a subset of `P` that is\n  - nonempty\n  - downward directed\n  - upward closed. -/\nstructure PFilter (P : Type*) [Preorder P] where\n  dual : Ideal Pᵒᵈ\n\n"}
{"name":"Order.PFilter.mk.inj","module":"Mathlib.Order.PFilter","initialProofState":"P : Type u_1\ninst✝ : Preorder P\ndual✝ dual : Order.Ideal (OrderDual P)\nx✝ : Eq { dual := dual✝ } { dual := dual }\n⊢ Eq dual✝ dual","decl":"/-- A filter on a preorder `P` is a subset of `P` that is\n  - nonempty\n  - downward directed\n  - upward closed. -/\nstructure PFilter (P : Type*) [Preorder P] where\n  dual : Ideal Pᵒᵈ\n\n"}
{"name":"Order.PFilter.mk.injEq","module":"Mathlib.Order.PFilter","initialProofState":"P : Type u_1\ninst✝ : Preorder P\ndual✝ dual : Order.Ideal (OrderDual P)\n⊢ Eq (Eq { dual := dual✝ } { dual := dual }) (Eq dual✝ dual)","decl":"/-- A filter on a preorder `P` is a subset of `P` that is\n  - nonempty\n  - downward directed\n  - upward closed. -/\nstructure PFilter (P : Type*) [Preorder P] where\n  dual : Ideal Pᵒᵈ\n\n"}
{"name":"Order.IsPFilter.of_def","module":"Mathlib.Order.PFilter","initialProofState":"P : Type u_1\ninst✝ : Preorder P\nF : Set P\nnonempty : F.Nonempty\ndirected : DirectedOn (fun x1 x2 => GE.ge x1 x2) F\nmem_of_le : ∀ {x y : P}, LE.le x y → Membership.mem F x → Membership.mem F y\n⊢ Order.IsPFilter F","decl":"theorem IsPFilter.of_def [Preorder P] {F : Set P} (nonempty : F.Nonempty)\n    (directed : DirectedOn (· ≥ ·) F) (mem_of_le : ∀ {x y : P}, x ≤ y → x ∈ F → y ∈ F) :\n    IsPFilter F :=\n  ⟨fun _ _ _ _ => mem_of_le ‹_› ‹_›, nonempty, directed⟩\n\n"}
{"name":"Order.PFilter.isPFilter","module":"Mathlib.Order.PFilter","initialProofState":"P : Type u_1\ninst✝ : Preorder P\nF : Order.PFilter P\n⊢ Order.IsPFilter ↑F","decl":"theorem isPFilter : IsPFilter (F : Set P) := F.dual.isIdeal\n\n"}
{"name":"Order.PFilter.nonempty","module":"Mathlib.Order.PFilter","initialProofState":"P : Type u_1\ninst✝ : Preorder P\nF : Order.PFilter P\n⊢ (↑F).Nonempty","decl":"protected theorem nonempty : (F : Set P).Nonempty := F.dual.nonempty\n\n"}
{"name":"Order.PFilter.directed","module":"Mathlib.Order.PFilter","initialProofState":"P : Type u_1\ninst✝ : Preorder P\nF : Order.PFilter P\n⊢ DirectedOn (fun x1 x2 => GE.ge x1 x2) ↑F","decl":"theorem directed : DirectedOn (· ≥ ·) (F : Set P) := F.dual.directed\n\n"}
{"name":"Order.PFilter.mem_of_le","module":"Mathlib.Order.PFilter","initialProofState":"P : Type u_1\ninst✝ : Preorder P\nx y : P\nF : Order.PFilter P\na✝¹ : LE.le x y\na✝ : Membership.mem F x\n⊢ Membership.mem F y","decl":"theorem mem_of_le {F : PFilter P} : x ≤ y → x ∈ F → y ∈ F := fun h => F.dual.lower h\n\n"}
{"name":"Order.PFilter.ext_iff","module":"Mathlib.Order.PFilter","initialProofState":"P : Type u_1\ninst✝ : Preorder P\ns t : Order.PFilter P\n⊢ Iff (Eq s t) (Eq ↑s ↑t)","decl":"/-- Two filters are equal when their underlying sets are equal. -/\n@[ext]\ntheorem ext (h : (s : Set P) = t) : s = t := SetLike.ext' h\n\n"}
{"name":"Order.PFilter.ext","module":"Mathlib.Order.PFilter","initialProofState":"P : Type u_1\ninst✝ : Preorder P\ns t : Order.PFilter P\nh : Eq ↑s ↑t\n⊢ Eq s t","decl":"/-- Two filters are equal when their underlying sets are equal. -/\n@[ext]\ntheorem ext (h : (s : Set P) = t) : s = t := SetLike.ext' h\n\n"}
{"name":"Order.PFilter.mem_of_mem_of_le","module":"Mathlib.Order.PFilter","initialProofState":"P : Type u_1\ninst✝ : Preorder P\nx : P\nF G : Order.PFilter P\nhx : Membership.mem F x\nhle : LE.le F G\n⊢ Membership.mem G x","decl":"@[trans]\ntheorem mem_of_mem_of_le {F G : PFilter P} (hx : x ∈ F) (hle : F ≤ G) : x ∈ G :=\n  hle hx\n\n"}
{"name":"Order.PFilter.mem_mk","module":"Mathlib.Order.PFilter","initialProofState":"P : Type u_1\ninst✝ : Preorder P\nx : P\nI : Order.Ideal (OrderDual P)\n⊢ Iff (Membership.mem { dual := I } x) (Membership.mem I (OrderDual.toDual x))","decl":"@[simp]\ntheorem mem_mk (x : P) (I : Ideal Pᵒᵈ) : x ∈ (⟨I⟩ : PFilter P) ↔ toDual x ∈ I :=\n  Iff.rfl\n\n"}
{"name":"Order.PFilter.principal_le_iff","module":"Mathlib.Order.PFilter","initialProofState":"P : Type u_1\ninst✝ : Preorder P\nx : P\nF : Order.PFilter P\n⊢ Iff (LE.le (Order.PFilter.principal x) F) (Membership.mem F x)","decl":"@[simp]\ntheorem principal_le_iff {F : PFilter P} : principal x ≤ F ↔ x ∈ F :=\n  Ideal.principal_le_iff (x := toDual x)\n\n"}
{"name":"Order.PFilter.mem_principal","module":"Mathlib.Order.PFilter","initialProofState":"P : Type u_1\ninst✝ : Preorder P\nx y : P\n⊢ Iff (Membership.mem (Order.PFilter.principal y) x) (LE.le y x)","decl":"@[simp] theorem mem_principal : x ∈ principal y ↔ y ≤ x := Iff.rfl\n\n"}
{"name":"Order.PFilter.principal_le_principal_iff","module":"Mathlib.Order.PFilter","initialProofState":"P : Type u_1\ninst✝ : Preorder P\np q : P\n⊢ Iff (LE.le (Order.PFilter.principal q) (Order.PFilter.principal p)) (LE.le p q)","decl":"theorem principal_le_principal_iff {p q : P} : principal q ≤ principal p ↔ p ≤ q := by simp\n\n-- defeq abuse\n"}
{"name":"Order.PFilter.antitone_principal","module":"Mathlib.Order.PFilter","initialProofState":"P : Type u_1\ninst✝ : Preorder P\n⊢ Antitone Order.PFilter.principal","decl":"theorem antitone_principal : Antitone (principal : P → PFilter P) := fun _ _ =>\n  principal_le_principal_iff.2\n\n"}
{"name":"Order.PFilter.top_mem","module":"Mathlib.Order.PFilter","initialProofState":"P : Type u_1\ninst✝¹ : Preorder P\ninst✝ : OrderTop P\nF : Order.PFilter P\n⊢ Membership.mem F Top.top","decl":"/-- A specific witness of `pfilter.nonempty` when `P` has a top element. -/\n@[simp] theorem top_mem : ⊤ ∈ F := Ideal.bot_mem _\n\n"}
{"name":"Order.PFilter.inf_mem","module":"Mathlib.Order.PFilter","initialProofState":"P : Type u_1\ninst✝ : SemilatticeInf P\nx y : P\nF : Order.PFilter P\nhx : Membership.mem F x\nhy : Membership.mem F y\n⊢ Membership.mem F (Min.min x y)","decl":"/-- A specific witness of `pfilter.directed` when `P` has meets. -/\ntheorem inf_mem (hx : x ∈ F) (hy : y ∈ F) : x ⊓ y ∈ F :=\n  Ideal.sup_mem hx hy\n\n"}
{"name":"Order.PFilter.inf_mem_iff","module":"Mathlib.Order.PFilter","initialProofState":"P : Type u_1\ninst✝ : SemilatticeInf P\nx y : P\nF : Order.PFilter P\n⊢ Iff (Membership.mem F (Min.min x y)) (And (Membership.mem F x) (Membership.mem F y))","decl":"@[simp]\ntheorem inf_mem_iff : x ⊓ y ∈ F ↔ x ∈ F ∧ y ∈ F :=\n  Ideal.sup_mem_iff\n\n"}
{"name":"Order.PFilter.sInf_gc","module":"Mathlib.Order.PFilter","initialProofState":"P : Type u_1\ninst✝ : CompleteSemilatticeInf P\n⊢ GaloisConnection (fun x => OrderDual.toDual (Order.PFilter.principal x)) fun F => InfSet.sInf ↑(OrderDual.ofDual F)","decl":"theorem sInf_gc :\n    GaloisConnection (fun x => toDual (principal x)) fun F => sInf (ofDual F : PFilter P) :=\n  fun x F => by simp only [le_sInf_iff, SetLike.mem_coe, toDual_le, SetLike.le_def, mem_principal]\n\n"}
