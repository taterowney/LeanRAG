{"name":"ErgodicVAdd.toVAddInvariantMeasure","module":"Mathlib.Dynamics.Ergodic.Action.Basic","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝ : VAdd G α\nx✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nself : ErgodicVAdd G α μ\n⊢ MeasureTheory.VAddInvariantMeasure G α μ","decl":"/--\nAn additive group action of `G` on a space `α` with measure `μ` is called *ergodic*,\nif for any (null) measurable set `s`,\nif it is a.e.-invariant under each scalar addition `(g +ᵥ ·)`, `g : G`,\nthen it is either null or conull.\n-/\nclass ErgodicVAdd (G α : Type*) [VAdd G α] {_ : MeasurableSpace α} (μ : Measure α)\n    extends VAddInvariantMeasure G α μ : Prop where\n  aeconst_of_forall_preimage_vadd_ae_eq {s : Set α} : MeasurableSet s →\n    (∀ g : G, (g +ᵥ ·) ⁻¹' s =ᵐ[μ] s) → EventuallyConst s (ae μ)\n\n"}
{"name":"ErgodicVAdd.aeconst_of_forall_preimage_vadd_ae_eq","module":"Mathlib.Dynamics.Ergodic.Action.Basic","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝ : VAdd G α\nx✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nself : ErgodicVAdd G α μ\ns : Set α\na✝¹ : MeasurableSet s\na✝ : ∀ (g : G), (MeasureTheory.ae μ).EventuallyEq (Set.preimage (fun x => HVAdd.hVAdd g x) s) s\n⊢ Filter.EventuallyConst s (MeasureTheory.ae μ)","decl":"/--\nAn additive group action of `G` on a space `α` with measure `μ` is called *ergodic*,\nif for any (null) measurable set `s`,\nif it is a.e.-invariant under each scalar addition `(g +ᵥ ·)`, `g : G`,\nthen it is either null or conull.\n-/\nclass ErgodicVAdd (G α : Type*) [VAdd G α] {_ : MeasurableSpace α} (μ : Measure α)\n    extends VAddInvariantMeasure G α μ : Prop where\n  aeconst_of_forall_preimage_vadd_ae_eq {s : Set α} : MeasurableSet s →\n    (∀ g : G, (g +ᵥ ·) ⁻¹' s =ᵐ[μ] s) → EventuallyConst s (ae μ)\n\n"}
{"name":"ErgodicSMul.toSMulInvariantMeasure","module":"Mathlib.Dynamics.Ergodic.Action.Basic","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝ : SMul G α\nx✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nself : ErgodicSMul G α μ\n⊢ MeasureTheory.SMulInvariantMeasure G α μ","decl":"/--\nA group action of `G` on a space `α` with measure `μ` is called *ergodic*,\nif for any (null) measurable set `s`,\nif it is a.e.-invariant under each scalar multiplication `(g • ·)`, `g : G`,\nthen it is either null or conull.\n-/\n@[to_additive, mk_iff]\nclass ErgodicSMul (G α : Type*) [SMul G α] {_ : MeasurableSpace α} (μ : Measure α)\n    extends SMulInvariantMeasure G α μ : Prop where\n  aeconst_of_forall_preimage_smul_ae_eq {s : Set α} : MeasurableSet s →\n    (∀ g : G, (g • ·) ⁻¹' s =ᵐ[μ] s) → EventuallyConst s (ae μ)\n\n"}
{"name":"ergodicSMul_iff","module":"Mathlib.Dynamics.Ergodic.Action.Basic","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝ : SMul G α\nx✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\n⊢ Iff (ErgodicSMul G α μ) (And (MeasureTheory.SMulInvariantMeasure G α μ) (∀ {s : Set α}, MeasurableSet s → (∀ (g : G), (MeasureTheory.ae μ).EventuallyEq (Set.preimage (fun x => HSMul.hSMul g x) s) s) → Filter.EventuallyConst s (MeasureTheory.ae μ)))","decl":"/--\nA group action of `G` on a space `α` with measure `μ` is called *ergodic*,\nif for any (null) measurable set `s`,\nif it is a.e.-invariant under each scalar multiplication `(g • ·)`, `g : G`,\nthen it is either null or conull.\n-/\n@[to_additive, mk_iff]\nclass ErgodicSMul (G α : Type*) [SMul G α] {_ : MeasurableSpace α} (μ : Measure α)\n    extends SMulInvariantMeasure G α μ : Prop where\n  aeconst_of_forall_preimage_smul_ae_eq {s : Set α} : MeasurableSet s →\n    (∀ g : G, (g • ·) ⁻¹' s =ᵐ[μ] s) → EventuallyConst s (ae μ)\n\n"}
{"name":"ErgodicSMul.aeconst_of_forall_preimage_smul_ae_eq","module":"Mathlib.Dynamics.Ergodic.Action.Basic","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝ : SMul G α\nx✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nself : ErgodicSMul G α μ\ns : Set α\na✝¹ : MeasurableSet s\na✝ : ∀ (g : G), (MeasureTheory.ae μ).EventuallyEq (Set.preimage (fun x => HSMul.hSMul g x) s) s\n⊢ Filter.EventuallyConst s (MeasureTheory.ae μ)","decl":"/--\nA group action of `G` on a space `α` with measure `μ` is called *ergodic*,\nif for any (null) measurable set `s`,\nif it is a.e.-invariant under each scalar multiplication `(g • ·)`, `g : G`,\nthen it is either null or conull.\n-/\n@[to_additive, mk_iff]\nclass ErgodicSMul (G α : Type*) [SMul G α] {_ : MeasurableSpace α} (μ : Measure α)\n    extends SMulInvariantMeasure G α μ : Prop where\n  aeconst_of_forall_preimage_smul_ae_eq {s : Set α} : MeasurableSet s →\n    (∀ g : G, (g • ·) ⁻¹' s =ᵐ[μ] s) → EventuallyConst s (ae μ)\n\n"}
{"name":"ergodicVAdd_iff","module":"Mathlib.Dynamics.Ergodic.Action.Basic","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝ : VAdd G α\nx✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\n⊢ Iff (ErgodicVAdd G α μ) (And (MeasureTheory.VAddInvariantMeasure G α μ) (∀ {s : Set α}, MeasurableSet s → (∀ (g : G), (MeasureTheory.ae μ).EventuallyEq (Set.preimage (fun x => HVAdd.hVAdd g x) s) s) → Filter.EventuallyConst s (MeasureTheory.ae μ)))","decl":"attribute [to_additive] ergodicSMul_iff\n\n"}
{"name":"MeasureTheory.aeconst_of_forall_preimage_smul_ae_eq","module":"Mathlib.Dynamics.Ergodic.Action.Basic","initialProofState":"G : Type u_1\nα : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : SMul G α\ninst✝ : ErgodicSMul G α μ\ns : Set α\nhm : MeasureTheory.NullMeasurableSet s μ\nh : ∀ (g : G), (MeasureTheory.ae μ).EventuallyEq (Set.preimage (fun x => HSMul.hSMul g x) s) s\n⊢ Filter.EventuallyConst s (MeasureTheory.ae μ)","decl":"@[to_additive]\ntheorem aeconst_of_forall_preimage_smul_ae_eq [SMul G α] [ErgodicSMul G α μ] {s : Set α}\n    (hm : NullMeasurableSet s μ) (h : ∀ g : G, (g • ·) ⁻¹' s =ᵐ[μ] s) :\n    EventuallyConst s (ae μ) := by\n  rcases hm with ⟨t, htm, hst⟩\n  refine .congr ?_ hst.symm\n  refine ErgodicSMul.aeconst_of_forall_preimage_smul_ae_eq htm fun g : G ↦ ?_\n  refine .trans (.trans ?_ (h g)) hst\n  exact tendsto_smul_ae _ _ hst.symm\n\n"}
{"name":"MeasureTheory.aeconst_of_forall_preimage_vadd_ae_eq","module":"Mathlib.Dynamics.Ergodic.Action.Basic","initialProofState":"G : Type u_1\nα : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : VAdd G α\ninst✝ : ErgodicVAdd G α μ\ns : Set α\nhm : MeasureTheory.NullMeasurableSet s μ\nh : ∀ (g : G), (MeasureTheory.ae μ).EventuallyEq (Set.preimage (fun x => HVAdd.hVAdd g x) s) s\n⊢ Filter.EventuallyConst s (MeasureTheory.ae μ)","decl":"@[to_additive]\ntheorem aeconst_of_forall_preimage_smul_ae_eq [SMul G α] [ErgodicSMul G α μ] {s : Set α}\n    (hm : NullMeasurableSet s μ) (h : ∀ g : G, (g • ·) ⁻¹' s =ᵐ[μ] s) :\n    EventuallyConst s (ae μ) := by\n  rcases hm with ⟨t, htm, hst⟩\n  refine .congr ?_ hst.symm\n  refine ErgodicSMul.aeconst_of_forall_preimage_smul_ae_eq htm fun g : G ↦ ?_\n  refine .trans (.trans ?_ (h g)) hst\n  exact tendsto_smul_ae _ _ hst.symm\n\n"}
{"name":"MeasureTheory.aeconst_of_forall_vadd_ae_eq","module":"Mathlib.Dynamics.Ergodic.Action.Basic","initialProofState":"G : Type u_1\nα : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝² : AddGroup G\ninst✝¹ : AddAction G α\ninst✝ : ErgodicVAdd G α μ\ns : Set α\nhm : MeasureTheory.NullMeasurableSet s μ\nh : ∀ (g : G), (MeasureTheory.ae μ).EventuallyEq (HVAdd.hVAdd g s) s\n⊢ Filter.EventuallyConst s (MeasureTheory.ae μ)","decl":"@[to_additive]\ntheorem aeconst_of_forall_smul_ae_eq (hm : NullMeasurableSet s μ) (h : ∀ g : G, g • s =ᵐ[μ] s) :\n    EventuallyConst s (ae μ) :=\n  aeconst_of_forall_preimage_smul_ae_eq G hm fun g ↦ by\n    simpa only [preimage_smul] using h g⁻¹\n\n"}
{"name":"MeasureTheory.aeconst_of_forall_smul_ae_eq","module":"Mathlib.Dynamics.Ergodic.Action.Basic","initialProofState":"G : Type u_1\nα : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝² : Group G\ninst✝¹ : MulAction G α\ninst✝ : ErgodicSMul G α μ\ns : Set α\nhm : MeasureTheory.NullMeasurableSet s μ\nh : ∀ (g : G), (MeasureTheory.ae μ).EventuallyEq (HSMul.hSMul g s) s\n⊢ Filter.EventuallyConst s (MeasureTheory.ae μ)","decl":"@[to_additive]\ntheorem aeconst_of_forall_smul_ae_eq (hm : NullMeasurableSet s μ) (h : ∀ g : G, g • s =ᵐ[μ] s) :\n    EventuallyConst s (ae μ) :=\n  aeconst_of_forall_preimage_smul_ae_eq G hm fun g ↦ by\n    simpa only [preimage_smul] using h g⁻¹\n\n"}
{"name":"MulAction.aeconst_of_aestabilizer_eq_top","module":"Mathlib.Dynamics.Ergodic.Action.Basic","initialProofState":"G : Type u_1\nα : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝² : Group G\ninst✝¹ : MulAction G α\ninst✝ : ErgodicSMul G α μ\ns : Set α\nhm : MeasureTheory.NullMeasurableSet s μ\nh : Eq (MulAction.aestabilizer G μ s) Top.top\n⊢ Filter.EventuallyConst s (MeasureTheory.ae μ)","decl":"@[to_additive]\ntheorem _root_.MulAction.aeconst_of_aestabilizer_eq_top\n    (hm : NullMeasurableSet s μ) (h : aestabilizer G μ s = ⊤) : EventuallyConst s (ae μ) :=\n  aeconst_of_forall_smul_ae_eq G hm <| (Subgroup.eq_top_iff' _).1 h\n\n"}
{"name":"AddAction.aeconst_of_aestabilizer_eq_top","module":"Mathlib.Dynamics.Ergodic.Action.Basic","initialProofState":"G : Type u_1\nα : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝² : AddGroup G\ninst✝¹ : AddAction G α\ninst✝ : ErgodicVAdd G α μ\ns : Set α\nhm : MeasureTheory.NullMeasurableSet s μ\nh : Eq (AddAction.aestabilizer G μ s) Top.top\n⊢ Filter.EventuallyConst s (MeasureTheory.ae μ)","decl":"@[to_additive]\ntheorem _root_.MulAction.aeconst_of_aestabilizer_eq_top\n    (hm : NullMeasurableSet s μ) (h : aestabilizer G μ s = ⊤) : EventuallyConst s (ae μ) :=\n  aeconst_of_forall_smul_ae_eq G hm <| (Subgroup.eq_top_iff' _).1 h\n\n"}
{"name":"ErgodicSMul.of_aestabilizer","module":"Mathlib.Dynamics.Ergodic.Action.Basic","initialProofState":"G : Type u_1\nα : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝² : Group G\ninst✝¹ : MulAction G α\ninst✝ : MeasureTheory.SMulInvariantMeasure G α μ\nh : ∀ (s : Set α), MeasurableSet s → Eq (MulAction.aestabilizer G μ s) Top.top → Filter.EventuallyConst s (MeasureTheory.ae μ)\n⊢ ErgodicSMul G α μ","decl":"theorem _root_.ErgodicSMul.of_aestabilizer [Group G] [MulAction G α] [SMulInvariantMeasure G α μ]\n    (h : ∀ s, MeasurableSet s → aestabilizer G μ s = ⊤ → EventuallyConst s (ae μ)) :\n    ErgodicSMul G α μ :=\n  ⟨fun hm hs ↦ h _ hm <| (Subgroup.eq_top_iff' _).2 fun g ↦ by\n    simpa only [preimage_smul_inv] using hs g⁻¹⟩\n\n"}
{"name":"MeasureTheory.ergodicSMul_iterateMulAct","module":"Mathlib.Dynamics.Ergodic.Action.Basic","initialProofState":"α : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → α\nhf : Measurable f\n⊢ Iff (ErgodicSMul (IterateMulAct f) α μ) (Ergodic f μ)","decl":"theorem ergodicSMul_iterateMulAct {f : α → α} (hf : Measurable f) :\n    ErgodicSMul (IterateMulAct f) α μ ↔ Ergodic f μ := by\n  simp only [ergodicSMul_iff, smulInvariantMeasure_iterateMulAct, hf]\n  refine ⟨fun ⟨h₁, h₂⟩ ↦ ⟨h₁, ⟨?_⟩⟩, fun h ↦ ⟨h.1, ?_⟩⟩\n  · intro s hm hs\n    refine h₂ hm fun n ↦ ?_\n    nth_rewrite 2 [← Function.IsFixedPt.preimage_iterate hs n.val]\n    rfl\n  · intro s hm hs\n    exact h.quasiErgodic.aeconst_set₀ hm.nullMeasurableSet <| hs (.mk 1)\n\n"}
