{"name":"Finset.natCast_card_filter","module":"Mathlib.Algebra.BigOperators.Ring","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝¹ : AddCommMonoidWithOne α\np : ι → Prop\ninst✝ : DecidablePred p\ns : Finset ι\n⊢ Eq (↑(Finset.filter (fun x => p x) s).card) (s.sum fun a => ite (p a) 1 0)","decl":"lemma natCast_card_filter (p) [DecidablePred p] (s : Finset ι) :\n    (#{x ∈ s | p x} : α) = ∑ a ∈ s, if p a then (1 : α) else 0 := by\n  rw [sum_ite, sum_const_zero, add_zero, sum_const, nsmul_one]\n\n"}
{"name":"Finset.sum_boole","module":"Mathlib.Algebra.BigOperators.Ring","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝¹ : AddCommMonoidWithOne α\np : ι → Prop\ninst✝ : DecidablePred p\ns : Finset ι\n⊢ Eq (s.sum fun x => ite (p x) 1 0) ↑(Finset.filter (fun x => p x) s).card","decl":"@[simp] lemma sum_boole (p) [DecidablePred p] (s : Finset ι) :\n    (∑ x ∈ s, if p x then 1 else 0 : α) = #{x ∈ s | p x} :=\n  (natCast_card_filter _ _).symm\n\n"}
{"name":"Finset.sum_mul","module":"Mathlib.Algebra.BigOperators.Ring","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝ : NonUnitalNonAssocSemiring α\ns : Finset ι\nf : ι → α\na : α\n⊢ Eq (HMul.hMul (s.sum fun i => f i) a) (s.sum fun i => HMul.hMul (f i) a)","decl":"lemma sum_mul (s : Finset ι) (f : ι → α) (a : α) :\n    (∑ i ∈ s, f i) * a = ∑ i ∈ s, f i * a := map_sum (AddMonoidHom.mulRight a) _ s\n\n"}
{"name":"Finset.mul_sum","module":"Mathlib.Algebra.BigOperators.Ring","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝ : NonUnitalNonAssocSemiring α\ns : Finset ι\nf : ι → α\na : α\n⊢ Eq (HMul.hMul a (s.sum fun i => f i)) (s.sum fun i => HMul.hMul a (f i))","decl":"lemma mul_sum (s : Finset ι) (f : ι → α) (a : α) :\n    a * ∑ i ∈ s, f i = ∑ i ∈ s, a * f i := map_sum (AddMonoidHom.mulLeft a) _ s\n\n"}
{"name":"Finset.sum_mul_sum","module":"Mathlib.Algebra.BigOperators.Ring","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝ : NonUnitalNonAssocSemiring α\nκ : Type u_7\ns : Finset ι\nt : Finset κ\nf : ι → α\ng : κ → α\n⊢ Eq (HMul.hMul (s.sum fun i => f i) (t.sum fun j => g j)) (s.sum fun i => t.sum fun j => HMul.hMul (f i) (g j))","decl":"lemma sum_mul_sum {κ : Type*} (s : Finset ι) (t : Finset κ) (f : ι → α) (g : κ → α) :\n    (∑ i ∈ s, f i) * ∑ j ∈ t, g j = ∑ i ∈ s, ∑ j ∈ t, f i * g j := by\n  simp_rw [sum_mul, ← mul_sum]\n\n"}
{"name":"Fintype.sum_mul_sum","module":"Mathlib.Algebra.BigOperators.Ring","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝² : NonUnitalNonAssocSemiring α\nκ : Type u_7\ninst✝¹ : Fintype ι\ninst✝ : Fintype κ\nf : ι → α\ng : κ → α\n⊢ Eq (HMul.hMul (Finset.univ.sum fun i => f i) (Finset.univ.sum fun j => g j)) (Finset.univ.sum fun i => Finset.univ.sum fun j => HMul.hMul (f i) (g j))","decl":"lemma _root_.Fintype.sum_mul_sum {κ : Type*} [Fintype ι] [Fintype κ] (f : ι → α) (g : κ → α) :\n    (∑ i, f i) * ∑ j, g j = ∑ i, ∑ j, f i * g j :=\n  Finset.sum_mul_sum _ _ _ _\n\n"}
{"name":"Commute.sum_right","module":"Mathlib.Algebra.BigOperators.Ring","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝ : NonUnitalNonAssocSemiring α\ns : Finset ι\nf : ι → α\nb : α\nh : ∀ (i : ι), Membership.mem s i → Commute b (f i)\n⊢ Commute b (s.sum fun i => f i)","decl":"lemma _root_.Commute.sum_right (s : Finset ι) (f : ι → α) (b : α)\n    (h : ∀ i ∈ s, Commute b (f i)) : Commute b (∑ i ∈ s, f i) :=\n  (Commute.multiset_sum_right _ _) fun b hb => by\n    obtain ⟨i, hi, rfl⟩ := Multiset.mem_map.mp hb\n    exact h _ hi\n\n"}
{"name":"Commute.sum_left","module":"Mathlib.Algebra.BigOperators.Ring","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝ : NonUnitalNonAssocSemiring α\ns : Finset ι\nf : ι → α\nb : α\nh : ∀ (i : ι), Membership.mem s i → Commute (f i) b\n⊢ Commute (s.sum fun i => f i) b","decl":"lemma _root_.Commute.sum_left (s : Finset ι) (f : ι → α) (b : α)\n    (h : ∀ i ∈ s, Commute (f i) b) : Commute (∑ i ∈ s, f i) b :=\n  ((Commute.sum_right _ _ _) fun _i hi => (h _ hi).symm).symm\n\n"}
{"name":"Finset.sum_range_succ_mul_sum_range_succ","module":"Mathlib.Algebra.BigOperators.Ring","initialProofState":"α : Type u_3\ninst✝ : NonUnitalNonAssocSemiring α\nm n : Nat\nf g : Nat → α\n⊢ Eq (HMul.hMul ((Finset.range (HAdd.hAdd m 1)).sum fun i => f i) ((Finset.range (HAdd.hAdd n 1)).sum fun i => g i)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HMul.hMul ((Finset.range m).sum fun i => f i) ((Finset.range n).sum fun i => g i)) (HMul.hMul (f m) ((Finset.range n).sum fun i => g i))) (HMul.hMul ((Finset.range m).sum fun i => f i) (g n))) (HMul.hMul (f m) (g n)))","decl":"lemma sum_range_succ_mul_sum_range_succ (m n : ℕ) (f g : ℕ → α) :\n    (∑ i ∈ range (m + 1), f i) * ∑ i ∈ range (n + 1), g i =\n      (∑ i ∈ range m, f i) * ∑ i ∈ range n, g i +\n        f m * ∑ i ∈ range n, g i + (∑ i ∈ range m, f i) * g n + f m * g n := by\n  simp only [add_mul, mul_add, add_assoc, sum_range_succ]\n\n"}
{"name":"Finset.dvd_sum","module":"Mathlib.Algebra.BigOperators.Ring","initialProofState":"ι : Type u_1\nα : Type u_3\ns : Finset ι\na : α\nf : ι → α\ninst✝ : NonUnitalSemiring α\nh : ∀ (i : ι), Membership.mem s i → Dvd.dvd a (f i)\n⊢ Dvd.dvd a (s.sum fun i => f i)","decl":"lemma dvd_sum (h : ∀ i ∈ s, a ∣ f i) : a ∣ ∑ i ∈ s, f i :=\n  Multiset.dvd_sum fun y hy => by rcases Multiset.mem_map.1 hy with ⟨x, hx, rfl⟩; exact h x hx\n\n"}
{"name":"Finset.sum_mul_boole","module":"Mathlib.Algebra.BigOperators.Ring","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝¹ : NonAssocSemiring α\ninst✝ : DecidableEq ι\ns : Finset ι\nf : ι → α\ni : ι\n⊢ Eq (s.sum fun j => HMul.hMul (f j) (ite (Eq i j) 1 0)) (ite (Membership.mem s i) (f i) 0)","decl":"lemma sum_mul_boole (s : Finset ι) (f : ι → α) (i : ι) :\n    ∑ j ∈ s, f j * ite (i = j) 1 0 = ite (i ∈ s) (f i) 0 := by simp\n\n"}
{"name":"Finset.sum_boole_mul","module":"Mathlib.Algebra.BigOperators.Ring","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝¹ : NonAssocSemiring α\ninst✝ : DecidableEq ι\ns : Finset ι\nf : ι → α\ni : ι\n⊢ Eq (s.sum fun j => HMul.hMul (ite (Eq i j) 1 0) (f j)) (ite (Membership.mem s i) (f i) 0)","decl":"lemma sum_boole_mul (s : Finset ι) (f : ι → α) (i : ι) :\n    ∑ j ∈ s, ite (i = j) 1 0 * f j = ite (i ∈ s) (f i) 0 := by simp\n\n"}
{"name":"Finset.prod_add_prod_eq","module":"Mathlib.Algebra.BigOperators.Ring","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝ : CommSemiring α\ns : Finset ι\ni : ι\nf g h : ι → α\nhi : Membership.mem s i\nh1 : Eq (HAdd.hAdd (g i) (h i)) (f i)\nh2 : ∀ (j : ι), Membership.mem s j → Ne j i → Eq (g j) (f j)\nh3 : ∀ (j : ι), Membership.mem s j → Ne j i → Eq (h j) (f j)\n⊢ Eq (HAdd.hAdd (s.prod fun i => g i) (s.prod fun i => h i)) (s.prod fun i => f i)","decl":"/-- If `f = g = h` everywhere but at `i`, where `f i = g i + h i`, then the product of `f` over `s`\n  is the sum of the products of `g` and `h`. -/\ntheorem prod_add_prod_eq {s : Finset ι} {i : ι} {f g h : ι → α} (hi : i ∈ s)\n    (h1 : g i + h i = f i) (h2 : ∀ j ∈ s, j ≠ i → g j = f j) (h3 : ∀ j ∈ s, j ≠ i → h j = f j) :\n    (∏ i ∈ s, g i) + ∏ i ∈ s, h i = ∏ i ∈ s, f i := by\n  classical\n    simp_rw [prod_eq_mul_prod_diff_singleton hi, ← h1, right_distrib]\n    congr 2 <;> apply prod_congr rfl <;> simpa\n\n"}
{"name":"Finset.prod_sum","module":"Mathlib.Algebra.BigOperators.Ring","initialProofState":"ι : Type u_1\nα : Type u_3\nκ : ι → Type u_6\ninst✝¹ : CommSemiring α\ninst✝ : DecidableEq ι\ns : Finset ι\nt : (i : ι) → Finset (κ i)\nf : (i : ι) → κ i → α\n⊢ Eq (s.prod fun a => (t a).sum fun b => f a b) ((s.pi t).sum fun p => s.attach.prod fun x => f (↑x) (p ↑x ⋯))","decl":"/-- The product over a sum can be written as a sum over the product of sets, `Finset.Pi`.\n  `Finset.prod_univ_sum` is an alternative statement when the product is over `univ`. -/\nlemma prod_sum (s : Finset ι) (t : ∀ i, Finset (κ i)) (f : ∀ i, κ i → α) :\n    ∏ a ∈ s, ∑ b ∈ t a, f a b = ∑ p ∈ s.pi t, ∏ x ∈ s.attach, f x.1 (p x.1 x.2) := by\n  classical\n  induction s using Finset.induction with\n  | empty => simp\n  | insert ha ih =>\n    rename_i a s\n    have h₁ : ∀ x ∈ t a, ∀ y ∈ t a, x ≠ y →\n      Disjoint (image (Pi.cons s a x) (pi s t)) (image (Pi.cons s a y) (pi s t)) := by\n      intro x _ y _ h\n      simp only [disjoint_iff_ne, mem_image]\n      rintro _ ⟨p₂, _, eq₂⟩ _ ⟨p₃, _, eq₃⟩ eq\n      have : Pi.cons s a x p₂ a (mem_insert_self _ _)\n              = Pi.cons s a y p₃ a (mem_insert_self _ _) := by rw [eq₂, eq₃, eq]\n      rw [Pi.cons_same, Pi.cons_same] at this\n      exact h this\n    rw [prod_insert ha, pi_insert ha, ih, sum_mul, sum_biUnion h₁]\n    refine sum_congr rfl fun b _ => ?_\n    have h₂ : ∀ p₁ ∈ pi s t, ∀ p₂ ∈ pi s t, Pi.cons s a b p₁ = Pi.cons s a b p₂ → p₁ = p₂ :=\n      fun p₁ _ p₂ _ eq => Pi.cons_injective ha eq\n    rw [sum_image h₂, mul_sum]\n    refine sum_congr rfl fun g _ => ?_\n    rw [attach_insert, prod_insert, prod_image]\n    · simp only [Pi.cons_same]\n      congr with ⟨v, hv⟩\n      congr\n      exact (Pi.cons_ne (by rintro rfl; exact ha hv)).symm\n    · exact fun _ _ _ _ => Subtype.eq ∘ Subtype.mk.inj\n    · simpa only [mem_image, mem_attach, Subtype.mk.injEq, true_and,\n        Subtype.exists, exists_prop, exists_eq_right] using ha\n\n"}
{"name":"Finset.prod_univ_sum","module":"Mathlib.Algebra.BigOperators.Ring","initialProofState":"ι : Type u_1\nα : Type u_3\nκ : ι → Type u_6\ninst✝² : CommSemiring α\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nt : (i : ι) → Finset (κ i)\nf : (i : ι) → κ i → α\n⊢ Eq (Finset.univ.prod fun i => (t i).sum fun j => f i j) ((Fintype.piFinset t).sum fun x => Finset.univ.prod fun i => f i (x i))","decl":"/-- The product over `univ` of a sum can be written as a sum over the product of sets,\n`Fintype.piFinset`. `Finset.prod_sum` is an alternative statement when the product is not\nover `univ`. -/\nlemma prod_univ_sum [Fintype ι] (t : ∀ i, Finset (κ i)) (f : ∀ i, κ i → α) :\n    ∏ i, ∑ j ∈ t i, f i j = ∑ x ∈ piFinset t, ∏ i, f i (x i) := by\n  simp only [prod_attach_univ, prod_sum, Finset.sum_univ_pi]\n\n"}
{"name":"Finset.sum_prod_piFinset","module":"Mathlib.Algebra.BigOperators.Ring","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝² : CommSemiring α\ninst✝¹ : DecidableEq ι\nκ : Type u_7\ninst✝ : Fintype ι\ns : Finset κ\ng : ι → κ → α\n⊢ Eq ((Fintype.piFinset fun x => s).sum fun f => Finset.univ.prod fun i => g i (f i)) (Finset.univ.prod fun i => s.sum fun j => g i j)","decl":"lemma sum_prod_piFinset {κ : Type*} [Fintype ι] (s : Finset κ) (g : ι → κ → α) :\n    ∑ f ∈ piFinset fun _ : ι ↦ s, ∏ i, g i (f i) = ∏ i, ∑ j ∈ s, g i j := by\n  rw [← prod_univ_sum]\n\n"}
{"name":"Finset.sum_pow'","module":"Mathlib.Algebra.BigOperators.Ring","initialProofState":"ι' : Type u_2\nα : Type u_3\ninst✝ : CommSemiring α\ns : Finset ι'\nf : ι' → α\nn : Nat\n⊢ Eq (HPow.hPow (s.sum fun a => f a) n) ((Fintype.piFinset fun _i => s).sum fun p => Finset.univ.prod fun i => f (p i))","decl":"lemma sum_pow' (s : Finset ι') (f : ι' → α) (n : ℕ) :\n    (∑ a ∈ s, f a) ^ n = ∑ p ∈ piFinset fun _i : Fin n ↦ s, ∏ i, f (p i) := by\n  convert @prod_univ_sum (Fin n) _ _ _ _ _ (fun _i ↦ s) fun _i d ↦ f d; simp\n\n"}
{"name":"Finset.prod_add","module":"Mathlib.Algebra.BigOperators.Ring","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝¹ : CommSemiring α\ninst✝ : DecidableEq ι\nf g : ι → α\ns : Finset ι\n⊢ Eq (s.prod fun i => HAdd.hAdd (f i) (g i)) (s.powerset.sum fun t => HMul.hMul (t.prod fun i => f i) ((SDiff.sdiff s t).prod fun i => g i))","decl":"/-- The product of `f a + g a` over all of `s` is the sum over the powerset of `s` of the product of\n`f` over a subset `t` times the product of `g` over the complement of `t`  -/\ntheorem prod_add (f g : ι → α) (s : Finset ι) :\n    ∏ i ∈ s, (f i + g i) = ∑ t ∈ s.powerset, (∏ i ∈ t, f i) * ∏ i ∈ s \\ t, g i := by\n  classical\n  calc\n    ∏ i ∈ s, (f i + g i) =\n        ∏ i ∈ s, ∑ p ∈ ({True, False} : Finset Prop), if p then f i else g i := by simp\n    _ = ∑ p ∈ (s.pi fun _ => {True, False} : Finset (∀ a ∈ s, Prop)),\n          ∏ a ∈ s.attach, if p a.1 a.2 then f a.1 else g a.1 := prod_sum _ _ _\n    _ = ∑ t ∈ s.powerset, (∏ a ∈ t, f a) * ∏ a ∈ s \\ t, g a :=\n      sum_bij'\n        (fun f _ ↦ {a ∈ s | ∃ h : a ∈ s, f a h})\n        (fun t _ a _ => a ∈ t)\n        (by simp)\n        (by simp [Classical.em])\n        (by simp_rw [mem_filter, funext_iff, eq_iff_iff, mem_pi, mem_insert]; tauto)\n        (by simp_rw [Finset.ext_iff, @mem_filter _ _ (id _), mem_powerset]; tauto)\n        (fun a _ ↦ by\n          simp only [prod_ite, filter_attach', prod_map, Function.Embedding.coeFn_mk,\n            Subtype.map_coe, id_eq, prod_attach, filter_congr_decidable]\n          congr 2 with x\n          simp only [mem_filter, mem_sdiff, not_and, not_exists, and_congr_right_iff]\n          tauto)\n\n"}
{"name":"Finset.prod_one_add","module":"Mathlib.Algebra.BigOperators.Ring","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝ : CommSemiring α\nf : ι → α\ns : Finset ι\n⊢ Eq (s.prod fun i => HAdd.hAdd 1 (f i)) (s.powerset.sum fun t => t.prod fun i => f i)","decl":"theorem prod_one_add {f : ι → α} (s : Finset ι) :\n    ∏ i ∈ s, (1 + f i) = ∑ t ∈ s.powerset, ∏ i ∈ t, f i := by\n  classical simp only [add_comm (1 : α), prod_add, prod_const_one, mul_one]\n\n"}
{"name":"Finset.prod_add_one","module":"Mathlib.Algebra.BigOperators.Ring","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝ : CommSemiring α\nf : ι → α\ns : Finset ι\n⊢ Eq (s.prod fun i => HAdd.hAdd (f i) 1) (s.powerset.sum fun t => t.prod fun i => f i)","decl":"theorem prod_add_one {f : ι → α} (s : Finset ι) :\n    ∏ i ∈ s, (f i + 1) = ∑ t ∈ s.powerset, ∏ i ∈ t, f i := by\n  classical simp only [prod_add, prod_const_one, mul_one]\n\n"}
{"name":"Finset.prod_add_ordered","module":"Mathlib.Algebra.BigOperators.Ring","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝¹ : CommSemiring α\ninst✝ : LinearOrder ι\ns : Finset ι\nf g : ι → α\n⊢ Eq (s.prod fun i => HAdd.hAdd (f i) (g i)) (HAdd.hAdd (s.prod fun i => f i) (s.sum fun i => HMul.hMul (HMul.hMul (g i) ((Finset.filter (fun j => LT.lt j i) s).prod fun j => HAdd.hAdd (f j) (g j))) ((Finset.filter (fun j => LT.lt i j) s).prod fun j => f j)))","decl":"/-- `∏ i, (f i + g i) = (∏ i, f i) + ∑ i, g i * (∏ j < i, f j + g j) * (∏ j > i, f j)`. -/\ntheorem prod_add_ordered [LinearOrder ι] (s : Finset ι) (f g : ι → α) :\n    ∏ i ∈ s, (f i + g i) =\n      (∏ i ∈ s, f i) +\n        ∑ i ∈ s, g i * (∏ j ∈ s with j < i, (f j + g j)) * ∏ j ∈ s with i < j, f j := by\n  refine Finset.induction_on_max s (by simp) ?_\n  clear s\n  intro a s ha ihs\n  have ha' : a ∉ s := fun ha' => lt_irrefl a (ha a ha')\n  rw [prod_insert ha', prod_insert ha', sum_insert ha', filter_insert, if_neg (lt_irrefl a),\n    filter_true_of_mem ha, ihs, add_mul, mul_add, mul_add, add_assoc]\n  congr 1\n  rw [add_comm]\n  congr 1\n  · rw [filter_false_of_mem, prod_empty, mul_one]\n    exact (forall_mem_insert _ _ _).2 ⟨lt_irrefl a, fun i hi => (ha i hi).not_lt⟩\n  · rw [mul_sum]\n    refine sum_congr rfl fun i hi => ?_\n    rw [filter_insert, if_neg (ha i hi).not_lt, filter_insert, if_pos (ha i hi), prod_insert,\n      mul_left_comm]\n    exact mt (fun ha => (mem_filter.1 ha).1) ha'\n\n"}
{"name":"Finset.sum_pow_mul_eq_add_pow","module":"Mathlib.Algebra.BigOperators.Ring","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝ : CommSemiring α\na b : α\ns : Finset ι\n⊢ Eq (s.powerset.sum fun t => HMul.hMul (HPow.hPow a t.card) (HPow.hPow b (HSub.hSub s.card t.card))) (HPow.hPow (HAdd.hAdd a b) s.card)","decl":"/-- Summing `a ^ #t * b ^ (n - #t)` over all finite subsets `t` of a finset `s`\ngives `(a + b) ^ #s`. -/\ntheorem sum_pow_mul_eq_add_pow (a b : α) (s : Finset ι) :\n    (∑ t ∈ s.powerset, a ^ #t * b ^ (#s - #t)) = (a + b) ^ #s := by\n  classical\n  rw [← prod_const, prod_add]\n  refine Finset.sum_congr rfl fun t ht => ?_\n  rw [prod_const, prod_const, ← card_sdiff (mem_powerset.1 ht)]\n\n"}
{"name":"Fintype.sum_pow_mul_eq_add_pow","module":"Mathlib.Algebra.BigOperators.Ring","initialProofState":"α : Type u_3\ninst✝¹ : CommSemiring α\nι : Type u_7\ninst✝ : Fintype ι\na b : α\n⊢ Eq (Finset.univ.sum fun s => HMul.hMul (HPow.hPow a s.card) (HPow.hPow b (HSub.hSub (Fintype.card ι) s.card))) (HPow.hPow (HAdd.hAdd a b) (Fintype.card ι))","decl":"/-- Summing `a^#s * b^(n-#s)` over all finite subsets `s` of a fintype of cardinality `n`\ngives `(a + b)^n`. The \"good\" proof involves expanding along all coordinates using the fact that\n`x^n` is multilinear, but multilinear maps are only available now over rings, so we give instead\na proof reducing to the usual binomial theorem to have a result over semirings. -/\nlemma _root_.Fintype.sum_pow_mul_eq_add_pow (ι : Type*) [Fintype ι] (a b : α) :\n    ∑ s : Finset ι, a ^ #s * b ^ (Fintype.card ι - #s) = (a + b) ^ Fintype.card ι :=\n  Finset.sum_pow_mul_eq_add_pow _ _ _\n\n"}
{"name":"Finset.prod_natCast","module":"Mathlib.Algebra.BigOperators.Ring","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝ : CommSemiring α\ns : Finset ι\nf : ι → Nat\n⊢ Eq (↑(s.prod fun i => f i)) (s.prod fun i => ↑(f i))","decl":"@[norm_cast]\ntheorem prod_natCast (s : Finset ι) (f : ι → ℕ) : ↑(∏ i ∈ s, f i : ℕ) = ∏ i ∈ s, (f i : α) :=\n  map_prod (Nat.castRingHom α) f s\n\n"}
{"name":"Finset.prod_sub","module":"Mathlib.Algebra.BigOperators.Ring","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝¹ : CommRing α\ninst✝ : DecidableEq ι\nf g : ι → α\ns : Finset ι\n⊢ Eq (s.prod fun i => HSub.hSub (f i) (g i)) (s.powerset.sum fun t => HMul.hMul (HMul.hMul (HPow.hPow (-1) t.card) ((SDiff.sdiff s t).prod fun i => f i)) (t.prod fun i => g i))","decl":"/-- The product of `f i - g i` over all of `s` is the sum over the powerset of `s` of the product of\n`g` over a subset `t` times the product of `f` over the complement of `t` times `(-1) ^ #t`. -/\nlemma prod_sub [DecidableEq ι] (f g : ι → α) (s : Finset ι) :\n    ∏ i ∈ s, (f i - g i) = ∑ t ∈ s.powerset, (-1) ^ #t * (∏ i ∈ s \\ t, f i) * ∏ i ∈ t, g i := by\n  simp [sub_eq_neg_add, prod_add, ← prod_const, ← prod_mul_distrib, mul_right_comm]\n\n"}
{"name":"Finset.prod_sub_ordered","module":"Mathlib.Algebra.BigOperators.Ring","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝¹ : CommRing α\ninst✝ : LinearOrder ι\ns : Finset ι\nf g : ι → α\n⊢ Eq (s.prod fun i => HSub.hSub (f i) (g i)) (HSub.hSub (s.prod fun i => f i) (s.sum fun i => HMul.hMul (HMul.hMul (g i) ((Finset.filter (fun j => LT.lt j i) s).prod fun j => HSub.hSub (f j) (g j))) ((Finset.filter (fun j => LT.lt i j) s).prod fun j => f j)))","decl":"/-- `∏ i, (f i - g i) = (∏ i, f i) - ∑ i, g i * (∏ j < i, f j - g j) * (∏ j > i, f j)`. -/\nlemma prod_sub_ordered [LinearOrder ι] (s : Finset ι) (f g : ι → α) :\n    ∏ i ∈ s, (f i - g i) =\n      (∏ i ∈ s, f i) -\n        ∑ i ∈ s, g i * (∏ j ∈ s with j < i, (f j - g j)) * ∏ j ∈ s with i < j, f j := by\n  simp only [sub_eq_add_neg]\n  convert prod_add_ordered s f fun i => -g i\n  simp\n\n"}
{"name":"Finset.prod_one_sub_ordered","module":"Mathlib.Algebra.BigOperators.Ring","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝¹ : CommRing α\ninst✝ : LinearOrder ι\ns : Finset ι\nf : ι → α\n⊢ Eq (s.prod fun i => HSub.hSub 1 (f i)) (HSub.hSub 1 (s.sum fun i => HMul.hMul (f i) ((Finset.filter (fun j => LT.lt j i) s).prod fun j => HSub.hSub 1 (f j))))","decl":"/-- `∏ i, (1 - f i) = 1 - ∑ i, f i * (∏ j < i, 1 - f j)`. This formula is useful in construction of\na partition of unity from a collection of “bump” functions. -/\ntheorem prod_one_sub_ordered [LinearOrder ι] (s : Finset ι) (f : ι → α) :\n    ∏ i ∈ s, (1 - f i) = 1 - ∑ i ∈ s, f i * ∏ j ∈ s with j < i, (1 - f j) := by\n  rw [prod_sub_ordered]\n  simp\n\n"}
{"name":"Finset.prod_range_natCast_sub","module":"Mathlib.Algebra.BigOperators.Ring","initialProofState":"α : Type u_3\ninst✝ : CommRing α\nn k : Nat\n⊢ Eq ((Finset.range k).prod fun i => HSub.hSub ↑n ↑i) ↑((Finset.range k).prod fun i => HSub.hSub n i)","decl":"theorem prod_range_natCast_sub (n k : ℕ) :\n    ∏ i ∈ range k, (n - i : α) = (∏ i ∈ range k, (n - i) : ℕ) := by\n  rw [prod_natCast]\n  rcases le_or_lt k n with hkn | hnk\n  · exact prod_congr rfl fun i hi => (Nat.cast_sub <| (mem_range.1 hi).le.trans hkn).symm\n  · rw [← mem_range] at hnk\n    rw [prod_eq_zero hnk, prod_eq_zero hnk] <;> simp\n\n\n"}
{"name":"Multiset.sum_map_div","module":"Mathlib.Algebra.BigOperators.Ring","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝ : DivisionSemiring α\ns : Multiset ι\nf : ι → α\na : α\n⊢ Eq (Multiset.map (fun x => HDiv.hDiv (f x) a) s).sum (HDiv.hDiv (Multiset.map f s).sum a)","decl":"lemma _root_.Multiset.sum_map_div {s : Multiset ι} {f : ι → α} {a : α} :\n    (s.map (fun x ↦ f x / a)).sum = (s.map f).sum / a := by\n  simp only [div_eq_mul_inv, Multiset.sum_map_mul_right]\n\n"}
{"name":"Finset.sum_div","module":"Mathlib.Algebra.BigOperators.Ring","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝ : DivisionSemiring α\ns : Finset ι\nf : ι → α\na : α\n⊢ Eq (HDiv.hDiv (s.sum fun i => f i) a) (s.sum fun i => HDiv.hDiv (f i) a)","decl":"lemma sum_div (s : Finset ι) (f : ι → α) (a : α) :\n    (∑ i ∈ s, f i) / a = ∑ i ∈ s, f i / a := by simp only [div_eq_mul_inv, sum_mul]\n\n"}
{"name":"Fintype.sum_pow","module":"Mathlib.Algebra.BigOperators.Ring","initialProofState":"ι : Type u_7\nα : Type u_9\ninst✝¹ : Fintype ι\ninst✝ : CommSemiring α\nf : ι → α\nn : Nat\n⊢ Eq (HPow.hPow (Finset.univ.sum fun a => f a) n) (Finset.univ.sum fun p => Finset.univ.prod fun i => f (p i))","decl":"lemma sum_pow (f : ι → α) (n : ℕ) : (∑ a, f a) ^ n = ∑ p : Fin n → ι, ∏ i, f (p i) := by\n  simp [sum_pow']\n\n"}
{"name":"Fintype.prod_sum","module":"Mathlib.Algebra.BigOperators.Ring","initialProofState":"ι : Type u_7\nα : Type u_9\ninst✝³ : Fintype ι\ninst✝² : CommSemiring α\ninst✝¹ : DecidableEq ι\nκ : ι → Type u_10\ninst✝ : (i : ι) → Fintype (κ i)\nf : (i : ι) → κ i → α\n⊢ Eq (Finset.univ.prod fun i => Finset.univ.sum fun j => f i j) (Finset.univ.sum fun x => Finset.univ.prod fun i => f i (x i))","decl":"/-- A product of sums can be written as a sum of products. -/\nlemma prod_sum {κ : ι → Type*} [∀ i, Fintype (κ i)] (f : ∀ i, κ i → α) :\n    ∏ i, ∑ j, f i j = ∑ x : ∀ i, κ i, ∏ i, f i (x i) := Finset.prod_univ_sum _ _\n\n"}
{"name":"Fintype.prod_add","module":"Mathlib.Algebra.BigOperators.Ring","initialProofState":"ι : Type u_7\nα : Type u_9\ninst✝² : Fintype ι\ninst✝¹ : CommSemiring α\ninst✝ : DecidableEq ι\nf g : ι → α\n⊢ Eq (Finset.univ.prod fun a => HAdd.hAdd (f a) (g a)) (Finset.univ.sum fun t => HMul.hMul (t.prod fun a => f a) ((HasCompl.compl t).prod fun a => g a))","decl":"lemma prod_add (f g : ι → α) : ∏ a, (f a + g a) = ∑ t, (∏ a ∈ t, f a) * ∏ a ∈ tᶜ, g a := by\n  simpa [compl_eq_univ_sdiff] using Finset.prod_add f g univ\n\n"}
{"name":"Nat.sum_div","module":"Mathlib.Algebra.BigOperators.Ring","initialProofState":"ι : Type u_7\ns : Finset ι\nf : ι → Nat\nn : Nat\nhf : ∀ (i : ι), Membership.mem s i → Dvd.dvd n (f i)\n⊢ Eq (HDiv.hDiv (s.sum fun i => f i) n) (s.sum fun i => HDiv.hDiv (f i) n)","decl":"protected lemma sum_div (hf : ∀ i ∈ s, n ∣ f i) : (∑ i ∈ s, f i) / n = ∑ i ∈ s, f i / n := by\n  obtain rfl | hn := n.eq_zero_or_pos\n  · simp\n  rw [Nat.div_eq_iff_eq_mul_left hn (dvd_sum hf), sum_mul]\n  refine sum_congr rfl fun s hs ↦ ?_\n  rw [Nat.div_mul_cancel (hf _ hs)]\n\n"}
{"name":"Nat.cast_list_sum","module":"Mathlib.Algebra.BigOperators.Ring","initialProofState":"β : Type u_4\ninst✝ : AddMonoidWithOne β\ns : List Nat\n⊢ Eq (↑s.sum) (List.map Nat.cast s).sum","decl":"@[simp, norm_cast]\nlemma cast_list_sum [AddMonoidWithOne β] (s : List ℕ) : (↑s.sum : β) = (s.map (↑)).sum :=\n  map_list_sum (castAddMonoidHom β) _\n\n"}
{"name":"Nat.cast_list_prod","module":"Mathlib.Algebra.BigOperators.Ring","initialProofState":"β : Type u_4\ninst✝ : Semiring β\ns : List Nat\n⊢ Eq (↑s.prod) (List.map Nat.cast s).prod","decl":"@[simp, norm_cast]\nlemma cast_list_prod [Semiring β] (s : List ℕ) : (↑s.prod : β) = (s.map (↑)).prod :=\n  map_list_prod (castRingHom β) _\n\n"}
{"name":"Nat.cast_multiset_sum","module":"Mathlib.Algebra.BigOperators.Ring","initialProofState":"β : Type u_4\ninst✝ : AddCommMonoidWithOne β\ns : Multiset Nat\n⊢ Eq (↑s.sum) (Multiset.map Nat.cast s).sum","decl":"@[simp, norm_cast]\nlemma cast_multiset_sum [AddCommMonoidWithOne β] (s : Multiset ℕ) :\n    (↑s.sum : β) = (s.map (↑)).sum :=\n  map_multiset_sum (castAddMonoidHom β) _\n\n"}
{"name":"Nat.cast_multiset_prod","module":"Mathlib.Algebra.BigOperators.Ring","initialProofState":"β : Type u_4\ninst✝ : CommSemiring β\ns : Multiset Nat\n⊢ Eq (↑s.prod) (Multiset.map Nat.cast s).prod","decl":"@[simp, norm_cast]\nlemma cast_multiset_prod [CommSemiring β] (s : Multiset ℕ) : (↑s.prod : β) = (s.map (↑)).prod :=\n  map_multiset_prod (castRingHom β) _\n\n"}
{"name":"Nat.cast_sum","module":"Mathlib.Algebra.BigOperators.Ring","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : AddCommMonoidWithOne β\ns : Finset α\nf : α → Nat\n⊢ Eq (↑(s.sum fun x => f x)) (s.sum fun x => ↑(f x))","decl":"@[simp, norm_cast]\nlemma cast_sum [AddCommMonoidWithOne β] (s : Finset α) (f : α → ℕ) :\n    ↑(∑ x ∈ s, f x : ℕ) = ∑ x ∈ s, (f x : β) :=\n  map_sum (castAddMonoidHom β) _ _\n\n"}
{"name":"Nat.cast_prod","module":"Mathlib.Algebra.BigOperators.Ring","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : CommSemiring β\nf : α → Nat\ns : Finset α\n⊢ Eq (↑(s.prod fun i => f i)) (s.prod fun i => ↑(f i))","decl":"@[simp, norm_cast]\nlemma cast_prod [CommSemiring β] (f : α → ℕ) (s : Finset α) :\n    (↑(∏ i ∈ s, f i) : β) = ∏ i ∈ s, (f i : β) :=\n  map_prod (castRingHom β) _ _\n\n"}
{"name":"Int.sum_div","module":"Mathlib.Algebra.BigOperators.Ring","initialProofState":"ι : Type u_7\ns : Finset ι\nf : ι → Int\nn : Int\nhf : ∀ (i : ι), Membership.mem s i → Dvd.dvd n (f i)\n⊢ Eq (HDiv.hDiv (s.sum fun i => f i) n) (s.sum fun i => HDiv.hDiv (f i) n)","decl":"protected lemma sum_div (hf : ∀ i ∈ s, n ∣ f i) : (∑ i ∈ s, f i) / n = ∑ i ∈ s, f i / n := by\n  obtain rfl | hn := eq_or_ne n 0\n  · simp\n  rw [Int.ediv_eq_iff_eq_mul_left hn (dvd_sum hf), sum_mul]\n  refine sum_congr rfl fun s hs ↦ ?_\n  rw [Int.ediv_mul_cancel (hf _ hs)]\n\n"}
{"name":"Int.cast_list_sum","module":"Mathlib.Algebra.BigOperators.Ring","initialProofState":"β : Type u_4\ninst✝ : AddGroupWithOne β\ns : List Int\n⊢ Eq (↑s.sum) (List.map Int.cast s).sum","decl":"@[simp, norm_cast]\nlemma cast_list_sum [AddGroupWithOne β] (s : List ℤ) : (↑s.sum : β) = (s.map (↑)).sum :=\n  map_list_sum (castAddHom β) _\n\n"}
{"name":"Int.cast_list_prod","module":"Mathlib.Algebra.BigOperators.Ring","initialProofState":"β : Type u_4\ninst✝ : Ring β\ns : List Int\n⊢ Eq (↑s.prod) (List.map Int.cast s).prod","decl":"@[simp, norm_cast]\nlemma cast_list_prod [Ring β] (s : List ℤ) : (↑s.prod : β) = (s.map (↑)).prod :=\n  map_list_prod (castRingHom β) _\n\n"}
{"name":"Int.cast_multiset_sum","module":"Mathlib.Algebra.BigOperators.Ring","initialProofState":"β : Type u_4\ninst✝ : AddCommGroupWithOne β\ns : Multiset Int\n⊢ Eq (↑s.sum) (Multiset.map Int.cast s).sum","decl":"@[simp, norm_cast]\nlemma cast_multiset_sum [AddCommGroupWithOne β] (s : Multiset ℤ) :\n    (↑s.sum : β) = (s.map (↑)).sum :=\n  map_multiset_sum (castAddHom β) _\n\n"}
{"name":"Int.cast_multiset_prod","module":"Mathlib.Algebra.BigOperators.Ring","initialProofState":"R : Type u_8\ninst✝ : CommRing R\ns : Multiset Int\n⊢ Eq (↑s.prod) (Multiset.map Int.cast s).prod","decl":"@[simp, norm_cast]\nlemma cast_multiset_prod {R : Type*} [CommRing R] (s : Multiset ℤ) :\n    (↑s.prod : R) = (s.map (↑)).prod :=\n  map_multiset_prod (castRingHom R) _\n\n"}
{"name":"Int.cast_sum","module":"Mathlib.Algebra.BigOperators.Ring","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : AddCommGroupWithOne β\ns : Finset α\nf : α → Int\n⊢ Eq (↑(s.sum fun x => f x)) (s.sum fun x => ↑(f x))","decl":"@[simp, norm_cast]\nlemma cast_sum [AddCommGroupWithOne β] (s : Finset α) (f : α → ℤ) :\n    ↑(∑ x ∈ s, f x : ℤ) = ∑ x ∈ s, (f x : β) :=\n  map_sum (castAddHom β) _ _\n\n"}
{"name":"Int.cast_prod","module":"Mathlib.Algebra.BigOperators.Ring","initialProofState":"α : Type u_3\nR : Type u_8\ninst✝ : CommRing R\nf : α → Int\ns : Finset α\n⊢ Eq (↑(s.prod fun i => f i)) (s.prod fun i => ↑(f i))","decl":"@[simp, norm_cast]\nlemma cast_prod {R : Type*} [CommRing R] (f : α → ℤ) (s : Finset α) :\n    (↑(∏ i ∈ s, f i) : R) = ∏ i ∈ s, (f i : R) :=\n  map_prod (Int.castRingHom R) _ _\n\n"}
