{"name":"DihedralGroup.r.injEq","module":"Mathlib.GroupTheory.SpecificGroups.Dihedral","initialProofState":"n : Nat\na✝¹ a✝ : ZMod n\n⊢ Eq (Eq (DihedralGroup.r a✝¹) (DihedralGroup.r a✝)) (Eq a✝¹ a✝)","decl":"/-- For `n ≠ 0`, `DihedralGroup n` represents the symmetry group of the regular `n`-gon.\n`r i` represents the rotations of the `n`-gon by `2πi/n`, and `sr i` represents the reflections of\nthe `n`-gon. `DihedralGroup 0` corresponds to the infinite dihedral group.\n-/\ninductive DihedralGroup (n : ℕ) : Type\n  | r : ZMod n → DihedralGroup n\n  | sr : ZMod n → DihedralGroup n\n  deriving DecidableEq\n\n"}
{"name":"DihedralGroup.r.sizeOf_spec","module":"Mathlib.GroupTheory.SpecificGroups.Dihedral","initialProofState":"n : Nat\na✝ : ZMod n\n⊢ Eq (SizeOf.sizeOf (DihedralGroup.r a✝)) (HAdd.hAdd 1 (SizeOf.sizeOf a✝))","decl":"/-- For `n ≠ 0`, `DihedralGroup n` represents the symmetry group of the regular `n`-gon.\n`r i` represents the rotations of the `n`-gon by `2πi/n`, and `sr i` represents the reflections of\nthe `n`-gon. `DihedralGroup 0` corresponds to the infinite dihedral group.\n-/\ninductive DihedralGroup (n : ℕ) : Type\n  | r : ZMod n → DihedralGroup n\n  | sr : ZMod n → DihedralGroup n\n  deriving DecidableEq\n\n"}
{"name":"DihedralGroup.sr.inj","module":"Mathlib.GroupTheory.SpecificGroups.Dihedral","initialProofState":"n : Nat\na✝¹ a✝ : ZMod n\nx✝ : Eq (DihedralGroup.sr a✝¹) (DihedralGroup.sr a✝)\n⊢ Eq a✝¹ a✝","decl":"/-- For `n ≠ 0`, `DihedralGroup n` represents the symmetry group of the regular `n`-gon.\n`r i` represents the rotations of the `n`-gon by `2πi/n`, and `sr i` represents the reflections of\nthe `n`-gon. `DihedralGroup 0` corresponds to the infinite dihedral group.\n-/\ninductive DihedralGroup (n : ℕ) : Type\n  | r : ZMod n → DihedralGroup n\n  | sr : ZMod n → DihedralGroup n\n  deriving DecidableEq\n\n"}
{"name":"DihedralGroup.r.inj","module":"Mathlib.GroupTheory.SpecificGroups.Dihedral","initialProofState":"n : Nat\na✝¹ a✝ : ZMod n\nx✝ : Eq (DihedralGroup.r a✝¹) (DihedralGroup.r a✝)\n⊢ Eq a✝¹ a✝","decl":"/-- For `n ≠ 0`, `DihedralGroup n` represents the symmetry group of the regular `n`-gon.\n`r i` represents the rotations of the `n`-gon by `2πi/n`, and `sr i` represents the reflections of\nthe `n`-gon. `DihedralGroup 0` corresponds to the infinite dihedral group.\n-/\ninductive DihedralGroup (n : ℕ) : Type\n  | r : ZMod n → DihedralGroup n\n  | sr : ZMod n → DihedralGroup n\n  deriving DecidableEq\n\n"}
{"name":"DihedralGroup.sr.injEq","module":"Mathlib.GroupTheory.SpecificGroups.Dihedral","initialProofState":"n : Nat\na✝¹ a✝ : ZMod n\n⊢ Eq (Eq (DihedralGroup.sr a✝¹) (DihedralGroup.sr a✝)) (Eq a✝¹ a✝)","decl":"/-- For `n ≠ 0`, `DihedralGroup n` represents the symmetry group of the regular `n`-gon.\n`r i` represents the rotations of the `n`-gon by `2πi/n`, and `sr i` represents the reflections of\nthe `n`-gon. `DihedralGroup 0` corresponds to the infinite dihedral group.\n-/\ninductive DihedralGroup (n : ℕ) : Type\n  | r : ZMod n → DihedralGroup n\n  | sr : ZMod n → DihedralGroup n\n  deriving DecidableEq\n\n"}
{"name":"DihedralGroup.sr.sizeOf_spec","module":"Mathlib.GroupTheory.SpecificGroups.Dihedral","initialProofState":"n : Nat\na✝ : ZMod n\n⊢ Eq (SizeOf.sizeOf (DihedralGroup.sr a✝)) (HAdd.hAdd 1 (SizeOf.sizeOf a✝))","decl":"/-- For `n ≠ 0`, `DihedralGroup n` represents the symmetry group of the regular `n`-gon.\n`r i` represents the rotations of the `n`-gon by `2πi/n`, and `sr i` represents the reflections of\nthe `n`-gon. `DihedralGroup 0` corresponds to the infinite dihedral group.\n-/\ninductive DihedralGroup (n : ℕ) : Type\n  | r : ZMod n → DihedralGroup n\n  | sr : ZMod n → DihedralGroup n\n  deriving DecidableEq\n\n"}
{"name":"DihedralGroup.r_mul_r","module":"Mathlib.GroupTheory.SpecificGroups.Dihedral","initialProofState":"n : Nat\ni j : ZMod n\n⊢ Eq (HMul.hMul (DihedralGroup.r i) (DihedralGroup.r j)) (DihedralGroup.r (HAdd.hAdd i j))","decl":"@[simp]\ntheorem r_mul_r (i j : ZMod n) : r i * r j = r (i + j) :=\n  rfl\n\n"}
{"name":"DihedralGroup.r_mul_sr","module":"Mathlib.GroupTheory.SpecificGroups.Dihedral","initialProofState":"n : Nat\ni j : ZMod n\n⊢ Eq (HMul.hMul (DihedralGroup.r i) (DihedralGroup.sr j)) (DihedralGroup.sr (HSub.hSub j i))","decl":"@[simp]\ntheorem r_mul_sr (i j : ZMod n) : r i * sr j = sr (j - i) :=\n  rfl\n\n"}
{"name":"DihedralGroup.sr_mul_r","module":"Mathlib.GroupTheory.SpecificGroups.Dihedral","initialProofState":"n : Nat\ni j : ZMod n\n⊢ Eq (HMul.hMul (DihedralGroup.sr i) (DihedralGroup.r j)) (DihedralGroup.sr (HAdd.hAdd i j))","decl":"@[simp]\ntheorem sr_mul_r (i j : ZMod n) : sr i * r j = sr (i + j) :=\n  rfl\n\n"}
{"name":"DihedralGroup.sr_mul_sr","module":"Mathlib.GroupTheory.SpecificGroups.Dihedral","initialProofState":"n : Nat\ni j : ZMod n\n⊢ Eq (HMul.hMul (DihedralGroup.sr i) (DihedralGroup.sr j)) (DihedralGroup.r (HSub.hSub j i))","decl":"@[simp]\ntheorem sr_mul_sr (i j : ZMod n) : sr i * sr j = r (j - i) :=\n  rfl\n\n"}
{"name":"DihedralGroup.inv_r","module":"Mathlib.GroupTheory.SpecificGroups.Dihedral","initialProofState":"n : Nat\ni : ZMod n\n⊢ Eq (Inv.inv (DihedralGroup.r i)) (DihedralGroup.r (Neg.neg i))","decl":"@[simp]\ntheorem inv_r (i : ZMod n) : (r i)⁻¹ = r (-i) :=\n  rfl\n\n"}
{"name":"DihedralGroup.inv_sr","module":"Mathlib.GroupTheory.SpecificGroups.Dihedral","initialProofState":"n : Nat\ni : ZMod n\n⊢ Eq (Inv.inv (DihedralGroup.sr i)) (DihedralGroup.sr i)","decl":"@[simp]\ntheorem inv_sr (i : ZMod n) : (sr i)⁻¹ = sr i :=\n  rfl\n\n"}
{"name":"DihedralGroup.one_def","module":"Mathlib.GroupTheory.SpecificGroups.Dihedral","initialProofState":"n : Nat\n⊢ Eq 1 (DihedralGroup.r 0)","decl":"theorem one_def : (1 : DihedralGroup n) = r 0 :=\n  rfl\n\n"}
{"name":"DihedralGroup.instInfiniteOfNatNat","module":"Mathlib.GroupTheory.SpecificGroups.Dihedral","initialProofState":"⊢ Infinite (DihedralGroup 0)","decl":"instance : Infinite (DihedralGroup 0) :=\n  DihedralGroup.fintypeHelper.infinite_iff.mp inferInstance\n\n"}
{"name":"DihedralGroup.instNontrivial","module":"Mathlib.GroupTheory.SpecificGroups.Dihedral","initialProofState":"n : Nat\n⊢ Nontrivial (DihedralGroup n)","decl":"instance : Nontrivial (DihedralGroup n) :=\n  ⟨⟨r 0, sr 0, by simp_rw [ne_eq, reduceCtorEq, not_false_eq_true]⟩⟩\n\n"}
{"name":"DihedralGroup.card","module":"Mathlib.GroupTheory.SpecificGroups.Dihedral","initialProofState":"n : Nat\ninst✝ : NeZero n\n⊢ Eq (Fintype.card (DihedralGroup n)) (HMul.hMul 2 n)","decl":"/-- If `0 < n`, then `DihedralGroup n` has `2n` elements.\n-/\ntheorem card [NeZero n] : Fintype.card (DihedralGroup n) = 2 * n := by\n  rw [← Fintype.card_eq.mpr ⟨fintypeHelper⟩, Fintype.card_sum, ZMod.card, two_mul]\n\n"}
{"name":"DihedralGroup.nat_card","module":"Mathlib.GroupTheory.SpecificGroups.Dihedral","initialProofState":"n : Nat\n⊢ Eq (Nat.card (DihedralGroup n)) (HMul.hMul 2 n)","decl":"theorem nat_card : Nat.card (DihedralGroup n) = 2 * n := by\n  cases n\n  · rw [Nat.card_eq_zero_of_infinite]\n  · rw [Nat.card_eq_fintype_card, card]\n\n"}
{"name":"DihedralGroup.r_one_pow","module":"Mathlib.GroupTheory.SpecificGroups.Dihedral","initialProofState":"n k : Nat\n⊢ Eq (HPow.hPow (DihedralGroup.r 1) k) (DihedralGroup.r ↑k)","decl":"@[simp]\ntheorem r_one_pow (k : ℕ) : (r 1 : DihedralGroup n) ^ k = r k := by\n  induction' k with k IH\n  · rw [Nat.cast_zero]\n    rfl\n  · rw [pow_succ', IH, r_mul_r]\n    congr 1\n    norm_cast\n    rw [Nat.one_add]\n\n"}
{"name":"DihedralGroup.r_one_zpow","module":"Mathlib.GroupTheory.SpecificGroups.Dihedral","initialProofState":"n : Nat\nk : Int\n⊢ Eq (HPow.hPow (DihedralGroup.r 1) k) (DihedralGroup.r ↑k)","decl":"@[simp]\ntheorem r_one_zpow (k : ℤ) : (r 1 : DihedralGroup n) ^ k = r k := by\n  cases k <;> simp\n\n-- @[simp] -- Porting note: simp changes the goal to `r 0 = 1`. `r_one_pow_n` is no longer useful.\n"}
{"name":"DihedralGroup.r_one_pow_n","module":"Mathlib.GroupTheory.SpecificGroups.Dihedral","initialProofState":"n : Nat\n⊢ Eq (HPow.hPow (DihedralGroup.r 1) n) 1","decl":"theorem r_one_pow_n : r (1 : ZMod n) ^ n = 1 := by\n  rw [r_one_pow, one_def]\n  congr 1\n  exact ZMod.natCast_self _\n\n-- @[simp] -- Porting note: simp changes the goal to `r 0 = 1`. `sr_mul_self` is no longer useful.\n"}
{"name":"DihedralGroup.sr_mul_self","module":"Mathlib.GroupTheory.SpecificGroups.Dihedral","initialProofState":"n : Nat\ni : ZMod n\n⊢ Eq (HMul.hMul (DihedralGroup.sr i) (DihedralGroup.sr i)) 1","decl":"theorem sr_mul_self (i : ZMod n) : sr i * sr i = 1 := by rw [sr_mul_sr, sub_self, one_def]\n\n"}
{"name":"DihedralGroup.orderOf_sr","module":"Mathlib.GroupTheory.SpecificGroups.Dihedral","initialProofState":"n : Nat\ni : ZMod n\n⊢ Eq (orderOf (DihedralGroup.sr i)) 2","decl":"/-- If `0 < n`, then `sr i` has order 2.\n-/\n@[simp]\ntheorem orderOf_sr (i : ZMod n) : orderOf (sr i) = 2 := by\n  apply orderOf_eq_prime\n  · rw [sq, sr_mul_self]\n  · -- Porting note: Previous proof was `decide`\n    revert n\n    simp_rw [one_def, ne_eq, reduceCtorEq, forall_const, not_false_eq_true]\n\n"}
{"name":"DihedralGroup.orderOf_r_one","module":"Mathlib.GroupTheory.SpecificGroups.Dihedral","initialProofState":"n : Nat\n⊢ Eq (orderOf (DihedralGroup.r 1)) n","decl":"/-- If `0 < n`, then `r 1` has order `n`.\n-/\n@[simp]\ntheorem orderOf_r_one : orderOf (r 1 : DihedralGroup n) = n := by\n  rcases eq_zero_or_neZero n with (rfl | hn)\n  · rw [orderOf_eq_zero_iff']\n    intro n hn\n    rw [r_one_pow, one_def]\n    apply mt r.inj\n    simpa using hn.ne'\n  · apply (Nat.le_of_dvd (NeZero.pos n) <|\n      orderOf_dvd_of_pow_eq_one <| @r_one_pow_n n).lt_or_eq.resolve_left\n    intro h\n    have h1 : (r 1 : DihedralGroup n) ^ orderOf (r 1) = 1 := pow_orderOf_eq_one _\n    rw [r_one_pow] at h1\n    injection h1 with h2\n    rw [← ZMod.val_eq_zero, ZMod.val_natCast, Nat.mod_eq_of_lt h] at h2\n    exact absurd h2.symm (orderOf_pos _).ne\n\n"}
{"name":"DihedralGroup.orderOf_r","module":"Mathlib.GroupTheory.SpecificGroups.Dihedral","initialProofState":"n : Nat\ninst✝ : NeZero n\ni : ZMod n\n⊢ Eq (orderOf (DihedralGroup.r i)) (HDiv.hDiv n (n.gcd i.val))","decl":"/-- If `0 < n`, then `i : ZMod n` has order `n / gcd n i`.\n-/\ntheorem orderOf_r [NeZero n] (i : ZMod n) : orderOf (r i) = n / Nat.gcd n i.val := by\n  conv_lhs => rw [← ZMod.natCast_zmod_val i]\n  rw [← r_one_pow, orderOf_pow, orderOf_r_one]\n\n"}
{"name":"DihedralGroup.exponent","module":"Mathlib.GroupTheory.SpecificGroups.Dihedral","initialProofState":"n : Nat\n⊢ Eq (Monoid.exponent (DihedralGroup n)) (GCDMonoid.lcm n 2)","decl":"theorem exponent : Monoid.exponent (DihedralGroup n) = lcm n 2 := by\n  rcases eq_zero_or_neZero n with (rfl | hn)\n  · exact Monoid.exponent_eq_zero_of_order_zero orderOf_r_one\n  apply Nat.dvd_antisymm\n  · apply Monoid.exponent_dvd_of_forall_pow_eq_one\n    rintro (m | m)\n    · rw [← orderOf_dvd_iff_pow_eq_one, orderOf_r]\n      refine Nat.dvd_trans ⟨gcd n m.val, ?_⟩ (dvd_lcm_left n 2)\n      exact (Nat.div_mul_cancel (Nat.gcd_dvd_left n m.val)).symm\n    · rw [← orderOf_dvd_iff_pow_eq_one, orderOf_sr]\n      exact dvd_lcm_right n 2\n  · apply lcm_dvd\n    · convert Monoid.order_dvd_exponent (r (1 : ZMod n))\n      exact orderOf_r_one.symm\n    · convert Monoid.order_dvd_exponent (sr (0 : ZMod n))\n      exact (orderOf_sr 0).symm\n\n"}
{"name":"DihedralGroup.not_commutative","module":"Mathlib.GroupTheory.SpecificGroups.Dihedral","initialProofState":"n : Nat\na✝¹ : Ne n 1\na✝ : Ne n 2\n⊢ Not (Std.Commutative fun x y => HMul.hMul x y)","decl":"lemma not_commutative : ∀ {n : ℕ}, n ≠ 1 → n ≠ 2 →\n    ¬Std.Commutative fun (x y : DihedralGroup n) => x * y\n  | 0, _, _ => fun ⟨h'⟩ ↦ by simpa using h' (r 1) (sr 0)\n  | n + 3, _, _ => by\n    rintro ⟨h'⟩\n    specialize h' (r 1) (sr 0)\n    rw [r_mul_sr, zero_sub, sr_mul_r, zero_add, sr.injEq, neg_eq_iff_add_eq_zero,\n      one_add_one_eq_two, ← ZMod.val_eq_zero, ZMod.val_two_eq_two_mod] at h'\n    simpa using Nat.le_of_dvd Nat.zero_lt_two <| Nat.dvd_of_mod_eq_zero h'\n\n"}
{"name":"DihedralGroup.commutative_iff","module":"Mathlib.GroupTheory.SpecificGroups.Dihedral","initialProofState":"n : Nat\n⊢ Iff (Std.Commutative fun x y => HMul.hMul x y) (Or (Eq n 1) (Eq n 2))","decl":"lemma commutative_iff {n : ℕ} :\n    Std.Commutative (fun x y : DihedralGroup n ↦ x * y) ↔ n = 1 ∨ n = 2 where\n  mp := by contrapose!; rintro ⟨h1, h2⟩; exact not_commutative h1 h2\n  mpr := by rintro (rfl | rfl) <;> exact ⟨by decide⟩\n\n"}
{"name":"DihedralGroup.OddCommuteEquiv_apply","module":"Mathlib.GroupTheory.SpecificGroups.Dihedral","initialProofState":"n : Nat\nhn : Odd n\nx✝ : Subtype fun p => Commute p.1 p.2\n⊢ Eq ((DihedralGroup.OddCommuteEquiv hn) x✝) (DihedralGroup.OddCommuteEquiv.match_1 (fun x => Sum (ZMod n) (Sum (ZMod n) (Sum (ZMod n) (Prod (ZMod n) (ZMod n))))) x✝ (fun i a property => Sum.inl i) (fun a j property => Sum.inr (Sum.inl j)) (fun i j property => Sum.inr (Sum.inr (Sum.inl (HAdd.hAdd i j)))) fun i j property => Sum.inr (Sum.inr (Sum.inr { fst := i, snd := j })))","decl":"/-- If n is odd, then the Dihedral group of order $2n$ has $n(n+3)$ pairs (represented as\n$n + n + n + n*n$) of commuting elements. -/\n@[simps]\ndef OddCommuteEquiv (hn : Odd n) : { p : DihedralGroup n × DihedralGroup n // Commute p.1 p.2 } ≃\n    ZMod n ⊕ ZMod n ⊕ ZMod n ⊕ ZMod n × ZMod n :=\n  let u := ZMod.unitOfCoprime 2 (Nat.prime_two.coprime_iff_not_dvd.mpr hn.not_two_dvd_nat)\n  have hu : ∀ a : ZMod n, a + a = 0 ↔ a = 0 := fun _ => ZMod.add_self_eq_zero_iff_eq_zero hn\n  { toFun := fun\n      | ⟨⟨sr i, r _⟩, _⟩ => Sum.inl i\n      | ⟨⟨r _, sr j⟩, _⟩ => Sum.inr (Sum.inl j)\n      | ⟨⟨sr i, sr j⟩, _⟩ => Sum.inr (Sum.inr (Sum.inl (i + j)))\n      | ⟨⟨r i, r j⟩, _⟩ => Sum.inr (Sum.inr (Sum.inr ⟨i, j⟩))\n    invFun := fun\n      | .inl i => ⟨⟨sr i, r 0⟩, congrArg sr ((add_zero i).trans (sub_zero i).symm)⟩\n      | .inr (.inl j) => ⟨⟨r 0, sr j⟩, congrArg sr ((sub_zero j).trans (add_zero j).symm)⟩\n      | .inr (.inr (.inl k)) => ⟨⟨sr (u⁻¹ * k), sr (u⁻¹ * k)⟩, rfl⟩\n      | .inr (.inr (.inr ⟨i, j⟩)) => ⟨⟨r i, r j⟩, congrArg r (add_comm i j)⟩\n    left_inv := fun\n      | ⟨⟨r _, r _⟩, _⟩ => rfl\n      | ⟨⟨r i, sr j⟩, h⟩ => by\n        simpa [sub_eq_add_neg, neg_eq_iff_add_eq_zero, hu, eq_comm (a := i) (b := 0)] using h.eq\n      | ⟨⟨sr i, r j⟩, h⟩ => by\n        simpa [sub_eq_add_neg, eq_neg_iff_add_eq_zero, hu, eq_comm (a := j) (b := 0)] using h.eq\n      | ⟨⟨sr i, sr j⟩, h⟩ => by\n        replace h := r.inj h\n        rw [← neg_sub, neg_eq_iff_add_eq_zero, hu, sub_eq_zero] at h\n        rw [Subtype.ext_iff, Prod.ext_iff, sr.injEq, sr.injEq, h, and_self, ← two_mul]\n        exact u.inv_mul_cancel_left j\n    right_inv := fun\n      | .inl _ => rfl\n      | .inr (.inl _) => rfl\n      | .inr (.inr (.inl k)) =>\n        congrArg (Sum.inr ∘ Sum.inr ∘ Sum.inl) <| two_mul (u⁻¹ * k) ▸ u.mul_inv_cancel_left k\n      | .inr (.inr (.inr ⟨_, _⟩)) => rfl }\n\n"}
{"name":"DihedralGroup.OddCommuteEquiv_symm_apply","module":"Mathlib.GroupTheory.SpecificGroups.Dihedral","initialProofState":"n : Nat\nhn : Odd n\nx✝ : Sum (ZMod n) (Sum (ZMod n) (Sum (ZMod n) (Prod (ZMod n) (ZMod n))))\n⊢ Eq ((DihedralGroup.OddCommuteEquiv hn).symm x✝) (DihedralGroup.OddCommuteEquiv.match_2 (fun x => Subtype fun p => Commute p.1 p.2) x✝ (fun i => ⟨{ fst := DihedralGroup.sr i, snd := DihedralGroup.r 0 }, ⋯⟩) (fun j => ⟨{ fst := DihedralGroup.r 0, snd := DihedralGroup.sr j }, ⋯⟩) (fun k => ⟨{ fst := DihedralGroup.sr (HMul.hMul (↑(Inv.inv (ZMod.unitOfCoprime 2 ⋯))) k), snd := DihedralGroup.sr (HMul.hMul (↑(Inv.inv (ZMod.unitOfCoprime 2 ⋯))) k) }, ⋯⟩) fun i j => ⟨{ fst := DihedralGroup.r i, snd := DihedralGroup.r j }, ⋯⟩)","decl":"/-- If n is odd, then the Dihedral group of order $2n$ has $n(n+3)$ pairs (represented as\n$n + n + n + n*n$) of commuting elements. -/\n@[simps]\ndef OddCommuteEquiv (hn : Odd n) : { p : DihedralGroup n × DihedralGroup n // Commute p.1 p.2 } ≃\n    ZMod n ⊕ ZMod n ⊕ ZMod n ⊕ ZMod n × ZMod n :=\n  let u := ZMod.unitOfCoprime 2 (Nat.prime_two.coprime_iff_not_dvd.mpr hn.not_two_dvd_nat)\n  have hu : ∀ a : ZMod n, a + a = 0 ↔ a = 0 := fun _ => ZMod.add_self_eq_zero_iff_eq_zero hn\n  { toFun := fun\n      | ⟨⟨sr i, r _⟩, _⟩ => Sum.inl i\n      | ⟨⟨r _, sr j⟩, _⟩ => Sum.inr (Sum.inl j)\n      | ⟨⟨sr i, sr j⟩, _⟩ => Sum.inr (Sum.inr (Sum.inl (i + j)))\n      | ⟨⟨r i, r j⟩, _⟩ => Sum.inr (Sum.inr (Sum.inr ⟨i, j⟩))\n    invFun := fun\n      | .inl i => ⟨⟨sr i, r 0⟩, congrArg sr ((add_zero i).trans (sub_zero i).symm)⟩\n      | .inr (.inl j) => ⟨⟨r 0, sr j⟩, congrArg sr ((sub_zero j).trans (add_zero j).symm)⟩\n      | .inr (.inr (.inl k)) => ⟨⟨sr (u⁻¹ * k), sr (u⁻¹ * k)⟩, rfl⟩\n      | .inr (.inr (.inr ⟨i, j⟩)) => ⟨⟨r i, r j⟩, congrArg r (add_comm i j)⟩\n    left_inv := fun\n      | ⟨⟨r _, r _⟩, _⟩ => rfl\n      | ⟨⟨r i, sr j⟩, h⟩ => by\n        simpa [sub_eq_add_neg, neg_eq_iff_add_eq_zero, hu, eq_comm (a := i) (b := 0)] using h.eq\n      | ⟨⟨sr i, r j⟩, h⟩ => by\n        simpa [sub_eq_add_neg, eq_neg_iff_add_eq_zero, hu, eq_comm (a := j) (b := 0)] using h.eq\n      | ⟨⟨sr i, sr j⟩, h⟩ => by\n        replace h := r.inj h\n        rw [← neg_sub, neg_eq_iff_add_eq_zero, hu, sub_eq_zero] at h\n        rw [Subtype.ext_iff, Prod.ext_iff, sr.injEq, sr.injEq, h, and_self, ← two_mul]\n        exact u.inv_mul_cancel_left j\n    right_inv := fun\n      | .inl _ => rfl\n      | .inr (.inl _) => rfl\n      | .inr (.inr (.inl k)) =>\n        congrArg (Sum.inr ∘ Sum.inr ∘ Sum.inl) <| two_mul (u⁻¹ * k) ▸ u.mul_inv_cancel_left k\n      | .inr (.inr (.inr ⟨_, _⟩)) => rfl }\n\n"}
{"name":"DihedralGroup.card_commute_odd","module":"Mathlib.GroupTheory.SpecificGroups.Dihedral","initialProofState":"n : Nat\nhn : Odd n\n⊢ Eq (Nat.card (Subtype fun p => Commute p.1 p.2)) (HMul.hMul n (HAdd.hAdd n 3))","decl":"/-- If n is odd, then the Dihedral group of order $2n$ has $n(n+3)$ pairs of commuting elements. -/\nlemma card_commute_odd (hn : Odd n) :\n    Nat.card { p : DihedralGroup n × DihedralGroup n // Commute p.1 p.2 } = n * (n + 3) := by\n  have hn' : NeZero n := ⟨hn.pos.ne'⟩\n  simp_rw [Nat.card_congr (OddCommuteEquiv hn), Nat.card_sum, Nat.card_prod, Nat.card_zmod]\n  ring\n\n"}
{"name":"DihedralGroup.card_conjClasses_odd","module":"Mathlib.GroupTheory.SpecificGroups.Dihedral","initialProofState":"n : Nat\nhn : Odd n\n⊢ Eq (Nat.card (ConjClasses (DihedralGroup n))) (HDiv.hDiv (HAdd.hAdd n 3) 2)","decl":"lemma card_conjClasses_odd (hn : Odd n) :\n    Nat.card (ConjClasses (DihedralGroup n)) = (n + 3) / 2 := by\n  rw [← Nat.mul_div_mul_left _ 2 hn.pos, ← card_commute_odd hn, mul_comm,\n    card_comm_eq_card_conjClasses_mul_card, nat_card, Nat.mul_div_left _ (mul_pos two_pos hn.pos)]\n\n\n"}
