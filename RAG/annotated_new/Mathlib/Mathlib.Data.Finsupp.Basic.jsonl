{"name":"Finsupp.mk_mem_graph_iff","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\na : α\nm : M\nf : Finsupp α M\n⊢ Iff (Membership.mem f.graph { fst := a, snd := m }) (And (Eq (f a) m) (Ne m 0))","decl":"theorem mk_mem_graph_iff {a : α} {m : M} {f : α →₀ M} : (a, m) ∈ f.graph ↔ f a = m ∧ m ≠ 0 := by\n  simp_rw [graph, mem_map, mem_support_iff]\n  constructor\n  · rintro ⟨b, ha, rfl, -⟩\n    exact ⟨rfl, ha⟩\n  · rintro ⟨rfl, ha⟩\n    exact ⟨a, ha, rfl⟩\n\n"}
{"name":"Finsupp.mem_graph_iff","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\nc : Prod α M\nf : Finsupp α M\n⊢ Iff (Membership.mem f.graph c) (And (Eq (f c.1) c.2) (Ne c.2 0))","decl":"@[simp]\ntheorem mem_graph_iff {c : α × M} {f : α →₀ M} : c ∈ f.graph ↔ f c.1 = c.2 ∧ c.2 ≠ 0 := by\n  cases c\n  exact mk_mem_graph_iff\n\n"}
{"name":"Finsupp.mk_mem_graph","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\nf : Finsupp α M\na : α\nha : Membership.mem f.support a\n⊢ Membership.mem f.graph { fst := a, snd := f a }","decl":"theorem mk_mem_graph (f : α →₀ M) {a : α} (ha : a ∈ f.support) : (a, f a) ∈ f.graph :=\n  mk_mem_graph_iff.2 ⟨rfl, mem_support_iff.1 ha⟩\n\n"}
{"name":"Finsupp.apply_eq_of_mem_graph","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\na : α\nm : M\nf : Finsupp α M\nh : Membership.mem f.graph { fst := a, snd := m }\n⊢ Eq (f a) m","decl":"theorem apply_eq_of_mem_graph {a : α} {m : M} {f : α →₀ M} (h : (a, m) ∈ f.graph) : f a = m :=\n  (mem_graph_iff.1 h).1\n\n"}
{"name":"Finsupp.not_mem_graph_snd_zero","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\na : α\nf : Finsupp α M\n⊢ Not (Membership.mem f.graph { fst := a, snd := 0 })","decl":"@[simp 1100] -- Porting note: change priority to appease `simpNF`\ntheorem not_mem_graph_snd_zero (a : α) (f : α →₀ M) : (a, (0 : M)) ∉ f.graph := fun h =>\n  (mem_graph_iff.1 h).2.irrefl\n\n"}
{"name":"Finsupp.image_fst_graph","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝¹ : Zero M\ninst✝ : DecidableEq α\nf : Finsupp α M\n⊢ Eq (Finset.image Prod.fst f.graph) f.support","decl":"@[simp]\ntheorem image_fst_graph [DecidableEq α] (f : α →₀ M) : f.graph.image Prod.fst = f.support := by\n  classical\n  simp only [graph, map_eq_image, image_image, Embedding.coeFn_mk, Function.comp_def, image_id']\n\n"}
{"name":"Finsupp.graph_injective","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_13\nM : Type u_14\ninst✝ : Zero M\n⊢ Function.Injective Finsupp.graph","decl":"theorem graph_injective (α M) [Zero M] : Injective (@graph α M _) := by\n  intro f g h\n  classical\n    have hsup : f.support = g.support := by rw [← image_fst_graph, h, image_fst_graph]\n    refine ext_iff'.2 ⟨hsup, fun x hx => apply_eq_of_mem_graph <| h.symm ▸ ?_⟩\n    exact mk_mem_graph _ (hsup ▸ hx)\n\n"}
{"name":"Finsupp.graph_inj","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\nf g : Finsupp α M\n⊢ Iff (Eq f.graph g.graph) (Eq f g)","decl":"@[simp]\ntheorem graph_inj {f g : α →₀ M} : f.graph = g.graph ↔ f = g :=\n  (graph_injective α M).eq_iff\n\n"}
{"name":"Finsupp.graph_zero","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\n⊢ Eq (Finsupp.graph 0) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem graph_zero : graph (0 : α →₀ M) = ∅ := by simp [graph]\n\n"}
{"name":"Finsupp.graph_eq_empty","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\nf : Finsupp α M\n⊢ Iff (Eq f.graph EmptyCollection.emptyCollection) (Eq f 0)","decl":"@[simp]\ntheorem graph_eq_empty {f : α →₀ M} : f.graph = ∅ ↔ f = 0 :=\n  (graph_injective α M).eq_iff' graph_zero\n\n"}
{"name":"Finsupp.mapRange.equiv_apply","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\nN : Type u_7\ninst✝¹ : Zero M\ninst✝ : Zero N\nf : Equiv M N\nhf : Eq (f 0) 0\nhf' : Eq (f.symm 0) 0\ng : Finsupp α M\n⊢ Eq ((Finsupp.mapRange.equiv f hf hf') g) (Finsupp.mapRange (⇑f) hf g)","decl":"/-- `Finsupp.mapRange` as an equiv. -/\n@[simps apply]\ndef mapRange.equiv (f : M ≃ N) (hf : f 0 = 0) (hf' : f.symm 0 = 0) : (α →₀ M) ≃ (α →₀ N) where\n  toFun := (mapRange f hf : (α →₀ M) → α →₀ N)\n  invFun := (mapRange f.symm hf' : (α →₀ N) → α →₀ M)\n  left_inv x := by\n    rw [← mapRange_comp _ _ _ _] <;> simp_rw [Equiv.symm_comp_self]\n    · exact mapRange_id _\n    · rfl\n  right_inv x := by\n    rw [← mapRange_comp _ _ _ _] <;> simp_rw [Equiv.self_comp_symm]\n    · exact mapRange_id _\n    · rfl\n\n"}
{"name":"Finsupp.mapRange.equiv_refl","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\n⊢ Eq (Finsupp.mapRange.equiv (Equiv.refl M) ⋯ ⋯) (Equiv.refl (Finsupp α M))","decl":"@[simp]\ntheorem mapRange.equiv_refl : mapRange.equiv (Equiv.refl M) rfl rfl = Equiv.refl (α →₀ M) :=\n  Equiv.ext mapRange_id\n\n"}
{"name":"Finsupp.mapRange.equiv_trans","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\nN : Type u_7\nP : Type u_8\ninst✝² : Zero M\ninst✝¹ : Zero N\ninst✝ : Zero P\nf : Equiv M N\nhf : Eq (f 0) 0\nhf' : Eq (f.symm 0) 0\nf₂ : Equiv N P\nhf₂ : Eq (f₂ 0) 0\nhf₂' : Eq (f₂.symm 0) 0\n⊢ Eq (Finsupp.mapRange.equiv (f.trans f₂) ⋯ ⋯) ((Finsupp.mapRange.equiv f hf hf').trans (Finsupp.mapRange.equiv f₂ hf₂ hf₂'))","decl":"theorem mapRange.equiv_trans (f : M ≃ N) (hf : f 0 = 0) (hf') (f₂ : N ≃ P) (hf₂ : f₂ 0 = 0) (hf₂') :\n    (mapRange.equiv (f.trans f₂) (by rw [Equiv.trans_apply, hf, hf₂])\n          (by rw [Equiv.symm_trans_apply, hf₂', hf']) :\n        (α →₀ _) ≃ _) =\n      (mapRange.equiv f hf hf').trans (mapRange.equiv f₂ hf₂ hf₂') :=\n  Equiv.ext <| mapRange_comp f₂ hf₂ f hf ((congrArg f₂ hf).trans hf₂)\n\n"}
{"name":"Finsupp.mapRange.equiv_symm","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\nN : Type u_7\ninst✝¹ : Zero M\ninst✝ : Zero N\nf : Equiv M N\nhf : Eq (f 0) 0\nhf' : Eq (f.symm 0) 0\n⊢ Eq (Finsupp.mapRange.equiv f hf hf').symm (Finsupp.mapRange.equiv f.symm hf' hf)","decl":"@[simp]\ntheorem mapRange.equiv_symm (f : M ≃ N) (hf hf') :\n    ((mapRange.equiv f hf hf').symm : (α →₀ _) ≃ _) = mapRange.equiv f.symm hf' hf :=\n  Equiv.ext fun _ => rfl\n\n"}
{"name":"Finsupp.mapRange.zeroHom_apply","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\nN : Type u_7\ninst✝¹ : Zero M\ninst✝ : Zero N\nf : ZeroHom M N\ng : Finsupp α M\n⊢ Eq ((Finsupp.mapRange.zeroHom f) g) (Finsupp.mapRange ⇑f ⋯ g)","decl":"/-- Composition with a fixed zero-preserving homomorphism is itself a zero-preserving homomorphism\non functions. -/\n@[simps]\ndef mapRange.zeroHom (f : ZeroHom M N) : ZeroHom (α →₀ M) (α →₀ N) where\n  toFun := (mapRange f f.map_zero : (α →₀ M) → α →₀ N)\n  map_zero' := mapRange_zero\n\n"}
{"name":"Finsupp.mapRange.zeroHom_id","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\n⊢ Eq (Finsupp.mapRange.zeroHom (ZeroHom.id M)) (ZeroHom.id (Finsupp α M))","decl":"@[simp]\ntheorem mapRange.zeroHom_id : mapRange.zeroHom (ZeroHom.id M) = ZeroHom.id (α →₀ M) :=\n  ZeroHom.ext mapRange_id\n\n"}
{"name":"Finsupp.mapRange.zeroHom_comp","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\nN : Type u_7\nP : Type u_8\ninst✝² : Zero M\ninst✝¹ : Zero N\ninst✝ : Zero P\nf : ZeroHom N P\nf₂ : ZeroHom M N\n⊢ Eq (Finsupp.mapRange.zeroHom (f.comp f₂)) ((Finsupp.mapRange.zeroHom f).comp (Finsupp.mapRange.zeroHom f₂))","decl":"theorem mapRange.zeroHom_comp (f : ZeroHom N P) (f₂ : ZeroHom M N) :\n    (mapRange.zeroHom (f.comp f₂) : ZeroHom (α →₀ _) _) =\n      (mapRange.zeroHom f).comp (mapRange.zeroHom f₂) :=\n  ZeroHom.ext <| mapRange_comp f (map_zero f) f₂ (map_zero f₂) (by simp only [comp_apply, map_zero])\n\n"}
{"name":"Finsupp.mapRange.addMonoidHom_apply","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\nN : Type u_7\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid N\nf : AddMonoidHom M N\ng : Finsupp α M\n⊢ Eq ((Finsupp.mapRange.addMonoidHom f) g) (Finsupp.mapRange ⇑f ⋯ g)","decl":"/-- Composition with a fixed additive homomorphism is itself an additive homomorphism on functions.\n-/\n@[simps]\ndef mapRange.addMonoidHom (f : M →+ N) : (α →₀ M) →+ α →₀ N where\n  toFun := (mapRange f f.map_zero : (α →₀ M) → α →₀ N)\n  map_zero' := mapRange_zero\n  map_add' a b := by dsimp only; exact mapRange_add f.map_add _ _; -- Porting note: `dsimp` needed\n\n"}
{"name":"Finsupp.mapRange.addMonoidHom_id","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddCommMonoid M\n⊢ Eq (Finsupp.mapRange.addMonoidHom (AddMonoidHom.id M)) (AddMonoidHom.id (Finsupp α M))","decl":"@[simp]\ntheorem mapRange.addMonoidHom_id :\n    mapRange.addMonoidHom (AddMonoidHom.id M) = AddMonoidHom.id (α →₀ M) :=\n  AddMonoidHom.ext mapRange_id\n\n"}
{"name":"Finsupp.mapRange.addMonoidHom_comp","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\nN : Type u_7\nP : Type u_8\ninst✝² : AddCommMonoid M\ninst✝¹ : AddCommMonoid N\ninst✝ : AddCommMonoid P\nf : AddMonoidHom N P\nf₂ : AddMonoidHom M N\n⊢ Eq (Finsupp.mapRange.addMonoidHom (f.comp f₂)) ((Finsupp.mapRange.addMonoidHom f).comp (Finsupp.mapRange.addMonoidHom f₂))","decl":"theorem mapRange.addMonoidHom_comp (f : N →+ P) (f₂ : M →+ N) :\n    (mapRange.addMonoidHom (f.comp f₂) : (α →₀ _) →+ _) =\n      (mapRange.addMonoidHom f).comp (mapRange.addMonoidHom f₂) :=\n  AddMonoidHom.ext <|\n    mapRange_comp f (map_zero f) f₂ (map_zero f₂) (by simp only [comp_apply, map_zero])\n\n"}
{"name":"Finsupp.mapRange.addMonoidHom_toZeroHom","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\nN : Type u_7\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid N\nf : AddMonoidHom M N\n⊢ Eq (↑(Finsupp.mapRange.addMonoidHom f)) (Finsupp.mapRange.zeroHom ↑f)","decl":"@[simp]\ntheorem mapRange.addMonoidHom_toZeroHom (f : M →+ N) :\n    (mapRange.addMonoidHom f).toZeroHom = (mapRange.zeroHom f.toZeroHom : ZeroHom (α →₀ _) _) :=\n  ZeroHom.ext fun _ => rfl\n\n"}
{"name":"Finsupp.mapRange_multiset_sum","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\nN : Type u_7\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\nF : Type u_13\ninst✝¹ : FunLike F M N\ninst✝ : AddMonoidHomClass F M N\nf : F\nm : Multiset (Finsupp α M)\n⊢ Eq (Finsupp.mapRange ⇑f ⋯ m.sum) (Multiset.map (fun x => Finsupp.mapRange ⇑f ⋯ x) m).sum","decl":"theorem mapRange_multiset_sum (f : F) (m : Multiset (α →₀ M)) :\n    mapRange f (map_zero f) m.sum = (m.map fun x => mapRange f (map_zero f) x).sum :=\n  (mapRange.addMonoidHom (f : M →+ N) : (α →₀ _) →+ _).map_multiset_sum _\n\n"}
{"name":"Finsupp.mapRange_finset_sum","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nι : Type u_4\nM : Type u_5\nN : Type u_7\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\nF : Type u_13\ninst✝¹ : FunLike F M N\ninst✝ : AddMonoidHomClass F M N\nf : F\ns : Finset ι\ng : ι → Finsupp α M\n⊢ Eq (Finsupp.mapRange ⇑f ⋯ (s.sum fun x => g x)) (s.sum fun x => Finsupp.mapRange ⇑f ⋯ (g x))","decl":"theorem mapRange_finset_sum (f : F) (s : Finset ι) (g : ι → α →₀ M) :\n    mapRange f (map_zero f) (∑ x ∈ s, g x) = ∑ x ∈ s, mapRange f (map_zero f) (g x) :=\n  map_sum (mapRange.addMonoidHom (f : M →+ N)) _ _\n\n"}
{"name":"Finsupp.mapRange.addEquiv_apply","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\nN : Type u_7\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid N\nf : AddEquiv M N\ng : Finsupp α M\n⊢ Eq ((Finsupp.mapRange.addEquiv f) g) (Finsupp.mapRange ⇑f ⋯ g)","decl":"/-- `Finsupp.mapRange.AddMonoidHom` as an equiv. -/\n@[simps apply]\ndef mapRange.addEquiv (f : M ≃+ N) : (α →₀ M) ≃+ (α →₀ N) :=\n  { mapRange.addMonoidHom f.toAddMonoidHom with\n    toFun := (mapRange f f.map_zero : (α →₀ M) → α →₀ N)\n    invFun := (mapRange f.symm f.symm.map_zero : (α →₀ N) → α →₀ M)\n    left_inv := fun x => by\n      rw [← mapRange_comp _ _ _ _] <;> simp_rw [AddEquiv.symm_comp_self]\n      · exact mapRange_id _\n      · rfl\n    right_inv := fun x => by\n      rw [← mapRange_comp _ _ _ _] <;> simp_rw [AddEquiv.self_comp_symm]\n      · exact mapRange_id _\n      · rfl }\n\n"}
{"name":"Finsupp.mapRange.addEquiv_refl","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddCommMonoid M\n⊢ Eq (Finsupp.mapRange.addEquiv (AddEquiv.refl M)) (AddEquiv.refl (Finsupp α M))","decl":"@[simp]\ntheorem mapRange.addEquiv_refl : mapRange.addEquiv (AddEquiv.refl M) = AddEquiv.refl (α →₀ M) :=\n  AddEquiv.ext mapRange_id\n\n"}
{"name":"Finsupp.mapRange.addEquiv_trans","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\nN : Type u_7\nP : Type u_8\ninst✝² : AddCommMonoid M\ninst✝¹ : AddCommMonoid N\ninst✝ : AddCommMonoid P\nf : AddEquiv M N\nf₂ : AddEquiv N P\n⊢ Eq (Finsupp.mapRange.addEquiv (f.trans f₂)) ((Finsupp.mapRange.addEquiv f).trans (Finsupp.mapRange.addEquiv f₂))","decl":"theorem mapRange.addEquiv_trans (f : M ≃+ N) (f₂ : N ≃+ P) :\n    (mapRange.addEquiv (f.trans f₂) : (α →₀ M) ≃+ (α →₀ P)) =\n      (mapRange.addEquiv f).trans (mapRange.addEquiv f₂) :=\n  AddEquiv.ext (mapRange_comp _ f₂.map_zero _ f.map_zero (by simp))\n\n"}
{"name":"Finsupp.mapRange.addEquiv_symm","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\nN : Type u_7\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid N\nf : AddEquiv M N\n⊢ Eq (Finsupp.mapRange.addEquiv f).symm (Finsupp.mapRange.addEquiv f.symm)","decl":"@[simp]\ntheorem mapRange.addEquiv_symm (f : M ≃+ N) :\n    ((mapRange.addEquiv f).symm : (α →₀ _) ≃+ _) = mapRange.addEquiv f.symm :=\n  AddEquiv.ext fun _ => rfl\n\n"}
{"name":"Finsupp.mapRange.addEquiv_toAddMonoidHom","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\nN : Type u_7\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid N\nf : AddEquiv M N\n⊢ Eq (↑(Finsupp.mapRange.addEquiv f)) (Finsupp.mapRange.addMonoidHom f.toAddMonoidHom)","decl":"@[simp]\ntheorem mapRange.addEquiv_toAddMonoidHom (f : M ≃+ N) :\n    ((mapRange.addEquiv f : (α →₀ _) ≃+ _) : _ →+ _) =\n      (mapRange.addMonoidHom f.toAddMonoidHom : (α →₀ _) →+ _) :=\n  AddMonoidHom.ext fun _ => rfl\n\n"}
{"name":"Finsupp.mapRange.addEquiv_toEquiv","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\nN : Type u_7\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid N\nf : AddEquiv M N\n⊢ Eq (↑(Finsupp.mapRange.addEquiv f)) (Finsupp.mapRange.equiv ↑f ⋯ ⋯)","decl":"@[simp]\ntheorem mapRange.addEquiv_toEquiv (f : M ≃+ N) :\n    ↑(mapRange.addEquiv f : (α →₀ _) ≃+ _) =\n      (mapRange.equiv (f : M ≃ N) f.map_zero f.symm.map_zero : (α →₀ _) ≃ _) :=\n  Equiv.ext fun _ => rfl\n\n"}
{"name":"Finsupp.equivMapDomain_apply","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : Zero M\nf : Equiv α β\nl : Finsupp α M\nb : β\n⊢ Eq ((Finsupp.equivMapDomain f l) b) (l (f.symm b))","decl":"@[simp]\ntheorem equivMapDomain_apply (f : α ≃ β) (l : α →₀ M) (b : β) :\n    equivMapDomain f l b = l (f.symm b) :=\n  rfl\n\n"}
{"name":"Finsupp.equivMapDomain_symm_apply","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : Zero M\nf : Equiv α β\nl : Finsupp β M\na : α\n⊢ Eq ((Finsupp.equivMapDomain f.symm l) a) (l (f a))","decl":"theorem equivMapDomain_symm_apply (f : α ≃ β) (l : β →₀ M) (a : α) :\n    equivMapDomain f.symm l a = l (f a) :=\n  rfl\n\n"}
{"name":"Finsupp.equivMapDomain_refl","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\nl : Finsupp α M\n⊢ Eq (Finsupp.equivMapDomain (Equiv.refl α) l) l","decl":"@[simp]\ntheorem equivMapDomain_refl (l : α →₀ M) : equivMapDomain (Equiv.refl _) l = l := by ext x; rfl\n\n"}
{"name":"Finsupp.equivMapDomain_refl'","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\n⊢ Eq (Finsupp.equivMapDomain (Equiv.refl α)) id","decl":"theorem equivMapDomain_refl' : equivMapDomain (Equiv.refl _) = @id (α →₀ M) := by ext x; rfl\n\n"}
{"name":"Finsupp.equivMapDomain_trans","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nM : Type u_5\ninst✝ : Zero M\nf : Equiv α β\ng : Equiv β γ\nl : Finsupp α M\n⊢ Eq (Finsupp.equivMapDomain (f.trans g) l) (Finsupp.equivMapDomain g (Finsupp.equivMapDomain f l))","decl":"theorem equivMapDomain_trans (f : α ≃ β) (g : β ≃ γ) (l : α →₀ M) :\n    equivMapDomain (f.trans g) l = equivMapDomain g (equivMapDomain f l) := by ext x; rfl\n\n"}
{"name":"Finsupp.equivMapDomain_trans'","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nM : Type u_5\ninst✝ : Zero M\nf : Equiv α β\ng : Equiv β γ\n⊢ Eq (Finsupp.equivMapDomain (f.trans g)) (Function.comp (Finsupp.equivMapDomain g) (Finsupp.equivMapDomain f))","decl":"theorem equivMapDomain_trans' (f : α ≃ β) (g : β ≃ γ) :\n    @equivMapDomain _ _ M _ (f.trans g) = equivMapDomain g ∘ equivMapDomain f := by ext x; rfl\n\n"}
{"name":"Finsupp.equivMapDomain_single","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : Zero M\nf : Equiv α β\na : α\nb : M\n⊢ Eq (Finsupp.equivMapDomain f (Finsupp.single a b)) (Finsupp.single (f a) b)","decl":"@[simp]\ntheorem equivMapDomain_single (f : α ≃ β) (a : α) (b : M) :\n    equivMapDomain f (single a b) = single (f a) b := by\n  classical\n    ext x\n    simp only [single_apply, Equiv.apply_eq_iff_eq_symm_apply, equivMapDomain_apply]\n\n"}
{"name":"Finsupp.equivMapDomain_zero","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : Zero M\nf : Equiv α β\n⊢ Eq (Finsupp.equivMapDomain f 0) 0","decl":"@[simp]\ntheorem equivMapDomain_zero {f : α ≃ β} : equivMapDomain f (0 : α →₀ M) = (0 : β →₀ M) := by\n  ext; simp only [equivMapDomain_apply, coe_zero, Pi.zero_apply]\n\n"}
{"name":"Finsupp.prod_equivMapDomain","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\nN : Type u_7\ninst✝¹ : Zero M\ninst✝ : CommMonoid N\nf : Equiv α β\nl : Finsupp α M\ng : β → M → N\n⊢ Eq ((Finsupp.equivMapDomain f l).prod g) (l.prod fun a m => g (f a) m)","decl":"@[to_additive (attr := simp)]\ntheorem prod_equivMapDomain [CommMonoid N] (f : α ≃ β) (l : α →₀ M) (g : β → M → N) :\n    prod (equivMapDomain f l) g = prod l (fun a m => g (f a) m) := by\n  simp [prod, equivMapDomain]\n\n"}
{"name":"Finsupp.sum_equivMapDomain","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\nN : Type u_7\ninst✝¹ : Zero M\ninst✝ : AddCommMonoid N\nf : Equiv α β\nl : Finsupp α M\ng : β → M → N\n⊢ Eq ((Finsupp.equivMapDomain f l).sum g) (l.sum fun a m => g (f a) m)","decl":"@[to_additive (attr := simp)]\ntheorem prod_equivMapDomain [CommMonoid N] (f : α ≃ β) (l : α →₀ M) (g : β → M → N) :\n    prod (equivMapDomain f l) g = prod l (fun a m => g (f a) m) := by\n  simp [prod, equivMapDomain]\n\n"}
{"name":"Finsupp.equivCongrLeft_apply","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : Zero M\nf : Equiv α β\nl : Finsupp α M\n⊢ Eq ((Finsupp.equivCongrLeft f) l) (Finsupp.equivMapDomain f l)","decl":"@[simp]\ntheorem equivCongrLeft_apply (f : α ≃ β) (l : α →₀ M) : equivCongrLeft f l = equivMapDomain f l :=\n  rfl\n\n"}
{"name":"Finsupp.equivCongrLeft_symm","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : Zero M\nf : Equiv α β\n⊢ Eq (Finsupp.equivCongrLeft f).symm (Finsupp.equivCongrLeft f.symm)","decl":"@[simp]\ntheorem equivCongrLeft_symm (f : α ≃ β) :\n    (@equivCongrLeft _ _ M _ f).symm = equivCongrLeft f.symm :=\n  rfl\n\n"}
{"name":"Nat.cast_finsupp_prod","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\nR : Type u_11\ninst✝¹ : Zero M\nf : Finsupp α M\ninst✝ : CommSemiring R\ng : α → M → Nat\n⊢ Eq (↑(f.prod g)) (f.prod fun a b => ↑(g a b))","decl":"@[simp, norm_cast]\ntheorem cast_finsupp_prod [CommSemiring R] (g : α → M → ℕ) :\n    (↑(f.prod g) : R) = f.prod fun a b => ↑(g a b) :=\n  Nat.cast_prod _ _\n\n"}
{"name":"Nat.cast_finsupp_sum","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\nR : Type u_11\ninst✝¹ : Zero M\nf : Finsupp α M\ninst✝ : CommSemiring R\ng : α → M → Nat\n⊢ Eq (↑(f.sum g)) (f.sum fun a b => ↑(g a b))","decl":"@[simp, norm_cast]\ntheorem cast_finsupp_sum [CommSemiring R] (g : α → M → ℕ) :\n    (↑(f.sum g) : R) = f.sum fun a b => ↑(g a b) :=\n  Nat.cast_sum _ _\n\n"}
{"name":"Int.cast_finsupp_prod","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\nR : Type u_11\ninst✝¹ : Zero M\nf : Finsupp α M\ninst✝ : CommRing R\ng : α → M → Int\n⊢ Eq (↑(f.prod g)) (f.prod fun a b => ↑(g a b))","decl":"@[simp, norm_cast]\ntheorem cast_finsupp_prod [CommRing R] (g : α → M → ℤ) :\n    (↑(f.prod g) : R) = f.prod fun a b => ↑(g a b) :=\n  Int.cast_prod _ _\n\n"}
{"name":"Int.cast_finsupp_sum","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\nR : Type u_11\ninst✝¹ : Zero M\nf : Finsupp α M\ninst✝ : CommRing R\ng : α → M → Int\n⊢ Eq (↑(f.sum g)) (f.sum fun a b => ↑(g a b))","decl":"@[simp, norm_cast]\ntheorem cast_finsupp_sum [CommRing R] (g : α → M → ℤ) :\n    (↑(f.sum g) : R) = f.sum fun a b => ↑(g a b) :=\n  Int.cast_sum _ _\n\n"}
{"name":"Rat.cast_finsupp_sum","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\nR : Type u_11\ninst✝² : Zero M\nf : Finsupp α M\ninst✝¹ : DivisionRing R\ninst✝ : CharZero R\ng : α → M → Rat\n⊢ Eq (↑(f.sum g)) (f.sum fun a b => ↑(g a b))","decl":"@[simp, norm_cast]\ntheorem cast_finsupp_sum [DivisionRing R] [CharZero R] (g : α → M → ℚ) :\n    (↑(f.sum g) : R) = f.sum fun a b => ↑(g a b) :=\n  cast_sum _ _\n\n"}
{"name":"Rat.cast_finsupp_prod","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\nR : Type u_11\ninst✝² : Zero M\nf : Finsupp α M\ninst✝¹ : Field R\ninst✝ : CharZero R\ng : α → M → Rat\n⊢ Eq (↑(f.prod g)) (f.prod fun a b => ↑(g a b))","decl":"@[simp, norm_cast]\ntheorem cast_finsupp_prod [Field R] [CharZero R] (g : α → M → ℚ) :\n    (↑(f.prod g) : R) = f.prod fun a b => ↑(g a b) :=\n  cast_prod _ _\n\n"}
{"name":"Finsupp.mapDomain_apply","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : α → β\nhf : Function.Injective f\nx : Finsupp α M\na : α\n⊢ Eq ((Finsupp.mapDomain f x) (f a)) (x a)","decl":"theorem mapDomain_apply {f : α → β} (hf : Function.Injective f) (x : α →₀ M) (a : α) :\n    mapDomain f x (f a) = x a := by\n  rw [mapDomain, sum_apply, sum_eq_single a, single_eq_same]\n  · intro b _ hba\n    exact single_eq_of_ne (hf.ne hba)\n  · intro _\n    rw [single_zero, coe_zero, Pi.zero_apply]\n\n"}
{"name":"Finsupp.mapDomain_notin_range","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : α → β\nx : Finsupp α M\na : β\nh : Not (Membership.mem (Set.range f) a)\n⊢ Eq ((Finsupp.mapDomain f x) a) 0","decl":"theorem mapDomain_notin_range {f : α → β} (x : α →₀ M) (a : β) (h : a ∉ Set.range f) :\n    mapDomain f x a = 0 := by\n  rw [mapDomain, sum_apply, sum]\n  exact Finset.sum_eq_zero fun a' _ => single_eq_of_ne fun eq => h <| eq ▸ Set.mem_range_self _\n\n"}
{"name":"Finsupp.mapDomain_id","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddCommMonoid M\nv : Finsupp α M\n⊢ Eq (Finsupp.mapDomain id v) v","decl":"@[simp]\ntheorem mapDomain_id : mapDomain id v = v :=\n  sum_single _\n\n"}
{"name":"Finsupp.mapDomain_comp","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nM : Type u_5\ninst✝ : AddCommMonoid M\nv : Finsupp α M\nf : α → β\ng : β → γ\n⊢ Eq (Finsupp.mapDomain (Function.comp g f) v) (Finsupp.mapDomain g (Finsupp.mapDomain f v))","decl":"theorem mapDomain_comp {f : α → β} {g : β → γ} :\n    mapDomain (g ∘ f) v = mapDomain g (mapDomain f v) := by\n  refine ((sum_sum_index ?_ ?_).trans ?_).symm\n  · intro\n    exact single_zero _\n  · intro\n    exact single_add _\n  refine sum_congr fun _ _ => sum_single_index ?_\n  exact single_zero _\n\n"}
{"name":"Finsupp.mapDomain_single","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : α → β\na : α\nb : M\n⊢ Eq (Finsupp.mapDomain f (Finsupp.single a b)) (Finsupp.single (f a) b)","decl":"@[simp]\ntheorem mapDomain_single {f : α → β} {a : α} {b : M} : mapDomain f (single a b) = single (f a) b :=\n  sum_single_index <| single_zero _\n\n"}
{"name":"Finsupp.mapDomain_zero","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : α → β\n⊢ Eq (Finsupp.mapDomain f 0) 0","decl":"@[simp]\ntheorem mapDomain_zero {f : α → β} : mapDomain f (0 : α →₀ M) = (0 : β →₀ M) :=\n  sum_zero_index\n\n"}
{"name":"Finsupp.mapDomain_congr","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : AddCommMonoid M\nv : Finsupp α M\nf g : α → β\nh : ∀ (x : α), Membership.mem v.support x → Eq (f x) (g x)\n⊢ Eq (Finsupp.mapDomain f v) (Finsupp.mapDomain g v)","decl":"theorem mapDomain_congr {f g : α → β} (h : ∀ x ∈ v.support, f x = g x) :\n    v.mapDomain f = v.mapDomain g :=\n  Finset.sum_congr rfl fun _ H => by simp only [h _ H]\n\n"}
{"name":"Finsupp.mapDomain_add","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : AddCommMonoid M\nv₁ v₂ : Finsupp α M\nf : α → β\n⊢ Eq (Finsupp.mapDomain f (HAdd.hAdd v₁ v₂)) (HAdd.hAdd (Finsupp.mapDomain f v₁) (Finsupp.mapDomain f v₂))","decl":"theorem mapDomain_add {f : α → β} : mapDomain f (v₁ + v₂) = mapDomain f v₁ + mapDomain f v₂ :=\n  sum_add_index' (fun _ => single_zero _) fun _ => single_add _\n\n"}
{"name":"Finsupp.mapDomain_equiv_apply","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : Equiv α β\nx : Finsupp α M\na : β\n⊢ Eq ((Finsupp.mapDomain (⇑f) x) a) (x (f.symm a))","decl":"@[simp]\ntheorem mapDomain_equiv_apply {f : α ≃ β} (x : α →₀ M) (a : β) :\n    mapDomain f x a = x (f.symm a) := by\n  conv_lhs => rw [← f.apply_symm_apply a]\n  exact mapDomain_apply f.injective _ _\n\n"}
{"name":"Finsupp.mapDomain.addMonoidHom_apply","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : α → β\nv : Finsupp α M\n⊢ Eq ((Finsupp.mapDomain.addMonoidHom f) v) (Finsupp.mapDomain f v)","decl":"/-- `Finsupp.mapDomain` is an `AddMonoidHom`. -/\n@[simps]\ndef mapDomain.addMonoidHom (f : α → β) : (α →₀ M) →+ β →₀ M where\n  toFun := mapDomain f\n  map_zero' := mapDomain_zero\n  map_add' _ _ := mapDomain_add\n\n"}
{"name":"Finsupp.mapDomain.addMonoidHom_id","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddCommMonoid M\n⊢ Eq (Finsupp.mapDomain.addMonoidHom id) (AddMonoidHom.id (Finsupp α M))","decl":"@[simp]\ntheorem mapDomain.addMonoidHom_id : mapDomain.addMonoidHom id = AddMonoidHom.id (α →₀ M) :=\n  AddMonoidHom.ext fun _ => mapDomain_id\n\n"}
{"name":"Finsupp.mapDomain.addMonoidHom_comp","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : β → γ\ng : α → β\n⊢ Eq (Finsupp.mapDomain.addMonoidHom (Function.comp f g)) ((Finsupp.mapDomain.addMonoidHom f).comp (Finsupp.mapDomain.addMonoidHom g))","decl":"theorem mapDomain.addMonoidHom_comp (f : β → γ) (g : α → β) :\n    (mapDomain.addMonoidHom (f ∘ g) : (α →₀ M) →+ γ →₀ M) =\n      (mapDomain.addMonoidHom f).comp (mapDomain.addMonoidHom g) :=\n  AddMonoidHom.ext fun _ => mapDomain_comp\n\n"}
{"name":"Finsupp.mapDomain_finset_sum","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Type u_4\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : α → β\ns : Finset ι\nv : ι → Finsupp α M\n⊢ Eq (Finsupp.mapDomain f (s.sum fun i => v i)) (s.sum fun i => Finsupp.mapDomain f (v i))","decl":"theorem mapDomain_finset_sum {f : α → β} {s : Finset ι} {v : ι → α →₀ M} :\n    mapDomain f (∑ i ∈ s, v i) = ∑ i ∈ s, mapDomain f (v i) :=\n  map_sum (mapDomain.addMonoidHom f) _ _\n\n"}
{"name":"Finsupp.mapDomain_sum","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\nN : Type u_7\ninst✝¹ : AddCommMonoid M\ninst✝ : Zero N\nf : α → β\ns : Finsupp α N\nv : α → N → Finsupp α M\n⊢ Eq (Finsupp.mapDomain f (s.sum v)) (s.sum fun a b => Finsupp.mapDomain f (v a b))","decl":"theorem mapDomain_sum [Zero N] {f : α → β} {s : α →₀ N} {v : α → N → α →₀ M} :\n    mapDomain f (s.sum v) = s.sum fun a b => mapDomain f (v a b) :=\n  map_finsupp_sum (mapDomain.addMonoidHom f : (α →₀ M) →+ β →₀ M) _ _\n\n"}
{"name":"Finsupp.mapDomain_support","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝¹ : AddCommMonoid M\ninst✝ : DecidableEq β\nf : α → β\ns : Finsupp α M\n⊢ HasSubset.Subset (Finsupp.mapDomain f s).support (Finset.image f s.support)","decl":"theorem mapDomain_support [DecidableEq β] {f : α → β} {s : α →₀ M} :\n    (s.mapDomain f).support ⊆ s.support.image f :=\n  Finset.Subset.trans support_sum <|\n    Finset.Subset.trans (Finset.biUnion_mono fun _ _ => support_single_subset) <| by\n      rw [Finset.biUnion_singleton]\n\n"}
{"name":"Finsupp.mapDomain_apply'","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : AddCommMonoid M\nS : Set α\nf : α → β\nx : Finsupp α M\nhS : HasSubset.Subset (↑x.support) S\nhf : Set.InjOn f S\na : α\nha : Membership.mem S a\n⊢ Eq ((Finsupp.mapDomain f x) (f a)) (x a)","decl":"theorem mapDomain_apply' (S : Set α) {f : α → β} (x : α →₀ M) (hS : (x.support : Set α) ⊆ S)\n    (hf : Set.InjOn f S) {a : α} (ha : a ∈ S) : mapDomain f x (f a) = x a := by\n  classical\n    rw [mapDomain, sum_apply, sum]\n    simp_rw [single_apply]\n    by_cases hax : a ∈ x.support\n    · rw [← Finset.add_sum_erase _ _ hax, if_pos rfl]\n      convert add_zero (x a)\n      refine Finset.sum_eq_zero fun i hi => if_neg ?_\n      exact (hf.mono hS).ne (Finset.mem_of_mem_erase hi) hax (Finset.ne_of_mem_erase hi)\n    · rw [not_mem_support_iff.1 hax]\n      refine Finset.sum_eq_zero fun i hi => if_neg ?_\n      exact hf.ne (hS hi) ha (ne_of_mem_of_not_mem hi hax)\n\n"}
{"name":"Finsupp.mapDomain_support_of_injOn","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝¹ : AddCommMonoid M\ninst✝ : DecidableEq β\nf : α → β\ns : Finsupp α M\nhf : Set.InjOn f ↑s.support\n⊢ Eq (Finsupp.mapDomain f s).support (Finset.image f s.support)","decl":"theorem mapDomain_support_of_injOn [DecidableEq β] {f : α → β} (s : α →₀ M)\n    (hf : Set.InjOn f s.support) : (mapDomain f s).support = Finset.image f s.support :=\n  Finset.Subset.antisymm mapDomain_support <| by\n    intro x hx\n    simp only [mem_image, exists_prop, mem_support_iff, Ne] at hx\n    rcases hx with ⟨hx_w, hx_h_left, rfl⟩\n    simp only [mem_support_iff, Ne]\n    rw [mapDomain_apply' (↑s.support : Set _) _ _ hf]\n    · exact hx_h_left\n    · simp only [mem_coe, mem_support_iff, Ne]\n      exact hx_h_left\n    · exact Subset.refl _\n\n"}
{"name":"Finsupp.mapDomain_support_of_injective","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝¹ : AddCommMonoid M\ninst✝ : DecidableEq β\nf : α → β\nhf : Function.Injective f\ns : Finsupp α M\n⊢ Eq (Finsupp.mapDomain f s).support (Finset.image f s.support)","decl":"theorem mapDomain_support_of_injective [DecidableEq β] {f : α → β} (hf : Function.Injective f)\n    (s : α →₀ M) : (mapDomain f s).support = Finset.image f s.support :=\n  mapDomain_support_of_injOn s hf.injOn\n\n"}
{"name":"Finsupp.sum_mapDomain_index","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\nN : Type u_7\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid N\nf : α → β\ns : Finsupp α M\nh : β → M → N\nh_zero : ∀ (b : β), Eq (h b 0) 0\nh_add : ∀ (b : β) (m₁ m₂ : M), Eq (h b (HAdd.hAdd m₁ m₂)) (HAdd.hAdd (h b m₁) (h b m₂))\n⊢ Eq ((Finsupp.mapDomain f s).sum h) (s.sum fun a m => h (f a) m)","decl":"@[to_additive]\ntheorem prod_mapDomain_index [CommMonoid N] {f : α → β} {s : α →₀ M} {h : β → M → N}\n    (h_zero : ∀ b, h b 0 = 1) (h_add : ∀ b m₁ m₂, h b (m₁ + m₂) = h b m₁ * h b m₂) :\n    (mapDomain f s).prod h = s.prod fun a m => h (f a) m :=\n  (prod_sum_index h_zero h_add).trans <| prod_congr fun _ _ => prod_single_index (h_zero _)\n\n-- Note that in `prod_mapDomain_index`, `M` is still an additive monoid,\n-- so there is no analogous version in terms of `MonoidHom`.\n"}
{"name":"Finsupp.prod_mapDomain_index","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\nN : Type u_7\ninst✝¹ : AddCommMonoid M\ninst✝ : CommMonoid N\nf : α → β\ns : Finsupp α M\nh : β → M → N\nh_zero : ∀ (b : β), Eq (h b 0) 1\nh_add : ∀ (b : β) (m₁ m₂ : M), Eq (h b (HAdd.hAdd m₁ m₂)) (HMul.hMul (h b m₁) (h b m₂))\n⊢ Eq ((Finsupp.mapDomain f s).prod h) (s.prod fun a m => h (f a) m)","decl":"@[to_additive]\ntheorem prod_mapDomain_index [CommMonoid N] {f : α → β} {s : α →₀ M} {h : β → M → N}\n    (h_zero : ∀ b, h b 0 = 1) (h_add : ∀ b m₁ m₂, h b (m₁ + m₂) = h b m₁ * h b m₂) :\n    (mapDomain f s).prod h = s.prod fun a m => h (f a) m :=\n  (prod_sum_index h_zero h_add).trans <| prod_congr fun _ _ => prod_single_index (h_zero _)\n\n-- Note that in `prod_mapDomain_index`, `M` is still an additive monoid,\n-- so there is no analogous version in terms of `MonoidHom`.\n"}
{"name":"Finsupp.sum_mapDomain_index_addMonoidHom","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\nN : Type u_7\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid N\nf : α → β\ns : Finsupp α M\nh : β → AddMonoidHom M N\n⊢ Eq ((Finsupp.mapDomain f s).sum fun b m => (h b) m) (s.sum fun a m => (h (f a)) m)","decl":"/-- A version of `sum_mapDomain_index` that takes a bundled `AddMonoidHom`,\nrather than separate linearity hypotheses.\n-/\n@[simp]\ntheorem sum_mapDomain_index_addMonoidHom [AddCommMonoid N] {f : α → β} {s : α →₀ M}\n    (h : β → M →+ N) : ((mapDomain f s).sum fun b m => h b m) = s.sum fun a m => h (f a) m :=\n  sum_mapDomain_index (fun b => (h b).map_zero) (fun b _ _ => (h b).map_add _ _)\n\n"}
{"name":"Finsupp.embDomain_eq_mapDomain","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : Function.Embedding α β\nv : Finsupp α M\n⊢ Eq (Finsupp.embDomain f v) (Finsupp.mapDomain (⇑f) v)","decl":"theorem embDomain_eq_mapDomain (f : α ↪ β) (v : α →₀ M) : embDomain f v = mapDomain f v := by\n  ext a\n  by_cases h : a ∈ Set.range f\n  · rcases h with ⟨a, rfl⟩\n    rw [mapDomain_apply f.injective, embDomain_apply]\n  · rw [mapDomain_notin_range, embDomain_notin_range] <;> assumption\n\n"}
{"name":"Finsupp.prod_mapDomain_index_inj","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\nN : Type u_7\ninst✝¹ : AddCommMonoid M\ninst✝ : CommMonoid N\nf : α → β\ns : Finsupp α M\nh : β → M → N\nhf : Function.Injective f\n⊢ Eq ((Finsupp.mapDomain f s).prod h) (s.prod fun a b => h (f a) b)","decl":"@[to_additive]\ntheorem prod_mapDomain_index_inj [CommMonoid N] {f : α → β} {s : α →₀ M} {h : β → M → N}\n    (hf : Function.Injective f) : (s.mapDomain f).prod h = s.prod fun a b => h (f a) b := by\n  rw [← Function.Embedding.coeFn_mk f hf, ← embDomain_eq_mapDomain, prod_embDomain]\n\n"}
{"name":"Finsupp.sum_mapDomain_index_inj","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\nN : Type u_7\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid N\nf : α → β\ns : Finsupp α M\nh : β → M → N\nhf : Function.Injective f\n⊢ Eq ((Finsupp.mapDomain f s).sum h) (s.sum fun a b => h (f a) b)","decl":"@[to_additive]\ntheorem prod_mapDomain_index_inj [CommMonoid N] {f : α → β} {s : α →₀ M} {h : β → M → N}\n    (hf : Function.Injective f) : (s.mapDomain f).prod h = s.prod fun a b => h (f a) b := by\n  rw [← Function.Embedding.coeFn_mk f hf, ← embDomain_eq_mapDomain, prod_embDomain]\n\n"}
{"name":"Finsupp.mapDomain_injective","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : α → β\nhf : Function.Injective f\n⊢ Function.Injective (Finsupp.mapDomain f)","decl":"theorem mapDomain_injective {f : α → β} (hf : Function.Injective f) :\n    Function.Injective (mapDomain f : (α →₀ M) → β →₀ M) := by\n  intro v₁ v₂ eq\n  ext a\n  have : mapDomain f v₁ (f a) = mapDomain f v₂ (f a) := by rw [eq]\n  rwa [mapDomain_apply hf, mapDomain_apply hf] at this\n\n"}
{"name":"Finsupp.mapDomainEmbedding_apply","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_13\nβ : Type u_14\nf : Function.Embedding α β\nv : Finsupp α Nat\n⊢ Eq ((Finsupp.mapDomainEmbedding f) v) (Finsupp.mapDomain (⇑f) v)","decl":"/-- When `f` is an embedding we have an embedding `(α →₀ ℕ) ↪ (β →₀ ℕ)` given by `mapDomain`. -/\n@[simps]\ndef mapDomainEmbedding {α β : Type*} (f : α ↪ β) : (α →₀ ℕ) ↪ β →₀ ℕ :=\n  ⟨Finsupp.mapDomain f, Finsupp.mapDomain_injective f.injective⟩\n\n"}
{"name":"Finsupp.mapDomain.addMonoidHom_comp_mapRange","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\nN : Type u_7\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid N\nf : α → β\ng : AddMonoidHom M N\n⊢ Eq ((Finsupp.mapDomain.addMonoidHom f).comp (Finsupp.mapRange.addMonoidHom g)) ((Finsupp.mapRange.addMonoidHom g).comp (Finsupp.mapDomain.addMonoidHom f))","decl":"theorem mapDomain.addMonoidHom_comp_mapRange [AddCommMonoid N] (f : α → β) (g : M →+ N) :\n    (mapDomain.addMonoidHom f).comp (mapRange.addMonoidHom g) =\n      (mapRange.addMonoidHom g).comp (mapDomain.addMonoidHom f) := by\n  ext\n  simp only [AddMonoidHom.coe_comp, Finsupp.mapRange_single, Finsupp.mapDomain.addMonoidHom_apply,\n    Finsupp.singleAddHom_apply, eq_self_iff_true, Function.comp_apply, Finsupp.mapDomain_single,\n    Finsupp.mapRange.addMonoidHom_apply]\n\n"}
{"name":"Finsupp.mapDomain_mapRange","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\nN : Type u_7\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid N\nf : α → β\nv : Finsupp α M\ng : M → N\nh0 : Eq (g 0) 0\nhadd : ∀ (x y : M), Eq (g (HAdd.hAdd x y)) (HAdd.hAdd (g x) (g y))\n⊢ Eq (Finsupp.mapDomain f (Finsupp.mapRange g h0 v)) (Finsupp.mapRange g h0 (Finsupp.mapDomain f v))","decl":"/-- When `g` preserves addition, `mapRange` and `mapDomain` commute. -/\ntheorem mapDomain_mapRange [AddCommMonoid N] (f : α → β) (v : α →₀ M) (g : M → N) (h0 : g 0 = 0)\n    (hadd : ∀ x y, g (x + y) = g x + g y) :\n    mapDomain f (mapRange g h0 v) = mapRange g h0 (mapDomain f v) :=\n  let g' : M →+ N :=\n    { toFun := g\n      map_zero' := h0\n      map_add' := hadd }\n  DFunLike.congr_fun (mapDomain.addMonoidHom_comp_mapRange f g') v\n\n"}
{"name":"Finsupp.sum_update_add","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Type u_4\ninst✝¹ : AddCommMonoid α\ninst✝ : AddCommMonoid β\nf : Finsupp ι α\ni : ι\na : α\ng : ι → α → β\nhg : ∀ (i : ι), Eq (g i 0) 0\nhgg : ∀ (j : ι) (a₁ a₂ : α), Eq (g j (HAdd.hAdd a₁ a₂)) (HAdd.hAdd (g j a₁) (g j a₂))\n⊢ Eq (HAdd.hAdd ((f.update i a).sum g) (g i (f i))) (HAdd.hAdd (f.sum g) (g i a))","decl":"theorem sum_update_add [AddCommMonoid α] [AddCommMonoid β] (f : ι →₀ α) (i : ι) (a : α)\n    (g : ι → α → β) (hg : ∀ i, g i 0 = 0)\n    (hgg : ∀ (j : ι) (a₁ a₂ : α), g j (a₁ + a₂) = g j a₁ + g j a₂) :\n    (f.update i a).sum g + g i (f i) = f.sum g + g i a := by\n  rw [update_eq_erase_add_single, sum_add_index' hg hgg]\n  conv_rhs => rw [← Finsupp.update_self f i]\n  rw [update_eq_erase_add_single, sum_add_index' hg hgg, add_assoc, add_assoc]\n  congr 1\n  rw [add_comm, sum_single_index (hg _), sum_single_index (hg _)]\n\n"}
{"name":"Finsupp.mapDomain_injOn","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : AddCommMonoid M\nS : Set α\nf : α → β\nhf : Set.InjOn f S\n⊢ Set.InjOn (Finsupp.mapDomain f) (setOf fun w => HasSubset.Subset (↑w.support) S)","decl":"theorem mapDomain_injOn (S : Set α) {f : α → β} (hf : Set.InjOn f S) :\n    Set.InjOn (mapDomain f : (α →₀ M) → β →₀ M) { w | (w.support : Set α) ⊆ S } := by\n  intro v₁ hv₁ v₂ hv₂ eq\n  ext a\n  classical\n    by_cases h : a ∈ v₁.support ∪ v₂.support\n    · rw [← mapDomain_apply' S _ hv₁ hf _, ← mapDomain_apply' S _ hv₂ hf _, eq] <;>\n        · apply Set.union_subset hv₁ hv₂\n          exact mod_cast h\n    · simp only [not_or, mem_union, not_not, mem_support_iff] at h\n      simp [h]\n\n"}
{"name":"Finsupp.equivMapDomain_eq_mapDomain","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_13\ninst✝ : AddCommMonoid M\nf : Equiv α β\nl : Finsupp α M\n⊢ Eq (Finsupp.equivMapDomain f l) (Finsupp.mapDomain (⇑f) l)","decl":"theorem equivMapDomain_eq_mapDomain {M} [AddCommMonoid M] (f : α ≃ β) (l : α →₀ M) :\n    equivMapDomain f l = mapDomain f l := by ext x; simp [mapDomain_equiv_apply]\n\n"}
{"name":"Finsupp.comapDomain_support","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : Zero M\nf : α → β\nl : Finsupp β M\nhf : Set.InjOn f (Set.preimage f ↑l.support)\n⊢ Eq (Finsupp.comapDomain f l hf).support (l.support.preimage f hf)","decl":"/-- Given `f : α → β`, `l : β →₀ M` and a proof `hf` that `f` is injective on\nthe preimage of `l.support`, `comapDomain f l hf` is the finitely supported function\nfrom `α` to `M` given by composing `l` with `f`. -/\n@[simps support]\ndef comapDomain [Zero M] (f : α → β) (l : β →₀ M) (hf : Set.InjOn f (f ⁻¹' ↑l.support)) :\n    α →₀ M where\n  support := l.support.preimage f hf\n  toFun a := l (f a)\n  mem_support_toFun := by\n    intro a\n    simp only [Finset.mem_def.symm, Finset.mem_preimage]\n    exact l.mem_support_toFun (f a)\n\n"}
{"name":"Finsupp.comapDomain_apply","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : Zero M\nf : α → β\nl : Finsupp β M\nhf : Set.InjOn f (Set.preimage f ↑l.support)\na : α\n⊢ Eq ((Finsupp.comapDomain f l hf) a) (l (f a))","decl":"@[simp]\ntheorem comapDomain_apply [Zero M] (f : α → β) (l : β →₀ M) (hf : Set.InjOn f (f ⁻¹' ↑l.support))\n    (a : α) : comapDomain f l hf a = l (f a) :=\n  rfl\n\n"}
{"name":"Finsupp.sum_comapDomain","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\nN : Type u_7\ninst✝¹ : Zero M\ninst✝ : AddCommMonoid N\nf : α → β\nl : Finsupp β M\ng : β → M → N\nhf : Set.BijOn f (Set.preimage f ↑l.support) ↑l.support\n⊢ Eq ((Finsupp.comapDomain f l ⋯).sum (Function.comp g f)) (l.sum g)","decl":"theorem sum_comapDomain [Zero M] [AddCommMonoid N] (f : α → β) (l : β →₀ M) (g : β → M → N)\n    (hf : Set.BijOn f (f ⁻¹' ↑l.support) ↑l.support) :\n    (comapDomain f l hf.injOn).sum (g ∘ f) = l.sum g := by\n  simp only [sum, comapDomain_apply, (· ∘ ·), comapDomain]\n  exact Finset.sum_preimage_of_bij f _ hf fun x => g x (l x)\n\n"}
{"name":"Finsupp.eq_zero_of_comapDomain_eq_zero","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : α → β\nl : Finsupp β M\nhf : Set.BijOn f (Set.preimage f ↑l.support) ↑l.support\na✝ : Eq (Finsupp.comapDomain f l ⋯) 0\n⊢ Eq l 0","decl":"theorem eq_zero_of_comapDomain_eq_zero [AddCommMonoid M] (f : α → β) (l : β →₀ M)\n    (hf : Set.BijOn f (f ⁻¹' ↑l.support) ↑l.support) : comapDomain f l hf.injOn = 0 → l = 0 := by\n  rw [← support_eq_empty, ← support_eq_empty, comapDomain]\n  simp only [Finset.ext_iff, Finset.not_mem_empty, iff_false, mem_preimage]\n  intro h a ha\n  cases' hf.2.2 ha with b hb\n  exact h b (hb.2.symm ▸ ha)\n\n"}
{"name":"Finsupp.embDomain_comapDomain","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : Zero M\nf : Function.Embedding α β\ng : Finsupp β M\nhg : HasSubset.Subset (↑g.support) (Set.range ⇑f)\n⊢ Eq (Finsupp.embDomain f (Finsupp.comapDomain (⇑f) g ⋯)) g","decl":"lemma embDomain_comapDomain {f : α ↪ β} {g : β →₀ M} (hg : ↑g.support ⊆ Set.range f) :\n    embDomain f (comapDomain f g f.injective.injOn) = g := by\n  ext b\n  by_cases hb : b ∈ Set.range f\n  · obtain ⟨a, rfl⟩ := hb\n    rw [embDomain_apply, comapDomain_apply]\n  · replace hg : g b = 0 := not_mem_support_iff.mp <| mt (hg ·) hb\n    rw [embDomain_notin_range _ _ _ hb, hg]\n\n"}
{"name":"Finsupp.comapDomain_zero","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : Zero M\nf : α → β\nhif : optParam (Set.InjOn f (Set.preimage f ↑(Finsupp.support 0))) ⋯\n⊢ Eq (Finsupp.comapDomain f 0 hif) 0","decl":"/-- Note the `hif` argument is needed for this to work in `rw`. -/\n@[simp]\ntheorem comapDomain_zero (f : α → β)\n    (hif : Set.InjOn f (f ⁻¹' ↑(0 : β →₀ M).support) := Finset.coe_empty ▸ (Set.injOn_empty f)) :\n    comapDomain f (0 : β →₀ M) hif = (0 : α →₀ M) := by\n  ext\n  rfl\n\n"}
{"name":"Finsupp.comapDomain_single","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : Zero M\nf : α → β\na : α\nm : M\nhif : Set.InjOn f (Set.preimage f ↑(Finsupp.single (f a) m).support)\n⊢ Eq (Finsupp.comapDomain f (Finsupp.single (f a) m) hif) (Finsupp.single a m)","decl":"@[simp]\ntheorem comapDomain_single (f : α → β) (a : α) (m : M)\n    (hif : Set.InjOn f (f ⁻¹' (single (f a) m).support)) :\n    comapDomain f (Finsupp.single (f a) m) hif = Finsupp.single a m := by\n  rcases eq_or_ne m 0 with (rfl | hm)\n  · simp only [single_zero, comapDomain_zero]\n  · rw [eq_single_iff, comapDomain_apply, comapDomain_support, ← Finset.coe_subset, coe_preimage,\n      support_single_ne_zero _ hm, coe_singleton, coe_singleton, single_eq_same]\n    rw [support_single_ne_zero _ hm, coe_singleton] at hif\n    exact ⟨fun x hx => hif hx rfl hx, rfl⟩\n\n"}
{"name":"Finsupp.comapDomain_add","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : AddZeroClass M\nf : α → β\nv₁ v₂ : Finsupp β M\nhv₁ : Set.InjOn f (Set.preimage f ↑v₁.support)\nhv₂ : Set.InjOn f (Set.preimage f ↑v₂.support)\nhv₁₂ : Set.InjOn f (Set.preimage f ↑(HAdd.hAdd v₁ v₂).support)\n⊢ Eq (Finsupp.comapDomain f (HAdd.hAdd v₁ v₂) hv₁₂) (HAdd.hAdd (Finsupp.comapDomain f v₁ hv₁) (Finsupp.comapDomain f v₂ hv₂))","decl":"theorem comapDomain_add (v₁ v₂ : β →₀ M) (hv₁ : Set.InjOn f (f ⁻¹' ↑v₁.support))\n    (hv₂ : Set.InjOn f (f ⁻¹' ↑v₂.support)) (hv₁₂ : Set.InjOn f (f ⁻¹' ↑(v₁ + v₂).support)) :\n    comapDomain f (v₁ + v₂) hv₁₂ = comapDomain f v₁ hv₁ + comapDomain f v₂ hv₂ := by\n  ext\n  simp only [comapDomain_apply, coe_add, Pi.add_apply]\n\n"}
{"name":"Finsupp.comapDomain_add_of_injective","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : AddZeroClass M\nf : α → β\nhf : Function.Injective f\nv₁ v₂ : Finsupp β M\n⊢ Eq (Finsupp.comapDomain f (HAdd.hAdd v₁ v₂) ⋯) (HAdd.hAdd (Finsupp.comapDomain f v₁ ⋯) (Finsupp.comapDomain f v₂ ⋯))","decl":"/-- A version of `Finsupp.comapDomain_add` that's easier to use. -/\ntheorem comapDomain_add_of_injective (hf : Function.Injective f) (v₁ v₂ : β →₀ M) :\n    comapDomain f (v₁ + v₂) hf.injOn =\n      comapDomain f v₁ hf.injOn + comapDomain f v₂ hf.injOn :=\n  comapDomain_add _ _ _ _ _\n\n"}
{"name":"Finsupp.comapDomain.addMonoidHom_apply","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : AddZeroClass M\nf : α → β\nhf : Function.Injective f\nx : Finsupp β M\n⊢ Eq ((Finsupp.comapDomain.addMonoidHom hf) x) (Finsupp.comapDomain f x ⋯)","decl":"/-- `Finsupp.comapDomain` is an `AddMonoidHom`. -/\n@[simps]\ndef comapDomain.addMonoidHom (hf : Function.Injective f) : (β →₀ M) →+ α →₀ M where\n  toFun x := comapDomain f x hf.injOn\n  map_zero' := comapDomain_zero f\n  map_add' := comapDomain_add_of_injective hf\n\n"}
{"name":"Finsupp.mapDomain_comapDomain","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : α → β\nhf : Function.Injective f\nl : Finsupp β M\nhl : HasSubset.Subset (↑l.support) (Set.range f)\n⊢ Eq (Finsupp.mapDomain f (Finsupp.comapDomain f l ⋯)) l","decl":"theorem mapDomain_comapDomain (hf : Function.Injective f) (l : β →₀ M)\n    (hl : ↑l.support ⊆ Set.range f) :\n    mapDomain f (comapDomain f l hf.injOn) = l := by\n  conv_rhs => rw [← embDomain_comapDomain (f := ⟨f, hf⟩) hl (M := M), embDomain_eq_mapDomain]\n  rfl\n\n"}
{"name":"Finsupp.some_apply","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\nf : Finsupp (Option α) M\na : α\n⊢ Eq (f.some a) (f (Option.some a))","decl":"@[simp]\ntheorem some_apply [Zero M] (f : Option α →₀ M) (a : α) : f.some a = f (Option.some a) :=\n  rfl\n\n"}
{"name":"Finsupp.some_zero","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\n⊢ Eq (Finsupp.some 0) 0","decl":"@[simp]\ntheorem some_zero [Zero M] : (0 : Option α →₀ M).some = 0 := by\n  ext\n  simp\n\n"}
{"name":"Finsupp.some_add","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddCommMonoid M\nf g : Finsupp (Option α) M\n⊢ Eq (HAdd.hAdd f g).some (HAdd.hAdd f.some g.some)","decl":"@[simp]\ntheorem some_add [AddCommMonoid M] (f g : Option α →₀ M) : (f + g).some = f.some + g.some := by\n  ext\n  simp\n\n"}
{"name":"Finsupp.some_single_none","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\nm : M\n⊢ Eq (Finsupp.single Option.none m).some 0","decl":"@[simp]\ntheorem some_single_none [Zero M] (m : M) : (single none m : Option α →₀ M).some = 0 := by\n  ext\n  simp\n\n"}
{"name":"Finsupp.some_single_some","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\na : α\nm : M\n⊢ Eq (Finsupp.single (Option.some a) m).some (Finsupp.single a m)","decl":"@[simp]\ntheorem some_single_some [Zero M] (a : α) (m : M) :\n    (single (Option.some a) m : Option α →₀ M).some = single a m := by\n  classical\n    ext b\n    simp [single_apply]\n\n"}
{"name":"Finsupp.prod_option_index","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\nN : Type u_7\ninst✝¹ : AddCommMonoid M\ninst✝ : CommMonoid N\nf : Finsupp (Option α) M\nb : Option α → M → N\nh_zero : ∀ (o : Option α), Eq (b o 0) 1\nh_add : ∀ (o : Option α) (m₁ m₂ : M), Eq (b o (HAdd.hAdd m₁ m₂)) (HMul.hMul (b o m₁) (b o m₂))\n⊢ Eq (f.prod b) (HMul.hMul (b Option.none (f Option.none)) (f.some.prod fun a => b (Option.some a)))","decl":"@[to_additive]\ntheorem prod_option_index [AddCommMonoid M] [CommMonoid N] (f : Option α →₀ M)\n    (b : Option α → M → N) (h_zero : ∀ o, b o 0 = 1)\n    (h_add : ∀ o m₁ m₂, b o (m₁ + m₂) = b o m₁ * b o m₂) :\n    f.prod b = b none (f none) * f.some.prod fun a => b (Option.some a) := by\n  classical\n    apply induction_linear f\n    · simp [some_zero, h_zero]\n    · intro f₁ f₂ h₁ h₂\n      rw [Finsupp.prod_add_index, h₁, h₂, some_add, Finsupp.prod_add_index]\n      · simp only [h_add, Pi.add_apply, Finsupp.coe_add]\n        rw [mul_mul_mul_comm]\n      all_goals simp [h_zero, h_add]\n    · rintro (_ | a) m <;> simp [h_zero, h_add]\n\n"}
{"name":"Finsupp.sum_option_index","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\nN : Type u_7\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid N\nf : Finsupp (Option α) M\nb : Option α → M → N\nh_zero : ∀ (o : Option α), Eq (b o 0) 0\nh_add : ∀ (o : Option α) (m₁ m₂ : M), Eq (b o (HAdd.hAdd m₁ m₂)) (HAdd.hAdd (b o m₁) (b o m₂))\n⊢ Eq (f.sum b) (HAdd.hAdd (b Option.none (f Option.none)) (f.some.sum fun a => b (Option.some a)))","decl":"@[to_additive]\ntheorem prod_option_index [AddCommMonoid M] [CommMonoid N] (f : Option α →₀ M)\n    (b : Option α → M → N) (h_zero : ∀ o, b o 0 = 1)\n    (h_add : ∀ o m₁ m₂, b o (m₁ + m₂) = b o m₁ * b o m₂) :\n    f.prod b = b none (f none) * f.some.prod fun a => b (Option.some a) := by\n  classical\n    apply induction_linear f\n    · simp [some_zero, h_zero]\n    · intro f₁ f₂ h₁ h₂\n      rw [Finsupp.prod_add_index, h₁, h₂, some_add, Finsupp.prod_add_index]\n      · simp only [h_add, Pi.add_apply, Finsupp.coe_add]\n        rw [mul_mul_mul_comm]\n      all_goals simp [h_zero, h_add]\n    · rintro (_ | a) m <;> simp [h_zero, h_add]\n\n"}
{"name":"Finsupp.sum_option_index_smul","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\nR : Type u_11\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf : Finsupp (Option α) R\nb : Option α → M\n⊢ Eq (f.sum fun o r => HSMul.hSMul r (b o)) (HAdd.hAdd (HSMul.hSMul (f Option.none) (b Option.none)) (f.some.sum fun a r => HSMul.hSMul r (b (Option.some a))))","decl":"theorem sum_option_index_smul [Semiring R] [AddCommMonoid M] [Module R M] (f : Option α →₀ R)\n    (b : Option α → M) :\n    (f.sum fun o r => r • b o) = f none • b none + f.some.sum fun a r => r • b (Option.some a) :=\n  f.sum_option_index _ (fun _ => zero_smul _ _) fun _ _ _ => add_smul _ _ _\n\n"}
{"name":"Finsupp.filter_apply","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝¹ : Zero M\np : α → Prop\ninst✝ : DecidablePred p\nf : Finsupp α M\na : α\n⊢ Eq ((Finsupp.filter p f) a) (ite (p a) (f a) 0)","decl":"theorem filter_apply (a : α) : f.filter p a = if p a then f a else 0 := rfl\n\n"}
{"name":"Finsupp.filter_eq_indicator","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝¹ : Zero M\np : α → Prop\ninst✝ : DecidablePred p\nf : Finsupp α M\n⊢ Eq (⇑(Finsupp.filter p f)) ((setOf fun x => p x).indicator ⇑f)","decl":"theorem filter_eq_indicator : ⇑(f.filter p) = Set.indicator { x | p x } f := by\n  ext\n  simp [filter_apply, Set.indicator_apply]\n\n"}
{"name":"Finsupp.filter_eq_zero_iff","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝¹ : Zero M\np : α → Prop\ninst✝ : DecidablePred p\nf : Finsupp α M\n⊢ Iff (Eq (Finsupp.filter p f) 0) (∀ (x : α), p x → Eq (f x) 0)","decl":"theorem filter_eq_zero_iff : f.filter p = 0 ↔ ∀ x, p x → f x = 0 := by\n  simp only [DFunLike.ext_iff, filter_eq_indicator, zero_apply, Set.indicator_apply_eq_zero,\n    Set.mem_setOf_eq]\n\n"}
{"name":"Finsupp.filter_eq_self_iff","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝¹ : Zero M\np : α → Prop\ninst✝ : DecidablePred p\nf : Finsupp α M\n⊢ Iff (Eq (Finsupp.filter p f) f) (∀ (x : α), Ne (f x) 0 → p x)","decl":"theorem filter_eq_self_iff : f.filter p = f ↔ ∀ x, f x ≠ 0 → p x := by\n  simp only [DFunLike.ext_iff, filter_eq_indicator, Set.indicator_apply_eq_self, Set.mem_setOf_eq,\n    not_imp_comm]\n\n"}
{"name":"Finsupp.filter_apply_pos","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝¹ : Zero M\np : α → Prop\ninst✝ : DecidablePred p\nf : Finsupp α M\na : α\nh : p a\n⊢ Eq ((Finsupp.filter p f) a) (f a)","decl":"@[simp]\ntheorem filter_apply_pos {a : α} (h : p a) : f.filter p a = f a := if_pos h\n\n"}
{"name":"Finsupp.filter_apply_neg","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝¹ : Zero M\np : α → Prop\ninst✝ : DecidablePred p\nf : Finsupp α M\na : α\nh : Not (p a)\n⊢ Eq ((Finsupp.filter p f) a) 0","decl":"@[simp]\ntheorem filter_apply_neg {a : α} (h : ¬p a) : f.filter p a = 0 := if_neg h\n\n"}
{"name":"Finsupp.support_filter","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝¹ : Zero M\np : α → Prop\ninst✝ : DecidablePred p\nf : Finsupp α M\n⊢ Eq (Finsupp.filter p f).support (Finset.filter (fun x => p x) f.support)","decl":"@[simp]\ntheorem support_filter : (f.filter p).support = {x ∈ f.support | p x} := rfl\n\n"}
{"name":"Finsupp.filter_zero","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝¹ : Zero M\np : α → Prop\ninst✝ : DecidablePred p\n⊢ Eq (Finsupp.filter p 0) 0","decl":"theorem filter_zero : (0 : α →₀ M).filter p = 0 := by\n  classical rw [← support_eq_empty, support_filter, support_zero, Finset.filter_empty]\n\n"}
{"name":"Finsupp.filter_single_of_pos","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝¹ : Zero M\np : α → Prop\ninst✝ : DecidablePred p\na : α\nb : M\nh : p a\n⊢ Eq (Finsupp.filter p (Finsupp.single a b)) (Finsupp.single a b)","decl":"@[simp]\ntheorem filter_single_of_pos {a : α} {b : M} (h : p a) : (single a b).filter p = single a b :=\n  (filter_eq_self_iff _ _).2 fun _ hx => (single_apply_ne_zero.1 hx).1.symm ▸ h\n\n"}
{"name":"Finsupp.filter_single_of_neg","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝¹ : Zero M\np : α → Prop\ninst✝ : DecidablePred p\na : α\nb : M\nh : Not (p a)\n⊢ Eq (Finsupp.filter p (Finsupp.single a b)) 0","decl":"@[simp]\ntheorem filter_single_of_neg {a : α} {b : M} (h : ¬p a) : (single a b).filter p = 0 :=\n  (filter_eq_zero_iff _ _).2 fun _ hpx =>\n    single_apply_eq_zero.2 fun hxa => absurd hpx (hxa.symm ▸ h)\n\n"}
{"name":"Finsupp.prod_filter_index","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\nN : Type u_7\ninst✝² : Zero M\np : α → Prop\ninst✝¹ : DecidablePred p\nf : Finsupp α M\ninst✝ : CommMonoid N\ng : α → M → N\n⊢ Eq ((Finsupp.filter p f).prod g) ((Finsupp.filter p f).support.prod fun x => g x (f x))","decl":"@[to_additive]\ntheorem prod_filter_index [CommMonoid N] (g : α → M → N) :\n    (f.filter p).prod g = ∏ x ∈ (f.filter p).support, g x (f x) := by\n  classical\n    refine Finset.prod_congr rfl fun x hx => ?_\n    rw [support_filter, Finset.mem_filter] at hx\n    rw [filter_apply_pos _ _ hx.2]\n\n"}
{"name":"Finsupp.sum_filter_index","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\nN : Type u_7\ninst✝² : Zero M\np : α → Prop\ninst✝¹ : DecidablePred p\nf : Finsupp α M\ninst✝ : AddCommMonoid N\ng : α → M → N\n⊢ Eq ((Finsupp.filter p f).sum g) ((Finsupp.filter p f).support.sum fun x => g x (f x))","decl":"@[to_additive]\ntheorem prod_filter_index [CommMonoid N] (g : α → M → N) :\n    (f.filter p).prod g = ∏ x ∈ (f.filter p).support, g x (f x) := by\n  classical\n    refine Finset.prod_congr rfl fun x hx => ?_\n    rw [support_filter, Finset.mem_filter] at hx\n    rw [filter_apply_pos _ _ hx.2]\n\n"}
{"name":"Finsupp.sum_filter_add_sum_filter_not","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\nN : Type u_7\ninst✝² : Zero M\np : α → Prop\ninst✝¹ : DecidablePred p\nf : Finsupp α M\ninst✝ : AddCommMonoid N\ng : α → M → N\n⊢ Eq (HAdd.hAdd ((Finsupp.filter p f).sum g) ((Finsupp.filter (fun a => Not (p a)) f).sum g)) (f.sum g)","decl":"@[to_additive (attr := simp)]\ntheorem prod_filter_mul_prod_filter_not [CommMonoid N] (g : α → M → N) :\n    (f.filter p).prod g * (f.filter fun a => ¬p a).prod g = f.prod g := by\n  classical simp_rw [prod_filter_index, support_filter, Finset.prod_filter_mul_prod_filter_not,\n    Finsupp.prod]\n\n"}
{"name":"Finsupp.prod_filter_mul_prod_filter_not","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\nN : Type u_7\ninst✝² : Zero M\np : α → Prop\ninst✝¹ : DecidablePred p\nf : Finsupp α M\ninst✝ : CommMonoid N\ng : α → M → N\n⊢ Eq (HMul.hMul ((Finsupp.filter p f).prod g) ((Finsupp.filter (fun a => Not (p a)) f).prod g)) (f.prod g)","decl":"@[to_additive (attr := simp)]\ntheorem prod_filter_mul_prod_filter_not [CommMonoid N] (g : α → M → N) :\n    (f.filter p).prod g * (f.filter fun a => ¬p a).prod g = f.prod g := by\n  classical simp_rw [prod_filter_index, support_filter, Finset.prod_filter_mul_prod_filter_not,\n    Finsupp.prod]\n\n"}
{"name":"Finsupp.sum_sub_sum_filter","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\nG : Type u_9\ninst✝² : Zero M\np : α → Prop\ninst✝¹ : DecidablePred p\nf : Finsupp α M\ninst✝ : AddCommGroup G\ng : α → M → G\n⊢ Eq (HSub.hSub (f.sum g) ((Finsupp.filter p f).sum g)) ((Finsupp.filter (fun a => Not (p a)) f).sum g)","decl":"@[to_additive (attr := simp)]\ntheorem prod_div_prod_filter [CommGroup G] (g : α → M → G) :\n    f.prod g / (f.filter p).prod g = (f.filter fun a => ¬p a).prod g :=\n  div_eq_of_eq_mul' (prod_filter_mul_prod_filter_not _ _ _).symm\n\n"}
{"name":"Finsupp.prod_div_prod_filter","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\nG : Type u_9\ninst✝² : Zero M\np : α → Prop\ninst✝¹ : DecidablePred p\nf : Finsupp α M\ninst✝ : CommGroup G\ng : α → M → G\n⊢ Eq (HDiv.hDiv (f.prod g) ((Finsupp.filter p f).prod g)) ((Finsupp.filter (fun a => Not (p a)) f).prod g)","decl":"@[to_additive (attr := simp)]\ntheorem prod_div_prod_filter [CommGroup G] (g : α → M → G) :\n    f.prod g / (f.filter p).prod g = (f.filter fun a => ¬p a).prod g :=\n  div_eq_of_eq_mul' (prod_filter_mul_prod_filter_not _ _ _).symm\n\n"}
{"name":"Finsupp.filter_pos_add_filter_neg","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝¹ : AddZeroClass M\nf : Finsupp α M\np : α → Prop\ninst✝ : DecidablePred p\n⊢ Eq (HAdd.hAdd (Finsupp.filter p f) (Finsupp.filter (fun a => Not (p a)) f)) f","decl":"theorem filter_pos_add_filter_neg [AddZeroClass M] (f : α →₀ M) (p : α → Prop) [DecidablePred p] :\n    (f.filter p + f.filter fun a => ¬p a) = f :=\n  DFunLike.coe_injective <| by\n    simp only [coe_add, filter_eq_indicator]\n    exact Set.indicator_self_add_compl { x | p x } f\n\n"}
{"name":"Finsupp.mem_frange","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\nf : Finsupp α M\ny : M\n⊢ Iff (Membership.mem f.frange y) (And (Ne y 0) (Exists fun x => Eq (f x) y))","decl":"theorem mem_frange {f : α →₀ M} {y : M} : y ∈ f.frange ↔ y ≠ 0 ∧ ∃ x, f x = y := by\n  rw [frange, @Finset.mem_image _ _ (Classical.decEq _) _ f.support]\n  exact ⟨fun ⟨x, hx1, hx2⟩ => ⟨hx2 ▸ mem_support_iff.1 hx1, x, hx2⟩, fun ⟨hy, x, hx⟩ =>\n    ⟨x, mem_support_iff.2 (hx.symm ▸ hy), hx⟩⟩\n  -- Porting note: maybe there is a better way to fix this, but (1) it wasn't seeing past `frange`\n  -- the definition, and (2) it needed the `Classical.decEq` instance again.\n\n"}
{"name":"Finsupp.zero_not_mem_frange","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\nf : Finsupp α M\n⊢ Not (Membership.mem f.frange 0)","decl":"theorem zero_not_mem_frange {f : α →₀ M} : (0 : M) ∉ f.frange := fun H => (mem_frange.1 H).1 rfl\n\n"}
{"name":"Finsupp.frange_single","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\nx : α\ny : M\n⊢ HasSubset.Subset (Finsupp.single x y).frange (Singleton.singleton y)","decl":"theorem frange_single {x : α} {y : M} : frange (single x y) ⊆ {y} := fun r hr =>\n  let ⟨t, ht1, ht2⟩ := mem_frange.1 hr\n  ht2 ▸ by\n    classical\n      rw [single_apply] at ht2 ⊢\n      split_ifs at ht2 ⊢\n      · exact Finset.mem_singleton_self _\n      · exact (t ht2.symm).elim\n\n"}
{"name":"Finsupp.support_subtypeDomain","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\np : α → Prop\nD : DecidablePred p\nf : Finsupp α M\n⊢ Eq (Finsupp.subtypeDomain p f).support (Finset.subtype p f.support)","decl":"@[simp]\ntheorem support_subtypeDomain [D : DecidablePred p] {f : α →₀ M} :\n    (subtypeDomain p f).support = f.support.subtype p := by rw [Subsingleton.elim D] <;> rfl\n\n"}
{"name":"Finsupp.subtypeDomain_apply","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\np : α → Prop\na : Subtype p\nv : Finsupp α M\n⊢ Eq ((Finsupp.subtypeDomain p v) a) (v ↑a)","decl":"@[simp]\ntheorem subtypeDomain_apply {a : Subtype p} {v : α →₀ M} : (subtypeDomain p v) a = v a.val :=\n  rfl\n\n"}
{"name":"Finsupp.subtypeDomain_zero","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\np : α → Prop\n⊢ Eq (Finsupp.subtypeDomain p 0) 0","decl":"@[simp]\ntheorem subtypeDomain_zero : subtypeDomain p (0 : α →₀ M) = 0 :=\n  rfl\n\n"}
{"name":"Finsupp.subtypeDomain_eq_iff_forall","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\np : α → Prop\nf g : Finsupp α M\n⊢ Iff (Eq (Finsupp.subtypeDomain p f) (Finsupp.subtypeDomain p g)) (∀ (x : α), p x → Eq (f x) (g x))","decl":"theorem subtypeDomain_eq_iff_forall {f g : α →₀ M} :\n    f.subtypeDomain p = g.subtypeDomain p ↔ ∀ x, p x → f x = g x := by\n  simp_rw [DFunLike.ext_iff, subtypeDomain_apply, Subtype.forall]\n\n"}
{"name":"Finsupp.subtypeDomain_eq_iff","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\np : α → Prop\nf g : Finsupp α M\nhf : ∀ (x : α), Membership.mem f.support x → p x\nhg : ∀ (x : α), Membership.mem g.support x → p x\n⊢ Iff (Eq (Finsupp.subtypeDomain p f) (Finsupp.subtypeDomain p g)) (Eq f g)","decl":"theorem subtypeDomain_eq_iff {f g : α →₀ M}\n    (hf : ∀ x ∈ f.support, p x) (hg : ∀ x ∈ g.support, p x) :\n    f.subtypeDomain p = g.subtypeDomain p ↔ f = g :=\n  subtypeDomain_eq_iff_forall.trans\n    ⟨fun H ↦ Finsupp.ext fun _a ↦ (em _).elim (H _ <| hf _ ·) fun haf ↦ (em _).elim (H _ <| hg _ ·)\n        fun hag ↦ (not_mem_support_iff.mp haf).trans (not_mem_support_iff.mp hag).symm,\n      fun H _ _ ↦ congr($H _)⟩\n\n"}
{"name":"Finsupp.subtypeDomain_eq_zero_iff'","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\np : α → Prop\nf : Finsupp α M\n⊢ Iff (Eq (Finsupp.subtypeDomain p f) 0) (∀ (x : α), p x → Eq (f x) 0)","decl":"theorem subtypeDomain_eq_zero_iff' {f : α →₀ M} : f.subtypeDomain p = 0 ↔ ∀ x, p x → f x = 0 :=\n  subtypeDomain_eq_iff_forall (g := 0)\n\n"}
{"name":"Finsupp.subtypeDomain_eq_zero_iff","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\np : α → Prop\nf : Finsupp α M\nhf : ∀ (x : α), Membership.mem f.support x → p x\n⊢ Iff (Eq (Finsupp.subtypeDomain p f) 0) (Eq f 0)","decl":"theorem subtypeDomain_eq_zero_iff {f : α →₀ M} (hf : ∀ x ∈ f.support, p x) :\n    f.subtypeDomain p = 0 ↔ f = 0 :=\n  subtypeDomain_eq_iff (g := 0) hf (by simp)\n\n"}
{"name":"Finsupp.prod_subtypeDomain_index","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\nN : Type u_7\ninst✝¹ : Zero M\np : α → Prop\ninst✝ : CommMonoid N\nv : Finsupp α M\nh : α → M → N\nhp : ∀ (x : α), Membership.mem v.support x → p x\n⊢ Eq ((Finsupp.subtypeDomain p v).prod fun a b => h (↑a) b) (v.prod h)","decl":"@[to_additive]\ntheorem prod_subtypeDomain_index [CommMonoid N] {v : α →₀ M} {h : α → M → N}\n    (hp : ∀ x ∈ v.support, p x) : (v.subtypeDomain p).prod (fun a b ↦ h a b) = v.prod h := by\n  refine Finset.prod_bij (fun p _ ↦ p) ?_ ?_ ?_ ?_ <;> aesop\n\n"}
{"name":"Finsupp.sum_subtypeDomain_index","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\nN : Type u_7\ninst✝¹ : Zero M\np : α → Prop\ninst✝ : AddCommMonoid N\nv : Finsupp α M\nh : α → M → N\nhp : ∀ (x : α), Membership.mem v.support x → p x\n⊢ Eq ((Finsupp.subtypeDomain p v).sum fun a b => h (↑a) b) (v.sum h)","decl":"@[to_additive]\ntheorem prod_subtypeDomain_index [CommMonoid N] {v : α →₀ M} {h : α → M → N}\n    (hp : ∀ x ∈ v.support, p x) : (v.subtypeDomain p).prod (fun a b ↦ h a b) = v.prod h := by\n  refine Finset.prod_bij (fun p _ ↦ p) ?_ ?_ ?_ ?_ <;> aesop\n\n"}
{"name":"Finsupp.subtypeDomain_add","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddZeroClass M\np : α → Prop\nv v' : Finsupp α M\n⊢ Eq (Finsupp.subtypeDomain p (HAdd.hAdd v v')) (HAdd.hAdd (Finsupp.subtypeDomain p v) (Finsupp.subtypeDomain p v'))","decl":"@[simp]\ntheorem subtypeDomain_add {v v' : α →₀ M} :\n    (v + v').subtypeDomain p = v.subtypeDomain p + v'.subtypeDomain p :=\n  ext fun _ => rfl\n\n"}
{"name":"Finsupp.filter_add","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝¹ : AddZeroClass M\np : α → Prop\ninst✝ : DecidablePred p\nv v' : Finsupp α M\n⊢ Eq (Finsupp.filter p (HAdd.hAdd v v')) (HAdd.hAdd (Finsupp.filter p v) (Finsupp.filter p v'))","decl":"@[simp]\ntheorem filter_add [DecidablePred p] {v v' : α →₀ M} :\n    (v + v').filter p = v.filter p + v'.filter p :=\n  (filterAddHom p).map_add v v'\n\n"}
{"name":"Finsupp.subtypeDomain_sum","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nι : Type u_4\nM : Type u_5\ninst✝ : AddCommMonoid M\np : α → Prop\ns : Finset ι\nh : ι → Finsupp α M\n⊢ Eq (Finsupp.subtypeDomain p (s.sum fun c => h c)) (s.sum fun c => Finsupp.subtypeDomain p (h c))","decl":"theorem subtypeDomain_sum {s : Finset ι} {h : ι → α →₀ M} :\n    (∑ c ∈ s, h c).subtypeDomain p = ∑ c ∈ s, (h c).subtypeDomain p :=\n  map_sum subtypeDomainAddMonoidHom _ s\n\n"}
{"name":"Finsupp.subtypeDomain_finsupp_sum","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\nN : Type u_7\ninst✝¹ : AddCommMonoid M\np : α → Prop\ninst✝ : Zero N\ns : Finsupp β N\nh : β → N → Finsupp α M\n⊢ Eq (Finsupp.subtypeDomain p (s.sum h)) (s.sum fun c d => Finsupp.subtypeDomain p (h c d))","decl":"theorem subtypeDomain_finsupp_sum [Zero N] {s : β →₀ N} {h : β → N → α →₀ M} :\n    (s.sum h).subtypeDomain p = s.sum fun c d => (h c d).subtypeDomain p :=\n  subtypeDomain_sum\n\n"}
{"name":"Finsupp.filter_sum","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nι : Type u_4\nM : Type u_5\ninst✝¹ : AddCommMonoid M\np : α → Prop\ninst✝ : DecidablePred p\ns : Finset ι\nf : ι → Finsupp α M\n⊢ Eq (Finsupp.filter p (s.sum fun a => f a)) (s.sum fun a => Finsupp.filter p (f a))","decl":"theorem filter_sum [DecidablePred p] (s : Finset ι) (f : ι → α →₀ M) :\n    (∑ a ∈ s, f a).filter p = ∑ a ∈ s, filter p (f a) :=\n  map_sum (filterAddHom p) f s\n\n"}
{"name":"Finsupp.filter_eq_sum","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝¹ : AddCommMonoid M\np : α → Prop\ninst✝ : DecidablePred p\nf : Finsupp α M\n⊢ Eq (Finsupp.filter p f) ((Finset.filter p f.support).sum fun i => Finsupp.single i (f i))","decl":"theorem filter_eq_sum (p : α → Prop) [DecidablePred p] (f : α →₀ M) :\n    f.filter p = ∑ i ∈ f.support.filter p, single i (f i) :=\n  (f.filter p).sum_single.symm.trans <|\n    Finset.sum_congr rfl fun x hx => by\n      rw [filter_apply_pos _ _ (mem_filter.1 hx).2]\n\n"}
{"name":"Finsupp.subtypeDomain_neg","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nG : Type u_9\ninst✝ : AddGroup G\np : α → Prop\nv : Finsupp α G\n⊢ Eq (Finsupp.subtypeDomain p (Neg.neg v)) (Neg.neg (Finsupp.subtypeDomain p v))","decl":"@[simp]\ntheorem subtypeDomain_neg : (-v).subtypeDomain p = -v.subtypeDomain p :=\n  ext fun _ => rfl\n\n"}
{"name":"Finsupp.subtypeDomain_sub","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nG : Type u_9\ninst✝ : AddGroup G\np : α → Prop\nv v' : Finsupp α G\n⊢ Eq (Finsupp.subtypeDomain p (HSub.hSub v v')) (HSub.hSub (Finsupp.subtypeDomain p v) (Finsupp.subtypeDomain p v'))","decl":"@[simp]\ntheorem subtypeDomain_sub : (v - v').subtypeDomain p = v.subtypeDomain p - v'.subtypeDomain p :=\n  ext fun _ => rfl\n\n"}
{"name":"Finsupp.filter_neg","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nG : Type u_9\ninst✝¹ : AddGroup G\np : α → Prop\ninst✝ : DecidablePred p\nf : Finsupp α G\n⊢ Eq (Finsupp.filter p (Neg.neg f)) (Neg.neg (Finsupp.filter p f))","decl":"@[simp]\ntheorem filter_neg (p : α → Prop) [DecidablePred p] (f : α →₀ G) : filter p (-f) = -filter p f :=\n  (filterAddHom p : (_ →₀ G) →+ _).map_neg f\n\n"}
{"name":"Finsupp.filter_sub","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nG : Type u_9\ninst✝¹ : AddGroup G\np : α → Prop\ninst✝ : DecidablePred p\nf₁ f₂ : Finsupp α G\n⊢ Eq (Finsupp.filter p (HSub.hSub f₁ f₂)) (HSub.hSub (Finsupp.filter p f₁) (Finsupp.filter p f₂))","decl":"@[simp]\ntheorem filter_sub (p : α → Prop) [DecidablePred p] (f₁ f₂ : α →₀ G) :\n    filter p (f₁ - f₂) = filter p f₁ - filter p f₂ :=\n  (filterAddHom p : (_ →₀ G) →+ _).map_sub f₁ f₂\n\n"}
{"name":"Finsupp.mem_support_multiset_sum","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddCommMonoid M\ns : Multiset (Finsupp α M)\na : α\na✝ : Membership.mem s.sum.support a\n⊢ Exists fun f => And (Membership.mem s f) (Membership.mem f.support a)","decl":"theorem mem_support_multiset_sum [AddCommMonoid M] {s : Multiset (α →₀ M)} (a : α) :\n    a ∈ s.sum.support → ∃ f ∈ s, a ∈ (f : α →₀ M).support :=\n  Multiset.induction_on s (fun h => False.elim (by simp at h))\n    (by\n      intro f s ih ha\n      by_cases h : a ∈ f.support\n      · exact ⟨f, Multiset.mem_cons_self _ _, h⟩\n      · simp only [Multiset.sum_cons, mem_support_iff, add_apply, not_mem_support_iff.1 h,\n          zero_add] at ha\n        rcases ih (mem_support_iff.2 ha) with ⟨f', h₀, h₁⟩\n        exact ⟨f', Multiset.mem_cons_of_mem h₀, h₁⟩)\n\n"}
{"name":"Finsupp.mem_support_finset_sum","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nι : Type u_4\nM : Type u_5\ninst✝ : AddCommMonoid M\ns : Finset ι\nh : ι → Finsupp α M\na : α\nha : Membership.mem (s.sum fun c => h c).support a\n⊢ Exists fun c => And (Membership.mem s c) (Membership.mem (h c).support a)","decl":"theorem mem_support_finset_sum [AddCommMonoid M] {s : Finset ι} {h : ι → α →₀ M} (a : α)\n    (ha : a ∈ (∑ c ∈ s, h c).support) : ∃ c ∈ s, a ∈ (h c).support :=\n  let ⟨_, hf, hfa⟩ := mem_support_multiset_sum a ha\n  let ⟨c, hc, Eq⟩ := Multiset.mem_map.1 hf\n  ⟨c, hc, Eq.symm ▸ hfa⟩\n\n"}
{"name":"Finsupp.curry_apply","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : Finsupp (Prod α β) M\nx : α\ny : β\n⊢ Eq ((f.curry x) y) (f { fst := x, snd := y })","decl":"@[simp]\ntheorem curry_apply (f : α × β →₀ M) (x : α) (y : β) : f.curry x y = f (x, y) := by\n  classical\n    have : ∀ b : α × β, single b.fst (single b.snd (f b)) x y = if b = (x, y) then f b else 0 := by\n      rintro ⟨b₁, b₂⟩\n      simp only [ne_eq, single_apply, Prod.ext_iff, ite_and]\n      split_ifs <;> simp [single_apply, *]\n    rw [Finsupp.curry, sum_apply, sum_apply, sum_eq_single, this, if_pos rfl]\n    · intro b _ b_ne\n      rw [this b, if_neg b_ne]\n    · intro _\n      rw [single_zero, single_zero, coe_zero, Pi.zero_apply, coe_zero, Pi.zero_apply]\n\n"}
{"name":"Finsupp.sum_curry_index","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\nN : Type u_7\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid N\nf : Finsupp (Prod α β) M\ng : α → β → M → N\nhg₀ : ∀ (a : α) (b : β), Eq (g a b 0) 0\nhg₁ : ∀ (a : α) (b : β) (c₀ c₁ : M), Eq (g a b (HAdd.hAdd c₀ c₁)) (HAdd.hAdd (g a b c₀) (g a b c₁))\n⊢ Eq (f.curry.sum fun a f => f.sum (g a)) (f.sum fun p c => g p.1 p.2 c)","decl":"theorem sum_curry_index (f : α × β →₀ M) (g : α → β → M → N) (hg₀ : ∀ a b, g a b 0 = 0)\n    (hg₁ : ∀ a b c₀ c₁, g a b (c₀ + c₁) = g a b c₀ + g a b c₁) :\n    (f.curry.sum fun a f => f.sum (g a)) = f.sum fun p c => g p.1 p.2 c := by\n  rw [Finsupp.curry]\n  trans\n  · exact\n      sum_sum_index (fun a => sum_zero_index) fun a b₀ b₁ =>\n        sum_add_index' (fun a => hg₀ _ _) fun c d₀ d₁ => hg₁ _ _ _ _\n  congr; funext p c\n  trans\n  · exact sum_single_index sum_zero_index\n  exact sum_single_index (hg₀ _ _)\n\n"}
{"name":"Finsupp.filter_curry","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝¹ : AddCommMonoid M\nf : Finsupp (Prod α β) M\np : α → Prop\ninst✝ : DecidablePred p\n⊢ Eq (Finsupp.filter (fun a => p a.1) f).curry (Finsupp.filter p f.curry)","decl":"theorem filter_curry (f : α × β →₀ M) (p : α → Prop) [DecidablePred p] :\n    (f.filter fun a : α × β => p a.1).curry = f.curry.filter p := by\n  classical\n    rw [Finsupp.curry, Finsupp.curry, Finsupp.sum, Finsupp.sum, filter_sum, support_filter,\n      sum_filter]\n    refine Finset.sum_congr rfl ?_\n    rintro ⟨a₁, a₂⟩ _\n    split_ifs with h\n    · rw [filter_apply_pos, filter_single_of_pos] <;> exact h\n    · rwa [filter_single_of_neg]\n\n"}
{"name":"Finsupp.support_curry","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝¹ : AddCommMonoid M\ninst✝ : DecidableEq α\nf : Finsupp (Prod α β) M\n⊢ HasSubset.Subset f.curry.support (Finset.image Prod.fst f.support)","decl":"theorem support_curry [DecidableEq α] (f : α × β →₀ M) :\n    f.curry.support ⊆ f.support.image Prod.fst := by\n  rw [← Finset.biUnion_singleton]\n  refine Finset.Subset.trans support_sum ?_\n  exact Finset.biUnion_mono fun a _ => support_single_subset\n\n"}
{"name":"Finsupp.sumElim_support","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_13\nβ : Type u_14\nγ : Type u_15\ninst✝ : Zero γ\nf : Finsupp α γ\ng : Finsupp β γ\n⊢ Eq (f.sumElim g).support (f.support.disjSum g.support)","decl":"/-- `Finsupp.sumElim f g` maps `inl x` to `f x` and `inr y` to `g y`. -/\n@[simps support]\ndef sumElim {α β γ : Type*} [Zero γ] (f : α →₀ γ) (g : β →₀ γ) : α ⊕ β →₀ γ where\n  support := f.support.disjSum g.support\n  toFun := Sum.elim f g\n  mem_support_toFun := by simp\n\n"}
{"name":"Finsupp.coe_sumElim","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_13\nβ : Type u_14\nγ : Type u_15\ninst✝ : Zero γ\nf : Finsupp α γ\ng : Finsupp β γ\n⊢ Eq (⇑(f.sumElim g)) (Sum.elim ⇑f ⇑g)","decl":"@[simp, norm_cast]\ntheorem coe_sumElim {α β γ : Type*} [Zero γ] (f : α →₀ γ) (g : β →₀ γ) :\n    ⇑(sumElim f g) = Sum.elim f g :=\n  rfl\n\n"}
{"name":"Finsupp.sumElim_apply","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_13\nβ : Type u_14\nγ : Type u_15\ninst✝ : Zero γ\nf : Finsupp α γ\ng : Finsupp β γ\nx : Sum α β\n⊢ Eq ((f.sumElim g) x) (Sum.elim (⇑f) (⇑g) x)","decl":"theorem sumElim_apply {α β γ : Type*} [Zero γ] (f : α →₀ γ) (g : β →₀ γ) (x : α ⊕ β) :\n    sumElim f g x = Sum.elim f g x :=\n  rfl\n\n"}
{"name":"Finsupp.sumElim_inl","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_13\nβ : Type u_14\nγ : Type u_15\ninst✝ : Zero γ\nf : Finsupp α γ\ng : Finsupp β γ\nx : α\n⊢ Eq ((f.sumElim g) (Sum.inl x)) (f x)","decl":"theorem sumElim_inl {α β γ : Type*} [Zero γ] (f : α →₀ γ) (g : β →₀ γ) (x : α) :\n    sumElim f g (Sum.inl x) = f x :=\n  rfl\n\n"}
{"name":"Finsupp.sumElim_inr","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_13\nβ : Type u_14\nγ : Type u_15\ninst✝ : Zero γ\nf : Finsupp α γ\ng : Finsupp β γ\nx : β\n⊢ Eq ((f.sumElim g) (Sum.inr x)) (g x)","decl":"theorem sumElim_inr {α β γ : Type*} [Zero γ] (f : α →₀ γ) (g : β →₀ γ) (x : β) :\n    sumElim f g (Sum.inr x) = g x :=\n  rfl\n\n"}
{"name":"Finsupp.prod_sumElim","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"ι₁ : Type u_13\nι₂ : Type u_14\nα : Type u_15\nM : Type u_16\ninst✝¹ : Zero α\ninst✝ : CommMonoid M\nf₁ : Finsupp ι₁ α\nf₂ : Finsupp ι₂ α\ng : Sum ι₁ ι₂ → α → M\n⊢ Eq ((f₁.sumElim f₂).prod g) (HMul.hMul (f₁.prod (Function.comp g Sum.inl)) (f₂.prod (Function.comp g Sum.inr)))","decl":"@[to_additive]\nlemma prod_sumElim {ι₁ ι₂ α M : Type*} [Zero α] [CommMonoid M]\n    (f₁ : ι₁ →₀ α) (f₂ : ι₂ →₀ α) (g : ι₁ ⊕ ι₂ → α → M) :\n    (f₁.sumElim f₂).prod g = f₁.prod (g ∘ Sum.inl) * f₂.prod (g ∘ Sum.inr) := by\n  simp [Finsupp.prod, Finset.prod_disj_sum]\n\n"}
{"name":"Finsupp.sum_sumElim","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"ι₁ : Type u_13\nι₂ : Type u_14\nα : Type u_15\nM : Type u_16\ninst✝¹ : Zero α\ninst✝ : AddCommMonoid M\nf₁ : Finsupp ι₁ α\nf₂ : Finsupp ι₂ α\ng : Sum ι₁ ι₂ → α → M\n⊢ Eq ((f₁.sumElim f₂).sum g) (HAdd.hAdd (f₁.sum (Function.comp g Sum.inl)) (f₂.sum (Function.comp g Sum.inr)))","decl":"@[to_additive]\nlemma prod_sumElim {ι₁ ι₂ α M : Type*} [Zero α] [CommMonoid M]\n    (f₁ : ι₁ →₀ α) (f₂ : ι₂ →₀ α) (g : ι₁ ⊕ ι₂ → α → M) :\n    (f₁.sumElim f₂).prod g = f₁.prod (g ∘ Sum.inl) * f₂.prod (g ∘ Sum.inr) := by\n  simp [Finsupp.prod, Finset.prod_disj_sum]\n\n"}
{"name":"Finsupp.sumFinsuppEquivProdFinsupp_symm_apply","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_13\nβ : Type u_14\nγ : Type u_15\ninst✝ : Zero γ\nfg : Prod (Finsupp α γ) (Finsupp β γ)\n⊢ Eq (Finsupp.sumFinsuppEquivProdFinsupp.symm fg) (fg.1.sumElim fg.2)","decl":"/-- The equivalence between `(α ⊕ β) →₀ γ` and `(α →₀ γ) × (β →₀ γ)`.\n\nThis is the `Finsupp` version of `Equiv.sum_arrow_equiv_prod_arrow`. -/\n@[simps apply symm_apply]\ndef sumFinsuppEquivProdFinsupp {α β γ : Type*} [Zero γ] : (α ⊕ β →₀ γ) ≃ (α →₀ γ) × (β →₀ γ) where\n  toFun f :=\n    ⟨f.comapDomain Sum.inl Sum.inl_injective.injOn,\n      f.comapDomain Sum.inr Sum.inr_injective.injOn⟩\n  invFun fg := sumElim fg.1 fg.2\n  left_inv f := by\n    ext ab\n    cases' ab with a b <;> simp\n  right_inv fg := by ext <;> simp\n\n"}
{"name":"Finsupp.sumFinsuppEquivProdFinsupp_apply","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_13\nβ : Type u_14\nγ : Type u_15\ninst✝ : Zero γ\nf : Finsupp (Sum α β) γ\n⊢ Eq (Finsupp.sumFinsuppEquivProdFinsupp f) { fst := Finsupp.comapDomain Sum.inl f ⋯, snd := Finsupp.comapDomain Sum.inr f ⋯ }","decl":"/-- The equivalence between `(α ⊕ β) →₀ γ` and `(α →₀ γ) × (β →₀ γ)`.\n\nThis is the `Finsupp` version of `Equiv.sum_arrow_equiv_prod_arrow`. -/\n@[simps apply symm_apply]\ndef sumFinsuppEquivProdFinsupp {α β γ : Type*} [Zero γ] : (α ⊕ β →₀ γ) ≃ (α →₀ γ) × (β →₀ γ) where\n  toFun f :=\n    ⟨f.comapDomain Sum.inl Sum.inl_injective.injOn,\n      f.comapDomain Sum.inr Sum.inr_injective.injOn⟩\n  invFun fg := sumElim fg.1 fg.2\n  left_inv f := by\n    ext ab\n    cases' ab with a b <;> simp\n  right_inv fg := by ext <;> simp\n\n"}
{"name":"Finsupp.fst_sumFinsuppEquivProdFinsupp","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_13\nβ : Type u_14\nγ : Type u_15\ninst✝ : Zero γ\nf : Finsupp (Sum α β) γ\nx : α\n⊢ Eq ((Finsupp.sumFinsuppEquivProdFinsupp f).1 x) (f (Sum.inl x))","decl":"theorem fst_sumFinsuppEquivProdFinsupp {α β γ : Type*} [Zero γ] (f : α ⊕ β →₀ γ) (x : α) :\n    (sumFinsuppEquivProdFinsupp f).1 x = f (Sum.inl x) :=\n  rfl\n\n"}
{"name":"Finsupp.snd_sumFinsuppEquivProdFinsupp","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_13\nβ : Type u_14\nγ : Type u_15\ninst✝ : Zero γ\nf : Finsupp (Sum α β) γ\ny : β\n⊢ Eq ((Finsupp.sumFinsuppEquivProdFinsupp f).2 y) (f (Sum.inr y))","decl":"theorem snd_sumFinsuppEquivProdFinsupp {α β γ : Type*} [Zero γ] (f : α ⊕ β →₀ γ) (y : β) :\n    (sumFinsuppEquivProdFinsupp f).2 y = f (Sum.inr y) :=\n  rfl\n\n"}
{"name":"Finsupp.sumFinsuppEquivProdFinsupp_symm_inl","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_13\nβ : Type u_14\nγ : Type u_15\ninst✝ : Zero γ\nfg : Prod (Finsupp α γ) (Finsupp β γ)\nx : α\n⊢ Eq ((Finsupp.sumFinsuppEquivProdFinsupp.symm fg) (Sum.inl x)) (fg.1 x)","decl":"theorem sumFinsuppEquivProdFinsupp_symm_inl {α β γ : Type*} [Zero γ] (fg : (α →₀ γ) × (β →₀ γ))\n    (x : α) : (sumFinsuppEquivProdFinsupp.symm fg) (Sum.inl x) = fg.1 x :=\n  rfl\n\n"}
{"name":"Finsupp.sumFinsuppEquivProdFinsupp_symm_inr","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_13\nβ : Type u_14\nγ : Type u_15\ninst✝ : Zero γ\nfg : Prod (Finsupp α γ) (Finsupp β γ)\ny : β\n⊢ Eq ((Finsupp.sumFinsuppEquivProdFinsupp.symm fg) (Sum.inr y)) (fg.2 y)","decl":"theorem sumFinsuppEquivProdFinsupp_symm_inr {α β γ : Type*} [Zero γ] (fg : (α →₀ γ) × (β →₀ γ))\n    (y : β) : (sumFinsuppEquivProdFinsupp.symm fg) (Sum.inr y) = fg.2 y :=\n  rfl\n\n"}
{"name":"Finsupp.sumFinsuppAddEquivProdFinsupp_symm_apply","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"M : Type u_5\ninst✝ : AddMonoid M\nα : Type u_13\nβ : Type u_14\nfg : Prod (Finsupp α M) (Finsupp β M)\n⊢ Eq (Finsupp.sumFinsuppAddEquivProdFinsupp.symm fg) (fg.1.sumElim fg.2)","decl":"/-- The additive equivalence between `(α ⊕ β) →₀ M` and `(α →₀ M) × (β →₀ M)`.\n\nThis is the `Finsupp` version of `Equiv.sum_arrow_equiv_prod_arrow`. -/\n@[simps! apply symm_apply]\ndef sumFinsuppAddEquivProdFinsupp {α β : Type*} : (α ⊕ β →₀ M) ≃+ (α →₀ M) × (β →₀ M) :=\n  { sumFinsuppEquivProdFinsupp with\n    map_add' := by\n      intros\n      ext <;>\n        simp only [Equiv.toFun_as_coe, Prod.fst_add, Prod.snd_add, add_apply,\n          snd_sumFinsuppEquivProdFinsupp, fst_sumFinsuppEquivProdFinsupp] }\n\n"}
{"name":"Finsupp.sumFinsuppAddEquivProdFinsupp_apply","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"M : Type u_5\ninst✝ : AddMonoid M\nα : Type u_13\nβ : Type u_14\nf : Finsupp (Sum α β) M\n⊢ Eq (Finsupp.sumFinsuppAddEquivProdFinsupp f) { fst := Finsupp.comapDomain Sum.inl f ⋯, snd := Finsupp.comapDomain Sum.inr f ⋯ }","decl":"/-- The additive equivalence between `(α ⊕ β) →₀ M` and `(α →₀ M) × (β →₀ M)`.\n\nThis is the `Finsupp` version of `Equiv.sum_arrow_equiv_prod_arrow`. -/\n@[simps! apply symm_apply]\ndef sumFinsuppAddEquivProdFinsupp {α β : Type*} : (α ⊕ β →₀ M) ≃+ (α →₀ M) × (β →₀ M) :=\n  { sumFinsuppEquivProdFinsupp with\n    map_add' := by\n      intros\n      ext <;>\n        simp only [Equiv.toFun_as_coe, Prod.fst_add, Prod.snd_add, add_apply,\n          snd_sumFinsuppEquivProdFinsupp, fst_sumFinsuppEquivProdFinsupp] }\n\n"}
{"name":"Finsupp.fst_sumFinsuppAddEquivProdFinsupp","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"M : Type u_5\ninst✝ : AddMonoid M\nα : Type u_13\nβ : Type u_14\nf : Finsupp (Sum α β) M\nx : α\n⊢ Eq ((Finsupp.sumFinsuppAddEquivProdFinsupp f).1 x) (f (Sum.inl x))","decl":"theorem fst_sumFinsuppAddEquivProdFinsupp {α β : Type*} (f : α ⊕ β →₀ M) (x : α) :\n    (sumFinsuppAddEquivProdFinsupp f).1 x = f (Sum.inl x) :=\n  rfl\n\n"}
{"name":"Finsupp.snd_sumFinsuppAddEquivProdFinsupp","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"M : Type u_5\ninst✝ : AddMonoid M\nα : Type u_13\nβ : Type u_14\nf : Finsupp (Sum α β) M\ny : β\n⊢ Eq ((Finsupp.sumFinsuppAddEquivProdFinsupp f).2 y) (f (Sum.inr y))","decl":"theorem snd_sumFinsuppAddEquivProdFinsupp {α β : Type*} (f : α ⊕ β →₀ M) (y : β) :\n    (sumFinsuppAddEquivProdFinsupp f).2 y = f (Sum.inr y) :=\n  rfl\n\n"}
{"name":"Finsupp.sumFinsuppAddEquivProdFinsupp_symm_inl","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"M : Type u_5\ninst✝ : AddMonoid M\nα : Type u_13\nβ : Type u_14\nfg : Prod (Finsupp α M) (Finsupp β M)\nx : α\n⊢ Eq ((Finsupp.sumFinsuppAddEquivProdFinsupp.symm fg) (Sum.inl x)) (fg.1 x)","decl":"theorem sumFinsuppAddEquivProdFinsupp_symm_inl {α β : Type*} (fg : (α →₀ M) × (β →₀ M)) (x : α) :\n    (sumFinsuppAddEquivProdFinsupp.symm fg) (Sum.inl x) = fg.1 x :=\n  rfl\n\n"}
{"name":"Finsupp.sumFinsuppAddEquivProdFinsupp_symm_inr","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"M : Type u_5\ninst✝ : AddMonoid M\nα : Type u_13\nβ : Type u_14\nfg : Prod (Finsupp α M) (Finsupp β M)\ny : β\n⊢ Eq ((Finsupp.sumFinsuppAddEquivProdFinsupp.symm fg) (Sum.inr y)) (fg.2 y)","decl":"theorem sumFinsuppAddEquivProdFinsupp_symm_inr {α β : Type*} (fg : (α →₀ M) × (β →₀ M)) (y : β) :\n    (sumFinsuppAddEquivProdFinsupp.symm fg) (Sum.inr y) = fg.2 y :=\n  rfl\n\n"}
{"name":"Finsupp.piecewise_support","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_13\ninst✝¹ : Zero M\nP : α → Prop\ninst✝ : DecidablePred P\nf : Finsupp (Subtype P) M\ng : Finsupp (Subtype fun a => Not (P a)) M\n⊢ Eq (f.piecewise g).support ((Finset.map (Function.Embedding.subtype P) f.support).disjUnion (Finset.map (Function.Embedding.subtype fun a => Not (P a)) g.support) ⋯)","decl":"/-- Combine finitely supported functions over `{a // P a}` and `{a // ¬P a}`, by case-splitting on\n`P a`. -/\n@[simps]\ndef piecewise (f : Subtype P →₀ M) (g : {a // ¬ P a} →₀ M) : α →₀ M where\n  toFun a := if h : P a then f ⟨a, h⟩ else g ⟨a, h⟩\n  support := (f.support.map (.subtype _)).disjUnion (g.support.map (.subtype _)) <| by\n    simp_rw [Finset.disjoint_left, mem_map, forall_exists_index, Embedding.coe_subtype,\n      Subtype.forall, Subtype.exists]\n    rintro _ a ha ⟨-, rfl⟩ ⟨b, hb, -, rfl⟩\n    exact hb ha\n  mem_support_toFun a := by\n    by_cases ha : P a <;> simp [ha]\n\n"}
{"name":"Finsupp.piecewise_toFun","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_13\ninst✝¹ : Zero M\nP : α → Prop\ninst✝ : DecidablePred P\nf : Finsupp (Subtype P) M\ng : Finsupp (Subtype fun a => Not (P a)) M\na : α\n⊢ Eq ((f.piecewise g) a) (dite (P a) (fun h => f ⟨a, h⟩) fun h => g ⟨a, h⟩)","decl":"/-- Combine finitely supported functions over `{a // P a}` and `{a // ¬P a}`, by case-splitting on\n`P a`. -/\n@[simps]\ndef piecewise (f : Subtype P →₀ M) (g : {a // ¬ P a} →₀ M) : α →₀ M where\n  toFun a := if h : P a then f ⟨a, h⟩ else g ⟨a, h⟩\n  support := (f.support.map (.subtype _)).disjUnion (g.support.map (.subtype _)) <| by\n    simp_rw [Finset.disjoint_left, mem_map, forall_exists_index, Embedding.coe_subtype,\n      Subtype.forall, Subtype.exists]\n    rintro _ a ha ⟨-, rfl⟩ ⟨b, hb, -, rfl⟩\n    exact hb ha\n  mem_support_toFun a := by\n    by_cases ha : P a <;> simp [ha]\n\n"}
{"name":"Finsupp.subtypeDomain_piecewise","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_13\ninst✝¹ : Zero M\nP : α → Prop\ninst✝ : DecidablePred P\nf : Finsupp (Subtype P) M\ng : Finsupp (Subtype fun a => Not (P a)) M\n⊢ Eq (Finsupp.subtypeDomain P (f.piecewise g)) f","decl":"@[simp]\ntheorem subtypeDomain_piecewise (f : Subtype P →₀ M) (g : {a // ¬ P a} →₀ M) :\n    subtypeDomain P (f.piecewise g) = f :=\n  Finsupp.ext fun a => dif_pos a.prop\n\n"}
{"name":"Finsupp.subtypeDomain_not_piecewise","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_13\ninst✝¹ : Zero M\nP : α → Prop\ninst✝ : DecidablePred P\nf : Finsupp (Subtype P) M\ng : Finsupp (Subtype fun a => Not (P a)) M\n⊢ Eq (Finsupp.subtypeDomain (fun x => Not (P x)) (f.piecewise g)) g","decl":"@[simp]\ntheorem subtypeDomain_not_piecewise (f : Subtype P →₀ M) (g : {a // ¬ P a} →₀ M) :\n    subtypeDomain (¬P ·) (f.piecewise g) = g :=\n  Finsupp.ext fun a => dif_neg a.prop\n\n"}
{"name":"Finsupp.extendDomain_support","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_13\ninst✝¹ : Zero M\nP : α → Prop\ninst✝ : DecidablePred P\nf : Finsupp (Subtype P) M\n⊢ Eq f.extendDomain.support (Finset.map (Function.Embedding.subtype P) f.support)","decl":"/-- Extend the domain of a `Finsupp` by using `0` where `P x` does not hold. -/\n@[simps! support toFun]\ndef extendDomain (f : Subtype P →₀ M) : α →₀ M := piecewise f 0\n\n"}
{"name":"Finsupp.extendDomain_toFun","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_13\ninst✝¹ : Zero M\nP : α → Prop\ninst✝ : DecidablePred P\nf : Finsupp (Subtype P) M\na : α\n⊢ Eq (f.extendDomain a) (dite (P a) (fun h => f ⟨a, h⟩) fun h => 0)","decl":"/-- Extend the domain of a `Finsupp` by using `0` where `P x` does not hold. -/\n@[simps! support toFun]\ndef extendDomain (f : Subtype P →₀ M) : α →₀ M := piecewise f 0\n\n"}
{"name":"Finsupp.extendDomain_eq_embDomain_subtype","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_13\ninst✝¹ : Zero M\nP : α → Prop\ninst✝ : DecidablePred P\nf : Finsupp (Subtype P) M\n⊢ Eq f.extendDomain (Finsupp.embDomain (Function.Embedding.subtype P) f)","decl":"theorem extendDomain_eq_embDomain_subtype (f : Subtype P →₀ M) :\n    extendDomain f = embDomain (.subtype _) f := by\n  ext a\n  by_cases h : P a\n  · refine Eq.trans ?_ (embDomain_apply (.subtype P) f (Subtype.mk a h)).symm\n    simp [h]\n  · rw [embDomain_notin_range, extendDomain_toFun, dif_neg h]\n    simp [h]\n\n"}
{"name":"Finsupp.support_extendDomain_subset","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_13\ninst✝¹ : Zero M\nP : α → Prop\ninst✝ : DecidablePred P\nf : Finsupp (Subtype P) M\n⊢ HasSubset.Subset (↑f.extendDomain.support) (setOf fun x => P x)","decl":"theorem support_extendDomain_subset (f : Subtype P →₀ M) :\n    ↑(f.extendDomain).support ⊆ {x | P x} := by\n  intro x\n  rw [extendDomain_support, mem_coe, mem_map, Embedding.coe_subtype]\n  rintro ⟨x, -, rfl⟩\n  exact x.prop\n\n"}
{"name":"Finsupp.subtypeDomain_extendDomain","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_13\ninst✝¹ : Zero M\nP : α → Prop\ninst✝ : DecidablePred P\nf : Finsupp (Subtype P) M\n⊢ Eq (Finsupp.subtypeDomain P f.extendDomain) f","decl":"@[simp]\ntheorem subtypeDomain_extendDomain (f : Subtype P →₀ M) :\n    subtypeDomain P f.extendDomain = f :=\n  subtypeDomain_piecewise _ _\n\n"}
{"name":"Finsupp.extendDomain_subtypeDomain","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_13\ninst✝¹ : Zero M\nP : α → Prop\ninst✝ : DecidablePred P\nf : Finsupp α M\nhf : ∀ (a : α), Membership.mem f.support a → P a\n⊢ Eq (Finsupp.subtypeDomain P f).extendDomain f","decl":"theorem extendDomain_subtypeDomain (f : α →₀ M) (hf : ∀ a ∈ f.support, P a) :\n    (subtypeDomain P f).extendDomain = f := by\n  ext a\n  by_cases h : P a\n  · exact dif_pos h\n  · #adaptation_note /-- nightly-2024-06-18\n    this `rw` was done by `dsimp`. -/\n    rw [extendDomain_toFun]\n    dsimp\n    rw [if_neg h, eq_comm, ← not_mem_support_iff]\n    refine mt ?_ h\n    exact @hf _\n\n"}
{"name":"Finsupp.extendDomain_single","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_13\ninst✝¹ : Zero M\nP : α → Prop\ninst✝ : DecidablePred P\na : Subtype P\nm : M\n⊢ Eq (Finsupp.single a m).extendDomain (Finsupp.single (↑a) m)","decl":"@[simp]\ntheorem extendDomain_single (a : Subtype P) (m : M) :\n    (single a m).extendDomain = single a.val m := by\n  ext a'\n  #adaptation_note /-- nightly-2024-06-18\n  this `rw` was instead `dsimp only`. -/\n  rw [extendDomain_toFun]\n  obtain rfl | ha := eq_or_ne a.val a'\n  · simp_rw [single_eq_same, dif_pos a.prop]\n  · simp_rw [single_eq_of_ne ha, dite_eq_right_iff]\n    intro h\n    rw [single_eq_of_ne]\n    simp [Subtype.ext_iff, ha]\n\n"}
{"name":"Finsupp.restrictSupportEquiv_apply","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\ns : Set α\nM : Type u_13\ninst✝ : AddCommMonoid M\nf : Subtype fun f => HasSubset.Subset (↑f.support) s\n⊢ Eq ((Finsupp.restrictSupportEquiv s M) f) (Finsupp.subtypeDomain (fun x => Membership.mem s x) ↑f)","decl":"/-- Given an `AddCommMonoid M` and `s : Set α`, `restrictSupportEquiv s M` is the `Equiv`\nbetween the subtype of finitely supported functions with support contained in `s` and\nthe type of finitely supported functions from `s`. -/\n-- TODO: add [DecidablePred (· ∈ s)] as an assumption\n@[simps] def restrictSupportEquiv (s : Set α) (M : Type*) [AddCommMonoid M] :\n    { f : α →₀ M // ↑f.support ⊆ s } ≃ (s →₀ M) where\n  toFun f := subtypeDomain (· ∈ s) f.1\n  invFun f := letI := Classical.decPred (· ∈ s); ⟨f.extendDomain, support_extendDomain_subset _⟩\n  left_inv f :=\n    letI := Classical.decPred (· ∈ s); Subtype.ext <| extendDomain_subtypeDomain f.1 f.prop\n  right_inv _ := letI := Classical.decPred (· ∈ s); subtypeDomain_extendDomain _\n\n"}
{"name":"Finsupp.restrictSupportEquiv_symm_apply_coe","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\ns : Set α\nM : Type u_13\ninst✝ : AddCommMonoid M\nf : Finsupp (↑s) M\n⊢ Eq (↑((Finsupp.restrictSupportEquiv s M).symm f)) f.extendDomain","decl":"/-- Given an `AddCommMonoid M` and `s : Set α`, `restrictSupportEquiv s M` is the `Equiv`\nbetween the subtype of finitely supported functions with support contained in `s` and\nthe type of finitely supported functions from `s`. -/\n-- TODO: add [DecidablePred (· ∈ s)] as an assumption\n@[simps] def restrictSupportEquiv (s : Set α) (M : Type*) [AddCommMonoid M] :\n    { f : α →₀ M // ↑f.support ⊆ s } ≃ (s →₀ M) where\n  toFun f := subtypeDomain (· ∈ s) f.1\n  invFun f := letI := Classical.decPred (· ∈ s); ⟨f.extendDomain, support_extendDomain_subset _⟩\n  left_inv f :=\n    letI := Classical.decPred (· ∈ s); Subtype.ext <| extendDomain_subtypeDomain f.1 f.prop\n  right_inv _ := letI := Classical.decPred (· ∈ s); subtypeDomain_extendDomain _\n\n"}
{"name":"Finsupp.domCongr_apply","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : AddCommMonoid M\ne : Equiv α β\nl : Finsupp α M\n⊢ Eq ((Finsupp.domCongr e) l) (Finsupp.equivMapDomain e l)","decl":"/-- Given `AddCommMonoid M` and `e : α ≃ β`, `domCongr e` is the corresponding `Equiv` between\n`α →₀ M` and `β →₀ M`.\n\nThis is `Finsupp.equivCongrLeft` as an `AddEquiv`. -/\n@[simps apply]\nprotected def domCongr [AddCommMonoid M] (e : α ≃ β) : (α →₀ M) ≃+ (β →₀ M) where\n  toFun := equivMapDomain e\n  invFun := equivMapDomain e.symm\n  left_inv v := by\n    simp only [← equivMapDomain_trans, Equiv.self_trans_symm]\n    exact equivMapDomain_refl _\n  right_inv := by\n    intro v\n    simp only [← equivMapDomain_trans, Equiv.symm_trans_self]\n    exact equivMapDomain_refl _\n  map_add' a b := by simp only [equivMapDomain_eq_mapDomain]; exact mapDomain_add\n\n"}
{"name":"Finsupp.domCongr_refl","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddCommMonoid M\n⊢ Eq (Finsupp.domCongr (Equiv.refl α)) (AddEquiv.refl (Finsupp α M))","decl":"@[simp]\ntheorem domCongr_refl [AddCommMonoid M] :\n    Finsupp.domCongr (Equiv.refl α) = AddEquiv.refl (α →₀ M) :=\n  AddEquiv.ext fun _ => equivMapDomain_refl _\n\n"}
{"name":"Finsupp.domCongr_symm","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : AddCommMonoid M\ne : Equiv α β\n⊢ Eq (Finsupp.domCongr e).symm (Finsupp.domCongr e.symm)","decl":"@[simp]\ntheorem domCongr_symm [AddCommMonoid M] (e : α ≃ β) :\n    (Finsupp.domCongr e).symm = (Finsupp.domCongr e.symm : (β →₀ M) ≃+ (α →₀ M)) :=\n  AddEquiv.ext fun _ => rfl\n\n"}
{"name":"Finsupp.domCongr_trans","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nM : Type u_5\ninst✝ : AddCommMonoid M\ne : Equiv α β\nf : Equiv β γ\n⊢ Eq ((Finsupp.domCongr e).trans (Finsupp.domCongr f)) (Finsupp.domCongr (e.trans f))","decl":"@[simp]\ntheorem domCongr_trans [AddCommMonoid M] (e : α ≃ β) (f : β ≃ γ) :\n    (Finsupp.domCongr e).trans (Finsupp.domCongr f) =\n      (Finsupp.domCongr (e.trans f) : (α →₀ M) ≃+ _) :=\n  AddEquiv.ext fun _ => (equivMapDomain_trans _ _ _).symm\n\n"}
{"name":"Finsupp.split_apply","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"ι : Type u_4\nM : Type u_5\nαs : ι → Type u_13\ninst✝ : Zero M\nl : Finsupp (Sigma fun i => αs i) M\ni : ι\nx : αs i\n⊢ Eq ((l.split i) x) (l ⟨i, x⟩)","decl":"theorem split_apply (i : ι) (x : αs i) : split l i x = l ⟨i, x⟩ := by\n  dsimp only [split]\n  rw [comapDomain_apply]\n\n"}
{"name":"Finsupp.mem_splitSupport_iff_nonzero","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"ι : Type u_4\nM : Type u_5\nαs : ι → Type u_13\ninst✝ : Zero M\nl : Finsupp (Sigma fun i => αs i) M\ni : ι\n⊢ Iff (Membership.mem l.splitSupport i) (Ne (l.split i) 0)","decl":"theorem mem_splitSupport_iff_nonzero (i : ι) : i ∈ splitSupport l ↔ split l i ≠ 0 := by\n  rw [splitSupport, @mem_image _ _ (Classical.decEq _), Ne, ← support_eq_empty, ← Ne, ←\n    Finset.nonempty_iff_ne_empty, split, comapDomain, Finset.Nonempty]\n  -- Porting note (https://github.com/leanprover-community/mathlib4/issues/10754): had to add the `Classical.decEq` instance manually\n  simp only [exists_prop, Finset.mem_preimage, exists_and_right, exists_eq_right, mem_support_iff,\n    Sigma.exists, Ne]\n\n"}
{"name":"Finsupp.sigma_support","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"ι : Type u_4\nM : Type u_5\nαs : ι → Type u_13\ninst✝ : Zero M\nl : Finsupp (Sigma fun i => αs i) M\n⊢ Eq l.support (l.splitSupport.sigma fun i => (l.split i).support)","decl":"theorem sigma_support : l.support = l.splitSupport.sigma fun i => (l.split i).support := by\n  simp only [Finset.ext_iff, splitSupport, split, comapDomain, @mem_image _ _ (Classical.decEq _),\n    mem_preimage, Sigma.forall, mem_sigma]\n  -- Porting note (https://github.com/leanprover-community/mathlib4/issues/10754): had to add the `Classical.decEq` instance manually\n  tauto\n\n"}
{"name":"Finsupp.sigma_sum","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"ι : Type u_4\nM : Type u_5\nN : Type u_7\nαs : ι → Type u_13\ninst✝¹ : Zero M\nl : Finsupp (Sigma fun i => αs i) M\ninst✝ : AddCommMonoid N\nf : (Sigma fun i => αs i) → M → N\n⊢ Eq (l.sum f) (l.splitSupport.sum fun i => (l.split i).sum fun a b => f ⟨i, a⟩ b)","decl":"theorem sigma_sum [AddCommMonoid N] (f : (Σi : ι, αs i) → M → N) :\n    l.sum f = ∑ i ∈ splitSupport l, (split l i).sum fun (a : αs i) b => f ⟨i, a⟩ b := by\n  simp only [sum, sigma_support, sum_sigma, split_apply]\n\n"}
{"name":"Finsupp.sigmaFinsuppEquivPiFinsupp_apply","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"α : Type u_1\nη : Type u_14\ninst✝¹ : Fintype η\nιs : η → Type u_15\ninst✝ : Zero α\nf : Finsupp (Sigma fun j => ιs j) α\nj : η\ni : ιs j\n⊢ Eq ((Finsupp.sigmaFinsuppEquivPiFinsupp f j) i) (f ⟨j, i⟩)","decl":"@[simp]\ntheorem sigmaFinsuppEquivPiFinsupp_apply (f : (Σj, ιs j) →₀ α) (j i) :\n    sigmaFinsuppEquivPiFinsupp f j i = f ⟨j, i⟩ :=\n  rfl\n\n"}
{"name":"Finsupp.sigmaFinsuppAddEquivPiFinsupp_apply","module":"Mathlib.Data.Finsupp.Basic","initialProofState":"η : Type u_14\ninst✝¹ : Fintype η\nα : Type u_16\nιs : η → Type u_17\ninst✝ : AddMonoid α\nf : Finsupp (Sigma fun j => ιs j) α\nj : η\ni : ιs j\n⊢ Eq ((Finsupp.sigmaFinsuppAddEquivPiFinsupp f j) i) (f ⟨j, i⟩)","decl":"@[simp]\ntheorem sigmaFinsuppAddEquivPiFinsupp_apply {α : Type*} {ιs : η → Type*} [AddMonoid α]\n    (f : (Σj, ιs j) →₀ α) (j i) : sigmaFinsuppAddEquivPiFinsupp f j i = f ⟨j, i⟩ :=\n  rfl\n\n"}
