{"name":"BddOrd.mk.sizeOf_spec","module":"Mathlib.Order.Category.BddOrd","initialProofState":"toPartOrd : PartOrd\nisBoundedOrder : BoundedOrder ↑toPartOrd\n⊢ Eq (SizeOf.sizeOf (BddOrd.mk toPartOrd)) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toPartOrd)) (SizeOf.sizeOf isBoundedOrder))","decl":"/-- The category of bounded orders with monotone functions. -/\nstructure BddOrd where\n  /-- The underlying object in the category of partial orders. -/\n  toPartOrd : PartOrd\n  [isBoundedOrder : BoundedOrder toPartOrd]\n\n"}
{"name":"BddOrd.mk.inj","module":"Mathlib.Order.Category.BddOrd","initialProofState":"toPartOrd✝ : PartOrd\nisBoundedOrder✝ : BoundedOrder ↑toPartOrd✝\ntoPartOrd : PartOrd\nisBoundedOrder : BoundedOrder ↑toPartOrd\nx✝ : Eq (BddOrd.mk toPartOrd✝) (BddOrd.mk toPartOrd)\n⊢ And (Eq toPartOrd✝ toPartOrd) (HEq isBoundedOrder✝ isBoundedOrder)","decl":"/-- The category of bounded orders with monotone functions. -/\nstructure BddOrd where\n  /-- The underlying object in the category of partial orders. -/\n  toPartOrd : PartOrd\n  [isBoundedOrder : BoundedOrder toPartOrd]\n\n"}
{"name":"BddOrd.mk.injEq","module":"Mathlib.Order.Category.BddOrd","initialProofState":"toPartOrd✝ : PartOrd\nisBoundedOrder✝ : BoundedOrder ↑toPartOrd✝\ntoPartOrd : PartOrd\nisBoundedOrder : BoundedOrder ↑toPartOrd\n⊢ Eq (Eq (BddOrd.mk toPartOrd✝) (BddOrd.mk toPartOrd)) (And (Eq toPartOrd✝ toPartOrd) (HEq isBoundedOrder✝ isBoundedOrder))","decl":"/-- The category of bounded orders with monotone functions. -/\nstructure BddOrd where\n  /-- The underlying object in the category of partial orders. -/\n  toPartOrd : PartOrd\n  [isBoundedOrder : BoundedOrder toPartOrd]\n\n"}
{"name":"BddOrd.coe_of","module":"Mathlib.Order.Category.BddOrd","initialProofState":"α : Type u_1\ninst✝¹ : PartialOrder α\ninst✝ : BoundedOrder α\n⊢ Eq (↑(BddOrd.of α).toPartOrd) α","decl":"@[simp]\ntheorem coe_of (α : Type*) [PartialOrder α] [BoundedOrder α] : ↥(of α) = α :=\n  rfl\n\n"}
{"name":"BddOrd.dual_map","module":"Mathlib.Order.Category.BddOrd","initialProofState":"x✝¹ x✝ : BddOrd\na : BoundedOrderHom ↑x✝¹.toPartOrd ↑x✝.toPartOrd\n⊢ Eq (BddOrd.dual.map a) (BoundedOrderHom.dual a)","decl":"/-- `OrderDual` as a functor. -/\n@[simps]\ndef dual : BddOrd ⥤ BddOrd where\n  obj X := of Xᵒᵈ\n  map {_ _} := BoundedOrderHom.dual\n\n"}
{"name":"BddOrd.dual_obj","module":"Mathlib.Order.Category.BddOrd","initialProofState":"X : BddOrd\n⊢ Eq (BddOrd.dual.obj X) (BddOrd.of (OrderDual ↑X.toPartOrd))","decl":"/-- `OrderDual` as a functor. -/\n@[simps]\ndef dual : BddOrd ⥤ BddOrd where\n  obj X := of Xᵒᵈ\n  map {_ _} := BoundedOrderHom.dual\n\n"}
{"name":"BddOrd.Iso.mk_inv","module":"Mathlib.Order.Category.BddOrd","initialProofState":"α β : BddOrd\ne : OrderIso ↑α.toPartOrd ↑β.toPartOrd\n⊢ Eq (BddOrd.Iso.mk e).inv ↑e.symm","decl":"/-- Constructs an equivalence between bounded orders from an order isomorphism between them. -/\n@[simps]\ndef Iso.mk {α β : BddOrd.{u}} (e : α ≃o β) : α ≅ β where\n  hom := (e : BoundedOrderHom _ _)\n  inv := (e.symm : BoundedOrderHom _ _)\n  hom_inv_id := by ext; exact e.symm_apply_apply _\n  inv_hom_id := by ext; exact e.apply_symm_apply _\n\n"}
{"name":"BddOrd.Iso.mk_hom","module":"Mathlib.Order.Category.BddOrd","initialProofState":"α β : BddOrd\ne : OrderIso ↑α.toPartOrd ↑β.toPartOrd\n⊢ Eq (BddOrd.Iso.mk e).hom ↑e","decl":"/-- Constructs an equivalence between bounded orders from an order isomorphism between them. -/\n@[simps]\ndef Iso.mk {α β : BddOrd.{u}} (e : α ≃o β) : α ≅ β where\n  hom := (e : BoundedOrderHom _ _)\n  inv := (e.symm : BoundedOrderHom _ _)\n  hom_inv_id := by ext; exact e.symm_apply_apply _\n  inv_hom_id := by ext; exact e.apply_symm_apply _\n\n"}
{"name":"BddOrd.dualEquiv_functor","module":"Mathlib.Order.Category.BddOrd","initialProofState":"⊢ Eq BddOrd.dualEquiv.functor BddOrd.dual","decl":"/-- The equivalence between `BddOrd` and itself induced by `OrderDual` both ways. -/\n@[simps functor inverse]\ndef dualEquiv : BddOrd ≌ BddOrd where\n  functor := dual\n  inverse := dual\n  unitIso := NatIso.ofComponents fun X => Iso.mk <| OrderIso.dualDual X\n  counitIso := NatIso.ofComponents fun X => Iso.mk <| OrderIso.dualDual X\n\n"}
{"name":"BddOrd.dualEquiv_inverse","module":"Mathlib.Order.Category.BddOrd","initialProofState":"⊢ Eq BddOrd.dualEquiv.inverse BddOrd.dual","decl":"/-- The equivalence between `BddOrd` and itself induced by `OrderDual` both ways. -/\n@[simps functor inverse]\ndef dualEquiv : BddOrd ≌ BddOrd where\n  functor := dual\n  inverse := dual\n  unitIso := NatIso.ofComponents fun X => Iso.mk <| OrderIso.dualDual X\n  counitIso := NatIso.ofComponents fun X => Iso.mk <| OrderIso.dualDual X\n\n"}
{"name":"bddOrd_dual_comp_forget_to_partOrd","module":"Mathlib.Order.Category.BddOrd","initialProofState":"⊢ Eq (BddOrd.dual.comp (CategoryTheory.forget₂ BddOrd PartOrd)) ((CategoryTheory.forget₂ BddOrd PartOrd).comp PartOrd.dual)","decl":"theorem bddOrd_dual_comp_forget_to_partOrd :\n    BddOrd.dual ⋙ forget₂ BddOrd PartOrd =\n    forget₂ BddOrd PartOrd ⋙ PartOrd.dual :=\n  rfl\n\n"}
{"name":"bddOrd_dual_comp_forget_to_bipointed","module":"Mathlib.Order.Category.BddOrd","initialProofState":"⊢ Eq (BddOrd.dual.comp (CategoryTheory.forget₂ BddOrd Bipointed)) ((CategoryTheory.forget₂ BddOrd Bipointed).comp Bipointed.swap)","decl":"theorem bddOrd_dual_comp_forget_to_bipointed :\n    BddOrd.dual ⋙ forget₂ BddOrd Bipointed =\n    forget₂ BddOrd Bipointed ⋙ Bipointed.swap :=\n  rfl\n"}
