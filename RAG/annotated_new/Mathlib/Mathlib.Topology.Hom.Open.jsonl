{"name":"ContinuousOpenMap.map_open'","module":"Mathlib.Topology.Hom.Open","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\nself : ContinuousOpenMap α β\n⊢ IsOpenMap self.toFun","decl":"/-- The type of continuous open maps from `α` to `β`, aka Priestley homomorphisms. -/\nstructure ContinuousOpenMap (α β : Type*) [TopologicalSpace α] [TopologicalSpace β] extends\n  ContinuousMap α β where\n  map_open' : IsOpenMap toFun\n\n"}
{"name":"ContinuousOpenMap.mk.sizeOf_spec","module":"Mathlib.Topology.Hom.Open","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : SizeOf α\ninst✝ : SizeOf β\ntoContinuousMap : ContinuousMap α β\nmap_open' : IsOpenMap toContinuousMap.toFun\n⊢ Eq (SizeOf.sizeOf { toContinuousMap := toContinuousMap, map_open' := map_open' }) (HAdd.hAdd 1 (SizeOf.sizeOf toContinuousMap))","decl":"/-- The type of continuous open maps from `α` to `β`, aka Priestley homomorphisms. -/\nstructure ContinuousOpenMap (α β : Type*) [TopologicalSpace α] [TopologicalSpace β] extends\n  ContinuousMap α β where\n  map_open' : IsOpenMap toFun\n\n"}
{"name":"ContinuousOpenMap.mk.inj","module":"Mathlib.Topology.Hom.Open","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\ntoContinuousMap✝ : ContinuousMap α β\nmap_open'✝ : IsOpenMap toContinuousMap✝.toFun\ntoContinuousMap : ContinuousMap α β\nmap_open' : IsOpenMap toContinuousMap.toFun\nx✝ : Eq { toContinuousMap := toContinuousMap✝, map_open' := map_open'✝ } { toContinuousMap := toContinuousMap, map_open' := map_open' }\n⊢ Eq toContinuousMap✝ toContinuousMap","decl":"/-- The type of continuous open maps from `α` to `β`, aka Priestley homomorphisms. -/\nstructure ContinuousOpenMap (α β : Type*) [TopologicalSpace α] [TopologicalSpace β] extends\n  ContinuousMap α β where\n  map_open' : IsOpenMap toFun\n\n"}
{"name":"ContinuousOpenMap.mk.injEq","module":"Mathlib.Topology.Hom.Open","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\ntoContinuousMap✝ : ContinuousMap α β\nmap_open'✝ : IsOpenMap toContinuousMap✝.toFun\ntoContinuousMap : ContinuousMap α β\nmap_open' : IsOpenMap toContinuousMap.toFun\n⊢ Eq (Eq { toContinuousMap := toContinuousMap✝, map_open' := map_open'✝ } { toContinuousMap := toContinuousMap, map_open' := map_open' }) (Eq toContinuousMap✝ toContinuousMap)","decl":"/-- The type of continuous open maps from `α` to `β`, aka Priestley homomorphisms. -/\nstructure ContinuousOpenMap (α β : Type*) [TopologicalSpace α] [TopologicalSpace β] extends\n  ContinuousMap α β where\n  map_open' : IsOpenMap toFun\n\n"}
{"name":"ContinuousOpenMapClass.toContinuousMapClass","module":"Mathlib.Topology.Hom.Open","initialProofState":"F : Type u_6\nα : outParam (Type u_7)\nβ : outParam (Type u_8)\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace β\ninst✝ : FunLike F α β\nself : ContinuousOpenMapClass F α β\n⊢ ContinuousMapClass F α β","decl":"/-- `ContinuousOpenMapClass F α β` states that `F` is a type of continuous open maps.\n\nYou should extend this class when you extend `ContinuousOpenMap`. -/\nclass ContinuousOpenMapClass (F : Type*) (α β : outParam Type*) [TopologicalSpace α]\n  [TopologicalSpace β] [FunLike F α β] extends ContinuousMapClass F α β : Prop where\n  map_open (f : F) : IsOpenMap f\n\n"}
{"name":"ContinuousOpenMapClass.map_open","module":"Mathlib.Topology.Hom.Open","initialProofState":"F : Type u_6\nα : outParam (Type u_7)\nβ : outParam (Type u_8)\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace β\ninst✝ : FunLike F α β\nself : ContinuousOpenMapClass F α β\nf : F\n⊢ IsOpenMap ⇑f","decl":"/-- `ContinuousOpenMapClass F α β` states that `F` is a type of continuous open maps.\n\nYou should extend this class when you extend `ContinuousOpenMap`. -/\nclass ContinuousOpenMapClass (F : Type*) (α β : outParam Type*) [TopologicalSpace α]\n  [TopologicalSpace β] [FunLike F α β] extends ContinuousMapClass F α β : Prop where\n  map_open (f : F) : IsOpenMap f\n\n"}
{"name":"ContinuousOpenMap.instContinuousOpenMapClass","module":"Mathlib.Topology.Hom.Open","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\n⊢ ContinuousOpenMapClass (ContinuousOpenMap α β) α β","decl":"instance : ContinuousOpenMapClass (α →CO β) α β where\n  map_continuous f := f.continuous_toFun\n  map_open f := f.map_open'\n\n"}
{"name":"ContinuousOpenMap.toFun_eq_coe","module":"Mathlib.Topology.Hom.Open","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\nf : ContinuousOpenMap α β\n⊢ Eq f.toFun ⇑f","decl":"theorem toFun_eq_coe {f : α →CO β} : f.toFun = (f : α → β) :=\n  rfl\n\n"}
{"name":"ContinuousOpenMap.coe_toContinuousMap","module":"Mathlib.Topology.Hom.Open","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\nf : ContinuousOpenMap α β\n⊢ Eq ⇑f.toContinuousMap ⇑f","decl":"/-- `simp`-normal form of `toFun_eq_coe`. -/\n@[simp]\ntheorem coe_toContinuousMap (f : α →CO β) : (f.toContinuousMap : α → β) = f := rfl\n\n"}
{"name":"ContinuousOpenMap.ext_iff","module":"Mathlib.Topology.Hom.Open","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\nf g : ContinuousOpenMap α β\n⊢ Iff (Eq f g) (∀ (a : α), Eq (f a) (g a))","decl":"@[ext]\ntheorem ext {f g : α →CO β} (h : ∀ a, f a = g a) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"ContinuousOpenMap.ext","module":"Mathlib.Topology.Hom.Open","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\nf g : ContinuousOpenMap α β\nh : ∀ (a : α), Eq (f a) (g a)\n⊢ Eq f g","decl":"@[ext]\ntheorem ext {f g : α →CO β} (h : ∀ a, f a = g a) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"ContinuousOpenMap.coe_copy","module":"Mathlib.Topology.Hom.Open","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\nf : ContinuousOpenMap α β\nf' : α → β\nh : Eq f' ⇑f\n⊢ Eq (⇑(f.copy f' h)) f'","decl":"@[simp]\ntheorem coe_copy (f : α →CO β) (f' : α → β) (h : f' = f) : ⇑(f.copy f' h) = f' :=\n  rfl\n\n"}
{"name":"ContinuousOpenMap.copy_eq","module":"Mathlib.Topology.Hom.Open","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\nf : ContinuousOpenMap α β\nf' : α → β\nh : Eq f' ⇑f\n⊢ Eq (f.copy f' h) f","decl":"theorem copy_eq (f : α →CO β) (f' : α → β) (h : f' = f) : f.copy f' h = f :=\n  DFunLike.ext' h\n\n"}
{"name":"ContinuousOpenMap.coe_id","module":"Mathlib.Topology.Hom.Open","initialProofState":"α : Type u_2\ninst✝ : TopologicalSpace α\n⊢ Eq (⇑(ContinuousOpenMap.id α)) id","decl":"@[simp, norm_cast]\ntheorem coe_id : ⇑(ContinuousOpenMap.id α) = id :=\n  rfl\n\n"}
{"name":"ContinuousOpenMap.id_apply","module":"Mathlib.Topology.Hom.Open","initialProofState":"α : Type u_2\ninst✝ : TopologicalSpace α\na : α\n⊢ Eq ((ContinuousOpenMap.id α) a) a","decl":"@[simp]\ntheorem id_apply (a : α) : ContinuousOpenMap.id α a = a :=\n  rfl\n\n"}
{"name":"ContinuousOpenMap.coe_comp","module":"Mathlib.Topology.Hom.Open","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace β\ninst✝ : TopologicalSpace γ\nf : ContinuousOpenMap β γ\ng : ContinuousOpenMap α β\n⊢ Eq (⇑(f.comp g)) (Function.comp ⇑f ⇑g)","decl":"@[simp]\ntheorem coe_comp (f : β →CO γ) (g : α →CO β) : (f.comp g : α → γ) = f ∘ g :=\n  rfl\n\n"}
{"name":"ContinuousOpenMap.comp_apply","module":"Mathlib.Topology.Hom.Open","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace β\ninst✝ : TopologicalSpace γ\nf : ContinuousOpenMap β γ\ng : ContinuousOpenMap α β\na : α\n⊢ Eq ((f.comp g) a) (f (g a))","decl":"@[simp]\ntheorem comp_apply (f : β →CO γ) (g : α →CO β) (a : α) : (f.comp g) a = f (g a) :=\n  rfl\n\n"}
{"name":"ContinuousOpenMap.comp_assoc","module":"Mathlib.Topology.Hom.Open","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\nδ : Type u_5\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : TopologicalSpace γ\ninst✝ : TopologicalSpace δ\nf : ContinuousOpenMap γ δ\ng : ContinuousOpenMap β γ\nh : ContinuousOpenMap α β\n⊢ Eq ((f.comp g).comp h) (f.comp (g.comp h))","decl":"@[simp]\ntheorem comp_assoc (f : γ →CO δ) (g : β →CO γ) (h : α →CO β) :\n    (f.comp g).comp h = f.comp (g.comp h) :=\n  rfl\n\n"}
{"name":"ContinuousOpenMap.comp_id","module":"Mathlib.Topology.Hom.Open","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\nf : ContinuousOpenMap α β\n⊢ Eq (f.comp (ContinuousOpenMap.id α)) f","decl":"@[simp]\ntheorem comp_id (f : α →CO β) : f.comp (ContinuousOpenMap.id α) = f :=\n  ext fun _ => rfl\n\n"}
{"name":"ContinuousOpenMap.id_comp","module":"Mathlib.Topology.Hom.Open","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\nf : ContinuousOpenMap α β\n⊢ Eq ((ContinuousOpenMap.id β).comp f) f","decl":"@[simp]\ntheorem id_comp (f : α →CO β) : (ContinuousOpenMap.id β).comp f = f :=\n  ext fun _ => rfl\n\n"}
{"name":"ContinuousOpenMap.cancel_right","module":"Mathlib.Topology.Hom.Open","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace β\ninst✝ : TopologicalSpace γ\ng₁ g₂ : ContinuousOpenMap β γ\nf : ContinuousOpenMap α β\nhf : Function.Surjective ⇑f\n⊢ Iff (Eq (g₁.comp f) (g₂.comp f)) (Eq g₁ g₂)","decl":"@[simp]\ntheorem cancel_right {g₁ g₂ : β →CO γ} {f : α →CO β} (hf : Surjective f) :\n    g₁.comp f = g₂.comp f ↔ g₁ = g₂ :=\n  ⟨fun h => ext <| hf.forall.2 <| DFunLike.ext_iff.1 h, fun h => congr_arg₂ _ h rfl⟩\n\n"}
{"name":"ContinuousOpenMap.cancel_left","module":"Mathlib.Topology.Hom.Open","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace β\ninst✝ : TopologicalSpace γ\ng : ContinuousOpenMap β γ\nf₁ f₂ : ContinuousOpenMap α β\nhg : Function.Injective ⇑g\n⊢ Iff (Eq (g.comp f₁) (g.comp f₂)) (Eq f₁ f₂)","decl":"@[simp]\ntheorem cancel_left {g : β →CO γ} {f₁ f₂ : α →CO β} (hg : Injective g) :\n    g.comp f₁ = g.comp f₂ ↔ f₁ = f₂ :=\n  ⟨fun h => ext fun a => hg <| by rw [← comp_apply, h, comp_apply], congr_arg _⟩\n\n"}
