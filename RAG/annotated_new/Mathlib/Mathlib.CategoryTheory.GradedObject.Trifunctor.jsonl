{"name":"CategoryTheory.GradedObject.mapTrifunctorObj_obj_obj","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\nC‚ÇÑ : Type u_4\ninst‚úù¬≥ : CategoryTheory.Category.{u_10, u_1} C‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u_11, u_2} C‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{u_12, u_3} C‚ÇÉ\ninst‚úù : CategoryTheory.Category.{u_13, u_4} C‚ÇÑ\nF : CategoryTheory.Functor C‚ÇÅ (CategoryTheory.Functor C‚ÇÇ (CategoryTheory.Functor C‚ÇÉ C‚ÇÑ))\nI‚ÇÅ : Type u_7\nX‚ÇÅ : CategoryTheory.GradedObject I‚ÇÅ C‚ÇÅ\nI‚ÇÇ : Type u_8\nI‚ÇÉ : Type u_9\nX‚ÇÇ : CategoryTheory.GradedObject I‚ÇÇ C‚ÇÇ\nX‚ÇÉ : CategoryTheory.GradedObject I‚ÇÉ C‚ÇÉ\nx : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ)\n‚ä¢ Eq (((CategoryTheory.GradedObject.mapTrifunctorObj F X‚ÇÅ I‚ÇÇ I‚ÇÉ).obj X‚ÇÇ).obj X‚ÇÉ x) (((F.obj (X‚ÇÅ x.1)).obj (X‚ÇÇ x.2.1)).obj (X‚ÇÉ x.2.2))","decl":"/-- Auxiliary definition for `mapTrifunctor`. -/\n@[simps]\ndef mapTrifunctorObj {I‚ÇÅ : Type*} (X‚ÇÅ : GradedObject I‚ÇÅ C‚ÇÅ) (I‚ÇÇ I‚ÇÉ : Type*) :\n    GradedObject I‚ÇÇ C‚ÇÇ ‚•§ GradedObject I‚ÇÉ C‚ÇÉ ‚•§ GradedObject (I‚ÇÅ √ó I‚ÇÇ √ó I‚ÇÉ) C‚ÇÑ where\n  obj X‚ÇÇ :=\n    { obj := fun X‚ÇÉ x => ((F.obj (X‚ÇÅ x.1)).obj (X‚ÇÇ x.2.1)).obj (X‚ÇÉ x.2.2)\n      map := fun {_ _} œÜ x => ((F.obj (X‚ÇÅ x.1)).obj (X‚ÇÇ x.2.1)).map (œÜ x.2.2) }\n  map {X‚ÇÇ Y‚ÇÇ} œÜ :=\n    { app := fun X‚ÇÉ x => ((F.obj (X‚ÇÅ x.1)).map (œÜ x.2.1)).app (X‚ÇÉ x.2.2) }\n\n"}
{"name":"CategoryTheory.GradedObject.mapTrifunctorObj_map_app","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\nC‚ÇÑ : Type u_4\ninst‚úù¬≥ : CategoryTheory.Category.{u_10, u_1} C‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u_11, u_2} C‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{u_12, u_3} C‚ÇÉ\ninst‚úù : CategoryTheory.Category.{u_13, u_4} C‚ÇÑ\nF : CategoryTheory.Functor C‚ÇÅ (CategoryTheory.Functor C‚ÇÇ (CategoryTheory.Functor C‚ÇÉ C‚ÇÑ))\nI‚ÇÅ : Type u_7\nX‚ÇÅ : CategoryTheory.GradedObject I‚ÇÅ C‚ÇÅ\nI‚ÇÇ : Type u_8\nI‚ÇÉ : Type u_9\nX‚ÇÇ Y‚ÇÇ : CategoryTheory.GradedObject I‚ÇÇ C‚ÇÇ\nœÜ : Quiver.Hom X‚ÇÇ Y‚ÇÇ\nX‚ÇÉ : CategoryTheory.GradedObject I‚ÇÉ C‚ÇÉ\nx : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ)\n‚ä¢ Eq (((CategoryTheory.GradedObject.mapTrifunctorObj F X‚ÇÅ I‚ÇÇ I‚ÇÉ).map œÜ).app X‚ÇÉ x) (((F.obj (X‚ÇÅ x.1)).map (œÜ x.2.1)).app (X‚ÇÉ x.2.2))","decl":"/-- Auxiliary definition for `mapTrifunctor`. -/\n@[simps]\ndef mapTrifunctorObj {I‚ÇÅ : Type*} (X‚ÇÅ : GradedObject I‚ÇÅ C‚ÇÅ) (I‚ÇÇ I‚ÇÉ : Type*) :\n    GradedObject I‚ÇÇ C‚ÇÇ ‚•§ GradedObject I‚ÇÉ C‚ÇÉ ‚•§ GradedObject (I‚ÇÅ √ó I‚ÇÇ √ó I‚ÇÉ) C‚ÇÑ where\n  obj X‚ÇÇ :=\n    { obj := fun X‚ÇÉ x => ((F.obj (X‚ÇÅ x.1)).obj (X‚ÇÇ x.2.1)).obj (X‚ÇÉ x.2.2)\n      map := fun {_ _} œÜ x => ((F.obj (X‚ÇÅ x.1)).obj (X‚ÇÇ x.2.1)).map (œÜ x.2.2) }\n  map {X‚ÇÇ Y‚ÇÇ} œÜ :=\n    { app := fun X‚ÇÉ x => ((F.obj (X‚ÇÅ x.1)).map (œÜ x.2.1)).app (X‚ÇÉ x.2.2) }\n\n"}
{"name":"CategoryTheory.GradedObject.mapTrifunctorObj_obj_map","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\nC‚ÇÑ : Type u_4\ninst‚úù¬≥ : CategoryTheory.Category.{u_10, u_1} C‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u_11, u_2} C‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{u_12, u_3} C‚ÇÉ\ninst‚úù : CategoryTheory.Category.{u_13, u_4} C‚ÇÑ\nF : CategoryTheory.Functor C‚ÇÅ (CategoryTheory.Functor C‚ÇÇ (CategoryTheory.Functor C‚ÇÉ C‚ÇÑ))\nI‚ÇÅ : Type u_7\nX‚ÇÅ : CategoryTheory.GradedObject I‚ÇÅ C‚ÇÅ\nI‚ÇÇ : Type u_8\nI‚ÇÉ : Type u_9\nX‚ÇÇ : CategoryTheory.GradedObject I‚ÇÇ C‚ÇÇ\nx‚úù¬π x‚úù : CategoryTheory.GradedObject I‚ÇÉ C‚ÇÉ\nœÜ : Quiver.Hom x‚úù¬π x‚úù\nx : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ)\n‚ä¢ Eq (((CategoryTheory.GradedObject.mapTrifunctorObj F X‚ÇÅ I‚ÇÇ I‚ÇÉ).obj X‚ÇÇ).map œÜ x) (((F.obj (X‚ÇÅ x.1)).obj (X‚ÇÇ x.2.1)).map (œÜ x.2.2))","decl":"/-- Auxiliary definition for `mapTrifunctor`. -/\n@[simps]\ndef mapTrifunctorObj {I‚ÇÅ : Type*} (X‚ÇÅ : GradedObject I‚ÇÅ C‚ÇÅ) (I‚ÇÇ I‚ÇÉ : Type*) :\n    GradedObject I‚ÇÇ C‚ÇÇ ‚•§ GradedObject I‚ÇÉ C‚ÇÉ ‚•§ GradedObject (I‚ÇÅ √ó I‚ÇÇ √ó I‚ÇÉ) C‚ÇÑ where\n  obj X‚ÇÇ :=\n    { obj := fun X‚ÇÉ x => ((F.obj (X‚ÇÅ x.1)).obj (X‚ÇÇ x.2.1)).obj (X‚ÇÉ x.2.2)\n      map := fun {_ _} œÜ x => ((F.obj (X‚ÇÅ x.1)).obj (X‚ÇÇ x.2.1)).map (œÜ x.2.2) }\n  map {X‚ÇÇ Y‚ÇÇ} œÜ :=\n    { app := fun X‚ÇÉ x => ((F.obj (X‚ÇÅ x.1)).map (œÜ x.2.1)).app (X‚ÇÉ x.2.2) }\n\n"}
{"name":"CategoryTheory.GradedObject.mapTrifunctor_map_app_app","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\nC‚ÇÑ : Type u_4\ninst‚úù¬≥ : CategoryTheory.Category.{u_10, u_1} C‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u_11, u_2} C‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{u_12, u_3} C‚ÇÉ\ninst‚úù : CategoryTheory.Category.{u_13, u_4} C‚ÇÑ\nF : CategoryTheory.Functor C‚ÇÅ (CategoryTheory.Functor C‚ÇÇ (CategoryTheory.Functor C‚ÇÉ C‚ÇÑ))\nI‚ÇÅ : Type u_7\nI‚ÇÇ : Type u_8\nI‚ÇÉ : Type u_9\nX‚ÇÅ Y‚ÇÅ : CategoryTheory.GradedObject I‚ÇÅ C‚ÇÅ\nœÜ : Quiver.Hom X‚ÇÅ Y‚ÇÅ\nX‚ÇÇ : CategoryTheory.GradedObject I‚ÇÇ C‚ÇÇ\nX‚ÇÉ : CategoryTheory.GradedObject I‚ÇÉ C‚ÇÉ\nx : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ)\n‚ä¢ Eq ((((CategoryTheory.GradedObject.mapTrifunctor F I‚ÇÅ I‚ÇÇ I‚ÇÉ).map œÜ).app X‚ÇÇ).app X‚ÇÉ x) (((F.map (œÜ x.1)).app (X‚ÇÇ x.2.1)).app (X‚ÇÉ x.2.2))","decl":"/-- Given a trifunctor `F : C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ C‚ÇÉ ‚•§ C‚ÇÑ` and types `I‚ÇÅ`, `I‚ÇÇ`, `I‚ÇÉ`,\nthis is the obvious functor\n`GradedObject I‚ÇÅ C‚ÇÅ ‚•§ GradedObject I‚ÇÇ C‚ÇÇ ‚•§ GradedObject I‚ÇÉ C‚ÇÉ ‚•§ GradedObject (I‚ÇÅ √ó I‚ÇÇ √ó I‚ÇÉ) C‚ÇÑ`.\n-/\n@[simps]\ndef mapTrifunctor (I‚ÇÅ I‚ÇÇ I‚ÇÉ : Type*) :\n    GradedObject I‚ÇÅ C‚ÇÅ ‚•§ GradedObject I‚ÇÇ C‚ÇÇ ‚•§ GradedObject I‚ÇÉ C‚ÇÉ ‚•§\n      GradedObject (I‚ÇÅ √ó I‚ÇÇ √ó I‚ÇÉ) C‚ÇÑ where\n  obj X‚ÇÅ := mapTrifunctorObj F X‚ÇÅ I‚ÇÇ I‚ÇÉ\n  map {X‚ÇÅ Y‚ÇÅ} œÜ :=\n    { app := fun X‚ÇÇ =>\n        { app := fun X‚ÇÉ x => ((F.map (œÜ x.1)).app (X‚ÇÇ x.2.1)).app (X‚ÇÉ x.2.2) }\n      naturality := fun {X‚ÇÇ Y‚ÇÇ} œà => by\n        ext X‚ÇÉ x\n        dsimp\n        simp only [‚Üê NatTrans.comp_app]\n        congr 1\n        rw [NatTrans.naturality] }\n"}
{"name":"CategoryTheory.GradedObject.mapTrifunctor_obj","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\nC‚ÇÑ : Type u_4\ninst‚úù¬≥ : CategoryTheory.Category.{u_10, u_1} C‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u_11, u_2} C‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{u_12, u_3} C‚ÇÉ\ninst‚úù : CategoryTheory.Category.{u_13, u_4} C‚ÇÑ\nF : CategoryTheory.Functor C‚ÇÅ (CategoryTheory.Functor C‚ÇÇ (CategoryTheory.Functor C‚ÇÉ C‚ÇÑ))\nI‚ÇÅ : Type u_7\nI‚ÇÇ : Type u_8\nI‚ÇÉ : Type u_9\nX‚ÇÅ : CategoryTheory.GradedObject I‚ÇÅ C‚ÇÅ\n‚ä¢ Eq ((CategoryTheory.GradedObject.mapTrifunctor F I‚ÇÅ I‚ÇÇ I‚ÇÉ).obj X‚ÇÅ) (CategoryTheory.GradedObject.mapTrifunctorObj F X‚ÇÅ I‚ÇÇ I‚ÇÉ)","decl":"/-- Given a trifunctor `F : C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ C‚ÇÉ ‚•§ C‚ÇÑ` and types `I‚ÇÅ`, `I‚ÇÇ`, `I‚ÇÉ`,\nthis is the obvious functor\n`GradedObject I‚ÇÅ C‚ÇÅ ‚•§ GradedObject I‚ÇÇ C‚ÇÇ ‚•§ GradedObject I‚ÇÉ C‚ÇÉ ‚•§ GradedObject (I‚ÇÅ √ó I‚ÇÇ √ó I‚ÇÉ) C‚ÇÑ`.\n-/\n@[simps]\ndef mapTrifunctor (I‚ÇÅ I‚ÇÇ I‚ÇÉ : Type*) :\n    GradedObject I‚ÇÅ C‚ÇÅ ‚•§ GradedObject I‚ÇÇ C‚ÇÇ ‚•§ GradedObject I‚ÇÉ C‚ÇÉ ‚•§\n      GradedObject (I‚ÇÅ √ó I‚ÇÇ √ó I‚ÇÉ) C‚ÇÑ where\n  obj X‚ÇÅ := mapTrifunctorObj F X‚ÇÅ I‚ÇÇ I‚ÇÉ\n  map {X‚ÇÅ Y‚ÇÅ} œÜ :=\n    { app := fun X‚ÇÇ =>\n        { app := fun X‚ÇÉ x => ((F.map (œÜ x.1)).app (X‚ÇÇ x.2.1)).app (X‚ÇÉ x.2.2) }\n      naturality := fun {X‚ÇÇ Y‚ÇÇ} œà => by\n        ext X‚ÇÉ x\n        dsimp\n        simp only [‚Üê NatTrans.comp_app]\n        congr 1\n        rw [NatTrans.naturality] }\n"}
{"name":"CategoryTheory.GradedObject.mapTrifunctorMapNatTrans_app_app_app","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\nC‚ÇÑ : Type u_4\ninst‚úù¬≥ : CategoryTheory.Category.{u_10, u_1} C‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u_11, u_2} C‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{u_12, u_3} C‚ÇÉ\ninst‚úù : CategoryTheory.Category.{u_13, u_4} C‚ÇÑ\nF F' : CategoryTheory.Functor C‚ÇÅ (CategoryTheory.Functor C‚ÇÇ (CategoryTheory.Functor C‚ÇÉ C‚ÇÑ))\nŒ± : Quiver.Hom F F'\nI‚ÇÅ : Type u_7\nI‚ÇÇ : Type u_8\nI‚ÇÉ : Type u_9\nX‚ÇÅ : CategoryTheory.GradedObject I‚ÇÅ C‚ÇÅ\nX‚ÇÇ : CategoryTheory.GradedObject I‚ÇÇ C‚ÇÇ\nx‚úù¬π : CategoryTheory.GradedObject I‚ÇÉ C‚ÇÉ\nx‚úù : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ)\n‚ä¢ Eq ((((CategoryTheory.GradedObject.mapTrifunctorMapNatTrans Œ± I‚ÇÅ I‚ÇÇ I‚ÇÉ).app X‚ÇÅ).app X‚ÇÇ).app x‚úù¬π x‚úù) (((Œ±.app (X‚ÇÅ x‚úù.1)).app (X‚ÇÇ x‚úù.2.1)).app (x‚úù¬π x‚úù.2.2))","decl":"/-- The natural transformation `mapTrifunctor F I‚ÇÅ I‚ÇÇ I‚ÇÉ ‚ü∂ mapTrifunctor F' I‚ÇÅ I‚ÇÇ I‚ÇÉ`\ninduced by a natural transformation `F ‚ü∂ F` of trifunctors. -/\n@[simps]\ndef mapTrifunctorMapNatTrans (Œ± : F ‚ü∂ F') (I‚ÇÅ I‚ÇÇ I‚ÇÉ : Type*) :\n    mapTrifunctor F I‚ÇÅ I‚ÇÇ I‚ÇÉ ‚ü∂ mapTrifunctor F' I‚ÇÅ I‚ÇÇ I‚ÇÉ where\n  app X‚ÇÅ :=\n    { app := fun X‚ÇÇ =>\n        { app := fun _ _ => ((Œ±.app _).app _).app _ }\n      naturality := fun {X‚ÇÇ Y‚ÇÇ} œÜ => by\n        ext X‚ÇÉ ‚ü®i‚ÇÅ, i‚ÇÇ, i‚ÇÉ‚ü©\n        dsimp\n        simp only [‚Üê NatTrans.comp_app, NatTrans.naturality] }\n  naturality := fun {X‚ÇÅ Y‚ÇÅ} œÜ => by\n    ext X‚ÇÇ X‚ÇÉ ‚ü®i‚ÇÅ, i‚ÇÇ, i‚ÇÉ‚ü©\n    dsimp\n    simp only [‚Üê NatTrans.comp_app, NatTrans.naturality]\n\n"}
{"name":"CategoryTheory.GradedObject.mapTrifunctorMapIso_inv","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\nC‚ÇÑ : Type u_4\ninst‚úù¬≥ : CategoryTheory.Category.{u_10, u_1} C‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u_11, u_2} C‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{u_12, u_3} C‚ÇÉ\ninst‚úù : CategoryTheory.Category.{u_13, u_4} C‚ÇÑ\nF F' : CategoryTheory.Functor C‚ÇÅ (CategoryTheory.Functor C‚ÇÇ (CategoryTheory.Functor C‚ÇÉ C‚ÇÑ))\ne : CategoryTheory.Iso F F'\nI‚ÇÅ : Type u_7\nI‚ÇÇ : Type u_8\nI‚ÇÉ : Type u_9\n‚ä¢ Eq (CategoryTheory.GradedObject.mapTrifunctorMapIso e I‚ÇÅ I‚ÇÇ I‚ÇÉ).inv (CategoryTheory.GradedObject.mapTrifunctorMapNatTrans e.inv I‚ÇÅ I‚ÇÇ I‚ÇÉ)","decl":"/-- The natural isomorphism `mapTrifunctor F I‚ÇÅ I‚ÇÇ I‚ÇÉ ‚âÖ mapTrifunctor F' I‚ÇÅ I‚ÇÇ I‚ÇÉ`\ninduced by a natural isomorphism `F ‚âÖ F` of trifunctors. -/\n@[simps]\ndef mapTrifunctorMapIso (e : F ‚âÖ F') (I‚ÇÅ I‚ÇÇ I‚ÇÉ : Type*) :\n    mapTrifunctor F I‚ÇÅ I‚ÇÇ I‚ÇÉ ‚âÖ mapTrifunctor F' I‚ÇÅ I‚ÇÇ I‚ÇÉ where\n  hom := mapTrifunctorMapNatTrans e.hom I‚ÇÅ I‚ÇÇ I‚ÇÉ\n  inv := mapTrifunctorMapNatTrans e.inv I‚ÇÅ I‚ÇÇ I‚ÇÉ\n  hom_inv_id := by\n    ext X‚ÇÅ X‚ÇÇ X‚ÇÉ ‚ü®i‚ÇÅ, i‚ÇÇ, i‚ÇÉ‚ü©\n    dsimp\n    simp only [‚Üê NatTrans.comp_app, e.hom_inv_id, NatTrans.id_app]\n  inv_hom_id := by\n    ext X‚ÇÅ X‚ÇÇ X‚ÇÉ ‚ü®i‚ÇÅ, i‚ÇÇ, i‚ÇÉ‚ü©\n    dsimp\n    simp only [‚Üê NatTrans.comp_app, e.inv_hom_id, NatTrans.id_app]\n\n"}
{"name":"CategoryTheory.GradedObject.mapTrifunctorMapIso_hom","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\nC‚ÇÑ : Type u_4\ninst‚úù¬≥ : CategoryTheory.Category.{u_10, u_1} C‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u_11, u_2} C‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{u_12, u_3} C‚ÇÉ\ninst‚úù : CategoryTheory.Category.{u_13, u_4} C‚ÇÑ\nF F' : CategoryTheory.Functor C‚ÇÅ (CategoryTheory.Functor C‚ÇÇ (CategoryTheory.Functor C‚ÇÉ C‚ÇÑ))\ne : CategoryTheory.Iso F F'\nI‚ÇÅ : Type u_7\nI‚ÇÇ : Type u_8\nI‚ÇÉ : Type u_9\n‚ä¢ Eq (CategoryTheory.GradedObject.mapTrifunctorMapIso e I‚ÇÅ I‚ÇÇ I‚ÇÉ).hom (CategoryTheory.GradedObject.mapTrifunctorMapNatTrans e.hom I‚ÇÅ I‚ÇÇ I‚ÇÉ)","decl":"/-- The natural isomorphism `mapTrifunctor F I‚ÇÅ I‚ÇÇ I‚ÇÉ ‚âÖ mapTrifunctor F' I‚ÇÅ I‚ÇÇ I‚ÇÉ`\ninduced by a natural isomorphism `F ‚âÖ F` of trifunctors. -/\n@[simps]\ndef mapTrifunctorMapIso (e : F ‚âÖ F') (I‚ÇÅ I‚ÇÇ I‚ÇÉ : Type*) :\n    mapTrifunctor F I‚ÇÅ I‚ÇÇ I‚ÇÉ ‚âÖ mapTrifunctor F' I‚ÇÅ I‚ÇÇ I‚ÇÉ where\n  hom := mapTrifunctorMapNatTrans e.hom I‚ÇÅ I‚ÇÇ I‚ÇÉ\n  inv := mapTrifunctorMapNatTrans e.inv I‚ÇÅ I‚ÇÇ I‚ÇÉ\n  hom_inv_id := by\n    ext X‚ÇÅ X‚ÇÇ X‚ÇÉ ‚ü®i‚ÇÅ, i‚ÇÇ, i‚ÇÉ‚ü©\n    dsimp\n    simp only [‚Üê NatTrans.comp_app, e.hom_inv_id, NatTrans.id_app]\n  inv_hom_id := by\n    ext X‚ÇÅ X‚ÇÇ X‚ÇÉ ‚ü®i‚ÇÅ, i‚ÇÇ, i‚ÇÉ‚ü©\n    dsimp\n    simp only [‚Üê NatTrans.comp_app, e.inv_hom_id, NatTrans.id_app]\n\n"}
{"name":"CategoryTheory.GradedObject.Œπ_mapTrifunctorMapMap_assoc","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\nC‚ÇÑ : Type u_4\ninst‚úù‚Åµ : CategoryTheory.Category.{u_11, u_1} C‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_12, u_2} C‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{u_13, u_3} C‚ÇÉ\ninst‚úù¬≤ : CategoryTheory.Category.{u_14, u_4} C‚ÇÑ\nF : CategoryTheory.Functor C‚ÇÅ (CategoryTheory.Functor C‚ÇÇ (CategoryTheory.Functor C‚ÇÉ C‚ÇÑ))\nI‚ÇÅ : Type u_7\nI‚ÇÇ : Type u_8\nI‚ÇÉ : Type u_9\nJ : Type u_10\np : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ) ‚Üí J\nX‚ÇÅ Y‚ÇÅ : CategoryTheory.GradedObject I‚ÇÅ C‚ÇÅ\nf‚ÇÅ : Quiver.Hom X‚ÇÅ Y‚ÇÅ\nX‚ÇÇ Y‚ÇÇ : CategoryTheory.GradedObject I‚ÇÇ C‚ÇÇ\nf‚ÇÇ : Quiver.Hom X‚ÇÇ Y‚ÇÇ\nX‚ÇÉ Y‚ÇÉ : CategoryTheory.GradedObject I‚ÇÉ C‚ÇÉ\nf‚ÇÉ : Quiver.Hom X‚ÇÉ Y‚ÇÉ\ninst‚úù¬π : ((((CategoryTheory.GradedObject.mapTrifunctor F I‚ÇÅ I‚ÇÇ I‚ÇÉ).obj X‚ÇÅ).obj X‚ÇÇ).obj X‚ÇÉ).HasMap p\ninst‚úù : ((((CategoryTheory.GradedObject.mapTrifunctor F I‚ÇÅ I‚ÇÇ I‚ÇÉ).obj Y‚ÇÅ).obj Y‚ÇÇ).obj Y‚ÇÉ).HasMap p\ni‚ÇÅ : I‚ÇÅ\ni‚ÇÇ : I‚ÇÇ\ni‚ÇÉ : I‚ÇÉ\nj : J\nh‚úù : Eq (p { fst := i‚ÇÅ, snd := { fst := i‚ÇÇ, snd := i‚ÇÉ } }) j\nZ : C‚ÇÑ\nh : Quiver.Hom (CategoryTheory.GradedObject.mapTrifunctorMapObj F p Y‚ÇÅ Y‚ÇÇ Y‚ÇÉ j) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ŒπMapTrifunctorMapObj F p X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h‚úù) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.mapTrifunctorMapMap F p f‚ÇÅ f‚ÇÇ f‚ÇÉ j) h)) (CategoryTheory.CategoryStruct.comp (((F.map (f‚ÇÅ i‚ÇÅ)).app (X‚ÇÇ i‚ÇÇ)).app (X‚ÇÉ i‚ÇÉ)) (CategoryTheory.CategoryStruct.comp (((F.obj (Y‚ÇÅ i‚ÇÅ)).map (f‚ÇÇ i‚ÇÇ)).app (X‚ÇÉ i‚ÇÉ)) (CategoryTheory.CategoryStruct.comp (((F.obj (Y‚ÇÅ i‚ÇÅ)).obj (Y‚ÇÇ i‚ÇÇ)).map (f‚ÇÉ i‚ÇÉ)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ŒπMapTrifunctorMapObj F p Y‚ÇÅ Y‚ÇÇ Y‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h‚úù) h))))","decl":"@[reassoc (attr := simp)]\nlemma Œπ_mapTrifunctorMapMap {X‚ÇÅ Y‚ÇÅ : GradedObject I‚ÇÅ C‚ÇÅ} (f‚ÇÅ : X‚ÇÅ ‚ü∂ Y‚ÇÅ)\n    {X‚ÇÇ Y‚ÇÇ : GradedObject I‚ÇÇ C‚ÇÇ} (f‚ÇÇ : X‚ÇÇ ‚ü∂ Y‚ÇÇ)\n    {X‚ÇÉ Y‚ÇÉ : GradedObject I‚ÇÉ C‚ÇÉ} (f‚ÇÉ : X‚ÇÉ ‚ü∂ Y‚ÇÉ)\n    [HasMap ((((mapTrifunctor F I‚ÇÅ I‚ÇÇ I‚ÇÉ).obj X‚ÇÅ).obj X‚ÇÇ).obj X‚ÇÉ) p]\n    [HasMap ((((mapTrifunctor F I‚ÇÅ I‚ÇÇ I‚ÇÉ).obj Y‚ÇÅ).obj Y‚ÇÇ).obj Y‚ÇÉ) p]\n    (i‚ÇÅ : I‚ÇÅ) (i‚ÇÇ : I‚ÇÇ) (i‚ÇÉ : I‚ÇÉ) (j : J) (h : p ‚ü®i‚ÇÅ, i‚ÇÇ, i‚ÇÉ‚ü© = j) :\n  ŒπMapTrifunctorMapObj F p X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h ‚â´ mapTrifunctorMapMap F p f‚ÇÅ f‚ÇÇ f‚ÇÉ j =\n    ((F.map (f‚ÇÅ i‚ÇÅ)).app (X‚ÇÇ i‚ÇÇ)).app (X‚ÇÉ i‚ÇÉ) ‚â´\n      ((F.obj (Y‚ÇÅ i‚ÇÅ)).map (f‚ÇÇ i‚ÇÇ)).app (X‚ÇÉ i‚ÇÉ) ‚â´\n      ((F.obj (Y‚ÇÅ i‚ÇÅ)).obj (Y‚ÇÇ i‚ÇÇ)).map (f‚ÇÉ i‚ÇÉ) ‚â´\n      ŒπMapTrifunctorMapObj F p Y‚ÇÅ Y‚ÇÇ Y‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h := by\n  dsimp only [ŒπMapTrifunctorMapObj, mapTrifunctorMapMap]\n  rw [Œπ_mapMap]\n  dsimp\n  rw [assoc, assoc]\n\n"}
{"name":"CategoryTheory.GradedObject.Œπ_mapTrifunctorMapMap","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\nC‚ÇÑ : Type u_4\ninst‚úù‚Åµ : CategoryTheory.Category.{u_11, u_1} C‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_12, u_2} C‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{u_13, u_3} C‚ÇÉ\ninst‚úù¬≤ : CategoryTheory.Category.{u_14, u_4} C‚ÇÑ\nF : CategoryTheory.Functor C‚ÇÅ (CategoryTheory.Functor C‚ÇÇ (CategoryTheory.Functor C‚ÇÉ C‚ÇÑ))\nI‚ÇÅ : Type u_7\nI‚ÇÇ : Type u_8\nI‚ÇÉ : Type u_9\nJ : Type u_10\np : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ) ‚Üí J\nX‚ÇÅ Y‚ÇÅ : CategoryTheory.GradedObject I‚ÇÅ C‚ÇÅ\nf‚ÇÅ : Quiver.Hom X‚ÇÅ Y‚ÇÅ\nX‚ÇÇ Y‚ÇÇ : CategoryTheory.GradedObject I‚ÇÇ C‚ÇÇ\nf‚ÇÇ : Quiver.Hom X‚ÇÇ Y‚ÇÇ\nX‚ÇÉ Y‚ÇÉ : CategoryTheory.GradedObject I‚ÇÉ C‚ÇÉ\nf‚ÇÉ : Quiver.Hom X‚ÇÉ Y‚ÇÉ\ninst‚úù¬π : ((((CategoryTheory.GradedObject.mapTrifunctor F I‚ÇÅ I‚ÇÇ I‚ÇÉ).obj X‚ÇÅ).obj X‚ÇÇ).obj X‚ÇÉ).HasMap p\ninst‚úù : ((((CategoryTheory.GradedObject.mapTrifunctor F I‚ÇÅ I‚ÇÇ I‚ÇÉ).obj Y‚ÇÅ).obj Y‚ÇÇ).obj Y‚ÇÉ).HasMap p\ni‚ÇÅ : I‚ÇÅ\ni‚ÇÇ : I‚ÇÇ\ni‚ÇÉ : I‚ÇÉ\nj : J\nh : Eq (p { fst := i‚ÇÅ, snd := { fst := i‚ÇÇ, snd := i‚ÇÉ } }) j\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ŒπMapTrifunctorMapObj F p X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h) (CategoryTheory.GradedObject.mapTrifunctorMapMap F p f‚ÇÅ f‚ÇÇ f‚ÇÉ j)) (CategoryTheory.CategoryStruct.comp (((F.map (f‚ÇÅ i‚ÇÅ)).app (X‚ÇÇ i‚ÇÇ)).app (X‚ÇÉ i‚ÇÉ)) (CategoryTheory.CategoryStruct.comp (((F.obj (Y‚ÇÅ i‚ÇÅ)).map (f‚ÇÇ i‚ÇÇ)).app (X‚ÇÉ i‚ÇÉ)) (CategoryTheory.CategoryStruct.comp (((F.obj (Y‚ÇÅ i‚ÇÅ)).obj (Y‚ÇÇ i‚ÇÇ)).map (f‚ÇÉ i‚ÇÉ)) (CategoryTheory.GradedObject.ŒπMapTrifunctorMapObj F p Y‚ÇÅ Y‚ÇÇ Y‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h))))","decl":"@[reassoc (attr := simp)]\nlemma Œπ_mapTrifunctorMapMap {X‚ÇÅ Y‚ÇÅ : GradedObject I‚ÇÅ C‚ÇÅ} (f‚ÇÅ : X‚ÇÅ ‚ü∂ Y‚ÇÅ)\n    {X‚ÇÇ Y‚ÇÇ : GradedObject I‚ÇÇ C‚ÇÇ} (f‚ÇÇ : X‚ÇÇ ‚ü∂ Y‚ÇÇ)\n    {X‚ÇÉ Y‚ÇÉ : GradedObject I‚ÇÉ C‚ÇÉ} (f‚ÇÉ : X‚ÇÉ ‚ü∂ Y‚ÇÉ)\n    [HasMap ((((mapTrifunctor F I‚ÇÅ I‚ÇÇ I‚ÇÉ).obj X‚ÇÅ).obj X‚ÇÇ).obj X‚ÇÉ) p]\n    [HasMap ((((mapTrifunctor F I‚ÇÅ I‚ÇÇ I‚ÇÉ).obj Y‚ÇÅ).obj Y‚ÇÇ).obj Y‚ÇÉ) p]\n    (i‚ÇÅ : I‚ÇÅ) (i‚ÇÇ : I‚ÇÇ) (i‚ÇÉ : I‚ÇÉ) (j : J) (h : p ‚ü®i‚ÇÅ, i‚ÇÇ, i‚ÇÉ‚ü© = j) :\n  ŒπMapTrifunctorMapObj F p X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h ‚â´ mapTrifunctorMapMap F p f‚ÇÅ f‚ÇÇ f‚ÇÉ j =\n    ((F.map (f‚ÇÅ i‚ÇÅ)).app (X‚ÇÇ i‚ÇÇ)).app (X‚ÇÉ i‚ÇÉ) ‚â´\n      ((F.obj (Y‚ÇÅ i‚ÇÅ)).map (f‚ÇÇ i‚ÇÇ)).app (X‚ÇÉ i‚ÇÉ) ‚â´\n      ((F.obj (Y‚ÇÅ i‚ÇÅ)).obj (Y‚ÇÇ i‚ÇÇ)).map (f‚ÇÉ i‚ÇÉ) ‚â´\n      ŒπMapTrifunctorMapObj F p Y‚ÇÅ Y‚ÇÇ Y‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h := by\n  dsimp only [ŒπMapTrifunctorMapObj, mapTrifunctorMapMap]\n  rw [Œπ_mapMap]\n  dsimp\n  rw [assoc, assoc]\n\n"}
{"name":"CategoryTheory.GradedObject.mapTrifunctorMapObj_ext","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\nC‚ÇÑ : Type u_4\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_14, u_1} C‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{u_13, u_2} C‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{u_12, u_3} C‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{u_11, u_4} C‚ÇÑ\nF : CategoryTheory.Functor C‚ÇÅ (CategoryTheory.Functor C‚ÇÇ (CategoryTheory.Functor C‚ÇÉ C‚ÇÑ))\nI‚ÇÅ : Type u_7\nI‚ÇÇ : Type u_8\nI‚ÇÉ : Type u_9\nJ : Type u_10\np : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ) ‚Üí J\nX‚ÇÅ : CategoryTheory.GradedObject I‚ÇÅ C‚ÇÅ\nX‚ÇÇ : CategoryTheory.GradedObject I‚ÇÇ C‚ÇÇ\nX‚ÇÉ : CategoryTheory.GradedObject I‚ÇÉ C‚ÇÉ\nY : C‚ÇÑ\nj : J\ninst‚úù : ((((CategoryTheory.GradedObject.mapTrifunctor F I‚ÇÅ I‚ÇÇ I‚ÇÉ).obj X‚ÇÅ).obj X‚ÇÇ).obj X‚ÇÉ).HasMap p\nœÜ œÜ' : Quiver.Hom (CategoryTheory.GradedObject.mapTrifunctorMapObj F p X‚ÇÅ X‚ÇÇ X‚ÇÉ j) Y\nh : ‚àÄ (i‚ÇÅ : I‚ÇÅ) (i‚ÇÇ : I‚ÇÇ) (i‚ÇÉ : I‚ÇÉ) (h : Eq (p { fst := i‚ÇÅ, snd := { fst := i‚ÇÇ, snd := i‚ÇÉ } }) j), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ŒπMapTrifunctorMapObj F p X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h) œÜ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ŒπMapTrifunctorMapObj F p X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h) œÜ')\n‚ä¢ Eq œÜ œÜ'","decl":"@[ext]\nlemma mapTrifunctorMapObj_ext {X‚ÇÅ : GradedObject I‚ÇÅ C‚ÇÅ} {X‚ÇÇ : GradedObject I‚ÇÇ C‚ÇÇ}\n    {X‚ÇÉ : GradedObject I‚ÇÉ C‚ÇÉ} {Y : C‚ÇÑ} (j : J)\n    [HasMap ((((mapTrifunctor F I‚ÇÅ I‚ÇÇ I‚ÇÉ).obj X‚ÇÅ).obj X‚ÇÇ).obj X‚ÇÉ) p]\n    {œÜ œÜ' : mapTrifunctorMapObj F p X‚ÇÅ X‚ÇÇ X‚ÇÉ j ‚ü∂ Y}\n    (h : ‚àÄ (i‚ÇÅ : I‚ÇÅ) (i‚ÇÇ : I‚ÇÇ) (i‚ÇÉ : I‚ÇÉ) (h : p ‚ü®i‚ÇÅ, i‚ÇÇ, i‚ÇÉ‚ü© = j),\n      ŒπMapTrifunctorMapObj F p X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h ‚â´ œÜ =\n        ŒπMapTrifunctorMapObj F p X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h ‚â´ œÜ') : œÜ = œÜ' := by\n  apply mapObj_ext\n  rintro ‚ü®i‚ÇÅ, i‚ÇÇ, i‚ÇÉ‚ü© hi\n  apply h\n\n"}
{"name":"CategoryTheory.GradedObject.mapTrifunctorMapObj_ext_iff","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\nC‚ÇÑ : Type u_4\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_14, u_1} C‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{u_13, u_2} C‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{u_12, u_3} C‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{u_11, u_4} C‚ÇÑ\nF : CategoryTheory.Functor C‚ÇÅ (CategoryTheory.Functor C‚ÇÇ (CategoryTheory.Functor C‚ÇÉ C‚ÇÑ))\nI‚ÇÅ : Type u_7\nI‚ÇÇ : Type u_8\nI‚ÇÉ : Type u_9\nJ : Type u_10\np : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ) ‚Üí J\nX‚ÇÅ : CategoryTheory.GradedObject I‚ÇÅ C‚ÇÅ\nX‚ÇÇ : CategoryTheory.GradedObject I‚ÇÇ C‚ÇÇ\nX‚ÇÉ : CategoryTheory.GradedObject I‚ÇÉ C‚ÇÉ\nY : C‚ÇÑ\nj : J\ninst‚úù : ((((CategoryTheory.GradedObject.mapTrifunctor F I‚ÇÅ I‚ÇÇ I‚ÇÉ).obj X‚ÇÅ).obj X‚ÇÇ).obj X‚ÇÉ).HasMap p\nœÜ œÜ' : Quiver.Hom (CategoryTheory.GradedObject.mapTrifunctorMapObj F p X‚ÇÅ X‚ÇÇ X‚ÇÉ j) Y\n‚ä¢ Iff (Eq œÜ œÜ') (‚àÄ (i‚ÇÅ : I‚ÇÅ) (i‚ÇÇ : I‚ÇÇ) (i‚ÇÉ : I‚ÇÉ) (h : Eq (p { fst := i‚ÇÅ, snd := { fst := i‚ÇÇ, snd := i‚ÇÉ } }) j), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ŒπMapTrifunctorMapObj F p X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h) œÜ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ŒπMapTrifunctorMapObj F p X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h) œÜ'))","decl":"@[ext]\nlemma mapTrifunctorMapObj_ext {X‚ÇÅ : GradedObject I‚ÇÅ C‚ÇÅ} {X‚ÇÇ : GradedObject I‚ÇÇ C‚ÇÇ}\n    {X‚ÇÉ : GradedObject I‚ÇÉ C‚ÇÉ} {Y : C‚ÇÑ} (j : J)\n    [HasMap ((((mapTrifunctor F I‚ÇÅ I‚ÇÇ I‚ÇÉ).obj X‚ÇÅ).obj X‚ÇÇ).obj X‚ÇÉ) p]\n    {œÜ œÜ' : mapTrifunctorMapObj F p X‚ÇÅ X‚ÇÇ X‚ÇÉ j ‚ü∂ Y}\n    (h : ‚àÄ (i‚ÇÅ : I‚ÇÅ) (i‚ÇÇ : I‚ÇÇ) (i‚ÇÉ : I‚ÇÉ) (h : p ‚ü®i‚ÇÅ, i‚ÇÇ, i‚ÇÉ‚ü© = j),\n      ŒπMapTrifunctorMapObj F p X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h ‚â´ œÜ =\n        ŒπMapTrifunctorMapObj F p X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h ‚â´ œÜ') : œÜ = œÜ' := by\n  apply mapObj_ext\n  rintro ‚ü®i‚ÇÅ, i‚ÇÇ, i‚ÇÉ‚ü© hi\n  apply h\n\n"}
{"name":"CategoryTheory.GradedObject.instHasMapProdObjFunctorMapTrifunctorObjOfMapTrifunctor","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\nC‚ÇÑ : Type u_4\ninst‚úù¬≥ : CategoryTheory.Category.{u_14, u_1} C‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u_13, u_2} C‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{u_12, u_3} C‚ÇÉ\ninst‚úù : CategoryTheory.Category.{u_11, u_4} C‚ÇÑ\nF : CategoryTheory.Functor C‚ÇÅ (CategoryTheory.Functor C‚ÇÇ (CategoryTheory.Functor C‚ÇÉ C‚ÇÑ))\nI‚ÇÅ : Type u_7\nI‚ÇÇ : Type u_8\nI‚ÇÉ : Type u_9\nJ : Type u_10\np : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ) ‚Üí J\nX‚ÇÅ : CategoryTheory.GradedObject I‚ÇÅ C‚ÇÅ\nX‚ÇÇ : CategoryTheory.GradedObject I‚ÇÇ C‚ÇÇ\nX‚ÇÉ : CategoryTheory.GradedObject I‚ÇÉ C‚ÇÉ\nh : ((((CategoryTheory.GradedObject.mapTrifunctor F I‚ÇÅ I‚ÇÇ I‚ÇÉ).obj X‚ÇÅ).obj X‚ÇÇ).obj X‚ÇÉ).HasMap p\n‚ä¢ (((CategoryTheory.GradedObject.mapTrifunctorObj F X‚ÇÅ I‚ÇÇ I‚ÇÉ).obj X‚ÇÇ).obj X‚ÇÉ).HasMap p","decl":"instance (X‚ÇÅ : GradedObject I‚ÇÅ C‚ÇÅ) (X‚ÇÇ : GradedObject I‚ÇÇ C‚ÇÇ) (X‚ÇÉ : GradedObject I‚ÇÉ C‚ÇÉ)\n  [h : HasMap ((((mapTrifunctor F I‚ÇÅ I‚ÇÇ I‚ÇÉ).obj X‚ÇÅ).obj X‚ÇÇ).obj X‚ÇÉ) p] :\n      HasMap (((mapTrifunctorObj F X‚ÇÅ I‚ÇÇ I‚ÇÉ).obj X‚ÇÇ).obj X‚ÇÉ) p := h\n\n"}
{"name":"CategoryTheory.GradedObject.mapTrifunctorMapFunctorObj_obj_map","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\nC‚ÇÑ : Type u_4\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_11, u_1} C‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{u_12, u_2} C‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{u_13, u_3} C‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{u_14, u_4} C‚ÇÑ\nF : CategoryTheory.Functor C‚ÇÅ (CategoryTheory.Functor C‚ÇÇ (CategoryTheory.Functor C‚ÇÉ C‚ÇÑ))\nI‚ÇÅ : Type u_7\nI‚ÇÇ : Type u_8\nI‚ÇÉ : Type u_9\nJ : Type u_10\np : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ) ‚Üí J\nX‚ÇÅ : CategoryTheory.GradedObject I‚ÇÅ C‚ÇÅ\ninst‚úù : ‚àÄ (X‚ÇÇ : CategoryTheory.GradedObject I‚ÇÇ C‚ÇÇ) (X‚ÇÉ : CategoryTheory.GradedObject I‚ÇÉ C‚ÇÉ), ((((CategoryTheory.GradedObject.mapTrifunctor F I‚ÇÅ I‚ÇÇ I‚ÇÉ).obj X‚ÇÅ).obj X‚ÇÇ).obj X‚ÇÉ).HasMap p\nX‚ÇÇ : CategoryTheory.GradedObject I‚ÇÇ C‚ÇÇ\nx‚úù¬π x‚úù : CategoryTheory.GradedObject I‚ÇÉ C‚ÇÉ\nœÜ : Quiver.Hom x‚úù¬π x‚úù\ni : J\n‚ä¢ Eq (((CategoryTheory.GradedObject.mapTrifunctorMapFunctorObj F p X‚ÇÅ).obj X‚ÇÇ).map œÜ i) (CategoryTheory.GradedObject.mapTrifunctorMapMap F p (CategoryTheory.CategoryStruct.id X‚ÇÅ) (CategoryTheory.CategoryStruct.id X‚ÇÇ) œÜ i)","decl":"/-- Given a trifunctor `F : C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ C‚ÇÉ ‚•§ C‚ÇÑ`, a map `p : I‚ÇÅ √ó I‚ÇÇ √ó I‚ÇÉ ‚Üí J`, and\ngraded objects `X‚ÇÅ : GradedObject I‚ÇÅ C‚ÇÅ`, `X‚ÇÇ : GradedObject I‚ÇÇ C‚ÇÇ` and `X‚ÇÉ : GradedObject I‚ÇÉ C‚ÇÉ`,\nthis is the `J`-graded object sending `j` to the coproduct of\n`((F.obj (X‚ÇÅ i‚ÇÅ)).obj (X‚ÇÇ i‚ÇÇ)).obj (X‚ÇÉ i‚ÇÉ)` for `p ‚ü®i‚ÇÅ, i‚ÇÇ, i‚ÇÉ‚ü© = j`. -/\n@[simps]\nnoncomputable def mapTrifunctorMapFunctorObj (X‚ÇÅ : GradedObject I‚ÇÅ C‚ÇÅ)\n    [‚àÄ X‚ÇÇ X‚ÇÉ, HasMap ((((mapTrifunctor F I‚ÇÅ I‚ÇÇ I‚ÇÉ).obj X‚ÇÅ).obj X‚ÇÇ).obj X‚ÇÉ) p] :\n    GradedObject I‚ÇÇ C‚ÇÇ ‚•§ GradedObject I‚ÇÉ C‚ÇÉ ‚•§ GradedObject J C‚ÇÑ where\n  obj X‚ÇÇ :=\n    { obj := fun X‚ÇÉ => mapTrifunctorMapObj F p X‚ÇÅ X‚ÇÇ X‚ÇÉ\n      map := fun {_ _} œÜ => mapTrifunctorMapMap F p (ùüô X‚ÇÅ) (ùüô X‚ÇÇ) œÜ\n      map_id := fun X‚ÇÉ => by\n        dsimp\n        ext j i‚ÇÅ i‚ÇÇ i‚ÇÉ h\n        simp only [Œπ_mapTrifunctorMapMap, categoryOfGradedObjects_id, Functor.map_id,\n          NatTrans.id_app, id_comp, comp_id]\n      map_comp := fun {X‚ÇÉ Y‚ÇÉ Z‚ÇÉ} œÜ œà => by\n        dsimp\n        ext j i‚ÇÅ i‚ÇÇ i‚ÇÉ h\n        simp only [Œπ_mapTrifunctorMapMap, categoryOfGradedObjects_id, Functor.map_id,\n          NatTrans.id_app, categoryOfGradedObjects_comp, Functor.map_comp, assoc, id_comp,\n          Œπ_mapTrifunctorMapMap_assoc] }\n  map {X‚ÇÇ Y‚ÇÇ} œÜ :=\n    { app := fun X‚ÇÉ => mapTrifunctorMapMap F p (ùüô X‚ÇÅ) œÜ (ùüô X‚ÇÉ)\n      naturality := fun {X‚ÇÉ Y‚ÇÉ} œà => by\n        ext j i‚ÇÅ i‚ÇÇ i‚ÇÉ h\n        dsimp\n        simp only [Œπ_mapTrifunctorMapMap_assoc, categoryOfGradedObjects_id, Functor.map_id,\n          NatTrans.id_app, Œπ_mapTrifunctorMapMap, id_comp, NatTrans.naturality_assoc] }\n  map_id X‚ÇÇ := by\n    dsimp\n    ext X‚ÇÉ j i‚ÇÅ i‚ÇÇ i‚ÇÉ h\n    simp only [Œπ_mapTrifunctorMapMap, categoryOfGradedObjects_id, Functor.map_id,\n      NatTrans.id_app, id_comp, comp_id]\n  map_comp {X‚ÇÇ Y‚ÇÇ Z‚ÇÇ} œÜ œà := by\n    dsimp\n    ext X‚ÇÉ j i‚ÇÅ i‚ÇÇ i‚ÇÉ\n    simp only [Œπ_mapTrifunctorMapMap, categoryOfGradedObjects_id, Functor.map_id,\n      NatTrans.id_app, categoryOfGradedObjects_comp, Functor.map_comp, NatTrans.comp_app,\n      id_comp, assoc, Œπ_mapTrifunctorMapMap_assoc]\n\n"}
{"name":"CategoryTheory.GradedObject.mapTrifunctorMapFunctorObj_obj_obj","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\nC‚ÇÑ : Type u_4\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_11, u_1} C‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{u_12, u_2} C‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{u_13, u_3} C‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{u_14, u_4} C‚ÇÑ\nF : CategoryTheory.Functor C‚ÇÅ (CategoryTheory.Functor C‚ÇÇ (CategoryTheory.Functor C‚ÇÉ C‚ÇÑ))\nI‚ÇÅ : Type u_7\nI‚ÇÇ : Type u_8\nI‚ÇÉ : Type u_9\nJ : Type u_10\np : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ) ‚Üí J\nX‚ÇÅ : CategoryTheory.GradedObject I‚ÇÅ C‚ÇÅ\ninst‚úù : ‚àÄ (X‚ÇÇ : CategoryTheory.GradedObject I‚ÇÇ C‚ÇÇ) (X‚ÇÉ : CategoryTheory.GradedObject I‚ÇÉ C‚ÇÉ), ((((CategoryTheory.GradedObject.mapTrifunctor F I‚ÇÅ I‚ÇÇ I‚ÇÉ).obj X‚ÇÅ).obj X‚ÇÇ).obj X‚ÇÉ).HasMap p\nX‚ÇÇ : CategoryTheory.GradedObject I‚ÇÇ C‚ÇÇ\nX‚ÇÉ : CategoryTheory.GradedObject I‚ÇÉ C‚ÇÉ\n‚ä¢ Eq (((CategoryTheory.GradedObject.mapTrifunctorMapFunctorObj F p X‚ÇÅ).obj X‚ÇÇ).obj X‚ÇÉ) (CategoryTheory.GradedObject.mapTrifunctorMapObj F p X‚ÇÅ X‚ÇÇ X‚ÇÉ)","decl":"/-- Given a trifunctor `F : C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ C‚ÇÉ ‚•§ C‚ÇÑ`, a map `p : I‚ÇÅ √ó I‚ÇÇ √ó I‚ÇÉ ‚Üí J`, and\ngraded objects `X‚ÇÅ : GradedObject I‚ÇÅ C‚ÇÅ`, `X‚ÇÇ : GradedObject I‚ÇÇ C‚ÇÇ` and `X‚ÇÉ : GradedObject I‚ÇÉ C‚ÇÉ`,\nthis is the `J`-graded object sending `j` to the coproduct of\n`((F.obj (X‚ÇÅ i‚ÇÅ)).obj (X‚ÇÇ i‚ÇÇ)).obj (X‚ÇÉ i‚ÇÉ)` for `p ‚ü®i‚ÇÅ, i‚ÇÇ, i‚ÇÉ‚ü© = j`. -/\n@[simps]\nnoncomputable def mapTrifunctorMapFunctorObj (X‚ÇÅ : GradedObject I‚ÇÅ C‚ÇÅ)\n    [‚àÄ X‚ÇÇ X‚ÇÉ, HasMap ((((mapTrifunctor F I‚ÇÅ I‚ÇÇ I‚ÇÉ).obj X‚ÇÅ).obj X‚ÇÇ).obj X‚ÇÉ) p] :\n    GradedObject I‚ÇÇ C‚ÇÇ ‚•§ GradedObject I‚ÇÉ C‚ÇÉ ‚•§ GradedObject J C‚ÇÑ where\n  obj X‚ÇÇ :=\n    { obj := fun X‚ÇÉ => mapTrifunctorMapObj F p X‚ÇÅ X‚ÇÇ X‚ÇÉ\n      map := fun {_ _} œÜ => mapTrifunctorMapMap F p (ùüô X‚ÇÅ) (ùüô X‚ÇÇ) œÜ\n      map_id := fun X‚ÇÉ => by\n        dsimp\n        ext j i‚ÇÅ i‚ÇÇ i‚ÇÉ h\n        simp only [Œπ_mapTrifunctorMapMap, categoryOfGradedObjects_id, Functor.map_id,\n          NatTrans.id_app, id_comp, comp_id]\n      map_comp := fun {X‚ÇÉ Y‚ÇÉ Z‚ÇÉ} œÜ œà => by\n        dsimp\n        ext j i‚ÇÅ i‚ÇÇ i‚ÇÉ h\n        simp only [Œπ_mapTrifunctorMapMap, categoryOfGradedObjects_id, Functor.map_id,\n          NatTrans.id_app, categoryOfGradedObjects_comp, Functor.map_comp, assoc, id_comp,\n          Œπ_mapTrifunctorMapMap_assoc] }\n  map {X‚ÇÇ Y‚ÇÇ} œÜ :=\n    { app := fun X‚ÇÉ => mapTrifunctorMapMap F p (ùüô X‚ÇÅ) œÜ (ùüô X‚ÇÉ)\n      naturality := fun {X‚ÇÉ Y‚ÇÉ} œà => by\n        ext j i‚ÇÅ i‚ÇÇ i‚ÇÉ h\n        dsimp\n        simp only [Œπ_mapTrifunctorMapMap_assoc, categoryOfGradedObjects_id, Functor.map_id,\n          NatTrans.id_app, Œπ_mapTrifunctorMapMap, id_comp, NatTrans.naturality_assoc] }\n  map_id X‚ÇÇ := by\n    dsimp\n    ext X‚ÇÉ j i‚ÇÅ i‚ÇÇ i‚ÇÉ h\n    simp only [Œπ_mapTrifunctorMapMap, categoryOfGradedObjects_id, Functor.map_id,\n      NatTrans.id_app, id_comp, comp_id]\n  map_comp {X‚ÇÇ Y‚ÇÇ Z‚ÇÇ} œÜ œà := by\n    dsimp\n    ext X‚ÇÉ j i‚ÇÅ i‚ÇÇ i‚ÇÉ\n    simp only [Œπ_mapTrifunctorMapMap, categoryOfGradedObjects_id, Functor.map_id,\n      NatTrans.id_app, categoryOfGradedObjects_comp, Functor.map_comp, NatTrans.comp_app,\n      id_comp, assoc, Œπ_mapTrifunctorMapMap_assoc]\n\n"}
{"name":"CategoryTheory.GradedObject.mapTrifunctorMapFunctorObj_map_app","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\nC‚ÇÑ : Type u_4\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_11, u_1} C‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{u_12, u_2} C‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{u_13, u_3} C‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{u_14, u_4} C‚ÇÑ\nF : CategoryTheory.Functor C‚ÇÅ (CategoryTheory.Functor C‚ÇÇ (CategoryTheory.Functor C‚ÇÉ C‚ÇÑ))\nI‚ÇÅ : Type u_7\nI‚ÇÇ : Type u_8\nI‚ÇÉ : Type u_9\nJ : Type u_10\np : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ) ‚Üí J\nX‚ÇÅ : CategoryTheory.GradedObject I‚ÇÅ C‚ÇÅ\ninst‚úù : ‚àÄ (X‚ÇÇ : CategoryTheory.GradedObject I‚ÇÇ C‚ÇÇ) (X‚ÇÉ : CategoryTheory.GradedObject I‚ÇÉ C‚ÇÉ), ((((CategoryTheory.GradedObject.mapTrifunctor F I‚ÇÅ I‚ÇÇ I‚ÇÉ).obj X‚ÇÅ).obj X‚ÇÇ).obj X‚ÇÉ).HasMap p\nX‚ÇÇ Y‚ÇÇ : CategoryTheory.GradedObject I‚ÇÇ C‚ÇÇ\nœÜ : Quiver.Hom X‚ÇÇ Y‚ÇÇ\nX‚ÇÉ : CategoryTheory.GradedObject I‚ÇÉ C‚ÇÉ\ni : J\n‚ä¢ Eq (((CategoryTheory.GradedObject.mapTrifunctorMapFunctorObj F p X‚ÇÅ).map œÜ).app X‚ÇÉ i) (CategoryTheory.GradedObject.mapTrifunctorMapMap F p (CategoryTheory.CategoryStruct.id X‚ÇÅ) œÜ (CategoryTheory.CategoryStruct.id X‚ÇÉ) i)","decl":"/-- Given a trifunctor `F : C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ C‚ÇÉ ‚•§ C‚ÇÑ`, a map `p : I‚ÇÅ √ó I‚ÇÇ √ó I‚ÇÉ ‚Üí J`, and\ngraded objects `X‚ÇÅ : GradedObject I‚ÇÅ C‚ÇÅ`, `X‚ÇÇ : GradedObject I‚ÇÇ C‚ÇÇ` and `X‚ÇÉ : GradedObject I‚ÇÉ C‚ÇÉ`,\nthis is the `J`-graded object sending `j` to the coproduct of\n`((F.obj (X‚ÇÅ i‚ÇÅ)).obj (X‚ÇÇ i‚ÇÇ)).obj (X‚ÇÉ i‚ÇÉ)` for `p ‚ü®i‚ÇÅ, i‚ÇÇ, i‚ÇÉ‚ü© = j`. -/\n@[simps]\nnoncomputable def mapTrifunctorMapFunctorObj (X‚ÇÅ : GradedObject I‚ÇÅ C‚ÇÅ)\n    [‚àÄ X‚ÇÇ X‚ÇÉ, HasMap ((((mapTrifunctor F I‚ÇÅ I‚ÇÇ I‚ÇÉ).obj X‚ÇÅ).obj X‚ÇÇ).obj X‚ÇÉ) p] :\n    GradedObject I‚ÇÇ C‚ÇÇ ‚•§ GradedObject I‚ÇÉ C‚ÇÉ ‚•§ GradedObject J C‚ÇÑ where\n  obj X‚ÇÇ :=\n    { obj := fun X‚ÇÉ => mapTrifunctorMapObj F p X‚ÇÅ X‚ÇÇ X‚ÇÉ\n      map := fun {_ _} œÜ => mapTrifunctorMapMap F p (ùüô X‚ÇÅ) (ùüô X‚ÇÇ) œÜ\n      map_id := fun X‚ÇÉ => by\n        dsimp\n        ext j i‚ÇÅ i‚ÇÇ i‚ÇÉ h\n        simp only [Œπ_mapTrifunctorMapMap, categoryOfGradedObjects_id, Functor.map_id,\n          NatTrans.id_app, id_comp, comp_id]\n      map_comp := fun {X‚ÇÉ Y‚ÇÉ Z‚ÇÉ} œÜ œà => by\n        dsimp\n        ext j i‚ÇÅ i‚ÇÇ i‚ÇÉ h\n        simp only [Œπ_mapTrifunctorMapMap, categoryOfGradedObjects_id, Functor.map_id,\n          NatTrans.id_app, categoryOfGradedObjects_comp, Functor.map_comp, assoc, id_comp,\n          Œπ_mapTrifunctorMapMap_assoc] }\n  map {X‚ÇÇ Y‚ÇÇ} œÜ :=\n    { app := fun X‚ÇÉ => mapTrifunctorMapMap F p (ùüô X‚ÇÅ) œÜ (ùüô X‚ÇÉ)\n      naturality := fun {X‚ÇÉ Y‚ÇÉ} œà => by\n        ext j i‚ÇÅ i‚ÇÇ i‚ÇÉ h\n        dsimp\n        simp only [Œπ_mapTrifunctorMapMap_assoc, categoryOfGradedObjects_id, Functor.map_id,\n          NatTrans.id_app, Œπ_mapTrifunctorMapMap, id_comp, NatTrans.naturality_assoc] }\n  map_id X‚ÇÇ := by\n    dsimp\n    ext X‚ÇÉ j i‚ÇÅ i‚ÇÇ i‚ÇÉ h\n    simp only [Œπ_mapTrifunctorMapMap, categoryOfGradedObjects_id, Functor.map_id,\n      NatTrans.id_app, id_comp, comp_id]\n  map_comp {X‚ÇÇ Y‚ÇÇ Z‚ÇÇ} œÜ œà := by\n    dsimp\n    ext X‚ÇÉ j i‚ÇÅ i‚ÇÇ i‚ÇÉ\n    simp only [Œπ_mapTrifunctorMapMap, categoryOfGradedObjects_id, Functor.map_id,\n      NatTrans.id_app, categoryOfGradedObjects_comp, Functor.map_comp, NatTrans.comp_app,\n      id_comp, assoc, Œπ_mapTrifunctorMapMap_assoc]\n\n"}
{"name":"CategoryTheory.GradedObject.mapTrifunctorMap_map_app_app","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\nC‚ÇÑ : Type u_4\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_11, u_1} C‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{u_12, u_2} C‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{u_13, u_3} C‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{u_14, u_4} C‚ÇÑ\nF : CategoryTheory.Functor C‚ÇÅ (CategoryTheory.Functor C‚ÇÇ (CategoryTheory.Functor C‚ÇÉ C‚ÇÑ))\nI‚ÇÅ : Type u_7\nI‚ÇÇ : Type u_8\nI‚ÇÉ : Type u_9\nJ : Type u_10\np : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ) ‚Üí J\ninst‚úù : ‚àÄ (X‚ÇÅ : CategoryTheory.GradedObject I‚ÇÅ C‚ÇÅ) (X‚ÇÇ : CategoryTheory.GradedObject I‚ÇÇ C‚ÇÇ) (X‚ÇÉ : CategoryTheory.GradedObject I‚ÇÉ C‚ÇÉ), ((((CategoryTheory.GradedObject.mapTrifunctor F I‚ÇÅ I‚ÇÇ I‚ÇÉ).obj X‚ÇÅ).obj X‚ÇÇ).obj X‚ÇÉ).HasMap p\nX‚ÇÅ Y‚ÇÅ : CategoryTheory.GradedObject I‚ÇÅ C‚ÇÅ\nœÜ : Quiver.Hom X‚ÇÅ Y‚ÇÅ\nX‚ÇÇ : CategoryTheory.GradedObject I‚ÇÇ C‚ÇÇ\nX‚ÇÉ : CategoryTheory.GradedObject I‚ÇÉ C‚ÇÉ\ni : J\n‚ä¢ Eq ((((CategoryTheory.GradedObject.mapTrifunctorMap F p).map œÜ).app X‚ÇÇ).app X‚ÇÉ i) (CategoryTheory.GradedObject.mapTrifunctorMapMap F p œÜ (CategoryTheory.CategoryStruct.id X‚ÇÇ) (CategoryTheory.CategoryStruct.id X‚ÇÉ) i)","decl":"attribute [simps] mapTrifunctorMap\n\n"}
{"name":"CategoryTheory.GradedObject.mapTrifunctorMap_obj","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\nC‚ÇÑ : Type u_4\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_11, u_1} C‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{u_12, u_2} C‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{u_13, u_3} C‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{u_14, u_4} C‚ÇÑ\nF : CategoryTheory.Functor C‚ÇÅ (CategoryTheory.Functor C‚ÇÇ (CategoryTheory.Functor C‚ÇÉ C‚ÇÑ))\nI‚ÇÅ : Type u_7\nI‚ÇÇ : Type u_8\nI‚ÇÉ : Type u_9\nJ : Type u_10\np : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ) ‚Üí J\ninst‚úù : ‚àÄ (X‚ÇÅ : CategoryTheory.GradedObject I‚ÇÅ C‚ÇÅ) (X‚ÇÇ : CategoryTheory.GradedObject I‚ÇÇ C‚ÇÇ) (X‚ÇÉ : CategoryTheory.GradedObject I‚ÇÉ C‚ÇÉ), ((((CategoryTheory.GradedObject.mapTrifunctor F I‚ÇÅ I‚ÇÇ I‚ÇÉ).obj X‚ÇÅ).obj X‚ÇÇ).obj X‚ÇÉ).HasMap p\nX‚ÇÅ : CategoryTheory.GradedObject I‚ÇÅ C‚ÇÅ\n‚ä¢ Eq ((CategoryTheory.GradedObject.mapTrifunctorMap F p).obj X‚ÇÅ) (CategoryTheory.GradedObject.mapTrifunctorMapFunctorObj F p X‚ÇÅ)","decl":"attribute [simps] mapTrifunctorMap\n\n"}
{"name":"CategoryTheory.GradedObject.BifunctorComp‚ÇÅ‚ÇÇIndexData.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"I‚ÇÅ : Type u_7\nI‚ÇÇ : Type u_8\nI‚ÇÉ : Type u_9\nJ : Type u_10\nr : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ) ‚Üí J\ninst‚úù¬≥ : SizeOf I‚ÇÅ\ninst‚úù¬≤ : SizeOf I‚ÇÇ\ninst‚úù¬π : SizeOf I‚ÇÉ\ninst‚úù : SizeOf J\nI‚ÇÅ‚ÇÇ : Type u_11\np : Prod I‚ÇÅ I‚ÇÇ ‚Üí I‚ÇÅ‚ÇÇ\nq : Prod I‚ÇÅ‚ÇÇ I‚ÇÉ ‚Üí J\nhpq : ‚àÄ (i : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ)), Eq (q { fst := p { fst := i.1, snd := i.2.1 }, snd := i.2.2 }) (r i)\n‚ä¢ Eq (SizeOf.sizeOf { I‚ÇÅ‚ÇÇ := I‚ÇÅ‚ÇÇ, p := p, q := q, hpq := hpq }) (HAdd.hAdd 1 (SizeOf.sizeOf I‚ÇÅ‚ÇÇ))","decl":"/-- Given a map `r : I‚ÇÅ √ó I‚ÇÇ √ó I‚ÇÉ ‚Üí J`, a `BifunctorComp‚ÇÅ‚ÇÇIndexData r` consists of the data\nof a type `I‚ÇÅ‚ÇÇ`, maps `p : I‚ÇÅ √ó I‚ÇÇ ‚Üí I‚ÇÅ‚ÇÇ` and `q : I‚ÇÅ‚ÇÇ √ó I‚ÇÉ ‚Üí J`, such that `r` is obtained\nby composition of `p` and `q`. -/\nstructure BifunctorComp‚ÇÅ‚ÇÇIndexData where\n  /-- an auxiliary type -/\n  I‚ÇÅ‚ÇÇ : Type*\n  /-- a map `I‚ÇÅ √ó I‚ÇÇ ‚Üí I‚ÇÅ‚ÇÇ` -/\n  p : I‚ÇÅ √ó I‚ÇÇ ‚Üí I‚ÇÅ‚ÇÇ\n  /-- a map `I‚ÇÅ‚ÇÇ √ó I‚ÇÉ ‚Üí J` -/\n  q : I‚ÇÅ‚ÇÇ √ó I‚ÇÉ ‚Üí J\n  hpq (i : I‚ÇÅ √ó I‚ÇÇ √ó I‚ÇÉ) : q ‚ü®p ‚ü®i.1, i.2.1‚ü©, i.2.2‚ü© = r i\n\n"}
{"name":"CategoryTheory.GradedObject.BifunctorComp‚ÇÅ‚ÇÇIndexData.hpq","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"I‚ÇÅ : Type u_7\nI‚ÇÇ : Type u_8\nI‚ÇÉ : Type u_9\nJ : Type u_10\nr : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ) ‚Üí J\nself : CategoryTheory.GradedObject.BifunctorComp‚ÇÅ‚ÇÇIndexData r\ni : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ)\n‚ä¢ Eq (self.q { fst := self.p { fst := i.1, snd := i.2.1 }, snd := i.2.2 }) (r i)","decl":"/-- Given a map `r : I‚ÇÅ √ó I‚ÇÇ √ó I‚ÇÉ ‚Üí J`, a `BifunctorComp‚ÇÅ‚ÇÇIndexData r` consists of the data\nof a type `I‚ÇÅ‚ÇÇ`, maps `p : I‚ÇÅ √ó I‚ÇÇ ‚Üí I‚ÇÅ‚ÇÇ` and `q : I‚ÇÅ‚ÇÇ √ó I‚ÇÉ ‚Üí J`, such that `r` is obtained\nby composition of `p` and `q`. -/\nstructure BifunctorComp‚ÇÅ‚ÇÇIndexData where\n  /-- an auxiliary type -/\n  I‚ÇÅ‚ÇÇ : Type*\n  /-- a map `I‚ÇÅ √ó I‚ÇÇ ‚Üí I‚ÇÅ‚ÇÇ` -/\n  p : I‚ÇÅ √ó I‚ÇÇ ‚Üí I‚ÇÅ‚ÇÇ\n  /-- a map `I‚ÇÅ‚ÇÇ √ó I‚ÇÉ ‚Üí J` -/\n  q : I‚ÇÅ‚ÇÇ √ó I‚ÇÉ ‚Üí J\n  hpq (i : I‚ÇÅ √ó I‚ÇÇ √ó I‚ÇÉ) : q ‚ü®p ‚ü®i.1, i.2.1‚ü©, i.2.2‚ü© = r i\n\n"}
{"name":"CategoryTheory.GradedObject.BifunctorComp‚ÇÅ‚ÇÇIndexData.mk.inj","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"I‚ÇÅ : Type u_7\nI‚ÇÇ : Type u_8\nI‚ÇÉ : Type u_9\nJ : Type u_10\nr : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ) ‚Üí J\nI‚ÇÅ‚ÇÇ‚úù : Type u_11\np‚úù : Prod I‚ÇÅ I‚ÇÇ ‚Üí I‚ÇÅ‚ÇÇ‚úù\nq‚úù : Prod I‚ÇÅ‚ÇÇ‚úù I‚ÇÉ ‚Üí J\nhpq‚úù : ‚àÄ (i : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ)), Eq (q‚úù { fst := p‚úù { fst := i.1, snd := i.2.1 }, snd := i.2.2 }) (r i)\nI‚ÇÅ‚ÇÇ : Type u_11\np : Prod I‚ÇÅ I‚ÇÇ ‚Üí I‚ÇÅ‚ÇÇ\nq : Prod I‚ÇÅ‚ÇÇ I‚ÇÉ ‚Üí J\nhpq : ‚àÄ (i : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ)), Eq (q { fst := p { fst := i.1, snd := i.2.1 }, snd := i.2.2 }) (r i)\nx‚úù : Eq { I‚ÇÅ‚ÇÇ := I‚ÇÅ‚ÇÇ‚úù, p := p‚úù, q := q‚úù, hpq := hpq‚úù } { I‚ÇÅ‚ÇÇ := I‚ÇÅ‚ÇÇ, p := p, q := q, hpq := hpq }\n‚ä¢ And (Eq I‚ÇÅ‚ÇÇ‚úù I‚ÇÅ‚ÇÇ) (And (HEq p‚úù p) (HEq q‚úù q))","decl":"/-- Given a map `r : I‚ÇÅ √ó I‚ÇÇ √ó I‚ÇÉ ‚Üí J`, a `BifunctorComp‚ÇÅ‚ÇÇIndexData r` consists of the data\nof a type `I‚ÇÅ‚ÇÇ`, maps `p : I‚ÇÅ √ó I‚ÇÇ ‚Üí I‚ÇÅ‚ÇÇ` and `q : I‚ÇÅ‚ÇÇ √ó I‚ÇÉ ‚Üí J`, such that `r` is obtained\nby composition of `p` and `q`. -/\nstructure BifunctorComp‚ÇÅ‚ÇÇIndexData where\n  /-- an auxiliary type -/\n  I‚ÇÅ‚ÇÇ : Type*\n  /-- a map `I‚ÇÅ √ó I‚ÇÇ ‚Üí I‚ÇÅ‚ÇÇ` -/\n  p : I‚ÇÅ √ó I‚ÇÇ ‚Üí I‚ÇÅ‚ÇÇ\n  /-- a map `I‚ÇÅ‚ÇÇ √ó I‚ÇÉ ‚Üí J` -/\n  q : I‚ÇÅ‚ÇÇ √ó I‚ÇÉ ‚Üí J\n  hpq (i : I‚ÇÅ √ó I‚ÇÇ √ó I‚ÇÉ) : q ‚ü®p ‚ü®i.1, i.2.1‚ü©, i.2.2‚ü© = r i\n\n"}
{"name":"CategoryTheory.GradedObject.BifunctorComp‚ÇÅ‚ÇÇIndexData.mk.injEq","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"I‚ÇÅ : Type u_7\nI‚ÇÇ : Type u_8\nI‚ÇÉ : Type u_9\nJ : Type u_10\nr : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ) ‚Üí J\nI‚ÇÅ‚ÇÇ‚úù : Type u_11\np‚úù : Prod I‚ÇÅ I‚ÇÇ ‚Üí I‚ÇÅ‚ÇÇ‚úù\nq‚úù : Prod I‚ÇÅ‚ÇÇ‚úù I‚ÇÉ ‚Üí J\nhpq‚úù : ‚àÄ (i : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ)), Eq (q‚úù { fst := p‚úù { fst := i.1, snd := i.2.1 }, snd := i.2.2 }) (r i)\nI‚ÇÅ‚ÇÇ : Type u_11\np : Prod I‚ÇÅ I‚ÇÇ ‚Üí I‚ÇÅ‚ÇÇ\nq : Prod I‚ÇÅ‚ÇÇ I‚ÇÉ ‚Üí J\nhpq : ‚àÄ (i : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ)), Eq (q { fst := p { fst := i.1, snd := i.2.1 }, snd := i.2.2 }) (r i)\n‚ä¢ Eq (Eq { I‚ÇÅ‚ÇÇ := I‚ÇÅ‚ÇÇ‚úù, p := p‚úù, q := q‚úù, hpq := hpq‚úù } { I‚ÇÅ‚ÇÇ := I‚ÇÅ‚ÇÇ, p := p, q := q, hpq := hpq }) (And (Eq I‚ÇÅ‚ÇÇ‚úù I‚ÇÅ‚ÇÇ) (And (HEq p‚úù p) (HEq q‚úù q)))","decl":"/-- Given a map `r : I‚ÇÅ √ó I‚ÇÇ √ó I‚ÇÉ ‚Üí J`, a `BifunctorComp‚ÇÅ‚ÇÇIndexData r` consists of the data\nof a type `I‚ÇÅ‚ÇÇ`, maps `p : I‚ÇÅ √ó I‚ÇÇ ‚Üí I‚ÇÅ‚ÇÇ` and `q : I‚ÇÅ‚ÇÇ √ó I‚ÇÉ ‚Üí J`, such that `r` is obtained\nby composition of `p` and `q`. -/\nstructure BifunctorComp‚ÇÅ‚ÇÇIndexData where\n  /-- an auxiliary type -/\n  I‚ÇÅ‚ÇÇ : Type*\n  /-- a map `I‚ÇÅ √ó I‚ÇÇ ‚Üí I‚ÇÅ‚ÇÇ` -/\n  p : I‚ÇÅ √ó I‚ÇÇ ‚Üí I‚ÇÅ‚ÇÇ\n  /-- a map `I‚ÇÅ‚ÇÇ √ó I‚ÇÉ ‚Üí J` -/\n  q : I‚ÇÅ‚ÇÇ √ó I‚ÇÉ ‚Üí J\n  hpq (i : I‚ÇÅ √ó I‚ÇÇ √ó I‚ÇÉ) : q ‚ü®p ‚ü®i.1, i.2.1‚ü©, i.2.2‚ü© = r i\n\n"}
{"name":"CategoryTheory.GradedObject.ŒπMapBifunctor‚ÇÅ‚ÇÇBifunctorMapObj_eq_assoc","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\nC‚ÇÑ : Type u_4\nC‚ÇÅ‚ÇÇ : Type u_5\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_16, u_1} C‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{u_15, u_2} C‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_13, u_3} C‚ÇÉ\ninst‚úù¬≥ : CategoryTheory.Category.{u_12, u_4} C‚ÇÑ\ninst‚úù¬≤ : CategoryTheory.Category.{u_14, u_5} C‚ÇÅ‚ÇÇ\nF‚ÇÅ‚ÇÇ : CategoryTheory.Functor C‚ÇÅ (CategoryTheory.Functor C‚ÇÇ C‚ÇÅ‚ÇÇ)\nG : CategoryTheory.Functor C‚ÇÅ‚ÇÇ (CategoryTheory.Functor C‚ÇÉ C‚ÇÑ)\nI‚ÇÅ : Type u_7\nI‚ÇÇ : Type u_8\nI‚ÇÉ : Type u_9\nJ : Type u_10\nr : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ) ‚Üí J\nœÅ‚ÇÅ‚ÇÇ : CategoryTheory.GradedObject.BifunctorComp‚ÇÅ‚ÇÇIndexData r\nX‚ÇÅ : CategoryTheory.GradedObject I‚ÇÅ C‚ÇÅ\nX‚ÇÇ : CategoryTheory.GradedObject I‚ÇÇ C‚ÇÇ\nX‚ÇÉ : CategoryTheory.GradedObject I‚ÇÉ C‚ÇÉ\ninst‚úù¬π : (((CategoryTheory.GradedObject.mapBifunctor F‚ÇÅ‚ÇÇ I‚ÇÅ I‚ÇÇ).obj X‚ÇÅ).obj X‚ÇÇ).HasMap œÅ‚ÇÅ‚ÇÇ.p\ninst‚úù : (((CategoryTheory.GradedObject.mapBifunctor G œÅ‚ÇÅ‚ÇÇ.I‚ÇÅ‚ÇÇ I‚ÇÉ).obj (CategoryTheory.GradedObject.mapBifunctorMapObj F‚ÇÅ‚ÇÇ œÅ‚ÇÅ‚ÇÇ.p X‚ÇÅ X‚ÇÇ)).obj X‚ÇÉ).HasMap œÅ‚ÇÅ‚ÇÇ.q\ni‚ÇÅ : I‚ÇÅ\ni‚ÇÇ : I‚ÇÇ\ni‚ÇÉ : I‚ÇÉ\nj : J\nh‚úù : Eq (r { fst := i‚ÇÅ, snd := { fst := i‚ÇÇ, snd := i‚ÇÉ } }) j\ni‚ÇÅ‚ÇÇ : œÅ‚ÇÅ‚ÇÇ.I‚ÇÅ‚ÇÇ\nh‚ÇÅ‚ÇÇ : Eq (œÅ‚ÇÅ‚ÇÇ.p { fst := i‚ÇÅ, snd := i‚ÇÇ }) i‚ÇÅ‚ÇÇ\nZ : C‚ÇÑ\nh : Quiver.Hom (CategoryTheory.GradedObject.mapBifunctorMapObj G œÅ‚ÇÅ‚ÇÇ.q (CategoryTheory.GradedObject.mapBifunctorMapObj F‚ÇÅ‚ÇÇ œÅ‚ÇÅ‚ÇÇ.p X‚ÇÅ X‚ÇÇ) X‚ÇÉ j) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ŒπMapBifunctor‚ÇÅ‚ÇÇBifunctorMapObj F‚ÇÅ‚ÇÇ G œÅ‚ÇÅ‚ÇÇ X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h‚úù) h) (CategoryTheory.CategoryStruct.comp ((G.map (CategoryTheory.GradedObject.ŒπMapBifunctorMapObj F‚ÇÅ‚ÇÇ œÅ‚ÇÅ‚ÇÇ.p X‚ÇÅ X‚ÇÇ i‚ÇÅ i‚ÇÇ i‚ÇÅ‚ÇÇ h‚ÇÅ‚ÇÇ)).app (X‚ÇÉ i‚ÇÉ)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ŒπMapBifunctorMapObj G œÅ‚ÇÅ‚ÇÇ.q (CategoryTheory.GradedObject.mapBifunctorMapObj F‚ÇÅ‚ÇÇ œÅ‚ÇÅ‚ÇÇ.p X‚ÇÅ X‚ÇÇ) X‚ÇÉ i‚ÇÅ‚ÇÇ i‚ÇÉ j ‚ãØ) h))","decl":"@[reassoc]\nlemma ŒπMapBifunctor‚ÇÅ‚ÇÇBifunctorMapObj_eq (i‚ÇÅ : I‚ÇÅ) (i‚ÇÇ : I‚ÇÇ) (i‚ÇÉ : I‚ÇÉ) (j : J)\n    (h : r (i‚ÇÅ, i‚ÇÇ, i‚ÇÉ) = j) (i‚ÇÅ‚ÇÇ : œÅ‚ÇÅ‚ÇÇ.I‚ÇÅ‚ÇÇ) (h‚ÇÅ‚ÇÇ : œÅ‚ÇÅ‚ÇÇ.p ‚ü®i‚ÇÅ, i‚ÇÇ‚ü© = i‚ÇÅ‚ÇÇ) :\n    ŒπMapBifunctor‚ÇÅ‚ÇÇBifunctorMapObj F‚ÇÅ‚ÇÇ G œÅ‚ÇÅ‚ÇÇ X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h =\n      (G.map (ŒπMapBifunctorMapObj F‚ÇÅ‚ÇÇ œÅ‚ÇÅ‚ÇÇ.p X‚ÇÅ X‚ÇÇ i‚ÇÅ i‚ÇÇ i‚ÇÅ‚ÇÇ h‚ÇÅ‚ÇÇ)).app (X‚ÇÉ i‚ÇÉ) ‚â´\n    ŒπMapBifunctorMapObj G œÅ‚ÇÅ‚ÇÇ.q (mapBifunctorMapObj F‚ÇÅ‚ÇÇ œÅ‚ÇÅ‚ÇÇ.p X‚ÇÅ X‚ÇÇ) X‚ÇÉ i‚ÇÅ‚ÇÇ i‚ÇÉ j\n      (by rw [‚Üê h‚ÇÅ‚ÇÇ, ‚Üê h, ‚Üê œÅ‚ÇÅ‚ÇÇ.hpq]) := by\n  subst h‚ÇÅ‚ÇÇ\n  rfl\n\n"}
{"name":"CategoryTheory.GradedObject.ŒπMapBifunctor‚ÇÅ‚ÇÇBifunctorMapObj_eq","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\nC‚ÇÑ : Type u_4\nC‚ÇÅ‚ÇÇ : Type u_5\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_16, u_1} C‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{u_15, u_2} C‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_13, u_3} C‚ÇÉ\ninst‚úù¬≥ : CategoryTheory.Category.{u_12, u_4} C‚ÇÑ\ninst‚úù¬≤ : CategoryTheory.Category.{u_14, u_5} C‚ÇÅ‚ÇÇ\nF‚ÇÅ‚ÇÇ : CategoryTheory.Functor C‚ÇÅ (CategoryTheory.Functor C‚ÇÇ C‚ÇÅ‚ÇÇ)\nG : CategoryTheory.Functor C‚ÇÅ‚ÇÇ (CategoryTheory.Functor C‚ÇÉ C‚ÇÑ)\nI‚ÇÅ : Type u_7\nI‚ÇÇ : Type u_8\nI‚ÇÉ : Type u_9\nJ : Type u_10\nr : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ) ‚Üí J\nœÅ‚ÇÅ‚ÇÇ : CategoryTheory.GradedObject.BifunctorComp‚ÇÅ‚ÇÇIndexData r\nX‚ÇÅ : CategoryTheory.GradedObject I‚ÇÅ C‚ÇÅ\nX‚ÇÇ : CategoryTheory.GradedObject I‚ÇÇ C‚ÇÇ\nX‚ÇÉ : CategoryTheory.GradedObject I‚ÇÉ C‚ÇÉ\ninst‚úù¬π : (((CategoryTheory.GradedObject.mapBifunctor F‚ÇÅ‚ÇÇ I‚ÇÅ I‚ÇÇ).obj X‚ÇÅ).obj X‚ÇÇ).HasMap œÅ‚ÇÅ‚ÇÇ.p\ninst‚úù : (((CategoryTheory.GradedObject.mapBifunctor G œÅ‚ÇÅ‚ÇÇ.I‚ÇÅ‚ÇÇ I‚ÇÉ).obj (CategoryTheory.GradedObject.mapBifunctorMapObj F‚ÇÅ‚ÇÇ œÅ‚ÇÅ‚ÇÇ.p X‚ÇÅ X‚ÇÇ)).obj X‚ÇÉ).HasMap œÅ‚ÇÅ‚ÇÇ.q\ni‚ÇÅ : I‚ÇÅ\ni‚ÇÇ : I‚ÇÇ\ni‚ÇÉ : I‚ÇÉ\nj : J\nh : Eq (r { fst := i‚ÇÅ, snd := { fst := i‚ÇÇ, snd := i‚ÇÉ } }) j\ni‚ÇÅ‚ÇÇ : œÅ‚ÇÅ‚ÇÇ.I‚ÇÅ‚ÇÇ\nh‚ÇÅ‚ÇÇ : Eq (œÅ‚ÇÅ‚ÇÇ.p { fst := i‚ÇÅ, snd := i‚ÇÇ }) i‚ÇÅ‚ÇÇ\n‚ä¢ Eq (CategoryTheory.GradedObject.ŒπMapBifunctor‚ÇÅ‚ÇÇBifunctorMapObj F‚ÇÅ‚ÇÇ G œÅ‚ÇÅ‚ÇÇ X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h) (CategoryTheory.CategoryStruct.comp ((G.map (CategoryTheory.GradedObject.ŒπMapBifunctorMapObj F‚ÇÅ‚ÇÇ œÅ‚ÇÅ‚ÇÇ.p X‚ÇÅ X‚ÇÇ i‚ÇÅ i‚ÇÇ i‚ÇÅ‚ÇÇ h‚ÇÅ‚ÇÇ)).app (X‚ÇÉ i‚ÇÉ)) (CategoryTheory.GradedObject.ŒπMapBifunctorMapObj G œÅ‚ÇÅ‚ÇÇ.q (CategoryTheory.GradedObject.mapBifunctorMapObj F‚ÇÅ‚ÇÇ œÅ‚ÇÅ‚ÇÇ.p X‚ÇÅ X‚ÇÇ) X‚ÇÉ i‚ÇÅ‚ÇÇ i‚ÇÉ j ‚ãØ))","decl":"@[reassoc]\nlemma ŒπMapBifunctor‚ÇÅ‚ÇÇBifunctorMapObj_eq (i‚ÇÅ : I‚ÇÅ) (i‚ÇÇ : I‚ÇÇ) (i‚ÇÉ : I‚ÇÉ) (j : J)\n    (h : r (i‚ÇÅ, i‚ÇÇ, i‚ÇÉ) = j) (i‚ÇÅ‚ÇÇ : œÅ‚ÇÅ‚ÇÇ.I‚ÇÅ‚ÇÇ) (h‚ÇÅ‚ÇÇ : œÅ‚ÇÅ‚ÇÇ.p ‚ü®i‚ÇÅ, i‚ÇÇ‚ü© = i‚ÇÅ‚ÇÇ) :\n    ŒπMapBifunctor‚ÇÅ‚ÇÇBifunctorMapObj F‚ÇÅ‚ÇÇ G œÅ‚ÇÅ‚ÇÇ X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h =\n      (G.map (ŒπMapBifunctorMapObj F‚ÇÅ‚ÇÇ œÅ‚ÇÅ‚ÇÇ.p X‚ÇÅ X‚ÇÇ i‚ÇÅ i‚ÇÇ i‚ÇÅ‚ÇÇ h‚ÇÅ‚ÇÇ)).app (X‚ÇÉ i‚ÇÉ) ‚â´\n    ŒπMapBifunctorMapObj G œÅ‚ÇÅ‚ÇÇ.q (mapBifunctorMapObj F‚ÇÅ‚ÇÇ œÅ‚ÇÅ‚ÇÇ.p X‚ÇÅ X‚ÇÇ) X‚ÇÉ i‚ÇÅ‚ÇÇ i‚ÇÉ j\n      (by rw [‚Üê h‚ÇÅ‚ÇÇ, ‚Üê h, ‚Üê œÅ‚ÇÅ‚ÇÇ.hpq]) := by\n  subst h‚ÇÅ‚ÇÇ\n  rfl\n\n"}
{"name":"CategoryTheory.GradedObject.HasGoodTrifunctor‚ÇÅ‚ÇÇObj.hasMap","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\nC‚ÇÑ : Type u_4\nC‚ÇÅ‚ÇÇ : Type u_5\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_14, u_1} C‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{u_13, u_2} C‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_12, u_3} C‚ÇÉ\ninst‚úù¬≥ : CategoryTheory.Category.{u_11, u_4} C‚ÇÑ\ninst‚úù¬≤ : CategoryTheory.Category.{u_15, u_5} C‚ÇÅ‚ÇÇ\nF‚ÇÅ‚ÇÇ : CategoryTheory.Functor C‚ÇÅ (CategoryTheory.Functor C‚ÇÇ C‚ÇÅ‚ÇÇ)\nG : CategoryTheory.Functor C‚ÇÅ‚ÇÇ (CategoryTheory.Functor C‚ÇÉ C‚ÇÑ)\nI‚ÇÅ : Type u_7\nI‚ÇÇ : Type u_8\nI‚ÇÉ : Type u_9\nJ : Type u_10\nr : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ) ‚Üí J\nœÅ‚ÇÅ‚ÇÇ : CategoryTheory.GradedObject.BifunctorComp‚ÇÅ‚ÇÇIndexData r\nX‚ÇÅ : CategoryTheory.GradedObject I‚ÇÅ C‚ÇÅ\nX‚ÇÇ : CategoryTheory.GradedObject I‚ÇÇ C‚ÇÇ\nX‚ÇÉ : CategoryTheory.GradedObject I‚ÇÉ C‚ÇÉ\ninst‚úù¬π : (((CategoryTheory.GradedObject.mapBifunctor F‚ÇÅ‚ÇÇ I‚ÇÅ I‚ÇÇ).obj X‚ÇÅ).obj X‚ÇÇ).HasMap œÅ‚ÇÅ‚ÇÇ.p\ninst‚úù : (((CategoryTheory.GradedObject.mapBifunctor G œÅ‚ÇÅ‚ÇÇ.I‚ÇÅ‚ÇÇ I‚ÇÉ).obj (CategoryTheory.GradedObject.mapBifunctorMapObj F‚ÇÅ‚ÇÇ œÅ‚ÇÅ‚ÇÇ.p X‚ÇÅ X‚ÇÇ)).obj X‚ÇÉ).HasMap œÅ‚ÇÅ‚ÇÇ.q\nH : CategoryTheory.GradedObject.HasGoodTrifunctor‚ÇÅ‚ÇÇObj F‚ÇÅ‚ÇÇ G œÅ‚ÇÅ‚ÇÇ X‚ÇÅ X‚ÇÇ X‚ÇÉ\n‚ä¢ ((((CategoryTheory.GradedObject.mapTrifunctor (CategoryTheory.bifunctorComp‚ÇÅ‚ÇÇ F‚ÇÅ‚ÇÇ G) I‚ÇÅ I‚ÇÇ I‚ÇÉ).obj X‚ÇÅ).obj X‚ÇÇ).obj X‚ÇÉ).HasMap r","decl":"include œÅ‚ÇÅ‚ÇÇ in\nlemma HasGoodTrifunctor‚ÇÅ‚ÇÇObj.hasMap :\n    HasMap ((((mapTrifunctor (bifunctorComp‚ÇÅ‚ÇÇ F‚ÇÅ‚ÇÇ G) I‚ÇÅ I‚ÇÇ I‚ÇÉ).obj X‚ÇÅ).obj X‚ÇÇ).obj X‚ÇÉ) r :=\n  fun j => ‚ü®_, isColimitCofan‚ÇÉMapBifunctor‚ÇÅ‚ÇÇBifunctorMapObj F‚ÇÅ‚ÇÇ G œÅ‚ÇÅ‚ÇÇ X‚ÇÅ X‚ÇÇ X‚ÇÉ j‚ü©\n\n"}
{"name":"CategoryTheory.GradedObject.Œπ_mapBifunctorComp‚ÇÅ‚ÇÇMapObjIso_hom_assoc","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\nC‚ÇÑ : Type u_4\nC‚ÇÅ‚ÇÇ : Type u_5\ninst‚úù‚Å∑ : CategoryTheory.Category.{u_14, u_1} C‚ÇÅ\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_13, u_2} C‚ÇÇ\ninst‚úù‚Åµ : CategoryTheory.Category.{u_12, u_3} C‚ÇÉ\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_11, u_4} C‚ÇÑ\ninst‚úù¬≥ : CategoryTheory.Category.{u_15, u_5} C‚ÇÅ‚ÇÇ\nF‚ÇÅ‚ÇÇ : CategoryTheory.Functor C‚ÇÅ (CategoryTheory.Functor C‚ÇÇ C‚ÇÅ‚ÇÇ)\nG : CategoryTheory.Functor C‚ÇÅ‚ÇÇ (CategoryTheory.Functor C‚ÇÉ C‚ÇÑ)\nI‚ÇÅ : Type u_7\nI‚ÇÇ : Type u_8\nI‚ÇÉ : Type u_9\nJ : Type u_10\nr : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ) ‚Üí J\nœÅ‚ÇÅ‚ÇÇ : CategoryTheory.GradedObject.BifunctorComp‚ÇÅ‚ÇÇIndexData r\nX‚ÇÅ : CategoryTheory.GradedObject I‚ÇÅ C‚ÇÅ\nX‚ÇÇ : CategoryTheory.GradedObject I‚ÇÇ C‚ÇÇ\nX‚ÇÉ : CategoryTheory.GradedObject I‚ÇÉ C‚ÇÉ\ninst‚úù¬≤ : (((CategoryTheory.GradedObject.mapBifunctor F‚ÇÅ‚ÇÇ I‚ÇÅ I‚ÇÇ).obj X‚ÇÅ).obj X‚ÇÇ).HasMap œÅ‚ÇÅ‚ÇÇ.p\ninst‚úù¬π : (((CategoryTheory.GradedObject.mapBifunctor G œÅ‚ÇÅ‚ÇÇ.I‚ÇÅ‚ÇÇ I‚ÇÉ).obj (CategoryTheory.GradedObject.mapBifunctorMapObj F‚ÇÅ‚ÇÇ œÅ‚ÇÅ‚ÇÇ.p X‚ÇÅ X‚ÇÇ)).obj X‚ÇÉ).HasMap œÅ‚ÇÅ‚ÇÇ.q\nH : CategoryTheory.GradedObject.HasGoodTrifunctor‚ÇÅ‚ÇÇObj F‚ÇÅ‚ÇÇ G œÅ‚ÇÅ‚ÇÇ X‚ÇÅ X‚ÇÇ X‚ÇÉ\ninst‚úù : ((((CategoryTheory.GradedObject.mapTrifunctor (CategoryTheory.bifunctorComp‚ÇÅ‚ÇÇ F‚ÇÅ‚ÇÇ G) I‚ÇÅ I‚ÇÇ I‚ÇÉ).obj X‚ÇÅ).obj X‚ÇÇ).obj X‚ÇÉ).HasMap r\ni‚ÇÅ : I‚ÇÅ\ni‚ÇÇ : I‚ÇÇ\ni‚ÇÉ : I‚ÇÉ\nj : J\nh‚úù : Eq (r { fst := i‚ÇÅ, snd := { fst := i‚ÇÇ, snd := i‚ÇÉ } }) j\nZ : C‚ÇÑ\nh : Quiver.Hom (CategoryTheory.GradedObject.mapBifunctorMapObj G œÅ‚ÇÅ‚ÇÇ.q (CategoryTheory.GradedObject.mapBifunctorMapObj F‚ÇÅ‚ÇÇ œÅ‚ÇÅ‚ÇÇ.p X‚ÇÅ X‚ÇÇ) X‚ÇÉ j) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ŒπMapTrifunctorMapObj (CategoryTheory.bifunctorComp‚ÇÅ‚ÇÇ F‚ÇÅ‚ÇÇ G) r X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h‚úù) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.GradedObject.mapBifunctorComp‚ÇÅ‚ÇÇMapObjIso F‚ÇÅ‚ÇÇ G œÅ‚ÇÅ‚ÇÇ X‚ÇÅ X‚ÇÇ X‚ÇÉ).hom j) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ŒπMapBifunctor‚ÇÅ‚ÇÇBifunctorMapObj F‚ÇÅ‚ÇÇ G œÅ‚ÇÅ‚ÇÇ X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h‚úù) h)","decl":"@[reassoc (attr := simp)]\nlemma Œπ_mapBifunctorComp‚ÇÅ‚ÇÇMapObjIso_hom (i‚ÇÅ : I‚ÇÅ) (i‚ÇÇ : I‚ÇÇ) (i‚ÇÉ : I‚ÇÉ) (j : J)\n    (h : r (i‚ÇÅ, i‚ÇÇ, i‚ÇÉ) = j) :\n    ŒπMapTrifunctorMapObj (bifunctorComp‚ÇÅ‚ÇÇ F‚ÇÅ‚ÇÇ G) r X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h ‚â´\n      (mapBifunctorComp‚ÇÅ‚ÇÇMapObjIso F‚ÇÅ‚ÇÇ G œÅ‚ÇÅ‚ÇÇ X‚ÇÅ X‚ÇÇ X‚ÇÉ).hom j =\n      ŒπMapBifunctor‚ÇÅ‚ÇÇBifunctorMapObj F‚ÇÅ‚ÇÇ G œÅ‚ÇÅ‚ÇÇ X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h := by\n  dsimp [mapBifunctorComp‚ÇÅ‚ÇÇMapObjIso]\n  apply CofanMapObjFun.ŒπMapObj_iso_inv\n\n"}
{"name":"CategoryTheory.GradedObject.Œπ_mapBifunctorComp‚ÇÅ‚ÇÇMapObjIso_hom","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\nC‚ÇÑ : Type u_4\nC‚ÇÅ‚ÇÇ : Type u_5\ninst‚úù‚Å∑ : CategoryTheory.Category.{u_14, u_1} C‚ÇÅ\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_13, u_2} C‚ÇÇ\ninst‚úù‚Åµ : CategoryTheory.Category.{u_12, u_3} C‚ÇÉ\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_11, u_4} C‚ÇÑ\ninst‚úù¬≥ : CategoryTheory.Category.{u_15, u_5} C‚ÇÅ‚ÇÇ\nF‚ÇÅ‚ÇÇ : CategoryTheory.Functor C‚ÇÅ (CategoryTheory.Functor C‚ÇÇ C‚ÇÅ‚ÇÇ)\nG : CategoryTheory.Functor C‚ÇÅ‚ÇÇ (CategoryTheory.Functor C‚ÇÉ C‚ÇÑ)\nI‚ÇÅ : Type u_7\nI‚ÇÇ : Type u_8\nI‚ÇÉ : Type u_9\nJ : Type u_10\nr : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ) ‚Üí J\nœÅ‚ÇÅ‚ÇÇ : CategoryTheory.GradedObject.BifunctorComp‚ÇÅ‚ÇÇIndexData r\nX‚ÇÅ : CategoryTheory.GradedObject I‚ÇÅ C‚ÇÅ\nX‚ÇÇ : CategoryTheory.GradedObject I‚ÇÇ C‚ÇÇ\nX‚ÇÉ : CategoryTheory.GradedObject I‚ÇÉ C‚ÇÉ\ninst‚úù¬≤ : (((CategoryTheory.GradedObject.mapBifunctor F‚ÇÅ‚ÇÇ I‚ÇÅ I‚ÇÇ).obj X‚ÇÅ).obj X‚ÇÇ).HasMap œÅ‚ÇÅ‚ÇÇ.p\ninst‚úù¬π : (((CategoryTheory.GradedObject.mapBifunctor G œÅ‚ÇÅ‚ÇÇ.I‚ÇÅ‚ÇÇ I‚ÇÉ).obj (CategoryTheory.GradedObject.mapBifunctorMapObj F‚ÇÅ‚ÇÇ œÅ‚ÇÅ‚ÇÇ.p X‚ÇÅ X‚ÇÇ)).obj X‚ÇÉ).HasMap œÅ‚ÇÅ‚ÇÇ.q\nH : CategoryTheory.GradedObject.HasGoodTrifunctor‚ÇÅ‚ÇÇObj F‚ÇÅ‚ÇÇ G œÅ‚ÇÅ‚ÇÇ X‚ÇÅ X‚ÇÇ X‚ÇÉ\ninst‚úù : ((((CategoryTheory.GradedObject.mapTrifunctor (CategoryTheory.bifunctorComp‚ÇÅ‚ÇÇ F‚ÇÅ‚ÇÇ G) I‚ÇÅ I‚ÇÇ I‚ÇÉ).obj X‚ÇÅ).obj X‚ÇÇ).obj X‚ÇÉ).HasMap r\ni‚ÇÅ : I‚ÇÅ\ni‚ÇÇ : I‚ÇÇ\ni‚ÇÉ : I‚ÇÉ\nj : J\nh : Eq (r { fst := i‚ÇÅ, snd := { fst := i‚ÇÇ, snd := i‚ÇÉ } }) j\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ŒπMapTrifunctorMapObj (CategoryTheory.bifunctorComp‚ÇÅ‚ÇÇ F‚ÇÅ‚ÇÇ G) r X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h) ((CategoryTheory.GradedObject.mapBifunctorComp‚ÇÅ‚ÇÇMapObjIso F‚ÇÅ‚ÇÇ G œÅ‚ÇÅ‚ÇÇ X‚ÇÅ X‚ÇÇ X‚ÇÉ).hom j)) (CategoryTheory.GradedObject.ŒπMapBifunctor‚ÇÅ‚ÇÇBifunctorMapObj F‚ÇÅ‚ÇÇ G œÅ‚ÇÅ‚ÇÇ X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h)","decl":"@[reassoc (attr := simp)]\nlemma Œπ_mapBifunctorComp‚ÇÅ‚ÇÇMapObjIso_hom (i‚ÇÅ : I‚ÇÅ) (i‚ÇÇ : I‚ÇÇ) (i‚ÇÉ : I‚ÇÉ) (j : J)\n    (h : r (i‚ÇÅ, i‚ÇÇ, i‚ÇÉ) = j) :\n    ŒπMapTrifunctorMapObj (bifunctorComp‚ÇÅ‚ÇÇ F‚ÇÅ‚ÇÇ G) r X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h ‚â´\n      (mapBifunctorComp‚ÇÅ‚ÇÇMapObjIso F‚ÇÅ‚ÇÇ G œÅ‚ÇÅ‚ÇÇ X‚ÇÅ X‚ÇÇ X‚ÇÉ).hom j =\n      ŒπMapBifunctor‚ÇÅ‚ÇÇBifunctorMapObj F‚ÇÅ‚ÇÇ G œÅ‚ÇÅ‚ÇÇ X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h := by\n  dsimp [mapBifunctorComp‚ÇÅ‚ÇÇMapObjIso]\n  apply CofanMapObjFun.ŒπMapObj_iso_inv\n\n"}
{"name":"CategoryTheory.GradedObject.Œπ_mapBifunctorComp‚ÇÅ‚ÇÇMapObjIso_inv","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\nC‚ÇÑ : Type u_4\nC‚ÇÅ‚ÇÇ : Type u_5\ninst‚úù‚Å∑ : CategoryTheory.Category.{u_15, u_1} C‚ÇÅ\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_14, u_2} C‚ÇÇ\ninst‚úù‚Åµ : CategoryTheory.Category.{u_12, u_3} C‚ÇÉ\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_11, u_4} C‚ÇÑ\ninst‚úù¬≥ : CategoryTheory.Category.{u_13, u_5} C‚ÇÅ‚ÇÇ\nF‚ÇÅ‚ÇÇ : CategoryTheory.Functor C‚ÇÅ (CategoryTheory.Functor C‚ÇÇ C‚ÇÅ‚ÇÇ)\nG : CategoryTheory.Functor C‚ÇÅ‚ÇÇ (CategoryTheory.Functor C‚ÇÉ C‚ÇÑ)\nI‚ÇÅ : Type u_7\nI‚ÇÇ : Type u_8\nI‚ÇÉ : Type u_9\nJ : Type u_10\nr : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ) ‚Üí J\nœÅ‚ÇÅ‚ÇÇ : CategoryTheory.GradedObject.BifunctorComp‚ÇÅ‚ÇÇIndexData r\nX‚ÇÅ : CategoryTheory.GradedObject I‚ÇÅ C‚ÇÅ\nX‚ÇÇ : CategoryTheory.GradedObject I‚ÇÇ C‚ÇÇ\nX‚ÇÉ : CategoryTheory.GradedObject I‚ÇÉ C‚ÇÉ\ninst‚úù¬≤ : (((CategoryTheory.GradedObject.mapBifunctor F‚ÇÅ‚ÇÇ I‚ÇÅ I‚ÇÇ).obj X‚ÇÅ).obj X‚ÇÇ).HasMap œÅ‚ÇÅ‚ÇÇ.p\ninst‚úù¬π : (((CategoryTheory.GradedObject.mapBifunctor G œÅ‚ÇÅ‚ÇÇ.I‚ÇÅ‚ÇÇ I‚ÇÉ).obj (CategoryTheory.GradedObject.mapBifunctorMapObj F‚ÇÅ‚ÇÇ œÅ‚ÇÅ‚ÇÇ.p X‚ÇÅ X‚ÇÇ)).obj X‚ÇÉ).HasMap œÅ‚ÇÅ‚ÇÇ.q\nH : CategoryTheory.GradedObject.HasGoodTrifunctor‚ÇÅ‚ÇÇObj F‚ÇÅ‚ÇÇ G œÅ‚ÇÅ‚ÇÇ X‚ÇÅ X‚ÇÇ X‚ÇÉ\ninst‚úù : ((((CategoryTheory.GradedObject.mapTrifunctor (CategoryTheory.bifunctorComp‚ÇÅ‚ÇÇ F‚ÇÅ‚ÇÇ G) I‚ÇÅ I‚ÇÇ I‚ÇÉ).obj X‚ÇÅ).obj X‚ÇÇ).obj X‚ÇÉ).HasMap r\ni‚ÇÅ : I‚ÇÅ\ni‚ÇÇ : I‚ÇÇ\ni‚ÇÉ : I‚ÇÉ\nj : J\nh : Eq (r { fst := i‚ÇÅ, snd := { fst := i‚ÇÇ, snd := i‚ÇÉ } }) j\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ŒπMapBifunctor‚ÇÅ‚ÇÇBifunctorMapObj F‚ÇÅ‚ÇÇ G œÅ‚ÇÅ‚ÇÇ X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h) ((CategoryTheory.GradedObject.mapBifunctorComp‚ÇÅ‚ÇÇMapObjIso F‚ÇÅ‚ÇÇ G œÅ‚ÇÅ‚ÇÇ X‚ÇÅ X‚ÇÇ X‚ÇÉ).inv j)) (CategoryTheory.GradedObject.ŒπMapTrifunctorMapObj (CategoryTheory.bifunctorComp‚ÇÅ‚ÇÇ F‚ÇÅ‚ÇÇ G) r X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h)","decl":"@[reassoc (attr := simp)]\nlemma Œπ_mapBifunctorComp‚ÇÅ‚ÇÇMapObjIso_inv (i‚ÇÅ : I‚ÇÅ) (i‚ÇÇ : I‚ÇÇ) (i‚ÇÉ : I‚ÇÉ) (j : J)\n    (h : r (i‚ÇÅ, i‚ÇÇ, i‚ÇÉ) = j) :\n    ŒπMapBifunctor‚ÇÅ‚ÇÇBifunctorMapObj F‚ÇÅ‚ÇÇ G œÅ‚ÇÅ‚ÇÇ X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h ‚â´\n      (mapBifunctorComp‚ÇÅ‚ÇÇMapObjIso F‚ÇÅ‚ÇÇ G œÅ‚ÇÅ‚ÇÇ X‚ÇÅ X‚ÇÇ X‚ÇÉ).inv j =\n      ŒπMapTrifunctorMapObj (bifunctorComp‚ÇÅ‚ÇÇ F‚ÇÅ‚ÇÇ G) r X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h :=\n  CofanMapObjFun.inj_iso_hom\n    (isColimitCofan‚ÇÉMapBifunctor‚ÇÅ‚ÇÇBifunctorMapObj F‚ÇÅ‚ÇÇ G œÅ‚ÇÅ‚ÇÇ X‚ÇÅ X‚ÇÇ X‚ÇÉ j) _ h\n\n"}
{"name":"CategoryTheory.GradedObject.Œπ_mapBifunctorComp‚ÇÅ‚ÇÇMapObjIso_inv_assoc","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\nC‚ÇÑ : Type u_4\nC‚ÇÅ‚ÇÇ : Type u_5\ninst‚úù‚Å∑ : CategoryTheory.Category.{u_15, u_1} C‚ÇÅ\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_14, u_2} C‚ÇÇ\ninst‚úù‚Åµ : CategoryTheory.Category.{u_12, u_3} C‚ÇÉ\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_11, u_4} C‚ÇÑ\ninst‚úù¬≥ : CategoryTheory.Category.{u_13, u_5} C‚ÇÅ‚ÇÇ\nF‚ÇÅ‚ÇÇ : CategoryTheory.Functor C‚ÇÅ (CategoryTheory.Functor C‚ÇÇ C‚ÇÅ‚ÇÇ)\nG : CategoryTheory.Functor C‚ÇÅ‚ÇÇ (CategoryTheory.Functor C‚ÇÉ C‚ÇÑ)\nI‚ÇÅ : Type u_7\nI‚ÇÇ : Type u_8\nI‚ÇÉ : Type u_9\nJ : Type u_10\nr : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ) ‚Üí J\nœÅ‚ÇÅ‚ÇÇ : CategoryTheory.GradedObject.BifunctorComp‚ÇÅ‚ÇÇIndexData r\nX‚ÇÅ : CategoryTheory.GradedObject I‚ÇÅ C‚ÇÅ\nX‚ÇÇ : CategoryTheory.GradedObject I‚ÇÇ C‚ÇÇ\nX‚ÇÉ : CategoryTheory.GradedObject I‚ÇÉ C‚ÇÉ\ninst‚úù¬≤ : (((CategoryTheory.GradedObject.mapBifunctor F‚ÇÅ‚ÇÇ I‚ÇÅ I‚ÇÇ).obj X‚ÇÅ).obj X‚ÇÇ).HasMap œÅ‚ÇÅ‚ÇÇ.p\ninst‚úù¬π : (((CategoryTheory.GradedObject.mapBifunctor G œÅ‚ÇÅ‚ÇÇ.I‚ÇÅ‚ÇÇ I‚ÇÉ).obj (CategoryTheory.GradedObject.mapBifunctorMapObj F‚ÇÅ‚ÇÇ œÅ‚ÇÅ‚ÇÇ.p X‚ÇÅ X‚ÇÇ)).obj X‚ÇÉ).HasMap œÅ‚ÇÅ‚ÇÇ.q\nH : CategoryTheory.GradedObject.HasGoodTrifunctor‚ÇÅ‚ÇÇObj F‚ÇÅ‚ÇÇ G œÅ‚ÇÅ‚ÇÇ X‚ÇÅ X‚ÇÇ X‚ÇÉ\ninst‚úù : ((((CategoryTheory.GradedObject.mapTrifunctor (CategoryTheory.bifunctorComp‚ÇÅ‚ÇÇ F‚ÇÅ‚ÇÇ G) I‚ÇÅ I‚ÇÇ I‚ÇÉ).obj X‚ÇÅ).obj X‚ÇÇ).obj X‚ÇÉ).HasMap r\ni‚ÇÅ : I‚ÇÅ\ni‚ÇÇ : I‚ÇÇ\ni‚ÇÉ : I‚ÇÉ\nj : J\nh‚úù : Eq (r { fst := i‚ÇÅ, snd := { fst := i‚ÇÇ, snd := i‚ÇÉ } }) j\nZ : C‚ÇÑ\nh : Quiver.Hom (CategoryTheory.GradedObject.mapTrifunctorMapObj (CategoryTheory.bifunctorComp‚ÇÅ‚ÇÇ F‚ÇÅ‚ÇÇ G) r X‚ÇÅ X‚ÇÇ X‚ÇÉ j) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ŒπMapBifunctor‚ÇÅ‚ÇÇBifunctorMapObj F‚ÇÅ‚ÇÇ G œÅ‚ÇÅ‚ÇÇ X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h‚úù) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.GradedObject.mapBifunctorComp‚ÇÅ‚ÇÇMapObjIso F‚ÇÅ‚ÇÇ G œÅ‚ÇÅ‚ÇÇ X‚ÇÅ X‚ÇÇ X‚ÇÉ).inv j) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ŒπMapTrifunctorMapObj (CategoryTheory.bifunctorComp‚ÇÅ‚ÇÇ F‚ÇÅ‚ÇÇ G) r X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h‚úù) h)","decl":"@[reassoc (attr := simp)]\nlemma Œπ_mapBifunctorComp‚ÇÅ‚ÇÇMapObjIso_inv (i‚ÇÅ : I‚ÇÅ) (i‚ÇÇ : I‚ÇÇ) (i‚ÇÉ : I‚ÇÉ) (j : J)\n    (h : r (i‚ÇÅ, i‚ÇÇ, i‚ÇÉ) = j) :\n    ŒπMapBifunctor‚ÇÅ‚ÇÇBifunctorMapObj F‚ÇÅ‚ÇÇ G œÅ‚ÇÅ‚ÇÇ X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h ‚â´\n      (mapBifunctorComp‚ÇÅ‚ÇÇMapObjIso F‚ÇÅ‚ÇÇ G œÅ‚ÇÅ‚ÇÇ X‚ÇÅ X‚ÇÇ X‚ÇÉ).inv j =\n      ŒπMapTrifunctorMapObj (bifunctorComp‚ÇÅ‚ÇÇ F‚ÇÅ‚ÇÇ G) r X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h :=\n  CofanMapObjFun.inj_iso_hom\n    (isColimitCofan‚ÇÉMapBifunctor‚ÇÅ‚ÇÇBifunctorMapObj F‚ÇÅ‚ÇÇ G œÅ‚ÇÅ‚ÇÇ X‚ÇÅ X‚ÇÇ X‚ÇÉ j) _ h\n\n"}
{"name":"CategoryTheory.GradedObject.mapBifunctor‚ÇÅ‚ÇÇBifunctorMapObj_ext","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\nC‚ÇÑ : Type u_4\nC‚ÇÅ‚ÇÇ : Type u_5\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_15, u_1} C‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{u_16, u_2} C‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_14, u_3} C‚ÇÉ\ninst‚úù¬≥ : CategoryTheory.Category.{u_11, u_4} C‚ÇÑ\ninst‚úù¬≤ : CategoryTheory.Category.{u_13, u_5} C‚ÇÅ‚ÇÇ\nF‚ÇÅ‚ÇÇ : CategoryTheory.Functor C‚ÇÅ (CategoryTheory.Functor C‚ÇÇ C‚ÇÅ‚ÇÇ)\nG : CategoryTheory.Functor C‚ÇÅ‚ÇÇ (CategoryTheory.Functor C‚ÇÉ C‚ÇÑ)\nI‚ÇÅ : Type u_7\nI‚ÇÇ : Type u_8\nI‚ÇÉ : Type u_9\nJ : Type u_10\nr : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ) ‚Üí J\nœÅ‚ÇÅ‚ÇÇ : CategoryTheory.GradedObject.BifunctorComp‚ÇÅ‚ÇÇIndexData r\nX‚ÇÅ : CategoryTheory.GradedObject I‚ÇÅ C‚ÇÅ\nX‚ÇÇ : CategoryTheory.GradedObject I‚ÇÇ C‚ÇÇ\nX‚ÇÉ : CategoryTheory.GradedObject I‚ÇÉ C‚ÇÉ\ninst‚úù¬π : (((CategoryTheory.GradedObject.mapBifunctor F‚ÇÅ‚ÇÇ I‚ÇÅ I‚ÇÇ).obj X‚ÇÅ).obj X‚ÇÇ).HasMap œÅ‚ÇÅ‚ÇÇ.p\ninst‚úù : (((CategoryTheory.GradedObject.mapBifunctor G œÅ‚ÇÅ‚ÇÇ.I‚ÇÅ‚ÇÇ I‚ÇÉ).obj (CategoryTheory.GradedObject.mapBifunctorMapObj F‚ÇÅ‚ÇÇ œÅ‚ÇÅ‚ÇÇ.p X‚ÇÅ X‚ÇÇ)).obj X‚ÇÉ).HasMap œÅ‚ÇÅ‚ÇÇ.q\nH : CategoryTheory.GradedObject.HasGoodTrifunctor‚ÇÅ‚ÇÇObj F‚ÇÅ‚ÇÇ G œÅ‚ÇÅ‚ÇÇ X‚ÇÅ X‚ÇÇ X‚ÇÉ\nj : J\nA : C‚ÇÑ\nf g : Quiver.Hom (CategoryTheory.GradedObject.mapBifunctorMapObj G œÅ‚ÇÅ‚ÇÇ.q (CategoryTheory.GradedObject.mapBifunctorMapObj F‚ÇÅ‚ÇÇ œÅ‚ÇÅ‚ÇÇ.p X‚ÇÅ X‚ÇÇ) X‚ÇÉ j) A\nh : ‚àÄ (i‚ÇÅ : I‚ÇÅ) (i‚ÇÇ : I‚ÇÇ) (i‚ÇÉ : I‚ÇÉ) (h : Eq (r { fst := i‚ÇÅ, snd := { fst := i‚ÇÇ, snd := i‚ÇÉ } }) j), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ŒπMapBifunctor‚ÇÅ‚ÇÇBifunctorMapObj F‚ÇÅ‚ÇÇ G œÅ‚ÇÅ‚ÇÇ X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h) f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ŒπMapBifunctor‚ÇÅ‚ÇÇBifunctorMapObj F‚ÇÅ‚ÇÇ G œÅ‚ÇÅ‚ÇÇ X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h) g)\n‚ä¢ Eq f g","decl":"@[ext]\nlemma mapBifunctor‚ÇÅ‚ÇÇBifunctorMapObj_ext {A : C‚ÇÑ}\n    {f g : mapBifunctorMapObj G œÅ‚ÇÅ‚ÇÇ.q (mapBifunctorMapObj F‚ÇÅ‚ÇÇ œÅ‚ÇÅ‚ÇÇ.p X‚ÇÅ X‚ÇÇ) X‚ÇÉ j ‚ü∂ A}\n    (h : ‚àÄ (i‚ÇÅ : I‚ÇÅ) (i‚ÇÇ : I‚ÇÇ) (i‚ÇÉ : I‚ÇÉ) (h : r ‚ü®i‚ÇÅ, i‚ÇÇ, i‚ÇÉ‚ü© = j),\n      ŒπMapBifunctor‚ÇÅ‚ÇÇBifunctorMapObj F‚ÇÅ‚ÇÇ G œÅ‚ÇÅ‚ÇÇ X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h ‚â´ f =\n        ŒπMapBifunctor‚ÇÅ‚ÇÇBifunctorMapObj F‚ÇÅ‚ÇÇ G œÅ‚ÇÅ‚ÇÇ X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h ‚â´ g) : f = g := by\n  apply Cofan.IsColimit.hom_ext (isColimitCofan‚ÇÉMapBifunctor‚ÇÅ‚ÇÇBifunctorMapObj F‚ÇÅ‚ÇÇ G œÅ‚ÇÅ‚ÇÇ X‚ÇÅ X‚ÇÇ X‚ÇÉ j)\n  rintro ‚ü®i, hi‚ü©\n  exact h _ _ _ hi\n\n"}
{"name":"CategoryTheory.GradedObject.mapBifunctor‚ÇÅ‚ÇÇBifunctorMapObj_ext_iff","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\nC‚ÇÑ : Type u_4\nC‚ÇÅ‚ÇÇ : Type u_5\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_15, u_1} C‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{u_16, u_2} C‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_14, u_3} C‚ÇÉ\ninst‚úù¬≥ : CategoryTheory.Category.{u_11, u_4} C‚ÇÑ\ninst‚úù¬≤ : CategoryTheory.Category.{u_13, u_5} C‚ÇÅ‚ÇÇ\nF‚ÇÅ‚ÇÇ : CategoryTheory.Functor C‚ÇÅ (CategoryTheory.Functor C‚ÇÇ C‚ÇÅ‚ÇÇ)\nG : CategoryTheory.Functor C‚ÇÅ‚ÇÇ (CategoryTheory.Functor C‚ÇÉ C‚ÇÑ)\nI‚ÇÅ : Type u_7\nI‚ÇÇ : Type u_8\nI‚ÇÉ : Type u_9\nJ : Type u_10\nr : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ) ‚Üí J\nœÅ‚ÇÅ‚ÇÇ : CategoryTheory.GradedObject.BifunctorComp‚ÇÅ‚ÇÇIndexData r\nX‚ÇÅ : CategoryTheory.GradedObject I‚ÇÅ C‚ÇÅ\nX‚ÇÇ : CategoryTheory.GradedObject I‚ÇÇ C‚ÇÇ\nX‚ÇÉ : CategoryTheory.GradedObject I‚ÇÉ C‚ÇÉ\ninst‚úù¬π : (((CategoryTheory.GradedObject.mapBifunctor F‚ÇÅ‚ÇÇ I‚ÇÅ I‚ÇÇ).obj X‚ÇÅ).obj X‚ÇÇ).HasMap œÅ‚ÇÅ‚ÇÇ.p\ninst‚úù : (((CategoryTheory.GradedObject.mapBifunctor G œÅ‚ÇÅ‚ÇÇ.I‚ÇÅ‚ÇÇ I‚ÇÉ).obj (CategoryTheory.GradedObject.mapBifunctorMapObj F‚ÇÅ‚ÇÇ œÅ‚ÇÅ‚ÇÇ.p X‚ÇÅ X‚ÇÇ)).obj X‚ÇÉ).HasMap œÅ‚ÇÅ‚ÇÇ.q\nH : CategoryTheory.GradedObject.HasGoodTrifunctor‚ÇÅ‚ÇÇObj F‚ÇÅ‚ÇÇ G œÅ‚ÇÅ‚ÇÇ X‚ÇÅ X‚ÇÇ X‚ÇÉ\nj : J\nA : C‚ÇÑ\nf g : Quiver.Hom (CategoryTheory.GradedObject.mapBifunctorMapObj G œÅ‚ÇÅ‚ÇÇ.q (CategoryTheory.GradedObject.mapBifunctorMapObj F‚ÇÅ‚ÇÇ œÅ‚ÇÅ‚ÇÇ.p X‚ÇÅ X‚ÇÇ) X‚ÇÉ j) A\n‚ä¢ Iff (Eq f g) (‚àÄ (i‚ÇÅ : I‚ÇÅ) (i‚ÇÇ : I‚ÇÇ) (i‚ÇÉ : I‚ÇÉ) (h : Eq (r { fst := i‚ÇÅ, snd := { fst := i‚ÇÇ, snd := i‚ÇÉ } }) j), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ŒπMapBifunctor‚ÇÅ‚ÇÇBifunctorMapObj F‚ÇÅ‚ÇÇ G œÅ‚ÇÅ‚ÇÇ X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h) f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ŒπMapBifunctor‚ÇÅ‚ÇÇBifunctorMapObj F‚ÇÅ‚ÇÇ G œÅ‚ÇÅ‚ÇÇ X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h) g))","decl":"@[ext]\nlemma mapBifunctor‚ÇÅ‚ÇÇBifunctorMapObj_ext {A : C‚ÇÑ}\n    {f g : mapBifunctorMapObj G œÅ‚ÇÅ‚ÇÇ.q (mapBifunctorMapObj F‚ÇÅ‚ÇÇ œÅ‚ÇÅ‚ÇÇ.p X‚ÇÅ X‚ÇÇ) X‚ÇÉ j ‚ü∂ A}\n    (h : ‚àÄ (i‚ÇÅ : I‚ÇÅ) (i‚ÇÇ : I‚ÇÇ) (i‚ÇÉ : I‚ÇÉ) (h : r ‚ü®i‚ÇÅ, i‚ÇÇ, i‚ÇÉ‚ü© = j),\n      ŒπMapBifunctor‚ÇÅ‚ÇÇBifunctorMapObj F‚ÇÅ‚ÇÇ G œÅ‚ÇÅ‚ÇÇ X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h ‚â´ f =\n        ŒπMapBifunctor‚ÇÅ‚ÇÇBifunctorMapObj F‚ÇÅ‚ÇÇ G œÅ‚ÇÅ‚ÇÇ X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h ‚â´ g) : f = g := by\n  apply Cofan.IsColimit.hom_ext (isColimitCofan‚ÇÉMapBifunctor‚ÇÅ‚ÇÇBifunctorMapObj F‚ÇÅ‚ÇÇ G œÅ‚ÇÅ‚ÇÇ X‚ÇÅ X‚ÇÇ X‚ÇÉ j)\n  rintro ‚ü®i, hi‚ü©\n  exact h _ _ _ hi\n\n"}
{"name":"CategoryTheory.GradedObject.Œπ_mapBifunctor‚ÇÅ‚ÇÇBifunctorDesc_assoc","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\nC‚ÇÑ : Type u_4\nC‚ÇÅ‚ÇÇ : Type u_5\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_15, u_1} C‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{u_14, u_2} C‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_12, u_3} C‚ÇÉ\ninst‚úù¬≥ : CategoryTheory.Category.{u_11, u_4} C‚ÇÑ\ninst‚úù¬≤ : CategoryTheory.Category.{u_13, u_5} C‚ÇÅ‚ÇÇ\nF‚ÇÅ‚ÇÇ : CategoryTheory.Functor C‚ÇÅ (CategoryTheory.Functor C‚ÇÇ C‚ÇÅ‚ÇÇ)\nG : CategoryTheory.Functor C‚ÇÅ‚ÇÇ (CategoryTheory.Functor C‚ÇÉ C‚ÇÑ)\nI‚ÇÅ : Type u_7\nI‚ÇÇ : Type u_8\nI‚ÇÉ : Type u_9\nJ : Type u_10\nr : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ) ‚Üí J\nœÅ‚ÇÅ‚ÇÇ : CategoryTheory.GradedObject.BifunctorComp‚ÇÅ‚ÇÇIndexData r\nX‚ÇÅ : CategoryTheory.GradedObject I‚ÇÅ C‚ÇÅ\nX‚ÇÇ : CategoryTheory.GradedObject I‚ÇÇ C‚ÇÇ\nX‚ÇÉ : CategoryTheory.GradedObject I‚ÇÉ C‚ÇÉ\ninst‚úù¬π : (((CategoryTheory.GradedObject.mapBifunctor F‚ÇÅ‚ÇÇ I‚ÇÅ I‚ÇÇ).obj X‚ÇÅ).obj X‚ÇÇ).HasMap œÅ‚ÇÅ‚ÇÇ.p\ninst‚úù : (((CategoryTheory.GradedObject.mapBifunctor G œÅ‚ÇÅ‚ÇÇ.I‚ÇÅ‚ÇÇ I‚ÇÉ).obj (CategoryTheory.GradedObject.mapBifunctorMapObj F‚ÇÅ‚ÇÇ œÅ‚ÇÅ‚ÇÇ.p X‚ÇÅ X‚ÇÇ)).obj X‚ÇÉ).HasMap œÅ‚ÇÅ‚ÇÇ.q\nH : CategoryTheory.GradedObject.HasGoodTrifunctor‚ÇÅ‚ÇÇObj F‚ÇÅ‚ÇÇ G œÅ‚ÇÅ‚ÇÇ X‚ÇÅ X‚ÇÇ X‚ÇÉ\nj : J\nA : C‚ÇÑ\nf : (i‚ÇÅ : I‚ÇÅ) ‚Üí (i‚ÇÇ : I‚ÇÇ) ‚Üí (i‚ÇÉ : I‚ÇÉ) ‚Üí Eq (r { fst := i‚ÇÅ, snd := { fst := i‚ÇÇ, snd := i‚ÇÉ } }) j ‚Üí Quiver.Hom ((G.obj ((F‚ÇÅ‚ÇÇ.obj (X‚ÇÅ i‚ÇÅ)).obj (X‚ÇÇ i‚ÇÇ))).obj (X‚ÇÉ i‚ÇÉ)) A\ni‚ÇÅ : I‚ÇÅ\ni‚ÇÇ : I‚ÇÇ\ni‚ÇÉ : I‚ÇÉ\nh‚úù : Eq (r { fst := i‚ÇÅ, snd := { fst := i‚ÇÇ, snd := i‚ÇÉ } }) j\nZ : C‚ÇÑ\nh : Quiver.Hom A Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ŒπMapBifunctor‚ÇÅ‚ÇÇBifunctorMapObj F‚ÇÅ‚ÇÇ G œÅ‚ÇÅ‚ÇÇ X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h‚úù) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.mapBifunctor‚ÇÅ‚ÇÇBifunctorDesc f) h)) (CategoryTheory.CategoryStruct.comp (f i‚ÇÅ i‚ÇÇ i‚ÇÉ h‚úù) h)","decl":"@[reassoc (attr := simp)]\nlemma Œπ_mapBifunctor‚ÇÅ‚ÇÇBifunctorDesc\n    (i‚ÇÅ : I‚ÇÅ) (i‚ÇÇ : I‚ÇÇ) (i‚ÇÉ : I‚ÇÉ) (h : r ‚ü®i‚ÇÅ, i‚ÇÇ, i‚ÇÉ‚ü© = j) :\n    ŒπMapBifunctor‚ÇÅ‚ÇÇBifunctorMapObj F‚ÇÅ‚ÇÇ G œÅ‚ÇÅ‚ÇÇ X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h ‚â´\n      mapBifunctor‚ÇÅ‚ÇÇBifunctorDesc f = f i‚ÇÅ i‚ÇÇ i‚ÇÉ h :=\n  Cofan.IsColimit.fac\n    (isColimitCofan‚ÇÉMapBifunctor‚ÇÅ‚ÇÇBifunctorMapObj F‚ÇÅ‚ÇÇ G œÅ‚ÇÅ‚ÇÇ X‚ÇÅ X‚ÇÇ X‚ÇÉ j) _ ‚ü®_, h‚ü©\n\n"}
{"name":"CategoryTheory.GradedObject.Œπ_mapBifunctor‚ÇÅ‚ÇÇBifunctorDesc","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\nC‚ÇÑ : Type u_4\nC‚ÇÅ‚ÇÇ : Type u_5\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_15, u_1} C‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{u_14, u_2} C‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_12, u_3} C‚ÇÉ\ninst‚úù¬≥ : CategoryTheory.Category.{u_11, u_4} C‚ÇÑ\ninst‚úù¬≤ : CategoryTheory.Category.{u_13, u_5} C‚ÇÅ‚ÇÇ\nF‚ÇÅ‚ÇÇ : CategoryTheory.Functor C‚ÇÅ (CategoryTheory.Functor C‚ÇÇ C‚ÇÅ‚ÇÇ)\nG : CategoryTheory.Functor C‚ÇÅ‚ÇÇ (CategoryTheory.Functor C‚ÇÉ C‚ÇÑ)\nI‚ÇÅ : Type u_7\nI‚ÇÇ : Type u_8\nI‚ÇÉ : Type u_9\nJ : Type u_10\nr : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ) ‚Üí J\nœÅ‚ÇÅ‚ÇÇ : CategoryTheory.GradedObject.BifunctorComp‚ÇÅ‚ÇÇIndexData r\nX‚ÇÅ : CategoryTheory.GradedObject I‚ÇÅ C‚ÇÅ\nX‚ÇÇ : CategoryTheory.GradedObject I‚ÇÇ C‚ÇÇ\nX‚ÇÉ : CategoryTheory.GradedObject I‚ÇÉ C‚ÇÉ\ninst‚úù¬π : (((CategoryTheory.GradedObject.mapBifunctor F‚ÇÅ‚ÇÇ I‚ÇÅ I‚ÇÇ).obj X‚ÇÅ).obj X‚ÇÇ).HasMap œÅ‚ÇÅ‚ÇÇ.p\ninst‚úù : (((CategoryTheory.GradedObject.mapBifunctor G œÅ‚ÇÅ‚ÇÇ.I‚ÇÅ‚ÇÇ I‚ÇÉ).obj (CategoryTheory.GradedObject.mapBifunctorMapObj F‚ÇÅ‚ÇÇ œÅ‚ÇÅ‚ÇÇ.p X‚ÇÅ X‚ÇÇ)).obj X‚ÇÉ).HasMap œÅ‚ÇÅ‚ÇÇ.q\nH : CategoryTheory.GradedObject.HasGoodTrifunctor‚ÇÅ‚ÇÇObj F‚ÇÅ‚ÇÇ G œÅ‚ÇÅ‚ÇÇ X‚ÇÅ X‚ÇÇ X‚ÇÉ\nj : J\nA : C‚ÇÑ\nf : (i‚ÇÅ : I‚ÇÅ) ‚Üí (i‚ÇÇ : I‚ÇÇ) ‚Üí (i‚ÇÉ : I‚ÇÉ) ‚Üí Eq (r { fst := i‚ÇÅ, snd := { fst := i‚ÇÇ, snd := i‚ÇÉ } }) j ‚Üí Quiver.Hom ((G.obj ((F‚ÇÅ‚ÇÇ.obj (X‚ÇÅ i‚ÇÅ)).obj (X‚ÇÇ i‚ÇÇ))).obj (X‚ÇÉ i‚ÇÉ)) A\ni‚ÇÅ : I‚ÇÅ\ni‚ÇÇ : I‚ÇÇ\ni‚ÇÉ : I‚ÇÉ\nh : Eq (r { fst := i‚ÇÅ, snd := { fst := i‚ÇÇ, snd := i‚ÇÉ } }) j\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ŒπMapBifunctor‚ÇÅ‚ÇÇBifunctorMapObj F‚ÇÅ‚ÇÇ G œÅ‚ÇÅ‚ÇÇ X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h) (CategoryTheory.GradedObject.mapBifunctor‚ÇÅ‚ÇÇBifunctorDesc f)) (f i‚ÇÅ i‚ÇÇ i‚ÇÉ h)","decl":"@[reassoc (attr := simp)]\nlemma Œπ_mapBifunctor‚ÇÅ‚ÇÇBifunctorDesc\n    (i‚ÇÅ : I‚ÇÅ) (i‚ÇÇ : I‚ÇÇ) (i‚ÇÉ : I‚ÇÉ) (h : r ‚ü®i‚ÇÅ, i‚ÇÇ, i‚ÇÉ‚ü© = j) :\n    ŒπMapBifunctor‚ÇÅ‚ÇÇBifunctorMapObj F‚ÇÅ‚ÇÇ G œÅ‚ÇÅ‚ÇÇ X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h ‚â´\n      mapBifunctor‚ÇÅ‚ÇÇBifunctorDesc f = f i‚ÇÅ i‚ÇÇ i‚ÇÉ h :=\n  Cofan.IsColimit.fac\n    (isColimitCofan‚ÇÉMapBifunctor‚ÇÅ‚ÇÇBifunctorMapObj F‚ÇÅ‚ÇÇ G œÅ‚ÇÅ‚ÇÇ X‚ÇÅ X‚ÇÇ X‚ÇÉ j) _ ‚ü®_, h‚ü©\n\n"}
{"name":"CategoryTheory.GradedObject.BifunctorComp‚ÇÇ‚ÇÉIndexData.mk.inj","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"I‚ÇÅ : Type u_7\nI‚ÇÇ : Type u_8\nI‚ÇÉ : Type u_9\nJ : Type u_10\nr : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ) ‚Üí J\nI‚ÇÇ‚ÇÉ‚úù : Type u_11\np‚úù : Prod I‚ÇÇ I‚ÇÉ ‚Üí I‚ÇÇ‚ÇÉ‚úù\nq‚úù : Prod I‚ÇÅ I‚ÇÇ‚ÇÉ‚úù ‚Üí J\nhpq‚úù : ‚àÄ (i : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ)), Eq (q‚úù { fst := i.1, snd := p‚úù i.2 }) (r i)\nI‚ÇÇ‚ÇÉ : Type u_11\np : Prod I‚ÇÇ I‚ÇÉ ‚Üí I‚ÇÇ‚ÇÉ\nq : Prod I‚ÇÅ I‚ÇÇ‚ÇÉ ‚Üí J\nhpq : ‚àÄ (i : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ)), Eq (q { fst := i.1, snd := p i.2 }) (r i)\nx‚úù : Eq { I‚ÇÇ‚ÇÉ := I‚ÇÇ‚ÇÉ‚úù, p := p‚úù, q := q‚úù, hpq := hpq‚úù } { I‚ÇÇ‚ÇÉ := I‚ÇÇ‚ÇÉ, p := p, q := q, hpq := hpq }\n‚ä¢ And (Eq I‚ÇÇ‚ÇÉ‚úù I‚ÇÇ‚ÇÉ) (And (HEq p‚úù p) (HEq q‚úù q))","decl":"/-- Given a map `r : I‚ÇÅ √ó I‚ÇÇ √ó I‚ÇÉ ‚Üí J`, a `BifunctorComp‚ÇÇ‚ÇÉIndexData r` consists of the data\nof a type `I‚ÇÇ‚ÇÉ`, maps `p : I‚ÇÇ √ó I‚ÇÉ ‚Üí I‚ÇÇ‚ÇÉ` and `q : I‚ÇÅ √ó I‚ÇÇ‚ÇÉ ‚Üí J`, such that `r` is obtained\nby composition of `p` and `q`. -/\nstructure BifunctorComp‚ÇÇ‚ÇÉIndexData where\n  /-- an auxiliary type -/\n  I‚ÇÇ‚ÇÉ : Type*\n  /-- a map `I‚ÇÇ √ó I‚ÇÉ ‚Üí I‚ÇÇ‚ÇÉ` -/\n  p : I‚ÇÇ √ó I‚ÇÉ ‚Üí I‚ÇÇ‚ÇÉ\n  /-- a map `I‚ÇÅ √ó I‚ÇÇ‚ÇÉ ‚Üí J` -/\n  q : I‚ÇÅ √ó I‚ÇÇ‚ÇÉ ‚Üí J\n  hpq (i : I‚ÇÅ √ó I‚ÇÇ √ó I‚ÇÉ) : q ‚ü®i.1, p i.2‚ü© = r i\n\n"}
{"name":"CategoryTheory.GradedObject.BifunctorComp‚ÇÇ‚ÇÉIndexData.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"I‚ÇÅ : Type u_7\nI‚ÇÇ : Type u_8\nI‚ÇÉ : Type u_9\nJ : Type u_10\nr : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ) ‚Üí J\ninst‚úù¬≥ : SizeOf I‚ÇÅ\ninst‚úù¬≤ : SizeOf I‚ÇÇ\ninst‚úù¬π : SizeOf I‚ÇÉ\ninst‚úù : SizeOf J\nI‚ÇÇ‚ÇÉ : Type u_11\np : Prod I‚ÇÇ I‚ÇÉ ‚Üí I‚ÇÇ‚ÇÉ\nq : Prod I‚ÇÅ I‚ÇÇ‚ÇÉ ‚Üí J\nhpq : ‚àÄ (i : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ)), Eq (q { fst := i.1, snd := p i.2 }) (r i)\n‚ä¢ Eq (SizeOf.sizeOf { I‚ÇÇ‚ÇÉ := I‚ÇÇ‚ÇÉ, p := p, q := q, hpq := hpq }) (HAdd.hAdd 1 (SizeOf.sizeOf I‚ÇÇ‚ÇÉ))","decl":"/-- Given a map `r : I‚ÇÅ √ó I‚ÇÇ √ó I‚ÇÉ ‚Üí J`, a `BifunctorComp‚ÇÇ‚ÇÉIndexData r` consists of the data\nof a type `I‚ÇÇ‚ÇÉ`, maps `p : I‚ÇÇ √ó I‚ÇÉ ‚Üí I‚ÇÇ‚ÇÉ` and `q : I‚ÇÅ √ó I‚ÇÇ‚ÇÉ ‚Üí J`, such that `r` is obtained\nby composition of `p` and `q`. -/\nstructure BifunctorComp‚ÇÇ‚ÇÉIndexData where\n  /-- an auxiliary type -/\n  I‚ÇÇ‚ÇÉ : Type*\n  /-- a map `I‚ÇÇ √ó I‚ÇÉ ‚Üí I‚ÇÇ‚ÇÉ` -/\n  p : I‚ÇÇ √ó I‚ÇÉ ‚Üí I‚ÇÇ‚ÇÉ\n  /-- a map `I‚ÇÅ √ó I‚ÇÇ‚ÇÉ ‚Üí J` -/\n  q : I‚ÇÅ √ó I‚ÇÇ‚ÇÉ ‚Üí J\n  hpq (i : I‚ÇÅ √ó I‚ÇÇ √ó I‚ÇÉ) : q ‚ü®i.1, p i.2‚ü© = r i\n\n"}
{"name":"CategoryTheory.GradedObject.BifunctorComp‚ÇÇ‚ÇÉIndexData.mk.injEq","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"I‚ÇÅ : Type u_7\nI‚ÇÇ : Type u_8\nI‚ÇÉ : Type u_9\nJ : Type u_10\nr : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ) ‚Üí J\nI‚ÇÇ‚ÇÉ‚úù : Type u_11\np‚úù : Prod I‚ÇÇ I‚ÇÉ ‚Üí I‚ÇÇ‚ÇÉ‚úù\nq‚úù : Prod I‚ÇÅ I‚ÇÇ‚ÇÉ‚úù ‚Üí J\nhpq‚úù : ‚àÄ (i : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ)), Eq (q‚úù { fst := i.1, snd := p‚úù i.2 }) (r i)\nI‚ÇÇ‚ÇÉ : Type u_11\np : Prod I‚ÇÇ I‚ÇÉ ‚Üí I‚ÇÇ‚ÇÉ\nq : Prod I‚ÇÅ I‚ÇÇ‚ÇÉ ‚Üí J\nhpq : ‚àÄ (i : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ)), Eq (q { fst := i.1, snd := p i.2 }) (r i)\n‚ä¢ Eq (Eq { I‚ÇÇ‚ÇÉ := I‚ÇÇ‚ÇÉ‚úù, p := p‚úù, q := q‚úù, hpq := hpq‚úù } { I‚ÇÇ‚ÇÉ := I‚ÇÇ‚ÇÉ, p := p, q := q, hpq := hpq }) (And (Eq I‚ÇÇ‚ÇÉ‚úù I‚ÇÇ‚ÇÉ) (And (HEq p‚úù p) (HEq q‚úù q)))","decl":"/-- Given a map `r : I‚ÇÅ √ó I‚ÇÇ √ó I‚ÇÉ ‚Üí J`, a `BifunctorComp‚ÇÇ‚ÇÉIndexData r` consists of the data\nof a type `I‚ÇÇ‚ÇÉ`, maps `p : I‚ÇÇ √ó I‚ÇÉ ‚Üí I‚ÇÇ‚ÇÉ` and `q : I‚ÇÅ √ó I‚ÇÇ‚ÇÉ ‚Üí J`, such that `r` is obtained\nby composition of `p` and `q`. -/\nstructure BifunctorComp‚ÇÇ‚ÇÉIndexData where\n  /-- an auxiliary type -/\n  I‚ÇÇ‚ÇÉ : Type*\n  /-- a map `I‚ÇÇ √ó I‚ÇÉ ‚Üí I‚ÇÇ‚ÇÉ` -/\n  p : I‚ÇÇ √ó I‚ÇÉ ‚Üí I‚ÇÇ‚ÇÉ\n  /-- a map `I‚ÇÅ √ó I‚ÇÇ‚ÇÉ ‚Üí J` -/\n  q : I‚ÇÅ √ó I‚ÇÇ‚ÇÉ ‚Üí J\n  hpq (i : I‚ÇÅ √ó I‚ÇÇ √ó I‚ÇÉ) : q ‚ü®i.1, p i.2‚ü© = r i\n\n"}
{"name":"CategoryTheory.GradedObject.BifunctorComp‚ÇÇ‚ÇÉIndexData.hpq","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"I‚ÇÅ : Type u_7\nI‚ÇÇ : Type u_8\nI‚ÇÉ : Type u_9\nJ : Type u_10\nr : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ) ‚Üí J\nself : CategoryTheory.GradedObject.BifunctorComp‚ÇÇ‚ÇÉIndexData r\ni : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ)\n‚ä¢ Eq (self.q { fst := i.1, snd := self.p i.2 }) (r i)","decl":"/-- Given a map `r : I‚ÇÅ √ó I‚ÇÇ √ó I‚ÇÉ ‚Üí J`, a `BifunctorComp‚ÇÇ‚ÇÉIndexData r` consists of the data\nof a type `I‚ÇÇ‚ÇÉ`, maps `p : I‚ÇÇ √ó I‚ÇÉ ‚Üí I‚ÇÇ‚ÇÉ` and `q : I‚ÇÅ √ó I‚ÇÇ‚ÇÉ ‚Üí J`, such that `r` is obtained\nby composition of `p` and `q`. -/\nstructure BifunctorComp‚ÇÇ‚ÇÉIndexData where\n  /-- an auxiliary type -/\n  I‚ÇÇ‚ÇÉ : Type*\n  /-- a map `I‚ÇÇ √ó I‚ÇÉ ‚Üí I‚ÇÇ‚ÇÉ` -/\n  p : I‚ÇÇ √ó I‚ÇÉ ‚Üí I‚ÇÇ‚ÇÉ\n  /-- a map `I‚ÇÅ √ó I‚ÇÇ‚ÇÉ ‚Üí J` -/\n  q : I‚ÇÅ √ó I‚ÇÇ‚ÇÉ ‚Üí J\n  hpq (i : I‚ÇÅ √ó I‚ÇÇ √ó I‚ÇÉ) : q ‚ü®i.1, p i.2‚ü© = r i\n\n"}
{"name":"CategoryTheory.GradedObject.ŒπMapBifunctorBifunctor‚ÇÇ‚ÇÉMapObj_eq","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\nC‚ÇÑ : Type u_4\nC‚ÇÇ‚ÇÉ : Type u_6\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_14, u_1} C‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{u_16, u_2} C‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_15, u_3} C‚ÇÉ\ninst‚úù¬≥ : CategoryTheory.Category.{u_12, u_4} C‚ÇÑ\ninst‚úù¬≤ : CategoryTheory.Category.{u_13, u_6} C‚ÇÇ‚ÇÉ\nF : CategoryTheory.Functor C‚ÇÅ (CategoryTheory.Functor C‚ÇÇ‚ÇÉ C‚ÇÑ)\nG‚ÇÇ‚ÇÉ : CategoryTheory.Functor C‚ÇÇ (CategoryTheory.Functor C‚ÇÉ C‚ÇÇ‚ÇÉ)\nI‚ÇÅ : Type u_7\nI‚ÇÇ : Type u_8\nI‚ÇÉ : Type u_9\nJ : Type u_10\nr : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ) ‚Üí J\nœÅ‚ÇÇ‚ÇÉ : CategoryTheory.GradedObject.BifunctorComp‚ÇÇ‚ÇÉIndexData r\nX‚ÇÅ : CategoryTheory.GradedObject I‚ÇÅ C‚ÇÅ\nX‚ÇÇ : CategoryTheory.GradedObject I‚ÇÇ C‚ÇÇ\nX‚ÇÉ : CategoryTheory.GradedObject I‚ÇÉ C‚ÇÉ\ninst‚úù¬π : (((CategoryTheory.GradedObject.mapBifunctor G‚ÇÇ‚ÇÉ I‚ÇÇ I‚ÇÉ).obj X‚ÇÇ).obj X‚ÇÉ).HasMap œÅ‚ÇÇ‚ÇÉ.p\ninst‚úù : (((CategoryTheory.GradedObject.mapBifunctor F I‚ÇÅ œÅ‚ÇÇ‚ÇÉ.I‚ÇÇ‚ÇÉ).obj X‚ÇÅ).obj (CategoryTheory.GradedObject.mapBifunctorMapObj G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ.p X‚ÇÇ X‚ÇÉ)).HasMap œÅ‚ÇÇ‚ÇÉ.q\ni‚ÇÅ : I‚ÇÅ\ni‚ÇÇ : I‚ÇÇ\ni‚ÇÉ : I‚ÇÉ\nj : J\nh : Eq (r { fst := i‚ÇÅ, snd := { fst := i‚ÇÇ, snd := i‚ÇÉ } }) j\ni‚ÇÇ‚ÇÉ : œÅ‚ÇÇ‚ÇÉ.I‚ÇÇ‚ÇÉ\nh‚ÇÇ‚ÇÉ : Eq (œÅ‚ÇÇ‚ÇÉ.p { fst := i‚ÇÇ, snd := i‚ÇÉ }) i‚ÇÇ‚ÇÉ\n‚ä¢ Eq (CategoryTheory.GradedObject.ŒπMapBifunctorBifunctor‚ÇÇ‚ÇÉMapObj F G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h) (CategoryTheory.CategoryStruct.comp ((F.obj (X‚ÇÅ i‚ÇÅ)).map (CategoryTheory.GradedObject.ŒπMapBifunctorMapObj G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ.p X‚ÇÇ X‚ÇÉ i‚ÇÇ i‚ÇÉ i‚ÇÇ‚ÇÉ h‚ÇÇ‚ÇÉ)) (CategoryTheory.GradedObject.ŒπMapBifunctorMapObj F œÅ‚ÇÇ‚ÇÉ.q X‚ÇÅ (CategoryTheory.GradedObject.mapBifunctorMapObj G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ.p X‚ÇÇ X‚ÇÉ) i‚ÇÅ i‚ÇÇ‚ÇÉ j ‚ãØ))","decl":"@[reassoc]\nlemma ŒπMapBifunctorBifunctor‚ÇÇ‚ÇÉMapObj_eq (i‚ÇÅ : I‚ÇÅ) (i‚ÇÇ : I‚ÇÇ) (i‚ÇÉ : I‚ÇÉ) (j : J)\n    (h : r (i‚ÇÅ, i‚ÇÇ, i‚ÇÉ) = j) (i‚ÇÇ‚ÇÉ : œÅ‚ÇÇ‚ÇÉ.I‚ÇÇ‚ÇÉ) (h‚ÇÇ‚ÇÉ : œÅ‚ÇÇ‚ÇÉ.p ‚ü®i‚ÇÇ, i‚ÇÉ‚ü© = i‚ÇÇ‚ÇÉ) :\n    ŒπMapBifunctorBifunctor‚ÇÇ‚ÇÉMapObj F G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h =\n  (F.obj (X‚ÇÅ i‚ÇÅ)).map (ŒπMapBifunctorMapObj G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ.p X‚ÇÇ X‚ÇÉ i‚ÇÇ i‚ÇÉ i‚ÇÇ‚ÇÉ h‚ÇÇ‚ÇÉ) ‚â´\n    ŒπMapBifunctorMapObj F œÅ‚ÇÇ‚ÇÉ.q X‚ÇÅ (mapBifunctorMapObj G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ.p X‚ÇÇ X‚ÇÉ) i‚ÇÅ i‚ÇÇ‚ÇÉ j\n      (by rw [‚Üê h, ‚Üê h‚ÇÇ‚ÇÉ, ‚Üê œÅ‚ÇÇ‚ÇÉ.hpq]) := by\n  subst h‚ÇÇ‚ÇÉ\n  rfl\n\n"}
{"name":"CategoryTheory.GradedObject.ŒπMapBifunctorBifunctor‚ÇÇ‚ÇÉMapObj_eq_assoc","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\nC‚ÇÑ : Type u_4\nC‚ÇÇ‚ÇÉ : Type u_6\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_14, u_1} C‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{u_16, u_2} C‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_15, u_3} C‚ÇÉ\ninst‚úù¬≥ : CategoryTheory.Category.{u_12, u_4} C‚ÇÑ\ninst‚úù¬≤ : CategoryTheory.Category.{u_13, u_6} C‚ÇÇ‚ÇÉ\nF : CategoryTheory.Functor C‚ÇÅ (CategoryTheory.Functor C‚ÇÇ‚ÇÉ C‚ÇÑ)\nG‚ÇÇ‚ÇÉ : CategoryTheory.Functor C‚ÇÇ (CategoryTheory.Functor C‚ÇÉ C‚ÇÇ‚ÇÉ)\nI‚ÇÅ : Type u_7\nI‚ÇÇ : Type u_8\nI‚ÇÉ : Type u_9\nJ : Type u_10\nr : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ) ‚Üí J\nœÅ‚ÇÇ‚ÇÉ : CategoryTheory.GradedObject.BifunctorComp‚ÇÇ‚ÇÉIndexData r\nX‚ÇÅ : CategoryTheory.GradedObject I‚ÇÅ C‚ÇÅ\nX‚ÇÇ : CategoryTheory.GradedObject I‚ÇÇ C‚ÇÇ\nX‚ÇÉ : CategoryTheory.GradedObject I‚ÇÉ C‚ÇÉ\ninst‚úù¬π : (((CategoryTheory.GradedObject.mapBifunctor G‚ÇÇ‚ÇÉ I‚ÇÇ I‚ÇÉ).obj X‚ÇÇ).obj X‚ÇÉ).HasMap œÅ‚ÇÇ‚ÇÉ.p\ninst‚úù : (((CategoryTheory.GradedObject.mapBifunctor F I‚ÇÅ œÅ‚ÇÇ‚ÇÉ.I‚ÇÇ‚ÇÉ).obj X‚ÇÅ).obj (CategoryTheory.GradedObject.mapBifunctorMapObj G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ.p X‚ÇÇ X‚ÇÉ)).HasMap œÅ‚ÇÇ‚ÇÉ.q\ni‚ÇÅ : I‚ÇÅ\ni‚ÇÇ : I‚ÇÇ\ni‚ÇÉ : I‚ÇÉ\nj : J\nh‚úù : Eq (r { fst := i‚ÇÅ, snd := { fst := i‚ÇÇ, snd := i‚ÇÉ } }) j\ni‚ÇÇ‚ÇÉ : œÅ‚ÇÇ‚ÇÉ.I‚ÇÇ‚ÇÉ\nh‚ÇÇ‚ÇÉ : Eq (œÅ‚ÇÇ‚ÇÉ.p { fst := i‚ÇÇ, snd := i‚ÇÉ }) i‚ÇÇ‚ÇÉ\nZ : C‚ÇÑ\nh : Quiver.Hom (CategoryTheory.GradedObject.mapBifunctorMapObj F œÅ‚ÇÇ‚ÇÉ.q X‚ÇÅ (CategoryTheory.GradedObject.mapBifunctorMapObj G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ.p X‚ÇÇ X‚ÇÉ) j) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ŒπMapBifunctorBifunctor‚ÇÇ‚ÇÉMapObj F G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h‚úù) h) (CategoryTheory.CategoryStruct.comp ((F.obj (X‚ÇÅ i‚ÇÅ)).map (CategoryTheory.GradedObject.ŒπMapBifunctorMapObj G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ.p X‚ÇÇ X‚ÇÉ i‚ÇÇ i‚ÇÉ i‚ÇÇ‚ÇÉ h‚ÇÇ‚ÇÉ)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ŒπMapBifunctorMapObj F œÅ‚ÇÇ‚ÇÉ.q X‚ÇÅ (CategoryTheory.GradedObject.mapBifunctorMapObj G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ.p X‚ÇÇ X‚ÇÉ) i‚ÇÅ i‚ÇÇ‚ÇÉ j ‚ãØ) h))","decl":"@[reassoc]\nlemma ŒπMapBifunctorBifunctor‚ÇÇ‚ÇÉMapObj_eq (i‚ÇÅ : I‚ÇÅ) (i‚ÇÇ : I‚ÇÇ) (i‚ÇÉ : I‚ÇÉ) (j : J)\n    (h : r (i‚ÇÅ, i‚ÇÇ, i‚ÇÉ) = j) (i‚ÇÇ‚ÇÉ : œÅ‚ÇÇ‚ÇÉ.I‚ÇÇ‚ÇÉ) (h‚ÇÇ‚ÇÉ : œÅ‚ÇÇ‚ÇÉ.p ‚ü®i‚ÇÇ, i‚ÇÉ‚ü© = i‚ÇÇ‚ÇÉ) :\n    ŒπMapBifunctorBifunctor‚ÇÇ‚ÇÉMapObj F G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h =\n  (F.obj (X‚ÇÅ i‚ÇÅ)).map (ŒπMapBifunctorMapObj G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ.p X‚ÇÇ X‚ÇÉ i‚ÇÇ i‚ÇÉ i‚ÇÇ‚ÇÉ h‚ÇÇ‚ÇÉ) ‚â´\n    ŒπMapBifunctorMapObj F œÅ‚ÇÇ‚ÇÉ.q X‚ÇÅ (mapBifunctorMapObj G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ.p X‚ÇÇ X‚ÇÉ) i‚ÇÅ i‚ÇÇ‚ÇÉ j\n      (by rw [‚Üê h, ‚Üê h‚ÇÇ‚ÇÉ, ‚Üê œÅ‚ÇÇ‚ÇÉ.hpq]) := by\n  subst h‚ÇÇ‚ÇÉ\n  rfl\n\n"}
{"name":"CategoryTheory.GradedObject.HasGoodTrifunctor‚ÇÇ‚ÇÉObj.hasMap","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\nC‚ÇÑ : Type u_4\nC‚ÇÇ‚ÇÉ : Type u_6\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_14, u_1} C‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{u_13, u_2} C‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_12, u_3} C‚ÇÉ\ninst‚úù¬≥ : CategoryTheory.Category.{u_11, u_4} C‚ÇÑ\ninst‚úù¬≤ : CategoryTheory.Category.{u_15, u_6} C‚ÇÇ‚ÇÉ\nF : CategoryTheory.Functor C‚ÇÅ (CategoryTheory.Functor C‚ÇÇ‚ÇÉ C‚ÇÑ)\nG‚ÇÇ‚ÇÉ : CategoryTheory.Functor C‚ÇÇ (CategoryTheory.Functor C‚ÇÉ C‚ÇÇ‚ÇÉ)\nI‚ÇÅ : Type u_7\nI‚ÇÇ : Type u_8\nI‚ÇÉ : Type u_9\nJ : Type u_10\nr : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ) ‚Üí J\nœÅ‚ÇÇ‚ÇÉ : CategoryTheory.GradedObject.BifunctorComp‚ÇÇ‚ÇÉIndexData r\nX‚ÇÅ : CategoryTheory.GradedObject I‚ÇÅ C‚ÇÅ\nX‚ÇÇ : CategoryTheory.GradedObject I‚ÇÇ C‚ÇÇ\nX‚ÇÉ : CategoryTheory.GradedObject I‚ÇÉ C‚ÇÉ\ninst‚úù¬π : (((CategoryTheory.GradedObject.mapBifunctor G‚ÇÇ‚ÇÉ I‚ÇÇ I‚ÇÉ).obj X‚ÇÇ).obj X‚ÇÉ).HasMap œÅ‚ÇÇ‚ÇÉ.p\ninst‚úù : (((CategoryTheory.GradedObject.mapBifunctor F I‚ÇÅ œÅ‚ÇÇ‚ÇÉ.I‚ÇÇ‚ÇÉ).obj X‚ÇÅ).obj (CategoryTheory.GradedObject.mapBifunctorMapObj G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ.p X‚ÇÇ X‚ÇÉ)).HasMap œÅ‚ÇÇ‚ÇÉ.q\nH : CategoryTheory.GradedObject.HasGoodTrifunctor‚ÇÇ‚ÇÉObj F G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ X‚ÇÅ X‚ÇÇ X‚ÇÉ\n‚ä¢ ((((CategoryTheory.GradedObject.mapTrifunctor (CategoryTheory.bifunctorComp‚ÇÇ‚ÇÉ F G‚ÇÇ‚ÇÉ) I‚ÇÅ I‚ÇÇ I‚ÇÉ).obj X‚ÇÅ).obj X‚ÇÇ).obj X‚ÇÉ).HasMap r","decl":"include œÅ‚ÇÇ‚ÇÉ in\nlemma HasGoodTrifunctor‚ÇÇ‚ÇÉObj.hasMap :\n    HasMap ((((mapTrifunctor (bifunctorComp‚ÇÇ‚ÇÉ F G‚ÇÇ‚ÇÉ) I‚ÇÅ I‚ÇÇ I‚ÇÉ).obj X‚ÇÅ).obj X‚ÇÇ).obj X‚ÇÉ) r :=\n  fun j => ‚ü®_, isColimitCofan‚ÇÉMapBifunctorBifunctor‚ÇÇ‚ÇÉMapObj F G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ X‚ÇÅ X‚ÇÇ X‚ÇÉ j‚ü©\n\n"}
{"name":"CategoryTheory.GradedObject.Œπ_mapBifunctorComp‚ÇÇ‚ÇÉMapObjIso_hom","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\nC‚ÇÑ : Type u_4\nC‚ÇÇ‚ÇÉ : Type u_6\ninst‚úù‚Å∑ : CategoryTheory.Category.{u_14, u_1} C‚ÇÅ\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_13, u_2} C‚ÇÇ\ninst‚úù‚Åµ : CategoryTheory.Category.{u_12, u_3} C‚ÇÉ\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_11, u_4} C‚ÇÑ\ninst‚úù¬≥ : CategoryTheory.Category.{u_15, u_6} C‚ÇÇ‚ÇÉ\nF : CategoryTheory.Functor C‚ÇÅ (CategoryTheory.Functor C‚ÇÇ‚ÇÉ C‚ÇÑ)\nG‚ÇÇ‚ÇÉ : CategoryTheory.Functor C‚ÇÇ (CategoryTheory.Functor C‚ÇÉ C‚ÇÇ‚ÇÉ)\nI‚ÇÅ : Type u_7\nI‚ÇÇ : Type u_8\nI‚ÇÉ : Type u_9\nJ : Type u_10\nr : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ) ‚Üí J\nœÅ‚ÇÇ‚ÇÉ : CategoryTheory.GradedObject.BifunctorComp‚ÇÇ‚ÇÉIndexData r\nX‚ÇÅ : CategoryTheory.GradedObject I‚ÇÅ C‚ÇÅ\nX‚ÇÇ : CategoryTheory.GradedObject I‚ÇÇ C‚ÇÇ\nX‚ÇÉ : CategoryTheory.GradedObject I‚ÇÉ C‚ÇÉ\ninst‚úù¬≤ : (((CategoryTheory.GradedObject.mapBifunctor G‚ÇÇ‚ÇÉ I‚ÇÇ I‚ÇÉ).obj X‚ÇÇ).obj X‚ÇÉ).HasMap œÅ‚ÇÇ‚ÇÉ.p\ninst‚úù¬π : (((CategoryTheory.GradedObject.mapBifunctor F I‚ÇÅ œÅ‚ÇÇ‚ÇÉ.I‚ÇÇ‚ÇÉ).obj X‚ÇÅ).obj (CategoryTheory.GradedObject.mapBifunctorMapObj G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ.p X‚ÇÇ X‚ÇÉ)).HasMap œÅ‚ÇÇ‚ÇÉ.q\nH : CategoryTheory.GradedObject.HasGoodTrifunctor‚ÇÇ‚ÇÉObj F G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ X‚ÇÅ X‚ÇÇ X‚ÇÉ\ninst‚úù : ((((CategoryTheory.GradedObject.mapTrifunctor (CategoryTheory.bifunctorComp‚ÇÇ‚ÇÉ F G‚ÇÇ‚ÇÉ) I‚ÇÅ I‚ÇÇ I‚ÇÉ).obj X‚ÇÅ).obj X‚ÇÇ).obj X‚ÇÉ).HasMap r\ni‚ÇÅ : I‚ÇÅ\ni‚ÇÇ : I‚ÇÇ\ni‚ÇÉ : I‚ÇÉ\nj : J\nh : Eq (r { fst := i‚ÇÅ, snd := { fst := i‚ÇÇ, snd := i‚ÇÉ } }) j\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ŒπMapTrifunctorMapObj (CategoryTheory.bifunctorComp‚ÇÇ‚ÇÉ F G‚ÇÇ‚ÇÉ) r X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h) ((CategoryTheory.GradedObject.mapBifunctorComp‚ÇÇ‚ÇÉMapObjIso F G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ X‚ÇÅ X‚ÇÇ X‚ÇÉ).hom j)) (CategoryTheory.GradedObject.ŒπMapBifunctorBifunctor‚ÇÇ‚ÇÉMapObj F G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h)","decl":"@[reassoc (attr := simp)]\nlemma Œπ_mapBifunctorComp‚ÇÇ‚ÇÉMapObjIso_hom (i‚ÇÅ : I‚ÇÅ) (i‚ÇÇ : I‚ÇÇ) (i‚ÇÉ : I‚ÇÉ) (j : J)\n    (h : r (i‚ÇÅ, i‚ÇÇ, i‚ÇÉ) = j) :\n    ŒπMapTrifunctorMapObj (bifunctorComp‚ÇÇ‚ÇÉ F G‚ÇÇ‚ÇÉ) r X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h ‚â´\n      (mapBifunctorComp‚ÇÇ‚ÇÉMapObjIso F G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ X‚ÇÅ X‚ÇÇ X‚ÇÉ).hom j =\n      ŒπMapBifunctorBifunctor‚ÇÇ‚ÇÉMapObj F G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h := by\n  dsimp [mapBifunctorComp‚ÇÇ‚ÇÉMapObjIso]\n  apply CofanMapObjFun.ŒπMapObj_iso_inv\n\n"}
{"name":"CategoryTheory.GradedObject.Œπ_mapBifunctorComp‚ÇÇ‚ÇÉMapObjIso_hom_assoc","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\nC‚ÇÑ : Type u_4\nC‚ÇÇ‚ÇÉ : Type u_6\ninst‚úù‚Å∑ : CategoryTheory.Category.{u_14, u_1} C‚ÇÅ\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_13, u_2} C‚ÇÇ\ninst‚úù‚Åµ : CategoryTheory.Category.{u_12, u_3} C‚ÇÉ\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_11, u_4} C‚ÇÑ\ninst‚úù¬≥ : CategoryTheory.Category.{u_15, u_6} C‚ÇÇ‚ÇÉ\nF : CategoryTheory.Functor C‚ÇÅ (CategoryTheory.Functor C‚ÇÇ‚ÇÉ C‚ÇÑ)\nG‚ÇÇ‚ÇÉ : CategoryTheory.Functor C‚ÇÇ (CategoryTheory.Functor C‚ÇÉ C‚ÇÇ‚ÇÉ)\nI‚ÇÅ : Type u_7\nI‚ÇÇ : Type u_8\nI‚ÇÉ : Type u_9\nJ : Type u_10\nr : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ) ‚Üí J\nœÅ‚ÇÇ‚ÇÉ : CategoryTheory.GradedObject.BifunctorComp‚ÇÇ‚ÇÉIndexData r\nX‚ÇÅ : CategoryTheory.GradedObject I‚ÇÅ C‚ÇÅ\nX‚ÇÇ : CategoryTheory.GradedObject I‚ÇÇ C‚ÇÇ\nX‚ÇÉ : CategoryTheory.GradedObject I‚ÇÉ C‚ÇÉ\ninst‚úù¬≤ : (((CategoryTheory.GradedObject.mapBifunctor G‚ÇÇ‚ÇÉ I‚ÇÇ I‚ÇÉ).obj X‚ÇÇ).obj X‚ÇÉ).HasMap œÅ‚ÇÇ‚ÇÉ.p\ninst‚úù¬π : (((CategoryTheory.GradedObject.mapBifunctor F I‚ÇÅ œÅ‚ÇÇ‚ÇÉ.I‚ÇÇ‚ÇÉ).obj X‚ÇÅ).obj (CategoryTheory.GradedObject.mapBifunctorMapObj G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ.p X‚ÇÇ X‚ÇÉ)).HasMap œÅ‚ÇÇ‚ÇÉ.q\nH : CategoryTheory.GradedObject.HasGoodTrifunctor‚ÇÇ‚ÇÉObj F G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ X‚ÇÅ X‚ÇÇ X‚ÇÉ\ninst‚úù : ((((CategoryTheory.GradedObject.mapTrifunctor (CategoryTheory.bifunctorComp‚ÇÇ‚ÇÉ F G‚ÇÇ‚ÇÉ) I‚ÇÅ I‚ÇÇ I‚ÇÉ).obj X‚ÇÅ).obj X‚ÇÇ).obj X‚ÇÉ).HasMap r\ni‚ÇÅ : I‚ÇÅ\ni‚ÇÇ : I‚ÇÇ\ni‚ÇÉ : I‚ÇÉ\nj : J\nh‚úù : Eq (r { fst := i‚ÇÅ, snd := { fst := i‚ÇÇ, snd := i‚ÇÉ } }) j\nZ : C‚ÇÑ\nh : Quiver.Hom (CategoryTheory.GradedObject.mapBifunctorMapObj F œÅ‚ÇÇ‚ÇÉ.q X‚ÇÅ (CategoryTheory.GradedObject.mapBifunctorMapObj G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ.p X‚ÇÇ X‚ÇÉ) j) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ŒπMapTrifunctorMapObj (CategoryTheory.bifunctorComp‚ÇÇ‚ÇÉ F G‚ÇÇ‚ÇÉ) r X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h‚úù) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.GradedObject.mapBifunctorComp‚ÇÇ‚ÇÉMapObjIso F G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ X‚ÇÅ X‚ÇÇ X‚ÇÉ).hom j) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ŒπMapBifunctorBifunctor‚ÇÇ‚ÇÉMapObj F G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h‚úù) h)","decl":"@[reassoc (attr := simp)]\nlemma Œπ_mapBifunctorComp‚ÇÇ‚ÇÉMapObjIso_hom (i‚ÇÅ : I‚ÇÅ) (i‚ÇÇ : I‚ÇÇ) (i‚ÇÉ : I‚ÇÉ) (j : J)\n    (h : r (i‚ÇÅ, i‚ÇÇ, i‚ÇÉ) = j) :\n    ŒπMapTrifunctorMapObj (bifunctorComp‚ÇÇ‚ÇÉ F G‚ÇÇ‚ÇÉ) r X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h ‚â´\n      (mapBifunctorComp‚ÇÇ‚ÇÉMapObjIso F G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ X‚ÇÅ X‚ÇÇ X‚ÇÉ).hom j =\n      ŒπMapBifunctorBifunctor‚ÇÇ‚ÇÉMapObj F G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h := by\n  dsimp [mapBifunctorComp‚ÇÇ‚ÇÉMapObjIso]\n  apply CofanMapObjFun.ŒπMapObj_iso_inv\n\n"}
{"name":"CategoryTheory.GradedObject.Œπ_mapBifunctorComp‚ÇÇ‚ÇÉMapObjIso_inv","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\nC‚ÇÑ : Type u_4\nC‚ÇÇ‚ÇÉ : Type u_6\ninst‚úù‚Å∑ : CategoryTheory.Category.{u_13, u_1} C‚ÇÅ\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_15, u_2} C‚ÇÇ\ninst‚úù‚Åµ : CategoryTheory.Category.{u_14, u_3} C‚ÇÉ\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_11, u_4} C‚ÇÑ\ninst‚úù¬≥ : CategoryTheory.Category.{u_12, u_6} C‚ÇÇ‚ÇÉ\nF : CategoryTheory.Functor C‚ÇÅ (CategoryTheory.Functor C‚ÇÇ‚ÇÉ C‚ÇÑ)\nG‚ÇÇ‚ÇÉ : CategoryTheory.Functor C‚ÇÇ (CategoryTheory.Functor C‚ÇÉ C‚ÇÇ‚ÇÉ)\nI‚ÇÅ : Type u_7\nI‚ÇÇ : Type u_8\nI‚ÇÉ : Type u_9\nJ : Type u_10\nr : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ) ‚Üí J\nœÅ‚ÇÇ‚ÇÉ : CategoryTheory.GradedObject.BifunctorComp‚ÇÇ‚ÇÉIndexData r\nX‚ÇÅ : CategoryTheory.GradedObject I‚ÇÅ C‚ÇÅ\nX‚ÇÇ : CategoryTheory.GradedObject I‚ÇÇ C‚ÇÇ\nX‚ÇÉ : CategoryTheory.GradedObject I‚ÇÉ C‚ÇÉ\ninst‚úù¬≤ : (((CategoryTheory.GradedObject.mapBifunctor G‚ÇÇ‚ÇÉ I‚ÇÇ I‚ÇÉ).obj X‚ÇÇ).obj X‚ÇÉ).HasMap œÅ‚ÇÇ‚ÇÉ.p\ninst‚úù¬π : (((CategoryTheory.GradedObject.mapBifunctor F I‚ÇÅ œÅ‚ÇÇ‚ÇÉ.I‚ÇÇ‚ÇÉ).obj X‚ÇÅ).obj (CategoryTheory.GradedObject.mapBifunctorMapObj G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ.p X‚ÇÇ X‚ÇÉ)).HasMap œÅ‚ÇÇ‚ÇÉ.q\nH : CategoryTheory.GradedObject.HasGoodTrifunctor‚ÇÇ‚ÇÉObj F G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ X‚ÇÅ X‚ÇÇ X‚ÇÉ\ninst‚úù : ((((CategoryTheory.GradedObject.mapTrifunctor (CategoryTheory.bifunctorComp‚ÇÇ‚ÇÉ F G‚ÇÇ‚ÇÉ) I‚ÇÅ I‚ÇÇ I‚ÇÉ).obj X‚ÇÅ).obj X‚ÇÇ).obj X‚ÇÉ).HasMap r\ni‚ÇÅ : I‚ÇÅ\ni‚ÇÇ : I‚ÇÇ\ni‚ÇÉ : I‚ÇÉ\nj : J\nh : Eq (r { fst := i‚ÇÅ, snd := { fst := i‚ÇÇ, snd := i‚ÇÉ } }) j\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ŒπMapBifunctorBifunctor‚ÇÇ‚ÇÉMapObj F G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h) ((CategoryTheory.GradedObject.mapBifunctorComp‚ÇÇ‚ÇÉMapObjIso F G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ X‚ÇÅ X‚ÇÇ X‚ÇÉ).inv j)) (CategoryTheory.GradedObject.ŒπMapTrifunctorMapObj (CategoryTheory.bifunctorComp‚ÇÇ‚ÇÉ F G‚ÇÇ‚ÇÉ) r X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h)","decl":"@[reassoc (attr := simp)]\nlemma Œπ_mapBifunctorComp‚ÇÇ‚ÇÉMapObjIso_inv (i‚ÇÅ : I‚ÇÅ) (i‚ÇÇ : I‚ÇÇ) (i‚ÇÉ : I‚ÇÉ) (j : J)\n    (h : r (i‚ÇÅ, i‚ÇÇ, i‚ÇÉ) = j) :\n    ŒπMapBifunctorBifunctor‚ÇÇ‚ÇÉMapObj F G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h ‚â´\n      (mapBifunctorComp‚ÇÇ‚ÇÉMapObjIso F G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ X‚ÇÅ X‚ÇÇ X‚ÇÉ).inv j =\n      ŒπMapTrifunctorMapObj (bifunctorComp‚ÇÇ‚ÇÉ F G‚ÇÇ‚ÇÉ) r X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h :=\n  CofanMapObjFun.inj_iso_hom\n    (isColimitCofan‚ÇÉMapBifunctorBifunctor‚ÇÇ‚ÇÉMapObj F G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ X‚ÇÅ X‚ÇÇ X‚ÇÉ j) _ h\n\n"}
{"name":"CategoryTheory.GradedObject.Œπ_mapBifunctorComp‚ÇÇ‚ÇÉMapObjIso_inv_assoc","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\nC‚ÇÑ : Type u_4\nC‚ÇÇ‚ÇÉ : Type u_6\ninst‚úù‚Å∑ : CategoryTheory.Category.{u_13, u_1} C‚ÇÅ\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_15, u_2} C‚ÇÇ\ninst‚úù‚Åµ : CategoryTheory.Category.{u_14, u_3} C‚ÇÉ\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_11, u_4} C‚ÇÑ\ninst‚úù¬≥ : CategoryTheory.Category.{u_12, u_6} C‚ÇÇ‚ÇÉ\nF : CategoryTheory.Functor C‚ÇÅ (CategoryTheory.Functor C‚ÇÇ‚ÇÉ C‚ÇÑ)\nG‚ÇÇ‚ÇÉ : CategoryTheory.Functor C‚ÇÇ (CategoryTheory.Functor C‚ÇÉ C‚ÇÇ‚ÇÉ)\nI‚ÇÅ : Type u_7\nI‚ÇÇ : Type u_8\nI‚ÇÉ : Type u_9\nJ : Type u_10\nr : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ) ‚Üí J\nœÅ‚ÇÇ‚ÇÉ : CategoryTheory.GradedObject.BifunctorComp‚ÇÇ‚ÇÉIndexData r\nX‚ÇÅ : CategoryTheory.GradedObject I‚ÇÅ C‚ÇÅ\nX‚ÇÇ : CategoryTheory.GradedObject I‚ÇÇ C‚ÇÇ\nX‚ÇÉ : CategoryTheory.GradedObject I‚ÇÉ C‚ÇÉ\ninst‚úù¬≤ : (((CategoryTheory.GradedObject.mapBifunctor G‚ÇÇ‚ÇÉ I‚ÇÇ I‚ÇÉ).obj X‚ÇÇ).obj X‚ÇÉ).HasMap œÅ‚ÇÇ‚ÇÉ.p\ninst‚úù¬π : (((CategoryTheory.GradedObject.mapBifunctor F I‚ÇÅ œÅ‚ÇÇ‚ÇÉ.I‚ÇÇ‚ÇÉ).obj X‚ÇÅ).obj (CategoryTheory.GradedObject.mapBifunctorMapObj G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ.p X‚ÇÇ X‚ÇÉ)).HasMap œÅ‚ÇÇ‚ÇÉ.q\nH : CategoryTheory.GradedObject.HasGoodTrifunctor‚ÇÇ‚ÇÉObj F G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ X‚ÇÅ X‚ÇÇ X‚ÇÉ\ninst‚úù : ((((CategoryTheory.GradedObject.mapTrifunctor (CategoryTheory.bifunctorComp‚ÇÇ‚ÇÉ F G‚ÇÇ‚ÇÉ) I‚ÇÅ I‚ÇÇ I‚ÇÉ).obj X‚ÇÅ).obj X‚ÇÇ).obj X‚ÇÉ).HasMap r\ni‚ÇÅ : I‚ÇÅ\ni‚ÇÇ : I‚ÇÇ\ni‚ÇÉ : I‚ÇÉ\nj : J\nh‚úù : Eq (r { fst := i‚ÇÅ, snd := { fst := i‚ÇÇ, snd := i‚ÇÉ } }) j\nZ : C‚ÇÑ\nh : Quiver.Hom (CategoryTheory.GradedObject.mapTrifunctorMapObj (CategoryTheory.bifunctorComp‚ÇÇ‚ÇÉ F G‚ÇÇ‚ÇÉ) r X‚ÇÅ X‚ÇÇ X‚ÇÉ j) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ŒπMapBifunctorBifunctor‚ÇÇ‚ÇÉMapObj F G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h‚úù) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.GradedObject.mapBifunctorComp‚ÇÇ‚ÇÉMapObjIso F G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ X‚ÇÅ X‚ÇÇ X‚ÇÉ).inv j) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ŒπMapTrifunctorMapObj (CategoryTheory.bifunctorComp‚ÇÇ‚ÇÉ F G‚ÇÇ‚ÇÉ) r X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h‚úù) h)","decl":"@[reassoc (attr := simp)]\nlemma Œπ_mapBifunctorComp‚ÇÇ‚ÇÉMapObjIso_inv (i‚ÇÅ : I‚ÇÅ) (i‚ÇÇ : I‚ÇÇ) (i‚ÇÉ : I‚ÇÉ) (j : J)\n    (h : r (i‚ÇÅ, i‚ÇÇ, i‚ÇÉ) = j) :\n    ŒπMapBifunctorBifunctor‚ÇÇ‚ÇÉMapObj F G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h ‚â´\n      (mapBifunctorComp‚ÇÇ‚ÇÉMapObjIso F G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ X‚ÇÅ X‚ÇÇ X‚ÇÉ).inv j =\n      ŒπMapTrifunctorMapObj (bifunctorComp‚ÇÇ‚ÇÉ F G‚ÇÇ‚ÇÉ) r X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h :=\n  CofanMapObjFun.inj_iso_hom\n    (isColimitCofan‚ÇÉMapBifunctorBifunctor‚ÇÇ‚ÇÉMapObj F G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ X‚ÇÅ X‚ÇÇ X‚ÇÉ j) _ h\n\n"}
{"name":"CategoryTheory.GradedObject.mapBifunctorBifunctor‚ÇÇ‚ÇÉMapObj_ext_iff","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\nC‚ÇÑ : Type u_4\nC‚ÇÇ‚ÇÉ : Type u_6\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_13, u_1} C‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{u_15, u_2} C‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_16, u_3} C‚ÇÉ\ninst‚úù¬≥ : CategoryTheory.Category.{u_11, u_4} C‚ÇÑ\ninst‚úù¬≤ : CategoryTheory.Category.{u_14, u_6} C‚ÇÇ‚ÇÉ\nF : CategoryTheory.Functor C‚ÇÅ (CategoryTheory.Functor C‚ÇÇ‚ÇÉ C‚ÇÑ)\nG‚ÇÇ‚ÇÉ : CategoryTheory.Functor C‚ÇÇ (CategoryTheory.Functor C‚ÇÉ C‚ÇÇ‚ÇÉ)\nI‚ÇÅ : Type u_7\nI‚ÇÇ : Type u_8\nI‚ÇÉ : Type u_9\nJ : Type u_10\nr : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ) ‚Üí J\nœÅ‚ÇÇ‚ÇÉ : CategoryTheory.GradedObject.BifunctorComp‚ÇÇ‚ÇÉIndexData r\nX‚ÇÅ : CategoryTheory.GradedObject I‚ÇÅ C‚ÇÅ\nX‚ÇÇ : CategoryTheory.GradedObject I‚ÇÇ C‚ÇÇ\nX‚ÇÉ : CategoryTheory.GradedObject I‚ÇÉ C‚ÇÉ\ninst‚úù¬π : (((CategoryTheory.GradedObject.mapBifunctor G‚ÇÇ‚ÇÉ I‚ÇÇ I‚ÇÉ).obj X‚ÇÇ).obj X‚ÇÉ).HasMap œÅ‚ÇÇ‚ÇÉ.p\ninst‚úù : (((CategoryTheory.GradedObject.mapBifunctor F I‚ÇÅ œÅ‚ÇÇ‚ÇÉ.I‚ÇÇ‚ÇÉ).obj X‚ÇÅ).obj (CategoryTheory.GradedObject.mapBifunctorMapObj G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ.p X‚ÇÇ X‚ÇÉ)).HasMap œÅ‚ÇÇ‚ÇÉ.q\nH : CategoryTheory.GradedObject.HasGoodTrifunctor‚ÇÇ‚ÇÉObj F G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ X‚ÇÅ X‚ÇÇ X‚ÇÉ\nj : J\nA : C‚ÇÑ\nf g : Quiver.Hom (CategoryTheory.GradedObject.mapBifunctorMapObj F œÅ‚ÇÇ‚ÇÉ.q X‚ÇÅ (CategoryTheory.GradedObject.mapBifunctorMapObj G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ.p X‚ÇÇ X‚ÇÉ) j) A\n‚ä¢ Iff (Eq f g) (‚àÄ (i‚ÇÅ : I‚ÇÅ) (i‚ÇÇ : I‚ÇÇ) (i‚ÇÉ : I‚ÇÉ) (h : Eq (r { fst := i‚ÇÅ, snd := { fst := i‚ÇÇ, snd := i‚ÇÉ } }) j), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ŒπMapBifunctorBifunctor‚ÇÇ‚ÇÉMapObj F G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h) f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ŒπMapBifunctorBifunctor‚ÇÇ‚ÇÉMapObj F G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h) g))","decl":"@[ext]\nlemma mapBifunctorBifunctor‚ÇÇ‚ÇÉMapObj_ext\n    {f g : mapBifunctorMapObj F œÅ‚ÇÇ‚ÇÉ.q X‚ÇÅ (mapBifunctorMapObj G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ.p X‚ÇÇ X‚ÇÉ) j ‚ü∂ A}\n    (h : ‚àÄ (i‚ÇÅ : I‚ÇÅ) (i‚ÇÇ : I‚ÇÇ) (i‚ÇÉ : I‚ÇÉ) (h : r ‚ü®i‚ÇÅ, i‚ÇÇ, i‚ÇÉ‚ü© = j),\n      ŒπMapBifunctorBifunctor‚ÇÇ‚ÇÉMapObj F G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h ‚â´ f =\n        ŒπMapBifunctorBifunctor‚ÇÇ‚ÇÉMapObj F G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h ‚â´ g) : f = g := by\n  apply Cofan.IsColimit.hom_ext (isColimitCofan‚ÇÉMapBifunctorBifunctor‚ÇÇ‚ÇÉMapObj F G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ X‚ÇÅ X‚ÇÇ X‚ÇÉ j)\n  rintro ‚ü®i, hi‚ü©\n  exact h _ _ _ hi\n\n"}
{"name":"CategoryTheory.GradedObject.mapBifunctorBifunctor‚ÇÇ‚ÇÉMapObj_ext","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\nC‚ÇÑ : Type u_4\nC‚ÇÇ‚ÇÉ : Type u_6\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_13, u_1} C‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{u_15, u_2} C‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_16, u_3} C‚ÇÉ\ninst‚úù¬≥ : CategoryTheory.Category.{u_11, u_4} C‚ÇÑ\ninst‚úù¬≤ : CategoryTheory.Category.{u_14, u_6} C‚ÇÇ‚ÇÉ\nF : CategoryTheory.Functor C‚ÇÅ (CategoryTheory.Functor C‚ÇÇ‚ÇÉ C‚ÇÑ)\nG‚ÇÇ‚ÇÉ : CategoryTheory.Functor C‚ÇÇ (CategoryTheory.Functor C‚ÇÉ C‚ÇÇ‚ÇÉ)\nI‚ÇÅ : Type u_7\nI‚ÇÇ : Type u_8\nI‚ÇÉ : Type u_9\nJ : Type u_10\nr : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ) ‚Üí J\nœÅ‚ÇÇ‚ÇÉ : CategoryTheory.GradedObject.BifunctorComp‚ÇÇ‚ÇÉIndexData r\nX‚ÇÅ : CategoryTheory.GradedObject I‚ÇÅ C‚ÇÅ\nX‚ÇÇ : CategoryTheory.GradedObject I‚ÇÇ C‚ÇÇ\nX‚ÇÉ : CategoryTheory.GradedObject I‚ÇÉ C‚ÇÉ\ninst‚úù¬π : (((CategoryTheory.GradedObject.mapBifunctor G‚ÇÇ‚ÇÉ I‚ÇÇ I‚ÇÉ).obj X‚ÇÇ).obj X‚ÇÉ).HasMap œÅ‚ÇÇ‚ÇÉ.p\ninst‚úù : (((CategoryTheory.GradedObject.mapBifunctor F I‚ÇÅ œÅ‚ÇÇ‚ÇÉ.I‚ÇÇ‚ÇÉ).obj X‚ÇÅ).obj (CategoryTheory.GradedObject.mapBifunctorMapObj G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ.p X‚ÇÇ X‚ÇÉ)).HasMap œÅ‚ÇÇ‚ÇÉ.q\nH : CategoryTheory.GradedObject.HasGoodTrifunctor‚ÇÇ‚ÇÉObj F G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ X‚ÇÅ X‚ÇÇ X‚ÇÉ\nj : J\nA : C‚ÇÑ\nf g : Quiver.Hom (CategoryTheory.GradedObject.mapBifunctorMapObj F œÅ‚ÇÇ‚ÇÉ.q X‚ÇÅ (CategoryTheory.GradedObject.mapBifunctorMapObj G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ.p X‚ÇÇ X‚ÇÉ) j) A\nh : ‚àÄ (i‚ÇÅ : I‚ÇÅ) (i‚ÇÇ : I‚ÇÇ) (i‚ÇÉ : I‚ÇÉ) (h : Eq (r { fst := i‚ÇÅ, snd := { fst := i‚ÇÇ, snd := i‚ÇÉ } }) j), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ŒπMapBifunctorBifunctor‚ÇÇ‚ÇÉMapObj F G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h) f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ŒπMapBifunctorBifunctor‚ÇÇ‚ÇÉMapObj F G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h) g)\n‚ä¢ Eq f g","decl":"@[ext]\nlemma mapBifunctorBifunctor‚ÇÇ‚ÇÉMapObj_ext\n    {f g : mapBifunctorMapObj F œÅ‚ÇÇ‚ÇÉ.q X‚ÇÅ (mapBifunctorMapObj G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ.p X‚ÇÇ X‚ÇÉ) j ‚ü∂ A}\n    (h : ‚àÄ (i‚ÇÅ : I‚ÇÅ) (i‚ÇÇ : I‚ÇÇ) (i‚ÇÉ : I‚ÇÉ) (h : r ‚ü®i‚ÇÅ, i‚ÇÇ, i‚ÇÉ‚ü© = j),\n      ŒπMapBifunctorBifunctor‚ÇÇ‚ÇÉMapObj F G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h ‚â´ f =\n        ŒπMapBifunctorBifunctor‚ÇÇ‚ÇÉMapObj F G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h ‚â´ g) : f = g := by\n  apply Cofan.IsColimit.hom_ext (isColimitCofan‚ÇÉMapBifunctorBifunctor‚ÇÇ‚ÇÉMapObj F G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ X‚ÇÅ X‚ÇÇ X‚ÇÉ j)\n  rintro ‚ü®i, hi‚ü©\n  exact h _ _ _ hi\n\n"}
{"name":"CategoryTheory.GradedObject.Œπ_mapBifunctorBifunctor‚ÇÇ‚ÇÉDesc","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\nC‚ÇÑ : Type u_4\nC‚ÇÇ‚ÇÉ : Type u_6\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_13, u_1} C‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{u_15, u_2} C‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_14, u_3} C‚ÇÉ\ninst‚úù¬≥ : CategoryTheory.Category.{u_11, u_4} C‚ÇÑ\ninst‚úù¬≤ : CategoryTheory.Category.{u_12, u_6} C‚ÇÇ‚ÇÉ\nF : CategoryTheory.Functor C‚ÇÅ (CategoryTheory.Functor C‚ÇÇ‚ÇÉ C‚ÇÑ)\nG‚ÇÇ‚ÇÉ : CategoryTheory.Functor C‚ÇÇ (CategoryTheory.Functor C‚ÇÉ C‚ÇÇ‚ÇÉ)\nI‚ÇÅ : Type u_7\nI‚ÇÇ : Type u_8\nI‚ÇÉ : Type u_9\nJ : Type u_10\nr : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ) ‚Üí J\nœÅ‚ÇÇ‚ÇÉ : CategoryTheory.GradedObject.BifunctorComp‚ÇÇ‚ÇÉIndexData r\nX‚ÇÅ : CategoryTheory.GradedObject I‚ÇÅ C‚ÇÅ\nX‚ÇÇ : CategoryTheory.GradedObject I‚ÇÇ C‚ÇÇ\nX‚ÇÉ : CategoryTheory.GradedObject I‚ÇÉ C‚ÇÉ\ninst‚úù¬π : (((CategoryTheory.GradedObject.mapBifunctor G‚ÇÇ‚ÇÉ I‚ÇÇ I‚ÇÉ).obj X‚ÇÇ).obj X‚ÇÉ).HasMap œÅ‚ÇÇ‚ÇÉ.p\ninst‚úù : (((CategoryTheory.GradedObject.mapBifunctor F I‚ÇÅ œÅ‚ÇÇ‚ÇÉ.I‚ÇÇ‚ÇÉ).obj X‚ÇÅ).obj (CategoryTheory.GradedObject.mapBifunctorMapObj G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ.p X‚ÇÇ X‚ÇÉ)).HasMap œÅ‚ÇÇ‚ÇÉ.q\nH : CategoryTheory.GradedObject.HasGoodTrifunctor‚ÇÇ‚ÇÉObj F G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ X‚ÇÅ X‚ÇÇ X‚ÇÉ\nj : J\nA : C‚ÇÑ\nf : (i‚ÇÅ : I‚ÇÅ) ‚Üí (i‚ÇÇ : I‚ÇÇ) ‚Üí (i‚ÇÉ : I‚ÇÉ) ‚Üí Eq (r { fst := i‚ÇÅ, snd := { fst := i‚ÇÇ, snd := i‚ÇÉ } }) j ‚Üí Quiver.Hom ((F.obj (X‚ÇÅ i‚ÇÅ)).obj ((G‚ÇÇ‚ÇÉ.obj (X‚ÇÇ i‚ÇÇ)).obj (X‚ÇÉ i‚ÇÉ))) A\ni‚ÇÅ : I‚ÇÅ\ni‚ÇÇ : I‚ÇÇ\ni‚ÇÉ : I‚ÇÉ\nh : Eq (r { fst := i‚ÇÅ, snd := { fst := i‚ÇÇ, snd := i‚ÇÉ } }) j\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ŒπMapBifunctorBifunctor‚ÇÇ‚ÇÉMapObj F G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h) (CategoryTheory.GradedObject.mapBifunctorBifunctor‚ÇÇ‚ÇÉDesc f)) (f i‚ÇÅ i‚ÇÇ i‚ÇÉ h)","decl":"@[reassoc (attr := simp)]\nlemma Œπ_mapBifunctorBifunctor‚ÇÇ‚ÇÉDesc\n    (i‚ÇÅ : I‚ÇÅ) (i‚ÇÇ : I‚ÇÇ) (i‚ÇÉ : I‚ÇÉ) (h : r ‚ü®i‚ÇÅ, i‚ÇÇ, i‚ÇÉ‚ü© = j) :\n    ŒπMapBifunctorBifunctor‚ÇÇ‚ÇÉMapObj F G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h ‚â´\n      mapBifunctorBifunctor‚ÇÇ‚ÇÉDesc f = f i‚ÇÅ i‚ÇÇ i‚ÇÉ h :=\n  Cofan.IsColimit.fac\n    (isColimitCofan‚ÇÉMapBifunctorBifunctor‚ÇÇ‚ÇÉMapObj F G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ X‚ÇÅ X‚ÇÇ X‚ÇÉ j) _ ‚ü®_, h‚ü©\n\n"}
{"name":"CategoryTheory.GradedObject.Œπ_mapBifunctorBifunctor‚ÇÇ‚ÇÉDesc_assoc","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\nC‚ÇÑ : Type u_4\nC‚ÇÇ‚ÇÉ : Type u_6\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_13, u_1} C‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{u_15, u_2} C‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_14, u_3} C‚ÇÉ\ninst‚úù¬≥ : CategoryTheory.Category.{u_11, u_4} C‚ÇÑ\ninst‚úù¬≤ : CategoryTheory.Category.{u_12, u_6} C‚ÇÇ‚ÇÉ\nF : CategoryTheory.Functor C‚ÇÅ (CategoryTheory.Functor C‚ÇÇ‚ÇÉ C‚ÇÑ)\nG‚ÇÇ‚ÇÉ : CategoryTheory.Functor C‚ÇÇ (CategoryTheory.Functor C‚ÇÉ C‚ÇÇ‚ÇÉ)\nI‚ÇÅ : Type u_7\nI‚ÇÇ : Type u_8\nI‚ÇÉ : Type u_9\nJ : Type u_10\nr : Prod I‚ÇÅ (Prod I‚ÇÇ I‚ÇÉ) ‚Üí J\nœÅ‚ÇÇ‚ÇÉ : CategoryTheory.GradedObject.BifunctorComp‚ÇÇ‚ÇÉIndexData r\nX‚ÇÅ : CategoryTheory.GradedObject I‚ÇÅ C‚ÇÅ\nX‚ÇÇ : CategoryTheory.GradedObject I‚ÇÇ C‚ÇÇ\nX‚ÇÉ : CategoryTheory.GradedObject I‚ÇÉ C‚ÇÉ\ninst‚úù¬π : (((CategoryTheory.GradedObject.mapBifunctor G‚ÇÇ‚ÇÉ I‚ÇÇ I‚ÇÉ).obj X‚ÇÇ).obj X‚ÇÉ).HasMap œÅ‚ÇÇ‚ÇÉ.p\ninst‚úù : (((CategoryTheory.GradedObject.mapBifunctor F I‚ÇÅ œÅ‚ÇÇ‚ÇÉ.I‚ÇÇ‚ÇÉ).obj X‚ÇÅ).obj (CategoryTheory.GradedObject.mapBifunctorMapObj G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ.p X‚ÇÇ X‚ÇÉ)).HasMap œÅ‚ÇÇ‚ÇÉ.q\nH : CategoryTheory.GradedObject.HasGoodTrifunctor‚ÇÇ‚ÇÉObj F G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ X‚ÇÅ X‚ÇÇ X‚ÇÉ\nj : J\nA : C‚ÇÑ\nf : (i‚ÇÅ : I‚ÇÅ) ‚Üí (i‚ÇÇ : I‚ÇÇ) ‚Üí (i‚ÇÉ : I‚ÇÉ) ‚Üí Eq (r { fst := i‚ÇÅ, snd := { fst := i‚ÇÇ, snd := i‚ÇÉ } }) j ‚Üí Quiver.Hom ((F.obj (X‚ÇÅ i‚ÇÅ)).obj ((G‚ÇÇ‚ÇÉ.obj (X‚ÇÇ i‚ÇÇ)).obj (X‚ÇÉ i‚ÇÉ))) A\ni‚ÇÅ : I‚ÇÅ\ni‚ÇÇ : I‚ÇÇ\ni‚ÇÉ : I‚ÇÉ\nh‚úù : Eq (r { fst := i‚ÇÅ, snd := { fst := i‚ÇÇ, snd := i‚ÇÉ } }) j\nZ : C‚ÇÑ\nh : Quiver.Hom A Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ŒπMapBifunctorBifunctor‚ÇÇ‚ÇÉMapObj F G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h‚úù) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.mapBifunctorBifunctor‚ÇÇ‚ÇÉDesc f) h)) (CategoryTheory.CategoryStruct.comp (f i‚ÇÅ i‚ÇÇ i‚ÇÉ h‚úù) h)","decl":"@[reassoc (attr := simp)]\nlemma Œπ_mapBifunctorBifunctor‚ÇÇ‚ÇÉDesc\n    (i‚ÇÅ : I‚ÇÅ) (i‚ÇÇ : I‚ÇÇ) (i‚ÇÉ : I‚ÇÉ) (h : r ‚ü®i‚ÇÅ, i‚ÇÇ, i‚ÇÉ‚ü© = j) :\n    ŒπMapBifunctorBifunctor‚ÇÇ‚ÇÉMapObj F G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ X‚ÇÅ X‚ÇÇ X‚ÇÉ i‚ÇÅ i‚ÇÇ i‚ÇÉ j h ‚â´\n      mapBifunctorBifunctor‚ÇÇ‚ÇÉDesc f = f i‚ÇÅ i‚ÇÇ i‚ÇÉ h :=\n  Cofan.IsColimit.fac\n    (isColimitCofan‚ÇÉMapBifunctorBifunctor‚ÇÇ‚ÇÉMapObj F G‚ÇÇ‚ÇÉ œÅ‚ÇÇ‚ÇÉ X‚ÇÅ X‚ÇÇ X‚ÇÉ j) _ ‚ü®_, h‚ü©\n\n"}
