{"name":"CategoryTheory.GradedObject.mapTrifunctorObj_obj_obj","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\ninst✝³ : CategoryTheory.Category.{u_10, u_1} C₁\ninst✝² : CategoryTheory.Category.{u_11, u_2} C₂\ninst✝¹ : CategoryTheory.Category.{u_12, u_3} C₃\ninst✝ : CategoryTheory.Category.{u_13, u_4} C₄\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ (CategoryTheory.Functor C₃ C₄))\nI₁ : Type u_7\nX₁ : CategoryTheory.GradedObject I₁ C₁\nI₂ : Type u_8\nI₃ : Type u_9\nX₂ : CategoryTheory.GradedObject I₂ C₂\nX₃ : CategoryTheory.GradedObject I₃ C₃\nx : Prod I₁ (Prod I₂ I₃)\n⊢ Eq (((CategoryTheory.GradedObject.mapTrifunctorObj F X₁ I₂ I₃).obj X₂).obj X₃ x) (((F.obj (X₁ x.1)).obj (X₂ x.2.1)).obj (X₃ x.2.2))","decl":"/-- Auxiliary definition for `mapTrifunctor`. -/\n@[simps]\ndef mapTrifunctorObj {I₁ : Type*} (X₁ : GradedObject I₁ C₁) (I₂ I₃ : Type*) :\n    GradedObject I₂ C₂ ⥤ GradedObject I₃ C₃ ⥤ GradedObject (I₁ × I₂ × I₃) C₄ where\n  obj X₂ :=\n    { obj := fun X₃ x => ((F.obj (X₁ x.1)).obj (X₂ x.2.1)).obj (X₃ x.2.2)\n      map := fun {_ _} φ x => ((F.obj (X₁ x.1)).obj (X₂ x.2.1)).map (φ x.2.2) }\n  map {X₂ Y₂} φ :=\n    { app := fun X₃ x => ((F.obj (X₁ x.1)).map (φ x.2.1)).app (X₃ x.2.2) }\n\n"}
{"name":"CategoryTheory.GradedObject.mapTrifunctorObj_map_app","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\ninst✝³ : CategoryTheory.Category.{u_10, u_1} C₁\ninst✝² : CategoryTheory.Category.{u_11, u_2} C₂\ninst✝¹ : CategoryTheory.Category.{u_12, u_3} C₃\ninst✝ : CategoryTheory.Category.{u_13, u_4} C₄\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ (CategoryTheory.Functor C₃ C₄))\nI₁ : Type u_7\nX₁ : CategoryTheory.GradedObject I₁ C₁\nI₂ : Type u_8\nI₃ : Type u_9\nX₂ Y₂ : CategoryTheory.GradedObject I₂ C₂\nφ : Quiver.Hom X₂ Y₂\nX₃ : CategoryTheory.GradedObject I₃ C₃\nx : Prod I₁ (Prod I₂ I₃)\n⊢ Eq (((CategoryTheory.GradedObject.mapTrifunctorObj F X₁ I₂ I₃).map φ).app X₃ x) (((F.obj (X₁ x.1)).map (φ x.2.1)).app (X₃ x.2.2))","decl":"/-- Auxiliary definition for `mapTrifunctor`. -/\n@[simps]\ndef mapTrifunctorObj {I₁ : Type*} (X₁ : GradedObject I₁ C₁) (I₂ I₃ : Type*) :\n    GradedObject I₂ C₂ ⥤ GradedObject I₃ C₃ ⥤ GradedObject (I₁ × I₂ × I₃) C₄ where\n  obj X₂ :=\n    { obj := fun X₃ x => ((F.obj (X₁ x.1)).obj (X₂ x.2.1)).obj (X₃ x.2.2)\n      map := fun {_ _} φ x => ((F.obj (X₁ x.1)).obj (X₂ x.2.1)).map (φ x.2.2) }\n  map {X₂ Y₂} φ :=\n    { app := fun X₃ x => ((F.obj (X₁ x.1)).map (φ x.2.1)).app (X₃ x.2.2) }\n\n"}
{"name":"CategoryTheory.GradedObject.mapTrifunctorObj_obj_map","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\ninst✝³ : CategoryTheory.Category.{u_10, u_1} C₁\ninst✝² : CategoryTheory.Category.{u_11, u_2} C₂\ninst✝¹ : CategoryTheory.Category.{u_12, u_3} C₃\ninst✝ : CategoryTheory.Category.{u_13, u_4} C₄\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ (CategoryTheory.Functor C₃ C₄))\nI₁ : Type u_7\nX₁ : CategoryTheory.GradedObject I₁ C₁\nI₂ : Type u_8\nI₃ : Type u_9\nX₂ : CategoryTheory.GradedObject I₂ C₂\nx✝¹ x✝ : CategoryTheory.GradedObject I₃ C₃\nφ : Quiver.Hom x✝¹ x✝\nx : Prod I₁ (Prod I₂ I₃)\n⊢ Eq (((CategoryTheory.GradedObject.mapTrifunctorObj F X₁ I₂ I₃).obj X₂).map φ x) (((F.obj (X₁ x.1)).obj (X₂ x.2.1)).map (φ x.2.2))","decl":"/-- Auxiliary definition for `mapTrifunctor`. -/\n@[simps]\ndef mapTrifunctorObj {I₁ : Type*} (X₁ : GradedObject I₁ C₁) (I₂ I₃ : Type*) :\n    GradedObject I₂ C₂ ⥤ GradedObject I₃ C₃ ⥤ GradedObject (I₁ × I₂ × I₃) C₄ where\n  obj X₂ :=\n    { obj := fun X₃ x => ((F.obj (X₁ x.1)).obj (X₂ x.2.1)).obj (X₃ x.2.2)\n      map := fun {_ _} φ x => ((F.obj (X₁ x.1)).obj (X₂ x.2.1)).map (φ x.2.2) }\n  map {X₂ Y₂} φ :=\n    { app := fun X₃ x => ((F.obj (X₁ x.1)).map (φ x.2.1)).app (X₃ x.2.2) }\n\n"}
{"name":"CategoryTheory.GradedObject.mapTrifunctor_map_app_app","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\ninst✝³ : CategoryTheory.Category.{u_10, u_1} C₁\ninst✝² : CategoryTheory.Category.{u_11, u_2} C₂\ninst✝¹ : CategoryTheory.Category.{u_12, u_3} C₃\ninst✝ : CategoryTheory.Category.{u_13, u_4} C₄\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ (CategoryTheory.Functor C₃ C₄))\nI₁ : Type u_7\nI₂ : Type u_8\nI₃ : Type u_9\nX₁ Y₁ : CategoryTheory.GradedObject I₁ C₁\nφ : Quiver.Hom X₁ Y₁\nX₂ : CategoryTheory.GradedObject I₂ C₂\nX₃ : CategoryTheory.GradedObject I₃ C₃\nx : Prod I₁ (Prod I₂ I₃)\n⊢ Eq ((((CategoryTheory.GradedObject.mapTrifunctor F I₁ I₂ I₃).map φ).app X₂).app X₃ x) (((F.map (φ x.1)).app (X₂ x.2.1)).app (X₃ x.2.2))","decl":"/-- Given a trifunctor `F : C₁ ⥤ C₂ ⥤ C₃ ⥤ C₄` and types `I₁`, `I₂`, `I₃`,\nthis is the obvious functor\n`GradedObject I₁ C₁ ⥤ GradedObject I₂ C₂ ⥤ GradedObject I₃ C₃ ⥤ GradedObject (I₁ × I₂ × I₃) C₄`.\n-/\n@[simps]\ndef mapTrifunctor (I₁ I₂ I₃ : Type*) :\n    GradedObject I₁ C₁ ⥤ GradedObject I₂ C₂ ⥤ GradedObject I₃ C₃ ⥤\n      GradedObject (I₁ × I₂ × I₃) C₄ where\n  obj X₁ := mapTrifunctorObj F X₁ I₂ I₃\n  map {X₁ Y₁} φ :=\n    { app := fun X₂ =>\n        { app := fun X₃ x => ((F.map (φ x.1)).app (X₂ x.2.1)).app (X₃ x.2.2) }\n      naturality := fun {X₂ Y₂} ψ => by\n        ext X₃ x\n        dsimp\n        simp only [← NatTrans.comp_app]\n        congr 1\n        rw [NatTrans.naturality] }\n"}
{"name":"CategoryTheory.GradedObject.mapTrifunctor_obj","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\ninst✝³ : CategoryTheory.Category.{u_10, u_1} C₁\ninst✝² : CategoryTheory.Category.{u_11, u_2} C₂\ninst✝¹ : CategoryTheory.Category.{u_12, u_3} C₃\ninst✝ : CategoryTheory.Category.{u_13, u_4} C₄\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ (CategoryTheory.Functor C₃ C₄))\nI₁ : Type u_7\nI₂ : Type u_8\nI₃ : Type u_9\nX₁ : CategoryTheory.GradedObject I₁ C₁\n⊢ Eq ((CategoryTheory.GradedObject.mapTrifunctor F I₁ I₂ I₃).obj X₁) (CategoryTheory.GradedObject.mapTrifunctorObj F X₁ I₂ I₃)","decl":"/-- Given a trifunctor `F : C₁ ⥤ C₂ ⥤ C₃ ⥤ C₄` and types `I₁`, `I₂`, `I₃`,\nthis is the obvious functor\n`GradedObject I₁ C₁ ⥤ GradedObject I₂ C₂ ⥤ GradedObject I₃ C₃ ⥤ GradedObject (I₁ × I₂ × I₃) C₄`.\n-/\n@[simps]\ndef mapTrifunctor (I₁ I₂ I₃ : Type*) :\n    GradedObject I₁ C₁ ⥤ GradedObject I₂ C₂ ⥤ GradedObject I₃ C₃ ⥤\n      GradedObject (I₁ × I₂ × I₃) C₄ where\n  obj X₁ := mapTrifunctorObj F X₁ I₂ I₃\n  map {X₁ Y₁} φ :=\n    { app := fun X₂ =>\n        { app := fun X₃ x => ((F.map (φ x.1)).app (X₂ x.2.1)).app (X₃ x.2.2) }\n      naturality := fun {X₂ Y₂} ψ => by\n        ext X₃ x\n        dsimp\n        simp only [← NatTrans.comp_app]\n        congr 1\n        rw [NatTrans.naturality] }\n"}
{"name":"CategoryTheory.GradedObject.mapTrifunctorMapNatTrans_app_app_app","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\ninst✝³ : CategoryTheory.Category.{u_10, u_1} C₁\ninst✝² : CategoryTheory.Category.{u_11, u_2} C₂\ninst✝¹ : CategoryTheory.Category.{u_12, u_3} C₃\ninst✝ : CategoryTheory.Category.{u_13, u_4} C₄\nF F' : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ (CategoryTheory.Functor C₃ C₄))\nα : Quiver.Hom F F'\nI₁ : Type u_7\nI₂ : Type u_8\nI₃ : Type u_9\nX₁ : CategoryTheory.GradedObject I₁ C₁\nX₂ : CategoryTheory.GradedObject I₂ C₂\nx✝¹ : CategoryTheory.GradedObject I₃ C₃\nx✝ : Prod I₁ (Prod I₂ I₃)\n⊢ Eq ((((CategoryTheory.GradedObject.mapTrifunctorMapNatTrans α I₁ I₂ I₃).app X₁).app X₂).app x✝¹ x✝) (((α.app (X₁ x✝.1)).app (X₂ x✝.2.1)).app (x✝¹ x✝.2.2))","decl":"/-- The natural transformation `mapTrifunctor F I₁ I₂ I₃ ⟶ mapTrifunctor F' I₁ I₂ I₃`\ninduced by a natural transformation `F ⟶ F` of trifunctors. -/\n@[simps]\ndef mapTrifunctorMapNatTrans (α : F ⟶ F') (I₁ I₂ I₃ : Type*) :\n    mapTrifunctor F I₁ I₂ I₃ ⟶ mapTrifunctor F' I₁ I₂ I₃ where\n  app X₁ :=\n    { app := fun X₂ =>\n        { app := fun _ _ => ((α.app _).app _).app _ }\n      naturality := fun {X₂ Y₂} φ => by\n        ext X₃ ⟨i₁, i₂, i₃⟩\n        dsimp\n        simp only [← NatTrans.comp_app, NatTrans.naturality] }\n  naturality := fun {X₁ Y₁} φ => by\n    ext X₂ X₃ ⟨i₁, i₂, i₃⟩\n    dsimp\n    simp only [← NatTrans.comp_app, NatTrans.naturality]\n\n"}
{"name":"CategoryTheory.GradedObject.mapTrifunctorMapIso_inv","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\ninst✝³ : CategoryTheory.Category.{u_10, u_1} C₁\ninst✝² : CategoryTheory.Category.{u_11, u_2} C₂\ninst✝¹ : CategoryTheory.Category.{u_12, u_3} C₃\ninst✝ : CategoryTheory.Category.{u_13, u_4} C₄\nF F' : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ (CategoryTheory.Functor C₃ C₄))\ne : CategoryTheory.Iso F F'\nI₁ : Type u_7\nI₂ : Type u_8\nI₃ : Type u_9\n⊢ Eq (CategoryTheory.GradedObject.mapTrifunctorMapIso e I₁ I₂ I₃).inv (CategoryTheory.GradedObject.mapTrifunctorMapNatTrans e.inv I₁ I₂ I₃)","decl":"/-- The natural isomorphism `mapTrifunctor F I₁ I₂ I₃ ≅ mapTrifunctor F' I₁ I₂ I₃`\ninduced by a natural isomorphism `F ≅ F` of trifunctors. -/\n@[simps]\ndef mapTrifunctorMapIso (e : F ≅ F') (I₁ I₂ I₃ : Type*) :\n    mapTrifunctor F I₁ I₂ I₃ ≅ mapTrifunctor F' I₁ I₂ I₃ where\n  hom := mapTrifunctorMapNatTrans e.hom I₁ I₂ I₃\n  inv := mapTrifunctorMapNatTrans e.inv I₁ I₂ I₃\n  hom_inv_id := by\n    ext X₁ X₂ X₃ ⟨i₁, i₂, i₃⟩\n    dsimp\n    simp only [← NatTrans.comp_app, e.hom_inv_id, NatTrans.id_app]\n  inv_hom_id := by\n    ext X₁ X₂ X₃ ⟨i₁, i₂, i₃⟩\n    dsimp\n    simp only [← NatTrans.comp_app, e.inv_hom_id, NatTrans.id_app]\n\n"}
{"name":"CategoryTheory.GradedObject.mapTrifunctorMapIso_hom","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\ninst✝³ : CategoryTheory.Category.{u_10, u_1} C₁\ninst✝² : CategoryTheory.Category.{u_11, u_2} C₂\ninst✝¹ : CategoryTheory.Category.{u_12, u_3} C₃\ninst✝ : CategoryTheory.Category.{u_13, u_4} C₄\nF F' : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ (CategoryTheory.Functor C₃ C₄))\ne : CategoryTheory.Iso F F'\nI₁ : Type u_7\nI₂ : Type u_8\nI₃ : Type u_9\n⊢ Eq (CategoryTheory.GradedObject.mapTrifunctorMapIso e I₁ I₂ I₃).hom (CategoryTheory.GradedObject.mapTrifunctorMapNatTrans e.hom I₁ I₂ I₃)","decl":"/-- The natural isomorphism `mapTrifunctor F I₁ I₂ I₃ ≅ mapTrifunctor F' I₁ I₂ I₃`\ninduced by a natural isomorphism `F ≅ F` of trifunctors. -/\n@[simps]\ndef mapTrifunctorMapIso (e : F ≅ F') (I₁ I₂ I₃ : Type*) :\n    mapTrifunctor F I₁ I₂ I₃ ≅ mapTrifunctor F' I₁ I₂ I₃ where\n  hom := mapTrifunctorMapNatTrans e.hom I₁ I₂ I₃\n  inv := mapTrifunctorMapNatTrans e.inv I₁ I₂ I₃\n  hom_inv_id := by\n    ext X₁ X₂ X₃ ⟨i₁, i₂, i₃⟩\n    dsimp\n    simp only [← NatTrans.comp_app, e.hom_inv_id, NatTrans.id_app]\n  inv_hom_id := by\n    ext X₁ X₂ X₃ ⟨i₁, i₂, i₃⟩\n    dsimp\n    simp only [← NatTrans.comp_app, e.inv_hom_id, NatTrans.id_app]\n\n"}
{"name":"CategoryTheory.GradedObject.ι_mapTrifunctorMapMap_assoc","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\ninst✝⁵ : CategoryTheory.Category.{u_11, u_1} C₁\ninst✝⁴ : CategoryTheory.Category.{u_12, u_2} C₂\ninst✝³ : CategoryTheory.Category.{u_13, u_3} C₃\ninst✝² : CategoryTheory.Category.{u_14, u_4} C₄\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ (CategoryTheory.Functor C₃ C₄))\nI₁ : Type u_7\nI₂ : Type u_8\nI₃ : Type u_9\nJ : Type u_10\np : Prod I₁ (Prod I₂ I₃) → J\nX₁ Y₁ : CategoryTheory.GradedObject I₁ C₁\nf₁ : Quiver.Hom X₁ Y₁\nX₂ Y₂ : CategoryTheory.GradedObject I₂ C₂\nf₂ : Quiver.Hom X₂ Y₂\nX₃ Y₃ : CategoryTheory.GradedObject I₃ C₃\nf₃ : Quiver.Hom X₃ Y₃\ninst✝¹ : ((((CategoryTheory.GradedObject.mapTrifunctor F I₁ I₂ I₃).obj X₁).obj X₂).obj X₃).HasMap p\ninst✝ : ((((CategoryTheory.GradedObject.mapTrifunctor F I₁ I₂ I₃).obj Y₁).obj Y₂).obj Y₃).HasMap p\ni₁ : I₁\ni₂ : I₂\ni₃ : I₃\nj : J\nh✝ : Eq (p { fst := i₁, snd := { fst := i₂, snd := i₃ } }) j\nZ : C₄\nh : Quiver.Hom (CategoryTheory.GradedObject.mapTrifunctorMapObj F p Y₁ Y₂ Y₃ j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ιMapTrifunctorMapObj F p X₁ X₂ X₃ i₁ i₂ i₃ j h✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.mapTrifunctorMapMap F p f₁ f₂ f₃ j) h)) (CategoryTheory.CategoryStruct.comp (((F.map (f₁ i₁)).app (X₂ i₂)).app (X₃ i₃)) (CategoryTheory.CategoryStruct.comp (((F.obj (Y₁ i₁)).map (f₂ i₂)).app (X₃ i₃)) (CategoryTheory.CategoryStruct.comp (((F.obj (Y₁ i₁)).obj (Y₂ i₂)).map (f₃ i₃)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ιMapTrifunctorMapObj F p Y₁ Y₂ Y₃ i₁ i₂ i₃ j h✝) h))))","decl":"@[reassoc (attr := simp)]\nlemma ι_mapTrifunctorMapMap {X₁ Y₁ : GradedObject I₁ C₁} (f₁ : X₁ ⟶ Y₁)\n    {X₂ Y₂ : GradedObject I₂ C₂} (f₂ : X₂ ⟶ Y₂)\n    {X₃ Y₃ : GradedObject I₃ C₃} (f₃ : X₃ ⟶ Y₃)\n    [HasMap ((((mapTrifunctor F I₁ I₂ I₃).obj X₁).obj X₂).obj X₃) p]\n    [HasMap ((((mapTrifunctor F I₁ I₂ I₃).obj Y₁).obj Y₂).obj Y₃) p]\n    (i₁ : I₁) (i₂ : I₂) (i₃ : I₃) (j : J) (h : p ⟨i₁, i₂, i₃⟩ = j) :\n  ιMapTrifunctorMapObj F p X₁ X₂ X₃ i₁ i₂ i₃ j h ≫ mapTrifunctorMapMap F p f₁ f₂ f₃ j =\n    ((F.map (f₁ i₁)).app (X₂ i₂)).app (X₃ i₃) ≫\n      ((F.obj (Y₁ i₁)).map (f₂ i₂)).app (X₃ i₃) ≫\n      ((F.obj (Y₁ i₁)).obj (Y₂ i₂)).map (f₃ i₃) ≫\n      ιMapTrifunctorMapObj F p Y₁ Y₂ Y₃ i₁ i₂ i₃ j h := by\n  dsimp only [ιMapTrifunctorMapObj, mapTrifunctorMapMap]\n  rw [ι_mapMap]\n  dsimp\n  rw [assoc, assoc]\n\n"}
{"name":"CategoryTheory.GradedObject.ι_mapTrifunctorMapMap","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\ninst✝⁵ : CategoryTheory.Category.{u_11, u_1} C₁\ninst✝⁴ : CategoryTheory.Category.{u_12, u_2} C₂\ninst✝³ : CategoryTheory.Category.{u_13, u_3} C₃\ninst✝² : CategoryTheory.Category.{u_14, u_4} C₄\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ (CategoryTheory.Functor C₃ C₄))\nI₁ : Type u_7\nI₂ : Type u_8\nI₃ : Type u_9\nJ : Type u_10\np : Prod I₁ (Prod I₂ I₃) → J\nX₁ Y₁ : CategoryTheory.GradedObject I₁ C₁\nf₁ : Quiver.Hom X₁ Y₁\nX₂ Y₂ : CategoryTheory.GradedObject I₂ C₂\nf₂ : Quiver.Hom X₂ Y₂\nX₃ Y₃ : CategoryTheory.GradedObject I₃ C₃\nf₃ : Quiver.Hom X₃ Y₃\ninst✝¹ : ((((CategoryTheory.GradedObject.mapTrifunctor F I₁ I₂ I₃).obj X₁).obj X₂).obj X₃).HasMap p\ninst✝ : ((((CategoryTheory.GradedObject.mapTrifunctor F I₁ I₂ I₃).obj Y₁).obj Y₂).obj Y₃).HasMap p\ni₁ : I₁\ni₂ : I₂\ni₃ : I₃\nj : J\nh : Eq (p { fst := i₁, snd := { fst := i₂, snd := i₃ } }) j\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ιMapTrifunctorMapObj F p X₁ X₂ X₃ i₁ i₂ i₃ j h) (CategoryTheory.GradedObject.mapTrifunctorMapMap F p f₁ f₂ f₃ j)) (CategoryTheory.CategoryStruct.comp (((F.map (f₁ i₁)).app (X₂ i₂)).app (X₃ i₃)) (CategoryTheory.CategoryStruct.comp (((F.obj (Y₁ i₁)).map (f₂ i₂)).app (X₃ i₃)) (CategoryTheory.CategoryStruct.comp (((F.obj (Y₁ i₁)).obj (Y₂ i₂)).map (f₃ i₃)) (CategoryTheory.GradedObject.ιMapTrifunctorMapObj F p Y₁ Y₂ Y₃ i₁ i₂ i₃ j h))))","decl":"@[reassoc (attr := simp)]\nlemma ι_mapTrifunctorMapMap {X₁ Y₁ : GradedObject I₁ C₁} (f₁ : X₁ ⟶ Y₁)\n    {X₂ Y₂ : GradedObject I₂ C₂} (f₂ : X₂ ⟶ Y₂)\n    {X₃ Y₃ : GradedObject I₃ C₃} (f₃ : X₃ ⟶ Y₃)\n    [HasMap ((((mapTrifunctor F I₁ I₂ I₃).obj X₁).obj X₂).obj X₃) p]\n    [HasMap ((((mapTrifunctor F I₁ I₂ I₃).obj Y₁).obj Y₂).obj Y₃) p]\n    (i₁ : I₁) (i₂ : I₂) (i₃ : I₃) (j : J) (h : p ⟨i₁, i₂, i₃⟩ = j) :\n  ιMapTrifunctorMapObj F p X₁ X₂ X₃ i₁ i₂ i₃ j h ≫ mapTrifunctorMapMap F p f₁ f₂ f₃ j =\n    ((F.map (f₁ i₁)).app (X₂ i₂)).app (X₃ i₃) ≫\n      ((F.obj (Y₁ i₁)).map (f₂ i₂)).app (X₃ i₃) ≫\n      ((F.obj (Y₁ i₁)).obj (Y₂ i₂)).map (f₃ i₃) ≫\n      ιMapTrifunctorMapObj F p Y₁ Y₂ Y₃ i₁ i₂ i₃ j h := by\n  dsimp only [ιMapTrifunctorMapObj, mapTrifunctorMapMap]\n  rw [ι_mapMap]\n  dsimp\n  rw [assoc, assoc]\n\n"}
{"name":"CategoryTheory.GradedObject.mapTrifunctorMapObj_ext","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\ninst✝⁴ : CategoryTheory.Category.{u_14, u_1} C₁\ninst✝³ : CategoryTheory.Category.{u_13, u_2} C₂\ninst✝² : CategoryTheory.Category.{u_12, u_3} C₃\ninst✝¹ : CategoryTheory.Category.{u_11, u_4} C₄\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ (CategoryTheory.Functor C₃ C₄))\nI₁ : Type u_7\nI₂ : Type u_8\nI₃ : Type u_9\nJ : Type u_10\np : Prod I₁ (Prod I₂ I₃) → J\nX₁ : CategoryTheory.GradedObject I₁ C₁\nX₂ : CategoryTheory.GradedObject I₂ C₂\nX₃ : CategoryTheory.GradedObject I₃ C₃\nY : C₄\nj : J\ninst✝ : ((((CategoryTheory.GradedObject.mapTrifunctor F I₁ I₂ I₃).obj X₁).obj X₂).obj X₃).HasMap p\nφ φ' : Quiver.Hom (CategoryTheory.GradedObject.mapTrifunctorMapObj F p X₁ X₂ X₃ j) Y\nh : ∀ (i₁ : I₁) (i₂ : I₂) (i₃ : I₃) (h : Eq (p { fst := i₁, snd := { fst := i₂, snd := i₃ } }) j), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ιMapTrifunctorMapObj F p X₁ X₂ X₃ i₁ i₂ i₃ j h) φ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ιMapTrifunctorMapObj F p X₁ X₂ X₃ i₁ i₂ i₃ j h) φ')\n⊢ Eq φ φ'","decl":"@[ext]\nlemma mapTrifunctorMapObj_ext {X₁ : GradedObject I₁ C₁} {X₂ : GradedObject I₂ C₂}\n    {X₃ : GradedObject I₃ C₃} {Y : C₄} (j : J)\n    [HasMap ((((mapTrifunctor F I₁ I₂ I₃).obj X₁).obj X₂).obj X₃) p]\n    {φ φ' : mapTrifunctorMapObj F p X₁ X₂ X₃ j ⟶ Y}\n    (h : ∀ (i₁ : I₁) (i₂ : I₂) (i₃ : I₃) (h : p ⟨i₁, i₂, i₃⟩ = j),\n      ιMapTrifunctorMapObj F p X₁ X₂ X₃ i₁ i₂ i₃ j h ≫ φ =\n        ιMapTrifunctorMapObj F p X₁ X₂ X₃ i₁ i₂ i₃ j h ≫ φ') : φ = φ' := by\n  apply mapObj_ext\n  rintro ⟨i₁, i₂, i₃⟩ hi\n  apply h\n\n"}
{"name":"CategoryTheory.GradedObject.mapTrifunctorMapObj_ext_iff","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\ninst✝⁴ : CategoryTheory.Category.{u_14, u_1} C₁\ninst✝³ : CategoryTheory.Category.{u_13, u_2} C₂\ninst✝² : CategoryTheory.Category.{u_12, u_3} C₃\ninst✝¹ : CategoryTheory.Category.{u_11, u_4} C₄\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ (CategoryTheory.Functor C₃ C₄))\nI₁ : Type u_7\nI₂ : Type u_8\nI₃ : Type u_9\nJ : Type u_10\np : Prod I₁ (Prod I₂ I₃) → J\nX₁ : CategoryTheory.GradedObject I₁ C₁\nX₂ : CategoryTheory.GradedObject I₂ C₂\nX₃ : CategoryTheory.GradedObject I₃ C₃\nY : C₄\nj : J\ninst✝ : ((((CategoryTheory.GradedObject.mapTrifunctor F I₁ I₂ I₃).obj X₁).obj X₂).obj X₃).HasMap p\nφ φ' : Quiver.Hom (CategoryTheory.GradedObject.mapTrifunctorMapObj F p X₁ X₂ X₃ j) Y\n⊢ Iff (Eq φ φ') (∀ (i₁ : I₁) (i₂ : I₂) (i₃ : I₃) (h : Eq (p { fst := i₁, snd := { fst := i₂, snd := i₃ } }) j), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ιMapTrifunctorMapObj F p X₁ X₂ X₃ i₁ i₂ i₃ j h) φ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ιMapTrifunctorMapObj F p X₁ X₂ X₃ i₁ i₂ i₃ j h) φ'))","decl":"@[ext]\nlemma mapTrifunctorMapObj_ext {X₁ : GradedObject I₁ C₁} {X₂ : GradedObject I₂ C₂}\n    {X₃ : GradedObject I₃ C₃} {Y : C₄} (j : J)\n    [HasMap ((((mapTrifunctor F I₁ I₂ I₃).obj X₁).obj X₂).obj X₃) p]\n    {φ φ' : mapTrifunctorMapObj F p X₁ X₂ X₃ j ⟶ Y}\n    (h : ∀ (i₁ : I₁) (i₂ : I₂) (i₃ : I₃) (h : p ⟨i₁, i₂, i₃⟩ = j),\n      ιMapTrifunctorMapObj F p X₁ X₂ X₃ i₁ i₂ i₃ j h ≫ φ =\n        ιMapTrifunctorMapObj F p X₁ X₂ X₃ i₁ i₂ i₃ j h ≫ φ') : φ = φ' := by\n  apply mapObj_ext\n  rintro ⟨i₁, i₂, i₃⟩ hi\n  apply h\n\n"}
{"name":"CategoryTheory.GradedObject.instHasMapProdObjFunctorMapTrifunctorObjOfMapTrifunctor","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\ninst✝³ : CategoryTheory.Category.{u_14, u_1} C₁\ninst✝² : CategoryTheory.Category.{u_13, u_2} C₂\ninst✝¹ : CategoryTheory.Category.{u_12, u_3} C₃\ninst✝ : CategoryTheory.Category.{u_11, u_4} C₄\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ (CategoryTheory.Functor C₃ C₄))\nI₁ : Type u_7\nI₂ : Type u_8\nI₃ : Type u_9\nJ : Type u_10\np : Prod I₁ (Prod I₂ I₃) → J\nX₁ : CategoryTheory.GradedObject I₁ C₁\nX₂ : CategoryTheory.GradedObject I₂ C₂\nX₃ : CategoryTheory.GradedObject I₃ C₃\nh : ((((CategoryTheory.GradedObject.mapTrifunctor F I₁ I₂ I₃).obj X₁).obj X₂).obj X₃).HasMap p\n⊢ (((CategoryTheory.GradedObject.mapTrifunctorObj F X₁ I₂ I₃).obj X₂).obj X₃).HasMap p","decl":"instance (X₁ : GradedObject I₁ C₁) (X₂ : GradedObject I₂ C₂) (X₃ : GradedObject I₃ C₃)\n  [h : HasMap ((((mapTrifunctor F I₁ I₂ I₃).obj X₁).obj X₂).obj X₃) p] :\n      HasMap (((mapTrifunctorObj F X₁ I₂ I₃).obj X₂).obj X₃) p := h\n\n"}
{"name":"CategoryTheory.GradedObject.mapTrifunctorMapFunctorObj_obj_map","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\ninst✝⁴ : CategoryTheory.Category.{u_11, u_1} C₁\ninst✝³ : CategoryTheory.Category.{u_12, u_2} C₂\ninst✝² : CategoryTheory.Category.{u_13, u_3} C₃\ninst✝¹ : CategoryTheory.Category.{u_14, u_4} C₄\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ (CategoryTheory.Functor C₃ C₄))\nI₁ : Type u_7\nI₂ : Type u_8\nI₃ : Type u_9\nJ : Type u_10\np : Prod I₁ (Prod I₂ I₃) → J\nX₁ : CategoryTheory.GradedObject I₁ C₁\ninst✝ : ∀ (X₂ : CategoryTheory.GradedObject I₂ C₂) (X₃ : CategoryTheory.GradedObject I₃ C₃), ((((CategoryTheory.GradedObject.mapTrifunctor F I₁ I₂ I₃).obj X₁).obj X₂).obj X₃).HasMap p\nX₂ : CategoryTheory.GradedObject I₂ C₂\nx✝¹ x✝ : CategoryTheory.GradedObject I₃ C₃\nφ : Quiver.Hom x✝¹ x✝\ni : J\n⊢ Eq (((CategoryTheory.GradedObject.mapTrifunctorMapFunctorObj F p X₁).obj X₂).map φ i) (CategoryTheory.GradedObject.mapTrifunctorMapMap F p (CategoryTheory.CategoryStruct.id X₁) (CategoryTheory.CategoryStruct.id X₂) φ i)","decl":"/-- Given a trifunctor `F : C₁ ⥤ C₂ ⥤ C₃ ⥤ C₄`, a map `p : I₁ × I₂ × I₃ → J`, and\ngraded objects `X₁ : GradedObject I₁ C₁`, `X₂ : GradedObject I₂ C₂` and `X₃ : GradedObject I₃ C₃`,\nthis is the `J`-graded object sending `j` to the coproduct of\n`((F.obj (X₁ i₁)).obj (X₂ i₂)).obj (X₃ i₃)` for `p ⟨i₁, i₂, i₃⟩ = j`. -/\n@[simps]\nnoncomputable def mapTrifunctorMapFunctorObj (X₁ : GradedObject I₁ C₁)\n    [∀ X₂ X₃, HasMap ((((mapTrifunctor F I₁ I₂ I₃).obj X₁).obj X₂).obj X₃) p] :\n    GradedObject I₂ C₂ ⥤ GradedObject I₃ C₃ ⥤ GradedObject J C₄ where\n  obj X₂ :=\n    { obj := fun X₃ => mapTrifunctorMapObj F p X₁ X₂ X₃\n      map := fun {_ _} φ => mapTrifunctorMapMap F p (𝟙 X₁) (𝟙 X₂) φ\n      map_id := fun X₃ => by\n        dsimp\n        ext j i₁ i₂ i₃ h\n        simp only [ι_mapTrifunctorMapMap, categoryOfGradedObjects_id, Functor.map_id,\n          NatTrans.id_app, id_comp, comp_id]\n      map_comp := fun {X₃ Y₃ Z₃} φ ψ => by\n        dsimp\n        ext j i₁ i₂ i₃ h\n        simp only [ι_mapTrifunctorMapMap, categoryOfGradedObjects_id, Functor.map_id,\n          NatTrans.id_app, categoryOfGradedObjects_comp, Functor.map_comp, assoc, id_comp,\n          ι_mapTrifunctorMapMap_assoc] }\n  map {X₂ Y₂} φ :=\n    { app := fun X₃ => mapTrifunctorMapMap F p (𝟙 X₁) φ (𝟙 X₃)\n      naturality := fun {X₃ Y₃} ψ => by\n        ext j i₁ i₂ i₃ h\n        dsimp\n        simp only [ι_mapTrifunctorMapMap_assoc, categoryOfGradedObjects_id, Functor.map_id,\n          NatTrans.id_app, ι_mapTrifunctorMapMap, id_comp, NatTrans.naturality_assoc] }\n  map_id X₂ := by\n    dsimp\n    ext X₃ j i₁ i₂ i₃ h\n    simp only [ι_mapTrifunctorMapMap, categoryOfGradedObjects_id, Functor.map_id,\n      NatTrans.id_app, id_comp, comp_id]\n  map_comp {X₂ Y₂ Z₂} φ ψ := by\n    dsimp\n    ext X₃ j i₁ i₂ i₃\n    simp only [ι_mapTrifunctorMapMap, categoryOfGradedObjects_id, Functor.map_id,\n      NatTrans.id_app, categoryOfGradedObjects_comp, Functor.map_comp, NatTrans.comp_app,\n      id_comp, assoc, ι_mapTrifunctorMapMap_assoc]\n\n"}
{"name":"CategoryTheory.GradedObject.mapTrifunctorMapFunctorObj_obj_obj","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\ninst✝⁴ : CategoryTheory.Category.{u_11, u_1} C₁\ninst✝³ : CategoryTheory.Category.{u_12, u_2} C₂\ninst✝² : CategoryTheory.Category.{u_13, u_3} C₃\ninst✝¹ : CategoryTheory.Category.{u_14, u_4} C₄\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ (CategoryTheory.Functor C₃ C₄))\nI₁ : Type u_7\nI₂ : Type u_8\nI₃ : Type u_9\nJ : Type u_10\np : Prod I₁ (Prod I₂ I₃) → J\nX₁ : CategoryTheory.GradedObject I₁ C₁\ninst✝ : ∀ (X₂ : CategoryTheory.GradedObject I₂ C₂) (X₃ : CategoryTheory.GradedObject I₃ C₃), ((((CategoryTheory.GradedObject.mapTrifunctor F I₁ I₂ I₃).obj X₁).obj X₂).obj X₃).HasMap p\nX₂ : CategoryTheory.GradedObject I₂ C₂\nX₃ : CategoryTheory.GradedObject I₃ C₃\n⊢ Eq (((CategoryTheory.GradedObject.mapTrifunctorMapFunctorObj F p X₁).obj X₂).obj X₃) (CategoryTheory.GradedObject.mapTrifunctorMapObj F p X₁ X₂ X₃)","decl":"/-- Given a trifunctor `F : C₁ ⥤ C₂ ⥤ C₃ ⥤ C₄`, a map `p : I₁ × I₂ × I₃ → J`, and\ngraded objects `X₁ : GradedObject I₁ C₁`, `X₂ : GradedObject I₂ C₂` and `X₃ : GradedObject I₃ C₃`,\nthis is the `J`-graded object sending `j` to the coproduct of\n`((F.obj (X₁ i₁)).obj (X₂ i₂)).obj (X₃ i₃)` for `p ⟨i₁, i₂, i₃⟩ = j`. -/\n@[simps]\nnoncomputable def mapTrifunctorMapFunctorObj (X₁ : GradedObject I₁ C₁)\n    [∀ X₂ X₃, HasMap ((((mapTrifunctor F I₁ I₂ I₃).obj X₁).obj X₂).obj X₃) p] :\n    GradedObject I₂ C₂ ⥤ GradedObject I₃ C₃ ⥤ GradedObject J C₄ where\n  obj X₂ :=\n    { obj := fun X₃ => mapTrifunctorMapObj F p X₁ X₂ X₃\n      map := fun {_ _} φ => mapTrifunctorMapMap F p (𝟙 X₁) (𝟙 X₂) φ\n      map_id := fun X₃ => by\n        dsimp\n        ext j i₁ i₂ i₃ h\n        simp only [ι_mapTrifunctorMapMap, categoryOfGradedObjects_id, Functor.map_id,\n          NatTrans.id_app, id_comp, comp_id]\n      map_comp := fun {X₃ Y₃ Z₃} φ ψ => by\n        dsimp\n        ext j i₁ i₂ i₃ h\n        simp only [ι_mapTrifunctorMapMap, categoryOfGradedObjects_id, Functor.map_id,\n          NatTrans.id_app, categoryOfGradedObjects_comp, Functor.map_comp, assoc, id_comp,\n          ι_mapTrifunctorMapMap_assoc] }\n  map {X₂ Y₂} φ :=\n    { app := fun X₃ => mapTrifunctorMapMap F p (𝟙 X₁) φ (𝟙 X₃)\n      naturality := fun {X₃ Y₃} ψ => by\n        ext j i₁ i₂ i₃ h\n        dsimp\n        simp only [ι_mapTrifunctorMapMap_assoc, categoryOfGradedObjects_id, Functor.map_id,\n          NatTrans.id_app, ι_mapTrifunctorMapMap, id_comp, NatTrans.naturality_assoc] }\n  map_id X₂ := by\n    dsimp\n    ext X₃ j i₁ i₂ i₃ h\n    simp only [ι_mapTrifunctorMapMap, categoryOfGradedObjects_id, Functor.map_id,\n      NatTrans.id_app, id_comp, comp_id]\n  map_comp {X₂ Y₂ Z₂} φ ψ := by\n    dsimp\n    ext X₃ j i₁ i₂ i₃\n    simp only [ι_mapTrifunctorMapMap, categoryOfGradedObjects_id, Functor.map_id,\n      NatTrans.id_app, categoryOfGradedObjects_comp, Functor.map_comp, NatTrans.comp_app,\n      id_comp, assoc, ι_mapTrifunctorMapMap_assoc]\n\n"}
{"name":"CategoryTheory.GradedObject.mapTrifunctorMapFunctorObj_map_app","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\ninst✝⁴ : CategoryTheory.Category.{u_11, u_1} C₁\ninst✝³ : CategoryTheory.Category.{u_12, u_2} C₂\ninst✝² : CategoryTheory.Category.{u_13, u_3} C₃\ninst✝¹ : CategoryTheory.Category.{u_14, u_4} C₄\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ (CategoryTheory.Functor C₃ C₄))\nI₁ : Type u_7\nI₂ : Type u_8\nI₃ : Type u_9\nJ : Type u_10\np : Prod I₁ (Prod I₂ I₃) → J\nX₁ : CategoryTheory.GradedObject I₁ C₁\ninst✝ : ∀ (X₂ : CategoryTheory.GradedObject I₂ C₂) (X₃ : CategoryTheory.GradedObject I₃ C₃), ((((CategoryTheory.GradedObject.mapTrifunctor F I₁ I₂ I₃).obj X₁).obj X₂).obj X₃).HasMap p\nX₂ Y₂ : CategoryTheory.GradedObject I₂ C₂\nφ : Quiver.Hom X₂ Y₂\nX₃ : CategoryTheory.GradedObject I₃ C₃\ni : J\n⊢ Eq (((CategoryTheory.GradedObject.mapTrifunctorMapFunctorObj F p X₁).map φ).app X₃ i) (CategoryTheory.GradedObject.mapTrifunctorMapMap F p (CategoryTheory.CategoryStruct.id X₁) φ (CategoryTheory.CategoryStruct.id X₃) i)","decl":"/-- Given a trifunctor `F : C₁ ⥤ C₂ ⥤ C₃ ⥤ C₄`, a map `p : I₁ × I₂ × I₃ → J`, and\ngraded objects `X₁ : GradedObject I₁ C₁`, `X₂ : GradedObject I₂ C₂` and `X₃ : GradedObject I₃ C₃`,\nthis is the `J`-graded object sending `j` to the coproduct of\n`((F.obj (X₁ i₁)).obj (X₂ i₂)).obj (X₃ i₃)` for `p ⟨i₁, i₂, i₃⟩ = j`. -/\n@[simps]\nnoncomputable def mapTrifunctorMapFunctorObj (X₁ : GradedObject I₁ C₁)\n    [∀ X₂ X₃, HasMap ((((mapTrifunctor F I₁ I₂ I₃).obj X₁).obj X₂).obj X₃) p] :\n    GradedObject I₂ C₂ ⥤ GradedObject I₃ C₃ ⥤ GradedObject J C₄ where\n  obj X₂ :=\n    { obj := fun X₃ => mapTrifunctorMapObj F p X₁ X₂ X₃\n      map := fun {_ _} φ => mapTrifunctorMapMap F p (𝟙 X₁) (𝟙 X₂) φ\n      map_id := fun X₃ => by\n        dsimp\n        ext j i₁ i₂ i₃ h\n        simp only [ι_mapTrifunctorMapMap, categoryOfGradedObjects_id, Functor.map_id,\n          NatTrans.id_app, id_comp, comp_id]\n      map_comp := fun {X₃ Y₃ Z₃} φ ψ => by\n        dsimp\n        ext j i₁ i₂ i₃ h\n        simp only [ι_mapTrifunctorMapMap, categoryOfGradedObjects_id, Functor.map_id,\n          NatTrans.id_app, categoryOfGradedObjects_comp, Functor.map_comp, assoc, id_comp,\n          ι_mapTrifunctorMapMap_assoc] }\n  map {X₂ Y₂} φ :=\n    { app := fun X₃ => mapTrifunctorMapMap F p (𝟙 X₁) φ (𝟙 X₃)\n      naturality := fun {X₃ Y₃} ψ => by\n        ext j i₁ i₂ i₃ h\n        dsimp\n        simp only [ι_mapTrifunctorMapMap_assoc, categoryOfGradedObjects_id, Functor.map_id,\n          NatTrans.id_app, ι_mapTrifunctorMapMap, id_comp, NatTrans.naturality_assoc] }\n  map_id X₂ := by\n    dsimp\n    ext X₃ j i₁ i₂ i₃ h\n    simp only [ι_mapTrifunctorMapMap, categoryOfGradedObjects_id, Functor.map_id,\n      NatTrans.id_app, id_comp, comp_id]\n  map_comp {X₂ Y₂ Z₂} φ ψ := by\n    dsimp\n    ext X₃ j i₁ i₂ i₃\n    simp only [ι_mapTrifunctorMapMap, categoryOfGradedObjects_id, Functor.map_id,\n      NatTrans.id_app, categoryOfGradedObjects_comp, Functor.map_comp, NatTrans.comp_app,\n      id_comp, assoc, ι_mapTrifunctorMapMap_assoc]\n\n"}
{"name":"CategoryTheory.GradedObject.mapTrifunctorMap_map_app_app","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\ninst✝⁴ : CategoryTheory.Category.{u_11, u_1} C₁\ninst✝³ : CategoryTheory.Category.{u_12, u_2} C₂\ninst✝² : CategoryTheory.Category.{u_13, u_3} C₃\ninst✝¹ : CategoryTheory.Category.{u_14, u_4} C₄\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ (CategoryTheory.Functor C₃ C₄))\nI₁ : Type u_7\nI₂ : Type u_8\nI₃ : Type u_9\nJ : Type u_10\np : Prod I₁ (Prod I₂ I₃) → J\ninst✝ : ∀ (X₁ : CategoryTheory.GradedObject I₁ C₁) (X₂ : CategoryTheory.GradedObject I₂ C₂) (X₃ : CategoryTheory.GradedObject I₃ C₃), ((((CategoryTheory.GradedObject.mapTrifunctor F I₁ I₂ I₃).obj X₁).obj X₂).obj X₃).HasMap p\nX₁ Y₁ : CategoryTheory.GradedObject I₁ C₁\nφ : Quiver.Hom X₁ Y₁\nX₂ : CategoryTheory.GradedObject I₂ C₂\nX₃ : CategoryTheory.GradedObject I₃ C₃\ni : J\n⊢ Eq ((((CategoryTheory.GradedObject.mapTrifunctorMap F p).map φ).app X₂).app X₃ i) (CategoryTheory.GradedObject.mapTrifunctorMapMap F p φ (CategoryTheory.CategoryStruct.id X₂) (CategoryTheory.CategoryStruct.id X₃) i)","decl":"attribute [simps] mapTrifunctorMap\n\n"}
{"name":"CategoryTheory.GradedObject.mapTrifunctorMap_obj","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\ninst✝⁴ : CategoryTheory.Category.{u_11, u_1} C₁\ninst✝³ : CategoryTheory.Category.{u_12, u_2} C₂\ninst✝² : CategoryTheory.Category.{u_13, u_3} C₃\ninst✝¹ : CategoryTheory.Category.{u_14, u_4} C₄\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ (CategoryTheory.Functor C₃ C₄))\nI₁ : Type u_7\nI₂ : Type u_8\nI₃ : Type u_9\nJ : Type u_10\np : Prod I₁ (Prod I₂ I₃) → J\ninst✝ : ∀ (X₁ : CategoryTheory.GradedObject I₁ C₁) (X₂ : CategoryTheory.GradedObject I₂ C₂) (X₃ : CategoryTheory.GradedObject I₃ C₃), ((((CategoryTheory.GradedObject.mapTrifunctor F I₁ I₂ I₃).obj X₁).obj X₂).obj X₃).HasMap p\nX₁ : CategoryTheory.GradedObject I₁ C₁\n⊢ Eq ((CategoryTheory.GradedObject.mapTrifunctorMap F p).obj X₁) (CategoryTheory.GradedObject.mapTrifunctorMapFunctorObj F p X₁)","decl":"attribute [simps] mapTrifunctorMap\n\n"}
{"name":"CategoryTheory.GradedObject.BifunctorComp₁₂IndexData.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"I₁ : Type u_7\nI₂ : Type u_8\nI₃ : Type u_9\nJ : Type u_10\nr : Prod I₁ (Prod I₂ I₃) → J\ninst✝³ : SizeOf I₁\ninst✝² : SizeOf I₂\ninst✝¹ : SizeOf I₃\ninst✝ : SizeOf J\nI₁₂ : Type u_11\np : Prod I₁ I₂ → I₁₂\nq : Prod I₁₂ I₃ → J\nhpq : ∀ (i : Prod I₁ (Prod I₂ I₃)), Eq (q { fst := p { fst := i.1, snd := i.2.1 }, snd := i.2.2 }) (r i)\n⊢ Eq (SizeOf.sizeOf { I₁₂ := I₁₂, p := p, q := q, hpq := hpq }) (HAdd.hAdd 1 (SizeOf.sizeOf I₁₂))","decl":"/-- Given a map `r : I₁ × I₂ × I₃ → J`, a `BifunctorComp₁₂IndexData r` consists of the data\nof a type `I₁₂`, maps `p : I₁ × I₂ → I₁₂` and `q : I₁₂ × I₃ → J`, such that `r` is obtained\nby composition of `p` and `q`. -/\nstructure BifunctorComp₁₂IndexData where\n  /-- an auxiliary type -/\n  I₁₂ : Type*\n  /-- a map `I₁ × I₂ → I₁₂` -/\n  p : I₁ × I₂ → I₁₂\n  /-- a map `I₁₂ × I₃ → J` -/\n  q : I₁₂ × I₃ → J\n  hpq (i : I₁ × I₂ × I₃) : q ⟨p ⟨i.1, i.2.1⟩, i.2.2⟩ = r i\n\n"}
{"name":"CategoryTheory.GradedObject.BifunctorComp₁₂IndexData.hpq","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"I₁ : Type u_7\nI₂ : Type u_8\nI₃ : Type u_9\nJ : Type u_10\nr : Prod I₁ (Prod I₂ I₃) → J\nself : CategoryTheory.GradedObject.BifunctorComp₁₂IndexData r\ni : Prod I₁ (Prod I₂ I₃)\n⊢ Eq (self.q { fst := self.p { fst := i.1, snd := i.2.1 }, snd := i.2.2 }) (r i)","decl":"/-- Given a map `r : I₁ × I₂ × I₃ → J`, a `BifunctorComp₁₂IndexData r` consists of the data\nof a type `I₁₂`, maps `p : I₁ × I₂ → I₁₂` and `q : I₁₂ × I₃ → J`, such that `r` is obtained\nby composition of `p` and `q`. -/\nstructure BifunctorComp₁₂IndexData where\n  /-- an auxiliary type -/\n  I₁₂ : Type*\n  /-- a map `I₁ × I₂ → I₁₂` -/\n  p : I₁ × I₂ → I₁₂\n  /-- a map `I₁₂ × I₃ → J` -/\n  q : I₁₂ × I₃ → J\n  hpq (i : I₁ × I₂ × I₃) : q ⟨p ⟨i.1, i.2.1⟩, i.2.2⟩ = r i\n\n"}
{"name":"CategoryTheory.GradedObject.BifunctorComp₁₂IndexData.mk.inj","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"I₁ : Type u_7\nI₂ : Type u_8\nI₃ : Type u_9\nJ : Type u_10\nr : Prod I₁ (Prod I₂ I₃) → J\nI₁₂✝ : Type u_11\np✝ : Prod I₁ I₂ → I₁₂✝\nq✝ : Prod I₁₂✝ I₃ → J\nhpq✝ : ∀ (i : Prod I₁ (Prod I₂ I₃)), Eq (q✝ { fst := p✝ { fst := i.1, snd := i.2.1 }, snd := i.2.2 }) (r i)\nI₁₂ : Type u_11\np : Prod I₁ I₂ → I₁₂\nq : Prod I₁₂ I₃ → J\nhpq : ∀ (i : Prod I₁ (Prod I₂ I₃)), Eq (q { fst := p { fst := i.1, snd := i.2.1 }, snd := i.2.2 }) (r i)\nx✝ : Eq { I₁₂ := I₁₂✝, p := p✝, q := q✝, hpq := hpq✝ } { I₁₂ := I₁₂, p := p, q := q, hpq := hpq }\n⊢ And (Eq I₁₂✝ I₁₂) (And (HEq p✝ p) (HEq q✝ q))","decl":"/-- Given a map `r : I₁ × I₂ × I₃ → J`, a `BifunctorComp₁₂IndexData r` consists of the data\nof a type `I₁₂`, maps `p : I₁ × I₂ → I₁₂` and `q : I₁₂ × I₃ → J`, such that `r` is obtained\nby composition of `p` and `q`. -/\nstructure BifunctorComp₁₂IndexData where\n  /-- an auxiliary type -/\n  I₁₂ : Type*\n  /-- a map `I₁ × I₂ → I₁₂` -/\n  p : I₁ × I₂ → I₁₂\n  /-- a map `I₁₂ × I₃ → J` -/\n  q : I₁₂ × I₃ → J\n  hpq (i : I₁ × I₂ × I₃) : q ⟨p ⟨i.1, i.2.1⟩, i.2.2⟩ = r i\n\n"}
{"name":"CategoryTheory.GradedObject.BifunctorComp₁₂IndexData.mk.injEq","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"I₁ : Type u_7\nI₂ : Type u_8\nI₃ : Type u_9\nJ : Type u_10\nr : Prod I₁ (Prod I₂ I₃) → J\nI₁₂✝ : Type u_11\np✝ : Prod I₁ I₂ → I₁₂✝\nq✝ : Prod I₁₂✝ I₃ → J\nhpq✝ : ∀ (i : Prod I₁ (Prod I₂ I₃)), Eq (q✝ { fst := p✝ { fst := i.1, snd := i.2.1 }, snd := i.2.2 }) (r i)\nI₁₂ : Type u_11\np : Prod I₁ I₂ → I₁₂\nq : Prod I₁₂ I₃ → J\nhpq : ∀ (i : Prod I₁ (Prod I₂ I₃)), Eq (q { fst := p { fst := i.1, snd := i.2.1 }, snd := i.2.2 }) (r i)\n⊢ Eq (Eq { I₁₂ := I₁₂✝, p := p✝, q := q✝, hpq := hpq✝ } { I₁₂ := I₁₂, p := p, q := q, hpq := hpq }) (And (Eq I₁₂✝ I₁₂) (And (HEq p✝ p) (HEq q✝ q)))","decl":"/-- Given a map `r : I₁ × I₂ × I₃ → J`, a `BifunctorComp₁₂IndexData r` consists of the data\nof a type `I₁₂`, maps `p : I₁ × I₂ → I₁₂` and `q : I₁₂ × I₃ → J`, such that `r` is obtained\nby composition of `p` and `q`. -/\nstructure BifunctorComp₁₂IndexData where\n  /-- an auxiliary type -/\n  I₁₂ : Type*\n  /-- a map `I₁ × I₂ → I₁₂` -/\n  p : I₁ × I₂ → I₁₂\n  /-- a map `I₁₂ × I₃ → J` -/\n  q : I₁₂ × I₃ → J\n  hpq (i : I₁ × I₂ × I₃) : q ⟨p ⟨i.1, i.2.1⟩, i.2.2⟩ = r i\n\n"}
{"name":"CategoryTheory.GradedObject.ιMapBifunctor₁₂BifunctorMapObj_eq_assoc","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\nC₁₂ : Type u_5\ninst✝⁶ : CategoryTheory.Category.{u_16, u_1} C₁\ninst✝⁵ : CategoryTheory.Category.{u_15, u_2} C₂\ninst✝⁴ : CategoryTheory.Category.{u_13, u_3} C₃\ninst✝³ : CategoryTheory.Category.{u_12, u_4} C₄\ninst✝² : CategoryTheory.Category.{u_14, u_5} C₁₂\nF₁₂ : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ C₁₂)\nG : CategoryTheory.Functor C₁₂ (CategoryTheory.Functor C₃ C₄)\nI₁ : Type u_7\nI₂ : Type u_8\nI₃ : Type u_9\nJ : Type u_10\nr : Prod I₁ (Prod I₂ I₃) → J\nρ₁₂ : CategoryTheory.GradedObject.BifunctorComp₁₂IndexData r\nX₁ : CategoryTheory.GradedObject I₁ C₁\nX₂ : CategoryTheory.GradedObject I₂ C₂\nX₃ : CategoryTheory.GradedObject I₃ C₃\ninst✝¹ : (((CategoryTheory.GradedObject.mapBifunctor F₁₂ I₁ I₂).obj X₁).obj X₂).HasMap ρ₁₂.p\ninst✝ : (((CategoryTheory.GradedObject.mapBifunctor G ρ₁₂.I₁₂ I₃).obj (CategoryTheory.GradedObject.mapBifunctorMapObj F₁₂ ρ₁₂.p X₁ X₂)).obj X₃).HasMap ρ₁₂.q\ni₁ : I₁\ni₂ : I₂\ni₃ : I₃\nj : J\nh✝ : Eq (r { fst := i₁, snd := { fst := i₂, snd := i₃ } }) j\ni₁₂ : ρ₁₂.I₁₂\nh₁₂ : Eq (ρ₁₂.p { fst := i₁, snd := i₂ }) i₁₂\nZ : C₄\nh : Quiver.Hom (CategoryTheory.GradedObject.mapBifunctorMapObj G ρ₁₂.q (CategoryTheory.GradedObject.mapBifunctorMapObj F₁₂ ρ₁₂.p X₁ X₂) X₃ j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ιMapBifunctor₁₂BifunctorMapObj F₁₂ G ρ₁₂ X₁ X₂ X₃ i₁ i₂ i₃ j h✝) h) (CategoryTheory.CategoryStruct.comp ((G.map (CategoryTheory.GradedObject.ιMapBifunctorMapObj F₁₂ ρ₁₂.p X₁ X₂ i₁ i₂ i₁₂ h₁₂)).app (X₃ i₃)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ιMapBifunctorMapObj G ρ₁₂.q (CategoryTheory.GradedObject.mapBifunctorMapObj F₁₂ ρ₁₂.p X₁ X₂) X₃ i₁₂ i₃ j ⋯) h))","decl":"@[reassoc]\nlemma ιMapBifunctor₁₂BifunctorMapObj_eq (i₁ : I₁) (i₂ : I₂) (i₃ : I₃) (j : J)\n    (h : r (i₁, i₂, i₃) = j) (i₁₂ : ρ₁₂.I₁₂) (h₁₂ : ρ₁₂.p ⟨i₁, i₂⟩ = i₁₂) :\n    ιMapBifunctor₁₂BifunctorMapObj F₁₂ G ρ₁₂ X₁ X₂ X₃ i₁ i₂ i₃ j h =\n      (G.map (ιMapBifunctorMapObj F₁₂ ρ₁₂.p X₁ X₂ i₁ i₂ i₁₂ h₁₂)).app (X₃ i₃) ≫\n    ιMapBifunctorMapObj G ρ₁₂.q (mapBifunctorMapObj F₁₂ ρ₁₂.p X₁ X₂) X₃ i₁₂ i₃ j\n      (by rw [← h₁₂, ← h, ← ρ₁₂.hpq]) := by\n  subst h₁₂\n  rfl\n\n"}
{"name":"CategoryTheory.GradedObject.ιMapBifunctor₁₂BifunctorMapObj_eq","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\nC₁₂ : Type u_5\ninst✝⁶ : CategoryTheory.Category.{u_16, u_1} C₁\ninst✝⁵ : CategoryTheory.Category.{u_15, u_2} C₂\ninst✝⁴ : CategoryTheory.Category.{u_13, u_3} C₃\ninst✝³ : CategoryTheory.Category.{u_12, u_4} C₄\ninst✝² : CategoryTheory.Category.{u_14, u_5} C₁₂\nF₁₂ : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ C₁₂)\nG : CategoryTheory.Functor C₁₂ (CategoryTheory.Functor C₃ C₄)\nI₁ : Type u_7\nI₂ : Type u_8\nI₃ : Type u_9\nJ : Type u_10\nr : Prod I₁ (Prod I₂ I₃) → J\nρ₁₂ : CategoryTheory.GradedObject.BifunctorComp₁₂IndexData r\nX₁ : CategoryTheory.GradedObject I₁ C₁\nX₂ : CategoryTheory.GradedObject I₂ C₂\nX₃ : CategoryTheory.GradedObject I₃ C₃\ninst✝¹ : (((CategoryTheory.GradedObject.mapBifunctor F₁₂ I₁ I₂).obj X₁).obj X₂).HasMap ρ₁₂.p\ninst✝ : (((CategoryTheory.GradedObject.mapBifunctor G ρ₁₂.I₁₂ I₃).obj (CategoryTheory.GradedObject.mapBifunctorMapObj F₁₂ ρ₁₂.p X₁ X₂)).obj X₃).HasMap ρ₁₂.q\ni₁ : I₁\ni₂ : I₂\ni₃ : I₃\nj : J\nh : Eq (r { fst := i₁, snd := { fst := i₂, snd := i₃ } }) j\ni₁₂ : ρ₁₂.I₁₂\nh₁₂ : Eq (ρ₁₂.p { fst := i₁, snd := i₂ }) i₁₂\n⊢ Eq (CategoryTheory.GradedObject.ιMapBifunctor₁₂BifunctorMapObj F₁₂ G ρ₁₂ X₁ X₂ X₃ i₁ i₂ i₃ j h) (CategoryTheory.CategoryStruct.comp ((G.map (CategoryTheory.GradedObject.ιMapBifunctorMapObj F₁₂ ρ₁₂.p X₁ X₂ i₁ i₂ i₁₂ h₁₂)).app (X₃ i₃)) (CategoryTheory.GradedObject.ιMapBifunctorMapObj G ρ₁₂.q (CategoryTheory.GradedObject.mapBifunctorMapObj F₁₂ ρ₁₂.p X₁ X₂) X₃ i₁₂ i₃ j ⋯))","decl":"@[reassoc]\nlemma ιMapBifunctor₁₂BifunctorMapObj_eq (i₁ : I₁) (i₂ : I₂) (i₃ : I₃) (j : J)\n    (h : r (i₁, i₂, i₃) = j) (i₁₂ : ρ₁₂.I₁₂) (h₁₂ : ρ₁₂.p ⟨i₁, i₂⟩ = i₁₂) :\n    ιMapBifunctor₁₂BifunctorMapObj F₁₂ G ρ₁₂ X₁ X₂ X₃ i₁ i₂ i₃ j h =\n      (G.map (ιMapBifunctorMapObj F₁₂ ρ₁₂.p X₁ X₂ i₁ i₂ i₁₂ h₁₂)).app (X₃ i₃) ≫\n    ιMapBifunctorMapObj G ρ₁₂.q (mapBifunctorMapObj F₁₂ ρ₁₂.p X₁ X₂) X₃ i₁₂ i₃ j\n      (by rw [← h₁₂, ← h, ← ρ₁₂.hpq]) := by\n  subst h₁₂\n  rfl\n\n"}
{"name":"CategoryTheory.GradedObject.HasGoodTrifunctor₁₂Obj.hasMap","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\nC₁₂ : Type u_5\ninst✝⁶ : CategoryTheory.Category.{u_14, u_1} C₁\ninst✝⁵ : CategoryTheory.Category.{u_13, u_2} C₂\ninst✝⁴ : CategoryTheory.Category.{u_12, u_3} C₃\ninst✝³ : CategoryTheory.Category.{u_11, u_4} C₄\ninst✝² : CategoryTheory.Category.{u_15, u_5} C₁₂\nF₁₂ : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ C₁₂)\nG : CategoryTheory.Functor C₁₂ (CategoryTheory.Functor C₃ C₄)\nI₁ : Type u_7\nI₂ : Type u_8\nI₃ : Type u_9\nJ : Type u_10\nr : Prod I₁ (Prod I₂ I₃) → J\nρ₁₂ : CategoryTheory.GradedObject.BifunctorComp₁₂IndexData r\nX₁ : CategoryTheory.GradedObject I₁ C₁\nX₂ : CategoryTheory.GradedObject I₂ C₂\nX₃ : CategoryTheory.GradedObject I₃ C₃\ninst✝¹ : (((CategoryTheory.GradedObject.mapBifunctor F₁₂ I₁ I₂).obj X₁).obj X₂).HasMap ρ₁₂.p\ninst✝ : (((CategoryTheory.GradedObject.mapBifunctor G ρ₁₂.I₁₂ I₃).obj (CategoryTheory.GradedObject.mapBifunctorMapObj F₁₂ ρ₁₂.p X₁ X₂)).obj X₃).HasMap ρ₁₂.q\nH : CategoryTheory.GradedObject.HasGoodTrifunctor₁₂Obj F₁₂ G ρ₁₂ X₁ X₂ X₃\n⊢ ((((CategoryTheory.GradedObject.mapTrifunctor (CategoryTheory.bifunctorComp₁₂ F₁₂ G) I₁ I₂ I₃).obj X₁).obj X₂).obj X₃).HasMap r","decl":"include ρ₁₂ in\nlemma HasGoodTrifunctor₁₂Obj.hasMap :\n    HasMap ((((mapTrifunctor (bifunctorComp₁₂ F₁₂ G) I₁ I₂ I₃).obj X₁).obj X₂).obj X₃) r :=\n  fun j => ⟨_, isColimitCofan₃MapBifunctor₁₂BifunctorMapObj F₁₂ G ρ₁₂ X₁ X₂ X₃ j⟩\n\n"}
{"name":"CategoryTheory.GradedObject.ι_mapBifunctorComp₁₂MapObjIso_hom_assoc","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\nC₁₂ : Type u_5\ninst✝⁷ : CategoryTheory.Category.{u_14, u_1} C₁\ninst✝⁶ : CategoryTheory.Category.{u_13, u_2} C₂\ninst✝⁵ : CategoryTheory.Category.{u_12, u_3} C₃\ninst✝⁴ : CategoryTheory.Category.{u_11, u_4} C₄\ninst✝³ : CategoryTheory.Category.{u_15, u_5} C₁₂\nF₁₂ : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ C₁₂)\nG : CategoryTheory.Functor C₁₂ (CategoryTheory.Functor C₃ C₄)\nI₁ : Type u_7\nI₂ : Type u_8\nI₃ : Type u_9\nJ : Type u_10\nr : Prod I₁ (Prod I₂ I₃) → J\nρ₁₂ : CategoryTheory.GradedObject.BifunctorComp₁₂IndexData r\nX₁ : CategoryTheory.GradedObject I₁ C₁\nX₂ : CategoryTheory.GradedObject I₂ C₂\nX₃ : CategoryTheory.GradedObject I₃ C₃\ninst✝² : (((CategoryTheory.GradedObject.mapBifunctor F₁₂ I₁ I₂).obj X₁).obj X₂).HasMap ρ₁₂.p\ninst✝¹ : (((CategoryTheory.GradedObject.mapBifunctor G ρ₁₂.I₁₂ I₃).obj (CategoryTheory.GradedObject.mapBifunctorMapObj F₁₂ ρ₁₂.p X₁ X₂)).obj X₃).HasMap ρ₁₂.q\nH : CategoryTheory.GradedObject.HasGoodTrifunctor₁₂Obj F₁₂ G ρ₁₂ X₁ X₂ X₃\ninst✝ : ((((CategoryTheory.GradedObject.mapTrifunctor (CategoryTheory.bifunctorComp₁₂ F₁₂ G) I₁ I₂ I₃).obj X₁).obj X₂).obj X₃).HasMap r\ni₁ : I₁\ni₂ : I₂\ni₃ : I₃\nj : J\nh✝ : Eq (r { fst := i₁, snd := { fst := i₂, snd := i₃ } }) j\nZ : C₄\nh : Quiver.Hom (CategoryTheory.GradedObject.mapBifunctorMapObj G ρ₁₂.q (CategoryTheory.GradedObject.mapBifunctorMapObj F₁₂ ρ₁₂.p X₁ X₂) X₃ j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ιMapTrifunctorMapObj (CategoryTheory.bifunctorComp₁₂ F₁₂ G) r X₁ X₂ X₃ i₁ i₂ i₃ j h✝) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.GradedObject.mapBifunctorComp₁₂MapObjIso F₁₂ G ρ₁₂ X₁ X₂ X₃).hom j) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ιMapBifunctor₁₂BifunctorMapObj F₁₂ G ρ₁₂ X₁ X₂ X₃ i₁ i₂ i₃ j h✝) h)","decl":"@[reassoc (attr := simp)]\nlemma ι_mapBifunctorComp₁₂MapObjIso_hom (i₁ : I₁) (i₂ : I₂) (i₃ : I₃) (j : J)\n    (h : r (i₁, i₂, i₃) = j) :\n    ιMapTrifunctorMapObj (bifunctorComp₁₂ F₁₂ G) r X₁ X₂ X₃ i₁ i₂ i₃ j h ≫\n      (mapBifunctorComp₁₂MapObjIso F₁₂ G ρ₁₂ X₁ X₂ X₃).hom j =\n      ιMapBifunctor₁₂BifunctorMapObj F₁₂ G ρ₁₂ X₁ X₂ X₃ i₁ i₂ i₃ j h := by\n  dsimp [mapBifunctorComp₁₂MapObjIso]\n  apply CofanMapObjFun.ιMapObj_iso_inv\n\n"}
{"name":"CategoryTheory.GradedObject.ι_mapBifunctorComp₁₂MapObjIso_hom","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\nC₁₂ : Type u_5\ninst✝⁷ : CategoryTheory.Category.{u_14, u_1} C₁\ninst✝⁶ : CategoryTheory.Category.{u_13, u_2} C₂\ninst✝⁵ : CategoryTheory.Category.{u_12, u_3} C₃\ninst✝⁴ : CategoryTheory.Category.{u_11, u_4} C₄\ninst✝³ : CategoryTheory.Category.{u_15, u_5} C₁₂\nF₁₂ : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ C₁₂)\nG : CategoryTheory.Functor C₁₂ (CategoryTheory.Functor C₃ C₄)\nI₁ : Type u_7\nI₂ : Type u_8\nI₃ : Type u_9\nJ : Type u_10\nr : Prod I₁ (Prod I₂ I₃) → J\nρ₁₂ : CategoryTheory.GradedObject.BifunctorComp₁₂IndexData r\nX₁ : CategoryTheory.GradedObject I₁ C₁\nX₂ : CategoryTheory.GradedObject I₂ C₂\nX₃ : CategoryTheory.GradedObject I₃ C₃\ninst✝² : (((CategoryTheory.GradedObject.mapBifunctor F₁₂ I₁ I₂).obj X₁).obj X₂).HasMap ρ₁₂.p\ninst✝¹ : (((CategoryTheory.GradedObject.mapBifunctor G ρ₁₂.I₁₂ I₃).obj (CategoryTheory.GradedObject.mapBifunctorMapObj F₁₂ ρ₁₂.p X₁ X₂)).obj X₃).HasMap ρ₁₂.q\nH : CategoryTheory.GradedObject.HasGoodTrifunctor₁₂Obj F₁₂ G ρ₁₂ X₁ X₂ X₃\ninst✝ : ((((CategoryTheory.GradedObject.mapTrifunctor (CategoryTheory.bifunctorComp₁₂ F₁₂ G) I₁ I₂ I₃).obj X₁).obj X₂).obj X₃).HasMap r\ni₁ : I₁\ni₂ : I₂\ni₃ : I₃\nj : J\nh : Eq (r { fst := i₁, snd := { fst := i₂, snd := i₃ } }) j\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ιMapTrifunctorMapObj (CategoryTheory.bifunctorComp₁₂ F₁₂ G) r X₁ X₂ X₃ i₁ i₂ i₃ j h) ((CategoryTheory.GradedObject.mapBifunctorComp₁₂MapObjIso F₁₂ G ρ₁₂ X₁ X₂ X₃).hom j)) (CategoryTheory.GradedObject.ιMapBifunctor₁₂BifunctorMapObj F₁₂ G ρ₁₂ X₁ X₂ X₃ i₁ i₂ i₃ j h)","decl":"@[reassoc (attr := simp)]\nlemma ι_mapBifunctorComp₁₂MapObjIso_hom (i₁ : I₁) (i₂ : I₂) (i₃ : I₃) (j : J)\n    (h : r (i₁, i₂, i₃) = j) :\n    ιMapTrifunctorMapObj (bifunctorComp₁₂ F₁₂ G) r X₁ X₂ X₃ i₁ i₂ i₃ j h ≫\n      (mapBifunctorComp₁₂MapObjIso F₁₂ G ρ₁₂ X₁ X₂ X₃).hom j =\n      ιMapBifunctor₁₂BifunctorMapObj F₁₂ G ρ₁₂ X₁ X₂ X₃ i₁ i₂ i₃ j h := by\n  dsimp [mapBifunctorComp₁₂MapObjIso]\n  apply CofanMapObjFun.ιMapObj_iso_inv\n\n"}
{"name":"CategoryTheory.GradedObject.ι_mapBifunctorComp₁₂MapObjIso_inv","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\nC₁₂ : Type u_5\ninst✝⁷ : CategoryTheory.Category.{u_15, u_1} C₁\ninst✝⁶ : CategoryTheory.Category.{u_14, u_2} C₂\ninst✝⁵ : CategoryTheory.Category.{u_12, u_3} C₃\ninst✝⁴ : CategoryTheory.Category.{u_11, u_4} C₄\ninst✝³ : CategoryTheory.Category.{u_13, u_5} C₁₂\nF₁₂ : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ C₁₂)\nG : CategoryTheory.Functor C₁₂ (CategoryTheory.Functor C₃ C₄)\nI₁ : Type u_7\nI₂ : Type u_8\nI₃ : Type u_9\nJ : Type u_10\nr : Prod I₁ (Prod I₂ I₃) → J\nρ₁₂ : CategoryTheory.GradedObject.BifunctorComp₁₂IndexData r\nX₁ : CategoryTheory.GradedObject I₁ C₁\nX₂ : CategoryTheory.GradedObject I₂ C₂\nX₃ : CategoryTheory.GradedObject I₃ C₃\ninst✝² : (((CategoryTheory.GradedObject.mapBifunctor F₁₂ I₁ I₂).obj X₁).obj X₂).HasMap ρ₁₂.p\ninst✝¹ : (((CategoryTheory.GradedObject.mapBifunctor G ρ₁₂.I₁₂ I₃).obj (CategoryTheory.GradedObject.mapBifunctorMapObj F₁₂ ρ₁₂.p X₁ X₂)).obj X₃).HasMap ρ₁₂.q\nH : CategoryTheory.GradedObject.HasGoodTrifunctor₁₂Obj F₁₂ G ρ₁₂ X₁ X₂ X₃\ninst✝ : ((((CategoryTheory.GradedObject.mapTrifunctor (CategoryTheory.bifunctorComp₁₂ F₁₂ G) I₁ I₂ I₃).obj X₁).obj X₂).obj X₃).HasMap r\ni₁ : I₁\ni₂ : I₂\ni₃ : I₃\nj : J\nh : Eq (r { fst := i₁, snd := { fst := i₂, snd := i₃ } }) j\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ιMapBifunctor₁₂BifunctorMapObj F₁₂ G ρ₁₂ X₁ X₂ X₃ i₁ i₂ i₃ j h) ((CategoryTheory.GradedObject.mapBifunctorComp₁₂MapObjIso F₁₂ G ρ₁₂ X₁ X₂ X₃).inv j)) (CategoryTheory.GradedObject.ιMapTrifunctorMapObj (CategoryTheory.bifunctorComp₁₂ F₁₂ G) r X₁ X₂ X₃ i₁ i₂ i₃ j h)","decl":"@[reassoc (attr := simp)]\nlemma ι_mapBifunctorComp₁₂MapObjIso_inv (i₁ : I₁) (i₂ : I₂) (i₃ : I₃) (j : J)\n    (h : r (i₁, i₂, i₃) = j) :\n    ιMapBifunctor₁₂BifunctorMapObj F₁₂ G ρ₁₂ X₁ X₂ X₃ i₁ i₂ i₃ j h ≫\n      (mapBifunctorComp₁₂MapObjIso F₁₂ G ρ₁₂ X₁ X₂ X₃).inv j =\n      ιMapTrifunctorMapObj (bifunctorComp₁₂ F₁₂ G) r X₁ X₂ X₃ i₁ i₂ i₃ j h :=\n  CofanMapObjFun.inj_iso_hom\n    (isColimitCofan₃MapBifunctor₁₂BifunctorMapObj F₁₂ G ρ₁₂ X₁ X₂ X₃ j) _ h\n\n"}
{"name":"CategoryTheory.GradedObject.ι_mapBifunctorComp₁₂MapObjIso_inv_assoc","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\nC₁₂ : Type u_5\ninst✝⁷ : CategoryTheory.Category.{u_15, u_1} C₁\ninst✝⁶ : CategoryTheory.Category.{u_14, u_2} C₂\ninst✝⁵ : CategoryTheory.Category.{u_12, u_3} C₃\ninst✝⁴ : CategoryTheory.Category.{u_11, u_4} C₄\ninst✝³ : CategoryTheory.Category.{u_13, u_5} C₁₂\nF₁₂ : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ C₁₂)\nG : CategoryTheory.Functor C₁₂ (CategoryTheory.Functor C₃ C₄)\nI₁ : Type u_7\nI₂ : Type u_8\nI₃ : Type u_9\nJ : Type u_10\nr : Prod I₁ (Prod I₂ I₃) → J\nρ₁₂ : CategoryTheory.GradedObject.BifunctorComp₁₂IndexData r\nX₁ : CategoryTheory.GradedObject I₁ C₁\nX₂ : CategoryTheory.GradedObject I₂ C₂\nX₃ : CategoryTheory.GradedObject I₃ C₃\ninst✝² : (((CategoryTheory.GradedObject.mapBifunctor F₁₂ I₁ I₂).obj X₁).obj X₂).HasMap ρ₁₂.p\ninst✝¹ : (((CategoryTheory.GradedObject.mapBifunctor G ρ₁₂.I₁₂ I₃).obj (CategoryTheory.GradedObject.mapBifunctorMapObj F₁₂ ρ₁₂.p X₁ X₂)).obj X₃).HasMap ρ₁₂.q\nH : CategoryTheory.GradedObject.HasGoodTrifunctor₁₂Obj F₁₂ G ρ₁₂ X₁ X₂ X₃\ninst✝ : ((((CategoryTheory.GradedObject.mapTrifunctor (CategoryTheory.bifunctorComp₁₂ F₁₂ G) I₁ I₂ I₃).obj X₁).obj X₂).obj X₃).HasMap r\ni₁ : I₁\ni₂ : I₂\ni₃ : I₃\nj : J\nh✝ : Eq (r { fst := i₁, snd := { fst := i₂, snd := i₃ } }) j\nZ : C₄\nh : Quiver.Hom (CategoryTheory.GradedObject.mapTrifunctorMapObj (CategoryTheory.bifunctorComp₁₂ F₁₂ G) r X₁ X₂ X₃ j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ιMapBifunctor₁₂BifunctorMapObj F₁₂ G ρ₁₂ X₁ X₂ X₃ i₁ i₂ i₃ j h✝) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.GradedObject.mapBifunctorComp₁₂MapObjIso F₁₂ G ρ₁₂ X₁ X₂ X₃).inv j) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ιMapTrifunctorMapObj (CategoryTheory.bifunctorComp₁₂ F₁₂ G) r X₁ X₂ X₃ i₁ i₂ i₃ j h✝) h)","decl":"@[reassoc (attr := simp)]\nlemma ι_mapBifunctorComp₁₂MapObjIso_inv (i₁ : I₁) (i₂ : I₂) (i₃ : I₃) (j : J)\n    (h : r (i₁, i₂, i₃) = j) :\n    ιMapBifunctor₁₂BifunctorMapObj F₁₂ G ρ₁₂ X₁ X₂ X₃ i₁ i₂ i₃ j h ≫\n      (mapBifunctorComp₁₂MapObjIso F₁₂ G ρ₁₂ X₁ X₂ X₃).inv j =\n      ιMapTrifunctorMapObj (bifunctorComp₁₂ F₁₂ G) r X₁ X₂ X₃ i₁ i₂ i₃ j h :=\n  CofanMapObjFun.inj_iso_hom\n    (isColimitCofan₃MapBifunctor₁₂BifunctorMapObj F₁₂ G ρ₁₂ X₁ X₂ X₃ j) _ h\n\n"}
{"name":"CategoryTheory.GradedObject.mapBifunctor₁₂BifunctorMapObj_ext","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\nC₁₂ : Type u_5\ninst✝⁶ : CategoryTheory.Category.{u_15, u_1} C₁\ninst✝⁵ : CategoryTheory.Category.{u_16, u_2} C₂\ninst✝⁴ : CategoryTheory.Category.{u_14, u_3} C₃\ninst✝³ : CategoryTheory.Category.{u_11, u_4} C₄\ninst✝² : CategoryTheory.Category.{u_13, u_5} C₁₂\nF₁₂ : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ C₁₂)\nG : CategoryTheory.Functor C₁₂ (CategoryTheory.Functor C₃ C₄)\nI₁ : Type u_7\nI₂ : Type u_8\nI₃ : Type u_9\nJ : Type u_10\nr : Prod I₁ (Prod I₂ I₃) → J\nρ₁₂ : CategoryTheory.GradedObject.BifunctorComp₁₂IndexData r\nX₁ : CategoryTheory.GradedObject I₁ C₁\nX₂ : CategoryTheory.GradedObject I₂ C₂\nX₃ : CategoryTheory.GradedObject I₃ C₃\ninst✝¹ : (((CategoryTheory.GradedObject.mapBifunctor F₁₂ I₁ I₂).obj X₁).obj X₂).HasMap ρ₁₂.p\ninst✝ : (((CategoryTheory.GradedObject.mapBifunctor G ρ₁₂.I₁₂ I₃).obj (CategoryTheory.GradedObject.mapBifunctorMapObj F₁₂ ρ₁₂.p X₁ X₂)).obj X₃).HasMap ρ₁₂.q\nH : CategoryTheory.GradedObject.HasGoodTrifunctor₁₂Obj F₁₂ G ρ₁₂ X₁ X₂ X₃\nj : J\nA : C₄\nf g : Quiver.Hom (CategoryTheory.GradedObject.mapBifunctorMapObj G ρ₁₂.q (CategoryTheory.GradedObject.mapBifunctorMapObj F₁₂ ρ₁₂.p X₁ X₂) X₃ j) A\nh : ∀ (i₁ : I₁) (i₂ : I₂) (i₃ : I₃) (h : Eq (r { fst := i₁, snd := { fst := i₂, snd := i₃ } }) j), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ιMapBifunctor₁₂BifunctorMapObj F₁₂ G ρ₁₂ X₁ X₂ X₃ i₁ i₂ i₃ j h) f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ιMapBifunctor₁₂BifunctorMapObj F₁₂ G ρ₁₂ X₁ X₂ X₃ i₁ i₂ i₃ j h) g)\n⊢ Eq f g","decl":"@[ext]\nlemma mapBifunctor₁₂BifunctorMapObj_ext {A : C₄}\n    {f g : mapBifunctorMapObj G ρ₁₂.q (mapBifunctorMapObj F₁₂ ρ₁₂.p X₁ X₂) X₃ j ⟶ A}\n    (h : ∀ (i₁ : I₁) (i₂ : I₂) (i₃ : I₃) (h : r ⟨i₁, i₂, i₃⟩ = j),\n      ιMapBifunctor₁₂BifunctorMapObj F₁₂ G ρ₁₂ X₁ X₂ X₃ i₁ i₂ i₃ j h ≫ f =\n        ιMapBifunctor₁₂BifunctorMapObj F₁₂ G ρ₁₂ X₁ X₂ X₃ i₁ i₂ i₃ j h ≫ g) : f = g := by\n  apply Cofan.IsColimit.hom_ext (isColimitCofan₃MapBifunctor₁₂BifunctorMapObj F₁₂ G ρ₁₂ X₁ X₂ X₃ j)\n  rintro ⟨i, hi⟩\n  exact h _ _ _ hi\n\n"}
{"name":"CategoryTheory.GradedObject.mapBifunctor₁₂BifunctorMapObj_ext_iff","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\nC₁₂ : Type u_5\ninst✝⁶ : CategoryTheory.Category.{u_15, u_1} C₁\ninst✝⁵ : CategoryTheory.Category.{u_16, u_2} C₂\ninst✝⁴ : CategoryTheory.Category.{u_14, u_3} C₃\ninst✝³ : CategoryTheory.Category.{u_11, u_4} C₄\ninst✝² : CategoryTheory.Category.{u_13, u_5} C₁₂\nF₁₂ : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ C₁₂)\nG : CategoryTheory.Functor C₁₂ (CategoryTheory.Functor C₃ C₄)\nI₁ : Type u_7\nI₂ : Type u_8\nI₃ : Type u_9\nJ : Type u_10\nr : Prod I₁ (Prod I₂ I₃) → J\nρ₁₂ : CategoryTheory.GradedObject.BifunctorComp₁₂IndexData r\nX₁ : CategoryTheory.GradedObject I₁ C₁\nX₂ : CategoryTheory.GradedObject I₂ C₂\nX₃ : CategoryTheory.GradedObject I₃ C₃\ninst✝¹ : (((CategoryTheory.GradedObject.mapBifunctor F₁₂ I₁ I₂).obj X₁).obj X₂).HasMap ρ₁₂.p\ninst✝ : (((CategoryTheory.GradedObject.mapBifunctor G ρ₁₂.I₁₂ I₃).obj (CategoryTheory.GradedObject.mapBifunctorMapObj F₁₂ ρ₁₂.p X₁ X₂)).obj X₃).HasMap ρ₁₂.q\nH : CategoryTheory.GradedObject.HasGoodTrifunctor₁₂Obj F₁₂ G ρ₁₂ X₁ X₂ X₃\nj : J\nA : C₄\nf g : Quiver.Hom (CategoryTheory.GradedObject.mapBifunctorMapObj G ρ₁₂.q (CategoryTheory.GradedObject.mapBifunctorMapObj F₁₂ ρ₁₂.p X₁ X₂) X₃ j) A\n⊢ Iff (Eq f g) (∀ (i₁ : I₁) (i₂ : I₂) (i₃ : I₃) (h : Eq (r { fst := i₁, snd := { fst := i₂, snd := i₃ } }) j), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ιMapBifunctor₁₂BifunctorMapObj F₁₂ G ρ₁₂ X₁ X₂ X₃ i₁ i₂ i₃ j h) f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ιMapBifunctor₁₂BifunctorMapObj F₁₂ G ρ₁₂ X₁ X₂ X₃ i₁ i₂ i₃ j h) g))","decl":"@[ext]\nlemma mapBifunctor₁₂BifunctorMapObj_ext {A : C₄}\n    {f g : mapBifunctorMapObj G ρ₁₂.q (mapBifunctorMapObj F₁₂ ρ₁₂.p X₁ X₂) X₃ j ⟶ A}\n    (h : ∀ (i₁ : I₁) (i₂ : I₂) (i₃ : I₃) (h : r ⟨i₁, i₂, i₃⟩ = j),\n      ιMapBifunctor₁₂BifunctorMapObj F₁₂ G ρ₁₂ X₁ X₂ X₃ i₁ i₂ i₃ j h ≫ f =\n        ιMapBifunctor₁₂BifunctorMapObj F₁₂ G ρ₁₂ X₁ X₂ X₃ i₁ i₂ i₃ j h ≫ g) : f = g := by\n  apply Cofan.IsColimit.hom_ext (isColimitCofan₃MapBifunctor₁₂BifunctorMapObj F₁₂ G ρ₁₂ X₁ X₂ X₃ j)\n  rintro ⟨i, hi⟩\n  exact h _ _ _ hi\n\n"}
{"name":"CategoryTheory.GradedObject.ι_mapBifunctor₁₂BifunctorDesc_assoc","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\nC₁₂ : Type u_5\ninst✝⁶ : CategoryTheory.Category.{u_15, u_1} C₁\ninst✝⁵ : CategoryTheory.Category.{u_14, u_2} C₂\ninst✝⁴ : CategoryTheory.Category.{u_12, u_3} C₃\ninst✝³ : CategoryTheory.Category.{u_11, u_4} C₄\ninst✝² : CategoryTheory.Category.{u_13, u_5} C₁₂\nF₁₂ : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ C₁₂)\nG : CategoryTheory.Functor C₁₂ (CategoryTheory.Functor C₃ C₄)\nI₁ : Type u_7\nI₂ : Type u_8\nI₃ : Type u_9\nJ : Type u_10\nr : Prod I₁ (Prod I₂ I₃) → J\nρ₁₂ : CategoryTheory.GradedObject.BifunctorComp₁₂IndexData r\nX₁ : CategoryTheory.GradedObject I₁ C₁\nX₂ : CategoryTheory.GradedObject I₂ C₂\nX₃ : CategoryTheory.GradedObject I₃ C₃\ninst✝¹ : (((CategoryTheory.GradedObject.mapBifunctor F₁₂ I₁ I₂).obj X₁).obj X₂).HasMap ρ₁₂.p\ninst✝ : (((CategoryTheory.GradedObject.mapBifunctor G ρ₁₂.I₁₂ I₃).obj (CategoryTheory.GradedObject.mapBifunctorMapObj F₁₂ ρ₁₂.p X₁ X₂)).obj X₃).HasMap ρ₁₂.q\nH : CategoryTheory.GradedObject.HasGoodTrifunctor₁₂Obj F₁₂ G ρ₁₂ X₁ X₂ X₃\nj : J\nA : C₄\nf : (i₁ : I₁) → (i₂ : I₂) → (i₃ : I₃) → Eq (r { fst := i₁, snd := { fst := i₂, snd := i₃ } }) j → Quiver.Hom ((G.obj ((F₁₂.obj (X₁ i₁)).obj (X₂ i₂))).obj (X₃ i₃)) A\ni₁ : I₁\ni₂ : I₂\ni₃ : I₃\nh✝ : Eq (r { fst := i₁, snd := { fst := i₂, snd := i₃ } }) j\nZ : C₄\nh : Quiver.Hom A Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ιMapBifunctor₁₂BifunctorMapObj F₁₂ G ρ₁₂ X₁ X₂ X₃ i₁ i₂ i₃ j h✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.mapBifunctor₁₂BifunctorDesc f) h)) (CategoryTheory.CategoryStruct.comp (f i₁ i₂ i₃ h✝) h)","decl":"@[reassoc (attr := simp)]\nlemma ι_mapBifunctor₁₂BifunctorDesc\n    (i₁ : I₁) (i₂ : I₂) (i₃ : I₃) (h : r ⟨i₁, i₂, i₃⟩ = j) :\n    ιMapBifunctor₁₂BifunctorMapObj F₁₂ G ρ₁₂ X₁ X₂ X₃ i₁ i₂ i₃ j h ≫\n      mapBifunctor₁₂BifunctorDesc f = f i₁ i₂ i₃ h :=\n  Cofan.IsColimit.fac\n    (isColimitCofan₃MapBifunctor₁₂BifunctorMapObj F₁₂ G ρ₁₂ X₁ X₂ X₃ j) _ ⟨_, h⟩\n\n"}
{"name":"CategoryTheory.GradedObject.ι_mapBifunctor₁₂BifunctorDesc","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\nC₁₂ : Type u_5\ninst✝⁶ : CategoryTheory.Category.{u_15, u_1} C₁\ninst✝⁵ : CategoryTheory.Category.{u_14, u_2} C₂\ninst✝⁴ : CategoryTheory.Category.{u_12, u_3} C₃\ninst✝³ : CategoryTheory.Category.{u_11, u_4} C₄\ninst✝² : CategoryTheory.Category.{u_13, u_5} C₁₂\nF₁₂ : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ C₁₂)\nG : CategoryTheory.Functor C₁₂ (CategoryTheory.Functor C₃ C₄)\nI₁ : Type u_7\nI₂ : Type u_8\nI₃ : Type u_9\nJ : Type u_10\nr : Prod I₁ (Prod I₂ I₃) → J\nρ₁₂ : CategoryTheory.GradedObject.BifunctorComp₁₂IndexData r\nX₁ : CategoryTheory.GradedObject I₁ C₁\nX₂ : CategoryTheory.GradedObject I₂ C₂\nX₃ : CategoryTheory.GradedObject I₃ C₃\ninst✝¹ : (((CategoryTheory.GradedObject.mapBifunctor F₁₂ I₁ I₂).obj X₁).obj X₂).HasMap ρ₁₂.p\ninst✝ : (((CategoryTheory.GradedObject.mapBifunctor G ρ₁₂.I₁₂ I₃).obj (CategoryTheory.GradedObject.mapBifunctorMapObj F₁₂ ρ₁₂.p X₁ X₂)).obj X₃).HasMap ρ₁₂.q\nH : CategoryTheory.GradedObject.HasGoodTrifunctor₁₂Obj F₁₂ G ρ₁₂ X₁ X₂ X₃\nj : J\nA : C₄\nf : (i₁ : I₁) → (i₂ : I₂) → (i₃ : I₃) → Eq (r { fst := i₁, snd := { fst := i₂, snd := i₃ } }) j → Quiver.Hom ((G.obj ((F₁₂.obj (X₁ i₁)).obj (X₂ i₂))).obj (X₃ i₃)) A\ni₁ : I₁\ni₂ : I₂\ni₃ : I₃\nh : Eq (r { fst := i₁, snd := { fst := i₂, snd := i₃ } }) j\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ιMapBifunctor₁₂BifunctorMapObj F₁₂ G ρ₁₂ X₁ X₂ X₃ i₁ i₂ i₃ j h) (CategoryTheory.GradedObject.mapBifunctor₁₂BifunctorDesc f)) (f i₁ i₂ i₃ h)","decl":"@[reassoc (attr := simp)]\nlemma ι_mapBifunctor₁₂BifunctorDesc\n    (i₁ : I₁) (i₂ : I₂) (i₃ : I₃) (h : r ⟨i₁, i₂, i₃⟩ = j) :\n    ιMapBifunctor₁₂BifunctorMapObj F₁₂ G ρ₁₂ X₁ X₂ X₃ i₁ i₂ i₃ j h ≫\n      mapBifunctor₁₂BifunctorDesc f = f i₁ i₂ i₃ h :=\n  Cofan.IsColimit.fac\n    (isColimitCofan₃MapBifunctor₁₂BifunctorMapObj F₁₂ G ρ₁₂ X₁ X₂ X₃ j) _ ⟨_, h⟩\n\n"}
{"name":"CategoryTheory.GradedObject.BifunctorComp₂₃IndexData.mk.inj","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"I₁ : Type u_7\nI₂ : Type u_8\nI₃ : Type u_9\nJ : Type u_10\nr : Prod I₁ (Prod I₂ I₃) → J\nI₂₃✝ : Type u_11\np✝ : Prod I₂ I₃ → I₂₃✝\nq✝ : Prod I₁ I₂₃✝ → J\nhpq✝ : ∀ (i : Prod I₁ (Prod I₂ I₃)), Eq (q✝ { fst := i.1, snd := p✝ i.2 }) (r i)\nI₂₃ : Type u_11\np : Prod I₂ I₃ → I₂₃\nq : Prod I₁ I₂₃ → J\nhpq : ∀ (i : Prod I₁ (Prod I₂ I₃)), Eq (q { fst := i.1, snd := p i.2 }) (r i)\nx✝ : Eq { I₂₃ := I₂₃✝, p := p✝, q := q✝, hpq := hpq✝ } { I₂₃ := I₂₃, p := p, q := q, hpq := hpq }\n⊢ And (Eq I₂₃✝ I₂₃) (And (HEq p✝ p) (HEq q✝ q))","decl":"/-- Given a map `r : I₁ × I₂ × I₃ → J`, a `BifunctorComp₂₃IndexData r` consists of the data\nof a type `I₂₃`, maps `p : I₂ × I₃ → I₂₃` and `q : I₁ × I₂₃ → J`, such that `r` is obtained\nby composition of `p` and `q`. -/\nstructure BifunctorComp₂₃IndexData where\n  /-- an auxiliary type -/\n  I₂₃ : Type*\n  /-- a map `I₂ × I₃ → I₂₃` -/\n  p : I₂ × I₃ → I₂₃\n  /-- a map `I₁ × I₂₃ → J` -/\n  q : I₁ × I₂₃ → J\n  hpq (i : I₁ × I₂ × I₃) : q ⟨i.1, p i.2⟩ = r i\n\n"}
{"name":"CategoryTheory.GradedObject.BifunctorComp₂₃IndexData.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"I₁ : Type u_7\nI₂ : Type u_8\nI₃ : Type u_9\nJ : Type u_10\nr : Prod I₁ (Prod I₂ I₃) → J\ninst✝³ : SizeOf I₁\ninst✝² : SizeOf I₂\ninst✝¹ : SizeOf I₃\ninst✝ : SizeOf J\nI₂₃ : Type u_11\np : Prod I₂ I₃ → I₂₃\nq : Prod I₁ I₂₃ → J\nhpq : ∀ (i : Prod I₁ (Prod I₂ I₃)), Eq (q { fst := i.1, snd := p i.2 }) (r i)\n⊢ Eq (SizeOf.sizeOf { I₂₃ := I₂₃, p := p, q := q, hpq := hpq }) (HAdd.hAdd 1 (SizeOf.sizeOf I₂₃))","decl":"/-- Given a map `r : I₁ × I₂ × I₃ → J`, a `BifunctorComp₂₃IndexData r` consists of the data\nof a type `I₂₃`, maps `p : I₂ × I₃ → I₂₃` and `q : I₁ × I₂₃ → J`, such that `r` is obtained\nby composition of `p` and `q`. -/\nstructure BifunctorComp₂₃IndexData where\n  /-- an auxiliary type -/\n  I₂₃ : Type*\n  /-- a map `I₂ × I₃ → I₂₃` -/\n  p : I₂ × I₃ → I₂₃\n  /-- a map `I₁ × I₂₃ → J` -/\n  q : I₁ × I₂₃ → J\n  hpq (i : I₁ × I₂ × I₃) : q ⟨i.1, p i.2⟩ = r i\n\n"}
{"name":"CategoryTheory.GradedObject.BifunctorComp₂₃IndexData.mk.injEq","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"I₁ : Type u_7\nI₂ : Type u_8\nI₃ : Type u_9\nJ : Type u_10\nr : Prod I₁ (Prod I₂ I₃) → J\nI₂₃✝ : Type u_11\np✝ : Prod I₂ I₃ → I₂₃✝\nq✝ : Prod I₁ I₂₃✝ → J\nhpq✝ : ∀ (i : Prod I₁ (Prod I₂ I₃)), Eq (q✝ { fst := i.1, snd := p✝ i.2 }) (r i)\nI₂₃ : Type u_11\np : Prod I₂ I₃ → I₂₃\nq : Prod I₁ I₂₃ → J\nhpq : ∀ (i : Prod I₁ (Prod I₂ I₃)), Eq (q { fst := i.1, snd := p i.2 }) (r i)\n⊢ Eq (Eq { I₂₃ := I₂₃✝, p := p✝, q := q✝, hpq := hpq✝ } { I₂₃ := I₂₃, p := p, q := q, hpq := hpq }) (And (Eq I₂₃✝ I₂₃) (And (HEq p✝ p) (HEq q✝ q)))","decl":"/-- Given a map `r : I₁ × I₂ × I₃ → J`, a `BifunctorComp₂₃IndexData r` consists of the data\nof a type `I₂₃`, maps `p : I₂ × I₃ → I₂₃` and `q : I₁ × I₂₃ → J`, such that `r` is obtained\nby composition of `p` and `q`. -/\nstructure BifunctorComp₂₃IndexData where\n  /-- an auxiliary type -/\n  I₂₃ : Type*\n  /-- a map `I₂ × I₃ → I₂₃` -/\n  p : I₂ × I₃ → I₂₃\n  /-- a map `I₁ × I₂₃ → J` -/\n  q : I₁ × I₂₃ → J\n  hpq (i : I₁ × I₂ × I₃) : q ⟨i.1, p i.2⟩ = r i\n\n"}
{"name":"CategoryTheory.GradedObject.BifunctorComp₂₃IndexData.hpq","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"I₁ : Type u_7\nI₂ : Type u_8\nI₃ : Type u_9\nJ : Type u_10\nr : Prod I₁ (Prod I₂ I₃) → J\nself : CategoryTheory.GradedObject.BifunctorComp₂₃IndexData r\ni : Prod I₁ (Prod I₂ I₃)\n⊢ Eq (self.q { fst := i.1, snd := self.p i.2 }) (r i)","decl":"/-- Given a map `r : I₁ × I₂ × I₃ → J`, a `BifunctorComp₂₃IndexData r` consists of the data\nof a type `I₂₃`, maps `p : I₂ × I₃ → I₂₃` and `q : I₁ × I₂₃ → J`, such that `r` is obtained\nby composition of `p` and `q`. -/\nstructure BifunctorComp₂₃IndexData where\n  /-- an auxiliary type -/\n  I₂₃ : Type*\n  /-- a map `I₂ × I₃ → I₂₃` -/\n  p : I₂ × I₃ → I₂₃\n  /-- a map `I₁ × I₂₃ → J` -/\n  q : I₁ × I₂₃ → J\n  hpq (i : I₁ × I₂ × I₃) : q ⟨i.1, p i.2⟩ = r i\n\n"}
{"name":"CategoryTheory.GradedObject.ιMapBifunctorBifunctor₂₃MapObj_eq","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\nC₂₃ : Type u_6\ninst✝⁶ : CategoryTheory.Category.{u_14, u_1} C₁\ninst✝⁵ : CategoryTheory.Category.{u_16, u_2} C₂\ninst✝⁴ : CategoryTheory.Category.{u_15, u_3} C₃\ninst✝³ : CategoryTheory.Category.{u_12, u_4} C₄\ninst✝² : CategoryTheory.Category.{u_13, u_6} C₂₃\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂₃ C₄)\nG₂₃ : CategoryTheory.Functor C₂ (CategoryTheory.Functor C₃ C₂₃)\nI₁ : Type u_7\nI₂ : Type u_8\nI₃ : Type u_9\nJ : Type u_10\nr : Prod I₁ (Prod I₂ I₃) → J\nρ₂₃ : CategoryTheory.GradedObject.BifunctorComp₂₃IndexData r\nX₁ : CategoryTheory.GradedObject I₁ C₁\nX₂ : CategoryTheory.GradedObject I₂ C₂\nX₃ : CategoryTheory.GradedObject I₃ C₃\ninst✝¹ : (((CategoryTheory.GradedObject.mapBifunctor G₂₃ I₂ I₃).obj X₂).obj X₃).HasMap ρ₂₃.p\ninst✝ : (((CategoryTheory.GradedObject.mapBifunctor F I₁ ρ₂₃.I₂₃).obj X₁).obj (CategoryTheory.GradedObject.mapBifunctorMapObj G₂₃ ρ₂₃.p X₂ X₃)).HasMap ρ₂₃.q\ni₁ : I₁\ni₂ : I₂\ni₃ : I₃\nj : J\nh : Eq (r { fst := i₁, snd := { fst := i₂, snd := i₃ } }) j\ni₂₃ : ρ₂₃.I₂₃\nh₂₃ : Eq (ρ₂₃.p { fst := i₂, snd := i₃ }) i₂₃\n⊢ Eq (CategoryTheory.GradedObject.ιMapBifunctorBifunctor₂₃MapObj F G₂₃ ρ₂₃ X₁ X₂ X₃ i₁ i₂ i₃ j h) (CategoryTheory.CategoryStruct.comp ((F.obj (X₁ i₁)).map (CategoryTheory.GradedObject.ιMapBifunctorMapObj G₂₃ ρ₂₃.p X₂ X₃ i₂ i₃ i₂₃ h₂₃)) (CategoryTheory.GradedObject.ιMapBifunctorMapObj F ρ₂₃.q X₁ (CategoryTheory.GradedObject.mapBifunctorMapObj G₂₃ ρ₂₃.p X₂ X₃) i₁ i₂₃ j ⋯))","decl":"@[reassoc]\nlemma ιMapBifunctorBifunctor₂₃MapObj_eq (i₁ : I₁) (i₂ : I₂) (i₃ : I₃) (j : J)\n    (h : r (i₁, i₂, i₃) = j) (i₂₃ : ρ₂₃.I₂₃) (h₂₃ : ρ₂₃.p ⟨i₂, i₃⟩ = i₂₃) :\n    ιMapBifunctorBifunctor₂₃MapObj F G₂₃ ρ₂₃ X₁ X₂ X₃ i₁ i₂ i₃ j h =\n  (F.obj (X₁ i₁)).map (ιMapBifunctorMapObj G₂₃ ρ₂₃.p X₂ X₃ i₂ i₃ i₂₃ h₂₃) ≫\n    ιMapBifunctorMapObj F ρ₂₃.q X₁ (mapBifunctorMapObj G₂₃ ρ₂₃.p X₂ X₃) i₁ i₂₃ j\n      (by rw [← h, ← h₂₃, ← ρ₂₃.hpq]) := by\n  subst h₂₃\n  rfl\n\n"}
{"name":"CategoryTheory.GradedObject.ιMapBifunctorBifunctor₂₃MapObj_eq_assoc","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\nC₂₃ : Type u_6\ninst✝⁶ : CategoryTheory.Category.{u_14, u_1} C₁\ninst✝⁵ : CategoryTheory.Category.{u_16, u_2} C₂\ninst✝⁴ : CategoryTheory.Category.{u_15, u_3} C₃\ninst✝³ : CategoryTheory.Category.{u_12, u_4} C₄\ninst✝² : CategoryTheory.Category.{u_13, u_6} C₂₃\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂₃ C₄)\nG₂₃ : CategoryTheory.Functor C₂ (CategoryTheory.Functor C₃ C₂₃)\nI₁ : Type u_7\nI₂ : Type u_8\nI₃ : Type u_9\nJ : Type u_10\nr : Prod I₁ (Prod I₂ I₃) → J\nρ₂₃ : CategoryTheory.GradedObject.BifunctorComp₂₃IndexData r\nX₁ : CategoryTheory.GradedObject I₁ C₁\nX₂ : CategoryTheory.GradedObject I₂ C₂\nX₃ : CategoryTheory.GradedObject I₃ C₃\ninst✝¹ : (((CategoryTheory.GradedObject.mapBifunctor G₂₃ I₂ I₃).obj X₂).obj X₃).HasMap ρ₂₃.p\ninst✝ : (((CategoryTheory.GradedObject.mapBifunctor F I₁ ρ₂₃.I₂₃).obj X₁).obj (CategoryTheory.GradedObject.mapBifunctorMapObj G₂₃ ρ₂₃.p X₂ X₃)).HasMap ρ₂₃.q\ni₁ : I₁\ni₂ : I₂\ni₃ : I₃\nj : J\nh✝ : Eq (r { fst := i₁, snd := { fst := i₂, snd := i₃ } }) j\ni₂₃ : ρ₂₃.I₂₃\nh₂₃ : Eq (ρ₂₃.p { fst := i₂, snd := i₃ }) i₂₃\nZ : C₄\nh : Quiver.Hom (CategoryTheory.GradedObject.mapBifunctorMapObj F ρ₂₃.q X₁ (CategoryTheory.GradedObject.mapBifunctorMapObj G₂₃ ρ₂₃.p X₂ X₃) j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ιMapBifunctorBifunctor₂₃MapObj F G₂₃ ρ₂₃ X₁ X₂ X₃ i₁ i₂ i₃ j h✝) h) (CategoryTheory.CategoryStruct.comp ((F.obj (X₁ i₁)).map (CategoryTheory.GradedObject.ιMapBifunctorMapObj G₂₃ ρ₂₃.p X₂ X₃ i₂ i₃ i₂₃ h₂₃)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ιMapBifunctorMapObj F ρ₂₃.q X₁ (CategoryTheory.GradedObject.mapBifunctorMapObj G₂₃ ρ₂₃.p X₂ X₃) i₁ i₂₃ j ⋯) h))","decl":"@[reassoc]\nlemma ιMapBifunctorBifunctor₂₃MapObj_eq (i₁ : I₁) (i₂ : I₂) (i₃ : I₃) (j : J)\n    (h : r (i₁, i₂, i₃) = j) (i₂₃ : ρ₂₃.I₂₃) (h₂₃ : ρ₂₃.p ⟨i₂, i₃⟩ = i₂₃) :\n    ιMapBifunctorBifunctor₂₃MapObj F G₂₃ ρ₂₃ X₁ X₂ X₃ i₁ i₂ i₃ j h =\n  (F.obj (X₁ i₁)).map (ιMapBifunctorMapObj G₂₃ ρ₂₃.p X₂ X₃ i₂ i₃ i₂₃ h₂₃) ≫\n    ιMapBifunctorMapObj F ρ₂₃.q X₁ (mapBifunctorMapObj G₂₃ ρ₂₃.p X₂ X₃) i₁ i₂₃ j\n      (by rw [← h, ← h₂₃, ← ρ₂₃.hpq]) := by\n  subst h₂₃\n  rfl\n\n"}
{"name":"CategoryTheory.GradedObject.HasGoodTrifunctor₂₃Obj.hasMap","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\nC₂₃ : Type u_6\ninst✝⁶ : CategoryTheory.Category.{u_14, u_1} C₁\ninst✝⁵ : CategoryTheory.Category.{u_13, u_2} C₂\ninst✝⁴ : CategoryTheory.Category.{u_12, u_3} C₃\ninst✝³ : CategoryTheory.Category.{u_11, u_4} C₄\ninst✝² : CategoryTheory.Category.{u_15, u_6} C₂₃\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂₃ C₄)\nG₂₃ : CategoryTheory.Functor C₂ (CategoryTheory.Functor C₃ C₂₃)\nI₁ : Type u_7\nI₂ : Type u_8\nI₃ : Type u_9\nJ : Type u_10\nr : Prod I₁ (Prod I₂ I₃) → J\nρ₂₃ : CategoryTheory.GradedObject.BifunctorComp₂₃IndexData r\nX₁ : CategoryTheory.GradedObject I₁ C₁\nX₂ : CategoryTheory.GradedObject I₂ C₂\nX₃ : CategoryTheory.GradedObject I₃ C₃\ninst✝¹ : (((CategoryTheory.GradedObject.mapBifunctor G₂₃ I₂ I₃).obj X₂).obj X₃).HasMap ρ₂₃.p\ninst✝ : (((CategoryTheory.GradedObject.mapBifunctor F I₁ ρ₂₃.I₂₃).obj X₁).obj (CategoryTheory.GradedObject.mapBifunctorMapObj G₂₃ ρ₂₃.p X₂ X₃)).HasMap ρ₂₃.q\nH : CategoryTheory.GradedObject.HasGoodTrifunctor₂₃Obj F G₂₃ ρ₂₃ X₁ X₂ X₃\n⊢ ((((CategoryTheory.GradedObject.mapTrifunctor (CategoryTheory.bifunctorComp₂₃ F G₂₃) I₁ I₂ I₃).obj X₁).obj X₂).obj X₃).HasMap r","decl":"include ρ₂₃ in\nlemma HasGoodTrifunctor₂₃Obj.hasMap :\n    HasMap ((((mapTrifunctor (bifunctorComp₂₃ F G₂₃) I₁ I₂ I₃).obj X₁).obj X₂).obj X₃) r :=\n  fun j => ⟨_, isColimitCofan₃MapBifunctorBifunctor₂₃MapObj F G₂₃ ρ₂₃ X₁ X₂ X₃ j⟩\n\n"}
{"name":"CategoryTheory.GradedObject.ι_mapBifunctorComp₂₃MapObjIso_hom","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\nC₂₃ : Type u_6\ninst✝⁷ : CategoryTheory.Category.{u_14, u_1} C₁\ninst✝⁶ : CategoryTheory.Category.{u_13, u_2} C₂\ninst✝⁵ : CategoryTheory.Category.{u_12, u_3} C₃\ninst✝⁴ : CategoryTheory.Category.{u_11, u_4} C₄\ninst✝³ : CategoryTheory.Category.{u_15, u_6} C₂₃\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂₃ C₄)\nG₂₃ : CategoryTheory.Functor C₂ (CategoryTheory.Functor C₃ C₂₃)\nI₁ : Type u_7\nI₂ : Type u_8\nI₃ : Type u_9\nJ : Type u_10\nr : Prod I₁ (Prod I₂ I₃) → J\nρ₂₃ : CategoryTheory.GradedObject.BifunctorComp₂₃IndexData r\nX₁ : CategoryTheory.GradedObject I₁ C₁\nX₂ : CategoryTheory.GradedObject I₂ C₂\nX₃ : CategoryTheory.GradedObject I₃ C₃\ninst✝² : (((CategoryTheory.GradedObject.mapBifunctor G₂₃ I₂ I₃).obj X₂).obj X₃).HasMap ρ₂₃.p\ninst✝¹ : (((CategoryTheory.GradedObject.mapBifunctor F I₁ ρ₂₃.I₂₃).obj X₁).obj (CategoryTheory.GradedObject.mapBifunctorMapObj G₂₃ ρ₂₃.p X₂ X₃)).HasMap ρ₂₃.q\nH : CategoryTheory.GradedObject.HasGoodTrifunctor₂₃Obj F G₂₃ ρ₂₃ X₁ X₂ X₃\ninst✝ : ((((CategoryTheory.GradedObject.mapTrifunctor (CategoryTheory.bifunctorComp₂₃ F G₂₃) I₁ I₂ I₃).obj X₁).obj X₂).obj X₃).HasMap r\ni₁ : I₁\ni₂ : I₂\ni₃ : I₃\nj : J\nh : Eq (r { fst := i₁, snd := { fst := i₂, snd := i₃ } }) j\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ιMapTrifunctorMapObj (CategoryTheory.bifunctorComp₂₃ F G₂₃) r X₁ X₂ X₃ i₁ i₂ i₃ j h) ((CategoryTheory.GradedObject.mapBifunctorComp₂₃MapObjIso F G₂₃ ρ₂₃ X₁ X₂ X₃).hom j)) (CategoryTheory.GradedObject.ιMapBifunctorBifunctor₂₃MapObj F G₂₃ ρ₂₃ X₁ X₂ X₃ i₁ i₂ i₃ j h)","decl":"@[reassoc (attr := simp)]\nlemma ι_mapBifunctorComp₂₃MapObjIso_hom (i₁ : I₁) (i₂ : I₂) (i₃ : I₃) (j : J)\n    (h : r (i₁, i₂, i₃) = j) :\n    ιMapTrifunctorMapObj (bifunctorComp₂₃ F G₂₃) r X₁ X₂ X₃ i₁ i₂ i₃ j h ≫\n      (mapBifunctorComp₂₃MapObjIso F G₂₃ ρ₂₃ X₁ X₂ X₃).hom j =\n      ιMapBifunctorBifunctor₂₃MapObj F G₂₃ ρ₂₃ X₁ X₂ X₃ i₁ i₂ i₃ j h := by\n  dsimp [mapBifunctorComp₂₃MapObjIso]\n  apply CofanMapObjFun.ιMapObj_iso_inv\n\n"}
{"name":"CategoryTheory.GradedObject.ι_mapBifunctorComp₂₃MapObjIso_hom_assoc","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\nC₂₃ : Type u_6\ninst✝⁷ : CategoryTheory.Category.{u_14, u_1} C₁\ninst✝⁶ : CategoryTheory.Category.{u_13, u_2} C₂\ninst✝⁵ : CategoryTheory.Category.{u_12, u_3} C₃\ninst✝⁴ : CategoryTheory.Category.{u_11, u_4} C₄\ninst✝³ : CategoryTheory.Category.{u_15, u_6} C₂₃\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂₃ C₄)\nG₂₃ : CategoryTheory.Functor C₂ (CategoryTheory.Functor C₃ C₂₃)\nI₁ : Type u_7\nI₂ : Type u_8\nI₃ : Type u_9\nJ : Type u_10\nr : Prod I₁ (Prod I₂ I₃) → J\nρ₂₃ : CategoryTheory.GradedObject.BifunctorComp₂₃IndexData r\nX₁ : CategoryTheory.GradedObject I₁ C₁\nX₂ : CategoryTheory.GradedObject I₂ C₂\nX₃ : CategoryTheory.GradedObject I₃ C₃\ninst✝² : (((CategoryTheory.GradedObject.mapBifunctor G₂₃ I₂ I₃).obj X₂).obj X₃).HasMap ρ₂₃.p\ninst✝¹ : (((CategoryTheory.GradedObject.mapBifunctor F I₁ ρ₂₃.I₂₃).obj X₁).obj (CategoryTheory.GradedObject.mapBifunctorMapObj G₂₃ ρ₂₃.p X₂ X₃)).HasMap ρ₂₃.q\nH : CategoryTheory.GradedObject.HasGoodTrifunctor₂₃Obj F G₂₃ ρ₂₃ X₁ X₂ X₃\ninst✝ : ((((CategoryTheory.GradedObject.mapTrifunctor (CategoryTheory.bifunctorComp₂₃ F G₂₃) I₁ I₂ I₃).obj X₁).obj X₂).obj X₃).HasMap r\ni₁ : I₁\ni₂ : I₂\ni₃ : I₃\nj : J\nh✝ : Eq (r { fst := i₁, snd := { fst := i₂, snd := i₃ } }) j\nZ : C₄\nh : Quiver.Hom (CategoryTheory.GradedObject.mapBifunctorMapObj F ρ₂₃.q X₁ (CategoryTheory.GradedObject.mapBifunctorMapObj G₂₃ ρ₂₃.p X₂ X₃) j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ιMapTrifunctorMapObj (CategoryTheory.bifunctorComp₂₃ F G₂₃) r X₁ X₂ X₃ i₁ i₂ i₃ j h✝) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.GradedObject.mapBifunctorComp₂₃MapObjIso F G₂₃ ρ₂₃ X₁ X₂ X₃).hom j) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ιMapBifunctorBifunctor₂₃MapObj F G₂₃ ρ₂₃ X₁ X₂ X₃ i₁ i₂ i₃ j h✝) h)","decl":"@[reassoc (attr := simp)]\nlemma ι_mapBifunctorComp₂₃MapObjIso_hom (i₁ : I₁) (i₂ : I₂) (i₃ : I₃) (j : J)\n    (h : r (i₁, i₂, i₃) = j) :\n    ιMapTrifunctorMapObj (bifunctorComp₂₃ F G₂₃) r X₁ X₂ X₃ i₁ i₂ i₃ j h ≫\n      (mapBifunctorComp₂₃MapObjIso F G₂₃ ρ₂₃ X₁ X₂ X₃).hom j =\n      ιMapBifunctorBifunctor₂₃MapObj F G₂₃ ρ₂₃ X₁ X₂ X₃ i₁ i₂ i₃ j h := by\n  dsimp [mapBifunctorComp₂₃MapObjIso]\n  apply CofanMapObjFun.ιMapObj_iso_inv\n\n"}
{"name":"CategoryTheory.GradedObject.ι_mapBifunctorComp₂₃MapObjIso_inv","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\nC₂₃ : Type u_6\ninst✝⁷ : CategoryTheory.Category.{u_13, u_1} C₁\ninst✝⁶ : CategoryTheory.Category.{u_15, u_2} C₂\ninst✝⁵ : CategoryTheory.Category.{u_14, u_3} C₃\ninst✝⁴ : CategoryTheory.Category.{u_11, u_4} C₄\ninst✝³ : CategoryTheory.Category.{u_12, u_6} C₂₃\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂₃ C₄)\nG₂₃ : CategoryTheory.Functor C₂ (CategoryTheory.Functor C₃ C₂₃)\nI₁ : Type u_7\nI₂ : Type u_8\nI₃ : Type u_9\nJ : Type u_10\nr : Prod I₁ (Prod I₂ I₃) → J\nρ₂₃ : CategoryTheory.GradedObject.BifunctorComp₂₃IndexData r\nX₁ : CategoryTheory.GradedObject I₁ C₁\nX₂ : CategoryTheory.GradedObject I₂ C₂\nX₃ : CategoryTheory.GradedObject I₃ C₃\ninst✝² : (((CategoryTheory.GradedObject.mapBifunctor G₂₃ I₂ I₃).obj X₂).obj X₃).HasMap ρ₂₃.p\ninst✝¹ : (((CategoryTheory.GradedObject.mapBifunctor F I₁ ρ₂₃.I₂₃).obj X₁).obj (CategoryTheory.GradedObject.mapBifunctorMapObj G₂₃ ρ₂₃.p X₂ X₃)).HasMap ρ₂₃.q\nH : CategoryTheory.GradedObject.HasGoodTrifunctor₂₃Obj F G₂₃ ρ₂₃ X₁ X₂ X₃\ninst✝ : ((((CategoryTheory.GradedObject.mapTrifunctor (CategoryTheory.bifunctorComp₂₃ F G₂₃) I₁ I₂ I₃).obj X₁).obj X₂).obj X₃).HasMap r\ni₁ : I₁\ni₂ : I₂\ni₃ : I₃\nj : J\nh : Eq (r { fst := i₁, snd := { fst := i₂, snd := i₃ } }) j\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ιMapBifunctorBifunctor₂₃MapObj F G₂₃ ρ₂₃ X₁ X₂ X₃ i₁ i₂ i₃ j h) ((CategoryTheory.GradedObject.mapBifunctorComp₂₃MapObjIso F G₂₃ ρ₂₃ X₁ X₂ X₃).inv j)) (CategoryTheory.GradedObject.ιMapTrifunctorMapObj (CategoryTheory.bifunctorComp₂₃ F G₂₃) r X₁ X₂ X₃ i₁ i₂ i₃ j h)","decl":"@[reassoc (attr := simp)]\nlemma ι_mapBifunctorComp₂₃MapObjIso_inv (i₁ : I₁) (i₂ : I₂) (i₃ : I₃) (j : J)\n    (h : r (i₁, i₂, i₃) = j) :\n    ιMapBifunctorBifunctor₂₃MapObj F G₂₃ ρ₂₃ X₁ X₂ X₃ i₁ i₂ i₃ j h ≫\n      (mapBifunctorComp₂₃MapObjIso F G₂₃ ρ₂₃ X₁ X₂ X₃).inv j =\n      ιMapTrifunctorMapObj (bifunctorComp₂₃ F G₂₃) r X₁ X₂ X₃ i₁ i₂ i₃ j h :=\n  CofanMapObjFun.inj_iso_hom\n    (isColimitCofan₃MapBifunctorBifunctor₂₃MapObj F G₂₃ ρ₂₃ X₁ X₂ X₃ j) _ h\n\n"}
{"name":"CategoryTheory.GradedObject.ι_mapBifunctorComp₂₃MapObjIso_inv_assoc","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\nC₂₃ : Type u_6\ninst✝⁷ : CategoryTheory.Category.{u_13, u_1} C₁\ninst✝⁶ : CategoryTheory.Category.{u_15, u_2} C₂\ninst✝⁵ : CategoryTheory.Category.{u_14, u_3} C₃\ninst✝⁴ : CategoryTheory.Category.{u_11, u_4} C₄\ninst✝³ : CategoryTheory.Category.{u_12, u_6} C₂₃\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂₃ C₄)\nG₂₃ : CategoryTheory.Functor C₂ (CategoryTheory.Functor C₃ C₂₃)\nI₁ : Type u_7\nI₂ : Type u_8\nI₃ : Type u_9\nJ : Type u_10\nr : Prod I₁ (Prod I₂ I₃) → J\nρ₂₃ : CategoryTheory.GradedObject.BifunctorComp₂₃IndexData r\nX₁ : CategoryTheory.GradedObject I₁ C₁\nX₂ : CategoryTheory.GradedObject I₂ C₂\nX₃ : CategoryTheory.GradedObject I₃ C₃\ninst✝² : (((CategoryTheory.GradedObject.mapBifunctor G₂₃ I₂ I₃).obj X₂).obj X₃).HasMap ρ₂₃.p\ninst✝¹ : (((CategoryTheory.GradedObject.mapBifunctor F I₁ ρ₂₃.I₂₃).obj X₁).obj (CategoryTheory.GradedObject.mapBifunctorMapObj G₂₃ ρ₂₃.p X₂ X₃)).HasMap ρ₂₃.q\nH : CategoryTheory.GradedObject.HasGoodTrifunctor₂₃Obj F G₂₃ ρ₂₃ X₁ X₂ X₃\ninst✝ : ((((CategoryTheory.GradedObject.mapTrifunctor (CategoryTheory.bifunctorComp₂₃ F G₂₃) I₁ I₂ I₃).obj X₁).obj X₂).obj X₃).HasMap r\ni₁ : I₁\ni₂ : I₂\ni₃ : I₃\nj : J\nh✝ : Eq (r { fst := i₁, snd := { fst := i₂, snd := i₃ } }) j\nZ : C₄\nh : Quiver.Hom (CategoryTheory.GradedObject.mapTrifunctorMapObj (CategoryTheory.bifunctorComp₂₃ F G₂₃) r X₁ X₂ X₃ j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ιMapBifunctorBifunctor₂₃MapObj F G₂₃ ρ₂₃ X₁ X₂ X₃ i₁ i₂ i₃ j h✝) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.GradedObject.mapBifunctorComp₂₃MapObjIso F G₂₃ ρ₂₃ X₁ X₂ X₃).inv j) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ιMapTrifunctorMapObj (CategoryTheory.bifunctorComp₂₃ F G₂₃) r X₁ X₂ X₃ i₁ i₂ i₃ j h✝) h)","decl":"@[reassoc (attr := simp)]\nlemma ι_mapBifunctorComp₂₃MapObjIso_inv (i₁ : I₁) (i₂ : I₂) (i₃ : I₃) (j : J)\n    (h : r (i₁, i₂, i₃) = j) :\n    ιMapBifunctorBifunctor₂₃MapObj F G₂₃ ρ₂₃ X₁ X₂ X₃ i₁ i₂ i₃ j h ≫\n      (mapBifunctorComp₂₃MapObjIso F G₂₃ ρ₂₃ X₁ X₂ X₃).inv j =\n      ιMapTrifunctorMapObj (bifunctorComp₂₃ F G₂₃) r X₁ X₂ X₃ i₁ i₂ i₃ j h :=\n  CofanMapObjFun.inj_iso_hom\n    (isColimitCofan₃MapBifunctorBifunctor₂₃MapObj F G₂₃ ρ₂₃ X₁ X₂ X₃ j) _ h\n\n"}
{"name":"CategoryTheory.GradedObject.mapBifunctorBifunctor₂₃MapObj_ext_iff","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\nC₂₃ : Type u_6\ninst✝⁶ : CategoryTheory.Category.{u_13, u_1} C₁\ninst✝⁵ : CategoryTheory.Category.{u_15, u_2} C₂\ninst✝⁴ : CategoryTheory.Category.{u_16, u_3} C₃\ninst✝³ : CategoryTheory.Category.{u_11, u_4} C₄\ninst✝² : CategoryTheory.Category.{u_14, u_6} C₂₃\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂₃ C₄)\nG₂₃ : CategoryTheory.Functor C₂ (CategoryTheory.Functor C₃ C₂₃)\nI₁ : Type u_7\nI₂ : Type u_8\nI₃ : Type u_9\nJ : Type u_10\nr : Prod I₁ (Prod I₂ I₃) → J\nρ₂₃ : CategoryTheory.GradedObject.BifunctorComp₂₃IndexData r\nX₁ : CategoryTheory.GradedObject I₁ C₁\nX₂ : CategoryTheory.GradedObject I₂ C₂\nX₃ : CategoryTheory.GradedObject I₃ C₃\ninst✝¹ : (((CategoryTheory.GradedObject.mapBifunctor G₂₃ I₂ I₃).obj X₂).obj X₃).HasMap ρ₂₃.p\ninst✝ : (((CategoryTheory.GradedObject.mapBifunctor F I₁ ρ₂₃.I₂₃).obj X₁).obj (CategoryTheory.GradedObject.mapBifunctorMapObj G₂₃ ρ₂₃.p X₂ X₃)).HasMap ρ₂₃.q\nH : CategoryTheory.GradedObject.HasGoodTrifunctor₂₃Obj F G₂₃ ρ₂₃ X₁ X₂ X₃\nj : J\nA : C₄\nf g : Quiver.Hom (CategoryTheory.GradedObject.mapBifunctorMapObj F ρ₂₃.q X₁ (CategoryTheory.GradedObject.mapBifunctorMapObj G₂₃ ρ₂₃.p X₂ X₃) j) A\n⊢ Iff (Eq f g) (∀ (i₁ : I₁) (i₂ : I₂) (i₃ : I₃) (h : Eq (r { fst := i₁, snd := { fst := i₂, snd := i₃ } }) j), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ιMapBifunctorBifunctor₂₃MapObj F G₂₃ ρ₂₃ X₁ X₂ X₃ i₁ i₂ i₃ j h) f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ιMapBifunctorBifunctor₂₃MapObj F G₂₃ ρ₂₃ X₁ X₂ X₃ i₁ i₂ i₃ j h) g))","decl":"@[ext]\nlemma mapBifunctorBifunctor₂₃MapObj_ext\n    {f g : mapBifunctorMapObj F ρ₂₃.q X₁ (mapBifunctorMapObj G₂₃ ρ₂₃.p X₂ X₃) j ⟶ A}\n    (h : ∀ (i₁ : I₁) (i₂ : I₂) (i₃ : I₃) (h : r ⟨i₁, i₂, i₃⟩ = j),\n      ιMapBifunctorBifunctor₂₃MapObj F G₂₃ ρ₂₃ X₁ X₂ X₃ i₁ i₂ i₃ j h ≫ f =\n        ιMapBifunctorBifunctor₂₃MapObj F G₂₃ ρ₂₃ X₁ X₂ X₃ i₁ i₂ i₃ j h ≫ g) : f = g := by\n  apply Cofan.IsColimit.hom_ext (isColimitCofan₃MapBifunctorBifunctor₂₃MapObj F G₂₃ ρ₂₃ X₁ X₂ X₃ j)\n  rintro ⟨i, hi⟩\n  exact h _ _ _ hi\n\n"}
{"name":"CategoryTheory.GradedObject.mapBifunctorBifunctor₂₃MapObj_ext","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\nC₂₃ : Type u_6\ninst✝⁶ : CategoryTheory.Category.{u_13, u_1} C₁\ninst✝⁵ : CategoryTheory.Category.{u_15, u_2} C₂\ninst✝⁴ : CategoryTheory.Category.{u_16, u_3} C₃\ninst✝³ : CategoryTheory.Category.{u_11, u_4} C₄\ninst✝² : CategoryTheory.Category.{u_14, u_6} C₂₃\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂₃ C₄)\nG₂₃ : CategoryTheory.Functor C₂ (CategoryTheory.Functor C₃ C₂₃)\nI₁ : Type u_7\nI₂ : Type u_8\nI₃ : Type u_9\nJ : Type u_10\nr : Prod I₁ (Prod I₂ I₃) → J\nρ₂₃ : CategoryTheory.GradedObject.BifunctorComp₂₃IndexData r\nX₁ : CategoryTheory.GradedObject I₁ C₁\nX₂ : CategoryTheory.GradedObject I₂ C₂\nX₃ : CategoryTheory.GradedObject I₃ C₃\ninst✝¹ : (((CategoryTheory.GradedObject.mapBifunctor G₂₃ I₂ I₃).obj X₂).obj X₃).HasMap ρ₂₃.p\ninst✝ : (((CategoryTheory.GradedObject.mapBifunctor F I₁ ρ₂₃.I₂₃).obj X₁).obj (CategoryTheory.GradedObject.mapBifunctorMapObj G₂₃ ρ₂₃.p X₂ X₃)).HasMap ρ₂₃.q\nH : CategoryTheory.GradedObject.HasGoodTrifunctor₂₃Obj F G₂₃ ρ₂₃ X₁ X₂ X₃\nj : J\nA : C₄\nf g : Quiver.Hom (CategoryTheory.GradedObject.mapBifunctorMapObj F ρ₂₃.q X₁ (CategoryTheory.GradedObject.mapBifunctorMapObj G₂₃ ρ₂₃.p X₂ X₃) j) A\nh : ∀ (i₁ : I₁) (i₂ : I₂) (i₃ : I₃) (h : Eq (r { fst := i₁, snd := { fst := i₂, snd := i₃ } }) j), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ιMapBifunctorBifunctor₂₃MapObj F G₂₃ ρ₂₃ X₁ X₂ X₃ i₁ i₂ i₃ j h) f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ιMapBifunctorBifunctor₂₃MapObj F G₂₃ ρ₂₃ X₁ X₂ X₃ i₁ i₂ i₃ j h) g)\n⊢ Eq f g","decl":"@[ext]\nlemma mapBifunctorBifunctor₂₃MapObj_ext\n    {f g : mapBifunctorMapObj F ρ₂₃.q X₁ (mapBifunctorMapObj G₂₃ ρ₂₃.p X₂ X₃) j ⟶ A}\n    (h : ∀ (i₁ : I₁) (i₂ : I₂) (i₃ : I₃) (h : r ⟨i₁, i₂, i₃⟩ = j),\n      ιMapBifunctorBifunctor₂₃MapObj F G₂₃ ρ₂₃ X₁ X₂ X₃ i₁ i₂ i₃ j h ≫ f =\n        ιMapBifunctorBifunctor₂₃MapObj F G₂₃ ρ₂₃ X₁ X₂ X₃ i₁ i₂ i₃ j h ≫ g) : f = g := by\n  apply Cofan.IsColimit.hom_ext (isColimitCofan₃MapBifunctorBifunctor₂₃MapObj F G₂₃ ρ₂₃ X₁ X₂ X₃ j)\n  rintro ⟨i, hi⟩\n  exact h _ _ _ hi\n\n"}
{"name":"CategoryTheory.GradedObject.ι_mapBifunctorBifunctor₂₃Desc","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\nC₂₃ : Type u_6\ninst✝⁶ : CategoryTheory.Category.{u_13, u_1} C₁\ninst✝⁵ : CategoryTheory.Category.{u_15, u_2} C₂\ninst✝⁴ : CategoryTheory.Category.{u_14, u_3} C₃\ninst✝³ : CategoryTheory.Category.{u_11, u_4} C₄\ninst✝² : CategoryTheory.Category.{u_12, u_6} C₂₃\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂₃ C₄)\nG₂₃ : CategoryTheory.Functor C₂ (CategoryTheory.Functor C₃ C₂₃)\nI₁ : Type u_7\nI₂ : Type u_8\nI₃ : Type u_9\nJ : Type u_10\nr : Prod I₁ (Prod I₂ I₃) → J\nρ₂₃ : CategoryTheory.GradedObject.BifunctorComp₂₃IndexData r\nX₁ : CategoryTheory.GradedObject I₁ C₁\nX₂ : CategoryTheory.GradedObject I₂ C₂\nX₃ : CategoryTheory.GradedObject I₃ C₃\ninst✝¹ : (((CategoryTheory.GradedObject.mapBifunctor G₂₃ I₂ I₃).obj X₂).obj X₃).HasMap ρ₂₃.p\ninst✝ : (((CategoryTheory.GradedObject.mapBifunctor F I₁ ρ₂₃.I₂₃).obj X₁).obj (CategoryTheory.GradedObject.mapBifunctorMapObj G₂₃ ρ₂₃.p X₂ X₃)).HasMap ρ₂₃.q\nH : CategoryTheory.GradedObject.HasGoodTrifunctor₂₃Obj F G₂₃ ρ₂₃ X₁ X₂ X₃\nj : J\nA : C₄\nf : (i₁ : I₁) → (i₂ : I₂) → (i₃ : I₃) → Eq (r { fst := i₁, snd := { fst := i₂, snd := i₃ } }) j → Quiver.Hom ((F.obj (X₁ i₁)).obj ((G₂₃.obj (X₂ i₂)).obj (X₃ i₃))) A\ni₁ : I₁\ni₂ : I₂\ni₃ : I₃\nh : Eq (r { fst := i₁, snd := { fst := i₂, snd := i₃ } }) j\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ιMapBifunctorBifunctor₂₃MapObj F G₂₃ ρ₂₃ X₁ X₂ X₃ i₁ i₂ i₃ j h) (CategoryTheory.GradedObject.mapBifunctorBifunctor₂₃Desc f)) (f i₁ i₂ i₃ h)","decl":"@[reassoc (attr := simp)]\nlemma ι_mapBifunctorBifunctor₂₃Desc\n    (i₁ : I₁) (i₂ : I₂) (i₃ : I₃) (h : r ⟨i₁, i₂, i₃⟩ = j) :\n    ιMapBifunctorBifunctor₂₃MapObj F G₂₃ ρ₂₃ X₁ X₂ X₃ i₁ i₂ i₃ j h ≫\n      mapBifunctorBifunctor₂₃Desc f = f i₁ i₂ i₃ h :=\n  Cofan.IsColimit.fac\n    (isColimitCofan₃MapBifunctorBifunctor₂₃MapObj F G₂₃ ρ₂₃ X₁ X₂ X₃ j) _ ⟨_, h⟩\n\n"}
{"name":"CategoryTheory.GradedObject.ι_mapBifunctorBifunctor₂₃Desc_assoc","module":"Mathlib.CategoryTheory.GradedObject.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\nC₂₃ : Type u_6\ninst✝⁶ : CategoryTheory.Category.{u_13, u_1} C₁\ninst✝⁵ : CategoryTheory.Category.{u_15, u_2} C₂\ninst✝⁴ : CategoryTheory.Category.{u_14, u_3} C₃\ninst✝³ : CategoryTheory.Category.{u_11, u_4} C₄\ninst✝² : CategoryTheory.Category.{u_12, u_6} C₂₃\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂₃ C₄)\nG₂₃ : CategoryTheory.Functor C₂ (CategoryTheory.Functor C₃ C₂₃)\nI₁ : Type u_7\nI₂ : Type u_8\nI₃ : Type u_9\nJ : Type u_10\nr : Prod I₁ (Prod I₂ I₃) → J\nρ₂₃ : CategoryTheory.GradedObject.BifunctorComp₂₃IndexData r\nX₁ : CategoryTheory.GradedObject I₁ C₁\nX₂ : CategoryTheory.GradedObject I₂ C₂\nX₃ : CategoryTheory.GradedObject I₃ C₃\ninst✝¹ : (((CategoryTheory.GradedObject.mapBifunctor G₂₃ I₂ I₃).obj X₂).obj X₃).HasMap ρ₂₃.p\ninst✝ : (((CategoryTheory.GradedObject.mapBifunctor F I₁ ρ₂₃.I₂₃).obj X₁).obj (CategoryTheory.GradedObject.mapBifunctorMapObj G₂₃ ρ₂₃.p X₂ X₃)).HasMap ρ₂₃.q\nH : CategoryTheory.GradedObject.HasGoodTrifunctor₂₃Obj F G₂₃ ρ₂₃ X₁ X₂ X₃\nj : J\nA : C₄\nf : (i₁ : I₁) → (i₂ : I₂) → (i₃ : I₃) → Eq (r { fst := i₁, snd := { fst := i₂, snd := i₃ } }) j → Quiver.Hom ((F.obj (X₁ i₁)).obj ((G₂₃.obj (X₂ i₂)).obj (X₃ i₃))) A\ni₁ : I₁\ni₂ : I₂\ni₃ : I₃\nh✝ : Eq (r { fst := i₁, snd := { fst := i₂, snd := i₃ } }) j\nZ : C₄\nh : Quiver.Hom A Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ιMapBifunctorBifunctor₂₃MapObj F G₂₃ ρ₂₃ X₁ X₂ X₃ i₁ i₂ i₃ j h✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.mapBifunctorBifunctor₂₃Desc f) h)) (CategoryTheory.CategoryStruct.comp (f i₁ i₂ i₃ h✝) h)","decl":"@[reassoc (attr := simp)]\nlemma ι_mapBifunctorBifunctor₂₃Desc\n    (i₁ : I₁) (i₂ : I₂) (i₃ : I₃) (h : r ⟨i₁, i₂, i₃⟩ = j) :\n    ιMapBifunctorBifunctor₂₃MapObj F G₂₃ ρ₂₃ X₁ X₂ X₃ i₁ i₂ i₃ j h ≫\n      mapBifunctorBifunctor₂₃Desc f = f i₁ i₂ i₃ h :=\n  Cofan.IsColimit.fac\n    (isColimitCofan₃MapBifunctorBifunctor₂₃MapObj F G₂₃ ρ₂₃ X₁ X₂ X₃ j) _ ⟨_, h⟩\n\n"}
