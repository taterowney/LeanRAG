{"name":"Nat.Primes.coe_pnat_nat","module":"Mathlib.Data.PNat.Prime","initialProofState":"p : Nat.Primes\n⊢ Eq ↑↑p ↑p","decl":"@[norm_cast]\ntheorem coe_pnat_nat (p : Nat.Primes) : ((p : ℕ+) : ℕ) = p :=\n  rfl\n\n"}
{"name":"Nat.Primes.coe_pnat_injective","module":"Mathlib.Data.PNat.Prime","initialProofState":"⊢ Function.Injective Nat.Primes.toPNat","decl":"theorem coe_pnat_injective : Function.Injective ((↑) : Nat.Primes → ℕ+) := fun p q h =>\n  Subtype.ext (by injection h)\n\n"}
{"name":"Nat.Primes.coe_pnat_inj","module":"Mathlib.Data.PNat.Prime","initialProofState":"p q : Nat.Primes\n⊢ Iff (Eq ↑p ↑q) (Eq p q)","decl":"@[norm_cast]\ntheorem coe_pnat_inj (p q : Nat.Primes) : (p : ℕ+) = (q : ℕ+) ↔ p = q :=\n  coe_pnat_injective.eq_iff\n\n"}
{"name":"PNat.gcd_coe","module":"Mathlib.Data.PNat.Prime","initialProofState":"n m : PNat\n⊢ Eq (↑(n.gcd m)) ((↑n).gcd ↑m)","decl":"@[simp, norm_cast]\ntheorem gcd_coe (n m : ℕ+) : (gcd n m : ℕ) = Nat.gcd n m :=\n  rfl\n\n"}
{"name":"PNat.lcm_coe","module":"Mathlib.Data.PNat.Prime","initialProofState":"n m : PNat\n⊢ Eq (↑(n.lcm m)) ((↑n).lcm ↑m)","decl":"@[simp, norm_cast]\ntheorem lcm_coe (n m : ℕ+) : (lcm n m : ℕ) = Nat.lcm n m :=\n  rfl\n\n"}
{"name":"PNat.gcd_dvd_left","module":"Mathlib.Data.PNat.Prime","initialProofState":"n m : PNat\n⊢ Dvd.dvd (n.gcd m) n","decl":"theorem gcd_dvd_left (n m : ℕ+) : gcd n m ∣ n :=\n  dvd_iff.2 (Nat.gcd_dvd_left (n : ℕ) (m : ℕ))\n\n"}
{"name":"PNat.gcd_dvd_right","module":"Mathlib.Data.PNat.Prime","initialProofState":"n m : PNat\n⊢ Dvd.dvd (n.gcd m) m","decl":"theorem gcd_dvd_right (n m : ℕ+) : gcd n m ∣ m :=\n  dvd_iff.2 (Nat.gcd_dvd_right (n : ℕ) (m : ℕ))\n\n"}
{"name":"PNat.dvd_gcd","module":"Mathlib.Data.PNat.Prime","initialProofState":"m n k : PNat\nhm : Dvd.dvd k m\nhn : Dvd.dvd k n\n⊢ Dvd.dvd k (m.gcd n)","decl":"theorem dvd_gcd {m n k : ℕ+} (hm : k ∣ m) (hn : k ∣ n) : k ∣ gcd m n :=\n  dvd_iff.2 (Nat.dvd_gcd (dvd_iff.1 hm) (dvd_iff.1 hn))\n\n"}
{"name":"PNat.dvd_lcm_left","module":"Mathlib.Data.PNat.Prime","initialProofState":"n m : PNat\n⊢ Dvd.dvd n (n.lcm m)","decl":"theorem dvd_lcm_left (n m : ℕ+) : n ∣ lcm n m :=\n  dvd_iff.2 (Nat.dvd_lcm_left (n : ℕ) (m : ℕ))\n\n"}
{"name":"PNat.dvd_lcm_right","module":"Mathlib.Data.PNat.Prime","initialProofState":"n m : PNat\n⊢ Dvd.dvd m (n.lcm m)","decl":"theorem dvd_lcm_right (n m : ℕ+) : m ∣ lcm n m :=\n  dvd_iff.2 (Nat.dvd_lcm_right (n : ℕ) (m : ℕ))\n\n"}
{"name":"PNat.lcm_dvd","module":"Mathlib.Data.PNat.Prime","initialProofState":"m n k : PNat\nhm : Dvd.dvd m k\nhn : Dvd.dvd n k\n⊢ Dvd.dvd (m.lcm n) k","decl":"theorem lcm_dvd {m n k : ℕ+} (hm : m ∣ k) (hn : n ∣ k) : lcm m n ∣ k :=\n  dvd_iff.2 (@Nat.lcm_dvd (m : ℕ) (n : ℕ) (k : ℕ) (dvd_iff.1 hm) (dvd_iff.1 hn))\n\n"}
{"name":"PNat.gcd_mul_lcm","module":"Mathlib.Data.PNat.Prime","initialProofState":"n m : PNat\n⊢ Eq (HMul.hMul (n.gcd m) (n.lcm m)) (HMul.hMul n m)","decl":"theorem gcd_mul_lcm (n m : ℕ+) : gcd n m * lcm n m = n * m :=\n  Subtype.eq (Nat.gcd_mul_lcm (n : ℕ) (m : ℕ))\n\n"}
{"name":"PNat.eq_one_of_lt_two","module":"Mathlib.Data.PNat.Prime","initialProofState":"n : PNat\na✝ : LT.lt n 2\n⊢ Eq n 1","decl":"theorem eq_one_of_lt_two {n : ℕ+} : n < 2 → n = 1 := by\n  intro h; apply le_antisymm; swap\n  · apply PNat.one_le\n  · exact PNat.lt_add_one_iff.1 h\n\n"}
{"name":"PNat.Prime.one_lt","module":"Mathlib.Data.PNat.Prime","initialProofState":"p : PNat\na✝ : p.Prime\n⊢ LT.lt 1 p","decl":"theorem Prime.one_lt {p : ℕ+} : p.Prime → 1 < p :=\n  Nat.Prime.one_lt\n\n"}
{"name":"PNat.prime_two","module":"Mathlib.Data.PNat.Prime","initialProofState":"⊢ PNat.Prime 2","decl":"theorem prime_two : (2 : ℕ+).Prime :=\n  Nat.prime_two\n\n"}
{"name":"PNat.instFactPrimeValOfPrime","module":"Mathlib.Data.PNat.Prime","initialProofState":"p : PNat\nh : Fact p.Prime\n⊢ Fact (Nat.Prime ↑p)","decl":"instance {p : ℕ+} [h : Fact p.Prime] : Fact (p : ℕ).Prime := h\n\n"}
{"name":"PNat.fact_prime_two","module":"Mathlib.Data.PNat.Prime","initialProofState":"⊢ Fact (PNat.Prime 2)","decl":"instance fact_prime_two : Fact (2 : ℕ+).Prime :=\n  ⟨prime_two⟩\n\n"}
{"name":"PNat.prime_three","module":"Mathlib.Data.PNat.Prime","initialProofState":"⊢ PNat.Prime 3","decl":"theorem prime_three : (3 : ℕ+).Prime :=\n  Nat.prime_three\n\n"}
{"name":"PNat.fact_prime_three","module":"Mathlib.Data.PNat.Prime","initialProofState":"⊢ Fact (PNat.Prime 3)","decl":"instance fact_prime_three : Fact (3 : ℕ+).Prime :=\n  ⟨prime_three⟩\n\n"}
{"name":"PNat.prime_five","module":"Mathlib.Data.PNat.Prime","initialProofState":"⊢ PNat.Prime 5","decl":"theorem prime_five : (5 : ℕ+).Prime :=\n  Nat.prime_five\n\n"}
{"name":"PNat.fact_prime_five","module":"Mathlib.Data.PNat.Prime","initialProofState":"⊢ Fact (PNat.Prime 5)","decl":"instance fact_prime_five : Fact (5 : ℕ+).Prime :=\n  ⟨prime_five⟩\n\n"}
{"name":"PNat.dvd_prime","module":"Mathlib.Data.PNat.Prime","initialProofState":"p m : PNat\npp : p.Prime\n⊢ Iff (Dvd.dvd m p) (Or (Eq m 1) (Eq m p))","decl":"theorem dvd_prime {p m : ℕ+} (pp : p.Prime) : m ∣ p ↔ m = 1 ∨ m = p := by\n  rw [PNat.dvd_iff]\n  rw [Nat.dvd_prime pp]\n  simp\n\n"}
{"name":"PNat.Prime.ne_one","module":"Mathlib.Data.PNat.Prime","initialProofState":"p : PNat\na✝ : p.Prime\n⊢ Ne p 1","decl":"theorem Prime.ne_one {p : ℕ+} : p.Prime → p ≠ 1 := by\n  intro pp\n  intro contra\n  apply Nat.Prime.ne_one pp\n  rw [PNat.coe_eq_one_iff]\n  apply contra\n\n"}
{"name":"PNat.not_prime_one","module":"Mathlib.Data.PNat.Prime","initialProofState":"⊢ Not (PNat.Prime 1)","decl":"@[simp]\ntheorem not_prime_one : ¬(1 : ℕ+).Prime :=\n  Nat.not_prime_one\n\n"}
{"name":"PNat.Prime.not_dvd_one","module":"Mathlib.Data.PNat.Prime","initialProofState":"p : PNat\na✝ : p.Prime\n⊢ Not (Dvd.dvd p 1)","decl":"theorem Prime.not_dvd_one {p : ℕ+} : p.Prime → ¬p ∣ 1 := fun pp : p.Prime => by\n  rw [dvd_iff]\n  apply Nat.Prime.not_dvd_one pp\n\n"}
{"name":"PNat.exists_prime_and_dvd","module":"Mathlib.Data.PNat.Prime","initialProofState":"n : PNat\nhn : Ne n 1\n⊢ Exists fun p => And p.Prime (Dvd.dvd p n)","decl":"theorem exists_prime_and_dvd {n : ℕ+} (hn : n ≠ 1) : ∃ p : ℕ+, p.Prime ∧ p ∣ n := by\n  obtain ⟨p, hp⟩ := Nat.exists_prime_and_dvd (mt coe_eq_one_iff.mp hn)\n  exists (⟨p, Nat.Prime.pos hp.left⟩ : ℕ+); rw [dvd_iff]; apply hp\n\n"}
{"name":"PNat.coprime_coe","module":"Mathlib.Data.PNat.Prime","initialProofState":"m n : PNat\n⊢ Iff ((↑m).Coprime ↑n) (m.Coprime n)","decl":"@[simp, norm_cast]\ntheorem coprime_coe {m n : ℕ+} : Nat.Coprime ↑m ↑n ↔ m.Coprime n := by\n  unfold Nat.Coprime Coprime\n  rw [← coe_inj]\n  simp\n\n"}
{"name":"PNat.Coprime.mul","module":"Mathlib.Data.PNat.Prime","initialProofState":"k m n : PNat\na✝¹ : m.Coprime k\na✝ : n.Coprime k\n⊢ (HMul.hMul m n).Coprime k","decl":"theorem Coprime.mul {k m n : ℕ+} : m.Coprime k → n.Coprime k → (m * n).Coprime k := by\n  repeat rw [← coprime_coe]\n  rw [mul_coe]\n  apply Nat.Coprime.mul\n\n"}
{"name":"PNat.Coprime.mul_right","module":"Mathlib.Data.PNat.Prime","initialProofState":"k m n : PNat\na✝¹ : k.Coprime m\na✝ : k.Coprime n\n⊢ k.Coprime (HMul.hMul m n)","decl":"theorem Coprime.mul_right {k m n : ℕ+} : k.Coprime m → k.Coprime n → k.Coprime (m * n) := by\n  repeat rw [← coprime_coe]\n  rw [mul_coe]\n  apply Nat.Coprime.mul_right\n\n"}
{"name":"PNat.gcd_comm","module":"Mathlib.Data.PNat.Prime","initialProofState":"m n : PNat\n⊢ Eq (m.gcd n) (n.gcd m)","decl":"theorem gcd_comm {m n : ℕ+} : m.gcd n = n.gcd m := by\n  apply eq\n  simp only [gcd_coe]\n  apply Nat.gcd_comm\n\n"}
{"name":"PNat.gcd_eq_left_iff_dvd","module":"Mathlib.Data.PNat.Prime","initialProofState":"m n : PNat\n⊢ Iff (Dvd.dvd m n) (Eq (m.gcd n) m)","decl":"theorem gcd_eq_left_iff_dvd {m n : ℕ+} : m ∣ n ↔ m.gcd n = m := by\n  rw [dvd_iff]\n  rw [Nat.gcd_eq_left_iff_dvd]\n  rw [← coe_inj]\n  simp\n\n"}
{"name":"PNat.gcd_eq_right_iff_dvd","module":"Mathlib.Data.PNat.Prime","initialProofState":"m n : PNat\n⊢ Iff (Dvd.dvd m n) (Eq (n.gcd m) m)","decl":"theorem gcd_eq_right_iff_dvd {m n : ℕ+} : m ∣ n ↔ n.gcd m = m := by\n  rw [gcd_comm]\n  apply gcd_eq_left_iff_dvd\n\n"}
{"name":"PNat.Coprime.gcd_mul_left_cancel","module":"Mathlib.Data.PNat.Prime","initialProofState":"m n k : PNat\na✝ : k.Coprime n\n⊢ Eq ((HMul.hMul k m).gcd n) (m.gcd n)","decl":"theorem Coprime.gcd_mul_left_cancel (m : ℕ+) {n k : ℕ+} :\n    k.Coprime n → (k * m).gcd n = m.gcd n := by\n  intro h; apply eq; simp only [gcd_coe, mul_coe]\n  apply Nat.Coprime.gcd_mul_left_cancel; simpa\n\n"}
{"name":"PNat.Coprime.gcd_mul_right_cancel","module":"Mathlib.Data.PNat.Prime","initialProofState":"m n k : PNat\na✝ : k.Coprime n\n⊢ Eq ((HMul.hMul m k).gcd n) (m.gcd n)","decl":"theorem Coprime.gcd_mul_right_cancel (m : ℕ+) {n k : ℕ+} :\n    k.Coprime n → (m * k).gcd n = m.gcd n := by rw [mul_comm]; apply Coprime.gcd_mul_left_cancel\n\n"}
{"name":"PNat.Coprime.gcd_mul_left_cancel_right","module":"Mathlib.Data.PNat.Prime","initialProofState":"m n k : PNat\na✝ : k.Coprime m\n⊢ Eq (m.gcd (HMul.hMul k n)) (m.gcd n)","decl":"theorem Coprime.gcd_mul_left_cancel_right (m : ℕ+) {n k : ℕ+} :\n    k.Coprime m → m.gcd (k * n) = m.gcd n := by\n  intro h; iterate 2 rw [gcd_comm]; symm\n  apply Coprime.gcd_mul_left_cancel _ h\n\n"}
{"name":"PNat.Coprime.gcd_mul_right_cancel_right","module":"Mathlib.Data.PNat.Prime","initialProofState":"m n k : PNat\na✝ : k.Coprime m\n⊢ Eq (m.gcd (HMul.hMul n k)) (m.gcd n)","decl":"theorem Coprime.gcd_mul_right_cancel_right (m : ℕ+) {n k : ℕ+} :\n    k.Coprime m → m.gcd (n * k) = m.gcd n := by\n  rw [mul_comm]\n  apply Coprime.gcd_mul_left_cancel_right\n\n"}
{"name":"PNat.one_gcd","module":"Mathlib.Data.PNat.Prime","initialProofState":"n : PNat\n⊢ Eq (PNat.gcd 1 n) 1","decl":"@[simp]\ntheorem one_gcd {n : ℕ+} : gcd 1 n = 1 := by\n  rw [← gcd_eq_left_iff_dvd]\n  apply one_dvd\n\n"}
{"name":"PNat.gcd_one","module":"Mathlib.Data.PNat.Prime","initialProofState":"n : PNat\n⊢ Eq (n.gcd 1) 1","decl":"@[simp]\ntheorem gcd_one {n : ℕ+} : gcd n 1 = 1 := by\n  rw [gcd_comm]\n  apply one_gcd\n\n"}
{"name":"PNat.Coprime.symm","module":"Mathlib.Data.PNat.Prime","initialProofState":"m n : PNat\na✝ : m.Coprime n\n⊢ n.Coprime m","decl":"@[symm]\ntheorem Coprime.symm {m n : ℕ+} : m.Coprime n → n.Coprime m := by\n  unfold Coprime\n  rw [gcd_comm]\n  simp\n\n"}
{"name":"PNat.one_coprime","module":"Mathlib.Data.PNat.Prime","initialProofState":"n : PNat\n⊢ PNat.Coprime 1 n","decl":"@[simp]\ntheorem one_coprime {n : ℕ+} : (1 : ℕ+).Coprime n :=\n  one_gcd\n\n"}
{"name":"PNat.coprime_one","module":"Mathlib.Data.PNat.Prime","initialProofState":"n : PNat\n⊢ n.Coprime 1","decl":"@[simp]\ntheorem coprime_one {n : ℕ+} : n.Coprime 1 :=\n  Coprime.symm one_coprime\n\n"}
{"name":"PNat.Coprime.coprime_dvd_left","module":"Mathlib.Data.PNat.Prime","initialProofState":"m k n : PNat\na✝¹ : Dvd.dvd m k\na✝ : k.Coprime n\n⊢ m.Coprime n","decl":"theorem Coprime.coprime_dvd_left {m k n : ℕ+} : m ∣ k → k.Coprime n → m.Coprime n := by\n  rw [dvd_iff]\n  repeat rw [← coprime_coe]\n  apply Nat.Coprime.coprime_dvd_left\n\n"}
{"name":"PNat.Coprime.factor_eq_gcd_left","module":"Mathlib.Data.PNat.Prime","initialProofState":"a b m n : PNat\ncop : m.Coprime n\nam : Dvd.dvd a m\nbn : Dvd.dvd b n\n⊢ Eq a ((HMul.hMul a b).gcd m)","decl":"theorem Coprime.factor_eq_gcd_left {a b m n : ℕ+} (cop : m.Coprime n) (am : a ∣ m) (bn : b ∣ n) :\n    a = (a * b).gcd m := by\n  rw [gcd_eq_left_iff_dvd] at am\n  conv_lhs => rw [← am]\n  rw [eq_comm]\n  apply Coprime.gcd_mul_right_cancel a\n  apply Coprime.coprime_dvd_left bn cop.symm\n\n"}
{"name":"PNat.Coprime.factor_eq_gcd_right","module":"Mathlib.Data.PNat.Prime","initialProofState":"a b m n : PNat\ncop : m.Coprime n\nam : Dvd.dvd a m\nbn : Dvd.dvd b n\n⊢ Eq a ((HMul.hMul b a).gcd m)","decl":"theorem Coprime.factor_eq_gcd_right {a b m n : ℕ+} (cop : m.Coprime n) (am : a ∣ m) (bn : b ∣ n) :\n    a = (b * a).gcd m := by rw [mul_comm]; apply Coprime.factor_eq_gcd_left cop am bn\n\n"}
{"name":"PNat.Coprime.factor_eq_gcd_left_right","module":"Mathlib.Data.PNat.Prime","initialProofState":"a b m n : PNat\ncop : m.Coprime n\nam : Dvd.dvd a m\nbn : Dvd.dvd b n\n⊢ Eq a (m.gcd (HMul.hMul a b))","decl":"theorem Coprime.factor_eq_gcd_left_right {a b m n : ℕ+} (cop : m.Coprime n) (am : a ∣ m)\n    (bn : b ∣ n) : a = m.gcd (a * b) := by rw [gcd_comm]; apply Coprime.factor_eq_gcd_left cop am bn\n\n"}
{"name":"PNat.Coprime.factor_eq_gcd_right_right","module":"Mathlib.Data.PNat.Prime","initialProofState":"a b m n : PNat\ncop : m.Coprime n\nam : Dvd.dvd a m\nbn : Dvd.dvd b n\n⊢ Eq a (m.gcd (HMul.hMul b a))","decl":"theorem Coprime.factor_eq_gcd_right_right {a b m n : ℕ+} (cop : m.Coprime n) (am : a ∣ m)\n    (bn : b ∣ n) : a = m.gcd (b * a) := by\n  rw [gcd_comm]\n  apply Coprime.factor_eq_gcd_right cop am bn\n\n"}
{"name":"PNat.Coprime.gcd_mul","module":"Mathlib.Data.PNat.Prime","initialProofState":"k m n : PNat\nh : m.Coprime n\n⊢ Eq (k.gcd (HMul.hMul m n)) (HMul.hMul (k.gcd m) (k.gcd n))","decl":"theorem Coprime.gcd_mul (k : ℕ+) {m n : ℕ+} (h : m.Coprime n) :\n    k.gcd (m * n) = k.gcd m * k.gcd n := by\n  rw [← coprime_coe] at h; apply eq\n  simp only [gcd_coe, mul_coe]; apply Nat.Coprime.gcd_mul k h\n\n"}
{"name":"PNat.gcd_eq_left","module":"Mathlib.Data.PNat.Prime","initialProofState":"m n : PNat\na✝ : Dvd.dvd m n\n⊢ Eq (m.gcd n) m","decl":"theorem gcd_eq_left {m n : ℕ+} : m ∣ n → m.gcd n = m := by\n  rw [dvd_iff]\n  intro h\n  apply eq\n  simp only [gcd_coe]\n  apply Nat.gcd_eq_left h\n\n"}
{"name":"PNat.Coprime.pow","module":"Mathlib.Data.PNat.Prime","initialProofState":"m n : PNat\nk l : Nat\nh : m.Coprime n\n⊢ (HPow.hPow (↑m) k).Coprime (HPow.hPow (↑n) l)","decl":"theorem Coprime.pow {m n : ℕ+} (k l : ℕ) (h : m.Coprime n) : (m ^ k : ℕ).Coprime (n ^ l) := by\n  rw [← coprime_coe] at *; apply Nat.Coprime.pow; apply h\n\n"}
