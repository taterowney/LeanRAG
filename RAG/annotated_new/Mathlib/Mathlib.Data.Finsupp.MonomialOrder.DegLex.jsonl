{"name":"toDegLex_injective","module":"Mathlib.Data.Finsupp.MonomialOrder.DegLex","initialProofState":"α : Type u_1\n⊢ Function.Injective ⇑toDegLex","decl":"theorem toDegLex_injective : Function.Injective (toDegLex (α := α)) := fun _ _ ↦ _root_.id\n\n"}
{"name":"toDegLex_inj","module":"Mathlib.Data.Finsupp.MonomialOrder.DegLex","initialProofState":"α : Type u_1\na b : α\n⊢ Iff (Eq (toDegLex a) (toDegLex b)) (Eq a b)","decl":"theorem toDegLex_inj {a b : α} : toDegLex a = toDegLex b ↔ a = b := Iff.rfl\n\n"}
{"name":"ofDegLex_injective","module":"Mathlib.Data.Finsupp.MonomialOrder.DegLex","initialProofState":"α : Type u_1\n⊢ Function.Injective ⇑ofDegLex","decl":"theorem ofDegLex_injective : Function.Injective (ofDegLex (α := α)) := fun _ _ ↦ _root_.id\n\n"}
{"name":"ofDegLex_inj","module":"Mathlib.Data.Finsupp.MonomialOrder.DegLex","initialProofState":"α : Type u_1\na b : DegLex α\n⊢ Iff (Eq (ofDegLex a) (ofDegLex b)) (Eq a b)","decl":"theorem ofDegLex_inj {a b : DegLex α} : ofDegLex a = ofDegLex b ↔ a = b := Iff.rfl\n\n"}
{"name":"ofDegLex_symm_eq","module":"Mathlib.Data.Finsupp.MonomialOrder.DegLex","initialProofState":"α : Type u_1\n⊢ Eq ofDegLex.symm toDegLex","decl":"@[simp] theorem ofDegLex_symm_eq : (@ofDegLex α).symm = toDegLex := rfl\n\n"}
{"name":"toDegLex_symm_eq","module":"Mathlib.Data.Finsupp.MonomialOrder.DegLex","initialProofState":"α : Type u_1\n⊢ Eq toDegLex.symm ofDegLex","decl":"@[simp] theorem toDegLex_symm_eq : (@toDegLex α).symm = ofDegLex := rfl\n\n"}
{"name":"ofDegLex_toDegLex","module":"Mathlib.Data.Finsupp.MonomialOrder.DegLex","initialProofState":"α : Type u_1\na : α\n⊢ Eq (ofDegLex (toDegLex a)) a","decl":"@[simp] theorem ofDegLex_toDegLex (a : α) : ofDegLex (toDegLex a) = a := rfl\n\n"}
{"name":"toDegLex_ofDegLex","module":"Mathlib.Data.Finsupp.MonomialOrder.DegLex","initialProofState":"α : Type u_1\na : DegLex α\n⊢ Eq (toDegLex (ofDegLex a)) a","decl":"@[simp] theorem toDegLex_ofDegLex (a : DegLex α) : toDegLex (ofDegLex a) = a := rfl\n\n"}
{"name":"DegLex.forall_iff","module":"Mathlib.Data.Finsupp.MonomialOrder.DegLex","initialProofState":"α : Type u_1\np : DegLex α → Prop\n⊢ Iff (∀ (a : DegLex α), p a) (∀ (a : α), p (toDegLex a))","decl":"@[simp] lemma DegLex.forall_iff {p : DegLex α → Prop} : (∀ a, p a) ↔ ∀ a, p (toDegLex a) := Iff.rfl\n"}
{"name":"DegLex.exists_iff","module":"Mathlib.Data.Finsupp.MonomialOrder.DegLex","initialProofState":"α : Type u_1\np : DegLex α → Prop\n⊢ Iff (Exists fun a => p a) (Exists fun a => p (toDegLex a))","decl":"@[simp] lemma DegLex.exists_iff {p : DegLex α → Prop} : (∃ a, p a) ↔ ∃ a, p (toDegLex a) := Iff.rfl\n\n"}
{"name":"toDegLex_add","module":"Mathlib.Data.Finsupp.MonomialOrder.DegLex","initialProofState":"α : Type u_1\ninst✝ : AddCommMonoid α\na b : α\n⊢ Eq (toDegLex (HAdd.hAdd a b)) (HAdd.hAdd (toDegLex a) (toDegLex b))","decl":"theorem toDegLex_add [AddCommMonoid α] (a b : α) :\n    toDegLex (a + b) = toDegLex a + toDegLex b := rfl\n\n"}
{"name":"ofDegLex_add","module":"Mathlib.Data.Finsupp.MonomialOrder.DegLex","initialProofState":"α : Type u_1\ninst✝ : AddCommMonoid α\na b : DegLex α\n⊢ Eq (ofDegLex (HAdd.hAdd a b)) (HAdd.hAdd (ofDegLex a) (ofDegLex b))","decl":"theorem ofDegLex_add [AddCommMonoid α] (a b : DegLex α) :\n    ofDegLex (a + b) = ofDegLex a + ofDegLex b := rfl\n\n"}
{"name":"Finsupp.degLex_def","module":"Mathlib.Data.Finsupp.MonomialOrder.DegLex","initialProofState":"α : Type u_1\nr : α → α → Prop\ns : Nat → Nat → Prop\na b : Finsupp α Nat\n⊢ Iff (Finsupp.DegLex r s a b) (Prod.Lex s (Finsupp.Lex r s) { fst := a.degree, snd := a } { fst := b.degree, snd := b })","decl":"theorem degLex_def {r : α → α → Prop} {s : ℕ → ℕ → Prop} {a b : α →₀ ℕ} :\n    Finsupp.DegLex r s a b ↔ Prod.Lex s (Finsupp.Lex r s) (a.degree, a) (b.degree, b) :=\n  Iff.rfl\n\n"}
{"name":"Finsupp.DegLex.wellFounded","module":"Mathlib.Data.Finsupp.MonomialOrder.DegLex","initialProofState":"α : Type u_1\nr : α → α → Prop\ninst✝ : IsTrichotomous α r\nhr : WellFounded (Function.swap r)\ns : Nat → Nat → Prop\nhs : WellFounded s\nhs0 : ∀ ⦃n : Nat⦄, Not (s n 0)\n⊢ WellFounded (Finsupp.DegLex r s)","decl":"theorem wellFounded\n    {r : α → α → Prop} [IsTrichotomous α r] (hr : WellFounded (Function.swap r))\n    {s : ℕ → ℕ → Prop} (hs : WellFounded s) (hs0 : ∀ ⦃n⦄, ¬ s n 0) :\n    WellFounded (Finsupp.DegLex r s) := by\n  have wft := WellFounded.prod_lex hs (Finsupp.Lex.wellFounded' hs0 hs hr)\n  rw [← Set.wellFoundedOn_univ] at wft\n  unfold Finsupp.DegLex\n  rw [← Set.wellFoundedOn_range]\n  exact Set.WellFoundedOn.mono wft (le_refl _) (fun _ _ ↦ trivial)\n\n"}
{"name":"Finsupp.DegLex.lt_def","module":"Mathlib.Data.Finsupp.MonomialOrder.DegLex","initialProofState":"α : Type u_1\ninst✝ : LT α\na b : DegLex (Finsupp α Nat)\n⊢ Iff (LT.lt a b) (LT.lt (toLex { fst := (ofDegLex a).degree, snd := toLex (ofDegLex a) }) (toLex { fst := (ofDegLex b).degree, snd := toLex (ofDegLex b) }))","decl":"theorem lt_def [LT α] {a b : DegLex (α →₀ ℕ)} :\n    a < b ↔ (toLex ((ofDegLex a).degree, toLex (ofDegLex a))) <\n        (toLex ((ofDegLex b).degree, toLex (ofDegLex b))) :=\n  Iff.rfl\n\n"}
{"name":"Finsupp.DegLex.lt_iff","module":"Mathlib.Data.Finsupp.MonomialOrder.DegLex","initialProofState":"α : Type u_1\ninst✝ : LT α\na b : DegLex (Finsupp α Nat)\n⊢ Iff (LT.lt a b) (Or (LT.lt (ofDegLex a).degree (ofDegLex b).degree) (And (Eq (ofDegLex a).degree (ofDegLex b).degree) (LT.lt (toLex (ofDegLex a)) (toLex (ofDegLex b)))))","decl":"theorem lt_iff [LT α] {a b : DegLex (α →₀ ℕ)} :\n    a < b ↔ (ofDegLex a).degree < (ofDegLex b).degree ∨\n    (((ofDegLex a).degree = (ofDegLex b).degree) ∧ toLex (ofDegLex a) < toLex (ofDegLex b)) := by\n  simp [lt_def, Prod.Lex.toLex_lt_toLex]\n\n"}
{"name":"Finsupp.DegLex.isStrictOrder","module":"Mathlib.Data.Finsupp.MonomialOrder.DegLex","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\n⊢ IsStrictOrder (DegLex (Finsupp α Nat)) fun x1 x2 => LT.lt x1 x2","decl":"instance isStrictOrder : IsStrictOrder (DegLex (α →₀ ℕ)) (· < ·) where\n  irrefl := fun a ↦ by simp [lt_def]\n  trans := by\n    intro a b c hab hbc\n    simp only [lt_iff] at hab hbc ⊢\n    rcases hab with (hab | hab)\n    · rcases hbc with (hbc | hbc)\n      · left; exact lt_trans hab hbc\n      · left; exact lt_of_lt_of_eq hab hbc.1\n    · rcases hbc with (hbc | hbc)\n      · left; exact lt_of_eq_of_lt hab.1 hbc\n      · right; exact ⟨Eq.trans hab.1 hbc.1, lt_trans hab.2 hbc.2⟩\n\n"}
{"name":"Finsupp.DegLex.le_iff","module":"Mathlib.Data.Finsupp.MonomialOrder.DegLex","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nx y : DegLex (Finsupp α Nat)\n⊢ Iff (LE.le x y) (Or (LT.lt (ofDegLex x).degree (ofDegLex y).degree) (And (Eq (ofDegLex x).degree (ofDegLex y).degree) (LE.le (toLex (ofDegLex x)) (toLex (ofDegLex y)))))","decl":"theorem le_iff {x y : DegLex (α →₀ ℕ)} :\n    x ≤ y ↔ (ofDegLex x).degree < (ofDegLex y).degree ∨\n      (ofDegLex x).degree = (ofDegLex y).degree ∧ toLex (ofDegLex x) ≤ toLex (ofDegLex y) := by\n  simp only [le_iff_eq_or_lt, lt_iff, EmbeddingLike.apply_eq_iff_eq]\n  by_cases h : x = y\n  · simp [h]\n  · by_cases k : (ofDegLex x).degree < (ofDegLex y).degree\n    · simp [k]\n    · simp only [h, k, false_or]\n\n"}
{"name":"Finsupp.DegLex.single_strictAnti","module":"Mathlib.Data.Finsupp.MonomialOrder.DegLex","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\n⊢ StrictAnti fun a => toDegLex (Finsupp.single a 1)","decl":"theorem single_strictAnti : StrictAnti (fun (a : α) ↦ toDegLex (single a 1)) := by\n  intro _ _ h\n  simp only [lt_iff, ofDegLex_toDegLex, degree_single, lt_self_iff_false, Lex.single_lt_iff, h,\n    and_self, or_true]\n\n"}
{"name":"Finsupp.DegLex.single_antitone","module":"Mathlib.Data.Finsupp.MonomialOrder.DegLex","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\n⊢ Antitone fun a => toDegLex (Finsupp.single a 1)","decl":"theorem single_antitone : Antitone (fun (a : α) ↦ toDegLex (single a 1)) :=\n  single_strictAnti.antitone\n\n"}
{"name":"Finsupp.DegLex.single_lt_iff","module":"Mathlib.Data.Finsupp.MonomialOrder.DegLex","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ Iff (LT.lt (toDegLex (Finsupp.single b 1)) (toDegLex (Finsupp.single a 1))) (LT.lt a b)","decl":"theorem single_lt_iff {a b : α} :\n    toDegLex (Finsupp.single b 1) < toDegLex (Finsupp.single a 1) ↔ a < b :=\n  single_strictAnti.lt_iff_lt\n\n"}
{"name":"Finsupp.DegLex.single_le_iff","module":"Mathlib.Data.Finsupp.MonomialOrder.DegLex","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ Iff (LE.le (toDegLex (Finsupp.single b 1)) (toDegLex (Finsupp.single a 1))) (LE.le a b)","decl":"theorem single_le_iff {a b : α} :\n    toDegLex (Finsupp.single b 1) ≤ toDegLex (Finsupp.single a 1) ↔ a ≤ b :=\n  single_strictAnti.le_iff_le\n\n"}
{"name":"Finsupp.DegLex.monotone_degree","module":"Mathlib.Data.Finsupp.MonomialOrder.DegLex","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\n⊢ Monotone fun x => (ofDegLex x).degree","decl":"theorem monotone_degree :\n    Monotone (fun (x : DegLex (α →₀ ℕ)) ↦ (ofDegLex x).degree) := by\n  intro x y\n  rw [le_iff]\n  rintro (h | h)\n  · apply le_of_lt h\n  · apply le_of_eq h.1\n\n"}
{"name":"Finsupp.DegLex.wellFoundedLT","module":"Mathlib.Data.Finsupp.MonomialOrder.DegLex","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\ninst✝ : WellFoundedGT α\n⊢ WellFoundedLT (DegLex (Finsupp α Nat))","decl":"instance wellFoundedLT [WellFoundedGT α] :\n    WellFoundedLT (DegLex (α →₀ ℕ)) :=\n  ⟨wellFounded wellFounded_gt wellFounded_lt fun n ↦ (zero_le n).not_lt⟩\n\n"}
{"name":"MonomialOrder.degLex_le_iff","module":"Mathlib.Data.Finsupp.MonomialOrder.DegLex","initialProofState":"σ : Type u_2\ninst✝¹ : LinearOrder σ\ninst✝ : WellFoundedGT σ\na b : Finsupp σ Nat\n⊢ Iff (LE.le (MonomialOrder.degLex.toSyn a) (MonomialOrder.degLex.toSyn b)) (LE.le (toDegLex a) (toDegLex b))","decl":"theorem degLex_le_iff {a b : σ →₀ ℕ} :\n    a ≼[degLex] b ↔ toDegLex a ≤ toDegLex b :=\n  Iff.rfl\n\n"}
{"name":"MonomialOrder.degLex_lt_iff","module":"Mathlib.Data.Finsupp.MonomialOrder.DegLex","initialProofState":"σ : Type u_2\ninst✝¹ : LinearOrder σ\ninst✝ : WellFoundedGT σ\na b : Finsupp σ Nat\n⊢ Iff (LT.lt (MonomialOrder.degLex.toSyn a) (MonomialOrder.degLex.toSyn b)) (LT.lt (toDegLex a) (toDegLex b))","decl":"theorem degLex_lt_iff {a b : σ →₀ ℕ} :\n    a ≺[degLex] b ↔ toDegLex a < toDegLex b :=\n  Iff.rfl\n\n"}
{"name":"MonomialOrder.degLex_single_le_iff","module":"Mathlib.Data.Finsupp.MonomialOrder.DegLex","initialProofState":"σ : Type u_2\ninst✝¹ : LinearOrder σ\ninst✝ : WellFoundedGT σ\na b : σ\n⊢ Iff (LE.le (MonomialOrder.degLex.toSyn (Finsupp.single a 1)) (MonomialOrder.degLex.toSyn (Finsupp.single b 1))) (LE.le b a)","decl":"theorem degLex_single_le_iff {a b : σ} :\n    single a 1 ≼[degLex] single b 1 ↔ b ≤ a := by\n  rw [MonomialOrder.degLex_le_iff, DegLex.single_le_iff]\n\n"}
{"name":"MonomialOrder.degLex_single_lt_iff","module":"Mathlib.Data.Finsupp.MonomialOrder.DegLex","initialProofState":"σ : Type u_2\ninst✝¹ : LinearOrder σ\ninst✝ : WellFoundedGT σ\na b : σ\n⊢ Iff (LT.lt (MonomialOrder.degLex.toSyn (Finsupp.single a 1)) (MonomialOrder.degLex.toSyn (Finsupp.single b 1))) (LT.lt b a)","decl":"theorem degLex_single_lt_iff {a b : σ} :\n    single a 1 ≺[degLex] single b 1 ↔ b < a := by\n  rw [MonomialOrder.degLex_lt_iff, DegLex.single_lt_iff]\n\n"}
