{"name":"ProperVAdd.isProperMap_vadd_pair","module":"Mathlib.Topology.Algebra.ProperAction.Basic","initialProofState":"G : Type u_1\nX : Type u_2\ninst✝³ : TopologicalSpace G\ninst✝² : TopologicalSpace X\ninst✝¹ : AddGroup G\ninst✝ : AddAction G X\nself : ProperVAdd G X\n⊢ IsProperMap fun gx => { fst := HVAdd.hVAdd gx.1 gx.2, snd := gx.2 }","decl":"/-- Proper group action in the sense of Bourbaki:\nthe map `G × X → X × X` is a proper map (see `IsProperMap`). -/\nclass ProperVAdd (G X : Type*) [TopologicalSpace G] [TopologicalSpace X] [AddGroup G]\n    [AddAction G X] : Prop where\n  /-- Proper group action in the sense of Bourbaki:\n  the map `G × X → X × X` is a proper map (see `IsProperMap`). -/\n  isProperMap_vadd_pair : IsProperMap (fun gx ↦ (gx.1 +ᵥ gx.2, gx.2) : G × X → X × X)\n\n"}
{"name":"properSMul_iff","module":"Mathlib.Topology.Algebra.ProperAction.Basic","initialProofState":"G : Type u_1\nX : Type u_2\ninst✝³ : TopologicalSpace G\ninst✝² : TopologicalSpace X\ninst✝¹ : Group G\ninst✝ : MulAction G X\n⊢ Iff (ProperSMul G X) (IsProperMap fun gx => { fst := HSMul.hSMul gx.1 gx.2, snd := gx.2 })","decl":"/-- Proper group action in the sense of Bourbaki:\nthe map `G × X → X × X` is a proper map (see `IsProperMap`). -/\n@[to_additive existing (attr := mk_iff)]\nclass ProperSMul (G X : Type*) [TopologicalSpace G] [TopologicalSpace X] [Group G]\n    [MulAction G X] : Prop where\n  /-- Proper group action in the sense of Bourbaki:\n  the map `G × X → X × X` is a proper map (see `IsProperMap`). -/\n  isProperMap_smul_pair : IsProperMap (fun gx ↦ (gx.1 • gx.2, gx.2) : G × X → X × X)\n\n"}
{"name":"properVAdd_iff","module":"Mathlib.Topology.Algebra.ProperAction.Basic","initialProofState":"G : Type u_1\nX : Type u_2\ninst✝³ : TopologicalSpace G\ninst✝² : TopologicalSpace X\ninst✝¹ : AddGroup G\ninst✝ : AddAction G X\n⊢ Iff (ProperVAdd G X) (IsProperMap fun gx => { fst := HVAdd.hVAdd gx.1 gx.2, snd := gx.2 })","decl":"/-- Proper group action in the sense of Bourbaki:\nthe map `G × X → X × X` is a proper map (see `IsProperMap`). -/\n@[to_additive existing (attr := mk_iff)]\nclass ProperSMul (G X : Type*) [TopologicalSpace G] [TopologicalSpace X] [Group G]\n    [MulAction G X] : Prop where\n  /-- Proper group action in the sense of Bourbaki:\n  the map `G × X → X × X` is a proper map (see `IsProperMap`). -/\n  isProperMap_smul_pair : IsProperMap (fun gx ↦ (gx.1 • gx.2, gx.2) : G × X → X × X)\n\n"}
{"name":"ProperSMul.isProperMap_smul_pair","module":"Mathlib.Topology.Algebra.ProperAction.Basic","initialProofState":"G : Type u_1\nX : Type u_2\ninst✝³ : TopologicalSpace G\ninst✝² : TopologicalSpace X\ninst✝¹ : Group G\ninst✝ : MulAction G X\nself : ProperSMul G X\n⊢ IsProperMap fun gx => { fst := HSMul.hSMul gx.1 gx.2, snd := gx.2 }","decl":"/-- Proper group action in the sense of Bourbaki:\nthe map `G × X → X × X` is a proper map (see `IsProperMap`). -/\n@[to_additive existing (attr := mk_iff)]\nclass ProperSMul (G X : Type*) [TopologicalSpace G] [TopologicalSpace X] [Group G]\n    [MulAction G X] : Prop where\n  /-- Proper group action in the sense of Bourbaki:\n  the map `G × X → X × X` is a proper map (see `IsProperMap`). -/\n  isProperMap_smul_pair : IsProperMap (fun gx ↦ (gx.1 • gx.2, gx.2) : G × X → X × X)\n\n"}
{"name":"ProperVAdd.toContinuousVAdd","module":"Mathlib.Topology.Algebra.ProperAction.Basic","initialProofState":"G : Type u_1\nX : Type u_2\ninst✝⁴ : AddGroup G\ninst✝³ : AddAction G X\ninst✝² : TopologicalSpace G\ninst✝¹ : TopologicalSpace X\ninst✝ : ProperVAdd G X\n⊢ ContinuousVAdd G X","decl":"/-- If a group acts properly then in particular it acts continuously. -/\n@[to_additive \"If a group acts properly then in particular it acts continuously.\"]\n-- See note [lower instance property]\ninstance (priority := 100) ProperSMul.toContinuousSMul [ProperSMul G X] : ContinuousSMul G X where\n  continuous_smul := isProperMap_smul_pair.continuous.fst\n\n"}
{"name":"ProperSMul.toContinuousSMul","module":"Mathlib.Topology.Algebra.ProperAction.Basic","initialProofState":"G : Type u_1\nX : Type u_2\ninst✝⁴ : Group G\ninst✝³ : MulAction G X\ninst✝² : TopologicalSpace G\ninst✝¹ : TopologicalSpace X\ninst✝ : ProperSMul G X\n⊢ ContinuousSMul G X","decl":"/-- If a group acts properly then in particular it acts continuously. -/\n@[to_additive \"If a group acts properly then in particular it acts continuously.\"]\n-- See note [lower instance property]\ninstance (priority := 100) ProperSMul.toContinuousSMul [ProperSMul G X] : ContinuousSMul G X where\n  continuous_smul := isProperMap_smul_pair.continuous.fst\n\n"}
{"name":"properVAdd_iff_continuousVAdd_ultrafilter_tendsto","module":"Mathlib.Topology.Algebra.ProperAction.Basic","initialProofState":"G : Type u_1\nX : Type u_2\ninst✝³ : AddGroup G\ninst✝² : AddAction G X\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalSpace X\n⊢ Iff (ProperVAdd G X) (And (ContinuousVAdd G X) (∀ (𝒰 : Ultrafilter (Prod G X)) (x₁ x₂ : X), Filter.Tendsto (fun gx => { fst := HVAdd.hVAdd gx.1 gx.2, snd := gx.2 }) (↑𝒰) (nhds { fst := x₁, snd := x₂ }) → Exists fun g => And (Eq (HVAdd.hVAdd g x₂) x₁) (Filter.Tendsto Prod.fst (↑𝒰) (nhds g))))","decl":"/-- A group `G` acts properly on a topological space `X` if and only if for all ultrafilters\n`𝒰` on `X × G`, if `𝒰` converges to `(x₁, x₂)` along the map `(g, x) ↦ (g • x, x)`,\nthen there exists `g : G` such that `g • x₂ = x₁` and `𝒰.fst` converges to `g`. -/\n@[to_additive \"A group `G` acts properly on a topological space `X` if and only if\nfor all ultrafilters `𝒰` on `X`, if `𝒰` converges to `(x₁, x₂)`\nalong the map `(g, x) ↦ (g • x, x)`, then there exists `g : G` such that `g • x₂ = x₁`\nand `𝒰.fst` converges to `g`.\"]\ntheorem properSMul_iff_continuousSMul_ultrafilter_tendsto :\n    ProperSMul G X ↔ ContinuousSMul G X ∧\n      (∀ 𝒰 : Ultrafilter (G × X), ∀ x₁ x₂ : X,\n        Tendsto (fun gx : G × X ↦ (gx.1 • gx.2, gx.2)) 𝒰 (𝓝 (x₁, x₂)) →\n      ∃ g : G, g • x₂ = x₁ ∧ Tendsto (Prod.fst : G × X → G) 𝒰 (𝓝 g)) := by\n  refine ⟨fun h ↦ ⟨inferInstance, fun 𝒰 x₁ x₂ h' ↦ ?_⟩, fun ⟨cont, h⟩ ↦ ?_⟩\n  · rw [properSMul_iff, isProperMap_iff_ultrafilter] at h\n    rcases h.2 h' with ⟨gx, hgx1, hgx2⟩\n    refine ⟨gx.1, ?_, (continuous_fst.tendsto gx).mono_left hgx2⟩\n    simp only [Prod.mk.injEq] at hgx1\n    rw [← hgx1.2, hgx1.1]\n  · rw [properSMul_iff, isProperMap_iff_ultrafilter]\n    refine ⟨by fun_prop, fun 𝒰 (x₁, x₂) hxx ↦ ?_⟩\n    rcases h 𝒰 x₁ x₂ hxx with ⟨g, hg1, hg2⟩\n    refine ⟨(g, x₂), by simp_rw [hg1], ?_⟩\n    rw [nhds_prod_eq, 𝒰.le_prod]\n    exact ⟨hg2, (continuous_snd.tendsto _).comp hxx⟩\n\n"}
{"name":"properSMul_iff_continuousSMul_ultrafilter_tendsto","module":"Mathlib.Topology.Algebra.ProperAction.Basic","initialProofState":"G : Type u_1\nX : Type u_2\ninst✝³ : Group G\ninst✝² : MulAction G X\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalSpace X\n⊢ Iff (ProperSMul G X) (And (ContinuousSMul G X) (∀ (𝒰 : Ultrafilter (Prod G X)) (x₁ x₂ : X), Filter.Tendsto (fun gx => { fst := HSMul.hSMul gx.1 gx.2, snd := gx.2 }) (↑𝒰) (nhds { fst := x₁, snd := x₂ }) → Exists fun g => And (Eq (HSMul.hSMul g x₂) x₁) (Filter.Tendsto Prod.fst (↑𝒰) (nhds g))))","decl":"/-- A group `G` acts properly on a topological space `X` if and only if for all ultrafilters\n`𝒰` on `X × G`, if `𝒰` converges to `(x₁, x₂)` along the map `(g, x) ↦ (g • x, x)`,\nthen there exists `g : G` such that `g • x₂ = x₁` and `𝒰.fst` converges to `g`. -/\n@[to_additive \"A group `G` acts properly on a topological space `X` if and only if\nfor all ultrafilters `𝒰` on `X`, if `𝒰` converges to `(x₁, x₂)`\nalong the map `(g, x) ↦ (g • x, x)`, then there exists `g : G` such that `g • x₂ = x₁`\nand `𝒰.fst` converges to `g`.\"]\ntheorem properSMul_iff_continuousSMul_ultrafilter_tendsto :\n    ProperSMul G X ↔ ContinuousSMul G X ∧\n      (∀ 𝒰 : Ultrafilter (G × X), ∀ x₁ x₂ : X,\n        Tendsto (fun gx : G × X ↦ (gx.1 • gx.2, gx.2)) 𝒰 (𝓝 (x₁, x₂)) →\n      ∃ g : G, g • x₂ = x₁ ∧ Tendsto (Prod.fst : G × X → G) 𝒰 (𝓝 g)) := by\n  refine ⟨fun h ↦ ⟨inferInstance, fun 𝒰 x₁ x₂ h' ↦ ?_⟩, fun ⟨cont, h⟩ ↦ ?_⟩\n  · rw [properSMul_iff, isProperMap_iff_ultrafilter] at h\n    rcases h.2 h' with ⟨gx, hgx1, hgx2⟩\n    refine ⟨gx.1, ?_, (continuous_fst.tendsto gx).mono_left hgx2⟩\n    simp only [Prod.mk.injEq] at hgx1\n    rw [← hgx1.2, hgx1.1]\n  · rw [properSMul_iff, isProperMap_iff_ultrafilter]\n    refine ⟨by fun_prop, fun 𝒰 (x₁, x₂) hxx ↦ ?_⟩\n    rcases h 𝒰 x₁ x₂ hxx with ⟨g, hg1, hg2⟩\n    refine ⟨(g, x₂), by simp_rw [hg1], ?_⟩\n    rw [nhds_prod_eq, 𝒰.le_prod]\n    exact ⟨hg2, (continuous_snd.tendsto _).comp hxx⟩\n\n"}
{"name":"properSMul_iff_continuousSMul_ultrafilter_tendsto_t2","module":"Mathlib.Topology.Algebra.ProperAction.Basic","initialProofState":"G : Type u_1\nX : Type u_2\ninst✝⁴ : Group G\ninst✝³ : MulAction G X\ninst✝² : TopologicalSpace G\ninst✝¹ : TopologicalSpace X\ninst✝ : T2Space X\n⊢ Iff (ProperSMul G X) (And (ContinuousSMul G X) (∀ (𝒰 : Ultrafilter (Prod G X)) (x₁ x₂ : X), Filter.Tendsto (fun gx => { fst := HSMul.hSMul gx.1 gx.2, snd := gx.2 }) (↑𝒰) (nhds { fst := x₁, snd := x₂ }) → Exists fun g => Filter.Tendsto Prod.fst (↑𝒰) (nhds g)))","decl":"/-- A group `G` acts properly on a T2 topological space `X` if and only if for all ultrafilters\n`𝒰` on `X × G`, if `𝒰` converges to `(x₁, x₂)` along the map `(g, x) ↦ (g • x, x)`,\nthen there exists `g : G` such that `𝒰.fst` converges to `g`. -/\ntheorem properSMul_iff_continuousSMul_ultrafilter_tendsto_t2 [T2Space X] :\n    ProperSMul G X ↔ ContinuousSMul G X ∧\n      (∀ 𝒰 : Ultrafilter (G × X), ∀ x₁ x₂ : X,\n        Tendsto (fun gx : G × X ↦ (gx.1 • gx.2, gx.2)) 𝒰 (𝓝 (x₁, x₂)) →\n     ∃ g : G, Tendsto (Prod.fst : G × X → G) 𝒰 (𝓝 g)) := by\n  rw [properSMul_iff_continuousSMul_ultrafilter_tendsto]\n  refine and_congr_right fun hc ↦ ?_\n  congrm ∀ 𝒰 x₁ x₂ hxx, ∃ g, ?_\n  exact and_iff_right_of_imp fun hg ↦ tendsto_nhds_unique\n    (hg.smul ((continuous_snd.tendsto _).comp hxx)) ((continuous_fst.tendsto _).comp hxx)\n\n"}
{"name":"t2Space_quotient_addAction_of_properVAdd","module":"Mathlib.Topology.Algebra.ProperAction.Basic","initialProofState":"G : Type u_1\nX : Type u_2\ninst✝⁴ : AddGroup G\ninst✝³ : AddAction G X\ninst✝² : TopologicalSpace G\ninst✝¹ : TopologicalSpace X\ninst✝ : ProperVAdd G X\n⊢ T2Space (Quotient (AddAction.orbitRel G X))","decl":"/-- If `G` acts properly on `X`, then the quotient space is Hausdorff (T2). -/\n@[to_additive \"If `G` acts properly on `X`, then the quotient space is Hausdorff (T2).\"]\ntheorem t2Space_quotient_mulAction_of_properSMul [ProperSMul G X] :\n    T2Space (Quotient (MulAction.orbitRel G X)) := by\n  rw [t2_iff_isClosed_diagonal]\n  set R := MulAction.orbitRel G X\n  let π : X → Quotient R := Quotient.mk'\n  have : IsOpenQuotientMap (Prod.map π π) :=\n    MulAction.isOpenQuotientMap_quotientMk.prodMap MulAction.isOpenQuotientMap_quotientMk\n  rw [← this.isQuotientMap.isClosed_preimage]\n  convert ProperSMul.isProperMap_smul_pair.isClosedMap.isClosed_range\n  · ext ⟨x₁, x₂⟩\n    simp only [mem_preimage, map_apply, mem_diagonal_iff, mem_range, Prod.mk.injEq, Prod.exists,\n      exists_eq_right]\n    rw [Quotient.eq', MulAction.orbitRel_apply, MulAction.mem_orbit_iff]\n  all_goals infer_instance\n\n"}
{"name":"t2Space_quotient_mulAction_of_properSMul","module":"Mathlib.Topology.Algebra.ProperAction.Basic","initialProofState":"G : Type u_1\nX : Type u_2\ninst✝⁴ : Group G\ninst✝³ : MulAction G X\ninst✝² : TopologicalSpace G\ninst✝¹ : TopologicalSpace X\ninst✝ : ProperSMul G X\n⊢ T2Space (Quotient (MulAction.orbitRel G X))","decl":"/-- If `G` acts properly on `X`, then the quotient space is Hausdorff (T2). -/\n@[to_additive \"If `G` acts properly on `X`, then the quotient space is Hausdorff (T2).\"]\ntheorem t2Space_quotient_mulAction_of_properSMul [ProperSMul G X] :\n    T2Space (Quotient (MulAction.orbitRel G X)) := by\n  rw [t2_iff_isClosed_diagonal]\n  set R := MulAction.orbitRel G X\n  let π : X → Quotient R := Quotient.mk'\n  have : IsOpenQuotientMap (Prod.map π π) :=\n    MulAction.isOpenQuotientMap_quotientMk.prodMap MulAction.isOpenQuotientMap_quotientMk\n  rw [← this.isQuotientMap.isClosed_preimage]\n  convert ProperSMul.isProperMap_smul_pair.isClosedMap.isClosed_range\n  · ext ⟨x₁, x₂⟩\n    simp only [mem_preimage, map_apply, mem_diagonal_iff, mem_range, Prod.mk.injEq, Prod.exists,\n      exists_eq_right]\n    rw [Quotient.eq', MulAction.orbitRel_apply, MulAction.mem_orbit_iff]\n  all_goals infer_instance\n\n"}
{"name":"t2Space_of_properVAdd_of_t2AddGroup","module":"Mathlib.Topology.Algebra.ProperAction.Basic","initialProofState":"G : Type u_1\nX : Type u_2\ninst✝⁴ : AddGroup G\ninst✝³ : AddAction G X\ninst✝² : TopologicalSpace G\ninst✝¹ : TopologicalSpace X\nh_proper : ProperVAdd G X\ninst✝ : T2Space G\n⊢ T2Space X","decl":"/-- If a T2 group acts properly on a topological space, then this topological space is T2. -/\n@[to_additive \"If a T2 group acts properly on a topological space,\nthen this topological space is T2.\"]\ntheorem t2Space_of_properSMul_of_t2Group [h_proper : ProperSMul G X] [T2Space G] : T2Space X := by\n  let f := fun x : X ↦ ((1 : G), x)\n  have proper_f : IsProperMap f := by\n    refine IsClosedEmbedding.isProperMap ⟨?_, ?_⟩\n    · let g := fun gx : G × X ↦ gx.2\n      have : Function.LeftInverse g f := fun x ↦ by simp [f, g]\n      exact this.isEmbedding (by fun_prop) (by fun_prop)\n    · have : range f = ({1} ×ˢ univ) := by simp [f]\n      rw [this]\n      exact isClosed_singleton.prod isClosed_univ\n  rw [t2_iff_isClosed_diagonal]\n  let g := fun gx : G × X ↦ (gx.1 • gx.2, gx.2)\n  have proper_g : IsProperMap g := (properSMul_iff G X).1 h_proper\n  have : g ∘ f = fun x ↦ (x, x) := by ext x <;> simp [f, g]\n  have range_gf : range (g ∘ f) = diagonal X := by simp [this]\n  rw [← range_gf]\n  exact (proper_f.comp proper_g).isClosed_range\n\n"}
{"name":"t2Space_of_properSMul_of_t2Group","module":"Mathlib.Topology.Algebra.ProperAction.Basic","initialProofState":"G : Type u_1\nX : Type u_2\ninst✝⁴ : Group G\ninst✝³ : MulAction G X\ninst✝² : TopologicalSpace G\ninst✝¹ : TopologicalSpace X\nh_proper : ProperSMul G X\ninst✝ : T2Space G\n⊢ T2Space X","decl":"/-- If a T2 group acts properly on a topological space, then this topological space is T2. -/\n@[to_additive \"If a T2 group acts properly on a topological space,\nthen this topological space is T2.\"]\ntheorem t2Space_of_properSMul_of_t2Group [h_proper : ProperSMul G X] [T2Space G] : T2Space X := by\n  let f := fun x : X ↦ ((1 : G), x)\n  have proper_f : IsProperMap f := by\n    refine IsClosedEmbedding.isProperMap ⟨?_, ?_⟩\n    · let g := fun gx : G × X ↦ gx.2\n      have : Function.LeftInverse g f := fun x ↦ by simp [f, g]\n      exact this.isEmbedding (by fun_prop) (by fun_prop)\n    · have : range f = ({1} ×ˢ univ) := by simp [f]\n      rw [this]\n      exact isClosed_singleton.prod isClosed_univ\n  rw [t2_iff_isClosed_diagonal]\n  let g := fun gx : G × X ↦ (gx.1 • gx.2, gx.2)\n  have proper_g : IsProperMap g := (properSMul_iff G X).1 h_proper\n  have : g ∘ f = fun x ↦ (x, x) := by ext x <;> simp [f, g]\n  have range_gf : range (g ∘ f) = diagonal X := by simp [this]\n  rw [← range_gf]\n  exact (proper_f.comp proper_g).isClosed_range\n\n"}
{"name":"properSMul_of_isClosedEmbedding","module":"Mathlib.Topology.Algebra.ProperAction.Basic","initialProofState":"G : Type u_1\nX : Type u_2\ninst✝⁷ : Group G\ninst✝⁶ : MulAction G X\ninst✝⁵ : TopologicalSpace G\ninst✝⁴ : TopologicalSpace X\nH : Type u_3\ninst✝³ : Group H\ninst✝² : MulAction H X\ninst✝¹ : TopologicalSpace H\ninst✝ : ProperSMul G X\nf : MonoidHom H G\nf_clemb : Topology.IsClosedEmbedding ⇑f\nf_compat : ∀ (h : H) (x : X), Eq (HSMul.hSMul (f h) x) (HSMul.hSMul h x)\n⊢ ProperSMul H X","decl":"/-- If two groups `H` and `G` act on a topological space `X` such that `G` acts properly and\nthere exists a group homomorphims `H → G` which is a closed embedding compatible with the actions,\nthen `H` also acts properly on `X`. -/\n@[to_additive \"If two groups `H` and `G` act on a topological space `X` such that `G` acts properly\nand there exists a group homomorphims `H → G` which is a closed embedding compatible with the\nactions, then `H` also acts properly on `X`.\"]\ntheorem properSMul_of_isClosedEmbedding {H : Type*} [Group H] [MulAction H X] [TopologicalSpace H]\n    [ProperSMul G X] (f : H →* G) (f_clemb : IsClosedEmbedding f)\n    (f_compat : ∀ (h : H) (x : X), f h • x = h • x) : ProperSMul H X where\n  isProperMap_smul_pair := by\n    have h : IsProperMap (Prod.map f (fun x : X ↦ x)) := f_clemb.isProperMap.prodMap isProperMap_id\n    have : (fun hx : H × X ↦ (hx.1 • hx.2, hx.2)) = (fun hx ↦ (f hx.1 • hx.2, hx.2)) := by\n      simp [f_compat]\n    rw [this]\n    exact h.comp <| ProperSMul.isProperMap_smul_pair\n\n"}
{"name":"properVAdd_of_isClosedEmbedding","module":"Mathlib.Topology.Algebra.ProperAction.Basic","initialProofState":"G : Type u_1\nX : Type u_2\ninst✝⁷ : AddGroup G\ninst✝⁶ : AddAction G X\ninst✝⁵ : TopologicalSpace G\ninst✝⁴ : TopologicalSpace X\nH : Type u_3\ninst✝³ : AddGroup H\ninst✝² : AddAction H X\ninst✝¹ : TopologicalSpace H\ninst✝ : ProperVAdd G X\nf : AddMonoidHom H G\nf_clemb : Topology.IsClosedEmbedding ⇑f\nf_compat : ∀ (h : H) (x : X), Eq (HVAdd.hVAdd (f h) x) (HVAdd.hVAdd h x)\n⊢ ProperVAdd H X","decl":"/-- If two groups `H` and `G` act on a topological space `X` such that `G` acts properly and\nthere exists a group homomorphims `H → G` which is a closed embedding compatible with the actions,\nthen `H` also acts properly on `X`. -/\n@[to_additive \"If two groups `H` and `G` act on a topological space `X` such that `G` acts properly\nand there exists a group homomorphims `H → G` which is a closed embedding compatible with the\nactions, then `H` also acts properly on `X`.\"]\ntheorem properSMul_of_isClosedEmbedding {H : Type*} [Group H] [MulAction H X] [TopologicalSpace H]\n    [ProperSMul G X] (f : H →* G) (f_clemb : IsClosedEmbedding f)\n    (f_compat : ∀ (h : H) (x : X), f h • x = h • x) : ProperSMul H X where\n  isProperMap_smul_pair := by\n    have h : IsProperMap (Prod.map f (fun x : X ↦ x)) := f_clemb.isProperMap.prodMap isProperMap_id\n    have : (fun hx : H × X ↦ (hx.1 • hx.2, hx.2)) = (fun hx ↦ (f hx.1 • hx.2, hx.2)) := by\n      simp [f_compat]\n    rw [this]\n    exact h.comp <| ProperSMul.isProperMap_smul_pair\n\n"}
{"name":"properSMul_of_closedEmbedding","module":"Mathlib.Topology.Algebra.ProperAction.Basic","initialProofState":"G : Type u_1\nX : Type u_2\ninst✝⁷ : Group G\ninst✝⁶ : MulAction G X\ninst✝⁵ : TopologicalSpace G\ninst✝⁴ : TopologicalSpace X\nH : Type u_3\ninst✝³ : Group H\ninst✝² : MulAction H X\ninst✝¹ : TopologicalSpace H\ninst✝ : ProperSMul G X\nf : MonoidHom H G\nf_clemb : Topology.IsClosedEmbedding ⇑f\nf_compat : ∀ (h : H) (x : X), Eq (HSMul.hSMul (f h) x) (HSMul.hSMul h x)\n⊢ ProperSMul H X","decl":"@[deprecated (since := \"2024-10-20\")]\nalias properSMul_of_closedEmbedding := properSMul_of_isClosedEmbedding\n\n"}
{"name":"instProperSMulSubtypeMemSubgroupOfIsClosedCoe","module":"Mathlib.Topology.Algebra.ProperAction.Basic","initialProofState":"G : Type u_1\nX : Type u_2\ninst✝⁴ : Group G\ninst✝³ : MulAction G X\ninst✝² : TopologicalSpace G\ninst✝¹ : TopologicalSpace X\nH : Subgroup G\ninst✝ : ProperSMul G X\nH_closed : IsClosed ↑H\n⊢ ProperSMul (Subtype fun x => Membership.mem H x) X","decl":"/-- If `H` is a closed subgroup of `G` and `G` acts properly on X then so does `H`. -/\n@[to_additive \"If `H` is a closed subgroup of `G` and `G` acts properly on X then so does `H`.\"]\ninstance {H : Subgroup G} [ProperSMul G X] [H_closed : IsClosed (H : Set G)] : ProperSMul H X :=\n  properSMul_of_isClosedEmbedding H.subtype H_closed.isClosedEmbedding_subtypeVal fun _ _ ↦ rfl\n"}
{"name":"instProperVAddSubtypeMemAddSubgroupOfIsClosedCoe","module":"Mathlib.Topology.Algebra.ProperAction.Basic","initialProofState":"G : Type u_1\nX : Type u_2\ninst✝⁴ : AddGroup G\ninst✝³ : AddAction G X\ninst✝² : TopologicalSpace G\ninst✝¹ : TopologicalSpace X\nH : AddSubgroup G\ninst✝ : ProperVAdd G X\nH_closed : IsClosed ↑H\n⊢ ProperVAdd (Subtype fun x => Membership.mem H x) X","decl":"/-- If `H` is a closed subgroup of `G` and `G` acts properly on X then so does `H`. -/\n@[to_additive \"If `H` is a closed subgroup of `G` and `G` acts properly on X then so does `H`.\"]\ninstance {H : Subgroup G} [ProperSMul G X] [H_closed : IsClosed (H : Set G)] : ProperSMul H X :=\n  properSMul_of_isClosedEmbedding H.subtype H_closed.isClosedEmbedding_subtypeVal fun _ _ ↦ rfl\n"}
