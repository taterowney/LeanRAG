{"name":"ProperVAdd.isProperMap_vadd_pair","module":"Mathlib.Topology.Algebra.ProperAction.Basic","initialProofState":"G : Type u_1\nX : Type u_2\ninst‚úù¬≥ : TopologicalSpace G\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : AddGroup G\ninst‚úù : AddAction G X\nself : ProperVAdd G X\n‚ä¢ IsProperMap fun gx => { fst := HVAdd.hVAdd gx.1 gx.2, snd := gx.2 }","decl":"/-- Proper group action in the sense of Bourbaki:\nthe map `G √ó X ‚Üí X √ó X` is a proper map (see `IsProperMap`). -/\nclass ProperVAdd (G X : Type*) [TopologicalSpace G] [TopologicalSpace X] [AddGroup G]\n    [AddAction G X] : Prop where\n  /-- Proper group action in the sense of Bourbaki:\n  the map `G √ó X ‚Üí X √ó X` is a proper map (see `IsProperMap`). -/\n  isProperMap_vadd_pair : IsProperMap (fun gx ‚Ü¶ (gx.1 +·µ• gx.2, gx.2) : G √ó X ‚Üí X √ó X)\n\n"}
{"name":"properSMul_iff","module":"Mathlib.Topology.Algebra.ProperAction.Basic","initialProofState":"G : Type u_1\nX : Type u_2\ninst‚úù¬≥ : TopologicalSpace G\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : Group G\ninst‚úù : MulAction G X\n‚ä¢ Iff (ProperSMul G X) (IsProperMap fun gx => { fst := HSMul.hSMul gx.1 gx.2, snd := gx.2 })","decl":"/-- Proper group action in the sense of Bourbaki:\nthe map `G √ó X ‚Üí X √ó X` is a proper map (see `IsProperMap`). -/\n@[to_additive existing (attr := mk_iff)]\nclass ProperSMul (G X : Type*) [TopologicalSpace G] [TopologicalSpace X] [Group G]\n    [MulAction G X] : Prop where\n  /-- Proper group action in the sense of Bourbaki:\n  the map `G √ó X ‚Üí X √ó X` is a proper map (see `IsProperMap`). -/\n  isProperMap_smul_pair : IsProperMap (fun gx ‚Ü¶ (gx.1 ‚Ä¢ gx.2, gx.2) : G √ó X ‚Üí X √ó X)\n\n"}
{"name":"properVAdd_iff","module":"Mathlib.Topology.Algebra.ProperAction.Basic","initialProofState":"G : Type u_1\nX : Type u_2\ninst‚úù¬≥ : TopologicalSpace G\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : AddGroup G\ninst‚úù : AddAction G X\n‚ä¢ Iff (ProperVAdd G X) (IsProperMap fun gx => { fst := HVAdd.hVAdd gx.1 gx.2, snd := gx.2 })","decl":"/-- Proper group action in the sense of Bourbaki:\nthe map `G √ó X ‚Üí X √ó X` is a proper map (see `IsProperMap`). -/\n@[to_additive existing (attr := mk_iff)]\nclass ProperSMul (G X : Type*) [TopologicalSpace G] [TopologicalSpace X] [Group G]\n    [MulAction G X] : Prop where\n  /-- Proper group action in the sense of Bourbaki:\n  the map `G √ó X ‚Üí X √ó X` is a proper map (see `IsProperMap`). -/\n  isProperMap_smul_pair : IsProperMap (fun gx ‚Ü¶ (gx.1 ‚Ä¢ gx.2, gx.2) : G √ó X ‚Üí X √ó X)\n\n"}
{"name":"ProperSMul.isProperMap_smul_pair","module":"Mathlib.Topology.Algebra.ProperAction.Basic","initialProofState":"G : Type u_1\nX : Type u_2\ninst‚úù¬≥ : TopologicalSpace G\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : Group G\ninst‚úù : MulAction G X\nself : ProperSMul G X\n‚ä¢ IsProperMap fun gx => { fst := HSMul.hSMul gx.1 gx.2, snd := gx.2 }","decl":"/-- Proper group action in the sense of Bourbaki:\nthe map `G √ó X ‚Üí X √ó X` is a proper map (see `IsProperMap`). -/\n@[to_additive existing (attr := mk_iff)]\nclass ProperSMul (G X : Type*) [TopologicalSpace G] [TopologicalSpace X] [Group G]\n    [MulAction G X] : Prop where\n  /-- Proper group action in the sense of Bourbaki:\n  the map `G √ó X ‚Üí X √ó X` is a proper map (see `IsProperMap`). -/\n  isProperMap_smul_pair : IsProperMap (fun gx ‚Ü¶ (gx.1 ‚Ä¢ gx.2, gx.2) : G √ó X ‚Üí X √ó X)\n\n"}
{"name":"ProperVAdd.toContinuousVAdd","module":"Mathlib.Topology.Algebra.ProperAction.Basic","initialProofState":"G : Type u_1\nX : Type u_2\ninst‚úù‚Å¥ : AddGroup G\ninst‚úù¬≥ : AddAction G X\ninst‚úù¬≤ : TopologicalSpace G\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : ProperVAdd G X\n‚ä¢ ContinuousVAdd G X","decl":"/-- If a group acts properly then in particular it acts continuously. -/\n@[to_additive \"If a group acts properly then in particular it acts continuously.\"]\n-- See note [lower instance property]\ninstance (priority := 100) ProperSMul.toContinuousSMul [ProperSMul G X] : ContinuousSMul G X where\n  continuous_smul := isProperMap_smul_pair.continuous.fst\n\n"}
{"name":"ProperSMul.toContinuousSMul","module":"Mathlib.Topology.Algebra.ProperAction.Basic","initialProofState":"G : Type u_1\nX : Type u_2\ninst‚úù‚Å¥ : Group G\ninst‚úù¬≥ : MulAction G X\ninst‚úù¬≤ : TopologicalSpace G\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : ProperSMul G X\n‚ä¢ ContinuousSMul G X","decl":"/-- If a group acts properly then in particular it acts continuously. -/\n@[to_additive \"If a group acts properly then in particular it acts continuously.\"]\n-- See note [lower instance property]\ninstance (priority := 100) ProperSMul.toContinuousSMul [ProperSMul G X] : ContinuousSMul G X where\n  continuous_smul := isProperMap_smul_pair.continuous.fst\n\n"}
{"name":"properVAdd_iff_continuousVAdd_ultrafilter_tendsto","module":"Mathlib.Topology.Algebra.ProperAction.Basic","initialProofState":"G : Type u_1\nX : Type u_2\ninst‚úù¬≥ : AddGroup G\ninst‚úù¬≤ : AddAction G X\ninst‚úù¬π : TopologicalSpace G\ninst‚úù : TopologicalSpace X\n‚ä¢ Iff (ProperVAdd G X) (And (ContinuousVAdd G X) (‚àÄ (ùí∞ : Ultrafilter (Prod G X)) (x‚ÇÅ x‚ÇÇ : X), Filter.Tendsto (fun gx => { fst := HVAdd.hVAdd gx.1 gx.2, snd := gx.2 }) (‚Üëùí∞) (nhds { fst := x‚ÇÅ, snd := x‚ÇÇ }) ‚Üí Exists fun g => And (Eq (HVAdd.hVAdd g x‚ÇÇ) x‚ÇÅ) (Filter.Tendsto Prod.fst (‚Üëùí∞) (nhds g))))","decl":"/-- A group `G` acts properly on a topological space `X` if and only if for all ultrafilters\n`ùí∞` on `X √ó G`, if `ùí∞` converges to `(x‚ÇÅ, x‚ÇÇ)` along the map `(g, x) ‚Ü¶ (g ‚Ä¢ x, x)`,\nthen there exists `g : G` such that `g ‚Ä¢ x‚ÇÇ = x‚ÇÅ` and `ùí∞.fst` converges to `g`. -/\n@[to_additive \"A group `G` acts properly on a topological space `X` if and only if\nfor all ultrafilters `ùí∞` on `X`, if `ùí∞` converges to `(x‚ÇÅ, x‚ÇÇ)`\nalong the map `(g, x) ‚Ü¶ (g ‚Ä¢ x, x)`, then there exists `g : G` such that `g ‚Ä¢ x‚ÇÇ = x‚ÇÅ`\nand `ùí∞.fst` converges to `g`.\"]\ntheorem properSMul_iff_continuousSMul_ultrafilter_tendsto :\n    ProperSMul G X ‚Üî ContinuousSMul G X ‚àß\n      (‚àÄ ùí∞ : Ultrafilter (G √ó X), ‚àÄ x‚ÇÅ x‚ÇÇ : X,\n        Tendsto (fun gx : G √ó X ‚Ü¶ (gx.1 ‚Ä¢ gx.2, gx.2)) ùí∞ (ùìù (x‚ÇÅ, x‚ÇÇ)) ‚Üí\n      ‚àÉ g : G, g ‚Ä¢ x‚ÇÇ = x‚ÇÅ ‚àß Tendsto (Prod.fst : G √ó X ‚Üí G) ùí∞ (ùìù g)) := by\n  refine ‚ü®fun h ‚Ü¶ ‚ü®inferInstance, fun ùí∞ x‚ÇÅ x‚ÇÇ h' ‚Ü¶ ?_‚ü©, fun ‚ü®cont, h‚ü© ‚Ü¶ ?_‚ü©\n  ¬∑ rw [properSMul_iff, isProperMap_iff_ultrafilter] at h\n    rcases h.2 h' with ‚ü®gx, hgx1, hgx2‚ü©\n    refine ‚ü®gx.1, ?_, (continuous_fst.tendsto gx).mono_left hgx2‚ü©\n    simp only [Prod.mk.injEq] at hgx1\n    rw [‚Üê hgx1.2, hgx1.1]\n  ¬∑ rw [properSMul_iff, isProperMap_iff_ultrafilter]\n    refine ‚ü®by fun_prop, fun ùí∞ (x‚ÇÅ, x‚ÇÇ) hxx ‚Ü¶ ?_‚ü©\n    rcases h ùí∞ x‚ÇÅ x‚ÇÇ hxx with ‚ü®g, hg1, hg2‚ü©\n    refine ‚ü®(g, x‚ÇÇ), by simp_rw [hg1], ?_‚ü©\n    rw [nhds_prod_eq, ùí∞.le_prod]\n    exact ‚ü®hg2, (continuous_snd.tendsto _).comp hxx‚ü©\n\n"}
{"name":"properSMul_iff_continuousSMul_ultrafilter_tendsto","module":"Mathlib.Topology.Algebra.ProperAction.Basic","initialProofState":"G : Type u_1\nX : Type u_2\ninst‚úù¬≥ : Group G\ninst‚úù¬≤ : MulAction G X\ninst‚úù¬π : TopologicalSpace G\ninst‚úù : TopologicalSpace X\n‚ä¢ Iff (ProperSMul G X) (And (ContinuousSMul G X) (‚àÄ (ùí∞ : Ultrafilter (Prod G X)) (x‚ÇÅ x‚ÇÇ : X), Filter.Tendsto (fun gx => { fst := HSMul.hSMul gx.1 gx.2, snd := gx.2 }) (‚Üëùí∞) (nhds { fst := x‚ÇÅ, snd := x‚ÇÇ }) ‚Üí Exists fun g => And (Eq (HSMul.hSMul g x‚ÇÇ) x‚ÇÅ) (Filter.Tendsto Prod.fst (‚Üëùí∞) (nhds g))))","decl":"/-- A group `G` acts properly on a topological space `X` if and only if for all ultrafilters\n`ùí∞` on `X √ó G`, if `ùí∞` converges to `(x‚ÇÅ, x‚ÇÇ)` along the map `(g, x) ‚Ü¶ (g ‚Ä¢ x, x)`,\nthen there exists `g : G` such that `g ‚Ä¢ x‚ÇÇ = x‚ÇÅ` and `ùí∞.fst` converges to `g`. -/\n@[to_additive \"A group `G` acts properly on a topological space `X` if and only if\nfor all ultrafilters `ùí∞` on `X`, if `ùí∞` converges to `(x‚ÇÅ, x‚ÇÇ)`\nalong the map `(g, x) ‚Ü¶ (g ‚Ä¢ x, x)`, then there exists `g : G` such that `g ‚Ä¢ x‚ÇÇ = x‚ÇÅ`\nand `ùí∞.fst` converges to `g`.\"]\ntheorem properSMul_iff_continuousSMul_ultrafilter_tendsto :\n    ProperSMul G X ‚Üî ContinuousSMul G X ‚àß\n      (‚àÄ ùí∞ : Ultrafilter (G √ó X), ‚àÄ x‚ÇÅ x‚ÇÇ : X,\n        Tendsto (fun gx : G √ó X ‚Ü¶ (gx.1 ‚Ä¢ gx.2, gx.2)) ùí∞ (ùìù (x‚ÇÅ, x‚ÇÇ)) ‚Üí\n      ‚àÉ g : G, g ‚Ä¢ x‚ÇÇ = x‚ÇÅ ‚àß Tendsto (Prod.fst : G √ó X ‚Üí G) ùí∞ (ùìù g)) := by\n  refine ‚ü®fun h ‚Ü¶ ‚ü®inferInstance, fun ùí∞ x‚ÇÅ x‚ÇÇ h' ‚Ü¶ ?_‚ü©, fun ‚ü®cont, h‚ü© ‚Ü¶ ?_‚ü©\n  ¬∑ rw [properSMul_iff, isProperMap_iff_ultrafilter] at h\n    rcases h.2 h' with ‚ü®gx, hgx1, hgx2‚ü©\n    refine ‚ü®gx.1, ?_, (continuous_fst.tendsto gx).mono_left hgx2‚ü©\n    simp only [Prod.mk.injEq] at hgx1\n    rw [‚Üê hgx1.2, hgx1.1]\n  ¬∑ rw [properSMul_iff, isProperMap_iff_ultrafilter]\n    refine ‚ü®by fun_prop, fun ùí∞ (x‚ÇÅ, x‚ÇÇ) hxx ‚Ü¶ ?_‚ü©\n    rcases h ùí∞ x‚ÇÅ x‚ÇÇ hxx with ‚ü®g, hg1, hg2‚ü©\n    refine ‚ü®(g, x‚ÇÇ), by simp_rw [hg1], ?_‚ü©\n    rw [nhds_prod_eq, ùí∞.le_prod]\n    exact ‚ü®hg2, (continuous_snd.tendsto _).comp hxx‚ü©\n\n"}
{"name":"properSMul_iff_continuousSMul_ultrafilter_tendsto_t2","module":"Mathlib.Topology.Algebra.ProperAction.Basic","initialProofState":"G : Type u_1\nX : Type u_2\ninst‚úù‚Å¥ : Group G\ninst‚úù¬≥ : MulAction G X\ninst‚úù¬≤ : TopologicalSpace G\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T2Space X\n‚ä¢ Iff (ProperSMul G X) (And (ContinuousSMul G X) (‚àÄ (ùí∞ : Ultrafilter (Prod G X)) (x‚ÇÅ x‚ÇÇ : X), Filter.Tendsto (fun gx => { fst := HSMul.hSMul gx.1 gx.2, snd := gx.2 }) (‚Üëùí∞) (nhds { fst := x‚ÇÅ, snd := x‚ÇÇ }) ‚Üí Exists fun g => Filter.Tendsto Prod.fst (‚Üëùí∞) (nhds g)))","decl":"/-- A group `G` acts properly on a T2 topological space `X` if and only if for all ultrafilters\n`ùí∞` on `X √ó G`, if `ùí∞` converges to `(x‚ÇÅ, x‚ÇÇ)` along the map `(g, x) ‚Ü¶ (g ‚Ä¢ x, x)`,\nthen there exists `g : G` such that `ùí∞.fst` converges to `g`. -/\ntheorem properSMul_iff_continuousSMul_ultrafilter_tendsto_t2 [T2Space X] :\n    ProperSMul G X ‚Üî ContinuousSMul G X ‚àß\n      (‚àÄ ùí∞ : Ultrafilter (G √ó X), ‚àÄ x‚ÇÅ x‚ÇÇ : X,\n        Tendsto (fun gx : G √ó X ‚Ü¶ (gx.1 ‚Ä¢ gx.2, gx.2)) ùí∞ (ùìù (x‚ÇÅ, x‚ÇÇ)) ‚Üí\n     ‚àÉ g : G, Tendsto (Prod.fst : G √ó X ‚Üí G) ùí∞ (ùìù g)) := by\n  rw [properSMul_iff_continuousSMul_ultrafilter_tendsto]\n  refine and_congr_right fun hc ‚Ü¶ ?_\n  congrm ‚àÄ ùí∞ x‚ÇÅ x‚ÇÇ hxx, ‚àÉ g, ?_\n  exact and_iff_right_of_imp fun hg ‚Ü¶ tendsto_nhds_unique\n    (hg.smul ((continuous_snd.tendsto _).comp hxx)) ((continuous_fst.tendsto _).comp hxx)\n\n"}
{"name":"t2Space_quotient_addAction_of_properVAdd","module":"Mathlib.Topology.Algebra.ProperAction.Basic","initialProofState":"G : Type u_1\nX : Type u_2\ninst‚úù‚Å¥ : AddGroup G\ninst‚úù¬≥ : AddAction G X\ninst‚úù¬≤ : TopologicalSpace G\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : ProperVAdd G X\n‚ä¢ T2Space (Quotient (AddAction.orbitRel G X))","decl":"/-- If `G` acts properly on `X`, then the quotient space is Hausdorff (T2). -/\n@[to_additive \"If `G` acts properly on `X`, then the quotient space is Hausdorff (T2).\"]\ntheorem t2Space_quotient_mulAction_of_properSMul [ProperSMul G X] :\n    T2Space (Quotient (MulAction.orbitRel G X)) := by\n  rw [t2_iff_isClosed_diagonal]\n  set R := MulAction.orbitRel G X\n  let œÄ : X ‚Üí Quotient R := Quotient.mk'\n  have : IsOpenQuotientMap (Prod.map œÄ œÄ) :=\n    MulAction.isOpenQuotientMap_quotientMk.prodMap MulAction.isOpenQuotientMap_quotientMk\n  rw [‚Üê this.isQuotientMap.isClosed_preimage]\n  convert ProperSMul.isProperMap_smul_pair.isClosedMap.isClosed_range\n  ¬∑ ext ‚ü®x‚ÇÅ, x‚ÇÇ‚ü©\n    simp only [mem_preimage, map_apply, mem_diagonal_iff, mem_range, Prod.mk.injEq, Prod.exists,\n      exists_eq_right]\n    rw [Quotient.eq', MulAction.orbitRel_apply, MulAction.mem_orbit_iff]\n  all_goals infer_instance\n\n"}
{"name":"t2Space_quotient_mulAction_of_properSMul","module":"Mathlib.Topology.Algebra.ProperAction.Basic","initialProofState":"G : Type u_1\nX : Type u_2\ninst‚úù‚Å¥ : Group G\ninst‚úù¬≥ : MulAction G X\ninst‚úù¬≤ : TopologicalSpace G\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : ProperSMul G X\n‚ä¢ T2Space (Quotient (MulAction.orbitRel G X))","decl":"/-- If `G` acts properly on `X`, then the quotient space is Hausdorff (T2). -/\n@[to_additive \"If `G` acts properly on `X`, then the quotient space is Hausdorff (T2).\"]\ntheorem t2Space_quotient_mulAction_of_properSMul [ProperSMul G X] :\n    T2Space (Quotient (MulAction.orbitRel G X)) := by\n  rw [t2_iff_isClosed_diagonal]\n  set R := MulAction.orbitRel G X\n  let œÄ : X ‚Üí Quotient R := Quotient.mk'\n  have : IsOpenQuotientMap (Prod.map œÄ œÄ) :=\n    MulAction.isOpenQuotientMap_quotientMk.prodMap MulAction.isOpenQuotientMap_quotientMk\n  rw [‚Üê this.isQuotientMap.isClosed_preimage]\n  convert ProperSMul.isProperMap_smul_pair.isClosedMap.isClosed_range\n  ¬∑ ext ‚ü®x‚ÇÅ, x‚ÇÇ‚ü©\n    simp only [mem_preimage, map_apply, mem_diagonal_iff, mem_range, Prod.mk.injEq, Prod.exists,\n      exists_eq_right]\n    rw [Quotient.eq', MulAction.orbitRel_apply, MulAction.mem_orbit_iff]\n  all_goals infer_instance\n\n"}
{"name":"t2Space_of_properVAdd_of_t2AddGroup","module":"Mathlib.Topology.Algebra.ProperAction.Basic","initialProofState":"G : Type u_1\nX : Type u_2\ninst‚úù‚Å¥ : AddGroup G\ninst‚úù¬≥ : AddAction G X\ninst‚úù¬≤ : TopologicalSpace G\ninst‚úù¬π : TopologicalSpace X\nh_proper : ProperVAdd G X\ninst‚úù : T2Space G\n‚ä¢ T2Space X","decl":"/-- If a T2 group acts properly on a topological space, then this topological space is T2. -/\n@[to_additive \"If a T2 group acts properly on a topological space,\nthen this topological space is T2.\"]\ntheorem t2Space_of_properSMul_of_t2Group [h_proper : ProperSMul G X] [T2Space G] : T2Space X := by\n  let f := fun x : X ‚Ü¶ ((1 : G), x)\n  have proper_f : IsProperMap f := by\n    refine IsClosedEmbedding.isProperMap ‚ü®?_, ?_‚ü©\n    ¬∑ let g := fun gx : G √ó X ‚Ü¶ gx.2\n      have : Function.LeftInverse g f := fun x ‚Ü¶ by simp [f, g]\n      exact this.isEmbedding (by fun_prop) (by fun_prop)\n    ¬∑ have : range f = ({1} √óÀ¢ univ) := by simp [f]\n      rw [this]\n      exact isClosed_singleton.prod isClosed_univ\n  rw [t2_iff_isClosed_diagonal]\n  let g := fun gx : G √ó X ‚Ü¶ (gx.1 ‚Ä¢ gx.2, gx.2)\n  have proper_g : IsProperMap g := (properSMul_iff G X).1 h_proper\n  have : g ‚àò f = fun x ‚Ü¶ (x, x) := by ext x <;> simp [f, g]\n  have range_gf : range (g ‚àò f) = diagonal X := by simp [this]\n  rw [‚Üê range_gf]\n  exact (proper_f.comp proper_g).isClosed_range\n\n"}
{"name":"t2Space_of_properSMul_of_t2Group","module":"Mathlib.Topology.Algebra.ProperAction.Basic","initialProofState":"G : Type u_1\nX : Type u_2\ninst‚úù‚Å¥ : Group G\ninst‚úù¬≥ : MulAction G X\ninst‚úù¬≤ : TopologicalSpace G\ninst‚úù¬π : TopologicalSpace X\nh_proper : ProperSMul G X\ninst‚úù : T2Space G\n‚ä¢ T2Space X","decl":"/-- If a T2 group acts properly on a topological space, then this topological space is T2. -/\n@[to_additive \"If a T2 group acts properly on a topological space,\nthen this topological space is T2.\"]\ntheorem t2Space_of_properSMul_of_t2Group [h_proper : ProperSMul G X] [T2Space G] : T2Space X := by\n  let f := fun x : X ‚Ü¶ ((1 : G), x)\n  have proper_f : IsProperMap f := by\n    refine IsClosedEmbedding.isProperMap ‚ü®?_, ?_‚ü©\n    ¬∑ let g := fun gx : G √ó X ‚Ü¶ gx.2\n      have : Function.LeftInverse g f := fun x ‚Ü¶ by simp [f, g]\n      exact this.isEmbedding (by fun_prop) (by fun_prop)\n    ¬∑ have : range f = ({1} √óÀ¢ univ) := by simp [f]\n      rw [this]\n      exact isClosed_singleton.prod isClosed_univ\n  rw [t2_iff_isClosed_diagonal]\n  let g := fun gx : G √ó X ‚Ü¶ (gx.1 ‚Ä¢ gx.2, gx.2)\n  have proper_g : IsProperMap g := (properSMul_iff G X).1 h_proper\n  have : g ‚àò f = fun x ‚Ü¶ (x, x) := by ext x <;> simp [f, g]\n  have range_gf : range (g ‚àò f) = diagonal X := by simp [this]\n  rw [‚Üê range_gf]\n  exact (proper_f.comp proper_g).isClosed_range\n\n"}
{"name":"properSMul_of_isClosedEmbedding","module":"Mathlib.Topology.Algebra.ProperAction.Basic","initialProofState":"G : Type u_1\nX : Type u_2\ninst‚úù‚Å∑ : Group G\ninst‚úù‚Å∂ : MulAction G X\ninst‚úù‚Åµ : TopologicalSpace G\ninst‚úù‚Å¥ : TopologicalSpace X\nH : Type u_3\ninst‚úù¬≥ : Group H\ninst‚úù¬≤ : MulAction H X\ninst‚úù¬π : TopologicalSpace H\ninst‚úù : ProperSMul G X\nf : MonoidHom H G\nf_clemb : Topology.IsClosedEmbedding ‚áëf\nf_compat : ‚àÄ (h : H) (x : X), Eq (HSMul.hSMul (f h) x) (HSMul.hSMul h x)\n‚ä¢ ProperSMul H X","decl":"/-- If two groups `H` and `G` act on a topological space `X` such that `G` acts properly and\nthere exists a group homomorphims `H ‚Üí G` which is a closed embedding compatible with the actions,\nthen `H` also acts properly on `X`. -/\n@[to_additive \"If two groups `H` and `G` act on a topological space `X` such that `G` acts properly\nand there exists a group homomorphims `H ‚Üí G` which is a closed embedding compatible with the\nactions, then `H` also acts properly on `X`.\"]\ntheorem properSMul_of_isClosedEmbedding {H : Type*} [Group H] [MulAction H X] [TopologicalSpace H]\n    [ProperSMul G X] (f : H ‚Üí* G) (f_clemb : IsClosedEmbedding f)\n    (f_compat : ‚àÄ (h : H) (x : X), f h ‚Ä¢ x = h ‚Ä¢ x) : ProperSMul H X where\n  isProperMap_smul_pair := by\n    have h : IsProperMap (Prod.map f (fun x : X ‚Ü¶ x)) := f_clemb.isProperMap.prodMap isProperMap_id\n    have : (fun hx : H √ó X ‚Ü¶ (hx.1 ‚Ä¢ hx.2, hx.2)) = (fun hx ‚Ü¶ (f hx.1 ‚Ä¢ hx.2, hx.2)) := by\n      simp [f_compat]\n    rw [this]\n    exact h.comp <| ProperSMul.isProperMap_smul_pair\n\n"}
{"name":"properVAdd_of_isClosedEmbedding","module":"Mathlib.Topology.Algebra.ProperAction.Basic","initialProofState":"G : Type u_1\nX : Type u_2\ninst‚úù‚Å∑ : AddGroup G\ninst‚úù‚Å∂ : AddAction G X\ninst‚úù‚Åµ : TopologicalSpace G\ninst‚úù‚Å¥ : TopologicalSpace X\nH : Type u_3\ninst‚úù¬≥ : AddGroup H\ninst‚úù¬≤ : AddAction H X\ninst‚úù¬π : TopologicalSpace H\ninst‚úù : ProperVAdd G X\nf : AddMonoidHom H G\nf_clemb : Topology.IsClosedEmbedding ‚áëf\nf_compat : ‚àÄ (h : H) (x : X), Eq (HVAdd.hVAdd (f h) x) (HVAdd.hVAdd h x)\n‚ä¢ ProperVAdd H X","decl":"/-- If two groups `H` and `G` act on a topological space `X` such that `G` acts properly and\nthere exists a group homomorphims `H ‚Üí G` which is a closed embedding compatible with the actions,\nthen `H` also acts properly on `X`. -/\n@[to_additive \"If two groups `H` and `G` act on a topological space `X` such that `G` acts properly\nand there exists a group homomorphims `H ‚Üí G` which is a closed embedding compatible with the\nactions, then `H` also acts properly on `X`.\"]\ntheorem properSMul_of_isClosedEmbedding {H : Type*} [Group H] [MulAction H X] [TopologicalSpace H]\n    [ProperSMul G X] (f : H ‚Üí* G) (f_clemb : IsClosedEmbedding f)\n    (f_compat : ‚àÄ (h : H) (x : X), f h ‚Ä¢ x = h ‚Ä¢ x) : ProperSMul H X where\n  isProperMap_smul_pair := by\n    have h : IsProperMap (Prod.map f (fun x : X ‚Ü¶ x)) := f_clemb.isProperMap.prodMap isProperMap_id\n    have : (fun hx : H √ó X ‚Ü¶ (hx.1 ‚Ä¢ hx.2, hx.2)) = (fun hx ‚Ü¶ (f hx.1 ‚Ä¢ hx.2, hx.2)) := by\n      simp [f_compat]\n    rw [this]\n    exact h.comp <| ProperSMul.isProperMap_smul_pair\n\n"}
{"name":"properSMul_of_closedEmbedding","module":"Mathlib.Topology.Algebra.ProperAction.Basic","initialProofState":"G : Type u_1\nX : Type u_2\ninst‚úù‚Å∑ : Group G\ninst‚úù‚Å∂ : MulAction G X\ninst‚úù‚Åµ : TopologicalSpace G\ninst‚úù‚Å¥ : TopologicalSpace X\nH : Type u_3\ninst‚úù¬≥ : Group H\ninst‚úù¬≤ : MulAction H X\ninst‚úù¬π : TopologicalSpace H\ninst‚úù : ProperSMul G X\nf : MonoidHom H G\nf_clemb : Topology.IsClosedEmbedding ‚áëf\nf_compat : ‚àÄ (h : H) (x : X), Eq (HSMul.hSMul (f h) x) (HSMul.hSMul h x)\n‚ä¢ ProperSMul H X","decl":"@[deprecated (since := \"2024-10-20\")]\nalias properSMul_of_closedEmbedding := properSMul_of_isClosedEmbedding\n\n"}
{"name":"instProperSMulSubtypeMemSubgroupOfIsClosedCoe","module":"Mathlib.Topology.Algebra.ProperAction.Basic","initialProofState":"G : Type u_1\nX : Type u_2\ninst‚úù‚Å¥ : Group G\ninst‚úù¬≥ : MulAction G X\ninst‚úù¬≤ : TopologicalSpace G\ninst‚úù¬π : TopologicalSpace X\nH : Subgroup G\ninst‚úù : ProperSMul G X\nH_closed : IsClosed ‚ÜëH\n‚ä¢ ProperSMul (Subtype fun x => Membership.mem H x) X","decl":"/-- If `H` is a closed subgroup of `G` and `G` acts properly on X then so does `H`. -/\n@[to_additive \"If `H` is a closed subgroup of `G` and `G` acts properly on X then so does `H`.\"]\ninstance {H : Subgroup G} [ProperSMul G X] [H_closed : IsClosed (H : Set G)] : ProperSMul H X :=\n  properSMul_of_isClosedEmbedding H.subtype H_closed.isClosedEmbedding_subtypeVal fun _ _ ‚Ü¶ rfl\n"}
{"name":"instProperVAddSubtypeMemAddSubgroupOfIsClosedCoe","module":"Mathlib.Topology.Algebra.ProperAction.Basic","initialProofState":"G : Type u_1\nX : Type u_2\ninst‚úù‚Å¥ : AddGroup G\ninst‚úù¬≥ : AddAction G X\ninst‚úù¬≤ : TopologicalSpace G\ninst‚úù¬π : TopologicalSpace X\nH : AddSubgroup G\ninst‚úù : ProperVAdd G X\nH_closed : IsClosed ‚ÜëH\n‚ä¢ ProperVAdd (Subtype fun x => Membership.mem H x) X","decl":"/-- If `H` is a closed subgroup of `G` and `G` acts properly on X then so does `H`. -/\n@[to_additive \"If `H` is a closed subgroup of `G` and `G` acts properly on X then so does `H`.\"]\ninstance {H : Subgroup G} [ProperSMul G X] [H_closed : IsClosed (H : Set G)] : ProperSMul H X :=\n  properSMul_of_isClosedEmbedding H.subtype H_closed.isClosedEmbedding_subtypeVal fun _ _ ‚Ü¶ rfl\n"}
