{"name":"AffineSubspace.nonempty_map","module":"Mathlib.LinearAlgebra.AffineSpace.Restrict","initialProofState":"k : Type u_1\nV₁ : Type u_2\nP₁ : Type u_3\nV₂ : Type u_4\nP₂ : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : AddCommGroup V₂\ninst✝³ : Module k V₁\ninst✝² : Module k V₂\ninst✝¹ : AddTorsor V₁ P₁\ninst✝ : AddTorsor V₂ P₂\nE : AffineSubspace k P₁\nEne : Nonempty (Subtype fun x => Membership.mem E x)\nφ : AffineMap k P₁ P₂\n⊢ Nonempty (Subtype fun x => Membership.mem (AffineSubspace.map φ E) x)","decl":"theorem AffineSubspace.nonempty_map {E : AffineSubspace k P₁} [Ene : Nonempty E] {φ : P₁ →ᵃ[k] P₂} :\n    Nonempty (E.map φ) := by\n  obtain ⟨x, hx⟩ := id Ene\n  exact ⟨⟨φ x, AffineSubspace.mem_map.mpr ⟨x, hx, rfl⟩⟩⟩\n\n-- Porting note: removed \"local nolint fails_quickly\" attribute\n"}
{"name":"AffineMap.restrict.coe_apply","module":"Mathlib.LinearAlgebra.AffineSpace.Restrict","initialProofState":"k : Type u_1\nV₁ : Type u_2\nP₁ : Type u_3\nV₂ : Type u_4\nP₂ : Type u_5\ninst✝⁸ : Ring k\ninst✝⁷ : AddCommGroup V₁\ninst✝⁶ : AddCommGroup V₂\ninst✝⁵ : Module k V₁\ninst✝⁴ : Module k V₂\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddTorsor V₂ P₂\nφ : AffineMap k P₁ P₂\nE : AffineSubspace k P₁\nF : AffineSubspace k P₂\ninst✝¹ : Nonempty (Subtype fun x => Membership.mem E x)\ninst✝ : Nonempty (Subtype fun x => Membership.mem F x)\nhEF : LE.le (AffineSubspace.map φ E) F\nx : Subtype fun x => Membership.mem E x\n⊢ Eq (↑((φ.restrict hEF) x)) (φ ↑x)","decl":"theorem AffineMap.restrict.coe_apply (φ : P₁ →ᵃ[k] P₂) {E : AffineSubspace k P₁}\n    {F : AffineSubspace k P₂} [Nonempty E] [Nonempty F] (hEF : E.map φ ≤ F) (x : E) :\n    ↑(φ.restrict hEF x) = φ x :=\n  rfl\n\n"}
{"name":"AffineMap.restrict.linear_aux","module":"Mathlib.LinearAlgebra.AffineSpace.Restrict","initialProofState":"k : Type u_1\nV₁ : Type u_2\nP₁ : Type u_3\nV₂ : Type u_4\nP₂ : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : AddCommGroup V₂\ninst✝³ : Module k V₁\ninst✝² : Module k V₂\ninst✝¹ : AddTorsor V₁ P₁\ninst✝ : AddTorsor V₂ P₂\nφ : AffineMap k P₁ P₂\nE : AffineSubspace k P₁\nF : AffineSubspace k P₂\nhEF : LE.le (AffineSubspace.map φ E) F\n⊢ LE.le E.direction (Submodule.comap φ.linear F.direction)","decl":"theorem AffineMap.restrict.linear_aux {φ : P₁ →ᵃ[k] P₂} {E : AffineSubspace k P₁}\n    {F : AffineSubspace k P₂} (hEF : E.map φ ≤ F) : E.direction ≤ F.direction.comap φ.linear := by\n  rw [← Submodule.map_le_iff_le_comap, ← AffineSubspace.map_direction]\n  exact AffineSubspace.direction_le hEF\n\n"}
{"name":"AffineMap.restrict.linear","module":"Mathlib.LinearAlgebra.AffineSpace.Restrict","initialProofState":"k : Type u_1\nV₁ : Type u_2\nP₁ : Type u_3\nV₂ : Type u_4\nP₂ : Type u_5\ninst✝⁸ : Ring k\ninst✝⁷ : AddCommGroup V₁\ninst✝⁶ : AddCommGroup V₂\ninst✝⁵ : Module k V₁\ninst✝⁴ : Module k V₂\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddTorsor V₂ P₂\nφ : AffineMap k P₁ P₂\nE : AffineSubspace k P₁\nF : AffineSubspace k P₂\ninst✝¹ : Nonempty (Subtype fun x => Membership.mem E x)\ninst✝ : Nonempty (Subtype fun x => Membership.mem F x)\nhEF : LE.le (AffineSubspace.map φ E) F\n⊢ Eq (φ.restrict hEF).linear (φ.linear.restrict ⋯)","decl":"theorem AffineMap.restrict.linear (φ : P₁ →ᵃ[k] P₂) {E : AffineSubspace k P₁}\n    {F : AffineSubspace k P₂} [Nonempty E] [Nonempty F] (hEF : E.map φ ≤ F) :\n    (φ.restrict hEF).linear = φ.linear.restrict (AffineMap.restrict.linear_aux hEF) :=\n  rfl\n\n"}
{"name":"AffineMap.restrict.injective","module":"Mathlib.LinearAlgebra.AffineSpace.Restrict","initialProofState":"k : Type u_1\nV₁ : Type u_2\nP₁ : Type u_3\nV₂ : Type u_4\nP₂ : Type u_5\ninst✝⁸ : Ring k\ninst✝⁷ : AddCommGroup V₁\ninst✝⁶ : AddCommGroup V₂\ninst✝⁵ : Module k V₁\ninst✝⁴ : Module k V₂\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddTorsor V₂ P₂\nφ : AffineMap k P₁ P₂\nhφ : Function.Injective ⇑φ\nE : AffineSubspace k P₁\nF : AffineSubspace k P₂\ninst✝¹ : Nonempty (Subtype fun x => Membership.mem E x)\ninst✝ : Nonempty (Subtype fun x => Membership.mem F x)\nhEF : LE.le (AffineSubspace.map φ E) F\n⊢ Function.Injective ⇑(φ.restrict hEF)","decl":"theorem AffineMap.restrict.injective {φ : P₁ →ᵃ[k] P₂} (hφ : Function.Injective φ)\n    {E : AffineSubspace k P₁} {F : AffineSubspace k P₂} [Nonempty E] [Nonempty F]\n    (hEF : E.map φ ≤ F) : Function.Injective (AffineMap.restrict φ hEF) := by\n  intro x y h\n  simp only [Subtype.ext_iff, Subtype.coe_mk, AffineMap.restrict.coe_apply] at h ⊢\n  exact hφ h\n\n"}
{"name":"AffineMap.restrict.surjective","module":"Mathlib.LinearAlgebra.AffineSpace.Restrict","initialProofState":"k : Type u_1\nV₁ : Type u_2\nP₁ : Type u_3\nV₂ : Type u_4\nP₂ : Type u_5\ninst✝⁸ : Ring k\ninst✝⁷ : AddCommGroup V₁\ninst✝⁶ : AddCommGroup V₂\ninst✝⁵ : Module k V₁\ninst✝⁴ : Module k V₂\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddTorsor V₂ P₂\nφ : AffineMap k P₁ P₂\nE : AffineSubspace k P₁\nF : AffineSubspace k P₂\ninst✝¹ : Nonempty (Subtype fun x => Membership.mem E x)\ninst✝ : Nonempty (Subtype fun x => Membership.mem F x)\nh : Eq (AffineSubspace.map φ E) F\n⊢ Function.Surjective ⇑(φ.restrict ⋯)","decl":"theorem AffineMap.restrict.surjective (φ : P₁ →ᵃ[k] P₂) {E : AffineSubspace k P₁}\n    {F : AffineSubspace k P₂} [Nonempty E] [Nonempty F] (h : E.map φ = F) :\n    Function.Surjective (AffineMap.restrict φ (le_of_eq h)) := by\n  rintro ⟨x, hx : x ∈ F⟩\n  rw [← h, AffineSubspace.mem_map] at hx\n  obtain ⟨y, hy, rfl⟩ := hx\n  exact ⟨⟨y, hy⟩, rfl⟩\n\n"}
{"name":"AffineMap.restrict.bijective","module":"Mathlib.LinearAlgebra.AffineSpace.Restrict","initialProofState":"k : Type u_1\nV₁ : Type u_2\nP₁ : Type u_3\nV₂ : Type u_4\nP₂ : Type u_5\ninst✝⁷ : Ring k\ninst✝⁶ : AddCommGroup V₁\ninst✝⁵ : AddCommGroup V₂\ninst✝⁴ : Module k V₁\ninst✝³ : Module k V₂\ninst✝² : AddTorsor V₁ P₁\ninst✝¹ : AddTorsor V₂ P₂\nE : AffineSubspace k P₁\ninst✝ : Nonempty (Subtype fun x => Membership.mem E x)\nφ : AffineMap k P₁ P₂\nhφ : Function.Injective ⇑φ\n⊢ Function.Bijective ⇑(φ.restrict ⋯)","decl":"theorem AffineMap.restrict.bijective {E : AffineSubspace k P₁} [Nonempty E] {φ : P₁ →ᵃ[k] P₂}\n    (hφ : Function.Injective φ) : Function.Bijective (φ.restrict (le_refl (E.map φ))) :=\n  ⟨AffineMap.restrict.injective hφ _, AffineMap.restrict.surjective _ rfl⟩\n"}
