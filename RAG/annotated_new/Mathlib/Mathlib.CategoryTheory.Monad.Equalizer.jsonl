{"name":"CategoryTheory.Comonad.CofreeEqualizer.topMap_f","module":"Mathlib.CategoryTheory.Monad.Equalizer","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Comonad C\nX : T.Coalgebra\n⊢ Eq (CategoryTheory.Comonad.CofreeEqualizer.topMap X).f (T.map X.a)","decl":"/-- The top map in the equalizer diagram we will construct. -/\n@[simps!]\ndef CofreeEqualizer.topMap :  (Comonad.cofree T).obj X.A ⟶ (Comonad.cofree T).obj (T.obj X.A) :=\n  (Comonad.cofree T).map X.a\n\n"}
{"name":"CategoryTheory.Comonad.CofreeEqualizer.bottomMap_f","module":"Mathlib.CategoryTheory.Monad.Equalizer","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Comonad C\nX : T.Coalgebra\n⊢ Eq (CategoryTheory.Comonad.CofreeEqualizer.bottomMap X).f (T.δ.app X.A)","decl":"/-- The bottom map in the equalizer diagram we will construct. -/\n@[simps]\ndef CofreeEqualizer.bottomMap :\n    (Comonad.cofree T).obj X.A ⟶ (Comonad.cofree T).obj (T.obj X.A) where\n  f := T.δ.app X.A\n  h := T.coassoc X.A\n\n"}
{"name":"CategoryTheory.Comonad.CofreeEqualizer.ι_f","module":"Mathlib.CategoryTheory.Monad.Equalizer","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Comonad C\nX : T.Coalgebra\n⊢ Eq (CategoryTheory.Comonad.CofreeEqualizer.ι X).f X.a","decl":"/-- The fork map in the equalizer diagram we will construct. -/\n@[simps]\ndef CofreeEqualizer.ι : X ⟶ (Comonad.cofree T).obj X.A where\n  f := X.a\n  h := X.coassoc.symm\n\n"}
{"name":"CategoryTheory.Comonad.CofreeEqualizer.condition","module":"Mathlib.CategoryTheory.Monad.Equalizer","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Comonad C\nX : T.Coalgebra\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Comonad.CofreeEqualizer.ι X) (CategoryTheory.Comonad.CofreeEqualizer.topMap X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Comonad.CofreeEqualizer.ι X) (CategoryTheory.Comonad.CofreeEqualizer.bottomMap X))","decl":"theorem CofreeEqualizer.condition :\n    CofreeEqualizer.ι X ≫ CofreeEqualizer.topMap X =\n      CofreeEqualizer.ι X ≫ CofreeEqualizer.bottomMap X :=\n  Coalgebra.Hom.ext X.coassoc.symm\n\n"}
{"name":"CategoryTheory.Comonad.instIsCoreflexivePairCoalgebraTopMapBottomMap","module":"Mathlib.CategoryTheory.Monad.Equalizer","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Comonad C\nX : T.Coalgebra\n⊢ CategoryTheory.IsCoreflexivePair (CategoryTheory.Comonad.CofreeEqualizer.topMap X) (CategoryTheory.Comonad.CofreeEqualizer.bottomMap X)","decl":"instance : IsCoreflexivePair (CofreeEqualizer.topMap X) (CofreeEqualizer.bottomMap X) := by\n  apply IsCoreflexivePair.mk' _ _ _\n  · apply (cofree T).map (T.ε.app X.A)\n  · ext\n    dsimp\n    rw [← Functor.map_comp, X.counit, Functor.map_id]\n  · ext\n    apply Comonad.right_counit\n\n"}
{"name":"CategoryTheory.Comonad.beckCoalgebraFork_pt","module":"Mathlib.CategoryTheory.Monad.Equalizer","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Comonad C\nX : T.Coalgebra\n⊢ Eq (CategoryTheory.Comonad.beckCoalgebraFork X).pt X","decl":"/-- Construct the Beck fork in the category of coalgebras. This fork is coreflexive as well as an\nequalizer.\n-/\n@[simps!]\ndef beckCoalgebraFork : Fork (CofreeEqualizer.topMap X) (CofreeEqualizer.bottomMap X) :=\n  Fork.ofι _ (CofreeEqualizer.condition X)\n\n"}
{"name":"CategoryTheory.Comonad.beckCoalgebraFork_π_app","module":"Mathlib.CategoryTheory.Monad.Equalizer","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Comonad C\nX✝ : T.Coalgebra\nX : CategoryTheory.Limits.WalkingParallelPair\n⊢ Eq ((CategoryTheory.Comonad.beckCoalgebraFork X✝).π.app X) (CategoryTheory.Limits.WalkingParallelPair.rec (motive := fun t => Eq X t → Quiver.Hom X✝ ((CategoryTheory.Limits.parallelPair (CategoryTheory.Comonad.CofreeEqualizer.topMap X✝) (CategoryTheory.Comonad.CofreeEqualizer.bottomMap X✝)).obj X)) (fun h => Eq.rec (CategoryTheory.Comonad.CofreeEqualizer.ι X✝) ⋯) (fun h => Eq.rec (CategoryTheory.CategoryStruct.comp (CategoryTheory.Comonad.CofreeEqualizer.ι X✝) (CategoryTheory.Comonad.CofreeEqualizer.topMap X✝)) ⋯) X ⋯)","decl":"/-- Construct the Beck fork in the category of coalgebras. This fork is coreflexive as well as an\nequalizer.\n-/\n@[simps!]\ndef beckCoalgebraFork : Fork (CofreeEqualizer.topMap X) (CofreeEqualizer.bottomMap X) :=\n  Fork.ofι _ (CofreeEqualizer.condition X)\n\n"}
{"name":"CategoryTheory.Comonad.beckFork_pt","module":"Mathlib.CategoryTheory.Monad.Equalizer","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Comonad C\nX : T.Coalgebra\n⊢ Eq (CategoryTheory.Comonad.beckFork X).pt X.A","decl":"/-- This is the Beck fork. It is a split equalizer, in particular a equalizer. -/\n@[simps! pt]\ndef beckFork : Fork (T.map X.a) (T.δ.app _) :=\n  (beckSplitEqualizer X).asFork\n\n"}
{"name":"CategoryTheory.Comonad.beckFork_ι","module":"Mathlib.CategoryTheory.Monad.Equalizer","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Comonad C\nX : T.Coalgebra\n⊢ Eq (CategoryTheory.Comonad.beckFork X).ι X.a","decl":"@[simp]\ntheorem beckFork_ι : (beckFork X).ι = X.a :=\n  rfl\n\n"}
{"name":"CategoryTheory.Comonad.beckEqualizer_lift","module":"Mathlib.CategoryTheory.Monad.Equalizer","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Comonad C\nX : T.Coalgebra\ns : CategoryTheory.Limits.Fork (T.map X.a) (T.δ.app X.A)\n⊢ Eq ((CategoryTheory.Comonad.beckEqualizer X).lift s) (CategoryTheory.CategoryStruct.comp s.ι (T.ε.app X.A))","decl":"@[simp]\ntheorem beckEqualizer_lift (s : Fork (T.toFunctor.map X.a) (T.δ.app X.A)) :\n    (beckEqualizer X).lift s = s.ι ≫ T.ε.app _ :=\n  rfl\n\n"}
