{"name":"FiniteInter.univ_mem","module":"Mathlib.Data.Set.Constructions","initialProofState":"α : Type u_1\nS : Set (Set α)\nself : FiniteInter S\n⊢ Membership.mem S Set.univ","decl":"/-- A structure encapsulating the fact that a set of sets is closed under finite intersection. -/\nstructure FiniteInter : Prop where\n  /-- `univ_mem` states that `Set.univ` is in `S`. -/\n  univ_mem : Set.univ ∈ S\n  /-- `inter_mem` states that any two intersections of sets in `S` is also in `S`. -/\n  inter_mem : ∀ ⦃s⦄, s ∈ S → ∀ ⦃t⦄, t ∈ S → s ∩ t ∈ S\n\n"}
{"name":"FiniteInter.inter_mem","module":"Mathlib.Data.Set.Constructions","initialProofState":"α : Type u_1\nS : Set (Set α)\nself : FiniteInter S\ns : Set α\na✝¹ : Membership.mem S s\nt : Set α\na✝ : Membership.mem S t\n⊢ Membership.mem S (Inter.inter s t)","decl":"/-- A structure encapsulating the fact that a set of sets is closed under finite intersection. -/\nstructure FiniteInter : Prop where\n  /-- `univ_mem` states that `Set.univ` is in `S`. -/\n  univ_mem : Set.univ ∈ S\n  /-- `inter_mem` states that any two intersections of sets in `S` is also in `S`. -/\n  inter_mem : ∀ ⦃s⦄, s ∈ S → ∀ ⦃t⦄, t ∈ S → s ∩ t ∈ S\n\n"}
{"name":"FiniteInter.finiteInterClosure.brecOn","module":"Mathlib.Data.Set.Constructions","initialProofState":"α : Type u_1\nS : Set (Set α)\nmotive✝ : (a : Set α) → FiniteInter.finiteInterClosure S a → Prop\na✝ : Set α\nx✝ : FiniteInter.finiteInterClosure S a✝\nih✝ : ∀ (a : Set α) (x : FiniteInter.finiteInterClosure S a), x.below → motive✝ a x\n⊢ motive✝ a✝ x✝","decl":"/-- The smallest set of sets containing `S` which is closed under finite intersections. -/\ninductive finiteInterClosure : Set (Set α)\n  | basic {s} : s ∈ S → finiteInterClosure s\n  | univ : finiteInterClosure Set.univ\n  | inter {s t} : finiteInterClosure s → finiteInterClosure t → finiteInterClosure (s ∩ t)\n\n"}
{"name":"FiniteInter.finiteInterClosure_finiteInter","module":"Mathlib.Data.Set.Constructions","initialProofState":"α : Type u_1\nS : Set (Set α)\n⊢ FiniteInter (FiniteInter.finiteInterClosure S)","decl":"theorem finiteInterClosure_finiteInter : FiniteInter (finiteInterClosure S) :=\n  { univ_mem := finiteInterClosure.univ\n    inter_mem := fun _ h _ => finiteInterClosure.inter h }\n\n"}
{"name":"FiniteInter.finiteInter_mem","module":"Mathlib.Data.Set.Constructions","initialProofState":"α : Type u_1\nS : Set (Set α)\ncond : FiniteInter S\nF : Finset (Set α)\na✝ : HasSubset.Subset (↑F) S\n⊢ Membership.mem S (↑F).sInter","decl":"theorem finiteInter_mem (cond : FiniteInter S) (F : Finset (Set α)) :\n    ↑F ⊆ S → ⋂₀ (↑F : Set (Set α)) ∈ S := by\n  classical\n    refine Finset.induction_on F (fun _ => ?_) ?_\n    · simp [cond.univ_mem]\n    · intro a s _ h1 h2\n      suffices a ∩ ⋂₀ ↑s ∈ S by simpa\n      exact\n        cond.inter_mem (h2 (Finset.mem_insert_self a s))\n          (h1 fun x hx => h2 <| Finset.mem_insert_of_mem hx)\n\n"}
{"name":"FiniteInter.finiteInterClosure_insert","module":"Mathlib.Data.Set.Constructions","initialProofState":"α : Type u_1\nS : Set (Set α)\nA : Set α\ncond : FiniteInter S\nP : Set α\nH : Membership.mem (FiniteInter.finiteInterClosure (Insert.insert A S)) P\n⊢ Or (Membership.mem S P) (Exists fun Q => And (Membership.mem S Q) (Eq P (Inter.inter A Q)))","decl":"theorem finiteInterClosure_insert {A : Set α} (cond : FiniteInter S) (P)\n    (H : P ∈ finiteInterClosure (insert A S)) : P ∈ S ∨ ∃ Q ∈ S, P = A ∩ Q := by\n  induction H with\n  | basic h =>\n    cases h\n    · exact Or.inr ⟨Set.univ, cond.univ_mem, by simpa⟩\n    · exact Or.inl (by assumption)\n  | univ => exact Or.inl cond.univ_mem\n  | @inter T1 T2 _ _ h1 h2 =>\n    rcases h1 with (h | ⟨Q, hQ, rfl⟩) <;> rcases h2 with (i | ⟨R, hR, rfl⟩)\n    · exact Or.inl (cond.inter_mem h i)\n    · exact\n        Or.inr ⟨T1 ∩ R, cond.inter_mem h hR, by simp only [← Set.inter_assoc, Set.inter_comm _ A]⟩\n    · exact Or.inr ⟨Q ∩ T2, cond.inter_mem hQ i, by simp only [Set.inter_assoc]⟩\n    · exact\n        Or.inr\n          ⟨Q ∩ R, cond.inter_mem hQ hR, by\n            ext x\n            constructor <;> simp +contextual⟩\n\n"}
{"name":"FiniteInter.mk₂","module":"Mathlib.Data.Set.Constructions","initialProofState":"α : Type u_1\nS : Set (Set α)\nh : ∀ ⦃s : Set α⦄, Membership.mem S s → ∀ ⦃t : Set α⦄, Membership.mem S t → Membership.mem S (Inter.inter s t)\n⊢ FiniteInter (Insert.insert Set.univ S)","decl":"theorem mk₂ (h: ∀ ⦃s⦄, s ∈ S → ∀ ⦃t⦄, t ∈ S → s ∩ t ∈ S) :\n    FiniteInter (insert (univ : Set α) S) where\n  univ_mem := Set.mem_insert Set.univ S\n  inter_mem s hs t ht := by aesop\n\n"}
