{"name":"FreeCommRing.of_injective","module":"Mathlib.RingTheory.FreeCommRing","initialProofState":"α : Type u\n⊢ Function.Injective FreeCommRing.of","decl":"theorem of_injective : Function.Injective (of : α → FreeCommRing α) :=\n  FreeAbelianGroup.of_injective.comp fun _ _ =>\n    (Multiset.coe_eq_coe.trans List.singleton_perm_singleton).mp\n\n"}
{"name":"FreeCommRing.of_ne_zero","module":"Mathlib.RingTheory.FreeCommRing","initialProofState":"α : Type u\nx : α\n⊢ Ne (FreeCommRing.of x) 0","decl":"@[simp]\ntheorem of_ne_zero (x : α) : of x ≠ 0 := FreeAbelianGroup.of_ne_zero _\n\n"}
{"name":"FreeCommRing.zero_ne_of","module":"Mathlib.RingTheory.FreeCommRing","initialProofState":"α : Type u\nx : α\n⊢ Ne 0 (FreeCommRing.of x)","decl":"@[simp]\ntheorem zero_ne_of (x : α) : 0 ≠ of x := FreeAbelianGroup.zero_ne_of _\n\n"}
{"name":"FreeCommRing.of_ne_one","module":"Mathlib.RingTheory.FreeCommRing","initialProofState":"α : Type u\nx : α\n⊢ Ne (FreeCommRing.of x) 1","decl":"@[simp]\ntheorem of_ne_one (x : α) : of x ≠ 1 :=\n  FreeAbelianGroup.of_injective.ne <| Multiset.singleton_ne_zero _\n\n"}
{"name":"FreeCommRing.one_ne_of","module":"Mathlib.RingTheory.FreeCommRing","initialProofState":"α : Type u\nx : α\n⊢ Ne 1 (FreeCommRing.of x)","decl":"@[simp]\ntheorem one_ne_of (x : α) : 1 ≠ of x :=\n  FreeAbelianGroup.of_injective.ne <| Multiset.zero_ne_singleton _\n\n-- Porting note: added to ease a proof in `Mathlib.Algebra.Colimit.Ring`\n"}
{"name":"FreeCommRing.of_cons","module":"Mathlib.RingTheory.FreeCommRing","initialProofState":"α : Type u\na : α\nm : Multiset α\n⊢ Eq (FreeAbelianGroup.of (Multiplicative.ofAdd (Multiset.cons a m))) (HMul.hMul (FreeCommRing.of a) (FreeAbelianGroup.of (Multiplicative.ofAdd m)))","decl":"lemma of_cons (a : α) (m : Multiset α) : (FreeAbelianGroup.of (Multiplicative.ofAdd (a ::ₘ m))) =\n    @HMul.hMul _ (FreeCommRing α) (FreeCommRing α) _ (of a)\n    (FreeAbelianGroup.of (Multiplicative.ofAdd m)) := by\n  dsimp [FreeCommRing]\n  rw [← Multiset.singleton_add, ofAdd_add,\n    of, FreeAbelianGroup.of_mul_of]\n\n"}
{"name":"FreeCommRing.induction_on","module":"Mathlib.RingTheory.FreeCommRing","initialProofState":"α : Type u\nC : FreeCommRing α → Prop\nz : FreeCommRing α\nhn1 : C (-1)\nhb : ∀ (b : α), C (FreeCommRing.of b)\nha : ∀ (x y : FreeCommRing α), C x → C y → C (HAdd.hAdd x y)\nhm : ∀ (x y : FreeCommRing α), C x → C y → C (HMul.hMul x y)\n⊢ C z","decl":"@[elab_as_elim, induction_eliminator]\nprotected theorem induction_on {C : FreeCommRing α → Prop} (z : FreeCommRing α) (hn1 : C (-1))\n    (hb : ∀ b, C (of b)) (ha : ∀ x y, C x → C y → C (x + y)) (hm : ∀ x y, C x → C y → C (x * y)) :\n    C z :=\n  have hn : ∀ x, C x → C (-x) := fun x ih => neg_one_mul x ▸ hm _ _ hn1 ih\n  have h1 : C 1 := neg_neg (1 : FreeCommRing α) ▸ hn _ hn1\n  FreeAbelianGroup.induction_on z (neg_add_cancel (1 : FreeCommRing α) ▸ ha _ _ hn1 h1)\n    (fun m => Multiset.induction_on m h1 fun a m ih => by\n      convert hm (of a) _ (hb a) ih\n      apply of_cons)\n    (fun _ ih => hn _ ih) ha\n\n"}
{"name":"FreeCommRing.lift_of","module":"Mathlib.RingTheory.FreeCommRing","initialProofState":"α : Type u\nR : Type v\ninst✝ : CommRing R\nf : α → R\nx : α\n⊢ Eq ((FreeCommRing.lift f) (FreeCommRing.of x)) (f x)","decl":"@[simp]\ntheorem lift_of (x : α) : lift f (of x) = f x :=\n  (FreeAbelianGroup.lift.of _ _).trans <| mul_one _\n\n"}
{"name":"FreeCommRing.lift_comp_of","module":"Mathlib.RingTheory.FreeCommRing","initialProofState":"α : Type u\nR : Type v\ninst✝ : CommRing R\nf : RingHom (FreeCommRing α) R\n⊢ Eq (FreeCommRing.lift (Function.comp (⇑f) FreeCommRing.of)) f","decl":"@[simp]\ntheorem lift_comp_of (f : FreeCommRing α →+* R) : lift (f ∘ of) = f :=\n  RingHom.ext fun x =>\n    FreeCommRing.induction_on x (by rw [RingHom.map_neg, RingHom.map_one, f.map_neg, f.map_one])\n      (lift_of _) (fun x y ihx ihy => by rw [RingHom.map_add, f.map_add, ihx, ihy])\n      fun x y ihx ihy => by rw [RingHom.map_mul, f.map_mul, ihx, ihy]\n\n"}
{"name":"FreeCommRing.hom_ext","module":"Mathlib.RingTheory.FreeCommRing","initialProofState":"α : Type u\nR : Type v\ninst✝ : CommRing R\nf g : RingHom (FreeCommRing α) R\nh : ∀ (x : α), Eq (f (FreeCommRing.of x)) (g (FreeCommRing.of x))\n⊢ Eq f g","decl":"@[ext 1100]\ntheorem hom_ext ⦃f g : FreeCommRing α →+* R⦄ (h : ∀ x, f (of x) = g (of x)) : f = g :=\n  lift.symm.injective (funext h)\n\n"}
{"name":"FreeCommRing.hom_ext_iff","module":"Mathlib.RingTheory.FreeCommRing","initialProofState":"α : Type u\nR : Type v\ninst✝ : CommRing R\nf g : RingHom (FreeCommRing α) R\n⊢ Iff (Eq f g) (∀ (x : α), Eq (f (FreeCommRing.of x)) (g (FreeCommRing.of x)))","decl":"@[ext 1100]\ntheorem hom_ext ⦃f g : FreeCommRing α →+* R⦄ (h : ∀ x, f (of x) = g (of x)) : f = g :=\n  lift.symm.injective (funext h)\n\n"}
{"name":"FreeCommRing.map_of","module":"Mathlib.RingTheory.FreeCommRing","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nx : α\n⊢ Eq ((FreeCommRing.map f) (FreeCommRing.of x)) (FreeCommRing.of (f x))","decl":"@[simp]\ntheorem map_of (x : α) : map f (of x) = of (f x) :=\n  lift_of _ _\n\n"}
{"name":"FreeCommRing.isSupported_upwards","module":"Mathlib.RingTheory.FreeCommRing","initialProofState":"α : Type u\nx : FreeCommRing α\ns t : Set α\nhs : x.IsSupported s\nhst : HasSubset.Subset s t\n⊢ x.IsSupported t","decl":"theorem isSupported_upwards (hs : IsSupported x s) (hst : s ⊆ t) : IsSupported x t :=\n  Subring.closure_mono (Set.monotone_image hst) hs\n\n"}
{"name":"FreeCommRing.isSupported_add","module":"Mathlib.RingTheory.FreeCommRing","initialProofState":"α : Type u\nx y : FreeCommRing α\ns : Set α\nhxs : x.IsSupported s\nhys : y.IsSupported s\n⊢ (HAdd.hAdd x y).IsSupported s","decl":"theorem isSupported_add (hxs : IsSupported x s) (hys : IsSupported y s) : IsSupported (x + y) s :=\n  Subring.add_mem _ hxs hys\n\n"}
{"name":"FreeCommRing.isSupported_neg","module":"Mathlib.RingTheory.FreeCommRing","initialProofState":"α : Type u\nx : FreeCommRing α\ns : Set α\nhxs : x.IsSupported s\n⊢ (Neg.neg x).IsSupported s","decl":"theorem isSupported_neg (hxs : IsSupported x s) : IsSupported (-x) s :=\n  Subring.neg_mem _ hxs\n\n"}
{"name":"FreeCommRing.isSupported_sub","module":"Mathlib.RingTheory.FreeCommRing","initialProofState":"α : Type u\nx y : FreeCommRing α\ns : Set α\nhxs : x.IsSupported s\nhys : y.IsSupported s\n⊢ (HSub.hSub x y).IsSupported s","decl":"theorem isSupported_sub (hxs : IsSupported x s) (hys : IsSupported y s) : IsSupported (x - y) s :=\n  Subring.sub_mem _ hxs hys\n\n"}
{"name":"FreeCommRing.isSupported_mul","module":"Mathlib.RingTheory.FreeCommRing","initialProofState":"α : Type u\nx y : FreeCommRing α\ns : Set α\nhxs : x.IsSupported s\nhys : y.IsSupported s\n⊢ (HMul.hMul x y).IsSupported s","decl":"theorem isSupported_mul (hxs : IsSupported x s) (hys : IsSupported y s) : IsSupported (x * y) s :=\n  Subring.mul_mem _ hxs hys\n\n"}
{"name":"FreeCommRing.isSupported_zero","module":"Mathlib.RingTheory.FreeCommRing","initialProofState":"α : Type u\ns : Set α\n⊢ FreeCommRing.IsSupported 0 s","decl":"theorem isSupported_zero : IsSupported 0 s :=\n  Subring.zero_mem _\n\n"}
{"name":"FreeCommRing.isSupported_one","module":"Mathlib.RingTheory.FreeCommRing","initialProofState":"α : Type u\ns : Set α\n⊢ FreeCommRing.IsSupported 1 s","decl":"theorem isSupported_one : IsSupported 1 s :=\n  Subring.one_mem _\n\n"}
{"name":"FreeCommRing.isSupported_int","module":"Mathlib.RingTheory.FreeCommRing","initialProofState":"α : Type u\ni : Int\ns : Set α\n⊢ (↑i).IsSupported s","decl":"theorem isSupported_int {i : ℤ} {s : Set α} : IsSupported (↑i) s :=\n  Int.induction_on i isSupported_zero\n    (fun i hi => by rw [Int.cast_add, Int.cast_one]; exact isSupported_add hi isSupported_one)\n    fun i hi => by rw [Int.cast_sub, Int.cast_one]; exact isSupported_sub hi isSupported_one\n\n"}
{"name":"FreeCommRing.restriction_of","module":"Mathlib.RingTheory.FreeCommRing","initialProofState":"α : Type u\ns : Set α\ninst✝ : DecidablePred fun x => Membership.mem s x\np : α\n⊢ Eq ((FreeCommRing.restriction s) (FreeCommRing.of p)) (dite (Membership.mem s p) (fun H => FreeCommRing.of ⟨p, H⟩) fun H => 0)","decl":"@[simp]\ntheorem restriction_of (p) : restriction s (of p) = if H : p ∈ s then of ⟨p, H⟩ else 0 :=\n  lift_of _ _\n\n"}
{"name":"FreeCommRing.isSupported_of","module":"Mathlib.RingTheory.FreeCommRing","initialProofState":"α : Type u\np : α\ns : Set α\n⊢ Iff ((FreeCommRing.of p).IsSupported s) (Membership.mem s p)","decl":"theorem isSupported_of {p} {s : Set α} : IsSupported (of p) s ↔ p ∈ s :=\n  suffices IsSupported (of p) s → p ∈ s from ⟨this, fun hps => Subring.subset_closure ⟨p, hps, rfl⟩⟩\n  fun hps : IsSupported (of p) s => by\n  classical\n  haveI := Classical.decPred s\n  have : ∀ x, IsSupported x s →\n        ∃ n : ℤ, lift (fun a => if a ∈ s then (0 : ℤ[X]) else Polynomial.X) x = n := by\n    intro x hx\n    refine Subring.InClosure.recOn hx ?_ ?_ ?_ ?_\n    · use 1\n      rw [RingHom.map_one]\n      norm_cast\n    · use -1\n      rw [RingHom.map_neg, RingHom.map_one, Int.cast_neg, Int.cast_one]\n    · rintro _ ⟨z, hzs, rfl⟩ _ _\n      use 0\n      rw [RingHom.map_mul, lift_of, if_pos hzs, zero_mul]\n      norm_cast\n    · rintro x y ⟨q, hq⟩ ⟨r, hr⟩\n      refine ⟨q + r, ?_⟩\n      rw [RingHom.map_add, hq, hr]\n      norm_cast\n  specialize this (of p) hps\n  rw [lift_of] at this\n  split_ifs at this with h\n  · exact h\n  exfalso\n  apply Ne.symm Int.zero_ne_one\n  rcases this with ⟨w, H⟩\n  rw [← Polynomial.C_eq_intCast] at H\n  have : Polynomial.X.coeff 1 = (Polynomial.C ↑w).coeff 1 := by rw [H]; rfl\n  rwa [Polynomial.coeff_C, if_neg (one_ne_zero : 1 ≠ 0), Polynomial.coeff_X, if_pos rfl] at this\n\n-- Porting note: Changed `(Subtype.val : s → α)` to `(↑)` in the type\n"}
{"name":"FreeCommRing.map_subtype_val_restriction","module":"Mathlib.RingTheory.FreeCommRing","initialProofState":"α : Type u\nx : FreeCommRing α\ns : Set α\ninst✝ : DecidablePred fun x => Membership.mem s x\nhxs : x.IsSupported s\n⊢ Eq ((FreeCommRing.map Subtype.val) ((FreeCommRing.restriction s) x)) x","decl":"theorem map_subtype_val_restriction {x} (s : Set α) [DecidablePred (· ∈ s)]\n    (hxs : IsSupported x s) : map (↑) (restriction s x) = x := by\n  refine Subring.InClosure.recOn hxs ?_ ?_ ?_ ?_\n  · rw [RingHom.map_one]\n    rfl\n  · rw [map_neg, map_one]\n    rfl\n  · rintro _ ⟨p, hps, rfl⟩ n ih\n    rw [RingHom.map_mul, restriction_of, dif_pos hps, RingHom.map_mul, map_of, ih]\n  · intro x y ihx ihy\n    rw [RingHom.map_add, RingHom.map_add, ihx, ihy]\n\n"}
{"name":"FreeCommRing.exists_finite_support","module":"Mathlib.RingTheory.FreeCommRing","initialProofState":"α : Type u\nx : FreeCommRing α\n⊢ Exists fun s => And s.Finite (x.IsSupported s)","decl":"theorem exists_finite_support (x : FreeCommRing α) : ∃ s : Set α, Set.Finite s ∧ IsSupported x s :=\n  FreeCommRing.induction_on x ⟨∅, Set.finite_empty, isSupported_neg isSupported_one⟩\n    (fun p => ⟨{p}, Set.finite_singleton p, isSupported_of.2 <| Set.mem_singleton _⟩)\n    (fun _ _ ⟨s, hfs, hxs⟩ ⟨t, hft, hxt⟩ =>\n      ⟨s ∪ t, hfs.union hft,\n        isSupported_add (isSupported_upwards hxs Set.subset_union_left)\n          (isSupported_upwards hxt Set.subset_union_right)⟩)\n    fun _ _ ⟨s, hfs, hxs⟩ ⟨t, hft, hxt⟩ =>\n    ⟨s ∪ t, hfs.union hft,\n      isSupported_mul (isSupported_upwards hxs Set.subset_union_left)\n        (isSupported_upwards hxt Set.subset_union_right)⟩\n\n"}
{"name":"FreeCommRing.exists_finset_support","module":"Mathlib.RingTheory.FreeCommRing","initialProofState":"α : Type u\nx : FreeCommRing α\n⊢ Exists fun s => x.IsSupported ↑s","decl":"theorem exists_finset_support (x : FreeCommRing α) : ∃ s : Finset α, IsSupported x ↑s :=\n  let ⟨s, hfs, hxs⟩ := exists_finite_support x\n  ⟨hfs.toFinset, by rwa [Set.Finite.coe_toFinset]⟩\n\n"}
{"name":"FreeRing.coe_zero","module":"Mathlib.RingTheory.FreeCommRing","initialProofState":"α : Type u\n⊢ Eq (↑0) 0","decl":"@[simp, norm_cast]\nprotected theorem coe_zero : ↑(0 : FreeRing α) = (0 : FreeCommRing α) := rfl\n\n"}
{"name":"FreeRing.coe_one","module":"Mathlib.RingTheory.FreeCommRing","initialProofState":"α : Type u\n⊢ Eq (↑1) 1","decl":"@[simp, norm_cast]\nprotected theorem coe_one : ↑(1 : FreeRing α) = (1 : FreeCommRing α) := rfl\n\n"}
{"name":"FreeRing.coe_of","module":"Mathlib.RingTheory.FreeCommRing","initialProofState":"α : Type u\na : α\n⊢ Eq (↑(FreeRing.of a)) (FreeCommRing.of a)","decl":"@[simp]\nprotected theorem coe_of (a : α) : ↑(FreeRing.of a) = FreeCommRing.of a :=\n  FreeRing.lift_of _ _\n\n"}
{"name":"FreeRing.coe_neg","module":"Mathlib.RingTheory.FreeCommRing","initialProofState":"α : Type u\nx : FreeRing α\n⊢ Eq (↑(Neg.neg x)) (Neg.neg ↑x)","decl":"@[simp, norm_cast]\nprotected theorem coe_neg (x : FreeRing α) : ↑(-x) = -(x : FreeCommRing α) := by\n  rw [castFreeCommRing, map_neg]\n\n"}
{"name":"FreeRing.coe_add","module":"Mathlib.RingTheory.FreeCommRing","initialProofState":"α : Type u\nx y : FreeRing α\n⊢ Eq (↑(HAdd.hAdd x y)) (HAdd.hAdd ↑x ↑y)","decl":"@[simp, norm_cast]\nprotected theorem coe_add (x y : FreeRing α) : ↑(x + y) = (x : FreeCommRing α) + y :=\n  (FreeRing.lift _).map_add _ _\n\n"}
{"name":"FreeRing.coe_sub","module":"Mathlib.RingTheory.FreeCommRing","initialProofState":"α : Type u\nx y : FreeRing α\n⊢ Eq (↑(HSub.hSub x y)) (HSub.hSub ↑x ↑y)","decl":"@[simp, norm_cast]\nprotected theorem coe_sub (x y : FreeRing α) : ↑(x - y) = (x : FreeCommRing α) - y := by\n  rw [castFreeCommRing, map_sub]\n\n"}
{"name":"FreeRing.coe_mul","module":"Mathlib.RingTheory.FreeCommRing","initialProofState":"α : Type u\nx y : FreeRing α\n⊢ Eq (↑(HMul.hMul x y)) (HMul.hMul ↑x ↑y)","decl":"@[simp, norm_cast]\nprotected theorem coe_mul (x y : FreeRing α) : ↑(x * y) = (x : FreeCommRing α) * y :=\n  (FreeRing.lift _).map_mul _ _\n\n"}
{"name":"FreeRing.coe_surjective","module":"Mathlib.RingTheory.FreeCommRing","initialProofState":"α : Type u\n⊢ Function.Surjective FreeRing.castFreeCommRing","decl":"protected theorem coe_surjective : Surjective ((↑) : FreeRing α → FreeCommRing α) := fun x => by\n  induction x with\n  | hn1 =>\n    use -1\n    rfl\n  | hb b =>\n    exact ⟨FreeRing.of b, rfl⟩\n  | ha _ _ hx hy =>\n    rcases hx with ⟨x, rfl⟩; rcases hy with ⟨y, rfl⟩\n    exact ⟨x + y, (FreeRing.lift _).map_add _ _⟩\n  | hm _ _ hx hy =>\n    rcases hx with ⟨x, rfl⟩; rcases hy with ⟨y, rfl⟩\n    exact ⟨x * y, (FreeRing.lift _).map_mul _ _⟩\n\n"}
{"name":"FreeRing.coe_eq","module":"Mathlib.RingTheory.FreeCommRing","initialProofState":"α : Type u\n⊢ Eq FreeRing.castFreeCommRing (Functor.map fun l => ↑l)","decl":"theorem coe_eq : ((↑) : FreeRing α → FreeCommRing α) =\n    @Functor.map FreeAbelianGroup _ _ _ fun l : List α => (l : Multiset α) := by\n  funext x\n  erw [castFreeCommRing, toFreeCommRing, FreeRing.lift, Equiv.coe_trans, Function.comp,\n    FreeAbelianGroup.liftMonoid_coe (FreeMonoid.lift FreeCommRing.of)]\n  dsimp [Functor.map]\n  rw [← AddMonoidHom.coe_coe]\n  apply FreeAbelianGroup.lift.unique; intro L\n  erw [FreeAbelianGroup.lift.of, Function.comp]\n  exact\n    FreeMonoid.recOn L rfl fun hd tl ih => by\n      rw [(FreeMonoid.lift _).map_mul, FreeMonoid.lift_eval_of, ih]\n      conv_lhs => reduce\n      rfl\n\n"}
