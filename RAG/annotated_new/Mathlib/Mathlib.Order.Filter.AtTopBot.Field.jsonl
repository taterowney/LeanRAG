{"name":"Filter.tendsto_const_mul_atTop_of_pos","module":"Mathlib.Order.Filter.AtTopBot.Field","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : LinearOrderedSemifield α\nl : Filter β\nf : β → α\nr : α\nhr : LT.lt 0 r\n⊢ Iff (Filter.Tendsto (fun x => HMul.hMul r (f x)) l Filter.atTop) (Filter.Tendsto f l Filter.atTop)","decl":"/-- If `r` is a positive constant, `fun x ↦ r * f x` tends to infinity along a filter\nif and only if `f` tends to infinity along the same filter. -/\ntheorem tendsto_const_mul_atTop_of_pos (hr : 0 < r) :\n    Tendsto (fun x => r * f x) l atTop ↔ Tendsto f l atTop :=\n  ⟨fun h => h.atTop_of_const_mul hr, fun h =>\n    Tendsto.atTop_of_const_mul (inv_pos.2 hr) <| by simpa only [inv_mul_cancel_left₀ hr.ne'] ⟩\n\n"}
{"name":"Filter.tendsto_mul_const_atTop_of_pos","module":"Mathlib.Order.Filter.AtTopBot.Field","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : LinearOrderedSemifield α\nl : Filter β\nf : β → α\nr : α\nhr : LT.lt 0 r\n⊢ Iff (Filter.Tendsto (fun x => HMul.hMul (f x) r) l Filter.atTop) (Filter.Tendsto f l Filter.atTop)","decl":"/-- If `r` is a positive constant, `fun x ↦ f x * r` tends to infinity along a filter\nif and only if `f` tends to infinity along the same filter. -/\ntheorem tendsto_mul_const_atTop_of_pos (hr : 0 < r) :\n    Tendsto (fun x => f x * r) l atTop ↔ Tendsto f l atTop := by\n  simpa only [mul_comm] using tendsto_const_mul_atTop_of_pos hr\n\n"}
{"name":"Filter.tendsto_div_const_atTop_of_pos","module":"Mathlib.Order.Filter.AtTopBot.Field","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : LinearOrderedSemifield α\nl : Filter β\nf : β → α\nr : α\nhr : LT.lt 0 r\n⊢ Iff (Filter.Tendsto (fun x => HDiv.hDiv (f x) r) l Filter.atTop) (Filter.Tendsto f l Filter.atTop)","decl":"/-- If `r` is a positive constant, `x ↦ f x / r` tends to infinity along a filter\nif and only if `f` tends to infinity along the same filter. -/\nlemma tendsto_div_const_atTop_of_pos (hr : 0 < r) :\n    Tendsto (fun x ↦ f x / r) l atTop ↔ Tendsto f l atTop := by\n  simpa only [div_eq_mul_inv] using tendsto_mul_const_atTop_of_pos (inv_pos.2 hr)\n\n"}
{"name":"Filter.tendsto_const_mul_atTop_iff_pos","module":"Mathlib.Order.Filter.AtTopBot.Field","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LinearOrderedSemifield α\nl : Filter β\nf : β → α\nr : α\ninst✝ : l.NeBot\nh : Filter.Tendsto f l Filter.atTop\n⊢ Iff (Filter.Tendsto (fun x => HMul.hMul r (f x)) l Filter.atTop) (LT.lt 0 r)","decl":"/-- If `f` tends to infinity along a nontrivial filter `l`, then\n`fun x ↦ r * f x` tends to infinity if and only if `0 < r. `-/\ntheorem tendsto_const_mul_atTop_iff_pos [NeBot l] (h : Tendsto f l atTop) :\n    Tendsto (fun x => r * f x) l atTop ↔ 0 < r := by\n  refine ⟨fun hrf => not_le.mp fun hr => ?_, fun hr => (tendsto_const_mul_atTop_of_pos hr).mpr h⟩\n  rcases ((h.eventually_ge_atTop 0).and (hrf.eventually_gt_atTop 0)).exists with ⟨x, hx, hrx⟩\n  exact (mul_nonpos_of_nonpos_of_nonneg hr hx).not_lt hrx\n\n"}
{"name":"Filter.tendsto_mul_const_atTop_iff_pos","module":"Mathlib.Order.Filter.AtTopBot.Field","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LinearOrderedSemifield α\nl : Filter β\nf : β → α\nr : α\ninst✝ : l.NeBot\nh : Filter.Tendsto f l Filter.atTop\n⊢ Iff (Filter.Tendsto (fun x => HMul.hMul (f x) r) l Filter.atTop) (LT.lt 0 r)","decl":"/-- If `f` tends to infinity along a nontrivial filter `l`, then\n`fun x ↦ f x * r` tends to infinity if and only if `0 < r. `-/\ntheorem tendsto_mul_const_atTop_iff_pos [NeBot l] (h : Tendsto f l atTop) :\n    Tendsto (fun x => f x * r) l atTop ↔ 0 < r := by\n  simp only [mul_comm _ r, tendsto_const_mul_atTop_iff_pos h]\n\n"}
{"name":"Filter.tendsto_div_const_atTop_iff_pos","module":"Mathlib.Order.Filter.AtTopBot.Field","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LinearOrderedSemifield α\nl : Filter β\nf : β → α\nr : α\ninst✝ : l.NeBot\nh : Filter.Tendsto f l Filter.atTop\n⊢ Iff (Filter.Tendsto (fun x => HDiv.hDiv (f x) r) l Filter.atTop) (LT.lt 0 r)","decl":"/-- If `f` tends to infinity along a nontrivial filter `l`, then\n`x ↦ f x * r` tends to infinity if and only if `0 < r. `-/\nlemma tendsto_div_const_atTop_iff_pos [NeBot l] (h : Tendsto f l atTop) :\n    Tendsto (fun x ↦ f x / r) l atTop ↔ 0 < r := by\n  simp only [div_eq_mul_inv, tendsto_mul_const_atTop_iff_pos h, inv_pos]\n\n"}
{"name":"Filter.Tendsto.const_mul_atTop","module":"Mathlib.Order.Filter.AtTopBot.Field","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : LinearOrderedSemifield α\nl : Filter β\nf : β → α\nr : α\nhr : LT.lt 0 r\nhf : Filter.Tendsto f l Filter.atTop\n⊢ Filter.Tendsto (fun x => HMul.hMul r (f x)) l Filter.atTop","decl":"/-- If `f` tends to infinity along a filter, then `f` multiplied by a positive\nconstant (on the left) also tends to infinity. For a version working in `ℕ` or `ℤ`, use\n`Filter.Tendsto.const_mul_atTop'` instead. -/\ntheorem Tendsto.const_mul_atTop (hr : 0 < r) (hf : Tendsto f l atTop) :\n    Tendsto (fun x => r * f x) l atTop :=\n  (tendsto_const_mul_atTop_of_pos hr).2 hf\n\n"}
{"name":"Filter.Tendsto.atTop_mul_const","module":"Mathlib.Order.Filter.AtTopBot.Field","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : LinearOrderedSemifield α\nl : Filter β\nf : β → α\nr : α\nhr : LT.lt 0 r\nhf : Filter.Tendsto f l Filter.atTop\n⊢ Filter.Tendsto (fun x => HMul.hMul (f x) r) l Filter.atTop","decl":"/-- If a function `f` tends to infinity along a filter, then `f` multiplied by a positive\nconstant (on the right) also tends to infinity. For a version working in `ℕ` or `ℤ`, use\n`Filter.Tendsto.atTop_mul_const'` instead. -/\ntheorem Tendsto.atTop_mul_const (hr : 0 < r) (hf : Tendsto f l atTop) :\n    Tendsto (fun x => f x * r) l atTop :=\n  (tendsto_mul_const_atTop_of_pos hr).2 hf\n\n"}
{"name":"Filter.Tendsto.atTop_div_const","module":"Mathlib.Order.Filter.AtTopBot.Field","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : LinearOrderedSemifield α\nl : Filter β\nf : β → α\nr : α\nhr : LT.lt 0 r\nhf : Filter.Tendsto f l Filter.atTop\n⊢ Filter.Tendsto (fun x => HDiv.hDiv (f x) r) l Filter.atTop","decl":"/-- If a function `f` tends to infinity along a filter, then `f` divided by a positive\nconstant also tends to infinity. -/\ntheorem Tendsto.atTop_div_const (hr : 0 < r) (hf : Tendsto f l atTop) :\n    Tendsto (fun x => f x / r) l atTop := by\n  simpa only [div_eq_mul_inv] using hf.atTop_mul_const (inv_pos.2 hr)\n\n"}
{"name":"Filter.tendsto_const_mul_pow_atTop","module":"Mathlib.Order.Filter.AtTopBot.Field","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedSemifield α\nc : α\nn : Nat\nhn : Ne n 0\nhc : LT.lt 0 c\n⊢ Filter.Tendsto (fun x => HMul.hMul c (HPow.hPow x n)) Filter.atTop Filter.atTop","decl":"theorem tendsto_const_mul_pow_atTop (hn : n ≠ 0) (hc : 0 < c) :\n    Tendsto (fun x => c * x ^ n) atTop atTop :=\n  Tendsto.const_mul_atTop hc (tendsto_pow_atTop hn)\n\n"}
{"name":"Filter.tendsto_const_mul_pow_atTop_iff","module":"Mathlib.Order.Filter.AtTopBot.Field","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedSemifield α\nc : α\nn : Nat\n⊢ Iff (Filter.Tendsto (fun x => HMul.hMul c (HPow.hPow x n)) Filter.atTop Filter.atTop) (And (Ne n 0) (LT.lt 0 c))","decl":"theorem tendsto_const_mul_pow_atTop_iff :\n    Tendsto (fun x => c * x ^ n) atTop atTop ↔ n ≠ 0 ∧ 0 < c := by\n  refine ⟨fun h => ⟨?_, ?_⟩, fun h => tendsto_const_mul_pow_atTop h.1 h.2⟩\n  · rintro rfl\n    simp only [pow_zero, not_tendsto_const_atTop] at h\n  · rcases ((h.eventually_gt_atTop 0).and (eventually_ge_atTop 0)).exists with ⟨k, hck, hk⟩\n    exact pos_of_mul_pos_left hck (pow_nonneg hk _)\n\n"}
{"name":"Filter.tendsto_zpow_atTop_atTop","module":"Mathlib.Order.Filter.AtTopBot.Field","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedSemifield α\nn : Int\nhn : LT.lt 0 n\n⊢ Filter.Tendsto (fun x => HPow.hPow x n) Filter.atTop Filter.atTop","decl":"lemma tendsto_zpow_atTop_atTop {n : ℤ} (hn : 0 < n) : Tendsto (fun x : α ↦ x ^ n) atTop atTop := by\n  lift n to ℕ using hn.le; simp [(Int.ofNat_pos.mp hn).ne']\n\n"}
{"name":"Filter.tendsto_const_mul_atBot_of_pos","module":"Mathlib.Order.Filter.AtTopBot.Field","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : LinearOrderedField α\nl : Filter β\nf : β → α\nr : α\nhr : LT.lt 0 r\n⊢ Iff (Filter.Tendsto (fun x => HMul.hMul r (f x)) l Filter.atBot) (Filter.Tendsto f l Filter.atBot)","decl":"/-- If `r` is a positive constant, `fun x ↦ r * f x` tends to negative infinity along a filter\nif and only if `f` tends to negative infinity along the same filter. -/\ntheorem tendsto_const_mul_atBot_of_pos (hr : 0 < r) :\n    Tendsto (fun x => r * f x) l atBot ↔ Tendsto f l atBot := by\n  simpa only [← mul_neg, ← tendsto_neg_atTop_iff] using tendsto_const_mul_atTop_of_pos hr\n\n"}
{"name":"Filter.tendsto_mul_const_atBot_of_pos","module":"Mathlib.Order.Filter.AtTopBot.Field","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : LinearOrderedField α\nl : Filter β\nf : β → α\nr : α\nhr : LT.lt 0 r\n⊢ Iff (Filter.Tendsto (fun x => HMul.hMul (f x) r) l Filter.atBot) (Filter.Tendsto f l Filter.atBot)","decl":"/-- If `r` is a positive constant, `fun x ↦ f x * r` tends to negative infinity along a filter\nif and only if `f` tends to negative infinity along the same filter. -/\ntheorem tendsto_mul_const_atBot_of_pos (hr : 0 < r) :\n    Tendsto (fun x => f x * r) l atBot ↔ Tendsto f l atBot := by\n  simpa only [mul_comm] using tendsto_const_mul_atBot_of_pos hr\n\n"}
{"name":"Filter.tendsto_div_const_atBot_of_pos","module":"Mathlib.Order.Filter.AtTopBot.Field","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : LinearOrderedField α\nl : Filter β\nf : β → α\nr : α\nhr : LT.lt 0 r\n⊢ Iff (Filter.Tendsto (fun x => HDiv.hDiv (f x) r) l Filter.atBot) (Filter.Tendsto f l Filter.atBot)","decl":"/-- If `r` is a positive constant, `fun x ↦ f x / r` tends to negative infinity along a filter\nif and only if `f` tends to negative infinity along the same filter. -/\nlemma tendsto_div_const_atBot_of_pos (hr : 0 < r) :\n    Tendsto (fun x ↦ f x / r) l atBot ↔ Tendsto f l atBot := by\n  simp [div_eq_mul_inv, tendsto_mul_const_atBot_of_pos, hr]\n\n"}
{"name":"Filter.tendsto_const_mul_atTop_of_neg","module":"Mathlib.Order.Filter.AtTopBot.Field","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : LinearOrderedField α\nl : Filter β\nf : β → α\nr : α\nhr : LT.lt r 0\n⊢ Iff (Filter.Tendsto (fun x => HMul.hMul r (f x)) l Filter.atTop) (Filter.Tendsto f l Filter.atBot)","decl":"/-- If `r` is a negative constant, `fun x ↦ r * f x` tends to infinity along a filter `l`\nif and only if `f` tends to negative infinity along `l`. -/\ntheorem tendsto_const_mul_atTop_of_neg (hr : r < 0) :\n    Tendsto (fun x => r * f x) l atTop ↔ Tendsto f l atBot := by\n  simpa only [neg_mul, tendsto_neg_atBot_iff] using tendsto_const_mul_atBot_of_pos (neg_pos.2 hr)\n\n"}
{"name":"Filter.tendsto_mul_const_atTop_of_neg","module":"Mathlib.Order.Filter.AtTopBot.Field","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : LinearOrderedField α\nl : Filter β\nf : β → α\nr : α\nhr : LT.lt r 0\n⊢ Iff (Filter.Tendsto (fun x => HMul.hMul (f x) r) l Filter.atTop) (Filter.Tendsto f l Filter.atBot)","decl":"/-- If `r` is a negative constant, `fun x ↦ f x * r` tends to infinity along a filter `l`\nif and only if `f` tends to negative infinity along `l`. -/\ntheorem tendsto_mul_const_atTop_of_neg (hr : r < 0) :\n    Tendsto (fun x => f x * r) l atTop ↔ Tendsto f l atBot := by\n  simpa only [mul_comm] using tendsto_const_mul_atTop_of_neg hr\n\n"}
{"name":"Filter.tendsto_div_const_atTop_of_neg","module":"Mathlib.Order.Filter.AtTopBot.Field","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : LinearOrderedField α\nl : Filter β\nf : β → α\nr : α\nhr : LT.lt r 0\n⊢ Iff (Filter.Tendsto (fun x => HDiv.hDiv (f x) r) l Filter.atTop) (Filter.Tendsto f l Filter.atBot)","decl":"/-- If `r` is a negative constant, `fun x ↦ f x / r` tends to infinity along a filter `l`\nif and only if `f` tends to negative infinity along `l`. -/\nlemma tendsto_div_const_atTop_of_neg (hr : r < 0) :\n    Tendsto (fun x ↦ f x / r) l atTop ↔ Tendsto f l atBot := by\n  simp [div_eq_mul_inv, tendsto_mul_const_atTop_of_neg, hr]\n\n"}
{"name":"Filter.tendsto_const_mul_atBot_of_neg","module":"Mathlib.Order.Filter.AtTopBot.Field","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : LinearOrderedField α\nl : Filter β\nf : β → α\nr : α\nhr : LT.lt r 0\n⊢ Iff (Filter.Tendsto (fun x => HMul.hMul r (f x)) l Filter.atBot) (Filter.Tendsto f l Filter.atTop)","decl":"/-- If `r` is a negative constant, `fun x ↦ r * f x` tends to negative infinity along a filter `l`\nif and only if `f` tends to infinity along `l`. -/\ntheorem tendsto_const_mul_atBot_of_neg (hr : r < 0) :\n    Tendsto (fun x => r * f x) l atBot ↔ Tendsto f l atTop := by\n  simpa only [neg_mul, tendsto_neg_atTop_iff] using tendsto_const_mul_atTop_of_pos (neg_pos.2 hr)\n\n"}
{"name":"Filter.tendsto_mul_const_atBot_of_neg","module":"Mathlib.Order.Filter.AtTopBot.Field","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : LinearOrderedField α\nl : Filter β\nf : β → α\nr : α\nhr : LT.lt r 0\n⊢ Iff (Filter.Tendsto (fun x => HMul.hMul (f x) r) l Filter.atBot) (Filter.Tendsto f l Filter.atTop)","decl":"/-- If `r` is a negative constant, `fun x ↦ f x * r` tends to negative infinity along a filter `l`\nif and only if `f` tends to infinity along `l`. -/\ntheorem tendsto_mul_const_atBot_of_neg (hr : r < 0) :\n    Tendsto (fun x => f x * r) l atBot ↔ Tendsto f l atTop := by\n  simpa only [mul_comm] using tendsto_const_mul_atBot_of_neg hr\n\n"}
{"name":"Filter.tendsto_div_const_atBot_of_neg","module":"Mathlib.Order.Filter.AtTopBot.Field","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : LinearOrderedField α\nl : Filter β\nf : β → α\nr : α\nhr : LT.lt r 0\n⊢ Iff (Filter.Tendsto (fun x => HDiv.hDiv (f x) r) l Filter.atBot) (Filter.Tendsto f l Filter.atTop)","decl":"/-- If `r` is a negative constant, `fun x ↦ f x / r` tends to negative infinity along a filter `l`\nif and only if `f` tends to infinity along `l`. -/\nlemma tendsto_div_const_atBot_of_neg (hr : r < 0) :\n    Tendsto (fun x ↦ f x / r) l atBot ↔ Tendsto f l atTop := by\n  simp [div_eq_mul_inv, tendsto_mul_const_atBot_of_neg, hr]\n\n"}
{"name":"Filter.tendsto_const_mul_atTop_iff","module":"Mathlib.Order.Filter.AtTopBot.Field","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LinearOrderedField α\nl : Filter β\nf : β → α\nr : α\ninst✝ : l.NeBot\n⊢ Iff (Filter.Tendsto (fun x => HMul.hMul r (f x)) l Filter.atTop) (Or (And (LT.lt 0 r) (Filter.Tendsto f l Filter.atTop)) (And (LT.lt r 0) (Filter.Tendsto f l Filter.atBot)))","decl":"/-- The function `fun x ↦ r * f x` tends to infinity along a nontrivial filter\nif and only if `r > 0` and `f` tends to infinity or `r < 0` and `f` tends to negative infinity. -/\ntheorem tendsto_const_mul_atTop_iff [NeBot l] :\n    Tendsto (fun x => r * f x) l atTop ↔ 0 < r ∧ Tendsto f l atTop ∨ r < 0 ∧ Tendsto f l atBot := by\n  rcases lt_trichotomy r 0 with (hr | rfl | hr)\n  · simp [hr, hr.not_lt, tendsto_const_mul_atTop_of_neg]\n  · simp [not_tendsto_const_atTop]\n  · simp [hr, hr.not_lt, tendsto_const_mul_atTop_of_pos]\n\n"}
{"name":"Filter.tendsto_mul_const_atTop_iff","module":"Mathlib.Order.Filter.AtTopBot.Field","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LinearOrderedField α\nl : Filter β\nf : β → α\nr : α\ninst✝ : l.NeBot\n⊢ Iff (Filter.Tendsto (fun x => HMul.hMul (f x) r) l Filter.atTop) (Or (And (LT.lt 0 r) (Filter.Tendsto f l Filter.atTop)) (And (LT.lt r 0) (Filter.Tendsto f l Filter.atBot)))","decl":"/-- The function `fun x ↦ f x * r` tends to infinity along a nontrivial filter\nif and only if `r > 0` and `f` tends to infinity or `r < 0` and `f` tends to negative infinity. -/\ntheorem tendsto_mul_const_atTop_iff [NeBot l] :\n    Tendsto (fun x => f x * r) l atTop ↔ 0 < r ∧ Tendsto f l atTop ∨ r < 0 ∧ Tendsto f l atBot := by\n  simp only [mul_comm _ r, tendsto_const_mul_atTop_iff]\n\n"}
{"name":"Filter.tendsto_div_const_atTop_iff","module":"Mathlib.Order.Filter.AtTopBot.Field","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LinearOrderedField α\nl : Filter β\nf : β → α\nr : α\ninst✝ : l.NeBot\n⊢ Iff (Filter.Tendsto (fun x => HDiv.hDiv (f x) r) l Filter.atTop) (Or (And (LT.lt 0 r) (Filter.Tendsto f l Filter.atTop)) (And (LT.lt r 0) (Filter.Tendsto f l Filter.atBot)))","decl":"/-- The function `fun x ↦ f x / r` tends to infinity along a nontrivial filter\nif and only if `r > 0` and `f` tends to infinity or `r < 0` and `f` tends to negative infinity. -/\nlemma tendsto_div_const_atTop_iff [NeBot l] :\n    Tendsto (fun x ↦ f x / r) l atTop ↔ 0 < r ∧ Tendsto f l atTop ∨ r < 0 ∧ Tendsto f l atBot := by\n  simp [div_eq_mul_inv, tendsto_mul_const_atTop_iff]\n\n"}
{"name":"Filter.tendsto_const_mul_atBot_iff","module":"Mathlib.Order.Filter.AtTopBot.Field","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LinearOrderedField α\nl : Filter β\nf : β → α\nr : α\ninst✝ : l.NeBot\n⊢ Iff (Filter.Tendsto (fun x => HMul.hMul r (f x)) l Filter.atBot) (Or (And (LT.lt 0 r) (Filter.Tendsto f l Filter.atBot)) (And (LT.lt r 0) (Filter.Tendsto f l Filter.atTop)))","decl":"/-- The function `fun x ↦ r * f x` tends to negative infinity along a nontrivial filter\nif and only if `r > 0` and `f` tends to negative infinity or `r < 0` and `f` tends to infinity. -/\ntheorem tendsto_const_mul_atBot_iff [NeBot l] :\n    Tendsto (fun x => r * f x) l atBot ↔ 0 < r ∧ Tendsto f l atBot ∨ r < 0 ∧ Tendsto f l atTop := by\n  simp only [← tendsto_neg_atTop_iff, ← mul_neg, tendsto_const_mul_atTop_iff, neg_neg]\n\n"}
{"name":"Filter.tendsto_mul_const_atBot_iff","module":"Mathlib.Order.Filter.AtTopBot.Field","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LinearOrderedField α\nl : Filter β\nf : β → α\nr : α\ninst✝ : l.NeBot\n⊢ Iff (Filter.Tendsto (fun x => HMul.hMul (f x) r) l Filter.atBot) (Or (And (LT.lt 0 r) (Filter.Tendsto f l Filter.atBot)) (And (LT.lt r 0) (Filter.Tendsto f l Filter.atTop)))","decl":"/-- The function `fun x ↦ f x * r` tends to negative infinity along a nontrivial filter\nif and only if `r > 0` and `f` tends to negative infinity or `r < 0` and `f` tends to infinity. -/\ntheorem tendsto_mul_const_atBot_iff [NeBot l] :\n    Tendsto (fun x => f x * r) l atBot ↔ 0 < r ∧ Tendsto f l atBot ∨ r < 0 ∧ Tendsto f l atTop := by\n  simp only [mul_comm _ r, tendsto_const_mul_atBot_iff]\n\n"}
{"name":"Filter.tendsto_div_const_atBot_iff","module":"Mathlib.Order.Filter.AtTopBot.Field","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LinearOrderedField α\nl : Filter β\nf : β → α\nr : α\ninst✝ : l.NeBot\n⊢ Iff (Filter.Tendsto (fun x => HDiv.hDiv (f x) r) l Filter.atBot) (Or (And (LT.lt 0 r) (Filter.Tendsto f l Filter.atBot)) (And (LT.lt r 0) (Filter.Tendsto f l Filter.atTop)))","decl":"/-- The function `fun x ↦ f x / r` tends to negative infinity along a nontrivial filter\nif and only if `r > 0` and `f` tends to negative infinity or `r < 0` and `f` tends to infinity. -/\nlemma tendsto_div_const_atBot_iff [NeBot l] :\n    Tendsto (fun x ↦ f x / r) l atBot ↔ 0 < r ∧ Tendsto f l atBot ∨ r < 0 ∧ Tendsto f l atTop := by\n  simp [div_eq_mul_inv, tendsto_mul_const_atBot_iff]\n\n"}
{"name":"Filter.tendsto_const_mul_atTop_iff_neg","module":"Mathlib.Order.Filter.AtTopBot.Field","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LinearOrderedField α\nl : Filter β\nf : β → α\nr : α\ninst✝ : l.NeBot\nh : Filter.Tendsto f l Filter.atBot\n⊢ Iff (Filter.Tendsto (fun x => HMul.hMul r (f x)) l Filter.atTop) (LT.lt r 0)","decl":"/-- If `f` tends to negative infinity along a nontrivial filter `l`,\nthen `fun x ↦ r * f x` tends to infinity if and only if `r < 0. `-/\ntheorem tendsto_const_mul_atTop_iff_neg [NeBot l] (h : Tendsto f l atBot) :\n    Tendsto (fun x => r * f x) l atTop ↔ r < 0 := by\n  simp [tendsto_const_mul_atTop_iff, h, h.not_tendsto disjoint_atBot_atTop]\n\n"}
{"name":"Filter.tendsto_mul_const_atTop_iff_neg","module":"Mathlib.Order.Filter.AtTopBot.Field","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LinearOrderedField α\nl : Filter β\nf : β → α\nr : α\ninst✝ : l.NeBot\nh : Filter.Tendsto f l Filter.atBot\n⊢ Iff (Filter.Tendsto (fun x => HMul.hMul (f x) r) l Filter.atTop) (LT.lt r 0)","decl":"/-- If `f` tends to negative infinity along a nontrivial filter `l`,\nthen `fun x ↦ f x * r` tends to infinity if and only if `r < 0. `-/\ntheorem tendsto_mul_const_atTop_iff_neg [NeBot l] (h : Tendsto f l atBot) :\n    Tendsto (fun x => f x * r) l atTop ↔ r < 0 := by\n  simp only [mul_comm _ r, tendsto_const_mul_atTop_iff_neg h]\n\n"}
{"name":"Filter.tendsto_div_const_atTop_iff_neg","module":"Mathlib.Order.Filter.AtTopBot.Field","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LinearOrderedField α\nl : Filter β\nf : β → α\nr : α\ninst✝ : l.NeBot\nh : Filter.Tendsto f l Filter.atBot\n⊢ Iff (Filter.Tendsto (fun x => HDiv.hDiv (f x) r) l Filter.atTop) (LT.lt r 0)","decl":"/-- If `f` tends to negative infinity along a nontrivial filter `l`,\nthen `fun x ↦ f x / r` tends to infinity if and only if `r < 0. `-/\nlemma tendsto_div_const_atTop_iff_neg [NeBot l] (h : Tendsto f l atBot) :\n    Tendsto (fun x ↦ f x / r) l atTop ↔ r < 0 := by\n  simp [div_eq_mul_inv, tendsto_mul_const_atTop_iff_neg h]\n\n"}
{"name":"Filter.tendsto_const_mul_atBot_iff_pos","module":"Mathlib.Order.Filter.AtTopBot.Field","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LinearOrderedField α\nl : Filter β\nf : β → α\nr : α\ninst✝ : l.NeBot\nh : Filter.Tendsto f l Filter.atBot\n⊢ Iff (Filter.Tendsto (fun x => HMul.hMul r (f x)) l Filter.atBot) (LT.lt 0 r)","decl":"/-- If `f` tends to negative infinity along a nontrivial filter `l`, then\n`fun x ↦ r * f x` tends to negative infinity if and only if `0 < r. `-/\ntheorem tendsto_const_mul_atBot_iff_pos [NeBot l] (h : Tendsto f l atBot) :\n    Tendsto (fun x => r * f x) l atBot ↔ 0 < r := by\n  simp [tendsto_const_mul_atBot_iff, h, h.not_tendsto disjoint_atBot_atTop]\n\n"}
{"name":"Filter.tendsto_mul_const_atBot_iff_pos","module":"Mathlib.Order.Filter.AtTopBot.Field","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LinearOrderedField α\nl : Filter β\nf : β → α\nr : α\ninst✝ : l.NeBot\nh : Filter.Tendsto f l Filter.atBot\n⊢ Iff (Filter.Tendsto (fun x => HMul.hMul (f x) r) l Filter.atBot) (LT.lt 0 r)","decl":"/-- If `f` tends to negative infinity along a nontrivial filter `l`, then\n`fun x ↦ f x * r` tends to negative infinity if and only if `0 < r. `-/\ntheorem tendsto_mul_const_atBot_iff_pos [NeBot l] (h : Tendsto f l atBot) :\n    Tendsto (fun x => f x * r) l atBot ↔ 0 < r := by\n  simp only [mul_comm _ r, tendsto_const_mul_atBot_iff_pos h]\n\n"}
{"name":"Filter.tendsto_div_const_atBot_iff_pos","module":"Mathlib.Order.Filter.AtTopBot.Field","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LinearOrderedField α\nl : Filter β\nf : β → α\nr : α\ninst✝ : l.NeBot\nh : Filter.Tendsto f l Filter.atBot\n⊢ Iff (Filter.Tendsto (fun x => HDiv.hDiv (f x) r) l Filter.atBot) (LT.lt 0 r)","decl":"/-- If `f` tends to negative infinity along a nontrivial filter `l`, then\n`fun x ↦ f x / r` tends to negative infinity if and only if `0 < r. `-/\nlemma tendsto_div_const_atBot_iff_pos [NeBot l] (h : Tendsto f l atBot) :\n    Tendsto (fun x ↦ f x / r) l atBot ↔ 0 < r := by\n  simp [div_eq_mul_inv, tendsto_mul_const_atBot_iff_pos h]\n\n"}
{"name":"Filter.tendsto_const_mul_atBot_iff_neg","module":"Mathlib.Order.Filter.AtTopBot.Field","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LinearOrderedField α\nl : Filter β\nf : β → α\nr : α\ninst✝ : l.NeBot\nh : Filter.Tendsto f l Filter.atTop\n⊢ Iff (Filter.Tendsto (fun x => HMul.hMul r (f x)) l Filter.atBot) (LT.lt r 0)","decl":"/-- If `f` tends to infinity along a nontrivial filter,\n`fun x ↦ r * f x` tends to negative infinity if and only if `r < 0. `-/\ntheorem tendsto_const_mul_atBot_iff_neg [NeBot l] (h : Tendsto f l atTop) :\n    Tendsto (fun x => r * f x) l atBot ↔ r < 0 := by\n  simp [tendsto_const_mul_atBot_iff, h, h.not_tendsto disjoint_atTop_atBot]\n\n"}
{"name":"Filter.tendsto_mul_const_atBot_iff_neg","module":"Mathlib.Order.Filter.AtTopBot.Field","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LinearOrderedField α\nl : Filter β\nf : β → α\nr : α\ninst✝ : l.NeBot\nh : Filter.Tendsto f l Filter.atTop\n⊢ Iff (Filter.Tendsto (fun x => HMul.hMul (f x) r) l Filter.atBot) (LT.lt r 0)","decl":"/-- If `f` tends to infinity along a nontrivial filter,\n`fun x ↦ f x * r` tends to negative infinity if and only if `r < 0. `-/\ntheorem tendsto_mul_const_atBot_iff_neg [NeBot l] (h : Tendsto f l atTop) :\n    Tendsto (fun x => f x * r) l atBot ↔ r < 0 := by\n  simp only [mul_comm _ r, tendsto_const_mul_atBot_iff_neg h]\n\n"}
{"name":"Filter.tendsto_div_const_atBot_iff_neg","module":"Mathlib.Order.Filter.AtTopBot.Field","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LinearOrderedField α\nl : Filter β\nf : β → α\nr : α\ninst✝ : l.NeBot\nh : Filter.Tendsto f l Filter.atTop\n⊢ Iff (Filter.Tendsto (fun x => HDiv.hDiv (f x) r) l Filter.atBot) (LT.lt r 0)","decl":"/-- If `f` tends to infinity along a nontrivial filter,\n`fun x ↦ f x / r` tends to negative infinity if and only if `r < 0. `-/\nlemma tendsto_div_const_atBot_iff_neg [NeBot l] (h : Tendsto f l atTop) :\n    Tendsto (fun x ↦ f x / r) l atBot ↔ r < 0 := by\n  simp [div_eq_mul_inv, tendsto_mul_const_atBot_iff_neg h]\n\n"}
{"name":"Filter.Tendsto.const_mul_atTop_of_neg","module":"Mathlib.Order.Filter.AtTopBot.Field","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : LinearOrderedField α\nl : Filter β\nf : β → α\nr : α\nhr : LT.lt r 0\nhf : Filter.Tendsto f l Filter.atTop\n⊢ Filter.Tendsto (fun x => HMul.hMul r (f x)) l Filter.atBot","decl":"/-- If a function `f` tends to infinity along a filter,\nthen `f` multiplied by a negative constant (on the left) tends to negative infinity. -/\ntheorem Tendsto.const_mul_atTop_of_neg (hr : r < 0) (hf : Tendsto f l atTop) :\n    Tendsto (fun x => r * f x) l atBot :=\n  (tendsto_const_mul_atBot_of_neg hr).2 hf\n\n"}
{"name":"Filter.Tendsto.atTop_mul_const_of_neg","module":"Mathlib.Order.Filter.AtTopBot.Field","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : LinearOrderedField α\nl : Filter β\nf : β → α\nr : α\nhr : LT.lt r 0\nhf : Filter.Tendsto f l Filter.atTop\n⊢ Filter.Tendsto (fun x => HMul.hMul (f x) r) l Filter.atBot","decl":"/-- If a function `f` tends to infinity along a filter,\nthen `f` multiplied by a negative constant (on the right) tends to negative infinity. -/\ntheorem Tendsto.atTop_mul_const_of_neg (hr : r < 0) (hf : Tendsto f l atTop) :\n    Tendsto (fun x => f x * r) l atBot :=\n  (tendsto_mul_const_atBot_of_neg hr).2 hf\n\n"}
{"name":"Filter.Tendsto.atTop_div_const_of_neg","module":"Mathlib.Order.Filter.AtTopBot.Field","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : LinearOrderedField α\nl : Filter β\nf : β → α\nr : α\nhr : LT.lt r 0\nhf : Filter.Tendsto f l Filter.atTop\n⊢ Filter.Tendsto (fun x => HDiv.hDiv (f x) r) l Filter.atBot","decl":"/-- If a function `f` tends to infinity along a filter,\nthen `f` divided by a negative constant tends to negative infinity. -/\nlemma Tendsto.atTop_div_const_of_neg (hr : r < 0) (hf : Tendsto f l atTop) :\n    Tendsto (fun x ↦ f x / r) l atBot := (tendsto_div_const_atBot_of_neg hr).2 hf\n\n"}
{"name":"Filter.Tendsto.const_mul_atBot","module":"Mathlib.Order.Filter.AtTopBot.Field","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : LinearOrderedField α\nl : Filter β\nf : β → α\nr : α\nhr : LT.lt 0 r\nhf : Filter.Tendsto f l Filter.atBot\n⊢ Filter.Tendsto (fun x => HMul.hMul r (f x)) l Filter.atBot","decl":"/-- If a function `f` tends to negative infinity along a filter, then `f` multiplied by\na positive constant (on the left) also tends to negative infinity. -/\ntheorem Tendsto.const_mul_atBot (hr : 0 < r) (hf : Tendsto f l atBot) :\n    Tendsto (fun x => r * f x) l atBot :=\n  (tendsto_const_mul_atBot_of_pos hr).2 hf\n\n"}
{"name":"Filter.Tendsto.atBot_mul_const","module":"Mathlib.Order.Filter.AtTopBot.Field","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : LinearOrderedField α\nl : Filter β\nf : β → α\nr : α\nhr : LT.lt 0 r\nhf : Filter.Tendsto f l Filter.atBot\n⊢ Filter.Tendsto (fun x => HMul.hMul (f x) r) l Filter.atBot","decl":"/-- If a function `f` tends to negative infinity along a filter, then `f` multiplied by\na positive constant (on the right) also tends to negative infinity. -/\ntheorem Tendsto.atBot_mul_const (hr : 0 < r) (hf : Tendsto f l atBot) :\n    Tendsto (fun x => f x * r) l atBot :=\n  (tendsto_mul_const_atBot_of_pos hr).2 hf\n\n"}
{"name":"Filter.Tendsto.atBot_div_const","module":"Mathlib.Order.Filter.AtTopBot.Field","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : LinearOrderedField α\nl : Filter β\nf : β → α\nr : α\nhr : LT.lt 0 r\nhf : Filter.Tendsto f l Filter.atBot\n⊢ Filter.Tendsto (fun x => HDiv.hDiv (f x) r) l Filter.atBot","decl":"/-- If a function `f` tends to negative infinity along a filter, then `f` divided by\na positive constant also tends to negative infinity. -/\ntheorem Tendsto.atBot_div_const (hr : 0 < r) (hf : Tendsto f l atBot) :\n    Tendsto (fun x => f x / r) l atBot := (tendsto_div_const_atBot_of_pos hr).2 hf\n\n"}
{"name":"Filter.Tendsto.const_mul_atBot_of_neg","module":"Mathlib.Order.Filter.AtTopBot.Field","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : LinearOrderedField α\nl : Filter β\nf : β → α\nr : α\nhr : LT.lt r 0\nhf : Filter.Tendsto f l Filter.atBot\n⊢ Filter.Tendsto (fun x => HMul.hMul r (f x)) l Filter.atTop","decl":"/-- If a function `f` tends to negative infinity along a filter,\nthen `f` multiplied by a negative constant (on the left) tends to positive infinity. -/\ntheorem Tendsto.const_mul_atBot_of_neg (hr : r < 0) (hf : Tendsto f l atBot) :\n    Tendsto (fun x => r * f x) l atTop :=\n  (tendsto_const_mul_atTop_of_neg hr).2 hf\n\n"}
{"name":"Filter.Tendsto.atBot_mul_const_of_neg","module":"Mathlib.Order.Filter.AtTopBot.Field","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : LinearOrderedField α\nl : Filter β\nf : β → α\nr : α\nhr : LT.lt r 0\nhf : Filter.Tendsto f l Filter.atBot\n⊢ Filter.Tendsto (fun x => HMul.hMul (f x) r) l Filter.atTop","decl":"/-- If a function tends to negative infinity along a filter,\nthen `f` multiplied by a negative constant (on the right) tends to positive infinity. -/\ntheorem Tendsto.atBot_mul_const_of_neg (hr : r < 0) (hf : Tendsto f l atBot) :\n    Tendsto (fun x => f x * r) l atTop :=\n  (tendsto_mul_const_atTop_of_neg hr).2 hf\n\n"}
{"name":"Filter.tendsto_neg_const_mul_pow_atTop","module":"Mathlib.Order.Filter.AtTopBot.Field","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedField α\nc : α\nn : Nat\nhn : Ne n 0\nhc : LT.lt c 0\n⊢ Filter.Tendsto (fun x => HMul.hMul c (HPow.hPow x n)) Filter.atTop Filter.atBot","decl":"theorem tendsto_neg_const_mul_pow_atTop {c : α} {n : ℕ} (hn : n ≠ 0) (hc : c < 0) :\n    Tendsto (fun x => c * x ^ n) atTop atBot :=\n  (tendsto_pow_atTop hn).const_mul_atTop_of_neg hc\n\n"}
{"name":"Filter.tendsto_const_mul_pow_atBot_iff","module":"Mathlib.Order.Filter.AtTopBot.Field","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedField α\nc : α\nn : Nat\n⊢ Iff (Filter.Tendsto (fun x => HMul.hMul c (HPow.hPow x n)) Filter.atTop Filter.atBot) (And (Ne n 0) (LT.lt c 0))","decl":"theorem tendsto_const_mul_pow_atBot_iff {c : α} {n : ℕ} :\n    Tendsto (fun x => c * x ^ n) atTop atBot ↔ n ≠ 0 ∧ c < 0 := by\n  simp only [← tendsto_neg_atTop_iff, ← neg_mul, tendsto_const_mul_pow_atTop_iff, neg_pos]\n\n"}
