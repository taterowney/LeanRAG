{"name":"isInvariant_iff_image","module":"Mathlib.Dynamics.Flow","initialProofState":"τ : Type u_1\nα : Type u_2\nϕ : τ → α → α\ns : Set α\n⊢ Iff (IsInvariant ϕ s) (∀ (t : τ), HasSubset.Subset (Set.image (ϕ t) s) s)","decl":"theorem isInvariant_iff_image : IsInvariant ϕ s ↔ ∀ t, ϕ t '' s ⊆ s := by\n  simp_rw [IsInvariant, mapsTo']\n\n"}
{"name":"IsInvariant.isFwInvariant","module":"Mathlib.Dynamics.Flow","initialProofState":"τ : Type u_1\nα : Type u_2\ninst✝¹ : Preorder τ\ninst✝ : Zero τ\nϕ : τ → α → α\ns : Set α\nh : IsInvariant ϕ s\n⊢ IsFwInvariant ϕ s","decl":"theorem IsInvariant.isFwInvariant [Preorder τ] [Zero τ] {ϕ : τ → α → α} {s : Set α}\n    (h : IsInvariant ϕ s) : IsFwInvariant ϕ s := fun t _ht => h t\n\n"}
{"name":"IsFwInvariant.isInvariant","module":"Mathlib.Dynamics.Flow","initialProofState":"τ : Type u_1\nα : Type u_2\ninst✝² : AddMonoid τ\ninst✝¹ : PartialOrder τ\ninst✝ : CanonicallyOrderedAdd τ\nϕ : τ → α → α\ns : Set α\nh : IsFwInvariant ϕ s\n⊢ IsInvariant ϕ s","decl":"/-- If `τ` is a `CanonicallyOrderedAdd` monoid (e.g., `ℕ` or `ℝ≥0`), then the notions\n`IsFwInvariant` and `IsInvariant` are equivalent. -/\ntheorem IsFwInvariant.isInvariant [AddMonoid τ] [PartialOrder τ] [CanonicallyOrderedAdd τ]\n    {ϕ : τ → α → α} {s : Set α}\n    (h : IsFwInvariant ϕ s) : IsInvariant ϕ s := fun t => h (zero_le t)\n\n"}
{"name":"isFwInvariant_iff_isInvariant","module":"Mathlib.Dynamics.Flow","initialProofState":"τ : Type u_1\nα : Type u_2\ninst✝² : AddMonoid τ\ninst✝¹ : PartialOrder τ\ninst✝ : CanonicallyOrderedAdd τ\nϕ : τ → α → α\ns : Set α\n⊢ Iff (IsFwInvariant ϕ s) (IsInvariant ϕ s)","decl":"/-- If `τ` is a `CanonicallyOrderedAdd` monoid (e.g., `ℕ` or `ℝ≥0`), then the notions\n`IsFwInvariant` and `IsInvariant` are equivalent. -/\ntheorem isFwInvariant_iff_isInvariant [AddMonoid τ] [PartialOrder τ] [CanonicallyOrderedAdd τ]\n    {ϕ : τ → α → α} {s : Set α} :\n    IsFwInvariant ϕ s ↔ IsInvariant ϕ s :=\n  ⟨IsFwInvariant.isInvariant, IsInvariant.isFwInvariant⟩\n\n"}
{"name":"Flow.mk.inj","module":"Mathlib.Dynamics.Flow","initialProofState":"τ : Type u_1\ninst✝³ : TopologicalSpace τ\ninst✝² : AddMonoid τ\ninst✝¹ : ContinuousAdd τ\nα : Type u_2\ninst✝ : TopologicalSpace α\ntoFun✝ : τ → α → α\ncont'✝ : Continuous (Function.uncurry toFun✝)\nmap_add'✝ : ∀ (t₁ t₂ : τ) (x : α), Eq (toFun✝ (HAdd.hAdd t₁ t₂) x) (toFun✝ t₁ (toFun✝ t₂ x))\nmap_zero'✝ : ∀ (x : α), Eq (toFun✝ 0 x) x\ntoFun : τ → α → α\ncont' : Continuous (Function.uncurry toFun)\nmap_add' : ∀ (t₁ t₂ : τ) (x : α), Eq (toFun (HAdd.hAdd t₁ t₂) x) (toFun t₁ (toFun t₂ x))\nmap_zero' : ∀ (x : α), Eq (toFun 0 x) x\nx✝ : Eq { toFun := toFun✝, cont' := cont'✝, map_add' := map_add'✝, map_zero' := map_zero'✝ } { toFun := toFun, cont' := cont', map_add' := map_add', map_zero' := map_zero' }\n⊢ Eq toFun✝ toFun","decl":"/-- A flow on a topological space `α` by an additive topological\n    monoid `τ` is a continuous monoid action of `τ` on `α`. -/\nstructure Flow (τ : Type*) [TopologicalSpace τ] [AddMonoid τ] [ContinuousAdd τ] (α : Type*)\n  [TopologicalSpace α] where\n  /-- The map `τ → α → α` underlying a flow of `τ` on `α`. -/\n  toFun : τ → α → α\n  cont' : Continuous (uncurry toFun)\n  map_add' : ∀ t₁ t₂ x, toFun (t₁ + t₂) x = toFun t₁ (toFun t₂ x)\n  map_zero' : ∀ x, toFun 0 x = x\n\n"}
{"name":"Flow.mk.injEq","module":"Mathlib.Dynamics.Flow","initialProofState":"τ : Type u_1\ninst✝³ : TopologicalSpace τ\ninst✝² : AddMonoid τ\ninst✝¹ : ContinuousAdd τ\nα : Type u_2\ninst✝ : TopologicalSpace α\ntoFun✝ : τ → α → α\ncont'✝ : Continuous (Function.uncurry toFun✝)\nmap_add'✝ : ∀ (t₁ t₂ : τ) (x : α), Eq (toFun✝ (HAdd.hAdd t₁ t₂) x) (toFun✝ t₁ (toFun✝ t₂ x))\nmap_zero'✝ : ∀ (x : α), Eq (toFun✝ 0 x) x\ntoFun : τ → α → α\ncont' : Continuous (Function.uncurry toFun)\nmap_add' : ∀ (t₁ t₂ : τ) (x : α), Eq (toFun (HAdd.hAdd t₁ t₂) x) (toFun t₁ (toFun t₂ x))\nmap_zero' : ∀ (x : α), Eq (toFun 0 x) x\n⊢ Eq (Eq { toFun := toFun✝, cont' := cont'✝, map_add' := map_add'✝, map_zero' := map_zero'✝ } { toFun := toFun, cont' := cont', map_add' := map_add', map_zero' := map_zero' }) (Eq toFun✝ toFun)","decl":"/-- A flow on a topological space `α` by an additive topological\n    monoid `τ` is a continuous monoid action of `τ` on `α`. -/\nstructure Flow (τ : Type*) [TopologicalSpace τ] [AddMonoid τ] [ContinuousAdd τ] (α : Type*)\n  [TopologicalSpace α] where\n  /-- The map `τ → α → α` underlying a flow of `τ` on `α`. -/\n  toFun : τ → α → α\n  cont' : Continuous (uncurry toFun)\n  map_add' : ∀ t₁ t₂ x, toFun (t₁ + t₂) x = toFun t₁ (toFun t₂ x)\n  map_zero' : ∀ x, toFun 0 x = x\n\n"}
{"name":"Flow.map_zero'","module":"Mathlib.Dynamics.Flow","initialProofState":"τ : Type u_1\ninst✝³ : TopologicalSpace τ\ninst✝² : AddMonoid τ\ninst✝¹ : ContinuousAdd τ\nα : Type u_2\ninst✝ : TopologicalSpace α\nself : Flow τ α\nx : α\n⊢ Eq (self.toFun 0 x) x","decl":"/-- A flow on a topological space `α` by an additive topological\n    monoid `τ` is a continuous monoid action of `τ` on `α`. -/\nstructure Flow (τ : Type*) [TopologicalSpace τ] [AddMonoid τ] [ContinuousAdd τ] (α : Type*)\n  [TopologicalSpace α] where\n  /-- The map `τ → α → α` underlying a flow of `τ` on `α`. -/\n  toFun : τ → α → α\n  cont' : Continuous (uncurry toFun)\n  map_add' : ∀ t₁ t₂ x, toFun (t₁ + t₂) x = toFun t₁ (toFun t₂ x)\n  map_zero' : ∀ x, toFun 0 x = x\n\n"}
{"name":"Flow.cont'","module":"Mathlib.Dynamics.Flow","initialProofState":"τ : Type u_1\ninst✝³ : TopologicalSpace τ\ninst✝² : AddMonoid τ\ninst✝¹ : ContinuousAdd τ\nα : Type u_2\ninst✝ : TopologicalSpace α\nself : Flow τ α\n⊢ Continuous (Function.uncurry self.toFun)","decl":"/-- A flow on a topological space `α` by an additive topological\n    monoid `τ` is a continuous monoid action of `τ` on `α`. -/\nstructure Flow (τ : Type*) [TopologicalSpace τ] [AddMonoid τ] [ContinuousAdd τ] (α : Type*)\n  [TopologicalSpace α] where\n  /-- The map `τ → α → α` underlying a flow of `τ` on `α`. -/\n  toFun : τ → α → α\n  cont' : Continuous (uncurry toFun)\n  map_add' : ∀ t₁ t₂ x, toFun (t₁ + t₂) x = toFun t₁ (toFun t₂ x)\n  map_zero' : ∀ x, toFun 0 x = x\n\n"}
{"name":"Flow.map_add'","module":"Mathlib.Dynamics.Flow","initialProofState":"τ : Type u_1\ninst✝³ : TopologicalSpace τ\ninst✝² : AddMonoid τ\ninst✝¹ : ContinuousAdd τ\nα : Type u_2\ninst✝ : TopologicalSpace α\nself : Flow τ α\nt₁ t₂ : τ\nx : α\n⊢ Eq (self.toFun (HAdd.hAdd t₁ t₂) x) (self.toFun t₁ (self.toFun t₂ x))","decl":"/-- A flow on a topological space `α` by an additive topological\n    monoid `τ` is a continuous monoid action of `τ` on `α`. -/\nstructure Flow (τ : Type*) [TopologicalSpace τ] [AddMonoid τ] [ContinuousAdd τ] (α : Type*)\n  [TopologicalSpace α] where\n  /-- The map `τ → α → α` underlying a flow of `τ` on `α`. -/\n  toFun : τ → α → α\n  cont' : Continuous (uncurry toFun)\n  map_add' : ∀ t₁ t₂ x, toFun (t₁ + t₂) x = toFun t₁ (toFun t₂ x)\n  map_zero' : ∀ x, toFun 0 x = x\n\n"}
{"name":"Flow.mk.sizeOf_spec","module":"Mathlib.Dynamics.Flow","initialProofState":"τ : Type u_1\ninst✝⁵ : TopologicalSpace τ\ninst✝⁴ : AddMonoid τ\ninst✝³ : ContinuousAdd τ\nα : Type u_2\ninst✝² : TopologicalSpace α\ninst✝¹ : SizeOf τ\ninst✝ : SizeOf α\ntoFun : τ → α → α\ncont' : Continuous (Function.uncurry toFun)\nmap_add' : ∀ (t₁ t₂ : τ) (x : α), Eq (toFun (HAdd.hAdd t₁ t₂) x) (toFun t₁ (toFun t₂ x))\nmap_zero' : ∀ (x : α), Eq (toFun 0 x) x\n⊢ Eq (SizeOf.sizeOf { toFun := toFun, cont' := cont', map_add' := map_add', map_zero' := map_zero' }) (HAdd.hAdd 1 (SizeOf.sizeOf cont'))","decl":"/-- A flow on a topological space `α` by an additive topological\n    monoid `τ` is a continuous monoid action of `τ` on `α`. -/\nstructure Flow (τ : Type*) [TopologicalSpace τ] [AddMonoid τ] [ContinuousAdd τ] (α : Type*)\n  [TopologicalSpace α] where\n  /-- The map `τ → α → α` underlying a flow of `τ` on `α`. -/\n  toFun : τ → α → α\n  cont' : Continuous (uncurry toFun)\n  map_add' : ∀ t₁ t₂ x, toFun (t₁ + t₂) x = toFun t₁ (toFun t₂ x)\n  map_zero' : ∀ x, toFun 0 x = x\n\n"}
{"name":"Flow.ext","module":"Mathlib.Dynamics.Flow","initialProofState":"τ : Type u_1\ninst✝³ : AddMonoid τ\ninst✝² : TopologicalSpace τ\ninst✝¹ : ContinuousAdd τ\nα : Type u_2\ninst✝ : TopologicalSpace α\nϕ₁ ϕ₂ : Flow τ α\na✝ : ∀ (t : τ) (x : α), Eq (ϕ₁.toFun t x) (ϕ₂.toFun t x)\n⊢ Eq ϕ₁ ϕ₂","decl":"@[ext]\ntheorem ext : ∀ {ϕ₁ ϕ₂ : Flow τ α}, (∀ t x, ϕ₁ t x = ϕ₂ t x) → ϕ₁ = ϕ₂\n  | ⟨f₁, _, _, _⟩, ⟨f₂, _, _, _⟩, h => by\n    congr\n    funext\n    exact h _ _\n\n"}
{"name":"Flow.ext_iff","module":"Mathlib.Dynamics.Flow","initialProofState":"τ : Type u_1\ninst✝³ : AddMonoid τ\ninst✝² : TopologicalSpace τ\ninst✝¹ : ContinuousAdd τ\nα : Type u_2\ninst✝ : TopologicalSpace α\nϕ₁ ϕ₂ : Flow τ α\n⊢ Iff (Eq ϕ₁ ϕ₂) (∀ (t : τ) (x : α), Eq (ϕ₁.toFun t x) (ϕ₂.toFun t x))","decl":"@[ext]\ntheorem ext : ∀ {ϕ₁ ϕ₂ : Flow τ α}, (∀ t x, ϕ₁ t x = ϕ₂ t x) → ϕ₁ = ϕ₂\n  | ⟨f₁, _, _, _⟩, ⟨f₂, _, _, _⟩, h => by\n    congr\n    funext\n    exact h _ _\n\n"}
{"name":"Flow.continuous","module":"Mathlib.Dynamics.Flow","initialProofState":"τ : Type u_1\ninst✝⁴ : AddMonoid τ\ninst✝³ : TopologicalSpace τ\ninst✝² : ContinuousAdd τ\nα : Type u_2\ninst✝¹ : TopologicalSpace α\nϕ : Flow τ α\nβ : Type u_3\ninst✝ : TopologicalSpace β\nt : β → τ\nht : Continuous t\nf : β → α\nhf : Continuous f\n⊢ Continuous fun x => ϕ.toFun (t x) (f x)","decl":"@[continuity, fun_prop]\nprotected theorem continuous {β : Type*} [TopologicalSpace β] {t : β → τ} (ht : Continuous t)\n    {f : β → α} (hf : Continuous f) : Continuous fun x => ϕ (t x) (f x) :=\n  ϕ.cont'.comp (ht.prod_mk hf)\n\n"}
{"name":"Continuous.flow","module":"Mathlib.Dynamics.Flow","initialProofState":"τ : Type u_1\ninst✝⁴ : AddMonoid τ\ninst✝³ : TopologicalSpace τ\ninst✝² : ContinuousAdd τ\nα : Type u_2\ninst✝¹ : TopologicalSpace α\nϕ : Flow τ α\nβ : Type u_3\ninst✝ : TopologicalSpace β\nt : β → τ\nht : Continuous t\nf : β → α\nhf : Continuous f\n⊢ Continuous fun x => ϕ.toFun (t x) (f x)","decl":"alias _root_.Continuous.flow := Flow.continuous\n\n"}
{"name":"Flow.map_add","module":"Mathlib.Dynamics.Flow","initialProofState":"τ : Type u_1\ninst✝³ : AddMonoid τ\ninst✝² : TopologicalSpace τ\ninst✝¹ : ContinuousAdd τ\nα : Type u_2\ninst✝ : TopologicalSpace α\nϕ : Flow τ α\nt₁ t₂ : τ\nx : α\n⊢ Eq (ϕ.toFun (HAdd.hAdd t₁ t₂) x) (ϕ.toFun t₁ (ϕ.toFun t₂ x))","decl":"theorem map_add (t₁ t₂ : τ) (x : α) : ϕ (t₁ + t₂) x = ϕ t₁ (ϕ t₂ x) := ϕ.map_add' _ _ _\n\n"}
{"name":"Flow.map_zero","module":"Mathlib.Dynamics.Flow","initialProofState":"τ : Type u_1\ninst✝³ : AddMonoid τ\ninst✝² : TopologicalSpace τ\ninst✝¹ : ContinuousAdd τ\nα : Type u_2\ninst✝ : TopologicalSpace α\nϕ : Flow τ α\n⊢ Eq (ϕ.toFun 0) id","decl":"@[simp]\ntheorem map_zero : ϕ 0 = id := funext ϕ.map_zero'\n\n"}
{"name":"Flow.map_zero_apply","module":"Mathlib.Dynamics.Flow","initialProofState":"τ : Type u_1\ninst✝³ : AddMonoid τ\ninst✝² : TopologicalSpace τ\ninst✝¹ : ContinuousAdd τ\nα : Type u_2\ninst✝ : TopologicalSpace α\nϕ : Flow τ α\nx : α\n⊢ Eq (ϕ.toFun 0 x) x","decl":"theorem map_zero_apply (x : α) : ϕ 0 x = x := ϕ.map_zero' x\n\n"}
{"name":"Flow.isInvariant_iff_image_eq","module":"Mathlib.Dynamics.Flow","initialProofState":"τ : Type u_1\ninst✝³ : AddCommGroup τ\ninst✝² : TopologicalSpace τ\ninst✝¹ : TopologicalAddGroup τ\nα : Type u_2\ninst✝ : TopologicalSpace α\nϕ : Flow τ α\ns : Set α\n⊢ Iff (IsInvariant ϕ.toFun s) (∀ (t : τ), Eq (Set.image (ϕ.toFun t) s) s)","decl":"theorem isInvariant_iff_image_eq (s : Set α) : IsInvariant ϕ s ↔ ∀ t, ϕ t '' s = s :=\n  (isInvariant_iff_image _ _).trans\n    (Iff.intro\n      (fun h t => Subset.antisymm (h t) fun _ hx => ⟨_, h (-t) ⟨_, hx, rfl⟩, by simp [← map_add]⟩)\n      fun h t => by rw [h t])\n\n"}
{"name":"Flow.continuous_toFun","module":"Mathlib.Dynamics.Flow","initialProofState":"τ : Type u_1\ninst✝³ : AddCommGroup τ\ninst✝² : TopologicalSpace τ\ninst✝¹ : TopologicalAddGroup τ\nα : Type u_2\ninst✝ : TopologicalSpace α\nϕ : Flow τ α\nt : τ\n⊢ Continuous (ϕ.toFun t)","decl":"@[continuity]\ntheorem continuous_toFun (t : τ) : Continuous (ϕ.toFun t) := by\n  rw [← curry_uncurry ϕ.toFun]\n  apply continuous_curry\n  exact ϕ.cont'\n\n"}
{"name":"Flow.image_eq_preimage","module":"Mathlib.Dynamics.Flow","initialProofState":"τ : Type u_1\ninst✝³ : AddCommGroup τ\ninst✝² : TopologicalSpace τ\ninst✝¹ : TopologicalAddGroup τ\nα : Type u_2\ninst✝ : TopologicalSpace α\nϕ : Flow τ α\nt : τ\ns : Set α\n⊢ Eq (Set.image (ϕ.toFun t) s) (Set.preimage (ϕ.toFun (Neg.neg t)) s)","decl":"theorem image_eq_preimage (t : τ) (s : Set α) : ϕ t '' s = ϕ (-t) ⁻¹' s :=\n  (ϕ.toHomeomorph t).toEquiv.image_eq_preimage s\n\n"}
