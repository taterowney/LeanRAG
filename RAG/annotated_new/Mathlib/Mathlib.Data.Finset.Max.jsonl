{"name":"Finset.max_eq_sup_coe","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ns : Finset α\n⊢ Eq s.max (s.sup WithBot.some)","decl":"theorem max_eq_sup_coe {s : Finset α} : s.max = s.sup (↑) :=\n  rfl\n\n"}
{"name":"Finset.max_eq_sup_withBot","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ns : Finset α\n⊢ Eq s.max (s.sup WithBot.some)","decl":"theorem max_eq_sup_withBot (s : Finset α) : s.max = sup s (↑) :=\n  rfl\n\n"}
{"name":"Finset.max_empty","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\n⊢ Eq EmptyCollection.emptyCollection.max Bot.bot","decl":"@[simp]\ntheorem max_empty : (∅ : Finset α).max = ⊥ :=\n  rfl\n\n"}
{"name":"Finset.max_insert","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\na : α\ns : Finset α\n⊢ Eq (Insert.insert a s).max (Max.max (↑a) s.max)","decl":"@[simp]\ntheorem max_insert {a : α} {s : Finset α} : (insert a s).max = max ↑a s.max :=\n  fold_insert_idem\n\n"}
{"name":"Finset.max_singleton","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\na : α\n⊢ Eq (Singleton.singleton a).max ↑a","decl":"@[simp]\ntheorem max_singleton {a : α} : Finset.max {a} = (a : WithBot α) := by\n  rw [← insert_emptyc_eq]\n  exact max_insert\n\n"}
{"name":"Finset.max_of_mem","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ns : Finset α\na : α\nh : Membership.mem s a\n⊢ Exists fun b => Eq s.max ↑b","decl":"theorem max_of_mem {s : Finset α} {a : α} (h : a ∈ s) : ∃ b : α, s.max = b := by\n  obtain ⟨b, h, _⟩ := le_sup (α := WithBot α) h _ rfl\n  exact ⟨b, h⟩\n\n"}
{"name":"Finset.max_of_nonempty","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ns : Finset α\nh : s.Nonempty\n⊢ Exists fun a => Eq s.max ↑a","decl":"theorem max_of_nonempty {s : Finset α} (h : s.Nonempty) : ∃ a : α, s.max = a :=\n  let ⟨_, h⟩ := h\n  max_of_mem h\n\n"}
{"name":"Finset.max_eq_bot","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ns : Finset α\n⊢ Iff (Eq s.max Bot.bot) (Eq s EmptyCollection.emptyCollection)","decl":"theorem max_eq_bot {s : Finset α} : s.max = ⊥ ↔ s = ∅ :=\n  ⟨fun h ↦ s.eq_empty_or_nonempty.elim id fun H ↦ by\n      obtain ⟨a, ha⟩ := max_of_nonempty H\n      rw [h] at ha; cases ha; , -- the `;` is needed since the `cases` syntax allows `cases a, b`\n    fun h ↦ h.symm ▸ max_empty⟩\n\n"}
{"name":"Finset.mem_of_max","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ns : Finset α\na : α\na✝ : Eq s.max ↑a\n⊢ Membership.mem s a","decl":"theorem mem_of_max {s : Finset α} : ∀ {a : α}, s.max = a → a ∈ s := by\n  induction' s using Finset.induction_on with b s _ ih\n  · intro _ H; cases H\n  · intro a h\n    by_cases p : b = a\n    · induction p\n      exact mem_insert_self b s\n    · cases' max_choice (↑b) s.max with q q <;> rw [max_insert, q] at h\n      · cases h\n        cases p rfl\n      · exact mem_insert_of_mem (ih h)\n\n"}
{"name":"Finset.le_max","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\na : α\ns : Finset α\nas : Membership.mem s a\n⊢ LE.le (↑a) s.max","decl":"theorem le_max {a : α} {s : Finset α} (as : a ∈ s) : ↑a ≤ s.max :=\n  le_sup as\n\n"}
{"name":"Finset.not_mem_of_max_lt_coe","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\na : α\ns : Finset α\nh : LT.lt s.max ↑a\n⊢ Not (Membership.mem s a)","decl":"theorem not_mem_of_max_lt_coe {a : α} {s : Finset α} (h : s.max < a) : a ∉ s :=\n  mt le_max h.not_le\n\n"}
{"name":"Finset.le_max_of_eq","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ns : Finset α\na b : α\nh₁ : Membership.mem s a\nh₂ : Eq s.max ↑b\n⊢ LE.le a b","decl":"theorem le_max_of_eq {s : Finset α} {a b : α} (h₁ : a ∈ s) (h₂ : s.max = b) : a ≤ b :=\n  WithBot.coe_le_coe.mp <| (le_max h₁).trans h₂.le\n\n"}
{"name":"Finset.not_mem_of_max_lt","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ns : Finset α\na b : α\nh₁ : LT.lt b a\nh₂ : Eq s.max ↑b\n⊢ Not (Membership.mem s a)","decl":"theorem not_mem_of_max_lt {s : Finset α} {a b : α} (h₁ : b < a) (h₂ : s.max = ↑b) : a ∉ s :=\n  Finset.not_mem_of_max_lt_coe <| h₂.trans_lt <| WithBot.coe_lt_coe.mpr h₁\n\n"}
{"name":"Finset.max_union","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ns t : Finset α\n⊢ Eq (Union.union s t).max (Max.max s.max t.max)","decl":"theorem max_union {s t : Finset α} : (s ∪ t).max = s.max ⊔ t.max := sup_union\n\n"}
{"name":"Finset.max_mono","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ns t : Finset α\nst : HasSubset.Subset s t\n⊢ LE.le s.max t.max","decl":"@[gcongr]\ntheorem max_mono {s t : Finset α} (st : s ⊆ t) : s.max ≤ t.max :=\n  sup_mono st\n\n"}
{"name":"Finset.max_le","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\nM : WithBot α\ns : Finset α\nst : ∀ (a : α), Membership.mem s a → LE.le (↑a) M\n⊢ LE.le s.max M","decl":"protected theorem max_le {M : WithBot α} {s : Finset α} (st : ∀ a ∈ s, (a : WithBot α) ≤ M) :\n    s.max ≤ M :=\n  Finset.sup_le st\n\n"}
{"name":"Finset.max_le_iff","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\nm : WithBot α\ns : Finset α\n⊢ Iff (LE.le s.max m) (∀ (a : α), Membership.mem s a → LE.le (↑a) m)","decl":"@[simp]\nprotected lemma max_le_iff {m : WithBot α} {s : Finset α} : s.max ≤ m ↔ ∀ a ∈ s, a ≤ m :=\n  Finset.sup_le_iff\n\n"}
{"name":"Finset.max_eq_top","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrder α\ninst✝ : OrderTop α\ns : Finset α\n⊢ Iff (Eq s.max Top.top) (Membership.mem s Top.top)","decl":"@[simp]\nprotected lemma max_eq_top [OrderTop α] {s : Finset α} : s.max = ⊤ ↔ ⊤ ∈ s :=\n  Finset.sup_eq_top_iff.trans <| by simp\n\n"}
{"name":"Finset.min_eq_inf_withTop","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ns : Finset α\n⊢ Eq s.min (s.inf WithTop.some)","decl":"theorem min_eq_inf_withTop (s : Finset α) : s.min = inf s (↑) :=\n  rfl\n\n"}
{"name":"Finset.min_empty","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\n⊢ Eq EmptyCollection.emptyCollection.min Top.top","decl":"@[simp]\ntheorem min_empty : (∅ : Finset α).min = ⊤ :=\n  rfl\n\n"}
{"name":"Finset.min_insert","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\na : α\ns : Finset α\n⊢ Eq (Insert.insert a s).min (Min.min (↑a) s.min)","decl":"@[simp]\ntheorem min_insert {a : α} {s : Finset α} : (insert a s).min = min (↑a) s.min :=\n  fold_insert_idem\n\n"}
{"name":"Finset.min_singleton","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\na : α\n⊢ Eq (Singleton.singleton a).min ↑a","decl":"@[simp]\ntheorem min_singleton {a : α} : Finset.min {a} = (a : WithTop α) := by\n  rw [← insert_emptyc_eq]\n  exact min_insert\n\n"}
{"name":"Finset.min_of_mem","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ns : Finset α\na : α\nh : Membership.mem s a\n⊢ Exists fun b => Eq s.min ↑b","decl":"theorem min_of_mem {s : Finset α} {a : α} (h : a ∈ s) : ∃ b : α, s.min = b := by\n  obtain ⟨b, h, _⟩ := inf_le (α := WithTop α) h _ rfl\n  exact ⟨b, h⟩\n\n"}
{"name":"Finset.min_of_nonempty","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ns : Finset α\nh : s.Nonempty\n⊢ Exists fun a => Eq s.min ↑a","decl":"theorem min_of_nonempty {s : Finset α} (h : s.Nonempty) : ∃ a : α, s.min = a :=\n  let ⟨_, h⟩ := h\n  min_of_mem h\n\n"}
{"name":"Finset.min_eq_top","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ns : Finset α\n⊢ Iff (Eq s.min Top.top) (Eq s EmptyCollection.emptyCollection)","decl":"@[simp]\ntheorem min_eq_top {s : Finset α} : s.min = ⊤ ↔ s = ∅ := by\n  simp [Finset.min, eq_empty_iff_forall_not_mem]\n\n"}
{"name":"Finset.mem_of_min","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ns : Finset α\na : α\na✝ : Eq s.min ↑a\n⊢ Membership.mem s a","decl":"theorem mem_of_min {s : Finset α} : ∀ {a : α}, s.min = a → a ∈ s :=\n  @mem_of_max αᵒᵈ _ s\n\n"}
{"name":"Finset.min_le","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\na : α\ns : Finset α\nas : Membership.mem s a\n⊢ LE.le s.min ↑a","decl":"theorem min_le {a : α} {s : Finset α} (as : a ∈ s) : s.min ≤ a :=\n  inf_le as\n\n"}
{"name":"Finset.not_mem_of_coe_lt_min","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\na : α\ns : Finset α\nh : LT.lt (↑a) s.min\n⊢ Not (Membership.mem s a)","decl":"theorem not_mem_of_coe_lt_min {a : α} {s : Finset α} (h : ↑a < s.min) : a ∉ s :=\n  mt min_le h.not_le\n\n"}
{"name":"Finset.min_le_of_eq","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ns : Finset α\na b : α\nh₁ : Membership.mem s b\nh₂ : Eq s.min ↑a\n⊢ LE.le a b","decl":"theorem min_le_of_eq {s : Finset α} {a b : α} (h₁ : b ∈ s) (h₂ : s.min = a) : a ≤ b :=\n  WithTop.coe_le_coe.mp <| h₂.ge.trans (min_le h₁)\n\n"}
{"name":"Finset.not_mem_of_lt_min","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ns : Finset α\na b : α\nh₁ : LT.lt a b\nh₂ : Eq s.min ↑b\n⊢ Not (Membership.mem s a)","decl":"theorem not_mem_of_lt_min {s : Finset α} {a b : α} (h₁ : a < b) (h₂ : s.min = ↑b) : a ∉ s :=\n  Finset.not_mem_of_coe_lt_min <| (WithTop.coe_lt_coe.mpr h₁).trans_eq h₂.symm\n\n"}
{"name":"Finset.min_union","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ns t : Finset α\n⊢ Eq (Union.union s t).min (Min.min s.min t.min)","decl":"theorem min_union {s t : Finset α} : (s ∪ t).min = s.min ⊓ t.min := inf_union\n\n"}
{"name":"Finset.min_mono","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ns t : Finset α\nst : HasSubset.Subset s t\n⊢ LE.le t.min s.min","decl":"@[gcongr]\ntheorem min_mono {s t : Finset α} (st : s ⊆ t) : t.min ≤ s.min :=\n  inf_mono st\n\n"}
{"name":"Finset.le_min","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\nm : WithTop α\ns : Finset α\nst : ∀ (a : α), Membership.mem s a → LE.le m ↑a\n⊢ LE.le m s.min","decl":"protected theorem le_min {m : WithTop α} {s : Finset α} (st : ∀ a : α, a ∈ s → m ≤ a) : m ≤ s.min :=\n  Finset.le_inf st\n\n"}
{"name":"Finset.le_min_iff","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\nm : WithTop α\ns : Finset α\n⊢ Iff (LE.le m s.min) (∀ (a : α), Membership.mem s a → LE.le m ↑a)","decl":"@[simp]\nprotected theorem le_min_iff {m : WithTop α} {s : Finset α} : m ≤ s.min ↔ ∀ a ∈ s, m ≤ a :=\n  Finset.le_inf_iff\n\n"}
{"name":"Finset.min_eq_bot","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrder α\ninst✝ : OrderBot α\ns : Finset α\n⊢ Iff (Eq s.min Bot.bot) (Membership.mem s Bot.bot)","decl":"@[simp]\nprotected theorem min_eq_bot [OrderBot α] {s : Finset α} : s.min = ⊥ ↔ ⊥ ∈ s :=\n  Finset.max_eq_top (α := αᵒᵈ)\n\n"}
{"name":"Finset.min'_mem","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ns : Finset α\nH : s.Nonempty\n⊢ Membership.mem s (s.min' H)","decl":"theorem min'_mem : s.min' H ∈ s :=\n  mem_of_min <| by simp only [Finset.min, min', id_eq, coe_inf', Function.comp_def]\n\n"}
{"name":"Finset.min'_le","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ns : Finset α\nx : α\nH2 : Membership.mem s x\n⊢ LE.le (s.min' ⋯) x","decl":"theorem min'_le (x) (H2 : x ∈ s) : s.min' ⟨x, H2⟩ ≤ x :=\n  min_le_of_eq H2 (WithTop.coe_untop _ _).symm\n\n"}
{"name":"Finset.le_min'","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ns : Finset α\nH : s.Nonempty\nx : α\nH2 : ∀ (y : α), Membership.mem s y → LE.le x y\n⊢ LE.le x (s.min' H)","decl":"theorem le_min' (x) (H2 : ∀ y ∈ s, x ≤ y) : x ≤ s.min' H :=\n  H2 _ <| min'_mem _ _\n\n"}
{"name":"Finset.isLeast_min'","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ns : Finset α\nH : s.Nonempty\n⊢ IsLeast (↑s) (s.min' H)","decl":"theorem isLeast_min' : IsLeast (↑s) (s.min' H) :=\n  ⟨min'_mem _ _, min'_le _⟩\n\n"}
{"name":"Finset.le_min'_iff","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ns : Finset α\nH : s.Nonempty\nx : α\n⊢ Iff (LE.le x (s.min' H)) (∀ (y : α), Membership.mem s y → LE.le x y)","decl":"@[simp]\ntheorem le_min'_iff {x} : x ≤ s.min' H ↔ ∀ y ∈ s, x ≤ y :=\n  le_isGLB_iff (isLeast_min' s H).isGLB\n\n"}
{"name":"Finset.min'_singleton","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\na : α\n⊢ Eq ((Singleton.singleton a).min' ⋯) a","decl":"/-- `{a}.min' _` is `a`. -/\n@[simp]\ntheorem min'_singleton (a : α) : ({a} : Finset α).min' (singleton_nonempty _) = a := by simp [min']\n\n"}
{"name":"Finset.max'_mem","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ns : Finset α\nH : s.Nonempty\n⊢ Membership.mem s (s.max' H)","decl":"theorem max'_mem : s.max' H ∈ s :=\n  mem_of_max <| by simp only [max', Finset.max, id_eq, coe_sup', Function.comp_def]\n\n"}
{"name":"Finset.le_max'","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ns : Finset α\nx : α\nH2 : Membership.mem s x\n⊢ LE.le x (s.max' ⋯)","decl":"theorem le_max' (x) (H2 : x ∈ s) : x ≤ s.max' ⟨x, H2⟩ :=\n  le_max_of_eq H2 (WithBot.coe_unbot _ _).symm\n\n"}
{"name":"Finset.max'_le","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ns : Finset α\nH : s.Nonempty\nx : α\nH2 : ∀ (y : α), Membership.mem s y → LE.le y x\n⊢ LE.le (s.max' H) x","decl":"theorem max'_le (x) (H2 : ∀ y ∈ s, y ≤ x) : s.max' H ≤ x :=\n  H2 _ <| max'_mem _ _\n\n"}
{"name":"Finset.isGreatest_max'","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ns : Finset α\nH : s.Nonempty\n⊢ IsGreatest (↑s) (s.max' H)","decl":"theorem isGreatest_max' : IsGreatest (↑s) (s.max' H) :=\n  ⟨max'_mem _ _, le_max' _⟩\n\n"}
{"name":"Finset.max'_le_iff","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ns : Finset α\nH : s.Nonempty\nx : α\n⊢ Iff (LE.le (s.max' H) x) (∀ (y : α), Membership.mem s y → LE.le y x)","decl":"@[simp]\ntheorem max'_le_iff {x} : s.max' H ≤ x ↔ ∀ y ∈ s, y ≤ x :=\n  isLUB_le_iff (isGreatest_max' s H).isLUB\n\n"}
{"name":"Finset.max'_lt_iff","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ns : Finset α\nH : s.Nonempty\nx : α\n⊢ Iff (LT.lt (s.max' H) x) (∀ (y : α), Membership.mem s y → LT.lt y x)","decl":"@[simp]\ntheorem max'_lt_iff {x} : s.max' H < x ↔ ∀ y ∈ s, y < x :=\n  ⟨fun Hlt y hy => (s.le_max' y hy).trans_lt Hlt, fun H => H _ <| s.max'_mem _⟩\n\n"}
{"name":"Finset.lt_min'_iff","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ns : Finset α\nH : s.Nonempty\nx : α\n⊢ Iff (LT.lt x (s.min' H)) (∀ (y : α), Membership.mem s y → LT.lt x y)","decl":"@[simp]\ntheorem lt_min'_iff : x < s.min' H ↔ ∀ y ∈ s, x < y :=\n  @max'_lt_iff αᵒᵈ _ _ H _\n\n"}
{"name":"Finset.max'_eq_sup'","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ns : Finset α\nH : s.Nonempty\n⊢ Eq (s.max' H) (s.sup' H id)","decl":"theorem max'_eq_sup' : s.max' H = s.sup' H id := rfl\n\n"}
{"name":"Finset.min'_eq_inf'","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ns : Finset α\nH : s.Nonempty\n⊢ Eq (s.min' H) (s.inf' H id)","decl":"theorem min'_eq_inf' : s.min' H = s.inf' H id := rfl\n\n"}
{"name":"Finset.max'_singleton","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\na : α\n⊢ Eq ((Singleton.singleton a).max' ⋯) a","decl":"/-- `{a}.max' _` is `a`. -/\n@[simp]\ntheorem max'_singleton (a : α) : ({a} : Finset α).max' (singleton_nonempty _) = a := by simp [max']\n\n"}
{"name":"Finset.min'_lt_max'","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ns : Finset α\ni j : α\nH1 : Membership.mem s i\nH2 : Membership.mem s j\nH3 : Ne i j\n⊢ LT.lt (s.min' ⋯) (s.max' ⋯)","decl":"theorem min'_lt_max' {i j} (H1 : i ∈ s) (H2 : j ∈ s) (H3 : i ≠ j) :\n    s.min' ⟨i, H1⟩ < s.max' ⟨i, H1⟩ :=\n  isGLB_lt_isLUB_of_ne (s.isLeast_min' _).isGLB (s.isGreatest_max' _).isLUB H1 H2 H3\n\n"}
{"name":"Finset.min'_lt_max'_of_card","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ns : Finset α\nh₂ : LT.lt 1 s.card\n⊢ LT.lt (s.min' ⋯) (s.max' ⋯)","decl":"/-- If there's more than 1 element, the min' is less than the max'. An alternate version of\n`min'_lt_max'` which is sometimes more convenient.\n-/\ntheorem min'_lt_max'_of_card (h₂ : 1 < card s) :\n    s.min' (Finset.card_pos.1 <| by omega) < s.max' (Finset.card_pos.1 <| by omega) := by\n  rcases one_lt_card.1 h₂ with ⟨a, ha, b, hb, hab⟩\n  exact s.min'_lt_max' ha hb hab\n\n"}
{"name":"Finset.max'_union","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ns₁ s₂ : Finset α\nh₁ : s₁.Nonempty\nh₂ : s₂.Nonempty\n⊢ Eq ((Union.union s₁ s₂).max' ⋯) (Max.max (s₁.max' h₁) (s₂.max' h₂))","decl":"theorem max'_union {s₁ s₂ : Finset α} (h₁ : s₁.Nonempty) (h₂ : s₂.Nonempty) :\n    (s₁ ∪ s₂).max' (h₁.mono subset_union_left) = s₁.max' h₁ ⊔ s₂.max' h₂ := sup'_union h₁ h₂ id\n\n"}
{"name":"Finset.min'_union","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ns₁ s₂ : Finset α\nh₁ : s₁.Nonempty\nh₂ : s₂.Nonempty\n⊢ Eq ((Union.union s₁ s₂).min' ⋯) (Min.min (s₁.min' h₁) (s₂.min' h₂))","decl":"theorem min'_union {s₁ s₂ : Finset α} (h₁ : s₁.Nonempty) (h₂ : s₂.Nonempty) :\n    (s₁ ∪ s₂).min' (h₁.mono subset_union_left) = s₁.min' h₁ ⊓ s₂.min' h₂ := inf'_union h₁ h₂ id\n\n"}
{"name":"Finset.map_ofDual_min","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ns : Finset (OrderDual α)\n⊢ Eq (WithTop.map (⇑OrderDual.ofDual) s.min) (Finset.image (⇑OrderDual.ofDual) s).max","decl":"theorem map_ofDual_min (s : Finset αᵒᵈ) : s.min.map ofDual = (s.image ofDual).max := by\n  rw [max_eq_sup_withBot, sup_image]\n  exact congr_fun Option.map_id _\n\n"}
{"name":"Finset.map_ofDual_max","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ns : Finset (OrderDual α)\n⊢ Eq (WithBot.map (⇑OrderDual.ofDual) s.max) (Finset.image (⇑OrderDual.ofDual) s).min","decl":"theorem map_ofDual_max (s : Finset αᵒᵈ) : s.max.map ofDual = (s.image ofDual).min := by\n  rw [min_eq_inf_withTop, inf_image]\n  exact congr_fun Option.map_id _\n\n"}
{"name":"Finset.map_toDual_min","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ns : Finset α\n⊢ Eq (WithTop.map (⇑OrderDual.toDual) s.min) (Finset.image (⇑OrderDual.toDual) s).max","decl":"theorem map_toDual_min (s : Finset α) : s.min.map toDual = (s.image toDual).max := by\n  rw [max_eq_sup_withBot, sup_image]\n  exact congr_fun Option.map_id _\n\n"}
{"name":"Finset.map_toDual_max","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ns : Finset α\n⊢ Eq (WithBot.map (⇑OrderDual.toDual) s.max) (Finset.image (⇑OrderDual.toDual) s).min","decl":"theorem map_toDual_max (s : Finset α) : s.max.map toDual = (s.image toDual).min := by\n  rw [min_eq_inf_withTop, inf_image]\n  exact congr_fun Option.map_id _\n\n-- Porting note: new proofs without `convert` for the next four theorems.\n\n"}
{"name":"Finset.ofDual_min'","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ns : Finset (OrderDual α)\nhs : s.Nonempty\n⊢ Eq (OrderDual.ofDual (s.min' hs)) ((Finset.image (⇑OrderDual.ofDual) s).max' ⋯)","decl":"theorem ofDual_min' {s : Finset αᵒᵈ} (hs : s.Nonempty) :\n    ofDual (min' s hs) = max' (s.image ofDual) (hs.image _) := by\n  rw [← WithBot.coe_eq_coe]\n  simp only [min'_eq_inf', id_eq, ofDual_inf', Function.comp_apply, coe_sup', max'_eq_sup',\n    sup_image]\n  rfl\n\n"}
{"name":"Finset.ofDual_max'","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ns : Finset (OrderDual α)\nhs : s.Nonempty\n⊢ Eq (OrderDual.ofDual (s.max' hs)) ((Finset.image (⇑OrderDual.ofDual) s).min' ⋯)","decl":"theorem ofDual_max' {s : Finset αᵒᵈ} (hs : s.Nonempty) :\n    ofDual (max' s hs) = min' (s.image ofDual) (hs.image _) := by\n  rw [← WithTop.coe_eq_coe]\n  simp only [max'_eq_sup', id_eq, ofDual_sup', Function.comp_apply, coe_inf', min'_eq_inf',\n    inf_image]\n  rfl\n\n"}
{"name":"Finset.toDual_min'","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ns : Finset α\nhs : s.Nonempty\n⊢ Eq (OrderDual.toDual (s.min' hs)) ((Finset.image (⇑OrderDual.toDual) s).max' ⋯)","decl":"theorem toDual_min' {s : Finset α} (hs : s.Nonempty) :\n    toDual (min' s hs) = max' (s.image toDual) (hs.image _) := by\n  rw [← WithBot.coe_eq_coe]\n  simp only [min'_eq_inf', id_eq, toDual_inf', Function.comp_apply, coe_sup', max'_eq_sup',\n    sup_image]\n  rfl\n\n"}
{"name":"Finset.toDual_max'","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ns : Finset α\nhs : s.Nonempty\n⊢ Eq (OrderDual.toDual (s.max' hs)) ((Finset.image (⇑OrderDual.toDual) s).min' ⋯)","decl":"theorem toDual_max' {s : Finset α} (hs : s.Nonempty) :\n    toDual (max' s hs) = min' (s.image toDual) (hs.image _) := by\n  rw [← WithTop.coe_eq_coe]\n  simp only [max'_eq_sup', id_eq, toDual_sup', Function.comp_apply, coe_inf', min'_eq_inf',\n    inf_image]\n  rfl\n\n"}
{"name":"Finset.max'_subset","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ns t : Finset α\nH : s.Nonempty\nhst : HasSubset.Subset s t\n⊢ LE.le (s.max' H) (t.max' ⋯)","decl":"theorem max'_subset {s t : Finset α} (H : s.Nonempty) (hst : s ⊆ t) :\n    s.max' H ≤ t.max' (H.mono hst) :=\n  le_max' _ _ (hst (s.max'_mem H))\n\n"}
{"name":"Finset.min'_subset","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ns t : Finset α\nH : s.Nonempty\nhst : HasSubset.Subset s t\n⊢ LE.le (t.min' ⋯) (s.min' H)","decl":"theorem min'_subset {s t : Finset α} (H : s.Nonempty) (hst : s ⊆ t) :\n    t.min' (H.mono hst) ≤ s.min' H :=\n  min'_le _ _ (hst (s.min'_mem H))\n\n"}
{"name":"Finset.max'_insert","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\na : α\ns : Finset α\nH : s.Nonempty\n⊢ Eq ((Insert.insert a s).max' ⋯) (Max.max (s.max' H) a)","decl":"theorem max'_insert (a : α) (s : Finset α) (H : s.Nonempty) :\n    (insert a s).max' (s.insert_nonempty a) = max (s.max' H) a :=\n  (isGreatest_max' _ _).unique <| by\n    rw [coe_insert, max_comm]\n    exact (isGreatest_max' _ _).insert _\n\n"}
{"name":"Finset.min'_insert","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\na : α\ns : Finset α\nH : s.Nonempty\n⊢ Eq ((Insert.insert a s).min' ⋯) (Min.min (s.min' H) a)","decl":"theorem min'_insert (a : α) (s : Finset α) (H : s.Nonempty) :\n    (insert a s).min' (s.insert_nonempty a) = min (s.min' H) a :=\n  (isLeast_min' _ _).unique <| by\n    rw [coe_insert, min_comm]\n    exact (isLeast_min' _ _).insert _\n\n"}
{"name":"Finset.lt_max'_of_mem_erase_max'","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrder α\ns : Finset α\nH : s.Nonempty\ninst✝ : DecidableEq α\na : α\nha : Membership.mem (s.erase (s.max' H)) a\n⊢ LT.lt a (s.max' H)","decl":"theorem lt_max'_of_mem_erase_max' [DecidableEq α] {a : α} (ha : a ∈ s.erase (s.max' H)) :\n    a < s.max' H :=\n  lt_of_le_of_ne (le_max' _ _ (mem_of_mem_erase ha)) <| ne_of_mem_of_not_mem ha <| not_mem_erase _ _\n\n"}
{"name":"Finset.min'_lt_of_mem_erase_min'","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrder α\ns : Finset α\nH : s.Nonempty\ninst✝ : DecidableEq α\na : α\nha : Membership.mem (s.erase (s.min' H)) a\n⊢ LT.lt (s.min' H) a","decl":"theorem min'_lt_of_mem_erase_min' [DecidableEq α] {a : α} (ha : a ∈ s.erase (s.min' H)) :\n    s.min' H < a :=\n  @lt_max'_of_mem_erase_max' αᵒᵈ _ s H _ a ha\n\n"}
{"name":"Finset.max'_image","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : LinearOrder α\ninst✝ : LinearOrder β\nf : α → β\nhf : Monotone f\ns : Finset α\nh : (Finset.image f s).Nonempty\n⊢ Eq ((Finset.image f s).max' h) (f (s.max' ⋯))","decl":"/-- To rewrite from right to left, use `Monotone.map_finset_max'`. -/\n@[simp]\ntheorem max'_image [LinearOrder β] {f : α → β} (hf : Monotone f) (s : Finset α)\n    (h : (s.image f).Nonempty) : (s.image f).max' h = f (s.max' h.of_image) := by\n  simp only [max', sup'_image]\n  exact .symm <| comp_sup'_eq_sup'_comp _ _ fun _ _ ↦ hf.map_max\n\n"}
{"name":"Monotone.map_finset_max'","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : LinearOrder α\ninst✝ : LinearOrder β\nf : α → β\nhf : Monotone f\ns : Finset α\nh : s.Nonempty\n⊢ Eq (f (s.max' h)) ((Finset.image f s).max' ⋯)","decl":"/-- A version of `Finset.max'_image` with LHS and RHS reversed.\nAlso, this version assumes that `s` is nonempty, not its image. -/\nlemma _root_.Monotone.map_finset_max' [LinearOrder β] {f : α → β} (hf : Monotone f) {s : Finset α}\n    (h : s.Nonempty) : f (s.max' h) = (s.image f).max' (h.image f) :=\n  .symm <| max'_image hf ..\n\n"}
{"name":"Finset.min'_image","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : LinearOrder α\ninst✝ : LinearOrder β\nf : α → β\nhf : Monotone f\ns : Finset α\nh : (Finset.image f s).Nonempty\n⊢ Eq ((Finset.image f s).min' h) (f (s.min' ⋯))","decl":"/-- To rewrite from right to left, use `Monotone.map_finset_min'`. -/\n@[simp]\ntheorem min'_image [LinearOrder β] {f : α → β} (hf : Monotone f) (s : Finset α)\n    (h : (s.image f).Nonempty) : (s.image f).min' h = f (s.min' h.of_image) := by\n  simp only [min', inf'_image]\n  exact .symm <| comp_inf'_eq_inf'_comp _ _ fun _ _ ↦ hf.map_min\n\n"}
{"name":"Monotone.map_finset_min'","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : LinearOrder α\ninst✝ : LinearOrder β\nf : α → β\nhf : Monotone f\ns : Finset α\nh : s.Nonempty\n⊢ Eq (f (s.min' h)) ((Finset.image f s).min' ⋯)","decl":"/-- A version of `Finset.min'_image` with LHS and RHS reversed.\nAlso, this version assumes that `s` is nonempty, not its image. -/\nlemma _root_.Monotone.map_finset_min' [LinearOrder β] {f : α → β} (hf : Monotone f) {s : Finset α}\n    (h : s.Nonempty) : f (s.min' h) = (s.image f).min' (h.image f) :=\n  .symm <| min'_image hf ..\n\n"}
{"name":"Finset.coe_max'","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ns : Finset α\nhs : s.Nonempty\n⊢ Eq (↑(s.max' hs)) s.max","decl":"theorem coe_max' {s : Finset α} (hs : s.Nonempty) : ↑(s.max' hs) = s.max :=\n  coe_sup' hs id\n\n"}
{"name":"Finset.coe_min'","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ns : Finset α\nhs : s.Nonempty\n⊢ Eq (↑(s.min' hs)) s.min","decl":"theorem coe_min' {s : Finset α} (hs : s.Nonempty) : ↑(s.min' hs) = s.min :=\n  coe_inf' hs id\n\n"}
{"name":"Finset.max_mem_image_coe","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ns : Finset α\nhs : s.Nonempty\n⊢ Membership.mem (Finset.image WithBot.some s) s.max","decl":"theorem max_mem_image_coe {s : Finset α} (hs : s.Nonempty) :\n    s.max ∈ (s.image (↑) : Finset (WithBot α)) :=\n  mem_image.2 ⟨max' s hs, max'_mem _ _, coe_max' hs⟩\n\n"}
{"name":"Finset.min_mem_image_coe","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ns : Finset α\nhs : s.Nonempty\n⊢ Membership.mem (Finset.image WithTop.some s) s.min","decl":"theorem min_mem_image_coe {s : Finset α} (hs : s.Nonempty) :\n    s.min ∈ (s.image (↑) : Finset (WithTop α)) :=\n  mem_image.2 ⟨min' s hs, min'_mem _ _, coe_min' hs⟩\n\n"}
{"name":"Finset.max_mem_insert_bot_image_coe","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ns : Finset α\n⊢ Membership.mem (Insert.insert Bot.bot (Finset.image WithBot.some s)) s.max","decl":"theorem max_mem_insert_bot_image_coe (s : Finset α) :\n    s.max ∈ (insert ⊥ (s.image (↑)) : Finset (WithBot α)) :=\n  mem_insert.2 <| s.eq_empty_or_nonempty.imp max_eq_bot.2 max_mem_image_coe\n\n"}
{"name":"Finset.min_mem_insert_top_image_coe","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ns : Finset α\n⊢ Membership.mem (Insert.insert Top.top (Finset.image WithTop.some s)) s.min","decl":"theorem min_mem_insert_top_image_coe (s : Finset α) :\n    s.min ∈ (insert ⊤ (s.image (↑)) : Finset (WithTop α)) :=\n  mem_insert.2 <| s.eq_empty_or_nonempty.imp min_eq_top.2 min_mem_image_coe\n\n"}
{"name":"Finset.max'_erase_ne_self","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\nx : α\ns : Finset α\ns0 : (s.erase x).Nonempty\n⊢ Ne ((s.erase x).max' s0) x","decl":"theorem max'_erase_ne_self {s : Finset α} (s0 : (s.erase x).Nonempty) : (s.erase x).max' s0 ≠ x :=\n  ne_of_mem_erase (max'_mem _ s0)\n\n"}
{"name":"Finset.min'_erase_ne_self","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\nx : α\ns : Finset α\ns0 : (s.erase x).Nonempty\n⊢ Ne ((s.erase x).min' s0) x","decl":"theorem min'_erase_ne_self {s : Finset α} (s0 : (s.erase x).Nonempty) : (s.erase x).min' s0 ≠ x :=\n  ne_of_mem_erase (min'_mem _ s0)\n\n"}
{"name":"Finset.max_erase_ne_self","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\nx : α\ns : Finset α\n⊢ Ne (s.erase x).max ↑x","decl":"theorem max_erase_ne_self {s : Finset α} : (s.erase x).max ≠ x := by\n  by_cases s0 : (s.erase x).Nonempty\n  · refine ne_of_eq_of_ne (coe_max' s0).symm ?_\n    exact WithBot.coe_eq_coe.not.mpr (max'_erase_ne_self _)\n  · rw [not_nonempty_iff_eq_empty.mp s0, max_empty]\n    exact WithBot.bot_ne_coe\n\n"}
{"name":"Finset.min_erase_ne_self","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\nx : α\ns : Finset α\n⊢ Ne (s.erase x).min ↑x","decl":"theorem min_erase_ne_self {s : Finset α} : (s.erase x).min ≠ x := by\n  -- Porting note: old proof `convert @max_erase_ne_self αᵒᵈ _ _ _`\n  convert @max_erase_ne_self αᵒᵈ _ (toDual x) (s.map toDual.toEmbedding) using 1\n  apply congr_arg -- Porting note: forces unfolding to see `Finset.min` is `Finset.max`\n  congr!\n  ext; simp only [mem_map_equiv]; exact Iff.rfl\n\n"}
{"name":"Finset.exists_next_right","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\nx : α\ns : Finset α\nh : Exists fun y => And (Membership.mem s y) (LT.lt x y)\n⊢ Exists fun y => And (Membership.mem s y) (And (LT.lt x y) (∀ (z : α), Membership.mem s z → LT.lt x z → LE.le y z))","decl":"theorem exists_next_right {x : α} {s : Finset α} (h : ∃ y ∈ s, x < y) :\n    ∃ y ∈ s, x < y ∧ ∀ z ∈ s, x < z → y ≤ z :=\n  have Hne : (s.filter (x < ·)).Nonempty := h.imp fun y hy => mem_filter.2 (by simpa)\n  have aux := mem_filter.1 (min'_mem _ Hne)\n  ⟨min' _ Hne, aux.1, by simp, fun z hzs hz => min'_le _ _ <| mem_filter.2 ⟨hzs, by simpa⟩⟩\n\n"}
{"name":"Finset.exists_next_left","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\nx : α\ns : Finset α\nh : Exists fun y => And (Membership.mem s y) (LT.lt y x)\n⊢ Exists fun y => And (Membership.mem s y) (And (LT.lt y x) (∀ (z : α), Membership.mem s z → LT.lt z x → LE.le z y))","decl":"theorem exists_next_left {x : α} {s : Finset α} (h : ∃ y ∈ s, y < x) :\n    ∃ y ∈ s, y < x ∧ ∀ z ∈ s, z < x → z ≤ y :=\n  @exists_next_right αᵒᵈ _ x s h\n\n"}
{"name":"Finset.card_le_of_interleaved","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ns t : Finset α\nh : ∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem s y → LT.lt x y → (∀ (z : α), Membership.mem s z → Not (Membership.mem (Set.Ioo x y) z)) → Exists fun z => And (Membership.mem t z) (And (LT.lt x z) (LT.lt z y))\n⊢ LE.le s.card (HAdd.hAdd t.card 1)","decl":"/-- If finsets `s` and `t` are interleaved, then `Finset.card s ≤ Finset.card t + 1`. -/\ntheorem card_le_of_interleaved {s t : Finset α}\n    (h : ∀ᵉ (x ∈ s) (y ∈ s),\n        x < y → (∀ z ∈ s, z ∉ Set.Ioo x y) → ∃ z ∈ t, x < z ∧ z < y) :\n    s.card ≤ t.card + 1 := by\n  replace h : ∀ᵉ (x ∈ s) (y ∈ s), x < y → ∃ z ∈ t, x < z ∧ z < y := by\n    intro x hx y hy hxy\n    rcases exists_next_right ⟨y, hy, hxy⟩ with ⟨a, has, hxa, ha⟩\n    rcases h x hx a has hxa fun z hzs hz => hz.2.not_le <| ha _ hzs hz.1 with ⟨b, hbt, hxb, hba⟩\n    exact ⟨b, hbt, hxb, hba.trans_le <| ha _ hy hxy⟩\n  set f : α → WithTop α := fun x => (t.filter fun y => x < y).min\n  have f_mono : StrictMonoOn f s := by\n    intro x hx y hy hxy\n    rcases h x hx y hy hxy with ⟨a, hat, hxa, hay⟩\n    calc\n      f x ≤ a := min_le (mem_filter.2 ⟨hat, by simpa⟩)\n      _ < f y :=\n        (Finset.lt_inf_iff <| WithTop.coe_lt_top a).2 fun b hb =>\n          WithTop.coe_lt_coe.2 <| hay.trans (by simpa using (mem_filter.1 hb).2)\n\n  calc\n    s.card = (s.image f).card := (card_image_of_injOn f_mono.injOn).symm\n    _ ≤ (insert ⊤ (t.image (↑)) : Finset (WithTop α)).card :=\n      card_mono <| image_subset_iff.2 fun x _ =>\n          insert_subset_insert _ (image_subset_image <| filter_subset _ _)\n            (min_mem_insert_top_image_coe _)\n    _ ≤ t.card + 1 := (card_insert_le _ _).trans (Nat.add_le_add_right card_image_le _)\n\n"}
{"name":"Finset.card_le_diff_of_interleaved","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ns t : Finset α\nh : ∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem s y → LT.lt x y → (∀ (z : α), Membership.mem s z → Not (Membership.mem (Set.Ioo x y) z)) → Exists fun z => And (Membership.mem t z) (And (LT.lt x z) (LT.lt z y))\n⊢ LE.le s.card (HAdd.hAdd (SDiff.sdiff t s).card 1)","decl":"/-- If finsets `s` and `t` are interleaved, then `Finset.card s ≤ Finset.card (t \\ s) + 1`. -/\ntheorem card_le_diff_of_interleaved {s t : Finset α}\n    (h :\n      ∀ᵉ (x ∈ s) (y ∈ s),\n        x < y → (∀ z ∈ s, z ∉ Set.Ioo x y) → ∃ z ∈ t, x < z ∧ z < y) :\n    s.card ≤ (t \\ s).card + 1 :=\n  card_le_of_interleaved fun x hx y hy hxy hs =>\n    let ⟨z, hzt, hxz, hzy⟩ := h x hx y hy hxy hs\n    ⟨z, mem_sdiff.2 ⟨hzt, fun hzs => hs z hzs ⟨hxz, hzy⟩⟩, hxz, hzy⟩\n\n"}
{"name":"Finset.induction_on_max","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrder α\ninst✝ : DecidableEq α\np : Finset α → Prop\ns : Finset α\nh0 : p EmptyCollection.emptyCollection\nstep : ∀ (a : α) (s : Finset α), (∀ (x : α), Membership.mem s x → LT.lt x a) → p s → p (Insert.insert a s)\n⊢ p s","decl":"/-- Induction principle for `Finset`s in a linearly ordered type: a predicate is true on all\n`s : Finset α` provided that:\n\n* it is true on the empty `Finset`,\n* for every `s : Finset α` and an element `a` strictly greater than all elements of `s`, `p s`\n  implies `p (insert a s)`. -/\n@[elab_as_elim]\ntheorem induction_on_max [DecidableEq α] {p : Finset α → Prop} (s : Finset α) (h0 : p ∅)\n    (step : ∀ a s, (∀ x ∈ s, x < a) → p s → p (insert a s)) : p s := by\n  induction' s using Finset.strongInductionOn with s ihs\n  rcases s.eq_empty_or_nonempty with (rfl | hne)\n  · exact h0\n  · have H : s.max' hne ∈ s := max'_mem s hne\n    rw [← insert_erase H]\n    exact step _ _ (fun x => s.lt_max'_of_mem_erase_max' hne) (ihs _ <| erase_ssubset H)\n\n"}
{"name":"Finset.induction_on_min","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrder α\ninst✝ : DecidableEq α\np : Finset α → Prop\ns : Finset α\nh0 : p EmptyCollection.emptyCollection\nstep : ∀ (a : α) (s : Finset α), (∀ (x : α), Membership.mem s x → LT.lt a x) → p s → p (Insert.insert a s)\n⊢ p s","decl":"/-- Induction principle for `Finset`s in a linearly ordered type: a predicate is true on all\n`s : Finset α` provided that:\n\n* it is true on the empty `Finset`,\n* for every `s : Finset α` and an element `a` strictly less than all elements of `s`, `p s`\n  implies `p (insert a s)`. -/\n@[elab_as_elim]\ntheorem induction_on_min [DecidableEq α] {p : Finset α → Prop} (s : Finset α) (h0 : p ∅)\n    (step : ∀ a s, (∀ x ∈ s, a < x) → p s → p (insert a s)) : p s :=\n  @induction_on_max αᵒᵈ _ _ _ s h0 step\n\n"}
{"name":"Finset.induction_on_max_value","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\nι : Type u_5\ninst✝¹ : LinearOrder α\ninst✝ : DecidableEq ι\nf : ι → α\np : Finset ι → Prop\ns : Finset ι\nh0 : p EmptyCollection.emptyCollection\nstep : ∀ (a : ι) (s : Finset ι), Not (Membership.mem s a) → (∀ (x : ι), Membership.mem s x → LE.le (f x) (f a)) → p s → p (Insert.insert a s)\n⊢ p s","decl":"/-- Induction principle for `Finset`s in any type from which a given function `f` maps to a linearly\nordered type : a predicate is true on all `s : Finset α` provided that:\n\n* it is true on the empty `Finset`,\n* for every `s : Finset α` and an element `a` such that for elements of `s` denoted by `x` we have\n  `f x ≤ f a`, `p s` implies `p (insert a s)`. -/\n@[elab_as_elim]\ntheorem induction_on_max_value [DecidableEq ι] (f : ι → α) {p : Finset ι → Prop} (s : Finset ι)\n    (h0 : p ∅) (step : ∀ a s, a ∉ s → (∀ x ∈ s, f x ≤ f a) → p s → p (insert a s)) : p s := by\n  induction' s using Finset.strongInductionOn with s ihs\n  rcases (s.image f).eq_empty_or_nonempty with (hne | hne)\n  · simp only [image_eq_empty] at hne\n    simp only [hne, h0]\n  · have H : (s.image f).max' hne ∈ s.image f := max'_mem (s.image f) hne\n    simp only [mem_image, exists_prop] at H\n    rcases H with ⟨a, has, hfa⟩\n    rw [← insert_erase has]\n    refine step _ _ (not_mem_erase a s) (fun x hx => ?_) (ihs _ <| erase_ssubset has)\n    rw [hfa]\n    exact le_max' _ _ (mem_image_of_mem _ <| mem_of_mem_erase hx)\n\n"}
{"name":"Finset.induction_on_min_value","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\nι : Type u_5\ninst✝¹ : LinearOrder α\ninst✝ : DecidableEq ι\nf : ι → α\np : Finset ι → Prop\ns : Finset ι\nh0 : p EmptyCollection.emptyCollection\nstep : ∀ (a : ι) (s : Finset ι), Not (Membership.mem s a) → (∀ (x : ι), Membership.mem s x → LE.le (f a) (f x)) → p s → p (Insert.insert a s)\n⊢ p s","decl":"/-- Induction principle for `Finset`s in any type from which a given function `f` maps to a linearly\nordered type : a predicate is true on all `s : Finset α` provided that:\n\n* it is true on the empty `Finset`,\n* for every `s : Finset α` and an element `a` such that for elements of `s` denoted by `x` we have\n  `f a ≤ f x`, `p s` implies `p (insert a s)`. -/\n@[elab_as_elim]\ntheorem induction_on_min_value [DecidableEq ι] (f : ι → α) {p : Finset ι → Prop} (s : Finset ι)\n    (h0 : p ∅) (step : ∀ a s, a ∉ s → (∀ x ∈ s, f a ≤ f x) → p s → p (insert a s)) : p s :=\n  @induction_on_max_value αᵒᵈ ι _ _ _ _ s h0 step\n\n"}
{"name":"Finset.exists_max_image","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : LinearOrder α\ns : Finset β\nf : β → α\nh : s.Nonempty\n⊢ Exists fun x => And (Membership.mem s x) (∀ (x' : β), Membership.mem s x' → LE.le (f x') (f x))","decl":"theorem exists_max_image (s : Finset β) (f : β → α) (h : s.Nonempty) :\n    ∃ x ∈ s, ∀ x' ∈ s, f x' ≤ f x := by\n  cases' max_of_nonempty (h.image f) with y hy\n  rcases mem_image.mp (mem_of_max hy) with ⟨x, hx, rfl⟩\n  exact ⟨x, hx, fun x' hx' => le_max_of_eq (mem_image_of_mem f hx') hy⟩\n\n"}
{"name":"Finset.exists_min_image","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : LinearOrder α\ns : Finset β\nf : β → α\nh : s.Nonempty\n⊢ Exists fun x => And (Membership.mem s x) (∀ (x' : β), Membership.mem s x' → LE.le (f x) (f x'))","decl":"theorem exists_min_image (s : Finset β) (f : β → α) (h : s.Nonempty) :\n    ∃ x ∈ s, ∀ x' ∈ s, f x ≤ f x' :=\n  @exists_max_image αᵒᵈ β _ s f h\n\n"}
{"name":"Finset.isGLB_iff_isLeast","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ni : α\ns : Finset α\nhs : s.Nonempty\n⊢ Iff (IsGLB (↑s) i) (IsLeast (↑s) i)","decl":"theorem isGLB_iff_isLeast [LinearOrder α] (i : α) (s : Finset α) (hs : s.Nonempty) :\n    IsGLB (s : Set α) i ↔ IsLeast (↑s) i := by\n  refine ⟨fun his => ?_, IsLeast.isGLB⟩\n  suffices i = min' s hs by\n    rw [this]\n    exact isLeast_min' s hs\n  rw [IsGLB, IsGreatest, mem_lowerBounds, mem_upperBounds] at his\n  exact le_antisymm (his.1 (Finset.min' s hs) (Finset.min'_mem s hs)) (his.2 _ (Finset.min'_le s))\n\n"}
{"name":"Finset.isLUB_iff_isGreatest","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ni : α\ns : Finset α\nhs : s.Nonempty\n⊢ Iff (IsLUB (↑s) i) (IsGreatest (↑s) i)","decl":"theorem isLUB_iff_isGreatest [LinearOrder α] (i : α) (s : Finset α) (hs : s.Nonempty) :\n    IsLUB (s : Set α) i ↔ IsGreatest (↑s) i :=\n  @isGLB_iff_isLeast αᵒᵈ _ i s hs\n\n"}
{"name":"Finset.isGLB_mem","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ni : α\ns : Finset α\nhis : IsGLB (↑s) i\nhs : s.Nonempty\n⊢ Membership.mem s i","decl":"theorem isGLB_mem [LinearOrder α] {i : α} (s : Finset α) (his : IsGLB (s : Set α) i)\n    (hs : s.Nonempty) : i ∈ s := by\n  rw [← mem_coe]\n  exact ((isGLB_iff_isLeast i s hs).mp his).1\n\n"}
{"name":"Finset.isLUB_mem","module":"Mathlib.Data.Finset.Max","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ni : α\ns : Finset α\nhis : IsLUB (↑s) i\nhs : s.Nonempty\n⊢ Membership.mem s i","decl":"theorem isLUB_mem [LinearOrder α] {i : α} (s : Finset α) (his : IsLUB (s : Set α) i)\n    (hs : s.Nonempty) : i ∈ s :=\n  @isGLB_mem αᵒᵈ _ i s his hs\n\n"}
