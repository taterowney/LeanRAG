{"name":"Real.tendsto_sum_pi_div_four","module":"Mathlib.Data.Real.Pi.Leibniz","initialProofState":"âŠ¢ Filter.Tendsto (fun k => (Finset.range k).sum fun i => HDiv.hDiv (HPow.hPow (-1) i) (HAdd.hAdd (HMul.hMul 2 â†‘i) 1)) Filter.atTop (nhds (HDiv.hDiv Real.pi 4))","decl":"/-- **Leibniz's series for `Ï€`**. The alternating sum of odd number reciprocals is `Ï€ / 4`,\nproved by using Abel's limit theorem to extend the Maclaurin series of `arctan` to 1. -/\ntheorem tendsto_sum_pi_div_four :\n    Tendsto (fun k => âˆ‘ i âˆˆ range k, (-1 : â„) ^ i / (2 * i + 1)) atTop (ğ“ (Ï€ / 4)) := by\n  -- The series is alternating with terms of decreasing magnitude, so it converges to some limit\n  obtain âŸ¨l, hâŸ© :\n      âˆƒ l, Tendsto (fun n â†¦ âˆ‘ i âˆˆ range n, (-1 : â„) ^ i / (2 * i + 1)) atTop (ğ“ l) := by\n    apply Antitone.tendsto_alternating_series_of_tendsto_zero\n    Â· exact antitone_iff_forall_lt.mpr fun _ _ _ â†¦ by gcongr\n    Â· apply Tendsto.inv_tendsto_atTop; apply tendsto_atTop_add_const_right\n      exact tendsto_natCast_atTop_atTop.const_mul_atTop zero_lt_two\n  -- Abel's limit theorem states that the corresponding power series has the same limit as `x â†’ 1â»`\n  have abel := tendsto_tsum_powerSeries_nhdsWithin_lt h\n  -- Massage the expression to get `x ^ (2 * n + 1)` in the tsum rather than `x ^ n`...\n  have m : ğ“[<] (1 : â„) â‰¤ ğ“ 1 := tendsto_nhdsWithin_of_tendsto_nhds fun _ a â†¦ a\n  have q : Tendsto (fun x : â„ â†¦ x ^ 2) (ğ“[<] 1) (ğ“[<] 1) := by\n    apply tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within\n    Â· nth_rw 3 [â† one_pow 2]\n      exact Tendsto.pow â€¹_â€º _\n    Â· rw [eventually_iff_exists_mem]\n      use Set.Ioo (-1) 1\n      exact âŸ¨Ioo_mem_nhdsLT <| by simp,\n        fun _ _ â†¦ by rwa [Set.mem_Iio, sq_lt_one_iff_abs_lt_one, abs_lt, â† Set.mem_Ioo]âŸ©\n  replace abel := (abel.comp q).mul m\n  rw [mul_one] at abel\n  -- ...so that we can replace the tsum with the real arctangent function\n  replace abel : Tendsto arctan (ğ“[<] 1) (ğ“ l) := by\n    apply abel.congr'\n    rw [eventuallyEq_nhdsWithin_iff, Metric.eventually_nhds_iff]\n    use 1, zero_lt_one\n    intro y hy1 hy2\n    rw [dist_eq, abs_sub_lt_iff] at hy1\n    rw [Set.mem_Iio] at hy2\n    have ny : â€–yâ€– < 1 := by rw [norm_eq_abs, abs_lt]; constructor <;> linarith\n    rw [â† (hasSum_arctan ny).tsum_eq, Function.comp_apply, â† tsum_mul_right]\n    simp_rw [mul_assoc, â† pow_mul, â† pow_succ, div_mul_eq_mul_div]\n    norm_cast\n  -- But `arctan` is continuous everywhere, so the limit is `arctan 1 = Ï€ / 4`\n  rwa [tendsto_nhds_unique abel ((continuous_arctan.tendsto 1).mono_left m), arctan_one] at h\n\n"}
