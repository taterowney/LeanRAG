{"name":"Polynomial.X_dvd_iff","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝ : Semiring R\nf : Polynomial R\n⊢ Iff (Dvd.dvd Polynomial.X f) (Eq (f.coeff 0) 0)","decl":"theorem X_dvd_iff {f : R[X]} : X ∣ f ↔ f.coeff 0 = 0 :=\n  ⟨fun ⟨g, hfg⟩ => by rw [hfg, coeff_X_mul_zero], fun hf =>\n    ⟨f.divX, by rw [← add_zero (X * f.divX), ← C_0, ← hf, X_mul_divX_add]⟩⟩\n\n"}
{"name":"Polynomial.X_pow_dvd_iff","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝ : Semiring R\nf : Polynomial R\nn : Nat\n⊢ Iff (Dvd.dvd (HPow.hPow Polynomial.X n) f) (∀ (d : Nat), LT.lt d n → Eq (f.coeff d) 0)","decl":"theorem X_pow_dvd_iff {f : R[X]} {n : ℕ} : X ^ n ∣ f ↔ ∀ d < n, f.coeff d = 0 :=\n  ⟨fun ⟨g, hgf⟩ d hd => by\n    simp only [hgf, coeff_X_pow_mul', ite_eq_right_iff, not_le_of_lt hd, IsEmpty.forall_iff],\n    fun hd => by\n    induction n with\n    | zero => simp [pow_zero, one_dvd]\n    | succ n hn =>\n      obtain ⟨g, hgf⟩ := hn fun d : ℕ => fun H : d < n => hd _ (Nat.lt_succ_of_lt H)\n      have := coeff_X_pow_mul g n 0\n      rw [zero_add, ← hgf, hd n (Nat.lt_succ_self n)] at this\n      obtain ⟨k, hgk⟩ := Polynomial.X_dvd_iff.mpr this.symm\n      use k\n      rwa [pow_succ, mul_assoc, ← hgk]⟩\n\n"}
{"name":"Polynomial.finiteMultiplicity_of_degree_pos_of_monic","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝ : Semiring R\np q : Polynomial R\nhp : LT.lt 0 p.degree\nhmp : p.Monic\nhq : Ne q 0\n⊢ FiniteMultiplicity p q","decl":"theorem finiteMultiplicity_of_degree_pos_of_monic (hp : (0 : WithBot ℕ) < degree p) (hmp : Monic p)\n    (hq : q ≠ 0) : FiniteMultiplicity p q :=\n  have zn0 : (0 : R) ≠ 1 :=\n    haveI := Nontrivial.of_polynomial_ne hq\n    zero_ne_one\n  ⟨natDegree q, fun ⟨r, hr⟩ => by\n    have hp0 : p ≠ 0 := fun hp0 => by simp [hp0] at hp\n    have hr0 : r ≠ 0 := fun hr0 => by subst hr0; simp [hq] at hr\n    have hpn1 : leadingCoeff p ^ (natDegree q + 1) = 1 := by simp [show _ = _ from hmp]\n    have hpn0' : leadingCoeff p ^ (natDegree q + 1) ≠ 0 := hpn1.symm ▸ zn0.symm\n    have hpnr0 : leadingCoeff (p ^ (natDegree q + 1)) * leadingCoeff r ≠ 0 := by\n      simp only [leadingCoeff_pow' hpn0', leadingCoeff_eq_zero, hpn1, one_pow, one_mul, Ne,\n          hr0, not_false_eq_true]\n    have hnp : 0 < natDegree p := Nat.cast_lt.1 <| by\n      rw [← degree_eq_natDegree hp0]; exact hp\n    have := congr_arg natDegree hr\n    rw [natDegree_mul' hpnr0, natDegree_pow' hpn0', add_mul, add_assoc] at this\n    exact\n      ne_of_lt\n        (lt_add_of_le_of_pos (le_mul_of_one_le_right (Nat.zero_le _) hnp)\n          (add_pos_of_pos_of_nonneg (by rwa [one_mul]) (Nat.zero_le _)))\n        this⟩\n\n"}
{"name":"Polynomial.multiplicity_finite_of_degree_pos_of_monic","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝ : Semiring R\np q : Polynomial R\nhp : LT.lt 0 p.degree\nhmp : p.Monic\nhq : Ne q 0\n⊢ FiniteMultiplicity p q","decl":"@[deprecated (since := \"2024-11-30\")]\nalias multiplicity_finite_of_degree_pos_of_monic := finiteMultiplicity_of_degree_pos_of_monic\n\n"}
{"name":"Polynomial.div_wf_lemma","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝ : Ring R\np q : Polynomial R\nh : And (LE.le q.degree p.degree) (Ne p 0)\nhq : q.Monic\n⊢ LT.lt (HSub.hSub p (HMul.hMul q (HMul.hMul (Polynomial.C p.leadingCoeff) (HPow.hPow Polynomial.X (HSub.hSub p.natDegree q.natDegree))))).degree p.degree","decl":"theorem div_wf_lemma (h : degree q ≤ degree p ∧ p ≠ 0) (hq : Monic q) :\n    degree (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) < degree p :=\n  have hp : leadingCoeff p ≠ 0 := mt leadingCoeff_eq_zero.1 h.2\n  have hq0 : q ≠ 0 := hq.ne_zero_of_polynomial_ne h.2\n  have hlt : natDegree q ≤ natDegree p :=\n    (Nat.cast_le (α := WithBot ℕ)).1\n      (by rw [← degree_eq_natDegree h.2, ← degree_eq_natDegree hq0]; exact h.1)\n  degree_sub_lt\n    (by\n      rw [hq.degree_mul_comm, hq.degree_mul, degree_C_mul_X_pow _ hp, degree_eq_natDegree h.2,\n        degree_eq_natDegree hq0, ← Nat.cast_add, tsub_add_cancel_of_le hlt])\n    h.2 (by rw [leadingCoeff_monic_mul hq, leadingCoeff_mul_X_pow, leadingCoeff_C])\n\n"}
{"name":"Polynomial.degree_modByMonic_lt","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝¹ : Ring R\ninst✝ : Nontrivial R\np q : Polynomial R\n_hq : q.Monic\n⊢ LT.lt (p.modByMonic q).degree q.degree","decl":"theorem degree_modByMonic_lt [Nontrivial R] :\n    ∀ (p : R[X]) {q : R[X]} (_hq : Monic q), degree (p %ₘ q) < degree q\n  | p, q, hq =>\n    letI := Classical.decEq R\n    if h : degree q ≤ degree p ∧ p ≠ 0 then by\n      have _wf := div_wf_lemma ⟨h.1, h.2⟩ hq\n      have :=\n        degree_modByMonic_lt (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) hq\n      unfold modByMonic at this ⊢\n      unfold divModByMonicAux\n      dsimp\n      rw [dif_pos hq] at this ⊢\n      rw [if_pos h]\n      exact this\n    else\n      Or.casesOn (not_and_or.1 h)\n        (by\n          unfold modByMonic divModByMonicAux\n          dsimp\n          rw [dif_pos hq, if_neg h]\n          exact lt_of_not_ge)\n        (by\n          intro hp\n          unfold modByMonic divModByMonicAux\n          dsimp\n          rw [dif_pos hq, if_neg h, Classical.not_not.1 hp]\n          exact lt_of_le_of_ne bot_le (Ne.symm (mt degree_eq_bot.1 hq.ne_zero)))\n  termination_by p => p\n\n"}
{"name":"Polynomial.natDegree_modByMonic_lt","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝ : Ring R\np q : Polynomial R\nhmq : q.Monic\nhq : Ne q 1\n⊢ LT.lt (p.modByMonic q).natDegree q.natDegree","decl":"theorem natDegree_modByMonic_lt (p : R[X]) {q : R[X]} (hmq : Monic q) (hq : q ≠ 1) :\n    natDegree (p %ₘ q) < q.natDegree := by\n  by_cases hpq : p %ₘ q = 0\n  · rw [hpq, natDegree_zero, Nat.pos_iff_ne_zero]\n    contrapose! hq\n    exact eq_one_of_monic_natDegree_zero hmq hq\n  · haveI := Nontrivial.of_polynomial_ne hpq\n    exact natDegree_lt_natDegree hpq (degree_modByMonic_lt p hmq)\n\n"}
{"name":"Polynomial.zero_modByMonic","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝ : Ring R\np : Polynomial R\n⊢ Eq (Polynomial.modByMonic 0 p) 0","decl":"@[simp]\ntheorem zero_modByMonic (p : R[X]) : 0 %ₘ p = 0 := by\n  classical\n  unfold modByMonic divModByMonicAux\n  dsimp\n  by_cases hp : Monic p\n  · rw [dif_pos hp, if_neg (mt And.right (not_not_intro rfl)), Prod.snd_zero]\n  · rw [dif_neg hp]\n\n"}
{"name":"Polynomial.zero_divByMonic","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝ : Ring R\np : Polynomial R\n⊢ Eq (Polynomial.divByMonic 0 p) 0","decl":"@[simp]\ntheorem zero_divByMonic (p : R[X]) : 0 /ₘ p = 0 := by\n  classical\n  unfold divByMonic divModByMonicAux\n  dsimp\n  by_cases hp : Monic p\n  · rw [dif_pos hp, if_neg (mt And.right (not_not_intro rfl)), Prod.fst_zero]\n  · rw [dif_neg hp]\n\n"}
{"name":"Polynomial.modByMonic_zero","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝ : Ring R\np : Polynomial R\n⊢ Eq (p.modByMonic 0) p","decl":"@[simp]\ntheorem modByMonic_zero (p : R[X]) : p %ₘ 0 = p :=\n  letI := Classical.decEq R\n  if h : Monic (0 : R[X]) then by\n    haveI := monic_zero_iff_subsingleton.mp h\n    simp [eq_iff_true_of_subsingleton]\n  else by unfold modByMonic divModByMonicAux; rw [dif_neg h]\n\n"}
{"name":"Polynomial.divByMonic_zero","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝ : Ring R\np : Polynomial R\n⊢ Eq (p.divByMonic 0) 0","decl":"@[simp]\ntheorem divByMonic_zero (p : R[X]) : p /ₘ 0 = 0 :=\n  letI := Classical.decEq R\n  if h : Monic (0 : R[X]) then by\n    haveI := monic_zero_iff_subsingleton.mp h\n    simp [eq_iff_true_of_subsingleton]\n  else by unfold divByMonic divModByMonicAux; rw [dif_neg h]\n\n"}
{"name":"Polynomial.divByMonic_eq_of_not_monic","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝ : Ring R\nq p : Polynomial R\nhq : Not q.Monic\n⊢ Eq (p.divByMonic q) 0","decl":"theorem divByMonic_eq_of_not_monic (p : R[X]) (hq : ¬Monic q) : p /ₘ q = 0 :=\n  dif_neg hq\n\n"}
{"name":"Polynomial.modByMonic_eq_of_not_monic","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝ : Ring R\nq p : Polynomial R\nhq : Not q.Monic\n⊢ Eq (p.modByMonic q) p","decl":"theorem modByMonic_eq_of_not_monic (p : R[X]) (hq : ¬Monic q) : p %ₘ q = p :=\n  dif_neg hq\n\n"}
{"name":"Polynomial.modByMonic_eq_self_iff","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝¹ : Ring R\np q : Polynomial R\ninst✝ : Nontrivial R\nhq : q.Monic\n⊢ Iff (Eq (p.modByMonic q) p) (LT.lt p.degree q.degree)","decl":"theorem modByMonic_eq_self_iff [Nontrivial R] (hq : Monic q) : p %ₘ q = p ↔ degree p < degree q :=\n  ⟨fun h => h ▸ degree_modByMonic_lt _ hq, fun h => by\n    classical\n    have : ¬degree q ≤ degree p := not_le_of_gt h\n    unfold modByMonic divModByMonicAux; dsimp; rw [dif_pos hq, if_neg (mt And.left this)]⟩\n\n"}
{"name":"Polynomial.degree_modByMonic_le","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝ : Ring R\np q : Polynomial R\nhq : q.Monic\n⊢ LE.le (p.modByMonic q).degree q.degree","decl":"theorem degree_modByMonic_le (p : R[X]) {q : R[X]} (hq : Monic q) : degree (p %ₘ q) ≤ degree q := by\n  nontriviality R\n  exact (degree_modByMonic_lt _ hq).le\n\n"}
{"name":"Polynomial.degree_modByMonic_le_left","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝ : Ring R\np q : Polynomial R\n⊢ LE.le (p.modByMonic q).degree p.degree","decl":"theorem degree_modByMonic_le_left : degree (p %ₘ q) ≤ degree p := by\n  nontriviality R\n  by_cases hq : q.Monic\n  · cases lt_or_ge (degree p) (degree q)\n    · rw [(modByMonic_eq_self_iff hq).mpr ‹_›]\n    · exact (degree_modByMonic_le p hq).trans ‹_›\n  · rw [modByMonic_eq_of_not_monic p hq]\n\n"}
{"name":"Polynomial.natDegree_modByMonic_le","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝ : Ring R\np g : Polynomial R\nhg : g.Monic\n⊢ LE.le (p.modByMonic g).natDegree g.natDegree","decl":"theorem natDegree_modByMonic_le (p : Polynomial R) {g : Polynomial R} (hg : g.Monic) :\n    natDegree (p %ₘ g) ≤ g.natDegree :=\n  natDegree_le_natDegree (degree_modByMonic_le p hg)\n\n"}
{"name":"Polynomial.natDegree_modByMonic_le_left","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝ : Ring R\np q : Polynomial R\n⊢ LE.le (p.modByMonic q).natDegree p.natDegree","decl":"theorem natDegree_modByMonic_le_left : natDegree (p %ₘ q) ≤ natDegree p :=\n  natDegree_le_natDegree degree_modByMonic_le_left\n\n"}
{"name":"Polynomial.X_dvd_sub_C","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝ : Ring R\np : Polynomial R\n⊢ Dvd.dvd Polynomial.X (HSub.hSub p (Polynomial.C (p.coeff 0)))","decl":"theorem X_dvd_sub_C : X ∣ p - C (p.coeff 0) := by\n  simp [X_dvd_iff, coeff_C]\n\n"}
{"name":"Polynomial.modByMonic_eq_sub_mul_div","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝ : Ring R\np q : Polynomial R\n_hq : q.Monic\n⊢ Eq (p.modByMonic q) (HSub.hSub p (HMul.hMul q (p.divByMonic q)))","decl":"theorem modByMonic_eq_sub_mul_div :\n    ∀ (p : R[X]) {q : R[X]} (_hq : Monic q), p %ₘ q = p - q * (p /ₘ q)\n  | p, q, hq =>\n    letI := Classical.decEq R\n    if h : degree q ≤ degree p ∧ p ≠ 0 then by\n      have _wf := div_wf_lemma h hq\n      have ih := modByMonic_eq_sub_mul_div\n        (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) hq\n      unfold modByMonic divByMonic divModByMonicAux\n      dsimp\n      rw [dif_pos hq, if_pos h]\n      rw [modByMonic, dif_pos hq] at ih\n      refine ih.trans ?_\n      unfold divByMonic\n      rw [dif_pos hq, dif_pos hq, if_pos h, mul_add, sub_add_eq_sub_sub]\n    else by\n      unfold modByMonic divByMonic divModByMonicAux\n      dsimp\n      rw [dif_pos hq, if_neg h, dif_pos hq, if_neg h, mul_zero, sub_zero]\n  termination_by p => p\n\n"}
{"name":"Polynomial.modByMonic_add_div","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝ : Ring R\np q : Polynomial R\nhq : q.Monic\n⊢ Eq (HAdd.hAdd (p.modByMonic q) (HMul.hMul q (p.divByMonic q))) p","decl":"theorem modByMonic_add_div (p : R[X]) {q : R[X]} (hq : Monic q) : p %ₘ q + q * (p /ₘ q) = p :=\n  eq_sub_iff_add_eq.1 (modByMonic_eq_sub_mul_div p hq)\n\n"}
{"name":"Polynomial.divByMonic_eq_zero_iff","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝¹ : Ring R\np q : Polynomial R\ninst✝ : Nontrivial R\nhq : q.Monic\n⊢ Iff (Eq (p.divByMonic q) 0) (LT.lt p.degree q.degree)","decl":"theorem divByMonic_eq_zero_iff [Nontrivial R] (hq : Monic q) : p /ₘ q = 0 ↔ degree p < degree q :=\n  ⟨fun h => by\n    have := modByMonic_add_div p hq\n    rwa [h, mul_zero, add_zero, modByMonic_eq_self_iff hq] at this,\n  fun h => by\n    classical\n    have : ¬degree q ≤ degree p := not_le_of_gt h\n    unfold divByMonic divModByMonicAux; dsimp; rw [dif_pos hq, if_neg (mt And.left this)]⟩\n\n"}
{"name":"Polynomial.degree_add_divByMonic","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝ : Ring R\np q : Polynomial R\nhq : q.Monic\nh : LE.le q.degree p.degree\n⊢ Eq (HAdd.hAdd q.degree (p.divByMonic q).degree) p.degree","decl":"theorem degree_add_divByMonic (hq : Monic q) (h : degree q ≤ degree p) :\n    degree q + degree (p /ₘ q) = degree p := by\n  nontriviality R\n  have hdiv0 : p /ₘ q ≠ 0 := by rwa [Ne, divByMonic_eq_zero_iff hq, not_lt]\n  have hlc : leadingCoeff q * leadingCoeff (p /ₘ q) ≠ 0 := by\n    rwa [Monic.def.1 hq, one_mul, Ne, leadingCoeff_eq_zero]\n  have hmod : degree (p %ₘ q) < degree (q * (p /ₘ q)) :=\n    calc\n      degree (p %ₘ q) < degree q := degree_modByMonic_lt _ hq\n      _ ≤ _ := by\n        rw [degree_mul' hlc, degree_eq_natDegree hq.ne_zero, degree_eq_natDegree hdiv0, ←\n            Nat.cast_add, Nat.cast_le]\n        exact Nat.le_add_right _ _\n  calc\n    degree q + degree (p /ₘ q) = degree (q * (p /ₘ q)) := Eq.symm (degree_mul' hlc)\n    _ = degree (p %ₘ q + q * (p /ₘ q)) := (degree_add_eq_right_of_degree_lt hmod).symm\n    _ = _ := congr_arg _ (modByMonic_add_div _ hq)\n\n"}
{"name":"Polynomial.degree_divByMonic_le","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝ : Ring R\np q : Polynomial R\n⊢ LE.le (p.divByMonic q).degree p.degree","decl":"theorem degree_divByMonic_le (p q : R[X]) : degree (p /ₘ q) ≤ degree p :=\n  letI := Classical.decEq R\n  if hp0 : p = 0 then by simp only [hp0, zero_divByMonic, le_refl]\n  else\n    if hq : Monic q then\n      if h : degree q ≤ degree p then by\n        haveI := Nontrivial.of_polynomial_ne hp0\n        rw [← degree_add_divByMonic hq h, degree_eq_natDegree hq.ne_zero,\n          degree_eq_natDegree (mt (divByMonic_eq_zero_iff hq).1 (not_lt.2 h))]\n        exact WithBot.coe_le_coe.2 (Nat.le_add_left _ _)\n      else by\n        unfold divByMonic divModByMonicAux\n        simp [dif_pos hq, h, if_false, degree_zero, bot_le]\n    else (divByMonic_eq_of_not_monic p hq).symm ▸ bot_le\n\n"}
{"name":"Polynomial.degree_divByMonic_lt","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝ : Ring R\np q : Polynomial R\nhq : q.Monic\nhp0 : Ne p 0\nh0q : LT.lt 0 q.degree\n⊢ LT.lt (p.divByMonic q).degree p.degree","decl":"theorem degree_divByMonic_lt (p : R[X]) {q : R[X]} (hq : Monic q) (hp0 : p ≠ 0)\n    (h0q : 0 < degree q) : degree (p /ₘ q) < degree p :=\n  if hpq : degree p < degree q then by\n    haveI := Nontrivial.of_polynomial_ne hp0\n    rw [(divByMonic_eq_zero_iff hq).2 hpq, degree_eq_natDegree hp0]\n    exact WithBot.bot_lt_coe _\n  else by\n    haveI := Nontrivial.of_polynomial_ne hp0\n    rw [← degree_add_divByMonic hq (not_lt.1 hpq), degree_eq_natDegree hq.ne_zero,\n      degree_eq_natDegree (mt (divByMonic_eq_zero_iff hq).1 hpq)]\n    exact\n      Nat.cast_lt.2\n        (Nat.lt_add_of_pos_left (Nat.cast_lt.1 <|\n          by simpa [degree_eq_natDegree hq.ne_zero] using h0q))\n\n"}
{"name":"Polynomial.natDegree_divByMonic","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝ : Ring R\nf g : Polynomial R\nhg : g.Monic\n⊢ Eq (f.divByMonic g).natDegree (HSub.hSub f.natDegree g.natDegree)","decl":"theorem natDegree_divByMonic (f : R[X]) {g : R[X]} (hg : g.Monic) :\n    natDegree (f /ₘ g) = natDegree f - natDegree g := by\n  nontriviality R\n  by_cases hfg : f /ₘ g = 0\n  · rw [hfg, natDegree_zero]\n    rw [divByMonic_eq_zero_iff hg] at hfg\n    rw [tsub_eq_zero_iff_le.mpr (natDegree_le_natDegree <| le_of_lt hfg)]\n  have hgf := hfg\n  rw [divByMonic_eq_zero_iff hg] at hgf\n  push_neg at hgf\n  have := degree_add_divByMonic hg hgf\n  have hf : f ≠ 0 := by\n    intro hf\n    apply hfg\n    rw [hf, zero_divByMonic]\n  rw [degree_eq_natDegree hf, degree_eq_natDegree hg.ne_zero, degree_eq_natDegree hfg,\n    ← Nat.cast_add, Nat.cast_inj] at this\n  rw [← this, add_tsub_cancel_left]\n\n"}
{"name":"Polynomial.div_modByMonic_unique","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝ : Ring R\nf g q r : Polynomial R\nhg : g.Monic\nh : And (Eq (HAdd.hAdd r (HMul.hMul g q)) f) (LT.lt r.degree g.degree)\n⊢ And (Eq (f.divByMonic g) q) (Eq (f.modByMonic g) r)","decl":"theorem div_modByMonic_unique {f g} (q r : R[X]) (hg : Monic g)\n    (h : r + g * q = f ∧ degree r < degree g) : f /ₘ g = q ∧ f %ₘ g = r := by\n  nontriviality R\n  have h₁ : r - f %ₘ g = -g * (q - f /ₘ g) :=\n    eq_of_sub_eq_zero\n      (by\n        rw [← sub_eq_zero_of_eq (h.1.trans (modByMonic_add_div f hg).symm)]\n        simp [mul_add, mul_comm, sub_eq_add_neg, add_comm, add_left_comm, add_assoc])\n  have h₂ : degree (r - f %ₘ g) = degree (g * (q - f /ₘ g)) := by simp [h₁]\n  have h₄ : degree (r - f %ₘ g) < degree g :=\n    calc\n      degree (r - f %ₘ g) ≤ max (degree r) (degree (f %ₘ g)) := degree_sub_le _ _\n      _ < degree g := max_lt_iff.2 ⟨h.2, degree_modByMonic_lt _ hg⟩\n  have h₅ : q - f /ₘ g = 0 :=\n    _root_.by_contradiction fun hqf =>\n      not_le_of_gt h₄ <|\n        calc\n          degree g ≤ degree g + degree (q - f /ₘ g) := by\n            erw [degree_eq_natDegree hg.ne_zero, degree_eq_natDegree hqf, WithBot.coe_le_coe]\n            exact Nat.le_add_right _ _\n          _ = degree (r - f %ₘ g) := by rw [h₂, degree_mul']; simpa [Monic.def.1 hg]\n  exact ⟨Eq.symm <| eq_of_sub_eq_zero h₅, Eq.symm <| eq_of_sub_eq_zero <| by simpa [h₅] using h₁⟩\n\n"}
{"name":"Polynomial.map_mod_divByMonic","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\np q : Polynomial R\ninst✝ : Ring S\nf : RingHom R S\nhq : q.Monic\n⊢ And (Eq (Polynomial.map f (p.divByMonic q)) ((Polynomial.map f p).divByMonic (Polynomial.map f q))) (Eq (Polynomial.map f (p.modByMonic q)) ((Polynomial.map f p).modByMonic (Polynomial.map f q)))","decl":"theorem map_mod_divByMonic [Ring S] (f : R →+* S) (hq : Monic q) :\n    (p /ₘ q).map f = p.map f /ₘ q.map f ∧ (p %ₘ q).map f = p.map f %ₘ q.map f := by\n  nontriviality S\n  haveI : Nontrivial R := f.domain_nontrivial\n  have : map f p /ₘ map f q = map f (p /ₘ q) ∧ map f p %ₘ map f q = map f (p %ₘ q) :=\n    div_modByMonic_unique ((p /ₘ q).map f) _ (hq.map f)\n      ⟨Eq.symm <| by rw [← Polynomial.map_mul, ← Polynomial.map_add, modByMonic_add_div _ hq],\n        calc\n          _ ≤ degree (p %ₘ q) := degree_map_le\n          _ < degree q := degree_modByMonic_lt _ hq\n          _ = _ :=\n            Eq.symm <|\n              degree_map_eq_of_leadingCoeff_ne_zero _\n                (by rw [Monic.def.1 hq, f.map_one]; exact one_ne_zero)⟩\n  exact ⟨this.1.symm, this.2.symm⟩\n\n"}
{"name":"Polynomial.map_divByMonic","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\np q : Polynomial R\ninst✝ : Ring S\nf : RingHom R S\nhq : q.Monic\n⊢ Eq (Polynomial.map f (p.divByMonic q)) ((Polynomial.map f p).divByMonic (Polynomial.map f q))","decl":"theorem map_divByMonic [Ring S] (f : R →+* S) (hq : Monic q) :\n    (p /ₘ q).map f = p.map f /ₘ q.map f :=\n  (map_mod_divByMonic f hq).1\n\n"}
{"name":"Polynomial.map_modByMonic","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\np q : Polynomial R\ninst✝ : Ring S\nf : RingHom R S\nhq : q.Monic\n⊢ Eq (Polynomial.map f (p.modByMonic q)) ((Polynomial.map f p).modByMonic (Polynomial.map f q))","decl":"theorem map_modByMonic [Ring S] (f : R →+* S) (hq : Monic q) :\n    (p %ₘ q).map f = p.map f %ₘ q.map f :=\n  (map_mod_divByMonic f hq).2\n\n"}
{"name":"Polynomial.modByMonic_eq_zero_iff_dvd","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝ : Ring R\np q : Polynomial R\nhq : q.Monic\n⊢ Iff (Eq (p.modByMonic q) 0) (Dvd.dvd q p)","decl":"theorem modByMonic_eq_zero_iff_dvd (hq : Monic q) : p %ₘ q = 0 ↔ q ∣ p :=\n  ⟨fun h => by rw [← modByMonic_add_div p hq, h, zero_add]; exact dvd_mul_right _ _, fun h => by\n    nontriviality R\n    obtain ⟨r, hr⟩ := exists_eq_mul_right_of_dvd h\n    by_contra hpq0\n    have hmod : p %ₘ q = q * (r - p /ₘ q) := by rw [modByMonic_eq_sub_mul_div _ hq, mul_sub, ← hr]\n    have : degree (q * (r - p /ₘ q)) < degree q := hmod ▸ degree_modByMonic_lt _ hq\n    have hrpq0 : leadingCoeff (r - p /ₘ q) ≠ 0 := fun h =>\n      hpq0 <|\n        leadingCoeff_eq_zero.1\n          (by rw [hmod, leadingCoeff_eq_zero.1 h, mul_zero, leadingCoeff_zero])\n    have hlc : leadingCoeff q * leadingCoeff (r - p /ₘ q) ≠ 0 := by rwa [Monic.def.1 hq, one_mul]\n    rw [degree_mul' hlc, degree_eq_natDegree hq.ne_zero,\n      degree_eq_natDegree (mt leadingCoeff_eq_zero.2 hrpq0)] at this\n    exact not_lt_of_ge (Nat.le_add_right _ _) (WithBot.coe_lt_coe.1 this)⟩\n\n\n"}
{"name":"Polynomial.self_mul_modByMonic","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝ : Ring R\np q : Polynomial R\nhq : q.Monic\n⊢ Eq ((HMul.hMul q p).modByMonic q) 0","decl":"/-- See `Polynomial.mul_left_modByMonic` for the other multiplication order. That version, unlike\nthis one, requires commutativity. -/\n@[simp]\nlemma self_mul_modByMonic (hq : q.Monic) : (q * p) %ₘ q = 0 := by\n  rw [modByMonic_eq_zero_iff_dvd hq]\n  exact dvd_mul_right q p\n\n"}
{"name":"Polynomial.map_dvd_map","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\ninst✝ : Ring S\nf : RingHom R S\nhf : Function.Injective ⇑f\nx y : Polynomial R\nhx : x.Monic\n⊢ Iff (Dvd.dvd (Polynomial.map f x) (Polynomial.map f y)) (Dvd.dvd x y)","decl":"theorem map_dvd_map [Ring S] (f : R →+* S) (hf : Function.Injective f) {x y : R[X]}\n    (hx : x.Monic) : x.map f ∣ y.map f ↔ x ∣ y := by\n  rw [← modByMonic_eq_zero_iff_dvd hx, ← modByMonic_eq_zero_iff_dvd (hx.map f), ←\n    map_modByMonic f hx]\n  exact\n    ⟨fun H => map_injective f hf <| by rw [H, Polynomial.map_zero], fun H => by\n      rw [H, Polynomial.map_zero]⟩\n\n"}
{"name":"Polynomial.modByMonic_one","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝ : Ring R\np : Polynomial R\n⊢ Eq (p.modByMonic 1) 0","decl":"@[simp]\ntheorem modByMonic_one (p : R[X]) : p %ₘ 1 = 0 :=\n  (modByMonic_eq_zero_iff_dvd (by convert monic_one (R := R))).2 (one_dvd _)\n\n"}
{"name":"Polynomial.divByMonic_one","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝ : Ring R\np : Polynomial R\n⊢ Eq (p.divByMonic 1) p","decl":"@[simp]\ntheorem divByMonic_one (p : R[X]) : p /ₘ 1 = p := by\n  conv_rhs => rw [← modByMonic_add_div p monic_one]; simp\n\n"}
{"name":"Polynomial.sum_modByMonic_coeff","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝ : Ring R\np q : Polynomial R\nhq : q.Monic\nn : Nat\nhn : LE.le q.degree ↑n\n⊢ Eq (Finset.univ.sum fun i => (Polynomial.monomial ↑i) ((p.modByMonic q).coeff ↑i)) (p.modByMonic q)","decl":"theorem sum_modByMonic_coeff (hq : q.Monic) {n : ℕ} (hn : q.degree ≤ n) :\n    (∑ i : Fin n, monomial i ((p %ₘ q).coeff i)) = p %ₘ q := by\n  nontriviality R\n  exact\n    (sum_fin (fun i c => monomial i c) (by simp) ((degree_modByMonic_lt _ hq).trans_le hn)).trans\n      (sum_monomial_eq _)\n\n"}
{"name":"Polynomial.mul_divByMonic_cancel_left","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝ : Ring R\np q : Polynomial R\nhmo : q.Monic\n⊢ Eq ((HMul.hMul q p).divByMonic q) p","decl":"theorem mul_divByMonic_cancel_left (p : R[X]) {q : R[X]} (hmo : q.Monic) :\n    q * p /ₘ q = p := by\n  nontriviality R\n  refine (div_modByMonic_unique _ 0 hmo ⟨by rw [zero_add], ?_⟩).1\n  rw [degree_zero]\n  exact Ne.bot_lt fun h => hmo.ne_zero (degree_eq_bot.1 h)\n\n"}
{"name":"Polynomial.coeff_divByMonic_X_sub_C_rec","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝ : Ring R\np : Polynomial R\na : R\nn : Nat\n⊢ Eq ((p.divByMonic (HSub.hSub Polynomial.X (Polynomial.C a))).coeff n) (HAdd.hAdd (p.coeff (HAdd.hAdd n 1)) (HMul.hMul a ((p.divByMonic (HSub.hSub Polynomial.X (Polynomial.C a))).coeff (HAdd.hAdd n 1))))","decl":"lemma coeff_divByMonic_X_sub_C_rec (p : R[X]) (a : R) (n : ℕ) :\n    (p /ₘ (X - C a)).coeff n = coeff p (n + 1) + a * (p /ₘ (X - C a)).coeff (n + 1) := by\n  nontriviality R\n  have := monic_X_sub_C a\n  set q := p /ₘ (X - C a)\n  rw [← p.modByMonic_add_div this]\n  have : degree (p %ₘ (X - C a)) < ↑(n + 1) := degree_X_sub_C a ▸ p.degree_modByMonic_lt this\n    |>.trans_le <| WithBot.coe_le_coe.mpr le_add_self\n  simp [q, sub_mul, add_sub, coeff_eq_zero_of_degree_lt this]\n\n"}
{"name":"Polynomial.coeff_divByMonic_X_sub_C","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝ : Ring R\np : Polynomial R\na : R\nn : Nat\n⊢ Eq ((p.divByMonic (HSub.hSub Polynomial.X (Polynomial.C a))).coeff n) ((Finset.Icc (HAdd.hAdd n 1) p.natDegree).sum fun i => HMul.hMul (HPow.hPow a (HSub.hSub i (HAdd.hAdd n 1))) (p.coeff i))","decl":"theorem coeff_divByMonic_X_sub_C (p : R[X]) (a : R) (n : ℕ) :\n    (p /ₘ (X - C a)).coeff n = ∑ i ∈ Icc (n + 1) p.natDegree, a ^ (i - (n + 1)) * p.coeff i := by\n  wlog h : p.natDegree ≤ n generalizing n\n  · refine Nat.decreasingInduction' (fun n hn _ ih ↦ ?_) (le_of_not_le h) ?_\n    · rw [coeff_divByMonic_X_sub_C_rec, ih, eq_comm, Icc_eq_cons_Ioc (Nat.succ_le.mpr hn),\n          sum_cons, Nat.sub_self, pow_zero, one_mul, mul_sum]\n      congr 1; refine sum_congr ?_ fun i hi ↦ ?_\n      · ext; simp [Nat.succ_le]\n      rw [← mul_assoc, ← pow_succ', eq_comm, i.sub_succ', Nat.sub_add_cancel]\n      apply Nat.le_sub_of_add_le\n      rw [add_comm]; exact (mem_Icc.mp hi).1\n    · exact this _ le_rfl\n  rw [Icc_eq_empty (Nat.lt_succ.mpr h).not_le, sum_empty]\n  nontriviality R\n  by_cases hp : p.natDegree = 0\n  · rw [(divByMonic_eq_zero_iff <| monic_X_sub_C a).mpr, coeff_zero]\n    apply degree_lt_degree; rw [hp, natDegree_X_sub_C]; norm_num\n  · apply coeff_eq_zero_of_natDegree_lt\n    rw [natDegree_divByMonic p (monic_X_sub_C a), natDegree_X_sub_C]\n    exact (Nat.pred_lt hp).trans_le h\n\n"}
{"name":"Polynomial.not_isField","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝ : Ring R\n⊢ Not (IsField (Polynomial R))","decl":"variable (R) in\ntheorem not_isField : ¬IsField R[X] := by\n  nontriviality R\n  intro h\n  letI := h.toField\n  simpa using congr_arg natDegree (monic_X.eq_one_of_isUnit <| monic_X (R := R).ne_zero.isUnit)\n\n"}
{"name":"Polynomial.finiteMultiplicity_X_sub_C","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝ : Ring R\np : Polynomial R\na : R\nh0 : Ne p 0\n⊢ FiniteMultiplicity (HSub.hSub Polynomial.X (Polynomial.C a)) p","decl":"theorem finiteMultiplicity_X_sub_C (a : R) (h0 : p ≠ 0) : FiniteMultiplicity (X - C a) p := by\n  haveI := Nontrivial.of_polynomial_ne h0\n  refine finiteMultiplicity_of_degree_pos_of_monic ?_ (monic_X_sub_C _) h0\n  rw [degree_X_sub_C]\n  decide\n\n"}
{"name":"Polynomial.multiplicity_X_sub_C_finite","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝ : Ring R\np : Polynomial R\na : R\nh0 : Ne p 0\n⊢ FiniteMultiplicity (HSub.hSub Polynomial.X (Polynomial.C a)) p","decl":"@[deprecated (since := \"2024-11-30\")]\nalias multiplicity_X_sub_C_finite := finiteMultiplicity_X_sub_C\n\n/- Porting note: stripping out classical for decidability instance parameter might\nmake for better ergonomics -/\n"}
{"name":"Polynomial.rootMultiplicity_eq_nat_find_of_nonzero","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝¹ : Ring R\ninst✝ : DecidableEq R\np : Polynomial R\np0 : Ne p 0\na : R\n⊢ Eq (Polynomial.rootMultiplicity a p) (Nat.find ⋯)","decl":"theorem rootMultiplicity_eq_nat_find_of_nonzero [DecidableEq R] {p : R[X]} (p0 : p ≠ 0) {a : R} :\n    letI : DecidablePred fun n : ℕ => ¬(X - C a) ^ (n + 1) ∣ p := fun n =>\n      have := decidableDvdMonic p ((monic_X_sub_C a).pow (n + 1))\n      inferInstanceAs (Decidable ¬_)\n    rootMultiplicity a p = Nat.find (finiteMultiplicity_X_sub_C a p0) := by\n  dsimp [rootMultiplicity]\n  cases Subsingleton.elim ‹DecidableEq R› (Classical.decEq R)\n  rw [dif_neg p0]\n\n"}
{"name":"Polynomial.rootMultiplicity_eq_multiplicity","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝¹ : Ring R\ninst✝ : DecidableEq R\np : Polynomial R\na : R\n⊢ Eq (Polynomial.rootMultiplicity a p) (ite (Eq p 0) 0 (multiplicity (HSub.hSub Polynomial.X (Polynomial.C a)) p))","decl":"theorem rootMultiplicity_eq_multiplicity [DecidableEq R]\n    (p : R[X]) (a : R) :\n    rootMultiplicity a p =\n      if p = 0 then 0 else multiplicity (X - C a) p := by\n  simp only [rootMultiplicity, multiplicity, emultiplicity]\n  split\n  · rfl\n  rename_i h\n  simp only [finiteMultiplicity_X_sub_C a h, ↓reduceDIte]\n  rw [← ENat.some_eq_coe, WithTop.untop'_coe]\n  congr\n\n"}
{"name":"Polynomial.rootMultiplicity_zero","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝ : Ring R\nx : R\n⊢ Eq (Polynomial.rootMultiplicity x 0) 0","decl":"@[simp]\ntheorem rootMultiplicity_zero {x : R} : rootMultiplicity x 0 = 0 :=\n  dif_pos rfl\n\n"}
{"name":"Polynomial.rootMultiplicity_C","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝ : Ring R\nr a : R\n⊢ Eq (Polynomial.rootMultiplicity a (Polynomial.C r)) 0","decl":"@[simp]\ntheorem rootMultiplicity_C (r a : R) : rootMultiplicity a (C r) = 0 := by\n  cases subsingleton_or_nontrivial R\n  · rw [Subsingleton.elim (C r) 0, rootMultiplicity_zero]\n  classical\n  rw [rootMultiplicity_eq_multiplicity]\n  split_ifs with hr\n  · rfl\n  have h : natDegree (C r) < natDegree (X - C a) := by simp\n  simp_rw [multiplicity_eq_zero.mpr ((monic_X_sub_C a).not_dvd_of_natDegree_lt hr h)]\n\n"}
{"name":"Polynomial.pow_rootMultiplicity_dvd","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝ : Ring R\np : Polynomial R\na : R\n⊢ Dvd.dvd (HPow.hPow (HSub.hSub Polynomial.X (Polynomial.C a)) (Polynomial.rootMultiplicity a p)) p","decl":"theorem pow_rootMultiplicity_dvd (p : R[X]) (a : R) : (X - C a) ^ rootMultiplicity a p ∣ p :=\n  letI := Classical.decEq R\n  if h : p = 0 then by simp [h]\n  else by\n    classical\n    rw [rootMultiplicity_eq_multiplicity, if_neg h]; apply pow_multiplicity_dvd\n\n"}
{"name":"Polynomial.pow_mul_divByMonic_rootMultiplicity_eq","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝ : Ring R\np : Polynomial R\na : R\n⊢ Eq (HMul.hMul (HPow.hPow (HSub.hSub Polynomial.X (Polynomial.C a)) (Polynomial.rootMultiplicity a p)) (p.divByMonic (HPow.hPow (HSub.hSub Polynomial.X (Polynomial.C a)) (Polynomial.rootMultiplicity a p)))) p","decl":"theorem pow_mul_divByMonic_rootMultiplicity_eq (p : R[X]) (a : R) :\n    (X - C a) ^ rootMultiplicity a p * (p /ₘ (X - C a) ^ rootMultiplicity a p) = p := by\n  have : Monic ((X - C a) ^ rootMultiplicity a p) := (monic_X_sub_C _).pow _\n  conv_rhs =>\n      rw [← modByMonic_add_div p this,\n        (modByMonic_eq_zero_iff_dvd this).2 (pow_rootMultiplicity_dvd _ _)]\n  simp\n\n"}
{"name":"Polynomial.exists_eq_pow_rootMultiplicity_mul_and_not_dvd","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝ : Ring R\np : Polynomial R\nhp : Ne p 0\na : R\n⊢ Exists fun q => And (Eq p (HMul.hMul (HPow.hPow (HSub.hSub Polynomial.X (Polynomial.C a)) (Polynomial.rootMultiplicity a p)) q)) (Not (Dvd.dvd (HSub.hSub Polynomial.X (Polynomial.C a)) q))","decl":"theorem exists_eq_pow_rootMultiplicity_mul_and_not_dvd (p : R[X]) (hp : p ≠ 0) (a : R) :\n    ∃ q : R[X], p = (X - C a) ^ p.rootMultiplicity a * q ∧ ¬ (X - C a) ∣ q := by\n  classical\n  rw [rootMultiplicity_eq_multiplicity, if_neg hp]\n  apply (finiteMultiplicity_X_sub_C a hp).exists_eq_pow_mul_and_not_dvd\n\n"}
{"name":"Polynomial.modByMonic_X_sub_C_eq_C_eval","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝ : CommRing R\np : Polynomial R\na : R\n⊢ Eq (p.modByMonic (HSub.hSub Polynomial.X (Polynomial.C a))) (Polynomial.C (Polynomial.eval a p))","decl":"@[simp]\ntheorem modByMonic_X_sub_C_eq_C_eval (p : R[X]) (a : R) : p %ₘ (X - C a) = C (p.eval a) := by\n  nontriviality R\n  have h : (p %ₘ (X - C a)).eval a = p.eval a := by\n    rw [modByMonic_eq_sub_mul_div _ (monic_X_sub_C a), eval_sub, eval_mul, eval_sub, eval_X,\n      eval_C, sub_self, zero_mul, sub_zero]\n  have : degree (p %ₘ (X - C a)) < 1 :=\n    degree_X_sub_C a ▸ degree_modByMonic_lt p (monic_X_sub_C a)\n  have : degree (p %ₘ (X - C a)) ≤ 0 := by\n    revert this\n    cases degree (p %ₘ (X - C a))\n    · exact fun _ => bot_le\n    · exact fun h => WithBot.coe_le_coe.2 (Nat.le_of_lt_succ (WithBot.coe_lt_coe.1 h))\n  rw [eq_C_of_degree_le_zero this, eval_C] at h\n  rw [eq_C_of_degree_le_zero this, h]\n\n"}
{"name":"Polynomial.mul_divByMonic_eq_iff_isRoot","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\na : R\ninst✝ : CommRing R\np : Polynomial R\n⊢ Iff (Eq (HMul.hMul (HSub.hSub Polynomial.X (Polynomial.C a)) (p.divByMonic (HSub.hSub Polynomial.X (Polynomial.C a)))) p) (p.IsRoot a)","decl":"theorem mul_divByMonic_eq_iff_isRoot : (X - C a) * (p /ₘ (X - C a)) = p ↔ IsRoot p a :=\n  .trans\n    ⟨fun h => by rw [← h, eval_mul, eval_sub, eval_X, eval_C, sub_self, zero_mul],\n    fun h => by\n      conv_rhs =>\n        rw [← modByMonic_add_div p (monic_X_sub_C a)]\n        rw [modByMonic_X_sub_C_eq_C_eval, h, C_0, zero_add]⟩\n    IsRoot.def.symm\n\n"}
{"name":"Polynomial.dvd_iff_isRoot","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\na : R\ninst✝ : CommRing R\np : Polynomial R\n⊢ Iff (Dvd.dvd (HSub.hSub Polynomial.X (Polynomial.C a)) p) (p.IsRoot a)","decl":"theorem dvd_iff_isRoot : X - C a ∣ p ↔ IsRoot p a :=\n  ⟨fun h => by\n    rwa [← modByMonic_eq_zero_iff_dvd (monic_X_sub_C _), modByMonic_X_sub_C_eq_C_eval, ← C_0,\n      C_inj] at h,\n    fun h => ⟨p /ₘ (X - C a), by rw [mul_divByMonic_eq_iff_isRoot.2 h]⟩⟩\n\n"}
{"name":"Polynomial.X_sub_C_dvd_sub_C_eval","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\na : R\ninst✝ : CommRing R\np : Polynomial R\n⊢ Dvd.dvd (HSub.hSub Polynomial.X (Polynomial.C a)) (HSub.hSub p (Polynomial.C (Polynomial.eval a p)))","decl":"theorem X_sub_C_dvd_sub_C_eval : X - C a ∣ p - C (p.eval a) := by\n  rw [dvd_iff_isRoot, IsRoot, eval_sub, eval_C, sub_self]\n\n-- TODO: generalize this to Ring. In general, 0 can be replaced by any element in the center of R.\n"}
{"name":"Polynomial.modByMonic_X","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝ : CommRing R\np : Polynomial R\n⊢ Eq (p.modByMonic Polynomial.X) (Polynomial.C (Polynomial.eval 0 p))","decl":"theorem modByMonic_X (p : R[X]) : p %ₘ X = C (p.eval 0) := by\n  rw [← modByMonic_X_sub_C_eq_C_eval, C_0, sub_zero]\n\n"}
{"name":"Polynomial.eval₂_modByMonic_eq_self_of_root","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nf : RingHom R S\np q : Polynomial R\nhq : q.Monic\nx : S\nhx : Eq (Polynomial.eval₂ f x q) 0\n⊢ Eq (Polynomial.eval₂ f x (p.modByMonic q)) (Polynomial.eval₂ f x p)","decl":"theorem eval₂_modByMonic_eq_self_of_root [CommRing S] {f : R →+* S} {p q : R[X]} (hq : q.Monic)\n    {x : S} (hx : q.eval₂ f x = 0) : (p %ₘ q).eval₂ f x = p.eval₂ f x := by\n  rw [modByMonic_eq_sub_mul_div p hq, eval₂_sub, eval₂_mul, hx, zero_mul, sub_zero]\n\n"}
{"name":"Polynomial.sub_dvd_eval_sub","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝ : CommRing R\na b : R\np : Polynomial R\n⊢ Dvd.dvd (HSub.hSub a b) (HSub.hSub (Polynomial.eval a p) (Polynomial.eval b p))","decl":"theorem sub_dvd_eval_sub (a b : R) (p : R[X]) : a - b ∣ p.eval a - p.eval b := by\n  suffices X - C b ∣ p - C (p.eval b) by\n    simpa only [coe_evalRingHom, eval_sub, eval_X, eval_C] using (evalRingHom a).map_dvd this\n  simp [dvd_iff_isRoot]\n\n"}
{"name":"Polynomial.rootMultiplicity_eq_zero_iff","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝ : CommRing R\np : Polynomial R\nx : R\n⊢ Iff (Eq (Polynomial.rootMultiplicity x p) 0) (p.IsRoot x → Eq p 0)","decl":"@[simp]\ntheorem rootMultiplicity_eq_zero_iff {p : R[X]} {x : R} :\n    rootMultiplicity x p = 0 ↔ IsRoot p x → p = 0 := by\n  classical\n  simp only [rootMultiplicity_eq_multiplicity, ite_eq_left_iff,\n    Nat.cast_zero, multiplicity_eq_zero, dvd_iff_isRoot, not_imp_not]\n\n"}
{"name":"Polynomial.rootMultiplicity_eq_zero","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝ : CommRing R\np : Polynomial R\nx : R\nh : Not (p.IsRoot x)\n⊢ Eq (Polynomial.rootMultiplicity x p) 0","decl":"theorem rootMultiplicity_eq_zero {p : R[X]} {x : R} (h : ¬IsRoot p x) : rootMultiplicity x p = 0 :=\n  rootMultiplicity_eq_zero_iff.2 fun h' => (h h').elim\n\n"}
{"name":"Polynomial.rootMultiplicity_pos'","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝ : CommRing R\np : Polynomial R\nx : R\n⊢ Iff (LT.lt 0 (Polynomial.rootMultiplicity x p)) (And (Ne p 0) (p.IsRoot x))","decl":"@[simp]\ntheorem rootMultiplicity_pos' {p : R[X]} {x : R} :\n    0 < rootMultiplicity x p ↔ p ≠ 0 ∧ IsRoot p x := by\n  rw [pos_iff_ne_zero, Ne, rootMultiplicity_eq_zero_iff, Classical.not_imp, and_comm]\n\n"}
{"name":"Polynomial.rootMultiplicity_pos","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝ : CommRing R\np : Polynomial R\nhp : Ne p 0\nx : R\n⊢ Iff (LT.lt 0 (Polynomial.rootMultiplicity x p)) (p.IsRoot x)","decl":"theorem rootMultiplicity_pos {p : R[X]} (hp : p ≠ 0) {x : R} :\n    0 < rootMultiplicity x p ↔ IsRoot p x :=\n  rootMultiplicity_pos'.trans (and_iff_right hp)\n\n"}
{"name":"Polynomial.eval_divByMonic_pow_rootMultiplicity_ne_zero","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝ : CommRing R\np : Polynomial R\na : R\nhp : Ne p 0\n⊢ Ne (Polynomial.eval a (p.divByMonic (HPow.hPow (HSub.hSub Polynomial.X (Polynomial.C a)) (Polynomial.rootMultiplicity a p)))) 0","decl":"theorem eval_divByMonic_pow_rootMultiplicity_ne_zero {p : R[X]} (a : R) (hp : p ≠ 0) :\n    eval a (p /ₘ (X - C a) ^ rootMultiplicity a p) ≠ 0 := by\n  classical\n  haveI : Nontrivial R := Nontrivial.of_polynomial_ne hp\n  rw [Ne, ← IsRoot, ← dvd_iff_isRoot]\n  rintro ⟨q, hq⟩\n  have := pow_mul_divByMonic_rootMultiplicity_eq p a\n  rw [hq, ← mul_assoc, ← pow_succ, rootMultiplicity_eq_multiplicity, if_neg hp] at this\n  exact\n    (finiteMultiplicity_of_degree_pos_of_monic\n      (show (0 : WithBot ℕ) < degree (X - C a) by rw [degree_X_sub_C]; decide)\n      (monic_X_sub_C _) hp).not_pow_dvd_of_multiplicity_lt\n      (Nat.lt_succ_self _) (dvd_of_mul_right_eq _ this)\n\n"}
{"name":"Polynomial.mul_self_modByMonic","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝ : CommRing R\np q : Polynomial R\nhq : q.Monic\n⊢ Eq ((HMul.hMul p q).modByMonic q) 0","decl":"/-- See `Polynomial.mul_right_modByMonic` for the other multiplication order. This version, unlike\nthat one, requires commutativity. -/\n@[simp]\nlemma mul_self_modByMonic (hq : q.Monic) : (p * q) %ₘ q = 0 := by\n  rw [modByMonic_eq_zero_iff_dvd hq]\n  exact dvd_mul_left q p\n\n"}
{"name":"Polynomial.modByMonic_eq_of_dvd_sub","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝ : CommRing R\np₁ p₂ q : Polynomial R\nhq : q.Monic\nh : Dvd.dvd q (HSub.hSub p₁ p₂)\n⊢ Eq (p₁.modByMonic q) (p₂.modByMonic q)","decl":"lemma modByMonic_eq_of_dvd_sub (hq : q.Monic) (h : q ∣ p₁ - p₂) : p₁ %ₘ q = p₂ %ₘ q := by\n  nontriviality R\n  obtain ⟨f, sub_eq⟩ := h\n  refine (div_modByMonic_unique (p₂ /ₘ q + f) _ hq ⟨?_, degree_modByMonic_lt _ hq⟩).2\n  rw [sub_eq_iff_eq_add.mp sub_eq, mul_add, ← add_assoc, modByMonic_add_div _ hq, add_comm]\n\n"}
{"name":"Polynomial.add_modByMonic","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝ : CommRing R\nq p₁ p₂ : Polynomial R\n⊢ Eq ((HAdd.hAdd p₁ p₂).modByMonic q) (HAdd.hAdd (p₁.modByMonic q) (p₂.modByMonic q))","decl":"lemma add_modByMonic (p₁ p₂ : R[X]) : (p₁ + p₂) %ₘ q = p₁ %ₘ q + p₂ %ₘ q := by\n  by_cases hq : q.Monic\n  · cases' subsingleton_or_nontrivial R with hR hR\n    · simp only [eq_iff_true_of_subsingleton]\n    · exact\n      (div_modByMonic_unique (p₁ /ₘ q + p₂ /ₘ q) _ hq\n          ⟨by\n            rw [mul_add, add_left_comm, add_assoc, modByMonic_add_div _ hq, ← add_assoc,\n              add_comm (q * _), modByMonic_add_div _ hq],\n            (degree_add_le _ _).trans_lt\n              (max_lt (degree_modByMonic_lt _ hq) (degree_modByMonic_lt _ hq))⟩).2\n  · simp_rw [modByMonic_eq_of_not_monic _ hq]\n\n"}
{"name":"Polynomial.neg_modByMonic","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝ : CommRing R\np q : Polynomial R\n⊢ Eq ((Neg.neg p).modByMonic q) (Neg.neg (p.modByMonic q))","decl":"lemma neg_modByMonic (p q : R[X]) : (-p) %ₘ q = - (p %ₘ q) := by\n  rw [eq_neg_iff_add_eq_zero, ← add_modByMonic, neg_add_cancel, zero_modByMonic]\n\n"}
{"name":"Polynomial.sub_modByMonic","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝ : CommRing R\np₁ p₂ q : Polynomial R\n⊢ Eq ((HSub.hSub p₁ p₂).modByMonic q) (HSub.hSub (p₁.modByMonic q) (p₂.modByMonic q))","decl":"lemma sub_modByMonic (p₁ p₂ q : R[X]) : (p₁ - p₂) %ₘ q = p₁ %ₘ q - p₂ %ₘ q := by\n  simp [sub_eq_add_neg, add_modByMonic, neg_modByMonic]\n\n"}
{"name":"Polynomial.eval_divByMonic_eq_trailingCoeff_comp","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝ : CommRing R\np : Polynomial R\nt : R\n⊢ Eq (Polynomial.eval t (p.divByMonic (HPow.hPow (HSub.hSub Polynomial.X (Polynomial.C t)) (Polynomial.rootMultiplicity t p)))) (p.comp (HAdd.hAdd Polynomial.X (Polynomial.C t))).trailingCoeff","decl":"lemma eval_divByMonic_eq_trailingCoeff_comp {p : R[X]} {t : R} :\n    (p /ₘ (X - C t) ^ p.rootMultiplicity t).eval t = (p.comp (X + C t)).trailingCoeff := by\n  obtain rfl | hp := eq_or_ne p 0\n  · rw [zero_divByMonic, eval_zero, zero_comp, trailingCoeff_zero]\n  have mul_eq := p.pow_mul_divByMonic_rootMultiplicity_eq t\n  set m := p.rootMultiplicity t\n  set g := p /ₘ (X - C t) ^ m\n  have : (g.comp (X + C t)).coeff 0 = g.eval t := by\n    rw [coeff_zero_eq_eval_zero, eval_comp, eval_add, eval_X, eval_C, zero_add]\n  rw [← congr_arg (comp · <| X + C t) mul_eq, mul_comp, pow_comp, sub_comp, X_comp, C_comp,\n    add_sub_cancel_right, ← reverse_leadingCoeff, reverse_X_pow_mul, reverse_leadingCoeff,\n    trailingCoeff, Nat.le_zero.1 (natTrailingDegree_le_of_ne_zero <|\n      this ▸ eval_divByMonic_pow_rootMultiplicity_ne_zero t hp), this]\n\n/- Porting note: the ML3 proof no longer worked because of a conflict in the\ninferred type and synthesized type for `DecidableRel` when using `Nat.le_find_iff` from\n`Mathlib.Algebra.Polynomial.Div` After some discussion on [Zulip]\n(https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/decidability.20leakage)\nintroduced `Polynomial.rootMultiplicity_eq_nat_find_of_nonzero` to contain the issue\n-/\n"}
{"name":"Polynomial.le_rootMultiplicity_iff","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝ : CommRing R\np : Polynomial R\np0 : Ne p 0\na : R\nn : Nat\n⊢ Iff (LE.le n (Polynomial.rootMultiplicity a p)) (Dvd.dvd (HPow.hPow (HSub.hSub Polynomial.X (Polynomial.C a)) n) p)","decl":"/-- The multiplicity of `a` as root of a nonzero polynomial `p` is at least `n` iff\n`(X - a) ^ n` divides `p`. -/\nlemma le_rootMultiplicity_iff (p0 : p ≠ 0) {a : R} {n : ℕ} :\n    n ≤ rootMultiplicity a p ↔ (X - C a) ^ n ∣ p := by\n  classical\n  rw [rootMultiplicity_eq_nat_find_of_nonzero p0, @Nat.le_find_iff _ (_)]\n  simp_rw [Classical.not_not]\n  refine ⟨fun h => ?_, fun h m hm => (pow_dvd_pow _ hm).trans h⟩\n  cases' n with n\n  · rw [pow_zero]\n    apply one_dvd\n  · exact h n n.lt_succ_self\n\n"}
{"name":"Polynomial.rootMultiplicity_le_iff","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝ : CommRing R\np : Polynomial R\np0 : Ne p 0\na : R\nn : Nat\n⊢ Iff (LE.le (Polynomial.rootMultiplicity a p) n) (Not (Dvd.dvd (HPow.hPow (HSub.hSub Polynomial.X (Polynomial.C a)) (HAdd.hAdd n 1)) p))","decl":"lemma rootMultiplicity_le_iff (p0 : p ≠ 0) (a : R) (n : ℕ) :\n    rootMultiplicity a p ≤ n ↔ ¬(X - C a) ^ (n + 1) ∣ p := by\n  rw [← (le_rootMultiplicity_iff p0).not, not_le, Nat.lt_add_one_iff]\n\n"}
{"name":"Polynomial.rootMultiplicity_add","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝ : CommRing R\np q : Polynomial R\na : R\nhzero : Ne (HAdd.hAdd p q) 0\n⊢ LE.le (Min.min (Polynomial.rootMultiplicity a p) (Polynomial.rootMultiplicity a q)) (Polynomial.rootMultiplicity a (HAdd.hAdd p q))","decl":"/-- The multiplicity of `p + q` is at least the minimum of the multiplicities. -/\nlemma rootMultiplicity_add {p q : R[X]} (a : R) (hzero : p + q ≠ 0) :\n    min (rootMultiplicity a p) (rootMultiplicity a q) ≤ rootMultiplicity a (p + q) := by\n  rw [le_rootMultiplicity_iff hzero]\n  exact min_pow_dvd_add (pow_rootMultiplicity_dvd p a) (pow_rootMultiplicity_dvd q a)\n\n"}
{"name":"Polynomial.le_rootMultiplicity_mul","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝ : CommRing R\np q : Polynomial R\nx : R\nhpq : Ne (HMul.hMul p q) 0\n⊢ LE.le (HAdd.hAdd (Polynomial.rootMultiplicity x p) (Polynomial.rootMultiplicity x q)) (Polynomial.rootMultiplicity x (HMul.hMul p q))","decl":"lemma le_rootMultiplicity_mul {p q : R[X]} (x : R) (hpq : p * q ≠ 0) :\n    rootMultiplicity x p + rootMultiplicity x q ≤ rootMultiplicity x (p * q) := by\n  rw [le_rootMultiplicity_iff hpq, pow_add]\n  exact mul_dvd_mul (pow_rootMultiplicity_dvd p x) (pow_rootMultiplicity_dvd q x)\n\n"}
{"name":"Polynomial.pow_rootMultiplicity_not_dvd","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝ : CommRing R\np : Polynomial R\np0 : Ne p 0\na : R\n⊢ Not (Dvd.dvd (HPow.hPow (HSub.hSub Polynomial.X (Polynomial.C a)) (HAdd.hAdd (Polynomial.rootMultiplicity a p) 1)) p)","decl":"lemma pow_rootMultiplicity_not_dvd (p0 : p ≠ 0) (a : R) :\n    ¬(X - C a) ^ (rootMultiplicity a p + 1) ∣ p := by rw [← rootMultiplicity_le_iff p0]\n\n"}
{"name":"Polynomial.rootMultiplicity_eq_natTrailingDegree'","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝ : CommRing R\np : Polynomial R\n⊢ Eq (Polynomial.rootMultiplicity 0 p) p.natTrailingDegree","decl":"/-- See `Polynomial.rootMultiplicity_eq_natTrailingDegree` for the general case. -/\nlemma rootMultiplicity_eq_natTrailingDegree' : p.rootMultiplicity 0 = p.natTrailingDegree := by\n  by_cases h : p = 0\n  · simp only [h, rootMultiplicity_zero, natTrailingDegree_zero]\n  refine le_antisymm ?_ ?_\n  · rw [rootMultiplicity_le_iff h, map_zero, sub_zero, X_pow_dvd_iff, not_forall]\n    exact ⟨p.natTrailingDegree,\n      fun h' ↦ trailingCoeff_nonzero_iff_nonzero.2 h <| h' <| Nat.lt.base _⟩\n  · rw [le_rootMultiplicity_iff h, map_zero, sub_zero, X_pow_dvd_iff]\n    exact fun _ ↦ coeff_eq_zero_of_lt_natTrailingDegree\n\n"}
{"name":"Polynomial.leadingCoeff_divByMonic_of_monic","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝ : CommRing R\np q : Polynomial R\nhmonic : q.Monic\nhdegree : LE.le q.degree p.degree\n⊢ Eq (p.divByMonic q).leadingCoeff p.leadingCoeff","decl":"/-- Division by a monic polynomial doesn't change the leading coefficient. -/\nlemma leadingCoeff_divByMonic_of_monic (hmonic : q.Monic)\n    (hdegree : q.degree ≤ p.degree) : (p /ₘ q).leadingCoeff = p.leadingCoeff := by\n  nontriviality\n  have h : q.leadingCoeff * (p /ₘ q).leadingCoeff ≠ 0 := by\n    simpa [divByMonic_eq_zero_iff hmonic, hmonic.leadingCoeff,\n      Nat.WithBot.one_le_iff_zero_lt] using hdegree\n  nth_rw 2 [← modByMonic_add_div p hmonic]\n  rw [leadingCoeff_add_of_degree_lt, leadingCoeff_monic_mul hmonic]\n  rw [degree_mul' h, degree_add_divByMonic hmonic hdegree]\n  exact (degree_modByMonic_lt p hmonic).trans_le hdegree\n\n"}
{"name":"Polynomial.degree_eq_one_of_irreducible_of_root","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝¹ : CommRing R\np : Polynomial R\ninst✝ : IsDomain R\nhi : Irreducible p\nx : R\nhx : p.IsRoot x\n⊢ Eq p.degree 1","decl":"lemma degree_eq_one_of_irreducible_of_root (hi : Irreducible p) {x : R} (hx : IsRoot p x) :\n    degree p = 1 :=\n  let ⟨g, hg⟩ := dvd_iff_isRoot.2 hx\n  have : IsUnit (X - C x) ∨ IsUnit g := hi.isUnit_or_isUnit hg\n  this.elim\n    (fun h => by\n      have h₁ : degree (X - C x) = 1 := degree_X_sub_C x\n      have h₂ : degree (X - C x) = 0 := degree_eq_zero_of_isUnit h\n      rw [h₁] at h₂; exact absurd h₂ (by decide))\n    fun hgu => by rw [hg, degree_mul, degree_X_sub_C, degree_eq_zero_of_isUnit hgu, add_zero]\n\n"}
{"name":"Polynomial.leadingCoeff_divByMonic_X_sub_C","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\np : Polynomial R\nhp : Ne p.degree 0\na : R\n⊢ Eq (p.divByMonic (HSub.hSub Polynomial.X (Polynomial.C a))).leadingCoeff p.leadingCoeff","decl":"lemma leadingCoeff_divByMonic_X_sub_C (p : R[X]) (hp : degree p ≠ 0) (a : R) :\n    leadingCoeff (p /ₘ (X - C a)) = leadingCoeff p := by\n  nontriviality\n  cases' hp.lt_or_lt with hd hd\n  · rw [degree_eq_bot.mp <| Nat.WithBot.lt_zero_iff.mp hd, zero_divByMonic]\n  refine leadingCoeff_divByMonic_of_monic (monic_X_sub_C a) ?_\n  rwa [degree_X_sub_C, Nat.WithBot.one_le_iff_zero_lt]\n\n"}
{"name":"Polynomial.eq_of_dvd_of_natDegree_le_of_leadingCoeff","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\np q : Polynomial R\nhpq : Dvd.dvd p q\nh₁ : LE.le q.natDegree p.natDegree\nh₂ : Eq p.leadingCoeff q.leadingCoeff\n⊢ Eq p q","decl":"lemma eq_of_dvd_of_natDegree_le_of_leadingCoeff {p q : R[X]} (hpq : p ∣ q)\n    (h₁ : q.natDegree ≤ p.natDegree) (h₂ : p.leadingCoeff = q.leadingCoeff) :\n    p = q := by\n  by_cases hq : q = 0\n  · rwa [hq, leadingCoeff_zero, leadingCoeff_eq_zero, ← hq] at h₂\n  replace h₁ := (natDegree_le_of_dvd hpq hq).antisymm h₁\n  obtain ⟨u, rfl⟩ := hpq\n  replace hq := mul_ne_zero_iff.mp hq\n  rw [natDegree_mul hq.1 hq.2, self_eq_add_right] at h₁\n  rw [eq_C_of_natDegree_eq_zero h₁, leadingCoeff_mul, leadingCoeff_C,\n    eq_comm, mul_eq_left₀ (leadingCoeff_ne_zero.mpr hq.1)] at h₂\n  rw [eq_C_of_natDegree_eq_zero h₁, h₂, map_one, mul_one]\n\n"}
{"name":"Polynomial.associated_of_dvd_of_natDegree_le_of_leadingCoeff","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\np q : Polynomial R\nhpq : Dvd.dvd p q\nh₁ : LE.le q.natDegree p.natDegree\nh₂ : Dvd.dvd q.leadingCoeff p.leadingCoeff\n⊢ Associated p q","decl":"lemma associated_of_dvd_of_natDegree_le_of_leadingCoeff {p q : R[X]} (hpq : p ∣ q)\n    (h₁ : q.natDegree ≤ p.natDegree) (h₂ : q.leadingCoeff ∣ p.leadingCoeff) :\n    Associated p q :=\n  have ⟨r, hr⟩ := hpq\n  have ⟨u, hu⟩ := associated_of_dvd_dvd ⟨leadingCoeff r, hr ▸ leadingCoeff_mul p r⟩ h₂\n  ⟨Units.map C.toMonoidHom u, eq_of_dvd_of_natDegree_le_of_leadingCoeff\n    (by rwa [Units.mul_right_dvd]) (by simpa [natDegree_mul_C] using h₁) (by simpa using hu)⟩\n\n"}
{"name":"Polynomial.associated_of_dvd_of_natDegree_le","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"K : Type u_1\ninst✝ : Field K\np q : Polynomial K\nhpq : Dvd.dvd p q\nhq : Ne q 0\nh₁ : LE.le q.natDegree p.natDegree\n⊢ Associated p q","decl":"lemma associated_of_dvd_of_natDegree_le {K} [Field K] {p q : K[X]} (hpq : p ∣ q) (hq : q ≠ 0)\n    (h₁ : q.natDegree ≤ p.natDegree) : Associated p q :=\n  associated_of_dvd_of_natDegree_le_of_leadingCoeff hpq h₁\n    (IsUnit.dvd (by rwa [← leadingCoeff_ne_zero, ← isUnit_iff_ne_zero] at hq))\n\n"}
{"name":"Polynomial.associated_of_dvd_of_degree_eq","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"K : Type u_1\ninst✝ : Field K\np q : Polynomial K\nhpq : Dvd.dvd p q\nh₁ : Eq p.degree q.degree\n⊢ Associated p q","decl":"lemma associated_of_dvd_of_degree_eq {K} [Field K] {p q : K[X]} (hpq : p ∣ q)\n    (h₁ : p.degree = q.degree) : Associated p q :=\n  (Classical.em (q = 0)).elim (fun hq ↦ (show p = q by simpa [hq] using h₁) ▸ Associated.refl p)\n    (associated_of_dvd_of_natDegree_le hpq · (natDegree_le_natDegree h₁.ge))\n\n"}
{"name":"Polynomial.eq_leadingCoeff_mul_of_monic_of_dvd_of_natDegree_le","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u_1\ninst✝ : CommRing R\np q : Polynomial R\nhp : p.Monic\nhdiv : Dvd.dvd p q\nhdeg : LE.le q.natDegree p.natDegree\n⊢ Eq q (HMul.hMul (Polynomial.C q.leadingCoeff) p)","decl":"lemma eq_leadingCoeff_mul_of_monic_of_dvd_of_natDegree_le {R} [CommRing R] {p q : R[X]}\n    (hp : p.Monic) (hdiv : p ∣ q) (hdeg : q.natDegree ≤ p.natDegree) :\n    q = C q.leadingCoeff * p := by\n  obtain ⟨r, hr⟩ := hdiv\n  obtain rfl | hq := eq_or_ne q 0; · simp\n  have rzero : r ≠ 0 := fun h => by simp [h, hq] at hr\n  rw [hr, natDegree_mul'] at hdeg; swap\n  · rw [hp.leadingCoeff, one_mul, leadingCoeff_ne_zero]\n    exact rzero\n  rw [mul_comm, @eq_C_of_natDegree_eq_zero _ _ r] at hr\n  · convert hr\n    convert leadingCoeff_C (coeff r 0) using 1\n    rw [hr, leadingCoeff_mul_monic hp]\n  · exact (add_right_inj _).1 (le_antisymm hdeg <| Nat.le.intro rfl)\n\n"}
{"name":"Polynomial.eq_of_monic_of_dvd_of_natDegree_le","module":"Mathlib.Algebra.Polynomial.Div","initialProofState":"R : Type u_1\ninst✝ : CommRing R\np q : Polynomial R\nhp : p.Monic\nhq : q.Monic\nhdiv : Dvd.dvd p q\nhdeg : LE.le q.natDegree p.natDegree\n⊢ Eq q p","decl":"lemma eq_of_monic_of_dvd_of_natDegree_le {R} [CommRing R] {p q : R[X]} (hp : p.Monic)\n    (hq : q.Monic) (hdiv : p ∣ q) (hdeg : q.natDegree ≤ p.natDegree) : q = p := by\n  convert eq_leadingCoeff_mul_of_monic_of_dvd_of_natDegree_le hp hdiv hdeg\n  rw [hq.leadingCoeff, C_1, one_mul]\n\n"}
