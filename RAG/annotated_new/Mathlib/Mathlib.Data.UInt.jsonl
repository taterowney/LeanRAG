{"name":"UInt64.pow_def","module":"Mathlib.Data.UInt","initialProofState":"a : UInt64\nn : Nat\n⊢ Eq (HPow.hPow a n) { toBitVec := { toFin := HPow.hPow a.val n } }","decl":"set_option hygiene false in\nrun_cmd\n  for typeName' in [`UInt8, `UInt16, `UInt32, `UInt64, `USize] do\n  let typeName := Lean.mkIdent typeName'\n  Lean.Elab.Command.elabCommand (← `(\n    namespace $typeName\n\n      instance : Neg $typeName where\n        neg a := mk ⟨-a.val⟩\n\n      instance : Pow $typeName ℕ where\n        pow a n := mk ⟨a.val ^ n⟩\n\n      instance : SMul ℕ $typeName where\n        smul n a := mk ⟨n • a.val⟩\n\n      instance : SMul ℤ $typeName where\n        smul z a := mk ⟨z • a.val⟩\n\n      lemma neg_def (a : $typeName) : -a = ⟨⟨-a.val⟩⟩ := rfl\n\n      lemma pow_def (a : $typeName) (n : ℕ) : a ^ n = ⟨⟨a.val ^ n⟩⟩ := rfl\n\n      lemma nsmul_def (n : ℕ) (a : $typeName) : n • a = ⟨⟨n • a.val⟩⟩ := rfl\n\n      lemma zsmul_def (z : ℤ) (a : $typeName) : z • a = ⟨⟨z • a.val⟩⟩ := rfl\n\n      open $typeName (eq_of_val_eq) in\n      lemma val_injective : Function.Injective val := @eq_of_val_eq\n\n      open $typeName (eq_of_toBitVec_eq) in\n      lemma toBitVec_injective : Function.Injective toBitVec := @eq_of_toBitVec_eq\n\n      instance instCommMonoid : CommMonoid $typeName :=\n        Function.Injective.commMonoid toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl)\n\n      instance instNonUnitalCommRing : NonUnitalCommRing $typeName :=\n        Function.Injective.nonUnitalCommRing toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl)\n\n      local instance instNatCast : NatCast $typeName where\n        natCast n := mk n\n\n      local instance instIntCast : IntCast $typeName where\n        intCast z := mk z\n\n      lemma natCast_def (n : ℕ) : (n : $typeName) = ⟨n⟩ := rfl\n\n      lemma intCast_def (z : ℤ) : (z : $typeName) = ⟨z⟩ := rfl\n\n      local instance instCommRing : CommRing $typeName :=\n        Function.Injective.commRing toBitVec toBitVec_injective\n          rfl rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ => rfl)\n\n      namespace CommRing\n      attribute [scoped instance] instCommRing instNatCast instIntCast\n      end CommRing\n\n    end $typeName\n  ))\n  -- interpolating docstrings above is more trouble than it's worth\n  let docString :=\n    s!\"To use this instance, use `open scoped {typeName'}.CommRing`.\\n\\n\" ++\n    \"See the module docstring for an explanation\"\n  Lean.addDocString (typeName'.mkStr \"instCommRing\") docString\n  Lean.addDocString (typeName'.mkStr \"instNatCast\") docString\n  Lean.addDocString (typeName'.mkStr \"instIntCast\") docString\n\n"}
{"name":"UInt32.val_injective","module":"Mathlib.Data.UInt","initialProofState":"⊢ Function.Injective UInt32.val","decl":"set_option hygiene false in\nrun_cmd\n  for typeName' in [`UInt8, `UInt16, `UInt32, `UInt64, `USize] do\n  let typeName := Lean.mkIdent typeName'\n  Lean.Elab.Command.elabCommand (← `(\n    namespace $typeName\n\n      instance : Neg $typeName where\n        neg a := mk ⟨-a.val⟩\n\n      instance : Pow $typeName ℕ where\n        pow a n := mk ⟨a.val ^ n⟩\n\n      instance : SMul ℕ $typeName where\n        smul n a := mk ⟨n • a.val⟩\n\n      instance : SMul ℤ $typeName where\n        smul z a := mk ⟨z • a.val⟩\n\n      lemma neg_def (a : $typeName) : -a = ⟨⟨-a.val⟩⟩ := rfl\n\n      lemma pow_def (a : $typeName) (n : ℕ) : a ^ n = ⟨⟨a.val ^ n⟩⟩ := rfl\n\n      lemma nsmul_def (n : ℕ) (a : $typeName) : n • a = ⟨⟨n • a.val⟩⟩ := rfl\n\n      lemma zsmul_def (z : ℤ) (a : $typeName) : z • a = ⟨⟨z • a.val⟩⟩ := rfl\n\n      open $typeName (eq_of_val_eq) in\n      lemma val_injective : Function.Injective val := @eq_of_val_eq\n\n      open $typeName (eq_of_toBitVec_eq) in\n      lemma toBitVec_injective : Function.Injective toBitVec := @eq_of_toBitVec_eq\n\n      instance instCommMonoid : CommMonoid $typeName :=\n        Function.Injective.commMonoid toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl)\n\n      instance instNonUnitalCommRing : NonUnitalCommRing $typeName :=\n        Function.Injective.nonUnitalCommRing toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl)\n\n      local instance instNatCast : NatCast $typeName where\n        natCast n := mk n\n\n      local instance instIntCast : IntCast $typeName where\n        intCast z := mk z\n\n      lemma natCast_def (n : ℕ) : (n : $typeName) = ⟨n⟩ := rfl\n\n      lemma intCast_def (z : ℤ) : (z : $typeName) = ⟨z⟩ := rfl\n\n      local instance instCommRing : CommRing $typeName :=\n        Function.Injective.commRing toBitVec toBitVec_injective\n          rfl rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ => rfl)\n\n      namespace CommRing\n      attribute [scoped instance] instCommRing instNatCast instIntCast\n      end CommRing\n\n    end $typeName\n  ))\n  -- interpolating docstrings above is more trouble than it's worth\n  let docString :=\n    s!\"To use this instance, use `open scoped {typeName'}.CommRing`.\\n\\n\" ++\n    \"See the module docstring for an explanation\"\n  Lean.addDocString (typeName'.mkStr \"instCommRing\") docString\n  Lean.addDocString (typeName'.mkStr \"instNatCast\") docString\n  Lean.addDocString (typeName'.mkStr \"instIntCast\") docString\n\n"}
{"name":"USize.val_injective","module":"Mathlib.Data.UInt","initialProofState":"⊢ Function.Injective USize.val","decl":"set_option hygiene false in\nrun_cmd\n  for typeName' in [`UInt8, `UInt16, `UInt32, `UInt64, `USize] do\n  let typeName := Lean.mkIdent typeName'\n  Lean.Elab.Command.elabCommand (← `(\n    namespace $typeName\n\n      instance : Neg $typeName where\n        neg a := mk ⟨-a.val⟩\n\n      instance : Pow $typeName ℕ where\n        pow a n := mk ⟨a.val ^ n⟩\n\n      instance : SMul ℕ $typeName where\n        smul n a := mk ⟨n • a.val⟩\n\n      instance : SMul ℤ $typeName where\n        smul z a := mk ⟨z • a.val⟩\n\n      lemma neg_def (a : $typeName) : -a = ⟨⟨-a.val⟩⟩ := rfl\n\n      lemma pow_def (a : $typeName) (n : ℕ) : a ^ n = ⟨⟨a.val ^ n⟩⟩ := rfl\n\n      lemma nsmul_def (n : ℕ) (a : $typeName) : n • a = ⟨⟨n • a.val⟩⟩ := rfl\n\n      lemma zsmul_def (z : ℤ) (a : $typeName) : z • a = ⟨⟨z • a.val⟩⟩ := rfl\n\n      open $typeName (eq_of_val_eq) in\n      lemma val_injective : Function.Injective val := @eq_of_val_eq\n\n      open $typeName (eq_of_toBitVec_eq) in\n      lemma toBitVec_injective : Function.Injective toBitVec := @eq_of_toBitVec_eq\n\n      instance instCommMonoid : CommMonoid $typeName :=\n        Function.Injective.commMonoid toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl)\n\n      instance instNonUnitalCommRing : NonUnitalCommRing $typeName :=\n        Function.Injective.nonUnitalCommRing toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl)\n\n      local instance instNatCast : NatCast $typeName where\n        natCast n := mk n\n\n      local instance instIntCast : IntCast $typeName where\n        intCast z := mk z\n\n      lemma natCast_def (n : ℕ) : (n : $typeName) = ⟨n⟩ := rfl\n\n      lemma intCast_def (z : ℤ) : (z : $typeName) = ⟨z⟩ := rfl\n\n      local instance instCommRing : CommRing $typeName :=\n        Function.Injective.commRing toBitVec toBitVec_injective\n          rfl rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ => rfl)\n\n      namespace CommRing\n      attribute [scoped instance] instCommRing instNatCast instIntCast\n      end CommRing\n\n    end $typeName\n  ))\n  -- interpolating docstrings above is more trouble than it's worth\n  let docString :=\n    s!\"To use this instance, use `open scoped {typeName'}.CommRing`.\\n\\n\" ++\n    \"See the module docstring for an explanation\"\n  Lean.addDocString (typeName'.mkStr \"instCommRing\") docString\n  Lean.addDocString (typeName'.mkStr \"instNatCast\") docString\n  Lean.addDocString (typeName'.mkStr \"instIntCast\") docString\n\n"}
{"name":"UInt8.pow_def","module":"Mathlib.Data.UInt","initialProofState":"a : UInt8\nn : Nat\n⊢ Eq (HPow.hPow a n) { toBitVec := { toFin := HPow.hPow a.val n } }","decl":"set_option hygiene false in\nrun_cmd\n  for typeName' in [`UInt8, `UInt16, `UInt32, `UInt64, `USize] do\n  let typeName := Lean.mkIdent typeName'\n  Lean.Elab.Command.elabCommand (← `(\n    namespace $typeName\n\n      instance : Neg $typeName where\n        neg a := mk ⟨-a.val⟩\n\n      instance : Pow $typeName ℕ where\n        pow a n := mk ⟨a.val ^ n⟩\n\n      instance : SMul ℕ $typeName where\n        smul n a := mk ⟨n • a.val⟩\n\n      instance : SMul ℤ $typeName where\n        smul z a := mk ⟨z • a.val⟩\n\n      lemma neg_def (a : $typeName) : -a = ⟨⟨-a.val⟩⟩ := rfl\n\n      lemma pow_def (a : $typeName) (n : ℕ) : a ^ n = ⟨⟨a.val ^ n⟩⟩ := rfl\n\n      lemma nsmul_def (n : ℕ) (a : $typeName) : n • a = ⟨⟨n • a.val⟩⟩ := rfl\n\n      lemma zsmul_def (z : ℤ) (a : $typeName) : z • a = ⟨⟨z • a.val⟩⟩ := rfl\n\n      open $typeName (eq_of_val_eq) in\n      lemma val_injective : Function.Injective val := @eq_of_val_eq\n\n      open $typeName (eq_of_toBitVec_eq) in\n      lemma toBitVec_injective : Function.Injective toBitVec := @eq_of_toBitVec_eq\n\n      instance instCommMonoid : CommMonoid $typeName :=\n        Function.Injective.commMonoid toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl)\n\n      instance instNonUnitalCommRing : NonUnitalCommRing $typeName :=\n        Function.Injective.nonUnitalCommRing toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl)\n\n      local instance instNatCast : NatCast $typeName where\n        natCast n := mk n\n\n      local instance instIntCast : IntCast $typeName where\n        intCast z := mk z\n\n      lemma natCast_def (n : ℕ) : (n : $typeName) = ⟨n⟩ := rfl\n\n      lemma intCast_def (z : ℤ) : (z : $typeName) = ⟨z⟩ := rfl\n\n      local instance instCommRing : CommRing $typeName :=\n        Function.Injective.commRing toBitVec toBitVec_injective\n          rfl rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ => rfl)\n\n      namespace CommRing\n      attribute [scoped instance] instCommRing instNatCast instIntCast\n      end CommRing\n\n    end $typeName\n  ))\n  -- interpolating docstrings above is more trouble than it's worth\n  let docString :=\n    s!\"To use this instance, use `open scoped {typeName'}.CommRing`.\\n\\n\" ++\n    \"See the module docstring for an explanation\"\n  Lean.addDocString (typeName'.mkStr \"instCommRing\") docString\n  Lean.addDocString (typeName'.mkStr \"instNatCast\") docString\n  Lean.addDocString (typeName'.mkStr \"instIntCast\") docString\n\n"}
{"name":"UInt16.neg_def","module":"Mathlib.Data.UInt","initialProofState":"a : UInt16\n⊢ Eq (Neg.neg a) { toBitVec := { toFin := Neg.neg a.val } }","decl":"set_option hygiene false in\nrun_cmd\n  for typeName' in [`UInt8, `UInt16, `UInt32, `UInt64, `USize] do\n  let typeName := Lean.mkIdent typeName'\n  Lean.Elab.Command.elabCommand (← `(\n    namespace $typeName\n\n      instance : Neg $typeName where\n        neg a := mk ⟨-a.val⟩\n\n      instance : Pow $typeName ℕ where\n        pow a n := mk ⟨a.val ^ n⟩\n\n      instance : SMul ℕ $typeName where\n        smul n a := mk ⟨n • a.val⟩\n\n      instance : SMul ℤ $typeName where\n        smul z a := mk ⟨z • a.val⟩\n\n      lemma neg_def (a : $typeName) : -a = ⟨⟨-a.val⟩⟩ := rfl\n\n      lemma pow_def (a : $typeName) (n : ℕ) : a ^ n = ⟨⟨a.val ^ n⟩⟩ := rfl\n\n      lemma nsmul_def (n : ℕ) (a : $typeName) : n • a = ⟨⟨n • a.val⟩⟩ := rfl\n\n      lemma zsmul_def (z : ℤ) (a : $typeName) : z • a = ⟨⟨z • a.val⟩⟩ := rfl\n\n      open $typeName (eq_of_val_eq) in\n      lemma val_injective : Function.Injective val := @eq_of_val_eq\n\n      open $typeName (eq_of_toBitVec_eq) in\n      lemma toBitVec_injective : Function.Injective toBitVec := @eq_of_toBitVec_eq\n\n      instance instCommMonoid : CommMonoid $typeName :=\n        Function.Injective.commMonoid toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl)\n\n      instance instNonUnitalCommRing : NonUnitalCommRing $typeName :=\n        Function.Injective.nonUnitalCommRing toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl)\n\n      local instance instNatCast : NatCast $typeName where\n        natCast n := mk n\n\n      local instance instIntCast : IntCast $typeName where\n        intCast z := mk z\n\n      lemma natCast_def (n : ℕ) : (n : $typeName) = ⟨n⟩ := rfl\n\n      lemma intCast_def (z : ℤ) : (z : $typeName) = ⟨z⟩ := rfl\n\n      local instance instCommRing : CommRing $typeName :=\n        Function.Injective.commRing toBitVec toBitVec_injective\n          rfl rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ => rfl)\n\n      namespace CommRing\n      attribute [scoped instance] instCommRing instNatCast instIntCast\n      end CommRing\n\n    end $typeName\n  ))\n  -- interpolating docstrings above is more trouble than it's worth\n  let docString :=\n    s!\"To use this instance, use `open scoped {typeName'}.CommRing`.\\n\\n\" ++\n    \"See the module docstring for an explanation\"\n  Lean.addDocString (typeName'.mkStr \"instCommRing\") docString\n  Lean.addDocString (typeName'.mkStr \"instNatCast\") docString\n  Lean.addDocString (typeName'.mkStr \"instIntCast\") docString\n\n"}
{"name":"UInt8.zsmul_def","module":"Mathlib.Data.UInt","initialProofState":"z : Int\na : UInt8\n⊢ Eq (HSMul.hSMul z a) { toBitVec := { toFin := HSMul.hSMul z a.val } }","decl":"set_option hygiene false in\nrun_cmd\n  for typeName' in [`UInt8, `UInt16, `UInt32, `UInt64, `USize] do\n  let typeName := Lean.mkIdent typeName'\n  Lean.Elab.Command.elabCommand (← `(\n    namespace $typeName\n\n      instance : Neg $typeName where\n        neg a := mk ⟨-a.val⟩\n\n      instance : Pow $typeName ℕ where\n        pow a n := mk ⟨a.val ^ n⟩\n\n      instance : SMul ℕ $typeName where\n        smul n a := mk ⟨n • a.val⟩\n\n      instance : SMul ℤ $typeName where\n        smul z a := mk ⟨z • a.val⟩\n\n      lemma neg_def (a : $typeName) : -a = ⟨⟨-a.val⟩⟩ := rfl\n\n      lemma pow_def (a : $typeName) (n : ℕ) : a ^ n = ⟨⟨a.val ^ n⟩⟩ := rfl\n\n      lemma nsmul_def (n : ℕ) (a : $typeName) : n • a = ⟨⟨n • a.val⟩⟩ := rfl\n\n      lemma zsmul_def (z : ℤ) (a : $typeName) : z • a = ⟨⟨z • a.val⟩⟩ := rfl\n\n      open $typeName (eq_of_val_eq) in\n      lemma val_injective : Function.Injective val := @eq_of_val_eq\n\n      open $typeName (eq_of_toBitVec_eq) in\n      lemma toBitVec_injective : Function.Injective toBitVec := @eq_of_toBitVec_eq\n\n      instance instCommMonoid : CommMonoid $typeName :=\n        Function.Injective.commMonoid toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl)\n\n      instance instNonUnitalCommRing : NonUnitalCommRing $typeName :=\n        Function.Injective.nonUnitalCommRing toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl)\n\n      local instance instNatCast : NatCast $typeName where\n        natCast n := mk n\n\n      local instance instIntCast : IntCast $typeName where\n        intCast z := mk z\n\n      lemma natCast_def (n : ℕ) : (n : $typeName) = ⟨n⟩ := rfl\n\n      lemma intCast_def (z : ℤ) : (z : $typeName) = ⟨z⟩ := rfl\n\n      local instance instCommRing : CommRing $typeName :=\n        Function.Injective.commRing toBitVec toBitVec_injective\n          rfl rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ => rfl)\n\n      namespace CommRing\n      attribute [scoped instance] instCommRing instNatCast instIntCast\n      end CommRing\n\n    end $typeName\n  ))\n  -- interpolating docstrings above is more trouble than it's worth\n  let docString :=\n    s!\"To use this instance, use `open scoped {typeName'}.CommRing`.\\n\\n\" ++\n    \"See the module docstring for an explanation\"\n  Lean.addDocString (typeName'.mkStr \"instCommRing\") docString\n  Lean.addDocString (typeName'.mkStr \"instNatCast\") docString\n  Lean.addDocString (typeName'.mkStr \"instIntCast\") docString\n\n"}
{"name":"UInt16.toBitVec_injective","module":"Mathlib.Data.UInt","initialProofState":"⊢ Function.Injective UInt16.toBitVec","decl":"set_option hygiene false in\nrun_cmd\n  for typeName' in [`UInt8, `UInt16, `UInt32, `UInt64, `USize] do\n  let typeName := Lean.mkIdent typeName'\n  Lean.Elab.Command.elabCommand (← `(\n    namespace $typeName\n\n      instance : Neg $typeName where\n        neg a := mk ⟨-a.val⟩\n\n      instance : Pow $typeName ℕ where\n        pow a n := mk ⟨a.val ^ n⟩\n\n      instance : SMul ℕ $typeName where\n        smul n a := mk ⟨n • a.val⟩\n\n      instance : SMul ℤ $typeName where\n        smul z a := mk ⟨z • a.val⟩\n\n      lemma neg_def (a : $typeName) : -a = ⟨⟨-a.val⟩⟩ := rfl\n\n      lemma pow_def (a : $typeName) (n : ℕ) : a ^ n = ⟨⟨a.val ^ n⟩⟩ := rfl\n\n      lemma nsmul_def (n : ℕ) (a : $typeName) : n • a = ⟨⟨n • a.val⟩⟩ := rfl\n\n      lemma zsmul_def (z : ℤ) (a : $typeName) : z • a = ⟨⟨z • a.val⟩⟩ := rfl\n\n      open $typeName (eq_of_val_eq) in\n      lemma val_injective : Function.Injective val := @eq_of_val_eq\n\n      open $typeName (eq_of_toBitVec_eq) in\n      lemma toBitVec_injective : Function.Injective toBitVec := @eq_of_toBitVec_eq\n\n      instance instCommMonoid : CommMonoid $typeName :=\n        Function.Injective.commMonoid toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl)\n\n      instance instNonUnitalCommRing : NonUnitalCommRing $typeName :=\n        Function.Injective.nonUnitalCommRing toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl)\n\n      local instance instNatCast : NatCast $typeName where\n        natCast n := mk n\n\n      local instance instIntCast : IntCast $typeName where\n        intCast z := mk z\n\n      lemma natCast_def (n : ℕ) : (n : $typeName) = ⟨n⟩ := rfl\n\n      lemma intCast_def (z : ℤ) : (z : $typeName) = ⟨z⟩ := rfl\n\n      local instance instCommRing : CommRing $typeName :=\n        Function.Injective.commRing toBitVec toBitVec_injective\n          rfl rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ => rfl)\n\n      namespace CommRing\n      attribute [scoped instance] instCommRing instNatCast instIntCast\n      end CommRing\n\n    end $typeName\n  ))\n  -- interpolating docstrings above is more trouble than it's worth\n  let docString :=\n    s!\"To use this instance, use `open scoped {typeName'}.CommRing`.\\n\\n\" ++\n    \"See the module docstring for an explanation\"\n  Lean.addDocString (typeName'.mkStr \"instCommRing\") docString\n  Lean.addDocString (typeName'.mkStr \"instNatCast\") docString\n  Lean.addDocString (typeName'.mkStr \"instIntCast\") docString\n\n"}
{"name":"USize.zsmul_def","module":"Mathlib.Data.UInt","initialProofState":"z : Int\na : USize\n⊢ Eq (HSMul.hSMul z a) { toBitVec := { toFin := HSMul.hSMul z a.val } }","decl":"set_option hygiene false in\nrun_cmd\n  for typeName' in [`UInt8, `UInt16, `UInt32, `UInt64, `USize] do\n  let typeName := Lean.mkIdent typeName'\n  Lean.Elab.Command.elabCommand (← `(\n    namespace $typeName\n\n      instance : Neg $typeName where\n        neg a := mk ⟨-a.val⟩\n\n      instance : Pow $typeName ℕ where\n        pow a n := mk ⟨a.val ^ n⟩\n\n      instance : SMul ℕ $typeName where\n        smul n a := mk ⟨n • a.val⟩\n\n      instance : SMul ℤ $typeName where\n        smul z a := mk ⟨z • a.val⟩\n\n      lemma neg_def (a : $typeName) : -a = ⟨⟨-a.val⟩⟩ := rfl\n\n      lemma pow_def (a : $typeName) (n : ℕ) : a ^ n = ⟨⟨a.val ^ n⟩⟩ := rfl\n\n      lemma nsmul_def (n : ℕ) (a : $typeName) : n • a = ⟨⟨n • a.val⟩⟩ := rfl\n\n      lemma zsmul_def (z : ℤ) (a : $typeName) : z • a = ⟨⟨z • a.val⟩⟩ := rfl\n\n      open $typeName (eq_of_val_eq) in\n      lemma val_injective : Function.Injective val := @eq_of_val_eq\n\n      open $typeName (eq_of_toBitVec_eq) in\n      lemma toBitVec_injective : Function.Injective toBitVec := @eq_of_toBitVec_eq\n\n      instance instCommMonoid : CommMonoid $typeName :=\n        Function.Injective.commMonoid toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl)\n\n      instance instNonUnitalCommRing : NonUnitalCommRing $typeName :=\n        Function.Injective.nonUnitalCommRing toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl)\n\n      local instance instNatCast : NatCast $typeName where\n        natCast n := mk n\n\n      local instance instIntCast : IntCast $typeName where\n        intCast z := mk z\n\n      lemma natCast_def (n : ℕ) : (n : $typeName) = ⟨n⟩ := rfl\n\n      lemma intCast_def (z : ℤ) : (z : $typeName) = ⟨z⟩ := rfl\n\n      local instance instCommRing : CommRing $typeName :=\n        Function.Injective.commRing toBitVec toBitVec_injective\n          rfl rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ => rfl)\n\n      namespace CommRing\n      attribute [scoped instance] instCommRing instNatCast instIntCast\n      end CommRing\n\n    end $typeName\n  ))\n  -- interpolating docstrings above is more trouble than it's worth\n  let docString :=\n    s!\"To use this instance, use `open scoped {typeName'}.CommRing`.\\n\\n\" ++\n    \"See the module docstring for an explanation\"\n  Lean.addDocString (typeName'.mkStr \"instCommRing\") docString\n  Lean.addDocString (typeName'.mkStr \"instNatCast\") docString\n  Lean.addDocString (typeName'.mkStr \"instIntCast\") docString\n\n"}
{"name":"UInt32.pow_def","module":"Mathlib.Data.UInt","initialProofState":"a : UInt32\nn : Nat\n⊢ Eq (HPow.hPow a n) { toBitVec := { toFin := HPow.hPow a.val n } }","decl":"set_option hygiene false in\nrun_cmd\n  for typeName' in [`UInt8, `UInt16, `UInt32, `UInt64, `USize] do\n  let typeName := Lean.mkIdent typeName'\n  Lean.Elab.Command.elabCommand (← `(\n    namespace $typeName\n\n      instance : Neg $typeName where\n        neg a := mk ⟨-a.val⟩\n\n      instance : Pow $typeName ℕ where\n        pow a n := mk ⟨a.val ^ n⟩\n\n      instance : SMul ℕ $typeName where\n        smul n a := mk ⟨n • a.val⟩\n\n      instance : SMul ℤ $typeName where\n        smul z a := mk ⟨z • a.val⟩\n\n      lemma neg_def (a : $typeName) : -a = ⟨⟨-a.val⟩⟩ := rfl\n\n      lemma pow_def (a : $typeName) (n : ℕ) : a ^ n = ⟨⟨a.val ^ n⟩⟩ := rfl\n\n      lemma nsmul_def (n : ℕ) (a : $typeName) : n • a = ⟨⟨n • a.val⟩⟩ := rfl\n\n      lemma zsmul_def (z : ℤ) (a : $typeName) : z • a = ⟨⟨z • a.val⟩⟩ := rfl\n\n      open $typeName (eq_of_val_eq) in\n      lemma val_injective : Function.Injective val := @eq_of_val_eq\n\n      open $typeName (eq_of_toBitVec_eq) in\n      lemma toBitVec_injective : Function.Injective toBitVec := @eq_of_toBitVec_eq\n\n      instance instCommMonoid : CommMonoid $typeName :=\n        Function.Injective.commMonoid toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl)\n\n      instance instNonUnitalCommRing : NonUnitalCommRing $typeName :=\n        Function.Injective.nonUnitalCommRing toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl)\n\n      local instance instNatCast : NatCast $typeName where\n        natCast n := mk n\n\n      local instance instIntCast : IntCast $typeName where\n        intCast z := mk z\n\n      lemma natCast_def (n : ℕ) : (n : $typeName) = ⟨n⟩ := rfl\n\n      lemma intCast_def (z : ℤ) : (z : $typeName) = ⟨z⟩ := rfl\n\n      local instance instCommRing : CommRing $typeName :=\n        Function.Injective.commRing toBitVec toBitVec_injective\n          rfl rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ => rfl)\n\n      namespace CommRing\n      attribute [scoped instance] instCommRing instNatCast instIntCast\n      end CommRing\n\n    end $typeName\n  ))\n  -- interpolating docstrings above is more trouble than it's worth\n  let docString :=\n    s!\"To use this instance, use `open scoped {typeName'}.CommRing`.\\n\\n\" ++\n    \"See the module docstring for an explanation\"\n  Lean.addDocString (typeName'.mkStr \"instCommRing\") docString\n  Lean.addDocString (typeName'.mkStr \"instNatCast\") docString\n  Lean.addDocString (typeName'.mkStr \"instIntCast\") docString\n\n"}
{"name":"UInt64.val_injective","module":"Mathlib.Data.UInt","initialProofState":"⊢ Function.Injective UInt64.val","decl":"set_option hygiene false in\nrun_cmd\n  for typeName' in [`UInt8, `UInt16, `UInt32, `UInt64, `USize] do\n  let typeName := Lean.mkIdent typeName'\n  Lean.Elab.Command.elabCommand (← `(\n    namespace $typeName\n\n      instance : Neg $typeName where\n        neg a := mk ⟨-a.val⟩\n\n      instance : Pow $typeName ℕ where\n        pow a n := mk ⟨a.val ^ n⟩\n\n      instance : SMul ℕ $typeName where\n        smul n a := mk ⟨n • a.val⟩\n\n      instance : SMul ℤ $typeName where\n        smul z a := mk ⟨z • a.val⟩\n\n      lemma neg_def (a : $typeName) : -a = ⟨⟨-a.val⟩⟩ := rfl\n\n      lemma pow_def (a : $typeName) (n : ℕ) : a ^ n = ⟨⟨a.val ^ n⟩⟩ := rfl\n\n      lemma nsmul_def (n : ℕ) (a : $typeName) : n • a = ⟨⟨n • a.val⟩⟩ := rfl\n\n      lemma zsmul_def (z : ℤ) (a : $typeName) : z • a = ⟨⟨z • a.val⟩⟩ := rfl\n\n      open $typeName (eq_of_val_eq) in\n      lemma val_injective : Function.Injective val := @eq_of_val_eq\n\n      open $typeName (eq_of_toBitVec_eq) in\n      lemma toBitVec_injective : Function.Injective toBitVec := @eq_of_toBitVec_eq\n\n      instance instCommMonoid : CommMonoid $typeName :=\n        Function.Injective.commMonoid toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl)\n\n      instance instNonUnitalCommRing : NonUnitalCommRing $typeName :=\n        Function.Injective.nonUnitalCommRing toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl)\n\n      local instance instNatCast : NatCast $typeName where\n        natCast n := mk n\n\n      local instance instIntCast : IntCast $typeName where\n        intCast z := mk z\n\n      lemma natCast_def (n : ℕ) : (n : $typeName) = ⟨n⟩ := rfl\n\n      lemma intCast_def (z : ℤ) : (z : $typeName) = ⟨z⟩ := rfl\n\n      local instance instCommRing : CommRing $typeName :=\n        Function.Injective.commRing toBitVec toBitVec_injective\n          rfl rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ => rfl)\n\n      namespace CommRing\n      attribute [scoped instance] instCommRing instNatCast instIntCast\n      end CommRing\n\n    end $typeName\n  ))\n  -- interpolating docstrings above is more trouble than it's worth\n  let docString :=\n    s!\"To use this instance, use `open scoped {typeName'}.CommRing`.\\n\\n\" ++\n    \"See the module docstring for an explanation\"\n  Lean.addDocString (typeName'.mkStr \"instCommRing\") docString\n  Lean.addDocString (typeName'.mkStr \"instNatCast\") docString\n  Lean.addDocString (typeName'.mkStr \"instIntCast\") docString\n\n"}
{"name":"UInt64.intCast_def","module":"Mathlib.Data.UInt","initialProofState":"z : Int\n⊢ Eq ↑z { toBitVec := ↑z }","decl":"set_option hygiene false in\nrun_cmd\n  for typeName' in [`UInt8, `UInt16, `UInt32, `UInt64, `USize] do\n  let typeName := Lean.mkIdent typeName'\n  Lean.Elab.Command.elabCommand (← `(\n    namespace $typeName\n\n      instance : Neg $typeName where\n        neg a := mk ⟨-a.val⟩\n\n      instance : Pow $typeName ℕ where\n        pow a n := mk ⟨a.val ^ n⟩\n\n      instance : SMul ℕ $typeName where\n        smul n a := mk ⟨n • a.val⟩\n\n      instance : SMul ℤ $typeName where\n        smul z a := mk ⟨z • a.val⟩\n\n      lemma neg_def (a : $typeName) : -a = ⟨⟨-a.val⟩⟩ := rfl\n\n      lemma pow_def (a : $typeName) (n : ℕ) : a ^ n = ⟨⟨a.val ^ n⟩⟩ := rfl\n\n      lemma nsmul_def (n : ℕ) (a : $typeName) : n • a = ⟨⟨n • a.val⟩⟩ := rfl\n\n      lemma zsmul_def (z : ℤ) (a : $typeName) : z • a = ⟨⟨z • a.val⟩⟩ := rfl\n\n      open $typeName (eq_of_val_eq) in\n      lemma val_injective : Function.Injective val := @eq_of_val_eq\n\n      open $typeName (eq_of_toBitVec_eq) in\n      lemma toBitVec_injective : Function.Injective toBitVec := @eq_of_toBitVec_eq\n\n      instance instCommMonoid : CommMonoid $typeName :=\n        Function.Injective.commMonoid toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl)\n\n      instance instNonUnitalCommRing : NonUnitalCommRing $typeName :=\n        Function.Injective.nonUnitalCommRing toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl)\n\n      local instance instNatCast : NatCast $typeName where\n        natCast n := mk n\n\n      local instance instIntCast : IntCast $typeName where\n        intCast z := mk z\n\n      lemma natCast_def (n : ℕ) : (n : $typeName) = ⟨n⟩ := rfl\n\n      lemma intCast_def (z : ℤ) : (z : $typeName) = ⟨z⟩ := rfl\n\n      local instance instCommRing : CommRing $typeName :=\n        Function.Injective.commRing toBitVec toBitVec_injective\n          rfl rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ => rfl)\n\n      namespace CommRing\n      attribute [scoped instance] instCommRing instNatCast instIntCast\n      end CommRing\n\n    end $typeName\n  ))\n  -- interpolating docstrings above is more trouble than it's worth\n  let docString :=\n    s!\"To use this instance, use `open scoped {typeName'}.CommRing`.\\n\\n\" ++\n    \"See the module docstring for an explanation\"\n  Lean.addDocString (typeName'.mkStr \"instCommRing\") docString\n  Lean.addDocString (typeName'.mkStr \"instNatCast\") docString\n  Lean.addDocString (typeName'.mkStr \"instIntCast\") docString\n\n"}
{"name":"USize.natCast_def","module":"Mathlib.Data.UInt","initialProofState":"n : Nat\n⊢ Eq ↑n { toBitVec := ↑n }","decl":"set_option hygiene false in\nrun_cmd\n  for typeName' in [`UInt8, `UInt16, `UInt32, `UInt64, `USize] do\n  let typeName := Lean.mkIdent typeName'\n  Lean.Elab.Command.elabCommand (← `(\n    namespace $typeName\n\n      instance : Neg $typeName where\n        neg a := mk ⟨-a.val⟩\n\n      instance : Pow $typeName ℕ where\n        pow a n := mk ⟨a.val ^ n⟩\n\n      instance : SMul ℕ $typeName where\n        smul n a := mk ⟨n • a.val⟩\n\n      instance : SMul ℤ $typeName where\n        smul z a := mk ⟨z • a.val⟩\n\n      lemma neg_def (a : $typeName) : -a = ⟨⟨-a.val⟩⟩ := rfl\n\n      lemma pow_def (a : $typeName) (n : ℕ) : a ^ n = ⟨⟨a.val ^ n⟩⟩ := rfl\n\n      lemma nsmul_def (n : ℕ) (a : $typeName) : n • a = ⟨⟨n • a.val⟩⟩ := rfl\n\n      lemma zsmul_def (z : ℤ) (a : $typeName) : z • a = ⟨⟨z • a.val⟩⟩ := rfl\n\n      open $typeName (eq_of_val_eq) in\n      lemma val_injective : Function.Injective val := @eq_of_val_eq\n\n      open $typeName (eq_of_toBitVec_eq) in\n      lemma toBitVec_injective : Function.Injective toBitVec := @eq_of_toBitVec_eq\n\n      instance instCommMonoid : CommMonoid $typeName :=\n        Function.Injective.commMonoid toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl)\n\n      instance instNonUnitalCommRing : NonUnitalCommRing $typeName :=\n        Function.Injective.nonUnitalCommRing toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl)\n\n      local instance instNatCast : NatCast $typeName where\n        natCast n := mk n\n\n      local instance instIntCast : IntCast $typeName where\n        intCast z := mk z\n\n      lemma natCast_def (n : ℕ) : (n : $typeName) = ⟨n⟩ := rfl\n\n      lemma intCast_def (z : ℤ) : (z : $typeName) = ⟨z⟩ := rfl\n\n      local instance instCommRing : CommRing $typeName :=\n        Function.Injective.commRing toBitVec toBitVec_injective\n          rfl rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ => rfl)\n\n      namespace CommRing\n      attribute [scoped instance] instCommRing instNatCast instIntCast\n      end CommRing\n\n    end $typeName\n  ))\n  -- interpolating docstrings above is more trouble than it's worth\n  let docString :=\n    s!\"To use this instance, use `open scoped {typeName'}.CommRing`.\\n\\n\" ++\n    \"See the module docstring for an explanation\"\n  Lean.addDocString (typeName'.mkStr \"instCommRing\") docString\n  Lean.addDocString (typeName'.mkStr \"instNatCast\") docString\n  Lean.addDocString (typeName'.mkStr \"instIntCast\") docString\n\n"}
{"name":"UInt16.nsmul_def","module":"Mathlib.Data.UInt","initialProofState":"n : Nat\na : UInt16\n⊢ Eq (HSMul.hSMul n a) { toBitVec := { toFin := HSMul.hSMul n a.val } }","decl":"set_option hygiene false in\nrun_cmd\n  for typeName' in [`UInt8, `UInt16, `UInt32, `UInt64, `USize] do\n  let typeName := Lean.mkIdent typeName'\n  Lean.Elab.Command.elabCommand (← `(\n    namespace $typeName\n\n      instance : Neg $typeName where\n        neg a := mk ⟨-a.val⟩\n\n      instance : Pow $typeName ℕ where\n        pow a n := mk ⟨a.val ^ n⟩\n\n      instance : SMul ℕ $typeName where\n        smul n a := mk ⟨n • a.val⟩\n\n      instance : SMul ℤ $typeName where\n        smul z a := mk ⟨z • a.val⟩\n\n      lemma neg_def (a : $typeName) : -a = ⟨⟨-a.val⟩⟩ := rfl\n\n      lemma pow_def (a : $typeName) (n : ℕ) : a ^ n = ⟨⟨a.val ^ n⟩⟩ := rfl\n\n      lemma nsmul_def (n : ℕ) (a : $typeName) : n • a = ⟨⟨n • a.val⟩⟩ := rfl\n\n      lemma zsmul_def (z : ℤ) (a : $typeName) : z • a = ⟨⟨z • a.val⟩⟩ := rfl\n\n      open $typeName (eq_of_val_eq) in\n      lemma val_injective : Function.Injective val := @eq_of_val_eq\n\n      open $typeName (eq_of_toBitVec_eq) in\n      lemma toBitVec_injective : Function.Injective toBitVec := @eq_of_toBitVec_eq\n\n      instance instCommMonoid : CommMonoid $typeName :=\n        Function.Injective.commMonoid toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl)\n\n      instance instNonUnitalCommRing : NonUnitalCommRing $typeName :=\n        Function.Injective.nonUnitalCommRing toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl)\n\n      local instance instNatCast : NatCast $typeName where\n        natCast n := mk n\n\n      local instance instIntCast : IntCast $typeName where\n        intCast z := mk z\n\n      lemma natCast_def (n : ℕ) : (n : $typeName) = ⟨n⟩ := rfl\n\n      lemma intCast_def (z : ℤ) : (z : $typeName) = ⟨z⟩ := rfl\n\n      local instance instCommRing : CommRing $typeName :=\n        Function.Injective.commRing toBitVec toBitVec_injective\n          rfl rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ => rfl)\n\n      namespace CommRing\n      attribute [scoped instance] instCommRing instNatCast instIntCast\n      end CommRing\n\n    end $typeName\n  ))\n  -- interpolating docstrings above is more trouble than it's worth\n  let docString :=\n    s!\"To use this instance, use `open scoped {typeName'}.CommRing`.\\n\\n\" ++\n    \"See the module docstring for an explanation\"\n  Lean.addDocString (typeName'.mkStr \"instCommRing\") docString\n  Lean.addDocString (typeName'.mkStr \"instNatCast\") docString\n  Lean.addDocString (typeName'.mkStr \"instIntCast\") docString\n\n"}
{"name":"USize.toBitVec_injective","module":"Mathlib.Data.UInt","initialProofState":"⊢ Function.Injective USize.toBitVec","decl":"set_option hygiene false in\nrun_cmd\n  for typeName' in [`UInt8, `UInt16, `UInt32, `UInt64, `USize] do\n  let typeName := Lean.mkIdent typeName'\n  Lean.Elab.Command.elabCommand (← `(\n    namespace $typeName\n\n      instance : Neg $typeName where\n        neg a := mk ⟨-a.val⟩\n\n      instance : Pow $typeName ℕ where\n        pow a n := mk ⟨a.val ^ n⟩\n\n      instance : SMul ℕ $typeName where\n        smul n a := mk ⟨n • a.val⟩\n\n      instance : SMul ℤ $typeName where\n        smul z a := mk ⟨z • a.val⟩\n\n      lemma neg_def (a : $typeName) : -a = ⟨⟨-a.val⟩⟩ := rfl\n\n      lemma pow_def (a : $typeName) (n : ℕ) : a ^ n = ⟨⟨a.val ^ n⟩⟩ := rfl\n\n      lemma nsmul_def (n : ℕ) (a : $typeName) : n • a = ⟨⟨n • a.val⟩⟩ := rfl\n\n      lemma zsmul_def (z : ℤ) (a : $typeName) : z • a = ⟨⟨z • a.val⟩⟩ := rfl\n\n      open $typeName (eq_of_val_eq) in\n      lemma val_injective : Function.Injective val := @eq_of_val_eq\n\n      open $typeName (eq_of_toBitVec_eq) in\n      lemma toBitVec_injective : Function.Injective toBitVec := @eq_of_toBitVec_eq\n\n      instance instCommMonoid : CommMonoid $typeName :=\n        Function.Injective.commMonoid toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl)\n\n      instance instNonUnitalCommRing : NonUnitalCommRing $typeName :=\n        Function.Injective.nonUnitalCommRing toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl)\n\n      local instance instNatCast : NatCast $typeName where\n        natCast n := mk n\n\n      local instance instIntCast : IntCast $typeName where\n        intCast z := mk z\n\n      lemma natCast_def (n : ℕ) : (n : $typeName) = ⟨n⟩ := rfl\n\n      lemma intCast_def (z : ℤ) : (z : $typeName) = ⟨z⟩ := rfl\n\n      local instance instCommRing : CommRing $typeName :=\n        Function.Injective.commRing toBitVec toBitVec_injective\n          rfl rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ => rfl)\n\n      namespace CommRing\n      attribute [scoped instance] instCommRing instNatCast instIntCast\n      end CommRing\n\n    end $typeName\n  ))\n  -- interpolating docstrings above is more trouble than it's worth\n  let docString :=\n    s!\"To use this instance, use `open scoped {typeName'}.CommRing`.\\n\\n\" ++\n    \"See the module docstring for an explanation\"\n  Lean.addDocString (typeName'.mkStr \"instCommRing\") docString\n  Lean.addDocString (typeName'.mkStr \"instNatCast\") docString\n  Lean.addDocString (typeName'.mkStr \"instIntCast\") docString\n\n"}
{"name":"USize.neg_def","module":"Mathlib.Data.UInt","initialProofState":"a : USize\n⊢ Eq (Neg.neg a) { toBitVec := { toFin := Neg.neg a.val } }","decl":"set_option hygiene false in\nrun_cmd\n  for typeName' in [`UInt8, `UInt16, `UInt32, `UInt64, `USize] do\n  let typeName := Lean.mkIdent typeName'\n  Lean.Elab.Command.elabCommand (← `(\n    namespace $typeName\n\n      instance : Neg $typeName where\n        neg a := mk ⟨-a.val⟩\n\n      instance : Pow $typeName ℕ where\n        pow a n := mk ⟨a.val ^ n⟩\n\n      instance : SMul ℕ $typeName where\n        smul n a := mk ⟨n • a.val⟩\n\n      instance : SMul ℤ $typeName where\n        smul z a := mk ⟨z • a.val⟩\n\n      lemma neg_def (a : $typeName) : -a = ⟨⟨-a.val⟩⟩ := rfl\n\n      lemma pow_def (a : $typeName) (n : ℕ) : a ^ n = ⟨⟨a.val ^ n⟩⟩ := rfl\n\n      lemma nsmul_def (n : ℕ) (a : $typeName) : n • a = ⟨⟨n • a.val⟩⟩ := rfl\n\n      lemma zsmul_def (z : ℤ) (a : $typeName) : z • a = ⟨⟨z • a.val⟩⟩ := rfl\n\n      open $typeName (eq_of_val_eq) in\n      lemma val_injective : Function.Injective val := @eq_of_val_eq\n\n      open $typeName (eq_of_toBitVec_eq) in\n      lemma toBitVec_injective : Function.Injective toBitVec := @eq_of_toBitVec_eq\n\n      instance instCommMonoid : CommMonoid $typeName :=\n        Function.Injective.commMonoid toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl)\n\n      instance instNonUnitalCommRing : NonUnitalCommRing $typeName :=\n        Function.Injective.nonUnitalCommRing toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl)\n\n      local instance instNatCast : NatCast $typeName where\n        natCast n := mk n\n\n      local instance instIntCast : IntCast $typeName where\n        intCast z := mk z\n\n      lemma natCast_def (n : ℕ) : (n : $typeName) = ⟨n⟩ := rfl\n\n      lemma intCast_def (z : ℤ) : (z : $typeName) = ⟨z⟩ := rfl\n\n      local instance instCommRing : CommRing $typeName :=\n        Function.Injective.commRing toBitVec toBitVec_injective\n          rfl rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ => rfl)\n\n      namespace CommRing\n      attribute [scoped instance] instCommRing instNatCast instIntCast\n      end CommRing\n\n    end $typeName\n  ))\n  -- interpolating docstrings above is more trouble than it's worth\n  let docString :=\n    s!\"To use this instance, use `open scoped {typeName'}.CommRing`.\\n\\n\" ++\n    \"See the module docstring for an explanation\"\n  Lean.addDocString (typeName'.mkStr \"instCommRing\") docString\n  Lean.addDocString (typeName'.mkStr \"instNatCast\") docString\n  Lean.addDocString (typeName'.mkStr \"instIntCast\") docString\n\n"}
{"name":"USize.nsmul_def","module":"Mathlib.Data.UInt","initialProofState":"n : Nat\na : USize\n⊢ Eq (HSMul.hSMul n a) { toBitVec := { toFin := HSMul.hSMul n a.val } }","decl":"set_option hygiene false in\nrun_cmd\n  for typeName' in [`UInt8, `UInt16, `UInt32, `UInt64, `USize] do\n  let typeName := Lean.mkIdent typeName'\n  Lean.Elab.Command.elabCommand (← `(\n    namespace $typeName\n\n      instance : Neg $typeName where\n        neg a := mk ⟨-a.val⟩\n\n      instance : Pow $typeName ℕ where\n        pow a n := mk ⟨a.val ^ n⟩\n\n      instance : SMul ℕ $typeName where\n        smul n a := mk ⟨n • a.val⟩\n\n      instance : SMul ℤ $typeName where\n        smul z a := mk ⟨z • a.val⟩\n\n      lemma neg_def (a : $typeName) : -a = ⟨⟨-a.val⟩⟩ := rfl\n\n      lemma pow_def (a : $typeName) (n : ℕ) : a ^ n = ⟨⟨a.val ^ n⟩⟩ := rfl\n\n      lemma nsmul_def (n : ℕ) (a : $typeName) : n • a = ⟨⟨n • a.val⟩⟩ := rfl\n\n      lemma zsmul_def (z : ℤ) (a : $typeName) : z • a = ⟨⟨z • a.val⟩⟩ := rfl\n\n      open $typeName (eq_of_val_eq) in\n      lemma val_injective : Function.Injective val := @eq_of_val_eq\n\n      open $typeName (eq_of_toBitVec_eq) in\n      lemma toBitVec_injective : Function.Injective toBitVec := @eq_of_toBitVec_eq\n\n      instance instCommMonoid : CommMonoid $typeName :=\n        Function.Injective.commMonoid toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl)\n\n      instance instNonUnitalCommRing : NonUnitalCommRing $typeName :=\n        Function.Injective.nonUnitalCommRing toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl)\n\n      local instance instNatCast : NatCast $typeName where\n        natCast n := mk n\n\n      local instance instIntCast : IntCast $typeName where\n        intCast z := mk z\n\n      lemma natCast_def (n : ℕ) : (n : $typeName) = ⟨n⟩ := rfl\n\n      lemma intCast_def (z : ℤ) : (z : $typeName) = ⟨z⟩ := rfl\n\n      local instance instCommRing : CommRing $typeName :=\n        Function.Injective.commRing toBitVec toBitVec_injective\n          rfl rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ => rfl)\n\n      namespace CommRing\n      attribute [scoped instance] instCommRing instNatCast instIntCast\n      end CommRing\n\n    end $typeName\n  ))\n  -- interpolating docstrings above is more trouble than it's worth\n  let docString :=\n    s!\"To use this instance, use `open scoped {typeName'}.CommRing`.\\n\\n\" ++\n    \"See the module docstring for an explanation\"\n  Lean.addDocString (typeName'.mkStr \"instCommRing\") docString\n  Lean.addDocString (typeName'.mkStr \"instNatCast\") docString\n  Lean.addDocString (typeName'.mkStr \"instIntCast\") docString\n\n"}
{"name":"UInt16.natCast_def","module":"Mathlib.Data.UInt","initialProofState":"n : Nat\n⊢ Eq ↑n { toBitVec := ↑n }","decl":"set_option hygiene false in\nrun_cmd\n  for typeName' in [`UInt8, `UInt16, `UInt32, `UInt64, `USize] do\n  let typeName := Lean.mkIdent typeName'\n  Lean.Elab.Command.elabCommand (← `(\n    namespace $typeName\n\n      instance : Neg $typeName where\n        neg a := mk ⟨-a.val⟩\n\n      instance : Pow $typeName ℕ where\n        pow a n := mk ⟨a.val ^ n⟩\n\n      instance : SMul ℕ $typeName where\n        smul n a := mk ⟨n • a.val⟩\n\n      instance : SMul ℤ $typeName where\n        smul z a := mk ⟨z • a.val⟩\n\n      lemma neg_def (a : $typeName) : -a = ⟨⟨-a.val⟩⟩ := rfl\n\n      lemma pow_def (a : $typeName) (n : ℕ) : a ^ n = ⟨⟨a.val ^ n⟩⟩ := rfl\n\n      lemma nsmul_def (n : ℕ) (a : $typeName) : n • a = ⟨⟨n • a.val⟩⟩ := rfl\n\n      lemma zsmul_def (z : ℤ) (a : $typeName) : z • a = ⟨⟨z • a.val⟩⟩ := rfl\n\n      open $typeName (eq_of_val_eq) in\n      lemma val_injective : Function.Injective val := @eq_of_val_eq\n\n      open $typeName (eq_of_toBitVec_eq) in\n      lemma toBitVec_injective : Function.Injective toBitVec := @eq_of_toBitVec_eq\n\n      instance instCommMonoid : CommMonoid $typeName :=\n        Function.Injective.commMonoid toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl)\n\n      instance instNonUnitalCommRing : NonUnitalCommRing $typeName :=\n        Function.Injective.nonUnitalCommRing toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl)\n\n      local instance instNatCast : NatCast $typeName where\n        natCast n := mk n\n\n      local instance instIntCast : IntCast $typeName where\n        intCast z := mk z\n\n      lemma natCast_def (n : ℕ) : (n : $typeName) = ⟨n⟩ := rfl\n\n      lemma intCast_def (z : ℤ) : (z : $typeName) = ⟨z⟩ := rfl\n\n      local instance instCommRing : CommRing $typeName :=\n        Function.Injective.commRing toBitVec toBitVec_injective\n          rfl rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ => rfl)\n\n      namespace CommRing\n      attribute [scoped instance] instCommRing instNatCast instIntCast\n      end CommRing\n\n    end $typeName\n  ))\n  -- interpolating docstrings above is more trouble than it's worth\n  let docString :=\n    s!\"To use this instance, use `open scoped {typeName'}.CommRing`.\\n\\n\" ++\n    \"See the module docstring for an explanation\"\n  Lean.addDocString (typeName'.mkStr \"instCommRing\") docString\n  Lean.addDocString (typeName'.mkStr \"instNatCast\") docString\n  Lean.addDocString (typeName'.mkStr \"instIntCast\") docString\n\n"}
{"name":"UInt64.neg_def","module":"Mathlib.Data.UInt","initialProofState":"a : UInt64\n⊢ Eq (Neg.neg a) { toBitVec := { toFin := Neg.neg a.val } }","decl":"set_option hygiene false in\nrun_cmd\n  for typeName' in [`UInt8, `UInt16, `UInt32, `UInt64, `USize] do\n  let typeName := Lean.mkIdent typeName'\n  Lean.Elab.Command.elabCommand (← `(\n    namespace $typeName\n\n      instance : Neg $typeName where\n        neg a := mk ⟨-a.val⟩\n\n      instance : Pow $typeName ℕ where\n        pow a n := mk ⟨a.val ^ n⟩\n\n      instance : SMul ℕ $typeName where\n        smul n a := mk ⟨n • a.val⟩\n\n      instance : SMul ℤ $typeName where\n        smul z a := mk ⟨z • a.val⟩\n\n      lemma neg_def (a : $typeName) : -a = ⟨⟨-a.val⟩⟩ := rfl\n\n      lemma pow_def (a : $typeName) (n : ℕ) : a ^ n = ⟨⟨a.val ^ n⟩⟩ := rfl\n\n      lemma nsmul_def (n : ℕ) (a : $typeName) : n • a = ⟨⟨n • a.val⟩⟩ := rfl\n\n      lemma zsmul_def (z : ℤ) (a : $typeName) : z • a = ⟨⟨z • a.val⟩⟩ := rfl\n\n      open $typeName (eq_of_val_eq) in\n      lemma val_injective : Function.Injective val := @eq_of_val_eq\n\n      open $typeName (eq_of_toBitVec_eq) in\n      lemma toBitVec_injective : Function.Injective toBitVec := @eq_of_toBitVec_eq\n\n      instance instCommMonoid : CommMonoid $typeName :=\n        Function.Injective.commMonoid toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl)\n\n      instance instNonUnitalCommRing : NonUnitalCommRing $typeName :=\n        Function.Injective.nonUnitalCommRing toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl)\n\n      local instance instNatCast : NatCast $typeName where\n        natCast n := mk n\n\n      local instance instIntCast : IntCast $typeName where\n        intCast z := mk z\n\n      lemma natCast_def (n : ℕ) : (n : $typeName) = ⟨n⟩ := rfl\n\n      lemma intCast_def (z : ℤ) : (z : $typeName) = ⟨z⟩ := rfl\n\n      local instance instCommRing : CommRing $typeName :=\n        Function.Injective.commRing toBitVec toBitVec_injective\n          rfl rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ => rfl)\n\n      namespace CommRing\n      attribute [scoped instance] instCommRing instNatCast instIntCast\n      end CommRing\n\n    end $typeName\n  ))\n  -- interpolating docstrings above is more trouble than it's worth\n  let docString :=\n    s!\"To use this instance, use `open scoped {typeName'}.CommRing`.\\n\\n\" ++\n    \"See the module docstring for an explanation\"\n  Lean.addDocString (typeName'.mkStr \"instCommRing\") docString\n  Lean.addDocString (typeName'.mkStr \"instNatCast\") docString\n  Lean.addDocString (typeName'.mkStr \"instIntCast\") docString\n\n"}
{"name":"UInt64.toBitVec_injective","module":"Mathlib.Data.UInt","initialProofState":"⊢ Function.Injective UInt64.toBitVec","decl":"set_option hygiene false in\nrun_cmd\n  for typeName' in [`UInt8, `UInt16, `UInt32, `UInt64, `USize] do\n  let typeName := Lean.mkIdent typeName'\n  Lean.Elab.Command.elabCommand (← `(\n    namespace $typeName\n\n      instance : Neg $typeName where\n        neg a := mk ⟨-a.val⟩\n\n      instance : Pow $typeName ℕ where\n        pow a n := mk ⟨a.val ^ n⟩\n\n      instance : SMul ℕ $typeName where\n        smul n a := mk ⟨n • a.val⟩\n\n      instance : SMul ℤ $typeName where\n        smul z a := mk ⟨z • a.val⟩\n\n      lemma neg_def (a : $typeName) : -a = ⟨⟨-a.val⟩⟩ := rfl\n\n      lemma pow_def (a : $typeName) (n : ℕ) : a ^ n = ⟨⟨a.val ^ n⟩⟩ := rfl\n\n      lemma nsmul_def (n : ℕ) (a : $typeName) : n • a = ⟨⟨n • a.val⟩⟩ := rfl\n\n      lemma zsmul_def (z : ℤ) (a : $typeName) : z • a = ⟨⟨z • a.val⟩⟩ := rfl\n\n      open $typeName (eq_of_val_eq) in\n      lemma val_injective : Function.Injective val := @eq_of_val_eq\n\n      open $typeName (eq_of_toBitVec_eq) in\n      lemma toBitVec_injective : Function.Injective toBitVec := @eq_of_toBitVec_eq\n\n      instance instCommMonoid : CommMonoid $typeName :=\n        Function.Injective.commMonoid toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl)\n\n      instance instNonUnitalCommRing : NonUnitalCommRing $typeName :=\n        Function.Injective.nonUnitalCommRing toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl)\n\n      local instance instNatCast : NatCast $typeName where\n        natCast n := mk n\n\n      local instance instIntCast : IntCast $typeName where\n        intCast z := mk z\n\n      lemma natCast_def (n : ℕ) : (n : $typeName) = ⟨n⟩ := rfl\n\n      lemma intCast_def (z : ℤ) : (z : $typeName) = ⟨z⟩ := rfl\n\n      local instance instCommRing : CommRing $typeName :=\n        Function.Injective.commRing toBitVec toBitVec_injective\n          rfl rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ => rfl)\n\n      namespace CommRing\n      attribute [scoped instance] instCommRing instNatCast instIntCast\n      end CommRing\n\n    end $typeName\n  ))\n  -- interpolating docstrings above is more trouble than it's worth\n  let docString :=\n    s!\"To use this instance, use `open scoped {typeName'}.CommRing`.\\n\\n\" ++\n    \"See the module docstring for an explanation\"\n  Lean.addDocString (typeName'.mkStr \"instCommRing\") docString\n  Lean.addDocString (typeName'.mkStr \"instNatCast\") docString\n  Lean.addDocString (typeName'.mkStr \"instIntCast\") docString\n\n"}
{"name":"USize.intCast_def","module":"Mathlib.Data.UInt","initialProofState":"z : Int\n⊢ Eq ↑z { toBitVec := ↑z }","decl":"set_option hygiene false in\nrun_cmd\n  for typeName' in [`UInt8, `UInt16, `UInt32, `UInt64, `USize] do\n  let typeName := Lean.mkIdent typeName'\n  Lean.Elab.Command.elabCommand (← `(\n    namespace $typeName\n\n      instance : Neg $typeName where\n        neg a := mk ⟨-a.val⟩\n\n      instance : Pow $typeName ℕ where\n        pow a n := mk ⟨a.val ^ n⟩\n\n      instance : SMul ℕ $typeName where\n        smul n a := mk ⟨n • a.val⟩\n\n      instance : SMul ℤ $typeName where\n        smul z a := mk ⟨z • a.val⟩\n\n      lemma neg_def (a : $typeName) : -a = ⟨⟨-a.val⟩⟩ := rfl\n\n      lemma pow_def (a : $typeName) (n : ℕ) : a ^ n = ⟨⟨a.val ^ n⟩⟩ := rfl\n\n      lemma nsmul_def (n : ℕ) (a : $typeName) : n • a = ⟨⟨n • a.val⟩⟩ := rfl\n\n      lemma zsmul_def (z : ℤ) (a : $typeName) : z • a = ⟨⟨z • a.val⟩⟩ := rfl\n\n      open $typeName (eq_of_val_eq) in\n      lemma val_injective : Function.Injective val := @eq_of_val_eq\n\n      open $typeName (eq_of_toBitVec_eq) in\n      lemma toBitVec_injective : Function.Injective toBitVec := @eq_of_toBitVec_eq\n\n      instance instCommMonoid : CommMonoid $typeName :=\n        Function.Injective.commMonoid toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl)\n\n      instance instNonUnitalCommRing : NonUnitalCommRing $typeName :=\n        Function.Injective.nonUnitalCommRing toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl)\n\n      local instance instNatCast : NatCast $typeName where\n        natCast n := mk n\n\n      local instance instIntCast : IntCast $typeName where\n        intCast z := mk z\n\n      lemma natCast_def (n : ℕ) : (n : $typeName) = ⟨n⟩ := rfl\n\n      lemma intCast_def (z : ℤ) : (z : $typeName) = ⟨z⟩ := rfl\n\n      local instance instCommRing : CommRing $typeName :=\n        Function.Injective.commRing toBitVec toBitVec_injective\n          rfl rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ => rfl)\n\n      namespace CommRing\n      attribute [scoped instance] instCommRing instNatCast instIntCast\n      end CommRing\n\n    end $typeName\n  ))\n  -- interpolating docstrings above is more trouble than it's worth\n  let docString :=\n    s!\"To use this instance, use `open scoped {typeName'}.CommRing`.\\n\\n\" ++\n    \"See the module docstring for an explanation\"\n  Lean.addDocString (typeName'.mkStr \"instCommRing\") docString\n  Lean.addDocString (typeName'.mkStr \"instNatCast\") docString\n  Lean.addDocString (typeName'.mkStr \"instIntCast\") docString\n\n"}
{"name":"UInt64.natCast_def","module":"Mathlib.Data.UInt","initialProofState":"n : Nat\n⊢ Eq ↑n { toBitVec := ↑n }","decl":"set_option hygiene false in\nrun_cmd\n  for typeName' in [`UInt8, `UInt16, `UInt32, `UInt64, `USize] do\n  let typeName := Lean.mkIdent typeName'\n  Lean.Elab.Command.elabCommand (← `(\n    namespace $typeName\n\n      instance : Neg $typeName where\n        neg a := mk ⟨-a.val⟩\n\n      instance : Pow $typeName ℕ where\n        pow a n := mk ⟨a.val ^ n⟩\n\n      instance : SMul ℕ $typeName where\n        smul n a := mk ⟨n • a.val⟩\n\n      instance : SMul ℤ $typeName where\n        smul z a := mk ⟨z • a.val⟩\n\n      lemma neg_def (a : $typeName) : -a = ⟨⟨-a.val⟩⟩ := rfl\n\n      lemma pow_def (a : $typeName) (n : ℕ) : a ^ n = ⟨⟨a.val ^ n⟩⟩ := rfl\n\n      lemma nsmul_def (n : ℕ) (a : $typeName) : n • a = ⟨⟨n • a.val⟩⟩ := rfl\n\n      lemma zsmul_def (z : ℤ) (a : $typeName) : z • a = ⟨⟨z • a.val⟩⟩ := rfl\n\n      open $typeName (eq_of_val_eq) in\n      lemma val_injective : Function.Injective val := @eq_of_val_eq\n\n      open $typeName (eq_of_toBitVec_eq) in\n      lemma toBitVec_injective : Function.Injective toBitVec := @eq_of_toBitVec_eq\n\n      instance instCommMonoid : CommMonoid $typeName :=\n        Function.Injective.commMonoid toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl)\n\n      instance instNonUnitalCommRing : NonUnitalCommRing $typeName :=\n        Function.Injective.nonUnitalCommRing toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl)\n\n      local instance instNatCast : NatCast $typeName where\n        natCast n := mk n\n\n      local instance instIntCast : IntCast $typeName where\n        intCast z := mk z\n\n      lemma natCast_def (n : ℕ) : (n : $typeName) = ⟨n⟩ := rfl\n\n      lemma intCast_def (z : ℤ) : (z : $typeName) = ⟨z⟩ := rfl\n\n      local instance instCommRing : CommRing $typeName :=\n        Function.Injective.commRing toBitVec toBitVec_injective\n          rfl rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ => rfl)\n\n      namespace CommRing\n      attribute [scoped instance] instCommRing instNatCast instIntCast\n      end CommRing\n\n    end $typeName\n  ))\n  -- interpolating docstrings above is more trouble than it's worth\n  let docString :=\n    s!\"To use this instance, use `open scoped {typeName'}.CommRing`.\\n\\n\" ++\n    \"See the module docstring for an explanation\"\n  Lean.addDocString (typeName'.mkStr \"instCommRing\") docString\n  Lean.addDocString (typeName'.mkStr \"instNatCast\") docString\n  Lean.addDocString (typeName'.mkStr \"instIntCast\") docString\n\n"}
{"name":"UInt8.toBitVec_injective","module":"Mathlib.Data.UInt","initialProofState":"⊢ Function.Injective UInt8.toBitVec","decl":"set_option hygiene false in\nrun_cmd\n  for typeName' in [`UInt8, `UInt16, `UInt32, `UInt64, `USize] do\n  let typeName := Lean.mkIdent typeName'\n  Lean.Elab.Command.elabCommand (← `(\n    namespace $typeName\n\n      instance : Neg $typeName where\n        neg a := mk ⟨-a.val⟩\n\n      instance : Pow $typeName ℕ where\n        pow a n := mk ⟨a.val ^ n⟩\n\n      instance : SMul ℕ $typeName where\n        smul n a := mk ⟨n • a.val⟩\n\n      instance : SMul ℤ $typeName where\n        smul z a := mk ⟨z • a.val⟩\n\n      lemma neg_def (a : $typeName) : -a = ⟨⟨-a.val⟩⟩ := rfl\n\n      lemma pow_def (a : $typeName) (n : ℕ) : a ^ n = ⟨⟨a.val ^ n⟩⟩ := rfl\n\n      lemma nsmul_def (n : ℕ) (a : $typeName) : n • a = ⟨⟨n • a.val⟩⟩ := rfl\n\n      lemma zsmul_def (z : ℤ) (a : $typeName) : z • a = ⟨⟨z • a.val⟩⟩ := rfl\n\n      open $typeName (eq_of_val_eq) in\n      lemma val_injective : Function.Injective val := @eq_of_val_eq\n\n      open $typeName (eq_of_toBitVec_eq) in\n      lemma toBitVec_injective : Function.Injective toBitVec := @eq_of_toBitVec_eq\n\n      instance instCommMonoid : CommMonoid $typeName :=\n        Function.Injective.commMonoid toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl)\n\n      instance instNonUnitalCommRing : NonUnitalCommRing $typeName :=\n        Function.Injective.nonUnitalCommRing toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl)\n\n      local instance instNatCast : NatCast $typeName where\n        natCast n := mk n\n\n      local instance instIntCast : IntCast $typeName where\n        intCast z := mk z\n\n      lemma natCast_def (n : ℕ) : (n : $typeName) = ⟨n⟩ := rfl\n\n      lemma intCast_def (z : ℤ) : (z : $typeName) = ⟨z⟩ := rfl\n\n      local instance instCommRing : CommRing $typeName :=\n        Function.Injective.commRing toBitVec toBitVec_injective\n          rfl rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ => rfl)\n\n      namespace CommRing\n      attribute [scoped instance] instCommRing instNatCast instIntCast\n      end CommRing\n\n    end $typeName\n  ))\n  -- interpolating docstrings above is more trouble than it's worth\n  let docString :=\n    s!\"To use this instance, use `open scoped {typeName'}.CommRing`.\\n\\n\" ++\n    \"See the module docstring for an explanation\"\n  Lean.addDocString (typeName'.mkStr \"instCommRing\") docString\n  Lean.addDocString (typeName'.mkStr \"instNatCast\") docString\n  Lean.addDocString (typeName'.mkStr \"instIntCast\") docString\n\n"}
{"name":"UInt16.zsmul_def","module":"Mathlib.Data.UInt","initialProofState":"z : Int\na : UInt16\n⊢ Eq (HSMul.hSMul z a) { toBitVec := { toFin := HSMul.hSMul z a.val } }","decl":"set_option hygiene false in\nrun_cmd\n  for typeName' in [`UInt8, `UInt16, `UInt32, `UInt64, `USize] do\n  let typeName := Lean.mkIdent typeName'\n  Lean.Elab.Command.elabCommand (← `(\n    namespace $typeName\n\n      instance : Neg $typeName where\n        neg a := mk ⟨-a.val⟩\n\n      instance : Pow $typeName ℕ where\n        pow a n := mk ⟨a.val ^ n⟩\n\n      instance : SMul ℕ $typeName where\n        smul n a := mk ⟨n • a.val⟩\n\n      instance : SMul ℤ $typeName where\n        smul z a := mk ⟨z • a.val⟩\n\n      lemma neg_def (a : $typeName) : -a = ⟨⟨-a.val⟩⟩ := rfl\n\n      lemma pow_def (a : $typeName) (n : ℕ) : a ^ n = ⟨⟨a.val ^ n⟩⟩ := rfl\n\n      lemma nsmul_def (n : ℕ) (a : $typeName) : n • a = ⟨⟨n • a.val⟩⟩ := rfl\n\n      lemma zsmul_def (z : ℤ) (a : $typeName) : z • a = ⟨⟨z • a.val⟩⟩ := rfl\n\n      open $typeName (eq_of_val_eq) in\n      lemma val_injective : Function.Injective val := @eq_of_val_eq\n\n      open $typeName (eq_of_toBitVec_eq) in\n      lemma toBitVec_injective : Function.Injective toBitVec := @eq_of_toBitVec_eq\n\n      instance instCommMonoid : CommMonoid $typeName :=\n        Function.Injective.commMonoid toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl)\n\n      instance instNonUnitalCommRing : NonUnitalCommRing $typeName :=\n        Function.Injective.nonUnitalCommRing toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl)\n\n      local instance instNatCast : NatCast $typeName where\n        natCast n := mk n\n\n      local instance instIntCast : IntCast $typeName where\n        intCast z := mk z\n\n      lemma natCast_def (n : ℕ) : (n : $typeName) = ⟨n⟩ := rfl\n\n      lemma intCast_def (z : ℤ) : (z : $typeName) = ⟨z⟩ := rfl\n\n      local instance instCommRing : CommRing $typeName :=\n        Function.Injective.commRing toBitVec toBitVec_injective\n          rfl rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ => rfl)\n\n      namespace CommRing\n      attribute [scoped instance] instCommRing instNatCast instIntCast\n      end CommRing\n\n    end $typeName\n  ))\n  -- interpolating docstrings above is more trouble than it's worth\n  let docString :=\n    s!\"To use this instance, use `open scoped {typeName'}.CommRing`.\\n\\n\" ++\n    \"See the module docstring for an explanation\"\n  Lean.addDocString (typeName'.mkStr \"instCommRing\") docString\n  Lean.addDocString (typeName'.mkStr \"instNatCast\") docString\n  Lean.addDocString (typeName'.mkStr \"instIntCast\") docString\n\n"}
{"name":"UInt32.intCast_def","module":"Mathlib.Data.UInt","initialProofState":"z : Int\n⊢ Eq ↑z { toBitVec := ↑z }","decl":"set_option hygiene false in\nrun_cmd\n  for typeName' in [`UInt8, `UInt16, `UInt32, `UInt64, `USize] do\n  let typeName := Lean.mkIdent typeName'\n  Lean.Elab.Command.elabCommand (← `(\n    namespace $typeName\n\n      instance : Neg $typeName where\n        neg a := mk ⟨-a.val⟩\n\n      instance : Pow $typeName ℕ where\n        pow a n := mk ⟨a.val ^ n⟩\n\n      instance : SMul ℕ $typeName where\n        smul n a := mk ⟨n • a.val⟩\n\n      instance : SMul ℤ $typeName where\n        smul z a := mk ⟨z • a.val⟩\n\n      lemma neg_def (a : $typeName) : -a = ⟨⟨-a.val⟩⟩ := rfl\n\n      lemma pow_def (a : $typeName) (n : ℕ) : a ^ n = ⟨⟨a.val ^ n⟩⟩ := rfl\n\n      lemma nsmul_def (n : ℕ) (a : $typeName) : n • a = ⟨⟨n • a.val⟩⟩ := rfl\n\n      lemma zsmul_def (z : ℤ) (a : $typeName) : z • a = ⟨⟨z • a.val⟩⟩ := rfl\n\n      open $typeName (eq_of_val_eq) in\n      lemma val_injective : Function.Injective val := @eq_of_val_eq\n\n      open $typeName (eq_of_toBitVec_eq) in\n      lemma toBitVec_injective : Function.Injective toBitVec := @eq_of_toBitVec_eq\n\n      instance instCommMonoid : CommMonoid $typeName :=\n        Function.Injective.commMonoid toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl)\n\n      instance instNonUnitalCommRing : NonUnitalCommRing $typeName :=\n        Function.Injective.nonUnitalCommRing toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl)\n\n      local instance instNatCast : NatCast $typeName where\n        natCast n := mk n\n\n      local instance instIntCast : IntCast $typeName where\n        intCast z := mk z\n\n      lemma natCast_def (n : ℕ) : (n : $typeName) = ⟨n⟩ := rfl\n\n      lemma intCast_def (z : ℤ) : (z : $typeName) = ⟨z⟩ := rfl\n\n      local instance instCommRing : CommRing $typeName :=\n        Function.Injective.commRing toBitVec toBitVec_injective\n          rfl rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ => rfl)\n\n      namespace CommRing\n      attribute [scoped instance] instCommRing instNatCast instIntCast\n      end CommRing\n\n    end $typeName\n  ))\n  -- interpolating docstrings above is more trouble than it's worth\n  let docString :=\n    s!\"To use this instance, use `open scoped {typeName'}.CommRing`.\\n\\n\" ++\n    \"See the module docstring for an explanation\"\n  Lean.addDocString (typeName'.mkStr \"instCommRing\") docString\n  Lean.addDocString (typeName'.mkStr \"instNatCast\") docString\n  Lean.addDocString (typeName'.mkStr \"instIntCast\") docString\n\n"}
{"name":"UInt8.natCast_def","module":"Mathlib.Data.UInt","initialProofState":"n : Nat\n⊢ Eq ↑n { toBitVec := ↑n }","decl":"set_option hygiene false in\nrun_cmd\n  for typeName' in [`UInt8, `UInt16, `UInt32, `UInt64, `USize] do\n  let typeName := Lean.mkIdent typeName'\n  Lean.Elab.Command.elabCommand (← `(\n    namespace $typeName\n\n      instance : Neg $typeName where\n        neg a := mk ⟨-a.val⟩\n\n      instance : Pow $typeName ℕ where\n        pow a n := mk ⟨a.val ^ n⟩\n\n      instance : SMul ℕ $typeName where\n        smul n a := mk ⟨n • a.val⟩\n\n      instance : SMul ℤ $typeName where\n        smul z a := mk ⟨z • a.val⟩\n\n      lemma neg_def (a : $typeName) : -a = ⟨⟨-a.val⟩⟩ := rfl\n\n      lemma pow_def (a : $typeName) (n : ℕ) : a ^ n = ⟨⟨a.val ^ n⟩⟩ := rfl\n\n      lemma nsmul_def (n : ℕ) (a : $typeName) : n • a = ⟨⟨n • a.val⟩⟩ := rfl\n\n      lemma zsmul_def (z : ℤ) (a : $typeName) : z • a = ⟨⟨z • a.val⟩⟩ := rfl\n\n      open $typeName (eq_of_val_eq) in\n      lemma val_injective : Function.Injective val := @eq_of_val_eq\n\n      open $typeName (eq_of_toBitVec_eq) in\n      lemma toBitVec_injective : Function.Injective toBitVec := @eq_of_toBitVec_eq\n\n      instance instCommMonoid : CommMonoid $typeName :=\n        Function.Injective.commMonoid toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl)\n\n      instance instNonUnitalCommRing : NonUnitalCommRing $typeName :=\n        Function.Injective.nonUnitalCommRing toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl)\n\n      local instance instNatCast : NatCast $typeName where\n        natCast n := mk n\n\n      local instance instIntCast : IntCast $typeName where\n        intCast z := mk z\n\n      lemma natCast_def (n : ℕ) : (n : $typeName) = ⟨n⟩ := rfl\n\n      lemma intCast_def (z : ℤ) : (z : $typeName) = ⟨z⟩ := rfl\n\n      local instance instCommRing : CommRing $typeName :=\n        Function.Injective.commRing toBitVec toBitVec_injective\n          rfl rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ => rfl)\n\n      namespace CommRing\n      attribute [scoped instance] instCommRing instNatCast instIntCast\n      end CommRing\n\n    end $typeName\n  ))\n  -- interpolating docstrings above is more trouble than it's worth\n  let docString :=\n    s!\"To use this instance, use `open scoped {typeName'}.CommRing`.\\n\\n\" ++\n    \"See the module docstring for an explanation\"\n  Lean.addDocString (typeName'.mkStr \"instCommRing\") docString\n  Lean.addDocString (typeName'.mkStr \"instNatCast\") docString\n  Lean.addDocString (typeName'.mkStr \"instIntCast\") docString\n\n"}
{"name":"UInt16.pow_def","module":"Mathlib.Data.UInt","initialProofState":"a : UInt16\nn : Nat\n⊢ Eq (HPow.hPow a n) { toBitVec := { toFin := HPow.hPow a.val n } }","decl":"set_option hygiene false in\nrun_cmd\n  for typeName' in [`UInt8, `UInt16, `UInt32, `UInt64, `USize] do\n  let typeName := Lean.mkIdent typeName'\n  Lean.Elab.Command.elabCommand (← `(\n    namespace $typeName\n\n      instance : Neg $typeName where\n        neg a := mk ⟨-a.val⟩\n\n      instance : Pow $typeName ℕ where\n        pow a n := mk ⟨a.val ^ n⟩\n\n      instance : SMul ℕ $typeName where\n        smul n a := mk ⟨n • a.val⟩\n\n      instance : SMul ℤ $typeName where\n        smul z a := mk ⟨z • a.val⟩\n\n      lemma neg_def (a : $typeName) : -a = ⟨⟨-a.val⟩⟩ := rfl\n\n      lemma pow_def (a : $typeName) (n : ℕ) : a ^ n = ⟨⟨a.val ^ n⟩⟩ := rfl\n\n      lemma nsmul_def (n : ℕ) (a : $typeName) : n • a = ⟨⟨n • a.val⟩⟩ := rfl\n\n      lemma zsmul_def (z : ℤ) (a : $typeName) : z • a = ⟨⟨z • a.val⟩⟩ := rfl\n\n      open $typeName (eq_of_val_eq) in\n      lemma val_injective : Function.Injective val := @eq_of_val_eq\n\n      open $typeName (eq_of_toBitVec_eq) in\n      lemma toBitVec_injective : Function.Injective toBitVec := @eq_of_toBitVec_eq\n\n      instance instCommMonoid : CommMonoid $typeName :=\n        Function.Injective.commMonoid toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl)\n\n      instance instNonUnitalCommRing : NonUnitalCommRing $typeName :=\n        Function.Injective.nonUnitalCommRing toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl)\n\n      local instance instNatCast : NatCast $typeName where\n        natCast n := mk n\n\n      local instance instIntCast : IntCast $typeName where\n        intCast z := mk z\n\n      lemma natCast_def (n : ℕ) : (n : $typeName) = ⟨n⟩ := rfl\n\n      lemma intCast_def (z : ℤ) : (z : $typeName) = ⟨z⟩ := rfl\n\n      local instance instCommRing : CommRing $typeName :=\n        Function.Injective.commRing toBitVec toBitVec_injective\n          rfl rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ => rfl)\n\n      namespace CommRing\n      attribute [scoped instance] instCommRing instNatCast instIntCast\n      end CommRing\n\n    end $typeName\n  ))\n  -- interpolating docstrings above is more trouble than it's worth\n  let docString :=\n    s!\"To use this instance, use `open scoped {typeName'}.CommRing`.\\n\\n\" ++\n    \"See the module docstring for an explanation\"\n  Lean.addDocString (typeName'.mkStr \"instCommRing\") docString\n  Lean.addDocString (typeName'.mkStr \"instNatCast\") docString\n  Lean.addDocString (typeName'.mkStr \"instIntCast\") docString\n\n"}
{"name":"UInt16.val_injective","module":"Mathlib.Data.UInt","initialProofState":"⊢ Function.Injective UInt16.val","decl":"set_option hygiene false in\nrun_cmd\n  for typeName' in [`UInt8, `UInt16, `UInt32, `UInt64, `USize] do\n  let typeName := Lean.mkIdent typeName'\n  Lean.Elab.Command.elabCommand (← `(\n    namespace $typeName\n\n      instance : Neg $typeName where\n        neg a := mk ⟨-a.val⟩\n\n      instance : Pow $typeName ℕ where\n        pow a n := mk ⟨a.val ^ n⟩\n\n      instance : SMul ℕ $typeName where\n        smul n a := mk ⟨n • a.val⟩\n\n      instance : SMul ℤ $typeName where\n        smul z a := mk ⟨z • a.val⟩\n\n      lemma neg_def (a : $typeName) : -a = ⟨⟨-a.val⟩⟩ := rfl\n\n      lemma pow_def (a : $typeName) (n : ℕ) : a ^ n = ⟨⟨a.val ^ n⟩⟩ := rfl\n\n      lemma nsmul_def (n : ℕ) (a : $typeName) : n • a = ⟨⟨n • a.val⟩⟩ := rfl\n\n      lemma zsmul_def (z : ℤ) (a : $typeName) : z • a = ⟨⟨z • a.val⟩⟩ := rfl\n\n      open $typeName (eq_of_val_eq) in\n      lemma val_injective : Function.Injective val := @eq_of_val_eq\n\n      open $typeName (eq_of_toBitVec_eq) in\n      lemma toBitVec_injective : Function.Injective toBitVec := @eq_of_toBitVec_eq\n\n      instance instCommMonoid : CommMonoid $typeName :=\n        Function.Injective.commMonoid toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl)\n\n      instance instNonUnitalCommRing : NonUnitalCommRing $typeName :=\n        Function.Injective.nonUnitalCommRing toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl)\n\n      local instance instNatCast : NatCast $typeName where\n        natCast n := mk n\n\n      local instance instIntCast : IntCast $typeName where\n        intCast z := mk z\n\n      lemma natCast_def (n : ℕ) : (n : $typeName) = ⟨n⟩ := rfl\n\n      lemma intCast_def (z : ℤ) : (z : $typeName) = ⟨z⟩ := rfl\n\n      local instance instCommRing : CommRing $typeName :=\n        Function.Injective.commRing toBitVec toBitVec_injective\n          rfl rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ => rfl)\n\n      namespace CommRing\n      attribute [scoped instance] instCommRing instNatCast instIntCast\n      end CommRing\n\n    end $typeName\n  ))\n  -- interpolating docstrings above is more trouble than it's worth\n  let docString :=\n    s!\"To use this instance, use `open scoped {typeName'}.CommRing`.\\n\\n\" ++\n    \"See the module docstring for an explanation\"\n  Lean.addDocString (typeName'.mkStr \"instCommRing\") docString\n  Lean.addDocString (typeName'.mkStr \"instNatCast\") docString\n  Lean.addDocString (typeName'.mkStr \"instIntCast\") docString\n\n"}
{"name":"UInt32.nsmul_def","module":"Mathlib.Data.UInt","initialProofState":"n : Nat\na : UInt32\n⊢ Eq (HSMul.hSMul n a) { toBitVec := { toFin := HSMul.hSMul n a.val } }","decl":"set_option hygiene false in\nrun_cmd\n  for typeName' in [`UInt8, `UInt16, `UInt32, `UInt64, `USize] do\n  let typeName := Lean.mkIdent typeName'\n  Lean.Elab.Command.elabCommand (← `(\n    namespace $typeName\n\n      instance : Neg $typeName where\n        neg a := mk ⟨-a.val⟩\n\n      instance : Pow $typeName ℕ where\n        pow a n := mk ⟨a.val ^ n⟩\n\n      instance : SMul ℕ $typeName where\n        smul n a := mk ⟨n • a.val⟩\n\n      instance : SMul ℤ $typeName where\n        smul z a := mk ⟨z • a.val⟩\n\n      lemma neg_def (a : $typeName) : -a = ⟨⟨-a.val⟩⟩ := rfl\n\n      lemma pow_def (a : $typeName) (n : ℕ) : a ^ n = ⟨⟨a.val ^ n⟩⟩ := rfl\n\n      lemma nsmul_def (n : ℕ) (a : $typeName) : n • a = ⟨⟨n • a.val⟩⟩ := rfl\n\n      lemma zsmul_def (z : ℤ) (a : $typeName) : z • a = ⟨⟨z • a.val⟩⟩ := rfl\n\n      open $typeName (eq_of_val_eq) in\n      lemma val_injective : Function.Injective val := @eq_of_val_eq\n\n      open $typeName (eq_of_toBitVec_eq) in\n      lemma toBitVec_injective : Function.Injective toBitVec := @eq_of_toBitVec_eq\n\n      instance instCommMonoid : CommMonoid $typeName :=\n        Function.Injective.commMonoid toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl)\n\n      instance instNonUnitalCommRing : NonUnitalCommRing $typeName :=\n        Function.Injective.nonUnitalCommRing toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl)\n\n      local instance instNatCast : NatCast $typeName where\n        natCast n := mk n\n\n      local instance instIntCast : IntCast $typeName where\n        intCast z := mk z\n\n      lemma natCast_def (n : ℕ) : (n : $typeName) = ⟨n⟩ := rfl\n\n      lemma intCast_def (z : ℤ) : (z : $typeName) = ⟨z⟩ := rfl\n\n      local instance instCommRing : CommRing $typeName :=\n        Function.Injective.commRing toBitVec toBitVec_injective\n          rfl rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ => rfl)\n\n      namespace CommRing\n      attribute [scoped instance] instCommRing instNatCast instIntCast\n      end CommRing\n\n    end $typeName\n  ))\n  -- interpolating docstrings above is more trouble than it's worth\n  let docString :=\n    s!\"To use this instance, use `open scoped {typeName'}.CommRing`.\\n\\n\" ++\n    \"See the module docstring for an explanation\"\n  Lean.addDocString (typeName'.mkStr \"instCommRing\") docString\n  Lean.addDocString (typeName'.mkStr \"instNatCast\") docString\n  Lean.addDocString (typeName'.mkStr \"instIntCast\") docString\n\n"}
{"name":"UInt64.zsmul_def","module":"Mathlib.Data.UInt","initialProofState":"z : Int\na : UInt64\n⊢ Eq (HSMul.hSMul z a) { toBitVec := { toFin := HSMul.hSMul z a.val } }","decl":"set_option hygiene false in\nrun_cmd\n  for typeName' in [`UInt8, `UInt16, `UInt32, `UInt64, `USize] do\n  let typeName := Lean.mkIdent typeName'\n  Lean.Elab.Command.elabCommand (← `(\n    namespace $typeName\n\n      instance : Neg $typeName where\n        neg a := mk ⟨-a.val⟩\n\n      instance : Pow $typeName ℕ where\n        pow a n := mk ⟨a.val ^ n⟩\n\n      instance : SMul ℕ $typeName where\n        smul n a := mk ⟨n • a.val⟩\n\n      instance : SMul ℤ $typeName where\n        smul z a := mk ⟨z • a.val⟩\n\n      lemma neg_def (a : $typeName) : -a = ⟨⟨-a.val⟩⟩ := rfl\n\n      lemma pow_def (a : $typeName) (n : ℕ) : a ^ n = ⟨⟨a.val ^ n⟩⟩ := rfl\n\n      lemma nsmul_def (n : ℕ) (a : $typeName) : n • a = ⟨⟨n • a.val⟩⟩ := rfl\n\n      lemma zsmul_def (z : ℤ) (a : $typeName) : z • a = ⟨⟨z • a.val⟩⟩ := rfl\n\n      open $typeName (eq_of_val_eq) in\n      lemma val_injective : Function.Injective val := @eq_of_val_eq\n\n      open $typeName (eq_of_toBitVec_eq) in\n      lemma toBitVec_injective : Function.Injective toBitVec := @eq_of_toBitVec_eq\n\n      instance instCommMonoid : CommMonoid $typeName :=\n        Function.Injective.commMonoid toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl)\n\n      instance instNonUnitalCommRing : NonUnitalCommRing $typeName :=\n        Function.Injective.nonUnitalCommRing toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl)\n\n      local instance instNatCast : NatCast $typeName where\n        natCast n := mk n\n\n      local instance instIntCast : IntCast $typeName where\n        intCast z := mk z\n\n      lemma natCast_def (n : ℕ) : (n : $typeName) = ⟨n⟩ := rfl\n\n      lemma intCast_def (z : ℤ) : (z : $typeName) = ⟨z⟩ := rfl\n\n      local instance instCommRing : CommRing $typeName :=\n        Function.Injective.commRing toBitVec toBitVec_injective\n          rfl rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ => rfl)\n\n      namespace CommRing\n      attribute [scoped instance] instCommRing instNatCast instIntCast\n      end CommRing\n\n    end $typeName\n  ))\n  -- interpolating docstrings above is more trouble than it's worth\n  let docString :=\n    s!\"To use this instance, use `open scoped {typeName'}.CommRing`.\\n\\n\" ++\n    \"See the module docstring for an explanation\"\n  Lean.addDocString (typeName'.mkStr \"instCommRing\") docString\n  Lean.addDocString (typeName'.mkStr \"instNatCast\") docString\n  Lean.addDocString (typeName'.mkStr \"instIntCast\") docString\n\n"}
{"name":"UInt32.neg_def","module":"Mathlib.Data.UInt","initialProofState":"a : UInt32\n⊢ Eq (Neg.neg a) { toBitVec := { toFin := Neg.neg a.val } }","decl":"set_option hygiene false in\nrun_cmd\n  for typeName' in [`UInt8, `UInt16, `UInt32, `UInt64, `USize] do\n  let typeName := Lean.mkIdent typeName'\n  Lean.Elab.Command.elabCommand (← `(\n    namespace $typeName\n\n      instance : Neg $typeName where\n        neg a := mk ⟨-a.val⟩\n\n      instance : Pow $typeName ℕ where\n        pow a n := mk ⟨a.val ^ n⟩\n\n      instance : SMul ℕ $typeName where\n        smul n a := mk ⟨n • a.val⟩\n\n      instance : SMul ℤ $typeName where\n        smul z a := mk ⟨z • a.val⟩\n\n      lemma neg_def (a : $typeName) : -a = ⟨⟨-a.val⟩⟩ := rfl\n\n      lemma pow_def (a : $typeName) (n : ℕ) : a ^ n = ⟨⟨a.val ^ n⟩⟩ := rfl\n\n      lemma nsmul_def (n : ℕ) (a : $typeName) : n • a = ⟨⟨n • a.val⟩⟩ := rfl\n\n      lemma zsmul_def (z : ℤ) (a : $typeName) : z • a = ⟨⟨z • a.val⟩⟩ := rfl\n\n      open $typeName (eq_of_val_eq) in\n      lemma val_injective : Function.Injective val := @eq_of_val_eq\n\n      open $typeName (eq_of_toBitVec_eq) in\n      lemma toBitVec_injective : Function.Injective toBitVec := @eq_of_toBitVec_eq\n\n      instance instCommMonoid : CommMonoid $typeName :=\n        Function.Injective.commMonoid toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl)\n\n      instance instNonUnitalCommRing : NonUnitalCommRing $typeName :=\n        Function.Injective.nonUnitalCommRing toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl)\n\n      local instance instNatCast : NatCast $typeName where\n        natCast n := mk n\n\n      local instance instIntCast : IntCast $typeName where\n        intCast z := mk z\n\n      lemma natCast_def (n : ℕ) : (n : $typeName) = ⟨n⟩ := rfl\n\n      lemma intCast_def (z : ℤ) : (z : $typeName) = ⟨z⟩ := rfl\n\n      local instance instCommRing : CommRing $typeName :=\n        Function.Injective.commRing toBitVec toBitVec_injective\n          rfl rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ => rfl)\n\n      namespace CommRing\n      attribute [scoped instance] instCommRing instNatCast instIntCast\n      end CommRing\n\n    end $typeName\n  ))\n  -- interpolating docstrings above is more trouble than it's worth\n  let docString :=\n    s!\"To use this instance, use `open scoped {typeName'}.CommRing`.\\n\\n\" ++\n    \"See the module docstring for an explanation\"\n  Lean.addDocString (typeName'.mkStr \"instCommRing\") docString\n  Lean.addDocString (typeName'.mkStr \"instNatCast\") docString\n  Lean.addDocString (typeName'.mkStr \"instIntCast\") docString\n\n"}
{"name":"UInt32.toBitVec_injective","module":"Mathlib.Data.UInt","initialProofState":"⊢ Function.Injective UInt32.toBitVec","decl":"set_option hygiene false in\nrun_cmd\n  for typeName' in [`UInt8, `UInt16, `UInt32, `UInt64, `USize] do\n  let typeName := Lean.mkIdent typeName'\n  Lean.Elab.Command.elabCommand (← `(\n    namespace $typeName\n\n      instance : Neg $typeName where\n        neg a := mk ⟨-a.val⟩\n\n      instance : Pow $typeName ℕ where\n        pow a n := mk ⟨a.val ^ n⟩\n\n      instance : SMul ℕ $typeName where\n        smul n a := mk ⟨n • a.val⟩\n\n      instance : SMul ℤ $typeName where\n        smul z a := mk ⟨z • a.val⟩\n\n      lemma neg_def (a : $typeName) : -a = ⟨⟨-a.val⟩⟩ := rfl\n\n      lemma pow_def (a : $typeName) (n : ℕ) : a ^ n = ⟨⟨a.val ^ n⟩⟩ := rfl\n\n      lemma nsmul_def (n : ℕ) (a : $typeName) : n • a = ⟨⟨n • a.val⟩⟩ := rfl\n\n      lemma zsmul_def (z : ℤ) (a : $typeName) : z • a = ⟨⟨z • a.val⟩⟩ := rfl\n\n      open $typeName (eq_of_val_eq) in\n      lemma val_injective : Function.Injective val := @eq_of_val_eq\n\n      open $typeName (eq_of_toBitVec_eq) in\n      lemma toBitVec_injective : Function.Injective toBitVec := @eq_of_toBitVec_eq\n\n      instance instCommMonoid : CommMonoid $typeName :=\n        Function.Injective.commMonoid toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl)\n\n      instance instNonUnitalCommRing : NonUnitalCommRing $typeName :=\n        Function.Injective.nonUnitalCommRing toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl)\n\n      local instance instNatCast : NatCast $typeName where\n        natCast n := mk n\n\n      local instance instIntCast : IntCast $typeName where\n        intCast z := mk z\n\n      lemma natCast_def (n : ℕ) : (n : $typeName) = ⟨n⟩ := rfl\n\n      lemma intCast_def (z : ℤ) : (z : $typeName) = ⟨z⟩ := rfl\n\n      local instance instCommRing : CommRing $typeName :=\n        Function.Injective.commRing toBitVec toBitVec_injective\n          rfl rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ => rfl)\n\n      namespace CommRing\n      attribute [scoped instance] instCommRing instNatCast instIntCast\n      end CommRing\n\n    end $typeName\n  ))\n  -- interpolating docstrings above is more trouble than it's worth\n  let docString :=\n    s!\"To use this instance, use `open scoped {typeName'}.CommRing`.\\n\\n\" ++\n    \"See the module docstring for an explanation\"\n  Lean.addDocString (typeName'.mkStr \"instCommRing\") docString\n  Lean.addDocString (typeName'.mkStr \"instNatCast\") docString\n  Lean.addDocString (typeName'.mkStr \"instIntCast\") docString\n\n"}
{"name":"UInt8.intCast_def","module":"Mathlib.Data.UInt","initialProofState":"z : Int\n⊢ Eq ↑z { toBitVec := ↑z }","decl":"set_option hygiene false in\nrun_cmd\n  for typeName' in [`UInt8, `UInt16, `UInt32, `UInt64, `USize] do\n  let typeName := Lean.mkIdent typeName'\n  Lean.Elab.Command.elabCommand (← `(\n    namespace $typeName\n\n      instance : Neg $typeName where\n        neg a := mk ⟨-a.val⟩\n\n      instance : Pow $typeName ℕ where\n        pow a n := mk ⟨a.val ^ n⟩\n\n      instance : SMul ℕ $typeName where\n        smul n a := mk ⟨n • a.val⟩\n\n      instance : SMul ℤ $typeName where\n        smul z a := mk ⟨z • a.val⟩\n\n      lemma neg_def (a : $typeName) : -a = ⟨⟨-a.val⟩⟩ := rfl\n\n      lemma pow_def (a : $typeName) (n : ℕ) : a ^ n = ⟨⟨a.val ^ n⟩⟩ := rfl\n\n      lemma nsmul_def (n : ℕ) (a : $typeName) : n • a = ⟨⟨n • a.val⟩⟩ := rfl\n\n      lemma zsmul_def (z : ℤ) (a : $typeName) : z • a = ⟨⟨z • a.val⟩⟩ := rfl\n\n      open $typeName (eq_of_val_eq) in\n      lemma val_injective : Function.Injective val := @eq_of_val_eq\n\n      open $typeName (eq_of_toBitVec_eq) in\n      lemma toBitVec_injective : Function.Injective toBitVec := @eq_of_toBitVec_eq\n\n      instance instCommMonoid : CommMonoid $typeName :=\n        Function.Injective.commMonoid toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl)\n\n      instance instNonUnitalCommRing : NonUnitalCommRing $typeName :=\n        Function.Injective.nonUnitalCommRing toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl)\n\n      local instance instNatCast : NatCast $typeName where\n        natCast n := mk n\n\n      local instance instIntCast : IntCast $typeName where\n        intCast z := mk z\n\n      lemma natCast_def (n : ℕ) : (n : $typeName) = ⟨n⟩ := rfl\n\n      lemma intCast_def (z : ℤ) : (z : $typeName) = ⟨z⟩ := rfl\n\n      local instance instCommRing : CommRing $typeName :=\n        Function.Injective.commRing toBitVec toBitVec_injective\n          rfl rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ => rfl)\n\n      namespace CommRing\n      attribute [scoped instance] instCommRing instNatCast instIntCast\n      end CommRing\n\n    end $typeName\n  ))\n  -- interpolating docstrings above is more trouble than it's worth\n  let docString :=\n    s!\"To use this instance, use `open scoped {typeName'}.CommRing`.\\n\\n\" ++\n    \"See the module docstring for an explanation\"\n  Lean.addDocString (typeName'.mkStr \"instCommRing\") docString\n  Lean.addDocString (typeName'.mkStr \"instNatCast\") docString\n  Lean.addDocString (typeName'.mkStr \"instIntCast\") docString\n\n"}
{"name":"UInt32.natCast_def","module":"Mathlib.Data.UInt","initialProofState":"n : Nat\n⊢ Eq ↑n { toBitVec := ↑n }","decl":"set_option hygiene false in\nrun_cmd\n  for typeName' in [`UInt8, `UInt16, `UInt32, `UInt64, `USize] do\n  let typeName := Lean.mkIdent typeName'\n  Lean.Elab.Command.elabCommand (← `(\n    namespace $typeName\n\n      instance : Neg $typeName where\n        neg a := mk ⟨-a.val⟩\n\n      instance : Pow $typeName ℕ where\n        pow a n := mk ⟨a.val ^ n⟩\n\n      instance : SMul ℕ $typeName where\n        smul n a := mk ⟨n • a.val⟩\n\n      instance : SMul ℤ $typeName where\n        smul z a := mk ⟨z • a.val⟩\n\n      lemma neg_def (a : $typeName) : -a = ⟨⟨-a.val⟩⟩ := rfl\n\n      lemma pow_def (a : $typeName) (n : ℕ) : a ^ n = ⟨⟨a.val ^ n⟩⟩ := rfl\n\n      lemma nsmul_def (n : ℕ) (a : $typeName) : n • a = ⟨⟨n • a.val⟩⟩ := rfl\n\n      lemma zsmul_def (z : ℤ) (a : $typeName) : z • a = ⟨⟨z • a.val⟩⟩ := rfl\n\n      open $typeName (eq_of_val_eq) in\n      lemma val_injective : Function.Injective val := @eq_of_val_eq\n\n      open $typeName (eq_of_toBitVec_eq) in\n      lemma toBitVec_injective : Function.Injective toBitVec := @eq_of_toBitVec_eq\n\n      instance instCommMonoid : CommMonoid $typeName :=\n        Function.Injective.commMonoid toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl)\n\n      instance instNonUnitalCommRing : NonUnitalCommRing $typeName :=\n        Function.Injective.nonUnitalCommRing toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl)\n\n      local instance instNatCast : NatCast $typeName where\n        natCast n := mk n\n\n      local instance instIntCast : IntCast $typeName where\n        intCast z := mk z\n\n      lemma natCast_def (n : ℕ) : (n : $typeName) = ⟨n⟩ := rfl\n\n      lemma intCast_def (z : ℤ) : (z : $typeName) = ⟨z⟩ := rfl\n\n      local instance instCommRing : CommRing $typeName :=\n        Function.Injective.commRing toBitVec toBitVec_injective\n          rfl rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ => rfl)\n\n      namespace CommRing\n      attribute [scoped instance] instCommRing instNatCast instIntCast\n      end CommRing\n\n    end $typeName\n  ))\n  -- interpolating docstrings above is more trouble than it's worth\n  let docString :=\n    s!\"To use this instance, use `open scoped {typeName'}.CommRing`.\\n\\n\" ++\n    \"See the module docstring for an explanation\"\n  Lean.addDocString (typeName'.mkStr \"instCommRing\") docString\n  Lean.addDocString (typeName'.mkStr \"instNatCast\") docString\n  Lean.addDocString (typeName'.mkStr \"instIntCast\") docString\n\n"}
{"name":"USize.pow_def","module":"Mathlib.Data.UInt","initialProofState":"a : USize\nn : Nat\n⊢ Eq (HPow.hPow a n) { toBitVec := { toFin := HPow.hPow a.val n } }","decl":"set_option hygiene false in\nrun_cmd\n  for typeName' in [`UInt8, `UInt16, `UInt32, `UInt64, `USize] do\n  let typeName := Lean.mkIdent typeName'\n  Lean.Elab.Command.elabCommand (← `(\n    namespace $typeName\n\n      instance : Neg $typeName where\n        neg a := mk ⟨-a.val⟩\n\n      instance : Pow $typeName ℕ where\n        pow a n := mk ⟨a.val ^ n⟩\n\n      instance : SMul ℕ $typeName where\n        smul n a := mk ⟨n • a.val⟩\n\n      instance : SMul ℤ $typeName where\n        smul z a := mk ⟨z • a.val⟩\n\n      lemma neg_def (a : $typeName) : -a = ⟨⟨-a.val⟩⟩ := rfl\n\n      lemma pow_def (a : $typeName) (n : ℕ) : a ^ n = ⟨⟨a.val ^ n⟩⟩ := rfl\n\n      lemma nsmul_def (n : ℕ) (a : $typeName) : n • a = ⟨⟨n • a.val⟩⟩ := rfl\n\n      lemma zsmul_def (z : ℤ) (a : $typeName) : z • a = ⟨⟨z • a.val⟩⟩ := rfl\n\n      open $typeName (eq_of_val_eq) in\n      lemma val_injective : Function.Injective val := @eq_of_val_eq\n\n      open $typeName (eq_of_toBitVec_eq) in\n      lemma toBitVec_injective : Function.Injective toBitVec := @eq_of_toBitVec_eq\n\n      instance instCommMonoid : CommMonoid $typeName :=\n        Function.Injective.commMonoid toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl)\n\n      instance instNonUnitalCommRing : NonUnitalCommRing $typeName :=\n        Function.Injective.nonUnitalCommRing toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl)\n\n      local instance instNatCast : NatCast $typeName where\n        natCast n := mk n\n\n      local instance instIntCast : IntCast $typeName where\n        intCast z := mk z\n\n      lemma natCast_def (n : ℕ) : (n : $typeName) = ⟨n⟩ := rfl\n\n      lemma intCast_def (z : ℤ) : (z : $typeName) = ⟨z⟩ := rfl\n\n      local instance instCommRing : CommRing $typeName :=\n        Function.Injective.commRing toBitVec toBitVec_injective\n          rfl rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ => rfl)\n\n      namespace CommRing\n      attribute [scoped instance] instCommRing instNatCast instIntCast\n      end CommRing\n\n    end $typeName\n  ))\n  -- interpolating docstrings above is more trouble than it's worth\n  let docString :=\n    s!\"To use this instance, use `open scoped {typeName'}.CommRing`.\\n\\n\" ++\n    \"See the module docstring for an explanation\"\n  Lean.addDocString (typeName'.mkStr \"instCommRing\") docString\n  Lean.addDocString (typeName'.mkStr \"instNatCast\") docString\n  Lean.addDocString (typeName'.mkStr \"instIntCast\") docString\n\n"}
{"name":"UInt8.val_injective","module":"Mathlib.Data.UInt","initialProofState":"⊢ Function.Injective UInt8.val","decl":"set_option hygiene false in\nrun_cmd\n  for typeName' in [`UInt8, `UInt16, `UInt32, `UInt64, `USize] do\n  let typeName := Lean.mkIdent typeName'\n  Lean.Elab.Command.elabCommand (← `(\n    namespace $typeName\n\n      instance : Neg $typeName where\n        neg a := mk ⟨-a.val⟩\n\n      instance : Pow $typeName ℕ where\n        pow a n := mk ⟨a.val ^ n⟩\n\n      instance : SMul ℕ $typeName where\n        smul n a := mk ⟨n • a.val⟩\n\n      instance : SMul ℤ $typeName where\n        smul z a := mk ⟨z • a.val⟩\n\n      lemma neg_def (a : $typeName) : -a = ⟨⟨-a.val⟩⟩ := rfl\n\n      lemma pow_def (a : $typeName) (n : ℕ) : a ^ n = ⟨⟨a.val ^ n⟩⟩ := rfl\n\n      lemma nsmul_def (n : ℕ) (a : $typeName) : n • a = ⟨⟨n • a.val⟩⟩ := rfl\n\n      lemma zsmul_def (z : ℤ) (a : $typeName) : z • a = ⟨⟨z • a.val⟩⟩ := rfl\n\n      open $typeName (eq_of_val_eq) in\n      lemma val_injective : Function.Injective val := @eq_of_val_eq\n\n      open $typeName (eq_of_toBitVec_eq) in\n      lemma toBitVec_injective : Function.Injective toBitVec := @eq_of_toBitVec_eq\n\n      instance instCommMonoid : CommMonoid $typeName :=\n        Function.Injective.commMonoid toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl)\n\n      instance instNonUnitalCommRing : NonUnitalCommRing $typeName :=\n        Function.Injective.nonUnitalCommRing toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl)\n\n      local instance instNatCast : NatCast $typeName where\n        natCast n := mk n\n\n      local instance instIntCast : IntCast $typeName where\n        intCast z := mk z\n\n      lemma natCast_def (n : ℕ) : (n : $typeName) = ⟨n⟩ := rfl\n\n      lemma intCast_def (z : ℤ) : (z : $typeName) = ⟨z⟩ := rfl\n\n      local instance instCommRing : CommRing $typeName :=\n        Function.Injective.commRing toBitVec toBitVec_injective\n          rfl rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ => rfl)\n\n      namespace CommRing\n      attribute [scoped instance] instCommRing instNatCast instIntCast\n      end CommRing\n\n    end $typeName\n  ))\n  -- interpolating docstrings above is more trouble than it's worth\n  let docString :=\n    s!\"To use this instance, use `open scoped {typeName'}.CommRing`.\\n\\n\" ++\n    \"See the module docstring for an explanation\"\n  Lean.addDocString (typeName'.mkStr \"instCommRing\") docString\n  Lean.addDocString (typeName'.mkStr \"instNatCast\") docString\n  Lean.addDocString (typeName'.mkStr \"instIntCast\") docString\n\n"}
{"name":"UInt8.nsmul_def","module":"Mathlib.Data.UInt","initialProofState":"n : Nat\na : UInt8\n⊢ Eq (HSMul.hSMul n a) { toBitVec := { toFin := HSMul.hSMul n a.val } }","decl":"set_option hygiene false in\nrun_cmd\n  for typeName' in [`UInt8, `UInt16, `UInt32, `UInt64, `USize] do\n  let typeName := Lean.mkIdent typeName'\n  Lean.Elab.Command.elabCommand (← `(\n    namespace $typeName\n\n      instance : Neg $typeName where\n        neg a := mk ⟨-a.val⟩\n\n      instance : Pow $typeName ℕ where\n        pow a n := mk ⟨a.val ^ n⟩\n\n      instance : SMul ℕ $typeName where\n        smul n a := mk ⟨n • a.val⟩\n\n      instance : SMul ℤ $typeName where\n        smul z a := mk ⟨z • a.val⟩\n\n      lemma neg_def (a : $typeName) : -a = ⟨⟨-a.val⟩⟩ := rfl\n\n      lemma pow_def (a : $typeName) (n : ℕ) : a ^ n = ⟨⟨a.val ^ n⟩⟩ := rfl\n\n      lemma nsmul_def (n : ℕ) (a : $typeName) : n • a = ⟨⟨n • a.val⟩⟩ := rfl\n\n      lemma zsmul_def (z : ℤ) (a : $typeName) : z • a = ⟨⟨z • a.val⟩⟩ := rfl\n\n      open $typeName (eq_of_val_eq) in\n      lemma val_injective : Function.Injective val := @eq_of_val_eq\n\n      open $typeName (eq_of_toBitVec_eq) in\n      lemma toBitVec_injective : Function.Injective toBitVec := @eq_of_toBitVec_eq\n\n      instance instCommMonoid : CommMonoid $typeName :=\n        Function.Injective.commMonoid toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl)\n\n      instance instNonUnitalCommRing : NonUnitalCommRing $typeName :=\n        Function.Injective.nonUnitalCommRing toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl)\n\n      local instance instNatCast : NatCast $typeName where\n        natCast n := mk n\n\n      local instance instIntCast : IntCast $typeName where\n        intCast z := mk z\n\n      lemma natCast_def (n : ℕ) : (n : $typeName) = ⟨n⟩ := rfl\n\n      lemma intCast_def (z : ℤ) : (z : $typeName) = ⟨z⟩ := rfl\n\n      local instance instCommRing : CommRing $typeName :=\n        Function.Injective.commRing toBitVec toBitVec_injective\n          rfl rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ => rfl)\n\n      namespace CommRing\n      attribute [scoped instance] instCommRing instNatCast instIntCast\n      end CommRing\n\n    end $typeName\n  ))\n  -- interpolating docstrings above is more trouble than it's worth\n  let docString :=\n    s!\"To use this instance, use `open scoped {typeName'}.CommRing`.\\n\\n\" ++\n    \"See the module docstring for an explanation\"\n  Lean.addDocString (typeName'.mkStr \"instCommRing\") docString\n  Lean.addDocString (typeName'.mkStr \"instNatCast\") docString\n  Lean.addDocString (typeName'.mkStr \"instIntCast\") docString\n\n"}
{"name":"UInt8.neg_def","module":"Mathlib.Data.UInt","initialProofState":"a : UInt8\n⊢ Eq (Neg.neg a) { toBitVec := { toFin := Neg.neg a.val } }","decl":"set_option hygiene false in\nrun_cmd\n  for typeName' in [`UInt8, `UInt16, `UInt32, `UInt64, `USize] do\n  let typeName := Lean.mkIdent typeName'\n  Lean.Elab.Command.elabCommand (← `(\n    namespace $typeName\n\n      instance : Neg $typeName where\n        neg a := mk ⟨-a.val⟩\n\n      instance : Pow $typeName ℕ where\n        pow a n := mk ⟨a.val ^ n⟩\n\n      instance : SMul ℕ $typeName where\n        smul n a := mk ⟨n • a.val⟩\n\n      instance : SMul ℤ $typeName where\n        smul z a := mk ⟨z • a.val⟩\n\n      lemma neg_def (a : $typeName) : -a = ⟨⟨-a.val⟩⟩ := rfl\n\n      lemma pow_def (a : $typeName) (n : ℕ) : a ^ n = ⟨⟨a.val ^ n⟩⟩ := rfl\n\n      lemma nsmul_def (n : ℕ) (a : $typeName) : n • a = ⟨⟨n • a.val⟩⟩ := rfl\n\n      lemma zsmul_def (z : ℤ) (a : $typeName) : z • a = ⟨⟨z • a.val⟩⟩ := rfl\n\n      open $typeName (eq_of_val_eq) in\n      lemma val_injective : Function.Injective val := @eq_of_val_eq\n\n      open $typeName (eq_of_toBitVec_eq) in\n      lemma toBitVec_injective : Function.Injective toBitVec := @eq_of_toBitVec_eq\n\n      instance instCommMonoid : CommMonoid $typeName :=\n        Function.Injective.commMonoid toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl)\n\n      instance instNonUnitalCommRing : NonUnitalCommRing $typeName :=\n        Function.Injective.nonUnitalCommRing toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl)\n\n      local instance instNatCast : NatCast $typeName where\n        natCast n := mk n\n\n      local instance instIntCast : IntCast $typeName where\n        intCast z := mk z\n\n      lemma natCast_def (n : ℕ) : (n : $typeName) = ⟨n⟩ := rfl\n\n      lemma intCast_def (z : ℤ) : (z : $typeName) = ⟨z⟩ := rfl\n\n      local instance instCommRing : CommRing $typeName :=\n        Function.Injective.commRing toBitVec toBitVec_injective\n          rfl rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ => rfl)\n\n      namespace CommRing\n      attribute [scoped instance] instCommRing instNatCast instIntCast\n      end CommRing\n\n    end $typeName\n  ))\n  -- interpolating docstrings above is more trouble than it's worth\n  let docString :=\n    s!\"To use this instance, use `open scoped {typeName'}.CommRing`.\\n\\n\" ++\n    \"See the module docstring for an explanation\"\n  Lean.addDocString (typeName'.mkStr \"instCommRing\") docString\n  Lean.addDocString (typeName'.mkStr \"instNatCast\") docString\n  Lean.addDocString (typeName'.mkStr \"instIntCast\") docString\n\n"}
{"name":"UInt16.intCast_def","module":"Mathlib.Data.UInt","initialProofState":"z : Int\n⊢ Eq ↑z { toBitVec := ↑z }","decl":"set_option hygiene false in\nrun_cmd\n  for typeName' in [`UInt8, `UInt16, `UInt32, `UInt64, `USize] do\n  let typeName := Lean.mkIdent typeName'\n  Lean.Elab.Command.elabCommand (← `(\n    namespace $typeName\n\n      instance : Neg $typeName where\n        neg a := mk ⟨-a.val⟩\n\n      instance : Pow $typeName ℕ where\n        pow a n := mk ⟨a.val ^ n⟩\n\n      instance : SMul ℕ $typeName where\n        smul n a := mk ⟨n • a.val⟩\n\n      instance : SMul ℤ $typeName where\n        smul z a := mk ⟨z • a.val⟩\n\n      lemma neg_def (a : $typeName) : -a = ⟨⟨-a.val⟩⟩ := rfl\n\n      lemma pow_def (a : $typeName) (n : ℕ) : a ^ n = ⟨⟨a.val ^ n⟩⟩ := rfl\n\n      lemma nsmul_def (n : ℕ) (a : $typeName) : n • a = ⟨⟨n • a.val⟩⟩ := rfl\n\n      lemma zsmul_def (z : ℤ) (a : $typeName) : z • a = ⟨⟨z • a.val⟩⟩ := rfl\n\n      open $typeName (eq_of_val_eq) in\n      lemma val_injective : Function.Injective val := @eq_of_val_eq\n\n      open $typeName (eq_of_toBitVec_eq) in\n      lemma toBitVec_injective : Function.Injective toBitVec := @eq_of_toBitVec_eq\n\n      instance instCommMonoid : CommMonoid $typeName :=\n        Function.Injective.commMonoid toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl)\n\n      instance instNonUnitalCommRing : NonUnitalCommRing $typeName :=\n        Function.Injective.nonUnitalCommRing toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl)\n\n      local instance instNatCast : NatCast $typeName where\n        natCast n := mk n\n\n      local instance instIntCast : IntCast $typeName where\n        intCast z := mk z\n\n      lemma natCast_def (n : ℕ) : (n : $typeName) = ⟨n⟩ := rfl\n\n      lemma intCast_def (z : ℤ) : (z : $typeName) = ⟨z⟩ := rfl\n\n      local instance instCommRing : CommRing $typeName :=\n        Function.Injective.commRing toBitVec toBitVec_injective\n          rfl rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ => rfl)\n\n      namespace CommRing\n      attribute [scoped instance] instCommRing instNatCast instIntCast\n      end CommRing\n\n    end $typeName\n  ))\n  -- interpolating docstrings above is more trouble than it's worth\n  let docString :=\n    s!\"To use this instance, use `open scoped {typeName'}.CommRing`.\\n\\n\" ++\n    \"See the module docstring for an explanation\"\n  Lean.addDocString (typeName'.mkStr \"instCommRing\") docString\n  Lean.addDocString (typeName'.mkStr \"instNatCast\") docString\n  Lean.addDocString (typeName'.mkStr \"instIntCast\") docString\n\n"}
{"name":"UInt32.zsmul_def","module":"Mathlib.Data.UInt","initialProofState":"z : Int\na : UInt32\n⊢ Eq (HSMul.hSMul z a) { toBitVec := { toFin := HSMul.hSMul z a.val } }","decl":"set_option hygiene false in\nrun_cmd\n  for typeName' in [`UInt8, `UInt16, `UInt32, `UInt64, `USize] do\n  let typeName := Lean.mkIdent typeName'\n  Lean.Elab.Command.elabCommand (← `(\n    namespace $typeName\n\n      instance : Neg $typeName where\n        neg a := mk ⟨-a.val⟩\n\n      instance : Pow $typeName ℕ where\n        pow a n := mk ⟨a.val ^ n⟩\n\n      instance : SMul ℕ $typeName where\n        smul n a := mk ⟨n • a.val⟩\n\n      instance : SMul ℤ $typeName where\n        smul z a := mk ⟨z • a.val⟩\n\n      lemma neg_def (a : $typeName) : -a = ⟨⟨-a.val⟩⟩ := rfl\n\n      lemma pow_def (a : $typeName) (n : ℕ) : a ^ n = ⟨⟨a.val ^ n⟩⟩ := rfl\n\n      lemma nsmul_def (n : ℕ) (a : $typeName) : n • a = ⟨⟨n • a.val⟩⟩ := rfl\n\n      lemma zsmul_def (z : ℤ) (a : $typeName) : z • a = ⟨⟨z • a.val⟩⟩ := rfl\n\n      open $typeName (eq_of_val_eq) in\n      lemma val_injective : Function.Injective val := @eq_of_val_eq\n\n      open $typeName (eq_of_toBitVec_eq) in\n      lemma toBitVec_injective : Function.Injective toBitVec := @eq_of_toBitVec_eq\n\n      instance instCommMonoid : CommMonoid $typeName :=\n        Function.Injective.commMonoid toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl)\n\n      instance instNonUnitalCommRing : NonUnitalCommRing $typeName :=\n        Function.Injective.nonUnitalCommRing toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl)\n\n      local instance instNatCast : NatCast $typeName where\n        natCast n := mk n\n\n      local instance instIntCast : IntCast $typeName where\n        intCast z := mk z\n\n      lemma natCast_def (n : ℕ) : (n : $typeName) = ⟨n⟩ := rfl\n\n      lemma intCast_def (z : ℤ) : (z : $typeName) = ⟨z⟩ := rfl\n\n      local instance instCommRing : CommRing $typeName :=\n        Function.Injective.commRing toBitVec toBitVec_injective\n          rfl rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ => rfl)\n\n      namespace CommRing\n      attribute [scoped instance] instCommRing instNatCast instIntCast\n      end CommRing\n\n    end $typeName\n  ))\n  -- interpolating docstrings above is more trouble than it's worth\n  let docString :=\n    s!\"To use this instance, use `open scoped {typeName'}.CommRing`.\\n\\n\" ++\n    \"See the module docstring for an explanation\"\n  Lean.addDocString (typeName'.mkStr \"instCommRing\") docString\n  Lean.addDocString (typeName'.mkStr \"instNatCast\") docString\n  Lean.addDocString (typeName'.mkStr \"instIntCast\") docString\n\n"}
{"name":"UInt64.nsmul_def","module":"Mathlib.Data.UInt","initialProofState":"n : Nat\na : UInt64\n⊢ Eq (HSMul.hSMul n a) { toBitVec := { toFin := HSMul.hSMul n a.val } }","decl":"set_option hygiene false in\nrun_cmd\n  for typeName' in [`UInt8, `UInt16, `UInt32, `UInt64, `USize] do\n  let typeName := Lean.mkIdent typeName'\n  Lean.Elab.Command.elabCommand (← `(\n    namespace $typeName\n\n      instance : Neg $typeName where\n        neg a := mk ⟨-a.val⟩\n\n      instance : Pow $typeName ℕ where\n        pow a n := mk ⟨a.val ^ n⟩\n\n      instance : SMul ℕ $typeName where\n        smul n a := mk ⟨n • a.val⟩\n\n      instance : SMul ℤ $typeName where\n        smul z a := mk ⟨z • a.val⟩\n\n      lemma neg_def (a : $typeName) : -a = ⟨⟨-a.val⟩⟩ := rfl\n\n      lemma pow_def (a : $typeName) (n : ℕ) : a ^ n = ⟨⟨a.val ^ n⟩⟩ := rfl\n\n      lemma nsmul_def (n : ℕ) (a : $typeName) : n • a = ⟨⟨n • a.val⟩⟩ := rfl\n\n      lemma zsmul_def (z : ℤ) (a : $typeName) : z • a = ⟨⟨z • a.val⟩⟩ := rfl\n\n      open $typeName (eq_of_val_eq) in\n      lemma val_injective : Function.Injective val := @eq_of_val_eq\n\n      open $typeName (eq_of_toBitVec_eq) in\n      lemma toBitVec_injective : Function.Injective toBitVec := @eq_of_toBitVec_eq\n\n      instance instCommMonoid : CommMonoid $typeName :=\n        Function.Injective.commMonoid toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl)\n\n      instance instNonUnitalCommRing : NonUnitalCommRing $typeName :=\n        Function.Injective.nonUnitalCommRing toBitVec toBitVec_injective\n          rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl)\n\n      local instance instNatCast : NatCast $typeName where\n        natCast n := mk n\n\n      local instance instIntCast : IntCast $typeName where\n        intCast z := mk z\n\n      lemma natCast_def (n : ℕ) : (n : $typeName) = ⟨n⟩ := rfl\n\n      lemma intCast_def (z : ℤ) : (z : $typeName) = ⟨z⟩ := rfl\n\n      local instance instCommRing : CommRing $typeName :=\n        Function.Injective.commRing toBitVec toBitVec_injective\n          rfl rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n          (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ => rfl)\n\n      namespace CommRing\n      attribute [scoped instance] instCommRing instNatCast instIntCast\n      end CommRing\n\n    end $typeName\n  ))\n  -- interpolating docstrings above is more trouble than it's worth\n  let docString :=\n    s!\"To use this instance, use `open scoped {typeName'}.CommRing`.\\n\\n\" ++\n    \"See the module docstring for an explanation\"\n  Lean.addDocString (typeName'.mkStr \"instCommRing\") docString\n  Lean.addDocString (typeName'.mkStr \"instNatCast\") docString\n  Lean.addDocString (typeName'.mkStr \"instIntCast\") docString\n\n"}
