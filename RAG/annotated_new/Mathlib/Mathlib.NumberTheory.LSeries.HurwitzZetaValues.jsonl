{"name":"HurwitzZeta.cosZeta_two_mul_nat","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaValues","initialProofState":"k : Nat\nx : Real\nhk : Ne k 0\nhx : Membership.mem (Set.Icc 0 1) x\n⊢ Eq (HurwitzZeta.cosZeta (↑x) (HMul.hMul 2 ↑k)) (HMul.hMul (HDiv.hDiv (HDiv.hDiv (HMul.hMul (HPow.hPow (-1) (HAdd.hAdd k 1)) (HPow.hPow (HMul.hMul 2 ↑Real.pi) (HMul.hMul 2 k))) 2) ↑(HMul.hMul 2 k).factorial) (Polynomial.eval (↑x) (Polynomial.map (algebraMap Rat Complex) (Polynomial.bernoulli (HMul.hMul 2 k)))))","decl":"/-- Express the value of `cosZeta` at a positive even integer as a value\nof the Bernoulli polynomial. -/\ntheorem cosZeta_two_mul_nat (hk : k ≠ 0) (hx : x ∈ Icc 0 1) :\n    cosZeta x (2 * k) = (-1) ^ (k + 1) * (2 * π) ^ (2 * k) / 2 / (2 * k)! *\n      ((Polynomial.bernoulli (2 * k)).map (algebraMap ℚ ℂ)).eval (x : ℂ) := by\n  rw [← (hasSum_nat_cosZeta x (?_ : 1 < re (2 * k))).tsum_eq]\n  · refine Eq.trans ?_ <|\n      (congr_arg ofReal (hasSum_one_div_nat_pow_mul_cos hk hx).tsum_eq).trans ?_\n    · rw [ofReal_tsum]\n      refine tsum_congr fun n ↦ ?_\n      norm_cast\n      ring_nf\n    · push_cast\n      congr 1\n      have : (Polynomial.bernoulli (2 * k)).map (algebraMap ℚ ℂ) = _ :=\n        (Polynomial.map_map (algebraMap ℚ ℝ) ofRealHom _).symm\n      rw [this, ← ofRealHom_eq_coe, ← ofRealHom_eq_coe]\n      apply Polynomial.map_aeval_eq_aeval_map (by simp)\n  · norm_cast\n    omega\n\n"}
{"name":"HurwitzZeta.sinZeta_two_mul_nat_add_one","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaValues","initialProofState":"k : Nat\nx : Real\nhk : Ne k 0\nhx : Membership.mem (Set.Icc 0 1) x\n⊢ Eq (HurwitzZeta.sinZeta (↑x) (HAdd.hAdd (HMul.hMul 2 ↑k) 1)) (HMul.hMul (HDiv.hDiv (HDiv.hDiv (HMul.hMul (HPow.hPow (-1) (HAdd.hAdd k 1)) (HPow.hPow (HMul.hMul 2 ↑Real.pi) (HAdd.hAdd (HMul.hMul 2 k) 1))) 2) ↑(HAdd.hAdd (HMul.hMul 2 k) 1).factorial) (Polynomial.eval (↑x) (Polynomial.map (algebraMap Rat Complex) (Polynomial.bernoulli (HAdd.hAdd (HMul.hMul 2 k) 1)))))","decl":"/--\nExpress the value of `sinZeta` at an odd integer `> 1` as a value of the Bernoulli polynomial.\n\nNote that this formula is also correct for `k = 0` (i.e. for the value at `s = 1`), but we do not\nprove it in this case, owing to the additional difficulty of working with series that are only\nconditionally convergent.\n-/\ntheorem sinZeta_two_mul_nat_add_one (hk : k ≠ 0) (hx : x ∈ Icc 0 1) :\n    sinZeta x (2 * k + 1) = (-1) ^ (k + 1) * (2 * π) ^ (2 * k + 1) / 2 / (2 * k + 1)! *\n      ((Polynomial.bernoulli (2 * k + 1)).map (algebraMap ℚ ℂ)).eval (x : ℂ) := by\n  rw [← (hasSum_nat_sinZeta x (?_ : 1 < re (2 * k + 1))).tsum_eq]\n  · refine Eq.trans ?_ <|\n      (congr_arg ofReal (hasSum_one_div_nat_pow_mul_sin hk hx).tsum_eq).trans ?_\n    · rw [ofReal_tsum]\n      refine tsum_congr fun n ↦ ?_\n      norm_cast\n      ring_nf\n    · push_cast\n      congr 1\n      have : (Polynomial.bernoulli (2 * k + 1)).map (algebraMap ℚ ℂ) = _ :=\n        (Polynomial.map_map (algebraMap ℚ ℝ) ofRealHom _).symm\n      rw [this, ← ofRealHom_eq_coe, ← ofRealHom_eq_coe]\n      apply Polynomial.map_aeval_eq_aeval_map (by simp)\n  · norm_cast\n    omega\n\n"}
{"name":"HurwitzZeta.cosZeta_two_mul_nat'","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaValues","initialProofState":"k : Nat\nx : Real\nhk : Ne k 0\nhx : Membership.mem (Set.Icc 0 1) x\n⊢ Eq (HurwitzZeta.cosZeta (↑x) (HMul.hMul 2 ↑k)) (HMul.hMul (HDiv.hDiv (HDiv.hDiv (HPow.hPow (-1) (HAdd.hAdd k 1)) (HMul.hMul 2 ↑k)) (HMul.hMul 2 ↑k).Gammaℂ) (Polynomial.eval (↑x) (Polynomial.map (algebraMap Rat Complex) (Polynomial.bernoulli (HMul.hMul 2 k)))))","decl":"/-- Reformulation of `cosZeta_two_mul_nat` using `Gammaℂ`. -/\ntheorem cosZeta_two_mul_nat' (hk : k ≠ 0) (hx : x ∈ Icc (0 : ℝ) 1) :\n    cosZeta x (2 * k) = (-1) ^ (k + 1) / (2 * k) / Gammaℂ (2 * k) *\n      ((Polynomial.bernoulli (2 * k)).map (algebraMap ℚ ℂ)).eval (x : ℂ) := by\n  rw [cosZeta_two_mul_nat hk hx]\n  congr 1\n  have : (2 * k)! = (2 * k) * Complex.Gamma (2 * k) := by\n    rw [(by { norm_cast; omega } : 2 * (k : ℂ) = ↑(2 * k - 1) + 1), Complex.Gamma_nat_eq_factorial,\n      ← Nat.cast_add_one, ← Nat.cast_mul, ← Nat.factorial_succ, Nat.sub_add_cancel (by omega)]\n  simp_rw [this, Gammaℂ, cpow_neg, ← div_div, div_inv_eq_mul, div_mul_eq_mul_div, div_div,\n    mul_right_comm (2 : ℂ) (k : ℂ)]\n  norm_cast\n\n"}
{"name":"HurwitzZeta.sinZeta_two_mul_nat_add_one'","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaValues","initialProofState":"k : Nat\nx : Real\nhk : Ne k 0\nhx : Membership.mem (Set.Icc 0 1) x\n⊢ Eq (HurwitzZeta.sinZeta (↑x) (HAdd.hAdd (HMul.hMul 2 ↑k) 1)) (HMul.hMul (HDiv.hDiv (HDiv.hDiv (HPow.hPow (-1) (HAdd.hAdd k 1)) (HAdd.hAdd (HMul.hMul 2 ↑k) 1)) (HAdd.hAdd (HMul.hMul 2 ↑k) 1).Gammaℂ) (Polynomial.eval (↑x) (Polynomial.map (algebraMap Rat Complex) (Polynomial.bernoulli (HAdd.hAdd (HMul.hMul 2 k) 1)))))","decl":"/-- Reformulation of `sinZeta_two_mul_nat_add_one` using `Gammaℂ`. -/\ntheorem sinZeta_two_mul_nat_add_one' (hk : k ≠ 0) (hx : x ∈ Icc (0 : ℝ) 1) :\n    sinZeta x (2 * k + 1) = (-1) ^ (k + 1) / (2 * k + 1) / Gammaℂ (2 * k + 1) *\n      ((Polynomial.bernoulli (2 * k + 1)).map (algebraMap ℚ ℂ)).eval (x : ℂ) := by\n  rw [sinZeta_two_mul_nat_add_one hk hx]\n  congr 1\n  have : (2 * k + 1)! = (2 * k + 1) * Complex.Gamma (2 * k + 1) := by\n    rw [(by simp : Complex.Gamma (2 * k + 1) = Complex.Gamma (↑(2 * k) + 1)),\n       Complex.Gamma_nat_eq_factorial, ← Nat.cast_ofNat (R := ℂ), ← Nat.cast_mul,\n      ← Nat.cast_add_one, ← Nat.cast_mul, ← Nat.factorial_succ]\n  simp_rw [this, Gammaℂ, cpow_neg, ← div_div, div_inv_eq_mul, div_mul_eq_mul_div, div_div]\n  rw [(by simp : 2 * (k : ℂ) + 1 = ↑(2 * k + 1)), cpow_natCast]\n  ring\n\n"}
{"name":"HurwitzZeta.hurwitzZetaEven_one_sub_two_mul_nat","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaValues","initialProofState":"k : Nat\nx : Real\nhk : Ne k 0\nhx : Membership.mem (Set.Icc 0 1) x\n⊢ Eq (HurwitzZeta.hurwitzZetaEven (↑x) (HSub.hSub 1 (HMul.hMul 2 ↑k))) (HMul.hMul (HDiv.hDiv (-1) (HMul.hMul 2 ↑k)) (Polynomial.eval (↑x) (Polynomial.map (algebraMap Rat Complex) (Polynomial.bernoulli (HMul.hMul 2 k)))))","decl":"theorem hurwitzZetaEven_one_sub_two_mul_nat (hk : k ≠ 0) (hx : x ∈ Icc (0 : ℝ) 1) :\n    hurwitzZetaEven x (1 - 2 * k) =\n      -1 / (2 * k) * ((Polynomial.bernoulli (2 * k)).map (algebraMap ℚ ℂ)).eval (x : ℂ) := by\n  have h1 (n : ℕ) : (2 * k : ℂ) ≠ -n := by\n    rw [← Int.cast_ofNat, ← Int.cast_natCast, ← Int.cast_mul, ← Int.cast_natCast n, ← Int.cast_neg,\n      Ne, Int.cast_inj, ← Ne]\n    refine ne_of_gt ((neg_nonpos_of_nonneg n.cast_nonneg).trans_lt (mul_pos two_pos ?_))\n    exact Nat.cast_pos.mpr (Nat.pos_of_ne_zero hk)\n  have h2 : (2 * k : ℂ) ≠ 1 := by norm_cast; simp\n  have h3 : Gammaℂ (2 * k) ≠ 0 := by\n    refine mul_ne_zero (mul_ne_zero two_ne_zero ?_) (Gamma_ne_zero h1)\n    simp [pi_ne_zero]\n  rw [hurwitzZetaEven_one_sub _ h1 (Or.inr h2), ← Gammaℂ, cosZeta_two_mul_nat' hk hx, ← mul_assoc,\n    ← mul_div_assoc, mul_assoc, mul_div_cancel_left₀ _ h3, ← mul_div_assoc]\n  congr 2\n  rw [mul_div_assoc, mul_div_cancel_left₀ _ two_ne_zero, ← ofReal_natCast, ← ofReal_mul,\n    ← ofReal_cos, mul_comm π, ← sub_zero (k * π), cos_nat_mul_pi_sub, Real.cos_zero, mul_one,\n    ofReal_pow, ofReal_neg, ofReal_one, pow_succ, mul_neg_one, mul_neg, ← mul_pow, neg_one_mul,\n    neg_neg, one_pow]\n\n"}
{"name":"HurwitzZeta.hurwitzZetaOdd_neg_two_mul_nat","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaValues","initialProofState":"k : Nat\nx : Real\nhk : Ne k 0\nhx : Membership.mem (Set.Icc 0 1) x\n⊢ Eq (HurwitzZeta.hurwitzZetaOdd (↑x) (Neg.neg (HMul.hMul 2 ↑k))) (HMul.hMul (HDiv.hDiv (-1) (HAdd.hAdd (HMul.hMul 2 ↑k) 1)) (Polynomial.eval (↑x) (Polynomial.map (algebraMap Rat Complex) (Polynomial.bernoulli (HAdd.hAdd (HMul.hMul 2 k) 1)))))","decl":"theorem hurwitzZetaOdd_neg_two_mul_nat (hk : k ≠ 0) (hx : x ∈ Icc (0 : ℝ) 1) :\n    hurwitzZetaOdd x (-(2 * k)) =\n    -1 / (2 * k + 1) * ((Polynomial.bernoulli (2 * k + 1)).map (algebraMap ℚ ℂ)).eval (x : ℂ) := by\n  have h1 (n : ℕ) : (2 * k + 1 : ℂ) ≠ -n := by\n    rw [← Int.cast_ofNat, ← Int.cast_natCast, ← Int.cast_mul, ← Int.cast_natCast n, ← Int.cast_neg,\n      ← Int.cast_one, ← Int.cast_add, Ne, Int.cast_inj, ← Ne]\n    refine ne_of_gt ((neg_nonpos_of_nonneg n.cast_nonneg).trans_lt ?_)\n    positivity\n  have h3 : Gammaℂ (2 * k + 1) ≠ 0 := by\n    refine mul_ne_zero (mul_ne_zero two_ne_zero ?_) (Gamma_ne_zero h1)\n    simp [pi_ne_zero]\n  rw [(by simp : -(2 * k : ℂ) = 1 - (2 * k + 1)),\n    hurwitzZetaOdd_one_sub _ h1, ← Gammaℂ, sinZeta_two_mul_nat_add_one' hk hx, ← mul_assoc,\n    ← mul_div_assoc, mul_assoc, mul_div_cancel_left₀ _ h3, ← mul_div_assoc]\n  congr 2\n  rw [mul_div_assoc, add_div, mul_div_cancel_left₀ _ two_ne_zero, ← ofReal_natCast,\n    ← ofReal_one, ← ofReal_ofNat, ← ofReal_div, ← ofReal_add, ← ofReal_mul,\n    ← ofReal_sin, mul_comm π, add_mul, mul_comm (1 / 2), mul_one_div, Real.sin_add_pi_div_two,\n    ← sub_zero (k * π), cos_nat_mul_pi_sub, Real.cos_zero, mul_one,\n    ofReal_pow, ofReal_neg, ofReal_one, pow_succ, mul_neg_one, mul_neg, ← mul_pow, neg_one_mul,\n    neg_neg, one_pow]\n\n-- private because it is superseded by `hurwitzZeta_neg_nat` below\n"}
{"name":"HurwitzZeta.hurwitzZeta_neg_nat","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaValues","initialProofState":"k : Nat\nx : Real\nhk : Ne k 0\nhx : Membership.mem (Set.Icc 0 1) x\n⊢ Eq (HurwitzZeta.hurwitzZeta (↑x) (Neg.neg ↑k)) (HMul.hMul (HDiv.hDiv (-1) (HAdd.hAdd (↑k) 1)) (Polynomial.eval (↑x) (Polynomial.map (algebraMap Rat Complex) (Polynomial.bernoulli (HAdd.hAdd k 1)))))","decl":"/-- Values of Hurwitz zeta functions at (strictly) negative integers.\n\nTODO: This formula is also correct for `k = 0`; but our current proof does not work in this\ncase. -/\ntheorem hurwitzZeta_neg_nat (hk : k ≠ 0) (hx : x ∈ Icc (0 : ℝ) 1) :\n    hurwitzZeta x (-k) =\n    -1 / (k + 1) * ((Polynomial.bernoulli (k + 1)).map (algebraMap ℚ ℂ)).eval (x : ℂ) := by\n  rcases Nat.even_or_odd' k with ⟨n, (rfl | rfl)⟩\n  · exact_mod_cast hurwitzZeta_neg_two_mul_nat (by omega : n ≠ 0) hx\n  · exact_mod_cast hurwitzZeta_one_sub_two_mul_nat (by omega : n + 1 ≠ 0) hx\n\n"}
{"name":"riemannZeta_two_mul_nat","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaValues","initialProofState":"k : Nat\nhk : Ne k 0\n⊢ Eq (riemannZeta (HMul.hMul 2 ↑k)) (HDiv.hDiv (HMul.hMul (HMul.hMul (HMul.hMul (HPow.hPow (-1) (HAdd.hAdd k 1)) (HPow.hPow 2 (HSub.hSub (HMul.hMul 2 k) 1))) (HPow.hPow (↑Real.pi) (HMul.hMul 2 k))) ↑(bernoulli (HMul.hMul 2 k))) ↑(HMul.hMul 2 k).factorial)","decl":"/-- Explicit formula for `ζ (2 * k)`, for `k ∈ ℕ` with `k ≠ 0`, in terms of the Bernoulli number\n`bernoulli (2 * k)`.\n\nCompare `hasSum_zeta_nat` for a version formulated in terms of a sum over `1 / n ^ (2 * k)`, and\n`riemannZeta_neg_nat_eq_bernoulli` for values at negative integers (equivalent to the above via\nthe functional equation). -/\ntheorem riemannZeta_two_mul_nat {k : ℕ} (hk : k ≠ 0) :\n    riemannZeta (2 * k) = (-1) ^ (k + 1) * (2 : ℂ) ^ (2 * k - 1)\n      * (π : ℂ) ^ (2 * k) * bernoulli (2 * k) / (2 * k)! := by\n  convert congr_arg ((↑) : ℝ → ℂ) (hasSum_zeta_nat hk).tsum_eq\n  · rw [← Nat.cast_two, ← Nat.cast_mul, zeta_nat_eq_tsum_of_gt_one (by omega)]\n    simp [push_cast]\n  · norm_cast\n\n"}
{"name":"riemannZeta_two","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaValues","initialProofState":"⊢ Eq (riemannZeta 2) (HDiv.hDiv (HPow.hPow (↑Real.pi) 2) 6)","decl":"theorem riemannZeta_two : riemannZeta 2 = (π : ℂ) ^ 2 / 6 := by\n  convert congr_arg ((↑) : ℝ → ℂ) hasSum_zeta_two.tsum_eq\n  · rw [← Nat.cast_two, zeta_nat_eq_tsum_of_gt_one one_lt_two]\n    simp [push_cast]\n  · norm_cast\n\n"}
{"name":"riemannZeta_four","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaValues","initialProofState":"⊢ Eq (riemannZeta 4) (HDiv.hDiv (HPow.hPow (↑Real.pi) 4) 90)","decl":"theorem riemannZeta_four : riemannZeta 4 = π ^ 4 / 90 := by\n  convert congr_arg ((↑) : ℝ → ℂ) hasSum_zeta_four.tsum_eq\n  · rw [← Nat.cast_one, show (4 : ℂ) = (4 : ℕ) by norm_num,\n      zeta_nat_eq_tsum_of_gt_one (by norm_num : 1 < 4)]\n    simp only [push_cast]\n  · norm_cast\n\n"}
{"name":"riemannZeta_neg_nat_eq_bernoulli'","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaValues","initialProofState":"k : Nat\n⊢ Eq (riemannZeta (Neg.neg ↑k)) (HDiv.hDiv (Neg.neg ↑(bernoulli' (HAdd.hAdd k 1))) (HAdd.hAdd (↑k) 1))","decl":"/-- Value of Riemann zeta at `-ℕ` in terms of `bernoulli'`. -/\ntheorem riemannZeta_neg_nat_eq_bernoulli' (k : ℕ) :\n    riemannZeta (-k) = -bernoulli' (k + 1) / (k + 1) := by\n  rcases eq_or_ne k 0 with rfl | hk\n  · rw [Nat.cast_zero, neg_zero, riemannZeta_zero, zero_add, zero_add, div_one,\n      bernoulli'_one, Rat.cast_div, Rat.cast_one, Rat.cast_ofNat, neg_div]\n  · rw [← hurwitzZeta_zero, ← QuotientAddGroup.mk_zero, hurwitzZeta_neg_nat hk\n      (left_mem_Icc.mpr zero_le_one), ofReal_zero, Polynomial.eval_zero_map,\n      Polynomial.bernoulli_eval_zero, Algebra.algebraMap_eq_smul_one, Rat.smul_one_eq_cast,\n      div_mul_eq_mul_div, neg_one_mul, bernoulli_eq_bernoulli'_of_ne_one (by simp [hk])]\n\n"}
{"name":"riemannZeta_neg_nat_eq_bernoulli","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaValues","initialProofState":"k : Nat\n⊢ Eq (riemannZeta (Neg.neg ↑k)) (HDiv.hDiv (HMul.hMul (HPow.hPow (-1) k) ↑(bernoulli (HAdd.hAdd k 1))) (HAdd.hAdd (↑k) 1))","decl":"/-- Value of Riemann zeta at `-ℕ` in terms of `bernoulli`. -/\ntheorem riemannZeta_neg_nat_eq_bernoulli (k : ℕ) :\n    riemannZeta (-k) = (-1 : ℂ) ^ k * bernoulli (k + 1) / (k + 1) := by\n  rw [riemannZeta_neg_nat_eq_bernoulli', bernoulli, Rat.cast_mul, Rat.cast_pow, Rat.cast_neg,\n    Rat.cast_one, ← neg_one_mul, ← mul_assoc, pow_succ, ← mul_assoc, ← mul_pow, neg_one_mul (-1),\n    neg_neg, one_pow, one_mul]\n"}
