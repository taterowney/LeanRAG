{"name":"SubringClass.toNegMemClass","module":"Mathlib.Algebra.Ring.Subring.Defs","initialProofState":"S : Type u_1\nR : outParam (Type u)\ninst✝¹ : Ring R\ninst✝ : SetLike S R\nself : SubringClass S R\n⊢ NegMemClass S R","decl":"/-- `SubringClass S R` states that `S` is a type of subsets `s ⊆ R` that\nare both a multiplicative submonoid and an additive subgroup. -/\nclass SubringClass (S : Type*) (R : outParam (Type u)) [Ring R] [SetLike S R] extends\n  SubsemiringClass S R, NegMemClass S R : Prop\n\n-- See note [lower instance priority]\n"}
{"name":"SubringClass.toSubsemiringClass","module":"Mathlib.Algebra.Ring.Subring.Defs","initialProofState":"S : Type u_1\nR : outParam (Type u)\ninst✝¹ : Ring R\ninst✝ : SetLike S R\nself : SubringClass S R\n⊢ SubsemiringClass S R","decl":"/-- `SubringClass S R` states that `S` is a type of subsets `s ⊆ R` that\nare both a multiplicative submonoid and an additive subgroup. -/\nclass SubringClass (S : Type*) (R : outParam (Type u)) [Ring R] [SetLike S R] extends\n  SubsemiringClass S R, NegMemClass S R : Prop\n\n-- See note [lower instance priority]\n"}
{"name":"SubringClass.addSubgroupClass","module":"Mathlib.Algebra.Ring.Subring.Defs","initialProofState":"S : Type u_1\nR : Type u\ninst✝¹ : SetLike S R\ninst✝ : Ring R\nh : SubringClass S R\n⊢ AddSubgroupClass S R","decl":"instance (priority := 100) SubringClass.addSubgroupClass (S : Type*) (R : Type u)\n    [SetLike S R] [Ring R] [h : SubringClass S R] : AddSubgroupClass S R :=\n  { h with }\n\n"}
{"name":"SubringClass.nonUnitalSubringClass","module":"Mathlib.Algebra.Ring.Subring.Defs","initialProofState":"S : Type u_1\nR : Type u\ninst✝² : SetLike S R\ninst✝¹ : Ring R\ninst✝ : SubringClass S R\n⊢ NonUnitalSubringClass S R","decl":"instance (priority := 100) SubringClass.nonUnitalSubringClass (S : Type*) (R : Type u)\n    [SetLike S R] [Ring R] [SubringClass S R] : NonUnitalSubringClass S R where\n\n"}
{"name":"intCast_mem","module":"Mathlib.Algebra.Ring.Subring.Defs","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\ninst✝ : SetLike S R\nhSR : SubringClass S R\ns : S\nn : Int\n⊢ Membership.mem s ↑n","decl":"@[aesop safe apply (rule_sets := [SetLike])]\ntheorem intCast_mem (n : ℤ) : (n : R) ∈ s := by simp only [← zsmul_one, zsmul_mem, one_mem]\n\n"}
{"name":"SubringClass.instIsDomainSubtypeMem","module":"Mathlib.Algebra.Ring.Subring.Defs","initialProofState":"S : Type v\ns : S\nR : Type u_1\ninst✝³ : Ring R\ninst✝² : IsDomain R\ninst✝¹ : SetLike S R\ninst✝ : SubringClass S R\n⊢ IsDomain (Subtype fun x => Membership.mem s x)","decl":"/-- A subring of a domain is a domain. -/\ninstance (priority := 75) {R} [Ring R] [IsDomain R] [SetLike S R] [SubringClass S R] : IsDomain s :=\n  NoZeroDivisors.to_isDomain _\n\n"}
{"name":"SubringClass.coeSubtype","module":"Mathlib.Algebra.Ring.Subring.Defs","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\ninst✝ : SetLike S R\nhSR : SubringClass S R\ns : S\n⊢ Eq (⇑(SubringClass.subtype s)) Subtype.val","decl":"@[simp]\ntheorem coeSubtype : (subtype s : s → R) = ((↑) : s → R) :=\n  rfl\n\n"}
{"name":"SubringClass.coe_natCast","module":"Mathlib.Algebra.Ring.Subring.Defs","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\ninst✝ : SetLike S R\nhSR : SubringClass S R\ns : S\nn : Nat\n⊢ Eq ↑↑n ↑n","decl":"@[simp, norm_cast]\ntheorem coe_natCast (n : ℕ) : ((n : s) : R) = n :=\n  map_natCast (subtype s) n\n\n"}
{"name":"SubringClass.coe_intCast","module":"Mathlib.Algebra.Ring.Subring.Defs","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\ninst✝ : SetLike S R\nhSR : SubringClass S R\ns : S\nn : Int\n⊢ Eq ↑↑n ↑n","decl":"@[simp, norm_cast]\ntheorem coe_intCast (n : ℤ) : ((n : s) : R) = n :=\n  map_intCast (subtype s) n\n\n"}
{"name":"Subring.mk.sizeOf_spec","module":"Mathlib.Algebra.Ring.Subring.Defs","initialProofState":"R : Type u\ninst✝¹ : Ring R\ninst✝ : SizeOf R\ntoSubsemiring : Subsemiring R\nneg_mem' : ∀ {x : R}, Membership.mem toSubsemiring.carrier x → Membership.mem toSubsemiring.carrier (Neg.neg x)\n⊢ Eq (SizeOf.sizeOf { toSubsemiring := toSubsemiring, neg_mem' := neg_mem' }) (HAdd.hAdd 1 (SizeOf.sizeOf toSubsemiring))","decl":"/-- `Subring R` is the type of subrings of `R`. A subring of `R` is a subset `s` that is a\n  multiplicative submonoid and an additive subgroup. Note in particular that it shares the\n  same 0 and 1 as R. -/\nstructure Subring (R : Type u) [Ring R] extends Subsemiring R, AddSubgroup R\n\n"}
{"name":"Subring.neg_mem'","module":"Mathlib.Algebra.Ring.Subring.Defs","initialProofState":"R : Type u\ninst✝ : Ring R\nself : Subring R\nx : R\na✝ : Membership.mem self.carrier x\n⊢ Membership.mem self.carrier (Neg.neg x)","decl":"/-- `Subring R` is the type of subrings of `R`. A subring of `R` is a subset `s` that is a\n  multiplicative submonoid and an additive subgroup. Note in particular that it shares the\n  same 0 and 1 as R. -/\nstructure Subring (R : Type u) [Ring R] extends Subsemiring R, AddSubgroup R\n\n"}
{"name":"Subring.mk.inj","module":"Mathlib.Algebra.Ring.Subring.Defs","initialProofState":"R : Type u\ninst✝ : Ring R\ntoSubsemiring✝ : Subsemiring R\nneg_mem'✝ : ∀ {x : R}, Membership.mem toSubsemiring✝.carrier x → Membership.mem toSubsemiring✝.carrier (Neg.neg x)\ntoSubsemiring : Subsemiring R\nneg_mem' : ∀ {x : R}, Membership.mem toSubsemiring.carrier x → Membership.mem toSubsemiring.carrier (Neg.neg x)\nx✝ : Eq { toSubsemiring := toSubsemiring✝, neg_mem' := neg_mem'✝ } { toSubsemiring := toSubsemiring, neg_mem' := neg_mem' }\n⊢ Eq toSubsemiring✝ toSubsemiring","decl":"/-- `Subring R` is the type of subrings of `R`. A subring of `R` is a subset `s` that is a\n  multiplicative submonoid and an additive subgroup. Note in particular that it shares the\n  same 0 and 1 as R. -/\nstructure Subring (R : Type u) [Ring R] extends Subsemiring R, AddSubgroup R\n\n"}
{"name":"Subring.mk.injEq","module":"Mathlib.Algebra.Ring.Subring.Defs","initialProofState":"R : Type u\ninst✝ : Ring R\ntoSubsemiring✝ : Subsemiring R\nneg_mem'✝ : ∀ {x : R}, Membership.mem toSubsemiring✝.carrier x → Membership.mem toSubsemiring✝.carrier (Neg.neg x)\ntoSubsemiring : Subsemiring R\nneg_mem' : ∀ {x : R}, Membership.mem toSubsemiring.carrier x → Membership.mem toSubsemiring.carrier (Neg.neg x)\n⊢ Eq (Eq { toSubsemiring := toSubsemiring✝, neg_mem' := neg_mem'✝ } { toSubsemiring := toSubsemiring, neg_mem' := neg_mem' }) (Eq toSubsemiring✝ toSubsemiring)","decl":"/-- `Subring R` is the type of subrings of `R`. A subring of `R` is a subset `s` that is a\n  multiplicative submonoid and an additive subgroup. Note in particular that it shares the\n  same 0 and 1 as R. -/\nstructure Subring (R : Type u) [Ring R] extends Subsemiring R, AddSubgroup R\n\n"}
{"name":"Subring.instSubringClass","module":"Mathlib.Algebra.Ring.Subring.Defs","initialProofState":"R : Type u\ninst✝ : Ring R\n⊢ SubringClass (Subring R) R","decl":"instance : SubringClass (Subring R) R where\n  zero_mem s := s.zero_mem'\n  add_mem {s} := s.add_mem'\n  one_mem s := s.one_mem'\n  mul_mem {s} := s.mul_mem'\n  neg_mem {s} := s.neg_mem'\n\n"}
{"name":"Subring.mem_toSubsemiring","module":"Mathlib.Algebra.Ring.Subring.Defs","initialProofState":"R : Type u\ninst✝ : Ring R\ns : Subring R\nx : R\n⊢ Iff (Membership.mem s.toSubsemiring x) (Membership.mem s x)","decl":"@[simp]\ntheorem mem_toSubsemiring {s : Subring R} {x : R} : x ∈ s.toSubsemiring ↔ x ∈ s := Iff.rfl\n\n"}
{"name":"Subring.mem_carrier","module":"Mathlib.Algebra.Ring.Subring.Defs","initialProofState":"R : Type u\ninst✝ : Ring R\ns : Subring R\nx : R\n⊢ Iff (Membership.mem s.carrier x) (Membership.mem s x)","decl":"theorem mem_carrier {s : Subring R} {x : R} : x ∈ s.carrier ↔ x ∈ s :=\n  Iff.rfl\n\n"}
{"name":"Subring.mem_mk","module":"Mathlib.Algebra.Ring.Subring.Defs","initialProofState":"R : Type u\ninst✝ : Ring R\nS : Subsemiring R\nx : R\nh : ∀ {x : R}, Membership.mem S.carrier x → Membership.mem S.carrier (Neg.neg x)\n⊢ Iff (Membership.mem { toSubsemiring := S, neg_mem' := h } x) (Membership.mem S x)","decl":"@[simp]\ntheorem mem_mk {S : Subsemiring R} {x : R} (h) : x ∈ (⟨S, h⟩ : Subring R) ↔ x ∈ S := Iff.rfl\n\n"}
{"name":"Subring.coe_set_mk","module":"Mathlib.Algebra.Ring.Subring.Defs","initialProofState":"R : Type u\ninst✝ : Ring R\nS : Subsemiring R\nh : ∀ {x : R}, Membership.mem S.carrier x → Membership.mem S.carrier (Neg.neg x)\n⊢ Eq ↑{ toSubsemiring := S, neg_mem' := h } ↑S","decl":"@[simp] theorem coe_set_mk (S : Subsemiring R) (h) : ((⟨S, h⟩ : Subring R) : Set R) = S := rfl\n\n"}
{"name":"Subring.mk_le_mk","module":"Mathlib.Algebra.Ring.Subring.Defs","initialProofState":"R : Type u\ninst✝ : Ring R\nS S' : Subsemiring R\nh₁ : ∀ {x : R}, Membership.mem S.carrier x → Membership.mem S.carrier (Neg.neg x)\nh₂ : ∀ {x : R}, Membership.mem S'.carrier x → Membership.mem S'.carrier (Neg.neg x)\n⊢ Iff (LE.le { toSubsemiring := S, neg_mem' := h₁ } { toSubsemiring := S', neg_mem' := h₂ }) (LE.le S S')","decl":"@[simp]\ntheorem mk_le_mk {S S' : Subsemiring R} (h₁ h₂) :\n    (⟨S, h₁⟩ : Subring R) ≤ (⟨S', h₂⟩ : Subring R) ↔ S ≤ S' :=\n  Iff.rfl\n\n"}
{"name":"Subring.one_mem_toNonUnitalSubring","module":"Mathlib.Algebra.Ring.Subring.Defs","initialProofState":"R : Type u\ninst✝ : Ring R\nS : Subring R\n⊢ Membership.mem S.toNonUnitalSubring 1","decl":"lemma one_mem_toNonUnitalSubring (S : Subring R) : 1 ∈ S.toNonUnitalSubring := S.one_mem\n\n"}
{"name":"Subring.ext","module":"Mathlib.Algebra.Ring.Subring.Defs","initialProofState":"R : Type u\ninst✝ : Ring R\nS T : Subring R\nh : ∀ (x : R), Iff (Membership.mem S x) (Membership.mem T x)\n⊢ Eq S T","decl":"/-- Two subrings are equal if they have the same elements. -/\n@[ext]\ntheorem ext {S T : Subring R} (h : ∀ x, x ∈ S ↔ x ∈ T) : S = T :=\n  SetLike.ext h\n\n"}
{"name":"Subring.ext_iff","module":"Mathlib.Algebra.Ring.Subring.Defs","initialProofState":"R : Type u\ninst✝ : Ring R\nS T : Subring R\n⊢ Iff (Eq S T) (∀ (x : R), Iff (Membership.mem S x) (Membership.mem T x))","decl":"/-- Two subrings are equal if they have the same elements. -/\n@[ext]\ntheorem ext {S T : Subring R} (h : ∀ x, x ∈ S ↔ x ∈ T) : S = T :=\n  SetLike.ext h\n\n"}
{"name":"Subring.coe_copy","module":"Mathlib.Algebra.Ring.Subring.Defs","initialProofState":"R : Type u\ninst✝ : Ring R\nS : Subring R\ns : Set R\nhs : Eq s ↑S\n⊢ Eq (↑(S.copy s hs)) s","decl":"/-- Copy of a subring with a new `carrier` equal to the old one. Useful to fix definitional\nequalities. -/\n@[simps coe toSubsemiring]\nprotected def copy (S : Subring R) (s : Set R) (hs : s = ↑S) : Subring R :=\n  { S.toSubsemiring.copy s hs with\n    carrier := s\n    neg_mem' := hs.symm ▸ S.neg_mem' }\n\n"}
{"name":"Subring.copy_toSubsemiring","module":"Mathlib.Algebra.Ring.Subring.Defs","initialProofState":"R : Type u\ninst✝ : Ring R\nS : Subring R\ns : Set R\nhs : Eq s ↑S\n⊢ Eq (S.copy s hs).toSubsemiring { carrier := s, mul_mem' := ⋯, one_mem' := ⋯, add_mem' := ⋯, zero_mem' := ⋯ }","decl":"/-- Copy of a subring with a new `carrier` equal to the old one. Useful to fix definitional\nequalities. -/\n@[simps coe toSubsemiring]\nprotected def copy (S : Subring R) (s : Set R) (hs : s = ↑S) : Subring R :=\n  { S.toSubsemiring.copy s hs with\n    carrier := s\n    neg_mem' := hs.symm ▸ S.neg_mem' }\n\n"}
{"name":"Subring.copy_eq","module":"Mathlib.Algebra.Ring.Subring.Defs","initialProofState":"R : Type u\ninst✝ : Ring R\nS : Subring R\ns : Set R\nhs : Eq s ↑S\n⊢ Eq (S.copy s hs) S","decl":"theorem copy_eq (S : Subring R) (s : Set R) (hs : s = ↑S) : S.copy s hs = S :=\n  SetLike.coe_injective hs\n\n"}
{"name":"Subring.toSubsemiring_injective","module":"Mathlib.Algebra.Ring.Subring.Defs","initialProofState":"R : Type u\ninst✝ : Ring R\n⊢ Function.Injective Subring.toSubsemiring","decl":"theorem toSubsemiring_injective : Function.Injective (toSubsemiring : Subring R → Subsemiring R)\n  | _, _, h => ext (SetLike.ext_iff.mp h :)\n\n"}
{"name":"Subring.toAddSubgroup_injective","module":"Mathlib.Algebra.Ring.Subring.Defs","initialProofState":"R : Type u\ninst✝ : Ring R\n⊢ Function.Injective Subring.toAddSubgroup","decl":"theorem toAddSubgroup_injective : Function.Injective (toAddSubgroup : Subring R → AddSubgroup R)\n  | _, _, h => ext (SetLike.ext_iff.mp h :)\n\n"}
{"name":"Subring.toSubmonoid_injective","module":"Mathlib.Algebra.Ring.Subring.Defs","initialProofState":"R : Type u\ninst✝ : Ring R\n⊢ Function.Injective fun s => s.toSubmonoid","decl":"theorem toSubmonoid_injective : Function.Injective (fun s : Subring R => s.toSubmonoid)\n  | _, _, h => ext (SetLike.ext_iff.mp h :)\n\n"}
{"name":"Subring.coe_mk'","module":"Mathlib.Algebra.Ring.Subring.Defs","initialProofState":"R : Type u\ninst✝ : Ring R\ns : Set R\nsm : Submonoid R\nsa : AddSubgroup R\nhm : Eq (↑sm) s\nha : Eq (↑sa) s\n⊢ Eq (↑(Subring.mk' s sm sa hm ha)) s","decl":"/-- Construct a `Subring R` from a set `s`, a submonoid `sm`, and an additive\nsubgroup `sa` such that `x ∈ s ↔ x ∈ sm ↔ x ∈ sa`. -/\n@[simps! coe]\nprotected def mk' (s : Set R) (sm : Submonoid R) (sa : AddSubgroup R) (hm : ↑sm = s)\n    (ha : ↑sa = s) : Subring R :=\n  { sm.copy s hm.symm, sa.copy s ha.symm with }\n\n"}
{"name":"Subring.mem_mk'","module":"Mathlib.Algebra.Ring.Subring.Defs","initialProofState":"R : Type u\ninst✝ : Ring R\ns : Set R\nsm : Submonoid R\nhm : Eq (↑sm) s\nsa : AddSubgroup R\nha : Eq (↑sa) s\nx : R\n⊢ Iff (Membership.mem (Subring.mk' s sm sa hm ha) x) (Membership.mem s x)","decl":"@[simp]\ntheorem mem_mk' {s : Set R} {sm : Submonoid R} (hm : ↑sm = s) {sa : AddSubgroup R} (ha : ↑sa = s)\n    {x : R} : x ∈ Subring.mk' s sm sa hm ha ↔ x ∈ s :=\n  Iff.rfl\n\n"}
{"name":"Subring.mk'_toSubmonoid","module":"Mathlib.Algebra.Ring.Subring.Defs","initialProofState":"R : Type u\ninst✝ : Ring R\ns : Set R\nsm : Submonoid R\nhm : Eq (↑sm) s\nsa : AddSubgroup R\nha : Eq (↑sa) s\n⊢ Eq (Subring.mk' s sm sa hm ha).toSubmonoid sm","decl":"@[simp]\ntheorem mk'_toSubmonoid {s : Set R} {sm : Submonoid R} (hm : ↑sm = s) {sa : AddSubgroup R}\n    (ha : ↑sa = s) : (Subring.mk' s sm sa hm ha).toSubmonoid = sm :=\n  SetLike.coe_injective hm.symm\n\n"}
{"name":"Subring.mk'_toAddSubgroup","module":"Mathlib.Algebra.Ring.Subring.Defs","initialProofState":"R : Type u\ninst✝ : Ring R\ns : Set R\nsm : Submonoid R\nhm : Eq (↑sm) s\nsa : AddSubgroup R\nha : Eq (↑sa) s\n⊢ Eq (Subring.mk' s sm sa hm ha).toAddSubgroup sa","decl":"@[simp]\ntheorem mk'_toAddSubgroup {s : Set R} {sm : Submonoid R} (hm : ↑sm = s) {sa : AddSubgroup R}\n    (ha : ↑sa = s) : (Subring.mk' s sm sa hm ha).toAddSubgroup = sa :=\n  SetLike.coe_injective ha.symm\n\n"}
{"name":"Subsemiring.toSubring_toSubsemiring","module":"Mathlib.Algebra.Ring.Subring.Defs","initialProofState":"R : Type u\ninst✝ : Ring R\ns : Subsemiring R\nhneg : Membership.mem s (-1)\n⊢ Eq (s.toSubring hneg).toSubsemiring s","decl":"/-- A `Subsemiring` containing -1 is a `Subring`. -/\n@[simps toSubsemiring]\ndef Subsemiring.toSubring (s : Subsemiring R) (hneg : (-1 : R) ∈ s) : Subring R where\n  toSubsemiring := s\n  neg_mem' h := by\n    rw [← neg_one_mul]\n    exact mul_mem hneg h\n\n"}
{"name":"Subring.one_mem","module":"Mathlib.Algebra.Ring.Subring.Defs","initialProofState":"R : Type u\ninst✝ : Ring R\ns : Subring R\n⊢ Membership.mem s 1","decl":"/-- A subring contains the ring's 1. -/\nprotected theorem one_mem : (1 : R) ∈ s :=\n  one_mem _\n\n"}
{"name":"Subring.zero_mem","module":"Mathlib.Algebra.Ring.Subring.Defs","initialProofState":"R : Type u\ninst✝ : Ring R\ns : Subring R\n⊢ Membership.mem s 0","decl":"/-- A subring contains the ring's 0. -/\nprotected theorem zero_mem : (0 : R) ∈ s :=\n  zero_mem _\n\n"}
{"name":"Subring.mul_mem","module":"Mathlib.Algebra.Ring.Subring.Defs","initialProofState":"R : Type u\ninst✝ : Ring R\ns : Subring R\nx y : R\na✝¹ : Membership.mem s x\na✝ : Membership.mem s y\n⊢ Membership.mem s (HMul.hMul x y)","decl":"/-- A subring is closed under multiplication. -/\nprotected theorem mul_mem {x y : R} : x ∈ s → y ∈ s → x * y ∈ s :=\n  mul_mem\n\n"}
{"name":"Subring.add_mem","module":"Mathlib.Algebra.Ring.Subring.Defs","initialProofState":"R : Type u\ninst✝ : Ring R\ns : Subring R\nx y : R\na✝¹ : Membership.mem s x\na✝ : Membership.mem s y\n⊢ Membership.mem s (HAdd.hAdd x y)","decl":"/-- A subring is closed under addition. -/\nprotected theorem add_mem {x y : R} : x ∈ s → y ∈ s → x + y ∈ s :=\n  add_mem\n\n"}
{"name":"Subring.neg_mem","module":"Mathlib.Algebra.Ring.Subring.Defs","initialProofState":"R : Type u\ninst✝ : Ring R\ns : Subring R\nx : R\na✝ : Membership.mem s x\n⊢ Membership.mem s (Neg.neg x)","decl":"/-- A subring is closed under negation. -/\nprotected theorem neg_mem {x : R} : x ∈ s → -x ∈ s :=\n  neg_mem\n\n"}
{"name":"Subring.sub_mem","module":"Mathlib.Algebra.Ring.Subring.Defs","initialProofState":"R : Type u\ninst✝ : Ring R\ns : Subring R\nx y : R\nhx : Membership.mem s x\nhy : Membership.mem s y\n⊢ Membership.mem s (HSub.hSub x y)","decl":"/-- A subring is closed under subtraction -/\nprotected theorem sub_mem {x y : R} (hx : x ∈ s) (hy : y ∈ s) : x - y ∈ s :=\n  sub_mem hx hy\n\n"}
{"name":"Subring.zsmul_mem","module":"Mathlib.Algebra.Ring.Subring.Defs","initialProofState":"R : Type u\ninst✝ : Ring R\ns : Subring R\nx : R\nhx : Membership.mem s x\nn : Int\n⊢ Membership.mem s (HSMul.hSMul n x)","decl":"protected theorem zsmul_mem {x : R} (hx : x ∈ s) (n : ℤ) : n • x ∈ s :=\n  zsmul_mem hx n\n\n"}
{"name":"Subring.pow_mem","module":"Mathlib.Algebra.Ring.Subring.Defs","initialProofState":"R : Type u\ninst✝ : Ring R\ns : Subring R\nx : R\nhx : Membership.mem s x\nn : Nat\n⊢ Membership.mem s (HPow.hPow x n)","decl":"protected theorem pow_mem {x : R} (hx : x ∈ s) (n : ℕ) : x ^ n ∈ s :=\n  pow_mem hx n\n\n"}
{"name":"Subring.coe_add","module":"Mathlib.Algebra.Ring.Subring.Defs","initialProofState":"R : Type u\ninst✝ : Ring R\ns : Subring R\nx y : Subtype fun x => Membership.mem s x\n⊢ Eq (↑(HAdd.hAdd x y)) (HAdd.hAdd ↑x ↑y)","decl":"@[simp, norm_cast]\ntheorem coe_add (x y : s) : (↑(x + y) : R) = ↑x + ↑y :=\n  rfl\n\n"}
{"name":"Subring.coe_neg","module":"Mathlib.Algebra.Ring.Subring.Defs","initialProofState":"R : Type u\ninst✝ : Ring R\ns : Subring R\nx : Subtype fun x => Membership.mem s x\n⊢ Eq (↑(Neg.neg x)) (Neg.neg ↑x)","decl":"@[simp, norm_cast]\ntheorem coe_neg (x : s) : (↑(-x) : R) = -↑x :=\n  rfl\n\n"}
{"name":"Subring.coe_mul","module":"Mathlib.Algebra.Ring.Subring.Defs","initialProofState":"R : Type u\ninst✝ : Ring R\ns : Subring R\nx y : Subtype fun x => Membership.mem s x\n⊢ Eq (↑(HMul.hMul x y)) (HMul.hMul ↑x ↑y)","decl":"@[simp, norm_cast]\ntheorem coe_mul (x y : s) : (↑(x * y) : R) = ↑x * ↑y :=\n  rfl\n\n"}
{"name":"Subring.coe_zero","module":"Mathlib.Algebra.Ring.Subring.Defs","initialProofState":"R : Type u\ninst✝ : Ring R\ns : Subring R\n⊢ Eq (↑0) 0","decl":"@[simp, norm_cast]\ntheorem coe_zero : ((0 : s) : R) = 0 :=\n  rfl\n\n"}
{"name":"Subring.coe_one","module":"Mathlib.Algebra.Ring.Subring.Defs","initialProofState":"R : Type u\ninst✝ : Ring R\ns : Subring R\n⊢ Eq (↑1) 1","decl":"@[simp, norm_cast]\ntheorem coe_one : ((1 : s) : R) = 1 :=\n  rfl\n\n"}
{"name":"Subring.coe_pow","module":"Mathlib.Algebra.Ring.Subring.Defs","initialProofState":"R : Type u\ninst✝ : Ring R\ns : Subring R\nx : Subtype fun x => Membership.mem s x\nn : Nat\n⊢ Eq (↑(HPow.hPow x n)) (HPow.hPow (↑x) n)","decl":"@[simp, norm_cast]\ntheorem coe_pow (x : s) (n : ℕ) : ↑(x ^ n) = (x : R) ^ n :=\n  SubmonoidClass.coe_pow x n\n\n"}
{"name":"Subring.coe_eq_zero_iff","module":"Mathlib.Algebra.Ring.Subring.Defs","initialProofState":"R : Type u\ninst✝ : Ring R\ns : Subring R\nx : Subtype fun x => Membership.mem s x\n⊢ Iff (Eq (↑x) 0) (Eq x 0)","decl":"theorem coe_eq_zero_iff {x : s} : (x : R) = 0 ↔ x = 0 :=\n  ⟨fun h => Subtype.ext (Trans.trans h s.coe_zero.symm), fun h => h.symm ▸ s.coe_zero⟩\n\n"}
{"name":"Subring.instNontrivialSubtypeMem","module":"Mathlib.Algebra.Ring.Subring.Defs","initialProofState":"R : Type u_1\ninst✝¹ : Ring R\ninst✝ : Nontrivial R\ns : Subring R\n⊢ Nontrivial (Subtype fun x => Membership.mem s x)","decl":"/-- A subring of a non-trivial ring is non-trivial. -/\ninstance {R} [Ring R] [Nontrivial R] (s : Subring R) : Nontrivial s :=\n  s.toSubsemiring.nontrivial\n\n"}
{"name":"Subring.instNoZeroDivisorsSubtypeMem","module":"Mathlib.Algebra.Ring.Subring.Defs","initialProofState":"R : Type u_1\ninst✝¹ : Ring R\ninst✝ : NoZeroDivisors R\ns : Subring R\n⊢ NoZeroDivisors (Subtype fun x => Membership.mem s x)","decl":"/-- A subring of a ring with no zero divisors has no zero divisors. -/\ninstance {R} [Ring R] [NoZeroDivisors R] (s : Subring R) : NoZeroDivisors s :=\n  s.toSubsemiring.noZeroDivisors\n\n"}
{"name":"Subring.instIsDomainSubtypeMem","module":"Mathlib.Algebra.Ring.Subring.Defs","initialProofState":"R : Type u_1\ninst✝¹ : Ring R\ninst✝ : IsDomain R\ns : Subring R\n⊢ IsDomain (Subtype fun x => Membership.mem s x)","decl":"/-- A subring of a domain is a domain. -/\ninstance {R} [Ring R] [IsDomain R] (s : Subring R) : IsDomain s :=\n  NoZeroDivisors.to_isDomain _\n\n"}
{"name":"Subring.coeSubtype","module":"Mathlib.Algebra.Ring.Subring.Defs","initialProofState":"R : Type u\ninst✝ : Ring R\ns : Subring R\n⊢ Eq (⇑s.subtype) Subtype.val","decl":"@[simp]\ntheorem coeSubtype : ⇑s.subtype = ((↑) : s → R) :=\n  rfl\n\n"}
{"name":"Subring.coe_natCast","module":"Mathlib.Algebra.Ring.Subring.Defs","initialProofState":"R : Type u\ninst✝ : Ring R\ns : Subring R\nn : Nat\n⊢ Eq ↑↑n ↑n","decl":"@[norm_cast]\ntheorem coe_natCast : ∀ n : ℕ, ((n : s) : R) = n :=\n  map_natCast s.subtype\n\n"}
{"name":"Subring.coe_intCast","module":"Mathlib.Algebra.Ring.Subring.Defs","initialProofState":"R : Type u\ninst✝ : Ring R\ns : Subring R\nn : Int\n⊢ Eq ↑↑n ↑n","decl":"@[norm_cast]\ntheorem coe_intCast : ∀ n : ℤ, ((n : s) : R) = n :=\n  map_intCast s.subtype\n\n"}
{"name":"Subring.coe_toSubsemiring","module":"Mathlib.Algebra.Ring.Subring.Defs","initialProofState":"R : Type u\ninst✝ : Ring R\ns : Subring R\n⊢ Eq ↑s.toSubsemiring ↑s","decl":"@[simp]\ntheorem coe_toSubsemiring (s : Subring R) : (s.toSubsemiring : Set R) = s :=\n  rfl\n\n-- Porting note: https://github.com/leanprover-community/mathlib4/issues/10675\n-- dsimp cannot prove this\n"}
{"name":"Subring.mem_toSubmonoid","module":"Mathlib.Algebra.Ring.Subring.Defs","initialProofState":"R : Type u\ninst✝ : Ring R\ns : Subring R\nx : R\n⊢ Iff (Membership.mem s.toSubmonoid x) (Membership.mem s x)","decl":"@[simp, nolint simpNF]\ntheorem mem_toSubmonoid {s : Subring R} {x : R} : x ∈ s.toSubmonoid ↔ x ∈ s :=\n  Iff.rfl\n\n"}
{"name":"Subring.coe_toSubmonoid","module":"Mathlib.Algebra.Ring.Subring.Defs","initialProofState":"R : Type u\ninst✝ : Ring R\ns : Subring R\n⊢ Eq ↑s.toSubmonoid ↑s","decl":"@[simp]\ntheorem coe_toSubmonoid (s : Subring R) : (s.toSubmonoid : Set R) = s :=\n  rfl\n\n-- Porting note: https://github.com/leanprover-community/mathlib4/issues/10675\n-- dsimp cannot prove this\n"}
{"name":"Subring.mem_toAddSubgroup","module":"Mathlib.Algebra.Ring.Subring.Defs","initialProofState":"R : Type u\ninst✝ : Ring R\ns : Subring R\nx : R\n⊢ Iff (Membership.mem s.toAddSubgroup x) (Membership.mem s x)","decl":"@[simp, nolint simpNF]\ntheorem mem_toAddSubgroup {s : Subring R} {x : R} : x ∈ s.toAddSubgroup ↔ x ∈ s :=\n  Iff.rfl\n\n"}
{"name":"Subring.coe_toAddSubgroup","module":"Mathlib.Algebra.Ring.Subring.Defs","initialProofState":"R : Type u\ninst✝ : Ring R\ns : Subring R\n⊢ Eq ↑s.toAddSubgroup ↑s","decl":"@[simp]\ntheorem coe_toAddSubgroup (s : Subring R) : (s.toAddSubgroup : Set R) = s :=\n  rfl\n\n"}
{"name":"Subring.toNonUnitalSubring_toSubring","module":"Mathlib.Algebra.Ring.Subring.Defs","initialProofState":"R : Type u\ninst✝ : Ring R\nS : Subring R\n⊢ Eq (S.toNonUnitalSubring.toSubring ⋯) S","decl":"lemma Subring.toNonUnitalSubring_toSubring (S : Subring R) :\n    S.toNonUnitalSubring.toSubring S.one_mem = S := by cases S; rfl\n\n"}
{"name":"NonUnitalSubring.toSubring_toNonUnitalSubring","module":"Mathlib.Algebra.Ring.Subring.Defs","initialProofState":"R : Type u\ninst✝ : Ring R\nS : NonUnitalSubring R\nh1 : Membership.mem S 1\n⊢ Eq (S.toSubring h1).toNonUnitalSubring S","decl":"lemma NonUnitalSubring.toSubring_toNonUnitalSubring (S : NonUnitalSubring R) (h1 : (1 : R) ∈ S) :\n    (NonUnitalSubring.toSubring S h1).toNonUnitalSubring = S := by cases S; rfl\n\n"}
{"name":"AddSubgroup.int_mul_mem","module":"Mathlib.Algebra.Ring.Subring.Defs","initialProofState":"R : Type u\ninst✝ : Ring R\nG : AddSubgroup R\nk : Int\ng : R\nh : Membership.mem G g\n⊢ Membership.mem G (HMul.hMul (↑k) g)","decl":"theorem AddSubgroup.int_mul_mem {G : AddSubgroup R} (k : ℤ) {g : R} (h : g ∈ G) :\n    (k : R) * g ∈ G := by\n  convert AddSubgroup.zsmul_mem G h k using 1\n  simp\n"}
