{"name":"Polynomial.instCharP","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Nat\nh : CharP R p\n⊢ CharP (Polynomial R) p","decl":"instance instCharP (p : ℕ) [h : CharP R p] : CharP R[X] p :=\n  let ⟨h⟩ := h\n  ⟨fun n => by rw [← map_natCast C, ← C_0, C_inj, h]⟩\n\n"}
{"name":"Polynomial.instExpChar","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Nat\nh : ExpChar R p\n⊢ ExpChar (Polynomial R) p","decl":"instance instExpChar (p : ℕ) [h : ExpChar R p] : ExpChar R[X] p := by\n  cases h; exacts [ExpChar.zero, ExpChar.prime ‹_›]\n\n"}
{"name":"Polynomial.mem_degreeLE","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nn : WithBot Nat\nf : Polynomial R\n⊢ Iff (Membership.mem (Polynomial.degreeLE R n) f) (LE.le f.degree n)","decl":"theorem mem_degreeLE {n : WithBot ℕ} {f : R[X]} : f ∈ degreeLE R n ↔ degree f ≤ n := by\n  simp only [degreeLE, Submodule.mem_iInf, degree_le_iff_coeff_zero, LinearMap.mem_ker]; rfl\n\n"}
{"name":"Polynomial.degreeLE_mono","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nm n : WithBot Nat\nH : LE.le m n\n⊢ LE.le (Polynomial.degreeLE R m) (Polynomial.degreeLE R n)","decl":"@[mono]\ntheorem degreeLE_mono {m n : WithBot ℕ} (H : m ≤ n) : degreeLE R m ≤ degreeLE R n := fun _ hf =>\n  mem_degreeLE.2 (le_trans (mem_degreeLE.1 hf) H)\n\n"}
{"name":"Polynomial.degreeLE_eq_span_X_pow","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝¹ : Semiring R\ninst✝ : DecidableEq R\nn : Nat\n⊢ Eq (Polynomial.degreeLE R ↑n) (Submodule.span R ↑(Finset.image (fun n => HPow.hPow Polynomial.X n) (Finset.range (HAdd.hAdd n 1))))","decl":"theorem degreeLE_eq_span_X_pow [DecidableEq R] {n : ℕ} :\n    degreeLE R n = Submodule.span R ↑((Finset.range (n + 1)).image fun n => (X : R[X]) ^ n) := by\n  apply le_antisymm\n  · intro p hp\n    replace hp := mem_degreeLE.1 hp\n    rw [← Polynomial.sum_monomial_eq p, Polynomial.sum]\n    refine Submodule.sum_mem _ fun k hk => ?_\n    have := WithBot.coe_le_coe.1 (Finset.sup_le_iff.1 hp k hk)\n    rw [← C_mul_X_pow_eq_monomial, C_mul']\n    refine\n      Submodule.smul_mem _ _\n        (Submodule.subset_span <|\n          Finset.mem_coe.2 <|\n            Finset.mem_image.2 ⟨_, Finset.mem_range.2 (Nat.lt_succ_of_le this), rfl⟩)\n  rw [Submodule.span_le, Finset.coe_image, Set.image_subset_iff]\n  intro k hk\n  apply mem_degreeLE.2\n  exact\n    (degree_X_pow_le _).trans (WithBot.coe_le_coe.2 <| Nat.le_of_lt_succ <| Finset.mem_range.1 hk)\n\n"}
{"name":"Polynomial.mem_degreeLT","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nn : Nat\nf : Polynomial R\n⊢ Iff (Membership.mem (Polynomial.degreeLT R n) f) (LT.lt f.degree ↑n)","decl":"theorem mem_degreeLT {n : ℕ} {f : R[X]} : f ∈ degreeLT R n ↔ degree f < n := by\n  rw [degreeLT, Submodule.mem_iInf]\n  conv_lhs => intro i; rw [Submodule.mem_iInf]\n  rw [degree, Finset.max_eq_sup_coe]\n  rw [Finset.sup_lt_iff ?_]\n  rotate_left\n  · apply WithBot.bot_lt_coe\n  conv_rhs =>\n    simp only [mem_support_iff]\n    intro b\n    rw [Nat.cast_withBot, WithBot.coe_lt_coe, lt_iff_not_le, Ne, not_imp_not]\n  rfl\n\n"}
{"name":"Polynomial.degreeLT_mono","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nm n : Nat\nH : LE.le m n\n⊢ LE.le (Polynomial.degreeLT R m) (Polynomial.degreeLT R n)","decl":"@[mono]\ntheorem degreeLT_mono {m n : ℕ} (H : m ≤ n) : degreeLT R m ≤ degreeLT R n := fun _ hf =>\n  mem_degreeLT.2 (lt_of_lt_of_le (mem_degreeLT.1 hf) <| WithBot.coe_le_coe.2 H)\n\n"}
{"name":"Polynomial.degreeLT_eq_span_X_pow","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝¹ : Semiring R\ninst✝ : DecidableEq R\nn : Nat\n⊢ Eq (Polynomial.degreeLT R n) (Submodule.span R ↑(Finset.image (fun n => HPow.hPow Polynomial.X n) (Finset.range n)))","decl":"theorem degreeLT_eq_span_X_pow [DecidableEq R] {n : ℕ} :\n    degreeLT R n = Submodule.span R ↑((Finset.range n).image fun n => X ^ n : Finset R[X]) := by\n  apply le_antisymm\n  · intro p hp\n    replace hp := mem_degreeLT.1 hp\n    rw [← Polynomial.sum_monomial_eq p, Polynomial.sum]\n    refine Submodule.sum_mem _ fun k hk => ?_\n    have := WithBot.coe_lt_coe.1 ((Finset.sup_lt_iff <| WithBot.bot_lt_coe n).1 hp k hk)\n    rw [← C_mul_X_pow_eq_monomial, C_mul']\n    refine\n      Submodule.smul_mem _ _\n        (Submodule.subset_span <|\n          Finset.mem_coe.2 <| Finset.mem_image.2 ⟨_, Finset.mem_range.2 this, rfl⟩)\n  rw [Submodule.span_le, Finset.coe_image, Set.image_subset_iff]\n  intro k hk\n  apply mem_degreeLT.2\n  exact lt_of_le_of_lt (degree_X_pow_le _) (WithBot.coe_lt_coe.2 <| Finset.mem_range.1 hk)\n\n"}
{"name":"Polynomial.degreeLTEquiv_eq_zero_iff_eq_zero","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nn : Nat\np : Polynomial R\nhp : Membership.mem (Polynomial.degreeLT R n) p\n⊢ Iff (Eq ((Polynomial.degreeLTEquiv R n) ⟨p, hp⟩) 0) (Eq p 0)","decl":"theorem degreeLTEquiv_eq_zero_iff_eq_zero {n : ℕ} {p : R[X]} (hp : p ∈ degreeLT R n) :\n    degreeLTEquiv _ _ ⟨p, hp⟩ = 0 ↔ p = 0 := by simp\n\n"}
{"name":"Polynomial.eval_eq_sum_degreeLTEquiv","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nn : Nat\np : Polynomial R\nhp : Membership.mem (Polynomial.degreeLT R n) p\nx : R\n⊢ Eq (Polynomial.eval x p) (Finset.univ.sum fun i => HMul.hMul ((Polynomial.degreeLTEquiv R n) ⟨p, hp⟩ i) (HPow.hPow x ↑i))","decl":"theorem eval_eq_sum_degreeLTEquiv {n : ℕ} {p : R[X]} (hp : p ∈ degreeLT R n) (x : R) :\n    p.eval x = ∑ i, degreeLTEquiv _ _ ⟨p, hp⟩ i * x ^ (i : ℕ) := by\n  simp_rw [eval_eq_sum]\n  exact (sum_fin _ (by simp_rw [zero_mul, forall_const]) (mem_degreeLT.mp hp)).symm\n\n"}
{"name":"Polynomial.degreeLT_succ_eq_degreeLE","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nn : Nat\n⊢ Eq (Polynomial.degreeLT R (HAdd.hAdd n 1)) (Polynomial.degreeLE R ↑n)","decl":"theorem degreeLT_succ_eq_degreeLE {n : ℕ} : degreeLT R (n + 1) = degreeLE R n := by\n  ext x\n  by_cases x_zero : x = 0\n  · simp_rw [x_zero, Submodule.zero_mem]\n  · rw [mem_degreeLT, mem_degreeLE, ← natDegree_lt_iff_degree_lt (by rwa [ne_eq]),\n      ← natDegree_le_iff_degree_le, Nat.lt_succ]\n\n"}
{"name":"Polynomial.exists_degree_le_of_mem_span","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\ns : Set (Polynomial R)\np : Polynomial R\nhs : s.Nonempty\nhp : Membership.mem (Submodule.span R s) p\n⊢ Exists fun p' => And (Membership.mem s p') (LE.le p.degree p'.degree)","decl":"/-- For every polynomial `p` in the span of a set `s : Set R[X]`, there exists a polynomial of\n  `p' ∈ s` with higher degree. See also `Polynomial.exists_degree_le_of_mem_span_of_finite`. -/\ntheorem exists_degree_le_of_mem_span {s : Set R[X]} {p : R[X]}\n    (hs : s.Nonempty) (hp : p ∈ Submodule.span R s) :\n    ∃ p' ∈ s, degree p ≤ degree p' := by\n  by_contra! h\n  by_cases hp_zero : p = 0\n  · rw [hp_zero, degree_zero] at h\n    rcases hs with ⟨x, hx⟩\n    exact not_lt_bot (h x hx)\n  · have : p ∈ degreeLT R (natDegree p) := by\n      refine (Submodule.span_le.mpr fun p' p'_mem => ?_) hp\n      rw [SetLike.mem_coe, mem_degreeLT, Nat.cast_withBot]\n      exact lt_of_lt_of_le (h p' p'_mem) degree_le_natDegree\n    rwa [mem_degreeLT, Nat.cast_withBot, degree_eq_natDegree hp_zero,\n      Nat.cast_withBot, lt_self_iff_false] at this\n\n"}
{"name":"Polynomial.exists_degree_le_of_mem_span_of_finite","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\ns : Set (Polynomial R)\ns_fin : s.Finite\nhs : s.Nonempty\n⊢ Exists fun p' => And (Membership.mem s p') (∀ (p : Polynomial R), Membership.mem (Submodule.span R s) p → LE.le p.degree p'.degree)","decl":"/-- A stronger version of `Polynomial.exists_degree_le_of_mem_span` under the assumption that the\n  set `s : R[X]` is finite. There exists a polynomial `p' ∈ s` whose degree dominates the degree of\n  every element of `p ∈ span R s`-/\ntheorem exists_degree_le_of_mem_span_of_finite {s : Set R[X]} (s_fin : s.Finite) (hs : s.Nonempty) :\n    ∃ p' ∈ s, ∀ (p : R[X]), p ∈ Submodule.span R s → degree p ≤ degree p' := by\n  rcases Set.Finite.exists_maximal_wrt degree s s_fin hs with ⟨a, has, hmax⟩\n  refine ⟨a, has, fun p hp => ?_⟩\n  rcases exists_degree_le_of_mem_span hs hp with ⟨p', hp'⟩\n  by_cases h : degree a ≤ degree p'\n  · rw [← hmax p' hp'.left h] at hp'; exact hp'.right\n  · exact le_trans hp'.right (not_le.mp h).le\n\n"}
{"name":"Polynomial.span_le_degreeLE_of_finite","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\ns : Set (Polynomial R)\ns_fin : s.Finite\n⊢ Exists fun n => LE.le (Submodule.span R s) (Polynomial.degreeLE R ↑n)","decl":"/-- The span of every finite set of polynomials is contained in a `degreeLE n` for some `n`. -/\ntheorem span_le_degreeLE_of_finite {s : Set R[X]} (s_fin : s.Finite) :\n    ∃ n : ℕ, Submodule.span R s ≤ degreeLE R n := by\n  by_cases s_emp : s.Nonempty\n  · rcases exists_degree_le_of_mem_span_of_finite s_fin s_emp with ⟨p', _, hp'max⟩\n    exact ⟨natDegree p', fun p hp => mem_degreeLE.mpr ((hp'max _ hp).trans degree_le_natDegree)⟩\n  · rw [Set.not_nonempty_iff_eq_empty] at s_emp\n    rw [s_emp, Submodule.span_empty]\n    exact ⟨0, bot_le⟩\n\n"}
{"name":"Polynomial.span_of_finite_le_degreeLT","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\ns : Set (Polynomial R)\ns_fin : s.Finite\n⊢ Exists fun n => LE.le (Submodule.span R s) (Polynomial.degreeLT R n)","decl":"/-- The span of every finite set of polynomials is contained in a `degreeLT n` for some `n`. -/\ntheorem span_of_finite_le_degreeLT {s : Set R[X]} (s_fin : s.Finite) :\n    ∃ n : ℕ, Submodule.span R s ≤ degreeLT R n := by\n  rcases span_le_degreeLE_of_finite s_fin with ⟨n, _⟩\n  exact ⟨n + 1, by rwa [degreeLT_succ_eq_degreeLE]⟩\n\n"}
{"name":"Polynomial.not_finite","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝¹ : Semiring R\ninst✝ : Nontrivial R\n⊢ Not (Module.Finite R (Polynomial R))","decl":"/-- If `R` is a nontrivial ring, the polynomials `R[X]` are not finite as an `R`-module. When `R` is\na field, this is equivalent to `R[X]` being an infinite-dimensional vector space over `R`. -/\ntheorem not_finite [Nontrivial R] : ¬ Module.Finite R R[X] := by\n  rw [Module.finite_def, Submodule.fg_def]\n  push_neg\n  intro s hs contra\n  rcases span_le_degreeLE_of_finite hs with ⟨n,hn⟩\n  have : ((X : R[X]) ^ (n + 1)) ∈ Polynomial.degreeLE R ↑n := by\n    rw [contra] at hn\n    exact hn Submodule.mem_top\n  rw [mem_degreeLE, degree_X_pow, Nat.cast_le, add_le_iff_nonpos_right, nonpos_iff_eq_zero] at this\n  exact one_ne_zero this\n\n"}
{"name":"Polynomial.coeffs_zero","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\n⊢ Eq (Polynomial.coeffs 0) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem coeffs_zero : coeffs (0 : R[X]) = ∅ :=\n  rfl\n\n"}
{"name":"Polynomial.mem_coeffs_iff","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nc : R\n⊢ Iff (Membership.mem p.coeffs c) (Exists fun n => And (Membership.mem p.support n) (Eq c (p.coeff n)))","decl":"theorem mem_coeffs_iff {p : R[X]} {c : R} : c ∈ p.coeffs ↔ ∃ n ∈ p.support, c = p.coeff n := by\n  simp [coeffs, eq_comm, (Finset.mem_image)]\n\n"}
{"name":"Polynomial.coeffs_one","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\n⊢ HasSubset.Subset (Polynomial.coeffs 1) (Singleton.singleton 1)","decl":"theorem coeffs_one : coeffs (1 : R[X]) ⊆ {1} := by\n  classical\n    simp_rw [coeffs, Finset.image_subset_iff]\n    simp_all [coeff_one]\n\n"}
{"name":"Polynomial.coeff_mem_coeffs","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nn : Nat\nh : Ne (p.coeff n) 0\n⊢ Membership.mem p.coeffs (p.coeff n)","decl":"theorem coeff_mem_coeffs (p : R[X]) (n : ℕ) (h : p.coeff n ≠ 0) : p.coeff n ∈ p.coeffs := by\n  classical\n  simp only [coeffs, exists_prop, mem_support_iff, Finset.mem_image, Ne]\n  exact ⟨n, h, rfl⟩\n\n"}
{"name":"Polynomial.coeffs_monomial","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nn : Nat\nc : R\nhc : Ne c 0\n⊢ Eq ((Polynomial.monomial n) c).coeffs (Singleton.singleton c)","decl":"theorem coeffs_monomial (n : ℕ) {c : R} (hc : c ≠ 0) : (monomial n c).coeffs = {c} := by\n  rw [coeffs, support_monomial n hc]\n  simp\n\n"}
{"name":"Polynomial.geom_sum_X_comp_X_add_one_eq_sum","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nn : Nat\n⊢ Eq (((Finset.range n).sum fun i => HPow.hPow Polynomial.X i).comp (HAdd.hAdd Polynomial.X 1)) ((Finset.range n).sum fun i => HMul.hMul (↑(n.choose (HAdd.hAdd i 1))) (HPow.hPow Polynomial.X i))","decl":"theorem geom_sum_X_comp_X_add_one_eq_sum (n : ℕ) :\n    (∑ i ∈ range n, (X : R[X]) ^ i).comp (X + 1) =\n      (Finset.range n).sum fun i : ℕ => (n.choose (i + 1) : R[X]) * X ^ i := by\n  ext i\n  trans (n.choose (i + 1) : R); swap\n  · simp only [finset_sum_coeff, ← C_eq_natCast, coeff_C_mul_X_pow]\n    rw [Finset.sum_eq_single i, if_pos rfl]\n    · simp +contextual only [@eq_comm _ i, if_false, eq_self_iff_true,\n        imp_true_iff]\n    · simp +contextual only [Nat.lt_add_one_iff, Nat.choose_eq_zero_of_lt,\n        Nat.cast_zero, Finset.mem_range, not_lt, eq_self_iff_true, if_true, imp_true_iff]\n  induction' n with n ih generalizing i\n  · dsimp; simp only [zero_comp, coeff_zero, Nat.cast_zero]\n  · simp only [geom_sum_succ', ih, add_comp, X_pow_comp, coeff_add, Nat.choose_succ_succ,\n    Nat.cast_add, coeff_X_add_one_pow]\n\n"}
{"name":"Polynomial.Monic.geom_sum","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nP : Polynomial R\nhP : P.Monic\nhdeg : LT.lt 0 P.natDegree\nn : Nat\nhn : Ne n 0\n⊢ ((Finset.range n).sum fun i => HPow.hPow P i).Monic","decl":"theorem Monic.geom_sum {P : R[X]} (hP : P.Monic) (hdeg : 0 < P.natDegree) {n : ℕ} (hn : n ≠ 0) :\n    (∑ i ∈ range n, P ^ i).Monic := by\n  nontriviality R\n  obtain ⟨n, rfl⟩ := Nat.exists_eq_succ_of_ne_zero hn\n  rw [geom_sum_succ']\n  refine (hP.pow _).add_of_left ?_\n  refine lt_of_le_of_lt (degree_sum_le _ _) ?_\n  rw [Finset.sup_lt_iff]\n  · simp only [Finset.mem_range, degree_eq_natDegree (hP.pow _).ne_zero]\n    simp only [Nat.cast_lt, hP.natDegree_pow]\n    intro k\n    exact nsmul_lt_nsmul_left hdeg\n  · rw [bot_lt_iff_ne_bot, Ne, degree_eq_bot]\n    exact (hP.pow _).ne_zero\n\n"}
{"name":"Polynomial.Monic.geom_sum'","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nP : Polynomial R\nhP : P.Monic\nhdeg : LT.lt 0 P.degree\nn : Nat\nhn : Ne n 0\n⊢ ((Finset.range n).sum fun i => HPow.hPow P i).Monic","decl":"theorem Monic.geom_sum' {P : R[X]} (hP : P.Monic) (hdeg : 0 < P.degree) {n : ℕ} (hn : n ≠ 0) :\n    (∑ i ∈ range n, P ^ i).Monic :=\n  hP.geom_sum (natDegree_pos_iff_degree_pos.2 hdeg) hn\n\n"}
{"name":"Polynomial.monic_geom_sum_X","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nn : Nat\nhn : Ne n 0\n⊢ ((Finset.range n).sum fun i => HPow.hPow Polynomial.X i).Monic","decl":"theorem monic_geom_sum_X {n : ℕ} (hn : n ≠ 0) : (∑ i ∈ range n, (X : R[X]) ^ i).Monic := by\n  nontriviality R\n  apply monic_X.geom_sum _ hn\n  simp only [natDegree_X, zero_lt_one]\n\n"}
{"name":"Polynomial.coeff_restriction","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\np : Polynomial R\nn : Nat\n⊢ Eq (↑(p.restriction.coeff n)) (p.coeff n)","decl":"@[simp]\ntheorem coeff_restriction {p : R[X]} {n : ℕ} : ↑(coeff (restriction p) n) = coeff p n := by\n  classical\n  simp only [restriction, coeff_monomial, finset_sum_coeff, mem_support_iff, Finset.sum_ite_eq',\n    Ne, ite_not]\n  split_ifs with h\n  · rw [h]\n    rfl\n  · rfl\n\n"}
{"name":"Polynomial.coeff_restriction'","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\np : Polynomial R\nn : Nat\n⊢ Eq (↑(p.restriction.coeff n)) (p.coeff n)","decl":"theorem coeff_restriction' {p : R[X]} {n : ℕ} : (coeff (restriction p) n).1 = coeff p n := by\n  simp\n\n"}
{"name":"Polynomial.support_restriction","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\np : Polynomial R\n⊢ Eq p.restriction.support p.support","decl":"@[simp]\ntheorem support_restriction (p : R[X]) : support (restriction p) = support p := by\n  ext i\n  simp only [mem_support_iff, not_iff_not, Ne]\n  conv_rhs => rw [← coeff_restriction]\n  exact ⟨fun H => by rw [H, ZeroMemClass.coe_zero], fun H => Subtype.coe_injective H⟩\n\n"}
{"name":"Polynomial.map_restriction","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : CommRing R\np : Polynomial R\n⊢ Eq (Polynomial.map (algebraMap (Subtype fun x => Membership.mem (Subring.closure ↑p.coeffs) x) R) p.restriction) p","decl":"@[simp]\ntheorem map_restriction {R : Type u} [CommRing R] (p : R[X]) :\n    p.restriction.map (algebraMap _ _) = p :=\n  ext fun n => by rw [coeff_map, Algebra.algebraMap_ofSubring_apply, coeff_restriction]\n\n"}
{"name":"Polynomial.degree_restriction","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\np : Polynomial R\n⊢ Eq p.restriction.degree p.degree","decl":"@[simp]\ntheorem degree_restriction {p : R[X]} : (restriction p).degree = p.degree := by simp [degree]\n\n"}
{"name":"Polynomial.natDegree_restriction","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\np : Polynomial R\n⊢ Eq p.restriction.natDegree p.natDegree","decl":"@[simp]\ntheorem natDegree_restriction {p : R[X]} : (restriction p).natDegree = p.natDegree := by\n  simp [natDegree]\n\n"}
{"name":"Polynomial.monic_restriction","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\np : Polynomial R\n⊢ Iff p.restriction.Monic p.Monic","decl":"@[simp]\ntheorem monic_restriction {p : R[X]} : Monic (restriction p) ↔ Monic p := by\n  simp only [Monic, leadingCoeff, natDegree_restriction]\n  rw [← @coeff_restriction _ _ p]\n  exact ⟨fun H => by rw [H, OneMemClass.coe_one], fun H => Subtype.coe_injective H⟩\n\n"}
{"name":"Polynomial.restriction_zero","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\n⊢ Eq (Polynomial.restriction 0) 0","decl":"@[simp]\ntheorem restriction_zero : restriction (0 : R[X]) = 0 := by\n  simp only [restriction, Finset.sum_empty, support_zero]\n\n"}
{"name":"Polynomial.restriction_one","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\n⊢ Eq (Polynomial.restriction 1) 1","decl":"@[simp]\ntheorem restriction_one : restriction (1 : R[X]) = 1 :=\n  ext fun i => Subtype.eq <| by rw [coeff_restriction', coeff_one, coeff_one]; split_ifs <;> rfl\n\n"}
{"name":"Polynomial.eval₂_restriction","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\nS : Type u_1\ninst✝¹ : Ring R\ninst✝ : Semiring S\nf : RingHom R S\nx : S\np : Polynomial R\n⊢ Eq (Polynomial.eval₂ f x p) (Polynomial.eval₂ (f.comp (Subring.closure ↑p.coeffs).subtype) x p.restriction)","decl":"theorem eval₂_restriction {p : R[X]} :\n    eval₂ f x p =\n      eval₂ (f.comp (Subring.subtype (Subring.closure (p.coeffs : Set R)))) x p.restriction := by\n  simp only [eval₂_eq_sum, sum, support_restriction, ← @coeff_restriction _ _ p, RingHom.comp_apply,\n    Subring.coeSubtype]\n\n"}
{"name":"Polynomial.coeff_toSubring","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\np : Polynomial R\nT : Subring R\nhp : HasSubset.Subset ↑p.coeffs ↑T\nn : Nat\n⊢ Eq (↑((p.toSubring T hp).coeff n)) (p.coeff n)","decl":"@[simp]\ntheorem coeff_toSubring {n : ℕ} : ↑(coeff (toSubring p T hp) n) = coeff p n := by\n  classical\n  simp only [toSubring, coeff_monomial, finset_sum_coeff, mem_support_iff, Finset.sum_ite_eq',\n    Ne, ite_not]\n  split_ifs with h\n  · rw [h]\n    rfl\n  · rfl\n\n"}
{"name":"Polynomial.coeff_toSubring'","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\np : Polynomial R\nT : Subring R\nhp : HasSubset.Subset ↑p.coeffs ↑T\nn : Nat\n⊢ Eq (↑((p.toSubring T hp).coeff n)) (p.coeff n)","decl":"theorem coeff_toSubring' {n : ℕ} : (coeff (toSubring p T hp) n).1 = coeff p n := by\n  simp\n\n"}
{"name":"Polynomial.support_toSubring","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\np : Polynomial R\nT : Subring R\nhp : HasSubset.Subset ↑p.coeffs ↑T\n⊢ Eq (p.toSubring T hp).support p.support","decl":"@[simp]\ntheorem support_toSubring : support (toSubring p T hp) = support p := by\n  ext i\n  simp only [mem_support_iff, not_iff_not, Ne]\n  conv_rhs => rw [← coeff_toSubring p T hp]\n  exact ⟨fun H => by rw [H, ZeroMemClass.coe_zero], fun H => Subtype.coe_injective H⟩\n\n"}
{"name":"Polynomial.degree_toSubring","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\np : Polynomial R\nT : Subring R\nhp : HasSubset.Subset ↑p.coeffs ↑T\n⊢ Eq (p.toSubring T hp).degree p.degree","decl":"@[simp]\ntheorem degree_toSubring : (toSubring p T hp).degree = p.degree := by simp [degree]\n\n"}
{"name":"Polynomial.natDegree_toSubring","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\np : Polynomial R\nT : Subring R\nhp : HasSubset.Subset ↑p.coeffs ↑T\n⊢ Eq (p.toSubring T hp).natDegree p.natDegree","decl":"@[simp]\ntheorem natDegree_toSubring : (toSubring p T hp).natDegree = p.natDegree := by simp [natDegree]\n\n"}
{"name":"Polynomial.monic_toSubring","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\np : Polynomial R\nT : Subring R\nhp : HasSubset.Subset ↑p.coeffs ↑T\n⊢ Iff (p.toSubring T hp).Monic p.Monic","decl":"@[simp]\ntheorem monic_toSubring : Monic (toSubring p T hp) ↔ Monic p := by\n  simp_rw [Monic, leadingCoeff, natDegree_toSubring, ← coeff_toSubring p T hp]\n  exact ⟨fun H => by rw [H, OneMemClass.coe_one], fun H => Subtype.coe_injective H⟩\n\n"}
{"name":"Polynomial.toSubring_zero","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\nT : Subring R\n⊢ Eq (Polynomial.toSubring 0 T ⋯) 0","decl":"@[simp]\ntheorem toSubring_zero : toSubring (0 : R[X]) T (by simp [coeffs]) = 0 := by\n  ext i\n  simp\n\n"}
{"name":"Polynomial.toSubring_one","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\nT : Subring R\n⊢ Eq (Polynomial.toSubring 1 T ⋯) 1","decl":"@[simp]\ntheorem toSubring_one :\n    toSubring (1 : R[X]) T\n        (Set.Subset.trans coeffs_one <| Finset.singleton_subset_set_iff.2 T.one_mem) =\n      1 :=\n  ext fun i => Subtype.eq <| by\n    rw [coeff_toSubring', coeff_one, coeff_one, apply_ite Subtype.val, ZeroMemClass.coe_zero,\n      OneMemClass.coe_one]\n\n"}
{"name":"Polynomial.map_toSubring","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\np : Polynomial R\nT : Subring R\nhp : HasSubset.Subset ↑p.coeffs ↑T\n⊢ Eq (Polynomial.map T.subtype (p.toSubring T hp)) p","decl":"@[simp]\ntheorem map_toSubring : (p.toSubring T hp).map (Subring.subtype T) = p := by\n  ext n\n  simp [coeff_map]\n\n"}
{"name":"Polynomial.coeff_ofSubring","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\nT : Subring R\np : Polynomial (Subtype fun x => Membership.mem T x)\nn : Nat\n⊢ Eq ((Polynomial.ofSubring T p).coeff n) ↑(p.coeff n)","decl":"theorem coeff_ofSubring (p : T[X]) (n : ℕ) : coeff (ofSubring T p) n = (coeff p n : T) := by\n  simp only [ofSubring, coeff_monomial, finset_sum_coeff, mem_support_iff, Finset.sum_ite_eq',\n    ite_eq_right_iff, Ne, ite_not, Classical.not_not, ite_eq_left_iff]\n  intro h\n  rw [h, ZeroMemClass.coe_zero]\n\n"}
{"name":"Polynomial.coeffs_ofSubring","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\nT : Subring R\np : Polynomial (Subtype fun x => Membership.mem T x)\n⊢ HasSubset.Subset ↑(Polynomial.ofSubring T p).coeffs ↑T","decl":"@[simp]\ntheorem coeffs_ofSubring {p : T[X]} : (↑(p.ofSubring T).coeffs : Set R) ⊆ T := by\n  classical\n  intro i hi\n  simp only [coeffs, Set.mem_image, mem_support_iff, Ne, Finset.mem_coe,\n    (Finset.coe_image)] at hi\n  rcases hi with ⟨n, _, h'n⟩\n  rw [← h'n, coeff_ofSubring]\n  exact Subtype.mem (coeff p n : T)\n\n"}
{"name":"Ideal.mem_ofPolynomial","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nI : Ideal (Polynomial R)\nx : Polynomial R\n⊢ Iff (Membership.mem I.ofPolynomial x) (Membership.mem I x)","decl":"theorem mem_ofPolynomial (x) : x ∈ I.ofPolynomial ↔ x ∈ I :=\n  Iff.rfl\n\n"}
{"name":"Ideal.polynomial_mem_ideal_of_coeff_mem_ideal","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI : Ideal (Polynomial R)\np : Polynomial R\nhp : ∀ (n : Nat), Membership.mem (Ideal.comap Polynomial.C I) (p.coeff n)\n⊢ Membership.mem I p","decl":"/-- If every coefficient of a polynomial is in an ideal `I`, then so is the polynomial itself -/\ntheorem polynomial_mem_ideal_of_coeff_mem_ideal (I : Ideal R[X]) (p : R[X])\n    (hp : ∀ n : ℕ, p.coeff n ∈ I.comap (C : R →+* R[X])) : p ∈ I :=\n  sum_C_mul_X_pow_eq p ▸ Submodule.sum_mem I fun n _ => I.mul_mem_right _ (hp n)\n\n"}
{"name":"Ideal.mem_map_C_iff","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI : Ideal R\nf : Polynomial R\n⊢ Iff (Membership.mem (Ideal.map Polynomial.C I) f) (∀ (n : Nat), Membership.mem I (f.coeff n))","decl":"/-- The push-forward of an ideal `I` of `R` to `R[X]` via inclusion\n is exactly the set of polynomials whose coefficients are in `I` -/\ntheorem mem_map_C_iff {I : Ideal R} {f : R[X]} :\n    f ∈ (Ideal.map (C : R →+* R[X]) I : Ideal R[X]) ↔ ∀ n : ℕ, f.coeff n ∈ I := by\n  constructor\n  · intro hf\n    refine Submodule.span_induction ?_ ?_ ?_ ?_ hf\n    · intro f hf n\n      cases' (Set.mem_image _ _ _).mp hf with x hx\n      rw [← hx.right, coeff_C]\n      by_cases h : n = 0\n      · simpa [h] using hx.left\n      · simp [h]\n    · simp\n    · exact fun f g _ _ hf hg n => by simp [I.add_mem (hf n) (hg n)]\n    · refine fun f g _ hg n => ?_\n      rw [smul_eq_mul, coeff_mul]\n      exact I.sum_mem fun c _ => I.mul_mem_left (f.coeff c.fst) (hg c.snd)\n  · intro hf\n    rw [← sum_monomial_eq f]\n    refine (I.map C : Ideal R[X]).sum_mem fun n _ => ?_\n    simp only [← C_mul_X_pow_eq_monomial, ne_eq]\n    rw [mul_comm]\n    exact (I.map C : Ideal R[X]).mul_mem_left _ (mem_map_of_mem _ (hf n))\n\n"}
{"name":"Polynomial.ker_mapRingHom","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\nS : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : Semiring S\nf : RingHom R S\n⊢ Eq (RingHom.ker (Polynomial.mapRingHom f)) (Ideal.map Polynomial.C (RingHom.ker f))","decl":"theorem _root_.Polynomial.ker_mapRingHom (f : R →+* S) :\n    RingHom.ker (Polynomial.mapRingHom f) = f.ker.map (C : R →+* R[X]) := by\n  ext\n  simp only [RingHom.mem_ker, coe_mapRingHom]\n  rw [mem_map_C_iff, Polynomial.ext_iff]\n  simp [RingHom.mem_ker]\n\n"}
{"name":"Ideal.mem_leadingCoeffNth","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI : Ideal (Polynomial R)\nn : Nat\nx : R\n⊢ Iff (Membership.mem (I.leadingCoeffNth n) x) (Exists fun p => And (Membership.mem I p) (And (LE.le p.degree ↑n) (Eq p.leadingCoeff x)))","decl":"theorem mem_leadingCoeffNth (n : ℕ) (x) :\n    x ∈ I.leadingCoeffNth n ↔ ∃ p ∈ I, degree p ≤ n ∧ p.leadingCoeff = x := by\n  simp only [leadingCoeffNth, degreeLE, Submodule.mem_map, lcoeff_apply, Submodule.mem_inf,\n    mem_degreeLE]\n  constructor\n  · rintro ⟨p, ⟨hpdeg, hpI⟩, rfl⟩\n    rcases lt_or_eq_of_le hpdeg with hpdeg | hpdeg\n    · refine ⟨0, I.zero_mem, bot_le, ?_⟩\n      rw [leadingCoeff_zero, eq_comm]\n      exact coeff_eq_zero_of_degree_lt hpdeg\n    · refine ⟨p, hpI, le_of_eq hpdeg, ?_⟩\n      rw [Polynomial.leadingCoeff, natDegree, hpdeg, Nat.cast_withBot, WithBot.unbot'_coe]\n  · rintro ⟨p, hpI, hpdeg, rfl⟩\n    have : natDegree p + (n - natDegree p) = n :=\n      add_tsub_cancel_of_le (natDegree_le_of_degree_le hpdeg)\n    refine ⟨p * X ^ (n - natDegree p), ⟨?_, I.mul_mem_right _ hpI⟩, ?_⟩\n    · apply le_trans (degree_mul_le _ _) _\n      apply le_trans (add_le_add degree_le_natDegree (degree_X_pow_le _)) _\n      rw [← Nat.cast_add, this]\n    · rw [Polynomial.leadingCoeff, ← coeff_mul_X_pow p (n - natDegree p), this]\n\n"}
{"name":"Ideal.mem_leadingCoeffNth_zero","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI : Ideal (Polynomial R)\nx : R\n⊢ Iff (Membership.mem (I.leadingCoeffNth 0) x) (Membership.mem I (Polynomial.C x))","decl":"theorem mem_leadingCoeffNth_zero (x) : x ∈ I.leadingCoeffNth 0 ↔ C x ∈ I :=\n  (mem_leadingCoeffNth _ _ _).trans\n    ⟨fun ⟨p, hpI, hpdeg, hpx⟩ => by\n      rwa [← hpx, Polynomial.leadingCoeff,\n        Nat.eq_zero_of_le_zero (natDegree_le_of_degree_le hpdeg), ← eq_C_of_degree_le_zero hpdeg],\n      fun hx => ⟨C x, hx, degree_C_le, leadingCoeff_C x⟩⟩\n\n"}
{"name":"Ideal.leadingCoeffNth_mono","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI : Ideal (Polynomial R)\nm n : Nat\nH : LE.le m n\n⊢ LE.le (I.leadingCoeffNth m) (I.leadingCoeffNth n)","decl":"theorem leadingCoeffNth_mono {m n : ℕ} (H : m ≤ n) : I.leadingCoeffNth m ≤ I.leadingCoeffNth n := by\n  intro r hr\n  simp only [SetLike.mem_coe, mem_leadingCoeffNth] at hr ⊢\n  rcases hr with ⟨p, hpI, hpdeg, rfl⟩\n  refine ⟨p * X ^ (n - m), I.mul_mem_right _ hpI, ?_, leadingCoeff_mul_X_pow⟩\n  refine le_trans (degree_mul_le _ _) ?_\n  refine le_trans (add_le_add hpdeg (degree_X_pow_le _)) ?_\n  rw [← Nat.cast_add, add_tsub_cancel_of_le H]\n\n"}
{"name":"Ideal.mem_leadingCoeff","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nI : Ideal (Polynomial R)\nx : R\n⊢ Iff (Membership.mem I.leadingCoeff x) (Exists fun p => And (Membership.mem I p) (Eq p.leadingCoeff x))","decl":"theorem mem_leadingCoeff (x) : x ∈ I.leadingCoeff ↔ ∃ p ∈ I, Polynomial.leadingCoeff p = x := by\n  rw [leadingCoeff, Submodule.mem_iSup_of_directed]\n  · simp only [mem_leadingCoeffNth]\n    constructor\n    · rintro ⟨i, p, hpI, _, rfl⟩\n      exact ⟨p, hpI, rfl⟩\n    rintro ⟨p, hpI, rfl⟩\n    exact ⟨natDegree p, p, hpI, degree_le_natDegree, rfl⟩\n  intro i j\n  exact\n    ⟨i + j, I.leadingCoeffNth_mono (Nat.le_add_right _ _),\n      I.leadingCoeffNth_mono (Nat.le_add_left _ _)⟩\n\n"}
{"name":"Polynomial.coeff_prod_mem_ideal_pow_tsub","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nι : Type u_2\ns : Finset ι\nf : ι → Polynomial R\nI : Ideal R\nn : ι → Nat\nh : ∀ (i : ι), Membership.mem s i → ∀ (k : Nat), Membership.mem (HPow.hPow I (HSub.hSub (n i) k)) ((f i).coeff k)\nk : Nat\n⊢ Membership.mem (HPow.hPow I (HSub.hSub (s.sum n) k)) ((s.prod f).coeff k)","decl":"/-- If `I` is an ideal, and `pᵢ` is a finite family of polynomials each satisfying\n`∀ k, (pᵢ)ₖ ∈ Iⁿⁱ⁻ᵏ` for some `nᵢ`, then `p = ∏ pᵢ` also satisfies `∀ k, pₖ ∈ Iⁿ⁻ᵏ` with `n = ∑ nᵢ`.\n-/\ntheorem _root_.Polynomial.coeff_prod_mem_ideal_pow_tsub {ι : Type*} (s : Finset ι) (f : ι → R[X])\n    (I : Ideal R) (n : ι → ℕ) (h : ∀ i ∈ s, ∀ (k), (f i).coeff k ∈ I ^ (n i - k)) (k : ℕ) :\n    (s.prod f).coeff k ∈ I ^ (s.sum n - k) := by\n  classical\n    induction' s using Finset.induction with a s ha hs generalizing k\n    · rw [sum_empty, prod_empty, coeff_one, zero_tsub, pow_zero, Ideal.one_eq_top]\n      exact Submodule.mem_top\n    · rw [sum_insert ha, prod_insert ha, coeff_mul]\n      apply sum_mem\n      rintro ⟨i, j⟩ e\n      obtain rfl : i + j = k := mem_antidiagonal.mp e\n      apply Ideal.pow_le_pow_right add_tsub_add_le_tsub_add_tsub\n      rw [pow_add]\n      exact\n        Ideal.mul_mem_mul (h _ (Finset.mem_insert.mpr <| Or.inl rfl) _)\n          (hs (fun i hi k => h _ (Finset.mem_insert.mpr <| Or.inr hi) _) j)\n\n"}
{"name":"Ideal.polynomial_not_isField","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\n⊢ Not (IsField (Polynomial R))","decl":"/-- `R[X]` is never a field for any ring `R`. -/\ntheorem polynomial_not_isField : ¬IsField R[X] := by\n  nontriviality R\n  intro hR\n  obtain ⟨p, hp⟩ := hR.mul_inv_cancel X_ne_zero\n  have hp0 : p ≠ 0 := right_ne_zero_of_mul_eq_one hp\n  have := degree_lt_degree_mul_X hp0\n  rw [← X_mul, congr_arg degree hp, degree_one, Nat.WithBot.lt_zero_iff, degree_eq_bot] at this\n  exact hp0 this\n\n"}
{"name":"Ideal.eq_zero_of_constant_mem_of_maximal","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\nhR : IsField R\nI : Ideal (Polynomial R)\nhI : I.IsMaximal\nx : R\nhx : Membership.mem I (Polynomial.C x)\n⊢ Eq x 0","decl":"/-- The only constant in a maximal ideal over a field is `0`. -/\ntheorem eq_zero_of_constant_mem_of_maximal (hR : IsField R) (I : Ideal R[X]) [hI : I.IsMaximal]\n    (x : R) (hx : C x ∈ I) : x = 0 := by\n  refine Classical.by_contradiction fun hx0 => hI.ne_top ((eq_top_iff_one I).2 ?_)\n  obtain ⟨y, hy⟩ := hR.mul_inv_cancel hx0\n  convert I.mul_mem_left (C y) hx\n  rw [← C.map_mul, hR.mul_comm y x, hy, RingHom.map_one]\n\n"}
{"name":"Ideal.isPrime_map_C_iff_isPrime","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : CommRing R\nP : Ideal R\n⊢ Iff (Ideal.map Polynomial.C P).IsPrime P.IsPrime","decl":"/-- If `P` is a prime ideal of `R`, then `P.R[x]` is a prime ideal of `R[x]`. -/\ntheorem isPrime_map_C_iff_isPrime (P : Ideal R) :\n    IsPrime (map (C : R →+* R[X]) P : Ideal R[X]) ↔ IsPrime P := by\n  -- Note: the following proof avoids quotient rings\n  -- It can be golfed substantially by using something like\n  -- `(Quotient.isDomain_iff_prime (map C P : Ideal R[X]))`\n  constructor\n  · intro H\n    have := comap_isPrime C (map C P)\n    convert this using 1\n    ext x\n    simp only [mem_comap, mem_map_C_iff]\n    constructor\n    · rintro h (- | n)\n      · rwa [coeff_C_zero]\n      · simp only [coeff_C_ne_zero (Nat.succ_ne_zero _), Submodule.zero_mem]\n    · intro h\n      simpa only [coeff_C_zero] using h 0\n  · intro h\n    constructor\n    · rw [Ne, eq_top_iff_one, mem_map_C_iff, not_forall]\n      use 0\n      rw [coeff_one_zero, ← eq_top_iff_one]\n      exact h.1\n    · intro f g\n      simp only [mem_map_C_iff]\n      contrapose!\n      rintro ⟨hf, hg⟩\n      classical\n        let m := Nat.find hf\n        let n := Nat.find hg\n        refine ⟨m + n, ?_⟩\n        rw [coeff_mul, ← Finset.insert_erase ((Finset.mem_antidiagonal (a := (m,n))).mpr rfl),\n          Finset.sum_insert (Finset.not_mem_erase _ _), (P.add_mem_iff_left _).not]\n        · apply mt h.2\n          rw [not_or]\n          exact ⟨Nat.find_spec hf, Nat.find_spec hg⟩\n        apply P.sum_mem\n        rintro ⟨i, j⟩ hij\n        rw [Finset.mem_erase, Finset.mem_antidiagonal] at hij\n        simp only [Ne, Prod.mk.inj_iff, not_and_or] at hij\n        obtain hi | hj : i < m ∨ j < n := by\n          omega\n        · rw [mul_comm]\n          apply P.mul_mem_left\n          exact Classical.not_not.1 (Nat.find_min hf hi)\n        · apply P.mul_mem_left\n          exact Classical.not_not.1 (Nat.find_min hg hj)\n\n"}
{"name":"Ideal.isPrime_map_C_of_isPrime","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : CommRing R\nP : Ideal R\nH : P.IsPrime\n⊢ (Ideal.map Polynomial.C P).IsPrime","decl":"/-- If `P` is a prime ideal of `R`, then `P.R[x]` is a prime ideal of `R[x]`. -/\ntheorem isPrime_map_C_of_isPrime {P : Ideal R} (H : IsPrime P) :\n    IsPrime (map (C : R →+* R[X]) P : Ideal R[X]) :=\n  (isPrime_map_C_iff_isPrime P).mpr H\n\n"}
{"name":"Ideal.is_fg_degreeLE","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsNoetherianRing R\nI : Ideal (Polynomial R)\nn : Nat\n⊢ (I.degreeLE ↑n).FG","decl":"theorem is_fg_degreeLE [IsNoetherianRing R] (I : Ideal R[X]) (n : ℕ) :\n    Submodule.FG (I.degreeLE n) :=\n  letI := Classical.decEq R\n  isNoetherian_submodule_left.1\n    (isNoetherian_of_fg_of_noetherian _ ⟨_, degreeLE_eq_span_X_pow.symm⟩) _\n\n"}
{"name":"span_le_of_C_coeff_mem","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nf : Polynomial R\nI : Ideal (Polynomial R)\ncf : ∀ (i : Nat), Membership.mem I (Polynomial.C (f.coeff i))\n⊢ LE.le (Ideal.span (setOf fun g => Exists fun i => Eq g (Polynomial.C (f.coeff i)))) I","decl":"/-- If the coefficients of a polynomial belong to an ideal, then that ideal contains\nthe ideal spanned by the coefficients of the polynomial. -/\ntheorem span_le_of_C_coeff_mem (cf : ∀ i : ℕ, C (f.coeff i) ∈ I) :\n    Ideal.span { g | ∃ i, g = C (f.coeff i) } ≤ I := by\n  simp only [@eq_comm _ _ (C _)]\n  exact (Ideal.span_le.trans range_subset_iff).mpr cf\n\n"}
{"name":"mem_span_C_coeff","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nf : Polynomial R\n⊢ Membership.mem (Ideal.span (setOf fun g => Exists fun i => Eq g (Polynomial.C (f.coeff i)))) f","decl":"theorem mem_span_C_coeff : f ∈ Ideal.span { g : R[X] | ∃ i : ℕ, g = C (coeff f i) } := by\n  let p := Ideal.span { g : R[X] | ∃ i : ℕ, g = C (coeff f i) }\n  nth_rw 2 [(sum_C_mul_X_pow_eq f).symm]\n  refine Submodule.sum_mem _ fun n _hn => ?_\n  dsimp\n  have : C (coeff f n) ∈ p := by\n    apply subset_span\n    rw [mem_setOf_eq]\n    use n\n  have : monomial n (1 : R) • C (coeff f n) ∈ p := p.smul_mem _ this\n  convert this using 1\n  simp only [monomial_mul_C, one_mul, smul_eq_mul]\n  rw [← C_mul_X_pow_eq_monomial]\n\n"}
{"name":"exists_C_coeff_not_mem","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nf : Polynomial R\nI : Ideal (Polynomial R)\na✝ : Not (Membership.mem I f)\n⊢ Exists fun i => Not (Membership.mem I (Polynomial.C (f.coeff i)))","decl":"theorem exists_C_coeff_not_mem : f ∉ I → ∃ i : ℕ, C (coeff f i) ∉ I :=\n  Not.imp_symm fun cf => span_le_of_C_coeff_mem (not_exists_not.mp cf) mem_span_C_coeff\n\n"}
{"name":"Polynomial.prime_C_iff","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : CommRing R\nr : R\n⊢ Iff (Prime (Polynomial.C r)) (Prime r)","decl":"theorem prime_C_iff : Prime (C r) ↔ Prime r :=\n  ⟨comap_prime C (evalRingHom (0 : R)) fun _ => eval_C, fun hr => by\n    have := hr.1\n    rw [← Ideal.span_singleton_prime] at hr ⊢\n    · rw [← Set.image_singleton, ← Ideal.map_span]\n      apply Ideal.isPrime_map_C_of_isPrime hr\n    · intro h; apply (this (C_eq_zero.mp h))\n    · assumption⟩\n\n"}
{"name":"MvPolynomial.prime_C_iff","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\nσ : Type v\ninst✝ : CommRing R\nr : R\n⊢ Iff (Prime (MvPolynomial.C r)) (Prime r)","decl":"theorem prime_C_iff : Prime (C r : MvPolynomial σ R) ↔ Prime r :=\n  ⟨comap_prime C constantCoeff (constantCoeff_C _), fun hr =>\n    ⟨fun h => hr.1 <| by\n        rw [← C_inj, h]\n        simp,\n      fun h =>\n      hr.2.1 <| by\n        rw [← constantCoeff_C _ r]\n        exact h.map _,\n      fun a b hd => by\n      obtain ⟨s, a', b', rfl, rfl⟩ := exists_finset_rename₂ a b\n      rw [← algebraMap_eq] at hd\n      have : algebraMap R _ r ∣ a' * b' := by\n        convert killCompl Subtype.coe_injective |>.toRingHom.map_dvd hd <;> simp\n      rw [← rename_C ((↑) : s → σ)]\n      let f := (rename (R := R) ((↑) : s → σ)).toRingHom\n      exact (((prime_C_iff_of_fintype s).2 hr).2.2 a' b' this).imp f.map_dvd f.map_dvd⟩⟩\n\n"}
{"name":"MvPolynomial.prime_rename_iff","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\nσ : Type v\ninst✝ : CommRing R\ns : Set σ\np : MvPolynomial (↑s) R\n⊢ Iff (Prime ((MvPolynomial.rename Subtype.val) p)) (Prime p)","decl":"theorem prime_rename_iff (s : Set σ) {p : MvPolynomial s R} :\n    Prime (rename ((↑) : s → σ) p) ↔ Prime (p : MvPolynomial s R) := by\n  classical\n    symm\n    let eqv :=\n      (sumAlgEquiv R (↥sᶜ) s).symm.trans\n        (renameEquiv R <| (Equiv.sumComm (↥sᶜ) s).trans <| Equiv.Set.sumCompl s)\n    have : (rename (↑)).toRingHom = eqv.toAlgHom.toRingHom.comp C := by\n      apply ringHom_ext\n      · intro\n        simp only [eqv, AlgHom.toRingHom_eq_coe, RingHom.coe_coe, rename_C,\n          AlgEquiv.toAlgHom_eq_coe, AlgEquiv.toAlgHom_toRingHom, RingHom.coe_comp,\n          AlgEquiv.coe_trans, Function.comp_apply, MvPolynomial.sumAlgEquiv_symm_apply,\n          iterToSum_C_C, renameEquiv_apply, Equiv.coe_trans, Equiv.sumComm_apply]\n      · intro\n        simp only [eqv, AlgHom.toRingHom_eq_coe, RingHom.coe_coe, rename_X,\n          AlgEquiv.toAlgHom_eq_coe, AlgEquiv.toAlgHom_toRingHom, RingHom.coe_comp,\n          AlgEquiv.coe_trans, Function.comp_apply, MvPolynomial.sumAlgEquiv_symm_apply,\n          iterToSum_C_X, renameEquiv_apply, Equiv.coe_trans, Equiv.sumComm_apply, Sum.swap_inr,\n          Equiv.Set.sumCompl_apply_inl]\n    apply_fun (· p) at this\n    simp only [AlgHom.toRingHom_eq_coe, RingHom.coe_coe, AlgEquiv.toAlgHom_eq_coe,\n      AlgEquiv.toAlgHom_toRingHom, RingHom.coe_comp, Function.comp_apply] at this\n    rw [this, MulEquiv.prime_iff, prime_C_iff]\n\n"}
{"name":"Polynomial.isNoetherianRing","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : CommRing R\ninst : IsNoetherianRing R\n⊢ IsNoetherianRing (Polynomial R)","decl":"/-- **Hilbert basis theorem**: a polynomial ring over a Noetherian ring is a Noetherian ring. -/\nprotected theorem Polynomial.isNoetherianRing [inst : IsNoetherianRing R] : IsNoetherianRing R[X] :=\n  isNoetherianRing_iff.2\n    ⟨fun I : Ideal R[X] =>\n      let M := inst.wf.min (Set.range I.leadingCoeffNth) ⟨_, ⟨0, rfl⟩⟩\n      have hm : M ∈ Set.range I.leadingCoeffNth := WellFounded.min_mem _ _ _\n      let ⟨N, HN⟩ := hm\n      let ⟨s, hs⟩ := I.is_fg_degreeLE N\n      have hm2 : ∀ k, I.leadingCoeffNth k ≤ M := fun k =>\n        Or.casesOn (le_or_lt k N) (fun h => HN ▸ I.leadingCoeffNth_mono h) fun h _ hx =>\n          Classical.by_contradiction fun hxm =>\n            haveI : IsNoetherian R R := inst\n            have : ¬M < I.leadingCoeffNth k := by\n              refine WellFounded.not_lt_min inst.wf _ _ ?_; exact ⟨k, rfl⟩\n            this ⟨HN ▸ I.leadingCoeffNth_mono (le_of_lt h), fun H => hxm (H hx)⟩\n      have hs2 : ∀ {x}, x ∈ I.degreeLE N → x ∈ Ideal.span (↑s : Set R[X]) :=\n        hs ▸ fun hx =>\n          Submodule.span_induction (hx := hx) (fun _ hx => Ideal.subset_span hx) (Ideal.zero_mem _)\n            (fun _ _ _ _ => Ideal.add_mem _) fun c f _ hf => f.C_mul' c ▸ Ideal.mul_mem_left _ _ hf\n      ⟨s, le_antisymm (Ideal.span_le.2 fun x hx =>\n          have : x ∈ I.degreeLE N := hs ▸ Submodule.subset_span hx\n          this.2) <| by\n        have : Submodule.span R[X] ↑s = Ideal.span ↑s := rfl\n        rw [this]\n        intro p hp\n        generalize hn : p.natDegree = k\n        induction' k using Nat.strong_induction_on with k ih generalizing p\n        rcases le_or_lt k N with h | h\n        · subst k\n          refine hs2 ⟨Polynomial.mem_degreeLE.2\n            (le_trans Polynomial.degree_le_natDegree <| WithBot.coe_le_coe.2 h), hp⟩\n        · have hp0 : p ≠ 0 := by\n            rintro rfl\n            cases hn\n            exact Nat.not_lt_zero _ h\n          have : (0 : R) ≠ 1 := by\n            intro h\n            apply hp0\n            ext i\n            refine (mul_one _).symm.trans ?_\n            rw [← h, mul_zero]\n            rfl\n          haveI : Nontrivial R := ⟨⟨0, 1, this⟩⟩\n          have : p.leadingCoeff ∈ I.leadingCoeffNth N := by\n            rw [HN]\n            exact hm2 k ((I.mem_leadingCoeffNth _ _).2\n              ⟨_, hp, hn ▸ Polynomial.degree_le_natDegree, rfl⟩)\n          rw [I.mem_leadingCoeffNth] at this\n          rcases this with ⟨q, hq, hdq, hlqp⟩\n          have hq0 : q ≠ 0 := by\n            intro H\n            rw [← Polynomial.leadingCoeff_eq_zero] at H\n            rw [hlqp, Polynomial.leadingCoeff_eq_zero] at H\n            exact hp0 H\n          have h1 : p.degree = (q * Polynomial.X ^ (k - q.natDegree)).degree := by\n            rw [Polynomial.degree_mul', Polynomial.degree_X_pow]\n            · rw [Polynomial.degree_eq_natDegree hp0, Polynomial.degree_eq_natDegree hq0]\n              rw [← Nat.cast_add, add_tsub_cancel_of_le, hn]\n              · refine le_trans (Polynomial.natDegree_le_of_degree_le hdq) (le_of_lt h)\n            rw [Polynomial.leadingCoeff_X_pow, mul_one]\n            exact mt Polynomial.leadingCoeff_eq_zero.1 hq0\n          have h2 : p.leadingCoeff = (q * Polynomial.X ^ (k - q.natDegree)).leadingCoeff := by\n            rw [← hlqp, Polynomial.leadingCoeff_mul_X_pow]\n          have := Polynomial.degree_sub_lt h1 hp0 h2\n          rw [Polynomial.degree_eq_natDegree hp0] at this\n          rw [← sub_add_cancel p (q * Polynomial.X ^ (k - q.natDegree))]\n          convert (Ideal.span ↑s).add_mem _ ((Ideal.span (s : Set R[X])).mul_mem_right _ _)\n          · by_cases hpq : p - q * Polynomial.X ^ (k - q.natDegree) = 0\n            · rw [hpq]\n              exact Ideal.zero_mem _\n            refine ih _ ?_ (I.sub_mem hp (I.mul_mem_right _ hq)) rfl\n            rwa [Polynomial.degree_eq_natDegree hpq, Nat.cast_lt, hn] at this\n          exact hs2 ⟨Polynomial.mem_degreeLE.2 hdq, hq⟩⟩⟩\n\n"}
{"name":"Polynomial.linearIndependent_powers_iff_aeval","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : LinearMap (RingHom.id R) M M\nv : M\n⊢ Iff (LinearIndependent R fun n => (HPow.hPow f n) v) (∀ (p : Polynomial R), Eq (((Polynomial.aeval f) p) v) 0 → Eq p 0)","decl":"theorem linearIndependent_powers_iff_aeval (f : M →ₗ[R] M) (v : M) :\n    (LinearIndependent R fun n : ℕ => (f ^ n) v) ↔ ∀ p : R[X], aeval f p v = 0 → p = 0 := by\n  rw [linearIndependent_iff]\n  simp only [Finsupp.linearCombination_apply, aeval_endomorphism, forall_iff_forall_finsupp, Sum,\n    support, coeff, ofFinsupp_eq_zero]\n  exact Iff.rfl\n\n"}
{"name":"Polynomial.disjoint_ker_aeval_of_isCoprime","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : LinearMap (RingHom.id R) M M\np q : Polynomial R\nhpq : IsCoprime p q\n⊢ Disjoint (LinearMap.ker ((Polynomial.aeval f) p)) (LinearMap.ker ((Polynomial.aeval f) q))","decl":"theorem disjoint_ker_aeval_of_isCoprime (f : M →ₗ[R] M) {p q : R[X]} (hpq : IsCoprime p q) :\n    Disjoint (LinearMap.ker (aeval f p)) (LinearMap.ker (aeval f q)) := by\n  rw [disjoint_iff_inf_le]\n  intro v hv\n  rcases hpq with ⟨p', q', hpq'⟩\n  simpa [LinearMap.mem_ker.1 (Submodule.mem_inf.1 hv).1,\n    LinearMap.mem_ker.1 (Submodule.mem_inf.1 hv).2] using\n    congr_arg (fun p : R[X] => aeval f p v) hpq'.symm\n\n"}
{"name":"Polynomial.disjoint_ker_aeval_of_coprime","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : LinearMap (RingHom.id R) M M\np q : Polynomial R\nhpq : IsCoprime p q\n⊢ Disjoint (LinearMap.ker ((Polynomial.aeval f) p)) (LinearMap.ker ((Polynomial.aeval f) q))","decl":"@[deprecated (since := \"2025-01-23\")]\nalias disjoint_ker_aeval_of_coprime := disjoint_ker_aeval_of_isCoprime\n\n"}
{"name":"Polynomial.sup_aeval_range_eq_top_of_isCoprime","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : LinearMap (RingHom.id R) M M\np q : Polynomial R\nhpq : IsCoprime p q\n⊢ Eq (Max.max (LinearMap.range ((Polynomial.aeval f) p)) (LinearMap.range ((Polynomial.aeval f) q))) Top.top","decl":"theorem sup_aeval_range_eq_top_of_isCoprime (f : M →ₗ[R] M) {p q : R[X]} (hpq : IsCoprime p q) :\n    LinearMap.range (aeval f p) ⊔ LinearMap.range (aeval f q) = ⊤ := by\n  rw [eq_top_iff]\n  intro v _\n  rw [Submodule.mem_sup]\n  rcases hpq with ⟨p', q', hpq'⟩\n  use aeval f (p * p') v\n  use LinearMap.mem_range.2 ⟨aeval f p' v, by simp only [LinearMap.mul_apply, aeval_mul]⟩\n  use aeval f (q * q') v\n  use LinearMap.mem_range.2 ⟨aeval f q' v, by simp only [LinearMap.mul_apply, aeval_mul]⟩\n  simpa only [mul_comm p p', mul_comm q q', aeval_one, aeval_add] using\n    congr_arg (fun p : R[X] => aeval f p v) hpq'\n\n"}
{"name":"Polynomial.sup_aeval_range_eq_top_of_coprime","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : LinearMap (RingHom.id R) M M\np q : Polynomial R\nhpq : IsCoprime p q\n⊢ Eq (Max.max (LinearMap.range ((Polynomial.aeval f) p)) (LinearMap.range ((Polynomial.aeval f) q))) Top.top","decl":"@[deprecated (since := \"2025-01-23\")]\nalias sup_aeval_range_eq_top_of_coprime := sup_aeval_range_eq_top_of_isCoprime\n\n"}
{"name":"Polynomial.sup_ker_aeval_le_ker_aeval_mul","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : LinearMap (RingHom.id R) M M\np q : Polynomial R\n⊢ LE.le (Max.max (LinearMap.ker ((Polynomial.aeval f) p)) (LinearMap.ker ((Polynomial.aeval f) q))) (LinearMap.ker ((Polynomial.aeval f) (HMul.hMul p q)))","decl":"theorem sup_ker_aeval_le_ker_aeval_mul {f : M →ₗ[R] M} {p q : R[X]} :\n    LinearMap.ker (aeval f p) ⊔ LinearMap.ker (aeval f q) ≤ LinearMap.ker (aeval f (p * q)) := by\n  intro v hv\n  rcases Submodule.mem_sup.1 hv with ⟨x, hx, y, hy, hxy⟩\n  have h_eval_x : aeval f (p * q) x = 0 := by\n    rw [mul_comm, aeval_mul, LinearMap.mul_apply, LinearMap.mem_ker.1 hx, LinearMap.map_zero]\n  have h_eval_y : aeval f (p * q) y = 0 := by\n    rw [aeval_mul, LinearMap.mul_apply, LinearMap.mem_ker.1 hy, LinearMap.map_zero]\n  rw [LinearMap.mem_ker, ← hxy, LinearMap.map_add, h_eval_x, h_eval_y, add_zero]\n\n"}
{"name":"Polynomial.sup_ker_aeval_eq_ker_aeval_mul_of_coprime","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : LinearMap (RingHom.id R) M M\np q : Polynomial R\nhpq : IsCoprime p q\n⊢ Eq (Max.max (LinearMap.ker ((Polynomial.aeval f) p)) (LinearMap.ker ((Polynomial.aeval f) q))) (LinearMap.ker ((Polynomial.aeval f) (HMul.hMul p q)))","decl":"theorem sup_ker_aeval_eq_ker_aeval_mul_of_coprime (f : M →ₗ[R] M) {p q : R[X]}\n    (hpq : IsCoprime p q) :\n    LinearMap.ker (aeval f p) ⊔ LinearMap.ker (aeval f q) = LinearMap.ker (aeval f (p * q)) := by\n  apply le_antisymm sup_ker_aeval_le_ker_aeval_mul\n  intro v hv\n  rw [Submodule.mem_sup]\n  rcases hpq with ⟨p', q', hpq'⟩\n  have h_eval₂_qpp' :=\n    calc\n      aeval f (q * (p * p')) v = aeval f (p' * (p * q)) v := by\n        rw [mul_comm, mul_assoc, mul_comm, mul_assoc, mul_comm q p]\n      _ = 0 := by rw [aeval_mul, LinearMap.mul_apply, LinearMap.mem_ker.1 hv, LinearMap.map_zero]\n\n  have h_eval₂_pqq' :=\n    calc\n      aeval f (p * (q * q')) v = aeval f (q' * (p * q)) v := by rw [← mul_assoc, mul_comm]\n      _ = 0 := by rw [aeval_mul, LinearMap.mul_apply, LinearMap.mem_ker.1 hv, LinearMap.map_zero]\n\n  rw [aeval_mul] at h_eval₂_qpp' h_eval₂_pqq'\n  refine\n    ⟨aeval f (q * q') v, LinearMap.mem_ker.1 h_eval₂_pqq', aeval f (p * p') v,\n      LinearMap.mem_ker.1 h_eval₂_qpp', ?_⟩\n  rw [add_comm, mul_comm p p', mul_comm q q']\n  simpa only [map_add, map_mul, aeval_one] using congr_arg (fun p : R[X] => aeval f p v) hpq'\n\n"}
{"name":"MvPolynomial.aeval_natDegree_le","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"σ : Type v\nR : Type u_2\ninst✝ : CommSemiring R\nm n : Nat\nF : MvPolynomial σ R\nhF : LE.le F.totalDegree m\nf : σ → Polynomial R\nhf : ∀ (i : σ), LE.le (f i).natDegree n\n⊢ LE.le ((MvPolynomial.aeval f) F).natDegree (HMul.hMul m n)","decl":"lemma aeval_natDegree_le {R : Type*} [CommSemiring R] {m n : ℕ}\n    (F : MvPolynomial σ R) (hF : F.totalDegree ≤ m)\n    (f : σ → Polynomial R) (hf : ∀ i, (f i).natDegree ≤ n) :\n    (MvPolynomial.aeval f F).natDegree ≤ m * n := by\n  rw [MvPolynomial.aeval_def, MvPolynomial.eval₂]\n  apply (Polynomial.natDegree_sum_le _ _).trans\n  apply Finset.sup_le\n  intro d hd\n  simp_rw [Function.comp_apply, ← C_eq_algebraMap]\n  apply (Polynomial.natDegree_C_mul_le _ _).trans\n  apply (Polynomial.natDegree_prod_le _ _).trans\n  have : ∑ i ∈ d.support, (d i) * n ≤ m * n := by\n    rw [← Finset.sum_mul]\n    apply mul_le_mul' (.trans _ hF) le_rfl\n    rw [MvPolynomial.totalDegree]\n    exact Finset.le_sup_of_le hd le_rfl\n  apply (Finset.sum_le_sum _).trans this\n  rintro i -\n  apply Polynomial.natDegree_pow_le.trans\n  exact mul_le_mul' le_rfl (hf i)\n\n"}
{"name":"MvPolynomial.isNoetherianRing_fin_0","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsNoetherianRing R\n⊢ IsNoetherianRing (MvPolynomial (Fin 0) R)","decl":"theorem isNoetherianRing_fin_0 [IsNoetherianRing R] :\n    IsNoetherianRing (MvPolynomial (Fin 0) R) := by\n  apply isNoetherianRing_of_ringEquiv R\n  symm; apply MvPolynomial.isEmptyRingEquiv R (Fin 0)\n\n"}
{"name":"MvPolynomial.isNoetherianRing_fin","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsNoetherianRing R\nn : Nat\n⊢ IsNoetherianRing (MvPolynomial (Fin n) R)","decl":"theorem isNoetherianRing_fin [IsNoetherianRing R] :\n    ∀ {n : ℕ}, IsNoetherianRing (MvPolynomial (Fin n) R)\n  | 0 => isNoetherianRing_fin_0\n  | n + 1 =>\n    @isNoetherianRing_of_ringEquiv (Polynomial (MvPolynomial (Fin n) R)) _ _ _\n      (MvPolynomial.finSuccEquiv _ n).toRingEquiv.symm\n      (@Polynomial.isNoetherianRing (MvPolynomial (Fin n) R) _ isNoetherianRing_fin)\n\n"}
{"name":"MvPolynomial.isNoetherianRing","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\nσ : Type v\ninst✝² : CommRing R\ninst✝¹ : Finite σ\ninst✝ : IsNoetherianRing R\n⊢ IsNoetherianRing (MvPolynomial σ R)","decl":"/-- The multivariate polynomial ring in finitely many variables over a noetherian ring\nis itself a noetherian ring. -/\ninstance isNoetherianRing [Finite σ] [IsNoetherianRing R] :\n    IsNoetherianRing (MvPolynomial σ R) := by\n  cases nonempty_fintype σ\n  exact\n    @isNoetherianRing_of_ringEquiv (MvPolynomial (Fin (Fintype.card σ)) R) _ _ _\n      (renameEquiv R (Fintype.equivFin σ).symm).toRingEquiv isNoetherianRing_fin\n\n"}
{"name":"MvPolynomial.noZeroDivisors_fin","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝¹ : CommSemiring R\ninst✝ : NoZeroDivisors R\nn : Nat\n⊢ NoZeroDivisors (MvPolynomial (Fin n) R)","decl":"/-- Auxiliary lemma:\nMultivariate polynomials over an integral domain\nwith variables indexed by `Fin n` form an integral domain.\nThis fact is proven inductively,\nand then used to prove the general case without any finiteness hypotheses.\nSee `MvPolynomial.noZeroDivisors` for the general case. -/\ntheorem noZeroDivisors_fin (R : Type u) [CommSemiring R] [NoZeroDivisors R] :\n    ∀ n : ℕ, NoZeroDivisors (MvPolynomial (Fin n) R)\n  | 0 => (MvPolynomial.isEmptyAlgEquiv R _).injective.noZeroDivisors _ (map_zero _) (map_mul _)\n  | n + 1 =>\n    haveI := noZeroDivisors_fin R n\n    (MvPolynomial.finSuccEquiv R n).injective.noZeroDivisors _ (map_zero _) (map_mul _)\n\n"}
{"name":"MvPolynomial.noZeroDivisors_of_finite","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\nσ : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Finite σ\ninst✝ : NoZeroDivisors R\n⊢ NoZeroDivisors (MvPolynomial σ R)","decl":"/-- Auxiliary definition:\nMultivariate polynomials in finitely many variables over an integral domain form an integral domain.\nThis fact is proven by transport of structure from the `MvPolynomial.noZeroDivisors_fin`,\nand then used to prove the general case without finiteness hypotheses.\nSee `MvPolynomial.noZeroDivisors` for the general case. -/\ntheorem noZeroDivisors_of_finite (R : Type u) (σ : Type v) [CommSemiring R] [Finite σ]\n    [NoZeroDivisors R] : NoZeroDivisors (MvPolynomial σ R) := by\n  cases nonempty_fintype σ\n  haveI := noZeroDivisors_fin R (Fintype.card σ)\n  exact (renameEquiv R (Fintype.equivFin σ)).injective.noZeroDivisors _ (map_zero _) (map_mul _)\n\n"}
{"name":"MvPolynomial.instNoZeroDivisors","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝¹ : CommSemiring R\ninst✝ : NoZeroDivisors R\nσ : Type v\n⊢ NoZeroDivisors (MvPolynomial σ R)","decl":"instance {R : Type u} [CommSemiring R] [NoZeroDivisors R] {σ : Type v} :\n    NoZeroDivisors (MvPolynomial σ R) where\n  eq_zero_or_eq_zero_of_mul_eq_zero {p q} h := by\n    obtain ⟨s, p, q, rfl, rfl⟩ := exists_finset_rename₂ p q\n    let _nzd := MvPolynomial.noZeroDivisors_of_finite R s\n    have : p * q = 0 := by\n      apply rename_injective _ Subtype.val_injective\n      simpa using h\n    rw [mul_eq_zero] at this\n    apply this.imp <;> rintro rfl <;> simp\n\n"}
{"name":"MvPolynomial.isDomain","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\nσ : Type v\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\n⊢ IsDomain (MvPolynomial σ R)","decl":"/-- The multivariate polynomial ring over an integral domain is an integral domain. -/\ninstance isDomain {R : Type u} {σ : Type v} [CommRing R] [IsDomain R] :\n    IsDomain (MvPolynomial σ R) := by\n  apply @NoZeroDivisors.to_isDomain (MvPolynomial σ R) _ ?_ _\n  apply AddMonoidAlgebra.nontrivial\n\n-- instance {R : Type u} {σ : Type v} [CommRing R] [IsDomain R] :\n--     IsDomain (MvPolynomial σ R)[X] := inferInstance\n\n"}
{"name":"MvPolynomial.map_mvPolynomial_eq_eval₂","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\nσ : Type v\ninst✝² : CommRing R\nS : Type u_2\ninst✝¹ : CommRing S\ninst✝ : Finite σ\nϕ : RingHom (MvPolynomial σ R) S\np : MvPolynomial σ R\n⊢ Eq (ϕ p) (MvPolynomial.eval₂ (ϕ.comp MvPolynomial.C) (fun s => ϕ (MvPolynomial.X s)) p)","decl":"theorem map_mvPolynomial_eq_eval₂ {S : Type*} [CommRing S] [Finite σ] (ϕ : MvPolynomial σ R →+* S)\n    (p : MvPolynomial σ R) :\n    ϕ p = MvPolynomial.eval₂ (ϕ.comp MvPolynomial.C) (fun s => ϕ (MvPolynomial.X s)) p := by\n  cases nonempty_fintype σ\n  refine Trans.trans (congr_arg ϕ (MvPolynomial.as_sum p)) ?_\n  rw [MvPolynomial.eval₂_eq', map_sum ϕ]\n  congr\n  ext\n  simp only [monomial_eq, ϕ.map_pow, map_prod ϕ, ϕ.comp_apply, ϕ.map_mul, Finsupp.prod_pow]\n\n"}
{"name":"MvPolynomial.mem_ideal_of_coeff_mem_ideal","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\nσ : Type v\ninst✝ : CommRing R\nI : Ideal (MvPolynomial σ R)\np : MvPolynomial σ R\nhcoe : ∀ (m : Finsupp σ Nat), Membership.mem (Ideal.comap MvPolynomial.C I) (MvPolynomial.coeff m p)\n⊢ Membership.mem I p","decl":"/-- If every coefficient of a polynomial is in an ideal `I`, then so is the polynomial itself,\nmultivariate version. -/\ntheorem mem_ideal_of_coeff_mem_ideal (I : Ideal (MvPolynomial σ R)) (p : MvPolynomial σ R)\n    (hcoe : ∀ m : σ →₀ ℕ, p.coeff m ∈ I.comap (C : R →+* MvPolynomial σ R)) : p ∈ I := by\n  rw [as_sum p]\n  suffices ∀ m ∈ p.support, monomial m (MvPolynomial.coeff m p) ∈ I by\n    exact Submodule.sum_mem I this\n  intro m _\n  rw [← mul_one (coeff m p), ← C_mul_monomial]\n  suffices C (coeff m p) ∈ I by exact I.mul_mem_right (monomial m 1) this\n  simpa [Ideal.mem_comap] using hcoe m\n\n"}
{"name":"MvPolynomial.mem_map_C_iff","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\nσ : Type v\ninst✝ : CommRing R\nI : Ideal R\nf : MvPolynomial σ R\n⊢ Iff (Membership.mem (Ideal.map MvPolynomial.C I) f) (∀ (m : Finsupp σ Nat), Membership.mem I (MvPolynomial.coeff m f))","decl":"/-- The push-forward of an ideal `I` of `R` to `MvPolynomial σ R` via inclusion\n is exactly the set of polynomials whose coefficients are in `I` -/\ntheorem mem_map_C_iff {I : Ideal R} {f : MvPolynomial σ R} :\n    f ∈ (Ideal.map (C : R →+* MvPolynomial σ R) I : Ideal (MvPolynomial σ R)) ↔\n      ∀ m : σ →₀ ℕ, f.coeff m ∈ I := by\n  classical\n  constructor\n  · intro hf\n    refine Submodule.span_induction ?_ ?_ ?_ ?_ hf\n    · intro f hf n\n      cases' (Set.mem_image _ _ _).mp hf with x hx\n      rw [← hx.right, coeff_C]\n      by_cases h : n = 0\n      · simpa [h] using hx.left\n      · simp [Ne.symm h]\n    · simp\n    · exact fun f g _ _ hf hg n => by simp [I.add_mem (hf n) (hg n)]\n    · refine fun f g _ hg n => ?_\n      rw [smul_eq_mul, coeff_mul]\n      exact I.sum_mem fun c _ => I.mul_mem_left (f.coeff c.fst) (hg c.snd)\n  · intro hf\n    rw [as_sum f]\n    suffices ∀ m ∈ f.support, monomial m (coeff m f) ∈ (Ideal.map C I : Ideal (MvPolynomial σ R)) by\n      exact Submodule.sum_mem _ this\n    intro m _\n    rw [← mul_one (coeff m f), ← C_mul_monomial]\n    suffices C (coeff m f) ∈ (Ideal.map C I : Ideal (MvPolynomial σ R)) by\n      exact Ideal.mul_mem_right _ _ this\n    apply Ideal.mem_map_of_mem _\n    exact hf m\n\n"}
{"name":"MvPolynomial.ker_map","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\nS : Type u_1\nσ : Type v\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nf : RingHom R S\n⊢ Eq (RingHom.ker (MvPolynomial.map f)) (Ideal.map MvPolynomial.C (RingHom.ker f))","decl":"theorem ker_map (f : R →+* S) :\n    RingHom.ker (map f : MvPolynomial σ R →+* MvPolynomial σ S) =\n    Ideal.map (C : R →+* MvPolynomial σ R) (RingHom.ker f) := by\n  ext\n  rw [MvPolynomial.mem_map_C_iff, RingHom.mem_ker, MvPolynomial.ext_iff]\n  simp_rw [coeff_map, coeff_zero, RingHom.mem_ker]\n\n"}
{"name":"MvPolynomial.ker_mapAlgHom","module":"Mathlib.RingTheory.Polynomial.Basic","initialProofState":"R : Type u\ninst✝⁴ : CommRing R\nS₁ : Type u_2\nS₂ : Type u_3\nσ : Type u_4\ninst✝³ : CommRing S₁\ninst✝² : CommRing S₂\ninst✝¹ : Algebra R S₁\ninst✝ : Algebra R S₂\nf : AlgHom R S₁ S₂\n⊢ Eq (RingHom.ker (MvPolynomial.mapAlgHom f)) (Ideal.map MvPolynomial.C (RingHom.ker f))","decl":"lemma ker_mapAlgHom {S₁ S₂ σ : Type*} [CommRing S₁] [CommRing S₂] [Algebra R S₁]\n    [Algebra R S₂] (f : S₁ →ₐ[R] S₂) :\n    RingHom.ker (MvPolynomial.mapAlgHom (σ := σ) f) = Ideal.map MvPolynomial.C (RingHom.ker f) :=\n  MvPolynomial.ker_map (f.toRingHom : S₁ →+* S₂)\n\n"}
