{"name":"Convex.integral_mem","module":"Mathlib.Analysis.Convex.Integral","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : CompleteSpace E\nŒº : MeasureTheory.Measure Œ±\ns : Set E\nf : Œ± ‚Üí E\ninst‚úù : MeasureTheory.IsProbabilityMeasure Œº\nhs : Convex Real s\nhsc : IsClosed s\nhf : Filter.Eventually (fun x => Membership.mem s (f x)) (MeasureTheory.ae Œº)\nhfi : MeasureTheory.Integrable f Œº\n‚ä¢ Membership.mem s (MeasureTheory.integral Œº fun x => f x)","decl":"/-- If `Œº` is a probability measure on `Œ±`, `s` is a convex closed set in `E`, and `f` is an\nintegrable function sending `Œº`-a.e. points to `s`, then the expected value of `f` belongs to `s`:\n`‚à´ x, f x ‚àÇŒº ‚àà s`. See also `Convex.sum_mem` for a finite sum version of this lemma. -/\ntheorem Convex.integral_mem [IsProbabilityMeasure Œº] (hs : Convex ‚Ñù s) (hsc : IsClosed s)\n    (hf : ‚àÄ·µê x ‚àÇŒº, f x ‚àà s) (hfi : Integrable f Œº) : (‚à´ x, f x ‚àÇŒº) ‚àà s := by\n  borelize E\n  rcases hfi.aestronglyMeasurable with ‚ü®g, hgm, hfg‚ü©\n  haveI : SeparableSpace (range g ‚à© s : Set E) :=\n    (hgm.isSeparable_range.mono inter_subset_left).separableSpace\n  obtain ‚ü®y‚ÇÄ, h‚ÇÄ‚ü© : (range g ‚à© s).Nonempty := by\n    rcases (hf.and hfg).exists with ‚ü®x‚ÇÄ, h‚ÇÄ‚ü©\n    exact ‚ü®f x‚ÇÄ, by simp only [h‚ÇÄ.2, mem_range_self], h‚ÇÄ.1‚ü©\n  rw [integral_congr_ae hfg]; rw [integrable_congr hfg] at hfi\n  have hg : ‚àÄ·µê x ‚àÇŒº, g x ‚àà closure (range g ‚à© s) := by\n    filter_upwards [hfg.rw (fun _ y => y ‚àà s) hf] with x hx\n    apply subset_closure\n    exact ‚ü®mem_range_self _, hx‚ü©\n  set G : ‚Ñï ‚Üí SimpleFunc Œ± E := SimpleFunc.approxOn _ hgm.measurable (range g ‚à© s) y‚ÇÄ h‚ÇÄ\n  have : Tendsto (fun n => (G n).integral Œº) atTop (ùìù <| ‚à´ x, g x ‚àÇŒº) :=\n    tendsto_integral_approxOn_of_measurable hfi _ hg _ (integrable_const _)\n  refine hsc.mem_of_tendsto this (Eventually.of_forall fun n => hs.sum_mem ?_ ?_ ?_)\n  ¬∑ exact fun _ _ => ENNReal.toReal_nonneg\n  ¬∑ rw [‚Üê ENNReal.toReal_sum, (G n).sum_range_measure_preimage_singleton, measure_univ,\n      ENNReal.one_toReal]\n    exact fun _ _ => measure_ne_top _ _\n  ¬∑ simp only [SimpleFunc.mem_range, forall_mem_range]\n    intro x\n    apply (range g).inter_subset_right\n    exact SimpleFunc.approxOn_mem hgm.measurable h‚ÇÄ _ _\n\n"}
{"name":"Convex.average_mem","module":"Mathlib.Analysis.Convex.Integral","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : CompleteSpace E\nŒº : MeasureTheory.Measure Œ±\ns : Set E\nf : Œ± ‚Üí E\ninst‚úù¬π : MeasureTheory.IsFiniteMeasure Œº\ninst‚úù : NeZero Œº\nhs : Convex Real s\nhsc : IsClosed s\nhfs : Filter.Eventually (fun x => Membership.mem s (f x)) (MeasureTheory.ae Œº)\nhfi : MeasureTheory.Integrable f Œº\n‚ä¢ Membership.mem s (MeasureTheory.average Œº fun x => f x)","decl":"/-- If `Œº` is a non-zero finite measure on `Œ±`, `s` is a convex closed set in `E`, and `f` is an\nintegrable function sending `Œº`-a.e. points to `s`, then the average value of `f` belongs to `s`:\n`‚®ç x, f x ‚àÇŒº ‚àà s`. See also `Convex.centerMass_mem` for a finite sum version of this lemma. -/\ntheorem Convex.average_mem [IsFiniteMeasure Œº] [NeZero Œº] (hs : Convex ‚Ñù s) (hsc : IsClosed s)\n    (hfs : ‚àÄ·µê x ‚àÇŒº, f x ‚àà s) (hfi : Integrable f Œº) : (‚®ç x, f x ‚àÇŒº) ‚àà s :=\n  hs.integral_mem hsc (ae_mono' smul_absolutelyContinuous hfs) hfi.to_average\n\n"}
{"name":"Convex.set_average_mem","module":"Mathlib.Analysis.Convex.Integral","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : NormedSpace Real E\ninst‚úù : CompleteSpace E\nŒº : MeasureTheory.Measure Œ±\ns : Set E\nt : Set Œ±\nf : Œ± ‚Üí E\nhs : Convex Real s\nhsc : IsClosed s\nh0 : Ne (Œº t) 0\nht : Ne (Œº t) Top.top\nhfs : Filter.Eventually (fun x => Membership.mem s (f x)) (MeasureTheory.ae (Œº.restrict t))\nhfi : MeasureTheory.IntegrableOn f t Œº\n‚ä¢ Membership.mem s (MeasureTheory.average (Œº.restrict t) fun x => f x)","decl":"/-- If `Œº` is a non-zero finite measure on `Œ±`, `s` is a convex closed set in `E`, and `f` is an\nintegrable function sending `Œº`-a.e. points to `s`, then the average value of `f` belongs to `s`:\n`‚®ç x, f x ‚àÇŒº ‚àà s`. See also `Convex.centerMass_mem` for a finite sum version of this lemma. -/\ntheorem Convex.set_average_mem (hs : Convex ‚Ñù s) (hsc : IsClosed s) (h0 : Œº t ‚â† 0) (ht : Œº t ‚â† ‚àû)\n    (hfs : ‚àÄ·µê x ‚àÇŒº.restrict t, f x ‚àà s) (hfi : IntegrableOn f t Œº) : (‚®ç x in t, f x ‚àÇŒº) ‚àà s :=\n  have := Fact.mk ht.lt_top\n  have := NeZero.mk h0\n  hs.average_mem hsc hfs hfi\n\n"}
{"name":"Convex.set_average_mem_closure","module":"Mathlib.Analysis.Convex.Integral","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : NormedSpace Real E\ninst‚úù : CompleteSpace E\nŒº : MeasureTheory.Measure Œ±\ns : Set E\nt : Set Œ±\nf : Œ± ‚Üí E\nhs : Convex Real s\nh0 : Ne (Œº t) 0\nht : Ne (Œº t) Top.top\nhfs : Filter.Eventually (fun x => Membership.mem s (f x)) (MeasureTheory.ae (Œº.restrict t))\nhfi : MeasureTheory.IntegrableOn f t Œº\n‚ä¢ Membership.mem (closure s) (MeasureTheory.average (Œº.restrict t) fun x => f x)","decl":"/-- If `Œº` is a non-zero finite measure on `Œ±`, `s` is a convex set in `E`, and `f` is an integrable\nfunction sending `Œº`-a.e. points to `s`, then the average value of `f` belongs to `closure s`:\n`‚®ç x, f x ‚àÇŒº ‚àà s`. See also `Convex.centerMass_mem` for a finite sum version of this lemma. -/\ntheorem Convex.set_average_mem_closure (hs : Convex ‚Ñù s) (h0 : Œº t ‚â† 0) (ht : Œº t ‚â† ‚àû)\n    (hfs : ‚àÄ·µê x ‚àÇŒº.restrict t, f x ‚àà s) (hfi : IntegrableOn f t Œº) :\n    (‚®ç x in t, f x ‚àÇŒº) ‚àà closure s :=\n  hs.closure.set_average_mem isClosed_closure h0 ht (hfs.mono fun _ hx => subset_closure hx) hfi\n\n"}
{"name":"ConvexOn.average_mem_epigraph","module":"Mathlib.Analysis.Convex.Integral","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : CompleteSpace E\nŒº : MeasureTheory.Measure Œ±\ns : Set E\nf : Œ± ‚Üí E\ng : E ‚Üí Real\ninst‚úù¬π : MeasureTheory.IsFiniteMeasure Œº\ninst‚úù : NeZero Œº\nhg : ConvexOn Real s g\nhgc : ContinuousOn g s\nhsc : IsClosed s\nhfs : Filter.Eventually (fun x => Membership.mem s (f x)) (MeasureTheory.ae Œº)\nhfi : MeasureTheory.Integrable f Œº\nhgi : MeasureTheory.Integrable (Function.comp g f) Œº\n‚ä¢ Membership.mem (setOf fun p => And (Membership.mem s p.1) (LE.le (g p.1) p.2)) { fst := MeasureTheory.average Œº fun x => f x, snd := MeasureTheory.average Œº fun x => g (f x) }","decl":"theorem ConvexOn.average_mem_epigraph [IsFiniteMeasure Œº] [NeZero Œº] (hg : ConvexOn ‚Ñù s g)\n    (hgc : ContinuousOn g s) (hsc : IsClosed s) (hfs : ‚àÄ·µê x ‚àÇŒº, f x ‚àà s)\n    (hfi : Integrable f Œº) (hgi : Integrable (g ‚àò f) Œº) :\n    (‚®ç x, f x ‚àÇŒº, ‚®ç x, g (f x) ‚àÇŒº) ‚àà {p : E √ó ‚Ñù | p.1 ‚àà s ‚àß g p.1 ‚â§ p.2} := by\n  have ht_mem : ‚àÄ·µê x ‚àÇŒº, (f x, g (f x)) ‚àà {p : E √ó ‚Ñù | p.1 ‚àà s ‚àß g p.1 ‚â§ p.2} :=\n    hfs.mono fun x hx => ‚ü®hx, le_rfl‚ü©\n  exact average_pair hfi hgi ‚ñ∏\n    hg.convex_epigraph.average_mem (hsc.epigraph hgc) ht_mem (hfi.prod_mk hgi)\n\n"}
{"name":"ConcaveOn.average_mem_hypograph","module":"Mathlib.Analysis.Convex.Integral","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : CompleteSpace E\nŒº : MeasureTheory.Measure Œ±\ns : Set E\nf : Œ± ‚Üí E\ng : E ‚Üí Real\ninst‚úù¬π : MeasureTheory.IsFiniteMeasure Œº\ninst‚úù : NeZero Œº\nhg : ConcaveOn Real s g\nhgc : ContinuousOn g s\nhsc : IsClosed s\nhfs : Filter.Eventually (fun x => Membership.mem s (f x)) (MeasureTheory.ae Œº)\nhfi : MeasureTheory.Integrable f Œº\nhgi : MeasureTheory.Integrable (Function.comp g f) Œº\n‚ä¢ Membership.mem (setOf fun p => And (Membership.mem s p.1) (LE.le p.2 (g p.1))) { fst := MeasureTheory.average Œº fun x => f x, snd := MeasureTheory.average Œº fun x => g (f x) }","decl":"theorem ConcaveOn.average_mem_hypograph [IsFiniteMeasure Œº] [NeZero Œº] (hg : ConcaveOn ‚Ñù s g)\n    (hgc : ContinuousOn g s) (hsc : IsClosed s) (hfs : ‚àÄ·µê x ‚àÇŒº, f x ‚àà s)\n    (hfi : Integrable f Œº) (hgi : Integrable (g ‚àò f) Œº) :\n    (‚®ç x, f x ‚àÇŒº, ‚®ç x, g (f x) ‚àÇŒº) ‚àà {p : E √ó ‚Ñù | p.1 ‚àà s ‚àß p.2 ‚â§ g p.1} := by\n  simpa only [mem_setOf_eq, Pi.neg_apply, average_neg, neg_le_neg_iff] using\n    hg.neg.average_mem_epigraph hgc.neg hsc hfs hfi hgi.neg\n\n"}
{"name":"ConvexOn.map_average_le","module":"Mathlib.Analysis.Convex.Integral","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : CompleteSpace E\nŒº : MeasureTheory.Measure Œ±\ns : Set E\nf : Œ± ‚Üí E\ng : E ‚Üí Real\ninst‚úù¬π : MeasureTheory.IsFiniteMeasure Œº\ninst‚úù : NeZero Œº\nhg : ConvexOn Real s g\nhgc : ContinuousOn g s\nhsc : IsClosed s\nhfs : Filter.Eventually (fun x => Membership.mem s (f x)) (MeasureTheory.ae Œº)\nhfi : MeasureTheory.Integrable f Œº\nhgi : MeasureTheory.Integrable (Function.comp g f) Œº\n‚ä¢ LE.le (g (MeasureTheory.average Œº fun x => f x)) (MeasureTheory.average Œº fun x => g (f x))","decl":"/-- **Jensen's inequality**: if a function `g : E ‚Üí ‚Ñù` is convex and continuous on a convex closed\nset `s`, `Œº` is a finite non-zero measure on `Œ±`, and `f : Œ± ‚Üí E` is a function sending\n`Œº`-a.e. points to `s`, then the value of `g` at the average value of `f` is less than or equal to\nthe average value of `g ‚àò f` provided that both `f` and `g ‚àò f` are integrable. See also\n`ConvexOn.map_centerMass_le` for a finite sum version of this lemma. -/\ntheorem ConvexOn.map_average_le [IsFiniteMeasure Œº] [NeZero Œº]\n    (hg : ConvexOn ‚Ñù s g) (hgc : ContinuousOn g s) (hsc : IsClosed s)\n    (hfs : ‚àÄ·µê x ‚àÇŒº, f x ‚àà s) (hfi : Integrable f Œº) (hgi : Integrable (g ‚àò f) Œº) :\n    g (‚®ç x, f x ‚àÇŒº) ‚â§ ‚®ç x, g (f x) ‚àÇŒº :=\n  (hg.average_mem_epigraph hgc hsc hfs hfi hgi).2\n\n"}
{"name":"ConcaveOn.le_map_average","module":"Mathlib.Analysis.Convex.Integral","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : CompleteSpace E\nŒº : MeasureTheory.Measure Œ±\ns : Set E\nf : Œ± ‚Üí E\ng : E ‚Üí Real\ninst‚úù¬π : MeasureTheory.IsFiniteMeasure Œº\ninst‚úù : NeZero Œº\nhg : ConcaveOn Real s g\nhgc : ContinuousOn g s\nhsc : IsClosed s\nhfs : Filter.Eventually (fun x => Membership.mem s (f x)) (MeasureTheory.ae Œº)\nhfi : MeasureTheory.Integrable f Œº\nhgi : MeasureTheory.Integrable (Function.comp g f) Œº\n‚ä¢ LE.le (MeasureTheory.average Œº fun x => g (f x)) (g (MeasureTheory.average Œº fun x => f x))","decl":"/-- **Jensen's inequality**: if a function `g : E ‚Üí ‚Ñù` is concave and continuous on a convex closed\nset `s`, `Œº` is a finite non-zero measure on `Œ±`, and `f : Œ± ‚Üí E` is a function sending\n`Œº`-a.e. points to `s`, then the average value of `g ‚àò f` is less than or equal to the value of `g`\nat the average value of `f` provided that both `f` and `g ‚àò f` are integrable. See also\n`ConcaveOn.le_map_centerMass` for a finite sum version of this lemma. -/\ntheorem ConcaveOn.le_map_average [IsFiniteMeasure Œº] [NeZero Œº]\n    (hg : ConcaveOn ‚Ñù s g) (hgc : ContinuousOn g s) (hsc : IsClosed s)\n    (hfs : ‚àÄ·µê x ‚àÇŒº, f x ‚àà s) (hfi : Integrable f Œº) (hgi : Integrable (g ‚àò f) Œº) :\n    (‚®ç x, g (f x) ‚àÇŒº) ‚â§ g (‚®ç x, f x ‚àÇŒº) :=\n  (hg.average_mem_hypograph hgc hsc hfs hfi hgi).2\n\n"}
{"name":"ConvexOn.set_average_mem_epigraph","module":"Mathlib.Analysis.Convex.Integral","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : NormedSpace Real E\ninst‚úù : CompleteSpace E\nŒº : MeasureTheory.Measure Œ±\ns : Set E\nt : Set Œ±\nf : Œ± ‚Üí E\ng : E ‚Üí Real\nhg : ConvexOn Real s g\nhgc : ContinuousOn g s\nhsc : IsClosed s\nh0 : Ne (Œº t) 0\nht : Ne (Œº t) Top.top\nhfs : Filter.Eventually (fun x => Membership.mem s (f x)) (MeasureTheory.ae (Œº.restrict t))\nhfi : MeasureTheory.IntegrableOn f t Œº\nhgi : MeasureTheory.IntegrableOn (Function.comp g f) t Œº\n‚ä¢ Membership.mem (setOf fun p => And (Membership.mem s p.1) (LE.le (g p.1) p.2)) { fst := MeasureTheory.average (Œº.restrict t) fun x => f x, snd := MeasureTheory.average (Œº.restrict t) fun x => g (f x) }","decl":"/-- **Jensen's inequality**: if a function `g : E ‚Üí ‚Ñù` is convex and continuous on a convex closed\nset `s`, `Œº` is a finite non-zero measure on `Œ±`, and `f : Œ± ‚Üí E` is a function sending\n`Œº`-a.e. points of a set `t` to `s`, then the value of `g` at the average value of `f` over `t` is\nless than or equal to the average value of `g ‚àò f` over `t` provided that both `f` and `g ‚àò f` are\nintegrable. -/\ntheorem ConvexOn.set_average_mem_epigraph (hg : ConvexOn ‚Ñù s g) (hgc : ContinuousOn g s)\n    (hsc : IsClosed s) (h0 : Œº t ‚â† 0) (ht : Œº t ‚â† ‚àû) (hfs : ‚àÄ·µê x ‚àÇŒº.restrict t, f x ‚àà s)\n    (hfi : IntegrableOn f t Œº) (hgi : IntegrableOn (g ‚àò f) t Œº) :\n    (‚®ç x in t, f x ‚àÇŒº, ‚®ç x in t, g (f x) ‚àÇŒº) ‚àà {p : E √ó ‚Ñù | p.1 ‚àà s ‚àß g p.1 ‚â§ p.2} :=\n  have := Fact.mk ht.lt_top\n  have := NeZero.mk h0\n  hg.average_mem_epigraph hgc hsc hfs hfi hgi\n\n"}
{"name":"ConcaveOn.set_average_mem_hypograph","module":"Mathlib.Analysis.Convex.Integral","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : NormedSpace Real E\ninst‚úù : CompleteSpace E\nŒº : MeasureTheory.Measure Œ±\ns : Set E\nt : Set Œ±\nf : Œ± ‚Üí E\ng : E ‚Üí Real\nhg : ConcaveOn Real s g\nhgc : ContinuousOn g s\nhsc : IsClosed s\nh0 : Ne (Œº t) 0\nht : Ne (Œº t) Top.top\nhfs : Filter.Eventually (fun x => Membership.mem s (f x)) (MeasureTheory.ae (Œº.restrict t))\nhfi : MeasureTheory.IntegrableOn f t Œº\nhgi : MeasureTheory.IntegrableOn (Function.comp g f) t Œº\n‚ä¢ Membership.mem (setOf fun p => And (Membership.mem s p.1) (LE.le p.2 (g p.1))) { fst := MeasureTheory.average (Œº.restrict t) fun x => f x, snd := MeasureTheory.average (Œº.restrict t) fun x => g (f x) }","decl":"/-- **Jensen's inequality**: if a function `g : E ‚Üí ‚Ñù` is concave and continuous on a convex closed\nset `s`, `Œº` is a finite non-zero measure on `Œ±`, and `f : Œ± ‚Üí E` is a function sending\n`Œº`-a.e. points of a set `t` to `s`, then the average value of `g ‚àò f` over `t` is less than or\nequal to the value of `g` at the average value of `f` over `t` provided that both `f` and `g ‚àò f`\nare integrable. -/\ntheorem ConcaveOn.set_average_mem_hypograph (hg : ConcaveOn ‚Ñù s g) (hgc : ContinuousOn g s)\n    (hsc : IsClosed s) (h0 : Œº t ‚â† 0) (ht : Œº t ‚â† ‚àû) (hfs : ‚àÄ·µê x ‚àÇŒº.restrict t, f x ‚àà s)\n    (hfi : IntegrableOn f t Œº) (hgi : IntegrableOn (g ‚àò f) t Œº) :\n    (‚®ç x in t, f x ‚àÇŒº, ‚®ç x in t, g (f x) ‚àÇŒº) ‚àà {p : E √ó ‚Ñù | p.1 ‚àà s ‚àß p.2 ‚â§ g p.1} := by\n  simpa only [mem_setOf_eq, Pi.neg_apply, average_neg, neg_le_neg_iff] using\n    hg.neg.set_average_mem_epigraph hgc.neg hsc h0 ht hfs hfi hgi.neg\n\n"}
{"name":"ConvexOn.map_set_average_le","module":"Mathlib.Analysis.Convex.Integral","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : NormedSpace Real E\ninst‚úù : CompleteSpace E\nŒº : MeasureTheory.Measure Œ±\ns : Set E\nt : Set Œ±\nf : Œ± ‚Üí E\ng : E ‚Üí Real\nhg : ConvexOn Real s g\nhgc : ContinuousOn g s\nhsc : IsClosed s\nh0 : Ne (Œº t) 0\nht : Ne (Œº t) Top.top\nhfs : Filter.Eventually (fun x => Membership.mem s (f x)) (MeasureTheory.ae (Œº.restrict t))\nhfi : MeasureTheory.IntegrableOn f t Œº\nhgi : MeasureTheory.IntegrableOn (Function.comp g f) t Œº\n‚ä¢ LE.le (g (MeasureTheory.average (Œº.restrict t) fun x => f x)) (MeasureTheory.average (Œº.restrict t) fun x => g (f x))","decl":"/-- **Jensen's inequality**: if a function `g : E ‚Üí ‚Ñù` is convex and continuous on a convex closed\nset `s`, `Œº` is a finite non-zero measure on `Œ±`, and `f : Œ± ‚Üí E` is a function sending\n`Œº`-a.e. points of a set `t` to `s`, then the value of `g` at the average value of `f` over `t` is\nless than or equal to the average value of `g ‚àò f` over `t` provided that both `f` and `g ‚àò f` are\nintegrable. -/\ntheorem ConvexOn.map_set_average_le (hg : ConvexOn ‚Ñù s g) (hgc : ContinuousOn g s)\n    (hsc : IsClosed s) (h0 : Œº t ‚â† 0) (ht : Œº t ‚â† ‚àû) (hfs : ‚àÄ·µê x ‚àÇŒº.restrict t, f x ‚àà s)\n    (hfi : IntegrableOn f t Œº) (hgi : IntegrableOn (g ‚àò f) t Œº) :\n    g (‚®ç x in t, f x ‚àÇŒº) ‚â§ ‚®ç x in t, g (f x) ‚àÇŒº :=\n  (hg.set_average_mem_epigraph hgc hsc h0 ht hfs hfi hgi).2\n\n"}
{"name":"ConcaveOn.le_map_set_average","module":"Mathlib.Analysis.Convex.Integral","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : NormedSpace Real E\ninst‚úù : CompleteSpace E\nŒº : MeasureTheory.Measure Œ±\ns : Set E\nt : Set Œ±\nf : Œ± ‚Üí E\ng : E ‚Üí Real\nhg : ConcaveOn Real s g\nhgc : ContinuousOn g s\nhsc : IsClosed s\nh0 : Ne (Œº t) 0\nht : Ne (Œº t) Top.top\nhfs : Filter.Eventually (fun x => Membership.mem s (f x)) (MeasureTheory.ae (Œº.restrict t))\nhfi : MeasureTheory.IntegrableOn f t Œº\nhgi : MeasureTheory.IntegrableOn (Function.comp g f) t Œº\n‚ä¢ LE.le (MeasureTheory.average (Œº.restrict t) fun x => g (f x)) (g (MeasureTheory.average (Œº.restrict t) fun x => f x))","decl":"/-- **Jensen's inequality**: if a function `g : E ‚Üí ‚Ñù` is concave and continuous on a convex closed\nset `s`, `Œº` is a finite non-zero measure on `Œ±`, and `f : Œ± ‚Üí E` is a function sending\n`Œº`-a.e. points of a set `t` to `s`, then the average value of `g ‚àò f` over `t` is less than or\nequal to the value of `g` at the average value of `f` over `t` provided that both `f` and `g ‚àò f`\nare integrable. -/\ntheorem ConcaveOn.le_map_set_average (hg : ConcaveOn ‚Ñù s g) (hgc : ContinuousOn g s)\n    (hsc : IsClosed s) (h0 : Œº t ‚â† 0) (ht : Œº t ‚â† ‚àû) (hfs : ‚àÄ·µê x ‚àÇŒº.restrict t, f x ‚àà s)\n    (hfi : IntegrableOn f t Œº) (hgi : IntegrableOn (g ‚àò f) t Œº) :\n    (‚®ç x in t, g (f x) ‚àÇŒº) ‚â§ g (‚®ç x in t, f x ‚àÇŒº) :=\n  (hg.set_average_mem_hypograph hgc hsc h0 ht hfs hfi hgi).2\n\n"}
{"name":"ConvexOn.map_integral_le","module":"Mathlib.Analysis.Convex.Integral","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : CompleteSpace E\nŒº : MeasureTheory.Measure Œ±\ns : Set E\nf : Œ± ‚Üí E\ng : E ‚Üí Real\ninst‚úù : MeasureTheory.IsProbabilityMeasure Œº\nhg : ConvexOn Real s g\nhgc : ContinuousOn g s\nhsc : IsClosed s\nhfs : Filter.Eventually (fun x => Membership.mem s (f x)) (MeasureTheory.ae Œº)\nhfi : MeasureTheory.Integrable f Œº\nhgi : MeasureTheory.Integrable (Function.comp g f) Œº\n‚ä¢ LE.le (g (MeasureTheory.integral Œº fun x => f x)) (MeasureTheory.integral Œº fun x => g (f x))","decl":"/-- **Jensen's inequality**: if a function `g : E ‚Üí ‚Ñù` is convex and continuous on a convex closed\nset `s`, `Œº` is a probability measure on `Œ±`, and `f : Œ± ‚Üí E` is a function sending `Œº`-a.e.  points\nto `s`, then the value of `g` at the expected value of `f` is less than or equal to the expected\nvalue of `g ‚àò f` provided that both `f` and `g ‚àò f` are integrable. See also\n`ConvexOn.map_centerMass_le` for a finite sum version of this lemma. -/\ntheorem ConvexOn.map_integral_le [IsProbabilityMeasure Œº] (hg : ConvexOn ‚Ñù s g)\n    (hgc : ContinuousOn g s) (hsc : IsClosed s) (hfs : ‚àÄ·µê x ‚àÇŒº, f x ‚àà s) (hfi : Integrable f Œº)\n    (hgi : Integrable (g ‚àò f) Œº) : g (‚à´ x, f x ‚àÇŒº) ‚â§ ‚à´ x, g (f x) ‚àÇŒº := by\n  simpa only [average_eq_integral] using hg.map_average_le hgc hsc hfs hfi hgi\n\n"}
{"name":"ConcaveOn.le_map_integral","module":"Mathlib.Analysis.Convex.Integral","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : CompleteSpace E\nŒº : MeasureTheory.Measure Œ±\ns : Set E\nf : Œ± ‚Üí E\ng : E ‚Üí Real\ninst‚úù : MeasureTheory.IsProbabilityMeasure Œº\nhg : ConcaveOn Real s g\nhgc : ContinuousOn g s\nhsc : IsClosed s\nhfs : Filter.Eventually (fun x => Membership.mem s (f x)) (MeasureTheory.ae Œº)\nhfi : MeasureTheory.Integrable f Œº\nhgi : MeasureTheory.Integrable (Function.comp g f) Œº\n‚ä¢ LE.le (MeasureTheory.integral Œº fun x => g (f x)) (g (MeasureTheory.integral Œº fun x => f x))","decl":"/-- **Jensen's inequality**: if a function `g : E ‚Üí ‚Ñù` is concave and continuous on a convex closed\nset `s`, `Œº` is a probability measure on `Œ±`, and `f : Œ± ‚Üí E` is a function sending `Œº`-a.e.  points\nto `s`, then the expected value of `g ‚àò f` is less than or equal to the value of `g` at the expected\nvalue of `f` provided that both `f` and `g ‚àò f` are integrable. -/\ntheorem ConcaveOn.le_map_integral [IsProbabilityMeasure Œº] (hg : ConcaveOn ‚Ñù s g)\n    (hgc : ContinuousOn g s) (hsc : IsClosed s) (hfs : ‚àÄ·µê x ‚àÇŒº, f x ‚àà s) (hfi : Integrable f Œº)\n    (hgi : Integrable (g ‚àò f) Œº) : (‚à´ x, g (f x) ‚àÇŒº) ‚â§ g (‚à´ x, f x ‚àÇŒº) := by\n  simpa only [average_eq_integral] using hg.le_map_average hgc hsc hfs hfi hgi\n\n"}
{"name":"ae_eq_const_or_exists_average_ne_compl","module":"Mathlib.Analysis.Convex.Integral","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : CompleteSpace E\nŒº : MeasureTheory.Measure Œ±\nf : Œ± ‚Üí E\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\nhfi : MeasureTheory.Integrable f Œº\n‚ä¢ Or ((MeasureTheory.ae Œº).EventuallyEq f (Function.const Œ± (MeasureTheory.average Œº fun x => f x))) (Exists fun t => And (MeasurableSet t) (And (Ne (Œº t) 0) (And (Ne (Œº (HasCompl.compl t)) 0) (Ne (MeasureTheory.average (Œº.restrict t) fun x => f x) (MeasureTheory.average (Œº.restrict (HasCompl.compl t)) fun x => f x)))))","decl":"/-- If `f : Œ± ‚Üí E` is an integrable function, then either it is a.e. equal to the constant\n`‚®ç x, f x ‚àÇŒº` or there exists a measurable set such that `Œº t ‚â† 0`, `Œº t·∂ú ‚â† 0`, and the average\nvalues of `f` over `t` and `t·∂ú` are different. -/\ntheorem ae_eq_const_or_exists_average_ne_compl [IsFiniteMeasure Œº] (hfi : Integrable f Œº) :\n    f =·µê[Œº] const Œ± (‚®ç x, f x ‚àÇŒº) ‚à®\n      ‚àÉ t, MeasurableSet t ‚àß Œº t ‚â† 0 ‚àß Œº t·∂ú ‚â† 0 ‚àß (‚®ç x in t, f x ‚àÇŒº) ‚â† ‚®ç x in t·∂ú, f x ‚àÇŒº := by\n  refine or_iff_not_imp_right.mpr fun H => ?_; push_neg at H\n  refine hfi.ae_eq_of_forall_setIntegral_eq _ _ (integrable_const _) fun t ht ht' => ?_; clear ht'\n  simp only [const_apply, setIntegral_const]\n  by_cases h‚ÇÄ : Œº t = 0\n  ¬∑ rw [restrict_eq_zero.2 h‚ÇÄ, integral_zero_measure, h‚ÇÄ, ENNReal.zero_toReal, zero_smul]\n  by_cases h‚ÇÄ' : Œº t·∂ú = 0\n  ¬∑ rw [‚Üê ae_eq_univ] at h‚ÇÄ'\n    rw [restrict_congr_set h‚ÇÄ', restrict_univ, measure_congr h‚ÇÄ', measure_smul_average]\n  have := average_mem_openSegment_compl_self ht.nullMeasurableSet h‚ÇÄ h‚ÇÄ' hfi\n  rw [‚Üê H t ht h‚ÇÄ h‚ÇÄ', openSegment_same, mem_singleton_iff] at this\n  rw [this, measure_smul_setAverage _ (measure_ne_top Œº _)]\n\n"}
{"name":"Convex.average_mem_interior_of_set","module":"Mathlib.Analysis.Convex.Integral","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : CompleteSpace E\nŒº : MeasureTheory.Measure Œ±\ns : Set E\nt : Set Œ±\nf : Œ± ‚Üí E\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\nhs : Convex Real s\nh0 : Ne (Œº t) 0\nhfs : Filter.Eventually (fun x => Membership.mem s (f x)) (MeasureTheory.ae Œº)\nhfi : MeasureTheory.Integrable f Œº\nht : Membership.mem (interior s) (MeasureTheory.average (Œº.restrict t) fun x => f x)\n‚ä¢ Membership.mem (interior s) (MeasureTheory.average Œº fun x => f x)","decl":"/-- If an integrable function `f : Œ± ‚Üí E` takes values in a convex set `s` and for some set `t` of\npositive measure, the average value of `f` over `t` belongs to the interior of `s`, then the average\nof `f` over the whole space belongs to the interior of `s`. -/\ntheorem Convex.average_mem_interior_of_set [IsFiniteMeasure Œº] (hs : Convex ‚Ñù s) (h0 : Œº t ‚â† 0)\n    (hfs : ‚àÄ·µê x ‚àÇŒº, f x ‚àà s) (hfi : Integrable f Œº) (ht : (‚®ç x in t, f x ‚àÇŒº) ‚àà interior s) :\n    (‚®ç x, f x ‚àÇŒº) ‚àà interior s := by\n  rw [‚Üê measure_toMeasurable] at h0; rw [‚Üê restrict_toMeasurable (measure_ne_top Œº t)] at ht\n  by_cases h0' : Œº (toMeasurable Œº t)·∂ú = 0\n  ¬∑ rw [‚Üê ae_eq_univ] at h0'\n    rwa [restrict_congr_set h0', restrict_univ] at ht\n  exact\n    hs.openSegment_interior_closure_subset_interior ht\n      (hs.set_average_mem_closure h0' (measure_ne_top _ _) (ae_restrict_of_ae hfs)\n        hfi.integrableOn)\n      (average_mem_openSegment_compl_self (measurableSet_toMeasurable Œº t).nullMeasurableSet h0\n        h0' hfi)\n\n"}
{"name":"StrictConvex.ae_eq_const_or_average_mem_interior","module":"Mathlib.Analysis.Convex.Integral","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : CompleteSpace E\nŒº : MeasureTheory.Measure Œ±\ns : Set E\nf : Œ± ‚Üí E\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\nhs : StrictConvex Real s\nhsc : IsClosed s\nhfs : Filter.Eventually (fun x => Membership.mem s (f x)) (MeasureTheory.ae Œº)\nhfi : MeasureTheory.Integrable f Œº\n‚ä¢ Or ((MeasureTheory.ae Œº).EventuallyEq f (Function.const Œ± (MeasureTheory.average Œº fun x => f x))) (Membership.mem (interior s) (MeasureTheory.average Œº fun x => f x))","decl":"/-- If an integrable function `f : Œ± ‚Üí E` takes values in a strictly convex closed set `s`, then\neither it is a.e. equal to its average value, or its average value belongs to the interior of\n`s`. -/\ntheorem StrictConvex.ae_eq_const_or_average_mem_interior [IsFiniteMeasure Œº] (hs : StrictConvex ‚Ñù s)\n    (hsc : IsClosed s) (hfs : ‚àÄ·µê x ‚àÇŒº, f x ‚àà s) (hfi : Integrable f Œº) :\n    f =·µê[Œº] const Œ± (‚®ç x, f x ‚àÇŒº) ‚à® (‚®ç x, f x ‚àÇŒº) ‚àà interior s := by\n  have : ‚àÄ {t}, Œº t ‚â† 0 ‚Üí (‚®ç x in t, f x ‚àÇŒº) ‚àà s := fun ht =>\n    hs.convex.set_average_mem hsc ht (measure_ne_top _ _) (ae_restrict_of_ae hfs) hfi.integrableOn\n  refine (ae_eq_const_or_exists_average_ne_compl hfi).imp_right ?_\n  rintro ‚ü®t, hm, h‚ÇÄ, h‚ÇÄ', hne‚ü©\n  exact\n    hs.openSegment_subset (this h‚ÇÄ) (this h‚ÇÄ') hne\n      (average_mem_openSegment_compl_self hm.nullMeasurableSet h‚ÇÄ h‚ÇÄ' hfi)\n\n"}
{"name":"StrictConvexOn.ae_eq_const_or_map_average_lt","module":"Mathlib.Analysis.Convex.Integral","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : CompleteSpace E\nŒº : MeasureTheory.Measure Œ±\ns : Set E\nf : Œ± ‚Üí E\ng : E ‚Üí Real\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\nhg : StrictConvexOn Real s g\nhgc : ContinuousOn g s\nhsc : IsClosed s\nhfs : Filter.Eventually (fun x => Membership.mem s (f x)) (MeasureTheory.ae Œº)\nhfi : MeasureTheory.Integrable f Œº\nhgi : MeasureTheory.Integrable (Function.comp g f) Œº\n‚ä¢ Or ((MeasureTheory.ae Œº).EventuallyEq f (Function.const Œ± (MeasureTheory.average Œº fun x => f x))) (LT.lt (g (MeasureTheory.average Œº fun x => f x)) (MeasureTheory.average Œº fun x => g (f x)))","decl":"/-- **Jensen's inequality**, strict version: if an integrable function `f : Œ± ‚Üí E` takes values in a\nconvex closed set `s`, and `g : E ‚Üí ‚Ñù` is continuous and strictly convex on `s`, then\neither `f` is a.e. equal to its average value, or `g (‚®ç x, f x ‚àÇŒº) < ‚®ç x, g (f x) ‚àÇŒº`. -/\ntheorem StrictConvexOn.ae_eq_const_or_map_average_lt [IsFiniteMeasure Œº] (hg : StrictConvexOn ‚Ñù s g)\n    (hgc : ContinuousOn g s) (hsc : IsClosed s) (hfs : ‚àÄ·µê x ‚àÇŒº, f x ‚àà s) (hfi : Integrable f Œº)\n    (hgi : Integrable (g ‚àò f) Œº) :\n    f =·µê[Œº] const Œ± (‚®ç x, f x ‚àÇŒº) ‚à® g (‚®ç x, f x ‚àÇŒº) < ‚®ç x, g (f x) ‚àÇŒº := by\n  have : ‚àÄ {t}, Œº t ‚â† 0 ‚Üí (‚®ç x in t, f x ‚àÇŒº) ‚àà s ‚àß g (‚®ç x in t, f x ‚àÇŒº) ‚â§ ‚®ç x in t, g (f x) ‚àÇŒº :=\n    fun ht =>\n    hg.convexOn.set_average_mem_epigraph hgc hsc ht (measure_ne_top _ _) (ae_restrict_of_ae hfs)\n      hfi.integrableOn hgi.integrableOn\n  refine (ae_eq_const_or_exists_average_ne_compl hfi).imp_right ?_\n  rintro ‚ü®t, hm, h‚ÇÄ, h‚ÇÄ', hne‚ü©\n  rcases average_mem_openSegment_compl_self hm.nullMeasurableSet h‚ÇÄ h‚ÇÄ' (hfi.prod_mk hgi) with\n    ‚ü®a, b, ha, hb, hab, h_avg‚ü©\n  rw [average_pair hfi hgi, average_pair hfi.integrableOn hgi.integrableOn,\n    average_pair hfi.integrableOn hgi.integrableOn, Prod.smul_mk,\n    Prod.smul_mk, Prod.mk_add_mk, Prod.mk.inj_iff] at h_avg\n  simp only [Function.comp] at h_avg\n  rw [‚Üê h_avg.1, ‚Üê h_avg.2]\n  calc\n    g ((a ‚Ä¢ ‚®ç x in t, f x ‚àÇŒº) + b ‚Ä¢ ‚®ç x in t·∂ú, f x ‚àÇŒº) <\n        a * g (‚®ç x in t, f x ‚àÇŒº) + b * g (‚®ç x in t·∂ú, f x ‚àÇŒº) :=\n      hg.2 (this h‚ÇÄ).1 (this h‚ÇÄ').1 hne ha hb hab\n    _ ‚â§ (a * ‚®ç x in t, g (f x) ‚àÇŒº) + b * ‚®ç x in t·∂ú, g (f x) ‚àÇŒº :=\n      add_le_add (mul_le_mul_of_nonneg_left (this h‚ÇÄ).2 ha.le)\n        (mul_le_mul_of_nonneg_left (this h‚ÇÄ').2 hb.le)\n\n"}
{"name":"StrictConcaveOn.ae_eq_const_or_lt_map_average","module":"Mathlib.Analysis.Convex.Integral","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : CompleteSpace E\nŒº : MeasureTheory.Measure Œ±\ns : Set E\nf : Œ± ‚Üí E\ng : E ‚Üí Real\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\nhg : StrictConcaveOn Real s g\nhgc : ContinuousOn g s\nhsc : IsClosed s\nhfs : Filter.Eventually (fun x => Membership.mem s (f x)) (MeasureTheory.ae Œº)\nhfi : MeasureTheory.Integrable f Œº\nhgi : MeasureTheory.Integrable (Function.comp g f) Œº\n‚ä¢ Or ((MeasureTheory.ae Œº).EventuallyEq f (Function.const Œ± (MeasureTheory.average Œº fun x => f x))) (LT.lt (MeasureTheory.average Œº fun x => g (f x)) (g (MeasureTheory.average Œº fun x => f x)))","decl":"/-- **Jensen's inequality**, strict version: if an integrable function `f : Œ± ‚Üí E` takes values in a\nconvex closed set `s`, and `g : E ‚Üí ‚Ñù` is continuous and strictly concave on `s`, then\neither `f` is a.e. equal to its average value, or `‚®ç x, g (f x) ‚àÇŒº < g (‚®ç x, f x ‚àÇŒº)`. -/\ntheorem StrictConcaveOn.ae_eq_const_or_lt_map_average [IsFiniteMeasure Œº]\n    (hg : StrictConcaveOn ‚Ñù s g) (hgc : ContinuousOn g s) (hsc : IsClosed s)\n    (hfs : ‚àÄ·µê x ‚àÇŒº, f x ‚àà s) (hfi : Integrable f Œº) (hgi : Integrable (g ‚àò f) Œº) :\n    f =·µê[Œº] const Œ± (‚®ç x, f x ‚àÇŒº) ‚à® (‚®ç x, g (f x) ‚àÇŒº) < g (‚®ç x, f x ‚àÇŒº) := by\n  simpa only [Pi.neg_apply, average_neg, neg_lt_neg_iff] using\n    hg.neg.ae_eq_const_or_map_average_lt hgc.neg hsc hfs hfi hgi.neg\n\n"}
{"name":"ae_eq_const_or_norm_average_lt_of_norm_le_const","module":"Mathlib.Analysis.Convex.Integral","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : CompleteSpace E\nŒº : MeasureTheory.Measure Œ±\nf : Œ± ‚Üí E\nC : Real\ninst‚úù : StrictConvexSpace Real E\nh_le : Filter.Eventually (fun x => LE.le (Norm.norm (f x)) C) (MeasureTheory.ae Œº)\n‚ä¢ Or ((MeasureTheory.ae Œº).EventuallyEq f (Function.const Œ± (MeasureTheory.average Œº fun x => f x))) (LT.lt (Norm.norm (MeasureTheory.average Œº fun x => f x)) C)","decl":"/-- If `E` is a strictly convex normed space and `f : Œ± ‚Üí E` is a function such that `‚Äñf x‚Äñ ‚â§ C`\na.e., then either this function is a.e. equal to its average value, or the norm of its average value\nis strictly less than `C`. -/\ntheorem ae_eq_const_or_norm_average_lt_of_norm_le_const [StrictConvexSpace ‚Ñù E]\n    (h_le : ‚àÄ·µê x ‚àÇŒº, ‚Äñf x‚Äñ ‚â§ C) : f =·µê[Œº] const Œ± (‚®ç x, f x ‚àÇŒº) ‚à® ‚Äñ‚®ç x, f x ‚àÇŒº‚Äñ < C := by\n  rcases le_or_lt C 0 with hC0 | hC0\n  ¬∑ have : f =·µê[Œº] 0 := h_le.mono fun x hx => norm_le_zero_iff.1 (hx.trans hC0)\n    simp only [average_congr this, Pi.zero_apply, average_zero]\n    exact Or.inl this\n  by_cases hfi : Integrable f Œº; swap\n  ¬∑ simp [average_eq, integral_undef hfi, hC0, ENNReal.toReal_pos_iff]\n  rcases (le_top : Œº univ ‚â§ ‚àû).eq_or_lt with hŒºt | hŒºt; ¬∑ simp [average_eq, hŒºt, hC0]\n  haveI : IsFiniteMeasure Œº := ‚ü®hŒºt‚ü©\n  replace h_le : ‚àÄ·µê x ‚àÇŒº, f x ‚àà closedBall (0 : E) C := by simpa only [mem_closedBall_zero_iff]\n  simpa only [interior_closedBall _ hC0.ne', mem_ball_zero_iff] using\n    (strictConvex_closedBall ‚Ñù (0 : E) C).ae_eq_const_or_average_mem_interior isClosed_ball h_le\n      hfi\n\n"}
{"name":"ae_eq_const_or_norm_integral_lt_of_norm_le_const","module":"Mathlib.Analysis.Convex.Integral","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : CompleteSpace E\nŒº : MeasureTheory.Measure Œ±\nf : Œ± ‚Üí E\nC : Real\ninst‚úù¬π : StrictConvexSpace Real E\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\nh_le : Filter.Eventually (fun x => LE.le (Norm.norm (f x)) C) (MeasureTheory.ae Œº)\n‚ä¢ Or ((MeasureTheory.ae Œº).EventuallyEq f (Function.const Œ± (MeasureTheory.average Œº fun x => f x))) (LT.lt (Norm.norm (MeasureTheory.integral Œº fun x => f x)) (HMul.hMul (Œº Set.univ).toReal C))","decl":"/-- If `E` is a strictly convex normed space and `f : Œ± ‚Üí E` is a function such that `‚Äñf x‚Äñ ‚â§ C`\na.e., then either this function is a.e. equal to its average value, or the norm of its integral is\nstrictly less than `(Œº univ).toReal * C`. -/\ntheorem ae_eq_const_or_norm_integral_lt_of_norm_le_const [StrictConvexSpace ‚Ñù E] [IsFiniteMeasure Œº]\n    (h_le : ‚àÄ·µê x ‚àÇŒº, ‚Äñf x‚Äñ ‚â§ C) :\n    f =·µê[Œº] const Œ± (‚®ç x, f x ‚àÇŒº) ‚à® ‚Äñ‚à´ x, f x ‚àÇŒº‚Äñ < (Œº univ).toReal * C := by\n  rcases eq_or_ne Œº 0 with h‚ÇÄ | h‚ÇÄ; ¬∑ left; simp [h‚ÇÄ, EventuallyEq]\n  have hŒº : 0 < (Œº univ).toReal := by\n    simp [ENNReal.toReal_pos_iff, pos_iff_ne_zero, h‚ÇÄ, measure_lt_top]\n  refine (ae_eq_const_or_norm_average_lt_of_norm_le_const h_le).imp_right fun H => ?_\n  rwa [average_eq, norm_smul, norm_inv, Real.norm_eq_abs, abs_of_pos hŒº, ‚Üê div_eq_inv_mul,\n    div_lt_iff‚ÇÄ' hŒº] at H\n\n"}
{"name":"ae_eq_const_or_norm_setIntegral_lt_of_norm_le_const","module":"Mathlib.Analysis.Convex.Integral","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Œ±\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : CompleteSpace E\nŒº : MeasureTheory.Measure Œ±\nt : Set Œ±\nf : Œ± ‚Üí E\nC : Real\ninst‚úù : StrictConvexSpace Real E\nht : Ne (Œº t) Top.top\nh_le : Filter.Eventually (fun x => LE.le (Norm.norm (f x)) C) (MeasureTheory.ae (Œº.restrict t))\n‚ä¢ Or ((MeasureTheory.ae (Œº.restrict t)).EventuallyEq f (Function.const Œ± (MeasureTheory.average (Œº.restrict t) fun x => f x))) (LT.lt (Norm.norm (MeasureTheory.integral (Œº.restrict t) fun x => f x)) (HMul.hMul (Œº t).toReal C))","decl":"/-- If `E` is a strictly convex normed space and `f : Œ± ‚Üí E` is a function such that `‚Äñf x‚Äñ ‚â§ C`\na.e. on a set `t` of finite measure, then either this function is a.e. equal to its average value on\n`t`, or the norm of its integral over `t` is strictly less than `(Œº t).toReal * C`. -/\ntheorem ae_eq_const_or_norm_setIntegral_lt_of_norm_le_const [StrictConvexSpace ‚Ñù E] (ht : Œº t ‚â† ‚àû)\n    (h_le : ‚àÄ·µê x ‚àÇŒº.restrict t, ‚Äñf x‚Äñ ‚â§ C) :\n    f =·µê[Œº.restrict t] const Œ± (‚®ç x in t, f x ‚àÇŒº) ‚à® ‚Äñ‚à´ x in t, f x ‚àÇŒº‚Äñ < (Œº t).toReal * C := by\n  haveI := Fact.mk ht.lt_top\n  rw [‚Üê restrict_apply_univ]\n  exact ae_eq_const_or_norm_integral_lt_of_norm_le_const h_le\n"}
