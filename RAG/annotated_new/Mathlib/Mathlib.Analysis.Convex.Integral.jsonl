{"name":"Convex.integral_mem","module":"Mathlib.Analysis.Convex.Integral","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\ninst✝¹ : CompleteSpace E\nμ : MeasureTheory.Measure α\ns : Set E\nf : α → E\ninst✝ : MeasureTheory.IsProbabilityMeasure μ\nhs : Convex Real s\nhsc : IsClosed s\nhf : Filter.Eventually (fun x => Membership.mem s (f x)) (MeasureTheory.ae μ)\nhfi : MeasureTheory.Integrable f μ\n⊢ Membership.mem s (MeasureTheory.integral μ fun x => f x)","decl":"/-- If `μ` is a probability measure on `α`, `s` is a convex closed set in `E`, and `f` is an\nintegrable function sending `μ`-a.e. points to `s`, then the expected value of `f` belongs to `s`:\n`∫ x, f x ∂μ ∈ s`. See also `Convex.sum_mem` for a finite sum version of this lemma. -/\ntheorem Convex.integral_mem [IsProbabilityMeasure μ] (hs : Convex ℝ s) (hsc : IsClosed s)\n    (hf : ∀ᵐ x ∂μ, f x ∈ s) (hfi : Integrable f μ) : (∫ x, f x ∂μ) ∈ s := by\n  borelize E\n  rcases hfi.aestronglyMeasurable with ⟨g, hgm, hfg⟩\n  haveI : SeparableSpace (range g ∩ s : Set E) :=\n    (hgm.isSeparable_range.mono inter_subset_left).separableSpace\n  obtain ⟨y₀, h₀⟩ : (range g ∩ s).Nonempty := by\n    rcases (hf.and hfg).exists with ⟨x₀, h₀⟩\n    exact ⟨f x₀, by simp only [h₀.2, mem_range_self], h₀.1⟩\n  rw [integral_congr_ae hfg]; rw [integrable_congr hfg] at hfi\n  have hg : ∀ᵐ x ∂μ, g x ∈ closure (range g ∩ s) := by\n    filter_upwards [hfg.rw (fun _ y => y ∈ s) hf] with x hx\n    apply subset_closure\n    exact ⟨mem_range_self _, hx⟩\n  set G : ℕ → SimpleFunc α E := SimpleFunc.approxOn _ hgm.measurable (range g ∩ s) y₀ h₀\n  have : Tendsto (fun n => (G n).integral μ) atTop (𝓝 <| ∫ x, g x ∂μ) :=\n    tendsto_integral_approxOn_of_measurable hfi _ hg _ (integrable_const _)\n  refine hsc.mem_of_tendsto this (Eventually.of_forall fun n => hs.sum_mem ?_ ?_ ?_)\n  · exact fun _ _ => ENNReal.toReal_nonneg\n  · rw [← ENNReal.toReal_sum, (G n).sum_range_measure_preimage_singleton, measure_univ,\n      ENNReal.one_toReal]\n    exact fun _ _ => measure_ne_top _ _\n  · simp only [SimpleFunc.mem_range, forall_mem_range]\n    intro x\n    apply (range g).inter_subset_right\n    exact SimpleFunc.approxOn_mem hgm.measurable h₀ _ _\n\n"}
{"name":"Convex.average_mem","module":"Mathlib.Analysis.Convex.Integral","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : CompleteSpace E\nμ : MeasureTheory.Measure α\ns : Set E\nf : α → E\ninst✝¹ : MeasureTheory.IsFiniteMeasure μ\ninst✝ : NeZero μ\nhs : Convex Real s\nhsc : IsClosed s\nhfs : Filter.Eventually (fun x => Membership.mem s (f x)) (MeasureTheory.ae μ)\nhfi : MeasureTheory.Integrable f μ\n⊢ Membership.mem s (MeasureTheory.average μ fun x => f x)","decl":"/-- If `μ` is a non-zero finite measure on `α`, `s` is a convex closed set in `E`, and `f` is an\nintegrable function sending `μ`-a.e. points to `s`, then the average value of `f` belongs to `s`:\n`⨍ x, f x ∂μ ∈ s`. See also `Convex.centerMass_mem` for a finite sum version of this lemma. -/\ntheorem Convex.average_mem [IsFiniteMeasure μ] [NeZero μ] (hs : Convex ℝ s) (hsc : IsClosed s)\n    (hfs : ∀ᵐ x ∂μ, f x ∈ s) (hfi : Integrable f μ) : (⨍ x, f x ∂μ) ∈ s :=\n  hs.integral_mem hsc (ae_mono' smul_absolutelyContinuous hfs) hfi.to_average\n\n"}
{"name":"Convex.set_average_mem","module":"Mathlib.Analysis.Convex.Integral","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : CompleteSpace E\nμ : MeasureTheory.Measure α\ns : Set E\nt : Set α\nf : α → E\nhs : Convex Real s\nhsc : IsClosed s\nh0 : Ne (μ t) 0\nht : Ne (μ t) Top.top\nhfs : Filter.Eventually (fun x => Membership.mem s (f x)) (MeasureTheory.ae (μ.restrict t))\nhfi : MeasureTheory.IntegrableOn f t μ\n⊢ Membership.mem s (MeasureTheory.average (μ.restrict t) fun x => f x)","decl":"/-- If `μ` is a non-zero finite measure on `α`, `s` is a convex closed set in `E`, and `f` is an\nintegrable function sending `μ`-a.e. points to `s`, then the average value of `f` belongs to `s`:\n`⨍ x, f x ∂μ ∈ s`. See also `Convex.centerMass_mem` for a finite sum version of this lemma. -/\ntheorem Convex.set_average_mem (hs : Convex ℝ s) (hsc : IsClosed s) (h0 : μ t ≠ 0) (ht : μ t ≠ ∞)\n    (hfs : ∀ᵐ x ∂μ.restrict t, f x ∈ s) (hfi : IntegrableOn f t μ) : (⨍ x in t, f x ∂μ) ∈ s :=\n  have := Fact.mk ht.lt_top\n  have := NeZero.mk h0\n  hs.average_mem hsc hfs hfi\n\n"}
{"name":"Convex.set_average_mem_closure","module":"Mathlib.Analysis.Convex.Integral","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : CompleteSpace E\nμ : MeasureTheory.Measure α\ns : Set E\nt : Set α\nf : α → E\nhs : Convex Real s\nh0 : Ne (μ t) 0\nht : Ne (μ t) Top.top\nhfs : Filter.Eventually (fun x => Membership.mem s (f x)) (MeasureTheory.ae (μ.restrict t))\nhfi : MeasureTheory.IntegrableOn f t μ\n⊢ Membership.mem (closure s) (MeasureTheory.average (μ.restrict t) fun x => f x)","decl":"/-- If `μ` is a non-zero finite measure on `α`, `s` is a convex set in `E`, and `f` is an integrable\nfunction sending `μ`-a.e. points to `s`, then the average value of `f` belongs to `closure s`:\n`⨍ x, f x ∂μ ∈ s`. See also `Convex.centerMass_mem` for a finite sum version of this lemma. -/\ntheorem Convex.set_average_mem_closure (hs : Convex ℝ s) (h0 : μ t ≠ 0) (ht : μ t ≠ ∞)\n    (hfs : ∀ᵐ x ∂μ.restrict t, f x ∈ s) (hfi : IntegrableOn f t μ) :\n    (⨍ x in t, f x ∂μ) ∈ closure s :=\n  hs.closure.set_average_mem isClosed_closure h0 ht (hfs.mono fun _ hx => subset_closure hx) hfi\n\n"}
{"name":"ConvexOn.average_mem_epigraph","module":"Mathlib.Analysis.Convex.Integral","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : CompleteSpace E\nμ : MeasureTheory.Measure α\ns : Set E\nf : α → E\ng : E → Real\ninst✝¹ : MeasureTheory.IsFiniteMeasure μ\ninst✝ : NeZero μ\nhg : ConvexOn Real s g\nhgc : ContinuousOn g s\nhsc : IsClosed s\nhfs : Filter.Eventually (fun x => Membership.mem s (f x)) (MeasureTheory.ae μ)\nhfi : MeasureTheory.Integrable f μ\nhgi : MeasureTheory.Integrable (Function.comp g f) μ\n⊢ Membership.mem (setOf fun p => And (Membership.mem s p.1) (LE.le (g p.1) p.2)) { fst := MeasureTheory.average μ fun x => f x, snd := MeasureTheory.average μ fun x => g (f x) }","decl":"theorem ConvexOn.average_mem_epigraph [IsFiniteMeasure μ] [NeZero μ] (hg : ConvexOn ℝ s g)\n    (hgc : ContinuousOn g s) (hsc : IsClosed s) (hfs : ∀ᵐ x ∂μ, f x ∈ s)\n    (hfi : Integrable f μ) (hgi : Integrable (g ∘ f) μ) :\n    (⨍ x, f x ∂μ, ⨍ x, g (f x) ∂μ) ∈ {p : E × ℝ | p.1 ∈ s ∧ g p.1 ≤ p.2} := by\n  have ht_mem : ∀ᵐ x ∂μ, (f x, g (f x)) ∈ {p : E × ℝ | p.1 ∈ s ∧ g p.1 ≤ p.2} :=\n    hfs.mono fun x hx => ⟨hx, le_rfl⟩\n  exact average_pair hfi hgi ▸\n    hg.convex_epigraph.average_mem (hsc.epigraph hgc) ht_mem (hfi.prod_mk hgi)\n\n"}
{"name":"ConcaveOn.average_mem_hypograph","module":"Mathlib.Analysis.Convex.Integral","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : CompleteSpace E\nμ : MeasureTheory.Measure α\ns : Set E\nf : α → E\ng : E → Real\ninst✝¹ : MeasureTheory.IsFiniteMeasure μ\ninst✝ : NeZero μ\nhg : ConcaveOn Real s g\nhgc : ContinuousOn g s\nhsc : IsClosed s\nhfs : Filter.Eventually (fun x => Membership.mem s (f x)) (MeasureTheory.ae μ)\nhfi : MeasureTheory.Integrable f μ\nhgi : MeasureTheory.Integrable (Function.comp g f) μ\n⊢ Membership.mem (setOf fun p => And (Membership.mem s p.1) (LE.le p.2 (g p.1))) { fst := MeasureTheory.average μ fun x => f x, snd := MeasureTheory.average μ fun x => g (f x) }","decl":"theorem ConcaveOn.average_mem_hypograph [IsFiniteMeasure μ] [NeZero μ] (hg : ConcaveOn ℝ s g)\n    (hgc : ContinuousOn g s) (hsc : IsClosed s) (hfs : ∀ᵐ x ∂μ, f x ∈ s)\n    (hfi : Integrable f μ) (hgi : Integrable (g ∘ f) μ) :\n    (⨍ x, f x ∂μ, ⨍ x, g (f x) ∂μ) ∈ {p : E × ℝ | p.1 ∈ s ∧ p.2 ≤ g p.1} := by\n  simpa only [mem_setOf_eq, Pi.neg_apply, average_neg, neg_le_neg_iff] using\n    hg.neg.average_mem_epigraph hgc.neg hsc hfs hfi hgi.neg\n\n"}
{"name":"ConvexOn.map_average_le","module":"Mathlib.Analysis.Convex.Integral","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : CompleteSpace E\nμ : MeasureTheory.Measure α\ns : Set E\nf : α → E\ng : E → Real\ninst✝¹ : MeasureTheory.IsFiniteMeasure μ\ninst✝ : NeZero μ\nhg : ConvexOn Real s g\nhgc : ContinuousOn g s\nhsc : IsClosed s\nhfs : Filter.Eventually (fun x => Membership.mem s (f x)) (MeasureTheory.ae μ)\nhfi : MeasureTheory.Integrable f μ\nhgi : MeasureTheory.Integrable (Function.comp g f) μ\n⊢ LE.le (g (MeasureTheory.average μ fun x => f x)) (MeasureTheory.average μ fun x => g (f x))","decl":"/-- **Jensen's inequality**: if a function `g : E → ℝ` is convex and continuous on a convex closed\nset `s`, `μ` is a finite non-zero measure on `α`, and `f : α → E` is a function sending\n`μ`-a.e. points to `s`, then the value of `g` at the average value of `f` is less than or equal to\nthe average value of `g ∘ f` provided that both `f` and `g ∘ f` are integrable. See also\n`ConvexOn.map_centerMass_le` for a finite sum version of this lemma. -/\ntheorem ConvexOn.map_average_le [IsFiniteMeasure μ] [NeZero μ]\n    (hg : ConvexOn ℝ s g) (hgc : ContinuousOn g s) (hsc : IsClosed s)\n    (hfs : ∀ᵐ x ∂μ, f x ∈ s) (hfi : Integrable f μ) (hgi : Integrable (g ∘ f) μ) :\n    g (⨍ x, f x ∂μ) ≤ ⨍ x, g (f x) ∂μ :=\n  (hg.average_mem_epigraph hgc hsc hfs hfi hgi).2\n\n"}
{"name":"ConcaveOn.le_map_average","module":"Mathlib.Analysis.Convex.Integral","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : CompleteSpace E\nμ : MeasureTheory.Measure α\ns : Set E\nf : α → E\ng : E → Real\ninst✝¹ : MeasureTheory.IsFiniteMeasure μ\ninst✝ : NeZero μ\nhg : ConcaveOn Real s g\nhgc : ContinuousOn g s\nhsc : IsClosed s\nhfs : Filter.Eventually (fun x => Membership.mem s (f x)) (MeasureTheory.ae μ)\nhfi : MeasureTheory.Integrable f μ\nhgi : MeasureTheory.Integrable (Function.comp g f) μ\n⊢ LE.le (MeasureTheory.average μ fun x => g (f x)) (g (MeasureTheory.average μ fun x => f x))","decl":"/-- **Jensen's inequality**: if a function `g : E → ℝ` is concave and continuous on a convex closed\nset `s`, `μ` is a finite non-zero measure on `α`, and `f : α → E` is a function sending\n`μ`-a.e. points to `s`, then the average value of `g ∘ f` is less than or equal to the value of `g`\nat the average value of `f` provided that both `f` and `g ∘ f` are integrable. See also\n`ConcaveOn.le_map_centerMass` for a finite sum version of this lemma. -/\ntheorem ConcaveOn.le_map_average [IsFiniteMeasure μ] [NeZero μ]\n    (hg : ConcaveOn ℝ s g) (hgc : ContinuousOn g s) (hsc : IsClosed s)\n    (hfs : ∀ᵐ x ∂μ, f x ∈ s) (hfi : Integrable f μ) (hgi : Integrable (g ∘ f) μ) :\n    (⨍ x, g (f x) ∂μ) ≤ g (⨍ x, f x ∂μ) :=\n  (hg.average_mem_hypograph hgc hsc hfs hfi hgi).2\n\n"}
{"name":"ConvexOn.set_average_mem_epigraph","module":"Mathlib.Analysis.Convex.Integral","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : CompleteSpace E\nμ : MeasureTheory.Measure α\ns : Set E\nt : Set α\nf : α → E\ng : E → Real\nhg : ConvexOn Real s g\nhgc : ContinuousOn g s\nhsc : IsClosed s\nh0 : Ne (μ t) 0\nht : Ne (μ t) Top.top\nhfs : Filter.Eventually (fun x => Membership.mem s (f x)) (MeasureTheory.ae (μ.restrict t))\nhfi : MeasureTheory.IntegrableOn f t μ\nhgi : MeasureTheory.IntegrableOn (Function.comp g f) t μ\n⊢ Membership.mem (setOf fun p => And (Membership.mem s p.1) (LE.le (g p.1) p.2)) { fst := MeasureTheory.average (μ.restrict t) fun x => f x, snd := MeasureTheory.average (μ.restrict t) fun x => g (f x) }","decl":"/-- **Jensen's inequality**: if a function `g : E → ℝ` is convex and continuous on a convex closed\nset `s`, `μ` is a finite non-zero measure on `α`, and `f : α → E` is a function sending\n`μ`-a.e. points of a set `t` to `s`, then the value of `g` at the average value of `f` over `t` is\nless than or equal to the average value of `g ∘ f` over `t` provided that both `f` and `g ∘ f` are\nintegrable. -/\ntheorem ConvexOn.set_average_mem_epigraph (hg : ConvexOn ℝ s g) (hgc : ContinuousOn g s)\n    (hsc : IsClosed s) (h0 : μ t ≠ 0) (ht : μ t ≠ ∞) (hfs : ∀ᵐ x ∂μ.restrict t, f x ∈ s)\n    (hfi : IntegrableOn f t μ) (hgi : IntegrableOn (g ∘ f) t μ) :\n    (⨍ x in t, f x ∂μ, ⨍ x in t, g (f x) ∂μ) ∈ {p : E × ℝ | p.1 ∈ s ∧ g p.1 ≤ p.2} :=\n  have := Fact.mk ht.lt_top\n  have := NeZero.mk h0\n  hg.average_mem_epigraph hgc hsc hfs hfi hgi\n\n"}
{"name":"ConcaveOn.set_average_mem_hypograph","module":"Mathlib.Analysis.Convex.Integral","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : CompleteSpace E\nμ : MeasureTheory.Measure α\ns : Set E\nt : Set α\nf : α → E\ng : E → Real\nhg : ConcaveOn Real s g\nhgc : ContinuousOn g s\nhsc : IsClosed s\nh0 : Ne (μ t) 0\nht : Ne (μ t) Top.top\nhfs : Filter.Eventually (fun x => Membership.mem s (f x)) (MeasureTheory.ae (μ.restrict t))\nhfi : MeasureTheory.IntegrableOn f t μ\nhgi : MeasureTheory.IntegrableOn (Function.comp g f) t μ\n⊢ Membership.mem (setOf fun p => And (Membership.mem s p.1) (LE.le p.2 (g p.1))) { fst := MeasureTheory.average (μ.restrict t) fun x => f x, snd := MeasureTheory.average (μ.restrict t) fun x => g (f x) }","decl":"/-- **Jensen's inequality**: if a function `g : E → ℝ` is concave and continuous on a convex closed\nset `s`, `μ` is a finite non-zero measure on `α`, and `f : α → E` is a function sending\n`μ`-a.e. points of a set `t` to `s`, then the average value of `g ∘ f` over `t` is less than or\nequal to the value of `g` at the average value of `f` over `t` provided that both `f` and `g ∘ f`\nare integrable. -/\ntheorem ConcaveOn.set_average_mem_hypograph (hg : ConcaveOn ℝ s g) (hgc : ContinuousOn g s)\n    (hsc : IsClosed s) (h0 : μ t ≠ 0) (ht : μ t ≠ ∞) (hfs : ∀ᵐ x ∂μ.restrict t, f x ∈ s)\n    (hfi : IntegrableOn f t μ) (hgi : IntegrableOn (g ∘ f) t μ) :\n    (⨍ x in t, f x ∂μ, ⨍ x in t, g (f x) ∂μ) ∈ {p : E × ℝ | p.1 ∈ s ∧ p.2 ≤ g p.1} := by\n  simpa only [mem_setOf_eq, Pi.neg_apply, average_neg, neg_le_neg_iff] using\n    hg.neg.set_average_mem_epigraph hgc.neg hsc h0 ht hfs hfi hgi.neg\n\n"}
{"name":"ConvexOn.map_set_average_le","module":"Mathlib.Analysis.Convex.Integral","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : CompleteSpace E\nμ : MeasureTheory.Measure α\ns : Set E\nt : Set α\nf : α → E\ng : E → Real\nhg : ConvexOn Real s g\nhgc : ContinuousOn g s\nhsc : IsClosed s\nh0 : Ne (μ t) 0\nht : Ne (μ t) Top.top\nhfs : Filter.Eventually (fun x => Membership.mem s (f x)) (MeasureTheory.ae (μ.restrict t))\nhfi : MeasureTheory.IntegrableOn f t μ\nhgi : MeasureTheory.IntegrableOn (Function.comp g f) t μ\n⊢ LE.le (g (MeasureTheory.average (μ.restrict t) fun x => f x)) (MeasureTheory.average (μ.restrict t) fun x => g (f x))","decl":"/-- **Jensen's inequality**: if a function `g : E → ℝ` is convex and continuous on a convex closed\nset `s`, `μ` is a finite non-zero measure on `α`, and `f : α → E` is a function sending\n`μ`-a.e. points of a set `t` to `s`, then the value of `g` at the average value of `f` over `t` is\nless than or equal to the average value of `g ∘ f` over `t` provided that both `f` and `g ∘ f` are\nintegrable. -/\ntheorem ConvexOn.map_set_average_le (hg : ConvexOn ℝ s g) (hgc : ContinuousOn g s)\n    (hsc : IsClosed s) (h0 : μ t ≠ 0) (ht : μ t ≠ ∞) (hfs : ∀ᵐ x ∂μ.restrict t, f x ∈ s)\n    (hfi : IntegrableOn f t μ) (hgi : IntegrableOn (g ∘ f) t μ) :\n    g (⨍ x in t, f x ∂μ) ≤ ⨍ x in t, g (f x) ∂μ :=\n  (hg.set_average_mem_epigraph hgc hsc h0 ht hfs hfi hgi).2\n\n"}
{"name":"ConcaveOn.le_map_set_average","module":"Mathlib.Analysis.Convex.Integral","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : CompleteSpace E\nμ : MeasureTheory.Measure α\ns : Set E\nt : Set α\nf : α → E\ng : E → Real\nhg : ConcaveOn Real s g\nhgc : ContinuousOn g s\nhsc : IsClosed s\nh0 : Ne (μ t) 0\nht : Ne (μ t) Top.top\nhfs : Filter.Eventually (fun x => Membership.mem s (f x)) (MeasureTheory.ae (μ.restrict t))\nhfi : MeasureTheory.IntegrableOn f t μ\nhgi : MeasureTheory.IntegrableOn (Function.comp g f) t μ\n⊢ LE.le (MeasureTheory.average (μ.restrict t) fun x => g (f x)) (g (MeasureTheory.average (μ.restrict t) fun x => f x))","decl":"/-- **Jensen's inequality**: if a function `g : E → ℝ` is concave and continuous on a convex closed\nset `s`, `μ` is a finite non-zero measure on `α`, and `f : α → E` is a function sending\n`μ`-a.e. points of a set `t` to `s`, then the average value of `g ∘ f` over `t` is less than or\nequal to the value of `g` at the average value of `f` over `t` provided that both `f` and `g ∘ f`\nare integrable. -/\ntheorem ConcaveOn.le_map_set_average (hg : ConcaveOn ℝ s g) (hgc : ContinuousOn g s)\n    (hsc : IsClosed s) (h0 : μ t ≠ 0) (ht : μ t ≠ ∞) (hfs : ∀ᵐ x ∂μ.restrict t, f x ∈ s)\n    (hfi : IntegrableOn f t μ) (hgi : IntegrableOn (g ∘ f) t μ) :\n    (⨍ x in t, g (f x) ∂μ) ≤ g (⨍ x in t, f x ∂μ) :=\n  (hg.set_average_mem_hypograph hgc hsc h0 ht hfs hfi hgi).2\n\n"}
{"name":"ConvexOn.map_integral_le","module":"Mathlib.Analysis.Convex.Integral","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\ninst✝¹ : CompleteSpace E\nμ : MeasureTheory.Measure α\ns : Set E\nf : α → E\ng : E → Real\ninst✝ : MeasureTheory.IsProbabilityMeasure μ\nhg : ConvexOn Real s g\nhgc : ContinuousOn g s\nhsc : IsClosed s\nhfs : Filter.Eventually (fun x => Membership.mem s (f x)) (MeasureTheory.ae μ)\nhfi : MeasureTheory.Integrable f μ\nhgi : MeasureTheory.Integrable (Function.comp g f) μ\n⊢ LE.le (g (MeasureTheory.integral μ fun x => f x)) (MeasureTheory.integral μ fun x => g (f x))","decl":"/-- **Jensen's inequality**: if a function `g : E → ℝ` is convex and continuous on a convex closed\nset `s`, `μ` is a probability measure on `α`, and `f : α → E` is a function sending `μ`-a.e.  points\nto `s`, then the value of `g` at the expected value of `f` is less than or equal to the expected\nvalue of `g ∘ f` provided that both `f` and `g ∘ f` are integrable. See also\n`ConvexOn.map_centerMass_le` for a finite sum version of this lemma. -/\ntheorem ConvexOn.map_integral_le [IsProbabilityMeasure μ] (hg : ConvexOn ℝ s g)\n    (hgc : ContinuousOn g s) (hsc : IsClosed s) (hfs : ∀ᵐ x ∂μ, f x ∈ s) (hfi : Integrable f μ)\n    (hgi : Integrable (g ∘ f) μ) : g (∫ x, f x ∂μ) ≤ ∫ x, g (f x) ∂μ := by\n  simpa only [average_eq_integral] using hg.map_average_le hgc hsc hfs hfi hgi\n\n"}
{"name":"ConcaveOn.le_map_integral","module":"Mathlib.Analysis.Convex.Integral","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\ninst✝¹ : CompleteSpace E\nμ : MeasureTheory.Measure α\ns : Set E\nf : α → E\ng : E → Real\ninst✝ : MeasureTheory.IsProbabilityMeasure μ\nhg : ConcaveOn Real s g\nhgc : ContinuousOn g s\nhsc : IsClosed s\nhfs : Filter.Eventually (fun x => Membership.mem s (f x)) (MeasureTheory.ae μ)\nhfi : MeasureTheory.Integrable f μ\nhgi : MeasureTheory.Integrable (Function.comp g f) μ\n⊢ LE.le (MeasureTheory.integral μ fun x => g (f x)) (g (MeasureTheory.integral μ fun x => f x))","decl":"/-- **Jensen's inequality**: if a function `g : E → ℝ` is concave and continuous on a convex closed\nset `s`, `μ` is a probability measure on `α`, and `f : α → E` is a function sending `μ`-a.e.  points\nto `s`, then the expected value of `g ∘ f` is less than or equal to the value of `g` at the expected\nvalue of `f` provided that both `f` and `g ∘ f` are integrable. -/\ntheorem ConcaveOn.le_map_integral [IsProbabilityMeasure μ] (hg : ConcaveOn ℝ s g)\n    (hgc : ContinuousOn g s) (hsc : IsClosed s) (hfs : ∀ᵐ x ∂μ, f x ∈ s) (hfi : Integrable f μ)\n    (hgi : Integrable (g ∘ f) μ) : (∫ x, g (f x) ∂μ) ≤ g (∫ x, f x ∂μ) := by\n  simpa only [average_eq_integral] using hg.le_map_average hgc hsc hfs hfi hgi\n\n"}
{"name":"ae_eq_const_or_exists_average_ne_compl","module":"Mathlib.Analysis.Convex.Integral","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\ninst✝¹ : CompleteSpace E\nμ : MeasureTheory.Measure α\nf : α → E\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhfi : MeasureTheory.Integrable f μ\n⊢ Or ((MeasureTheory.ae μ).EventuallyEq f (Function.const α (MeasureTheory.average μ fun x => f x))) (Exists fun t => And (MeasurableSet t) (And (Ne (μ t) 0) (And (Ne (μ (HasCompl.compl t)) 0) (Ne (MeasureTheory.average (μ.restrict t) fun x => f x) (MeasureTheory.average (μ.restrict (HasCompl.compl t)) fun x => f x)))))","decl":"/-- If `f : α → E` is an integrable function, then either it is a.e. equal to the constant\n`⨍ x, f x ∂μ` or there exists a measurable set such that `μ t ≠ 0`, `μ tᶜ ≠ 0`, and the average\nvalues of `f` over `t` and `tᶜ` are different. -/\ntheorem ae_eq_const_or_exists_average_ne_compl [IsFiniteMeasure μ] (hfi : Integrable f μ) :\n    f =ᵐ[μ] const α (⨍ x, f x ∂μ) ∨\n      ∃ t, MeasurableSet t ∧ μ t ≠ 0 ∧ μ tᶜ ≠ 0 ∧ (⨍ x in t, f x ∂μ) ≠ ⨍ x in tᶜ, f x ∂μ := by\n  refine or_iff_not_imp_right.mpr fun H => ?_; push_neg at H\n  refine hfi.ae_eq_of_forall_setIntegral_eq _ _ (integrable_const _) fun t ht ht' => ?_; clear ht'\n  simp only [const_apply, setIntegral_const]\n  by_cases h₀ : μ t = 0\n  · rw [restrict_eq_zero.2 h₀, integral_zero_measure, h₀, ENNReal.zero_toReal, zero_smul]\n  by_cases h₀' : μ tᶜ = 0\n  · rw [← ae_eq_univ] at h₀'\n    rw [restrict_congr_set h₀', restrict_univ, measure_congr h₀', measure_smul_average]\n  have := average_mem_openSegment_compl_self ht.nullMeasurableSet h₀ h₀' hfi\n  rw [← H t ht h₀ h₀', openSegment_same, mem_singleton_iff] at this\n  rw [this, measure_smul_setAverage _ (measure_ne_top μ _)]\n\n"}
{"name":"Convex.average_mem_interior_of_set","module":"Mathlib.Analysis.Convex.Integral","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\ninst✝¹ : CompleteSpace E\nμ : MeasureTheory.Measure α\ns : Set E\nt : Set α\nf : α → E\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhs : Convex Real s\nh0 : Ne (μ t) 0\nhfs : Filter.Eventually (fun x => Membership.mem s (f x)) (MeasureTheory.ae μ)\nhfi : MeasureTheory.Integrable f μ\nht : Membership.mem (interior s) (MeasureTheory.average (μ.restrict t) fun x => f x)\n⊢ Membership.mem (interior s) (MeasureTheory.average μ fun x => f x)","decl":"/-- If an integrable function `f : α → E` takes values in a convex set `s` and for some set `t` of\npositive measure, the average value of `f` over `t` belongs to the interior of `s`, then the average\nof `f` over the whole space belongs to the interior of `s`. -/\ntheorem Convex.average_mem_interior_of_set [IsFiniteMeasure μ] (hs : Convex ℝ s) (h0 : μ t ≠ 0)\n    (hfs : ∀ᵐ x ∂μ, f x ∈ s) (hfi : Integrable f μ) (ht : (⨍ x in t, f x ∂μ) ∈ interior s) :\n    (⨍ x, f x ∂μ) ∈ interior s := by\n  rw [← measure_toMeasurable] at h0; rw [← restrict_toMeasurable (measure_ne_top μ t)] at ht\n  by_cases h0' : μ (toMeasurable μ t)ᶜ = 0\n  · rw [← ae_eq_univ] at h0'\n    rwa [restrict_congr_set h0', restrict_univ] at ht\n  exact\n    hs.openSegment_interior_closure_subset_interior ht\n      (hs.set_average_mem_closure h0' (measure_ne_top _ _) (ae_restrict_of_ae hfs)\n        hfi.integrableOn)\n      (average_mem_openSegment_compl_self (measurableSet_toMeasurable μ t).nullMeasurableSet h0\n        h0' hfi)\n\n"}
{"name":"StrictConvex.ae_eq_const_or_average_mem_interior","module":"Mathlib.Analysis.Convex.Integral","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\ninst✝¹ : CompleteSpace E\nμ : MeasureTheory.Measure α\ns : Set E\nf : α → E\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhs : StrictConvex Real s\nhsc : IsClosed s\nhfs : Filter.Eventually (fun x => Membership.mem s (f x)) (MeasureTheory.ae μ)\nhfi : MeasureTheory.Integrable f μ\n⊢ Or ((MeasureTheory.ae μ).EventuallyEq f (Function.const α (MeasureTheory.average μ fun x => f x))) (Membership.mem (interior s) (MeasureTheory.average μ fun x => f x))","decl":"/-- If an integrable function `f : α → E` takes values in a strictly convex closed set `s`, then\neither it is a.e. equal to its average value, or its average value belongs to the interior of\n`s`. -/\ntheorem StrictConvex.ae_eq_const_or_average_mem_interior [IsFiniteMeasure μ] (hs : StrictConvex ℝ s)\n    (hsc : IsClosed s) (hfs : ∀ᵐ x ∂μ, f x ∈ s) (hfi : Integrable f μ) :\n    f =ᵐ[μ] const α (⨍ x, f x ∂μ) ∨ (⨍ x, f x ∂μ) ∈ interior s := by\n  have : ∀ {t}, μ t ≠ 0 → (⨍ x in t, f x ∂μ) ∈ s := fun ht =>\n    hs.convex.set_average_mem hsc ht (measure_ne_top _ _) (ae_restrict_of_ae hfs) hfi.integrableOn\n  refine (ae_eq_const_or_exists_average_ne_compl hfi).imp_right ?_\n  rintro ⟨t, hm, h₀, h₀', hne⟩\n  exact\n    hs.openSegment_subset (this h₀) (this h₀') hne\n      (average_mem_openSegment_compl_self hm.nullMeasurableSet h₀ h₀' hfi)\n\n"}
{"name":"StrictConvexOn.ae_eq_const_or_map_average_lt","module":"Mathlib.Analysis.Convex.Integral","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\ninst✝¹ : CompleteSpace E\nμ : MeasureTheory.Measure α\ns : Set E\nf : α → E\ng : E → Real\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhg : StrictConvexOn Real s g\nhgc : ContinuousOn g s\nhsc : IsClosed s\nhfs : Filter.Eventually (fun x => Membership.mem s (f x)) (MeasureTheory.ae μ)\nhfi : MeasureTheory.Integrable f μ\nhgi : MeasureTheory.Integrable (Function.comp g f) μ\n⊢ Or ((MeasureTheory.ae μ).EventuallyEq f (Function.const α (MeasureTheory.average μ fun x => f x))) (LT.lt (g (MeasureTheory.average μ fun x => f x)) (MeasureTheory.average μ fun x => g (f x)))","decl":"/-- **Jensen's inequality**, strict version: if an integrable function `f : α → E` takes values in a\nconvex closed set `s`, and `g : E → ℝ` is continuous and strictly convex on `s`, then\neither `f` is a.e. equal to its average value, or `g (⨍ x, f x ∂μ) < ⨍ x, g (f x) ∂μ`. -/\ntheorem StrictConvexOn.ae_eq_const_or_map_average_lt [IsFiniteMeasure μ] (hg : StrictConvexOn ℝ s g)\n    (hgc : ContinuousOn g s) (hsc : IsClosed s) (hfs : ∀ᵐ x ∂μ, f x ∈ s) (hfi : Integrable f μ)\n    (hgi : Integrable (g ∘ f) μ) :\n    f =ᵐ[μ] const α (⨍ x, f x ∂μ) ∨ g (⨍ x, f x ∂μ) < ⨍ x, g (f x) ∂μ := by\n  have : ∀ {t}, μ t ≠ 0 → (⨍ x in t, f x ∂μ) ∈ s ∧ g (⨍ x in t, f x ∂μ) ≤ ⨍ x in t, g (f x) ∂μ :=\n    fun ht =>\n    hg.convexOn.set_average_mem_epigraph hgc hsc ht (measure_ne_top _ _) (ae_restrict_of_ae hfs)\n      hfi.integrableOn hgi.integrableOn\n  refine (ae_eq_const_or_exists_average_ne_compl hfi).imp_right ?_\n  rintro ⟨t, hm, h₀, h₀', hne⟩\n  rcases average_mem_openSegment_compl_self hm.nullMeasurableSet h₀ h₀' (hfi.prod_mk hgi) with\n    ⟨a, b, ha, hb, hab, h_avg⟩\n  rw [average_pair hfi hgi, average_pair hfi.integrableOn hgi.integrableOn,\n    average_pair hfi.integrableOn hgi.integrableOn, Prod.smul_mk,\n    Prod.smul_mk, Prod.mk_add_mk, Prod.mk.inj_iff] at h_avg\n  simp only [Function.comp] at h_avg\n  rw [← h_avg.1, ← h_avg.2]\n  calc\n    g ((a • ⨍ x in t, f x ∂μ) + b • ⨍ x in tᶜ, f x ∂μ) <\n        a * g (⨍ x in t, f x ∂μ) + b * g (⨍ x in tᶜ, f x ∂μ) :=\n      hg.2 (this h₀).1 (this h₀').1 hne ha hb hab\n    _ ≤ (a * ⨍ x in t, g (f x) ∂μ) + b * ⨍ x in tᶜ, g (f x) ∂μ :=\n      add_le_add (mul_le_mul_of_nonneg_left (this h₀).2 ha.le)\n        (mul_le_mul_of_nonneg_left (this h₀').2 hb.le)\n\n"}
{"name":"StrictConcaveOn.ae_eq_const_or_lt_map_average","module":"Mathlib.Analysis.Convex.Integral","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\ninst✝¹ : CompleteSpace E\nμ : MeasureTheory.Measure α\ns : Set E\nf : α → E\ng : E → Real\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhg : StrictConcaveOn Real s g\nhgc : ContinuousOn g s\nhsc : IsClosed s\nhfs : Filter.Eventually (fun x => Membership.mem s (f x)) (MeasureTheory.ae μ)\nhfi : MeasureTheory.Integrable f μ\nhgi : MeasureTheory.Integrable (Function.comp g f) μ\n⊢ Or ((MeasureTheory.ae μ).EventuallyEq f (Function.const α (MeasureTheory.average μ fun x => f x))) (LT.lt (MeasureTheory.average μ fun x => g (f x)) (g (MeasureTheory.average μ fun x => f x)))","decl":"/-- **Jensen's inequality**, strict version: if an integrable function `f : α → E` takes values in a\nconvex closed set `s`, and `g : E → ℝ` is continuous and strictly concave on `s`, then\neither `f` is a.e. equal to its average value, or `⨍ x, g (f x) ∂μ < g (⨍ x, f x ∂μ)`. -/\ntheorem StrictConcaveOn.ae_eq_const_or_lt_map_average [IsFiniteMeasure μ]\n    (hg : StrictConcaveOn ℝ s g) (hgc : ContinuousOn g s) (hsc : IsClosed s)\n    (hfs : ∀ᵐ x ∂μ, f x ∈ s) (hfi : Integrable f μ) (hgi : Integrable (g ∘ f) μ) :\n    f =ᵐ[μ] const α (⨍ x, f x ∂μ) ∨ (⨍ x, g (f x) ∂μ) < g (⨍ x, f x ∂μ) := by\n  simpa only [Pi.neg_apply, average_neg, neg_lt_neg_iff] using\n    hg.neg.ae_eq_const_or_map_average_lt hgc.neg hsc hfs hfi hgi.neg\n\n"}
{"name":"ae_eq_const_or_norm_average_lt_of_norm_le_const","module":"Mathlib.Analysis.Convex.Integral","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\ninst✝¹ : CompleteSpace E\nμ : MeasureTheory.Measure α\nf : α → E\nC : Real\ninst✝ : StrictConvexSpace Real E\nh_le : Filter.Eventually (fun x => LE.le (Norm.norm (f x)) C) (MeasureTheory.ae μ)\n⊢ Or ((MeasureTheory.ae μ).EventuallyEq f (Function.const α (MeasureTheory.average μ fun x => f x))) (LT.lt (Norm.norm (MeasureTheory.average μ fun x => f x)) C)","decl":"/-- If `E` is a strictly convex normed space and `f : α → E` is a function such that `‖f x‖ ≤ C`\na.e., then either this function is a.e. equal to its average value, or the norm of its average value\nis strictly less than `C`. -/\ntheorem ae_eq_const_or_norm_average_lt_of_norm_le_const [StrictConvexSpace ℝ E]\n    (h_le : ∀ᵐ x ∂μ, ‖f x‖ ≤ C) : f =ᵐ[μ] const α (⨍ x, f x ∂μ) ∨ ‖⨍ x, f x ∂μ‖ < C := by\n  rcases le_or_lt C 0 with hC0 | hC0\n  · have : f =ᵐ[μ] 0 := h_le.mono fun x hx => norm_le_zero_iff.1 (hx.trans hC0)\n    simp only [average_congr this, Pi.zero_apply, average_zero]\n    exact Or.inl this\n  by_cases hfi : Integrable f μ; swap\n  · simp [average_eq, integral_undef hfi, hC0, ENNReal.toReal_pos_iff]\n  rcases (le_top : μ univ ≤ ∞).eq_or_lt with hμt | hμt; · simp [average_eq, hμt, hC0]\n  haveI : IsFiniteMeasure μ := ⟨hμt⟩\n  replace h_le : ∀ᵐ x ∂μ, f x ∈ closedBall (0 : E) C := by simpa only [mem_closedBall_zero_iff]\n  simpa only [interior_closedBall _ hC0.ne', mem_ball_zero_iff] using\n    (strictConvex_closedBall ℝ (0 : E) C).ae_eq_const_or_average_mem_interior isClosed_ball h_le\n      hfi\n\n"}
{"name":"ae_eq_const_or_norm_integral_lt_of_norm_le_const","module":"Mathlib.Analysis.Convex.Integral","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : CompleteSpace E\nμ : MeasureTheory.Measure α\nf : α → E\nC : Real\ninst✝¹ : StrictConvexSpace Real E\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nh_le : Filter.Eventually (fun x => LE.le (Norm.norm (f x)) C) (MeasureTheory.ae μ)\n⊢ Or ((MeasureTheory.ae μ).EventuallyEq f (Function.const α (MeasureTheory.average μ fun x => f x))) (LT.lt (Norm.norm (MeasureTheory.integral μ fun x => f x)) (HMul.hMul (μ Set.univ).toReal C))","decl":"/-- If `E` is a strictly convex normed space and `f : α → E` is a function such that `‖f x‖ ≤ C`\na.e., then either this function is a.e. equal to its average value, or the norm of its integral is\nstrictly less than `(μ univ).toReal * C`. -/\ntheorem ae_eq_const_or_norm_integral_lt_of_norm_le_const [StrictConvexSpace ℝ E] [IsFiniteMeasure μ]\n    (h_le : ∀ᵐ x ∂μ, ‖f x‖ ≤ C) :\n    f =ᵐ[μ] const α (⨍ x, f x ∂μ) ∨ ‖∫ x, f x ∂μ‖ < (μ univ).toReal * C := by\n  rcases eq_or_ne μ 0 with h₀ | h₀; · left; simp [h₀, EventuallyEq]\n  have hμ : 0 < (μ univ).toReal := by\n    simp [ENNReal.toReal_pos_iff, pos_iff_ne_zero, h₀, measure_lt_top]\n  refine (ae_eq_const_or_norm_average_lt_of_norm_le_const h_le).imp_right fun H => ?_\n  rwa [average_eq, norm_smul, norm_inv, Real.norm_eq_abs, abs_of_pos hμ, ← div_eq_inv_mul,\n    div_lt_iff₀' hμ] at H\n\n"}
{"name":"ae_eq_const_or_norm_setIntegral_lt_of_norm_le_const","module":"Mathlib.Analysis.Convex.Integral","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\ninst✝¹ : CompleteSpace E\nμ : MeasureTheory.Measure α\nt : Set α\nf : α → E\nC : Real\ninst✝ : StrictConvexSpace Real E\nht : Ne (μ t) Top.top\nh_le : Filter.Eventually (fun x => LE.le (Norm.norm (f x)) C) (MeasureTheory.ae (μ.restrict t))\n⊢ Or ((MeasureTheory.ae (μ.restrict t)).EventuallyEq f (Function.const α (MeasureTheory.average (μ.restrict t) fun x => f x))) (LT.lt (Norm.norm (MeasureTheory.integral (μ.restrict t) fun x => f x)) (HMul.hMul (μ t).toReal C))","decl":"/-- If `E` is a strictly convex normed space and `f : α → E` is a function such that `‖f x‖ ≤ C`\na.e. on a set `t` of finite measure, then either this function is a.e. equal to its average value on\n`t`, or the norm of its integral over `t` is strictly less than `(μ t).toReal * C`. -/\ntheorem ae_eq_const_or_norm_setIntegral_lt_of_norm_le_const [StrictConvexSpace ℝ E] (ht : μ t ≠ ∞)\n    (h_le : ∀ᵐ x ∂μ.restrict t, ‖f x‖ ≤ C) :\n    f =ᵐ[μ.restrict t] const α (⨍ x in t, f x ∂μ) ∨ ‖∫ x in t, f x ∂μ‖ < (μ t).toReal * C := by\n  haveI := Fact.mk ht.lt_top\n  rw [← restrict_apply_univ]\n  exact ae_eq_const_or_norm_integral_lt_of_norm_le_const h_le\n"}
