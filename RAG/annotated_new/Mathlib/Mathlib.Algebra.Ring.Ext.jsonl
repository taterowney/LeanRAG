{"name":"Distrib.ext","module":"Mathlib.Algebra.Ring.Ext","initialProofState":"R : Type u\ninst₁ inst₂ : Distrib R\nh_add : Eq HAdd.hAdd HAdd.hAdd\nh_mul : Eq HMul.hMul HMul.hMul\n⊢ Eq inst₁ inst₂","decl":"@[ext] theorem ext ⦃inst₁ inst₂ : Distrib R⦄\n    (h_add : local_hAdd[R, inst₁] = local_hAdd[R, inst₂])\n    (h_mul : local_hMul[R, inst₁] = local_hMul[R, inst₂]) :\n    inst₁ = inst₂ := by\n  -- Split into `add` and `mul` functions and properties.\n  rcases inst₁ with @⟨⟨⟩, ⟨⟩⟩\n  rcases inst₂ with @⟨⟨⟩, ⟨⟩⟩\n  -- Prove equality of parts using function extensionality.\n  congr\n\n"}
{"name":"Distrib.ext_iff","module":"Mathlib.Algebra.Ring.Ext","initialProofState":"R : Type u\ninst₁ inst₂ : Distrib R\n⊢ Iff (Eq inst₁ inst₂) (And (Eq HAdd.hAdd HAdd.hAdd) (Eq HMul.hMul HMul.hMul))","decl":"@[ext] theorem ext ⦃inst₁ inst₂ : Distrib R⦄\n    (h_add : local_hAdd[R, inst₁] = local_hAdd[R, inst₂])\n    (h_mul : local_hMul[R, inst₁] = local_hMul[R, inst₂]) :\n    inst₁ = inst₂ := by\n  -- Split into `add` and `mul` functions and properties.\n  rcases inst₁ with @⟨⟨⟩, ⟨⟩⟩\n  rcases inst₂ with @⟨⟨⟩, ⟨⟩⟩\n  -- Prove equality of parts using function extensionality.\n  congr\n\n"}
{"name":"NonUnitalNonAssocSemiring.ext_iff","module":"Mathlib.Algebra.Ring.Ext","initialProofState":"R : Type u\ninst₁ inst₂ : NonUnitalNonAssocSemiring R\n⊢ Iff (Eq inst₁ inst₂) (And (Eq HAdd.hAdd HAdd.hAdd) (Eq HMul.hMul HMul.hMul))","decl":"@[ext] theorem ext ⦃inst₁ inst₂ : NonUnitalNonAssocSemiring R⦄\n    (h_add : local_hAdd[R, inst₁] = local_hAdd[R, inst₂])\n    (h_mul : local_hMul[R, inst₁] = local_hMul[R, inst₂]) :\n    inst₁ = inst₂ := by\n  -- Split into `AddMonoid` instance, `mul` function and properties.\n  rcases inst₁ with @⟨_, ⟨⟩⟩\n  rcases inst₂ with @⟨_, ⟨⟩⟩\n  -- Prove equality of parts using already-proved extensionality lemmas.\n  congr; ext : 1; assumption\n\n"}
{"name":"NonUnitalNonAssocSemiring.ext","module":"Mathlib.Algebra.Ring.Ext","initialProofState":"R : Type u\ninst₁ inst₂ : NonUnitalNonAssocSemiring R\nh_add : Eq HAdd.hAdd HAdd.hAdd\nh_mul : Eq HMul.hMul HMul.hMul\n⊢ Eq inst₁ inst₂","decl":"@[ext] theorem ext ⦃inst₁ inst₂ : NonUnitalNonAssocSemiring R⦄\n    (h_add : local_hAdd[R, inst₁] = local_hAdd[R, inst₂])\n    (h_mul : local_hMul[R, inst₁] = local_hMul[R, inst₂]) :\n    inst₁ = inst₂ := by\n  -- Split into `AddMonoid` instance, `mul` function and properties.\n  rcases inst₁ with @⟨_, ⟨⟩⟩\n  rcases inst₂ with @⟨_, ⟨⟩⟩\n  -- Prove equality of parts using already-proved extensionality lemmas.\n  congr; ext : 1; assumption\n\n"}
{"name":"NonUnitalNonAssocSemiring.toDistrib_injective","module":"Mathlib.Algebra.Ring.Ext","initialProofState":"R : Type u\n⊢ Function.Injective (@NonUnitalNonAssocSemiring.toDistrib R)","decl":"theorem toDistrib_injective : Function.Injective (@toDistrib R) := by\n  intro _ _ h\n  ext x y\n  · exact congrArg (·.toAdd.add x y) h\n  · exact congrArg (·.toMul.mul x y) h\n\n"}
{"name":"NonUnitalSemiring.toNonUnitalNonAssocSemiring_injective","module":"Mathlib.Algebra.Ring.Ext","initialProofState":"R : Type u\n⊢ Function.Injective (@NonUnitalSemiring.toNonUnitalNonAssocSemiring R)","decl":"theorem toNonUnitalNonAssocSemiring_injective :\n    Function.Injective (@toNonUnitalNonAssocSemiring R) := by\n  rintro ⟨⟩ ⟨⟩ _; congr\n\n"}
{"name":"NonUnitalSemiring.ext_iff","module":"Mathlib.Algebra.Ring.Ext","initialProofState":"R : Type u\ninst₁ inst₂ : NonUnitalSemiring R\n⊢ Iff (Eq inst₁ inst₂) (And (Eq HAdd.hAdd HAdd.hAdd) (Eq HMul.hMul HMul.hMul))","decl":"@[ext] theorem ext ⦃inst₁ inst₂ : NonUnitalSemiring R⦄\n    (h_add : local_hAdd[R, inst₁] = local_hAdd[R, inst₂])\n    (h_mul : local_hMul[R, inst₁] = local_hMul[R, inst₂]) :\n    inst₁ = inst₂ :=\n  toNonUnitalNonAssocSemiring_injective <|\n    NonUnitalNonAssocSemiring.ext h_add h_mul\n\n"}
{"name":"NonUnitalSemiring.ext","module":"Mathlib.Algebra.Ring.Ext","initialProofState":"R : Type u\ninst₁ inst₂ : NonUnitalSemiring R\nh_add : Eq HAdd.hAdd HAdd.hAdd\nh_mul : Eq HMul.hMul HMul.hMul\n⊢ Eq inst₁ inst₂","decl":"@[ext] theorem ext ⦃inst₁ inst₂ : NonUnitalSemiring R⦄\n    (h_add : local_hAdd[R, inst₁] = local_hAdd[R, inst₂])\n    (h_mul : local_hMul[R, inst₁] = local_hMul[R, inst₂]) :\n    inst₁ = inst₂ :=\n  toNonUnitalNonAssocSemiring_injective <|\n    NonUnitalNonAssocSemiring.ext h_add h_mul\n\n"}
{"name":"AddMonoidWithOne.ext_iff","module":"Mathlib.Algebra.Ring.Ext","initialProofState":"R : Type u\ninst₁ inst₂ : AddMonoidWithOne R\n⊢ Iff (Eq inst₁ inst₂) (And (Eq HAdd.hAdd HAdd.hAdd) (Eq One.one One.one))","decl":"@[ext] theorem AddMonoidWithOne.ext ⦃inst₁ inst₂ : AddMonoidWithOne R⦄\n    (h_add : local_hAdd[R, inst₁] = local_hAdd[R, inst₂])\n    (h_one : (letI := inst₁; One.one : R) = (letI := inst₂; One.one : R)) :\n    inst₁ = inst₂ := by\n  have h_monoid : inst₁.toAddMonoid = inst₂.toAddMonoid := by ext : 1; exact h_add\n  have h_zero' : inst₁.toZero = inst₂.toZero := congrArg (·.toZero) h_monoid\n  have h_one' : inst₁.toOne = inst₂.toOne :=\n    congrArg One.mk h_one\n  have h_natCast : inst₁.toNatCast.natCast = inst₂.toNatCast.natCast := by\n    funext n; induction n with\n    | zero     => rewrite [inst₁.natCast_zero, inst₂.natCast_zero]\n                  exact congrArg (@Zero.zero R) h_zero'\n    | succ n h => rw [inst₁.natCast_succ, inst₂.natCast_succ, h_add]\n                  exact congrArg₂ _ h h_one\n  rcases inst₁ with @⟨⟨⟩⟩; rcases inst₂ with @⟨⟨⟩⟩\n  congr\n\n"}
{"name":"AddMonoidWithOne.ext","module":"Mathlib.Algebra.Ring.Ext","initialProofState":"R : Type u\ninst₁ inst₂ : AddMonoidWithOne R\nh_add : Eq HAdd.hAdd HAdd.hAdd\nh_one : Eq One.one One.one\n⊢ Eq inst₁ inst₂","decl":"@[ext] theorem AddMonoidWithOne.ext ⦃inst₁ inst₂ : AddMonoidWithOne R⦄\n    (h_add : local_hAdd[R, inst₁] = local_hAdd[R, inst₂])\n    (h_one : (letI := inst₁; One.one : R) = (letI := inst₂; One.one : R)) :\n    inst₁ = inst₂ := by\n  have h_monoid : inst₁.toAddMonoid = inst₂.toAddMonoid := by ext : 1; exact h_add\n  have h_zero' : inst₁.toZero = inst₂.toZero := congrArg (·.toZero) h_monoid\n  have h_one' : inst₁.toOne = inst₂.toOne :=\n    congrArg One.mk h_one\n  have h_natCast : inst₁.toNatCast.natCast = inst₂.toNatCast.natCast := by\n    funext n; induction n with\n    | zero     => rewrite [inst₁.natCast_zero, inst₂.natCast_zero]\n                  exact congrArg (@Zero.zero R) h_zero'\n    | succ n h => rw [inst₁.natCast_succ, inst₂.natCast_succ, h_add]\n                  exact congrArg₂ _ h h_one\n  rcases inst₁ with @⟨⟨⟩⟩; rcases inst₂ with @⟨⟨⟩⟩\n  congr\n\n"}
{"name":"AddCommMonoidWithOne.toAddMonoidWithOne_injective","module":"Mathlib.Algebra.Ring.Ext","initialProofState":"R : Type u\n⊢ Function.Injective (@AddCommMonoidWithOne.toAddMonoidWithOne R)","decl":"theorem AddCommMonoidWithOne.toAddMonoidWithOne_injective :\n    Function.Injective (@AddCommMonoidWithOne.toAddMonoidWithOne R) := by\n  rintro ⟨⟩ ⟨⟩ _; congr\n\n"}
{"name":"AddCommMonoidWithOne.ext","module":"Mathlib.Algebra.Ring.Ext","initialProofState":"R : Type u\ninst₁ inst₂ : AddCommMonoidWithOne R\nh_add : Eq HAdd.hAdd HAdd.hAdd\nh_one : Eq One.one One.one\n⊢ Eq inst₁ inst₂","decl":"@[ext] theorem AddCommMonoidWithOne.ext ⦃inst₁ inst₂ : AddCommMonoidWithOne R⦄\n    (h_add : local_hAdd[R, inst₁] = local_hAdd[R, inst₂])\n    (h_one : (letI := inst₁; One.one : R) = (letI := inst₂; One.one : R)) :\n    inst₁ = inst₂ :=\n  AddCommMonoidWithOne.toAddMonoidWithOne_injective <|\n    AddMonoidWithOne.ext h_add h_one\n\n"}
{"name":"AddCommMonoidWithOne.ext_iff","module":"Mathlib.Algebra.Ring.Ext","initialProofState":"R : Type u\ninst₁ inst₂ : AddCommMonoidWithOne R\n⊢ Iff (Eq inst₁ inst₂) (And (Eq HAdd.hAdd HAdd.hAdd) (Eq One.one One.one))","decl":"@[ext] theorem AddCommMonoidWithOne.ext ⦃inst₁ inst₂ : AddCommMonoidWithOne R⦄\n    (h_add : local_hAdd[R, inst₁] = local_hAdd[R, inst₂])\n    (h_one : (letI := inst₁; One.one : R) = (letI := inst₂; One.one : R)) :\n    inst₁ = inst₂ :=\n  AddCommMonoidWithOne.toAddMonoidWithOne_injective <|\n    AddMonoidWithOne.ext h_add h_one\n\n"}
{"name":"NonAssocSemiring.ext","module":"Mathlib.Algebra.Ring.Ext","initialProofState":"R : Type u\ninst₁ inst₂ : NonAssocSemiring R\nh_add : Eq HAdd.hAdd HAdd.hAdd\nh_mul : Eq HMul.hMul HMul.hMul\n⊢ Eq inst₁ inst₂","decl":"@[ext] theorem ext ⦃inst₁ inst₂ : NonAssocSemiring R⦄\n    (h_add : local_hAdd[R, inst₁] = local_hAdd[R, inst₂])\n    (h_mul : local_hMul[R, inst₁] = local_hMul[R, inst₂]) :\n    inst₁ = inst₂ := by\n  have h : inst₁.toNonUnitalNonAssocSemiring = inst₂.toNonUnitalNonAssocSemiring := by\n    ext : 1 <;> assumption\n  have h_zero : (inst₁.toMulZeroClass).toZero.zero = (inst₂.toMulZeroClass).toZero.zero :=\n    congrArg (fun inst => (inst.toMulZeroClass).toZero.zero) h\n  have h_one' : (inst₁.toMulZeroOneClass).toMulOneClass.toOne\n                = (inst₂.toMulZeroOneClass).toMulOneClass.toOne :=\n    congrArg (@MulOneClass.toOne R) <| by ext : 1; exact h_mul\n  have h_one : (inst₁.toMulZeroOneClass).toMulOneClass.toOne.one\n               = (inst₂.toMulZeroOneClass).toMulOneClass.toOne.one :=\n    congrArg (@One.one R) h_one'\n  have : inst₁.toAddCommMonoidWithOne = inst₂.toAddCommMonoidWithOne := by\n    ext : 1 <;> assumption\n  have : inst₁.toNatCast = inst₂.toNatCast :=\n    congrArg (·.toNatCast) this\n  -- Split into `NonUnitalNonAssocSemiring`, `One` and `natCast` instances.\n  cases inst₁; cases inst₂\n  congr\n\n"}
{"name":"NonAssocSemiring.ext_iff","module":"Mathlib.Algebra.Ring.Ext","initialProofState":"R : Type u\ninst₁ inst₂ : NonAssocSemiring R\n⊢ Iff (Eq inst₁ inst₂) (And (Eq HAdd.hAdd HAdd.hAdd) (Eq HMul.hMul HMul.hMul))","decl":"@[ext] theorem ext ⦃inst₁ inst₂ : NonAssocSemiring R⦄\n    (h_add : local_hAdd[R, inst₁] = local_hAdd[R, inst₂])\n    (h_mul : local_hMul[R, inst₁] = local_hMul[R, inst₂]) :\n    inst₁ = inst₂ := by\n  have h : inst₁.toNonUnitalNonAssocSemiring = inst₂.toNonUnitalNonAssocSemiring := by\n    ext : 1 <;> assumption\n  have h_zero : (inst₁.toMulZeroClass).toZero.zero = (inst₂.toMulZeroClass).toZero.zero :=\n    congrArg (fun inst => (inst.toMulZeroClass).toZero.zero) h\n  have h_one' : (inst₁.toMulZeroOneClass).toMulOneClass.toOne\n                = (inst₂.toMulZeroOneClass).toMulOneClass.toOne :=\n    congrArg (@MulOneClass.toOne R) <| by ext : 1; exact h_mul\n  have h_one : (inst₁.toMulZeroOneClass).toMulOneClass.toOne.one\n               = (inst₂.toMulZeroOneClass).toMulOneClass.toOne.one :=\n    congrArg (@One.one R) h_one'\n  have : inst₁.toAddCommMonoidWithOne = inst₂.toAddCommMonoidWithOne := by\n    ext : 1 <;> assumption\n  have : inst₁.toNatCast = inst₂.toNatCast :=\n    congrArg (·.toNatCast) this\n  -- Split into `NonUnitalNonAssocSemiring`, `One` and `natCast` instances.\n  cases inst₁; cases inst₂\n  congr\n\n"}
{"name":"NonAssocSemiring.toNonUnitalNonAssocSemiring_injective","module":"Mathlib.Algebra.Ring.Ext","initialProofState":"R : Type u\n⊢ Function.Injective (@NonAssocSemiring.toNonUnitalNonAssocSemiring R)","decl":"theorem toNonUnitalNonAssocSemiring_injective :\n    Function.Injective (@toNonUnitalNonAssocSemiring R) := by\n  intro _ _ _\n  ext <;> congr\n\n"}
{"name":"NonUnitalNonAssocRing.ext","module":"Mathlib.Algebra.Ring.Ext","initialProofState":"R : Type u\ninst₁ inst₂ : NonUnitalNonAssocRing R\nh_add : Eq HAdd.hAdd HAdd.hAdd\nh_mul : Eq HMul.hMul HMul.hMul\n⊢ Eq inst₁ inst₂","decl":"@[ext] theorem ext ⦃inst₁ inst₂ : NonUnitalNonAssocRing R⦄\n    (h_add : local_hAdd[R, inst₁] = local_hAdd[R, inst₂])\n    (h_mul : local_hMul[R, inst₁] = local_hMul[R, inst₂]) :\n    inst₁ = inst₂ := by\n  -- Split into `AddCommGroup` instance, `mul` function and properties.\n  rcases inst₁ with @⟨_, ⟨⟩⟩; rcases inst₂ with @⟨_, ⟨⟩⟩\n  congr; (ext : 1; assumption)\n\n"}
{"name":"NonUnitalNonAssocRing.ext_iff","module":"Mathlib.Algebra.Ring.Ext","initialProofState":"R : Type u\ninst₁ inst₂ : NonUnitalNonAssocRing R\n⊢ Iff (Eq inst₁ inst₂) (And (Eq HAdd.hAdd HAdd.hAdd) (Eq HMul.hMul HMul.hMul))","decl":"@[ext] theorem ext ⦃inst₁ inst₂ : NonUnitalNonAssocRing R⦄\n    (h_add : local_hAdd[R, inst₁] = local_hAdd[R, inst₂])\n    (h_mul : local_hMul[R, inst₁] = local_hMul[R, inst₂]) :\n    inst₁ = inst₂ := by\n  -- Split into `AddCommGroup` instance, `mul` function and properties.\n  rcases inst₁ with @⟨_, ⟨⟩⟩; rcases inst₂ with @⟨_, ⟨⟩⟩\n  congr; (ext : 1; assumption)\n\n"}
{"name":"NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring_injective","module":"Mathlib.Algebra.Ring.Ext","initialProofState":"R : Type u\n⊢ Function.Injective (@NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring R)","decl":"theorem toNonUnitalNonAssocSemiring_injective :\n    Function.Injective (@toNonUnitalNonAssocSemiring R) := by\n  intro _ _ h\n  -- Use above extensionality lemma to prove injectivity by showing that `h_add` and `h_mul` hold.\n  ext x y\n  · exact congrArg (·.toAdd.add x y) h\n  · exact congrArg (·.toMul.mul x y) h\n\n"}
{"name":"NonUnitalRing.ext_iff","module":"Mathlib.Algebra.Ring.Ext","initialProofState":"R : Type u\ninst₁ inst₂ : NonUnitalRing R\n⊢ Iff (Eq inst₁ inst₂) (And (Eq HAdd.hAdd HAdd.hAdd) (Eq HMul.hMul HMul.hMul))","decl":"@[ext] theorem ext ⦃inst₁ inst₂ : NonUnitalRing R⦄\n    (h_add : local_hAdd[R, inst₁] = local_hAdd[R, inst₂])\n    (h_mul : local_hMul[R, inst₁] = local_hMul[R, inst₂]) :\n    inst₁ = inst₂ := by\n  have : inst₁.toNonUnitalNonAssocRing = inst₂.toNonUnitalNonAssocRing := by\n    ext : 1 <;> assumption\n  -- Split into fields and prove they are equal using the above.\n  cases inst₁; cases inst₂\n  congr\n\n"}
{"name":"NonUnitalRing.ext","module":"Mathlib.Algebra.Ring.Ext","initialProofState":"R : Type u\ninst₁ inst₂ : NonUnitalRing R\nh_add : Eq HAdd.hAdd HAdd.hAdd\nh_mul : Eq HMul.hMul HMul.hMul\n⊢ Eq inst₁ inst₂","decl":"@[ext] theorem ext ⦃inst₁ inst₂ : NonUnitalRing R⦄\n    (h_add : local_hAdd[R, inst₁] = local_hAdd[R, inst₂])\n    (h_mul : local_hMul[R, inst₁] = local_hMul[R, inst₂]) :\n    inst₁ = inst₂ := by\n  have : inst₁.toNonUnitalNonAssocRing = inst₂.toNonUnitalNonAssocRing := by\n    ext : 1 <;> assumption\n  -- Split into fields and prove they are equal using the above.\n  cases inst₁; cases inst₂\n  congr\n\n"}
{"name":"NonUnitalRing.toNonUnitalSemiring_injective","module":"Mathlib.Algebra.Ring.Ext","initialProofState":"R : Type u\n⊢ Function.Injective (@NonUnitalRing.toNonUnitalSemiring R)","decl":"theorem toNonUnitalSemiring_injective :\n    Function.Injective (@toNonUnitalSemiring R) := by\n  intro _ _ h\n  ext x y\n  · exact congrArg (·.toAdd.add x y) h\n  · exact congrArg (·.toMul.mul x y) h\n\n"}
{"name":"NonUnitalRing.toNonUnitalNonAssocring_injective","module":"Mathlib.Algebra.Ring.Ext","initialProofState":"R : Type u\n⊢ Function.Injective (@NonUnitalRing.toNonUnitalNonAssocRing R)","decl":"theorem toNonUnitalNonAssocring_injective :\n    Function.Injective (@toNonUnitalNonAssocRing R) := by\n  intro _ _ _\n  ext <;> congr\n\n"}
{"name":"AddGroupWithOne.ext_iff","module":"Mathlib.Algebra.Ring.Ext","initialProofState":"R : Type u\ninst₁ inst₂ : AddGroupWithOne R\n⊢ Iff (Eq inst₁ inst₂) (And (Eq HAdd.hAdd HAdd.hAdd) (Eq One.one One.one))","decl":"@[ext] theorem AddGroupWithOne.ext ⦃inst₁ inst₂ : AddGroupWithOne R⦄\n    (h_add : local_hAdd[R, inst₁] = local_hAdd[R, inst₂])\n    (h_one : (letI := inst₁; One.one : R) = (letI := inst₂; One.one)) :\n    inst₁ = inst₂ := by\n  have : inst₁.toAddMonoidWithOne = inst₂.toAddMonoidWithOne :=\n    AddMonoidWithOne.ext h_add h_one\n  have : inst₁.toNatCast = inst₂.toNatCast := congrArg (·.toNatCast) this\n  have h_group : inst₁.toAddGroup = inst₂.toAddGroup := by ext : 1; exact h_add\n  -- Extract equality of necessary substructures from h_group\n  injection h_group with h_group; injection h_group\n  have : inst₁.toIntCast.intCast = inst₂.toIntCast.intCast := by\n    funext n; cases n with\n    | ofNat n   => rewrite [Int.ofNat_eq_coe, inst₁.intCast_ofNat, inst₂.intCast_ofNat]; congr\n    | negSucc n => rewrite [inst₁.intCast_negSucc, inst₂.intCast_negSucc]; congr\n  rcases inst₁ with @⟨⟨⟩⟩; rcases inst₂ with @⟨⟨⟩⟩\n  congr\n\n"}
{"name":"AddGroupWithOne.ext","module":"Mathlib.Algebra.Ring.Ext","initialProofState":"R : Type u\ninst₁ inst₂ : AddGroupWithOne R\nh_add : Eq HAdd.hAdd HAdd.hAdd\nh_one : Eq One.one One.one\n⊢ Eq inst₁ inst₂","decl":"@[ext] theorem AddGroupWithOne.ext ⦃inst₁ inst₂ : AddGroupWithOne R⦄\n    (h_add : local_hAdd[R, inst₁] = local_hAdd[R, inst₂])\n    (h_one : (letI := inst₁; One.one : R) = (letI := inst₂; One.one)) :\n    inst₁ = inst₂ := by\n  have : inst₁.toAddMonoidWithOne = inst₂.toAddMonoidWithOne :=\n    AddMonoidWithOne.ext h_add h_one\n  have : inst₁.toNatCast = inst₂.toNatCast := congrArg (·.toNatCast) this\n  have h_group : inst₁.toAddGroup = inst₂.toAddGroup := by ext : 1; exact h_add\n  -- Extract equality of necessary substructures from h_group\n  injection h_group with h_group; injection h_group\n  have : inst₁.toIntCast.intCast = inst₂.toIntCast.intCast := by\n    funext n; cases n with\n    | ofNat n   => rewrite [Int.ofNat_eq_coe, inst₁.intCast_ofNat, inst₂.intCast_ofNat]; congr\n    | negSucc n => rewrite [inst₁.intCast_negSucc, inst₂.intCast_negSucc]; congr\n  rcases inst₁ with @⟨⟨⟩⟩; rcases inst₂ with @⟨⟨⟩⟩\n  congr\n\n"}
{"name":"AddCommGroupWithOne.ext_iff","module":"Mathlib.Algebra.Ring.Ext","initialProofState":"R : Type u\ninst₁ inst₂ : AddCommGroupWithOne R\n⊢ Iff (Eq inst₁ inst₂) (And (Eq HAdd.hAdd HAdd.hAdd) (Eq One.one One.one))","decl":"@[ext] theorem AddCommGroupWithOne.ext ⦃inst₁ inst₂ : AddCommGroupWithOne R⦄\n    (h_add : local_hAdd[R, inst₁] = local_hAdd[R, inst₂])\n    (h_one : (letI := inst₁; One.one : R) = (letI := inst₂; One.one)) :\n    inst₁ = inst₂ := by\n  have : inst₁.toAddCommGroup = inst₂.toAddCommGroup :=\n    AddCommGroup.ext h_add\n  have : inst₁.toAddGroupWithOne = inst₂.toAddGroupWithOne :=\n    AddGroupWithOne.ext h_add h_one\n  injection this with _ h_addMonoidWithOne; injection h_addMonoidWithOne\n  cases inst₁; cases inst₂\n  congr\n\n"}
{"name":"AddCommGroupWithOne.ext","module":"Mathlib.Algebra.Ring.Ext","initialProofState":"R : Type u\ninst₁ inst₂ : AddCommGroupWithOne R\nh_add : Eq HAdd.hAdd HAdd.hAdd\nh_one : Eq One.one One.one\n⊢ Eq inst₁ inst₂","decl":"@[ext] theorem AddCommGroupWithOne.ext ⦃inst₁ inst₂ : AddCommGroupWithOne R⦄\n    (h_add : local_hAdd[R, inst₁] = local_hAdd[R, inst₂])\n    (h_one : (letI := inst₁; One.one : R) = (letI := inst₂; One.one)) :\n    inst₁ = inst₂ := by\n  have : inst₁.toAddCommGroup = inst₂.toAddCommGroup :=\n    AddCommGroup.ext h_add\n  have : inst₁.toAddGroupWithOne = inst₂.toAddGroupWithOne :=\n    AddGroupWithOne.ext h_add h_one\n  injection this with _ h_addMonoidWithOne; injection h_addMonoidWithOne\n  cases inst₁; cases inst₂\n  congr\n\n"}
{"name":"NonAssocRing.ext_iff","module":"Mathlib.Algebra.Ring.Ext","initialProofState":"R : Type u\ninst₁ inst₂ : NonAssocRing R\n⊢ Iff (Eq inst₁ inst₂) (And (Eq HAdd.hAdd HAdd.hAdd) (Eq HMul.hMul HMul.hMul))","decl":"@[ext] theorem ext ⦃inst₁ inst₂ : NonAssocRing R⦄\n    (h_add : local_hAdd[R, inst₁] = local_hAdd[R, inst₂])\n    (h_mul : local_hMul[R, inst₁] = local_hMul[R, inst₂]) :\n    inst₁ = inst₂ := by\n  have h₁ : inst₁.toNonUnitalNonAssocRing = inst₂.toNonUnitalNonAssocRing := by\n    ext : 1 <;> assumption\n  have h₂ : inst₁.toNonAssocSemiring = inst₂.toNonAssocSemiring := by\n    ext : 1 <;> assumption\n  -- Mathematically non-trivial fact: `intCast` is determined by the rest.\n  have h₃ : inst₁.toAddCommGroupWithOne = inst₂.toAddCommGroupWithOne :=\n    AddCommGroupWithOne.ext h_add (congrArg (·.toOne.one) h₂)\n  cases inst₁; cases inst₂\n  congr <;> solve| injection h₁ | injection h₂ | injection h₃\n\n"}
{"name":"NonAssocRing.ext","module":"Mathlib.Algebra.Ring.Ext","initialProofState":"R : Type u\ninst₁ inst₂ : NonAssocRing R\nh_add : Eq HAdd.hAdd HAdd.hAdd\nh_mul : Eq HMul.hMul HMul.hMul\n⊢ Eq inst₁ inst₂","decl":"@[ext] theorem ext ⦃inst₁ inst₂ : NonAssocRing R⦄\n    (h_add : local_hAdd[R, inst₁] = local_hAdd[R, inst₂])\n    (h_mul : local_hMul[R, inst₁] = local_hMul[R, inst₂]) :\n    inst₁ = inst₂ := by\n  have h₁ : inst₁.toNonUnitalNonAssocRing = inst₂.toNonUnitalNonAssocRing := by\n    ext : 1 <;> assumption\n  have h₂ : inst₁.toNonAssocSemiring = inst₂.toNonAssocSemiring := by\n    ext : 1 <;> assumption\n  -- Mathematically non-trivial fact: `intCast` is determined by the rest.\n  have h₃ : inst₁.toAddCommGroupWithOne = inst₂.toAddCommGroupWithOne :=\n    AddCommGroupWithOne.ext h_add (congrArg (·.toOne.one) h₂)\n  cases inst₁; cases inst₂\n  congr <;> solve| injection h₁ | injection h₂ | injection h₃\n\n"}
{"name":"NonAssocRing.toNonAssocSemiring_injective","module":"Mathlib.Algebra.Ring.Ext","initialProofState":"R : Type u\n⊢ Function.Injective (@NonAssocRing.toNonAssocSemiring R)","decl":"theorem toNonAssocSemiring_injective :\n    Function.Injective (@toNonAssocSemiring R) := by\n  intro _ _ h\n  ext x y\n  · exact congrArg (·.toAdd.add x y) h\n  · exact congrArg (·.toMul.mul x y) h\n\n"}
{"name":"NonAssocRing.toNonUnitalNonAssocring_injective","module":"Mathlib.Algebra.Ring.Ext","initialProofState":"R : Type u\n⊢ Function.Injective (@NonAssocRing.toNonUnitalNonAssocRing R)","decl":"theorem toNonUnitalNonAssocring_injective :\n    Function.Injective (@toNonUnitalNonAssocRing R) := by\n  intro _ _ _\n  ext <;> congr\n\n"}
{"name":"Semiring.ext_iff","module":"Mathlib.Algebra.Ring.Ext","initialProofState":"R : Type u\ninst₁ inst₂ : Semiring R\n⊢ Iff (Eq inst₁ inst₂) (And (Eq HAdd.hAdd HAdd.hAdd) (Eq HMul.hMul HMul.hMul))","decl":"@[ext] theorem ext ⦃inst₁ inst₂ : Semiring R⦄\n    (h_add : local_hAdd[R, inst₁] = local_hAdd[R, inst₂])\n    (h_mul : local_hMul[R, inst₁] = local_hMul[R, inst₂]) :\n    inst₁ = inst₂ := by\n  -- Show that enough substructures are equal.\n  have h₁ : inst₁.toNonUnitalSemiring = inst₂.toNonUnitalSemiring := by\n    ext : 1 <;> assumption\n  have h₂ : inst₁.toNonAssocSemiring = inst₂.toNonAssocSemiring := by\n    ext : 1 <;> assumption\n  have h₃ : (inst₁.toMonoidWithZero).toMonoid = (inst₂.toMonoidWithZero).toMonoid := by\n    ext : 1; exact h_mul\n  -- Split into fields and prove they are equal using the above.\n  cases inst₁; cases inst₂\n  congr <;> solve| injection h₁ | injection h₂ | injection h₃\n\n"}
{"name":"Semiring.ext","module":"Mathlib.Algebra.Ring.Ext","initialProofState":"R : Type u\ninst₁ inst₂ : Semiring R\nh_add : Eq HAdd.hAdd HAdd.hAdd\nh_mul : Eq HMul.hMul HMul.hMul\n⊢ Eq inst₁ inst₂","decl":"@[ext] theorem ext ⦃inst₁ inst₂ : Semiring R⦄\n    (h_add : local_hAdd[R, inst₁] = local_hAdd[R, inst₂])\n    (h_mul : local_hMul[R, inst₁] = local_hMul[R, inst₂]) :\n    inst₁ = inst₂ := by\n  -- Show that enough substructures are equal.\n  have h₁ : inst₁.toNonUnitalSemiring = inst₂.toNonUnitalSemiring := by\n    ext : 1 <;> assumption\n  have h₂ : inst₁.toNonAssocSemiring = inst₂.toNonAssocSemiring := by\n    ext : 1 <;> assumption\n  have h₃ : (inst₁.toMonoidWithZero).toMonoid = (inst₂.toMonoidWithZero).toMonoid := by\n    ext : 1; exact h_mul\n  -- Split into fields and prove they are equal using the above.\n  cases inst₁; cases inst₂\n  congr <;> solve| injection h₁ | injection h₂ | injection h₃\n\n"}
{"name":"Semiring.toNonUnitalSemiring_injective","module":"Mathlib.Algebra.Ring.Ext","initialProofState":"R : Type u\n⊢ Function.Injective (@Semiring.toNonUnitalSemiring R)","decl":"theorem toNonUnitalSemiring_injective :\n    Function.Injective (@toNonUnitalSemiring R) := by\n  intro _ _ h\n  ext x y\n  · exact congrArg (·.toAdd.add x y) h\n  · exact congrArg (·.toMul.mul x y) h\n\n"}
{"name":"Semiring.toNonAssocSemiring_injective","module":"Mathlib.Algebra.Ring.Ext","initialProofState":"R : Type u\n⊢ Function.Injective (@Semiring.toNonAssocSemiring R)","decl":"theorem toNonAssocSemiring_injective :\n    Function.Injective (@toNonAssocSemiring R) := by\n  intro _ _ h\n  ext x y\n  · exact congrArg (·.toAdd.add x y) h\n  · exact congrArg (·.toMul.mul x y) h\n\n"}
{"name":"Ring.ext","module":"Mathlib.Algebra.Ring.Ext","initialProofState":"R : Type u\ninst₁ inst₂ : Ring R\nh_add : Eq HAdd.hAdd HAdd.hAdd\nh_mul : Eq HMul.hMul HMul.hMul\n⊢ Eq inst₁ inst₂","decl":"@[ext] theorem ext ⦃inst₁ inst₂ : Ring R⦄\n    (h_add : local_hAdd[R, inst₁] = local_hAdd[R, inst₂])\n    (h_mul : local_hMul[R, inst₁] = local_hMul[R, inst₂]) :\n    inst₁ = inst₂ := by\n  -- Show that enough substructures are equal.\n  have h₁ : inst₁.toSemiring = inst₂.toSemiring := by\n    ext : 1 <;> assumption\n  have h₂ : inst₁.toNonAssocRing = inst₂.toNonAssocRing := by\n    ext : 1 <;> assumption\n  /- We prove that the `SubNegMonoid`s are equal because they are one\n  field away from `Sub` and `Neg`, enabling use of `injection`. -/\n  have h₃ : (inst₁.toAddCommGroup).toAddGroup.toSubNegMonoid\n            = (inst₂.toAddCommGroup).toAddGroup.toSubNegMonoid :=\n    congrArg (@AddGroup.toSubNegMonoid R) <| by ext : 1; exact h_add\n  -- Split into fields and prove they are equal using the above.\n  cases inst₁; cases inst₂\n  congr <;> solve | injection h₂ | injection h₃\n\n"}
{"name":"Ring.ext_iff","module":"Mathlib.Algebra.Ring.Ext","initialProofState":"R : Type u\ninst₁ inst₂ : Ring R\n⊢ Iff (Eq inst₁ inst₂) (And (Eq HAdd.hAdd HAdd.hAdd) (Eq HMul.hMul HMul.hMul))","decl":"@[ext] theorem ext ⦃inst₁ inst₂ : Ring R⦄\n    (h_add : local_hAdd[R, inst₁] = local_hAdd[R, inst₂])\n    (h_mul : local_hMul[R, inst₁] = local_hMul[R, inst₂]) :\n    inst₁ = inst₂ := by\n  -- Show that enough substructures are equal.\n  have h₁ : inst₁.toSemiring = inst₂.toSemiring := by\n    ext : 1 <;> assumption\n  have h₂ : inst₁.toNonAssocRing = inst₂.toNonAssocRing := by\n    ext : 1 <;> assumption\n  /- We prove that the `SubNegMonoid`s are equal because they are one\n  field away from `Sub` and `Neg`, enabling use of `injection`. -/\n  have h₃ : (inst₁.toAddCommGroup).toAddGroup.toSubNegMonoid\n            = (inst₂.toAddCommGroup).toAddGroup.toSubNegMonoid :=\n    congrArg (@AddGroup.toSubNegMonoid R) <| by ext : 1; exact h_add\n  -- Split into fields and prove they are equal using the above.\n  cases inst₁; cases inst₂\n  congr <;> solve | injection h₂ | injection h₃\n\n"}
{"name":"Ring.toNonUnitalRing_injective","module":"Mathlib.Algebra.Ring.Ext","initialProofState":"R : Type u\n⊢ Function.Injective (@Ring.toNonUnitalRing R)","decl":"theorem toNonUnitalRing_injective :\n    Function.Injective (@toNonUnitalRing R) := by\n  intro _ _ h\n  ext x y\n  · exact congrArg (·.toAdd.add x y) h\n  · exact congrArg (·.toMul.mul x y) h\n\n"}
{"name":"Ring.toNonAssocRing_injective","module":"Mathlib.Algebra.Ring.Ext","initialProofState":"R : Type u\n⊢ Function.Injective (@Ring.toNonAssocRing R)","decl":"theorem toNonAssocRing_injective :\n    Function.Injective (@toNonAssocRing R) := by\n  intro _ _ _\n  ext <;> congr\n\n"}
{"name":"Ring.toSemiring_injective","module":"Mathlib.Algebra.Ring.Ext","initialProofState":"R : Type u\n⊢ Function.Injective (@Ring.toSemiring R)","decl":"theorem toSemiring_injective :\n    Function.Injective (@toSemiring R) := by\n  intro _ _ h\n  ext x y\n  · exact congrArg (·.toAdd.add x y) h\n  · exact congrArg (·.toMul.mul x y) h\n\n"}
{"name":"NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring_injective","module":"Mathlib.Algebra.Ring.Ext","initialProofState":"R : Type u\n⊢ Function.Injective (@NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring R)","decl":"theorem toNonUnitalNonAssocSemiring_injective :\n    Function.Injective (@toNonUnitalNonAssocSemiring R) := by\n  rintro ⟨⟩ ⟨⟩ _; congr\n\n"}
{"name":"NonUnitalNonAssocCommSemiring.ext_iff","module":"Mathlib.Algebra.Ring.Ext","initialProofState":"R : Type u\ninst₁ inst₂ : NonUnitalNonAssocCommSemiring R\n⊢ Iff (Eq inst₁ inst₂) (And (Eq HAdd.hAdd HAdd.hAdd) (Eq HMul.hMul HMul.hMul))","decl":"@[ext] theorem ext ⦃inst₁ inst₂ : NonUnitalNonAssocCommSemiring R⦄\n    (h_add : local_hAdd[R, inst₁] = local_hAdd[R, inst₂])\n    (h_mul : local_hMul[R, inst₁] = local_hMul[R, inst₂]) :\n    inst₁ = inst₂ :=\n  toNonUnitalNonAssocSemiring_injective <|\n    NonUnitalNonAssocSemiring.ext h_add h_mul\n\n"}
{"name":"NonUnitalNonAssocCommSemiring.ext","module":"Mathlib.Algebra.Ring.Ext","initialProofState":"R : Type u\ninst₁ inst₂ : NonUnitalNonAssocCommSemiring R\nh_add : Eq HAdd.hAdd HAdd.hAdd\nh_mul : Eq HMul.hMul HMul.hMul\n⊢ Eq inst₁ inst₂","decl":"@[ext] theorem ext ⦃inst₁ inst₂ : NonUnitalNonAssocCommSemiring R⦄\n    (h_add : local_hAdd[R, inst₁] = local_hAdd[R, inst₂])\n    (h_mul : local_hMul[R, inst₁] = local_hMul[R, inst₂]) :\n    inst₁ = inst₂ :=\n  toNonUnitalNonAssocSemiring_injective <|\n    NonUnitalNonAssocSemiring.ext h_add h_mul\n\n"}
{"name":"NonUnitalCommSemiring.toNonUnitalSemiring_injective","module":"Mathlib.Algebra.Ring.Ext","initialProofState":"R : Type u\n⊢ Function.Injective (@NonUnitalCommSemiring.toNonUnitalSemiring R)","decl":"theorem toNonUnitalSemiring_injective :\n    Function.Injective (@toNonUnitalSemiring R) := by\n  rintro ⟨⟩ ⟨⟩ _; congr\n\n"}
{"name":"NonUnitalCommSemiring.ext","module":"Mathlib.Algebra.Ring.Ext","initialProofState":"R : Type u\ninst₁ inst₂ : NonUnitalCommSemiring R\nh_add : Eq HAdd.hAdd HAdd.hAdd\nh_mul : Eq HMul.hMul HMul.hMul\n⊢ Eq inst₁ inst₂","decl":"@[ext] theorem ext ⦃inst₁ inst₂ : NonUnitalCommSemiring R⦄\n    (h_add : local_hAdd[R, inst₁] = local_hAdd[R, inst₂])\n    (h_mul : local_hMul[R, inst₁] = local_hMul[R, inst₂]) :\n    inst₁ = inst₂ :=\n  toNonUnitalSemiring_injective <|\n    NonUnitalSemiring.ext h_add h_mul\n\n"}
{"name":"NonUnitalCommSemiring.ext_iff","module":"Mathlib.Algebra.Ring.Ext","initialProofState":"R : Type u\ninst₁ inst₂ : NonUnitalCommSemiring R\n⊢ Iff (Eq inst₁ inst₂) (And (Eq HAdd.hAdd HAdd.hAdd) (Eq HMul.hMul HMul.hMul))","decl":"@[ext] theorem ext ⦃inst₁ inst₂ : NonUnitalCommSemiring R⦄\n    (h_add : local_hAdd[R, inst₁] = local_hAdd[R, inst₂])\n    (h_mul : local_hMul[R, inst₁] = local_hMul[R, inst₂]) :\n    inst₁ = inst₂ :=\n  toNonUnitalSemiring_injective <|\n    NonUnitalSemiring.ext h_add h_mul\n\n"}
{"name":"NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing_injective","module":"Mathlib.Algebra.Ring.Ext","initialProofState":"R : Type u\n⊢ Function.Injective (@NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing R)","decl":"theorem toNonUnitalNonAssocRing_injective :\n    Function.Injective (@toNonUnitalNonAssocRing R) := by\n  rintro ⟨⟩ ⟨⟩ _; congr\n\n"}
{"name":"NonUnitalNonAssocCommRing.ext","module":"Mathlib.Algebra.Ring.Ext","initialProofState":"R : Type u\ninst₁ inst₂ : NonUnitalNonAssocCommRing R\nh_add : Eq HAdd.hAdd HAdd.hAdd\nh_mul : Eq HMul.hMul HMul.hMul\n⊢ Eq inst₁ inst₂","decl":"@[ext] theorem ext ⦃inst₁ inst₂ : NonUnitalNonAssocCommRing R⦄\n    (h_add : local_hAdd[R, inst₁] = local_hAdd[R, inst₂])\n    (h_mul : local_hMul[R, inst₁] = local_hMul[R, inst₂]) :\n    inst₁ = inst₂ :=\n  toNonUnitalNonAssocRing_injective <|\n    NonUnitalNonAssocRing.ext h_add h_mul\n\n"}
{"name":"NonUnitalNonAssocCommRing.ext_iff","module":"Mathlib.Algebra.Ring.Ext","initialProofState":"R : Type u\ninst₁ inst₂ : NonUnitalNonAssocCommRing R\n⊢ Iff (Eq inst₁ inst₂) (And (Eq HAdd.hAdd HAdd.hAdd) (Eq HMul.hMul HMul.hMul))","decl":"@[ext] theorem ext ⦃inst₁ inst₂ : NonUnitalNonAssocCommRing R⦄\n    (h_add : local_hAdd[R, inst₁] = local_hAdd[R, inst₂])\n    (h_mul : local_hMul[R, inst₁] = local_hMul[R, inst₂]) :\n    inst₁ = inst₂ :=\n  toNonUnitalNonAssocRing_injective <|\n    NonUnitalNonAssocRing.ext h_add h_mul\n\n"}
{"name":"NonUnitalCommRing.toNonUnitalRing_injective","module":"Mathlib.Algebra.Ring.Ext","initialProofState":"R : Type u\n⊢ Function.Injective (@NonUnitalCommRing.toNonUnitalRing R)","decl":"theorem toNonUnitalRing_injective :\n    Function.Injective (@toNonUnitalRing R) := by\n  rintro ⟨⟩ ⟨⟩ _; congr\n\n"}
{"name":"NonUnitalCommRing.ext_iff","module":"Mathlib.Algebra.Ring.Ext","initialProofState":"R : Type u\ninst₁ inst₂ : NonUnitalCommRing R\n⊢ Iff (Eq inst₁ inst₂) (And (Eq HAdd.hAdd HAdd.hAdd) (Eq HMul.hMul HMul.hMul))","decl":"@[ext] theorem ext ⦃inst₁ inst₂ : NonUnitalCommRing R⦄\n    (h_add : local_hAdd[R, inst₁] = local_hAdd[R, inst₂])\n    (h_mul : local_hMul[R, inst₁] = local_hMul[R, inst₂]) :\n    inst₁ = inst₂ :=\n  toNonUnitalRing_injective <|\n    NonUnitalRing.ext h_add h_mul\n\n"}
{"name":"NonUnitalCommRing.ext","module":"Mathlib.Algebra.Ring.Ext","initialProofState":"R : Type u\ninst₁ inst₂ : NonUnitalCommRing R\nh_add : Eq HAdd.hAdd HAdd.hAdd\nh_mul : Eq HMul.hMul HMul.hMul\n⊢ Eq inst₁ inst₂","decl":"@[ext] theorem ext ⦃inst₁ inst₂ : NonUnitalCommRing R⦄\n    (h_add : local_hAdd[R, inst₁] = local_hAdd[R, inst₂])\n    (h_mul : local_hMul[R, inst₁] = local_hMul[R, inst₂]) :\n    inst₁ = inst₂ :=\n  toNonUnitalRing_injective <|\n    NonUnitalRing.ext h_add h_mul\n\n"}
{"name":"CommSemiring.toSemiring_injective","module":"Mathlib.Algebra.Ring.Ext","initialProofState":"R : Type u\n⊢ Function.Injective (@CommSemiring.toSemiring R)","decl":"theorem toSemiring_injective :\n    Function.Injective (@toSemiring R) := by\n  rintro ⟨⟩ ⟨⟩ _; congr\n\n"}
{"name":"CommSemiring.ext_iff","module":"Mathlib.Algebra.Ring.Ext","initialProofState":"R : Type u\ninst₁ inst₂ : CommSemiring R\n⊢ Iff (Eq inst₁ inst₂) (And (Eq HAdd.hAdd HAdd.hAdd) (Eq HMul.hMul HMul.hMul))","decl":"@[ext] theorem ext ⦃inst₁ inst₂ : CommSemiring R⦄\n    (h_add : local_hAdd[R, inst₁] = local_hAdd[R, inst₂])\n    (h_mul : local_hMul[R, inst₁] = local_hMul[R, inst₂]) :\n    inst₁ = inst₂ :=\n  toSemiring_injective <|\n    Semiring.ext h_add h_mul\n\n"}
{"name":"CommSemiring.ext","module":"Mathlib.Algebra.Ring.Ext","initialProofState":"R : Type u\ninst₁ inst₂ : CommSemiring R\nh_add : Eq HAdd.hAdd HAdd.hAdd\nh_mul : Eq HMul.hMul HMul.hMul\n⊢ Eq inst₁ inst₂","decl":"@[ext] theorem ext ⦃inst₁ inst₂ : CommSemiring R⦄\n    (h_add : local_hAdd[R, inst₁] = local_hAdd[R, inst₂])\n    (h_mul : local_hMul[R, inst₁] = local_hMul[R, inst₂]) :\n    inst₁ = inst₂ :=\n  toSemiring_injective <|\n    Semiring.ext h_add h_mul\n\n"}
{"name":"CommRing.toRing_injective","module":"Mathlib.Algebra.Ring.Ext","initialProofState":"R : Type u\n⊢ Function.Injective (@CommRing.toRing R)","decl":"theorem toRing_injective : Function.Injective (@toRing R) := by\n  rintro ⟨⟩ ⟨⟩ _; congr\n\n"}
{"name":"CommRing.ext","module":"Mathlib.Algebra.Ring.Ext","initialProofState":"R : Type u\ninst₁ inst₂ : CommRing R\nh_add : Eq HAdd.hAdd HAdd.hAdd\nh_mul : Eq HMul.hMul HMul.hMul\n⊢ Eq inst₁ inst₂","decl":"@[ext] theorem ext ⦃inst₁ inst₂ : CommRing R⦄\n    (h_add : local_hAdd[R, inst₁] = local_hAdd[R, inst₂])\n    (h_mul : local_hMul[R, inst₁] = local_hMul[R, inst₂]) :\n    inst₁ = inst₂ :=\n  toRing_injective <| Ring.ext h_add h_mul\n\n"}
{"name":"CommRing.ext_iff","module":"Mathlib.Algebra.Ring.Ext","initialProofState":"R : Type u\ninst₁ inst₂ : CommRing R\n⊢ Iff (Eq inst₁ inst₂) (And (Eq HAdd.hAdd HAdd.hAdd) (Eq HMul.hMul HMul.hMul))","decl":"@[ext] theorem ext ⦃inst₁ inst₂ : CommRing R⦄\n    (h_add : local_hAdd[R, inst₁] = local_hAdd[R, inst₂])\n    (h_mul : local_hMul[R, inst₁] = local_hMul[R, inst₂]) :\n    inst₁ = inst₂ :=\n  toRing_injective <| Ring.ext h_add h_mul\n\n"}
