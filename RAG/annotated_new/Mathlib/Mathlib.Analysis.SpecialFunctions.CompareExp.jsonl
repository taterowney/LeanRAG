{"name":"Complex.IsExpCmpFilter.tendsto_re","module":"Mathlib.Analysis.SpecialFunctions.CompareExp","initialProofState":"l : Filter Complex\nself : Complex.IsExpCmpFilter l\n⊢ Filter.Tendsto Complex.re l Filter.atTop","decl":"/-- We say that `l : Filter ℂ` is an *exponential comparison filter* if the real part tends to\ninfinity along `l` and the imaginary part grows subexponentially compared to the real part. These\nproperties guarantee that `(fun z ↦ z ^ a₁ * exp (b₁ * z)) =o[l] (fun z ↦ z ^ a₂ * exp (b₂ * z))`\nfor any complex `a₁`, `a₂` and real `b₁ < b₂`.\n\nIn particular, the second property is automatically satisfied if the imaginary part is bounded along\n`l`. -/\nstructure IsExpCmpFilter (l : Filter ℂ) : Prop where\n  tendsto_re : Tendsto re l atTop\n  isBigO_im_pow_re : ∀ n : ℕ, (fun z : ℂ => z.im ^ n) =O[l] fun z => Real.exp z.re\n\n"}
{"name":"Complex.IsExpCmpFilter.isBigO_im_pow_re","module":"Mathlib.Analysis.SpecialFunctions.CompareExp","initialProofState":"l : Filter Complex\nself : Complex.IsExpCmpFilter l\nn : Nat\n⊢ Asymptotics.IsBigO l (fun z => HPow.hPow z.im n) fun z => Real.exp z.re","decl":"/-- We say that `l : Filter ℂ` is an *exponential comparison filter* if the real part tends to\ninfinity along `l` and the imaginary part grows subexponentially compared to the real part. These\nproperties guarantee that `(fun z ↦ z ^ a₁ * exp (b₁ * z)) =o[l] (fun z ↦ z ^ a₂ * exp (b₂ * z))`\nfor any complex `a₁`, `a₂` and real `b₁ < b₂`.\n\nIn particular, the second property is automatically satisfied if the imaginary part is bounded along\n`l`. -/\nstructure IsExpCmpFilter (l : Filter ℂ) : Prop where\n  tendsto_re : Tendsto re l atTop\n  isBigO_im_pow_re : ∀ n : ℕ, (fun z : ℂ => z.im ^ n) =O[l] fun z => Real.exp z.re\n\n"}
{"name":"Complex.IsExpCmpFilter.of_isBigO_im_re_rpow","module":"Mathlib.Analysis.SpecialFunctions.CompareExp","initialProofState":"l : Filter Complex\nhre : Filter.Tendsto Complex.re l Filter.atTop\nr : Real\nhr : Asymptotics.IsBigO l Complex.im fun z => HPow.hPow z.re r\n⊢ Complex.IsExpCmpFilter l","decl":"theorem of_isBigO_im_re_rpow (hre : Tendsto re l atTop) (r : ℝ) (hr : im =O[l] fun z => z.re ^ r) :\n    IsExpCmpFilter l :=\n  ⟨hre, fun n =>\n    IsLittleO.isBigO <|\n      calc\n        (fun z : ℂ => z.im ^ n) =O[l] fun z => (z.re ^ r) ^ n := hr.pow n\n        _ =ᶠ[l] fun z => z.re ^ (r * n) :=\n          ((hre.eventually_ge_atTop 0).mono fun z hz => by\n            simp only [Real.rpow_mul hz r n, Real.rpow_natCast])\n        _ =o[l] fun z => Real.exp z.re := (isLittleO_rpow_exp_atTop _).comp_tendsto hre ⟩\n\n"}
{"name":"Complex.IsExpCmpFilter.of_isBigO_im_re_pow","module":"Mathlib.Analysis.SpecialFunctions.CompareExp","initialProofState":"l : Filter Complex\nhre : Filter.Tendsto Complex.re l Filter.atTop\nn : Nat\nhr : Asymptotics.IsBigO l Complex.im fun z => HPow.hPow z.re n\n⊢ Complex.IsExpCmpFilter l","decl":"theorem of_isBigO_im_re_pow (hre : Tendsto re l atTop) (n : ℕ) (hr : im =O[l] fun z => z.re ^ n) :\n    IsExpCmpFilter l :=\n  of_isBigO_im_re_rpow hre n <| mod_cast hr\n\n"}
{"name":"Complex.IsExpCmpFilter.of_boundedUnder_abs_im","module":"Mathlib.Analysis.SpecialFunctions.CompareExp","initialProofState":"l : Filter Complex\nhre : Filter.Tendsto Complex.re l Filter.atTop\nhim : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l fun z => abs z.im\n⊢ Complex.IsExpCmpFilter l","decl":"theorem of_boundedUnder_abs_im (hre : Tendsto re l atTop)\n    (him : IsBoundedUnder (· ≤ ·) l fun z => |z.im|) : IsExpCmpFilter l :=\n  of_isBigO_im_re_pow hre 0 <| by\n    simpa only [pow_zero] using him.isBigO_const (f := im) one_ne_zero\n\n"}
{"name":"Complex.IsExpCmpFilter.of_boundedUnder_im","module":"Mathlib.Analysis.SpecialFunctions.CompareExp","initialProofState":"l : Filter Complex\nhre : Filter.Tendsto Complex.re l Filter.atTop\nhim_le : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l Complex.im\nhim_ge : Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) l Complex.im\n⊢ Complex.IsExpCmpFilter l","decl":"theorem of_boundedUnder_im (hre : Tendsto re l atTop) (him_le : IsBoundedUnder (· ≤ ·) l im)\n    (him_ge : IsBoundedUnder (· ≥ ·) l im) : IsExpCmpFilter l :=\n  of_boundedUnder_abs_im hre <| isBoundedUnder_le_abs.2 ⟨him_le, him_ge⟩\n\n"}
{"name":"Complex.IsExpCmpFilter.eventually_ne","module":"Mathlib.Analysis.SpecialFunctions.CompareExp","initialProofState":"l : Filter Complex\nhl : Complex.IsExpCmpFilter l\n⊢ Filter.Eventually (fun w => Ne w 0) l","decl":"theorem eventually_ne (hl : IsExpCmpFilter l) : ∀ᶠ w : ℂ in l, w ≠ 0 :=\n  hl.tendsto_re.eventually_ne_atTop' _\n\n"}
{"name":"Complex.IsExpCmpFilter.tendsto_abs_re","module":"Mathlib.Analysis.SpecialFunctions.CompareExp","initialProofState":"l : Filter Complex\nhl : Complex.IsExpCmpFilter l\n⊢ Filter.Tendsto (fun z => abs z.re) l Filter.atTop","decl":"theorem tendsto_abs_re (hl : IsExpCmpFilter l) : Tendsto (fun z : ℂ => |z.re|) l atTop :=\n  tendsto_abs_atTop_atTop.comp hl.tendsto_re\n\n"}
{"name":"Complex.IsExpCmpFilter.tendsto_abs","module":"Mathlib.Analysis.SpecialFunctions.CompareExp","initialProofState":"l : Filter Complex\nhl : Complex.IsExpCmpFilter l\n⊢ Filter.Tendsto (⇑Complex.abs) l Filter.atTop","decl":"theorem tendsto_abs (hl : IsExpCmpFilter l) : Tendsto abs l atTop :=\n  tendsto_atTop_mono abs_re_le_abs hl.tendsto_abs_re\n\n"}
{"name":"Complex.IsExpCmpFilter.isLittleO_log_re_re","module":"Mathlib.Analysis.SpecialFunctions.CompareExp","initialProofState":"l : Filter Complex\nhl : Complex.IsExpCmpFilter l\n⊢ Asymptotics.IsLittleO l (fun z => Real.log z.re) Complex.re","decl":"theorem isLittleO_log_re_re (hl : IsExpCmpFilter l) : (fun z => Real.log z.re) =o[l] re :=\n  Real.isLittleO_log_id_atTop.comp_tendsto hl.tendsto_re\n\n"}
{"name":"Complex.IsExpCmpFilter.isLittleO_im_pow_exp_re","module":"Mathlib.Analysis.SpecialFunctions.CompareExp","initialProofState":"l : Filter Complex\nhl : Complex.IsExpCmpFilter l\nn : Nat\n⊢ Asymptotics.IsLittleO l (fun z => HPow.hPow z.im n) fun z => Real.exp z.re","decl":"theorem isLittleO_im_pow_exp_re (hl : IsExpCmpFilter l) (n : ℕ) :\n    (fun z : ℂ => z.im ^ n) =o[l] fun z => Real.exp z.re :=\n  flip IsLittleO.of_pow two_ne_zero <|\n    calc\n      (fun z : ℂ ↦ (z.im ^ n) ^ 2) = (fun z ↦ z.im ^ (2 * n)) := by simp only [pow_mul']\n      _ =O[l] fun z ↦ Real.exp z.re := hl.isBigO_im_pow_re _\n      _ =     fun z ↦ (Real.exp z.re) ^ 1 := by simp only [pow_one]\n      _ =o[l] fun z ↦ (Real.exp z.re) ^ 2 :=\n        (isLittleO_pow_pow_atTop_of_lt one_lt_two).comp_tendsto <|\n          Real.tendsto_exp_atTop.comp hl.tendsto_re\n\n"}
{"name":"Complex.IsExpCmpFilter.abs_im_pow_eventuallyLE_exp_re","module":"Mathlib.Analysis.SpecialFunctions.CompareExp","initialProofState":"l : Filter Complex\nhl : Complex.IsExpCmpFilter l\nn : Nat\n⊢ l.EventuallyLE (fun z => HPow.hPow (abs z.im) n) fun z => Real.exp z.re","decl":"theorem abs_im_pow_eventuallyLE_exp_re (hl : IsExpCmpFilter l) (n : ℕ) :\n    (fun z : ℂ => |z.im| ^ n) ≤ᶠ[l] fun z => Real.exp z.re := by\n  simpa using (hl.isLittleO_im_pow_exp_re n).bound zero_lt_one\n\n"}
{"name":"Complex.IsExpCmpFilter.isLittleO_log_abs_re","module":"Mathlib.Analysis.SpecialFunctions.CompareExp","initialProofState":"l : Filter Complex\nhl : Complex.IsExpCmpFilter l\n⊢ Asymptotics.IsLittleO l (fun z => Real.log (Complex.abs z)) Complex.re","decl":"/-- If `l : Filter ℂ` is an \"exponential comparison filter\", then $\\log |z| =o(ℜ z)$ along `l`.\nThis is the main lemma in the proof of `Complex.IsExpCmpFilter.isLittleO_cpow_exp` below.\n-/\ntheorem isLittleO_log_abs_re (hl : IsExpCmpFilter l) : (fun z => Real.log (abs z)) =o[l] re :=\n  calc\n    (fun z => Real.log (abs z)) =O[l] fun z => Real.log (√2) + Real.log (max z.re |z.im|) :=\n      .of_norm_eventuallyLE <|\n        (hl.tendsto_re.eventually_ge_atTop 1).mono fun z hz => by\n          have h2 : 0 < √2 := by simp\n          have hz' : 1 ≤ abs z := hz.trans (re_le_abs z)\n          have hm₀ : 0 < max z.re |z.im| := lt_max_iff.2 (Or.inl <| one_pos.trans_le hz)\n          simp only [Real.norm_of_nonneg (Real.log_nonneg hz')]\n          rw [← Real.log_mul, Real.log_le_log_iff, ← _root_.abs_of_nonneg (le_trans zero_le_one hz)]\n          exacts [abs_le_sqrt_two_mul_max z, one_pos.trans_le hz', mul_pos h2 hm₀, h2.ne', hm₀.ne']\n    _ =o[l] re :=\n      IsLittleO.add (isLittleO_const_left.2 <| Or.inr <| hl.tendsto_abs_re) <|\n        isLittleO_iff_nat_mul_le.2 fun n => by\n          filter_upwards [isLittleO_iff_nat_mul_le'.1 hl.isLittleO_log_re_re n,\n            hl.abs_im_pow_eventuallyLE_exp_re n,\n            hl.tendsto_re.eventually_gt_atTop 1] with z hre him h₁\n          rcases le_total |z.im| z.re with hle | hle\n          · rwa [max_eq_left hle]\n          · have H : 1 < |z.im| := h₁.trans_le hle\n            norm_cast at *\n            rwa [max_eq_right hle, Real.norm_eq_abs, Real.norm_eq_abs, abs_of_pos (Real.log_pos H),\n              ← Real.log_pow, Real.log_le_iff_le_exp (pow_pos (one_pos.trans H) _),\n              abs_of_pos (one_pos.trans h₁)]\n\n"}
{"name":"Complex.IsExpCmpFilter.isTheta_cpow_exp_re_mul_log","module":"Mathlib.Analysis.SpecialFunctions.CompareExp","initialProofState":"l : Filter Complex\nhl : Complex.IsExpCmpFilter l\na : Complex\n⊢ Asymptotics.IsTheta l (fun x => HPow.hPow x a) fun z => Real.exp (HMul.hMul a.re (Real.log (Complex.abs z)))","decl":"lemma isTheta_cpow_exp_re_mul_log (hl : IsExpCmpFilter l) (a : ℂ) :\n    (· ^ a) =Θ[l] fun z ↦ Real.exp (re a * Real.log (abs z)) :=\n  calc\n    (fun z => z ^ a) =Θ[l] (fun z : ℂ => (abs z ^ re a)) :=\n      isTheta_cpow_const_rpow fun _ _ => hl.eventually_ne\n    _ =ᶠ[l] fun z => Real.exp (re a * Real.log (abs z)) :=\n      (hl.eventually_ne.mono fun z hz => by simp only [Real.rpow_def_of_pos, abs.pos hz, mul_comm])\n\n"}
{"name":"Complex.IsExpCmpFilter.isLittleO_cpow_exp","module":"Mathlib.Analysis.SpecialFunctions.CompareExp","initialProofState":"l : Filter Complex\nhl : Complex.IsExpCmpFilter l\na : Complex\nb : Real\nhb : LT.lt 0 b\n⊢ Asymptotics.IsLittleO l (fun z => HPow.hPow z a) fun z => Complex.exp (HMul.hMul (↑b) z)","decl":"/-- If `l : Filter ℂ` is an \"exponential comparison filter\", then for any complex `a` and any\npositive real `b`, we have `(fun z ↦ z ^ a) =o[l] (fun z ↦ exp (b * z))`. -/\ntheorem isLittleO_cpow_exp (hl : IsExpCmpFilter l) (a : ℂ) {b : ℝ} (hb : 0 < b) :\n    (fun z => z ^ a) =o[l] fun z => exp (b * z) :=\n  calc\n    (fun z => z ^ a) =Θ[l] fun z => Real.exp (re a * Real.log (abs z)) :=\n      hl.isTheta_cpow_exp_re_mul_log a\n    _ =o[l] fun z => exp (b * z) :=\n      IsLittleO.of_norm_right <| by\n        simp only [norm_eq_abs, abs_exp, re_ofReal_mul, Real.isLittleO_exp_comp_exp_comp]\n        refine (IsEquivalent.refl.sub_isLittleO ?_).symm.tendsto_atTop\n          (hl.tendsto_re.const_mul_atTop hb)\n        exact (hl.isLittleO_log_abs_re.const_mul_left _).const_mul_right hb.ne'\n\n"}
{"name":"Complex.IsExpCmpFilter.isLittleO_cpow_mul_exp","module":"Mathlib.Analysis.SpecialFunctions.CompareExp","initialProofState":"l : Filter Complex\nb₁ b₂ : Real\nhl : Complex.IsExpCmpFilter l\nhb : LT.lt b₁ b₂\na₁ a₂ : Complex\n⊢ Asymptotics.IsLittleO l (fun z => HMul.hMul (HPow.hPow z a₁) (Complex.exp (HMul.hMul (↑b₁) z))) fun z => HMul.hMul (HPow.hPow z a₂) (Complex.exp (HMul.hMul (↑b₂) z))","decl":"/-- If `l : Filter ℂ` is an \"exponential comparison filter\", then for any complex `a₁`, `a₂` and any\nreal `b₁ < b₂`, we have `(fun z ↦ z ^ a₁ * exp (b₁ * z)) =o[l] (fun z ↦ z ^ a₂ * exp (b₂ * z))`. -/\ntheorem isLittleO_cpow_mul_exp {b₁ b₂ : ℝ} (hl : IsExpCmpFilter l) (hb : b₁ < b₂) (a₁ a₂ : ℂ) :\n    (fun z => z ^ a₁ * exp (b₁ * z)) =o[l] fun z => z ^ a₂ * exp (b₂ * z) :=\n  calc\n    (fun z => z ^ a₁ * exp (b₁ * z)) =ᶠ[l] fun z => z ^ a₂ * exp (b₁ * z) * z ^ (a₁ - a₂) :=\n      hl.eventually_ne.mono fun z hz => by\n        simp only\n        rw [mul_right_comm, ← cpow_add _ _ hz, add_sub_cancel]\n    _ =o[l] fun z => z ^ a₂ * exp (b₁ * z) * exp (↑(b₂ - b₁) * z) :=\n      ((isBigO_refl (fun z => z ^ a₂ * exp (b₁ * z)) l).mul_isLittleO <|\n        hl.isLittleO_cpow_exp _ (sub_pos.2 hb))\n    _ =ᶠ[l] fun z => z ^ a₂ * exp (b₂ * z) := by\n      simp only [ofReal_sub, sub_mul, mul_assoc, ← exp_add, add_sub_cancel]\n      norm_cast\n\n"}
{"name":"Complex.IsExpCmpFilter.isLittleO_exp_cpow","module":"Mathlib.Analysis.SpecialFunctions.CompareExp","initialProofState":"l : Filter Complex\nhl : Complex.IsExpCmpFilter l\na : Complex\nb : Real\nhb : LT.lt b 0\n⊢ Asymptotics.IsLittleO l (fun z => Complex.exp (HMul.hMul (↑b) z)) fun z => HPow.hPow z a","decl":"/-- If `l : Filter ℂ` is an \"exponential comparison filter\", then for any complex `a` and any\nnegative real `b`, we have `(fun z ↦ exp (b * z)) =o[l] (fun z ↦ z ^ a)`. -/\ntheorem isLittleO_exp_cpow (hl : IsExpCmpFilter l) (a : ℂ) {b : ℝ} (hb : b < 0) :\n    (fun z => exp (b * z)) =o[l] fun z => z ^ a := by simpa using hl.isLittleO_cpow_mul_exp hb 0 a\n\n"}
{"name":"Complex.IsExpCmpFilter.isLittleO_pow_mul_exp","module":"Mathlib.Analysis.SpecialFunctions.CompareExp","initialProofState":"l : Filter Complex\nb₁ b₂ : Real\nhl : Complex.IsExpCmpFilter l\nhb : LT.lt b₁ b₂\nm n : Nat\n⊢ Asymptotics.IsLittleO l (fun z => HMul.hMul (HPow.hPow z m) (Complex.exp (HMul.hMul (↑b₁) z))) fun z => HMul.hMul (HPow.hPow z n) (Complex.exp (HMul.hMul (↑b₂) z))","decl":"/-- If `l : Filter ℂ` is an \"exponential comparison filter\", then for any complex `a₁`, `a₂` and any\nnatural `b₁ < b₂`, we have\n`(fun z ↦ z ^ a₁ * exp (b₁ * z)) =o[l] (fun z ↦ z ^ a₂ * exp (b₂ * z))`. -/\ntheorem isLittleO_pow_mul_exp {b₁ b₂ : ℝ} (hl : IsExpCmpFilter l) (hb : b₁ < b₂) (m n : ℕ) :\n    (fun z => z ^ m * exp (b₁ * z)) =o[l] fun z => z ^ n * exp (b₂ * z) := by\n  simpa only [cpow_natCast] using hl.isLittleO_cpow_mul_exp hb m n\n\n"}
{"name":"Complex.IsExpCmpFilter.isLittleO_zpow_mul_exp","module":"Mathlib.Analysis.SpecialFunctions.CompareExp","initialProofState":"l : Filter Complex\nb₁ b₂ : Real\nhl : Complex.IsExpCmpFilter l\nhb : LT.lt b₁ b₂\nm n : Int\n⊢ Asymptotics.IsLittleO l (fun z => HMul.hMul (HPow.hPow z m) (Complex.exp (HMul.hMul (↑b₁) z))) fun z => HMul.hMul (HPow.hPow z n) (Complex.exp (HMul.hMul (↑b₂) z))","decl":"/-- If `l : Filter ℂ` is an \"exponential comparison filter\", then for any complex `a₁`, `a₂` and any\ninteger `b₁ < b₂`, we have\n`(fun z ↦ z ^ a₁ * exp (b₁ * z)) =o[l] (fun z ↦ z ^ a₂ * exp (b₂ * z))`. -/\ntheorem isLittleO_zpow_mul_exp {b₁ b₂ : ℝ} (hl : IsExpCmpFilter l) (hb : b₁ < b₂) (m n : ℤ) :\n    (fun z => z ^ m * exp (b₁ * z)) =o[l] fun z => z ^ n * exp (b₂ * z) := by\n  simpa only [cpow_intCast] using hl.isLittleO_cpow_mul_exp hb m n\n\n"}
