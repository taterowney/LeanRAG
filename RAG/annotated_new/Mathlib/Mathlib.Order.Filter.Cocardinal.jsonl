{"name":"Filter.mem_cocardinal","module":"Mathlib.Order.Filter.Cocardinal","initialProofState":"Œ± : Type u\nc : Cardinal.{u}\nhreg : c.IsRegular\ns : Set Œ±\n‚ä¢ Iff (Membership.mem (Filter.cocardinal Œ± hreg) s) (LT.lt (Cardinal.mk ‚Üë(HasCompl.compl s)) c)","decl":"@[simp]\ntheorem mem_cocardinal {s : Set Œ±} :\n    s ‚àà cocardinal Œ± hreg ‚Üî Cardinal.mk (s·∂ú : Set Œ±) < c := Iff.rfl\n\n"}
{"name":"Filter.cocardinal_aleph0_eq_cofinite","module":"Mathlib.Order.Filter.Cocardinal","initialProofState":"Œ± : Type u\n‚ä¢ Eq (Filter.cocardinal Œ± Cardinal.isRegular_aleph0) Filter.cofinite","decl":"@[simp] lemma cocardinal_aleph0_eq_cofinite :\n    cocardinal (Œ± := Œ±) isRegular_aleph0 = cofinite := by\n  aesop\n\n"}
{"name":"Filter.instCardinalInterFilter_cocardinal","module":"Mathlib.Order.Filter.Cocardinal","initialProofState":"Œ± : Type u\nc : Cardinal.{u}\nhreg : c.IsRegular\n‚ä¢ CardinalInterFilter (Filter.cocardinal Œ± hreg) c","decl":"instance instCardinalInterFilter_cocardinal : CardinalInterFilter (cocardinal (Œ± := Œ±) hreg) c where\n  cardinal_sInter_mem S hS hSs := by\n    rw [mem_cocardinal, Set.compl_sInter]\n    apply lt_of_le_of_lt (mk_sUnion_le _)\n    apply mul_lt_of_lt hreg.aleph0_le (lt_of_le_of_lt mk_image_le hS)\n    apply iSup_lt_of_isRegular hreg <| lt_of_le_of_lt mk_image_le hS\n    aesop\n\n"}
{"name":"Filter.eventually_cocardinal","module":"Mathlib.Order.Filter.Cocardinal","initialProofState":"Œ± : Type u\nc : Cardinal.{u}\nhreg : c.IsRegular\np : Œ± ‚Üí Prop\n‚ä¢ Iff (Filter.Eventually (fun x => p x) (Filter.cocardinal Œ± hreg)) (LT.lt (Cardinal.mk ‚Üë(setOf fun x => Not (p x))) c)","decl":"@[simp]\ntheorem eventually_cocardinal {p : Œ± ‚Üí Prop} :\n    (‚àÄ·∂† x in cocardinal Œ± hreg, p x) ‚Üî #{ x | ¬¨p x } < c := Iff.rfl\n\n"}
{"name":"Filter.hasBasis_cocardinal","module":"Mathlib.Order.Filter.Cocardinal","initialProofState":"Œ± : Type u\nc : Cardinal.{u}\nhreg : c.IsRegular\n‚ä¢ (Filter.cocardinal Œ± hreg).HasBasis (setOf fun s => LT.lt (Cardinal.mk ‚Üës) c) HasCompl.compl","decl":"theorem hasBasis_cocardinal : HasBasis (cocardinal Œ± hreg) {s : Set Œ± | #s < c} compl :=\n  ‚ü®fun s =>\n    ‚ü®fun h => ‚ü®s·∂ú, h, (compl_compl s).subset‚ü©, fun ‚ü®_t, htf, hts‚ü© => by\n      have : #‚Üës·∂ú < c := by\n        apply lt_of_le_of_lt _ htf\n        rw [compl_subset_comm] at hts\n        apply Cardinal.mk_le_mk_of_subset hts\n      simp_all only [mem_cocardinal] ‚ü©‚ü©\n\n"}
{"name":"Filter.frequently_cocardinal","module":"Mathlib.Order.Filter.Cocardinal","initialProofState":"Œ± : Type u\nc : Cardinal.{u}\nhreg : c.IsRegular\np : Œ± ‚Üí Prop\n‚ä¢ Iff (Filter.Frequently (fun x => p x) (Filter.cocardinal Œ± hreg)) (LE.le c (Cardinal.mk ‚Üë(setOf fun x => p x)))","decl":"theorem frequently_cocardinal {p : Œ± ‚Üí Prop} :\n    (‚àÉ·∂† x in cocardinal Œ± hreg, p x) ‚Üî c ‚â§ # { x | p x } := by\n  simp only [Filter.Frequently, eventually_cocardinal, not_not,coe_setOf, not_lt]\n\n"}
{"name":"Filter.frequently_cocardinal_mem","module":"Mathlib.Order.Filter.Cocardinal","initialProofState":"Œ± : Type u\nc : Cardinal.{u}\nhreg : c.IsRegular\ns : Set Œ±\n‚ä¢ Iff (Filter.Frequently (fun x => Membership.mem s x) (Filter.cocardinal Œ± hreg)) (LE.le c (Cardinal.mk ‚Üës))","decl":"lemma frequently_cocardinal_mem {s : Set Œ±} :\n    (‚àÉ·∂† x in cocardinal Œ± hreg, x ‚àà s) ‚Üî c ‚â§ #s := frequently_cocardinal\n\n"}
{"name":"Filter.cocardinal_inf_principal_neBot_iff","module":"Mathlib.Order.Filter.Cocardinal","initialProofState":"Œ± : Type u\nc : Cardinal.{u}\nhreg : c.IsRegular\ns : Set Œ±\n‚ä¢ Iff (Min.min (Filter.cocardinal Œ± hreg) (Filter.principal s)).NeBot (LE.le c (Cardinal.mk ‚Üës))","decl":"@[simp]\nlemma cocardinal_inf_principal_neBot_iff {s : Set Œ±} :\n    (cocardinal Œ± hreg ‚äì ùìü s).NeBot ‚Üî c ‚â§ #s :=\n  frequently_mem_iff_neBot.symm.trans frequently_cocardinal\n\n"}
{"name":"Filter.compl_mem_cocardinal_of_card_lt","module":"Mathlib.Order.Filter.Cocardinal","initialProofState":"Œ± : Type u\nc : Cardinal.{u}\nhreg : c.IsRegular\ns : Set Œ±\nhs : LT.lt (Cardinal.mk ‚Üës) c\n‚ä¢ Membership.mem (Filter.cocardinal Œ± hreg) (HasCompl.compl s)","decl":"theorem compl_mem_cocardinal_of_card_lt {s : Set Œ±} (hs : #s < c) :\n    s·∂ú ‚àà cocardinal Œ± hreg :=\n  mem_cocardinal.2 <| (compl_compl s).symm ‚ñ∏ hs\n\n"}
{"name":"Set.Finite.compl_mem_cocardinal","module":"Mathlib.Order.Filter.Cocardinal","initialProofState":"Œ± : Type u\nc : Cardinal.{u}\nhreg : c.IsRegular\ns : Set Œ±\nhs : s.Finite\n‚ä¢ Membership.mem (Filter.cocardinal Œ± hreg) (HasCompl.compl s)","decl":"theorem _root_.Set.Finite.compl_mem_cocardinal {s : Set Œ±} (hs : s.Finite) :\n    s·∂ú ‚àà cocardinal Œ± hreg :=\n  compl_mem_cocardinal_of_card_lt <| lt_of_lt_of_le (Finite.lt_aleph0 hs) (hreg.aleph0_le)\n\n"}
{"name":"Filter.eventually_cocardinal_nmem_of_card_lt","module":"Mathlib.Order.Filter.Cocardinal","initialProofState":"Œ± : Type u\nc : Cardinal.{u}\nhreg : c.IsRegular\ns : Set Œ±\nhs : LT.lt (Cardinal.mk ‚Üës) c\n‚ä¢ Filter.Eventually (fun x => Not (Membership.mem s x)) (Filter.cocardinal Œ± hreg)","decl":"theorem eventually_cocardinal_nmem_of_card_lt  {s : Set Œ±} (hs : #s < c) :\n    ‚àÄ·∂† x in cocardinal Œ± hreg, x ‚àâ s :=\n  compl_mem_cocardinal_of_card_lt hs\n\n"}
{"name":"Finset.eventually_cocardinal_nmem","module":"Mathlib.Order.Filter.Cocardinal","initialProofState":"Œ± : Type u\nc : Cardinal.{u}\nhreg : c.IsRegular\ns : Finset Œ±\n‚ä¢ Filter.Eventually (fun x => Not (Membership.mem s x)) (Filter.cocardinal Œ± hreg)","decl":"theorem _root_.Finset.eventually_cocardinal_nmem (s : Finset Œ±) :\n    ‚àÄ·∂† x in cocardinal Œ± hreg, x ‚àâ s :=\n  eventually_cocardinal_nmem_of_card_lt <| lt_of_lt_of_le (finset_card_lt_aleph0 s) (hreg.aleph0_le)\n\n"}
{"name":"Filter.eventually_cocardinal_ne","module":"Mathlib.Order.Filter.Cocardinal","initialProofState":"Œ± : Type u\nc : Cardinal.{u}\nhreg : c.IsRegular\nx : Œ±\n‚ä¢ Filter.Eventually (fun a => Ne a x) (Filter.cocardinal Œ± hreg)","decl":"theorem eventually_cocardinal_ne (x : Œ±) : ‚àÄ·∂† a in cocardinal Œ± hreg, a ‚â† x := by\n  simpa [Set.finite_singleton x] using hreg.nat_lt 1\n\n"}
{"name":"Filter.mem_cocountable","module":"Mathlib.Order.Filter.Cocardinal","initialProofState":"Œ± : Type u\ns : Set Œ±\n‚ä¢ Iff (Membership.mem Filter.cocountable s) (HasCompl.compl s).Countable","decl":"theorem mem_cocountable {s : Set Œ±} :\n    s ‚àà cocountable ‚Üî (s·∂ú : Set Œ±).Countable := by\n  rw [Cardinal.countable_iff_lt_aleph_one, mem_cocardinal]\n\n"}
